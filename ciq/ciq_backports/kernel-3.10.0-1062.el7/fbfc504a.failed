bpf: introduce new bpf AF_XDP map type BPF_MAP_TYPE_XSKMAP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Björn Töpel <bjorn.topel@intel.com>
commit fbfc504a24f53f7ebe128ab55cb5dba634f4ece8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fbfc504a.failed

The xskmap is yet another BPF map, very much inspired by
dev/cpu/sockmap, and is a holder of AF_XDP sockets. A user application
adds AF_XDP sockets into the map, and by using the bpf_redirect_map
helper, an XDP program can redirect XDP frames to an AF_XDP socket.

Note that a socket that is bound to certain ifindex/queue index will
*only* accept XDP frames from that netdev/queue index. If an XDP
program tries to redirect from a netdev/queue index other than what
the socket is bound to, the frame will not be received on the socket.

A socket can reside in multiple maps.

v3: Fixed race and simplified code.
v2: Removed one indirection in map lookup.

	Signed-off-by: Björn Töpel <bjorn.topel@intel.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit fbfc504a24f53f7ebe128ab55cb5dba634f4ece8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	include/linux/bpf_types.h
#	include/net/xdp_sock.h
#	include/uapi/linux/bpf.h
#	kernel/bpf/Makefile
#	kernel/bpf/verifier.c
#	net/xdp/xsk.c
diff --cc include/linux/bpf.h
index a13be0886557,68ecdb4eea09..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -460,8 -550,157 +460,119 @@@ static inline int bpf_obj_get_user(cons
  	return -EOPNOTSUPP;
  }
  
 -static inline struct net_device  *__dev_map_lookup_elem(struct bpf_map *map,
 -						       u32 key)
 -{
 -	return NULL;
 -}
 -
 -static inline void __dev_map_insert_ctx(struct bpf_map *map, u32 index)
 -{
 -}
 -
 -static inline void __dev_map_flush(struct bpf_map *map)
 -{
 -}
 -
 -static inline
 -struct bpf_cpu_map_entry *__cpu_map_lookup_elem(struct bpf_map *map, u32 key)
 -{
 -	return NULL;
 -}
 -
 -static inline void __cpu_map_insert_ctx(struct bpf_map *map, u32 index)
 -{
 -}
 -
 -static inline void __cpu_map_flush(struct bpf_map *map)
 -{
 -}
 -
 -struct xdp_buff;
 -static inline int cpu_map_enqueue(struct bpf_cpu_map_entry *rcpu,
 -				  struct xdp_buff *xdp,
 -				  struct net_device *dev_rx)
 -{
 -	return 0;
 -}
 -
 -static inline struct bpf_prog *bpf_prog_get_type_path(const char *name,
 -				enum bpf_prog_type type)
 -{
 -	return ERR_PTR(-EOPNOTSUPP);
 -}
  #endif /* CONFIG_BPF_SYSCALL */
  
++<<<<<<< HEAD
++=======
+ static inline struct bpf_prog *bpf_prog_get_type(u32 ufd,
+ 						 enum bpf_prog_type type)
+ {
+ 	return bpf_prog_get_type_dev(ufd, type, false);
+ }
+ 
+ bool bpf_prog_get_ok(struct bpf_prog *, enum bpf_prog_type *, bool);
+ 
+ int bpf_prog_offload_compile(struct bpf_prog *prog);
+ void bpf_prog_offload_destroy(struct bpf_prog *prog);
+ int bpf_prog_offload_info_fill(struct bpf_prog_info *info,
+ 			       struct bpf_prog *prog);
+ 
+ int bpf_map_offload_info_fill(struct bpf_map_info *info, struct bpf_map *map);
+ 
+ int bpf_map_offload_lookup_elem(struct bpf_map *map, void *key, void *value);
+ int bpf_map_offload_update_elem(struct bpf_map *map,
+ 				void *key, void *value, u64 flags);
+ int bpf_map_offload_delete_elem(struct bpf_map *map, void *key);
+ int bpf_map_offload_get_next_key(struct bpf_map *map,
+ 				 void *key, void *next_key);
+ 
+ bool bpf_offload_dev_match(struct bpf_prog *prog, struct bpf_map *map);
+ 
+ #if defined(CONFIG_NET) && defined(CONFIG_BPF_SYSCALL)
+ int bpf_prog_offload_init(struct bpf_prog *prog, union bpf_attr *attr);
+ 
+ static inline bool bpf_prog_is_dev_bound(struct bpf_prog_aux *aux)
+ {
+ 	return aux->offload_requested;
+ }
+ 
+ static inline bool bpf_map_is_dev_bound(struct bpf_map *map)
+ {
+ 	return unlikely(map->ops == &bpf_map_offload_ops);
+ }
+ 
+ struct bpf_map *bpf_map_offload_map_alloc(union bpf_attr *attr);
+ void bpf_map_offload_map_free(struct bpf_map *map);
+ #else
+ static inline int bpf_prog_offload_init(struct bpf_prog *prog,
+ 					union bpf_attr *attr)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline bool bpf_prog_is_dev_bound(struct bpf_prog_aux *aux)
+ {
+ 	return false;
+ }
+ 
+ static inline bool bpf_map_is_dev_bound(struct bpf_map *map)
+ {
+ 	return false;
+ }
+ 
+ static inline struct bpf_map *bpf_map_offload_map_alloc(union bpf_attr *attr)
+ {
+ 	return ERR_PTR(-EOPNOTSUPP);
+ }
+ 
+ static inline void bpf_map_offload_map_free(struct bpf_map *map)
+ {
+ }
+ #endif /* CONFIG_NET && CONFIG_BPF_SYSCALL */
+ 
+ #if defined(CONFIG_STREAM_PARSER) && defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_INET)
+ struct sock  *__sock_map_lookup_elem(struct bpf_map *map, u32 key);
+ int sock_map_prog(struct bpf_map *map, struct bpf_prog *prog, u32 type);
+ #else
+ static inline struct sock  *__sock_map_lookup_elem(struct bpf_map *map, u32 key)
+ {
+ 	return NULL;
+ }
+ 
+ static inline int sock_map_prog(struct bpf_map *map,
+ 				struct bpf_prog *prog,
+ 				u32 type)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ #endif
+ 
+ #if defined(CONFIG_XDP_SOCKETS)
+ struct xdp_sock;
+ struct xdp_sock *__xsk_map_lookup_elem(struct bpf_map *map, u32 key);
+ int __xsk_map_redirect(struct bpf_map *map, struct xdp_buff *xdp,
+ 		       struct xdp_sock *xs);
+ void __xsk_map_flush(struct bpf_map *map);
+ #else
+ struct xdp_sock;
+ static inline struct xdp_sock *__xsk_map_lookup_elem(struct bpf_map *map,
+ 						     u32 key)
+ {
+ 	return NULL;
+ }
+ 
+ static inline int __xsk_map_redirect(struct bpf_map *map, struct xdp_buff *xdp,
+ 				     struct xdp_sock *xs)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline void __xsk_map_flush(struct bpf_map *map)
+ {
+ }
+ #endif
+ 
++>>>>>>> fbfc504a24f5 (bpf: introduce new bpf AF_XDP map type BPF_MAP_TYPE_XSKMAP)
  /* verifier prototypes for helper functions called from eBPF programs */
  extern const struct bpf_func_proto bpf_map_lookup_elem_proto;
  extern const struct bpf_func_proto bpf_map_update_elem_proto;
diff --cc include/linux/bpf_types.h
index 54729afe45a0,d7df1b323082..000000000000
--- a/include/linux/bpf_types.h
+++ b/include/linux/bpf_types.h
@@@ -30,4 -45,11 +30,14 @@@ BPF_MAP_TYPE(BPF_MAP_TYPE_ARRAY_OF_MAPS
  BPF_MAP_TYPE(BPF_MAP_TYPE_HASH_OF_MAPS, htab_of_maps_map_ops)
  #ifdef CONFIG_NET
  BPF_MAP_TYPE(BPF_MAP_TYPE_DEVMAP, dev_map_ops)
++<<<<<<< HEAD
++=======
+ #if defined(CONFIG_STREAM_PARSER) && defined(CONFIG_INET)
+ BPF_MAP_TYPE(BPF_MAP_TYPE_SOCKMAP, sock_map_ops)
+ #endif
+ BPF_MAP_TYPE(BPF_MAP_TYPE_CPUMAP, cpu_map_ops)
+ #if defined(CONFIG_XDP_SOCKETS)
+ BPF_MAP_TYPE(BPF_MAP_TYPE_XSKMAP, xsk_map_ops)
+ #endif
++>>>>>>> fbfc504a24f5 (bpf: introduce new bpf AF_XDP map type BPF_MAP_TYPE_XSKMAP)
  #endif
diff --cc include/uapi/linux/bpf.h
index 000f5ce2d064,a3a495052511..000000000000
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@@ -111,6 -114,9 +111,12 @@@ enum bpf_map_type 
  	BPF_MAP_TYPE_ARRAY_OF_MAPS,
  	BPF_MAP_TYPE_HASH_OF_MAPS,
  	BPF_MAP_TYPE_DEVMAP,
++<<<<<<< HEAD
++=======
+ 	BPF_MAP_TYPE_SOCKMAP,
+ 	BPF_MAP_TYPE_CPUMAP,
+ 	BPF_MAP_TYPE_XSKMAP,
++>>>>>>> fbfc504a24f5 (bpf: introduce new bpf AF_XDP map type BPF_MAP_TYPE_XSKMAP)
  };
  
  enum bpf_prog_type {
diff --cc kernel/bpf/Makefile
index 35e0ff912437,f27f5496d6fe..000000000000
--- a/kernel/bpf/Makefile
+++ b/kernel/bpf/Makefile
@@@ -3,10 -4,19 +3,23 @@@ obj-y := core.
  obj-$(CONFIG_BPF_SYSCALL) += syscall.o verifier.o inode.o helpers.o tnum.o
  obj-$(CONFIG_BPF_SYSCALL) += hashtab.o arraymap.o percpu_freelist.o bpf_lru_list.o lpm_trie.o map_in_map.o
  obj-$(CONFIG_BPF_SYSCALL) += disasm.o
 -obj-$(CONFIG_BPF_SYSCALL) += btf.o
 +obj-$(CONFIG_BPF_SYSCALL) += socket_filter.o
 +obj-$(CONFIG_BPF_SYSCALL) += sched_cls_act.o
  ifeq ($(CONFIG_NET),y)
  obj-$(CONFIG_BPF_SYSCALL) += devmap.o
++<<<<<<< HEAD
++=======
+ obj-$(CONFIG_BPF_SYSCALL) += cpumap.o
+ ifeq ($(CONFIG_XDP_SOCKETS),y)
+ obj-$(CONFIG_BPF_SYSCALL) += xskmap.o
+ endif
+ obj-$(CONFIG_BPF_SYSCALL) += offload.o
+ ifeq ($(CONFIG_STREAM_PARSER),y)
+ ifeq ($(CONFIG_INET),y)
+ obj-$(CONFIG_BPF_SYSCALL) += sockmap.o
+ endif
+ endif
++>>>>>>> fbfc504a24f5 (bpf: introduce new bpf AF_XDP map type BPF_MAP_TYPE_XSKMAP)
  endif
  ifeq ($(CONFIG_PERF_EVENTS),y)
  obj-$(CONFIG_BPF_SYSCALL) += stackmap.o
diff --cc kernel/bpf/verifier.c
index d6b273f4ee39,0d91f18b2eb5..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -2091,7 -2067,15 +2091,19 @@@ static int check_map_func_compatibility
  	 * for now.
  	 */
  	case BPF_MAP_TYPE_DEVMAP:
++<<<<<<< HEAD
 +		if (func_id == BPF_FUNC_map_lookup_elem)
++=======
+ 		if (func_id != BPF_FUNC_redirect_map)
+ 			goto error;
+ 		break;
+ 	/* Restrict bpf side of cpumap and xskmap, open when use-cases
+ 	 * appear.
+ 	 */
+ 	case BPF_MAP_TYPE_CPUMAP:
+ 	case BPF_MAP_TYPE_XSKMAP:
+ 		if (func_id != BPF_FUNC_redirect_map)
++>>>>>>> fbfc504a24f5 (bpf: introduce new bpf AF_XDP map type BPF_MAP_TYPE_XSKMAP)
  			goto error;
  		break;
  	case BPF_MAP_TYPE_ARRAY_OF_MAPS:
@@@ -2122,6 -2114,26 +2134,29 @@@
  		if (map->map_type != BPF_MAP_TYPE_STACK_TRACE)
  			goto error;
  		break;
++<<<<<<< HEAD
++=======
+ 	case BPF_FUNC_current_task_under_cgroup:
+ 	case BPF_FUNC_skb_under_cgroup:
+ 		if (map->map_type != BPF_MAP_TYPE_CGROUP_ARRAY)
+ 			goto error;
+ 		break;
+ 	case BPF_FUNC_redirect_map:
+ 		if (map->map_type != BPF_MAP_TYPE_DEVMAP &&
+ 		    map->map_type != BPF_MAP_TYPE_CPUMAP &&
+ 		    map->map_type != BPF_MAP_TYPE_XSKMAP)
+ 			goto error;
+ 		break;
+ 	case BPF_FUNC_sk_redirect_map:
+ 	case BPF_FUNC_msg_redirect_map:
+ 		if (map->map_type != BPF_MAP_TYPE_SOCKMAP)
+ 			goto error;
+ 		break;
+ 	case BPF_FUNC_sock_map_update:
+ 		if (map->map_type != BPF_MAP_TYPE_SOCKMAP)
+ 			goto error;
+ 		break;
++>>>>>>> fbfc504a24f5 (bpf: introduce new bpf AF_XDP map type BPF_MAP_TYPE_XSKMAP)
  	default:
  		break;
  	}
* Unmerged path include/net/xdp_sock.h
* Unmerged path net/xdp/xsk.c
* Unmerged path include/linux/bpf.h
* Unmerged path include/linux/bpf_types.h
* Unmerged path include/net/xdp_sock.h
* Unmerged path include/uapi/linux/bpf.h
* Unmerged path kernel/bpf/Makefile
* Unmerged path kernel/bpf/verifier.c
diff --git a/kernel/bpf/xskmap.c b/kernel/bpf/xskmap.c
new file mode 100644
index 000000000000..869dbb11b612
--- /dev/null
+++ b/kernel/bpf/xskmap.c
@@ -0,0 +1,239 @@
+// SPDX-License-Identifier: GPL-2.0
+/* XSKMAP used for AF_XDP sockets
+ * Copyright(c) 2018 Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/bpf.h>
+#include <linux/capability.h>
+#include <net/xdp_sock.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+
+struct xsk_map {
+	struct bpf_map map;
+	struct xdp_sock **xsk_map;
+	struct list_head __percpu *flush_list;
+};
+
+static struct bpf_map *xsk_map_alloc(union bpf_attr *attr)
+{
+	int cpu, err = -EINVAL;
+	struct xsk_map *m;
+	u64 cost;
+
+	if (!capable(CAP_NET_ADMIN))
+		return ERR_PTR(-EPERM);
+
+	if (attr->max_entries == 0 || attr->key_size != 4 ||
+	    attr->value_size != 4 ||
+	    attr->map_flags & ~(BPF_F_NUMA_NODE | BPF_F_RDONLY | BPF_F_WRONLY))
+		return ERR_PTR(-EINVAL);
+
+	m = kzalloc(sizeof(*m), GFP_USER);
+	if (!m)
+		return ERR_PTR(-ENOMEM);
+
+	bpf_map_init_from_attr(&m->map, attr);
+
+	cost = (u64)m->map.max_entries * sizeof(struct xdp_sock *);
+	cost += sizeof(struct list_head) * num_possible_cpus();
+	if (cost >= U32_MAX - PAGE_SIZE)
+		goto free_m;
+
+	m->map.pages = round_up(cost, PAGE_SIZE) >> PAGE_SHIFT;
+
+	/* Notice returns -EPERM on if map size is larger than memlock limit */
+	err = bpf_map_precharge_memlock(m->map.pages);
+	if (err)
+		goto free_m;
+
+	m->flush_list = alloc_percpu(struct list_head);
+	if (!m->flush_list)
+		goto free_m;
+
+	for_each_possible_cpu(cpu)
+		INIT_LIST_HEAD(per_cpu_ptr(m->flush_list, cpu));
+
+	m->xsk_map = bpf_map_area_alloc(m->map.max_entries *
+					sizeof(struct xdp_sock *),
+					m->map.numa_node);
+	if (!m->xsk_map)
+		goto free_percpu;
+	return &m->map;
+
+free_percpu:
+	free_percpu(m->flush_list);
+free_m:
+	kfree(m);
+	return ERR_PTR(err);
+}
+
+static void xsk_map_free(struct bpf_map *map)
+{
+	struct xsk_map *m = container_of(map, struct xsk_map, map);
+	int i;
+
+	synchronize_net();
+
+	for (i = 0; i < map->max_entries; i++) {
+		struct xdp_sock *xs;
+
+		xs = m->xsk_map[i];
+		if (!xs)
+			continue;
+
+		sock_put((struct sock *)xs);
+	}
+
+	free_percpu(m->flush_list);
+	bpf_map_area_free(m->xsk_map);
+	kfree(m);
+}
+
+static int xsk_map_get_next_key(struct bpf_map *map, void *key, void *next_key)
+{
+	struct xsk_map *m = container_of(map, struct xsk_map, map);
+	u32 index = key ? *(u32 *)key : U32_MAX;
+	u32 *next = next_key;
+
+	if (index >= m->map.max_entries) {
+		*next = 0;
+		return 0;
+	}
+
+	if (index == m->map.max_entries - 1)
+		return -ENOENT;
+	*next = index + 1;
+	return 0;
+}
+
+struct xdp_sock *__xsk_map_lookup_elem(struct bpf_map *map, u32 key)
+{
+	struct xsk_map *m = container_of(map, struct xsk_map, map);
+	struct xdp_sock *xs;
+
+	if (key >= map->max_entries)
+		return NULL;
+
+	xs = READ_ONCE(m->xsk_map[key]);
+	return xs;
+}
+
+int __xsk_map_redirect(struct bpf_map *map, struct xdp_buff *xdp,
+		       struct xdp_sock *xs)
+{
+	struct xsk_map *m = container_of(map, struct xsk_map, map);
+	struct list_head *flush_list = this_cpu_ptr(m->flush_list);
+	int err;
+
+	err = xsk_rcv(xs, xdp);
+	if (err)
+		return err;
+
+	if (!xs->flush_node.prev)
+		list_add(&xs->flush_node, flush_list);
+
+	return 0;
+}
+
+void __xsk_map_flush(struct bpf_map *map)
+{
+	struct xsk_map *m = container_of(map, struct xsk_map, map);
+	struct list_head *flush_list = this_cpu_ptr(m->flush_list);
+	struct xdp_sock *xs, *tmp;
+
+	list_for_each_entry_safe(xs, tmp, flush_list, flush_node) {
+		xsk_flush(xs);
+		__list_del(xs->flush_node.prev, xs->flush_node.next);
+		xs->flush_node.prev = NULL;
+	}
+}
+
+static void *xsk_map_lookup_elem(struct bpf_map *map, void *key)
+{
+	return NULL;
+}
+
+static int xsk_map_update_elem(struct bpf_map *map, void *key, void *value,
+			       u64 map_flags)
+{
+	struct xsk_map *m = container_of(map, struct xsk_map, map);
+	u32 i = *(u32 *)key, fd = *(u32 *)value;
+	struct xdp_sock *xs, *old_xs;
+	struct socket *sock;
+	int err;
+
+	if (unlikely(map_flags > BPF_EXIST))
+		return -EINVAL;
+	if (unlikely(i >= m->map.max_entries))
+		return -E2BIG;
+	if (unlikely(map_flags == BPF_NOEXIST))
+		return -EEXIST;
+
+	sock = sockfd_lookup(fd, &err);
+	if (!sock)
+		return err;
+
+	if (sock->sk->sk_family != PF_XDP) {
+		sockfd_put(sock);
+		return -EOPNOTSUPP;
+	}
+
+	xs = (struct xdp_sock *)sock->sk;
+
+	if (!xsk_is_setup_for_bpf_map(xs)) {
+		sockfd_put(sock);
+		return -EOPNOTSUPP;
+	}
+
+	sock_hold(sock->sk);
+
+	old_xs = xchg(&m->xsk_map[i], xs);
+	if (old_xs) {
+		/* Make sure we've flushed everything. */
+		synchronize_net();
+		sock_put((struct sock *)old_xs);
+	}
+
+	sockfd_put(sock);
+	return 0;
+}
+
+static int xsk_map_delete_elem(struct bpf_map *map, void *key)
+{
+	struct xsk_map *m = container_of(map, struct xsk_map, map);
+	struct xdp_sock *old_xs;
+	int k = *(u32 *)key;
+
+	if (k >= map->max_entries)
+		return -EINVAL;
+
+	old_xs = xchg(&m->xsk_map[k], NULL);
+	if (old_xs) {
+		/* Make sure we've flushed everything. */
+		synchronize_net();
+		sock_put((struct sock *)old_xs);
+	}
+
+	return 0;
+}
+
+const struct bpf_map_ops xsk_map_ops = {
+	.map_alloc = xsk_map_alloc,
+	.map_free = xsk_map_free,
+	.map_get_next_key = xsk_map_get_next_key,
+	.map_lookup_elem = xsk_map_lookup_elem,
+	.map_update_elem = xsk_map_update_elem,
+	.map_delete_elem = xsk_map_delete_elem,
+};
+
+
* Unmerged path net/xdp/xsk.c
