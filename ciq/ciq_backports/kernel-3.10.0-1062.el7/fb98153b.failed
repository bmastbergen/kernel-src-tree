IB/mlx5: Enforce DEVX privilege by firmware

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Yishai Hadas <yishaih@mellanox.com>
commit fb98153bbf28b627fe52f41e658ae39fa67d2684
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fb98153b.failed

Enforce DEVX privilege by firmware, this enables future device
functionality without the need to make driver changes unless a new
privilege type will be introduced.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Reviewed-by: Artemy Kovalyov <artemyko@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit fb98153bbf28b627fe52f41e658ae39fa67d2684)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
#	drivers/infiniband/hw/mlx5/main.c
#	drivers/infiniband/hw/mlx5/mlx5_ib.h
diff --cc drivers/infiniband/hw/mlx5/main.c
index e944c3c2b419,2b09e6896e5a..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -1737,9 -1762,17 +1737,21 @@@ static struct ib_ucontext *mlx5_ib_allo
  	context->ibucontext.invalidate_range = &mlx5_ib_invalidate_range;
  #endif
  
++<<<<<<< HEAD
 +	err = mlx5_ib_alloc_transport_domain(dev, &context->tdn);
++=======
+ 	if (req.flags & MLX5_IB_ALLOC_UCTX_DEVX) {
+ 		err = mlx5_ib_devx_create(dev, true);
+ 		if (err < 0)
+ 			goto out_uars;
+ 		context->devx_uid = err;
+ 	}
+ 
+ 	err = mlx5_ib_alloc_transport_domain(dev, &context->tdn,
+ 					     context->devx_uid);
++>>>>>>> fb98153bbf28 (IB/mlx5: Enforce DEVX privilege by firmware)
  	if (err)
 -		goto out_devx;
 +		goto out_uars;
  
  	if (MLX5_CAP_GEN(dev->mdev, dump_fill_mkey)) {
  		err = mlx5_cmd_dump_fill_mkey(dev->mdev, &dump_fill_mkey);
@@@ -5296,9 -6218,37 +5308,43 @@@ static void mlx5_ib_stage_rep_reg_clean
  	mlx5_ib_unregister_vport_reps(dev);
  }
  
++<<<<<<< HEAD
 +static void __mlx5_ib_remove(struct mlx5_ib_dev *dev,
 +			     const struct mlx5_ib_profile *profile,
 +			     int stage)
++=======
+ static int mlx5_ib_stage_dev_notifier_init(struct mlx5_ib_dev *dev)
+ {
+ 	dev->mdev_events.notifier_call = mlx5_ib_event;
+ 	mlx5_notifier_register(dev->mdev, &dev->mdev_events);
+ 	return 0;
+ }
+ 
+ static void mlx5_ib_stage_dev_notifier_cleanup(struct mlx5_ib_dev *dev)
+ {
+ 	mlx5_notifier_unregister(dev->mdev, &dev->mdev_events);
+ }
+ 
+ static int mlx5_ib_stage_devx_init(struct mlx5_ib_dev *dev)
+ {
+ 	int uid;
+ 
+ 	uid = mlx5_ib_devx_create(dev, false);
+ 	if (uid > 0)
+ 		dev->devx_whitelist_uid = uid;
+ 
+ 	return 0;
+ }
+ static void mlx5_ib_stage_devx_cleanup(struct mlx5_ib_dev *dev)
+ {
+ 	if (dev->devx_whitelist_uid)
+ 		mlx5_ib_devx_destroy(dev, dev->devx_whitelist_uid);
+ }
+ 
+ void __mlx5_ib_remove(struct mlx5_ib_dev *dev,
+ 		      const struct mlx5_ib_profile *profile,
+ 		      int stage)
++>>>>>>> fb98153bbf28 (IB/mlx5: Enforce DEVX privilege by firmware)
  {
  	/* Number of stages to cleanup */
  	while (stage) {
diff --cc drivers/infiniband/hw/mlx5/mlx5_ib.h
index 3c57e5c58ad3,4d33965369cc..000000000000
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@@ -1092,6 -1267,36 +1092,39 @@@ struct mlx5_core_dev *mlx5_ib_get_nativ
  void mlx5_ib_put_native_port_mdev(struct mlx5_ib_dev *dev,
  				  u8 port_num);
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_INFINIBAND_USER_ACCESS)
+ int mlx5_ib_devx_create(struct mlx5_ib_dev *dev, bool is_user);
+ void mlx5_ib_devx_destroy(struct mlx5_ib_dev *dev, u16 uid);
+ const struct uverbs_object_tree_def *mlx5_ib_get_devx_tree(void);
+ extern const struct uapi_definition mlx5_ib_devx_defs[];
+ extern const struct uapi_definition mlx5_ib_flow_defs[];
+ struct mlx5_ib_flow_handler *mlx5_ib_raw_fs_rule_add(
+ 	struct mlx5_ib_dev *dev, struct mlx5_ib_flow_matcher *fs_matcher,
+ 	struct mlx5_flow_act *flow_act, u32 counter_id,
+ 	void *cmd_in, int inlen, int dest_id, int dest_type);
+ bool mlx5_ib_devx_is_flow_dest(void *obj, int *dest_id, int *dest_type);
+ bool mlx5_ib_devx_is_flow_counter(void *obj, u32 *counter_id);
+ int mlx5_ib_get_flow_trees(const struct uverbs_object_tree_def **root);
+ void mlx5_ib_destroy_flow_action_raw(struct mlx5_ib_flow_action *maction);
+ #else
+ static inline int
+ mlx5_ib_devx_create(struct mlx5_ib_dev *dev,
+ 			   bool is_user) { return -EOPNOTSUPP; }
+ static inline void mlx5_ib_devx_destroy(struct mlx5_ib_dev *dev, u16 uid) {}
+ static inline bool mlx5_ib_devx_is_flow_dest(void *obj, int *dest_id,
+ 					     int *dest_type)
+ {
+ 	return false;
+ }
+ static inline void
+ mlx5_ib_destroy_flow_action_raw(struct mlx5_ib_flow_action *maction)
+ {
+ 	return;
+ };
+ #endif
++>>>>>>> fb98153bbf28 (IB/mlx5: Enforce DEVX privilege by firmware)
  static inline void init_query_mad(struct ib_smp *mad)
  {
  	mad->base_version  = 1;
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path drivers/infiniband/hw/mlx5/mlx5_ib.h
