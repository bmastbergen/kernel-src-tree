ipv6: enforce egress device match in per table nexthop lookups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Paolo Abeni <pabeni@redhat.com>
commit 48f1dcb55a7d29aeb8965c567660c14d0dfd1a42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/48f1dcb5.failed

with the commit 8c14586fc320 ("net: ipv6: Use passed in table for
nexthop lookups"), net hop lookup is first performed on route creation
in the passed-in table.
However device match is not enforced in table lookup, so the found
route can be later discarded due to egress device mismatch and no
global lookup will be performed.
This cause the following to fail:

ip link add dummy1 type dummy
ip link add dummy2 type dummy
ip link set dummy1 up
ip link set dummy2 up
ip route add 2001:db8:8086::/48 dev dummy1 metric 20
ip route add 2001:db8:d34d::/64 via 2001:db8:8086::2 dev dummy1 metric 20
ip route add 2001:db8:8086::/48 dev dummy2 metric 21
ip route add 2001:db8:d34d::/64 via 2001:db8:8086::2 dev dummy2 metric 21
RTNETLINK answers: No route to host

This change fixes the issue enforcing device lookup in
ip6_nh_lookup_table()

v1->v2: updated commit message title

Fixes: 8c14586fc320 ("net: ipv6: Use passed in table for nexthop lookups")
Reported-and-tested-by: Beniamino Galvani <bgalvani@redhat.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Acked-by: David Ahern <dsa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 48f1dcb55a7d29aeb8965c567660c14d0dfd1a42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/route.c
diff --cc net/ipv6/route.c
index 9ee2312eaf73,520b7884d0c2..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -1772,9 -1771,39 +1772,44 @@@ static int ip6_convert_metrics(struct m
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
 +int ip6_route_info_create(struct fib6_config *cfg, struct rt6_info **rt_ret)
++=======
+ static struct rt6_info *ip6_nh_lookup_table(struct net *net,
+ 					    struct fib6_config *cfg,
+ 					    const struct in6_addr *gw_addr)
+ {
+ 	struct flowi6 fl6 = {
+ 		.flowi6_oif = cfg->fc_ifindex,
+ 		.daddr = *gw_addr,
+ 		.saddr = cfg->fc_prefsrc,
+ 	};
+ 	struct fib6_table *table;
+ 	struct rt6_info *rt;
+ 	int flags = RT6_LOOKUP_F_IFACE;
+ 
+ 	table = fib6_get_table(net, cfg->fc_table);
+ 	if (!table)
+ 		return NULL;
+ 
+ 	if (!ipv6_addr_any(&cfg->fc_prefsrc))
+ 		flags |= RT6_LOOKUP_F_HAS_SADDR;
+ 
+ 	rt = ip6_pol_route(net, table, cfg->fc_ifindex, &fl6, flags);
+ 
+ 	/* if table lookup failed, fall back to full lookup */
+ 	if (rt == net->ipv6.ip6_null_entry) {
+ 		ip6_rt_put(rt);
+ 		rt = NULL;
+ 	}
+ 
+ 	return rt;
+ }
+ 
+ static struct rt6_info *ip6_route_info_create(struct fib6_config *cfg)
++>>>>>>> 48f1dcb55a7d (ipv6: enforce egress device match in per table nexthop lookups)
  {
 +	int err;
  	struct net *net = cfg->fc_nlinfo.nl_net;
  	struct rt6_info *rt = NULL;
  	struct net_device *dev = NULL;
* Unmerged path net/ipv6/route.c
