efi: Fix debugobjects warning on 'efi_rts_work'

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Waiman Long <longman@redhat.com>
commit ef1491e791308317bb9851a0ad380c4a68b58d54
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ef1491e7.failed

The following commit:

  9dbbedaa6171 ("efi: Make efi_rts_work accessible to efi page fault handler")

converted 'efi_rts_work' from an auto variable to a global variable.
However, when submitting the work, INIT_WORK_ONSTACK() was still used,
causing the following complaint from debugobjects:

  ODEBUG: object 00000000ed27b500 is NOT on stack 00000000c7d38760, but annotated.

Change the macro to just INIT_WORK() to eliminate the warning.

	Signed-off-by: Waiman Long <longman@redhat.com>
	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Acked-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
Fixes: 9dbbedaa6171 ("efi: Make efi_rts_work accessible to efi page fault handler")
Link: http://lkml.kernel.org/r/20181114175544.12860-2-ard.biesheuvel@linaro.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit ef1491e791308317bb9851a0ad380c4a68b58d54)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/runtime-wrappers.c
diff --cc drivers/firmware/efi/runtime-wrappers.c
index dcc976822484,8903b9ccfc2b..000000000000
--- a/drivers/firmware/efi/runtime-wrappers.c
+++ b/drivers/firmware/efi/runtime-wrappers.c
@@@ -27,6 -45,50 +27,53 @@@
  #define __efi_call_virt(f, args...) \
  	__efi_call_virt_pointer(efi.systab->runtime, f, args)
  
++<<<<<<< HEAD
++=======
+ struct efi_runtime_work efi_rts_work;
+ 
+ /*
+  * efi_queue_work:	Queue efi_runtime_service() and wait until it's done
+  * @rts:		efi_runtime_service() function identifier
+  * @rts_arg<1-5>:	efi_runtime_service() function arguments
+  *
+  * Accesses to efi_runtime_services() are serialized by a binary
+  * semaphore (efi_runtime_lock) and caller waits until the work is
+  * finished, hence _only_ one work is queued at a time and the caller
+  * thread waits for completion.
+  */
+ #define efi_queue_work(_rts, _arg1, _arg2, _arg3, _arg4, _arg5)		\
+ ({									\
+ 	efi_rts_work.status = EFI_ABORTED;				\
+ 									\
+ 	if (!efi_enabled(EFI_RUNTIME_SERVICES)) {			\
+ 		pr_warn_once("EFI Runtime Services are disabled!\n");	\
+ 		goto exit;						\
+ 	}								\
+ 									\
+ 	init_completion(&efi_rts_work.efi_rts_comp);			\
+ 	INIT_WORK(&efi_rts_work.work, efi_call_rts);			\
+ 	efi_rts_work.arg1 = _arg1;					\
+ 	efi_rts_work.arg2 = _arg2;					\
+ 	efi_rts_work.arg3 = _arg3;					\
+ 	efi_rts_work.arg4 = _arg4;					\
+ 	efi_rts_work.arg5 = _arg5;					\
+ 	efi_rts_work.efi_rts_id = _rts;					\
+ 									\
+ 	/*								\
+ 	 * queue_work() returns 0 if work was already on queue,         \
+ 	 * _ideally_ this should never happen.                          \
+ 	 */								\
+ 	if (queue_work(efi_rts_wq, &efi_rts_work.work))			\
+ 		wait_for_completion(&efi_rts_work.efi_rts_comp);	\
+ 	else								\
+ 		pr_err("Failed to queue work to efi_rts_wq.\n");	\
+ 									\
+ exit:									\
+ 	efi_rts_work.efi_rts_id = NONE;					\
+ 	efi_rts_work.status;						\
+ })
+ 
++>>>>>>> ef1491e79130 (efi: Fix debugobjects warning on 'efi_rts_work')
  void efi_call_virt_check_flags(unsigned long flags, const char *call)
  {
  	unsigned long cur_flags, mismatch;
* Unmerged path drivers/firmware/efi/runtime-wrappers.c
