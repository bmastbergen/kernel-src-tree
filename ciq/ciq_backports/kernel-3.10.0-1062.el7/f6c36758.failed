dm thin: send event about thin-pool state change _after_ making it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Mike Snitzer <snitzer@redhat.com>
commit f6c367585d0d851349d3a9e607c43e5bea993fa1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f6c36758.failed

Sending a DM event before a thin-pool state change is about to happen is
a bug.  It wasn't realized until it became clear that userspace response
to the event raced with the actual state change that the event was
meant to notify about.

Fix this by first updating internal thin-pool state to reflect what the
DM event is being issued about.  This fixes a long-standing racey/buggy
userspace device-mapper-test-suite 'resize_io' test that would get an
event but not find the state it was looking for -- so it would just go
on to hang because no other events caused the test to reevaluate the
thin-pool's state.

	Cc: stable@vger.kernel.org
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit f6c367585d0d851349d3a9e607c43e5bea993fa1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-thin.c
diff --cc drivers/md/dm-thin.c
index 639f6519fe1f,53f8d03f76f7..000000000000
--- a/drivers/md/dm-thin.c
+++ b/drivers/md/dm-thin.c
@@@ -279,11 -278,42 +279,40 @@@ struct pool 
  	process_mapping_fn process_prepared_discard_pt2;
  
  	struct dm_bio_prison_cell **cell_sort_array;
 -
 -	mempool_t mapping_pool;
  };
  
- static enum pool_mode get_pool_mode(struct pool *pool);
  static void metadata_operation_failed(struct pool *pool, const char *op, int r);
  
+ static enum pool_mode get_pool_mode(struct pool *pool)
+ {
+ 	return pool->pf.mode;
+ }
+ 
+ static void notify_of_pool_mode_change(struct pool *pool)
+ {
+ 	const char *descs[] = {
+ 		"write",
+ 		"out-of-data-space",
+ 		"read-only",
+ 		"read-only",
+ 		"fail"
+ 	};
+ 	const char *extra_desc = NULL;
+ 	enum pool_mode mode = get_pool_mode(pool);
+ 
+ 	if (mode == PM_OUT_OF_DATA_SPACE) {
+ 		if (!pool->pf.error_if_no_space)
+ 			extra_desc = " (queue IO)";
+ 		else
+ 			extra_desc = " (error IO)";
+ 	}
+ 
+ 	dm_table_event(pool->ti->table);
+ 	DMINFO("%s: switching pool to %s%s mode",
+ 	       dm_device_name(pool->pool_md),
+ 	       descs[(int)mode], extra_desc ? : "");
+ }
+ 
  /*
   * Target context for a pool.
   */
@@@ -2474,8 -2392,8 +2501,13 @@@ static void do_no_space_timeout(struct 
  
  	if (get_pool_mode(pool) == PM_OUT_OF_DATA_SPACE && !pool->pf.error_if_no_space) {
  		pool->pf.error_if_no_space = true;
++<<<<<<< HEAD
 +		notify_of_pool_mode_change_to_oods(pool);
 +		error_retry_list_with_code(pool, -ENOSPC);
++=======
+ 		notify_of_pool_mode_change(pool);
+ 		error_retry_list_with_code(pool, BLK_STS_NOSPC);
++>>>>>>> f6c367585d0d (dm thin: send event about thin-pool state change _after_ making it)
  	}
  }
  
* Unmerged path drivers/md/dm-thin.c
