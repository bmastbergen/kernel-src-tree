netlabel: fix out-of-bounds memory accesses

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Paul Moore <paul@paul-moore.com>
commit 5578de4834fe0f2a34fedc7374be691443396d1f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/5578de48.failed

There are two array out-of-bounds memory accesses, one in
cipso_v4_map_lvl_valid(), the other in netlbl_bitmap_walk().  Both
errors are embarassingly simple, and the fixes are straightforward.

As a FYI for anyone backporting this patch to kernels prior to v4.8,
you'll want to apply the netlbl_bitmap_walk() patch to
cipso_v4_bitmap_walk() as netlbl_bitmap_walk() doesn't exist before
Linux v4.8.

	Reported-by: Jann Horn <jannh@google.com>
Fixes: 446fda4f2682 ("[NetLabel]: CIPSOv4 engine")
Fixes: 3faa8f982f95 ("netlabel: Move bitmap manipulation functions to the NetLabel core.")
	Signed-off-by: Paul Moore <paul@paul-moore.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5578de4834fe0f2a34fedc7374be691443396d1f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netlabel/netlabel_kapi.c
diff --cc net/netlabel/netlabel_kapi.c
index 6b1788bbda11,ee3e5b6471a6..000000000000
--- a/net/netlabel/netlabel_kapi.c
+++ b/net/netlabel/netlabel_kapi.c
@@@ -729,6 -870,77 +729,80 @@@ int netlbl_catmap_setlong(struct netlbl
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* Bitmap functions
+  */
+ 
+ /**
+  * netlbl_bitmap_walk - Walk a bitmap looking for a bit
+  * @bitmap: the bitmap
+  * @bitmap_len: length in bits
+  * @offset: starting offset
+  * @state: if non-zero, look for a set (1) bit else look for a cleared (0) bit
+  *
+  * Description:
+  * Starting at @offset, walk the bitmap from left to right until either the
+  * desired bit is found or we reach the end.  Return the bit offset, -1 if
+  * not found, or -2 if error.
+  */
+ int netlbl_bitmap_walk(const unsigned char *bitmap, u32 bitmap_len,
+ 		       u32 offset, u8 state)
+ {
+ 	u32 bit_spot;
+ 	u32 byte_offset;
+ 	unsigned char bitmask;
+ 	unsigned char byte;
+ 
+ 	byte_offset = offset / 8;
+ 	byte = bitmap[byte_offset];
+ 	bit_spot = offset;
+ 	bitmask = 0x80 >> (offset % 8);
+ 
+ 	while (bit_spot < bitmap_len) {
+ 		if ((state && (byte & bitmask) == bitmask) ||
+ 		    (state == 0 && (byte & bitmask) == 0))
+ 			return bit_spot;
+ 
+ 		if (++bit_spot >= bitmap_len)
+ 			return -1;
+ 		bitmask >>= 1;
+ 		if (bitmask == 0) {
+ 			byte = bitmap[++byte_offset];
+ 			bitmask = 0x80;
+ 		}
+ 	}
+ 
+ 	return -1;
+ }
+ EXPORT_SYMBOL(netlbl_bitmap_walk);
+ 
+ /**
+  * netlbl_bitmap_setbit - Sets a single bit in a bitmap
+  * @bitmap: the bitmap
+  * @bit: the bit
+  * @state: if non-zero, set the bit (1) else clear the bit (0)
+  *
+  * Description:
+  * Set a single bit in the bitmask.  Returns zero on success, negative values
+  * on error.
+  */
+ void netlbl_bitmap_setbit(unsigned char *bitmap, u32 bit, u8 state)
+ {
+ 	u32 byte_spot;
+ 	u8 bitmask;
+ 
+ 	/* gcc always rounds to zero when doing integer division */
+ 	byte_spot = bit / 8;
+ 	bitmask = 0x80 >> (bit % 8);
+ 	if (state)
+ 		bitmap[byte_spot] |= bitmask;
+ 	else
+ 		bitmap[byte_spot] &= ~bitmask;
+ }
+ EXPORT_SYMBOL(netlbl_bitmap_setbit);
+ 
++>>>>>>> 5578de4834fe (netlabel: fix out-of-bounds memory accesses)
  /*
   * LSM Functions
   */
diff --git a/net/ipv4/cipso_ipv4.c b/net/ipv4/cipso_ipv4.c
index 1c46d73c8f2c..a56168fbdb44 100644
--- a/net/ipv4/cipso_ipv4.c
+++ b/net/ipv4/cipso_ipv4.c
@@ -738,7 +738,8 @@ static int cipso_v4_map_lvl_valid(const struct cipso_v4_doi *doi_def, u8 level)
 	case CIPSO_V4_MAP_PASS:
 		return 0;
 	case CIPSO_V4_MAP_TRANS:
-		if (doi_def->map.std->lvl.cipso[level] < CIPSO_V4_INV_LVL)
+		if ((level < doi_def->map.std->lvl.cipso_size) &&
+		    (doi_def->map.std->lvl.cipso[level] < CIPSO_V4_INV_LVL))
 			return 0;
 		break;
 	}
* Unmerged path net/netlabel/netlabel_kapi.c
