cxgb4: Add support to read actual provisioned resources

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Casey Leedom <leedom@chelsio.com>
commit 0eaec62a91ed9d5694b7e2bff30a1b1ad7107be7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0eaec62a.failed

In highly constrained resources environments (like the 124VF
T5 and 248VF T6 configurations), PF4 may not have very many
resources at all and we need to adapt to whatever we've been
allocated, this patch adds support to get the provisioned
resources.

	Signed-off-by: Casey Leedom <leedom@chelsio.com>
	Signed-off-by: Ganesh Goudar <ganeshgr@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0eaec62a91ed9d5694b7e2bff30a1b1ad7107be7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
index 5bd37da0d0e0,516c883e1613..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
@@@ -2956,58 -2985,59 +2994,107 @@@ int t4_setup_debugfs(struct adapter *ad
  	struct dentry *de;
  
  	static struct t4_debugfs_entry t4_debugfs_files[] = {
++<<<<<<< HEAD
 +		{ "cim_la", &cim_la_fops, S_IRUSR, 0 },
 +		{ "cim_pif_la", &cim_pif_la_fops, S_IRUSR, 0 },
 +		{ "cim_ma_la", &cim_ma_la_fops, S_IRUSR, 0 },
 +		{ "cim_qcfg", &cim_qcfg_fops, S_IRUSR, 0 },
 +		{ "clk", &clk_debugfs_fops, S_IRUSR, 0 },
 +		{ "devlog", &devlog_fops, S_IRUSR, 0 },
 +		{ "mboxlog", &mboxlog_fops, S_IRUSR, 0 },
 +		{ "mbox0", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 0 },
 +		{ "mbox1", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 1 },
 +		{ "mbox2", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 2 },
 +		{ "mbox3", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 3 },
 +		{ "mbox4", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 4 },
 +		{ "mbox5", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 5 },
 +		{ "mbox6", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 6 },
 +		{ "mbox7", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 7 },
 +		{ "trace0", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 0 },
 +		{ "trace1", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 1 },
 +		{ "trace2", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 2 },
 +		{ "trace3", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 3 },
 +		{ "l2t", &t4_l2t_fops, S_IRUSR, 0},
 +		{ "mps_tcam", &mps_tcam_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss", &rss_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss_config", &rss_config_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss_key", &rss_key_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss_pf_config", &rss_pf_config_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss_vf_config", &rss_vf_config_debugfs_fops, S_IRUSR, 0 },
 +		{ "sge_qinfo", &sge_qinfo_debugfs_fops, S_IRUSR, 0 },
 +		{ "ibq_tp0",  &cim_ibq_fops, S_IRUSR, 0 },
 +		{ "ibq_tp1",  &cim_ibq_fops, S_IRUSR, 1 },
 +		{ "ibq_ulp",  &cim_ibq_fops, S_IRUSR, 2 },
 +		{ "ibq_sge0", &cim_ibq_fops, S_IRUSR, 3 },
 +		{ "ibq_sge1", &cim_ibq_fops, S_IRUSR, 4 },
 +		{ "ibq_ncsi", &cim_ibq_fops, S_IRUSR, 5 },
 +		{ "obq_ulp0", &cim_obq_fops, S_IRUSR, 0 },
 +		{ "obq_ulp1", &cim_obq_fops, S_IRUSR, 1 },
 +		{ "obq_ulp2", &cim_obq_fops, S_IRUSR, 2 },
 +		{ "obq_ulp3", &cim_obq_fops, S_IRUSR, 3 },
 +		{ "obq_sge",  &cim_obq_fops, S_IRUSR, 4 },
 +		{ "obq_ncsi", &cim_obq_fops, S_IRUSR, 5 },
 +		{ "tp_la", &tp_la_fops, S_IRUSR, 0 },
 +		{ "ulprx_la", &ulprx_la_fops, S_IRUSR, 0 },
 +		{ "sensors", &sensors_debugfs_fops, S_IRUSR, 0 },
 +		{ "pm_stats", &pm_stats_debugfs_fops, S_IRUSR, 0 },
 +		{ "tx_rate", &tx_rate_debugfs_fops, S_IRUSR, 0 },
 +		{ "cctrl", &cctrl_tbl_debugfs_fops, S_IRUSR, 0 },
++=======
+ 		{ "cim_la", &cim_la_fops, 0400, 0 },
+ 		{ "cim_pif_la", &cim_pif_la_fops, 0400, 0 },
+ 		{ "cim_ma_la", &cim_ma_la_fops, 0400, 0 },
+ 		{ "cim_qcfg", &cim_qcfg_fops, 0400, 0 },
+ 		{ "clk", &clk_debugfs_fops, 0400, 0 },
+ 		{ "devlog", &devlog_fops, 0400, 0 },
+ 		{ "mboxlog", &mboxlog_fops, 0400, 0 },
+ 		{ "mbox0", &mbox_debugfs_fops, 0600, 0 },
+ 		{ "mbox1", &mbox_debugfs_fops, 0600, 1 },
+ 		{ "mbox2", &mbox_debugfs_fops, 0600, 2 },
+ 		{ "mbox3", &mbox_debugfs_fops, 0600, 3 },
+ 		{ "mbox4", &mbox_debugfs_fops, 0600, 4 },
+ 		{ "mbox5", &mbox_debugfs_fops, 0600, 5 },
+ 		{ "mbox6", &mbox_debugfs_fops, 0600, 6 },
+ 		{ "mbox7", &mbox_debugfs_fops, 0600, 7 },
+ 		{ "trace0", &mps_trc_debugfs_fops, 0600, 0 },
+ 		{ "trace1", &mps_trc_debugfs_fops, 0600, 1 },
+ 		{ "trace2", &mps_trc_debugfs_fops, 0600, 2 },
+ 		{ "trace3", &mps_trc_debugfs_fops, 0600, 3 },
+ 		{ "l2t", &t4_l2t_fops, 0400, 0},
+ 		{ "mps_tcam", &mps_tcam_debugfs_fops, 0400, 0 },
+ 		{ "rss", &rss_debugfs_fops, 0400, 0 },
+ 		{ "rss_config", &rss_config_debugfs_fops, 0400, 0 },
+ 		{ "rss_key", &rss_key_debugfs_fops, 0400, 0 },
+ 		{ "rss_pf_config", &rss_pf_config_debugfs_fops, 0400, 0 },
+ 		{ "rss_vf_config", &rss_vf_config_debugfs_fops, 0400, 0 },
+ 		{ "resources", &resources_debugfs_fops, 0400, 0 },
+ 		{ "sge_qinfo", &sge_qinfo_debugfs_fops, 0400, 0 },
+ 		{ "ibq_tp0",  &cim_ibq_fops, 0400, 0 },
+ 		{ "ibq_tp1",  &cim_ibq_fops, 0400, 1 },
+ 		{ "ibq_ulp",  &cim_ibq_fops, 0400, 2 },
+ 		{ "ibq_sge0", &cim_ibq_fops, 0400, 3 },
+ 		{ "ibq_sge1", &cim_ibq_fops, 0400, 4 },
+ 		{ "ibq_ncsi", &cim_ibq_fops, 0400, 5 },
+ 		{ "obq_ulp0", &cim_obq_fops, 0400, 0 },
+ 		{ "obq_ulp1", &cim_obq_fops, 0400, 1 },
+ 		{ "obq_ulp2", &cim_obq_fops, 0400, 2 },
+ 		{ "obq_ulp3", &cim_obq_fops, 0400, 3 },
+ 		{ "obq_sge",  &cim_obq_fops, 0400, 4 },
+ 		{ "obq_ncsi", &cim_obq_fops, 0400, 5 },
+ 		{ "tp_la", &tp_la_fops, 0400, 0 },
+ 		{ "ulprx_la", &ulprx_la_fops, 0400, 0 },
+ 		{ "sensors", &sensors_debugfs_fops, 0400, 0 },
+ 		{ "pm_stats", &pm_stats_debugfs_fops, 0400, 0 },
+ 		{ "tx_rate", &tx_rate_debugfs_fops, 0400, 0 },
+ 		{ "cctrl", &cctrl_tbl_debugfs_fops, 0400, 0 },
++>>>>>>> 0eaec62a91ed (cxgb4: Add support to read actual provisioned resources)
  #if IS_ENABLED(CONFIG_IPV6)
 -		{ "clip_tbl", &clip_tbl_debugfs_fops, 0400, 0 },
 +		{ "clip_tbl", &clip_tbl_debugfs_fops, S_IRUSR, 0 },
  #endif
 -		{ "tids", &tid_info_debugfs_fops, 0400, 0},
 -		{ "blocked_fl", &blocked_fl_fops, 0600, 0 },
 -		{ "meminfo", &meminfo_fops, 0400, 0 },
 -		{ "crypto", &chcr_stats_debugfs_fops, 0400, 0 },
 +		{ "tids", &tid_info_debugfs_fops, S_IRUSR, 0},
 +		{ "blocked_fl", &blocked_fl_fops, S_IRUSR | S_IWUSR, 0 },
 +		{ "meminfo", &meminfo_fops, S_IRUSR, 0 },
 +		{ "crypto", &chcr_stats_debugfs_fops, S_IRUSR, 0 },
  	};
  
  	/* Debug FS nodes common to all T5 and later adapters.
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index 9ea4a4c716a2..81fec8d5a749 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@ -319,6 +319,21 @@ struct vpd_params {
 	u8 na[MACADDR_LEN + 1];
 };
 
+/* Maximum resources provisioned for a PCI PF.
+ */
+struct pf_resources {
+	unsigned int nvi;		/* N virtual interfaces */
+	unsigned int neq;		/* N egress Qs */
+	unsigned int nethctrl;		/* N egress ETH or CTRL Qs */
+	unsigned int niqflint;		/* N ingress Qs/w free list(s) & intr */
+	unsigned int niq;		/* N ingress Qs */
+	unsigned int tc;		/* PCI-E traffic class */
+	unsigned int pmask;		/* port access rights mask */
+	unsigned int nexactf;		/* N exact MPS filters */
+	unsigned int r_caps;		/* read capabilities */
+	unsigned int wx_caps;		/* write/execute capabilities */
+};
+
 struct pci_params {
 	unsigned int vpd_cap_addr;
 	unsigned char speed;
@@ -346,6 +361,7 @@ struct adapter_params {
 	struct sge_params sge;
 	struct tp_params  tp;
 	struct vpd_params vpd;
+	struct pf_resources pfres;
 	struct pci_params pci;
 	struct devlog_params devlog;
 	enum pcie_memwin drv_memwin;
@@ -1560,6 +1576,7 @@ int t4_eeprom_ptov(unsigned int phys_addr, unsigned int fn, unsigned int sz);
 int t4_seeprom_wp(struct adapter *adapter, bool enable);
 int t4_get_raw_vpd_params(struct adapter *adapter, struct vpd_params *p);
 int t4_get_vpd_params(struct adapter *adapter, struct vpd_params *p);
+int t4_get_pfres(struct adapter *adapter);
 int t4_read_flash(struct adapter *adapter, unsigned int addr,
 		  unsigned int nwords, u32 *data, int byte_oriented);
 int t4_load_fw(struct adapter *adapter, const u8 *fw_data, unsigned int size);
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 08e2850ddbdf..bfab9c62f497 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -925,6 +925,7 @@ static int setup_sge_queues(struct adapter *adap)
 		     QUEUENUMBER_V(s->ethrxq[0].rspq.abs_id));
 	return 0;
 freeout:
+	dev_err(adap->pdev_dev, "Can't allocate queues, err=%d\n", -err);
 	t4_free_sge_resources(adap);
 	return err;
 }
@@ -3535,6 +3536,16 @@ static int adap_init1(struct adapter *adap, struct fw_caps_config_cmd *c)
 	u32 v;
 	int ret;
 
+	/* Now that we've successfully configured and initialized the adapter
+	 * can ask the Firmware what resources it has provisioned for us.
+	 */
+	ret = t4_get_pfres(adap);
+	if (ret) {
+		dev_err(adap->pdev_dev,
+			"Unable to retrieve resource provisioning information\n");
+		return ret;
+	}
+
 	/* get device capabilities */
 	memset(c, 0, sizeof(*c));
 	c->op_to_write = htonl(FW_CMD_OP_V(FW_CAPS_CONFIG_CMD) |
@@ -4169,32 +4180,6 @@ static int adap_init0(struct adapter *adap)
 			goto bye;
 	}
 
-	/*
-	 * Grab VPD parameters.  This should be done after we establish a
-	 * connection to the firmware since some of the VPD parameters
-	 * (notably the Core Clock frequency) are retrieved via requests to
-	 * the firmware.  On the other hand, we need these fairly early on
-	 * so we do this right after getting ahold of the firmware.
-	 */
-	ret = t4_get_vpd_params(adap, &adap->params.vpd);
-	if (ret < 0)
-		goto bye;
-
-	/*
-	 * Find out what ports are available to us.  Note that we need to do
-	 * this before calling adap_init0_no_config() since it needs nports
-	 * and portvec ...
-	 */
-	v =
-	    FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
-	    FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PORTVEC);
-	ret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, &v, &port_vec);
-	if (ret < 0)
-		goto bye;
-
-	adap->params.nports = hweight32(port_vec);
-	adap->params.portvec = port_vec;
-
 	/* If the firmware is initialized already, emit a simply note to that
 	 * effect. Otherwise, it's time to try initializing the adapter.
 	 */
@@ -4245,6 +4230,45 @@ static int adap_init0(struct adapter *adap)
 		}
 	}
 
+	/* Now that we've successfully configured and initialized the adapter
+	 * (or found it already initialized), we can ask the Firmware what
+	 * resources it has provisioned for us.
+	 */
+	ret = t4_get_pfres(adap);
+	if (ret) {
+		dev_err(adap->pdev_dev,
+			"Unable to retrieve resource provisioning information\n");
+		goto bye;
+	}
+
+	/* Grab VPD parameters.  This should be done after we establish a
+	 * connection to the firmware since some of the VPD parameters
+	 * (notably the Core Clock frequency) are retrieved via requests to
+	 * the firmware.  On the other hand, we need these fairly early on
+	 * so we do this right after getting ahold of the firmware.
+	 *
+	 * We need to do this after initializing the adapter because someone
+	 * could have FLASHed a new VPD which won't be read by the firmware
+	 * until we do the RESET ...
+	 */
+	ret = t4_get_vpd_params(adap, &adap->params.vpd);
+	if (ret < 0)
+		goto bye;
+
+	/* Find out what ports are available to us.  Note that we need to do
+	 * this before calling adap_init0_no_config() since it needs nports
+	 * and portvec ...
+	 */
+	v =
+	    FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
+	    FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_PORTVEC);
+	ret = t4_query_params(adap, adap->mbox, adap->pf, 0, 1, &v, &port_vec);
+	if (ret < 0)
+		goto bye;
+
+	adap->params.nports = hweight32(port_vec);
+	adap->params.portvec = port_vec;
+
 	/* Give the SGE code a chance to pull in anything that it needs ...
 	 * Note that this must be called after we retrieve our VPD parameters
 	 * in order to know how to convert core ticks to seconds, etc.
@@ -4796,10 +4820,12 @@ static inline bool is_x_10g_port(const struct link_config *lc)
  * of ports we found and the number of available CPUs.  Most settings can be
  * modified by the admin prior to actual use.
  */
-static void cfg_queues(struct adapter *adap)
+static int cfg_queues(struct adapter *adap)
 {
 	struct sge *s = &adap->sge;
-	int i = 0, n10g = 0, qidx = 0;
+	int i, n10g = 0, qidx = 0;
+	int niqflint, neq, avail_eth_qsets;
+	int max_eth_qsets = 32;
 #ifndef CONFIG_CHELSIO_T4_DCB
 	int q10g = 0;
 #endif
@@ -4811,16 +4837,46 @@ static void cfg_queues(struct adapter *adap)
 		adap->params.crypto = 0;
 	}
 
-	n10g += is_x_10g_port(&adap2pinfo(adap, i)->link_cfg);
+	/* Calculate the number of Ethernet Queue Sets available based on
+	 * resources provisioned for us.  We always have an Asynchronous
+	 * Firmware Event Ingress Queue.  If we're operating in MSI or Legacy
+	 * IRQ Pin Interrupt mode, then we'll also have a Forwarded Interrupt
+	 * Ingress Queue.  Meanwhile, we need two Egress Queues for each
+	 * Queue Set: one for the Free List and one for the Ethernet TX Queue.
+	 *
+	 * Note that we should also take into account all of the various
+	 * Offload Queues.  But, in any situation where we're operating in
+	 * a Resource Constrained Provisioning environment, doing any Offload
+	 * at all is problematic ...
+	 */
+	niqflint = adap->params.pfres.niqflint - 1;
+	if (!(adap->flags & USING_MSIX))
+		niqflint--;
+	neq = adap->params.pfres.neq / 2;
+	avail_eth_qsets = min(niqflint, neq);
+
+	if (avail_eth_qsets > max_eth_qsets)
+		avail_eth_qsets = max_eth_qsets;
+
+	if (avail_eth_qsets < adap->params.nports) {
+		dev_err(adap->pdev_dev, "avail_eth_qsets=%d < nports=%d\n",
+			avail_eth_qsets, adap->params.nports);
+		return -ENOMEM;
+	}
+
+	/* Count the number of 10Gb/s or better ports */
+	for_each_port(adap, i)
+		n10g += is_x_10g_port(&adap2pinfo(adap, i)->link_cfg);
+
 #ifdef CONFIG_CHELSIO_T4_DCB
 	/* For Data Center Bridging support we need to be able to support up
 	 * to 8 Traffic Priorities; each of which will be assigned to its
 	 * own TX Queue in order to prevent Head-Of-Line Blocking.
 	 */
-	if (adap->params.nports * 8 > MAX_ETH_QSETS) {
-		dev_err(adap->pdev_dev, "MAX_ETH_QSETS=%d < %d!\n",
-			MAX_ETH_QSETS, adap->params.nports * 8);
-		BUG_ON(1);
+	if (adap->params.nports * 8 > avail_eth_qsets) {
+		dev_err(adap->pdev_dev, "DCB avail_eth_qsets=%d < %d!\n",
+			avail_eth_qsets, adap->params.nports * 8);
+		return -ENOMEM;
 	}
 
 	for_each_port(adap, i) {
@@ -4836,7 +4892,7 @@ static void cfg_queues(struct adapter *adap)
 	 * per 10G port.
 	 */
 	if (n10g)
-		q10g = (MAX_ETH_QSETS - (adap->params.nports - n10g)) / n10g;
+		q10g = (avail_eth_qsets - (adap->params.nports - n10g)) / n10g;
 	if (q10g > netif_get_num_default_rss_queues())
 		q10g = netif_get_num_default_rss_queues();
 
@@ -4887,6 +4943,8 @@ static void cfg_queues(struct adapter *adap)
 
 	init_rspq(adap, &s->fw_evtq, 0, 1, 1024, 64);
 	init_rspq(adap, &s->intrq, 0, 1, 512, 64);
+
+	return 0;
 }
 
 /*
@@ -5624,10 +5682,15 @@ static int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 		}
 	}
 
+	if (!(adapter->flags & FW_OK))
+		goto fw_attach_fail;
+
 	/* Configure queues and allocate tables now, they can be needed as
 	 * soon as the first register_netdev completes.
 	 */
-	cfg_queues(adapter);
+	err = cfg_queues(adapter);
+	if (err)
+		goto out_free_dev;
 
 	adapter->smt = t4_init_smt();
 	if (!adapter->smt) {
@@ -5734,6 +5797,7 @@ static int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 		goto out_free_dev;
 	}
 
+fw_attach_fail:
 	/*
 	 * The card is now ready to go.  If any errors occur during device
 	 * registration we do not fail the whole card but rather proceed only
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index 38d920475751..22c06932b70f 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@ -2883,6 +2883,57 @@ int t4_get_vpd_params(struct adapter *adapter, struct vpd_params *p)
 	return 0;
 }
 
+/**
+ *	t4_get_pfres - retrieve VF resource limits
+ *	@adapter: the adapter
+ *
+ *	Retrieves configured resource limits and capabilities for a physical
+ *	function.  The results are stored in @adapter->pfres.
+ */
+int t4_get_pfres(struct adapter *adapter)
+{
+	struct pf_resources *pfres = &adapter->params.pfres;
+	struct fw_pfvf_cmd cmd, rpl;
+	int v;
+	u32 word;
+
+	/* Execute PFVF Read command to get VF resource limits; bail out early
+	 * with error on command failure.
+	 */
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP_V(FW_PFVF_CMD) |
+				    FW_CMD_REQUEST_F |
+				    FW_CMD_READ_F |
+				    FW_PFVF_CMD_PFN_V(adapter->pf) |
+				    FW_PFVF_CMD_VFN_V(0));
+	cmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));
+	v = t4_wr_mbox(adapter, adapter->mbox, &cmd, sizeof(cmd), &rpl);
+	if (v != FW_SUCCESS)
+		return v;
+
+	/* Extract PF resource limits and return success.
+	 */
+	word = be32_to_cpu(rpl.niqflint_niq);
+	pfres->niqflint = FW_PFVF_CMD_NIQFLINT_G(word);
+	pfres->niq = FW_PFVF_CMD_NIQ_G(word);
+
+	word = be32_to_cpu(rpl.type_to_neq);
+	pfres->neq = FW_PFVF_CMD_NEQ_G(word);
+	pfres->pmask = FW_PFVF_CMD_PMASK_G(word);
+
+	word = be32_to_cpu(rpl.tc_to_nexactf);
+	pfres->tc = FW_PFVF_CMD_TC_G(word);
+	pfres->nvi = FW_PFVF_CMD_NVI_G(word);
+	pfres->nexactf = FW_PFVF_CMD_NEXACTF_G(word);
+
+	word = be32_to_cpu(rpl.r_caps_to_nethctrl);
+	pfres->r_caps = FW_PFVF_CMD_R_CAPS_G(word);
+	pfres->wx_caps = FW_PFVF_CMD_WX_CAPS_G(word);
+	pfres->nethctrl = FW_PFVF_CMD_NETHCTRL_G(word);
+
+	return 0;
+}
+
 /* serial flash and firmware constants */
 enum {
 	SF_ATTEMPTS = 10,             /* max retries for SF operations */
