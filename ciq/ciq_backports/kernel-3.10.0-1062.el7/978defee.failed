tracing: Do a WARN_ON() if start_thread() in hwlat is called when thread exists

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Steven Rostedt (VMware) <rostedt@goodmis.org>
commit 978defee11a5d54f8f546e79867d2aab1b50606b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/978defee.failed

The start function of the hwlat tracer should never be called when the hwlat
thread already exists. If it is called, do a WARN_ON().

	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit 978defee11a5d54f8f546e79867d2aab1b50606b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_hwlat.c
diff --cc kernel/trace/trace_hwlat.c
index 4b30d8bcf79c,688e48be7bb5..000000000000
--- a/kernel/trace/trace_hwlat.c
+++ b/kernel/trace/trace_hwlat.c
@@@ -366,7 -350,19 +366,21 @@@ static int kthread_fn(void *data
   */
  static int start_kthread(struct trace_array *tr)
  {
 -	struct cpumask *current_mask = &save_cpumask;
  	struct task_struct *kthread;
++<<<<<<< HEAD
++=======
+ 	int next_cpu;
+ 
+ 	if (WARN_ON(hwlat_kthread))
+ 		return 0;
+ 
+ 	/* Just pick the first CPU on first iteration */
+ 	current_mask = &save_cpumask;
+ 	get_online_cpus();
+ 	cpumask_and(current_mask, cpu_online_mask, tracing_buffer_mask);
+ 	put_online_cpus();
+ 	next_cpu = cpumask_first(current_mask);
++>>>>>>> 978defee11a5 (tracing: Do a WARN_ON() if start_thread() in hwlat is called when thread exists)
  
  	kthread = kthread_create(kthread_fn, NULL, "hwlatd");
  	if (IS_ERR(kthread)) {
* Unmerged path kernel/trace/trace_hwlat.c
