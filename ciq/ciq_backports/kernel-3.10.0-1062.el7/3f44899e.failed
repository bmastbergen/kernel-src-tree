net/mlx5e: Use PARTIAL_GSO for UDP segmentation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Use PARTIAL_GSO for UDP segmentation (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 95.56%
commit-author Boris Pismenny <borisp@mellanox.com>
commit 3f44899ef2ce0c9da49feb0d6f08098a08cb96ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3f44899e.failed

This patch removes the splitting of UDP_GSO_L4 packets in the driver,
and exposes UDP_GSO_L4 as a PARTIAL_GSO feature. Thus, the network stack
is not responsible for splitting the packet into two.

	Signed-off-by: Boris Pismenny <borisp@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 3f44899ef2ce0c9da49feb0d6f08098a08cb96ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
diff --cc drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
index 1d7bd82a1fb1,1dd225380a66..000000000000
--- a/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
+++ b/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
@@@ -28,35 -28,53 +28,79 @@@
   * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
 - *
   */
  
 -#ifndef __MLX5E_EN_ACCEL_H__
 -#define __MLX5E_EN_ACCEL_H__
 +/*
 + * This file is conditionally built on PowerPC only.  Otherwise weak symbol
 + * versions of the functions exported from here are used.
 + */
 +
++<<<<<<< HEAD:drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
 +#include "ipath_kernel.h"
  
 +/**
 + * ipath_enable_wc - enable write combining for MMIO writes to the device
 + * @dd: infinipath device
 + *
 + * Nothing to do on PowerPC, so just return without error.
 + */
 +int ipath_enable_wc(struct ipath_devdata *dd)
 +{
 +	return 0;
++=======
+ #include <linux/skbuff.h>
+ #include <linux/netdevice.h>
+ #include "en_accel/ipsec_rxtx.h"
+ #include "en_accel/tls_rxtx.h"
+ #include "en.h"
+ 
+ static inline void
+ mlx5e_udp_gso_handle_tx_skb(struct sk_buff *skb)
+ {
+ 	int payload_len = skb_shinfo(skb)->gso_size + sizeof(struct udphdr);
+ 
+ 	udp_hdr(skb)->len = htons(payload_len);
+ }
+ 
+ static inline struct sk_buff *
+ mlx5e_accel_handle_tx(struct sk_buff *skb,
+ 		      struct mlx5e_txqsq *sq,
+ 		      struct net_device *dev,
+ 		      struct mlx5e_tx_wqe **wqe,
+ 		      u16 *pi)
+ {
+ #ifdef CONFIG_MLX5_EN_TLS
+ 	if (test_bit(MLX5E_SQ_STATE_TLS, &sq->state)) {
+ 		skb = mlx5e_tls_handle_tx_skb(dev, sq, skb, wqe, pi);
+ 		if (unlikely(!skb))
+ 			return NULL;
+ 	}
+ #endif
+ 
+ #ifdef CONFIG_MLX5_EN_IPSEC
+ 	if (test_bit(MLX5E_SQ_STATE_IPSEC, &sq->state)) {
+ 		skb = mlx5e_ipsec_handle_tx_skb(dev, *wqe, skb);
+ 		if (unlikely(!skb))
+ 			return NULL;
+ 	}
+ #endif
+ 
+ 	if (skb_is_gso(skb) && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_L4)
+ 		mlx5e_udp_gso_handle_tx_skb(skb);
+ 
+ 	return skb;
++>>>>>>> 3f44899ef2ce (net/mlx5e: Use PARTIAL_GSO for UDP segmentation):drivers/net/ethernet/mellanox/mlx5/core/en_accel/en_accel.h
  }
  
 -#endif /* __MLX5E_EN_ACCEL_H__ */
 +/**
 + * ipath_unordered_wc - indicate whether write combining is unordered
 + *
 + * Because our performance depends on our ability to do write
 + * combining mmio writes in the most efficient way, we need to
 + * know if we are on a processor that may reorder stores when
 + * write combining.
 + */
 +int ipath_unordered_wc(void)
 +{
 +	return 1;
 +}
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 7500fab9286b,fa7fcca5dc78..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -13,8 -14,8 +13,13 @@@ mlx5_core-$(CONFIG_MLX5_FPGA) += fpga/c
  		fpga/ipsec.o fpga/tls.o
  
  mlx5_core-$(CONFIG_MLX5_CORE_EN) += en_main.o en_common.o en_fs.o en_ethtool.o \
++<<<<<<< HEAD
 +		en_tx.o en_rx.o en_dim.o en_txrx.o en_stats.o vxlan.o \
 +		en_arfs.o en_fs_ethtool.o en_selftest.o
++=======
+ 		en_tx.o en_rx.o en_dim.o en_txrx.o en_stats.o vxlan.o          \
+ 		en_arfs.o en_fs_ethtool.o en_selftest.o en/port.o
++>>>>>>> 3f44899ef2ce (net/mlx5e: Use PARTIAL_GSO for UDP segmentation)
  
  mlx5_core-$(CONFIG_MLX5_MPFS) += lib/mpfs.o
  
* Unmerged path drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index a0bfa9c3ce47..ecb5b99d6b0e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -4189,7 +4189,6 @@ static void mlx5e_build_nic_netdev(struct net_device *netdev)
 	netdev->hw_features      |= NETIF_F_HW_VLAN_STAG_TX;
 
 	if (mlx5e_vxlan_allowed(mdev) || MLX5_CAP_ETH(mdev, tunnel_stateless_gre)) {
-		netdev->hw_features     |= NETIF_F_GSO_PARTIAL;
 		netdev->hw_enc_features |= NETIF_F_IP_CSUM;
 		netdev->hw_enc_features |= NETIF_F_IPV6_CSUM;
 		netdev->hw_enc_features |= NETIF_F_TSO;
@@ -4214,6 +4213,11 @@ static void mlx5e_build_nic_netdev(struct net_device *netdev)
 						NETIF_F_GSO_GRE_CSUM;
 	}
 
+	netdev->hw_features	                 |= NETIF_F_GSO_PARTIAL;
+	netdev->gso_partial_features             |= NETIF_F_GSO_UDP_L4;
+	netdev->hw_features                      |= NETIF_F_GSO_UDP_L4;
+	netdev->features                         |= NETIF_F_GSO_UDP_L4;
+
 	mlx5_query_port_fcs(mdev, &fcs_supported, &fcs_enabled);
 
 	if (fcs_supported)
