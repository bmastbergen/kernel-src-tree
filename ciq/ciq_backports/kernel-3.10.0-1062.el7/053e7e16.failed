phy: phy_{read|write}_mmd_indirect: get addr from phydev

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Andrew Lunn <andrew@lunn.ch>
commit 053e7e169229adebbc27fc176c5369398e9f5eba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/053e7e16.failed

The address of the device can be determined from the phydev structure,
rather than passing it as a parameter.

	Signed-off-by: Andrew Lunn <andrew@lunn.ch>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 053e7e169229adebbc27fc176c5369398e9f5eba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/bcm-phy-lib.c
#	drivers/net/phy/dp83867.c
#	drivers/net/phy/microchip.c
#	drivers/net/phy/phy.c
#	include/linux/phy.h
diff --cc drivers/net/phy/phy.c
index 72b4ef80a369,56c8dd8c0c85..000000000000
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@@ -926,10 -1026,9 +926,9 @@@ static inline void mmd_phy_indirect(str
  
  /**
   * phy_read_mmd_indirect - reads data from the MMD registers
 - * @phydev: The PHY device bus
 + * @bus: the target MII bus
   * @prtad: MMD Address
   * @devad: MMD DEVAD
-  * @addr: PHY address on the MII bus
   *
   * Description: it reads data from the MMD registers (clause 22 to access to
   * clause 45) of the specified phy address.
@@@ -939,21 -1038,33 +938,28 @@@
   * 3) Write reg 13 // MMD Data Command for MMD DEVAD
   * 3) Read  reg 14 // Read MMD data
   */
++<<<<<<< HEAD
 +static int phy_read_mmd_indirect(struct mii_bus *bus, int prtad, int devad,
 +				 int addr)
 +{
 +	mmd_phy_indirect(bus, prtad, devad, addr);
++=======
+ int phy_read_mmd_indirect(struct phy_device *phydev, int prtad, int devad)
+ {
+ 	struct phy_driver *phydrv = phydev->drv;
+ 	int addr = phydev->addr;
+ 	int value = -1;
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
  
 -	if (!phydrv->read_mmd_indirect) {
 -		struct mii_bus *bus = phydev->bus;
 -
 -		mutex_lock(&bus->mdio_lock);
 -		mmd_phy_indirect(bus, prtad, devad, addr);
 -
 -		/* Read the content of the MMD's selected register */
 -		value = bus->read(bus, addr, MII_MMD_DATA);
 -		mutex_unlock(&bus->mdio_lock);
 -	} else {
 -		value = phydrv->read_mmd_indirect(phydev, prtad, devad, addr);
 -	}
 -	return value;
 +	/* Read the content of the MMD's selected register */
 +	return bus->read(bus, addr, MII_MMD_DATA);
  }
 -EXPORT_SYMBOL(phy_read_mmd_indirect);
  
  /**
   * phy_write_mmd_indirect - writes data to the MMD registers
 - * @phydev: The PHY device
 + * @bus: the target MII bus
   * @prtad: MMD Address
   * @devad: MMD DEVAD
-  * @addr: PHY address on the MII bus
   * @data: data to write in the MMD register
   *
   * Description: Write data from the MMD registers of the specified
@@@ -964,14 -1075,26 +970,22 @@@
   * 3) Write reg 13 // MMD Data Command for MMD DEVAD
   * 3) Write reg 14 // Write MMD data
   */
++<<<<<<< HEAD
 +static void phy_write_mmd_indirect(struct mii_bus *bus, int prtad, int devad,
 +				   int addr, u32 data)
 +{
 +	mmd_phy_indirect(bus, prtad, devad, addr);
++=======
+ void phy_write_mmd_indirect(struct phy_device *phydev, int prtad,
+ 				   int devad, u32 data)
+ {
+ 	struct phy_driver *phydrv = phydev->drv;
+ 	int addr = phydev->addr;
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
  
 -	if (!phydrv->write_mmd_indirect) {
 -		struct mii_bus *bus = phydev->bus;
 -
 -		mutex_lock(&bus->mdio_lock);
 -		mmd_phy_indirect(bus, prtad, devad, addr);
 -
 -		/* Write the data into MMD's selected register */
 -		bus->write(bus, addr, MII_MMD_DATA, data);
 -		mutex_unlock(&bus->mdio_lock);
 -	} else {
 -		phydrv->write_mmd_indirect(phydev, prtad, devad, addr, data);
 -	}
 +	/* Write the data into MMD's selected register */
 +	bus->write(bus, addr, MII_MMD_DATA, data);
  }
 -EXPORT_SYMBOL(phy_write_mmd_indirect);
  
  /**
   * phy_init_eee - init and check the EEE feature
@@@ -1005,8 -1128,8 +1019,13 @@@ int phy_init_eee(struct phy_device *phy
  			return status;
  
  		/* First check if the EEE ability is supported */
++<<<<<<< HEAD
 +		eee_cap = phy_read_mmd_indirect(phydev->bus, MDIO_PCS_EEE_ABLE,
 +						MDIO_MMD_PCS, phydev->addr);
++=======
+ 		eee_cap = phy_read_mmd_indirect(phydev, MDIO_PCS_EEE_ABLE,
+ 						MDIO_MMD_PCS);
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
  		if (eee_cap <= 0)
  			goto eee_exit_err;
  
@@@ -1017,13 -1140,13 +1036,23 @@@
  		/* Check which link settings negotiated and verify it in
  		 * the EEE advertising registers.
  		 */
++<<<<<<< HEAD
 +		eee_lp = phy_read_mmd_indirect(phydev->bus, MDIO_AN_EEE_LPABLE,
 +					       MDIO_MMD_AN, phydev->addr);
 +		if (eee_lp <= 0)
 +			goto eee_exit_err;
 +
 +		eee_adv = phy_read_mmd_indirect(phydev->bus, MDIO_AN_EEE_ADV,
 +						MDIO_MMD_AN, phydev->addr);
++=======
+ 		eee_lp = phy_read_mmd_indirect(phydev, MDIO_AN_EEE_LPABLE,
+ 					       MDIO_MMD_AN);
+ 		if (eee_lp <= 0)
+ 			goto eee_exit_err;
+ 
+ 		eee_adv = phy_read_mmd_indirect(phydev, MDIO_AN_EEE_ADV,
+ 						MDIO_MMD_AN);
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
  		if (eee_adv <= 0)
  			goto eee_exit_err;
  
@@@ -1037,15 -1159,14 +1066,25 @@@
  			/* Configure the PHY to stop receiving xMII
  			 * clock while it is signaling LPI.
  			 */
++<<<<<<< HEAD
 +			int val = phy_read_mmd_indirect(phydev->bus, MDIO_CTRL1,
 +							MDIO_MMD_PCS,
 +							phydev->addr);
++=======
+ 			int val = phy_read_mmd_indirect(phydev, MDIO_CTRL1,
+ 							MDIO_MMD_PCS);
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
  			if (val < 0)
  				return val;
  
  			val |= MDIO_PCS_CTRL1_CLKSTOP_EN;
++<<<<<<< HEAD
 +			phy_write_mmd_indirect(phydev->bus, MDIO_CTRL1,
 +					       MDIO_MMD_PCS, phydev->addr, val);
++=======
+ 			phy_write_mmd_indirect(phydev, MDIO_CTRL1,
+ 					       MDIO_MMD_PCS, val);
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
  		}
  
  		return 0; /* EEE supported */
@@@ -1064,8 -1185,7 +1103,12 @@@ EXPORT_SYMBOL(phy_init_eee)
   */
  int phy_get_eee_err(struct phy_device *phydev)
  {
++<<<<<<< HEAD
 +	return phy_read_mmd_indirect(phydev->bus, MDIO_PCS_EEE_WK_ERR,
 +				     MDIO_MMD_PCS, phydev->addr);
++=======
+ 	return phy_read_mmd_indirect(phydev, MDIO_PCS_EEE_WK_ERR, MDIO_MMD_PCS);
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
  }
  EXPORT_SYMBOL(phy_get_eee_err);
  
@@@ -1082,22 -1202,19 +1125,34 @@@ int phy_ethtool_get_eee(struct phy_devi
  	int val;
  
  	/* Get Supported EEE */
++<<<<<<< HEAD
 +	val = phy_read_mmd_indirect(phydev->bus, MDIO_PCS_EEE_ABLE,
 +				    MDIO_MMD_PCS, phydev->addr);
++=======
+ 	val = phy_read_mmd_indirect(phydev, MDIO_PCS_EEE_ABLE, MDIO_MMD_PCS);
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
  	if (val < 0)
  		return val;
  	data->supported = mmd_eee_cap_to_ethtool_sup_t(val);
  
  	/* Get advertisement EEE */
++<<<<<<< HEAD
 +	val = phy_read_mmd_indirect(phydev->bus, MDIO_AN_EEE_ADV,
 +				    MDIO_MMD_AN, phydev->addr);
++=======
+ 	val = phy_read_mmd_indirect(phydev, MDIO_AN_EEE_ADV, MDIO_MMD_AN);
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
  	if (val < 0)
  		return val;
  	data->advertised = mmd_eee_adv_to_ethtool_adv_t(val);
  
  	/* Get LP advertisement EEE */
++<<<<<<< HEAD
 +	val = phy_read_mmd_indirect(phydev->bus, MDIO_AN_EEE_LPABLE,
 +				    MDIO_MMD_AN, phydev->addr);
++=======
+ 	val = phy_read_mmd_indirect(phydev, MDIO_AN_EEE_LPABLE, MDIO_MMD_AN);
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
  	if (val < 0)
  		return val;
  	data->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(val);
@@@ -1117,8 -1234,7 +1172,12 @@@ int phy_ethtool_set_eee(struct phy_devi
  {
  	int val = ethtool_adv_to_mmd_eee_adv_t(data->advertised);
  
++<<<<<<< HEAD
 +	phy_write_mmd_indirect(phydev->bus, MDIO_AN_EEE_ADV, MDIO_MMD_AN,
 +			       phydev->addr, val);
++=======
+ 	phy_write_mmd_indirect(phydev, MDIO_AN_EEE_ADV, MDIO_MMD_AN, val);
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
  
  	return 0;
  }
diff --cc include/linux/phy.h
index 4477c1bcd079,08198ce98773..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -565,6 -626,17 +565,20 @@@ static inline int phy_read_mmd(struct p
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * phy_read_mmd_indirect - reads data from the MMD registers
+  * @phydev: The PHY device bus
+  * @prtad: MMD Address
+  * @addr: PHY address on the MII bus
+  *
+  * Description: it reads data from the MMD registers (clause 22 to access to
+  * clause 45) of the specified phy address.
+  */
+ int phy_read_mmd_indirect(struct phy_device *phydev, int prtad, int devad);
+ 
+ /**
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
   * phy_read - Convenience function for reading a given PHY register
   * @phydev: the phy_device struct
   * @regnum: register number to read
@@@ -635,6 -728,19 +649,22 @@@ static inline int phy_write_mmd(struct 
  	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * phy_write_mmd_indirect - writes data to the MMD registers
+  * @phydev: The PHY device
+  * @prtad: MMD Address
+  * @devad: MMD DEVAD
+  * @data: data to write in the MMD register
+  *
+  * Description: Write data from the MMD registers of the specified
+  * phy address.
+  */
+ void phy_write_mmd_indirect(struct phy_device *phydev, int prtad,
+ 			    int devad, u32 data);
+ 
++>>>>>>> 053e7e169229 (phy: phy_{read|write}_mmd_indirect: get addr from phydev)
  struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
  				     bool is_c45,
  				     struct phy_c45_device_ids *c45_ids);
* Unmerged path drivers/net/phy/bcm-phy-lib.c
* Unmerged path drivers/net/phy/dp83867.c
* Unmerged path drivers/net/phy/microchip.c
* Unmerged path drivers/net/phy/bcm-phy-lib.c
* Unmerged path drivers/net/phy/dp83867.c
* Unmerged path drivers/net/phy/microchip.c
* Unmerged path drivers/net/phy/phy.c
* Unmerged path include/linux/phy.h
