perf stat: Do not use the global 'evsel_list' in print functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit a138af663500a07742bb27793302625135a0f6c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a138af66.failed

Get rid of the the 'evsel_list' global variable dependency, here we can
use the 'evlist' pointer from the evsel.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20180830063252.23729-38-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit a138af663500a07742bb27793302625135a0f6c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-stat.c
diff --cc tools/perf/builtin-stat.c
index 13693124ed08,445673f688de..000000000000
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@@ -1011,57 -905,31 +1011,62 @@@ static void print_metric_header(void *c
  	if (!valid_only_metric(unit))
  		return;
  	unit = fixunit(tbuf, os->evsel, unit);
 -	if (config->csv_output)
 -		fprintf(os->fh, "%s%s", unit, config->csv_sep);
 +	if (csv_output)
 +		fprintf(os->fh, "%s%s", unit, csv_sep);
  	else
 -		fprintf(os->fh, "%*s ", config->metric_only_len, unit);
 +		fprintf(os->fh, "%*s ", metric_only_len, unit);
  }
  
 -static int first_shadow_cpu(struct perf_stat_config *config,
 -			    struct perf_evsel *evsel, int id)
 +static void nsec_printout(int id, int nr, struct perf_evsel *evsel, double avg)
 +{
 +	FILE *output = stat_config.output;
 +	double msecs = avg / NSEC_PER_MSEC;
 +	const char *fmt_v, *fmt_n;
 +	char name[25];
 +
 +	fmt_v = csv_output ? "%.6f%s" : "%18.6f%s";
 +	fmt_n = csv_output ? "%s" : "%-25s";
 +
 +	aggr_printout(evsel, id, nr);
 +
 +	scnprintf(name, sizeof(name), "%s%s",
 +		  perf_evsel__name(evsel), csv_output ? "" : " (msec)");
 +
 +	fprintf(output, fmt_v, msecs, csv_sep);
 +
 +	if (csv_output)
 +		fprintf(output, "%s%s", evsel->unit, csv_sep);
 +	else
 +		fprintf(output, "%-*s%s", unit_width, evsel->unit, csv_sep);
 +
 +	fprintf(output, fmt_n, name);
 +
 +	if (evsel->cgrp)
 +		fprintf(output, "%s%s", csv_sep, evsel->cgrp->name);
 +}
 +
 +static int first_shadow_cpu(struct perf_evsel *evsel, int id)
  {
+ 	struct perf_evlist *evlist = evsel->evlist;
  	int i;
  
 -	if (!config->aggr_get_id)
 +	if (!aggr_get_id)
  		return 0;
  
 -	if (config->aggr_mode == AGGR_NONE)
 +	if (stat_config.aggr_mode == AGGR_NONE)
  		return id;
  
 -	if (config->aggr_mode == AGGR_GLOBAL)
 +	if (stat_config.aggr_mode == AGGR_GLOBAL)
  		return 0;
  
  	for (i = 0; i < perf_evsel__nr_cpus(evsel); i++) {
  		int cpu2 = perf_evsel__cpus(evsel)->map[i];
  
++<<<<<<< HEAD
 +		if (aggr_get_id(evsel_list->cpus, cpu2) == id)
++=======
+ 		if (config->aggr_get_id(config, evlist->cpus, cpu2) == id)
++>>>>>>> a138af663500 (perf stat: Do not use the global 'evsel_list' in print functions)
  			return cpu2;
  	}
  	return 0;
@@@ -1231,12 -1099,12 +1236,16 @@@ static void aggr_update_shadow(void
  	u64 val;
  	struct perf_evsel *counter;
  
 -	for (s = 0; s < config->aggr_map->nr; s++) {
 -		id = config->aggr_map->map[s];
 -		evlist__for_each_entry(evlist, counter) {
 +	for (s = 0; s < aggr_map->nr; s++) {
 +		id = aggr_map->map[s];
 +		evlist__for_each_entry(evsel_list, counter) {
  			val = 0;
  			for (cpu = 0; cpu < perf_evsel__nr_cpus(counter); cpu++) {
++<<<<<<< HEAD
 +				s2 = aggr_get_id(evsel_list->cpus, cpu);
++=======
+ 				s2 = config->aggr_get_id(config, evlist->cpus, cpu);
++>>>>>>> a138af663500 (perf stat: Do not use the global 'evsel_list' in print functions)
  				if (s2 != id)
  					continue;
  				val += perf_counts(counter->counts, cpu, 0)->val;
* Unmerged path tools/perf/builtin-stat.c
