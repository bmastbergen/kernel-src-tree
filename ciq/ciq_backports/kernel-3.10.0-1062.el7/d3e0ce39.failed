perf bpf: Improve BPF related error messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit d3e0ce393057cfa907a0c4fe7b1ff56d5c30cca5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d3e0ce39.failed

A series of bpf loader related error codes were introduced to help error
reporting. Functions were improved to return these new error codes.

Functions which return pointers were adjusted to encode error codes into
return value using the ERR_PTR() interface.

bpf_loader_strerror() was improved to convert these error messages to
strings. It checks the error codes and calls libbpf_strerror() and
strerror_r() accordingly, so caller don't need to consider checking the
range of the error code.

In bpf__strerror_load(), print kernel version of running kernel and the
object's 'version' section to notify user how to fix his/her program.

v1 -> v2:
 Use macro for error code.

 Fetch error message based on array index, eliminate for-loop.

 Print version strings.

Before:

  # perf record -e ./test_kversion_nomatch_program.o sleep 1
  event syntax error: './test_kversion_nomatch_program.o'
                       \___ Failed to load program: Validate your program and check 'license'/'version' sections in your object
  SKIP

  After:

  # perf record -e ./test_kversion_nomatch_program.o ls
  event syntax error: './test_kversion_nomatch_program.o'
                       \___ 'version' (4.4.0) doesn't match running kernel (4.3.0)
  SKIP

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/1446818289-87444-1-git-send-email-wangnan0@huawei.com
[ Add 'static inline' to bpf__strerror_prepare_load() when LIBBPF is disabled ]
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit d3e0ce393057cfa907a0c4fe7b1ff56d5c30cca5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/bpf-loader.c
#	tools/perf/util/bpf-loader.h
#	tools/perf/util/parse-events.c
#	tools/perf/util/util.h
diff --cc tools/perf/util/bpf-loader.c
index ab56073c5d6e,e3afa1b60bb5..000000000000
--- a/tools/perf/util/bpf-loader.c
+++ b/tools/perf/util/bpf-loader.c
@@@ -39,10 -46,22 +39,27 @@@ struct bpf_object *bpf__prepare_load(co
  		libbpf_initialized = true;
  	}
  
++<<<<<<< HEAD
 +	obj = bpf_object__open(filename);
 +	if (!obj) {
++=======
+ 	if (source) {
+ 		int err;
+ 		void *obj_buf;
+ 		size_t obj_buf_sz;
+ 
+ 		err = llvm__compile_bpf(filename, &obj_buf, &obj_buf_sz);
+ 		if (err)
+ 			return ERR_PTR(-BPF_LOADER_ERRNO__COMPILE);
+ 		obj = bpf_object__open_buffer(obj_buf, obj_buf_sz, filename);
+ 		free(obj_buf);
+ 	} else
+ 		obj = bpf_object__open(filename);
+ 
+ 	if (IS_ERR(obj)) {
++>>>>>>> d3e0ce393057 (perf bpf: Improve BPF related error messages)
  		pr_debug("bpf: failed to load %s\n", filename);
 -		return obj;
 +		return ERR_PTR(-EINVAL);
  	}
  
  	return obj;
@@@ -52,6 -71,365 +69,367 @@@ void bpf__clear(void
  {
  	struct bpf_object *obj, *tmp;
  
 -	bpf_object__for_each_safe(obj, tmp) {
 -		bpf__unprobe(obj);
 +	bpf_object__for_each_safe(obj, tmp)
  		bpf_object__close(obj);
++<<<<<<< HEAD
++=======
+ 	}
+ }
+ 
+ static void
+ bpf_prog_priv__clear(struct bpf_program *prog __maybe_unused,
+ 		     void *_priv)
+ {
+ 	struct bpf_prog_priv *priv = _priv;
+ 
+ 	cleanup_perf_probe_events(&priv->pev, 1);
+ 	free(priv);
+ }
+ 
+ static int
+ config_bpf_program(struct bpf_program *prog)
+ {
+ 	struct perf_probe_event *pev = NULL;
+ 	struct bpf_prog_priv *priv = NULL;
+ 	const char *config_str;
+ 	int err;
+ 
+ 	config_str = bpf_program__title(prog, false);
+ 	if (IS_ERR(config_str)) {
+ 		pr_debug("bpf: unable to get title for program\n");
+ 		return PTR_ERR(config_str);
+ 	}
+ 
+ 	priv = calloc(sizeof(*priv), 1);
+ 	if (!priv) {
+ 		pr_debug("bpf: failed to alloc priv\n");
+ 		return -ENOMEM;
+ 	}
+ 	pev = &priv->pev;
+ 
+ 	pr_debug("bpf: config program '%s'\n", config_str);
+ 	err = parse_perf_probe_command(config_str, pev);
+ 	if (err < 0) {
+ 		pr_debug("bpf: '%s' is not a valid config string\n",
+ 			 config_str);
+ 		err = -BPF_LOADER_ERRNO__CONFIG;
+ 		goto errout;
+ 	}
+ 
+ 	if (pev->group && strcmp(pev->group, PERF_BPF_PROBE_GROUP)) {
+ 		pr_debug("bpf: '%s': group for event is set and not '%s'.\n",
+ 			 config_str, PERF_BPF_PROBE_GROUP);
+ 		err = -BPF_LOADER_ERRNO__GROUP;
+ 		goto errout;
+ 	} else if (!pev->group)
+ 		pev->group = strdup(PERF_BPF_PROBE_GROUP);
+ 
+ 	if (!pev->group) {
+ 		pr_debug("bpf: strdup failed\n");
+ 		err = -ENOMEM;
+ 		goto errout;
+ 	}
+ 
+ 	if (!pev->event) {
+ 		pr_debug("bpf: '%s': event name is missing. Section name should be 'key=value'\n",
+ 			 config_str);
+ 		err = -BPF_LOADER_ERRNO__EVENTNAME;
+ 		goto errout;
+ 	}
+ 	pr_debug("bpf: config '%s' is ok\n", config_str);
+ 
+ 	err = bpf_program__set_private(prog, priv, bpf_prog_priv__clear);
+ 	if (err) {
+ 		pr_debug("Failed to set priv for program '%s'\n", config_str);
+ 		goto errout;
+ 	}
+ 
+ 	return 0;
+ 
+ errout:
+ 	if (pev)
+ 		clear_perf_probe_event(pev);
+ 	free(priv);
+ 	return err;
+ }
+ 
+ static int bpf__prepare_probe(void)
+ {
+ 	static int err = 0;
+ 	static bool initialized = false;
+ 
+ 	/*
+ 	 * Make err static, so if init failed the first, bpf__prepare_probe()
+ 	 * fails each time without calling init_probe_symbol_maps multiple
+ 	 * times.
+ 	 */
+ 	if (initialized)
+ 		return err;
+ 
+ 	initialized = true;
+ 	err = init_probe_symbol_maps(false);
+ 	if (err < 0)
+ 		pr_debug("Failed to init_probe_symbol_maps\n");
+ 	probe_conf.max_probes = MAX_PROBES;
+ 	return err;
+ }
+ 
+ int bpf__probe(struct bpf_object *obj)
+ {
+ 	int err = 0;
+ 	struct bpf_program *prog;
+ 	struct bpf_prog_priv *priv;
+ 	struct perf_probe_event *pev;
+ 
+ 	err = bpf__prepare_probe();
+ 	if (err) {
+ 		pr_debug("bpf__prepare_probe failed\n");
+ 		return err;
+ 	}
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		err = config_bpf_program(prog);
+ 		if (err)
+ 			goto out;
+ 
+ 		err = bpf_program__get_private(prog, (void **)&priv);
+ 		if (err || !priv)
+ 			goto out;
+ 		pev = &priv->pev;
+ 
+ 		err = convert_perf_probe_events(pev, 1);
+ 		if (err < 0) {
+ 			pr_debug("bpf_probe: failed to convert perf probe events");
+ 			goto out;
+ 		}
+ 
+ 		err = apply_perf_probe_events(pev, 1);
+ 		if (err < 0) {
+ 			pr_debug("bpf_probe: failed to apply perf probe events");
+ 			goto out;
+ 		}
+ 	}
+ out:
+ 	return err < 0 ? err : 0;
+ }
+ 
+ #define EVENTS_WRITE_BUFSIZE  4096
+ int bpf__unprobe(struct bpf_object *obj)
+ {
+ 	int err, ret = 0;
+ 	struct bpf_program *prog;
+ 	struct bpf_prog_priv *priv;
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		int i;
+ 
+ 		err = bpf_program__get_private(prog, (void **)&priv);
+ 		if (err || !priv)
+ 			continue;
+ 
+ 		for (i = 0; i < priv->pev.ntevs; i++) {
+ 			struct probe_trace_event *tev = &priv->pev.tevs[i];
+ 			char name_buf[EVENTS_WRITE_BUFSIZE];
+ 			struct strfilter *delfilter;
+ 
+ 			snprintf(name_buf, EVENTS_WRITE_BUFSIZE,
+ 				 "%s:%s", tev->group, tev->event);
+ 			name_buf[EVENTS_WRITE_BUFSIZE - 1] = '\0';
+ 
+ 			delfilter = strfilter__new(name_buf, NULL);
+ 			if (!delfilter) {
+ 				pr_debug("Failed to create filter for unprobing\n");
+ 				ret = -ENOMEM;
+ 				continue;
+ 			}
+ 
+ 			err = del_perf_probe_events(delfilter);
+ 			strfilter__delete(delfilter);
+ 			if (err) {
+ 				pr_debug("Failed to delete %s\n", name_buf);
+ 				ret = err;
+ 				continue;
+ 			}
+ 		}
+ 	}
+ 	return ret;
+ }
+ 
+ int bpf__load(struct bpf_object *obj)
+ {
+ 	int err;
+ 
+ 	err = bpf_object__load(obj);
+ 	if (err) {
+ 		pr_debug("bpf: load objects failed\n");
+ 		return err;
+ 	}
+ 	return 0;
+ }
+ 
+ int bpf__foreach_tev(struct bpf_object *obj,
+ 		     bpf_prog_iter_callback_t func,
+ 		     void *arg)
+ {
+ 	struct bpf_program *prog;
+ 	int err;
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		struct probe_trace_event *tev;
+ 		struct perf_probe_event *pev;
+ 		struct bpf_prog_priv *priv;
+ 		int i, fd;
+ 
+ 		err = bpf_program__get_private(prog,
+ 				(void **)&priv);
+ 		if (err || !priv) {
+ 			pr_debug("bpf: failed to get private field\n");
+ 			return -BPF_LOADER_ERRNO__INTERNAL;
+ 		}
+ 
+ 		pev = &priv->pev;
+ 		for (i = 0; i < pev->ntevs; i++) {
+ 			tev = &pev->tevs[i];
+ 
+ 			fd = bpf_program__fd(prog);
+ 			if (fd < 0) {
+ 				pr_debug("bpf: failed to get file descriptor\n");
+ 				return fd;
+ 			}
+ 
+ 			err = (*func)(tev, fd, arg);
+ 			if (err) {
+ 				pr_debug("bpf: call back failed, stop iterate\n");
+ 				return err;
+ 			}
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ #define ERRNO_OFFSET(e)		((e) - __BPF_LOADER_ERRNO__START)
+ #define ERRCODE_OFFSET(c)	ERRNO_OFFSET(BPF_LOADER_ERRNO__##c)
+ #define NR_ERRNO	(__BPF_LOADER_ERRNO__END - __BPF_LOADER_ERRNO__START)
+ 
+ static const char *bpf_loader_strerror_table[NR_ERRNO] = {
+ 	[ERRCODE_OFFSET(CONFIG)]	= "Invalid config string",
+ 	[ERRCODE_OFFSET(GROUP)]		= "Invalid group name",
+ 	[ERRCODE_OFFSET(EVENTNAME)]	= "No event name found in config string",
+ 	[ERRCODE_OFFSET(INTERNAL)]	= "BPF loader internal error",
+ 	[ERRCODE_OFFSET(COMPILE)]	= "Error when compiling BPF scriptlet",
+ };
+ 
+ static int
+ bpf_loader_strerror(int err, char *buf, size_t size)
+ {
+ 	char sbuf[STRERR_BUFSIZE];
+ 	const char *msg;
+ 
+ 	if (!buf || !size)
+ 		return -1;
+ 
+ 	err = err > 0 ? err : -err;
+ 
+ 	if (err >= __LIBBPF_ERRNO__START)
+ 		return libbpf_strerror(err, buf, size);
+ 
+ 	if (err >= __BPF_LOADER_ERRNO__START && err < __BPF_LOADER_ERRNO__END) {
+ 		msg = bpf_loader_strerror_table[ERRNO_OFFSET(err)];
+ 		snprintf(buf, size, "%s", msg);
+ 		buf[size - 1] = '\0';
+ 		return 0;
+ 	}
+ 
+ 	if (err >= __BPF_LOADER_ERRNO__END)
+ 		snprintf(buf, size, "Unknown bpf loader error %d", err);
+ 	else
+ 		snprintf(buf, size, "%s",
+ 			 strerror_r(err, sbuf, sizeof(sbuf)));
+ 
+ 	buf[size - 1] = '\0';
+ 	return -1;
+ }
+ 
+ #define bpf__strerror_head(err, buf, size) \
+ 	char sbuf[STRERR_BUFSIZE], *emsg;\
+ 	if (!size)\
+ 		return 0;\
+ 	if (err < 0)\
+ 		err = -err;\
+ 	bpf_loader_strerror(err, sbuf, sizeof(sbuf));\
+ 	emsg = sbuf;\
+ 	switch (err) {\
+ 	default:\
+ 		scnprintf(buf, size, "%s", emsg);\
+ 		break;
+ 
+ #define bpf__strerror_entry(val, fmt...)\
+ 	case val: {\
+ 		scnprintf(buf, size, fmt);\
+ 		break;\
+ 	}
+ 
+ #define bpf__strerror_end(buf, size)\
+ 	}\
+ 	buf[size - 1] = '\0';
+ 
+ int bpf__strerror_prepare_load(const char *filename, bool source,
+ 			       int err, char *buf, size_t size)
+ {
+ 	size_t n;
+ 	int ret;
+ 
+ 	n = snprintf(buf, size, "Failed to load %s%s: ",
+ 			 filename, source ? " from source" : "");
+ 	if (n >= size) {
+ 		buf[size - 1] = '\0';
+ 		return 0;
+ 	}
+ 	buf += n;
+ 	size -= n;
+ 
+ 	ret = bpf_loader_strerror(err, buf, size);
+ 	buf[size - 1] = '\0';
+ 	return ret;
+ }
+ 
+ int bpf__strerror_probe(struct bpf_object *obj __maybe_unused,
+ 			int err, char *buf, size_t size)
+ {
+ 	bpf__strerror_head(err, buf, size);
+ 	bpf__strerror_entry(EEXIST, "Probe point exist. Try use 'perf probe -d \"*\"'");
+ 	bpf__strerror_entry(EACCES, "You need to be root");
+ 	bpf__strerror_entry(EPERM, "You need to be root, and /proc/sys/kernel/kptr_restrict should be 0");
+ 	bpf__strerror_entry(ENOENT, "You need to check probing points in BPF file");
+ 	bpf__strerror_end(buf, size);
+ 	return 0;
+ }
+ 
+ int bpf__strerror_load(struct bpf_object *obj,
+ 		       int err, char *buf, size_t size)
+ {
+ 	bpf__strerror_head(err, buf, size);
+ 	case LIBBPF_ERRNO__KVER: {
+ 		unsigned int obj_kver = bpf_object__get_kversion(obj);
+ 		unsigned int real_kver;
+ 
+ 		if (fetch_kernel_version(&real_kver, NULL, 0)) {
+ 			scnprintf(buf, size, "Unable to fetch kernel version");
+ 			break;
+ 		}
+ 
+ 		if (obj_kver != real_kver) {
+ 			scnprintf(buf, size,
+ 				  "'version' ("KVER_FMT") doesn't match running kernel ("KVER_FMT")",
+ 				  KVER_PARAM(obj_kver),
+ 				  KVER_PARAM(real_kver));
+ 			break;
+ 		}
+ 
+ 		scnprintf(buf, size, "Failed to load program for unknown reason");
+ 		break;
+ 	}
+ 	bpf__strerror_end(buf, size);
+ 	return 0;
++>>>>>>> d3e0ce393057 (perf bpf: Improve BPF related error messages)
  }
diff --cc tools/perf/util/bpf-loader.h
index f402d7c8c288,5eb3629eed8b..000000000000
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@@ -8,22 -8,101 +8,95 @@@
  #include <linux/compiler.h>
  #include <linux/err.h>
  #include <string.h>
++<<<<<<< HEAD
++=======
+ #include <bpf/libbpf.h>
+ #include "probe-event.h"
++>>>>>>> d3e0ce393057 (perf bpf: Improve BPF related error messages)
  #include "debug.h"
  
+ enum bpf_loader_errno {
+ 	__BPF_LOADER_ERRNO__START = __LIBBPF_ERRNO__START - 100,
+ 	/* Invalid config string */
+ 	BPF_LOADER_ERRNO__CONFIG = __BPF_LOADER_ERRNO__START,
+ 	BPF_LOADER_ERRNO__GROUP,	/* Invalid group name */
+ 	BPF_LOADER_ERRNO__EVENTNAME,	/* Event name is missing */
+ 	BPF_LOADER_ERRNO__INTERNAL,	/* BPF loader internal error */
+ 	BPF_LOADER_ERRNO__COMPILE,	/* Error when compiling BPF scriptlet */
+ 	__BPF_LOADER_ERRNO__END,
+ };
+ 
  struct bpf_object;
 -#define PERF_BPF_PROBE_GROUP "perf_bpf_probe"
 -
 -typedef int (*bpf_prog_iter_callback_t)(struct probe_trace_event *tev,
 -					int fd, void *arg);
  
  #ifdef HAVE_LIBBPF_SUPPORT
++<<<<<<< HEAD
 +struct bpf_object *bpf__prepare_load(const char *filename);
++=======
+ struct bpf_object *bpf__prepare_load(const char *filename, bool source);
+ int bpf__strerror_prepare_load(const char *filename, bool source,
+ 			       int err, char *buf, size_t size);
++>>>>>>> d3e0ce393057 (perf bpf: Improve BPF related error messages)
  
  void bpf__clear(void);
 -
 -int bpf__probe(struct bpf_object *obj);
 -int bpf__unprobe(struct bpf_object *obj);
 -int bpf__strerror_probe(struct bpf_object *obj, int err,
 -			char *buf, size_t size);
 -
 -int bpf__load(struct bpf_object *obj);
 -int bpf__strerror_load(struct bpf_object *obj, int err,
 -		       char *buf, size_t size);
 -int bpf__foreach_tev(struct bpf_object *obj,
 -		     bpf_prog_iter_callback_t func, void *arg);
  #else
  static inline struct bpf_object *
 -bpf__prepare_load(const char *filename __maybe_unused,
 -		  bool source __maybe_unused)
 +bpf__prepare_load(const char *filename __maybe_unused)
  {
  	pr_debug("ERROR: eBPF object loading is disabled during compiling.\n");
  	return ERR_PTR(-ENOTSUP);
  }
  
  static inline void bpf__clear(void) { }
++<<<<<<< HEAD
++=======
+ 
+ static inline int bpf__probe(struct bpf_object *obj __maybe_unused) { return 0;}
+ static inline int bpf__unprobe(struct bpf_object *obj __maybe_unused) { return 0;}
+ static inline int bpf__load(struct bpf_object *obj __maybe_unused) { return 0; }
+ 
+ static inline int
+ bpf__foreach_tev(struct bpf_object *obj __maybe_unused,
+ 		 bpf_prog_iter_callback_t func __maybe_unused,
+ 		 void *arg __maybe_unused)
+ {
+ 	return 0;
+ }
+ 
+ static inline int
+ __bpf_strerror(char *buf, size_t size)
+ {
+ 	if (!size)
+ 		return 0;
+ 	strncpy(buf,
+ 		"ERROR: eBPF object loading is disabled during compiling.\n",
+ 		size);
+ 	buf[size - 1] = '\0';
+ 	return 0;
+ }
+ 
+ static inline
+ int bpf__strerror_prepare_load(const char *filename __maybe_unused,
+ 			       bool source __maybe_unused,
+ 			       int err __maybe_unused,
+ 			       char *buf, size_t size)
+ {
+ 	return __bpf_strerror(buf, size);
+ }
+ 
+ static inline int
+ bpf__strerror_probe(struct bpf_object *obj __maybe_unused,
+ 		    int err __maybe_unused,
+ 		    char *buf, size_t size)
+ {
+ 	return __bpf_strerror(buf, size);
+ }
+ 
+ static inline int bpf__strerror_load(struct bpf_object *obj __maybe_unused,
+ 				     int err __maybe_unused,
+ 				     char *buf, size_t size)
+ {
+ 	return __bpf_strerror(buf, size);
+ }
++>>>>>>> d3e0ce393057 (perf bpf: Improve BPF related error messages)
  #endif
  #endif
diff --cc tools/perf/util/parse-events.c
index 3a234b74d6ff,e48d9da75707..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -590,6 -530,131 +590,134 @@@ static int add_tracepoint_multi_sys(str
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ struct __add_bpf_event_param {
+ 	struct parse_events_evlist *data;
+ 	struct list_head *list;
+ };
+ 
+ static int add_bpf_event(struct probe_trace_event *tev, int fd,
+ 			 void *_param)
+ {
+ 	LIST_HEAD(new_evsels);
+ 	struct __add_bpf_event_param *param = _param;
+ 	struct parse_events_evlist *evlist = param->data;
+ 	struct list_head *list = param->list;
+ 	struct perf_evsel *pos;
+ 	int err;
+ 
+ 	pr_debug("add bpf event %s:%s and attach bpf program %d\n",
+ 		 tev->group, tev->event, fd);
+ 
+ 	err = parse_events_add_tracepoint(&new_evsels, &evlist->idx, tev->group,
+ 					  tev->event, evlist->error, NULL);
+ 	if (err) {
+ 		struct perf_evsel *evsel, *tmp;
+ 
+ 		pr_debug("Failed to add BPF event %s:%s\n",
+ 			 tev->group, tev->event);
+ 		list_for_each_entry_safe(evsel, tmp, &new_evsels, node) {
+ 			list_del(&evsel->node);
+ 			perf_evsel__delete(evsel);
+ 		}
+ 		return err;
+ 	}
+ 	pr_debug("adding %s:%s\n", tev->group, tev->event);
+ 
+ 	list_for_each_entry(pos, &new_evsels, node) {
+ 		pr_debug("adding %s:%s to %p\n",
+ 			 tev->group, tev->event, pos);
+ 		pos->bpf_fd = fd;
+ 	}
+ 	list_splice(&new_evsels, list);
+ 	return 0;
+ }
+ 
+ int parse_events_load_bpf_obj(struct parse_events_evlist *data,
+ 			      struct list_head *list,
+ 			      struct bpf_object *obj)
+ {
+ 	int err;
+ 	char errbuf[BUFSIZ];
+ 	struct __add_bpf_event_param param = {data, list};
+ 	static bool registered_unprobe_atexit = false;
+ 
+ 	if (IS_ERR(obj) || !obj) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Internal error: load bpf obj with NULL");
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 
+ 	/*
+ 	 * Register atexit handler before calling bpf__probe() so
+ 	 * bpf__probe() don't need to unprobe probe points its already
+ 	 * created when failure.
+ 	 */
+ 	if (!registered_unprobe_atexit) {
+ 		atexit(bpf__clear);
+ 		registered_unprobe_atexit = true;
+ 	}
+ 
+ 	err = bpf__probe(obj);
+ 	if (err) {
+ 		bpf__strerror_probe(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__load(obj);
+ 	if (err) {
+ 		bpf__strerror_load(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__foreach_tev(obj, add_bpf_event, &param);
+ 	if (err) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Attach events in BPF object failed");
+ 		goto errout;
+ 	}
+ 
+ 	return 0;
+ errout:
+ 	data->error->help = strdup("(add -v to see detail)");
+ 	data->error->str = strdup(errbuf);
+ 	return err;
+ }
+ 
+ int parse_events_load_bpf(struct parse_events_evlist *data,
+ 			  struct list_head *list,
+ 			  char *bpf_file_name,
+ 			  bool source)
+ {
+ 	struct bpf_object *obj;
+ 
+ 	obj = bpf__prepare_load(bpf_file_name, source);
+ 	if (IS_ERR(obj)) {
+ 		char errbuf[BUFSIZ];
+ 		int err;
+ 
+ 		err = PTR_ERR(obj);
+ 
+ 		if (err == -ENOTSUP)
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "BPF support is not compiled");
+ 		else
+ 			bpf__strerror_prepare_load(bpf_file_name,
+ 						   source,
+ 						   -err, errbuf,
+ 						   sizeof(errbuf));
+ 
+ 		data->error->help = strdup("(add -v to see detail)");
+ 		data->error->str = strdup(errbuf);
+ 		return err;
+ 	}
+ 
+ 	return parse_events_load_bpf_obj(data, list, obj);
+ }
+ 
++>>>>>>> d3e0ce393057 (perf bpf: Improve BPF related error messages)
  static int
  parse_breakpoint_type(const char *type, struct perf_event_attr *attr)
  {
diff --cc tools/perf/util/util.h
index 9e6e8607d8e3,dcc659017976..000000000000
--- a/tools/perf/util/util.h
+++ b/tools/perf/util/util.h
@@@ -42,19 -276,86 +42,41 @@@ int hex2u64(const char *ptr, u64 *val)
  extern unsigned int page_size;
  extern int cacheline_size;
  
 -void get_term_dimensions(struct winsize *ws);
 -void set_term_quiet_input(struct termios *old);
 -
 -struct parse_tag {
 -	char tag;
 -	int mult;
 -};
 -
 -unsigned long parse_tag_value(const char *str, struct parse_tag *tags);
 -
 -#define SRCLINE_UNKNOWN  ((char *) "??:0")
 -
 -static inline int path__join(char *bf, size_t size,
 -			     const char *path1, const char *path2)
 -{
 -	return scnprintf(bf, size, "%s%s%s", path1, path1[0] ? "/" : "", path2);
 -}
 -
 -static inline int path__join3(char *bf, size_t size,
 -			      const char *path1, const char *path2,
 -			      const char *path3)
 -{
 -	return scnprintf(bf, size, "%s%s%s%s%s",
 -			 path1, path1[0] ? "/" : "",
 -			 path2, path2[0] ? "/" : "", path3);
 -}
 -
 -struct dso;
 -struct symbol;
 -
 -extern bool srcline_full_filename;
 -char *get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 -		  bool show_sym);
 -char *__get_srcline(struct dso *dso, u64 addr, struct symbol *sym,
 -		  bool show_sym, bool unwind_inlines);
 -void free_srcline(char *srcline);
 -
 -int filename__read_str(const char *filename, char **buf, size_t *sizep);
 -int perf_event_paranoid(void);
 -
 -void mem_bswap_64(void *src, int byte_size);
 -void mem_bswap_32(void *src, int byte_size);
 -
 -const char *get_filename_for_perf_kvm(void);
 -bool find_process(const char *name);
 +const char *perf_tip(const char *dirpath);
  
 -#ifdef HAVE_ZLIB_SUPPORT
 -int gzip_decompress_to_file(const char *input, int output_fd);
 +#ifndef HAVE_SCHED_GETCPU_SUPPORT
 +int sched_getcpu(void);
  #endif
  
 -#ifdef HAVE_LZMA_SUPPORT
 -int lzma_decompress_to_file(const char *input, int output_fd);
 +#ifndef HAVE_SETNS_SUPPORT
 +int setns(int fd, int nstype);
  #endif
  
 -char *asprintf_expr_inout_ints(const char *var, bool in, size_t nints, int *ints);
 +extern bool perf_singlethreaded;
  
++<<<<<<< HEAD
 +void perf_set_singlethreaded(void);
 +void perf_set_multithreaded(void);
++=======
+ static inline char *asprintf_expr_in_ints(const char *var, size_t nints, int *ints)
+ {
+ 	return asprintf_expr_inout_ints(var, true, nints, ints);
+ }
+ 
+ static inline char *asprintf_expr_not_in_ints(const char *var, size_t nints, int *ints)
+ {
+ 	return asprintf_expr_inout_ints(var, false, nints, ints);
+ }
+ 
+ int get_stack_size(const char *str, unsigned long *_size);
+ 
+ int fetch_kernel_version(unsigned int *puint,
+ 			 char *str, size_t str_sz);
+ #define KVER_VERSION(x)		(((x) >> 16) & 0xff)
+ #define KVER_PATCHLEVEL(x)	(((x) >> 8) & 0xff)
+ #define KVER_SUBLEVEL(x)	((x) & 0xff)
+ #define KVER_FMT	"%d.%d.%d"
+ #define KVER_PARAM(x)	KVER_VERSION(x), KVER_PATCHLEVEL(x), KVER_SUBLEVEL(x)
++>>>>>>> d3e0ce393057 (perf bpf: Improve BPF related error messages)
  
  #endif /* GIT_COMPAT_UTIL_H */
* Unmerged path tools/perf/util/bpf-loader.c
* Unmerged path tools/perf/util/bpf-loader.h
* Unmerged path tools/perf/util/parse-events.c
* Unmerged path tools/perf/util/util.h
