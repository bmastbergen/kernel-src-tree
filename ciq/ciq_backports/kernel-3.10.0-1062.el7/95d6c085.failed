cpufreq: intel_pstate: Register when ACPI PCCH is present

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: Register when ACPI PCCH is present (Prarit Bhargava) [1671693]
Rebuild_FUZZ: 91.43%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 95d6c0857e54b788982746071130d822a795026b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/95d6c085.failed

Currently, intel_pstate doesn't register if _PSS is not present on
HP Proliant systems, because it expects the firmware to take over
CPU performance scaling in that case.  However, if ACPI PCCH is
present, the firmware expects the kernel to use it for CPU
performance scaling and the pcc-cpufreq driver is loaded for that.

Unfortunately, the firmware interface used by that driver is not
scalable for fundamental reasons, so pcc-cpufreq is way suboptimal
on systems with more than just a few CPUs.  In fact, it is better to
avoid using it at all.

For this reason, modify intel_pstate to look for ACPI PCCH if _PSS
is not present and register if it is there.  Also prevent the
pcc-cpufreq driver from trying to initialize itself if intel_pstate
has been registered already.

Fixes: fbbcdc0744da (intel_pstate: skip the driver if ACPI has power mgmt option)
	Reported-by: Andreas Herrmann <aherrmann@suse.com>
	Reviewed-by: Andreas Herrmann <aherrmann@suse.com>
	Acked-by: Srinivas Pandruvada <srinivas.pandruvada@linux.intel.com>
	Tested-by: Andreas Herrmann <aherrmann@suse.com>
	Cc: 4.16+ <stable@vger.kernel.org> # 4.16+
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 95d6c0857e54b788982746071130d822a795026b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 43c7d59b35ef,3c3971256130..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -2369,7 -2394,19 +2369,23 @@@ static bool intel_pstate_no_acpi_pss(vo
  	return true;
  }
  
++<<<<<<< HEAD
 +static bool intel_pstate_has_acpi_ppc(void)
++=======
+ static bool __init intel_pstate_no_acpi_pcch(void)
+ {
+ 	acpi_status status;
+ 	acpi_handle handle;
+ 
+ 	status = acpi_get_handle(NULL, "\\_SB", &handle);
+ 	if (ACPI_FAILURE(status))
+ 		return true;
+ 
+ 	return !acpi_has_method(handle, "PCCH");
+ }
+ 
+ static bool __init intel_pstate_has_acpi_ppc(void)
++>>>>>>> 95d6c0857e54 (cpufreq: intel_pstate: Register when ACPI PCCH is present)
  {
  	int i;
  
@@@ -2430,21 -2459,18 +2446,32 @@@ static bool intel_pstate_platform_pwr_m
  			return true;
  	}
  
 -	idx = acpi_match_platform_list(plat_info);
 -	if (idx < 0)
 +	if (acpi_disabled ||
 +	    ACPI_FAILURE(acpi_get_table_header(ACPI_SIG_FADT, 0, &hdr)))
  		return false;
  
++<<<<<<< HEAD
 +	for (v_info = vendor_info; v_info->valid; v_info++) {
 +		if (!strncmp(hdr.oem_id, v_info->oem_id, ACPI_OEM_ID_SIZE) &&
 +			!strncmp(hdr.oem_table_id, v_info->oem_table_id,
 +						ACPI_OEM_TABLE_ID_SIZE))
 +			switch (v_info->oem_pwr_table) {
 +			case PSS:
 +				return intel_pstate_no_acpi_pss();
 +			case PPC:
 +				return intel_pstate_has_acpi_ppc() &&
 +					(!force_load);
 +			}
++=======
+ 	switch (plat_info[idx].data) {
+ 	case PSS:
+ 		if (!intel_pstate_no_acpi_pss())
+ 			return false;
+ 
+ 		return intel_pstate_no_acpi_pcch();
+ 	case PPC:
+ 		return intel_pstate_has_acpi_ppc() && !force_load;
++>>>>>>> 95d6c0857e54 (cpufreq: intel_pstate: Register when ACPI PCCH is present)
  	}
  
  	return false;
* Unmerged path drivers/cpufreq/intel_pstate.c
diff --git a/drivers/cpufreq/pcc-cpufreq.c b/drivers/cpufreq/pcc-cpufreq.c
index 418c6dd4ff4a..1d96be32cbcb 100644
--- a/drivers/cpufreq/pcc-cpufreq.c
+++ b/drivers/cpufreq/pcc-cpufreq.c
@@ -581,6 +581,10 @@ static int __init pcc_cpufreq_init(void)
 {
 	int ret;
 
+	/* Skip initialization if another cpufreq driver is there. */
+	if (cpufreq_get_current_driver())
+		return 0;
+
 	if (acpi_disabled)
 		return 0;
 
