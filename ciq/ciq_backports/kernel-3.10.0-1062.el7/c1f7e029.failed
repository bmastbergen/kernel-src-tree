net: cls_flower: Remove filter from mask before freeing it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [net] cls_flower: Remove filter from mask before freeing it (Davide Caratti) [1706791]
Rebuild_FUZZ: 95.50%
commit-author Petr Machata <petrm@mellanox.com>
commit c1f7e02979edd7a3a3e69fe04be60b1d650dc8a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c1f7e029.failed

In fl_change(), when adding a new rule (i.e. fold == NULL), a driver may
reject the new rule, for example due to resource exhaustion. By that
point, the new rule was already assigned a mask, and it was added to
that mask's hash table. The clean-up path that's invoked as a result of
the rejection however neglects to undo the hash table addition, and
proceeds to free the new rule, thus leaving a dangling pointer in the
hash table.

Fix by removing fnew from the mask's hash table before it is freed.

Fixes: 35cc3cefc4de ("net/sched: cls_flower: Reject duplicated rules also under skip_sw")
	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c1f7e02979edd7a3a3e69fe04be60b1d650dc8a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_flower.c
diff --cc net/sched/cls_flower.c
index eb4e6a91f3e1,12ca9d13db83..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -984,25 -1358,20 +984,29 @@@ static int fl_change(struct net *net, s
  	if (err)
  		goto errout_idr;
  
 -	if (!fold && __fl_lookup(fnew->mask, &fnew->mkey)) {
 -		err = -EEXIST;
 -		goto errout_mask;
 -	}
 +	if (!tc_skip_sw(fnew->flags)) {
 +		if (!fold && fl_lookup(head, &fnew->mkey)) {
 +			err = -EEXIST;
 +			goto errout_idr;
 +		}
  
 -	err = rhashtable_insert_fast(&fnew->mask->ht, &fnew->ht_node,
 -				     fnew->mask->filter_ht_params);
 -	if (err)
 -		goto errout_mask;
 +		err = rhashtable_insert_fast(&head->ht, &fnew->ht_node,
 +					     head->ht_params);
 +		if (err)
 +			goto errout_idr;
 +	}
  
  	if (!tc_skip_hw(fnew->flags)) {
 -		err = fl_hw_replace_filter(tp, fnew, extack);
 +		err = fl_hw_replace_filter(tp,
 +					   &head->dissector,
 +					   &mask.key,
 +					   fnew);
  		if (err)
++<<<<<<< HEAD
 +			goto errout_idr;
++=======
+ 			goto errout_mask_ht;
++>>>>>>> c1f7e02979ed (net: cls_flower: Remove filter from mask before freeing it)
  	}
  
  	if (!tc_in_hw(fnew->flags))
@@@ -1030,11 -1398,19 +1034,21 @@@
  	}
  
  	kfree(tb);
 -	kfree(mask);
  	return 0;
  
++<<<<<<< HEAD
++=======
+ errout_mask_ht:
+ 	rhashtable_remove_fast(&fnew->mask->ht, &fnew->ht_node,
+ 			       fnew->mask->filter_ht_params);
+ 
+ errout_mask:
+ 	fl_mask_put(head, fnew->mask, false);
+ 
++>>>>>>> c1f7e02979ed (net: cls_flower: Remove filter from mask before freeing it)
  errout_idr:
 -	if (!fold)
 -		idr_remove(&head->handle_idr, fnew->handle);
 +	if (fnew->handle)
 +		idr_remove_ext(&head->handle_idr, fnew->handle);
  errout:
  	tcf_exts_destroy(&fnew->exts);
  	kfree(fnew);
* Unmerged path net/sched/cls_flower.c
