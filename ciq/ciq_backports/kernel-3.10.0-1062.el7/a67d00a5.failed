xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit a67d00a55507dc324037f182563e10339945721a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a67d00a5.failed

Now that we've massaged the callers into the right form we can always
pass the actual extent record instead of the individual fields.

With that xfs_bmbt_disk_set_allf can go away, and xfs_bmbt_disk_set_all
can be merged into the former implementation of xfs_bmbt_disk_set_allf.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit a67d00a55507dc324037f182563e10339945721a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 667acf472273,a7bd6ed0185a..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -1688,11 -1711,7 +1684,15 @@@ xfs_bmap_add_extent_delay_real
  			if (error)
  				goto done;
  			XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
++<<<<<<< HEAD
 +			error = xfs_bmbt_update(bma->cur, LEFT.br_startoff,
 +					LEFT.br_startblock,
 +					LEFT.br_blockcount +
 +					PREV.br_blockcount +
 +					RIGHT.br_blockcount, LEFT.br_state);
++=======
+ 			error = xfs_bmbt_update(bma->cur, &LEFT);
++>>>>>>> a67d00a55507 (xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update)
  			if (error)
  				goto done;
  		}
@@@ -1721,10 -1741,7 +1721,14 @@@
  			if (error)
  				goto done;
  			XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
++<<<<<<< HEAD
 +			error = xfs_bmbt_update(bma->cur, LEFT.br_startoff,
 +					LEFT.br_startblock,
 +					LEFT.br_blockcount +
 +					PREV.br_blockcount, LEFT.br_state);
++=======
+ 			error = xfs_bmbt_update(bma->cur, &LEFT);
++>>>>>>> a67d00a55507 (xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update)
  			if (error)
  				goto done;
  		}
@@@ -1752,10 -1769,7 +1756,14 @@@
  			if (error)
  				goto done;
  			XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
++<<<<<<< HEAD
 +			error = xfs_bmbt_update(bma->cur, PREV.br_startoff,
 +					new->br_startblock,
 +					PREV.br_blockcount +
 +					RIGHT.br_blockcount, PREV.br_state);
++=======
+ 			error = xfs_bmbt_update(bma->cur, &PREV);
++>>>>>>> a67d00a55507 (xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update)
  			if (error)
  				goto done;
  		}
@@@ -1816,11 -1838,7 +1824,15 @@@
  			if (error)
  				goto done;
  			XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
++<<<<<<< HEAD
 +			error = xfs_bmbt_update(bma->cur, LEFT.br_startoff,
 +					LEFT.br_startblock,
 +					LEFT.br_blockcount +
 +					new->br_blockcount,
 +					LEFT.br_state);
++=======
+ 			error = xfs_bmbt_update(bma->cur, &LEFT);
++>>>>>>> a67d00a55507 (xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update)
  			if (error)
  				goto done;
  		}
@@@ -1899,11 -1916,7 +1911,15 @@@
  			if (error)
  				goto done;
  			XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
++<<<<<<< HEAD
 +			error = xfs_bmbt_update(bma->cur, new->br_startoff,
 +					new->br_startblock,
 +					new->br_blockcount +
 +					RIGHT.br_blockcount,
 +					RIGHT.br_state);
++=======
+ 			error = xfs_bmbt_update(bma->cur, &RIGHT);
++>>>>>>> a67d00a55507 (xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update)
  			if (error)
  				goto done;
  		}
@@@ -4815,13 -5146,11 +4804,18 @@@ xfs_bmap_del_extent
  			flags |= xfs_ilog_fext(whichfork);
  			break;
  		}
++<<<<<<< HEAD
 +		if ((error = xfs_bmbt_update(cur, del_endoff, del_endblock,
 +				got.br_blockcount - del->br_blockcount,
 +				got.br_state)))
++=======
+ 		error = xfs_bmbt_update(cur, &got);
+ 		if (error)
++>>>>>>> a67d00a55507 (xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update)
  			goto done;
  		break;
 -	case BMAP_RIGHT_FILLING:
 +
 +	case 1:
  		/*
  		 * Deleting the last part of the extent.
  		 */
@@@ -4841,107 -5162,74 +4835,167 @@@
  			flags |= xfs_ilog_fext(whichfork);
  			break;
  		}
++<<<<<<< HEAD
 +		if ((error = xfs_bmbt_update(cur, got.br_startoff,
 +				got.br_startblock,
 +				got.br_blockcount - del->br_blockcount,
 +				got.br_state)))
++=======
+ 		error = xfs_bmbt_update(cur, &got);
+ 		if (error)
++>>>>>>> a67d00a55507 (xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update)
  			goto done;
  		break;
 +
  	case 0:
  		/*
  		 * Deleting the middle of the extent.
  		 */
 +		temp = del->br_startoff - got.br_startoff;
  		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
 -
 -		old = got;
 -		got.br_blockcount = del->br_startoff - got.br_startoff;
 -		xfs_iext_update_extent(ifp, *idx, &got);
 -
 +		xfs_bmbt_set_blockcount(ep, temp);
  		new.br_startoff = del_endoff;
 -		new.br_blockcount = got_endoff - del_endoff;
 +		temp2 = got_endoff - del_endoff;
 +		new.br_blockcount = temp2;
  		new.br_state = got.br_state;
++<<<<<<< HEAD
 +		if (!delay) {
 +			new.br_startblock = del_endblock;
 +			flags |= XFS_ILOG_CORE;
 +			if (cur) {
 +				if ((error = xfs_bmbt_update(cur,
 +						got.br_startoff,
 +						got.br_startblock, temp,
 +						got.br_state)))
++=======
+ 		new.br_startblock = del_endblock;
+ 
+ 		flags |= XFS_ILOG_CORE;
+ 		if (cur) {
+ 			error = xfs_bmbt_update(cur, &got);
+ 			if (error)
+ 				goto done;
+ 			error = xfs_btree_increment(cur, 0, &i);
+ 			if (error)
+ 				goto done;
+ 			cur->bc_rec.b = new;
+ 			error = xfs_btree_insert(cur, &i);
+ 			if (error && error != -ENOSPC)
+ 				goto done;
+ 			/*
+ 			 * If get no-space back from btree insert, it tried a
+ 			 * split, and we have a zero block reservation.  Fix up
+ 			 * our state and return the error.
+ 			 */
+ 			if (error == -ENOSPC) {
+ 				/*
+ 				 * Reset the cursor, don't trust it after any
+ 				 * insert operation.
+ 				 */
+ 				error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
+ 						got.br_startblock,
+ 						got.br_blockcount, &i);
+ 				if (error)
++>>>>>>> a67d00a55507 (xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update)
  					goto done;
 +				if ((error = xfs_btree_increment(cur, 0, &i)))
 +					goto done;
 +				cur->bc_rec.b = new;
 +				error = xfs_btree_insert(cur, &i);
 +				if (error && error != -ENOSPC)
 +					goto done;
 +				/*
 +				 * If get no-space back from btree insert,
 +				 * it tried a split, and we have a zero
 +				 * block reservation.
 +				 * Fix up our state and return the error.
 +				 */
 +				if (error == -ENOSPC) {
 +					/*
 +					 * Reset the cursor, don't trust
 +					 * it after any insert operation.
 +					 */
 +					if ((error = xfs_bmbt_lookup_eq(cur,
 +							got.br_startoff,
 +							got.br_startblock,
 +							temp, &i)))
 +						goto done;
 +					XFS_WANT_CORRUPTED_GOTO(mp,
 +								i == 1, done);
 +					/*
 +					 * Update the btree record back
 +					 * to the original value.
 +					 */
 +					if ((error = xfs_bmbt_update(cur,
 +							got.br_startoff,
 +							got.br_startblock,
 +							got.br_blockcount,
 +							got.br_state)))
 +						goto done;
 +					/*
 +					 * Reset the extent record back
 +					 * to the original value.
 +					 */
 +					xfs_bmbt_set_blockcount(ep,
 +						got.br_blockcount);
 +					flags = 0;
 +					error = -ENOSPC;
 +					goto done;
 +				}
  				XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
++<<<<<<< HEAD
 +			} else
 +				flags |= xfs_ilog_fext(whichfork);
 +			XFS_IFORK_NEXT_SET(ip, whichfork,
 +				XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
 +		} else {
 +			xfs_filblks_t	stolen;
 +			ASSERT(whichfork == XFS_DATA_FORK);
 +
 +			/*
 +			 * Distribute the original indlen reservation across the
 +			 * two new extents. Steal blocks from the deleted extent
 +			 * if necessary. Stealing blocks simply fudges the
 +			 * fdblocks accounting in xfs_bunmapi().
 +			 */
 +			temp = xfs_bmap_worst_indlen(ip, got.br_blockcount);
 +			temp2 = xfs_bmap_worst_indlen(ip, new.br_blockcount);
 +			stolen = xfs_bmap_split_indlen(da_old, &temp, &temp2,
 +						       del->br_blockcount);
 +			da_new = temp + temp2 - stolen;
 +			del->br_blockcount -= stolen;
 +
 +			/*
 +			 * Set the reservation for each extent. Warn if either
 +			 * is zero as this can lead to delalloc problems.
 +			 */
 +			WARN_ON_ONCE(!temp || !temp2);
 +			xfs_bmbt_set_startblock(ep, nullstartblock((int)temp));
 +			new.br_startblock = nullstartblock((int)temp2);
 +		}
++=======
+ 				/*
+ 				 * Update the btree record back
+ 				 * to the original value.
+ 				 */
+ 				error = xfs_bmbt_update(cur, &old);
+ 				if (error)
+ 					goto done;
+ 				/*
+ 				 * Reset the extent record back
+ 				 * to the original value.
+ 				 */
+ 				xfs_iext_update_extent(ifp, *idx, &old);
+ 				flags = 0;
+ 				error = -ENOSPC;
+ 				goto done;
+ 			}
+ 			XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
+ 		} else
+ 			flags |= xfs_ilog_fext(whichfork);
+ 		XFS_IFORK_NEXT_SET(ip, whichfork,
+ 			XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
++>>>>>>> a67d00a55507 (xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update)
  		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
  		xfs_iext_insert(ip, *idx + 1, 1, &new, state);
  		++*idx;
@@@ -5487,10 -5751,21 +5541,16 @@@ xfs_bmse_merge
  		return error;
  	XFS_WANT_CORRUPTED_RETURN(mp, i == 1);
  
++<<<<<<< HEAD
 +	left.br_blockcount = blockcount;
++=======
+ 	error = xfs_bmbt_update(cur, &new);
+ 	if (error)
+ 		return error;
++>>>>>>> a67d00a55507 (xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update)
  
 -done:
 -	xfs_iext_update_extent(ifp, current_ext - 1, &new);
 -	xfs_iext_remove(ip, current_ext, 1, 0);
 -
 -	/* update reverse mapping. rmap functions merge the rmaps for us */
 -	error = xfs_rmap_unmap_extent(mp, dfops, ip, whichfork, got);
 -	if (error)
 -		return error;
 -	memcpy(&new, got, sizeof(new));
 -	new.br_startoff = left->br_startoff + left->br_blockcount;
 -	return xfs_rmap_map_extent(mp, dfops, ip, whichfork, &new);
 +	return xfs_bmbt_update(cur, left.br_startoff, left.br_startblock,
 +			       left.br_blockcount, left.br_state);
  }
  
  /*
@@@ -5549,23 -5855,38 +5609,41 @@@ xfs_bmse_shift_one
  	 * Increment the extent index for the next iteration, update the start
  	 * offset of the in-core extent and update the btree if applicable.
  	 */
 -update_current_ext:
 +	(*current_ext)++;
 +	xfs_bmbt_set_startoff(gotp, startoff);
  	*logflags |= XFS_ILOG_CORE;
++<<<<<<< HEAD
 +	if (!cur) {
++=======
+ 
+ 	new = *got;
+ 	new.br_startoff = startoff;
+ 
+ 	if (cur) {
+ 		error = xfs_bmbt_lookup_eq(cur, got->br_startoff,
+ 				got->br_startblock, got->br_blockcount, &i);
+ 		if (error)
+ 			return error;
+ 		XFS_WANT_CORRUPTED_RETURN(mp, i == 1);
+ 
+ 		error = xfs_bmbt_update(cur, &new);
+ 		if (error)
+ 			return error;
+ 	} else {
++>>>>>>> a67d00a55507 (xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update)
  		*logflags |= XFS_ILOG_DEXT;
 +		return 0;
  	}
  
 -	xfs_iext_update_extent(ifp, *current_ext, &new);
 -
 -	if (direction == SHIFT_LEFT)
 -		(*current_ext)++;
 -	else
 -		(*current_ext)--;
 -
 -	/* update reverse mapping */
 -	error = xfs_rmap_unmap_extent(mp, dfops, ip, whichfork, got);
 +	error = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,
 +				   got.br_blockcount, &i);
  	if (error)
  		return error;
 -	return xfs_rmap_map_extent(mp, dfops, ip, whichfork, &new);
 +	XFS_WANT_CORRUPTED_RETURN(mp, i == 1);
 +
 +	got.br_startoff = startoff;
 +	return xfs_bmbt_update(cur, got.br_startoff, got.br_startblock,
 +				got.br_blockcount, got.br_state);
  }
  
  /*
@@@ -5684,3 -6050,306 +5762,309 @@@ del_cursor
  
  	return error;
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Splits an extent into two extents at split_fsb block such that it is
+  * the first block of the current_ext. @current_ext is a target extent
+  * to be split. @split_fsb is a block where the extents is split.
+  * If split_fsb lies in a hole or the first block of extents, just return 0.
+  */
+ STATIC int
+ xfs_bmap_split_extent_at(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	xfs_fileoff_t		split_fsb,
+ 	xfs_fsblock_t		*firstfsb,
+ 	struct xfs_defer_ops	*dfops)
+ {
+ 	int				whichfork = XFS_DATA_FORK;
+ 	struct xfs_btree_cur		*cur = NULL;
+ 	struct xfs_bmbt_irec		got;
+ 	struct xfs_bmbt_irec		new; /* split extent */
+ 	struct xfs_mount		*mp = ip->i_mount;
+ 	struct xfs_ifork		*ifp;
+ 	xfs_fsblock_t			gotblkcnt; /* new block count for got */
+ 	xfs_extnum_t			current_ext;
+ 	int				error = 0;
+ 	int				logflags = 0;
+ 	int				i = 0;
+ 
+ 	if (unlikely(XFS_TEST_ERROR(
+ 	    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&
+ 	     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),
+ 	     mp, XFS_ERRTAG_BMAPIFORMAT))) {
+ 		XFS_ERROR_REPORT("xfs_bmap_split_extent_at",
+ 				 XFS_ERRLEVEL_LOW, mp);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (XFS_FORCED_SHUTDOWN(mp))
+ 		return -EIO;
+ 
+ 	ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	if (!(ifp->if_flags & XFS_IFEXTENTS)) {
+ 		/* Read in all the extents */
+ 		error = xfs_iread_extents(tp, ip, whichfork);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/*
+ 	 * If there are not extents, or split_fsb lies in a hole we are done.
+ 	 */
+ 	if (!xfs_iext_lookup_extent(ip, ifp, split_fsb, &current_ext, &got) ||
+ 	    got.br_startoff >= split_fsb)
+ 		return 0;
+ 
+ 	gotblkcnt = split_fsb - got.br_startoff;
+ 	new.br_startoff = split_fsb;
+ 	new.br_startblock = got.br_startblock + gotblkcnt;
+ 	new.br_blockcount = got.br_blockcount - gotblkcnt;
+ 	new.br_state = got.br_state;
+ 
+ 	if (ifp->if_flags & XFS_IFBROOT) {
+ 		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
+ 		cur->bc_private.b.firstblock = *firstfsb;
+ 		cur->bc_private.b.dfops = dfops;
+ 		cur->bc_private.b.flags = 0;
+ 		error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
+ 				got.br_startblock,
+ 				got.br_blockcount,
+ 				&i);
+ 		if (error)
+ 			goto del_cursor;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 1, del_cursor);
+ 	}
+ 
+ 	got.br_blockcount = gotblkcnt;
+ 	xfs_iext_update_extent(ifp, current_ext, &got);
+ 
+ 	logflags = XFS_ILOG_CORE;
+ 	if (cur) {
+ 		error = xfs_bmbt_update(cur, &got);
+ 		if (error)
+ 			goto del_cursor;
+ 	} else
+ 		logflags |= XFS_ILOG_DEXT;
+ 
+ 	/* Add new extent */
+ 	current_ext++;
+ 	xfs_iext_insert(ip, current_ext, 1, &new, 0);
+ 	XFS_IFORK_NEXT_SET(ip, whichfork,
+ 			   XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
+ 
+ 	if (cur) {
+ 		error = xfs_bmbt_lookup_eq(cur, new.br_startoff,
+ 				new.br_startblock, new.br_blockcount,
+ 				&i);
+ 		if (error)
+ 			goto del_cursor;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 0, del_cursor);
+ 		cur->bc_rec.b.br_state = new.br_state;
+ 
+ 		error = xfs_btree_insert(cur, &i);
+ 		if (error)
+ 			goto del_cursor;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 1, del_cursor);
+ 	}
+ 
+ 	/*
+ 	 * Convert to a btree if necessary.
+ 	 */
+ 	if (xfs_bmap_needs_btree(ip, whichfork)) {
+ 		int tmp_logflags; /* partial log flag return val */
+ 
+ 		ASSERT(cur == NULL);
+ 		error = xfs_bmap_extents_to_btree(tp, ip, firstfsb, dfops,
+ 				&cur, 0, &tmp_logflags, whichfork);
+ 		logflags |= tmp_logflags;
+ 	}
+ 
+ del_cursor:
+ 	if (cur) {
+ 		cur->bc_private.b.allocated = 0;
+ 		xfs_btree_del_cursor(cur,
+ 				error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);
+ 	}
+ 
+ 	if (logflags)
+ 		xfs_trans_log_inode(tp, ip, logflags);
+ 	return error;
+ }
+ 
+ int
+ xfs_bmap_split_extent(
+ 	struct xfs_inode        *ip,
+ 	xfs_fileoff_t           split_fsb)
+ {
+ 	struct xfs_mount        *mp = ip->i_mount;
+ 	struct xfs_trans        *tp;
+ 	struct xfs_defer_ops    dfops;
+ 	xfs_fsblock_t           firstfsb;
+ 	int                     error;
+ 
+ 	error = xfs_trans_alloc(mp, &M_RES(mp)->tr_write,
+ 			XFS_DIOSTRAT_SPACE_RES(mp, 0), 0, 0, &tp);
+ 	if (error)
+ 		return error;
+ 
+ 	xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
+ 
+ 	xfs_defer_init(&dfops, &firstfsb);
+ 
+ 	error = xfs_bmap_split_extent_at(tp, ip, split_fsb,
+ 			&firstfsb, &dfops);
+ 	if (error)
+ 		goto out;
+ 
+ 	error = xfs_defer_finish(&tp, &dfops);
+ 	if (error)
+ 		goto out;
+ 
+ 	return xfs_trans_commit(tp);
+ 
+ out:
+ 	xfs_defer_cancel(&dfops);
+ 	xfs_trans_cancel(tp);
+ 	return error;
+ }
+ 
+ /* Deferred mapping is only for real extents in the data fork. */
+ static bool
+ xfs_bmap_is_update_needed(
+ 	struct xfs_bmbt_irec	*bmap)
+ {
+ 	return  bmap->br_startblock != HOLESTARTBLOCK &&
+ 		bmap->br_startblock != DELAYSTARTBLOCK;
+ }
+ 
+ /* Record a bmap intent. */
+ static int
+ __xfs_bmap_add(
+ 	struct xfs_mount		*mp,
+ 	struct xfs_defer_ops		*dfops,
+ 	enum xfs_bmap_intent_type	type,
+ 	struct xfs_inode		*ip,
+ 	int				whichfork,
+ 	struct xfs_bmbt_irec		*bmap)
+ {
+ 	int				error;
+ 	struct xfs_bmap_intent		*bi;
+ 
+ 	trace_xfs_bmap_defer(mp,
+ 			XFS_FSB_TO_AGNO(mp, bmap->br_startblock),
+ 			type,
+ 			XFS_FSB_TO_AGBNO(mp, bmap->br_startblock),
+ 			ip->i_ino, whichfork,
+ 			bmap->br_startoff,
+ 			bmap->br_blockcount,
+ 			bmap->br_state);
+ 
+ 	bi = kmem_alloc(sizeof(struct xfs_bmap_intent), KM_SLEEP | KM_NOFS);
+ 	INIT_LIST_HEAD(&bi->bi_list);
+ 	bi->bi_type = type;
+ 	bi->bi_owner = ip;
+ 	bi->bi_whichfork = whichfork;
+ 	bi->bi_bmap = *bmap;
+ 
+ 	error = xfs_defer_ijoin(dfops, bi->bi_owner);
+ 	if (error) {
+ 		kmem_free(bi);
+ 		return error;
+ 	}
+ 
+ 	xfs_defer_add(dfops, XFS_DEFER_OPS_TYPE_BMAP, &bi->bi_list);
+ 	return 0;
+ }
+ 
+ /* Map an extent into a file. */
+ int
+ xfs_bmap_map_extent(
+ 	struct xfs_mount	*mp,
+ 	struct xfs_defer_ops	*dfops,
+ 	struct xfs_inode	*ip,
+ 	struct xfs_bmbt_irec	*PREV)
+ {
+ 	if (!xfs_bmap_is_update_needed(PREV))
+ 		return 0;
+ 
+ 	return __xfs_bmap_add(mp, dfops, XFS_BMAP_MAP, ip,
+ 			XFS_DATA_FORK, PREV);
+ }
+ 
+ /* Unmap an extent out of a file. */
+ int
+ xfs_bmap_unmap_extent(
+ 	struct xfs_mount	*mp,
+ 	struct xfs_defer_ops	*dfops,
+ 	struct xfs_inode	*ip,
+ 	struct xfs_bmbt_irec	*PREV)
+ {
+ 	if (!xfs_bmap_is_update_needed(PREV))
+ 		return 0;
+ 
+ 	return __xfs_bmap_add(mp, dfops, XFS_BMAP_UNMAP, ip,
+ 			XFS_DATA_FORK, PREV);
+ }
+ 
+ /*
+  * Process one of the deferred bmap operations.  We pass back the
+  * btree cursor to maintain our lock on the bmapbt between calls.
+  */
+ int
+ xfs_bmap_finish_one(
+ 	struct xfs_trans		*tp,
+ 	struct xfs_defer_ops		*dfops,
+ 	struct xfs_inode		*ip,
+ 	enum xfs_bmap_intent_type	type,
+ 	int				whichfork,
+ 	xfs_fileoff_t			startoff,
+ 	xfs_fsblock_t			startblock,
+ 	xfs_filblks_t			*blockcount,
+ 	xfs_exntst_t			state)
+ {
+ 	xfs_fsblock_t			firstfsb;
+ 	int				error = 0;
+ 
+ 	/*
+ 	 * firstfsb is tied to the transaction lifetime and is used to
+ 	 * ensure correct AG locking order and schedule work item
+ 	 * continuations.  XFS_BUI_MAX_FAST_EXTENTS (== 1) restricts us
+ 	 * to only making one bmap call per transaction, so it should
+ 	 * be safe to have it as a local variable here.
+ 	 */
+ 	firstfsb = NULLFSBLOCK;
+ 
+ 	trace_xfs_bmap_deferred(tp->t_mountp,
+ 			XFS_FSB_TO_AGNO(tp->t_mountp, startblock), type,
+ 			XFS_FSB_TO_AGBNO(tp->t_mountp, startblock),
+ 			ip->i_ino, whichfork, startoff, *blockcount, state);
+ 
+ 	if (WARN_ON_ONCE(whichfork != XFS_DATA_FORK))
+ 		return -EFSCORRUPTED;
+ 
+ 	if (XFS_TEST_ERROR(false, tp->t_mountp,
+ 			XFS_ERRTAG_BMAP_FINISH_ONE))
+ 		return -EIO;
+ 
+ 	switch (type) {
+ 	case XFS_BMAP_MAP:
+ 		error = xfs_bmapi_remap(tp, ip, startoff, *blockcount,
+ 				startblock, dfops);
+ 		*blockcount = 0;
+ 		break;
+ 	case XFS_BMAP_UNMAP:
+ 		error = __xfs_bunmapi(tp, ip, startoff, blockcount,
+ 				XFS_BMAPI_REMAP, 1, &firstfsb, dfops);
+ 		break;
+ 	default:
+ 		ASSERT(0);
+ 		error = -EFSCORRUPTED;
+ 	}
+ 
+ 	return error;
+ }
++>>>>>>> a67d00a55507 (xfs: pass a struct xfs_bmbt_irec to xfs_bmbt_update)
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
diff --git a/fs/xfs/libxfs/xfs_bmap_btree.c b/fs/xfs/libxfs/xfs_bmap_btree.c
index da7cd00747be..1f79bf4e0bfc 100644
--- a/fs/xfs/libxfs/xfs_bmap_btree.c
+++ b/fs/xfs/libxfs/xfs_bmap_btree.c
@@ -227,47 +227,31 @@ xfs_bmbt_set_all(
 			     s->br_blockcount, s->br_state);
 }
 
-
 /*
- * Set all the fields in a disk format bmap extent record from the arguments.
+ * Set all the fields in a bmap extent record from the uncompressed form.
  */
 void
-xfs_bmbt_disk_set_allf(
-	xfs_bmbt_rec_t		*r,
-	xfs_fileoff_t		startoff,
-	xfs_fsblock_t		startblock,
-	xfs_filblks_t		blockcount,
-	xfs_exntst_t		state)
+xfs_bmbt_disk_set_all(
+	struct xfs_bmbt_rec	*r,
+	struct xfs_bmbt_irec	*s)
 {
-	int			extent_flag = (state == XFS_EXT_NORM) ? 0 : 1;
+	int			extent_flag = (s->br_state != XFS_EXT_NORM);
 
-	ASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);
-	ASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);
-	ASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);
-	ASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);
+	ASSERT(s->br_state == XFS_EXT_NORM || s->br_state == XFS_EXT_UNWRITTEN);
+	ASSERT(!(s->br_startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)));
+	ASSERT(!(s->br_blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)));
+	ASSERT(!(s->br_startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)));
 
 	r->l0 = cpu_to_be64(
 		((xfs_bmbt_rec_base_t)extent_flag << 63) |
-		 ((xfs_bmbt_rec_base_t)startoff << 9) |
-		 ((xfs_bmbt_rec_base_t)startblock >> 43));
+		 ((xfs_bmbt_rec_base_t)s->br_startoff << 9) |
+		 ((xfs_bmbt_rec_base_t)s->br_startblock >> 43));
 	r->l1 = cpu_to_be64(
-		((xfs_bmbt_rec_base_t)startblock << 21) |
-		 ((xfs_bmbt_rec_base_t)blockcount &
+		((xfs_bmbt_rec_base_t)s->br_startblock << 21) |
+		 ((xfs_bmbt_rec_base_t)s->br_blockcount &
 		  (xfs_bmbt_rec_base_t)xfs_mask64lo(21)));
 }
 
-/*
- * Set all the fields in a bmap extent record from the uncompressed form.
- */
-STATIC void
-xfs_bmbt_disk_set_all(
-	xfs_bmbt_rec_t	*r,
-	xfs_bmbt_irec_t *s)
-{
-	xfs_bmbt_disk_set_allf(r, s->br_startoff, s->br_startblock,
-				  s->br_blockcount, s->br_state);
-}
-
 /*
  * Set the blockcount field in a bmap extent record.
  */
diff --git a/fs/xfs/libxfs/xfs_bmap_btree.h b/fs/xfs/libxfs/xfs_bmap_btree.h
index e1de4743151d..965b4d16091d 100644
--- a/fs/xfs/libxfs/xfs_bmap_btree.h
+++ b/fs/xfs/libxfs/xfs_bmap_btree.h
@@ -106,6 +106,7 @@ extern xfs_fsblock_t xfs_bmbt_get_startblock(xfs_bmbt_rec_host_t *r);
 extern xfs_fileoff_t xfs_bmbt_get_startoff(xfs_bmbt_rec_host_t *r);
 extern xfs_exntst_t xfs_bmbt_get_state(xfs_bmbt_rec_host_t *r);
 
+void xfs_bmbt_disk_set_all(struct xfs_bmbt_rec *r, struct xfs_bmbt_irec *s);
 extern xfs_filblks_t xfs_bmbt_disk_get_blockcount(xfs_bmbt_rec_t *r);
 extern xfs_fileoff_t xfs_bmbt_disk_get_startoff(xfs_bmbt_rec_t *r);
 
@@ -117,9 +118,6 @@ extern void xfs_bmbt_set_startblock(xfs_bmbt_rec_host_t *r, xfs_fsblock_t v);
 extern void xfs_bmbt_set_startoff(xfs_bmbt_rec_host_t *r, xfs_fileoff_t v);
 extern void xfs_bmbt_set_state(xfs_bmbt_rec_host_t *r, xfs_exntst_t v);
 
-extern void xfs_bmbt_disk_set_allf(xfs_bmbt_rec_t *r, xfs_fileoff_t o,
-			xfs_fsblock_t b, xfs_filblks_t c, xfs_exntst_t v);
-
 extern void xfs_bmbt_to_bmdr(struct xfs_mount *, struct xfs_btree_block *, int,
 			xfs_bmdr_block_t *, int);
 
