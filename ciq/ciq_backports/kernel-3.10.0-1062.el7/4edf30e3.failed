perf bpf: Collect perf_evsel in BPF object files

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit 4edf30e39e6cff32390eaff6a1508969b3cd967b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4edf30e3.failed

This patch creates a 'struct perf_evsel' for every probe in a BPF object
file(s) and fills 'struct evlist' with them. The previously introduced
dummy event is now removed. After this patch, the following command:

 # perf record --event filter.o ls

Can trace on each of the probes defined in filter.o.

The core of this patch is bpf__foreach_tev(), which calls a callback
function for each 'struct probe_trace_event' event for a bpf program
with each associated file descriptors. The add_bpf_event() callback
creates evsels by calling parse_events_add_tracepoint().

Since bpf-loader.c will not be built if libbpf is turned off, an empty
bpf__foreach_tev() is defined in bpf-loader.h to avoid build errors.

Committer notes:

Before:

  # /tmp/oldperf record --event /tmp/foo.o -a usleep 1
  [ perf record: Woken up 1 times to write data ]
  [ perf record: Captured and wrote 0.198 MB perf.data ]
  # perf evlist
  /tmp/foo.o
  # perf evlist -v
  /tmp/foo.o: type: 1, size: 112, config: 0x9, { sample_period,
  sample_freq }: 4000, sample_type: IP|TID|TIME|CPU|PERIOD, disabled: 1,
  inherit: 1, mmap: 1, comm: 1, freq: 1, task: 1, sample_id_all: 1,
  exclude_guest: 1, mmap2: 1, comm_exec: 1

I.e. we create just the PERF_TYPE_SOFTWARE (type: 1),
PERF_COUNT_SW_DUMMY(config 0x9) event, now, with this patch:

  # perf record --event /tmp/foo.o -a usleep 1
  [ perf record: Woken up 1 times to write data ]
  [ perf record: Captured and wrote 0.210 MB perf.data ]
  # perf evlist -v
  perf_bpf_probe:fork: type: 2, size: 112, config: 0x6bd, { sample_period,
  sample_freq }: 1, sample_type: IP|TID|TIME|CPU|PERIOD|RAW, disabled: 1,
  inherit: 1, mmap: 1, comm: 1, task: 1, sample_id_all: 1, exclude_guest:
  1, mmap2: 1, comm_exec: 1
  #

We now have a PERF_TYPE_SOFTWARE (type: 1), but the config states 0x6bd,
which is how, after setting up the event via the kprobes interface, the
'perf_bpf_probe:fork' event is accessible via the perf_event_open
syscall. This is all transient, as soon as the 'perf record' session
ends, these probes will go away.

To see how it looks like, lets try doing a neverending session, one that
expects a control+C to end:

  # perf record --event /tmp/foo.o -a

So, with that in place, we can use 'perf probe' to see what is in place:

  # perf probe -l
    perf_bpf_probe:fork  (on _do_fork@acme/git/linux/kernel/fork.c)

We also can use debugfs:

  [root@felicio ~]# cat /sys/kernel/debug/tracing/kprobe_events
  p:perf_bpf_probe/fork _text+638512

Ok, now lets stop and see if we got some forks:

  [root@felicio linux]# perf record --event /tmp/foo.o -a
  ^C[ perf record: Woken up 1 times to write data ]
  [ perf record: Captured and wrote 0.325 MB perf.data (111 samples) ]

  [root@felicio linux]# perf script
      sshd  1271 [003] 81797.507678: perf_bpf_probe:fork: (ffffffff8109be30)
      sshd 18309 [000] 81797.524917: perf_bpf_probe:fork: (ffffffff8109be30)
      sshd 18309 [001] 81799.381603: perf_bpf_probe:fork: (ffffffff8109be30)
      sshd 18309 [001] 81799.408635: perf_bpf_probe:fork: (ffffffff8109be30)
  <SNIP>

Sure enough, we have 111 forks :-)

Callchains seems to work as well:

  # perf report --stdio --no-child
  # To display the perf.data header info, please use --header/--header-only options.
  #
  # Total Lost Samples: 0
  #
  # Samples: 562  of event 'perf_bpf_probe:fork'
  # Event count (approx.): 562
  #
  # Overhead  Command   Shared Object     Symbol
  # ........  ........  ................  ............
  #
      44.66%  sh        [kernel.vmlinux]  [k] _do_fork
                    |
                    ---_do_fork
                       entry_SYSCALL_64_fastpath
                       __libc_fork
                       make_child

    26.16%  make      [kernel.vmlinux]  [k] _do_fork
<SNIP>
  #

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexei Starovoitov <ast@plumgrid.com>
	Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
	Cc: Daniel Borkmann <daniel@iogearbox.net>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Kaixu Xia <xiakaixu@huawei.com>
	Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/1444826502-49291-7-git-send-email-wangnan0@huawei.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 4edf30e39e6cff32390eaff6a1508969b3cd967b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/bpf-loader.c
#	tools/perf/util/bpf-loader.h
#	tools/perf/util/parse-events.c
diff --cc tools/perf/util/bpf-loader.c
index ab56073c5d6e,aa784a498c48..000000000000
--- a/tools/perf/util/bpf-loader.c
+++ b/tools/perf/util/bpf-loader.c
@@@ -52,6 -58,282 +52,284 @@@ void bpf__clear(void
  {
  	struct bpf_object *obj, *tmp;
  
 -	bpf_object__for_each_safe(obj, tmp) {
 -		bpf__unprobe(obj);
 +	bpf_object__for_each_safe(obj, tmp)
  		bpf_object__close(obj);
++<<<<<<< HEAD
++=======
+ 	}
+ }
+ 
+ static void
+ bpf_prog_priv__clear(struct bpf_program *prog __maybe_unused,
+ 		     void *_priv)
+ {
+ 	struct bpf_prog_priv *priv = _priv;
+ 
+ 	cleanup_perf_probe_events(&priv->pev, 1);
+ 	free(priv);
+ }
+ 
+ static int
+ config_bpf_program(struct bpf_program *prog)
+ {
+ 	struct perf_probe_event *pev = NULL;
+ 	struct bpf_prog_priv *priv = NULL;
+ 	const char *config_str;
+ 	int err;
+ 
+ 	config_str = bpf_program__title(prog, false);
+ 	if (!config_str) {
+ 		pr_debug("bpf: unable to get title for program\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	priv = calloc(sizeof(*priv), 1);
+ 	if (!priv) {
+ 		pr_debug("bpf: failed to alloc priv\n");
+ 		return -ENOMEM;
+ 	}
+ 	pev = &priv->pev;
+ 
+ 	pr_debug("bpf: config program '%s'\n", config_str);
+ 	err = parse_perf_probe_command(config_str, pev);
+ 	if (err < 0) {
+ 		pr_debug("bpf: '%s' is not a valid config string\n",
+ 			 config_str);
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 
+ 	if (pev->group && strcmp(pev->group, PERF_BPF_PROBE_GROUP)) {
+ 		pr_debug("bpf: '%s': group for event is set and not '%s'.\n",
+ 			 config_str, PERF_BPF_PROBE_GROUP);
+ 		err = -EINVAL;
+ 		goto errout;
+ 	} else if (!pev->group)
+ 		pev->group = strdup(PERF_BPF_PROBE_GROUP);
+ 
+ 	if (!pev->group) {
+ 		pr_debug("bpf: strdup failed\n");
+ 		err = -ENOMEM;
+ 		goto errout;
+ 	}
+ 
+ 	if (!pev->event) {
+ 		pr_debug("bpf: '%s': event name is missing\n",
+ 			 config_str);
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 	pr_debug("bpf: config '%s' is ok\n", config_str);
+ 
+ 	err = bpf_program__set_private(prog, priv, bpf_prog_priv__clear);
+ 	if (err) {
+ 		pr_debug("Failed to set priv for program '%s'\n", config_str);
+ 		goto errout;
+ 	}
+ 
+ 	return 0;
+ 
+ errout:
+ 	if (pev)
+ 		clear_perf_probe_event(pev);
+ 	free(priv);
+ 	return err;
+ }
+ 
+ static int bpf__prepare_probe(void)
+ {
+ 	static int err = 0;
+ 	static bool initialized = false;
+ 
+ 	/*
+ 	 * Make err static, so if init failed the first, bpf__prepare_probe()
+ 	 * fails each time without calling init_probe_symbol_maps multiple
+ 	 * times.
+ 	 */
+ 	if (initialized)
+ 		return err;
+ 
+ 	initialized = true;
+ 	err = init_probe_symbol_maps(false);
+ 	if (err < 0)
+ 		pr_debug("Failed to init_probe_symbol_maps\n");
+ 	probe_conf.max_probes = MAX_PROBES;
+ 	return err;
+ }
+ 
+ int bpf__probe(struct bpf_object *obj)
+ {
+ 	int err = 0;
+ 	struct bpf_program *prog;
+ 	struct bpf_prog_priv *priv;
+ 	struct perf_probe_event *pev;
+ 
+ 	err = bpf__prepare_probe();
+ 	if (err) {
+ 		pr_debug("bpf__prepare_probe failed\n");
+ 		return err;
+ 	}
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		err = config_bpf_program(prog);
+ 		if (err)
+ 			goto out;
+ 
+ 		err = bpf_program__get_private(prog, (void **)&priv);
+ 		if (err || !priv)
+ 			goto out;
+ 		pev = &priv->pev;
+ 
+ 		err = convert_perf_probe_events(pev, 1);
+ 		if (err < 0) {
+ 			pr_debug("bpf_probe: failed to convert perf probe events");
+ 			goto out;
+ 		}
+ 
+ 		err = apply_perf_probe_events(pev, 1);
+ 		if (err < 0) {
+ 			pr_debug("bpf_probe: failed to apply perf probe events");
+ 			goto out;
+ 		}
+ 	}
+ out:
+ 	return err < 0 ? err : 0;
+ }
+ 
+ #define EVENTS_WRITE_BUFSIZE  4096
+ int bpf__unprobe(struct bpf_object *obj)
+ {
+ 	int err, ret = 0;
+ 	struct bpf_program *prog;
+ 	struct bpf_prog_priv *priv;
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		int i;
+ 
+ 		err = bpf_program__get_private(prog, (void **)&priv);
+ 		if (err || !priv)
+ 			continue;
+ 
+ 		for (i = 0; i < priv->pev.ntevs; i++) {
+ 			struct probe_trace_event *tev = &priv->pev.tevs[i];
+ 			char name_buf[EVENTS_WRITE_BUFSIZE];
+ 			struct strfilter *delfilter;
+ 
+ 			snprintf(name_buf, EVENTS_WRITE_BUFSIZE,
+ 				 "%s:%s", tev->group, tev->event);
+ 			name_buf[EVENTS_WRITE_BUFSIZE - 1] = '\0';
+ 
+ 			delfilter = strfilter__new(name_buf, NULL);
+ 			if (!delfilter) {
+ 				pr_debug("Failed to create filter for unprobing\n");
+ 				ret = -ENOMEM;
+ 				continue;
+ 			}
+ 
+ 			err = del_perf_probe_events(delfilter);
+ 			strfilter__delete(delfilter);
+ 			if (err) {
+ 				pr_debug("Failed to delete %s\n", name_buf);
+ 				ret = err;
+ 				continue;
+ 			}
+ 		}
+ 	}
+ 	return ret;
+ }
+ 
+ int bpf__load(struct bpf_object *obj)
+ {
+ 	int err;
+ 
+ 	err = bpf_object__load(obj);
+ 	if (err) {
+ 		pr_debug("bpf: load objects failed\n");
+ 		return err;
+ 	}
+ 	return 0;
+ }
+ 
+ int bpf__foreach_tev(struct bpf_object *obj,
+ 		     bpf_prog_iter_callback_t func,
+ 		     void *arg)
+ {
+ 	struct bpf_program *prog;
+ 	int err;
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		struct probe_trace_event *tev;
+ 		struct perf_probe_event *pev;
+ 		struct bpf_prog_priv *priv;
+ 		int i, fd;
+ 
+ 		err = bpf_program__get_private(prog,
+ 				(void **)&priv);
+ 		if (err || !priv) {
+ 			pr_debug("bpf: failed to get private field\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		pev = &priv->pev;
+ 		for (i = 0; i < pev->ntevs; i++) {
+ 			tev = &pev->tevs[i];
+ 
+ 			fd = bpf_program__fd(prog);
+ 			if (fd < 0) {
+ 				pr_debug("bpf: failed to get file descriptor\n");
+ 				return fd;
+ 			}
+ 
+ 			err = (*func)(tev, fd, arg);
+ 			if (err) {
+ 				pr_debug("bpf: call back failed, stop iterate\n");
+ 				return err;
+ 			}
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ #define bpf__strerror_head(err, buf, size) \
+ 	char sbuf[STRERR_BUFSIZE], *emsg;\
+ 	if (!size)\
+ 		return 0;\
+ 	if (err < 0)\
+ 		err = -err;\
+ 	emsg = strerror_r(err, sbuf, sizeof(sbuf));\
+ 	switch (err) {\
+ 	default:\
+ 		scnprintf(buf, size, "%s", emsg);\
+ 		break;
+ 
+ #define bpf__strerror_entry(val, fmt...)\
+ 	case val: {\
+ 		scnprintf(buf, size, fmt);\
+ 		break;\
+ 	}
+ 
+ #define bpf__strerror_end(buf, size)\
+ 	}\
+ 	buf[size - 1] = '\0';
+ 
+ int bpf__strerror_probe(struct bpf_object *obj __maybe_unused,
+ 			int err, char *buf, size_t size)
+ {
+ 	bpf__strerror_head(err, buf, size);
+ 	bpf__strerror_entry(EEXIST, "Probe point exist. Try use 'perf probe -d \"*\"'");
+ 	bpf__strerror_entry(EPERM, "You need to be root, and /proc/sys/kernel/kptr_restrict should be 0\n");
+ 	bpf__strerror_entry(ENOENT, "You need to check probing points in BPF file\n");
+ 	bpf__strerror_end(buf, size);
+ 	return 0;
+ }
+ 
+ int bpf__strerror_load(struct bpf_object *obj __maybe_unused,
+ 		       int err, char *buf, size_t size)
+ {
+ 	bpf__strerror_head(err, buf, size);
+ 	bpf__strerror_entry(EINVAL, "%s: Are you root and runing a CONFIG_BPF_SYSCALL kernel?",
+ 			    emsg)
+ 	bpf__strerror_end(buf, size);
+ 	return 0;
++>>>>>>> 4edf30e39e6c (perf bpf: Collect perf_evsel in BPF object files)
  }
diff --cc tools/perf/util/bpf-loader.h
index f402d7c8c288,a8f25ee06fc5..000000000000
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@@ -11,11 -12,26 +12,28 @@@
  #include "debug.h"
  
  struct bpf_object;
 -#define PERF_BPF_PROBE_GROUP "perf_bpf_probe"
  
+ typedef int (*bpf_prog_iter_callback_t)(struct probe_trace_event *tev,
+ 					int fd, void *arg);
+ 
  #ifdef HAVE_LIBBPF_SUPPORT
  struct bpf_object *bpf__prepare_load(const char *filename);
  
  void bpf__clear(void);
++<<<<<<< HEAD
++=======
+ 
+ int bpf__probe(struct bpf_object *obj);
+ int bpf__unprobe(struct bpf_object *obj);
+ int bpf__strerror_probe(struct bpf_object *obj, int err,
+ 			char *buf, size_t size);
+ 
+ int bpf__load(struct bpf_object *obj);
+ int bpf__strerror_load(struct bpf_object *obj, int err,
+ 		       char *buf, size_t size);
+ int bpf__foreach_tev(struct bpf_object *obj,
+ 		     bpf_prog_iter_callback_t func, void *arg);
++>>>>>>> 4edf30e39e6c (perf bpf: Collect perf_evsel in BPF object files)
  #else
  static inline struct bpf_object *
  bpf__prepare_load(const char *filename __maybe_unused)
@@@ -25,5 -41,44 +43,47 @@@
  }
  
  static inline void bpf__clear(void) { }
++<<<<<<< HEAD
++=======
+ 
+ static inline int bpf__probe(struct bpf_object *obj __maybe_unused) { return 0;}
+ static inline int bpf__unprobe(struct bpf_object *obj __maybe_unused) { return 0;}
+ static inline int bpf__load(struct bpf_object *obj __maybe_unused) { return 0; }
+ 
+ static inline int
+ bpf__foreach_tev(struct bpf_object *obj __maybe_unused,
+ 		 bpf_prog_iter_callback_t func __maybe_unused,
+ 		 void *arg __maybe_unused)
+ {
+ 	return 0;
+ }
+ 
+ static inline int
+ __bpf_strerror(char *buf, size_t size)
+ {
+ 	if (!size)
+ 		return 0;
+ 	strncpy(buf,
+ 		"ERROR: eBPF object loading is disabled during compiling.\n",
+ 		size);
+ 	buf[size - 1] = '\0';
+ 	return 0;
+ }
+ 
+ static inline int
+ bpf__strerror_probe(struct bpf_object *obj __maybe_unused,
+ 		    int err __maybe_unused,
+ 		    char *buf, size_t size)
+ {
+ 	return __bpf_strerror(buf, size);
+ }
+ 
+ static inline int bpf__strerror_load(struct bpf_object *obj __maybe_unused,
+ 				     int err __maybe_unused,
+ 				     char *buf, size_t size)
+ {
+ 	return __bpf_strerror(buf, size);
+ }
++>>>>>>> 4edf30e39e6c (perf bpf: Collect perf_evsel in BPF object files)
  #endif
  #endif
diff --cc tools/perf/util/parse-events.c
index 3a234b74d6ff,d97b03710331..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -590,6 -530,123 +590,126 @@@ static int add_tracepoint_multi_sys(str
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ struct __add_bpf_event_param {
+ 	struct parse_events_evlist *data;
+ 	struct list_head *list;
+ };
+ 
+ static int add_bpf_event(struct probe_trace_event *tev, int fd,
+ 			 void *_param)
+ {
+ 	LIST_HEAD(new_evsels);
+ 	struct __add_bpf_event_param *param = _param;
+ 	struct parse_events_evlist *evlist = param->data;
+ 	struct list_head *list = param->list;
+ 	int err;
+ 
+ 	pr_debug("add bpf event %s:%s and attach bpf program %d\n",
+ 		 tev->group, tev->event, fd);
+ 
+ 	err = parse_events_add_tracepoint(&new_evsels, &evlist->idx, tev->group,
+ 					  tev->event, evlist->error, NULL);
+ 	if (err) {
+ 		struct perf_evsel *evsel, *tmp;
+ 
+ 		pr_debug("Failed to add BPF event %s:%s\n",
+ 			 tev->group, tev->event);
+ 		list_for_each_entry_safe(evsel, tmp, &new_evsels, node) {
+ 			list_del(&evsel->node);
+ 			perf_evsel__delete(evsel);
+ 		}
+ 		return err;
+ 	}
+ 	pr_debug("adding %s:%s\n", tev->group, tev->event);
+ 
+ 	list_splice(&new_evsels, list);
+ 	return 0;
+ }
+ 
+ int parse_events_load_bpf_obj(struct parse_events_evlist *data,
+ 			      struct list_head *list,
+ 			      struct bpf_object *obj)
+ {
+ 	int err;
+ 	char errbuf[BUFSIZ];
+ 	struct __add_bpf_event_param param = {data, list};
+ 	static bool registered_unprobe_atexit = false;
+ 
+ 	if (IS_ERR(obj) || !obj) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Internal error: load bpf obj with NULL");
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 
+ 	/*
+ 	 * Register atexit handler before calling bpf__probe() so
+ 	 * bpf__probe() don't need to unprobe probe points its already
+ 	 * created when failure.
+ 	 */
+ 	if (!registered_unprobe_atexit) {
+ 		atexit(bpf__clear);
+ 		registered_unprobe_atexit = true;
+ 	}
+ 
+ 	err = bpf__probe(obj);
+ 	if (err) {
+ 		bpf__strerror_probe(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__load(obj);
+ 	if (err) {
+ 		bpf__strerror_load(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__foreach_tev(obj, add_bpf_event, &param);
+ 	if (err) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Attach events in BPF object failed");
+ 		goto errout;
+ 	}
+ 
+ 	return 0;
+ errout:
+ 	data->error->help = strdup("(add -v to see detail)");
+ 	data->error->str = strdup(errbuf);
+ 	return err;
+ }
+ 
+ int parse_events_load_bpf(struct parse_events_evlist *data,
+ 			  struct list_head *list,
+ 			  char *bpf_file_name)
+ {
+ 	struct bpf_object *obj;
+ 
+ 	obj = bpf__prepare_load(bpf_file_name);
+ 	if (IS_ERR(obj) || !obj) {
+ 		char errbuf[BUFSIZ];
+ 		int err;
+ 
+ 		err = obj ? PTR_ERR(obj) : -EINVAL;
+ 
+ 		if (err == -ENOTSUP)
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "BPF support is not compiled");
+ 		else
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "BPF object file '%s' is invalid",
+ 				 bpf_file_name);
+ 
+ 		data->error->help = strdup("(add -v to see detail)");
+ 		data->error->str = strdup(errbuf);
+ 		return err;
+ 	}
+ 
+ 	return parse_events_load_bpf_obj(data, list, obj);
+ }
+ 
++>>>>>>> 4edf30e39e6c (perf bpf: Collect perf_evsel in BPF object files)
  static int
  parse_breakpoint_type(const char *type, struct perf_event_attr *attr)
  {
* Unmerged path tools/perf/util/bpf-loader.c
* Unmerged path tools/perf/util/bpf-loader.h
* Unmerged path tools/perf/util/parse-events.c
