ext4: limit xattr size to INT_MAX

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eric Biggers <ebiggers@google.com>
commit ce3fd194fcc6fbdc00ce095a852f22df97baa401
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ce3fd194.failed

ext4 isn't validating the sizes of xattrs where the value of the xattr
is stored in an external inode.  This is problematic because
->e_value_size is a u32, but ext4_xattr_get() returns an int.  A very
large size is misinterpreted as an error code, which ext4_get_acl()
translates into a bogus ERR_PTR() for which IS_ERR() returns false,
causing a crash.

Fix this by validating that all xattrs are <= INT_MAX bytes.

This issue has been assigned CVE-2018-1095.

https://bugzilla.kernel.org/show_bug.cgi?id=199185
https://bugzilla.redhat.com/show_bug.cgi?id=1560793

	Reported-by: Wen Xu <wen.xu@gatech.edu>
	Signed-off-by: Eric Biggers <ebiggers@google.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@vger.kernel.org
Fixes: e50e5129f384 ("ext4: xattr-in-inode support")
(cherry picked from commit ce3fd194fcc6fbdc00ce095a852f22df97baa401)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/xattr.c
diff --cc fs/ext4/xattr.c
index ef6e269c5f10,2077d87b09f2..000000000000
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@@ -199,15 -193,31 +199,41 @@@ ext4_xattr_check_names(struct ext4_xatt
  		e = next;
  	}
  
 -	/* Check the values */
  	while (!IS_LAST_ENTRY(entry)) {
++<<<<<<< HEAD
 +		if (entry->e_value_block != 0)
 +			return -EFSCORRUPTED;
 +		if (entry->e_value_size != 0 &&
 +		    (value_start + le16_to_cpu(entry->e_value_offs) <
 +		     (void *)e + sizeof(__u32) ||
 +		     value_start + le16_to_cpu(entry->e_value_offs) +
 +		    le32_to_cpu(entry->e_value_size) > end))
 +			return -EIO;
++=======
+ 		u32 size = le32_to_cpu(entry->e_value_size);
+ 
+ 		if (size > INT_MAX)
+ 			return -EFSCORRUPTED;
+ 
+ 		if (size != 0 && entry->e_value_inum == 0) {
+ 			u16 offs = le16_to_cpu(entry->e_value_offs);
+ 			void *value;
+ 
+ 			/*
+ 			 * The value cannot overlap the names, and the value
+ 			 * with padding cannot extend beyond 'end'.  Check both
+ 			 * the padded and unpadded sizes, since the size may
+ 			 * overflow to 0 when adding padding.
+ 			 */
+ 			if (offs > end - value_start)
+ 				return -EFSCORRUPTED;
+ 			value = value_start + offs;
+ 			if (value < (void *)e + sizeof(u32) ||
+ 			    size > end - value ||
+ 			    EXT4_XATTR_SIZE(size) > end - value)
+ 				return -EFSCORRUPTED;
+ 		}
++>>>>>>> ce3fd194fcc6 (ext4: limit xattr size to INT_MAX)
  		entry = EXT4_XATTR_NEXT(entry);
  	}
  
* Unmerged path fs/ext4/xattr.c
