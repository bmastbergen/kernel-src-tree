mm/fault, arch: Use pagefault_disable() to check for disabled pagefaults in the handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author David Hildenbrand <dahi@linux.vnet.ibm.com>
commit 70ffdb9393a7264a069265edded729078dcf0425
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/70ffdb93.failed

Introduce faulthandler_disabled() and use it to check for irq context and
disabled pagefaults (via pagefault_disable()) in the pagefault handlers.

Please note that we keep the in_atomic() checks in place - to detect
whether in irq context (in which case preemption is always properly
disabled).

In contrast, preempt_disable() should never be used to disable pagefaults.
With !CONFIG_PREEMPT_COUNT, preempt_disable() doesn't modify the preempt
counter, and therefore the result of in_atomic() differs.
We validate that condition by using might_fault() checks when calling
might_sleep().

Therefore, add a comment to faulthandler_disabled(), describing why this
is needed.

faulthandler_disabled() and pagefault_disable() are defined in
linux/uaccess.h, so let's properly add that include to all relevant files.

This patch is based on a patch from Thomas Gleixner.

Reviewed-and-tested-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: David Hildenbrand <dahi@linux.vnet.ibm.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: David.Laight@ACULAB.COM
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: airlied@linux.ie
	Cc: akpm@linux-foundation.org
	Cc: benh@kernel.crashing.org
	Cc: bigeasy@linutronix.de
	Cc: borntraeger@de.ibm.com
	Cc: daniel.vetter@intel.com
	Cc: heiko.carstens@de.ibm.com
	Cc: herbert@gondor.apana.org.au
	Cc: hocko@suse.cz
	Cc: hughd@google.com
	Cc: mst@redhat.com
	Cc: paulus@samba.org
	Cc: ralf@linux-mips.org
	Cc: schwidefsky@de.ibm.com
	Cc: yang.shi@windriver.com
Link: http://lkml.kernel.org/r/1431359540-32227-7-git-send-email-dahi@linux.vnet.ibm.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 70ffdb9393a7264a069265edded729078dcf0425)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/nios2/mm/fault.c
#	arch/parisc/kernel/traps.c
#	arch/parisc/mm/fault.c
#	arch/sparc/mm/fault_64.c
#	arch/x86/mm/fault.c
#	include/linux/uaccess.h
diff --cc arch/parisc/kernel/traps.c
index b3f87a3b4bce,6548fd1d2e62..000000000000
--- a/arch/parisc/kernel/traps.c
+++ b/arch/parisc/kernel/traps.c
@@@ -25,9 -25,10 +25,13 @@@
  #include <linux/interrupt.h>
  #include <linux/console.h>
  #include <linux/bug.h>
++<<<<<<< HEAD
++=======
+ #include <linux/ratelimit.h>
+ #include <linux/uaccess.h>
++>>>>>>> 70ffdb9393a7 (mm/fault, arch: Use pagefault_disable() to check for disabled pagefaults in the handler)
  
  #include <asm/assembly.h>
- #include <asm/uaccess.h>
  #include <asm/io.h>
  #include <asm/irq.h>
  #include <asm/traps.h>
diff --cc arch/parisc/mm/fault.c
index d35ef55a999c,15503adddf4f..000000000000
--- a/arch/parisc/mm/fault.c
+++ b/arch/parisc/mm/fault.c
@@@ -15,14 -15,10 +15,14 @@@
  #include <linux/sched.h>
  #include <linux/interrupt.h>
  #include <linux/module.h>
+ #include <linux/uaccess.h>
  
- #include <asm/uaccess.h>
  #include <asm/traps.h>
  
 +#define PRINT_USER_FAULTS /* (turn this on if you want user faults to be */
 +			 /*  dumped to the console via printk)          */
 +
 +
  /* Various important other fields */
  #define bit22set(x)		(x & 0x00000200)
  #define bits23_25set(x)		(x & 0x000001c0)
@@@ -171,15 -201,27 +171,19 @@@ void do_page_fault(struct pt_regs *regs
  			      unsigned long address)
  {
  	struct vm_area_struct *vma, *prev_vma;
 -	struct task_struct *tsk;
 -	struct mm_struct *mm;
 +	struct task_struct *tsk = current;
 +	struct mm_struct *mm = tsk->mm;
  	unsigned long acc_type;
  	int fault;
 -	unsigned int flags;
 +	unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;
  
++<<<<<<< HEAD
 +	if (in_atomic() || !mm)
++=======
+ 	if (pagefault_disabled())
++>>>>>>> 70ffdb9393a7 (mm/fault, arch: Use pagefault_disable() to check for disabled pagefaults in the handler)
  		goto no_context;
  
 -	tsk = current;
 -	mm = tsk->mm;
 -	if (!mm)
 -		goto no_context;
 -
 -	flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;
 -	if (user_mode(regs))
 -		flags |= FAULT_FLAG_USER;
 -
 -	acc_type = parisc_acctyp(code, regs->iir);
 -	if (acc_type & VM_WRITE)
 -		flags |= FAULT_FLAG_WRITE;
  retry:
  	down_read(&mm->mmap_sem);
  	vma = find_vma_prev(mm, address, &prev_vma);
diff --cc arch/sparc/mm/fault_64.c
index 32f48cc82c88,e9268ea1a68d..000000000000
--- a/arch/sparc/mm/fault_64.c
+++ b/arch/sparc/mm/fault_64.c
@@@ -21,6 -21,8 +21,11 @@@
  #include <linux/kprobes.h>
  #include <linux/kdebug.h>
  #include <linux/percpu.h>
++<<<<<<< HEAD
++=======
+ #include <linux/context_tracking.h>
+ #include <linux/uaccess.h>
++>>>>>>> 70ffdb9393a7 (mm/fault, arch: Use pagefault_disable() to check for disabled pagefaults in the handler)
  
  #include <asm/page.h>
  #include <asm/pgtable.h>
diff --cc arch/x86/mm/fault.c
index afbf23e0599d,9dc909841739..000000000000
--- a/arch/x86/mm/fault.c
+++ b/arch/x86/mm/fault.c
@@@ -14,8 -13,8 +14,9 @@@
  #include <linux/hugetlb.h>		/* hstate_index_to_shift	*/
  #include <linux/prefetch.h>		/* prefetchw			*/
  #include <linux/context_tracking.h>	/* exception_enter(), ...	*/
+ #include <linux/uaccess.h>		/* faulthandler_disabled()	*/
  
 +#include <asm/cpufeature.h>		/* boot_cpu_has, ...		*/
  #include <asm/traps.h>			/* dotraplinkage, ...		*/
  #include <asm/pgalloc.h>		/* pgd_*(), ...			*/
  #include <asm/kmemcheck.h>		/* kmemcheck_*(), ...		*/
@@@ -1189,10 -1127,10 +1190,15 @@@ __do_page_fault(struct pt_regs *regs, u
  
  	/*
  	 * If we're in an interrupt, have no user context or are running
- 	 * in an atomic region then we must not take the fault:
+ 	 * in a region with pagefaults disabled then we must not take the fault
  	 */
++<<<<<<< HEAD
 +	if (unlikely(in_atomic() || !mm)) {
 +		bad_area_nosemaphore(regs, error_code, address, NULL);
++=======
+ 	if (unlikely(faulthandler_disabled() || !mm)) {
+ 		bad_area_nosemaphore(regs, error_code, address);
++>>>>>>> 70ffdb9393a7 (mm/fault, arch: Use pagefault_disable() to check for disabled pagefaults in the handler)
  		return;
  	}
  
diff --cc include/linux/uaccess.h
index 0497c0dedb93,90786d2d74e5..000000000000
--- a/include/linux/uaccess.h
+++ b/include/linux/uaccess.h
@@@ -33,14 -46,31 +33,34 @@@ static inline void pagefault_enable(voi
  	 * the pagefault handler again.
  	 */
  	barrier();
 -	pagefault_disabled_dec();
 -#ifndef CONFIG_PREEMPT
 -	preempt_count_dec();
 -#else
 -	preempt_enable();
 -#endif
 +	dec_preempt_count();
 +	/*
 +	 * make sure we do..
 +	 */
 +	barrier();
 +	preempt_check_resched();
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Is the pagefault handler disabled? If so, user access methods will not sleep.
+  */
+ #define pagefault_disabled() (current->pagefault_disabled != 0)
+ 
+ /*
+  * The pagefault handler is in general disabled by pagefault_disable() or
+  * when in irq context (via in_atomic()).
+  *
+  * This function should only be used by the fault handlers. Other users should
+  * stick to pagefault_disabled().
+  * Please NEVER use preempt_disable() to disable the fault handler. With
+  * !CONFIG_PREEMPT_COUNT, this is like a NOP. So the handler won't be disabled.
+  * in_atomic() will report different values based on !CONFIG_PREEMPT_COUNT.
+  */
+ #define faulthandler_disabled() (pagefault_disabled() || in_atomic())
+ 
++>>>>>>> 70ffdb9393a7 (mm/fault, arch: Use pagefault_disable() to check for disabled pagefaults in the handler)
  #ifndef ARCH_HAS_NOCACHE_UACCESS
  
  static inline unsigned long __copy_from_user_inatomic_nocache(void *to,
* Unmerged path arch/nios2/mm/fault.c
diff --git a/arch/alpha/mm/fault.c b/arch/alpha/mm/fault.c
index aa1346e9b717..fd448bf0dc17 100644
--- a/arch/alpha/mm/fault.c
+++ b/arch/alpha/mm/fault.c
@@ -23,8 +23,7 @@
 #include <linux/smp.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
-
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 extern void die_if_kernel(char *,struct pt_regs *,long, unsigned long *);
 
@@ -108,7 +107,7 @@ do_page_fault(unsigned long address, unsigned long mmcsr,
 
 	/* If we're in an interrupt context, or have no user context,
 	   we must not take the fault.  */
-	if (!mm || in_atomic())
+	if (!mm || faulthandler_disabled())
 		goto no_context;
 
 #ifdef CONFIG_ALPHA_LARGE_VMALLOC
diff --git a/arch/arc/mm/fault.c b/arch/arc/mm/fault.c
index d04defca5856..464ddfc4c51c 100644
--- a/arch/arc/mm/fault.c
+++ b/arch/arc/mm/fault.c
@@ -85,7 +85,7 @@ void do_page_fault(struct pt_regs *regs, int write, unsigned long address,
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
-	if (in_atomic() || !mm)
+	if (faulthandler_disabled() || !mm)
 		goto no_context;
 
 retry:
diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c
index 9ee0cc0d57b6..e20621fa3dd2 100644
--- a/arch/arm/mm/fault.c
+++ b/arch/arm/mm/fault.c
@@ -279,7 +279,7 @@ do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
-	if (in_atomic() || !mm)
+	if (faulthandler_disabled() || !mm)
 		goto no_context;
 
 	/*
diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c
index d06496abfdb4..052eee49a6a6 100644
--- a/arch/arm64/mm/fault.c
+++ b/arch/arm64/mm/fault.c
@@ -217,7 +217,7 @@ static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,
 	 * If we're in an interrupt or have no user context, we must not take
 	 * the fault.
 	 */
-	if (in_atomic() || !mm)
+	if (faulthandler_disabled() || !mm)
 		goto no_context;
 
 	/*
diff --git a/arch/avr32/mm/fault.c b/arch/avr32/mm/fault.c
index 583503dcfb1c..fae3da2b1e56 100644
--- a/arch/avr32/mm/fault.c
+++ b/arch/avr32/mm/fault.c
@@ -14,11 +14,11 @@
 #include <linux/pagemap.h>
 #include <linux/kdebug.h>
 #include <linux/kprobes.h>
+#include <linux/uaccess.h>
 
 #include <asm/mmu_context.h>
 #include <asm/sysreg.h>
 #include <asm/tlb.h>
-#include <asm/uaccess.h>
 
 #ifdef CONFIG_KPROBES
 static inline int notify_page_fault(struct pt_regs *regs, int trap)
@@ -81,7 +81,7 @@ asmlinkage void do_page_fault(unsigned long ecr, struct pt_regs *regs)
 	 * If we're in an interrupt or have no user context, we must
 	 * not take the fault...
 	 */
-	if (in_atomic() || !mm || regs->sr & SYSREG_BIT(GM))
+	if (faulthandler_disabled() || !mm || regs->sr & SYSREG_BIT(GM))
 		goto no_context;
 
 	local_irq_enable();
diff --git a/arch/cris/mm/fault.c b/arch/cris/mm/fault.c
index 4e5531bc44af..ebca5abafb37 100644
--- a/arch/cris/mm/fault.c
+++ b/arch/cris/mm/fault.c
@@ -8,7 +8,7 @@
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/wait.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <arch/system.h>
 
 extern int find_fixup_code(struct pt_regs *);
@@ -110,11 +110,11 @@ do_page_fault(unsigned long address, struct pt_regs *regs,
 	info.si_code = SEGV_MAPERR;
 
 	/*
-	 * If we're in an interrupt or "atomic" operation or have no
+	 * If we're in an interrupt, have pagefaults disabled or have no
 	 * user context, we must not take the fault.
 	 */
 
-	if (in_atomic() || !mm)
+	if (faulthandler_disabled() || !mm)
 		goto no_context;
 
 retry:
diff --git a/arch/frv/mm/fault.c b/arch/frv/mm/fault.c
index 74fc511ffc12..314464a36dbb 100644
--- a/arch/frv/mm/fault.c
+++ b/arch/frv/mm/fault.c
@@ -19,9 +19,9 @@
 #include <linux/kernel.h>
 #include <linux/ptrace.h>
 #include <linux/hardirq.h>
+#include <linux/uaccess.h>
 
 #include <asm/pgtable.h>
-#include <asm/uaccess.h>
 #include <asm/gdb-stub.h>
 
 /*****************************************************************************/
@@ -78,7 +78,7 @@ asmlinkage void do_page_fault(int datammu, unsigned long esr0, unsigned long ear
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
-	if (in_atomic() || !mm)
+	if (faulthandler_disabled() || !mm)
 		goto no_context;
 
 	down_read(&mm->mmap_sem);
diff --git a/arch/ia64/mm/fault.c b/arch/ia64/mm/fault.c
index 9c47b409482b..5f7728f1784e 100644
--- a/arch/ia64/mm/fault.c
+++ b/arch/ia64/mm/fault.c
@@ -11,10 +11,10 @@
 #include <linux/kprobes.h>
 #include <linux/kdebug.h>
 #include <linux/prefetch.h>
+#include <linux/uaccess.h>
 
 #include <asm/pgtable.h>
 #include <asm/processor.h>
-#include <asm/uaccess.h>
 
 extern int die(char *, struct pt_regs *, long);
 
@@ -98,7 +98,7 @@ ia64_do_page_fault (unsigned long address, unsigned long isr, struct pt_regs *re
 	/*
 	 * If we're in an interrupt or have no user context, we must not take the fault..
 	 */
-	if (in_atomic() || !mm)
+	if (faulthandler_disabled() || !mm)
 		goto no_context;
 
 #ifdef CONFIG_VIRTUAL_MEM_MAP
diff --git a/arch/m32r/mm/fault.c b/arch/m32r/mm/fault.c
index 19e3698a4299..63b63d243666 100644
--- a/arch/m32r/mm/fault.c
+++ b/arch/m32r/mm/fault.c
@@ -24,9 +24,9 @@
 #include <linux/vt_kern.h>		/* For unblank_screen() */
 #include <linux/highmem.h>
 #include <linux/module.h>
+#include <linux/uaccess.h>
 
 #include <asm/m32r.h>
-#include <asm/uaccess.h>
 #include <asm/hardirq.h>
 #include <asm/mmu_context.h>
 #include <asm/tlbflush.h>
@@ -111,10 +111,10 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code,
 	mm = tsk->mm;
 
 	/*
-	 * If we're in an interrupt or have no user context or are running in an
-	 * atomic region then we must not take the fault..
+	 * If we're in an interrupt or have no user context or have pagefaults
+	 * disabled then we must not take the fault.
 	 */
-	if (in_atomic() || !mm)
+	if (faulthandler_disabled() || !mm)
 		goto bad_area_nosemaphore;
 
 	/* When running in the kernel we expect faults to occur only to
diff --git a/arch/m68k/mm/fault.c b/arch/m68k/mm/fault.c
index e77567d7f69e..79c83ed47568 100644
--- a/arch/m68k/mm/fault.c
+++ b/arch/m68k/mm/fault.c
@@ -10,10 +10,10 @@
 #include <linux/ptrace.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/uaccess.h>
 
 #include <asm/setup.h>
 #include <asm/traps.h>
-#include <asm/uaccess.h>
 #include <asm/pgalloc.h>
 
 extern void die_if_kernel(char *, struct pt_regs *, long);
@@ -85,7 +85,7 @@ int do_page_fault(struct pt_regs *regs, unsigned long address,
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
-	if (in_atomic() || !mm)
+	if (faulthandler_disabled() || !mm)
 		goto no_context;
 
 retry:
diff --git a/arch/metag/mm/fault.c b/arch/metag/mm/fault.c
index 53ffb1bb380c..1faebdd5e3e5 100644
--- a/arch/metag/mm/fault.c
+++ b/arch/metag/mm/fault.c
@@ -106,7 +106,7 @@ int do_page_fault(struct pt_regs *regs, unsigned long address,
 
 	mm = tsk->mm;
 
-	if (in_atomic() || !mm)
+	if (faulthandler_disabled() || !mm)
 		goto no_context;
 
 retry:
diff --git a/arch/microblaze/mm/fault.c b/arch/microblaze/mm/fault.c
index eb965dfcc63a..5e31970a084a 100644
--- a/arch/microblaze/mm/fault.c
+++ b/arch/microblaze/mm/fault.c
@@ -108,14 +108,14 @@ void do_page_fault(struct pt_regs *regs, unsigned long address,
 	if ((error_code & 0x13) == 0x13 || (error_code & 0x11) == 0x11)
 		is_write = 0;
 
-	if (unlikely(in_atomic() || !mm)) {
+	if (unlikely(faulthandler_disabled() || !mm)) {
 		if (kernel_mode(regs))
 			goto bad_area_nosemaphore;
 
-		/* in_atomic() in user mode is really bad,
+		/* faulthandler_disabled() in user mode is really bad,
 		   as is current->mm == NULL. */
-		pr_emerg("Page fault in user mode with in_atomic(), mm = %p\n",
-									mm);
+		pr_emerg("Page fault in user mode with faulthandler_disabled(), mm = %p\n",
+			 mm);
 		pr_emerg("r15 = %lx  MSR = %lx\n",
 		       regs->r15, regs->msr);
 		die("Weird page fault", regs, SIGSEGV);
diff --git a/arch/mips/mm/fault.c b/arch/mips/mm/fault.c
index 407f6be1b588..6a599d8c8202 100644
--- a/arch/mips/mm/fault.c
+++ b/arch/mips/mm/fault.c
@@ -19,10 +19,10 @@
 #include <linux/module.h>
 #include <linux/kprobes.h>
 #include <linux/perf_event.h>
+#include <linux/uaccess.h>
 
 #include <asm/branch.h>
 #include <asm/mmu_context.h>
-#include <asm/uaccess.h>
 #include <asm/ptrace.h>
 #include <asm/highmem.h>		/* For VMALLOC_END */
 #include <linux/kdebug.h>
@@ -89,7 +89,7 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs, unsigned long writ
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
-	if (in_atomic() || !mm)
+	if (faulthandler_disabled() || !mm)
 		goto bad_area_nosemaphore;
 
 retry:
diff --git a/arch/mn10300/mm/fault.c b/arch/mn10300/mm/fault.c
index f1af2df6ac60..dd5781ab301c 100644
--- a/arch/mn10300/mm/fault.c
+++ b/arch/mn10300/mm/fault.c
@@ -23,8 +23,8 @@
 #include <linux/interrupt.h>
 #include <linux/init.h>
 #include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/uaccess.h>
 
-#include <asm/uaccess.h>
 #include <asm/pgalloc.h>
 #include <asm/hardirq.h>
 #include <asm/cpu-regs.h>
@@ -168,7 +168,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long fault_code,
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
-	if (in_atomic() || !mm)
+	if (faulthandler_disabled() || !mm)
 		goto no_context;
 
 retry:
* Unmerged path arch/nios2/mm/fault.c
* Unmerged path arch/parisc/kernel/traps.c
* Unmerged path arch/parisc/mm/fault.c
diff --git a/arch/powerpc/mm/fault.c b/arch/powerpc/mm/fault.c
index 3a38ad437b28..afe4da51568f 100644
--- a/arch/powerpc/mm/fault.c
+++ b/arch/powerpc/mm/fault.c
@@ -34,13 +34,13 @@
 #include <linux/ratelimit.h>
 #include <linux/context_tracking.h>
 #include <linux/hugetlb.h>
+#include <linux/uaccess.h>
 
 #include <asm/firmware.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/mmu.h>
 #include <asm/mmu_context.h>
-#include <asm/uaccess.h>
 #include <asm/tlbflush.h>
 #include <asm/siginfo.h>
 #include <asm/debug.h>
@@ -274,15 +274,16 @@ int __kprobes do_page_fault(struct pt_regs *regs, unsigned long address,
 	if (!arch_irq_disabled_regs(regs))
 		local_irq_enable();
 
-	if (in_atomic() || mm == NULL) {
+	if (faulthandler_disabled() || mm == NULL) {
 		if (!user_mode(regs)) {
 			rc = SIGSEGV;
 			goto bail;
 		}
-		/* in_atomic() in user mode is really bad,
+		/* faulthandler_disabled() in user mode is really bad,
 		   as is current->mm == NULL. */
 		printk(KERN_EMERG "Page fault in user mode with "
-		       "in_atomic() = %d mm = %p\n", in_atomic(), mm);
+		       "faulthandler_disabled() = %d mm = %p\n",
+		       faulthandler_disabled(), mm);
 		printk(KERN_EMERG "NIP = %lx  MSR = %lx\n",
 		       regs->nip, regs->msr);
 		die("Weird page fault", regs, SIGSEGV);
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index 54bfc6b9a179..a9965a0518b2 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -322,7 +322,7 @@ static inline int do_exception(struct pt_regs *regs, int access)
 	 * user context.
 	 */
 	fault = VM_FAULT_BADCONTEXT;
-	if (unlikely(!user_space_fault(regs) || in_atomic() || !mm))
+	if (unlikely(!user_space_fault(regs) || faulthandler_disabled() || !mm))
 		goto out;
 
 	address = trans_exc_code & __FAIL_ADDR_MASK;
diff --git a/arch/score/mm/fault.c b/arch/score/mm/fault.c
index 250fcdb489b2..33dea7f3a4ec 100644
--- a/arch/score/mm/fault.c
+++ b/arch/score/mm/fault.c
@@ -34,6 +34,7 @@
 #include <linux/string.h>
 #include <linux/types.h>
 #include <linux/ptrace.h>
+#include <linux/uaccess.h>
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -72,7 +73,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long write,
 	* If we're in an interrupt or have no user
 	* context, we must not take the fault..
 	*/
-	if (in_atomic() || !mm)
+	if (pagefault_disabled() || !mm)
 		goto bad_area_nosemaphore;
 
 	down_read(&mm->mmap_sem);
diff --git a/arch/sh/mm/fault.c b/arch/sh/mm/fault.c
index 5a61fca74adb..09b0b7cbaa8b 100644
--- a/arch/sh/mm/fault.c
+++ b/arch/sh/mm/fault.c
@@ -17,6 +17,7 @@
 #include <linux/kprobes.h>
 #include <linux/perf_event.h>
 #include <linux/kdebug.h>
+#include <linux/uaccess.h>
 #include <asm/io_trapped.h>
 #include <asm/mmu_context.h>
 #include <asm/tlbflush.h>
@@ -438,9 +439,9 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,
 
 	/*
 	 * If we're in an interrupt, have no user context or are running
-	 * in an atomic region then we must not take the fault:
+	 * with pagefaults disabled then we must not take the fault:
 	 */
-	if (unlikely(in_atomic() || !mm)) {
+	if (unlikely(faulthandler_disabled() || !mm)) {
 		bad_area_nosemaphore(regs, error_code, address);
 		return;
 	}
diff --git a/arch/sparc/mm/fault_32.c b/arch/sparc/mm/fault_32.c
index fb6bc3b6125f..70063c58fe1a 100644
--- a/arch/sparc/mm/fault_32.c
+++ b/arch/sparc/mm/fault_32.c
@@ -21,6 +21,7 @@
 #include <linux/perf_event.h>
 #include <linux/interrupt.h>
 #include <linux/kdebug.h>
+#include <linux/uaccess.h>
 
 #include <asm/page.h>
 #include <asm/pgtable.h>
@@ -28,7 +29,6 @@
 #include <asm/oplib.h>
 #include <asm/smp.h>
 #include <asm/traps.h>
-#include <asm/uaccess.h>
 
 int show_unhandled_signals = 1;
 
@@ -200,7 +200,7 @@ asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
-	if (in_atomic() || !mm)
+	if (pagefault_disabled() || !mm)
 		goto no_context;
 
 	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);
* Unmerged path arch/sparc/mm/fault_64.c
diff --git a/arch/sparc/mm/init_64.c b/arch/sparc/mm/init_64.c
index 1e1aed064009..05db6fde2e84 100644
--- a/arch/sparc/mm/init_64.c
+++ b/arch/sparc/mm/init_64.c
@@ -2714,7 +2714,7 @@ void hugetlb_setup(struct pt_regs *regs)
 	struct mm_struct *mm = current->mm;
 	struct tsb_config *tp;
 
-	if (in_atomic() || !mm) {
+	if (faulthandler_disabled() || !mm) {
 		const struct exception_table_entry *entry;
 
 		entry = search_exception_tables(regs->tpc);
diff --git a/arch/tile/mm/fault.c b/arch/tile/mm/fault.c
index c54a9b32c678..749b13578413 100644
--- a/arch/tile/mm/fault.c
+++ b/arch/tile/mm/fault.c
@@ -358,9 +358,9 @@ static int handle_page_fault(struct pt_regs *regs,
 
 	/*
 	 * If we're in an interrupt, have no user context or are running in an
-	 * atomic region then we must not take the fault.
+	 * region with pagefaults disabled then we must not take the fault.
 	 */
-	if (in_atomic() || !mm) {
+	if (pagefault_disabled() || !mm) {
 		vma = NULL;  /* happy compiler */
 		goto bad_area_nosemaphore;
 	}
diff --git a/arch/um/kernel/trap.c b/arch/um/kernel/trap.c
index f2a84dcd6b6c..9ce539b1415e 100644
--- a/arch/um/kernel/trap.c
+++ b/arch/um/kernel/trap.c
@@ -36,10 +36,10 @@ int handle_page_fault(unsigned long address, unsigned long ip,
 	*code_out = SEGV_MAPERR;
 
 	/*
-	 * If the fault was during atomic operation, don't take the fault, just
+	 * If the fault was with pagefaults disabled, don't take the fault, just
 	 * fail.
 	 */
-	if (in_atomic())
+	if (faulthandler_disabled())
 		goto out_nosemaphore;
 
 retry:
diff --git a/arch/unicore32/mm/fault.c b/arch/unicore32/mm/fault.c
index c54d882ab202..d020215f701f 100644
--- a/arch/unicore32/mm/fault.c
+++ b/arch/unicore32/mm/fault.c
@@ -219,7 +219,7 @@ static int do_pf(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 	 * If we're in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
-	if (in_atomic() || !mm)
+	if (faulthandler_disabled() || !mm)
 		goto no_context;
 
 	/*
* Unmerged path arch/x86/mm/fault.c
diff --git a/arch/xtensa/mm/fault.c b/arch/xtensa/mm/fault.c
index f491a0ffab4f..1a746037e009 100644
--- a/arch/xtensa/mm/fault.c
+++ b/arch/xtensa/mm/fault.c
@@ -15,10 +15,10 @@
 #include <linux/mm.h>
 #include <linux/module.h>
 #include <linux/hardirq.h>
+#include <linux/uaccess.h>
 #include <asm/mmu_context.h>
 #include <asm/cacheflush.h>
 #include <asm/hardirq.h>
-#include <asm/uaccess.h>
 #include <asm/pgalloc.h>
 
 unsigned long asid_cache = ASID_USER_FIRST;
@@ -57,7 +57,7 @@ void do_page_fault(struct pt_regs *regs)
 	/* If we're in an interrupt or have no user
 	 * context, we must not take the fault..
 	 */
-	if (in_atomic() || !mm) {
+	if (faulthandler_disabled() || !mm) {
 		bad_page_fault(regs, address, SIGSEGV);
 		return;
 	}
* Unmerged path include/linux/uaccess.h
