nfp: flower: ignore checksum actions when performing pedit actions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
commit ed8f2b52b622bbc550dadb69d3f10d81528f9fbc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ed8f2b52.failed

Hardware will automatically update csum in headers when a set action has
been performed. This means we could in the driver ignore the explicit
checksum action when performing a set action.

	Signed-off-by: Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ed8f2b52b622bbc550dadb69d3f10d81528f9fbc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/action.c
diff --cc drivers/net/ethernet/netronome/nfp/flower/action.c
index b8f6f44149cd,61ba8d4f99f1..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/action.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/action.c
@@@ -443,10 -535,57 +489,64 @@@ nfp_fl_pedit(const struct tc_action *ac
  }
  
  static int
++<<<<<<< HEAD
 +nfp_flower_loop_action(const struct tc_action *a,
 +		       struct nfp_fl_payload *nfp_fl, int *a_len,
 +		       struct net_device *netdev,
 +		       enum nfp_flower_tun_type *tun_type, int *tun_out_cnt)
++=======
+ nfp_flower_output_action(struct nfp_app *app, const struct tc_action *a,
+ 			 struct nfp_fl_payload *nfp_fl, int *a_len,
+ 			 struct net_device *netdev, bool last,
+ 			 enum nfp_flower_tun_type *tun_type, int *tun_out_cnt,
+ 			 int *out_cnt, u32 *csum_updated)
+ {
+ 	struct nfp_flower_priv *priv = app->priv;
+ 	struct nfp_fl_output *output;
+ 	int err, prelag_size;
+ 
+ 	/* If csum_updated has not been reset by now, it means HW will
+ 	 * incorrectly update csums when they are not requested.
+ 	 */
+ 	if (*csum_updated)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (*a_len + sizeof(struct nfp_fl_output) > NFP_FL_MAX_A_SIZ)
+ 		return -EOPNOTSUPP;
+ 
+ 	output = (struct nfp_fl_output *)&nfp_fl->action_data[*a_len];
+ 	err = nfp_fl_output(app, output, a, nfp_fl, last, netdev, *tun_type,
+ 			    tun_out_cnt);
+ 	if (err)
+ 		return err;
+ 
+ 	*a_len += sizeof(struct nfp_fl_output);
+ 
+ 	if (priv->flower_ext_feats & NFP_FL_FEATS_LAG) {
+ 		/* nfp_fl_pre_lag returns -err or size of prelag action added.
+ 		 * This will be 0 if it is not egressing to a lag dev.
+ 		 */
+ 		prelag_size = nfp_fl_pre_lag(app, a, nfp_fl, *a_len);
+ 		if (prelag_size < 0)
+ 			return prelag_size;
+ 		else if (prelag_size > 0 && (!last || *out_cnt))
+ 			return -EOPNOTSUPP;
+ 
+ 		*a_len += prelag_size;
+ 	}
+ 	(*out_cnt)++;
+ 
+ 	return 0;
+ }
+ 
+ static int
+ nfp_flower_loop_action(struct nfp_app *app, const struct tc_action *a,
+ 		       struct tc_cls_flower_offload *flow,
+ 		       struct nfp_fl_payload *nfp_fl, int *a_len,
+ 		       struct net_device *netdev,
+ 		       enum nfp_flower_tun_type *tun_type, int *tun_out_cnt,
+ 		       int *out_cnt, u32 *csum_updated)
++>>>>>>> ed8f2b52b622 (nfp: flower: ignore checksum actions when performing pedit actions)
  {
  	struct nfp_fl_set_ipv4_udp_tun *set_tun;
  	struct nfp_fl_pre_tunnel *pre_tun;
@@@ -458,23 -596,16 +558,35 @@@
  	if (is_tcf_gact_shot(a)) {
  		nfp_fl->meta.shortcut = cpu_to_be32(NFP_FL_SC_ACT_DROP);
  	} else if (is_tcf_mirred_egress_redirect(a)) {
++<<<<<<< HEAD
 +		if (*a_len + sizeof(struct nfp_fl_output) > NFP_FL_MAX_A_SIZ)
 +			return -EOPNOTSUPP;
 +
 +		output = (struct nfp_fl_output *)&nfp_fl->action_data[*a_len];
 +		err = nfp_fl_output(output, a, nfp_fl, true, netdev, *tun_type,
 +				    tun_out_cnt);
++=======
+ 		err = nfp_flower_output_action(app, a, nfp_fl, a_len, netdev,
+ 					       true, tun_type, tun_out_cnt,
+ 					       out_cnt, csum_updated);
++>>>>>>> ed8f2b52b622 (nfp: flower: ignore checksum actions when performing pedit actions)
  		if (err)
  			return err;
  
 +		*a_len += sizeof(struct nfp_fl_output);
  	} else if (is_tcf_mirred_egress_mirror(a)) {
++<<<<<<< HEAD
 +		if (*a_len + sizeof(struct nfp_fl_output) > NFP_FL_MAX_A_SIZ)
 +			return -EOPNOTSUPP;
 +
 +		output = (struct nfp_fl_output *)&nfp_fl->action_data[*a_len];
 +		err = nfp_fl_output(output, a, nfp_fl, false, netdev, *tun_type,
 +				    tun_out_cnt);
++=======
+ 		err = nfp_flower_output_action(app, a, nfp_fl, a_len, netdev,
+ 					       false, tun_type, tun_out_cnt,
+ 					       out_cnt, csum_updated);
++>>>>>>> ed8f2b52b622 (nfp: flower: ignore checksum actions when performing pedit actions)
  		if (err)
  			return err;
  
@@@ -539,9 -679,10 +660,10 @@@ int nfp_flower_compile_action(struct tc
  			      struct net_device *netdev,
  			      struct nfp_fl_payload *nfp_flow)
  {
 -	int act_len, act_cnt, err, tun_out_cnt, out_cnt;
 +	int act_len, act_cnt, err, tun_out_cnt;
  	enum nfp_flower_tun_type tun_type;
  	const struct tc_action *a;
+ 	u32 csum_updated = 0;
  	LIST_HEAD(actions);
  
  	memset(nfp_flow->action_data, 0, NFP_FL_MAX_A_SIZ);
@@@ -553,8 -694,10 +675,14 @@@
  
  	tcf_exts_to_list(flow->exts, &actions);
  	list_for_each_entry(a, &actions, list) {
++<<<<<<< HEAD
 +		err = nfp_flower_loop_action(a, nfp_flow, &act_len, netdev,
 +					     &tun_type, &tun_out_cnt);
++=======
+ 		err = nfp_flower_loop_action(app, a, flow, nfp_flow, &act_len,
+ 					     netdev, &tun_type, &tun_out_cnt,
+ 					     &out_cnt, &csum_updated);
++>>>>>>> ed8f2b52b622 (nfp: flower: ignore checksum actions when performing pedit actions)
  		if (err)
  			return err;
  		act_cnt++;
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/action.c
