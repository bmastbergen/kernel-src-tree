IB/uverbs: Do not check for device disassociation during ioctl

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit 4ce719f846a4177f2631e4149503e3baf3dce87b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4ce719f8.failed

Now that the ioctl path and uobjects are converted to use uverbs_api, it
is now safe to remove the disassociation protection from the common ioctl
code.

This completes the work to make destroy functions continue to work even
after device disassociation.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 4ce719f846a4177f2631e4149503e3baf3dce87b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_ioctl.c
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index ec7b453e622b,1a6b229e3db3..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -165,303 -253,361 +165,317 @@@ static int uverbs_process_attr(struct i
  	return 0;
  }
  
 -/*
 - * We search the radix tree with the method prefix and now we want to fast
 - * search the suffix bits to get a particular attribute pointer. It is not
 - * totally clear to me if this breaks the radix tree encasulation or not, but
 - * it uses the iter data to determine if the method iter points at the same
 - * chunk that will store the attribute, if so it just derefs it directly. By
 - * construction in most kernel configs the method and attrs will all fit in a
 - * single radix chunk, so in most cases this will have no search. Other cases
 - * this falls back to a full search.
 - */
 -static void __rcu **uapi_get_attr_for_method(struct bundle_priv *pbundle,
 -					     u32 attr_key)
 +static int uverbs_finalize_attrs(struct uverbs_attr_bundle *attrs_bundle,
 +				 struct uverbs_attr_spec_hash *const *spec_hash,
 +				 size_t num, bool commit)
  {
 -	void __rcu **slot;
 +	unsigned int i;
 +	int ret = 0;
  
 -	if (likely(attr_key < pbundle->radix_slots_len)) {
 -		void *entry;
 +	for (i = 0; i < num; i++) {
 +		struct uverbs_attr_bundle_hash *curr_bundle =
 +			&attrs_bundle->hash[i];
 +		const struct uverbs_attr_spec_hash *curr_spec_bucket =
 +			spec_hash[i];
 +		unsigned int j;
  
 -		slot = pbundle->radix_slots + attr_key;
 -		entry = rcu_dereference_raw(*slot);
 -		if (likely(!radix_tree_is_internal_node(entry) && entry))
 -			return slot;
 -	}
 +		if (!curr_spec_bucket)
 +			continue;
 +
 +		for (j = 0; j < curr_bundle->num_attrs; j++) {
 +			struct uverbs_attr *attr;
 +			const struct uverbs_attr_spec *spec;
 +
 +			if (!uverbs_attr_is_valid_in_hash(curr_bundle, j))
 +				continue;
 +
 +			attr = &curr_bundle->attrs[j];
 +			spec = &curr_spec_bucket->attrs[j];
 +
 +			if (spec->type == UVERBS_ATTR_TYPE_IDR ||
 +			    spec->type == UVERBS_ATTR_TYPE_FD) {
 +				int current_ret;
  
 -	return radix_tree_lookup_slot(pbundle->radix,
 -				      pbundle->method_key | attr_key);
 +				current_ret = uverbs_finalize_object(
 +					attr->obj_attr.uobject,
 +					spec->obj.access, commit);
 +				if (!ret)
 +					ret = current_ret;
 +			}
 +		}
 +	}
 +	return ret;
  }
  
 -static int uverbs_set_attr(struct bundle_priv *pbundle,
 -			   struct ib_uverbs_attr *uattr)
 +static int uverbs_uattrs_process(struct ib_device *ibdev,
 +				 struct ib_ucontext *ucontext,
 +				 const struct ib_uverbs_attr *uattrs,
 +				 size_t num_uattrs,
 +				 const struct uverbs_method_spec *method,
 +				 struct uverbs_attr_bundle *attr_bundle,
 +				 struct ib_uverbs_attr __user *uattr_ptr)
  {
 -	u32 attr_key = uapi_key_attr(uattr->attr_id);
 -	u32 attr_bkey = uapi_bkey_attr(attr_key);
 -	const struct uverbs_api_attr *attr;
 -	void __rcu **slot;
 -	int ret;
 +	size_t i;
 +	int ret = 0;
 +	int num_given_buckets = 0;
 +
 +	for (i = 0; i < num_uattrs; i++) {
 +		const struct ib_uverbs_attr *uattr = &uattrs[i];
 +		u16 attr_id = uattr->attr_id;
 +		struct uverbs_attr_spec_hash *attr_spec_bucket;
 +
 +		ret = uverbs_ns_idx(&attr_id, method->num_buckets);
 +		if (ret < 0 || !method->attr_buckets[ret]) {
 +			if (uattr->flags & UVERBS_ATTR_F_MANDATORY) {
 +				uverbs_finalize_attrs(attr_bundle,
 +						      method->attr_buckets,
 +						      num_given_buckets,
 +						      false);
 +				return ret;
 +			}
 +			continue;
 +		}
  
 -	slot = uapi_get_attr_for_method(pbundle, attr_key);
 -	if (!slot) {
  		/*
 -		 * Kernel does not support the attribute but user-space says it
 -		 * is mandatory
 +		 * ret is the found ns, so increase num_given_buckets if
 +		 * necessary.
  		 */
 -		if (uattr->flags & UVERBS_ATTR_F_MANDATORY)
 -			return -EPROTONOSUPPORT;
 -		return 0;
 +		if (ret >= num_given_buckets)
 +			num_given_buckets = ret + 1;
 +
 +		attr_spec_bucket = method->attr_buckets[ret];
 +		ret = uverbs_process_attr(ibdev, ucontext, uattr, attr_id,
 +					  attr_spec_bucket, &attr_bundle->hash[ret],
 +					  uattr_ptr++);
 +		if (ret) {
 +			uverbs_finalize_attrs(attr_bundle,
 +					      method->attr_buckets,
 +					      num_given_buckets,
 +					      false);
 +			return ret;
 +		}
  	}
 -	attr = srcu_dereference(
 -		*slot, &pbundle->bundle.ufile->device->disassociate_srcu);
  
 -	/* Reject duplicate attributes from user-space */
 -	if (test_bit(attr_bkey, pbundle->bundle.attr_present))
 -		return -EINVAL;
 -
 -	ret = uverbs_process_attr(pbundle, attr, uattr, attr_bkey);
 -	if (ret)
 -		return ret;
 -
 -	__set_bit(attr_bkey, pbundle->bundle.attr_present);
 -
 -	return 0;
 +	return num_given_buckets;
  }
  
 -static int ib_uverbs_run_method(struct bundle_priv *pbundle,
 -				unsigned int num_attrs)
 +static int uverbs_validate_kernel_mandatory(const struct uverbs_method_spec *method_spec,
 +					    struct uverbs_attr_bundle *attr_bundle)
  {
 -	int (*handler)(struct ib_uverbs_file *ufile,
 -		       struct uverbs_attr_bundle *ctx);
 -	size_t uattrs_size = array_size(sizeof(*pbundle->uattrs), num_attrs);
 -	unsigned int destroy_bkey = pbundle->method_elm->destroy_bkey;
  	unsigned int i;
 -	int ret;
  
 -	/* See uverbs_disassociate_api() */
 -	handler = srcu_dereference(
 -		pbundle->method_elm->handler,
 -		&pbundle->bundle.ufile->device->disassociate_srcu);
 -	if (!handler)
 -		return -EIO;
 -
 -	pbundle->uattrs = uverbs_alloc(&pbundle->bundle, uattrs_size);
 -	if (IS_ERR(pbundle->uattrs))
 -		return PTR_ERR(pbundle->uattrs);
 -	if (copy_from_user(pbundle->uattrs, pbundle->user_attrs, uattrs_size))
 -		return -EFAULT;
 +	for (i = 0; i < attr_bundle->num_buckets; i++) {
 +		struct uverbs_attr_spec_hash *attr_spec_bucket =
 +			method_spec->attr_buckets[i];
  
 -	for (i = 0; i != num_attrs; i++) {
 -		ret = uverbs_set_attr(pbundle, &pbundle->uattrs[i]);
 -		if (unlikely(ret))
 -			return ret;
 +		if (!attr_spec_bucket)
 +			continue;
 +
 +		if (!bitmap_subset(attr_spec_bucket->mandatory_attrs_bitmask,
 +				   attr_bundle->hash[i].valid_bitmap,
 +				   attr_spec_bucket->num_attrs))
 +			return -EINVAL;
  	}
  
 -	/* User space did not provide all the mandatory attributes */
 -	if (unlikely(!bitmap_subset(pbundle->method_elm->attr_mandatory,
 -				    pbundle->bundle.attr_present,
 -				    pbundle->method_elm->key_bitmap_len)))
 -		return -EINVAL;
 +	for (; i < method_spec->num_buckets; i++) {
 +		struct uverbs_attr_spec_hash *attr_spec_bucket =
 +			method_spec->attr_buckets[i];
  
 -	if (destroy_bkey != UVERBS_API_ATTR_BKEY_LEN) {
 -		struct uverbs_obj_attr *destroy_attr =
 -			&pbundle->bundle.attrs[destroy_bkey].obj_attr;
 +		if (!bitmap_empty(attr_spec_bucket->mandatory_attrs_bitmask,
 +				  attr_spec_bucket->num_attrs))
 +			return -EINVAL;
 +	}
  
 -		ret = uobj_destroy(destroy_attr->uobject);
 -		if (ret)
 -			return ret;
 -		__clear_bit(destroy_bkey, pbundle->uobj_finalize);
 +	return 0;
 +}
  
 -		ret = handler(pbundle->bundle.ufile, &pbundle->bundle);
 -		uobj_put_destroy(destroy_attr->uobject);
 -	} else {
 -		ret = handler(pbundle->bundle.ufile, &pbundle->bundle);
 -	}
 +static int uverbs_handle_method(struct ib_uverbs_attr __user *uattr_ptr,
 +				const struct ib_uverbs_attr *uattrs,
 +				size_t num_uattrs,
 +				struct ib_device *ibdev,
 +				struct ib_uverbs_file *ufile,
 +				const struct uverbs_method_spec *method_spec,
 +				struct uverbs_attr_bundle *attr_bundle)
 +{
 +	int ret;
 +	int finalize_ret;
 +	int num_given_buckets;
  
 -	/*
 -	 * EPROTONOSUPPORT is ONLY to be returned if the ioctl framework can
 -	 * not invoke the method because the request is not supported.  No
 -	 * other cases should return this code.
 -	 */
 -	if (WARN_ON_ONCE(ret == -EPROTONOSUPPORT))
 +	num_given_buckets = uverbs_uattrs_process(ibdev, ufile->ucontext, uattrs,
 +						  num_uattrs, method_spec,
 +						  attr_bundle, uattr_ptr);
 +	if (num_given_buckets <= 0)
  		return -EINVAL;
  
 -	return ret;
 +	attr_bundle->num_buckets = num_given_buckets;
 +	ret = uverbs_validate_kernel_mandatory(method_spec, attr_bundle);
 +	if (ret)
 +		goto cleanup;
 +
 +	ret = method_spec->handler(ibdev, ufile, attr_bundle);
 +cleanup:
 +	finalize_ret = uverbs_finalize_attrs(attr_bundle,
 +					     method_spec->attr_buckets,
 +					     attr_bundle->num_buckets,
 +					     !ret);
 +
 +	return ret ? ret : finalize_ret;
  }
  
 -static int bundle_destroy(struct bundle_priv *pbundle, bool commit)
 +#define UVERBS_OPTIMIZE_USING_STACK_SZ  256
 +static long ib_uverbs_cmd_verbs(struct ib_device *ib_dev,
 +				struct ib_uverbs_file *file,
 +				struct ib_uverbs_ioctl_hdr *hdr,
 +				void __user *buf)
  {
 -	unsigned int key_bitmap_len = pbundle->method_elm->key_bitmap_len;
 -	struct bundle_alloc_head *memblock;
 +	const struct uverbs_object_spec *object_spec;
 +	const struct uverbs_method_spec *method_spec;
 +	long err = 0;
  	unsigned int i;
 -	int ret = 0;
 +	struct {
 +		struct ib_uverbs_attr		*uattrs;
 +		struct uverbs_attr_bundle	*uverbs_attr_bundle;
 +	} *ctx = NULL;
 +	struct uverbs_attr *curr_attr;
 +	unsigned long *curr_bitmap;
 +	size_t ctx_size;
 +	uintptr_t data[UVERBS_OPTIMIZE_USING_STACK_SZ / sizeof(uintptr_t)];
 +
 +	object_spec = uverbs_get_object(ib_dev, hdr->object_id);
 +	if (!object_spec)
 +		return -EPROTONOSUPPORT;
  
 -	i = -1;
 -	while ((i = find_next_bit(pbundle->uobj_finalize, key_bitmap_len,
 -				  i + 1)) < key_bitmap_len) {
 -		struct uverbs_attr *attr = &pbundle->bundle.attrs[i];
 -		int current_ret;
 -
 -		current_ret = uverbs_finalize_object(
 -			attr->obj_attr.uobject,
 -			attr->obj_attr.attr_elm->spec.u.obj.access, commit);
 -		if (!ret)
 -			ret = current_ret;
 -	}
 +	method_spec = uverbs_get_method(object_spec, hdr->method_id);
 +	if (!method_spec)
 +		return -EPROTONOSUPPORT;
  
 -	for (memblock = pbundle->allocated_mem; memblock;) {
 -		struct bundle_alloc_head *tmp = memblock;
 +	if ((method_spec->flags & UVERBS_ACTION_FLAG_CREATE_ROOT) ^ !file->ucontext)
 +		return -EINVAL;
  
 -		memblock = memblock->next;
 -		kvfree(tmp);
 -	}
 +	ctx_size = sizeof(*ctx) +
 +		   sizeof(struct uverbs_attr_bundle) +
 +		   sizeof(struct uverbs_attr_bundle_hash) * method_spec->num_buckets +
 +		   sizeof(*ctx->uattrs) * hdr->num_attrs +
 +		   sizeof(*ctx->uverbs_attr_bundle->hash[0].attrs) *
 +		   method_spec->num_child_attrs +
 +		   sizeof(*ctx->uverbs_attr_bundle->hash[0].valid_bitmap) *
 +			(method_spec->num_child_attrs / BITS_PER_LONG +
 +			 method_spec->num_buckets);
 +
 +	if (ctx_size <= UVERBS_OPTIMIZE_USING_STACK_SZ)
 +		ctx = (void *)data;
 +	if (!ctx)
 +		ctx = kmalloc(ctx_size, GFP_KERNEL);
 +	if (!ctx)
 +		return -ENOMEM;
 +
 +	ctx->uverbs_attr_bundle = (void *)ctx + sizeof(*ctx);
 +	ctx->uattrs = (void *)(ctx->uverbs_attr_bundle + 1) +
 +			      (sizeof(ctx->uverbs_attr_bundle->hash[0]) *
 +			       method_spec->num_buckets);
 +	curr_attr = (void *)(ctx->uattrs + hdr->num_attrs);
 +	curr_bitmap = (void *)(curr_attr + method_spec->num_child_attrs);
  
 -	return ret;
 -}
 +	/*
 +	 * We just fill the pointers and num_attrs here. The data itself will be
 +	 * filled at a later stage (uverbs_process_attr)
 +	 */
 +	for (i = 0; i < method_spec->num_buckets; i++) {
 +		unsigned int curr_num_attrs;
  
 -static int ib_uverbs_cmd_verbs(struct ib_uverbs_file *ufile,
 -			       struct ib_uverbs_ioctl_hdr *hdr,
 -			       struct ib_uverbs_attr __user *user_attrs)
 -{
 -	const struct uverbs_api_ioctl_method *method_elm;
 -	struct uverbs_api *uapi = ufile->device->uapi;
 -	struct radix_tree_iter attrs_iter;
 -	struct bundle_priv *pbundle;
 -	struct bundle_priv onstack;
 -	void __rcu **slot;
 -	int destroy_ret;
 -	int ret;
 +		if (!method_spec->attr_buckets[i])
 +			continue;
  
 -	if (unlikely(hdr->driver_id != uapi->driver_id))
 -		return -EINVAL;
 +		curr_num_attrs = method_spec->attr_buckets[i]->num_attrs;
  
 -	slot = radix_tree_iter_lookup(
 -		&uapi->radix, &attrs_iter,
 -		uapi_key_obj(hdr->object_id) |
 -			uapi_key_ioctl_method(hdr->method_id));
 -	if (unlikely(!slot))
 -		return -EPROTONOSUPPORT;
 -	method_elm = srcu_dereference(*slot, &ufile->device->disassociate_srcu);
 -
 -	if (!method_elm->use_stack) {
 -		pbundle = kmalloc(method_elm->bundle_size, GFP_KERNEL);
 -		if (!pbundle)
 -			return -ENOMEM;
 -		pbundle->internal_avail =
 -			method_elm->bundle_size -
 -			offsetof(struct bundle_priv, internal_buffer);
 -		pbundle->alloc_head.next = NULL;
 -		pbundle->allocated_mem = &pbundle->alloc_head;
 -	} else {
 -		pbundle = &onstack;
 -		pbundle->internal_avail = sizeof(pbundle->internal_buffer);
 -		pbundle->allocated_mem = NULL;
 +		ctx->uverbs_attr_bundle->hash[i].attrs = curr_attr;
 +		curr_attr += curr_num_attrs;
 +		ctx->uverbs_attr_bundle->hash[i].num_attrs = curr_num_attrs;
 +		ctx->uverbs_attr_bundle->hash[i].valid_bitmap = curr_bitmap;
 +		bitmap_zero(curr_bitmap, curr_num_attrs);
 +		curr_bitmap += BITS_TO_LONGS(curr_num_attrs);
  	}
  
 -	/* Space for the pbundle->bundle.attrs flex array */
 -	pbundle->method_elm = method_elm;
 -	pbundle->method_key = attrs_iter.index;
 -	pbundle->bundle.ufile = ufile;
 -	pbundle->radix = &uapi->radix;
 -	pbundle->radix_slots = slot;
 -	pbundle->radix_slots_len = radix_tree_chunk_size(&attrs_iter);
 -	pbundle->user_attrs = user_attrs;
 -
 -	pbundle->internal_used = ALIGN(pbundle->method_elm->key_bitmap_len *
 -					       sizeof(*pbundle->bundle.attrs),
 -				       sizeof(*pbundle->internal_buffer));
 -	memset(pbundle->bundle.attr_present, 0,
 -	       sizeof(pbundle->bundle.attr_present));
 -	memset(pbundle->uobj_finalize, 0, sizeof(pbundle->uobj_finalize));
 -
 -	ret = ib_uverbs_run_method(pbundle, hdr->num_attrs);
 -	destroy_ret = bundle_destroy(pbundle, ret == 0);
 -	if (unlikely(destroy_ret && !ret))
 -		return destroy_ret;
 +	err = copy_from_user(ctx->uattrs, buf,
 +			     sizeof(*ctx->uattrs) * hdr->num_attrs);
 +	if (err) {
 +		err = -EFAULT;
 +		goto out;
 +	}
  
 -	return ret;
 +	err = uverbs_handle_method(buf, ctx->uattrs, hdr->num_attrs, ib_dev,
 +				   file, method_spec, ctx->uverbs_attr_bundle);
 +
 +	/*
 +	 * EPROTONOSUPPORT is ONLY to be returned if the ioctl framework can
 +	 * not invoke the method because the request is not supported.  No
 +	 * other cases should return this code.
 +	*/
 +	if (unlikely(err == -EPROTONOSUPPORT)) {
 +		WARN_ON_ONCE(err == -EPROTONOSUPPORT);
 +		err = -EINVAL;
 +	}
 +out:
 +	if (ctx != (void *)data)
 +		kfree(ctx);
 +	return err;
  }
  
- #define IB_UVERBS_MAX_CMD_SZ 4096
- 
  long ib_uverbs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
  {
  	struct ib_uverbs_file *file = filp->private_data;
  	struct ib_uverbs_ioctl_hdr __user *user_hdr =
  		(struct ib_uverbs_ioctl_hdr __user *)arg;
  	struct ib_uverbs_ioctl_hdr hdr;
- 	struct ib_device *ib_dev;
  	int srcu_key;
- 	long err;
+ 	int err;
+ 
+ 	if (unlikely(cmd != RDMA_VERBS_IOCTL))
+ 		return -ENOIOCTLCMD;
+ 
+ 	err = copy_from_user(&hdr, user_hdr, sizeof(hdr));
+ 	if (err)
+ 		return -EFAULT;
+ 
+ 	if (hdr.length > PAGE_SIZE ||
+ 	    hdr.length != struct_size(&hdr, attrs, hdr.num_attrs))
+ 		return -EINVAL;
+ 
+ 	if (hdr.reserved1 || hdr.reserved2)
+ 		return -EPROTONOSUPPORT;
  
  	srcu_key = srcu_read_lock(&file->device->disassociate_srcu);
 -	err = ib_uverbs_cmd_verbs(file, &hdr, user_hdr->attrs);
 -	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
 -	return err;
 -}
 -
 -int uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,
 -		       size_t idx, u64 allowed_bits)
 -{
 -	const struct uverbs_attr *attr;
 -	u64 flags;
 -
 -	attr = uverbs_attr_get(attrs_bundle, idx);
 -	/* Missing attribute means 0 flags */
 -	if (IS_ERR(attr)) {
 -		*to = 0;
 -		return 0;
++<<<<<<< HEAD
 +	ib_dev = srcu_dereference(file->device->ib_dev,
 +				  &file->device->disassociate_srcu);
 +	if (!ib_dev) {
 +		err = -EIO;
 +		goto out;
  	}
  
 -	/*
 -	 * New userspace code should use 8 bytes to pass flags, but we
 -	 * transparently support old userspaces that were using 4 bytes as
 -	 * well.
 -	 */
 -	if (attr->ptr_attr.len == 8)
 -		flags = attr->ptr_attr.data;
 -	else if (attr->ptr_attr.len == 4)
 -		flags = *(u32 *)&attr->ptr_attr.data;
 -	else
 -		return -EINVAL;
 -
 -	if (flags & ~allowed_bits)
 -		return -EINVAL;
 -
 -	*to = flags;
 -	return 0;
 -}
 -EXPORT_SYMBOL(uverbs_get_flags64);
 -
 -int uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,
 -		       size_t idx, u64 allowed_bits)
 -{
 -	u64 flags;
 -	int ret;
 -
 -	ret = uverbs_get_flags64(&flags, attrs_bundle, idx, allowed_bits);
 -	if (ret)
 -		return ret;
 -
 -	if (flags > U32_MAX)
 -		return -EINVAL;
 -	*to = flags;
 +	if (cmd == RDMA_VERBS_IOCTL) {
 +		err = copy_from_user(&hdr, user_hdr, sizeof(hdr));
  
 -	return 0;
 -}
 -EXPORT_SYMBOL(uverbs_get_flags32);
 +		if (err || hdr.length > IB_UVERBS_MAX_CMD_SZ ||
 +		    hdr.length != sizeof(hdr) + hdr.num_attrs * sizeof(struct ib_uverbs_attr)) {
 +			err = -EINVAL;
 +			goto out;
 +		}
  
 -/*
 - * This is for ease of conversion. The purpose is to convert all drivers to
 - * use uverbs_attr_bundle instead of ib_udata.  Assume attr == 0 is input and
 - * attr == 1 is output.
 - */
 -void create_udata(struct uverbs_attr_bundle *bundle, struct ib_udata *udata)
 -{
 -	struct bundle_priv *pbundle =
 -		container_of(bundle, struct bundle_priv, bundle);
 -	const struct uverbs_attr *uhw_in =
 -		uverbs_attr_get(bundle, UVERBS_ATTR_UHW_IN);
 -	const struct uverbs_attr *uhw_out =
 -		uverbs_attr_get(bundle, UVERBS_ATTR_UHW_OUT);
 -
 -	if (!IS_ERR(uhw_in)) {
 -		udata->inlen = uhw_in->ptr_attr.len;
 -		if (uverbs_attr_ptr_is_inline(uhw_in))
 -			udata->inbuf =
 -				&pbundle->user_attrs[uhw_in->ptr_attr.uattr_idx]
 -					 .data;
 -		else
 -			udata->inbuf = u64_to_user_ptr(uhw_in->ptr_attr.data);
 -	} else {
 -		udata->inbuf = NULL;
 -		udata->inlen = 0;
 -	}
 +		if (hdr.reserved) {
 +			err = -EPROTONOSUPPORT;
 +			goto out;
 +		}
  
 -	if (!IS_ERR(uhw_out)) {
 -		udata->outbuf = u64_to_user_ptr(uhw_out->ptr_attr.data);
 -		udata->outlen = uhw_out->ptr_attr.len;
 +		err = ib_uverbs_cmd_verbs(ib_dev, file, &hdr,
 +					  (__user void *)arg + sizeof(hdr));
  	} else {
 -		udata->outbuf = NULL;
 -		udata->outlen = 0;
 +		err = -ENOIOCTLCMD;
  	}
 +out:
++=======
++	err = ib_uverbs_cmd_verbs(file, &hdr, user_hdr->attrs);
++>>>>>>> 4ce719f846a4 (IB/uverbs: Do not check for device disassociation during ioctl)
 +	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
- 
 +	return err;
  }
 -
 -int uverbs_copy_to(const struct uverbs_attr_bundle *bundle, size_t idx,
 -		   const void *from, size_t size)
 -{
 -	struct bundle_priv *pbundle =
 -		container_of(bundle, struct bundle_priv, bundle);
 -	const struct uverbs_attr *attr = uverbs_attr_get(bundle, idx);
 -	u16 flags;
 -	size_t min_size;
 -
 -	if (IS_ERR(attr))
 -		return PTR_ERR(attr);
 -
 -	min_size = min_t(size_t, attr->ptr_attr.len, size);
 -	if (copy_to_user(u64_to_user_ptr(attr->ptr_attr.data), from, min_size))
 -		return -EFAULT;
 -
 -	flags = pbundle->uattrs[attr->ptr_attr.uattr_idx].flags |
 -		UVERBS_ATTR_F_VALID_OUTPUT;
 -	if (put_user(flags,
 -		     &pbundle->user_attrs[attr->ptr_attr.uattr_idx].flags))
 -		return -EFAULT;
 -
 -	return 0;
 -}
 -EXPORT_SYMBOL(uverbs_copy_to);
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
