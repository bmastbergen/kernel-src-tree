x86/gart: Exclude GART aperture from kcore

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] gart: Exclude GART aperture from kcore (Kairui Song) [1532150]
Rebuild_FUZZ: 95.00%
commit-author Kairui Song <kasong@redhat.com>
commit ffc8599aa9763f39f6736a79da4d1575e7006f9a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ffc8599a.failed

On machines where the GART aperture is mapped over physical RAM,
/proc/kcore contains the GART aperture range. Accessing the GART range via
/proc/kcore results in a kernel crash.

vmcore used to have the same issue, until it was fixed with commit
2a3e83c6f96c ("x86/gart: Exclude GART aperture from vmcore")', leveraging
existing hook infrastructure in vmcore to let /proc/vmcore return zeroes
when attempting to read the aperture region, and so it won't read from the
actual memory.

Apply the same workaround for kcore. First implement the same hook
infrastructure for kcore, then reuse the hook functions introduced in the
previous vmcore fix. Just with some minor adjustment, rename some functions
for more general usage, and simplify the hook infrastructure a bit as there
is no module usage yet.

	Suggested-by: Baoquan He <bhe@redhat.com>
	Signed-off-by: Kairui Song <kasong@redhat.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Jiri Bohac <jbohac@suse.cz>
	Acked-by: Baoquan He <bhe@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Alexey Dobriyan <adobriyan@gmail.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Omar Sandoval <osandov@fb.com>
	Cc: Dave Young <dyoung@redhat.com>
Link: https://lkml.kernel.org/r/20190308030508.13548-1-kasong@redhat.com


(cherry picked from commit ffc8599aa9763f39f6736a79da4d1575e7006f9a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/aperture_64.c
#	fs/proc/kcore.c
#	include/linux/kcore.h
diff --cc arch/x86/kernel/aperture_64.c
index 6e85f713641d,294ed4392a0e..000000000000
--- a/arch/x86/kernel/aperture_64.c
+++ b/arch/x86/kernel/aperture_64.c
@@@ -55,6 -58,38 +56,41 @@@ int fallback_aper_force __initdata
  
  int fix_aperture __initdata = 1;
  
++<<<<<<< HEAD
++=======
+ #if defined(CONFIG_PROC_VMCORE) || defined(CONFIG_PROC_KCORE)
+ /*
+  * If the first kernel maps the aperture over e820 RAM, the kdump kernel will
+  * use the same range because it will remain configured in the northbridge.
+  * Trying to dump this area via /proc/vmcore may crash the machine, so exclude
+  * it from vmcore.
+  */
+ static unsigned long aperture_pfn_start, aperture_page_count;
+ 
+ static int gart_mem_pfn_is_ram(unsigned long pfn)
+ {
+ 	return likely((pfn < aperture_pfn_start) ||
+ 		      (pfn >= aperture_pfn_start + aperture_page_count));
+ }
+ 
+ static void __init exclude_from_core(u64 aper_base, u32 aper_order)
+ {
+ 	aperture_pfn_start = aper_base >> PAGE_SHIFT;
+ 	aperture_page_count = (32 * 1024 * 1024) << aper_order >> PAGE_SHIFT;
+ #ifdef CONFIG_PROC_VMCORE
+ 	WARN_ON(register_oldmem_pfn_is_ram(&gart_mem_pfn_is_ram));
+ #endif
+ #ifdef CONFIG_PROC_KCORE
+ 	WARN_ON(register_mem_pfn_is_ram(&gart_mem_pfn_is_ram));
+ #endif
+ }
+ #else
+ static void exclude_from_core(u64 aper_base, u32 aper_order)
+ {
+ }
+ #endif
+ 
++>>>>>>> ffc8599aa976 (x86/gart: Exclude GART aperture from kcore)
  /* This code runs before the PCI subsystem is initialized, so just
     access the northbridge directly. */
  
@@@ -442,8 -474,16 +478,19 @@@ int __init gart_iommu_hole_init(void
  
  out:
  	if (!fix && !fallback_aper_force) {
++<<<<<<< HEAD
 +		if (last_aper_base)
++=======
+ 		if (last_aper_base) {
+ 			/*
+ 			 * If this is the kdump kernel, the first kernel
+ 			 * may have allocated the range over its e820 RAM
+ 			 * and fixed up the northbridge
+ 			 */
+ 			exclude_from_core(last_aper_base, last_aper_order);
+ 
++>>>>>>> ffc8599aa976 (x86/gart: Exclude GART aperture from kcore)
  			return 1;
 -		}
  		return 0;
  	}
  
@@@ -480,6 -520,14 +527,17 @@@
  		return 0;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * If this is the kdump kernel _and_ the first kernel did not
+ 	 * configure the aperture in the northbridge, this range may
+ 	 * overlap with the first kernel's memory. We can't access the
+ 	 * range through vmcore even though it should be part of the dump.
+ 	 */
+ 	exclude_from_core(aper_alloc, aper_order);
+ 
++>>>>>>> ffc8599aa976 (x86/gart: Exclude GART aperture from kcore)
  	/* Fix up the north bridges */
  	for (i = 0; i < amd_nb_bus_dev_ranges[i].dev_limit; i++) {
  		int bus, dev_base, dev_limit;
diff --cc fs/proc/kcore.c
index 89982e107324,d29d869abec1..000000000000
--- a/fs/proc/kcore.c
+++ b/fs/proc/kcore.c
@@@ -47,21 -50,35 +47,49 @@@ static struct proc_dir_entry *proc_root
  #define	kc_offset_to_vaddr(o) ((o) + PAGE_OFFSET)
  #endif
  
 +/* An ELF note in memory */
 +struct memelfnote
 +{
 +	const char *name;
 +	int type;
 +	unsigned int datasz;
 +	void *data;
 +};
 +
  static LIST_HEAD(kclist_head);
 -static DECLARE_RWSEM(kclist_lock);
 +static DEFINE_RWLOCK(kclist_lock);
  static int kcore_need_update = 1;
  
++<<<<<<< HEAD
 +void
 +kclist_add(struct kcore_list *new, void *addr, size_t size, int type)
++=======
+ /*
+  * Returns > 0 for RAM pages, 0 for non-RAM pages, < 0 on error
+  * Same as oldmem_pfn_is_ram in vmcore
+  */
+ static int (*mem_pfn_is_ram)(unsigned long pfn);
+ 
+ int __init register_mem_pfn_is_ram(int (*fn)(unsigned long pfn))
+ {
+ 	if (mem_pfn_is_ram)
+ 		return -EBUSY;
+ 	mem_pfn_is_ram = fn;
+ 	return 0;
+ }
+ 
+ static int pfn_is_ram(unsigned long pfn)
+ {
+ 	if (mem_pfn_is_ram)
+ 		return mem_pfn_is_ram(pfn);
+ 	else
+ 		return 1;
+ }
+ 
+ /* This doesn't grab kclist_lock, so it should only be used at init time. */
+ void __init kclist_add(struct kcore_list *new, void *addr, size_t size,
+ 		       int type)
++>>>>>>> ffc8599aa976 (x86/gart: Exclude GART aperture from kcore)
  {
  	new->addr = (unsigned long)addr;
  	new->size = size;
@@@ -487,32 -463,48 +515,46 @@@ read_kcore(struct file *file, char __us
  	 * Check to see if our file offset matches with any of
  	 * the addresses in the elf_phdr on our list.
  	 */
 -	start = kc_offset_to_vaddr(*fpos - data_offset);
 +	start = kc_offset_to_vaddr(*fpos - elf_buflen);
  	if ((tsz = (PAGE_SIZE - (start & ~PAGE_MASK))) > buflen)
  		tsz = buflen;
 -
 -	m = NULL;
 +		
  	while (buflen) {
 -		/*
 -		 * If this is the first iteration or the address is not within
 -		 * the previous entry, search for a matching entry.
 -		 */
 -		if (!m || start < m->addr || start >= m->addr + m->size) {
 -			list_for_each_entry(m, &kclist_head, list) {
 -				if (start >= m->addr &&
 -				    start < m->addr + m->size)
 -					break;
 -			}
 +		struct kcore_list *m;
 +
 +		read_lock(&kclist_lock);
 +		list_for_each_entry(m, &kclist_head, list) {
 +			if (start >= m->addr && start < (m->addr+m->size))
 +				break;
  		}
 +		read_unlock(&kclist_lock);
  
  		if (&m->list == &kclist_head) {
++<<<<<<< HEAD
 +			if (clear_user(buffer, tsz))
 +				return -EFAULT;
 +		} else if (is_vmalloc_or_module_addr((void *)start)) {
++=======
+ 			if (clear_user(buffer, tsz)) {
+ 				ret = -EFAULT;
+ 				goto out;
+ 			}
+ 			m = NULL;	/* skip the list anchor */
+ 		} else if (!pfn_is_ram(__pa(start) >> PAGE_SHIFT)) {
+ 			if (clear_user(buffer, tsz)) {
+ 				ret = -EFAULT;
+ 				goto out;
+ 			}
+ 		} else if (m->type == KCORE_VMALLOC) {
++>>>>>>> ffc8599aa976 (x86/gart: Exclude GART aperture from kcore)
  			vread(buf, (char *)start, tsz);
  			/* we have to zero-fill user buffer even if no read */
 -			if (copy_to_user(buffer, buf, tsz)) {
 -				ret = -EFAULT;
 -				goto out;
 -			}
 +			if (copy_to_user(buffer, buf, tsz))
 +				return -EFAULT;
  		} else if (m->type == KCORE_USER) {
  			/* User page is handled prior to normal kernel page: */
 -			if (copy_to_user(buffer, (char *)start, tsz)) {
 -				ret = -EFAULT;
 -				goto out;
 -			}
 +			if (copy_to_user(buffer, (char *)start, tsz))
 +				return -EFAULT;
  		} else {
  			if (kern_addr_valid(start)) {
  				/*
diff --cc include/linux/kcore.h
index 3ffade4f2798,c843f4a9c512..000000000000
--- a/include/linux/kcore.h
+++ b/include/linux/kcore.h
@@@ -27,8 -30,22 +27,20 @@@ struct vmcore 
  	loff_t offset;
  };
  
 -struct vmcoredd_node {
 -	struct list_head list;	/* List of dumps */
 -	void *buf;		/* Buffer containing device's dump */
 -	unsigned int size;	/* Size of the buffer */
 -};
 -
  #ifdef CONFIG_PROC_KCORE
++<<<<<<< HEAD
 +extern void kclist_add(struct kcore_list *, void *, size_t, int type);
++=======
+ void __init kclist_add(struct kcore_list *, void *, size_t, int type);
+ static inline
+ void kclist_add_remap(struct kcore_list *m, void *addr, void *vaddr, size_t sz)
+ {
+ 	m->vaddr = (unsigned long)vaddr;
+ 	kclist_add(m, addr, sz, KCORE_REMAP);
+ }
+ 
+ extern int __init register_mem_pfn_is_ram(int (*fn)(unsigned long pfn));
++>>>>>>> ffc8599aa976 (x86/gart: Exclude GART aperture from kcore)
  #else
  static inline
  void kclist_add(struct kcore_list *new, void *addr, size_t size, int type)
* Unmerged path arch/x86/kernel/aperture_64.c
* Unmerged path fs/proc/kcore.c
* Unmerged path include/linux/kcore.h
