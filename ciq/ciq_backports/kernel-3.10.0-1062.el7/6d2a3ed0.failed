net/mlx5e: Avoid duplicated code for tc offloads add/del fdb rule

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Avoid duplicated code for tc offloads add/del fdb rule (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 96.83%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 6d2a3ed011e84287c634ec2b6e4a856ce95fd729
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6d2a3ed0.failed

The code for adding/deleting fdb flow is repeated when
user-space does flow add/del and when we add/del from
the neigh update path - unify them to avoid the duplication.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 6d2a3ed011e84287c634ec2b6e4a856ce95fd729)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 3a01f0d3c372,1786e25644ac..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -811,12 -820,51 +811,52 @@@ static int mlx5e_attach_encap(struct ml
  			      struct ip_tunnel_info *tun_info,
  			      struct net_device *mirred_dev,
  			      struct net_device **encap_dev,
 -			      struct mlx5e_tc_flow *flow,
 -			      struct netlink_ext_ack *extack);
 +			      struct mlx5e_tc_flow *flow);
  
  static struct mlx5_flow_handle *
++<<<<<<< HEAD
++=======
+ mlx5e_tc_offload_fdb_rules(struct mlx5_eswitch *esw,
+ 			   struct mlx5e_tc_flow *flow,
+ 			   struct mlx5_flow_spec *spec,
+ 			   struct mlx5_esw_flow_attr *attr)
+ {
+ 	struct mlx5_flow_handle *rule;
+ 
+ 	rule = mlx5_eswitch_add_offloaded_rule(esw, spec, attr);
+ 	if (IS_ERR(rule))
+ 		return rule;
+ 
+ 	if (attr->mirror_count) {
+ 		flow->rule[1] = mlx5_eswitch_add_fwd_rule(esw, spec, attr);
+ 		if (IS_ERR(flow->rule[1])) {
+ 			mlx5_eswitch_del_offloaded_rule(esw, rule, attr);
+ 			return flow->rule[1];
+ 		}
+ 	}
+ 
+ 	flow->flags |= MLX5E_TC_FLOW_OFFLOADED;
+ 	return rule;
+ }
+ 
+ static void
+ mlx5e_tc_unoffload_fdb_rules(struct mlx5_eswitch *esw,
+ 			     struct mlx5e_tc_flow *flow,
+ 			   struct mlx5_esw_flow_attr *attr)
+ {
+ 	flow->flags &= ~MLX5E_TC_FLOW_OFFLOADED;
+ 
+ 	if (attr->mirror_count)
+ 		mlx5_eswitch_del_fwd_rule(esw, flow->rule[1], attr);
+ 
+ 	mlx5_eswitch_del_offloaded_rule(esw, flow->rule[0], attr);
+ }
+ 
+ static int
++>>>>>>> 6d2a3ed011e8 (net/mlx5e: Avoid duplicated code for tc offloads add/del fdb rule)
  mlx5e_tc_add_fdb_flow(struct mlx5e_priv *priv,
  		      struct mlx5e_tc_flow_parse_attr *parse_attr,
 -		      struct mlx5e_tc_flow *flow,
 -		      struct netlink_ext_ack *extack)
 +		      struct mlx5e_tc_flow *flow)
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
  	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
@@@ -851,23 -900,36 +891,37 @@@
  	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR) {
  		err = mlx5e_attach_mod_hdr(priv, flow, parse_attr);
  		kfree(parse_attr->mod_hdr_actions);
 -		if (err)
 +		if (err) {
 +			rule = ERR_PTR(err);
  			goto err_mod_hdr;
 -	}
 -
 -	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {
 -		counter = mlx5_fc_create(esw->dev, true);
 -		if (IS_ERR(counter)) {
 -			err = PTR_ERR(counter);
 -			goto err_create_counter;
  		}
 -
 -		attr->counter = counter;
  	}
  
 -	/* we get here if (1) there's no error or when
 +	/* we get here if (1) there's no error (rule being null) or when
  	 * (2) there's an encap action and we're on -EAGAIN (no valid neigh)
  	 */
++<<<<<<< HEAD
 +	if (rule != ERR_PTR(-EAGAIN)) {
 +		rule = mlx5_eswitch_add_offloaded_rule(esw, &parse_attr->spec, attr);
 +		if (IS_ERR(rule))
 +			goto err_add_rule;
++=======
+ 	if (encap_err != -EAGAIN) {
+ 		flow->rule[0] = mlx5e_tc_offload_fdb_rules(esw, flow, &parse_attr->spec, attr);
+ 		if (IS_ERR(flow->rule[0])) {
+ 			err = PTR_ERR(flow->rule[0]);
+ 			goto err_add_rule;
+ 		}
++>>>>>>> 6d2a3ed011e8 (net/mlx5e: Avoid duplicated code for tc offloads add/del fdb rule)
  	}
 +	return rule;
  
++<<<<<<< HEAD
++=======
+ 	return encap_err;
+ 
++>>>>>>> 6d2a3ed011e8 (net/mlx5e: Avoid duplicated code for tc offloads add/del fdb rule)
  err_add_rule:
 -	mlx5_fc_destroy(esw->dev, counter);
 -err_create_counter:
  	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
  		mlx5e_detach_mod_hdr(priv, flow);
  err_mod_hdr:
@@@ -885,10 -947,8 +939,15 @@@ static void mlx5e_tc_del_fdb_flow(struc
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
  	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
  
++<<<<<<< HEAD
 +	if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
 +		flow->flags &= ~MLX5E_TC_FLOW_OFFLOADED;
 +		mlx5_eswitch_del_offloaded_rule(esw, flow->rule, attr);
 +	}
++=======
+ 	if (flow->flags & MLX5E_TC_FLOW_OFFLOADED)
+ 		mlx5e_tc_unoffload_fdb_rules(esw, flow, flow->esw_attr);
++>>>>>>> 6d2a3ed011e8 (net/mlx5e: Avoid duplicated code for tc offloads add/del fdb rule)
  
  	mlx5_eswitch_del_vlan_action(esw, attr);
  
@@@ -923,14 -989,16 +984,26 @@@ void mlx5e_tc_encap_flows_add(struct ml
  	list_for_each_entry(flow, &e->flows, encap) {
  		esw_attr = flow->esw_attr;
  		esw_attr->encap_id = e->encap_id;
++<<<<<<< HEAD
 +		flow->rule = mlx5_eswitch_add_offloaded_rule(esw, &esw_attr->parse_attr->spec, esw_attr);
 +		if (IS_ERR(flow->rule)) {
 +			err = PTR_ERR(flow->rule);
++=======
+ 		spec = &esw_attr->parse_attr->spec;
+ 
+ 		rule = mlx5e_tc_offload_fdb_rules(esw, flow, spec, esw_attr);
+ 		if (IS_ERR(rule)) {
+ 			err = PTR_ERR(rule);
++>>>>>>> 6d2a3ed011e8 (net/mlx5e: Avoid duplicated code for tc offloads add/del fdb rule)
  			mlx5_core_warn(priv->mdev, "Failed to update cached encapsulation flow, %d\n",
  				       err);
  			continue;
  		}
++<<<<<<< HEAD
 +		flow->flags |= MLX5E_TC_FLOW_OFFLOADED;
++=======
+ 		flow->rule[0] = rule;
++>>>>>>> 6d2a3ed011e8 (net/mlx5e: Avoid duplicated code for tc offloads add/del fdb rule)
  	}
  }
  
@@@ -941,10 -1009,8 +1014,15 @@@ void mlx5e_tc_encap_flows_del(struct ml
  	struct mlx5e_tc_flow *flow;
  
  	list_for_each_entry(flow, &e->flows, encap) {
++<<<<<<< HEAD
 +		if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
 +			flow->flags &= ~MLX5E_TC_FLOW_OFFLOADED;
 +			mlx5_eswitch_del_offloaded_rule(esw, flow->rule, flow->esw_attr);
 +		}
++=======
+ 		if (flow->flags & MLX5E_TC_FLOW_OFFLOADED)
+ 			mlx5e_tc_unoffload_fdb_rules(esw, flow, flow->esw_attr);
++>>>>>>> 6d2a3ed011e8 (net/mlx5e: Avoid duplicated code for tc offloads add/del fdb rule)
  	}
  
  	if (e->flags & MLX5_ENCAP_ENTRY_VALID) {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
