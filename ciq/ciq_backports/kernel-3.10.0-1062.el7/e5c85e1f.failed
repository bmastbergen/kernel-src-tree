autofs: make expire flags usage consistent with v5 params

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ian Kent <raven@themaw.net>
commit e5c85e1fe19c03777cbacf4b5a5167b2f5ff90fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e5c85e1f.failed

Make the usage of the expire flags consistent by naming the expire flags
the same as it is named in the version 5 miscelaneous ioctl parameters and
only check the bit flags when needed.

Link: http://lkml.kernel.org/r/152937734046.21213.9454131988766280028.stgit@pluto.themaw.net
	Signed-off-by: Ian Kent <raven@themaw.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e5c85e1fe19c03777cbacf4b5a5167b2f5ff90fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/autofs4/autofs_i.h
#	fs/autofs4/expire.c
diff --cc fs/autofs4/autofs_i.h
index 7e44fa72be46,633986a6a93a..000000000000
--- a/fs/autofs4/autofs_i.h
+++ b/fs/autofs4/autofs_i.h
@@@ -140,25 -143,19 +140,37 @@@ static inline int autofs4_oz_mode(struc
  	return sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;
  }
  
 -struct inode *autofs_get_inode(struct super_block *, umode_t);
 -void autofs_free_ino(struct autofs_info *);
 +struct inode *autofs4_get_inode(struct super_block *, umode_t);
 +void autofs4_free_ino(struct autofs_info *);
  
  /* Expiration */
++<<<<<<< HEAD:fs/autofs4/autofs_i.h
 +int is_autofs4_dentry(struct dentry *);
 +int autofs4_expire_wait(const struct path *path, int rcu_walk);
 +int autofs4_expire_run(struct super_block *, struct vfsmount *,
 +		       struct autofs_sb_info *,
 +		       struct autofs_packet_expire __user *);
 +int autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,
 +			    struct autofs_sb_info *sbi, int when);
 +int autofs4_expire_multi(struct super_block *, struct vfsmount *,
 +			 struct autofs_sb_info *, int __user *);
 +struct dentry *autofs4_expire_direct(struct super_block *sb,
 +				     struct vfsmount *mnt,
 +				     struct autofs_sb_info *sbi, int how);
 +struct dentry *autofs4_expire_indirect(struct super_block *sb,
 +				       struct vfsmount *mnt,
 +				       struct autofs_sb_info *sbi, int how);
++=======
+ int is_autofs_dentry(struct dentry *);
+ int autofs_expire_wait(const struct path *path, int rcu_walk);
+ int autofs_expire_run(struct super_block *, struct vfsmount *,
+ 		      struct autofs_sb_info *,
+ 		      struct autofs_packet_expire __user *);
+ int autofs_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,
+ 			   struct autofs_sb_info *sbi, unsigned int how);
+ int autofs_expire_multi(struct super_block *, struct vfsmount *,
+ 			struct autofs_sb_info *, int __user *);
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/autofs_i.h
  
  /* Device node initialization */
  
diff --cc fs/autofs4/expire.c
index 0f4f1d4ac0bf,dfb666c5b8a2..000000000000
--- a/fs/autofs4/expire.c
+++ b/fs/autofs4/expire.c
@@@ -11,10 -11,10 +11,15 @@@
  #include "autofs_i.h"
  
  /* Check if a dentry can be expired */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +static inline int autofs4_can_expire(struct dentry *dentry,
 +				     unsigned long timeout, int do_now)
++=======
+ static inline int autofs_can_expire(struct dentry *dentry,
+ 				    unsigned long timeout, unsigned int how)
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  {
 -	struct autofs_info *ino = autofs_dentry_ino(dentry);
 +	struct autofs_info *ino = autofs4_dentry_ino(dentry);
  
  	/* dentry in the process of being deleted */
  	if (ino == NULL)
@@@ -182,10 -182,10 +187,17 @@@ again
   * The tree is not busy iff no mountpoints are busy and there are no
   * autofs submounts.
   */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +static int autofs4_direct_busy(struct vfsmount *mnt,
 +			       struct dentry *top,
 +			       unsigned long timeout,
 +			       int do_now)
++=======
+ static int autofs_direct_busy(struct vfsmount *mnt,
+ 			      struct dentry *top,
+ 			      unsigned long timeout,
+ 			      unsigned int how)
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  {
  	pr_debug("top %p %pd\n", top, top);
  
@@@ -200,7 -200,7 +212,11 @@@
  	}
  
  	/* Timeout of a direct mount is determined by its top dentry */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +	if (!autofs4_can_expire(top, timeout, do_now))
++=======
+ 	if (!autofs_can_expire(top, timeout, how))
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  		return 1;
  
  	return 0;
@@@ -210,12 -210,12 +226,19 @@@
   * Check a directory tree of mount points for busyness
   * The tree is not busy iff no mountpoints are busy
   */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +static int autofs4_tree_busy(struct vfsmount *mnt,
 +	       		     struct dentry *top,
 +			     unsigned long timeout,
 +			     int do_now)
++=======
+ static int autofs_tree_busy(struct vfsmount *mnt,
+ 			    struct dentry *top,
+ 			    unsigned long timeout,
+ 			    unsigned int how)
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  {
 -	struct autofs_info *top_ino = autofs_dentry_ino(top);
 +	struct autofs_info *top_ino = autofs4_dentry_ino(top);
  	struct dentry *p;
  
  	pr_debug("top %p %pd\n", top, top);
@@@ -259,16 -259,16 +282,27 @@@
  	}
  
  	/* Timeout of a tree mount is ultimately determined by its top dentry */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +	if (!autofs4_can_expire(top, timeout, do_now))
++=======
+ 	if (!autofs_can_expire(top, timeout, how))
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  		return 1;
  
  	return 0;
  }
  
++<<<<<<< HEAD:fs/autofs4/expire.c
 +static struct dentry *autofs4_check_leaves(struct vfsmount *mnt,
 +					   struct dentry *parent,
 +					   unsigned long timeout,
 +					   int do_now)
++=======
+ static struct dentry *autofs_check_leaves(struct vfsmount *mnt,
+ 					  struct dentry *parent,
+ 					  unsigned long timeout,
+ 					  unsigned int how)
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  {
  	struct dentry *p;
  
@@@ -284,7 -284,7 +318,11 @@@
  				continue;
  
  			/* Can we expire this guy */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +			if (autofs4_can_expire(p, timeout, do_now))
++=======
+ 			if (autofs_can_expire(p, timeout, how))
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  				return p;
  		}
  	}
@@@ -292,24 -292,23 +330,34 @@@
  }
  
  /* Check if we can expire a direct mount (possibly a tree) */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +struct dentry *autofs4_expire_direct(struct super_block *sb,
 +				     struct vfsmount *mnt,
 +				     struct autofs_sb_info *sbi,
 +				     int how)
++=======
+ static struct dentry *autofs_expire_direct(struct super_block *sb,
+ 					   struct vfsmount *mnt,
+ 					   struct autofs_sb_info *sbi,
+ 					   unsigned int how)
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  {
- 	unsigned long timeout;
  	struct dentry *root = dget(sb->s_root);
- 	int do_now = how & AUTOFS_EXP_IMMEDIATE;
  	struct autofs_info *ino;
+ 	unsigned long timeout;
  
  	if (!root)
  		return NULL;
  
  	timeout = sbi->exp_timeout;
  
++<<<<<<< HEAD:fs/autofs4/expire.c
 +	if (!autofs4_direct_busy(mnt, root, timeout, do_now)) {
++=======
+ 	if (!autofs_direct_busy(mnt, root, timeout, how)) {
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  		spin_lock(&sbi->fs_lock);
 -		ino = autofs_dentry_ino(root);
 +		ino = autofs4_dentry_ino(root);
  		/* No point expiring a pending mount */
  		if (ino->flags & AUTOFS_INF_PENDING) {
  			spin_unlock(&sbi->fs_lock);
@@@ -318,7 -317,7 +366,11 @@@
  		ino->flags |= AUTOFS_INF_WANT_EXPIRE;
  		spin_unlock(&sbi->fs_lock);
  		synchronize_rcu();
++<<<<<<< HEAD:fs/autofs4/expire.c
 +		if (!autofs4_direct_busy(mnt, root, timeout, do_now)) {
++=======
+ 		if (!autofs_direct_busy(mnt, root, timeout, how)) {
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  			spin_lock(&sbi->fs_lock);
  			ino->flags |= AUTOFS_INF_EXPIRING;
  			init_completion(&ino->expire_complete);
@@@ -343,11 -342,9 +395,15 @@@ out
  static struct dentry *should_expire(struct dentry *dentry,
  				    struct vfsmount *mnt,
  				    unsigned long timeout,
- 				    int how)
+ 				    unsigned int how)
  {
++<<<<<<< HEAD:fs/autofs4/expire.c
 +	int do_now = how & AUTOFS_EXP_IMMEDIATE;
 +	int exp_leaves = how & AUTOFS_EXP_LEAVES;
 +	struct autofs_info *ino = autofs4_dentry_ino(dentry);
++=======
+ 	struct autofs_info *ino = autofs_dentry_ino(dentry);
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  	unsigned int ino_count;
  
  	/* No point expiring a pending mount */
@@@ -368,7 -365,7 +424,11 @@@
  			return NULL;
  
  		/* Can we expire this guy */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +		if (autofs4_can_expire(dentry, timeout, do_now))
++=======
+ 		if (autofs_can_expire(dentry, timeout, how))
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  			return dentry;
  		return NULL;
  	}
@@@ -379,7 -376,7 +439,11 @@@
  		 * A symlink can't be "busy" in the usual sense so
  		 * just check last used for expire timeout.
  		 */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +		if (autofs4_can_expire(dentry, timeout, do_now))
++=======
+ 		if (autofs_can_expire(dentry, timeout, how))
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  			return dentry;
  		return NULL;
  	}
@@@ -394,7 -391,7 +458,11 @@@
  		if (d_count(dentry) > ino_count)
  			return NULL;
  
++<<<<<<< HEAD:fs/autofs4/expire.c
 +		if (!autofs4_tree_busy(mnt, dentry, timeout, do_now))
++=======
+ 		if (!autofs_tree_busy(mnt, dentry, timeout, how))
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  			return dentry;
  	/*
  	 * Case 3: pseudo direct mount, expire individual leaves
@@@ -408,7 -405,7 +476,11 @@@
  		if (d_count(dentry) > ino_count)
  			return NULL;
  
++<<<<<<< HEAD:fs/autofs4/expire.c
 +		expired = autofs4_check_leaves(mnt, dentry, timeout, do_now);
++=======
+ 		expired = autofs_check_leaves(mnt, dentry, timeout, how);
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  		if (expired) {
  			if (expired == dentry)
  				dput(dentry);
@@@ -424,10 -421,10 +496,17 @@@
   *  - it is unused by any user process
   *  - it has been unused for exp_timeout time
   */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +struct dentry *autofs4_expire_indirect(struct super_block *sb,
 +				       struct vfsmount *mnt,
 +				       struct autofs_sb_info *sbi,
 +				       int how)
++=======
+ static struct dentry *autofs_expire_indirect(struct super_block *sb,
+ 					     struct vfsmount *mnt,
+ 					     struct autofs_sb_info *sbi,
+ 					     unsigned int how)
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  {
  	unsigned long timeout;
  	struct dentry *root = sb->s_root;
@@@ -443,10 -440,8 +522,8 @@@
  
  	dentry = NULL;
  	while ((dentry = get_next_positive_subdir(dentry, root))) {
- 		int flags = how;
- 
  		spin_lock(&sbi->fs_lock);
 -		ino = autofs_dentry_ino(dentry);
 +		ino = autofs4_dentry_ino(dentry);
  		if (ino->flags & AUTOFS_INF_WANT_EXPIRE) {
  			spin_unlock(&sbi->fs_lock);
  			continue;
@@@ -579,19 -574,19 +656,30 @@@ int autofs4_expire_run(struct super_blo
  	return ret;
  }
  
++<<<<<<< HEAD:fs/autofs4/expire.c
 +int autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,
 +			    struct autofs_sb_info *sbi, int when)
++=======
+ int autofs_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,
+ 			   struct autofs_sb_info *sbi, unsigned int how)
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  {
  	struct dentry *dentry;
  	int ret = -EAGAIN;
  
  	if (autofs_type_trigger(sbi->type))
++<<<<<<< HEAD:fs/autofs4/expire.c
 +		dentry = autofs4_expire_direct(sb, mnt, sbi, when);
 +	else
 +		dentry = autofs4_expire_indirect(sb, mnt, sbi, when);
++=======
+ 		dentry = autofs_expire_direct(sb, mnt, sbi, how);
+ 	else
+ 		dentry = autofs_expire_indirect(sb, mnt, sbi, how);
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  
  	if (dentry) {
 -		struct autofs_info *ino = autofs_dentry_ino(dentry);
 +		struct autofs_info *ino = autofs4_dentry_ino(dentry);
  		const struct path path = { .mnt = mnt, .dentry = dentry };
  
  		/* This is synchronous because it makes the daemon a
@@@ -615,14 -610,13 +703,18 @@@
   * Call repeatedly until it returns -EAGAIN, meaning there's nothing
   * more to be done.
   */
 -int autofs_expire_multi(struct super_block *sb, struct vfsmount *mnt,
 +int autofs4_expire_multi(struct super_block *sb, struct vfsmount *mnt,
  			struct autofs_sb_info *sbi, int __user *arg)
  {
- 	int do_now = 0;
+ 	unsigned int how = 0;
  
- 	if (arg && get_user(do_now, arg))
+ 	if (arg && get_user(how, arg))
  		return -EFAULT;
  
++<<<<<<< HEAD:fs/autofs4/expire.c
 +	return autofs4_do_expire_multi(sb, mnt, sbi, do_now);
++=======
+ 	return autofs_do_expire_multi(sb, mnt, sbi, how);
++>>>>>>> e5c85e1fe19c (autofs: make expire flags usage consistent with v5 params):fs/autofs/expire.c
  }
 +
* Unmerged path fs/autofs4/autofs_i.h
* Unmerged path fs/autofs4/expire.c
