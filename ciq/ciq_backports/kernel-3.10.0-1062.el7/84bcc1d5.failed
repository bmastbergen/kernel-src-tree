x86/mce/AMD: Carve out SMCA bank configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] mce/amd: Carve out SMCA bank configuration (David Arcari) [1676301]
Rebuild_FUZZ: 95.45%
commit-author Yazen Ghannam <yazen.ghannam@amd.com>
commit 84bcc1d57f634ba8a55eda9a910c159467af0aac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/84bcc1d5.failed

Scalable MCA systems have a new MCA_CONFIG register that we use to
configure each bank. We currently use this when we set up thresholding.
However, this is logically separate.

Group all SMCA-related initialization into a single function.

	Signed-off-by: Yazen Ghannam <yazen.ghannam@amd.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: linux-edac <linux-edac@vger.kernel.org>
Link: http://lkml.kernel.org/r/1493147772-2721-2-git-send-email-Yazen.Ghannam@amd.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 84bcc1d57f634ba8a55eda9a910c159467af0aac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/mcheck/mce_amd.c
diff --cc arch/x86/kernel/cpu/mcheck/mce_amd.c
index 502f33739c8f,d00f299f2ada..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce_amd.c
+++ b/arch/x86/kernel/cpu/mcheck/mce_amd.c
@@@ -163,8 -216,14 +194,13 @@@ static void smca_configure(unsigned in
  	for (i = 0; i < ARRAY_SIZE(smca_hwid_mcatypes); i++) {
  		s_hwid = &smca_hwid_mcatypes[i];
  		if (hwid_mcatype == s_hwid->hwid_mcatype) {
 -
 -			WARN(smca_banks[bank].hwid,
 -			     "Bank %s already initialized!\n",
 -			     smca_get_name(s_hwid->bank_type));
 -
  			smca_banks[bank].hwid = s_hwid;
++<<<<<<< HEAD
 +			smca_banks[bank].id = instance_id;
++=======
+ 			smca_banks[bank].id = low;
+ 			smca_banks[bank].sysfs_id = s_hwid->count++;
++>>>>>>> 84bcc1d57f63 (x86/mce/AMD: Carve out SMCA bank configuration)
  			break;
  		}
  	}
@@@ -429,51 -488,6 +465,54 @@@ prepare_threshold_block(unsigned int ba
  		goto set_offset;
  	}
  
++<<<<<<< HEAD
 +	smca_addr = MSR_AMD64_SMCA_MCx_CONFIG(bank);
 +
 +	if (!rdmsr_safe(smca_addr, &smca_low, &smca_high)) {
 +		/*
 +		 * OS is required to set the MCAX bit to acknowledge that it is
 +		 * now using the new MSR ranges and new registers under each
 +		 * bank. It also means that the OS will configure deferred
 +		 * errors in the new MCx_CONFIG register. If the bit is not set,
 +		 * uncorrectable errors will cause a system panic.
 +		 *
 +		 * MCA_CONFIG[MCAX] is bit 32 (0 in the high portion of the MSR.)
 +		 */
 +		smca_high |= BIT(0);
 +
 +		/*
 +		 * SMCA logs Deferred Error information in MCA_DE{STAT,ADDR}
 +		 * registers with the option of additionally logging to
 +		 * MCA_{STATUS,ADDR} if MCA_CONFIG[LogDeferredInMcaStat] is set.
 +		 *
 +		 * This bit is usually set by BIOS to retain the old behavior
 +		 * for OSes that don't use the new registers. Linux supports the
 +		 * new registers so let's disable that additional logging here.
 +		 *
 +		 * MCA_CONFIG[LogDeferredInMcaStat] is bit 34 (bit 2 in the high
 +		 * portion of the MSR).
 +		 */
 +		smca_high &= ~BIT(2);
 +
 +		/*
 +		 * SMCA sets the Deferred Error Interrupt type per bank.
 +		 *
 +		 * MCA_CONFIG[DeferredIntTypeSupported] is bit 5, and tells us
 +		 * if the DeferredIntType bit field is available.
 +		 *
 +		 * MCA_CONFIG[DeferredIntType] is bits [38:37] ([6:5] in the
 +		 * high portion of the MSR). OS should set this to 0x1 to enable
 +		 * APIC based interrupt. First, check that no interrupt has been
 +		 * set.
 +		 */
 +		if ((smca_low & BIT(5)) && !((smca_high >> 5) & 0x3))
 +			smca_high |= BIT(5);
 +
 +		wrmsr(smca_addr, smca_low, smca_high);
 +	}
 +
++=======
++>>>>>>> 84bcc1d57f63 (x86/mce/AMD: Carve out SMCA bank configuration)
  	/* Gather LVT offset for thresholding: */
  	if (rdmsr_safe(MSR_CU_DEF_ERR, &smca_low, &smca_high))
  		goto out;
* Unmerged path arch/x86/kernel/cpu/mcheck/mce_amd.c
