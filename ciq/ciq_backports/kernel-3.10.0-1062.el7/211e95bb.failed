xfs: merge xfs_bmap_read_extents into xfs_iread_extents

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 211e95bbab71359e56f3d9adce1b4d6de8e18471
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/211e95bb.failed

xfs_iread_extents is just a trivial wrapper, there is no good reason
to keep the two separate.

[darrick: minor fixups having left xfs_bmbt_validate_extent intact]

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 211e95bbab71359e56f3d9adce1b4d6de8e18471)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_inode_fork.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 905742f2f1f9,26518aa7b9ae..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -1175,32 -1164,37 +1175,51 @@@ trans_cancel
   */
  
  /*
-  * Read in the extents to if_extents.
-  * All inode fields are set up by caller, we just traverse the btree
-  * and copy the records in. If the file system cannot contain unwritten
-  * extents, the records are checked for no "state" flags.
+  * Read in extents from a btree-format inode.
   */
- int					/* error */
- xfs_bmap_read_extents(
- 	xfs_trans_t		*tp,	/* transaction pointer */
- 	xfs_inode_t		*ip,	/* incore inode */
- 	int			whichfork) /* data or attr fork */
+ int
+ xfs_iread_extents(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	int			whichfork)
  {
++<<<<<<< HEAD
 +	struct xfs_btree_block	*block;	/* current btree block */
 +	xfs_fsblock_t		bno;	/* block # of "block" */
 +	xfs_buf_t		*bp;	/* buffer for "block" */
 +	int			error;	/* error return value */
 +	xfs_extnum_t		i, j;	/* index into the extents list */
 +	xfs_ifork_t		*ifp;	/* fork structure */
 +	int			level;	/* btree level, for checking */
 +	xfs_mount_t		*mp;	/* file system mount structure */
 +	__be64			*pp;	/* pointer to block address */
 +	/* REFERENCED */
 +	xfs_extnum_t		room;	/* number of entries there's room for */
++=======
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	int			state = xfs_bmap_fork_to_state(whichfork);
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	xfs_extnum_t		nextents = XFS_IFORK_NEXTENTS(ip, whichfork);
+ 	struct xfs_btree_block	*block = ifp->if_broot;
+ 	xfs_fsblock_t		bno;
+ 	struct xfs_buf		*bp;
+ 	xfs_extnum_t		i, j;
+ 	int			level;
+ 	__be64			*pp;
+ 	int			error;
+ 
+ 	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));
+ 
+ 	if (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {
+ 		XFS_ERROR_REPORT(__func__, XFS_ERRLEVEL_LOW, mp);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	ifp->if_bytes = 0;
+ 	ifp->if_real_bytes = 0;
+ 	xfs_iext_add(ifp, 0, nextents);
++>>>>>>> 211e95bbab71 (xfs: merge xfs_bmap_read_extents into xfs_iread_extents)
  
- 	mp = ip->i_mount;
- 	ifp = XFS_IFORK_PTR(ip, whichfork);
- 	block = ifp->if_broot;
  	/*
  	 * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.
  	 */
@@@ -1268,8 -1264,10 +1289,9 @@@
  			if (!xfs_bmbt_validate_extent(mp, whichfork, trp)) {
  				XFS_ERROR_REPORT("xfs_bmap_read_extents(2)",
  						 XFS_ERRLEVEL_LOW, mp);
- 				goto error0;
+ 				error = -EFSCORRUPTED;
+ 				goto out_brelse;
  			}
 -			trace_xfs_read_extent(ip, i, state, _THIS_IP_);
  		}
  		xfs_trans_brelse(tp, bp);
  		bno = nextbno;
@@@ -1281,17 -1279,24 +1303,28 @@@
  		error = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,
  				XFS_BMAP_BTREE_REF, &xfs_bmbt_buf_ops);
  		if (error)
- 			return error;
+ 			goto out;
  		block = XFS_BUF_TO_BLOCK(bp);
  	}
- 	if (i != XFS_IFORK_NEXTENTS(ip, whichfork))
- 		return -EFSCORRUPTED;
+ 
+ 	if (i != XFS_IFORK_NEXTENTS(ip, whichfork)) {
+ 		error = -EFSCORRUPTED;
+ 		goto out;
+ 	}
  	ASSERT(i == xfs_iext_count(ifp));
++<<<<<<< HEAD
 +	XFS_BMAP_TRACE_EXLIST(ip, i, whichfork);
++=======
+ 
+ 	ifp->if_flags |= XFS_IFEXTENTS;
++>>>>>>> 211e95bbab71 (xfs: merge xfs_bmap_read_extents into xfs_iread_extents)
  	return 0;
- error0:
+ 
+ out_brelse:
  	xfs_trans_brelse(tp, bp);
- 	return -EFSCORRUPTED;
+ out:
+ 	xfs_iext_destroy(ifp);
+ 	return error;
  }
  
  /*
diff --cc fs/xfs/libxfs/xfs_inode_fork.c
index f83028029221,911ff791a896..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@@ -335,41 -449,6 +335,44 @@@ xfs_iformat_btree
  }
  
  /*
++<<<<<<< HEAD
 + * Read in extents from a btree-format inode.
 + * Allocate and fill in if_extents.  Real work is done in xfs_bmap.c.
 + */
 +int
 +xfs_iread_extents(
 +	xfs_trans_t	*tp,
 +	xfs_inode_t	*ip,
 +	int		whichfork)
 +{
 +	int		error;
 +	xfs_ifork_t	*ifp;
 +	xfs_extnum_t	nextents;
 +
 +	if (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {
 +		XFS_ERROR_REPORT("xfs_iread_extents", XFS_ERRLEVEL_LOW,
 +				 ip->i_mount);
 +		return -EFSCORRUPTED;
 +	}
 +	nextents = XFS_IFORK_NEXTENTS(ip, whichfork);
 +	ifp = XFS_IFORK_PTR(ip, whichfork);
 +
 +	/*
 +	 * We know that the size is valid (it's checked in iformat_btree)
 +	 */
 +	ifp->if_bytes = ifp->if_real_bytes = 0;
 +	xfs_iext_add(ifp, 0, nextents);
 +	error = xfs_bmap_read_extents(tp, ip, whichfork);
 +	if (error) {
 +		xfs_iext_destroy(ifp);
 +		return error;
 +	}
 +	ifp->if_flags |= XFS_IFEXTENTS;
 +	return 0;
 +}
 +/*
++=======
++>>>>>>> 211e95bbab71 (xfs: merge xfs_bmap_read_extents into xfs_iread_extents)
   * Reallocate the space for if_broot based on the number of records
   * being added or deleted as indicated in rec_diff.  Move the records
   * and pointers in if_broot to fit the new size.  When shrinking this
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
diff --git a/fs/xfs/libxfs/xfs_bmap.h b/fs/xfs/libxfs/xfs_bmap.h
index bbb72c6ceb86..f483abfac1e7 100644
--- a/fs/xfs/libxfs/xfs_bmap.h
+++ b/fs/xfs/libxfs/xfs_bmap.h
@@ -176,8 +176,6 @@ int	xfs_bmap_last_before(struct xfs_trans *tp, struct xfs_inode *ip,
 int	xfs_bmap_last_offset(struct xfs_inode *ip, xfs_fileoff_t *unused,
 		int whichfork);
 int	xfs_bmap_one_block(struct xfs_inode *ip, int whichfork);
-int	xfs_bmap_read_extents(struct xfs_trans *tp, struct xfs_inode *ip,
-		int whichfork);
 int	xfs_bmapi_read(struct xfs_inode *ip, xfs_fileoff_t bno,
 		xfs_filblks_t len, struct xfs_bmbt_irec *mval,
 		int *nmap, int flags);
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.c
