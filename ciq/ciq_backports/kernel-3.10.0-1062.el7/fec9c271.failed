openvswitch: load and reference the NAT helper.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Flavio Leitner <fbl@redhat.com>
commit fec9c271b8f1bde1086be5aa415cdb586e0dc800
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fec9c271.failed

This improves the original commit 17c357efe5ec ("openvswitch: load
NAT helper") where it unconditionally tries to load the module for
every flow using NAT, so not efficient when loading multiple flows.
It also doesn't hold any references to the NAT module while the
flow is active.

This change fixes those problems. It will try to load the module
only if it's not present. It grabs a reference to the NAT module
and holds it while the flow is active. Finally, an error message
shows up if either actions above fails.

Fixes: 17c357efe5ec ("openvswitch: load NAT helper")
	Signed-off-by: Flavio Leitner <fbl@redhat.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit fec9c271b8f1bde1086be5aa415cdb586e0dc800)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/conntrack.c
diff --cc net/openvswitch/conntrack.c
index 16ab80c02e9c,c4128082f88b..000000000000
--- a/net/openvswitch/conntrack.c
+++ b/net/openvswitch/conntrack.c
@@@ -1222,16 -1322,24 +1223,24 @@@ static int ovs_ct_add_helper(struct ovs
  		return -ENOMEM;
  	}
  
+ #ifdef CONFIG_NF_NAT_NEEDED
+ 	if (info->nat) {
+ 		ret = nf_nat_helper_try_module_get(name, info->family,
+ 						   key->ip.proto);
+ 		if (ret) {
+ 			nf_conntrack_helper_put(helper);
+ 			OVS_NLERR(log, "Failed to load \"%s\" NAT helper, error: %d",
+ 				  name, ret);
+ 			return ret;
+ 		}
+ 	}
+ #endif
  	rcu_assign_pointer(help->helper, helper);
  	info->helper = helper;
- 
- 	if (info->nat)
- 		request_module("ip_nat_%s", name);
- 
- 	return 0;
+ 	return ret;
  }
  
 -#if IS_ENABLED(CONFIG_NF_NAT)
 +#ifdef CONFIG_NF_NAT_NEEDED
  static int parse_nat(const struct nlattr *attr,
  		     struct ovs_conntrack_info *info, bool log)
  {
@@@ -1681,13 -1810,435 +1690,26 @@@ void ovs_ct_free_action(const struct nl
  
  static void __ovs_ct_free_action(struct ovs_conntrack_info *ct_info)
  {
++<<<<<<< HEAD
 +	if (ct_info->helper)
 +		module_put(ct_info->helper->me);
 +	if (ct_info->ct)
++=======
+ 	if (ct_info->helper) {
+ #ifdef CONFIG_NF_NAT_NEEDED
+ 		if (ct_info->nat)
+ 			nf_nat_helper_put(ct_info->helper);
+ #endif
+ 		nf_conntrack_helper_put(ct_info->helper);
+ 	}
+ 	if (ct_info->ct) {
+ 		if (ct_info->timeout[0])
+ 			nf_ct_destroy_timeout(ct_info->ct);
++>>>>>>> fec9c271b8f1 (openvswitch: load and reference the NAT helper.)
  		nf_ct_tmpl_free(ct_info->ct);
 -	}
 -}
 -
 -#if	IS_ENABLED(CONFIG_NETFILTER_CONNCOUNT)
 -static int ovs_ct_limit_init(struct net *net, struct ovs_net *ovs_net)
 -{
 -	int i, err;
 -
 -	ovs_net->ct_limit_info = kmalloc(sizeof(*ovs_net->ct_limit_info),
 -					 GFP_KERNEL);
 -	if (!ovs_net->ct_limit_info)
 -		return -ENOMEM;
 -
 -	ovs_net->ct_limit_info->default_limit = OVS_CT_LIMIT_DEFAULT;
 -	ovs_net->ct_limit_info->limits =
 -		kmalloc_array(CT_LIMIT_HASH_BUCKETS, sizeof(struct hlist_head),
 -			      GFP_KERNEL);
 -	if (!ovs_net->ct_limit_info->limits) {
 -		kfree(ovs_net->ct_limit_info);
 -		return -ENOMEM;
 -	}
 -
 -	for (i = 0; i < CT_LIMIT_HASH_BUCKETS; i++)
 -		INIT_HLIST_HEAD(&ovs_net->ct_limit_info->limits[i]);
 -
 -	ovs_net->ct_limit_info->data =
 -		nf_conncount_init(net, NFPROTO_INET, sizeof(u32));
 -
 -	if (IS_ERR(ovs_net->ct_limit_info->data)) {
 -		err = PTR_ERR(ovs_net->ct_limit_info->data);
 -		kfree(ovs_net->ct_limit_info->limits);
 -		kfree(ovs_net->ct_limit_info);
 -		pr_err("openvswitch: failed to init nf_conncount %d\n", err);
 -		return err;
 -	}
 -	return 0;
 -}
 -
 -static void ovs_ct_limit_exit(struct net *net, struct ovs_net *ovs_net)
 -{
 -	const struct ovs_ct_limit_info *info = ovs_net->ct_limit_info;
 -	int i;
 -
 -	nf_conncount_destroy(net, NFPROTO_INET, info->data);
 -	for (i = 0; i < CT_LIMIT_HASH_BUCKETS; ++i) {
 -		struct hlist_head *head = &info->limits[i];
 -		struct ovs_ct_limit *ct_limit;
 -
 -		hlist_for_each_entry_rcu(ct_limit, head, hlist_node)
 -			kfree_rcu(ct_limit, rcu);
 -	}
 -	kfree(ovs_net->ct_limit_info->limits);
 -	kfree(ovs_net->ct_limit_info);
 -}
 -
 -static struct sk_buff *
 -ovs_ct_limit_cmd_reply_start(struct genl_info *info, u8 cmd,
 -			     struct ovs_header **ovs_reply_header)
 -{
 -	struct ovs_header *ovs_header = info->userhdr;
 -	struct sk_buff *skb;
 -
 -	skb = genlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
 -	if (!skb)
 -		return ERR_PTR(-ENOMEM);
 -
 -	*ovs_reply_header = genlmsg_put(skb, info->snd_portid,
 -					info->snd_seq,
 -					&dp_ct_limit_genl_family, 0, cmd);
 -
 -	if (!*ovs_reply_header) {
 -		nlmsg_free(skb);
 -		return ERR_PTR(-EMSGSIZE);
 -	}
 -	(*ovs_reply_header)->dp_ifindex = ovs_header->dp_ifindex;
 -
 -	return skb;
 -}
 -
 -static bool check_zone_id(int zone_id, u16 *pzone)
 -{
 -	if (zone_id >= 0 && zone_id <= 65535) {
 -		*pzone = (u16)zone_id;
 -		return true;
 -	}
 -	return false;
  }
  
 -static int ovs_ct_limit_set_zone_limit(struct nlattr *nla_zone_limit,
 -				       struct ovs_ct_limit_info *info)
 -{
 -	struct ovs_zone_limit *zone_limit;
 -	int rem;
 -	u16 zone;
 -
 -	rem = NLA_ALIGN(nla_len(nla_zone_limit));
 -	zone_limit = (struct ovs_zone_limit *)nla_data(nla_zone_limit);
 -
 -	while (rem >= sizeof(*zone_limit)) {
 -		if (unlikely(zone_limit->zone_id ==
 -				OVS_ZONE_LIMIT_DEFAULT_ZONE)) {
 -			ovs_lock();
 -			info->default_limit = zone_limit->limit;
 -			ovs_unlock();
 -		} else if (unlikely(!check_zone_id(
 -				zone_limit->zone_id, &zone))) {
 -			OVS_NLERR(true, "zone id is out of range");
 -		} else {
 -			struct ovs_ct_limit *ct_limit;
 -
 -			ct_limit = kmalloc(sizeof(*ct_limit), GFP_KERNEL);
 -			if (!ct_limit)
 -				return -ENOMEM;
 -
 -			ct_limit->zone = zone;
 -			ct_limit->limit = zone_limit->limit;
 -
 -			ovs_lock();
 -			ct_limit_set(info, ct_limit);
 -			ovs_unlock();
 -		}
 -		rem -= NLA_ALIGN(sizeof(*zone_limit));
 -		zone_limit = (struct ovs_zone_limit *)((u8 *)zone_limit +
 -				NLA_ALIGN(sizeof(*zone_limit)));
 -	}
 -
 -	if (rem)
 -		OVS_NLERR(true, "set zone limit has %d unknown bytes", rem);
 -
 -	return 0;
 -}
 -
 -static int ovs_ct_limit_del_zone_limit(struct nlattr *nla_zone_limit,
 -				       struct ovs_ct_limit_info *info)
 -{
 -	struct ovs_zone_limit *zone_limit;
 -	int rem;
 -	u16 zone;
 -
 -	rem = NLA_ALIGN(nla_len(nla_zone_limit));
 -	zone_limit = (struct ovs_zone_limit *)nla_data(nla_zone_limit);
 -
 -	while (rem >= sizeof(*zone_limit)) {
 -		if (unlikely(zone_limit->zone_id ==
 -				OVS_ZONE_LIMIT_DEFAULT_ZONE)) {
 -			ovs_lock();
 -			info->default_limit = OVS_CT_LIMIT_DEFAULT;
 -			ovs_unlock();
 -		} else if (unlikely(!check_zone_id(
 -				zone_limit->zone_id, &zone))) {
 -			OVS_NLERR(true, "zone id is out of range");
 -		} else {
 -			ovs_lock();
 -			ct_limit_del(info, zone);
 -			ovs_unlock();
 -		}
 -		rem -= NLA_ALIGN(sizeof(*zone_limit));
 -		zone_limit = (struct ovs_zone_limit *)((u8 *)zone_limit +
 -				NLA_ALIGN(sizeof(*zone_limit)));
 -	}
 -
 -	if (rem)
 -		OVS_NLERR(true, "del zone limit has %d unknown bytes", rem);
 -
 -	return 0;
 -}
 -
 -static int ovs_ct_limit_get_default_limit(struct ovs_ct_limit_info *info,
 -					  struct sk_buff *reply)
 -{
 -	struct ovs_zone_limit zone_limit;
 -	int err;
 -
 -	zone_limit.zone_id = OVS_ZONE_LIMIT_DEFAULT_ZONE;
 -	zone_limit.limit = info->default_limit;
 -	err = nla_put_nohdr(reply, sizeof(zone_limit), &zone_limit);
 -	if (err)
 -		return err;
 -
 -	return 0;
 -}
 -
 -static int __ovs_ct_limit_get_zone_limit(struct net *net,
 -					 struct nf_conncount_data *data,
 -					 u16 zone_id, u32 limit,
 -					 struct sk_buff *reply)
 -{
 -	struct nf_conntrack_zone ct_zone;
 -	struct ovs_zone_limit zone_limit;
 -	u32 conncount_key = zone_id;
 -
 -	zone_limit.zone_id = zone_id;
 -	zone_limit.limit = limit;
 -	nf_ct_zone_init(&ct_zone, zone_id, NF_CT_DEFAULT_ZONE_DIR, 0);
 -
 -	zone_limit.count = nf_conncount_count(net, data, &conncount_key, NULL,
 -					      &ct_zone);
 -	return nla_put_nohdr(reply, sizeof(zone_limit), &zone_limit);
 -}
 -
 -static int ovs_ct_limit_get_zone_limit(struct net *net,
 -				       struct nlattr *nla_zone_limit,
 -				       struct ovs_ct_limit_info *info,
 -				       struct sk_buff *reply)
 -{
 -	struct ovs_zone_limit *zone_limit;
 -	int rem, err;
 -	u32 limit;
 -	u16 zone;
 -
 -	rem = NLA_ALIGN(nla_len(nla_zone_limit));
 -	zone_limit = (struct ovs_zone_limit *)nla_data(nla_zone_limit);
 -
 -	while (rem >= sizeof(*zone_limit)) {
 -		if (unlikely(zone_limit->zone_id ==
 -				OVS_ZONE_LIMIT_DEFAULT_ZONE)) {
 -			err = ovs_ct_limit_get_default_limit(info, reply);
 -			if (err)
 -				return err;
 -		} else if (unlikely(!check_zone_id(zone_limit->zone_id,
 -							&zone))) {
 -			OVS_NLERR(true, "zone id is out of range");
 -		} else {
 -			rcu_read_lock();
 -			limit = ct_limit_get(info, zone);
 -			rcu_read_unlock();
 -
 -			err = __ovs_ct_limit_get_zone_limit(
 -				net, info->data, zone, limit, reply);
 -			if (err)
 -				return err;
 -		}
 -		rem -= NLA_ALIGN(sizeof(*zone_limit));
 -		zone_limit = (struct ovs_zone_limit *)((u8 *)zone_limit +
 -				NLA_ALIGN(sizeof(*zone_limit)));
 -	}
 -
 -	if (rem)
 -		OVS_NLERR(true, "get zone limit has %d unknown bytes", rem);
 -
 -	return 0;
 -}
 -
 -static int ovs_ct_limit_get_all_zone_limit(struct net *net,
 -					   struct ovs_ct_limit_info *info,
 -					   struct sk_buff *reply)
 -{
 -	struct ovs_ct_limit *ct_limit;
 -	struct hlist_head *head;
 -	int i, err = 0;
 -
 -	err = ovs_ct_limit_get_default_limit(info, reply);
 -	if (err)
 -		return err;
 -
 -	rcu_read_lock();
 -	for (i = 0; i < CT_LIMIT_HASH_BUCKETS; ++i) {
 -		head = &info->limits[i];
 -		hlist_for_each_entry_rcu(ct_limit, head, hlist_node) {
 -			err = __ovs_ct_limit_get_zone_limit(net, info->data,
 -				ct_limit->zone, ct_limit->limit, reply);
 -			if (err)
 -				goto exit_err;
 -		}
 -	}
 -
 -exit_err:
 -	rcu_read_unlock();
 -	return err;
 -}
 -
 -static int ovs_ct_limit_cmd_set(struct sk_buff *skb, struct genl_info *info)
 -{
 -	struct nlattr **a = info->attrs;
 -	struct sk_buff *reply;
 -	struct ovs_header *ovs_reply_header;
 -	struct ovs_net *ovs_net = net_generic(sock_net(skb->sk), ovs_net_id);
 -	struct ovs_ct_limit_info *ct_limit_info = ovs_net->ct_limit_info;
 -	int err;
 -
 -	reply = ovs_ct_limit_cmd_reply_start(info, OVS_CT_LIMIT_CMD_SET,
 -					     &ovs_reply_header);
 -	if (IS_ERR(reply))
 -		return PTR_ERR(reply);
 -
 -	if (!a[OVS_CT_LIMIT_ATTR_ZONE_LIMIT]) {
 -		err = -EINVAL;
 -		goto exit_err;
 -	}
 -
 -	err = ovs_ct_limit_set_zone_limit(a[OVS_CT_LIMIT_ATTR_ZONE_LIMIT],
 -					  ct_limit_info);
 -	if (err)
 -		goto exit_err;
 -
 -	static_branch_enable(&ovs_ct_limit_enabled);
 -
 -	genlmsg_end(reply, ovs_reply_header);
 -	return genlmsg_reply(reply, info);
 -
 -exit_err:
 -	nlmsg_free(reply);
 -	return err;
 -}
 -
 -static int ovs_ct_limit_cmd_del(struct sk_buff *skb, struct genl_info *info)
 -{
 -	struct nlattr **a = info->attrs;
 -	struct sk_buff *reply;
 -	struct ovs_header *ovs_reply_header;
 -	struct ovs_net *ovs_net = net_generic(sock_net(skb->sk), ovs_net_id);
 -	struct ovs_ct_limit_info *ct_limit_info = ovs_net->ct_limit_info;
 -	int err;
 -
 -	reply = ovs_ct_limit_cmd_reply_start(info, OVS_CT_LIMIT_CMD_DEL,
 -					     &ovs_reply_header);
 -	if (IS_ERR(reply))
 -		return PTR_ERR(reply);
 -
 -	if (!a[OVS_CT_LIMIT_ATTR_ZONE_LIMIT]) {
 -		err = -EINVAL;
 -		goto exit_err;
 -	}
 -
 -	err = ovs_ct_limit_del_zone_limit(a[OVS_CT_LIMIT_ATTR_ZONE_LIMIT],
 -					  ct_limit_info);
 -	if (err)
 -		goto exit_err;
 -
 -	genlmsg_end(reply, ovs_reply_header);
 -	return genlmsg_reply(reply, info);
 -
 -exit_err:
 -	nlmsg_free(reply);
 -	return err;
 -}
 -
 -static int ovs_ct_limit_cmd_get(struct sk_buff *skb, struct genl_info *info)
 -{
 -	struct nlattr **a = info->attrs;
 -	struct nlattr *nla_reply;
 -	struct sk_buff *reply;
 -	struct ovs_header *ovs_reply_header;
 -	struct net *net = sock_net(skb->sk);
 -	struct ovs_net *ovs_net = net_generic(net, ovs_net_id);
 -	struct ovs_ct_limit_info *ct_limit_info = ovs_net->ct_limit_info;
 -	int err;
 -
 -	reply = ovs_ct_limit_cmd_reply_start(info, OVS_CT_LIMIT_CMD_GET,
 -					     &ovs_reply_header);
 -	if (IS_ERR(reply))
 -		return PTR_ERR(reply);
 -
 -	nla_reply = nla_nest_start_noflag(reply, OVS_CT_LIMIT_ATTR_ZONE_LIMIT);
 -
 -	if (a[OVS_CT_LIMIT_ATTR_ZONE_LIMIT]) {
 -		err = ovs_ct_limit_get_zone_limit(
 -			net, a[OVS_CT_LIMIT_ATTR_ZONE_LIMIT], ct_limit_info,
 -			reply);
 -		if (err)
 -			goto exit_err;
 -	} else {
 -		err = ovs_ct_limit_get_all_zone_limit(net, ct_limit_info,
 -						      reply);
 -		if (err)
 -			goto exit_err;
 -	}
 -
 -	nla_nest_end(reply, nla_reply);
 -	genlmsg_end(reply, ovs_reply_header);
 -	return genlmsg_reply(reply, info);
 -
 -exit_err:
 -	nlmsg_free(reply);
 -	return err;
 -}
 -
 -static struct genl_ops ct_limit_genl_ops[] = {
 -	{ .cmd = OVS_CT_LIMIT_CMD_SET,
 -		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 -		.flags = GENL_ADMIN_PERM, /* Requires CAP_NET_ADMIN
 -					   * privilege. */
 -		.doit = ovs_ct_limit_cmd_set,
 -	},
 -	{ .cmd = OVS_CT_LIMIT_CMD_DEL,
 -		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 -		.flags = GENL_ADMIN_PERM, /* Requires CAP_NET_ADMIN
 -					   * privilege. */
 -		.doit = ovs_ct_limit_cmd_del,
 -	},
 -	{ .cmd = OVS_CT_LIMIT_CMD_GET,
 -		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 -		.flags = 0,		  /* OK for unprivileged users. */
 -		.doit = ovs_ct_limit_cmd_get,
 -	},
 -};
 -
 -static const struct genl_multicast_group ovs_ct_limit_multicast_group = {
 -	.name = OVS_CT_LIMIT_MCGROUP,
 -};
 -
 -struct genl_family dp_ct_limit_genl_family __ro_after_init = {
 -	.hdrsize = sizeof(struct ovs_header),
 -	.name = OVS_CT_LIMIT_FAMILY,
 -	.version = OVS_CT_LIMIT_VERSION,
 -	.maxattr = OVS_CT_LIMIT_ATTR_MAX,
 -	.policy = ct_limit_policy,
 -	.netnsok = true,
 -	.parallel_ops = true,
 -	.ops = ct_limit_genl_ops,
 -	.n_ops = ARRAY_SIZE(ct_limit_genl_ops),
 -	.mcgrps = &ovs_ct_limit_multicast_group,
 -	.n_mcgrps = 1,
 -	.module = THIS_MODULE,
 -};
 -#endif
 -
 -int ovs_ct_init(struct net *net)
 +void ovs_ct_init(struct net *net)
  {
  	unsigned int n_bits = sizeof(struct ovs_key_ct_labels) * BITS_PER_BYTE;
  	struct ovs_net *ovs_net = net_generic(net, ovs_net_id);
* Unmerged path net/openvswitch/conntrack.c
