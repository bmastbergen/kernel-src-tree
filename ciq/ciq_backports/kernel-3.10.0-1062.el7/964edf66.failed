ext4: clear lockdep subtype for quota files on quota off

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jan Kara <jack@suse.cz>
commit 964edf66bf9ab70cb387b27946c0aef7b94c4d1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/964edf66.failed

Quota files have special ranking of i_data_sem lock. We inform lockdep
about it when turning on quotas however when turning quotas off, we
don't clear the lockdep subclass from i_data_sem lock and thus when the
inode gets later reused for a normal file or directory, lockdep gets
confused and complains about possible deadlocks. Fix the problem by
resetting lockdep subclass of i_data_sem on quota off.

	Cc: stable@vger.kernel.org
Fixes: daf647d2dd58cec59570d7698a45b98e580f2076
Reported-and-tested-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Reviewed-by: Andreas Dilger <adilger@dilger.ca>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit 964edf66bf9ab70cb387b27946c0aef7b94c4d1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/super.c
diff --cc fs/ext4/super.c
index fd0252f29e8f,8f05c72bc4ec..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -779,6 -841,23 +779,26 @@@ static void dump_orphan_list(struct sup
  	}
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_QUOTA
+ static int ext4_quota_off(struct super_block *sb, int type);
+ 
+ static inline void ext4_quota_off_umount(struct super_block *sb)
+ {
+ 	int type;
+ 
+ 	/* Use our quota_off function to clear inode flags etc. */
+ 	for (type = 0; type < EXT4_MAXQUOTAS; type++)
+ 		ext4_quota_off(sb, type);
+ }
+ #else
+ static inline void ext4_quota_off_umount(struct super_block *sb)
+ {
+ }
+ #endif
+ 
++>>>>>>> 964edf66bf9a (ext4: clear lockdep subtype for quota files on quota off)
  static void ext4_put_super(struct super_block *sb)
  {
  	struct ext4_sb_info *sbi = EXT4_SB(sb);
@@@ -5537,18 -5476,33 +5557,40 @@@ static int ext4_quota_off(struct super_
  	if (test_opt(sb, DELALLOC))
  		sync_filesystem(sb);
  
 -	if (!inode || !igrab(inode))
 +	if (!inode)
  		goto out;
  
++<<<<<<< HEAD
 +	/* Update modification times of quota files when userspace can
 +	 * start looking at them */
++=======
+ 	err = dquot_quota_off(sb, type);
+ 	if (err || ext4_has_feature_quota(sb))
+ 		goto out_put;
+ 
+ 	inode_lock(inode);
+ 	/*
+ 	 * Update modification times of quota files when userspace can
+ 	 * start looking at them. If we fail, we return success anyway since
+ 	 * this is not a hard failure and quotas are already disabled.
+ 	 */
++>>>>>>> 964edf66bf9a (ext4: clear lockdep subtype for quota files on quota off)
  	handle = ext4_journal_start(inode, EXT4_HT_QUOTA, 1);
  	if (IS_ERR(handle))
 -		goto out_unlock;
 -	EXT4_I(inode)->i_flags &= ~(EXT4_NOATIME_FL | EXT4_IMMUTABLE_FL);
 -	inode_set_flags(inode, 0, S_NOATIME | S_IMMUTABLE);
 -	inode->i_mtime = inode->i_ctime = current_time(inode);
 +		goto out;
 +	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
  	ext4_mark_inode_dirty(handle, inode);
  	ext4_journal_stop(handle);
- 
++<<<<<<< HEAD
++
++=======
+ out_unlock:
+ 	inode_unlock(inode);
+ out_put:
+ 	lockdep_set_quota_inode(inode, I_DATA_SEM_NORMAL);
+ 	iput(inode);
+ 	return err;
++>>>>>>> 964edf66bf9a (ext4: clear lockdep subtype for quota files on quota off)
  out:
  	return dquot_quota_off(sb, type);
  }
* Unmerged path fs/ext4/super.c
