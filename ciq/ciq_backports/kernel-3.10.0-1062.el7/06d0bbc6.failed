powerpc/asm: Add a patch_site macro & helpers for patching instructions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [powerpc] asm: Add a patch_site macro & helpers for patching instructions (Gustavo Duarte) [1694459]
Rebuild_FUZZ: 94.03%
commit-author Michael Ellerman <mpe@ellerman.id.au>
commit 06d0bbc6d0f56dacac3a79900e9a9a0d5972d818
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/06d0bbc6.failed

Add a macro and some helper C functions for patching single asm
instructions.

The gas macro means we can do something like:

  1:	nop
  	patch_site 1b, patch__foo

Which is less visually distracting than defining a GLOBAL symbol at 1,
and also doesn't pollute the symbol table which can confuse eg. perf.

These are obviously similar to our existing feature sections, but are
not automatically patched based on CPU/MMU features, rather they are
designed to be manually patched by C code at some arbitrary point.

	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 06d0bbc6d0f56dacac3a79900e9a9a0d5972d818)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/code-patching.h
diff --cc arch/powerpc/include/asm/code-patching.h
index 87f2a56a692e,31733a95bbd0..000000000000
--- a/arch/powerpc/include/asm/code-patching.h
+++ b/arch/powerpc/include/asm/code-patching.h
@@@ -29,6 -32,9 +29,12 @@@ unsigned int create_cond_branch(const u
  				unsigned long target, int flags);
  int patch_branch(unsigned int *addr, unsigned long target, int flags);
  int patch_instruction(unsigned int *addr, unsigned int instr);
++<<<<<<< HEAD
++=======
+ int raw_patch_instruction(unsigned int *addr, unsigned int instr);
+ int patch_instruction_site(s32 *addr, unsigned int instr);
+ int patch_branch_site(s32 *site, unsigned long target, int flags);
++>>>>>>> 06d0bbc6d0f5 (powerpc/asm: Add a patch_site macro & helpers for patching instructions)
  
  int instr_is_relative_branch(unsigned int instr);
  int instr_is_relative_link_branch(unsigned int instr);
diff --git a/arch/powerpc/include/asm/code-patching-asm.h b/arch/powerpc/include/asm/code-patching-asm.h
new file mode 100644
index 000000000000..ed7b1448493a
--- /dev/null
+++ b/arch/powerpc/include/asm/code-patching-asm.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2018, Michael Ellerman, IBM Corporation.
+ */
+#ifndef _ASM_POWERPC_CODE_PATCHING_ASM_H
+#define _ASM_POWERPC_CODE_PATCHING_ASM_H
+
+/* Define a "site" that can be patched */
+.macro patch_site label name
+	.pushsection ".rodata"
+	.balign 4
+	.global \name
+\name:
+	.4byte	\label - .
+	.popsection
+.endm
+
+#endif /* _ASM_POWERPC_CODE_PATCHING_ASM_H */
* Unmerged path arch/powerpc/include/asm/code-patching.h
diff --git a/arch/powerpc/lib/code-patching.c b/arch/powerpc/lib/code-patching.c
index 940f8984e9e1..ce5dd3e20fff 100644
--- a/arch/powerpc/lib/code-patching.c
+++ b/arch/powerpc/lib/code-patching.c
@@ -32,6 +32,22 @@ int patch_branch(unsigned int *addr, unsigned long target, int flags)
 	return patch_instruction(addr, create_branch(addr, target, flags));
 }
 
+int patch_branch_site(s32 *site, unsigned long target, int flags)
+{
+	unsigned int *addr;
+
+	addr = (unsigned int *)((unsigned long)site + *site);
+	return patch_instruction(addr, create_branch(addr, target, flags));
+}
+
+int patch_instruction_site(s32 *site, unsigned int instr)
+{
+	unsigned int *addr;
+
+	addr = (unsigned int *)((unsigned long)site + *site);
+	return patch_instruction(addr, instr);
+}
+
 bool is_offset_in_branch_range(long offset)
 {
 	/*
