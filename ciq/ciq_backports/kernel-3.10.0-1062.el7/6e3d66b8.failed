uio_hv_generic: set size of ring buffer attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit 6e3d66b80f670fdc64b9a120362a9f94b0494621
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6e3d66b8.failed

The original code had ring size as a module parameter, but
then it was made a fixed value.  The code to set the size of
the ring buffer binary file was lost in the transistion.
The size is needed by user mode driver to know the size of
the ring buffer.

Fixes: 37b96a4931db ("uio_hv_generic: support sub-channels")
	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 6e3d66b80f670fdc64b9a120362a9f94b0494621)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/uio/uio_hv_generic.c
diff --cc drivers/uio/uio_hv_generic.c
index d608865b1e1e,7ff659dff11d..000000000000
--- a/drivers/uio/uio_hv_generic.c
+++ b/drivers/uio/uio_hv_generic.c
@@@ -91,6 -103,124 +91,127 @@@ static void hv_uio_channel_cb(void *con
  	uio_event_notify(&pdata->info);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Callback from vmbus_event when channel is rescinded.
+  */
+ static void hv_uio_rescind(struct vmbus_channel *channel)
+ {
+ 	struct hv_device *hv_dev = channel->primary_channel->device_obj;
+ 	struct hv_uio_private_data *pdata = hv_get_drvdata(hv_dev);
+ 
+ 	/*
+ 	 * Turn off the interrupt file handle
+ 	 * Next read for event will return -EIO
+ 	 */
+ 	pdata->info.irq = 0;
+ 
+ 	/* Wake up reader */
+ 	uio_event_notify(&pdata->info);
+ }
+ 
+ /*
+  * Handle fault when looking for sub channel ring buffer
+  * Subchannel ring buffer is same as resource 0 which is main ring buffer
+  * This is derived from uio_vma_fault
+  */
+ static int hv_uio_vma_fault(struct vm_fault *vmf)
+ {
+ 	struct vm_area_struct *vma = vmf->vma;
+ 	void *ring_buffer = vma->vm_private_data;
+ 	struct page *page;
+ 	void *addr;
+ 
+ 	addr = ring_buffer + (vmf->pgoff << PAGE_SHIFT);
+ 	page = virt_to_page(addr);
+ 	get_page(page);
+ 	vmf->page = page;
+ 	return 0;
+ }
+ 
+ static const struct vm_operations_struct hv_uio_vm_ops = {
+ 	.fault = hv_uio_vma_fault,
+ };
+ 
+ /* Sysfs API to allow mmap of the ring buffers */
+ static int hv_uio_ring_mmap(struct file *filp, struct kobject *kobj,
+ 			    struct bin_attribute *attr,
+ 			    struct vm_area_struct *vma)
+ {
+ 	struct vmbus_channel *channel
+ 		= container_of(kobj, struct vmbus_channel, kobj);
+ 	unsigned long requested_pages, actual_pages;
+ 
+ 	if (vma->vm_end < vma->vm_start)
+ 		return -EINVAL;
+ 
+ 	/* only allow 0 for now */
+ 	if (vma->vm_pgoff > 0)
+ 		return -EINVAL;
+ 
+ 	requested_pages = vma_pages(vma);
+ 	actual_pages = 2 * HV_RING_SIZE;
+ 	if (requested_pages > actual_pages)
+ 		return -EINVAL;
+ 
+ 	vma->vm_private_data = channel->ringbuffer_pages;
+ 	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
+ 	vma->vm_ops = &hv_uio_vm_ops;
+ 	return 0;
+ }
+ 
+ static const struct bin_attribute ring_buffer_bin_attr = {
+ 	.attr = {
+ 		.name = "ring",
+ 		.mode = 0600,
+ 	},
+ 	.size = 2 * HV_RING_SIZE * PAGE_SIZE,
+ 	.mmap = hv_uio_ring_mmap,
+ };
+ 
+ /* Callback from VMBUS subystem when new channel created. */
+ static void
+ hv_uio_new_channel(struct vmbus_channel *new_sc)
+ {
+ 	struct hv_device *hv_dev = new_sc->primary_channel->device_obj;
+ 	struct device *device = &hv_dev->device;
+ 	struct hv_uio_private_data *pdata = hv_get_drvdata(hv_dev);
+ 	const size_t ring_bytes = HV_RING_SIZE * PAGE_SIZE;
+ 	int ret;
+ 
+ 	/* Create host communication ring */
+ 	ret = vmbus_open(new_sc, ring_bytes, ring_bytes, NULL, 0,
+ 			 hv_uio_channel_cb, pdata);
+ 	if (ret) {
+ 		dev_err(device, "vmbus_open subchannel failed: %d\n", ret);
+ 		return;
+ 	}
+ 
+ 	/* Disable interrupts on sub channel */
+ 	new_sc->inbound.ring_buffer->interrupt_mask = 1;
+ 	set_channel_read_mode(new_sc, HV_CALL_ISR);
+ 
+ 	ret = sysfs_create_bin_file(&new_sc->kobj, &ring_buffer_bin_attr);
+ 	if (ret) {
+ 		dev_err(device, "sysfs create ring bin file failed; %d\n", ret);
+ 		vmbus_close(new_sc);
+ 	}
+ }
+ 
+ static void
+ hv_uio_cleanup(struct hv_device *dev, struct hv_uio_private_data *pdata)
+ {
+ 	if (pdata->send_gpadl)
+ 		vmbus_teardown_gpadl(dev->channel, pdata->send_gpadl);
+ 	vfree(pdata->send_buf);
+ 
+ 	if (pdata->recv_gpadl)
+ 		vmbus_teardown_gpadl(dev->channel, pdata->recv_gpadl);
+ 	vfree(pdata->recv_buf);
+ }
+ 
++>>>>>>> 6e3d66b80f67 (uio_hv_generic: set size of ring buffer attribute)
  static int
  hv_uio_probe(struct hv_device *dev,
  	     const struct hv_vmbus_device_id *dev_id)
* Unmerged path drivers/uio/uio_hv_generic.c
