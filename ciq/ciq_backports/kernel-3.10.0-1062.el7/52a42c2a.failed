vmbus: keep pointer to ring buffer page

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit 52a42c2a90226dc61c99bbd0cb096deeb52c334b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/52a42c2a.failed

Avoid going from struct page to virt address (and back) by just
keeping pointer to the allocated pages instead of virt address.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 52a42c2a90226dc61c99bbd0cb096deeb52c334b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/uio/uio_hv_generic.c
diff --cc drivers/uio/uio_hv_generic.c
index d608865b1e1e,ba67a5267557..000000000000
--- a/drivers/uio/uio_hv_generic.c
+++ b/drivers/uio/uio_hv_generic.c
@@@ -91,6 -101,93 +91,96 @@@ static void hv_uio_channel_cb(void *con
  	uio_event_notify(&pdata->info);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Callback from vmbus_event when channel is rescinded.
+  */
+ static void hv_uio_rescind(struct vmbus_channel *channel)
+ {
+ 	struct hv_device *hv_dev = channel->primary_channel->device_obj;
+ 	struct hv_uio_private_data *pdata = hv_get_drvdata(hv_dev);
+ 
+ 	/*
+ 	 * Turn off the interrupt file handle
+ 	 * Next read for event will return -EIO
+ 	 */
+ 	pdata->info.irq = 0;
+ 
+ 	/* Wake up reader */
+ 	uio_event_notify(&pdata->info);
+ }
+ 
+ /* Sysfs API to allow mmap of the ring buffers
+  * The ring buffer is allocated as contiguous memory by vmbus_open
+  */
+ static int hv_uio_ring_mmap(struct file *filp, struct kobject *kobj,
+ 			    struct bin_attribute *attr,
+ 			    struct vm_area_struct *vma)
+ {
+ 	struct vmbus_channel *channel
+ 		= container_of(kobj, struct vmbus_channel, kobj);
+ 	struct hv_device *dev = channel->primary_channel->device_obj;
+ 	u16 q_idx = channel->offermsg.offer.sub_channel_index;
+ 	void *ring_buffer = page_address(channel->ringbuffer_page);
+ 
+ 	dev_dbg(&dev->device, "mmap channel %u pages %#lx at %#lx\n",
+ 		q_idx, vma_pages(vma), vma->vm_pgoff);
+ 
+ 	return vm_iomap_memory(vma, virt_to_phys(ring_buffer),
+ 			       channel->ringbuffer_pagecount << PAGE_SHIFT);
+ }
+ 
+ static const struct bin_attribute ring_buffer_bin_attr = {
+ 	.attr = {
+ 		.name = "ring",
+ 		.mode = 0600,
+ 	},
+ 	.size = 2 * HV_RING_SIZE * PAGE_SIZE,
+ 	.mmap = hv_uio_ring_mmap,
+ };
+ 
+ /* Callback from VMBUS subsystem when new channel created. */
+ static void
+ hv_uio_new_channel(struct vmbus_channel *new_sc)
+ {
+ 	struct hv_device *hv_dev = new_sc->primary_channel->device_obj;
+ 	struct device *device = &hv_dev->device;
+ 	const size_t ring_bytes = HV_RING_SIZE * PAGE_SIZE;
+ 	int ret;
+ 
+ 	/* Create host communication ring */
+ 	ret = vmbus_open(new_sc, ring_bytes, ring_bytes, NULL, 0,
+ 			 hv_uio_channel_cb, new_sc);
+ 	if (ret) {
+ 		dev_err(device, "vmbus_open subchannel failed: %d\n", ret);
+ 		return;
+ 	}
+ 
+ 	/* Disable interrupts on sub channel */
+ 	new_sc->inbound.ring_buffer->interrupt_mask = 1;
+ 	set_channel_read_mode(new_sc, HV_CALL_ISR);
+ 
+ 	ret = sysfs_create_bin_file(&new_sc->kobj, &ring_buffer_bin_attr);
+ 	if (ret) {
+ 		dev_err(device, "sysfs create ring bin file failed; %d\n", ret);
+ 		vmbus_close(new_sc);
+ 	}
+ }
+ 
+ static void
+ hv_uio_cleanup(struct hv_device *dev, struct hv_uio_private_data *pdata)
+ {
+ 	if (pdata->send_gpadl)
+ 		vmbus_teardown_gpadl(dev->channel, pdata->send_gpadl);
+ 	vfree(pdata->send_buf);
+ 
+ 	if (pdata->recv_gpadl)
+ 		vmbus_teardown_gpadl(dev->channel, pdata->recv_gpadl);
+ 	vfree(pdata->recv_buf);
+ }
+ 
++>>>>>>> 52a42c2a9022 (vmbus: keep pointer to ring buffer page)
  static int
  hv_uio_probe(struct hv_device *dev,
  	     const struct hv_vmbus_device_id *dev_id)
diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c
index 1d5898605d9d..ed0db2d64e22 100644
--- a/drivers/hv/channel.c
+++ b/drivers/hv/channel.c
@@ -77,11 +77,14 @@ int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,
 	unsigned long flags;
 	int ret, err = 0;
 	struct page *page;
+	unsigned int order;
 
 	if (send_ringbuffer_size % PAGE_SIZE ||
 	    recv_ringbuffer_size % PAGE_SIZE)
 		return -EINVAL;
 
+	order = get_order(send_ringbuffer_size + recv_ringbuffer_size);
+
 	spin_lock_irqsave(&newchannel->lock, flags);
 	if (newchannel->state == CHANNEL_OPEN_STATE) {
 		newchannel->state = CHANNEL_OPENING_STATE;
@@ -96,21 +99,17 @@ int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,
 
 	/* Allocate the ring buffer */
 	page = alloc_pages_node(cpu_to_node(newchannel->target_cpu),
-				GFP_KERNEL|__GFP_ZERO,
-				get_order(send_ringbuffer_size +
-				recv_ringbuffer_size));
+				GFP_KERNEL|__GFP_ZERO, order);
 
 	if (!page)
-		page = alloc_pages(GFP_KERNEL|__GFP_ZERO,
-				   get_order(send_ringbuffer_size +
-					     recv_ringbuffer_size));
+		page = alloc_pages(GFP_KERNEL|__GFP_ZERO, order);
 
 	if (!page) {
 		err = -ENOMEM;
 		goto error_set_chnstate;
 	}
 
-	newchannel->ringbuffer_pages = page_address(page);
+	newchannel->ringbuffer_page = page;
 	newchannel->ringbuffer_pagecount = (send_ringbuffer_size +
 					   recv_ringbuffer_size) >> PAGE_SHIFT;
 
@@ -225,8 +224,7 @@ error_free_gpadl:
 error_free_pages:
 	hv_ringbuffer_cleanup(&newchannel->outbound);
 	hv_ringbuffer_cleanup(&newchannel->inbound);
-	__free_pages(page,
-		     get_order(send_ringbuffer_size + recv_ringbuffer_size));
+	__free_pages(page, order);
 error_set_chnstate:
 	newchannel->state = CHANNEL_OPEN_STATE;
 	return err;
@@ -635,8 +633,8 @@ static int vmbus_close_internal(struct vmbus_channel *channel)
 	hv_ringbuffer_cleanup(&channel->outbound);
 	hv_ringbuffer_cleanup(&channel->inbound);
 
-	free_pages((unsigned long)channel->ringbuffer_pages,
-		get_order(channel->ringbuffer_pagecount * PAGE_SIZE));
+	__free_pages(channel->ringbuffer_page,
+		     get_order(channel->ringbuffer_pagecount << PAGE_SHIFT));
 
 out:
 	/* re-enable tasklet for use on re-open */
* Unmerged path drivers/uio/uio_hv_generic.c
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index a015a435d28c..040d420953bb 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -705,7 +705,7 @@ struct vmbus_channel {
 	u32 ringbuffer_gpadlhandle;
 
 	/* Allocated memory for ring buffer */
-	void *ringbuffer_pages;
+	struct page *ringbuffer_page;
 	u32 ringbuffer_pagecount;
 	struct hv_ring_buffer_info outbound;	/* send to parent */
 	struct hv_ring_buffer_info inbound;	/* receive from parent */
