fs: mark expected switch fall-throughs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [usb] mark expected switch fall-throughs (Torez Smith) [1657401]
Rebuild_FUZZ: 94.44%
commit-author Gustavo A. R. Silva <gustavo@embeddedor.com>
commit 0a4c92657f2543bb8fd480c5af90c6bb87f18e00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0a4c9265.failed

In preparation to enabling -Wimplicit-fallthrough, mark switch cases
where we are expecting to fall through.

This patch fixes the following warnings:

fs/affs/affs.h:124:38: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/configfs/dir.c:1692:11: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/configfs/dir.c:1694:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/ceph/file.c:249:3: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/ext4/hash.c:233:15: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/ext4/hash.c:246:15: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/ext2/inode.c:1237:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/ext2/inode.c:1244:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/ext4/indirect.c:1182:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/ext4/indirect.c:1188:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/ext4/indirect.c:1432:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/ext4/indirect.c:1440:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/f2fs/node.c:618:8: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/f2fs/node.c:620:8: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/btrfs/ref-verify.c:522:15: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/gfs2/bmap.c:711:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/gfs2/bmap.c:722:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/jffs2/fs.c:339:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/nfsd/nfs4proc.c:429:12: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/ufs/util.h:62:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/ufs/util.h:43:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/fcntl.c:770:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/seq_file.c:319:10: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/libfs.c:148:11: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/libfs.c:150:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/signalfd.c:178:7: warning: this statement may fall through [-Wimplicit-fallthrough=]
fs/locks.c:1473:16: warning: this statement may fall through [-Wimplicit-fallthrough=]

Warning level 3 was used: -Wimplicit-fallthrough=3

This patch is part of the ongoing efforts to enabling
-Wimplicit-fallthrough.

	Reviewed-by: Kees Cook <keescook@chromium.org>
	Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
(cherry picked from commit 0a4c92657f2543bb8fd480c5af90c6bb87f18e00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/affs/super.c
#	fs/btrfs/ref-verify.c
#	fs/btrfs/volumes.h
#	fs/ceph/file.c
#	fs/f2fs/node.c
#	fs/nfsd/nfs4proc.c
diff --cc fs/affs/super.c
index 45161a832bbc,3accc6daec68..000000000000
--- a/fs/affs/super.c
+++ b/fs/affs/super.c
@@@ -433,50 -466,51 +433,88 @@@ got_root
  	 * not recommended.
  	 */
  	if ((chksum == FS_DCFFS || chksum == MUFS_DCFFS || chksum == FS_DCOFS
 -	     || chksum == MUFS_DCOFS) && !sb_rdonly(sb)) {
 -		pr_notice("Dircache FS - mounting %s read only\n", sb->s_id);
 -		sb->s_flags |= SB_RDONLY;
 +	     || chksum == MUFS_DCOFS) && !(sb->s_flags & MS_RDONLY)) {
 +		printk(KERN_NOTICE "AFFS: Dircache FS - mounting %s read only\n",
 +			sb->s_id);
 +		sb->s_flags |= MS_RDONLY;
  	}
  	switch (chksum) {
++<<<<<<< HEAD
 +		case MUFS_FS:
 +		case MUFS_INTLFFS:
 +		case MUFS_DCFFS:
 +			sbi->s_flags |= SF_MUFS;
 +			/* fall thru */
 +		case FS_INTLFFS:
 +		case FS_DCFFS:
 +			sbi->s_flags |= SF_INTL;
 +			break;
 +		case MUFS_FFS:
 +			sbi->s_flags |= SF_MUFS;
 +			break;
 +		case FS_FFS:
 +			break;
 +		case MUFS_OFS:
 +			sbi->s_flags |= SF_MUFS;
 +			/* fall thru */
 +		case FS_OFS:
 +			sbi->s_flags |= SF_OFS;
 +			sb->s_flags |= MS_NOEXEC;
 +			break;
 +		case MUFS_DCOFS:
 +		case MUFS_INTLOFS:
 +			sbi->s_flags |= SF_MUFS;
 +		case FS_DCOFS:
 +		case FS_INTLOFS:
 +			sbi->s_flags |= SF_INTL | SF_OFS;
 +			sb->s_flags |= MS_NOEXEC;
 +			break;
 +		default:
 +			printk(KERN_ERR "AFFS: Unknown filesystem on device %s: %08X\n",
 +				sb->s_id, chksum);
 +			goto out_error;
++=======
+ 	case MUFS_FS:
+ 	case MUFS_INTLFFS:
+ 	case MUFS_DCFFS:
+ 		affs_set_opt(sbi->s_flags, SF_MUFS);
+ 		/* fall thru */
+ 	case FS_INTLFFS:
+ 	case FS_DCFFS:
+ 		affs_set_opt(sbi->s_flags, SF_INTL);
+ 		break;
+ 	case MUFS_FFS:
+ 		affs_set_opt(sbi->s_flags, SF_MUFS);
+ 		break;
+ 	case FS_FFS:
+ 		break;
+ 	case MUFS_OFS:
+ 		affs_set_opt(sbi->s_flags, SF_MUFS);
+ 		/* fall through */
+ 	case FS_OFS:
+ 		affs_set_opt(sbi->s_flags, SF_OFS);
+ 		sb->s_flags |= SB_NOEXEC;
+ 		break;
+ 	case MUFS_DCOFS:
+ 	case MUFS_INTLOFS:
+ 		affs_set_opt(sbi->s_flags, SF_MUFS);
+ 		/* fall through */
+ 	case FS_DCOFS:
+ 	case FS_INTLOFS:
+ 		affs_set_opt(sbi->s_flags, SF_INTL);
+ 		affs_set_opt(sbi->s_flags, SF_OFS);
+ 		sb->s_flags |= SB_NOEXEC;
+ 		break;
+ 	default:
+ 		pr_err("Unknown filesystem on device %s: %08X\n",
+ 		       sb->s_id, chksum);
+ 		return -EINVAL;
++>>>>>>> 0a4c92657f25 (fs: mark expected switch fall-throughs)
  	}
  
 -	if (affs_test_opt(mount_flags, SF_VERBOSE)) {
 +	if (mount_flags & SF_VERBOSE) {
  		u8 len = AFFS_ROOT_TAIL(sb, root_bh)->disk_name[0];
 -		pr_notice("Mounting volume \"%.*s\": Type=%.3s\\%c, Blocksize=%d\n",
 +		printk(KERN_NOTICE "AFFS: Mounting volume \"%.*s\": Type=%.3s\\%c, Blocksize=%d\n",
  			len > 31 ? 31 : len,
  			AFFS_ROOT_TAIL(sb, root_bh)->disk_name + 1,
  			sig, sig[3] + '0', blocksize);
diff --cc fs/btrfs/volumes.h
index 0ac90f8d85bd,adcbb4e7b1a0..000000000000
--- a/fs/btrfs/volumes.h
+++ b/fs/btrfs/volumes.h
@@@ -371,42 -374,57 +371,67 @@@ struct btrfs_balance_control 
  	struct btrfs_balance_progress stat;
  };
  
++<<<<<<< HEAD
 +int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,
 +				   u64 end, u64 *length);
++=======
+ enum btrfs_map_op {
+ 	BTRFS_MAP_READ,
+ 	BTRFS_MAP_WRITE,
+ 	BTRFS_MAP_DISCARD,
+ 	BTRFS_MAP_GET_READ_MIRRORS,
+ };
+ 
+ static inline enum btrfs_map_op btrfs_op(struct bio *bio)
+ {
+ 	switch (bio_op(bio)) {
+ 	case REQ_OP_DISCARD:
+ 		return BTRFS_MAP_DISCARD;
+ 	case REQ_OP_WRITE:
+ 		return BTRFS_MAP_WRITE;
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		/* fall through */
+ 	case REQ_OP_READ:
+ 		return BTRFS_MAP_READ;
+ 	}
+ }
+ 
++>>>>>>> 0a4c92657f25 (fs: mark expected switch fall-throughs)
  void btrfs_get_bbio(struct btrfs_bio *bbio);
  void btrfs_put_bbio(struct btrfs_bio *bbio);
 -int btrfs_map_block(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 +int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,
  		    u64 logical, u64 *length,
  		    struct btrfs_bio **bbio_ret, int mirror_num);
 -int btrfs_map_sblock(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,
 +int btrfs_map_sblock(struct btrfs_fs_info *fs_info, int rw,
  		     u64 logical, u64 *length,
 -		     struct btrfs_bio **bbio_ret);
 -int btrfs_rmap_block(struct btrfs_fs_info *fs_info, u64 chunk_start,
 -		     u64 physical, u64 **logical, int *naddrs, int *stripe_len);
 -int btrfs_read_sys_array(struct btrfs_fs_info *fs_info);
 -int btrfs_read_chunk_tree(struct btrfs_fs_info *fs_info);
 -int btrfs_alloc_chunk(struct btrfs_trans_handle *trans, u64 type);
 +		     struct btrfs_bio **bbio_ret, int mirror_num,
 +		     int need_raid_map);
 +int btrfs_rmap_block(struct btrfs_mapping_tree *map_tree,
 +		     u64 chunk_start, u64 physical, u64 devid,
 +		     u64 **logical, int *naddrs, int *stripe_len);
 +int btrfs_read_sys_array(struct btrfs_root *root);
 +int btrfs_read_chunk_tree(struct btrfs_root *root);
 +int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,
 +		      struct btrfs_root *extent_root, u64 type);
  void btrfs_mapping_init(struct btrfs_mapping_tree *tree);
  void btrfs_mapping_tree_free(struct btrfs_mapping_tree *tree);
 -blk_status_t btrfs_map_bio(struct btrfs_fs_info *fs_info, struct bio *bio,
 -			   int mirror_num, int async_submit);
 +int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,
 +		  int mirror_num, int async_submit);
  int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,
  		       fmode_t flags, void *holder);
 -struct btrfs_device *btrfs_scan_one_device(const char *path,
 -					   fmode_t flags, void *holder);
 -int btrfs_forget_devices(const char *path);
 +int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,
 +			  struct btrfs_fs_devices **fs_devices_ret);
  int btrfs_close_devices(struct btrfs_fs_devices *fs_devices);
 -void btrfs_free_extra_devids(struct btrfs_fs_devices *fs_devices, int step);
 -void btrfs_assign_next_active_device(struct btrfs_device *device,
 -				     struct btrfs_device *this_dev);
 -struct btrfs_device *btrfs_find_device_by_devspec(struct btrfs_fs_info *fs_info,
 -						  u64 devid,
 -						  const char *devpath);
 +void btrfs_close_extra_devices(struct btrfs_fs_devices *fs_devices, int step);
 +void btrfs_assign_next_active_device(struct btrfs_fs_info *fs_info,
 +		struct btrfs_device *device, struct btrfs_device *this_dev);
 +int btrfs_find_device_missing_or_by_path(struct btrfs_root *root,
 +					 char *device_path,
 +					 struct btrfs_device **device);
 +int btrfs_find_device_by_devspec(struct btrfs_root *root, u64 devid,
 +					 char *devpath,
 +					 struct btrfs_device **device);
  struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,
  					const u64 *devid,
  					const u8 *uuid);
diff --cc fs/ceph/file.c
index 84d17ac3bc8e,84725b53ac21..000000000000
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@@ -214,6 -245,9 +214,12 @@@ static int ceph_init_file(struct inode 
  
  	switch (inode->i_mode & S_IFMT) {
  	case S_IFREG:
++<<<<<<< HEAD
++=======
+ 		ceph_fscache_register_inode_cookie(inode);
+ 		ceph_fscache_file_set_cookie(inode, file);
+ 		/* fall through */
++>>>>>>> 0a4c92657f25 (fs: mark expected switch fall-throughs)
  	case S_IFDIR:
  		ret = ceph_init_file_info(inode, file, fmode,
  						S_ISDIR(inode->i_mode));
diff --cc fs/f2fs/node.c
index 3df43b4efd89,d6e48a6487d5..000000000000
--- a/fs/f2fs/node.c
+++ b/fs/f2fs/node.c
@@@ -308,7 -570,64 +308,68 @@@ void get_node_info(struct f2fs_sb_info 
  	f2fs_put_page(page, 1);
  cache:
  	/* cache nat entry */
++<<<<<<< HEAD
 +	cache_nat_entry(NM_I(sbi), nid, &ne);
++=======
+ 	cache_nat_entry(sbi, nid, &ne);
+ 	return 0;
+ }
+ 
+ /*
+  * readahead MAX_RA_NODE number of node pages.
+  */
+ static void f2fs_ra_node_pages(struct page *parent, int start, int n)
+ {
+ 	struct f2fs_sb_info *sbi = F2FS_P_SB(parent);
+ 	struct blk_plug plug;
+ 	int i, end;
+ 	nid_t nid;
+ 
+ 	blk_start_plug(&plug);
+ 
+ 	/* Then, try readahead for siblings of the desired node */
+ 	end = start + n;
+ 	end = min(end, NIDS_PER_BLOCK);
+ 	for (i = start; i < end; i++) {
+ 		nid = get_nid(parent, i, false);
+ 		f2fs_ra_node_page(sbi, nid);
+ 	}
+ 
+ 	blk_finish_plug(&plug);
+ }
+ 
+ pgoff_t f2fs_get_next_page_offset(struct dnode_of_data *dn, pgoff_t pgofs)
+ {
+ 	const long direct_index = ADDRS_PER_INODE(dn->inode);
+ 	const long direct_blks = ADDRS_PER_BLOCK;
+ 	const long indirect_blks = ADDRS_PER_BLOCK * NIDS_PER_BLOCK;
+ 	unsigned int skipped_unit = ADDRS_PER_BLOCK;
+ 	int cur_level = dn->cur_level;
+ 	int max_level = dn->max_level;
+ 	pgoff_t base = 0;
+ 
+ 	if (!dn->max_level)
+ 		return pgofs + 1;
+ 
+ 	while (max_level-- > cur_level)
+ 		skipped_unit *= NIDS_PER_BLOCK;
+ 
+ 	switch (dn->max_level) {
+ 	case 3:
+ 		base += 2 * indirect_blks;
+ 		/* fall through */
+ 	case 2:
+ 		base += 2 * direct_blks;
+ 		/* fall through */
+ 	case 1:
+ 		base += direct_index;
+ 		break;
+ 	default:
+ 		f2fs_bug_on(F2FS_I_SB(dn->inode), 1);
+ 	}
+ 
+ 	return ((pgofs - base) / skipped_unit + 1) * skipped_unit + base;
++>>>>>>> 0a4c92657f25 (fs: mark expected switch fall-throughs)
  }
  
  /*
diff --cc fs/nfsd/nfs4proc.c
index 4a0ef5cfe8c6,4680ad3bf55b..000000000000
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@@ -419,6 -426,8 +419,11 @@@ nfsd4_open(struct svc_rqst *rqstp, stru
  			if (status)
  				goto out;
  			open->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;
++<<<<<<< HEAD
++=======
+ 			reclaim = true;
+ 			/* fall through */
++>>>>>>> 0a4c92657f25 (fs: mark expected switch fall-throughs)
  		case NFS4_OPEN_CLAIM_FH:
  		case NFS4_OPEN_CLAIM_DELEG_CUR_FH:
  			status = do_open_fhandle(rqstp, cstate, open);
* Unmerged path fs/btrfs/ref-verify.c
* Unmerged path fs/affs/super.c
* Unmerged path fs/btrfs/ref-verify.c
* Unmerged path fs/btrfs/volumes.h
* Unmerged path fs/ceph/file.c
diff --git a/fs/configfs/dir.c b/fs/configfs/dir.c
index b8f7d00b73ed..9727aa2f3c94 100644
--- a/fs/configfs/dir.c
+++ b/fs/configfs/dir.c
@@ -1656,9 +1656,11 @@ static loff_t configfs_dir_lseek(struct file *file, loff_t offset, int whence)
 	switch (whence) {
 		case 1:
 			offset += file->f_pos;
+			/* fall through */
 		case 0:
 			if (offset >= 0)
 				break;
+			/* fall through */
 		default:
 			mutex_unlock(&file_inode(file)->i_mutex);
 			return -EINVAL;
* Unmerged path fs/f2fs/node.c
diff --git a/fs/fcntl.c b/fs/fcntl.c
index 5c030954e9f9..ad77fd8f55c6 100644
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
@@ -506,7 +506,7 @@ static void send_sigio_to_task(struct task_struct *p,
 			si.si_fd    = fd;
 			if (!do_send_sig_info(signum, &si, p, group))
 				break;
-		/* fall-through: fall back on the old plain SIGIO signal */
+		/* fall-through - fall back on the old plain SIGIO signal */
 		case 0:
 			do_send_sig_info(SIGIO, SEND_SIG_PRIV, p, group);
 	}
diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index 3990a05f99a4..daf1083a16df 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -592,7 +592,7 @@ static int gfs2_iomap_alloc(struct inode *inode, struct iomap *iomap,
 			}
 			if (n == 0)
 				break;
-		/* Branching from existing tree */
+		/* fall through - To branching from existing tree */
 		case ALLOC_GROW_DEPTH:
 			if (i > 1 && i < mp->mp_fheight)
 				gfs2_trans_add_meta(ip->i_gl, mp->mp_bh[i-1]);
@@ -603,7 +603,7 @@ static int gfs2_iomap_alloc(struct inode *inode, struct iomap *iomap,
 				state = ALLOC_DATA;
 			if (n == 0)
 				break;
-		/* Tree complete, adding data blocks */
+		/* fall through - To tree complete, adding data blocks */
 		case ALLOC_DATA:
 			BUG_ON(n > dblks);
 			BUG_ON(mp->mp_bh[end_of_metadata] == NULL);
diff --git a/fs/jffs2/fs.c b/fs/jffs2/fs.c
index 00ed6c64a579..46157445de55 100644
--- a/fs/jffs2/fs.c
+++ b/fs/jffs2/fs.c
@@ -340,6 +340,7 @@ struct inode *jffs2_iget(struct super_block *sb, unsigned long ino)
 			rdev = old_decode_dev(je16_to_cpu(jdev.old_id));
 		else
 			rdev = new_decode_dev(je32_to_cpu(jdev.new_id));
+		/* fall through */
 
 	case S_IFSOCK:
 	case S_IFIFO:
diff --git a/fs/libfs.c b/fs/libfs.c
index 1f2023801ea9..41cd27bad299 100644
--- a/fs/libfs.c
+++ b/fs/libfs.c
@@ -95,9 +95,11 @@ loff_t dcache_dir_lseek(struct file *file, loff_t offset, int whence)
 	switch (whence) {
 		case 1:
 			offset += file->f_pos;
+			/* fall through */
 		case 0:
 			if (offset >= 0)
 				break;
+			/* fall through */
 		default:
 			mutex_unlock(&dentry->d_inode->i_mutex);
 			return -EINVAL;
diff --git a/fs/locks.c b/fs/locks.c
index a3072b4762e2..cbecace80009 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1274,7 +1274,7 @@ static void lease_clear_pending(struct file_lock *fl, int arg)
 	switch (arg) {
 	case F_UNLCK:
 		fl->fl_flags &= ~FL_UNLOCK_PENDING;
-		/* fall through: */
+		/* fall through */
 	case F_RDLCK:
 		fl->fl_flags &= ~FL_DOWNGRADE_PENDING;
 	}
* Unmerged path fs/nfsd/nfs4proc.c
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 13023d60dc0a..5455ce3d0721 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -2509,6 +2509,7 @@ nfsd4_exchange_id(struct svc_rqst *rqstp,
 		break;
 	default:				/* checked by xdr code */
 		WARN_ON_ONCE(1);
+		/* fall through */
 	case SP4_SSV:
 		status = nfserr_encr_alg_unsupp;
 		goto out_nolock;
diff --git a/fs/ocfs2/cluster/quorum.c b/fs/ocfs2/cluster/quorum.c
index c19897d0fe14..18c3245da138 100644
--- a/fs/ocfs2/cluster/quorum.c
+++ b/fs/ocfs2/cluster/quorum.c
@@ -81,6 +81,7 @@ static void o2quo_fence_self(void)
 	default:
 		WARN_ON(o2nm_single_cluster->cl_fence_method >=
 			O2NM_FENCE_METHODS);
+		/* fall through */
 	case O2NM_FENCE_RESET:
 		printk(KERN_ERR "*** ocfs2 is very sorry to be fencing this "
 		       "system by restarting ***\n");
diff --git a/fs/seq_file.c b/fs/seq_file.c
index bc7a9ec855aa..18c62f7f84db 100644
--- a/fs/seq_file.c
+++ b/fs/seq_file.c
@@ -331,6 +331,7 @@ loff_t seq_lseek(struct file *file, loff_t offset, int whence)
 	switch (whence) {
 	case SEEK_CUR:
 		offset += file->f_pos;
+		/* fall through */
 	case SEEK_SET:
 		if (offset < 0)
 			break;
diff --git a/fs/signalfd.c b/fs/signalfd.c
index 424b7b65321f..47d42af05ef3 100644
--- a/fs/signalfd.c
+++ b/fs/signalfd.c
@@ -168,6 +168,7 @@ static ssize_t signalfd_dequeue(struct signalfd_ctx *ctx, siginfo_t *info,
 		if (!nonblock)
 			break;
 		ret = -EAGAIN;
+		/* fall through */
 	default:
 		spin_unlock_irq(&current->sighand->siglock);
 		return ret;
diff --git a/fs/ufs/util.h b/fs/ufs/util.h
index 954175928240..59b605649559 100644
--- a/fs/ufs/util.h
+++ b/fs/ufs/util.h
@@ -41,7 +41,7 @@ ufs_get_fs_state(struct super_block *sb, struct ufs_super_block_first *usb1,
 	case UFS_ST_SUNOS:
 		if (fs32_to_cpu(sb, usb3->fs_postblformat) == UFS_42POSTBLFMT)
 			return fs32_to_cpu(sb, usb1->fs_u0.fs_sun.fs_state);
-		/* Fall Through to UFS_ST_SUN */
+		/* Fall Through - to UFS_ST_SUN */
 	case UFS_ST_SUN:
 		return fs32_to_cpu(sb, usb3->fs_un2.fs_sun.fs_state);
 	case UFS_ST_SUNx86:
@@ -62,7 +62,7 @@ ufs_set_fs_state(struct super_block *sb, struct ufs_super_block_first *usb1,
 			usb1->fs_u0.fs_sun.fs_state = cpu_to_fs32(sb, value);
 			break;
 		}
-		/* Fall Through to UFS_ST_SUN */
+		/* Fall Through - to UFS_ST_SUN */
 	case UFS_ST_SUN:
 		usb3->fs_un2.fs_sun.fs_state = cpu_to_fs32(sb, value);
 		break;
