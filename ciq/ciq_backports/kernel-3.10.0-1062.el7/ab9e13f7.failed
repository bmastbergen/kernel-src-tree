fuse: allow ctime flushing to userspace

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Maxim Patlasov <MPatlasov@parallels.com>
commit ab9e13f7c771b511d8f71666e83cb27bcc635b98
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ab9e13f7.failed

The patch extends fuse_setattr_in, and extends the flush procedure
(fuse_flush_times()) called on ->write_inode() to send the ctime as well as
mtime.

	Signed-off-by: Maxim Patlasov <MPatlasov@parallels.com>
	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit ab9e13f7c771b511d8f71666e83cb27bcc635b98)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dir.c
#	fs/fuse/file.c
#	fs/fuse/fuse_i.h
#	include/uapi/linux/fuse.h
diff --cc fs/fuse/dir.c
index 3e1c8cd01fea,e6ba579e2937..000000000000
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@@ -1645,6 -1576,62 +1645,65 @@@ void fuse_release_nowrite(struct inode 
  	spin_unlock(&fc->lock);
  }
  
++<<<<<<< HEAD
++=======
+ static void fuse_setattr_fill(struct fuse_conn *fc, struct fuse_req *req,
+ 			      struct inode *inode,
+ 			      struct fuse_setattr_in *inarg_p,
+ 			      struct fuse_attr_out *outarg_p)
+ {
+ 	req->in.h.opcode = FUSE_SETATTR;
+ 	req->in.h.nodeid = get_node_id(inode);
+ 	req->in.numargs = 1;
+ 	req->in.args[0].size = sizeof(*inarg_p);
+ 	req->in.args[0].value = inarg_p;
+ 	req->out.numargs = 1;
+ 	if (fc->minor < 9)
+ 		req->out.args[0].size = FUSE_COMPAT_ATTR_OUT_SIZE;
+ 	else
+ 		req->out.args[0].size = sizeof(*outarg_p);
+ 	req->out.args[0].value = outarg_p;
+ }
+ 
+ /*
+  * Flush inode->i_mtime to the server
+  */
+ int fuse_flush_times(struct inode *inode, struct fuse_file *ff)
+ {
+ 	struct fuse_conn *fc = get_fuse_conn(inode);
+ 	struct fuse_req *req;
+ 	struct fuse_setattr_in inarg;
+ 	struct fuse_attr_out outarg;
+ 	int err;
+ 
+ 	req = fuse_get_req_nopages(fc);
+ 	if (IS_ERR(req))
+ 		return PTR_ERR(req);
+ 
+ 	memset(&inarg, 0, sizeof(inarg));
+ 	memset(&outarg, 0, sizeof(outarg));
+ 
+ 	inarg.valid = FATTR_MTIME;
+ 	inarg.mtime = inode->i_mtime.tv_sec;
+ 	inarg.mtimensec = inode->i_mtime.tv_nsec;
+ 	if (fc->minor >= 23) {
+ 		inarg.valid |= FATTR_CTIME;
+ 		inarg.ctime = inode->i_ctime.tv_sec;
+ 		inarg.ctimensec = inode->i_ctime.tv_nsec;
+ 	}
+ 	if (ff) {
+ 		inarg.valid |= FATTR_FH;
+ 		inarg.fh = ff->fh;
+ 	}
+ 	fuse_setattr_fill(fc, req, inode, &inarg, &outarg);
+ 	fuse_request_send(fc, req);
+ 	err = req->out.h.error;
+ 	fuse_put_request(fc, req);
+ 
+ 	return err;
+ }
+ 
++>>>>>>> ab9e13f7c771 (fuse: allow ctime flushing to userspace)
  /*
   * Set attributes, and at the same time refresh them.
   *
diff --cc fs/fuse/file.c
index 109621a5f183,96d513e01a5d..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -1655,6 -1675,29 +1655,32 @@@ static struct fuse_file *fuse_write_fil
  	return ff;
  }
  
++<<<<<<< HEAD
++=======
+ static struct fuse_file *fuse_write_file_get(struct fuse_conn *fc,
+ 					     struct fuse_inode *fi)
+ {
+ 	struct fuse_file *ff = __fuse_write_file_get(fc, fi);
+ 	WARN_ON(!ff);
+ 	return ff;
+ }
+ 
+ int fuse_write_inode(struct inode *inode, struct writeback_control *wbc)
+ {
+ 	struct fuse_conn *fc = get_fuse_conn(inode);
+ 	struct fuse_inode *fi = get_fuse_inode(inode);
+ 	struct fuse_file *ff;
+ 	int err;
+ 
+ 	ff = __fuse_write_file_get(fc, fi);
+ 	err = fuse_flush_times(inode, ff);
+ 	if (ff)
+ 		fuse_file_put(ff, 0);
+ 
+ 	return err;
+ }
+ 
++>>>>>>> ab9e13f7c771 (fuse: allow ctime flushing to userspace)
  static int fuse_writepage_locked(struct page *page)
  {
  	struct address_space *mapping = page->mapping;
diff --cc fs/fuse/fuse_i.h
index a6fe9fdc6997,40677e33504f..000000000000
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@@ -900,7 -887,10 +900,14 @@@ long fuse_ioctl_common(struct file *fil
  unsigned fuse_file_poll(struct file *file, poll_table *wait);
  int fuse_dev_release(struct inode *inode, struct file *file);
  
++<<<<<<< HEAD
 +void fuse_write_update_size(struct inode *inode, loff_t pos);
++=======
+ bool fuse_write_update_size(struct inode *inode, loff_t pos);
+ 
+ int fuse_flush_times(struct inode *inode, struct fuse_file *ff);
+ int fuse_write_inode(struct inode *inode, struct writeback_control *wbc);
++>>>>>>> ab9e13f7c771 (fuse: allow ctime flushing to userspace)
  
  int fuse_do_setattr(struct inode *inode, struct iattr *attr,
  		    struct file *file);
diff --cc include/uapi/linux/fuse.h
index 5d0f06afda03,e86a21acef75..000000000000
--- a/include/uapi/linux/fuse.h
+++ b/include/uapi/linux/fuse.h
@@@ -100,10 -100,6 +100,13 @@@
   *  - add reserved space to fuse_init_out
   *  - add FATTR_CTIME
   *  - add ctime and ctimensec to fuse_setattr_in
++<<<<<<< HEAD
 + *  - add FUSE_RENAME2 request
 + *
 + *  7.24
 + *  - add FUSE_LSEEK for SEEK_HOLE and SEEK_DATA support
++=======
++>>>>>>> ab9e13f7c771 (fuse: allow ctime flushing to userspace)
   */
  
  #ifndef _LINUX_FUSE_H
* Unmerged path fs/fuse/dir.c
* Unmerged path fs/fuse/file.c
* Unmerged path fs/fuse/fuse_i.h
* Unmerged path include/uapi/linux/fuse.h
