GFS2: Merge ordered and writeback writepage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Steven Whitehouse <swhiteho@redhat.com>
commit 9d35814355e2baba9de523941e2ce52235359670
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9d358143.failed

The writepages function was recently merged between writeback
and ordered mode. This completes the change by doing the same
with writepage. The remaining differences in writepage were
left over from some earlier time and not actually doing anything
useful.

	Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>
(cherry picked from commit 9d35814355e2baba9de523941e2ce52235359670)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/aops.c
diff --cc fs/gfs2/aops.c
index 1e7480923c2d,a9ea6f07774b..000000000000
--- a/fs/gfs2/aops.c
+++ b/fs/gfs2/aops.c
@@@ -142,58 -140,6 +141,61 @@@ static int gfs2_writepage(struct page *
  }
  
  /**
++<<<<<<< HEAD
 + * gfs2_ordered_writepage - Write page for ordered data files
 + * @page: The page to write
 + * @wbc: The writeback control
 + *
 + */
 +
 +static int gfs2_ordered_writepage(struct page *page,
 +				  struct writeback_control *wbc)
 +{
 +	struct inode *inode = page->mapping->host;
 +	struct gfs2_inode *ip = GFS2_I(inode);
 +	int ret;
 +
 +	ret = gfs2_writepage_common(page, wbc);
 +	if (ret <= 0)
 +		return ret;
 +
 +	if (!page_has_buffers(page)) {
 +		create_empty_buffers(page, inode->i_sb->s_blocksize,
 +				     (1 << BH_Dirty)|(1 << BH_Uptodate));
 +	}
 +	gfs2_page_add_databufs(ip, page, 0, inode->i_sb->s_blocksize-1);
 +	return block_write_full_page(page, gfs2_get_block_noalloc, wbc);
 +}
 +
 +/* This is the same as calling block_write_full_page, but it also
 + * writes pages outside of i_size
 + */
 +int gfs2_write_full_page(struct page *page, get_block_t *get_block,
 +			 struct writeback_control *wbc)
 +{
 +	struct inode * const inode = page->mapping->host;
 +	loff_t i_size = i_size_read(inode);
 +	const pgoff_t end_index = i_size >> PAGE_SHIFT;
 +	unsigned offset;
 +
 +	/*
 +	 * The page straddles i_size.  It must be zeroed out on each and every
 +	 * writepage invocation because it may be mmapped.  "A file is mapped
 +	 * in multiples of the page size.  For a file that is not a multiple of
 +	 * the  page size, the remaining memory is zeroed when mapped, and
 +	 * writes to that region are not written out to the file."
 +	 */
 +	offset = i_size & (PAGE_SIZE-1);
 +	if (page->index == end_index && offset)
 +		zero_user_segment(page, offset, PAGE_SIZE);
 +
 +	return __block_write_full_page(inode, page, get_block, wbc,
 +				       end_buffer_async_write);
 +}
 +
 +/**
++=======
++>>>>>>> 9d35814355e2 (GFS2: Merge ordered and writeback writepage)
   * __gfs2_jdata_writepage - The core of jdata writepage
   * @page: The page to write
   * @wbc: The writeback control
* Unmerged path fs/gfs2/aops.c
