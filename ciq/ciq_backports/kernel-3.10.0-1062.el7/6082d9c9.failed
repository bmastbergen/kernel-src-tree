net/mlx5: Fix mlx5_get_vector_affinity function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [kernel] mlx5: Fix mlx5_get_vector_affinity function (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 95.56%
commit-author Israel Rukshin <israelr@mellanox.com>
commit 6082d9c9c94a408d7409b5f2e4e42ac9e8b16d0d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6082d9c9.failed

Adding the vector offset when calling to mlx5_vector2eqn() is wrong.
This is because mlx5_vector2eqn() checks if EQ index is equal to vector number
and the fact that the internal completion vectors that mlx5 allocates
don't get an EQ index.

The second problem here is that using effective_affinity_mask gives the same
CPU for different vectors.
This leads to unmapped queues when calling it from blk_mq_rdma_map_queues().
This doesn't happen when using affinity_hint mask.

Fixes: 2572cf57d75a ("mlx5: fix mlx5_get_vector_affinity to start from completion vector 0")
Fixes: 05e0cc84e00c ("net/mlx5: Fix get vector affinity helper function")
	Signed-off-by: Israel Rukshin <israelr@mellanox.com>
	Reviewed-by: Max Gurtovoy <maxg@mellanox.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
(cherry picked from commit 6082d9c9c94a408d7409b5f2e4e42ac9e8b16d0d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mlx5/driver.h
diff --cc include/linux/mlx5/driver.h
index 4e54981203eb,2a156c5dfadd..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -1281,13 -1284,8 +1281,16 @@@ enum 
  };
  
  static inline const struct cpumask *
- mlx5_get_vector_affinity(struct mlx5_core_dev *dev, int vector)
+ mlx5_get_vector_affinity_hint(struct mlx5_core_dev *dev, int vector)
  {
++<<<<<<< HEAD
 +/* calling irq_to_desc will result to undefinded irq_desc symbol */
 +#ifndef CONFIG_GENERIC_HARDIRQS
 +	return cpu_possible_mask;
 +#else
 +	const struct cpumask *mask;
++=======
++>>>>>>> 6082d9c9c94a (net/mlx5: Fix mlx5_get_vector_affinity function)
  	struct irq_desc *desc;
  	unsigned int irq;
  	int eqn;
@@@ -1298,13 -1296,7 +1301,17 @@@
  		return NULL;
  
  	desc = irq_to_desc(irq);
++<<<<<<< HEAD
 +#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK
 +	mask = irq_data_get_effective_affinity_mask(&desc->irq_data);
 +#else
 +	mask = desc->irq_data.affinity;
 +#endif
 +	return mask;
 +#endif
++=======
+ 	return desc->affinity_hint;
++>>>>>>> 6082d9c9c94a (net/mlx5: Fix mlx5_get_vector_affinity function)
  }
  
  #endif /* MLX5_DRIVER_H */
diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c
index 70c3fef60c09..79f530a7dbe0 100644
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@ -4439,7 +4439,7 @@ mlx5_ib_get_vector_affinity(struct ib_device *ibdev, int comp_vector)
 {
 	struct mlx5_ib_dev *dev = to_mdev(ibdev);
 
-	return mlx5_get_vector_affinity(dev->mdev, comp_vector);
+	return mlx5_get_vector_affinity_hint(dev->mdev, comp_vector);
 }
 
 /* The mlx5_ib_multiport_mutex should be held when calling this function */
* Unmerged path include/linux/mlx5/driver.h
