io: change outX() to have their own IO barrier overrides

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Sinan Kaya <okaya@codeaurora.org>
commit a7851aa54c0cdd2f62457b72aee0da5d5586e514
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a7851aa5.failed

Open code writeX() inside outX() so that outX() variants have their own
overrideable Port IO barrier combinations as __io_pbw() and __io_paw() for
actions to be taken before port IO and after port IO write.

	Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
(cherry picked from commit a7851aa54c0cdd2f62457b72aee0da5d5586e514)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/asm-generic/io.h
diff --cc include/asm-generic/io.h
index 66a3fecbf792,53226d907c45..000000000000
--- a/include/asm-generic/io.h
+++ b/include/asm-generic/io.h
@@@ -294,6 -423,423 +294,426 @@@ static inline void outsl(unsigned long 
  #define IO_SPACE_LIMIT 0xffff
  #endif
  
++<<<<<<< HEAD
++=======
+ /*
+  * {in,out}{b,w,l}() access little endian I/O. {in,out}{b,w,l}_p() can be
+  * implemented on hardware that needs an additional delay for I/O accesses to
+  * take effect.
+  */
+ 
+ #ifndef inb
+ #define inb inb
+ static inline u8 inb(unsigned long addr)
+ {
+ 	return readb(PCI_IOBASE + addr);
+ }
+ #endif
+ 
+ #ifndef inw
+ #define inw inw
+ static inline u16 inw(unsigned long addr)
+ {
+ 	return readw(PCI_IOBASE + addr);
+ }
+ #endif
+ 
+ #ifndef inl
+ #define inl inl
+ static inline u32 inl(unsigned long addr)
+ {
+ 	return readl(PCI_IOBASE + addr);
+ }
+ #endif
+ 
+ #ifndef outb
+ #define outb outb
+ static inline void outb(u8 value, unsigned long addr)
+ {
+ 	__io_pbw();
+ 	__raw_writeb(value, PCI_IOBASE + addr);
+ 	__io_paw();
+ }
+ #endif
+ 
+ #ifndef outw
+ #define outw outw
+ static inline void outw(u16 value, unsigned long addr)
+ {
+ 	__io_pbw();
+ 	__raw_writew(cpu_to_le16(value), PCI_IOBASE + addr);
+ 	__io_paw();
+ }
+ #endif
+ 
+ #ifndef outl
+ #define outl outl
+ static inline void outl(u32 value, unsigned long addr)
+ {
+ 	__io_pbw();
+ 	__raw_writel(cpu_to_le32(value), PCI_IOBASE + addr);
+ 	__io_paw();
+ }
+ #endif
+ 
+ #ifndef inb_p
+ #define inb_p inb_p
+ static inline u8 inb_p(unsigned long addr)
+ {
+ 	return inb(addr);
+ }
+ #endif
+ 
+ #ifndef inw_p
+ #define inw_p inw_p
+ static inline u16 inw_p(unsigned long addr)
+ {
+ 	return inw(addr);
+ }
+ #endif
+ 
+ #ifndef inl_p
+ #define inl_p inl_p
+ static inline u32 inl_p(unsigned long addr)
+ {
+ 	return inl(addr);
+ }
+ #endif
+ 
+ #ifndef outb_p
+ #define outb_p outb_p
+ static inline void outb_p(u8 value, unsigned long addr)
+ {
+ 	outb(value, addr);
+ }
+ #endif
+ 
+ #ifndef outw_p
+ #define outw_p outw_p
+ static inline void outw_p(u16 value, unsigned long addr)
+ {
+ 	outw(value, addr);
+ }
+ #endif
+ 
+ #ifndef outl_p
+ #define outl_p outl_p
+ static inline void outl_p(u32 value, unsigned long addr)
+ {
+ 	outl(value, addr);
+ }
+ #endif
+ 
+ /*
+  * {in,out}s{b,w,l}{,_p}() are variants of the above that repeatedly access a
+  * single I/O port multiple times.
+  */
+ 
+ #ifndef insb
+ #define insb insb
+ static inline void insb(unsigned long addr, void *buffer, unsigned int count)
+ {
+ 	readsb(PCI_IOBASE + addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef insw
+ #define insw insw
+ static inline void insw(unsigned long addr, void *buffer, unsigned int count)
+ {
+ 	readsw(PCI_IOBASE + addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef insl
+ #define insl insl
+ static inline void insl(unsigned long addr, void *buffer, unsigned int count)
+ {
+ 	readsl(PCI_IOBASE + addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef outsb
+ #define outsb outsb
+ static inline void outsb(unsigned long addr, const void *buffer,
+ 			 unsigned int count)
+ {
+ 	writesb(PCI_IOBASE + addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef outsw
+ #define outsw outsw
+ static inline void outsw(unsigned long addr, const void *buffer,
+ 			 unsigned int count)
+ {
+ 	writesw(PCI_IOBASE + addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef outsl
+ #define outsl outsl
+ static inline void outsl(unsigned long addr, const void *buffer,
+ 			 unsigned int count)
+ {
+ 	writesl(PCI_IOBASE + addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef insb_p
+ #define insb_p insb_p
+ static inline void insb_p(unsigned long addr, void *buffer, unsigned int count)
+ {
+ 	insb(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef insw_p
+ #define insw_p insw_p
+ static inline void insw_p(unsigned long addr, void *buffer, unsigned int count)
+ {
+ 	insw(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef insl_p
+ #define insl_p insl_p
+ static inline void insl_p(unsigned long addr, void *buffer, unsigned int count)
+ {
+ 	insl(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef outsb_p
+ #define outsb_p outsb_p
+ static inline void outsb_p(unsigned long addr, const void *buffer,
+ 			   unsigned int count)
+ {
+ 	outsb(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef outsw_p
+ #define outsw_p outsw_p
+ static inline void outsw_p(unsigned long addr, const void *buffer,
+ 			   unsigned int count)
+ {
+ 	outsw(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef outsl_p
+ #define outsl_p outsl_p
+ static inline void outsl_p(unsigned long addr, const void *buffer,
+ 			   unsigned int count)
+ {
+ 	outsl(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef CONFIG_GENERIC_IOMAP
+ #ifndef ioread8
+ #define ioread8 ioread8
+ static inline u8 ioread8(const volatile void __iomem *addr)
+ {
+ 	return readb(addr);
+ }
+ #endif
+ 
+ #ifndef ioread16
+ #define ioread16 ioread16
+ static inline u16 ioread16(const volatile void __iomem *addr)
+ {
+ 	return readw(addr);
+ }
+ #endif
+ 
+ #ifndef ioread32
+ #define ioread32 ioread32
+ static inline u32 ioread32(const volatile void __iomem *addr)
+ {
+ 	return readl(addr);
+ }
+ #endif
+ 
+ #ifdef CONFIG_64BIT
+ #ifndef ioread64
+ #define ioread64 ioread64
+ static inline u64 ioread64(const volatile void __iomem *addr)
+ {
+ 	return readq(addr);
+ }
+ #endif
+ #endif /* CONFIG_64BIT */
+ 
+ #ifndef iowrite8
+ #define iowrite8 iowrite8
+ static inline void iowrite8(u8 value, volatile void __iomem *addr)
+ {
+ 	writeb(value, addr);
+ }
+ #endif
+ 
+ #ifndef iowrite16
+ #define iowrite16 iowrite16
+ static inline void iowrite16(u16 value, volatile void __iomem *addr)
+ {
+ 	writew(value, addr);
+ }
+ #endif
+ 
+ #ifndef iowrite32
+ #define iowrite32 iowrite32
+ static inline void iowrite32(u32 value, volatile void __iomem *addr)
+ {
+ 	writel(value, addr);
+ }
+ #endif
+ 
+ #ifdef CONFIG_64BIT
+ #ifndef iowrite64
+ #define iowrite64 iowrite64
+ static inline void iowrite64(u64 value, volatile void __iomem *addr)
+ {
+ 	writeq(value, addr);
+ }
+ #endif
+ #endif /* CONFIG_64BIT */
+ 
+ #ifndef ioread16be
+ #define ioread16be ioread16be
+ static inline u16 ioread16be(const volatile void __iomem *addr)
+ {
+ 	return swab16(readw(addr));
+ }
+ #endif
+ 
+ #ifndef ioread32be
+ #define ioread32be ioread32be
+ static inline u32 ioread32be(const volatile void __iomem *addr)
+ {
+ 	return swab32(readl(addr));
+ }
+ #endif
+ 
+ #ifdef CONFIG_64BIT
+ #ifndef ioread64be
+ #define ioread64be ioread64be
+ static inline u64 ioread64be(const volatile void __iomem *addr)
+ {
+ 	return swab64(readq(addr));
+ }
+ #endif
+ #endif /* CONFIG_64BIT */
+ 
+ #ifndef iowrite16be
+ #define iowrite16be iowrite16be
+ static inline void iowrite16be(u16 value, void volatile __iomem *addr)
+ {
+ 	writew(swab16(value), addr);
+ }
+ #endif
+ 
+ #ifndef iowrite32be
+ #define iowrite32be iowrite32be
+ static inline void iowrite32be(u32 value, volatile void __iomem *addr)
+ {
+ 	writel(swab32(value), addr);
+ }
+ #endif
+ 
+ #ifdef CONFIG_64BIT
+ #ifndef iowrite64be
+ #define iowrite64be iowrite64be
+ static inline void iowrite64be(u64 value, volatile void __iomem *addr)
+ {
+ 	writeq(swab64(value), addr);
+ }
+ #endif
+ #endif /* CONFIG_64BIT */
+ 
+ #ifndef ioread8_rep
+ #define ioread8_rep ioread8_rep
+ static inline void ioread8_rep(const volatile void __iomem *addr, void *buffer,
+ 			       unsigned int count)
+ {
+ 	readsb(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef ioread16_rep
+ #define ioread16_rep ioread16_rep
+ static inline void ioread16_rep(const volatile void __iomem *addr,
+ 				void *buffer, unsigned int count)
+ {
+ 	readsw(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef ioread32_rep
+ #define ioread32_rep ioread32_rep
+ static inline void ioread32_rep(const volatile void __iomem *addr,
+ 				void *buffer, unsigned int count)
+ {
+ 	readsl(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifdef CONFIG_64BIT
+ #ifndef ioread64_rep
+ #define ioread64_rep ioread64_rep
+ static inline void ioread64_rep(const volatile void __iomem *addr,
+ 				void *buffer, unsigned int count)
+ {
+ 	readsq(addr, buffer, count);
+ }
+ #endif
+ #endif /* CONFIG_64BIT */
+ 
+ #ifndef iowrite8_rep
+ #define iowrite8_rep iowrite8_rep
+ static inline void iowrite8_rep(volatile void __iomem *addr,
+ 				const void *buffer,
+ 				unsigned int count)
+ {
+ 	writesb(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef iowrite16_rep
+ #define iowrite16_rep iowrite16_rep
+ static inline void iowrite16_rep(volatile void __iomem *addr,
+ 				 const void *buffer,
+ 				 unsigned int count)
+ {
+ 	writesw(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef iowrite32_rep
+ #define iowrite32_rep iowrite32_rep
+ static inline void iowrite32_rep(volatile void __iomem *addr,
+ 				 const void *buffer,
+ 				 unsigned int count)
+ {
+ 	writesl(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifdef CONFIG_64BIT
+ #ifndef iowrite64_rep
+ #define iowrite64_rep iowrite64_rep
+ static inline void iowrite64_rep(volatile void __iomem *addr,
+ 				 const void *buffer,
+ 				 unsigned int count)
+ {
+ 	writesq(addr, buffer, count);
+ }
+ #endif
+ #endif /* CONFIG_64BIT */
+ #endif /* CONFIG_GENERIC_IOMAP */
+ 
++>>>>>>> a7851aa54c0c (io: change outX() to have their own IO barrier overrides)
  #ifdef __KERNEL__
  
  #include <linux/vmalloc.h>
* Unmerged path include/asm-generic/io.h
