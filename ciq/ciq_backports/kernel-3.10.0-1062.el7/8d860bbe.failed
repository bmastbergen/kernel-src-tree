kvm: vmx: Basic APIC virtualization controls have three settings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jim Mattson <jmattson@google.com>
commit 8d860bbeedef97fe981d28fa7b71d77f3b29563f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/8d860bbe.failed

Previously, we toggled between SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE
and SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES, depending on whether or
not the EXTD bit was set in MSR_IA32_APICBASE. However, if the local
APIC is disabled, we should not set either of these APIC
virtualization control bits.

	Signed-off-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 8d860bbeedef97fe981d28fa7b71d77f3b29563f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/include/asm/kvm_host.h
index 4091026435c1,187c8e09a019..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -906,8 -994,8 +906,13 @@@ struct kvm_x86_ops 
  	void (*refresh_apicv_exec_ctrl)(struct kvm_vcpu *vcpu);
  	void (*hwapic_irr_update)(struct kvm_vcpu *vcpu, int max_irr);
  	void (*hwapic_isr_update)(struct kvm_vcpu *vcpu, int isr);
++<<<<<<< HEAD
 +	void (*load_eoi_exitmap)(struct kvm_vcpu *vcpu);
 +	void (*set_virtual_x2apic_mode)(struct kvm_vcpu *vcpu, bool set);
++=======
+ 	void (*load_eoi_exitmap)(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap);
+ 	void (*set_virtual_apic_mode)(struct kvm_vcpu *vcpu);
++>>>>>>> 8d860bbeedef (kvm: vmx: Basic APIC virtualization controls have three settings)
  	void (*set_apic_access_page_addr)(struct kvm_vcpu *vcpu, hpa_t hpa);
  	void (*deliver_posted_interrupt)(struct kvm_vcpu *vcpu, int vector);
  	int (*sync_pir_to_irr)(struct kvm_vcpu *vcpu);
diff --cc arch/x86/kvm/vmx.c
index 5501a1957de2,4149c5ee09fc..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -573,8 -479,10 +573,9 @@@ struct nested_vmx 
  	 * data hold by vmcs12
  	 */
  	bool sync_shadow_vmcs;
 -	bool dirty_vmcs12;
  
- 	bool change_vmcs01_virtual_x2apic_mode;
+ 	bool change_vmcs01_virtual_apic_mode;
+ 
  	/* L2 must run next, and mustn't decide to exit to L1. */
  	bool nested_run_pending;
  
@@@ -8720,25 -9295,30 +8724,50 @@@ static void vmx_set_virtual_apic_mode(s
  		return;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * There is not point to enable virtualize x2apic without enable
 +	 * apicv
 +	 */
 +	if (!cpu_has_vmx_virtualize_x2apic_mode() ||
 +				!kvm_vcpu_apicv_active(vcpu))
 +		return;
 +
++=======
++>>>>>>> 8d860bbeedef (kvm: vmx: Basic APIC virtualization controls have three settings)
  	if (!cpu_need_tpr_shadow(vcpu))
  		return;
  
  	sec_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);
+ 	sec_exec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
+ 			      SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);
  
++<<<<<<< HEAD
 +	if (set) {
 +		sec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
 +		sec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;
 +	} else {
 +		sec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;
 +		sec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
++=======
+ 	switch (kvm_get_apic_mode(vcpu)) {
+ 	case LAPIC_MODE_INVALID:
+ 		WARN_ONCE(true, "Invalid local APIC state");
+ 	case LAPIC_MODE_DISABLED:
+ 		break;
+ 	case LAPIC_MODE_XAPIC:
+ 		if (flexpriority_enabled) {
+ 			sec_exec_control |=
+ 				SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
+ 			vmx_flush_tlb(vcpu, true);
+ 		}
+ 		break;
+ 	case LAPIC_MODE_X2APIC:
+ 		if (cpu_has_vmx_virtualize_x2apic_mode())
+ 			sec_exec_control |=
+ 				SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;
+ 		break;
++>>>>>>> 8d860bbeedef (kvm: vmx: Basic APIC virtualization controls have three settings)
  	}
  	vmcs_write32(SECONDARY_VM_EXEC_CONTROL, sec_exec_control);
  
@@@ -11394,10 -12100,13 +11423,20 @@@ static void nested_vmx_vmexit(struct kv
  	if (kvm_has_tsc_control)
  		decache_tsc_multiplier(vmx);
  
++<<<<<<< HEAD
 +	if (vmx->nested.change_vmcs01_virtual_x2apic_mode) {
 +		vmx->nested.change_vmcs01_virtual_x2apic_mode = false;
 +		vmx_set_virtual_x2apic_mode(vcpu,
 +				vcpu->arch.apic_base & X2APIC_ENABLE);
++=======
+ 	if (vmx->nested.change_vmcs01_virtual_apic_mode) {
+ 		vmx->nested.change_vmcs01_virtual_apic_mode = false;
+ 		vmx_set_virtual_apic_mode(vcpu);
+ 	} else if (!nested_cpu_has_ept(vmcs12) &&
+ 		   nested_cpu_has2(vmcs12,
+ 				   SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {
+ 		vmx_flush_tlb(vcpu, true);
++>>>>>>> 8d860bbeedef (kvm: vmx: Basic APIC virtualization controls have three settings)
  	}
  
  	/* This is needed for same reason as it was needed in prepare_vmcs02 */
* Unmerged path arch/x86/include/asm/kvm_host.h
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 3f0ea5c58164..3f03ecefa308 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -1940,13 +1940,11 @@ void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)
 		recalculate_apic_map(vcpu->kvm);
 	}
 
-	if ((old_value ^ value) & X2APIC_ENABLE) {
-		if (value & X2APIC_ENABLE) {
-			kvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);
-			kvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);
-		} else
-			kvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);
-	}
+	if (((old_value ^ value) & X2APIC_ENABLE) && (value & X2APIC_ENABLE))
+		kvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);
+
+	if ((old_value ^ value) & (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE))
+		kvm_x86_ops->set_virtual_apic_mode(vcpu);
 
 	apic->base_address = apic->vcpu->arch.apic_base &
 			     MSR_IA32_APICBASE_BASE;
diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c
index 2abd6b8af3db..3a721bb2e741 100644
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -4618,7 +4618,7 @@ static void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)
 		set_cr_intercept(svm, INTERCEPT_CR8_WRITE);
 }
 
-static void svm_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)
+static void svm_set_virtual_apic_mode(struct kvm_vcpu *vcpu)
 {
 	return;
 }
@@ -5784,7 +5784,7 @@ static struct kvm_x86_ops svm_x86_ops = {
 	.enable_nmi_window = enable_nmi_window,
 	.enable_irq_window = enable_irq_window,
 	.update_cr8_intercept = update_cr8_intercept,
-	.set_virtual_x2apic_mode = svm_set_virtual_x2apic_mode,
+	.set_virtual_apic_mode = svm_set_virtual_apic_mode,
 	.get_enable_apicv = svm_get_enable_apicv,
 	.refresh_apicv_exec_ctrl = svm_refresh_apicv_exec_ctrl,
 	.load_eoi_exitmap = svm_load_eoi_exitmap,
* Unmerged path arch/x86/kvm/vmx.c
