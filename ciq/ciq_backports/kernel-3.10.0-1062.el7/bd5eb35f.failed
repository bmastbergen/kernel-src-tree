xfrm: take care of request sockets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eric Dumazet <edumazet@google.com>
commit bd5eb35f16a9c55afcf5eb1c920cbbaf09747369
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/bd5eb35f.failed

TCP SYNACK messages might now be attached to request sockets.

XFRM needs to get back to a listener socket.

Adds new helpers that might be used elsewhere :
sk_to_full_sk() and sk_const_to_full_sk()

Note: We also need to add RCU protection for xfrm lookups,
now TCP/DCCP have lockless listener processing. This will
be addressed in separate patches.

Fixes: ca6fb0651883 ("tcp: attach SYNACK messages to request sockets instead of listener")
	Reported-by: Dave Jones <davej@codemonkey.org.uk>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bd5eb35f16a9c55afcf5eb1c920cbbaf09747369)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/inet_sock.h
diff --cc include/net/inet_sock.h
index adb8a8b50c3e,625bdf95d673..000000000000
--- a/include/net/inet_sock.h
+++ b/include/net/inet_sock.h
@@@ -188,6 -200,47 +188,50 @@@ struct inet_sock 
  #define IPCORK_OPT	1	/* ip-options has been held in ipcork.opt */
  #define IPCORK_ALLFRAG	2	/* always fragment (for ipv6 for now) */
  
++<<<<<<< HEAD
++=======
+ /* cmsg flags for inet */
+ #define IP_CMSG_PKTINFO		BIT(0)
+ #define IP_CMSG_TTL		BIT(1)
+ #define IP_CMSG_TOS		BIT(2)
+ #define IP_CMSG_RECVOPTS	BIT(3)
+ #define IP_CMSG_RETOPTS		BIT(4)
+ #define IP_CMSG_PASSSEC		BIT(5)
+ #define IP_CMSG_ORIGDSTADDR	BIT(6)
+ #define IP_CMSG_CHECKSUM	BIT(7)
+ 
+ /**
+  * sk_to_full_sk - Access to a full socket
+  * @sk: pointer to a socket
+  *
+  * SYNACK messages might be attached to request sockets.
+  * Some places want to reach the listener in this case.
+  */
+ static inline struct sock *sk_to_full_sk(struct sock *sk)
+ {
+ #ifdef CONFIG_INET
+ 	if (sk && sk->sk_state == TCP_NEW_SYN_RECV)
+ 		sk = inet_reqsk(sk)->rsk_listener;
+ #endif
+ 	return sk;
+ }
+ 
+ /* sk_to_full_sk() variant with a const argument */
+ static inline const struct sock *sk_const_to_full_sk(const struct sock *sk)
+ {
+ #ifdef CONFIG_INET
+ 	if (sk && sk->sk_state == TCP_NEW_SYN_RECV)
+ 		sk = ((const struct request_sock *)sk)->rsk_listener;
+ #endif
+ 	return sk;
+ }
+ 
+ static inline struct sock *skb_to_full_sk(const struct sk_buff *skb)
+ {
+ 	return sk_to_full_sk(skb->sk);
+ }
+ 
++>>>>>>> bd5eb35f16a9 (xfrm: take care of request sockets)
  static inline struct inet_sock *inet_sk(const struct sock *sk)
  {
  	return (struct inet_sock *)sk;
* Unmerged path include/net/inet_sock.h
diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
index ea07a18efdad..3e7d4e32a4a5 100644
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -2152,6 +2152,7 @@ struct dst_entry *xfrm_lookup(struct net *net, struct dst_entry *dst_orig,
 	xdst = NULL;
 	route = NULL;
 
+	sk = sk_const_to_full_sk(sk);
 	if (sk && sk->sk_policy[XFRM_POLICY_OUT]) {
 		num_pols = 1;
 		pols[0] = xfrm_sk_policy_lookup(sk, XFRM_POLICY_OUT, fl, family);
@@ -2431,6 +2432,7 @@ int __xfrm_policy_check(struct sock *sk, int dir, struct sk_buff *skb,
 	}
 
 	pol = NULL;
+	sk = sk_to_full_sk(sk);
 	if (sk && sk->sk_policy[dir]) {
 		pol = xfrm_sk_policy_lookup(sk, dir, &fl, family);
 		if (IS_ERR(pol)) {
