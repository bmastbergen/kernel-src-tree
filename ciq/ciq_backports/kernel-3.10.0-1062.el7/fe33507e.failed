RDMA/core: Check error status of rdma_find_ndev_for_src_ip_rcu

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Parav Pandit <parav@mellanox.com>
commit fe33507ec38a8b2e8b782b83669943b7a5fefd4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fe33507e.failed

rdma_find_ndev_for_src_ip_rcu() returns either valid netdev pointer or
ERR_PTR().  Instead of checking for NULL, check for error.

Fixes: caf1e3ae9fa6 ("RDMA/core Introduce and use rdma_find_ndev_for_src_ip_rcu")
	Reported-by: syzbot+20c32fa6ff84a2d28c36@syzkaller.appspotmail.com
	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit fe33507ec38a8b2e8b782b83669943b7a5fefd4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/addr.c
diff --cc drivers/infiniband/core/addr.c
index f539cd007a75,07e0ffe74a8a..000000000000
--- a/drivers/infiniband/core/addr.c
+++ b/drivers/infiniband/core/addr.c
@@@ -512,6 -496,56 +512,59 @@@ static int rdma_set_src_addr(const stru
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int rdma_set_src_addr_rcu(struct rdma_dev_addr *dev_addr,
+ 				 unsigned int *ndev_flags,
+ 				 const struct sockaddr *dst_in,
+ 				 const struct dst_entry *dst)
+ {
+ 	struct net_device *ndev = READ_ONCE(dst->dev);
+ 
+ 	*ndev_flags = ndev->flags;
+ 	/* A physical device must be the RDMA device to use */
+ 	if (ndev->flags & IFF_LOOPBACK) {
+ 		/*
+ 		 * RDMA (IB/RoCE, iWarp) doesn't run on lo interface or
+ 		 * loopback IP address. So if route is resolved to loopback
+ 		 * interface, translate that to a real ndev based on non
+ 		 * loopback IP address.
+ 		 */
+ 		ndev = rdma_find_ndev_for_src_ip_rcu(dev_net(ndev), dst_in);
+ 		if (IS_ERR(ndev))
+ 			return -ENODEV;
+ 	}
+ 
+ 	return copy_src_l2_addr(dev_addr, dst_in, dst, ndev);
+ }
+ 
+ static int set_addr_netns_by_gid_rcu(struct rdma_dev_addr *addr)
+ {
+ 	struct net_device *ndev;
+ 
+ 	ndev = rdma_read_gid_attr_ndev_rcu(addr->sgid_attr);
+ 	if (IS_ERR(ndev))
+ 		return PTR_ERR(ndev);
+ 
+ 	/*
+ 	 * Since we are holding the rcu, reading net and ifindex
+ 	 * are safe without any additional reference; because
+ 	 * change_net_namespace() in net/core/dev.c does rcu sync
+ 	 * after it changes the state to IFF_DOWN and before
+ 	 * updating netdev fields {net, ifindex}.
+ 	 */
+ 	addr->net = dev_net(ndev);
+ 	addr->bound_dev_if = ndev->ifindex;
+ 	return 0;
+ }
+ 
+ static void rdma_addr_set_net_defaults(struct rdma_dev_addr *addr)
+ {
+ 	addr->net = &init_net;
+ 	addr->bound_dev_if = 0;
+ }
+ 
++>>>>>>> fe33507ec38a (RDMA/core: Check error status of rdma_find_ndev_for_src_ip_rcu)
  static int addr_resolve(struct sockaddr *src_in,
  			const struct sockaddr *dst_in,
  			struct rdma_dev_addr *addr,
* Unmerged path drivers/infiniband/core/addr.c
