Revert "xhci: Reset Renesas uPD72020x USB controller for 32-bit DMA issue"

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Marc Zyngier <marc.zyngier@arm.com>
commit c2ef60fea2dc7f903450926aee1f9c282ea529ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c2ef60fe.failed

This reverts commit 8466489ef5ba48272ba4fa4ea9f8f403306de4c7.

Now that we can properly reset the uPD72020x without a hard PCI reset,
let's get rid of the existing quirks.

	Tested-by: Domenico Andreoli <domenico.andreoli@linux.com>
	Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
	Tested-by: Faiz Abbas <faiz_abbas@ti.com>
	Tested-by: Domenico Andreoli <domenico.andreoli@linux.com>
	Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit c2ef60fea2dc7f903450926aee1f9c282ea529ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/pci-quirks.h
diff --cc drivers/usb/host/pci-quirks.h
index b68dcb5dd0fd,63c633077d9e..000000000000
--- a/drivers/usb/host/pci-quirks.h
+++ b/drivers/usb/host/pci-quirks.h
@@@ -16,7 -16,7 +16,11 @@@ void usb_asmedia_modifyflowcontrol(stru
  void usb_enable_intel_xhci_ports(struct pci_dev *xhci_pdev);
  void usb_disable_xhci_ports(struct pci_dev *xhci_pdev);
  void sb800_prefetch(struct device *dev, int on);
++<<<<<<< HEAD
 +bool usb_xhci_needs_pci_reset(struct pci_dev *pdev);
++=======
+ bool usb_amd_pt_check_port(struct device *device, int port);
++>>>>>>> c2ef60fea2dc (Revert "xhci: Reset Renesas uPD72020x USB controller for 32-bit DMA issue")
  #else
  struct pci_dev;
  static inline void usb_amd_quirk_pll_disable(void) {}
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 161536717025..c13212c4f133 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -1159,23 +1159,3 @@ static void quirk_usb_early_handoff(struct pci_dev *pdev)
 }
 DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_ANY_ID, PCI_ANY_ID,
 			PCI_CLASS_SERIAL_USB, 8, quirk_usb_early_handoff);
-
-bool usb_xhci_needs_pci_reset(struct pci_dev *pdev)
-{
-	/*
-	 * Our dear uPD72020{1,2} friend only partially resets when
-	 * asked to via the XHCI interface, and may end up doing DMA
-	 * at the wrong addresses, as it keeps the top 32bit of some
-	 * addresses from its previous programming under obscure
-	 * circumstances.
-	 * Give it a good wack at probe time. Unfortunately, this
-	 * needs to happen before we've had a chance to discover any
-	 * quirk, or the system will be in a rather bad state.
-	 */
-	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
-	    (pdev->device == 0x0014 || pdev->device == 0x0015))
-		return true;
-
-	return false;
-}
-EXPORT_SYMBOL_GPL(usb_xhci_needs_pci_reset);
* Unmerged path drivers/usb/host/pci-quirks.h
diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index eee065bef09f..0443c3816e46 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -273,13 +273,6 @@ static int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 
 	driver = (struct hc_driver *)id->driver_data;
 
-	/* For some HW implementation, a XHCI reset is just not enough... */
-	if (usb_xhci_needs_pci_reset(dev)) {
-		dev_info(&dev->dev, "Resetting\n");
-		if (pci_reset_function_locked(dev))
-			dev_warn(&dev->dev, "Reset failed");
-	}
-
 	/* Prevent runtime suspending between USB-2 and USB-3 initialization */
 	pm_runtime_get_noresume(&dev->dev);
 
