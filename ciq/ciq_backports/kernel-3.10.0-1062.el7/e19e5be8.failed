s390/qeth: sanitize strings in debug messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [s390] qeth: sanitize strings in debug messages (Hendrik Brueckner) [1652059]
Rebuild_FUZZ: 94.12%
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit e19e5be8b4cafa8b3f8b0cd1b1dfe20fa0145b83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e19e5be8.failed

As Documentation/s390/s390dbf.txt states quite clearly, using any
pointer in sprinf-formatted s390dbf debug entries is dangerous.
The pointers are dereferenced whenever the trace file is read from.
So if the referenced data has a shorter life-time than the trace file,
any read operation can result in a use-after-free.

So rip out all hazardous use of indirect data, and replace any usage of
dev_name() and such by the Bus ID number.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e19e5be8b4cafa8b3f8b0cd1b1dfe20fa0145b83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
#	drivers/s390/net/qeth_l2_main.c
#	drivers/s390/net/qeth_l3_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index a4e0e50b3a2b,639ac0aca1e9..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -511,18 -554,18 +511,24 @@@ static int __qeth_issue_next_read(struc
  	if (!iob) {
  		dev_warn(&card->gdev->dev, "The qeth device driver "
  			"failed to recover an error on the device\n");
- 		QETH_DBF_MESSAGE(2, "%s issue_next_read failed: no iob "
- 			"available\n", dev_name(&card->gdev->dev));
+ 		QETH_DBF_MESSAGE(2, "issue_next_read on device %x failed: no iob available\n",
+ 				 CARD_DEVID(card));
  		return -ENOMEM;
  	}
 -	qeth_setup_ccw(channel->ccw, CCW_CMD_READ, QETH_BUFSIZE, iob->data);
 +	qeth_setup_ccw(&card->read, iob->data, QETH_BUFSIZE);
  	QETH_CARD_TEXT(card, 6, "noirqpnd");
 -	rc = ccw_device_start(channel->ccwdev, channel->ccw,
 +	rc = ccw_device_start(card->read.ccwdev, &card->read.ccw,
  			      (addr_t) iob, 0, 0);
  	if (rc) {
++<<<<<<< HEAD
 +		QETH_DBF_MESSAGE(2, "%s error in starting next read ccw! "
 +			"rc=%i\n", dev_name(&card->gdev->dev), rc);
 +		atomic_set(&card->read.irq_pending, 0);
++=======
+ 		QETH_DBF_MESSAGE(2, "error %i on device %x when starting next read ccw!\n",
+ 				 rc, CARD_DEVID(card));
+ 		atomic_set(&channel->irq_pending, 0);
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  		card->read_or_write_problem = 1;
  		qeth_schedule_recovery(card);
  		wake_up(&card->wait_q);
@@@ -1894,13 -1888,12 +1898,13 @@@ static int qeth_idx_activate_channel(st
  	if (channel->state != CH_STATE_ACTIVATING) {
  		dev_warn(&channel->ccwdev->dev, "The qeth device driver"
  			" failed to recover an error on the device\n");
- 		QETH_DBF_MESSAGE(2, "%s IDX activate timed out\n",
- 			dev_name(&channel->ccwdev->dev));
+ 		QETH_DBF_MESSAGE(2, "IDX activate timed out on channel %x\n",
+ 				 CCW_DEVID(channel->ccwdev));
  		QETH_DBF_TEXT_(SETUP, 2, "2err%d", -ETIME);
 +		qeth_clear_cmd_buffers(channel);
  		return -ETIME;
  	}
 -	return qeth_idx_activate_get_answer(card, channel, reply_cb);
 +	return qeth_idx_activate_get_answer(channel, idx_reply_cb);
  }
  
  static int qeth_peer_func_level(int level)
@@@ -1932,17 -1924,15 +1936,28 @@@ static void qeth_idx_write_cb(struct qe
  				"The adapter is used exclusively by another "
  				"host\n");
  		else
++<<<<<<< HEAD
 +			QETH_DBF_MESSAGE(2, "%s IDX_ACTIVATE on write channel:"
 +				" negative reply\n",
 +				dev_name(&card->write.ccwdev->dev));
++=======
+ 			QETH_DBF_MESSAGE(2, "IDX_ACTIVATE on channel %x: negative reply\n",
+ 					 CCW_DEVID(channel->ccwdev));
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  		goto out;
  	}
  	memcpy(&temp, QETH_IDX_ACT_FUNC_LEVEL(iob->data), 2);
  	if ((temp & ~0x0100) != qeth_peer_func_level(card->info.func_level)) {
++<<<<<<< HEAD
 +		QETH_DBF_MESSAGE(2, "%s IDX_ACTIVATE on write channel: "
 +			"function level mismatch (sent: 0x%x, received: "
 +			"0x%x)\n", dev_name(&card->write.ccwdev->dev),
 +			card->info.func_level, temp);
++=======
+ 		QETH_DBF_MESSAGE(2, "IDX_ACTIVATE on channel %x: function level mismatch (sent: %#x, received: %#x)\n",
+ 				 CCW_DEVID(channel->ccwdev),
+ 				 card->info.func_level, temp);
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  		goto out;
  	}
  	channel->state = CH_STATE_UP;
@@@ -1980,29 -1969,19 +1995,40 @@@ static void qeth_idx_read_cb(struct qet
  				"insufficient authorization\n");
  			break;
  		default:
++<<<<<<< HEAD
 +			QETH_DBF_MESSAGE(2, "%s IDX_ACTIVATE on read channel:"
 +				" negative reply\n",
 +				dev_name(&card->read.ccwdev->dev));
++=======
+ 			QETH_DBF_MESSAGE(2, "IDX_ACTIVATE on channel %x: negative reply\n",
+ 					 CCW_DEVID(channel->ccwdev));
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  		}
  		QETH_CARD_TEXT_(card, 2, "idxread%c",
  			QETH_IDX_ACT_CAUSE_CODE(iob->data));
  		goto out;
  	}
  
 +/**
 + *  * temporary fix for microcode bug
 + *   * to revert it,replace OR by AND
 + *    */
 +	if ((!QETH_IDX_NO_PORTNAME_REQUIRED(iob->data)) ||
 +	     (card->info.type == QETH_CARD_TYPE_OSD))
 +		card->info.portname_required = 1;
 +
  	memcpy(&temp, QETH_IDX_ACT_FUNC_LEVEL(iob->data), 2);
  	if (temp != qeth_peer_func_level(card->info.func_level)) {
++<<<<<<< HEAD
 +		QETH_DBF_MESSAGE(2, "%s IDX_ACTIVATE on read channel: function "
 +			"level mismatch (sent: 0x%x, received: 0x%x)\n",
 +			dev_name(&card->read.ccwdev->dev),
 +			card->info.func_level, temp);
++=======
+ 		QETH_DBF_MESSAGE(2, "IDX_ACTIVATE on channel %x: function level mismatch (sent: %#x, received: %#x)\n",
+ 				 CCW_DEVID(channel->ccwdev),
+ 				 card->info.func_level, temp);
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  		goto out;
  	}
  	memcpy(&card->token.issuer_rm_r,
@@@ -2080,21 -2085,20 +2106,26 @@@ int qeth_send_control_data(struct qeth_
  	timeout = jiffies + event_timeout;
  
  	QETH_CARD_TEXT(card, 6, "noirqpnd");
 -	spin_lock_irq(get_ccwdev_lock(channel->ccwdev));
 -	rc = ccw_device_start_timeout(channel->ccwdev, channel->ccw,
 -				      (addr_t) iob, 0, 0, event_timeout);
 -	spin_unlock_irq(get_ccwdev_lock(channel->ccwdev));
 +	spin_lock_irqsave(get_ccwdev_lock(card->write.ccwdev), flags);
 +	rc = ccw_device_start(card->write.ccwdev, &card->write.ccw,
 +			      (addr_t) iob, 0, 0);
 +	spin_unlock_irqrestore(get_ccwdev_lock(card->write.ccwdev), flags);
  	if (rc) {
++<<<<<<< HEAD
 +		QETH_DBF_MESSAGE(2, "%s qeth_send_control_data: "
 +			"ccw_device_start rc = %i\n",
 +			dev_name(&card->write.ccwdev->dev), rc);
++=======
+ 		QETH_DBF_MESSAGE(2, "qeth_send_control_data on device %x: ccw_device_start rc = %i\n",
+ 				 CARD_DEVID(card), rc);
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  		QETH_CARD_TEXT_(card, 2, " err%d", rc);
 -		spin_lock_irq(&card->lock);
 +		spin_lock_irqsave(&card->lock, flags);
  		list_del_init(&reply->list);
  		qeth_put_reply(reply);
 -		spin_unlock_irq(&card->lock);
 -		qeth_release_buffer(channel, iob);
 -		atomic_set(&channel->irq_pending, 0);
 +		spin_unlock_irqrestore(&card->lock, flags);
 +		qeth_release_buffer(iob->channel, iob);
 +		atomic_set(&card->write.irq_pending, 0);
  		wake_up(&card->wait_q);
  		return rc;
  	}
@@@ -2884,11 -2839,16 +2915,23 @@@ struct qeth_cmd_buffer *qeth_get_ipacmd
  		enum qeth_ipa_cmds ipacmd, enum qeth_prot_versions prot)
  {
  	struct qeth_cmd_buffer *iob;
 +	struct qeth_ipa_cmd *cmd;
  
++<<<<<<< HEAD
 +	iob = qeth_wait_for_buffer(&card->write);
 +	cmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);
 +	qeth_fill_ipacmd_header(card, cmd, ipacmd, prot);
++=======
+ 	iob = qeth_get_buffer(&card->write);
+ 	if (iob) {
+ 		qeth_fill_ipacmd_header(card, __ipa_cmd(iob), ipacmd, prot);
+ 	} else {
+ 		dev_warn(&card->gdev->dev,
+ 			 "The qeth driver ran out of channel command buffers\n");
+ 		QETH_DBF_MESSAGE(1, "device %x ran out of channel command buffers",
+ 				 CARD_DEVID(card));
+ 	}
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  
  	return iob;
  }
@@@ -3017,13 -2979,12 +3060,12 @@@ static int qeth_query_ipassists_cb(stru
  		QETH_DBF_TEXT(SETUP, 2, "ipaunsup");
  		card->options.ipa4.supported_funcs |= IPA_SETADAPTERPARMS;
  		card->options.ipa6.supported_funcs |= IPA_SETADAPTERPARMS;
 -		return 0;
 +		return -0;
  	default:
  		if (cmd->hdr.return_code) {
- 			QETH_DBF_MESSAGE(1, "%s IPA_CMD_QIPASSIST: Unhandled "
- 						"rc=%d\n",
- 						dev_name(&card->gdev->dev),
- 						cmd->hdr.return_code);
+ 			QETH_DBF_MESSAGE(1, "IPA_CMD_QIPASSIST on device %x: Unhandled rc=%#x\n",
+ 					 CARD_DEVID(card),
+ 					 cmd->hdr.return_code);
  			return 0;
  		}
  	}
diff --cc drivers/s390/net/qeth_l2_main.c
index b9852de25f9b,5b67fd1f2b77..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -131,100 -58,126 +131,132 @@@ static struct net_device *qeth_l2_netde
  	return ndev;
  }
  
 -static int qeth_setdelmac_makerc(struct qeth_card *card, int retcode)
 +static int qeth_l2_send_setgroupmac_cb(struct qeth_card *card,
 +				struct qeth_reply *reply,
 +				unsigned long data)
  {
 -	int rc;
 +	struct qeth_ipa_cmd *cmd;
 +	__u8 *mac;
  
 -	if (retcode)
 -		QETH_CARD_TEXT_(card, 2, "err%04x", retcode);
 -	switch (retcode) {
 -	case IPA_RC_SUCCESS:
 -		rc = 0;
 -		break;
 -	case IPA_RC_L2_UNSUPPORTED_CMD:
 -		rc = -EOPNOTSUPP;
 -		break;
 -	case IPA_RC_L2_ADDR_TABLE_FULL:
 -		rc = -ENOSPC;
 -		break;
 -	case IPA_RC_L2_DUP_MAC:
 -	case IPA_RC_L2_DUP_LAYER3_MAC:
 -		rc = -EEXIST;
 -		break;
 -	case IPA_RC_L2_MAC_NOT_AUTH_BY_HYP:
 -	case IPA_RC_L2_MAC_NOT_AUTH_BY_ADP:
 -		rc = -EPERM;
 -		break;
 -	case IPA_RC_L2_MAC_NOT_FOUND:
 -		rc = -ENOENT;
 -		break;
 -	case -ENOMEM:
 -		rc = -ENOMEM;
 -		break;
 -	default:
 -		rc = -EIO;
 -		break;
 +	QETH_CARD_TEXT(card, 2, "L2Sgmacb");
 +	cmd = (struct qeth_ipa_cmd *) data;
 +	mac = &cmd->data.setdelmac.mac[0];
 +	/* MAC already registered, needed in couple/uncouple case */
 +	if (cmd->hdr.return_code ==  IPA_RC_L2_DUP_MAC) {
 +		QETH_DBF_MESSAGE(2, "Group MAC %pM already existing on %s \n",
 +			  mac, QETH_CARD_IFNAME(card));
 +		cmd->hdr.return_code = 0;
  	}
 -	return rc;
 +	if (cmd->hdr.return_code)
 +		QETH_DBF_MESSAGE(2, "Could not set group MAC %pM on %s: %x\n",
 +			  mac, QETH_CARD_IFNAME(card), cmd->hdr.return_code);
 +	return 0;
  }
  
 -static int qeth_l2_send_setdelmac(struct qeth_card *card, __u8 *mac,
 -			   enum qeth_ipa_cmds ipacmd)
 +static int qeth_l2_send_setgroupmac(struct qeth_card *card, __u8 *mac)
 +{
 +	QETH_CARD_TEXT(card, 2, "L2Sgmac");
 +	return qeth_l2_send_setdelmac(card, mac, IPA_CMD_SETGMAC,
 +					  qeth_l2_send_setgroupmac_cb);
 +}
 +
 +static int qeth_l2_send_delgroupmac_cb(struct qeth_card *card,
 +				struct qeth_reply *reply,
 +				unsigned long data)
  {
  	struct qeth_ipa_cmd *cmd;
 -	struct qeth_cmd_buffer *iob;
 +	__u8 *mac;
  
 -	QETH_CARD_TEXT(card, 2, "L2sdmac");
 -	iob = qeth_get_ipacmd_buffer(card, ipacmd, QETH_PROT_IPV4);
 -	if (!iob)
 -		return -ENOMEM;
 -	cmd = __ipa_cmd(iob);
 -	cmd->data.setdelmac.mac_length = ETH_ALEN;
 -	ether_addr_copy(cmd->data.setdelmac.mac, mac);
 -	return qeth_setdelmac_makerc(card, qeth_send_ipa_cmd(card, iob,
 -					   NULL, NULL));
 +	QETH_CARD_TEXT(card, 2, "L2Dgmacb");
 +	cmd = (struct qeth_ipa_cmd *) data;
 +	mac = &cmd->data.setdelmac.mac[0];
 +	if (cmd->hdr.return_code)
 +		QETH_DBF_MESSAGE(2, "Could not delete group MAC %pM on %s: %x\n",
 +			  mac, QETH_CARD_IFNAME(card), cmd->hdr.return_code);
 +	return 0;
  }
  
 -static int qeth_l2_send_setmac(struct qeth_card *card, __u8 *mac)
 +static int qeth_l2_send_delgroupmac(struct qeth_card *card, __u8 *mac)
  {
 -	int rc;
 -
 -	QETH_CARD_TEXT(card, 2, "L2Setmac");
 -	rc = qeth_l2_send_setdelmac(card, mac, IPA_CMD_SETVMAC);
 -	if (rc == 0) {
 -		dev_info(&card->gdev->dev,
 -			 "MAC address %pM successfully registered on device %s\n",
 -			 mac, card->dev->name);
 -	} else {
 -		switch (rc) {
 -		case -EEXIST:
 -			dev_warn(&card->gdev->dev,
 -				"MAC address %pM already exists\n", mac);
 -			break;
 -		case -EPERM:
 -			dev_warn(&card->gdev->dev,
 -				"MAC address %pM is not authorized\n", mac);
 -			break;
 -		}
 -	}
 -	return rc;
 +	QETH_CARD_TEXT(card, 2, "L2Dgmac");
 +	return qeth_l2_send_setdelmac(card, mac, IPA_CMD_DELGMAC,
 +					  qeth_l2_send_delgroupmac_cb);
  }
  
 -static int qeth_l2_write_mac(struct qeth_card *card, u8 *mac)
 +static void qeth_l2_add_mc(struct qeth_card *card, __u8 *mac, int vmac)
  {
 -	enum qeth_ipa_cmds cmd = is_multicast_ether_addr(mac) ?
 -					IPA_CMD_SETGMAC : IPA_CMD_SETVMAC;
 +	struct qeth_mc_mac *mc;
  	int rc;
  
++<<<<<<< HEAD
 +	mc = kmalloc(sizeof(struct qeth_mc_mac), GFP_ATOMIC);
 +
 +	if (!mc)
 +		return;
 +
 +	memcpy(mc->mc_addr, mac, OSA_ADDR_LEN);
 +	mc->mc_addrlen = OSA_ADDR_LEN;
 +	mc->is_vmac = vmac;
 +
 +	if (vmac) {
 +		rc = qeth_l2_send_setdelmac(card, mac, IPA_CMD_SETVMAC,
 +					NULL);
 +	} else {
 +		rc = qeth_l2_send_setgroupmac(card, mac);
 +	}
 +
 +	if (!rc)
 +		list_add_tail(&mc->list, &card->mc_list);
 +	else
 +		kfree(mc);
++=======
+ 	QETH_CARD_TEXT(card, 2, "L2Wmac");
+ 	rc = qeth_l2_send_setdelmac(card, mac, cmd);
+ 	if (rc == -EEXIST)
+ 		QETH_DBF_MESSAGE(2, "MAC already registered on device %x\n",
+ 				 CARD_DEVID(card));
+ 	else if (rc)
+ 		QETH_DBF_MESSAGE(2, "Failed to register MAC on device %x: %d\n",
+ 				 CARD_DEVID(card), rc);
+ 	return rc;
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  }
  
 -static int qeth_l2_remove_mac(struct qeth_card *card, u8 *mac)
 +static void qeth_l2_del_all_mc(struct qeth_card *card, int del)
  {
++<<<<<<< HEAD
 +	struct qeth_mc_mac *mc, *tmp;
++=======
+ 	enum qeth_ipa_cmds cmd = is_multicast_ether_addr(mac) ?
+ 					IPA_CMD_DELGMAC : IPA_CMD_DELVMAC;
+ 	int rc;
+ 
+ 	QETH_CARD_TEXT(card, 2, "L2Rmac");
+ 	rc = qeth_l2_send_setdelmac(card, mac, cmd);
+ 	if (rc)
+ 		QETH_DBF_MESSAGE(2, "Failed to delete MAC on device %u: %d\n",
+ 				 CARD_DEVID(card), rc);
+ 	return rc;
+ }
+ 
+ static void qeth_l2_del_all_macs(struct qeth_card *card)
+ {
+ 	struct qeth_mac *mac;
+ 	struct hlist_node *tmp;
+ 	int i;
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  
  	spin_lock_bh(&card->mclock);
 -	hash_for_each_safe(card->mac_htable, i, tmp, mac, hnode) {
 -		hash_del(&mac->hnode);
 -		kfree(mac);
 +	list_for_each_entry_safe(mc, tmp, &card->mc_list, list) {
 +		if (del) {
 +			if (mc->is_vmac)
 +				qeth_l2_send_setdelmac(card, mc->mc_addr,
 +					IPA_CMD_DELVMAC, NULL);
 +			else
 +				qeth_l2_send_delgroupmac(card, mc->mc_addr);
 +		}
 +		list_del(&mc->list);
 +		kfree(mc);
  	}
  	spin_unlock_bh(&card->mclock);
  }
@@@ -284,17 -229,40 +316,23 @@@ static void qeth_l2_fill_header(struct 
  	}
  }
  
 -static int qeth_setdelvlan_makerc(struct qeth_card *card, int retcode)
 -{
 -	if (retcode)
 -		QETH_CARD_TEXT_(card, 2, "err%04x", retcode);
 -
 -	switch (retcode) {
 -	case IPA_RC_SUCCESS:
 -		return 0;
 -	case IPA_RC_L2_INVALID_VLAN_ID:
 -		return -EINVAL;
 -	case IPA_RC_L2_DUP_VLAN_ID:
 -		return -EEXIST;
 -	case IPA_RC_L2_VLAN_ID_NOT_FOUND:
 -		return -ENOENT;
 -	case IPA_RC_L2_VLAN_ID_NOT_ALLOWED:
 -		return -EPERM;
 -	case -ENOMEM:
 -		return -ENOMEM;
 -	default:
 -		return -EIO;
 -	}
 -}
 -
  static int qeth_l2_send_setdelvlan_cb(struct qeth_card *card,
 -				      struct qeth_reply *reply,
 -				      unsigned long data)
 +			struct qeth_reply *reply, unsigned long data)
  {
 -	struct qeth_ipa_cmd *cmd = (struct qeth_ipa_cmd *) data;
 +	struct qeth_ipa_cmd *cmd;
  
  	QETH_CARD_TEXT(card, 2, "L2sdvcb");
 +	cmd = (struct qeth_ipa_cmd *) data;
  	if (cmd->hdr.return_code) {
++<<<<<<< HEAD
 +		QETH_DBF_MESSAGE(2, "Error in processing VLAN %i on %s: 0x%x. "
 +			  "Continuing\n", cmd->data.setdelvlan.vlan_id,
 +			  QETH_CARD_IFNAME(card), cmd->hdr.return_code);
++=======
+ 		QETH_DBF_MESSAGE(2, "Error in processing VLAN %u on device %x: %#x.\n",
+ 				 cmd->data.setdelvlan.vlan_id,
+ 				 CARD_DEVID(card), cmd->hdr.return_code);
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  		QETH_CARD_TEXT_(card, 2, "L2VL%4x", cmd->hdr.command);
  		QETH_CARD_TEXT_(card, 2, "err%d", cmd->hdr.return_code);
  	}
@@@ -716,16 -466,20 +754,25 @@@ static int qeth_l2_request_initial_mac(
  	    card->info.type == QETH_CARD_TYPE_OSX ||
  	    card->info.guestlan) {
  		rc = qeth_setadpparms_change_macaddr(card);
++<<<<<<< HEAD
 +		if (rc) {
 +			QETH_DBF_MESSAGE(2, "couldn't get MAC address on "
 +				"device %s: x%x\n", CARD_BUS_ID(card), rc);
 +			QETH_DBF_TEXT_(SETUP, 2, "1err%d", rc);
 +			return rc;
 +		}
 +	} else {
 +		eth_random_addr(card->dev->dev_addr);
 +		memcpy(card->dev->dev_addr, vendor_pre, 3);
++=======
+ 		if (!rc)
+ 			goto out;
+ 		QETH_DBF_MESSAGE(2, "READ_MAC Assist failed on device %x: %#x\n",
+ 				 CARD_DEVID(card), rc);
+ 		QETH_DBF_TEXT_(SETUP, 2, "1err%04x", rc);
+ 		/* fall back once more: */
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  	}
 -
 -	/* some devices don't support a custom MAC address: */
 -	if (card->info.type == QETH_CARD_TYPE_OSM ||
 -	    card->info.type == QETH_CARD_TYPE_OSX)
 -		return (rc) ? rc : -EADDRNOTAVAIL;
 -	eth_hw_addr_random(card->dev);
 -
  out:
  	QETH_DBF_HEX(SETUP, 2, card->dev->dev_addr, card->dev->addr_len);
  	return 0;
diff --cc drivers/s390/net/qeth_l3_main.c
index faa467771068,ffa2aa1dd4c5..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -695,11 -517,9 +694,10 @@@ int qeth_l3_setrouting_v6(struct qeth_c
  				  QETH_PROT_IPV6);
  	if (rc) {
  		card->options.route6.type = NO_ROUTER;
- 		QETH_DBF_MESSAGE(2, "Error (0x%04x) while setting routing type"
- 			" on %s. Type set to 'no router'.\n", rc,
- 			QETH_CARD_IFNAME(card));
+ 		QETH_DBF_MESSAGE(2, "Error (%#06x) while setting routing type on device %x. Type set to 'no router'.\n",
+ 				 rc, CARD_DEVID(card));
  	}
 +#endif
  	return rc;
  }
  
@@@ -2433,15 -1801,13 +2413,23 @@@ static int qeth_l3_arp_add_entry(struc
  	rc = qeth_send_setassparms(card, iob,
  				   sizeof(struct qeth_arp_cache_entry),
  				   (unsigned long) entry,
++<<<<<<< HEAD
 +				   qeth_l3_default_setassparms_cb, NULL);
 +	if (rc) {
 +		tmp = rc;
 +		qeth_l3_ipaddr4_to_string((u8 *)entry->ipaddr, buf);
 +		QETH_DBF_MESSAGE(2, "Could not add ARP entry for address %s "
 +			"on %s: %s (0x%x/%d)\n", buf, QETH_CARD_IFNAME(card),
 +			qeth_l3_arp_get_error_cause(&rc), tmp, tmp);
 +	}
 +	return rc;
++=======
+ 				   qeth_setassparms_cb, NULL);
+ 	if (rc)
+ 		QETH_DBF_MESSAGE(2, "Could not add ARP entry on device %x: %#x\n",
+ 				 CARD_DEVID(card), rc);
+ 	return qeth_l3_arp_makerc(rc);
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  }
  
  static int qeth_l3_arp_remove_entry(struct qeth_card *card,
@@@ -2469,18 -1834,15 +2456,26 @@@
  				       IPA_CMD_ASS_ARP_REMOVE_ENTRY,
  				       12,
  				       QETH_PROT_IPV4);
 -	if (!iob)
 -		return -ENOMEM;
  	rc = qeth_send_setassparms(card, iob,
  				   12, (unsigned long)buf,
++<<<<<<< HEAD
 +				   qeth_l3_default_setassparms_cb, NULL);
 +	if (rc) {
 +		tmp = rc;
 +		memset(buf, 0, 16);
 +		qeth_l3_ipaddr4_to_string((u8 *)entry->ipaddr, buf);
 +		QETH_DBF_MESSAGE(2, "Could not delete ARP entry for address %s"
 +			" on %s: %s (0x%x/%d)\n", buf, QETH_CARD_IFNAME(card),
 +			qeth_l3_arp_get_error_cause(&rc), tmp, tmp);
 +	}
 +	return rc;
++=======
+ 				   qeth_setassparms_cb, NULL);
+ 	if (rc)
+ 		QETH_DBF_MESSAGE(2, "Could not delete ARP entry on device %x: %#x\n",
+ 				 CARD_DEVID(card), rc);
+ 	return qeth_l3_arp_makerc(rc);
++>>>>>>> e19e5be8b4ca (s390/qeth: sanitize strings in debug messages)
  }
  
  static int qeth_l3_arp_flush_cache(struct qeth_card *card)
diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h
index d4437aa7c289..df6dc1f24242 100644
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -82,6 +82,18 @@ struct qeth_dbf_info {
 #define SENSE_RESETTING_EVENT_BYTE 1
 #define SENSE_RESETTING_EVENT_FLAG 0x80
 
+static inline u32 qeth_get_device_id(struct ccw_device *cdev)
+{
+	struct ccw_dev_id dev_id;
+	u32 id;
+
+	ccw_device_get_id(cdev, &dev_id);
+	id = dev_id.devno;
+	id |= (u32) (dev_id.ssid << 16);
+
+	return id;
+}
+
 /*
  * Common IO related definitions
  */
@@ -92,7 +104,8 @@ struct qeth_dbf_info {
 #define CARD_RDEV_ID(card) dev_name(&card->read.ccwdev->dev)
 #define CARD_WDEV_ID(card) dev_name(&card->write.ccwdev->dev)
 #define CARD_DDEV_ID(card) dev_name(&card->data.ccwdev->dev)
-#define CHANNEL_ID(channel) dev_name(&channel->ccwdev->dev)
+#define CCW_DEVID(cdev)		(qeth_get_device_id(cdev))
+#define CARD_DEVID(card)	(CCW_DEVID(CARD_RDEV(card)))
 
 /**
  * card stuff
* Unmerged path drivers/s390/net/qeth_core_main.c
* Unmerged path drivers/s390/net/qeth_l2_main.c
* Unmerged path drivers/s390/net/qeth_l3_main.c
