efi: Generalize handle_ramdisks() and rename to handle_cmdline_files().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] efi: Generalize handle_ramdisks() and rename to handle_cmdline_files() (Lenny Szubowicz) [1608955]
Rebuild_FUZZ: 99.29%
commit-author Roy Franz <roy.franz@linaro.org>
commit 46f4582e7cbc5f30127183812d4da875782518f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/46f4582e.failed

The handle_cmdline_files now takes the option to handle as a string,
and returns the loaded data through parameters, rather than taking
an x86 specific setup_header structure.  For ARM, this will be used
to load a device tree blob in addition to initrd images.

	Signed-off-by: Roy Franz <roy.franz@linaro.org>
	Acked-by: Mark Salter <msalter@redhat.com>
	Reviewed-by: Grant Likely <grant.likely@linaro.org>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 46f4582e7cbc5f30127183812d4da875782518f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/efi-stub-helper.c
diff --cc drivers/firmware/efi/efi-stub-helper.c
index 3fe91c7ac446,8c7839437c14..000000000000
--- a/drivers/firmware/efi/efi-stub-helper.c
+++ b/drivers/firmware/efi/efi-stub-helper.c
@@@ -285,21 -321,27 +294,25 @@@ static efi_status_t handle_cmdline_file
  	if (!nr_initrds)
  		return EFI_SUCCESS;
  
 -	status = efi_call_phys3(sys_table_arg->boottime->allocate_pool,
 -				EFI_LOADER_DATA,
 +	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,
  				nr_initrds * sizeof(*initrds),
 -				&initrds);
 +				(void **)&initrds);
  	if (status != EFI_SUCCESS) {
++<<<<<<< HEAD
 +		pr_efi_err(sys_table_arg, "Failed to alloc mem for initrds\n");
++=======
+ 		efi_printk(sys_table_arg, "Failed to alloc mem for file load\n");
++>>>>>>> 46f4582e7cbc (efi: Generalize handle_ramdisks() and rename to handle_cmdline_files().)
  		goto fail;
  	}
  
- 	str = (char *)(unsigned long)hdr->cmd_line_ptr;
+ 	str = cmd_line;
  	for (i = 0; i < nr_initrds; i++) {
  		struct initrd *initrd;
 -		efi_file_handle_t *h;
 -		efi_file_info_t *info;
  		efi_char16_t filename_16[256];
 -		unsigned long info_sz;
 -		efi_guid_t info_guid = EFI_FILE_INFO_ID;
  		efi_char16_t *p;
 -		u64 file_sz;
  
- 		str = strstr(str, "initrd=");
+ 		str = strstr(str, option_string);
  		if (!str)
  			break;
  
@@@ -328,18 -370,69 +341,66 @@@
  
  		/* Only open the volume once. */
  		if (!i) {
 -			efi_boot_services_t *boottime;
 -
 -			boottime = sys_table_arg->boottime;
 -
 -			status = efi_call_phys3(boottime->handle_protocol,
 -					image->device_handle, &fs_proto, &io);
 -			if (status != EFI_SUCCESS) {
 -				efi_printk(sys_table_arg, "Failed to handle fs_proto\n");
 +			status = efi_open_volume(sys_table_arg, image,
 +						 (void **)&fh);
 +			if (status != EFI_SUCCESS)
  				goto free_initrds;
 -			}
 -
 -			status = efi_call_phys2(io->open_volume, io, &fh);
 -			if (status != EFI_SUCCESS) {
 -				efi_printk(sys_table_arg, "Failed to open volume\n");
 -				goto free_initrds;
 -			}
  		}
  
++<<<<<<< HEAD
 +		status = efi_file_size(sys_table_arg, fh, filename_16,
 +				       (void **)&initrd->handle, &initrd->size);
 +		if (status != EFI_SUCCESS)
++=======
+ 		status = efi_call_phys5(fh->open, fh, &h, filename_16,
+ 					EFI_FILE_MODE_READ, (u64)0);
+ 		if (status != EFI_SUCCESS) {
+ 			efi_printk(sys_table_arg, "Failed to open file: ");
+ 			efi_char16_printk(sys_table_arg, filename_16);
+ 			efi_printk(sys_table_arg, "\n");
++>>>>>>> 46f4582e7cbc (efi: Generalize handle_ramdisks() and rename to handle_cmdline_files().)
  			goto close_handles;
 -		}
  
++<<<<<<< HEAD
 +		initrd_total += initrd->size;
++=======
+ 		initrd->handle = h;
+ 
+ 		info_sz = 0;
+ 		status = efi_call_phys4(h->get_info, h, &info_guid,
+ 					&info_sz, NULL);
+ 		if (status != EFI_BUFFER_TOO_SMALL) {
+ 			efi_printk(sys_table_arg, "Failed to get file info size\n");
+ 			goto close_handles;
+ 		}
+ 
+ grow:
+ 		status = efi_call_phys3(sys_table_arg->boottime->allocate_pool,
+ 					EFI_LOADER_DATA, info_sz, &info);
+ 		if (status != EFI_SUCCESS) {
+ 			efi_printk(sys_table_arg, "Failed to alloc mem for file info\n");
+ 			goto close_handles;
+ 		}
+ 
+ 		status = efi_call_phys4(h->get_info, h, &info_guid,
+ 					&info_sz, info);
+ 		if (status == EFI_BUFFER_TOO_SMALL) {
+ 			efi_call_phys1(sys_table_arg->boottime->free_pool,
+ 				       info);
+ 			goto grow;
+ 		}
+ 
+ 		file_sz = info->file_size;
+ 		efi_call_phys1(sys_table_arg->boottime->free_pool, info);
+ 
+ 		if (status != EFI_SUCCESS) {
+ 			efi_printk(sys_table_arg, "Failed to get file info\n");
+ 			goto close_handles;
+ 		}
+ 
+ 		initrd->size = file_sz;
+ 		initrd_total += file_sz;
++>>>>>>> 46f4582e7cbc (efi: Generalize handle_ramdisks() and rename to handle_cmdline_files().)
  	}
  
  	if (initrd_total) {
@@@ -351,15 -444,15 +412,20 @@@
  		 * all the initrd's.
  		 */
  		status = efi_high_alloc(sys_table_arg, initrd_total, 0x1000,
- 				    &initrd_addr, hdr->initrd_addr_max);
+ 				    &initrd_addr, max_addr);
  		if (status != EFI_SUCCESS) {
 -			efi_printk(sys_table_arg, "Failed to alloc highmem for initrds\n");
 +			pr_efi_err(sys_table_arg, "Failed to alloc highmem for initrds\n");
  			goto close_handles;
  		}
  
  		/* We've run out of free low memory. */
++<<<<<<< HEAD
 +		if (initrd_addr > hdr->initrd_addr_max) {
 +			pr_efi_err(sys_table_arg, "We've run out of free low memory\n");
++=======
+ 		if (initrd_addr > max_addr) {
+ 			efi_printk(sys_table_arg, "We've run out of free low memory\n");
++>>>>>>> 46f4582e7cbc (efi: Generalize handle_ramdisks() and rename to handle_cmdline_files().)
  			status = EFI_INVALID_PARAMETER;
  			goto free_initrd_total;
  		}
@@@ -375,12 -468,11 +441,16 @@@
  					chunksize = EFI_READ_CHUNK_SIZE;
  				else
  					chunksize = size;
 -				status = efi_call_phys3(fh->read,
 -							initrds[j].handle,
 -							&chunksize, addr);
 +
 +				status = efi_file_read(initrds[j].handle,
 +						       &chunksize,
 +						       (void *)addr);
  				if (status != EFI_SUCCESS) {
++<<<<<<< HEAD
 +					pr_efi_err(sys_table_arg, "Failed to read initrd\n");
++=======
+ 					efi_printk(sys_table_arg, "Failed to read file\n");
++>>>>>>> 46f4582e7cbc (efi: Generalize handle_ramdisks() and rename to handle_cmdline_files().)
  					goto free_initrd_total;
  				}
  				addr += chunksize;
@@@ -392,10 -484,10 +462,10 @@@
  
  	}
  
 -	efi_call_phys1(sys_table_arg->boottime->free_pool, initrds);
 +	efi_call_early(free_pool, initrds);
  
- 	hdr->ramdisk_image = initrd_addr;
- 	hdr->ramdisk_size = initrd_total;
+ 	*load_addr = initrd_addr;
+ 	*load_size = initrd_total;
  
  	return status;
  
@@@ -404,12 -496,12 +474,12 @@@ free_initrd_total
  
  close_handles:
  	for (k = j; k < i; k++)
 -		efi_call_phys1(fh->close, initrds[k].handle);
 +		efi_file_close(initrds[k].handle);
  free_initrds:
 -	efi_call_phys1(sys_table_arg->boottime->free_pool, initrds);
 +	efi_call_early(free_pool, initrds);
  fail:
- 	hdr->ramdisk_image = 0;
- 	hdr->ramdisk_size = 0;
+ 	*load_addr = 0;
+ 	*load_size = 0;
  
  	return status;
  }
diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c
index 79174181d150..98ca35f059c8 100644
--- a/arch/x86/boot/compressed/eboot.c
+++ b/arch/x86/boot/compressed/eboot.c
@@ -1106,6 +1106,8 @@ struct boot_params *make_boot_params(struct efi_config *c)
 	u16 *s2;
 	u8 *s1;
 	int i;
+	unsigned long ramdisk_addr;
+	unsigned long ramdisk_size;
 
 	efi_early = c;
 	sys_table = (efi_system_table_t *)(unsigned long)efi_early->table;
@@ -1169,9 +1171,14 @@ struct boot_params *make_boot_params(struct efi_config *c)
 
 	memset(sdt, 0, sizeof(*sdt));
 
-	status = handle_ramdisks(sys_table, image, hdr);
+	status = handle_cmdline_files(sys_table, image,
+				      (char *)(unsigned long)hdr->cmd_line_ptr,
+				      "initrd=", hdr->initrd_addr_max,
+				      &ramdisk_addr, &ramdisk_size);
 	if (status != EFI_SUCCESS)
 		goto fail2;
+	hdr->ramdisk_image = ramdisk_addr;
+	hdr->ramdisk_size = ramdisk_size;
 
 	return boot_params;
 fail2:
* Unmerged path drivers/firmware/efi/efi-stub-helper.c
