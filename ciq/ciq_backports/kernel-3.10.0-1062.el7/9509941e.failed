fuse: call pipe_buf_release() under pipe lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jann Horn <jannh@google.com>
commit 9509941e9c534920ccc4771ae70bd6cbbe79df1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9509941e.failed

Some of the pipe_buf_release() handlers seem to assume that the pipe is
locked - in particular, anon_pipe_buf_release() accesses pipe->tmp_page
without taking any extra locks. From a glance through the callers of
pipe_buf_release(), it looks like FUSE is the only one that calls
pipe_buf_release() without having the pipe locked.

This bug should only lead to a memory leak, nothing terrible.

Fixes: dd3bb14f44a6 ("fuse: support splice() writing to fuse device")
	Cc: stable@vger.kernel.org
	Signed-off-by: Jann Horn <jannh@google.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 9509941e9c534920ccc4771ae70bd6cbbe79df1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dev.c
diff --cc fs/fuse/dev.c
index 711baa95ec29,809c0f2f9942..000000000000
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@@ -1975,14 -2075,15 +1975,23 @@@ static ssize_t fuse_dev_splice_write(st
  	if (flags & SPLICE_F_MOVE)
  		cs.move_pages = 1;
  
++<<<<<<< HEAD
 +	ret = fuse_dev_do_write(fc, &cs, len);
++=======
+ 	ret = fuse_dev_do_write(fud, &cs, len);
+ 
+ 	pipe_lock(pipe);
+ 	for (idx = 0; idx < nbuf; idx++)
+ 		pipe_buf_release(pipe, &bufs[idx]);
+ 	pipe_unlock(pipe);
++>>>>>>> 9509941e9c53 (fuse: call pipe_buf_release() under pipe lock)
  
 +	for (idx = 0; idx < nbuf; idx++) {
 +		struct pipe_buffer *buf = &bufs[idx];
 +		buf->ops->release(pipe, buf);
 +	}
  out:
 -	kvfree(bufs);
 +	kfree(bufs);
  	return ret;
  }
  
* Unmerged path fs/fuse/dev.c
