uio_hv_generic: use correct channel in isr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit 135db384a2efde3718fd551e3968e97fcb400c84
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/135db384.failed

Need to mask the correct sub-channel in the callback from VMBUS
isr.  Otherwise, can get in to infinite interrupt storm.

Fixes: 37b96a4931db ("uio_hv_generic: support sub-channels")
	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 135db384a2efde3718fd551e3968e97fcb400c84)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/uio/uio_hv_generic.c
diff --cc drivers/uio/uio_hv_generic.c
index d608865b1e1e,a9d7be4b964f..000000000000
--- a/drivers/uio/uio_hv_generic.c
+++ b/drivers/uio/uio_hv_generic.c
@@@ -82,15 -94,133 +82,141 @@@ hv_uio_irqcontrol(struct uio_info *info
   */
  static void hv_uio_channel_cb(void *context)
  {
- 	struct hv_uio_private_data *pdata = context;
- 	struct hv_device *dev = pdata->device;
+ 	struct vmbus_channel *chan = context;
+ 	struct hv_device *hv_dev = chan->device_obj;
+ 	struct hv_uio_private_data *pdata = hv_get_drvdata(hv_dev);
  
++<<<<<<< HEAD
 +	dev->channel->inbound.ring_buffer->interrupt_mask = 1;
 +	mb();
++=======
+ 	chan->inbound.ring_buffer->interrupt_mask = 1;
+ 	virt_mb();
++>>>>>>> 135db384a2ef (uio_hv_generic: use correct channel in isr)
+ 
+ 	uio_event_notify(&pdata->info);
+ }
+ 
++<<<<<<< HEAD
++=======
+ /*
+  * Callback from vmbus_event when channel is rescinded.
+  */
+ static void hv_uio_rescind(struct vmbus_channel *channel)
+ {
+ 	struct hv_device *hv_dev = channel->primary_channel->device_obj;
+ 	struct hv_uio_private_data *pdata = hv_get_drvdata(hv_dev);
  
+ 	/*
+ 	 * Turn off the interrupt file handle
+ 	 * Next read for event will return -EIO
+ 	 */
+ 	pdata->info.irq = 0;
+ 
+ 	/* Wake up reader */
  	uio_event_notify(&pdata->info);
  }
  
+ /*
+  * Handle fault when looking for sub channel ring buffer
+  * Subchannel ring buffer is same as resource 0 which is main ring buffer
+  * This is derived from uio_vma_fault
+  */
+ static int hv_uio_vma_fault(struct vm_fault *vmf)
+ {
+ 	struct vm_area_struct *vma = vmf->vma;
+ 	void *ring_buffer = vma->vm_private_data;
+ 	struct page *page;
+ 	void *addr;
+ 
+ 	addr = ring_buffer + (vmf->pgoff << PAGE_SHIFT);
+ 	page = virt_to_page(addr);
+ 	get_page(page);
+ 	vmf->page = page;
+ 	return 0;
+ }
+ 
+ static const struct vm_operations_struct hv_uio_vm_ops = {
+ 	.fault = hv_uio_vma_fault,
+ };
+ 
+ /* Sysfs API to allow mmap of the ring buffers */
+ static int hv_uio_ring_mmap(struct file *filp, struct kobject *kobj,
+ 			    struct bin_attribute *attr,
+ 			    struct vm_area_struct *vma)
+ {
+ 	struct vmbus_channel *channel
+ 		= container_of(kobj, struct vmbus_channel, kobj);
+ 	unsigned long requested_pages, actual_pages;
+ 
+ 	if (vma->vm_end < vma->vm_start)
+ 		return -EINVAL;
+ 
+ 	/* only allow 0 for now */
+ 	if (vma->vm_pgoff > 0)
+ 		return -EINVAL;
+ 
+ 	requested_pages = vma_pages(vma);
+ 	actual_pages = 2 * HV_RING_SIZE;
+ 	if (requested_pages > actual_pages)
+ 		return -EINVAL;
+ 
+ 	vma->vm_private_data = channel->ringbuffer_pages;
+ 	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
+ 	vma->vm_ops = &hv_uio_vm_ops;
+ 	return 0;
+ }
+ 
+ static const struct bin_attribute ring_buffer_bin_attr = {
+ 	.attr = {
+ 		.name = "ring",
+ 		.mode = 0600,
+ 	},
+ 	.size = 2 * HV_RING_SIZE * PAGE_SIZE,
+ 	.mmap = hv_uio_ring_mmap,
+ };
+ 
+ /* Callback from VMBUS subsystem when new channel created. */
+ static void
+ hv_uio_new_channel(struct vmbus_channel *new_sc)
+ {
+ 	struct hv_device *hv_dev = new_sc->primary_channel->device_obj;
+ 	struct device *device = &hv_dev->device;
+ 	const size_t ring_bytes = HV_RING_SIZE * PAGE_SIZE;
+ 	int ret;
+ 
+ 	/* Create host communication ring */
+ 	ret = vmbus_open(new_sc, ring_bytes, ring_bytes, NULL, 0,
+ 			 hv_uio_channel_cb, new_sc);
+ 	if (ret) {
+ 		dev_err(device, "vmbus_open subchannel failed: %d\n", ret);
+ 		return;
+ 	}
+ 
+ 	/* Disable interrupts on sub channel */
+ 	new_sc->inbound.ring_buffer->interrupt_mask = 1;
+ 	set_channel_read_mode(new_sc, HV_CALL_ISR);
+ 
+ 	ret = sysfs_create_bin_file(&new_sc->kobj, &ring_buffer_bin_attr);
+ 	if (ret) {
+ 		dev_err(device, "sysfs create ring bin file failed; %d\n", ret);
+ 		vmbus_close(new_sc);
+ 	}
+ }
+ 
+ static void
+ hv_uio_cleanup(struct hv_device *dev, struct hv_uio_private_data *pdata)
+ {
+ 	if (pdata->send_gpadl)
+ 		vmbus_teardown_gpadl(dev->channel, pdata->send_gpadl);
+ 	vfree(pdata->send_buf);
+ 
+ 	if (pdata->recv_gpadl)
+ 		vmbus_teardown_gpadl(dev->channel, pdata->recv_gpadl);
+ 	vfree(pdata->recv_buf);
+ }
+ 
++>>>>>>> 135db384a2ef (uio_hv_generic: use correct channel in isr)
  static int
  hv_uio_probe(struct hv_device *dev,
  	     const struct hv_vmbus_device_id *dev_id)
* Unmerged path drivers/uio/uio_hv_generic.c
