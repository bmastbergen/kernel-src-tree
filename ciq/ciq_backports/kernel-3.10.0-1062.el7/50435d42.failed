scsi: qla2xxx: Modify fall-through annotations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Modify fall-through annotations (Himanshu Madhani) [1628301]
Rebuild_FUZZ: 93.02%
commit-author Bart Van Assche <bvanassche@acm.org>
commit 50435d4211a784e1577b4af72b07276c3851d324
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/50435d42.failed

This patch avoids that the compiler complains about missing fall-through
annotations when building with W=1.

	Cc: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Bart Van Assche <bvanassche@acm.org>
	Acked-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 50435d4211a784e1577b4af72b07276c3851d324)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_target.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index bba78b867404,2ccf9f190c68..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -579,37 -628,73 +579,80 @@@ static void qla24xx_handle_gnl_done_eve
  			fcport->login_pause = 1;
  		}
  
 -		switch (vha->hw->current_topology) {
 -		default:
 -			switch (current_login_state) {
 -			case DSC_LS_PRLI_COMP:
 -				ql_dbg(ql_dbg_disc + ql_dbg_verbose,
 -				    vha, 0x20e4, "%s %d %8phC post gpdb\n",
 -				    __func__, __LINE__, fcport->port_name);
 +		if  (fcport->fc4f_nvme)
 +			current_login_state = e->current_login_state >> 4;
 +		else
 +			current_login_state = e->current_login_state & 0xf;
  
 -				if ((e->prli_svc_param_word_3[0] & BIT_4) == 0)
 -					fcport->port_type = FCT_INITIATOR;
 -				else
 -					fcport->port_type = FCT_TARGET;
 -				data[0] = data[1] = 0;
 -				qla2x00_post_async_adisc_work(vha, fcport,
 -				    data);
 -				break;
 -			case DSC_LS_PORT_UNAVAIL:
 -			default:
 -				if (fcport->loop_id != FC_NO_LOOP_ID)
 -					qla2x00_clear_loop_id(fcport);
 +		switch (current_login_state) {
 +		case DSC_LS_PRLI_COMP:
 +			ql_dbg(ql_dbg_disc, vha, 0x20e4,
 +			    "%s %d %8phC post gpdb\n",
 +			    __func__, __LINE__, fcport->port_name);
 +
 +			if ((e->prli_svc_param_word_3[0] & BIT_4) == 0)
 +				fcport->port_type = FCT_INITIATOR;
 +			else
 +				fcport->port_type = FCT_TARGET;
  
 -				fcport->loop_id = loop_id;
 +			data[0] = data[1] = 0;
 +			qla2x00_post_async_adisc_work(vha, fcport, data);
 +			break;
 +		case DSC_LS_PORT_UNAVAIL:
 +		default:
 +			if (fcport->loop_id == FC_NO_LOOP_ID) {
 +				qla2x00_find_new_loop_id(vha, fcport);
  				fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;
 -				qla24xx_fcport_handle_login(vha, fcport);
 -				break;
  			}
 +			ql_dbg(ql_dbg_disc, vha, 0x20e5,
 +			    "%s %d %8phC\n",
 +			    __func__, __LINE__, fcport->port_name);
 +			qla24xx_fcport_handle_login(vha, fcport);
  			break;
++<<<<<<< HEAD
 +		}
++=======
+ 		case ISP_CFG_N:
+ 			fcport->fw_login_state = current_login_state;
+ 			fcport->d_id = id;
+ 			switch (current_login_state) {
+ 			case DSC_LS_PRLI_COMP:
+ 				if ((e->prli_svc_param_word_3[0] & BIT_4) == 0)
+ 					fcport->port_type = FCT_INITIATOR;
+ 				else
+ 					fcport->port_type = FCT_TARGET;
+ 
+ 				data[0] = data[1] = 0;
+ 				qla2x00_post_async_adisc_work(vha, fcport,
+ 				    data);
+ 				break;
+ 			case DSC_LS_PLOGI_COMP:
+ 				if (fcport_is_bigger(fcport)) {
+ 					/* local adapter is smaller */
+ 					if (fcport->loop_id != FC_NO_LOOP_ID)
+ 						qla2x00_clear_loop_id(fcport);
+ 
+ 					fcport->loop_id = loop_id;
+ 					qla24xx_fcport_handle_login(vha,
+ 					    fcport);
+ 					break;
+ 				}
+ 				/* fall through */
+ 			default:
+ 				if (fcport_is_smaller(fcport)) {
+ 					/* local adapter is bigger */
+ 					if (fcport->loop_id != FC_NO_LOOP_ID)
+ 						qla2x00_clear_loop_id(fcport);
+ 
+ 					fcport->loop_id = loop_id;
+ 					qla24xx_fcport_handle_login(vha,
+ 					    fcport);
+ 				}
+ 				break;
+ 			}
+ 			break;
+ 		} /* switch (ha->current_topology) */
++>>>>>>> 50435d4211a7 (scsi: qla2xxx: Modify fall-through annotations)
  	}
  
  	if (!found) {
diff --cc drivers/scsi/qla2xxx/qla_target.c
index d135c240090f,78dfece2e89d..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -4363,18 -4535,30 +4363,38 @@@ static int qlt_issue_task_mgmt(struct f
  
  	switch (fn) {
  	case QLA_TGT_LUN_RESET:
++<<<<<<< HEAD
 +	    abort_cmds_for_lun(vha, lun, a->u.isp24.fcp_hdr.s_id);
 +	    break;
++=======
+ 	case QLA_TGT_CLEAR_TS:
+ 	case QLA_TGT_ABORT_TS:
+ 		abort_cmds_for_lun(vha, lun, a->u.isp24.fcp_hdr.s_id);
+ 		/* fall through */
+ 	case QLA_TGT_CLEAR_ACA:
+ 		h = qlt_find_qphint(vha, mcmd->unpacked_lun);
+ 		mcmd->qpair = h->qpair;
+ 		mcmd->se_cmd.cpuid = h->cpuid;
+ 		break;
+ 
+ 	case QLA_TGT_TARGET_RESET:
+ 	case QLA_TGT_NEXUS_LOSS_SESS:
+ 	case QLA_TGT_NEXUS_LOSS:
+ 	case QLA_TGT_ABORT_ALL:
+ 	default:
+ 		/* no-op */
+ 		break;
++>>>>>>> 50435d4211a7 (scsi: qla2xxx: Modify fall-through annotations)
  	}
  
 -	INIT_WORK(&mcmd->work, qlt_do_tmr_work);
 -	queue_work_on(mcmd->se_cmd.cpuid, qla_tgt_wq,
 -	    &mcmd->work);
 +	res = ha->tgt.tgt_ops->handle_tmr(mcmd, lun, mcmd->tmr_func, 0);
 +	if (res != 0) {
 +		ql_dbg(ql_dbg_tgt_tmr, vha, 0x1000b,
 +		    "qla_target(%d): tgt.tgt_ops->handle_tmr() failed: %d\n",
 +		    sess->vha->vp_idx, res);
 +		mempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);
 +		return -EFAULT;
 +	}
  
  	return 0;
  }
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
