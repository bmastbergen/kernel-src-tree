xfs: relog dirty buffers during swapext bmbt owner change

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 2dd3d709fc4338681a3aa61658122fa8faa5a437
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/2dd3d709.failed

The owner change bmbt scan that occurs during extent swap operations
does not handle ordered buffer failures. Buffers that cannot be
marked ordered must be physically logged so previously dirty ranges
of the buffer can be relogged in the transaction.

Since the bmbt scan may need to process and potentially log a large
number of blocks, we can't expect to complete this operation in a
single transaction. Update extent swap to use a permanent
transaction with enough log reservation to physically log a buffer.
Update the bmbt scan to physically log any buffers that cannot be
ordered and to terminate the scan with -EAGAIN. On -EAGAIN, the
caller rolls the transaction and restarts the scan. Finally, update
the bmbt scan helper function to skip bmbt blocks that already match
the expected owner so they are not reprocessed after scan restarts.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
[darrick: fix the xfs_trans_roll call]
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 2dd3d709fc4338681a3aa61658122fa8faa5a437)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/xfs_bmap_util.c
index 9d383ffc740d,8661be0aacaa..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -1610,6 -1985,9 +1652,12 @@@ xfs_swap_extents
  	int			src_log_flags, target_log_flags;
  	int			error = 0;
  	int			lock_flags;
++<<<<<<< HEAD
++=======
+ 	struct xfs_ifork	*cowfp;
+ 	uint64_t		f;
+ 	int			resblks = 0;
++>>>>>>> 2dd3d709fc43 (xfs: relog dirty buffers during swapext bmbt owner change)
  
  	/*
  	 * Lock the inodes against other IO, page faults and truncate to
@@@ -1640,7 -2018,25 +1688,29 @@@
  	if (error)
  		goto out_unlock;
  
++<<<<<<< HEAD
 +	error = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);
++=======
+ 	/*
+ 	 * Extent "swapping" with rmap requires a permanent reservation and
+ 	 * a block reservation because it's really just a remap operation
+ 	 * performed with log redo items!
+ 	 */
+ 	if (xfs_sb_version_hasrmapbt(&mp->m_sb)) {
+ 		/*
+ 		 * Conceptually this shouldn't affect the shape of either
+ 		 * bmbt, but since we atomically move extents one by one,
+ 		 * we reserve enough space to rebuild both trees.
+ 		 */
+ 		resblks = XFS_SWAP_RMAP_SPACE_RES(mp,
+ 				XFS_IFORK_NEXTENTS(ip, XFS_DATA_FORK),
+ 				XFS_DATA_FORK) +
+ 			  XFS_SWAP_RMAP_SPACE_RES(mp,
+ 				XFS_IFORK_NEXTENTS(tip, XFS_DATA_FORK),
+ 				XFS_DATA_FORK);
+ 	}
+ 	error = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, resblks, 0, 0, &tp);
++>>>>>>> 2dd3d709fc43 (xfs: relog dirty buffers during swapext bmbt owner change)
  	if (error)
  		goto out_unlock;
  
diff --git a/fs/xfs/libxfs/xfs_btree.c b/fs/xfs/libxfs/xfs_btree.c
index c2ac5d2d4421..68189b685fde 100644
--- a/fs/xfs/libxfs/xfs_btree.c
+++ b/fs/xfs/libxfs/xfs_btree.c
@@ -4163,10 +4163,15 @@ xfs_btree_block_change_owner(
 
 	/* modify the owner */
 	block = xfs_btree_get_block(cur, level, &bp);
-	if (cur->bc_flags & XFS_BTREE_LONG_PTRS)
+	if (cur->bc_flags & XFS_BTREE_LONG_PTRS) {
+		if (block->bb_u.l.bb_owner == cpu_to_be64(bbcoi->new_owner))
+			return 0;
 		block->bb_u.l.bb_owner = cpu_to_be64(bbcoi->new_owner);
-	else
+	} else {
+		if (block->bb_u.s.bb_owner == cpu_to_be32(bbcoi->new_owner))
+			return 0;
 		block->bb_u.s.bb_owner = cpu_to_be32(bbcoi->new_owner);
+	}
 
 	/*
 	 * If the block is a root block hosted in an inode, we might not have a
@@ -4175,14 +4180,19 @@ xfs_btree_block_change_owner(
 	 * block is formatted into the on-disk inode fork. We still change it,
 	 * though, so everything is consistent in memory.
 	 */
-	if (bp) {
-		if (cur->bc_tp)
-			xfs_trans_ordered_buf(cur->bc_tp, bp);
-		else
-			xfs_buf_delwri_queue(bp, bbcoi->buffer_list);
-	} else {
+	if (!bp) {
 		ASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);
 		ASSERT(level == cur->bc_nlevels - 1);
+		return 0;
+	}
+
+	if (cur->bc_tp) {
+		if (!xfs_trans_ordered_buf(cur->bc_tp, bp)) {
+			xfs_btree_log_block(cur, bp, XFS_BB_OWNER);
+			return -EAGAIN;
+		}
+	} else {
+		xfs_buf_delwri_queue(bp, bbcoi->buffer_list);
 	}
 
 	return 0;
* Unmerged path fs/xfs/xfs_bmap_util.c
