mm, swap: add swap readahead hit statistics

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [mm] swap: add swap readahead hit statistics (Rafael Aquini) [1485248]
Rebuild_FUZZ: 95.12%
commit-author Huang Ying <ying.huang@intel.com>
commit cbc65df240c104bf540af1ad58595bf1eaa5ee10
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/cbc65df2.failed

Patch series "mm, swap: VMA based swap readahead", v4.

The swap readahead is an important mechanism to reduce the swap in
latency.  Although pure sequential memory access pattern isn't very
popular for anonymous memory, the space locality is still considered
valid.

In the original swap readahead implementation, the consecutive blocks in
swap device are readahead based on the global space locality estimation.
But the consecutive blocks in swap device just reflect the order of page
reclaiming, don't necessarily reflect the access pattern in virtual
memory space.  And the different tasks in the system may have different
access patterns, which makes the global space locality estimation
incorrect.

In this patchset, when page fault occurs, the virtual pages near the
fault address will be readahead instead of the swap slots near the fault
swap slot in swap device.  This avoid to readahead the unrelated swap
slots.  At the same time, the swap readahead is changed to work on
per-VMA from globally.  So that the different access patterns of the
different VMAs could be distinguished, and the different readahead
policy could be applied accordingly.  The original core readahead
detection and scaling algorithm is reused, because it is an effect
algorithm to detect the space locality.

In addition to the swap readahead changes, some new sysfs interface is
added to show the efficiency of the readahead algorithm and some other
swap statistics.

This new implementation will incur more small random read, on SSD, the
improved correctness of estimation and readahead target should beat the
potential increased overhead, this is also illustrated in the test
results below.  But on HDD, the overhead may beat the benefit, so the
original implementation will be used by default.

The test and result is as follow,

Common test condition
=====================

Test Machine: Xeon E5 v3 (2 sockets, 72 threads, 32G RAM)
Swap device: NVMe disk

Micro-benchmark with combined access pattern
============================================

vm-scalability, sequential swap test case, 4 processes to eat 50G
virtual memory space, repeat the sequential memory writing until 300
seconds.  The first round writing will trigger swap out, the following
rounds will trigger sequential swap in and out.

At the same time, run vm-scalability random swap test case in
background, 8 processes to eat 30G virtual memory space, repeat the
random memory write until 300 seconds.  This will trigger random swap-in
in the background.

This is a combined workload with sequential and random memory accessing
at the same time.  The result (for sequential workload) is as follow,

			Base		Optimized
			----		---------
throughput		345413 KB/s	414029 KB/s (+19.9%)
latency.average		97.14 us	61.06 us (-37.1%)
latency.50th		2 us		1 us
latency.60th		2 us		1 us
latency.70th		98 us		2 us
latency.80th		160 us		2 us
latency.90th		260 us		217 us
latency.95th		346 us		369 us
latency.99th		1.34 ms		1.09 ms
ra_hit%			52.69%		99.98%

The original swap readahead algorithm is confused by the background
random access workload, so readahead hit rate is lower.  The VMA-base
readahead algorithm works much better.

Linpack
=======

The test memory size is bigger than RAM to trigger swapping.

			Base		Optimized
			----		---------
elapsed_time		393.49 s	329.88 s (-16.2%)
ra_hit%			86.21%		98.82%

The score of base and optimized kernel hasn't visible changes.  But the
elapsed time reduced and readahead hit rate improved, so the optimized
kernel runs better for startup and tear down stages.  And the absolute
value of readahead hit rate is high, shows that the space locality is
still valid in some practical workloads.

This patch (of 5):

The statistics for total readahead pages and total readahead hits are
recorded and exported via the following sysfs interface.

/sys/kernel/mm/swap/ra_hits
/sys/kernel/mm/swap/ra_total

With them, the efficiency of the swap readahead could be measured, so
that the swap readahead algorithm and parameters could be tuned
accordingly.

[akpm@linux-foundation.org: don't display swap stats if CONFIG_SWAP=n]
Link: http://lkml.kernel.org/r/20170807054038.1843-2-ying.huang@intel.com
	Signed-off-by: "Huang, Ying" <ying.huang@intel.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Shaohua Li <shli@kernel.org>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Fengguang Wu <fengguang.wu@intel.com>
	Cc: Tim Chen <tim.c.chen@intel.com>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit cbc65df240c104bf540af1ad58595bf1eaa5ee10)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/vm_event_item.h
#	mm/swap_state.c
#	mm/vmstat.c
diff --cc include/linux/vm_event_item.h
index 7f1f41abc0d7,d77bc35278b0..000000000000
--- a/include/linux/vm_event_item.h
+++ b/include/linux/vm_event_item.h
@@@ -80,6 -95,21 +80,24 @@@ enum vm_event_item { PGPGIN, PGPGOUT, P
  		BALLOON_MIGRATE,
  #endif
  #endif
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_DEBUG_TLBFLUSH
+ 		NR_TLB_REMOTE_FLUSH,	/* cpu tried to flush others' tlbs */
+ 		NR_TLB_REMOTE_FLUSH_RECEIVED,/* cpu received ipi for flush */
+ 		NR_TLB_LOCAL_FLUSH_ALL,
+ 		NR_TLB_LOCAL_FLUSH_ONE,
+ #endif /* CONFIG_DEBUG_TLBFLUSH */
+ #ifdef CONFIG_DEBUG_VM_VMACACHE
+ 		VMACACHE_FIND_CALLS,
+ 		VMACACHE_FIND_HITS,
+ 		VMACACHE_FULL_FLUSHES,
+ #endif
+ #ifdef CONFIG_SWAP
+ 		SWAP_RA,
+ 		SWAP_RA_HIT,
+ #endif
++>>>>>>> cbc65df240c1 (mm, swap: add swap readahead hit statistics)
  		NR_VM_EVENT_ITEMS
  };
  
diff --cc mm/swap_state.c
index bbce650716cb,d1bdb31cab13..000000000000
--- a/mm/swap_state.c
+++ b/mm/swap_state.c
@@@ -307,10 -301,15 +307,18 @@@ struct page * lookup_swap_cache(swp_ent
  {
  	struct page *page;
  
 -	page = find_get_page(swap_address_space(entry), swp_offset(entry));
 +	page = find_get_page(swap_address_space(entry), entry.val);
  
 -	if (page && likely(!PageTransCompound(page))) {
 +	if (page)
  		INC_CACHE_INFO(find_success);
++<<<<<<< HEAD
++=======
+ 		if (TestClearPageReadahead(page)) {
+ 			atomic_inc(&swapin_readahead_hits);
+ 			count_vm_event(SWAP_RA_HIT);
+ 		}
+ 	}
++>>>>>>> cbc65df240c1 (mm, swap: add swap readahead hit statistics)
  
  	INC_CACHE_INFO(find_total);
  	return page;
@@@ -479,10 -515,15 +487,19 @@@ struct page *swapin_readahead(swp_entry
  	for (offset = start_offset; offset <= end_offset ; offset++) {
  		/* Ok, do the async read-ahead now */
  		page = read_swap_cache_async(swp_entry(swp_type(entry), offset),
 -						gfp_mask, vma, addr, false);
 +						gfp_mask, vma, addr);
  		if (!page)
  			continue;
++<<<<<<< HEAD
 +		page_cache_release(page);
++=======
+ 		if (offset != entry_offset &&
+ 		    likely(!PageTransCompound(page))) {
+ 			SetPageReadahead(page);
+ 			count_vm_event(SWAP_RA);
+ 		}
+ 		put_page(page);
++>>>>>>> cbc65df240c1 (mm, swap: add swap readahead hit statistics)
  	}
  	blk_finish_plug(&plug);
  
diff --cc mm/vmstat.c
index bf0311ec1984,c7e4b8458023..000000000000
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@@ -883,6 -1084,24 +883,27 @@@ const char * const vmstat_text[] = 
  	"balloon_migrate",
  #endif
  #endif /* CONFIG_MEMORY_BALLOON */
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_DEBUG_TLBFLUSH
+ #ifdef CONFIG_SMP
+ 	"nr_tlb_remote_flush",
+ 	"nr_tlb_remote_flush_received",
+ #endif /* CONFIG_SMP */
+ 	"nr_tlb_local_flush_all",
+ 	"nr_tlb_local_flush_one",
+ #endif /* CONFIG_DEBUG_TLBFLUSH */
+ 
+ #ifdef CONFIG_DEBUG_VM_VMACACHE
+ 	"vmacache_find_calls",
+ 	"vmacache_find_hits",
+ 	"vmacache_full_flushes",
+ #endif
+ #ifdef CONFIG_SWAP
+ 	"swap_ra",
+ 	"swap_ra_hit",
+ #endif
++>>>>>>> cbc65df240c1 (mm, swap: add swap readahead hit statistics)
  #endif /* CONFIG_VM_EVENTS_COUNTERS */
  };
  #endif /* CONFIG_PROC_FS || CONFIG_SYSFS || CONFIG_NUMA */
* Unmerged path include/linux/vm_event_item.h
* Unmerged path mm/swap_state.c
* Unmerged path mm/vmstat.c
