net/mlx5: E-Switch, Get counters for offloaded flows from callers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Get counters for offloaded flows from callers (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 96.83%
commit-author Mark Bloch <markb@mellanox.com>
commit b8aee82250b7d90a32b11ba208656f52dbaca342
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b8aee822.failed

There's no real reason for the e-switch logic to manage the creation of
counters for offloaded flows. The API already has the directive for the
caller to denote they want to attach a counter to the created flow.
As such, we go and move the management of flow counters to the mlx5e
tc offload logic. This also lets us remove an inelegant interface where
the FS layer had to provide a way to retrieve a counter from a flow rule.

	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit b8aee82250b7d90a32b11ba208656f52dbaca342)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 3a01f0d3c372,8a27c0813a18..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -788,8 -799,8 +790,13 @@@ static void mlx5e_tc_del_nic_flow(struc
  	struct mlx5_nic_flow_attr *attr = flow->nic_attr;
  	struct mlx5_fc *counter = NULL;
  
++<<<<<<< HEAD
 +	counter = mlx5_flow_rule_counter(flow->rule);
 +	mlx5_del_flow_rules(flow->rule);
++=======
+ 	counter = attr->counter;
+ 	mlx5_del_flow_rules(flow->rule[0]);
++>>>>>>> b8aee82250b7 (net/mlx5: E-Switch, Get counters for offloaded flows from callers)
  	mlx5_fc_destroy(priv->mdev, counter);
  
  	if (!mlx5e_tc_num_filters(priv) && priv->fs.tc.t) {
@@@ -867,7 -891,18 +885,9 @@@ mlx5e_tc_add_fdb_flow(struct mlx5e_pri
  	}
  	return rule;
  
 -err_fwd_rule:
 -	mlx5_eswitch_del_offloaded_rule(esw, rule, attr);
 -	rule = flow->rule[1];
  err_add_rule:
+ 	mlx5_fc_destroy(esw->dev, counter);
+ err_create_counter:
  	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
  		mlx5e_detach_mod_hdr(priv, flow);
  err_mod_hdr:
@@@ -978,7 -1043,7 +1009,11 @@@ void mlx5e_tc_update_neigh_used_value(s
  			continue;
  		list_for_each_entry(flow, &e->flows, encap) {
  			if (flow->flags & MLX5E_TC_FLOW_OFFLOADED) {
++<<<<<<< HEAD
 +				counter = mlx5_flow_rule_counter(flow->rule);
++=======
+ 				counter = mlx5e_tc_get_counter(flow);
++>>>>>>> b8aee82250b7 (net/mlx5: E-Switch, Get counters for offloaded flows from callers)
  				mlx5_fc_query_cached(counter, &bytes, &packets, &lastuse);
  				if (time_after((unsigned long)lastuse, nhe->reported_lastuse)) {
  					neigh_used = true;
@@@ -2843,7 -3045,7 +2878,11 @@@ int mlx5e_stats_flower(struct mlx5e_pri
  	if (!(flow->flags & MLX5E_TC_FLOW_OFFLOADED))
  		return 0;
  
++<<<<<<< HEAD
 +	counter = mlx5_flow_rule_counter(flow->rule);
++=======
+ 	counter = mlx5e_tc_get_counter(flow);
++>>>>>>> b8aee82250b7 (net/mlx5: E-Switch, Get counters for offloaded flows from callers)
  	if (!counter)
  		return 0;
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 84864631953e,a2f2d726c99b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -48,12 -48,12 +48,16 @@@ mlx5_eswitch_add_offloaded_rule(struct 
  				struct mlx5_flow_spec *spec,
  				struct mlx5_esw_flow_attr *attr)
  {
 -	struct mlx5_flow_destination dest[MLX5_MAX_FLOW_FWD_VPORTS + 1] = {};
 +	struct mlx5_flow_destination dest[2] = {};
  	struct mlx5_flow_act flow_act = {0};
++<<<<<<< HEAD
 +	struct mlx5_fc *counter = NULL;
++=======
+ 	struct mlx5_flow_table *ft = NULL;
++>>>>>>> b8aee82250b7 (net/mlx5: E-Switch, Get counters for offloaded flows from callers)
  	struct mlx5_flow_handle *rule;
 -	int j, i = 0;
  	void *misc;
 +	int i = 0;
  
  	if (esw->mode != SRIOV_OFFLOADS)
  		return ERR_PTR(-EOPNOTSUPP);
@@@ -70,23 -80,18 +74,18 @@@
  	}
  
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {
 -		for (j = attr->mirror_count; j < attr->out_count; j++) {
 -			dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
 -			dest[i].vport.num = attr->out_rep[j]->vport;
 +		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
 +		dest[i].vport.num = attr->out_rep->vport;
 +		if (MLX5_CAP_ESW(esw->dev, merged_eswitch)) {
  			dest[i].vport.vhca_id =
 -				MLX5_CAP_GEN(attr->out_mdev[j], vhca_id);
 -			dest[i].vport.vhca_id_valid = !!MLX5_CAP_ESW(esw->dev, merged_eswitch);
 -			i++;
 +				MLX5_CAP_GEN(attr->out_mdev, vhca_id);
 +			dest[i].vport.vhca_id_valid = 1;
  		}
 +		i++;
  	}
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {
- 		counter = mlx5_fc_create(esw->dev, true);
- 		if (IS_ERR(counter)) {
- 			rule = ERR_CAST(counter);
- 			goto err_counter_alloc;
- 		}
  		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;
- 		dest[i].counter = counter;
+ 		dest[i].counter = attr->counter;
  		i++;
  	}
  
@@@ -116,13 -121,12 +115,13 @@@
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
  		flow_act.modify_id = attr->mod_hdr_id;
  
 -	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT)
 -		flow_act.reformat_id = attr->encap_id;
 +	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_ENCAP)
 +		flow_act.encap_id = attr->encap_id;
  
 -	rule = mlx5_add_flow_rules(ft, spec, &flow_act, dest, i);
 +	rule = mlx5_add_flow_rules((struct mlx5_flow_table *)esw->fdb_table.offloads.fast_fdb,
 +				   spec, &flow_act, dest, i);
  	if (IS_ERR(rule))
- 		goto err_add_rule;
+ 		goto out;
  	else
  		esw->offloads.num_flows++;
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 21bc97b70ed9..e68a895da73e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -255,6 +255,7 @@ struct mlx5_esw_flow_attr {
 	u32	encap_id;
 	u32	mod_hdr_id;
 	u8	match_level;
+	struct mlx5_fc *counter;
 	struct mlx5e_tc_flow_parse_attr *parse_attr;
 };
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index 72297c31a849..de8e5da02919 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@ -1453,21 +1453,6 @@ static struct mlx5_flow_handle *add_rule_fg(struct mlx5_flow_group *fg,
 	return handle;
 }
 
-struct mlx5_fc *mlx5_flow_rule_counter(struct mlx5_flow_handle *handle)
-{
-	struct mlx5_flow_rule *dst;
-	struct fs_fte *fte;
-
-	fs_get_obj(fte, handle->rule[0]->node.parent);
-
-	fs_for_each_dst(dst, fte) {
-		if (dst->dest_attr.type == MLX5_FLOW_DESTINATION_TYPE_COUNTER)
-			return dst->dest_attr.counter;
-	}
-
-	return NULL;
-}
-
 static bool counter_is_valid(struct mlx5_fc *counter, u32 action)
 {
 	if (!(action & MLX5_FLOW_CONTEXT_ACTION_COUNT))
diff --git a/include/linux/mlx5/fs.h b/include/linux/mlx5/fs.h
index 7035fec2adf8..ecbb469b919b 100644
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@ -180,7 +180,6 @@ int mlx5_modify_rule_destination(struct mlx5_flow_handle *handler,
 				 struct mlx5_flow_destination *new_dest,
 				 struct mlx5_flow_destination *old_dest);
 
-struct mlx5_fc *mlx5_flow_rule_counter(struct mlx5_flow_handle *handler);
 struct mlx5_fc *mlx5_fc_create(struct mlx5_core_dev *dev, bool aging);
 void mlx5_fc_destroy(struct mlx5_core_dev *dev, struct mlx5_fc *counter);
 void mlx5_fc_query_cached(struct mlx5_fc *counter,
