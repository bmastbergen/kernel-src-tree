treewide: kzalloc() -> kcalloc()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Kees Cook <keescook@chromium.org>
commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6396bb22.failed

The kzalloc() function has a 2-factor argument form, kcalloc(). This
patch replaces cases of:

        kzalloc(a * b, gfp)

with:
        kcalloc(a * b, gfp)

as well as handling cases of:

        kzalloc(a * b * c, gfp)

with:

        kzalloc(array3_size(a, b, c), gfp)

as it's slightly less ugly than:

        kzalloc_array(array_size(a, b), c, gfp)

This does, however, attempt to ignore constant size factors like:

        kzalloc(4 * 1024, gfp)

though any constants defined via macros get caught up in the conversion.

Any factors with a sizeof() of "unsigned char", "char", and "u8" were
dropped, since they're redundant.

The Coccinelle script used for this was:

// Fix redundant parens around sizeof().
@@
type TYPE;
expression THING, E;
@@

(
  kzalloc(
-	(sizeof(TYPE)) * E
+	sizeof(TYPE) * E
  , ...)
|
  kzalloc(
-	(sizeof(THING)) * E
+	sizeof(THING) * E
  , ...)
)

// Drop single-byte sizes and redundant parens.
@@
expression COUNT;
typedef u8;
typedef __u8;
@@

(
  kzalloc(
-	sizeof(u8) * (COUNT)
+	COUNT
  , ...)
|
  kzalloc(
-	sizeof(__u8) * (COUNT)
+	COUNT
  , ...)
|
  kzalloc(
-	sizeof(char) * (COUNT)
+	COUNT
  , ...)
|
  kzalloc(
-	sizeof(unsigned char) * (COUNT)
+	COUNT
  , ...)
|
  kzalloc(
-	sizeof(u8) * COUNT
+	COUNT
  , ...)
|
  kzalloc(
-	sizeof(__u8) * COUNT
+	COUNT
  , ...)
|
  kzalloc(
-	sizeof(char) * COUNT
+	COUNT
  , ...)
|
  kzalloc(
-	sizeof(unsigned char) * COUNT
+	COUNT
  , ...)
)

// 2-factor product with sizeof(type/expression) and identifier or constant.
@@
type TYPE;
expression THING;
identifier COUNT_ID;
constant COUNT_CONST;
@@

(
- kzalloc
+ kcalloc
  (
-	sizeof(TYPE) * (COUNT_ID)
+	COUNT_ID, sizeof(TYPE)
  , ...)
|
- kzalloc
+ kcalloc
  (
-	sizeof(TYPE) * COUNT_ID
+	COUNT_ID, sizeof(TYPE)
  , ...)
|
- kzalloc
+ kcalloc
  (
-	sizeof(TYPE) * (COUNT_CONST)
+	COUNT_CONST, sizeof(TYPE)
  , ...)
|
- kzalloc
+ kcalloc
  (
-	sizeof(TYPE) * COUNT_CONST
+	COUNT_CONST, sizeof(TYPE)
  , ...)
|
- kzalloc
+ kcalloc
  (
-	sizeof(THING) * (COUNT_ID)
+	COUNT_ID, sizeof(THING)
  , ...)
|
- kzalloc
+ kcalloc
  (
-	sizeof(THING) * COUNT_ID
+	COUNT_ID, sizeof(THING)
  , ...)
|
- kzalloc
+ kcalloc
  (
-	sizeof(THING) * (COUNT_CONST)
+	COUNT_CONST, sizeof(THING)
  , ...)
|
- kzalloc
+ kcalloc
  (
-	sizeof(THING) * COUNT_CONST
+	COUNT_CONST, sizeof(THING)
  , ...)
)

// 2-factor product, only identifiers.
@@
identifier SIZE, COUNT;
@@

- kzalloc
+ kcalloc
  (
-	SIZE * COUNT
+	COUNT, SIZE
  , ...)

// 3-factor product with 1 sizeof(type) or sizeof(expression), with
// redundant parens removed.
@@
expression THING;
identifier STRIDE, COUNT;
type TYPE;
@@

(
  kzalloc(
-	sizeof(TYPE) * (COUNT) * (STRIDE)
+	array3_size(COUNT, STRIDE, sizeof(TYPE))
  , ...)
|
  kzalloc(
-	sizeof(TYPE) * (COUNT) * STRIDE
+	array3_size(COUNT, STRIDE, sizeof(TYPE))
  , ...)
|
  kzalloc(
-	sizeof(TYPE) * COUNT * (STRIDE)
+	array3_size(COUNT, STRIDE, sizeof(TYPE))
  , ...)
|
  kzalloc(
-	sizeof(TYPE) * COUNT * STRIDE
+	array3_size(COUNT, STRIDE, sizeof(TYPE))
  , ...)
|
  kzalloc(
-	sizeof(THING) * (COUNT) * (STRIDE)
+	array3_size(COUNT, STRIDE, sizeof(THING))
  , ...)
|
  kzalloc(
-	sizeof(THING) * (COUNT) * STRIDE
+	array3_size(COUNT, STRIDE, sizeof(THING))
  , ...)
|
  kzalloc(
-	sizeof(THING) * COUNT * (STRIDE)
+	array3_size(COUNT, STRIDE, sizeof(THING))
  , ...)
|
  kzalloc(
-	sizeof(THING) * COUNT * STRIDE
+	array3_size(COUNT, STRIDE, sizeof(THING))
  , ...)
)

// 3-factor product with 2 sizeof(variable), with redundant parens removed.
@@
expression THING1, THING2;
identifier COUNT;
type TYPE1, TYPE2;
@@

(
  kzalloc(
-	sizeof(TYPE1) * sizeof(TYPE2) * COUNT
+	array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
  , ...)
|
  kzalloc(
-	sizeof(TYPE1) * sizeof(THING2) * (COUNT)
+	array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
  , ...)
|
  kzalloc(
-	sizeof(THING1) * sizeof(THING2) * COUNT
+	array3_size(COUNT, sizeof(THING1), sizeof(THING2))
  , ...)
|
  kzalloc(
-	sizeof(THING1) * sizeof(THING2) * (COUNT)
+	array3_size(COUNT, sizeof(THING1), sizeof(THING2))
  , ...)
|
  kzalloc(
-	sizeof(TYPE1) * sizeof(THING2) * COUNT
+	array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
  , ...)
|
  kzalloc(
-	sizeof(TYPE1) * sizeof(THING2) * (COUNT)
+	array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
  , ...)
)

// 3-factor product, only identifiers, with redundant parens removed.
@@
identifier STRIDE, SIZE, COUNT;
@@

(
  kzalloc(
-	(COUNT) * STRIDE * SIZE
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  kzalloc(
-	COUNT * (STRIDE) * SIZE
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  kzalloc(
-	COUNT * STRIDE * (SIZE)
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  kzalloc(
-	(COUNT) * (STRIDE) * SIZE
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  kzalloc(
-	COUNT * (STRIDE) * (SIZE)
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  kzalloc(
-	(COUNT) * STRIDE * (SIZE)
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  kzalloc(
-	(COUNT) * (STRIDE) * (SIZE)
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  kzalloc(
-	COUNT * STRIDE * SIZE
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
)

// Any remaining multi-factor products, first at least 3-factor products,
// when they're not all constants...
@@
expression E1, E2, E3;
constant C1, C2, C3;
@@

(
  kzalloc(C1 * C2 * C3, ...)
|
  kzalloc(
-	(E1) * E2 * E3
+	array3_size(E1, E2, E3)
  , ...)
|
  kzalloc(
-	(E1) * (E2) * E3
+	array3_size(E1, E2, E3)
  , ...)
|
  kzalloc(
-	(E1) * (E2) * (E3)
+	array3_size(E1, E2, E3)
  , ...)
|
  kzalloc(
-	E1 * E2 * E3
+	array3_size(E1, E2, E3)
  , ...)
)

// And then all remaining 2 factors products when they're not all constants,
// keeping sizeof() as the second factor argument.
@@
expression THING, E1, E2;
type TYPE;
constant C1, C2, C3;
@@

(
  kzalloc(sizeof(THING) * C2, ...)
|
  kzalloc(sizeof(TYPE) * C2, ...)
|
  kzalloc(C1 * C2 * C3, ...)
|
  kzalloc(C1 * C2, ...)
|
- kzalloc
+ kcalloc
  (
-	sizeof(TYPE) * (E2)
+	E2, sizeof(TYPE)
  , ...)
|
- kzalloc
+ kcalloc
  (
-	sizeof(TYPE) * E2
+	E2, sizeof(TYPE)
  , ...)
|
- kzalloc
+ kcalloc
  (
-	sizeof(THING) * (E2)
+	E2, sizeof(THING)
  , ...)
|
- kzalloc
+ kcalloc
  (
-	sizeof(THING) * E2
+	E2, sizeof(THING)
  , ...)
|
- kzalloc
+ kcalloc
  (
-	(E1) * E2
+	E1, E2
  , ...)
|
- kzalloc
+ kcalloc
  (
-	(E1) * (E2)
+	E1, E2
  , ...)
|
- kzalloc
+ kcalloc
  (
-	E1 * E2
+	E1, E2
  , ...)
)

	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/mach-omap2/omap_device.c
#	arch/arm/mach-s3c24xx/cpufreq.c
#	arch/arm/mach-vexpress/spc.c
#	arch/arm/mm/dma-mapping.c
#	arch/arm64/kernel/armv8_deprecated.c
#	arch/arm64/mm/context.c
#	arch/mips/alchemy/common/clock.c
#	arch/mips/bmips/dma.c
#	arch/powerpc/net/bpf_jit_comp64.c
#	arch/powerpc/sysdev/xive/native.c
#	arch/x86/events/amd/iommu.c
#	arch/x86/kernel/cpu/mcheck/mce_amd.c
#	arch/x86/kernel/hpet.c
#	drivers/android/binder_alloc.c
#	drivers/block/drbd/drbd_main.c
#	drivers/block/null_blk.c
#	drivers/block/ps3vram.c
#	drivers/block/xen-blkback/xenbus.c
#	drivers/block/xen-blkfront.c
#	drivers/clk/renesas/clk-r8a7740.c
#	drivers/clk/renesas/clk-r8a7779.c
#	drivers/clk/renesas/clk-rcar-gen2.c
#	drivers/clk/renesas/clk-rz.c
#	drivers/clk/st/clkgen-fsyn.c
#	drivers/clk/st/clkgen-pll.c
#	drivers/clk/sunxi/clk-usb.c
#	drivers/clk/tegra/clk.c
#	drivers/clk/ti/apll.c
#	drivers/clk/ti/divider.c
#	drivers/clk/ti/dpll.c
#	drivers/clocksource/sh_cmt.c
#	drivers/clocksource/sh_mtu2.c
#	drivers/clocksource/sh_tmu.c
#	drivers/cpufreq/acpi-cpufreq.c
#	drivers/cpufreq/arm_big_little.c
#	drivers/cpufreq/ia64-acpi-cpufreq.c
#	drivers/cpufreq/longhaul.c
#	drivers/cpufreq/sfi-cpufreq.c
#	drivers/cpufreq/spear-cpufreq.c
#	drivers/crypto/amcc/crypto4xx_core.c
#	drivers/crypto/inside-secure/safexcel_hash.c
#	drivers/crypto/marvell/hash.c
#	drivers/dma/ioat/init.c
#	drivers/dma/mv_xor.c
#	drivers/dma/pl330.c
#	drivers/dma/xilinx/zynqmp_dma.c
#	drivers/edac/amd64_edac.c
#	drivers/extcon/extcon.c
#	drivers/firmware/efi/capsule.c
#	drivers/firmware/efi/runtime-map.c
#	drivers/fmc/fmc-sdb.c
#	drivers/gpu/drm/amd/display/modules/color/color_gamma.c
#	drivers/gpu/drm/amd/display/modules/stats/stats.c
#	drivers/gpu/drm/i915/intel_hdcp.c
#	drivers/hwmon/coretemp.c
#	drivers/i2c/i2c-stub.c
#	drivers/infiniband/hw/hns/hns_roce_hw_v2.c
#	drivers/iommu/omap-iommu.c
#	drivers/irqchip/irq-alpine-msi.c
#	drivers/irqchip/irq-gic-v2m.c
#	drivers/irqchip/irq-gic-v3-its.c
#	drivers/irqchip/irq-gic-v3.c
#	drivers/irqchip/irq-partition-percpu.c
#	drivers/isdn/capi/capi.c
#	drivers/isdn/mISDN/fsm.c
#	drivers/lightnvm/pblk-init.c
#	drivers/md/bcache/super.c
#	drivers/md/dm-crypt.c
#	drivers/md/md-cluster.c
#	drivers/media/usb/usbtv/usbtv-video.c
#	drivers/mfd/cros_ec_dev.c
#	drivers/misc/sram.c
#	drivers/mtd/chips/cfi_cmdset_0001.c
#	drivers/mtd/maps/physmap_of.c
#	drivers/mtd/ofpart.c
#	drivers/mtd/parsers/parser_trx.c
#	drivers/mtd/parsers/sharpslpart.c
#	drivers/mtd/tests/mtd_pagetest.c
#	drivers/net/bonding/bond_main.c
#	drivers/net/ethernet/broadcom/bcm63xx_enet.c
#	drivers/net/ethernet/cavium/thunder/nicvf_queues.c
#	drivers/net/ethernet/cortina/gemini.c
#	drivers/net/ethernet/hisilicon/hns/hns_enet.c
#	drivers/net/ethernet/jme.c
#	drivers/net/ethernet/socionext/netsec.c
#	drivers/net/phy/dp83640.c
#	drivers/net/virtio_net.c
#	drivers/net/wan/fsl_ucc_hdlc.c
#	drivers/net/wireless/quantenna/qtnfmac/commands.c
#	drivers/net/wireless/st/cw1200/queue.c
#	drivers/net/wireless/st/cw1200/scan.c
#	drivers/nvmem/rockchip-efuse.c
#	drivers/nvmem/sunxi_sid.c
#	drivers/of/unittest.c
#	drivers/opp/ti-opp-supply.c
#	drivers/pinctrl/sirf/pinctrl-sirf.c
#	drivers/pinctrl/sunxi/pinctrl-sunxi.c
#	drivers/platform/x86/alienware-wmi.c
#	drivers/rapidio/rio-scan.c
#	drivers/regulator/s2mps11.c
#	drivers/s390/char/zcore.c
#	drivers/s390/crypto/pkey_api.c
#	drivers/scsi/BusLogic.c
#	drivers/scsi/aic7xxx/aic7xxx_core.c
#	drivers/scsi/esas2r/esas2r_init.c
#	drivers/scsi/scsi_debug.c
#	drivers/scsi/sg.c
#	drivers/scsi/st.c
#	drivers/slimbus/qcom-ctrl.c
#	drivers/staging/mt7621-pinctrl/pinctrl-rt2880.c
#	drivers/staging/rtlwifi/efuse.c
#	drivers/staging/unisys/visorhba/visorhba_main.c
#	drivers/target/target_core_transport.c
#	drivers/target/target_core_user.c
#	drivers/thermal/int340x_thermal/int340x_thermal_zone.c
#	drivers/thermal/of-thermal.c
#	drivers/thermal/x86_pkg_temp_thermal.c
#	drivers/tty/goldfish.c
#	drivers/usb/dwc2/hcd.c
#	drivers/usb/gadget/fsl_udc_core.c
#	drivers/usb/gadget/udc/bdc/bdc_ep.c
#	drivers/usb/renesas_usbhs/pipe.c
#	drivers/vhost/scsi.c
#	drivers/video/fbmon.c
#	drivers/xen/arm-device.c
#	fs/btrfs/check-integrity.c
#	fs/cifs/cifssmb.c
#	fs/cifs/file.c
#	fs/ext4/extents.c
#	fs/overlayfs/namei.c
#	fs/udf/super.c
#	kernel/bpf/verifier.c
#	kernel/locking/locktorture.c
#	kernel/trace/trace.c
#	kernel/workqueue.c
#	mm/slub.c
#	net/can/bcm.c
#	net/ipv4/fib_frontend.c
#	net/ipv6/icmp.c
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nfnetlink_cthelper.c
#	net/rds/ib.c
#	net/sctp/auth.c
#	net/smc/smc_wr.c
#	net/sunrpc/cache.c
#	sound/firewire/fireface/ff-protocol-ff400.c
#	sound/pci/hda/patch_ca0132.c
#	sound/soc/codecs/wm_adsp.c
#	virt/kvm/arm/vgic/vgic-v4.c
diff --cc arch/arm/mach-omap2/omap_device.c
index b595998da3e7,06b6bca3a179..000000000000
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@@ -137,7 -151,11 +137,15 @@@ static int omap_device_build_from_dt(st
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	hwmods = kzalloc(sizeof(struct omap_hwmod *) * oh_cnt, GFP_KERNEL);
++=======
+ 	/* Use ti-sysc driver instead of omap_device? */
+ 	if (!omap_hwmod_parse_module_range(NULL, node, &res))
+ 		return -ENODEV;
+ 
+ 	hwmods = kcalloc(oh_cnt, sizeof(struct omap_hwmod *), GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!hwmods) {
  		ret = -ENOMEM;
  		goto odbfd_exit;
@@@ -484,6 -376,91 +492,94 @@@ void omap_device_delete(struct omap_dev
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * omap_device_copy_resources - Add legacy IO and IRQ resources
+  * @oh: interconnect target module
+  * @pdev: platform device to copy resources to
+  *
+  * We still have legacy DMA and smartreflex needing resources.
+  * Let's populate what they need until we can eventually just
+  * remove this function. Note that there should be no need to
+  * call this from omap_device_build_from_dt(), nor should there
+  * be any need to call it for other devices.
+  */
+ static int
+ omap_device_copy_resources(struct omap_hwmod *oh,
+ 			   struct platform_device *pdev)
+ {
+ 	struct device_node *np, *child;
+ 	struct property *prop;
+ 	struct resource *res;
+ 	const char *name;
+ 	int error, irq = 0;
+ 
+ 	if (!oh || !oh->od || !oh->od->pdev)
+ 		return -EINVAL;
+ 
+ 	np = oh->od->pdev->dev.of_node;
+ 	if (!np) {
+ 		error = -ENODEV;
+ 		goto error;
+ 	}
+ 
+ 	res = kcalloc(2, sizeof(*res), GFP_KERNEL);
+ 	if (!res)
+ 		return -ENOMEM;
+ 
+ 	/* Do we have a dts range for the interconnect target module? */
+ 	error = omap_hwmod_parse_module_range(oh, np, res);
+ 
+ 	/* No ranges, rely on device reg entry */
+ 	if (error)
+ 		error = of_address_to_resource(np, 0, res);
+ 	if (error)
+ 		goto free;
+ 
+ 	/* SmartReflex needs first IO resource name to be "mpu" */
+ 	res[0].name = "mpu";
+ 
+ 	/*
+ 	 * We may have a configured "ti,sysc" interconnect target with a
+ 	 * dts child with the interrupt. If so use the first child's
+ 	 * first interrupt for "ti-hwmods" legacy support.
+ 	 */
+ 	of_property_for_each_string(np, "compatible", prop, name)
+ 		if (!strncmp("ti,sysc-", name, 8))
+ 			break;
+ 
+ 	child = of_get_next_available_child(np, NULL);
+ 
+ 	if (name)
+ 		irq = irq_of_parse_and_map(child, 0);
+ 	if (!irq)
+ 		irq = irq_of_parse_and_map(np, 0);
+ 	if (!irq) {
+ 		error = -EINVAL;
+ 		goto free;
+ 	}
+ 
+ 	/* Legacy DMA code needs interrupt name to be "0" */
+ 	res[1].start = irq;
+ 	res[1].end = irq;
+ 	res[1].flags = IORESOURCE_IRQ;
+ 	res[1].name = "0";
+ 
+ 	error = platform_device_add_resources(pdev, res, 2);
+ 
+ free:
+ 	kfree(res);
+ 
+ error:
+ 	WARN(error, "%s: %s device %s failed: %i\n",
+ 	     __func__, oh->name, dev_name(&pdev->dev),
+ 	     error);
+ 
+ 	return error;
+ }
+ 
+ /**
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
   * omap_device_build - build and register an omap_device with one omap_hwmod
   * @pdev_name: name of the platform_device driver to use
   * @pdev_id: this platform_device's connection ID
diff --cc arch/arm/mach-s3c24xx/cpufreq.c
index 3c0e78ede0da,3b291a2b0cb3..000000000000
--- a/arch/arm/mach-s3c24xx/cpufreq.c
+++ b/arch/arm/mach-s3c24xx/cpufreq.c
@@@ -615,11 -562,9 +615,16 @@@ static int s3c_cpufreq_build_freq(void
  	size = cpu_cur.info->calc_freqtable(&cpu_cur, NULL, 0);
  	size++;
  
++<<<<<<< HEAD:arch/arm/mach-s3c24xx/cpufreq.c
 +	ftab = kmalloc(sizeof(struct cpufreq_frequency_table) * size, GFP_KERNEL);
 +	if (!ftab) {
 +		printk(KERN_ERR "%s: no memory for tables\n", __func__);
++=======
+ 	ftab = kcalloc(size, sizeof(*ftab), GFP_KERNEL);
+ 	if (!ftab)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc()):drivers/cpufreq/s3c24xx-cpufreq.c
  		return -ENOMEM;
 +	}
  
  	ftab_size = size;
  
diff --cc arch/arm/mm/dma-mapping.c
index 1fb40dc37ec2,be0fa7e39c26..000000000000
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@@ -1818,13 -2161,21 +1818,20 @@@ arm_iommu_create_mapping(struct bus_typ
  	if (!mapping)
  		goto err;
  
++<<<<<<< HEAD
 +	mapping->bitmap = kzalloc(bitmap_size, GFP_KERNEL);
 +	if (!mapping->bitmap)
++=======
+ 	mapping->bitmap_size = bitmap_size;
+ 	mapping->bitmaps = kcalloc(extensions, sizeof(unsigned long *),
+ 				   GFP_KERNEL);
+ 	if (!mapping->bitmaps)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		goto err2;
  
 -	mapping->bitmaps[0] = kzalloc(bitmap_size, GFP_KERNEL);
 -	if (!mapping->bitmaps[0])
 -		goto err3;
 -
 -	mapping->nr_bitmaps = 1;
 -	mapping->extensions = extensions;
  	mapping->base = base;
  	mapping->bits = BITS_PER_BYTE * bitmap_size;
 -
 +	mapping->order = order;
  	spin_lock_init(&mapping->lock);
  
  	mapping->domain = iommu_domain_alloc(bus);
diff --cc arch/arm64/mm/context.c
index baa758d37021,c127f94da8e2..000000000000
--- a/arch/arm64/mm/context.c
+++ b/arch/arm64/mm/context.c
@@@ -17,143 -17,259 +17,175 @@@
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  
 -#include <linux/bitops.h>
 +#include <linux/init.h>
  #include <linux/sched.h>
 -#include <linux/slab.h>
  #include <linux/mm.h>
 +#include <linux/smp.h>
 +#include <linux/percpu.h>
  
 -#include <asm/cpufeature.h>
  #include <asm/mmu_context.h>
 -#include <asm/smp.h>
  #include <asm/tlbflush.h>
 +#include <asm/cachetype.h>
  
 -static u32 asid_bits;
 -static DEFINE_RAW_SPINLOCK(cpu_asid_lock);
 -
 -static atomic64_t asid_generation;
 -static unsigned long *asid_map;
 +#define asid_bits(reg) \
 +	(((read_cpuid(ID_AA64MMFR0_EL1) & 0xf0) >> 2) + 8)
  
 -static DEFINE_PER_CPU(atomic64_t, active_asids);
 -static DEFINE_PER_CPU(u64, reserved_asids);
 -static cpumask_t tlb_flush_pending;
 +#define ASID_FIRST_VERSION	(1 << MAX_ASID_BITS)
  
 -#define ASID_MASK		(~GENMASK(asid_bits - 1, 0))
 -#define ASID_FIRST_VERSION	(1UL << asid_bits)
 -
 -#ifdef CONFIG_UNMAP_KERNEL_AT_EL0
 -#define NUM_USER_ASIDS		(ASID_FIRST_VERSION >> 1)
 -#define asid2idx(asid)		(((asid) & ~ASID_MASK) >> 1)
 -#define idx2asid(idx)		(((idx) << 1) & ~ASID_MASK)
 -#else
 -#define NUM_USER_ASIDS		(ASID_FIRST_VERSION)
 -#define asid2idx(asid)		((asid) & ~ASID_MASK)
 -#define idx2asid(idx)		asid2idx(idx)
 -#endif
 +static DEFINE_RAW_SPINLOCK(cpu_asid_lock);
 +unsigned int cpu_last_asid = ASID_FIRST_VERSION;
  
 -/* Get the ASIDBits supported by the current CPU */
 -static u32 get_cpu_asid_bits(void)
 +/*
 + * We fork()ed a process, and we need a new context for the child to run in.
 + */
 +void __init_new_context(struct task_struct *tsk, struct mm_struct *mm)
  {
 -	u32 asid;
 -	int fld = cpuid_feature_extract_unsigned_field(read_cpuid(ID_AA64MMFR0_EL1),
 -						ID_AA64MMFR0_ASID_SHIFT);
 -
 -	switch (fld) {
 -	default:
 -		pr_warn("CPU%d: Unknown ASID size (%d); assuming 8-bit\n",
 -					smp_processor_id(),  fld);
 -		/* Fallthrough */
 -	case 0:
 -		asid = 8;
 -		break;
 -	case 2:
 -		asid = 16;
 -	}
 -
 -	return asid;
 +	mm->context.id = 0;
 +	raw_spin_lock_init(&mm->context.id_lock);
  }
  
 -/* Check if the current cpu's ASIDBits is compatible with asid_bits */
 -void verify_cpu_asid_bits(void)
 +static void flush_context(void)
  {
 -	u32 asid = get_cpu_asid_bits();
 -
 -	if (asid < asid_bits) {
 -		/*
 -		 * We cannot decrease the ASID size at runtime, so panic if we support
 -		 * fewer ASID bits than the boot CPU.
 -		 */
 -		pr_crit("CPU%d: smaller ASID size(%u) than boot CPU (%u)\n",
 -				smp_processor_id(), asid, asid_bits);
 -		cpu_panic_kernel();
 -	}
 +	/* set the reserved TTBR0 before flushing the TLB */
 +	cpu_set_reserved_ttbr0();
 +	flush_tlb_all();
 +	if (icache_is_aivivt())
 +		__flush_icache_all();
  }
  
 -static void flush_context(unsigned int cpu)
 -{
 -	int i;
 -	u64 asid;
 +#ifdef CONFIG_SMP
  
 -	/* Update the list of reserved ASIDs and the ASID bitmap. */
 -	bitmap_clear(asid_map, 0, NUM_USER_ASIDS);
 +static void set_mm_context(struct mm_struct *mm, unsigned int asid)
 +{
 +	unsigned long flags;
  
 -	for_each_possible_cpu(i) {
 -		asid = atomic64_xchg_relaxed(&per_cpu(active_asids, i), 0);
 +	/*
 +	 * Locking needed for multi-threaded applications where the same
 +	 * mm->context.id could be set from different CPUs during the
 +	 * broadcast. This function is also called via IPI so the
 +	 * mm->context.id_lock has to be IRQ-safe.
 +	 */
 +	raw_spin_lock_irqsave(&mm->context.id_lock, flags);
 +	if (likely((mm->context.id ^ cpu_last_asid) >> MAX_ASID_BITS)) {
  		/*
 -		 * If this CPU has already been through a
 -		 * rollover, but hasn't run another task in
 -		 * the meantime, we must preserve its reserved
 -		 * ASID, as this is the only trace we have of
 -		 * the process it is still running.
 +		 * Old version of ASID found. Set the new one and reset
 +		 * mm_cpumask(mm).
  		 */
 -		if (asid == 0)
 -			asid = per_cpu(reserved_asids, i);
 -		__set_bit(asid2idx(asid), asid_map);
 -		per_cpu(reserved_asids, i) = asid;
 +		mm->context.id = asid;
 +		cpumask_clear(mm_cpumask(mm));
  	}
 +	raw_spin_unlock_irqrestore(&mm->context.id_lock, flags);
  
  	/*
 -	 * Queue a TLB invalidation for each CPU to perform on next
 -	 * context-switch
 +	 * Set the mm_cpumask(mm) bit for the current CPU.
  	 */
 -	cpumask_setall(&tlb_flush_pending);
 +	cpumask_set_cpu(smp_processor_id(), mm_cpumask(mm));
  }
  
 -static bool check_update_reserved_asid(u64 asid, u64 newasid)
 +/*
 + * Reset the ASID on the current CPU. This function call is broadcast from the
 + * CPU handling the ASID rollover and holding cpu_asid_lock.
 + */
 +static void reset_context(void *info)
  {
 -	int cpu;
 -	bool hit = false;
 +	unsigned int asid;
 +	unsigned int cpu = smp_processor_id();
 +	struct mm_struct *mm = current->active_mm;
  
 -	/*
 -	 * Iterate over the set of reserved ASIDs looking for a match.
 -	 * If we find one, then we can update our mm to use newasid
 -	 * (i.e. the same ASID in the current generation) but we can't
 -	 * exit the loop early, since we need to ensure that all copies
 -	 * of the old ASID are updated to reflect the mm. Failure to do
 -	 * so could result in us missing the reserved ASID in a future
 -	 * generation.
 -	 */
 -	for_each_possible_cpu(cpu) {
 -		if (per_cpu(reserved_asids, cpu) == asid) {
 -			hit = true;
 -			per_cpu(reserved_asids, cpu) = newasid;
 -		}
 -	}
 +	smp_rmb();
 +	asid = cpu_last_asid + cpu;
  
 -	return hit;
 +	flush_context();
 +	set_mm_context(mm, asid);
 +
 +	/* set the new ASID */
 +	cpu_switch_mm(mm->pgd, mm);
  }
  
 -static u64 new_context(struct mm_struct *mm, unsigned int cpu)
 +#else
 +
 +static inline void set_mm_context(struct mm_struct *mm, unsigned int asid)
  {
 -	static u32 cur_idx = 1;
 -	u64 asid = atomic64_read(&mm->context.id);
 -	u64 generation = atomic64_read(&asid_generation);
 +	mm->context.id = asid;
 +	cpumask_copy(mm_cpumask(mm), cpumask_of(smp_processor_id()));
 +}
  
 -	if (asid != 0) {
 -		u64 newasid = generation | (asid & ~ASID_MASK);
 +#endif
  
 -		/*
 -		 * If our current ASID was active during a rollover, we
 -		 * can continue to use it and this was just a false alarm.
 -		 */
 -		if (check_update_reserved_asid(asid, newasid))
 -			return newasid;
 +void __new_context(struct mm_struct *mm)
 +{
 +	unsigned int asid;
 +	unsigned int bits = asid_bits();
  
 -		/*
 -		 * We had a valid ASID in a previous life, so try to re-use
 -		 * it if possible.
 -		 */
 -		if (!__test_and_set_bit(asid2idx(asid), asid_map))
 -			return newasid;
 +	raw_spin_lock(&cpu_asid_lock);
 +#ifdef CONFIG_SMP
 +	/*
 +	 * Check the ASID again, in case the change was broadcast from another
 +	 * CPU before we acquired the lock.
 +	 */
 +	if (!unlikely((mm->context.id ^ cpu_last_asid) >> MAX_ASID_BITS)) {
 +		cpumask_set_cpu(smp_processor_id(), mm_cpumask(mm));
 +		raw_spin_unlock(&cpu_asid_lock);
 +		return;
  	}
 -
 +#endif
  	/*
 -	 * Allocate a free ASID. If we can't find one, take a note of the
 -	 * currently active ASIDs and mark the TLBs as requiring flushes.  We
 -	 * always count from ASID #2 (index 1), as we use ASID #0 when setting
 -	 * a reserved TTBR0 for the init_mm and we allocate ASIDs in even/odd
 -	 * pairs.
 +	 * At this point, it is guaranteed that the current mm (with an old
 +	 * ASID) isn't active on any other CPU since the ASIDs are changed
 +	 * simultaneously via IPI.
  	 */
 -	asid = find_next_zero_bit(asid_map, NUM_USER_ASIDS, cur_idx);
 -	if (asid != NUM_USER_ASIDS)
 -		goto set_asid;
 -
 -	/* We're out of ASIDs, so increment the global generation count */
 -	generation = atomic64_add_return_relaxed(ASID_FIRST_VERSION,
 -						 &asid_generation);
 -	flush_context(cpu);
 -
 -	/* We have more ASIDs than CPUs, so this will always succeed */
 -	asid = find_next_zero_bit(asid_map, NUM_USER_ASIDS, 1);
 -
 -set_asid:
 -	__set_bit(asid, asid_map);
 -	cur_idx = asid;
 -	return idx2asid(asid) | generation;
 -}
 -
 -void check_and_switch_context(struct mm_struct *mm, unsigned int cpu)
 -{
 -	unsigned long flags;
 -	u64 asid, old_active_asid;
 -
 -	asid = atomic64_read(&mm->context.id);
 +	asid = ++cpu_last_asid;
  
  	/*
 -	 * The memory ordering here is subtle.
 -	 * If our active_asids is non-zero and the ASID matches the current
 -	 * generation, then we update the active_asids entry with a relaxed
 -	 * cmpxchg. Racing with a concurrent rollover means that either:
 -	 *
 -	 * - We get a zero back from the cmpxchg and end up waiting on the
 -	 *   lock. Taking the lock synchronises with the rollover and so
 -	 *   we are forced to see the updated generation.
 -	 *
 -	 * - We get a valid ASID back from the cmpxchg, which means the
 -	 *   relaxed xchg in flush_context will treat us as reserved
 -	 *   because atomic RmWs are totally ordered for a given location.
 +	 * If we've used up all our ASIDs, we need to start a new version and
 +	 * flush the TLB.
  	 */
 -	old_active_asid = atomic64_read(&per_cpu(active_asids, cpu));
 -	if (old_active_asid &&
 -	    !((asid ^ atomic64_read(&asid_generation)) >> asid_bits) &&
 -	    atomic64_cmpxchg_relaxed(&per_cpu(active_asids, cpu),
 -				     old_active_asid, asid))
 -		goto switch_mm_fastpath;
 -
 -	raw_spin_lock_irqsave(&cpu_asid_lock, flags);
 -	/* Check that our ASID belongs to the current generation. */
 -	asid = atomic64_read(&mm->context.id);
 -	if ((asid ^ atomic64_read(&asid_generation)) >> asid_bits) {
 -		asid = new_context(mm, cpu);
 -		atomic64_set(&mm->context.id, asid);
 +	if (unlikely((asid & ((1 << bits) - 1)) == 0)) {
 +		/* increment the ASID version */
 +		cpu_last_asid += (1 << MAX_ASID_BITS) - (1 << bits);
 +		if (cpu_last_asid == 0)
 +			cpu_last_asid = ASID_FIRST_VERSION;
 +		asid = cpu_last_asid + smp_processor_id();
 +		flush_context();
 +#ifdef CONFIG_SMP
 +		smp_wmb();
 +		smp_call_function(reset_context, NULL, 1);
 +#endif
 +		cpu_last_asid += NR_CPUS - 1;
  	}
  
 -	if (cpumask_test_and_clear_cpu(cpu, &tlb_flush_pending))
 -		local_flush_tlb_all();
 -
 -	atomic64_set(&per_cpu(active_asids, cpu), asid);
 -	raw_spin_unlock_irqrestore(&cpu_asid_lock, flags);
 -
 -switch_mm_fastpath:
 -
 -	arm64_apply_bp_hardening();
 -
 -	/*
 -	 * Defer TTBR0_EL1 setting for user threads to uaccess_enable() when
 -	 * emulating PAN.
 -	 */
 -	if (!system_uses_ttbr0_pan())
 -		cpu_switch_mm(mm->pgd, mm);
 +	set_mm_context(mm, asid);
 +	raw_spin_unlock(&cpu_asid_lock);
  }
++<<<<<<< HEAD
++=======
+ 
+ /* Errata workaround post TTBRx_EL1 update. */
+ asmlinkage void post_ttbr_update_workaround(void)
+ {
+ 	asm(ALTERNATIVE("nop; nop; nop",
+ 			"ic iallu; dsb nsh; isb",
+ 			ARM64_WORKAROUND_CAVIUM_27456,
+ 			CONFIG_CAVIUM_ERRATUM_27456));
+ }
+ 
+ static int asids_init(void)
+ {
+ 	asid_bits = get_cpu_asid_bits();
+ 	/*
+ 	 * Expect allocation after rollover to fail if we don't have at least
+ 	 * one more ASID than CPUs. ASID #0 is reserved for init_mm.
+ 	 */
+ 	WARN_ON(NUM_USER_ASIDS - 1 <= num_possible_cpus());
+ 	atomic64_set(&asid_generation, ASID_FIRST_VERSION);
+ 	asid_map = kcalloc(BITS_TO_LONGS(NUM_USER_ASIDS), sizeof(*asid_map),
+ 			   GFP_KERNEL);
+ 	if (!asid_map)
+ 		panic("Failed to allocate bitmap for %lu ASIDs\n",
+ 		      NUM_USER_ASIDS);
+ 
+ 	pr_info("ASID allocator initialised with %lu entries\n", NUM_USER_ASIDS);
+ 	return 0;
+ }
+ early_initcall(asids_init);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
diff --cc arch/x86/kernel/cpu/mcheck/mce_amd.c
index 89d7b0aeefb3,dd33c357548f..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce_amd.c
+++ b/arch/x86/kernel/cpu/mcheck/mce_amd.c
@@@ -1323,24 -1366,42 +1323,51 @@@ static void threshold_remove_device(uns
  		threshold_remove_bank(cpu, bank);
  	}
  	kfree(per_cpu(threshold_banks, cpu));
 -	per_cpu(threshold_banks, cpu) = NULL;
 -	return 0;
  }
  
 -/* create dir/files for all valid threshold banks */
 -int mce_threshold_create_device(unsigned int cpu)
 +/* get notified when a cpu comes on/off */
 +static void
 +amd_64_threshold_cpu_callback(unsigned long action, unsigned int cpu)
  {
++<<<<<<< HEAD
 +	switch (action) {
 +	case CPU_ONLINE:
 +	case CPU_ONLINE_FROZEN:
 +		threshold_create_device(cpu);
 +		break;
 +	case CPU_DEAD:
 +	case CPU_DEAD_FROZEN:
 +		threshold_remove_device(cpu);
 +		break;
 +	default:
 +		break;
++=======
+ 	unsigned int bank;
+ 	struct threshold_bank **bp;
+ 	int err = 0;
+ 
+ 	if (!thresholding_en)
+ 		return 0;
+ 
+ 	bp = per_cpu(threshold_banks, cpu);
+ 	if (bp)
+ 		return 0;
+ 
+ 	bp = kcalloc(mca_cfg.banks, sizeof(struct threshold_bank *),
+ 		     GFP_KERNEL);
+ 	if (!bp)
+ 		return -ENOMEM;
+ 
+ 	per_cpu(threshold_banks, cpu) = bp;
+ 
+ 	for (bank = 0; bank < mca_cfg.banks; ++bank) {
+ 		if (!(per_cpu(bank_map, cpu) & (1 << bank)))
+ 			continue;
+ 		err = threshold_create_bank(cpu, bank);
+ 		if (err)
+ 			goto err;
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	}
 -	return err;
 -err:
 -	mce_threshold_remove_device(cpu);
 -	return err;
  }
  
  static __init int threshold_init_device(void)
diff --cc arch/x86/kernel/hpet.c
index e2332b3fcf98,346b24883911..000000000000
--- a/arch/x86/kernel/hpet.c
+++ b/arch/x86/kernel/hpet.c
@@@ -594,7 -606,11 +594,15 @@@ static void hpet_msi_capability_lookup(
  	num_timers++; /* Value read out starts from 0 */
  	hpet_print_config();
  
++<<<<<<< HEAD
 +	hpet_devs = kzalloc(sizeof(struct hpet_dev) * num_timers, GFP_KERNEL);
++=======
+ 	hpet_domain = hpet_create_irq_domain(hpet_blockid);
+ 	if (!hpet_domain)
+ 		return;
+ 
+ 	hpet_devs = kcalloc(num_timers, sizeof(struct hpet_dev), GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!hpet_devs)
  		return;
  
diff --cc drivers/block/drbd/drbd_main.c
index 1aae75db5ba5,a80809bd3057..000000000000
--- a/drivers/block/drbd/drbd_main.c
+++ b/drivers/block/drbd/drbd_main.c
@@@ -510,28 -503,39 +510,53 @@@ int conn_lowest_minor(struct drbd_tcon
  #ifdef CONFIG_SMP
  /**
   * drbd_calc_cpu_mask() - Generate CPU masks, spread over all CPUs
 + * @mdev:	DRBD device.
   *
 - * Forces all threads of a resource onto the same CPU. This is beneficial for
 + * Forces all threads of a device onto the same CPU. This is beneficial for
   * DRBD's performance. May be overwritten by user's configuration.
   */
 -static void drbd_calc_cpu_mask(cpumask_var_t *cpu_mask)
 +void drbd_calc_cpu_mask(struct drbd_tconn *tconn)
  {
 -	unsigned int *resources_per_cpu, min_index = ~0;
 +	int ord, cpu;
  
++<<<<<<< HEAD
 +	/* user override. */
 +	if (cpumask_weight(tconn->cpu_mask))
++=======
+ 	resources_per_cpu = kcalloc(nr_cpu_ids, sizeof(*resources_per_cpu),
+ 				    GFP_KERNEL);
+ 	if (resources_per_cpu) {
+ 		struct drbd_resource *resource;
+ 		unsigned int cpu, min = ~0;
+ 
+ 		rcu_read_lock();
+ 		for_each_resource_rcu(resource, &drbd_resources) {
+ 			for_each_cpu(cpu, resource->cpu_mask)
+ 				resources_per_cpu[cpu]++;
+ 		}
+ 		rcu_read_unlock();
+ 		for_each_online_cpu(cpu) {
+ 			if (resources_per_cpu[cpu] < min) {
+ 				min = resources_per_cpu[cpu];
+ 				min_index = cpu;
+ 			}
+ 		}
+ 		kfree(resources_per_cpu);
+ 	}
+ 	if (min_index == ~0) {
+ 		cpumask_setall(*cpu_mask);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		return;
 +
 +	ord = conn_lowest_minor(tconn) % cpumask_weight(cpu_online_mask);
 +	for_each_online_cpu(cpu) {
 +		if (ord-- == 0) {
 +			cpumask_set_cpu(cpu, tconn->cpu_mask);
 +			return;
 +		}
  	}
 -	cpumask_set_cpu(min_index, *cpu_mask);
 +	/* should not be reached */
 +	cpumask_setall(tconn->cpu_mask);
  }
  
  /**
diff --cc drivers/block/null_blk.c
index afbbc1db26c4,7948049f6c43..000000000000
--- a/drivers/block/null_blk.c
+++ b/drivers/block/null_blk.c
@@@ -408,26 -1596,11 +408,32 @@@ static int setup_commands(struct nullb_
  	return 0;
  }
  
 +static void cleanup_queue(struct nullb_queue *nq)
 +{
 +	kfree(nq->tag_map);
 +	kfree(nq->cmds);
 +}
 +
 +static void cleanup_queues(struct nullb *nullb)
 +{
 +	int i;
 +
 +	for (i = 0; i < nullb->nr_queues; i++)
 +		cleanup_queue(&nullb->queues[i]);
 +
 +	kfree(nullb->queues);
 +}
 +
  static int setup_queues(struct nullb *nullb)
  {
++<<<<<<< HEAD
 +	nullb->queues = kzalloc(submit_queues * sizeof(struct nullb_queue),
 +								GFP_KERNEL);
++=======
+ 	nullb->queues = kcalloc(nullb->dev->submit_queues,
+ 				sizeof(struct nullb_queue),
+ 				GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!nullb->queues)
  		return -ENOMEM;
  
diff --cc drivers/block/ps3vram.c
index 06a2e53e5f37,1e3d5de9d838..000000000000
--- a/drivers/block/ps3vram.c
+++ b/drivers/block/ps3vram.c
@@@ -407,12 -407,11 +407,19 @@@ static int ps3vram_cache_init(struct ps
  
  	priv->cache.page_count = CACHE_PAGE_COUNT;
  	priv->cache.page_size = CACHE_PAGE_SIZE;
++<<<<<<< HEAD
 +	priv->cache.tags = kzalloc(sizeof(struct ps3vram_tag) *
 +				   CACHE_PAGE_COUNT, GFP_KERNEL);
 +	if (priv->cache.tags == NULL) {
 +		dev_err(&dev->core, "Could not allocate cache tags\n");
++=======
+ 	priv->cache.tags = kcalloc(CACHE_PAGE_COUNT,
+ 				   sizeof(struct ps3vram_tag),
+ 				   GFP_KERNEL);
+ 	if (!priv->cache.tags)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		return -ENOMEM;
 +	}
  
  	dev_info(&dev->core, "Created ram cache: %d entries, %d KiB each\n",
  		CACHE_PAGE_COUNT, CACHE_PAGE_SIZE / 1024);
diff --cc drivers/block/xen-blkback/xenbus.c
index 8a5e018f1303,a4bc74e72c39..000000000000
--- a/drivers/block/xen-blkback/xenbus.c
+++ b/drivers/block/xen-blkback/xenbus.c
@@@ -93,12 -114,56 +93,54 @@@ static void xen_update_blkif_status(str
  	}
  	invalidate_inode_pages2(blkif->vbd.bdev->bd_inode->i_mapping);
  
 -	for (i = 0; i < blkif->nr_rings; i++) {
 -		ring = &blkif->rings[i];
 -		ring->xenblkd = kthread_run(xen_blkif_schedule, ring, "%s-%d", name, i);
 -		if (IS_ERR(ring->xenblkd)) {
 -			err = PTR_ERR(ring->xenblkd);
 -			ring->xenblkd = NULL;
 -			xenbus_dev_fatal(blkif->be->dev, err,
 -					"start %s-%d xenblkd", name, i);
 -			goto out;
 -		}
 +	blkif->xenblkd = kthread_run(xen_blkif_schedule, blkif, name);
 +	if (IS_ERR(blkif->xenblkd)) {
 +		err = PTR_ERR(blkif->xenblkd);
 +		blkif->xenblkd = NULL;
 +		xenbus_dev_error(blkif->be->dev, err, "start xenblkd");
  	}
++<<<<<<< HEAD
++=======
+ 	return;
+ 
+ out:
+ 	while (--i >= 0) {
+ 		ring = &blkif->rings[i];
+ 		kthread_stop(ring->xenblkd);
+ 	}
+ 	return;
+ }
+ 
+ static int xen_blkif_alloc_rings(struct xen_blkif *blkif)
+ {
+ 	unsigned int r;
+ 
+ 	blkif->rings = kcalloc(blkif->nr_rings, sizeof(struct xen_blkif_ring),
+ 			       GFP_KERNEL);
+ 	if (!blkif->rings)
+ 		return -ENOMEM;
+ 
+ 	for (r = 0; r < blkif->nr_rings; r++) {
+ 		struct xen_blkif_ring *ring = &blkif->rings[r];
+ 
+ 		spin_lock_init(&ring->blk_ring_lock);
+ 		init_waitqueue_head(&ring->wq);
+ 		INIT_LIST_HEAD(&ring->pending_free);
+ 		INIT_LIST_HEAD(&ring->persistent_purge_list);
+ 		INIT_WORK(&ring->persistent_purge_work, xen_blkbk_unmap_purged_grants);
+ 		spin_lock_init(&ring->free_pages_lock);
+ 		INIT_LIST_HEAD(&ring->free_pages);
+ 
+ 		spin_lock_init(&ring->pending_free_lock);
+ 		init_waitqueue_head(&ring->pending_free_wq);
+ 		init_waitqueue_head(&ring->shutdown_wq);
+ 		ring->blkif = blkif;
+ 		ring->st_print = jiffies;
+ 		ring->active = true;
+ 	}
+ 
+ 	return 0;
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  }
  
  static struct xen_blkif *xen_blkif_alloc(domid_t domid)
diff --cc drivers/block/xen-blkfront.c
index 5cb25b62d3a8,b5cedccb5d7d..000000000000
--- a/drivers/block/xen-blkfront.c
+++ b/drivers/block/xen-blkfront.c
@@@ -1355,6 -1891,41 +1355,44 @@@ again
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int negotiate_mq(struct blkfront_info *info)
+ {
+ 	unsigned int backend_max_queues;
+ 	unsigned int i;
+ 
+ 	BUG_ON(info->nr_rings);
+ 
+ 	/* Check if backend supports multiple queues. */
+ 	backend_max_queues = xenbus_read_unsigned(info->xbdev->otherend,
+ 						  "multi-queue-max-queues", 1);
+ 	info->nr_rings = min(backend_max_queues, xen_blkif_max_queues);
+ 	/* We need at least one ring. */
+ 	if (!info->nr_rings)
+ 		info->nr_rings = 1;
+ 
+ 	info->rinfo = kcalloc(info->nr_rings,
+ 			      sizeof(struct blkfront_ring_info),
+ 			      GFP_KERNEL);
+ 	if (!info->rinfo) {
+ 		xenbus_dev_fatal(info->xbdev, -ENOMEM, "allocating ring_info structure");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	for (i = 0; i < info->nr_rings; i++) {
+ 		struct blkfront_ring_info *rinfo;
+ 
+ 		rinfo = &info->rinfo[i];
+ 		INIT_LIST_HEAD(&rinfo->indirect_pages);
+ 		INIT_LIST_HEAD(&rinfo->grants);
+ 		rinfo->dev_info = info;
+ 		INIT_WORK(&rinfo->work, blkif_restart_queue);
+ 		spin_lock_init(&rinfo->ring_lock);
+ 	}
+ 	return 0;
+ }
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  /**
   * Entry point to this code when a new device is created.  Allocate the basic
   * structures and the ring buffer for communication with the backend, and
@@@ -1714,22 -2217,25 +1752,40 @@@ static int blkfront_setup_indirect(stru
  		}
  	}
  
++<<<<<<< HEAD
 +	for (i = 0; i < BLK_RING_SIZE; i++) {
 +		info->shadow[i].grants_used = kzalloc(
 +			sizeof(info->shadow[i].grants_used[0]) * segs,
 +			GFP_NOIO);
 +		info->shadow[i].sg = kzalloc(sizeof(info->shadow[i].sg[0]) * segs, GFP_NOIO);
 +		if (info->max_indirect_segments)
 +			info->shadow[i].indirect_grants = kzalloc(
 +				sizeof(info->shadow[i].indirect_grants[0]) *
 +				INDIRECT_GREFS(segs),
 +				GFP_NOIO);
 +		if ((info->shadow[i].grants_used == NULL) ||
 +			(info->shadow[i].sg == NULL) ||
++=======
+ 	for (i = 0; i < BLK_RING_SIZE(info); i++) {
+ 		rinfo->shadow[i].grants_used =
+ 			kcalloc(grants,
+ 				sizeof(rinfo->shadow[i].grants_used[0]),
+ 				GFP_NOIO);
+ 		rinfo->shadow[i].sg = kcalloc(psegs,
+ 					      sizeof(rinfo->shadow[i].sg[0]),
+ 					      GFP_NOIO);
+ 		if (info->max_indirect_segments)
+ 			rinfo->shadow[i].indirect_grants =
+ 				kcalloc(INDIRECT_GREFS(grants),
+ 					sizeof(rinfo->shadow[i].indirect_grants[0]),
+ 					GFP_NOIO);
+ 		if ((rinfo->shadow[i].grants_used == NULL) ||
+ 			(rinfo->shadow[i].sg == NULL) ||
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		     (info->max_indirect_segments &&
 -		     (rinfo->shadow[i].indirect_grants == NULL)))
 +		     (info->shadow[i].indirect_grants == NULL)))
  			goto out_of_memory;
 -		sg_init_table(rinfo->shadow[i].sg, psegs);
 +		sg_init_table(info->shadow[i].sg, segs);
  	}
  
  
diff --cc drivers/clk/tegra/clk.c
index 923ca7ee4694,ffaf17f71860..000000000000
--- a/drivers/clk/tegra/clk.c
+++ b/drivers/clk/tegra/clk.c
@@@ -25,6 -74,165 +25,168 @@@
  static struct tegra_cpu_car_ops dummy_car_ops;
  struct tegra_cpu_car_ops *tegra_cpu_car_ops = &dummy_car_ops;
  
++<<<<<<< HEAD
++=======
+ int *periph_clk_enb_refcnt;
+ static int periph_banks;
+ static struct clk **clks;
+ static int clk_num;
+ static struct clk_onecell_data clk_data;
+ 
+ /* Handlers for SoC-specific reset lines */
+ static int (*special_reset_assert)(unsigned long);
+ static int (*special_reset_deassert)(unsigned long);
+ static unsigned int num_special_reset;
+ 
+ static const struct tegra_clk_periph_regs periph_regs[] = {
+ 	[0] = {
+ 		.enb_reg = CLK_OUT_ENB_L,
+ 		.enb_set_reg = CLK_OUT_ENB_SET_L,
+ 		.enb_clr_reg = CLK_OUT_ENB_CLR_L,
+ 		.rst_reg = RST_DEVICES_L,
+ 		.rst_set_reg = RST_DEVICES_SET_L,
+ 		.rst_clr_reg = RST_DEVICES_CLR_L,
+ 	},
+ 	[1] = {
+ 		.enb_reg = CLK_OUT_ENB_H,
+ 		.enb_set_reg = CLK_OUT_ENB_SET_H,
+ 		.enb_clr_reg = CLK_OUT_ENB_CLR_H,
+ 		.rst_reg = RST_DEVICES_H,
+ 		.rst_set_reg = RST_DEVICES_SET_H,
+ 		.rst_clr_reg = RST_DEVICES_CLR_H,
+ 	},
+ 	[2] = {
+ 		.enb_reg = CLK_OUT_ENB_U,
+ 		.enb_set_reg = CLK_OUT_ENB_SET_U,
+ 		.enb_clr_reg = CLK_OUT_ENB_CLR_U,
+ 		.rst_reg = RST_DEVICES_U,
+ 		.rst_set_reg = RST_DEVICES_SET_U,
+ 		.rst_clr_reg = RST_DEVICES_CLR_U,
+ 	},
+ 	[3] = {
+ 		.enb_reg = CLK_OUT_ENB_V,
+ 		.enb_set_reg = CLK_OUT_ENB_SET_V,
+ 		.enb_clr_reg = CLK_OUT_ENB_CLR_V,
+ 		.rst_reg = RST_DEVICES_V,
+ 		.rst_set_reg = RST_DEVICES_SET_V,
+ 		.rst_clr_reg = RST_DEVICES_CLR_V,
+ 	},
+ 	[4] = {
+ 		.enb_reg = CLK_OUT_ENB_W,
+ 		.enb_set_reg = CLK_OUT_ENB_SET_W,
+ 		.enb_clr_reg = CLK_OUT_ENB_CLR_W,
+ 		.rst_reg = RST_DEVICES_W,
+ 		.rst_set_reg = RST_DEVICES_SET_W,
+ 		.rst_clr_reg = RST_DEVICES_CLR_W,
+ 	},
+ 	[5] = {
+ 		.enb_reg = CLK_OUT_ENB_X,
+ 		.enb_set_reg = CLK_OUT_ENB_SET_X,
+ 		.enb_clr_reg = CLK_OUT_ENB_CLR_X,
+ 		.rst_reg = RST_DEVICES_X,
+ 		.rst_set_reg = RST_DEVICES_SET_X,
+ 		.rst_clr_reg = RST_DEVICES_CLR_X,
+ 	},
+ 	[6] = {
+ 		.enb_reg = CLK_OUT_ENB_Y,
+ 		.enb_set_reg = CLK_OUT_ENB_SET_Y,
+ 		.enb_clr_reg = CLK_OUT_ENB_CLR_Y,
+ 		.rst_reg = RST_DEVICES_Y,
+ 		.rst_set_reg = RST_DEVICES_SET_Y,
+ 		.rst_clr_reg = RST_DEVICES_CLR_Y,
+ 	},
+ };
+ 
+ static void __iomem *clk_base;
+ 
+ static int tegra_clk_rst_assert(struct reset_controller_dev *rcdev,
+ 		unsigned long id)
+ {
+ 	/*
+ 	 * If peripheral is on the APB bus then we must read the APB bus to
+ 	 * flush the write operation in apb bus. This will avoid peripheral
+ 	 * access after disabling clock. Since the reset driver has no
+ 	 * knowledge of which reset IDs represent which devices, simply do
+ 	 * this all the time.
+ 	 */
+ 	tegra_read_chipid();
+ 
+ 	if (id < periph_banks * 32) {
+ 		writel_relaxed(BIT(id % 32),
+ 			       clk_base + periph_regs[id / 32].rst_set_reg);
+ 		return 0;
+ 	} else if (id < periph_banks * 32 + num_special_reset) {
+ 		return special_reset_assert(id);
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ static int tegra_clk_rst_deassert(struct reset_controller_dev *rcdev,
+ 		unsigned long id)
+ {
+ 	if (id < periph_banks * 32) {
+ 		writel_relaxed(BIT(id % 32),
+ 			       clk_base + periph_regs[id / 32].rst_clr_reg);
+ 		return 0;
+ 	} else if (id < periph_banks * 32 + num_special_reset) {
+ 		return special_reset_deassert(id);
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ static int tegra_clk_rst_reset(struct reset_controller_dev *rcdev,
+ 		unsigned long id)
+ {
+ 	int err;
+ 
+ 	err = tegra_clk_rst_assert(rcdev, id);
+ 	if (err)
+ 		return err;
+ 
+ 	udelay(1);
+ 
+ 	return tegra_clk_rst_deassert(rcdev, id);
+ }
+ 
+ const struct tegra_clk_periph_regs *get_reg_bank(int clkid)
+ {
+ 	int reg_bank = clkid / 32;
+ 
+ 	if (reg_bank < periph_banks)
+ 		return &periph_regs[reg_bank];
+ 	else {
+ 		WARN_ON(1);
+ 		return NULL;
+ 	}
+ }
+ 
+ struct clk ** __init tegra_clk_init(void __iomem *regs, int num, int banks)
+ {
+ 	clk_base = regs;
+ 
+ 	if (WARN_ON(banks > ARRAY_SIZE(periph_regs)))
+ 		return NULL;
+ 
+ 	periph_clk_enb_refcnt = kcalloc(32 * banks,
+ 					sizeof(*periph_clk_enb_refcnt),
+ 					GFP_KERNEL);
+ 	if (!periph_clk_enb_refcnt)
+ 		return NULL;
+ 
+ 	periph_banks = banks;
+ 
+ 	clks = kcalloc(num, sizeof(struct clk *), GFP_KERNEL);
+ 	if (!clks)
+ 		kfree(periph_clk_enb_refcnt);
+ 
+ 	clk_num = num;
+ 
+ 	return clks;
+ }
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  void __init tegra_init_dup_clks(struct tegra_clk_duplicate *dup_list,
  				struct clk *clks[], int clk_max)
  {
diff --cc drivers/clocksource/sh_cmt.c
index f1979aa6a4bd,bbbf37c471a3..000000000000
--- a/drivers/clocksource/sh_cmt.c
+++ b/drivers/clocksource/sh_cmt.c
@@@ -673,104 -852,189 +673,114 @@@ static int sh_cmt_register(struct sh_cm
  	return 0;
  }
  
 -static int sh_cmt_setup_channel(struct sh_cmt_channel *ch, unsigned int index,
 -				unsigned int hwidx, bool clockevent,
 -				bool clocksource, struct sh_cmt_device *cmt)
 +static int sh_cmt_setup(struct sh_cmt_priv *p, struct platform_device *pdev)
  {
 -	int ret;
 +	struct sh_timer_config *cfg = pdev->dev.platform_data;
 +	struct resource *res;
 +	int irq, ret;
 +	ret = -ENXIO;
  
 -	/* Skip unused channels. */
 -	if (!clockevent && !clocksource)
 -		return 0;
 +	memset(p, 0, sizeof(*p));
 +	p->pdev = pdev;
  
 -	ch->cmt = cmt;
 -	ch->index = index;
 -	ch->hwidx = hwidx;
 -	ch->timer_bit = hwidx;
 -
 -	/*
 -	 * Compute the address of the channel control register block. For the
 -	 * timers with a per-channel start/stop register, compute its address
 -	 * as well.
 -	 */
 -	switch (cmt->info->model) {
 -	case SH_CMT_16BIT:
 -		ch->ioctrl = cmt->mapbase + 2 + ch->hwidx * 6;
 -		break;
 -	case SH_CMT_32BIT:
 -	case SH_CMT_48BIT:
 -		ch->ioctrl = cmt->mapbase + 0x10 + ch->hwidx * 0x10;
 -		break;
 -	case SH_CMT0_RCAR_GEN2:
 -	case SH_CMT1_RCAR_GEN2:
 -		ch->iostart = cmt->mapbase + ch->hwidx * 0x100;
 -		ch->ioctrl = ch->iostart + 0x10;
 -		ch->timer_bit = 0;
 -		break;
 +	if (!cfg) {
 +		dev_err(&p->pdev->dev, "missing platform data\n");
 +		goto err0;
  	}
  
 -	if (cmt->info->width == (sizeof(ch->max_match_value) * 8))
 -		ch->max_match_value = ~0;
 -	else
 -		ch->max_match_value = (1 << cmt->info->width) - 1;
 -
 -	ch->match_value = ch->max_match_value;
 -	raw_spin_lock_init(&ch->lock);
 -
 -	ret = sh_cmt_register(ch, dev_name(&cmt->pdev->dev),
 -			      clockevent, clocksource);
 -	if (ret) {
 -		dev_err(&cmt->pdev->dev, "ch%u: registration failed\n",
 -			ch->index);
 -		return ret;
 +	res = platform_get_resource(p->pdev, IORESOURCE_MEM, 0);
 +	if (!res) {
 +		dev_err(&p->pdev->dev, "failed to get I/O memory\n");
 +		goto err0;
  	}
 -	ch->cs_enabled = false;
  
 -	return 0;
 -}
 -
 -static int sh_cmt_map_memory(struct sh_cmt_device *cmt)
 -{
 -	struct resource *mem;
 -
 -	mem = platform_get_resource(cmt->pdev, IORESOURCE_MEM, 0);
 -	if (!mem) {
 -		dev_err(&cmt->pdev->dev, "failed to get I/O memory\n");
 -		return -ENXIO;
 +	irq = platform_get_irq(p->pdev, 0);
 +	if (irq < 0) {
 +		dev_err(&p->pdev->dev, "failed to get irq\n");
 +		goto err0;
  	}
  
 -	cmt->mapbase = ioremap_nocache(mem->start, resource_size(mem));
 -	if (cmt->mapbase == NULL) {
 -		dev_err(&cmt->pdev->dev, "failed to remap I/O memory\n");
 -		return -ENXIO;
 +	/* map memory, let mapbase point to our channel */
 +	p->mapbase = ioremap_nocache(res->start, resource_size(res));
 +	if (p->mapbase == NULL) {
 +		dev_err(&p->pdev->dev, "failed to remap I/O memory\n");
 +		goto err0;
  	}
  
 -	return 0;
 -}
 -
 -static const struct platform_device_id sh_cmt_id_table[] = {
 -	{ "sh-cmt-16", (kernel_ulong_t)&sh_cmt_info[SH_CMT_16BIT] },
 -	{ "sh-cmt-32", (kernel_ulong_t)&sh_cmt_info[SH_CMT_32BIT] },
 -	{ }
 -};
 -MODULE_DEVICE_TABLE(platform, sh_cmt_id_table);
 -
 -static const struct of_device_id sh_cmt_of_table[] __maybe_unused = {
 -	{ .compatible = "renesas,cmt-48", .data = &sh_cmt_info[SH_CMT_48BIT] },
 -	{
 -		/* deprecated, preserved for backward compatibility */
 -		.compatible = "renesas,cmt-48-gen2",
 -		.data = &sh_cmt_info[SH_CMT0_RCAR_GEN2]
 -	},
 -	{ .compatible = "renesas,rcar-gen2-cmt0", .data = &sh_cmt_info[SH_CMT0_RCAR_GEN2] },
 -	{ .compatible = "renesas,rcar-gen2-cmt1", .data = &sh_cmt_info[SH_CMT1_RCAR_GEN2] },
 -	{ }
 -};
 -MODULE_DEVICE_TABLE(of, sh_cmt_of_table);
 -
 -static int sh_cmt_setup(struct sh_cmt_device *cmt, struct platform_device *pdev)
 -{
 -	unsigned int mask;
 -	unsigned int i;
 -	int ret;
 -
 -	cmt->pdev = pdev;
 -	raw_spin_lock_init(&cmt->lock);
 +	/* request irq using setup_irq() (too early for request_irq()) */
 +	p->irqaction.name = dev_name(&p->pdev->dev);
 +	p->irqaction.handler = sh_cmt_interrupt;
 +	p->irqaction.dev_id = p;
 +	p->irqaction.flags = IRQF_DISABLED | IRQF_TIMER | \
 +			     IRQF_IRQPOLL  | IRQF_NOBALANCING;
 +
 +	/* get hold of clock */
 +	p->clk = clk_get(&p->pdev->dev, "cmt_fck");
 +	if (IS_ERR(p->clk)) {
 +		dev_err(&p->pdev->dev, "cannot get clock\n");
 +		ret = PTR_ERR(p->clk);
 +		goto err1;
 +	}
  
 -	if (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {
 -		cmt->info = of_device_get_match_data(&pdev->dev);
 -		cmt->hw_channels = cmt->info->channels_mask;
 -	} else if (pdev->dev.platform_data) {
 -		struct sh_timer_config *cfg = pdev->dev.platform_data;
 -		const struct platform_device_id *id = pdev->id_entry;
 +	p->read_control = sh_cmt_read16;
 +	p->write_control = sh_cmt_write16;
  
 -		cmt->info = (const struct sh_cmt_info *)id->driver_data;
 -		cmt->hw_channels = cfg->channels_mask;
 +	if (resource_size(res) == 6) {
 +		p->width = 16;
 +		p->read_count = sh_cmt_read16;
 +		p->write_count = sh_cmt_write16;
 +		p->overflow_bit = 0x80;
 +		p->clear_bits = ~0x80;
  	} else {
 -		dev_err(&cmt->pdev->dev, "missing platform data\n");
 -		return -ENXIO;
 -	}
 -
 -	/* Get hold of clock. */
 -	cmt->clk = clk_get(&cmt->pdev->dev, "fck");
 -	if (IS_ERR(cmt->clk)) {
 -		dev_err(&cmt->pdev->dev, "cannot get clock\n");
 -		return PTR_ERR(cmt->clk);
 +		p->width = 32;
 +		p->read_count = sh_cmt_read32;
 +		p->write_count = sh_cmt_write32;
 +		p->overflow_bit = 0x8000;
 +		p->clear_bits = ~0xc000;
  	}
  
 -	ret = clk_prepare(cmt->clk);
 -	if (ret < 0)
 -		goto err_clk_put;
 -
 -	/* Determine clock rate. */
 -	ret = clk_enable(cmt->clk);
 -	if (ret < 0)
 -		goto err_clk_unprepare;
 -
 -	if (cmt->info->width == 16)
 -		cmt->rate = clk_get_rate(cmt->clk) / 512;
 +	if (p->width == (sizeof(p->max_match_value) * 8))
 +		p->max_match_value = ~0;
  	else
 -		cmt->rate = clk_get_rate(cmt->clk) / 8;
 +		p->max_match_value = (1 << p->width) - 1;
  
 -	clk_disable(cmt->clk);
 +	p->match_value = p->max_match_value;
 +	raw_spin_lock_init(&p->lock);
  
 -	/* Map the memory resource(s). */
 -	ret = sh_cmt_map_memory(cmt);
 -	if (ret < 0)
 -		goto err_clk_unprepare;
 +	ret = sh_cmt_register(p, (char *)dev_name(&p->pdev->dev),
 +			      cfg->clockevent_rating,
 +			      cfg->clocksource_rating);
 +	if (ret) {
 +		dev_err(&p->pdev->dev, "registration failed\n");
 +		goto err2;
 +	}
 +	p->cs_enabled = false;
  
++<<<<<<< HEAD
 +	ret = setup_irq(irq, &p->irqaction);
 +	if (ret) {
 +		dev_err(&p->pdev->dev, "failed to request irq %d\n", irq);
 +		goto err2;
++=======
+ 	/* Allocate and setup the channels. */
+ 	cmt->num_channels = hweight8(cmt->hw_channels);
+ 	cmt->channels = kcalloc(cmt->num_channels, sizeof(*cmt->channels),
+ 				GFP_KERNEL);
+ 	if (cmt->channels == NULL) {
+ 		ret = -ENOMEM;
+ 		goto err_unmap;
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	}
  
 -	/*
 -	 * Use the first channel as a clock event device and the second channel
 -	 * as a clock source. If only one channel is available use it for both.
 -	 */
 -	for (i = 0, mask = cmt->hw_channels; i < cmt->num_channels; ++i) {
 -		unsigned int hwidx = ffs(mask) - 1;
 -		bool clocksource = i == 1 || cmt->num_channels == 1;
 -		bool clockevent = i == 0;
 -
 -		ret = sh_cmt_setup_channel(&cmt->channels[i], i, hwidx,
 -					   clockevent, clocksource, cmt);
 -		if (ret < 0)
 -			goto err_unmap;
 -
 -		mask &= ~(1 << hwidx);
 -	}
 -
 -	platform_set_drvdata(pdev, cmt);
 +	platform_set_drvdata(pdev, p);
  
  	return 0;
 +err2:
 +	clk_put(p->clk);
  
 -err_unmap:
 -	kfree(cmt->channels);
 -	iounmap(cmt->mapbase);
 -err_clk_unprepare:
 -	clk_unprepare(cmt->clk);
 -err_clk_put:
 -	clk_put(cmt->clk);
 +err1:
 +	iounmap(p->mapbase);
 +err0:
  	return ret;
  }
  
diff --cc drivers/clocksource/sh_mtu2.c
index 4aac9ee0d0c0,6812e099b6a3..000000000000
--- a/drivers/clocksource/sh_mtu2.c
+++ b/drivers/clocksource/sh_mtu2.c
@@@ -261,63 -336,112 +261,71 @@@ static int sh_mtu2_register(struct sh_m
  	return 0;
  }
  
 -static int sh_mtu2_setup_channel(struct sh_mtu2_channel *ch, unsigned int index,
 -				 struct sh_mtu2_device *mtu)
 +static int sh_mtu2_setup(struct sh_mtu2_priv *p, struct platform_device *pdev)
  {
 -	static const unsigned int channel_offsets[] = {
 -		0x300, 0x380, 0x000,
 -	};
 -	char name[6];
 -	int irq;
 -	int ret;
 -
 -	ch->mtu = mtu;
 +	struct sh_timer_config *cfg = pdev->dev.platform_data;
 +	struct resource *res;
 +	int irq, ret;
 +	ret = -ENXIO;
  
 -	sprintf(name, "tgi%ua", index);
 -	irq = platform_get_irq_byname(mtu->pdev, name);
 -	if (irq < 0) {
 -		/* Skip channels with no declared interrupt. */
 -		return 0;
 -	}
 +	memset(p, 0, sizeof(*p));
 +	p->pdev = pdev;
  
 -	ret = request_irq(irq, sh_mtu2_interrupt,
 -			  IRQF_TIMER | IRQF_IRQPOLL | IRQF_NOBALANCING,
 -			  dev_name(&ch->mtu->pdev->dev), ch);
 -	if (ret) {
 -		dev_err(&ch->mtu->pdev->dev, "ch%u: failed to request irq %d\n",
 -			index, irq);
 -		return ret;
 +	if (!cfg) {
 +		dev_err(&p->pdev->dev, "missing platform data\n");
 +		goto err0;
  	}
  
 -	ch->base = mtu->mapbase + channel_offsets[index];
 -	ch->index = index;
 -
 -	return sh_mtu2_register(ch, dev_name(&mtu->pdev->dev));
 -}
 -
 -static int sh_mtu2_map_memory(struct sh_mtu2_device *mtu)
 -{
 -	struct resource *res;
 +	platform_set_drvdata(pdev, p);
  
 -	res = platform_get_resource(mtu->pdev, IORESOURCE_MEM, 0);
 +	res = platform_get_resource(p->pdev, IORESOURCE_MEM, 0);
  	if (!res) {
 -		dev_err(&mtu->pdev->dev, "failed to get I/O memory\n");
 -		return -ENXIO;
 +		dev_err(&p->pdev->dev, "failed to get I/O memory\n");
 +		goto err0;
  	}
  
 -	mtu->mapbase = ioremap_nocache(res->start, resource_size(res));
 -	if (mtu->mapbase == NULL)
 -		return -ENXIO;
 -
 -	return 0;
 -}
 -
 -static int sh_mtu2_setup(struct sh_mtu2_device *mtu,
 -			 struct platform_device *pdev)
 -{
 -	unsigned int i;
 -	int ret;
 -
 -	mtu->pdev = pdev;
 -
 -	raw_spin_lock_init(&mtu->lock);
 -
 -	/* Get hold of clock. */
 -	mtu->clk = clk_get(&mtu->pdev->dev, "fck");
 -	if (IS_ERR(mtu->clk)) {
 -		dev_err(&mtu->pdev->dev, "cannot get clock\n");
 -		return PTR_ERR(mtu->clk);
 +	irq = platform_get_irq(p->pdev, 0);
 +	if (irq < 0) {
 +		dev_err(&p->pdev->dev, "failed to get irq\n");
 +		goto err0;
  	}
  
 -	ret = clk_prepare(mtu->clk);
 -	if (ret < 0)
 -		goto err_clk_put;
 -
 -	/* Map the memory resource. */
 -	ret = sh_mtu2_map_memory(mtu);
 -	if (ret < 0) {
 -		dev_err(&mtu->pdev->dev, "failed to remap I/O memory\n");
 -		goto err_clk_unprepare;
 +	/* map memory, let mapbase point to our channel */
 +	p->mapbase = ioremap_nocache(res->start, resource_size(res));
 +	if (p->mapbase == NULL) {
 +		dev_err(&p->pdev->dev, "failed to remap I/O memory\n");
 +		goto err0;
  	}
  
 -	/* Allocate and setup the channels. */
 -	mtu->num_channels = 3;
 -
 +	/* setup data for setup_irq() (too early for request_irq()) */
 +	p->irqaction.name = dev_name(&p->pdev->dev);
 +	p->irqaction.handler = sh_mtu2_interrupt;
 +	p->irqaction.dev_id = p;
 +	p->irqaction.irq = irq;
 +	p->irqaction.flags = IRQF_DISABLED | IRQF_TIMER | \
 +			     IRQF_IRQPOLL  | IRQF_NOBALANCING;
 +
++<<<<<<< HEAD
 +	/* get hold of clock */
 +	p->clk = clk_get(&p->pdev->dev, "mtu2_fck");
 +	if (IS_ERR(p->clk)) {
 +		dev_err(&p->pdev->dev, "cannot get clock\n");
 +		ret = PTR_ERR(p->clk);
 +		goto err1;
++=======
+ 	mtu->channels = kcalloc(mtu->num_channels, sizeof(*mtu->channels),
+ 				GFP_KERNEL);
+ 	if (mtu->channels == NULL) {
+ 		ret = -ENOMEM;
+ 		goto err_unmap;
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	}
  
 -	for (i = 0; i < mtu->num_channels; ++i) {
 -		ret = sh_mtu2_setup_channel(&mtu->channels[i], i, mtu);
 -		if (ret < 0)
 -			goto err_unmap;
 -	}
 -
 -	platform_set_drvdata(pdev, mtu);
 -
 -	return 0;
 -
 -err_unmap:
 -	kfree(mtu->channels);
 -	iounmap(mtu->mapbase);
 -err_clk_unprepare:
 -	clk_unprepare(mtu->clk);
 -err_clk_put:
 -	clk_put(mtu->clk);
 +	return sh_mtu2_register(p, (char *)dev_name(&p->pdev->dev),
 +				cfg->clockevent_rating);
 + err1:
 +	iounmap(p->mapbase);
 + err0:
  	return ret;
  }
  
diff --cc drivers/clocksource/sh_tmu.c
index 57aefd7b9459,c74a6c543ca2..000000000000
--- a/drivers/clocksource/sh_tmu.c
+++ b/drivers/clocksource/sh_tmu.c
@@@ -421,66 -453,151 +421,118 @@@ static int sh_tmu_register(struct sh_tm
  	return 0;
  }
  
 -static int sh_tmu_channel_setup(struct sh_tmu_channel *ch, unsigned int index,
 -				bool clockevent, bool clocksource,
 -				struct sh_tmu_device *tmu)
 +static int sh_tmu_setup(struct sh_tmu_priv *p, struct platform_device *pdev)
  {
 -	/* Skip unused channels. */
 -	if (!clockevent && !clocksource)
 -		return 0;
 -
 -	ch->tmu = tmu;
 -	ch->index = index;
 +	struct sh_timer_config *cfg = pdev->dev.platform_data;
 +	struct resource *res;
 +	int irq, ret;
 +	ret = -ENXIO;
  
 -	if (tmu->model == SH_TMU_SH3)
 -		ch->base = tmu->mapbase + 4 + ch->index * 12;
 -	else
 -		ch->base = tmu->mapbase + 8 + ch->index * 12;
 +	memset(p, 0, sizeof(*p));
 +	p->pdev = pdev;
  
 -	ch->irq = platform_get_irq(tmu->pdev, index);
 -	if (ch->irq < 0) {
 -		dev_err(&tmu->pdev->dev, "ch%u: failed to get irq\n",
 -			ch->index);
 -		return ch->irq;
 +	if (!cfg) {
 +		dev_err(&p->pdev->dev, "missing platform data\n");
 +		goto err0;
  	}
  
 -	ch->cs_enabled = false;
 -	ch->enable_count = 0;
 -
 -	return sh_tmu_register(ch, dev_name(&tmu->pdev->dev),
 -			       clockevent, clocksource);
 -}
 -
 -static int sh_tmu_map_memory(struct sh_tmu_device *tmu)
 -{
 -	struct resource *res;
 +	platform_set_drvdata(pdev, p);
  
 -	res = platform_get_resource(tmu->pdev, IORESOURCE_MEM, 0);
 +	res = platform_get_resource(p->pdev, IORESOURCE_MEM, 0);
  	if (!res) {
 -		dev_err(&tmu->pdev->dev, "failed to get I/O memory\n");
 -		return -ENXIO;
 +		dev_err(&p->pdev->dev, "failed to get I/O memory\n");
 +		goto err0;
  	}
  
 -	tmu->mapbase = ioremap_nocache(res->start, resource_size(res));
 -	if (tmu->mapbase == NULL)
 -		return -ENXIO;
 -
 -	return 0;
 -}
 -
 -static int sh_tmu_parse_dt(struct sh_tmu_device *tmu)
 -{
 -	struct device_node *np = tmu->pdev->dev.of_node;
 -
 -	tmu->model = SH_TMU;
 -	tmu->num_channels = 3;
 -
 -	of_property_read_u32(np, "#renesas,channels", &tmu->num_channels);
 -
 -	if (tmu->num_channels != 2 && tmu->num_channels != 3) {
 -		dev_err(&tmu->pdev->dev, "invalid number of channels %u\n",
 -			tmu->num_channels);
 -		return -EINVAL;
 +	irq = platform_get_irq(p->pdev, 0);
 +	if (irq < 0) {
 +		dev_err(&p->pdev->dev, "failed to get irq\n");
 +		goto err0;
  	}
  
 -	return 0;
 -}
 -
 -static int sh_tmu_setup(struct sh_tmu_device *tmu, struct platform_device *pdev)
 -{
 -	unsigned int i;
 -	int ret;
 -
 -	tmu->pdev = pdev;
 -
 -	raw_spin_lock_init(&tmu->lock);
 -
 -	if (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {
 -		ret = sh_tmu_parse_dt(tmu);
 -		if (ret < 0)
 -			return ret;
 -	} else if (pdev->dev.platform_data) {
 -		const struct platform_device_id *id = pdev->id_entry;
 -		struct sh_timer_config *cfg = pdev->dev.platform_data;
 -
 -		tmu->model = id->driver_data;
 -		tmu->num_channels = hweight8(cfg->channels_mask);
 -	} else {
 -		dev_err(&tmu->pdev->dev, "missing platform data\n");
 -		return -ENXIO;
 +	/* map memory, let mapbase point to our channel */
 +	p->mapbase = ioremap_nocache(res->start, resource_size(res));
 +	if (p->mapbase == NULL) {
 +		dev_err(&p->pdev->dev, "failed to remap I/O memory\n");
 +		goto err0;
  	}
  
 -	/* Get hold of clock. */
 -	tmu->clk = clk_get(&tmu->pdev->dev, "fck");
 -	if (IS_ERR(tmu->clk)) {
 -		dev_err(&tmu->pdev->dev, "cannot get clock\n");
 -		return PTR_ERR(tmu->clk);
 +	/* setup data for setup_irq() (too early for request_irq()) */
 +	p->irqaction.name = dev_name(&p->pdev->dev);
 +	p->irqaction.handler = sh_tmu_interrupt;
 +	p->irqaction.dev_id = p;
 +	p->irqaction.irq = irq;
 +	p->irqaction.flags = IRQF_DISABLED | IRQF_TIMER | \
 +			     IRQF_IRQPOLL  | IRQF_NOBALANCING;
 +
 +	/* get hold of clock */
 +	p->clk = clk_get(&p->pdev->dev, "tmu_fck");
 +	if (IS_ERR(p->clk)) {
 +		dev_err(&p->pdev->dev, "cannot get clock\n");
 +		ret = PTR_ERR(p->clk);
 +		goto err1;
  	}
 -
 +	p->cs_enabled = false;
 +	p->enable_count = 0;
 +
++<<<<<<< HEAD
 +	return sh_tmu_register(p, (char *)dev_name(&p->pdev->dev),
 +			       cfg->clockevent_rating,
 +			       cfg->clocksource_rating);
 + err1:
 +	iounmap(p->mapbase);
 + err0:
++=======
+ 	ret = clk_prepare(tmu->clk);
+ 	if (ret < 0)
+ 		goto err_clk_put;
+ 
+ 	/* Determine clock rate. */
+ 	ret = clk_enable(tmu->clk);
+ 	if (ret < 0)
+ 		goto err_clk_unprepare;
+ 
+ 	tmu->rate = clk_get_rate(tmu->clk) / 4;
+ 	clk_disable(tmu->clk);
+ 
+ 	/* Map the memory resource. */
+ 	ret = sh_tmu_map_memory(tmu);
+ 	if (ret < 0) {
+ 		dev_err(&tmu->pdev->dev, "failed to remap I/O memory\n");
+ 		goto err_clk_unprepare;
+ 	}
+ 
+ 	/* Allocate and setup the channels. */
+ 	tmu->channels = kcalloc(tmu->num_channels, sizeof(*tmu->channels),
+ 				GFP_KERNEL);
+ 	if (tmu->channels == NULL) {
+ 		ret = -ENOMEM;
+ 		goto err_unmap;
+ 	}
+ 
+ 	/*
+ 	 * Use the first channel as a clock event device and the second channel
+ 	 * as a clock source.
+ 	 */
+ 	for (i = 0; i < tmu->num_channels; ++i) {
+ 		ret = sh_tmu_channel_setup(&tmu->channels[i], i,
+ 					   i == 0, i == 1, tmu);
+ 		if (ret < 0)
+ 			goto err_unmap;
+ 	}
+ 
+ 	platform_set_drvdata(pdev, tmu);
+ 
+ 	return 0;
+ 
+ err_unmap:
+ 	kfree(tmu->channels);
+ 	iounmap(tmu->mapbase);
+ err_clk_unprepare:
+ 	clk_unprepare(tmu->clk);
+ err_clk_put:
+ 	clk_put(tmu->clk);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	return ret;
  }
  
diff --cc drivers/cpufreq/acpi-cpufreq.c
index b38f5d963599,8ff1c9123834..000000000000
--- a/drivers/cpufreq/acpi-cpufreq.c
+++ b/drivers/cpufreq/acpi-cpufreq.c
@@@ -770,9 -759,9 +770,15 @@@ static int acpi_cpufreq_cpu_init(struc
  		goto err_unreg;
  	}
  
++<<<<<<< HEAD
 +	data->freq_table = kzalloc(sizeof(*data->freq_table) *
 +		    (perf->state_count+1), GFP_KERNEL);
 +	if (!data->freq_table) {
++=======
+ 	freq_table = kcalloc(perf->state_count + 1, sizeof(*freq_table),
+ 			     GFP_KERNEL);
+ 	if (!freq_table) {
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		result = -ENOMEM;
  		goto err_unreg;
  	}
diff --cc drivers/cpufreq/arm_big_little.c
index 5d7f53fcd6f5,cf62a1f64dd7..000000000000
--- a/drivers/cpufreq/arm_big_little.c
+++ b/drivers/cpufreq/arm_big_little.c
@@@ -94,27 -240,123 +94,113 @@@ static int bL_cpufreq_set_target(struc
  	return ret;
  }
  
++<<<<<<< HEAD
 +static void put_cluster_clk_and_freq_table(struct device *cpu_dev)
++=======
+ static inline u32 get_table_count(struct cpufreq_frequency_table *table)
+ {
+ 	int count;
+ 
+ 	for (count = 0; table[count].frequency != CPUFREQ_TABLE_END; count++)
+ 		;
+ 
+ 	return count;
+ }
+ 
+ /* get the minimum frequency in the cpufreq_frequency_table */
+ static inline u32 get_table_min(struct cpufreq_frequency_table *table)
+ {
+ 	struct cpufreq_frequency_table *pos;
+ 	uint32_t min_freq = ~0;
+ 	cpufreq_for_each_entry(pos, table)
+ 		if (pos->frequency < min_freq)
+ 			min_freq = pos->frequency;
+ 	return min_freq;
+ }
+ 
+ /* get the maximum frequency in the cpufreq_frequency_table */
+ static inline u32 get_table_max(struct cpufreq_frequency_table *table)
+ {
+ 	struct cpufreq_frequency_table *pos;
+ 	uint32_t max_freq = 0;
+ 	cpufreq_for_each_entry(pos, table)
+ 		if (pos->frequency > max_freq)
+ 			max_freq = pos->frequency;
+ 	return max_freq;
+ }
+ 
+ static int merge_cluster_tables(void)
+ {
+ 	int i, j, k = 0, count = 1;
+ 	struct cpufreq_frequency_table *table;
+ 
+ 	for (i = 0; i < MAX_CLUSTERS; i++)
+ 		count += get_table_count(freq_table[i]);
+ 
+ 	table = kcalloc(count, sizeof(*table), GFP_KERNEL);
+ 	if (!table)
+ 		return -ENOMEM;
+ 
+ 	freq_table[MAX_CLUSTERS] = table;
+ 
+ 	/* Add in reverse order to get freqs in increasing order */
+ 	for (i = MAX_CLUSTERS - 1; i >= 0; i--) {
+ 		for (j = 0; freq_table[i][j].frequency != CPUFREQ_TABLE_END;
+ 				j++) {
+ 			table[k].frequency = VIRT_FREQ(i,
+ 					freq_table[i][j].frequency);
+ 			pr_debug("%s: index: %d, freq: %d\n", __func__, k,
+ 					table[k].frequency);
+ 			k++;
+ 		}
+ 	}
+ 
+ 	table[k].driver_data = k;
+ 	table[k].frequency = CPUFREQ_TABLE_END;
+ 
+ 	pr_debug("%s: End, table: %p, count: %d\n", __func__, table, k);
+ 
+ 	return 0;
+ }
+ 
+ static void _put_cluster_clk_and_freq_table(struct device *cpu_dev,
+ 					    const struct cpumask *cpumask)
+ {
+ 	u32 cluster = raw_cpu_to_cluster(cpu_dev->id);
+ 
+ 	if (!freq_table[cluster])
+ 		return;
+ 
+ 	clk_put(clk[cluster]);
+ 	dev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table[cluster]);
+ 	if (arm_bL_ops->free_opp_table)
+ 		arm_bL_ops->free_opp_table(cpumask);
+ 	dev_dbg(cpu_dev, "%s: cluster: %d\n", __func__, cluster);
+ }
+ 
+ static void put_cluster_clk_and_freq_table(struct device *cpu_dev,
+ 					   const struct cpumask *cpumask)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  {
  	u32 cluster = cpu_to_cluster(cpu_dev->id);
 -	int i;
 -
 -	if (atomic_dec_return(&cluster_usage[cluster]))
 -		return;
 -
 -	if (cluster < MAX_CLUSTERS)
 -		return _put_cluster_clk_and_freq_table(cpu_dev, cpumask);
 -
 -	for_each_present_cpu(i) {
 -		struct device *cdev = get_cpu_device(i);
 -		if (!cdev) {
 -			pr_err("%s: failed to get cpu%d device\n", __func__, i);
 -			return;
 -		}
  
 -		_put_cluster_clk_and_freq_table(cdev, cpumask);
 +	if (!atomic_dec_return(&cluster_usage[cluster])) {
 +		clk_put(clk[cluster]);
 +		opp_free_cpufreq_table(cpu_dev, &freq_table[cluster]);
 +		dev_dbg(cpu_dev, "%s: cluster: %d\n", __func__, cluster);
  	}
 -
 -	/* free virtual table */
 -	kfree(freq_table[cluster]);
  }
  
 -static int _get_cluster_clk_and_freq_table(struct device *cpu_dev,
 -					   const struct cpumask *cpumask)
 +static int get_cluster_clk_and_freq_table(struct device *cpu_dev)
  {
 -	u32 cluster = raw_cpu_to_cluster(cpu_dev->id);
 +	u32 cluster = cpu_to_cluster(cpu_dev->id);
 +	char name[14] = "cpu-cluster.";
  	int ret;
  
 -	if (freq_table[cluster])
 +	if (atomic_inc_return(&cluster_usage[cluster]) != 1)
  		return 0;
  
 -	ret = arm_bL_ops->init_opp_table(cpumask);
 +	ret = arm_bL_ops->init_opp_table(cpu_dev);
  	if (ret) {
  		dev_err(cpu_dev, "%s: init_opp_table failed, cpu: %d, err: %d\n",
  				__func__, cpu_dev->id, ret);
diff --cc drivers/cpufreq/ia64-acpi-cpufreq.c
index c0075dbaa633,dd5440d3372d..000000000000
--- a/drivers/cpufreq/ia64-acpi-cpufreq.c
+++ b/drivers/cpufreq/ia64-acpi-cpufreq.c
@@@ -304,10 -241,10 +304,15 @@@ acpi_cpufreq_cpu_init 
  	}
  
  	/* alloc freq_table */
++<<<<<<< HEAD
 +	data->freq_table = kmalloc(sizeof(struct cpufreq_frequency_table) *
 +	                           (data->acpi_data.state_count + 1),
++=======
+ 	freq_table = kcalloc(data->acpi_data.state_count + 1,
+ 	                           sizeof(*freq_table),
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	                           GFP_KERNEL);
 -	if (!freq_table) {
 +	if (!data->freq_table) {
  		result = -ENOMEM;
  		goto err_unreg;
  	}
diff --cc drivers/cpufreq/longhaul.c
index 51a0420c0c78,279bd9e9fa95..000000000000
--- a/drivers/cpufreq/longhaul.c
+++ b/drivers/cpufreq/longhaul.c
@@@ -475,8 -474,8 +475,13 @@@ static int longhaul_get_ranges(void
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	longhaul_table = kmalloc((numscales + 1) * sizeof(*longhaul_table),
 +			GFP_KERNEL);
++=======
+ 	longhaul_table = kcalloc(numscales + 1, sizeof(*longhaul_table),
+ 				 GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!longhaul_table)
  		return -ENOMEM;
  
diff --cc drivers/cpufreq/spear-cpufreq.c
index 156829f4576d,4074e2615522..000000000000
--- a/drivers/cpufreq/spear-cpufreq.c
+++ b/drivers/cpufreq/spear-cpufreq.c
@@@ -243,7 -195,7 +243,11 @@@ static int spear_cpufreq_driver_init(vo
  	cnt = prop->length / sizeof(u32);
  	val = prop->value;
  
++<<<<<<< HEAD
 +	freq_tbl = kmalloc(sizeof(*freq_tbl) * (cnt + 1), GFP_KERNEL);
++=======
+ 	freq_tbl = kcalloc(cnt + 1, sizeof(*freq_tbl), GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!freq_tbl) {
  		ret = -ENOMEM;
  		goto out_put_node;
diff --cc drivers/crypto/amcc/crypto4xx_core.c
index 172bdb74aed2,05981ccd9901..000000000000
--- a/drivers/crypto/amcc/crypto4xx_core.c
+++ b/drivers/crypto/amcc/crypto4xx_core.c
@@@ -126,17 -141,14 +126,25 @@@ static void crypto4xx_hw_init(struct cr
  
  int crypto4xx_alloc_sa(struct crypto4xx_ctx *ctx, u32 size)
  {
++<<<<<<< HEAD
 +	ctx->sa_in = dma_alloc_coherent(ctx->dev->core_dev->device, size * 4,
 +					&ctx->sa_in_dma_addr, GFP_ATOMIC);
 +	if (ctx->sa_in == NULL)
 +		return -ENOMEM;
 +
 +	ctx->sa_out = dma_alloc_coherent(ctx->dev->core_dev->device, size * 4,
 +					 &ctx->sa_out_dma_addr, GFP_ATOMIC);
++=======
+ 	ctx->sa_in = kcalloc(size, 4, GFP_ATOMIC);
+ 	if (ctx->sa_in == NULL)
+ 		return -ENOMEM;
+ 
+ 	ctx->sa_out = kcalloc(size, 4, GFP_ATOMIC);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (ctx->sa_out == NULL) {
 -		kfree(ctx->sa_in);
 -		ctx->sa_in = NULL;
 +		dma_free_coherent(ctx->dev->core_dev->device,
 +				  ctx->sa_len * 4,
 +				  ctx->sa_in, ctx->sa_in_dma_addr);
  		return -ENOMEM;
  	}
  
diff --cc drivers/dma/mv_xor.c
index 7c522ab6433a,969534c1a6c6..000000000000
--- a/drivers/dma/mv_xor.c
+++ b/drivers/dma/mv_xor.c
@@@ -910,7 -781,7 +910,11 @@@ static int mv_xor_memcpy_self_test(stru
  	if (!src)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	dest = kzalloc(sizeof(u8) * MV_XOR_TEST_SIZE, GFP_KERNEL);
++=======
+ 	dest = kzalloc(PAGE_SIZE, GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!dest) {
  		kfree(src);
  		return -ENOMEM;
diff --cc drivers/dma/pl330.c
index 4c2f465be339,defcdde4d358..000000000000
--- a/drivers/dma/pl330.c
+++ b/drivers/dma/pl330.c
@@@ -2972,15 -2986,13 +2972,22 @@@ pl330_probe(struct amba_device *adev, c
  	INIT_LIST_HEAD(&pd->channels);
  
  	/* Initialize channel parameters */
 -	num_chan = max_t(int, pcfg->num_peri, pcfg->num_chan);
 +	if (pdat)
 +		num_chan = max_t(int, pdat->nr_valid_peri, pi->pcfg.num_chan);
 +	else
 +		num_chan = max_t(int, pi->pcfg.num_peri, pi->pcfg.num_chan);
  
++<<<<<<< HEAD
 +	pdmac->peripherals = kzalloc(num_chan * sizeof(*pch), GFP_KERNEL);
 +	if (!pdmac->peripherals) {
++=======
+ 	pl330->num_peripherals = num_chan;
+ 
+ 	pl330->peripherals = kcalloc(num_chan, sizeof(*pch), GFP_KERNEL);
+ 	if (!pl330->peripherals) {
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		ret = -ENOMEM;
 +		dev_err(&adev->dev, "unable to allocate pdmac->peripherals\n");
  		goto probe_err2;
  	}
  
diff --cc drivers/edac/amd64_edac.c
index ecb3952b2828,18aeabb1d5ee..000000000000
--- a/drivers/edac/amd64_edac.c
+++ b/drivers/edac/amd64_edac.c
@@@ -3450,17 -3437,22 +3450,22 @@@ static int __init amd64_edac_init(void
  	int err = -ENODEV;
  	int i;
  
 -	owner = edac_get_owner();
 -	if (owner && strncmp(owner, EDAC_MOD_STR, sizeof(EDAC_MOD_STR)))
 -		return -EBUSY;
 +	printk(KERN_INFO "AMD64 EDAC driver v%s\n", EDAC_AMD64_VERSION);
  
 -	if (!x86_match_cpu(amd64_cpuids))
 -		return -ENODEV;
 +	opstate_init();
  
  	if (amd_cache_northbridges() < 0)
 -		return -ENODEV;
 -
 -	opstate_init();
 +		goto err_ret;
  
  	err = -ENOMEM;
++<<<<<<< HEAD
 +	mcis	  = kzalloc(amd_nb_num() * sizeof(mcis[0]), GFP_KERNEL);
 +	ecc_stngs = kzalloc(amd_nb_num() * sizeof(ecc_stngs[0]), GFP_KERNEL);
 +	if (!(mcis && ecc_stngs))
++=======
+ 	ecc_stngs = kcalloc(amd_nb_num(), sizeof(ecc_stngs[0]), GFP_KERNEL);
+ 	if (!ecc_stngs)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		goto err_free;
  
  	msrs = msrs_alloc();
diff --cc drivers/firmware/efi/runtime-map.c
index 018c29a26615,84a11d0a8023..000000000000
--- a/drivers/firmware/efi/runtime-map.c
+++ b/drivers/firmware/efi/runtime-map.c
@@@ -170,11 -161,12 +170,15 @@@ int __init efi_runtime_map_init(struct 
  {
  	int i, j, ret = 0;
  	struct efi_runtime_map_entry *entry;
 -	efi_memory_desc_t *md;
  
 -	if (!efi_enabled(EFI_MEMMAP))
 +	if (!efi_runtime_map)
  		return 0;
  
++<<<<<<< HEAD
 +	map_entries = kzalloc(nr_efi_runtime_map * sizeof(entry), GFP_KERNEL);
++=======
+ 	map_entries = kcalloc(efi.memmap.nr_map, sizeof(entry), GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!map_entries) {
  		ret = -ENOMEM;
  		goto out;
diff --cc drivers/gpu/drm/amd/display/modules/color/color_gamma.c
index b3747a019deb,2533274e9cef..000000000000
--- a/drivers/gpu/drm/amd/display/modules/color/color_gamma.c
+++ b/drivers/gpu/drm/amd/display/modules/color/color_gamma.c
@@@ -1168,6 -1349,115 +1168,118 @@@ rgb_user_alloc_fail
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ bool calculate_user_regamma_coeff(struct dc_transfer_func *output_tf,
+ 		const struct regamma_lut *regamma)
+ {
+ 	struct gamma_coefficients coeff;
+ 	const struct hw_x_point *coord_x = coordinates_x;
+ 	uint32_t i = 0;
+ 
+ 	do {
+ 		coeff.a0[i] = dc_fixpt_from_fraction(
+ 				regamma->coeff.A0[i], 10000000);
+ 		coeff.a1[i] = dc_fixpt_from_fraction(
+ 				regamma->coeff.A1[i], 1000);
+ 		coeff.a2[i] = dc_fixpt_from_fraction(
+ 				regamma->coeff.A2[i], 1000);
+ 		coeff.a3[i] = dc_fixpt_from_fraction(
+ 				regamma->coeff.A3[i], 1000);
+ 		coeff.user_gamma[i] = dc_fixpt_from_fraction(
+ 				regamma->coeff.gamma[i], 1000);
+ 
+ 		++i;
+ 	} while (i != 3);
+ 
+ 	i = 0;
+ 	/* fixed_pt library has problems handling too small values */
+ 	while (i != 32) {
+ 		output_tf->tf_pts.red[i] = dc_fixpt_zero;
+ 		output_tf->tf_pts.green[i] = dc_fixpt_zero;
+ 		output_tf->tf_pts.blue[i] = dc_fixpt_zero;
+ 		++coord_x;
+ 		++i;
+ 	}
+ 	while (i != MAX_HW_POINTS + 1) {
+ 		output_tf->tf_pts.red[i] = translate_from_linear_space_ex(
+ 				coord_x->x, &coeff, 0);
+ 		output_tf->tf_pts.green[i] = translate_from_linear_space_ex(
+ 				coord_x->x, &coeff, 1);
+ 		output_tf->tf_pts.blue[i] = translate_from_linear_space_ex(
+ 				coord_x->x, &coeff, 2);
+ 		++coord_x;
+ 		++i;
+ 	}
+ 
+ 	// this function just clamps output to 0-1
+ 	build_new_custom_resulted_curve(MAX_HW_POINTS, &output_tf->tf_pts);
+ 	output_tf->type = TF_TYPE_DISTRIBUTED_POINTS;
+ 
+ 	return true;
+ }
+ 
+ bool calculate_user_regamma_ramp(struct dc_transfer_func *output_tf,
+ 		const struct regamma_lut *regamma)
+ {
+ 	struct dc_transfer_func_distributed_points *tf_pts = &output_tf->tf_pts;
+ 	struct dividers dividers;
+ 
+ 	struct pwl_float_data *rgb_user = NULL;
+ 	struct pwl_float_data_ex *rgb_regamma = NULL;
+ 	bool ret = false;
+ 
+ 	if (regamma == NULL)
+ 		return false;
+ 
+ 	output_tf->type = TF_TYPE_DISTRIBUTED_POINTS;
+ 
+ 	rgb_user = kcalloc(GAMMA_RGB_256_ENTRIES + _EXTRA_POINTS,
+ 			   sizeof(*rgb_user),
+ 			   GFP_KERNEL);
+ 	if (!rgb_user)
+ 		goto rgb_user_alloc_fail;
+ 
+ 	rgb_regamma = kcalloc(MAX_HW_POINTS + _EXTRA_POINTS,
+ 			      sizeof(*rgb_regamma),
+ 			      GFP_KERNEL);
+ 	if (!rgb_regamma)
+ 		goto rgb_regamma_alloc_fail;
+ 
+ 	dividers.divider1 = dc_fixpt_from_fraction(3, 2);
+ 	dividers.divider2 = dc_fixpt_from_int(2);
+ 	dividers.divider3 = dc_fixpt_from_fraction(5, 2);
+ 
+ 	scale_user_regamma_ramp(rgb_user, &regamma->ramp, dividers);
+ 
+ 	if (regamma->flags.bits.applyDegamma == 1) {
+ 		apply_degamma_for_user_regamma(rgb_regamma, MAX_HW_POINTS);
+ 		copy_rgb_regamma_to_coordinates_x(coordinates_x,
+ 				MAX_HW_POINTS, rgb_regamma);
+ 	}
+ 
+ 	interpolate_user_regamma(MAX_HW_POINTS, rgb_user,
+ 			regamma->flags.bits.applyDegamma, tf_pts);
+ 
+ 	// no custom HDR curves!
+ 	tf_pts->end_exponent = 0;
+ 	tf_pts->x_point_at_y1_red = 1;
+ 	tf_pts->x_point_at_y1_green = 1;
+ 	tf_pts->x_point_at_y1_blue = 1;
+ 
+ 	// this function just clamps output to 0-1
+ 	build_new_custom_resulted_curve(MAX_HW_POINTS, tf_pts);
+ 
+ 	ret = true;
+ 
+ 	kfree(rgb_regamma);
+ rgb_regamma_alloc_fail:
+ 	kvfree(rgb_user);
+ rgb_user_alloc_fail:
+ 	return ret;
+ }
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  bool mod_color_calculate_degamma_params(struct dc_transfer_func *input_tf,
  		const struct dc_gamma *ramp, bool mapUserRamp)
  {
diff --cc drivers/gpu/drm/amd/display/modules/stats/stats.c
index 041f87b73d5f,710852ad03f3..000000000000
--- a/drivers/gpu/drm/amd/display/modules/stats/stats.c
+++ b/drivers/gpu/drm/amd/display/modules/stats/stats.c
@@@ -115,22 -131,35 +115,52 @@@ struct mod_stats *mod_stats_create(stru
  			&reg_data, sizeof(unsigned int), &flag))
  		core_stats->enabled = reg_data;
  
++<<<<<<< HEAD
 +	core_stats->entries = DAL_STATS_ENTRIES_REGKEY_DEFAULT;
 +	if (dm_read_persistent_data(dc->ctx, NULL, NULL,
 +			DAL_STATS_ENTRIES_REGKEY,
 +			&reg_data, sizeof(unsigned int), &flag)) {
 +		if (reg_data > DAL_STATS_ENTRIES_REGKEY_MAX)
 +			core_stats->entries = DAL_STATS_ENTRIES_REGKEY_MAX;
 +		else
 +			core_stats->entries = reg_data;
++=======
+ 	if (core_stats->enabled) {
+ 		core_stats->entries = DAL_STATS_ENTRIES_REGKEY_DEFAULT;
+ 		if (dm_read_persistent_data(dc->ctx, NULL, NULL,
+ 				DAL_STATS_ENTRIES_REGKEY,
+ 				&reg_data, sizeof(unsigned int), &flag)) {
+ 			if (reg_data > DAL_STATS_ENTRIES_REGKEY_MAX)
+ 				core_stats->entries = DAL_STATS_ENTRIES_REGKEY_MAX;
+ 			else
+ 				core_stats->entries = reg_data;
+ 		}
+ 		core_stats->time = kcalloc(core_stats->entries,
+ 						sizeof(struct stats_time_cache),
+ 						GFP_KERNEL);
+ 
+ 		if (core_stats->time == NULL)
+ 			goto fail_construct_time;
+ 
+ 		core_stats->event_entries = DAL_STATS_EVENT_ENTRIES_DEFAULT;
+ 		core_stats->events = kcalloc(core_stats->event_entries,
+ 					     sizeof(struct stats_event_cache),
+ 					     GFP_KERNEL);
+ 
+ 		if (core_stats->events == NULL)
+ 			goto fail_construct_events;
+ 
+ 	} else {
+ 		core_stats->entries = 0;
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	}
  
 +	core_stats->time = kzalloc(sizeof(struct stats_time_cache) * core_stats->entries,
 +					GFP_KERNEL);
 +
 +	if (core_stats->time == NULL)
 +		goto fail_construct;
 +
  	/* Purposely leave index 0 unused so we don't need special logic to
  	 * handle calculation cases that depend on previous flip data.
  	 */
diff --cc drivers/gpu/drm/i915/intel_hdcp.c
index 14ca5d3057a7,0cc6a861bcf8..000000000000
--- a/drivers/gpu/drm/i915/intel_hdcp.c
+++ b/drivers/gpu/drm/i915/intel_hdcp.c
@@@ -389,9 -391,75 +389,75 @@@ int intel_hdcp_auth_downstream(struct i
  		return -ENXIO;
  	}
  
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ /* Implements Part 2 of the HDCP authorization procedure */
+ static
+ int intel_hdcp_auth_downstream(struct intel_digital_port *intel_dig_port,
+ 			       const struct intel_hdcp_shim *shim)
+ {
+ 	u8 bstatus[2], num_downstream, *ksv_fifo;
+ 	int ret, i, tries = 3;
+ 
+ 	ret = intel_hdcp_poll_ksv_fifo(intel_dig_port, shim);
+ 	if (ret) {
+ 		DRM_ERROR("KSV list failed to become ready (%d)\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = shim->read_bstatus(intel_dig_port, bstatus);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (DRM_HDCP_MAX_DEVICE_EXCEEDED(bstatus[0]) ||
+ 	    DRM_HDCP_MAX_CASCADE_EXCEEDED(bstatus[1])) {
+ 		DRM_ERROR("Max Topology Limit Exceeded\n");
+ 		return -EPERM;
+ 	}
+ 
+ 	/*
+ 	 * When repeater reports 0 device count, HDCP1.4 spec allows disabling
+ 	 * the HDCP encryption. That implies that repeater can't have its own
+ 	 * display. As there is no consumption of encrypted content in the
+ 	 * repeater with 0 downstream devices, we are failing the
+ 	 * authentication.
+ 	 */
+ 	num_downstream = DRM_HDCP_NUM_DOWNSTREAM(bstatus[0]);
+ 	if (num_downstream == 0)
+ 		return -EINVAL;
+ 
+ 	ksv_fifo = kcalloc(DRM_HDCP_KSV_LEN, num_downstream, GFP_KERNEL);
+ 	if (!ksv_fifo)
+ 		return -ENOMEM;
+ 
+ 	ret = shim->read_ksv_fifo(intel_dig_port, num_downstream, ksv_fifo);
+ 	if (ret)
+ 		goto err;
+ 
+ 	/*
+ 	 * When V prime mismatches, DP Spec mandates re-read of
+ 	 * V prime atleast twice.
+ 	 */
+ 	for (i = 0; i < tries; i++) {
+ 		ret = intel_hdcp_validate_v_prime(intel_dig_port, shim,
+ 						  ksv_fifo, num_downstream,
+ 						  bstatus);
+ 		if (!ret)
+ 			break;
+ 	}
+ 
+ 	if (i == tries) {
+ 		DRM_ERROR("V Prime validation failed.(%d)\n", ret);
+ 		goto err;
+ 	}
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	DRM_DEBUG_KMS("HDCP is enabled (%d downstream devices)\n",
  		      num_downstream);
 -	ret = 0;
 -err:
 -	kfree(ksv_fifo);
 -	return ret;
 +	return 0;
  }
  
  /* Implements Part 1 of the HDCP authorization procedure */
diff --cc drivers/hwmon/coretemp.c
index 158187653545,10645c9bb7be..000000000000
--- a/drivers/hwmon/coretemp.c
+++ b/drivers/hwmon/coretemp.c
@@@ -806,33 -741,29 +806,42 @@@ static int __init coretemp_init(void
  	if (!x86_match_cpu(coretemp_ids))
  		return -ENODEV;
  
++<<<<<<< HEAD
++=======
+ 	max_packages = topology_max_packages();
+ 	pkg_devices = kcalloc(max_packages, sizeof(struct platform_device *),
+ 			      GFP_KERNEL);
+ 	if (!pkg_devices)
+ 		return -ENOMEM;
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	err = platform_driver_register(&coretemp_driver);
  	if (err)
 -		return err;
 +		goto exit;
  
 -	err = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "hwmon/coretemp:online",
 -				coretemp_cpu_online, coretemp_cpu_offline);
 -	if (err < 0)
 -		goto outdrv;
 -	coretemp_hp_online = err;
 +	cpu_notifier_register_begin();
 +	for_each_online_cpu(i)
 +		get_core_online(i);
 +
 +#ifndef CONFIG_HOTPLUG_CPU
 +	if (list_empty(&pdev_list)) {
 +		cpu_notifier_register_done();
 +		err = -ENODEV;
 +		goto exit_driver_unreg;
 +	}
 +#endif
 +
 +	__register_hotcpu_notifier(&coretemp_cpu_notifier);
 +	cpu_notifier_register_done();
  	return 0;
  
 -outdrv:
 +#ifndef CONFIG_HOTPLUG_CPU
 +exit_driver_unreg:
  	platform_driver_unregister(&coretemp_driver);
 -	kfree(pkg_devices);
 +#endif
 +exit:
  	return err;
  }
 -module_init(coretemp_init)
  
  static void __exit coretemp_exit(void)
  {
diff --cc drivers/i2c/i2c-stub.c
index 30ab5f87f140,f31ec0861979..000000000000
--- a/drivers/i2c/i2c-stub.c
+++ b/drivers/i2c/i2c-stub.c
@@@ -170,6 -322,44 +170,47 @@@ static struct i2c_adapter stub_adapter 
  	.name		= "SMBus stub driver",
  };
  
++<<<<<<< HEAD
++=======
+ static int __init i2c_stub_allocate_banks(int i)
+ {
+ 	struct stub_chip *chip = stub_chips + i;
+ 
+ 	chip->bank_reg = bank_reg[i];
+ 	chip->bank_start = bank_start[i];
+ 	chip->bank_end = bank_end[i];
+ 	chip->bank_size = bank_end[i] - bank_start[i] + 1;
+ 
+ 	/* We assume that all bits in the mask are contiguous */
+ 	chip->bank_mask = bank_mask[i];
+ 	while (!(chip->bank_mask & 1)) {
+ 		chip->bank_shift++;
+ 		chip->bank_mask >>= 1;
+ 	}
+ 
+ 	chip->bank_words = kcalloc(chip->bank_mask * chip->bank_size,
+ 				   sizeof(u16),
+ 				   GFP_KERNEL);
+ 	if (!chip->bank_words)
+ 		return -ENOMEM;
+ 
+ 	pr_debug("Allocated %u banks of %u words each (registers 0x%02x to 0x%02x)\n",
+ 		 chip->bank_mask, chip->bank_size, chip->bank_start,
+ 		 chip->bank_end);
+ 
+ 	return 0;
+ }
+ 
+ static void i2c_stub_free(void)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < stub_chips_nr; i++)
+ 		kfree(stub_chips[i].bank_words);
+ 	kfree(stub_chips);
+ }
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  static int __init i2c_stub_init(void)
  {
  	int i, ret;
diff --cc drivers/iommu/omap-iommu.c
index e02e5d71745b,af4a8e7fcd27..000000000000
--- a/drivers/iommu/omap-iommu.c
+++ b/drivers/iommu/omap-iommu.c
@@@ -1248,9 -1427,91 +1248,95 @@@ static phys_addr_t omap_iommu_iova_to_p
  	return ret;
  }
  
 -static int omap_iommu_add_device(struct device *dev)
 +static int omap_iommu_domain_has_cap(struct iommu_domain *domain,
 +				    unsigned long cap)
  {
++<<<<<<< HEAD
++=======
+ 	struct omap_iommu_arch_data *arch_data, *tmp;
+ 	struct omap_iommu *oiommu;
+ 	struct iommu_group *group;
+ 	struct device_node *np;
+ 	struct platform_device *pdev;
+ 	int num_iommus, i;
+ 	int ret;
+ 
+ 	/*
+ 	 * Allocate the archdata iommu structure for DT-based devices.
+ 	 *
+ 	 * TODO: Simplify this when removing non-DT support completely from the
+ 	 * IOMMU users.
+ 	 */
+ 	if (!dev->of_node)
+ 		return 0;
+ 
+ 	/*
+ 	 * retrieve the count of IOMMU nodes using phandle size as element size
+ 	 * since #iommu-cells = 0 for OMAP
+ 	 */
+ 	num_iommus = of_property_count_elems_of_size(dev->of_node, "iommus",
+ 						     sizeof(phandle));
+ 	if (num_iommus < 0)
+ 		return 0;
+ 
+ 	arch_data = kcalloc(num_iommus + 1, sizeof(*arch_data), GFP_KERNEL);
+ 	if (!arch_data)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0, tmp = arch_data; i < num_iommus; i++, tmp++) {
+ 		np = of_parse_phandle(dev->of_node, "iommus", i);
+ 		if (!np) {
+ 			kfree(arch_data);
+ 			return -EINVAL;
+ 		}
+ 
+ 		pdev = of_find_device_by_node(np);
+ 		if (WARN_ON(!pdev)) {
+ 			of_node_put(np);
+ 			kfree(arch_data);
+ 			return -EINVAL;
+ 		}
+ 
+ 		oiommu = platform_get_drvdata(pdev);
+ 		if (!oiommu) {
+ 			of_node_put(np);
+ 			kfree(arch_data);
+ 			return -EINVAL;
+ 		}
+ 
+ 		tmp->iommu_dev = oiommu;
+ 
+ 		of_node_put(np);
+ 	}
+ 
+ 	/*
+ 	 * use the first IOMMU alone for the sysfs device linking.
+ 	 * TODO: Evaluate if a single iommu_group needs to be
+ 	 * maintained for both IOMMUs
+ 	 */
+ 	oiommu = arch_data->iommu_dev;
+ 	ret = iommu_device_link(&oiommu->iommu, dev);
+ 	if (ret) {
+ 		kfree(arch_data);
+ 		return ret;
+ 	}
+ 
+ 	dev->archdata.iommu = arch_data;
+ 
+ 	/*
+ 	 * IOMMU group initialization calls into omap_iommu_device_group, which
+ 	 * needs a valid dev->archdata.iommu pointer
+ 	 */
+ 	group = iommu_group_get_for_dev(dev);
+ 	if (IS_ERR(group)) {
+ 		iommu_device_unlink(&oiommu->iommu, dev);
+ 		dev->archdata.iommu = NULL;
+ 		kfree(arch_data);
+ 		return PTR_ERR(group);
+ 	}
+ 	iommu_group_put(group);
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	return 0;
  }
  
diff --cc drivers/isdn/capi/capi.c
index 7ebdd9466f94,6e0c2814d032..000000000000
--- a/drivers/isdn/capi/capi.c
+++ b/drivers/isdn/capi/capi.c
@@@ -1260,7 -1260,7 +1260,11 @@@ static int __init capinc_tty_init(void
  	if (capi_ttyminors <= 0)
  		capi_ttyminors = CAPINC_NR_PORTS;
  
++<<<<<<< HEAD
 +	capiminors = kzalloc(sizeof(struct capi_minor *) * capi_ttyminors,
++=======
+ 	capiminors = kcalloc(capi_ttyminors, sizeof(struct capiminor *),
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  			     GFP_KERNEL);
  	if (!capiminors)
  		return -ENOMEM;
diff --cc drivers/isdn/mISDN/fsm.c
index 26477d48bbda,9a8d08d677a4..000000000000
--- a/drivers/isdn/mISDN/fsm.c
+++ b/drivers/isdn/mISDN/fsm.c
@@@ -32,8 -32,12 +32,17 @@@ mISDN_FsmNew(struct Fsm *fsm
  {
  	int i;
  
++<<<<<<< HEAD
 +	fsm->jumpmatrix = kzalloc(sizeof(FSMFNPTR) * fsm->state_count *
 +				  fsm->event_count, GFP_KERNEL);
++=======
+ 	fsm->jumpmatrix =
+ 		kzalloc(array3_size(sizeof(FSMFNPTR), fsm->state_count,
+ 				    fsm->event_count),
+ 			GFP_KERNEL);
+ 	if (fsm->jumpmatrix == NULL)
+ 		return -ENOMEM;
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  
  	for (i = 0; i < fncount; i++)
  		if ((fnlist[i].state >= fsm->state_count) ||
diff --cc drivers/md/bcache/super.c
index b4713cea1913,ec5f70d021de..000000000000
--- a/drivers/md/bcache/super.c
+++ b/drivers/md/bcache/super.c
@@@ -1412,24 -1715,27 +1412,35 @@@ struct cache_set *bch_cache_set_alloc(s
  	iter_size = (sb->bucket_size / sb->block_size + 1) *
  		sizeof(struct btree_iter_set);
  
++<<<<<<< HEAD
 +	if (!(c->devices = kzalloc(c->nr_uuids * sizeof(void *), GFP_KERNEL)) ||
 +	    !(c->bio_meta = mempool_create_kmalloc_pool(2,
 +				sizeof(struct bbio) + sizeof(struct bio_vec) *
 +				bucket_pages(c))) ||
 +	    !(c->bio_split = bioset_create(4, offsetof(struct bbio, bio))) ||
 +	    !(c->fill_iter = kmalloc(iter_size, GFP_KERNEL)) ||
 +	    !(c->sort = alloc_bucket_pages(GFP_KERNEL, c)) ||
++=======
+ 	if (!(c->devices = kcalloc(c->nr_uuids, sizeof(void *), GFP_KERNEL)) ||
+ 	    mempool_init_slab_pool(&c->search, 32, bch_search_cache) ||
+ 	    mempool_init_kmalloc_pool(&c->bio_meta, 2,
+ 				      sizeof(struct bbio) + sizeof(struct bio_vec) *
+ 				      bucket_pages(c)) ||
+ 	    mempool_init_kmalloc_pool(&c->fill_iter, 1, iter_size) ||
+ 	    bioset_init(&c->bio_split, 4, offsetof(struct bbio, bio),
+ 			BIOSET_NEED_BVECS|BIOSET_NEED_RESCUER) ||
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	    !(c->uuids = alloc_bucket_pages(GFP_KERNEL, c)) ||
 -	    !(c->moving_gc_wq = alloc_workqueue("bcache_gc",
 -						WQ_MEM_RECLAIM, 0)) ||
  	    bch_journal_alloc(c) ||
  	    bch_btree_cache_alloc(c) ||
 -	    bch_open_buckets_alloc(c) ||
 -	    bch_bset_sort_state_init(&c->sort, ilog2(c->btree_pages)))
 +	    bch_open_buckets_alloc(c))
  		goto err;
  
 +	c->fill_iter->size = sb->bucket_size / sb->block_size;
 +
  	c->congested_read_threshold_us	= 2000;
  	c->congested_write_threshold_us	= 20000;
 -	c->error_limit	= DEFAULT_IO_ERROR_LIMIT;
 -	WARN_ON(test_and_clear_bit(CACHE_SET_IO_DISABLE, &c->flags));
 +	c->error_limit	= 8 << IO_ERROR_SHIFT;
  
  	return c;
  err:
@@@ -1735,11 -2043,10 +1746,18 @@@ static int cache_alloc(struct cache_sb 
  	    !init_heap(&ca->heap,	free << 3, GFP_KERNEL) ||
  	    !(ca->buckets	= vzalloc(sizeof(struct bucket) *
  					  ca->sb.nbuckets)) ||
++<<<<<<< HEAD
 +	    !(ca->prio_buckets	= kzalloc(sizeof(uint64_t) * prio_buckets(ca) *
 +					  2, GFP_KERNEL)) ||
 +	    !(ca->disk_buckets	= alloc_bucket_pages(GFP_KERNEL, ca)) ||
 +	    !(ca->alloc_workqueue = alloc_workqueue("bch_allocator", 0, 1)) ||
 +	    bio_split_pool_init(&ca->bio_split_hook))
++=======
+ 	    !(ca->prio_buckets	= kzalloc(array3_size(sizeof(uint64_t),
+ 						      prio_buckets(ca), 2),
+ 					  GFP_KERNEL)) ||
+ 	    !(ca->disk_buckets	= alloc_bucket_pages(GFP_KERNEL, ca)))
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		return -ENOMEM;
  
  	ca->prio_last_buckets = ca->prio_buckets + prio_buckets(ca);
diff --cc drivers/md/dm-crypt.c
index 846ca2c190c8,57ca92dc0c3e..000000000000
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@@ -1452,9 -1878,10 +1452,16 @@@ static int crypt_alloc_tfms(struct cryp
  	unsigned i;
  	int err;
  
++<<<<<<< HEAD
 +	cc->tfms = kzalloc(cc->tfms_count * sizeof(struct crypto_ablkcipher *),
 +			   GFP_KERNEL);
 +	if (!cc->tfms)
++=======
+ 	cc->cipher_tfm.tfms = kcalloc(cc->tfms_count,
+ 				      sizeof(struct crypto_skcipher *),
+ 				      GFP_KERNEL);
+ 	if (!cc->cipher_tfm.tfms)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		return -ENOMEM;
  
  	for (i = 0; i < cc->tfms_count; i++) {
diff --cc drivers/misc/sram.c
index 437192e43006,e2e31b65bc5a..000000000000
--- a/drivers/misc/sram.c
+++ b/drivers/misc/sram.c
@@@ -31,9 -35,321 +31,327 @@@
  
  #define SRAM_GRANULARITY	32
  
++<<<<<<< HEAD
 +struct sram_dev {
 +	struct gen_pool *pool;
 +	struct clk *clk;
++=======
+ static ssize_t sram_read(struct file *filp, struct kobject *kobj,
+ 			 struct bin_attribute *attr,
+ 			 char *buf, loff_t pos, size_t count)
+ {
+ 	struct sram_partition *part;
+ 
+ 	part = container_of(attr, struct sram_partition, battr);
+ 
+ 	mutex_lock(&part->lock);
+ 	memcpy_fromio(buf, part->base + pos, count);
+ 	mutex_unlock(&part->lock);
+ 
+ 	return count;
+ }
+ 
+ static ssize_t sram_write(struct file *filp, struct kobject *kobj,
+ 			  struct bin_attribute *attr,
+ 			  char *buf, loff_t pos, size_t count)
+ {
+ 	struct sram_partition *part;
+ 
+ 	part = container_of(attr, struct sram_partition, battr);
+ 
+ 	mutex_lock(&part->lock);
+ 	memcpy_toio(part->base + pos, buf, count);
+ 	mutex_unlock(&part->lock);
+ 
+ 	return count;
+ }
+ 
+ static int sram_add_pool(struct sram_dev *sram, struct sram_reserve *block,
+ 			 phys_addr_t start, struct sram_partition *part)
+ {
+ 	int ret;
+ 
+ 	part->pool = devm_gen_pool_create(sram->dev, ilog2(SRAM_GRANULARITY),
+ 					  NUMA_NO_NODE, block->label);
+ 	if (IS_ERR(part->pool))
+ 		return PTR_ERR(part->pool);
+ 
+ 	ret = gen_pool_add_virt(part->pool, (unsigned long)part->base, start,
+ 				block->size, NUMA_NO_NODE);
+ 	if (ret < 0) {
+ 		dev_err(sram->dev, "failed to register subpool: %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int sram_add_export(struct sram_dev *sram, struct sram_reserve *block,
+ 			   phys_addr_t start, struct sram_partition *part)
+ {
+ 	sysfs_bin_attr_init(&part->battr);
+ 	part->battr.attr.name = devm_kasprintf(sram->dev, GFP_KERNEL,
+ 					       "%llx.sram",
+ 					       (unsigned long long)start);
+ 	if (!part->battr.attr.name)
+ 		return -ENOMEM;
+ 
+ 	part->battr.attr.mode = S_IRUSR | S_IWUSR;
+ 	part->battr.read = sram_read;
+ 	part->battr.write = sram_write;
+ 	part->battr.size = block->size;
+ 
+ 	return device_create_bin_file(sram->dev, &part->battr);
+ }
+ 
+ static int sram_add_partition(struct sram_dev *sram, struct sram_reserve *block,
+ 			      phys_addr_t start)
+ {
+ 	int ret;
+ 	struct sram_partition *part = &sram->partition[sram->partitions];
+ 
+ 	mutex_init(&part->lock);
+ 	part->base = sram->virt_base + block->start;
+ 
+ 	if (block->pool) {
+ 		ret = sram_add_pool(sram, block, start, part);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 	if (block->export) {
+ 		ret = sram_add_export(sram, block, start, part);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 	if (block->protect_exec) {
+ 		ret = sram_check_protect_exec(sram, block, part);
+ 		if (ret)
+ 			return ret;
+ 
+ 		ret = sram_add_pool(sram, block, start, part);
+ 		if (ret)
+ 			return ret;
+ 
+ 		sram_add_protect_exec(part);
+ 	}
+ 
+ 	sram->partitions++;
+ 
+ 	return 0;
+ }
+ 
+ static void sram_free_partitions(struct sram_dev *sram)
+ {
+ 	struct sram_partition *part;
+ 
+ 	if (!sram->partitions)
+ 		return;
+ 
+ 	part = &sram->partition[sram->partitions - 1];
+ 	for (; sram->partitions; sram->partitions--, part--) {
+ 		if (part->battr.size)
+ 			device_remove_bin_file(sram->dev, &part->battr);
+ 
+ 		if (part->pool &&
+ 		    gen_pool_avail(part->pool) < gen_pool_size(part->pool))
+ 			dev_err(sram->dev, "removed pool while SRAM allocated\n");
+ 	}
+ }
+ 
+ static int sram_reserve_cmp(void *priv, struct list_head *a,
+ 					struct list_head *b)
+ {
+ 	struct sram_reserve *ra = list_entry(a, struct sram_reserve, list);
+ 	struct sram_reserve *rb = list_entry(b, struct sram_reserve, list);
+ 
+ 	return ra->start - rb->start;
+ }
+ 
+ static int sram_reserve_regions(struct sram_dev *sram, struct resource *res)
+ {
+ 	struct device_node *np = sram->dev->of_node, *child;
+ 	unsigned long size, cur_start, cur_size;
+ 	struct sram_reserve *rblocks, *block;
+ 	struct list_head reserve_list;
+ 	unsigned int nblocks, exports = 0;
+ 	const char *label;
+ 	int ret = 0;
+ 
+ 	INIT_LIST_HEAD(&reserve_list);
+ 
+ 	size = resource_size(res);
+ 
+ 	/*
+ 	 * We need an additional block to mark the end of the memory region
+ 	 * after the reserved blocks from the dt are processed.
+ 	 */
+ 	nblocks = (np) ? of_get_available_child_count(np) + 1 : 1;
+ 	rblocks = kcalloc(nblocks, sizeof(*rblocks), GFP_KERNEL);
+ 	if (!rblocks)
+ 		return -ENOMEM;
+ 
+ 	block = &rblocks[0];
+ 	for_each_available_child_of_node(np, child) {
+ 		struct resource child_res;
+ 
+ 		ret = of_address_to_resource(child, 0, &child_res);
+ 		if (ret < 0) {
+ 			dev_err(sram->dev,
+ 				"could not get address for node %pOF\n",
+ 				child);
+ 			goto err_chunks;
+ 		}
+ 
+ 		if (child_res.start < res->start || child_res.end > res->end) {
+ 			dev_err(sram->dev,
+ 				"reserved block %pOF outside the sram area\n",
+ 				child);
+ 			ret = -EINVAL;
+ 			goto err_chunks;
+ 		}
+ 
+ 		block->start = child_res.start - res->start;
+ 		block->size = resource_size(&child_res);
+ 		list_add_tail(&block->list, &reserve_list);
+ 
+ 		if (of_find_property(child, "export", NULL))
+ 			block->export = true;
+ 
+ 		if (of_find_property(child, "pool", NULL))
+ 			block->pool = true;
+ 
+ 		if (of_find_property(child, "protect-exec", NULL))
+ 			block->protect_exec = true;
+ 
+ 		if ((block->export || block->pool || block->protect_exec) &&
+ 		    block->size) {
+ 			exports++;
+ 
+ 			label = NULL;
+ 			ret = of_property_read_string(child, "label", &label);
+ 			if (ret && ret != -EINVAL) {
+ 				dev_err(sram->dev,
+ 					"%pOF has invalid label name\n",
+ 					child);
+ 				goto err_chunks;
+ 			}
+ 			if (!label)
+ 				label = child->name;
+ 
+ 			block->label = devm_kstrdup(sram->dev,
+ 						    label, GFP_KERNEL);
+ 			if (!block->label) {
+ 				ret = -ENOMEM;
+ 				goto err_chunks;
+ 			}
+ 
+ 			dev_dbg(sram->dev, "found %sblock '%s' 0x%x-0x%x\n",
+ 				block->export ? "exported " : "", block->label,
+ 				block->start, block->start + block->size);
+ 		} else {
+ 			dev_dbg(sram->dev, "found reserved block 0x%x-0x%x\n",
+ 				block->start, block->start + block->size);
+ 		}
+ 
+ 		block++;
+ 	}
+ 	child = NULL;
+ 
+ 	/* the last chunk marks the end of the region */
+ 	rblocks[nblocks - 1].start = size;
+ 	rblocks[nblocks - 1].size = 0;
+ 	list_add_tail(&rblocks[nblocks - 1].list, &reserve_list);
+ 
+ 	list_sort(NULL, &reserve_list, sram_reserve_cmp);
+ 
+ 	if (exports) {
+ 		sram->partition = devm_kzalloc(sram->dev,
+ 				       exports * sizeof(*sram->partition),
+ 				       GFP_KERNEL);
+ 		if (!sram->partition) {
+ 			ret = -ENOMEM;
+ 			goto err_chunks;
+ 		}
+ 	}
+ 
+ 	cur_start = 0;
+ 	list_for_each_entry(block, &reserve_list, list) {
+ 		/* can only happen if sections overlap */
+ 		if (block->start < cur_start) {
+ 			dev_err(sram->dev,
+ 				"block at 0x%x starts after current offset 0x%lx\n",
+ 				block->start, cur_start);
+ 			ret = -EINVAL;
+ 			sram_free_partitions(sram);
+ 			goto err_chunks;
+ 		}
+ 
+ 		if ((block->export || block->pool || block->protect_exec) &&
+ 		    block->size) {
+ 			ret = sram_add_partition(sram, block,
+ 						 res->start + block->start);
+ 			if (ret) {
+ 				sram_free_partitions(sram);
+ 				goto err_chunks;
+ 			}
+ 		}
+ 
+ 		/* current start is in a reserved block, so continue after it */
+ 		if (block->start == cur_start) {
+ 			cur_start = block->start + block->size;
+ 			continue;
+ 		}
+ 
+ 		/*
+ 		 * allocate the space between the current starting
+ 		 * address and the following reserved block, or the
+ 		 * end of the region.
+ 		 */
+ 		cur_size = block->start - cur_start;
+ 
+ 		dev_dbg(sram->dev, "adding chunk 0x%lx-0x%lx\n",
+ 			cur_start, cur_start + cur_size);
+ 
+ 		ret = gen_pool_add_virt(sram->pool,
+ 				(unsigned long)sram->virt_base + cur_start,
+ 				res->start + cur_start, cur_size, -1);
+ 		if (ret < 0) {
+ 			sram_free_partitions(sram);
+ 			goto err_chunks;
+ 		}
+ 
+ 		/* next allocation after this reserved block */
+ 		cur_start = block->start + block->size;
+ 	}
+ 
+  err_chunks:
+ 	if (child)
+ 		of_node_put(child);
+ 
+ 	kfree(rblocks);
+ 
+ 	return ret;
+ }
+ 
+ static int atmel_securam_wait(void)
+ {
+ 	struct regmap *regmap;
+ 	u32 val;
+ 
+ 	regmap = syscon_regmap_lookup_by_compatible("atmel,sama5d2-secumod");
+ 	if (IS_ERR(regmap))
+ 		return -ENODEV;
+ 
+ 	return regmap_read_poll_timeout(regmap, AT91_SECUMOD_RAMRDY, val,
+ 					val & AT91_SECUMOD_RAMRDY_READY,
+ 					10000, 500000);
+ }
+ 
+ static const struct of_device_id sram_dt_ids[] = {
+ 	{ .compatible = "mmio-sram" },
+ 	{ .compatible = "atmel,sama5d2-securam", .data = atmel_securam_wait },
+ 	{}
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  };
  
  static int sram_probe(struct platform_device *pdev)
diff --cc drivers/mtd/chips/cfi_cmdset_0001.c
index 77514430f1fe,6e8e7b1bb34b..000000000000
--- a/drivers/mtd/chips/cfi_cmdset_0001.c
+++ b/drivers/mtd/chips/cfi_cmdset_0001.c
@@@ -562,12 -608,11 +562,19 @@@ static struct mtd_info *cfi_intelext_se
  	mtd->size = devsize * cfi->numchips;
  
  	mtd->numeraseregions = cfi->cfiq->NumEraseRegions * cfi->numchips;
++<<<<<<< HEAD
 +	mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info)
 +			* mtd->numeraseregions, GFP_KERNEL);
 +	if (!mtd->eraseregions) {
 +		printk(KERN_ERR "Failed to allocate memory for MTD erase region info\n");
++=======
+ 	mtd->eraseregions = kcalloc(mtd->numeraseregions,
+ 				    sizeof(struct mtd_erase_region_info),
+ 				    GFP_KERNEL);
+ 	if (!mtd->eraseregions)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		goto setup_err;
 +	}
  
  	for (i=0; i<cfi->cfiq->NumEraseRegions; i++) {
  		unsigned long ernum, ersize;
diff --cc drivers/mtd/maps/physmap_of.c
index d11109762ac5,4129535b8e46..000000000000
--- a/drivers/mtd/maps/physmap_of.c
+++ b/drivers/mtd/maps/physmap_of.c
@@@ -117,30 -117,22 +117,41 @@@ static const char * const part_probe_ty
  
  static const char * const *of_get_probes(struct device_node *dp)
  {
 +	const char *cp;
 +	int cplen;
 +	unsigned int l;
 +	unsigned int count;
  	const char **res;
 -	int count;
  
 -	count = of_property_count_strings(dp, "linux,part-probe");
 -	if (count < 0)
 +	cp = of_get_property(dp, "linux,part-probe", &cplen);
 +	if (cp == NULL)
  		return part_probe_types_def;
  
++<<<<<<< HEAD:drivers/mtd/maps/physmap_of.c
 +	count = 0;
 +	for (l = 0; l != cplen; l++)
 +		if (cp[l] == 0)
 +			count++;
++=======
+ 	res = kcalloc(count + 1, sizeof(*res), GFP_KERNEL);
+ 	if (!res)
+ 		return NULL;
+ 
+ 	count = of_property_read_string_array(dp, "linux,part-probe", res,
+ 					      count);
+ 	if (count < 0)
+ 		return NULL;
 -
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc()):drivers/mtd/maps/physmap_of_core.c
 +
 +	res = kzalloc((count + 1)*sizeof(*res), GFP_KERNEL);
 +	count = 0;
 +	while (cplen > 0) {
 +		res[count] = cp;
 +		l = strlen(cp) + 1;
 +		cp += l;
 +		cplen -= l;
 +		count++;
 +	}
  	return res;
  }
  
diff --cc drivers/mtd/ofpart.c
index 553d6d6d5603,6b21a92d3622..000000000000
--- a/drivers/mtd/ofpart.c
+++ b/drivers/mtd/ofpart.c
@@@ -46,13 -71,12 +46,18 @@@ static int parse_ofpart_partitions(stru
  	if (nr_parts == 0)
  		return 0;
  
++<<<<<<< HEAD
 +	*pparts = kzalloc(nr_parts * sizeof(**pparts), GFP_KERNEL);
 +	if (!*pparts)
++=======
+ 	parts = kcalloc(nr_parts, sizeof(*parts), GFP_KERNEL);
+ 	if (!parts)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		return -ENOMEM;
  
 +	pp = NULL;
  	i = 0;
 -	for_each_child_of_node(ofpart_node,  pp) {
 +	while ((pp = of_get_next_child(node, pp))) {
  		const __be32 *reg;
  		int len;
  		int a_cells, s_cells;
@@@ -126,8 -177,8 +131,13 @@@ static int parse_ofoldpart_partitions(s
  
  	nr_parts = plen / sizeof(part[0]);
  
++<<<<<<< HEAD
 +	*pparts = kzalloc(nr_parts * sizeof(*(*pparts)), GFP_KERNEL);
 +	if (!*pparts)
++=======
+ 	parts = kcalloc(nr_parts, sizeof(*parts), GFP_KERNEL);
+ 	if (!parts)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		return -ENOMEM;
  
  	names = of_get_property(dp, "partition-names", &plen);
diff --cc drivers/mtd/tests/mtd_pagetest.c
index 0c1140b6c286,75687369bc20..000000000000
--- a/drivers/mtd/tests/mtd_pagetest.c
+++ b/drivers/mtd/tests/mtd_pagetest.c
@@@ -190,11 -127,9 +190,16 @@@ static int crosstest(void
  	unsigned char *pp1, *pp2, *pp3, *pp4;
  
  	pr_info("crosstest\n");
++<<<<<<< HEAD:drivers/mtd/tests/mtd_pagetest.c
 +	pp1 = kmalloc(pgsize * 4, GFP_KERNEL);
 +	if (!pp1) {
 +		pr_err("error: cannot allocate memory\n");
++=======
+ 	pp1 = kcalloc(pgsize, 4, GFP_KERNEL);
+ 	if (!pp1)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc()):drivers/mtd/tests/pagetest.c
  		return -ENOMEM;
 +	}
  	pp2 = pp1 + pgsize;
  	pp3 = pp2 + pgsize;
  	pp4 = pp3 + pgsize;
diff --cc drivers/net/bonding/bond_main.c
index 68ecc8b7552b,63e3844c5bec..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -2410,6 -2394,54 +2410,48 @@@ static void bond_arp_send(struct net_de
  	arp_xmit(skb);
  }
  
++<<<<<<< HEAD
++=======
+ /* Validate the device path between the @start_dev and the @end_dev.
+  * The path is valid if the @end_dev is reachable through device
+  * stacking.
+  * When the path is validated, collect any vlan information in the
+  * path.
+  */
+ struct bond_vlan_tag *bond_verify_device_path(struct net_device *start_dev,
+ 					      struct net_device *end_dev,
+ 					      int level)
+ {
+ 	struct bond_vlan_tag *tags;
+ 	struct net_device *upper;
+ 	struct list_head  *iter;
+ 
+ 	if (start_dev == end_dev) {
+ 		tags = kcalloc(level + 1, sizeof(*tags), GFP_ATOMIC);
+ 		if (!tags)
+ 			return ERR_PTR(-ENOMEM);
+ 		tags[level].vlan_proto = VLAN_N_VID;
+ 		return tags;
+ 	}
+ 
+ 	netdev_for_each_upper_dev_rcu(start_dev, upper, iter) {
+ 		tags = bond_verify_device_path(upper, end_dev, level + 1);
+ 		if (IS_ERR_OR_NULL(tags)) {
+ 			if (IS_ERR(tags))
+ 				return tags;
+ 			continue;
+ 		}
+ 		if (is_vlan_dev(upper)) {
+ 			tags[level].vlan_proto = vlan_dev_vlan_proto(upper);
+ 			tags[level].vlan_id = vlan_dev_vlan_id(upper);
+ 		}
+ 
+ 		return tags;
+ 	}
+ 
+ 	return NULL;
+ }
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  
  static void bond_arp_send_all(struct bonding *bond, struct slave *slave)
  {
diff --cc drivers/net/ethernet/broadcom/bcm63xx_enet.c
index 1f7233bbb0e3,897302adc38e..000000000000
--- a/drivers/net/ethernet/broadcom/bcm63xx_enet.c
+++ b/drivers/net/ethernet/broadcom/bcm63xx_enet.c
@@@ -1862,8 -1944,844 +1862,847 @@@ struct platform_driver bcm63xx_enet_dri
  };
  
  /*
 - * switch mii access callbacks
 + * reserve & remap memory space shared between all macs
   */
++<<<<<<< HEAD
++=======
+ static int bcmenet_sw_mdio_read(struct bcm_enet_priv *priv,
+ 				int ext, int phy_id, int location)
+ {
+ 	u32 reg;
+ 	int ret;
+ 
+ 	spin_lock_bh(&priv->enetsw_mdio_lock);
+ 	enetsw_writel(priv, 0, ENETSW_MDIOC_REG);
+ 
+ 	reg = ENETSW_MDIOC_RD_MASK |
+ 		(phy_id << ENETSW_MDIOC_PHYID_SHIFT) |
+ 		(location << ENETSW_MDIOC_REG_SHIFT);
+ 
+ 	if (ext)
+ 		reg |= ENETSW_MDIOC_EXT_MASK;
+ 
+ 	enetsw_writel(priv, reg, ENETSW_MDIOC_REG);
+ 	udelay(50);
+ 	ret = enetsw_readw(priv, ENETSW_MDIOD_REG);
+ 	spin_unlock_bh(&priv->enetsw_mdio_lock);
+ 	return ret;
+ }
+ 
+ static void bcmenet_sw_mdio_write(struct bcm_enet_priv *priv,
+ 				 int ext, int phy_id, int location,
+ 				 uint16_t data)
+ {
+ 	u32 reg;
+ 
+ 	spin_lock_bh(&priv->enetsw_mdio_lock);
+ 	enetsw_writel(priv, 0, ENETSW_MDIOC_REG);
+ 
+ 	reg = ENETSW_MDIOC_WR_MASK |
+ 		(phy_id << ENETSW_MDIOC_PHYID_SHIFT) |
+ 		(location << ENETSW_MDIOC_REG_SHIFT);
+ 
+ 	if (ext)
+ 		reg |= ENETSW_MDIOC_EXT_MASK;
+ 
+ 	reg |= data;
+ 
+ 	enetsw_writel(priv, reg, ENETSW_MDIOC_REG);
+ 	udelay(50);
+ 	spin_unlock_bh(&priv->enetsw_mdio_lock);
+ }
+ 
+ static inline int bcm_enet_port_is_rgmii(int portid)
+ {
+ 	return portid >= ENETSW_RGMII_PORT0;
+ }
+ 
+ /*
+  * enet sw PHY polling
+  */
+ static void swphy_poll_timer(struct timer_list *t)
+ {
+ 	struct bcm_enet_priv *priv = from_timer(priv, t, swphy_poll);
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < priv->num_ports; i++) {
+ 		struct bcm63xx_enetsw_port *port;
+ 		int val, j, up, advertise, lpa, speed, duplex, media;
+ 		int external_phy = bcm_enet_port_is_rgmii(i);
+ 		u8 override;
+ 
+ 		port = &priv->used_ports[i];
+ 		if (!port->used)
+ 			continue;
+ 
+ 		if (port->bypass_link)
+ 			continue;
+ 
+ 		/* dummy read to clear */
+ 		for (j = 0; j < 2; j++)
+ 			val = bcmenet_sw_mdio_read(priv, external_phy,
+ 						   port->phy_id, MII_BMSR);
+ 
+ 		if (val == 0xffff)
+ 			continue;
+ 
+ 		up = (val & BMSR_LSTATUS) ? 1 : 0;
+ 		if (!(up ^ priv->sw_port_link[i]))
+ 			continue;
+ 
+ 		priv->sw_port_link[i] = up;
+ 
+ 		/* link changed */
+ 		if (!up) {
+ 			dev_info(&priv->pdev->dev, "link DOWN on %s\n",
+ 				 port->name);
+ 			enetsw_writeb(priv, ENETSW_PORTOV_ENABLE_MASK,
+ 				      ENETSW_PORTOV_REG(i));
+ 			enetsw_writeb(priv, ENETSW_PTCTRL_RXDIS_MASK |
+ 				      ENETSW_PTCTRL_TXDIS_MASK,
+ 				      ENETSW_PTCTRL_REG(i));
+ 			continue;
+ 		}
+ 
+ 		advertise = bcmenet_sw_mdio_read(priv, external_phy,
+ 						 port->phy_id, MII_ADVERTISE);
+ 
+ 		lpa = bcmenet_sw_mdio_read(priv, external_phy, port->phy_id,
+ 					   MII_LPA);
+ 
+ 		/* figure out media and duplex from advertise and LPA values */
+ 		media = mii_nway_result(lpa & advertise);
+ 		duplex = (media & ADVERTISE_FULL) ? 1 : 0;
+ 
+ 		if (media & (ADVERTISE_100FULL | ADVERTISE_100HALF))
+ 			speed = 100;
+ 		else
+ 			speed = 10;
+ 
+ 		if (val & BMSR_ESTATEN) {
+ 			advertise = bcmenet_sw_mdio_read(priv, external_phy,
+ 						port->phy_id, MII_CTRL1000);
+ 
+ 			lpa = bcmenet_sw_mdio_read(priv, external_phy,
+ 						port->phy_id, MII_STAT1000);
+ 
+ 			if (advertise & (ADVERTISE_1000FULL | ADVERTISE_1000HALF)
+ 					&& lpa & (LPA_1000FULL | LPA_1000HALF)) {
+ 				speed = 1000;
+ 				duplex = (lpa & LPA_1000FULL);
+ 			}
+ 		}
+ 
+ 		dev_info(&priv->pdev->dev,
+ 			 "link UP on %s, %dMbps, %s-duplex\n",
+ 			 port->name, speed, duplex ? "full" : "half");
+ 
+ 		override = ENETSW_PORTOV_ENABLE_MASK |
+ 			ENETSW_PORTOV_LINKUP_MASK;
+ 
+ 		if (speed == 1000)
+ 			override |= ENETSW_IMPOV_1000_MASK;
+ 		else if (speed == 100)
+ 			override |= ENETSW_IMPOV_100_MASK;
+ 		if (duplex)
+ 			override |= ENETSW_IMPOV_FDX_MASK;
+ 
+ 		enetsw_writeb(priv, override, ENETSW_PORTOV_REG(i));
+ 		enetsw_writeb(priv, 0, ENETSW_PTCTRL_REG(i));
+ 	}
+ 
+ 	priv->swphy_poll.expires = jiffies + HZ;
+ 	add_timer(&priv->swphy_poll);
+ }
+ 
+ /*
+  * open callback, allocate dma rings & buffers and start rx operation
+  */
+ static int bcm_enetsw_open(struct net_device *dev)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	struct device *kdev;
+ 	int i, ret;
+ 	unsigned int size;
+ 	void *p;
+ 	u32 val;
+ 
+ 	priv = netdev_priv(dev);
+ 	kdev = &priv->pdev->dev;
+ 
+ 	/* mask all interrupts and request them */
+ 	enet_dmac_writel(priv, 0, ENETDMAC_IRMASK, priv->rx_chan);
+ 	enet_dmac_writel(priv, 0, ENETDMAC_IRMASK, priv->tx_chan);
+ 
+ 	ret = request_irq(priv->irq_rx, bcm_enet_isr_dma,
+ 			  0, dev->name, dev);
+ 	if (ret)
+ 		goto out_freeirq;
+ 
+ 	if (priv->irq_tx != -1) {
+ 		ret = request_irq(priv->irq_tx, bcm_enet_isr_dma,
+ 				  0, dev->name, dev);
+ 		if (ret)
+ 			goto out_freeirq_rx;
+ 	}
+ 
+ 	/* allocate rx dma ring */
+ 	size = priv->rx_ring_size * sizeof(struct bcm_enet_desc);
+ 	p = dma_zalloc_coherent(kdev, size, &priv->rx_desc_dma, GFP_KERNEL);
+ 	if (!p) {
+ 		dev_err(kdev, "cannot allocate rx ring %u\n", size);
+ 		ret = -ENOMEM;
+ 		goto out_freeirq_tx;
+ 	}
+ 
+ 	priv->rx_desc_alloc_size = size;
+ 	priv->rx_desc_cpu = p;
+ 
+ 	/* allocate tx dma ring */
+ 	size = priv->tx_ring_size * sizeof(struct bcm_enet_desc);
+ 	p = dma_zalloc_coherent(kdev, size, &priv->tx_desc_dma, GFP_KERNEL);
+ 	if (!p) {
+ 		dev_err(kdev, "cannot allocate tx ring\n");
+ 		ret = -ENOMEM;
+ 		goto out_free_rx_ring;
+ 	}
+ 
+ 	priv->tx_desc_alloc_size = size;
+ 	priv->tx_desc_cpu = p;
+ 
+ 	priv->tx_skb = kcalloc(priv->tx_ring_size, sizeof(struct sk_buff *),
+ 			       GFP_KERNEL);
+ 	if (!priv->tx_skb) {
+ 		dev_err(kdev, "cannot allocate rx skb queue\n");
+ 		ret = -ENOMEM;
+ 		goto out_free_tx_ring;
+ 	}
+ 
+ 	priv->tx_desc_count = priv->tx_ring_size;
+ 	priv->tx_dirty_desc = 0;
+ 	priv->tx_curr_desc = 0;
+ 	spin_lock_init(&priv->tx_lock);
+ 
+ 	/* init & fill rx ring with skbs */
+ 	priv->rx_skb = kcalloc(priv->rx_ring_size, sizeof(struct sk_buff *),
+ 			       GFP_KERNEL);
+ 	if (!priv->rx_skb) {
+ 		dev_err(kdev, "cannot allocate rx skb queue\n");
+ 		ret = -ENOMEM;
+ 		goto out_free_tx_skb;
+ 	}
+ 
+ 	priv->rx_desc_count = 0;
+ 	priv->rx_dirty_desc = 0;
+ 	priv->rx_curr_desc = 0;
+ 
+ 	/* disable all ports */
+ 	for (i = 0; i < priv->num_ports; i++) {
+ 		enetsw_writeb(priv, ENETSW_PORTOV_ENABLE_MASK,
+ 			      ENETSW_PORTOV_REG(i));
+ 		enetsw_writeb(priv, ENETSW_PTCTRL_RXDIS_MASK |
+ 			      ENETSW_PTCTRL_TXDIS_MASK,
+ 			      ENETSW_PTCTRL_REG(i));
+ 
+ 		priv->sw_port_link[i] = 0;
+ 	}
+ 
+ 	/* reset mib */
+ 	val = enetsw_readb(priv, ENETSW_GMCR_REG);
+ 	val |= ENETSW_GMCR_RST_MIB_MASK;
+ 	enetsw_writeb(priv, val, ENETSW_GMCR_REG);
+ 	mdelay(1);
+ 	val &= ~ENETSW_GMCR_RST_MIB_MASK;
+ 	enetsw_writeb(priv, val, ENETSW_GMCR_REG);
+ 	mdelay(1);
+ 
+ 	/* force CPU port state */
+ 	val = enetsw_readb(priv, ENETSW_IMPOV_REG);
+ 	val |= ENETSW_IMPOV_FORCE_MASK | ENETSW_IMPOV_LINKUP_MASK;
+ 	enetsw_writeb(priv, val, ENETSW_IMPOV_REG);
+ 
+ 	/* enable switch forward engine */
+ 	val = enetsw_readb(priv, ENETSW_SWMODE_REG);
+ 	val |= ENETSW_SWMODE_FWD_EN_MASK;
+ 	enetsw_writeb(priv, val, ENETSW_SWMODE_REG);
+ 
+ 	/* enable jumbo on all ports */
+ 	enetsw_writel(priv, 0x1ff, ENETSW_JMBCTL_PORT_REG);
+ 	enetsw_writew(priv, 9728, ENETSW_JMBCTL_MAXSIZE_REG);
+ 
+ 	/* initialize flow control buffer allocation */
+ 	enet_dma_writel(priv, ENETDMA_BUFALLOC_FORCE_MASK | 0,
+ 			ENETDMA_BUFALLOC_REG(priv->rx_chan));
+ 
+ 	if (bcm_enet_refill_rx(dev)) {
+ 		dev_err(kdev, "cannot allocate rx skb queue\n");
+ 		ret = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	/* write rx & tx ring addresses */
+ 	enet_dmas_writel(priv, priv->rx_desc_dma,
+ 			 ENETDMAS_RSTART_REG, priv->rx_chan);
+ 	enet_dmas_writel(priv, priv->tx_desc_dma,
+ 			 ENETDMAS_RSTART_REG, priv->tx_chan);
+ 
+ 	/* clear remaining state ram for rx & tx channel */
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM2_REG, priv->rx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM2_REG, priv->tx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM3_REG, priv->rx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM3_REG, priv->tx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM4_REG, priv->rx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM4_REG, priv->tx_chan);
+ 
+ 	/* set dma maximum burst len */
+ 	enet_dmac_writel(priv, priv->dma_maxburst,
+ 			 ENETDMAC_MAXBURST, priv->rx_chan);
+ 	enet_dmac_writel(priv, priv->dma_maxburst,
+ 			 ENETDMAC_MAXBURST, priv->tx_chan);
+ 
+ 	/* set flow control low/high threshold to 1/3 / 2/3 */
+ 	val = priv->rx_ring_size / 3;
+ 	enet_dma_writel(priv, val, ENETDMA_FLOWCL_REG(priv->rx_chan));
+ 	val = (priv->rx_ring_size * 2) / 3;
+ 	enet_dma_writel(priv, val, ENETDMA_FLOWCH_REG(priv->rx_chan));
+ 
+ 	/* all set, enable mac and interrupts, start dma engine and
+ 	 * kick rx dma channel
+ 	 */
+ 	wmb();
+ 	enet_dma_writel(priv, ENETDMA_CFG_EN_MASK, ENETDMA_CFG_REG);
+ 	enet_dmac_writel(priv, ENETDMAC_CHANCFG_EN_MASK,
+ 			 ENETDMAC_CHANCFG, priv->rx_chan);
+ 
+ 	/* watch "packet transferred" interrupt in rx and tx */
+ 	enet_dmac_writel(priv, ENETDMAC_IR_PKTDONE_MASK,
+ 			 ENETDMAC_IR, priv->rx_chan);
+ 	enet_dmac_writel(priv, ENETDMAC_IR_PKTDONE_MASK,
+ 			 ENETDMAC_IR, priv->tx_chan);
+ 
+ 	/* make sure we enable napi before rx interrupt  */
+ 	napi_enable(&priv->napi);
+ 
+ 	enet_dmac_writel(priv, ENETDMAC_IR_PKTDONE_MASK,
+ 			 ENETDMAC_IRMASK, priv->rx_chan);
+ 	enet_dmac_writel(priv, ENETDMAC_IR_PKTDONE_MASK,
+ 			 ENETDMAC_IRMASK, priv->tx_chan);
+ 
+ 	netif_carrier_on(dev);
+ 	netif_start_queue(dev);
+ 
+ 	/* apply override config for bypass_link ports here. */
+ 	for (i = 0; i < priv->num_ports; i++) {
+ 		struct bcm63xx_enetsw_port *port;
+ 		u8 override;
+ 		port = &priv->used_ports[i];
+ 		if (!port->used)
+ 			continue;
+ 
+ 		if (!port->bypass_link)
+ 			continue;
+ 
+ 		override = ENETSW_PORTOV_ENABLE_MASK |
+ 			ENETSW_PORTOV_LINKUP_MASK;
+ 
+ 		switch (port->force_speed) {
+ 		case 1000:
+ 			override |= ENETSW_IMPOV_1000_MASK;
+ 			break;
+ 		case 100:
+ 			override |= ENETSW_IMPOV_100_MASK;
+ 			break;
+ 		case 10:
+ 			break;
+ 		default:
+ 			pr_warn("invalid forced speed on port %s: assume 10\n",
+ 			       port->name);
+ 			break;
+ 		}
+ 
+ 		if (port->force_duplex_full)
+ 			override |= ENETSW_IMPOV_FDX_MASK;
+ 
+ 
+ 		enetsw_writeb(priv, override, ENETSW_PORTOV_REG(i));
+ 		enetsw_writeb(priv, 0, ENETSW_PTCTRL_REG(i));
+ 	}
+ 
+ 	/* start phy polling timer */
+ 	timer_setup(&priv->swphy_poll, swphy_poll_timer, 0);
+ 	mod_timer(&priv->swphy_poll, jiffies);
+ 	return 0;
+ 
+ out:
+ 	for (i = 0; i < priv->rx_ring_size; i++) {
+ 		struct bcm_enet_desc *desc;
+ 
+ 		if (!priv->rx_skb[i])
+ 			continue;
+ 
+ 		desc = &priv->rx_desc_cpu[i];
+ 		dma_unmap_single(kdev, desc->address, priv->rx_skb_size,
+ 				 DMA_FROM_DEVICE);
+ 		kfree_skb(priv->rx_skb[i]);
+ 	}
+ 	kfree(priv->rx_skb);
+ 
+ out_free_tx_skb:
+ 	kfree(priv->tx_skb);
+ 
+ out_free_tx_ring:
+ 	dma_free_coherent(kdev, priv->tx_desc_alloc_size,
+ 			  priv->tx_desc_cpu, priv->tx_desc_dma);
+ 
+ out_free_rx_ring:
+ 	dma_free_coherent(kdev, priv->rx_desc_alloc_size,
+ 			  priv->rx_desc_cpu, priv->rx_desc_dma);
+ 
+ out_freeirq_tx:
+ 	if (priv->irq_tx != -1)
+ 		free_irq(priv->irq_tx, dev);
+ 
+ out_freeirq_rx:
+ 	free_irq(priv->irq_rx, dev);
+ 
+ out_freeirq:
+ 	return ret;
+ }
+ 
+ /* stop callback */
+ static int bcm_enetsw_stop(struct net_device *dev)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	struct device *kdev;
+ 	int i;
+ 
+ 	priv = netdev_priv(dev);
+ 	kdev = &priv->pdev->dev;
+ 
+ 	del_timer_sync(&priv->swphy_poll);
+ 	netif_stop_queue(dev);
+ 	napi_disable(&priv->napi);
+ 	del_timer_sync(&priv->rx_timeout);
+ 
+ 	/* mask all interrupts */
+ 	enet_dmac_writel(priv, 0, ENETDMAC_IRMASK, priv->rx_chan);
+ 	enet_dmac_writel(priv, 0, ENETDMAC_IRMASK, priv->tx_chan);
+ 
+ 	/* disable dma & mac */
+ 	bcm_enet_disable_dma(priv, priv->tx_chan);
+ 	bcm_enet_disable_dma(priv, priv->rx_chan);
+ 
+ 	/* force reclaim of all tx buffers */
+ 	bcm_enet_tx_reclaim(dev, 1);
+ 
+ 	/* free the rx skb ring */
+ 	for (i = 0; i < priv->rx_ring_size; i++) {
+ 		struct bcm_enet_desc *desc;
+ 
+ 		if (!priv->rx_skb[i])
+ 			continue;
+ 
+ 		desc = &priv->rx_desc_cpu[i];
+ 		dma_unmap_single(kdev, desc->address, priv->rx_skb_size,
+ 				 DMA_FROM_DEVICE);
+ 		kfree_skb(priv->rx_skb[i]);
+ 	}
+ 
+ 	/* free remaining allocated memory */
+ 	kfree(priv->rx_skb);
+ 	kfree(priv->tx_skb);
+ 	dma_free_coherent(kdev, priv->rx_desc_alloc_size,
+ 			  priv->rx_desc_cpu, priv->rx_desc_dma);
+ 	dma_free_coherent(kdev, priv->tx_desc_alloc_size,
+ 			  priv->tx_desc_cpu, priv->tx_desc_dma);
+ 	if (priv->irq_tx != -1)
+ 		free_irq(priv->irq_tx, dev);
+ 	free_irq(priv->irq_rx, dev);
+ 
+ 	return 0;
+ }
+ 
+ /* try to sort out phy external status by walking the used_port field
+  * in the bcm_enet_priv structure. in case the phy address is not
+  * assigned to any physical port on the switch, assume it is external
+  * (and yell at the user).
+  */
+ static int bcm_enetsw_phy_is_external(struct bcm_enet_priv *priv, int phy_id)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < priv->num_ports; ++i) {
+ 		if (!priv->used_ports[i].used)
+ 			continue;
+ 		if (priv->used_ports[i].phy_id == phy_id)
+ 			return bcm_enet_port_is_rgmii(i);
+ 	}
+ 
+ 	printk_once(KERN_WARNING  "bcm63xx_enet: could not find a used port with phy_id %i, assuming phy is external\n",
+ 		    phy_id);
+ 	return 1;
+ }
+ 
+ /* can't use bcmenet_sw_mdio_read directly as we need to sort out
+  * external/internal status of the given phy_id first.
+  */
+ static int bcm_enetsw_mii_mdio_read(struct net_device *dev, int phy_id,
+ 				    int location)
+ {
+ 	struct bcm_enet_priv *priv;
+ 
+ 	priv = netdev_priv(dev);
+ 	return bcmenet_sw_mdio_read(priv,
+ 				    bcm_enetsw_phy_is_external(priv, phy_id),
+ 				    phy_id, location);
+ }
+ 
+ /* can't use bcmenet_sw_mdio_write directly as we need to sort out
+  * external/internal status of the given phy_id first.
+  */
+ static void bcm_enetsw_mii_mdio_write(struct net_device *dev, int phy_id,
+ 				      int location,
+ 				      int val)
+ {
+ 	struct bcm_enet_priv *priv;
+ 
+ 	priv = netdev_priv(dev);
+ 	bcmenet_sw_mdio_write(priv, bcm_enetsw_phy_is_external(priv, phy_id),
+ 			      phy_id, location, val);
+ }
+ 
+ static int bcm_enetsw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+ {
+ 	struct mii_if_info mii;
+ 
+ 	mii.dev = dev;
+ 	mii.mdio_read = bcm_enetsw_mii_mdio_read;
+ 	mii.mdio_write = bcm_enetsw_mii_mdio_write;
+ 	mii.phy_id = 0;
+ 	mii.phy_id_mask = 0x3f;
+ 	mii.reg_num_mask = 0x1f;
+ 	return generic_mii_ioctl(&mii, if_mii(rq), cmd, NULL);
+ 
+ }
+ 
+ static const struct net_device_ops bcm_enetsw_ops = {
+ 	.ndo_open		= bcm_enetsw_open,
+ 	.ndo_stop		= bcm_enetsw_stop,
+ 	.ndo_start_xmit		= bcm_enet_start_xmit,
+ 	.ndo_change_mtu		= bcm_enet_change_mtu,
+ 	.ndo_do_ioctl		= bcm_enetsw_ioctl,
+ };
+ 
+ 
+ static const struct bcm_enet_stats bcm_enetsw_gstrings_stats[] = {
+ 	{ "rx_packets", DEV_STAT(rx_packets), -1 },
+ 	{ "tx_packets",	DEV_STAT(tx_packets), -1 },
+ 	{ "rx_bytes", DEV_STAT(rx_bytes), -1 },
+ 	{ "tx_bytes", DEV_STAT(tx_bytes), -1 },
+ 	{ "rx_errors", DEV_STAT(rx_errors), -1 },
+ 	{ "tx_errors", DEV_STAT(tx_errors), -1 },
+ 	{ "rx_dropped",	DEV_STAT(rx_dropped), -1 },
+ 	{ "tx_dropped",	DEV_STAT(tx_dropped), -1 },
+ 
+ 	{ "tx_good_octets", GEN_STAT(mib.tx_gd_octets), ETHSW_MIB_RX_GD_OCT },
+ 	{ "tx_unicast", GEN_STAT(mib.tx_unicast), ETHSW_MIB_RX_BRDCAST },
+ 	{ "tx_broadcast", GEN_STAT(mib.tx_brdcast), ETHSW_MIB_RX_BRDCAST },
+ 	{ "tx_multicast", GEN_STAT(mib.tx_mult), ETHSW_MIB_RX_MULT },
+ 	{ "tx_64_octets", GEN_STAT(mib.tx_64), ETHSW_MIB_RX_64 },
+ 	{ "tx_65_127_oct", GEN_STAT(mib.tx_65_127), ETHSW_MIB_RX_65_127 },
+ 	{ "tx_128_255_oct", GEN_STAT(mib.tx_128_255), ETHSW_MIB_RX_128_255 },
+ 	{ "tx_256_511_oct", GEN_STAT(mib.tx_256_511), ETHSW_MIB_RX_256_511 },
+ 	{ "tx_512_1023_oct", GEN_STAT(mib.tx_512_1023), ETHSW_MIB_RX_512_1023},
+ 	{ "tx_1024_1522_oct", GEN_STAT(mib.tx_1024_max),
+ 	  ETHSW_MIB_RX_1024_1522 },
+ 	{ "tx_1523_2047_oct", GEN_STAT(mib.tx_1523_2047),
+ 	  ETHSW_MIB_RX_1523_2047 },
+ 	{ "tx_2048_4095_oct", GEN_STAT(mib.tx_2048_4095),
+ 	  ETHSW_MIB_RX_2048_4095 },
+ 	{ "tx_4096_8191_oct", GEN_STAT(mib.tx_4096_8191),
+ 	  ETHSW_MIB_RX_4096_8191 },
+ 	{ "tx_8192_9728_oct", GEN_STAT(mib.tx_8192_9728),
+ 	  ETHSW_MIB_RX_8192_9728 },
+ 	{ "tx_oversize", GEN_STAT(mib.tx_ovr), ETHSW_MIB_RX_OVR },
+ 	{ "tx_oversize_drop", GEN_STAT(mib.tx_ovr), ETHSW_MIB_RX_OVR_DISC },
+ 	{ "tx_dropped",	GEN_STAT(mib.tx_drop), ETHSW_MIB_RX_DROP },
+ 	{ "tx_undersize", GEN_STAT(mib.tx_underrun), ETHSW_MIB_RX_UND },
+ 	{ "tx_pause", GEN_STAT(mib.tx_pause), ETHSW_MIB_RX_PAUSE },
+ 
+ 	{ "rx_good_octets", GEN_STAT(mib.rx_gd_octets), ETHSW_MIB_TX_ALL_OCT },
+ 	{ "rx_broadcast", GEN_STAT(mib.rx_brdcast), ETHSW_MIB_TX_BRDCAST },
+ 	{ "rx_multicast", GEN_STAT(mib.rx_mult), ETHSW_MIB_TX_MULT },
+ 	{ "rx_unicast", GEN_STAT(mib.rx_unicast), ETHSW_MIB_TX_MULT },
+ 	{ "rx_pause", GEN_STAT(mib.rx_pause), ETHSW_MIB_TX_PAUSE },
+ 	{ "rx_dropped", GEN_STAT(mib.rx_drop), ETHSW_MIB_TX_DROP_PKTS },
+ 
+ };
+ 
+ #define BCM_ENETSW_STATS_LEN	\
+ 	(sizeof(bcm_enetsw_gstrings_stats) / sizeof(struct bcm_enet_stats))
+ 
+ static void bcm_enetsw_get_strings(struct net_device *netdev,
+ 				   u32 stringset, u8 *data)
+ {
+ 	int i;
+ 
+ 	switch (stringset) {
+ 	case ETH_SS_STATS:
+ 		for (i = 0; i < BCM_ENETSW_STATS_LEN; i++) {
+ 			memcpy(data + i * ETH_GSTRING_LEN,
+ 			       bcm_enetsw_gstrings_stats[i].stat_string,
+ 			       ETH_GSTRING_LEN);
+ 		}
+ 		break;
+ 	}
+ }
+ 
+ static int bcm_enetsw_get_sset_count(struct net_device *netdev,
+ 				     int string_set)
+ {
+ 	switch (string_set) {
+ 	case ETH_SS_STATS:
+ 		return BCM_ENETSW_STATS_LEN;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ static void bcm_enetsw_get_drvinfo(struct net_device *netdev,
+ 				   struct ethtool_drvinfo *drvinfo)
+ {
+ 	strncpy(drvinfo->driver, bcm_enet_driver_name, 32);
+ 	strncpy(drvinfo->version, bcm_enet_driver_version, 32);
+ 	strncpy(drvinfo->fw_version, "N/A", 32);
+ 	strncpy(drvinfo->bus_info, "bcm63xx", 32);
+ }
+ 
+ static void bcm_enetsw_get_ethtool_stats(struct net_device *netdev,
+ 					 struct ethtool_stats *stats,
+ 					 u64 *data)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	int i;
+ 
+ 	priv = netdev_priv(netdev);
+ 
+ 	for (i = 0; i < BCM_ENETSW_STATS_LEN; i++) {
+ 		const struct bcm_enet_stats *s;
+ 		u32 lo, hi;
+ 		char *p;
+ 		int reg;
+ 
+ 		s = &bcm_enetsw_gstrings_stats[i];
+ 
+ 		reg = s->mib_reg;
+ 		if (reg == -1)
+ 			continue;
+ 
+ 		lo = enetsw_readl(priv, ENETSW_MIB_REG(reg));
+ 		p = (char *)priv + s->stat_offset;
+ 
+ 		if (s->sizeof_stat == sizeof(u64)) {
+ 			hi = enetsw_readl(priv, ENETSW_MIB_REG(reg + 1));
+ 			*(u64 *)p = ((u64)hi << 32 | lo);
+ 		} else {
+ 			*(u32 *)p = lo;
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < BCM_ENETSW_STATS_LEN; i++) {
+ 		const struct bcm_enet_stats *s;
+ 		char *p;
+ 
+ 		s = &bcm_enetsw_gstrings_stats[i];
+ 
+ 		if (s->mib_reg == -1)
+ 			p = (char *)&netdev->stats + s->stat_offset;
+ 		else
+ 			p = (char *)priv + s->stat_offset;
+ 
+ 		data[i] = (s->sizeof_stat == sizeof(u64)) ?
+ 			*(u64 *)p : *(u32 *)p;
+ 	}
+ }
+ 
+ static void bcm_enetsw_get_ringparam(struct net_device *dev,
+ 				     struct ethtool_ringparam *ering)
+ {
+ 	struct bcm_enet_priv *priv;
+ 
+ 	priv = netdev_priv(dev);
+ 
+ 	/* rx/tx ring is actually only limited by memory */
+ 	ering->rx_max_pending = 8192;
+ 	ering->tx_max_pending = 8192;
+ 	ering->rx_mini_max_pending = 0;
+ 	ering->rx_jumbo_max_pending = 0;
+ 	ering->rx_pending = priv->rx_ring_size;
+ 	ering->tx_pending = priv->tx_ring_size;
+ }
+ 
+ static int bcm_enetsw_set_ringparam(struct net_device *dev,
+ 				    struct ethtool_ringparam *ering)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	int was_running;
+ 
+ 	priv = netdev_priv(dev);
+ 
+ 	was_running = 0;
+ 	if (netif_running(dev)) {
+ 		bcm_enetsw_stop(dev);
+ 		was_running = 1;
+ 	}
+ 
+ 	priv->rx_ring_size = ering->rx_pending;
+ 	priv->tx_ring_size = ering->tx_pending;
+ 
+ 	if (was_running) {
+ 		int err;
+ 
+ 		err = bcm_enetsw_open(dev);
+ 		if (err)
+ 			dev_close(dev);
+ 	}
+ 	return 0;
+ }
+ 
+ static const struct ethtool_ops bcm_enetsw_ethtool_ops = {
+ 	.get_strings		= bcm_enetsw_get_strings,
+ 	.get_sset_count		= bcm_enetsw_get_sset_count,
+ 	.get_ethtool_stats      = bcm_enetsw_get_ethtool_stats,
+ 	.get_drvinfo		= bcm_enetsw_get_drvinfo,
+ 	.get_ringparam		= bcm_enetsw_get_ringparam,
+ 	.set_ringparam		= bcm_enetsw_set_ringparam,
+ };
+ 
+ /* allocate netdevice, request register memory and register device. */
+ static int bcm_enetsw_probe(struct platform_device *pdev)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	struct net_device *dev;
+ 	struct bcm63xx_enetsw_platform_data *pd;
+ 	struct resource *res_mem;
+ 	int ret, irq_rx, irq_tx;
+ 
+ 	if (!bcm_enet_shared_base[0])
+ 		return -EPROBE_DEFER;
+ 
+ 	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	irq_rx = platform_get_irq(pdev, 0);
+ 	irq_tx = platform_get_irq(pdev, 1);
+ 	if (!res_mem || irq_rx < 0)
+ 		return -ENODEV;
+ 
+ 	ret = 0;
+ 	dev = alloc_etherdev(sizeof(*priv));
+ 	if (!dev)
+ 		return -ENOMEM;
+ 	priv = netdev_priv(dev);
+ 	memset(priv, 0, sizeof(*priv));
+ 
+ 	/* initialize default and fetch platform data */
+ 	priv->enet_is_sw = true;
+ 	priv->irq_rx = irq_rx;
+ 	priv->irq_tx = irq_tx;
+ 	priv->rx_ring_size = BCMENET_DEF_RX_DESC;
+ 	priv->tx_ring_size = BCMENET_DEF_TX_DESC;
+ 	priv->dma_maxburst = BCMENETSW_DMA_MAXBURST;
+ 
+ 	pd = dev_get_platdata(&pdev->dev);
+ 	if (pd) {
+ 		memcpy(dev->dev_addr, pd->mac_addr, ETH_ALEN);
+ 		memcpy(priv->used_ports, pd->used_ports,
+ 		       sizeof(pd->used_ports));
+ 		priv->num_ports = pd->num_ports;
+ 		priv->dma_has_sram = pd->dma_has_sram;
+ 		priv->dma_chan_en_mask = pd->dma_chan_en_mask;
+ 		priv->dma_chan_int_mask = pd->dma_chan_int_mask;
+ 		priv->dma_chan_width = pd->dma_chan_width;
+ 	}
+ 
+ 	ret = bcm_enet_change_mtu(dev, dev->mtu);
+ 	if (ret)
+ 		goto out;
+ 
+ 	priv->base = devm_ioremap_resource(&pdev->dev, res_mem);
+ 	if (IS_ERR(priv->base)) {
+ 		ret = PTR_ERR(priv->base);
+ 		goto out;
+ 	}
+ 
+ 	priv->mac_clk = devm_clk_get(&pdev->dev, "enetsw");
+ 	if (IS_ERR(priv->mac_clk)) {
+ 		ret = PTR_ERR(priv->mac_clk);
+ 		goto out;
+ 	}
+ 	ret = clk_prepare_enable(priv->mac_clk);
+ 	if (ret)
+ 		goto out;
+ 
+ 	priv->rx_chan = 0;
+ 	priv->tx_chan = 1;
+ 	spin_lock_init(&priv->rx_lock);
+ 
+ 	/* init rx timeout (used for oom) */
+ 	timer_setup(&priv->rx_timeout, bcm_enet_refill_rx_timer, 0);
+ 
+ 	/* register netdevice */
+ 	dev->netdev_ops = &bcm_enetsw_ops;
+ 	netif_napi_add(dev, &priv->napi, bcm_enet_poll, 16);
+ 	dev->ethtool_ops = &bcm_enetsw_ethtool_ops;
+ 	SET_NETDEV_DEV(dev, &pdev->dev);
+ 
+ 	spin_lock_init(&priv->enetsw_mdio_lock);
+ 
+ 	ret = register_netdev(dev);
+ 	if (ret)
+ 		goto out_disable_clk;
+ 
+ 	netif_carrier_off(dev);
+ 	platform_set_drvdata(pdev, dev);
+ 	priv->pdev = pdev;
+ 	priv->net_dev = dev;
+ 
+ 	return 0;
+ 
+ out_disable_clk:
+ 	clk_disable_unprepare(priv->mac_clk);
+ out:
+ 	free_netdev(dev);
+ 	return ret;
+ }
+ 
+ 
+ /* exit func, stops hardware and unregisters netdevice */
+ static int bcm_enetsw_remove(struct platform_device *pdev)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	struct net_device *dev;
+ 
+ 	/* stop netdevice */
+ 	dev = platform_get_drvdata(pdev);
+ 	priv = netdev_priv(dev);
+ 	unregister_netdev(dev);
+ 
+ 	clk_disable_unprepare(priv->mac_clk);
+ 
+ 	free_netdev(dev);
+ 	return 0;
+ }
+ 
+ struct platform_driver bcm63xx_enetsw_driver = {
+ 	.probe	= bcm_enetsw_probe,
+ 	.remove	= bcm_enetsw_remove,
+ 	.driver	= {
+ 		.name	= "bcm63xx_enetsw",
+ 		.owner  = THIS_MODULE,
+ 	},
+ };
+ 
+ /* reserve & remap memory space shared between all macs */
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  static int bcm_enet_shared_probe(struct platform_device *pdev)
  {
  	struct resource *res;
diff --cc drivers/net/ethernet/jme.c
index dac58884674e,06ff185eb188..000000000000
--- a/drivers/net/ethernet/jme.c
+++ b/drivers/net/ethernet/jme.c
@@@ -583,8 -589,9 +583,14 @@@ jme_setup_tx_resources(struct jme_adapt
  	atomic_set(&txring->next_to_clean, 0);
  	atomic_set(&txring->nr_free, jme->tx_ring_size);
  
++<<<<<<< HEAD
 +	txring->bufinf		= kmalloc(sizeof(struct jme_buffer_info) *
 +					jme->tx_ring_size, GFP_ATOMIC);
++=======
+ 	txring->bufinf		= kcalloc(jme->tx_ring_size,
+ 						sizeof(struct jme_buffer_info),
+ 						GFP_ATOMIC);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (unlikely(!(txring->bufinf)))
  		goto err_free_txring;
  
@@@ -845,8 -839,9 +851,14 @@@ jme_setup_rx_resources(struct jme_adapt
  	rxring->next_to_use	= 0;
  	atomic_set(&rxring->next_to_clean, 0);
  
++<<<<<<< HEAD
 +	rxring->bufinf		= kmalloc(sizeof(struct jme_buffer_info) *
 +					jme->rx_ring_size, GFP_ATOMIC);
++=======
+ 	rxring->bufinf		= kcalloc(jme->rx_ring_size,
+ 						sizeof(struct jme_buffer_info),
+ 						GFP_ATOMIC);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (unlikely(!(rxring->bufinf)))
  		goto err_free_rxring;
  
diff --cc drivers/net/phy/dp83640.c
index 7490b6c866e6,79e9b103188b..000000000000
--- a/drivers/net/phy/dp83640.c
+++ b/drivers/net/phy/dp83640.c
@@@ -947,6 -1097,14 +947,17 @@@ static struct dp83640_clock *dp83640_cl
  	if (!clock)
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	clock->caps.pin_config = kcalloc(DP83640_N_PINS,
+ 					 sizeof(struct ptp_pin_desc),
+ 					 GFP_KERNEL);
+ 	if (!clock->caps.pin_config) {
+ 		kfree(clock);
+ 		clock = NULL;
+ 		goto out;
+ 	}
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	dp83640_clock_init(clock, bus);
  	list_add_tail(&phyter_clocks, &clock->list);
  out:
diff --cc drivers/net/virtio_net.c
index da63bcba4f5b,b6c9a2af3732..000000000000
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@@ -1413,15 -2552,22 +1413,25 @@@ static int virtnet_find_vqs(struct virt
  		    virtio_has_feature(vi->vdev, VIRTIO_NET_F_CTRL_VQ);
  
  	/* Allocate space for find_vqs parameters */
- 	vqs = kzalloc(total_vqs * sizeof(*vqs), GFP_KERNEL);
+ 	vqs = kcalloc(total_vqs, sizeof(*vqs), GFP_KERNEL);
  	if (!vqs)
  		goto err_vq;
 -	callbacks = kmalloc_array(total_vqs, sizeof(*callbacks), GFP_KERNEL);
 +	callbacks = kmalloc(total_vqs * sizeof(*callbacks), GFP_KERNEL);
  	if (!callbacks)
  		goto err_callback;
 -	names = kmalloc_array(total_vqs, sizeof(*names), GFP_KERNEL);
 +	names = kmalloc(total_vqs * sizeof(*names), GFP_KERNEL);
  	if (!names)
  		goto err_names;
++<<<<<<< HEAD
++=======
+ 	if (!vi->big_packets || vi->mergeable_rx_bufs) {
+ 		ctx = kcalloc(total_vqs, sizeof(*ctx), GFP_KERNEL);
+ 		if (!ctx)
+ 			goto err_ctx;
+ 	} else {
+ 		ctx = NULL;
+ 	}
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  
  	/* Parameters for control virtqueue, if any */
  	if (vi->has_cvq) {
@@@ -1475,10 -2623,13 +1485,17 @@@ static int virtnet_alloc_queues(struct 
  {
  	int i;
  
++<<<<<<< HEAD
 +	vi->sq = kzalloc(sizeof(*vi->sq) * vi->max_queue_pairs, GFP_KERNEL);
++=======
+ 	vi->ctrl = kzalloc(sizeof(*vi->ctrl), GFP_KERNEL);
+ 	if (!vi->ctrl)
+ 		goto err_ctrl;
+ 	vi->sq = kcalloc(vi->max_queue_pairs, sizeof(*vi->sq), GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!vi->sq)
  		goto err_sq;
- 	vi->rq = kzalloc(sizeof(*vi->rq) * vi->max_queue_pairs, GFP_KERNEL);
+ 	vi->rq = kcalloc(vi->max_queue_pairs, sizeof(*vi->rq), GFP_KERNEL);
  	if (!vi->rq)
  		goto err_rq;
  
diff --cc drivers/rapidio/rio-scan.c
index 4c15dbf81087,fd7b517132ac..000000000000
--- a/drivers/rapidio/rio-scan.c
+++ b/drivers/rapidio/rio-scan.c
@@@ -432,11 -423,11 +432,18 @@@ static struct rio_dev *rio_setup_device
  	/* If a PE has both switch and other functions, show it as a switch */
  	if (rio_is_switch(rdev)) {
  		rswitch = rdev->rswitch;
 +		rswitch->switchid = rdev->comp_tag & RIO_CTAG_UDEVID;
  		rswitch->port_ok = 0;
++<<<<<<< HEAD
 +		rswitch->route_table = kzalloc(sizeof(u8)*
 +					RIO_MAX_ROUTE_ENTRIES(port->sys_size),
 +					GFP_KERNEL);
++=======
+ 		spin_lock_init(&rswitch->lock);
+ 		rswitch->route_table =
+ 			kzalloc(RIO_MAX_ROUTE_ENTRIES(port->sys_size),
+ 				GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		if (!rswitch->route_table)
  			goto cleanup;
  		/* Initialize switch route table */
diff --cc drivers/regulator/s2mps11.c
index cd9ea2ea1826,b4e588cce03d..000000000000
--- a/drivers/regulator/s2mps11.c
+++ b/drivers/regulator/s2mps11.c
@@@ -250,52 -1106,111 +250,123 @@@ static int s2mps11_pmic_probe(struct pl
  	if (!s2mps11)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	s2mps11->dev_type = platform_get_device_id(pdev)->driver_data;
+ 	switch (s2mps11->dev_type) {
+ 	case S2MPS11X:
+ 		rdev_num = ARRAY_SIZE(s2mps11_regulators);
+ 		regulators = s2mps11_regulators;
+ 		BUILD_BUG_ON(S2MPS_REGULATOR_MAX < ARRAY_SIZE(s2mps11_regulators));
+ 		break;
+ 	case S2MPS13X:
+ 		rdev_num = ARRAY_SIZE(s2mps13_regulators);
+ 		regulators = s2mps13_regulators;
+ 		BUILD_BUG_ON(S2MPS_REGULATOR_MAX < ARRAY_SIZE(s2mps13_regulators));
+ 		break;
+ 	case S2MPS14X:
+ 		rdev_num = ARRAY_SIZE(s2mps14_regulators);
+ 		regulators = s2mps14_regulators;
+ 		BUILD_BUG_ON(S2MPS_REGULATOR_MAX < ARRAY_SIZE(s2mps14_regulators));
+ 		break;
+ 	case S2MPS15X:
+ 		rdev_num = ARRAY_SIZE(s2mps15_regulators);
+ 		regulators = s2mps15_regulators;
+ 		BUILD_BUG_ON(S2MPS_REGULATOR_MAX < ARRAY_SIZE(s2mps15_regulators));
+ 		break;
+ 	case S2MPU02:
+ 		rdev_num = ARRAY_SIZE(s2mpu02_regulators);
+ 		regulators = s2mpu02_regulators;
+ 		BUILD_BUG_ON(S2MPS_REGULATOR_MAX < ARRAY_SIZE(s2mpu02_regulators));
+ 		break;
+ 	default:
+ 		dev_err(&pdev->dev, "Invalid device type: %u\n",
+ 				    s2mps11->dev_type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	s2mps11->ext_control_gpio = devm_kmalloc(&pdev->dev,
+ 			sizeof(*s2mps11->ext_control_gpio) * rdev_num,
+ 			GFP_KERNEL);
+ 	if (!s2mps11->ext_control_gpio)
+ 		return -ENOMEM;
+ 	/*
+ 	 * 0 is a valid GPIO so initialize all GPIO-s to negative value
+ 	 * to indicate that external control won't be used for this regulator.
+ 	 */
+ 	for (i = 0; i < rdev_num; i++)
+ 		s2mps11->ext_control_gpio[i] = -EINVAL;
+ 
+ 	if (!iodev->dev->of_node) {
+ 		if (iodev->pdata) {
+ 			pdata = iodev->pdata;
+ 			goto common_reg;
+ 		} else {
+ 			dev_err(pdev->dev.parent,
+ 				"Platform data or DT node not supplied\n");
+ 			return -ENODEV;
+ 		}
+ 	}
+ 
+ 	rdata = kcalloc(rdev_num, sizeof(*rdata), GFP_KERNEL);
+ 	if (!rdata)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < rdev_num; i++)
+ 		rdata[i].name = regulators[i].name;
+ 
+ 	ret = s2mps11_pmic_dt_parse(pdev, rdata, s2mps11, rdev_num);
+ 	if (ret)
+ 		goto out;
+ 
+ common_reg:
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	platform_set_drvdata(pdev, s2mps11);
  
 -	config.dev = &pdev->dev;
 -	config.regmap = iodev->regmap_pmic;
 -	config.driver_data = s2mps11;
 -	config.ena_gpio_flags = GPIOF_OUT_INIT_HIGH;
 -	config.ena_gpio_initialized = true;
 -	for (i = 0; i < rdev_num; i++) {
 -		struct regulator_dev *regulator;
 +	s2mps11->ramp_delay2 = pdata->buck2_ramp_delay;
 +	s2mps11->ramp_delay34 = pdata->buck34_ramp_delay;
 +	s2mps11->ramp_delay5 = pdata->buck5_ramp_delay;
 +	s2mps11->ramp_delay16 = pdata->buck16_ramp_delay;
 +	s2mps11->ramp_delay7810 = pdata->buck7810_ramp_delay;
 +	s2mps11->ramp_delay9 = pdata->buck9_ramp_delay;
 +
 +	s2mps11->buck6_ramp = pdata->buck6_ramp_enable;
 +	s2mps11->buck2_ramp = pdata->buck2_ramp_enable;
 +	s2mps11->buck3_ramp = pdata->buck3_ramp_enable;
 +	s2mps11->buck4_ramp = pdata->buck4_ramp_enable;
 +
 +	ramp_enable = (s2mps11->buck2_ramp << 3) | (s2mps11->buck3_ramp << 2) |
 +		(s2mps11->buck4_ramp << 1) | s2mps11->buck6_ramp ;
 +
 +	if (ramp_enable) {
 +		if (s2mps11->buck2_ramp)
 +			ramp_reg |= get_ramp_delay(s2mps11->ramp_delay2) << 6;
 +		if (s2mps11->buck3_ramp || s2mps11->buck4_ramp)
 +			ramp_reg |= get_ramp_delay(s2mps11->ramp_delay34) << 4;
 +		sec_reg_write(iodev, S2MPS11_REG_RAMP, ramp_reg | ramp_enable);
 +	}
  
 -		if (pdata) {
 -			config.init_data = pdata->regulators[i].initdata;
 -			config.of_node = pdata->regulators[i].reg_node;
 -		} else {
 -			config.init_data = rdata[i].init_data;
 -			config.of_node = rdata[i].of_node;
 -		}
 -		config.ena_gpio = s2mps11->ext_control_gpio[i];
 +	ramp_reg &= 0x00;
 +	ramp_reg |= get_ramp_delay(s2mps11->ramp_delay5) << 6;
 +	ramp_reg |= get_ramp_delay(s2mps11->ramp_delay16) << 4;
 +	ramp_reg |= get_ramp_delay(s2mps11->ramp_delay7810) << 2;
 +	ramp_reg |= get_ramp_delay(s2mps11->ramp_delay9);
 +	sec_reg_write(iodev, S2MPS11_REG_RAMP_BUCK, ramp_reg);
 +
 +	for (i = 0; i < S2MPS11_REGULATOR_MAX; i++) {
  
 -		regulator = devm_regulator_register(&pdev->dev,
 -						&regulators[i], &config);
 -		if (IS_ERR(regulator)) {
 -			ret = PTR_ERR(regulator);
 +		config.dev = &pdev->dev;
 +		config.regmap = iodev->regmap;
 +		config.init_data = pdata->regulators[i].initdata;
 +		config.driver_data = s2mps11;
 +
 +		s2mps11->rdev[i] = regulator_register(&regulators[i], &config);
 +		if (IS_ERR(s2mps11->rdev[i])) {
 +			ret = PTR_ERR(s2mps11->rdev[i]);
  			dev_err(&pdev->dev, "regulator init failed for %d\n",
  				i);
 -			goto out;
 -		}
 -
 -		if (gpio_is_valid(s2mps11->ext_control_gpio[i])) {
 -			ret = s2mps14_pmic_enable_ext_control(s2mps11,
 -					regulator);
 -			if (ret < 0) {
 -				dev_err(&pdev->dev,
 -						"failed to enable GPIO control over %s: %d\n",
 -						regulator->desc->name, ret);
 -				goto out;
 -			}
 +			s2mps11->rdev[i] = NULL;
 +			goto err;
  		}
  	}
  
diff --cc drivers/s390/char/zcore.c
index d55aa4409397,76d3c50bf078..000000000000
--- a/drivers/s390/char/zcore.c
+++ b/drivers/s390/char/zcore.c
@@@ -409,28 -148,19 +409,32 @@@ static ssize_t zcore_memmap_read(struc
  
  static int zcore_memmap_open(struct inode *inode, struct file *filp)
  {
 -	struct memblock_region *reg;
 +	int i;
  	char *buf;
 -	int i = 0;
 +	struct mem_chunk *chunk_array;
  
++<<<<<<< HEAD
 +	chunk_array = kzalloc(MEMORY_CHUNKS * sizeof(struct mem_chunk),
 +			      GFP_KERNEL);
 +	if (!chunk_array)
 +		return -ENOMEM;
 +	detect_memory_layout(chunk_array, 0);
 +	buf = kzalloc(MEMORY_CHUNKS * CHUNK_INFO_SIZE, GFP_KERNEL);
++=======
+ 	buf = kcalloc(memblock.memory.cnt, CHUNK_INFO_SIZE, GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!buf) {
 +		kfree(chunk_array);
  		return -ENOMEM;
  	}
 -	for_each_memblock(memory, reg) {
 -		sprintf(buf + (i++ * CHUNK_INFO_SIZE), "%016llx %016llx ",
 -			(unsigned long long) reg->base,
 -			(unsigned long long) reg->size);
 +	for (i = 0; i < MEMORY_CHUNKS; i++) {
 +		sprintf(buf + (i * CHUNK_INFO_SIZE), "%016llx %016llx ",
 +			(unsigned long long) chunk_array[i].addr,
 +			(unsigned long long) chunk_array[i].size);
 +		if (chunk_array[i].size == 0)
 +			break;
  	}
 +	kfree(chunk_array);
  	filp->private_data = buf;
  	return nonseekable_open(inode, filp);
  }
diff --cc drivers/s390/crypto/pkey_api.c
index dae0c82dffdd,3929c8be8098..000000000000
--- a/drivers/s390/crypto/pkey_api.c
+++ b/drivers/s390/crypto/pkey_api.c
@@@ -127,10 -121,9 +127,14 @@@ static int alloc_and_prep_cprbmem(size_
  	 * allocate consecutive memory for request CPRB, request param
  	 * block, reply CPRB and reply param block
  	 */
++<<<<<<< HEAD
 +	cprbmem = kmalloc(2 * cprbplusparamblen, GFP_KERNEL);
++=======
+ 	cprbmem = kcalloc(2, cprbplusparamblen, GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!cprbmem)
  		return -ENOMEM;
 +	memset(cprbmem, 0, 2 * cprbplusparamblen);
  
  	preqcblk = (struct CPRBX *) cprbmem;
  	prepcblk = (struct CPRBX *) (cprbmem + cprbplusparamblen);
diff --cc drivers/scsi/BusLogic.c
index 344d87599cd2,0d4ffe0ae306..000000000000
--- a/drivers/scsi/BusLogic.c
+++ b/drivers/scsi/BusLogic.c
@@@ -2186,15 -2360,17 +2186,24 @@@ static int __init BusLogic_init(void
  
  #ifdef MODULE
  	if (BusLogic)
 -		blogic_setup(BusLogic);
 +		BusLogic_Setup(BusLogic);
  #endif
  
 -	if (blogic_probe_options.noprobe)
 +	if (BusLogic_ProbeOptions.NoProbe)
  		return -ENODEV;
++<<<<<<< HEAD
 +	BusLogic_ProbeInfoList =
 +	    kzalloc(BusLogic_MaxHostAdapters * sizeof(struct BusLogic_ProbeInfo), GFP_KERNEL);
 +	if (BusLogic_ProbeInfoList == NULL) {
 +		BusLogic_Error("BusLogic: Unable to allocate Probe Info List\n", NULL);
++=======
+ 	blogic_probeinfo_list =
+ 	    kcalloc(BLOGIC_MAX_ADAPTERS, sizeof(struct blogic_probeinfo),
+ 			    GFP_KERNEL);
+ 	if (blogic_probeinfo_list == NULL) {
+ 		blogic_err("BusLogic: Unable to allocate Probe Info List\n",
+ 				NULL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		return -ENOMEM;
  	}
  
diff --cc drivers/scsi/aic7xxx/aic7xxx_core.c
index 10172a3af1b9,915a34f141e4..000000000000
--- a/drivers/scsi/aic7xxx/aic7xxx_core.c
+++ b/drivers/scsi/aic7xxx/aic7xxx_core.c
@@@ -4780,10 -4779,10 +4780,15 @@@ ahc_init_scbdata(struct ahc_softc *ahc
  	SLIST_INIT(&scb_data->sg_maps);
  
  	/* Allocate SCB resources */
++<<<<<<< HEAD
 +	scb_data->scbarray = kmalloc(sizeof(struct scb) * AHC_SCB_MAX_ALLOC, GFP_ATOMIC);
++=======
+ 	scb_data->scbarray = kcalloc(AHC_SCB_MAX_ALLOC, sizeof(struct scb),
+ 				     GFP_ATOMIC);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (scb_data->scbarray == NULL)
  		return (ENOMEM);
 +	memset(scb_data->scbarray, 0, sizeof(struct scb) * AHC_SCB_MAX_ALLOC);
  
  	/* Determine the number of hardware SCBs and initialize them */
  
diff --cc drivers/scsi/scsi_debug.c
index 7f28c0f429a8,798a6afa4cbf..000000000000
--- a/drivers/scsi/scsi_debug.c
+++ b/drivers/scsi/scsi_debug.c
@@@ -2177,6 -3307,184 +2177,187 @@@ out
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int resp_write_same_10(struct scsi_cmnd *scp,
+ 			      struct sdebug_dev_info *devip)
+ {
+ 	u8 *cmd = scp->cmnd;
+ 	u32 lba;
+ 	u16 num;
+ 	u32 ei_lba = 0;
+ 	bool unmap = false;
+ 
+ 	if (cmd[1] & 0x8) {
+ 		if (sdebug_lbpws10 == 0) {
+ 			mk_sense_invalid_fld(scp, SDEB_IN_CDB, 1, 3);
+ 			return check_condition_result;
+ 		} else
+ 			unmap = true;
+ 	}
+ 	lba = get_unaligned_be32(cmd + 2);
+ 	num = get_unaligned_be16(cmd + 7);
+ 	if (num > sdebug_write_same_length) {
+ 		mk_sense_invalid_fld(scp, SDEB_IN_CDB, 7, -1);
+ 		return check_condition_result;
+ 	}
+ 	return resp_write_same(scp, lba, num, ei_lba, unmap, false);
+ }
+ 
+ static int resp_write_same_16(struct scsi_cmnd *scp,
+ 			      struct sdebug_dev_info *devip)
+ {
+ 	u8 *cmd = scp->cmnd;
+ 	u64 lba;
+ 	u32 num;
+ 	u32 ei_lba = 0;
+ 	bool unmap = false;
+ 	bool ndob = false;
+ 
+ 	if (cmd[1] & 0x8) {	/* UNMAP */
+ 		if (sdebug_lbpws == 0) {
+ 			mk_sense_invalid_fld(scp, SDEB_IN_CDB, 1, 3);
+ 			return check_condition_result;
+ 		} else
+ 			unmap = true;
+ 	}
+ 	if (cmd[1] & 0x1)  /* NDOB (no data-out buffer, assumes zeroes) */
+ 		ndob = true;
+ 	lba = get_unaligned_be64(cmd + 2);
+ 	num = get_unaligned_be32(cmd + 10);
+ 	if (num > sdebug_write_same_length) {
+ 		mk_sense_invalid_fld(scp, SDEB_IN_CDB, 10, -1);
+ 		return check_condition_result;
+ 	}
+ 	return resp_write_same(scp, lba, num, ei_lba, unmap, ndob);
+ }
+ 
+ /* Note the mode field is in the same position as the (lower) service action
+  * field. For the Report supported operation codes command, SPC-4 suggests
+  * each mode of this command should be reported separately; for future. */
+ static int resp_write_buffer(struct scsi_cmnd *scp,
+ 			     struct sdebug_dev_info *devip)
+ {
+ 	u8 *cmd = scp->cmnd;
+ 	struct scsi_device *sdp = scp->device;
+ 	struct sdebug_dev_info *dp;
+ 	u8 mode;
+ 
+ 	mode = cmd[1] & 0x1f;
+ 	switch (mode) {
+ 	case 0x4:	/* download microcode (MC) and activate (ACT) */
+ 		/* set UAs on this device only */
+ 		set_bit(SDEBUG_UA_BUS_RESET, devip->uas_bm);
+ 		set_bit(SDEBUG_UA_MICROCODE_CHANGED, devip->uas_bm);
+ 		break;
+ 	case 0x5:	/* download MC, save and ACT */
+ 		set_bit(SDEBUG_UA_MICROCODE_CHANGED_WO_RESET, devip->uas_bm);
+ 		break;
+ 	case 0x6:	/* download MC with offsets and ACT */
+ 		/* set UAs on most devices (LUs) in this target */
+ 		list_for_each_entry(dp,
+ 				    &devip->sdbg_host->dev_info_list,
+ 				    dev_list)
+ 			if (dp->target == sdp->id) {
+ 				set_bit(SDEBUG_UA_BUS_RESET, dp->uas_bm);
+ 				if (devip != dp)
+ 					set_bit(SDEBUG_UA_MICROCODE_CHANGED,
+ 						dp->uas_bm);
+ 			}
+ 		break;
+ 	case 0x7:	/* download MC with offsets, save, and ACT */
+ 		/* set UA on all devices (LUs) in this target */
+ 		list_for_each_entry(dp,
+ 				    &devip->sdbg_host->dev_info_list,
+ 				    dev_list)
+ 			if (dp->target == sdp->id)
+ 				set_bit(SDEBUG_UA_MICROCODE_CHANGED_WO_RESET,
+ 					dp->uas_bm);
+ 		break;
+ 	default:
+ 		/* do nothing for this command for other mode values */
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static int resp_comp_write(struct scsi_cmnd *scp,
+ 			   struct sdebug_dev_info *devip)
+ {
+ 	u8 *cmd = scp->cmnd;
+ 	u8 *arr;
+ 	u8 *fake_storep_hold;
+ 	u64 lba;
+ 	u32 dnum;
+ 	u32 lb_size = sdebug_sector_size;
+ 	u8 num;
+ 	unsigned long iflags;
+ 	int ret;
+ 	int retval = 0;
+ 
+ 	lba = get_unaligned_be64(cmd + 2);
+ 	num = cmd[13];		/* 1 to a maximum of 255 logical blocks */
+ 	if (0 == num)
+ 		return 0;	/* degenerate case, not an error */
+ 	if (sdebug_dif == T10_PI_TYPE2_PROTECTION &&
+ 	    (cmd[1] & 0xe0)) {
+ 		mk_sense_invalid_opcode(scp);
+ 		return check_condition_result;
+ 	}
+ 	if ((sdebug_dif == T10_PI_TYPE1_PROTECTION ||
+ 	     sdebug_dif == T10_PI_TYPE3_PROTECTION) &&
+ 	    (cmd[1] & 0xe0) == 0)
+ 		sdev_printk(KERN_ERR, scp->device, "Unprotected WR "
+ 			    "to DIF device\n");
+ 
+ 	/* inline check_device_access_params() */
+ 	if (lba + num > sdebug_capacity) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, LBA_OUT_OF_RANGE, 0);
+ 		return check_condition_result;
+ 	}
+ 	/* transfer length excessive (tie in to block limits VPD page) */
+ 	if (num > sdebug_store_sectors) {
+ 		/* needs work to find which cdb byte 'num' comes from */
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+ 		return check_condition_result;
+ 	}
+ 	dnum = 2 * num;
+ 	arr = kcalloc(lb_size, dnum, GFP_ATOMIC);
+ 	if (NULL == arr) {
+ 		mk_sense_buffer(scp, ILLEGAL_REQUEST, INSUFF_RES_ASC,
+ 				INSUFF_RES_ASCQ);
+ 		return check_condition_result;
+ 	}
+ 
+ 	write_lock_irqsave(&atomic_rw, iflags);
+ 
+ 	/* trick do_device_access() to fetch both compare and write buffers
+ 	 * from data-in into arr. Safe (atomic) since write_lock held. */
+ 	fake_storep_hold = fake_storep;
+ 	fake_storep = arr;
+ 	ret = do_device_access(scp, 0, 0, dnum, true);
+ 	fake_storep = fake_storep_hold;
+ 	if (ret == -1) {
+ 		retval = DID_ERROR << 16;
+ 		goto cleanup;
+ 	} else if (sdebug_verbose && (ret < (dnum * lb_size)))
+ 		sdev_printk(KERN_INFO, scp->device, "%s: compare_write: cdb "
+ 			    "indicated=%u, IO sent=%d bytes\n", my_name,
+ 			    dnum * lb_size, ret);
+ 	if (!comp_write_worker(lba, num, arr)) {
+ 		mk_sense_buffer(scp, MISCOMPARE, MISCOMPARE_VERIFY_ASC, 0);
+ 		retval = check_condition_result;
+ 		goto cleanup;
+ 	}
+ 	if (scsi_debug_lbp())
+ 		map_region(lba, num);
+ cleanup:
+ 	write_unlock_irqrestore(&atomic_rw, iflags);
+ 	kfree(arr);
+ 	return retval;
+ }
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  struct unmap_block_desc {
  	__be64	lba;
  	__be32	blocks;
diff --cc drivers/scsi/sg.c
index 4ce04123d0c8,53ae52dbff84..000000000000
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@@ -1014,10 -1044,9 +1014,15 @@@ sg_ioctl(struct file *filp, unsigned in
  			return -EFAULT;
  		else {
  			sg_req_info_t *rinfo;
 +			unsigned int ms;
  
++<<<<<<< HEAD
 +			rinfo = kmalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,
 +								GFP_KERNEL);
++=======
+ 			rinfo = kcalloc(SG_MAX_QUEUE, SZ_SG_REQ_INFO,
+ 					GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  			if (!rinfo)
  				return -ENOMEM;
  			read_lock_irqsave(&sfp->rq_list_lock, iflags);
diff --cc drivers/scsi/st.c
index 93b0cd27c3c8,50c66ccc4b41..000000000000
--- a/drivers/scsi/st.c
+++ b/drivers/scsi/st.c
@@@ -3885,8 -3888,8 +3885,13 @@@ static struct st_buffer *new_tape_buffe
  	tb->dma = need_dma;
  	tb->buffer_size = 0;
  
++<<<<<<< HEAD
 +	tb->reserved_pages = kzalloc(max_sg * sizeof(struct page *),
 +				     GFP_ATOMIC);
++=======
+ 	tb->reserved_pages = kcalloc(max_sg, sizeof(struct page *),
+ 				     GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!tb->reserved_pages) {
  		kfree(tb);
  		return NULL;
diff --cc drivers/staging/unisys/visorhba/visorhba_main.c
index acd5dd585846,4fc521c51c0e..000000000000
--- a/drivers/staging/unisys/visorhba/visorhba_main.c
+++ b/drivers/staging/unisys/visorhba/visorhba_main.c
@@@ -811,6 -865,10 +811,13 @@@ do_scsi_nolinuxstat(struct uiscmdrsp *c
  		if (cmdrsp->scsi.no_disk_result == 0)
  			return;
  
++<<<<<<< HEAD
++=======
+ 		buf = kzalloc(36, GFP_KERNEL);
+ 		if (!buf)
+ 			return;
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		/* Linux scsi code wants a device at Lun 0
  		 * to issue report luns, but we don't want
  		 * a disk there so we'll present a processor
diff --cc drivers/target/target_core_transport.c
index b9aa35b66946,efe8214f2df3..000000000000
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@@ -252,8 -250,8 +252,13 @@@ int transport_alloc_session_tags(struc
  {
  	int rc;
  
++<<<<<<< HEAD
 +	se_sess->sess_cmd_map = kzalloc(tag_num * tag_size,
 +					GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);
++=======
+ 	se_sess->sess_cmd_map = kcalloc(tag_size, tag_num,
+ 					GFP_KERNEL | __GFP_NOWARN | __GFP_RETRY_MAYFAIL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!se_sess->sess_cmd_map) {
  		se_sess->sess_cmd_map = vzalloc(tag_num * tag_size);
  		if (!se_sess->sess_cmd_map) {
diff --cc drivers/target/target_core_user.c
index b64dfbc72dae,7f96dfa32b9c..000000000000
--- a/drivers/target/target_core_user.c
+++ b/drivers/target/target_core_user.c
@@@ -1791,10 -1717,9 +1791,16 @@@ static int tcmu_configure_device(struc
  
  	info = &udev->uio_info;
  
++<<<<<<< HEAD
 +	mutex_lock(&udev->cmdr_lock);
 +	udev->data_bitmap = kzalloc(BITS_TO_LONGS(udev->max_blocks) *
 +				    sizeof(unsigned long), GFP_KERNEL);
 +	mutex_unlock(&udev->cmdr_lock);
++=======
+ 	udev->data_bitmap = kcalloc(BITS_TO_LONGS(udev->max_blocks),
+ 				    sizeof(unsigned long),
+ 				    GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!udev->data_bitmap) {
  		ret = -ENOMEM;
  		goto err_bitmap_alloc;
diff --cc drivers/tty/goldfish.c
index f17d2e4ee2ca,37caba7c3aff..000000000000
--- a/drivers/tty/goldfish.c
+++ b/drivers/tty/goldfish.c
@@@ -173,8 -245,10 +173,15 @@@ static int goldfish_tty_create_driver(v
  	int ret;
  	struct tty_driver *tty;
  
++<<<<<<< HEAD
 +	goldfish_ttys = kzalloc(sizeof(*goldfish_ttys) * goldfish_tty_line_count, GFP_KERNEL);
 +	if(goldfish_ttys == NULL) {
++=======
+ 	goldfish_ttys = kcalloc(goldfish_tty_line_count,
+ 				sizeof(*goldfish_ttys),
+ 				GFP_KERNEL);
+ 	if (goldfish_ttys == NULL) {
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		ret = -ENOMEM;
  		goto err_alloc_goldfish_ttys_failed;
  	}
diff --cc drivers/usb/gadget/fsl_udc_core.c
index a766a4ca1cb7,be59309e848c..000000000000
--- a/drivers/usb/gadget/fsl_udc_core.c
+++ b/drivers/usb/gadget/fsl_udc_core.c
@@@ -2248,14 -2243,12 +2248,19 @@@ static int __init struct_udc_setup(stru
  	struct fsl_usb2_platform_data *pdata;
  	size_t size;
  
 -	pdata = dev_get_platdata(&pdev->dev);
 +	pdata = pdev->dev.platform_data;
  	udc->phy_mode = pdata->phy_mode;
  
++<<<<<<< HEAD:drivers/usb/gadget/fsl_udc_core.c
 +	udc->eps = kzalloc(sizeof(struct fsl_ep) * udc->max_ep, GFP_KERNEL);
 +	if (!udc->eps) {
 +		ERR("malloc fsl_ep failed\n");
++=======
+ 	udc->eps = kcalloc(udc->max_ep, sizeof(struct fsl_ep), GFP_KERNEL);
+ 	if (!udc->eps)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc()):drivers/usb/gadget/udc/fsl_udc_core.c
  		return -1;
 +	}
  
  	/* initialized QHs, take care of alignment */
  	size = udc->max_ep * sizeof(struct ep_queue_head);
diff --cc drivers/usb/renesas_usbhs/pipe.c
index 7926e1c700f1,c4922b96c93b..000000000000
--- a/drivers/usb/renesas_usbhs/pipe.c
+++ b/drivers/usb/renesas_usbhs/pipe.c
@@@ -794,11 -803,10 +794,17 @@@ int usbhs_pipe_probe(struct usbhs_priv 
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	info->pipe = kzalloc(sizeof(struct usbhs_pipe) * pipe_size, GFP_KERNEL);
 +	if (!info->pipe) {
 +		dev_err(dev, "Could not allocate pipe\n");
++=======
+ 	info->pipe = kcalloc(pipe_size, sizeof(struct usbhs_pipe),
+ 			     GFP_KERNEL);
+ 	if (!info->pipe)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		return -ENOMEM;
 +	}
  
  	info->size = pipe_size;
  
diff --cc drivers/vhost/scsi.c
index 2b14ae4c9782,17fcd3b2e686..000000000000
--- a/drivers/vhost/scsi.c
+++ b/drivers/vhost/scsi.c
@@@ -1445,50 -1603,134 +1445,152 @@@ static int tcm_vhost_port_link(struct s
  	return 0;
  }
  
 -static void vhost_scsi_port_unlink(struct se_portal_group *se_tpg,
 -				  struct se_lun *lun)
 +static void tcm_vhost_port_unlink(struct se_portal_group *se_tpg,
 +	struct se_lun *lun)
  {
 -	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
 -				struct vhost_scsi_tpg, se_tpg);
 +	struct tcm_vhost_tpg *tv_tpg = container_of(se_tpg,
 +				struct tcm_vhost_tpg, se_tpg);
  
 -	mutex_lock(&vhost_scsi_mutex);
 +	mutex_lock(&tcm_vhost_mutex);
  
 -	mutex_lock(&tpg->tv_tpg_mutex);
 -	tpg->tv_tpg_port_count--;
 -	mutex_unlock(&tpg->tv_tpg_mutex);
 +	mutex_lock(&tv_tpg->tv_tpg_mutex);
 +	tv_tpg->tv_tpg_port_count--;
 +	mutex_unlock(&tv_tpg->tv_tpg_mutex);
  
 -	vhost_scsi_hotunplug(tpg, lun);
 +	tcm_vhost_hotunplug(tv_tpg, lun);
  
 -	mutex_unlock(&vhost_scsi_mutex);
 +	mutex_unlock(&tcm_vhost_mutex);
  }
  
 -static void vhost_scsi_free_cmd_map_res(struct se_session *se_sess)
 +static int tcm_vhost_make_nexus(struct tcm_vhost_tpg *tv_tpg,
 +	const char *name)
  {
 -	struct vhost_scsi_cmd *tv_cmd;
 -	unsigned int i;
 -
 +	struct se_portal_group *se_tpg;
 +	struct tcm_vhost_nexus *tv_nexus;
 +
++<<<<<<< HEAD
 +	mutex_lock(&tv_tpg->tv_tpg_mutex);
 +	if (tv_tpg->tpg_nexus) {
 +		mutex_unlock(&tv_tpg->tv_tpg_mutex);
 +		pr_debug("tv_tpg->tpg_nexus already exists\n");
++=======
+ 	if (!se_sess->sess_cmd_map)
+ 		return;
+ 
+ 	for (i = 0; i < VHOST_SCSI_DEFAULT_TAGS; i++) {
+ 		tv_cmd = &((struct vhost_scsi_cmd *)se_sess->sess_cmd_map)[i];
+ 
+ 		kfree(tv_cmd->tvc_sgl);
+ 		kfree(tv_cmd->tvc_prot_sgl);
+ 		kfree(tv_cmd->tvc_upages);
+ 	}
+ }
+ 
+ static ssize_t vhost_scsi_tpg_attrib_fabric_prot_type_store(
+ 		struct config_item *item, const char *page, size_t count)
+ {
+ 	struct se_portal_group *se_tpg = attrib_to_tpg(item);
+ 	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
+ 				struct vhost_scsi_tpg, se_tpg);
+ 	unsigned long val;
+ 	int ret = kstrtoul(page, 0, &val);
+ 
+ 	if (ret) {
+ 		pr_err("kstrtoul() returned %d for fabric_prot_type\n", ret);
+ 		return ret;
+ 	}
+ 	if (val != 0 && val != 1 && val != 3) {
+ 		pr_err("Invalid vhost_scsi fabric_prot_type: %lu\n", val);
+ 		return -EINVAL;
+ 	}
+ 	tpg->tv_fabric_prot_type = val;
+ 
+ 	return count;
+ }
+ 
+ static ssize_t vhost_scsi_tpg_attrib_fabric_prot_type_show(
+ 		struct config_item *item, char *page)
+ {
+ 	struct se_portal_group *se_tpg = attrib_to_tpg(item);
+ 	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
+ 				struct vhost_scsi_tpg, se_tpg);
+ 
+ 	return sprintf(page, "%d\n", tpg->tv_fabric_prot_type);
+ }
+ 
+ CONFIGFS_ATTR(vhost_scsi_tpg_attrib_, fabric_prot_type);
+ 
+ static struct configfs_attribute *vhost_scsi_tpg_attrib_attrs[] = {
+ 	&vhost_scsi_tpg_attrib_attr_fabric_prot_type,
+ 	NULL,
+ };
+ 
+ static int vhost_scsi_nexus_cb(struct se_portal_group *se_tpg,
+ 			       struct se_session *se_sess, void *p)
+ {
+ 	struct vhost_scsi_cmd *tv_cmd;
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < VHOST_SCSI_DEFAULT_TAGS; i++) {
+ 		tv_cmd = &((struct vhost_scsi_cmd *)se_sess->sess_cmd_map)[i];
+ 
+ 		tv_cmd->tvc_sgl = kcalloc(VHOST_SCSI_PREALLOC_SGLS,
+ 					  sizeof(struct scatterlist),
+ 					  GFP_KERNEL);
+ 		if (!tv_cmd->tvc_sgl) {
+ 			pr_err("Unable to allocate tv_cmd->tvc_sgl\n");
+ 			goto out;
+ 		}
+ 
+ 		tv_cmd->tvc_upages = kcalloc(VHOST_SCSI_PREALLOC_UPAGES,
+ 					     sizeof(struct page *),
+ 					     GFP_KERNEL);
+ 		if (!tv_cmd->tvc_upages) {
+ 			pr_err("Unable to allocate tv_cmd->tvc_upages\n");
+ 			goto out;
+ 		}
+ 
+ 		tv_cmd->tvc_prot_sgl = kcalloc(VHOST_SCSI_PREALLOC_PROT_SGLS,
+ 					       sizeof(struct scatterlist),
+ 					       GFP_KERNEL);
+ 		if (!tv_cmd->tvc_prot_sgl) {
+ 			pr_err("Unable to allocate tv_cmd->tvc_prot_sgl\n");
+ 			goto out;
+ 		}
+ 	}
+ 	return 0;
+ out:
+ 	vhost_scsi_free_cmd_map_res(se_sess);
+ 	return -ENOMEM;
+ }
+ 
+ static int vhost_scsi_make_nexus(struct vhost_scsi_tpg *tpg,
+ 				const char *name)
+ {
+ 	struct vhost_scsi_nexus *tv_nexus;
+ 
+ 	mutex_lock(&tpg->tv_tpg_mutex);
+ 	if (tpg->tpg_nexus) {
+ 		mutex_unlock(&tpg->tv_tpg_mutex);
+ 		pr_debug("tpg->tpg_nexus already exists\n");
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		return -EEXIST;
  	}
 +	se_tpg = &tv_tpg->se_tpg;
  
 -	tv_nexus = kzalloc(sizeof(*tv_nexus), GFP_KERNEL);
 +	tv_nexus = kzalloc(sizeof(struct tcm_vhost_nexus), GFP_KERNEL);
  	if (!tv_nexus) {
 -		mutex_unlock(&tpg->tv_tpg_mutex);
 -		pr_err("Unable to allocate struct vhost_scsi_nexus\n");
 +		mutex_unlock(&tv_tpg->tv_tpg_mutex);
 +		pr_err("Unable to allocate struct tcm_vhost_nexus\n");
 +		return -ENOMEM;
 +	}
 +	/*
 +	 *  Initialize the struct se_session pointer
 +	 */
 +	tv_nexus->tvn_se_sess = transport_init_session();
 +	if (IS_ERR(tv_nexus->tvn_se_sess)) {
 +		mutex_unlock(&tv_tpg->tv_tpg_mutex);
 +		kfree(tv_nexus);
  		return -ENOMEM;
  	}
  	/*
diff --cc drivers/video/fbmon.c
index 6103fa6fb54f,852d86c1c527..000000000000
--- a/drivers/video/fbmon.c
+++ b/drivers/video/fbmon.c
@@@ -608,10 -620,7 +608,14 @@@ static struct fb_videomode *fb_create_m
  	int num = 0, i, first = 1;
  	int ver, rev;
  
++<<<<<<< HEAD:drivers/video/fbmon.c
 +	ver = edid[EDID_STRUCT_VERSION];
 +	rev = edid[EDID_STRUCT_REVISION];
 +
 +	mode = kzalloc(50 * sizeof(struct fb_videomode), GFP_KERNEL);
++=======
+ 	mode = kcalloc(50, sizeof(struct fb_videomode), GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc()):drivers/video/fbdev/core/fbmon.c
  	if (mode == NULL)
  		return NULL;
  
diff --cc fs/btrfs/check-integrity.c
index 7fbdc9157608,a3fdb4fe967d..000000000000
--- a/fs/btrfs/check-integrity.c
+++ b/fs/btrfs/check-integrity.c
@@@ -1632,10 -1601,10 +1632,17 @@@ static int btrfsic_read_block(struct bt
  		return -1;
  	}
  
++<<<<<<< HEAD
 +	num_pages = (block_ctx->len + (u64)PAGE_CACHE_SIZE - 1) >>
 +		    PAGE_CACHE_SHIFT;
 +	block_ctx->mem_to_free = kzalloc((sizeof(*block_ctx->datav) +
 +					  sizeof(*block_ctx->pagev)) *
++=======
+ 	num_pages = (block_ctx->len + (u64)PAGE_SIZE - 1) >>
+ 		    PAGE_SHIFT;
+ 	block_ctx->mem_to_free = kcalloc(sizeof(*block_ctx->datav) +
+ 						sizeof(*block_ctx->pagev),
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  					 num_pages, GFP_NOFS);
  	if (!block_ctx->mem_to_free)
  		return -ENOMEM;
diff --cc fs/cifs/cifssmb.c
index 5bc5bed0de12,42329b25877d..000000000000
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@@ -2046,12 -2076,22 +2046,26 @@@ cifs_writev_complete(struct work_struc
  struct cifs_writedata *
  cifs_writedata_alloc(unsigned int nr_pages, work_func_t complete)
  {
++<<<<<<< HEAD
++=======
+ 	struct page **pages =
+ 		kcalloc(nr_pages, sizeof(struct page *), GFP_NOFS);
+ 	if (pages)
+ 		return cifs_writedata_direct_alloc(pages, complete);
+ 
+ 	return NULL;
+ }
+ 
+ struct cifs_writedata *
+ cifs_writedata_direct_alloc(struct page **pages, work_func_t complete)
+ {
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	struct cifs_writedata *wdata;
  
 -	wdata = kzalloc(sizeof(*wdata), GFP_NOFS);
 +	/* writedata + number of page pointers */
 +	wdata = kzalloc(sizeof(*wdata) +
 +			sizeof(struct page *) * nr_pages, GFP_NOFS);
  	if (wdata != NULL) {
 -		wdata->pages = pages;
  		kref_init(&wdata->refcount);
  		INIT_LIST_HEAD(&wdata->list);
  		init_completion(&wdata->done);
diff --cc fs/cifs/file.c
index 236079b60f70,8d41ca7bfcf1..000000000000
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@@ -2859,6 -2896,22 +2859,25 @@@ cifs_readdata_alloc(unsigned int nr_pag
  	return rdata;
  }
  
++<<<<<<< HEAD
++=======
+ static struct cifs_readdata *
+ cifs_readdata_alloc(unsigned int nr_pages, work_func_t complete)
+ {
+ 	struct page **pages =
+ 		kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);
+ 	struct cifs_readdata *ret = NULL;
+ 
+ 	if (pages) {
+ 		ret = cifs_readdata_direct_alloc(pages, complete);
+ 		if (!ret)
+ 			kfree(pages);
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  void
  cifs_readdata_release(struct kref *refcount)
  {
diff --cc fs/ext4/extents.c
index 8dadcda011ff,0057fe3f248d..000000000000
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@@ -853,19 -869,21 +853,24 @@@ ext4_ext_find_extent(struct inode *inod
  
  	eh = ext_inode_hdr(inode);
  	depth = ext_depth(inode);
 -
 -	if (path) {
 -		ext4_ext_drop_refs(path);
 -		if (depth > path[0].p_maxdepth) {
 -			kfree(path);
 -			*orig_path = path = NULL;
 -		}
 +	if (depth < 0 || depth > EXT4_MAX_EXTENT_DEPTH) {
 +		EXT4_ERROR_INODE(inode, "inode has invalid extent depth: %d",
 +				 depth);
 +		return ERR_PTR(-EFSCORRUPTED);
  	}
 +
 +	/* account possible depth increase */
  	if (!path) {
++<<<<<<< HEAD
 +		path = kzalloc(sizeof(struct ext4_ext_path) * (depth + 2),
++=======
+ 		/* account possible depth increase */
+ 		path = kcalloc(depth + 2, sizeof(struct ext4_ext_path),
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  				GFP_NOFS);
 -		if (unlikely(!path))
 +		if (!path)
  			return ERR_PTR(-ENOMEM);
 -		path[0].p_maxdepth = depth + 1;
 +		alloc = 1;
  	}
  	path[0].p_hdr = eh;
  	path[0].p_bh = NULL;
diff --cc fs/overlayfs/namei.c
index ca8d8dc36a0f,c993dd8db739..000000000000
--- a/fs/overlayfs/namei.c
+++ b/fs/overlayfs/namei.c
@@@ -449,6 -599,28 +449,31 @@@ fail
  	pr_warn_ratelimited("overlayfs: failed to verify index (%pd2, ftype=%x, err=%i)\n",
  			    index, d_inode(index)->i_mode & S_IFMT, err);
  	goto out;
++<<<<<<< HEAD
++=======
+ 
+ orphan:
+ 	pr_warn_ratelimited("overlayfs: orphan index entry (%pd2, ftype=%x, nlink=%u)\n",
+ 			    index, d_inode(index)->i_mode & S_IFMT,
+ 			    d_inode(index)->i_nlink);
+ 	err = -ENOENT;
+ 	goto out;
+ }
+ 
+ static int ovl_get_index_name_fh(struct ovl_fh *fh, struct qstr *name)
+ {
+ 	char *n, *s;
+ 
+ 	n = kcalloc(fh->len, 2, GFP_KERNEL);
+ 	if (!n)
+ 		return -ENOMEM;
+ 
+ 	s  = bin2hex(n, fh, fh->len);
+ 	*name = (struct qstr) QSTR_INIT(n, s - n);
+ 
+ 	return 0;
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  }
  
  /*
diff --cc fs/udf/super.c
index 9a45395df54b,fc77ea736da7..000000000000
--- a/fs/udf/super.c
+++ b/fs/udf/super.c
@@@ -1503,25 -1523,97 +1503,88 @@@ static void udf_load_logicalvolint(stru
  	uint16_t ident;
  	struct udf_sb_info *sbi = UDF_SB(sb);
  	struct logicalVolIntegrityDesc *lvid;
 -	int indirections = 0;
 -
 -	while (++indirections <= UDF_MAX_LVID_NESTING) {
 -		final_bh = NULL;
 -		while (loc.extLength > 0 &&
 -			(bh = udf_read_tagged(sb, loc.extLocation,
 -					loc.extLocation, &ident))) {
 -			if (ident != TAG_IDENT_LVID) {
 -				brelse(bh);
 -				break;
 -			}
 -
 -			brelse(final_bh);
 -			final_bh = bh;
 -
 -			loc.extLength -= sb->s_blocksize;
 -			loc.extLocation++;
 -		}
 -
 -		if (!final_bh)
 -			return;
  
 -		brelse(sbi->s_lvid_bh);
 -		sbi->s_lvid_bh = final_bh;
 +	while (loc.extLength > 0 &&
 +	       (bh = udf_read_tagged(sb, loc.extLocation,
 +				     loc.extLocation, &ident)) &&
 +	       ident == TAG_IDENT_LVID) {
 +		sbi->s_lvid_bh = bh;
 +		lvid = (struct logicalVolIntegrityDesc *)bh->b_data;
  
 -		lvid = (struct logicalVolIntegrityDesc *)final_bh->b_data;
 -		if (lvid->nextIntegrityExt.extLength == 0)
 -			return;
 +		if (lvid->nextIntegrityExt.extLength)
 +			udf_load_logicalvolint(sb,
 +				leea_to_cpu(lvid->nextIntegrityExt));
  
 -		loc = leea_to_cpu(lvid->nextIntegrityExt);
 +		if (sbi->s_lvid_bh != bh)
 +			brelse(bh);
 +		loc.extLength -= sb->s_blocksize;
 +		loc.extLocation++;
  	}
++<<<<<<< HEAD
 +	if (sbi->s_lvid_bh != bh)
 +		brelse(bh);
++=======
+ 
+ 	udf_warn(sb, "Too many LVID indirections (max %u), ignoring.\n",
+ 		UDF_MAX_LVID_NESTING);
+ 	brelse(sbi->s_lvid_bh);
+ 	sbi->s_lvid_bh = NULL;
+ }
+ 
+ /*
+  * Step for reallocation of table of partition descriptor sequence numbers.
+  * Must be power of 2.
+  */
+ #define PART_DESC_ALLOC_STEP 32
+ 
+ struct desc_seq_scan_data {
+ 	struct udf_vds_record vds[VDS_POS_LENGTH];
+ 	unsigned int size_part_descs;
+ 	struct udf_vds_record *part_descs_loc;
+ };
+ 
+ static struct udf_vds_record *handle_partition_descriptor(
+ 				struct buffer_head *bh,
+ 				struct desc_seq_scan_data *data)
+ {
+ 	struct partitionDesc *desc = (struct partitionDesc *)bh->b_data;
+ 	int partnum;
+ 
+ 	partnum = le16_to_cpu(desc->partitionNumber);
+ 	if (partnum >= data->size_part_descs) {
+ 		struct udf_vds_record *new_loc;
+ 		unsigned int new_size = ALIGN(partnum, PART_DESC_ALLOC_STEP);
+ 
+ 		new_loc = kcalloc(new_size, sizeof(*new_loc), GFP_KERNEL);
+ 		if (!new_loc)
+ 			return ERR_PTR(-ENOMEM);
+ 		memcpy(new_loc, data->part_descs_loc,
+ 		       data->size_part_descs * sizeof(*new_loc));
+ 		kfree(data->part_descs_loc);
+ 		data->part_descs_loc = new_loc;
+ 		data->size_part_descs = new_size;
+ 	}
+ 	return &(data->part_descs_loc[partnum]);
+ }
+ 
+ 
+ static struct udf_vds_record *get_volume_descriptor_record(uint16_t ident,
+ 		struct buffer_head *bh, struct desc_seq_scan_data *data)
+ {
+ 	switch (ident) {
+ 	case TAG_IDENT_PVD: /* ISO 13346 3/10.1 */
+ 		return &(data->vds[VDS_POS_PRIMARY_VOL_DESC]);
+ 	case TAG_IDENT_IUVD: /* ISO 13346 3/10.4 */
+ 		return &(data->vds[VDS_POS_IMP_USE_VOL_DESC]);
+ 	case TAG_IDENT_LVD: /* ISO 13346 3/10.6 */
+ 		return &(data->vds[VDS_POS_LOGICAL_VOL_DESC]);
+ 	case TAG_IDENT_USD: /* ISO 13346 3/10.8 */
+ 		return &(data->vds[VDS_POS_UNALLOC_SPACE_DESC]);
+ 	case TAG_IDENT_PD: /* ISO 13346 3/10.5 */
+ 		return handle_partition_descriptor(bh, data);
+ 	}
+ 	return NULL;
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  }
  
  /*
@@@ -1543,13 -1634,21 +1606,23 @@@ static noinline int udf_process_sequenc
  	struct udf_vds_record *curr;
  	struct generic_desc *gd;
  	struct volDescPtr *vdp;
 -	bool done = false;
 +	int done = 0;
  	uint32_t vdsn;
  	uint16_t ident;
 +	long next_s = 0, next_e = 0;
  	int ret;
 -	unsigned int indirections = 0;
 -	struct desc_seq_scan_data data;
 -	unsigned int i;
  
++<<<<<<< HEAD
 +	memset(vds, 0, sizeof(struct udf_vds_record) * VDS_POS_LENGTH);
++=======
+ 	memset(data.vds, 0, sizeof(struct udf_vds_record) * VDS_POS_LENGTH);
+ 	data.size_part_descs = PART_DESC_ALLOC_STEP;
+ 	data.part_descs_loc = kcalloc(data.size_part_descs,
+ 				      sizeof(*data.part_descs_loc),
+ 				      GFP_KERNEL);
+ 	if (!data.part_descs_loc)
+ 		return -ENOMEM;
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  
  	/*
  	 * Read the main descriptor sequence and find which descriptors
diff --cc kernel/bpf/verifier.c
index d6b273f4ee39,1494e087890e..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -5322,16 -5447,13 +5322,20 @@@ static int jit_subprogs(struct bpf_veri
  		insn->imm = 1;
  	}
  
++<<<<<<< HEAD
 +	func = kzalloc(sizeof(prog) * (env->subprog_cnt + 1), GFP_KERNEL);
++=======
+ 	func = kcalloc(env->subprog_cnt, sizeof(prog), GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!func)
 -		return -ENOMEM;
 +		goto out_undo_insn;
  
 -	for (i = 0; i < env->subprog_cnt; i++) {
 +	for (i = 0; i <= env->subprog_cnt; i++) {
  		subprog_start = subprog_end;
 -		subprog_end = env->subprog_info[i + 1].start;
 +		if (env->subprog_cnt == i)
 +			subprog_end = prog->len;
 +		else
 +			subprog_end = env->subprog_starts[i];
  
  		len = subprog_end - subprog_start;
  		func[i] = bpf_prog_alloc(bpf_prog_size(len), GFP_USER);
diff --cc kernel/trace/trace.c
index 7b0fc13198d8,c9336e98ac59..000000000000
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@@ -3446,6 -4359,25 +3446,28 @@@ int set_tracer_flag(struct trace_array 
  	if (mask == TRACE_ITER_RECORD_CMD)
  		trace_event_enable_cmd_record(enabled);
  
++<<<<<<< HEAD
++=======
+ 	if (mask == TRACE_ITER_RECORD_TGID) {
+ 		if (!tgid_map)
+ 			tgid_map = kcalloc(PID_MAX_DEFAULT + 1,
+ 					   sizeof(*tgid_map),
+ 					   GFP_KERNEL);
+ 		if (!tgid_map) {
+ 			tr->trace_flags &= ~TRACE_ITER_RECORD_TGID;
+ 			return -ENOMEM;
+ 		}
+ 
+ 		trace_event_enable_tgid_record(enabled);
+ 	}
+ 
+ 	if (mask == TRACE_ITER_EVENT_FORK)
+ 		trace_event_follow_fork(tr, enabled);
+ 
+ 	if (mask == TRACE_ITER_FUNC_FORK)
+ 		ftrace_pid_follow_fork(tr, enabled);
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (mask == TRACE_ITER_OVERWRITE) {
  		ring_buffer_change_overwrite(tr->trace_buffer.buffer, enabled);
  #ifdef CONFIG_TRACER_MAX_TRACE
diff --cc kernel/workqueue.c
index ddaafa97bdb8,78b192071ef7..000000000000
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@@ -5364,7 -5638,7 +5364,11 @@@ static void __init wq_numa_init(void
  	 * available.  Build one from cpu_to_node() which should have been
  	 * fully initialized by now.
  	 */
++<<<<<<< HEAD
 +	tbl = kzalloc(wq_numa_tbl_len * sizeof(tbl[0]), GFP_KERNEL);
++=======
+ 	tbl = kcalloc(nr_node_ids, sizeof(tbl[0]), GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	BUG_ON(!tbl);
  
  	for_each_node(node)
diff --cc mm/slub.c
index afb5f0e66a73,a3b8467c14af..000000000000
--- a/mm/slub.c
+++ b/mm/slub.c
@@@ -4587,12 -4752,10 +4588,16 @@@ static ssize_t show_slab_objects(struc
  	int node;
  	int x;
  	unsigned long *nodes;
 +	unsigned long *per_cpu;
  
++<<<<<<< HEAD
 +	nodes = kzalloc(2 * sizeof(unsigned long) * nr_node_ids, GFP_KERNEL);
++=======
+ 	nodes = kcalloc(nr_node_ids, sizeof(unsigned long), GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!nodes)
  		return -ENOMEM;
 +	per_cpu = nodes + nr_node_ids;
  
  	if (flags & SO_CPU) {
  		int cpu;
diff --cc net/can/bcm.c
index a192e8509d71,9393f25df08d..000000000000
--- a/net/can/bcm.c
+++ b/net/can/bcm.c
@@@ -1055,8 -1104,9 +1055,14 @@@ static int bcm_rx_setup(struct bcm_msg_
  				return -ENOMEM;
  			}
  
++<<<<<<< HEAD
 +			/* create and init array for received can_frames */
 +			op->last_frames = kzalloc(msg_head->nframes * CFSIZ,
++=======
+ 			/* create and init array for received CAN frames */
+ 			op->last_frames = kcalloc(msg_head->nframes,
+ 						  op->cfsiz,
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  						  GFP_KERNEL);
  			if (!op->last_frames) {
  				kfree(op->frames);
diff --cc net/ipv4/fib_frontend.c
index 9ca53ed464e7,b21833651394..000000000000
--- a/net/ipv4/fib_frontend.c
+++ b/net/ipv4/fib_frontend.c
@@@ -504,8 -567,8 +504,13 @@@ static int rtentry_to_fib_config(struc
  		struct nlattr *mx;
  		int len = 0;
  
++<<<<<<< HEAD
 +		mx = kzalloc(3 * nla_total_size(4), GFP_KERNEL);
 +		if (mx == NULL)
++=======
+ 		mx = kcalloc(3, nla_total_size(4), GFP_KERNEL);
+ 		if (!mx)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  			return -ENOMEM;
  
  		if (rt->rt_flags & RTF_MTU)
diff --cc net/ipv6/icmp.c
index e629e07c2516,be491bf6ab6e..000000000000
--- a/net/ipv6/icmp.c
+++ b/net/ipv6/icmp.c
@@@ -851,8 -956,8 +851,13 @@@ static int __net_init icmpv6_sk_init(st
  	int err, i, j;
  
  	net->ipv6.icmp_sk =
++<<<<<<< HEAD
 +		kzalloc(nr_cpu_ids * sizeof(struct sock *), GFP_KERNEL);
 +	if (net->ipv6.icmp_sk == NULL)
++=======
+ 		kcalloc(nr_cpu_ids, sizeof(struct sock *), GFP_KERNEL);
+ 	if (!net->ipv6.icmp_sk)
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  		return -ENOMEM;
  
  	for_each_possible_cpu(i) {
diff --cc net/netfilter/nf_tables_api.c
index e2ddb2bff2ce,f0411fbffe77..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -3706,6 -4618,1172 +3706,1175 @@@ struct nft_set_gc_batch *nft_set_gc_bat
  }
  EXPORT_SYMBOL_GPL(nft_set_gc_batch_alloc);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Stateful objects
+  */
+ 
+ /**
+  *	nft_register_obj- register nf_tables stateful object type
+  *	@obj: object type
+  *
+  *	Registers the object type for use with nf_tables. Returns zero on
+  *	success or a negative errno code otherwise.
+  */
+ int nft_register_obj(struct nft_object_type *obj_type)
+ {
+ 	if (obj_type->type == NFT_OBJECT_UNSPEC)
+ 		return -EINVAL;
+ 
+ 	nfnl_lock(NFNL_SUBSYS_NFTABLES);
+ 	list_add_rcu(&obj_type->list, &nf_tables_objects);
+ 	nfnl_unlock(NFNL_SUBSYS_NFTABLES);
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(nft_register_obj);
+ 
+ /**
+  *	nft_unregister_obj - unregister nf_tables object type
+  *	@obj: object type
+  *
+  * 	Unregisters the object type for use with nf_tables.
+  */
+ void nft_unregister_obj(struct nft_object_type *obj_type)
+ {
+ 	nfnl_lock(NFNL_SUBSYS_NFTABLES);
+ 	list_del_rcu(&obj_type->list);
+ 	nfnl_unlock(NFNL_SUBSYS_NFTABLES);
+ }
+ EXPORT_SYMBOL_GPL(nft_unregister_obj);
+ 
+ struct nft_object *nft_obj_lookup(const struct nft_table *table,
+ 				  const struct nlattr *nla, u32 objtype,
+ 				  u8 genmask)
+ {
+ 	struct nft_object *obj;
+ 
+ 	list_for_each_entry_rcu(obj, &table->objects, list) {
+ 		if (!nla_strcmp(nla, obj->name) &&
+ 		    objtype == obj->ops->type->type &&
+ 		    nft_active_genmask(obj, genmask))
+ 			return obj;
+ 	}
+ 	return ERR_PTR(-ENOENT);
+ }
+ EXPORT_SYMBOL_GPL(nft_obj_lookup);
+ 
+ static struct nft_object *nft_obj_lookup_byhandle(const struct nft_table *table,
+ 						  const struct nlattr *nla,
+ 						  u32 objtype, u8 genmask)
+ {
+ 	struct nft_object *obj;
+ 
+ 	list_for_each_entry(obj, &table->objects, list) {
+ 		if (be64_to_cpu(nla_get_be64(nla)) == obj->handle &&
+ 		    objtype == obj->ops->type->type &&
+ 		    nft_active_genmask(obj, genmask))
+ 			return obj;
+ 	}
+ 	return ERR_PTR(-ENOENT);
+ }
+ 
+ static const struct nla_policy nft_obj_policy[NFTA_OBJ_MAX + 1] = {
+ 	[NFTA_OBJ_TABLE]	= { .type = NLA_STRING,
+ 				    .len = NFT_TABLE_MAXNAMELEN - 1 },
+ 	[NFTA_OBJ_NAME]		= { .type = NLA_STRING,
+ 				    .len = NFT_OBJ_MAXNAMELEN - 1 },
+ 	[NFTA_OBJ_TYPE]		= { .type = NLA_U32 },
+ 	[NFTA_OBJ_DATA]		= { .type = NLA_NESTED },
+ 	[NFTA_OBJ_HANDLE]	= { .type = NLA_U64},
+ };
+ 
+ static struct nft_object *nft_obj_init(const struct nft_ctx *ctx,
+ 				       const struct nft_object_type *type,
+ 				       const struct nlattr *attr)
+ {
+ 	struct nlattr **tb;
+ 	const struct nft_object_ops *ops;
+ 	struct nft_object *obj;
+ 	int err = -ENOMEM;
+ 
+ 	tb = kmalloc_array(type->maxattr + 1, sizeof(*tb), GFP_KERNEL);
+ 	if (!tb)
+ 		goto err1;
+ 
+ 	if (attr) {
+ 		err = nla_parse_nested(tb, type->maxattr, attr, type->policy,
+ 				       NULL);
+ 		if (err < 0)
+ 			goto err2;
+ 	} else {
+ 		memset(tb, 0, sizeof(tb[0]) * (type->maxattr + 1));
+ 	}
+ 
+ 	if (type->select_ops) {
+ 		ops = type->select_ops(ctx, (const struct nlattr * const *)tb);
+ 		if (IS_ERR(ops)) {
+ 			err = PTR_ERR(ops);
+ 			goto err2;
+ 		}
+ 	} else {
+ 		ops = type->ops;
+ 	}
+ 
+ 	err = -ENOMEM;
+ 	obj = kzalloc(sizeof(*obj) + ops->size, GFP_KERNEL);
+ 	if (!obj)
+ 		goto err2;
+ 
+ 	err = ops->init(ctx, (const struct nlattr * const *)tb, obj);
+ 	if (err < 0)
+ 		goto err3;
+ 
+ 	obj->ops = ops;
+ 
+ 	kfree(tb);
+ 	return obj;
+ err3:
+ 	kfree(obj);
+ err2:
+ 	kfree(tb);
+ err1:
+ 	return ERR_PTR(err);
+ }
+ 
+ static int nft_object_dump(struct sk_buff *skb, unsigned int attr,
+ 			   struct nft_object *obj, bool reset)
+ {
+ 	struct nlattr *nest;
+ 
+ 	nest = nla_nest_start(skb, attr);
+ 	if (!nest)
+ 		goto nla_put_failure;
+ 	if (obj->ops->dump(skb, obj, reset) < 0)
+ 		goto nla_put_failure;
+ 	nla_nest_end(skb, nest);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	return -1;
+ }
+ 
+ static const struct nft_object_type *__nft_obj_type_get(u32 objtype)
+ {
+ 	const struct nft_object_type *type;
+ 
+ 	list_for_each_entry(type, &nf_tables_objects, list) {
+ 		if (objtype == type->type)
+ 			return type;
+ 	}
+ 	return NULL;
+ }
+ 
+ static const struct nft_object_type *nft_obj_type_get(u32 objtype)
+ {
+ 	const struct nft_object_type *type;
+ 
+ 	type = __nft_obj_type_get(objtype);
+ 	if (type != NULL && try_module_get(type->owner))
+ 		return type;
+ 
+ #ifdef CONFIG_MODULES
+ 	if (type == NULL) {
+ 		nfnl_unlock(NFNL_SUBSYS_NFTABLES);
+ 		request_module("nft-obj-%u", objtype);
+ 		nfnl_lock(NFNL_SUBSYS_NFTABLES);
+ 		if (__nft_obj_type_get(objtype))
+ 			return ERR_PTR(-EAGAIN);
+ 	}
+ #endif
+ 	return ERR_PTR(-ENOENT);
+ }
+ 
+ static int nf_tables_newobj(struct net *net, struct sock *nlsk,
+ 			    struct sk_buff *skb, const struct nlmsghdr *nlh,
+ 			    const struct nlattr * const nla[],
+ 			    struct netlink_ext_ack *extack)
+ {
+ 	const struct nfgenmsg *nfmsg = nlmsg_data(nlh);
+ 	const struct nft_object_type *type;
+ 	u8 genmask = nft_genmask_next(net);
+ 	int family = nfmsg->nfgen_family;
+ 	struct nft_table *table;
+ 	struct nft_object *obj;
+ 	struct nft_ctx ctx;
+ 	u32 objtype;
+ 	int err;
+ 
+ 	if (!nla[NFTA_OBJ_TYPE] ||
+ 	    !nla[NFTA_OBJ_NAME] ||
+ 	    !nla[NFTA_OBJ_DATA])
+ 		return -EINVAL;
+ 
+ 	table = nft_table_lookup(net, nla[NFTA_OBJ_TABLE], family, genmask);
+ 	if (IS_ERR(table)) {
+ 		NL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_TABLE]);
+ 		return PTR_ERR(table);
+ 	}
+ 
+ 	objtype = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));
+ 	obj = nft_obj_lookup(table, nla[NFTA_OBJ_NAME], objtype, genmask);
+ 	if (IS_ERR(obj)) {
+ 		err = PTR_ERR(obj);
+ 		if (err != -ENOENT) {
+ 			NL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_NAME]);
+ 			return err;
+ 		}
+ 	} else {
+ 		if (nlh->nlmsg_flags & NLM_F_EXCL) {
+ 			NL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_NAME]);
+ 			return -EEXIST;
+ 		}
+ 		return 0;
+ 	}
+ 
+ 	nft_ctx_init(&ctx, net, skb, nlh, family, table, NULL, nla);
+ 
+ 	type = nft_obj_type_get(objtype);
+ 	if (IS_ERR(type))
+ 		return PTR_ERR(type);
+ 
+ 	obj = nft_obj_init(&ctx, type, nla[NFTA_OBJ_DATA]);
+ 	if (IS_ERR(obj)) {
+ 		err = PTR_ERR(obj);
+ 		goto err1;
+ 	}
+ 	obj->table = table;
+ 	obj->handle = nf_tables_alloc_handle(table);
+ 
+ 	obj->name = nla_strdup(nla[NFTA_OBJ_NAME], GFP_KERNEL);
+ 	if (!obj->name) {
+ 		err = -ENOMEM;
+ 		goto err2;
+ 	}
+ 
+ 	err = nft_trans_obj_add(&ctx, NFT_MSG_NEWOBJ, obj);
+ 	if (err < 0)
+ 		goto err3;
+ 
+ 	list_add_tail_rcu(&obj->list, &table->objects);
+ 	table->use++;
+ 	return 0;
+ err3:
+ 	kfree(obj->name);
+ err2:
+ 	if (obj->ops->destroy)
+ 		obj->ops->destroy(&ctx, obj);
+ 	kfree(obj);
+ err1:
+ 	module_put(type->owner);
+ 	return err;
+ }
+ 
+ static int nf_tables_fill_obj_info(struct sk_buff *skb, struct net *net,
+ 				   u32 portid, u32 seq, int event, u32 flags,
+ 				   int family, const struct nft_table *table,
+ 				   struct nft_object *obj, bool reset)
+ {
+ 	struct nfgenmsg *nfmsg;
+ 	struct nlmsghdr *nlh;
+ 
+ 	event = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);
+ 	nlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg), flags);
+ 	if (nlh == NULL)
+ 		goto nla_put_failure;
+ 
+ 	nfmsg = nlmsg_data(nlh);
+ 	nfmsg->nfgen_family	= family;
+ 	nfmsg->version		= NFNETLINK_V0;
+ 	nfmsg->res_id		= htons(net->nft.base_seq & 0xffff);
+ 
+ 	if (nla_put_string(skb, NFTA_OBJ_TABLE, table->name) ||
+ 	    nla_put_string(skb, NFTA_OBJ_NAME, obj->name) ||
+ 	    nla_put_be32(skb, NFTA_OBJ_TYPE, htonl(obj->ops->type->type)) ||
+ 	    nla_put_be32(skb, NFTA_OBJ_USE, htonl(obj->use)) ||
+ 	    nft_object_dump(skb, NFTA_OBJ_DATA, obj, reset) ||
+ 	    nla_put_be64(skb, NFTA_OBJ_HANDLE, cpu_to_be64(obj->handle),
+ 			 NFTA_OBJ_PAD))
+ 		goto nla_put_failure;
+ 
+ 	nlmsg_end(skb, nlh);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	nlmsg_trim(skb, nlh);
+ 	return -1;
+ }
+ 
+ struct nft_obj_filter {
+ 	char		*table;
+ 	u32		type;
+ };
+ 
+ static int nf_tables_dump_obj(struct sk_buff *skb, struct netlink_callback *cb)
+ {
+ 	const struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);
+ 	const struct nft_table *table;
+ 	unsigned int idx = 0, s_idx = cb->args[0];
+ 	struct nft_obj_filter *filter = cb->data;
+ 	struct net *net = sock_net(skb->sk);
+ 	int family = nfmsg->nfgen_family;
+ 	struct nft_object *obj;
+ 	bool reset = false;
+ 
+ 	if (NFNL_MSG_TYPE(cb->nlh->nlmsg_type) == NFT_MSG_GETOBJ_RESET)
+ 		reset = true;
+ 
+ 	rcu_read_lock();
+ 	cb->seq = net->nft.base_seq;
+ 
+ 	list_for_each_entry_rcu(table, &net->nft.tables, list) {
+ 		if (family != NFPROTO_UNSPEC && family != table->family)
+ 			continue;
+ 
+ 		list_for_each_entry_rcu(obj, &table->objects, list) {
+ 			if (!nft_is_active(net, obj))
+ 				goto cont;
+ 			if (idx < s_idx)
+ 				goto cont;
+ 			if (idx > s_idx)
+ 				memset(&cb->args[1], 0,
+ 				       sizeof(cb->args) - sizeof(cb->args[0]));
+ 			if (filter && filter->table &&
+ 			    strcmp(filter->table, table->name))
+ 				goto cont;
+ 			if (filter &&
+ 			    filter->type != NFT_OBJECT_UNSPEC &&
+ 			    obj->ops->type->type != filter->type)
+ 				goto cont;
+ 
+ 			if (nf_tables_fill_obj_info(skb, net, NETLINK_CB(cb->skb).portid,
+ 						    cb->nlh->nlmsg_seq,
+ 						    NFT_MSG_NEWOBJ,
+ 						    NLM_F_MULTI | NLM_F_APPEND,
+ 						    table->family, table,
+ 						    obj, reset) < 0)
+ 				goto done;
+ 
+ 			nl_dump_check_consistent(cb, nlmsg_hdr(skb));
+ cont:
+ 			idx++;
+ 		}
+ 	}
+ done:
+ 	rcu_read_unlock();
+ 
+ 	cb->args[0] = idx;
+ 	return skb->len;
+ }
+ 
+ static int nf_tables_dump_obj_done(struct netlink_callback *cb)
+ {
+ 	struct nft_obj_filter *filter = cb->data;
+ 
+ 	if (filter) {
+ 		kfree(filter->table);
+ 		kfree(filter);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static struct nft_obj_filter *
+ nft_obj_filter_alloc(const struct nlattr * const nla[])
+ {
+ 	struct nft_obj_filter *filter;
+ 
+ 	filter = kzalloc(sizeof(*filter), GFP_ATOMIC);
+ 	if (!filter)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	if (nla[NFTA_OBJ_TABLE]) {
+ 		filter->table = nla_strdup(nla[NFTA_OBJ_TABLE], GFP_ATOMIC);
+ 		if (!filter->table) {
+ 			kfree(filter);
+ 			return ERR_PTR(-ENOMEM);
+ 		}
+ 	}
+ 	if (nla[NFTA_OBJ_TYPE])
+ 		filter->type = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));
+ 
+ 	return filter;
+ }
+ 
+ /* called with rcu_read_lock held */
+ static int nf_tables_getobj(struct net *net, struct sock *nlsk,
+ 			    struct sk_buff *skb, const struct nlmsghdr *nlh,
+ 			    const struct nlattr * const nla[],
+ 			    struct netlink_ext_ack *extack)
+ {
+ 	const struct nfgenmsg *nfmsg = nlmsg_data(nlh);
+ 	u8 genmask = nft_genmask_cur(net);
+ 	int family = nfmsg->nfgen_family;
+ 	const struct nft_table *table;
+ 	struct nft_object *obj;
+ 	struct sk_buff *skb2;
+ 	bool reset = false;
+ 	u32 objtype;
+ 	int err;
+ 
+ 	if (nlh->nlmsg_flags & NLM_F_DUMP) {
+ 		struct netlink_dump_control c = {
+ 			.dump = nf_tables_dump_obj,
+ 			.done = nf_tables_dump_obj_done,
+ 			.module = THIS_MODULE,
+ 		};
+ 
+ 		if (nla[NFTA_OBJ_TABLE] ||
+ 		    nla[NFTA_OBJ_TYPE]) {
+ 			struct nft_obj_filter *filter;
+ 
+ 			filter = nft_obj_filter_alloc(nla);
+ 			if (IS_ERR(filter))
+ 				return -ENOMEM;
+ 
+ 			c.data = filter;
+ 		}
+ 		return nft_netlink_dump_start_rcu(nlsk, skb, nlh, &c);
+ 	}
+ 
+ 	if (!nla[NFTA_OBJ_NAME] ||
+ 	    !nla[NFTA_OBJ_TYPE])
+ 		return -EINVAL;
+ 
+ 	table = nft_table_lookup(net, nla[NFTA_OBJ_TABLE], family, genmask);
+ 	if (IS_ERR(table)) {
+ 		NL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_TABLE]);
+ 		return PTR_ERR(table);
+ 	}
+ 
+ 	objtype = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));
+ 	obj = nft_obj_lookup(table, nla[NFTA_OBJ_NAME], objtype, genmask);
+ 	if (IS_ERR(obj)) {
+ 		NL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_NAME]);
+ 		return PTR_ERR(obj);
+ 	}
+ 
+ 	skb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);
+ 	if (!skb2)
+ 		return -ENOMEM;
+ 
+ 	if (NFNL_MSG_TYPE(nlh->nlmsg_type) == NFT_MSG_GETOBJ_RESET)
+ 		reset = true;
+ 
+ 	err = nf_tables_fill_obj_info(skb2, net, NETLINK_CB(skb).portid,
+ 				      nlh->nlmsg_seq, NFT_MSG_NEWOBJ, 0,
+ 				      family, table, obj, reset);
+ 	if (err < 0)
+ 		goto err;
+ 
+ 	return nlmsg_unicast(nlsk, skb2, NETLINK_CB(skb).portid);
+ err:
+ 	kfree_skb(skb2);
+ 	return err;
+ }
+ 
+ static void nft_obj_destroy(const struct nft_ctx *ctx, struct nft_object *obj)
+ {
+ 	if (obj->ops->destroy)
+ 		obj->ops->destroy(ctx, obj);
+ 
+ 	module_put(obj->ops->type->owner);
+ 	kfree(obj->name);
+ 	kfree(obj);
+ }
+ 
+ static int nf_tables_delobj(struct net *net, struct sock *nlsk,
+ 			    struct sk_buff *skb, const struct nlmsghdr *nlh,
+ 			    const struct nlattr * const nla[],
+ 			    struct netlink_ext_ack *extack)
+ {
+ 	const struct nfgenmsg *nfmsg = nlmsg_data(nlh);
+ 	u8 genmask = nft_genmask_next(net);
+ 	int family = nfmsg->nfgen_family;
+ 	const struct nlattr *attr;
+ 	struct nft_table *table;
+ 	struct nft_object *obj;
+ 	struct nft_ctx ctx;
+ 	u32 objtype;
+ 
+ 	if (!nla[NFTA_OBJ_TYPE] ||
+ 	    (!nla[NFTA_OBJ_NAME] && !nla[NFTA_OBJ_HANDLE]))
+ 		return -EINVAL;
+ 
+ 	table = nft_table_lookup(net, nla[NFTA_OBJ_TABLE], family, genmask);
+ 	if (IS_ERR(table)) {
+ 		NL_SET_BAD_ATTR(extack, nla[NFTA_OBJ_TABLE]);
+ 		return PTR_ERR(table);
+ 	}
+ 
+ 	objtype = ntohl(nla_get_be32(nla[NFTA_OBJ_TYPE]));
+ 	if (nla[NFTA_OBJ_HANDLE]) {
+ 		attr = nla[NFTA_OBJ_HANDLE];
+ 		obj = nft_obj_lookup_byhandle(table, attr, objtype, genmask);
+ 	} else {
+ 		attr = nla[NFTA_OBJ_NAME];
+ 		obj = nft_obj_lookup(table, attr, objtype, genmask);
+ 	}
+ 
+ 	if (IS_ERR(obj)) {
+ 		NL_SET_BAD_ATTR(extack, attr);
+ 		return PTR_ERR(obj);
+ 	}
+ 	if (obj->use > 0) {
+ 		NL_SET_BAD_ATTR(extack, attr);
+ 		return -EBUSY;
+ 	}
+ 
+ 	nft_ctx_init(&ctx, net, skb, nlh, family, table, NULL, nla);
+ 
+ 	return nft_delobj(&ctx, obj);
+ }
+ 
+ void nft_obj_notify(struct net *net, struct nft_table *table,
+ 		    struct nft_object *obj, u32 portid, u32 seq, int event,
+ 		    int family, int report, gfp_t gfp)
+ {
+ 	struct sk_buff *skb;
+ 	int err;
+ 
+ 	if (!report &&
+ 	    !nfnetlink_has_listeners(net, NFNLGRP_NFTABLES))
+ 		return;
+ 
+ 	skb = nlmsg_new(NLMSG_GOODSIZE, gfp);
+ 	if (skb == NULL)
+ 		goto err;
+ 
+ 	err = nf_tables_fill_obj_info(skb, net, portid, seq, event, 0, family,
+ 				      table, obj, false);
+ 	if (err < 0) {
+ 		kfree_skb(skb);
+ 		goto err;
+ 	}
+ 
+ 	nfnetlink_send(skb, net, portid, NFNLGRP_NFTABLES, report, gfp);
+ 	return;
+ err:
+ 	nfnetlink_set_err(net, portid, NFNLGRP_NFTABLES, -ENOBUFS);
+ }
+ EXPORT_SYMBOL_GPL(nft_obj_notify);
+ 
+ static void nf_tables_obj_notify(const struct nft_ctx *ctx,
+ 				 struct nft_object *obj, int event)
+ {
+ 	nft_obj_notify(ctx->net, ctx->table, obj, ctx->portid, ctx->seq, event,
+ 		       ctx->family, ctx->report, GFP_KERNEL);
+ }
+ 
+ /*
+  * Flow tables
+  */
+ void nft_register_flowtable_type(struct nf_flowtable_type *type)
+ {
+ 	nfnl_lock(NFNL_SUBSYS_NFTABLES);
+ 	list_add_tail_rcu(&type->list, &nf_tables_flowtables);
+ 	nfnl_unlock(NFNL_SUBSYS_NFTABLES);
+ }
+ EXPORT_SYMBOL_GPL(nft_register_flowtable_type);
+ 
+ void nft_unregister_flowtable_type(struct nf_flowtable_type *type)
+ {
+ 	nfnl_lock(NFNL_SUBSYS_NFTABLES);
+ 	list_del_rcu(&type->list);
+ 	nfnl_unlock(NFNL_SUBSYS_NFTABLES);
+ }
+ EXPORT_SYMBOL_GPL(nft_unregister_flowtable_type);
+ 
+ static const struct nla_policy nft_flowtable_policy[NFTA_FLOWTABLE_MAX + 1] = {
+ 	[NFTA_FLOWTABLE_TABLE]		= { .type = NLA_STRING,
+ 					    .len = NFT_NAME_MAXLEN - 1 },
+ 	[NFTA_FLOWTABLE_NAME]		= { .type = NLA_STRING,
+ 					    .len = NFT_NAME_MAXLEN - 1 },
+ 	[NFTA_FLOWTABLE_HOOK]		= { .type = NLA_NESTED },
+ 	[NFTA_FLOWTABLE_HANDLE]		= { .type = NLA_U64 },
+ };
+ 
+ struct nft_flowtable *nft_flowtable_lookup(const struct nft_table *table,
+ 					   const struct nlattr *nla, u8 genmask)
+ {
+ 	struct nft_flowtable *flowtable;
+ 
+ 	list_for_each_entry_rcu(flowtable, &table->flowtables, list) {
+ 		if (!nla_strcmp(nla, flowtable->name) &&
+ 		    nft_active_genmask(flowtable, genmask))
+ 			return flowtable;
+ 	}
+ 	return ERR_PTR(-ENOENT);
+ }
+ EXPORT_SYMBOL_GPL(nft_flowtable_lookup);
+ 
+ static struct nft_flowtable *
+ nft_flowtable_lookup_byhandle(const struct nft_table *table,
+ 			      const struct nlattr *nla, u8 genmask)
+ {
+        struct nft_flowtable *flowtable;
+ 
+        list_for_each_entry(flowtable, &table->flowtables, list) {
+                if (be64_to_cpu(nla_get_be64(nla)) == flowtable->handle &&
+                    nft_active_genmask(flowtable, genmask))
+                        return flowtable;
+        }
+        return ERR_PTR(-ENOENT);
+ }
+ 
+ static int nf_tables_parse_devices(const struct nft_ctx *ctx,
+ 				   const struct nlattr *attr,
+ 				   struct net_device *dev_array[], int *len)
+ {
+ 	const struct nlattr *tmp;
+ 	struct net_device *dev;
+ 	char ifname[IFNAMSIZ];
+ 	int rem, n = 0, err;
+ 
+ 	nla_for_each_nested(tmp, attr, rem) {
+ 		if (nla_type(tmp) != NFTA_DEVICE_NAME) {
+ 			err = -EINVAL;
+ 			goto err1;
+ 		}
+ 
+ 		nla_strlcpy(ifname, tmp, IFNAMSIZ);
+ 		dev = __dev_get_by_name(ctx->net, ifname);
+ 		if (!dev) {
+ 			err = -ENOENT;
+ 			goto err1;
+ 		}
+ 
+ 		dev_array[n++] = dev;
+ 		if (n == NFT_FLOWTABLE_DEVICE_MAX) {
+ 			err = -EFBIG;
+ 			goto err1;
+ 		}
+ 	}
+ 	if (!len)
+ 		return -EINVAL;
+ 
+ 	err = 0;
+ err1:
+ 	*len = n;
+ 	return err;
+ }
+ 
+ static const struct nla_policy nft_flowtable_hook_policy[NFTA_FLOWTABLE_HOOK_MAX + 1] = {
+ 	[NFTA_FLOWTABLE_HOOK_NUM]	= { .type = NLA_U32 },
+ 	[NFTA_FLOWTABLE_HOOK_PRIORITY]	= { .type = NLA_U32 },
+ 	[NFTA_FLOWTABLE_HOOK_DEVS]	= { .type = NLA_NESTED },
+ };
+ 
+ static int nf_tables_flowtable_parse_hook(const struct nft_ctx *ctx,
+ 					  const struct nlattr *attr,
+ 					  struct nft_flowtable *flowtable)
+ {
+ 	struct net_device *dev_array[NFT_FLOWTABLE_DEVICE_MAX];
+ 	struct nlattr *tb[NFTA_FLOWTABLE_HOOK_MAX + 1];
+ 	struct nf_hook_ops *ops;
+ 	int hooknum, priority;
+ 	int err, n = 0, i;
+ 
+ 	err = nla_parse_nested(tb, NFTA_FLOWTABLE_HOOK_MAX, attr,
+ 			       nft_flowtable_hook_policy, NULL);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (!tb[NFTA_FLOWTABLE_HOOK_NUM] ||
+ 	    !tb[NFTA_FLOWTABLE_HOOK_PRIORITY] ||
+ 	    !tb[NFTA_FLOWTABLE_HOOK_DEVS])
+ 		return -EINVAL;
+ 
+ 	hooknum = ntohl(nla_get_be32(tb[NFTA_FLOWTABLE_HOOK_NUM]));
+ 	if (hooknum != NF_NETDEV_INGRESS)
+ 		return -EINVAL;
+ 
+ 	priority = ntohl(nla_get_be32(tb[NFTA_FLOWTABLE_HOOK_PRIORITY]));
+ 
+ 	err = nf_tables_parse_devices(ctx, tb[NFTA_FLOWTABLE_HOOK_DEVS],
+ 				      dev_array, &n);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	ops = kcalloc(n, sizeof(struct nf_hook_ops), GFP_KERNEL);
+ 	if (!ops)
+ 		return -ENOMEM;
+ 
+ 	flowtable->hooknum	= hooknum;
+ 	flowtable->priority	= priority;
+ 	flowtable->ops		= ops;
+ 	flowtable->ops_len	= n;
+ 
+ 	for (i = 0; i < n; i++) {
+ 		flowtable->ops[i].pf		= NFPROTO_NETDEV;
+ 		flowtable->ops[i].hooknum	= hooknum;
+ 		flowtable->ops[i].priority	= priority;
+ 		flowtable->ops[i].priv		= &flowtable->data;
+ 		flowtable->ops[i].hook		= flowtable->data.type->hook;
+ 		flowtable->ops[i].dev		= dev_array[i];
+ 		flowtable->dev_name[i]		= kstrdup(dev_array[i]->name,
+ 							  GFP_KERNEL);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static const struct nf_flowtable_type *__nft_flowtable_type_get(u8 family)
+ {
+ 	const struct nf_flowtable_type *type;
+ 
+ 	list_for_each_entry(type, &nf_tables_flowtables, list) {
+ 		if (family == type->family)
+ 			return type;
+ 	}
+ 	return NULL;
+ }
+ 
+ static const struct nf_flowtable_type *nft_flowtable_type_get(u8 family)
+ {
+ 	const struct nf_flowtable_type *type;
+ 
+ 	type = __nft_flowtable_type_get(family);
+ 	if (type != NULL && try_module_get(type->owner))
+ 		return type;
+ 
+ #ifdef CONFIG_MODULES
+ 	if (type == NULL) {
+ 		nfnl_unlock(NFNL_SUBSYS_NFTABLES);
+ 		request_module("nf-flowtable-%u", family);
+ 		nfnl_lock(NFNL_SUBSYS_NFTABLES);
+ 		if (__nft_flowtable_type_get(family))
+ 			return ERR_PTR(-EAGAIN);
+ 	}
+ #endif
+ 	return ERR_PTR(-ENOENT);
+ }
+ 
+ static void nft_unregister_flowtable_net_hooks(struct net *net,
+ 					       struct nft_flowtable *flowtable)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < flowtable->ops_len; i++) {
+ 		if (!flowtable->ops[i].dev)
+ 			continue;
+ 
+ 		nf_unregister_net_hook(net, &flowtable->ops[i]);
+ 	}
+ }
+ 
+ static int nf_tables_newflowtable(struct net *net, struct sock *nlsk,
+ 				  struct sk_buff *skb,
+ 				  const struct nlmsghdr *nlh,
+ 				  const struct nlattr * const nla[],
+ 				  struct netlink_ext_ack *extack)
+ {
+ 	const struct nfgenmsg *nfmsg = nlmsg_data(nlh);
+ 	const struct nf_flowtable_type *type;
+ 	struct nft_flowtable *flowtable, *ft;
+ 	u8 genmask = nft_genmask_next(net);
+ 	int family = nfmsg->nfgen_family;
+ 	struct nft_table *table;
+ 	struct nft_ctx ctx;
+ 	int err, i, k;
+ 
+ 	if (!nla[NFTA_FLOWTABLE_TABLE] ||
+ 	    !nla[NFTA_FLOWTABLE_NAME] ||
+ 	    !nla[NFTA_FLOWTABLE_HOOK])
+ 		return -EINVAL;
+ 
+ 	table = nft_table_lookup(net, nla[NFTA_FLOWTABLE_TABLE], family,
+ 				 genmask);
+ 	if (IS_ERR(table)) {
+ 		NL_SET_BAD_ATTR(extack, nla[NFTA_FLOWTABLE_TABLE]);
+ 		return PTR_ERR(table);
+ 	}
+ 
+ 	flowtable = nft_flowtable_lookup(table, nla[NFTA_FLOWTABLE_NAME],
+ 					 genmask);
+ 	if (IS_ERR(flowtable)) {
+ 		err = PTR_ERR(flowtable);
+ 		if (err != -ENOENT) {
+ 			NL_SET_BAD_ATTR(extack, nla[NFTA_FLOWTABLE_NAME]);
+ 			return err;
+ 		}
+ 	} else {
+ 		if (nlh->nlmsg_flags & NLM_F_EXCL) {
+ 			NL_SET_BAD_ATTR(extack, nla[NFTA_FLOWTABLE_NAME]);
+ 			return -EEXIST;
+ 		}
+ 
+ 		return 0;
+ 	}
+ 
+ 	nft_ctx_init(&ctx, net, skb, nlh, family, table, NULL, nla);
+ 
+ 	flowtable = kzalloc(sizeof(*flowtable), GFP_KERNEL);
+ 	if (!flowtable)
+ 		return -ENOMEM;
+ 
+ 	flowtable->table = table;
+ 	flowtable->handle = nf_tables_alloc_handle(table);
+ 
+ 	flowtable->name = nla_strdup(nla[NFTA_FLOWTABLE_NAME], GFP_KERNEL);
+ 	if (!flowtable->name) {
+ 		err = -ENOMEM;
+ 		goto err1;
+ 	}
+ 
+ 	type = nft_flowtable_type_get(family);
+ 	if (IS_ERR(type)) {
+ 		err = PTR_ERR(type);
+ 		goto err2;
+ 	}
+ 
+ 	flowtable->data.type = type;
+ 	err = type->init(&flowtable->data);
+ 	if (err < 0)
+ 		goto err3;
+ 
+ 	err = nf_tables_flowtable_parse_hook(&ctx, nla[NFTA_FLOWTABLE_HOOK],
+ 					     flowtable);
+ 	if (err < 0)
+ 		goto err4;
+ 
+ 	for (i = 0; i < flowtable->ops_len; i++) {
+ 		if (!flowtable->ops[i].dev)
+ 			continue;
+ 
+ 		list_for_each_entry(ft, &table->flowtables, list) {
+ 			for (k = 0; k < ft->ops_len; k++) {
+ 				if (!ft->ops[k].dev)
+ 					continue;
+ 
+ 				if (flowtable->ops[i].dev == ft->ops[k].dev &&
+ 				    flowtable->ops[i].pf == ft->ops[k].pf) {
+ 					err = -EBUSY;
+ 					goto err5;
+ 				}
+ 			}
+ 		}
+ 
+ 		err = nf_register_net_hook(net, &flowtable->ops[i]);
+ 		if (err < 0)
+ 			goto err5;
+ 	}
+ 
+ 	err = nft_trans_flowtable_add(&ctx, NFT_MSG_NEWFLOWTABLE, flowtable);
+ 	if (err < 0)
+ 		goto err6;
+ 
+ 	list_add_tail_rcu(&flowtable->list, &table->flowtables);
+ 	table->use++;
+ 
+ 	return 0;
+ err6:
+ 	i = flowtable->ops_len;
+ err5:
+ 	for (k = i - 1; k >= 0; k--) {
+ 		kfree(flowtable->dev_name[k]);
+ 		nf_unregister_net_hook(net, &flowtable->ops[k]);
+ 	}
+ 
+ 	kfree(flowtable->ops);
+ err4:
+ 	flowtable->data.type->free(&flowtable->data);
+ err3:
+ 	module_put(type->owner);
+ err2:
+ 	kfree(flowtable->name);
+ err1:
+ 	kfree(flowtable);
+ 	return err;
+ }
+ 
+ static int nf_tables_delflowtable(struct net *net, struct sock *nlsk,
+ 				  struct sk_buff *skb,
+ 				  const struct nlmsghdr *nlh,
+ 				  const struct nlattr * const nla[],
+ 				  struct netlink_ext_ack *extack)
+ {
+ 	const struct nfgenmsg *nfmsg = nlmsg_data(nlh);
+ 	u8 genmask = nft_genmask_next(net);
+ 	int family = nfmsg->nfgen_family;
+ 	struct nft_flowtable *flowtable;
+ 	const struct nlattr *attr;
+ 	struct nft_table *table;
+ 	struct nft_ctx ctx;
+ 
+ 	if (!nla[NFTA_FLOWTABLE_TABLE] ||
+ 	    (!nla[NFTA_FLOWTABLE_NAME] &&
+ 	     !nla[NFTA_FLOWTABLE_HANDLE]))
+ 		return -EINVAL;
+ 
+ 	table = nft_table_lookup(net, nla[NFTA_FLOWTABLE_TABLE], family,
+ 				 genmask);
+ 	if (IS_ERR(table)) {
+ 		NL_SET_BAD_ATTR(extack, nla[NFTA_FLOWTABLE_TABLE]);
+ 		return PTR_ERR(table);
+ 	}
+ 
+ 	if (nla[NFTA_FLOWTABLE_HANDLE]) {
+ 		attr = nla[NFTA_FLOWTABLE_HANDLE];
+ 		flowtable = nft_flowtable_lookup_byhandle(table, attr, genmask);
+ 	} else {
+ 		attr = nla[NFTA_FLOWTABLE_NAME];
+ 		flowtable = nft_flowtable_lookup(table, attr, genmask);
+ 	}
+ 
+ 	if (IS_ERR(flowtable)) {
+ 		NL_SET_BAD_ATTR(extack, attr);
+ 		return PTR_ERR(flowtable);
+ 	}
+ 	if (flowtable->use > 0) {
+ 		NL_SET_BAD_ATTR(extack, attr);
+ 		return -EBUSY;
+ 	}
+ 
+ 	nft_ctx_init(&ctx, net, skb, nlh, family, table, NULL, nla);
+ 
+ 	return nft_delflowtable(&ctx, flowtable);
+ }
+ 
+ static int nf_tables_fill_flowtable_info(struct sk_buff *skb, struct net *net,
+ 					 u32 portid, u32 seq, int event,
+ 					 u32 flags, int family,
+ 					 struct nft_flowtable *flowtable)
+ {
+ 	struct nlattr *nest, *nest_devs;
+ 	struct nfgenmsg *nfmsg;
+ 	struct nlmsghdr *nlh;
+ 	int i;
+ 
+ 	event = nfnl_msg_type(NFNL_SUBSYS_NFTABLES, event);
+ 	nlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg), flags);
+ 	if (nlh == NULL)
+ 		goto nla_put_failure;
+ 
+ 	nfmsg = nlmsg_data(nlh);
+ 	nfmsg->nfgen_family	= family;
+ 	nfmsg->version		= NFNETLINK_V0;
+ 	nfmsg->res_id		= htons(net->nft.base_seq & 0xffff);
+ 
+ 	if (nla_put_string(skb, NFTA_FLOWTABLE_TABLE, flowtable->table->name) ||
+ 	    nla_put_string(skb, NFTA_FLOWTABLE_NAME, flowtable->name) ||
+ 	    nla_put_be32(skb, NFTA_FLOWTABLE_USE, htonl(flowtable->use)) ||
+ 	    nla_put_be64(skb, NFTA_FLOWTABLE_HANDLE, cpu_to_be64(flowtable->handle),
+ 			 NFTA_FLOWTABLE_PAD))
+ 		goto nla_put_failure;
+ 
+ 	nest = nla_nest_start(skb, NFTA_FLOWTABLE_HOOK);
+ 	if (nla_put_be32(skb, NFTA_FLOWTABLE_HOOK_NUM, htonl(flowtable->hooknum)) ||
+ 	    nla_put_be32(skb, NFTA_FLOWTABLE_HOOK_PRIORITY, htonl(flowtable->priority)))
+ 		goto nla_put_failure;
+ 
+ 	nest_devs = nla_nest_start(skb, NFTA_FLOWTABLE_HOOK_DEVS);
+ 	if (!nest_devs)
+ 		goto nla_put_failure;
+ 
+ 	for (i = 0; i < flowtable->ops_len; i++) {
+ 		if (flowtable->dev_name[i][0] &&
+ 		    nla_put_string(skb, NFTA_DEVICE_NAME,
+ 				   flowtable->dev_name[i]))
+ 			goto nla_put_failure;
+ 	}
+ 	nla_nest_end(skb, nest_devs);
+ 	nla_nest_end(skb, nest);
+ 
+ 	nlmsg_end(skb, nlh);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	nlmsg_trim(skb, nlh);
+ 	return -1;
+ }
+ 
+ struct nft_flowtable_filter {
+ 	char		*table;
+ };
+ 
+ static int nf_tables_dump_flowtable(struct sk_buff *skb,
+ 				    struct netlink_callback *cb)
+ {
+ 	const struct nfgenmsg *nfmsg = nlmsg_data(cb->nlh);
+ 	struct nft_flowtable_filter *filter = cb->data;
+ 	unsigned int idx = 0, s_idx = cb->args[0];
+ 	struct net *net = sock_net(skb->sk);
+ 	int family = nfmsg->nfgen_family;
+ 	struct nft_flowtable *flowtable;
+ 	const struct nft_table *table;
+ 
+ 	rcu_read_lock();
+ 	cb->seq = net->nft.base_seq;
+ 
+ 	list_for_each_entry_rcu(table, &net->nft.tables, list) {
+ 		if (family != NFPROTO_UNSPEC && family != table->family)
+ 			continue;
+ 
+ 		list_for_each_entry_rcu(flowtable, &table->flowtables, list) {
+ 			if (!nft_is_active(net, flowtable))
+ 				goto cont;
+ 			if (idx < s_idx)
+ 				goto cont;
+ 			if (idx > s_idx)
+ 				memset(&cb->args[1], 0,
+ 				       sizeof(cb->args) - sizeof(cb->args[0]));
+ 			if (filter && filter->table &&
+ 			    strcmp(filter->table, table->name))
+ 				goto cont;
+ 
+ 			if (nf_tables_fill_flowtable_info(skb, net, NETLINK_CB(cb->skb).portid,
+ 							  cb->nlh->nlmsg_seq,
+ 							  NFT_MSG_NEWFLOWTABLE,
+ 							  NLM_F_MULTI | NLM_F_APPEND,
+ 							  table->family, flowtable) < 0)
+ 				goto done;
+ 
+ 			nl_dump_check_consistent(cb, nlmsg_hdr(skb));
+ cont:
+ 			idx++;
+ 		}
+ 	}
+ done:
+ 	rcu_read_unlock();
+ 
+ 	cb->args[0] = idx;
+ 	return skb->len;
+ }
+ 
+ static int nf_tables_dump_flowtable_done(struct netlink_callback *cb)
+ {
+ 	struct nft_flowtable_filter *filter = cb->data;
+ 
+ 	if (!filter)
+ 		return 0;
+ 
+ 	kfree(filter->table);
+ 	kfree(filter);
+ 
+ 	return 0;
+ }
+ 
+ static struct nft_flowtable_filter *
+ nft_flowtable_filter_alloc(const struct nlattr * const nla[])
+ {
+ 	struct nft_flowtable_filter *filter;
+ 
+ 	filter = kzalloc(sizeof(*filter), GFP_ATOMIC);
+ 	if (!filter)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	if (nla[NFTA_FLOWTABLE_TABLE]) {
+ 		filter->table = nla_strdup(nla[NFTA_FLOWTABLE_TABLE],
+ 					   GFP_ATOMIC);
+ 		if (!filter->table) {
+ 			kfree(filter);
+ 			return ERR_PTR(-ENOMEM);
+ 		}
+ 	}
+ 	return filter;
+ }
+ 
+ /* called with rcu_read_lock held */
+ static int nf_tables_getflowtable(struct net *net, struct sock *nlsk,
+ 				  struct sk_buff *skb,
+ 				  const struct nlmsghdr *nlh,
+ 				  const struct nlattr * const nla[],
+ 				  struct netlink_ext_ack *extack)
+ {
+ 	const struct nfgenmsg *nfmsg = nlmsg_data(nlh);
+ 	u8 genmask = nft_genmask_cur(net);
+ 	int family = nfmsg->nfgen_family;
+ 	struct nft_flowtable *flowtable;
+ 	const struct nft_table *table;
+ 	struct sk_buff *skb2;
+ 	int err;
+ 
+ 	if (nlh->nlmsg_flags & NLM_F_DUMP) {
+ 		struct netlink_dump_control c = {
+ 			.dump = nf_tables_dump_flowtable,
+ 			.done = nf_tables_dump_flowtable_done,
+ 			.module = THIS_MODULE,
+ 		};
+ 
+ 		if (nla[NFTA_FLOWTABLE_TABLE]) {
+ 			struct nft_flowtable_filter *filter;
+ 
+ 			filter = nft_flowtable_filter_alloc(nla);
+ 			if (IS_ERR(filter))
+ 				return -ENOMEM;
+ 
+ 			c.data = filter;
+ 		}
+ 		return nft_netlink_dump_start_rcu(nlsk, skb, nlh, &c);
+ 	}
+ 
+ 	if (!nla[NFTA_FLOWTABLE_NAME])
+ 		return -EINVAL;
+ 
+ 	table = nft_table_lookup(net, nla[NFTA_FLOWTABLE_TABLE], family,
+ 				 genmask);
+ 	if (IS_ERR(table))
+ 		return PTR_ERR(table);
+ 
+ 	flowtable = nft_flowtable_lookup(table, nla[NFTA_FLOWTABLE_NAME],
+ 					 genmask);
+ 	if (IS_ERR(flowtable))
+ 		return PTR_ERR(flowtable);
+ 
+ 	skb2 = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);
+ 	if (!skb2)
+ 		return -ENOMEM;
+ 
+ 	err = nf_tables_fill_flowtable_info(skb2, net, NETLINK_CB(skb).portid,
+ 					    nlh->nlmsg_seq,
+ 					    NFT_MSG_NEWFLOWTABLE, 0, family,
+ 					    flowtable);
+ 	if (err < 0)
+ 		goto err;
+ 
+ 	return nlmsg_unicast(nlsk, skb2, NETLINK_CB(skb).portid);
+ err:
+ 	kfree_skb(skb2);
+ 	return err;
+ }
+ 
+ static void nf_tables_flowtable_notify(struct nft_ctx *ctx,
+ 				       struct nft_flowtable *flowtable,
+ 				       int event)
+ {
+ 	struct sk_buff *skb;
+ 	int err;
+ 
+ 	if (ctx->report &&
+ 	    !nfnetlink_has_listeners(ctx->net, NFNLGRP_NFTABLES))
+ 		return;
+ 
+ 	skb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+ 	if (skb == NULL)
+ 		goto err;
+ 
+ 	err = nf_tables_fill_flowtable_info(skb, ctx->net, ctx->portid,
+ 					    ctx->seq, event, 0,
+ 					    ctx->family, flowtable);
+ 	if (err < 0) {
+ 		kfree_skb(skb);
+ 		goto err;
+ 	}
+ 
+ 	nfnetlink_send(skb, ctx->net, ctx->portid, NFNLGRP_NFTABLES,
+ 		       ctx->report, GFP_KERNEL);
+ 	return;
+ err:
+ 	nfnetlink_set_err(ctx->net, ctx->portid, NFNLGRP_NFTABLES, -ENOBUFS);
+ }
+ 
+ static void nf_tables_flowtable_destroy(struct nft_flowtable *flowtable)
+ {
+ 	kfree(flowtable->ops);
+ 	kfree(flowtable->name);
+ 	flowtable->data.type->free(&flowtable->data);
+ 	module_put(flowtable->data.type->owner);
+ }
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  static int nf_tables_fill_gen_info(struct sk_buff *skb, struct net *net,
  				   u32 portid, u32 seq)
  {
diff --cc net/netfilter/nfnetlink_cthelper.c
index 8f6f06e608b2,e5d27b2e4eba..000000000000
--- a/net/netfilter/nfnetlink_cthelper.c
+++ b/net/netfilter/nfnetlink_cthelper.c
@@@ -168,15 -184,15 +168,21 @@@ nfnl_cthelper_parse_expect_policy(struc
  	if (!tb[NFCTH_POLICY_SET_NUM])
  		return -EINVAL;
  
 -	class_max = ntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));
 -	if (class_max == 0)
 -		return -EINVAL;
 -	if (class_max > NF_CT_MAX_EXPECT_CLASSES)
 +	helper->expect_class_max =
 +		ntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));
 +
 +	if (helper->expect_class_max != 0 &&
 +	    helper->expect_class_max > NF_CT_MAX_EXPECT_CLASSES)
  		return -EOVERFLOW;
  
++<<<<<<< HEAD
 +	expect_policy = kzalloc(sizeof(struct nf_conntrack_expect_policy) *
 +				helper->expect_class_max, GFP_KERNEL);
++=======
+ 	expect_policy = kcalloc(class_max,
+ 				sizeof(struct nf_conntrack_expect_policy),
+ 				GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (expect_policy == NULL)
  		return -ENOMEM;
  
diff --cc net/rds/ib.c
index 57189fefc1c3,b6ad38e48f62..000000000000
--- a/net/rds/ib.c
+++ b/net/rds/ib.c
@@@ -159,6 -163,15 +159,18 @@@ static void rds_ib_add_one(struct ib_de
  	rds_ibdev->max_initiator_depth = device->attrs.max_qp_init_rd_atom;
  	rds_ibdev->max_responder_resources = device->attrs.max_qp_rd_atom;
  
++<<<<<<< HEAD
++=======
+ 	rds_ibdev->vector_load = kcalloc(device->num_comp_vectors,
+ 					 sizeof(int),
+ 					 GFP_KERNEL);
+ 	if (!rds_ibdev->vector_load) {
+ 		pr_err("RDS/IB: %s failed to allocate vector memory\n",
+ 			__func__);
+ 		goto put_dev;
+ 	}
+ 
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	rds_ibdev->dev = device;
  	rds_ibdev->pd = ib_alloc_pd(device, 0);
  	if (IS_ERR(rds_ibdev->pd)) {
diff --cc net/sctp/auth.c
index 622fcf85a037,5b537613946f..000000000000
--- a/net/sctp/auth.c
+++ b/net/sctp/auth.c
@@@ -469,9 -482,9 +469,15 @@@ int sctp_auth_init_hmacs(struct sctp_en
  		return 0;
  
  	/* Allocated the array of pointers to transorms */
++<<<<<<< HEAD
 +	ep->auth_hmacs = kzalloc(
 +			    sizeof(struct crypto_hash *) * SCTP_AUTH_NUM_HMACS,
 +			    gfp);
++=======
+ 	ep->auth_hmacs = kcalloc(SCTP_AUTH_NUM_HMACS,
+ 				 sizeof(struct crypto_shash *),
+ 				 gfp);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!ep->auth_hmacs)
  		return -ENOMEM;
  
diff --cc net/sunrpc/cache.c
index dc28f124a5ff,109fbe591e7b..000000000000
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@@ -1713,7 -1683,7 +1713,11 @@@ struct cache_detail *cache_create_net(s
  	if (cd == NULL)
  		return ERR_PTR(-ENOMEM);
  
++<<<<<<< HEAD
 +	cd->hash_table = kzalloc(cd->hash_size * sizeof(struct cache_head *),
++=======
+ 	cd->hash_table = kcalloc(cd->hash_size, sizeof(struct hlist_head),
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  				 GFP_KERNEL);
  	if (cd->hash_table == NULL) {
  		kfree(cd);
diff --cc sound/pci/hda/patch_ca0132.c
index 86e3e7952188,04e949aa01ad..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -5125,7 -7480,11 +5125,15 @@@ static int ca0132_prepare_verbs(struct 
  	struct ca0132_spec *spec = codec->spec;
  
  	spec->chip_init_verbs = ca0132_init_verbs0;
++<<<<<<< HEAD
 +	spec->spec_init_verbs = kzalloc(sizeof(struct hda_verb) * NUM_SPEC_VERBS, GFP_KERNEL);
++=======
+ 	if (spec->quirk == QUIRK_SBZ)
+ 		spec->sbz_init_verbs = sbz_init_verbs;
+ 	spec->spec_init_verbs = kcalloc(NUM_SPEC_VERBS,
+ 					sizeof(struct hda_verb),
+ 					GFP_KERNEL);
++>>>>>>> 6396bb221514 (treewide: kzalloc() -> kcalloc())
  	if (!spec->spec_init_verbs)
  		return -ENOMEM;
  
* Unmerged path arch/arm/mach-vexpress/spc.c
* Unmerged path arch/arm64/kernel/armv8_deprecated.c
* Unmerged path arch/mips/alchemy/common/clock.c
* Unmerged path arch/mips/bmips/dma.c
* Unmerged path arch/powerpc/net/bpf_jit_comp64.c
* Unmerged path arch/powerpc/sysdev/xive/native.c
* Unmerged path arch/x86/events/amd/iommu.c
* Unmerged path drivers/android/binder_alloc.c
* Unmerged path drivers/clk/renesas/clk-r8a7740.c
* Unmerged path drivers/clk/renesas/clk-r8a7779.c
* Unmerged path drivers/clk/renesas/clk-rcar-gen2.c
* Unmerged path drivers/clk/renesas/clk-rz.c
* Unmerged path drivers/clk/st/clkgen-fsyn.c
* Unmerged path drivers/clk/st/clkgen-pll.c
* Unmerged path drivers/clk/sunxi/clk-usb.c
* Unmerged path drivers/clk/ti/apll.c
* Unmerged path drivers/clk/ti/divider.c
* Unmerged path drivers/clk/ti/dpll.c
* Unmerged path drivers/cpufreq/sfi-cpufreq.c
* Unmerged path drivers/crypto/inside-secure/safexcel_hash.c
* Unmerged path drivers/crypto/marvell/hash.c
* Unmerged path drivers/dma/ioat/init.c
* Unmerged path drivers/dma/xilinx/zynqmp_dma.c
* Unmerged path drivers/extcon/extcon.c
* Unmerged path drivers/firmware/efi/capsule.c
* Unmerged path drivers/fmc/fmc-sdb.c
* Unmerged path drivers/infiniband/hw/hns/hns_roce_hw_v2.c
* Unmerged path drivers/irqchip/irq-alpine-msi.c
* Unmerged path drivers/irqchip/irq-gic-v2m.c
* Unmerged path drivers/irqchip/irq-gic-v3-its.c
* Unmerged path drivers/irqchip/irq-gic-v3.c
* Unmerged path drivers/irqchip/irq-partition-percpu.c
* Unmerged path drivers/lightnvm/pblk-init.c
* Unmerged path drivers/md/md-cluster.c
* Unmerged path drivers/media/usb/usbtv/usbtv-video.c
* Unmerged path drivers/mfd/cros_ec_dev.c
* Unmerged path drivers/mtd/parsers/parser_trx.c
* Unmerged path drivers/mtd/parsers/sharpslpart.c
* Unmerged path drivers/net/ethernet/cavium/thunder/nicvf_queues.c
* Unmerged path drivers/net/ethernet/cortina/gemini.c
* Unmerged path drivers/net/ethernet/hisilicon/hns/hns_enet.c
* Unmerged path drivers/net/ethernet/socionext/netsec.c
* Unmerged path drivers/net/wan/fsl_ucc_hdlc.c
* Unmerged path drivers/net/wireless/quantenna/qtnfmac/commands.c
* Unmerged path drivers/net/wireless/st/cw1200/queue.c
* Unmerged path drivers/net/wireless/st/cw1200/scan.c
* Unmerged path drivers/nvmem/rockchip-efuse.c
* Unmerged path drivers/nvmem/sunxi_sid.c
* Unmerged path drivers/of/unittest.c
* Unmerged path drivers/opp/ti-opp-supply.c
* Unmerged path drivers/pinctrl/sirf/pinctrl-sirf.c
* Unmerged path drivers/pinctrl/sunxi/pinctrl-sunxi.c
* Unmerged path drivers/platform/x86/alienware-wmi.c
* Unmerged path drivers/scsi/esas2r/esas2r_init.c
* Unmerged path drivers/slimbus/qcom-ctrl.c
* Unmerged path drivers/staging/mt7621-pinctrl/pinctrl-rt2880.c
* Unmerged path drivers/staging/rtlwifi/efuse.c
* Unmerged path drivers/thermal/int340x_thermal/int340x_thermal_zone.c
* Unmerged path drivers/thermal/of-thermal.c
* Unmerged path drivers/thermal/x86_pkg_temp_thermal.c
* Unmerged path drivers/usb/dwc2/hcd.c
* Unmerged path drivers/usb/gadget/udc/bdc/bdc_ep.c
* Unmerged path drivers/xen/arm-device.c
* Unmerged path kernel/locking/locktorture.c
* Unmerged path net/smc/smc_wr.c
* Unmerged path sound/firewire/fireface/ff-protocol-ff400.c
* Unmerged path sound/soc/codecs/wm_adsp.c
* Unmerged path virt/kvm/arm/vgic/vgic-v4.c
diff --git a/arch/arm/mach-footbridge/dc21285.c b/arch/arm/mach-footbridge/dc21285.c
index 7c2fdae9a38b..d0b4222713f3 100644
--- a/arch/arm/mach-footbridge/dc21285.c
+++ b/arch/arm/mach-footbridge/dc21285.c
@@ -257,7 +257,7 @@ int __init dc21285_setup(int nr, struct pci_sys_data *sys)
 	if (nr || !footbridge_cfn_mode())
 		return 0;
 
-	res = kzalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	res = kcalloc(2, sizeof(struct resource), GFP_KERNEL);
 	if (!res) {
 		printk("out of memory for root bus resources");
 		return 0;
diff --git a/arch/arm/mach-ixp4xx/common-pci.c b/arch/arm/mach-ixp4xx/common-pci.c
index dcd334b2368e..75b7d7204d90 100644
--- a/arch/arm/mach-ixp4xx/common-pci.c
+++ b/arch/arm/mach-ixp4xx/common-pci.c
@@ -448,7 +448,7 @@ int ixp4xx_setup(int nr, struct pci_sys_data *sys)
 	if (nr >= 1)
 		return 0;
 
-	res = kzalloc(sizeof(*res) * 2, GFP_KERNEL);
+	res = kcalloc(2, sizeof(*res), GFP_KERNEL);
 	if (res == NULL) {
 		/* 
 		 * If we're out of memory this early, something is wrong,
diff --git a/arch/arm/mach-omap1/mcbsp.c b/arch/arm/mach-omap1/mcbsp.c
index b0d4723c9a90..7ee5f9866ee7 100644
--- a/arch/arm/mach-omap1/mcbsp.c
+++ b/arch/arm/mach-omap1/mcbsp.c
@@ -390,7 +390,7 @@ static void omap_mcbsp_register_board_cfg(struct resource *res, int res_count,
 {
 	int i;
 
-	omap_mcbsp_devices = kzalloc(size * sizeof(struct platform_device *),
+	omap_mcbsp_devices = kcalloc(size, sizeof(struct platform_device *),
 				     GFP_KERNEL);
 	if (!omap_mcbsp_devices) {
 		printk(KERN_ERR "Could not register McBSP devices\n");
diff --git a/arch/arm/mach-omap2/hsmmc.c b/arch/arm/mach-omap2/hsmmc.c
index 2ef1f8714fcf..7cac02e746a8 100644
--- a/arch/arm/mach-omap2/hsmmc.c
+++ b/arch/arm/mach-omap2/hsmmc.c
@@ -299,7 +299,7 @@ static int __init omap_hsmmc_pdata_init(struct omap2_hsmmc_info *c,
 {
 	char *hc_name;
 
-	hc_name = kzalloc(sizeof(char) * (HSMMC_NAME_LEN + 1), GFP_KERNEL);
+	hc_name = kzalloc(HSMMC_NAME_LEN + 1, GFP_KERNEL);
 	if (!hc_name) {
 		pr_err("Cannot allocate memory for controller slot name\n");
 		kfree(hc_name);
* Unmerged path arch/arm/mach-omap2/omap_device.c
diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c
index 228b850e632f..c97103c53896 100644
--- a/arch/arm/mach-omap2/prm_common.c
+++ b/arch/arm/mach-omap2/prm_common.c
@@ -269,10 +269,11 @@ int omap_prcm_register_chain_handler(struct omap_prcm_irq_setup *irq_setup)
 
 	prcm_irq_setup = irq_setup;
 
-	prcm_irq_chips = kzalloc(sizeof(void *) * nr_regs, GFP_KERNEL);
-	prcm_irq_setup->saved_mask = kzalloc(sizeof(u32) * nr_regs, GFP_KERNEL);
-	prcm_irq_setup->priority_mask = kzalloc(sizeof(u32) * nr_regs,
-		GFP_KERNEL);
+	prcm_irq_chips = kcalloc(nr_regs, sizeof(void *), GFP_KERNEL);
+	prcm_irq_setup->saved_mask = kcalloc(nr_regs, sizeof(u32),
+					     GFP_KERNEL);
+	prcm_irq_setup->priority_mask = kcalloc(nr_regs, sizeof(u32),
+						GFP_KERNEL);
 
 	if (!prcm_irq_chips || !prcm_irq_setup->saved_mask ||
 	    !prcm_irq_setup->priority_mask) {
* Unmerged path arch/arm/mach-s3c24xx/cpufreq.c
* Unmerged path arch/arm/mach-vexpress/spc.c
* Unmerged path arch/arm/mm/dma-mapping.c
* Unmerged path arch/arm64/kernel/armv8_deprecated.c
* Unmerged path arch/arm64/mm/context.c
diff --git a/arch/ia64/kernel/topology.c b/arch/ia64/kernel/topology.c
index dc00b2c1b42a..40523af8a649 100644
--- a/arch/ia64/kernel/topology.c
+++ b/arch/ia64/kernel/topology.c
@@ -85,7 +85,7 @@ static int __init topology_init(void)
 	}
 #endif
 
-	sysfs_cpus = kzalloc(sizeof(struct ia64_cpu) * NR_CPUS, GFP_KERNEL);
+	sysfs_cpus = kcalloc(NR_CPUS, sizeof(struct ia64_cpu), GFP_KERNEL);
 	if (!sysfs_cpus)
 		panic("kzalloc in topology_init failed - NR_CPUS too big?");
 
@@ -321,8 +321,8 @@ static int __cpuinit cpu_cache_sysfs_init(unsigned int cpu)
 		return -1;
 	}
 
-	this_cache=kzalloc(sizeof(struct cache_info)*unique_caches,
-			GFP_KERNEL);
+	this_cache=kcalloc(unique_caches, sizeof(struct cache_info),
+			   GFP_KERNEL);
 	if (this_cache == NULL)
 		return -ENOMEM;
 
diff --git a/arch/ia64/sn/kernel/io_common.c b/arch/ia64/sn/kernel/io_common.c
index 11f2275570fb..5b009d54d3df 100644
--- a/arch/ia64/sn/kernel/io_common.c
+++ b/arch/ia64/sn/kernel/io_common.c
@@ -132,7 +132,7 @@ static s64 sn_device_fixup_war(u64 nasid, u64 widget, int device,
 	printk_once(KERN_WARNING
 		"PROM version < 4.50 -- implementing old PROM flush WAR\n");
 
-	war_list = kzalloc(DEV_PER_WIDGET * sizeof(*war_list), GFP_KERNEL);
+	war_list = kcalloc(DEV_PER_WIDGET, sizeof(*war_list), GFP_KERNEL);
 	BUG_ON(!war_list);
 
 	SAL_CALL_NOLOCK(isrv, SN_SAL_IOIF_GET_WIDGET_DMAFLUSH_LIST,
diff --git a/arch/ia64/sn/pci/pcibr/pcibr_provider.c b/arch/ia64/sn/pci/pcibr/pcibr_provider.c
index 8dbbef4a4f47..7195df1da121 100644
--- a/arch/ia64/sn/pci/pcibr/pcibr_provider.c
+++ b/arch/ia64/sn/pci/pcibr/pcibr_provider.c
@@ -184,7 +184,7 @@ pcibr_bus_fixup(struct pcibus_bussoft *prom_bussoft, struct pci_controller *cont
 	/* Setup the PMU ATE map */
 	soft->pbi_int_ate_resource.lowest_free_index = 0;
 	soft->pbi_int_ate_resource.ate =
-	    kzalloc(soft->pbi_int_ate_size * sizeof(u64), GFP_KERNEL);
+	    kcalloc(soft->pbi_int_ate_size, sizeof(u64), GFP_KERNEL);
 
 	if (!soft->pbi_int_ate_resource.ate) {
 		kfree(soft);
* Unmerged path arch/mips/alchemy/common/clock.c
diff --git a/arch/mips/alchemy/common/dbdma.c b/arch/mips/alchemy/common/dbdma.c
index 19d5642c16d9..0ed1debe8090 100644
--- a/arch/mips/alchemy/common/dbdma.c
+++ b/arch/mips/alchemy/common/dbdma.c
@@ -1050,7 +1050,7 @@ static int __init dbdma_setup(unsigned int irq, dbdev_tab_t *idtable)
 {
 	int ret;
 
-	dbdev_tab = kzalloc(sizeof(dbdev_tab_t) * DBDEV_TAB_SIZE, GFP_KERNEL);
+	dbdev_tab = kcalloc(DBDEV_TAB_SIZE, sizeof(dbdev_tab_t), GFP_KERNEL);
 	if (!dbdev_tab)
 		return -ENOMEM;
 
diff --git a/arch/mips/alchemy/common/platform.c b/arch/mips/alchemy/common/platform.c
index 9837a134a6d6..7ae959c577a8 100644
--- a/arch/mips/alchemy/common/platform.c
+++ b/arch/mips/alchemy/common/platform.c
@@ -104,7 +104,7 @@ static void __init alchemy_setup_uarts(int ctype)
 	int c = alchemy_get_uarts(ctype);
 	struct plat_serial8250_port *ports;
 
-	ports = kzalloc(s * (c + 1), GFP_KERNEL);
+	ports = kcalloc(s, (c + 1), GFP_KERNEL);
 	if (!ports) {
 		printk(KERN_INFO "Alchemy: no memory for UART data\n");
 		return;
@@ -187,7 +187,7 @@ static unsigned long alchemy_ehci_data[][2] __initdata = {
 
 static int __init _new_usbres(struct resource **r, struct platform_device **d)
 {
-	*r = kzalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	*r = kcalloc(2, sizeof(struct resource), GFP_KERNEL);
 	if (!*r)
 		return -ENOMEM;
 	*d = kzalloc(sizeof(struct platform_device), GFP_KERNEL);
diff --git a/arch/mips/alchemy/devboards/platform.c b/arch/mips/alchemy/devboards/platform.c
index 8df86eb94972..ffb876a541ca 100644
--- a/arch/mips/alchemy/devboards/platform.c
+++ b/arch/mips/alchemy/devboards/platform.c
@@ -99,7 +99,7 @@ int __init db1x_register_pcmcia_socket(phys_addr_t pcmcia_attr_start,
 	if (stschg_irq)
 		cnt++;
 
-	sr = kzalloc(sizeof(struct resource) * cnt, GFP_KERNEL);
+	sr = kcalloc(cnt, sizeof(struct resource), GFP_KERNEL);
 	if (!sr)
 		return -ENOMEM;
 
@@ -174,7 +174,7 @@ int __init db1x_register_norflash(unsigned long size, int width,
 		return -EINVAL;
 
 	ret = -ENOMEM;
-	parts = kzalloc(sizeof(struct mtd_partition) * 5, GFP_KERNEL);
+	parts = kcalloc(5, sizeof(struct mtd_partition), GFP_KERNEL);
 	if (!parts)
 		goto out;
 
* Unmerged path arch/mips/bmips/dma.c
diff --git a/arch/mips/txx9/rbtx4939/setup.c b/arch/mips/txx9/rbtx4939/setup.c
index 2da5f25f98bc..47ca35c99470 100644
--- a/arch/mips/txx9/rbtx4939/setup.c
+++ b/arch/mips/txx9/rbtx4939/setup.c
@@ -219,7 +219,7 @@ static int __init rbtx4939_led_probe(struct platform_device *pdev)
 		"nand-disk",
 	};
 
-	leds_data = kzalloc(sizeof(*leds_data) * RBTX4939_MAX_7SEGLEDS,
+	leds_data = kcalloc(RBTX4939_MAX_7SEGLEDS, sizeof(*leds_data),
 			    GFP_KERNEL);
 	if (!leds_data)
 		return -ENOMEM;
diff --git a/arch/powerpc/kernel/vdso.c b/arch/powerpc/kernel/vdso.c
index 094e45c16a17..7ee715ecb6f9 100644
--- a/arch/powerpc/kernel/vdso.c
+++ b/arch/powerpc/kernel/vdso.c
@@ -806,7 +806,7 @@ static int __init vdso_init(void)
 	}
 
 	/* Make sure pages are in the correct state */
-	vdso32_pagelist = kzalloc(sizeof(struct page *) * (vdso32_pages + 2),
+	vdso32_pagelist = kcalloc(vdso32_pages + 2, sizeof(struct page *),
 				  GFP_KERNEL);
 	BUG_ON(vdso32_pagelist == NULL);
 	for (i = 0; i < vdso32_pages; i++) {
@@ -819,7 +819,7 @@ static int __init vdso_init(void)
 	vdso32_pagelist[i] = NULL;
 
 #ifdef CONFIG_PPC64
-	vdso64_pagelist = kzalloc(sizeof(struct page *) * (vdso64_pages + 2),
+	vdso64_pagelist = kcalloc(vdso64_pages + 2, sizeof(struct page *),
 				  GFP_KERNEL);
 	BUG_ON(vdso64_pagelist == NULL);
 	for (i = 0; i < vdso64_pages; i++) {
diff --git a/arch/powerpc/mm/numa.c b/arch/powerpc/mm/numa.c
index e66a35db2e35..6498cfeee917 100644
--- a/arch/powerpc/mm/numa.c
+++ b/arch/powerpc/mm/numa.c
@@ -1660,7 +1660,7 @@ int arch_update_cpu_topology(void)
 	if (!weight)
 		return 0;
 
-	updates = kzalloc(weight * (sizeof(*updates)), GFP_KERNEL);
+	updates = kcalloc(weight, sizeof(*updates), GFP_KERNEL);
 	if (!updates)
 		return 0;
 
diff --git a/arch/powerpc/net/bpf_jit_comp.c b/arch/powerpc/net/bpf_jit_comp.c
index 20ef809f5ba6..67379d407c9c 100644
--- a/arch/powerpc/net/bpf_jit_comp.c
+++ b/arch/powerpc/net/bpf_jit_comp.c
@@ -588,7 +588,7 @@ void bpf_jit_compile(struct sk_filter *fp)
 	if (!bpf_jit_enable)
 		return;
 
-	addrs = kzalloc((flen+1) * sizeof(*addrs), GFP_KERNEL);
+	addrs = kcalloc(flen + 1, sizeof(*addrs), GFP_KERNEL);
 	if (addrs == NULL)
 		return;
 
* Unmerged path arch/powerpc/net/bpf_jit_comp64.c
diff --git a/arch/powerpc/oprofile/cell/spu_profiler.c b/arch/powerpc/oprofile/cell/spu_profiler.c
index b19265de9178..321fad8fc319 100644
--- a/arch/powerpc/oprofile/cell/spu_profiler.c
+++ b/arch/powerpc/oprofile/cell/spu_profiler.c
@@ -210,8 +210,8 @@ int start_spu_profiling_cycles(unsigned int cycles_reset)
 	timer.function = profile_spus;
 
 	/* Allocate arrays for collecting SPU PC samples */
-	samples = kzalloc(SPUS_PER_NODE *
-			  TRACE_ARRAY_SIZE * sizeof(u32), GFP_KERNEL);
+	samples = kcalloc(SPUS_PER_NODE * TRACE_ARRAY_SIZE, sizeof(u32),
+			  GFP_KERNEL);
 
 	if (!samples)
 		return -ENOMEM;
diff --git a/arch/powerpc/platforms/powernv/opal-sysparam.c b/arch/powerpc/platforms/powernv/opal-sysparam.c
index 2e52b47393e7..8a9f004c860f 100644
--- a/arch/powerpc/platforms/powernv/opal-sysparam.c
+++ b/arch/powerpc/platforms/powernv/opal-sysparam.c
@@ -194,21 +194,21 @@ void __init opal_sys_param_init(void)
 		goto out_param_buf;
 	}
 
-	id = kzalloc(sizeof(*id) * count, GFP_KERNEL);
+	id = kcalloc(count, sizeof(*id), GFP_KERNEL);
 	if (!id) {
 		pr_err("SYSPARAM: Failed to allocate memory to read parameter "
 				"id\n");
 		goto out_param_buf;
 	}
 
-	size = kzalloc(sizeof(*size) * count, GFP_KERNEL);
+	size = kcalloc(count, sizeof(*size), GFP_KERNEL);
 	if (!size) {
 		pr_err("SYSPARAM: Failed to allocate memory to read parameter "
 				"size\n");
 		goto out_free_id;
 	}
 
-	perm = kzalloc(sizeof(*perm) * count, GFP_KERNEL);
+	perm = kcalloc(count, sizeof(*perm), GFP_KERNEL);
 	if (!perm) {
 		pr_err("SYSPARAM: Failed to allocate memory to read supported "
 				"action on the parameter");
@@ -231,7 +231,7 @@ void __init opal_sys_param_init(void)
 		goto out_free_perm;
 	}
 
-	attr = kzalloc(sizeof(*attr) * count, GFP_KERNEL);
+	attr = kcalloc(count, sizeof(*attr), GFP_KERNEL);
 	if (!attr) {
 		pr_err("SYSPARAM: Failed to allocate memory for parameter "
 				"attributes\n");
diff --git a/arch/powerpc/sysdev/mpic.c b/arch/powerpc/sysdev/mpic.c
index fe4da84e54ae..530e2a4e7f9b 100644
--- a/arch/powerpc/sysdev/mpic.c
+++ b/arch/powerpc/sysdev/mpic.c
@@ -539,7 +539,7 @@ static void __init mpic_scan_ht_pics(struct mpic *mpic)
 	printk(KERN_INFO "mpic: Setting up HT PICs workarounds for U3/U4\n");
 
 	/* Allocate fixups array */
-	mpic->fixups = kzalloc(128 * sizeof(*mpic->fixups), GFP_KERNEL);
+	mpic->fixups = kcalloc(128, sizeof(*mpic->fixups), GFP_KERNEL);
 	BUG_ON(mpic->fixups == NULL);
 
 	/* Init spinlock */
@@ -1288,7 +1288,7 @@ struct mpic * __init mpic_alloc(struct device_node *node,
 	if (psrc) {
 		/* Allocate a bitmap with one bit per interrupt */
 		unsigned int mapsize = BITS_TO_LONGS(intvec_top + 1);
-		mpic->protected = kzalloc(mapsize*sizeof(long), GFP_KERNEL);
+		mpic->protected = kcalloc(mapsize, sizeof(long), GFP_KERNEL);
 		BUG_ON(mpic->protected == NULL);
 		for (i = 0; i < psize/sizeof(u32); i++) {
 			if (psrc[i] > intvec_top)
diff --git a/arch/powerpc/sysdev/ppc4xx_pci.c b/arch/powerpc/sysdev/ppc4xx_pci.c
index 64603a10b863..fbe8d31d1764 100644
--- a/arch/powerpc/sysdev/ppc4xx_pci.c
+++ b/arch/powerpc/sysdev/ppc4xx_pci.c
@@ -1452,7 +1452,7 @@ static int __init ppc4xx_pciex_check_core_init(struct device_node *np)
 	count = ppc4xx_pciex_hwops->core_init(np);
 	if (count > 0) {
 		ppc4xx_pciex_ports =
-		       kzalloc(count * sizeof(struct ppc4xx_pciex_port),
+		       kcalloc(count, sizeof(struct ppc4xx_pciex_port),
 			       GFP_KERNEL);
 		if (ppc4xx_pciex_ports) {
 			ppc4xx_pciex_port_count = count;
* Unmerged path arch/powerpc/sysdev/xive/native.c
diff --git a/arch/s390/appldata/appldata_base.c b/arch/s390/appldata/appldata_base.c
index 6c0281f30d44..a265f4f94b8c 100644
--- a/arch/s390/appldata/appldata_base.c
+++ b/arch/s390/appldata/appldata_base.c
@@ -387,7 +387,7 @@ int appldata_register_ops(struct appldata_ops *ops)
 	if (ops->size > APPLDATA_MAX_REC_SIZE)
 		return -EINVAL;
 
-	ops->ctl_table = kzalloc(4 * sizeof(struct ctl_table), GFP_KERNEL);
+	ops->ctl_table = kcalloc(4, sizeof(struct ctl_table), GFP_KERNEL);
 	if (!ops->ctl_table)
 		return -ENOMEM;
 
diff --git a/arch/s390/kernel/vdso.c b/arch/s390/kernel/vdso.c
index f19cb448513c..e5623e9f67d1 100644
--- a/arch/s390/kernel/vdso.c
+++ b/arch/s390/kernel/vdso.c
@@ -274,7 +274,7 @@ static int __init vdso_init(void)
 			 + PAGE_SIZE - 1) >> PAGE_SHIFT) + 1;
 
 	/* Make sure pages are in the correct state */
-	vdso32_pagelist = kzalloc(sizeof(struct page *) * (vdso32_pages + 1),
+	vdso32_pagelist = kcalloc(vdso32_pages + 1, sizeof(struct page *),
 				  GFP_KERNEL);
 	BUG_ON(vdso32_pagelist == NULL);
 	for (i = 0; i < vdso32_pages - 1; i++) {
@@ -293,7 +293,7 @@ static int __init vdso_init(void)
 			 + PAGE_SIZE - 1) >> PAGE_SHIFT) + 1;
 
 	/* Make sure pages are in the correct state */
-	vdso64_pagelist = kzalloc(sizeof(struct page *) * (vdso64_pages + 1),
+	vdso64_pagelist = kcalloc(vdso64_pages + 1, sizeof(struct page *),
 				  GFP_KERNEL);
 	BUG_ON(vdso64_pagelist == NULL);
 	for (i = 0; i < vdso64_pages - 1; i++) {
diff --git a/arch/sh/drivers/dma/dmabrg.c b/arch/sh/drivers/dma/dmabrg.c
index c0dd904483c7..e5a57a109d6c 100644
--- a/arch/sh/drivers/dma/dmabrg.c
+++ b/arch/sh/drivers/dma/dmabrg.c
@@ -154,7 +154,7 @@ static int __init dmabrg_init(void)
 	unsigned long or;
 	int ret;
 
-	dmabrg_handlers = kzalloc(10 * sizeof(struct dmabrg_handler),
+	dmabrg_handlers = kcalloc(10, sizeof(struct dmabrg_handler),
 				  GFP_KERNEL);
 	if (!dmabrg_handlers)
 		return -ENOMEM;
diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
index a162a7f86b2e..85c20f1d8770 100644
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ b/arch/sh/drivers/pci/pcie-sh7786.c
@@ -539,7 +539,7 @@ static int __init sh7786_pcie_init(void)
 	if (unlikely(nr_ports == 0))
 		return -ENODEV;
 
-	sh7786_pcie_ports = kzalloc(nr_ports * sizeof(struct sh7786_pcie_port),
+	sh7786_pcie_ports = kcalloc(nr_ports, sizeof(struct sh7786_pcie_port),
 				    GFP_KERNEL);
 	if (unlikely(!sh7786_pcie_ports))
 		return -ENOMEM;
diff --git a/arch/sparc/kernel/sys_sparc_64.c b/arch/sparc/kernel/sys_sparc_64.c
index 1e9e320583c7..30210741f264 100644
--- a/arch/sparc/kernel/sys_sparc_64.c
+++ b/arch/sparc/kernel/sys_sparc_64.c
@@ -571,7 +571,8 @@ SYSCALL_DEFINE5(utrap_install, utrap_entry_t, type,
 	}
 	if (!current_thread_info()->utraps) {
 		current_thread_info()->utraps =
-			kzalloc((UT_TRAP_INSTRUCTION_31+1)*sizeof(long), GFP_KERNEL);
+			kcalloc(UT_TRAP_INSTRUCTION_31 + 1, sizeof(long),
+				GFP_KERNEL);
 		if (!current_thread_info()->utraps)
 			return -ENOMEM;
 		current_thread_info()->utraps[0] = 1;
* Unmerged path arch/x86/events/amd/iommu.c
diff --git a/arch/x86/events/intel/uncore.c b/arch/x86/events/intel/uncore.c
index ff23e9faa5b1..a5ce482e47c5 100644
--- a/arch/x86/events/intel/uncore.c
+++ b/arch/x86/events/intel/uncore.c
@@ -888,7 +888,7 @@ static int __init uncore_type_init(struct intel_uncore_type *type, bool setid)
 	size_t size;
 	int i, j;
 
-	pmus = kzalloc(sizeof(*pmus) * type->num_boxes, GFP_KERNEL);
+	pmus = kcalloc(type->num_boxes, sizeof(*pmus), GFP_KERNEL);
 	if (!pmus)
 		return -ENOMEM;
 
diff --git a/arch/x86/kernel/cpu/mcheck/mce.c b/arch/x86/kernel/cpu/mcheck/mce.c
index f4e26139f488..5c5e1e51158d 100644
--- a/arch/x86/kernel/cpu/mcheck/mce.c
+++ b/arch/x86/kernel/cpu/mcheck/mce.c
@@ -1449,7 +1449,7 @@ static int __mcheck_cpu_mce_banks_init(void)
 	int i;
 	u8 num_banks = mca_cfg.banks;
 
-	mce_banks = kzalloc(num_banks * sizeof(struct mce_bank), GFP_KERNEL);
+	mce_banks = kcalloc(num_banks, sizeof(struct mce_bank), GFP_KERNEL);
 	if (!mce_banks)
 		return -ENOMEM;
 
* Unmerged path arch/x86/kernel/cpu/mcheck/mce_amd.c
diff --git a/arch/x86/kernel/cpu/mtrr/if.c b/arch/x86/kernel/cpu/mtrr/if.c
index a041e094b8b9..fc1d9d762084 100644
--- a/arch/x86/kernel/cpu/mtrr/if.c
+++ b/arch/x86/kernel/cpu/mtrr/if.c
@@ -43,7 +43,7 @@ mtrr_file_add(unsigned long base, unsigned long size,
 
 	max = num_var_ranges;
 	if (fcount == NULL) {
-		fcount = kzalloc(max * sizeof *fcount, GFP_KERNEL);
+		fcount = kcalloc(max, sizeof(*fcount), GFP_KERNEL);
 		if (!fcount)
 			return -ENOMEM;
 		FILE_FCOUNT(file) = fcount;
* Unmerged path arch/x86/kernel/hpet.c
diff --git a/arch/x86/pci/xen.c b/arch/x86/pci/xen.c
index e7a3db43a095..f2cc6cc05332 100644
--- a/arch/x86/pci/xen.c
+++ b/arch/x86/pci/xen.c
@@ -166,7 +166,7 @@ static int xen_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
 	if (type == PCI_CAP_ID_MSI && nvec > 1)
 		return 1;
 
-	v = kzalloc(sizeof(int) * max(1, nvec), GFP_KERNEL);
+	v = kcalloc(max(1, nvec), sizeof(int), GFP_KERNEL);
 	if (!v)
 		return -ENOMEM;
 
diff --git a/arch/x86/platform/uv/uv_time.c b/arch/x86/platform/uv/uv_time.c
index 362c149c799c..5da1d9dedb86 100644
--- a/arch/x86/platform/uv/uv_time.c
+++ b/arch/x86/platform/uv/uv_time.c
@@ -159,7 +159,7 @@ static __init int uv_rtc_allocate_timers(void)
 {
 	int cpu;
 
-	blade_info = kzalloc(uv_possible_blades * sizeof(void *), GFP_KERNEL);
+	blade_info = kcalloc(uv_possible_blades, sizeof(void *), GFP_KERNEL);
 	if (!blade_info)
 		return -ENOMEM;
 
diff --git a/block/blk-tag.c b/block/blk-tag.c
index f0344e6939d5..b9d306a6bc08 100644
--- a/block/blk-tag.c
+++ b/block/blk-tag.c
@@ -98,12 +98,12 @@ init_tag_map(struct request_queue *q, struct blk_queue_tag *tags, int depth)
 		       __func__, depth);
 	}
 
-	tag_index = kzalloc(depth * sizeof(struct request *), GFP_ATOMIC);
+	tag_index = kcalloc(depth, sizeof(struct request *), GFP_ATOMIC);
 	if (!tag_index)
 		goto fail;
 
 	nr_ulongs = ALIGN(depth, BITS_PER_LONG) / BITS_PER_LONG;
-	tag_map = kzalloc(nr_ulongs * sizeof(unsigned long), GFP_ATOMIC);
+	tag_map = kcalloc(nr_ulongs, sizeof(unsigned long), GFP_ATOMIC);
 	if (!tag_map)
 		goto fail;
 
diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 38c826da2b92..bb6737a005a4 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -62,7 +62,7 @@ struct platform_device *acpi_create_platform_device(struct acpi_device *adev)
 	if (count < 0) {
 		return NULL;
 	} else if (count > 0) {
-		resources = kzalloc(count * sizeof(struct resource),
+		resources = kcalloc(count, sizeof(struct resource),
 				    GFP_KERNEL);
 		if (!resources) {
 			dev_err(&adev->dev, "No memory for resources\n");
diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c
index a4c4db16b7d3..8140bcf3058a 100644
--- a/drivers/acpi/sysfs.c
+++ b/drivers/acpi/sysfs.c
@@ -684,12 +684,12 @@ void acpi_irq_stats_init(void)
 	num_gpes = acpi_current_gpe_count;
 	num_counters = num_gpes + ACPI_NUM_FIXED_EVENTS + NUM_COUNTERS_EXTRA;
 
-	all_attrs = kzalloc(sizeof(struct attribute *) * (num_counters + 1),
+	all_attrs = kcalloc(num_counters + 1, sizeof(struct attribute *),
 			    GFP_KERNEL);
 	if (all_attrs == NULL)
 		return;
 
-	all_counters = kzalloc(sizeof(struct event_counter) * (num_counters),
+	all_counters = kcalloc(num_counters, sizeof(struct event_counter),
 			       GFP_KERNEL);
 	if (all_counters == NULL)
 		goto fail;
@@ -698,7 +698,7 @@ void acpi_irq_stats_init(void)
 	if (ACPI_FAILURE(status))
 		goto fail;
 
-	counter_attrs = kzalloc(sizeof(struct kobj_attribute) * (num_counters),
+	counter_attrs = kcalloc(num_counters, sizeof(struct kobj_attribute),
 				GFP_KERNEL);
 	if (counter_attrs == NULL)
 		goto fail;
* Unmerged path drivers/android/binder_alloc.c
diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c
index 34afaa753dc9..8013ee7dbad0 100644
--- a/drivers/ata/libata-core.c
+++ b/drivers/ata/libata-core.c
@@ -6647,7 +6647,7 @@ static void __init ata_parse_force_param(void)
 		if (*p == ',')
 			size++;
 
-	ata_force_tbl = kzalloc(sizeof(ata_force_tbl[0]) * size, GFP_KERNEL);
+	ata_force_tbl = kcalloc(size, sizeof(ata_force_tbl[0]), GFP_KERNEL);
 	if (!ata_force_tbl) {
 		printk(KERN_WARNING "ata: failed to extend force table, "
 		       "libata.force ignored\n");
diff --git a/drivers/ata/libata-pmp.c b/drivers/ata/libata-pmp.c
index 7ccc084bf1df..b1839c7496a8 100644
--- a/drivers/ata/libata-pmp.c
+++ b/drivers/ata/libata-pmp.c
@@ -340,7 +340,7 @@ static int sata_pmp_init_links (struct ata_port *ap, int nr_ports)
 	int i, err;
 
 	if (!pmp_link) {
-		pmp_link = kzalloc(sizeof(pmp_link[0]) * SATA_PMP_MAX_PORTS,
+		pmp_link = kcalloc(SATA_PMP_MAX_PORTS, sizeof(pmp_link[0]),
 				   GFP_NOIO);
 		if (!pmp_link)
 			return -ENOMEM;
diff --git a/drivers/atm/fore200e.c b/drivers/atm/fore200e.c
index 204814e88e46..37591e9d8580 100644
--- a/drivers/atm/fore200e.c
+++ b/drivers/atm/fore200e.c
@@ -2095,7 +2095,8 @@ static int fore200e_alloc_rx_buf(struct fore200e *fore200e)
 	    DPRINTK(2, "rx buffers %d / %d are being allocated\n", scheme, magn);
 
 	    /* allocate the array of receive buffers */
-	    buffer = bsq->buffer = kzalloc(nbr * sizeof(struct buffer), GFP_KERNEL);
+	    buffer = bsq->buffer = kcalloc(nbr, sizeof(struct buffer),
+                                           GFP_KERNEL);
 
 	    if (buffer == NULL)
 		return -ENOMEM;
diff --git a/drivers/atm/iphase.c b/drivers/atm/iphase.c
index 4217f29a85e0..d128a3229735 100644
--- a/drivers/atm/iphase.c
+++ b/drivers/atm/iphase.c
@@ -1617,7 +1617,7 @@ static int rx_init(struct atm_dev *dev)
 	skb_queue_head_init(&iadev->rx_dma_q);  
 	iadev->rx_free_desc_qhead = NULL;   
 
-	iadev->rx_open = kzalloc(4 * iadev->num_vc, GFP_KERNEL);
+	iadev->rx_open = kcalloc(4, iadev->num_vc, GFP_KERNEL);
 	if (!iadev->rx_open) {
 		printk(KERN_ERR DEV_LABEL "itf %d couldn't get free page\n",
 		dev->number);  
* Unmerged path drivers/block/drbd/drbd_main.c
* Unmerged path drivers/block/null_blk.c
* Unmerged path drivers/block/ps3vram.c
diff --git a/drivers/block/rsxx/core.c b/drivers/block/rsxx/core.c
index 820b4009d5f7..298361bf855f 100644
--- a/drivers/block/rsxx/core.c
+++ b/drivers/block/rsxx/core.c
@@ -925,7 +925,8 @@ static int rsxx_pci_probe(struct pci_dev *dev,
 		dev_info(CARD_TO_DEV(card),
 			"Failed reading the number of DMA targets\n");
 
-	card->ctrl = kzalloc(card->n_targets * sizeof(*card->ctrl), GFP_KERNEL);
+	card->ctrl = kcalloc(card->n_targets, sizeof(*card->ctrl),
+			     GFP_KERNEL);
 	if (!card->ctrl) {
 		st = -ENOMEM;
 		goto failed_dma_setup;
diff --git a/drivers/block/rsxx/dma.c b/drivers/block/rsxx/dma.c
index fc88ba3e1bd2..f57cc04dae98 100644
--- a/drivers/block/rsxx/dma.c
+++ b/drivers/block/rsxx/dma.c
@@ -1039,7 +1039,7 @@ int rsxx_eeh_save_issued_dmas(struct rsxx_cardinfo *card)
 	struct rsxx_dma *dma;
 	struct list_head *issued_dmas;
 
-	issued_dmas = kzalloc(sizeof(*issued_dmas) * card->n_targets,
+	issued_dmas = kcalloc(card->n_targets, sizeof(*issued_dmas),
 			      GFP_KERNEL);
 	if (!issued_dmas)
 		return -ENOMEM;
* Unmerged path drivers/block/xen-blkback/xenbus.c
* Unmerged path drivers/block/xen-blkfront.c
diff --git a/drivers/char/agp/amd-k7-agp.c b/drivers/char/agp/amd-k7-agp.c
index 5fbd333e4c6d..9b37e1754856 100644
--- a/drivers/char/agp/amd-k7-agp.c
+++ b/drivers/char/agp/amd-k7-agp.c
@@ -85,7 +85,8 @@ static int amd_create_gatt_pages(int nr_tables)
 	int retval = 0;
 	int i;
 
-	tables = kzalloc((nr_tables + 1) * sizeof(struct amd_page_map *),GFP_KERNEL);
+	tables = kcalloc(nr_tables + 1, sizeof(struct amd_page_map *),
+			 GFP_KERNEL);
 	if (tables == NULL)
 		return -ENOMEM;
 
diff --git a/drivers/char/agp/ati-agp.c b/drivers/char/agp/ati-agp.c
index 0b5ec7af2414..3db6f6dc8ecd 100644
--- a/drivers/char/agp/ati-agp.c
+++ b/drivers/char/agp/ati-agp.c
@@ -108,7 +108,8 @@ static int ati_create_gatt_pages(int nr_tables)
 	int retval = 0;
 	int i;
 
-	tables = kzalloc((nr_tables + 1) * sizeof(struct ati_page_map *),GFP_KERNEL);
+	tables = kcalloc(nr_tables + 1, sizeof(struct ati_page_map *),
+			 GFP_KERNEL);
 	if (tables == NULL)
 		return -ENOMEM;
 
diff --git a/drivers/char/agp/sworks-agp.c b/drivers/char/agp/sworks-agp.c
index 03be4ac79b0d..71ea2cac20d0 100644
--- a/drivers/char/agp/sworks-agp.c
+++ b/drivers/char/agp/sworks-agp.c
@@ -96,7 +96,7 @@ static int serverworks_create_gatt_pages(int nr_tables)
 	int retval = 0;
 	int i;
 
-	tables = kzalloc((nr_tables + 1) * sizeof(struct serverworks_page_map *),
+	tables = kcalloc(nr_tables + 1, sizeof(struct serverworks_page_map *),
 			 GFP_KERNEL);
 	if (tables == NULL)
 		return -ENOMEM;
diff --git a/drivers/char/ipmi/ipmi_ssif.c b/drivers/char/ipmi/ipmi_ssif.c
index f848b5306c6a..db17000d506c 100644
--- a/drivers/char/ipmi/ipmi_ssif.c
+++ b/drivers/char/ipmi/ipmi_ssif.c
@@ -2021,7 +2021,8 @@ static unsigned short *ssif_address_list(void)
 	list_for_each_entry(info, &ssif_infos, link)
 		count++;
 
-	address_list = kzalloc(sizeof(*address_list) * (count + 1), GFP_KERNEL);
+	address_list = kcalloc(count + 1, sizeof(*address_list),
+			       GFP_KERNEL);
 	if (!address_list)
 		return NULL;
 
* Unmerged path drivers/clk/renesas/clk-r8a7740.c
* Unmerged path drivers/clk/renesas/clk-r8a7779.c
* Unmerged path drivers/clk/renesas/clk-rcar-gen2.c
* Unmerged path drivers/clk/renesas/clk-rz.c
* Unmerged path drivers/clk/st/clkgen-fsyn.c
* Unmerged path drivers/clk/st/clkgen-pll.c
* Unmerged path drivers/clk/sunxi/clk-usb.c
* Unmerged path drivers/clk/tegra/clk.c
* Unmerged path drivers/clk/ti/apll.c
* Unmerged path drivers/clk/ti/divider.c
* Unmerged path drivers/clk/ti/dpll.c
* Unmerged path drivers/clocksource/sh_cmt.c
* Unmerged path drivers/clocksource/sh_mtu2.c
* Unmerged path drivers/clocksource/sh_tmu.c
* Unmerged path drivers/cpufreq/acpi-cpufreq.c
* Unmerged path drivers/cpufreq/arm_big_little.c
diff --git a/drivers/cpufreq/cppc_cpufreq.c b/drivers/cpufreq/cppc_cpufreq.c
index 10be285c9055..947c496fd4c0 100644
--- a/drivers/cpufreq/cppc_cpufreq.c
+++ b/drivers/cpufreq/cppc_cpufreq.c
@@ -204,7 +204,8 @@ static int __init cppc_cpufreq_init(void)
 	if (acpi_disabled)
 		return -ENODEV;
 
-	all_cpu_data = kzalloc(sizeof(void *) * num_possible_cpus(), GFP_KERNEL);
+	all_cpu_data = kcalloc(num_possible_cpus(), sizeof(void *),
+			       GFP_KERNEL);
 	if (!all_cpu_data)
 		return -ENOMEM;
 
* Unmerged path drivers/cpufreq/ia64-acpi-cpufreq.c
* Unmerged path drivers/cpufreq/longhaul.c
diff --git a/drivers/cpufreq/pxa3xx-cpufreq.c b/drivers/cpufreq/pxa3xx-cpufreq.c
index 15d60f857ad5..50f499fe5b6d 100644
--- a/drivers/cpufreq/pxa3xx-cpufreq.c
+++ b/drivers/cpufreq/pxa3xx-cpufreq.c
@@ -93,7 +93,7 @@ static int setup_freqs_table(struct cpufreq_policy *policy,
 	struct cpufreq_frequency_table *table;
 	int i;
 
-	table = kzalloc((num + 1) * sizeof(*table), GFP_KERNEL);
+	table = kcalloc(num + 1, sizeof(*table), GFP_KERNEL);
 	if (table == NULL)
 		return -ENOMEM;
 
* Unmerged path drivers/cpufreq/sfi-cpufreq.c
* Unmerged path drivers/cpufreq/spear-cpufreq.c
* Unmerged path drivers/crypto/amcc/crypto4xx_core.c
* Unmerged path drivers/crypto/inside-secure/safexcel_hash.c
* Unmerged path drivers/crypto/marvell/hash.c
diff --git a/drivers/crypto/n2_core.c b/drivers/crypto/n2_core.c
index e1f0ab413c3b..26be524c56c4 100644
--- a/drivers/crypto/n2_core.c
+++ b/drivers/crypto/n2_core.c
@@ -1927,12 +1927,12 @@ static int grab_global_resources(void)
 		goto out_hvapi_release;
 
 	err = -ENOMEM;
-	cpu_to_cwq = kzalloc(sizeof(struct spu_queue *) * NR_CPUS,
+	cpu_to_cwq = kcalloc(NR_CPUS, sizeof(struct spu_queue *),
 			     GFP_KERNEL);
 	if (!cpu_to_cwq)
 		goto out_queue_cache_destroy;
 
-	cpu_to_mau = kzalloc(sizeof(struct spu_queue *) * NR_CPUS,
+	cpu_to_mau = kcalloc(NR_CPUS, sizeof(struct spu_queue *),
 			     GFP_KERNEL);
 	if (!cpu_to_mau)
 		goto out_free_cwq_table;
diff --git a/drivers/crypto/qat/qat_common/qat_uclo.c b/drivers/crypto/qat/qat_common/qat_uclo.c
index 98d22c2096e3..6bd8f6a2a24f 100644
--- a/drivers/crypto/qat/qat_common/qat_uclo.c
+++ b/drivers/crypto/qat/qat_common/qat_uclo.c
@@ -1162,8 +1162,9 @@ static int qat_uclo_map_suof(struct icp_qat_fw_loader_handle *handle,
 	suof_handle->img_table.num_simgs = suof_ptr->num_chunks - 1;
 
 	if (suof_handle->img_table.num_simgs != 0) {
-		suof_img_hdr = kzalloc(suof_handle->img_table.num_simgs *
-				       sizeof(img_header), GFP_KERNEL);
+		suof_img_hdr = kcalloc(suof_handle->img_table.num_simgs,
+				       sizeof(img_header),
+				       GFP_KERNEL);
 		if (!suof_img_hdr)
 			return -ENOMEM;
 		suof_handle->img_table.simg_hdr = suof_img_hdr;
* Unmerged path drivers/dma/ioat/init.c
* Unmerged path drivers/dma/mv_xor.c
* Unmerged path drivers/dma/pl330.c
diff --git a/drivers/dma/sh/shdma-base.c b/drivers/dma/sh/shdma-base.c
index 4acb85a10250..a65c1e33503a 100644
--- a/drivers/dma/sh/shdma-base.c
+++ b/drivers/dma/sh/shdma-base.c
@@ -921,8 +921,9 @@ EXPORT_SYMBOL(shdma_cleanup);
 
 static int __init shdma_enter(void)
 {
-	shdma_slave_used = kzalloc(DIV_ROUND_UP(slave_num, BITS_PER_LONG) *
-				    sizeof(long), GFP_KERNEL);
+	shdma_slave_used = kcalloc(DIV_ROUND_UP(slave_num, BITS_PER_LONG),
+				   sizeof(long),
+				   GFP_KERNEL);
 	if (!shdma_slave_used)
 		return -ENOMEM;
 	return 0;
* Unmerged path drivers/dma/xilinx/zynqmp_dma.c
* Unmerged path drivers/edac/amd64_edac.c
diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c
index 002d39c3d788..3b64a816f951 100644
--- a/drivers/edac/i7core_edac.c
+++ b/drivers/edac/i7core_edac.c
@@ -471,7 +471,7 @@ static struct i7core_dev *alloc_i7core_dev(u8 socket,
 	if (!i7core_dev)
 		return NULL;
 
-	i7core_dev->pdev = kzalloc(sizeof(*i7core_dev->pdev) * table->n_devs,
+	i7core_dev->pdev = kcalloc(table->n_devs, sizeof(*i7core_dev->pdev),
 				   GFP_KERNEL);
 	if (!i7core_dev->pdev) {
 		kfree(i7core_dev);
* Unmerged path drivers/extcon/extcon.c
diff --git a/drivers/firmware/dell_rbu.c b/drivers/firmware/dell_rbu.c
index 04ebc8956016..37cb94b9889a 100644
--- a/drivers/firmware/dell_rbu.c
+++ b/drivers/firmware/dell_rbu.c
@@ -147,7 +147,7 @@ static int create_packet(void *data, size_t length)
 	packet_array_size = max(
 	       		(unsigned int)(allocation_floor / rbu_data.packetsize),
 			(unsigned int)1);
-	invalid_addr_packet_array = kzalloc(packet_array_size * sizeof(void*),
+	invalid_addr_packet_array = kcalloc(packet_array_size, sizeof(void *),
 						GFP_KERNEL);
 
 	if (!invalid_addr_packet_array) {
* Unmerged path drivers/firmware/efi/capsule.c
* Unmerged path drivers/firmware/efi/runtime-map.c
* Unmerged path drivers/fmc/fmc-sdb.c
diff --git a/drivers/gpio/gpio-ml-ioh.c b/drivers/gpio/gpio-ml-ioh.c
index 0183add9b232..9fc673af34ca 100644
--- a/drivers/gpio/gpio-ml-ioh.c
+++ b/drivers/gpio/gpio-ml-ioh.c
@@ -435,7 +435,7 @@ static int ioh_gpio_probe(struct pci_dev *pdev,
 		goto err_iomap;
 	}
 
-	chip_save = kzalloc(sizeof(*chip) * 8, GFP_KERNEL);
+	chip_save = kcalloc(8, sizeof(*chip), GFP_KERNEL);
 	if (chip_save == NULL) {
 		dev_err(&pdev->dev, "%s : kzalloc failed", __func__);
 		ret = -ENOMEM;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c
index a29362f9ef41..5a49c5d7def4 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c
@@ -311,20 +311,20 @@ static int acp_hw_init(void *handle)
 		pm_genpd_init(&adev->acp.acp_genpd->gpd, NULL, false);
 	}
 
-	adev->acp.acp_cell = kzalloc(sizeof(struct mfd_cell) * ACP_DEVS,
+	adev->acp.acp_cell = kcalloc(ACP_DEVS, sizeof(struct mfd_cell),
 							GFP_KERNEL);
 
 	if (adev->acp.acp_cell == NULL)
 		return -ENOMEM;
 
-	adev->acp.acp_res = kzalloc(sizeof(struct resource) * 4, GFP_KERNEL);
+	adev->acp.acp_res = kcalloc(4, sizeof(struct resource), GFP_KERNEL);
 
 	if (adev->acp.acp_res == NULL) {
 		kfree(adev->acp.acp_cell);
 		return -ENOMEM;
 	}
 
-	i2s_pdata = kzalloc(sizeof(struct i2s_platform_data) * 2, GFP_KERNEL);
+	i2s_pdata = kcalloc(2, sizeof(struct i2s_platform_data), GFP_KERNEL);
 	if (i2s_pdata == NULL) {
 		kfree(adev->acp.acp_res);
 		kfree(adev->acp.acp_cell);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c
index e997ebbe43ea..9673b1ce5e6b 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c
@@ -432,7 +432,7 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 			ATOM_PPLIB_PhaseSheddingLimits_Record *entry;
 
 			adev->pm.dpm.dyn_state.phase_shedding_limits_table.entries =
-				kzalloc(psl->ucNumEntries *
+				kcalloc(psl->ucNumEntries,
 					sizeof(struct amdgpu_phase_shedding_limits_entry),
 					GFP_KERNEL);
 			if (!adev->pm.dpm.dyn_state.phase_shedding_limits_table.entries) {
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_test.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_test.c
index 2dbe87591f81..45f22df1917a 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_test.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_test.c
@@ -52,7 +52,7 @@ static void amdgpu_do_test_moves(struct amdgpu_device *adev)
 		n -= adev->irq.ih.ring_size;
 	n /= size;
 
-	gtt_obj = kzalloc(n * sizeof(*gtt_obj), GFP_KERNEL);
+	gtt_obj = kcalloc(n, sizeof(*gtt_obj), GFP_KERNEL);
 	if (!gtt_obj) {
 		DRM_ERROR("Failed to allocate %d pointers\n", n);
 		r = 1;
diff --git a/drivers/gpu/drm/amd/amdgpu/atom.c b/drivers/gpu/drm/amd/amdgpu/atom.c
index 69500a8b4e2d..e9934de1b9cf 100644
--- a/drivers/gpu/drm/amd/amdgpu/atom.c
+++ b/drivers/gpu/drm/amd/amdgpu/atom.c
@@ -1221,7 +1221,7 @@ static int amdgpu_atom_execute_table_locked(struct atom_context *ctx, int index,
 	ectx.abort = false;
 	ectx.last_jump = 0;
 	if (ws)
-		ectx.ws = kzalloc(4 * ws, GFP_KERNEL);
+		ectx.ws = kcalloc(4, ws, GFP_KERNEL);
 	else
 		ectx.ws = NULL;
 
diff --git a/drivers/gpu/drm/amd/amdgpu/ci_dpm.c b/drivers/gpu/drm/amd/amdgpu/ci_dpm.c
index 47ef3e6e7178..45457c569e44 100644
--- a/drivers/gpu/drm/amd/amdgpu/ci_dpm.c
+++ b/drivers/gpu/drm/amd/amdgpu/ci_dpm.c
@@ -5679,8 +5679,9 @@ static int ci_parse_power_table(struct amdgpu_device *adev)
 		(mode_info->atom_context->bios + data_offset +
 		 le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));
 
-	adev->pm.dpm.ps = kzalloc(sizeof(struct amdgpu_ps) *
-				  state_array->ucNumEntries, GFP_KERNEL);
+	adev->pm.dpm.ps = kcalloc(state_array->ucNumEntries,
+				  sizeof(struct amdgpu_ps),
+				  GFP_KERNEL);
 	if (!adev->pm.dpm.ps)
 		return -ENOMEM;
 	power_state_offset = (u8 *)state_array->states;
@@ -5927,7 +5928,9 @@ static int ci_dpm_init(struct amdgpu_device *adev)
 	ci_set_private_data_variables_based_on_pptable(adev);
 
 	adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =
-		kzalloc(4 * sizeof(struct amdgpu_clock_voltage_dependency_entry), GFP_KERNEL);
+		kcalloc(4,
+			sizeof(struct amdgpu_clock_voltage_dependency_entry),
+			GFP_KERNEL);
 	if (!adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) {
 		ci_dpm_fini(adev);
 		return -ENOMEM;
diff --git a/drivers/gpu/drm/amd/amdgpu/kv_dpm.c b/drivers/gpu/drm/amd/amdgpu/kv_dpm.c
index 26ba984ab2b7..3370effffb5b 100644
--- a/drivers/gpu/drm/amd/amdgpu/kv_dpm.c
+++ b/drivers/gpu/drm/amd/amdgpu/kv_dpm.c
@@ -2727,8 +2727,9 @@ static int kv_parse_power_table(struct amdgpu_device *adev)
 		(mode_info->atom_context->bios + data_offset +
 		 le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));
 
-	adev->pm.dpm.ps = kzalloc(sizeof(struct amdgpu_ps) *
-				  state_array->ucNumEntries, GFP_KERNEL);
+	adev->pm.dpm.ps = kcalloc(state_array->ucNumEntries,
+				  sizeof(struct amdgpu_ps),
+				  GFP_KERNEL);
 	if (!adev->pm.dpm.ps)
 		return -ENOMEM;
 	power_state_offset = (u8 *)state_array->states;
diff --git a/drivers/gpu/drm/amd/amdgpu/si_dpm.c b/drivers/gpu/drm/amd/amdgpu/si_dpm.c
index 797d505bf9ee..700ac9bf057f 100644
--- a/drivers/gpu/drm/amd/amdgpu/si_dpm.c
+++ b/drivers/gpu/drm/amd/amdgpu/si_dpm.c
@@ -7242,8 +7242,9 @@ static int si_parse_power_table(struct amdgpu_device *adev)
 		(mode_info->atom_context->bios + data_offset +
 		 le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));
 
-	adev->pm.dpm.ps = kzalloc(sizeof(struct amdgpu_ps) *
-				  state_array->ucNumEntries, GFP_KERNEL);
+	adev->pm.dpm.ps = kcalloc(state_array->ucNumEntries,
+				  sizeof(struct amdgpu_ps),
+				  GFP_KERNEL);
 	if (!adev->pm.dpm.ps)
 		return -ENOMEM;
 	power_state_offset = (u8 *)state_array->states;
@@ -7346,7 +7347,9 @@ static int si_dpm_init(struct amdgpu_device *adev)
 		return ret;
 
 	adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =
-		kzalloc(4 * sizeof(struct amdgpu_clock_voltage_dependency_entry), GFP_KERNEL);
+		kcalloc(4,
+			sizeof(struct amdgpu_clock_voltage_dependency_entry),
+			GFP_KERNEL);
 	if (!adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) {
 		amdgpu_free_extended_power_table(adev);
 		return -ENOMEM;
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c
index ca0b08bfa2cf..9b4a72f29692 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c
@@ -440,7 +440,7 @@ bool dm_helpers_submit_i2c(
 		return false;
 	}
 
-	msgs = kzalloc(num * sizeof(struct i2c_msg), GFP_KERNEL);
+	msgs = kcalloc(num, sizeof(struct i2c_msg), GFP_KERNEL);
 
 	if (!msgs)
 		return false;
diff --git a/drivers/gpu/drm/amd/display/dc/basics/logger.c b/drivers/gpu/drm/amd/display/dc/basics/logger.c
index 31bee054f43a..4a0af5e953f4 100644
--- a/drivers/gpu/drm/amd/display/dc/basics/logger.c
+++ b/drivers/gpu/drm/amd/display/dc/basics/logger.c
@@ -364,7 +364,7 @@ void dm_logger_open(
 	entry->type = log_type;
 	entry->logger = logger;
 
-	entry->buf = kzalloc(DAL_LOGGER_BUFFER_MAX_SIZE * sizeof(char),
+	entry->buf = kzalloc(DAL_LOGGER_BUFFER_MAX_SIZE,
 			     GFP_KERNEL);
 
 	entry->buf_offset = 0;
diff --git a/drivers/gpu/drm/amd/display/dc/basics/vector.c b/drivers/gpu/drm/amd/display/dc/basics/vector.c
index 217b8f1f7bf6..d28e9cf0e961 100644
--- a/drivers/gpu/drm/amd/display/dc/basics/vector.c
+++ b/drivers/gpu/drm/amd/display/dc/basics/vector.c
@@ -40,7 +40,7 @@ bool dal_vector_construct(
 		return false;
 	}
 
-	vector->container = kzalloc(struct_size * capacity, GFP_KERNEL);
+	vector->container = kcalloc(capacity, struct_size, GFP_KERNEL);
 	if (vector->container == NULL)
 		return false;
 	vector->capacity = capacity;
@@ -67,7 +67,7 @@ bool dal_vector_presized_costruct(
 		return false;
 	}
 
-	vector->container = kzalloc(struct_size * count, GFP_KERNEL);
+	vector->container = kcalloc(count, struct_size, GFP_KERNEL);
 
 	if (vector->container == NULL)
 		return false;
diff --git a/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.c b/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.c
index 0aa2cda60890..89fed41c6d58 100644
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.c
@@ -1076,13 +1076,15 @@ static void get_ss_info_from_atombios(
 	if (*ss_entries_num == 0)
 		return;
 
-	ss_info = kzalloc(sizeof(struct spread_spectrum_info) * (*ss_entries_num),
+	ss_info = kcalloc(*ss_entries_num,
+			  sizeof(struct spread_spectrum_info),
 			  GFP_KERNEL);
 	ss_info_cur = ss_info;
 	if (ss_info == NULL)
 		return;
 
-	ss_data = kzalloc(sizeof(struct spread_spectrum_data) * (*ss_entries_num),
+	ss_data = kcalloc(*ss_entries_num,
+			  sizeof(struct spread_spectrum_data),
 			  GFP_KERNEL);
 	if (ss_data == NULL)
 		goto out_free_info;
diff --git a/drivers/gpu/drm/amd/display/dc/gpio/gpio_service.c b/drivers/gpu/drm/amd/display/dc/gpio/gpio_service.c
index 80038e0e610f..ab5483c0c502 100644
--- a/drivers/gpu/drm/amd/display/dc/gpio/gpio_service.c
+++ b/drivers/gpu/drm/amd/display/dc/gpio/gpio_service.c
@@ -98,7 +98,8 @@ struct gpio_service *dal_gpio_service_create(
 			if (number_of_bits) {
 				uint32_t index_of_uint = 0;
 
-				slot = kzalloc(number_of_uints * sizeof(uint32_t),
+				slot = kcalloc(number_of_uints,
+					       sizeof(uint32_t),
 					       GFP_KERNEL);
 
 				if (!slot) {
* Unmerged path drivers/gpu/drm/amd/display/modules/color/color_gamma.c
diff --git a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
index 27d4003aa2c7..fa344ceafc17 100644
--- a/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
+++ b/drivers/gpu/drm/amd/display/modules/freesync/freesync.c
@@ -155,7 +155,8 @@ struct mod_freesync *mod_freesync_create(struct dc *dc)
 	if (core_freesync == NULL)
 		goto fail_alloc_context;
 
-	core_freesync->map = kzalloc(sizeof(struct freesync_entity) * MOD_FREESYNC_MAX_CONCURRENT_STREAMS,
+	core_freesync->map = kcalloc(MOD_FREESYNC_MAX_CONCURRENT_STREAMS,
+					sizeof(struct freesync_entity),
 					GFP_KERNEL);
 
 	if (core_freesync->map == NULL)
* Unmerged path drivers/gpu/drm/amd/display/modules/stats/stats.c
diff --git a/drivers/gpu/drm/amd/powerplay/hwmgr/pp_psm.c b/drivers/gpu/drm/amd/powerplay/hwmgr/pp_psm.c
index 0f2851b5b368..072336949a43 100644
--- a/drivers/gpu/drm/amd/powerplay/hwmgr/pp_psm.c
+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/pp_psm.c
@@ -50,7 +50,7 @@ int psm_init_power_state_table(struct pp_hwmgr *hwmgr)
 		return 0;
 	}
 
-	hwmgr->ps = kzalloc(size * table_entries, GFP_KERNEL);
+	hwmgr->ps = kcalloc(table_entries, size, GFP_KERNEL);
 	if (hwmgr->ps == NULL)
 		return -ENOMEM;
 
diff --git a/drivers/gpu/drm/i915/gvt/vgpu.c b/drivers/gpu/drm/i915/gvt/vgpu.c
index 2e0a02a80fe4..572a18c2bfb5 100644
--- a/drivers/gpu/drm/i915/gvt/vgpu.c
+++ b/drivers/gpu/drm/i915/gvt/vgpu.c
@@ -121,7 +121,7 @@ int intel_gvt_init_vgpu_types(struct intel_gvt *gvt)
 	high_avail = gvt_hidden_sz(gvt) - HOST_HIGH_GM_SIZE;
 	num_types = sizeof(vgpu_types) / sizeof(vgpu_types[0]);
 
-	gvt->types = kzalloc(num_types * sizeof(struct intel_vgpu_type),
+	gvt->types = kcalloc(num_types, sizeof(struct intel_vgpu_type),
 			     GFP_KERNEL);
 	if (!gvt->types)
 		return -ENOMEM;
* Unmerged path drivers/gpu/drm/i915/intel_hdcp.c
diff --git a/drivers/gpu/drm/i915/selftests/intel_uncore.c b/drivers/gpu/drm/i915/selftests/intel_uncore.c
index f76f2597df5c..47bc5b2ddb56 100644
--- a/drivers/gpu/drm/i915/selftests/intel_uncore.c
+++ b/drivers/gpu/drm/i915/selftests/intel_uncore.c
@@ -137,7 +137,7 @@ static int intel_uncore_check_forcewake_domains(struct drm_i915_private *dev_pri
 	if (!IS_ENABLED(CONFIG_DRM_I915_SELFTEST_BROKEN))
 		return 0;
 
-	valid = kzalloc(BITS_TO_LONGS(FW_RANGE) * sizeof(*valid),
+	valid = kcalloc(BITS_TO_LONGS(FW_RANGE), sizeof(*valid),
 			GFP_KERNEL);
 	if (!valid)
 		return -ENOMEM;
diff --git a/drivers/gpu/drm/nouveau/nvif/fifo.c b/drivers/gpu/drm/nouveau/nvif/fifo.c
index 99d4fd17543c..e84a2e2ff043 100644
--- a/drivers/gpu/drm/nouveau/nvif/fifo.c
+++ b/drivers/gpu/drm/nouveau/nvif/fifo.c
@@ -50,8 +50,8 @@ nvif_fifo_runlists(struct nvif_device *device)
 		goto done;
 
 	device->runlists = fls64(a->v.runlists.data);
-	device->runlist = kzalloc(sizeof(*device->runlist) *
-				  device->runlists, GFP_KERNEL);
+	device->runlist = kcalloc(device->runlists, sizeof(*device->runlist),
+				  GFP_KERNEL);
 	if (!device->runlist) {
 		ret = -ENOMEM;
 		goto done;
diff --git a/drivers/gpu/drm/nouveau/nvif/object.c b/drivers/gpu/drm/nouveau/nvif/object.c
index 40adfe9b334b..ef3f62840e83 100644
--- a/drivers/gpu/drm/nouveau/nvif/object.c
+++ b/drivers/gpu/drm/nouveau/nvif/object.c
@@ -83,7 +83,7 @@ nvif_object_sclass_get(struct nvif_object *object, struct nvif_sclass **psclass)
 			return ret;
 	}
 
-	*psclass = kzalloc(sizeof(**psclass) * args->sclass.count, GFP_KERNEL);
+	*psclass = kcalloc(args->sclass.count, sizeof(**psclass), GFP_KERNEL);
 	if (*psclass) {
 		for (i = 0; i < args->sclass.count; i++) {
 			(*psclass)[i].oclass = args->sclass.oclass[i].oclass;
diff --git a/drivers/gpu/drm/nouveau/nvkm/core/event.c b/drivers/gpu/drm/nouveau/nvkm/core/event.c
index 4e8d3fa042df..006618d77aa4 100644
--- a/drivers/gpu/drm/nouveau/nvkm/core/event.c
+++ b/drivers/gpu/drm/nouveau/nvkm/core/event.c
@@ -84,7 +84,8 @@ int
 nvkm_event_init(const struct nvkm_event_func *func, int types_nr, int index_nr,
 		struct nvkm_event *event)
 {
-	event->refs = kzalloc(sizeof(*event->refs) * index_nr * types_nr,
+	event->refs = kzalloc(array3_size(index_nr, types_nr,
+					  sizeof(*event->refs)),
 			      GFP_KERNEL);
 	if (!event->refs)
 		return -ENOMEM;
diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/gk104.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/gk104.c
index a99046414a18..afccf9721cf0 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/gk104.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/gk104.c
@@ -910,7 +910,7 @@ gk104_fifo_oneinit(struct nvkm_fifo *base)
 	nvkm_debug(subdev, "%d PBDMA(s)\n", fifo->pbdma_nr);
 
 	/* Read PBDMA->runlist(s) mapping from HW. */
-	if (!(map = kzalloc(sizeof(*map) * fifo->pbdma_nr, GFP_KERNEL)))
+	if (!(map = kcalloc(fifo->pbdma_nr, sizeof(*map), GFP_KERNEL)))
 		return -ENOMEM;
 
 	for (i = 0; i < fifo->pbdma_nr; i++)
diff --git a/drivers/gpu/drm/omapdrm/omap_gem.c b/drivers/gpu/drm/omapdrm/omap_gem.c
index 8e9fe9e2bbc1..497d2e6ea35b 100644
--- a/drivers/gpu/drm/omapdrm/omap_gem.c
+++ b/drivers/gpu/drm/omapdrm/omap_gem.c
@@ -258,7 +258,7 @@ static int omap_gem_attach_pages(struct drm_gem_object *obj)
 					0, PAGE_SIZE, DMA_BIDIRECTIONAL);
 		}
 	} else {
-		addrs = kzalloc(npages * sizeof(*addrs), GFP_KERNEL);
+		addrs = kcalloc(npages, sizeof(*addrs), GFP_KERNEL);
 		if (!addrs) {
 			ret = -ENOMEM;
 			goto free_pages;
diff --git a/drivers/gpu/drm/radeon/atom.c b/drivers/gpu/drm/radeon/atom.c
index 6a2e091aa7b6..e55cbeee7a53 100644
--- a/drivers/gpu/drm/radeon/atom.c
+++ b/drivers/gpu/drm/radeon/atom.c
@@ -1176,7 +1176,7 @@ static int atom_execute_table_locked(struct atom_context *ctx, int index, uint32
 	ectx.abort = false;
 	ectx.last_jump = 0;
 	if (ws)
-		ectx.ws = kzalloc(4 * ws, GFP_KERNEL);
+		ectx.ws = kcalloc(4, ws, GFP_KERNEL);
 	else
 		ectx.ws = NULL;
 
diff --git a/drivers/gpu/drm/radeon/btc_dpm.c b/drivers/gpu/drm/radeon/btc_dpm.c
index 95652e643da1..0aef4937c901 100644
--- a/drivers/gpu/drm/radeon/btc_dpm.c
+++ b/drivers/gpu/drm/radeon/btc_dpm.c
@@ -2581,7 +2581,9 @@ int btc_dpm_init(struct radeon_device *rdev)
 		return ret;
 
 	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =
-		kzalloc(4 * sizeof(struct radeon_clock_voltage_dependency_entry), GFP_KERNEL);
+		kcalloc(4,
+			sizeof(struct radeon_clock_voltage_dependency_entry),
+			GFP_KERNEL);
 	if (!rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) {
 		r600_free_extended_power_table(rdev);
 		return -ENOMEM;
diff --git a/drivers/gpu/drm/radeon/ci_dpm.c b/drivers/gpu/drm/radeon/ci_dpm.c
index 7e1b04dc5593..b9302c918271 100644
--- a/drivers/gpu/drm/radeon/ci_dpm.c
+++ b/drivers/gpu/drm/radeon/ci_dpm.c
@@ -5568,8 +5568,9 @@ static int ci_parse_power_table(struct radeon_device *rdev)
 		(mode_info->atom_context->bios + data_offset +
 		 le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));
 
-	rdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *
-				  state_array->ucNumEntries, GFP_KERNEL);
+	rdev->pm.dpm.ps = kcalloc(state_array->ucNumEntries,
+				  sizeof(struct radeon_ps),
+				  GFP_KERNEL);
 	if (!rdev->pm.dpm.ps)
 		return -ENOMEM;
 	power_state_offset = (u8 *)state_array->states;
@@ -5770,7 +5771,9 @@ int ci_dpm_init(struct radeon_device *rdev)
 	ci_set_private_data_variables_based_on_pptable(rdev);
 
 	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =
-		kzalloc(4 * sizeof(struct radeon_clock_voltage_dependency_entry), GFP_KERNEL);
+		kcalloc(4,
+			sizeof(struct radeon_clock_voltage_dependency_entry),
+			GFP_KERNEL);
 	if (!rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) {
 		ci_dpm_fini(rdev);
 		return -ENOMEM;
diff --git a/drivers/gpu/drm/radeon/kv_dpm.c b/drivers/gpu/drm/radeon/kv_dpm.c
index ae1529b0ef6f..f055d6ea3522 100644
--- a/drivers/gpu/drm/radeon/kv_dpm.c
+++ b/drivers/gpu/drm/radeon/kv_dpm.c
@@ -2660,8 +2660,9 @@ static int kv_parse_power_table(struct radeon_device *rdev)
 		(mode_info->atom_context->bios + data_offset +
 		 le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));
 
-	rdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *
-				  state_array->ucNumEntries, GFP_KERNEL);
+	rdev->pm.dpm.ps = kcalloc(state_array->ucNumEntries,
+				  sizeof(struct radeon_ps),
+				  GFP_KERNEL);
 	if (!rdev->pm.dpm.ps)
 		return -ENOMEM;
 	power_state_offset = (u8 *)state_array->states;
diff --git a/drivers/gpu/drm/radeon/ni_dpm.c b/drivers/gpu/drm/radeon/ni_dpm.c
index 9416e72f86aa..0fd8d6ba9828 100644
--- a/drivers/gpu/drm/radeon/ni_dpm.c
+++ b/drivers/gpu/drm/radeon/ni_dpm.c
@@ -3998,8 +3998,9 @@ static int ni_parse_power_table(struct radeon_device *rdev)
 		return -EINVAL;
 	power_info = (union power_info *)(mode_info->atom_context->bios + data_offset);
 
-	rdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *
-				  power_info->pplib.ucNumStates, GFP_KERNEL);
+	rdev->pm.dpm.ps = kcalloc(power_info->pplib.ucNumStates,
+				  sizeof(struct radeon_ps),
+				  GFP_KERNEL);
 	if (!rdev->pm.dpm.ps)
 		return -ENOMEM;
 
@@ -4075,7 +4076,9 @@ int ni_dpm_init(struct radeon_device *rdev)
 		return ret;
 
 	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =
-		kzalloc(4 * sizeof(struct radeon_clock_voltage_dependency_entry), GFP_KERNEL);
+		kcalloc(4,
+			sizeof(struct radeon_clock_voltage_dependency_entry),
+			GFP_KERNEL);
 	if (!rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) {
 		r600_free_extended_power_table(rdev);
 		return -ENOMEM;
diff --git a/drivers/gpu/drm/radeon/r600_dpm.c b/drivers/gpu/drm/radeon/r600_dpm.c
index 31d1b4710844..73d4c5348116 100644
--- a/drivers/gpu/drm/radeon/r600_dpm.c
+++ b/drivers/gpu/drm/radeon/r600_dpm.c
@@ -991,7 +991,7 @@ int r600_parse_extended_power_table(struct radeon_device *rdev)
 			ATOM_PPLIB_PhaseSheddingLimits_Record *entry;
 
 			rdev->pm.dpm.dyn_state.phase_shedding_limits_table.entries =
-				kzalloc(psl->ucNumEntries *
+				kcalloc(psl->ucNumEntries,
 					sizeof(struct radeon_phase_shedding_limits_entry),
 					GFP_KERNEL);
 			if (!rdev->pm.dpm.dyn_state.phase_shedding_limits_table.entries) {
diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c
index 4134759a6823..f422a8d6aec4 100644
--- a/drivers/gpu/drm/radeon/radeon_atombios.c
+++ b/drivers/gpu/drm/radeon/radeon_atombios.c
@@ -2126,13 +2126,16 @@ static int radeon_atombios_parse_power_table_1_3(struct radeon_device *rdev)
 		num_modes = ATOM_MAX_NUMBEROF_POWER_BLOCK;
 	if (num_modes == 0)
 		return state_index;
-	rdev->pm.power_state = kzalloc(sizeof(struct radeon_power_state) * num_modes, GFP_KERNEL);
+	rdev->pm.power_state = kcalloc(num_modes,
+				       sizeof(struct radeon_power_state),
+				       GFP_KERNEL);
 	if (!rdev->pm.power_state)
 		return state_index;
 	/* last mode is usually default, array is low to high */
 	for (i = 0; i < num_modes; i++) {
 		rdev->pm.power_state[state_index].clock_info =
-			kzalloc(sizeof(struct radeon_pm_clock_info) * 1, GFP_KERNEL);
+			kcalloc(1, sizeof(struct radeon_pm_clock_info),
+				GFP_KERNEL);
 		if (!rdev->pm.power_state[state_index].clock_info)
 			return state_index;
 		rdev->pm.power_state[state_index].num_clock_modes = 1;
@@ -2587,8 +2590,9 @@ static int radeon_atombios_parse_power_table_4_5(struct radeon_device *rdev)
 	radeon_atombios_add_pplib_thermal_controller(rdev, &power_info->pplib.sThermalController);
 	if (power_info->pplib.ucNumStates == 0)
 		return state_index;
-	rdev->pm.power_state = kzalloc(sizeof(struct radeon_power_state) *
-				       power_info->pplib.ucNumStates, GFP_KERNEL);
+	rdev->pm.power_state = kcalloc(power_info->pplib.ucNumStates,
+				       sizeof(struct radeon_power_state),
+				       GFP_KERNEL);
 	if (!rdev->pm.power_state)
 		return state_index;
 	/* first mode is usually default, followed by low to high */
@@ -2603,10 +2607,11 @@ static int radeon_atombios_parse_power_table_4_5(struct radeon_device *rdev)
 			 le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset) +
 			 (power_state->v1.ucNonClockStateIndex *
 			  power_info->pplib.ucNonClockSize));
-		rdev->pm.power_state[i].clock_info = kzalloc(sizeof(struct radeon_pm_clock_info) *
-							     ((power_info->pplib.ucStateEntrySize - 1) ?
-							      (power_info->pplib.ucStateEntrySize - 1) : 1),
-							     GFP_KERNEL);
+		rdev->pm.power_state[i].clock_info =
+			kcalloc((power_info->pplib.ucStateEntrySize - 1) ?
+				(power_info->pplib.ucStateEntrySize - 1) : 1,
+				sizeof(struct radeon_pm_clock_info),
+				GFP_KERNEL);
 		if (!rdev->pm.power_state[i].clock_info)
 			return state_index;
 		if (power_info->pplib.ucStateEntrySize - 1) {
@@ -2688,8 +2693,9 @@ static int radeon_atombios_parse_power_table_6(struct radeon_device *rdev)
 		 le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));
 	if (state_array->ucNumEntries == 0)
 		return state_index;
-	rdev->pm.power_state = kzalloc(sizeof(struct radeon_power_state) *
-				       state_array->ucNumEntries, GFP_KERNEL);
+	rdev->pm.power_state = kcalloc(state_array->ucNumEntries,
+				       sizeof(struct radeon_power_state),
+				       GFP_KERNEL);
 	if (!rdev->pm.power_state)
 		return state_index;
 	power_state_offset = (u8 *)state_array->states;
@@ -2699,10 +2705,11 @@ static int radeon_atombios_parse_power_table_6(struct radeon_device *rdev)
 		non_clock_array_index = power_state->v2.nonClockInfoIndex;
 		non_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)
 			&non_clock_info_array->nonClockInfo[non_clock_array_index];
-		rdev->pm.power_state[i].clock_info = kzalloc(sizeof(struct radeon_pm_clock_info) *
-							     (power_state->v2.ucNumDPMLevels ?
-							      power_state->v2.ucNumDPMLevels : 1),
-							     GFP_KERNEL);
+		rdev->pm.power_state[i].clock_info =
+			kcalloc(power_state->v2.ucNumDPMLevels ?
+				power_state->v2.ucNumDPMLevels : 1,
+				sizeof(struct radeon_pm_clock_info),
+				GFP_KERNEL);
 		if (!rdev->pm.power_state[i].clock_info)
 			return state_index;
 		if (power_state->v2.ucNumDPMLevels) {
@@ -2782,7 +2789,9 @@ void radeon_atombios_get_power_modes(struct radeon_device *rdev)
 		rdev->pm.power_state = kzalloc(sizeof(struct radeon_power_state), GFP_KERNEL);
 		if (rdev->pm.power_state) {
 			rdev->pm.power_state[0].clock_info =
-				kzalloc(sizeof(struct radeon_pm_clock_info) * 1, GFP_KERNEL);
+				kcalloc(1,
+				        sizeof(struct radeon_pm_clock_info),
+				        GFP_KERNEL);
 			if (rdev->pm.power_state[0].clock_info) {
 				/* add the default mode */
 				rdev->pm.power_state[state_index].type =
diff --git a/drivers/gpu/drm/radeon/radeon_combios.c b/drivers/gpu/drm/radeon/radeon_combios.c
index 3178ba0c537c..60a61d33f607 100644
--- a/drivers/gpu/drm/radeon/radeon_combios.c
+++ b/drivers/gpu/drm/radeon/radeon_combios.c
@@ -2642,13 +2642,16 @@ void radeon_combios_get_power_modes(struct radeon_device *rdev)
 	rdev->pm.default_power_state_index = -1;
 
 	/* allocate 2 power states */
-	rdev->pm.power_state = kzalloc(sizeof(struct radeon_power_state) * 2, GFP_KERNEL);
+	rdev->pm.power_state = kcalloc(2, sizeof(struct radeon_power_state),
+				       GFP_KERNEL);
 	if (rdev->pm.power_state) {
 		/* allocate 1 clock mode per state */
 		rdev->pm.power_state[0].clock_info =
-			kzalloc(sizeof(struct radeon_pm_clock_info) * 1, GFP_KERNEL);
+			kcalloc(1, sizeof(struct radeon_pm_clock_info),
+				GFP_KERNEL);
 		rdev->pm.power_state[1].clock_info =
-			kzalloc(sizeof(struct radeon_pm_clock_info) * 1, GFP_KERNEL);
+			kcalloc(1, sizeof(struct radeon_pm_clock_info),
+				GFP_KERNEL);
 		if (!rdev->pm.power_state[0].clock_info ||
 		    !rdev->pm.power_state[1].clock_info)
 			goto pm_failed;
diff --git a/drivers/gpu/drm/radeon/radeon_test.c b/drivers/gpu/drm/radeon/radeon_test.c
index f5e9abfadb56..48f4b273e316 100644
--- a/drivers/gpu/drm/radeon/radeon_test.c
+++ b/drivers/gpu/drm/radeon/radeon_test.c
@@ -59,7 +59,7 @@ static void radeon_do_test_moves(struct radeon_device *rdev, int flag)
 	n = rdev->mc.gtt_size - rdev->gart_pin_size;
 	n /= size;
 
-	gtt_obj = kzalloc(n * sizeof(*gtt_obj), GFP_KERNEL);
+	gtt_obj = kcalloc(n, sizeof(*gtt_obj), GFP_KERNEL);
 	if (!gtt_obj) {
 		DRM_ERROR("Failed to allocate %d pointers\n", n);
 		r = 1;
diff --git a/drivers/gpu/drm/radeon/rs780_dpm.c b/drivers/gpu/drm/radeon/rs780_dpm.c
index b5e4e09a8996..694b7b3e9799 100644
--- a/drivers/gpu/drm/radeon/rs780_dpm.c
+++ b/drivers/gpu/drm/radeon/rs780_dpm.c
@@ -804,8 +804,9 @@ static int rs780_parse_power_table(struct radeon_device *rdev)
 		return -EINVAL;
 	power_info = (union power_info *)(mode_info->atom_context->bios + data_offset);
 
-	rdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *
-				  power_info->pplib.ucNumStates, GFP_KERNEL);
+	rdev->pm.dpm.ps = kcalloc(power_info->pplib.ucNumStates,
+				  sizeof(struct radeon_ps),
+				  GFP_KERNEL);
 	if (!rdev->pm.dpm.ps)
 		return -ENOMEM;
 
diff --git a/drivers/gpu/drm/radeon/rv6xx_dpm.c b/drivers/gpu/drm/radeon/rv6xx_dpm.c
index d91aa3944593..6986051fbb89 100644
--- a/drivers/gpu/drm/radeon/rv6xx_dpm.c
+++ b/drivers/gpu/drm/radeon/rv6xx_dpm.c
@@ -1888,8 +1888,9 @@ static int rv6xx_parse_power_table(struct radeon_device *rdev)
 		return -EINVAL;
 	power_info = (union power_info *)(mode_info->atom_context->bios + data_offset);
 
-	rdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *
-				  power_info->pplib.ucNumStates, GFP_KERNEL);
+	rdev->pm.dpm.ps = kcalloc(power_info->pplib.ucNumStates,
+				  sizeof(struct radeon_ps),
+				  GFP_KERNEL);
 	if (!rdev->pm.dpm.ps)
 		return -ENOMEM;
 
diff --git a/drivers/gpu/drm/radeon/rv770_dpm.c b/drivers/gpu/drm/radeon/rv770_dpm.c
index cb2a7ec4e217..c765ae7ea806 100644
--- a/drivers/gpu/drm/radeon/rv770_dpm.c
+++ b/drivers/gpu/drm/radeon/rv770_dpm.c
@@ -2282,8 +2282,9 @@ int rv7xx_parse_power_table(struct radeon_device *rdev)
 		return -EINVAL;
 	power_info = (union power_info *)(mode_info->atom_context->bios + data_offset);
 
-	rdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *
-				  power_info->pplib.ucNumStates, GFP_KERNEL);
+	rdev->pm.dpm.ps = kcalloc(power_info->pplib.ucNumStates,
+				  sizeof(struct radeon_ps),
+				  GFP_KERNEL);
 	if (!rdev->pm.dpm.ps)
 		return -ENOMEM;
 
diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c
index 90d5b41007bf..fea88078cf8e 100644
--- a/drivers/gpu/drm/radeon/si_dpm.c
+++ b/drivers/gpu/drm/radeon/si_dpm.c
@@ -6832,8 +6832,9 @@ static int si_parse_power_table(struct radeon_device *rdev)
 		(mode_info->atom_context->bios + data_offset +
 		 le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));
 
-	rdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *
-				  state_array->ucNumEntries, GFP_KERNEL);
+	rdev->pm.dpm.ps = kcalloc(state_array->ucNumEntries,
+				  sizeof(struct radeon_ps),
+				  GFP_KERNEL);
 	if (!rdev->pm.dpm.ps)
 		return -ENOMEM;
 	power_state_offset = (u8 *)state_array->states;
@@ -6941,7 +6942,9 @@ int si_dpm_init(struct radeon_device *rdev)
 		return ret;
 
 	rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =
-		kzalloc(4 * sizeof(struct radeon_clock_voltage_dependency_entry), GFP_KERNEL);
+		kcalloc(4,
+			sizeof(struct radeon_clock_voltage_dependency_entry),
+			GFP_KERNEL);
 	if (!rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) {
 		r600_free_extended_power_table(rdev);
 		return -ENOMEM;
diff --git a/drivers/gpu/drm/radeon/sumo_dpm.c b/drivers/gpu/drm/radeon/sumo_dpm.c
index fd4804829e46..1e4975f3374c 100644
--- a/drivers/gpu/drm/radeon/sumo_dpm.c
+++ b/drivers/gpu/drm/radeon/sumo_dpm.c
@@ -1482,8 +1482,9 @@ static int sumo_parse_power_table(struct radeon_device *rdev)
 		(mode_info->atom_context->bios + data_offset +
 		 le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));
 
-	rdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *
-				  state_array->ucNumEntries, GFP_KERNEL);
+	rdev->pm.dpm.ps = kcalloc(state_array->ucNumEntries,
+				  sizeof(struct radeon_ps),
+				  GFP_KERNEL);
 	if (!rdev->pm.dpm.ps)
 		return -ENOMEM;
 	power_state_offset = (u8 *)state_array->states;
diff --git a/drivers/gpu/drm/radeon/trinity_dpm.c b/drivers/gpu/drm/radeon/trinity_dpm.c
index 2ef7c4e5e495..5d317f763eea 100644
--- a/drivers/gpu/drm/radeon/trinity_dpm.c
+++ b/drivers/gpu/drm/radeon/trinity_dpm.c
@@ -1757,8 +1757,9 @@ static int trinity_parse_power_table(struct radeon_device *rdev)
 		(mode_info->atom_context->bios + data_offset +
 		 le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));
 
-	rdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *
-				  state_array->ucNumEntries, GFP_KERNEL);
+	rdev->pm.dpm.ps = kcalloc(state_array->ucNumEntries,
+				  sizeof(struct radeon_ps),
+				  GFP_KERNEL);
 	if (!rdev->pm.dpm.ps)
 		return -ENOMEM;
 	power_state_offset = (u8 *)state_array->states;
diff --git a/drivers/gpu/drm/selftests/test-drm_mm.c b/drivers/gpu/drm/selftests/test-drm_mm.c
index 7cc935d7b7aa..ab6c6c9c5b5c 100644
--- a/drivers/gpu/drm/selftests/test-drm_mm.c
+++ b/drivers/gpu/drm/selftests/test-drm_mm.c
@@ -1631,7 +1631,7 @@ static int igt_topdown(void *ignored)
 	if (!nodes)
 		goto err;
 
-	bitmap = kzalloc(count / BITS_PER_LONG * sizeof(unsigned long),
+	bitmap = kcalloc(count / BITS_PER_LONG, sizeof(unsigned long),
 			 GFP_KERNEL);
 	if (!bitmap)
 		goto err_nodes;
@@ -1745,7 +1745,7 @@ static int igt_bottomup(void *ignored)
 	if (!nodes)
 		goto err;
 
-	bitmap = kzalloc(count / BITS_PER_LONG * sizeof(unsigned long),
+	bitmap = kcalloc(count / BITS_PER_LONG, sizeof(unsigned long),
 			 GFP_KERNEL);
 	if (!bitmap)
 		goto err_nodes;
diff --git a/drivers/hid/hid-debug.c b/drivers/hid/hid-debug.c
index bf0370e1129d..53223613630e 100644
--- a/drivers/hid/hid-debug.c
+++ b/drivers/hid/hid-debug.c
@@ -376,7 +376,7 @@ static char *resolv_usage_page(unsigned page, struct seq_file *f) {
 	char *buf = NULL;
 
 	if (!f) {
-		buf = kzalloc(sizeof(char) * HID_DEBUG_BUFSIZE, GFP_ATOMIC);
+		buf = kzalloc(HID_DEBUG_BUFSIZE, GFP_ATOMIC);
 		if (!buf)
 			return ERR_PTR(-ENOMEM);
 	}
@@ -988,7 +988,7 @@ static int hid_debug_events_open(struct inode *inode, struct file *file)
 		goto out;
 	}
 
-	if (!(list->hid_debug_buf = kzalloc(sizeof(char) * HID_DEBUG_BUFSIZE, GFP_KERNEL))) {
+	if (!(list->hid_debug_buf = kzalloc(HID_DEBUG_BUFSIZE, GFP_KERNEL))) {
 		err = -ENOMEM;
 		kfree(list);
 		goto out;
diff --git a/drivers/hv/hv.c b/drivers/hv/hv.c
index 48c7cee5b844..86a7e837681e 100644
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@ -152,7 +152,7 @@ int hv_synic_alloc(void)
 {
 	int cpu;
 
-	hv_context.hv_numa_map = kzalloc(sizeof(struct cpumask) * nr_node_ids,
+	hv_context.hv_numa_map = kcalloc(nr_node_ids, sizeof(struct cpumask),
 					 GFP_KERNEL);
 	if (hv_context.hv_numa_map == NULL) {
 		pr_err("Unable to allocate NUMA map\n");
diff --git a/drivers/hv/ring_buffer.c b/drivers/hv/ring_buffer.c
index 5540d1bf57f2..62ded162001d 100644
--- a/drivers/hv/ring_buffer.c
+++ b/drivers/hv/ring_buffer.c
@@ -202,7 +202,7 @@ int hv_ringbuffer_init(struct hv_ring_buffer_info *ring_info,
 	 * First page holds struct hv_ring_buffer, do wraparound mapping for
 	 * the rest.
 	 */
-	pages_wraparound = kzalloc(sizeof(struct page *) * (page_cnt * 2 - 1),
+	pages_wraparound = kcalloc(page_cnt * 2 - 1, sizeof(struct page *),
 				   GFP_KERNEL);
 	if (!pages_wraparound)
 		return -ENOMEM;
diff --git a/drivers/hwmon/acpi_power_meter.c b/drivers/hwmon/acpi_power_meter.c
index 6351aba8819c..5223509822e7 100644
--- a/drivers/hwmon/acpi_power_meter.c
+++ b/drivers/hwmon/acpi_power_meter.c
@@ -572,8 +572,9 @@ static int read_domain_devices(struct acpi_power_meter_resource *resource)
 	if (!pss->package.count)
 		goto end;
 
-	resource->domain_devices = kzalloc(sizeof(struct acpi_device *) *
-					   pss->package.count, GFP_KERNEL);
+	resource->domain_devices = kcalloc(pss->package.count,
+					   sizeof(struct acpi_device *),
+					   GFP_KERNEL);
 	if (!resource->domain_devices) {
 		res = -ENOMEM;
 		goto end;
@@ -794,7 +795,7 @@ static int read_capabilities(struct acpi_power_meter_resource *resource)
 			goto error;
 		}
 
-		*str = kzalloc(sizeof(u8) * (element->string.length + 1),
+		*str = kcalloc(element->string.length + 1, sizeof(u8),
 			       GFP_KERNEL);
 		if (!*str) {
 			res = -ENOMEM;
* Unmerged path drivers/hwmon/coretemp.c
diff --git a/drivers/hwmon/i5k_amb.c b/drivers/hwmon/i5k_amb.c
index b87c2ccee06b..fa2d82f28b7f 100644
--- a/drivers/hwmon/i5k_amb.c
+++ b/drivers/hwmon/i5k_amb.c
@@ -274,8 +274,9 @@ static int i5k_amb_hwmon_init(struct platform_device *pdev)
 		num_ambs += hweight16(data->amb_present[i] & 0x7fff);
 
 	/* Set up sysfs stuff */
-	data->attrs = kzalloc(sizeof(*data->attrs) * num_ambs * KNOBS_PER_AMB,
-				GFP_KERNEL);
+	data->attrs = kzalloc(array3_size(num_ambs, KNOBS_PER_AMB,
+					  sizeof(*data->attrs)),
+			      GFP_KERNEL);
 	if (!data->attrs)
 		return -ENOMEM;
 	data->num_attrs = 0;
diff --git a/drivers/hwmon/ibmpex.c b/drivers/hwmon/ibmpex.c
index 74b365ea01c7..a3941e37ca18 100644
--- a/drivers/hwmon/ibmpex.c
+++ b/drivers/hwmon/ibmpex.c
@@ -390,7 +390,7 @@ static int ibmpex_find_sensors(struct ibmpex_bmc_data *data)
 		return -ENOENT;
 	data->num_sensors = err;
 
-	data->sensors = kzalloc(data->num_sensors * sizeof(*data->sensors),
+	data->sensors = kcalloc(data->num_sensors, sizeof(*data->sensors),
 				GFP_KERNEL);
 	if (!data->sensors)
 		return -ENOMEM;
diff --git a/drivers/i2c/busses/i2c-amd756-s4882.c b/drivers/i2c/busses/i2c-amd756-s4882.c
index 072c4d41787e..b8b9238690a9 100644
--- a/drivers/i2c/busses/i2c-amd756-s4882.c
+++ b/drivers/i2c/busses/i2c-amd756-s4882.c
@@ -169,12 +169,12 @@ static int __init amd756_s4882_init(void)
 
 	printk(KERN_INFO "Enabling SMBus multiplexing for Tyan S4882\n");
 	/* Define the 5 virtual adapters and algorithms structures */
-	if (!(s4882_adapter = kzalloc(5 * sizeof(struct i2c_adapter),
+	if (!(s4882_adapter = kcalloc(5, sizeof(struct i2c_adapter),
 				      GFP_KERNEL))) {
 		error = -ENOMEM;
 		goto ERROR1;
 	}
-	if (!(s4882_algo = kzalloc(5 * sizeof(struct i2c_algorithm),
+	if (!(s4882_algo = kcalloc(5, sizeof(struct i2c_algorithm),
 				   GFP_KERNEL))) {
 		error = -ENOMEM;
 		goto ERROR2;
diff --git a/drivers/i2c/busses/i2c-nforce2-s4985.c b/drivers/i2c/busses/i2c-nforce2-s4985.c
index b4e3efc1a3dd..116703038f84 100644
--- a/drivers/i2c/busses/i2c-nforce2-s4985.c
+++ b/drivers/i2c/busses/i2c-nforce2-s4985.c
@@ -164,12 +164,12 @@ static int __init nforce2_s4985_init(void)
 
 	printk(KERN_INFO "Enabling SMBus multiplexing for Tyan S4985\n");
 	/* Define the 5 virtual adapters and algorithms structures */
-	s4985_adapter = kzalloc(5 * sizeof(struct i2c_adapter), GFP_KERNEL);
+	s4985_adapter = kcalloc(5, sizeof(struct i2c_adapter), GFP_KERNEL);
 	if (!s4985_adapter) {
 		error = -ENOMEM;
 		goto ERROR1;
 	}
-	s4985_algo = kzalloc(5 * sizeof(struct i2c_algorithm), GFP_KERNEL);
+	s4985_algo = kcalloc(5, sizeof(struct i2c_algorithm), GFP_KERNEL);
 	if (!s4985_algo) {
 		error = -ENOMEM;
 		goto ERROR2;
diff --git a/drivers/i2c/busses/i2c-nforce2.c b/drivers/i2c/busses/i2c-nforce2.c
index c8670c20dfff..04788b540757 100644
--- a/drivers/i2c/busses/i2c-nforce2.c
+++ b/drivers/i2c/busses/i2c-nforce2.c
@@ -383,7 +383,7 @@ static int nforce2_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	int res1, res2;
 
 	/* we support 2 SMBus adapters */
-	smbuses = kzalloc(2 * sizeof(struct nforce2_smbus), GFP_KERNEL);
+	smbuses = kcalloc(2, sizeof(struct nforce2_smbus), GFP_KERNEL);
 	if (!smbuses)
 		return -ENOMEM;
 	pci_set_drvdata(dev, smbuses);
* Unmerged path drivers/i2c/i2c-stub.c
diff --git a/drivers/ide/hpt366.c b/drivers/ide/hpt366.c
index 696b6c1ec940..96ed9820d3d4 100644
--- a/drivers/ide/hpt366.c
+++ b/drivers/ide/hpt366.c
@@ -1460,7 +1460,7 @@ static int hpt366_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 	if (info == &hpt36x || info == &hpt374)
 		dev2 = pci_get_slot(dev->bus, dev->devfn + 1);
 
-	dyn_info = kzalloc(sizeof(*dyn_info) * (dev2 ? 2 : 1), GFP_KERNEL);
+	dyn_info = kcalloc(dev2 ? 2 : 1, sizeof(*dyn_info), GFP_KERNEL);
 	if (dyn_info == NULL) {
 		printk(KERN_ERR "%s %s: out of memory!\n",
 			d.name, pci_name(dev));
diff --git a/drivers/ide/it821x.c b/drivers/ide/it821x.c
index f01ba4606be0..25d23bb7d37c 100644
--- a/drivers/ide/it821x.c
+++ b/drivers/ide/it821x.c
@@ -652,7 +652,7 @@ static int it821x_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 	struct it821x_dev *itdevs;
 	int rc;
 
-	itdevs = kzalloc(2 * sizeof(*itdevs), GFP_KERNEL);
+	itdevs = kcalloc(2, sizeof(*itdevs), GFP_KERNEL);
 	if (itdevs == NULL) {
 		printk(KERN_ERR DRV_NAME " %s: out of memory\n", pci_name(dev));
 		return -ENOMEM;
diff --git a/drivers/iio/imu/adis_buffer.c b/drivers/iio/imu/adis_buffer.c
index 99d8e0b0dd34..93bf397261e0 100644
--- a/drivers/iio/imu/adis_buffer.c
+++ b/drivers/iio/imu/adis_buffer.c
@@ -38,7 +38,7 @@ int adis_update_scan_mode(struct iio_dev *indio_dev,
 	if (!adis->xfer)
 		return -ENOMEM;
 
-	adis->buffer = kzalloc(indio_dev->scan_bytes * 2, GFP_KERNEL);
+	adis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL);
 	if (!adis->buffer)
 		return -ENOMEM;
 
diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 1c35abd6d409..e64731700e55 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -436,7 +436,7 @@ struct iio_channel *iio_channel_get_all(struct device *dev)
 	}
 
 	/* NULL terminated array to save passing size */
-	chans = kzalloc(sizeof(*chans)*(nummaps + 1), GFP_KERNEL);
+	chans = kcalloc(nummaps + 1, sizeof(*chans), GFP_KERNEL);
 	if (chans == NULL) {
 		ret = -ENOMEM;
 		goto error_ret;
diff --git a/drivers/infiniband/core/cache.c b/drivers/infiniband/core/cache.c
index 36d3478f5cc1..f19e17011404 100644
--- a/drivers/infiniband/core/cache.c
+++ b/drivers/infiniband/core/cache.c
@@ -1247,8 +1247,9 @@ int ib_cache_setup_one(struct ib_device *device)
 	rwlock_init(&device->cache.lock);
 
 	device->cache.ports =
-		kzalloc(sizeof(*device->cache.ports) *
-			(rdma_end_port(device) - rdma_start_port(device) + 1), GFP_KERNEL);
+		kcalloc(rdma_end_port(device) - rdma_start_port(device) + 1,
+			sizeof(*device->cache.ports),
+			GFP_KERNEL);
 	if (!device->cache.ports)
 		return -ENOMEM;
 
diff --git a/drivers/infiniband/core/device.c b/drivers/infiniband/core/device.c
index 0df20870c5f9..ace3c03f2a16 100644
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@ -336,8 +336,8 @@ static int read_port_immutable(struct ib_device *device)
 	 * Therefore port_immutable is declared as a 1 based array with
 	 * potential empty slots at the beginning.
 	 */
-	device->port_immutable = kzalloc(sizeof(*device->port_immutable)
-					 * (end_port + 1),
+	device->port_immutable = kcalloc(end_port + 1,
+					 sizeof(*device->port_immutable),
 					 GFP_KERNEL);
 	if (!device->port_immutable)
 		return -ENOMEM;
diff --git a/drivers/infiniband/core/iwpm_util.c b/drivers/infiniband/core/iwpm_util.c
index 3b67a55d586e..63ca8344d571 100644
--- a/drivers/infiniband/core/iwpm_util.c
+++ b/drivers/infiniband/core/iwpm_util.c
@@ -56,14 +56,16 @@ int iwpm_init(u8 nl_client)
 	int ret = 0;
 	mutex_lock(&iwpm_admin_lock);
 	if (atomic_read(&iwpm_admin.refcount) == 0) {
-		iwpm_hash_bucket = kzalloc(IWPM_MAPINFO_HASH_SIZE *
-					sizeof(struct hlist_head), GFP_KERNEL);
+		iwpm_hash_bucket = kcalloc(IWPM_MAPINFO_HASH_SIZE,
+					   sizeof(struct hlist_head),
+					   GFP_KERNEL);
 		if (!iwpm_hash_bucket) {
 			ret = -ENOMEM;
 			goto init_exit;
 		}
-		iwpm_reminfo_bucket = kzalloc(IWPM_REMINFO_HASH_SIZE *
-					sizeof(struct hlist_head), GFP_KERNEL);
+		iwpm_reminfo_bucket = kcalloc(IWPM_REMINFO_HASH_SIZE,
+					      sizeof(struct hlist_head),
+					      GFP_KERNEL);
 		if (!iwpm_reminfo_bucket) {
 			kfree(iwpm_hash_bucket);
 			ret = -ENOMEM;
diff --git a/drivers/infiniband/hw/cxgb3/cxio_hal.c b/drivers/infiniband/hw/cxgb3/cxio_hal.c
index b4e840bf7d03..4b0f05b65a9e 100644
--- a/drivers/infiniband/hw/cxgb3/cxio_hal.c
+++ b/drivers/infiniband/hw/cxgb3/cxio_hal.c
@@ -280,7 +280,7 @@ int cxio_create_qp(struct cxio_rdev *rdev_p, u32 kernel_domain,
 	if (!wq->qpid)
 		return -ENOMEM;
 
-	wq->rq = kzalloc(depth * sizeof(struct t3_swrq), GFP_KERNEL);
+	wq->rq = kcalloc(depth, sizeof(struct t3_swrq), GFP_KERNEL);
 	if (!wq->rq)
 		goto err1;
 
@@ -288,7 +288,7 @@ int cxio_create_qp(struct cxio_rdev *rdev_p, u32 kernel_domain,
 	if (!wq->rq_addr)
 		goto err2;
 
-	wq->sq = kzalloc(depth * sizeof(struct t3_swsq), GFP_KERNEL);
+	wq->sq = kcalloc(depth, sizeof(struct t3_swsq), GFP_KERNEL);
 	if (!wq->sq)
 		goto err3;
 
diff --git a/drivers/infiniband/hw/cxgb4/device.c b/drivers/infiniband/hw/cxgb4/device.c
index aca5bf2747f9..15fbe59fe04e 100644
--- a/drivers/infiniband/hw/cxgb4/device.c
+++ b/drivers/infiniband/hw/cxgb4/device.c
@@ -871,8 +871,9 @@ static int c4iw_rdev_open(struct c4iw_rdev *rdev)
 	rdev->status_page->cq_start = rdev->lldi.vr->cq.start;
 	rdev->status_page->cq_size = rdev->lldi.vr->cq.size;
 	if (c4iw_wr_log) {
-		rdev->wr_log = kzalloc((1 << c4iw_wr_log_size_order) *
-				       sizeof(*rdev->wr_log), GFP_KERNEL);
+		rdev->wr_log = kcalloc(1 << c4iw_wr_log_size_order,
+				       sizeof(*rdev->wr_log),
+				       GFP_KERNEL);
 		if (rdev->wr_log) {
 			rdev->wr_log_size = 1 << c4iw_wr_log_size_order;
 			atomic_set(&rdev->wr_log_idx, 0);
@@ -1456,7 +1457,7 @@ static void recover_queues(struct uld_ctx *ctx)
 	ctx->dev->db_state = RECOVERY;
 	idr_for_each(&ctx->dev->qpidr, count_qps, &count);
 
-	qp_list.qps = kzalloc(count * sizeof *qp_list.qps, GFP_ATOMIC);
+	qp_list.qps = kcalloc(count, sizeof(*qp_list.qps), GFP_ATOMIC);
 	if (!qp_list.qps) {
 		spin_unlock_irq(&ctx->dev->lock);
 		return;
diff --git a/drivers/infiniband/hw/cxgb4/qp.c b/drivers/infiniband/hw/cxgb4/qp.c
index 4106eed1b8fb..aef53305f1c3 100644
--- a/drivers/infiniband/hw/cxgb4/qp.c
+++ b/drivers/infiniband/hw/cxgb4/qp.c
@@ -216,15 +216,15 @@ static int create_qp(struct c4iw_rdev *rdev, struct t4_wq *wq,
 	}
 
 	if (!user) {
-		wq->sq.sw_sq = kzalloc(wq->sq.size * sizeof *wq->sq.sw_sq,
-				 GFP_KERNEL);
+		wq->sq.sw_sq = kcalloc(wq->sq.size, sizeof(*wq->sq.sw_sq),
+				       GFP_KERNEL);
 		if (!wq->sq.sw_sq) {
 			ret = -ENOMEM;
 			goto free_rq_qid;
 		}
 
-		wq->rq.sw_rq = kzalloc(wq->rq.size * sizeof *wq->rq.sw_rq,
-				 GFP_KERNEL);
+		wq->rq.sw_rq = kcalloc(wq->rq.size, sizeof(*wq->rq.sw_rq),
+				       GFP_KERNEL);
 		if (!wq->rq.sw_rq) {
 			ret = -ENOMEM;
 			goto free_sw_sq;
* Unmerged path drivers/infiniband/hw/hns/hns_roce_hw_v2.c
diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c
index 41ce0a2e3faa..483ae4bac996 100644
--- a/drivers/infiniband/hw/mlx4/mad.c
+++ b/drivers/infiniband/hw/mlx4/mad.c
@@ -1615,7 +1615,8 @@ static int mlx4_ib_alloc_pv_bufs(struct mlx4_ib_demux_pv_ctx *ctx,
 
 	tun_qp = &ctx->qp[qp_type];
 
-	tun_qp->ring = kzalloc(sizeof (struct mlx4_ib_buf) * MLX4_NUM_TUNNEL_BUFS,
+	tun_qp->ring = kcalloc(MLX4_NUM_TUNNEL_BUFS,
+			       sizeof(struct mlx4_ib_buf),
 			       GFP_KERNEL);
 	if (!tun_qp->ring)
 		return -ENOMEM;
diff --git a/drivers/infiniband/hw/mthca/mthca_mr.c b/drivers/infiniband/hw/mthca/mthca_mr.c
index ed9a989e501b..79438346d975 100644
--- a/drivers/infiniband/hw/mthca/mthca_mr.c
+++ b/drivers/infiniband/hw/mthca/mthca_mr.c
@@ -144,7 +144,7 @@ static int mthca_buddy_init(struct mthca_buddy *buddy, int max_order)
 	buddy->max_order = max_order;
 	spin_lock_init(&buddy->lock);
 
-	buddy->bits = kzalloc((buddy->max_order + 1) * sizeof (long *),
+	buddy->bits = kcalloc(buddy->max_order + 1, sizeof(long *),
 			      GFP_KERNEL);
 	buddy->num_free = kcalloc((buddy->max_order + 1), sizeof *buddy->num_free,
 				  GFP_KERNEL);
diff --git a/drivers/infiniband/hw/mthca/mthca_profile.c b/drivers/infiniband/hw/mthca/mthca_profile.c
index 27337e120714..e7232dda0d5b 100644
--- a/drivers/infiniband/hw/mthca/mthca_profile.c
+++ b/drivers/infiniband/hw/mthca/mthca_profile.c
@@ -79,7 +79,7 @@ s64 mthca_make_profile(struct mthca_dev *dev,
 	struct mthca_resource *profile;
 	int i, j;
 
-	profile = kzalloc(MTHCA_RES_NUM * sizeof *profile, GFP_KERNEL);
+	profile = kcalloc(MTHCA_RES_NUM, sizeof(*profile), GFP_KERNEL);
 	if (!profile)
 		return -ENOMEM;
 
diff --git a/drivers/infiniband/hw/nes/nes_mgt.c b/drivers/infiniband/hw/nes/nes_mgt.c
index cd999d28ad39..ef04ef4491a2 100644
--- a/drivers/infiniband/hw/nes/nes_mgt.c
+++ b/drivers/infiniband/hw/nes/nes_mgt.c
@@ -879,7 +879,8 @@ int nes_init_mgt_qp(struct nes_device *nesdev, struct net_device *netdev, struct
 	int ret;
 
 	/* Allocate space the all mgt QPs once */
-	mgtvnic = kzalloc(NES_MGT_QP_COUNT * sizeof(struct nes_vnic_mgt), GFP_KERNEL);
+	mgtvnic = kcalloc(NES_MGT_QP_COUNT, sizeof(struct nes_vnic_mgt),
+			  GFP_KERNEL);
 	if (!mgtvnic)
 		return -ENOMEM;
 
diff --git a/drivers/infiniband/hw/nes/nes_verbs.c b/drivers/infiniband/hw/nes/nes_verbs.c
index 989ad9f44435..c436bb1859f3 100644
--- a/drivers/infiniband/hw/nes/nes_verbs.c
+++ b/drivers/infiniband/hw/nes/nes_verbs.c
@@ -2254,8 +2254,9 @@ static struct ib_mr *nes_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,
 								ibmr = ERR_PTR(-ENOMEM);
 								goto reg_user_mr_err;
 							}
-							root_vpbl.leaf_vpbl = kzalloc(sizeof(*root_vpbl.leaf_vpbl)*1024,
-									GFP_KERNEL);
+							root_vpbl.leaf_vpbl = kcalloc(1024,
+										      sizeof(*root_vpbl.leaf_vpbl),
+										      GFP_KERNEL);
 							if (!root_vpbl.leaf_vpbl) {
 								ib_umem_release(region);
 								pci_free_consistent(nesdev->pcidev, 8192, root_vpbl.pbl_vbase,
diff --git a/drivers/infiniband/hw/ocrdma/ocrdma_hw.c b/drivers/infiniband/hw/ocrdma/ocrdma_hw.c
index 552d2e7b3aff..d31a64c2d511 100644
--- a/drivers/infiniband/hw/ocrdma/ocrdma_hw.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_hw.c
@@ -3097,7 +3097,7 @@ static int ocrdma_create_eqs(struct ocrdma_dev *dev)
 	if (!num_eq)
 		return -EINVAL;
 
-	dev->eq_tbl = kzalloc(sizeof(struct ocrdma_eq) * num_eq, GFP_KERNEL);
+	dev->eq_tbl = kcalloc(num_eq, sizeof(struct ocrdma_eq), GFP_KERNEL);
 	if (!dev->eq_tbl)
 		return -ENOMEM;
 
diff --git a/drivers/infiniband/hw/ocrdma/ocrdma_main.c b/drivers/infiniband/hw/ocrdma/ocrdma_main.c
index 72c190ee9ffd..7dba1ee4260e 100644
--- a/drivers/infiniband/hw/ocrdma/ocrdma_main.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_main.c
@@ -221,19 +221,20 @@ static int ocrdma_register_device(struct ocrdma_dev *dev)
 static int ocrdma_alloc_resources(struct ocrdma_dev *dev)
 {
 	mutex_init(&dev->dev_lock);
-	dev->cq_tbl = kzalloc(sizeof(struct ocrdma_cq *) *
-			      OCRDMA_MAX_CQ, GFP_KERNEL);
+	dev->cq_tbl = kcalloc(OCRDMA_MAX_CQ, sizeof(struct ocrdma_cq *),
+			      GFP_KERNEL);
 	if (!dev->cq_tbl)
 		goto alloc_err;
 
 	if (dev->attr.max_qp) {
-		dev->qp_tbl = kzalloc(sizeof(struct ocrdma_qp *) *
-				      OCRDMA_MAX_QP, GFP_KERNEL);
+		dev->qp_tbl = kcalloc(OCRDMA_MAX_QP,
+				      sizeof(struct ocrdma_qp *),
+				      GFP_KERNEL);
 		if (!dev->qp_tbl)
 			goto alloc_err;
 	}
 
-	dev->stag_arr = kzalloc(sizeof(u64) * OCRDMA_MAX_STAG, GFP_KERNEL);
+	dev->stag_arr = kcalloc(OCRDMA_MAX_STAG, sizeof(u64), GFP_KERNEL);
 	if (dev->stag_arr == NULL)
 		goto alloc_err;
 
diff --git a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
index ae3e9b166250..6eccd9c6197b 100644
--- a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c
@@ -849,8 +849,8 @@ static int ocrdma_build_pbl_tbl(struct ocrdma_dev *dev, struct ocrdma_hw_mr *mr)
 	void *va;
 	dma_addr_t pa;
 
-	mr->pbl_table = kzalloc(sizeof(struct ocrdma_pbl) *
-				mr->num_pbls, GFP_KERNEL);
+	mr->pbl_table = kcalloc(mr->num_pbls, sizeof(struct ocrdma_pbl),
+				GFP_KERNEL);
 
 	if (!mr->pbl_table)
 		return -ENOMEM;
@@ -1329,12 +1329,12 @@ static void ocrdma_set_qp_db(struct ocrdma_dev *dev, struct ocrdma_qp *qp,
 static int ocrdma_alloc_wr_id_tbl(struct ocrdma_qp *qp)
 {
 	qp->wqe_wr_id_tbl =
-	    kzalloc(sizeof(*(qp->wqe_wr_id_tbl)) * qp->sq.max_cnt,
+	    kcalloc(qp->sq.max_cnt, sizeof(*(qp->wqe_wr_id_tbl)),
 		    GFP_KERNEL);
 	if (qp->wqe_wr_id_tbl == NULL)
 		return -ENOMEM;
 	qp->rqe_wr_id_tbl =
-	    kzalloc(sizeof(u64) * qp->rq.max_cnt, GFP_KERNEL);
+	    kcalloc(qp->rq.max_cnt, sizeof(u64), GFP_KERNEL);
 	if (qp->rqe_wr_id_tbl == NULL)
 		return -ENOMEM;
 
@@ -1871,8 +1871,8 @@ struct ib_srq *ocrdma_create_srq(struct ib_pd *ibpd,
 
 	if (udata == NULL) {
 		status = -ENOMEM;
-		srq->rqe_wr_id_tbl = kzalloc(sizeof(u64) * srq->rq.max_cnt,
-			    GFP_KERNEL);
+		srq->rqe_wr_id_tbl = kcalloc(srq->rq.max_cnt, sizeof(u64),
+					     GFP_KERNEL);
 		if (srq->rqe_wr_id_tbl == NULL)
 			goto arm_err;
 
diff --git a/drivers/infiniband/hw/qedr/main.c b/drivers/infiniband/hw/qedr/main.c
index bb34adfc0b07..bec6b01c1aeb 100644
--- a/drivers/infiniband/hw/qedr/main.c
+++ b/drivers/infiniband/hw/qedr/main.c
@@ -317,8 +317,8 @@ static int qedr_alloc_resources(struct qedr_dev *dev)
 	u16 n_entries;
 	int i, rc;
 
-	dev->sgid_tbl = kzalloc(sizeof(union ib_gid) *
-				QEDR_MAX_SGID, GFP_KERNEL);
+	dev->sgid_tbl = kcalloc(QEDR_MAX_SGID, sizeof(union ib_gid),
+				GFP_KERNEL);
 	if (!dev->sgid_tbl)
 		return -ENOMEM;
 
diff --git a/drivers/infiniband/hw/qedr/verbs.c b/drivers/infiniband/hw/qedr/verbs.c
index 318a25dc7043..10a6b270a384 100644
--- a/drivers/infiniband/hw/qedr/verbs.c
+++ b/drivers/infiniband/hw/qedr/verbs.c
@@ -1620,7 +1620,7 @@ static int qedr_create_kernel_qp(struct qedr_dev *dev,
 	qp->sq.max_wr = min_t(u32, attrs->cap.max_send_wr * dev->wq_multiplier,
 			      dev->attr.max_sqe);
 
-	qp->wqe_wr_id = kzalloc(qp->sq.max_wr * sizeof(*qp->wqe_wr_id),
+	qp->wqe_wr_id = kcalloc(qp->sq.max_wr, sizeof(*qp->wqe_wr_id),
 				GFP_KERNEL);
 	if (!qp->wqe_wr_id) {
 		DP_ERR(dev, "create qp: failed SQ shadow memory allocation\n");
@@ -1638,7 +1638,7 @@ static int qedr_create_kernel_qp(struct qedr_dev *dev,
 	qp->rq.max_wr = (u16) max_t(u32, attrs->cap.max_recv_wr, 1);
 
 	/* Allocate driver internal RQ array */
-	qp->rqe_wr_id = kzalloc(qp->rq.max_wr * sizeof(*qp->rqe_wr_id),
+	qp->rqe_wr_id = kcalloc(qp->rq.max_wr, sizeof(*qp->rqe_wr_id),
 				GFP_KERNEL);
 	if (!qp->rqe_wr_id) {
 		DP_ERR(dev,
diff --git a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c
index c2f15de34292..678b030b79f0 100644
--- a/drivers/infiniband/hw/qib/qib_iba7322.c
+++ b/drivers/infiniband/hw/qib/qib_iba7322.c
@@ -7321,8 +7321,9 @@ struct qib_devdata *qib_init_iba7322_funcs(struct pci_dev *pdev,
 		actual_cnt -= dd->num_pports;
 
 	tabsize = actual_cnt;
-	dd->cspec->msix_entries = kzalloc(tabsize *
-			sizeof(struct qib_msix_entry), GFP_KERNEL);
+	dd->cspec->msix_entries = kcalloc(tabsize,
+					  sizeof(struct qib_msix_entry),
+					  GFP_KERNEL);
 	if (!dd->cspec->msix_entries)
 		tabsize = 0;
 
diff --git a/drivers/infiniband/hw/qib/qib_init.c b/drivers/infiniband/hw/qib/qib_init.c
index 039e6a31066e..5480188b2cf3 100644
--- a/drivers/infiniband/hw/qib/qib_init.c
+++ b/drivers/infiniband/hw/qib/qib_init.c
@@ -1145,8 +1145,8 @@ struct qib_devdata *qib_alloc_devdata(struct pci_dev *pdev, size_t extra)
 	if (!qib_cpulist_count) {
 		u32 count = num_online_cpus();
 
-		qib_cpulist = kzalloc(BITS_TO_LONGS(count) *
-				      sizeof(long), GFP_KERNEL);
+		qib_cpulist = kcalloc(BITS_TO_LONGS(count), sizeof(long),
+				      GFP_KERNEL);
 		if (qib_cpulist)
 			qib_cpulist_count = count;
 	}
diff --git a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
index d948da9a6228..a5655a48d365 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c
@@ -543,7 +543,7 @@ alloc_res_chunk_list(struct usnic_vnic *vnic,
 		/* Do Nothing */
 	}
 
-	res_chunk_list = kzalloc(sizeof(*res_chunk_list)*(res_lst_sz+1),
+	res_chunk_list = kcalloc(res_lst_sz + 1, sizeof(*res_chunk_list),
 					GFP_ATOMIC);
 	if (!res_chunk_list)
 		return ERR_PTR(-ENOMEM);
diff --git a/drivers/infiniband/hw/usnic/usnic_vnic.c b/drivers/infiniband/hw/usnic/usnic_vnic.c
index e7b0030254da..ebe08f348453 100644
--- a/drivers/infiniband/hw/usnic/usnic_vnic.c
+++ b/drivers/infiniband/hw/usnic/usnic_vnic.c
@@ -312,7 +312,7 @@ static int usnic_vnic_alloc_res_chunk(struct usnic_vnic *vnic,
 	}
 
 	chunk->cnt = chunk->free_cnt = cnt;
-	chunk->res = kzalloc(sizeof(*(chunk->res))*cnt, GFP_KERNEL);
+	chunk->res = kcalloc(cnt, sizeof(*(chunk->res)), GFP_KERNEL);
 	if (!chunk->res)
 		return -ENOMEM;
 
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c
index 7e4e2a9adc93..38a3096a948c 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -1527,7 +1527,7 @@ static int ipoib_neigh_hash_init(struct ipoib_dev_priv *priv)
 	if (!htbl)
 		return -ENOMEM;
 	size = roundup_pow_of_two(arp_tbl.gc_thresh3);
-	buckets = kzalloc(size * sizeof(*buckets), GFP_KERNEL);
+	buckets = kcalloc(size, sizeof(*buckets), GFP_KERNEL);
 	if (!buckets) {
 		kfree(htbl);
 		return -ENOMEM;
@@ -1700,8 +1700,9 @@ static int ipoib_dev_init_default(struct net_device *dev)
 	ipoib_napi_add(dev);
 
 	/* Allocate RX/TX "rings" to hold queued skbs */
-	priv->rx_ring =	kzalloc(ipoib_recvq_size * sizeof *priv->rx_ring,
-				GFP_KERNEL);
+	priv->rx_ring =	kcalloc(ipoib_recvq_size,
+				       sizeof(*priv->rx_ring),
+				       GFP_KERNEL);
 	if (!priv->rx_ring)
 		goto out;
 
diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c
index cfc9f4b38ed3..d2abdeba7377 100644
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@ -181,8 +181,9 @@ isert_alloc_rx_descriptors(struct isert_conn *isert_conn)
 	u64 dma_addr;
 	int i, j;
 
-	isert_conn->rx_descs = kzalloc(ISERT_QP_MAX_RECV_DTOS *
-				sizeof(struct iser_rx_desc), GFP_KERNEL);
+	isert_conn->rx_descs = kcalloc(ISERT_QP_MAX_RECV_DTOS,
+				       sizeof(struct iser_rx_desc),
+				       GFP_KERNEL);
 	if (!isert_conn->rx_descs)
 		return -ENOMEM;
 
diff --git a/drivers/input/keyboard/omap4-keypad.c b/drivers/input/keyboard/omap4-keypad.c
index 1b289092f4e3..9e7c5b16c514 100644
--- a/drivers/input/keyboard/omap4-keypad.c
+++ b/drivers/input/keyboard/omap4-keypad.c
@@ -347,7 +347,8 @@ static int omap4_keypad_probe(struct platform_device *pdev)
 
 	keypad_data->row_shift = get_count_order(keypad_data->cols);
 	max_keys = keypad_data->rows << keypad_data->row_shift;
-	keypad_data->keymap = kzalloc(max_keys * sizeof(keypad_data->keymap[0]),
+	keypad_data->keymap = kcalloc(max_keys,
+				      sizeof(keypad_data->keymap[0]),
 				      GFP_KERNEL);
 	if (!keypad_data->keymap) {
 		dev_err(&pdev->dev, "Not enough memory for keymap\n");
diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c
index 4658dc3fed52..6cf1ec9ee9a1 100644
--- a/drivers/iommu/dmar.c
+++ b/drivers/iommu/dmar.c
@@ -1446,7 +1446,7 @@ int dmar_enable_qi(struct intel_iommu *iommu)
 
 	qi->desc = page_address(desc_page);
 
-	qi->desc_status = kzalloc(QI_LENGTH * sizeof(int), GFP_ATOMIC);
+	qi->desc_status = kcalloc(QI_LENGTH, sizeof(int), GFP_ATOMIC);
 	if (!qi->desc_status) {
 		free_page((unsigned long) qi->desc);
 		kfree(qi);
diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c
index f2592de41396..80a0aa5e8e73 100644
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@ -3123,7 +3123,7 @@ static int copy_translation_tables(struct intel_iommu *iommu)
 	/* This is too big for the stack - allocate it from slab */
 	ctxt_table_entries = ext ? 512 : 256;
 	ret = -ENOMEM;
-	ctxt_tbls = kzalloc(ctxt_table_entries * sizeof(void *), GFP_KERNEL);
+	ctxt_tbls = kcalloc(ctxt_table_entries, sizeof(void *), GFP_KERNEL);
 	if (!ctxt_tbls)
 		goto out_unmap;
 
@@ -3993,7 +3993,7 @@ static int iommu_suspend(void)
 	unsigned long flag;
 
 	for_each_active_iommu(iommu, drhd) {
-		iommu->iommu_state = kzalloc(sizeof(u32) * MAX_SR_DMAR_REGS,
+		iommu->iommu_state = kcalloc(MAX_SR_DMAR_REGS, sizeof(u32),
 						 GFP_ATOMIC);
 		if (!iommu->iommu_state)
 			goto nomem;
* Unmerged path drivers/iommu/omap-iommu.c
diff --git a/drivers/ipack/carriers/tpci200.c b/drivers/ipack/carriers/tpci200.c
index de5e32151a1e..82789ea7cbe8 100644
--- a/drivers/ipack/carriers/tpci200.c
+++ b/drivers/ipack/carriers/tpci200.c
@@ -457,8 +457,8 @@ static int tpci200_install(struct tpci200_board *tpci200)
 {
 	int res;
 
-	tpci200->slots = kzalloc(
-		TPCI200_NB_SLOT * sizeof(struct tpci200_slot), GFP_KERNEL);
+	tpci200->slots = kcalloc(TPCI200_NB_SLOT, sizeof(struct tpci200_slot),
+				 GFP_KERNEL);
 	if (tpci200->slots == NULL)
 		return -ENOMEM;
 
* Unmerged path drivers/irqchip/irq-alpine-msi.c
* Unmerged path drivers/irqchip/irq-gic-v2m.c
* Unmerged path drivers/irqchip/irq-gic-v3-its.c
* Unmerged path drivers/irqchip/irq-gic-v3.c
* Unmerged path drivers/irqchip/irq-partition-percpu.c
diff --git a/drivers/irqchip/irq-s3c24xx.c b/drivers/irqchip/irq-s3c24xx.c
index bbcc944ed94f..a4d0988d408d 100644
--- a/drivers/irqchip/irq-s3c24xx.c
+++ b/drivers/irqchip/irq-s3c24xx.c
@@ -1276,7 +1276,7 @@ static int __init s3c_init_intc_of(struct device_node *np,
 			return -ENOMEM;
 
 		intc->domain = domain;
-		intc->irqs = kzalloc(sizeof(struct s3c_irq_data) * 32,
+		intc->irqs = kcalloc(32, sizeof(struct s3c_irq_data),
 				     GFP_KERNEL);
 		if (!intc->irqs) {
 			kfree(intc);
* Unmerged path drivers/isdn/capi/capi.c
diff --git a/drivers/isdn/gigaset/capi.c b/drivers/isdn/gigaset/capi.c
index 3286903a95d2..6924eec210d2 100644
--- a/drivers/isdn/gigaset/capi.c
+++ b/drivers/isdn/gigaset/capi.c
@@ -1313,7 +1313,7 @@ static void do_connect_req(struct gigaset_capi_ctr *iif,
 	cmsg->adr.adrPLCI |= (bcs->channel + 1) << 8;
 
 	/* build command table */
-	commands = kzalloc(AT_NUM * (sizeof *commands), GFP_KERNEL);
+	commands = kcalloc(AT_NUM, sizeof(*commands), GFP_KERNEL);
 	if (!commands)
 		goto oom;
 
diff --git a/drivers/isdn/gigaset/i4l.c b/drivers/isdn/gigaset/i4l.c
index 2d75329007f1..b5b389e95edd 100644
--- a/drivers/isdn/gigaset/i4l.c
+++ b/drivers/isdn/gigaset/i4l.c
@@ -243,7 +243,7 @@ static int command_from_LL(isdn_ctrl *cntrl)
 		dev_kfree_skb(bcs->rx_skb);
 		gigaset_new_rx_skb(bcs);
 
-		commands = kzalloc(AT_NUM * (sizeof *commands), GFP_ATOMIC);
+		commands = kcalloc(AT_NUM, sizeof(*commands), GFP_ATOMIC);
 		if (!commands) {
 			gigaset_free_channel(bcs);
 			dev_err(cs->dev, "ISDN_CMD_DIAL: out of memory\n");
diff --git a/drivers/isdn/hardware/avm/b1.c b/drivers/isdn/hardware/avm/b1.c
index 4d9b195547c5..3a44b6c68366 100644
--- a/drivers/isdn/hardware/avm/b1.c
+++ b/drivers/isdn/hardware/avm/b1.c
@@ -72,7 +72,7 @@ avmcard *b1_alloc_card(int nr_controllers)
 	if (!card)
 		return NULL;
 
-	cinfo = kzalloc(sizeof(*cinfo) * nr_controllers, GFP_KERNEL);
+	cinfo = kcalloc(nr_controllers, sizeof(*cinfo), GFP_KERNEL);
 	if (!cinfo) {
 		kfree(card);
 		return NULL;
diff --git a/drivers/isdn/hisax/fsm.c b/drivers/isdn/hisax/fsm.c
index c7a94713e9ec..4ecf26db70a2 100644
--- a/drivers/isdn/hisax/fsm.c
+++ b/drivers/isdn/hisax/fsm.c
@@ -27,7 +27,9 @@ FsmNew(struct Fsm *fsm, struct FsmNode *fnlist, int fncount)
 	int i;
 
 	fsm->jumpmatrix =
-		kzalloc(sizeof(FSMFNPTR) * fsm->state_count * fsm->event_count, GFP_KERNEL);
+		kzalloc(array3_size(sizeof(FSMFNPTR), fsm->state_count,
+				    fsm->event_count),
+			GFP_KERNEL);
 	if (!fsm->jumpmatrix)
 		return -ENOMEM;
 
diff --git a/drivers/isdn/i4l/isdn_common.c b/drivers/isdn/i4l/isdn_common.c
index 9bb12ba3191f..fb708c673b8c 100644
--- a/drivers/isdn/i4l/isdn_common.c
+++ b/drivers/isdn/i4l/isdn_common.c
@@ -2084,14 +2084,14 @@ isdn_add_channels(isdn_driver_t *d, int drvidx, int n, int adding)
 
 	if ((adding) && (d->rcverr))
 		kfree(d->rcverr);
-	if (!(d->rcverr = kzalloc(sizeof(int) * m, GFP_ATOMIC))) {
+	if (!(d->rcverr = kcalloc(m, sizeof(int), GFP_ATOMIC))) {
 		printk(KERN_WARNING "register_isdn: Could not alloc rcverr\n");
 		return -1;
 	}
 
 	if ((adding) && (d->rcvcount))
 		kfree(d->rcvcount);
-	if (!(d->rcvcount = kzalloc(sizeof(int) * m, GFP_ATOMIC))) {
+	if (!(d->rcvcount = kcalloc(m, sizeof(int), GFP_ATOMIC))) {
 		printk(KERN_WARNING "register_isdn: Could not alloc rcvcount\n");
 		if (!adding)
 			kfree(d->rcverr);
* Unmerged path drivers/isdn/mISDN/fsm.c
* Unmerged path drivers/lightnvm/pblk-init.c
diff --git a/drivers/mailbox/pcc.c b/drivers/mailbox/pcc.c
index 67fb8e0a357e..48da7ed8f305 100644
--- a/drivers/mailbox/pcc.c
+++ b/drivers/mailbox/pcc.c
@@ -470,7 +470,8 @@ static int __init acpi_pcc_probe(void)
 		return -EINVAL;
 	}
 
-	pcc_mbox_channels = kzalloc(sizeof(struct mbox_chan) * count, GFP_KERNEL);
+	pcc_mbox_channels = kcalloc(count, sizeof(struct mbox_chan),
+				    GFP_KERNEL);
 	if (!pcc_mbox_channels) {
 		pr_err("Could not allocate space for PCC mbox channels\n");
 		return -ENOMEM;
* Unmerged path drivers/md/bcache/super.c
* Unmerged path drivers/md/dm-crypt.c
diff --git a/drivers/md/md-bitmap.c b/drivers/md/md-bitmap.c
index f0b5deb43b45..ada5c5dc03bf 100644
--- a/drivers/md/md-bitmap.c
+++ b/drivers/md/md-bitmap.c
@@ -1884,7 +1884,7 @@ int bitmap_resize(struct bitmap *bitmap, sector_t blocks,
 
 	pages = DIV_ROUND_UP(chunks, PAGE_COUNTER_RATIO);
 
-	new_bp = kzalloc(pages * sizeof(*new_bp), GFP_KERNEL);
+	new_bp = kcalloc(pages, sizeof(*new_bp), GFP_KERNEL);
 	ret = -ENOMEM;
 	if (!new_bp) {
 		bitmap_file_unmap(&store);
* Unmerged path drivers/md/md-cluster.c
diff --git a/drivers/md/md-multipath.c b/drivers/md/md-multipath.c
index c1e888deed4a..d7b876d6e1de 100644
--- a/drivers/md/md-multipath.c
+++ b/drivers/md/md-multipath.c
@@ -424,7 +424,8 @@ static int multipath_run (struct mddev *mddev)
 	if (!conf)
 		goto out;
 
-	conf->multipaths = kzalloc(sizeof(struct multipath_info)*mddev->raid_disks,
+	conf->multipaths = kcalloc(mddev->raid_disks,
+				   sizeof(struct multipath_info),
 				   GFP_KERNEL);
 	if (!conf->multipaths)
 		goto out_free_conf;
diff --git a/drivers/md/raid0.c b/drivers/md/raid0.c
index 0bfe93a75836..b9ecada67a0a 100644
--- a/drivers/md/raid0.c
+++ b/drivers/md/raid0.c
@@ -158,12 +158,14 @@ static int create_strip_zones(struct mddev *mddev, struct r0conf **private_conf)
 	}
 
 	err = -ENOMEM;
-	conf->strip_zone = kzalloc(sizeof(struct strip_zone)*
-				conf->nr_strip_zones, GFP_KERNEL);
+	conf->strip_zone = kcalloc(conf->nr_strip_zones,
+				   sizeof(struct strip_zone),
+				   GFP_KERNEL);
 	if (!conf->strip_zone)
 		goto abort;
-	conf->devlist = kzalloc(sizeof(struct md_rdev*)*
-				conf->nr_strip_zones*mddev->raid_disks,
+	conf->devlist = kzalloc(array3_size(sizeof(struct md_rdev *),
+					    conf->nr_strip_zones,
+					    mddev->raid_disks),
 				GFP_KERNEL);
 	if (!conf->devlist)
 		goto abort;
diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
index 9643c43d8d42..5a58427ecd54 100644
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@ -3017,9 +3017,9 @@ static struct r1conf *setup_conf(struct mddev *mddev)
 	if (!conf->barrier)
 		goto abort;
 
-	conf->mirrors = kzalloc(sizeof(struct raid1_info)
-				* mddev->raid_disks * 2,
-				 GFP_KERNEL);
+	conf->mirrors = kzalloc(array3_size(sizeof(struct raid1_info),
+					    mddev->raid_disks, 2),
+				GFP_KERNEL);
 	if (!conf->mirrors)
 		goto abort;
 
@@ -3315,7 +3315,8 @@ static int raid1_reshape(struct mddev *mddev)
 		kfree(newpoolinfo);
 		return -ENOMEM;
 	}
-	newmirrors = kzalloc(sizeof(struct raid1_info) * raid_disks * 2,
+	newmirrors = kzalloc(array3_size(sizeof(struct raid1_info),
+					 raid_disks, 2),
 			     GFP_KERNEL);
 	if (!newmirrors) {
 		kfree(newpoolinfo);
diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c
index 4fd433755960..755a5f28f308 100644
--- a/drivers/md/raid10.c
+++ b/drivers/md/raid10.c
@@ -3807,8 +3807,8 @@ static struct r10conf *setup_conf(struct mddev *mddev)
 		goto out;
 
 	/* FIXME calc properly */
-	conf->mirrors = kzalloc(sizeof(struct raid10_info)*(mddev->raid_disks +
-							    max(0,-mddev->delta_disks)),
+	conf->mirrors = kcalloc(mddev->raid_disks + max(0, -mddev->delta_disks),
+				sizeof(struct raid10_info),
 				GFP_KERNEL);
 	if (!conf->mirrors)
 		goto out;
@@ -4239,11 +4239,10 @@ static int raid10_check_reshape(struct mddev *mddev)
 	conf->mirrors_new = NULL;
 	if (mddev->delta_disks > 0) {
 		/* allocate new 'mirrors' list */
-		conf->mirrors_new = kzalloc(
-			sizeof(struct raid10_info)
-			*(mddev->raid_disks +
-			  mddev->delta_disks),
-			GFP_KERNEL);
+		conf->mirrors_new =
+			kcalloc(mddev->raid_disks + mddev->delta_disks,
+				sizeof(struct raid10_info),
+				GFP_KERNEL);
 		if (!conf->mirrors_new)
 			return -ENOMEM;
 	}
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index f957b7e42562..0dc607888226 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -2395,7 +2395,7 @@ static int resize_stripes(struct r5conf *conf, int newsize)
 	 * is completely stalled, so now is a good time to resize
 	 * conf->disks and the scribble region
 	 */
-	ndisks = kzalloc(newsize * sizeof(struct disk_info), GFP_NOIO);
+	ndisks = kcalloc(newsize, sizeof(struct disk_info), GFP_NOIO);
 	if (ndisks) {
 		for (i = 0; i < conf->pool_size; i++)
 			ndisks[i] = conf->disks[i];
@@ -6694,9 +6694,9 @@ static int alloc_thread_groups(struct r5conf *conf, int cnt,
 	}
 	*group_cnt = num_possible_nodes();
 	size = sizeof(struct r5worker) * cnt;
-	workers = kzalloc(size * *group_cnt, GFP_NOIO);
-	*worker_groups = kzalloc(sizeof(struct r5worker_group) *
-				*group_cnt, GFP_NOIO);
+	workers = kcalloc(size, *group_cnt, GFP_NOIO);
+	*worker_groups = kcalloc(*group_cnt, sizeof(struct r5worker_group),
+				 GFP_NOIO);
 	if (!*worker_groups || !workers) {
 		kfree(workers);
 		kfree(*worker_groups);
@@ -6968,8 +6968,9 @@ static struct r5conf *setup_conf(struct mddev *mddev)
 		goto abort;
 	INIT_LIST_HEAD(&conf->free_list);
 	INIT_LIST_HEAD(&conf->pending_list);
-	conf->pending_data = kzalloc(sizeof(struct r5pending_data) *
-		PENDING_IO_MAX, GFP_KERNEL);
+	conf->pending_data = kcalloc(PENDING_IO_MAX,
+				     sizeof(struct r5pending_data),
+				     GFP_KERNEL);
 	if (!conf->pending_data)
 		goto abort;
 	for (i = 0; i < PENDING_IO_MAX; i++)
@@ -7018,7 +7019,7 @@ static struct r5conf *setup_conf(struct mddev *mddev)
 		conf->previous_raid_disks = mddev->raid_disks - mddev->delta_disks;
 	max_disks = max(conf->raid_disks, conf->previous_raid_disks);
 
-	conf->disks = kzalloc(max_disks * sizeof(struct disk_info),
+	conf->disks = kcalloc(max_disks, sizeof(struct disk_info),
 			      GFP_KERNEL);
 
 	if (!conf->disks)
diff --git a/drivers/media/dvb-frontends/dib7000p.c b/drivers/media/dvb-frontends/dib7000p.c
index 639c8a532ef0..a5af8232b15b 100644
--- a/drivers/media/dvb-frontends/dib7000p.c
+++ b/drivers/media/dvb-frontends/dib7000p.c
@@ -1652,10 +1652,10 @@ int dib7000pc_detection(struct i2c_adapter *i2c_adap)
 	};
 	int ret = 0;
 
-	tx = kzalloc(2*sizeof(u8), GFP_KERNEL);
+	tx = kzalloc(2, GFP_KERNEL);
 	if (!tx)
 		return -ENOMEM;
-	rx = kzalloc(2*sizeof(u8), GFP_KERNEL);
+	rx = kzalloc(2, GFP_KERNEL);
 	if (!rx) {
 		ret = -ENOMEM;
 		goto rx_memory_error;
diff --git a/drivers/media/dvb-frontends/dib8000.c b/drivers/media/dvb-frontends/dib8000.c
index 4cec77457f1b..ab6c4158de64 100644
--- a/drivers/media/dvb-frontends/dib8000.c
+++ b/drivers/media/dvb-frontends/dib8000.c
@@ -3757,12 +3757,12 @@ int dib8000_i2c_enumeration(struct i2c_adapter *host, int no_of_demods,
 	u8 new_addr = 0;
 	struct i2c_device client = {.adap = host };
 
-	client.i2c_write_buffer = kzalloc(4 * sizeof(u8), GFP_KERNEL);
+	client.i2c_write_buffer = kzalloc(4, GFP_KERNEL);
 	if (!client.i2c_write_buffer) {
 		dprintk("%s: not enough memory", __func__);
 		return -ENOMEM;
 	}
-	client.i2c_read_buffer = kzalloc(4 * sizeof(u8), GFP_KERNEL);
+	client.i2c_read_buffer = kzalloc(4, GFP_KERNEL);
 	if (!client.i2c_read_buffer) {
 		dprintk("%s: not enough memory", __func__);
 		ret = -ENOMEM;
diff --git a/drivers/media/dvb-frontends/dib9000.c b/drivers/media/dvb-frontends/dib9000.c
index 6201c59a78dd..9aab27bd002f 100644
--- a/drivers/media/dvb-frontends/dib9000.c
+++ b/drivers/media/dvb-frontends/dib9000.c
@@ -2368,12 +2368,12 @@ int dib9000_i2c_enumeration(struct i2c_adapter *i2c, int no_of_demods, u8 defaul
 	u8 new_addr = 0;
 	struct i2c_device client = {.i2c_adap = i2c };
 
-	client.i2c_write_buffer = kzalloc(4 * sizeof(u8), GFP_KERNEL);
+	client.i2c_write_buffer = kzalloc(4, GFP_KERNEL);
 	if (!client.i2c_write_buffer) {
 		dprintk("%s: not enough memory", __func__);
 		return -ENOMEM;
 	}
-	client.i2c_read_buffer = kzalloc(4 * sizeof(u8), GFP_KERNEL);
+	client.i2c_read_buffer = kzalloc(4, GFP_KERNEL);
 	if (!client.i2c_read_buffer) {
 		dprintk("%s: not enough memory", __func__);
 		ret = -ENOMEM;
diff --git a/drivers/media/usb/au0828/au0828-video.c b/drivers/media/usb/au0828/au0828-video.c
index 68abd1614051..d1d571faa969 100644
--- a/drivers/media/usb/au0828/au0828-video.c
+++ b/drivers/media/usb/au0828/au0828-video.c
@@ -223,14 +223,14 @@ static int au0828_init_isoc(struct au0828_dev *dev, int max_packets,
 	dev->isoc_ctl.isoc_copy = isoc_copy;
 	dev->isoc_ctl.num_bufs = num_bufs;
 
-	dev->isoc_ctl.urb = kzalloc(sizeof(void *)*num_bufs,  GFP_KERNEL);
+	dev->isoc_ctl.urb = kcalloc(num_bufs, sizeof(void *),  GFP_KERNEL);
 	if (!dev->isoc_ctl.urb) {
 		au0828_isocdbg("cannot alloc memory for usb buffers\n");
 		return -ENOMEM;
 	}
 
-	dev->isoc_ctl.transfer_buffer = kzalloc(sizeof(void *)*num_bufs,
-					      GFP_KERNEL);
+	dev->isoc_ctl.transfer_buffer = kcalloc(num_bufs, sizeof(void *),
+						GFP_KERNEL);
 	if (!dev->isoc_ctl.transfer_buffer) {
 		au0828_isocdbg("cannot allocate memory for usb transfer\n");
 		kfree(dev->isoc_ctl.urb);
diff --git a/drivers/media/usb/cx231xx/cx231xx-core.c b/drivers/media/usb/cx231xx/cx231xx-core.c
index 4ba3ce09b713..552e14aaaace 100644
--- a/drivers/media/usb/cx231xx/cx231xx-core.c
+++ b/drivers/media/usb/cx231xx/cx231xx-core.c
@@ -1014,14 +1014,14 @@ int cx231xx_init_isoc(struct cx231xx *dev, int max_packets,
 		dma_q->partial_buf[i] = 0;
 
 	dev->video_mode.isoc_ctl.urb =
-	    kzalloc(sizeof(void *) * num_bufs, GFP_KERNEL);
+	    kcalloc(num_bufs, sizeof(void *), GFP_KERNEL);
 	if (!dev->video_mode.isoc_ctl.urb) {
 		cx231xx_errdev("cannot alloc memory for usb buffers\n");
 		return -ENOMEM;
 	}
 
 	dev->video_mode.isoc_ctl.transfer_buffer =
-	    kzalloc(sizeof(void *) * num_bufs, GFP_KERNEL);
+	    kcalloc(num_bufs, sizeof(void *), GFP_KERNEL);
 	if (!dev->video_mode.isoc_ctl.transfer_buffer) {
 		cx231xx_errdev("cannot allocate memory for usbtransfer\n");
 		kfree(dev->video_mode.isoc_ctl.urb);
@@ -1147,14 +1147,14 @@ int cx231xx_init_bulk(struct cx231xx *dev, int max_packets,
 		dma_q->partial_buf[i] = 0;
 
 	dev->video_mode.bulk_ctl.urb =
-	    kzalloc(sizeof(void *) * num_bufs, GFP_KERNEL);
+	    kcalloc(num_bufs, sizeof(void *), GFP_KERNEL);
 	if (!dev->video_mode.bulk_ctl.urb) {
 		cx231xx_errdev("cannot alloc memory for usb buffers\n");
 		return -ENOMEM;
 	}
 
 	dev->video_mode.bulk_ctl.transfer_buffer =
-	    kzalloc(sizeof(void *) * num_bufs, GFP_KERNEL);
+	    kcalloc(num_bufs, sizeof(void *), GFP_KERNEL);
 	if (!dev->video_mode.bulk_ctl.transfer_buffer) {
 		cx231xx_errdev("cannot allocate memory for usbtransfer\n");
 		kfree(dev->video_mode.bulk_ctl.urb);
diff --git a/drivers/media/usb/cx231xx/cx231xx-vbi.c b/drivers/media/usb/cx231xx/cx231xx-vbi.c
index 1340ff268817..7c6fc5a2b112 100644
--- a/drivers/media/usb/cx231xx/cx231xx-vbi.c
+++ b/drivers/media/usb/cx231xx/cx231xx-vbi.c
@@ -417,7 +417,7 @@ int cx231xx_init_vbi_isoc(struct cx231xx *dev, int max_packets,
 	for (i = 0; i < 8; i++)
 		dma_q->partial_buf[i] = 0;
 
-	dev->vbi_mode.bulk_ctl.urb = kzalloc(sizeof(void *) * num_bufs,
+	dev->vbi_mode.bulk_ctl.urb = kcalloc(num_bufs, sizeof(void *),
 					     GFP_KERNEL);
 	if (!dev->vbi_mode.bulk_ctl.urb) {
 		cx231xx_errdev("cannot alloc memory for usb buffers\n");
@@ -425,7 +425,7 @@ int cx231xx_init_vbi_isoc(struct cx231xx *dev, int max_packets,
 	}
 
 	dev->vbi_mode.bulk_ctl.transfer_buffer =
-	    kzalloc(sizeof(void *) * num_bufs, GFP_KERNEL);
+	    kcalloc(num_bufs, sizeof(void *), GFP_KERNEL);
 	if (!dev->vbi_mode.bulk_ctl.transfer_buffer) {
 		cx231xx_errdev("cannot allocate memory for usbtransfer\n");
 		kfree(dev->vbi_mode.bulk_ctl.urb);
diff --git a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c b/drivers/media/usb/pvrusb2/pvrusb2-hdw.c
index e11267f35d87..e221dfd6361d 100644
--- a/drivers/media/usb/pvrusb2/pvrusb2-hdw.c
+++ b/drivers/media/usb/pvrusb2/pvrusb2-hdw.c
@@ -2471,7 +2471,7 @@ struct pvr2_hdw *pvr2_hdw_create(struct usb_interface *intf,
 
 	hdw->control_cnt = CTRLDEF_COUNT;
 	hdw->control_cnt += MPEGDEF_COUNT;
-	hdw->controls = kzalloc(sizeof(struct pvr2_ctrl) * hdw->control_cnt,
+	hdw->controls = kcalloc(hdw->control_cnt, sizeof(struct pvr2_ctrl),
 				GFP_KERNEL);
 	if (!hdw->controls) goto fail;
 	hdw->hdw_desc = hdw_desc;
diff --git a/drivers/media/usb/pvrusb2/pvrusb2-std.c b/drivers/media/usb/pvrusb2/pvrusb2-std.c
index 453627b07833..48cfb74b797f 100644
--- a/drivers/media/usb/pvrusb2/pvrusb2-std.c
+++ b/drivers/media/usb/pvrusb2/pvrusb2-std.c
@@ -366,7 +366,7 @@ struct v4l2_standard *pvr2_std_create_enum(unsigned int *countptr,
 		   std_cnt);
 	if (!std_cnt) return NULL; // paranoia
 
-	stddefs = kzalloc(sizeof(struct v4l2_standard) * std_cnt,
+	stddefs = kcalloc(std_cnt, sizeof(struct v4l2_standard),
 			  GFP_KERNEL);
 	if (!stddefs)
 		return NULL;
diff --git a/drivers/media/usb/stk1160/stk1160-video.c b/drivers/media/usb/stk1160/stk1160-video.c
index 39f1aae209bc..e82d98a49998 100644
--- a/drivers/media/usb/stk1160/stk1160-video.c
+++ b/drivers/media/usb/stk1160/stk1160-video.c
@@ -442,14 +442,14 @@ int stk1160_alloc_isoc(struct stk1160 *dev)
 
 	dev->isoc_ctl.buf = NULL;
 	dev->isoc_ctl.max_pkt_size = dev->max_pkt_size;
-	dev->isoc_ctl.urb = kzalloc(sizeof(void *)*num_bufs, GFP_KERNEL);
+	dev->isoc_ctl.urb = kcalloc(num_bufs, sizeof(void *), GFP_KERNEL);
 	if (!dev->isoc_ctl.urb) {
 		stk1160_err("out of memory for urb array\n");
 		return -ENOMEM;
 	}
 
-	dev->isoc_ctl.transfer_buffer = kzalloc(sizeof(void *)*num_bufs,
-					      GFP_KERNEL);
+	dev->isoc_ctl.transfer_buffer = kcalloc(num_bufs, sizeof(void *),
+						GFP_KERNEL);
 	if (!dev->isoc_ctl.transfer_buffer) {
 		stk1160_err("out of memory for usb transfers\n");
 		kfree(dev->isoc_ctl.urb);
diff --git a/drivers/media/usb/stkwebcam/stk-webcam.c b/drivers/media/usb/stkwebcam/stk-webcam.c
index c43c8d32be40..b749e5fd653d 100644
--- a/drivers/media/usb/stkwebcam/stk-webcam.c
+++ b/drivers/media/usb/stkwebcam/stk-webcam.c
@@ -564,8 +564,9 @@ static int stk_prepare_sio_buffers(struct stk_camera *dev, unsigned n_sbufs)
 	if (dev->sio_bufs != NULL)
 		STK_ERROR("sio_bufs already allocated\n");
 	else {
-		dev->sio_bufs = kzalloc(n_sbufs * sizeof(struct stk_sio_buffer),
-				GFP_KERNEL);
+		dev->sio_bufs = kcalloc(n_sbufs,
+					sizeof(struct stk_sio_buffer),
+					GFP_KERNEL);
 		if (dev->sio_bufs == NULL)
 			return -ENOMEM;
 		for (i = 0; i < n_sbufs; i++) {
* Unmerged path drivers/media/usb/usbtv/usbtv-video.c
* Unmerged path drivers/mfd/cros_ec_dev.c
diff --git a/drivers/mfd/mfd-core.c b/drivers/mfd/mfd-core.c
index 8ba98a4ad857..3ac4b06e19af 100644
--- a/drivers/mfd/mfd-core.c
+++ b/drivers/mfd/mfd-core.c
@@ -131,7 +131,7 @@ static int mfd_add_device(struct device *parent, int id,
 	if (!pdev)
 		goto fail_alloc;
 
-	res = kzalloc(sizeof(*res) * cell->num_resources, GFP_KERNEL);
+	res = kcalloc(cell->num_resources, sizeof(*res), GFP_KERNEL);
 	if (!res)
 		goto fail_device;
 
diff --git a/drivers/mfd/timberdale.c b/drivers/mfd/timberdale.c
index 97f8b84ee07b..5a1f8c9abf93 100644
--- a/drivers/mfd/timberdale.c
+++ b/drivers/mfd/timberdale.c
@@ -708,8 +708,8 @@ static int timb_probe(struct pci_dev *dev,
 		goto err_config;
 	}
 
-	msix_entries = kzalloc(TIMBERDALE_NR_IRQS * sizeof(*msix_entries),
-		GFP_KERNEL);
+	msix_entries = kcalloc(TIMBERDALE_NR_IRQS, sizeof(*msix_entries),
+			       GFP_KERNEL);
 	if (!msix_entries)
 		goto err_config;
 
diff --git a/drivers/misc/altera-stapl/altera.c b/drivers/misc/altera-stapl/altera.c
index 24272e022bec..cd0476eacfcf 100644
--- a/drivers/misc/altera-stapl/altera.c
+++ b/drivers/misc/altera-stapl/altera.c
@@ -304,13 +304,13 @@ static int altera_execute(struct altera_state *astate,
 	if (sym_count <= 0)
 		goto exit_done;
 
-	vars = kzalloc(sym_count * sizeof(long), GFP_KERNEL);
+	vars = kcalloc(sym_count, sizeof(long), GFP_KERNEL);
 
 	if (vars == NULL)
 		status = -ENOMEM;
 
 	if (status == 0) {
-		var_size = kzalloc(sym_count * sizeof(s32), GFP_KERNEL);
+		var_size = kcalloc(sym_count, sizeof(s32), GFP_KERNEL);
 
 		if (var_size == NULL)
 			status = -ENOMEM;
@@ -1136,7 +1136,7 @@ exit_done:
 				/* Allocate a writable buffer for this array */
 				count = var_size[variable_id];
 				long_tmp = vars[variable_id];
-				longptr_tmp = kzalloc(count * sizeof(long),
+				longptr_tmp = kcalloc(count, sizeof(long),
 								GFP_KERNEL);
 				vars[variable_id] = (long)longptr_tmp;
 
diff --git a/drivers/misc/cxl/guest.c b/drivers/misc/cxl/guest.c
index 8972a74f5c3c..d57663405f31 100644
--- a/drivers/misc/cxl/guest.c
+++ b/drivers/misc/cxl/guest.c
@@ -89,7 +89,7 @@ static ssize_t guest_collect_vpd(struct cxl *adapter, struct cxl_afu *afu,
 		mod = 0;
 	}
 
-	vpd_buf = kzalloc(entries * sizeof(unsigned long *), GFP_KERNEL);
+	vpd_buf = kcalloc(entries, sizeof(unsigned long *), GFP_KERNEL);
 	if (!vpd_buf)
 		return -ENOMEM;
 
diff --git a/drivers/misc/cxl/of.c b/drivers/misc/cxl/of.c
index edc458395f68..25221b15f945 100644
--- a/drivers/misc/cxl/of.c
+++ b/drivers/misc/cxl/of.c
@@ -302,7 +302,7 @@ static int read_adapter_irq_config(struct cxl *adapter, struct device_node *np)
 	if (nranges == 0 || (nranges * 2 * sizeof(int)) != len)
 		return -EINVAL;
 
-	adapter->guest->irq_avail = kzalloc(nranges * sizeof(struct irq_avail),
+	adapter->guest->irq_avail = kcalloc(nranges, sizeof(struct irq_avail),
 					    GFP_KERNEL);
 	if (adapter->guest->irq_avail == NULL)
 		return -ENOMEM;
diff --git a/drivers/misc/genwqe/card_ddcb.c b/drivers/misc/genwqe/card_ddcb.c
index ddfeefe39540..9af976db90a0 100644
--- a/drivers/misc/genwqe/card_ddcb.c
+++ b/drivers/misc/genwqe/card_ddcb.c
@@ -1048,15 +1048,16 @@ static int setup_ddcb_queue(struct genwqe_dev *cd, struct ddcb_queue *queue)
 			"[%s] **err: could not allocate DDCB **\n", __func__);
 		return -ENOMEM;
 	}
-	queue->ddcb_req = kzalloc(sizeof(struct ddcb_requ *) *
-				  queue->ddcb_max, GFP_KERNEL);
+	queue->ddcb_req = kcalloc(queue->ddcb_max, sizeof(struct ddcb_requ *),
+				  GFP_KERNEL);
 	if (!queue->ddcb_req) {
 		rc = -ENOMEM;
 		goto free_ddcbs;
 	}
 
-	queue->ddcb_waitqs = kzalloc(sizeof(wait_queue_head_t) *
-				     queue->ddcb_max, GFP_KERNEL);
+	queue->ddcb_waitqs = kcalloc(queue->ddcb_max,
+				     sizeof(wait_queue_head_t),
+				     GFP_KERNEL);
 	if (!queue->ddcb_waitqs) {
 		rc = -ENOMEM;
 		goto free_requs;
diff --git a/drivers/misc/sgi-xp/xpc_main.c b/drivers/misc/sgi-xp/xpc_main.c
index d971817182f7..3eb682c728ae 100644
--- a/drivers/misc/sgi-xp/xpc_main.c
+++ b/drivers/misc/sgi-xp/xpc_main.c
@@ -417,7 +417,8 @@ xpc_setup_ch_structures(struct xpc_partition *part)
 	 * memory.
 	 */
 	DBUG_ON(part->channels != NULL);
-	part->channels = kzalloc(sizeof(struct xpc_channel) * XPC_MAX_NCHANNELS,
+	part->channels = kcalloc(XPC_MAX_NCHANNELS,
+				 sizeof(struct xpc_channel),
 				 GFP_KERNEL);
 	if (part->channels == NULL) {
 		dev_err(xpc_chan, "can't get memory for channels\n");
@@ -906,8 +907,9 @@ xpc_setup_partitions(void)
 	short partid;
 	struct xpc_partition *part;
 
-	xpc_partitions = kzalloc(sizeof(struct xpc_partition) *
-				 xp_max_npartitions, GFP_KERNEL);
+	xpc_partitions = kcalloc(xp_max_npartitions,
+				 sizeof(struct xpc_partition),
+				 GFP_KERNEL);
 	if (xpc_partitions == NULL) {
 		dev_err(xpc_part, "can't get memory for partition structure\n");
 		return -ENOMEM;
diff --git a/drivers/misc/sgi-xp/xpc_partition.c b/drivers/misc/sgi-xp/xpc_partition.c
index 6956f7e7d439..7284413dabfd 100644
--- a/drivers/misc/sgi-xp/xpc_partition.c
+++ b/drivers/misc/sgi-xp/xpc_partition.c
@@ -425,7 +425,7 @@ xpc_discovery(void)
 	if (remote_rp == NULL)
 		return;
 
-	discovered_nasids = kzalloc(sizeof(long) * xpc_nasid_mask_nlongs,
+	discovered_nasids = kcalloc(xpc_nasid_mask_nlongs, sizeof(long),
 				    GFP_KERNEL);
 	if (discovered_nasids == NULL) {
 		kfree(remote_rp_base);
diff --git a/drivers/misc/sgi-xp/xpnet.c b/drivers/misc/sgi-xp/xpnet.c
index f5416637838e..3f4bc33f4c8a 100644
--- a/drivers/misc/sgi-xp/xpnet.c
+++ b/drivers/misc/sgi-xp/xpnet.c
@@ -535,8 +535,9 @@ xpnet_init(void)
 
 	dev_info(xpnet, "registering network device %s\n", XPNET_DEVICE_NAME);
 
-	xpnet_broadcast_partitions = kzalloc(BITS_TO_LONGS(xp_max_npartitions) *
-					     sizeof(long), GFP_KERNEL);
+	xpnet_broadcast_partitions = kcalloc(BITS_TO_LONGS(xp_max_npartitions),
+					     sizeof(long),
+					     GFP_KERNEL);
 	if (xpnet_broadcast_partitions == NULL)
 		return -ENOMEM;
 
* Unmerged path drivers/misc/sram.c
diff --git a/drivers/mtd/ar7part.c b/drivers/mtd/ar7part.c
index ddc0a4287a4b..e5930c8f74e1 100644
--- a/drivers/mtd/ar7part.c
+++ b/drivers/mtd/ar7part.c
@@ -55,7 +55,7 @@ static int create_mtd_partitions(struct mtd_info *master,
 	int retries = 10;
 	struct mtd_partition *ar7_parts;
 
-	ar7_parts = kzalloc(sizeof(*ar7_parts) * AR7_PARTS, GFP_KERNEL);
+	ar7_parts = kcalloc(AR7_PARTS, sizeof(*ar7_parts), GFP_KERNEL);
 	if (!ar7_parts)
 		return -ENOMEM;
 	ar7_parts[0].name = "loader";
diff --git a/drivers/mtd/bcm47xxpart.c b/drivers/mtd/bcm47xxpart.c
index 9279a9174f84..11257f17639e 100644
--- a/drivers/mtd/bcm47xxpart.c
+++ b/drivers/mtd/bcm47xxpart.c
@@ -69,7 +69,7 @@ static int bcm47xxpart_parse(struct mtd_info *master,
 		blocksize = 0x10000;
 
 	/* Alloc */
-	parts = kzalloc(sizeof(struct mtd_partition) * BCM47XXPART_MAX_PARTS,
+	parts = kcalloc(BCM47XXPART_MAX_PARTS, sizeof(struct mtd_partition),
 			GFP_KERNEL);
 	buf = kzalloc(BCM47XXPART_BYTES_TO_READ, GFP_KERNEL);
 
* Unmerged path drivers/mtd/chips/cfi_cmdset_0001.c
diff --git a/drivers/mtd/chips/cfi_cmdset_0002.c b/drivers/mtd/chips/cfi_cmdset_0002.c
index fff665d59a0d..a433107f05ce 100644
--- a/drivers/mtd/chips/cfi_cmdset_0002.c
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c
@@ -2306,7 +2306,7 @@ static int __maybe_unused cfi_ppb_unlock(struct mtd_info *mtd, loff_t ofs,
 	 * first check the locking status of all sectors and save
 	 * it for future use.
 	 */
-	sect = kzalloc(MAX_SECTORS * sizeof(struct ppb_lock), GFP_KERNEL);
+	sect = kcalloc(MAX_SECTORS, sizeof(struct ppb_lock), GFP_KERNEL);
 	if (!sect)
 		return -ENOMEM;
 
diff --git a/drivers/mtd/devices/docg3.c b/drivers/mtd/devices/docg3.c
index 3e1b0a0ef4db..50344487714f 100644
--- a/drivers/mtd/devices/docg3.c
+++ b/drivers/mtd/devices/docg3.c
@@ -1890,7 +1890,7 @@ doc_probe_device(struct docg3_cascade *cascade, int floor, struct device *dev)
 	mtd->priv = docg3;
 	bbt_nbpages = DIV_ROUND_UP(docg3->max_block + 1,
 				   8 * DOC_LAYOUT_PAGE_SIZE);
-	docg3->bbt = kzalloc(bbt_nbpages * DOC_LAYOUT_PAGE_SIZE, GFP_KERNEL);
+	docg3->bbt = kcalloc(DOC_LAYOUT_PAGE_SIZE, bbt_nbpages, GFP_KERNEL);
 	if (!docg3->bbt)
 		goto nomem3;
 
* Unmerged path drivers/mtd/maps/physmap_of.c
* Unmerged path drivers/mtd/ofpart.c
diff --git a/drivers/mtd/onenand/onenand_base.c b/drivers/mtd/onenand/onenand_base.c
index b3f41f200622..e7eafe22991d 100644
--- a/drivers/mtd/onenand/onenand_base.c
+++ b/drivers/mtd/onenand/onenand_base.c
@@ -3862,8 +3862,10 @@ static int onenand_probe(struct mtd_info *mtd)
 		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
 		/* Maximum possible erase regions */
 		mtd->numeraseregions = this->dies << 1;
-		mtd->eraseregions = kzalloc(sizeof(struct mtd_erase_region_info)
-					* (this->dies << 1), GFP_KERNEL);
+		mtd->eraseregions =
+			kcalloc(this->dies << 1,
+				sizeof(struct mtd_erase_region_info),
+				GFP_KERNEL);
 		if (!mtd->eraseregions)
 			return -ENOMEM;
 	}
* Unmerged path drivers/mtd/parsers/parser_trx.c
* Unmerged path drivers/mtd/parsers/sharpslpart.c
diff --git a/drivers/mtd/sm_ftl.c b/drivers/mtd/sm_ftl.c
index f9d5615c5727..2a2896d7931c 100644
--- a/drivers/mtd/sm_ftl.c
+++ b/drivers/mtd/sm_ftl.c
@@ -85,7 +85,7 @@ struct attribute_group *sm_create_sysfs_attributes(struct sm_ftl *ftl)
 
 
 	/* Create array of pointers to the attributes */
-	attributes = kzalloc(sizeof(struct attribute *) * (NUM_ATTRIBUTES + 1),
+	attributes = kcalloc(NUM_ATTRIBUTES + 1, sizeof(struct attribute *),
 								GFP_KERNEL);
 	if (!attributes)
 		goto error3;
@@ -1158,7 +1158,7 @@ static void sm_add_mtd(struct mtd_blktrans_ops *tr, struct mtd_info *mtd)
 		goto error2;
 
 	/* Allocate zone array, it will be initialized on demand */
-	ftl->zones = kzalloc(sizeof(struct ftl_zone) * ftl->zone_count,
+	ftl->zones = kcalloc(ftl->zone_count, sizeof(struct ftl_zone),
 								GFP_KERNEL);
 	if (!ftl->zones)
 		goto error3;
* Unmerged path drivers/mtd/tests/mtd_pagetest.c
diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c
index c95bfb183c62..20f6446dd72b 100644
--- a/drivers/mtd/ubi/wl.c
+++ b/drivers/mtd/ubi/wl.c
@@ -1888,7 +1888,7 @@ int ubi_wl_init(struct ubi_device *ubi, struct ubi_attach_info *ai)
 	sprintf(ubi->bgt_name, UBI_BGT_NAME_PATTERN, ubi->ubi_num);
 
 	err = -ENOMEM;
-	ubi->lookuptbl = kzalloc(ubi->peb_count * sizeof(void *), GFP_KERNEL);
+	ubi->lookuptbl = kcalloc(ubi->peb_count, sizeof(void *), GFP_KERNEL);
 	if (!ubi->lookuptbl)
 		return err;
 
* Unmerged path drivers/net/bonding/bond_main.c
diff --git a/drivers/net/can/grcan.c b/drivers/net/can/grcan.c
index 17fbc7a09224..d0940f031788 100644
--- a/drivers/net/can/grcan.c
+++ b/drivers/net/can/grcan.c
@@ -1060,7 +1060,7 @@ static int grcan_open(struct net_device *dev)
 		return err;
 	}
 
-	priv->echo_skb = kzalloc(dma->tx.size * sizeof(*priv->echo_skb),
+	priv->echo_skb = kcalloc(dma->tx.size, sizeof(*priv->echo_skb),
 				 GFP_KERNEL);
 	if (!priv->echo_skb) {
 		err = -ENOMEM;
@@ -1069,7 +1069,7 @@ static int grcan_open(struct net_device *dev)
 	priv->can.echo_skb_max = dma->tx.size;
 	priv->can.echo_skb = priv->echo_skb;
 
-	priv->txdlc = kzalloc(dma->tx.size * sizeof(*priv->txdlc), GFP_KERNEL);
+	priv->txdlc = kcalloc(dma->tx.size, sizeof(*priv->txdlc), GFP_KERNEL);
 	if (!priv->txdlc) {
 		err = -ENOMEM;
 		goto exit_free_echo_skb;
diff --git a/drivers/net/can/slcan.c b/drivers/net/can/slcan.c
index 92bc87cbf3e3..fe4c7e408a25 100644
--- a/drivers/net/can/slcan.c
+++ b/drivers/net/can/slcan.c
@@ -648,7 +648,7 @@ static int __init slcan_init(void)
 	printk(banner);
 	printk(KERN_INFO "slcan: %d dynamic interface channels.\n", maxdev);
 
-	slcan_devs = kzalloc(sizeof(struct net_device *)*maxdev, GFP_KERNEL);
+	slcan_devs = kcalloc(maxdev, sizeof(struct net_device *), GFP_KERNEL);
 	if (!slcan_devs)
 		return -ENOMEM;
 
* Unmerged path drivers/net/ethernet/broadcom/bcm63xx_enet.c
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c
index 383db0c3a78b..c835f6c7ecd0 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c
@@ -574,7 +574,7 @@ int bnx2x_vf_mcast(struct bnx2x *bp, struct bnx2x_virtf *vf,
 	else
 		set_bit(RAMROD_COMP_WAIT, &mcast.ramrod_flags);
 	if (mc_num) {
-		mc = kzalloc(mc_num * sizeof(struct bnx2x_mcast_list_elem),
+		mc = kcalloc(mc_num, sizeof(struct bnx2x_mcast_list_elem),
 			     GFP_KERNEL);
 		if (!mc) {
 			BNX2X_ERR("Cannot Configure multicasts due to lack of memory\n");
@@ -1256,8 +1256,9 @@ int bnx2x_iov_init_one(struct bnx2x *bp, int int_mode_param,
 	   num_vfs_param, iov->nr_virtfn);
 
 	/* allocate the vf array */
-	bp->vfdb->vfs = kzalloc(sizeof(struct bnx2x_virtf) *
-				BNX2X_NR_VIRTFN(bp), GFP_KERNEL);
+	bp->vfdb->vfs = kcalloc(BNX2X_NR_VIRTFN(bp),
+				sizeof(struct bnx2x_virtf),
+				GFP_KERNEL);
 	if (!bp->vfdb->vfs) {
 		BNX2X_ERR("failed to allocate vf array\n");
 		err = -ENOMEM;
@@ -1283,9 +1284,9 @@ int bnx2x_iov_init_one(struct bnx2x *bp, int int_mode_param,
 	}
 
 	/* allocate the queue arrays for all VFs */
-	bp->vfdb->vfqs = kzalloc(
-		BNX2X_MAX_NUM_VF_QUEUES * sizeof(struct bnx2x_vf_queue),
-		GFP_KERNEL);
+	bp->vfdb->vfqs = kcalloc(BNX2X_MAX_NUM_VF_QUEUES,
+				 sizeof(struct bnx2x_vf_queue),
+				 GFP_KERNEL);
 
 	if (!bp->vfdb->vfqs) {
 		BNX2X_ERR("failed to allocate vf queue array\n");
diff --git a/drivers/net/ethernet/broadcom/cnic.c b/drivers/net/ethernet/broadcom/cnic.c
index ae0e72a89854..8fcae2ee31a1 100644
--- a/drivers/net/ethernet/broadcom/cnic.c
+++ b/drivers/net/ethernet/broadcom/cnic.c
@@ -660,7 +660,7 @@ static int cnic_init_id_tbl(struct cnic_id_tbl *id_tbl, u32 size, u32 start_id,
 	id_tbl->max = size;
 	id_tbl->next = next;
 	spin_lock_init(&id_tbl->lock);
-	id_tbl->table = kzalloc(DIV_ROUND_UP(size, 32) * 4, GFP_KERNEL);
+	id_tbl->table = kcalloc(DIV_ROUND_UP(size, 32), 4, GFP_KERNEL);
 	if (!id_tbl->table)
 		return -ENOMEM;
 
@@ -1255,13 +1255,13 @@ static int cnic_alloc_bnx2x_resc(struct cnic_dev *dev)
 			cp->fcoe_init_cid = 0x10;
 	}
 
-	cp->iscsi_tbl = kzalloc(sizeof(struct cnic_iscsi) * MAX_ISCSI_TBL_SZ,
+	cp->iscsi_tbl = kcalloc(MAX_ISCSI_TBL_SZ, sizeof(struct cnic_iscsi),
 				GFP_KERNEL);
 	if (!cp->iscsi_tbl)
 		goto error;
 
-	cp->ctx_tbl = kzalloc(sizeof(struct cnic_context) *
-				cp->max_cid_space, GFP_KERNEL);
+	cp->ctx_tbl = kcalloc(cp->max_cid_space, sizeof(struct cnic_context),
+			      GFP_KERNEL);
 	if (!cp->ctx_tbl)
 		goto error;
 
@@ -4098,7 +4098,7 @@ static int cnic_cm_alloc_mem(struct cnic_dev *dev)
 	struct cnic_local *cp = dev->cnic_priv;
 	u32 port_id;
 
-	cp->csk_tbl = kzalloc(sizeof(struct cnic_sock) * MAX_CM_SK_TBL_SZ,
+	cp->csk_tbl = kcalloc(MAX_CM_SK_TBL_SZ, sizeof(struct cnic_sock),
 			      GFP_KERNEL);
 	if (!cp->csk_tbl)
 		return -ENOMEM;
diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c
index 3a7e8ee26e3f..3caa27158dc6 100644
--- a/drivers/net/ethernet/broadcom/tg3.c
+++ b/drivers/net/ethernet/broadcom/tg3.c
@@ -8631,8 +8631,9 @@ static int tg3_mem_tx_acquire(struct tg3 *tp)
 		tnapi++;
 
 	for (i = 0; i < tp->txq_cnt; i++, tnapi++) {
-		tnapi->tx_buffers = kzalloc(sizeof(struct tg3_tx_ring_info) *
-					    TG3_TX_RING_SIZE, GFP_KERNEL);
+		tnapi->tx_buffers = kcalloc(TG3_TX_RING_SIZE,
+					    sizeof(struct tg3_tx_ring_info),
+					    GFP_KERNEL);
 		if (!tnapi->tx_buffers)
 			goto err_out;
 
diff --git a/drivers/net/ethernet/brocade/bna/bnad.c b/drivers/net/ethernet/brocade/bna/bnad.c
index 44a0cf4a713f..e030955c3101 100644
--- a/drivers/net/ethernet/brocade/bna/bnad.c
+++ b/drivers/net/ethernet/brocade/bna/bnad.c
@@ -3143,7 +3143,7 @@ bnad_set_rx_ucast_fltr(struct bnad *bnad)
 	if (uc_count > bna_attr(&bnad->bna)->num_ucmac)
 		goto mode_default;
 
-	mac_list = kzalloc(uc_count * ETH_ALEN, GFP_ATOMIC);
+	mac_list = kcalloc(ETH_ALEN, uc_count, GFP_ATOMIC);
 	if (mac_list == NULL)
 		goto mode_default;
 
@@ -3184,7 +3184,7 @@ bnad_set_rx_mcast_fltr(struct bnad *bnad)
 	if (mc_count > bna_attr(&bnad->bna)->num_mcmac)
 		goto mode_allmulti;
 
-	mac_list = kzalloc((mc_count + 1) * ETH_ALEN, GFP_ATOMIC);
+	mac_list = kcalloc(mc_count + 1, ETH_ALEN, GFP_ATOMIC);
 
 	if (mac_list == NULL)
 		goto mode_allmulti;
diff --git a/drivers/net/ethernet/calxeda/xgmac.c b/drivers/net/ethernet/calxeda/xgmac.c
index 97f7fe38c1c3..eb073fbb3765 100644
--- a/drivers/net/ethernet/calxeda/xgmac.c
+++ b/drivers/net/ethernet/calxeda/xgmac.c
@@ -716,7 +716,7 @@ static int xgmac_dma_desc_rings_init(struct net_device *dev)
 
 	netdev_dbg(priv->dev, "mtu [%d] bfsize [%d]\n", dev->mtu, bfsize);
 
-	priv->rx_skbuff = kzalloc(sizeof(struct sk_buff *) * DMA_RX_RING_SZ,
+	priv->rx_skbuff = kcalloc(DMA_RX_RING_SZ, sizeof(struct sk_buff *),
 				  GFP_KERNEL);
 	if (!priv->rx_skbuff)
 		return -ENOMEM;
@@ -729,7 +729,7 @@ static int xgmac_dma_desc_rings_init(struct net_device *dev)
 	if (!priv->dma_rx)
 		goto err_dma_rx;
 
-	priv->tx_skbuff = kzalloc(sizeof(struct sk_buff *) * DMA_TX_RING_SZ,
+	priv->tx_skbuff = kcalloc(DMA_TX_RING_SZ, sizeof(struct sk_buff *),
 				  GFP_KERNEL);
 	if (!priv->tx_skbuff)
 		goto err_tx_skb;
* Unmerged path drivers/net/ethernet/cavium/thunder/nicvf_queues.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
index 33a5f1548b3a..8a7c3515c43d 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
@@ -576,13 +576,13 @@ int t4_uld_mem_alloc(struct adapter *adap)
 	if (!adap->uld)
 		return -ENOMEM;
 
-	s->uld_rxq_info = kzalloc(CXGB4_ULD_MAX *
+	s->uld_rxq_info = kcalloc(CXGB4_ULD_MAX,
 				  sizeof(struct sge_uld_rxq_info *),
 				  GFP_KERNEL);
 	if (!s->uld_rxq_info)
 		goto err_uld;
 
-	s->uld_txq_info = kzalloc(CXGB4_TX_MAX *
+	s->uld_txq_info = kcalloc(CXGB4_TX_MAX,
 				  sizeof(struct sge_uld_txq_info *),
 				  GFP_KERNEL);
 	if (!s->uld_txq_info)
* Unmerged path drivers/net/ethernet/cortina/gemini.c
* Unmerged path drivers/net/ethernet/hisilicon/hns/hns_enet.c
diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c
index e2400a9cba88..e8c29db4e901 100644
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@ -3333,7 +3333,7 @@ static int e1000e_write_mc_addr_list(struct net_device *netdev)
 		return 0;
 	}
 
-	mta_list = kzalloc(netdev_mc_count(netdev) * ETH_ALEN, GFP_ATOMIC);
+	mta_list = kcalloc(netdev_mc_count(netdev), ETH_ALEN, GFP_ATOMIC);
 	if (!mta_list)
 		return -ENOMEM;
 
diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index f3ec7f4386c9..f2005e7ff057 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -3878,8 +3878,9 @@ static int igb_sw_init(struct igb_adapter *adapter)
 	/* Assume MSI-X interrupts, will be checked during IRQ allocation */
 	adapter->flags |= IGB_FLAG_HAS_MSIX;
 
-	adapter->mac_table = kzalloc(sizeof(struct igb_mac_addr) *
-				     hw->mac.rar_entry_count, GFP_ATOMIC);
+	adapter->mac_table = kcalloc(hw->mac.rar_entry_count,
+				     sizeof(struct igb_mac_addr),
+				     GFP_ATOMIC);
 	if (!adapter->mac_table)
 		return -ENOMEM;
 
@@ -4870,7 +4871,7 @@ static int igb_write_mc_addr_list(struct net_device *netdev)
 		return 0;
 	}
 
-	mta_list = kzalloc(netdev_mc_count(netdev) * 6, GFP_ATOMIC);
+	mta_list = kcalloc(netdev_mc_count(netdev), 6, GFP_ATOMIC);
 	if (!mta_list)
 		return -ENOMEM;
 
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 8fd9411ca42e..093356cdd758 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -6226,8 +6226,8 @@ static int ixgbe_sw_init(struct ixgbe_adapter *adapter,
 	for (i = 1; i < IXGBE_MAX_LINK_HANDLE; i++)
 		adapter->jump_tables[i] = NULL;
 
-	adapter->mac_table = kzalloc(sizeof(struct ixgbe_mac_addr) *
-				     hw->mac.num_rar_entries,
+	adapter->mac_table = kcalloc(hw->mac.num_rar_entries,
+				     sizeof(struct ixgbe_mac_addr),
 				     GFP_ATOMIC);
 	if (!adapter->mac_table)
 		return -ENOMEM;
* Unmerged path drivers/net/ethernet/jme.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/alloc.c b/drivers/net/ethernet/mellanox/mlx4/alloc.c
index 94f4dc4a77e9..21788d4f9881 100644
--- a/drivers/net/ethernet/mellanox/mlx4/alloc.c
+++ b/drivers/net/ethernet/mellanox/mlx4/alloc.c
@@ -185,8 +185,8 @@ int mlx4_bitmap_init(struct mlx4_bitmap *bitmap, u32 num, u32 mask,
 	bitmap->avail = num - reserved_top - reserved_bot;
 	bitmap->effective_len = bitmap->avail;
 	spin_lock_init(&bitmap->lock);
-	bitmap->table = kzalloc(BITS_TO_LONGS(bitmap->max) *
-				sizeof(long), GFP_KERNEL);
+	bitmap->table = kcalloc(BITS_TO_LONGS(bitmap->max), sizeof(long),
+				GFP_KERNEL);
 	if (!bitmap->table)
 		return -ENOMEM;
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/cmd.c b/drivers/net/ethernet/mellanox/mlx4/cmd.c
index 6a9086dc1e92..882c5e48a687 100644
--- a/drivers/net/ethernet/mellanox/mlx4/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx4/cmd.c
@@ -2377,20 +2377,23 @@ int mlx4_multi_func_init(struct mlx4_dev *dev)
 		struct mlx4_vf_admin_state *vf_admin;
 
 		priv->mfunc.master.slave_state =
-			kzalloc(dev->num_slaves *
-				sizeof(struct mlx4_slave_state), GFP_KERNEL);
+			kcalloc(dev->num_slaves,
+				sizeof(struct mlx4_slave_state),
+				GFP_KERNEL);
 		if (!priv->mfunc.master.slave_state)
 			goto err_comm;
 
 		priv->mfunc.master.vf_admin =
-			kzalloc(dev->num_slaves *
-				sizeof(struct mlx4_vf_admin_state), GFP_KERNEL);
+			kcalloc(dev->num_slaves,
+				sizeof(struct mlx4_vf_admin_state),
+				GFP_KERNEL);
 		if (!priv->mfunc.master.vf_admin)
 			goto err_comm_admin;
 
 		priv->mfunc.master.vf_oper =
-			kzalloc(dev->num_slaves *
-				sizeof(struct mlx4_vf_oper_state), GFP_KERNEL);
+			kcalloc(dev->num_slaves,
+				sizeof(struct mlx4_vf_oper_state),
+				GFP_KERNEL);
 		if (!priv->mfunc.master.vf_oper)
 			goto err_comm_oper;
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 3d60d5c2c905..3603a993d50d 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -2217,13 +2217,15 @@ static int mlx4_en_copy_priv(struct mlx4_en_priv *dst,
 		if (!dst->tx_ring_num[t])
 			continue;
 
-		dst->tx_ring[t] = kzalloc(sizeof(struct mlx4_en_tx_ring *) *
-					  MAX_TX_RINGS, GFP_KERNEL);
+		dst->tx_ring[t] = kcalloc(MAX_TX_RINGS,
+					  sizeof(struct mlx4_en_tx_ring *),
+					  GFP_KERNEL);
 		if (!dst->tx_ring[t])
 			goto err_free_tx;
 
-		dst->tx_cq[t] = kzalloc(sizeof(struct mlx4_en_cq *) *
-					MAX_TX_RINGS, GFP_KERNEL);
+		dst->tx_cq[t] = kcalloc(MAX_TX_RINGS,
+					sizeof(struct mlx4_en_cq *),
+					GFP_KERNEL);
 		if (!dst->tx_cq[t]) {
 			kfree(dst->tx_ring[t]);
 			goto err_free_tx;
@@ -3296,14 +3298,16 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 		if (!priv->tx_ring_num[t])
 			continue;
 
-		priv->tx_ring[t] = kzalloc(sizeof(struct mlx4_en_tx_ring *) *
-					   MAX_TX_RINGS, GFP_KERNEL);
+		priv->tx_ring[t] = kcalloc(MAX_TX_RINGS,
+					   sizeof(struct mlx4_en_tx_ring *),
+					   GFP_KERNEL);
 		if (!priv->tx_ring[t]) {
 			err = -ENOMEM;
 			goto out;
 		}
-		priv->tx_cq[t] = kzalloc(sizeof(struct mlx4_en_cq *) *
-					 MAX_TX_RINGS, GFP_KERNEL);
+		priv->tx_cq[t] = kcalloc(MAX_TX_RINGS,
+					 sizeof(struct mlx4_en_cq *),
+					 GFP_KERNEL);
 		if (!priv->tx_cq[t]) {
 			err = -ENOMEM;
 			goto out;
diff --git a/drivers/net/ethernet/mellanox/mlx4/main.c b/drivers/net/ethernet/mellanox/mlx4/main.c
index 65a8aede739e..992783c7e4ca 100644
--- a/drivers/net/ethernet/mellanox/mlx4/main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/main.c
@@ -3175,7 +3175,8 @@ static int mlx4_init_steering(struct mlx4_dev *dev)
 	int num_entries = dev->caps.num_ports;
 	int i, j;
 
-	priv->steer = kzalloc(sizeof(struct mlx4_steer) * num_entries, GFP_KERNEL);
+	priv->steer = kcalloc(num_entries, sizeof(struct mlx4_steer),
+			      GFP_KERNEL);
 	if (!priv->steer)
 		return -ENOMEM;
 
@@ -3296,7 +3297,7 @@ static u64 mlx4_enable_sriov(struct mlx4_dev *dev, struct pci_dev *pdev,
 		}
 	}
 
-	dev->dev_vfs = kzalloc(total_vfs * sizeof(*dev->dev_vfs), GFP_KERNEL);
+	dev->dev_vfs = kcalloc(total_vfs, sizeof(*dev->dev_vfs), GFP_KERNEL);
 	if (NULL == dev->dev_vfs) {
 		mlx4_err(dev, "Failed to allocate memory for VFs\n");
 		goto disable_sriov;
diff --git a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
index f03745a96d40..05e55851cbb0 100644
--- a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
+++ b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
@@ -487,7 +487,7 @@ int mlx4_init_resource_tracker(struct mlx4_dev *dev)
 	int max_vfs_guarantee_counter = get_max_gauranteed_vfs_counter(dev);
 
 	priv->mfunc.master.res_tracker.slave_list =
-		kzalloc(dev->num_slaves * sizeof(struct slave_list),
+		kcalloc(dev->num_slaves, sizeof(struct slave_list),
 			GFP_KERNEL);
 	if (!priv->mfunc.master.res_tracker.slave_list)
 		return -ENOMEM;
@@ -512,14 +512,14 @@ int mlx4_init_resource_tracker(struct mlx4_dev *dev)
 		res_alloc->guaranteed = kmalloc((dev->persist->num_vfs + 1) *
 						sizeof(int), GFP_KERNEL);
 		if (i == RES_MAC || i == RES_VLAN)
-			res_alloc->allocated = kzalloc(MLX4_MAX_PORTS *
-						       (dev->persist->num_vfs
-						       + 1) *
-						       sizeof(int), GFP_KERNEL);
+			res_alloc->allocated =
+				kcalloc(MLX4_MAX_PORTS *
+						(dev->persist->num_vfs + 1),
+					sizeof(int), GFP_KERNEL);
 		else
-			res_alloc->allocated = kzalloc((dev->persist->
-							num_vfs + 1) *
-						       sizeof(int), GFP_KERNEL);
+			res_alloc->allocated =
+				kcalloc(dev->persist->num_vfs + 1,
+					sizeof(int), GFP_KERNEL);
 		/* Reduce the sink counter */
 		if (i == RES_COUNTER)
 			res_alloc->res_free = dev->caps.max_counters - 1;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c b/drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c
index 929c9483610b..87bff3a049a5 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c
@@ -370,7 +370,7 @@ int mlx5_fpga_ipsec_counters_read(struct mlx5_core_dev *mdev, u64 *counters,
 
 	count = mlx5_fpga_ipsec_counters_count(mdev);
 
-	data = kzalloc(sizeof(*data) * count * 2, GFP_KERNEL);
+	data = kzalloc(array3_size(sizeof(*data), count, 2), GFP_KERNEL);
 	if (!data) {
 		ret = -ENOMEM;
 		goto out;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lib/clock.c b/drivers/net/ethernet/mellanox/mlx5/core/lib/clock.c
index 2d64a157cc79..23e769e41abc 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lib/clock.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lib/clock.c
@@ -399,8 +399,9 @@ static int mlx5_init_pin_config(struct mlx5_clock *clock)
 	int i;
 
 	clock->ptp_info.pin_config =
-			kzalloc(sizeof(*clock->ptp_info.pin_config) *
-				clock->ptp_info.n_pins, GFP_KERNEL);
+			kcalloc(clock->ptp_info.n_pins,
+				sizeof(*clock->ptp_info.pin_config),
+				GFP_KERNEL);
 	if (!clock->ptp_info.pin_config)
 		return -ENOMEM;
 	clock->ptp_info.enable = mlx5_ptp_enable;
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
index 91262b0573e3..cad603c35271 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_qdisc.c
@@ -740,7 +740,8 @@ int mlxsw_sp_tc_qdisc_init(struct mlxsw_sp_port *mlxsw_sp_port)
 	mlxsw_sp_port->root_qdisc->prio_bitmap = 0xff;
 	mlxsw_sp_port->root_qdisc->tclass_num = MLXSW_SP_PORT_DEFAULT_TCLASS;
 
-	mlxsw_sp_qdisc = kzalloc(sizeof(*mlxsw_sp_qdisc) * IEEE_8021QAZ_MAX_TCS,
+	mlxsw_sp_qdisc = kcalloc(IEEE_8021QAZ_MAX_TCS,
+				 sizeof(*mlxsw_sp_qdisc),
 				 GFP_KERNEL);
 	if (!mlxsw_sp_qdisc)
 		goto err_tclass_qdiscs_init;
diff --git a/drivers/net/ethernet/micrel/ksz884x.c b/drivers/net/ethernet/micrel/ksz884x.c
index 3bd89509c643..d796d5a1d15c 100644
--- a/drivers/net/ethernet/micrel/ksz884x.c
+++ b/drivers/net/ethernet/micrel/ksz884x.c
@@ -4380,7 +4380,7 @@ static void ksz_update_timer(struct ksz_timer_info *info)
  */
 static int ksz_alloc_soft_desc(struct ksz_desc_info *desc_info, int transmit)
 {
-	desc_info->ring = kzalloc(sizeof(struct ksz_desc) * desc_info->alloc,
+	desc_info->ring = kcalloc(desc_info->alloc, sizeof(struct ksz_desc),
 				  GFP_KERNEL);
 	if (!desc_info->ring)
 		return 1;
diff --git a/drivers/net/ethernet/neterion/vxge/vxge-config.c b/drivers/net/ethernet/neterion/vxge/vxge-config.c
index fbe5363cb89c..13fd25afdb6d 100644
--- a/drivers/net/ethernet/neterion/vxge/vxge-config.c
+++ b/drivers/net/ethernet/neterion/vxge/vxge-config.c
@@ -2223,22 +2223,22 @@ __vxge_hw_channel_allocate(struct __vxge_hw_vpath_handle *vph,
 	channel->length = length;
 	channel->vp_id = vp_id;
 
-	channel->work_arr = kzalloc(sizeof(void *)*length, GFP_KERNEL);
+	channel->work_arr = kcalloc(length, sizeof(void *), GFP_KERNEL);
 	if (channel->work_arr == NULL)
 		goto exit1;
 
-	channel->free_arr = kzalloc(sizeof(void *)*length, GFP_KERNEL);
+	channel->free_arr = kcalloc(length, sizeof(void *), GFP_KERNEL);
 	if (channel->free_arr == NULL)
 		goto exit1;
 	channel->free_ptr = length;
 
-	channel->reserve_arr = kzalloc(sizeof(void *)*length, GFP_KERNEL);
+	channel->reserve_arr = kcalloc(length, sizeof(void *), GFP_KERNEL);
 	if (channel->reserve_arr == NULL)
 		goto exit1;
 	channel->reserve_ptr = length;
 	channel->reserve_top = 0;
 
-	channel->orig_arr = kzalloc(sizeof(void *)*length, GFP_KERNEL);
+	channel->orig_arr = kcalloc(length, sizeof(void *), GFP_KERNEL);
 	if (channel->orig_arr == NULL)
 		goto exit1;
 
diff --git a/drivers/net/ethernet/neterion/vxge/vxge-main.c b/drivers/net/ethernet/neterion/vxge/vxge-main.c
index 58127161ca20..4d4c8dc15eaa 100644
--- a/drivers/net/ethernet/neterion/vxge/vxge-main.c
+++ b/drivers/net/ethernet/neterion/vxge/vxge-main.c
@@ -3433,8 +3433,8 @@ static int vxge_device_register(struct __vxge_hw_device *hldev,
 	vxge_initialize_ethtool_ops(ndev);
 
 	/* Allocate memory for vpath */
-	vdev->vpaths = kzalloc((sizeof(struct vxge_vpath)) *
-				no_of_vpath, GFP_KERNEL);
+	vdev->vpaths = kcalloc(no_of_vpath, sizeof(struct vxge_vpath),
+			       GFP_KERNEL);
 	if (!vdev->vpaths) {
 		vxge_debug_init(VXGE_ERR,
 			"%s: vpath memory allocation failed",
diff --git a/drivers/net/ethernet/pasemi/pasemi_mac.c b/drivers/net/ethernet/pasemi/pasemi_mac.c
index c8a6ad2e9b98..4cb4c9b13947 100644
--- a/drivers/net/ethernet/pasemi/pasemi_mac.c
+++ b/drivers/net/ethernet/pasemi/pasemi_mac.c
@@ -429,8 +429,9 @@ static int pasemi_mac_setup_rx_resources(const struct net_device *dev)
 	spin_lock_init(&ring->lock);
 
 	ring->size = RX_RING_SIZE;
-	ring->ring_info = kzalloc(sizeof(struct pasemi_mac_buffer) *
-				  RX_RING_SIZE, GFP_KERNEL);
+	ring->ring_info = kcalloc(RX_RING_SIZE,
+				  sizeof(struct pasemi_mac_buffer),
+				  GFP_KERNEL);
 
 	if (!ring->ring_info)
 		goto out_ring_info;
@@ -513,8 +514,9 @@ pasemi_mac_setup_tx_resources(const struct net_device *dev)
 	spin_lock_init(&ring->lock);
 
 	ring->size = TX_RING_SIZE;
-	ring->ring_info = kzalloc(sizeof(struct pasemi_mac_buffer) *
-				  TX_RING_SIZE, GFP_KERNEL);
+	ring->ring_info = kcalloc(TX_RING_SIZE,
+				  sizeof(struct pasemi_mac_buffer),
+				  GFP_KERNEL);
 	if (!ring->ring_info)
 		goto out_ring_info;
 
diff --git a/drivers/net/ethernet/qlogic/qed/qed_debug.c b/drivers/net/ethernet/qlogic/qed/qed_debug.c
index 0f812608f0e9..5e30c6db7bbb 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_debug.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_debug.c
@@ -6584,7 +6584,8 @@ qed_mcp_trace_alloc_meta_data(struct qed_hwfn *p_hwfn,
 
 	/* Read no. of modules and allocate memory for their pointers */
 	meta->modules_num = qed_read_byte_from_buf(meta_buf_bytes, &offset);
-	meta->modules = kzalloc(meta->modules_num * sizeof(char *), GFP_KERNEL);
+	meta->modules = kcalloc(meta->modules_num, sizeof(char *),
+				GFP_KERNEL);
 	if (!meta->modules)
 		return DBG_STATUS_VIRT_MEM_ALLOC_FAILED;
 
@@ -6612,7 +6613,7 @@ qed_mcp_trace_alloc_meta_data(struct qed_hwfn *p_hwfn,
 
 	/* Read number of formats and allocate memory for all formats */
 	meta->formats_num = qed_read_dword_from_buf(meta_buf_bytes, &offset);
-	meta->formats = kzalloc(meta->formats_num *
+	meta->formats = kcalloc(meta->formats_num,
 				sizeof(struct mcp_trace_format),
 				GFP_KERNEL);
 	if (!meta->formats)
diff --git a/drivers/net/ethernet/qlogic/qed/qed_dev.c b/drivers/net/ethernet/qlogic/qed/qed_dev.c
index a528e2ee9e1e..276a82e50e8b 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@ -1229,26 +1229,26 @@ static int qed_alloc_qm_data(struct qed_hwfn *p_hwfn)
 	if (rc)
 		goto alloc_err;
 
-	qm_info->qm_pq_params = kzalloc(sizeof(*qm_info->qm_pq_params) *
-					qed_init_qm_get_num_pqs(p_hwfn),
+	qm_info->qm_pq_params = kcalloc(qed_init_qm_get_num_pqs(p_hwfn),
+					sizeof(*qm_info->qm_pq_params),
 					GFP_KERNEL);
 	if (!qm_info->qm_pq_params)
 		goto alloc_err;
 
-	qm_info->qm_vport_params = kzalloc(sizeof(*qm_info->qm_vport_params) *
-					   qed_init_qm_get_num_vports(p_hwfn),
+	qm_info->qm_vport_params = kcalloc(qed_init_qm_get_num_vports(p_hwfn),
+					   sizeof(*qm_info->qm_vport_params),
 					   GFP_KERNEL);
 	if (!qm_info->qm_vport_params)
 		goto alloc_err;
 
-	qm_info->qm_port_params = kzalloc(sizeof(*qm_info->qm_port_params) *
-					  p_hwfn->cdev->num_ports_in_engine,
+	qm_info->qm_port_params = kcalloc(p_hwfn->cdev->num_ports_in_engine,
+					  sizeof(*qm_info->qm_port_params),
 					  GFP_KERNEL);
 	if (!qm_info->qm_port_params)
 		goto alloc_err;
 
-	qm_info->wfq_data = kzalloc(sizeof(*qm_info->wfq_data) *
-				    qed_init_qm_get_num_vports(p_hwfn),
+	qm_info->wfq_data = kcalloc(qed_init_qm_get_num_vports(p_hwfn),
+				    sizeof(*qm_info->wfq_data),
 				    GFP_KERNEL);
 	if (!qm_info->wfq_data)
 		goto alloc_err;
diff --git a/drivers/net/ethernet/qlogic/qed/qed_init_ops.c b/drivers/net/ethernet/qlogic/qed/qed_init_ops.c
index b415d25afecf..34193c2f1699 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_init_ops.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_init_ops.c
@@ -149,12 +149,12 @@ int qed_init_alloc(struct qed_hwfn *p_hwfn)
 	if (IS_VF(p_hwfn->cdev))
 		return 0;
 
-	rt_data->b_valid = kzalloc(sizeof(bool) * RUNTIME_ARRAY_SIZE,
+	rt_data->b_valid = kcalloc(RUNTIME_ARRAY_SIZE, sizeof(bool),
 				   GFP_KERNEL);
 	if (!rt_data->b_valid)
 		return -ENOMEM;
 
-	rt_data->init_val = kzalloc(sizeof(u32) * RUNTIME_ARRAY_SIZE,
+	rt_data->init_val = kcalloc(RUNTIME_ARRAY_SIZE, sizeof(u32),
 				    GFP_KERNEL);
 	if (!rt_data->init_val) {
 		kfree(rt_data->b_valid);
diff --git a/drivers/net/ethernet/qlogic/qed/qed_l2.c b/drivers/net/ethernet/qlogic/qed/qed_l2.c
index d0ebd7de3110..f2b2fa9e9df7 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_l2.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_l2.c
@@ -98,7 +98,7 @@ int qed_l2_alloc(struct qed_hwfn *p_hwfn)
 		p_l2_info->queues = max_t(u8, rx, tx);
 	}
 
-	pp_qids = kzalloc(sizeof(unsigned long *) * p_l2_info->queues,
+	pp_qids = kcalloc(p_l2_info->queues, sizeof(unsigned long *),
 			  GFP_KERNEL);
 	if (!pp_qids)
 		return -ENOMEM;
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index 238395f5b308..235ea20462cb 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@ -1023,15 +1023,17 @@ int qlcnic_init_pci_info(struct qlcnic_adapter *adapter)
 
 	act_pci_func = ahw->total_nic_func;
 
-	adapter->npars = kzalloc(sizeof(struct qlcnic_npar_info) *
-				 act_pci_func, GFP_KERNEL);
+	adapter->npars = kcalloc(act_pci_func,
+				 sizeof(struct qlcnic_npar_info),
+				 GFP_KERNEL);
 	if (!adapter->npars) {
 		ret = -ENOMEM;
 		goto err_pci_info;
 	}
 
-	adapter->eswitch = kzalloc(sizeof(struct qlcnic_eswitch) *
-				QLCNIC_NIU_MAX_XG_PORTS, GFP_KERNEL);
+	adapter->eswitch = kcalloc(QLCNIC_NIU_MAX_XG_PORTS,
+				   sizeof(struct qlcnic_eswitch),
+				   GFP_KERNEL);
 	if (!adapter->eswitch) {
 		ret = -ENOMEM;
 		goto err_npars;
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c
index c58180f40844..0c744b9c6e0a 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sriov_common.c
@@ -157,8 +157,8 @@ int qlcnic_sriov_init(struct qlcnic_adapter *adapter, int num_vfs)
 	adapter->ahw->sriov = sriov;
 	sriov->num_vfs = num_vfs;
 	bc = &sriov->bc;
-	sriov->vf_info = kzalloc(sizeof(struct qlcnic_vf_info) *
-				 num_vfs, GFP_KERNEL);
+	sriov->vf_info = kcalloc(num_vfs, sizeof(struct qlcnic_vf_info),
+				 GFP_KERNEL);
 	if (!sriov->vf_info) {
 		err = -ENOMEM;
 		goto qlcnic_free_sriov;
@@ -450,7 +450,7 @@ static int qlcnic_sriov_set_guest_vlan_mode(struct qlcnic_adapter *adapter,
 		return 0;
 
 	num_vlans = sriov->num_allowed_vlans;
-	sriov->allowed_vlans = kzalloc(sizeof(u16) * num_vlans, GFP_KERNEL);
+	sriov->allowed_vlans = kcalloc(num_vlans, sizeof(u16), GFP_KERNEL);
 	if (!sriov->allowed_vlans)
 		return -ENOMEM;
 
@@ -706,7 +706,7 @@ static inline int qlcnic_sriov_alloc_bc_trans(struct qlcnic_bc_trans **trans)
 static inline int qlcnic_sriov_alloc_bc_msg(struct qlcnic_bc_hdr **hdr,
 					    u32 size)
 {
-	*hdr = kzalloc(sizeof(struct qlcnic_bc_hdr) * size, GFP_ATOMIC);
+	*hdr = kcalloc(size, sizeof(struct qlcnic_bc_hdr), GFP_ATOMIC);
 	if (!*hdr)
 		return -ENOMEM;
 
* Unmerged path drivers/net/ethernet/socionext/netsec.c
diff --git a/drivers/net/ethernet/toshiba/ps3_gelic_wireless.c b/drivers/net/ethernet/toshiba/ps3_gelic_wireless.c
index d568af1eb4f4..c39381275d5b 100644
--- a/drivers/net/ethernet/toshiba/ps3_gelic_wireless.c
+++ b/drivers/net/ethernet/toshiba/ps3_gelic_wireless.c
@@ -2330,8 +2330,9 @@ static struct net_device *gelic_wl_alloc(struct gelic_card *card)
 	pr_debug("%s: wl=%p port=%p\n", __func__, wl, port);
 
 	/* allocate scan list */
-	wl->networks = kzalloc(sizeof(struct gelic_wl_scan_info) *
-			       GELIC_WL_BSS_MAX_ENT, GFP_KERNEL);
+	wl->networks = kcalloc(GELIC_WL_BSS_MAX_ENT,
+			       sizeof(struct gelic_wl_scan_info),
+			       GFP_KERNEL);
 
 	if (!wl->networks)
 		goto fail_bss;
* Unmerged path drivers/net/phy/dp83640.c
diff --git a/drivers/net/slip/slip.c b/drivers/net/slip/slip.c
index 3a65fc0cbfe5..64bef96164b9 100644
--- a/drivers/net/slip/slip.c
+++ b/drivers/net/slip/slip.c
@@ -1312,7 +1312,7 @@ static int __init slip_init(void)
 	printk(KERN_INFO "SLIP linefill/keepalive option.\n");
 #endif
 
-	slip_devs = kzalloc(sizeof(struct net_device *)*slip_maxdev,
+	slip_devs = kcalloc(slip_maxdev, sizeof(struct net_device *),
 								GFP_KERNEL);
 	if (!slip_devs)
 		return -ENOMEM;
diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c
index 43766247fcd0..8a82aa20582d 100644
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@ -269,7 +269,7 @@ static int __team_options_register(struct team *team,
 	struct team_option **dst_opts;
 	int err;
 
-	dst_opts = kzalloc(sizeof(struct team_option *) * option_count,
+	dst_opts = kcalloc(option_count, sizeof(struct team_option *),
 			   GFP_KERNEL);
 	if (!dst_opts)
 		return -ENOMEM;
diff --git a/drivers/net/usb/smsc95xx.c b/drivers/net/usb/smsc95xx.c
index a69da965b07c..f98f3d850dde 100644
--- a/drivers/net/usb/smsc95xx.c
+++ b/drivers/net/usb/smsc95xx.c
@@ -1664,7 +1664,7 @@ static int smsc95xx_suspend(struct usb_interface *intf, pm_message_t message)
 	}
 
 	if (pdata->wolopts & (WAKE_BCAST | WAKE_MCAST | WAKE_ARP | WAKE_UCAST)) {
-		u32 *filter_mask = kzalloc(sizeof(u32) * 32, GFP_KERNEL);
+		u32 *filter_mask = kcalloc(32, sizeof(u32), GFP_KERNEL);
 		u32 command[2];
 		u32 offset[2];
 		u32 crc[4];
* Unmerged path drivers/net/virtio_net.c
* Unmerged path drivers/net/wan/fsl_ucc_hdlc.c
diff --git a/drivers/net/wireless/ath/ath10k/htt_rx.c b/drivers/net/wireless/ath/ath10k/htt_rx.c
index b911c0ae567f..46ca94f4ee71 100644
--- a/drivers/net/wireless/ath/ath10k/htt_rx.c
+++ b/drivers/net/wireless/ath/ath10k/htt_rx.c
@@ -481,7 +481,7 @@ int ath10k_htt_rx_alloc(struct ath10k_htt *htt)
 	}
 
 	htt->rx_ring.netbufs_ring =
-		kzalloc(htt->rx_ring.size * sizeof(struct sk_buff *),
+		kcalloc(htt->rx_ring.size, sizeof(struct sk_buff *),
 			GFP_KERNEL);
 	if (!htt->rx_ring.netbufs_ring)
 		goto err_netbuf;
diff --git a/drivers/net/wireless/ath/ath10k/wmi-tlv.c b/drivers/net/wireless/ath/ath10k/wmi-tlv.c
index 7616c1c4bbd3..134a2ac1ce27 100644
--- a/drivers/net/wireless/ath/ath10k/wmi-tlv.c
+++ b/drivers/net/wireless/ath/ath10k/wmi-tlv.c
@@ -154,7 +154,7 @@ ath10k_wmi_tlv_parse_alloc(struct ath10k *ar, const void *ptr,
 	const void **tb;
 	int ret;
 
-	tb = kzalloc(sizeof(*tb) * WMI_TLV_TAG_MAX, gfp);
+	tb = kcalloc(WMI_TLV_TAG_MAX, sizeof(*tb), gfp);
 	if (!tb)
 		return ERR_PTR(-ENOMEM);
 
diff --git a/drivers/net/wireless/ath/ath6kl/cfg80211.c b/drivers/net/wireless/ath/ath6kl/cfg80211.c
index 0e26f4a34fda..72edba8a281d 100644
--- a/drivers/net/wireless/ath/ath6kl/cfg80211.c
+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.c
@@ -1032,7 +1032,7 @@ static int ath6kl_cfg80211_scan(struct wiphy *wiphy,
 
 		n_channels = request->n_channels;
 
-		channels = kzalloc(n_channels * sizeof(u16), GFP_KERNEL);
+		channels = kcalloc(n_channels, sizeof(u16), GFP_KERNEL);
 		if (channels == NULL) {
 			ath6kl_warn("failed to set scan channels, scan all channels");
 			n_channels = 0;
diff --git a/drivers/net/wireless/ath/carl9170/main.c b/drivers/net/wireless/ath/carl9170/main.c
index 7e2c1c870a1d..023f46f61eb3 100644
--- a/drivers/net/wireless/ath/carl9170/main.c
+++ b/drivers/net/wireless/ath/carl9170/main.c
@@ -1959,7 +1959,7 @@ static int carl9170_parse_eeprom(struct ar9170 *ar)
 	if (!bands)
 		return -EINVAL;
 
-	ar->survey = kzalloc(sizeof(struct survey_info) * chans, GFP_KERNEL);
+	ar->survey = kcalloc(chans, sizeof(struct survey_info), GFP_KERNEL);
 	if (!ar->survey)
 		return -ENOMEM;
 	ar->num_channels = chans;
@@ -1989,8 +1989,9 @@ int carl9170_register(struct ar9170 *ar)
 	if (WARN_ON(ar->mem_bitmap))
 		return -EINVAL;
 
-	ar->mem_bitmap = kzalloc(roundup(ar->fw.mem_blocks, BITS_PER_LONG) *
-				 sizeof(unsigned long), GFP_KERNEL);
+	ar->mem_bitmap = kcalloc(roundup(ar->fw.mem_blocks, BITS_PER_LONG),
+				 sizeof(unsigned long),
+				 GFP_KERNEL);
 
 	if (!ar->mem_bitmap)
 		return -ENOMEM;
diff --git a/drivers/net/wireless/b43/phy_n.c b/drivers/net/wireless/b43/phy_n.c
index 7c970d3ae358..52dccb0ffd10 100644
--- a/drivers/net/wireless/b43/phy_n.c
+++ b/drivers/net/wireless/b43/phy_n.c
@@ -1090,7 +1090,7 @@ static int b43_nphy_load_samples(struct b43_wldev *dev,
 	u16 i;
 	u32 *data;
 
-	data = kzalloc(len * sizeof(u32), GFP_KERNEL);
+	data = kcalloc(len, sizeof(u32), GFP_KERNEL);
 	if (!data) {
 		b43err(dev->wl, "allocation for samples loading failed\n");
 		return -ENOMEM;
diff --git a/drivers/net/wireless/b43legacy/main.c b/drivers/net/wireless/b43legacy/main.c
index 572668821862..e9410ee047f5 100644
--- a/drivers/net/wireless/b43legacy/main.c
+++ b/drivers/net/wireless/b43legacy/main.c
@@ -3304,8 +3304,8 @@ static int b43legacy_wireless_core_init(struct b43legacy_wldev *dev)
 
 	if ((phy->type == B43legacy_PHYTYPE_B) ||
 	    (phy->type == B43legacy_PHYTYPE_G)) {
-		phy->_lo_pairs = kzalloc(sizeof(struct b43legacy_lopair)
-					 * B43legacy_LO_COUNT,
+		phy->_lo_pairs = kcalloc(B43legacy_LO_COUNT,
+					 sizeof(struct b43legacy_lopair),
 					 GFP_KERNEL);
 		if (!phy->_lo_pairs)
 			return -ENOMEM;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
index d2c834c3b2fc..c042707e3572 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
@@ -1478,8 +1478,9 @@ int brcmf_proto_msgbuf_attach(struct brcmf_pub *drvr)
 		(struct brcmf_commonring **)if_msgbuf->commonrings;
 	msgbuf->flowrings = (struct brcmf_commonring **)if_msgbuf->flowrings;
 	msgbuf->max_flowrings = if_msgbuf->max_flowrings;
-	msgbuf->flowring_dma_handle = kzalloc(msgbuf->max_flowrings *
-		sizeof(*msgbuf->flowring_dma_handle), GFP_KERNEL);
+	msgbuf->flowring_dma_handle =
+		kcalloc(msgbuf->max_flowrings,
+			sizeof(*msgbuf->flowring_dma_handle), GFP_KERNEL);
 	if (!msgbuf->flowring_dma_handle)
 		goto fail;
 
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
index 94577da71958..f8faf06ede39 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
@@ -1065,7 +1065,7 @@ static s32 brcmf_p2p_act_frm_search(struct brcmf_p2p_info *p2p, u16 channel)
 		channel_cnt = AF_PEER_SEARCH_CNT;
 	else
 		channel_cnt = SOCIAL_CHAN_CNT;
-	default_chan_list = kzalloc(channel_cnt * sizeof(*default_chan_list),
+	default_chan_list = kcalloc(channel_cnt, sizeof(*default_chan_list),
 				    GFP_KERNEL);
 	if (default_chan_list == NULL) {
 		brcmf_err("channel list allocation failed\n");
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/main.c b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/main.c
index 0a14942b8216..7d4e8f589fdc 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/main.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/main.c
@@ -507,7 +507,7 @@ brcms_c_attach_malloc(uint unit, uint *err, uint devid)
 	wlc->hw->wlc = wlc;
 
 	wlc->hw->bandstate[0] =
-		kzalloc(sizeof(struct brcms_hw_band) * MAXBANDS, GFP_ATOMIC);
+		kcalloc(MAXBANDS, sizeof(struct brcms_hw_band), GFP_ATOMIC);
 	if (wlc->hw->bandstate[0] == NULL) {
 		*err = 1006;
 		goto fail;
@@ -521,7 +521,8 @@ brcms_c_attach_malloc(uint unit, uint *err, uint devid)
 	}
 
 	wlc->modulecb =
-		kzalloc(sizeof(struct modulecb) * BRCMS_MAXMODULES, GFP_ATOMIC);
+		kcalloc(BRCMS_MAXMODULES, sizeof(struct modulecb),
+			GFP_ATOMIC);
 	if (wlc->modulecb == NULL) {
 		*err = 1009;
 		goto fail;
@@ -553,7 +554,7 @@ brcms_c_attach_malloc(uint unit, uint *err, uint devid)
 	}
 
 	wlc->bandstate[0] =
-		kzalloc(sizeof(struct brcms_band)*MAXBANDS, GFP_ATOMIC);
+		kcalloc(MAXBANDS, sizeof(struct brcms_band), GFP_ATOMIC);
 	if (wlc->bandstate[0] == NULL) {
 		*err = 1025;
 		goto fail;
diff --git a/drivers/net/wireless/intel/iwlegacy/common.c b/drivers/net/wireless/intel/iwlegacy/common.c
index 8d5acda92a9b..f35c97caf29d 100644
--- a/drivers/net/wireless/intel/iwlegacy/common.c
+++ b/drivers/net/wireless/intel/iwlegacy/common.c
@@ -922,7 +922,7 @@ il_init_channel_map(struct il_priv *il)
 	D_EEPROM("Parsing data for %d channels.\n", il->channel_count);
 
 	il->channel_info =
-	    kzalloc(sizeof(struct il_channel_info) * il->channel_count,
+	    kcalloc(il->channel_count, sizeof(struct il_channel_info),
 		    GFP_KERNEL);
 	if (!il->channel_info) {
 		IL_ERR("Could not allocate channel_info\n");
@@ -3041,9 +3041,9 @@ il_tx_queue_init(struct il_priv *il, u32 txq_id)
 	}
 
 	txq->meta =
-	    kzalloc(sizeof(struct il_cmd_meta) * actual_slots, GFP_KERNEL);
+	    kcalloc(actual_slots, sizeof(struct il_cmd_meta), GFP_KERNEL);
 	txq->cmd =
-	    kzalloc(sizeof(struct il_device_cmd *) * actual_slots, GFP_KERNEL);
+	    kcalloc(actual_slots, sizeof(struct il_device_cmd *), GFP_KERNEL);
 
 	if (!txq->meta || !txq->cmd)
 		goto out_free_arrays;
@@ -3455,7 +3455,7 @@ il_init_geos(struct il_priv *il)
 	}
 
 	channels =
-	    kzalloc(sizeof(struct ieee80211_channel) * il->channel_count,
+	    kcalloc(il->channel_count, sizeof(struct ieee80211_channel),
 		    GFP_KERNEL);
 	if (!channels)
 		return -ENOMEM;
@@ -4654,8 +4654,9 @@ il_alloc_txq_mem(struct il_priv *il)
 {
 	if (!il->txq)
 		il->txq =
-		    kzalloc(sizeof(struct il_tx_queue) *
-			    il->cfg->num_of_queues, GFP_KERNEL);
+		    kcalloc(il->cfg->num_of_queues,
+			    sizeof(struct il_tx_queue),
+			    GFP_KERNEL);
 	if (!il->txq) {
 		IL_ERR("Not enough memory for txq\n");
 		return -ENOMEM;
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/scan.c b/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
index e4fd476e9ccb..c36096875c79 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
@@ -501,7 +501,7 @@ iwl_mvm_config_sched_scan_profiles(struct iwl_mvm *mvm,
 	else
 		blacklist_len = IWL_SCAN_MAX_BLACKLIST_LEN;
 
-	blacklist = kzalloc(sizeof(*blacklist) * blacklist_len, GFP_KERNEL);
+	blacklist = kcalloc(blacklist_len, sizeof(*blacklist), GFP_KERNEL);
 	if (!blacklist)
 		return -ENOMEM;
 
diff --git a/drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c b/drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c
index 274dd5a1574a..6da0088b3e3a 100644
--- a/drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c
+++ b/drivers/net/wireless/marvell/mwifiex/11n_rxreorder.c
@@ -399,8 +399,8 @@ mwifiex_11n_create_rx_reorder_tbl(struct mwifiex_private *priv, u8 *ta,
 
 	new_node->win_size = win_size;
 
-	new_node->rx_reorder_ptr = kzalloc(sizeof(void *) * win_size,
-					GFP_KERNEL);
+	new_node->rx_reorder_ptr = kcalloc(win_size, sizeof(void *),
+					   GFP_KERNEL);
 	if (!new_node->rx_reorder_ptr) {
 		kfree((u8 *) new_node);
 		mwifiex_dbg(priv->adapter, ERROR,
diff --git a/drivers/net/wireless/marvell/mwifiex/sdio.c b/drivers/net/wireless/marvell/mwifiex/sdio.c
index fd5183c10c4e..065c44636157 100644
--- a/drivers/net/wireless/marvell/mwifiex/sdio.c
+++ b/drivers/net/wireless/marvell/mwifiex/sdio.c
@@ -2094,15 +2094,16 @@ static int mwifiex_init_sdio(struct mwifiex_adapter *adapter)
 		return -ENOMEM;
 
 	/* Allocate skb pointer buffers */
-	card->mpa_rx.skb_arr = kzalloc((sizeof(void *)) *
-				       card->mp_agg_pkt_limit, GFP_KERNEL);
+	card->mpa_rx.skb_arr = kcalloc(card->mp_agg_pkt_limit, sizeof(void *),
+				       GFP_KERNEL);
 	if (!card->mpa_rx.skb_arr) {
 		kfree(card->mp_regs);
 		return -ENOMEM;
 	}
 
-	card->mpa_rx.len_arr = kzalloc(sizeof(*card->mpa_rx.len_arr) *
-				       card->mp_agg_pkt_limit, GFP_KERNEL);
+	card->mpa_rx.len_arr = kcalloc(card->mp_agg_pkt_limit,
+				       sizeof(*card->mpa_rx.len_arr),
+				       GFP_KERNEL);
 	if (!card->mpa_rx.len_arr) {
 		kfree(card->mp_regs);
 		kfree(card->mpa_rx.skb_arr);
diff --git a/drivers/net/wireless/p54/eeprom.c b/drivers/net/wireless/p54/eeprom.c
index d43e3740e45d..5b7b0a2ac495 100644
--- a/drivers/net/wireless/p54/eeprom.c
+++ b/drivers/net/wireless/p54/eeprom.c
@@ -162,8 +162,9 @@ static int p54_generate_band(struct ieee80211_hw *dev,
 	if (!tmp)
 		goto err_out;
 
-	tmp->channels = kzalloc(sizeof(struct ieee80211_channel) *
-				list->band_channel_num[band], GFP_KERNEL);
+	tmp->channels = kcalloc(list->band_channel_num[band],
+				sizeof(struct ieee80211_channel),
+				GFP_KERNEL);
 	if (!tmp->channels)
 		goto err_out;
 
@@ -345,7 +346,7 @@ static int p54_generate_channel_lists(struct ieee80211_hw *dev)
 		goto free;
 	}
 	priv->chan_num = max_channel_num;
-	priv->survey = kzalloc(sizeof(struct survey_info) * max_channel_num,
+	priv->survey = kcalloc(max_channel_num, sizeof(struct survey_info),
 			       GFP_KERNEL);
 	if (!priv->survey) {
 		ret = -ENOMEM;
@@ -353,8 +354,9 @@ static int p54_generate_channel_lists(struct ieee80211_hw *dev)
 	}
 
 	list->max_entries = max_channel_num;
-	list->channels = kzalloc(sizeof(struct p54_channel_entry) *
-				 max_channel_num, GFP_KERNEL);
+	list->channels = kcalloc(max_channel_num,
+				 sizeof(struct p54_channel_entry),
+				 GFP_KERNEL);
 	if (!list->channels) {
 		ret = -ENOMEM;
 		goto free;
diff --git a/drivers/net/wireless/prism54/oid_mgt.c b/drivers/net/wireless/prism54/oid_mgt.c
index 056af38e72e3..36d226cf98c6 100644
--- a/drivers/net/wireless/prism54/oid_mgt.c
+++ b/drivers/net/wireless/prism54/oid_mgt.c
@@ -245,7 +245,7 @@ mgt_init(islpci_private *priv)
 	/* Alloc the cache */
 	for (i = 0; i < OID_NUM_LAST; i++) {
 		if (isl_oid[i].flags & OID_FLAG_CACHED) {
-			priv->mib[i] = kzalloc(isl_oid[i].size *
+			priv->mib[i] = kcalloc(isl_oid[i].size,
 					       (isl_oid[i].range + 1),
 					       GFP_KERNEL);
 			if (!priv->mib[i])
* Unmerged path drivers/net/wireless/quantenna/qtnfmac/commands.c
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c b/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c
index 82d648b2642f..7c8e1a21c979 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c
@@ -396,7 +396,7 @@ static ssize_t rt2x00debug_read_crypto_stats(struct file *file,
 	if (*offset)
 		return 0;
 
-	data = kzalloc((1 + CIPHER_MAX) * MAX_LINE_LENGTH, GFP_KERNEL);
+	data = kcalloc(1 + CIPHER_MAX, MAX_LINE_LENGTH, GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
diff --git a/drivers/net/wireless/realtek/rtlwifi/efuse.c b/drivers/net/wireless/realtek/rtlwifi/efuse.c
index ef9acd466cca..8ad6aa373de3 100644
--- a/drivers/net/wireless/realtek/rtlwifi/efuse.c
+++ b/drivers/net/wireless/realtek/rtlwifi/efuse.c
@@ -253,8 +253,8 @@ void read_efuse(struct ieee80211_hw *hw, u16 _offset, u16 _size_byte, u8 *pbuf)
 	}
 
 	/* allocate memory for efuse_tbl and efuse_word */
-	efuse_tbl = kzalloc(rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE] *
-			    sizeof(u8), GFP_ATOMIC);
+	efuse_tbl = kzalloc(rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE],
+			    GFP_ATOMIC);
 	if (!efuse_tbl)
 		return;
 	efuse_word = kzalloc(EFUSE_MAX_WORD_UNIT * sizeof(u16 *), GFP_ATOMIC);
diff --git a/drivers/net/wireless/realtek/rtlwifi/usb.c b/drivers/net/wireless/realtek/rtlwifi/usb.c
index 5590d07d0918..1da1a1f022f9 100644
--- a/drivers/net/wireless/realtek/rtlwifi/usb.c
+++ b/drivers/net/wireless/realtek/rtlwifi/usb.c
@@ -1066,7 +1066,7 @@ int rtl_usb_probe(struct usb_interface *intf,
 	}
 	rtlpriv = hw->priv;
 	rtlpriv->hw = hw;
-	rtlpriv->usb_data = kzalloc(RTL_USB_MAX_RX_COUNT * sizeof(u32),
+	rtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32),
 				    GFP_KERNEL);
 	if (!rtlpriv->usb_data)
 		return -ENOMEM;
* Unmerged path drivers/net/wireless/st/cw1200/queue.c
* Unmerged path drivers/net/wireless/st/cw1200/scan.c
* Unmerged path drivers/nvmem/rockchip-efuse.c
* Unmerged path drivers/nvmem/sunxi_sid.c
diff --git a/drivers/of/platform.c b/drivers/of/platform.c
index b71c13b4d3bc..daa102fb6fa2 100644
--- a/drivers/of/platform.c
+++ b/drivers/of/platform.c
@@ -144,7 +144,7 @@ struct platform_device *of_device_alloc(struct device_node *np,
 
 	/* Populate the resource table */
 	if (num_irq || num_reg) {
-		res = kzalloc(sizeof(*res) * (num_irq + num_reg), GFP_KERNEL);
+		res = kcalloc(num_irq + num_reg, sizeof(*res), GFP_KERNEL);
 		if (!res) {
 			platform_device_put(dev);
 			return NULL;
* Unmerged path drivers/of/unittest.c
* Unmerged path drivers/opp/ti-opp-supply.c
diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c
index f5a53c7f5bcf..024c16579215 100644
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@ -514,7 +514,7 @@ static int populate_msi_sysfs(struct pci_dev *pdev)
 		return 0;
 
 	/* Dynamically create the MSI attributes for the PCI device */
-	msi_attrs = kzalloc(sizeof(void *) * (num_msi + 1), GFP_KERNEL);
+	msi_attrs = kcalloc(num_msi + 1, sizeof(void *), GFP_KERNEL);
 	if (!msi_attrs)
 		return -ENOMEM;
 	list_for_each_entry(entry, &pdev->msi_list, list) {
@@ -541,7 +541,7 @@ static int populate_msi_sysfs(struct pci_dev *pdev)
 	msi_irq_group->name = "msi_irqs";
 	msi_irq_group->attrs = msi_attrs;
 
-	msi_irq_groups = kzalloc(sizeof(void *) * 2, GFP_KERNEL);
+	msi_irq_groups = kcalloc(2, sizeof(void *), GFP_KERNEL);
 	if (!msi_irq_groups)
 		goto error_irq_group;
 	msi_irq_groups[0] = msi_irq_group;
diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c
index 8b7b99b7e9dc..6c2e5196cee0 100644
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@ -1056,7 +1056,7 @@ void pci_create_legacy_files(struct pci_bus *b)
 {
 	int error;
 
-	b->legacy_io = kzalloc(sizeof(struct bin_attribute) * 2,
+	b->legacy_io = kcalloc(2, sizeof(struct bin_attribute),
 			       GFP_ATOMIC);
 	if (!b->legacy_io)
 		goto kzalloc_err;
diff --git a/drivers/pcmcia/pd6729.c b/drivers/pcmcia/pd6729.c
index 14434b9ef374..8cd3e9ad967c 100644
--- a/drivers/pcmcia/pd6729.c
+++ b/drivers/pcmcia/pd6729.c
@@ -628,7 +628,7 @@ static int pd6729_pci_probe(struct pci_dev *dev,
 	char configbyte;
 	struct pd6729_socket *socket;
 
-	socket = kzalloc(sizeof(struct pd6729_socket) * MAX_SOCKETS,
+	socket = kcalloc(MAX_SOCKETS, sizeof(struct pd6729_socket),
 			 GFP_KERNEL);
 	if (!socket) {
 		dev_warn(&dev->dev, "failed to kzalloc socket.\n");
diff --git a/drivers/pinctrl/pinctrl-bcm2835.c b/drivers/pinctrl/pinctrl-bcm2835.c
index c8f20a3d8f88..88062a24cc82 100644
--- a/drivers/pinctrl/pinctrl-bcm2835.c
+++ b/drivers/pinctrl/pinctrl-bcm2835.c
@@ -750,8 +750,8 @@ static int bcm2835_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,
 		maps_per_pin++;
 	if (num_pulls)
 		maps_per_pin++;
-	cur_map = maps = kzalloc(num_pins * maps_per_pin * sizeof(*maps),
-				GFP_KERNEL);
+	cur_map = maps = kcalloc(num_pins * maps_per_pin, sizeof(*maps),
+				 GFP_KERNEL);
 	if (!maps)
 		return -ENOMEM;
 
diff --git a/drivers/pinctrl/pinctrl-lantiq.c b/drivers/pinctrl/pinctrl-lantiq.c
index dfac2299007b..077a195e391d 100644
--- a/drivers/pinctrl/pinctrl-lantiq.c
+++ b/drivers/pinctrl/pinctrl-lantiq.c
@@ -158,7 +158,8 @@ static int ltq_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,
 
 	for_each_child_of_node(np_config, np)
 		max_maps += ltq_pinctrl_dt_subnode_size(np);
-	*map = kzalloc(max_maps * sizeof(struct pinctrl_map) * 2, GFP_KERNEL);
+	*map = kzalloc(array3_size(max_maps, sizeof(struct pinctrl_map), 2),
+		       GFP_KERNEL);
 	if (!*map)
 		return -ENOMEM;
 	tmp = *map;
diff --git a/drivers/pinctrl/pinctrl-mxs.c b/drivers/pinctrl/pinctrl-mxs.c
index b45c4eb35798..7f664018921b 100644
--- a/drivers/pinctrl/pinctrl-mxs.c
+++ b/drivers/pinctrl/pinctrl-mxs.c
@@ -97,7 +97,7 @@ static int mxs_dt_node_to_map(struct pinctrl_dev *pctldev,
 	if (!purecfg && config)
 		new_num = 2;
 
-	new_map = kzalloc(sizeof(*new_map) * new_num, GFP_KERNEL);
+	new_map = kcalloc(new_num, sizeof(*new_map), GFP_KERNEL);
 	if (!new_map)
 		return -ENOMEM;
 
* Unmerged path drivers/pinctrl/sirf/pinctrl-sirf.c
diff --git a/drivers/pinctrl/spear/pinctrl-spear.c b/drivers/pinctrl/spear/pinctrl-spear.c
index 3f24f2fa7236..7a88b8c5bf81 100644
--- a/drivers/pinctrl/spear/pinctrl-spear.c
+++ b/drivers/pinctrl/spear/pinctrl-spear.c
@@ -172,7 +172,7 @@ static int spear_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,
 		return -ENODEV;
 	}
 
-	*map = kzalloc(sizeof(**map) * count, GFP_KERNEL);
+	*map = kcalloc(count, sizeof(**map), GFP_KERNEL);
 	if (!*map)
 		return -ENOMEM;
 
* Unmerged path drivers/pinctrl/sunxi/pinctrl-sunxi.c
diff --git a/drivers/pinctrl/vt8500/pinctrl-wmt.c b/drivers/pinctrl/vt8500/pinctrl-wmt.c
index 6df6303b4749..4c33a1c14415 100644
--- a/drivers/pinctrl/vt8500/pinctrl-wmt.c
+++ b/drivers/pinctrl/vt8500/pinctrl-wmt.c
@@ -352,7 +352,7 @@ static int wmt_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,
 	if (num_pulls)
 		maps_per_pin++;
 
-	cur_map = maps = kzalloc(num_pins * maps_per_pin * sizeof(*maps),
+	cur_map = maps = kcalloc(num_pins * maps_per_pin, sizeof(*maps),
 				 GFP_KERNEL);
 	if (!maps)
 		return -ENOMEM;
* Unmerged path drivers/platform/x86/alienware-wmi.c
diff --git a/drivers/platform/x86/intel_ips.c b/drivers/platform/x86/intel_ips.c
index 101a97e75803..bdd63a8e961f 100644
--- a/drivers/platform/x86/intel_ips.c
+++ b/drivers/platform/x86/intel_ips.c
@@ -967,12 +967,12 @@ static int ips_monitor(void *data)
 	u16 *mcp_samples, *ctv1_samples, *ctv2_samples, *mch_samples;
 	u8 cur_seqno, last_seqno;
 
-	mcp_samples = kzalloc(sizeof(u16) * IPS_SAMPLE_COUNT, GFP_KERNEL);
-	ctv1_samples = kzalloc(sizeof(u16) * IPS_SAMPLE_COUNT, GFP_KERNEL);
-	ctv2_samples = kzalloc(sizeof(u16) * IPS_SAMPLE_COUNT, GFP_KERNEL);
-	mch_samples = kzalloc(sizeof(u16) * IPS_SAMPLE_COUNT, GFP_KERNEL);
-	cpu_samples = kzalloc(sizeof(u32) * IPS_SAMPLE_COUNT, GFP_KERNEL);
-	mchp_samples = kzalloc(sizeof(u32) * IPS_SAMPLE_COUNT, GFP_KERNEL);
+	mcp_samples = kcalloc(IPS_SAMPLE_COUNT, sizeof(u16), GFP_KERNEL);
+	ctv1_samples = kcalloc(IPS_SAMPLE_COUNT, sizeof(u16), GFP_KERNEL);
+	ctv2_samples = kcalloc(IPS_SAMPLE_COUNT, sizeof(u16), GFP_KERNEL);
+	mch_samples = kcalloc(IPS_SAMPLE_COUNT, sizeof(u16), GFP_KERNEL);
+	cpu_samples = kcalloc(IPS_SAMPLE_COUNT, sizeof(u32), GFP_KERNEL);
+	mchp_samples = kcalloc(IPS_SAMPLE_COUNT, sizeof(u32), GFP_KERNEL);
 	if (!mcp_samples || !ctv1_samples || !ctv2_samples || !mch_samples ||
 			!cpu_samples || !mchp_samples) {
 		dev_err(&ips->dev->dev,
diff --git a/drivers/platform/x86/panasonic-laptop.c b/drivers/platform/x86/panasonic-laptop.c
index 7aa6e7198d48..861cff6689b7 100644
--- a/drivers/platform/x86/panasonic-laptop.c
+++ b/drivers/platform/x86/panasonic-laptop.c
@@ -584,7 +584,7 @@ static int acpi_pcc_hotkey_add(struct acpi_device *device)
 		return -ENOMEM;
 	}
 
-	pcc->sinf = kzalloc(sizeof(u32) * (num_sifr + 1), GFP_KERNEL);
+	pcc->sinf = kcalloc(num_sifr + 1, sizeof(u32), GFP_KERNEL);
 	if (!pcc->sinf) {
 		result = -ENOMEM;
 		goto out_hotkey;
diff --git a/drivers/platform/x86/thinkpad_acpi.c b/drivers/platform/x86/thinkpad_acpi.c
index 2f2f9aae7c9f..8dc6917e0569 100644
--- a/drivers/platform/x86/thinkpad_acpi.c
+++ b/drivers/platform/x86/thinkpad_acpi.c
@@ -5887,7 +5887,7 @@ static int __init led_init(struct ibm_init_struct *iibm)
 	if (led_supported == TPACPI_LED_NONE)
 		return 1;
 
-	tpacpi_leds = kzalloc(sizeof(*tpacpi_leds) * TPACPI_LED_NUMLEDS,
+	tpacpi_leds = kcalloc(TPACPI_LED_NUMLEDS, sizeof(*tpacpi_leds),
 			      GFP_KERNEL);
 	if (!tpacpi_leds) {
 		pr_err("Out of memory for LED data\n");
diff --git a/drivers/power/wm97xx_battery.c b/drivers/power/wm97xx_battery.c
index 58f7348e6c22..0b1bcc4a6e08 100644
--- a/drivers/power/wm97xx_battery.c
+++ b/drivers/power/wm97xx_battery.c
@@ -211,7 +211,7 @@ static int wm97xx_bat_probe(struct platform_device *dev)
 	if (pdata->min_voltage >= 0)
 		props++;	/* POWER_SUPPLY_PROP_VOLTAGE_MIN */
 
-	prop = kzalloc(props * sizeof(*prop), GFP_KERNEL);
+	prop = kcalloc(props, sizeof(*prop), GFP_KERNEL);
 	if (!prop) {
 		ret = -ENOMEM;
 		goto err3;
diff --git a/drivers/power/z2_battery.c b/drivers/power/z2_battery.c
index 814d2e31f0c9..c1d0a53e12ed 100644
--- a/drivers/power/z2_battery.c
+++ b/drivers/power/z2_battery.c
@@ -145,7 +145,7 @@ static int z2_batt_ps_init(struct z2_charger *charger, int props)
 	if (info->min_voltage >= 0)
 		props++;	/* POWER_SUPPLY_PROP_VOLTAGE_MIN */
 
-	prop = kzalloc(props * sizeof(*prop), GFP_KERNEL);
+	prop = kcalloc(props, sizeof(*prop), GFP_KERNEL);
 	if (!prop)
 		return -ENOMEM;
 
diff --git a/drivers/powercap/powercap_sys.c b/drivers/powercap/powercap_sys.c
index 90ec0e205655..e7a2d3feba4f 100644
--- a/drivers/powercap/powercap_sys.c
+++ b/drivers/powercap/powercap_sys.c
@@ -537,15 +537,16 @@ struct powercap_zone *powercap_register_zone(
 	dev_set_name(&power_zone->dev, "%s:%x",
 					dev_name(power_zone->dev.parent),
 					power_zone->id);
-	power_zone->constraints = kzalloc(sizeof(*power_zone->constraints) *
-					 nr_constraints, GFP_KERNEL);
+	power_zone->constraints = kcalloc(nr_constraints,
+					  sizeof(*power_zone->constraints),
+					  GFP_KERNEL);
 	if (!power_zone->constraints)
 		goto err_const_alloc;
 
 	nr_attrs = nr_constraints * POWERCAP_CONSTRAINTS_ATTRS +
 						POWERCAP_ZONE_MAX_ATTRS + 1;
-	power_zone->zone_dev_attrs = kzalloc(sizeof(void *) *
-						nr_attrs, GFP_KERNEL);
+	power_zone->zone_dev_attrs = kcalloc(nr_attrs, sizeof(void *),
+					     GFP_KERNEL);
 	if (!power_zone->zone_dev_attrs)
 		goto err_attr_alloc;
 	create_power_zone_common_attributes(power_zone);
* Unmerged path drivers/rapidio/rio-scan.c
* Unmerged path drivers/regulator/s2mps11.c
diff --git a/drivers/s390/block/dcssblk.c b/drivers/s390/block/dcssblk.c
index 44a7bf955842..7742352083d3 100644
--- a/drivers/s390/block/dcssblk.c
+++ b/drivers/s390/block/dcssblk.c
@@ -238,9 +238,9 @@ dcssblk_is_continuous(struct dcssblk_dev_info *dev_info)
 	if (dev_info->num_of_segments <= 1)
 		return 0;
 
-	sort_list = kzalloc(
-			sizeof(struct segment_info) * dev_info->num_of_segments,
-			GFP_KERNEL);
+	sort_list = kcalloc(dev_info->num_of_segments,
+			    sizeof(struct segment_info),
+			    GFP_KERNEL);
 	if (sort_list == NULL)
 		return -ENOMEM;
 	i = 0;
diff --git a/drivers/s390/char/keyboard.c b/drivers/s390/char/keyboard.c
index 1c6270b7b15f..daef2096f4bd 100644
--- a/drivers/s390/char/keyboard.c
+++ b/drivers/s390/char/keyboard.c
@@ -77,7 +77,7 @@ kbd_alloc(void) {
 		}
 	}
 	kbd->fn_handler =
-		kzalloc(sizeof(fn_handler_fn *) * NR_FN_HANDLER, GFP_KERNEL);
+		kcalloc(NR_FN_HANDLER, sizeof(fn_handler_fn *), GFP_KERNEL);
 	if (!kbd->fn_handler)
 		goto out_func;
 	kbd->accent_table = kmemdup(ebc_accent_table,
diff --git a/drivers/s390/char/vmur.c b/drivers/s390/char/vmur.c
index 4c5c6e00be90..3ca49a3fe1f0 100644
--- a/drivers/s390/char/vmur.c
+++ b/drivers/s390/char/vmur.c
@@ -241,7 +241,7 @@ static struct ccw1 *alloc_chan_prog(const char __user *ubuf, int rec_count,
 	 * That means we allocate room for CCWs to cover count/reclen
 	 * records plus a NOP.
 	 */
-	cpa = kzalloc((rec_count + 1) * sizeof(struct ccw1),
+	cpa = kcalloc(rec_count + 1, sizeof(struct ccw1),
 		      GFP_KERNEL | GFP_DMA);
 	if (!cpa)
 		return ERR_PTR(-ENOMEM);
* Unmerged path drivers/s390/char/zcore.c
diff --git a/drivers/s390/cio/qdio_setup.c b/drivers/s390/cio/qdio_setup.c
index 09ecb9c1457e..565d10d705ff 100644
--- a/drivers/s390/cio/qdio_setup.c
+++ b/drivers/s390/cio/qdio_setup.c
@@ -490,7 +490,7 @@ void qdio_print_subchannel_info(struct qdio_irq *irq_ptr,
 
 int qdio_enable_async_operation(struct qdio_output_q *outq)
 {
-	outq->aobs = kzalloc(sizeof(struct qaob *) * QDIO_MAX_BUFFERS_PER_Q,
+	outq->aobs = kcalloc(QDIO_MAX_BUFFERS_PER_Q, sizeof(struct qaob *),
 			     GFP_ATOMIC);
 	if (!outq->aobs) {
 		outq->use_cq = 0;
diff --git a/drivers/s390/cio/qdio_thinint.c b/drivers/s390/cio/qdio_thinint.c
index 30e9fbbff051..75d6ec22b774 100644
--- a/drivers/s390/cio/qdio_thinint.c
+++ b/drivers/s390/cio/qdio_thinint.c
@@ -243,8 +243,9 @@ out:
 /* allocate non-shared indicators and shared indicator */
 int __init tiqdio_allocate_memory(void)
 {
-	q_indicators = kzalloc(sizeof(struct indicator_t) * TIQDIO_NR_INDICATORS,
-			     GFP_KERNEL);
+	q_indicators = kcalloc(TIQDIO_NR_INDICATORS,
+			       sizeof(struct indicator_t),
+			       GFP_KERNEL);
 	if (!q_indicators)
 		return -ENOMEM;
 	return 0;
* Unmerged path drivers/s390/crypto/pkey_api.c
diff --git a/drivers/s390/net/ctcm_main.c b/drivers/s390/net/ctcm_main.c
index 49c4dc04f705..f9756a019db6 100644
--- a/drivers/s390/net/ctcm_main.c
+++ b/drivers/s390/net/ctcm_main.c
@@ -1377,7 +1377,7 @@ static int add_channel(struct ccw_device *cdev, enum ctcm_channel_types type,
 	} else
 		ccw_num = 8;
 
-	ch->ccw = kzalloc(ccw_num * sizeof(struct ccw1), GFP_KERNEL | GFP_DMA);
+	ch->ccw = kcalloc(ccw_num, sizeof(struct ccw1), GFP_KERNEL | GFP_DMA);
 	if (ch->ccw == NULL)
 					goto nomem_return;
 
diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c
index 88e60ed5028a..7bad63f436c7 100644
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -339,9 +339,10 @@ static inline int qeth_alloc_cq(struct qeth_card *card)
 		card->qdio.no_in_queues = 2;
 
 		card->qdio.out_bufstates =
-			kzalloc(card->qdio.no_out_queues *
-				QDIO_MAX_BUFFERS_PER_Q *
-				sizeof(struct qdio_outbuf_state), GFP_KERNEL);
+			kcalloc(card->qdio.no_out_queues *
+					QDIO_MAX_BUFFERS_PER_Q,
+				sizeof(struct qdio_outbuf_state),
+				GFP_KERNEL);
 		outbuf_states = card->qdio.out_bufstates;
 		if (outbuf_states == NULL) {
 			rc = -1;
@@ -2461,8 +2462,9 @@ static int qeth_alloc_qdio_buffers(struct qeth_card *card)
 
 	/* outbound */
 	card->qdio.out_qs =
-		kzalloc(card->qdio.no_out_queues *
-			sizeof(struct qeth_qdio_out_q *), GFP_KERNEL);
+		kcalloc(card->qdio.no_out_queues,
+			sizeof(struct qeth_qdio_out_q *),
+			GFP_KERNEL);
 	if (!card->qdio.out_qs)
 		goto out_freepool;
 	for (i = 0; i < card->qdio.no_out_queues; ++i) {
@@ -4866,8 +4868,8 @@ static int qeth_qdio_establish(struct qeth_card *card)
 
 	QETH_DBF_TEXT(SETUP, 2, "qdioest");
 
-	qib_param_field = kzalloc(QDIO_MAX_BUFFERS_PER_Q * sizeof(char),
-			      GFP_KERNEL);
+	qib_param_field = kzalloc(QDIO_MAX_BUFFERS_PER_Q,
+				  GFP_KERNEL);
 	if (!qib_param_field) {
 		rc =  -ENOMEM;
 		goto out_free_nothing;
@@ -4876,8 +4878,8 @@ static int qeth_qdio_establish(struct qeth_card *card)
 	qeth_create_qib_param_field(card, qib_param_field);
 	qeth_create_qib_param_field_blkt(card, qib_param_field);
 
-	in_sbal_ptrs = kzalloc(card->qdio.no_in_queues *
-			       QDIO_MAX_BUFFERS_PER_Q * sizeof(void *),
+	in_sbal_ptrs = kcalloc(card->qdio.no_in_queues * QDIO_MAX_BUFFERS_PER_Q,
+			       sizeof(void *),
 			       GFP_KERNEL);
 	if (!in_sbal_ptrs) {
 		rc = -ENOMEM;
@@ -4888,7 +4890,7 @@ static int qeth_qdio_establish(struct qeth_card *card)
 			virt_to_phys(card->qdio.in_q->bufs[i].buffer);
 	}
 
-	queue_start_poll = kzalloc(sizeof(void *) * card->qdio.no_in_queues,
+	queue_start_poll = kcalloc(card->qdio.no_in_queues, sizeof(void *),
 				   GFP_KERNEL);
 	if (!queue_start_poll) {
 		rc = -ENOMEM;
@@ -4900,8 +4902,9 @@ static int qeth_qdio_establish(struct qeth_card *card)
 	qeth_qdio_establish_cq(card, in_sbal_ptrs, queue_start_poll);
 
 	out_sbal_ptrs =
-		kzalloc(card->qdio.no_out_queues * QDIO_MAX_BUFFERS_PER_Q *
-			sizeof(void *), GFP_KERNEL);
+		kcalloc(card->qdio.no_out_queues * QDIO_MAX_BUFFERS_PER_Q,
+			sizeof(void *),
+			GFP_KERNEL);
 	if (!out_sbal_ptrs) {
 		rc = -ENOMEM;
 		goto out_free_queue_start_poll;
* Unmerged path drivers/scsi/BusLogic.c
diff --git a/drivers/scsi/aacraid/linit.c b/drivers/scsi/aacraid/linit.c
index 46240762f5ab..71495e4938d1 100644
--- a/drivers/scsi/aacraid/linit.c
+++ b/drivers/scsi/aacraid/linit.c
@@ -1788,7 +1788,9 @@ static int aac_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (aac_reset_devices || reset_devices)
 		aac->init_reset = true;
 
-	aac->fibs = kzalloc(sizeof(struct fib) * (shost->can_queue + AAC_NUM_MGT_FIB), GFP_KERNEL);
+	aac->fibs = kcalloc(shost->can_queue + AAC_NUM_MGT_FIB,
+			    sizeof(struct fib),
+			    GFP_KERNEL);
 	if (!aac->fibs)
 		goto out_free_host;
 	spin_lock_init(&aac->fib_lock);
* Unmerged path drivers/scsi/aic7xxx/aic7xxx_core.c
diff --git a/drivers/scsi/aic94xx/aic94xx_hwi.c b/drivers/scsi/aic94xx/aic94xx_hwi.c
index 9f636a34d595..b9a6d331e65e 100644
--- a/drivers/scsi/aic94xx/aic94xx_hwi.c
+++ b/drivers/scsi/aic94xx/aic94xx_hwi.c
@@ -220,8 +220,9 @@ static int asd_init_scbs(struct asd_ha_struct *asd_ha)
 
 	/* allocate the index array and bitmap */
 	asd_ha->seq.tc_index_bitmap_bits = asd_ha->hw_prof.max_scbs;
-	asd_ha->seq.tc_index_array = kzalloc(asd_ha->seq.tc_index_bitmap_bits*
-					     sizeof(void *), GFP_KERNEL);
+	asd_ha->seq.tc_index_array = kcalloc(asd_ha->seq.tc_index_bitmap_bits,
+					     sizeof(void *),
+					     GFP_KERNEL);
 	if (!asd_ha->seq.tc_index_array)
 		return -ENOMEM;
 
diff --git a/drivers/scsi/aic94xx/aic94xx_init.c b/drivers/scsi/aic94xx/aic94xx_init.c
index e633d4ca83b9..01557483a2e7 100644
--- a/drivers/scsi/aic94xx/aic94xx_init.c
+++ b/drivers/scsi/aic94xx/aic94xx_init.c
@@ -355,7 +355,7 @@ static ssize_t asd_store_update_bios(struct device *dev,
 	int flash_command = FLASH_CMD_NONE;
 	int err = 0;
 
-	cmd_ptr = kzalloc(count*2, GFP_KERNEL);
+	cmd_ptr = kcalloc(count, 2, GFP_KERNEL);
 
 	if (!cmd_ptr) {
 		err = FAIL_OUT_MEMORY;
diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index 8451c95ff857..115442793e57 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -2468,8 +2468,8 @@ static int beiscsi_alloc_mem(struct beiscsi_hba *phba)
 
 	/* Allocate memory for wrb_context */
 	phwi_ctrlr = phba->phwi_ctrlr;
-	phwi_ctrlr->wrb_context = kzalloc(sizeof(struct hwi_wrb_context) *
-					  phba->params.cxns_per_ctrl,
+	phwi_ctrlr->wrb_context = kcalloc(phba->params.cxns_per_ctrl,
+					  sizeof(struct hwi_wrb_context),
 					  GFP_KERNEL);
 	if (!phwi_ctrlr->wrb_context) {
 		kfree(phba->phwi_ctrlr);
@@ -2621,8 +2621,8 @@ static int beiscsi_init_wrb_handle(struct beiscsi_hba *phba)
 
 	/* Allocate memory for WRBQ */
 	phwi_ctxt = phwi_ctrlr->phwi_ctxt;
-	phwi_ctxt->be_wrbq = kzalloc(sizeof(struct be_queue_info) *
-				     phba->params.cxns_per_ctrl,
+	phwi_ctxt->be_wrbq = kcalloc(phba->params.cxns_per_ctrl,
+				     sizeof(struct be_queue_info),
 				     GFP_KERNEL);
 	if (!phwi_ctxt->be_wrbq) {
 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
@@ -2633,16 +2633,18 @@ static int beiscsi_init_wrb_handle(struct beiscsi_hba *phba)
 	for (index = 0; index < phba->params.cxns_per_ctrl; index++) {
 		pwrb_context = &phwi_ctrlr->wrb_context[index];
 		pwrb_context->pwrb_handle_base =
-				kzalloc(sizeof(struct wrb_handle *) *
-					phba->params.wrbs_per_cxn, GFP_KERNEL);
+				kcalloc(phba->params.wrbs_per_cxn,
+					sizeof(struct wrb_handle *),
+					GFP_KERNEL);
 		if (!pwrb_context->pwrb_handle_base) {
 			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 				    "BM_%d : Mem Alloc Failed. Failing to load\n");
 			goto init_wrb_hndl_failed;
 		}
 		pwrb_context->pwrb_handle_basestd =
-				kzalloc(sizeof(struct wrb_handle *) *
-					phba->params.wrbs_per_cxn, GFP_KERNEL);
+				kcalloc(phba->params.wrbs_per_cxn,
+					sizeof(struct wrb_handle *),
+					GFP_KERNEL);
 		if (!pwrb_context->pwrb_handle_basestd) {
 			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 				    "BM_%d : Mem Alloc Failed. Failing to load\n");
@@ -3896,18 +3898,18 @@ static int beiscsi_init_sgl_handle(struct beiscsi_hba *phba)
 	mem_descr_sglh = phba->init_mem;
 	mem_descr_sglh += HWI_MEM_SGLH;
 	if (1 == mem_descr_sglh->num_elements) {
-		phba->io_sgl_hndl_base = kzalloc(sizeof(struct sgl_handle *) *
-						 phba->params.ios_per_ctrl,
+		phba->io_sgl_hndl_base = kcalloc(phba->params.ios_per_ctrl,
+						 sizeof(struct sgl_handle *),
 						 GFP_KERNEL);
 		if (!phba->io_sgl_hndl_base) {
 			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 				    "BM_%d : Mem Alloc Failed. Failing to load\n");
 			return -ENOMEM;
 		}
-		phba->eh_sgl_hndl_base = kzalloc(sizeof(struct sgl_handle *) *
-						 (phba->params.icds_per_ctrl -
-						 phba->params.ios_per_ctrl),
-						 GFP_KERNEL);
+		phba->eh_sgl_hndl_base =
+			kcalloc(phba->params.icds_per_ctrl -
+					phba->params.ios_per_ctrl,
+				sizeof(struct sgl_handle *), GFP_KERNEL);
 		if (!phba->eh_sgl_hndl_base) {
 			kfree(phba->io_sgl_hndl_base);
 			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
@@ -4034,8 +4036,9 @@ static int hba_setup_cid_tbls(struct beiscsi_hba *phba)
 			phba->cid_array_info[ulp_num] = ptr_cid_info;
 		}
 	}
-	phba->ep_array = kzalloc(sizeof(struct iscsi_endpoint *) *
-				 phba->params.cxns_per_ctrl, GFP_KERNEL);
+	phba->ep_array = kcalloc(phba->params.cxns_per_ctrl,
+				 sizeof(struct iscsi_endpoint *),
+				 GFP_KERNEL);
 	if (!phba->ep_array) {
 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 			    "BM_%d : Failed to allocate memory in "
@@ -4045,8 +4048,9 @@ static int hba_setup_cid_tbls(struct beiscsi_hba *phba)
 		goto free_memory;
 	}
 
-	phba->conn_table = kzalloc(sizeof(struct beiscsi_conn *) *
-				   phba->params.cxns_per_ctrl, GFP_KERNEL);
+	phba->conn_table = kcalloc(phba->params.cxns_per_ctrl,
+				   sizeof(struct beiscsi_conn *),
+				   GFP_KERNEL);
 	if (!phba->conn_table) {
 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 			    "BM_%d : Failed to allocate memory in"
diff --git a/drivers/scsi/bfa/bfad_attr.c b/drivers/scsi/bfa/bfad_attr.c
index 13db3b7bc873..54e4614efdf2 100644
--- a/drivers/scsi/bfa/bfad_attr.c
+++ b/drivers/scsi/bfa/bfad_attr.c
@@ -930,7 +930,7 @@ bfad_im_num_of_discovered_ports_show(struct device *dev,
 	struct bfa_rport_qualifier_s *rports = NULL;
 	unsigned long   flags;
 
-	rports = kzalloc(sizeof(struct bfa_rport_qualifier_s) * nrports,
+	rports = kcalloc(nrports, sizeof(struct bfa_rport_qualifier_s),
 			 GFP_ATOMIC);
 	if (rports == NULL)
 		return snprintf(buf, PAGE_SIZE, "Failed\n");
diff --git a/drivers/scsi/bfa/bfad_bsg.c b/drivers/scsi/bfa/bfad_bsg.c
index daad88226ea4..d50551bb7274 100644
--- a/drivers/scsi/bfa/bfad_bsg.c
+++ b/drivers/scsi/bfa/bfad_bsg.c
@@ -3258,8 +3258,9 @@ bfad_fcxp_map_sg(struct bfad_s *bfad, void *payload_kbuf,
 	struct bfa_sge_s	*sg_table;
 	int sge_num = 1;
 
-	buf_base = kzalloc((sizeof(struct bfad_buf_info) +
-			   sizeof(struct bfa_sge_s)) * sge_num, GFP_KERNEL);
+	buf_base = kcalloc(sizeof(struct bfad_buf_info) +
+				sizeof(struct bfa_sge_s),
+			   sge_num, GFP_KERNEL);
 	if (!buf_base)
 		return NULL;
 
diff --git a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
index 0654fc8b2b81..82b9939f753a 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_fcoe.c
@@ -1398,7 +1398,7 @@ static struct bnx2fc_hba *bnx2fc_hba_create(struct cnic_dev *cnic)
 	hba->next_conn_id = 0;
 
 	hba->tgt_ofld_list =
-		kzalloc(sizeof(struct bnx2fc_rport *) * BNX2FC_NUM_MAX_SESS,
+		kcalloc(BNX2FC_NUM_MAX_SESS, sizeof(struct bnx2fc_rport *),
 			GFP_KERNEL);
 	if (!hba->tgt_ofld_list) {
 		printk(KERN_ERR PFX "Unable to allocate tgt offload list\n");
diff --git a/drivers/scsi/bnx2fc/bnx2fc_io.c b/drivers/scsi/bnx2fc/bnx2fc_io.c
index 5dc3d3b54416..d79cc8c88bb4 100644
--- a/drivers/scsi/bnx2fc/bnx2fc_io.c
+++ b/drivers/scsi/bnx2fc/bnx2fc_io.c
@@ -240,15 +240,15 @@ struct bnx2fc_cmd_mgr *bnx2fc_cmd_mgr_alloc(struct bnx2fc_hba *hba)
 		return NULL;
 	}
 
-	cmgr->free_list = kzalloc(sizeof(*cmgr->free_list) *
-				  arr_sz, GFP_KERNEL);
+	cmgr->free_list = kcalloc(arr_sz, sizeof(*cmgr->free_list),
+				  GFP_KERNEL);
 	if (!cmgr->free_list) {
 		printk(KERN_ERR PFX "failed to alloc free_list\n");
 		goto mem_err;
 	}
 
-	cmgr->free_list_lock = kzalloc(sizeof(*cmgr->free_list_lock) *
-				       arr_sz, GFP_KERNEL);
+	cmgr->free_list_lock = kcalloc(arr_sz, sizeof(*cmgr->free_list_lock),
+				       GFP_KERNEL);
 	if (!cmgr->free_list_lock) {
 		printk(KERN_ERR PFX "failed to alloc free_list_lock\n");
 		kfree(cmgr->free_list);
diff --git a/drivers/scsi/csiostor/csio_wr.c b/drivers/scsi/csiostor/csio_wr.c
index c44a1af23fd2..36eff7a283dc 100644
--- a/drivers/scsi/csiostor/csio_wr.c
+++ b/drivers/scsi/csiostor/csio_wr.c
@@ -283,7 +283,7 @@ csio_wr_alloc_q(struct csio_hw *hw, uint32_t qsize, uint32_t wrsize,
 			q->un.iq.flq_idx = flq_idx;
 
 			flq = wrm->q_arr[q->un.iq.flq_idx];
-			flq->un.fl.bufs = kzalloc(flq->credits *
+			flq->un.fl.bufs = kcalloc(flq->credits,
 						  sizeof(struct csio_dma_buf),
 						  GFP_KERNEL);
 			if (!flq->un.fl.bufs) {
@@ -1659,7 +1659,7 @@ csio_wrm_init(struct csio_wrm *wrm, struct csio_hw *hw)
 		return -EINVAL;
 	}
 
-	wrm->q_arr = kzalloc(sizeof(struct csio_q *) * wrm->num_q, GFP_KERNEL);
+	wrm->q_arr = kcalloc(wrm->num_q, sizeof(struct csio_q *), GFP_KERNEL);
 	if (!wrm->q_arr)
 		goto err;
 
* Unmerged path drivers/scsi/esas2r/esas2r_init.c
diff --git a/drivers/scsi/hpsa.c b/drivers/scsi/hpsa.c
index 76507e2c820f..783b3f8aab4c 100644
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@ -1887,8 +1887,8 @@ static void adjust_hpsa_scsi_table(struct ctlr_info *h,
 	}
 	spin_unlock_irqrestore(&h->reset_lock, flags);
 
-	added = kzalloc(sizeof(*added) * HPSA_MAX_DEVICES, GFP_KERNEL);
-	removed = kzalloc(sizeof(*removed) * HPSA_MAX_DEVICES, GFP_KERNEL);
+	added = kcalloc(HPSA_MAX_DEVICES, sizeof(*added), GFP_KERNEL);
+	removed = kcalloc(HPSA_MAX_DEVICES, sizeof(*removed), GFP_KERNEL);
 
 	if (!added || !removed) {
 		dev_warn(&h->pdev->dev, "out of memory in "
@@ -2140,7 +2140,7 @@ static int hpsa_allocate_ioaccel2_sg_chain_blocks(struct ctlr_info *h)
 		return 0;
 
 	h->ioaccel2_cmd_sg_list =
-		kzalloc(sizeof(*h->ioaccel2_cmd_sg_list) * h->nr_cmds,
+		kcalloc(h->nr_cmds, sizeof(*h->ioaccel2_cmd_sg_list),
 					GFP_KERNEL);
 	if (!h->ioaccel2_cmd_sg_list)
 		return -ENOMEM;
@@ -2179,8 +2179,8 @@ static int hpsa_alloc_sg_chain_blocks(struct ctlr_info *h)
 	if (h->chainsize <= 0)
 		return 0;
 
-	h->cmd_sg_list = kzalloc(sizeof(*h->cmd_sg_list) * h->nr_cmds,
-				GFP_KERNEL);
+	h->cmd_sg_list = kcalloc(h->nr_cmds, sizeof(*h->cmd_sg_list),
+				 GFP_KERNEL);
 	if (!h->cmd_sg_list)
 		return -ENOMEM;
 
@@ -4275,7 +4275,7 @@ static void hpsa_update_scsi_devices(struct ctlr_info *h)
 	bool physical_device;
 	DECLARE_BITMAP(lunzerobits, MAX_EXT_TARGETS);
 
-	currentsd = kzalloc(sizeof(*currentsd) * HPSA_MAX_DEVICES, GFP_KERNEL);
+	currentsd = kcalloc(HPSA_MAX_DEVICES, sizeof(*currentsd), GFP_KERNEL);
 	physdev_list = kzalloc(sizeof(*physdev_list), GFP_KERNEL);
 	logdev_list = kzalloc(sizeof(*logdev_list), GFP_KERNEL);
 	tmpdevice = kzalloc(sizeof(*tmpdevice), GFP_KERNEL);
@@ -6380,7 +6380,7 @@ static int hpsa_big_passthru_ioctl(struct ctlr_info *h, void __user *argp)
 		status = -EINVAL;
 		goto cleanup1;
 	}
-	buff = kzalloc(SG_ENTRIES_IN_CMD * sizeof(char *), GFP_KERNEL);
+	buff = kcalloc(SG_ENTRIES_IN_CMD, sizeof(char *), GFP_KERNEL);
 	if (!buff) {
 		status = -ENOMEM;
 		goto cleanup1;
@@ -7906,9 +7906,9 @@ static void hpsa_free_cmd_pool(struct ctlr_info *h)
 
 static int hpsa_alloc_cmd_pool(struct ctlr_info *h)
 {
-	h->cmd_pool_bits = kzalloc(
-		DIV_ROUND_UP(h->nr_cmds, BITS_PER_LONG) *
-		sizeof(unsigned long), GFP_KERNEL);
+	h->cmd_pool_bits = kcalloc(DIV_ROUND_UP(h->nr_cmds, BITS_PER_LONG),
+				   sizeof(unsigned long),
+				   GFP_KERNEL);
 	h->cmd_pool = pci_alloc_consistent(h->pdev,
 		    h->nr_cmds * sizeof(*h->cmd_pool),
 		    &(h->cmd_pool_dhandle));
@@ -8482,7 +8482,7 @@ static struct ctlr_info *hpda_alloc_ctlr_info(void)
 	if (!h)
 		return NULL;
 
-	h->reply_map = kzalloc(sizeof(*h->reply_map) * nr_cpu_ids, GFP_KERNEL);
+	h->reply_map = kcalloc(nr_cpu_ids, sizeof(*h->reply_map), GFP_KERNEL);
 	if (!h->reply_map) {
 		kfree(h);
 		return NULL;
diff --git a/drivers/scsi/ipr.c b/drivers/scsi/ipr.c
index a0d821d6f5ec..ec56afce91ac 100644
--- a/drivers/scsi/ipr.c
+++ b/drivers/scsi/ipr.c
@@ -9868,8 +9868,9 @@ static int ipr_alloc_mem(struct ipr_ioa_cfg *ioa_cfg)
 	int i, rc = -ENOMEM;
 
 	ENTER;
-	ioa_cfg->res_entries = kzalloc(sizeof(struct ipr_resource_entry) *
-				       ioa_cfg->max_devs_supported, GFP_KERNEL);
+	ioa_cfg->res_entries = kcalloc(ioa_cfg->max_devs_supported,
+				       sizeof(struct ipr_resource_entry),
+				       GFP_KERNEL);
 
 	if (!ioa_cfg->res_entries)
 		goto out;
@@ -9926,8 +9927,9 @@ static int ipr_alloc_mem(struct ipr_ioa_cfg *ioa_cfg)
 		list_add_tail(&ioa_cfg->hostrcb[i]->queue, &ioa_cfg->hostrcb_free_q);
 	}
 
-	ioa_cfg->trace = kzalloc(sizeof(struct ipr_trace_entry) *
-				 IPR_NUM_TRACE_ENTRIES, GFP_KERNEL);
+	ioa_cfg->trace = kcalloc(IPR_NUM_TRACE_ENTRIES,
+				 sizeof(struct ipr_trace_entry),
+				 GFP_KERNEL);
 
 	if (!ioa_cfg->trace)
 		goto out_free_hostrcb_dma;
diff --git a/drivers/scsi/libsas/sas_expander.c b/drivers/scsi/libsas/sas_expander.c
index 70c62bb8db3e..a92bc4fc9b1b 100644
--- a/drivers/scsi/libsas/sas_expander.c
+++ b/drivers/scsi/libsas/sas_expander.c
@@ -431,7 +431,7 @@ static int sas_expander_discover(struct domain_device *dev)
 	struct expander_device *ex = &dev->ex_dev;
 	int res = -ENOMEM;
 
-	ex->ex_phy = kzalloc(sizeof(*ex->ex_phy)*ex->num_phys, GFP_KERNEL);
+	ex->ex_phy = kcalloc(ex->num_phys, sizeof(*ex->ex_phy), GFP_KERNEL);
 	if (!ex->ex_phy)
 		return -ENOMEM;
 
diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c
index 627f7716d6d1..0acfd42e9bc8 100644
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@ -5780,8 +5780,9 @@ lpfc_sli_driver_resource_setup(struct lpfc_hba *phba)
 	}
 
 	if (!phba->sli.sli3_ring)
-		phba->sli.sli3_ring = kzalloc(LPFC_SLI3_MAX_RING *
-			sizeof(struct lpfc_sli_ring), GFP_KERNEL);
+		phba->sli.sli3_ring = kcalloc(LPFC_SLI3_MAX_RING,
+					      sizeof(struct lpfc_sli_ring),
+					      GFP_KERNEL);
 	if (!phba->sli.sli3_ring)
 		return -ENOMEM;
 
@@ -6312,7 +6313,7 @@ lpfc_sli4_driver_resource_setup(struct lpfc_hba *phba)
 
 	/* Allocate eligible FCF bmask memory for FCF roundrobin failover */
 	longs = (LPFC_SLI4_FCF_TBL_INDX_MAX + BITS_PER_LONG - 1)/BITS_PER_LONG;
-	phba->fcf.fcf_rr_bmask = kzalloc(longs * sizeof(unsigned long),
+	phba->fcf.fcf_rr_bmask = kcalloc(longs, sizeof(unsigned long),
 					 GFP_KERNEL);
 	if (!phba->fcf.fcf_rr_bmask) {
 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
diff --git a/drivers/scsi/lpfc/lpfc_sli.c b/drivers/scsi/lpfc/lpfc_sli.c
index 709fa50c3365..5d7c3f6e8604 100644
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@ -1703,7 +1703,7 @@ lpfc_sli_next_iotag(struct lpfc_hba *phba, struct lpfc_iocbq *iocbq)
 					   - LPFC_IOCBQ_LOOKUP_INCREMENT)) {
 		new_len = psli->iocbq_lookup_len + LPFC_IOCBQ_LOOKUP_INCREMENT;
 		spin_unlock_irq(&phba->hbalock);
-		new_arr = kzalloc(new_len * sizeof (struct lpfc_iocbq *),
+		new_arr = kcalloc(new_len, sizeof(struct lpfc_iocbq *),
 				  GFP_KERNEL);
 		if (new_arr) {
 			spin_lock_irq(&phba->hbalock);
@@ -5174,16 +5174,17 @@ lpfc_sli_hba_setup(struct lpfc_hba *phba)
 		 */
 		if ((phba->vpi_bmask == NULL) && (phba->vpi_ids == NULL)) {
 			longs = (phba->max_vpi + BITS_PER_LONG) / BITS_PER_LONG;
-			phba->vpi_bmask = kzalloc(longs * sizeof(unsigned long),
+			phba->vpi_bmask = kcalloc(longs,
+						  sizeof(unsigned long),
 						  GFP_KERNEL);
 			if (!phba->vpi_bmask) {
 				rc = -ENOMEM;
 				goto lpfc_sli_hba_setup_error;
 			}
 
-			phba->vpi_ids = kzalloc(
-					(phba->max_vpi+1) * sizeof(uint16_t),
-					GFP_KERNEL);
+			phba->vpi_ids = kcalloc(phba->max_vpi + 1,
+						sizeof(uint16_t),
+						GFP_KERNEL);
 			if (!phba->vpi_ids) {
 				kfree(phba->vpi_bmask);
 				rc = -ENOMEM;
@@ -5868,14 +5869,14 @@ lpfc_sli4_alloc_extent(struct lpfc_hba *phba, uint16_t type)
 	length = sizeof(struct lpfc_rsrc_blks);
 	switch (type) {
 	case LPFC_RSC_TYPE_FCOE_RPI:
-		phba->sli4_hba.rpi_bmask = kzalloc(longs *
+		phba->sli4_hba.rpi_bmask = kcalloc(longs,
 						   sizeof(unsigned long),
 						   GFP_KERNEL);
 		if (unlikely(!phba->sli4_hba.rpi_bmask)) {
 			rc = -ENOMEM;
 			goto err_exit;
 		}
-		phba->sli4_hba.rpi_ids = kzalloc(rsrc_id_cnt *
+		phba->sli4_hba.rpi_ids = kcalloc(rsrc_id_cnt,
 						 sizeof(uint16_t),
 						 GFP_KERNEL);
 		if (unlikely(!phba->sli4_hba.rpi_ids)) {
@@ -5897,15 +5898,13 @@ lpfc_sli4_alloc_extent(struct lpfc_hba *phba, uint16_t type)
 		ext_blk_list = &phba->sli4_hba.lpfc_rpi_blk_list;
 		break;
 	case LPFC_RSC_TYPE_FCOE_VPI:
-		phba->vpi_bmask = kzalloc(longs *
-					  sizeof(unsigned long),
+		phba->vpi_bmask = kcalloc(longs, sizeof(unsigned long),
 					  GFP_KERNEL);
 		if (unlikely(!phba->vpi_bmask)) {
 			rc = -ENOMEM;
 			goto err_exit;
 		}
-		phba->vpi_ids = kzalloc(rsrc_id_cnt *
-					 sizeof(uint16_t),
+		phba->vpi_ids = kcalloc(rsrc_id_cnt, sizeof(uint16_t),
 					 GFP_KERNEL);
 		if (unlikely(!phba->vpi_ids)) {
 			kfree(phba->vpi_bmask);
@@ -5919,7 +5918,7 @@ lpfc_sli4_alloc_extent(struct lpfc_hba *phba, uint16_t type)
 		ext_blk_list = &phba->lpfc_vpi_blk_list;
 		break;
 	case LPFC_RSC_TYPE_FCOE_XRI:
-		phba->sli4_hba.xri_bmask = kzalloc(longs *
+		phba->sli4_hba.xri_bmask = kcalloc(longs,
 						   sizeof(unsigned long),
 						   GFP_KERNEL);
 		if (unlikely(!phba->sli4_hba.xri_bmask)) {
@@ -5927,7 +5926,7 @@ lpfc_sli4_alloc_extent(struct lpfc_hba *phba, uint16_t type)
 			goto err_exit;
 		}
 		phba->sli4_hba.max_cfg_param.xri_used = 0;
-		phba->sli4_hba.xri_ids = kzalloc(rsrc_id_cnt *
+		phba->sli4_hba.xri_ids = kcalloc(rsrc_id_cnt,
 						 sizeof(uint16_t),
 						 GFP_KERNEL);
 		if (unlikely(!phba->sli4_hba.xri_ids)) {
@@ -5942,14 +5941,14 @@ lpfc_sli4_alloc_extent(struct lpfc_hba *phba, uint16_t type)
 		ext_blk_list = &phba->sli4_hba.lpfc_xri_blk_list;
 		break;
 	case LPFC_RSC_TYPE_FCOE_VFI:
-		phba->sli4_hba.vfi_bmask = kzalloc(longs *
+		phba->sli4_hba.vfi_bmask = kcalloc(longs,
 						   sizeof(unsigned long),
 						   GFP_KERNEL);
 		if (unlikely(!phba->sli4_hba.vfi_bmask)) {
 			rc = -ENOMEM;
 			goto err_exit;
 		}
-		phba->sli4_hba.vfi_ids = kzalloc(rsrc_id_cnt *
+		phba->sli4_hba.vfi_ids = kcalloc(rsrc_id_cnt,
 						 sizeof(uint16_t),
 						 GFP_KERNEL);
 		if (unlikely(!phba->sli4_hba.vfi_ids)) {
@@ -6282,15 +6281,14 @@ lpfc_sli4_alloc_resource_identifiers(struct lpfc_hba *phba)
 		}
 		base = phba->sli4_hba.max_cfg_param.rpi_base;
 		longs = (count + BITS_PER_LONG - 1) / BITS_PER_LONG;
-		phba->sli4_hba.rpi_bmask = kzalloc(longs *
+		phba->sli4_hba.rpi_bmask = kcalloc(longs,
 						   sizeof(unsigned long),
 						   GFP_KERNEL);
 		if (unlikely(!phba->sli4_hba.rpi_bmask)) {
 			rc = -ENOMEM;
 			goto err_exit;
 		}
-		phba->sli4_hba.rpi_ids = kzalloc(count *
-						 sizeof(uint16_t),
+		phba->sli4_hba.rpi_ids = kcalloc(count, sizeof(uint16_t),
 						 GFP_KERNEL);
 		if (unlikely(!phba->sli4_hba.rpi_ids)) {
 			rc = -ENOMEM;
@@ -6311,15 +6309,13 @@ lpfc_sli4_alloc_resource_identifiers(struct lpfc_hba *phba)
 		}
 		base = phba->sli4_hba.max_cfg_param.vpi_base;
 		longs = (count + BITS_PER_LONG - 1) / BITS_PER_LONG;
-		phba->vpi_bmask = kzalloc(longs *
-					  sizeof(unsigned long),
+		phba->vpi_bmask = kcalloc(longs, sizeof(unsigned long),
 					  GFP_KERNEL);
 		if (unlikely(!phba->vpi_bmask)) {
 			rc = -ENOMEM;
 			goto free_rpi_ids;
 		}
-		phba->vpi_ids = kzalloc(count *
-					sizeof(uint16_t),
+		phba->vpi_ids = kcalloc(count, sizeof(uint16_t),
 					GFP_KERNEL);
 		if (unlikely(!phba->vpi_ids)) {
 			rc = -ENOMEM;
@@ -6340,7 +6336,7 @@ lpfc_sli4_alloc_resource_identifiers(struct lpfc_hba *phba)
 		}
 		base = phba->sli4_hba.max_cfg_param.xri_base;
 		longs = (count + BITS_PER_LONG - 1) / BITS_PER_LONG;
-		phba->sli4_hba.xri_bmask = kzalloc(longs *
+		phba->sli4_hba.xri_bmask = kcalloc(longs,
 						   sizeof(unsigned long),
 						   GFP_KERNEL);
 		if (unlikely(!phba->sli4_hba.xri_bmask)) {
@@ -6348,8 +6344,7 @@ lpfc_sli4_alloc_resource_identifiers(struct lpfc_hba *phba)
 			goto free_vpi_ids;
 		}
 		phba->sli4_hba.max_cfg_param.xri_used = 0;
-		phba->sli4_hba.xri_ids = kzalloc(count *
-						 sizeof(uint16_t),
+		phba->sli4_hba.xri_ids = kcalloc(count, sizeof(uint16_t),
 						 GFP_KERNEL);
 		if (unlikely(!phba->sli4_hba.xri_ids)) {
 			rc = -ENOMEM;
@@ -6370,15 +6365,14 @@ lpfc_sli4_alloc_resource_identifiers(struct lpfc_hba *phba)
 		}
 		base = phba->sli4_hba.max_cfg_param.vfi_base;
 		longs = (count + BITS_PER_LONG - 1) / BITS_PER_LONG;
-		phba->sli4_hba.vfi_bmask = kzalloc(longs *
+		phba->sli4_hba.vfi_bmask = kcalloc(longs,
 						   sizeof(unsigned long),
 						   GFP_KERNEL);
 		if (unlikely(!phba->sli4_hba.vfi_bmask)) {
 			rc = -ENOMEM;
 			goto free_xri_ids;
 		}
-		phba->sli4_hba.vfi_ids = kzalloc(count *
-						 sizeof(uint16_t),
+		phba->sli4_hba.vfi_ids = kcalloc(count, sizeof(uint16_t),
 						 GFP_KERNEL);
 		if (unlikely(!phba->sli4_hba.vfi_ids)) {
 			rc = -ENOMEM;
diff --git a/drivers/scsi/lpfc/lpfc_vport.c b/drivers/scsi/lpfc/lpfc_vport.c
index 572bd886153e..a8e6ed9b895f 100644
--- a/drivers/scsi/lpfc/lpfc_vport.c
+++ b/drivers/scsi/lpfc/lpfc_vport.c
@@ -839,7 +839,7 @@ lpfc_create_vport_work_array(struct lpfc_hba *phba)
 	struct lpfc_vport *port_iterator;
 	struct lpfc_vport **vports;
 	int index = 0;
-	vports = kzalloc((phba->max_vports + 1) * sizeof(struct lpfc_vport *),
+	vports = kcalloc(phba->max_vports + 1, sizeof(struct lpfc_vport *),
 			 GFP_KERNEL);
 	if (vports == NULL)
 		return NULL;
diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c
index 4a0c6dd70101..6c7e2005c708 100644
--- a/drivers/scsi/megaraid/megaraid_sas_base.c
+++ b/drivers/scsi/megaraid/megaraid_sas_base.c
@@ -5607,9 +5607,9 @@ static int megasas_init_fw(struct megasas_instance *instance)
 	/* stream detection initialization */
 	if (instance->adapter_type >= VENTURA_SERIES) {
 		fusion->stream_detect_by_ld =
-			kzalloc(sizeof(struct LD_STREAM_DETECT *)
-			* MAX_LOGICAL_DRIVES_EXT,
-			GFP_KERNEL);
+			kcalloc(MAX_LOGICAL_DRIVES_EXT,
+				sizeof(struct LD_STREAM_DETECT *),
+				GFP_KERNEL);
 		if (!fusion->stream_detect_by_ld) {
 			dev_err(&instance->pdev->dev,
 				"unable to allocate stream detection for pool of LDs\n");
@@ -6362,7 +6362,7 @@ static inline int megasas_alloc_mfi_ctrl_mem(struct megasas_instance *instance)
  */
 static int megasas_alloc_ctrl_mem(struct megasas_instance *instance)
 {
-	instance->reply_map = kzalloc(sizeof(unsigned int) * nr_cpu_ids,
+	instance->reply_map = kcalloc(nr_cpu_ids, sizeof(unsigned int),
 				      GFP_KERNEL);
 	if (!instance->reply_map)
 		return -ENOMEM;
diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c
index 80e5cffa9aff..0073e5b47dcd 100644
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@ -495,7 +495,7 @@ megasas_alloc_cmdlist_fusion(struct megasas_instance *instance)
 	 * commands.
 	 */
 	fusion->cmd_list =
-		kzalloc(sizeof(struct megasas_cmd_fusion *) * max_mpt_cmd,
+		kcalloc(max_mpt_cmd, sizeof(struct megasas_cmd_fusion *),
 			GFP_KERNEL);
 	if (!fusion->cmd_list) {
 		dev_err(&instance->pdev->dev,
diff --git a/drivers/scsi/osst.c b/drivers/scsi/osst.c
index 5da60596e5e0..d6b33c0e8cd3 100644
--- a/drivers/scsi/osst.c
+++ b/drivers/scsi/osst.c
@@ -376,7 +376,7 @@ static int osst_execute(struct osst_request *SRpnt, const unsigned char *cmd,
 		struct scatterlist *sg, *sgl = (struct scatterlist *)buffer;
 		int i;
 
-		pages = kzalloc(use_sg * sizeof(struct page *), GFP_KERNEL);
+		pages = kcalloc(use_sg, sizeof(struct page *), GFP_KERNEL);
 		if (!pages)
 			goto free_req;
 
diff --git a/drivers/scsi/pm8001/pm8001_ctl.c b/drivers/scsi/pm8001/pm8001_ctl.c
index be8269c8d127..b989ed968020 100644
--- a/drivers/scsi/pm8001/pm8001_ctl.c
+++ b/drivers/scsi/pm8001/pm8001_ctl.c
@@ -653,7 +653,7 @@ static ssize_t pm8001_store_update_fw(struct device *cdev,
 		return -EINPROGRESS;
 	pm8001_ha->fw_status = FLASH_IN_PROGRESS;
 
-	cmd_ptr = kzalloc(count*2, GFP_KERNEL);
+	cmd_ptr = kcalloc(count, 2, GFP_KERNEL);
 	if (!cmd_ptr) {
 		pm8001_ha->fw_status = FAIL_OUT_MEMORY;
 		return -ENOMEM;
diff --git a/drivers/scsi/pmcraid.c b/drivers/scsi/pmcraid.c
index ff5b85df0d93..a8b993a68c03 100644
--- a/drivers/scsi/pmcraid.c
+++ b/drivers/scsi/pmcraid.c
@@ -5051,8 +5051,9 @@ static int pmcraid_allocate_config_buffers(struct pmcraid_instance *pinstance)
 	int i;
 
 	pinstance->res_entries =
-			kzalloc(sizeof(struct pmcraid_resource_entry) *
-				PMCRAID_MAX_RESOURCES, GFP_KERNEL);
+			kcalloc(PMCRAID_MAX_RESOURCES,
+				sizeof(struct pmcraid_resource_entry),
+				GFP_KERNEL);
 
 	if (NULL == pinstance->res_entries) {
 		pmcraid_err("failed to allocate memory for resource table\n");
diff --git a/drivers/scsi/qedi/qedi_main.c b/drivers/scsi/qedi/qedi_main.c
index d56bf4c9af49..776ba86d3714 100644
--- a/drivers/scsi/qedi/qedi_main.c
+++ b/drivers/scsi/qedi/qedi_main.c
@@ -529,7 +529,7 @@ static int qedi_init_id_tbl(struct qedi_portid_tbl *id_tbl, u16 size,
 	id_tbl->max = size;
 	id_tbl->next = next;
 	spin_lock_init(&id_tbl->lock);
-	id_tbl->table = kzalloc(DIV_ROUND_UP(size, 32) * 4, GFP_KERNEL);
+	id_tbl->table = kcalloc(DIV_ROUND_UP(size, 32), 4, GFP_KERNEL);
 	if (!id_tbl->table)
 		return -ENOMEM;
 
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index 1c4bb984c354..31eca302cff2 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -3113,8 +3113,9 @@ qla2x00_alloc_outstanding_cmds(struct qla_hw_data *ha, struct req_que *req)
 			req->num_outstanding_cmds = ha->cur_fw_iocb_count;
 	}
 
-	req->outstanding_cmds = kzalloc(sizeof(srb_t *) *
-	    req->num_outstanding_cmds, GFP_KERNEL);
+	req->outstanding_cmds = kcalloc(req->num_outstanding_cmds,
+					sizeof(srb_t *),
+					GFP_KERNEL);
 
 	if (!req->outstanding_cmds) {
 		/*
@@ -3122,8 +3123,9 @@ qla2x00_alloc_outstanding_cmds(struct qla_hw_data *ha, struct req_que *req)
 		 * initialization.
 		 */
 		req->num_outstanding_cmds = MIN_OUTSTANDING_COMMANDS;
-		req->outstanding_cmds = kzalloc(sizeof(srb_t *) *
-		    req->num_outstanding_cmds, GFP_KERNEL);
+		req->outstanding_cmds = kcalloc(req->num_outstanding_cmds,
+						sizeof(srb_t *),
+						GFP_KERNEL);
 
 		if (!req->outstanding_cmds) {
 			ql_log(ql_log_fatal, NULL, 0x0126,
diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c
index 84e0ef83e084..c6afb40fde98 100644
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@ -3438,8 +3438,9 @@ qla24xx_enable_msix(struct qla_hw_data *ha, struct rsp_que *rsp)
 					ha->max_qpairs);
 		}
 	}
-	ha->msix_entries = kzalloc(sizeof(struct qla_msix_entry) *
-				ha->msix_count, GFP_KERNEL);
+	ha->msix_entries = kcalloc(ha->msix_count,
+				   sizeof(struct qla_msix_entry),
+				   GFP_KERNEL);
 	if (!ha->msix_entries) {
 		ql_log(ql_log_fatal, vha, 0x00c8,
 		    "Failed to allocate memory for ha->msix_entries.\n");
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index e99b9c05ac9d..e961edd99c01 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -414,7 +414,7 @@ static int qla2x00_alloc_queues(struct qla_hw_data *ha, struct req_que *req,
 				struct rsp_que *rsp)
 {
 	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
-	ha->req_q_map = kzalloc(sizeof(struct req_que *) * ha->max_req_queues,
+	ha->req_q_map = kcalloc(ha->max_req_queues, sizeof(struct req_que *),
 				GFP_KERNEL);
 	if (!ha->req_q_map) {
 		ql_log(ql_log_fatal, vha, 0x003b,
@@ -422,7 +422,7 @@ static int qla2x00_alloc_queues(struct qla_hw_data *ha, struct req_que *req,
 		goto fail_req_map;
 	}
 
-	ha->rsp_q_map = kzalloc(sizeof(struct rsp_que *) * ha->max_rsp_queues,
+	ha->rsp_q_map = kcalloc(ha->max_rsp_queues, sizeof(struct rsp_que *),
 				GFP_KERNEL);
 	if (!ha->rsp_q_map) {
 		ql_log(ql_log_fatal, vha, 0x003c,
@@ -4119,8 +4119,9 @@ qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,
 	    (*rsp)->ring);
 	/* Allocate memory for NVRAM data for vports */
 	if (ha->nvram_npiv_size) {
-		ha->npiv_info = kzalloc(sizeof(struct qla_npiv_entry) *
-		    ha->nvram_npiv_size, GFP_KERNEL);
+		ha->npiv_info = kcalloc(ha->nvram_npiv_size,
+					sizeof(struct qla_npiv_entry),
+					GFP_KERNEL);
 		if (!ha->npiv_info) {
 			ql_log_pci(ql_log_fatal, ha->pdev, 0x002d,
 			    "Failed to allocate memory for npiv_info.\n");
@@ -4154,8 +4155,9 @@ qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,
 	INIT_LIST_HEAD(&ha->vp_list);
 
 	/* Allocate memory for our loop_id bitmap */
-	ha->loop_id_map = kzalloc(BITS_TO_LONGS(LOOPID_MAP_SIZE) * sizeof(long),
-	    GFP_KERNEL);
+	ha->loop_id_map = kcalloc(BITS_TO_LONGS(LOOPID_MAP_SIZE),
+				  sizeof(long),
+				  GFP_KERNEL);
 	if (!ha->loop_id_map)
 		goto fail_loop_id_map;
 	else {
diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c
index f8c3bd6110b5..a1d40c02631b 100644
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@ -6234,8 +6234,9 @@ int qlt_add_target(struct qla_hw_data *ha, struct scsi_qla_host *base_vha)
 		return -ENOMEM;
 	}
 
-	tgt->qphints = kzalloc((ha->max_qpairs + 1) *
-	    sizeof(struct qla_qpair_hint), GFP_KERNEL);
+	tgt->qphints = kcalloc(ha->max_qpairs + 1,
+			       sizeof(struct qla_qpair_hint),
+			       GFP_KERNEL);
 	if (!tgt->qphints) {
 		kfree(tgt);
 		ql_log(ql_log_warn, base_vha, 0x0197,
@@ -7076,8 +7077,9 @@ qlt_mem_alloc(struct qla_hw_data *ha)
 	if (!QLA_TGT_MODE_ENABLED())
 		return 0;
 
-	ha->tgt.tgt_vp_map = kzalloc(sizeof(struct qla_tgt_vp_map) *
-	    MAX_MULTI_ID_FABRIC, GFP_KERNEL);
+	ha->tgt.tgt_vp_map = kcalloc(MAX_MULTI_ID_FABRIC,
+				     sizeof(struct qla_tgt_vp_map),
+				     GFP_KERNEL);
 	if (!ha->tgt.tgt_vp_map)
 		return -ENOMEM;
 
* Unmerged path drivers/scsi/scsi_debug.c
diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 994c05d8ebf0..a7b0c56eed39 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -744,7 +744,7 @@ static int ses_intf_add(struct device *cdev,
 		buf = NULL;
 	}
 page2_not_supported:
-	scomp = kzalloc(sizeof(struct ses_component) * components, GFP_KERNEL);
+	scomp = kcalloc(components, sizeof(struct ses_component), GFP_KERNEL);
 	if (!scomp)
 		goto err_free;
 
* Unmerged path drivers/scsi/sg.c
diff --git a/drivers/scsi/smartpqi/smartpqi_init.c b/drivers/scsi/smartpqi/smartpqi_init.c
index f7fe8546866d..b6a1f8e53793 100644
--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@ -4654,8 +4654,9 @@ static int pqi_alloc_io_resources(struct pqi_ctrl_info *ctrl_info)
 	struct device *dev;
 	struct pqi_io_request *io_request;
 
-	ctrl_info->io_request_pool = kzalloc(ctrl_info->max_io_slots *
-		sizeof(ctrl_info->io_request_pool[0]), GFP_KERNEL);
+	ctrl_info->io_request_pool =
+		kcalloc(ctrl_info->max_io_slots,
+			sizeof(ctrl_info->io_request_pool[0]), GFP_KERNEL);
 
 	if (!ctrl_info->io_request_pool) {
 		dev_err(&ctrl_info->pci_dev->dev,
* Unmerged path drivers/scsi/st.c
diff --git a/drivers/sh/clk/cpg.c b/drivers/sh/clk/cpg.c
index 1ebe67cd1833..9c96450b06fb 100644
--- a/drivers/sh/clk/cpg.c
+++ b/drivers/sh/clk/cpg.c
@@ -211,7 +211,7 @@ static int __init sh_clk_div_register_ops(struct clk *clks, int nr,
 	int k;
 
 	freq_table_size *= (nr_divs + 1);
-	freq_table = kzalloc(freq_table_size * nr, GFP_KERNEL);
+	freq_table = kcalloc(nr, freq_table_size, GFP_KERNEL);
 	if (!freq_table) {
 		pr_err("%s: unable to alloc memory\n", __func__);
 		return -ENOMEM;
diff --git a/drivers/sh/intc/core.c b/drivers/sh/intc/core.c
index 8f32a1323a79..5ebb1e2fa1ac 100644
--- a/drivers/sh/intc/core.c
+++ b/drivers/sh/intc/core.c
@@ -209,7 +209,7 @@ int __init register_intc_controller(struct intc_desc *desc)
 
 	if (desc->num_resources) {
 		d->nr_windows = desc->num_resources;
-		d->window = kzalloc(d->nr_windows * sizeof(*d->window),
+		d->window = kcalloc(d->nr_windows, sizeof(*d->window),
 				    GFP_NOWAIT);
 		if (!d->window)
 			goto err1;
@@ -236,12 +236,12 @@ int __init register_intc_controller(struct intc_desc *desc)
 	d->nr_reg += hw->ack_regs ? hw->nr_ack_regs : 0;
 	d->nr_reg += hw->subgroups ? hw->nr_subgroups : 0;
 
-	d->reg = kzalloc(d->nr_reg * sizeof(*d->reg), GFP_NOWAIT);
+	d->reg = kcalloc(d->nr_reg, sizeof(*d->reg), GFP_NOWAIT);
 	if (!d->reg)
 		goto err2;
 
 #ifdef CONFIG_SMP
-	d->smp = kzalloc(d->nr_reg * sizeof(*d->smp), GFP_NOWAIT);
+	d->smp = kcalloc(d->nr_reg, sizeof(*d->smp), GFP_NOWAIT);
 	if (!d->smp)
 		goto err3;
 #endif
@@ -259,7 +259,7 @@ int __init register_intc_controller(struct intc_desc *desc)
 	}
 
 	if (hw->prio_regs) {
-		d->prio = kzalloc(hw->nr_vectors * sizeof(*d->prio),
+		d->prio = kcalloc(hw->nr_vectors, sizeof(*d->prio),
 				  GFP_NOWAIT);
 		if (!d->prio)
 			goto err4;
@@ -275,7 +275,7 @@ int __init register_intc_controller(struct intc_desc *desc)
 	}
 
 	if (hw->sense_regs) {
-		d->sense = kzalloc(hw->nr_vectors * sizeof(*d->sense),
+		d->sense = kcalloc(hw->nr_vectors, sizeof(*d->sense),
 				   GFP_NOWAIT);
 		if (!d->sense)
 			goto err5;
diff --git a/drivers/sh/maple/maple.c b/drivers/sh/maple/maple.c
index bec81c2404f7..040ba4777d63 100644
--- a/drivers/sh/maple/maple.c
+++ b/drivers/sh/maple/maple.c
@@ -161,7 +161,7 @@ int maple_add_packet(struct maple_device *mdev, u32 function, u32 command,
 	void *sendbuf = NULL;
 
 	if (length) {
-		sendbuf = kzalloc(length * 4, GFP_KERNEL);
+		sendbuf = kcalloc(length, 4, GFP_KERNEL);
 		if (!sendbuf) {
 			ret = -ENOMEM;
 			goto out;
* Unmerged path drivers/slimbus/qcom-ctrl.c
diff --git a/drivers/staging/media/go7007/go7007-fw.c b/drivers/staging/media/go7007/go7007-fw.c
index c2d0e58afc34..25821019461c 100644
--- a/drivers/staging/media/go7007/go7007-fw.c
+++ b/drivers/staging/media/go7007/go7007-fw.c
@@ -1576,7 +1576,7 @@ int go7007_construct_fw_image(struct go7007 *go, u8 **fw, int *fwlen)
 			GO7007_FW_NAME);
 		return -1;
 	}
-	code = kzalloc(codespace * 2, GFP_KERNEL);
+	code = kcalloc(codespace, 2, GFP_KERNEL);
 	if (code == NULL)
 		goto fw_failed;
 
* Unmerged path drivers/staging/mt7621-pinctrl/pinctrl-rt2880.c
* Unmerged path drivers/staging/rtlwifi/efuse.c
* Unmerged path drivers/staging/unisys/visorhba/visorhba_main.c
* Unmerged path drivers/target/target_core_transport.c
* Unmerged path drivers/target/target_core_user.c
diff --git a/drivers/thermal/int340x_thermal/acpi_thermal_rel.c b/drivers/thermal/int340x_thermal/acpi_thermal_rel.c
index 2c2ec7666eb1..5875d3f60903 100644
--- a/drivers/thermal/int340x_thermal/acpi_thermal_rel.c
+++ b/drivers/thermal/int340x_thermal/acpi_thermal_rel.c
@@ -96,7 +96,7 @@ int acpi_parse_trt(acpi_handle handle, int *trt_count, struct trt **trtp,
 	}
 
 	*trt_count = p->package.count;
-	trts = kzalloc(*trt_count * sizeof(struct trt), GFP_KERNEL);
+	trts = kcalloc(*trt_count, sizeof(struct trt), GFP_KERNEL);
 	if (!trts) {
 		result = -ENOMEM;
 		goto end;
@@ -178,7 +178,7 @@ int acpi_parse_art(acpi_handle handle, int *art_count, struct art **artp,
 
 	/* ignore p->package.elements[0], as this is _ART Revision field */
 	*art_count = p->package.count - 1;
-	arts = kzalloc(*art_count * sizeof(struct art), GFP_KERNEL);
+	arts = kcalloc(*art_count, sizeof(struct art), GFP_KERNEL);
 	if (!arts) {
 		result = -ENOMEM;
 		goto end;
* Unmerged path drivers/thermal/int340x_thermal/int340x_thermal_zone.c
* Unmerged path drivers/thermal/of-thermal.c
* Unmerged path drivers/thermal/x86_pkg_temp_thermal.c
diff --git a/drivers/tty/ehv_bytechan.c b/drivers/tty/ehv_bytechan.c
index 9bffcec5ad82..adae7a63c77d 100644
--- a/drivers/tty/ehv_bytechan.c
+++ b/drivers/tty/ehv_bytechan.c
@@ -807,7 +807,7 @@ static int __init ehv_bc_init(void)
 	 * array, then you can use pointer math (e.g. "bc - bcs") to get its
 	 * tty index.
 	 */
-	bcs = kzalloc(count * sizeof(struct ehv_bc_data), GFP_KERNEL);
+	bcs = kcalloc(count, sizeof(struct ehv_bc_data), GFP_KERNEL);
 	if (!bcs)
 		return -ENOMEM;
 
* Unmerged path drivers/tty/goldfish.c
diff --git a/drivers/tty/hvc/hvc_iucv.c b/drivers/tty/hvc/hvc_iucv.c
index bb08676e7f3e..fc331106aac8 100644
--- a/drivers/tty/hvc/hvc_iucv.c
+++ b/drivers/tty/hvc/hvc_iucv.c
@@ -1147,7 +1147,7 @@ static int hvc_iucv_setup_filter(const char *val)
 	if (size > MAX_VMID_FILTER)
 		return -ENOSPC;
 
-	array = kzalloc(size * 8, GFP_KERNEL);
+	array = kcalloc(size, 8, GFP_KERNEL);
 	if (!array)
 		return -ENOMEM;
 
diff --git a/drivers/tty/serial/pch_uart.c b/drivers/tty/serial/pch_uart.c
index 80158594c974..8e49bd5e5716 100644
--- a/drivers/tty/serial/pch_uart.c
+++ b/drivers/tty/serial/pch_uart.c
@@ -987,7 +987,7 @@ static unsigned int dma_handle_tx(struct eg20t_port *priv)
 
 	priv->tx_dma_use = 1;
 
-	priv->sg_tx_p = kzalloc(sizeof(struct scatterlist)*num, GFP_ATOMIC);
+	priv->sg_tx_p = kcalloc(num, sizeof(struct scatterlist), GFP_ATOMIC);
 	if (!priv->sg_tx_p) {
 		dev_err(priv->port.dev, "%s:kzalloc Failed\n", __func__);
 		return 0;
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 2436b552ef0b..4f2d500d3691 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -2292,7 +2292,7 @@ int uart_register_driver(struct uart_driver *drv)
 	 * Maybe we should be using a slab cache for this, especially if
 	 * we have a large number of ports to handle.
 	 */
-	drv->state = kzalloc(sizeof(struct uart_state) * drv->nr, GFP_KERNEL);
+	drv->state = kcalloc(drv->nr, sizeof(struct uart_state), GFP_KERNEL);
 	if (!drv->state)
 		goto out;
 
diff --git a/drivers/tty/serial/sunsab.c b/drivers/tty/serial/sunsab.c
index a422c8b55a47..a9e726c391bd 100644
--- a/drivers/tty/serial/sunsab.c
+++ b/drivers/tty/serial/sunsab.c
@@ -1111,8 +1111,9 @@ static int __init sunsab_init(void)
 	}
 
 	if (num_channels) {
-		sunsab_ports = kzalloc(sizeof(struct uart_sunsab_port) *
-				       num_channels, GFP_KERNEL);
+		sunsab_ports = kcalloc(num_channels,
+				       sizeof(struct uart_sunsab_port),
+				       GFP_KERNEL);
 		if (!sunsab_ports)
 			return -ENOMEM;
 
diff --git a/drivers/uio/uio_pruss.c b/drivers/uio/uio_pruss.c
index 5d65daa71929..15934f7d5e22 100644
--- a/drivers/uio/uio_pruss.c
+++ b/drivers/uio/uio_pruss.c
@@ -127,7 +127,7 @@ static int pruss_probe(struct platform_device *dev)
 	if (!gdev)
 		return -ENOMEM;
 
-	gdev->info = kzalloc(sizeof(*p) * MAX_PRUSS_EVT, GFP_KERNEL);
+	gdev->info = kcalloc(MAX_PRUSS_EVT, sizeof(*p), GFP_KERNEL);
 	if (!gdev->info) {
 		kfree(gdev);
 		return -ENOMEM;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 2cb5ba6e5e0e..a1c835226199 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1380,7 +1380,7 @@ static int hub_configure(struct usb_hub *hub,
 	dev_info(hub_dev, "%d port%s detected\n", maxchild,
 			(maxchild == 1) ? "" : "s");
 
-	hub->ports = kzalloc(maxchild * sizeof(struct usb_port *), GFP_KERNEL);
+	hub->ports = kcalloc(maxchild, sizeof(struct usb_port *), GFP_KERNEL);
 	if (!hub->ports) {
 		ret = -ENOMEM;
 		goto fail;
* Unmerged path drivers/usb/dwc2/hcd.c
* Unmerged path drivers/usb/gadget/fsl_udc_core.c
* Unmerged path drivers/usb/gadget/udc/bdc/bdc_ep.c
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 82ca054aae3a..da7b00a6110b 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -117,8 +117,9 @@ static struct ehci_tt *find_tt(struct usb_device *udev)
 	if (utt->multi) {
 		tt_index = utt->hcpriv;
 		if (!tt_index) {		/* Create the index array */
-			tt_index = kzalloc(utt->hub->maxchild *
-					sizeof(*tt_index), GFP_ATOMIC);
+			tt_index = kcalloc(utt->hub->maxchild,
+					   sizeof(*tt_index),
+					   GFP_ATOMIC);
 			if (!tt_index)
 				return ERR_PTR(-ENOMEM);
 			utt->hcpriv = tt_index;
diff --git a/drivers/usb/host/imx21-hcd.c b/drivers/usb/host/imx21-hcd.c
index 46d0d3b5d4c7..0f332998b74a 100644
--- a/drivers/usb/host/imx21-hcd.c
+++ b/drivers/usb/host/imx21-hcd.c
@@ -754,8 +754,8 @@ static int imx21_hc_urb_enqueue_isoc(struct usb_hcd *hcd,
 	if (urb_priv == NULL)
 		return -ENOMEM;
 
-	urb_priv->isoc_td = kzalloc(
-		sizeof(struct td) * urb->number_of_packets, mem_flags);
+	urb_priv->isoc_td = kcalloc(urb->number_of_packets, sizeof(struct td),
+				    mem_flags);
 	if (urb_priv->isoc_td == NULL) {
 		ret = -ENOMEM;
 		goto alloc_td_failed;
diff --git a/drivers/usb/mon/mon_bin.c b/drivers/usb/mon/mon_bin.c
index 8f9428d53b6a..7e3c0d811a69 100644
--- a/drivers/usb/mon/mon_bin.c
+++ b/drivers/usb/mon/mon_bin.c
@@ -1023,7 +1023,8 @@ static long mon_bin_ioctl(struct file *file, unsigned int cmd, unsigned long arg
 			return -EINVAL;
 
 		size = CHUNK_ALIGN(arg);
-		vec = kzalloc(sizeof(struct mon_pgmap) * (size / CHUNK_SIZE), GFP_KERNEL);
+		vec = kcalloc(size / CHUNK_SIZE, sizeof(struct mon_pgmap),
+			      GFP_KERNEL);
 		if (vec == NULL) {
 			ret = -ENOMEM;
 			break;
diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c
index ed4949faa70d..79563e5e6bfe 100644
--- a/drivers/usb/renesas_usbhs/mod_gadget.c
+++ b/drivers/usb/renesas_usbhs/mod_gadget.c
@@ -938,7 +938,7 @@ int usbhs_mod_gadget_probe(struct usbhs_priv *priv)
 		return -ENOMEM;
 	}
 
-	uep = kzalloc(sizeof(struct usbhsg_uep) * pipe_size, GFP_KERNEL);
+	uep = kcalloc(pipe_size, sizeof(struct usbhsg_uep), GFP_KERNEL);
 	if (!uep) {
 		dev_err(dev, "Could not allocate ep\n");
 		ret = -ENOMEM;
* Unmerged path drivers/usb/renesas_usbhs/pipe.c
diff --git a/drivers/usb/wusbcore/wa-rpipe.c b/drivers/usb/wusbcore/wa-rpipe.c
index d0f1a6698460..38884aac862b 100644
--- a/drivers/usb/wusbcore/wa-rpipe.c
+++ b/drivers/usb/wusbcore/wa-rpipe.c
@@ -470,7 +470,8 @@ error:
 int wa_rpipes_create(struct wahc *wa)
 {
 	wa->rpipes = le16_to_cpu(wa->wa_descr->wNumRPipes);
-	wa->rpipe_bm = kzalloc(BITS_TO_LONGS(wa->rpipes)*sizeof(unsigned long),
+	wa->rpipe_bm = kcalloc(BITS_TO_LONGS(wa->rpipes),
+			       sizeof(unsigned long),
 			       GFP_KERNEL);
 	if (wa->rpipe_bm == NULL)
 		return -ENOMEM;
* Unmerged path drivers/vhost/scsi.c
diff --git a/drivers/video/broadsheetfb.c b/drivers/video/broadsheetfb.c
index b09701c79432..ec5bd17fbd9c 100644
--- a/drivers/video/broadsheetfb.c
+++ b/drivers/video/broadsheetfb.c
@@ -617,7 +617,7 @@ static int broadsheet_spiflash_rewrite_sector(struct broadsheetfb_par *par,
 	int tail_start_addr;
 	int start_sector_addr;
 
-	sector_buffer = kzalloc(sizeof(char)*sector_size, GFP_KERNEL);
+	sector_buffer = kzalloc(sector_size, GFP_KERNEL);
 	if (!sector_buffer)
 		return -ENOMEM;
 
diff --git a/drivers/video/console/sticore.c b/drivers/video/console/sticore.c
index 4ad24f2c6472..d60e3e4fa0c0 100644
--- a/drivers/video/console/sticore.c
+++ b/drivers/video/console/sticore.c
@@ -649,7 +649,7 @@ static void *sti_bmode_font_raw(struct sti_cooked_font *f)
 	unsigned char *n, *p, *q;
 	int size = f->raw->bytes_per_char*256+sizeof(struct sti_rom_font);
 	
-	n = kzalloc(4*size, STI_LOWMEM);
+	n = kcalloc(4, size, STI_LOWMEM);
 	if (!n)
 		return NULL;
 	p = n + 3;
* Unmerged path drivers/video/fbmon.c
diff --git a/drivers/video/mmp/fb/mmpfb.c b/drivers/video/mmp/fb/mmpfb.c
index 6d1fa96c5cc3..035b0b3dfb4f 100644
--- a/drivers/video/mmp/fb/mmpfb.c
+++ b/drivers/video/mmp/fb/mmpfb.c
@@ -483,8 +483,8 @@ static int modes_setup(struct mmpfb_info *fbi)
 		return 0;
 	}
 	/* put videomode list to info structure */
-	videomodes = kzalloc(sizeof(struct fb_videomode) * videomode_num,
-			GFP_KERNEL);
+	videomodes = kcalloc(videomode_num, sizeof(struct fb_videomode),
+			     GFP_KERNEL);
 	if (!videomodes) {
 		dev_err(fbi->dev, "can't malloc video modes\n");
 		return -ENOMEM;
diff --git a/drivers/video/of_display_timing.c b/drivers/video/of_display_timing.c
index 56009bc02b02..ebeda340920a 100644
--- a/drivers/video/of_display_timing.c
+++ b/drivers/video/of_display_timing.c
@@ -161,8 +161,9 @@ struct display_timings *of_get_display_timings(struct device_node *np)
 		goto entryfail;
 	}
 
-	disp->timings = kzalloc(sizeof(struct display_timing *) *
-				disp->num_timings, GFP_KERNEL);
+	disp->timings = kcalloc(disp->num_timings,
+				sizeof(struct display_timing *),
+				GFP_KERNEL);
 	if (!disp->timings) {
 		pr_err("%s: could not allocate timings array\n",
 			of_node_full_name(np));
diff --git a/drivers/video/omap2/dss/manager.c b/drivers/video/omap2/dss/manager.c
index 2551eaa14c42..77ccc4a51bab 100644
--- a/drivers/video/omap2/dss/manager.c
+++ b/drivers/video/omap2/dss/manager.c
@@ -42,8 +42,8 @@ int dss_init_overlay_managers(struct platform_device *pdev)
 
 	num_managers = dss_feat_get_num_mgrs();
 
-	managers = kzalloc(sizeof(struct omap_overlay_manager) * num_managers,
-			GFP_KERNEL);
+	managers = kcalloc(num_managers, sizeof(struct omap_overlay_manager),
+			   GFP_KERNEL);
 
 	BUG_ON(managers == NULL);
 
diff --git a/drivers/video/omap2/dss/overlay.c b/drivers/video/omap2/dss/overlay.c
index eccde322c28a..fd0946085262 100644
--- a/drivers/video/omap2/dss/overlay.c
+++ b/drivers/video/omap2/dss/overlay.c
@@ -59,8 +59,8 @@ void dss_init_overlays(struct platform_device *pdev)
 
 	num_overlays = dss_feat_get_num_ovls();
 
-	overlays = kzalloc(sizeof(struct omap_overlay) * num_overlays,
-			GFP_KERNEL);
+	overlays = kcalloc(num_overlays, sizeof(struct omap_overlay),
+			   GFP_KERNEL);
 
 	BUG_ON(overlays == NULL);
 
diff --git a/drivers/video/uvesafb.c b/drivers/video/uvesafb.c
index e328a61b64ba..959a94e6bf34 100644
--- a/drivers/video/uvesafb.c
+++ b/drivers/video/uvesafb.c
@@ -492,8 +492,9 @@ static int uvesafb_vbe_getmodes(struct uvesafb_ktask *task,
 		mode++;
 	}
 
-	par->vbe_modes = kzalloc(sizeof(struct vbe_mode_ib) *
-				par->vbe_modes_cnt, GFP_KERNEL);
+	par->vbe_modes = kcalloc(par->vbe_modes_cnt,
+				 sizeof(struct vbe_mode_ib),
+				 GFP_KERNEL);
 	if (!par->vbe_modes)
 		return -ENOMEM;
 
@@ -877,7 +878,7 @@ static int uvesafb_vbe_init_mode(struct fb_info *info)
 	 * Convert the modelist into a modedb so that we can use it with
 	 * fb_find_mode().
 	 */
-	mode = kzalloc(i * sizeof(*mode), GFP_KERNEL);
+	mode = kcalloc(i, sizeof(*mode), GFP_KERNEL);
 	if (mode) {
 		i = 0;
 		list_for_each(pos, &info->modelist) {
diff --git a/drivers/virt/fsl_hypervisor.c b/drivers/virt/fsl_hypervisor.c
index d294f67d6f84..4fa66cb5eb77 100644
--- a/drivers/virt/fsl_hypervisor.c
+++ b/drivers/virt/fsl_hypervisor.c
@@ -222,7 +222,7 @@ static long ioctl_memcpy(struct fsl_hv_ioctl_memcpy __user *p)
 	 * 'pages' is an array of struct page pointers that's initialized by
 	 * get_user_pages().
 	 */
-	pages = kzalloc(num_pages * sizeof(struct page *), GFP_KERNEL);
+	pages = kcalloc(num_pages, sizeof(struct page *), GFP_KERNEL);
 	if (!pages) {
 		pr_debug("fsl-hv: could not allocate page list\n");
 		return -ENOMEM;
diff --git a/drivers/virtio/virtio_pci_common.c b/drivers/virtio/virtio_pci_common.c
index ee13eb83bfb1..e5e4650a2238 100644
--- a/drivers/virtio/virtio_pci_common.c
+++ b/drivers/virtio/virtio_pci_common.c
@@ -156,7 +156,7 @@ static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 	if (!vp_dev->msix_names)
 		goto error;
 	vp_dev->msix_affinity_masks
-		= kzalloc(nvectors * sizeof *vp_dev->msix_affinity_masks,
+		= kcalloc(nvectors, sizeof(*vp_dev->msix_affinity_masks),
 			  GFP_KERNEL);
 	if (!vp_dev->msix_affinity_masks)
 		goto error;
* Unmerged path drivers/xen/arm-device.c
diff --git a/fs/bio.c b/fs/bio.c
index 95f8b9565f90..b3a643e6cdc7 100644
--- a/fs/bio.c
+++ b/fs/bio.c
@@ -2277,7 +2277,8 @@ static int __init init_bio(void)
 {
 	bio_slab_max = 2;
 	bio_slab_nr = 0;
-	bio_slabs = kzalloc(bio_slab_max * sizeof(struct bio_slab), GFP_KERNEL);
+	bio_slabs = kcalloc(bio_slab_max, sizeof(struct bio_slab),
+			    GFP_KERNEL);
 	if (!bio_slabs)
 		panic("bio: can't allocate bios\n");
 
* Unmerged path fs/btrfs/check-integrity.c
* Unmerged path fs/cifs/cifssmb.c
* Unmerged path fs/cifs/file.c
* Unmerged path fs/ext4/extents.c
diff --git a/fs/nfs/flexfilelayout/flexfilelayout.c b/fs/nfs/flexfilelayout/flexfilelayout.c
index f31b869adf8f..39364313d96c 100644
--- a/fs/nfs/flexfilelayout/flexfilelayout.c
+++ b/fs/nfs/flexfilelayout/flexfilelayout.c
@@ -462,7 +462,7 @@ ff_layout_alloc_lseg(struct pnfs_layout_hdr *lh,
 		fh_count = be32_to_cpup(p);
 
 		fls->mirror_array[i]->fh_versions =
-			kzalloc(fh_count * sizeof(struct nfs_fh),
+			kcalloc(fh_count, sizeof(struct nfs_fh),
 				gfp_flags);
 		if (fls->mirror_array[i]->fh_versions == NULL) {
 			rc = -ENOMEM;
diff --git a/fs/nfs/flexfilelayout/flexfilelayoutdev.c b/fs/nfs/flexfilelayout/flexfilelayoutdev.c
index 7a54a9dbe119..35583a16fd3d 100644
--- a/fs/nfs/flexfilelayout/flexfilelayoutdev.c
+++ b/fs/nfs/flexfilelayout/flexfilelayoutdev.c
@@ -98,7 +98,8 @@ nfs4_ff_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,
 	version_count = be32_to_cpup(p);
 	dprintk("%s: version count %d\n", __func__, version_count);
 
-	ds_versions = kzalloc(version_count * sizeof(struct nfs4_ff_ds_version),
+	ds_versions = kcalloc(version_count,
+			      sizeof(struct nfs4_ff_ds_version),
 			      gfp_flags);
 	if (!ds_versions)
 		goto out_scratch;
diff --git a/fs/nfsd/export.c b/fs/nfsd/export.c
index 27459a453bb8..a0c64961dbed 100644
--- a/fs/nfsd/export.c
+++ b/fs/nfsd/export.c
@@ -403,8 +403,9 @@ fsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc)
 	if (fsloc->locations_count == 0)
 		return 0;
 
-	fsloc->locations = kzalloc(fsloc->locations_count
-			* sizeof(struct nfsd4_fs_location), GFP_KERNEL);
+	fsloc->locations = kcalloc(fsloc->locations_count,
+				   sizeof(struct nfsd4_fs_location),
+				   GFP_KERNEL);
 	if (!fsloc->locations)
 		return -ENOMEM;
 	for (i=0; i < fsloc->locations_count; i++) {
diff --git a/fs/ocfs2/journal.c b/fs/ocfs2/journal.c
index 8eccfabcd12e..1d21106b2d68 100644
--- a/fs/ocfs2/journal.c
+++ b/fs/ocfs2/journal.c
@@ -1306,7 +1306,7 @@ static int __ocfs2_recovery_thread(void *arg)
 		goto bail;
 	}
 
-	rm_quota = kzalloc(osb->max_slots * sizeof(int), GFP_NOFS);
+	rm_quota = kcalloc(osb->max_slots, sizeof(int), GFP_NOFS);
 	if (!rm_quota) {
 		status = -ENOMEM;
 		goto bail;
diff --git a/fs/ocfs2/sysfile.c b/fs/ocfs2/sysfile.c
index f053688d22a3..6c2d480bcaec 100644
--- a/fs/ocfs2/sysfile.c
+++ b/fs/ocfs2/sysfile.c
@@ -69,10 +69,11 @@ static struct inode **get_local_system_inode(struct ocfs2_super *osb,
 	spin_unlock(&osb->osb_lock);
 
 	if (unlikely(!local_system_inodes)) {
-		local_system_inodes = kzalloc(sizeof(struct inode *) *
-					      NUM_LOCAL_SYSTEM_INODES *
-					      osb->max_slots,
-					      GFP_NOFS);
+		local_system_inodes =
+			kzalloc(array3_size(sizeof(struct inode *),
+					    NUM_LOCAL_SYSTEM_INODES,
+					    osb->max_slots),
+				GFP_NOFS);
 		if (!local_system_inodes) {
 			mlog_errno(-ENOMEM);
 			/*
* Unmerged path fs/overlayfs/namei.c
diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c
index df9e927d244d..ed3d540b878d 100644
--- a/fs/proc/proc_sysctl.c
+++ b/fs/proc/proc_sysctl.c
@@ -1379,7 +1379,7 @@ static int register_leaf_sysctl_tables(const char *path, char *pos,
 	/* If there are mixed files and directories we need a new table */
 	if (nr_dirs && nr_files) {
 		struct ctl_table *new;
-		files = kzalloc(sizeof(struct ctl_table) * (nr_files + 1),
+		files = kcalloc(nr_files + 1, sizeof(struct ctl_table),
 				GFP_KERNEL);
 		if (!files)
 			goto out;
diff --git a/fs/reiserfs/inode.c b/fs/reiserfs/inode.c
index a3aae8634a3e..1839bf5e11fd 100644
--- a/fs/reiserfs/inode.c
+++ b/fs/reiserfs/inode.c
@@ -944,7 +944,8 @@ int reiserfs_get_block(struct inode *inode, sector_t block,
 			if (blocks_needed == 1) {
 				un = &unf_single;
 			} else {
-				un = kzalloc(min(blocks_needed, max_to_insert) * UNFM_P_SIZE, GFP_NOFS);
+				un = kcalloc(min(blocks_needed, max_to_insert),
+					     UNFM_P_SIZE, GFP_NOFS);
 				if (!un) {
 					un = &unf_single;
 					blocks_needed = 1;
* Unmerged path fs/udf/super.c
* Unmerged path kernel/bpf/verifier.c
diff --git a/kernel/debug/kdb/kdb_main.c b/kernel/debug/kdb/kdb_main.c
index 0b097c8a1e50..e6ad3cf903f5 100644
--- a/kernel/debug/kdb/kdb_main.c
+++ b/kernel/debug/kdb/kdb_main.c
@@ -647,7 +647,7 @@ static int kdb_defcmd2(const char *cmdstr, const char *argv0)
 	}
 	if (!s->usable)
 		return KDB_NOTIMP;
-	s->command = kzalloc((s->count + 1) * sizeof(*(s->command)), GFP_KDB);
+	s->command = kcalloc(s->count + 1, sizeof(*(s->command)), GFP_KDB);
 	if (!s->command) {
 		kdb_printf("Could not allocate new kdb_defcmd table for %s\n",
 			   cmdstr);
diff --git a/kernel/events/uprobes.c b/kernel/events/uprobes.c
index 13ed569db7eb..9e4023302d7f 100644
--- a/kernel/events/uprobes.c
+++ b/kernel/events/uprobes.c
@@ -1125,7 +1125,8 @@ static struct xol_area *__create_xol_area(unsigned long vaddr)
 	if (unlikely(!area))
 		goto out;
 
-	area->bitmap = kzalloc(BITS_TO_LONGS(UINSNS_PER_PAGE) * sizeof(long), GFP_KERNEL);
+	area->bitmap = kcalloc(BITS_TO_LONGS(UINSNS_PER_PAGE), sizeof(long),
+			       GFP_KERNEL);
 	if (!area->bitmap)
 		goto free_area;
 
* Unmerged path kernel/locking/locktorture.c
diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index 381125ae2591..5cc1b3546fa8 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -7672,10 +7672,10 @@ int alloc_fair_sched_group(struct task_group *tg, struct task_group *parent)
 	struct sched_entity *se;
 	int i;
 
-	tg->cfs_rq = kzalloc(sizeof(cfs_rq) * nr_cpu_ids, GFP_KERNEL);
+	tg->cfs_rq = kcalloc(nr_cpu_ids, sizeof(cfs_rq), GFP_KERNEL);
 	if (!tg->cfs_rq)
 		goto err;
-	tg->se = kzalloc(sizeof(se) * nr_cpu_ids, GFP_KERNEL);
+	tg->se = kcalloc(nr_cpu_ids, sizeof(se), GFP_KERNEL);
 	if (!tg->se)
 		goto err;
 
diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c
index 6b68ceb9a68d..699c4d7ea042 100644
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@ -163,10 +163,10 @@ int alloc_rt_sched_group(struct task_group *tg, struct task_group *parent)
 	struct sched_rt_entity *rt_se;
 	int i;
 
-	tg->rt_rq = kzalloc(sizeof(rt_rq) * nr_cpu_ids, GFP_KERNEL);
+	tg->rt_rq = kcalloc(nr_cpu_ids, sizeof(rt_rq), GFP_KERNEL);
 	if (!tg->rt_rq)
 		goto err;
-	tg->rt_se = kzalloc(sizeof(rt_se) * nr_cpu_ids, GFP_KERNEL);
+	tg->rt_se = kcalloc(nr_cpu_ids, sizeof(rt_se), GFP_KERNEL);
 	if (!tg->rt_se)
 		goto err;
 
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index bd08bee1cd68..581f4690744a 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -3017,7 +3017,8 @@ int proc_do_large_bitmap(struct ctl_table *table, int write,
                 }
 		kbuf[left] = 0;
 
-		tmp_bitmap = kzalloc(BITS_TO_LONGS(bitmap_len) * sizeof(unsigned long),
+		tmp_bitmap = kcalloc(BITS_TO_LONGS(bitmap_len),
+				     sizeof(unsigned long),
 				     GFP_KERNEL);
 		if (!tmp_bitmap) {
 			free_page(page);
diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index 6a691495c059..ae07c294d63b 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -775,7 +775,7 @@ static int ftrace_profile_init_cpu(int cpu)
 	 */
 	size = FTRACE_PROFILE_HASH_SIZE;
 
-	stat->hash = kzalloc(sizeof(struct hlist_head) * size, GFP_KERNEL);
+	stat->hash = kcalloc(size, sizeof(struct hlist_head), GFP_KERNEL);
 
 	if (!stat->hash)
 		return -ENOMEM;
* Unmerged path kernel/trace/trace.c
* Unmerged path kernel/workqueue.c
diff --git a/lib/lru_cache.c b/lib/lru_cache.c
index 4a83ecd03650..751bd36c7ee0 100644
--- a/lib/lru_cache.c
+++ b/lib/lru_cache.c
@@ -119,7 +119,7 @@ struct lru_cache *lc_create(const char *name, struct kmem_cache *cache,
 	slot = kcalloc(e_count, sizeof(struct hlist_head), GFP_KERNEL);
 	if (!slot)
 		goto out_fail;
-	element = kzalloc(e_count * sizeof(struct lc_element *), GFP_KERNEL);
+	element = kcalloc(e_count, sizeof(struct lc_element *), GFP_KERNEL);
 	if (!element)
 		goto out_fail;
 
diff --git a/lib/mpi/mpiutil.c b/lib/mpi/mpiutil.c
index 314f4dfa603e..ead93cce01df 100644
--- a/lib/mpi/mpiutil.c
+++ b/lib/mpi/mpiutil.c
@@ -98,7 +98,7 @@ int mpi_resize(MPI a, unsigned nlimbs)
 		kzfree(a->d);
 		a->d = p;
 	} else {
-		a->d = kzalloc(nlimbs * sizeof(mpi_limb_t), GFP_KERNEL);
+		a->d = kcalloc(nlimbs, sizeof(mpi_limb_t), GFP_KERNEL);
 		if (!a->d)
 			return -ENOMEM;
 	}
diff --git a/mm/slab.c b/mm/slab.c
index 0a4735511ea7..1ef9434c5dd1 100644
--- a/mm/slab.c
+++ b/mm/slab.c
@@ -4417,7 +4417,8 @@ static int leaks_show(struct seq_file *m, void *p)
 	if (x[0] == x[1]) {
 		/* Increase the buffer size */
 		mutex_unlock(&slab_mutex);
-		m->private = kzalloc(x[0] * 4 * sizeof(unsigned long), GFP_KERNEL);
+		m->private = kcalloc(x[0] * 4, sizeof(unsigned long),
+				     GFP_KERNEL);
 		if (!m->private) {
 			/* Too bad, we are really out */
 			m->private = x;
* Unmerged path mm/slub.c
diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c
index 6e1b81f42a3f..6071ac84255b 100644
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@ -331,7 +331,7 @@ static int br_mdb_rehash(struct net_bridge_mdb_htable __rcu **mdbp, int max,
 	mdb->max = max;
 	mdb->old = old;
 
-	mdb->mhash = kzalloc(max * sizeof(*mdb->mhash), GFP_ATOMIC);
+	mdb->mhash = kcalloc(max, sizeof(*mdb->mhash), GFP_ATOMIC);
 	if (!mdb->mhash) {
 		kfree(mdb);
 		return -ENOMEM;
* Unmerged path net/can/bcm.c
diff --git a/net/core/ethtool.c b/net/core/ethtool.c
index 396a7c77a080..59dabd4c704a 100644
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@ -939,7 +939,7 @@ static noinline_for_stack int ethtool_get_sset_info(struct net_device *dev,
 	memset(&info, 0, sizeof(info));
 	info.cmd = ETHTOOL_GSSET_INFO;
 
-	info_buf = kzalloc(n_bits * sizeof(u32), GFP_USER);
+	info_buf = kcalloc(n_bits, sizeof(u32), GFP_USER);
 	if (!info_buf)
 		return -ENOMEM;
 
@@ -1040,7 +1040,7 @@ static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,
 	if (info.cmd == ETHTOOL_GRXCLSRLALL) {
 		if (info.rule_cnt > 0) {
 			if (info.rule_cnt <= KMALLOC_MAX_SIZE / sizeof(u32))
-				rule_buf = kzalloc(info.rule_cnt * sizeof(u32),
+				rule_buf = kcalloc(info.rule_cnt, sizeof(u32),
 						   GFP_USER);
 			if (!rule_buf)
 				return -ENOMEM;
diff --git a/net/ieee802154/nl-phy.c b/net/ieee802154/nl-phy.c
index 76bd1488aa48..766244fd1f74 100644
--- a/net/ieee802154/nl-phy.c
+++ b/net/ieee802154/nl-phy.c
@@ -38,7 +38,7 @@ static int ieee802154_nl_fill_phy(struct sk_buff *msg, u32 portid,
 {
 	void *hdr;
 	int i, pages = 0;
-	uint32_t *buf = kzalloc(32 * sizeof(uint32_t), GFP_KERNEL);
+	uint32_t *buf = kcalloc(32, sizeof(uint32_t), GFP_KERNEL);
 
 	pr_debug("%s\n", __func__);
 
* Unmerged path net/ipv4/fib_frontend.c
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 1ca3ee23b3a6..5c8c25135360 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -664,7 +664,7 @@ static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,
 
 	hash = rcu_dereference(nh->nh_exceptions);
 	if (!hash) {
-		hash = kzalloc(FNHE_HASH_SIZE * sizeof(*hash), GFP_ATOMIC);
+		hash = kcalloc(FNHE_HASH_SIZE, sizeof(*hash), GFP_ATOMIC);
 		if (!hash)
 			goto out_unlock;
 		rcu_assign_pointer(nh->nh_exceptions, hash);
* Unmerged path net/ipv6/icmp.c
diff --git a/net/mac80211/chan.c b/net/mac80211/chan.c
index 89178b46b32f..d9558ffb8acf 100644
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@ -1186,7 +1186,7 @@ static int ieee80211_chsw_switch_vifs(struct ieee80211_local *local,
 	lockdep_assert_held(&local->mtx);
 	lockdep_assert_held(&local->chanctx_mtx);
 
-	vif_chsw = kzalloc(sizeof(vif_chsw[0]) * n_vifs, GFP_KERNEL);
+	vif_chsw = kcalloc(n_vifs, sizeof(vif_chsw[0]), GFP_KERNEL);
 	if (!vif_chsw)
 		return -ENOMEM;
 
diff --git a/net/mac80211/rc80211_minstrel.c b/net/mac80211/rc80211_minstrel.c
index 9766c1cc4b0a..b92da5dfca70 100644
--- a/net/mac80211/rc80211_minstrel.c
+++ b/net/mac80211/rc80211_minstrel.c
@@ -592,7 +592,7 @@ minstrel_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)
 			max_rates = sband->n_bitrates;
 	}
 
-	mi->r = kzalloc(sizeof(struct minstrel_rate) * max_rates, gfp);
+	mi->r = kcalloc(max_rates, sizeof(struct minstrel_rate), gfp);
 	if (!mi->r)
 		goto error;
 
diff --git a/net/mac80211/rc80211_minstrel_ht.c b/net/mac80211/rc80211_minstrel_ht.c
index 4a5bdad9f303..d32a5692a28c 100644
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -1313,7 +1313,7 @@ minstrel_ht_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)
 	if (!msp)
 		return NULL;
 
-	msp->ratelist = kzalloc(sizeof(struct minstrel_rate) * max_rates, gfp);
+	msp->ratelist = kcalloc(max_rates, sizeof(struct minstrel_rate), gfp);
 	if (!msp->ratelist)
 		goto error;
 
diff --git a/net/mac80211/scan.c b/net/mac80211/scan.c
index 47d2ed570470..af9ef59a0513 100644
--- a/net/mac80211/scan.c
+++ b/net/mac80211/scan.c
@@ -1136,7 +1136,7 @@ int __ieee80211_request_sched_scan_start(struct ieee80211_sub_if_data *sdata,
 		}
 	}
 
-	ie = kzalloc(num_bands * iebufsz, GFP_KERNEL);
+	ie = kcalloc(iebufsz, num_bands, GFP_KERNEL);
 	if (!ie) {
 		ret = -ENOMEM;
 		goto out;
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index ba73e9893408..77d173cf3174 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -1809,8 +1809,9 @@ static int ieee80211_reconfig_nan(struct ieee80211_sub_if_data *sdata)
 	if (WARN_ON(res))
 		return res;
 
-	funcs = kzalloc((sdata->local->hw.max_nan_de_entries + 1) *
-			sizeof(*funcs), GFP_KERNEL);
+	funcs = kcalloc(sdata->local->hw.max_nan_de_entries + 1,
+			sizeof(*funcs),
+			GFP_KERNEL);
 	if (!funcs)
 		return -ENOMEM;
 
* Unmerged path net/netfilter/nf_tables_api.c
* Unmerged path net/netfilter/nfnetlink_cthelper.c
diff --git a/net/netrom/af_netrom.c b/net/netrom/af_netrom.c
index a3322646a667..802eada38c92 100644
--- a/net/netrom/af_netrom.c
+++ b/net/netrom/af_netrom.c
@@ -1407,7 +1407,7 @@ static int __init nr_proto_init(void)
 		return -1;
 	}
 
-	dev_nr = kzalloc(nr_ndevs * sizeof(struct net_device *), GFP_KERNEL);
+	dev_nr = kcalloc(nr_ndevs, sizeof(struct net_device *), GFP_KERNEL);
 	if (dev_nr == NULL) {
 		printk(KERN_ERR "NET/ROM: nr_proto_init - unable to allocate device array\n");
 		return -1;
diff --git a/net/openvswitch/vport.c b/net/openvswitch/vport.c
index b6c8524032a0..da2a77c67b4c 100644
--- a/net/openvswitch/vport.c
+++ b/net/openvswitch/vport.c
@@ -47,7 +47,7 @@ static struct hlist_head *dev_table;
  */
 int ovs_vport_init(void)
 {
-	dev_table = kzalloc(VPORT_HASH_BUCKETS * sizeof(struct hlist_head),
+	dev_table = kcalloc(VPORT_HASH_BUCKETS, sizeof(struct hlist_head),
 			    GFP_KERNEL);
 	if (!dev_table)
 		return -ENOMEM;
* Unmerged path net/rds/ib.c
diff --git a/net/rose/af_rose.c b/net/rose/af_rose.c
index 708c3a0ee061..64ce5816d2e2 100644
--- a/net/rose/af_rose.c
+++ b/net/rose/af_rose.c
@@ -1533,7 +1533,8 @@ static int __init rose_proto_init(void)
 
 	rose_callsign = null_ax25_address;
 
-	dev_rose = kzalloc(rose_ndevs * sizeof(struct net_device *), GFP_KERNEL);
+	dev_rose = kcalloc(rose_ndevs, sizeof(struct net_device *),
+			   GFP_KERNEL);
 	if (dev_rose == NULL) {
 		printk(KERN_ERR "ROSE: rose_proto_init - unable to allocate device structure\n");
 		rc = -ENOMEM;
* Unmerged path net/sctp/auth.c
* Unmerged path net/smc/smc_wr.c
diff --git a/net/sunrpc/auth_gss/gss_rpc_upcall.c b/net/sunrpc/auth_gss/gss_rpc_upcall.c
index fb2fddb1ce21..ea5d9b314dbf 100644
--- a/net/sunrpc/auth_gss/gss_rpc_upcall.c
+++ b/net/sunrpc/auth_gss/gss_rpc_upcall.c
@@ -224,7 +224,7 @@ static void gssp_free_receive_pages(struct gssx_arg_accept_sec_context *arg)
 static int gssp_alloc_receive_pages(struct gssx_arg_accept_sec_context *arg)
 {
 	arg->npages = DIV_ROUND_UP(NGROUPS_MAX * 4, PAGE_SIZE);
-	arg->pages = kzalloc(arg->npages * sizeof(struct page *), GFP_KERNEL);
+	arg->pages = kcalloc(arg->npages, sizeof(struct page *), GFP_KERNEL);
 	/*
 	 * XXX: actual pages are allocated by xdr layer in
 	 * xdr_partial_copy_from_skb.
* Unmerged path net/sunrpc/cache.c
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 6c9c7561a9f7..c5397b9097ce 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -10460,7 +10460,7 @@ static int nl80211_parse_wowlan_nd(struct cfg80211_registered_device *rdev,
 	struct nlattr **tb;
 	int err;
 
-	tb = kzalloc(NUM_NL80211_ATTR * sizeof(*tb), GFP_KERNEL);
+	tb = kcalloc(NUM_NL80211_ATTR, sizeof(*tb), GFP_KERNEL);
 	if (!tb)
 		return -ENOMEM;
 
@@ -11417,7 +11417,7 @@ static int nl80211_nan_add_func(struct sk_buff *skb,
 
 			func->srf_num_macs = n_entries;
 			func->srf_macs =
-				kzalloc(sizeof(*func->srf_macs) * n_entries,
+				kcalloc(n_entries, sizeof(*func->srf_macs),
 					GFP_KERNEL);
 			if (!func->srf_macs) {
 				err = -ENOMEM;
diff --git a/security/apparmor/policy_unpack.c b/security/apparmor/policy_unpack.c
index 329b1fd30749..5a3c8f1fa1ff 100644
--- a/security/apparmor/policy_unpack.c
+++ b/security/apparmor/policy_unpack.c
@@ -376,7 +376,7 @@ static bool unpack_trans_table(struct aa_ext *e, struct aa_profile *profile)
 		/* currently 4 exec bits and entries 0-3 are reserved iupcx */
 		if (size > 16 - 4)
 			goto fail;
-		profile->file.trans.table = kzalloc(sizeof(char *) * size,
+		profile->file.trans.table = kcalloc(size, sizeof(char *),
 						    GFP_KERNEL);
 		if (!profile->file.trans.table)
 			goto fail;
diff --git a/security/selinux/ss/services.c b/security/selinux/ss/services.c
index f2e85744961c..9df72595fe6d 100644
--- a/security/selinux/ss/services.c
+++ b/security/selinux/ss/services.c
@@ -2022,7 +2022,7 @@ int security_load_policy(void *data, size_t len)
 	int rc = 0;
 	struct policy_file file = { data, len }, *fp = &file;
 
-	oldpolicydb = kzalloc(2 * sizeof(*oldpolicydb), GFP_KERNEL);
+	oldpolicydb = kcalloc(2, sizeof(*oldpolicydb), GFP_KERNEL);
 	if (!oldpolicydb) {
 		rc = -ENOMEM;
 		goto out;
* Unmerged path sound/firewire/fireface/ff-protocol-ff400.c
diff --git a/sound/pci/ctxfi/ctatc.c b/sound/pci/ctxfi/ctatc.c
index 908658a00377..2ada8444abd9 100644
--- a/sound/pci/ctxfi/ctatc.c
+++ b/sound/pci/ctxfi/ctatc.c
@@ -275,7 +275,7 @@ static int atc_pcm_playback_prepare(struct ct_atc *atc, struct ct_atc_pcm *apcm)
 
 	/* Get AMIXER resource */
 	n_amixer = (n_amixer < 2) ? 2 : n_amixer;
-	apcm->amixers = kzalloc(sizeof(void *)*n_amixer, GFP_KERNEL);
+	apcm->amixers = kcalloc(n_amixer, sizeof(void *), GFP_KERNEL);
 	if (!apcm->amixers) {
 		err = -ENOMEM;
 		goto error1;
@@ -543,18 +543,18 @@ atc_pcm_capture_get_resources(struct ct_atc *atc, struct ct_atc_pcm *apcm)
 	}
 
 	if (n_srcc) {
-		apcm->srccs = kzalloc(sizeof(void *)*n_srcc, GFP_KERNEL);
+		apcm->srccs = kcalloc(n_srcc, sizeof(void *), GFP_KERNEL);
 		if (!apcm->srccs)
 			return -ENOMEM;
 	}
 	if (n_amixer) {
-		apcm->amixers = kzalloc(sizeof(void *)*n_amixer, GFP_KERNEL);
+		apcm->amixers = kcalloc(n_amixer, sizeof(void *), GFP_KERNEL);
 		if (!apcm->amixers) {
 			err = -ENOMEM;
 			goto error1;
 		}
 	}
-	apcm->srcimps = kzalloc(sizeof(void *)*n_srcimp, GFP_KERNEL);
+	apcm->srcimps = kcalloc(n_srcimp, sizeof(void *), GFP_KERNEL);
 	if (!apcm->srcimps) {
 		err = -ENOMEM;
 		goto error1;
@@ -819,7 +819,7 @@ static int spdif_passthru_playback_get_resources(struct ct_atc *atc,
 
 	/* Get AMIXER resource */
 	n_amixer = (n_amixer < 2) ? 2 : n_amixer;
-	apcm->amixers = kzalloc(sizeof(void *)*n_amixer, GFP_KERNEL);
+	apcm->amixers = kcalloc(n_amixer, sizeof(void *), GFP_KERNEL);
 	if (!apcm->amixers) {
 		err = -ENOMEM;
 		goto error1;
@@ -1378,19 +1378,19 @@ static int atc_get_resources(struct ct_atc *atc)
 	num_daios = ((atc->model == CTSB1270) ? 8 : 7);
 	num_srcs = ((atc->model == CTSB1270) ? 6 : 4);
 
-	atc->daios = kzalloc(sizeof(void *)*num_daios, GFP_KERNEL);
+	atc->daios = kcalloc(num_daios, sizeof(void *), GFP_KERNEL);
 	if (!atc->daios)
 		return -ENOMEM;
 
-	atc->srcs = kzalloc(sizeof(void *)*num_srcs, GFP_KERNEL);
+	atc->srcs = kcalloc(num_srcs, sizeof(void *), GFP_KERNEL);
 	if (!atc->srcs)
 		return -ENOMEM;
 
-	atc->srcimps = kzalloc(sizeof(void *)*num_srcs, GFP_KERNEL);
+	atc->srcimps = kcalloc(num_srcs, sizeof(void *), GFP_KERNEL);
 	if (!atc->srcimps)
 		return -ENOMEM;
 
-	atc->pcm = kzalloc(sizeof(void *)*(2*4), GFP_KERNEL);
+	atc->pcm = kcalloc(2 * 4, sizeof(void *), GFP_KERNEL);
 	if (!atc->pcm)
 		return -ENOMEM;
 
diff --git a/sound/pci/ctxfi/ctdaio.c b/sound/pci/ctxfi/ctdaio.c
index 7f089cb433e1..f35a7341e446 100644
--- a/sound/pci/ctxfi/ctdaio.c
+++ b/sound/pci/ctxfi/ctdaio.c
@@ -398,7 +398,8 @@ static int dao_rsc_init(struct dao *dao,
 	if (err)
 		return err;
 
-	dao->imappers = kzalloc(sizeof(void *)*desc->msr*2, GFP_KERNEL);
+	dao->imappers = kzalloc(array3_size(sizeof(void *), desc->msr, 2),
+				GFP_KERNEL);
 	if (!dao->imappers) {
 		err = -ENOMEM;
 		goto error1;
diff --git a/sound/pci/ctxfi/ctmixer.c b/sound/pci/ctxfi/ctmixer.c
index da66499d6668..4777d50fbbf8 100644
--- a/sound/pci/ctxfi/ctmixer.c
+++ b/sound/pci/ctxfi/ctmixer.c
@@ -910,13 +910,14 @@ static int ct_mixer_get_mem(struct ct_mixer **rmixer)
 	if (!mixer)
 		return -ENOMEM;
 
-	mixer->amixers = kzalloc(sizeof(void *)*(NUM_CT_AMIXERS*CHN_NUM),
+	mixer->amixers = kcalloc(NUM_CT_AMIXERS * CHN_NUM, sizeof(void *),
 				 GFP_KERNEL);
 	if (!mixer->amixers) {
 		err = -ENOMEM;
 		goto error1;
 	}
-	mixer->sums = kzalloc(sizeof(void *)*(NUM_CT_SUMS*CHN_NUM), GFP_KERNEL);
+	mixer->sums = kcalloc(NUM_CT_SUMS * CHN_NUM, sizeof(void *),
+			      GFP_KERNEL);
 	if (!mixer->sums) {
 		err = -ENOMEM;
 		goto error2;
diff --git a/sound/pci/ctxfi/ctsrc.c b/sound/pci/ctxfi/ctsrc.c
index bb4c9c3c89ae..a4fc10723fc6 100644
--- a/sound/pci/ctxfi/ctsrc.c
+++ b/sound/pci/ctxfi/ctsrc.c
@@ -679,7 +679,7 @@ static int srcimp_rsc_init(struct srcimp *srcimp,
 		return err;
 
 	/* Reserve memory for imapper nodes */
-	srcimp->imappers = kzalloc(sizeof(struct imapper)*desc->msr,
+	srcimp->imappers = kcalloc(desc->msr, sizeof(struct imapper),
 				   GFP_KERNEL);
 	if (!srcimp->imappers) {
 		err = -ENOMEM;
* Unmerged path sound/pci/hda/patch_ca0132.c
* Unmerged path sound/soc/codecs/wm_adsp.c
diff --git a/sound/soc/intel/common/sst-ipc.c b/sound/soc/intel/common/sst-ipc.c
index 62f3a8e0ec87..dcff13802c00 100644
--- a/sound/soc/intel/common/sst-ipc.c
+++ b/sound/soc/intel/common/sst-ipc.c
@@ -121,8 +121,8 @@ static int msg_empty_list_init(struct sst_generic_ipc *ipc)
 {
 	int i;
 
-	ipc->msg = kzalloc(sizeof(struct ipc_message) *
-		IPC_EMPTY_LIST_SIZE, GFP_KERNEL);
+	ipc->msg = kcalloc(IPC_EMPTY_LIST_SIZE, sizeof(struct ipc_message),
+			   GFP_KERNEL);
 	if (ipc->msg == NULL)
 		return -ENOMEM;
 
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9f9e9110c31c..eb78070a68a6 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -570,8 +570,8 @@ static struct snd_soc_pcm_runtime *soc_new_pcm_runtime(
 	if (!rtd->dai_link->ops)
 		rtd->dai_link->ops = &null_snd_soc_ops;
 
-	rtd->codec_dais = kzalloc(sizeof(struct snd_soc_dai *) *
-					dai_link->num_codecs,
+	rtd->codec_dais = kcalloc(dai_link->num_codecs,
+					sizeof(struct snd_soc_dai *),
 					GFP_KERNEL);
 	if (!rtd->codec_dais) {
 		kfree(rtd);
diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c
index 84ab79ffba0b..fbe3eaa0ef17 100644
--- a/sound/soc/soc-dapm.c
+++ b/sound/soc/soc-dapm.c
@@ -3057,7 +3057,7 @@ int snd_soc_dapm_new_widgets(struct snd_soc_card *card)
 			continue;
 
 		if (w->num_kcontrols) {
-			w->kcontrols = kzalloc(w->num_kcontrols *
+			w->kcontrols = kcalloc(w->num_kcontrols,
 						sizeof(struct snd_kcontrol *),
 						GFP_KERNEL);
 			if (!w->kcontrols) {
diff --git a/sound/soc/soc-topology.c b/sound/soc/soc-topology.c
index 986b8b2f90fb..e12700220712 100644
--- a/sound/soc/soc-topology.c
+++ b/sound/soc/soc-topology.c
@@ -941,7 +941,7 @@ static int soc_tplg_denum_create_texts(struct soc_enum *se,
 	int i, ret;
 
 	se->dobj.control.dtexts =
-		kzalloc(sizeof(char *) * ec->items, GFP_KERNEL);
+		kcalloc(ec->items, sizeof(char *), GFP_KERNEL);
 	if (se->dobj.control.dtexts == NULL)
 		return -ENOMEM;
 
diff --git a/sound/usb/6fire/pcm.c b/sound/usb/6fire/pcm.c
index 224a6a5d1c0e..2dd2518a71d3 100644
--- a/sound/usb/6fire/pcm.c
+++ b/sound/usb/6fire/pcm.c
@@ -591,12 +591,14 @@ static int usb6fire_pcm_buffers_init(struct pcm_runtime *rt)
 	int i;
 
 	for (i = 0; i < PCM_N_URBS; i++) {
-		rt->out_urbs[i].buffer = kzalloc(PCM_N_PACKETS_PER_URB
-				* PCM_MAX_PACKET_SIZE, GFP_KERNEL);
+		rt->out_urbs[i].buffer = kcalloc(PCM_MAX_PACKET_SIZE,
+						 PCM_N_PACKETS_PER_URB,
+						 GFP_KERNEL);
 		if (!rt->out_urbs[i].buffer)
 			return -ENOMEM;
-		rt->in_urbs[i].buffer = kzalloc(PCM_N_PACKETS_PER_URB
-				* PCM_MAX_PACKET_SIZE, GFP_KERNEL);
+		rt->in_urbs[i].buffer = kcalloc(PCM_MAX_PACKET_SIZE,
+						PCM_N_PACKETS_PER_URB,
+						GFP_KERNEL);
 		if (!rt->in_urbs[i].buffer)
 			return -ENOMEM;
 	}
diff --git a/sound/usb/line6/capture.c b/sound/usb/line6/capture.c
index 947d6168f24a..d8a14d769f48 100644
--- a/sound/usb/line6/capture.c
+++ b/sound/usb/line6/capture.c
@@ -264,8 +264,8 @@ int line6_create_audio_in_urbs(struct snd_line6_pcm *line6pcm)
 	struct usb_line6 *line6 = line6pcm->line6;
 	int i;
 
-	line6pcm->in.urbs = kzalloc(
-		sizeof(struct urb *) * line6->iso_buffers, GFP_KERNEL);
+	line6pcm->in.urbs = kcalloc(line6->iso_buffers, sizeof(struct urb *),
+				    GFP_KERNEL);
 	if (line6pcm->in.urbs == NULL)
 		return -ENOMEM;
 
diff --git a/sound/usb/line6/playback.c b/sound/usb/line6/playback.c
index 819e9b2d1d6e..dec89d2beb57 100644
--- a/sound/usb/line6/playback.c
+++ b/sound/usb/line6/playback.c
@@ -409,8 +409,8 @@ int line6_create_audio_out_urbs(struct snd_line6_pcm *line6pcm)
 	struct usb_line6 *line6 = line6pcm->line6;
 	int i;
 
-	line6pcm->out.urbs = kzalloc(
-		sizeof(struct urb *) * line6->iso_buffers, GFP_KERNEL);
+	line6pcm->out.urbs = kcalloc(line6->iso_buffers, sizeof(struct urb *),
+				     GFP_KERNEL);
 	if (line6pcm->out.urbs == NULL)
 		return -ENOMEM;
 
* Unmerged path virt/kvm/arm/vgic/vgic-v4.c
