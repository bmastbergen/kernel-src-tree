fuse: avoid scheduling while atomic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit c55a01d360afafcd52bc405c044a6ebf5de436d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c55a01d3.failed

As reported by Richard Sharpe, an attempt to use fuse_notify_inval_entry()
triggers complains about scheduling while atomic:

  BUG: scheduling while atomic: fuse.hf/13976/0x10000001

This happens because fuse_notify_inval_entry() attempts to allocate memory
with GFP_KERNEL, holding "struct fuse_copy_state" mapped by kmap_atomic().

Introduced by commit 58bda1da4b3c "fuse/dev: use atomic maps"

Fix by moving the map/unmap to just cover the actual memcpy operation.

Original patch from Maxim Patlasov <mpatlasov@parallels.com>

	Reported-by: Richard Sharpe <realrichardsharpe@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
	Cc: <stable@vger.kernel.org> # v3.15+
(cherry picked from commit c55a01d360afafcd52bc405c044a6ebf5de436d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dev.c
diff --cc fs/fuse/dev.c
index 77c3e9637687,75fa055012b2..000000000000
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@@ -667,16 -665,10 +666,17 @@@ static void fuse_copy_finish(struct fus
  	if (cs->currbuf) {
  		struct pipe_buffer *buf = cs->currbuf;
  
++<<<<<<< HEAD
 +		if (!cs->write) {
 +			buf->ops->unmap(cs->pipe, buf, cs->mapaddr);
 +		} else {
 +			kunmap_atomic(cs->mapaddr);
++=======
+ 		if (cs->write)
++>>>>>>> c55a01d360af (fuse: avoid scheduling while atomic)
  			buf->len = PAGE_SIZE - cs->len;
- 		}
  		cs->currbuf = NULL;
- 		cs->mapaddr = NULL;
- 	} else if (cs->mapaddr) {
- 		kunmap_atomic(cs->mapaddr);
+ 	} else if (cs->pg) {
  		if (cs->write) {
  			flush_dcache_page(cs->pg);
  			set_page_dirty_lock(cs->pg);
@@@ -707,9 -699,9 +707,13 @@@ static int fuse_copy_fill(struct fuse_c
  
  			BUG_ON(!cs->nr_segs);
  			cs->currbuf = buf;
++<<<<<<< HEAD
 +			cs->mapaddr = buf->ops->map(cs->pipe, buf, 1);
++=======
+ 			cs->pg = buf->page;
+ 			cs->offset = buf->offset;
++>>>>>>> c55a01d360af (fuse: avoid scheduling while atomic)
  			cs->len = buf->len;
- 			cs->buf = cs->mapaddr + buf->offset;
  			cs->pipebufs++;
  			cs->nr_segs--;
  		} else {
@@@ -875,8 -869,8 +881,13 @@@ static int fuse_try_move_page(struct fu
  out_fallback_unlock:
  	unlock_page(newpage);
  out_fallback:
++<<<<<<< HEAD
 +	cs->mapaddr = buf->ops->map(cs->pipe, buf, 1);
 +	cs->buf = cs->mapaddr + buf->offset;
++=======
+ 	cs->pg = buf->page;
+ 	cs->offset = buf->offset;
++>>>>>>> c55a01d360af (fuse: avoid scheduling while atomic)
  
  	err = lock_request(cs->fc, cs->req);
  	if (err)
* Unmerged path fs/fuse/dev.c
