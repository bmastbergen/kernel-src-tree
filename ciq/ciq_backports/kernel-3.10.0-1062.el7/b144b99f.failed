s390/qeth: utilize virtual MAC for Layer2 OSD devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [s390] qeth: utilize virtual MAC for Layer2 OSD devices (Hendrik Brueckner) [1640649]
Rebuild_FUZZ: 95.05%
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit b144b99fff69a5bc0d34c8e168bedb88c68ca23d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b144b99f.failed

By default, READ MAC on a Layer2 OSD device returns the adapter's
burnt-in MAC address. Given the default scenario of many virtual devices
on the same adapter, qeth can't make any use of this address and
therefore skips the READ MAC call for this device type.

But in some configurations, the READ MAC command for a Layer2 OSD device
actually returns a pre-provisioned, virtual MAC address. So enable the
READ MAC code to detect this situation, and let the L2 subdriver
call READ MAC for OSD devices.

This also removes the QETH_LAYER2_MAC_READ flag, which protects L2
devices against calling READ MAC multiple times. Instead protect the
whole call to qeth_l2_request_initial_mac().

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b144b99fff69a5bc0d34c8e168bedb88c68ca23d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
#	drivers/s390/net/qeth_core_mpc.h
#	drivers/s390/net/qeth_l2_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index d13f23aa9162,abeecffb6d2e..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -4188,13 -4241,12 +4189,22 @@@ static int qeth_setadpparms_change_maca
  	if (qeth_setadpparms_inspect_rc(cmd))
  		return 0;
  
++<<<<<<< HEAD
 +	if (!card->options.layer2 ||
 +	    !(card->info.mac_bits & QETH_LAYER2_MAC_READ)) {
 +		memcpy(card->dev->dev_addr,
 +		       &cmd->data.setadapterparms.data.change_addr.addr,
 +		       OSA_ADDR_LEN);
 +		card->info.mac_bits |= QETH_LAYER2_MAC_READ;
 +	}
++=======
+ 	adp_cmd = &cmd->data.setadapterparms;
+ 	if (IS_LAYER2(card) && IS_OSD(card) && !IS_VM_NIC(card) &&
+ 	    !(adp_cmd->hdr.flags & QETH_SETADP_FLAGS_VIRTUAL_MAC))
+ 		return 0;
+ 
+ 	ether_addr_copy(card->dev->dev_addr, adp_cmd->data.change_addr.addr);
++>>>>>>> b144b99fff69 (s390/qeth: utilize virtual MAC for Layer2 OSD devices)
  	return 0;
  }
  
diff --cc drivers/s390/net/qeth_core_mpc.h
index 5f06f9906e61,10cc487c16d6..000000000000
--- a/drivers/s390/net/qeth_core_mpc.h
+++ b/drivers/s390/net/qeth_core_mpc.h
@@@ -53,6 -79,11 +53,14 @@@ enum qeth_card_types 
  	QETH_CARD_TYPE_OSX     = 2,
  };
  
++<<<<<<< HEAD
++=======
+ #define IS_IQD(card)	((card)->info.type == QETH_CARD_TYPE_IQD)
+ #define IS_OSD(card)	((card)->info.type == QETH_CARD_TYPE_OSD)
+ #define IS_OSN(card)	((card)->info.type == QETH_CARD_TYPE_OSN)
+ #define IS_VM_NIC(card)	((card)->info.guestlan)
+ 
++>>>>>>> b144b99fff69 (s390/qeth: utilize virtual MAC for Layer2 OSD devices)
  #define QETH_MPC_DIFINFO_LEN_INDICATES_LINK_TYPE 0x18
  /* only the first two bytes are looked at in qeth_get_cardname_short */
  enum qeth_link_types {
diff --cc drivers/s390/net/qeth_l2_main.c
index b9852de25f9b,8d3601891c62..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -702,30 -461,22 +702,41 @@@ static int qeth_l2_request_initial_mac(
  		/* fall back to alternative mechanism: */
  	}
  
++<<<<<<< HEAD
 +	if (qeth_is_supported(card, IPA_SETADAPTERPARMS)) {
 +		rc = qeth_query_setadapterparms(card);
 +		if (rc) {
 +			QETH_DBF_MESSAGE(2, "could not query adapter "
 +				"parameters on device %s: x%x\n",
 +				CARD_BUS_ID(card), rc);
 +		}
 +	}
 +
 +	if (card->info.type == QETH_CARD_TYPE_IQD ||
 +	    card->info.type == QETH_CARD_TYPE_OSM ||
 +	    card->info.type == QETH_CARD_TYPE_OSX ||
 +	    card->info.guestlan) {
 +		rc = qeth_setadpparms_change_macaddr(card);
 +		if (rc) {
 +			QETH_DBF_MESSAGE(2, "couldn't get MAC address on "
 +				"device %s: x%x\n", CARD_BUS_ID(card), rc);
 +			QETH_DBF_TEXT_(SETUP, 2, "1err%d", rc);
 +			return rc;
 +		}
 +	} else {
 +		eth_random_addr(card->dev->dev_addr);
 +		memcpy(card->dev->dev_addr, vendor_pre, 3);
++=======
+ 	if (!IS_OSN(card)) {
+ 		rc = qeth_setadpparms_change_macaddr(card);
+ 		if (!rc && is_valid_ether_addr(card->dev->dev_addr))
+ 			goto out;
+ 		QETH_DBF_MESSAGE(2, "READ_MAC Assist failed on device %x: %#x\n",
+ 				 CARD_DEVID(card), rc);
+ 		QETH_DBF_TEXT_(SETUP, 2, "1err%04x", rc);
+ 		/* fall back once more: */
++>>>>>>> b144b99fff69 (s390/qeth: utilize virtual MAC for Layer2 OSD devices)
  	}
 -
 -	/* some devices don't support a custom MAC address: */
 -	if (card->info.type == QETH_CARD_TYPE_OSM ||
 -	    card->info.type == QETH_CARD_TYPE_OSX)
 -		return (rc) ? rc : -EADDRNOTAVAIL;
 -	eth_hw_addr_random(card->dev);
 -
  out:
  	QETH_DBF_HEX(SETUP, 2, card->dev->dev_addr, card->dev->addr_len);
  	return 0;
@@@ -1099,17 -889,41 +1110,54 @@@ static int qeth_l2_setup_netdev(struct 
  			card->dev->hw_features |= NETIF_F_IP_CSUM;
  			card->dev->vlan_features |= NETIF_F_IP_CSUM;
  		}
 +		if (qeth_is_supported(card, IPA_INBOUND_CHECKSUM)) {
 +			card->dev->hw_features |= NETIF_F_RXCSUM;
 +			card->dev->vlan_features |= NETIF_F_RXCSUM;
 +		}
  	}
++<<<<<<< HEAD
 +	card->info.broadcast_capable = 1;
 +	qeth_l2_request_initial_mac(card);
 +	SET_NETDEV_DEV(card->dev, &card->gdev->dev);
 +	netif_napi_add(card->dev, &card->napi, qeth_l2_poll, QETH_NAPI_WEIGHT);
 +	netif_carrier_off(card->dev);
 +	return register_netdev(card->dev);
++=======
+ 	if (qeth_is_supported6(card, IPA_OUTBOUND_CHECKSUM_V6)) {
+ 		card->dev->hw_features |= NETIF_F_IPV6_CSUM;
+ 		card->dev->vlan_features |= NETIF_F_IPV6_CSUM;
+ 	}
+ 	if (qeth_is_supported(card, IPA_INBOUND_CHECKSUM) ||
+ 	    qeth_is_supported6(card, IPA_INBOUND_CHECKSUM_V6)) {
+ 		card->dev->hw_features |= NETIF_F_RXCSUM;
+ 		card->dev->vlan_features |= NETIF_F_RXCSUM;
+ 	}
+ 	if (qeth_is_supported(card, IPA_OUTBOUND_TSO)) {
+ 		card->dev->hw_features |= NETIF_F_TSO;
+ 		card->dev->vlan_features |= NETIF_F_TSO;
+ 	}
+ 	if (qeth_is_supported6(card, IPA_OUTBOUND_TSO)) {
+ 		card->dev->hw_features |= NETIF_F_TSO6;
+ 		card->dev->vlan_features |= NETIF_F_TSO6;
+ 	}
+ 
+ 	if (card->dev->hw_features & (NETIF_F_TSO | NETIF_F_TSO6)) {
+ 		card->dev->needed_headroom = sizeof(struct qeth_hdr_tso);
+ 		netif_set_gso_max_size(card->dev,
+ 				       PAGE_SIZE * (QDIO_MAX_ELEMENTS_PER_BUFFER - 1));
+ 	}
+ 
+ 	if (!is_valid_ether_addr(card->dev->dev_addr))
+ 		qeth_l2_request_initial_mac(card);
+ 	netif_napi_add(card->dev, &card->napi, qeth_poll, QETH_NAPI_WEIGHT);
+ 	rc = register_netdev(card->dev);
+ 	if (!rc && carrier_ok)
+ 		netif_carrier_on(card->dev);
+ 
+ 	if (rc)
+ 		card->dev->netdev_ops = NULL;
+ 	return rc;
++>>>>>>> b144b99fff69 (s390/qeth: utilize virtual MAC for Layer2 OSD devices)
  }
  
  static int qeth_l2_start_ipassists(struct qeth_card *card)
diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h
index d4437aa7c289..596886b91569 100644
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -664,7 +664,6 @@ struct qeth_card_blkt {
 
 #define QETH_BROADCAST_WITH_ECHO    0x01
 #define QETH_BROADCAST_WITHOUT_ECHO 0x02
-#define QETH_LAYER2_MAC_READ	    0x01
 #define QETH_LAYER2_MAC_REGISTERED  0x02
 struct qeth_card_info {
 	unsigned short unit_addr2;
* Unmerged path drivers/s390/net/qeth_core_main.c
* Unmerged path drivers/s390/net/qeth_core_mpc.h
* Unmerged path drivers/s390/net/qeth_l2_main.c
