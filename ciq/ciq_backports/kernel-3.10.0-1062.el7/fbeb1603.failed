bpf: verifier: MOV64 don't mark dst reg unbounded

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Arthur Fabre <afabre@cloudflare.com>
commit fbeb1603bf4e9baa82da8f794de42949d0fe5e25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fbeb1603.failed

When check_alu_op() handles a BPF_MOV64 between two registers,
it calls check_reg_arg(DST_OP) on the dst register, marking it
as unbounded. If the src and dst register are the same, this
marks the src as unbounded, which can lead to unexpected errors
for further checks that rely on bounds info. For example:

	BPF_MOV64_IMM(BPF_REG_2, 0),
	BPF_MOV64_REG(BPF_REG_2, BPF_REG_2),
	BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),
	BPF_MOV64_IMM(BPF_REG_0, 0),
	BPF_EXIT_INSN(),

Results in:

	"math between ctx pointer and register with unbounded
	min value is not allowed"

check_alu_op() now uses check_reg_arg(DST_OP_NO_MARK), and MOVs
that need to mark the dst register (MOVIMM, MOV32) do so.

Added a test case for MOV64 dst == src, and dst != src.

	Signed-off-by: Arthur Fabre <afabre@cloudflare.com>
	Acked-by: Edward Cree <ecree@solarflare.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit fbeb1603bf4e9baa82da8f794de42949d0fe5e25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/test_verifier.c
diff --cc tools/testing/selftests/bpf/test_verifier.c
index 0a13072fd644,c582afba9d1f..000000000000
--- a/tools/testing/selftests/bpf/test_verifier.c
+++ b/tools/testing/selftests/bpf/test_verifier.c
@@@ -12014,6 -12240,124 +12014,127 @@@ static struct bpf_test tests[] = 
  		.result = ACCEPT,
  		.retval = 10,
  	},
++<<<<<<< HEAD
++=======
+ 	{
+ 		"ld_dw: xor semi-random 64 bit imms, test 1",
+ 		.insns = { },
+ 		.data = { },
+ 		.fill_helper = bpf_fill_rand_ld_dw,
+ 		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+ 		.result = ACCEPT,
+ 		.retval = 4090,
+ 	},
+ 	{
+ 		"ld_dw: xor semi-random 64 bit imms, test 2",
+ 		.insns = { },
+ 		.data = { },
+ 		.fill_helper = bpf_fill_rand_ld_dw,
+ 		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+ 		.result = ACCEPT,
+ 		.retval = 2047,
+ 	},
+ 	{
+ 		"ld_dw: xor semi-random 64 bit imms, test 3",
+ 		.insns = { },
+ 		.data = { },
+ 		.fill_helper = bpf_fill_rand_ld_dw,
+ 		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+ 		.result = ACCEPT,
+ 		.retval = 511,
+ 	},
+ 	{
+ 		"ld_dw: xor semi-random 64 bit imms, test 4",
+ 		.insns = { },
+ 		.data = { },
+ 		.fill_helper = bpf_fill_rand_ld_dw,
+ 		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+ 		.result = ACCEPT,
+ 		.retval = 5,
+ 	},
+ 	{
+ 		"pass unmodified ctx pointer to helper",
+ 		.insns = {
+ 			BPF_MOV64_IMM(BPF_REG_2, 0),
+ 			BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,
+ 				     BPF_FUNC_csum_update),
+ 			BPF_MOV64_IMM(BPF_REG_0, 0),
+ 			BPF_EXIT_INSN(),
+ 		},
+ 		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+ 		.result = ACCEPT,
+ 	},
+ 	{
+ 		"pass modified ctx pointer to helper, 1",
+ 		.insns = {
+ 			BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -612),
+ 			BPF_MOV64_IMM(BPF_REG_2, 0),
+ 			BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,
+ 				     BPF_FUNC_csum_update),
+ 			BPF_MOV64_IMM(BPF_REG_0, 0),
+ 			BPF_EXIT_INSN(),
+ 		},
+ 		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+ 		.result = REJECT,
+ 		.errstr = "dereference of modified ctx ptr",
+ 	},
+ 	{
+ 		"pass modified ctx pointer to helper, 2",
+ 		.insns = {
+ 			BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, -612),
+ 			BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,
+ 				     BPF_FUNC_get_socket_cookie),
+ 			BPF_MOV64_IMM(BPF_REG_0, 0),
+ 			BPF_EXIT_INSN(),
+ 		},
+ 		.result_unpriv = REJECT,
+ 		.result = REJECT,
+ 		.errstr_unpriv = "dereference of modified ctx ptr",
+ 		.errstr = "dereference of modified ctx ptr",
+ 	},
+ 	{
+ 		"pass modified ctx pointer to helper, 3",
+ 		.insns = {
+ 			BPF_LDX_MEM(BPF_W, BPF_REG_3, BPF_REG_1, 0),
+ 			BPF_ALU64_IMM(BPF_AND, BPF_REG_3, 4),
+ 			BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_3),
+ 			BPF_MOV64_IMM(BPF_REG_2, 0),
+ 			BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,
+ 				     BPF_FUNC_csum_update),
+ 			BPF_MOV64_IMM(BPF_REG_0, 0),
+ 			BPF_EXIT_INSN(),
+ 		},
+ 		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+ 		.result = REJECT,
+ 		.errstr = "variable ctx access var_off=(0x0; 0x4)",
+ 	},
+ 	{
+ 		"mov64 src == dst",
+ 		.insns = {
+ 			BPF_MOV64_IMM(BPF_REG_2, 0),
+ 			BPF_MOV64_REG(BPF_REG_2, BPF_REG_2),
+ 			// Check bounds are OK
+ 			BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),
+ 			BPF_MOV64_IMM(BPF_REG_0, 0),
+ 			BPF_EXIT_INSN(),
+ 		},
+ 		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+ 		.result = ACCEPT,
+ 	},
+ 	{
+ 		"mov64 src != dst",
+ 		.insns = {
+ 			BPF_MOV64_IMM(BPF_REG_3, 0),
+ 			BPF_MOV64_REG(BPF_REG_2, BPF_REG_3),
+ 			// Check bounds are OK
+ 			BPF_ALU64_REG(BPF_ADD, BPF_REG_1, BPF_REG_2),
+ 			BPF_MOV64_IMM(BPF_REG_0, 0),
+ 			BPF_EXIT_INSN(),
+ 		},
+ 		.prog_type = BPF_PROG_TYPE_SCHED_CLS,
+ 		.result = ACCEPT,
+ 	},
++>>>>>>> fbeb1603bf4e (bpf: verifier: MOV64 don't mark dst reg unbounded)
  };
  
  static int probe_filter_length(const struct bpf_insn *fp)
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index bd6b277dfa5c..434b4ba0b1c9 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -3108,8 +3108,8 @@ static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)
 			}
 		}
 
-		/* check dest operand */
-		err = check_reg_arg(env, insn->dst_reg, DST_OP);
+		/* check dest operand, mark as required later */
+		err = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);
 		if (err)
 			return err;
 
@@ -3135,6 +3135,8 @@ static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)
 			/* case: R = imm
 			 * remember the value we stored into this reg
 			 */
+			/* clear any state __mark_reg_known doesn't set */
+			mark_reg_unknown(env, regs, insn->dst_reg);
 			regs[insn->dst_reg].type = SCALAR_VALUE;
 			if (BPF_CLASS(insn->code) == BPF_ALU64) {
 				__mark_reg_known(regs + insn->dst_reg,
* Unmerged path tools/testing/selftests/bpf/test_verifier.c
