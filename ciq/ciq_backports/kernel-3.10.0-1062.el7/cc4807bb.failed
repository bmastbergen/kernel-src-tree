vxlan: Don't call gro_cells_destroy() before device is unregistered

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Zhiqiang Liu <liuzhiqiang26@huawei.com>
commit cc4807bb609230d8959fd732b0bf3bd4c2de8eac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/cc4807bb.failed

Commit ad6c9986bcb62 ("vxlan: Fix GRO cells race condition between
receive and link delete") fixed a race condition for the typical case a vxlan
device is dismantled from the current netns. But if a netns is dismantled,
vxlan_destroy_tunnels() is called to schedule a unregister_netdevice_queue()
of all the vxlan tunnels that are related to this netns.

In vxlan_destroy_tunnels(), gro_cells_destroy() is called and finished before
unregister_netdevice_queue(). This means that the gro_cells_destroy() call is
done too soon, for the same reasons explained in above commit.

So we need to fully respect the RCU rules, and thus must remove the
gro_cells_destroy() call or risk use after-free.

Fixes: 58ce31cca1ff ("vxlan: GRO support at tunnel layer")
	Signed-off-by: Suanming.Mou <mousuanming@huawei.com>
	Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
	Reviewed-by: Stefano Brivio <sbrivio@redhat.com>
	Reviewed-by: Zhiqiang Liu <liuzhiqiang26@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cc4807bb609230d8959fd732b0bf3bd4c2de8eac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index c6bf0552cab3,d76dfed8d9bb..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -3676,12 -4335,23 +3676,17 @@@ static void __net_exit vxlan_exit_net(s
  		/* If vxlan->dev is in the same netns, it has already been added
  		 * to the list by the previous loop.
  		 */
++<<<<<<< HEAD
 +		if (!net_eq(dev_net(vxlan->dev), net)) {
 +			gro_cells_destroy(&vxlan->gro_cells);
 +			unregister_netdevice_queue(vxlan->dev, &list);
 +		}
++=======
+ 		if (!net_eq(dev_net(vxlan->dev), net))
+ 			unregister_netdevice_queue(vxlan->dev, head);
++>>>>>>> cc4807bb6092 (vxlan: Don't call gro_cells_destroy() before device is unregistered)
  	}
  
 -	for (h = 0; h < PORT_HASH_SIZE; ++h)
 -		WARN_ON_ONCE(!hlist_empty(&vn->sock_list[h]));
 -}
 -
 -static void __net_exit vxlan_exit_batch_net(struct list_head *net_list)
 -{
 -	struct net *net;
 -	LIST_HEAD(list);
 -
 -	rtnl_lock();
 -	list_for_each_entry(net, net_list, exit_list)
 -		vxlan_destroy_tunnels(net, &list);
 -
  	unregister_netdevice_many(&list);
  	rtnl_unlock();
  }
* Unmerged path drivers/net/vxlan.c
