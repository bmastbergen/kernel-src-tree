perf bpf: Add prologue for BPF programs for fetching arguments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author He Kuang <hekuang@huawei.com>
commit bfc077b4cf106793b30bf942e426ee99f1f4ac44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/bfc077b4.failed

This patch generates a prologue for a BPF program which fetches arguments for
it.  With this patch, the program can have arguments as follow:

  SEC("lock_page=__lock_page page->flags")
  int lock_page(struct pt_regs *ctx, int err, unsigned long flags)
  {
 	 return 1;
  }

This patch passes at most 3 arguments from r3, r4 and r5. r1 is still the ctx
pointer. r2 is used to indicate if dereferencing was done successfully.

This patch uses r6 to hold ctx (struct pt_regs) and r7 to hold stack pointer
for result. Result of each arguments first store on stack:

 low address
 BPF_REG_FP - 24  ARG3
 BPF_REG_FP - 16  ARG2
 BPF_REG_FP - 8   ARG1
 BPF_REG_FP
 high address

Then loaded into r3, r4 and r5.

The output prologue for offn(...off2(off1(reg)))) should be:

     r6 <- r1			// save ctx into a callee saved register
     r7 <- fp
     r7 <- r7 - stack_offset	// pointer to result slot
     /* load r3 with the offset in pt_regs of 'reg' */
     (r7) <- r3			// make slot valid
     r3 <- r3 + off1		// prepare to read unsafe pointer
     r2 <- 8
     r1 <- r7			// result put onto stack
     call probe_read		// read unsafe pointer
     jnei r0, 0, err		// error checking
     r3 <- (r7)			// read result
     r3 <- r3 + off2		// prepare to read unsafe pointer
     r2 <- 8
     r1 <- r7
     call probe_read
     jnei r0, 0, err
     ...
     /* load r2, r3, r4 from stack */
     goto success
err:
     r2 <- 1
     /* load r3, r4, r5 with 0 */
     goto usercode
success:
     r2 <- 0
usercode:
     r1 <- r6	// restore ctx
     // original user code

If all of arguments reside in register (dereferencing is not
required), gen_prologue_fastpath() will be used to create
fast prologue:

     r3 <- (r1 + offset of reg1)
     r4 <- (r1 + offset of reg2)
     r5 <- (r1 + offset of reg3)
     r2 <- 0

P.S.

eBPF calling convention is defined as:

* r0		- return value from in-kernel function, and exit value
                  for eBPF program
* r1 - r5	- arguments from eBPF program to in-kernel function
* r6 - r9	- callee saved registers that in-kernel function will
                  preserve
* r10		- read-only frame pointer to access stack

Committer note:

At least testing if it builds and loads:

  # cat test_probe_arg.c
  struct pt_regs;

  __attribute__((section("lock_page=__lock_page page->flags"), used))
  int func(struct pt_regs *ctx, int err, unsigned long flags)
  {
  	return 1;
  }

  char _license[] __attribute__((section("license"), used)) = "GPL";
  int _version __attribute__((section("version"), used)) = 0x40300;
  # perf record -e ./test_probe_arg.c usleep 1
  [ perf record: Woken up 1 times to write data ]
  [ perf record: Captured and wrote 0.016 MB perf.data ]
  # perf evlist
  perf_bpf_probe:lock_page
  #

	Signed-off-by: He Kuang <hekuang@huawei.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Cc: Wang Nan <wangnan0@huawei.com>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/1447675815-166222-11-git-send-email-wangnan0@huawei.com
	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit bfc077b4cf106793b30bf942e426ee99f1f4ac44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/Build
#	tools/perf/util/bpf-loader.c
#	tools/perf/util/bpf-loader.h
diff --cc tools/perf/util/Build
index 6be76ae5c66f,0513dd525d87..000000000000
--- a/tools/perf/util/Build
+++ b/tools/perf/util/Build
@@@ -86,18 -86,10 +86,23 @@@ libperf-$(CONFIG_AUXTRACE) += intel-pt-
  libperf-$(CONFIG_AUXTRACE) += intel-pt.o
  libperf-$(CONFIG_AUXTRACE) += intel-bts.o
  libperf-y += parse-branch-options.o
 +libperf-y += dump-insn.o
  libperf-y += parse-regs-options.o
 -
 +libperf-y += term.o
 +libperf-y += help-unknown-cmd.o
 +libperf-y += mem-events.o
 +libperf-y += vsprintf.o
 +libperf-y += drv_configs.o
 +libperf-y += units.o
 +libperf-y += time-utils.o
 +libperf-y += expr-bison.o
 +libperf-y += branch.o
 +
++<<<<<<< HEAD
++=======
+ libperf-$(CONFIG_LIBBPF) += bpf-loader.o
+ libperf-$(CONFIG_BPF_PROLOGUE) += bpf-prologue.o
++>>>>>>> bfc077b4cf10 (perf bpf: Add prologue for BPF programs for fetching arguments)
  libperf-$(CONFIG_LIBELF) += symbol-elf.o
  libperf-$(CONFIG_LIBELF) += probe-file.o
  libperf-$(CONFIG_LIBELF) += probe-event.o
diff --cc tools/perf/util/bpf-loader.c
index 39bf9252ae96,bd14be438cda..000000000000
--- a/tools/perf/util/bpf-loader.c
+++ b/tools/perf/util/bpf-loader.c
@@@ -52,6 -94,540 +52,542 @@@ void bpf__clear(void
  {
  	struct bpf_object *obj, *tmp;
  
 -	bpf_object__for_each_safe(obj, tmp) {
 -		bpf__unprobe(obj);
 +	bpf_object__for_each_safe(obj, tmp)
  		bpf_object__close(obj);
++<<<<<<< HEAD
++=======
+ 	}
+ }
+ 
+ static void
+ bpf_prog_priv__clear(struct bpf_program *prog __maybe_unused,
+ 		     void *_priv)
+ {
+ 	struct bpf_prog_priv *priv = _priv;
+ 
+ 	cleanup_perf_probe_events(&priv->pev, 1);
+ 	free(priv);
+ }
+ 
+ static int
+ config__exec(const char *value, struct perf_probe_event *pev)
+ {
+ 	pev->uprobes = true;
+ 	pev->target = strdup(value);
+ 	if (!pev->target)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ static int
+ config__module(const char *value, struct perf_probe_event *pev)
+ {
+ 	pev->uprobes = false;
+ 	pev->target = strdup(value);
+ 	if (!pev->target)
+ 		return -ENOMEM;
+ 	return 0;
+ }
+ 
+ static int
+ config__bool(const char *value,
+ 	     bool *pbool, bool invert)
+ {
+ 	int err;
+ 	bool bool_value;
+ 
+ 	if (!pbool)
+ 		return -EINVAL;
+ 
+ 	err = strtobool(value, &bool_value);
+ 	if (err)
+ 		return err;
+ 
+ 	*pbool = invert ? !bool_value : bool_value;
+ 	return 0;
+ }
+ 
+ static int
+ config__inlines(const char *value,
+ 		struct perf_probe_event *pev __maybe_unused)
+ {
+ 	return config__bool(value, &probe_conf.no_inlines, true);
+ }
+ 
+ static int
+ config__force(const char *value,
+ 	      struct perf_probe_event *pev __maybe_unused)
+ {
+ 	return config__bool(value, &probe_conf.force_add, false);
+ }
+ 
+ static struct {
+ 	const char *key;
+ 	const char *usage;
+ 	const char *desc;
+ 	int (*func)(const char *, struct perf_probe_event *);
+ } bpf_config_terms[] = {
+ 	{
+ 		.key	= "exec",
+ 		.usage	= "exec=<full path of file>",
+ 		.desc	= "Set uprobe target",
+ 		.func	= config__exec,
+ 	},
+ 	{
+ 		.key	= "module",
+ 		.usage	= "module=<module name>    ",
+ 		.desc	= "Set kprobe module",
+ 		.func	= config__module,
+ 	},
+ 	{
+ 		.key	= "inlines",
+ 		.usage	= "inlines=[yes|no]        ",
+ 		.desc	= "Probe at inline symbol",
+ 		.func	= config__inlines,
+ 	},
+ 	{
+ 		.key	= "force",
+ 		.usage	= "force=[yes|no]          ",
+ 		.desc	= "Forcibly add events with existing name",
+ 		.func	= config__force,
+ 	},
+ };
+ 
+ static int
+ do_config(const char *key, const char *value,
+ 	  struct perf_probe_event *pev)
+ {
+ 	unsigned int i;
+ 
+ 	pr_debug("config bpf program: %s=%s\n", key, value);
+ 	for (i = 0; i < ARRAY_SIZE(bpf_config_terms); i++)
+ 		if (strcmp(key, bpf_config_terms[i].key) == 0)
+ 			return bpf_config_terms[i].func(value, pev);
+ 
+ 	pr_debug("BPF: ERROR: invalid config option in object: %s=%s\n",
+ 		 key, value);
+ 
+ 	pr_debug("\nHint: Currently valid options are:\n");
+ 	for (i = 0; i < ARRAY_SIZE(bpf_config_terms); i++)
+ 		pr_debug("\t%s:\t%s\n", bpf_config_terms[i].usage,
+ 			 bpf_config_terms[i].desc);
+ 	pr_debug("\n");
+ 
+ 	return -BPF_LOADER_ERRNO__CONFIG_TERM;
+ }
+ 
+ static const char *
+ parse_config_kvpair(const char *config_str, struct perf_probe_event *pev)
+ {
+ 	char *text = strdup(config_str);
+ 	char *sep, *line;
+ 	const char *main_str = NULL;
+ 	int err = 0;
+ 
+ 	if (!text) {
+ 		pr_debug("No enough memory: dup config_str failed\n");
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	line = text;
+ 	while ((sep = strchr(line, ';'))) {
+ 		char *equ;
+ 
+ 		*sep = '\0';
+ 		equ = strchr(line, '=');
+ 		if (!equ) {
+ 			pr_warning("WARNING: invalid config in BPF object: %s\n",
+ 				   line);
+ 			pr_warning("\tShould be 'key=value'.\n");
+ 			goto nextline;
+ 		}
+ 		*equ = '\0';
+ 
+ 		err = do_config(line, equ + 1, pev);
+ 		if (err)
+ 			break;
+ nextline:
+ 		line = sep + 1;
+ 	}
+ 
+ 	if (!err)
+ 		main_str = config_str + (line - text);
+ 	free(text);
+ 
+ 	return err ? ERR_PTR(err) : main_str;
+ }
+ 
+ static int
+ parse_config(const char *config_str, struct perf_probe_event *pev)
+ {
+ 	int err;
+ 	const char *main_str = parse_config_kvpair(config_str, pev);
+ 
+ 	if (IS_ERR(main_str))
+ 		return PTR_ERR(main_str);
+ 
+ 	err = parse_perf_probe_command(main_str, pev);
+ 	if (err < 0) {
+ 		pr_debug("bpf: '%s' is not a valid config string\n",
+ 			 config_str);
+ 		/* parse failed, don't need clear pev. */
+ 		return -BPF_LOADER_ERRNO__CONFIG;
+ 	}
+ 	return 0;
+ }
+ 
+ static int
+ config_bpf_program(struct bpf_program *prog)
+ {
+ 	struct perf_probe_event *pev = NULL;
+ 	struct bpf_prog_priv *priv = NULL;
+ 	const char *config_str;
+ 	int err;
+ 
+ 	/* Initialize per-program probing setting */
+ 	probe_conf.no_inlines = false;
+ 	probe_conf.force_add = false;
+ 
+ 	config_str = bpf_program__title(prog, false);
+ 	if (IS_ERR(config_str)) {
+ 		pr_debug("bpf: unable to get title for program\n");
+ 		return PTR_ERR(config_str);
+ 	}
+ 
+ 	priv = calloc(sizeof(*priv), 1);
+ 	if (!priv) {
+ 		pr_debug("bpf: failed to alloc priv\n");
+ 		return -ENOMEM;
+ 	}
+ 	pev = &priv->pev;
+ 
+ 	pr_debug("bpf: config program '%s'\n", config_str);
+ 	err = parse_config(config_str, pev);
+ 	if (err)
+ 		goto errout;
+ 
+ 	if (pev->group && strcmp(pev->group, PERF_BPF_PROBE_GROUP)) {
+ 		pr_debug("bpf: '%s': group for event is set and not '%s'.\n",
+ 			 config_str, PERF_BPF_PROBE_GROUP);
+ 		err = -BPF_LOADER_ERRNO__GROUP;
+ 		goto errout;
+ 	} else if (!pev->group)
+ 		pev->group = strdup(PERF_BPF_PROBE_GROUP);
+ 
+ 	if (!pev->group) {
+ 		pr_debug("bpf: strdup failed\n");
+ 		err = -ENOMEM;
+ 		goto errout;
+ 	}
+ 
+ 	if (!pev->event) {
+ 		pr_debug("bpf: '%s': event name is missing. Section name should be 'key=value'\n",
+ 			 config_str);
+ 		err = -BPF_LOADER_ERRNO__EVENTNAME;
+ 		goto errout;
+ 	}
+ 	pr_debug("bpf: config '%s' is ok\n", config_str);
+ 
+ 	err = bpf_program__set_private(prog, priv, bpf_prog_priv__clear);
+ 	if (err) {
+ 		pr_debug("Failed to set priv for program '%s'\n", config_str);
+ 		goto errout;
+ 	}
+ 
+ 	return 0;
+ 
+ errout:
+ 	if (pev)
+ 		clear_perf_probe_event(pev);
+ 	free(priv);
+ 	return err;
+ }
+ 
+ static int bpf__prepare_probe(void)
+ {
+ 	static int err = 0;
+ 	static bool initialized = false;
+ 
+ 	/*
+ 	 * Make err static, so if init failed the first, bpf__prepare_probe()
+ 	 * fails each time without calling init_probe_symbol_maps multiple
+ 	 * times.
+ 	 */
+ 	if (initialized)
+ 		return err;
+ 
+ 	initialized = true;
+ 	err = init_probe_symbol_maps(false);
+ 	if (err < 0)
+ 		pr_debug("Failed to init_probe_symbol_maps\n");
+ 	probe_conf.max_probes = MAX_PROBES;
+ 	return err;
+ }
+ 
+ int bpf__probe(struct bpf_object *obj)
+ {
+ 	int err = 0;
+ 	struct bpf_program *prog;
+ 	struct bpf_prog_priv *priv;
+ 	struct perf_probe_event *pev;
+ 
+ 	err = bpf__prepare_probe();
+ 	if (err) {
+ 		pr_debug("bpf__prepare_probe failed\n");
+ 		return err;
+ 	}
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		err = config_bpf_program(prog);
+ 		if (err)
+ 			goto out;
+ 
+ 		err = bpf_program__get_private(prog, (void **)&priv);
+ 		if (err || !priv)
+ 			goto out;
+ 		pev = &priv->pev;
+ 
+ 		err = convert_perf_probe_events(pev, 1);
+ 		if (err < 0) {
+ 			pr_debug("bpf_probe: failed to convert perf probe events");
+ 			goto out;
+ 		}
+ 
+ 		err = apply_perf_probe_events(pev, 1);
+ 		if (err < 0) {
+ 			pr_debug("bpf_probe: failed to apply perf probe events");
+ 			goto out;
+ 		}
+ 	}
+ out:
+ 	return err < 0 ? err : 0;
+ }
+ 
+ #define EVENTS_WRITE_BUFSIZE  4096
+ int bpf__unprobe(struct bpf_object *obj)
+ {
+ 	int err, ret = 0;
+ 	struct bpf_program *prog;
+ 	struct bpf_prog_priv *priv;
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		int i;
+ 
+ 		err = bpf_program__get_private(prog, (void **)&priv);
+ 		if (err || !priv)
+ 			continue;
+ 
+ 		for (i = 0; i < priv->pev.ntevs; i++) {
+ 			struct probe_trace_event *tev = &priv->pev.tevs[i];
+ 			char name_buf[EVENTS_WRITE_BUFSIZE];
+ 			struct strfilter *delfilter;
+ 
+ 			snprintf(name_buf, EVENTS_WRITE_BUFSIZE,
+ 				 "%s:%s", tev->group, tev->event);
+ 			name_buf[EVENTS_WRITE_BUFSIZE - 1] = '\0';
+ 
+ 			delfilter = strfilter__new(name_buf, NULL);
+ 			if (!delfilter) {
+ 				pr_debug("Failed to create filter for unprobing\n");
+ 				ret = -ENOMEM;
+ 				continue;
+ 			}
+ 
+ 			err = del_perf_probe_events(delfilter);
+ 			strfilter__delete(delfilter);
+ 			if (err) {
+ 				pr_debug("Failed to delete %s\n", name_buf);
+ 				ret = err;
+ 				continue;
+ 			}
+ 		}
+ 	}
+ 	return ret;
+ }
+ 
+ int bpf__load(struct bpf_object *obj)
+ {
+ 	int err;
+ 
+ 	err = bpf_object__load(obj);
+ 	if (err) {
+ 		pr_debug("bpf: load objects failed\n");
+ 		return err;
+ 	}
+ 	return 0;
+ }
+ 
+ int bpf__foreach_tev(struct bpf_object *obj,
+ 		     bpf_prog_iter_callback_t func,
+ 		     void *arg)
+ {
+ 	struct bpf_program *prog;
+ 	int err;
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		struct probe_trace_event *tev;
+ 		struct perf_probe_event *pev;
+ 		struct bpf_prog_priv *priv;
+ 		int i, fd;
+ 
+ 		err = bpf_program__get_private(prog,
+ 				(void **)&priv);
+ 		if (err || !priv) {
+ 			pr_debug("bpf: failed to get private field\n");
+ 			return -BPF_LOADER_ERRNO__INTERNAL;
+ 		}
+ 
+ 		pev = &priv->pev;
+ 		for (i = 0; i < pev->ntevs; i++) {
+ 			tev = &pev->tevs[i];
+ 
+ 			fd = bpf_program__fd(prog);
+ 			if (fd < 0) {
+ 				pr_debug("bpf: failed to get file descriptor\n");
+ 				return fd;
+ 			}
+ 
+ 			err = (*func)(tev, fd, arg);
+ 			if (err) {
+ 				pr_debug("bpf: call back failed, stop iterate\n");
+ 				return err;
+ 			}
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ #define ERRNO_OFFSET(e)		((e) - __BPF_LOADER_ERRNO__START)
+ #define ERRCODE_OFFSET(c)	ERRNO_OFFSET(BPF_LOADER_ERRNO__##c)
+ #define NR_ERRNO	(__BPF_LOADER_ERRNO__END - __BPF_LOADER_ERRNO__START)
+ 
+ static const char *bpf_loader_strerror_table[NR_ERRNO] = {
+ 	[ERRCODE_OFFSET(CONFIG)]	= "Invalid config string",
+ 	[ERRCODE_OFFSET(GROUP)]		= "Invalid group name",
+ 	[ERRCODE_OFFSET(EVENTNAME)]	= "No event name found in config string",
+ 	[ERRCODE_OFFSET(INTERNAL)]	= "BPF loader internal error",
+ 	[ERRCODE_OFFSET(COMPILE)]	= "Error when compiling BPF scriptlet",
+ 	[ERRCODE_OFFSET(CONFIG_TERM)]	= "Invalid config term in config string",
+ 	[ERRCODE_OFFSET(PROLOGUE)]	= "Failed to generate prologue",
+ 	[ERRCODE_OFFSET(PROLOGUE2BIG)]	= "Prologue too big for program",
+ 	[ERRCODE_OFFSET(PROLOGUEOOB)]	= "Offset out of bound for prologue",
+ };
+ 
+ static int
+ bpf_loader_strerror(int err, char *buf, size_t size)
+ {
+ 	char sbuf[STRERR_BUFSIZE];
+ 	const char *msg;
+ 
+ 	if (!buf || !size)
+ 		return -1;
+ 
+ 	err = err > 0 ? err : -err;
+ 
+ 	if (err >= __LIBBPF_ERRNO__START)
+ 		return libbpf_strerror(err, buf, size);
+ 
+ 	if (err >= __BPF_LOADER_ERRNO__START && err < __BPF_LOADER_ERRNO__END) {
+ 		msg = bpf_loader_strerror_table[ERRNO_OFFSET(err)];
+ 		snprintf(buf, size, "%s", msg);
+ 		buf[size - 1] = '\0';
+ 		return 0;
+ 	}
+ 
+ 	if (err >= __BPF_LOADER_ERRNO__END)
+ 		snprintf(buf, size, "Unknown bpf loader error %d", err);
+ 	else
+ 		snprintf(buf, size, "%s",
+ 			 strerror_r(err, sbuf, sizeof(sbuf)));
+ 
+ 	buf[size - 1] = '\0';
+ 	return -1;
+ }
+ 
+ #define bpf__strerror_head(err, buf, size) \
+ 	char sbuf[STRERR_BUFSIZE], *emsg;\
+ 	if (!size)\
+ 		return 0;\
+ 	if (err < 0)\
+ 		err = -err;\
+ 	bpf_loader_strerror(err, sbuf, sizeof(sbuf));\
+ 	emsg = sbuf;\
+ 	switch (err) {\
+ 	default:\
+ 		scnprintf(buf, size, "%s", emsg);\
+ 		break;
+ 
+ #define bpf__strerror_entry(val, fmt...)\
+ 	case val: {\
+ 		scnprintf(buf, size, fmt);\
+ 		break;\
+ 	}
+ 
+ #define bpf__strerror_end(buf, size)\
+ 	}\
+ 	buf[size - 1] = '\0';
+ 
+ int bpf__strerror_prepare_load(const char *filename, bool source,
+ 			       int err, char *buf, size_t size)
+ {
+ 	size_t n;
+ 	int ret;
+ 
+ 	n = snprintf(buf, size, "Failed to load %s%s: ",
+ 			 filename, source ? " from source" : "");
+ 	if (n >= size) {
+ 		buf[size - 1] = '\0';
+ 		return 0;
+ 	}
+ 	buf += n;
+ 	size -= n;
+ 
+ 	ret = bpf_loader_strerror(err, buf, size);
+ 	buf[size - 1] = '\0';
+ 	return ret;
+ }
+ 
+ int bpf__strerror_probe(struct bpf_object *obj __maybe_unused,
+ 			int err, char *buf, size_t size)
+ {
+ 	bpf__strerror_head(err, buf, size);
+ 	case BPF_LOADER_ERRNO__CONFIG_TERM: {
+ 		scnprintf(buf, size, "%s (add -v to see detail)", emsg);
+ 		break;
+ 	}
+ 	bpf__strerror_entry(EEXIST, "Probe point exist. Try 'perf probe -d \"*\"' and set 'force=yes'");
+ 	bpf__strerror_entry(EACCES, "You need to be root");
+ 	bpf__strerror_entry(EPERM, "You need to be root, and /proc/sys/kernel/kptr_restrict should be 0");
+ 	bpf__strerror_entry(ENOENT, "You need to check probing points in BPF file");
+ 	bpf__strerror_end(buf, size);
+ 	return 0;
+ }
+ 
+ int bpf__strerror_load(struct bpf_object *obj,
+ 		       int err, char *buf, size_t size)
+ {
+ 	bpf__strerror_head(err, buf, size);
+ 	case LIBBPF_ERRNO__KVER: {
+ 		unsigned int obj_kver = bpf_object__get_kversion(obj);
+ 		unsigned int real_kver;
+ 
+ 		if (fetch_kernel_version(&real_kver, NULL, 0)) {
+ 			scnprintf(buf, size, "Unable to fetch kernel version");
+ 			break;
+ 		}
+ 
+ 		if (obj_kver != real_kver) {
+ 			scnprintf(buf, size,
+ 				  "'version' ("KVER_FMT") doesn't match running kernel ("KVER_FMT")",
+ 				  KVER_PARAM(obj_kver),
+ 				  KVER_PARAM(real_kver));
+ 			break;
+ 		}
+ 
+ 		scnprintf(buf, size, "Failed to load program for unknown reason");
+ 		break;
+ 	}
+ 	bpf__strerror_end(buf, size);
+ 	return 0;
++>>>>>>> bfc077b4cf10 (perf bpf: Add prologue for BPF programs for fetching arguments)
  }
diff --cc tools/perf/util/bpf-loader.h
index f402d7c8c288,a58740b0f31e..000000000000
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@@ -8,17 -8,55 +8,35 @@@
  #include <linux/compiler.h>
  #include <linux/err.h>
  #include <string.h>
 -#include <bpf/libbpf.h>
 -#include "probe-event.h"
  #include "debug.h"
  
++<<<<<<< HEAD
++=======
+ enum bpf_loader_errno {
+ 	__BPF_LOADER_ERRNO__START = __LIBBPF_ERRNO__START - 100,
+ 	/* Invalid config string */
+ 	BPF_LOADER_ERRNO__CONFIG = __BPF_LOADER_ERRNO__START,
+ 	BPF_LOADER_ERRNO__GROUP,	/* Invalid group name */
+ 	BPF_LOADER_ERRNO__EVENTNAME,	/* Event name is missing */
+ 	BPF_LOADER_ERRNO__INTERNAL,	/* BPF loader internal error */
+ 	BPF_LOADER_ERRNO__COMPILE,	/* Error when compiling BPF scriptlet */
+ 	BPF_LOADER_ERRNO__CONFIG_TERM,	/* Invalid config term in config term */
+ 	BPF_LOADER_ERRNO__PROLOGUE,	/* Failed to generate prologue */
+ 	BPF_LOADER_ERRNO__PROLOGUE2BIG,	/* Prologue too big for program */
+ 	BPF_LOADER_ERRNO__PROLOGUEOOB,	/* Offset out of bound for prologue */
+ 	__BPF_LOADER_ERRNO__END,
+ };
+ 
++>>>>>>> bfc077b4cf10 (perf bpf: Add prologue for BPF programs for fetching arguments)
  struct bpf_object;
 -#define PERF_BPF_PROBE_GROUP "perf_bpf_probe"
 -
 -typedef int (*bpf_prog_iter_callback_t)(struct probe_trace_event *tev,
 -					int fd, void *arg);
  
  #ifdef HAVE_LIBBPF_SUPPORT
 -struct bpf_object *bpf__prepare_load(const char *filename, bool source);
 -int bpf__strerror_prepare_load(const char *filename, bool source,
 -			       int err, char *buf, size_t size);
 -
 -struct bpf_object *bpf__prepare_load_buffer(void *obj_buf, size_t obj_buf_sz,
 -					    const char *name);
 +struct bpf_object *bpf__prepare_load(const char *filename);
  
  void bpf__clear(void);
 -
 -int bpf__probe(struct bpf_object *obj);
 -int bpf__unprobe(struct bpf_object *obj);
 -int bpf__strerror_probe(struct bpf_object *obj, int err,
 -			char *buf, size_t size);
 -
 -int bpf__load(struct bpf_object *obj);
 -int bpf__strerror_load(struct bpf_object *obj, int err,
 -		       char *buf, size_t size);
 -int bpf__foreach_tev(struct bpf_object *obj,
 -		     bpf_prog_iter_callback_t func, void *arg);
  #else
  static inline struct bpf_object *
 -bpf__prepare_load(const char *filename __maybe_unused,
 -		  bool source __maybe_unused)
 +bpf__prepare_load(const char *filename __maybe_unused)
  {
  	pr_debug("ERROR: eBPF object loading is disabled during compiling.\n");
  	return ERR_PTR(-ENOTSUP);
* Unmerged path tools/perf/util/Build
* Unmerged path tools/perf/util/bpf-loader.c
* Unmerged path tools/perf/util/bpf-loader.h
diff --git a/tools/perf/util/bpf-prologue.c b/tools/perf/util/bpf-prologue.c
new file mode 100644
index 000000000000..6cdbee119ceb
--- /dev/null
+++ b/tools/perf/util/bpf-prologue.c
@@ -0,0 +1,455 @@
+/*
+ * bpf-prologue.c
+ *
+ * Copyright (C) 2015 He Kuang <hekuang@huawei.com>
+ * Copyright (C) 2015 Wang Nan <wangnan0@huawei.com>
+ * Copyright (C) 2015 Huawei Inc.
+ */
+
+#include <bpf/libbpf.h>
+#include "perf.h"
+#include "debug.h"
+#include "bpf-loader.h"
+#include "bpf-prologue.h"
+#include "probe-finder.h"
+#include <dwarf-regs.h>
+#include <linux/filter.h>
+
+#define BPF_REG_SIZE		8
+
+#define JMP_TO_ERROR_CODE	-1
+#define JMP_TO_SUCCESS_CODE	-2
+#define JMP_TO_USER_CODE	-3
+
+struct bpf_insn_pos {
+	struct bpf_insn *begin;
+	struct bpf_insn *end;
+	struct bpf_insn *pos;
+};
+
+static inline int
+pos_get_cnt(struct bpf_insn_pos *pos)
+{
+	return pos->pos - pos->begin;
+}
+
+static int
+append_insn(struct bpf_insn new_insn, struct bpf_insn_pos *pos)
+{
+	if (!pos->pos)
+		return -BPF_LOADER_ERRNO__PROLOGUE2BIG;
+
+	if (pos->pos + 1 >= pos->end) {
+		pr_err("bpf prologue: prologue too long\n");
+		pos->pos = NULL;
+		return -BPF_LOADER_ERRNO__PROLOGUE2BIG;
+	}
+
+	*(pos->pos)++ = new_insn;
+	return 0;
+}
+
+static int
+check_pos(struct bpf_insn_pos *pos)
+{
+	if (!pos->pos || pos->pos >= pos->end)
+		return -BPF_LOADER_ERRNO__PROLOGUE2BIG;
+	return 0;
+}
+
+/* Give it a shorter name */
+#define ins(i, p) append_insn((i), (p))
+
+/*
+ * Give a register name (in 'reg'), generate instruction to
+ * load register into an eBPF register rd:
+ *   'ldd target_reg, offset(ctx_reg)', where:
+ * ctx_reg is pre initialized to pointer of 'struct pt_regs'.
+ */
+static int
+gen_ldx_reg_from_ctx(struct bpf_insn_pos *pos, int ctx_reg,
+		     const char *reg, int target_reg)
+{
+	int offset = regs_query_register_offset(reg);
+
+	if (offset < 0) {
+		pr_err("bpf: prologue: failed to get register %s\n",
+		       reg);
+		return offset;
+	}
+	ins(BPF_LDX_MEM(BPF_DW, target_reg, ctx_reg, offset), pos);
+
+	return check_pos(pos);
+}
+
+/*
+ * Generate a BPF_FUNC_probe_read function call.
+ *
+ * src_base_addr_reg is a register holding base address,
+ * dst_addr_reg is a register holding dest address (on stack),
+ * result is:
+ *
+ *  *[dst_addr_reg] = *([src_base_addr_reg] + offset)
+ *
+ * Arguments of BPF_FUNC_probe_read:
+ *     ARG1: ptr to stack (dest)
+ *     ARG2: size (8)
+ *     ARG3: unsafe ptr (src)
+ */
+static int
+gen_read_mem(struct bpf_insn_pos *pos,
+	     int src_base_addr_reg,
+	     int dst_addr_reg,
+	     long offset)
+{
+	/* mov arg3, src_base_addr_reg */
+	if (src_base_addr_reg != BPF_REG_ARG3)
+		ins(BPF_MOV64_REG(BPF_REG_ARG3, src_base_addr_reg), pos);
+	/* add arg3, #offset */
+	if (offset)
+		ins(BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, offset), pos);
+
+	/* mov arg2, #reg_size */
+	ins(BPF_ALU64_IMM(BPF_MOV, BPF_REG_ARG2, BPF_REG_SIZE), pos);
+
+	/* mov arg1, dst_addr_reg */
+	if (dst_addr_reg != BPF_REG_ARG1)
+		ins(BPF_MOV64_REG(BPF_REG_ARG1, dst_addr_reg), pos);
+
+	/* Call probe_read  */
+	ins(BPF_EMIT_CALL(BPF_FUNC_probe_read), pos);
+	/*
+	 * Error processing: if read fail, goto error code,
+	 * will be relocated. Target should be the start of
+	 * error processing code.
+	 */
+	ins(BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, JMP_TO_ERROR_CODE),
+	    pos);
+
+	return check_pos(pos);
+}
+
+/*
+ * Each arg should be bare register. Fetch and save them into argument
+ * registers (r3 - r5).
+ *
+ * BPF_REG_1 should have been initialized with pointer to
+ * 'struct pt_regs'.
+ */
+static int
+gen_prologue_fastpath(struct bpf_insn_pos *pos,
+		      struct probe_trace_arg *args, int nargs)
+{
+	int i, err = 0;
+
+	for (i = 0; i < nargs; i++) {
+		err = gen_ldx_reg_from_ctx(pos, BPF_REG_1, args[i].value,
+					   BPF_PROLOGUE_START_ARG_REG + i);
+		if (err)
+			goto errout;
+	}
+
+	return check_pos(pos);
+errout:
+	return err;
+}
+
+/*
+ * Slow path:
+ *   At least one argument has the form of 'offset($rx)'.
+ *
+ * Following code first stores them into stack, then loads all of then
+ * to r2 - r5.
+ * Before final loading, the final result should be:
+ *
+ * low address
+ * BPF_REG_FP - 24  ARG3
+ * BPF_REG_FP - 16  ARG2
+ * BPF_REG_FP - 8   ARG1
+ * BPF_REG_FP
+ * high address
+ *
+ * For each argument (described as: offn(...off2(off1(reg)))),
+ * generates following code:
+ *
+ *  r7 <- fp
+ *  r7 <- r7 - stack_offset  // Ideal code should initialize r7 using
+ *                           // fp before generating args. However,
+ *                           // eBPF won't regard r7 as stack pointer
+ *                           // if it is generated by minus 8 from
+ *                           // another stack pointer except fp.
+ *                           // This is why we have to set r7
+ *                           // to fp for each variable.
+ *  r3 <- value of 'reg'-> generated using gen_ldx_reg_from_ctx()
+ *  (r7) <- r3       // skip following instructions for bare reg
+ *  r3 <- r3 + off1  . // skip if off1 == 0
+ *  r2 <- 8           \
+ *  r1 <- r7           |-> generated by gen_read_mem()
+ *  call probe_read    /
+ *  jnei r0, 0, err  ./
+ *  r3 <- (r7)
+ *  r3 <- r3 + off2  . // skip if off2 == 0
+ *  r2 <- 8           \  // r2 may be broken by probe_read, so set again
+ *  r1 <- r7           |-> generated by gen_read_mem()
+ *  call probe_read    /
+ *  jnei r0, 0, err  ./
+ *  ...
+ */
+static int
+gen_prologue_slowpath(struct bpf_insn_pos *pos,
+		      struct probe_trace_arg *args, int nargs)
+{
+	int err, i;
+
+	for (i = 0; i < nargs; i++) {
+		struct probe_trace_arg *arg = &args[i];
+		const char *reg = arg->value;
+		struct probe_trace_arg_ref *ref = NULL;
+		int stack_offset = (i + 1) * -8;
+
+		pr_debug("prologue: fetch arg %d, base reg is %s\n",
+			 i, reg);
+
+		/* value of base register is stored into ARG3 */
+		err = gen_ldx_reg_from_ctx(pos, BPF_REG_CTX, reg,
+					   BPF_REG_ARG3);
+		if (err) {
+			pr_err("prologue: failed to get offset of register %s\n",
+			       reg);
+			goto errout;
+		}
+
+		/* Make r7 the stack pointer. */
+		ins(BPF_MOV64_REG(BPF_REG_7, BPF_REG_FP), pos);
+		/* r7 += -8 */
+		ins(BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, stack_offset), pos);
+		/*
+		 * Store r3 (base register) onto stack
+		 * Ensure fp[offset] is set.
+		 * fp is the only valid base register when storing
+		 * into stack. We are not allowed to use r7 as base
+		 * register here.
+		 */
+		ins(BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_ARG3,
+				stack_offset), pos);
+
+		ref = arg->ref;
+		while (ref) {
+			pr_debug("prologue: arg %d: offset %ld\n",
+				 i, ref->offset);
+			err = gen_read_mem(pos, BPF_REG_3, BPF_REG_7,
+					   ref->offset);
+			if (err) {
+				pr_err("prologue: failed to generate probe_read function call\n");
+				goto errout;
+			}
+
+			ref = ref->next;
+			/*
+			 * Load previous result into ARG3. Use
+			 * BPF_REG_FP instead of r7 because verifier
+			 * allows FP based addressing only.
+			 */
+			if (ref)
+				ins(BPF_LDX_MEM(BPF_DW, BPF_REG_ARG3,
+						BPF_REG_FP, stack_offset), pos);
+		}
+	}
+
+	/* Final pass: read to registers */
+	for (i = 0; i < nargs; i++)
+		ins(BPF_LDX_MEM(BPF_DW, BPF_PROLOGUE_START_ARG_REG + i,
+				BPF_REG_FP, -BPF_REG_SIZE * (i + 1)), pos);
+
+	ins(BPF_JMP_IMM(BPF_JA, BPF_REG_0, 0, JMP_TO_SUCCESS_CODE), pos);
+
+	return check_pos(pos);
+errout:
+	return err;
+}
+
+static int
+prologue_relocate(struct bpf_insn_pos *pos, struct bpf_insn *error_code,
+		  struct bpf_insn *success_code, struct bpf_insn *user_code)
+{
+	struct bpf_insn *insn;
+
+	if (check_pos(pos))
+		return -BPF_LOADER_ERRNO__PROLOGUE2BIG;
+
+	for (insn = pos->begin; insn < pos->pos; insn++) {
+		struct bpf_insn *target;
+		u8 class = BPF_CLASS(insn->code);
+		u8 opcode;
+
+		if (class != BPF_JMP)
+			continue;
+		opcode = BPF_OP(insn->code);
+		if (opcode == BPF_CALL)
+			continue;
+
+		switch (insn->off) {
+		case JMP_TO_ERROR_CODE:
+			target = error_code;
+			break;
+		case JMP_TO_SUCCESS_CODE:
+			target = success_code;
+			break;
+		case JMP_TO_USER_CODE:
+			target = user_code;
+			break;
+		default:
+			pr_err("bpf prologue: internal error: relocation failed\n");
+			return -BPF_LOADER_ERRNO__PROLOGUE;
+		}
+
+		insn->off = target - (insn + 1);
+	}
+	return 0;
+}
+
+int bpf__gen_prologue(struct probe_trace_arg *args, int nargs,
+		      struct bpf_insn *new_prog, size_t *new_cnt,
+		      size_t cnt_space)
+{
+	struct bpf_insn *success_code = NULL;
+	struct bpf_insn *error_code = NULL;
+	struct bpf_insn *user_code = NULL;
+	struct bpf_insn_pos pos;
+	bool fastpath = true;
+	int err = 0, i;
+
+	if (!new_prog || !new_cnt)
+		return -EINVAL;
+
+	if (cnt_space > BPF_MAXINSNS)
+		cnt_space = BPF_MAXINSNS;
+
+	pos.begin = new_prog;
+	pos.end = new_prog + cnt_space;
+	pos.pos = new_prog;
+
+	if (!nargs) {
+		ins(BPF_ALU64_IMM(BPF_MOV, BPF_PROLOGUE_FETCH_RESULT_REG, 0),
+		    &pos);
+
+		if (check_pos(&pos))
+			goto errout;
+
+		*new_cnt = pos_get_cnt(&pos);
+		return 0;
+	}
+
+	if (nargs > BPF_PROLOGUE_MAX_ARGS) {
+		pr_warning("bpf: prologue: %d arguments are dropped\n",
+			   nargs - BPF_PROLOGUE_MAX_ARGS);
+		nargs = BPF_PROLOGUE_MAX_ARGS;
+	}
+
+	/* First pass: validation */
+	for (i = 0; i < nargs; i++) {
+		struct probe_trace_arg_ref *ref = args[i].ref;
+
+		if (args[i].value[0] == '@') {
+			/* TODO: fetch global variable */
+			pr_err("bpf: prologue: global %s%+ld not support\n",
+				args[i].value, ref ? ref->offset : 0);
+			return -ENOTSUP;
+		}
+
+		while (ref) {
+			/* fastpath is true if all args has ref == NULL */
+			fastpath = false;
+
+			/*
+			 * Instruction encodes immediate value using
+			 * s32, ref->offset is long. On systems which
+			 * can't fill long in s32, refuse to process if
+			 * ref->offset too large (or small).
+			 */
+#ifdef __LP64__
+#define OFFSET_MAX	((1LL << 31) - 1)
+#define OFFSET_MIN	((1LL << 31) * -1)
+			if (ref->offset > OFFSET_MAX ||
+					ref->offset < OFFSET_MIN) {
+				pr_err("bpf: prologue: offset out of bound: %ld\n",
+				       ref->offset);
+				return -BPF_LOADER_ERRNO__PROLOGUEOOB;
+			}
+#endif
+			ref = ref->next;
+		}
+	}
+	pr_debug("prologue: pass validation\n");
+
+	if (fastpath) {
+		/* If all variables are registers... */
+		pr_debug("prologue: fast path\n");
+		err = gen_prologue_fastpath(&pos, args, nargs);
+		if (err)
+			goto errout;
+	} else {
+		pr_debug("prologue: slow path\n");
+
+		/* Initialization: move ctx to a callee saved register. */
+		ins(BPF_MOV64_REG(BPF_REG_CTX, BPF_REG_ARG1), &pos);
+
+		err = gen_prologue_slowpath(&pos, args, nargs);
+		if (err)
+			goto errout;
+		/*
+		 * start of ERROR_CODE (only slow pass needs error code)
+		 *   mov r2 <- 1  // r2 is error number
+		 *   mov r3 <- 0  // r3, r4... should be touched or
+		 *                // verifier would complain
+		 *   mov r4 <- 0
+		 *   ...
+		 *   goto usercode
+		 */
+		error_code = pos.pos;
+		ins(BPF_ALU64_IMM(BPF_MOV, BPF_PROLOGUE_FETCH_RESULT_REG, 1),
+		    &pos);
+
+		for (i = 0; i < nargs; i++)
+			ins(BPF_ALU64_IMM(BPF_MOV,
+					  BPF_PROLOGUE_START_ARG_REG + i,
+					  0),
+			    &pos);
+		ins(BPF_JMP_IMM(BPF_JA, BPF_REG_0, 0, JMP_TO_USER_CODE),
+				&pos);
+	}
+
+	/*
+	 * start of SUCCESS_CODE:
+	 *   mov r2 <- 0
+	 *   goto usercode  // skip
+	 */
+	success_code = pos.pos;
+	ins(BPF_ALU64_IMM(BPF_MOV, BPF_PROLOGUE_FETCH_RESULT_REG, 0), &pos);
+
+	/*
+	 * start of USER_CODE:
+	 *   Restore ctx to r1
+	 */
+	user_code = pos.pos;
+	if (!fastpath) {
+		/*
+		 * Only slow path needs restoring of ctx. In fast path,
+		 * register are loaded directly from r1.
+		 */
+		ins(BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_CTX), &pos);
+		err = prologue_relocate(&pos, error_code, success_code,
+					user_code);
+		if (err)
+			goto errout;
+	}
+
+	err = check_pos(&pos);
+	if (err)
+		goto errout;
+
+	*new_cnt = pos_get_cnt(&pos);
+	return 0;
+errout:
+	return err;
+}
diff --git a/tools/perf/util/bpf-prologue.h b/tools/perf/util/bpf-prologue.h
new file mode 100644
index 000000000000..d94cbea12899
--- /dev/null
+++ b/tools/perf/util/bpf-prologue.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015, He Kuang <hekuang@huawei.com>
+ * Copyright (C) 2015, Huawei Inc.
+ */
+#ifndef __BPF_PROLOGUE_H
+#define __BPF_PROLOGUE_H
+
+#include <linux/compiler.h>
+#include <linux/filter.h>
+#include "probe-event.h"
+
+#define BPF_PROLOGUE_MAX_ARGS 3
+#define BPF_PROLOGUE_START_ARG_REG BPF_REG_3
+#define BPF_PROLOGUE_FETCH_RESULT_REG BPF_REG_2
+
+#ifdef HAVE_BPF_PROLOGUE
+int bpf__gen_prologue(struct probe_trace_arg *args, int nargs,
+		      struct bpf_insn *new_prog, size_t *new_cnt,
+		      size_t cnt_space);
+#else
+static inline int
+bpf__gen_prologue(struct probe_trace_arg *args __maybe_unused,
+		  int nargs __maybe_unused,
+		  struct bpf_insn *new_prog __maybe_unused,
+		  size_t *new_cnt,
+		  size_t cnt_space __maybe_unused)
+{
+	if (!new_cnt)
+		return -EINVAL;
+	*new_cnt = 0;
+	return -ENOTSUP;
+}
+#endif
+#endif /* __BPF_PROLOGUE_H */
