ixgbe: use return codes from ndo_xdp_xmit that are distinguishable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jesper Dangaard Brouer <brouer@redhat.com>
commit 2886447dc5add28226451c163cd9ac1d1b3bf59a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/2886447d.failed

For XDP_REDIRECT the use of return code -EINVAL is confusing, as it is
used in three different cases.  (1) When the index or ifindex lookup
fails, and in the ixgbe driver (2) when link is down and (3) when XDP
have not been enabled.

The return code can be picked up by the tracepoint xdp:xdp_redirect
for diagnosing why XDP_REDIRECT isn't working.  Thus, there is a need
different return codes to tell the issues apart.

I'm considering using a specific err-code scheme for XDP_REDIRECT
instead of using these errno codes.

	Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2886447dc5add28226451c163cd9ac1d1b3bf59a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 3497b22f2764,d962368d08d0..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -9933,8 -9842,54 +9933,58 @@@ static int ixgbe_xdp(struct net_device 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int ixgbe_xdp_xmit(struct net_device *dev, struct xdp_buff *xdp)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 	struct ixgbe_ring *ring;
+ 	int err;
+ 
+ 	if (unlikely(test_bit(__IXGBE_DOWN, &adapter->state)))
+ 		return -ENETDOWN;
+ 
+ 	/* During program transitions its possible adapter->xdp_prog is assigned
+ 	 * but ring has not been configured yet. In this case simply abort xmit.
+ 	 */
+ 	ring = adapter->xdp_prog ? adapter->xdp_ring[smp_processor_id()] : NULL;
+ 	if (unlikely(!ring))
+ 		return -ENXIO;
+ 
+ 	err = ixgbe_xmit_xdp_ring(adapter, xdp);
+ 	if (err != IXGBE_XDP_TX)
+ 		return -ENOSPC;
+ 
+ 	return 0;
+ }
+ 
+ static void ixgbe_xdp_flush(struct net_device *dev)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 	struct ixgbe_ring *ring;
+ 
+ 	/* Its possible the device went down between xdp xmit and flush so
+ 	 * we need to ensure device is still up.
+ 	 */
+ 	if (unlikely(test_bit(__IXGBE_DOWN, &adapter->state)))
+ 		return;
+ 
+ 	ring = adapter->xdp_prog ? adapter->xdp_ring[smp_processor_id()] : NULL;
+ 	if (unlikely(!ring))
+ 		return;
+ 
+ 	/* Force memory writes to complete before letting h/w know there
+ 	 * are new descriptors to fetch.
+ 	 */
+ 	wmb();
+ 	writel(ring->next_to_use, ring->tail);
+ 
+ 	return;
+ }
+ 
++>>>>>>> 2886447dc5ad (ixgbe: use return codes from ndo_xdp_xmit that are distinguishable)
  static const struct net_device_ops ixgbe_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
  	.ndo_open		= ixgbe_open,
  	.ndo_stop		= ixgbe_close,
  	.ndo_start_xmit		= ixgbe_xmit_frame,
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
