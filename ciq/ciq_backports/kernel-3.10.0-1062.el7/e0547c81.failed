PCI: Reset Lenovo ThinkPad P50 nvgpu at boot if necessary

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [pci] Reset Lenovo ThinkPad P50 nvgpu at boot if necessary (Lyude Paul) [1628644]
Rebuild_FUZZ: 95.41%
commit-author Lyude Paul <lyude@redhat.com>
commit e0547c81bfcfad01cbbfa93a5e66bb98ab932f80
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e0547c81.failed

On ThinkPad P50 SKUs with an Nvidia Quadro M1000M instead of the M2000M
variant, the BIOS does not always reset the secondary Nvidia GPU during
reboot if the laptop is configured in Hybrid Graphics mode.  The reason is
unknown, but the following steps and possibly a good bit of patience will
reproduce the issue:

  1. Boot up the laptop normally in Hybrid Graphics mode
  2. Make sure nouveau is loaded and that the GPU is awake
  3. Allow the Nvidia GPU to runtime suspend itself after being idle
  4. Reboot the machine, the more sudden the better (e.g. sysrq-b may help)
  5. If nouveau loads up properly, reboot the machine again and go back to
     step 2 until you reproduce the issue

This results in some very strange behavior: the GPU will be left in exactly
the same state it was in when the previously booted kernel started the
reboot.  This has all sorts of bad side effects: for starters, this
completely breaks nouveau starting with a mysterious EVO channel failure
that happens well before we've actually used the EVO channel for anything:

  nouveau 0000:01:00.0: disp: chid 0 mthd 0000 data 00000400 00001000 00000002

This causes a timeout trying to bring up the GR ctx:

  nouveau 0000:01:00.0: timeout
  WARNING: CPU: 0 PID: 12 at drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgf100.c:1547 gf100_grctx_generate+0x7b2/0x850 [nouveau]
  Hardware name: LENOVO 20EQS64N0B/20EQS64N0B, BIOS N1EET82W (1.55 ) 12/18/2018
  Workqueue: events_long drm_dp_mst_link_probe_work [drm_kms_helper]
  ...
  nouveau 0000:01:00.0: gr: wait for idle timeout (en: 1, ctxsw: 0, busy: 1)
  nouveau 0000:01:00.0: gr: wait for idle timeout (en: 1, ctxsw: 0, busy: 1)
  nouveau 0000:01:00.0: fifo: fault 01 [WRITE] at 0000000000008000 engine 00 [GR] client 15 [HUB/SCC_NB] reason c4 [] on channel -1 [0000000000 unknown]

The GPU never manages to recover.  Booting without loading nouveau causes
issues as well, since the GPU starts sending spurious interrupts that cause
other device's IRQs to get disabled by the kernel:

  irq 16: nobody cared (try booting with the "irqpoll" option)
  ...
  handlers:
  [<000000007faa9e99>] i801_isr [i2c_i801]
  Disabling IRQ #16
  ...
  serio: RMI4 PS/2 pass-through port at rmi4-00.fn03
  i801_smbus 0000:00:1f.4: Timeout waiting for interrupt!
  i801_smbus 0000:00:1f.4: Transaction timeout
  rmi4_f03 rmi4-00.fn03: rmi_f03_pt_write: Failed to write to F03 TX register (-110).
  i801_smbus 0000:00:1f.4: Timeout waiting for interrupt!
  i801_smbus 0000:00:1f.4: Transaction timeout
  rmi4_physical rmi4-00: rmi_driver_set_irq_bits: Failed to change enabled interrupts!

This causes the touchpad and sometimes other things to get disabled.

Since this happens without nouveau, we can't fix this problem from nouveau
itself.

Add a PCI quirk for the specific P50 variant of this GPU.  Make sure the
GPU is advertising NoReset- so we don't reset the GPU when the machine is
in Dedicated graphics mode (where the GPU being initialized by the BIOS is
normal and expected).  Map the GPU MMIO space and read the magic 0x2240c
register, which will have bit 1 set if the device was POSTed during a
previous boot.  Once we've confirmed all of this, reset the GPU and
re-disable it - bringing it back to a healthy state.

Link: https://bugzilla.kernel.org/show_bug.cgi?id=203003
Link: https://lore.kernel.org/lkml/20190212220230.1568-1-lyude@redhat.com
	Signed-off-by: Lyude Paul <lyude@redhat.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Cc: nouveau@lists.freedesktop.org
	Cc: dri-devel@lists.freedesktop.org
	Cc: Karol Herbst <kherbst@redhat.com>
	Cc: Ben Skeggs <skeggsb@gmail.com>
	Cc: stable@vger.kernel.org
(cherry picked from commit e0547c81bfcfad01cbbfa93a5e66bb98ab932f80)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/quirks.c
diff --cc drivers/pci/quirks.c
index 6a123dc287f4,819a595b0b1d..000000000000
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@@ -4600,3 -4869,312 +4600,315 @@@ static void quirk_intel_no_flr(struct p
  }
  DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x1502, quirk_intel_no_flr);
  DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x1503, quirk_intel_no_flr);
++<<<<<<< HEAD
++=======
+ 
+ static void quirk_no_ext_tags(struct pci_dev *pdev)
+ {
+ 	struct pci_host_bridge *bridge = pci_find_host_bridge(pdev->bus);
+ 
+ 	if (!bridge)
+ 		return;
+ 
+ 	bridge->no_ext_tags = 1;
+ 	pci_info(pdev, "disabling Extended Tags (this device can't handle them)\n");
+ 
+ 	pci_walk_bus(bridge->bus, pci_configure_extended_tags, NULL);
+ }
+ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0132, quirk_no_ext_tags);
+ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0140, quirk_no_ext_tags);
+ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0141, quirk_no_ext_tags);
+ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0142, quirk_no_ext_tags);
+ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0144, quirk_no_ext_tags);
+ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0420, quirk_no_ext_tags);
+ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_SERVERWORKS, 0x0422, quirk_no_ext_tags);
+ 
+ #ifdef CONFIG_PCI_ATS
+ /*
+  * Some devices have a broken ATS implementation causing IOMMU stalls.
+  * Don't use ATS for those devices.
+  */
+ static void quirk_no_ats(struct pci_dev *pdev)
+ {
+ 	pci_info(pdev, "disabling ATS (broken on this device)\n");
+ 	pdev->ats_cap = 0;
+ }
+ 
+ /* AMD Stoney platform GPU */
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI, 0x98e4, quirk_no_ats);
+ #endif /* CONFIG_PCI_ATS */
+ 
+ /* Freescale PCIe doesn't support MSI in RC mode */
+ static void quirk_fsl_no_msi(struct pci_dev *pdev)
+ {
+ 	if (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT)
+ 		pdev->no_msi = 1;
+ }
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_FREESCALE, PCI_ANY_ID, quirk_fsl_no_msi);
+ 
+ /*
+  * GPUs with integrated HDA controller for streaming audio to attached displays
+  * need a device link from the HDA controller (consumer) to the GPU (supplier)
+  * so that the GPU is powered up whenever the HDA controller is accessed.
+  * The GPU and HDA controller are functions 0 and 1 of the same PCI device.
+  * The device link stays in place until shutdown (or removal of the PCI device
+  * if it's hotplugged).  Runtime PM is allowed by default on the HDA controller
+  * to prevent it from permanently keeping the GPU awake.
+  */
+ static void quirk_gpu_hda(struct pci_dev *hda)
+ {
+ 	struct pci_dev *gpu;
+ 
+ 	if (PCI_FUNC(hda->devfn) != 1)
+ 		return;
+ 
+ 	gpu = pci_get_domain_bus_and_slot(pci_domain_nr(hda->bus),
+ 					  hda->bus->number,
+ 					  PCI_DEVFN(PCI_SLOT(hda->devfn), 0));
+ 	if (!gpu || (gpu->class >> 16) != PCI_BASE_CLASS_DISPLAY) {
+ 		pci_dev_put(gpu);
+ 		return;
+ 	}
+ 
+ 	if (!device_link_add(&hda->dev, &gpu->dev,
+ 			     DL_FLAG_STATELESS | DL_FLAG_PM_RUNTIME))
+ 		pci_err(hda, "cannot link HDA to GPU %s\n", pci_name(gpu));
+ 
+ 	pm_runtime_allow(&hda->dev);
+ 	pci_dev_put(gpu);
+ }
+ DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_ATI, PCI_ANY_ID,
+ 			      PCI_CLASS_MULTIMEDIA_HD_AUDIO, 8, quirk_gpu_hda);
+ DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_AMD, PCI_ANY_ID,
+ 			      PCI_CLASS_MULTIMEDIA_HD_AUDIO, 8, quirk_gpu_hda);
+ DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,
+ 			      PCI_CLASS_MULTIMEDIA_HD_AUDIO, 8, quirk_gpu_hda);
+ 
+ /*
+  * Some IDT switches incorrectly flag an ACS Source Validation error on
+  * completions for config read requests even though PCIe r4.0, sec
+  * 6.12.1.1, says that completions are never affected by ACS Source
+  * Validation.  Here's the text of IDT 89H32H8G3-YC, erratum #36:
+  *
+  *   Item #36 - Downstream port applies ACS Source Validation to Completions
+  *   Section 6.12.1.1 of the PCI Express Base Specification 3.1 states that
+  *   completions are never affected by ACS Source Validation.  However,
+  *   completions received by a downstream port of the PCIe switch from a
+  *   device that has not yet captured a PCIe bus number are incorrectly
+  *   dropped by ACS Source Validation by the switch downstream port.
+  *
+  * The workaround suggested by IDT is to issue a config write to the
+  * downstream device before issuing the first config read.  This allows the
+  * downstream device to capture its bus and device numbers (see PCIe r4.0,
+  * sec 2.2.9), thus avoiding the ACS error on the completion.
+  *
+  * However, we don't know when the device is ready to accept the config
+  * write, so we do config reads until we receive a non-Config Request Retry
+  * Status, then do the config write.
+  *
+  * To avoid hitting the erratum when doing the config reads, we disable ACS
+  * SV around this process.
+  */
+ int pci_idt_bus_quirk(struct pci_bus *bus, int devfn, u32 *l, int timeout)
+ {
+ 	int pos;
+ 	u16 ctrl = 0;
+ 	bool found;
+ 	struct pci_dev *bridge = bus->self;
+ 
+ 	pos = pci_find_ext_capability(bridge, PCI_EXT_CAP_ID_ACS);
+ 
+ 	/* Disable ACS SV before initial config reads */
+ 	if (pos) {
+ 		pci_read_config_word(bridge, pos + PCI_ACS_CTRL, &ctrl);
+ 		if (ctrl & PCI_ACS_SV)
+ 			pci_write_config_word(bridge, pos + PCI_ACS_CTRL,
+ 					      ctrl & ~PCI_ACS_SV);
+ 	}
+ 
+ 	found = pci_bus_generic_read_dev_vendor_id(bus, devfn, l, timeout);
+ 
+ 	/* Write Vendor ID (read-only) so the endpoint latches its bus/dev */
+ 	if (found)
+ 		pci_bus_write_config_word(bus, devfn, PCI_VENDOR_ID, 0);
+ 
+ 	/* Re-enable ACS_SV if it was previously enabled */
+ 	if (ctrl & PCI_ACS_SV)
+ 		pci_write_config_word(bridge, pos + PCI_ACS_CTRL, ctrl);
+ 
+ 	return found;
+ }
+ 
+ /*
+  * Microsemi Switchtec NTB uses devfn proxy IDs to move TLPs between
+  * NT endpoints via the internal switch fabric. These IDs replace the
+  * originating requestor ID TLPs which access host memory on peer NTB
+  * ports. Therefore, all proxy IDs must be aliased to the NTB device
+  * to permit access when the IOMMU is turned on.
+  */
+ static void quirk_switchtec_ntb_dma_alias(struct pci_dev *pdev)
+ {
+ 	void __iomem *mmio;
+ 	struct ntb_info_regs __iomem *mmio_ntb;
+ 	struct ntb_ctrl_regs __iomem *mmio_ctrl;
+ 	u64 partition_map;
+ 	u8 partition;
+ 	int pp;
+ 
+ 	if (pci_enable_device(pdev)) {
+ 		pci_err(pdev, "Cannot enable Switchtec device\n");
+ 		return;
+ 	}
+ 
+ 	mmio = pci_iomap(pdev, 0, 0);
+ 	if (mmio == NULL) {
+ 		pci_disable_device(pdev);
+ 		pci_err(pdev, "Cannot iomap Switchtec device\n");
+ 		return;
+ 	}
+ 
+ 	pci_info(pdev, "Setting Switchtec proxy ID aliases\n");
+ 
+ 	mmio_ntb = mmio + SWITCHTEC_GAS_NTB_OFFSET;
+ 	mmio_ctrl = (void __iomem *) mmio_ntb + SWITCHTEC_NTB_REG_CTRL_OFFSET;
+ 
+ 	partition = ioread8(&mmio_ntb->partition_id);
+ 
+ 	partition_map = ioread32(&mmio_ntb->ep_map);
+ 	partition_map |= ((u64) ioread32(&mmio_ntb->ep_map + 4)) << 32;
+ 	partition_map &= ~(1ULL << partition);
+ 
+ 	for (pp = 0; pp < (sizeof(partition_map) * 8); pp++) {
+ 		struct ntb_ctrl_regs __iomem *mmio_peer_ctrl;
+ 		u32 table_sz = 0;
+ 		int te;
+ 
+ 		if (!(partition_map & (1ULL << pp)))
+ 			continue;
+ 
+ 		pci_dbg(pdev, "Processing partition %d\n", pp);
+ 
+ 		mmio_peer_ctrl = &mmio_ctrl[pp];
+ 
+ 		table_sz = ioread16(&mmio_peer_ctrl->req_id_table_size);
+ 		if (!table_sz) {
+ 			pci_warn(pdev, "Partition %d table_sz 0\n", pp);
+ 			continue;
+ 		}
+ 
+ 		if (table_sz > 512) {
+ 			pci_warn(pdev,
+ 				 "Invalid Switchtec partition %d table_sz %d\n",
+ 				 pp, table_sz);
+ 			continue;
+ 		}
+ 
+ 		for (te = 0; te < table_sz; te++) {
+ 			u32 rid_entry;
+ 			u8 devfn;
+ 
+ 			rid_entry = ioread32(&mmio_peer_ctrl->req_id_table[te]);
+ 			devfn = (rid_entry >> 1) & 0xFF;
+ 			pci_dbg(pdev,
+ 				"Aliasing Partition %d Proxy ID %02x.%d\n",
+ 				pp, PCI_SLOT(devfn), PCI_FUNC(devfn));
+ 			pci_add_dma_alias(pdev, devfn);
+ 		}
+ 	}
+ 
+ 	pci_iounmap(pdev, mmio);
+ 	pci_disable_device(pdev);
+ }
+ #define SWITCHTEC_QUIRK(vid) \
+ 	DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_MICROSEMI, vid, \
+ 		PCI_CLASS_BRIDGE_OTHER, 8, quirk_switchtec_ntb_dma_alias)
+ 
+ SWITCHTEC_QUIRK(0x8531);  /* PFX 24xG3 */
+ SWITCHTEC_QUIRK(0x8532);  /* PFX 32xG3 */
+ SWITCHTEC_QUIRK(0x8533);  /* PFX 48xG3 */
+ SWITCHTEC_QUIRK(0x8534);  /* PFX 64xG3 */
+ SWITCHTEC_QUIRK(0x8535);  /* PFX 80xG3 */
+ SWITCHTEC_QUIRK(0x8536);  /* PFX 96xG3 */
+ SWITCHTEC_QUIRK(0x8541);  /* PSX 24xG3 */
+ SWITCHTEC_QUIRK(0x8542);  /* PSX 32xG3 */
+ SWITCHTEC_QUIRK(0x8543);  /* PSX 48xG3 */
+ SWITCHTEC_QUIRK(0x8544);  /* PSX 64xG3 */
+ SWITCHTEC_QUIRK(0x8545);  /* PSX 80xG3 */
+ SWITCHTEC_QUIRK(0x8546);  /* PSX 96xG3 */
+ SWITCHTEC_QUIRK(0x8551);  /* PAX 24XG3 */
+ SWITCHTEC_QUIRK(0x8552);  /* PAX 32XG3 */
+ SWITCHTEC_QUIRK(0x8553);  /* PAX 48XG3 */
+ SWITCHTEC_QUIRK(0x8554);  /* PAX 64XG3 */
+ SWITCHTEC_QUIRK(0x8555);  /* PAX 80XG3 */
+ SWITCHTEC_QUIRK(0x8556);  /* PAX 96XG3 */
+ SWITCHTEC_QUIRK(0x8561);  /* PFXL 24XG3 */
+ SWITCHTEC_QUIRK(0x8562);  /* PFXL 32XG3 */
+ SWITCHTEC_QUIRK(0x8563);  /* PFXL 48XG3 */
+ SWITCHTEC_QUIRK(0x8564);  /* PFXL 64XG3 */
+ SWITCHTEC_QUIRK(0x8565);  /* PFXL 80XG3 */
+ SWITCHTEC_QUIRK(0x8566);  /* PFXL 96XG3 */
+ SWITCHTEC_QUIRK(0x8571);  /* PFXI 24XG3 */
+ SWITCHTEC_QUIRK(0x8572);  /* PFXI 32XG3 */
+ SWITCHTEC_QUIRK(0x8573);  /* PFXI 48XG3 */
+ SWITCHTEC_QUIRK(0x8574);  /* PFXI 64XG3 */
+ SWITCHTEC_QUIRK(0x8575);  /* PFXI 80XG3 */
+ SWITCHTEC_QUIRK(0x8576);  /* PFXI 96XG3 */
+ 
+ /*
+  * On Lenovo Thinkpad P50 SKUs with a Nvidia Quadro M1000M, the BIOS does
+  * not always reset the secondary Nvidia GPU between reboots if the system
+  * is configured to use Hybrid Graphics mode.  This results in the GPU
+  * being left in whatever state it was in during the *previous* boot, which
+  * causes spurious interrupts from the GPU, which in turn causes us to
+  * disable the wrong IRQ and end up breaking the touchpad.  Unsurprisingly,
+  * this also completely breaks nouveau.
+  *
+  * Luckily, it seems a simple reset of the Nvidia GPU brings it back to a
+  * clean state and fixes all these issues.
+  *
+  * When the machine is configured in Dedicated display mode, the issue
+  * doesn't occur.  Fortunately the GPU advertises NoReset+ when in this
+  * mode, so we can detect that and avoid resetting it.
+  */
+ static void quirk_reset_lenovo_thinkpad_p50_nvgpu(struct pci_dev *pdev)
+ {
+ 	void __iomem *map;
+ 	int ret;
+ 
+ 	if (pdev->subsystem_vendor != PCI_VENDOR_ID_LENOVO ||
+ 	    pdev->subsystem_device != 0x222e ||
+ 	    !pdev->reset_fn)
+ 		return;
+ 
+ 	if (pci_enable_device_mem(pdev))
+ 		return;
+ 
+ 	/*
+ 	 * Based on nvkm_device_ctor() in
+ 	 * drivers/gpu/drm/nouveau/nvkm/engine/device/base.c
+ 	 */
+ 	map = pci_iomap(pdev, 0, 0x23000);
+ 	if (!map) {
+ 		pci_err(pdev, "Can't map MMIO space\n");
+ 		goto out_disable;
+ 	}
+ 
+ 	/*
+ 	 * Make sure the GPU looks like it's been POSTed before resetting
+ 	 * it.
+ 	 */
+ 	if (ioread32(map + 0x2240c) & 0x2) {
+ 		pci_info(pdev, FW_BUG "GPU left initialized by EFI, resetting\n");
+ 		ret = pci_reset_function(pdev);
+ 		if (ret < 0)
+ 			pci_err(pdev, "Failed to reset GPU: %d\n", ret);
+ 	}
+ 
+ 	iounmap(map);
+ out_disable:
+ 	pci_disable_device(pdev);
+ }
+ DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_NVIDIA, 0x13b1,
+ 			      PCI_CLASS_DISPLAY_VGA, 8,
+ 			      quirk_reset_lenovo_thinkpad_p50_nvgpu);
++>>>>>>> e0547c81bfcf (PCI: Reset Lenovo ThinkPad P50 nvgpu at boot if necessary)
* Unmerged path drivers/pci/quirks.c
