io: define stronger ordering for the default readX() implementation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Sinan Kaya <okaya@codeaurora.org>
commit 032d59e1cde9dd71bb5918e1f6529776623ee86b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/032d59e1.failed

The default implementation of mapping readX() to __raw_readX() is wrong.
readX() has stronger ordering semantics. Compiler is allowed to reorder
__raw_readX() against the memory accesses following register read.

Use the previously defined __io_ar() and __io_br() macros to harden
code generation according to architecture support.

	Signed-off-by: Sinan Kaya <okaya@codeaurora.org>
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
(cherry picked from commit 032d59e1cde9dd71bb5918e1f6529776623ee86b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/asm-generic/io.h
diff --cc include/asm-generic/io.h
index 66a3fecbf792,d27e8af9dd5a..000000000000
--- a/include/asm-generic/io.h
+++ b/include/asm-generic/io.h
@@@ -46,39 -94,129 +46,97 @@@ static inline u16 __raw_readw(const vol
  #endif
  
  #ifndef __raw_readl
 -#define __raw_readl __raw_readl
  static inline u32 __raw_readl(const volatile void __iomem *addr)
  {
 -	return *(const volatile u32 __force *)addr;
 -}
 -#endif
 -
 -#ifdef CONFIG_64BIT
 -#ifndef __raw_readq
 -#define __raw_readq __raw_readq
 -static inline u64 __raw_readq(const volatile void __iomem *addr)
 -{
 -	return *(const volatile u64 __force *)addr;
 +	return *(const volatile u32 __force *) addr;
  }
  #endif
 -#endif /* CONFIG_64BIT */
  
 -#ifndef __raw_writeb
 -#define __raw_writeb __raw_writeb
 -static inline void __raw_writeb(u8 value, volatile void __iomem *addr)
 -{
 -	*(volatile u8 __force *)addr = value;
 -}
 +#define readb __raw_readb
 +#ifndef readb_relaxed
 +#define readb_relaxed readb
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifndef __raw_writew
+ #define __raw_writew __raw_writew
+ static inline void __raw_writew(u16 value, volatile void __iomem *addr)
+ {
+ 	*(volatile u16 __force *)addr = value;
+ }
+ #endif
+ 
+ #ifndef __raw_writel
+ #define __raw_writel __raw_writel
+ static inline void __raw_writel(u32 value, volatile void __iomem *addr)
+ {
+ 	*(volatile u32 __force *)addr = value;
+ }
+ #endif
+ 
+ #ifdef CONFIG_64BIT
+ #ifndef __raw_writeq
+ #define __raw_writeq __raw_writeq
+ static inline void __raw_writeq(u64 value, volatile void __iomem *addr)
+ {
+ 	*(volatile u64 __force *)addr = value;
+ }
+ #endif
+ #endif /* CONFIG_64BIT */
+ 
+ /*
+  * {read,write}{b,w,l,q}() access little endian memory and return result in
+  * native endianness.
+  */
+ 
+ #ifndef readb
+ #define readb readb
+ static inline u8 readb(const volatile void __iomem *addr)
+ {
+ 	u8 val;
+ 
+ 	__io_br();
+ 	val = __raw_readb(addr);
+ 	__io_ar();
+ 	return val;
+ }
+ #endif
+ 
+ #ifndef readw
++>>>>>>> 032d59e1cde9 (io: define stronger ordering for the default readX() implementation)
  #define readw readw
  static inline u16 readw(const volatile void __iomem *addr)
  {
- 	return __le16_to_cpu(__raw_readw(addr));
+ 	u16 val;
+ 
+ 	__io_br();
+ 	val = __le16_to_cpu(__raw_readw(addr));
+ 	__io_ar();
+ 	return val;
  }
 +#ifndef readw_relaxed
 +#define readw_relaxed readw
  #endif
  
 -#ifndef readl
  #define readl readl
  static inline u32 readl(const volatile void __iomem *addr)
  {
- 	return __le32_to_cpu(__raw_readl(addr));
+ 	u32 val;
+ 
+ 	__io_br();
+ 	val = __le32_to_cpu(__raw_readl(addr));
+ 	__io_ar();
+ 	return val;
  }
 +#ifndef readl_relaxed
 +#define readl_relaxed readl
  #endif
  
 -#ifdef CONFIG_64BIT
 -#ifndef readq
 -#define readq readq
 -static inline u64 readq(const volatile void __iomem *addr)
 -{
 -	u64 val;
 -
 -	__io_br();
 -	val = __le64_to_cpu(__raw_readq(addr));
 -	__io_ar();
 -	return val;
 -}
 -#endif
 -#endif /* CONFIG_64BIT */
 -
 -#ifndef writeb
 -#define writeb writeb
 -static inline void writeb(u8 value, volatile void __iomem *addr)
 -{
 -	__raw_writeb(value, addr);
 -}
 -#endif
 -
 -#ifndef writew
 -#define writew writew
 -static inline void writew(u16 value, volatile void __iomem *addr)
 +#ifndef __raw_writeb
 +static inline void __raw_writeb(u8 b, volatile void __iomem *addr)
  {
 -	__raw_writew(cpu_to_le16(value), addr);
 +	*(volatile u8 __force *) addr = b;
  }
  #endif
  
@@@ -119,19 -360,33 +177,24 @@@ static inline u64 __raw_readq(const vol
  }
  #endif
  
 -#ifndef writesw
 -#define writesw writesw
 -static inline void writesw(volatile void __iomem *addr, const void *buffer,
 -			   unsigned int count)
 +#define readq readq
 +static inline u64 readq(const volatile void __iomem *addr)
  {
- 	return __le64_to_cpu(__raw_readq(addr));
 -	if (count) {
 -		const u16 *buf = buffer;
++	u64 val;
+ 
 -		do {
 -			__raw_writew(*buf++, addr);
 -		} while (--count);
 -	}
++	__io_br();
++	val = __le64_to_cpu(__raw_readq(addr));
++	__io_ar();
++	return val;
  }
 +#ifndef readq_relaxed
 +#define readq_relaxed readq
  #endif
  
 -#ifndef writesl
 -#define writesl writesl
 -static inline void writesl(volatile void __iomem *addr, const void *buffer,
 -			   unsigned int count)
 +#ifndef __raw_writeq
 +static inline void __raw_writeq(u64 b, volatile void __iomem *addr)
  {
 -	if (count) {
 -		const u32 *buf = buffer;
 -
 -		do {
 -			__raw_writel(*buf++, addr);
 -		} while (--count);
 -	}
 +	*(volatile u64 __force *) addr = b;
  }
  #endif
  
* Unmerged path include/asm-generic/io.h
