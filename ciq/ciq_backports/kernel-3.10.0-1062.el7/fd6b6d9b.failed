KVM: VMX: check for existence of secondary exec controls before accessing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit fd6b6d9b82f97a851fb0078201ddc38fe9728cda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fd6b6d9b.failed

Return early from vmx_set_virtual_apic_mode() if the processor doesn't
support VIRTUALIZE_APIC_ACCESSES or VIRTUALIZE_X2APIC_MODE, both of
which reside in SECONDARY_VM_EXEC_CONTROL.  This eliminates warnings
due to VMWRITEs to SECONDARY_VM_EXEC_CONTROL (VMCS field 401e) failing
on processors without secondary exec controls.

Remove the similar check for TPR shadowing as it is incorporated in the
flexpriority_enabled check and the APIC-related code in
vmx_update_msr_bitmap() is further gated by VIRTUALIZE_X2APIC_MODE.

	Reported-by: Gerhard Wiesinger <redhat@wiesinger.com>
Fixes: 8d860bbeedef ("kvm: vmx: Basic APIC virtualization controls have three settings")
	Cc: Jim Mattson <jmattson@google.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit fd6b6d9b82f97a851fb0078201ddc38fe9728cda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 5501a1957de2,764ae031054f..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -8714,31 -10211,40 +8714,44 @@@ static void vmx_set_virtual_x2apic_mode
  {
  	u32 sec_exec_control;
  
++<<<<<<< HEAD
++=======
+ 	if (!lapic_in_kernel(vcpu))
+ 		return;
+ 
+ 	if (!flexpriority_enabled &&
+ 	    !cpu_has_vmx_virtualize_x2apic_mode())
+ 		return;
+ 
++>>>>>>> fd6b6d9b82f9 (KVM: VMX: check for existence of secondary exec controls before accessing)
  	/* Postpone execution until vmcs01 is the current VMCS. */
  	if (is_guest_mode(vcpu)) {
 -		to_vmx(vcpu)->nested.change_vmcs01_virtual_apic_mode = true;
 +		to_vmx(vcpu)->nested.change_vmcs01_virtual_x2apic_mode = true;
  		return;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * There is not point to enable virtualize x2apic without enable
 +	 * apicv
 +	 */
 +	if (!cpu_has_vmx_virtualize_x2apic_mode() ||
 +				!kvm_vcpu_apicv_active(vcpu))
 +		return;
 +
 +	if (!cpu_need_tpr_shadow(vcpu))
 +		return;
 +
++=======
++>>>>>>> fd6b6d9b82f9 (KVM: VMX: check for existence of secondary exec controls before accessing)
  	sec_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);
 -	sec_exec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |
 -			      SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);
  
 -	switch (kvm_get_apic_mode(vcpu)) {
 -	case LAPIC_MODE_INVALID:
 -		WARN_ONCE(true, "Invalid local APIC state");
 -	case LAPIC_MODE_DISABLED:
 -		break;
 -	case LAPIC_MODE_XAPIC:
 -		if (flexpriority_enabled) {
 -			sec_exec_control |=
 -				SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
 -			vmx_flush_tlb(vcpu, true);
 -		}
 -		break;
 -	case LAPIC_MODE_X2APIC:
 -		if (cpu_has_vmx_virtualize_x2apic_mode())
 -			sec_exec_control |=
 -				SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;
 -		break;
 +	if (set) {
 +		sec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
 +		sec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;
 +	} else {
 +		sec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;
 +		sec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
  	}
  	vmcs_write32(SECONDARY_VM_EXEC_CONTROL, sec_exec_control);
  
* Unmerged path arch/x86/kvm/vmx.c
