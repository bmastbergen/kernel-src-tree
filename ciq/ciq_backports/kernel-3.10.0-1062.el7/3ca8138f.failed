fuse: break infinite loop in fuse_fill_write_pages()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Roman Gushchin <klamm@yandex-team.ru>
commit 3ca8138f014a913f98e6ef40e939868e1e9ea876
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3ca8138f.failed

I got a report about unkillable task eating CPU. Further
investigation shows, that the problem is in the fuse_fill_write_pages()
function. If iov's first segment has zero length, we get an infinite
loop, because we never reach iov_iter_advance() call.

Fix this by calling iov_iter_advance() before repeating an attempt to
copy data from userspace.

A similar problem is described in 124d3b7041f ("fix writev regression:
pan hanging unkillable and un-straceable"). If zero-length segmend
is followed by segment with invalid address,
iov_iter_fault_in_readable() checks only first segment (zero-length),
iov_iter_copy_from_user_atomic() skips it, fails at second and
returns zero -> goto again without skipping zero-length segment.

Patch calls iov_iter_advance() before goto again: we'll skip zero-length
segment at second iteraction and iov_iter_fault_in_readable() will detect
invalid address.

Special thanks to Konstantin Khlebnikov, who helped a lot with the commit
description.

	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Maxim Patlasov <mpatlasov@parallels.com>
	Cc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
	Signed-off-by: Roman Gushchin <klamm@yandex-team.ru>
	Signed-off-by: Miklos Szeredi <miklos@szeredi.hu>
Fixes: ea9b9907b82a ("fuse: implement perform_write")
	Cc: <stable@vger.kernel.org>
(cherry picked from commit 3ca8138f014a913f98e6ef40e939868e1e9ea876)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/file.c
diff --cc fs/fuse/file.c
index d613834754c6,195476a24148..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -1077,8 -1049,7 +1077,12 @@@ static ssize_t fuse_fill_write_pages(st
  		tmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);
  		flush_dcache_page(page);
  
++<<<<<<< HEAD
 +		mark_page_accessed(page);
 +
++=======
+ 		iov_iter_advance(ii, tmp);
++>>>>>>> 3ca8138f014a (fuse: break infinite loop in fuse_fill_write_pages())
  		if (!tmp) {
  			unlock_page(page);
  			page_cache_release(page);
* Unmerged path fs/fuse/file.c
