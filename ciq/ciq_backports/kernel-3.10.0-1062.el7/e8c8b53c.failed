net/mlx5e: Force CHECKSUM_UNNECESSARY for short ethernet frames

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Force CHECKSUM_UNNECESSARY for short ethernet frames (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 96.72%
commit-author Cong Wang <xiyou.wangcong@gmail.com>
commit e8c8b53ccaff568fef4c13a6ccaf08bf241aa01a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e8c8b53c.failed

When an ethernet frame is padded to meet the minimum ethernet frame
size, the padding octets are not covered by the hardware checksum.
Fortunately the padding octets are usually zero's, which don't affect
checksum. However, we have a switch which pads non-zero octets, this
causes kernel hardware checksum fault repeatedly.

Prior to:
commit '88078d98d1bb ("net: pskb_trim_rcsum() and CHECKSUM_COMPLETE ...")'
skb checksum was forced to be CHECKSUM_NONE when padding is detected.
After it, we need to keep skb->csum updated, like what we do for RXFCS.
However, fixing up CHECKSUM_COMPLETE requires to verify and parse IP
headers, it is not worthy the effort as the packets are so small that
CHECKSUM_COMPLETE can't save anything.

Fixes: 88078d98d1bb ("net: pskb_trim_rcsum() and CHECKSUM_COMPLETE are friends"),
	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Tariq Toukan <tariqt@mellanox.com>
	Cc: Nikola Ciprich <nikola.ciprich@linuxbox.cz>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit e8c8b53ccaff568fef4c13a6ccaf08bf241aa01a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
index a60ee24e6b99,f86e4804e83e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
@@@ -635,14 -688,52 +635,16 @@@ static inline void mlx5e_skb_set_hash(s
  	skb_set_hash(skb, be32_to_cpu(cqe->rss_hash_result), ht);
  }
  
 -static inline bool is_last_ethertype_ip(struct sk_buff *skb, int *network_depth,
 -					__be16 *proto)
 +static inline bool is_last_ethertype_ip(struct sk_buff *skb, int *network_depth)
  {
 -	*proto = ((struct ethhdr *)skb->data)->h_proto;
 -	*proto = __vlan_get_protocol(skb, *proto, network_depth);
 -	return (*proto == htons(ETH_P_IP) || *proto == htons(ETH_P_IPV6));
 -}
 +	__be16 ethertype = ((struct ethhdr *)skb->data)->h_proto;
  
 -static inline void mlx5e_enable_ecn(struct mlx5e_rq *rq, struct sk_buff *skb)
 -{
 -	int network_depth = 0;
 -	__be16 proto;
 -	void *ip;
 -	int rc;
 -
 -	if (unlikely(!is_last_ethertype_ip(skb, &network_depth, &proto)))
 -		return;
 -
 -	ip = skb->data + network_depth;
 -	rc = ((proto == htons(ETH_P_IP)) ? IP_ECN_set_ce((struct iphdr *)ip) :
 -					 IP6_ECN_set_ce(skb, (struct ipv6hdr *)ip));
 -
 -	rq->stats->ecn_mark += !!rc;
 -}
 -
 -static u32 mlx5e_get_fcs(const struct sk_buff *skb)
 -{
 -	const void *fcs_bytes;
 -	u32 _fcs_bytes;
 -
 -	fcs_bytes = skb_header_pointer(skb, skb->len - ETH_FCS_LEN,
 -				       ETH_FCS_LEN, &_fcs_bytes);
 -
 -	return __get_unaligned_cpu32(fcs_bytes);
 -}
 -
 -static u8 get_ip_proto(struct sk_buff *skb, int network_depth, __be16 proto)
 -{
 -	void *ip_p = skb->data + network_depth;
 -
 -	return (proto == htons(ETH_P_IP)) ? ((struct iphdr *)ip_p)->protocol :
 -					    ((struct ipv6hdr *)ip_p)->nexthdr;
 +	ethertype = __vlan_get_protocol(skb, ethertype, network_depth);
 +	return (ethertype == htons(ETH_P_IP) || ethertype == htons(ETH_P_IPV6));
  }
  
+ #define short_frame(size) ((size) <= ETH_ZLEN + ETH_FCS_LEN)
+ 
  static inline void mlx5e_handle_csum(struct net_device *netdev,
  				     struct mlx5_cqe64 *cqe,
  				     struct mlx5e_rq *rq,
@@@ -661,7 -753,24 +663,28 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	if (likely(is_last_ethertype_ip(skb, &network_depth))) {
++=======
+ 	if (unlikely(test_bit(MLX5E_RQ_STATE_NO_CSUM_COMPLETE, &rq->state)))
+ 		goto csum_unnecessary;
+ 
+ 	/* CQE csum doesn't cover padding octets in short ethernet
+ 	 * frames. And the pad field is appended prior to calculating
+ 	 * and appending the FCS field.
+ 	 *
+ 	 * Detecting these padded frames requires to verify and parse
+ 	 * IP headers, so we simply force all those small frames to be
+ 	 * CHECKSUM_UNNECESSARY even if they are not padded.
+ 	 */
+ 	if (short_frame(skb->len))
+ 		goto csum_unnecessary;
+ 
+ 	if (likely(is_last_ethertype_ip(skb, &network_depth, &proto))) {
+ 		if (unlikely(get_ip_proto(skb, network_depth, proto) == IPPROTO_SCTP))
+ 			goto csum_unnecessary;
+ 
++>>>>>>> e8c8b53ccaff (net/mlx5e: Force CHECKSUM_UNNECESSARY for short ethernet frames)
  		skb->ip_summed = CHECKSUM_COMPLETE;
  		skb->csum = csum_unfold((__force __sum16)cqe->check_sum);
  		if (network_depth > ETH_HLEN)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
