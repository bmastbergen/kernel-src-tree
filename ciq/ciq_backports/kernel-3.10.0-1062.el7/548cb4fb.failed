RDMA/core: Refactor ib_register_device() function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Parav Pandit <parav@mellanox.com>
commit 548cb4fbe80d68b9d1b8b30aca179636e74bec36
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/548cb4fb.failed

ib_register_device() does several allocation and initialization
steps. Split it into smaller more readable functions for easy
review and maintenance.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Daniel Jurgens <danielj@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 548cb4fbe80d68b9d1b8b30aca179636e74bec36)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/device.c
diff --cc drivers/infiniband/core/device.c
index 910f35ee49f7,87eb4f2cdd7d..000000000000
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@@ -446,22 -465,8 +446,23 @@@ static u32 __dev_new_index(void
  	}
  }
  
++<<<<<<< HEAD
 +/**
 + * ib_register_device - Register an IB device with IB core
 + * @device:Device to register
 + *
 + * Low-level drivers use ib_register_device() to register their
 + * devices with the IB core.  All registered clients will receive a
 + * callback for each device that is added. @device must be allocated
 + * with ib_alloc_device().
 + */
 +int ib_register_device(struct ib_device *device,
 +		       int (*port_callback)(struct ib_device *,
 +					    u8, struct kobject *))
++=======
+ static void setup_dma_device(struct ib_device *device)
++>>>>>>> 548cb4fbe80d (RDMA/core: Refactor ib_register_device() function)
  {
- 	int ret;
- 	struct ib_client *client;
- 	struct ib_udata uhw = {.outlen = 0, .inlen = 0};
  	struct device *parent = device->dev.parent;
  
  	WARN_ON_ONCE(device->dma_device);
@@@ -496,41 -573,32 +569,52 @@@ int ib_register_device(struct ib_devic
  
  	mutex_lock(&device_mutex);
  
 -	if (strchr(name, '%')) {
 -		ret = alloc_name(device, name);
 +	if (strchr(device->name, '%')) {
 +		ret = alloc_name(device->name);
  		if (ret)
  			goto out;
 -	} else {
 -		ret = dev_set_name(&device->dev, name);
 -		if (ret)
 -			goto out;
 -	}
 -	if (__ib_device_get_by_name(dev_name(&device->dev))) {
 -		ret = -ENFILE;
 -		goto out;
  	}
 -	strlcpy(device->name, dev_name(&device->dev), IB_DEVICE_NAME_MAX);
  
- 	if (ib_device_check_mandatory(device)) {
- 		ret = -EINVAL;
+ 	ret = setup_device(device);
+ 	if (ret)
  		goto out;
++<<<<<<< HEAD
 +	}
 +
 +	ret = read_port_immutable(device);
 +	if (ret) {
 +		pr_warn("Couldn't create per port immutable data %s\n",
 +			device->name);
 +		goto out;
 +	}
 +
 +	ret = setup_port_pkey_list(device);
 +	if (ret) {
 +		pr_warn("Couldn't create per port_pkey_list\n");
 +		goto out;
 +	}
 +
 +	ret = ib_cache_setup_one(device);
 +	if (ret) {
 +		pr_warn("Couldn't set up InfiniBand P_Key/GID cache\n");
 +		goto port_cleanup;
 +	}
 +
 +	memset(&device->attrs, 0, sizeof(device->attrs));
 +	ret = device->query_device(device, &device->attrs, &uhw);
 +	if (ret) {
 +		pr_warn("Couldn't query the device attributes\n");
 +		goto cache_cleanup;
++=======
+ 
+ 	device->index = __dev_new_index();
+ 
+ 	ret = ib_device_register_rdmacg(device);
+ 	if (ret) {
+ 		dev_warn(&device->dev,
+ 			 "Couldn't register device with rdma cgroup\n");
+ 		goto dev_cleanup;
++>>>>>>> 548cb4fbe80d (RDMA/core: Refactor ib_register_device() function)
  	}
  
  	ret = ib_device_register_sysfs(device, port_callback);
@@@ -553,11 -620,10 +637,18 @@@
  	mutex_unlock(&device_mutex);
  	return 0;
  
++<<<<<<< HEAD
 +cache_cleanup:
 +	ib_cache_cleanup_one(device);
 +	ib_cache_release_one(device);
 +port_cleanup:
 +	kfree(device->port_immutable);
++=======
+ cg_cleanup:
+ 	ib_device_unregister_rdmacg(device);
+ dev_cleanup:
+ 	cleanup_device(device);
++>>>>>>> 548cb4fbe80d (RDMA/core: Refactor ib_register_device() function)
  out:
  	mutex_unlock(&device_mutex);
  	return ret;
* Unmerged path drivers/infiniband/core/device.c
