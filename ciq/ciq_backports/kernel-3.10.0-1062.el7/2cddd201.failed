net/sched: cls_flower: allocate mask dynamically in fl_change()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [net] sched: cls_flower: allocate mask dynamically in fl_change() (Ivan Vecera) [1666481]
Rebuild_FUZZ: 96.72%
commit-author Ivan Vecera <ivecera@redhat.com>
commit 2cddd20147826aef283115abb00012d4dafe3cdb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/2cddd201.failed

Recent changes (especially 05cd271fd61a ("cls_flower: Support multiple
masks per priority")) in the fl_flow_mask structure grow it and its
current size e.g. on x86_64 with defconfig is 760 bytes and more than
1024 bytes with some debug options enabled. Prior the mentioned commit
its size was 176 bytes (using defconfig on x86_64).
With regard to this fact it's reasonable to allocate this structure
dynamically in fl_change() to reduce its stack size.

v2:
- use kzalloc() instead of kcalloc()

Fixes: 05cd271fd61a ("cls_flower: Support multiple masks per priority")
	Cc: Jiri Pirko <jiri@resnulli.us>
	Cc: Paul Blakey <paulb@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Ivan Vecera <ivecera@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2cddd20147826aef283115abb00012d4dafe3cdb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_flower.c
diff --cc net/sched/cls_flower.c
index eb4e6a91f3e1,f6aa57fbbbaf..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -919,19 -1290,25 +919,34 @@@ static int fl_change(struct net *net, s
  	struct cls_fl_head *head = rtnl_dereference(tp->root);
  	struct cls_fl_filter *fold = *arg;
  	struct cls_fl_filter *fnew;
+ 	struct fl_flow_mask *mask;
  	struct nlattr **tb;
++<<<<<<< HEAD
 +	struct fl_flow_mask mask = {};
 +	unsigned long idr_index;
++=======
++>>>>>>> 2cddd2014782 (net/sched: cls_flower: allocate mask dynamically in fl_change())
  	int err;
  
  	if (!tca[TCA_OPTIONS])
  		return -EINVAL;
  
- 	tb = kcalloc(TCA_FLOWER_MAX + 1, sizeof(struct nlattr *), GFP_KERNEL);
- 	if (!tb)
+ 	mask = kzalloc(sizeof(struct fl_flow_mask), GFP_KERNEL);
+ 	if (!mask)
  		return -ENOBUFS;
  
++<<<<<<< HEAD
 +	err = nla_parse_nested(tb, TCA_FLOWER_MAX, tca[TCA_OPTIONS], fl_policy);
++=======
+ 	tb = kcalloc(TCA_FLOWER_MAX + 1, sizeof(struct nlattr *), GFP_KERNEL);
+ 	if (!tb) {
+ 		err = -ENOBUFS;
+ 		goto errout_mask_alloc;
+ 	}
+ 
+ 	err = nla_parse_nested(tb, TCA_FLOWER_MAX, tca[TCA_OPTIONS],
+ 			       fl_policy, NULL);
++>>>>>>> 2cddd2014782 (net/sched: cls_flower: allocate mask dynamically in fl_change())
  	if (err < 0)
  		goto errout_tb;
  
@@@ -976,11 -1349,12 +991,20 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	err = fl_set_parms(net, tp, fnew, &mask, base, tb, tca[TCA_RATE], ovr);
 +	if (err)
 +		goto errout_idr;
 +
 +	err = fl_check_assign_mask(head, &mask);
++=======
+ 	err = fl_set_parms(net, tp, fnew, mask, base, tb, tca[TCA_RATE], ovr,
+ 			   tp->chain->tmplt_priv, extack);
+ 	if (err)
+ 		goto errout_idr;
+ 
+ 	err = fl_check_assign_mask(head, fnew, fold, mask);
++>>>>>>> 2cddd2014782 (net/sched: cls_flower: allocate mask dynamically in fl_change())
  	if (err)
  		goto errout_idr;
  
@@@ -1030,11 -1398,15 +1054,12 @@@
  	}
  
  	kfree(tb);
+ 	kfree(mask);
  	return 0;
  
 -errout_mask:
 -	fl_mask_put(head, fnew->mask, false);
 -
  errout_idr:
 -	if (!fold)
 -		idr_remove(&head->handle_idr, fnew->handle);
 +	if (fnew->handle)
 +		idr_remove_ext(&head->handle_idr, fnew->handle);
  errout:
  	tcf_exts_destroy(&fnew->exts);
  	kfree(fnew);
* Unmerged path net/sched/cls_flower.c
