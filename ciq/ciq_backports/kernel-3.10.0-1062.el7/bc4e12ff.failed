net/mlx5: Refactor queries to speed fields in Port Type and Speed register

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Refactor queries to speed fields in Port Type and Speed register (Alaa Hleihel) [1590191]
Rebuild_FUZZ: 97.22%
commit-author Aya Levin <ayal@mellanox.com>
commit bc4e12ffefdd886057eabe38135515690d0756a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/bc4e12ff.failed

This patch fascicles queries to speed related fields in Port Type and
Speed register (PTYS) into a single API. I addition, this patch
refactors functions which serves only Ethernet driver: remove the
protocol type as an input parameter, move code from 'core' directory
into 'en' directory and add 'eth' prefix to the function's name. The
patch also encapsulates functions that are not used outside the Ethernet
driver removes redundant include files.

	Signed-off-by: Aya Levin <ayal@mellanox.com>
	Reviewed-by: Eran Ben Elisha <eranbe@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit bc4e12ffefdd886057eabe38135515690d0756a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/port.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index 889e7668b711,c29e141d72fb..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -939,24 -878,11 +939,24 @@@ static u32 mlx5e_ethtool2ptys_adver_lin
  	return ptys_modes;
  }
  
 -int mlx5e_ethtool_set_link_ksettings(struct mlx5e_priv *priv,
 -				     const struct ethtool_link_ksettings *link_ksettings)
 +static u32 mlx5e_ethtool2ptys_speed_link(u32 speed)
 +{
 +	u32 i, speed_links = 0;
 +
 +	for (i = 0; i < MLX5E_LINK_MODES_NUMBER; ++i) {
 +		if (ptys2ethtool_table[i].speed == speed)
 +			speed_links |= MLX5E_PROT_MASK(i);
 +	}
 +
 +	return speed_links;
 +}
 +
 +static int mlx5e_set_link_ksettings(struct net_device *netdev,
 +				    const struct ethtool_link_ksettings *link_ksettings)
  {
 +	struct mlx5e_priv *priv    = netdev_priv(netdev);
  	struct mlx5_core_dev *mdev = priv->mdev;
- 	u32 eth_proto_cap, eth_proto_admin;
+ 	struct mlx5e_port_eth_proto eproto;
  	bool an_changes = false;
  	u8 an_disable_admin;
  	u8 an_disable_cap;
@@@ -970,32 -896,25 +970,41 @@@
  
  	link_modes = link_ksettings->base.autoneg == AUTONEG_ENABLE ?
  		mlx5e_ethtool2ptys_adver_link(link_ksettings->link_modes.advertising) :
 -		mlx5e_port_speed2linkmodes(speed);
 +		mlx5e_ethtool2ptys_speed_link(speed);
  
- 	err = mlx5_query_port_proto_cap(mdev, &eth_proto_cap, MLX5_PTYS_EN);
+ 	err = mlx5_port_query_eth_proto(mdev, 1, &eproto);
  	if (err) {
++<<<<<<< HEAD
 +		netdev_err(netdev, "%s: query port eth proto cap failed: %d\n",
++=======
+ 		netdev_err(priv->netdev, "%s: query port eth proto failed: %d\n",
++>>>>>>> bc4e12ffefdd (net/mlx5: Refactor queries to speed fields in Port Type and Speed register)
  			   __func__, err);
  		goto out;
  	}
  
- 	link_modes = link_modes & eth_proto_cap;
+ 	link_modes = link_modes & eproto.cap;
  	if (!link_modes) {
 -		netdev_err(priv->netdev, "%s: Not supported link mode(s) requested",
 +		netdev_err(netdev, "%s: Not supported link mode(s) requested",
  			   __func__);
  		err = -EINVAL;
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	err = mlx5_query_port_proto_admin(mdev, &eth_proto_admin, MLX5_PTYS_EN);
 +	if (err) {
 +		netdev_err(netdev, "%s: query port eth proto admin failed: %d\n",
 +			   __func__, err);
 +		goto out;
 +	}
 +
 +	mlx5_query_port_autoneg(mdev, MLX5_PTYS_EN, &an_status,
 +				&an_disable_cap, &an_disable_admin);
++=======
+ 	mlx5_port_query_eth_autoneg(mdev, &an_status, &an_disable_cap,
+ 				    &an_disable_admin);
++>>>>>>> bc4e12ffefdd (net/mlx5: Refactor queries to speed fields in Port Type and Speed register)
  
  	an_disable = link_ksettings->base.autoneg == AUTONEG_DISABLE;
  	an_changes = ((!an_disable && an_disable_admin) ||
diff --cc drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
index 6b38b6fbd030,4bdab8be10af..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
@@@ -35,18 -36,37 +35,37 @@@
  #include <linux/mlx5/driver.h>
  #include "en.h"
  
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
 +struct mlx5_vxlan_port;
++=======
+ struct mlx5e_port_eth_proto {
+ 	u32 cap;
+ 	u32 admin;
+ 	u32 oper;
+ };
+ 
+ int mlx5_port_query_eth_proto(struct mlx5_core_dev *dev, u8 port,
+ 			      struct mlx5e_port_eth_proto *eproto);
+ void mlx5_port_query_eth_autoneg(struct mlx5_core_dev *dev, u8 *an_status,
+ 				 u8 *an_disable_cap, u8 *an_disable_admin);
+ int mlx5_port_set_eth_ptys(struct mlx5_core_dev *dev, bool an_disable,
+ 			   u32 proto_admin);
+ u32 mlx5e_port_ptys2speed(u32 eth_proto_oper);
+ int mlx5e_port_linkspeed(struct mlx5_core_dev *mdev, u32 *speed);
+ int mlx5e_port_max_linkspeed(struct mlx5_core_dev *mdev, u32 *speed);
+ u32 mlx5e_port_speed2linkmodes(u32 speed);
++>>>>>>> bc4e12ffefdd (net/mlx5: Refactor queries to speed fields in Port Type and Speed register):drivers/net/ethernet/mellanox/mlx5/core/en/port.h
  
 -int mlx5e_port_query_pbmc(struct mlx5_core_dev *mdev, void *out);
 -int mlx5e_port_set_pbmc(struct mlx5_core_dev *mdev, void *in);
 -int mlx5e_port_query_priority2buffer(struct mlx5_core_dev *mdev, u8 *buffer);
 -int mlx5e_port_set_priority2buffer(struct mlx5_core_dev *mdev, u8 *buffer);
 -
 -int mlx5e_get_fec_caps(struct mlx5_core_dev *dev, u8 *fec_caps);
 -int mlx5e_get_fec_mode(struct mlx5_core_dev *dev, u32 *fec_mode_active,
 -		       u8 *fec_configured_mode);
 -int mlx5e_set_fec_mode(struct mlx5_core_dev *dev, u8 fec_policy);
 +static inline bool mlx5e_vxlan_allowed(struct mlx5_core_dev *mdev)
 +{
 +	return (MLX5_CAP_ETH(mdev, tunnel_stateless_vxlan) &&
 +		mlx5_core_is_pf(mdev));
 +}
  
 -enum {
 -	MLX5E_FEC_NOFEC,
 -	MLX5E_FEC_FIRECODE,
 -	MLX5E_FEC_RS_528_514,
 -};
 +void mlx5e_vxlan_init(struct mlx5e_priv *priv);
 +void mlx5e_vxlan_cleanup(struct mlx5e_priv *priv);
 +void mlx5e_vxlan_add_port(struct mlx5e_priv *priv, u16 port);
 +void mlx5e_vxlan_del_port(struct mlx5e_priv *priv, u16 port);
 +struct mlx5_vxlan_port *mlx5e_vxlan_lookup_port(struct mlx5e_priv *priv, u16 port);
  
 -#endif
 +#endif /* __MLX5_VXLAN_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/port.c
diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c
index db7406c6b74d..7d23dbda0c67 100644
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@ -375,6 +375,7 @@ static int mlx5_query_port_roce(struct ib_device *device, u8 port_num,
 				struct ib_port_attr *props)
 {
 	struct mlx5_ib_dev *dev = to_mdev(device);
+	u32 out[MLX5_ST_SZ_DW(ptys_reg)] = {0};
 	struct mlx5_core_dev *mdev;
 	struct net_device *ndev, *upper;
 	enum ib_mtu ndev_ib_mtu;
@@ -398,10 +399,11 @@ static int mlx5_query_port_roce(struct ib_device *device, u8 port_num,
 	/* Possible bad flows are checked before filling out props so in case
 	 * of an error it will still be zeroed out.
 	 */
-	err = mlx5_query_port_eth_proto_oper(mdev, &eth_prot_oper,
-					     mdev_port_num);
+	err = mlx5_query_port_ptys(mdev, out, sizeof(out), MLX5_PTYS_EN,
+				   mdev_port_num);
 	if (err)
 		goto out;
+	eth_prot_oper = MLX5_GET(ptys_reg, out, eth_proto_oper);
 
 	props->active_width     = IB_WIDTH_4X;
 	props->active_speed     = IB_SPEED_QDR;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/port.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/port.c b/drivers/net/ethernet/mellanox/mlx5/core/port.c
index 31a9cbd85689..40d26547855d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/port.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/port.c
@@ -30,10 +30,7 @@
  * SOFTWARE.
  */
 
-#include <linux/module.h>
-#include <linux/mlx5/driver.h>
 #include <linux/mlx5/port.h>
-#include <linux/mlx5/cmd.h>
 #include "mlx5_core.h"
 
 int mlx5_core_access_reg(struct mlx5_core_dev *dev, void *data_in,
@@ -157,44 +154,6 @@ int mlx5_set_port_beacon(struct mlx5_core_dev *dev, u16 beacon_duration)
 				    sizeof(out), MLX5_REG_MLCR, 0, 1);
 }
 
-int mlx5_query_port_proto_cap(struct mlx5_core_dev *dev,
-			      u32 *proto_cap, int proto_mask)
-{
-	u32 out[MLX5_ST_SZ_DW(ptys_reg)];
-	int err;
-
-	err = mlx5_query_port_ptys(dev, out, sizeof(out), proto_mask, 1);
-	if (err)
-		return err;
-
-	if (proto_mask == MLX5_PTYS_EN)
-		*proto_cap = MLX5_GET(ptys_reg, out, eth_proto_capability);
-	else
-		*proto_cap = MLX5_GET(ptys_reg, out, ib_proto_capability);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(mlx5_query_port_proto_cap);
-
-int mlx5_query_port_proto_admin(struct mlx5_core_dev *dev,
-				u32 *proto_admin, int proto_mask)
-{
-	u32 out[MLX5_ST_SZ_DW(ptys_reg)];
-	int err;
-
-	err = mlx5_query_port_ptys(dev, out, sizeof(out), proto_mask, 1);
-	if (err)
-		return err;
-
-	if (proto_mask == MLX5_PTYS_EN)
-		*proto_admin = MLX5_GET(ptys_reg, out, eth_proto_admin);
-	else
-		*proto_admin = MLX5_GET(ptys_reg, out, ib_proto_admin);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(mlx5_query_port_proto_admin);
-
 int mlx5_query_port_link_width_oper(struct mlx5_core_dev *dev,
 				    u8 *link_width_oper, u8 local_port)
 {
@@ -211,23 +170,6 @@ int mlx5_query_port_link_width_oper(struct mlx5_core_dev *dev,
 }
 EXPORT_SYMBOL_GPL(mlx5_query_port_link_width_oper);
 
-int mlx5_query_port_eth_proto_oper(struct mlx5_core_dev *dev,
-				   u32 *proto_oper, u8 local_port)
-{
-	u32 out[MLX5_ST_SZ_DW(ptys_reg)];
-	int err;
-
-	err = mlx5_query_port_ptys(dev, out, sizeof(out), MLX5_PTYS_EN,
-				   local_port);
-	if (err)
-		return err;
-
-	*proto_oper = MLX5_GET(ptys_reg, out, eth_proto_oper);
-
-	return 0;
-}
-EXPORT_SYMBOL(mlx5_query_port_eth_proto_oper);
-
 int mlx5_query_port_ib_proto_oper(struct mlx5_core_dev *dev,
 				  u8 *proto_oper, u8 local_port)
 {
@@ -245,35 +187,6 @@ int mlx5_query_port_ib_proto_oper(struct mlx5_core_dev *dev,
 }
 EXPORT_SYMBOL(mlx5_query_port_ib_proto_oper);
 
-int mlx5_set_port_ptys(struct mlx5_core_dev *dev, bool an_disable,
-		       u32 proto_admin, int proto_mask)
-{
-	u32 out[MLX5_ST_SZ_DW(ptys_reg)];
-	u32 in[MLX5_ST_SZ_DW(ptys_reg)];
-	u8 an_disable_admin;
-	u8 an_disable_cap;
-	u8 an_status;
-
-	mlx5_query_port_autoneg(dev, proto_mask, &an_status,
-				&an_disable_cap, &an_disable_admin);
-	if (!an_disable_cap && an_disable)
-		return -EPERM;
-
-	memset(in, 0, sizeof(in));
-
-	MLX5_SET(ptys_reg, in, local_port, 1);
-	MLX5_SET(ptys_reg, in, an_disable_admin, an_disable);
-	MLX5_SET(ptys_reg, in, proto_mask, proto_mask);
-	if (proto_mask == MLX5_PTYS_EN)
-		MLX5_SET(ptys_reg, in, eth_proto_admin, proto_admin);
-	else
-		MLX5_SET(ptys_reg, in, ib_proto_admin, proto_admin);
-
-	return mlx5_core_access_reg(dev, in, sizeof(in), out,
-				    sizeof(out), MLX5_REG_PTYS, 0, 1);
-}
-EXPORT_SYMBOL_GPL(mlx5_set_port_ptys);
-
 /* This function should be used after setting a port register only */
 void mlx5_toggle_port_link(struct mlx5_core_dev *dev)
 {
@@ -606,25 +519,6 @@ int mlx5_query_port_pfc(struct mlx5_core_dev *dev, u8 *pfc_en_tx, u8 *pfc_en_rx)
 }
 EXPORT_SYMBOL_GPL(mlx5_query_port_pfc);
 
-void mlx5_query_port_autoneg(struct mlx5_core_dev *dev, int proto_mask,
-			     u8 *an_status,
-			     u8 *an_disable_cap, u8 *an_disable_admin)
-{
-	u32 out[MLX5_ST_SZ_DW(ptys_reg)];
-
-	*an_status = 0;
-	*an_disable_cap = 0;
-	*an_disable_admin = 0;
-
-	if (mlx5_query_port_ptys(dev, out, sizeof(out), proto_mask, 1))
-		return;
-
-	*an_status = MLX5_GET(ptys_reg, out, an_status);
-	*an_disable_cap = MLX5_GET(ptys_reg, out, an_disable_cap);
-	*an_disable_admin = MLX5_GET(ptys_reg, out, an_disable_admin);
-}
-EXPORT_SYMBOL_GPL(mlx5_query_port_autoneg);
-
 int mlx5_max_tc(struct mlx5_core_dev *mdev)
 {
 	u8 num_tc = MLX5_CAP_GEN(mdev, max_tc) ? : 8;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
diff --git a/include/linux/mlx5/port.h b/include/linux/mlx5/port.h
index 34aed6032f86..2801dff03279 100644
--- a/include/linux/mlx5/port.h
+++ b/include/linux/mlx5/port.h
@@ -113,27 +113,16 @@ enum mlx5e_connector_type {
 int mlx5_set_port_caps(struct mlx5_core_dev *dev, u8 port_num, u32 caps);
 int mlx5_query_port_ptys(struct mlx5_core_dev *dev, u32 *ptys,
 			 int ptys_size, int proto_mask, u8 local_port);
-int mlx5_query_port_proto_cap(struct mlx5_core_dev *dev,
-			      u32 *proto_cap, int proto_mask);
-int mlx5_query_port_proto_admin(struct mlx5_core_dev *dev,
-				u32 *proto_admin, int proto_mask);
 int mlx5_query_port_link_width_oper(struct mlx5_core_dev *dev,
 				    u8 *link_width_oper, u8 local_port);
 int mlx5_query_port_ib_proto_oper(struct mlx5_core_dev *dev,
 				  u8 *proto_oper, u8 local_port);
-int mlx5_query_port_eth_proto_oper(struct mlx5_core_dev *dev,
-				   u32 *proto_oper, u8 local_port);
-int mlx5_set_port_ptys(struct mlx5_core_dev *dev, bool an_disable,
-		       u32 proto_admin, int proto_mask);
 void mlx5_toggle_port_link(struct mlx5_core_dev *dev);
 int mlx5_set_port_admin_status(struct mlx5_core_dev *dev,
 			       enum mlx5_port_status status);
 int mlx5_query_port_admin_status(struct mlx5_core_dev *dev,
 				 enum mlx5_port_status *status);
 int mlx5_set_port_beacon(struct mlx5_core_dev *dev, u16 beacon_duration);
-void mlx5_query_port_autoneg(struct mlx5_core_dev *dev, int proto_mask,
-			     u8 *an_status,
-			     u8 *an_disable_cap, u8 *an_disable_admin);
 
 int mlx5_set_port_mtu(struct mlx5_core_dev *dev, u16 mtu, u8 port);
 void mlx5_query_port_max_mtu(struct mlx5_core_dev *dev, u16 *max_mtu, u8 port);
