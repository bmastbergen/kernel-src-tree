ALSA: hda/ca0132 - Add ZxR DSP post-download commands

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit c25c73e06a70765578c86569086965b61973283f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c25c73e0.failed

This patch adds commands for setting up the ZxR after the DSP is
downloaded. The ZxR already shares most of the post-download commands
from the regular Sound Blaster Z.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit c25c73e06a70765578c86569086965b61973283f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index 5992a3b4cc50,729766a57189..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -4376,6 -6754,351 +4376,354 @@@ static void ca0132_refresh_widget_caps(
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Creates a dummy stream to bind the output to. This seems to have to be done
+  * after changing the main outputs source and destination streams.
+  */
+ static void ca0132_alt_create_dummy_stream(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int stream_format;
+ 
+ 	stream_format = snd_hdac_calc_stream_format(48000, 2,
+ 			SNDRV_PCM_FORMAT_S32_LE, 32, 0);
+ 
+ 	snd_hda_codec_setup_stream(codec, spec->dacs[0], spec->dsp_stream_id,
+ 					0, stream_format);
+ 
+ 	snd_hda_codec_cleanup_stream(codec, spec->dacs[0]);
+ }
+ 
+ /*
+  * Initialize mic for non-chromebook ca0132 implementations.
+  */
+ static void ca0132_alt_init_analog_mics(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	/* Mic 1 Setup */
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 	if (spec->quirk == QUIRK_R3DI) {
+ 		chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 		tmp = FLOAT_ONE;
+ 	} else
+ 		tmp = FLOAT_THREE;
+ 	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 	/* Mic 2 setup (not present on desktop cards) */
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN2, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT2, SR_96_000);
+ 	if (spec->quirk == QUIRK_R3DI)
+ 		chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x80, 0x01, tmp);
+ }
+ 
+ /*
+  * Sets the source of stream 0x14 to connpointID 0x48, and the destination
+  * connpointID to 0x91. If this isn't done, the destination is 0x71, and
+  * you get no sound. I'm guessing this has to do with the Sound Blaster Z
+  * having an updated DAC, which changes the destination to that DAC.
+  */
+ static void sbz_connect_streams(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 
+ 	codec_dbg(codec, "Connect Streams entered, mutex locked and loaded.\n");
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 
+ 	/* This value is 0x43 for 96khz, and 0x83 for 192khz. */
+ 	chipio_write_no_mutex(codec, 0x18a020, 0x00000043);
+ 
+ 	/* Setup stream 0x14 with it's source and destination points */
+ 	chipio_set_stream_source_dest(codec, 0x14, 0x48, 0x91);
+ 	chipio_set_conn_rate_no_mutex(codec, 0x48, SR_96_000);
+ 	chipio_set_conn_rate_no_mutex(codec, 0x91, SR_96_000);
+ 	chipio_set_stream_channels(codec, 0x14, 2);
+ 	chipio_set_stream_control(codec, 0x14, 1);
+ 
+ 	codec_dbg(codec, "Connect Streams exited, mutex released.\n");
+ 
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ /*
+  * Write data through ChipIO to setup proper stream destinations.
+  * Not sure how it exactly works, but it seems to direct data
+  * to different destinations. Example is f8 to c0, e0 to c0.
+  * All I know is, if you don't set these, you get no sound.
+  */
+ static void sbz_chipio_startup_data(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 	codec_dbg(codec, "Startup Data entered, mutex locked and loaded.\n");
+ 
+ 	/* These control audio output */
+ 	chipio_write_no_mutex(codec, 0x190060, 0x0001f8c0);
+ 	chipio_write_no_mutex(codec, 0x190064, 0x0001f9c1);
+ 	chipio_write_no_mutex(codec, 0x190068, 0x0001fac6);
+ 	chipio_write_no_mutex(codec, 0x19006c, 0x0001fbc7);
+ 	/* Signal to update I think */
+ 	chipio_write_no_mutex(codec, 0x19042c, 0x00000001);
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 	/* No clue what these control */
+ 	if (spec->quirk == QUIRK_SBZ) {
+ 		chipio_write_no_mutex(codec, 0x190030, 0x0001e0c0);
+ 		chipio_write_no_mutex(codec, 0x190034, 0x0001e1c1);
+ 		chipio_write_no_mutex(codec, 0x190038, 0x0001e4c2);
+ 		chipio_write_no_mutex(codec, 0x19003c, 0x0001e5c3);
+ 		chipio_write_no_mutex(codec, 0x190040, 0x0001e2c4);
+ 		chipio_write_no_mutex(codec, 0x190044, 0x0001e3c5);
+ 		chipio_write_no_mutex(codec, 0x190048, 0x0001e8c6);
+ 		chipio_write_no_mutex(codec, 0x19004c, 0x0001e9c7);
+ 		chipio_write_no_mutex(codec, 0x190050, 0x0001ecc8);
+ 		chipio_write_no_mutex(codec, 0x190054, 0x0001edc9);
+ 		chipio_write_no_mutex(codec, 0x190058, 0x0001eaca);
+ 		chipio_write_no_mutex(codec, 0x19005c, 0x0001ebcb);
+ 	} else if (spec->quirk == QUIRK_ZXR) {
+ 		chipio_write_no_mutex(codec, 0x190038, 0x000140c2);
+ 		chipio_write_no_mutex(codec, 0x19003c, 0x000141c3);
+ 		chipio_write_no_mutex(codec, 0x190040, 0x000150c4);
+ 		chipio_write_no_mutex(codec, 0x190044, 0x000151c5);
+ 		chipio_write_no_mutex(codec, 0x190050, 0x000142c8);
+ 		chipio_write_no_mutex(codec, 0x190054, 0x000143c9);
+ 		chipio_write_no_mutex(codec, 0x190058, 0x000152ca);
+ 		chipio_write_no_mutex(codec, 0x19005c, 0x000153cb);
+ 	}
+ 	chipio_write_no_mutex(codec, 0x19042c, 0x00000001);
+ 
+ 	codec_dbg(codec, "Startup Data exited, mutex released.\n");
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ /*
+  * Custom DSP SCP commands where the src value is 0x00 instead of 0x20. This is
+  * done after the DSP is loaded.
+  */
+ static void ca0132_alt_dsp_scp_startup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 	case QUIRK_AE5:
+ 		tmp = 0x00000003;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		tmp = 0x00000000;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0A, tmp);
+ 		tmp = 0x00000001;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0B, tmp);
+ 		tmp = 0x00000004;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		tmp = 0x00000005;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		tmp = 0x00000000;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		break;
+ 	case QUIRK_R3D:
+ 	case QUIRK_R3DI:
+ 		tmp = 0x00000000;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0A, tmp);
+ 		tmp = 0x00000001;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0B, tmp);
+ 		tmp = 0x00000004;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		tmp = 0x00000005;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		tmp = 0x00000000;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		break;
+ 	}
+ }
+ 
+ static void ca0132_alt_dsp_initial_mic_setup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	chipio_set_stream_control(codec, 0x03, 0);
+ 	chipio_set_stream_control(codec, 0x04, 0);
+ 
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 
+ 	tmp = FLOAT_THREE;
+ 	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 	chipio_set_stream_control(codec, 0x03, 1);
+ 	chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 		chipio_write(codec, 0x18b098, 0x0000000c);
+ 		chipio_write(codec, 0x18b09C, 0x0000000c);
+ 		break;
+ 	case QUIRK_AE5:
+ 		chipio_write(codec, 0x18b098, 0x0000000c);
+ 		chipio_write(codec, 0x18b09c, 0x0000004c);
+ 		break;
+ 	}
+ }
+ 
+ static void ae5_post_dsp_register_set(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	chipio_8051_write_direct(codec, 0x93, 0x10);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x44);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc2);
+ 
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 
+ 	ca0113_mmio_command_set(codec, 0x30, 0x2b, 0x3f);
+ 	ca0113_mmio_command_set(codec, 0x30, 0x2d, 0x3f);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);
+ }
+ 
+ static void ae5_post_dsp_param_setup(struct hda_codec *codec)
+ {
+ 	/*
+ 	 * Param3 in the 8051's memory is represented by the ascii string 'mch'
+ 	 * which seems to be 'multichannel'. This is also mentioned in the
+ 	 * AE-5's registry values in Windows.
+ 	 */
+ 	chipio_set_control_param(codec, 3, 0);
+ 	/*
+ 	 * I believe ASI is 'audio serial interface' and that it's used to
+ 	 * change colors on the external LED strip connected to the AE-5.
+ 	 */
+ 	chipio_set_control_flag(codec, CONTROL_FLAG_ASI_96KHZ, 1);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x724, 0x83);
+ 	chipio_set_control_param(codec, CONTROL_PARAM_ASI, 0);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x92);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_HIGH, 0xfa);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_DATA_WRITE, 0x22);
+ }
+ 
+ static void ae5_post_dsp_pll_setup(struct hda_codec *codec)
+ {
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x41);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc8);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x45);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xcc);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x40);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xcb);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x43);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc7);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x51);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0x8d);
+ }
+ 
+ static void ae5_post_dsp_stream_setup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x725, 0x81);
+ 
+ 	chipio_set_conn_rate_no_mutex(codec, 0x70, SR_96_000);
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 
+ 	chipio_set_stream_source_dest(codec, 0x5, 0x43, 0x0);
+ 
+ 	chipio_set_stream_source_dest(codec, 0x18, 0x9, 0xd0);
+ 	chipio_set_conn_rate_no_mutex(codec, 0xd0, SR_96_000);
+ 	chipio_set_stream_channels(codec, 0x18, 6);
+ 	chipio_set_stream_control(codec, 0x18, 1);
+ 
+ 	chipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 4);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x43);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc7);
+ 
+ 	ca0113_mmio_command_set(codec, 0x48, 0x01, 0x80);
+ 
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ static void ae5_post_dsp_startup_data(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 
+ 	chipio_write_no_mutex(codec, 0x189000, 0x0001f101);
+ 	chipio_write_no_mutex(codec, 0x189004, 0x0001f101);
+ 	chipio_write_no_mutex(codec, 0x189024, 0x00014004);
+ 	chipio_write_no_mutex(codec, 0x189028, 0x0002000f);
+ 
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0a, 0x05);
+ 	chipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 7);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0b, 0x12);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x04, 0x00);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x06, 0x48);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0a, 0x05);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0f, 0x00);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x10, 0x00);
+ 	ca0113_mmio_gpio_set(codec, 0, true);
+ 	ca0113_mmio_gpio_set(codec, 1, true);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x80);
+ 
+ 	chipio_write_no_mutex(codec, 0x18b03c, 0x00000012);
+ 
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0f, 0x00);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x10, 0x00);
+ 
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ /*
++>>>>>>> c25c73e06a70 (ALSA: hda/ca0132 - Add ZxR DSP post-download commands)
   * Setup default parameters for DSP
   */
  static void ca0132_setup_defaults(struct hda_codec *codec)
@@@ -4799,18 -8144,45 +5147,40 @@@ static int ca0132_init(struct hda_code
  		spec->dsp_state = DSP_DOWNLOAD_INIT;
  	spec->curr_chip_addx = INVALID_CHIP_ADDRESS;
  
 -	if (spec->use_pci_mmio)
 -		ca0132_mmio_init(codec);
 -
  	snd_hda_power_up_pm(codec);
  
 -	if (spec->quirk == QUIRK_AE5)
 -		ae5_register_set(codec);
 -
  	ca0132_init_unsol(codec);
 +
  	ca0132_init_params(codec);
  	ca0132_init_flags(codec);
 -
  	snd_hda_sequence_write(codec, spec->base_init_verbs);
 -
 -	if (spec->use_alt_functions)
 -		ca0132_alt_init(codec);
 -
  	ca0132_download_dsp(codec);
 -
  	ca0132_refresh_widget_caps(codec);
++<<<<<<< HEAD
 +	ca0132_setup_defaults(codec);
 +	ca0132_init_analog_mic2(codec);
 +	ca0132_init_dmic(codec);
++=======
+ 
+ 	switch (spec->quirk) {
+ 	case QUIRK_R3DI:
+ 	case QUIRK_R3D:
+ 		r3d_setup_defaults(codec);
+ 		break;
+ 	case QUIRK_SBZ:
+ 	case QUIRK_ZXR:
+ 		sbz_setup_defaults(codec);
+ 		break;
+ 	case QUIRK_AE5:
+ 		ae5_setup_defaults(codec);
+ 		break;
+ 	default:
+ 		ca0132_setup_defaults(codec);
+ 		ca0132_init_analog_mic2(codec);
+ 		ca0132_init_dmic(codec);
+ 		break;
+ 	}
++>>>>>>> c25c73e06a70 (ALSA: hda/ca0132 - Add ZxR DSP post-download commands)
  
  	for (i = 0; i < spec->num_outputs; i++)
  		init_output(codec, spec->out_pins[i], spec->dacs[0]);
* Unmerged path sound/pci/hda/patch_ca0132.c
