HID: debug: fix the ring buffer implementation

jira LE-1907
cve CVE-2019-3819
cve CVE-2018-9516
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [hid] debug: fix the ring buffer implementation (Torez Smith) [1635834] {CVE-2018-9516 CVE-2019-3819}
Rebuild_FUZZ: 94.25%
commit-author Vladis Dronov <vdronov@redhat.com>
commit 13054abbaa4f1fd4e6f3b4b63439ec033b4c8035
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/13054abb.failed

Ring buffer implementation in hid_debug_event() and hid_debug_events_read()
is strange allowing lost or corrupted data. After commit 717adfdaf147
("HID: debug: check length before copy_to_user()") it is possible to enter
an infinite loop in hid_debug_events_read() by providing 0 as count, this
locks up a system. Fix this by rewriting the ring buffer implementation
with kfifo and simplify the code.

This fixes CVE-2019-3819.

v2: fix an execution logic and add a comment
v3: use __set_current_state() instead of set_current_state()

Link: https://bugzilla.redhat.com/show_bug.cgi?id=1669187
	Cc: stable@vger.kernel.org # v4.18+
Fixes: cd667ce24796 ("HID: use debugfs for events/reports dumping")
Fixes: 717adfdaf147 ("HID: debug: check length before copy_to_user()")
	Signed-off-by: Vladis Dronov <vdronov@redhat.com>
	Reviewed-by: Oleg Nesterov <oleg@redhat.com>
	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
(cherry picked from commit 13054abbaa4f1fd4e6f3b4b63439ec033b4c8035)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-debug.c
diff --cc drivers/hid/hid-debug.c
index 6efdbce49137,ac9fda1b5a72..000000000000
--- a/drivers/hid/hid-debug.c
+++ b/drivers/hid/hid-debug.c
@@@ -30,7 -30,8 +30,12 @@@
  
  #include <linux/debugfs.h>
  #include <linux/seq_file.h>
++<<<<<<< HEAD
 +#include <linux/sched.h>
++=======
+ #include <linux/kfifo.h>
+ #include <linux/sched/signal.h>
++>>>>>>> 13054abbaa4f (HID: debug: fix the ring buffer implementation)
  #include <linux/export.h>
  #include <linux/slab.h>
  #include <linux/uaccess.h>
@@@ -988,8 -1078,8 +987,13 @@@ static int hid_debug_events_open(struc
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	if (!(list->hid_debug_buf = kzalloc(sizeof(char) * HID_DEBUG_BUFSIZE, GFP_KERNEL))) {
 +		err = -ENOMEM;
++=======
+ 	err = kfifo_alloc(&list->hid_debug_fifo, HID_DEBUG_FIFOSIZE, GFP_KERNEL);
+ 	if (err) {
++>>>>>>> 13054abbaa4f (HID: debug: fix the ring buffer implementation)
  		kfree(list);
  		goto out;
  	}
@@@ -1013,72 -1103,53 +1017,76 @@@ static ssize_t hid_debug_events_read(st
  	DECLARE_WAITQUEUE(wait, current);
  
  	mutex_lock(&list->read_mutex);
- 	while (ret == 0) {
- 		if (list->head == list->tail) {
- 			add_wait_queue(&list->hdev->debug_wait, &wait);
- 			set_current_state(TASK_INTERRUPTIBLE);
+ 	if (kfifo_is_empty(&list->hid_debug_fifo)) {
+ 		add_wait_queue(&list->hdev->debug_wait, &wait);
+ 		set_current_state(TASK_INTERRUPTIBLE);
  
++<<<<<<< HEAD
 +			while (list->head == list->tail) {
 +				if (file->f_flags & O_NONBLOCK) {
 +					ret = -EAGAIN;
 +					break;
 +				}
 +				if (signal_pending(current)) {
 +					ret = -ERESTARTSYS;
 +					break;
 +				}
 +
 +				if (!list->hdev || !list->hdev->debug) {
 +					ret = -EIO;
 +					break;
 +				}
 +
 +				/* allow O_NONBLOCK from other threads */
 +				mutex_unlock(&list->read_mutex);
 +				schedule();
 +				mutex_lock(&list->read_mutex);
 +				set_current_state(TASK_INTERRUPTIBLE);
++=======
+ 		while (kfifo_is_empty(&list->hid_debug_fifo)) {
+ 			if (file->f_flags & O_NONBLOCK) {
+ 				ret = -EAGAIN;
+ 				break;
++>>>>>>> 13054abbaa4f (HID: debug: fix the ring buffer implementation)
  			}
  
- 			set_current_state(TASK_RUNNING);
- 			remove_wait_queue(&list->hdev->debug_wait, &wait);
- 		}
- 
- 		if (ret)
- 			goto out;
- 
- 		/* pass the ringbuffer contents to userspace */
- copy_rest:
- 		if (list->tail == list->head)
- 			goto out;
- 		if (list->tail > list->head) {
- 			len = list->tail - list->head;
- 			if (len > count)
- 				len = count;
- 
- 			if (copy_to_user(buffer + ret, &list->hid_debug_buf[list->head], len)) {
- 				ret = -EFAULT;
- 				goto out;
+ 			if (signal_pending(current)) {
+ 				ret = -ERESTARTSYS;
+ 				break;
  			}
- 			ret += len;
- 			list->head += len;
- 		} else {
- 			len = HID_DEBUG_BUFSIZE - list->head;
- 			if (len > count)
- 				len = count;
- 
- 			if (copy_to_user(buffer, &list->hid_debug_buf[list->head], len)) {
- 				ret = -EFAULT;
+ 
+ 			/* if list->hdev is NULL we cannot remove_wait_queue().
+ 			 * if list->hdev->debug is 0 then hid_debug_unregister()
+ 			 * was already called and list->hdev is being destroyed.
+ 			 * if we add remove_wait_queue() here we can hit a race.
+ 			 */
+ 			if (!list->hdev || !list->hdev->debug) {
+ 				ret = -EIO;
+ 				set_current_state(TASK_RUNNING);
  				goto out;
  			}
- 			list->head = 0;
- 			ret += len;
- 			count -= len;
- 			if (count > 0)
- 				goto copy_rest;
+ 
+ 			/* allow O_NONBLOCK from other threads */
+ 			mutex_unlock(&list->read_mutex);
+ 			schedule();
+ 			mutex_lock(&list->read_mutex);
+ 			set_current_state(TASK_INTERRUPTIBLE);
  		}
  
+ 		__set_current_state(TASK_RUNNING);
+ 		remove_wait_queue(&list->hdev->debug_wait, &wait);
+ 
+ 		if (ret)
+ 			goto out;
  	}
+ 
+ 	/* pass the fifo content to userspace, locking is not needed with only
+ 	 * one concurrent reader and one concurrent writer
+ 	 */
+ 	ret = kfifo_to_user(&list->hid_debug_fifo, buffer, count, &copied);
+ 	if (ret)
+ 		goto out;
+ 	ret = copied;
  out:
  	mutex_unlock(&list->read_mutex);
  	return ret;
@@@ -1089,10 -1160,10 +1097,15 @@@ static unsigned int hid_debug_events_po
  	struct hid_debug_list *list = file->private_data;
  
  	poll_wait(file, &list->hdev->debug_wait, wait);
++<<<<<<< HEAD
 +	if (list->head != list->tail)
 +		return POLLIN | POLLRDNORM;
++=======
+ 	if (!kfifo_is_empty(&list->hid_debug_fifo))
+ 		return EPOLLIN | EPOLLRDNORM;
++>>>>>>> 13054abbaa4f (HID: debug: fix the ring buffer implementation)
  	if (!list->hdev->debug)
 -		return EPOLLERR | EPOLLHUP;
 +		return POLLERR | POLLHUP;
  	return 0;
  }
  
* Unmerged path drivers/hid/hid-debug.c
diff --git a/include/linux/hid-debug.h b/include/linux/hid-debug.h
index 8663f216c563..2d6100edf204 100644
--- a/include/linux/hid-debug.h
+++ b/include/linux/hid-debug.h
@@ -24,7 +24,10 @@
 
 #ifdef CONFIG_DEBUG_FS
 
+#include <linux/kfifo.h>
+
 #define HID_DEBUG_BUFSIZE 512
+#define HID_DEBUG_FIFOSIZE 512
 
 void hid_dump_input(struct hid_device *, struct hid_usage *, __s32);
 void hid_dump_report(struct hid_device *, int , u8 *, int);
@@ -37,11 +40,8 @@ void hid_debug_init(void);
 void hid_debug_exit(void);
 void hid_debug_event(struct hid_device *, char *);
 
-
 struct hid_debug_list {
-	char *hid_debug_buf;
-	int head;
-	int tail;
+	DECLARE_KFIFO_PTR(hid_debug_fifo, char);
 	struct fasync_struct *fasync;
 	struct hid_device *hdev;
 	struct list_head node;
@@ -64,4 +64,3 @@ struct hid_debug_list {
 #endif
 
 #endif
-
