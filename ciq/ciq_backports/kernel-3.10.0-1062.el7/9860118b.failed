net: phy: move phy MMD accessors to phy-core.c

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] phy: move phy MMD accessors to phy-core.c (Ivan Vecera) [1655590]
Rebuild_FUZZ: 94.25%
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit 9860118b58241169f67ba77dfeb935fcf53ce4cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9860118b.failed

Move the phy_(read|write)__mmd() helpers out of line, they will become
our main MMD accessor functions, and so will be a little more complex.
This complexity doesn't belong in an inline function.  Also move the
_indirect variants as well to keep like functionality together.

	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9860118b58241169f67ba77dfeb935fcf53ce4cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/Makefile
#	drivers/net/phy/phy.c
#	include/linux/phy.h
diff --cc drivers/net/phy/Makefile
index a2bb4785c03f,82d915614646..000000000000
--- a/drivers/net/phy/Makefile
+++ b/drivers/net/phy/Makefile
@@@ -1,32 -1,58 +1,39 @@@
 -# Makefile for Linux PHY drivers and MDIO bus drivers
 +# Makefile for Linux PHY drivers
  
++<<<<<<< HEAD
 +libphy-objs			:= phy.o phy_device.o mdio_bus.o
++=======
+ libphy-y			:= phy.o phy_device.o mdio_bus.o mdio_device.o \
+ 				   mdio-boardinfo.o phy-core.o
+ libphy-$(CONFIG_SWPHY)		+= swphy.o
+ libphy-$(CONFIG_LED_TRIGGER_PHY)	+= phy_led_triggers.o
++>>>>>>> 9860118b5824 (net: phy: move phy MMD accessors to phy-core.c)
  
  obj-$(CONFIG_PHYLIB)		+= libphy.o
 -
 -obj-$(CONFIG_MDIO_BCM_IPROC)	+= mdio-bcm-iproc.o
 -obj-$(CONFIG_MDIO_BCM_UNIMAC)	+= mdio-bcm-unimac.o
 -obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
 -obj-$(CONFIG_MDIO_BUS_MUX)	+= mdio-mux.o
 -obj-$(CONFIG_MDIO_BUS_MUX_BCM_IPROC)	+= mdio-mux-bcm-iproc.o
 -obj-$(CONFIG_MDIO_BUS_MUX_GPIO)	+= mdio-mux-gpio.o
 -obj-$(CONFIG_MDIO_BUS_MUX_MMIOREG) += mdio-mux-mmioreg.o
 -obj-$(CONFIG_MDIO_CAVIUM)	+= mdio-cavium.o
 -obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
 -obj-$(CONFIG_MDIO_HISI_FEMAC)	+= mdio-hisi-femac.o
 -obj-$(CONFIG_MDIO_MOXART)	+= mdio-moxart.o
 -obj-$(CONFIG_MDIO_OCTEON)	+= mdio-octeon.o
 -obj-$(CONFIG_MDIO_SUN4I)	+= mdio-sun4i.o
 -obj-$(CONFIG_MDIO_THUNDER)	+= mdio-thunder.o
 -obj-$(CONFIG_MDIO_XGENE)	+= mdio-xgene.o
 -
 -obj-$(CONFIG_AMD_PHY)		+= amd.o
 -obj-$(CONFIG_AQUANTIA_PHY)	+= aquantia.o
 -obj-$(CONFIG_AT803X_PHY)	+= at803x.o
 +obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
 +obj-$(CONFIG_DAVICOM_PHY)	+= davicom.o
 +obj-$(CONFIG_CICADA_PHY)	+= cicada.o
 +obj-$(CONFIG_LXT_PHY)		+= lxt.o
 +obj-$(CONFIG_QSEMI_PHY)		+= qsemi.o
 +obj-$(CONFIG_SMSC_PHY)		+= smsc.o
 +obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 +obj-$(CONFIG_BROADCOM_PHY)	+= broadcom.o
  obj-$(CONFIG_BCM63XX_PHY)	+= bcm63xx.o
 -obj-$(CONFIG_BCM7XXX_PHY)	+= bcm7xxx.o
  obj-$(CONFIG_BCM87XX_PHY)	+= bcm87xx.o
 -obj-$(CONFIG_BCM_CYGNUS_PHY)	+= bcm-cygnus.o
 -obj-$(CONFIG_BCM_NET_PHYLIB)	+= bcm-phy-lib.o
 -obj-$(CONFIG_BROADCOM_PHY)	+= broadcom.o
 -obj-$(CONFIG_CICADA_PHY)	+= cicada.o
 -obj-$(CONFIG_DAVICOM_PHY)	+= davicom.o
 -obj-$(CONFIG_DP83640_PHY)	+= dp83640.o
 -obj-$(CONFIG_DP83848_PHY)	+= dp83848.o
 -obj-$(CONFIG_DP83867_PHY)	+= dp83867.o
 -obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
  obj-$(CONFIG_ICPLUS_PHY)	+= icplus.o
 -obj-$(CONFIG_INTEL_XWAY_PHY)	+= intel-xway.o
 +obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
  obj-$(CONFIG_LSI_ET1011C_PHY)	+= et1011c.o
 -obj-$(CONFIG_LXT_PHY)		+= lxt.o
 -obj-$(CONFIG_MARVELL_PHY)	+= marvell.o
 -obj-$(CONFIG_MESON_GXL_PHY)	+= meson-gxl.o
 -obj-$(CONFIG_MICREL_KS8995MA)	+= spi_ks8995.o
 -obj-$(CONFIG_MICREL_PHY)	+= micrel.o
 -obj-$(CONFIG_MICROCHIP_PHY)	+= microchip.o
 -obj-$(CONFIG_MICROSEMI_PHY)	+= mscc.o
 +obj-$(CONFIG_FIXED_PHY)		+= fixed_phy.o
 +obj-$(CONFIG_MDIO_BITBANG)	+= mdio-bitbang.o
 +obj-$(CONFIG_MDIO_GPIO)		+= mdio-gpio.o
  obj-$(CONFIG_NATIONAL_PHY)	+= national.o
 -obj-$(CONFIG_QSEMI_PHY)		+= qsemi.o
 -obj-$(CONFIG_REALTEK_PHY)	+= realtek.o
 -obj-$(CONFIG_SMSC_PHY)		+= smsc.o
 +obj-$(CONFIG_DP83640_PHY)	+= dp83640.o
  obj-$(CONFIG_STE10XP)		+= ste10Xp.o
 -obj-$(CONFIG_TERANETICS_PHY)	+= teranetics.o
 -obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 -obj-$(CONFIG_XILINX_GMII2RGMII) += xilinx_gmii2rgmii.o
 +obj-$(CONFIG_MICREL_PHY)	+= micrel.o
 +obj-$(CONFIG_MDIO_OCTEON)	+= mdio-octeon.o
 +obj-$(CONFIG_MICREL_KS8995MA)	+= spi_ks8995.o
 +obj-$(CONFIG_AT803X_PHY)	+= at803x.o
 +obj-$(CONFIG_AMD_PHY)		+= amd.o
 +obj-$(CONFIG_MDIO_BUS_MUX)	+= mdio-mux.o
 +obj-$(CONFIG_MDIO_BUS_MUX_GPIO)	+= mdio-mux-gpio.o
 +obj-$(CONFIG_MDIO_BUS_MUX_MMIOREG) += mdio-mux-mmioreg.o
diff --cc drivers/net/phy/phy.c
index f64de02dbd2e,ffc28c42e2d1..000000000000
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@@ -992,68 -1192,6 +992,71 @@@ void phy_mac_interrupt(struct phy_devic
  }
  EXPORT_SYMBOL(phy_mac_interrupt);
  
++<<<<<<< HEAD
 +static inline void mmd_phy_indirect(struct mii_bus *bus, int prtad, int devad,
 +				    int addr)
 +{
 +	/* Write the desired MMD Devad */
 +	bus->write(bus, addr, MII_MMD_CTRL, devad);
 +
 +	/* Write the desired MMD register address */
 +	bus->write(bus, addr, MII_MMD_DATA, prtad);
 +
 +	/* Select the Function : DATA with no post increment */
 +	bus->write(bus, addr, MII_MMD_CTRL, (devad | MII_MMD_CTRL_NOINCR));
 +}
 +
 +/**
 + * phy_read_mmd_indirect - reads data from the MMD registers
 + * @bus: the target MII bus
 + * @prtad: MMD Address
 + * @devad: MMD DEVAD
 + * @addr: PHY address on the MII bus
 + *
 + * Description: it reads data from the MMD registers (clause 22 to access to
 + * clause 45) of the specified phy address.
 + * To read these register we have:
 + * 1) Write reg 13 // DEVAD
 + * 2) Write reg 14 // MMD Address
 + * 3) Write reg 13 // MMD Data Command for MMD DEVAD
 + * 3) Read  reg 14 // Read MMD data
 + */
 +static int phy_read_mmd_indirect(struct mii_bus *bus, int prtad, int devad,
 +				 int addr)
 +{
 +	mmd_phy_indirect(bus, prtad, devad, addr);
 +
 +	/* Read the content of the MMD's selected register */
 +	return bus->read(bus, addr, MII_MMD_DATA);
 +}
 +
 +/**
 + * phy_write_mmd_indirect - writes data to the MMD registers
 + * @bus: the target MII bus
 + * @prtad: MMD Address
 + * @devad: MMD DEVAD
 + * @addr: PHY address on the MII bus
 + * @data: data to write in the MMD register
 + *
 + * Description: Write data from the MMD registers of the specified
 + * phy address.
 + * To write these register we have:
 + * 1) Write reg 13 // DEVAD
 + * 2) Write reg 14 // MMD Address
 + * 3) Write reg 13 // MMD Data Command for MMD DEVAD
 + * 3) Write reg 14 // Write MMD data
 + */
 +static void phy_write_mmd_indirect(struct mii_bus *bus, int prtad, int devad,
 +				   int addr, u32 data)
 +{
 +	mmd_phy_indirect(bus, prtad, devad, addr);
 +
 +	/* Write the data into MMD's selected register */
 +	bus->write(bus, addr, MII_MMD_DATA, data);
 +}
 +
++=======
++>>>>>>> 9860118b5824 (net: phy: move phy MMD accessors to phy-core.c)
  /**
   * phy_init_eee - init and check the EEE feature
   * @phydev: target phy_device struct
diff --cc include/linux/phy.h
index 9542c61131f8,bcb4549b41d6..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -555,14 -651,18 +555,18 @@@ struct phy_fixup 
   *
   * Same rules as for phy_read();
   */
 -int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);
++<<<<<<< HEAD
 +static inline int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum)
 +{
 +	if (!phydev->is_c45)
 +		return -EOPNOTSUPP;
  
 -/**
 - * phy_read_mmd_indirect - reads data from the MMD registers
 - * @phydev: The PHY device bus
 - * @prtad: MMD Address
 - * @addr: PHY address on the MII bus
 - *
 - * Description: it reads data from the MMD registers (clause 22 to access to
 - * clause 45) of the specified phy address.
 - */
 -int phy_read_mmd_indirect(struct phy_device *phydev, int prtad, int devad);
 +	return mdiobus_read(phydev->bus, phydev->addr,
 +			    MII_ADDR_C45 | (devad << 16) | (regnum & 0xffff));
 +}
++=======
++int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);
++>>>>>>> 9860118b5824 (net: phy: move phy MMD accessors to phy-core.c)
  
  /**
   * phy_read - Convenience function for reading a given PHY register
@@@ -624,16 -745,20 +628,20 @@@ static inline bool phy_is_internal(stru
   *
   * Same rules as for phy_write();
   */
 -int phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
++<<<<<<< HEAD
 +static inline int phy_write_mmd(struct phy_device *phydev, int devad,
 +				u32 regnum, u16 val)
 +{
 +	if (!phydev->is_c45)
 +		return -EOPNOTSUPP;
  
 -/**
 - * phy_write_mmd_indirect - writes data to the MMD registers
 - * @phydev: The PHY device
 - * @prtad: MMD Address
 - * @devad: MMD DEVAD
 - * @data: data to write in the MMD register
 - *
 - * Description: Write data from the MMD registers of the specified
 - * phy address.
 - */
 -void phy_write_mmd_indirect(struct phy_device *phydev, int prtad,
 -			    int devad, u32 data);
 +	regnum = MII_ADDR_C45 | ((devad & 0x1f) << 16) | (regnum & 0xffff);
 +
 +	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
 +}
++=======
++int phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
++>>>>>>> 9860118b5824 (net: phy: move phy MMD accessors to phy-core.c)
  
  struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
  				     bool is_c45,
* Unmerged path drivers/net/phy/Makefile
diff --git a/drivers/net/phy/phy-core.c b/drivers/net/phy/phy-core.c
new file mode 100644
index 000000000000..b8d8276a3099
--- /dev/null
+++ b/drivers/net/phy/phy-core.c
@@ -0,0 +1,135 @@
+/*
+ * Core PHY library, taken from phy.c
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/export.h>
+#include <linux/phy.h>
+
+static inline void mmd_phy_indirect(struct mii_bus *bus, int prtad, int devad,
+				    int addr)
+{
+	/* Write the desired MMD Devad */
+	bus->write(bus, addr, MII_MMD_CTRL, devad);
+
+	/* Write the desired MMD register address */
+	bus->write(bus, addr, MII_MMD_DATA, prtad);
+
+	/* Select the Function : DATA with no post increment */
+	bus->write(bus, addr, MII_MMD_CTRL, (devad | MII_MMD_CTRL_NOINCR));
+}
+
+/**
+ * phy_read_mmd_indirect - reads data from the MMD registers
+ * @phydev: The PHY device bus
+ * @prtad: MMD Address
+ * @devad: MMD DEVAD
+ *
+ * Description: it reads data from the MMD registers (clause 22 to access to
+ * clause 45) of the specified phy address.
+ * To read these register we have:
+ * 1) Write reg 13 // DEVAD
+ * 2) Write reg 14 // MMD Address
+ * 3) Write reg 13 // MMD Data Command for MMD DEVAD
+ * 3) Read  reg 14 // Read MMD data
+ */
+int phy_read_mmd_indirect(struct phy_device *phydev, int prtad, int devad)
+{
+	struct phy_driver *phydrv = phydev->drv;
+	int addr = phydev->mdio.addr;
+	int value = -1;
+
+	if (!phydrv->read_mmd_indirect) {
+		struct mii_bus *bus = phydev->mdio.bus;
+
+		mutex_lock(&bus->mdio_lock);
+		mmd_phy_indirect(bus, prtad, devad, addr);
+
+		/* Read the content of the MMD's selected register */
+		value = bus->read(bus, addr, MII_MMD_DATA);
+		mutex_unlock(&bus->mdio_lock);
+	} else {
+		value = phydrv->read_mmd_indirect(phydev, prtad, devad, addr);
+	}
+	return value;
+}
+EXPORT_SYMBOL(phy_read_mmd_indirect);
+
+/**
+ * phy_read_mmd - Convenience function for reading a register
+ * from an MMD on a given PHY.
+ * @phydev: The phy_device struct
+ * @devad: The MMD to read from
+ * @regnum: The register on the MMD to read
+ *
+ * Same rules as for phy_read();
+ */
+int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum)
+{
+	if (!phydev->is_c45)
+		return -EOPNOTSUPP;
+
+	return mdiobus_read(phydev->mdio.bus, phydev->mdio.addr,
+			    MII_ADDR_C45 | (devad << 16) | (regnum & 0xffff));
+}
+EXPORT_SYMBOL(phy_read_mmd);
+
+/**
+ * phy_write_mmd_indirect - writes data to the MMD registers
+ * @phydev: The PHY device
+ * @prtad: MMD Address
+ * @devad: MMD DEVAD
+ * @data: data to write in the MMD register
+ *
+ * Description: Write data from the MMD registers of the specified
+ * phy address.
+ * To write these register we have:
+ * 1) Write reg 13 // DEVAD
+ * 2) Write reg 14 // MMD Address
+ * 3) Write reg 13 // MMD Data Command for MMD DEVAD
+ * 3) Write reg 14 // Write MMD data
+ */
+void phy_write_mmd_indirect(struct phy_device *phydev, int prtad,
+				   int devad, u32 data)
+{
+	struct phy_driver *phydrv = phydev->drv;
+	int addr = phydev->mdio.addr;
+
+	if (!phydrv->write_mmd_indirect) {
+		struct mii_bus *bus = phydev->mdio.bus;
+
+		mutex_lock(&bus->mdio_lock);
+		mmd_phy_indirect(bus, prtad, devad, addr);
+
+		/* Write the data into MMD's selected register */
+		bus->write(bus, addr, MII_MMD_DATA, data);
+		mutex_unlock(&bus->mdio_lock);
+	} else {
+		phydrv->write_mmd_indirect(phydev, prtad, devad, addr, data);
+	}
+}
+EXPORT_SYMBOL(phy_write_mmd_indirect);
+
+/**
+ * phy_write_mmd - Convenience function for writing a register
+ * on an MMD on a given PHY.
+ * @phydev: The phy_device struct
+ * @devad: The MMD to read from
+ * @regnum: The register on the MMD to read
+ * @val: value to write to @regnum
+ *
+ * Same rules as for phy_write();
+ */
+int phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val)
+{
+	if (!phydev->is_c45)
+		return -EOPNOTSUPP;
+
+	regnum = MII_ADDR_C45 | ((devad & 0x1f) << 16) | (regnum & 0xffff);
+
+	return mdiobus_write(phydev->mdio.bus, phydev->mdio.addr, regnum, val);
+}
+EXPORT_SYMBOL(phy_write_mmd);
* Unmerged path drivers/net/phy/phy.c
* Unmerged path include/linux/phy.h
