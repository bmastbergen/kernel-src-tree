net: phy: make phy_(read|write)_mmd() generic MMD accessors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] phy: make phy_(read|write)_mmd() generic MMD accessors (Ivan Vecera) [1655590]
Rebuild_FUZZ: 95.58%
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit 1ee6b9bc6206cd0837bc16e46f580e40fe663384
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/1ee6b9bc.failed

Make phy_(read|write)_mmd() generic 802.3 clause 45 register accessors
for both Clause 22 and Clause 45 PHYs, using either the direct register
reading for Clause 45, or the indirect method for Clause 22 PHYs.
Allow this behaviour to be overriden by PHY drivers where necessary.

	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1ee6b9bc6206cd0837bc16e46f580e40fe663384)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phy-core.c
#	include/linux/phy.h
diff --cc include/linux/phy.h
index 9542c61131f8,b8feeffeb64c..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -523,16 -578,81 +523,84 @@@ struct phy_driver 
  	/* See set_wol, but for checking whether Wake on LAN is enabled. */
  	void (*get_wol)(struct phy_device *dev, struct ethtool_wolinfo *wol);
  
 -	/*
 -	 * Called to inform a PHY device driver when the core is about to
 -	 * change the link state. This callback is supposed to be used as
 -	 * fixup hook for drivers that need to take action when the link
 -	 * state changes. Drivers are by no means allowed to mess with the
 -	 * PHY device structure in their implementations.
 +	struct device_driver driver;
 +
 +	/* Determines the auto negotiation result */
 +	RH_KABI_EXTEND(int (*aneg_done)(struct phy_device *phydev))
 +
 +	/* PHY API is not on symbol whitelist now so we can extend
 +	 * this structure directly via simple RH_KABI_EXTEND.
  	 */
++<<<<<<< HEAD
++=======
+ 	void (*link_change_notify)(struct phy_device *dev);
+ 
+ 	/*
+ 	 * Phy specific driver override for reading a MMD register.
+ 	 * This function is optional for PHY specific drivers.  When
+ 	 * not provided, the default MMD read function will be used
+ 	 * by phy_read_mmd(), which will use either a direct read for
+ 	 * Clause 45 PHYs or an indirect read for Clause 22 PHYs.
+ 	 *  devnum is the MMD device number within the PHY device,
+ 	 *  regnum is the register within the selected MMD device.
+ 	 */
+ 	int (*read_mmd)(struct phy_device *dev, int devnum, u16 regnum);
+ 
+ 	/*
+ 	 * Phy specific driver override for writing a MMD register.
+ 	 * This function is optional for PHY specific drivers.  When
+ 	 * not provided, the default MMD write function will be used
+ 	 * by phy_write_mmd(), which will use either a direct write for
+ 	 * Clause 45 PHYs, or an indirect write for Clause 22 PHYs.
+ 	 *  devnum is the MMD device number within the PHY device,
+ 	 *  regnum is the register within the selected MMD device.
+ 	 *  val is the value to be written.
+ 	 */
+ 	int (*write_mmd)(struct phy_device *dev, int devnum, u16 regnum,
+ 			 u16 val);
+ 
+ 	/* A function provided by a phy specific driver to override the
+ 	 * the PHY driver framework support for reading a MMD register
+ 	 * from the PHY. If not supported, return -1. This function is
+ 	 * optional for PHY specific drivers, if not provided then the
+ 	 * default MMD read function is used by the PHY framework.
+ 	 */
+ 	int (*read_mmd_indirect)(struct phy_device *dev, int ptrad,
+ 				 int devnum, int regnum);
+ 
+ 	/* A function provided by a phy specific driver to override the
+ 	 * the PHY driver framework support for writing a MMD register
+ 	 * from the PHY. This function is optional for PHY specific drivers,
+ 	 * if not provided then the default MMD read function is used by
+ 	 * the PHY framework.
+ 	 */
+ 	void (*write_mmd_indirect)(struct phy_device *dev, int ptrad,
+ 				   int devnum, int regnum, u32 val);
+ 
+ 	/* Get the size and type of the eeprom contained within a plug-in
+ 	 * module */
+ 	int (*module_info)(struct phy_device *dev,
+ 			   struct ethtool_modinfo *modinfo);
+ 
+ 	/* Get the eeprom information from the plug-in module */
+ 	int (*module_eeprom)(struct phy_device *dev,
+ 			     struct ethtool_eeprom *ee, u8 *data);
+ 
+ 	/* Get statistics from the phy using ethtool */
+ 	int (*get_sset_count)(struct phy_device *dev);
+ 	void (*get_strings)(struct phy_device *dev, u8 *data);
+ 	void (*get_stats)(struct phy_device *dev,
+ 			  struct ethtool_stats *stats, u64 *data);
+ 
+ 	/* Get and Set PHY tunables */
+ 	int (*get_tunable)(struct phy_device *dev,
+ 			   struct ethtool_tunable *tuna, void *data);
+ 	int (*set_tunable)(struct phy_device *dev,
+ 			    struct ethtool_tunable *tuna,
+ 			    const void *data);
++>>>>>>> 1ee6b9bc6206 (net: phy: make phy_(read|write)_mmd() generic MMD accessors)
  };
 -#define to_phy_driver(d) container_of(to_mdio_common_driver(d),		\
 -				      struct phy_driver, mdiodrv)
 +#define to_phy_driver(d) container_of(d, struct phy_driver, driver)
  
  #define PHY_ANY_ID "MATCH ANY PHY"
  #define PHY_ANY_UID 0xffffffff
* Unmerged path drivers/net/phy/phy-core.c
* Unmerged path drivers/net/phy/phy-core.c
* Unmerged path include/linux/phy.h
