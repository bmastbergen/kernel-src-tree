bpf: centre subprog information fields

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jiong Wang <jiong.wang@netronome.com>
commit 9c8105bd4402236b1bb0f8f10709c5cec1440a0c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9c8105bd.failed

It is better to centre all subprog information fields into one structure.
This structure could later serve as function node in call graph.

	Signed-off-by: Jiong Wang <jiong.wang@netronome.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 9c8105bd4402236b1bb0f8f10709c5cec1440a0c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf_verifier.h
#	kernel/bpf/verifier.c
diff --cc include/linux/bpf_verifier.h
index 30a64bcc7a7d,8f70dc181e23..000000000000
--- a/include/linux/bpf_verifier.h
+++ b/include/linux/bpf_verifier.h
@@@ -195,9 -196,7 +200,13 @@@ struct bpf_verifier_env 
  	bool seen_direct_write;
  	struct bpf_insn_aux_data *insn_aux_data; /* array of per-insn state */
  	struct bpf_verifier_log log;
++<<<<<<< HEAD
 +	u32 subprog_starts[BPF_MAX_SUBPROGS];
 +	/* computes the stack depth of each bpf function */
 +	u16 subprog_stack_depth[BPF_MAX_SUBPROGS + 1];
++=======
+ 	struct bpf_subprog_info subprog_info[BPF_MAX_SUBPROGS + 1];
++>>>>>>> 9c8105bd4402 (bpf: centre subprog information fields)
  	u32 subprog_cnt;
  };
  
diff --cc kernel/bpf/verifier.c
index 9f1b98f148a8,5b293b4abb70..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -816,10 -816,10 +818,14 @@@ static int check_subprogs(struct bpf_ve
  
  	/* now check that all jumps are within the same subprog */
  	subprog_start = 0;
 -	if (env->subprog_cnt == cur_subprog + 1)
 +	if (env->subprog_cnt == cur_subprog)
  		subprog_end = insn_cnt;
  	else
++<<<<<<< HEAD
 +		subprog_end = env->subprog_starts[cur_subprog++];
++=======
+ 		subprog_end = subprog[cur_subprog + 1].start;
++>>>>>>> 9c8105bd4402 (bpf: centre subprog information fields)
  	for (i = 0; i < insn_cnt; i++) {
  		u8 code = insn[i].code;
  
@@@ -843,11 -843,12 +849,15 @@@ next
  				verbose(env, "last insn is not an exit or jmp\n");
  				return -EINVAL;
  			}
 -			cur_subprog++;
  			subprog_start = subprog_end;
 -			if (env->subprog_cnt == cur_subprog + 1)
 +			if (env->subprog_cnt == cur_subprog)
  				subprog_end = insn_cnt;
  			else
++<<<<<<< HEAD
 +				subprog_end = env->subprog_starts[cur_subprog++];
++=======
+ 				subprog_end = subprog[cur_subprog + 1].start;
++>>>>>>> 9c8105bd4402 (bpf: centre subprog information fields)
  		}
  	}
  	return 0;
@@@ -1541,10 -1517,10 +1552,17 @@@ process_func
  		return -EACCES;
  	}
  continue_func:
++<<<<<<< HEAD
 +	if (env->subprog_cnt == subprog)
 +		subprog_end = insn_cnt;
 +	else
 +		subprog_end = env->subprog_starts[subprog];
++=======
+ 	if (env->subprog_cnt == idx + 1)
+ 		subprog_end = insn_cnt;
+ 	else
+ 		subprog_end = subprog[idx + 1].start;
++>>>>>>> 9c8105bd4402 (bpf: centre subprog information fields)
  	for (; i < subprog_end; i++) {
  		if (insn[i].code != (BPF_JMP | BPF_CALL))
  			continue;
@@@ -1594,8 -1569,7 +1612,12 @@@ static int get_callee_stack_depth(struc
  			  start);
  		return -EFAULT;
  	}
++<<<<<<< HEAD
 +	subprog++;
 +	return env->subprog_stack_depth[subprog];
++=======
+ 	return env->subprog_info[subprog].stack_depth;
++>>>>>>> 9c8105bd4402 (bpf: centre subprog information fields)
  }
  #endif
  
@@@ -4876,11 -4927,11 +4898,16 @@@ process_bpf_exit
  
  	verbose(env, "processed %d insns (limit %d), stack depth ",
  		insn_processed, BPF_COMPLEXITY_LIMIT_INSNS);
++<<<<<<< HEAD
 +	for (i = 0; i < env->subprog_cnt + 1; i++) {
 +		u32 depth = env->subprog_stack_depth[i];
++=======
+ 	for (i = 0; i < env->subprog_cnt; i++) {
+ 		u32 depth = env->subprog_info[i].stack_depth;
++>>>>>>> 9c8105bd4402 (bpf: centre subprog information fields)
  
  		verbose(env, "%d", depth);
 -		if (i + 1 < env->subprog_cnt)
 +		if (i + 1 < env->subprog_cnt + 1)
  			verbose(env, "+");
  	}
  	verbose(env, "\n");
@@@ -5307,12 -5337,12 +5334,16 @@@ static int jit_subprogs(struct bpf_veri
  	if (!func)
  		return -ENOMEM;
  
 -	for (i = 0; i < env->subprog_cnt; i++) {
 +	for (i = 0; i <= env->subprog_cnt; i++) {
  		subprog_start = subprog_end;
 -		if (env->subprog_cnt == i + 1)
 +		if (env->subprog_cnt == i)
  			subprog_end = prog->len;
  		else
++<<<<<<< HEAD
 +			subprog_end = env->subprog_starts[i];
++=======
+ 			subprog_end = env->subprog_info[i + 1].start;
++>>>>>>> 9c8105bd4402 (bpf: centre subprog information fields)
  
  		len = subprog_end - subprog_start;
  		func[i] = bpf_prog_alloc(bpf_prog_size(len), GFP_USER);
@@@ -5326,9 -5359,9 +5357,9 @@@
  		 * Long term would need debug info to populate names
  		 */
  		func[i]->aux->name[0] = 'F';
- 		func[i]->aux->stack_depth = env->subprog_stack_depth[i];
+ 		func[i]->aux->stack_depth = env->subprog_info[i].stack_depth;
  		func[i]->jit_requested = 1;
 -		func[i] = bpf_int_jit_compile(func[i]);
 +		func[i] = trace_bpf_int_jit_compile(func[i]);
  		if (!func[i]->jited) {
  			err = -ENOTSUPP;
  			goto out_free;
* Unmerged path include/linux/bpf_verifier.h
* Unmerged path kernel/bpf/verifier.c
