pinctrl: intel: Implement intel_gpio_get_direction callback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [pinctrl] intel: Implement intel_gpio_get_direction callback (Benjamin Tissoires) [1609926 1544041]
Rebuild_FUZZ: 91.74%
commit-author Javier Arteaga <javier@emutex.com>
commit 67e6d3e83c18188bdc1467663c49787f8d4fdc0d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/67e6d3e8.failed

Allows querying GPIO direction from the pad config register.
If the pad is not in GPIO mode, return an error.

	Signed-off-by: Javier Arteaga <javier@emutex.com>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 67e6d3e83c18188bdc1467663c49787f8d4fdc0d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/intel/pinctrl-intel.c
diff --cc drivers/pinctrl/intel/pinctrl-intel.c
index 849966e04702,1e24a6b8a64e..000000000000
--- a/drivers/pinctrl/intel/pinctrl-intel.c
+++ b/drivers/pinctrl/intel/pinctrl-intel.c
@@@ -779,24 -770,42 +779,42 @@@ static int intel_gpio_get(struct gpio_c
  static void intel_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
  {
  	struct intel_pinctrl *pctrl = gpiochip_get_data(chip);
 -	unsigned long flags;
  	void __iomem *reg;
 -	u32 padcfg0;
  
  	reg = intel_get_padcfg(pctrl, offset, PADCFG0);
 -	if (!reg)
 -		return;
 +	if (reg) {
 +		unsigned long flags;
 +		u32 padcfg0;
  
 -	raw_spin_lock_irqsave(&pctrl->lock, flags);
 -	padcfg0 = readl(reg);
 -	if (value)
 -		padcfg0 |= PADCFG0_GPIOTXSTATE;
 -	else
 -		padcfg0 &= ~PADCFG0_GPIOTXSTATE;
 -	writel(padcfg0, reg);
 -	raw_spin_unlock_irqrestore(&pctrl->lock, flags);
 +		raw_spin_lock_irqsave(&pctrl->lock, flags);
 +		padcfg0 = readl(reg);
 +		if (value)
 +			padcfg0 |= PADCFG0_GPIOTXSTATE;
 +		else
 +			padcfg0 &= ~PADCFG0_GPIOTXSTATE;
 +		writel(padcfg0, reg);
 +		raw_spin_unlock_irqrestore(&pctrl->lock, flags);
 +	}
  }
  
+ static int intel_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
+ {
+ 	struct intel_pinctrl *pctrl = gpiochip_get_data(chip);
+ 	void __iomem *reg;
+ 	u32 padcfg0;
+ 
+ 	reg = intel_get_padcfg(pctrl, offset, PADCFG0);
+ 	if (!reg)
+ 		return -EINVAL;
+ 
+ 	padcfg0 = readl(reg);
+ 
+ 	if (padcfg0 & PADCFG0_PMODE_MASK)
+ 		return -EINVAL;
+ 
+ 	return !!(padcfg0 & PADCFG0_GPIOTXDIS);
+ }
+ 
  static int intel_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
  {
  	return pinctrl_gpio_direction_input(chip->base + offset);
@@@ -811,8 -820,9 +829,14 @@@ static int intel_gpio_direction_output(
  
  static const struct gpio_chip intel_gpio_chip = {
  	.owner = THIS_MODULE,
++<<<<<<< HEAD
 +	.request = intel_gpio_request,
 +	.free = intel_gpio_free,
++=======
+ 	.request = gpiochip_generic_request,
+ 	.free = gpiochip_generic_free,
+ 	.get_direction = intel_gpio_get_direction,
++>>>>>>> 67e6d3e83c18 (pinctrl: intel: Implement intel_gpio_get_direction callback)
  	.direction_input = intel_gpio_direction_input,
  	.direction_output = intel_gpio_direction_output,
  	.get = intel_gpio_get,
* Unmerged path drivers/pinctrl/intel/pinctrl-intel.c
