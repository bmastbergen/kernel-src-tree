ALSA: hda/ca0132 - Add AE-5 specific controls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit 212de2e7414a8a719d7a1206ba940380d6fb6bc0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/212de2e7.failed

This patch adds controls for the AE-5's headphone gain setting, and the
DAC's interpolation filter setting.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 212de2e7414a8a719d7a1206ba940380d6fb6bc0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index 20ce308ff039,dbd17d8f9513..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -127,7 -146,15 +127,19 @@@ enum 
  	VOICEFX = IN_EFFECT_END_NID,
  	PLAY_ENHANCEMENT,
  	CRYSTAL_VOICE,
++<<<<<<< HEAD
 +	EFFECT_END_NID
++=======
+ 	EFFECT_END_NID,
+ 	OUTPUT_SOURCE_ENUM,
+ 	INPUT_SOURCE_ENUM,
+ 	XBASS_XOVER,
+ 	EQ_PRESET_ENUM,
+ 	SMART_VOLUME_ENUM,
+ 	MIC_BOOST_ENUM,
+ 	AE5_HEADPHONE_GAIN_ENUM,
+ 	AE5_SOUND_FILTER_ENUM
++>>>>>>> 212de2e7414a (ALSA: hda/ca0132 - Add AE-5 specific controls)
  #define EFFECTS_COUNT  (EFFECT_END_NID - EFFECT_START_NID)
  };
  
@@@ -477,6 -513,220 +489,223 @@@ static struct ct_voicefx_preset ca0132_
  	}
  };
  
++<<<<<<< HEAD
++=======
+ /* ca0132 EQ presets, taken from Windows Sound Blaster Z Driver */
+ 
+ #define EQ_PRESET_MAX_PARAM_COUNT 11
+ 
+ struct ct_eq {
+ 	char *name;
+ 	hda_nid_t nid;
+ 	int mid;
+ 	int reqs[EQ_PRESET_MAX_PARAM_COUNT]; /*effect module request*/
+ };
+ 
+ struct ct_eq_preset {
+ 	char *name; /*preset name*/
+ 	unsigned int vals[EQ_PRESET_MAX_PARAM_COUNT];
+ };
+ 
+ static const struct ct_eq ca0132_alt_eq_enum = {
+ 	.name = "FX: Equalizer Preset Switch",
+ 	.nid = EQ_PRESET_ENUM,
+ 	.mid = 0x96,
+ 	.reqs = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
+ };
+ 
+ 
+ static const struct ct_eq_preset ca0132_alt_eq_presets[] = {
+ 	{ .name = "Flat",
+ 	 .vals = { 0x00000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x00000000	     }
+ 	},
+ 	{ .name = "Acoustic",
+ 	 .vals = { 0x00000000, 0x00000000, 0x3F8CCCCD,
+ 		   0x40000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x00000000, 0x40000000,
+ 		   0x40000000, 0x40000000	     }
+ 	},
+ 	{ .name = "Classical",
+ 	 .vals = { 0x00000000, 0x00000000, 0x40C00000,
+ 		   0x40C00000, 0x40466666, 0x00000000,
+ 		   0x00000000, 0x00000000, 0x00000000,
+ 		   0x40466666, 0x40466666	     }
+ 	},
+ 	{ .name = "Country",
+ 	 .vals = { 0x00000000, 0xBF99999A, 0x00000000,
+ 		   0x3FA66666, 0x3FA66666, 0x3F8CCCCD,
+ 		   0x00000000, 0x00000000, 0x40000000,
+ 		   0x40466666, 0x40800000	     }
+ 	},
+ 	{ .name = "Dance",
+ 	 .vals = { 0x00000000, 0xBF99999A, 0x40000000,
+ 		   0x40466666, 0x40866666, 0xBF99999A,
+ 		   0xBF99999A, 0x00000000, 0x00000000,
+ 		   0x40800000, 0x40800000	     }
+ 	},
+ 	{ .name = "Jazz",
+ 	 .vals = { 0x00000000, 0x00000000, 0x00000000,
+ 		   0x3F8CCCCD, 0x40800000, 0x40800000,
+ 		   0x40800000, 0x00000000, 0x3F8CCCCD,
+ 		   0x40466666, 0x40466666	     }
+ 	},
+ 	{ .name = "New Age",
+ 	 .vals = { 0x00000000, 0x00000000, 0x40000000,
+ 		   0x40000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x3F8CCCCD, 0x40000000,
+ 		   0x40000000, 0x40000000	     }
+ 	},
+ 	{ .name = "Pop",
+ 	 .vals = { 0x00000000, 0xBFCCCCCD, 0x00000000,
+ 		   0x40000000, 0x40000000, 0x00000000,
+ 		   0xBF99999A, 0xBF99999A, 0x00000000,
+ 		   0x40466666, 0x40C00000	     }
+ 	},
+ 	{ .name = "Rock",
+ 	 .vals = { 0x00000000, 0xBF99999A, 0xBF99999A,
+ 		   0x3F8CCCCD, 0x40000000, 0xBF99999A,
+ 		   0xBF99999A, 0x00000000, 0x00000000,
+ 		   0x40800000, 0x40800000	     }
+ 	},
+ 	{ .name = "Vocal",
+ 	 .vals = { 0x00000000, 0xC0000000, 0xBF99999A,
+ 		   0xBF99999A, 0x00000000, 0x40466666,
+ 		   0x40800000, 0x40466666, 0x00000000,
+ 		   0x00000000, 0x3F8CCCCD	     }
+ 	}
+ };
+ 
+ /* DSP command sequences for ca0132_alt_select_out */
+ #define ALT_OUT_SET_MAX_COMMANDS 9 /* Max number of commands in sequence */
+ struct ca0132_alt_out_set {
+ 	char *name; /*preset name*/
+ 	unsigned char commands;
+ 	unsigned int mids[ALT_OUT_SET_MAX_COMMANDS];
+ 	unsigned int reqs[ALT_OUT_SET_MAX_COMMANDS];
+ 	unsigned int vals[ALT_OUT_SET_MAX_COMMANDS];
+ };
+ 
+ static const struct ca0132_alt_out_set alt_out_presets[] = {
+ 	{ .name = "Line Out",
+ 	  .commands = 7,
+ 	  .mids = { 0x96, 0x96, 0x96, 0x8F,
+ 		    0x96, 0x96, 0x96 },
+ 	  .reqs = { 0x19, 0x17, 0x18, 0x01,
+ 		    0x1F, 0x15, 0x3A },
+ 	  .vals = { 0x3F000000, 0x42A00000, 0x00000000,
+ 		    0x00000000, 0x00000000, 0x00000000,
+ 		    0x00000000 }
+ 	},
+ 	{ .name = "Headphone",
+ 	  .commands = 7,
+ 	  .mids = { 0x96, 0x96, 0x96, 0x8F,
+ 		    0x96, 0x96, 0x96 },
+ 	  .reqs = { 0x19, 0x17, 0x18, 0x01,
+ 		    0x1F, 0x15, 0x3A },
+ 	  .vals = { 0x3F000000, 0x42A00000, 0x00000000,
+ 		    0x00000000, 0x00000000, 0x00000000,
+ 		    0x00000000 }
+ 	},
+ 	{ .name = "Surround",
+ 	  .commands = 8,
+ 	  .mids = { 0x96, 0x8F, 0x96, 0x96,
+ 		    0x96, 0x96, 0x96, 0x96 },
+ 	  .reqs = { 0x18, 0x01, 0x1F, 0x15,
+ 		    0x3A, 0x1A, 0x1B, 0x1C },
+ 	  .vals = { 0x00000000, 0x00000000, 0x00000000,
+ 		    0x00000000, 0x00000000, 0x00000000,
+ 		    0x00000000, 0x00000000 }
+ 	}
+ };
+ 
+ /*
+  * DSP volume setting structs. Req 1 is left volume, req 2 is right volume,
+  * and I don't know what the third req is, but it's always zero. I assume it's
+  * some sort of update or set command to tell the DSP there's new volume info.
+  */
+ #define DSP_VOL_OUT 0
+ #define DSP_VOL_IN  1
+ 
+ struct ct_dsp_volume_ctl {
+ 	hda_nid_t vnid;
+ 	int mid; /* module ID*/
+ 	unsigned int reqs[3]; /* scp req ID */
+ };
+ 
+ static const struct ct_dsp_volume_ctl ca0132_alt_vol_ctls[] = {
+ 	{ .vnid = VNID_SPK,
+ 	  .mid = 0x32,
+ 	  .reqs = {3, 4, 2}
+ 	},
+ 	{ .vnid = VNID_MIC,
+ 	  .mid = 0x37,
+ 	  .reqs = {2, 3, 1}
+ 	}
+ };
+ 
+ /* Values for ca0113_mmio_command_set for selecting output. */
+ #define AE5_CA0113_OUT_SET_COMMANDS 6
+ struct ae5_ca0113_output_set {
+ 	unsigned int group[AE5_CA0113_OUT_SET_COMMANDS];
+ 	unsigned int target[AE5_CA0113_OUT_SET_COMMANDS];
+ 	unsigned int vals[AE5_CA0113_OUT_SET_COMMANDS];
+ };
+ 
+ static const struct ae5_ca0113_output_set ae5_ca0113_output_presets[] = {
+ 	{ .group =  { 0x30, 0x30, 0x48, 0x48, 0x48, 0x30 },
+ 	  .target = { 0x2e, 0x30, 0x0d, 0x17, 0x19, 0x32 },
+ 	  .vals =   { 0x00, 0x00, 0x40, 0x00, 0x00, 0x3f }
+ 	},
+ 	{ .group =  { 0x30, 0x30, 0x48, 0x48, 0x48, 0x30 },
+ 	  .target = { 0x2e, 0x30, 0x0d, 0x17, 0x19, 0x32 },
+ 	  .vals =   { 0x3f, 0x3f, 0x00, 0x00, 0x00, 0x00 }
+ 	},
+ 	{ .group =  { 0x30, 0x30, 0x48, 0x48, 0x48, 0x30 },
+ 	  .target = { 0x2e, 0x30, 0x0d, 0x17, 0x19, 0x32 },
+ 	  .vals =   { 0x00, 0x00, 0x40, 0x00, 0x00, 0x3f }
+ 	}
+ };
+ 
+ /* ae5 ca0113 command sequences to set headphone gain levels. */
+ #define AE5_HEADPHONE_GAIN_PRESET_MAX_COMMANDS 4
+ struct ae5_headphone_gain_set {
+ 	char *name;
+ 	unsigned int vals[AE5_HEADPHONE_GAIN_PRESET_MAX_COMMANDS];
+ };
+ 
+ static const struct ae5_headphone_gain_set ae5_headphone_gain_presets[] = {
+ 	{ .name = "Low (16-31",
+ 	  .vals = { 0xff, 0x2c, 0xf5, 0x32 }
+ 	},
+ 	{ .name = "Medium (32-149",
+ 	  .vals = { 0x38, 0xa8, 0x3e, 0x4c }
+ 	},
+ 	{ .name = "High (150-600",
+ 	  .vals = { 0xff, 0xff, 0xff, 0x7f }
+ 	}
+ };
+ 
+ struct ae5_filter_set {
+ 	char *name;
+ 	unsigned int val;
+ };
+ 
+ static const struct ae5_filter_set ae5_filter_presets[] = {
+ 	{ .name = "Slow Roll Off",
+ 	  .val = 0xa0
+ 	},
+ 	{ .name = "Minimum Phase",
+ 	  .val = 0xc0
+ 	},
+ 	{ .name = "Fast Roll Off",
+ 	  .val = 0x80
+ 	}
+ };
+ 
++>>>>>>> 212de2e7414a (ALSA: hda/ca0132 - Add AE-5 specific controls)
  enum hda_cmd_vendor_io {
  	/* for DspIO node */
  	VENDOR_DSPIO_SCP_WRITE_DATA_LOW      = 0x000,
@@@ -753,6 -1018,20 +982,23 @@@ struct ca0132_spec 
  	long effects_switch[EFFECTS_COUNT];
  	long voicefx_val;
  	long cur_mic_boost;
++<<<<<<< HEAD
++=======
+ 	/* ca0132_alt control related values */
+ 	unsigned char in_enum_val;
+ 	unsigned char out_enum_val;
+ 	unsigned char mic_boost_enum_val;
+ 	unsigned char smart_volume_setting;
+ 	long fx_ctl_val[EFFECT_LEVEL_SLIDERS];
+ 	long xbass_xover_freq;
+ 	long eq_preset_val;
+ 	unsigned int tlv[4];
+ 	struct hda_vmaster_mute_hook vmaster_mute;
+ 	/* AE-5 Control values */
+ 	unsigned char ae5_headphone_gain_val;
+ 	unsigned char ae5_filter_val;
+ 
++>>>>>>> 212de2e7414a (ALSA: hda/ca0132 - Add AE-5 specific controls)
  
  	struct hda_codec *codec;
  	struct delayed_work unsol_hp_work;
@@@ -2763,6 -3195,277 +3009,280 @@@ static bool dspload_wait_loaded(struct 
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * ca0113 related functions. The ca0113 acts as the HDA bus for the pci-e
+  * based cards, and has a second mmio region, region2, that's used for special
+  * commands.
+  */
+ 
+ /*
+  * For cards with PCI-E region2 (Sound Blaster Z/ZxR, Recon3D, and AE-5)
+  * the mmio address 0x320 is used to set GPIO pins. The format for the data
+  * The first eight bits are just the number of the pin. So far, I've only seen
+  * this number go to 7.
+  * AE-5 note: The AE-5 seems to use pins 2 and 3 to somehow set the color value
+  * of the on-card LED. It seems to use pin 2 for data, then toggles 3 to on and
+  * then off to send that bit.
+  */
+ static void ca0113_mmio_gpio_set(struct hda_codec *codec, unsigned int gpio_pin,
+ 		bool enable)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned short gpio_data;
+ 
+ 	gpio_data = gpio_pin & 0xF;
+ 	gpio_data |= ((enable << 8) & 0x100);
+ 
+ 	writew(gpio_data, spec->mem_base + 0x320);
+ }
+ 
+ /*
+  * Special pci region2 commands that are only used by the AE-5. They follow
+  * a set format, and require reads at certain points to seemingly 'clear'
+  * the response data. My first tests didn't do these reads, and would cause
+  * the card to get locked up until the memory was read. These commands
+  * seem to work with three distinct values that I've taken to calling group,
+  * target-id, and value.
+  */
+ static void ca0113_mmio_command_set(struct hda_codec *codec, unsigned int group,
+ 		unsigned int target, unsigned int value)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int write_val;
+ 
+ 	writel(0x0000007e, spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 	writel(0x0000005a, spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 
+ 	writel(0x00800005, spec->mem_base + 0x20c);
+ 	writel(group, spec->mem_base + 0x804);
+ 
+ 	writel(0x00800005, spec->mem_base + 0x20c);
+ 	write_val = (target & 0xff);
+ 	write_val |= (value << 8);
+ 
+ 
+ 	writel(write_val, spec->mem_base + 0x204);
+ 	/*
+ 	 * Need delay here or else it goes too fast and works inconsistently.
+ 	 */
+ 	msleep(20);
+ 
+ 	readl(spec->mem_base + 0x860);
+ 	readl(spec->mem_base + 0x854);
+ 	readl(spec->mem_base + 0x840);
+ 
+ 	writel(0x00800004, spec->mem_base + 0x20c);
+ 	writel(0x00000000, spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ }
+ 
+ /*
+  * This second type of command is used for setting the sound filter type.
+  */
+ static void ca0113_mmio_command_set_type2(struct hda_codec *codec,
+ 		unsigned int group, unsigned int target, unsigned int value)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int write_val;
+ 
+ 	writel(0x0000007e, spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 	writel(0x0000005a, spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 
+ 	writel(0x00800003, spec->mem_base + 0x20c);
+ 	writel(group, spec->mem_base + 0x804);
+ 
+ 	writel(0x00800005, spec->mem_base + 0x20c);
+ 	write_val = (target & 0xff);
+ 	write_val |= (value << 8);
+ 
+ 
+ 	writel(write_val, spec->mem_base + 0x204);
+ 	msleep(20);
+ 	readl(spec->mem_base + 0x860);
+ 	readl(spec->mem_base + 0x854);
+ 	readl(spec->mem_base + 0x840);
+ 
+ 	writel(0x00800004, spec->mem_base + 0x20c);
+ 	writel(0x00000000, spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ }
+ 
+ /*
+  * Setup GPIO for the other variants of Core3D.
+  */
+ 
+ /*
+  * Sets up the GPIO pins so that they are discoverable. If this isn't done,
+  * the card shows as having no GPIO pins.
+  */
+ static void ca0132_gpio_init(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 	case QUIRK_AE5:
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x793, 0x00);
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x794, 0x53);
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x790, 0x23);
+ 		break;
+ 	case QUIRK_R3DI:
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x793, 0x00);
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x794, 0x5B);
+ 		break;
+ 	}
+ 
+ }
+ 
+ /* Sets the GPIO for audio output. */
+ static void ca0132_gpio_setup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DIRECTION, 0x07);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_MASK, 0x07);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DATA, 0x04);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DATA, 0x06);
+ 		break;
+ 	case QUIRK_R3DI:
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DIRECTION, 0x1E);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_MASK, 0x1F);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DATA, 0x0C);
+ 		break;
+ 	}
+ }
+ 
+ /*
+  * GPIO control functions for the Recon3D integrated.
+  */
+ 
+ enum r3di_gpio_bit {
+ 	/* Bit 1 - Switch between front/rear mic. 0 = rear, 1 = front */
+ 	R3DI_MIC_SELECT_BIT = 1,
+ 	/* Bit 2 - Switch between headphone/line out. 0 = Headphone, 1 = Line */
+ 	R3DI_OUT_SELECT_BIT = 2,
+ 	/*
+ 	 * I dunno what this actually does, but it stays on until the dsp
+ 	 * is downloaded.
+ 	 */
+ 	R3DI_GPIO_DSP_DOWNLOADING = 3,
+ 	/*
+ 	 * Same as above, no clue what it does, but it comes on after the dsp
+ 	 * is downloaded.
+ 	 */
+ 	R3DI_GPIO_DSP_DOWNLOADED = 4
+ };
+ 
+ enum r3di_mic_select {
+ 	/* Set GPIO bit 1 to 0 for rear mic */
+ 	R3DI_REAR_MIC = 0,
+ 	/* Set GPIO bit 1 to 1 for front microphone*/
+ 	R3DI_FRONT_MIC = 1
+ };
+ 
+ enum r3di_out_select {
+ 	/* Set GPIO bit 2 to 0 for headphone */
+ 	R3DI_HEADPHONE_OUT = 0,
+ 	/* Set GPIO bit 2 to 1 for speaker */
+ 	R3DI_LINE_OUT = 1
+ };
+ enum r3di_dsp_status {
+ 	/* Set GPIO bit 3 to 1 until DSP is downloaded */
+ 	R3DI_DSP_DOWNLOADING = 0,
+ 	/* Set GPIO bit 4 to 1 once DSP is downloaded */
+ 	R3DI_DSP_DOWNLOADED = 1
+ };
+ 
+ 
+ static void r3di_gpio_mic_set(struct hda_codec *codec,
+ 		enum r3di_mic_select cur_mic)
+ {
+ 	unsigned int cur_gpio;
+ 
+ 	/* Get the current GPIO Data setup */
+ 	cur_gpio = snd_hda_codec_read(codec, 0x01, 0, AC_VERB_GET_GPIO_DATA, 0);
+ 
+ 	switch (cur_mic) {
+ 	case R3DI_REAR_MIC:
+ 		cur_gpio &= ~(1 << R3DI_MIC_SELECT_BIT);
+ 		break;
+ 	case R3DI_FRONT_MIC:
+ 		cur_gpio |= (1 << R3DI_MIC_SELECT_BIT);
+ 		break;
+ 	}
+ 	snd_hda_codec_write(codec, codec->core.afg, 0,
+ 			    AC_VERB_SET_GPIO_DATA, cur_gpio);
+ }
+ 
+ static void r3di_gpio_out_set(struct hda_codec *codec,
+ 		enum r3di_out_select cur_out)
+ {
+ 	unsigned int cur_gpio;
+ 
+ 	/* Get the current GPIO Data setup */
+ 	cur_gpio = snd_hda_codec_read(codec, 0x01, 0, AC_VERB_GET_GPIO_DATA, 0);
+ 
+ 	switch (cur_out) {
+ 	case R3DI_HEADPHONE_OUT:
+ 		cur_gpio &= ~(1 << R3DI_OUT_SELECT_BIT);
+ 		break;
+ 	case R3DI_LINE_OUT:
+ 		cur_gpio |= (1 << R3DI_OUT_SELECT_BIT);
+ 		break;
+ 	}
+ 	snd_hda_codec_write(codec, codec->core.afg, 0,
+ 			    AC_VERB_SET_GPIO_DATA, cur_gpio);
+ }
+ 
+ static void r3di_gpio_dsp_status_set(struct hda_codec *codec,
+ 		enum r3di_dsp_status dsp_status)
+ {
+ 	unsigned int cur_gpio;
+ 
+ 	/* Get the current GPIO Data setup */
+ 	cur_gpio = snd_hda_codec_read(codec, 0x01, 0, AC_VERB_GET_GPIO_DATA, 0);
+ 
+ 	switch (dsp_status) {
+ 	case R3DI_DSP_DOWNLOADING:
+ 		cur_gpio |= (1 << R3DI_GPIO_DSP_DOWNLOADING);
+ 		snd_hda_codec_write(codec, codec->core.afg, 0,
+ 				AC_VERB_SET_GPIO_DATA, cur_gpio);
+ 		break;
+ 	case R3DI_DSP_DOWNLOADED:
+ 		/* Set DOWNLOADING bit to 0. */
+ 		cur_gpio &= ~(1 << R3DI_GPIO_DSP_DOWNLOADING);
+ 
+ 		snd_hda_codec_write(codec, codec->core.afg, 0,
+ 				AC_VERB_SET_GPIO_DATA, cur_gpio);
+ 
+ 		cur_gpio |= (1 << R3DI_GPIO_DSP_DOWNLOADED);
+ 		break;
+ 	}
+ 
+ 	snd_hda_codec_write(codec, codec->core.afg, 0,
+ 			    AC_VERB_SET_GPIO_DATA, cur_gpio);
+ }
+ 
+ /*
++>>>>>>> 212de2e7414a (ALSA: hda/ca0132 - Add AE-5 specific controls)
   * PCM callbacks
   */
  static int ca0132_playback_pcm_prepare(struct hda_pcm_stream *hinfo,
@@@ -3324,28 -4124,25 +3844,27 @@@ exit
  	return err < 0 ? err : 0;
  }
  
- static void ca0132_unsol_hp_delayed(struct work_struct *work)
++<<<<<<< HEAD
++=======
+ static int ae5_headphone_gain_set(struct hda_codec *codec, long val);
+ 
+ static void ae5_mmio_select_out(struct hda_codec *codec)
  {
- 	struct ca0132_spec *spec = container_of(
- 		to_delayed_work(work), struct ca0132_spec, unsol_hp_work);
- 	struct hda_jack_tbl *jack;
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int i;
  
- 	ca0132_select_out(spec->codec);
- 	jack = snd_hda_jack_tbl_get(spec->codec, spec->unsol_tag_hp);
- 	if (jack) {
- 		jack->block_report = 0;
- 		snd_hda_jack_report_sync(spec->codec);
- 	}
+ 	for (i = 0; i < AE5_CA0113_OUT_SET_COMMANDS; i++)
+ 		ca0113_mmio_command_set(codec,
+ 			ae5_ca0113_output_presets[spec->cur_out_type].group[i],
+ 			ae5_ca0113_output_presets[spec->cur_out_type].target[i],
+ 			ae5_ca0113_output_presets[spec->cur_out_type].vals[i]);
  }
  
- static void ca0132_set_dmic(struct hda_codec *codec, int enable);
- static int ca0132_mic_boost_set(struct hda_codec *codec, long val);
- static int ca0132_effects_set(struct hda_codec *codec, hda_nid_t nid, long val);
- 
  /*
-  * Select the active VIP source
+  * These are the commands needed to setup output on each of the different card
+  * types.
   */
- static int ca0132_set_vipsource(struct hda_codec *codec, int val)
+ static void ca0132_alt_select_out_quirk_handler(struct hda_codec *codec)
  {
  	struct ca0132_spec *spec = codec->spec;
  	unsigned int tmp;
@@@ -3399,18 -4259,296 +3981,224 @@@ static int ca0132_alt_select_out(struc
  
  	snd_hda_power_up_pm(codec);
  
- 	auto_jack = spec->vnode_lswitch[VNID_AMIC1_ASEL - VNODE_START_NID];
+ 	auto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
  
- 	if (auto_jack)
- 		jack_present = snd_hda_jack_detect(codec, spec->unsol_tag_amic1);
- 	else
- 		jack_present =
- 			spec->vnode_lswitch[VNID_AMIC1_SEL - VNODE_START_NID];
+ 	/*
+ 	 * If headphone rear or front is plugged in, set to headphone.
+ 	 * If neither is plugged in, set to rear line out. Only if
+ 	 * hp/speaker auto detect is enabled.
+ 	 */
+ 	if (auto_jack) {
+ 		jack_present = snd_hda_jack_detect(codec, spec->unsol_tag_hp) ||
+ 			   snd_hda_jack_detect(codec, spec->unsol_tag_front_hp);
  
- 	if (jack_present)
- 		spec->cur_mic_type = LINE_MIC_IN;
- 	else
- 		spec->cur_mic_type = DIGITAL_MIC;
+ 		if (jack_present)
+ 			spec->cur_out_type = HEADPHONE_OUT;
+ 		else
+ 			spec->cur_out_type = SPEAKER_OUT;
+ 	} else
+ 		spec->cur_out_type = spec->out_enum_val;
+ 
+ 	/* Begin DSP output switch */
+ 	tmp = FLOAT_ONE;
+ 	err = dspio_set_uint_param(codec, 0x96, 0x3A, tmp);
+ 	if (err < 0)
+ 		goto exit;
+ 
+ 	ca0132_alt_select_out_quirk_handler(codec);
+ 
+ 	switch (spec->cur_out_type) {
+ 	case SPEAKER_OUT:
+ 		codec_dbg(codec, "%s speaker\n", __func__);
+ 
+ 		/* disable headphone node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[1],
+ 				    pin_ctl & ~PIN_HP);
+ 		/* enable line-out node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
+ 				AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
+ 				    pin_ctl | PIN_OUT);
+ 		/* Enable EAPD */
+ 		snd_hda_codec_write(codec, spec->out_pins[0], 0,
+ 			AC_VERB_SET_EAPD_BTLENABLE, 0x01);
+ 
+ 		/* If PlayEnhancement is enabled, set different source */
+ 		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
+ 		else
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_EIGHT);
+ 		break;
+ 	case HEADPHONE_OUT:
+ 		codec_dbg(codec, "%s hp\n", __func__);
+ 
+ 		snd_hda_codec_write(codec, spec->out_pins[0], 0,
+ 			AC_VERB_SET_EAPD_BTLENABLE, 0x00);
+ 
+ 		/* disable speaker*/
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
+ 				pin_ctl & ~PIN_HP);
+ 
+ 		/* enable headphone, either front or rear */
+ 
+ 		if (snd_hda_jack_detect(codec, spec->unsol_tag_front_hp))
+ 			headphone_nid = spec->out_pins[2];
+ 		else if (snd_hda_jack_detect(codec, spec->unsol_tag_hp))
+ 			headphone_nid = spec->out_pins[1];
+ 
+ 		pin_ctl = snd_hda_codec_read(codec, headphone_nid, 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, headphone_nid,
+ 				    pin_ctl | PIN_HP);
+ 
+ 		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
+ 		else
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ZERO);
+ 		break;
+ 	case SURROUND_OUT:
+ 		codec_dbg(codec, "%s surround\n", __func__);
+ 
+ 		/* enable line out node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
+ 				AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
+ 						pin_ctl | PIN_OUT);
+ 		/* Disable headphone out */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[1],
+ 				    pin_ctl & ~PIN_HP);
+ 		/* Enable EAPD on line out */
+ 		snd_hda_codec_write(codec, spec->out_pins[0], 0,
+ 			AC_VERB_SET_EAPD_BTLENABLE, 0x01);
+ 		/* enable center/lfe out node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[2], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[2],
+ 				    pin_ctl | PIN_OUT);
+ 		/* Now set rear surround node as out. */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[3], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[3],
+ 				    pin_ctl | PIN_OUT);
+ 
+ 		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
+ 		else
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_EIGHT);
+ 		break;
+ 	}
+ 
+ 	/* run through the output dsp commands for the selected output. */
+ 	for (i = 0; i < alt_out_presets[spec->cur_out_type].commands; i++) {
+ 		err = dspio_set_uint_param(codec,
+ 		alt_out_presets[spec->cur_out_type].mids[i],
+ 		alt_out_presets[spec->cur_out_type].reqs[i],
+ 		alt_out_presets[spec->cur_out_type].vals[i]);
+ 
+ 		if (err < 0)
+ 			goto exit;
+ 	}
+ 
+ exit:
+ 	snd_hda_power_down_pm(codec);
+ 
+ 	return err < 0 ? err : 0;
+ }
+ 
++>>>>>>> 212de2e7414a (ALSA: hda/ca0132 - Add AE-5 specific controls)
+ static void ca0132_unsol_hp_delayed(struct work_struct *work)
+ {
+ 	struct ca0132_spec *spec = container_of(
+ 		to_delayed_work(work), struct ca0132_spec, unsol_hp_work);
+ 	struct hda_jack_tbl *jack;
+ 
 -	if (spec->use_alt_functions)
 -		ca0132_alt_select_out(spec->codec);
 -	else
 -		ca0132_select_out(spec->codec);
 -
++	ca0132_select_out(spec->codec);
+ 	jack = snd_hda_jack_tbl_get(spec->codec, spec->unsol_tag_hp);
+ 	if (jack) {
+ 		jack->block_report = 0;
+ 		snd_hda_jack_report_sync(spec->codec);
+ 	}
+ }
+ 
+ static void ca0132_set_dmic(struct hda_codec *codec, int enable);
+ static int ca0132_mic_boost_set(struct hda_codec *codec, long val);
+ static int ca0132_effects_set(struct hda_codec *codec, hda_nid_t nid, long val);
 -static void resume_mic1(struct hda_codec *codec, unsigned int oldval);
 -static int stop_mic1(struct hda_codec *codec);
 -static int ca0132_cvoice_switch_set(struct hda_codec *codec);
 -static int ca0132_alt_mic_boost_set(struct hda_codec *codec, long val);
+ 
+ /*
+  * Select the active VIP source
+  */
+ static int ca0132_set_vipsource(struct hda_codec *codec, int val)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return 0;
+ 
+ 	/* if CrystalVoice if off, vipsource should be 0 */
+ 	if (!spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] ||
+ 	    (val == 0)) {
+ 		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, 0);
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 		if (spec->cur_mic_type == DIGITAL_MIC)
+ 			tmp = FLOAT_TWO;
+ 		else
+ 			tmp = FLOAT_ONE;
+ 		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 		tmp = FLOAT_ZERO;
+ 		dspio_set_uint_param(codec, 0x80, 0x05, tmp);
+ 	} else {
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_16_000);
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_16_000);
+ 		if (spec->cur_mic_type == DIGITAL_MIC)
+ 			tmp = FLOAT_TWO;
+ 		else
+ 			tmp = FLOAT_ONE;
+ 		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 		tmp = FLOAT_ONE;
+ 		dspio_set_uint_param(codec, 0x80, 0x05, tmp);
+ 		msleep(20);
+ 		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, val);
+ 	}
+ 
+ 	return 1;
+ }
+ 
 -static int ca0132_alt_set_vipsource(struct hda_codec *codec, int val)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -	unsigned int tmp;
 -
 -	if (spec->dsp_state != DSP_DOWNLOADED)
 -		return 0;
 -
 -	codec_dbg(codec, "%s\n", __func__);
 -
 -	chipio_set_stream_control(codec, 0x03, 0);
 -	chipio_set_stream_control(codec, 0x04, 0);
 -
 -	/* if CrystalVoice is off, vipsource should be 0 */
 -	if (!spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] ||
 -	    (val == 0) || spec->in_enum_val == REAR_LINE_IN) {
 -		codec_dbg(codec, "%s: off.", __func__);
 -		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, 0);
 -
 -		tmp = FLOAT_ZERO;
 -		dspio_set_uint_param(codec, 0x80, 0x05, tmp);
 -
 -		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
 -		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
 -		if (spec->quirk == QUIRK_R3DI)
 -			chipio_set_conn_rate(codec, 0x0F, SR_96_000);
 -
 -
 -		if (spec->in_enum_val == REAR_LINE_IN)
 -			tmp = FLOAT_ZERO;
 -		else {
 -			if (spec->quirk == QUIRK_SBZ)
 -				tmp = FLOAT_THREE;
 -			else
 -				tmp = FLOAT_ONE;
 -		}
 -
 -		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
 -
 -	} else {
 -		codec_dbg(codec, "%s: on.", __func__);
 -		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_16_000);
 -		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_16_000);
 -		if (spec->quirk == QUIRK_R3DI)
 -			chipio_set_conn_rate(codec, 0x0F, SR_16_000);
 -
 -		if (spec->effects_switch[VOICE_FOCUS - EFFECT_START_NID])
 -			tmp = FLOAT_TWO;
 -		else
 -			tmp = FLOAT_ONE;
 -		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
 -
 -		tmp = FLOAT_ONE;
 -		dspio_set_uint_param(codec, 0x80, 0x05, tmp);
 -
 -		msleep(20);
 -		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, val);
 -	}
 -
 -	chipio_set_stream_control(codec, 0x03, 1);
 -	chipio_set_stream_control(codec, 0x04, 1);
 -
 -	return 1;
 -}
 -
+ /*
+  * Select the active microphone.
+  * If autodetect is enabled, mic will be selected based on jack detection.
+  * If jack inserted, ext.mic will be selected, else built-in mic
+  * If autodetect is disabled, mic will be selected based on selection.
+  */
+ static int ca0132_select_mic(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int jack_present;
+ 	int auto_jack;
+ 
+ 	codec_dbg(codec, "ca0132_select_mic\n");
+ 
+ 	snd_hda_power_up_pm(codec);
+ 
+ 	auto_jack = spec->vnode_lswitch[VNID_AMIC1_ASEL - VNODE_START_NID];
+ 
+ 	if (auto_jack)
+ 		jack_present = snd_hda_jack_detect(codec, spec->unsol_tag_amic1);
+ 	else
+ 		jack_present =
+ 			spec->vnode_lswitch[VNID_AMIC1_SEL - VNODE_START_NID];
+ 
+ 	if (jack_present)
+ 		spec->cur_mic_type = LINE_MIC_IN;
+ 	else
+ 		spec->cur_mic_type = DIGITAL_MIC;
  
  	if (spec->cur_mic_type == DIGITAL_MIC) {
  		/* enable digital Mic */
@@@ -3512,20 -4795,595 +4300,547 @@@ static int ca0132_effects_set(struct hd
  		if (!spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID])
  			val = 0;
  
- 		/* Voice Focus applies to 2-ch Mic, Digital Mic */
- 		if ((nid == VOICE_FOCUS) && (spec->cur_mic_type != DIGITAL_MIC))
- 			val = 0;
- 	}
+ 		/* Voice Focus applies to 2-ch Mic, Digital Mic */
+ 		if ((nid == VOICE_FOCUS) && (spec->cur_mic_type != DIGITAL_MIC))
+ 			val = 0;
 -
 -		/* If Voice Focus on SBZ, set to two channel. */
 -		if ((nid == VOICE_FOCUS) && (spec->quirk == QUIRK_SBZ)
 -				&& (spec->cur_mic_type != REAR_LINE_IN)) {
 -			if (spec->effects_switch[CRYSTAL_VOICE -
 -						 EFFECT_START_NID]) {
 -
 -				if (spec->effects_switch[VOICE_FOCUS -
 -							 EFFECT_START_NID]) {
 -					tmp = FLOAT_TWO;
 -					val = 1;
 -				} else
 -					tmp = FLOAT_ONE;
 -
 -				dspio_set_uint_param(codec, 0x80, 0x00, tmp);
 -			}
 -		}
 -		/*
 -		 * For SBZ noise reduction, there's an extra command
 -		 * to module ID 0x47. No clue why.
 -		 */
 -		if ((nid == NOISE_REDUCTION) && (spec->quirk == QUIRK_SBZ)
 -				&& (spec->cur_mic_type != REAR_LINE_IN)) {
 -			if (spec->effects_switch[CRYSTAL_VOICE -
 -						 EFFECT_START_NID]) {
 -				if (spec->effects_switch[NOISE_REDUCTION -
 -							 EFFECT_START_NID])
 -					tmp = FLOAT_ONE;
 -				else
 -					tmp = FLOAT_ZERO;
 -			} else
 -				tmp = FLOAT_ZERO;
 -
 -			dspio_set_uint_param(codec, 0x47, 0x00, tmp);
 -		}
 -
 -		/* If rear line in disable effects. */
 -		if (spec->use_alt_functions &&
 -				spec->in_enum_val == REAR_LINE_IN)
 -			val = 0;
+ 	}
+ 
+ 	codec_dbg(codec, "ca0132_effect_set: nid=0x%x, val=%ld\n",
+ 		    nid, val);
+ 
+ 	on = (val == 0) ? FLOAT_ZERO : FLOAT_ONE;
+ 	err = dspio_set_uint_param(codec, ca0132_effects[idx].mid,
+ 				   ca0132_effects[idx].reqs[0], on);
+ 
+ 	if (err < 0)
+ 		return 0; /* no changed */
+ 
+ 	return 1;
+ }
+ 
+ /*
+  * Turn on/off Playback Enhancements
+  */
+ static int ca0132_pe_switch_set(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	hda_nid_t nid;
+ 	int i, ret = 0;
+ 
+ 	codec_dbg(codec, "ca0132_pe_switch_set: val=%ld\n",
+ 		    spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID]);
+ 
 -	if (spec->use_alt_functions)
 -		ca0132_alt_select_out(codec);
 -
+ 	i = OUT_EFFECT_START_NID - EFFECT_START_NID;
+ 	nid = OUT_EFFECT_START_NID;
+ 	/* PE affects all out effects */
+ 	for (; nid < OUT_EFFECT_END_NID; nid++, i++)
+ 		ret |= ca0132_effects_set(codec, nid, spec->effects_switch[i]);
+ 
+ 	return ret;
+ }
+ 
+ /* Check if Mic1 is streaming, if so, stop streaming */
+ static int stop_mic1(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int oldval = snd_hda_codec_read(codec, spec->adcs[0], 0,
+ 						 AC_VERB_GET_CONV, 0);
+ 	if (oldval != 0)
+ 		snd_hda_codec_write(codec, spec->adcs[0], 0,
+ 				    AC_VERB_SET_CHANNEL_STREAMID,
+ 				    0);
+ 	return oldval;
+ }
+ 
+ /* Resume Mic1 streaming if it was stopped. */
+ static void resume_mic1(struct hda_codec *codec, unsigned int oldval)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	/* Restore the previous stream and channel */
+ 	if (oldval != 0)
+ 		snd_hda_codec_write(codec, spec->adcs[0], 0,
+ 				    AC_VERB_SET_CHANNEL_STREAMID,
+ 				    oldval);
+ }
+ 
+ /*
+  * Turn on/off CrystalVoice
+  */
+ static int ca0132_cvoice_switch_set(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	hda_nid_t nid;
+ 	int i, ret = 0;
+ 	unsigned int oldval;
+ 
+ 	codec_dbg(codec, "ca0132_cvoice_switch_set: val=%ld\n",
+ 		    spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID]);
+ 
+ 	i = IN_EFFECT_START_NID - EFFECT_START_NID;
+ 	nid = IN_EFFECT_START_NID;
+ 	/* CrystalVoice affects all in effects */
+ 	for (; nid < IN_EFFECT_END_NID; nid++, i++)
+ 		ret |= ca0132_effects_set(codec, nid, spec->effects_switch[i]);
+ 
+ 	/* including VoiceFX */
+ 	ret |= ca0132_voicefx_set(codec, (spec->voicefx_val ? 1 : 0));
+ 
+ 	/* set correct vipsource */
+ 	oldval = stop_mic1(codec);
 -	if (spec->use_alt_functions)
 -		ret |= ca0132_alt_set_vipsource(codec, 1);
 -	else
 -		ret |= ca0132_set_vipsource(codec, 1);
++	ret |= ca0132_set_vipsource(codec, 1);
+ 	resume_mic1(codec, oldval);
+ 	return ret;
+ }
+ 
+ static int ca0132_mic_boost_set(struct hda_codec *codec, long val)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int ret = 0;
+ 
+ 	if (val) /* on */
+ 		ret = snd_hda_codec_amp_update(codec, spec->input_pins[0], 0,
+ 					HDA_INPUT, 0, HDA_AMP_VOLMASK, 3);
+ 	else /* off */
+ 		ret = snd_hda_codec_amp_update(codec, spec->input_pins[0], 0,
+ 					HDA_INPUT, 0, HDA_AMP_VOLMASK, 0);
+ 
+ 	return ret;
+ }
+ 
++<<<<<<< HEAD
++=======
+ static int ca0132_alt_mic_boost_set(struct hda_codec *codec, long val)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int ret = 0;
+ 
+ 	ret = snd_hda_codec_amp_update(codec, spec->input_pins[0], 0,
+ 				HDA_INPUT, 0, HDA_AMP_VOLMASK, val);
+ 	return ret;
+ }
+ 
+ static int ae5_headphone_gain_set(struct hda_codec *codec, long val)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < 4; i++)
+ 		ca0113_mmio_command_set(codec, 0x48, 0x11 + i,
+ 				ae5_headphone_gain_presets[val].vals[i]);
+ 	return 0;
+ }
+ 
++>>>>>>> 212de2e7414a (ALSA: hda/ca0132 - Add AE-5 specific controls)
+ static int ca0132_vnode_switch_set(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	hda_nid_t nid = get_amp_nid(kcontrol);
+ 	hda_nid_t shared_nid = 0;
+ 	bool effective;
+ 	int ret = 0;
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int auto_jack;
+ 
+ 	if (nid == VNID_HP_SEL) {
+ 		auto_jack =
+ 			spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
 -		if (!auto_jack) {
 -			if (spec->use_alt_functions)
 -				ca0132_alt_select_out(codec);
 -			else
 -				ca0132_select_out(codec);
 -		}
++		if (!auto_jack)
++			ca0132_select_out(codec);
+ 		return 1;
+ 	}
+ 
+ 	if (nid == VNID_AMIC1_SEL) {
+ 		auto_jack =
+ 			spec->vnode_lswitch[VNID_AMIC1_ASEL - VNODE_START_NID];
+ 		if (!auto_jack)
+ 			ca0132_select_mic(codec);
+ 		return 1;
+ 	}
+ 
+ 	if (nid == VNID_HP_ASEL) {
 -		if (spec->use_alt_functions)
 -			ca0132_alt_select_out(codec);
 -		else
 -			ca0132_select_out(codec);
++		ca0132_select_out(codec);
+ 		return 1;
+ 	}
+ 
+ 	if (nid == VNID_AMIC1_ASEL) {
+ 		ca0132_select_mic(codec);
+ 		return 1;
+ 	}
+ 
+ 	/* if effective conditions, then update hw immediately. */
+ 	effective = ca0132_is_vnode_effective(codec, nid, &shared_nid);
+ 	if (effective) {
+ 		int dir = get_amp_direction(kcontrol);
+ 		int ch = get_amp_channels(kcontrol);
+ 		unsigned long pval;
+ 
+ 		mutex_lock(&codec->control_mutex);
+ 		pval = kcontrol->private_value;
+ 		kcontrol->private_value = HDA_COMPOSE_AMP_VAL(shared_nid, ch,
+ 								0, dir);
+ 		ret = snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);
+ 		kcontrol->private_value = pval;
+ 		mutex_unlock(&codec->control_mutex);
+ 	}
+ 
+ 	return ret;
+ }
+ /* End of control change helpers. */
++<<<<<<< HEAD
++=======
+ /*
+  * Below I've added controls to mess with the effect levels, I've only enabled
+  * them on the Sound Blaster Z, but they would probably also work on the
+  * Chromebook. I figured they were probably tuned specifically for it, and left
+  * out for a reason.
+  */
+ 
+ /* Sets DSP effect level from the sliders above the controls */
+ static int ca0132_alt_slider_ctl_set(struct hda_codec *codec, hda_nid_t nid,
+ 			  const unsigned int *lookup, int idx)
+ {
+ 	int i = 0;
+ 	unsigned int y;
+ 	/*
+ 	 * For X_BASS, req 2 is actually crossover freq instead of
+ 	 * effect level
+ 	 */
+ 	if (nid == X_BASS)
+ 		y = 2;
+ 	else
+ 		y = 1;
+ 
+ 	snd_hda_power_up(codec);
+ 	if (nid == XBASS_XOVER) {
+ 		for (i = 0; i < OUT_EFFECTS_COUNT; i++)
+ 			if (ca0132_effects[i].nid == X_BASS)
+ 				break;
+ 
+ 		dspio_set_param(codec, ca0132_effects[i].mid, 0x20,
+ 				ca0132_effects[i].reqs[1],
+ 				&(lookup[idx - 1]), sizeof(unsigned int));
+ 	} else {
+ 		/* Find the actual effect structure */
+ 		for (i = 0; i < OUT_EFFECTS_COUNT; i++)
+ 			if (nid == ca0132_effects[i].nid)
+ 				break;
+ 
+ 		dspio_set_param(codec, ca0132_effects[i].mid, 0x20,
+ 				ca0132_effects[i].reqs[y],
+ 				&(lookup[idx]), sizeof(unsigned int));
+ 	}
+ 
+ 	snd_hda_power_down(codec);
+ 
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_xbass_xover_slider_ctl_get(struct snd_kcontrol *kcontrol,
+ 			  struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	long *valp = ucontrol->value.integer.value;
+ 
+ 	*valp = spec->xbass_xover_freq;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_slider_ctl_get(struct snd_kcontrol *kcontrol,
+ 			  struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	hda_nid_t nid = get_amp_nid(kcontrol);
+ 	long *valp = ucontrol->value.integer.value;
+ 	int idx = nid - OUT_EFFECT_START_NID;
+ 
+ 	*valp = spec->fx_ctl_val[idx];
+ 	return 0;
+ }
+ 
+ /*
+  * The X-bass crossover starts at 10hz, so the min is 1. The
+  * frequency is set in multiples of 10.
+  */
+ static int ca0132_alt_xbass_xover_slider_info(struct snd_kcontrol *kcontrol,
+ 		struct snd_ctl_elem_info *uinfo)
+ {
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+ 	uinfo->count = 1;
+ 	uinfo->value.integer.min = 1;
+ 	uinfo->value.integer.max = 100;
+ 	uinfo->value.integer.step = 1;
+ 
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_effect_slider_info(struct snd_kcontrol *kcontrol,
+ 		struct snd_ctl_elem_info *uinfo)
+ {
+ 	int chs = get_amp_channels(kcontrol);
+ 
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+ 	uinfo->count = chs == 3 ? 2 : 1;
+ 	uinfo->value.integer.min = 0;
+ 	uinfo->value.integer.max = 100;
+ 	uinfo->value.integer.step = 1;
+ 
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_xbass_xover_slider_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	hda_nid_t nid = get_amp_nid(kcontrol);
+ 	long *valp = ucontrol->value.integer.value;
+ 	int idx;
+ 
+ 	/* any change? */
+ 	if (spec->xbass_xover_freq == *valp)
+ 		return 0;
+ 
+ 	spec->xbass_xover_freq = *valp;
+ 
+ 	idx = *valp;
+ 	ca0132_alt_slider_ctl_set(codec, nid, float_xbass_xover_lookup, idx);
+ 
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_effect_slider_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	hda_nid_t nid = get_amp_nid(kcontrol);
+ 	long *valp = ucontrol->value.integer.value;
+ 	int idx;
+ 
+ 	idx = nid - EFFECT_START_NID;
+ 	/* any change? */
+ 	if (spec->fx_ctl_val[idx] == *valp)
+ 		return 0;
+ 
+ 	spec->fx_ctl_val[idx] = *valp;
+ 
+ 	idx = *valp;
+ 	ca0132_alt_slider_ctl_set(codec, nid, float_zero_to_one_lookup, idx);
+ 
+ 	return 0;
+ }
+ 
+ 
+ /*
+  * Mic Boost Enum for alternative ca0132 codecs. I didn't like that the original
+  * only has off or full 30 dB, and didn't like making a volume slider that has
+  * traditional 0-100 in alsamixer that goes in big steps. I like enum better.
+  */
+ #define MIC_BOOST_NUM_OF_STEPS 4
+ #define MIC_BOOST_ENUM_MAX_STRLEN 10
+ 
+ static int ca0132_alt_mic_boost_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	char *sfx = "dB";
+ 	char namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+ 
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = MIC_BOOST_NUM_OF_STEPS;
+ 	if (uinfo->value.enumerated.item >= MIC_BOOST_NUM_OF_STEPS)
+ 		uinfo->value.enumerated.item = MIC_BOOST_NUM_OF_STEPS - 1;
+ 	sprintf(namestr, "%d %s", (uinfo->value.enumerated.item * 10), sfx);
+ 	strcpy(uinfo->value.enumerated.name, namestr);
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_mic_boost_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->mic_boost_enum_val;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_mic_boost_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = MIC_BOOST_NUM_OF_STEPS;
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "ca0132_alt_mic_boost: boost=%d\n",
+ 		    sel);
+ 
+ 	spec->mic_boost_enum_val = sel;
+ 
+ 	if (spec->in_enum_val != REAR_LINE_IN)
+ 		ca0132_alt_mic_boost_set(codec, spec->mic_boost_enum_val);
+ 
+ 	return 1;
+ }
+ 
+ /*
+  * Sound BlasterX AE-5 Headphone Gain Controls.
+  */
+ #define AE5_HEADPHONE_GAIN_MAX 3
+ static int ae5_headphone_gain_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	char *sfx = " Ohms)";
+ 	char namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+ 
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = AE5_HEADPHONE_GAIN_MAX;
+ 	if (uinfo->value.enumerated.item >= AE5_HEADPHONE_GAIN_MAX)
+ 		uinfo->value.enumerated.item = AE5_HEADPHONE_GAIN_MAX - 1;
+ 	sprintf(namestr, "%s %s",
+ 		ae5_headphone_gain_presets[uinfo->value.enumerated.item].name,
+ 		sfx);
+ 	strcpy(uinfo->value.enumerated.name, namestr);
+ 	return 0;
+ }
+ 
+ static int ae5_headphone_gain_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->ae5_headphone_gain_val;
+ 	return 0;
+ }
+ 
+ static int ae5_headphone_gain_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = AE5_HEADPHONE_GAIN_MAX;
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "ae5_headphone_gain: boost=%d\n",
+ 		    sel);
+ 
+ 	spec->ae5_headphone_gain_val = sel;
+ 
+ 	if (spec->out_enum_val == HEADPHONE_OUT)
+ 		ae5_headphone_gain_set(codec, spec->ae5_headphone_gain_val);
+ 
+ 	return 1;
+ }
+ 
+ /*
+  * Sound BlasterX AE-5 sound filter enumerated control.
+  */
+ #define AE5_SOUND_FILTER_MAX 3
+ 
+ static int ae5_sound_filter_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	char namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+ 
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = AE5_SOUND_FILTER_MAX;
+ 	if (uinfo->value.enumerated.item >= AE5_SOUND_FILTER_MAX)
+ 		uinfo->value.enumerated.item = AE5_SOUND_FILTER_MAX - 1;
+ 	sprintf(namestr, "%s",
+ 			ae5_filter_presets[uinfo->value.enumerated.item].name);
+ 	strcpy(uinfo->value.enumerated.name, namestr);
+ 	return 0;
+ }
+ 
+ static int ae5_sound_filter_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->ae5_filter_val;
+ 	return 0;
+ }
+ 
+ static int ae5_sound_filter_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = AE5_SOUND_FILTER_MAX;
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "ae5_sound_filter: %s\n",
+ 			ae5_filter_presets[sel].name);
+ 
+ 	spec->ae5_filter_val = sel;
+ 
+ 	ca0113_mmio_command_set_type2(codec, 0x48, 0x07,
+ 			ae5_filter_presets[sel].val);
+ 
+ 	return 1;
+ }
+ 
+ /*
+  * Input Select Control for alternative ca0132 codecs. This exists because
+  * front microphone has no auto-detect, and we need a way to set the rear
+  * as line-in
+  */
+ static int ca0132_alt_input_source_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = IN_SRC_NUM_OF_INPUTS;
+ 	if (uinfo->value.enumerated.item >= IN_SRC_NUM_OF_INPUTS)
+ 		uinfo->value.enumerated.item = IN_SRC_NUM_OF_INPUTS - 1;
+ 	strcpy(uinfo->value.enumerated.name,
+ 			in_src_str[uinfo->value.enumerated.item]);
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_input_source_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->in_enum_val;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_input_source_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = IN_SRC_NUM_OF_INPUTS;
+ 
+ 	if (sel >= items)
+ 		return 0;
  
- 	codec_dbg(codec, "ca0132_effect_set: nid=0x%x, val=%ld\n",
- 		    nid, val);
+ 	codec_dbg(codec, "ca0132_alt_input_select: sel=%d, preset=%s\n",
+ 		    sel, in_src_str[sel]);
  
- 	on = (val == 0) ? FLOAT_ZERO : FLOAT_ONE;
- 	err = dspio_set_uint_param(codec, ca0132_effects[idx].mid,
- 				   ca0132_effects[idx].reqs[0], on);
+ 	spec->in_enum_val = sel;
  
- 	if (err < 0)
- 		return 0; /* no changed */
+ 	ca0132_alt_select_in(codec);
  
  	return 1;
  }
@@@ -3623,58 -5526,43 +4983,44 @@@ static int ca0132_alt_eq_preset_get(str
  				struct snd_ctl_elem_value *ucontrol)
  {
  	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
- 	hda_nid_t nid = get_amp_nid(kcontrol);
- 	hda_nid_t shared_nid = 0;
- 	bool effective;
- 	int ret = 0;
  	struct ca0132_spec *spec = codec->spec;
- 	int auto_jack;
  
- 	if (nid == VNID_HP_SEL) {
- 		auto_jack =
- 			spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
- 		if (!auto_jack)
- 			ca0132_select_out(codec);
- 		return 1;
- 	}
+ 	ucontrol->value.enumerated.item[0] = spec->eq_preset_val;
+ 	return 0;
+ }
  
- 	if (nid == VNID_AMIC1_SEL) {
- 		auto_jack =
- 			spec->vnode_lswitch[VNID_AMIC1_ASEL - VNODE_START_NID];
- 		if (!auto_jack)
- 			ca0132_select_mic(codec);
- 		return 1;
- 	}
+ static int ca0132_alt_eq_preset_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int i, err = 0;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = ARRAY_SIZE(ca0132_alt_eq_presets);
  
- 	if (nid == VNID_HP_ASEL) {
- 		ca0132_select_out(codec);
- 		return 1;
- 	}
+ 	if (sel >= items)
+ 		return 0;
  
- 	if (nid == VNID_AMIC1_ASEL) {
- 		ca0132_select_mic(codec);
- 		return 1;
+ 	codec_dbg(codec, "%s: sel=%d, preset=%s\n", __func__, sel,
+ 			ca0132_alt_eq_presets[sel].name);
+ 	/*
+ 	 * Idx 0 is default.
+ 	 * Default needs to qualify with CrystalVoice state.
+ 	 */
+ 	for (i = 0; i < EQ_PRESET_MAX_PARAM_COUNT; i++) {
+ 		err = dspio_set_uint_param(codec, ca0132_alt_eq_enum.mid,
+ 				ca0132_alt_eq_enum.reqs[i],
+ 				ca0132_alt_eq_presets[sel].vals[i]);
+ 		if (err < 0)
+ 			break;
  	}
  
- 	/* if effective conditions, then update hw immediately. */
- 	effective = ca0132_is_vnode_effective(codec, nid, &shared_nid);
- 	if (effective) {
- 		int dir = get_amp_direction(kcontrol);
- 		int ch = get_amp_channels(kcontrol);
- 		unsigned long pval;
- 
- 		mutex_lock(&codec->control_mutex);
- 		pval = kcontrol->private_value;
- 		kcontrol->private_value = HDA_COMPOSE_AMP_VAL(shared_nid, ch,
- 								0, dir);
- 		ret = snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);
- 		kcontrol->private_value = pval;
- 		mutex_unlock(&codec->control_mutex);
- 	}
+ 	if (err >= 0)
+ 		spec->eq_preset_val = sel;
  
- 	return ret;
+ 	return 1;
  }
- /* End of control change helpers. */
++>>>>>>> 212de2e7414a (ALSA: hda/ca0132 - Add AE-5 specific controls)
  
  static int ca0132_voicefx_info(struct snd_kcontrol *kcontrol,
  				 struct snd_ctl_elem_info *uinfo)
@@@ -4002,6 -6019,170 +5348,173 @@@ static int add_voicefx(struct hda_code
  	return snd_hda_ctl_add(codec, VOICEFX, snd_ctl_new1(&knew, codec));
  }
  
++<<<<<<< HEAD
++=======
+ /* Create the EQ Preset control */
+ static int add_ca0132_alt_eq_presets(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO(ca0132_alt_eq_enum.name,
+ 				    EQ_PRESET_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ca0132_alt_eq_preset_info;
+ 	knew.get = ca0132_alt_eq_preset_get;
+ 	knew.put = ca0132_alt_eq_preset_put;
+ 	return snd_hda_ctl_add(codec, EQ_PRESET_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Add enumerated control for the three different settings of the smart volume
+  * output effect. Normal just uses the slider value, and loud and night are
+  * their own things that ignore that value.
+  */
+ static int ca0132_alt_add_svm_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("FX: Smart Volume Setting",
+ 				    SMART_VOLUME_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ca0132_alt_svm_setting_info;
+ 	knew.get = ca0132_alt_svm_setting_get;
+ 	knew.put = ca0132_alt_svm_setting_put;
+ 	return snd_hda_ctl_add(codec, SMART_VOLUME_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ 
+ }
+ 
+ /*
+  * Create an Output Select enumerated control for codecs with surround
+  * out capabilities.
+  */
+ static int ca0132_alt_add_output_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("Output Select",
+ 				    OUTPUT_SOURCE_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ca0132_alt_output_select_get_info;
+ 	knew.get = ca0132_alt_output_select_get;
+ 	knew.put = ca0132_alt_output_select_put;
+ 	return snd_hda_ctl_add(codec, OUTPUT_SOURCE_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Create an Input Source enumerated control for the alternate ca0132 codecs
+  * because the front microphone has no auto-detect, and Line-in has to be set
+  * somehow.
+  */
+ static int ca0132_alt_add_input_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("Input Source",
+ 				    INPUT_SOURCE_ENUM, 1, 0, HDA_INPUT);
+ 	knew.info = ca0132_alt_input_source_info;
+ 	knew.get = ca0132_alt_input_source_get;
+ 	knew.put = ca0132_alt_input_source_put;
+ 	return snd_hda_ctl_add(codec, INPUT_SOURCE_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Add mic boost enumerated control. Switches through 0dB to 30dB. This adds
+  * more control than the original mic boost, which is either full 30dB or off.
+  */
+ static int ca0132_alt_add_mic_boost_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("Mic Boost Capture Switch",
+ 				    MIC_BOOST_ENUM, 1, 0, HDA_INPUT);
+ 	knew.info = ca0132_alt_mic_boost_info;
+ 	knew.get = ca0132_alt_mic_boost_get;
+ 	knew.put = ca0132_alt_mic_boost_put;
+ 	return snd_hda_ctl_add(codec, MIC_BOOST_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ 
+ }
+ 
+ /*
+  * Add headphone gain enumerated control for the AE-5. This switches between
+  * three modes, low, medium, and high. When non-headphone outputs are selected,
+  * it is automatically set to high. This is the same behavior as Windows.
+  */
+ static int ae5_add_headphone_gain_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("AE-5: Headphone Gain",
+ 				    AE5_HEADPHONE_GAIN_ENUM, 1, 0, HDA_INPUT);
+ 	knew.info = ae5_headphone_gain_info;
+ 	knew.get = ae5_headphone_gain_get;
+ 	knew.put = ae5_headphone_gain_put;
+ 	return snd_hda_ctl_add(codec, AE5_HEADPHONE_GAIN_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Add sound filter enumerated control for the AE-5. This adds three different
+  * settings: Slow Roll Off, Minimum Phase, and Fast Roll Off. From what I've
+  * read into it, it changes the DAC's interpolation filter.
+  */
+ static int ae5_add_sound_filter_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("AE-5: Sound Filter",
+ 				    AE5_SOUND_FILTER_ENUM, 1, 0, HDA_INPUT);
+ 	knew.info = ae5_sound_filter_info;
+ 	knew.get = ae5_sound_filter_get;
+ 	knew.put = ae5_sound_filter_put;
+ 	return snd_hda_ctl_add(codec, AE5_SOUND_FILTER_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Need to create slave controls for the alternate codecs that have surround
+  * capabilities.
+  */
+ static const char * const ca0132_alt_slave_pfxs[] = {
+ 	"Front", "Surround", "Center", "LFE", NULL,
+ };
+ 
+ /*
+  * Also need special channel map, because the default one is incorrect.
+  * I think this has to do with the pin for rear surround being 0x11,
+  * and the center/lfe being 0x10. Usually the pin order is the opposite.
+  */
+ static const struct snd_pcm_chmap_elem ca0132_alt_chmaps[] = {
+ 	{ .channels = 2,
+ 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
+ 	{ .channels = 4,
+ 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+ 		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+ 	{ .channels = 6,
+ 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+ 		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,
+ 		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+ 	{ }
+ };
+ 
+ /* Add the correct chmap for streams with 6 channels. */
+ static void ca0132_alt_add_chmap_ctls(struct hda_codec *codec)
+ {
+ 	int err = 0;
+ 	struct hda_pcm *pcm;
+ 
+ 	list_for_each_entry(pcm, &codec->pcm_list_head, list) {
+ 		struct hda_pcm_stream *hinfo =
+ 			&pcm->stream[SNDRV_PCM_STREAM_PLAYBACK];
+ 		struct snd_pcm_chmap *chmap;
+ 		const struct snd_pcm_chmap_elem *elem;
+ 
+ 		elem = ca0132_alt_chmaps;
+ 		if (hinfo->channels_max == 6) {
+ 			err = snd_pcm_add_chmap_ctls(pcm->pcm,
+ 					SNDRV_PCM_STREAM_PLAYBACK,
+ 					elem, hinfo->channels_max, 0, &chmap);
+ 			if (err < 0)
+ 				codec_dbg(codec, "snd_pcm_add_chmap_ctls failed!");
+ 		}
+ 	}
+ }
+ 
++>>>>>>> 212de2e7414a (ALSA: hda/ca0132 - Add AE-5 specific controls)
  /*
   * When changing Node IDs for Mixer Controls below, make sure to update
   * Node IDs in ca0132_config() as well.
@@@ -4052,17 -6298,67 +5565,35 @@@ static int ca0132_build_controls(struc
  		if (err < 0)
  			return err;
  	}
 -	/*
 -	 * If codec has use_alt_controls set to true, add effect level sliders,
 -	 * EQ presets, and Smart Volume presets. Also, change names to add FX
 -	 * prefix, and change PlayEnhancement and CrystalVoice to match.
 -	 */
 -	if (spec->use_alt_controls) {
 -		ca0132_alt_add_svm_enum(codec);
 -		add_ca0132_alt_eq_presets(codec);
 -		err = add_fx_switch(codec, PLAY_ENHANCEMENT,
 -					"Enable OutFX", 0);
 -		if (err < 0)
 -			return err;
 -
 -		err = add_fx_switch(codec, CRYSTAL_VOICE,
 -					"Enable InFX", 1);
 -		if (err < 0)
 -			return err;
 -
 -		num_sliders = OUT_EFFECTS_COUNT - 1;
 -		for (i = 0; i < num_sliders; i++) {
 -			err = ca0132_alt_add_effect_slider(codec,
 -					    ca0132_effects[i].nid,
 -					    ca0132_effects[i].name,
 -					    ca0132_effects[i].direct);
 -			if (err < 0)
 -				return err;
 -		}
  
 -		err = ca0132_alt_add_effect_slider(codec, XBASS_XOVER,
 -					"X-Bass Crossover", EFX_DIR_OUT);
 +	err = add_fx_switch(codec, PLAY_ENHANCEMENT, "PlayEnhancement", 0);
 +	if (err < 0)
 +		return err;
  
 -		if (err < 0)
 -			return err;
 -	} else {
 -		err = add_fx_switch(codec, PLAY_ENHANCEMENT,
 -					"PlayEnhancement", 0);
 -		if (err < 0)
 -			return err;
 +	err = add_fx_switch(codec, CRYSTAL_VOICE, "CrystalVoice", 1);
 +	if (err < 0)
 +		return err;
  
 -		err = add_fx_switch(codec, CRYSTAL_VOICE,
 -					"CrystalVoice", 1);
 -		if (err < 0)
 -			return err;
 -	}
  	add_voicefx(codec);
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * If the codec uses alt_functions, you need the enumerated controls
+ 	 * to select the new outputs and inputs, plus add the new mic boost
+ 	 * setting control.
+ 	 */
+ 	if (spec->use_alt_functions) {
+ 		ca0132_alt_add_output_enum(codec);
+ 		ca0132_alt_add_input_enum(codec);
+ 		ca0132_alt_add_mic_boost_enum(codec);
+ 	}
+ 
+ 	if (spec->quirk == QUIRK_AE5) {
+ 		ae5_add_headphone_gain_enum(codec);
+ 		ae5_add_sound_filter_enum(codec);
+ 	}
++>>>>>>> 212de2e7414a (ALSA: hda/ca0132 - Add AE-5 specific controls)
  #ifdef ENABLE_TUNING_CONTROLS
  	add_tuning_ctls(codec);
  #endif
* Unmerged path sound/pci/hda/patch_ca0132.c
