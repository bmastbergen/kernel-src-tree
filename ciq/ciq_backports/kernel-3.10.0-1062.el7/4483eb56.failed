xfs: mark xfs_btree_check_lblock and xfs_btree_check_ptr static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 4483eb566b2c045f69f2fa01629aca7772cdf95e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4483eb56.failed

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 4483eb566b2c045f69f2fa01629aca7772cdf95e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_btree.c
diff --cc fs/xfs/libxfs/xfs_btree.c
index bad40823795f,5f33adf8eecb..000000000000
--- a/fs/xfs/libxfs/xfs_btree.c
+++ b/fs/xfs/libxfs/xfs_btree.c
@@@ -62,45 -64,63 +62,64 @@@ xfs_btree_magic
  	return magic;
  }
  
 -/*
 - * Check a long btree block header.  Return the address of the failing check,
 - * or NULL if everything is ok.
 - */
 -xfs_failaddr_t
 -__xfs_btree_check_lblock(
 -	struct xfs_btree_cur	*cur,
 -	struct xfs_btree_block	*block,
 -	int			level,
 -	struct xfs_buf		*bp)
 +
 +STATIC int				/* error (0 or EFSCORRUPTED) */
 +xfs_btree_check_lblock(
 +	struct xfs_btree_cur	*cur,	/* btree cursor */
 +	struct xfs_btree_block	*block,	/* btree long form block pointer */
 +	int			level,	/* level of the btree block */
 +	struct xfs_buf		*bp)	/* buffer for block, if any */
  {
 -	struct xfs_mount	*mp = cur->bc_mp;
 +	int			lblock_ok = 1; /* block passes checks */
 +	struct xfs_mount	*mp;	/* file system mount point */
  	xfs_btnum_t		btnum = cur->bc_btnum;
 -	int			crc = xfs_sb_version_hascrc(&mp->m_sb);
 +	int			crc;
 +
 +	mp = cur->bc_mp;
 +	crc = xfs_sb_version_hascrc(&mp->m_sb);
  
  	if (crc) {
 -		if (!uuid_equal(&block->bb_u.l.bb_uuid, &mp->m_sb.sb_meta_uuid))
 -			return __this_address;
 -		if (block->bb_u.l.bb_blkno !=
 -		    cpu_to_be64(bp ? bp->b_bn : XFS_BUF_DADDR_NULL))
 -			return __this_address;
 -		if (block->bb_u.l.bb_pad != cpu_to_be32(0))
 -			return __this_address;
 +		lblock_ok = lblock_ok &&
 +			uuid_equal(&block->bb_u.l.bb_uuid,
 +				   &mp->m_sb.sb_meta_uuid) &&
 +			block->bb_u.l.bb_blkno == cpu_to_be64(
 +				bp ? bp->b_bn : XFS_BUF_DADDR_NULL);
  	}
  
 -	if (be32_to_cpu(block->bb_magic) != xfs_btree_magic(crc, btnum))
 -		return __this_address;
 -	if (be16_to_cpu(block->bb_level) != level)
 -		return __this_address;
 -	if (be16_to_cpu(block->bb_numrecs) >
 -	    cur->bc_ops->get_maxrecs(cur, level))
 -		return __this_address;
 -	if (block->bb_u.l.bb_leftsib != cpu_to_be64(NULLFSBLOCK) &&
 -	    !xfs_btree_check_lptr(cur, be64_to_cpu(block->bb_u.l.bb_leftsib),
 -			level + 1))
 -		return __this_address;
 -	if (block->bb_u.l.bb_rightsib != cpu_to_be64(NULLFSBLOCK) &&
 -	    !xfs_btree_check_lptr(cur, be64_to_cpu(block->bb_u.l.bb_rightsib),
 -			level + 1))
 -		return __this_address;
 -
 +	lblock_ok = lblock_ok &&
 +		be32_to_cpu(block->bb_magic) == xfs_btree_magic(crc, btnum) &&
 +		be16_to_cpu(block->bb_level) == level &&
 +		be16_to_cpu(block->bb_numrecs) <=
 +			cur->bc_ops->get_maxrecs(cur, level) &&
 +		block->bb_u.l.bb_leftsib &&
 +		(block->bb_u.l.bb_leftsib == cpu_to_be64(NULLFSBLOCK) ||
 +		 XFS_FSB_SANITY_CHECK(mp,
 +			be64_to_cpu(block->bb_u.l.bb_leftsib))) &&
 +		block->bb_u.l.bb_rightsib &&
 +		(block->bb_u.l.bb_rightsib == cpu_to_be64(NULLFSBLOCK) ||
 +		 XFS_FSB_SANITY_CHECK(mp,
 +			be64_to_cpu(block->bb_u.l.bb_rightsib)));
 +
++<<<<<<< HEAD
 +	if (unlikely(XFS_TEST_ERROR(!lblock_ok, mp,
++=======
+ 	return NULL;
+ }
+ 
+ /* Check a long btree block header. */
+ static int
+ xfs_btree_check_lblock(
+ 	struct xfs_btree_cur	*cur,
+ 	struct xfs_btree_block	*block,
+ 	int			level,
+ 	struct xfs_buf		*bp)
+ {
+ 	struct xfs_mount	*mp = cur->bc_mp;
+ 	xfs_failaddr_t		fa;
+ 
+ 	fa = __xfs_btree_check_lblock(cur, block, level, bp);
+ 	if (unlikely(XFS_TEST_ERROR(fa != NULL, mp,
++>>>>>>> 4483eb566b2c (xfs: mark xfs_btree_check_lblock and xfs_btree_check_ptr static)
  			XFS_ERRTAG_BTREE_CHECK_LBLOCK))) {
  		if (bp)
  			trace_xfs_btree_corrupt(bp, _RET_IP_);
* Unmerged path fs/xfs/libxfs/xfs_btree.c
