udp: Handle ICMP errors for tunnels with same destination port on both endpoints

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Stefano Brivio <sbrivio@redhat.com>
commit a36e185e8c85523413c1ae3e03a0bdde5501f403
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a36e185e.failed

For both IPv4 and IPv6, if we can't match errors to a socket, try
tunnels before ignoring them. Look up a socket with the original source
and destination ports as found in the UDP packet inside the ICMP payload,
this will work for tunnels that force the same destination port for both
endpoints, i.e. VXLAN and GENEVE.

Actually, lwtunnels could break this assumption if they are configured by
an external control plane to have different destination ports on the
endpoints: in this case, we won't be able to trace ICMP messages back to
them.

For IPv6 redirect messages, call ip6_redirect() directly with the output
interface argument set to the interface we received the packet from (as
it's the very interface we should build the exception on), otherwise the
new nexthop will be rejected. There's no such need for IPv4.

Tunnels can now export an encap_err_lookup() operation that indicates a
match. Pass the packet to the lookup function, and if the tunnel driver
reports a matching association, continue with regular ICMP error handling.

v2:
- Added newline between network and transport header sets in
  __udp{4,6}_lib_err_encap() (David Miller)
- Removed redundant skb_reset_network_header(skb); in
  __udp4_lib_err_encap()
- Removed redundant reassignment of iph in __udp4_lib_err_encap()
  (Sabrina Dubroca)
- Edited comment to __udp{4,6}_lib_err_encap() to reflect the fact this
  won't work with lwtunnels configured to use asymmetric ports. By the way,
  it's VXLAN, not VxLAN (Jiri Benc)

	Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
	Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a36e185e8c85523413c1ae3e03a0bdde5501f403)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp.c
#	net/ipv6/udp.c
diff --cc net/ipv4/udp.c
index 9a9ad5b95505,ce759b61f6cd..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -645,10 -664,18 +702,25 @@@ void __udp4_lib_err(struct sk_buff *skb
  	struct net *net = dev_net(skb->dev);
  
  	sk = __udp4_lib_lookup(net, iph->daddr, uh->dest,
++<<<<<<< HEAD
 +			iph->saddr, uh->source, skb->dev->ifindex, udptable);
 +	if (sk == NULL) {
 +		ICMP_INC_STATS_BH(net, ICMP_MIB_INERRORS);
 +		return;	/* No socket for error */
++=======
+ 			       iph->saddr, uh->source, skb->dev->ifindex,
+ 			       inet_sdif(skb), udptable, NULL);
+ 	if (!sk) {
+ 		/* No socket for error: try tunnels before discarding */
+ 		if (static_branch_unlikely(&udp_encap_needed_key))
+ 			sk = __udp4_lib_err_encap(net, iph, uh, udptable, skb);
+ 
+ 		if (!sk) {
+ 			__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);
+ 			return;
+ 		}
+ 		tunnel = true;
++>>>>>>> a36e185e8c85 (udp: Handle ICMP errors for tunnels with same destination port on both endpoints)
  	}
  
  	err = 0;
@@@ -1602,14 -1959,6 +1678,17 @@@ static int __udp_queue_rcv_skb(struct s
  	return 0;
  }
  
++<<<<<<< HEAD
 +static struct static_key udp_encap_needed __read_mostly;
 +void udp_encap_enable(void)
 +{
 +	if (!static_key_enabled(&udp_encap_needed))
 +		static_key_slow_inc(&udp_encap_needed);
 +}
 +EXPORT_SYMBOL(udp_encap_enable);
 +
++=======
++>>>>>>> a36e185e8c85 (udp: Handle ICMP errors for tunnels with same destination port on both endpoints)
  /* returns:
   *  -1: error
   *   0: success
diff --cc net/ipv6/udp.c
index 51c09afad847,1216c920f945..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -513,39 -525,60 +568,77 @@@ void __udp6_lib_err(struct sk_buff *skb
  	const struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;
  	const struct in6_addr *saddr = &hdr->saddr;
  	const struct in6_addr *daddr = &hdr->daddr;
++<<<<<<< HEAD
 +	struct udphdr *uh = (struct udphdr*)(skb->data+offset);
++=======
+ 	struct udphdr *uh = (struct udphdr *)(skb->data+offset);
+ 	bool tunnel = false;
++>>>>>>> a36e185e8c85 (udp: Handle ICMP errors for tunnels with same destination port on both endpoints)
  	struct sock *sk;
 -	int harderr;
  	int err;
  	struct net *net = dev_net(skb->dev);
  
  	sk = __udp6_lib_lookup(net, daddr, uh->dest, saddr, uh->source,
++<<<<<<< HEAD
 +			       inet6_iif(skb), udptable);
 +	if (sk == NULL) {
 +		ICMP6_INC_STATS_BH(net, __in6_dev_get(skb->dev),
 +				   ICMP6_MIB_INERRORS);
 +		return;
++=======
+ 			       inet6_iif(skb), inet6_sdif(skb), udptable, skb);
+ 	if (!sk) {
+ 		/* No socket for error: try tunnels before discarding */
+ 		if (static_branch_unlikely(&udpv6_encap_needed_key)) {
+ 			sk = __udp6_lib_err_encap(net, hdr, offset, uh,
+ 						  udptable, skb);
+ 		}
+ 
+ 		if (!sk) {
+ 			__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),
+ 					  ICMP6_MIB_INERRORS);
+ 			return;
+ 		}
+ 		tunnel = true;
++>>>>>>> a36e185e8c85 (udp: Handle ICMP errors for tunnels with same destination port on both endpoints)
  	}
  
 -	harderr = icmpv6_err_convert(type, code, &err);
 -	np = inet6_sk(sk);
 -
  	if (type == ICMPV6_PKT_TOOBIG) {
  		if (!ip6_sk_accept_pmtu(sk))
  			goto out;
  		ip6_sk_update_pmtu(skb, sk, info);
 -		if (np->pmtudisc != IPV6_PMTUDISC_DONT)
 -			harderr = 1;
  	}
  	if (type == NDISC_REDIRECT) {
- 		ip6_sk_redirect(skb, sk);
+ 		if (tunnel) {
+ 			ip6_redirect(skb, sock_net(sk), inet6_iif(skb),
+ 				     sk->sk_mark, sk->sk_uid);
+ 		} else {
+ 			ip6_sk_redirect(skb, sk);
+ 		}
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	np = inet6_sk(sk);
 +
 +	if (!icmpv6_err_convert(type, code, &err) && !np->recverr)
 +		goto out;
 +
 +	if (sk->sk_state != TCP_ESTABLISHED && !np->recverr)
 +		goto out;
 +
 +	if (np->recverr)
++=======
+ 	/* Tunnels don't have an application socket: don't pass errors back */
+ 	if (tunnel)
+ 		goto out;
+ 
+ 	if (!np->recverr) {
+ 		if (!harderr || sk->sk_state != TCP_ESTABLISHED)
+ 			goto out;
+ 	} else {
++>>>>>>> a36e185e8c85 (udp: Handle ICMP errors for tunnels with same destination port on both endpoints)
  		ipv6_icmp_error(sk, skb, err, uh->dest, ntohl(info), (u8 *)(uh+1));
 -	}
  
  	sk->sk_err = err;
  	sk->sk_error_report(sk);
@@@ -585,15 -621,7 +678,19 @@@ static __inline__ void udpv6_err(struc
  	__udp6_lib_err(skb, opt, type, code, offset, info, &udp_table);
  }
  
++<<<<<<< HEAD
 +static struct static_key udpv6_encap_needed __read_mostly;
 +void udpv6_encap_enable(void)
 +{
 +	if (!static_key_enabled(&udpv6_encap_needed))
 +		static_key_slow_inc(&udpv6_encap_needed);
 +}
 +EXPORT_SYMBOL(udpv6_encap_enable);
 +
 +int udpv6_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
++=======
+ static int udpv6_queue_rcv_one_skb(struct sock *sk, struct sk_buff *skb)
++>>>>>>> a36e185e8c85 (udp: Handle ICMP errors for tunnels with same destination port on both endpoints)
  {
  	struct udp_sock *up = udp_sk(sk);
  	int is_udplite = IS_UDPLITE(sk);
diff --git a/include/linux/udp.h b/include/linux/udp.h
index 3b44c8aa0d07..1d1d6358e1d3 100644
--- a/include/linux/udp.h
+++ b/include/linux/udp.h
@@ -70,6 +70,7 @@ struct udp_sock {
 	 * For encapsulation sockets.
 	 */
 	int (*encap_rcv)(struct sock *sk, struct sk_buff *skb);
+	int (*encap_err_lookup)(struct sock *sk, struct sk_buff *skb);
 	void (*encap_destroy)(struct sock *sk);
 
 	/* GRO functions for UDP socket */
diff --git a/include/net/udp_tunnel.h b/include/net/udp_tunnel.h
index 10cce0dd4450..b8124c779651 100644
--- a/include/net/udp_tunnel.h
+++ b/include/net/udp_tunnel.h
@@ -63,6 +63,8 @@ static inline int udp_sock_create(struct net *net,
 }
 
 typedef int (*udp_tunnel_encap_rcv_t)(struct sock *sk, struct sk_buff *skb);
+typedef int (*udp_tunnel_encap_err_lookup_t)(struct sock *sk,
+					     struct sk_buff *skb);
 typedef void (*udp_tunnel_encap_destroy_t)(struct sock *sk);
 typedef struct sk_buff **(*udp_tunnel_gro_receive_t)(struct sock *sk,
 						     struct sk_buff **head,
@@ -75,6 +77,7 @@ struct udp_tunnel_sock_cfg {
 	/* Used for setting up udp_sock fields, see udp.h for details */
 	__u8  encap_type;
 	udp_tunnel_encap_rcv_t encap_rcv;
+	udp_tunnel_encap_err_lookup_t encap_err_lookup;
 	udp_tunnel_encap_destroy_t encap_destroy;
 	udp_tunnel_gro_receive_t gro_receive;
 	udp_tunnel_gro_complete_t gro_complete;
* Unmerged path net/ipv4/udp.c
diff --git a/net/ipv4/udp_tunnel.c b/net/ipv4/udp_tunnel.c
index d58437264812..10b8152ff168 100644
--- a/net/ipv4/udp_tunnel.c
+++ b/net/ipv4/udp_tunnel.c
@@ -73,6 +73,7 @@ void setup_udp_tunnel_sock(struct net *net, struct socket *sock,
 
 	udp_sk(sk)->encap_type = cfg->encap_type;
 	udp_sk(sk)->encap_rcv = cfg->encap_rcv;
+	udp_sk(sk)->encap_err_lookup = cfg->encap_err_lookup;
 	udp_sk(sk)->encap_destroy = cfg->encap_destroy;
 	udp_sk(sk)->gro_receive = cfg->gro_receive;
 	udp_sk(sk)->gro_complete = cfg->gro_complete;
* Unmerged path net/ipv6/udp.c
