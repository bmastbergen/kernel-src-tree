bpf: enable stackmap with build_id in nmi context

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Song Liu <songliubraving@fb.com>
commit bae77c5eb5b2107e300fb02da2311f2aa0d8ee3c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/bae77c5e.failed

Currently, we cannot parse build_id in nmi context because of
up_read(&current->mm->mmap_sem), this makes stackmap with build_id
less useful. This patch enables parsing build_id in nmi by putting
the up_read() call in irq_work. To avoid memory allocation in nmi
context, we use per cpu variable for the irq_work. As a result, only
one irq_work per cpu is allowed. If the irq_work is in-use, we
fallback to only report ips.

	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Daniel Borkmann <daniel@iogearbox.net>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Signed-off-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit bae77c5eb5b2107e300fb02da2311f2aa0d8ee3c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	init/Kconfig
diff --cc init/Kconfig
index bede66c90088,480a4f2713d9..000000000000
--- a/init/Kconfig
+++ b/init/Kconfig
@@@ -1506,6 -1324,100 +1506,103 @@@ config MEMBARRIE
  
  	  If unsure, say Y.
  
++<<<<<<< HEAD
++=======
+ config CHECKPOINT_RESTORE
+ 	bool "Checkpoint/restore support" if EXPERT
+ 	select PROC_CHILDREN
+ 	default n
+ 	help
+ 	  Enables additional kernel features in a sake of checkpoint/restore.
+ 	  In particular it adds auxiliary prctl codes to setup process text,
+ 	  data and heap segment sizes, and a few additional /proc filesystem
+ 	  entries.
+ 
+ 	  If unsure, say N here.
+ 
+ config KALLSYMS
+ 	 bool "Load all symbols for debugging/ksymoops" if EXPERT
+ 	 default y
+ 	 help
+ 	   Say Y here to let the kernel print out symbolic crash information and
+ 	   symbolic stack backtraces. This increases the size of the kernel
+ 	   somewhat, as all symbols have to be loaded into the kernel image.
+ 
+ config KALLSYMS_ALL
+ 	bool "Include all symbols in kallsyms"
+ 	depends on DEBUG_KERNEL && KALLSYMS
+ 	help
+ 	   Normally kallsyms only contains the symbols of functions for nicer
+ 	   OOPS messages and backtraces (i.e., symbols from the text and inittext
+ 	   sections). This is sufficient for most cases. And only in very rare
+ 	   cases (e.g., when a debugger is used) all symbols are required (e.g.,
+ 	   names of variables from the data sections, etc).
+ 
+ 	   This option makes sure that all symbols are loaded into the kernel
+ 	   image (i.e., symbols from all sections) in cost of increased kernel
+ 	   size (depending on the kernel configuration, it may be 300KiB or
+ 	   something like this).
+ 
+ 	   Say N unless you really need all symbols.
+ 
+ config KALLSYMS_ABSOLUTE_PERCPU
+ 	bool
+ 	depends on KALLSYMS
+ 	default X86_64 && SMP
+ 
+ config KALLSYMS_BASE_RELATIVE
+ 	bool
+ 	depends on KALLSYMS
+ 	default !IA64
+ 	help
+ 	  Instead of emitting them as absolute values in the native word size,
+ 	  emit the symbol references in the kallsyms table as 32-bit entries,
+ 	  each containing a relative value in the range [base, base + U32_MAX]
+ 	  or, when KALLSYMS_ABSOLUTE_PERCPU is in effect, each containing either
+ 	  an absolute value in the range [0, S32_MAX] or a relative value in the
+ 	  range [base, base + S32_MAX], where base is the lowest relative symbol
+ 	  address encountered in the image.
+ 
+ 	  On 64-bit builds, this reduces the size of the address table by 50%,
+ 	  but more importantly, it results in entries whose values are build
+ 	  time constants, and no relocation pass is required at runtime to fix
+ 	  up the entries based on the runtime load address of the kernel.
+ 
+ # end of the "standard kernel features (expert users)" menu
+ 
+ # syscall, maps, verifier
+ config BPF_SYSCALL
+ 	bool "Enable bpf() system call"
+ 	select ANON_INODES
+ 	select BPF
+ 	select IRQ_WORK
+ 	default n
+ 	help
+ 	  Enable the bpf() system call that allows to manipulate eBPF
+ 	  programs and maps via file descriptors.
+ 
+ config BPF_JIT_ALWAYS_ON
+ 	bool "Permanently enable BPF JIT and remove BPF interpreter"
+ 	depends on BPF_SYSCALL && HAVE_EBPF_JIT && BPF_JIT
+ 	help
+ 	  Enables BPF JIT and removes BPF interpreter to avoid
+ 	  speculative execution of BPF instructions by the interpreter
+ 
+ config USERFAULTFD
+ 	bool "Enable userfaultfd() system call"
+ 	select ANON_INODES
+ 	depends on MMU
+ 	help
+ 	  Enable the userfaultfd() system call that allows to intercept and
+ 	  handle page faults in userland.
+ 
+ config ARCH_HAS_MEMBARRIER_CALLBACKS
+ 	bool
+ 
+ config ARCH_HAS_MEMBARRIER_SYNC_CORE
+ 	bool
+ 
++>>>>>>> bae77c5eb5b2 (bpf: enable stackmap with build_id in nmi context)
  config EMBEDDED
  	bool "Embedded system"
  	option allnoconfig_y
* Unmerged path init/Kconfig
diff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c
index 15bd541c30ba..7d9e0a4fe3f4 100644
--- a/kernel/bpf/stackmap.c
+++ b/kernel/bpf/stackmap.c
@@ -11,6 +11,7 @@
 #include <linux/perf_event.h>
 #include <linux/elf.h>
 #include <linux/pagemap.h>
+#include <linux/irq_work.h>
 #include "percpu_freelist.h"
 
 #define STACK_CREATE_FLAG_MASK					\
@@ -32,6 +33,23 @@ struct bpf_stack_map {
 	struct stack_map_bucket *buckets[];
 };
 
+/* irq_work to run up_read() for build_id lookup in nmi context */
+struct stack_map_irq_work {
+	struct irq_work irq_work;
+	struct rw_semaphore *sem;
+};
+
+static void do_up_read(struct irq_work *entry)
+{
+	struct stack_map_irq_work *work;
+
+	work = container_of(entry, struct stack_map_irq_work, irq_work);
+	up_read(work->sem);
+	work->sem = NULL;
+}
+
+static DEFINE_PER_CPU(struct stack_map_irq_work, up_read_work);
+
 static inline bool stack_map_use_build_id(struct bpf_map *map)
 {
 	return (map->map_flags & BPF_F_STACK_BUILD_ID);
@@ -267,17 +285,27 @@ static void stack_map_get_build_id_offset(struct bpf_stack_build_id *id_offs,
 {
 	int i;
 	struct vm_area_struct *vma;
+	bool in_nmi_ctx = in_nmi();
+	bool irq_work_busy = false;
+	struct stack_map_irq_work *work;
+
+	if (in_nmi_ctx) {
+		work = this_cpu_ptr(&up_read_work);
+		if (work->irq_work.flags & IRQ_WORK_BUSY)
+			/* cannot queue more up_read, fallback */
+			irq_work_busy = true;
+	}
 
 	/*
-	 * We cannot do up_read() in nmi context, so build_id lookup is
-	 * only supported for non-nmi events. If at some point, it is
-	 * possible to run find_vma() without taking the semaphore, we
-	 * would like to allow build_id lookup in nmi context.
+	 * We cannot do up_read() in nmi context. To do build_id lookup
+	 * in nmi context, we need to run up_read() in irq_work. We use
+	 * a percpu variable to do the irq_work. If the irq_work is
+	 * already used by another lookup, we fall back to report ips.
 	 *
 	 * Same fallback is used for kernel stack (!user) on a stackmap
 	 * with build_id.
 	 */
-	if (!user || !current || !current->mm || in_nmi() ||
+	if (!user || !current || !current->mm || irq_work_busy ||
 	    down_read_trylock(&current->mm->mmap_sem) == 0) {
 		/* cannot access current->mm, fall back to ips */
 		for (i = 0; i < trace_nr; i++) {
@@ -299,7 +327,13 @@ static void stack_map_get_build_id_offset(struct bpf_stack_build_id *id_offs,
 			- vma->vm_start;
 		id_offs[i].status = BPF_STACK_BUILD_ID_VALID;
 	}
-	up_read(&current->mm->mmap_sem);
+
+	if (!in_nmi_ctx) {
+		up_read(&current->mm->mmap_sem);
+	} else {
+		work->sem = &current->mm->mmap_sem;
+		irq_work_queue(&work->irq_work);
+	}
 }
 
 BPF_CALL_3(bpf_get_stackid, struct pt_regs *, regs, struct bpf_map *, map,
@@ -507,3 +541,16 @@ const struct bpf_map_ops stack_map_ops = {
 	.map_update_elem = stack_map_update_elem,
 	.map_delete_elem = stack_map_delete_elem,
 };
+
+static int __init stack_map_init(void)
+{
+	int cpu;
+	struct stack_map_irq_work *work;
+
+	for_each_possible_cpu(cpu) {
+		work = per_cpu_ptr(&up_read_work, cpu);
+		init_irq_work(&work->irq_work, do_up_read);
+	}
+	return 0;
+}
+subsys_initcall(stack_map_init);
