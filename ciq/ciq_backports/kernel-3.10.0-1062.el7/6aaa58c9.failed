md: fix memleak for mempool

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [md] fix memleak for mempool (Nigel Croxon) [1636944 1527943 1576466 1599780]
Rebuild_FUZZ: 92.00%
commit-author Jack Wang <jinpu.wang@profitbricks.com>
commit 6aaa58c994277647f8b05ffef3b9b225a2d08f36
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6aaa58c9.failed

I noticed kmemleak report memory leak when run create/stop
md in a loop, backtrace:
[<000000001ca975e7>] mempool_create_node+0x86/0xd0
[<0000000095576bcd>] md_run+0x1057/0x1410 [md_mod]
[<000000007b45c5fc>] do_md_run+0x15/0x130 [md_mod]
[<000000001ede9ec0>] md_ioctl+0x1f49/0x25d0 [md_mod]
[<000000004142cacf>] blkdev_ioctl+0x680/0xd00

The root cause is we alloc mddev->flush_pool and
mddev->flush_bio_pool in md_run, but from do_md_stop
will not call into md_stop but __md_stop, move the
mempool_destroy to __md_stop fixes the problem for me.

The bug was introduced in 5a409b4f56d5, the fixes should go to
4.18+

Fixes: 5a409b4f56d5 ("MD: fix lock contention for flush bios")
	Signed-off-by: Jack Wang <jinpu.wang@profitbricks.com>
	Reviewed-by: Xiao Ni <xni@redhat.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 6aaa58c994277647f8b05ffef3b9b225a2d08f36)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index c487b2c6f765,1fa7f1b1d98a..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -5804,23 -5904,24 +5804,42 @@@ static void __md_stop(struct mddev *mdd
  		mddev->to_remove = &md_redundancy_group;
  	module_put(pers->owner);
  	clear_bit(MD_RECOVERY_FROZEN, &mddev->recovery);
++<<<<<<< HEAD
 +}
 +
 +void md_stop(struct mddev *mddev)
 +{
 +	/* stop the array and free an attached data structures.
 +	 * This is called from dm-raid
 +	 */
 +	__md_stop(mddev);
 +	bitmap_destroy(mddev);
 +	if (mddev->bio_set) {
 +		bioset_free(mddev->bio_set);
 +		mddev->bio_set = NULL;
++=======
+ 	if (mddev->flush_bio_pool) {
+ 		mempool_destroy(mddev->flush_bio_pool);
+ 		mddev->flush_bio_pool = NULL;
++>>>>>>> 6aaa58c99427 (md: fix memleak for mempool)
  	}
 -	if (mddev->flush_pool) {
 -		mempool_destroy(mddev->flush_pool);
 -		mddev->flush_pool = NULL;
 +	if (mddev->sync_set) {
 +		bioset_free(mddev->sync_set);
 +		mddev->sync_set = NULL;
  	}
++<<<<<<< HEAD
++=======
+ }
+ 
+ void md_stop(struct mddev *mddev)
+ {
+ 	/* stop the array and free an attached data structures.
+ 	 * This is called from dm-raid
+ 	 */
+ 	__md_stop(mddev);
+ 	bioset_exit(&mddev->bio_set);
+ 	bioset_exit(&mddev->sync_set);
++>>>>>>> 6aaa58c99427 (md: fix memleak for mempool)
  }
  
  EXPORT_SYMBOL_GPL(md_stop);
* Unmerged path drivers/md/md.c
