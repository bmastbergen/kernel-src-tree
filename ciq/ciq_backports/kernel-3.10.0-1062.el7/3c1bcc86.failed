net: ethernet: Convert phydev advertize and supported from u32 to link mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] Convert phydev advertize and supported from u32 to link mode (Corinna Vinschen) [1646441]
Rebuild_FUZZ: 88.89%
commit-author Andrew Lunn <andrew@lunn.ch>
commit 3c1bcc8614db10803f1f57ef0295363917448cb2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3c1bcc86.failed

There are a few MAC/PHYs combinations which now support > 1Gbps. These
may need to make use of link modes with bits > 31. Thus their
supported PHY features or advertised features cannot be implemented
using the current bitmap in a u32. Convert to using a linkmode bitmap,
which can support all the currently devices link modes, and is future
proof as more modes are added.

	Signed-off-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3c1bcc8614db10803f1f57ef0295363917448cb2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/dsa/mt7530.c
#	drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
#	drivers/net/ethernet/apm/xgene-v2/mdio.c
#	drivers/net/ethernet/arc/emac_main.c
#	drivers/net/ethernet/broadcom/b44.c
#	drivers/net/ethernet/broadcom/genet/bcmmii.c
#	drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
#	drivers/net/ethernet/freescale/fman/mac.c
#	drivers/net/ethernet/freescale/gianfar.c
#	drivers/net/ethernet/freescale/ucc_geth.c
#	drivers/net/ethernet/hisilicon/hns/hns_enet.c
#	drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
#	drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.c
#	drivers/net/ethernet/ibm/emac/core.c
#	drivers/net/ethernet/marvell/mv643xx_eth.c
#	drivers/net/ethernet/mediatek/mtk_eth_soc.c
#	drivers/net/ethernet/octeon/octeon_mgmt.c
#	drivers/net/ethernet/realtek/r8169.c
#	drivers/net/ethernet/socionext/sni_ave.c
#	drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
#	drivers/net/ethernet/toshiba/tc35815.c
#	drivers/net/phy/aquantia.c
#	drivers/net/phy/bcm63xx.c
#	drivers/net/phy/fixed_phy.c
#	drivers/net/phy/marvell.c
#	drivers/net/phy/marvell10g.c
#	drivers/net/phy/micrel.c
#	drivers/net/phy/phy-c45.c
#	drivers/net/phy/phy-core.c
#	drivers/net/phy/phy.c
#	drivers/net/phy/phy_device.c
#	drivers/net/phy/phylink.c
#	include/linux/mii.h
#	include/linux/phy.h
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
index 3ceb4f95ca7c,128cd648ba99..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
@@@ -878,9 -879,16 +879,22 @@@ static bool xgbe_phy_finisar_phy_quirks
  	phy_write(phy_data->phydev, 0x04, 0x0d01);
  	phy_write(phy_data->phydev, 0x00, 0x9140);
  
++<<<<<<< HEAD
 +	phy_data->phydev->supported = PHY_GBIT_FEATURES;
 +	phy_data->phydev->supported |= SUPPORTED_Pause | SUPPORTED_Asym_Pause;
 +	phy_data->phydev->advertising = phy_data->phydev->supported;
++=======
+ 	linkmode_set_bit_array(phy_10_100_features_array,
+ 			       ARRAY_SIZE(phy_10_100_features_array),
+ 			       supported);
+ 	linkmode_set_bit_array(phy_gbit_features_array,
+ 			       ARRAY_SIZE(phy_gbit_features_array),
+ 			       supported);
+ 
+ 	linkmode_copy(phy_data->phydev->supported, supported);
+ 
+ 	phy_support_asym_pause(phy_data->phydev);
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	netif_dbg(pdata, drv, pdata->netdev,
  		  "Finisar PHY quirk in place\n");
@@@ -950,9 -959,14 +965,20 @@@ static bool xgbe_phy_belfuse_phy_quirks
  	reg = phy_read(phy_data->phydev, 0x00);
  	phy_write(phy_data->phydev, 0x00, reg & ~0x00800);
  
++<<<<<<< HEAD
 +	phy_data->phydev->supported = PHY_GBIT_FEATURES;
 +	phy_data->phydev->supported |= SUPPORTED_Pause | SUPPORTED_Asym_Pause;
 +	phy_data->phydev->advertising = phy_data->phydev->supported;
++=======
+ 	linkmode_set_bit_array(phy_10_100_features_array,
+ 			       ARRAY_SIZE(phy_10_100_features_array),
+ 			       supported);
+ 	linkmode_set_bit_array(phy_gbit_features_array,
+ 			       ARRAY_SIZE(phy_gbit_features_array),
+ 			       supported);
+ 	linkmode_copy(phy_data->phydev->supported, supported);
+ 	phy_support_asym_pause(phy_data->phydev);
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	netif_dbg(pdata, drv, pdata->netdev,
  		  "BelFuse PHY quirk in place\n");
@@@ -1495,10 -1507,7 +1519,14 @@@ static void xgbe_phy_phydev_flowctrl(st
  	if (!phy_data->phydev)
  		return;
  
++<<<<<<< HEAD
 +	if (phy_data->phydev->advertising & ADVERTISED_Pause)
 +		lcl_adv |= ADVERTISE_PAUSE_CAP;
 +	if (phy_data->phydev->advertising & ADVERTISED_Asym_Pause)
 +		lcl_adv |= ADVERTISE_PAUSE_ASYM;
++=======
+ 	lcl_adv = linkmode_adv_to_lcl_adv_t(phy_data->phydev->advertising);
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	if (phy_data->phydev->pause) {
  		XGBE_SET_LP_ADV(lks, Pause);
diff --cc drivers/net/ethernet/broadcom/b44.c
index 468c4c17635e,f44808959ff3..000000000000
--- a/drivers/net/ethernet/broadcom/b44.c
+++ b/drivers/net/ethernet/broadcom/b44.c
@@@ -2135,6 -2209,135 +2135,138 @@@ static const struct net_device_ops b44_
  #endif
  };
  
++<<<<<<< HEAD
++=======
+ static void b44_adjust_link(struct net_device *dev)
+ {
+ 	struct b44 *bp = netdev_priv(dev);
+ 	struct phy_device *phydev = dev->phydev;
+ 	bool status_changed = 0;
+ 
+ 	BUG_ON(!phydev);
+ 
+ 	if (bp->old_link != phydev->link) {
+ 		status_changed = 1;
+ 		bp->old_link = phydev->link;
+ 	}
+ 
+ 	/* reflect duplex change */
+ 	if (phydev->link) {
+ 		if ((phydev->duplex == DUPLEX_HALF) &&
+ 		    (bp->flags & B44_FLAG_FULL_DUPLEX)) {
+ 			status_changed = 1;
+ 			bp->flags &= ~B44_FLAG_FULL_DUPLEX;
+ 		} else if ((phydev->duplex == DUPLEX_FULL) &&
+ 			   !(bp->flags & B44_FLAG_FULL_DUPLEX)) {
+ 			status_changed = 1;
+ 			bp->flags |= B44_FLAG_FULL_DUPLEX;
+ 		}
+ 	}
+ 
+ 	if (status_changed) {
+ 		u32 val = br32(bp, B44_TX_CTRL);
+ 		if (bp->flags & B44_FLAG_FULL_DUPLEX)
+ 			val |= TX_CTRL_DUPLEX;
+ 		else
+ 			val &= ~TX_CTRL_DUPLEX;
+ 		bw32(bp, B44_TX_CTRL, val);
+ 		phy_print_status(phydev);
+ 	}
+ }
+ 
+ static int b44_register_phy_one(struct b44 *bp)
+ {
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 	struct mii_bus *mii_bus;
+ 	struct ssb_device *sdev = bp->sdev;
+ 	struct phy_device *phydev;
+ 	char bus_id[MII_BUS_ID_SIZE + 3];
+ 	struct ssb_sprom *sprom = &sdev->bus->sprom;
+ 	int err;
+ 
+ 	mii_bus = mdiobus_alloc();
+ 	if (!mii_bus) {
+ 		dev_err(sdev->dev, "mdiobus_alloc() failed\n");
+ 		err = -ENOMEM;
+ 		goto err_out;
+ 	}
+ 
+ 	mii_bus->priv = bp;
+ 	mii_bus->read = b44_mdio_read_phylib;
+ 	mii_bus->write = b44_mdio_write_phylib;
+ 	mii_bus->name = "b44_eth_mii";
+ 	mii_bus->parent = sdev->dev;
+ 	mii_bus->phy_mask = ~(1 << bp->phy_addr);
+ 	snprintf(mii_bus->id, MII_BUS_ID_SIZE, "%x", instance);
+ 
+ 	bp->mii_bus = mii_bus;
+ 
+ 	err = mdiobus_register(mii_bus);
+ 	if (err) {
+ 		dev_err(sdev->dev, "failed to register MII bus\n");
+ 		goto err_out_mdiobus;
+ 	}
+ 
+ 	if (!mdiobus_is_registered_device(bp->mii_bus, bp->phy_addr) &&
+ 	    (sprom->boardflags_lo & (B44_BOARDFLAG_ROBO | B44_BOARDFLAG_ADM))) {
+ 
+ 		dev_info(sdev->dev,
+ 			 "could not find PHY at %i, use fixed one\n",
+ 			 bp->phy_addr);
+ 
+ 		bp->phy_addr = 0;
+ 		snprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, "fixed-0",
+ 			 bp->phy_addr);
+ 	} else {
+ 		snprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, mii_bus->id,
+ 			 bp->phy_addr);
+ 	}
+ 
+ 	phydev = phy_connect(bp->dev, bus_id, &b44_adjust_link,
+ 			     PHY_INTERFACE_MODE_MII);
+ 	if (IS_ERR(phydev)) {
+ 		dev_err(sdev->dev, "could not attach PHY at %i\n",
+ 			bp->phy_addr);
+ 		err = PTR_ERR(phydev);
+ 		goto err_out_mdiobus_unregister;
+ 	}
+ 
+ 	/* mask with MAC supported features */
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, mask);
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, mask);
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, mask);
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_MII_BIT, mask);
+ 	linkmode_and(phydev->supported, phydev->supported, mask);
+ 	linkmode_copy(phydev->advertising, phydev->supported);
+ 
+ 	bp->old_link = 0;
+ 	bp->phy_addr = phydev->mdio.addr;
+ 
+ 	phy_attached_info(phydev);
+ 
+ 	return 0;
+ 
+ err_out_mdiobus_unregister:
+ 	mdiobus_unregister(mii_bus);
+ 
+ err_out_mdiobus:
+ 	mdiobus_free(mii_bus);
+ 
+ err_out:
+ 	return err;
+ }
+ 
+ static void b44_unregister_phy_one(struct b44 *bp)
+ {
+ 	struct net_device *dev = bp->dev;
+ 	struct mii_bus *mii_bus = bp->mii_bus;
+ 
+ 	phy_disconnect(dev->phydev);
+ 	mdiobus_unregister(mii_bus);
+ 	mdiobus_free(mii_bus);
+ }
+ 
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  static int b44_init_one(struct ssb_device *sdev,
  			const struct ssb_device_id *ent)
  {
diff --cc drivers/net/ethernet/freescale/gianfar.c
index 8c3c26ff4738,0e102c764b13..000000000000
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@@ -1455,12 -1784,20 +1455,24 @@@ static phy_interface_t gfar_get_interfa
   */
  static int init_phy(struct net_device *dev)
  {
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
  	struct gfar_private *priv = netdev_priv(dev);
++<<<<<<< HEAD
 +	uint gigabit_support =
 +		priv->device_flags & FSL_GIANFAR_DEV_HAS_GIGABIT ?
 +		SUPPORTED_1000baseT_Full : 0;
++=======
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  	phy_interface_t interface;
 -	struct phy_device *phydev;
 -	struct ethtool_eee edata;
  
+ 	linkmode_set_bit_array(phy_10_100_features_array,
+ 			       ARRAY_SIZE(phy_10_100_features_array),
+ 			       mask);
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, mask);
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_MII_BIT, mask);
+ 	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_GIGABIT)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, mask);
+ 
  	priv->oldlink = 0;
  	priv->oldspeed = 0;
  	priv->oldduplex = -1;
@@@ -1481,8 -1815,15 +1493,20 @@@
  		gfar_configure_serdes(dev);
  
  	/* Remove any features not supported by the controller */
++<<<<<<< HEAD
 +	priv->phydev->supported &= (GFAR_SUPPORTED | gigabit_support);
 +	priv->phydev->advertising = priv->phydev->supported;
++=======
+ 	linkmode_and(phydev->supported, phydev->supported, mask);
+ 	linkmode_copy(phydev->advertising, phydev->supported);
+ 
+ 	/* Add support for flow control */
+ 	phy_support_asym_pause(phydev);
+ 
+ 	/* disable EEE autoneg, EEE not supported by eTSEC */
+ 	memset(&edata, 0, sizeof(struct ethtool_eee));
+ 	phy_ethtool_set_eee(phydev, &edata);
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	return 0;
  }
@@@ -3300,7 -3638,135 +3324,139 @@@ static irqreturn_t gfar_error(int irq, 
  	return IRQ_HANDLED;
  }
  
++<<<<<<< HEAD
 +static struct of_device_id gfar_match[] =
++=======
+ static u32 gfar_get_flowctrl_cfg(struct gfar_private *priv)
+ {
+ 	struct net_device *ndev = priv->ndev;
+ 	struct phy_device *phydev = ndev->phydev;
+ 	u32 val = 0;
+ 
+ 	if (!phydev->duplex)
+ 		return val;
+ 
+ 	if (!priv->pause_aneg_en) {
+ 		if (priv->tx_pause_en)
+ 			val |= MACCFG1_TX_FLOW;
+ 		if (priv->rx_pause_en)
+ 			val |= MACCFG1_RX_FLOW;
+ 	} else {
+ 		u16 lcl_adv, rmt_adv;
+ 		u8 flowctrl;
+ 		/* get link partner capabilities */
+ 		rmt_adv = 0;
+ 		if (phydev->pause)
+ 			rmt_adv = LPA_PAUSE_CAP;
+ 		if (phydev->asym_pause)
+ 			rmt_adv |= LPA_PAUSE_ASYM;
+ 
+ 		lcl_adv = linkmode_adv_to_lcl_adv_t(phydev->advertising);
+ 		flowctrl = mii_resolve_flowctrl_fdx(lcl_adv, rmt_adv);
+ 		if (flowctrl & FLOW_CTRL_TX)
+ 			val |= MACCFG1_TX_FLOW;
+ 		if (flowctrl & FLOW_CTRL_RX)
+ 			val |= MACCFG1_RX_FLOW;
+ 	}
+ 
+ 	return val;
+ }
+ 
+ static noinline void gfar_update_link_state(struct gfar_private *priv)
+ {
+ 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+ 	struct net_device *ndev = priv->ndev;
+ 	struct phy_device *phydev = ndev->phydev;
+ 	struct gfar_priv_rx_q *rx_queue = NULL;
+ 	int i;
+ 
+ 	if (unlikely(test_bit(GFAR_RESETTING, &priv->state)))
+ 		return;
+ 
+ 	if (phydev->link) {
+ 		u32 tempval1 = gfar_read(&regs->maccfg1);
+ 		u32 tempval = gfar_read(&regs->maccfg2);
+ 		u32 ecntrl = gfar_read(&regs->ecntrl);
+ 		u32 tx_flow_oldval = (tempval1 & MACCFG1_TX_FLOW);
+ 
+ 		if (phydev->duplex != priv->oldduplex) {
+ 			if (!(phydev->duplex))
+ 				tempval &= ~(MACCFG2_FULL_DUPLEX);
+ 			else
+ 				tempval |= MACCFG2_FULL_DUPLEX;
+ 
+ 			priv->oldduplex = phydev->duplex;
+ 		}
+ 
+ 		if (phydev->speed != priv->oldspeed) {
+ 			switch (phydev->speed) {
+ 			case 1000:
+ 				tempval =
+ 				    ((tempval & ~(MACCFG2_IF)) | MACCFG2_GMII);
+ 
+ 				ecntrl &= ~(ECNTRL_R100);
+ 				break;
+ 			case 100:
+ 			case 10:
+ 				tempval =
+ 				    ((tempval & ~(MACCFG2_IF)) | MACCFG2_MII);
+ 
+ 				/* Reduced mode distinguishes
+ 				 * between 10 and 100
+ 				 */
+ 				if (phydev->speed == SPEED_100)
+ 					ecntrl |= ECNTRL_R100;
+ 				else
+ 					ecntrl &= ~(ECNTRL_R100);
+ 				break;
+ 			default:
+ 				netif_warn(priv, link, priv->ndev,
+ 					   "Ack!  Speed (%d) is not 10/100/1000!\n",
+ 					   phydev->speed);
+ 				break;
+ 			}
+ 
+ 			priv->oldspeed = phydev->speed;
+ 		}
+ 
+ 		tempval1 &= ~(MACCFG1_TX_FLOW | MACCFG1_RX_FLOW);
+ 		tempval1 |= gfar_get_flowctrl_cfg(priv);
+ 
+ 		/* Turn last free buffer recording on */
+ 		if ((tempval1 & MACCFG1_TX_FLOW) && !tx_flow_oldval) {
+ 			for (i = 0; i < priv->num_rx_queues; i++) {
+ 				u32 bdp_dma;
+ 
+ 				rx_queue = priv->rx_queue[i];
+ 				bdp_dma = gfar_rxbd_dma_lastfree(rx_queue);
+ 				gfar_write(rx_queue->rfbptr, bdp_dma);
+ 			}
+ 
+ 			priv->tx_actual_en = 1;
+ 		}
+ 
+ 		if (unlikely(!(tempval1 & MACCFG1_TX_FLOW) && tx_flow_oldval))
+ 			priv->tx_actual_en = 0;
+ 
+ 		gfar_write(&regs->maccfg1, tempval1);
+ 		gfar_write(&regs->maccfg2, tempval);
+ 		gfar_write(&regs->ecntrl, ecntrl);
+ 
+ 		if (!priv->oldlink)
+ 			priv->oldlink = 1;
+ 
+ 	} else if (priv->oldlink) {
+ 		priv->oldlink = 0;
+ 		priv->oldspeed = 0;
+ 		priv->oldduplex = -1;
+ 	}
+ 
+ 	if (netif_msg_link(priv))
+ 		phy_print_status(phydev);
+ }
+ 
+ static const struct of_device_id gfar_match[] =
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  {
  	{
  		.type = "network",
diff --cc drivers/net/ethernet/freescale/ucc_geth.c
index 388f2e5b6b27,2e978cb8b28c..000000000000
--- a/drivers/net/ethernet/freescale/ucc_geth.c
+++ b/drivers/net/ethernet/freescale/ucc_geth.c
@@@ -1742,17 -1742,7 +1742,21 @@@ static int init_phy(struct net_device *
  	if (priv->phy_interface == PHY_INTERFACE_MODE_SGMII)
  		uec_configure_serdes(dev);
  
++<<<<<<< HEAD
 +	phydev->supported &= (SUPPORTED_MII |
 +			      SUPPORTED_Autoneg |
 +			      ADVERTISED_10baseT_Half |
 +			      ADVERTISED_10baseT_Full |
 +			      ADVERTISED_100baseT_Half |
 +			      ADVERTISED_100baseT_Full);
 +
 +	if (priv->max_speed == SPEED_1000)
 +		phydev->supported |= ADVERTISED_1000baseT_Full;
 +
 +	phydev->advertising = phydev->supported;
++=======
+ 	phy_set_max_speed(phydev, priv->max_speed);
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	priv->phydev = phydev;
  
diff --cc drivers/net/ethernet/ibm/emac/core.c
index 673fc13efc95,209255495bc9..000000000000
--- a/drivers/net/ethernet/ibm/emac/core.c
+++ b/drivers/net/ethernet/ibm/emac/core.c
@@@ -2400,6 -2445,215 +2400,218 @@@ static int emac_read_uint_prop(struct d
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void emac_adjust_link(struct net_device *ndev)
+ {
+ 	struct emac_instance *dev = netdev_priv(ndev);
+ 	struct phy_device *phy = dev->phy_dev;
+ 
+ 	dev->phy.autoneg = phy->autoneg;
+ 	dev->phy.speed = phy->speed;
+ 	dev->phy.duplex = phy->duplex;
+ 	dev->phy.pause = phy->pause;
+ 	dev->phy.asym_pause = phy->asym_pause;
+ 	ethtool_convert_link_mode_to_legacy_u32(&dev->phy.advertising,
+ 						phy->advertising);
+ }
+ 
+ static int emac_mii_bus_read(struct mii_bus *bus, int addr, int regnum)
+ {
+ 	int ret = emac_mdio_read(bus->priv, addr, regnum);
+ 	/* This is a workaround for powered down ports/phys.
+ 	 * In the wild, this was seen on the Cisco Meraki MX60(W).
+ 	 * This hardware disables ports as part of the handoff
+ 	 * procedure. Accessing the ports will lead to errors
+ 	 * (-ETIMEDOUT, -EREMOTEIO) that do more harm than good.
+ 	 */
+ 	return ret < 0 ? 0xffff : ret;
+ }
+ 
+ static int emac_mii_bus_write(struct mii_bus *bus, int addr,
+ 			      int regnum, u16 val)
+ {
+ 	emac_mdio_write(bus->priv, addr, regnum, val);
+ 	return 0;
+ }
+ 
+ static int emac_mii_bus_reset(struct mii_bus *bus)
+ {
+ 	struct emac_instance *dev = netdev_priv(bus->priv);
+ 
+ 	return emac_reset(dev);
+ }
+ 
+ static int emac_mdio_phy_start_aneg(struct mii_phy *phy,
+ 				    struct phy_device *phy_dev)
+ {
+ 	phy_dev->autoneg = phy->autoneg;
+ 	phy_dev->speed = phy->speed;
+ 	phy_dev->duplex = phy->duplex;
+ 	ethtool_convert_legacy_u32_to_link_mode(phy_dev->advertising,
+ 						phy->advertising);
+ 	return phy_start_aneg(phy_dev);
+ }
+ 
+ static int emac_mdio_setup_aneg(struct mii_phy *phy, u32 advertise)
+ {
+ 	struct net_device *ndev = phy->dev;
+ 	struct emac_instance *dev = netdev_priv(ndev);
+ 
+ 	phy->autoneg = AUTONEG_ENABLE;
+ 	phy->advertising = advertise;
+ 	return emac_mdio_phy_start_aneg(phy, dev->phy_dev);
+ }
+ 
+ static int emac_mdio_setup_forced(struct mii_phy *phy, int speed, int fd)
+ {
+ 	struct net_device *ndev = phy->dev;
+ 	struct emac_instance *dev = netdev_priv(ndev);
+ 
+ 	phy->autoneg = AUTONEG_DISABLE;
+ 	phy->speed = speed;
+ 	phy->duplex = fd;
+ 	return emac_mdio_phy_start_aneg(phy, dev->phy_dev);
+ }
+ 
+ static int emac_mdio_poll_link(struct mii_phy *phy)
+ {
+ 	struct net_device *ndev = phy->dev;
+ 	struct emac_instance *dev = netdev_priv(ndev);
+ 	int res;
+ 
+ 	res = phy_read_status(dev->phy_dev);
+ 	if (res) {
+ 		dev_err(&dev->ofdev->dev, "link update failed (%d).", res);
+ 		return ethtool_op_get_link(ndev);
+ 	}
+ 
+ 	return dev->phy_dev->link;
+ }
+ 
+ static int emac_mdio_read_link(struct mii_phy *phy)
+ {
+ 	struct net_device *ndev = phy->dev;
+ 	struct emac_instance *dev = netdev_priv(ndev);
+ 	struct phy_device *phy_dev = dev->phy_dev;
+ 	int res;
+ 
+ 	res = phy_read_status(phy_dev);
+ 	if (res)
+ 		return res;
+ 
+ 	phy->speed = phy_dev->speed;
+ 	phy->duplex = phy_dev->duplex;
+ 	phy->pause = phy_dev->pause;
+ 	phy->asym_pause = phy_dev->asym_pause;
+ 	return 0;
+ }
+ 
+ static int emac_mdio_init_phy(struct mii_phy *phy)
+ {
+ 	struct net_device *ndev = phy->dev;
+ 	struct emac_instance *dev = netdev_priv(ndev);
+ 
+ 	phy_start(dev->phy_dev);
+ 	return phy_init_hw(dev->phy_dev);
+ }
+ 
+ static const struct mii_phy_ops emac_dt_mdio_phy_ops = {
+ 	.init		= emac_mdio_init_phy,
+ 	.setup_aneg	= emac_mdio_setup_aneg,
+ 	.setup_forced	= emac_mdio_setup_forced,
+ 	.poll_link	= emac_mdio_poll_link,
+ 	.read_link	= emac_mdio_read_link,
+ };
+ 
+ static int emac_dt_mdio_probe(struct emac_instance *dev)
+ {
+ 	struct device_node *mii_np;
+ 	int res;
+ 
+ 	mii_np = of_get_child_by_name(dev->ofdev->dev.of_node, "mdio");
+ 	if (!mii_np) {
+ 		dev_err(&dev->ofdev->dev, "no mdio definition found.");
+ 		return -ENODEV;
+ 	}
+ 
+ 	if (!of_device_is_available(mii_np)) {
+ 		res = -ENODEV;
+ 		goto put_node;
+ 	}
+ 
+ 	dev->mii_bus = devm_mdiobus_alloc(&dev->ofdev->dev);
+ 	if (!dev->mii_bus) {
+ 		res = -ENOMEM;
+ 		goto put_node;
+ 	}
+ 
+ 	dev->mii_bus->priv = dev->ndev;
+ 	dev->mii_bus->parent = dev->ndev->dev.parent;
+ 	dev->mii_bus->name = "emac_mdio";
+ 	dev->mii_bus->read = &emac_mii_bus_read;
+ 	dev->mii_bus->write = &emac_mii_bus_write;
+ 	dev->mii_bus->reset = &emac_mii_bus_reset;
+ 	snprintf(dev->mii_bus->id, MII_BUS_ID_SIZE, "%s", dev->ofdev->name);
+ 	res = of_mdiobus_register(dev->mii_bus, mii_np);
+ 	if (res) {
+ 		dev_err(&dev->ofdev->dev, "cannot register MDIO bus %s (%d)",
+ 			dev->mii_bus->name, res);
+ 	}
+ 
+  put_node:
+ 	of_node_put(mii_np);
+ 	return res;
+ }
+ 
+ static int emac_dt_phy_connect(struct emac_instance *dev,
+ 			       struct device_node *phy_handle)
+ {
+ 	dev->phy.def = devm_kzalloc(&dev->ofdev->dev, sizeof(*dev->phy.def),
+ 				    GFP_KERNEL);
+ 	if (!dev->phy.def)
+ 		return -ENOMEM;
+ 
+ 	dev->phy_dev = of_phy_connect(dev->ndev, phy_handle, &emac_adjust_link,
+ 				      0, dev->phy_mode);
+ 	if (!dev->phy_dev) {
+ 		dev_err(&dev->ofdev->dev, "failed to connect to PHY.\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	dev->phy.def->phy_id = dev->phy_dev->drv->phy_id;
+ 	dev->phy.def->phy_id_mask = dev->phy_dev->drv->phy_id_mask;
+ 	dev->phy.def->name = dev->phy_dev->drv->name;
+ 	dev->phy.def->ops = &emac_dt_mdio_phy_ops;
+ 	ethtool_convert_link_mode_to_legacy_u32(&dev->phy.features,
+ 						dev->phy_dev->supported);
+ 	dev->phy.address = dev->phy_dev->mdio.addr;
+ 	dev->phy.mode = dev->phy_dev->interface;
+ 	return 0;
+ }
+ 
+ static int emac_dt_phy_probe(struct emac_instance *dev)
+ {
+ 	struct device_node *np = dev->ofdev->dev.of_node;
+ 	struct device_node *phy_handle;
+ 	int res = 1;
+ 
+ 	phy_handle = of_parse_phandle(np, "phy-handle", 0);
+ 
+ 	if (phy_handle) {
+ 		res = emac_dt_mdio_probe(dev);
+ 		if (!res) {
+ 			res = emac_dt_phy_connect(dev, phy_handle);
+ 			if (res)
+ 				mdiobus_unregister(dev->mii_bus);
+ 		}
+ 	}
+ 
+ 	of_node_put(phy_handle);
+ 	return res;
+ }
+ 
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  static int emac_init_phy(struct emac_instance *dev)
  {
  	struct device_node *np = dev->ofdev->dev.of_node;
diff --cc drivers/net/ethernet/marvell/mv643xx_eth.c
index 96eef22501e0,2f427271a793..000000000000
--- a/drivers/net/ethernet/marvell/mv643xx_eth.c
+++ b/drivers/net/ethernet/marvell/mv643xx_eth.c
@@@ -1274,22 -1495,22 +1274,33 @@@ static const struct mv643xx_eth_stats m
  };
  
  static int
 -mv643xx_eth_get_link_ksettings_phy(struct mv643xx_eth_private *mp,
 -				   struct ethtool_link_ksettings *cmd)
 +mv643xx_eth_get_settings_phy(struct mv643xx_eth_private *mp,
 +			     struct ethtool_cmd *cmd)
  {
++<<<<<<< HEAD
 +	int err;
++=======
+ 	struct net_device *dev = mp->dev;
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
 -	phy_ethtool_ksettings_get(dev->phydev, cmd);
 +	err = phy_read_status(mp->phy);
 +	if (err == 0)
 +		err = phy_ethtool_gset(mp->phy, cmd);
  
  	/*
  	 * The MAC does not support 1000baseT_Half.
  	 */
++<<<<<<< HEAD
 +	cmd->supported &= ~SUPPORTED_1000baseT_Half;
 +	cmd->advertising &= ~ADVERTISED_1000baseT_Half;
++=======
+ 	linkmode_clear_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+ 			   cmd->link_modes.supported);
+ 	linkmode_clear_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+ 			   cmd->link_modes.advertising);
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
 -	return 0;
 +	return err;
  }
  
  static int
diff --cc drivers/net/ethernet/octeon/octeon_mgmt.c
index 93ac07aa1d17,5359c1021f42..000000000000
--- a/drivers/net/ethernet/octeon/octeon_mgmt.c
+++ b/drivers/net/ethernet/octeon/octeon_mgmt.c
@@@ -1101,10 -1078,13 +1101,18 @@@ static int octeon_mgmt_open(struct net_
  	}
  
  	/* Set the mode of the interface, RGMII/MII. */
 -	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) && netdev->phydev) {
 +	if (OCTEON_IS_MODEL(OCTEON_CN6XXX) && p->phydev) {
  		union cvmx_agl_prtx_ctl agl_prtx_ctl;
++<<<<<<< HEAD:drivers/net/ethernet/octeon/octeon_mgmt.c
 +		int rgmii_mode = (p->phydev->supported &
 +				  (SUPPORTED_1000baseT_Half | SUPPORTED_1000baseT_Full)) != 0;
++=======
+ 		int rgmii_mode =
+ 			(linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+ 					   netdev->phydev->supported) |
+ 			 linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+ 					   netdev->phydev->supported)) != 0;
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode):drivers/net/ethernet/cavium/octeon/octeon_mgmt.c
  
  		agl_prtx_ctl.u64 = cvmx_read_csr(p->agl_prt_ctl);
  		agl_prtx_ctl.s.mode = rgmii_mode ? 0 : 1;
diff --cc drivers/net/ethernet/realtek/r8169.c
index b884c766fbf3,56de045268f8..000000000000
--- a/drivers/net/ethernet/realtek/r8169.c
+++ b/drivers/net/ethernet/realtek/r8169.c
@@@ -6851,6 -6551,46 +6851,49 @@@ static void rtl8169_rx_missed(struct ne
  	RTL_W32(tp, RxMissed, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static void r8169_phylink_handler(struct net_device *ndev)
+ {
+ 	struct rtl8169_private *tp = netdev_priv(ndev);
+ 
+ 	if (netif_carrier_ok(ndev)) {
+ 		rtl_link_chg_patch(tp);
+ 		pm_request_resume(&tp->pci_dev->dev);
+ 	} else {
+ 		pm_runtime_idle(&tp->pci_dev->dev);
+ 	}
+ 
+ 	if (net_ratelimit())
+ 		phy_print_status(ndev->phydev);
+ }
+ 
+ static int r8169_phy_connect(struct rtl8169_private *tp)
+ {
+ 	struct phy_device *phydev = mdiobus_get_phy(tp->mii_bus, 0);
+ 	phy_interface_t phy_mode;
+ 	int ret;
+ 
+ 	phy_mode = tp->supports_gmii ? PHY_INTERFACE_MODE_GMII :
+ 		   PHY_INTERFACE_MODE_MII;
+ 
+ 	ret = phy_connect_direct(tp->dev, phydev, r8169_phylink_handler,
+ 				 phy_mode);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!tp->supports_gmii)
+ 		phy_set_max_speed(phydev, SPEED_100);
+ 
+ 	/* Ensure to advertise everything, incl. pause */
+ 	linkmode_copy(phydev->advertising, phydev->supported);
+ 
+ 	phy_attached_info(phydev);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  static void rtl8169_down(struct net_device *dev)
  {
  	struct rtl8169_private *tp = netdev_priv(dev);
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index c5f9cb85c8ef,d1f61c25d82b..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@@ -435,7 -452,20 +435,24 @@@ stmmac_get_pauseparam(struct net_devic
  
  	pause->rx_pause = 0;
  	pause->tx_pause = 0;
++<<<<<<< HEAD
 +	pause->autoneg = priv->phydev->autoneg;
++=======
+ 
+ 	if (priv->hw->pcs && !stmmac_pcs_get_adv_lp(priv, priv->ioaddr, &adv_lp)) {
+ 		pause->autoneg = 1;
+ 		if (!adv_lp.pause)
+ 			return;
+ 	} else {
+ 		if (!linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 				       netdev->phydev->supported) ||
+ 		    linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 				      netdev->phydev->supported))
+ 			return;
+ 	}
+ 
+ 	pause->autoneg = netdev->phydev->autoneg;
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	if (priv->flow_ctrl & FLOW_RX)
  		pause->rx_pause = 1;
@@@ -450,14 -479,22 +467,28 @@@ stmmac_set_pauseparam(struct net_devic
  		      struct ethtool_pauseparam *pause)
  {
  	struct stmmac_priv *priv = netdev_priv(netdev);
 -	u32 tx_cnt = priv->plat->tx_queues_to_use;
 -	struct phy_device *phy = netdev->phydev;
 +	struct phy_device *phy = priv->phydev;
  	int new_pause = FLOW_OFF;
 -	struct rgmii_adv adv_lp;
 +	int ret = 0;
 +
++<<<<<<< HEAD
 +	if (priv->pcs)	/* FIXME */
 +		return -EOPNOTSUPP;
  
 +	spin_lock(&priv->lock);
++=======
+ 	if (priv->hw->pcs && !stmmac_pcs_get_adv_lp(priv, priv->ioaddr, &adv_lp)) {
+ 		pause->autoneg = 1;
+ 		if (!adv_lp.pause)
+ 			return -EOPNOTSUPP;
+ 	} else {
+ 		if (!linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 				       phy->supported) ||
+ 		    linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 				      phy->supported))
+ 			return -EOPNOTSUPP;
+ 	}
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	if (pause->rx_pause)
  		new_pause |= FLOW_RX;
diff --cc drivers/net/ethernet/toshiba/tc35815.c
index c53ca489092f,c50a9772f4af..000000000000
--- a/drivers/net/ethernet/toshiba/tc35815.c
+++ b/drivers/net/ethernet/toshiba/tc35815.c
@@@ -608,24 -607,11 +608,29 @@@ static void tc_handle_link_change(struc
  
  static int tc_mii_probe(struct net_device *dev)
  {
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
  	struct tc35815_local *lp = netdev_priv(dev);
++<<<<<<< HEAD
 +	struct phy_device *phydev = NULL;
 +	int phy_addr;
 +	u32 dropmask;
++=======
+ 	struct phy_device *phydev;
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
 +
 +	/* find the first phy */
 +	for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {
 +		if (lp->mii_bus->phy_map[phy_addr]) {
 +			if (phydev) {
 +				printk(KERN_ERR "%s: multiple PHYs found\n",
 +				       dev->name);
 +				return -EINVAL;
 +			}
 +			phydev = lp->mii_bus->phy_map[phy_addr];
 +			break;
 +		}
 +	}
  
 -	phydev = phy_find_first(lp->mii_bus);
  	if (!phydev) {
  		printk(KERN_ERR "%s: no PHY found\n", dev->name);
  		return -ENODEV;
@@@ -639,24 -625,27 +644,44 @@@
  		printk(KERN_ERR "%s: Could not attach to PHY\n", dev->name);
  		return PTR_ERR(phydev);
  	}
 -
 -	phy_attached_info(phydev);
 +	printk(KERN_INFO "%s: attached PHY driver [%s] "
 +		"(mii_bus:phy_addr=%s, id=%x)\n",
 +		dev->name, phydev->drv->name, dev_name(&phydev->dev),
 +		phydev->phy_id);
  
  	/* mask with MAC supported features */
++<<<<<<< HEAD
 +	phydev->supported &= PHY_BASIC_FEATURES;
 +	dropmask = 0;
 +	if (options.speed == 10)
 +		dropmask |= SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full;
 +	else if (options.speed == 100)
 +		dropmask |= SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full;
 +	if (options.duplex == 1)
 +		dropmask |= SUPPORTED_10baseT_Full | SUPPORTED_100baseT_Full;
 +	else if (options.duplex == 2)
 +		dropmask |= SUPPORTED_10baseT_Half | SUPPORTED_100baseT_Half;
 +	phydev->supported &= ~dropmask;
 +	phydev->advertising = phydev->supported;
++=======
+ 	phy_set_max_speed(phydev, SPEED_100);
+ 	if (options.speed == 10) {
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, mask);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, mask);
+ 	} else if (options.speed == 100) {
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, mask);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, mask);
+ 	}
+ 	if (options.duplex == 1) {
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, mask);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, mask);
+ 	} else if (options.duplex == 2) {
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, mask);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, mask);
+ 	}
+ 	linkmode_and(phydev->supported, phydev->supported, mask);
+ 	linkmode_copy(phydev->advertising, phydev->supported);
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	lp->link = 0;
  	lp->speed = 0;
diff --cc drivers/net/phy/bcm63xx.c
index 84c7a39b1c65,a88dd14a25c0..000000000000
--- a/drivers/net/phy/bcm63xx.c
+++ b/drivers/net/phy/bcm63xx.c
@@@ -24,6 -42,9 +24,12 @@@ static int bcm63xx_config_init(struct p
  {
  	int reg, err;
  
++<<<<<<< HEAD
++=======
+ 	/* ASYM_PAUSE bit is marked RO in datasheet, so don't cheat */
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->supported);
+ 
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  	reg = phy_read(phydev, MII_BCM63XX_IR);
  	if (reg < 0)
  		return reg;
diff --cc drivers/net/phy/fixed_phy.c
index 82314743f4cc,f7fb62712cd8..000000000000
--- a/drivers/net/phy/fixed_phy.c
+++ b/drivers/net/phy/fixed_phy.c
@@@ -310,8 -208,39 +310,34 @@@ struct phy_device *fixed_phy_register(u
  		return ERR_PTR(-EINVAL);
  	}
  
 -	/* propagate the fixed link values to struct phy_device */
 -	phy->link = status->link;
 -	if (status->link) {
 -		phy->speed = status->speed;
 -		phy->duplex = status->duplex;
 -		phy->pause = status->pause;
 -		phy->asym_pause = status->asym_pause;
 -	}
 -
  	of_node_get(np);
++<<<<<<< HEAD
 +	phy->dev.of_node = np;
++=======
+ 	phy->mdio.dev.of_node = np;
+ 	phy->is_pseudo_fixed_link = true;
+ 
+ 	switch (status->speed) {
+ 	case SPEED_1000:
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+ 				 phy->supported);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+ 				 phy->supported);
+ 		/* fall through */
+ 	case SPEED_100:
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+ 				 phy->supported);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+ 				 phy->supported);
+ 		/* fall through */
+ 	case SPEED_10:
+ 	default:
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+ 				 phy->supported);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+ 				 phy->supported);
+ 	}
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	ret = phy_device_register(phy);
  	if (ret) {
diff --cc drivers/net/phy/marvell.c
index e84c049c80c3,96f33831ea99..000000000000
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@@ -410,6 -490,312 +410,315 @@@ static int m88e1318_config_aneg(struct 
  	return m88e1121_config_aneg(phydev);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * linkmode_adv_to_fiber_adv_t
+  * @advertise: the linkmode advertisement settings
+  *
+  * A small helper function that translates linkmode advertisement
+  * settings to phy autonegotiation advertisements for the MII_ADV
+  * register for fiber link.
+  */
+ static inline u32 linkmode_adv_to_fiber_adv_t(unsigned long *advertise)
+ {
+ 	u32 result = 0;
+ 
+ 	if (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT, advertise))
+ 		result |= ADVERTISE_FIBER_1000HALF;
+ 	if (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, advertise))
+ 		result |= ADVERTISE_FIBER_1000FULL;
+ 
+ 	if (linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, advertise) &&
+ 	    linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT, advertise))
+ 		result |= LPA_PAUSE_ASYM_FIBER;
+ 	else if (linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT, advertise))
+ 		result |= (ADVERTISE_PAUSE_FIBER
+ 			   & (~ADVERTISE_PAUSE_ASYM_FIBER));
+ 
+ 	return result;
+ }
+ 
+ /**
+  * marvell_config_aneg_fiber - restart auto-negotiation or write BMCR
+  * @phydev: target phy_device struct
+  *
+  * Description: If auto-negotiation is enabled, we configure the
+  *   advertising, and then restart auto-negotiation.  If it is not
+  *   enabled, then we write the BMCR. Adapted for fiber link in
+  *   some Marvell's devices.
+  */
+ static int marvell_config_aneg_fiber(struct phy_device *phydev)
+ {
+ 	int changed = 0;
+ 	int err;
+ 	int adv, oldadv;
+ 
+ 	if (phydev->autoneg != AUTONEG_ENABLE)
+ 		return genphy_setup_forced(phydev);
+ 
+ 	/* Only allow advertising what this PHY supports */
+ 	linkmode_and(phydev->advertising, phydev->advertising,
+ 		     phydev->supported);
+ 
+ 	/* Setup fiber advertisement */
+ 	adv = phy_read(phydev, MII_ADVERTISE);
+ 	if (adv < 0)
+ 		return adv;
+ 
+ 	oldadv = adv;
+ 	adv &= ~(ADVERTISE_FIBER_1000HALF | ADVERTISE_FIBER_1000FULL
+ 		| LPA_PAUSE_FIBER);
+ 	adv |= linkmode_adv_to_fiber_adv_t(phydev->advertising);
+ 
+ 	if (adv != oldadv) {
+ 		err = phy_write(phydev, MII_ADVERTISE, adv);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		changed = 1;
+ 	}
+ 
+ 	if (changed == 0) {
+ 		/* Advertisement hasn't changed, but maybe aneg was never on to
+ 		 * begin with?	Or maybe phy was isolated?
+ 		 */
+ 		int ctl = phy_read(phydev, MII_BMCR);
+ 
+ 		if (ctl < 0)
+ 			return ctl;
+ 
+ 		if (!(ctl & BMCR_ANENABLE) || (ctl & BMCR_ISOLATE))
+ 			changed = 1; /* do restart aneg */
+ 	}
+ 
+ 	/* Only restart aneg if we are advertising something different
+ 	 * than we were before.
+ 	 */
+ 	if (changed > 0)
+ 		changed = genphy_restart_aneg(phydev);
+ 
+ 	return changed;
+ }
+ 
+ static int m88e1510_config_aneg(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 	if (err < 0)
+ 		goto error;
+ 
+ 	/* Configure the copper link first */
+ 	err = m88e1318_config_aneg(phydev);
+ 	if (err < 0)
+ 		goto error;
+ 
+ 	/* Do not touch the fiber page if we're in copper->sgmii mode */
+ 	if (phydev->interface == PHY_INTERFACE_MODE_SGMII)
+ 		return 0;
+ 
+ 	/* Then the fiber link */
+ 	err = marvell_set_page(phydev, MII_MARVELL_FIBER_PAGE);
+ 	if (err < 0)
+ 		goto error;
+ 
+ 	err = marvell_config_aneg_fiber(phydev);
+ 	if (err < 0)
+ 		goto error;
+ 
+ 	return marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 
+ error:
+ 	marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 	return err;
+ }
+ 
+ static void marvell_config_led(struct phy_device *phydev)
+ {
+ 	u16 def_config;
+ 	int err;
+ 
+ 	switch (MARVELL_PHY_FAMILY_ID(phydev->phy_id)) {
+ 	/* Default PHY LED config: LED[0] .. Link, LED[1] .. Activity */
+ 	case MARVELL_PHY_FAMILY_ID(MARVELL_PHY_ID_88E1121R):
+ 	case MARVELL_PHY_FAMILY_ID(MARVELL_PHY_ID_88E1318S):
+ 		def_config = MII_88E1121_PHY_LED_DEF;
+ 		break;
+ 	/* Default PHY LED config:
+ 	 * LED[0] .. 1000Mbps Link
+ 	 * LED[1] .. 100Mbps Link
+ 	 * LED[2] .. Blink, Activity
+ 	 */
+ 	case MARVELL_PHY_FAMILY_ID(MARVELL_PHY_ID_88E1510):
+ 		def_config = MII_88E1510_PHY_LED_DEF;
+ 		break;
+ 	default:
+ 		return;
+ 	}
+ 
+ 	err = phy_write_paged(phydev, MII_MARVELL_LED_PAGE, MII_PHY_LED_CTRL,
+ 			      def_config);
+ 	if (err < 0)
+ 		phydev_warn(phydev, "Fail to config marvell phy LED.\n");
+ }
+ 
+ static int marvell_config_init(struct phy_device *phydev)
+ {
+ 	/* Set defalut LED */
+ 	marvell_config_led(phydev);
+ 
+ 	/* Set registers from marvell,reg-init DT property */
+ 	return marvell_of_reg_init(phydev);
+ }
+ 
+ static int m88e1116r_config_init(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = genphy_soft_reset(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	msleep(500);
+ 
+ 	err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = marvell_set_polarity(phydev, phydev->mdix_ctrl);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = marvell_set_downshift(phydev, true, 8);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (phy_interface_is_rgmii(phydev)) {
+ 		err = m88e1121_config_aneg_rgmii_delays(phydev);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	err = genphy_soft_reset(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	return marvell_config_init(phydev);
+ }
+ 
+ static int m88e3016_config_init(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	/* Enable Scrambler and Auto-Crossover */
+ 	ret = phy_modify(phydev, MII_88E3016_PHY_SPEC_CTRL,
+ 			 MII_88E3016_DISABLE_SCRAMBLER,
+ 			 MII_88E3016_AUTO_MDIX_CROSSOVER);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return marvell_config_init(phydev);
+ }
+ 
+ static int m88e1111_config_init_hwcfg_mode(struct phy_device *phydev,
+ 					   u16 mode,
+ 					   int fibre_copper_auto)
+ {
+ 	if (fibre_copper_auto)
+ 		mode |= MII_M1111_HWCFG_FIBER_COPPER_AUTO;
+ 
+ 	return phy_modify(phydev, MII_M1111_PHY_EXT_SR,
+ 			  MII_M1111_HWCFG_MODE_MASK |
+ 			  MII_M1111_HWCFG_FIBER_COPPER_AUTO |
+ 			  MII_M1111_HWCFG_FIBER_COPPER_RES,
+ 			  mode);
+ }
+ 
+ static int m88e1111_config_init_rgmii_delays(struct phy_device *phydev)
+ {
+ 	int delay;
+ 
+ 	if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {
+ 		delay = MII_M1111_RGMII_RX_DELAY | MII_M1111_RGMII_TX_DELAY;
+ 	} else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID) {
+ 		delay = MII_M1111_RGMII_RX_DELAY;
+ 	} else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID) {
+ 		delay = MII_M1111_RGMII_TX_DELAY;
+ 	} else {
+ 		delay = 0;
+ 	}
+ 
+ 	return phy_modify(phydev, MII_M1111_PHY_EXT_CR,
+ 			  MII_M1111_RGMII_RX_DELAY | MII_M1111_RGMII_TX_DELAY,
+ 			  delay);
+ }
+ 
+ static int m88e1111_config_init_rgmii(struct phy_device *phydev)
+ {
+ 	int temp;
+ 	int err;
+ 
+ 	err = m88e1111_config_init_rgmii_delays(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	temp = phy_read(phydev, MII_M1111_PHY_EXT_SR);
+ 	if (temp < 0)
+ 		return temp;
+ 
+ 	temp &= ~(MII_M1111_HWCFG_MODE_MASK);
+ 
+ 	if (temp & MII_M1111_HWCFG_FIBER_COPPER_RES)
+ 		temp |= MII_M1111_HWCFG_MODE_FIBER_RGMII;
+ 	else
+ 		temp |= MII_M1111_HWCFG_MODE_COPPER_RGMII;
+ 
+ 	return phy_write(phydev, MII_M1111_PHY_EXT_SR, temp);
+ }
+ 
+ static int m88e1111_config_init_sgmii(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = m88e1111_config_init_hwcfg_mode(
+ 		phydev,
+ 		MII_M1111_HWCFG_MODE_SGMII_NO_CLK,
+ 		MII_M1111_HWCFG_FIBER_COPPER_AUTO);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/* make sure copper is selected */
+ 	return marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ }
+ 
+ static int m88e1111_config_init_rtbi(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = m88e1111_config_init_rgmii_delays(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = m88e1111_config_init_hwcfg_mode(
+ 		phydev,
+ 		MII_M1111_HWCFG_MODE_RTBI,
+ 		MII_M1111_HWCFG_FIBER_COPPER_AUTO);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/* soft reset */
+ 	err = genphy_soft_reset(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	return m88e1111_config_init_hwcfg_mode(
+ 		phydev,
+ 		MII_M1111_HWCFG_MODE_RTBI,
+ 		MII_M1111_HWCFG_FIBER_COPPER_AUTO);
+ }
+ 
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  static int m88e1111_config_init(struct phy_device *phydev)
  {
  	int err;
@@@ -508,7 -822,74 +817,78 @@@
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
 +	return phy_write(phydev, MII_BMCR, BMCR_RESET);
++=======
+ 	return genphy_soft_reset(phydev);
+ }
+ 
+ static int m88e1318_config_init(struct phy_device *phydev)
+ {
+ 	if (phy_interrupt_is_valid(phydev)) {
+ 		int err = phy_modify_paged(
+ 			phydev, MII_MARVELL_LED_PAGE,
+ 			MII_88E1318S_PHY_LED_TCR,
+ 			MII_88E1318S_PHY_LED_TCR_FORCE_INT,
+ 			MII_88E1318S_PHY_LED_TCR_INTn_ENABLE |
+ 			MII_88E1318S_PHY_LED_TCR_INT_ACTIVE_LOW);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	return marvell_config_init(phydev);
+ }
+ 
+ static int m88e1510_config_init(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	/* SGMII-to-Copper mode initialization */
+ 	if (phydev->interface == PHY_INTERFACE_MODE_SGMII) {
+ 		u32 pause;
+ 
+ 		/* Select page 18 */
+ 		err = marvell_set_page(phydev, 18);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* In reg 20, write MODE[2:0] = 0x1 (SGMII to Copper) */
+ 		err = phy_modify(phydev, MII_88E1510_GEN_CTRL_REG_1,
+ 				 MII_88E1510_GEN_CTRL_REG_1_MODE_MASK,
+ 				 MII_88E1510_GEN_CTRL_REG_1_MODE_SGMII);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* PHY reset is necessary after changing MODE[2:0] */
+ 		err = phy_modify(phydev, MII_88E1510_GEN_CTRL_REG_1, 0,
+ 				 MII_88E1510_GEN_CTRL_REG_1_RESET);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* Reset page selection */
+ 		err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* There appears to be a bug in the 88e1512 when used in
+ 		 * SGMII to copper mode, where the AN advertisement register
+ 		 * clears the pause bits each time a negotiation occurs.
+ 		 * This means we can never be truely sure what was advertised,
+ 		 * so disable Pause support.
+ 		 */
+ 		pause = SUPPORTED_Pause | SUPPORTED_Asym_Pause;
+ 		linkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 				   phydev->supported);
+ 		linkmode_clear_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 				   phydev->supported);
+ 		linkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 				   phydev->advertising);
+ 		linkmode_clear_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 				   phydev->advertising);
+ 	}
+ 
+ 	return m88e1318_config_init(phydev);
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  }
  
  static int m88e1118_config_aneg(struct phy_device *phydev)
@@@ -681,69 -1219,137 +1061,164 @@@ static int marvell_read_status(struct p
  	if (err)
  		return err;
  
 -	if (phydev->autoneg == AUTONEG_ENABLE)
 -		err = marvell_read_status_page_an(phydev, fiber);
 -	else
 -		err = marvell_read_status_page_fixed(phydev);
 +	if (AUTONEG_ENABLE == phydev->autoneg) {
 +		status = phy_read(phydev, MII_M1011_PHY_STATUS);
 +		if (status < 0)
 +			return status;
  
 -	return err;
 -}
 +		lpa = phy_read(phydev, MII_LPA);
 +		if (lpa < 0)
 +			return lpa;
  
 -/* marvell_read_status
 - *
 - * Some Marvell's phys have two modes: fiber and copper.
 - * Both need status checked.
 - * Description:
 - *   First, check the fiber link and status.
 - *   If the fiber link is down, check the copper link and status which
 - *   will be the default value if both link are down.
 - */
 -static int marvell_read_status(struct phy_device *phydev)
 -{
 -	int err;
 +		adv = phy_read(phydev, MII_ADVERTISE);
 +		if (adv < 0)
 +			return adv;
  
++<<<<<<< HEAD
 +		lpa &= adv;
++=======
+ 	/* Check the fiber mode first */
+ 	if (linkmode_test_bit(ETHTOOL_LINK_MODE_FIBRE_BIT,
+ 			      phydev->supported) &&
+ 	    phydev->interface != PHY_INTERFACE_MODE_SGMII) {
+ 		err = marvell_set_page(phydev, MII_MARVELL_FIBER_PAGE);
+ 		if (err < 0)
+ 			goto error;
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
 -		err = marvell_read_status_page(phydev, MII_MARVELL_FIBER_PAGE);
 -		if (err < 0)
 -			goto error;
 +		if (status & MII_M1011_PHY_STATUS_FULLDUPLEX)
 +			phydev->duplex = DUPLEX_FULL;
 +		else
 +			phydev->duplex = DUPLEX_HALF;
  
 -		/* If the fiber link is up, it is the selected and
 -		 * used link. In this case, we need to stay in the
 -		 * fiber page. Please to be careful about that, avoid
 -		 * to restore Copper page in other functions which
 -		 * could break the behaviour for some fiber phy like
 -		 * 88E1512.
 -		 */
 -		if (phydev->link)
 -			return 0;
 +		status = status & MII_M1011_PHY_STATUS_SPD_MASK;
 +		phydev->pause = phydev->asym_pause = 0;
  
 -		/* If fiber link is down, check and save copper mode state */
 -		err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
 -		if (err < 0)
 -			goto error;
 +		switch (status) {
 +		case MII_M1011_PHY_STATUS_1000:
 +			phydev->speed = SPEED_1000;
 +			break;
 +
 +		case MII_M1011_PHY_STATUS_100:
 +			phydev->speed = SPEED_100;
 +			break;
 +
 +		default:
 +			phydev->speed = SPEED_10;
 +			break;
 +		}
 +
 +		if (phydev->duplex == DUPLEX_FULL) {
 +			phydev->pause = lpa & LPA_PAUSE_CAP ? 1 : 0;
 +			phydev->asym_pause = lpa & LPA_PAUSE_ASYM ? 1 : 0;
 +		}
 +	} else {
 +		int bmcr = phy_read(phydev, MII_BMCR);
 +
 +		if (bmcr < 0)
 +			return bmcr;
 +
 +		if (bmcr & BMCR_FULLDPLX)
 +			phydev->duplex = DUPLEX_FULL;
 +		else
 +			phydev->duplex = DUPLEX_HALF;
 +
 +		if (bmcr & BMCR_SPEED1000)
 +			phydev->speed = SPEED_1000;
 +		else if (bmcr & BMCR_SPEED100)
 +			phydev->speed = SPEED_100;
 +		else
 +			phydev->speed = SPEED_10;
 +
 +		phydev->pause = phydev->asym_pause = 0;
  	}
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	return marvell_read_status_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 
+ error:
+ 	marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 	return err;
+ }
+ 
+ /* marvell_suspend
+  *
+  * Some Marvell's phys have two modes: fiber and copper.
+  * Both need to be suspended
+  */
+ static int marvell_suspend(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	/* Suspend the fiber mode first */
+ 	if (!linkmode_test_bit(ETHTOOL_LINK_MODE_FIBRE_BIT,
+ 			       phydev->supported)) {
+ 		err = marvell_set_page(phydev, MII_MARVELL_FIBER_PAGE);
+ 		if (err < 0)
+ 			goto error;
+ 
+ 		/* With the page set, use the generic suspend */
+ 		err = genphy_suspend(phydev);
+ 		if (err < 0)
+ 			goto error;
+ 
+ 		/* Then, the copper link */
+ 		err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 		if (err < 0)
+ 			goto error;
+ 	}
+ 
+ 	/* With the page set, use the generic suspend */
+ 	return genphy_suspend(phydev);
+ 
+ error:
+ 	marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 	return err;
+ }
+ 
+ /* marvell_resume
+  *
+  * Some Marvell's phys have two modes: fiber and copper.
+  * Both need to be resumed
+  */
+ static int marvell_resume(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	/* Resume the fiber mode first */
+ 	if (!linkmode_test_bit(ETHTOOL_LINK_MODE_FIBRE_BIT,
+ 			       phydev->supported)) {
+ 		err = marvell_set_page(phydev, MII_MARVELL_FIBER_PAGE);
+ 		if (err < 0)
+ 			goto error;
+ 
+ 		/* With the page set, use the generic resume */
+ 		err = genphy_resume(phydev);
+ 		if (err < 0)
+ 			goto error;
+ 
+ 		/* Then, the copper link */
+ 		err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 		if (err < 0)
+ 			goto error;
+ 	}
+ 
+ 	/* With the page set, use the generic resume */
+ 	return genphy_resume(phydev);
+ 
+ error:
+ 	marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 	return err;
+ }
+ 
+ static int marvell_aneg_done(struct phy_device *phydev)
+ {
+ 	int retval = phy_read(phydev, MII_M1011_PHY_STATUS);
+ 
+ 	return (retval < 0) ? retval : (retval & MII_M1011_PHY_STATUS_RESOLVED);
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  }
  
  static int m88e1121_did_interrupt(struct phy_device *phydev)
@@@ -828,34 -1445,515 +1303,495 @@@ static int m88e1318_set_wol(struct phy_
  				((phydev->attached_dev->dev_addr[1] << 8) |
  				 phydev->attached_dev->dev_addr[0]));
  		if (err < 0)
 -			goto error;
 +			return err;
  
  		/* Clear WOL status and enable magic packet matching */
 -		err = __phy_modify(phydev, MII_88E1318S_PHY_WOL_CTRL, 0,
 -				   MII_88E1318S_PHY_WOL_CTRL_CLEAR_WOL_STATUS |
 -				   MII_88E1318S_PHY_WOL_CTRL_MAGIC_PACKET_MATCH_ENABLE);
 +		temp = phy_read(phydev, MII_88E1318S_PHY_WOL_CTRL);
 +		temp |= MII_88E1318S_PHY_WOL_CTRL_CLEAR_WOL_STATUS;
 +		temp |= MII_88E1318S_PHY_WOL_CTRL_MAGIC_PACKET_MATCH_ENABLE;
 +		err = phy_write(phydev, MII_88E1318S_PHY_WOL_CTRL, temp);
  		if (err < 0)
 -			goto error;
 +			return err;
  	} else {
 -		err = marvell_write_page(phydev, MII_MARVELL_WOL_PAGE);
 +		err = phy_write(phydev, MII_MARVELL_PHY_PAGE,
 +				MII_88E1318S_PHY_WOL_PAGE);
  		if (err < 0)
 -			goto error;
 +			return err;
  
  		/* Clear WOL status and disable magic packet matching */
 -		err = __phy_modify(phydev, MII_88E1318S_PHY_WOL_CTRL,
 -				   MII_88E1318S_PHY_WOL_CTRL_MAGIC_PACKET_MATCH_ENABLE,
 -				   MII_88E1318S_PHY_WOL_CTRL_CLEAR_WOL_STATUS);
 +		temp = phy_read(phydev, MII_88E1318S_PHY_WOL_CTRL);
 +		temp |= MII_88E1318S_PHY_WOL_CTRL_CLEAR_WOL_STATUS;
 +		temp &= ~MII_88E1318S_PHY_WOL_CTRL_MAGIC_PACKET_MATCH_ENABLE;
 +		err = phy_write(phydev, MII_88E1318S_PHY_WOL_CTRL, temp);
  		if (err < 0)
 -			goto error;
 +			return err;
  	}
  
++<<<<<<< HEAD
 +	err = phy_write(phydev, MII_MARVELL_PHY_PAGE, oldpage);
 +	if (err < 0)
++=======
+ error:
+ 	return phy_restore_page(phydev, oldpage, err);
+ }
+ 
+ static int marvell_get_sset_count(struct phy_device *phydev)
+ {
+ 	if (linkmode_test_bit(ETHTOOL_LINK_MODE_FIBRE_BIT,
+ 			      phydev->supported))
+ 		return ARRAY_SIZE(marvell_hw_stats);
+ 	else
+ 		return ARRAY_SIZE(marvell_hw_stats) - NB_FIBER_STATS;
+ }
+ 
+ static void marvell_get_strings(struct phy_device *phydev, u8 *data)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(marvell_hw_stats); i++) {
+ 		strlcpy(data + i * ETH_GSTRING_LEN,
+ 			marvell_hw_stats[i].string, ETH_GSTRING_LEN);
+ 	}
+ }
+ 
+ static u64 marvell_get_stat(struct phy_device *phydev, int i)
+ {
+ 	struct marvell_hw_stat stat = marvell_hw_stats[i];
+ 	struct marvell_priv *priv = phydev->priv;
+ 	int val;
+ 	u64 ret;
+ 
+ 	val = phy_read_paged(phydev, stat.page, stat.reg);
+ 	if (val < 0) {
+ 		ret = U64_MAX;
+ 	} else {
+ 		val = val & ((1 << stat.bits) - 1);
+ 		priv->stats[i] += val;
+ 		ret = priv->stats[i];
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static void marvell_get_stats(struct phy_device *phydev,
+ 			      struct ethtool_stats *stats, u64 *data)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(marvell_hw_stats); i++)
+ 		data[i] = marvell_get_stat(phydev, i);
+ }
+ 
+ #ifdef CONFIG_HWMON
+ static int m88e1121_get_temp(struct phy_device *phydev, long *temp)
+ {
+ 	int oldpage;
+ 	int ret = 0;
+ 	int val;
+ 
+ 	*temp = 0;
+ 
+ 	oldpage = phy_select_page(phydev, MII_MARVELL_MISC_TEST_PAGE);
+ 	if (oldpage < 0)
+ 		goto error;
+ 
+ 	/* Enable temperature sensor */
+ 	ret = __phy_read(phydev, MII_88E1121_MISC_TEST);
+ 	if (ret < 0)
+ 		goto error;
+ 
+ 	ret = __phy_write(phydev, MII_88E1121_MISC_TEST,
+ 			  ret | MII_88E1121_MISC_TEST_TEMP_SENSOR_EN);
+ 	if (ret < 0)
+ 		goto error;
+ 
+ 	/* Wait for temperature to stabilize */
+ 	usleep_range(10000, 12000);
+ 
+ 	val = __phy_read(phydev, MII_88E1121_MISC_TEST);
+ 	if (val < 0) {
+ 		ret = val;
+ 		goto error;
+ 	}
+ 
+ 	/* Disable temperature sensor */
+ 	ret = __phy_write(phydev, MII_88E1121_MISC_TEST,
+ 			  ret & ~MII_88E1121_MISC_TEST_TEMP_SENSOR_EN);
+ 	if (ret < 0)
+ 		goto error;
+ 
+ 	*temp = ((val & MII_88E1121_MISC_TEST_TEMP_MASK) - 5) * 5000;
+ 
+ error:
+ 	return phy_restore_page(phydev, oldpage, ret);
+ }
+ 
+ static int m88e1121_hwmon_read(struct device *dev,
+ 			       enum hwmon_sensor_types type,
+ 			       u32 attr, int channel, long *temp)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	int err;
+ 
+ 	switch (attr) {
+ 	case hwmon_temp_input:
+ 		err = m88e1121_get_temp(phydev, temp);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static umode_t m88e1121_hwmon_is_visible(const void *data,
+ 					 enum hwmon_sensor_types type,
+ 					 u32 attr, int channel)
+ {
+ 	if (type != hwmon_temp)
+ 		return 0;
+ 
+ 	switch (attr) {
+ 	case hwmon_temp_input:
+ 		return 0444;
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ static u32 m88e1121_hwmon_chip_config[] = {
+ 	HWMON_C_REGISTER_TZ,
+ 	0
+ };
+ 
+ static const struct hwmon_channel_info m88e1121_hwmon_chip = {
+ 	.type = hwmon_chip,
+ 	.config = m88e1121_hwmon_chip_config,
+ };
+ 
+ static u32 m88e1121_hwmon_temp_config[] = {
+ 	HWMON_T_INPUT,
+ 	0
+ };
+ 
+ static const struct hwmon_channel_info m88e1121_hwmon_temp = {
+ 	.type = hwmon_temp,
+ 	.config = m88e1121_hwmon_temp_config,
+ };
+ 
+ static const struct hwmon_channel_info *m88e1121_hwmon_info[] = {
+ 	&m88e1121_hwmon_chip,
+ 	&m88e1121_hwmon_temp,
+ 	NULL
+ };
+ 
+ static const struct hwmon_ops m88e1121_hwmon_hwmon_ops = {
+ 	.is_visible = m88e1121_hwmon_is_visible,
+ 	.read = m88e1121_hwmon_read,
+ };
+ 
+ static const struct hwmon_chip_info m88e1121_hwmon_chip_info = {
+ 	.ops = &m88e1121_hwmon_hwmon_ops,
+ 	.info = m88e1121_hwmon_info,
+ };
+ 
+ static int m88e1510_get_temp(struct phy_device *phydev, long *temp)
+ {
+ 	int ret;
+ 
+ 	*temp = 0;
+ 
+ 	ret = phy_read_paged(phydev, MII_MARVELL_MISC_TEST_PAGE,
+ 			     MII_88E1510_TEMP_SENSOR);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	*temp = ((ret & MII_88E1510_TEMP_SENSOR_MASK) - 25) * 1000;
+ 
+ 	return 0;
+ }
+ 
+ static int m88e1510_get_temp_critical(struct phy_device *phydev, long *temp)
+ {
+ 	int ret;
+ 
+ 	*temp = 0;
+ 
+ 	ret = phy_read_paged(phydev, MII_MARVELL_MISC_TEST_PAGE,
+ 			     MII_88E1121_MISC_TEST);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	*temp = (((ret & MII_88E1510_MISC_TEST_TEMP_THRESHOLD_MASK) >>
+ 		  MII_88E1510_MISC_TEST_TEMP_THRESHOLD_SHIFT) * 5) - 25;
+ 	/* convert to mC */
+ 	*temp *= 1000;
+ 
+ 	return 0;
+ }
+ 
+ static int m88e1510_set_temp_critical(struct phy_device *phydev, long temp)
+ {
+ 	temp = temp / 1000;
+ 	temp = clamp_val(DIV_ROUND_CLOSEST(temp, 5) + 5, 0, 0x1f);
+ 
+ 	return phy_modify_paged(phydev, MII_MARVELL_MISC_TEST_PAGE,
+ 				MII_88E1121_MISC_TEST,
+ 				MII_88E1510_MISC_TEST_TEMP_THRESHOLD_MASK,
+ 				temp << MII_88E1510_MISC_TEST_TEMP_THRESHOLD_SHIFT);
+ }
+ 
+ static int m88e1510_get_temp_alarm(struct phy_device *phydev, long *alarm)
+ {
+ 	int ret;
+ 
+ 	*alarm = false;
+ 
+ 	ret = phy_read_paged(phydev, MII_MARVELL_MISC_TEST_PAGE,
+ 			     MII_88E1121_MISC_TEST);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	*alarm = !!(ret & MII_88E1510_MISC_TEST_TEMP_IRQ);
+ 
+ 	return 0;
+ }
+ 
+ static int m88e1510_hwmon_read(struct device *dev,
+ 			       enum hwmon_sensor_types type,
+ 			       u32 attr, int channel, long *temp)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	int err;
+ 
+ 	switch (attr) {
+ 	case hwmon_temp_input:
+ 		err = m88e1510_get_temp(phydev, temp);
+ 		break;
+ 	case hwmon_temp_crit:
+ 		err = m88e1510_get_temp_critical(phydev, temp);
+ 		break;
+ 	case hwmon_temp_max_alarm:
+ 		err = m88e1510_get_temp_alarm(phydev, temp);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int m88e1510_hwmon_write(struct device *dev,
+ 				enum hwmon_sensor_types type,
+ 				u32 attr, int channel, long temp)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	int err;
+ 
+ 	switch (attr) {
+ 	case hwmon_temp_crit:
+ 		err = m88e1510_set_temp_critical(phydev, temp);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 	return err;
+ }
+ 
+ static umode_t m88e1510_hwmon_is_visible(const void *data,
+ 					 enum hwmon_sensor_types type,
+ 					 u32 attr, int channel)
+ {
+ 	if (type != hwmon_temp)
+ 		return 0;
+ 
+ 	switch (attr) {
+ 	case hwmon_temp_input:
+ 	case hwmon_temp_max_alarm:
+ 		return 0444;
+ 	case hwmon_temp_crit:
+ 		return 0644;
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ static u32 m88e1510_hwmon_temp_config[] = {
+ 	HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_MAX_ALARM,
+ 	0
+ };
+ 
+ static const struct hwmon_channel_info m88e1510_hwmon_temp = {
+ 	.type = hwmon_temp,
+ 	.config = m88e1510_hwmon_temp_config,
+ };
+ 
+ static const struct hwmon_channel_info *m88e1510_hwmon_info[] = {
+ 	&m88e1121_hwmon_chip,
+ 	&m88e1510_hwmon_temp,
+ 	NULL
+ };
+ 
+ static const struct hwmon_ops m88e1510_hwmon_hwmon_ops = {
+ 	.is_visible = m88e1510_hwmon_is_visible,
+ 	.read = m88e1510_hwmon_read,
+ 	.write = m88e1510_hwmon_write,
+ };
+ 
+ static const struct hwmon_chip_info m88e1510_hwmon_chip_info = {
+ 	.ops = &m88e1510_hwmon_hwmon_ops,
+ 	.info = m88e1510_hwmon_info,
+ };
+ 
+ static int m88e6390_get_temp(struct phy_device *phydev, long *temp)
+ {
+ 	int sum = 0;
+ 	int oldpage;
+ 	int ret = 0;
+ 	int i;
+ 
+ 	*temp = 0;
+ 
+ 	oldpage = phy_select_page(phydev, MII_MARVELL_MISC_TEST_PAGE);
+ 	if (oldpage < 0)
+ 		goto error;
+ 
+ 	/* Enable temperature sensor */
+ 	ret = __phy_read(phydev, MII_88E6390_MISC_TEST);
+ 	if (ret < 0)
+ 		goto error;
+ 
+ 	ret = ret & ~MII_88E6390_MISC_TEST_SAMPLE_MASK;
+ 	ret |= MII_88E6390_MISC_TEST_SAMPLE_ENABLE |
+ 		MII_88E6390_MISC_TEST_SAMPLE_1S;
+ 
+ 	ret = __phy_write(phydev, MII_88E6390_MISC_TEST, ret);
+ 	if (ret < 0)
+ 		goto error;
+ 
+ 	/* Wait for temperature to stabilize */
+ 	usleep_range(10000, 12000);
+ 
+ 	/* Reading the temperature sense has an errata. You need to read
+ 	 * a number of times and take an average.
+ 	 */
+ 	for (i = 0; i < MII_88E6390_TEMP_SENSOR_SAMPLES; i++) {
+ 		ret = __phy_read(phydev, MII_88E6390_TEMP_SENSOR);
+ 		if (ret < 0)
+ 			goto error;
+ 		sum += ret & MII_88E6390_TEMP_SENSOR_MASK;
+ 	}
+ 
+ 	sum /= MII_88E6390_TEMP_SENSOR_SAMPLES;
+ 	*temp = (sum  - 75) * 1000;
+ 
+ 	/* Disable temperature sensor */
+ 	ret = __phy_read(phydev, MII_88E6390_MISC_TEST);
+ 	if (ret < 0)
+ 		goto error;
+ 
+ 	ret = ret & ~MII_88E6390_MISC_TEST_SAMPLE_MASK;
+ 	ret |= MII_88E6390_MISC_TEST_SAMPLE_DISABLE;
+ 
+ 	ret = __phy_write(phydev, MII_88E6390_MISC_TEST, ret);
+ 
+ error:
+ 	phy_restore_page(phydev, oldpage, ret);
+ 
+ 	return ret;
+ }
+ 
+ static int m88e6390_hwmon_read(struct device *dev,
+ 			       enum hwmon_sensor_types type,
+ 			       u32 attr, int channel, long *temp)
+ {
+ 	struct phy_device *phydev = dev_get_drvdata(dev);
+ 	int err;
+ 
+ 	switch (attr) {
+ 	case hwmon_temp_input:
+ 		err = m88e6390_get_temp(phydev, temp);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static umode_t m88e6390_hwmon_is_visible(const void *data,
+ 					 enum hwmon_sensor_types type,
+ 					 u32 attr, int channel)
+ {
+ 	if (type != hwmon_temp)
+ 		return 0;
+ 
+ 	switch (attr) {
+ 	case hwmon_temp_input:
+ 		return 0444;
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ static u32 m88e6390_hwmon_temp_config[] = {
+ 	HWMON_T_INPUT,
+ 	0
+ };
+ 
+ static const struct hwmon_channel_info m88e6390_hwmon_temp = {
+ 	.type = hwmon_temp,
+ 	.config = m88e6390_hwmon_temp_config,
+ };
+ 
+ static const struct hwmon_channel_info *m88e6390_hwmon_info[] = {
+ 	&m88e1121_hwmon_chip,
+ 	&m88e6390_hwmon_temp,
+ 	NULL
+ };
+ 
+ static const struct hwmon_ops m88e6390_hwmon_hwmon_ops = {
+ 	.is_visible = m88e6390_hwmon_is_visible,
+ 	.read = m88e6390_hwmon_read,
+ };
+ 
+ static const struct hwmon_chip_info m88e6390_hwmon_chip_info = {
+ 	.ops = &m88e6390_hwmon_hwmon_ops,
+ 	.info = m88e6390_hwmon_info,
+ };
+ 
+ static int marvell_hwmon_name(struct phy_device *phydev)
+ {
+ 	struct marvell_priv *priv = phydev->priv;
+ 	struct device *dev = &phydev->mdio.dev;
+ 	const char *devname = dev_name(dev);
+ 	size_t len = strlen(devname);
+ 	int i, j;
+ 
+ 	priv->hwmon_name = devm_kzalloc(dev, len, GFP_KERNEL);
+ 	if (!priv->hwmon_name)
+ 		return -ENOMEM;
+ 
+ 	for (i = j = 0; i < len && devname[i]; i++) {
+ 		if (isalnum(devname[i]))
+ 			priv->hwmon_name[j++] = devname[i];
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int marvell_hwmon_probe(struct phy_device *phydev,
+ 			       const struct hwmon_chip_info *chip)
+ {
+ 	struct marvell_priv *priv = phydev->priv;
+ 	struct device *dev = &phydev->mdio.dev;
+ 	int err;
+ 
+ 	err = marvell_hwmon_name(phydev);
+ 	if (err)
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  		return err;
  
 -	priv->hwmon_dev = devm_hwmon_device_register_with_info(
 -		dev, priv->hwmon_name, phydev, chip, NULL);
 -
 -	return PTR_ERR_OR_ZERO(priv->hwmon_dev);
 -}
 -
 -static int m88e1121_hwmon_probe(struct phy_device *phydev)
 -{
 -	return marvell_hwmon_probe(phydev, &m88e1121_hwmon_chip_info);
 -}
 -
 -static int m88e1510_hwmon_probe(struct phy_device *phydev)
 -{
 -	return marvell_hwmon_probe(phydev, &m88e1510_hwmon_chip_info);
 -}
 -
 -static int m88e6390_hwmon_probe(struct phy_device *phydev)
 -{
 -	return marvell_hwmon_probe(phydev, &m88e6390_hwmon_chip_info);
 -}
 -#else
 -static int m88e1121_hwmon_probe(struct phy_device *phydev)
 -{
 -	return 0;
 -}
 -
 -static int m88e1510_hwmon_probe(struct phy_device *phydev)
 -{
  	return 0;
  }
  
diff --cc drivers/net/phy/micrel.c
index 2510435f34ed,c33384710d26..000000000000
--- a/drivers/net/phy/micrel.c
+++ b/drivers/net/phy/micrel.c
@@@ -121,6 -292,137 +121,140 @@@ static int ks8737_config_intr(struct ph
  
  static int kszphy_config_init(struct phy_device *phydev)
  {
++<<<<<<< HEAD
++=======
+ 	struct kszphy_priv *priv = phydev->priv;
+ 	const struct kszphy_type *type;
+ 
+ 	if (!priv)
+ 		return 0;
+ 
+ 	type = priv->type;
+ 
+ 	if (type->has_broadcast_disable)
+ 		kszphy_broadcast_disable(phydev);
+ 
+ 	if (type->has_nand_tree_disable)
+ 		kszphy_nand_tree_disable(phydev);
+ 
+ 	return kszphy_config_reset(phydev);
+ }
+ 
+ static int ksz8041_config_init(struct phy_device *phydev)
+ {
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 
+ 	struct device_node *of_node = phydev->mdio.dev.of_node;
+ 
+ 	/* Limit supported and advertised modes in fiber mode */
+ 	if (of_property_read_bool(of_node, "micrel,fiber-mode")) {
+ 		phydev->dev_flags |= MICREL_PHY_FXEN;
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, mask);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, mask);
+ 
+ 		linkmode_and(phydev->supported, phydev->supported, mask);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT,
+ 				 phydev->supported);
+ 		linkmode_and(phydev->advertising, phydev->advertising, mask);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT,
+ 				 phydev->advertising);
+ 		phydev->autoneg = AUTONEG_DISABLE;
+ 	}
+ 
+ 	return kszphy_config_init(phydev);
+ }
+ 
+ static int ksz8041_config_aneg(struct phy_device *phydev)
+ {
+ 	/* Skip auto-negotiation in fiber mode */
+ 	if (phydev->dev_flags & MICREL_PHY_FXEN) {
+ 		phydev->speed = SPEED_100;
+ 		return 0;
+ 	}
+ 
+ 	return genphy_config_aneg(phydev);
+ }
+ 
+ static int ksz9021_load_values_from_of(struct phy_device *phydev,
+ 				       const struct device_node *of_node,
+ 				       u16 reg,
+ 				       const char *field1, const char *field2,
+ 				       const char *field3, const char *field4)
+ {
+ 	int val1 = -1;
+ 	int val2 = -2;
+ 	int val3 = -3;
+ 	int val4 = -4;
+ 	int newval;
+ 	int matches = 0;
+ 
+ 	if (!of_property_read_u32(of_node, field1, &val1))
+ 		matches++;
+ 
+ 	if (!of_property_read_u32(of_node, field2, &val2))
+ 		matches++;
+ 
+ 	if (!of_property_read_u32(of_node, field3, &val3))
+ 		matches++;
+ 
+ 	if (!of_property_read_u32(of_node, field4, &val4))
+ 		matches++;
+ 
+ 	if (!matches)
+ 		return 0;
+ 
+ 	if (matches < 4)
+ 		newval = kszphy_extended_read(phydev, reg);
+ 	else
+ 		newval = 0;
+ 
+ 	if (val1 != -1)
+ 		newval = ((newval & 0xfff0) | ((val1 / PS_TO_REG) & 0xf) << 0);
+ 
+ 	if (val2 != -2)
+ 		newval = ((newval & 0xff0f) | ((val2 / PS_TO_REG) & 0xf) << 4);
+ 
+ 	if (val3 != -3)
+ 		newval = ((newval & 0xf0ff) | ((val3 / PS_TO_REG) & 0xf) << 8);
+ 
+ 	if (val4 != -4)
+ 		newval = ((newval & 0x0fff) | ((val4 / PS_TO_REG) & 0xf) << 12);
+ 
+ 	return kszphy_extended_write(phydev, reg, newval);
+ }
+ 
+ static int ksz9021_config_init(struct phy_device *phydev)
+ {
+ 	const struct device *dev = &phydev->mdio.dev;
+ 	const struct device_node *of_node = dev->of_node;
+ 	const struct device *dev_walker;
+ 
+ 	/* The Micrel driver has a deprecated option to place phy OF
+ 	 * properties in the MAC node. Walk up the tree of devices to
+ 	 * find a device with an OF node.
+ 	 */
+ 	dev_walker = &phydev->mdio.dev;
+ 	do {
+ 		of_node = dev_walker->of_node;
+ 		dev_walker = dev_walker->parent;
+ 
+ 	} while (!of_node && dev_walker);
+ 
+ 	if (of_node) {
+ 		ksz9021_load_values_from_of(phydev, of_node,
+ 				    MII_KSZPHY_CLK_CONTROL_PAD_SKEW,
+ 				    "txen-skew-ps", "txc-skew-ps",
+ 				    "rxdv-skew-ps", "rxc-skew-ps");
+ 		ksz9021_load_values_from_of(phydev, of_node,
+ 				    MII_KSZPHY_RX_DATA_PAD_SKEW,
+ 				    "rxd0-skew-ps", "rxd1-skew-ps",
+ 				    "rxd2-skew-ps", "rxd3-skew-ps");
+ 		ksz9021_load_values_from_of(phydev, of_node,
+ 				    MII_KSZPHY_TX_DATA_PAD_SKEW,
+ 				    "txd0-skew-ps", "txd1-skew-ps",
+ 				    "txd2-skew-ps", "txd3-skew-ps");
+ 	}
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  	return 0;
  }
  
diff --cc drivers/net/phy/phy.c
index c89d087511ee,ecc8a7d5306c..000000000000
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@@ -113,93 -165,55 +113,129 @@@ int phy_aneg_done(struct phy_device *ph
  }
  EXPORT_SYMBOL(phy_aneg_done);
  
 -/**
 - * phy_find_valid - find a PHY setting that matches the requested parameters
 - * @speed: desired speed
 - * @duplex: desired duplex
 - * @supported: mask of supported link modes
 - *
 - * Locate a supported phy setting that is, in priority order:
 - * - an exact match for the specified speed and duplex mode
 - * - a match for the specified speed, or slower speed
 - * - the slowest supported speed
 - * Returns the matched phy_setting entry, or %NULL if no supported phy
 - * settings were found.
 +/* A structure for mapping a particular speed and duplex
 + * combination to a particular SUPPORTED and ADVERTISED value
   */
++<<<<<<< HEAD
 +struct phy_setting {
 +	int speed;
 +	int duplex;
 +	u32 setting;
 +};
 +
 +/* A mapping of all SUPPORTED settings to speed/duplex */
 +static const struct phy_setting settings[] = {
 +	{
 +		.speed = 10000,
 +		.duplex = DUPLEX_FULL,
 +		.setting = SUPPORTED_10000baseT_Full,
 +	},
 +	{
 +		.speed = SPEED_1000,
 +		.duplex = DUPLEX_FULL,
 +		.setting = SUPPORTED_1000baseT_Full,
 +	},
 +	{
 +		.speed = SPEED_1000,
 +		.duplex = DUPLEX_HALF,
 +		.setting = SUPPORTED_1000baseT_Half,
 +	},
 +	{
 +		.speed = SPEED_100,
 +		.duplex = DUPLEX_FULL,
 +		.setting = SUPPORTED_100baseT_Full,
 +	},
 +	{
 +		.speed = SPEED_100,
 +		.duplex = DUPLEX_HALF,
 +		.setting = SUPPORTED_100baseT_Half,
 +	},
 +	{
 +		.speed = SPEED_10,
 +		.duplex = DUPLEX_FULL,
 +		.setting = SUPPORTED_10baseT_Full,
 +	},
 +	{
 +		.speed = SPEED_10,
 +		.duplex = DUPLEX_HALF,
 +		.setting = SUPPORTED_10baseT_Half,
 +	},
 +};
 +
 +#define MAX_NUM_SETTINGS ARRAY_SIZE(settings)
 +
 +/**
 + * phy_find_setting - find a PHY settings array entry that matches speed & duplex
++=======
+ static const struct phy_setting *
+ phy_find_valid(int speed, int duplex, unsigned long *supported)
+ {
+ 	return phy_lookup_setting(speed, duplex, supported, false);
+ }
+ 
+ /**
+  * phy_supported_speeds - return all speeds currently supported by a phy device
+  * @phy: The phy device to return supported speeds of.
+  * @speeds: buffer to store supported speeds in.
+  * @size:   size of speeds buffer.
+  *
+  * Description: Returns the number of supported speeds, and fills the speeds
+  * buffer with the supported speeds. If speeds buffer is too small to contain
+  * all currently supported speeds, will return as many speeds as can fit.
+  */
+ unsigned int phy_supported_speeds(struct phy_device *phy,
+ 				  unsigned int *speeds,
+ 				  unsigned int size)
+ {
+ 	return phy_speeds(speeds, size, phy->supported);
+ }
+ 
+ /**
+  * phy_check_valid - check if there is a valid PHY setting which matches
+  *		     speed, duplex, and feature mask
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
   * @speed: speed to match
   * @duplex: duplex to match
 + *
 + * Description: Searches the settings array for the setting which
 + *   matches the desired speed and duplex, and returns the index
 + *   of that setting.  Returns the index of the last setting if
 + *   none of the others match.
 + */
 +static inline int phy_find_setting(int speed, int duplex)
 +{
 +	int idx = 0;
 +
 +	while (idx < ARRAY_SIZE(settings) &&
 +	       (settings[idx].speed != speed || settings[idx].duplex != duplex))
 +		idx++;
 +
 +	return idx < MAX_NUM_SETTINGS ? idx : MAX_NUM_SETTINGS - 1;
 +}
 +
 +/**
 + * phy_find_valid - find a PHY setting that matches the requested features mask
 + * @idx: The first index in settings[] to search
   * @features: A mask of the valid settings
   *
 - * Description: Returns true if there is a valid setting, false otherwise.
 + * Description: Returns the index of the first valid setting less
 + *   than or equal to the one pointed to by idx, as determined by
 + *   the mask in features.  Returns the index of the last setting
 + *   if nothing else matches.
   */
++<<<<<<< HEAD
 +static inline int phy_find_valid(int idx, u32 features)
 +{
 +	while (idx < MAX_NUM_SETTINGS && !(settings[idx].setting & features))
 +		idx++;
 +
 +	return idx < MAX_NUM_SETTINGS ? idx : MAX_NUM_SETTINGS - 1;
++=======
+ static inline bool phy_check_valid(int speed, int duplex,
+ 				   unsigned long *features)
+ {
+ 	return !!phy_lookup_setting(speed, duplex, features, true);
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  }
  
  /**
@@@ -212,18 -226,22 +248,35 @@@
   */
  static void phy_sanitize_settings(struct phy_device *phydev)
  {
++<<<<<<< HEAD
 +	u32 features = phydev->supported;
 +	int idx;
++=======
+ 	const struct phy_setting *setting;
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	/* Sanitize settings based on PHY capabilities */
- 	if ((features & SUPPORTED_Autoneg) == 0)
+ 	if (linkmode_test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, phydev->supported))
  		phydev->autoneg = AUTONEG_DISABLE;
  
++<<<<<<< HEAD
 +	idx = phy_find_valid(phy_find_setting(phydev->speed, phydev->duplex),
 +			features);
 +
 +	phydev->speed = settings[idx].speed;
 +	phydev->duplex = settings[idx].duplex;
++=======
+ 	setting = phy_find_valid(phydev->speed, phydev->duplex,
+ 				 phydev->supported);
+ 	if (setting) {
+ 		phydev->speed = setting->speed;
+ 		phydev->duplex = setting->duplex;
+ 	} else {
+ 		/* We failed to find anything (no supported speeds?) */
+ 		phydev->speed = SPEED_UNKNOWN;
+ 		phydev->duplex = DUPLEX_UNKNOWN;
+ 	}
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  }
  
  /**
@@@ -240,9 -259,10 +293,10 @@@
   */
  int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd)
  {
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);
  	u32 speed = ethtool_cmd_speed(cmd);
  
 -	if (cmd->phy_address != phydev->mdio.addr)
 +	if (cmd->phy_address != phydev->addr)
  		return -EINVAL;
  
  	/* We make sure that we don't pass unsupported values in to the PHY */
@@@ -339,37 -363,11 +397,34 @@@ int phy_ethtool_ksettings_set(struct ph
  }
  EXPORT_SYMBOL(phy_ethtool_ksettings_set);
  
 -void phy_ethtool_ksettings_get(struct phy_device *phydev,
 -			       struct ethtool_link_ksettings *cmd)
 +int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd)
 +{
 +	cmd->supported = phydev->supported;
 +
 +	cmd->advertising = phydev->advertising;
 +	cmd->lp_advertising = phydev->lp_advertising;
 +
 +	ethtool_cmd_speed_set(cmd, phydev->speed);
 +	cmd->duplex = phydev->duplex;
 +	if (phydev->interface == PHY_INTERFACE_MODE_MOCA)
 +		cmd->port = PORT_BNC;
 +	else
 +		cmd->port = PORT_MII;
 +	cmd->phy_address = phydev->addr;
 +	cmd->transceiver = phy_is_internal(phydev) ?
 +		XCVR_INTERNAL : XCVR_EXTERNAL;
 +	cmd->autoneg = phydev->autoneg;
 +	cmd->eth_tp_mdix_ctrl = phydev->mdix;
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL(phy_ethtool_gset);
 +
 +int phy_ethtool_ksettings_get(struct phy_device *phydev,
 +			      struct ethtool_link_ksettings *cmd)
  {
- 	ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,
- 						phydev->supported);
- 
- 	ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,
- 						phydev->advertising);
+ 	linkmode_copy(cmd->link_modes.supported, phydev->supported);
+ 	linkmode_copy(cmd->link_modes.advertising, phydev->advertising);
  
  	ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.lp_advertising,
  						phydev->lp_advertising);
@@@ -416,25 -415,33 +471,31 @@@ int phy_mii_ioctl(struct phy_device *ph
  		return 0;
  
  	case SIOCSMIIREG:
 -		if (mii_data->phy_id == phydev->mdio.addr) {
 +		if (mii_data->phy_id == phydev->addr) {
  			switch (mii_data->reg_num) {
  			case MII_BMCR:
 -				if ((val & (BMCR_RESET | BMCR_ANENABLE)) == 0) {
 -					if (phydev->autoneg == AUTONEG_ENABLE)
 -						change_autoneg = true;
 +				if ((val & (BMCR_RESET | BMCR_ANENABLE)) == 0)
  					phydev->autoneg = AUTONEG_DISABLE;
 -					if (val & BMCR_FULLDPLX)
 -						phydev->duplex = DUPLEX_FULL;
 -					else
 -						phydev->duplex = DUPLEX_HALF;
 -					if (val & BMCR_SPEED1000)
 -						phydev->speed = SPEED_1000;
 -					else if (val & BMCR_SPEED100)
 -						phydev->speed = SPEED_100;
 -					else phydev->speed = SPEED_10;
 -				}
 -				else {
 -					if (phydev->autoneg == AUTONEG_DISABLE)
 -						change_autoneg = true;
 +				else
  					phydev->autoneg = AUTONEG_ENABLE;
 -				}
 +				if (!phydev->autoneg && (val & BMCR_FULLDPLX))
 +					phydev->duplex = DUPLEX_FULL;
 +				else
 +					phydev->duplex = DUPLEX_HALF;
 +				if (!phydev->autoneg && (val & BMCR_SPEED1000))
 +					phydev->speed = SPEED_1000;
 +				else if (!phydev->autoneg &&
 +					 (val & BMCR_SPEED100))
 +					phydev->speed = SPEED_100;
  				break;
  			case MII_ADVERTISE:
++<<<<<<< HEAD
 +				phydev->advertising = val;
++=======
+ 				mii_adv_to_linkmode_adv_t(phydev->advertising,
+ 							  val);
+ 				change_autoneg = true;
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  				break;
  			default:
  				/* do nothing */
@@@ -1116,54 -991,43 +1210,78 @@@ static inline void mmd_phy_indirect(str
  }
  
  /**
 - * phy_mac_interrupt - MAC says the link has changed
 - * @phydev: phy_device struct with changed link
 + * phy_read_mmd_indirect - reads data from the MMD registers
 + * @bus: the target MII bus
 + * @prtad: MMD Address
 + * @devad: MMD DEVAD
 + * @addr: PHY address on the MII bus
   *
 - * The MAC layer is able to indicate there has been a change in the PHY link
 - * status. Trigger the state machine and work a work queue.
 + * Description: it reads data from the MMD registers (clause 22 to access to
 + * clause 45) of the specified phy address.
 + * To read these register we have:
 + * 1) Write reg 13 // DEVAD
 + * 2) Write reg 14 // MMD Address
 + * 3) Write reg 13 // MMD Data Command for MMD DEVAD
 + * 3) Read  reg 14 // Read MMD data
   */
 -void phy_mac_interrupt(struct phy_device *phydev)
 +static int phy_read_mmd_indirect(struct mii_bus *bus, int prtad, int devad,
 +				 int addr)
  {
 -	/* Trigger a state machine change */
 -	phy_trigger_machine(phydev);
 +	mmd_phy_indirect(bus, prtad, devad, addr);
 +
 +	/* Read the content of the MMD's selected register */
 +	return bus->read(bus, addr, MII_MMD_DATA);
 +}
 +
 +/**
 + * phy_write_mmd_indirect - writes data to the MMD registers
 + * @bus: the target MII bus
 + * @prtad: MMD Address
 + * @devad: MMD DEVAD
 + * @addr: PHY address on the MII bus
 + * @data: data to write in the MMD register
 + *
 + * Description: Write data from the MMD registers of the specified
 + * phy address.
 + * To write these register we have:
 + * 1) Write reg 13 // DEVAD
 + * 2) Write reg 14 // MMD Address
 + * 3) Write reg 13 // MMD Data Command for MMD DEVAD
 + * 3) Write reg 14 // Write MMD data
 + */
 +static void phy_write_mmd_indirect(struct mii_bus *bus, int prtad, int devad,
 +				   int addr, u32 data)
 +{
 +	mmd_phy_indirect(bus, prtad, devad, addr);
 +
 +	/* Write the data into MMD's selected register */
 +	bus->write(bus, addr, MII_MMD_DATA, data);
  }
 -EXPORT_SYMBOL(phy_mac_interrupt);
  
+ static void mmd_eee_adv_to_linkmode(unsigned long *advertising, u16 eee_adv)
+ {
+ 	linkmode_zero(advertising);
+ 
+ 	if (eee_adv & MDIO_EEE_100TX)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+ 				 advertising);
+ 	if (eee_adv & MDIO_EEE_1000T)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+ 				 advertising);
+ 	if (eee_adv & MDIO_EEE_10GT)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+ 				 advertising);
+ 	if (eee_adv & MDIO_EEE_1000KX)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseKX_Full_BIT,
+ 				 advertising);
+ 	if (eee_adv & MDIO_EEE_10GKX4)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT,
+ 				 advertising);
+ 	if (eee_adv & MDIO_EEE_10GKR)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseKR_Full_BIT,
+ 				 advertising);
+ }
+ 
  /**
   * phy_init_eee - init and check the EEE feature
   * @phydev: target phy_device struct
@@@ -1176,19 -1040,18 +1294,29 @@@
   */
  int phy_init_eee(struct phy_device *phydev, bool clk_stop_enable)
  {
 -	if (!phydev->drv)
 -		return -EIO;
 -
  	/* According to 802.3az,the EEE is supported only in full duplex-mode.
 +	 * Also EEE feature is active when core is operating with MII, GMII
 +	 * or RGMII. Internal PHYs are also allowed to proceed and should
 +	 * return an error if they do not support EEE.
  	 */
++<<<<<<< HEAD
 +	if ((phydev->duplex == DUPLEX_FULL) &&
 +	    ((phydev->interface == PHY_INTERFACE_MODE_MII) ||
 +	    (phydev->interface == PHY_INTERFACE_MODE_GMII) ||
 +	    (phydev->interface == PHY_INTERFACE_MODE_RGMII) ||
 +	     phy_is_internal(phydev))) {
 +		int eee_lp, eee_cap, eee_adv;
 +		u32 lp, cap, adv;
 +		int idx, status;
++=======
+ 	if (phydev->duplex == DUPLEX_FULL) {
+ 		__ETHTOOL_DECLARE_LINK_MODE_MASK(common);
+ 		__ETHTOOL_DECLARE_LINK_MODE_MASK(lp);
+ 		__ETHTOOL_DECLARE_LINK_MODE_MASK(adv);
+ 		int eee_lp, eee_cap, eee_adv;
+ 		int status;
+ 		u32 cap;
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  		/* Read phy status to properly get the right settings */
  		status = phy_read_status(phydev);
@@@ -1218,10 -1078,11 +1346,18 @@@
  		if (eee_adv <= 0)
  			goto eee_exit_err;
  
++<<<<<<< HEAD
 +		adv = mmd_eee_adv_to_ethtool_adv_t(eee_adv);
 +		lp = mmd_eee_adv_to_ethtool_adv_t(eee_lp);
 +		idx = phy_find_setting(phydev->speed, phydev->duplex);
 +		if (!(lp & adv & settings[idx].setting))
++=======
+ 		mmd_eee_adv_to_linkmode(adv, eee_adv);
+ 		mmd_eee_adv_to_linkmode(lp, eee_lp);
+ 		linkmode_and(common, adv, lp);
+ 
+ 		if (!phy_check_valid(phydev->speed, phydev->duplex, common))
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  			goto eee_exit_err;
  
  		if (clk_stop_enable) {
diff --cc drivers/net/phy/phy_device.c
index f7f4abfd4a6f,09a1c2d835b2..000000000000
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@@ -40,9 -43,159 +40,162 @@@ MODULE_DESCRIPTION("PHY library")
  MODULE_AUTHOR("Andy Fleming");
  MODULE_LICENSE("GPL");
  
++<<<<<<< HEAD
++=======
+ __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_basic_features) __ro_after_init;
+ EXPORT_SYMBOL_GPL(phy_basic_features);
+ 
+ __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_basic_t1_features) __ro_after_init;
+ EXPORT_SYMBOL_GPL(phy_basic_t1_features);
+ 
+ __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_features) __ro_after_init;
+ EXPORT_SYMBOL_GPL(phy_gbit_features);
+ 
+ __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_fibre_features) __ro_after_init;
+ EXPORT_SYMBOL_GPL(phy_gbit_fibre_features);
+ 
+ __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_all_ports_features) __ro_after_init;
+ EXPORT_SYMBOL_GPL(phy_gbit_all_ports_features);
+ 
+ __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_features) __ro_after_init;
+ EXPORT_SYMBOL_GPL(phy_10gbit_features);
+ 
+ static const int phy_basic_ports_array[] = {
+ 	ETHTOOL_LINK_MODE_Autoneg_BIT,
+ 	ETHTOOL_LINK_MODE_TP_BIT,
+ 	ETHTOOL_LINK_MODE_MII_BIT,
+ };
+ EXPORT_SYMBOL_GPL(phy_basic_ports_array);
+ 
+ static const int phy_fibre_port_array[] = {
+ 	ETHTOOL_LINK_MODE_FIBRE_BIT,
+ };
+ EXPORT_SYMBOL_GPL(phy_fibre_port_array);
+ 
+ static const int phy_all_ports_features_array[] = {
+ 	ETHTOOL_LINK_MODE_Autoneg_BIT,
+ 	ETHTOOL_LINK_MODE_TP_BIT,
+ 	ETHTOOL_LINK_MODE_MII_BIT,
+ 	ETHTOOL_LINK_MODE_FIBRE_BIT,
+ 	ETHTOOL_LINK_MODE_AUI_BIT,
+ 	ETHTOOL_LINK_MODE_BNC_BIT,
+ 	ETHTOOL_LINK_MODE_Backplane_BIT,
+ };
+ EXPORT_SYMBOL_GPL(phy_all_ports_features_array);
+ 
+ const int phy_10_100_features_array[4] = {
+ 	ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+ 	ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+ 	ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+ 	ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+ };
+ EXPORT_SYMBOL_GPL(phy_10_100_features_array);
+ 
+ const int phy_basic_t1_features_array[2] = {
+ 	ETHTOOL_LINK_MODE_TP_BIT,
+ 	ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+ };
+ EXPORT_SYMBOL_GPL(phy_basic_t1_features_array);
+ 
+ const int phy_gbit_features_array[2] = {
+ 	ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+ 	ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+ };
+ EXPORT_SYMBOL_GPL(phy_gbit_features_array);
+ 
+ const int phy_10gbit_features_array[1] = {
+ 	ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+ };
+ EXPORT_SYMBOL_GPL(phy_10gbit_features_array);
+ 
+ __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_full_features) __ro_after_init;
+ EXPORT_SYMBOL_GPL(phy_10gbit_full_features);
+ 
+ static const int phy_10gbit_full_features_array[] = {
+ 	ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+ 	ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+ 	ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+ 	ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+ };
+ 
+ static void features_init(void)
+ {
+ 	/* 10/100 half/full*/
+ 	linkmode_set_bit_array(phy_basic_ports_array,
+ 			       ARRAY_SIZE(phy_basic_ports_array),
+ 			       phy_basic_features);
+ 	linkmode_set_bit_array(phy_10_100_features_array,
+ 			       ARRAY_SIZE(phy_10_100_features_array),
+ 			       phy_basic_features);
+ 
+ 	/* 100 full, TP */
+ 	linkmode_set_bit_array(phy_basic_t1_features_array,
+ 			       ARRAY_SIZE(phy_basic_t1_features_array),
+ 			       phy_basic_t1_features);
+ 
+ 	/* 10/100 half/full + 1000 half/full */
+ 	linkmode_set_bit_array(phy_basic_ports_array,
+ 			       ARRAY_SIZE(phy_basic_ports_array),
+ 			       phy_gbit_features);
+ 	linkmode_set_bit_array(phy_10_100_features_array,
+ 			       ARRAY_SIZE(phy_10_100_features_array),
+ 			       phy_gbit_features);
+ 	linkmode_set_bit_array(phy_gbit_features_array,
+ 			       ARRAY_SIZE(phy_gbit_features_array),
+ 			       phy_gbit_features);
+ 
+ 	/* 10/100 half/full + 1000 half/full + fibre*/
+ 	linkmode_set_bit_array(phy_basic_ports_array,
+ 			       ARRAY_SIZE(phy_basic_ports_array),
+ 			       phy_gbit_fibre_features);
+ 	linkmode_set_bit_array(phy_10_100_features_array,
+ 			       ARRAY_SIZE(phy_10_100_features_array),
+ 			       phy_gbit_fibre_features);
+ 	linkmode_set_bit_array(phy_gbit_features_array,
+ 			       ARRAY_SIZE(phy_gbit_features_array),
+ 			       phy_gbit_fibre_features);
+ 	linkmode_set_bit_array(phy_fibre_port_array,
+ 			       ARRAY_SIZE(phy_fibre_port_array),
+ 			       phy_gbit_fibre_features);
+ 
+ 	/* 10/100 half/full + 1000 half/full + TP/MII/FIBRE/AUI/BNC/Backplane*/
+ 	linkmode_set_bit_array(phy_all_ports_features_array,
+ 			       ARRAY_SIZE(phy_all_ports_features_array),
+ 			       phy_gbit_all_ports_features);
+ 	linkmode_set_bit_array(phy_10_100_features_array,
+ 			       ARRAY_SIZE(phy_10_100_features_array),
+ 			       phy_gbit_all_ports_features);
+ 	linkmode_set_bit_array(phy_gbit_features_array,
+ 			       ARRAY_SIZE(phy_gbit_features_array),
+ 			       phy_gbit_all_ports_features);
+ 
+ 	/* 10/100 half/full + 1000 half/full + 10G full*/
+ 	linkmode_set_bit_array(phy_all_ports_features_array,
+ 			       ARRAY_SIZE(phy_all_ports_features_array),
+ 			       phy_10gbit_features);
+ 	linkmode_set_bit_array(phy_10_100_features_array,
+ 			       ARRAY_SIZE(phy_10_100_features_array),
+ 			       phy_10gbit_features);
+ 	linkmode_set_bit_array(phy_gbit_features_array,
+ 			       ARRAY_SIZE(phy_gbit_features_array),
+ 			       phy_10gbit_features);
+ 	linkmode_set_bit_array(phy_10gbit_features_array,
+ 			       ARRAY_SIZE(phy_10gbit_features_array),
+ 			       phy_10gbit_features);
+ 
+ 	/* 10/100/1000/10G full */
+ 	linkmode_set_bit_array(phy_all_ports_features_array,
+ 			       ARRAY_SIZE(phy_all_ports_features_array),
+ 			       phy_10gbit_full_features);
+ 	linkmode_set_bit_array(phy_10gbit_full_features_array,
+ 			       ARRAY_SIZE(phy_10gbit_full_features_array),
+ 			       phy_10gbit_full_features);
+ }
+ 
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  void phy_device_free(struct phy_device *phydev)
  {
 -	put_device(&phydev->mdio.dev);
 +	put_device(&phydev->dev);
  }
  EXPORT_SYMBOL(phy_device_free);
  
@@@ -807,25 -1474,37 +965,40 @@@ static int genphy_config_advert(struct 
  		changed = 1;
  	}
  
 -	bmsr = phy_read(phydev, MII_BMSR);
 -	if (bmsr < 0)
 -		return bmsr;
 +	/* Configure gigabit if it's supported */
++<<<<<<< HEAD
 +	if (phydev->supported & (SUPPORTED_1000baseT_Half |
 +				 SUPPORTED_1000baseT_Full)) {
 +		adv = phy_read(phydev, MII_CTRL1000);
 +		if (adv < 0)
 +			return adv;
  
 -	/* Per 802.3-2008, Section 22.2.4.2.16 Extended status all
 -	 * 1000Mbits/sec capable PHYs shall have the BMSR_ESTATEN bit set to a
 -	 * logical 1.
 -	 */
 -	if (!(bmsr & BMSR_ESTATEN))
 -		return changed;
 +		oldadv = adv;
 +		adv &= ~(ADVERTISE_1000FULL | ADVERTISE_1000HALF);
 +		adv |= ethtool_adv_to_mii_ctrl1000_t(advertise);
  
 -	/* Configure gigabit if it's supported */
 +		if (adv != oldadv) {
 +			err = phy_write(phydev, MII_CTRL1000, adv);
 +
 +			if (err < 0)
 +				return err;
 +			changed = 1;
 +		}
 +	}
++=======
+ 	adv = phy_read(phydev, MII_CTRL1000);
+ 	if (adv < 0)
+ 		return adv;
+ 
+ 	oldadv = adv;
+ 	adv &= ~(ADVERTISE_1000FULL | ADVERTISE_1000HALF);
+ 
+ 	if (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+ 			      phydev->supported) ||
+ 	    linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+ 			      phydev->supported))
+ 		adv |= ethtool_adv_to_mii_ctrl1000_t(advertise);
 -
 -	if (adv != oldadv)
 -		changed = 1;
 -
 -	err = phy_write(phydev, MII_CTRL1000, adv);
 -	if (err < 0)
 -		return err;
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	return changed;
  }
@@@ -1119,17 -1812,16 +1294,25 @@@ int genphy_soft_reset(struct phy_devic
  }
  EXPORT_SYMBOL(genphy_soft_reset);
  
 -int genphy_config_init(struct phy_device *phydev)
 +static int genphy_config_init(struct phy_device *phydev)
  {
  	int val;
- 	u32 features;
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(features) = { 0, };
  
++<<<<<<< HEAD
 +	/* For now, I'll claim that the generic driver supports
 +	 * all possible port types
 +	 */
 +	features = (SUPPORTED_TP | SUPPORTED_MII
 +			| SUPPORTED_AUI | SUPPORTED_FIBRE |
 +			SUPPORTED_BNC);
++=======
+ 	linkmode_set_bit_array(phy_basic_ports_array,
+ 			       ARRAY_SIZE(phy_basic_ports_array),
+ 			       features);
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, features);
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, features);
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	/* Do we support autonegotiation? */
  	val = phy_read(phydev, MII_BMSR);
@@@ -1154,13 -1846,15 +1337,20 @@@
  			return val;
  
  		if (val & ESTATUS_1000_TFULL)
- 			features |= SUPPORTED_1000baseT_Full;
+ 			linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+ 					 features);
  		if (val & ESTATUS_1000_THALF)
- 			features |= SUPPORTED_1000baseT_Half;
+ 			linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+ 					 features);
  	}
  
++<<<<<<< HEAD
 +	phydev->supported = features;
 +	phydev->advertising = features;
++=======
+ 	linkmode_and(phydev->supported, phydev->supported, features);
+ 	linkmode_and(phydev->advertising, phydev->advertising, features);
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	return 0;
  }
@@@ -1209,11 -1889,242 +1399,248 @@@ int genphy_resume(struct phy_device *ph
  }
  EXPORT_SYMBOL(genphy_resume);
  
 -int genphy_loopback(struct phy_device *phydev, bool enable)
 +static int gen10g_resume(struct phy_device *phydev)
  {
++<<<<<<< HEAD
++	return 0;
++}
++
++=======
+ 	return phy_modify(phydev, MII_BMCR, BMCR_LOOPBACK,
+ 			  enable ? BMCR_LOOPBACK : 0);
+ }
+ EXPORT_SYMBOL(genphy_loopback);
+ 
+ static int __set_phy_supported(struct phy_device *phydev, u32 max_speed)
+ {
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(speeds) = { 0, };
+ 
+ 	linkmode_set_bit_array(phy_10_100_features_array,
+ 			       ARRAY_SIZE(phy_10_100_features_array),
+ 			       speeds);
+ 	linkmode_set_bit_array(phy_gbit_features_array,
+ 			       ARRAY_SIZE(phy_gbit_features_array),
+ 			       speeds);
+ 
+ 	linkmode_andnot(phydev->supported, phydev->supported, speeds);
+ 
+ 	switch (max_speed) {
+ 	default:
+ 		return -ENOTSUPP;
+ 	case SPEED_1000:
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,
+ 				 phydev->supported);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,
+ 				 phydev->supported);
+ 		/* fall through */
+ 	case SPEED_100:
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+ 				 phydev->supported);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+ 				 phydev->supported);
+ 		/* fall through */
+ 	case SPEED_10:
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+ 				 phydev->supported);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+ 				 phydev->supported);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int phy_set_max_speed(struct phy_device *phydev, u32 max_speed)
+ {
+ 	int err;
+ 
+ 	err = __set_phy_supported(phydev, max_speed);
+ 	if (err)
+ 		return err;
+ 
+ 	linkmode_copy(phydev->advertising, phydev->supported);
+ 
  	return 0;
  }
+ EXPORT_SYMBOL(phy_set_max_speed);
+ 
+ /**
+  * phy_remove_link_mode - Remove a supported link mode
+  * @phydev: phy_device structure to remove link mode from
+  * @link_mode: Link mode to be removed
+  *
+  * Description: Some MACs don't support all link modes which the PHY
+  * does.  e.g. a 1G MAC often does not support 1000Half. Add a helper
+  * to remove a link mode.
+  */
+ void phy_remove_link_mode(struct phy_device *phydev, u32 link_mode)
+ {
+ 	linkmode_clear_bit(link_mode, phydev->supported);
+ 	linkmode_copy(phydev->advertising, phydev->supported);
+ }
+ EXPORT_SYMBOL(phy_remove_link_mode);
  
+ /**
+  * phy_support_sym_pause - Enable support of symmetrical pause
+  * @phydev: target phy_device struct
+  *
+  * Description: Called by the MAC to indicate is supports symmetrical
+  * Pause, but not asym pause.
+  */
+ void phy_support_sym_pause(struct phy_device *phydev)
+ {
+ 	linkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->supported);
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->supported);
+ 	linkmode_copy(phydev->advertising, phydev->supported);
+ }
+ EXPORT_SYMBOL(phy_support_sym_pause);
+ 
+ /**
+  * phy_support_asym_pause - Enable support of asym pause
+  * @phydev: target phy_device struct
+  *
+  * Description: Called by the MAC to indicate is supports Asym Pause.
+  */
+ void phy_support_asym_pause(struct phy_device *phydev)
+ {
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->supported);
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->supported);
+ 	linkmode_copy(phydev->advertising, phydev->supported);
+ }
+ EXPORT_SYMBOL(phy_support_asym_pause);
+ 
+ /**
+  * phy_set_sym_pause - Configure symmetric Pause
+  * @phydev: target phy_device struct
+  * @rx: Receiver Pause is supported
+  * @tx: Transmit Pause is supported
+  * @autoneg: Auto neg should be used
+  *
+  * Description: Configure advertised Pause support depending on if
+  * receiver pause and pause auto neg is supported. Generally called
+  * from the set_pauseparam .ndo.
+  */
+ void phy_set_sym_pause(struct phy_device *phydev, bool rx, bool tx,
+ 		       bool autoneg)
+ {
+ 	linkmode_clear_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->supported);
+ 
+ 	if (rx && tx && autoneg)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 				 phydev->supported);
+ 
+ 	linkmode_copy(phydev->advertising, phydev->supported);
+ }
+ EXPORT_SYMBOL(phy_set_sym_pause);
+ 
+ /**
+  * phy_set_asym_pause - Configure Pause and Asym Pause
+  * @phydev: target phy_device struct
+  * @rx: Receiver Pause is supported
+  * @tx: Transmit Pause is supported
+  *
+  * Description: Configure advertised Pause support depending on if
+  * transmit and receiver pause is supported. If there has been a
+  * change in adverting, trigger a new autoneg. Generally called from
+  * the set_pauseparam .ndo.
+  */
+ void phy_set_asym_pause(struct phy_device *phydev, bool rx, bool tx)
+ {
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(oldadv);
+ 
+ 	linkmode_copy(oldadv, phydev->advertising);
+ 
+ 	linkmode_clear_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 			   phydev->advertising);
+ 	linkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 			   phydev->advertising);
+ 
+ 	if (rx) {
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 				 phydev->advertising);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 				 phydev->advertising);
+ 	}
+ 
+ 	if (tx)
+ 		linkmode_change_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 				    phydev->advertising);
+ 
+ 	if (!linkmode_equal(oldadv, phydev->advertising) &&
+ 	    phydev->autoneg)
+ 		phy_start_aneg(phydev);
+ }
+ EXPORT_SYMBOL(phy_set_asym_pause);
+ 
+ /**
+  * phy_validate_pause - Test if the PHY/MAC support the pause configuration
+  * @phydev: phy_device struct
+  * @pp: requested pause configuration
+  *
+  * Description: Test if the PHY/MAC combination supports the Pause
+  * configuration the user is requesting. Returns True if it is
+  * supported, false otherwise.
+  */
+ bool phy_validate_pause(struct phy_device *phydev,
+ 			struct ethtool_pauseparam *pp)
+ {
+ 	if (!linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 			       phydev->supported) ||
+ 	    (!linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 				phydev->supported) &&
+ 	     pp->rx_pause != pp->tx_pause))
+ 		return false;
+ 	return true;
+ }
+ EXPORT_SYMBOL(phy_validate_pause);
+ 
+ static void of_set_phy_supported(struct phy_device *phydev)
+ {
+ 	struct device_node *node = phydev->mdio.dev.of_node;
+ 	u32 max_speed;
+ 
+ 	if (!IS_ENABLED(CONFIG_OF_MDIO))
+ 		return;
+ 
+ 	if (!node)
+ 		return;
+ 
+ 	if (!of_property_read_u32(node, "max-speed", &max_speed))
+ 		__set_phy_supported(phydev, max_speed);
+ }
+ 
+ static void of_set_phy_eee_broken(struct phy_device *phydev)
+ {
+ 	struct device_node *node = phydev->mdio.dev.of_node;
+ 	u32 broken = 0;
+ 
+ 	if (!IS_ENABLED(CONFIG_OF_MDIO))
+ 		return;
+ 
+ 	if (!node)
+ 		return;
+ 
+ 	if (of_property_read_bool(node, "eee-broken-100tx"))
+ 		broken |= MDIO_EEE_100TX;
+ 	if (of_property_read_bool(node, "eee-broken-1000t"))
+ 		broken |= MDIO_EEE_1000T;
+ 	if (of_property_read_bool(node, "eee-broken-10gt"))
+ 		broken |= MDIO_EEE_10GT;
+ 	if (of_property_read_bool(node, "eee-broken-1000kx"))
+ 		broken |= MDIO_EEE_1000KX;
+ 	if (of_property_read_bool(node, "eee-broken-10gkx4"))
+ 		broken |= MDIO_EEE_10GKX4;
+ 	if (of_property_read_bool(node, "eee-broken-10gkr"))
+ 		broken |= MDIO_EEE_10GKR;
+ 
+ 	phydev->eee_broken_modes = broken;
+ }
+ 
+ static bool phy_drv_supports_irq(struct phy_driver *phydrv)
+ {
+ 	return phydrv->config_intr || phydrv->ack_interrupt;
+ }
+ 
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  /**
   * phy_probe - probe and init a PHY device
   * @dev: device to probe and init
@@@ -1247,8 -2158,46 +1674,51 @@@ static int phy_probe(struct device *dev
  	 * a controller will attach, and may modify one
  	 * or both of these values
  	 */
++<<<<<<< HEAD
 +	phydev->supported = phydrv->features;
 +	phydev->advertising = phydrv->features;
++=======
+ 	ethtool_convert_link_mode_to_legacy_u32(&features, phydrv->features);
+ 	linkmode_copy(phydev->supported, phydrv->features);
+ 	of_set_phy_supported(phydev);
+ 	linkmode_copy(phydev->advertising, phydev->supported);
+ 
+ 	/* Get the EEE modes we want to prohibit. We will ask
+ 	 * the PHY stop advertising these mode later on
+ 	 */
+ 	of_set_phy_eee_broken(phydev);
+ 
+ 	/* The Pause Frame bits indicate that the PHY can support passing
+ 	 * pause frames. During autonegotiation, the PHYs will determine if
+ 	 * they should allow pause frames to pass.  The MAC driver should then
+ 	 * use that result to determine whether to enable flow control via
+ 	 * pause frames.
+ 	 *
+ 	 * Normally, PHY drivers should not set the Pause bits, and instead
+ 	 * allow phylib to do that.  However, there may be some situations
+ 	 * (e.g. hardware erratum) where the driver wants to set only one
+ 	 * of these bits.
+ 	 */
+ 	if (test_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydrv->features) ||
+ 	    test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydrv->features)) {
+ 		linkmode_clear_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 				   phydev->supported);
+ 		linkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 				   phydev->supported);
+ 		if (test_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydrv->features))
+ 			linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 					 phydev->supported);
+ 		if (test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 			     phydrv->features))
+ 			linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 					 phydev->supported);
+ 	} else {
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 				 phydev->supported);
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+ 				 phydev->supported);
+ 	}
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  
  	/* Set the state to READY by default */
  	phydev->state = PHY_READY;
diff --cc include/linux/mii.h
index e870bfa6abfe,aaa458bbef2a..000000000000
--- a/include/linux/mii.h
+++ b/include/linux/mii.h
@@@ -302,6 -354,58 +302,61 @@@ static inline u32 mii_lpa_to_ethtool_lp
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mii_adv_to_linkmode_adv_t
+  * @advertising:pointer to destination link mode.
+  * @adv: value of the MII_ADVERTISE register
+  *
+  * A small helper function that translates MII_ADVERTISE bits
+  * to linkmode advertisement settings.
+  */
+ static inline void mii_adv_to_linkmode_adv_t(unsigned long *advertising,
+ 					     u32 adv)
+ {
+ 	linkmode_zero(advertising);
+ 
+ 	if (adv & ADVERTISE_10HALF)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+ 				 advertising);
+ 	if (adv & ADVERTISE_10FULL)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+ 				 advertising);
+ 	if (adv & ADVERTISE_100HALF)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+ 				 advertising);
+ 	if (adv & ADVERTISE_100FULL)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+ 				 advertising);
+ 	if (adv & ADVERTISE_PAUSE_CAP)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, advertising);
+ 	if (adv & ADVERTISE_PAUSE_ASYM)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, advertising);
+ }
+ 
+ /**
+  * linkmode_adv_to_lcl_adv_t
+  * @advertising:pointer to linkmode advertising
+  *
+  * A small helper function that translates linkmode advertising to LVL
+  * pause capabilities.
+  */
+ static inline u32 linkmode_adv_to_lcl_adv_t(unsigned long *advertising)
+ {
+ 	u32 lcl_adv = 0;
+ 
+ 	if (linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 			      advertising))
+ 		lcl_adv |= ADVERTISE_PAUSE_CAP;
+ 	if (linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+ 			      advertising))
+ 		lcl_adv |= ADVERTISE_PAUSE_ASYM;
+ 
+ 	return lcl_adv;
+ }
+ 
+ /**
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
   * mii_advertise_flowctrl - get flow control advertisement flags
   * @cap: Flow control capabilities (FLOW_CTRL_RX, FLOW_CTRL_TX or both)
   */
diff --cc include/linux/phy.h
index 2a7a15321caa,cbc66ac3b560..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -40,14 -42,27 +40,19 @@@
  #define PHY_1000BT_FEATURES	(SUPPORTED_1000baseT_Half | \
  				 SUPPORTED_1000baseT_Full)
  
 -extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_basic_features) __ro_after_init;
 -extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_basic_t1_features) __ro_after_init;
 -extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_features) __ro_after_init;
 -extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_fibre_features) __ro_after_init;
 -extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_all_ports_features) __ro_after_init;
 -extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_features) __ro_after_init;
 -extern __ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_full_features) __ro_after_init;
 -
 -#define PHY_BASIC_FEATURES ((unsigned long *)&phy_basic_features)
 -#define PHY_BASIC_T1_FEATURES ((unsigned long *)&phy_basic_t1_features)
 -#define PHY_GBIT_FEATURES ((unsigned long *)&phy_gbit_features)
 -#define PHY_GBIT_FIBRE_FEATURES ((unsigned long *)&phy_gbit_fibre_features)
 -#define PHY_GBIT_ALL_PORTS_FEATURES ((unsigned long *)&phy_gbit_all_ports_features)
 -#define PHY_10GBIT_FEATURES ((unsigned long *)&phy_10gbit_features)
 -#define PHY_10GBIT_FULL_FEATURES ((unsigned long *)&phy_10gbit_full_features)
 +#define PHY_BASIC_FEATURES	(PHY_10BT_FEATURES | \
 +				 PHY_100BT_FEATURES | \
 +				 PHY_DEFAULT_FEATURES)
 +
 +#define PHY_GBIT_FEATURES	(PHY_BASIC_FEATURES | \
 +				 PHY_1000BT_FEATURES)
 +
  
+ extern const int phy_10_100_features_array[4];
+ extern const int phy_basic_t1_features_array[2];
+ extern const int phy_gbit_features_array[2];
+ extern const int phy_10gbit_features_array[1];
+ 
  /*
   * Set phydev->irq to PHY_POLL if interrupts are not supported,
   * or not desired for this PHY.  Set to PHY_IGNORE_INTERRUPT if
@@@ -375,19 -410,15 +380,27 @@@ struct phy_device 
  	int pause;
  	int asym_pause;
  
++<<<<<<< HEAD
 +	/* The most recently read link state */
 +	int link;
 +
 +	/* Enabled Interrupts */
 +	u32 interrupts;
 +
 +	/* Union of PHY and Attached devices' supported modes */
 +	/* See mii.h for more info */
 +	u32 supported;
 +	u32 advertising;
++=======
+ 	/* Union of PHY and Attached devices' supported link modes */
+ 	/* See ethtool.h for more info */
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(supported);
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);
+ 
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  	u32 lp_advertising;
  
 -	/* Energy efficient ethernet modes which should be prohibited */
 -	u32 eee_broken_modes;
 +	int autoneg;
  
  	int link_timeout;
  
@@@ -546,6 -652,26 +559,29 @@@ struct phy_fixup 
  	int (*run)(struct phy_device *phydev);
  };
  
++<<<<<<< HEAD
++=======
+ const char *phy_speed_to_str(int speed);
+ const char *phy_duplex_to_str(unsigned int duplex);
+ 
+ /* A structure for mapping a particular speed and duplex
+  * combination to a particular SUPPORTED and ADVERTISED value
+  */
+ struct phy_setting {
+ 	u32 speed;
+ 	u8 duplex;
+ 	u8 bit;
+ };
+ 
+ const struct phy_setting *
+ phy_lookup_setting(int speed, int duplex, const unsigned long *mask,
+ 		   bool exact);
+ size_t phy_speeds(unsigned int *speeds, size_t size,
+ 		  unsigned long *mask);
+ 
+ void phy_resolve_aneg_linkmode(struct phy_device *phydev);
+ 
++>>>>>>> 3c1bcc8614db (net: ethernet: Convert phydev advertize and supported from u32 to link mode)
  /**
   * phy_read_mmd - Convenience function for reading a register
   * from an MMD on a given PHY.
* Unmerged path drivers/net/dsa/mt7530.c
* Unmerged path drivers/net/ethernet/apm/xgene-v2/mdio.c
* Unmerged path drivers/net/ethernet/arc/emac_main.c
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmmii.c
* Unmerged path drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
* Unmerged path drivers/net/ethernet/freescale/fman/mac.c
* Unmerged path drivers/net/ethernet/hisilicon/hns/hns_enet.c
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.c
* Unmerged path drivers/net/ethernet/mediatek/mtk_eth_soc.c
* Unmerged path drivers/net/ethernet/socionext/sni_ave.c
* Unmerged path drivers/net/phy/aquantia.c
* Unmerged path drivers/net/phy/marvell10g.c
* Unmerged path drivers/net/phy/phy-c45.c
* Unmerged path drivers/net/phy/phy-core.c
* Unmerged path drivers/net/phy/phylink.c
* Unmerged path drivers/net/dsa/mt7530.c
diff --git a/drivers/net/ethernet/aeroflex/greth.c b/drivers/net/ethernet/aeroflex/greth.c
index 48dd6ff189ba..bb785473aa2d 100644
--- a/drivers/net/ethernet/aeroflex/greth.c
+++ b/drivers/net/ethernet/aeroflex/greth.c
@@ -1298,7 +1298,7 @@ static int greth_mdio_probe(struct net_device *dev)
 	else
 		phy->supported &= PHY_BASIC_FEATURES;
 
-	phy->advertising = phy->supported;
+	linkmode_copy(phy->advertising, phy->supported);
 
 	greth->link = 0;
 	greth->speed = 0;
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
* Unmerged path drivers/net/ethernet/apm/xgene-v2/mdio.c
* Unmerged path drivers/net/ethernet/arc/emac_main.c
* Unmerged path drivers/net/ethernet/broadcom/b44.c
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmmii.c
diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c
index 34c729a025a9..d03c8a7503cb 100644
--- a/drivers/net/ethernet/broadcom/tg3.c
+++ b/drivers/net/ethernet/broadcom/tg3.c
@@ -2155,7 +2155,8 @@ static void tg3_phy_start(struct tg3 *tp)
 		phydev->speed = tp->link_config.speed;
 		phydev->duplex = tp->link_config.duplex;
 		phydev->autoneg = tp->link_config.autoneg;
-		phydev->advertising = tp->link_config.advertising;
+		ethtool_convert_legacy_u32_to_link_mode(
+			phydev->advertising, tp->link_config.advertising);
 	}
 
 	phy_start(phydev);
@@ -4055,8 +4056,9 @@ static int tg3_power_down_prepare(struct tg3 *tp)
 		do_low_power = false;
 		if ((tp->phy_flags & TG3_PHYFLG_IS_CONNECTED) &&
 		    !(tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)) {
+			__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising) = { 0, };
 			struct phy_device *phydev;
-			u32 phyid, advertising;
+			u32 phyid;
 
 			phydev = tp->mdio_bus->phy_map[tp->phy_addr];
 
@@ -4065,25 +4067,33 @@ static int tg3_power_down_prepare(struct tg3 *tp)
 			tp->link_config.speed = phydev->speed;
 			tp->link_config.duplex = phydev->duplex;
 			tp->link_config.autoneg = phydev->autoneg;
-			tp->link_config.advertising = phydev->advertising;
-
-			advertising = ADVERTISED_TP |
-				      ADVERTISED_Pause |
-				      ADVERTISED_Autoneg |
-				      ADVERTISED_10baseT_Half;
+			ethtool_convert_link_mode_to_legacy_u32(
+				&tp->link_config.advertising,
+				phydev->advertising);
+
+			linkmode_set_bit(ETHTOOL_LINK_MODE_TP_BIT, advertising);
+			linkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+					 advertising);
+			linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,
+					 advertising);
+			linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,
+					 advertising);
 
 			if (tg3_flag(tp, ENABLE_ASF) || device_should_wake) {
-				if (tg3_flag(tp, WOL_SPEED_100MB))
-					advertising |=
-						ADVERTISED_100baseT_Half |
-						ADVERTISED_100baseT_Full |
-						ADVERTISED_10baseT_Full;
-				else
-					advertising |= ADVERTISED_10baseT_Full;
+				if (tg3_flag(tp, WOL_SPEED_100MB)) {
+					linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,
+							 advertising);
+					linkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,
+							 advertising);
+					linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+							 advertising);
+				} else {
+					linkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,
+							 advertising);
+				}
 			}
 
-			phydev->advertising = advertising;
-
+			linkmode_copy(phydev->advertising, advertising);
 			phy_start_aneg(phydev);
 
 			phyid = phydev->drv->phy_id & phydev->drv->phy_id_mask;
* Unmerged path drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
* Unmerged path drivers/net/ethernet/freescale/fman/mac.c
* Unmerged path drivers/net/ethernet/freescale/gianfar.c
* Unmerged path drivers/net/ethernet/freescale/ucc_geth.c
* Unmerged path drivers/net/ethernet/hisilicon/hns/hns_enet.c
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_mdio.c
* Unmerged path drivers/net/ethernet/ibm/emac/core.c
* Unmerged path drivers/net/ethernet/marvell/mv643xx_eth.c
* Unmerged path drivers/net/ethernet/mediatek/mtk_eth_soc.c
diff --git a/drivers/net/ethernet/nxp/lpc_eth.c b/drivers/net/ethernet/nxp/lpc_eth.c
index 55a5548d6add..d6decd7f5237 100644
--- a/drivers/net/ethernet/nxp/lpc_eth.c
+++ b/drivers/net/ethernet/nxp/lpc_eth.c
@@ -811,8 +811,6 @@ static int lpc_mii_probe(struct net_device *ndev)
 	/* mask with MAC supported features */
 	phydev->supported &= PHY_BASIC_FEATURES;
 
-	phydev->advertising = phydev->supported;
-
 	pldat->link = 0;
 	pldat->speed = 0;
 	pldat->duplex = -1;
* Unmerged path drivers/net/ethernet/octeon/octeon_mgmt.c
* Unmerged path drivers/net/ethernet/realtek/r8169.c
* Unmerged path drivers/net/ethernet/socionext/sni_ave.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
* Unmerged path drivers/net/ethernet/toshiba/tc35815.c
* Unmerged path drivers/net/phy/aquantia.c
* Unmerged path drivers/net/phy/bcm63xx.c
diff --git a/drivers/net/phy/bcm87xx.c b/drivers/net/phy/bcm87xx.c
index 799789518e87..5fee7f64b79b 100644
--- a/drivers/net/phy/bcm87xx.c
+++ b/drivers/net/phy/bcm87xx.c
@@ -86,8 +86,12 @@ static int bcm87xx_of_reg_init(struct phy_device *phydev)
 
 static int bcm87xx_config_init(struct phy_device *phydev)
 {
-	phydev->supported = SUPPORTED_10000baseR_FEC;
-	phydev->advertising = ADVERTISED_10000baseR_FEC;
+	linkmode_zero(phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseR_FEC_BIT,
+			 phydev->supported);
+	linkmode_zero(phydev->advertising);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseR_FEC_BIT,
+			 phydev->advertising);
 	phydev->state = PHY_NOLINK;
 	phydev->autoneg = AUTONEG_DISABLE;
 
* Unmerged path drivers/net/phy/fixed_phy.c
* Unmerged path drivers/net/phy/marvell.c
* Unmerged path drivers/net/phy/marvell10g.c
* Unmerged path drivers/net/phy/micrel.c
* Unmerged path drivers/net/phy/phy-c45.c
* Unmerged path drivers/net/phy/phy-core.c
* Unmerged path drivers/net/phy/phy.c
* Unmerged path drivers/net/phy/phy_device.c
* Unmerged path drivers/net/phy/phylink.c
diff --git a/drivers/net/usb/lan78xx.c b/drivers/net/usb/lan78xx.c
index 3ea6b9c0134f..4d9b9eb83524 100644
--- a/drivers/net/usb/lan78xx.c
+++ b/drivers/net/usb/lan78xx.c
@@ -25,6 +25,7 @@
 #include <linux/slab.h>
 #include <linux/if_vlan.h>
 #include <linux/uaccess.h>
+#include <linux/linkmode.h>
 #include <linux/list.h>
 #include <linux/ip.h>
 #include <linux/ipv6.h>
@@ -1647,18 +1648,17 @@ static int lan78xx_set_pause(struct net_device *net,
 		dev->fc_request_control |= FLOW_CTRL_TX;
 
 	if (ecmd.base.autoneg) {
+		__ETHTOOL_DECLARE_LINK_MODE_MASK(fc) = { 0, };
 		u32 mii_adv;
-		u32 advertising;
 
-		ethtool_convert_link_mode_to_legacy_u32(
-			&advertising, ecmd.link_modes.advertising);
-
-		advertising &= ~(ADVERTISED_Pause | ADVERTISED_Asym_Pause);
+		linkmode_clear_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+				   ecmd.link_modes.advertising);
+		linkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+				   ecmd.link_modes.advertising);
 		mii_adv = (u32)mii_advertise_flowctrl(dev->fc_request_control);
-		advertising |= mii_adv_to_ethtool_adv_t(mii_adv);
-
-		ethtool_convert_legacy_u32_to_link_mode(
-			ecmd.link_modes.advertising, advertising);
+		mii_adv_to_linkmode_adv_t(fc, mii_adv);
+		linkmode_or(ecmd.link_modes.advertising, fc,
+			    ecmd.link_modes.advertising);
 
 		phy_ethtool_ksettings_set(phydev, &ecmd);
 	}
@@ -2079,6 +2079,7 @@ static int ksz9031rnx_fixup(struct phy_device *phydev)
 
 static int lan78xx_phy_init(struct lan78xx_net *dev)
 {
+	__ETHTOOL_DECLARE_LINK_MODE_MASK(fc) = { 0, };
 	int ret;
 	u32 mii_adv;
 	struct phy_device *phydev;
@@ -2149,9 +2150,13 @@ static int lan78xx_phy_init(struct lan78xx_net *dev)
 
 	/* support both flow controls */
 	dev->fc_request_control = (FLOW_CTRL_RX | FLOW_CTRL_TX);
-	phydev->advertising &= ~(ADVERTISED_Pause | ADVERTISED_Asym_Pause);
+	linkmode_clear_bit(ETHTOOL_LINK_MODE_Pause_BIT,
+			   phydev->advertising);
+	linkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,
+			   phydev->advertising);
 	mii_adv = (u32)mii_advertise_flowctrl(dev->fc_request_control);
-	phydev->advertising |= mii_adv_to_ethtool_adv_t(mii_adv);
+	mii_adv_to_linkmode_adv_t(fc, mii_adv);
+	linkmode_or(phydev->advertising, fc, phydev->advertising);
 
 	genphy_config_aneg(phydev);
 
* Unmerged path include/linux/mii.h
* Unmerged path include/linux/phy.h
