RDMA/uverbs: Get rid of the & in method specifications

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit 9a119cd597769e0dd432110361ed1deec729ac06
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9a119cd5.failed

Hide it inside the macros. The & is confusing and interferes with using
this as a generic DSL in later patches.

Since this also touches almost every line, also run the specs through
clang-format (with 'BinPackParameters: false') to make the maintenance
easier.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 9a119cd597769e0dd432110361ed1deec729ac06)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_std_types.c
#	drivers/infiniband/core/uverbs_std_types_counters.c
#	drivers/infiniband/core/uverbs_std_types_cq.c
#	drivers/infiniband/core/uverbs_std_types_dm.c
#	drivers/infiniband/core/uverbs_std_types_flow_action.c
#	drivers/infiniband/core/uverbs_std_types_mr.c
#	drivers/infiniband/hw/mlx5/devx.c
#	drivers/infiniband/hw/mlx5/main.c
#	include/rdma/uverbs_ioctl.h
#	include/rdma/uverbs_named_ioctl.h
diff --cc drivers/infiniband/core/uverbs_std_types.c
index f83837ce24d4,2f1a0b6598fe..000000000000
--- a/drivers/infiniband/core/uverbs_std_types.c
+++ b/drivers/infiniband/core/uverbs_std_types.c
@@@ -247,66 -248,68 +247,111 @@@ void create_udata(struct uverbs_attr_bu
  	}
  }
  
++<<<<<<< HEAD
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_COMP_CHANNEL,
 +			    &UVERBS_TYPE_ALLOC_FD(0,
 +						  sizeof(struct ib_uverbs_completion_event_file),
 +						  uverbs_hot_unplug_completion_event_file,
 +						  &uverbs_event_fops,
 +						  "[infinibandevent]", O_RDONLY));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_QP,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uqp_object), 0,
 +						      uverbs_free_qp));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MW,
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_mw));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MR,
 +			    /* 1 is used in order to free the MR after all the MWs */
 +			    &UVERBS_TYPE_ALLOC_IDR(1, uverbs_free_mr));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_SRQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_usrq_object), 0,
 +						      uverbs_free_srq));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_AH,
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_ah));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_FLOW,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uflow_object),
 +						      0, uverbs_free_flow));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_WQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uwq_object), 0,
 +						      uverbs_free_wq));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL,
 +			    &UVERBS_TYPE_ALLOC_IDR(0, uverbs_free_rwq_ind_tbl));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_XRCD,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uxrcd_object), 0,
 +						      uverbs_free_xrcd));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_PD,
 +			    /* 2 is used in order to free the PD after MRs */
 +			    &UVERBS_TYPE_ALLOC_IDR(2, uverbs_free_pd));
++=======
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_COMP_CHANNEL,
+ 	UVERBS_TYPE_ALLOC_FD(sizeof(struct ib_uverbs_completion_event_file),
+ 			     uverbs_hot_unplug_completion_event_file,
+ 			     &uverbs_event_fops,
+ 			     "[infinibandevent]",
+ 			     O_RDONLY));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_QP,
+ 	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uqp_object), uverbs_free_qp));
  
- DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_DEVICE, NULL);
+ DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MW,
+ 			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_mw));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_SRQ,
+ 	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_usrq_object),
+ 				 uverbs_free_srq));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_AH,
+ 			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_ah));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_FLOW,
+ 	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uflow_object),
+ 				 uverbs_free_flow));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_WQ,
+ 	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uwq_object), uverbs_free_wq));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL,
+ 			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_rwq_ind_tbl));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_XRCD,
+ 	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uxrcd_object),
+ 				 uverbs_free_xrcd));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_PD,
+ 			    UVERBS_TYPE_ALLOC_IDR(uverbs_free_pd));
++>>>>>>> 9a119cd59776 (RDMA/uverbs: Get rid of the & in method specifications)
+ 
+ DECLARE_UVERBS_GLOBAL_METHODS(UVERBS_OBJECT_DEVICE);
  
 -DECLARE_UVERBS_OBJECT_TREE(uverbs_default_objects,
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_DEVICE),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_PD),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_MR),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_COMP_CHANNEL),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_CQ),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_QP),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_AH),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_MW),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_SRQ),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_FLOW),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_WQ),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_XRCD),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_FLOW_ACTION),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_DM),
 -			   &UVERBS_OBJECT(UVERBS_OBJECT_COUNTERS));
 +static DECLARE_UVERBS_OBJECT_TREE(uverbs_default_objects,
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_DEVICE),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_PD),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_MR),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_COMP_CHANNEL),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_CQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_QP),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_AH),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_MW),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_SRQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_FLOW),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_WQ),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL),
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_XRCD));
  
  const struct uverbs_object_tree_def *uverbs_default_get_objects(void)
  {
diff --cc drivers/infiniband/core/uverbs_std_types_cq.c
index b0dbae9dd0d7,0aa16868149f..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_cq.c
+++ b/drivers/infiniband/core/uverbs_std_types_cq.c
@@@ -146,25 -147,29 +146,51 @@@ err_event_file
  	return ret;
  };
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_CQ_CREATE,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE, UVERBS_OBJECT_CQ,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
 +			    UVERBS_ATTR_TYPE(u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
 +			UVERBS_OBJECT_COMP_CHANNEL,
 +			UVERBS_ACCESS_READ),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR, UVERBS_ATTR_TYPE(u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_FLAGS, UVERBS_ATTR_TYPE(u32)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE, UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&uverbs_uhw_compat_in, &uverbs_uhw_compat_out);
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_CQ_CREATE,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE,
+ 			UVERBS_OBJECT_CQ,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
+ 		       UVERBS_OBJECT_COMP_CHANNEL,
+ 		       UVERBS_ACCESS_READ),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_FLAGS, UVERBS_ATTR_TYPE(u32)),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	UVERBS_ATTR_UHW());
++>>>>>>> 9a119cd59776 (RDMA/uverbs: Get rid of the & in method specifications)
  
  static int UVERBS_HANDLER(UVERBS_METHOD_CQ_DESTROY)(struct ib_device *ib_dev,
  						    struct ib_uverbs_file *file,
@@@ -191,20 -200,22 +217,36 @@@
  			      sizeof(resp));
  }
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_CQ_DESTROY,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_CQ_HANDLE, UVERBS_OBJECT_CQ,
 +			 UVERBS_ACCESS_DESTROY,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_DESTROY_CQ_RESP,
 +			     UVERBS_ATTR_TYPE(struct ib_uverbs_destroy_cq_resp),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
 +
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_CQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_ucq_object), 0,
 +						      uverbs_free_cq),
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_CQ_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_CQ_HANDLE,
+ 			UVERBS_OBJECT_CQ,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_DESTROY_CQ_RESP,
+ 			    UVERBS_ATTR_TYPE(struct ib_uverbs_destroy_cq_resp),
+ 			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_CQ,
+ 	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_ucq_object), uverbs_free_cq),
+ 
++>>>>>>> 9a119cd59776 (RDMA/uverbs: Get rid of the & in method specifications)
  #if IS_ENABLED(CONFIG_INFINIBAND_EXP_LEGACY_VERBS_NEW_UAPI)
- 			    &UVERBS_METHOD(UVERBS_METHOD_CQ_CREATE),
- 			    &UVERBS_METHOD(UVERBS_METHOD_CQ_DESTROY)
+ 	&UVERBS_METHOD(UVERBS_METHOD_CQ_CREATE),
+ 	&UVERBS_METHOD(UVERBS_METHOD_CQ_DESTROY)
  #endif
- 			   );
- 
+ );
diff --cc drivers/infiniband/hw/mlx5/main.c
index caab7cc36fbe,a0f4361981ab..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -4475,7 -5315,127 +4475,131 @@@ static void mlx5_ib_cleanup_multiport_m
  	mlx5_nic_vport_disable_roce(dev->mdev);
  }
  
++<<<<<<< HEAD
 +static void mlx5_ib_stage_init_cleanup(struct mlx5_ib_dev *dev)
++=======
+ ADD_UVERBS_ATTRIBUTES_SIMPLE(
+ 	mlx5_ib_dm,
+ 	UVERBS_OBJECT_DM,
+ 	UVERBS_METHOD_DM_ALLOC,
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_START_OFFSET,
+ 			    UVERBS_ATTR_TYPE(u64),
+ 			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_PAGE_INDEX,
+ 			    UVERBS_ATTR_TYPE(u16),
+ 			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+ 
+ ADD_UVERBS_ATTRIBUTES_SIMPLE(
+ 	mlx5_ib_flow_action,
+ 	UVERBS_OBJECT_FLOW_ACTION,
+ 	UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_FLOW_ACTION_FLAGS,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+ 
+ #define NUM_TREES	3
+ static int populate_specs_root(struct mlx5_ib_dev *dev)
+ {
+ 	const struct uverbs_object_tree_def *default_root[NUM_TREES + 1] = {
+ 		uverbs_default_get_objects()};
+ 	size_t num_trees = 1;
+ 
+ 	if (mlx5_accel_ipsec_device_caps(dev->mdev) & MLX5_ACCEL_IPSEC_CAP_DEVICE &&
+ 	    !WARN_ON(num_trees >= ARRAY_SIZE(default_root)))
+ 		default_root[num_trees++] = &mlx5_ib_flow_action;
+ 
+ 	if (MLX5_CAP_DEV_MEM(dev->mdev, memic) &&
+ 	    !WARN_ON(num_trees >= ARRAY_SIZE(default_root)))
+ 		default_root[num_trees++] = &mlx5_ib_dm;
+ 
+ 	if (MLX5_CAP_GEN_64(dev->mdev, general_obj_types) &
+ 			    MLX5_GENERAL_OBJ_TYPES_CAP_UCTX &&
+ 	    !WARN_ON(num_trees >= ARRAY_SIZE(default_root)))
+ 		default_root[num_trees++] = mlx5_ib_get_devx_tree();
+ 
+ 	dev->ib_dev.driver_specs_root =
+ 		uverbs_alloc_spec_tree(num_trees, default_root);
+ 
+ 	return PTR_ERR_OR_ZERO(dev->ib_dev.driver_specs_root);
+ }
+ 
+ static void depopulate_specs_root(struct mlx5_ib_dev *dev)
+ {
+ 	uverbs_free_spec_tree(dev->ib_dev.driver_specs_root);
+ }
+ 
+ static int mlx5_ib_read_counters(struct ib_counters *counters,
+ 				 struct ib_counters_read_attr *read_attr,
+ 				 struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_mcounters *mcounters = to_mcounters(counters);
+ 	struct mlx5_read_counters_attr mread_attr = {};
+ 	struct mlx5_ib_flow_counters_desc *desc;
+ 	int ret, i;
+ 
+ 	mutex_lock(&mcounters->mcntrs_mutex);
+ 	if (mcounters->cntrs_max_index > read_attr->ncounters) {
+ 		ret = -EINVAL;
+ 		goto err_bound;
+ 	}
+ 
+ 	mread_attr.out = kcalloc(mcounters->counters_num, sizeof(u64),
+ 				 GFP_KERNEL);
+ 	if (!mread_attr.out) {
+ 		ret = -ENOMEM;
+ 		goto err_bound;
+ 	}
+ 
+ 	mread_attr.hw_cntrs_hndl = mcounters->hw_cntrs_hndl;
+ 	mread_attr.flags = read_attr->flags;
+ 	ret = mcounters->read_counters(counters->device, &mread_attr);
+ 	if (ret)
+ 		goto err_read;
+ 
+ 	/* do the pass over the counters data array to assign according to the
+ 	 * descriptions and indexing pairs
+ 	 */
+ 	desc = mcounters->counters_data;
+ 	for (i = 0; i < mcounters->ncounters; i++)
+ 		read_attr->counters_buff[desc[i].index] += mread_attr.out[desc[i].description];
+ 
+ err_read:
+ 	kfree(mread_attr.out);
+ err_bound:
+ 	mutex_unlock(&mcounters->mcntrs_mutex);
+ 	return ret;
+ }
+ 
+ static int mlx5_ib_destroy_counters(struct ib_counters *counters)
+ {
+ 	struct mlx5_ib_mcounters *mcounters = to_mcounters(counters);
+ 
+ 	counters_clear_description(counters);
+ 	if (mcounters->hw_cntrs_hndl)
+ 		mlx5_fc_destroy(to_mdev(counters->device)->mdev,
+ 				mcounters->hw_cntrs_hndl);
+ 
+ 	kfree(mcounters);
+ 
+ 	return 0;
+ }
+ 
+ static struct ib_counters *mlx5_ib_create_counters(struct ib_device *device,
+ 						   struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_mcounters *mcounters;
+ 
+ 	mcounters = kzalloc(sizeof(*mcounters), GFP_KERNEL);
+ 	if (!mcounters)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	mutex_init(&mcounters->mcntrs_mutex);
+ 
+ 	return &mcounters->ibcntrs;
+ }
+ 
+ void mlx5_ib_stage_init_cleanup(struct mlx5_ib_dev *dev)
++>>>>>>> 9a119cd59776 (RDMA/uverbs: Get rid of the & in method specifications)
  {
  	mlx5_ib_cleanup_multiport_master(dev);
  #ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
diff --cc include/rdma/uverbs_ioctl.h
index 2cc45699a237,d21c29a0f8ec..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -214,110 -208,78 +214,167 @@@ struct uverbs_object_tree_def 
  #define UVERBS_ATTR_MIN_SIZE(_min_len)				\
  	UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
  
++<<<<<<< HEAD
 +/*
 + * In new compiler, UVERBS_ATTR could be simplified by declaring it as
 + * [_id] = {.type = _type, .len = _len, ##__VA_ARGS__}
 + * But since we support older compilers too, we need the more complex code.
 + */
 +#define UVERBS_ATTR(_id, _type, _fld, _attr, ...)			\
 +	__UVERBS_ATTR(_id, _type, _fld, _attr, ##__VA_ARGS__, 2, 1, 0)
 +#define UVERBS_ATTR_PTR_IN_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_IN, ptr, _len, ##__VA_ARGS__)
 +/* If sizeof(_type) <= sizeof(u64), this will be inlined rather than a pointer */
 +#define UVERBS_ATTR_PTR_IN(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_IN_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_OUT, ptr, _len, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_OUT_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_ENUM_IN(_id, _enum_arr, ...)			\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_ENUM_IN, enum_def,		\
 +		    .ids = (_enum_arr),					\
 +		    .num_elems = ARRAY_SIZE(_enum_arr), ##__VA_ARGS__)
++=======
+ /* Must be used in the '...' of any UVERBS_ATTR */
+ #define UA_FLAGS(_flags) .flags = _flags
+ 
+ #define UVERBS_ATTR_IDR(_attr_id, _idr_type, _access, ...)                     \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_IDR,                        \
+ 			  .u.obj.obj_type = _idr_type,                         \
+ 			  .u.obj.access = _access,                             \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_FD(_attr_id, _fd_type, _access, ...)                       \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = (_attr_id) +                                             \
+ 		      BUILD_BUG_ON_ZERO((_access) != UVERBS_ACCESS_NEW &&      \
+ 					(_access) != UVERBS_ACCESS_READ),      \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_FD,                         \
+ 			  .u.obj.obj_type = _fd_type,                          \
+ 			  .u.obj.access = _access,                             \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_PTR_IN(_attr_id, _type, ...)                               \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_PTR_IN,                     \
+ 			  _type,                                               \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_PTR_OUT(_attr_id, _type, ...)                              \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_PTR_OUT,                    \
+ 			  _type,                                               \
+ 			  __VA_ARGS__ } })
+ 
+ /* _enum_arry should be a 'static const union uverbs_attr_spec[]' */
+ #define UVERBS_ATTR_ENUM_IN(_attr_id, _enum_arr, ...)                          \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_ENUM_IN,                    \
+ 			  .u2.enum_def.ids = _enum_arr,                        \
+ 			  .u.enum_def.num_elems = ARRAY_SIZE(_enum_arr),       \
+ 			  __VA_ARGS__ },                                       \
+ 	})
++>>>>>>> 9a119cd59776 (RDMA/uverbs: Get rid of the & in method specifications)
  
  /*
 - * This spec is used in order to pass information to the hardware driver in a
 - * legacy way. Every verb that could get driver specific data should get this
 - * spec.
 + * In new compiler, UVERBS_ATTR_IDR (and FD) could be simplified by declaring
 + * it as
 + * {.id = _id,								\
 + *  .attr {.type = __obj_class,						\
 + *         .obj = {.obj_type = _idr_type,				\
 + *                       .access = _access                              \
 + *                }, ##__VA_ARGS__ } }
 + * But since we support older compilers too, we need the more complex code.
   */
++<<<<<<< HEAD
 +#define ___UVERBS_ATTR_OBJ0(_id, _obj_class, _obj_type, _access, ...)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	 .attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			    .access = _access, .flags = 0 } }, } })
 +#define ___UVERBS_ATTR_OBJ1(_id, _obj_class, _obj_type, _access, _flags)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	.attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			   .access = _access, _flags} }, } })
 +#define ___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, _flags, \
 +			   _n, ...)					\
 +	___UVERBS_ATTR_OBJ##_n(_id, _obj_class, _obj_type, _access, _flags)
 +#define __UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, ...)	\
 +	___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access,		\
 +			   ##__VA_ARGS__, 1, 0)
 +#define UVERBS_ATTR_IDR(_id, _idr_type, _access, ...)			 \
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_IDR, _idr_type, _access,\
 +			  ##__VA_ARGS__)
 +#define UVERBS_ATTR_FD(_id, _fd_type, _access, ...)			\
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_FD, _fd_type,		\
 +			  (_access) + BUILD_BUG_ON_ZERO(		\
 +				(_access) != UVERBS_ACCESS_NEW &&	\
 +				(_access) != UVERBS_ACCESS_READ),	\
 +			  ##__VA_ARGS__)
 +#define DECLARE_UVERBS_ATTR_SPEC(_name, ...)				\
 +	const struct uverbs_attr_def _name = __VA_ARGS__
++=======
+ #define UVERBS_ATTR_UHW()                                                      \
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_UHW_IN,                                 \
+ 			   UVERBS_ATTR_SIZE(0, USHRT_MAX),		       \
+ 			   UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO)),       \
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_UHW_OUT,                               \
+ 			    UVERBS_ATTR_SIZE(0, USHRT_MAX),		       \
+ 			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO))
++>>>>>>> 9a119cd59776 (RDMA/uverbs: Get rid of the & in method specifications)
  
 -/*
 - * =======================================
 - *	Declaration helpers
 - * =======================================
 - */
 -
 -#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)                                 \
 -	static const struct uverbs_object_def *const _name##_ptr[] = {         \
 -		__VA_ARGS__,                                                   \
 -	};                                                                     \
 -	static const struct uverbs_object_tree_def _name = {                   \
 -		.num_objects = ARRAY_SIZE(_name##_ptr),                        \
 -		.objects = &_name##_ptr,                                       \
 +#define DECLARE_UVERBS_ENUM(_name, ...)					\
 +	const struct uverbs_enum_spec _name = {				\
 +		.len = ARRAY_SIZE(((struct uverbs_attr_spec[]){__VA_ARGS__})),\
 +		.ids = {__VA_ARGS__},					\
  	}
 +#define _UVERBS_METHOD_ATTRS_SZ(...)					\
 +	(sizeof((const struct uverbs_attr_def * const []){__VA_ARGS__}) /\
 +	 sizeof(const struct uverbs_attr_def *))
 +#define _UVERBS_METHOD(_id, _handler, _flags, ...)			\
 +	((const struct uverbs_method_def) {				\
 +	 .id = _id,							\
 +	 .flags = _flags,						\
 +	 .handler = _handler,						\
 +	 .num_attrs = _UVERBS_METHOD_ATTRS_SZ(__VA_ARGS__),		\
 +	 .attrs = &(const struct uverbs_attr_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_METHOD(_name, _id, _handler, ...)		\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler, 0, ##__VA_ARGS__)
 +#define DECLARE_UVERBS_CTX_METHOD(_name, _id, _handler, _flags, ...)	\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler,				\
 +			       UVERBS_ACTION_FLAG_CREATE_ROOT,		\
 +			       ##__VA_ARGS__)
 +#define _UVERBS_OBJECT_METHODS_SZ(...)					\
 +	(sizeof((const struct uverbs_method_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_method_def *))
 +#define _UVERBS_OBJECT(_id, _type_attrs, ...)				\
 +	((const struct uverbs_object_def) {				\
 +	 .id = _id,							\
 +	 .type_attrs = _type_attrs,					\
 +	 .num_methods = _UVERBS_OBJECT_METHODS_SZ(__VA_ARGS__),		\
 +	 .methods = &(const struct uverbs_method_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT(_name, _id, _type_attrs, ...)		\
 +	const struct uverbs_object_def _name =				\
 +		_UVERBS_OBJECT(_id, _type_attrs, ##__VA_ARGS__)
 +#define _UVERBS_TREE_OBJECTS_SZ(...)					\
 +	(sizeof((const struct uverbs_object_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_object_def *))
 +#define _UVERBS_OBJECT_TREE(...)					\
 +	((const struct uverbs_object_tree_def) {			\
 +	 .num_objects = _UVERBS_TREE_OBJECTS_SZ(__VA_ARGS__),		\
 +	 .objects = &(const struct uverbs_object_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)				\
 +	const struct uverbs_object_tree_def _name =			\
 +		_UVERBS_OBJECT_TREE(__VA_ARGS__)
  
  /* =================================================
   *              Parsing infrastructure
diff --cc include/rdma/uverbs_named_ioctl.h
index 228421f2a427,2eb1767042af..000000000000
--- a/include/rdma/uverbs_named_ioctl.h
+++ b/include/rdma/uverbs_named_ioctl.h
@@@ -45,50 -45,82 +45,73 @@@
  #define UVERBS_HANDLER(id)	_UVERBS_NAME(UVERBS_MODULE_NAME, _handler_##id)
  #define UVERBS_OBJECT(id)	_UVERBS_NAME(UVERBS_MOUDLE_NAME, _object_##id)
  
 -/* These are static so they do not need to be qualified */
 -#define UVERBS_METHOD_ATTRS(method_id) _method_attrs_##method_id
 -#define UVERBS_OBJECT_METHODS(object_id) _object_methods_##object_id
 +#define DECLARE_UVERBS_NAMED_METHOD(id, ...)	\
 +	DECLARE_UVERBS_METHOD(UVERBS_METHOD(id), id, UVERBS_HANDLER(id), ##__VA_ARGS__)
  
 -#define DECLARE_UVERBS_NAMED_METHOD(_method_id, ...)                           \
 -	static const struct uverbs_attr_def *const UVERBS_METHOD_ATTRS(        \
 -		_method_id)[] = { __VA_ARGS__ };                               \
 -	static const struct uverbs_method_def UVERBS_METHOD(_method_id) = {    \
 -		.id = _method_id,                                              \
 -		.handler = UVERBS_HANDLER(_method_id),                         \
 -		.num_attrs = ARRAY_SIZE(UVERBS_METHOD_ATTRS(_method_id)),      \
 -		.attrs = &UVERBS_METHOD_ATTRS(_method_id),                     \
 -	}
 +#define DECLARE_UVERBS_NAMED_METHOD_WITH_HANDLER(id, handler, ...)	\
 +	DECLARE_UVERBS_METHOD(UVERBS_METHOD(id), id, handler, ##__VA_ARGS__)
  
 -/* Create a standard destroy method using the default handler. The handle_attr
 - * argument must be the attribute specifying the handle to destroy, the
 - * default handler does not support any other attributes.
 - */
 -#define DECLARE_UVERBS_NAMED_METHOD_DESTROY(_method_id, _handle_attr)          \
 -	static const struct uverbs_attr_def *const UVERBS_METHOD_ATTRS(        \
 -		_method_id)[] = { _handle_attr };                              \
 -	static const struct uverbs_method_def UVERBS_METHOD(_method_id) = {    \
 -		.id = _method_id,                                              \
 -		.handler = uverbs_destroy_def_handler,                         \
 -		.num_attrs = ARRAY_SIZE(UVERBS_METHOD_ATTRS(_method_id)),      \
 -		.attrs = &UVERBS_METHOD_ATTRS(_method_id),                     \
 -	}
 +#define DECLARE_UVERBS_NAMED_METHOD_NO_OVERRIDE(id, handler, ...)	\
 +	DECLARE_UVERBS_METHOD(UVERBS_METHOD(id), id, NULL, ##__VA_ARGS__)
  
++<<<<<<< HEAD
 +#define DECLARE_UVERBS_NAMED_OBJECT(id, ...)	\
 +	DECLARE_UVERBS_OBJECT(UVERBS_OBJECT(id), id, ##__VA_ARGS__)
++=======
+ #define DECLARE_UVERBS_NAMED_OBJECT(_object_id, _type_attrs, ...)              \
+ 	static const struct uverbs_method_def *const UVERBS_OBJECT_METHODS(    \
+ 		_object_id)[] = { __VA_ARGS__ };                               \
+ 	const struct uverbs_object_def UVERBS_OBJECT(_object_id) = {           \
+ 		.id = _object_id,                                              \
+ 		.type_attrs = &_type_attrs,                                    \
+ 		.num_methods = ARRAY_SIZE(UVERBS_OBJECT_METHODS(_object_id)),  \
+ 		.methods = &UVERBS_OBJECT_METHODS(_object_id)                  \
+ 	}
++>>>>>>> 9a119cd59776 (RDMA/uverbs: Get rid of the & in method specifications)
  
- #define DECLARE_UVERBS_GLOBAL_METHODS(_name, ...)	\
- 	DECLARE_UVERBS_NAMED_OBJECT(_name, NULL, ##__VA_ARGS__)
+ /*
+  * Declare global methods. These still have a unique object_id because we
+  * identify all uapi methods with a (object,method) tuple. However, they have
+  * no type pointer.
+  */
+ #define DECLARE_UVERBS_GLOBAL_METHODS(_object_id, ...)	\
+ 	static const struct uverbs_method_def *const UVERBS_OBJECT_METHODS(    \
+ 		_object_id)[] = { __VA_ARGS__ };                               \
+ 	const struct uverbs_object_def UVERBS_OBJECT(_object_id) = {           \
+ 		.id = _object_id,                                              \
+ 		.num_methods = ARRAY_SIZE(UVERBS_OBJECT_METHODS(_object_id)),  \
+ 		.methods = &UVERBS_OBJECT_METHODS(_object_id)                  \
+ 	}
  
 -/* Used by drivers to declare a complete parsing tree for a single method that
 - * differs only in having additional driver specific attributes.
 +#define _UVERBS_COMP_NAME(x, y, z) _UVERBS_NAME(_UVERBS_NAME(x, y), z)
 +
 +#define UVERBS_NO_OVERRIDE	NULL
 +
 +/* This declares a parsing tree with one object and one method. This is usually
 + * used for merging driver attributes to the common attributes. The driver has
 + * a chance to override the handler and type attrs of the original object.
 + * The __VA_ARGS__ just contains a list of attributes.
   */
 -#define ADD_UVERBS_ATTRIBUTES_SIMPLE(_name, _object_id, _method_id, ...)       \
 -	static const struct uverbs_attr_def *const UVERBS_METHOD_ATTRS(        \
 -		_method_id)[] = { __VA_ARGS__ };                               \
 -	static const struct uverbs_method_def UVERBS_METHOD(_method_id) = {    \
 -		.id = _method_id,                                              \
 -		.num_attrs = ARRAY_SIZE(UVERBS_METHOD_ATTRS(_method_id)),      \
 -		.attrs = &UVERBS_METHOD_ATTRS(_method_id),                     \
 -	};                                                                     \
 -	static const struct uverbs_method_def *const UVERBS_OBJECT_METHODS(    \
 -		_object_id)[] = { &UVERBS_METHOD(_method_id) };                \
 -	static const struct uverbs_object_def _name##_struct = {               \
 -		.id = _object_id,                                              \
 -		.num_methods = 1,                                              \
 -		.methods = &UVERBS_OBJECT_METHODS(_object_id)                  \
 -	};                                                                     \
 -	static const struct uverbs_object_def *const _name##_ptrs[] = {        \
 -		&_name##_struct,                                               \
 -	};                                                                     \
 -	static const struct uverbs_object_tree_def _name = {                   \
 -		.num_objects = 1,                                              \
 -		.objects = &_name##_ptrs,                                      \
 -	}
 +#define ADD_UVERBS_ATTRIBUTES(_name, _object, _method, _type_attrs, _handler, ...) \
 +static DECLARE_UVERBS_METHOD(_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,	     \
 +					       _method_, _name),	     \
 +			     _method, _handler, ##__VA_ARGS__);		     \
 +									     \
 +static DECLARE_UVERBS_OBJECT(_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,	     \
 +					       _object_, _name),	     \
 +			     _object, _type_attrs,			     \
 +			     &_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,	     \
 +					       _method_, _name));	     \
 +									     \
 +static DECLARE_UVERBS_OBJECT_TREE(_name,				     \
 +				  &_UVERBS_COMP_NAME(UVERBS_MODULE_NAME,     \
 +						     _object_, _name))
 +
 +/* A very common use case is that the driver doesn't override the handler and
 + * type_attrs. Therefore, we provide a simplified macro for this common case.
 + */
 +#define ADD_UVERBS_ATTRIBUTES_SIMPLE(_name, _object, _method, ...)	     \
 +	ADD_UVERBS_ATTRIBUTES(_name, _object, _method, UVERBS_NO_OVERRIDE,   \
 +			      UVERBS_NO_OVERRIDE, ##__VA_ARGS__)
  
  #endif
* Unmerged path drivers/infiniband/core/uverbs_std_types_counters.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_dm.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_flow_action.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/core/uverbs_std_types.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_counters.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_cq.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_dm.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_flow_action.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path include/rdma/uverbs_ioctl.h
* Unmerged path include/rdma/uverbs_named_ioctl.h
