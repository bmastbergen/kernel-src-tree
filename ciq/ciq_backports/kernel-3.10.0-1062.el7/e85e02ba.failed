net/mlx5: E-Switch, Rename esw attr mirror count field

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Rename esw attr mirror count field (Alaa Hleihel) [1642383 1642498]
Rebuild_FUZZ: 96.15%
commit-author Eli Britstein <elibr@mellanox.com>
commit e85e02bad29e822c3ebde80e7c9e7428329c4a5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e85e02ba.failed

The mirror count esw attributes field is used to determine if splitting
the rule to two FTEs is required while programming e-switch mirroring.
Rename it to split count, making it clearer with no functional change.

	Signed-off-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit e85e02bad29e822c3ebde80e7c9e7428329c4a5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index fbb4f1b36627,342f807543a0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -811,30 -823,119 +811,100 @@@ static int mlx5e_attach_encap(struct ml
  			      struct ip_tunnel_info *tun_info,
  			      struct net_device *mirred_dev,
  			      struct net_device **encap_dev,
 -			      struct mlx5e_tc_flow *flow,
 -			      struct netlink_ext_ack *extack);
 +			      struct mlx5e_tc_flow *flow);
  
  static struct mlx5_flow_handle *
++<<<<<<< HEAD
++=======
+ mlx5e_tc_offload_fdb_rules(struct mlx5_eswitch *esw,
+ 			   struct mlx5e_tc_flow *flow,
+ 			   struct mlx5_flow_spec *spec,
+ 			   struct mlx5_esw_flow_attr *attr)
+ {
+ 	struct mlx5_flow_handle *rule;
+ 
+ 	rule = mlx5_eswitch_add_offloaded_rule(esw, spec, attr);
+ 	if (IS_ERR(rule))
+ 		return rule;
+ 
+ 	if (attr->split_count) {
+ 		flow->rule[1] = mlx5_eswitch_add_fwd_rule(esw, spec, attr);
+ 		if (IS_ERR(flow->rule[1])) {
+ 			mlx5_eswitch_del_offloaded_rule(esw, rule, attr);
+ 			return flow->rule[1];
+ 		}
+ 	}
+ 
+ 	flow->flags |= MLX5E_TC_FLOW_OFFLOADED;
+ 	return rule;
+ }
+ 
+ static void
+ mlx5e_tc_unoffload_fdb_rules(struct mlx5_eswitch *esw,
+ 			     struct mlx5e_tc_flow *flow,
+ 			   struct mlx5_esw_flow_attr *attr)
+ {
+ 	flow->flags &= ~MLX5E_TC_FLOW_OFFLOADED;
+ 
+ 	if (attr->split_count)
+ 		mlx5_eswitch_del_fwd_rule(esw, flow->rule[1], attr);
+ 
+ 	mlx5_eswitch_del_offloaded_rule(esw, flow->rule[0], attr);
+ }
+ 
+ static struct mlx5_flow_handle *
+ mlx5e_tc_offload_to_slow_path(struct mlx5_eswitch *esw,
+ 			      struct mlx5e_tc_flow *flow,
+ 			      struct mlx5_flow_spec *spec,
+ 			      struct mlx5_esw_flow_attr *slow_attr)
+ {
+ 	struct mlx5_flow_handle *rule;
+ 
+ 	memcpy(slow_attr, flow->esw_attr, sizeof(*slow_attr));
+ 	slow_attr->action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,
+ 	slow_attr->split_count = 0,
+ 	slow_attr->dest_chain = FDB_SLOW_PATH_CHAIN,
+ 
+ 	rule = mlx5e_tc_offload_fdb_rules(esw, flow, spec, slow_attr);
+ 	if (!IS_ERR(rule))
+ 		flow->flags |= MLX5E_TC_FLOW_SLOW;
+ 
+ 	return rule;
+ }
+ 
+ static void
+ mlx5e_tc_unoffload_from_slow_path(struct mlx5_eswitch *esw,
+ 				  struct mlx5e_tc_flow *flow,
+ 				  struct mlx5_esw_flow_attr *slow_attr)
+ {
+ 	memcpy(slow_attr, flow->esw_attr, sizeof(*slow_attr));
+ 	mlx5e_tc_unoffload_fdb_rules(esw, flow, slow_attr);
+ 	flow->flags &= ~MLX5E_TC_FLOW_SLOW;
+ }
+ 
+ static int
++>>>>>>> e85e02bad29e (net/mlx5: E-Switch, Rename esw attr mirror count field)
  mlx5e_tc_add_fdb_flow(struct mlx5e_priv *priv,
  		      struct mlx5e_tc_flow_parse_attr *parse_attr,
 -		      struct mlx5e_tc_flow *flow,
 -		      struct netlink_ext_ack *extack)
 +		      struct mlx5e_tc_flow *flow)
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
 -	u32 max_chain = mlx5_eswitch_get_chain_range(esw);
  	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
 -	u16 max_prio = mlx5_eswitch_get_prio_range(esw);
  	struct net_device *out_dev, *encap_dev = NULL;
 -	struct mlx5_fc *counter = NULL;
 +	struct mlx5_flow_handle *rule = NULL;
  	struct mlx5e_rep_priv *rpriv;
  	struct mlx5e_priv *out_priv;
 -	int err = 0, encap_err = 0;
 -
 -	/* if prios are not supported, keep the old behaviour of using same prio
 -	 * for all offloaded rules.
 -	 */
 -	if (!mlx5_eswitch_prios_supported(esw))
 -		attr->prio = 1;
 -
 -	if (attr->chain > max_chain) {
 -		NL_SET_ERR_MSG(extack, "Requested chain is out of supported range");
 -		err = -EOPNOTSUPP;
 -		goto err_max_prio_chain;
 -	}
 -
 -	if (attr->prio > max_prio) {
 -		NL_SET_ERR_MSG(extack, "Requested priority is out of supported range");
 -		err = -EOPNOTSUPP;
 -		goto err_max_prio_chain;
 -	}
 +	int err;
  
 -	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT) {
 +	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_ENCAP) {
  		out_dev = __dev_get_by_index(dev_net(priv->netdev),
  					     attr->parse_attr->mirred_ifindex);
 -		encap_err = mlx5e_attach_encap(priv, &parse_attr->tun_info,
 -					       out_dev, &encap_dev, flow,
 -					       extack);
 -		if (encap_err && encap_err != -EAGAIN) {
 -			err = encap_err;
 -			goto err_attach_encap;
 +		err = mlx5e_attach_encap(priv, &parse_attr->tun_info,
 +					 out_dev, &encap_dev, flow);
 +		if (err) {
 +			rule = ERR_PTR(err);
 +			if (err != -EAGAIN)
 +				goto err_attach_encap;
  		}
  		out_priv = netdev_priv(encap_dev);
  		rpriv = out_priv->ppriv;
@@@ -2594,11 -2413,21 +2664,27 @@@ static int parse_tc_fdb_actions(struct 
  	attr->in_rep = rpriv->rep;
  	attr->in_mdev = priv->mdev;
  
 -	tcf_exts_for_each_action(i, a, exts) {
 +	tcf_exts_to_list(exts, &actions);
 +	list_for_each_entry(a, &actions, list) {
  		if (is_tcf_gact_shot(a)) {
++<<<<<<< HEAD
 +			attr->action |= MLX5_FLOW_CONTEXT_ACTION_DROP |
 +					MLX5_FLOW_CONTEXT_ACTION_COUNT;
++=======
+ 			action |= MLX5_FLOW_CONTEXT_ACTION_DROP |
+ 				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
+ 			continue;
+ 		}
+ 
+ 		if (is_tcf_pedit(a)) {
+ 			err = parse_tc_pedit_action(priv, a, MLX5_FLOW_NAMESPACE_FDB,
+ 						    parse_attr, extack);
+ 			if (err)
+ 				return err;
+ 
+ 			action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
+ 			attr->split_count = attr->out_count;
++>>>>>>> e85e02bad29e (net/mlx5: E-Switch, Rename esw attr mirror count field)
  			continue;
  		}
  
@@@ -2658,27 -2501,17 +2744,40 @@@
  				encap = true;
  			else
  				return -EOPNOTSUPP;
++<<<<<<< HEAD
++=======
+ 			attr->split_count = attr->out_count;
++>>>>>>> e85e02bad29e (net/mlx5: E-Switch, Rename esw attr mirror count field)
  			continue;
  		}
  
  		if (is_tcf_vlan(a)) {
++<<<<<<< HEAD
 +			if (tcf_vlan_action(a) == TCA_VLAN_ACT_POP) {
 +				attr->action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
 +			} else if (tcf_vlan_action(a) == TCA_VLAN_ACT_PUSH) {
 +				attr->action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;
 +				attr->vlan_vid = tcf_vlan_push_vid(a);
 +				if (mlx5_eswitch_vlan_actions_supported(priv->mdev)) {
 +					attr->vlan_prio = tcf_vlan_push_prio(a);
 +					attr->vlan_proto = tcf_vlan_push_proto(a);
 +					if (!attr->vlan_proto)
 +						attr->vlan_proto = htons(ETH_P_8021Q);
 +				} else if (tcf_vlan_push_proto(a) != htons(ETH_P_8021Q) ||
 +					   tcf_vlan_push_prio(a)) {
 +					return -EOPNOTSUPP;
 +				}
 +			} else { /* action is TCA_VLAN_ACT_MODIFY */
 +				return -EOPNOTSUPP;
 +			}
++=======
+ 			err = parse_tc_vlan_action(priv, a, attr, &action);
+ 
+ 			if (err)
+ 				return err;
+ 
+ 			attr->split_count = attr->out_count;
++>>>>>>> e85e02bad29e (net/mlx5: E-Switch, Rename esw attr mirror count field)
  			continue;
  		}
  
@@@ -2690,9 -2542,17 +2789,19 @@@
  		return -EINVAL;
  	}
  
 -	attr->action = action;
 -	if (!actions_match_supported(priv, exts, parse_attr, flow, extack))
 +	if (!actions_match_supported(priv, exts, parse_attr, flow))
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
++=======
+ 	if (attr->split_count > 0 && !mlx5_esw_has_fwd_fdb(priv->mdev)) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "current firmware doesn't support split rule for port mirroring");
+ 		netdev_warn_once(priv->netdev, "current firmware doesn't support split rule for port mirroring\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
++>>>>>>> e85e02bad29e (net/mlx5: E-Switch, Rename esw attr mirror count field)
  	return 0;
  }
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 21bc97b70ed9,c28ff6487dfd..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -241,16 -278,23 +241,22 @@@ enum mlx5_flow_match_level 
  	MLX5_MATCH_L4	= MLX5_INLINE_MODE_TCP_UDP,
  };
  
 -/* current maximum for flow based vport multicasting */
 -#define MLX5_MAX_FLOW_FWD_VPORTS 2
 -
  struct mlx5_esw_flow_attr {
  	struct mlx5_eswitch_rep *in_rep;
 -	struct mlx5_eswitch_rep *out_rep[MLX5_MAX_FLOW_FWD_VPORTS];
 -	struct mlx5_core_dev	*out_mdev[MLX5_MAX_FLOW_FWD_VPORTS];
 +	struct mlx5_eswitch_rep *out_rep;
 +	struct mlx5_core_dev	*out_mdev;
  	struct mlx5_core_dev	*in_mdev;
  
++<<<<<<< HEAD
++=======
+ 	int split_count;
+ 	int out_count;
+ 
++>>>>>>> e85e02bad29e (net/mlx5: E-Switch, Rename esw attr mirror count field)
  	int	action;
 -	__be16	vlan_proto[MLX5_FS_VLAN_DEPTH];
 -	u16	vlan_vid[MLX5_FS_VLAN_DEPTH];
 -	u8	vlan_prio[MLX5_FS_VLAN_DEPTH];
 -	u8	total_vlan;
 +	__be16	vlan_proto;
 +	u16	vlan_vid;
 +	u8	vlan_prio;
  	bool	vlan_handled;
  	u32	encap_id;
  	u32	mod_hdr_id;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 84864631953e,63ac9d3d1690..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -48,12 -79,13 +48,18 @@@ mlx5_eswitch_add_offloaded_rule(struct 
  				struct mlx5_flow_spec *spec,
  				struct mlx5_esw_flow_attr *attr)
  {
++<<<<<<< HEAD
 +	struct mlx5_flow_destination dest[2] = {};
 +	struct mlx5_flow_act flow_act = {0};
 +	struct mlx5_fc *counter = NULL;
++=======
+ 	struct mlx5_flow_destination dest[MLX5_MAX_FLOW_FWD_VPORTS + 1] = {};
+ 	struct mlx5_flow_act flow_act = { .flags = FLOW_ACT_NO_APPEND, };
+ 	bool split = !!(attr->split_count);
++>>>>>>> e85e02bad29e (net/mlx5: E-Switch, Rename esw attr mirror count field)
  	struct mlx5_flow_handle *rule;
 -	struct mlx5_flow_table *fdb;
 -	int j, i = 0;
  	void *misc;
 +	int i = 0;
  
  	if (esw->mode != SRIOV_OFFLOADS)
  		return ERR_PTR(-EOPNOTSUPP);
@@@ -70,23 -107,34 +76,49 @@@
  	}
  
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {
++<<<<<<< HEAD
 +		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
 +		dest[i].vport.num = attr->out_rep->vport;
 +		if (MLX5_CAP_ESW(esw->dev, merged_eswitch)) {
 +			dest[i].vport.vhca_id =
 +				MLX5_CAP_GEN(attr->out_mdev, vhca_id);
 +			dest[i].vport.vhca_id_valid = 1;
++=======
+ 		if (attr->dest_chain) {
+ 			struct mlx5_flow_table *ft;
+ 
+ 			ft = esw_get_prio_table(esw, attr->dest_chain, 1, 0);
+ 			if (IS_ERR(ft)) {
+ 				rule = ERR_CAST(ft);
+ 				goto err_create_goto_table;
+ 			}
+ 
+ 			dest[i].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 			dest[i].ft = ft;
+ 			i++;
+ 		} else {
+ 			for (j = attr->split_count; j < attr->out_count; j++) {
+ 				dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
+ 				dest[i].vport.num = attr->out_rep[j]->vport;
+ 				dest[i].vport.vhca_id =
+ 					MLX5_CAP_GEN(attr->out_mdev[j], vhca_id);
+ 				if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 					dest[i].vport.flags |=
+ 						MLX5_FLOW_DEST_VPORT_VHCA_ID;
+ 				i++;
+ 			}
++>>>>>>> e85e02bad29e (net/mlx5: E-Switch, Rename esw attr mirror count field)
  		}
 +		i++;
  	}
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {
 +		counter = mlx5_fc_create(esw->dev, true);
 +		if (IS_ERR(counter)) {
 +			rule = ERR_CAST(counter);
 +			goto err_counter_alloc;
 +		}
  		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;
 -		dest[i].counter_id = mlx5_fc_id(attr->counter);
 +		dest[i].counter = counter;
  		i++;
  	}
  
@@@ -116,11 -164,16 +148,21 @@@
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
  		flow_act.modify_id = attr->mod_hdr_id;
  
 -	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT)
 -		flow_act.reformat_id = attr->encap_id;
 +	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_ENCAP)
 +		flow_act.encap_id = attr->encap_id;
  
++<<<<<<< HEAD
 +	rule = mlx5_add_flow_rules((struct mlx5_flow_table *)esw->fdb_table.offloads.fast_fdb,
 +				   spec, &flow_act, dest, i);
++=======
+ 	fdb = esw_get_prio_table(esw, attr->chain, attr->prio, !!split);
+ 	if (IS_ERR(fdb)) {
+ 		rule = ERR_CAST(fdb);
+ 		goto err_esw_get;
+ 	}
+ 
+ 	rule = mlx5_add_flow_rules(fdb, spec, &flow_act, dest, i);
++>>>>>>> e85e02bad29e (net/mlx5: E-Switch, Rename esw attr mirror count field)
  	if (IS_ERR(rule))
  		goto err_add_rule;
  	else
@@@ -129,11 -182,109 +171,117 @@@
  	return rule;
  
  err_add_rule:
++<<<<<<< HEAD
 +	mlx5_fc_destroy(esw->dev, counter);
 +err_counter_alloc:
 +	return rule;
 +}
 +
++=======
+ 	esw_put_prio_table(esw, attr->chain, attr->prio, !!split);
+ err_esw_get:
+ 	if (attr->dest_chain)
+ 		esw_put_prio_table(esw, attr->dest_chain, 1, 0);
+ err_create_goto_table:
+ 	return rule;
+ }
+ 
+ struct mlx5_flow_handle *
+ mlx5_eswitch_add_fwd_rule(struct mlx5_eswitch *esw,
+ 			  struct mlx5_flow_spec *spec,
+ 			  struct mlx5_esw_flow_attr *attr)
+ {
+ 	struct mlx5_flow_destination dest[MLX5_MAX_FLOW_FWD_VPORTS + 1] = {};
+ 	struct mlx5_flow_act flow_act = { .flags = FLOW_ACT_NO_APPEND, };
+ 	struct mlx5_flow_table *fast_fdb;
+ 	struct mlx5_flow_table *fwd_fdb;
+ 	struct mlx5_flow_handle *rule;
+ 	void *misc;
+ 	int i;
+ 
+ 	fast_fdb = esw_get_prio_table(esw, attr->chain, attr->prio, 0);
+ 	if (IS_ERR(fast_fdb)) {
+ 		rule = ERR_CAST(fast_fdb);
+ 		goto err_get_fast;
+ 	}
+ 
+ 	fwd_fdb = esw_get_prio_table(esw, attr->chain, attr->prio, 1);
+ 	if (IS_ERR(fwd_fdb)) {
+ 		rule = ERR_CAST(fwd_fdb);
+ 		goto err_get_fwd;
+ 	}
+ 
+ 	flow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
+ 	for (i = 0; i < attr->split_count; i++) {
+ 		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
+ 		dest[i].vport.num = attr->out_rep[i]->vport;
+ 		dest[i].vport.vhca_id =
+ 			MLX5_CAP_GEN(attr->out_mdev[i], vhca_id);
+ 		if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 			dest[i].vport.flags |= MLX5_FLOW_DEST_VPORT_VHCA_ID;
+ 	}
+ 	dest[i].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 	dest[i].ft = fwd_fdb,
+ 	i++;
+ 
+ 	misc = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters);
+ 	MLX5_SET(fte_match_set_misc, misc, source_port, attr->in_rep->vport);
+ 
+ 	if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 		MLX5_SET(fte_match_set_misc, misc,
+ 			 source_eswitch_owner_vhca_id,
+ 			 MLX5_CAP_GEN(attr->in_mdev, vhca_id));
+ 
+ 	misc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);
+ 	MLX5_SET_TO_ONES(fte_match_set_misc, misc, source_port);
+ 	if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 		MLX5_SET_TO_ONES(fte_match_set_misc, misc,
+ 				 source_eswitch_owner_vhca_id);
+ 
+ 	if (attr->match_level == MLX5_MATCH_NONE)
+ 		spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS;
+ 	else
+ 		spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS |
+ 					      MLX5_MATCH_MISC_PARAMETERS;
+ 
+ 	rule = mlx5_add_flow_rules(fast_fdb, spec, &flow_act, dest, i);
+ 
+ 	if (IS_ERR(rule))
+ 		goto add_err;
+ 
+ 	esw->offloads.num_flows++;
+ 
+ 	return rule;
+ add_err:
+ 	esw_put_prio_table(esw, attr->chain, attr->prio, 1);
+ err_get_fwd:
+ 	esw_put_prio_table(esw, attr->chain, attr->prio, 0);
+ err_get_fast:
+ 	return rule;
+ }
+ 
+ static void
+ __mlx5_eswitch_del_rule(struct mlx5_eswitch *esw,
+ 			struct mlx5_flow_handle *rule,
+ 			struct mlx5_esw_flow_attr *attr,
+ 			bool fwd_rule)
+ {
+ 	bool split = (attr->split_count > 0);
+ 
+ 	mlx5_del_flow_rules(rule);
+ 	esw->offloads.num_flows--;
+ 
+ 	if (fwd_rule)  {
+ 		esw_put_prio_table(esw, attr->chain, attr->prio, 1);
+ 		esw_put_prio_table(esw, attr->chain, attr->prio, 0);
+ 	} else {
+ 		esw_put_prio_table(esw, attr->chain, attr->prio, !!split);
+ 		if (attr->dest_chain)
+ 			esw_put_prio_table(esw, attr->dest_chain, 1, 0);
+ 	}
+ }
+ 
++>>>>>>> e85e02bad29e (net/mlx5: E-Switch, Rename esw attr mirror count field)
  void
  mlx5_eswitch_del_offloaded_rule(struct mlx5_eswitch *esw,
  				struct mlx5_flow_handle *rule,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
