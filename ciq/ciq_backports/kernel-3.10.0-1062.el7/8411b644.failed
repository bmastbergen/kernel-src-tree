netfilter: nf_tables: support for set flushing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 8411b6442e59810fe0750a2f321b9dcb7d0a3d17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/8411b644.failed

This patch adds support for set flushing, that consists of walking over
the set elements if the NFTA_SET_ELEM_LIST_ELEMENTS attribute is set.
This patch requires the following changes:

1) Add set->ops->deactivate_one() operation: This allows us to
   deactivate an element from the set element walk path, given we can
   skip the lookup that happens in ->deactivate().

2) Add a new nft_trans_alloc_gfp() function since we need to allocate
   transactions using GFP_ATOMIC given the set walk path happens with
   held rcu_read_lock.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 8411b6442e59810fe0750a2f321b9dcb7d0a3d17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
#	net/netfilter/nft_set_hash.c
diff --cc net/netfilter/nf_tables_api.c
index e2ddb2bff2ce,a019a87e58ee..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -3658,10 -3920,7 +3692,14 @@@ static int nf_tables_delsetelem(struct 
  	struct nft_ctx ctx;
  	int rem, err = 0;
  
++<<<<<<< HEAD
 +	if (nla[NFTA_SET_ELEM_LIST_ELEMENTS] == NULL)
 +		return -EINVAL;
 +
 +	err = nft_ctx_init_from_elemattr(&ctx, net, skb, nlh, nla);
++=======
+ 	err = nft_ctx_init_from_elemattr(&ctx, net, skb, nlh, nla, genmask);
++>>>>>>> 8411b6442e59 (netfilter: nf_tables: support for set flushing)
  	if (err < 0)
  		return err;
  
* Unmerged path net/netfilter/nft_set_hash.c
diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h
index aefa47fab07d..3c96ea6325f8 100644
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@ -256,7 +256,8 @@ struct nft_expr;
  *	@lookup: look up an element within the set
  *	@insert: insert new element into set
  *	@activate: activate new element in the next generation
- *	@deactivate: deactivate element in the next generation
+ *	@deactivate: lookup for element and deactivate it in the next generation
+ *	@deactivate_one: deactivate element in the next generation
  *	@remove: remove element from set
  *	@walk: iterate over all set elemeennts
  *	@privsize: function to return size of set private data
@@ -286,6 +287,9 @@ struct nft_set_ops {
 						    const struct nft_set_elem *elem);
 	void *				(*deactivate)(const struct nft_set *set,
 						      const struct nft_set_elem *elem);
+	bool				(*deactivate_one)(const struct net *net,
+							  const struct nft_set *set,
+							  void *priv);
 	void				(*remove)(const struct nft_set *set,
 						  const struct nft_set_elem *elem);
 	void				(*walk)(const struct nft_ctx *ctx,
* Unmerged path net/netfilter/nf_tables_api.c
diff --git a/net/netfilter/nft_rbtree.c b/net/netfilter/nft_rbtree.c
index 1c30f41cff5b..b74194845da4 100644
--- a/net/netfilter/nft_rbtree.c
+++ b/net/netfilter/nft_rbtree.c
@@ -255,6 +255,7 @@ static struct nft_set_ops nft_rbtree_ops __read_mostly = {
 	.insert		= nft_rbtree_insert,
 	.remove		= nft_rbtree_remove,
 	.deactivate	= nft_rbtree_deactivate,
+	.deactivate_one	= nft_rbtree_deactivate_one,
 	.activate	= nft_rbtree_activate,
 	.lookup		= nft_rbtree_lookup,
 	.walk		= nft_rbtree_walk,
* Unmerged path net/netfilter/nft_set_hash.c
