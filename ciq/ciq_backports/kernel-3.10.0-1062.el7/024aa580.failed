ixgbe: added Rx/Tx ring disable/enable functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Björn Töpel <bjorn.topel@intel.com>
commit 024aa5800f3246875ac824fab4bee3b4dc82f499
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/024aa580.failed

Add functions for Rx/Tx ring enable/disable. Instead of resetting the
whole device, only the affected ring is disabled or enabled.

This plumbing is used in later commits, when zero-copy AF_XDP support
is introduced.

	Signed-off-by: Björn Töpel <bjorn.topel@intel.com>
	Tested-by: William Tu <u9012063@gmail.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 024aa5800f3246875ac824fab4bee3b4dc82f499)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 7dcb8ca7aac8,47e28d9ce1e3..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -10158,8 -10210,57 +10160,61 @@@ static int ixgbe_xdp(struct net_device 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void ixgbe_xdp_ring_update_tail(struct ixgbe_ring *ring)
+ {
+ 	/* Force memory writes to complete before letting h/w know there
+ 	 * are new descriptors to fetch.
+ 	 */
+ 	wmb();
+ 	writel(ring->next_to_use, ring->tail);
+ }
+ 
+ static int ixgbe_xdp_xmit(struct net_device *dev, int n,
+ 			  struct xdp_frame **frames, u32 flags)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 	struct ixgbe_ring *ring;
+ 	int drops = 0;
+ 	int i;
+ 
+ 	if (unlikely(test_bit(__IXGBE_DOWN, &adapter->state)))
+ 		return -ENETDOWN;
+ 
+ 	if (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))
+ 		return -EINVAL;
+ 
+ 	/* During program transitions its possible adapter->xdp_prog is assigned
+ 	 * but ring has not been configured yet. In this case simply abort xmit.
+ 	 */
+ 	ring = adapter->xdp_prog ? adapter->xdp_ring[smp_processor_id()] : NULL;
+ 	if (unlikely(!ring))
+ 		return -ENXIO;
+ 
+ 	if (unlikely(test_bit(__IXGBE_TX_DISABLED, &ring->state)))
+ 		return -ENXIO;
+ 
+ 	for (i = 0; i < n; i++) {
+ 		struct xdp_frame *xdpf = frames[i];
+ 		int err;
+ 
+ 		err = ixgbe_xmit_xdp_ring(adapter, xdpf);
+ 		if (err != IXGBE_XDP_TX) {
+ 			xdp_return_frame_rx_napi(xdpf);
+ 			drops++;
+ 		}
+ 	}
+ 
+ 	if (unlikely(flags & XDP_XMIT_FLUSH))
+ 		ixgbe_xdp_ring_update_tail(ring);
+ 
+ 	return n - drops;
+ }
+ 
++>>>>>>> 024aa5800f32 (ixgbe: added Rx/Tx ring disable/enable functions)
  static const struct net_device_ops ixgbe_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
  	.ndo_open		= ixgbe_open,
  	.ndo_stop		= ixgbe_close,
  	.ndo_start_xmit		= ixgbe_xmit_frame,
@@@ -10199,14 -10297,168 +10254,167 @@@
  	.ndo_fdb_add		= ixgbe_ndo_fdb_add,
  	.ndo_bridge_setlink	= ixgbe_ndo_bridge_setlink,
  	.ndo_bridge_getlink	= ixgbe_ndo_bridge_getlink,
 -	.ndo_dfwd_add_station	= ixgbe_fwd_add,
 -	.ndo_dfwd_del_station	= ixgbe_fwd_del,
 -	.ndo_udp_tunnel_add	= ixgbe_add_udp_tunnel_port,
 -	.ndo_udp_tunnel_del	= ixgbe_del_udp_tunnel_port,
 +	.extended.ndo_udp_tunnel_add	= ixgbe_add_udp_tunnel_port,
 +	.extended.ndo_udp_tunnel_del	= ixgbe_del_udp_tunnel_port,
  	.ndo_features_check	= ixgbe_features_check,
 -	.ndo_bpf		= ixgbe_xdp,
 -	.ndo_xdp_xmit		= ixgbe_xdp_xmit,
 +	.extended.ndo_dfwd_add_station	= ixgbe_fwd_add,
 +	.extended.ndo_dfwd_del_station	= ixgbe_fwd_del,
 +	.extended.ndo_bpf	= ixgbe_xdp,
  };
  
+ static void ixgbe_disable_txr_hw(struct ixgbe_adapter *adapter,
+ 				 struct ixgbe_ring *tx_ring)
+ {
+ 	unsigned long wait_delay, delay_interval;
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	u8 reg_idx = tx_ring->reg_idx;
+ 	int wait_loop;
+ 	u32 txdctl;
+ 
+ 	IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(reg_idx), IXGBE_TXDCTL_SWFLSH);
+ 
+ 	/* delay mechanism from ixgbe_disable_tx */
+ 	delay_interval = ixgbe_get_completion_timeout(adapter) / 100;
+ 
+ 	wait_loop = IXGBE_MAX_RX_DESC_POLL;
+ 	wait_delay = delay_interval;
+ 
+ 	while (wait_loop--) {
+ 		usleep_range(wait_delay, wait_delay + 10);
+ 		wait_delay += delay_interval * 2;
+ 		txdctl = IXGBE_READ_REG(hw, IXGBE_TXDCTL(reg_idx));
+ 
+ 		if (!(txdctl & IXGBE_TXDCTL_ENABLE))
+ 			return;
+ 	}
+ 
+ 	e_err(drv, "TXDCTL.ENABLE not cleared within the polling period\n");
+ }
+ 
+ static void ixgbe_disable_txr(struct ixgbe_adapter *adapter,
+ 			      struct ixgbe_ring *tx_ring)
+ {
+ 	set_bit(__IXGBE_TX_DISABLED, &tx_ring->state);
+ 	ixgbe_disable_txr_hw(adapter, tx_ring);
+ }
+ 
+ static void ixgbe_disable_rxr_hw(struct ixgbe_adapter *adapter,
+ 				 struct ixgbe_ring *rx_ring)
+ {
+ 	unsigned long wait_delay, delay_interval;
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	u8 reg_idx = rx_ring->reg_idx;
+ 	int wait_loop;
+ 	u32 rxdctl;
+ 
+ 	rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
+ 	rxdctl &= ~IXGBE_RXDCTL_ENABLE;
+ 	rxdctl |= IXGBE_RXDCTL_SWFLSH;
+ 
+ 	/* write value back with RXDCTL.ENABLE bit cleared */
+ 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
+ 
+ 	/* RXDCTL.EN may not change on 82598 if link is down, so skip it */
+ 	if (hw->mac.type == ixgbe_mac_82598EB &&
+ 	    !(IXGBE_READ_REG(hw, IXGBE_LINKS) & IXGBE_LINKS_UP))
+ 		return;
+ 
+ 	/* delay mechanism from ixgbe_disable_rx */
+ 	delay_interval = ixgbe_get_completion_timeout(adapter) / 100;
+ 
+ 	wait_loop = IXGBE_MAX_RX_DESC_POLL;
+ 	wait_delay = delay_interval;
+ 
+ 	while (wait_loop--) {
+ 		usleep_range(wait_delay, wait_delay + 10);
+ 		wait_delay += delay_interval * 2;
+ 		rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
+ 
+ 		if (!(rxdctl & IXGBE_RXDCTL_ENABLE))
+ 			return;
+ 	}
+ 
+ 	e_err(drv, "RXDCTL.ENABLE not cleared within the polling period\n");
+ }
+ 
+ static void ixgbe_reset_txr_stats(struct ixgbe_ring *tx_ring)
+ {
+ 	memset(&tx_ring->stats, 0, sizeof(tx_ring->stats));
+ 	memset(&tx_ring->tx_stats, 0, sizeof(tx_ring->tx_stats));
+ }
+ 
+ static void ixgbe_reset_rxr_stats(struct ixgbe_ring *rx_ring)
+ {
+ 	memset(&rx_ring->stats, 0, sizeof(rx_ring->stats));
+ 	memset(&rx_ring->rx_stats, 0, sizeof(rx_ring->rx_stats));
+ }
+ 
+ /**
+  * ixgbe_txrx_ring_disable - Disable Rx/Tx/XDP Tx rings
+  * @adapter: adapter structure
+  * @ring: ring index
+  *
+  * This function disables a certain Rx/Tx/XDP Tx ring. The function
+  * assumes that the netdev is running.
+  **/
+ void ixgbe_txrx_ring_disable(struct ixgbe_adapter *adapter, int ring)
+ {
+ 	struct ixgbe_ring *rx_ring, *tx_ring, *xdp_ring;
+ 
+ 	rx_ring = adapter->rx_ring[ring];
+ 	tx_ring = adapter->tx_ring[ring];
+ 	xdp_ring = adapter->xdp_ring[ring];
+ 
+ 	ixgbe_disable_txr(adapter, tx_ring);
+ 	if (xdp_ring)
+ 		ixgbe_disable_txr(adapter, xdp_ring);
+ 	ixgbe_disable_rxr_hw(adapter, rx_ring);
+ 
+ 	if (xdp_ring)
+ 		synchronize_sched();
+ 
+ 	/* Rx/Tx/XDP Tx share the same napi context. */
+ 	napi_disable(&rx_ring->q_vector->napi);
+ 
+ 	ixgbe_clean_tx_ring(tx_ring);
+ 	if (xdp_ring)
+ 		ixgbe_clean_tx_ring(xdp_ring);
+ 	ixgbe_clean_rx_ring(rx_ring);
+ 
+ 	ixgbe_reset_txr_stats(tx_ring);
+ 	if (xdp_ring)
+ 		ixgbe_reset_txr_stats(xdp_ring);
+ 	ixgbe_reset_rxr_stats(rx_ring);
+ }
+ 
+ /**
+  * ixgbe_txrx_ring_enable - Enable Rx/Tx/XDP Tx rings
+  * @adapter: adapter structure
+  * @ring: ring index
+  *
+  * This function enables a certain Rx/Tx/XDP Tx ring. The function
+  * assumes that the netdev is running.
+  **/
+ void ixgbe_txrx_ring_enable(struct ixgbe_adapter *adapter, int ring)
+ {
+ 	struct ixgbe_ring *rx_ring, *tx_ring, *xdp_ring;
+ 
+ 	rx_ring = adapter->rx_ring[ring];
+ 	tx_ring = adapter->tx_ring[ring];
+ 	xdp_ring = adapter->xdp_ring[ring];
+ 
+ 	/* Rx/Tx/XDP Tx share the same napi context. */
+ 	napi_enable(&rx_ring->q_vector->napi);
+ 
+ 	ixgbe_configure_tx_ring(adapter, tx_ring);
+ 	if (xdp_ring)
+ 		ixgbe_configure_tx_ring(adapter, xdp_ring);
+ 	ixgbe_configure_rx_ring(adapter, rx_ring);
+ 
+ 	clear_bit(__IXGBE_TX_DISABLED, &tx_ring->state);
+ 	clear_bit(__IXGBE_TX_DISABLED, &xdp_ring->state);
+ }
+ 
  /**
   * ixgbe_enumerate_functions - Get the number of ports this device has
   * @adapter: adapter structure
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe.h b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
index ba3f7581de16..f9248ddff7b3 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
@@ -273,6 +273,7 @@ enum ixgbe_ring_state_t {
 	__IXGBE_TX_DETECT_HANG,
 	__IXGBE_HANG_CHECK_ARMED,
 	__IXGBE_TX_XDP_RING,
+	__IXGBE_TX_DISABLED,
 };
 
 #define ring_uses_build_skb(ring) \
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
