scsi: qla2xxx: Fix stuck session in PLOGI state

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix stuck session in PLOGI state (Himanshu Madhani) [1628301]
Rebuild_FUZZ: 93.18%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 861d483dcd1822b360ed186801c889a7da83e80d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/861d483d.failed

On PLOGI complete + RSCN received, driver tries to handle RSCN but failed to
reset the session back to the beginning to restart the login process. Instead
the session was left in the Plogi complete without moving forward.  This patch
will push the session state back to the delete state and restart the
connection.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 861d483dcd1822b360ed186801c889a7da83e80d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 656a7bb1d73f,bd1afa3063ee..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -394,9 -413,8 +394,14 @@@ void qla24xx_handle_adisc_event(scsi_ql
  		    __func__, ea->fcport->port_name);
  		return;
  	} else if (ea->sp->gen1 != ea->fcport->rscn_gen) {
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_disc, vha, 0x20d4, "%s %d %8phC post gidpn\n",
 +		    __func__, __LINE__, ea->fcport->port_name);
 +		qla24xx_post_gidpn_work(vha, ea->fcport);
++=======
+ 		qla_rscn_replay(fcport);
+ 		qlt_schedule_sess_for_deletion(fcport);
++>>>>>>> 861d483dcd18 (scsi: qla2xxx: Fix stuck session in PLOGI state)
  		return;
  	}
  
@@@ -506,11 -538,8 +511,16 @@@ static void qla24xx_handle_gnl_done_eve
  	}
  
  	if (fcport->last_rscn_gen != fcport->rscn_gen) {
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_disc, vha, 0x20df,
 +		    "%s %8phC rscn gen changed rscn %d|%d \n",
 +		    __func__, fcport->port_name,
 +		    fcport->last_rscn_gen, fcport->rscn_gen);
 +		qla24xx_post_gidpn_work(vha, fcport);
++=======
+ 		qla_rscn_replay(fcport);
+ 		qlt_schedule_sess_for_deletion(fcport);
++>>>>>>> 861d483dcd18 (scsi: qla2xxx: Fix stuck session in PLOGI state)
  		return;
  	} else if (fcport->last_login_gen != fcport->login_gen) {
  		ql_dbg(ql_dbg_disc, vha, 0x20e0,
@@@ -1099,6 -1222,19 +1109,22 @@@ void qla24xx_handle_gpdb_event(scsi_qla
  	else
  		ls = pd->current_login_state & 0xf;
  
++<<<<<<< HEAD
++=======
+ 	if (ea->sp->gen2 != fcport->login_gen) {
+ 		/* target side must have changed it. */
+ 
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d3,
+ 		    "%s %8phC generation changed\n",
+ 		    __func__, fcport->port_name);
+ 		return;
+ 	} else if (ea->sp->gen1 != fcport->rscn_gen) {
+ 		qla_rscn_replay(fcport);
+ 		qlt_schedule_sess_for_deletion(fcport);
+ 		return;
+ 	}
+ 
++>>>>>>> 861d483dcd18 (scsi: qla2xxx: Fix stuck session in PLOGI state)
  	switch (ls) {
  	case PDS_PRLI_COMPLETE:
  		__qla24xx_parse_gpdb(vha, fcport, pd);
@@@ -1469,6 -1677,34 +1495,37 @@@ void qla2x00_fcport_event_handler(scsi_
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * RSCN(s) came in for this fcport, but the RSCN(s) was not able
+  * to be consumed by the fcport
+  */
+ void qla_rscn_replay(fc_port_t *fcport)
+ {
+        struct event_arg ea;
+ 
+        switch (fcport->disc_state) {
+        case DSC_DELETE_PEND:
+                return;
+        default:
+                break;
+        }
+ 
+        if (fcport->scan_needed) {
+                memset(&ea, 0, sizeof(ea));
+                ea.event = FCME_RSCN;
+                ea.id = fcport->d_id;
+                ea.id.b.rsvd_1 = RSCN_PORT_ADDR;
+ #if defined BIGSCAN & BIGSCAN > 0
+                qla2x00_fcport_event_handler(fcport->vha, &ea);
+ #else
+                qla24xx_post_gpnid_work(fcport->vha, &ea.id);
+ #endif
+ 	}
+ }
+ 
++>>>>>>> 861d483dcd18 (scsi: qla2xxx: Fix stuck session in PLOGI state)
  static void
  qla2x00_tmf_iocb_timeout(void *data)
  {
@@@ -1727,9 -1961,11 +1784,17 @@@ qla24xx_handle_plogi_done_event(struct 
  		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
  		return;
  	} else if (ea->sp->gen1 != fcport->rscn_gen) {
++<<<<<<< HEAD
 +		ql_dbg(ql_dbg_disc, vha, 0x20d4, "%s %d %8phC post gidpn\n",
 +		    __func__, __LINE__, fcport->port_name);
 +		qla24xx_post_gidpn_work(vha, fcport);
++=======
+ 		ql_dbg(ql_dbg_disc, vha, 0x20d3,
+ 		    "%s %8phC RSCN generation changed\n",
+ 		    __func__, fcport->port_name);
+ 		qla_rscn_replay(fcport);
+ 		qlt_schedule_sess_for_deletion(fcport);
++>>>>>>> 861d483dcd18 (scsi: qla2xxx: Fix stuck session in PLOGI state)
  		return;
  	}
  
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c
index 1de1bf228cff..6041bf5b0d16 100644
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@ -1234,9 +1234,6 @@ void qlt_schedule_sess_for_deletion(struct fc_port *sess)
 			return;
 	}
 
-	if (sess->deleted == QLA_SESS_DELETED)
-		sess->logout_on_delete = 0;
-
 	spin_lock_irqsave(&sess->vha->work_lock, flags);
 	if (sess->deleted == QLA_SESS_DELETION_IN_PROGRESS) {
 		spin_unlock_irqrestore(&sess->vha->work_lock, flags);
@@ -3924,7 +3921,6 @@ static void qlt_do_ctio_completion(struct scsi_qla_host *vha,
 				 * Session is already logged out, but we need
 				 * to notify initiator, who's not aware of this
 				 */
-				cmd->sess->logout_on_delete = 0;
 				cmd->sess->send_els_logo = 1;
 				ql_dbg(ql_dbg_disc, vha, 0x20f8,
 				    "%s %d %8phC post del sess\n",
