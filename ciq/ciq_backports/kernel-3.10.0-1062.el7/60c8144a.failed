x86/MCE/AMD: Fix the thresholding machinery initialization order

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] mce/amd: Fix the thresholding machinery initialization order (Gary Hook) [1685269]
Rebuild_FUZZ: 96.77%
commit-author Borislav Petkov <bp@suse.de>
commit 60c8144afc287ef09ce8c1230c6aa972659ba1bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/60c8144a.failed

Currently, the code sets up the thresholding interrupt vector and only
then goes about initializing the thresholding banks. Which is wrong,
because an early thresholding interrupt would cause a NULL pointer
dereference when accessing those banks and prevent the machine from
booting.

Therefore, set the thresholding interrupt vector only *after* having
initialized the banks successfully.

Fixes: 18807ddb7f88 ("x86/mce/AMD: Reset Threshold Limit after logging error")
	Reported-by: Rafał Miłecki <rafal@milecki.pl>
	Reported-by: John Clemens <clemej@gmail.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Tested-by: Rafał Miłecki <rafal@milecki.pl>
	Tested-by: John Clemens <john@deater.net>
	Cc: Aravind Gopalakrishnan <aravindksg.lkml@gmail.com>
	Cc: linux-edac@vger.kernel.org
	Cc: stable@vger.kernel.org
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: x86@kernel.org
	Cc: Yazen Ghannam <Yazen.Ghannam@amd.com>
Link: https://lkml.kernel.org/r/20181127101700.2964-1-zajec5@gmail.com
Link: https://bugzilla.kernel.org/show_bug.cgi?id=201291
(cherry picked from commit 60c8144afc287ef09ce8c1230c6aa972659ba1bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/mcheck/mce_amd.c
diff --cc arch/x86/kernel/cpu/mcheck/mce_amd.c
index 6cf441f79966,e12454e21b8a..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce_amd.c
+++ b/arch/x86/kernel/cpu/mcheck/mce_amd.c
@@@ -55,6 -56,8 +55,11 @@@
  /* Threshold LVT offset is at MSR0xC0000410[15:12] */
  #define SMCA_THR_LVT_OFF	0xF000
  
++<<<<<<< HEAD
++=======
+ static bool thresholding_irq_en;
+ 
++>>>>>>> 60c8144afc28 (x86/MCE/AMD: Fix the thresholding machinery initialization order)
  static const char * const th_names[] = {
  	"load_store",
  	"insn_fetch",
@@@ -1338,24 -1362,39 +1342,48 @@@ static void threshold_remove_device(uns
  		threshold_remove_bank(cpu, bank);
  	}
  	kfree(per_cpu(threshold_banks, cpu));
 -	per_cpu(threshold_banks, cpu) = NULL;
 -	return 0;
  }
  
 -/* create dir/files for all valid threshold banks */
 -int mce_threshold_create_device(unsigned int cpu)
 +/* get notified when a cpu comes on/off */
 +static void
 +amd_64_threshold_cpu_callback(unsigned long action, unsigned int cpu)
  {
++<<<<<<< HEAD
 +	switch (action) {
 +	case CPU_ONLINE:
 +	case CPU_ONLINE_FROZEN:
 +		threshold_create_device(cpu);
 +		break;
 +	case CPU_DEAD:
 +	case CPU_DEAD_FROZEN:
 +		threshold_remove_device(cpu);
 +		break;
 +	default:
 +		break;
++=======
+ 	unsigned int bank;
+ 	struct threshold_bank **bp;
+ 	int err = 0;
+ 
+ 	bp = per_cpu(threshold_banks, cpu);
+ 	if (bp)
+ 		return 0;
+ 
+ 	bp = kcalloc(mca_cfg.banks, sizeof(struct threshold_bank *),
+ 		     GFP_KERNEL);
+ 	if (!bp)
+ 		return -ENOMEM;
+ 
+ 	per_cpu(threshold_banks, cpu) = bp;
+ 
+ 	for (bank = 0; bank < mca_cfg.banks; ++bank) {
+ 		if (!(per_cpu(bank_map, cpu) & (1 << bank)))
+ 			continue;
+ 		err = threshold_create_bank(cpu, bank);
+ 		if (err)
+ 			goto err;
++>>>>>>> 60c8144afc28 (x86/MCE/AMD: Fix the thresholding machinery initialization order)
  	}
 -	return err;
 -err:
 -	mce_threshold_remove_device(cpu);
 -	return err;
  }
  
  static __init int threshold_init_device(void)
@@@ -1369,8 -1408,10 +1397,11 @@@
  		if (err)
  			return err;
  	}
 +	threshold_cpu_callback = amd_64_threshold_cpu_callback;
  
+ 	if (thresholding_irq_en)
+ 		mce_threshold_vector = amd_threshold_interrupt;
+ 
  	return 0;
  }
  /*
* Unmerged path arch/x86/kernel/cpu/mcheck/mce_amd.c
