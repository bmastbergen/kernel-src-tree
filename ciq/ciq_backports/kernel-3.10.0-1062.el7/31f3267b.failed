fuse: trust kernel i_ctime only

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Maxim Patlasov <MPatlasov@parallels.com>
commit 31f3267b4ba16b12fb9dd3b1953ea0f221cc2ab4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/31f3267b.failed

Let the kernel maintain i_ctime locally: update i_ctime explicitly on
truncate, fallocate, open(O_TRUNC), setxattr, removexattr, link, rename,
unlink.

The inode flag I_DIRTY_SYNC serves as indication that local i_ctime should
be flushed to the server eventually.  The patch sets the flag and updates
i_ctime in course of operations listed above.

	Signed-off-by: Maxim Patlasov <MPatlasov@parallels.com>
	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit 31f3267b4ba16b12fb9dd3b1953ea0f221cc2ab4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dir.c
#	fs/fuse/inode.c
diff --cc fs/fuse/dir.c
index 3e1c8cd01fea,f62ab8eedb5f..000000000000
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@@ -802,19 -780,17 +811,21 @@@ static int fuse_rename_common(struct in
  	if (!err) {
  		/* ctime changes */
  		fuse_invalidate_attr(oldent->d_inode);
+ 		fuse_update_ctime(oldent->d_inode);
  
 +		if (flags & RENAME_EXCHANGE) {
 +			fuse_invalidate_attr(newent->d_inode);
 +		}
 +
  		fuse_invalidate_attr(olddir);
  		if (olddir != newdir)
  			fuse_invalidate_attr(newdir);
  
  		/* newent will end up negative */
 -		if (newent->d_inode) {
 +		if (!(flags & RENAME_EXCHANGE) && newent->d_inode) {
  			fuse_invalidate_attr(newent->d_inode);
  			fuse_invalidate_entry_cache(newent);
+ 			fuse_update_ctime(newent->d_inode);
  		}
  	} else if (err == -EINTR) {
  		/* If request was interrupted, DEITY only knows if the
@@@ -915,8 -854,13 +927,16 @@@ static void fuse_fillattr(struct inode 
  	struct fuse_conn *fc = get_fuse_conn(inode);
  
  	/* see the comment in fuse_change_attributes() */
 -	if (fc->writeback_cache && S_ISREG(inode->i_mode)) {
 +	if (fc->writeback_cache && S_ISREG(inode->i_mode))
  		attr->size = i_size_read(inode);
++<<<<<<< HEAD
++=======
+ 		attr->mtime = inode->i_mtime.tv_sec;
+ 		attr->mtimensec = inode->i_mtime.tv_nsec;
+ 		attr->ctime = inode->i_ctime.tv_sec;
+ 		attr->ctimensec = inode->i_ctime.tv_nsec;
+ 	}
++>>>>>>> 31f3267b4ba1 (fuse: trust kernel i_ctime only)
  
  	stat->dev = inode->i_sb->s_dev;
  	stat->ino = attr->ino;
diff --cc fs/fuse/inode.c
index 4fc9c23e42fa,e9ecb1878109..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -171,10 -171,13 +171,20 @@@ void fuse_change_attributes_common(stru
  	inode->i_blocks  = attr->blocks;
  	inode->i_atime.tv_sec   = attr->atime;
  	inode->i_atime.tv_nsec  = attr->atimensec;
++<<<<<<< HEAD
 +	inode->i_mtime.tv_sec   = attr->mtime;
 +	inode->i_mtime.tv_nsec  = attr->mtimensec;
 +	inode->i_ctime.tv_sec   = attr->ctime;
 +	inode->i_ctime.tv_nsec  = attr->ctimensec;
++=======
+ 	/* mtime from server may be stale due to local buffered write */
+ 	if (!fc->writeback_cache || !S_ISREG(inode->i_mode)) {
+ 		inode->i_mtime.tv_sec   = attr->mtime;
+ 		inode->i_mtime.tv_nsec  = attr->mtimensec;
+ 		inode->i_ctime.tv_sec   = attr->ctime;
+ 		inode->i_ctime.tv_nsec  = attr->ctimensec;
+ 	}
++>>>>>>> 31f3267b4ba1 (fuse: trust kernel i_ctime only)
  
  	if (attr->blksize != 0)
  		inode->i_blkbits = ilog2(attr->blksize);
@@@ -251,6 -254,10 +261,13 @@@ static void fuse_init_inode(struct inod
  {
  	inode->i_mode = attr->mode & S_IFMT;
  	inode->i_size = attr->size;
++<<<<<<< HEAD
++=======
+ 	inode->i_mtime.tv_sec  = attr->mtime;
+ 	inode->i_mtime.tv_nsec = attr->mtimensec;
+ 	inode->i_ctime.tv_sec  = attr->ctime;
+ 	inode->i_ctime.tv_nsec = attr->ctimensec;
++>>>>>>> 31f3267b4ba1 (fuse: trust kernel i_ctime only)
  	if (S_ISREG(inode->i_mode)) {
  		fuse_init_common(inode);
  		fuse_init_file_inode(inode);
* Unmerged path fs/fuse/dir.c
* Unmerged path fs/fuse/inode.c
