net: mdiobus: add unlocked accessors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mdiobus: add unlocked accessors (Ivan Vecera) [1685646]
Rebuild_FUZZ: 92.54%
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit 34dc08e4be208539b7c4aa8154a610e1736705e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/34dc08e4.failed

Add unlocked versions of the bus accessors, which allows access to the
bus with all the tracing. These accessors validate that the bus mutex
is held, which is a basic requirement for all mii bus accesses.

	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 34dc08e4be208539b7c4aa8154a610e1736705e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/mdio_bus.c
diff --cc drivers/net/phy/mdio_bus.c
index 1dbef80dbf2d,e2419c792a44..000000000000
--- a/drivers/net/phy/mdio_bus.c
+++ b/drivers/net/phy/mdio_bus.c
@@@ -342,8 -582,8 +391,13 @@@ int mdiobus_read_nested(struct mii_bus 
  
  	BUG_ON(in_interrupt());
  
++<<<<<<< HEAD
 +	mutex_lock_nested(&bus->mdio_lock, SINGLE_DEPTH_NESTING);
 +	retval = bus->read(bus, addr, regnum);
++=======
+ 	mutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);
+ 	retval = __mdiobus_read(bus, addr, regnum);
++>>>>>>> 34dc08e4be20 (net: mdiobus: add unlocked accessors)
  	mutex_unlock(&bus->mdio_lock);
  
  	return retval;
@@@ -394,8 -634,8 +448,13 @@@ int mdiobus_write_nested(struct mii_bu
  
  	BUG_ON(in_interrupt());
  
++<<<<<<< HEAD
 +	mutex_lock_nested(&bus->mdio_lock, SINGLE_DEPTH_NESTING);
 +	err = bus->write(bus, addr, regnum, val);
++=======
+ 	mutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);
+ 	err = __mdiobus_write(bus, addr, regnum, val);
++>>>>>>> 34dc08e4be20 (net: mdiobus: add unlocked accessors)
  	mutex_unlock(&bus->mdio_lock);
  
  	return err;
* Unmerged path drivers/net/phy/mdio_bus.c
diff --git a/include/linux/mdio.h b/include/linux/mdio.h
index 07a206d16ffc..6ff13d3c6fe4 100644
--- a/include/linux/mdio.h
+++ b/include/linux/mdio.h
@@ -198,6 +198,9 @@ static inline u16 ethtool_adv_to_mmd_eee_adv_t(u32 adv)
 	return reg;
 }
 
+int __mdiobus_read(struct mii_bus *bus, int addr, u32 regnum);
+int __mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val);
+
 int mdiobus_read(struct mii_bus *bus, int addr, u32 regnum);
 int mdiobus_read_nested(struct mii_bus *bus, int addr, u32 regnum);
 int mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val);
