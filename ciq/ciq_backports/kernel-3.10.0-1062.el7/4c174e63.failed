nvme-rdma: fix timeout handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Sagi Grimberg <sagi@grimberg.me>
commit 4c174e6366746ae8d49f9cc409f728eebb7a9ac9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4c174e63.failed

Currently, we have several problems with the timeout
handler:
1. If we timeout on the controller establishment flow, we will hang
because we don't execute the error recovery (and we shouldn't because
the create_ctrl flow needs to fail and cleanup on its own)
2. We might also hang if we get a disconnet on a queue while the
controller is already deleting. This racy flow can cause the controller
disable/shutdown admin command to hang.

We cannot complete a timed out request from the timeout handler without
mutual exclusion from the teardown flow (e.g. nvme_rdma_error_recovery_work).
So we serialize it in the timeout handler and teardown io and admin
queues to guarantee that no one races with us from completing the
request.

	Reported-by: Jaesoo Lee <jalee@purestorage.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 4c174e6366746ae8d49f9cc409f728eebb7a9ac9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/rdma.c
diff --cc drivers/nvme/host/rdma.c
index f692db6210d1,4101961feb44..000000000000
--- a/drivers/nvme/host/rdma.c
+++ b/drivers/nvme/host/rdma.c
@@@ -1634,21 -1689,31 +1634,35 @@@ static enum blk_eh_timer_retur
  nvme_rdma_timeout(struct request *rq, bool reserved)
  {
  	struct nvme_rdma_request *req = blk_mq_rq_to_pdu(rq);
+ 	struct nvme_rdma_queue *queue = req->queue;
+ 	struct nvme_rdma_ctrl *ctrl = queue->ctrl;
  
- 	dev_warn(req->queue->ctrl->ctrl.device,
- 		 "I/O %d QID %d timeout, reset controller\n",
- 		 rq->tag, nvme_rdma_queue_idx(req->queue));
+ 	dev_warn(ctrl->ctrl.device, "I/O %d QID %d timeout\n",
+ 		 rq->tag, nvme_rdma_queue_idx(queue));
  
- 	/* queue error recovery */
- 	nvme_rdma_error_recovery(req->queue->ctrl);
+ 	if (ctrl->ctrl.state != NVME_CTRL_LIVE) {
+ 		/*
+ 		 * Teardown immediately if controller times out while starting
+ 		 * or we are already started error recovery. all outstanding
+ 		 * requests are completed on shutdown, so we return BLK_EH_DONE.
+ 		 */
+ 		flush_work(&ctrl->err_work);
+ 		nvme_rdma_teardown_io_queues(ctrl, false);
+ 		nvme_rdma_teardown_admin_queue(ctrl, false);
+ 		return BLK_EH_DONE;
+ 	}
  
- 	/* fail with DNR on cmd timeout */
- 	nvme_req(rq)->status = NVME_SC_ABORT_REQ | NVME_SC_DNR;
+ 	dev_warn(ctrl->ctrl.device, "starting error recovery\n");
+ 	nvme_rdma_error_recovery(ctrl);
  
++<<<<<<< HEAD
 +	return BLK_EH_HANDLED;
++=======
+ 	return BLK_EH_RESET_TIMER;
++>>>>>>> 4c174e636674 (nvme-rdma: fix timeout handler)
  }
  
 -static blk_status_t nvme_rdma_queue_rq(struct blk_mq_hw_ctx *hctx,
 +static int nvme_rdma_queue_rq(struct blk_mq_hw_ctx *hctx,
  		const struct blk_mq_queue_data *bd)
  {
  	struct nvme_ns *ns = hctx->queue->queuedata;
* Unmerged path drivers/nvme/host/rdma.c
