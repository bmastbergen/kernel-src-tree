net/mlx5e: Support VLAN modify action

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eli Britstein <elibr@mellanox.com>
commit bdc837eecf73c391f5a9f97b5b61e6a1f30cf31f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/bdc837ee.failed

Support VLAN modify action by emulating a rewrite action for the VLAN
fields. Currently, the only supported field is the vid. The prio in the
action must be set to 0 to indicate no change.

	Signed-off-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit bdc837eecf73c391f5a9f97b5b61e6a1f30cf31f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 5862f33b4ba7,0f4e9615f666..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2025,16 -2249,48 +2025,50 @@@ static bool same_hw_devs(struct mlx5e_p
  	return (fsystem_guid == psystem_guid);
  }
  
++<<<<<<< HEAD
 +static int parse_tc_nic_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
++=======
+ static int add_vlan_rewrite_action(struct mlx5e_priv *priv, int namespace,
+ 				   const struct flow_action_entry *act,
+ 				   struct mlx5e_tc_flow_parse_attr *parse_attr,
+ 				   struct pedit_headers_action *hdrs,
+ 				   u32 *action, struct netlink_ext_ack *extack)
+ {
+ 	u16 mask16 = VLAN_VID_MASK;
+ 	u16 val16 = act->vlan.vid & VLAN_VID_MASK;
+ 	const struct flow_action_entry pedit_act = {
+ 		.id = FLOW_ACTION_MANGLE,
+ 		.mangle.htype = FLOW_ACT_MANGLE_HDR_TYPE_ETH,
+ 		.mangle.offset = offsetof(struct vlan_ethhdr, h_vlan_TCI),
+ 		.mangle.mask = ~(u32)be16_to_cpu(*(__be16 *)&mask16),
+ 		.mangle.val = (u32)be16_to_cpu(*(__be16 *)&val16),
+ 	};
+ 	int err;
+ 
+ 	if (act->vlan.prio) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Setting VLAN prio is not supported");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	err = parse_tc_pedit_action(priv, &pedit_act, namespace, parse_attr,
+ 				    hdrs, NULL);
+ 	*action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;
+ 
+ 	return err;
+ }
+ 
+ static int parse_tc_nic_actions(struct mlx5e_priv *priv,
+ 				struct flow_action *flow_action,
++>>>>>>> bdc837eecf73 (net/mlx5e: Support VLAN modify action)
  				struct mlx5e_tc_flow_parse_attr *parse_attr,
 -				struct mlx5e_tc_flow *flow,
 -				struct netlink_ext_ack *extack)
 +				struct mlx5e_tc_flow *flow)
  {
  	struct mlx5_nic_flow_attr *attr = flow->nic_attr;
 -	struct pedit_headers_action hdrs[2] = {};
 -	const struct flow_action_entry *act;
 -	u32 action = 0;
 -	int err, i;
 +	const struct tc_action *a;
 +	LIST_HEAD(actions);
 +	int err;
  
 -	if (!flow_action_has_entries(flow_action))
 +	if (!tcf_exts_has_actions(exts))
  		return -EINVAL;
  
  	attr->flow_tag = MLX5_FS_DEFAULT_FLOW_TAG;
@@@ -2055,21 -2310,27 +2089,41 @@@
  			if (err)
  				return err;
  
++<<<<<<< HEAD
 +			attr->action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR |
 +					MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
 +			continue;
 +		}
 +
 +		if (is_tcf_csum(a)) {
 +			if (csum_offload_supported(priv, attr->action,
 +						   tcf_csum_update_flags(a)))
 +				continue;
++=======
+ 			action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR |
+ 				  MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
+ 			break;
+ 		case FLOW_ACTION_VLAN_MANGLE:
+ 			err = add_vlan_rewrite_action(priv,
+ 						      MLX5_FLOW_NAMESPACE_KERNEL,
+ 						      act, parse_attr, hdrs,
+ 						      &action, extack);
+ 			if (err)
+ 				return err;
+ 
+ 			break;
+ 		case FLOW_ACTION_CSUM:
+ 			if (csum_offload_supported(priv, action,
+ 						   act->csum_flags,
+ 						   extack))
+ 				break;
++>>>>>>> bdc837eecf73 (net/mlx5e: Support VLAN modify action)
  
  			return -EOPNOTSUPP;
 -		case FLOW_ACTION_REDIRECT: {
 -			struct net_device *peer_dev = act->dev;
 +		}
 +
 +		if (is_tcf_mirred_egress_redirect(a)) {
 +			struct net_device *peer_dev = tcf_mirred_dev(a);
  
  			if (priv->netdev->netdev_ops == peer_dev->netdev_ops &&
  			    same_hw_devs(priv, netdev_priv(peer_dev))) {
@@@ -2584,18 -2485,76 +2638,76 @@@ out_err
  	return err;
  }
  
++<<<<<<< HEAD
 +static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
++=======
+ static int parse_tc_vlan_action(struct mlx5e_priv *priv,
+ 				const struct flow_action_entry *act,
+ 				struct mlx5_esw_flow_attr *attr,
+ 				u32 *action)
+ {
+ 	u8 vlan_idx = attr->total_vlan;
+ 
+ 	if (vlan_idx >= MLX5_FS_VLAN_DEPTH)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (act->id) {
+ 	case FLOW_ACTION_VLAN_POP:
+ 		if (vlan_idx) {
+ 			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev,
+ 								 MLX5_FS_VLAN_DEPTH))
+ 				return -EOPNOTSUPP;
+ 
+ 			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP_2;
+ 		} else {
+ 			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
+ 		}
+ 		break;
+ 	case FLOW_ACTION_VLAN_PUSH:
+ 		attr->vlan_vid[vlan_idx] = act->vlan.vid;
+ 		attr->vlan_prio[vlan_idx] = act->vlan.prio;
+ 		attr->vlan_proto[vlan_idx] = act->vlan.proto;
+ 		if (!attr->vlan_proto[vlan_idx])
+ 			attr->vlan_proto[vlan_idx] = htons(ETH_P_8021Q);
+ 
+ 		if (vlan_idx) {
+ 			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev,
+ 								 MLX5_FS_VLAN_DEPTH))
+ 				return -EOPNOTSUPP;
+ 
+ 			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH_2;
+ 		} else {
+ 			if (!mlx5_eswitch_vlan_actions_supported(priv->mdev, 1) &&
+ 			    (act->vlan.proto != htons(ETH_P_8021Q) ||
+ 			     act->vlan.prio))
+ 				return -EOPNOTSUPP;
+ 
+ 			*action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;
+ 		}
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	attr->total_vlan = vlan_idx + 1;
+ 
+ 	return 0;
+ }
+ 
+ static int parse_tc_fdb_actions(struct mlx5e_priv *priv,
+ 				struct flow_action *flow_action,
++>>>>>>> bdc837eecf73 (net/mlx5e: Support VLAN modify action)
  				struct mlx5e_tc_flow_parse_attr *parse_attr,
 -				struct mlx5e_tc_flow *flow,
 -				struct netlink_ext_ack *extack)
 +				struct mlx5e_tc_flow *flow)
  {
 -	struct pedit_headers_action hdrs[2] = {};
 -	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
  	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
  	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 -	const struct ip_tunnel_info *info = NULL;
 -	const struct flow_action_entry *act;
 +	struct ip_tunnel_info *info = NULL;
 +	const struct tc_action *a;
 +	LIST_HEAD(actions);
  	bool encap = false;
 -	u32 action = 0;
 -	int err, i;
  
 -	if (!flow_action_has_entries(flow_action))
 +	if (!tcf_exts_has_actions(exts))
  		return -EINVAL;
  
  	attr->in_rep = rpriv->rep;
@@@ -2665,40 -2660,76 +2777,71 @@@
  				encap = true;
  			else
  				return -EOPNOTSUPP;
 +			continue;
 +		}
  
++<<<<<<< HEAD
 +		if (is_tcf_vlan(a)) {
 +			if (tcf_vlan_action(a) == TCA_VLAN_ACT_POP) {
 +				attr->action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
 +			} else if (tcf_vlan_action(a) == TCA_VLAN_ACT_PUSH) {
 +				attr->action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;
 +				attr->vlan_vid = tcf_vlan_push_vid(a);
 +				if (mlx5_eswitch_vlan_actions_supported(priv->mdev)) {
 +					attr->vlan_prio = tcf_vlan_push_prio(a);
 +					attr->vlan_proto = tcf_vlan_push_proto(a);
 +					if (!attr->vlan_proto)
 +						attr->vlan_proto = htons(ETH_P_8021Q);
 +				} else if (tcf_vlan_push_proto(a) != htons(ETH_P_8021Q) ||
 +					   tcf_vlan_push_prio(a)) {
 +					return -EOPNOTSUPP;
 +				}
 +			} else { /* action is TCA_VLAN_ACT_MODIFY */
++=======
+ 			break;
+ 		case FLOW_ACTION_VLAN_PUSH:
+ 		case FLOW_ACTION_VLAN_POP:
+ 			err = parse_tc_vlan_action(priv, act, attr, &action);
+ 			if (err)
+ 				return err;
+ 
+ 			attr->split_count = attr->out_count;
+ 			break;
+ 		case FLOW_ACTION_VLAN_MANGLE:
+ 			err = add_vlan_rewrite_action(priv,
+ 						      MLX5_FLOW_NAMESPACE_FDB,
+ 						      act, parse_attr, hdrs,
+ 						      &action, extack);
+ 			if (err)
+ 				return err;
+ 
+ 			attr->split_count = attr->out_count;
+ 			break;
+ 		case FLOW_ACTION_TUNNEL_DECAP:
+ 			action |= MLX5_FLOW_CONTEXT_ACTION_DECAP;
+ 			break;
+ 		case FLOW_ACTION_GOTO: {
+ 			u32 dest_chain = act->chain_index;
+ 			u32 max_chain = mlx5_eswitch_get_chain_range(esw);
+ 
+ 			if (dest_chain <= attr->chain) {
+ 				NL_SET_ERR_MSG(extack, "Goto earlier chain isn't supported");
++>>>>>>> bdc837eecf73 (net/mlx5e: Support VLAN modify action)
  				return -EOPNOTSUPP;
  			}
 -			if (dest_chain > max_chain) {
 -				NL_SET_ERR_MSG(extack, "Requested destination chain is out of supported range");
 -				return -EOPNOTSUPP;
 -			}
 -			action |= MLX5_FLOW_CONTEXT_ACTION_COUNT;
 -			attr->dest_chain = dest_chain;
 -			break;
 -			}
 -		default:
 -			return -EINVAL;
 +			continue;
  		}
 -	}
 -
 -	if (hdrs[TCA_PEDIT_KEY_EX_CMD_SET].pedits ||
 -	    hdrs[TCA_PEDIT_KEY_EX_CMD_ADD].pedits) {
 -		err = alloc_tc_pedit_action(priv, MLX5_FLOW_NAMESPACE_KERNEL,
 -					    parse_attr, hdrs, extack);
 -		if (err)
 -			return err;
 -	}
 -
 -	attr->action = action;
 -	if (!actions_match_supported(priv, flow_action, parse_attr, flow, extack))
 -		return -EOPNOTSUPP;
  
 -	if (attr->dest_chain) {
 -		if (attr->action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {
 -			NL_SET_ERR_MSG(extack, "Mirroring goto chain rules isn't supported");
 -			return -EOPNOTSUPP;
 +		if (is_tcf_tunnel_release(a)) {
 +			attr->action |= MLX5_FLOW_CONTEXT_ACTION_DECAP;
 +			continue;
  		}
 -		attr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
 +
 +		return -EINVAL;
  	}
  
 -	if (attr->split_count > 0 && !mlx5_esw_has_fwd_fdb(priv->mdev)) {
 -		NL_SET_ERR_MSG_MOD(extack,
 -				   "current firmware doesn't support split rule for port mirroring");
 -		netdev_warn_once(priv->netdev, "current firmware doesn't support split rule for port mirroring\n");
 +	if (!actions_match_supported(priv, exts, parse_attr, flow))
  		return -EOPNOTSUPP;
 -	}
  
  	return 0;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
