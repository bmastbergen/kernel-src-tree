efi: Use a work queue to invoke EFI Runtime Services

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Sai Praneeth <sai.praneeth.prakhya@intel.com>
commit 3eb420e70d879ce0e6bf752accf5cdedb0a59de8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3eb420e7.failed

Presently, when a user process requests the kernel to execute any
UEFI runtime service, the kernel temporarily switches to a separate
set of page tables that describe the virtual mapping of the UEFI
runtime services regions in memory. Since UEFI runtime services are
typically invoked with interrupts enabled, any code that may be called
during this time, will have an incorrect view of the process's address
space. Although it is unusual for code running in interrupt context to
make assumptions about the process context it runs in, there are cases
(such as the perf subsystem taking samples) where this causes problems.

So let's set up a work queue for calling UEFI runtime services, so that
the actual calls are made when the work queue items are dispatched by a
work queue worker running in a separate kernel thread. Such threads are
not expected to have userland mappings in the first place, and so the
additional mappings created for the UEFI runtime services can never
clash with any.

The ResetSystem() runtime service is not covered by the work queue
handling, since it is not expected to return, and may be called at a
time when the kernel is torn down to the point where we cannot expect
work queues to still be operational.

The non-blocking variants of SetVariable() and QueryVariableInfo()
are also excluded: these are intended to be used from atomic context,
which obviously rules out waiting for a completion to be signalled by
another thread. Note that these variants are currently only used for
UEFI runtime services calls that occur very early in the boot, and
for ones that occur in critical conditions, e.g., to flush kernel logs
to UEFI variables via efi-pstore.

	Suggested-by: Andy Lutomirski <luto@kernel.org>
	Signed-off-by: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
[ardb: exclude ResetSystem() from the workqueue treatment
       merge from 2 separate patches and rewrite commit log]
	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
Link: http://lkml.kernel.org/r/20180711094040.12506-4-ard.biesheuvel@linaro.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 3eb420e70d879ce0e6bf752accf5cdedb0a59de8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/runtime-wrappers.c
#	include/linux/efi.h
diff --cc drivers/firmware/efi/runtime-wrappers.c
index dcc976822484,aa66cbf23512..000000000000
--- a/drivers/firmware/efi/runtime-wrappers.c
+++ b/drivers/firmware/efi/runtime-wrappers.c
@@@ -14,8 -23,17 +23,18 @@@
   * This file is released under the GPLv2.
   */
  
 -#define pr_fmt(fmt)	"efi: " fmt
 -
 -#include <linux/bug.h>
  #include <linux/efi.h>
++<<<<<<< HEAD
 +#include <linux/spinlock.h>             /* spinlock_t */
++=======
+ #include <linux/irqflags.h>
+ #include <linux/mutex.h>
+ #include <linux/semaphore.h>
+ #include <linux/stringify.h>
+ #include <linux/workqueue.h>
+ #include <linux/completion.h>
+ 
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  #include <asm/efi.h>
  
  /*
@@@ -43,32 -131,151 +132,131 @@@ void efi_call_virt_check_flags(unsigne
  	local_irq_restore(flags);
  }
  
 -/*
 - * According to section 7.1 of the UEFI spec, Runtime Services are not fully
 - * reentrant, and there are particular combinations of calls that need to be
 - * serialized. (source: UEFI Specification v2.4A)
 - *
 - * Table 31. Rules for Reentry Into Runtime Services
 - * +------------------------------------+-------------------------------+
 - * | If previous call is busy in	| Forbidden to call		|
 - * +------------------------------------+-------------------------------+
 - * | Any				| SetVirtualAddressMap()	|
 - * +------------------------------------+-------------------------------+
 - * | ConvertPointer()			| ConvertPointer()		|
 - * +------------------------------------+-------------------------------+
 - * | SetVariable()			| ResetSystem()			|
 - * | UpdateCapsule()			|				|
 - * | SetTime()				|				|
 - * | SetWakeupTime()			|				|
 - * | GetNextHighMonotonicCount()	|				|
 - * +------------------------------------+-------------------------------+
 - * | GetVariable()			| GetVariable()			|
 - * | GetNextVariableName()		| GetNextVariableName()		|
 - * | SetVariable()			| SetVariable()			|
 - * | QueryVariableInfo()		| QueryVariableInfo()		|
 - * | UpdateCapsule()			| UpdateCapsule()		|
 - * | QueryCapsuleCapabilities()		| QueryCapsuleCapabilities()	|
 - * | GetNextHighMonotonicCount()	| GetNextHighMonotonicCount()	|
 - * +------------------------------------+-------------------------------+
 - * | GetTime()				| GetTime()			|
 - * | SetTime()				| SetTime()			|
 - * | GetWakeupTime()			| GetWakeupTime()		|
 - * | SetWakeupTime()			| SetWakeupTime()		|
 - * +------------------------------------+-------------------------------+
 - *
 - * Due to the fact that the EFI pstore may write to the variable store in
 - * interrupt context, we need to use a lock for at least the groups that
 - * contain SetVariable() and QueryVariableInfo(). That leaves little else, as
 - * none of the remaining functions are actually ever called at runtime.
 - * So let's just use a single lock to serialize all Runtime Services calls.
 +/* As per commit ef68c8f87ed1 ("x86: Serialize EFI time accesses on rtc_lock"),
 + * the EFI specification requires that callers of the time related runtime
 + * functions serialize with other CMOS accesses in the kernel, as the EFI time
 + * functions may choose to also use the legacy CMOS RTC.
   */
 -static DEFINE_SEMAPHORE(efi_runtime_lock);
 +__weak DEFINE_SPINLOCK(rtc_lock);
  
+ /*
+  * Calls the appropriate efi_runtime_service() with the appropriate
+  * arguments.
+  *
+  * Semantics followed by efi_call_rts() to understand efi_runtime_work:
+  * 1. If argument was a pointer, recast it from void pointer to original
+  * pointer type.
+  * 2. If argument was a value, recast it from void pointer to original
+  * pointer type and dereference it.
+  */
+ static void efi_call_rts(struct work_struct *work)
+ {
+ 	struct efi_runtime_work *efi_rts_work;
+ 	void *arg1, *arg2, *arg3, *arg4, *arg5;
+ 	efi_status_t status = EFI_NOT_FOUND;
+ 
+ 	efi_rts_work = container_of(work, struct efi_runtime_work, work);
+ 	arg1 = efi_rts_work->arg1;
+ 	arg2 = efi_rts_work->arg2;
+ 	arg3 = efi_rts_work->arg3;
+ 	arg4 = efi_rts_work->arg4;
+ 	arg5 = efi_rts_work->arg5;
+ 
+ 	switch (efi_rts_work->efi_rts_id) {
+ 	case GET_TIME:
+ 		status = efi_call_virt(get_time, (efi_time_t *)arg1,
+ 				       (efi_time_cap_t *)arg2);
+ 		break;
+ 	case SET_TIME:
+ 		status = efi_call_virt(set_time, (efi_time_t *)arg1);
+ 		break;
+ 	case GET_WAKEUP_TIME:
+ 		status = efi_call_virt(get_wakeup_time, (efi_bool_t *)arg1,
+ 				       (efi_bool_t *)arg2, (efi_time_t *)arg3);
+ 		break;
+ 	case SET_WAKEUP_TIME:
+ 		status = efi_call_virt(set_wakeup_time, *(efi_bool_t *)arg1,
+ 				       (efi_time_t *)arg2);
+ 		break;
+ 	case GET_VARIABLE:
+ 		status = efi_call_virt(get_variable, (efi_char16_t *)arg1,
+ 				       (efi_guid_t *)arg2, (u32 *)arg3,
+ 				       (unsigned long *)arg4, (void *)arg5);
+ 		break;
+ 	case GET_NEXT_VARIABLE:
+ 		status = efi_call_virt(get_next_variable, (unsigned long *)arg1,
+ 				       (efi_char16_t *)arg2,
+ 				       (efi_guid_t *)arg3);
+ 		break;
+ 	case SET_VARIABLE:
+ 		status = efi_call_virt(set_variable, (efi_char16_t *)arg1,
+ 				       (efi_guid_t *)arg2, *(u32 *)arg3,
+ 				       *(unsigned long *)arg4, (void *)arg5);
+ 		break;
+ 	case QUERY_VARIABLE_INFO:
+ 		status = efi_call_virt(query_variable_info, *(u32 *)arg1,
+ 				       (u64 *)arg2, (u64 *)arg3, (u64 *)arg4);
+ 		break;
+ 	case GET_NEXT_HIGH_MONO_COUNT:
+ 		status = efi_call_virt(get_next_high_mono_count, (u32 *)arg1);
+ 		break;
+ 	case UPDATE_CAPSULE:
+ 		status = efi_call_virt(update_capsule,
+ 				       (efi_capsule_header_t **)arg1,
+ 				       *(unsigned long *)arg2,
+ 				       *(unsigned long *)arg3);
+ 		break;
+ 	case QUERY_CAPSULE_CAPS:
+ 		status = efi_call_virt(query_capsule_caps,
+ 				       (efi_capsule_header_t **)arg1,
+ 				       *(unsigned long *)arg2, (u64 *)arg3,
+ 				       (int *)arg4);
+ 		break;
+ 	default:
+ 		/*
+ 		 * Ideally, we should never reach here because a caller of this
+ 		 * function should have put the right efi_runtime_service()
+ 		 * function identifier into efi_rts_work->efi_rts_id
+ 		 */
+ 		pr_err("Requested executing invalid EFI Runtime Service.\n");
+ 	}
+ 	efi_rts_work->status = status;
+ 	complete(&efi_rts_work->efi_rts_comp);
+ }
+ 
  static efi_status_t virt_efi_get_time(efi_time_t *tm, efi_time_cap_t *tc)
  {
 +	unsigned long flags;
  	efi_status_t status;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	status = efi_call_virt(get_time, tm, tc);
 +	spin_unlock_irqrestore(&rtc_lock, flags);
++=======
+ 	if (down_interruptible(&efi_runtime_lock))
+ 		return EFI_ABORTED;
+ 	status = efi_queue_work(GET_TIME, tm, tc, NULL, NULL, NULL);
+ 	up(&efi_runtime_lock);
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  	return status;
  }
  
  static efi_status_t virt_efi_set_time(efi_time_t *tm)
  {
 +	unsigned long flags;
  	efi_status_t status;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	status = efi_call_virt(set_time, tm);
 +	spin_unlock_irqrestore(&rtc_lock, flags);
++=======
+ 	if (down_interruptible(&efi_runtime_lock))
+ 		return EFI_ABORTED;
+ 	status = efi_queue_work(SET_TIME, tm, NULL, NULL, NULL, NULL);
+ 	up(&efi_runtime_lock);
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  	return status;
  }
  
@@@ -76,23 -283,25 +264,39 @@@ static efi_status_t virt_efi_get_wakeup
  					     efi_bool_t *pending,
  					     efi_time_t *tm)
  {
 +	unsigned long flags;
  	efi_status_t status;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	status = efi_call_virt(get_wakeup_time, enabled, pending, tm);
 +	spin_unlock_irqrestore(&rtc_lock, flags);
++=======
+ 	if (down_interruptible(&efi_runtime_lock))
+ 		return EFI_ABORTED;
+ 	status = efi_queue_work(GET_WAKEUP_TIME, enabled, pending, tm, NULL,
+ 				NULL);
+ 	up(&efi_runtime_lock);
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  	return status;
  }
  
  static efi_status_t virt_efi_set_wakeup_time(efi_bool_t enabled, efi_time_t *tm)
  {
 +	unsigned long flags;
  	efi_status_t status;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	status = efi_call_virt(set_wakeup_time, enabled, tm);
 +	spin_unlock_irqrestore(&rtc_lock, flags);
++=======
+ 	if (down_interruptible(&efi_runtime_lock))
+ 		return EFI_ABORTED;
+ 	status = efi_queue_work(SET_WAKEUP_TIME, &enabled, tm, NULL, NULL,
+ 				NULL);
+ 	up(&efi_runtime_lock);
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  	return status;
  }
  
@@@ -102,14 -311,28 +306,36 @@@ static efi_status_t virt_efi_get_variab
  					  unsigned long *data_size,
  					  void *data)
  {
++<<<<<<< HEAD
 +	return efi_call_virt(get_variable, name, vendor, attr, data_size, data);
++=======
+ 	efi_status_t status;
+ 
+ 	if (down_interruptible(&efi_runtime_lock))
+ 		return EFI_ABORTED;
+ 	status = efi_queue_work(GET_VARIABLE, name, vendor, attr, data_size,
+ 				data);
+ 	up(&efi_runtime_lock);
+ 	return status;
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  }
  
  static efi_status_t virt_efi_get_next_variable(unsigned long *name_size,
  					       efi_char16_t *name,
  					       efi_guid_t *vendor)
  {
++<<<<<<< HEAD
 +	return efi_call_virt(get_next_variable, name_size, name, vendor);
++=======
+ 	efi_status_t status;
+ 
+ 	if (down_interruptible(&efi_runtime_lock))
+ 		return EFI_ABORTED;
+ 	status = efi_queue_work(GET_NEXT_VARIABLE, name_size, name, vendor,
+ 				NULL, NULL);
+ 	up(&efi_runtime_lock);
+ 	return status;
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  }
  
  static efi_status_t virt_efi_set_variable(efi_char16_t *name,
@@@ -118,7 -341,14 +344,18 @@@
  					  unsigned long data_size,
  					  void *data)
  {
++<<<<<<< HEAD
 +	return efi_call_virt(set_variable, name, vendor, attr, data_size, data);
++=======
+ 	efi_status_t status;
+ 
+ 	if (down_interruptible(&efi_runtime_lock))
+ 		return EFI_ABORTED;
+ 	status = efi_queue_work(SET_VARIABLE, name, vendor, &attr, &data_size,
+ 				data);
+ 	up(&efi_runtime_lock);
+ 	return status;
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  }
  
  static efi_status_t
@@@ -147,8 -376,14 +384,17 @@@ static efi_status_t virt_efi_query_vari
  	if (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)
  		return EFI_UNSUPPORTED;
  
++<<<<<<< HEAD
 +	return efi_call_virt(query_variable_info, attr, storage_space,
 +			     remaining_space, max_variable_size);
++=======
+ 	if (down_interruptible(&efi_runtime_lock))
+ 		return EFI_ABORTED;
+ 	status = efi_queue_work(QUERY_VARIABLE_INFO, &attr, storage_space,
+ 				remaining_space, max_variable_size, NULL);
+ 	up(&efi_runtime_lock);
+ 	return status;
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  }
  
  static efi_status_t
@@@ -174,7 -408,14 +420,18 @@@ virt_efi_query_variable_info_nonblockin
  
  static efi_status_t virt_efi_get_next_high_mono_count(u32 *count)
  {
++<<<<<<< HEAD
 +	return efi_call_virt(get_next_high_mono_count, count);
++=======
+ 	efi_status_t status;
+ 
+ 	if (down_interruptible(&efi_runtime_lock))
+ 		return EFI_ABORTED;
+ 	status = efi_queue_work(GET_NEXT_HIGH_MONO_COUNT, count, NULL, NULL,
+ 				NULL, NULL);
+ 	up(&efi_runtime_lock);
+ 	return status;
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  }
  
  static void virt_efi_reset_system(int reset_type,
@@@ -192,7 -439,14 +449,16 @@@ static efi_status_t virt_efi_update_cap
  	if (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)
  		return EFI_UNSUPPORTED;
  
++<<<<<<< HEAD
 +	return efi_call_virt(update_capsule, capsules, count, sg_list);
++=======
+ 	if (down_interruptible(&efi_runtime_lock))
+ 		return EFI_ABORTED;
+ 	status = efi_queue_work(UPDATE_CAPSULE, capsules, &count, &sg_list,
+ 				NULL, NULL);
+ 	up(&efi_runtime_lock);
+ 	return status;
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  }
  
  static efi_status_t virt_efi_query_capsule_caps(efi_capsule_header_t **capsules,
@@@ -203,8 -457,14 +469,17 @@@
  	if (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)
  		return EFI_UNSUPPORTED;
  
++<<<<<<< HEAD
 +	return efi_call_virt(query_capsule_caps, capsules, count, max_size,
 +			     reset_type);
++=======
+ 	if (down_interruptible(&efi_runtime_lock))
+ 		return EFI_ABORTED;
+ 	status = efi_queue_work(QUERY_CAPSULE_CAPS, capsules, &count,
+ 				max_size, reset_type, NULL);
+ 	up(&efi_runtime_lock);
+ 	return status;
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  }
  
  void efi_native_runtime_setup(void)
diff --cc include/linux/efi.h
index ce99ad24fa74,8ba0cdd244b2..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -1334,7 -1622,36 +1334,39 @@@ extern void efi_call_virt_check_flags(u
  	arch_efi_call_virt(p, f, args);					\
  	efi_call_virt_check_flags(__flags, __stringify(f));		\
  									\
 -	arch_efi_call_virt_teardown();					\
 +	arch_efi_call_virt_teardown(ibrs_on);				\
  })
  
++<<<<<<< HEAD
++=======
+ typedef efi_status_t (*efi_exit_boot_map_processing)(
+ 	efi_system_table_t *sys_table_arg,
+ 	struct efi_boot_memmap *map,
+ 	void *priv);
+ 
+ efi_status_t efi_exit_boot_services(efi_system_table_t *sys_table,
+ 				    void *handle,
+ 				    struct efi_boot_memmap *map,
+ 				    void *priv,
+ 				    efi_exit_boot_map_processing priv_func);
+ 
+ #define EFI_RANDOM_SEED_SIZE		64U
+ 
+ struct linux_efi_random_seed {
+ 	u32	size;
+ 	u8	bits[];
+ };
+ 
+ struct linux_efi_tpm_eventlog {
+ 	u32	size;
+ 	u8	version;
+ 	u8	log[];
+ };
+ 
+ extern int efi_tpm_eventlog_init(void);
+ 
+ /* Workqueue to queue EFI Runtime Services */
+ extern struct workqueue_struct *efi_rts_wq;
+ 
++>>>>>>> 3eb420e70d87 (efi: Use a work queue to invoke EFI Runtime Services)
  #endif /* _LINUX_EFI_H */
diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index a7e5bf388aed..c724e827bd97 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -59,6 +59,8 @@ static unsigned long *efi_tables[] = {
 
 struct kobject *efi_kobj;
 
+struct workqueue_struct *efi_rts_wq;
+
 static bool disable_runtime;
 static int __init setup_noefi(char *arg)
 {
@@ -196,6 +198,18 @@ static int __init efisubsys_init(void)
 	if (!efi_enabled(EFI_BOOT))
 		return 0;
 
+	/*
+	 * Since we process only one efi_runtime_service() at a time, an
+	 * ordered workqueue (which creates only one execution context)
+	 * should suffice all our needs.
+	 */
+	efi_rts_wq = alloc_ordered_workqueue("efi_rts_wq", 0);
+	if (!efi_rts_wq) {
+		pr_err("Creating efi_rts_wq failed, EFI runtime services disabled.\n");
+		clear_bit(EFI_RUNTIME_SERVICES, &efi.flags);
+		return 0;
+	}
+
 	/* We register the efi directory at /sys/firmware/efi */
 	efi_kobj = kobject_create_and_add("efi", firmware_kobj);
 	if (!efi_kobj) {
* Unmerged path drivers/firmware/efi/runtime-wrappers.c
* Unmerged path include/linux/efi.h
