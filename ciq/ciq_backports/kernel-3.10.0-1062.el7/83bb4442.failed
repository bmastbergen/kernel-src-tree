RDMA/uverbs: Remove UA_FLAGS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit 83bb4442330f035bd68ec5d2f5b87bfef1c1a4ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/83bb4442.failed

This bit of boilerplate isn't really necessary, we can use bitfields
instead of a flags enum and the macros can then individually initialize
them through the __VA_ARGS__ like everything else.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 83bb4442330f035bd68ec5d2f5b87bfef1c1a4ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_ioctl.c
#	drivers/infiniband/core/uverbs_std_types_counters.c
#	drivers/infiniband/core/uverbs_std_types_cq.c
#	drivers/infiniband/core/uverbs_std_types_dm.c
#	drivers/infiniband/core/uverbs_std_types_flow_action.c
#	drivers/infiniband/core/uverbs_std_types_mr.c
#	drivers/infiniband/hw/mlx5/devx.c
#	drivers/infiniband/hw/mlx5/main.c
#	include/rdma/uverbs_ioctl.h
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index ec7b453e622b,cb6109036129..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -98,25 -97,42 +98,58 @@@ static int uverbs_process_attr(struct i
  		 * longer struct will fail here if used with an old kernel and
  		 * non-zero content, making ABI compat/discovery simpler.
  		 */
++<<<<<<< HEAD
 +		if (uattr->len > val_spec->ptr.len &&
 +		    val_spec->flags & UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO &&
 +		    !uverbs_is_attr_cleared(uattr, val_spec->ptr.len))
++=======
+ 		if (uattr->len > val_spec->u.ptr.len &&
+ 		    val_spec->min_sz_or_zero &&
+ 		    !uverbs_is_attr_cleared(uattr, val_spec->u.ptr.len))
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  			return -EOPNOTSUPP;
  
  	/* fall through */
  	case UVERBS_ATTR_TYPE_PTR_OUT:
++<<<<<<< HEAD
 +		if (uattr->len < val_spec->ptr.min_len ||
 +		    (!(val_spec->flags & UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO) &&
 +		     uattr->len > val_spec->ptr.len))
++=======
+ 		if (uattr->len < val_spec->u.ptr.min_len ||
+ 		    (!val_spec->min_sz_or_zero &&
+ 		     uattr->len > val_spec->u.ptr.len))
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  			return -EINVAL;
  
  		if (spec->type != UVERBS_ATTR_TYPE_ENUM_IN &&
  		    uattr->attr_data.reserved)
  			return -EINVAL;
  
 +		e->ptr_attr.data = uattr->data;
  		e->ptr_attr.len = uattr->len;
  		e->ptr_attr.flags = uattr->flags;
++<<<<<<< HEAD
++=======
+ 
+ 		if (val_spec->alloc_and_copy && !uverbs_attr_ptr_is_inline(e)) {
+ 			void *p;
+ 
+ 			p = kvmalloc(uattr->len, GFP_KERNEL);
+ 			if (!p)
+ 				return -ENOMEM;
+ 
+ 			e->ptr_attr.ptr = p;
+ 
+ 			if (copy_from_user(p, u64_to_user_ptr(uattr->data),
+ 					   uattr->len)) {
+ 				kvfree(p);
+ 				return -EFAULT;
+ 			}
+ 		} else {
+ 			e->ptr_attr.data = uattr->data;
+ 		}
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  		break;
  
  	case UVERBS_ATTR_TYPE_IDR:
@@@ -198,9 -215,13 +231,16 @@@ static int uverbs_finalize_attrs(struc
  
  				current_ret = uverbs_finalize_object(
  					attr->obj_attr.uobject,
 -					spec->u.obj.access, commit);
 +					spec->obj.access, commit);
  				if (!ret)
  					ret = current_ret;
++<<<<<<< HEAD
++=======
+ 			} else if (spec->type == UVERBS_ATTR_TYPE_PTR_IN &&
+ 				   spec->alloc_and_copy &&
+ 				   !uverbs_attr_ptr_is_inline(attr)) {
+ 				kvfree(attr->ptr_attr.ptr);
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  			}
  		}
  	}
diff --cc drivers/infiniband/core/uverbs_std_types_cq.c
index b0dbae9dd0d7,1a14c245b511..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_cq.c
+++ b/drivers/infiniband/core/uverbs_std_types_cq.c
@@@ -146,25 -147,30 +146,52 @@@ err_event_file
  	return ret;
  };
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_CQ_CREATE,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE, UVERBS_OBJECT_CQ,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
 +			    UVERBS_ATTR_TYPE(u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
 +			UVERBS_OBJECT_COMP_CHANNEL,
 +			UVERBS_ACCESS_READ),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR, UVERBS_ATTR_TYPE(u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_FLAGS, UVERBS_ATTR_TYPE(u32)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE, UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&uverbs_uhw_compat_in, &uverbs_uhw_compat_out);
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_CQ_CREATE,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE,
+ 			UVERBS_OBJECT_CQ,
+ 			UVERBS_ACCESS_NEW,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
+ 		       UVERBS_OBJECT_COMP_CHANNEL,
+ 		       UVERBS_ACCESS_READ,
+ 		       UA_OPTIONAL),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR,
+ 			   UVERBS_ATTR_TYPE(u32),
+ 			   UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_FLAGS, UVERBS_ATTR_TYPE(u32)),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE,
+ 			    UVERBS_ATTR_TYPE(u32),
+ 			    UA_MANDATORY),
+ 	UVERBS_ATTR_UHW());
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
  static int UVERBS_HANDLER(UVERBS_METHOD_CQ_DESTROY)(struct ib_device *ib_dev,
  						    struct ib_uverbs_file *file,
@@@ -191,20 -201,22 +218,36 @@@
  			      sizeof(resp));
  }
  
++<<<<<<< HEAD
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_CQ_DESTROY,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_CQ_HANDLE, UVERBS_OBJECT_CQ,
 +			 UVERBS_ACCESS_DESTROY,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_DESTROY_CQ_RESP,
 +			     UVERBS_ATTR_TYPE(struct ib_uverbs_destroy_cq_resp),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
++=======
+ DECLARE_UVERBS_NAMED_METHOD(
+ 	UVERBS_METHOD_CQ_DESTROY,
+ 	UVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_CQ_HANDLE,
+ 			UVERBS_OBJECT_CQ,
+ 			UVERBS_ACCESS_DESTROY,
+ 			UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_DESTROY_CQ_RESP,
+ 			    UVERBS_ATTR_TYPE(struct ib_uverbs_destroy_cq_resp),
+ 			    UA_MANDATORY));
+ 
+ DECLARE_UVERBS_NAMED_OBJECT(
+ 	UVERBS_OBJECT_CQ,
+ 	UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_ucq_object), uverbs_free_cq),
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
 +DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_CQ,
 +			    &UVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_ucq_object), 0,
 +						      uverbs_free_cq),
  #if IS_ENABLED(CONFIG_INFINIBAND_EXP_LEGACY_VERBS_NEW_UAPI)
 -	&UVERBS_METHOD(UVERBS_METHOD_CQ_CREATE),
 -	&UVERBS_METHOD(UVERBS_METHOD_CQ_DESTROY)
 +			    &UVERBS_METHOD(UVERBS_METHOD_CQ_CREATE),
 +			    &UVERBS_METHOD(UVERBS_METHOD_CQ_DESTROY)
  #endif
 -);
 +			   );
 +
diff --cc drivers/infiniband/hw/mlx5/main.c
index caab7cc36fbe,54d45e13de34..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -4475,7 -5315,127 +4475,131 @@@ static void mlx5_ib_cleanup_multiport_m
  	mlx5_nic_vport_disable_roce(dev->mdev);
  }
  
++<<<<<<< HEAD
 +static void mlx5_ib_stage_init_cleanup(struct mlx5_ib_dev *dev)
++=======
+ ADD_UVERBS_ATTRIBUTES_SIMPLE(
+ 	mlx5_ib_dm,
+ 	UVERBS_OBJECT_DM,
+ 	UVERBS_METHOD_DM_ALLOC,
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_START_OFFSET,
+ 			    UVERBS_ATTR_TYPE(u64),
+ 			    UA_MANDATORY),
+ 	UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_PAGE_INDEX,
+ 			    UVERBS_ATTR_TYPE(u16),
+ 			    UA_MANDATORY));
+ 
+ ADD_UVERBS_ATTRIBUTES_SIMPLE(
+ 	mlx5_ib_flow_action,
+ 	UVERBS_OBJECT_FLOW_ACTION,
+ 	UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
+ 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_FLOW_ACTION_FLAGS,
+ 			   UVERBS_ATTR_TYPE(u64),
+ 			   UA_MANDATORY));
+ 
+ #define NUM_TREES	3
+ static int populate_specs_root(struct mlx5_ib_dev *dev)
+ {
+ 	const struct uverbs_object_tree_def *default_root[NUM_TREES + 1] = {
+ 		uverbs_default_get_objects()};
+ 	size_t num_trees = 1;
+ 
+ 	if (mlx5_accel_ipsec_device_caps(dev->mdev) & MLX5_ACCEL_IPSEC_CAP_DEVICE &&
+ 	    !WARN_ON(num_trees >= ARRAY_SIZE(default_root)))
+ 		default_root[num_trees++] = &mlx5_ib_flow_action;
+ 
+ 	if (MLX5_CAP_DEV_MEM(dev->mdev, memic) &&
+ 	    !WARN_ON(num_trees >= ARRAY_SIZE(default_root)))
+ 		default_root[num_trees++] = &mlx5_ib_dm;
+ 
+ 	if (MLX5_CAP_GEN_64(dev->mdev, general_obj_types) &
+ 			    MLX5_GENERAL_OBJ_TYPES_CAP_UCTX &&
+ 	    !WARN_ON(num_trees >= ARRAY_SIZE(default_root)))
+ 		default_root[num_trees++] = mlx5_ib_get_devx_tree();
+ 
+ 	dev->ib_dev.driver_specs_root =
+ 		uverbs_alloc_spec_tree(num_trees, default_root);
+ 
+ 	return PTR_ERR_OR_ZERO(dev->ib_dev.driver_specs_root);
+ }
+ 
+ static void depopulate_specs_root(struct mlx5_ib_dev *dev)
+ {
+ 	uverbs_free_spec_tree(dev->ib_dev.driver_specs_root);
+ }
+ 
+ static int mlx5_ib_read_counters(struct ib_counters *counters,
+ 				 struct ib_counters_read_attr *read_attr,
+ 				 struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_mcounters *mcounters = to_mcounters(counters);
+ 	struct mlx5_read_counters_attr mread_attr = {};
+ 	struct mlx5_ib_flow_counters_desc *desc;
+ 	int ret, i;
+ 
+ 	mutex_lock(&mcounters->mcntrs_mutex);
+ 	if (mcounters->cntrs_max_index > read_attr->ncounters) {
+ 		ret = -EINVAL;
+ 		goto err_bound;
+ 	}
+ 
+ 	mread_attr.out = kcalloc(mcounters->counters_num, sizeof(u64),
+ 				 GFP_KERNEL);
+ 	if (!mread_attr.out) {
+ 		ret = -ENOMEM;
+ 		goto err_bound;
+ 	}
+ 
+ 	mread_attr.hw_cntrs_hndl = mcounters->hw_cntrs_hndl;
+ 	mread_attr.flags = read_attr->flags;
+ 	ret = mcounters->read_counters(counters->device, &mread_attr);
+ 	if (ret)
+ 		goto err_read;
+ 
+ 	/* do the pass over the counters data array to assign according to the
+ 	 * descriptions and indexing pairs
+ 	 */
+ 	desc = mcounters->counters_data;
+ 	for (i = 0; i < mcounters->ncounters; i++)
+ 		read_attr->counters_buff[desc[i].index] += mread_attr.out[desc[i].description];
+ 
+ err_read:
+ 	kfree(mread_attr.out);
+ err_bound:
+ 	mutex_unlock(&mcounters->mcntrs_mutex);
+ 	return ret;
+ }
+ 
+ static int mlx5_ib_destroy_counters(struct ib_counters *counters)
+ {
+ 	struct mlx5_ib_mcounters *mcounters = to_mcounters(counters);
+ 
+ 	counters_clear_description(counters);
+ 	if (mcounters->hw_cntrs_hndl)
+ 		mlx5_fc_destroy(to_mdev(counters->device)->mdev,
+ 				mcounters->hw_cntrs_hndl);
+ 
+ 	kfree(mcounters);
+ 
+ 	return 0;
+ }
+ 
+ static struct ib_counters *mlx5_ib_create_counters(struct ib_device *device,
+ 						   struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_mcounters *mcounters;
+ 
+ 	mcounters = kzalloc(sizeof(*mcounters), GFP_KERNEL);
+ 	if (!mcounters)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	mutex_init(&mcounters->mcntrs_mutex);
+ 
+ 	return &mcounters->ibcntrs;
+ }
+ 
+ void mlx5_ib_stage_init_cleanup(struct mlx5_ib_dev *dev)
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  {
  	mlx5_ib_cleanup_multiport_master(dev);
  #ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
diff --cc include/rdma/uverbs_ioctl.h
index 2cc45699a237,6073fd9d9c49..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -61,34 -61,32 +61,55 @@@ enum uverbs_obj_access 
  	UVERBS_ACCESS_DESTROY
  };
  
++<<<<<<< HEAD
 +enum {
 +	UVERBS_ATTR_SPEC_F_MANDATORY	= 1U << 0,
 +	/* Support extending attributes by length, validate all unknown size == zero  */
 +	UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO = 1U << 1,
 +};
 +
++=======
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  /* Specification of a single attribute inside the ioctl message */
+ /* good size 16 */
  struct uverbs_attr_spec {
++<<<<<<< HEAD
++=======
+ 	u8 type;
+ 
+ 	/*
+ 	 * Support extending attributes by length, validate all
+ 	 * unknown size == zero
+ 	 */
+ 	u8 min_sz_or_zero:1;
+ 	/*
+ 	 * Valid only for PTR_IN. Allocate and copy the data inside
+ 	 * the parser
+ 	 */
+ 	u8 alloc_and_copy:1;
+ 	u8 mandatory:1;
+ 
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  	union {
 +		/* Header shared by all following union members - to reduce space. */
 +		struct {
 +			enum uverbs_attr_type		type;
 +			/* Combination of bits from enum UVERBS_ATTR_SPEC_F_XXXX */
 +			u8				flags;
 +		};
  		struct {
 +			enum uverbs_attr_type		type;
 +			/* Combination of bits from enum UVERBS_ATTR_SPEC_F_XXXX */
 +			u8				flags;
  			/* Current known size to kernel */
 -			u16 len;
 +			u16				len;
  			/* User isn't allowed to provide something < min_len */
 -			u16 min_len;
 +			u16				min_len;
  		} ptr;
 -
  		struct {
 +			enum uverbs_attr_type		type;
 +			/* Combination of bits from enum UVERBS_ATTR_SPEC_F_XXXX */
 +			u8				flags;
  			/*
  			 * higher bits mean the namespace and lower bits mean
  			 * the type id within the namespace.
@@@ -214,110 -210,83 +235,172 @@@ struct uverbs_object_tree_def 
  #define UVERBS_ATTR_MIN_SIZE(_min_len)				\
  	UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
  
++<<<<<<< HEAD
 +/*
 + * In new compiler, UVERBS_ATTR could be simplified by declaring it as
 + * [_id] = {.type = _type, .len = _len, ##__VA_ARGS__}
 + * But since we support older compilers too, we need the more complex code.
 + */
 +#define UVERBS_ATTR(_id, _type, _fld, _attr, ...)			\
 +	__UVERBS_ATTR(_id, _type, _fld, _attr, ##__VA_ARGS__, 2, 1, 0)
 +#define UVERBS_ATTR_PTR_IN_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_IN, ptr, _len, ##__VA_ARGS__)
 +/* If sizeof(_type) <= sizeof(u64), this will be inlined rather than a pointer */
 +#define UVERBS_ATTR_PTR_IN(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_IN_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_OUT, ptr, _len, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_OUT_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_ENUM_IN(_id, _enum_arr, ...)			\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_ENUM_IN, enum_def,		\
 +		    .ids = (_enum_arr),					\
 +		    .num_elems = ARRAY_SIZE(_enum_arr), ##__VA_ARGS__)
++=======
+ /* Must be used in the '...' of any UVERBS_ATTR */
+ #define UA_ALLOC_AND_COPY .alloc_and_copy = 1
+ #define UA_MANDATORY .mandatory = 1
+ #define UA_MIN_SZ_OR_ZERO .min_sz_or_zero = 1
+ #define UA_OPTIONAL .mandatory = 0
+ 
+ #define UVERBS_ATTR_IDR(_attr_id, _idr_type, _access, ...)                     \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_IDR,                        \
+ 			  .u.obj.obj_type = _idr_type,                         \
+ 			  .u.obj.access = _access,                             \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_FD(_attr_id, _fd_type, _access, ...)                       \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = (_attr_id) +                                             \
+ 		      BUILD_BUG_ON_ZERO((_access) != UVERBS_ACCESS_NEW &&      \
+ 					(_access) != UVERBS_ACCESS_READ),      \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_FD,                         \
+ 			  .u.obj.obj_type = _fd_type,                          \
+ 			  .u.obj.access = _access,                             \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_PTR_IN(_attr_id, _type, ...)                               \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_PTR_IN,                     \
+ 			  _type,                                               \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_PTR_OUT(_attr_id, _type, ...)                              \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_PTR_OUT,                    \
+ 			  _type,                                               \
+ 			  __VA_ARGS__ } })
+ 
+ /* _enum_arry should be a 'static const union uverbs_attr_spec[]' */
+ #define UVERBS_ATTR_ENUM_IN(_attr_id, _enum_arr, ...)                          \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_ENUM_IN,                    \
+ 			  .u2.enum_def.ids = _enum_arr,                        \
+ 			  .u.enum_def.num_elems = ARRAY_SIZE(_enum_arr),       \
+ 			  __VA_ARGS__ },                                       \
+ 	})
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
  /*
 - * This spec is used in order to pass information to the hardware driver in a
 - * legacy way. Every verb that could get driver specific data should get this
 - * spec.
 + * In new compiler, UVERBS_ATTR_IDR (and FD) could be simplified by declaring
 + * it as
 + * {.id = _id,								\
 + *  .attr {.type = __obj_class,						\
 + *         .obj = {.obj_type = _idr_type,				\
 + *                       .access = _access                              \
 + *                }, ##__VA_ARGS__ } }
 + * But since we support older compilers too, we need the more complex code.
   */
++<<<<<<< HEAD
 +#define ___UVERBS_ATTR_OBJ0(_id, _obj_class, _obj_type, _access, ...)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	 .attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			    .access = _access, .flags = 0 } }, } })
 +#define ___UVERBS_ATTR_OBJ1(_id, _obj_class, _obj_type, _access, _flags)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	.attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			   .access = _access, _flags} }, } })
 +#define ___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, _flags, \
 +			   _n, ...)					\
 +	___UVERBS_ATTR_OBJ##_n(_id, _obj_class, _obj_type, _access, _flags)
 +#define __UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, ...)	\
 +	___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access,		\
 +			   ##__VA_ARGS__, 1, 0)
 +#define UVERBS_ATTR_IDR(_id, _idr_type, _access, ...)			 \
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_IDR, _idr_type, _access,\
 +			  ##__VA_ARGS__)
 +#define UVERBS_ATTR_FD(_id, _fd_type, _access, ...)			\
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_FD, _fd_type,		\
 +			  (_access) + BUILD_BUG_ON_ZERO(		\
 +				(_access) != UVERBS_ACCESS_NEW &&	\
 +				(_access) != UVERBS_ACCESS_READ),	\
 +			  ##__VA_ARGS__)
 +#define DECLARE_UVERBS_ATTR_SPEC(_name, ...)				\
 +	const struct uverbs_attr_def _name = __VA_ARGS__
++=======
+ #define UVERBS_ATTR_UHW()                                                      \
+ 	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_UHW_IN,                                 \
+ 			   UVERBS_ATTR_SIZE(0, USHRT_MAX),		       \
+ 			   UA_OPTIONAL,					       \
+ 			   UA_MIN_SZ_OR_ZERO),				       \
+ 	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_UHW_OUT,                               \
+ 			    UVERBS_ATTR_SIZE(0, USHRT_MAX),		       \
+ 			    UA_OPTIONAL,				       \
+ 			    UA_MIN_SZ_OR_ZERO),				       \
++>>>>>>> 83bb4442330f (RDMA/uverbs: Remove UA_FLAGS)
  
 -/*
 - * =======================================
 - *	Declaration helpers
 - * =======================================
 - */
 -
 -#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)                                 \
 -	static const struct uverbs_object_def *const _name##_ptr[] = {         \
 -		__VA_ARGS__,                                                   \
 -	};                                                                     \
 -	static const struct uverbs_object_tree_def _name = {                   \
 -		.num_objects = ARRAY_SIZE(_name##_ptr),                        \
 -		.objects = &_name##_ptr,                                       \
 +#define DECLARE_UVERBS_ENUM(_name, ...)					\
 +	const struct uverbs_enum_spec _name = {				\
 +		.len = ARRAY_SIZE(((struct uverbs_attr_spec[]){__VA_ARGS__})),\
 +		.ids = {__VA_ARGS__},					\
  	}
 +#define _UVERBS_METHOD_ATTRS_SZ(...)					\
 +	(sizeof((const struct uverbs_attr_def * const []){__VA_ARGS__}) /\
 +	 sizeof(const struct uverbs_attr_def *))
 +#define _UVERBS_METHOD(_id, _handler, _flags, ...)			\
 +	((const struct uverbs_method_def) {				\
 +	 .id = _id,							\
 +	 .flags = _flags,						\
 +	 .handler = _handler,						\
 +	 .num_attrs = _UVERBS_METHOD_ATTRS_SZ(__VA_ARGS__),		\
 +	 .attrs = &(const struct uverbs_attr_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_METHOD(_name, _id, _handler, ...)		\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler, 0, ##__VA_ARGS__)
 +#define DECLARE_UVERBS_CTX_METHOD(_name, _id, _handler, _flags, ...)	\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler,				\
 +			       UVERBS_ACTION_FLAG_CREATE_ROOT,		\
 +			       ##__VA_ARGS__)
 +#define _UVERBS_OBJECT_METHODS_SZ(...)					\
 +	(sizeof((const struct uverbs_method_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_method_def *))
 +#define _UVERBS_OBJECT(_id, _type_attrs, ...)				\
 +	((const struct uverbs_object_def) {				\
 +	 .id = _id,							\
 +	 .type_attrs = _type_attrs,					\
 +	 .num_methods = _UVERBS_OBJECT_METHODS_SZ(__VA_ARGS__),		\
 +	 .methods = &(const struct uverbs_method_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT(_name, _id, _type_attrs, ...)		\
 +	const struct uverbs_object_def _name =				\
 +		_UVERBS_OBJECT(_id, _type_attrs, ##__VA_ARGS__)
 +#define _UVERBS_TREE_OBJECTS_SZ(...)					\
 +	(sizeof((const struct uverbs_object_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_object_def *))
 +#define _UVERBS_OBJECT_TREE(...)					\
 +	((const struct uverbs_object_tree_def) {			\
 +	 .num_objects = _UVERBS_TREE_OBJECTS_SZ(__VA_ARGS__),		\
 +	 .objects = &(const struct uverbs_object_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)				\
 +	const struct uverbs_object_tree_def _name =			\
 +		_UVERBS_OBJECT_TREE(__VA_ARGS__)
  
  /* =================================================
   *              Parsing infrastructure
* Unmerged path drivers/infiniband/core/uverbs_std_types_counters.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_dm.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_flow_action.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
diff --git a/drivers/infiniband/core/uverbs_ioctl_merge.c b/drivers/infiniband/core/uverbs_ioctl_merge.c
index 0f88a1919d51..d700c61cdae0 100644
--- a/drivers/infiniband/core/uverbs_ioctl_merge.c
+++ b/drivers/infiniband/core/uverbs_ioctl_merge.c
@@ -375,18 +375,18 @@ static struct uverbs_method_spec *build_method_with_attrs(const struct uverbs_me
 				 "ib_uverbs: Method contains more than one object attr (%d) with new/destroy access\n",
 				 min_id) ||
 			    WARN(attr_obj_with_special_access &&
-				 !(attr->flags & UVERBS_ATTR_SPEC_F_MANDATORY),
+				 !attr->mandatory,
 				 "ib_uverbs: Tried to merge attr (%d) but it's an object with new/destroy access but isn't mandatory\n",
 				 min_id) ||
 			    WARN(IS_ATTR_OBJECT(attr) &&
-				 attr->flags & UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO,
+				 attr->min_sz_or_zero,
 				 "ib_uverbs: Tried to merge attr (%d) but it's an object with min_sz flag\n",
 				 min_id)) {
 				res = -EINVAL;
 				goto free;
 			}
 
-			if (attr->flags & UVERBS_ATTR_SPEC_F_MANDATORY)
+			if (attr->mandatory)
 				set_bit(min_id, hash->mandatory_attrs_bitmask);
 			min_id++;
 
* Unmerged path drivers/infiniband/core/uverbs_std_types_counters.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_cq.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_dm.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_flow_action.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path include/rdma/uverbs_ioctl.h
