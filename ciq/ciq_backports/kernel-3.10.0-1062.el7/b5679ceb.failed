vmbus: fix subchannel removal

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Dexuan Cui <decui@microsoft.com>
commit b5679cebf780c6f1c2451a73bf1842a4409840e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b5679ceb.failed

The changes to split ring allocation from open/close, broke
the cleanup of subchannels. This resulted in problems using
uio on network devices because the subchannel was left behind
when the network device was unbound.

The cause was in the disconnect logic which used list splice
to move the subchannel list into a local variable. This won't
work because the subchannel list is needed later during the
process of the rescind messages (relid2channel).

The fix is to just leave the subchannel list in place
which is what the original code did. The list is cleaned
up later when the host rescind is processed.

Without the fix, we have a lot of "hang" issues in netvsc when we
try to change the NIC's MTU, set the number of channels, etc.

Fixes: ae6935ed7d42 ("vmbus: split ring buffer allocation from open")
	Cc: stable@vger.kernel.org
	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: Dexuan Cui <decui@microsoft.com>
	Signed-off-by: Sasha Levin <sashal@kernel.org>
(cherry picked from commit b5679cebf780c6f1c2451a73bf1842a4409840e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/channel.c
diff --cc drivers/hv/channel.c
index f33dbb282bfc,bea4c9850247..000000000000
--- a/drivers/hv/channel.c
+++ b/drivers/hv/channel.c
@@@ -652,6 -697,40 +652,43 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /* disconnect ring - close all channels */
+ int vmbus_disconnect_ring(struct vmbus_channel *channel)
+ {
+ 	struct vmbus_channel *cur_channel, *tmp;
+ 	int ret;
+ 
+ 	if (channel->primary_channel != NULL)
+ 		return -EINVAL;
+ 
+ 	list_for_each_entry_safe(cur_channel, tmp, &channel->sc_list, sc_list) {
+ 		if (cur_channel->rescind)
+ 			wait_for_completion(&cur_channel->rescind_event);
+ 
+ 		mutex_lock(&vmbus_connection.channel_mutex);
+ 		if (vmbus_close_internal(cur_channel) == 0) {
+ 			vmbus_free_ring(cur_channel);
+ 
+ 			if (cur_channel->rescind)
+ 				hv_process_channel_removal(cur_channel);
+ 		}
+ 		mutex_unlock(&vmbus_connection.channel_mutex);
+ 	}
+ 
+ 	/*
+ 	 * Now close the primary.
+ 	 */
+ 	mutex_lock(&vmbus_connection.channel_mutex);
+ 	ret = vmbus_close_internal(channel);
+ 	mutex_unlock(&vmbus_connection.channel_mutex);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(vmbus_disconnect_ring);
+ 
++>>>>>>> b5679cebf780 (vmbus: fix subchannel removal)
  /*
   * vmbus_close - Close the specified channel
   */
* Unmerged path drivers/hv/channel.c
