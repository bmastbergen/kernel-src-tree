net: phy: fix wrong masks to phy_modify()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] phy: fix wrong masks to phy_modify() (Ivan Vecera) [1685646]
Rebuild_FUZZ: 93.51%
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit f102852f980eac250855504c18f195900616deec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f102852f.failed

The mask argument for phy_modify() in several locations was inverted.

Fixes: fea23fb591cc ("net: phy: convert read-modify-write to phy_modify()")
	Reported-by: Heiner Kallweit <hkallweit1@gmail.com>
	Tested-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f102852f980eac250855504c18f195900616deec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/at803x.c
#	drivers/net/phy/marvell.c
#	drivers/net/phy/phy-core.c
#	drivers/net/phy/phy_device.c
diff --cc drivers/net/phy/at803x.c
index 45cbc10de01c,411cf1072bae..000000000000
--- a/drivers/net/phy/at803x.c
+++ b/drivers/net/phy/at803x.c
@@@ -43,23 -160,91 +43,78 @@@ static void at803x_set_wol_mac_addr(str
  	};
  
  	if (!ndev)
 -		return -ENODEV;
 +		return;
  
 -	if (wol->wolopts & WAKE_MAGIC) {
 -		mac = (const u8 *) ndev->dev_addr;
 +	mac = (const u8 *) ndev->dev_addr;
  
 -		if (!is_valid_ether_addr(mac))
 -			return -EINVAL;
 +	if (!is_valid_ether_addr(mac))
 +		return;
  
 -		for (i = 0; i < 3; i++) {
 -			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
 +	for (i = 0; i < 3; i++) {
 +		phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
  				  AT803X_DEVICE_ADDR);
 -			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,
 +		phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,
  				  offsets[i]);
 -			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
 +		phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
  				  AT803X_FUNC_DATA);
 -			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,
 +		phy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,
  				  mac[(i * 2) + 1] | (mac[(i * 2)] << 8));
 -		}
 -
 -		value = phy_read(phydev, AT803X_INTR_ENABLE);
 -		value |= AT803X_INTR_ENABLE_WOL;
 -		ret = phy_write(phydev, AT803X_INTR_ENABLE, value);
 -		if (ret)
 -			return ret;
 -		value = phy_read(phydev, AT803X_INTR_STATUS);
 -	} else {
 -		value = phy_read(phydev, AT803X_INTR_ENABLE);
 -		value &= (~AT803X_INTR_ENABLE_WOL);
 -		ret = phy_write(phydev, AT803X_INTR_ENABLE, value);
 -		if (ret)
 -			return ret;
 -		value = phy_read(phydev, AT803X_INTR_STATUS);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	return ret;
+ }
+ 
+ static void at803x_get_wol(struct phy_device *phydev,
+ 			   struct ethtool_wolinfo *wol)
+ {
+ 	u32 value;
+ 
+ 	wol->supported = WAKE_MAGIC;
+ 	wol->wolopts = 0;
+ 
+ 	value = phy_read(phydev, AT803X_INTR_ENABLE);
+ 	if (value & AT803X_INTR_ENABLE_WOL)
+ 		wol->wolopts |= WAKE_MAGIC;
+ }
+ 
+ static int at803x_suspend(struct phy_device *phydev)
+ {
+ 	int value;
+ 	int wol_enabled;
+ 
+ 	value = phy_read(phydev, AT803X_INTR_ENABLE);
+ 	wol_enabled = value & AT803X_INTR_ENABLE_WOL;
+ 
+ 	if (wol_enabled)
+ 		value = BMCR_ISOLATE;
+ 	else
+ 		value = BMCR_PDOWN;
+ 
+ 	phy_modify(phydev, MII_BMCR, 0, value);
+ 
+ 	return 0;
+ }
+ 
+ static int at803x_resume(struct phy_device *phydev)
+ {
+ 	return phy_modify(phydev, MII_BMCR, BMCR_PDOWN | BMCR_ISOLATE, 0);
+ }
+ 
+ static int at803x_probe(struct phy_device *phydev)
+ {
+ 	struct device *dev = &phydev->mdio.dev;
+ 	struct at803x_priv *priv;
+ 
+ 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+ 	phydev->priv = priv;
+ 
+ 	return 0;
++>>>>>>> f102852f980e (net: phy: fix wrong masks to phy_modify())
  }
  
  static int at803x_config_init(struct phy_device *phydev)
diff --cc drivers/net/phy/marvell.c
index e84c049c80c3,fd66304f18b7..000000000000
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@@ -410,6 -499,280 +410,283 @@@ static int m88e1318_config_aneg(struct 
  	return m88e1121_config_aneg(phydev);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * ethtool_adv_to_fiber_adv_t
+  * @ethadv: the ethtool advertisement settings
+  *
+  * A small helper function that translates ethtool advertisement
+  * settings to phy autonegotiation advertisements for the
+  * MII_ADV register for fiber link.
+  */
+ static inline u32 ethtool_adv_to_fiber_adv_t(u32 ethadv)
+ {
+ 	u32 result = 0;
+ 
+ 	if (ethadv & ADVERTISED_1000baseT_Half)
+ 		result |= ADVERTISE_FIBER_1000HALF;
+ 	if (ethadv & ADVERTISED_1000baseT_Full)
+ 		result |= ADVERTISE_FIBER_1000FULL;
+ 
+ 	if ((ethadv & ADVERTISE_PAUSE_ASYM) && (ethadv & ADVERTISE_PAUSE_CAP))
+ 		result |= LPA_PAUSE_ASYM_FIBER;
+ 	else if (ethadv & ADVERTISE_PAUSE_CAP)
+ 		result |= (ADVERTISE_PAUSE_FIBER
+ 			   & (~ADVERTISE_PAUSE_ASYM_FIBER));
+ 
+ 	return result;
+ }
+ 
+ /**
+  * marvell_config_aneg_fiber - restart auto-negotiation or write BMCR
+  * @phydev: target phy_device struct
+  *
+  * Description: If auto-negotiation is enabled, we configure the
+  *   advertising, and then restart auto-negotiation.  If it is not
+  *   enabled, then we write the BMCR. Adapted for fiber link in
+  *   some Marvell's devices.
+  */
+ static int marvell_config_aneg_fiber(struct phy_device *phydev)
+ {
+ 	int changed = 0;
+ 	int err;
+ 	int adv, oldadv;
+ 	u32 advertise;
+ 
+ 	if (phydev->autoneg != AUTONEG_ENABLE)
+ 		return genphy_setup_forced(phydev);
+ 
+ 	/* Only allow advertising what this PHY supports */
+ 	phydev->advertising &= phydev->supported;
+ 	advertise = phydev->advertising;
+ 
+ 	/* Setup fiber advertisement */
+ 	adv = phy_read(phydev, MII_ADVERTISE);
+ 	if (adv < 0)
+ 		return adv;
+ 
+ 	oldadv = adv;
+ 	adv &= ~(ADVERTISE_FIBER_1000HALF | ADVERTISE_FIBER_1000FULL
+ 		| LPA_PAUSE_FIBER);
+ 	adv |= ethtool_adv_to_fiber_adv_t(advertise);
+ 
+ 	if (adv != oldadv) {
+ 		err = phy_write(phydev, MII_ADVERTISE, adv);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		changed = 1;
+ 	}
+ 
+ 	if (changed == 0) {
+ 		/* Advertisement hasn't changed, but maybe aneg was never on to
+ 		 * begin with?	Or maybe phy was isolated?
+ 		 */
+ 		int ctl = phy_read(phydev, MII_BMCR);
+ 
+ 		if (ctl < 0)
+ 			return ctl;
+ 
+ 		if (!(ctl & BMCR_ANENABLE) || (ctl & BMCR_ISOLATE))
+ 			changed = 1; /* do restart aneg */
+ 	}
+ 
+ 	/* Only restart aneg if we are advertising something different
+ 	 * than we were before.
+ 	 */
+ 	if (changed > 0)
+ 		changed = genphy_restart_aneg(phydev);
+ 
+ 	return changed;
+ }
+ 
+ static int m88e1510_config_aneg(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 	if (err < 0)
+ 		goto error;
+ 
+ 	/* Configure the copper link first */
+ 	err = m88e1318_config_aneg(phydev);
+ 	if (err < 0)
+ 		goto error;
+ 
+ 	/* Do not touch the fiber page if we're in copper->sgmii mode */
+ 	if (phydev->interface == PHY_INTERFACE_MODE_SGMII)
+ 		return 0;
+ 
+ 	/* Then the fiber link */
+ 	err = marvell_set_page(phydev, MII_MARVELL_FIBER_PAGE);
+ 	if (err < 0)
+ 		goto error;
+ 
+ 	err = marvell_config_aneg_fiber(phydev);
+ 	if (err < 0)
+ 		goto error;
+ 
+ 	return marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 
+ error:
+ 	marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 	return err;
+ }
+ 
+ static int marvell_config_init(struct phy_device *phydev)
+ {
+ 	/* Set registers from marvell,reg-init DT property */
+ 	return marvell_of_reg_init(phydev);
+ }
+ 
+ static int m88e1116r_config_init(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = genphy_soft_reset(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	mdelay(500);
+ 
+ 	err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = marvell_set_polarity(phydev, phydev->mdix_ctrl);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = marvell_set_downshift(phydev, true, 8);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (phy_interface_is_rgmii(phydev)) {
+ 		err = m88e1121_config_aneg_rgmii_delays(phydev);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	err = genphy_soft_reset(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	return marvell_config_init(phydev);
+ }
+ 
+ static int m88e3016_config_init(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	/* Enable Scrambler and Auto-Crossover */
+ 	ret = phy_modify(phydev, MII_88E3016_PHY_SPEC_CTRL,
+ 			 MII_88E3016_DISABLE_SCRAMBLER,
+ 			 MII_88E3016_AUTO_MDIX_CROSSOVER);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return marvell_config_init(phydev);
+ }
+ 
+ static int m88e1111_config_init_hwcfg_mode(struct phy_device *phydev,
+ 					   u16 mode,
+ 					   int fibre_copper_auto)
+ {
+ 	if (fibre_copper_auto)
+ 		mode |= MII_M1111_HWCFG_FIBER_COPPER_AUTO;
+ 
+ 	return phy_modify(phydev, MII_M1111_PHY_EXT_SR,
+ 			  MII_M1111_HWCFG_MODE_MASK |
+ 			  MII_M1111_HWCFG_FIBER_COPPER_AUTO |
+ 			  MII_M1111_HWCFG_FIBER_COPPER_RES,
+ 			  mode);
+ }
+ 
+ static int m88e1111_config_init_rgmii_delays(struct phy_device *phydev)
+ {
+ 	int delay;
+ 
+ 	if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {
+ 		delay = MII_M1111_RGMII_RX_DELAY | MII_M1111_RGMII_TX_DELAY;
+ 	} else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID) {
+ 		delay = MII_M1111_RGMII_RX_DELAY;
+ 	} else if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID) {
+ 		delay = MII_M1111_RGMII_TX_DELAY;
+ 	} else {
+ 		delay = 0;
+ 	}
+ 
+ 	return phy_modify(phydev, MII_M1111_PHY_EXT_CR,
+ 			  MII_M1111_RGMII_RX_DELAY | MII_M1111_RGMII_TX_DELAY,
+ 			  delay);
+ }
+ 
+ static int m88e1111_config_init_rgmii(struct phy_device *phydev)
+ {
+ 	int temp;
+ 	int err;
+ 
+ 	err = m88e1111_config_init_rgmii_delays(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	temp = phy_read(phydev, MII_M1111_PHY_EXT_SR);
+ 	if (temp < 0)
+ 		return temp;
+ 
+ 	temp &= ~(MII_M1111_HWCFG_MODE_MASK);
+ 
+ 	if (temp & MII_M1111_HWCFG_FIBER_COPPER_RES)
+ 		temp |= MII_M1111_HWCFG_MODE_FIBER_RGMII;
+ 	else
+ 		temp |= MII_M1111_HWCFG_MODE_COPPER_RGMII;
+ 
+ 	return phy_write(phydev, MII_M1111_PHY_EXT_SR, temp);
+ }
+ 
+ static int m88e1111_config_init_sgmii(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = m88e1111_config_init_hwcfg_mode(
+ 		phydev,
+ 		MII_M1111_HWCFG_MODE_SGMII_NO_CLK,
+ 		MII_M1111_HWCFG_FIBER_COPPER_AUTO);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/* make sure copper is selected */
+ 	return marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ }
+ 
+ static int m88e1111_config_init_rtbi(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = m88e1111_config_init_rgmii_delays(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = m88e1111_config_init_hwcfg_mode(
+ 		phydev,
+ 		MII_M1111_HWCFG_MODE_RTBI,
+ 		MII_M1111_HWCFG_FIBER_COPPER_AUTO);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/* soft reset */
+ 	err = genphy_soft_reset(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	return m88e1111_config_init_hwcfg_mode(
+ 		phydev,
+ 		MII_M1111_HWCFG_MODE_RTBI,
+ 		MII_M1111_HWCFG_FIBER_COPPER_AUTO);
+ }
+ 
++>>>>>>> f102852f980e (net: phy: fix wrong masks to phy_modify())
  static int m88e1111_config_init(struct phy_device *phydev)
  {
  	int err;
@@@ -508,7 -799,67 +785,71 @@@
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
 +	return phy_write(phydev, MII_BMCR, BMCR_RESET);
++=======
+ 	return genphy_soft_reset(phydev);
+ }
+ 
+ static int m88e1121_config_init(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	/* Default PHY LED config: LED[0] .. Link, LED[1] .. Activity */
+ 	err = phy_write_paged(phydev, MII_MARVELL_LED_PAGE,
+ 			      MII_88E1121_PHY_LED_CTRL,
+ 			      MII_88E1121_PHY_LED_DEF);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/* Set marvell,reg-init configuration from device tree */
+ 	return marvell_config_init(phydev);
+ }
+ 
+ static int m88e1510_config_init(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	/* SGMII-to-Copper mode initialization */
+ 	if (phydev->interface == PHY_INTERFACE_MODE_SGMII) {
+ 		u32 pause;
+ 
+ 		/* Select page 18 */
+ 		err = marvell_set_page(phydev, 18);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* In reg 20, write MODE[2:0] = 0x1 (SGMII to Copper) */
+ 		err = phy_modify(phydev, MII_88E1510_GEN_CTRL_REG_1,
+ 				 MII_88E1510_GEN_CTRL_REG_1_MODE_MASK,
+ 				 MII_88E1510_GEN_CTRL_REG_1_MODE_SGMII);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* PHY reset is necessary after changing MODE[2:0] */
+ 		err = phy_modify(phydev, MII_88E1510_GEN_CTRL_REG_1, 0,
+ 				 MII_88E1510_GEN_CTRL_REG_1_RESET);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* Reset page selection */
+ 		err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		/* There appears to be a bug in the 88e1512 when used in
+ 		 * SGMII to copper mode, where the AN advertisment register
+ 		 * clears the pause bits each time a negotiation occurs.
+ 		 * This means we can never be truely sure what was advertised,
+ 		 * so disable Pause support.
+ 		 */
+ 		pause = SUPPORTED_Pause | SUPPORTED_Asym_Pause;
+ 		phydev->supported &= ~pause;
+ 		phydev->advertising &= ~pause;
+ 	}
+ 
+ 	return m88e1121_config_init(phydev);
++>>>>>>> f102852f980e (net: phy: fix wrong masks to phy_modify())
  }
  
  static int m88e1118_config_aneg(struct phy_device *phydev)
@@@ -590,7 -940,42 +931,46 @@@ static int m88e1149_config_init(struct 
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
 +	return phy_write(phydev, MII_BMCR, BMCR_RESET);
++=======
+ 	return genphy_soft_reset(phydev);
+ }
+ 
+ static int m88e1145_config_init_rgmii(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = m88e1111_config_init_rgmii_delays(phydev);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (phydev->dev_flags & MARVELL_PHY_M1145_FLAGS_RESISTANCE) {
+ 		err = phy_write(phydev, 0x1d, 0x0012);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = phy_modify(phydev, 0x1e, 0x0fc0,
+ 				 2 << 9 | /* 36 ohm */
+ 				 2 << 6); /* 39 ohm */
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = phy_write(phydev, 0x1d, 0x3);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = phy_write(phydev, 0x1e, 0x8000);
+ 	}
+ 	return err;
+ }
+ 
+ static int m88e1145_config_init_sgmii(struct phy_device *phydev)
+ {
+ 	return m88e1111_config_init_hwcfg_mode(
+ 		phydev, MII_M1111_HWCFG_MODE_SGMII_NO_CLK,
+ 		MII_M1111_HWCFG_FIBER_COPPER_AUTO);
++>>>>>>> f102852f980e (net: phy: fix wrong masks to phy_modify())
  }
  
  static int m88e1145_config_init(struct phy_device *phydev)
@@@ -758,63 -1164,232 +1138,70 @@@ static int m88e1121_did_interrupt(struc
  	return 0;
  }
  
 -/* marvell_read_status_page
 - *
 - * Description:
 - *   Check the link, then figure out the current state
 - *   by comparing what we advertise with what the link partner
 - *   advertises.  Start by checking the gigabit possibilities,
 - *   then move on to 10/100.
 - */
 -static int marvell_read_status_page(struct phy_device *phydev, int page)
 +static void m88e1318_get_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)
  {
 -	int fiber;
 -	int err;
 -
 -	/* Detect and update the link, but return if there
 -	 * was an error
 -	 */
 -	if (page == MII_MARVELL_FIBER_PAGE)
 -		fiber = 1;
 -	else
 -		fiber = 0;
 +	wol->supported = WAKE_MAGIC;
 +	wol->wolopts = 0;
  
 -	err = marvell_update_link(phydev, fiber);
 -	if (err)
 -		return err;
 +	if (phy_write(phydev, MII_MARVELL_PHY_PAGE,
 +		      MII_88E1318S_PHY_WOL_PAGE) < 0)
 +		return;
  
 -	if (phydev->autoneg == AUTONEG_ENABLE)
 -		err = marvell_read_status_page_an(phydev, fiber);
 -	else
 -		err = marvell_read_status_page_fixed(phydev);
 +	if (phy_read(phydev, MII_88E1318S_PHY_WOL_CTRL) &
 +	    MII_88E1318S_PHY_WOL_CTRL_MAGIC_PACKET_MATCH_ENABLE)
 +		wol->wolopts |= WAKE_MAGIC;
  
 -	return err;
 +	if (phy_write(phydev, MII_MARVELL_PHY_PAGE, 0x00) < 0)
 +		return;
  }
  
 -/* marvell_read_status
 - *
 - * Some Marvell's phys have two modes: fiber and copper.
 - * Both need status checked.
 - * Description:
 - *   First, check the fiber link and status.
 - *   If the fiber link is down, check the copper link and status which
 - *   will be the default value if both link are down.
 - */
 -static int marvell_read_status(struct phy_device *phydev)
 +static int m88e1318_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)
  {
 -	int err;
 +	int err, oldpage, temp;
  
 -	/* Check the fiber mode first */
 -	if (phydev->supported & SUPPORTED_FIBRE &&
 -	    phydev->interface != PHY_INTERFACE_MODE_SGMII) {
 -		err = marvell_set_page(phydev, MII_MARVELL_FIBER_PAGE);
 +	oldpage = phy_read(phydev, MII_MARVELL_PHY_PAGE);
 +
 +	if (wol->wolopts & WAKE_MAGIC) {
 +		/* Explicitly switch to page 0x00, just to be sure */
 +		err = phy_write(phydev, MII_MARVELL_PHY_PAGE, 0x00);
  		if (err < 0)
 -			goto error;
 +			return err;
  
 -		err = marvell_read_status_page(phydev, MII_MARVELL_FIBER_PAGE);
 +		/* Enable the WOL interrupt */
 +		temp = phy_read(phydev, MII_88E1318S_PHY_CSIER);
 +		temp |= MII_88E1318S_PHY_CSIER_WOL_EIE;
 +		err = phy_write(phydev, MII_88E1318S_PHY_CSIER, temp);
  		if (err < 0)
 -			goto error;
 -
 -		/* If the fiber link is up, it is the selected and
 -		 * used link. In this case, we need to stay in the
 -		 * fiber page. Please to be careful about that, avoid
 -		 * to restore Copper page in other functions which
 -		 * could break the behaviour for some fiber phy like
 -		 * 88E1512.
 -		 */
 -		if (phydev->link)
 -			return 0;
 +			return err;
  
 -		/* If fiber link is down, check and save copper mode state */
 -		err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
 +		err = phy_write(phydev, MII_MARVELL_PHY_PAGE,
 +				MII_88E1318S_PHY_LED_PAGE);
  		if (err < 0)
 -			goto error;
 -	}
 +			return err;
  
 -	return marvell_read_status_page(phydev, MII_MARVELL_COPPER_PAGE);
 +		/* Setup LED[2] as interrupt pin (active low) */
++<<<<<<< HEAD
 +		temp = phy_read(phydev, MII_88E1318S_PHY_LED_TCR);
 +		temp &= ~MII_88E1318S_PHY_LED_TCR_FORCE_INT;
 +		temp |= MII_88E1318S_PHY_LED_TCR_INTn_ENABLE;
 +		temp |= MII_88E1318S_PHY_LED_TCR_INT_ACTIVE_LOW;
 +		err = phy_write(phydev, MII_88E1318S_PHY_LED_TCR, temp);
++=======
++		err = __phy_modify(phydev, MII_88E1318S_PHY_LED_TCR,
++				   MII_88E1318S_PHY_LED_TCR_FORCE_INT,
++				   MII_88E1318S_PHY_LED_TCR_INTn_ENABLE |
++				   MII_88E1318S_PHY_LED_TCR_INT_ACTIVE_LOW);
++>>>>>>> f102852f980e (net: phy: fix wrong masks to phy_modify())
 +		if (err < 0)
 +			return err;
  
 -error:
 -	marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
 -	return err;
 -}
 -
 -/* marvell_suspend
 - *
 - * Some Marvell's phys have two modes: fiber and copper.
 - * Both need to be suspended
 - */
 -static int marvell_suspend(struct phy_device *phydev)
 -{
 -	int err;
 -
 -	/* Suspend the fiber mode first */
 -	if (!(phydev->supported & SUPPORTED_FIBRE)) {
 -		err = marvell_set_page(phydev, MII_MARVELL_FIBER_PAGE);
 -		if (err < 0)
 -			goto error;
 -
 -		/* With the page set, use the generic suspend */
 -		err = genphy_suspend(phydev);
 -		if (err < 0)
 -			goto error;
 -
 -		/* Then, the copper link */
 -		err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
 -		if (err < 0)
 -			goto error;
 -	}
 -
 -	/* With the page set, use the generic suspend */
 -	return genphy_suspend(phydev);
 -
 -error:
 -	marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
 -	return err;
 -}
 -
 -/* marvell_resume
 - *
 - * Some Marvell's phys have two modes: fiber and copper.
 - * Both need to be resumed
 - */
 -static int marvell_resume(struct phy_device *phydev)
 -{
 -	int err;
 -
 -	/* Resume the fiber mode first */
 -	if (!(phydev->supported & SUPPORTED_FIBRE)) {
 -		err = marvell_set_page(phydev, MII_MARVELL_FIBER_PAGE);
 -		if (err < 0)
 -			goto error;
 -
 -		/* With the page set, use the generic resume */
 -		err = genphy_resume(phydev);
 -		if (err < 0)
 -			goto error;
 -
 -		/* Then, the copper link */
 -		err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
 -		if (err < 0)
 -			goto error;
 -	}
 -
 -	/* With the page set, use the generic resume */
 -	return genphy_resume(phydev);
 -
 -error:
 -	marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
 -	return err;
 -}
 -
 -static int marvell_aneg_done(struct phy_device *phydev)
 -{
 -	int retval = phy_read(phydev, MII_M1011_PHY_STATUS);
 -
 -	return (retval < 0) ? retval : (retval & MII_M1011_PHY_STATUS_RESOLVED);
 -}
 -
 -static int m88e1121_did_interrupt(struct phy_device *phydev)
 -{
 -	int imask;
 -
 -	imask = phy_read(phydev, MII_M1011_IEVENT);
 -
 -	if (imask & MII_M1011_IMASK_INIT)
 -		return 1;
 -
 -	return 0;
 -}
 -
 -static void m88e1318_get_wol(struct phy_device *phydev,
 -			     struct ethtool_wolinfo *wol)
 -{
 -	int oldpage, ret = 0;
 -
 -	wol->supported = WAKE_MAGIC;
 -	wol->wolopts = 0;
 -
 -	oldpage = phy_select_page(phydev, MII_MARVELL_WOL_PAGE);
 -	if (oldpage < 0)
 -		goto error;
 -
 -	ret = __phy_read(phydev, MII_88E1318S_PHY_WOL_CTRL);
 -	if (ret & MII_88E1318S_PHY_WOL_CTRL_MAGIC_PACKET_MATCH_ENABLE)
 -		wol->wolopts |= WAKE_MAGIC;
 -
 -error:
 -	phy_restore_page(phydev, oldpage, ret);
 -}
 -
 -static int m88e1318_set_wol(struct phy_device *phydev,
 -			    struct ethtool_wolinfo *wol)
 -{
 -	int err = 0, oldpage;
 -
 -	oldpage = phy_save_page(phydev);
 -	if (oldpage < 0)
 -		goto error;
 -
 -	if (wol->wolopts & WAKE_MAGIC) {
 -		/* Explicitly switch to page 0x00, just to be sure */
 -		err = marvell_write_page(phydev, MII_MARVELL_COPPER_PAGE);
 -		if (err < 0)
 -			goto error;
 -
 -		/* Enable the WOL interrupt */
 -		err = __phy_modify(phydev, MII_88E1318S_PHY_CSIER, 0,
 -				   MII_88E1318S_PHY_CSIER_WOL_EIE);
 -		if (err < 0)
 -			goto error;
 -
 -		err = marvell_write_page(phydev, MII_MARVELL_LED_PAGE);
 +		err = phy_write(phydev, MII_MARVELL_PHY_PAGE,
 +				MII_88E1318S_PHY_WOL_PAGE);
  		if (err < 0)
 -			goto error;
 -
 -		/* Setup LED[2] as interrupt pin (active low) */
 -		err = __phy_modify(phydev, MII_88E1318S_PHY_LED_TCR,
 -				   MII_88E1318S_PHY_LED_TCR_FORCE_INT,
 -				   MII_88E1318S_PHY_LED_TCR_INTn_ENABLE |
 -				   MII_88E1318S_PHY_LED_TCR_INT_ACTIVE_LOW);
 -		if (err < 0)
 -			goto error;
 -
 -		err = marvell_write_page(phydev, MII_MARVELL_WOL_PAGE);
 -		if (err < 0)
 -			goto error;
 +			return err;
  
  		/* Store the device address for the magic packet */
 -		err = __phy_write(phydev, MII_88E1318S_PHY_MAGIC_PACKET_WORD2,
 +		err = phy_write(phydev, MII_88E1318S_PHY_MAGIC_PACKET_WORD2,
  				((phydev->attached_dev->dev_addr[5] << 8) |
  				 phydev->attached_dev->dev_addr[4]));
  		if (err < 0)
@@@ -828,34 -1403,409 +1215,40 @@@
  				((phydev->attached_dev->dev_addr[1] << 8) |
  				 phydev->attached_dev->dev_addr[0]));
  		if (err < 0)
 -			goto error;
 +			return err;
  
  		/* Clear WOL status and enable magic packet matching */
 -		err = __phy_modify(phydev, MII_88E1318S_PHY_WOL_CTRL, 0,
 -				   MII_88E1318S_PHY_WOL_CTRL_CLEAR_WOL_STATUS |
 -				   MII_88E1318S_PHY_WOL_CTRL_MAGIC_PACKET_MATCH_ENABLE);
 +		temp = phy_read(phydev, MII_88E1318S_PHY_WOL_CTRL);
 +		temp |= MII_88E1318S_PHY_WOL_CTRL_CLEAR_WOL_STATUS;
 +		temp |= MII_88E1318S_PHY_WOL_CTRL_MAGIC_PACKET_MATCH_ENABLE;
 +		err = phy_write(phydev, MII_88E1318S_PHY_WOL_CTRL, temp);
  		if (err < 0)
 -			goto error;
 +			return err;
  	} else {
 -		err = marvell_write_page(phydev, MII_MARVELL_WOL_PAGE);
 +		err = phy_write(phydev, MII_MARVELL_PHY_PAGE,
 +				MII_88E1318S_PHY_WOL_PAGE);
  		if (err < 0)
 -			goto error;
 +			return err;
  
  		/* Clear WOL status and disable magic packet matching */
++<<<<<<< HEAD
 +		temp = phy_read(phydev, MII_88E1318S_PHY_WOL_CTRL);
 +		temp |= MII_88E1318S_PHY_WOL_CTRL_CLEAR_WOL_STATUS;
 +		temp &= ~MII_88E1318S_PHY_WOL_CTRL_MAGIC_PACKET_MATCH_ENABLE;
 +		err = phy_write(phydev, MII_88E1318S_PHY_WOL_CTRL, temp);
++=======
+ 		err = __phy_modify(phydev, MII_88E1318S_PHY_WOL_CTRL,
+ 				   MII_88E1318S_PHY_WOL_CTRL_MAGIC_PACKET_MATCH_ENABLE,
+ 				   MII_88E1318S_PHY_WOL_CTRL_CLEAR_WOL_STATUS);
++>>>>>>> f102852f980e (net: phy: fix wrong masks to phy_modify())
  		if (err < 0)
 -			goto error;
 -	}
 -
 -error:
 -	return phy_restore_page(phydev, oldpage, err);
 -}
 -
 -static int marvell_get_sset_count(struct phy_device *phydev)
 -{
 -	if (phydev->supported & SUPPORTED_FIBRE)
 -		return ARRAY_SIZE(marvell_hw_stats);
 -	else
 -		return ARRAY_SIZE(marvell_hw_stats) - NB_FIBER_STATS;
 -}
 -
 -static void marvell_get_strings(struct phy_device *phydev, u8 *data)
 -{
 -	int i;
 -
 -	for (i = 0; i < ARRAY_SIZE(marvell_hw_stats); i++) {
 -		memcpy(data + i * ETH_GSTRING_LEN,
 -		       marvell_hw_stats[i].string, ETH_GSTRING_LEN);
 -	}
 -}
 -
 -#ifndef UINT64_MAX
 -#define UINT64_MAX		(u64)(~((u64)0))
 -#endif
 -static u64 marvell_get_stat(struct phy_device *phydev, int i)
 -{
 -	struct marvell_hw_stat stat = marvell_hw_stats[i];
 -	struct marvell_priv *priv = phydev->priv;
 -	int val;
 -	u64 ret;
 -
 -	val = phy_read_paged(phydev, stat.page, stat.reg);
 -	if (val < 0) {
 -		ret = UINT64_MAX;
 -	} else {
 -		val = val & ((1 << stat.bits) - 1);
 -		priv->stats[i] += val;
 -		ret = priv->stats[i];
 -	}
 -
 -	return ret;
 -}
 -
 -static void marvell_get_stats(struct phy_device *phydev,
 -			      struct ethtool_stats *stats, u64 *data)
 -{
 -	int i;
 -
 -	for (i = 0; i < ARRAY_SIZE(marvell_hw_stats); i++)
 -		data[i] = marvell_get_stat(phydev, i);
 -}
 -
 -#ifdef CONFIG_HWMON
 -static int m88e1121_get_temp(struct phy_device *phydev, long *temp)
 -{
 -	int oldpage;
 -	int ret = 0;
 -	int val;
 -
 -	*temp = 0;
 -
 -	oldpage = phy_select_page(phydev, MII_MARVELL_MISC_TEST_PAGE);
 -	if (oldpage < 0)
 -		goto error;
 -
 -	/* Enable temperature sensor */
 -	ret = __phy_read(phydev, MII_88E1121_MISC_TEST);
 -	if (ret < 0)
 -		goto error;
 -
 -	ret = __phy_write(phydev, MII_88E1121_MISC_TEST,
 -			  ret | MII_88E1121_MISC_TEST_TEMP_SENSOR_EN);
 -	if (ret < 0)
 -		goto error;
 -
 -	/* Wait for temperature to stabilize */
 -	usleep_range(10000, 12000);
 -
 -	val = __phy_read(phydev, MII_88E1121_MISC_TEST);
 -	if (val < 0) {
 -		ret = val;
 -		goto error;
 -	}
 -
 -	/* Disable temperature sensor */
 -	ret = __phy_write(phydev, MII_88E1121_MISC_TEST,
 -			  ret & ~MII_88E1121_MISC_TEST_TEMP_SENSOR_EN);
 -	if (ret < 0)
 -		goto error;
 -
 -	*temp = ((val & MII_88E1121_MISC_TEST_TEMP_MASK) - 5) * 5000;
 -
 -error:
 -	return phy_restore_page(phydev, oldpage, ret);
 -}
 -
 -static int m88e1121_hwmon_read(struct device *dev,
 -			       enum hwmon_sensor_types type,
 -			       u32 attr, int channel, long *temp)
 -{
 -	struct phy_device *phydev = dev_get_drvdata(dev);
 -	int err;
 -
 -	switch (attr) {
 -	case hwmon_temp_input:
 -		err = m88e1121_get_temp(phydev, temp);
 -		break;
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 -
 -	return err;
 -}
 -
 -static umode_t m88e1121_hwmon_is_visible(const void *data,
 -					 enum hwmon_sensor_types type,
 -					 u32 attr, int channel)
 -{
 -	if (type != hwmon_temp)
 -		return 0;
 -
 -	switch (attr) {
 -	case hwmon_temp_input:
 -		return 0444;
 -	default:
 -		return 0;
 -	}
 -}
 -
 -static u32 m88e1121_hwmon_chip_config[] = {
 -	HWMON_C_REGISTER_TZ,
 -	0
 -};
 -
 -static const struct hwmon_channel_info m88e1121_hwmon_chip = {
 -	.type = hwmon_chip,
 -	.config = m88e1121_hwmon_chip_config,
 -};
 -
 -static u32 m88e1121_hwmon_temp_config[] = {
 -	HWMON_T_INPUT,
 -	0
 -};
 -
 -static const struct hwmon_channel_info m88e1121_hwmon_temp = {
 -	.type = hwmon_temp,
 -	.config = m88e1121_hwmon_temp_config,
 -};
 -
 -static const struct hwmon_channel_info *m88e1121_hwmon_info[] = {
 -	&m88e1121_hwmon_chip,
 -	&m88e1121_hwmon_temp,
 -	NULL
 -};
 -
 -static const struct hwmon_ops m88e1121_hwmon_hwmon_ops = {
 -	.is_visible = m88e1121_hwmon_is_visible,
 -	.read = m88e1121_hwmon_read,
 -};
 -
 -static const struct hwmon_chip_info m88e1121_hwmon_chip_info = {
 -	.ops = &m88e1121_hwmon_hwmon_ops,
 -	.info = m88e1121_hwmon_info,
 -};
 -
 -static int m88e1510_get_temp(struct phy_device *phydev, long *temp)
 -{
 -	int ret;
 -
 -	*temp = 0;
 -
 -	ret = phy_read_paged(phydev, MII_MARVELL_MISC_TEST_PAGE,
 -			     MII_88E1510_TEMP_SENSOR);
 -	if (ret < 0)
 -		return ret;
 -
 -	*temp = ((ret & MII_88E1510_TEMP_SENSOR_MASK) - 25) * 1000;
 -
 -	return 0;
 -}
 -
 -static int m88e1510_get_temp_critical(struct phy_device *phydev, long *temp)
 -{
 -	int ret;
 -
 -	*temp = 0;
 -
 -	ret = phy_read_paged(phydev, MII_MARVELL_MISC_TEST_PAGE,
 -			     MII_88E1121_MISC_TEST);
 -	if (ret < 0)
 -		return ret;
 -
 -	*temp = (((ret & MII_88E1510_MISC_TEST_TEMP_THRESHOLD_MASK) >>
 -		  MII_88E1510_MISC_TEST_TEMP_THRESHOLD_SHIFT) * 5) - 25;
 -	/* convert to mC */
 -	*temp *= 1000;
 -
 -	return 0;
 -}
 -
 -static int m88e1510_set_temp_critical(struct phy_device *phydev, long temp)
 -{
 -	temp = temp / 1000;
 -	temp = clamp_val(DIV_ROUND_CLOSEST(temp, 5) + 5, 0, 0x1f);
 -
 -	return phy_modify_paged(phydev, MII_MARVELL_MISC_TEST_PAGE,
 -				MII_88E1121_MISC_TEST,
 -				MII_88E1510_MISC_TEST_TEMP_THRESHOLD_MASK,
 -				temp << MII_88E1510_MISC_TEST_TEMP_THRESHOLD_SHIFT);
 -}
 -
 -static int m88e1510_get_temp_alarm(struct phy_device *phydev, long *alarm)
 -{
 -	int ret;
 -
 -	*alarm = false;
 -
 -	ret = phy_read_paged(phydev, MII_MARVELL_MISC_TEST_PAGE,
 -			     MII_88E1121_MISC_TEST);
 -	if (ret < 0)
 -		return ret;
 -
 -	*alarm = !!(ret & MII_88E1510_MISC_TEST_TEMP_IRQ);
 -
 -	return 0;
 -}
 -
 -static int m88e1510_hwmon_read(struct device *dev,
 -			       enum hwmon_sensor_types type,
 -			       u32 attr, int channel, long *temp)
 -{
 -	struct phy_device *phydev = dev_get_drvdata(dev);
 -	int err;
 -
 -	switch (attr) {
 -	case hwmon_temp_input:
 -		err = m88e1510_get_temp(phydev, temp);
 -		break;
 -	case hwmon_temp_crit:
 -		err = m88e1510_get_temp_critical(phydev, temp);
 -		break;
 -	case hwmon_temp_max_alarm:
 -		err = m88e1510_get_temp_alarm(phydev, temp);
 -		break;
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 -
 -	return err;
 -}
 -
 -static int m88e1510_hwmon_write(struct device *dev,
 -				enum hwmon_sensor_types type,
 -				u32 attr, int channel, long temp)
 -{
 -	struct phy_device *phydev = dev_get_drvdata(dev);
 -	int err;
 -
 -	switch (attr) {
 -	case hwmon_temp_crit:
 -		err = m88e1510_set_temp_critical(phydev, temp);
 -		break;
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 -	return err;
 -}
 -
 -static umode_t m88e1510_hwmon_is_visible(const void *data,
 -					 enum hwmon_sensor_types type,
 -					 u32 attr, int channel)
 -{
 -	if (type != hwmon_temp)
 -		return 0;
 -
 -	switch (attr) {
 -	case hwmon_temp_input:
 -	case hwmon_temp_max_alarm:
 -		return 0444;
 -	case hwmon_temp_crit:
 -		return 0644;
 -	default:
 -		return 0;
 -	}
 -}
 -
 -static u32 m88e1510_hwmon_temp_config[] = {
 -	HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_MAX_ALARM,
 -	0
 -};
 -
 -static const struct hwmon_channel_info m88e1510_hwmon_temp = {
 -	.type = hwmon_temp,
 -	.config = m88e1510_hwmon_temp_config,
 -};
 -
 -static const struct hwmon_channel_info *m88e1510_hwmon_info[] = {
 -	&m88e1121_hwmon_chip,
 -	&m88e1510_hwmon_temp,
 -	NULL
 -};
 -
 -static const struct hwmon_ops m88e1510_hwmon_hwmon_ops = {
 -	.is_visible = m88e1510_hwmon_is_visible,
 -	.read = m88e1510_hwmon_read,
 -	.write = m88e1510_hwmon_write,
 -};
 -
 -static const struct hwmon_chip_info m88e1510_hwmon_chip_info = {
 -	.ops = &m88e1510_hwmon_hwmon_ops,
 -	.info = m88e1510_hwmon_info,
 -};
 -
 -static int marvell_hwmon_name(struct phy_device *phydev)
 -{
 -	struct marvell_priv *priv = phydev->priv;
 -	struct device *dev = &phydev->mdio.dev;
 -	const char *devname = dev_name(dev);
 -	size_t len = strlen(devname);
 -	int i, j;
 -
 -	priv->hwmon_name = devm_kzalloc(dev, len, GFP_KERNEL);
 -	if (!priv->hwmon_name)
 -		return -ENOMEM;
 -
 -	for (i = j = 0; i < len && devname[i]; i++) {
 -		if (isalnum(devname[i]))
 -			priv->hwmon_name[j++] = devname[i];
 +			return err;
  	}
  
 -	return 0;
 -}
 -
 -static int marvell_hwmon_probe(struct phy_device *phydev,
 -			       const struct hwmon_chip_info *chip)
 -{
 -	struct marvell_priv *priv = phydev->priv;
 -	struct device *dev = &phydev->mdio.dev;
 -	int err;
 -
 -	err = marvell_hwmon_name(phydev);
 -	if (err)
 +	err = phy_write(phydev, MII_MARVELL_PHY_PAGE, oldpage);
 +	if (err < 0)
  		return err;
  
 -	priv->hwmon_dev = devm_hwmon_device_register_with_info(
 -		dev, priv->hwmon_name, phydev, chip, NULL);
 -
 -	return PTR_ERR_OR_ZERO(priv->hwmon_dev);
 -}
 -
 -static int m88e1121_hwmon_probe(struct phy_device *phydev)
 -{
 -	return marvell_hwmon_probe(phydev, &m88e1121_hwmon_chip_info);
 -}
 -
 -static int m88e1510_hwmon_probe(struct phy_device *phydev)
 -{
 -	return marvell_hwmon_probe(phydev, &m88e1510_hwmon_chip_info);
 -}
 -#else
 -static int m88e1121_hwmon_probe(struct phy_device *phydev)
 -{
 -	return 0;
 -}
 -
 -static int m88e1510_hwmon_probe(struct phy_device *phydev)
 -{
 -	return 0;
 -}
 -#endif
 -
 -static int marvell_probe(struct phy_device *phydev)
 -{
 -	struct marvell_priv *priv;
 -
 -	priv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);
 -	if (!priv)
 -		return -ENOMEM;
 -
 -	phydev->priv = priv;
 -
  	return 0;
  }
  
diff --cc drivers/net/phy/phy_device.c
index f7f4abfd4a6f,6bd11a070ec8..000000000000
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@@ -864,17 -1392,9 +864,22 @@@ static int genphy_setup_forced(struct p
   */
  int genphy_restart_aneg(struct phy_device *phydev)
  {
 +	int ctl = phy_read(phydev, MII_BMCR);
 +
 +	if (ctl < 0)
 +		return ctl;
 +
 +	ctl |= BMCR_ANENABLE | BMCR_ANRESTART;
 +
  	/* Don't isolate the PHY if we're negotiating */
++<<<<<<< HEAD
 +	ctl &= ~BMCR_ISOLATE;
 +
 +	return phy_write(phydev, MII_BMCR, ctl);
++=======
+ 	return phy_modify(phydev, MII_BMCR, BMCR_ISOLATE,
+ 			  BMCR_ANENABLE | BMCR_ANRESTART);
++>>>>>>> f102852f980e (net: phy: fix wrong masks to phy_modify())
  }
  EXPORT_SYMBOL(genphy_restart_aneg);
  
@@@ -1189,28 -1664,40 +1194,61 @@@ int genphy_suspend(struct phy_device *p
  }
  EXPORT_SYMBOL(genphy_suspend);
  
 +static int gen10g_suspend(struct phy_device *phydev)
 +{
 +	return 0;
 +}
 +
  int genphy_resume(struct phy_device *phydev)
  {
++<<<<<<< HEAD
 +	int value;
 +
 +	mutex_lock(&phydev->lock);
 +
 +	value = phy_read(phydev, MII_BMCR);
 +	phy_write(phydev, MII_BMCR, value & ~BMCR_PDOWN);
 +
 +	mutex_unlock(&phydev->lock);
 +
 +	return 0;
++=======
+ 	return phy_modify(phydev, MII_BMCR, BMCR_PDOWN, 0);
++>>>>>>> f102852f980e (net: phy: fix wrong masks to phy_modify())
  }
  EXPORT_SYMBOL(genphy_resume);
  
 -int genphy_loopback(struct phy_device *phydev, bool enable)
 +static int gen10g_resume(struct phy_device *phydev)
  {
++<<<<<<< HEAD
++=======
+ 	return phy_modify(phydev, MII_BMCR, BMCR_LOOPBACK,
+ 			  enable ? BMCR_LOOPBACK : 0);
+ }
+ EXPORT_SYMBOL(genphy_loopback);
+ 
+ static int __set_phy_supported(struct phy_device *phydev, u32 max_speed)
+ {
+ 	/* The default values for phydev->supported are provided by the PHY
+ 	 * driver "features" member, we want to reset to sane defaults first
+ 	 * before supporting higher speeds.
+ 	 */
+ 	phydev->supported &= PHY_DEFAULT_FEATURES;
+ 
+ 	switch (max_speed) {
+ 	default:
+ 		return -ENOTSUPP;
+ 	case SPEED_1000:
+ 		phydev->supported |= PHY_1000BT_FEATURES;
+ 		/* fall through */
+ 	case SPEED_100:
+ 		phydev->supported |= PHY_100BT_FEATURES;
+ 		/* fall through */
+ 	case SPEED_10:
+ 		phydev->supported |= PHY_10BT_FEATURES;
+ 	}
+ 
++>>>>>>> f102852f980e (net: phy: fix wrong masks to phy_modify())
  	return 0;
  }
  
* Unmerged path drivers/net/phy/phy-core.c
* Unmerged path drivers/net/phy/at803x.c
* Unmerged path drivers/net/phy/marvell.c
* Unmerged path drivers/net/phy/phy-core.c
* Unmerged path drivers/net/phy/phy_device.c
