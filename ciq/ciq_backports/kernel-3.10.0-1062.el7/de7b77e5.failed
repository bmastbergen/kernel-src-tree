cpu/hotplug: Create SMT sysfs interface for all arches

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit de7b77e5bb9451417ca57f1b6501da654587c048
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/de7b77e5.failed

Make the /sys/devices/system/cpu/smt/* files available on all arches, so
user space has a consistent way to detect whether SMT is enabled.

The 'control' file now shows 'notimplemented' for architectures which
don't yet have CONFIG_HOTPLUG_SMT.

[ tglx: Make notimplemented a real state ]

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Waiman Long <longman@redhat.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Jiri Kosina <jikos@kernel.org>
Link: https://lkml.kernel.org/r/469c2b98055f2c41e75748e06447d592a64080c9.1553635520.git.jpoimboe@redhat.com

(cherry picked from commit de7b77e5bb9451417ca57f1b6501da654587c048)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/ABI/testing/sysfs-devices-system-cpu
#	kernel/cpu.c
diff --cc Documentation/ABI/testing/sysfs-devices-system-cpu
index ff65f15670cd,5eea46fefcb2..000000000000
--- a/Documentation/ABI/testing/sysfs-devices-system-cpu
+++ b/Documentation/ABI/testing/sysfs-devices-system-cpu
@@@ -303,7 -511,12 +303,19 @@@ Description:	Control Symetric Multi Thr
  		control: Read/write interface to control SMT. Possible
  			 values:
  
++<<<<<<< HEAD
 +			 "on"		SMT is enabled
 +			 "off"		SMT is disabled
 +			 "forceoff"	SMT is force disabled. Cannot be changed.
 +			 "notsupported" SMT is not supported by the CPU
++=======
+ 			 "on"		  SMT is enabled
+ 			 "off"		  SMT is disabled
+ 			 "forceoff"	  SMT is force disabled. Cannot be changed.
+ 			 "notsupported"   SMT is not supported by the CPU
+ 			 "notimplemented" SMT runtime toggling is not
+ 					  implemented for the architecture
+ 
+ 			 If control status is "forceoff" or "notsupported" writes
+ 			 are rejected.
++>>>>>>> de7b77e5bb94 (cpu/hotplug: Create SMT sysfs interface for all arches)
diff --cc kernel/cpu.c
index 364a4aba2443,b8bf3f93e39b..000000000000
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@@ -916,31 -2197,38 +934,51 @@@ static const struct attribute_group cpu
  	NULL
  };
  
- static int __init cpu_smt_state_init(void)
+ static int __init cpu_smt_sysfs_init(void)
  {
 +	/*
 +	 * If SMT was disabled by BIOS, detect it here, after the CPUs have
 +	 * been brought online.  This ensures the smt/l1tf sysfs entries are
 +	 * consistent with reality.  Note this may overwrite cpu_smt_control's
 +	 * previous setting.
 +	 */
 +	if (topology_max_smt_threads() == 1)
 +		cpu_smt_control = CPU_SMT_NOT_SUPPORTED;
 +
  	return sysfs_create_group(&cpu_subsys.dev_root->kobj,
  				  &cpuhp_smt_attr_group);
  }
  
- #else
- static inline int cpu_smt_state_init(void) { return 0; }
- #endif
- 
  static int __init cpuhp_sysfs_init(void)
  {
++<<<<<<< HEAD
 +	return cpu_smt_state_init();
++=======
+ 	int cpu, ret;
+ 
+ 	ret = cpu_smt_sysfs_init();
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = sysfs_create_group(&cpu_subsys.dev_root->kobj,
+ 				 &cpuhp_cpu_root_attr_group);
+ 	if (ret)
+ 		return ret;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		struct device *dev = get_cpu_device(cpu);
+ 
+ 		if (!dev)
+ 			continue;
+ 		ret = sysfs_create_group(&dev->kobj, &cpuhp_cpu_attr_group);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 	return 0;
++>>>>>>> de7b77e5bb94 (cpu/hotplug: Create SMT sysfs interface for all arches)
  }
  device_initcall(cpuhp_sysfs_init);
- #endif
+ #endif /* CONFIG_SYSFS && CONFIG_HOTPLUG_CPU */
  
  /*
   * cpu_bit_bitmap[] is a special, "compressed" data structure that
* Unmerged path Documentation/ABI/testing/sysfs-devices-system-cpu
diff --git a/include/linux/cpu.h b/include/linux/cpu.h
index 82180fe1c5dc..b2dde41fcc75 100644
--- a/include/linux/cpu.h
+++ b/include/linux/cpu.h
@@ -304,6 +304,7 @@ enum cpuhp_smt_control {
 	CPU_SMT_DISABLED,
 	CPU_SMT_FORCE_DISABLED,
 	CPU_SMT_NOT_SUPPORTED,
+	CPU_SMT_NOT_IMPLEMENTED,
 };
 
 #if defined(CONFIG_SMP) && defined(CONFIG_HOTPLUG_SMT)
@@ -311,7 +312,7 @@ extern enum cpuhp_smt_control cpu_smt_control;
 extern void cpu_smt_disable(bool force);
 extern void cpu_smt_check_topology(void);
 #else
-# define cpu_smt_control		(CPU_SMT_ENABLED)
+# define cpu_smt_control		(CPU_SMT_NOT_IMPLEMENTED)
 static inline void cpu_smt_disable(bool force) { }
 static inline void cpu_smt_check_topology(void) { }
 #endif
* Unmerged path kernel/cpu.c
