ovl: fix oopses in ovl_fill_super() failure paths

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 8c25741aaad8be6fbe51510e917c740e0059cf83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/8c25741a.failed

ovl_free_fs() dereferences ofs->workbasedir and ofs->upper_mnt in cases when
those might not have been initialized yet.

Fix the initialization order for these fields.

	Reported-by: syzbot+c75f181dc8429d2eb887@syzkaller.appspotmail.com
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
	Cc:  <stable@vger.kernel.org> # v4.15
Fixes: 95e6d4177cb7 ("ovl: grab reference to workbasedir early")
Fixes: a9075cdb467d ("ovl: factor out ovl_free_fs() helper")
(cherry picked from commit 8c25741aaad8be6fbe51510e917c740e0059cf83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index b0392d1737a3,30adc9d408a0..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -871,121 -962,341 +871,306 @@@ static const struct xattr_handler *ovl_
  	NULL
  };
  
 -static int ovl_get_upper(struct ovl_fs *ofs, struct path *upperpath)
 +static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
++<<<<<<< HEAD
 +	struct path upperpath = { };
++=======
+ 	struct vfsmount *upper_mnt;
+ 	int err;
+ 
+ 	err = ovl_mount_dir(ofs->config.upperdir, upperpath);
+ 	if (err)
+ 		goto out;
+ 
+ 	/* Upper fs should not be r/o */
+ 	if (sb_rdonly(upperpath->mnt->mnt_sb)) {
+ 		pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	err = ovl_check_namelen(upperpath, ofs, ofs->config.upperdir);
+ 	if (err)
+ 		goto out;
+ 
+ 	upper_mnt = clone_private_mount(upperpath);
+ 	err = PTR_ERR(upper_mnt);
+ 	if (IS_ERR(upper_mnt)) {
+ 		pr_err("overlayfs: failed to clone upperpath\n");
+ 		goto out;
+ 	}
+ 
+ 	/* Don't inherit atime flags */
+ 	upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
+ 	ofs->upper_mnt = upper_mnt;
+ 
+ 	err = -EBUSY;
+ 	if (ovl_inuse_trylock(ofs->upper_mnt->mnt_root)) {
+ 		ofs->upperdir_locked = true;
+ 	} else if (ofs->config.index) {
+ 		pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
+ 		goto out;
+ 	} else {
+ 		pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
+ 	}
+ 
+ 	err = 0;
+ out:
+ 	return err;
+ }
+ 
+ static int ovl_make_workdir(struct ovl_fs *ofs, struct path *workpath)
+ {
+ 	struct vfsmount *mnt = ofs->upper_mnt;
+ 	struct dentry *temp;
+ 	int fh_type;
+ 	int err;
+ 
+ 	err = mnt_want_write(mnt);
+ 	if (err)
+ 		return err;
+ 
+ 	ofs->workdir = ovl_workdir_create(ofs, OVL_WORKDIR_NAME, false);
+ 	if (!ofs->workdir)
+ 		goto out;
+ 
+ 	/*
+ 	 * Upper should support d_type, else whiteouts are visible.  Given
+ 	 * workdir and upper are on same fs, we can do iterate_dir() on
+ 	 * workdir. This check requires successful creation of workdir in
+ 	 * previous step.
+ 	 */
+ 	err = ovl_check_d_type_supported(workpath);
+ 	if (err < 0)
+ 		goto out;
+ 
+ 	/*
+ 	 * We allowed this configuration and don't want to break users over
+ 	 * kernel upgrade. So warn instead of erroring out.
+ 	 */
+ 	if (!err)
+ 		pr_warn("overlayfs: upper fs needs to support d_type.\n");
+ 
+ 	/* Check if upper/work fs supports O_TMPFILE */
+ 	temp = ovl_do_tmpfile(ofs->workdir, S_IFREG | 0);
+ 	ofs->tmpfile = !IS_ERR(temp);
+ 	if (ofs->tmpfile)
+ 		dput(temp);
+ 	else
+ 		pr_warn("overlayfs: upper fs does not support tmpfile.\n");
+ 
+ 	/*
+ 	 * Check if upper/work fs supports trusted.overlay.* xattr
+ 	 */
+ 	err = ovl_do_setxattr(ofs->workdir, OVL_XATTR_OPAQUE, "0", 1, 0);
+ 	if (err) {
+ 		ofs->noxattr = true;
+ 		ofs->config.index = false;
+ 		ofs->config.metacopy = false;
+ 		pr_warn("overlayfs: upper fs does not support xattr, falling back to index=off and metacopy=off.\n");
+ 		err = 0;
+ 	} else {
+ 		vfs_removexattr(ofs->workdir, OVL_XATTR_OPAQUE);
+ 	}
+ 
+ 	/* Check if upper/work fs supports file handles */
+ 	fh_type = ovl_can_decode_fh(ofs->workdir->d_sb);
+ 	if (ofs->config.index && !fh_type) {
+ 		ofs->config.index = false;
+ 		pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
+ 	}
+ 
+ 	/* Check if upper fs has 32bit inode numbers */
+ 	if (fh_type != FILEID_INO32_GEN)
+ 		ofs->xino_bits = 0;
+ 
+ 	/* NFS export of r/w mount depends on index */
+ 	if (ofs->config.nfs_export && !ofs->config.index) {
+ 		pr_warn("overlayfs: NFS export requires \"index=on\", falling back to nfs_export=off.\n");
+ 		ofs->config.nfs_export = false;
+ 	}
+ out:
+ 	mnt_drop_write(mnt);
+ 	return err;
+ }
+ 
+ static int ovl_get_workdir(struct ovl_fs *ofs, struct path *upperpath)
+ {
+ 	int err;
++>>>>>>> 8c25741aaad8 (ovl: fix oopses in ovl_fill_super() failure paths)
  	struct path workpath = { };
 +	struct dentry *root_dentry;
 +	struct ovl_entry *oe;
 +	struct ovl_fs *ufs;
 +	const int *upper_stack_depth;
 +	int *overlay_stack_depth;
 +	struct path *stack = NULL;
 +	char *lowertmp;
 +	char *lower;
 +	unsigned int numlower;
 +	unsigned int stacklen = 0;
 +	unsigned int i;
 +	bool remote = false;
 +	struct cred *cred;
 +	int err;
  
 -	err = ovl_mount_dir(ofs->config.workdir, &workpath);
 -	if (err)
 +	err = -ENOMEM;
 +	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
 +	if (!ufs)
  		goto out;
  
 +	ufs->config.index = ovl_index_def;
 +	err = ovl_parse_opt((char *) data, &ufs->config);
 +	if (err)
 +		goto out_free_config;
 +
  	err = -EINVAL;
 -	if (upperpath->mnt != workpath.mnt) {
 -		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 -		goto out;
 -	}
 -	if (!ovl_workdir_ok(workpath.dentry, upperpath->dentry)) {
 -		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 -		goto out;
 +	if (!ufs->config.lowerdir) {
 +		if (!silent)
 +			pr_err("overlayfs: missing 'lowerdir'\n");
 +		goto out_free_config;
  	}
  
++<<<<<<< HEAD
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_free_config;
++=======
+ 	ofs->workbasedir = dget(workpath.dentry);
+ 
+ 	err = -EBUSY;
+ 	if (ovl_inuse_trylock(ofs->workbasedir)) {
+ 		ofs->workdir_locked = true;
+ 	} else if (ofs->config.index) {
+ 		pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
+ 		goto out;
+ 	} else {
+ 		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
++>>>>>>> 8c25741aaad8 (ovl: fix oopses in ovl_fill_super() failure paths)
  	}
 +	*overlay_stack_depth = 0;
  
++<<<<<<< HEAD
 +	sb->s_maxbytes = MAX_LFS_FILESIZE;
 +	if (ufs->config.upperdir) {
 +		if (!ufs->config.workdir) {
 +			pr_err("overlayfs: missing 'workdir'\n");
 +			goto out_free_config;
++=======
+ 	err = ovl_make_workdir(ofs, &workpath);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = 0;
+ out:
+ 	path_put(&workpath);
+ 
+ 	return err;
+ }
+ 
+ static int ovl_get_indexdir(struct ovl_fs *ofs, struct ovl_entry *oe,
+ 			    struct path *upperpath)
+ {
+ 	struct vfsmount *mnt = ofs->upper_mnt;
+ 	int err;
+ 
+ 	err = mnt_want_write(mnt);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Verify lower root is upper root origin */
+ 	err = ovl_verify_origin(upperpath->dentry, oe->lowerstack[0].dentry,
+ 				true);
+ 	if (err) {
+ 		pr_err("overlayfs: failed to verify upper root origin\n");
+ 		goto out;
+ 	}
+ 
+ 	ofs->indexdir = ovl_workdir_create(ofs, OVL_INDEXDIR_NAME, true);
+ 	if (ofs->indexdir) {
+ 		/*
+ 		 * Verify upper root is exclusively associated with index dir.
+ 		 * Older kernels stored upper fh in "trusted.overlay.origin"
+ 		 * xattr. If that xattr exists, verify that it is a match to
+ 		 * upper dir file handle. In any case, verify or set xattr
+ 		 * "trusted.overlay.upper" to indicate that index may have
+ 		 * directory entries.
+ 		 */
+ 		if (ovl_check_origin_xattr(ofs->indexdir)) {
+ 			err = ovl_verify_set_fh(ofs->indexdir, OVL_XATTR_ORIGIN,
+ 						upperpath->dentry, true, false);
+ 			if (err)
+ 				pr_err("overlayfs: failed to verify index dir 'origin' xattr\n");
++>>>>>>> 8c25741aaad8 (ovl: fix oopses in ovl_fill_super() failure paths)
  		}
 -		err = ovl_verify_upper(ofs->indexdir, upperpath->dentry, true);
 -		if (err)
 -			pr_err("overlayfs: failed to verify index dir 'upper' xattr\n");
 -
 -		/* Cleanup bad/stale/orphan index entries */
 -		if (!err)
 -			err = ovl_indexdir_cleanup(ofs);
 -	}
 -	if (err || !ofs->indexdir)
 -		pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
 -
 -out:
 -	mnt_drop_write(mnt);
 -	return err;
 -}
 -
 -/* Get a unique fsid for the layer */
 -static int ovl_get_fsid(struct ovl_fs *ofs, struct super_block *sb)
 -{
 -	unsigned int i;
 -	dev_t dev;
 -	int err;
 -
 -	/* fsid 0 is reserved for upper fs even with non upper overlay */
 -	if (ofs->upper_mnt && ofs->upper_mnt->mnt_sb == sb)
 -		return 0;
 -
 -	for (i = 0; i < ofs->numlowerfs; i++) {
 -		if (ofs->lower_fs[i].sb == sb)
 -			return i + 1;
 -	}
  
 -	err = get_anon_bdev(&dev);
 -	if (err) {
 -		pr_err("overlayfs: failed to get anonymous bdev for lowerpath\n");
 -		return err;
 -	}
 -
 -	ofs->lower_fs[ofs->numlowerfs].sb = sb;
 -	ofs->lower_fs[ofs->numlowerfs].pseudo_dev = dev;
 -	ofs->numlowerfs++;
 -
 -	return ofs->numlowerfs;
 -}
 -
 -static int ovl_get_lower_layers(struct ovl_fs *ofs, struct path *stack,
 -				unsigned int numlower)
 -{
 -	int err;
 -	unsigned int i;
 -
 -	err = -ENOMEM;
 -	ofs->lower_layers = kcalloc(numlower, sizeof(struct ovl_layer),
 -				    GFP_KERNEL);
 -	if (ofs->lower_layers == NULL)
 -		goto out;
 +		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 +		if (err)
 +			goto out_free_config;
  
 -	ofs->lower_fs = kcalloc(numlower, sizeof(struct ovl_sb),
 -				GFP_KERNEL);
 -	if (ofs->lower_fs == NULL)
 -		goto out;
 +		/* Upper fs should not be r/o */
 +		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
 +			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 +			err = -EINVAL;
 +			goto out_put_upperpath;
 +		}
  
 -	for (i = 0; i < numlower; i++) {
 -		struct vfsmount *mnt;
 -		int fsid;
 +		err = ovl_check_namelen(&upperpath, ufs, ufs->config.upperdir);
 +		if (err)
 +			goto out_put_upperpath;
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(upperpath.dentry)) {
 +			ufs->upperdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 +			goto out_put_upperpath;
 +		} else {
 +			pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
  
 -		err = fsid = ovl_get_fsid(ofs, stack[i].mnt->mnt_sb);
 -		if (err < 0)
 -			goto out;
 +		err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +		if (err)
 +			goto out_unlock_upperdentry;
  
 -		mnt = clone_private_mount(&stack[i]);
 -		err = PTR_ERR(mnt);
 -		if (IS_ERR(mnt)) {
 -			pr_err("overlayfs: failed to clone lowerpath\n");
 -			goto out;
 +		err = -EINVAL;
 +		if (upperpath.mnt != workpath.mnt) {
 +			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +			goto out_put_workpath;
 +		}
 +		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +			goto out_put_workpath;
  		}
  
 -		/*
 -		 * Make lower layers R/O.  That way fchmod/fchown on lower file
 -		 * will fail instead of modifying lower fs.
 -		 */
 -		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
 -
 -		ofs->lower_layers[ofs->numlower].mnt = mnt;
 -		ofs->lower_layers[ofs->numlower].idx = i + 1;
 -		ofs->lower_layers[ofs->numlower].fsid = fsid;
 -		if (fsid) {
 -			ofs->lower_layers[ofs->numlower].fs =
 -				&ofs->lower_fs[fsid - 1];
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(workpath.dentry)) {
 +			ufs->workdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 +			goto out_put_workpath;
 +		} else {
 +			pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
  		}
 -		ofs->numlower++;
 -	}
  
 -	/*
 -	 * When all layers on same fs, overlay can use real inode numbers.
 -	 * With mount option "xino=on", mounter declares that there are enough
 -	 * free high bits in underlying fs to hold the unique fsid.
 -	 * If overlayfs does encounter underlying inodes using the high xino
 -	 * bits reserved for fsid, it emits a warning and uses the original
 -	 * inode number.
 -	 */
 -	if (!ofs->numlowerfs || (ofs->numlowerfs == 1 && !ofs->upper_mnt)) {
 -		ofs->xino_bits = 0;
 -		ofs->config.xino = OVL_XINO_OFF;
 -	} else if (ofs->config.xino == OVL_XINO_ON && !ofs->xino_bits) {
 -		/*
 -		 * This is a roundup of number of bits needed for numlowerfs+1
 -		 * (i.e. ilog2(numlowerfs+1 - 1) + 1). fsid 0 is reserved for
 -		 * upper fs even with non upper overlay.
 -		 */
 -		BUILD_BUG_ON(ilog2(OVL_MAX_STACK) > 31);
 -		ofs->xino_bits = ilog2(ofs->numlowerfs) + 1;
 -	}
 +		ufs->workbasedir = workpath.dentry;
 +		upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +		err = -EOPNOTSUPP;
 +		if (!upper_stack_depth) {
 +			pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +			goto out_put_workpath;
 +		}
  
 -	if (ofs->xino_bits) {
 -		pr_info("overlayfs: \"xino\" feature enabled using %d upper inode bits.\n",
 -			ofs->xino_bits);
 +		*overlay_stack_depth = *upper_stack_depth;
  	}
  
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static struct ovl_entry *ovl_get_lowerstack(struct super_block *sb,
 -					    struct ovl_fs *ofs)
 -{
 -	int err;
 -	char *lowertmp, *lower;
 -	struct path *stack = NULL;
 -	unsigned int stacklen, numlower = 0, i;
 -	bool remote = false;
 -	struct ovl_entry *oe;
 -
  	err = -ENOMEM;
 -	lowertmp = kstrdup(ofs->config.lowerdir, GFP_KERNEL);
 +	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
  	if (!lowertmp)
 -		goto out_err;
 +		goto out_unlock_workdentry;
  
  	err = -EINVAL;
  	stacklen = ovl_split_lowerdirs(lowertmp);
* Unmerged path fs/overlayfs/super.c
