sunrpc: remove svc_tcp_bc_class

jira LE-1907
cve CVE-2018-16884
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Vasily Averin <vvs@virtuozzo.com>
commit 7f391546098702bf8160038d8512a2502a0343ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7f391546.failed

Remove svc_xprt_class svc_tcp_bc_class and related functions

	Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 7f391546098702bf8160038d8512a2502a0343ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/svcsock.c
diff --cc net/sunrpc/svcsock.c
index b442f943933f,19acf10dfca1..000000000000
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@@ -1227,59 -1182,7 +1220,63 @@@ static struct svc_xprt *svc_tcp_create(
  	return svc_create_socket(serv, IPPROTO_TCP, net, sa, salen, flags);
  }
  
++<<<<<<< HEAD
 +#if defined(CONFIG_SUNRPC_BACKCHANNEL)
 +static struct svc_xprt *svc_bc_create_socket(struct svc_serv *, int,
 +					     struct net *, struct sockaddr *,
 +					     int, int);
 +static void svc_bc_sock_free(struct svc_xprt *xprt);
 +
 +static struct svc_xprt *svc_bc_tcp_create(struct svc_serv *serv,
 +				       struct net *net,
 +				       struct sockaddr *sa, int salen,
 +				       int flags)
 +{
 +	return svc_bc_create_socket(serv, IPPROTO_TCP, net, sa, salen, flags);
 +}
 +
 +static void svc_bc_tcp_sock_detach(struct svc_xprt *xprt)
 +{
 +}
 +
 +static struct svc_xprt_ops svc_tcp_bc_ops = {
 +	.xpo_create = svc_bc_tcp_create,
 +	.xpo_detach = svc_bc_tcp_sock_detach,
 +	.xpo_free = svc_bc_sock_free,
 +	.xpo_prep_reply_hdr = svc_tcp_prep_reply_hdr,
 +	.xpo_secure_port = svc_sock_secure_port,
 +};
 +
 +static struct svc_xprt_class svc_tcp_bc_class = {
 +	.xcl_name = "tcp-bc",
 +	.xcl_owner = THIS_MODULE,
 +	.xcl_ops = &svc_tcp_bc_ops,
 +	.xcl_max_payload = RPCSVC_MAXPAYLOAD_TCP,
 +};
 +
 +static void svc_init_bc_xprt_sock(void)
 +{
 +	svc_reg_xprt_class(&svc_tcp_bc_class);
 +}
 +
 +static void svc_cleanup_bc_xprt_sock(void)
 +{
 +	svc_unreg_xprt_class(&svc_tcp_bc_class);
 +}
 +#else /* CONFIG_SUNRPC_BACKCHANNEL */
 +static void svc_init_bc_xprt_sock(void)
 +{
 +}
 +
 +static void svc_cleanup_bc_xprt_sock(void)
 +{
 +}
 +#endif /* CONFIG_SUNRPC_BACKCHANNEL */
 +
 +static struct svc_xprt_ops svc_tcp_ops = {
++=======
+ static const struct svc_xprt_ops svc_tcp_ops = {
++>>>>>>> 7f3915460987 (sunrpc: remove svc_tcp_bc_class)
  	.xpo_create = svc_tcp_create,
  	.xpo_recvfrom = svc_tcp_recvfrom,
  	.xpo_sendto = svc_tcp_sendto,
@@@ -1631,42 -1534,3 +1626,45 @@@ static void svc_sock_free(struct svc_xp
  		sock_release(svsk->sk_sock);
  	kfree(svsk);
  }
++<<<<<<< HEAD
 +
 +#if defined(CONFIG_SUNRPC_BACKCHANNEL)
 +/*
 + * Create a back channel svc_xprt which shares the fore channel socket.
 + */
 +static struct svc_xprt *svc_bc_create_socket(struct svc_serv *serv,
 +					     int protocol,
 +					     struct net *net,
 +					     struct sockaddr *sin, int len,
 +					     int flags)
 +{
 +	struct svc_sock *svsk;
 +	struct svc_xprt *xprt;
 +
 +	if (protocol != IPPROTO_TCP) {
 +		printk(KERN_WARNING "svc: only TCP sockets"
 +			" supported on shared back channel\n");
 +		return ERR_PTR(-EINVAL);
 +	}
 +
 +	svsk = kzalloc(sizeof(*svsk), GFP_KERNEL);
 +	if (!svsk)
 +		return ERR_PTR(-ENOMEM);
 +
 +	xprt = &svsk->sk_xprt;
 +	svc_xprt_init(net, &svc_tcp_bc_class, xprt, serv);
 +
 +	return xprt;
 +}
 +
 +/*
 + * Free a back channel svc_sock.
 + */
 +static void svc_bc_sock_free(struct svc_xprt *xprt)
 +{
 +	if (xprt)
 +		kfree(container_of(xprt, struct svc_sock, sk_xprt));
 +}
 +#endif /* CONFIG_SUNRPC_BACKCHANNEL */
++=======
++>>>>>>> 7f3915460987 (sunrpc: remove svc_tcp_bc_class)
* Unmerged path net/sunrpc/svcsock.c
