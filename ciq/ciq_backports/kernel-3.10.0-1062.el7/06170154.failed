ovl: lookup indexed ancestor of lower dir

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 061701540349c30d72e48a201449a840c77ad509
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/06170154.failed

ovl_lookup_real() in lower layer walks back lower parents to find the
topmost indexed parent. If an indexed ancestor is found before reaching
lower layer root, ovl_lookup_real() is called recursively with upper
layer to walk back from indexed upper to the topmost connected/hashed
upper parent (or up to root).

ovl_lookup_real() in upper layer then walks forward to connect the topmost
upper overlay dir dentry and ovl_lookup_real() in lower layer continues to
walk forward to connect the decoded lower overlay dir dentry.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 061701540349c30d72e48a201449a840c77ad509)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/export.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
diff --cc fs/overlayfs/namei.c
index 5e444838b3c6,c5449efd96d5..000000000000
--- a/fs/overlayfs/namei.c
+++ b/fs/overlayfs/namei.c
@@@ -475,24 -623,47 +475,22 @@@ int ovl_get_index_name(struct dentry *o
  	if (IS_ERR(fh))
  		return PTR_ERR(fh);
  
 -	err = ovl_get_index_name_fh(fh, name);
 -
 -	kfree(fh);
 -	return err;
 -}
 -
 -/* Lookup index by file handle for NFS export */
 -struct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh)
 -{
 -	struct dentry *index;
 -	struct qstr name;
 -	int err;
 -
 -	err = ovl_get_index_name_fh(fh, &name);
 -	if (err)
 -		return ERR_PTR(err);
 -
 -	index = lookup_one_len_unlocked(name.name, ofs->indexdir, name.len);
 -	kfree(name.name);
 -	if (IS_ERR(index)) {
 -		if (PTR_ERR(index) == -ENOENT)
 -			index = NULL;
 -		return index;
 +	err = -ENOMEM;
 +	n = kzalloc(fh->len * 2, GFP_TEMPORARY);
 +	if (n) {
 +		s  = bin2hex(n, fh, fh->len);
 +		*name = (struct qstr) QSTR_INIT(n, s - n);
 +		err = 0;
  	}
 +	kfree(fh);
  
 -	if (d_is_negative(index))
 -		err = 0;
 -	else if (ovl_is_whiteout(index))
 -		err = -ESTALE;
 -	else if (ovl_dentry_weird(index))
 -		err = -EIO;
 -	else
 -		return index;
 +	return err;
  
 -	dput(index);
 -	return ERR_PTR(err);
  }
  
- static struct dentry *ovl_lookup_index(struct dentry *dentry,
- 				       struct dentry *upper,
- 				       struct dentry *origin)
+ struct dentry *ovl_lookup_index(struct ovl_fs *ofs, struct dentry *upper,
+ 				struct dentry *origin, bool verify)
  {
- 	struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
  	struct dentry *index;
  	struct inode *inode;
  	struct qstr name;
@@@ -519,8 -691,16 +517,21 @@@
  	inode = d_inode(index);
  	if (d_is_negative(index)) {
  		goto out_dput;
++<<<<<<< HEAD
 +	} else if (upper && d_inode(upper) != inode) {
 +		goto out_dput;
++=======
+ 	} else if (ovl_is_whiteout(index) && !verify) {
+ 		/*
+ 		 * When index lookup is called with !verify for decoding an
+ 		 * overlay file handle, a whiteout index implies that decode
+ 		 * should treat file handle as stale and no need to print a
+ 		 * warning about it.
+ 		 */
+ 		dput(index);
+ 		index = ERR_PTR(-ESTALE);
+ 		goto out;
++>>>>>>> 061701540349 (ovl: lookup indexed ancestor of lower dir)
  	} else if (ovl_dentry_weird(index) || ovl_is_whiteout(index) ||
  		   ((inode->i_mode ^ d_inode(origin)->i_mode) & S_IFMT)) {
  		/*
@@@ -534,8 -714,25 +545,29 @@@
  				    index, d_inode(index)->i_mode & S_IFMT,
  				    d_inode(origin)->i_mode & S_IFMT);
  		goto fail;
++<<<<<<< HEAD
++=======
+ 	} else if (is_dir && verify) {
+ 		if (!upper) {
+ 			pr_warn_ratelimited("overlayfs: suspected uncovered redirected dir found (origin=%pd2, index=%pd2).\n",
+ 					    origin, index);
+ 			goto fail;
+ 		}
+ 
+ 		/* Verify that dir index 'upper' xattr points to upper dir */
+ 		err = ovl_verify_upper(index, upper, false);
+ 		if (err) {
+ 			if (err == -ESTALE) {
+ 				pr_warn_ratelimited("overlayfs: suspected multiply redirected dir found (upper=%pd2, origin=%pd2, index=%pd2).\n",
+ 						    upper, origin, index);
+ 			}
+ 			goto fail;
+ 		}
+ 	} else if (upper && d_inode(upper) != inode) {
+ 		goto out_dput;
++>>>>>>> 061701540349 (ovl: lookup indexed ancestor of lower dir)
  	}
 +
  out:
  	kfree(name.name);
  	return index;
@@@ -698,11 -940,18 +730,17 @@@ struct dentry *ovl_lookup(struct inode 
  		}
  	}
  
 -	/*
 -	 * Lookup index by lower inode and verify it matches upper inode.
 -	 * We only trust dir index if we verified that lower dir matches
 -	 * origin, otherwise dir index entries may be inconsistent and we
 -	 * ignore them. Always lookup index of non-dir and non-upper.
 -	 */
 -	if (ctr && (!upperdentry || !d.is_dir))
 -		origin = stack[0].dentry;
 +	/* Lookup index by lower inode and verify it matches upper inode */
 +	if (ctr && !d.is_dir && ovl_indexdir(dentry->d_sb)) {
 +		struct dentry *origin = stack[0].dentry;
  
++<<<<<<< HEAD
 +		index = ovl_lookup_index(dentry, upperdentry, origin);
++=======
+ 	if (origin && ovl_indexdir(dentry->d_sb) &&
+ 	    (!d.is_dir || ovl_index_all(dentry->d_sb))) {
+ 		index = ovl_lookup_index(ofs, upperdentry, origin, true);
++>>>>>>> 061701540349 (ovl: lookup indexed ancestor of lower dir)
  		if (IS_ERR(index)) {
  			err = PTR_ERR(index);
  			index = NULL;
diff --cc fs/overlayfs/overlayfs.h
index 403c48960f89,0df25a9c94bd..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -247,15 -264,35 +247,21 @@@ static inline bool ovl_is_impuredir(str
  
  
  /* namei.c */
 -int ovl_check_fh_len(struct ovl_fh *fh, int fh_len);
 -struct dentry *ovl_decode_fh(struct ovl_fh *fh, struct vfsmount *mnt);
 -int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh,
 -			struct dentry *upperdentry, struct ovl_path **stackp);
 -int ovl_verify_set_fh(struct dentry *dentry, const char *name,
 -		      struct dentry *real, bool is_upper, bool set);
 -struct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index);
 -int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
 +int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 +		      struct dentry *origin, bool is_upper, bool set);
 +int ovl_verify_index(struct dentry *index, struct path *lowerstack,
 +		     unsigned int numlower);
  int ovl_get_index_name(struct dentry *origin, struct qstr *name);
++<<<<<<< HEAD
++=======
+ struct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh);
+ struct dentry *ovl_lookup_index(struct ovl_fs *ofs, struct dentry *upper,
+ 				struct dentry *origin, bool verify);
++>>>>>>> 061701540349 (ovl: lookup indexed ancestor of lower dir)
  int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 -struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 -			  unsigned int flags);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
  bool ovl_lower_positive(struct dentry *dentry);
  
 -static inline int ovl_verify_origin(struct dentry *upper,
 -				    struct dentry *origin, bool set)
 -{
 -	return ovl_verify_set_fh(upper, OVL_XATTR_ORIGIN, origin, false, set);
 -}
 -
 -static inline int ovl_verify_upper(struct dentry *index,
 -				    struct dentry *upper, bool set)
 -{
 -	return ovl_verify_set_fh(index, OVL_XATTR_UPPER, upper, true, set);
 -}
 -
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
  int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
