nfp: flower: remove TC egdev offloads

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author John Hurley <john.hurley@netronome.com>
commit 4f63fde3fc08045a232923cc83fb08defbd7ca4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4f63fde3.failed

Previously, only tunnel decap rules required egdev registration for
offload in NFP. These are now supported via indirect TC block callbacks.

Remove the egdev code from NFP.

	Signed-off-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4f63fde3fc08045a232923cc83fb08defbd7ca4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/offload.c
diff --cc drivers/net/ethernet/netronome/nfp/flower/offload.c
index 970ddbd64602,0e2dfbb3ef86..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/offload.c
@@@ -159,9 -128,9 +159,8 @@@ nfp_flower_calc_opt_layer(struct flow_d
  
  static int
  nfp_flower_calculate_key_layers(struct nfp_app *app,
 -				struct net_device *netdev,
  				struct nfp_fl_key_ls *ret_key_ls,
  				struct tc_cls_flower_offload *flow,
- 				bool egress,
  				enum nfp_flower_tun_type *tun_type)
  {
  	struct flow_dissector_key_basic *mask_basic = NULL;
@@@ -281,9 -248,10 +280,16 @@@
  		default:
  			return -EOPNOTSUPP;
  		}
++<<<<<<< HEAD
 +	} else if (egress) {
 +		/* Reject non tunnel matches offloaded to egress repr. */
 +		return -EOPNOTSUPP;
++=======
+ 
+ 		/* Ensure the ingress netdev matches the expected tun type. */
+ 		if (!nfp_fl_netdev_is_tunnel_type(netdev, *tun_type))
+ 			return -EOPNOTSUPP;
++>>>>>>> 4f63fde3fc08 (nfp: flower: remove TC egdev offloads)
  	}
  
  	if (dissector_uses_key(flow->dissector, FLOW_DISSECTOR_KEY_BASIC)) {
@@@ -428,7 -396,6 +434,10 @@@ nfp_flower_allocate_new(struct nfp_fl_k
  
  	flow_pay->nfp_tun_ipv4_addr = 0;
  	flow_pay->meta.flags = 0;
++<<<<<<< HEAD
 +	spin_lock_init(&flow_pay->lock);
++=======
++>>>>>>> 4f63fde3fc08 (nfp: flower: remove TC egdev offloads)
  
  	return flow_pay;
  
@@@ -454,21 -420,23 +462,34 @@@ err_free_flow
   */
  static int
  nfp_flower_add_offload(struct nfp_app *app, struct net_device *netdev,
- 		       struct tc_cls_flower_offload *flow, bool egress)
+ 		       struct tc_cls_flower_offload *flow)
  {
  	enum nfp_flower_tun_type tun_type = NFP_FL_TUNNEL_NONE;
 +	struct nfp_port *port = nfp_port_from_netdev(netdev);
  	struct nfp_flower_priv *priv = app->priv;
  	struct nfp_fl_payload *flow_pay;
  	struct nfp_fl_key_ls *key_layer;
++<<<<<<< HEAD
 +	unsigned long fl_key;
 +	int err;
 +
++=======
+ 	struct nfp_port *port = NULL;
+ 	int err;
+ 
+ 	if (nfp_netdev_is_nfp_repr(netdev))
+ 		port = nfp_port_from_netdev(netdev);
+ 
++>>>>>>> 4f63fde3fc08 (nfp: flower: remove TC egdev offloads)
  	key_layer = kmalloc(sizeof(*key_layer), GFP_KERNEL);
  	if (!key_layer)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	err = nfp_flower_calculate_key_layers(app, key_layer, flow, egress,
++=======
+ 	err = nfp_flower_calculate_key_layers(app, netdev, key_layer, flow,
++>>>>>>> 4f63fde3fc08 (nfp: flower: remove TC egdev offloads)
  					      &tun_type);
  	if (err)
  		goto err_free_key_ls;
@@@ -479,8 -447,8 +500,13 @@@
  		goto err_free_key_ls;
  	}
  
++<<<<<<< HEAD
 +	err = nfp_flower_compile_flow_match(flow, key_layer, netdev, flow_pay,
 +					    tun_type);
++=======
+ 	err = nfp_flower_compile_flow_match(app, flow, key_layer, netdev,
+ 					    flow_pay, tun_type);
++>>>>>>> 4f63fde3fc08 (nfp: flower: remove TC egdev offloads)
  	if (err)
  		goto err_destroy_flow;
  
@@@ -488,7 -456,7 +514,11 @@@
  	if (err)
  		goto err_destroy_flow;
  
++<<<<<<< HEAD
 +	err = nfp_compile_flow_metadata(app, flow, flow_pay);
++=======
+ 	err = nfp_compile_flow_metadata(app, flow, flow_pay, netdev);
++>>>>>>> 4f63fde3fc08 (nfp: flower: remove TC egdev offloads)
  	if (err)
  		goto err_destroy_flow;
  
@@@ -533,11 -504,16 +563,22 @@@ static in
  nfp_flower_del_offload(struct nfp_app *app, struct net_device *netdev,
  		       struct tc_cls_flower_offload *flow)
  {
 -	struct nfp_flower_priv *priv = app->priv;
 +	struct nfp_port *port = nfp_port_from_netdev(netdev);
  	struct nfp_fl_payload *nfp_flow;
++<<<<<<< HEAD
 +	int err;
 +
 +	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie);
++=======
+ 	struct nfp_port *port = NULL;
+ 	int err;
+ 
+ 	if (nfp_netdev_is_nfp_repr(netdev))
+ 		port = nfp_port_from_netdev(netdev);
+ 
+ 	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie, netdev,
+ 					      NFP_FL_STATS_CTX_DONT_CARE);
++>>>>>>> 4f63fde3fc08 (nfp: flower: remove TC egdev offloads)
  	if (!nfp_flow)
  		return -ENOENT;
  
@@@ -574,21 -554,28 +615,46 @@@ err_free_flow
   * Return: negative value on error, 0 if stats populated successfully.
   */
  static int
++<<<<<<< HEAD
 +nfp_flower_get_stats(struct nfp_app *app, struct tc_cls_flower_offload *flow)
++=======
+ nfp_flower_get_stats(struct nfp_app *app, struct net_device *netdev,
+ 		     struct tc_cls_flower_offload *flow)
++>>>>>>> 4f63fde3fc08 (nfp: flower: remove TC egdev offloads)
  {
 -	struct nfp_flower_priv *priv = app->priv;
  	struct nfp_fl_payload *nfp_flow;
++<<<<<<< HEAD
 +
 +	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie);
 +	if (!nfp_flow)
 +		return -EINVAL;
 +
 +	spin_lock_bh(&nfp_flow->lock);
 +	tcf_exts_stats_update(flow->exts, nfp_flow->stats.bytes,
 +			      nfp_flow->stats.pkts, nfp_flow->stats.used);
 +
 +	nfp_flow->stats.pkts = 0;
 +	nfp_flow->stats.bytes = 0;
 +	spin_unlock_bh(&nfp_flow->lock);
++=======
+ 	u32 ctx_id;
+ 
+ 	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie, netdev,
+ 					      NFP_FL_STATS_CTX_DONT_CARE);
+ 	if (!nfp_flow)
+ 		return -EINVAL;
+ 
+ 	ctx_id = be32_to_cpu(nfp_flow->meta.host_ctx_id);
+ 
+ 	spin_lock_bh(&priv->stats_lock);
+ 	tcf_exts_stats_update(flow->exts, priv->stats[ctx_id].bytes,
+ 			      priv->stats[ctx_id].pkts,
+ 			      priv->stats[ctx_id].used);
+ 
+ 	priv->stats[ctx_id].pkts = 0;
+ 	priv->stats[ctx_id].bytes = 0;
+ 	spin_unlock_bh(&priv->stats_lock);
++>>>>>>> 4f63fde3fc08 (nfp: flower: remove TC egdev offloads)
  
  	return 0;
  }
@@@ -606,24 -593,7 +672,28 @@@ nfp_flower_repr_offload(struct nfp_app 
  	case TC_CLSFLOWER_DESTROY:
  		return nfp_flower_del_offload(app, netdev, flower);
  	case TC_CLSFLOWER_STATS:
++<<<<<<< HEAD
 +		return nfp_flower_get_stats(app, flower);
 +	}
 +
 +	return -EOPNOTSUPP;
 +}
 +
 +int nfp_flower_setup_tc_egress_cb(enum tc_setup_type type, void *type_data,
 +				  void *cb_priv)
 +{
 +	struct nfp_repr *repr = cb_priv;
 +
 +	if (!tc_cls_can_offload_and_chain0(repr->netdev, type_data))
 +		return -EOPNOTSUPP;
 +
 +	switch (type) {
 +	case TC_SETUP_CLSFLOWER:
 +		return nfp_flower_repr_offload(repr->app, repr->netdev,
 +					       type_data, true);
++=======
+ 		return nfp_flower_get_stats(app, netdev, flower);
++>>>>>>> 4f63fde3fc08 (nfp: flower: remove TC egdev offloads)
  	default:
  		return -EOPNOTSUPP;
  	}
@@@ -679,3 -649,129 +749,132 @@@ int nfp_flower_setup_tc(struct nfp_app 
  		return -EOPNOTSUPP;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ struct nfp_flower_indr_block_cb_priv {
+ 	struct net_device *netdev;
+ 	struct nfp_app *app;
+ 	struct list_head list;
+ };
+ 
+ static struct nfp_flower_indr_block_cb_priv *
+ nfp_flower_indr_block_cb_priv_lookup(struct nfp_app *app,
+ 				     struct net_device *netdev)
+ {
+ 	struct nfp_flower_indr_block_cb_priv *cb_priv;
+ 	struct nfp_flower_priv *priv = app->priv;
+ 
+ 	/* All callback list access should be protected by RTNL. */
+ 	ASSERT_RTNL();
+ 
+ 	list_for_each_entry(cb_priv, &priv->indr_block_cb_priv, list)
+ 		if (cb_priv->netdev == netdev)
+ 			return cb_priv;
+ 
+ 	return NULL;
+ }
+ 
+ static int nfp_flower_setup_indr_block_cb(enum tc_setup_type type,
+ 					  void *type_data, void *cb_priv)
+ {
+ 	struct nfp_flower_indr_block_cb_priv *priv = cb_priv;
+ 	struct tc_cls_flower_offload *flower = type_data;
+ 
+ 	if (flower->common.chain_index)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (type) {
+ 	case TC_SETUP_CLSFLOWER:
+ 		return nfp_flower_repr_offload(priv->app, priv->netdev,
+ 					       type_data);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int
+ nfp_flower_setup_indr_tc_block(struct net_device *netdev, struct nfp_app *app,
+ 			       struct tc_block_offload *f)
+ {
+ 	struct nfp_flower_indr_block_cb_priv *cb_priv;
+ 	struct nfp_flower_priv *priv = app->priv;
+ 	int err;
+ 
+ 	if (f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (f->command) {
+ 	case TC_BLOCK_BIND:
+ 		cb_priv = kmalloc(sizeof(*cb_priv), GFP_KERNEL);
+ 		if (!cb_priv)
+ 			return -ENOMEM;
+ 
+ 		cb_priv->netdev = netdev;
+ 		cb_priv->app = app;
+ 		list_add(&cb_priv->list, &priv->indr_block_cb_priv);
+ 
+ 		err = tcf_block_cb_register(f->block,
+ 					    nfp_flower_setup_indr_block_cb,
+ 					    netdev, cb_priv, f->extack);
+ 		if (err) {
+ 			list_del(&cb_priv->list);
+ 			kfree(cb_priv);
+ 		}
+ 
+ 		return err;
+ 	case TC_BLOCK_UNBIND:
+ 		tcf_block_cb_unregister(f->block,
+ 					nfp_flower_setup_indr_block_cb, netdev);
+ 		cb_priv = nfp_flower_indr_block_cb_priv_lookup(app, netdev);
+ 		if (cb_priv) {
+ 			list_del(&cb_priv->list);
+ 			kfree(cb_priv);
+ 		}
+ 
+ 		return 0;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 	return 0;
+ }
+ 
+ static int
+ nfp_flower_indr_setup_tc_cb(struct net_device *netdev, void *cb_priv,
+ 			    enum tc_setup_type type, void *type_data)
+ {
+ 	switch (type) {
+ 	case TC_SETUP_BLOCK:
+ 		return nfp_flower_setup_indr_tc_block(netdev, cb_priv,
+ 						      type_data);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ int nfp_flower_reg_indir_block_handler(struct nfp_app *app,
+ 				       struct net_device *netdev,
+ 				       unsigned long event)
+ {
+ 	int err;
+ 
+ 	if (!nfp_fl_is_netdev_to_offload(netdev))
+ 		return NOTIFY_OK;
+ 
+ 	if (event == NETDEV_REGISTER) {
+ 		err = __tc_indr_block_cb_register(netdev, app,
+ 						  nfp_flower_indr_setup_tc_cb,
+ 						  netdev);
+ 		if (err)
+ 			nfp_flower_cmsg_warn(app,
+ 					     "Indirect block reg failed - %s\n",
+ 					     netdev->name);
+ 	} else if (event == NETDEV_UNREGISTER) {
+ 		__tc_indr_block_cb_unregister(netdev,
+ 					      nfp_flower_indr_setup_tc_cb,
+ 					      netdev);
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
++>>>>>>> 4f63fde3fc08 (nfp: flower: remove TC egdev offloads)
diff --git a/drivers/net/ethernet/netronome/nfp/flower/main.c b/drivers/net/ethernet/netronome/nfp/flower/main.c
index 171014032993..3cf8192f5c6c 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/main.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/main.c
@@ -176,23 +176,12 @@ nfp_flower_repr_netdev_stop(struct nfp_app *app, struct nfp_repr *repr)
 	return nfp_flower_cmsg_portmod(repr, false, repr->netdev->mtu, false);
 }
 
-static int
-nfp_flower_repr_netdev_init(struct nfp_app *app, struct net_device *netdev)
-{
-	return tc_setup_cb_egdev_register(netdev,
-					  nfp_flower_setup_tc_egress_cb,
-					  netdev_priv(netdev));
-}
-
 static void
 nfp_flower_repr_netdev_clean(struct nfp_app *app, struct net_device *netdev)
 {
 	struct nfp_repr *repr = netdev_priv(netdev);
 
 	kfree(repr->app_priv);
-
-	tc_setup_cb_egdev_unregister(netdev, nfp_flower_setup_tc_egress_cb,
-				     netdev_priv(netdev));
 }
 
 static void
@@ -716,7 +705,6 @@ const struct nfp_app_type app_flower = {
 	.vnic_init	= nfp_flower_vnic_init,
 	.vnic_clean	= nfp_flower_vnic_clean,
 
-	.repr_init	= nfp_flower_repr_netdev_init,
 	.repr_preclean	= nfp_flower_repr_netdev_preclean,
 	.repr_clean	= nfp_flower_repr_netdev_clean,
 
diff --git a/drivers/net/ethernet/netronome/nfp/flower/main.h b/drivers/net/ethernet/netronome/nfp/flower/main.h
index 90cc96d4eae4..90a413019400 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/main.h
+++ b/drivers/net/ethernet/netronome/nfp/flower/main.h
@@ -288,8 +288,6 @@ void nfp_tunnel_del_ipv4_off(struct nfp_app *app, __be32 ipv4);
 void nfp_tunnel_add_ipv4_off(struct nfp_app *app, __be32 ipv4);
 void nfp_tunnel_request_route(struct nfp_app *app, struct sk_buff *skb);
 void nfp_tunnel_keep_alive(struct nfp_app *app, struct sk_buff *skb);
-int nfp_flower_setup_tc_egress_cb(enum tc_setup_type type, void *type_data,
-				  void *cb_priv);
 void nfp_flower_lag_init(struct nfp_fl_lag *lag);
 void nfp_flower_lag_cleanup(struct nfp_fl_lag *lag);
 int nfp_flower_lag_reset(struct nfp_fl_lag *lag);
diff --git a/drivers/net/ethernet/netronome/nfp/flower/metadata.c b/drivers/net/ethernet/netronome/nfp/flower/metadata.c
index c748aceb17bb..ee2eaf9d17c6 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/metadata.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/metadata.c
@@ -328,6 +328,7 @@ int nfp_compile_flow_metadata(struct nfp_app *app,
 
 	nfp_flow->meta.host_ctx_id = cpu_to_be32(stats_cxt);
 	nfp_flow->meta.host_cookie = cpu_to_be64(flow->cookie);
+	nfp_flow->ingress_dev = netdev;
 
 	new_mask_id = 0;
 	if (!nfp_check_mask_add(app, nfp_flow->mask_data,
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/offload.c
