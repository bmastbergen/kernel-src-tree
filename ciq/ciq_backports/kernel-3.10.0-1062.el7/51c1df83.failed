nfp: assign vNIC id as phys_port_name of vNICs which are not ports

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 51c1df83e35ce0e24ca10037c73245cb4c8ac11a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/51c1df83.failed

When NFP is modelled as a switch we assign phys_port_name to respective
port(representor )s:

 vNIC0 - | - PF port (pf%d)     MAC/PHY (p%d[s%d]) - |E==

In most cases there is only one vNIC for communication with the switch.
If there is more than one we need to be able to identify them.  Use %d
as phys_port_name of the vNICs.

We don't have to pass ID to nfp_net_debugfs_vnic_add() separately any
more.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Dirk van der Merwe <dirk.vandermerwe@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 51c1df83e35ce0e24ca10037c73245cb4c8ac11a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 1b191a368eb3,eea11e881bf5..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -3490,10 -3493,10 +3508,17 @@@ const struct net_device_ops nfp_net_net
  	.ndo_set_mac_address	= nfp_net_set_mac_address,
  	.ndo_set_features	= nfp_net_set_features,
  	.ndo_features_check	= nfp_net_features_check,
++<<<<<<< HEAD
 +	.extended.ndo_get_phys_port_name	= nfp_port_get_phys_port_name,
 +	.extended.ndo_udp_tunnel_add	= nfp_net_add_vxlan_port,
 +	.extended.ndo_udp_tunnel_del	= nfp_net_del_vxlan_port,
 +	.extended.ndo_xdp		= nfp_net_xdp,
++=======
+ 	.ndo_get_phys_port_name	= nfp_net_get_phys_port_name,
+ 	.ndo_udp_tunnel_add	= nfp_net_add_vxlan_port,
+ 	.ndo_udp_tunnel_del	= nfp_net_del_vxlan_port,
+ 	.ndo_bpf		= nfp_net_xdp,
++>>>>>>> 51c1df83e35c (nfp: assign vNIC id as phys_port_name of vNICs which are not ports)
  };
  
  /**
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
index 683ea8796165,099b63d67451..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
@@@ -190,9 -193,17 +190,21 @@@ static int nfp_net_debugfs_tx_q_open(st
  	return single_open(f, nfp_net_debugfs_tx_q_read, inode->i_private);
  }
  
++<<<<<<< HEAD
 +void nfp_net_debugfs_vnic_add(struct nfp_net *nn, struct dentry *ddir, int id)
++=======
+ static const struct file_operations nfp_xdp_q_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = nfp_net_debugfs_tx_q_open,
+ 	.release = single_release,
+ 	.read = seq_read,
+ 	.llseek = seq_lseek
+ };
+ 
+ void nfp_net_debugfs_vnic_add(struct nfp_net *nn, struct dentry *ddir)
++>>>>>>> 51c1df83e35c (nfp: assign vNIC id as phys_port_name of vNICs which are not ports)
  {
 -	struct dentry *queues, *tx, *rx, *xdp;
 +	struct dentry *queues, *tx, *rx;
  	char name[20];
  	int i;
  
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net.h b/drivers/net/ethernet/netronome/nfp/nfp_net.h
index 401d705a5802..11944915a887 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@ -543,6 +543,7 @@ struct nfp_net_dp {
 /**
  * struct nfp_net - NFP network device structure
  * @dp:			Datapath structure
+ * @id:			vNIC id within the PF (0 for VFs)
  * @fw_ver:		Firmware version
  * @cap:                Capabilities advertised by the Firmware
  * @max_mtu:            Maximum support MTU advertised by the Firmware
@@ -595,6 +596,8 @@ struct nfp_net {
 
 	struct nfp_net_fw_version fw_ver;
 
+	u32 id;
+
 	u32 cap;
 	u32 max_mtu;
 
@@ -906,7 +909,7 @@ int nfp_net_ring_reconfig(struct nfp_net *nn, struct nfp_net_dp *new);
 void nfp_net_debugfs_create(void);
 void nfp_net_debugfs_destroy(void);
 struct dentry *nfp_net_debugfs_device_add(struct pci_dev *pdev);
-void nfp_net_debugfs_vnic_add(struct nfp_net *nn, struct dentry *ddir, int id);
+void nfp_net_debugfs_vnic_add(struct nfp_net *nn, struct dentry *ddir);
 void nfp_net_debugfs_dir_clean(struct dentry **dir);
 #else
 static inline void nfp_net_debugfs_create(void)
@@ -923,7 +926,7 @@ static inline struct dentry *nfp_net_debugfs_device_add(struct pci_dev *pdev)
 }
 
 static inline void
-nfp_net_debugfs_vnic_add(struct nfp_net *nn, struct dentry *ddir, int id)
+nfp_net_debugfs_vnic_add(struct nfp_net *nn, struct dentry *ddir)
 {
 }
 
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
index 65db3bc15a10..bea657ba75bb 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_main.c
@@ -175,11 +175,13 @@ nfp_net_pf_init_vnic(struct nfp_pf *pf, struct nfp_net *nn, unsigned int id)
 {
 	int err;
 
+	nn->id = id;
+
 	err = nfp_net_init(nn);
 	if (err)
 		return err;
 
-	nfp_net_debugfs_vnic_add(nn, pf->ddir, id);
+	nfp_net_debugfs_vnic_add(nn, pf->ddir);
 
 	if (nn->port) {
 		err = nfp_devlink_port_register(pf->app, nn->port);
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c b/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
index 4ecb0b72db87..08a8e842a8a9 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
@@ -282,7 +282,7 @@ static int nfp_netvf_pci_probe(struct pci_dev *pdev,
 
 	nfp_net_info(nn);
 	vf->ddir = nfp_net_debugfs_device_add(pdev);
-	nfp_net_debugfs_vnic_add(nn, vf->ddir, 0);
+	nfp_net_debugfs_vnic_add(nn, vf->ddir);
 
 	return 0;
 
