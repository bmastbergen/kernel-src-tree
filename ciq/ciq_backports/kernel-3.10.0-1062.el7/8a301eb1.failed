fuse: fix congested state leak on aborted connections

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Tejun Heo <tj@kernel.org>
commit 8a301eb16d99983a4961f884690ec97b92e7dcfe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/8a301eb1.failed

If a connection gets aborted while congested, FUSE can leave
nr_wb_congested[] stuck until reboot causing wait_iff_congested() to
wait spuriously which can lead to severe performance degradation.

The leak is caused by gating congestion state clearing with
fc->connected test in request_end().  This was added way back in 2009
by 26c3679101db ("fuse: destroy bdi on umount").  While the commit
description doesn't explain why the test was added, it most likely was
to avoid dereferencing bdi after it got destroyed.

Since then, bdi lifetime rules have changed many times and now we're
always guaranteed to have access to the bdi while the superblock is
alive (fc->sb).

Drop fc->connected conditional to avoid leaking congestion states.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Reported-by: Joshua Miller <joshmiller@fb.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: stable@vger.kernel.org # v2.6.29+
	Acked-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 8a301eb16d99983a4961f884690ec97b92e7dcfe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dev.c
diff --cc fs/fuse/dev.c
index d81feeed9393,e03ca14f40e9..000000000000
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@@ -384,10 -385,9 +384,16 @@@ __releases(fc->lock
  		if (!fc->blocked && waitqueue_active(&fc->blocked_waitq))
  			wake_up(&fc->blocked_waitq);
  
++<<<<<<< HEAD
 +		if (fc->num_background == fc->congestion_threshold &&
 +		    fc->connected && fc->bdi_initialized) {
 +			clear_bdi_congested(&fc->bdi, BLK_RW_SYNC);
 +			clear_bdi_congested(&fc->bdi, BLK_RW_ASYNC);
++=======
+ 		if (fc->num_background == fc->congestion_threshold && fc->sb) {
+ 			clear_bdi_congested(fc->sb->s_bdi, BLK_RW_SYNC);
+ 			clear_bdi_congested(fc->sb->s_bdi, BLK_RW_ASYNC);
++>>>>>>> 8a301eb16d99 (fuse: fix congested state leak on aborted connections)
  		}
  		fc->num_background--;
  		fc->active_background--;
* Unmerged path fs/fuse/dev.c
