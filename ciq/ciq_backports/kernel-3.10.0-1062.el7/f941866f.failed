ovl: decode lower non-dir file handles

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit f941866fc4a8ad0d0b861cc2dbffa06a9f5e8963
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f941866f.failed

Decoding a lower non-dir file handle is done by decoding the lower dentry
from underlying lower fs, finding or allocating an overlay inode that is
hashed by the real lower inode and instantiating an overlay dentry with
that inode.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit f941866fc4a8ad0d0b861cc2dbffa06a9f5e8963)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/export.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
diff --cc fs/overlayfs/namei.c
index 5e444838b3c6,741a42d974a3..000000000000
--- a/fs/overlayfs/namei.c
+++ b/fs/overlayfs/namei.c
@@@ -284,11 -310,9 +284,16 @@@ static int ovl_lookup_layer(struct dent
  }
  
  
++<<<<<<< HEAD
 +static int ovl_check_origin(struct dentry *upperdentry,
 +			    struct path *lowerstack, unsigned int numlower,
 +			    struct path **stackp, unsigned int *ctrp)
++=======
+ int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh,
+ 			struct dentry *upperdentry, struct ovl_path **stackp)
++>>>>>>> f941866fc4a8 (ovl: decode lower non-dir file handles)
  {
 +	struct vfsmount *mnt;
  	struct dentry *origin = NULL;
  	int i;
  
@@@ -304,11 -323,16 +309,21 @@@
  	}
  
  	if (!origin)
++<<<<<<< HEAD
 +		return 0;
++=======
+ 		return -ESTALE;
+ 	else if (IS_ERR(origin))
+ 		return PTR_ERR(origin);
+ 
+ 	if (upperdentry && !ovl_is_whiteout(upperdentry) &&
+ 	    ((d_inode(origin)->i_mode ^ d_inode(upperdentry)->i_mode) & S_IFMT))
+ 		goto invalid;
++>>>>>>> f941866fc4a8 (ovl: decode lower non-dir file handles)
  
 +	BUG_ON(*ctrp);
  	if (!*stackp)
 -		*stackp = kmalloc(sizeof(struct ovl_path), GFP_KERNEL);
 +		*stackp = kmalloc(sizeof(struct path), GFP_TEMPORARY);
  	if (!*stackp) {
  		dput(origin);
  		return -ENOMEM;
diff --cc fs/overlayfs/overlayfs.h
index 403c48960f89,40ba11e412b1..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -247,15 -264,32 +247,25 @@@ static inline bool ovl_is_impuredir(str
  
  
  /* namei.c */
++<<<<<<< HEAD
 +int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 +		      struct dentry *origin, bool is_upper, bool set);
 +int ovl_verify_index(struct dentry *index, struct path *lowerstack,
 +		     unsigned int numlower);
++=======
+ int ovl_check_fh_len(struct ovl_fh *fh, int fh_len);
+ struct dentry *ovl_decode_fh(struct ovl_fh *fh, struct vfsmount *mnt);
+ int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh,
+ 			struct dentry *upperdentry, struct ovl_path **stackp);
+ int ovl_verify_set_fh(struct dentry *dentry, const char *name,
+ 		      struct dentry *real, bool is_upper, bool set);
+ int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
++>>>>>>> f941866fc4a8 (ovl: decode lower non-dir file handles)
  int ovl_get_index_name(struct dentry *origin, struct qstr *name);
 -struct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh);
  int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 -struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 -			  unsigned int flags);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
  bool ovl_lower_positive(struct dentry *dentry);
  
 -static inline int ovl_verify_origin(struct dentry *upper,
 -				    struct dentry *origin, bool set)
 -{
 -	return ovl_verify_set_fh(upper, OVL_XATTR_ORIGIN, origin, false, set);
 -}
 -
 -static inline int ovl_verify_upper(struct dentry *index,
 -				    struct dentry *upper, bool set)
 -{
 -	return ovl_verify_set_fh(index, OVL_XATTR_UPPER, upper, true, set);
 -}
 -
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
  int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
