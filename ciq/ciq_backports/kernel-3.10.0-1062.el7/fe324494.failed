efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ard Biesheuvel <ard.biesheuvel@linaro.org>
commit fe3244945c47161e2486412d6412c87ba279305d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fe324494.failed

The UEFI spec allows Runtime Services to be invoked with interrupts
enabled. The only reason we were disabling interrupts was to prevent
recursive calls into the services on the same CPU, which will lead to
deadlock. However, the only context where such invocations may occur
legally is from efi-pstore via efivars, and that code has been updated
to call a non-blocking alternative when invoked from a non-interruptible
context.

So instead, update the ordinary, blocking UEFI Runtime Services wrappers
to execute with interrupts enabled. This aims to prevent excessive interrupt
latencies on uniprocessor platforms with slow variable stores.

Note that other OSes such as Windows call UEFI Runtime Services with
interrupts enabled as well.

	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Sai Praneeth Prakhya <sai.praneeth.prakhya@intel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
Link: http://lkml.kernel.org/r/1455712566-16727-3-git-send-email-matt@codeblueprint.co.uk
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit fe3244945c47161e2486412d6412c87ba279305d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/runtime-wrappers.c
diff --cc drivers/firmware/efi/runtime-wrappers.c
index dcc976822484,de6953039af6..000000000000
--- a/drivers/firmware/efi/runtime-wrappers.c
+++ b/drivers/firmware/efi/runtime-wrappers.c
@@@ -52,23 -63,21 +52,33 @@@ __weak DEFINE_SPINLOCK(rtc_lock)
  
  static efi_status_t virt_efi_get_time(efi_time_t *tm, efi_time_cap_t *tc)
  {
- 	unsigned long flags;
  	efi_status_t status;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	status = efi_call_virt(get_time, tm, tc);
 +	spin_unlock_irqrestore(&rtc_lock, flags);
++=======
+ 	spin_lock(&efi_runtime_lock);
+ 	status = efi_call_virt(get_time, tm, tc);
+ 	spin_unlock(&efi_runtime_lock);
++>>>>>>> fe3244945c47 (efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled)
  	return status;
  }
  
  static efi_status_t virt_efi_set_time(efi_time_t *tm)
  {
- 	unsigned long flags;
  	efi_status_t status;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	status = efi_call_virt(set_time, tm);
 +	spin_unlock_irqrestore(&rtc_lock, flags);
++=======
+ 	spin_lock(&efi_runtime_lock);
+ 	status = efi_call_virt(set_time, tm);
+ 	spin_unlock(&efi_runtime_lock);
++>>>>>>> fe3244945c47 (efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled)
  	return status;
  }
  
@@@ -76,23 -85,21 +86,33 @@@ static efi_status_t virt_efi_get_wakeup
  					     efi_bool_t *pending,
  					     efi_time_t *tm)
  {
- 	unsigned long flags;
  	efi_status_t status;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	status = efi_call_virt(get_wakeup_time, enabled, pending, tm);
 +	spin_unlock_irqrestore(&rtc_lock, flags);
++=======
+ 	spin_lock(&efi_runtime_lock);
+ 	status = efi_call_virt(get_wakeup_time, enabled, pending, tm);
+ 	spin_unlock(&efi_runtime_lock);
++>>>>>>> fe3244945c47 (efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled)
  	return status;
  }
  
  static efi_status_t virt_efi_set_wakeup_time(efi_bool_t enabled, efi_time_t *tm)
  {
- 	unsigned long flags;
  	efi_status_t status;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	status = efi_call_virt(set_wakeup_time, enabled, tm);
 +	spin_unlock_irqrestore(&rtc_lock, flags);
++=======
+ 	spin_lock(&efi_runtime_lock);
+ 	status = efi_call_virt(set_wakeup_time, enabled, tm);
+ 	spin_unlock(&efi_runtime_lock);
++>>>>>>> fe3244945c47 (efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled)
  	return status;
  }
  
@@@ -102,14 -109,25 +122,33 @@@ static efi_status_t virt_efi_get_variab
  					  unsigned long *data_size,
  					  void *data)
  {
++<<<<<<< HEAD
 +	return efi_call_virt(get_variable, name, vendor, attr, data_size, data);
++=======
+ 	efi_status_t status;
+ 
+ 	spin_lock(&efi_runtime_lock);
+ 	status = efi_call_virt(get_variable, name, vendor, attr, data_size,
+ 			       data);
+ 	spin_unlock(&efi_runtime_lock);
+ 	return status;
++>>>>>>> fe3244945c47 (efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled)
  }
  
  static efi_status_t virt_efi_get_next_variable(unsigned long *name_size,
  					       efi_char16_t *name,
  					       efi_guid_t *vendor)
  {
++<<<<<<< HEAD
 +	return efi_call_virt(get_next_variable, name_size, name, vendor);
++=======
+ 	efi_status_t status;
+ 
+ 	spin_lock(&efi_runtime_lock);
+ 	status = efi_call_virt(get_next_variable, name_size, name, vendor);
+ 	spin_unlock(&efi_runtime_lock);
+ 	return status;
++>>>>>>> fe3244945c47 (efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled)
  }
  
  static efi_status_t virt_efi_set_variable(efi_char16_t *name,
@@@ -118,7 -136,13 +157,17 @@@
  					  unsigned long data_size,
  					  void *data)
  {
++<<<<<<< HEAD
 +	return efi_call_virt(set_variable, name, vendor, attr, data_size, data);
++=======
+ 	efi_status_t status;
+ 
+ 	spin_lock(&efi_runtime_lock);
+ 	status = efi_call_virt(set_variable, name, vendor, attr, data_size,
+ 			       data);
+ 	spin_unlock(&efi_runtime_lock);
+ 	return status;
++>>>>>>> fe3244945c47 (efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled)
  }
  
  static efi_status_t
@@@ -144,11 -167,16 +192,24 @@@ static efi_status_t virt_efi_query_vari
  						 u64 *remaining_space,
  						 u64 *max_variable_size)
  {
++<<<<<<< HEAD
 +	if (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)
 +		return EFI_UNSUPPORTED;
 +
 +	return efi_call_virt(query_variable_info, attr, storage_space,
 +			     remaining_space, max_variable_size);
++=======
+ 	efi_status_t status;
+ 
+ 	if (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)
+ 		return EFI_UNSUPPORTED;
+ 
+ 	spin_lock(&efi_runtime_lock);
+ 	status = efi_call_virt(query_variable_info, attr, storage_space,
+ 			       remaining_space, max_variable_size);
+ 	spin_unlock(&efi_runtime_lock);
+ 	return status;
++>>>>>>> fe3244945c47 (efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled)
  }
  
  static efi_status_t
@@@ -174,7 -201,12 +234,16 @@@ virt_efi_query_variable_info_nonblockin
  
  static efi_status_t virt_efi_get_next_high_mono_count(u32 *count)
  {
++<<<<<<< HEAD
 +	return efi_call_virt(get_next_high_mono_count, count);
++=======
+ 	efi_status_t status;
+ 
+ 	spin_lock(&efi_runtime_lock);
+ 	status = efi_call_virt(get_next_high_mono_count, count);
+ 	spin_unlock(&efi_runtime_lock);
+ 	return status;
++>>>>>>> fe3244945c47 (efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled)
  }
  
  static void virt_efi_reset_system(int reset_type,
@@@ -182,17 -214,24 +251,35 @@@
  				  unsigned long data_size,
  				  efi_char16_t *data)
  {
++<<<<<<< HEAD
++	__efi_call_virt(reset_system, reset_type, status, data_size, data);
++=======
+ 	spin_lock(&efi_runtime_lock);
  	__efi_call_virt(reset_system, reset_type, status, data_size, data);
+ 	spin_unlock(&efi_runtime_lock);
++>>>>>>> fe3244945c47 (efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled)
  }
  
  static efi_status_t virt_efi_update_capsule(efi_capsule_header_t **capsules,
  					    unsigned long count,
  					    unsigned long sg_list)
  {
++<<<<<<< HEAD
 +	if (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)
 +		return EFI_UNSUPPORTED;
 +
 +	return efi_call_virt(update_capsule, capsules, count, sg_list);
++=======
+ 	efi_status_t status;
+ 
+ 	if (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)
+ 		return EFI_UNSUPPORTED;
+ 
+ 	spin_lock(&efi_runtime_lock);
+ 	status = efi_call_virt(update_capsule, capsules, count, sg_list);
+ 	spin_unlock(&efi_runtime_lock);
+ 	return status;
++>>>>>>> fe3244945c47 (efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled)
  }
  
  static efi_status_t virt_efi_query_capsule_caps(efi_capsule_header_t **capsules,
@@@ -200,11 -239,16 +287,24 @@@
  						u64 *max_size,
  						int *reset_type)
  {
++<<<<<<< HEAD
 +	if (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)
 +		return EFI_UNSUPPORTED;
 +
 +	return efi_call_virt(query_capsule_caps, capsules, count, max_size,
 +			     reset_type);
++=======
+ 	efi_status_t status;
+ 
+ 	if (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)
+ 		return EFI_UNSUPPORTED;
+ 
+ 	spin_lock(&efi_runtime_lock);
+ 	status = efi_call_virt(query_capsule_caps, capsules, count, max_size,
+ 			       reset_type);
+ 	spin_unlock(&efi_runtime_lock);
+ 	return status;
++>>>>>>> fe3244945c47 (efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled)
  }
  
  void efi_native_runtime_setup(void)
* Unmerged path drivers/firmware/efi/runtime-wrappers.c
