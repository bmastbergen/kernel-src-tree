ovl: return dentry from ovl_create_real()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 95a1c8153ad8bc99e7c4b90257f20b4f0474a9a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/95a1c815.failed

Al Viro suggested to simplify callers of ovl_create_real() by
returning the created dentry (or ERR_PTR) from ovl_create_real().

	Suggested-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 95a1c8153ad8bc99e7c4b90257f20b4f0474a9a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/dir.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/copy_up.c
index 5bfbfc122918,d3e9c1eeb7a4..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -533,20 -502,12 +533,25 @@@ static int ovl_get_tmpfile(struct ovl_c
  
  	if (c->tmpfile) {
  		temp = ovl_do_tmpfile(c->workdir, c->stat.mode);
- 		if (IS_ERR(temp))
- 			goto temp_err;
  	} else {
++<<<<<<< HEAD
 +		temp = ovl_lookup_temp(c->workdir);
 +		if (IS_ERR(temp))
 +			goto temp_err;
 +
 +		err = ovl_create_real(d_inode(c->workdir), temp, &cattr,
 +				      NULL, true);
 +		if (err) {
 +			dput(temp);
 +			goto out;
 +		}
++=======
+ 		temp = ovl_create_real(d_inode(c->workdir),
+ 				       ovl_lookup_temp(c->workdir), &cattr);
++>>>>>>> 95a1c8153ad8 (ovl: return dentry from ovl_create_real())
  	}
+ 	if (IS_ERR(temp))
+ 		goto temp_err;
  	err = 0;
  	*tempp = temp;
  out:
diff --cc fs/overlayfs/dir.c
index de117ec8c92e,425ddb098c4a..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -114,16 -114,20 +114,25 @@@ kill_whiteout
  	goto out;
  }
  
++<<<<<<< HEAD
 +int ovl_create_real(struct inode *dir, struct dentry *newdentry,
 +		    struct cattr *attr, struct dentry *hardlink, bool debug)
++=======
+ struct dentry *ovl_create_real(struct inode *dir, struct dentry *newdentry,
+ 			       struct ovl_cattr *attr)
++>>>>>>> 95a1c8153ad8 (ovl: return dentry from ovl_create_real())
  {
  	int err;
  
+ 	if (IS_ERR(newdentry))
+ 		return newdentry;
+ 
+ 	err = -ESTALE;
  	if (newdentry->d_inode)
- 		return -ESTALE;
+ 		goto out;
  
 -	if (attr->hardlink) {
 -		err = ovl_do_link(attr->hardlink, dir, newdentry);
 +	if (hardlink) {
 +		err = ovl_do_link(hardlink, dir, newdentry, debug);
  	} else {
  		switch (attr->mode & S_IFMT) {
  		case S_IFREG:
@@@ -220,30 -229,28 +234,47 @@@ static int ovl_create_upper(struct dent
  	struct dentry *newdentry;
  	int err;
  
 -	if (!attr->hardlink && !IS_POSIXACL(udir))
 +	if (!hardlink && !IS_POSIXACL(udir))
  		attr->mode &= ~current_umask();
  
++<<<<<<< HEAD
 +	mutex_lock_nested(&udir->i_mutex, I_MUTEX_PARENT);
 +	newdentry = lookup_one_len(dentry->d_name.name, upperdir,
 +				   dentry->d_name.len);
 +	err = PTR_ERR(newdentry);
 +	if (IS_ERR(newdentry))
 +		goto out_unlock;
 +	err = ovl_create_real(udir, newdentry, attr, hardlink, false);
 +	if (err)
 +		goto out_dput;
++=======
+ 	inode_lock_nested(udir, I_MUTEX_PARENT);
+ 	newdentry = ovl_create_real(udir,
+ 				    lookup_one_len(dentry->d_name.name,
+ 						   upperdir,
+ 						   dentry->d_name.len),
+ 				    attr);
+ 	err = PTR_ERR(newdentry);
+ 	if (IS_ERR(newdentry))
+ 		goto out_unlock;
++>>>>>>> 95a1c8153ad8 (ovl: return dentry from ovl_create_real())
  
  	if (ovl_type_merge(dentry->d_parent) && d_is_dir(newdentry)) {
  		/* Setting opaque here is just an optimization, allow to fail */
  		ovl_set_opaque(dentry, newdentry);
  	}
  
++<<<<<<< HEAD
 +	ovl_instantiate(dentry, inode, newdentry, !!hardlink);
 +	newdentry = NULL;
 +out_dput:
 +	dput(newdentry);
++=======
+ 	ovl_instantiate(dentry, inode, newdentry, !!attr->hardlink);
+ 	err = 0;
++>>>>>>> 95a1c8153ad8 (ovl: return dentry from ovl_create_real())
  out_unlock:
 -	inode_unlock(udir);
 +	mutex_unlock(&udir->i_mutex);
  	return err;
  }
  
@@@ -284,11 -293,6 +316,14 @@@ static struct dentry *ovl_clear_empty(s
  	if (IS_ERR(opaquedir))
  		goto out_unlock;
  
++<<<<<<< HEAD
 +	err = ovl_create_real(wdir, opaquedir,
 +			      &(struct cattr){.mode = stat.mode}, NULL, true);
 +	if (err)
 +		goto out_dput;
 +
++=======
++>>>>>>> 95a1c8153ad8 (ovl: return dentry from ovl_create_real())
  	err = ovl_copy_xattr(upper, opaquedir);
  	if (err)
  		goto out_cleanup;
@@@ -432,11 -386,12 +461,18 @@@ static int ovl_create_over_whiteout(str
  			       dentry->d_name.len);
  	err = PTR_ERR(upper);
  	if (IS_ERR(upper))
- 		goto out_dput;
+ 		goto out_unlock;
  
++<<<<<<< HEAD
 +	err = ovl_create_real(wdir, newdentry, cattr, hardlink, true);
 +	if (err)
 +		goto out_dput2;
++=======
+ 	newdentry = ovl_create_real(wdir, ovl_lookup_temp(workdir), cattr);
+ 	err = PTR_ERR(newdentry);
+ 	if (IS_ERR(newdentry))
+ 		goto out_dput;
++>>>>>>> 95a1c8153ad8 (ovl: return dentry from ovl_create_real())
  
  	/*
  	 * mode could have been mutilated due to umask (e.g. sgid directory)
@@@ -482,12 -437,10 +518,17 @@@
  		if (err)
  			goto out_cleanup;
  	}
++<<<<<<< HEAD
 +	ovl_instantiate(dentry, inode, newdentry, !!hardlink);
 +	newdentry = NULL;
 +out_dput2:
 +	dput(upper);
++=======
+ 	ovl_instantiate(dentry, inode, newdentry, hardlink);
+ 	err = 0;
++>>>>>>> 95a1c8153ad8 (ovl: return dentry from ovl_create_real())
  out_dput:
- 	dput(newdentry);
+ 	dput(upper);
  out_unlock:
  	unlock_rename(workdir, upperdir);
  out:
diff --cc fs/overlayfs/overlayfs.h
index 403c48960f89,6bbde513e068..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -311,10 -353,13 +311,18 @@@ struct cattr 
  	dev_t rdev;
  	umode_t mode;
  	const char *link;
 -	struct dentry *hardlink;
  };
++<<<<<<< HEAD
 +int ovl_create_real(struct inode *dir, struct dentry *newdentry,
 +		    struct cattr *attr,
 +		    struct dentry *hardlink, bool debug);
++=======
+ 
+ #define OVL_CATTR(m) (&(struct ovl_cattr) { .mode = (m) })
+ 
+ struct dentry *ovl_create_real(struct inode *dir, struct dentry *newdentry,
+ 			       struct ovl_cattr *attr);
++>>>>>>> 95a1c8153ad8 (ovl: return dentry from ovl_create_real())
  int ovl_cleanup(struct inode *dir, struct dentry *dentry);
  
  /* copy_up.c */
diff --cc fs/overlayfs/super.c
index b0392d1737a3,704b37311467..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -533,11 -611,10 +533,18 @@@ retry
  			goto retry;
  		}
  
++<<<<<<< HEAD
 +		err = ovl_create_real(dir, work,
 +				      &(struct cattr){.mode = S_IFDIR | 0},
 +				      NULL, true);
 +		if (err)
 +			goto out_dput;
++=======
+ 		work = ovl_create_real(dir, work, OVL_CATTR(attr.ia_mode));
+ 		err = PTR_ERR(work);
+ 		if (IS_ERR(work))
+ 			goto out_err;
++>>>>>>> 95a1c8153ad8 (ovl: return dentry from ovl_create_real())
  
  		/*
  		 * Try to remove POSIX ACL xattrs from workdir.  We are good if:
* Unmerged path fs/overlayfs/copy_up.c
* Unmerged path fs/overlayfs/dir.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/super.c
