acpi/nfit, libnvdimm: Add enable/update passphrase support for Intel nvdimms

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Dave Jiang <dave.jiang@intel.com>
commit d2a4ac73f56a5d0709d28b41fec8d15e4500f8f1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d2a4ac73.failed

Add support for enabling and updating passphrase on the Intel nvdimms.
The passphrase is the an encrypted key in the kernel user keyring.
We trigger the update via writing "update <old_keyid> <new_keyid>" to the
sysfs attribute "security". If no <old_keyid> exists (for enabling
security) then a 0 should be used.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit d2a4ac73f56a5d0709d28b41fec8d15e4500f8f1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvdimm/dimm_devs.c
#	drivers/nvdimm/nd-core.h
#	drivers/nvdimm/security.c
diff --cc drivers/nvdimm/dimm_devs.c
index 508dd405f84f,1cc3a6af3d0e..000000000000
--- a/drivers/nvdimm/dimm_devs.c
+++ b/drivers/nvdimm/dimm_devs.c
@@@ -370,6 -370,114 +370,117 @@@ static ssize_t available_slots_show(str
  }
  static DEVICE_ATTR_RO(available_slots);
  
++<<<<<<< HEAD
++=======
+ static ssize_t security_show(struct device *dev,
+ 		struct device_attribute *attr, char *buf)
+ {
+ 	struct nvdimm *nvdimm = to_nvdimm(dev);
+ 
+ 	switch (nvdimm->sec.state) {
+ 	case NVDIMM_SECURITY_DISABLED:
+ 		return sprintf(buf, "disabled\n");
+ 	case NVDIMM_SECURITY_UNLOCKED:
+ 		return sprintf(buf, "unlocked\n");
+ 	case NVDIMM_SECURITY_LOCKED:
+ 		return sprintf(buf, "locked\n");
+ 	case NVDIMM_SECURITY_FROZEN:
+ 		return sprintf(buf, "frozen\n");
+ 	case NVDIMM_SECURITY_OVERWRITE:
+ 		return sprintf(buf, "overwrite\n");
+ 	}
+ 
+ 	return -ENOTTY;
+ }
+ 
+ #define OPS						\
+ 	C( OP_FREEZE,		"freeze",	1),	\
+ 	C( OP_DISABLE,		"disable",	2),	\
+ 	C( OP_UPDATE,		"update",	3)
+ #undef C
+ #define C(a, b, c) a
+ enum nvdimmsec_op_ids { OPS };
+ #undef C
+ #define C(a, b, c) { b, c }
+ static struct {
+ 	const char *name;
+ 	int args;
+ } ops[] = { OPS };
+ #undef C
+ 
+ #define SEC_CMD_SIZE 32
+ #define KEY_ID_SIZE 10
+ 
+ static ssize_t __security_store(struct device *dev, const char *buf, size_t len)
+ {
+ 	struct nvdimm *nvdimm = to_nvdimm(dev);
+ 	ssize_t rc;
+ 	char cmd[SEC_CMD_SIZE+1], keystr[KEY_ID_SIZE+1],
+ 		nkeystr[KEY_ID_SIZE+1];
+ 	unsigned int key, newkey;
+ 	int i;
+ 
+ 	if (atomic_read(&nvdimm->busy))
+ 		return -EBUSY;
+ 
+ 	rc = sscanf(buf, "%"__stringify(SEC_CMD_SIZE)"s"
+ 			" %"__stringify(KEY_ID_SIZE)"s"
+ 			" %"__stringify(KEY_ID_SIZE)"s",
+ 			cmd, keystr, nkeystr);
+ 	if (rc < 1)
+ 		return -EINVAL;
+ 	for (i = 0; i < ARRAY_SIZE(ops); i++)
+ 		if (sysfs_streq(cmd, ops[i].name))
+ 			break;
+ 	if (i >= ARRAY_SIZE(ops))
+ 		return -EINVAL;
+ 	if (ops[i].args > 1)
+ 		rc = kstrtouint(keystr, 0, &key);
+ 	if (rc >= 0 && ops[i].args > 2)
+ 		rc = kstrtouint(nkeystr, 0, &newkey);
+ 	if (rc < 0)
+ 		return rc;
+ 
+ 	if (i == OP_FREEZE) {
+ 		dev_dbg(dev, "freeze\n");
+ 		rc = nvdimm_security_freeze(nvdimm);
+ 	} else if (i == OP_DISABLE) {
+ 		dev_dbg(dev, "disable %u\n", key);
+ 		rc = nvdimm_security_disable(nvdimm, key);
+ 	} else if (i == OP_UPDATE) {
+ 		dev_dbg(dev, "update %u %u\n", key, newkey);
+ 		rc = nvdimm_security_update(nvdimm, key, newkey);
+ 	} else
+ 		return -EINVAL;
+ 
+ 	if (rc == 0)
+ 		rc = len;
+ 	return rc;
+ }
+ 
+ static ssize_t security_store(struct device *dev,
+ 		struct device_attribute *attr, const char *buf, size_t len)
+ 
+ {
+ 	ssize_t rc;
+ 
+ 	/*
+ 	 * Require all userspace triggered security management to be
+ 	 * done while probing is idle and the DIMM is not in active use
+ 	 * in any region.
+ 	 */
+ 	device_lock(dev);
+ 	nvdimm_bus_lock(dev);
+ 	wait_nvdimm_bus_probe_idle(dev);
+ 	rc = __security_store(dev, buf, len);
+ 	nvdimm_bus_unlock(dev);
+ 	device_unlock(dev);
+ 
+ 	return rc;
+ }
+ static DEVICE_ATTR_RW(security);
+ 
++>>>>>>> d2a4ac73f56a (acpi/nfit, libnvdimm: Add enable/update passphrase support for Intel nvdimms)
  static struct attribute *nvdimm_attributes[] = {
  	&dev_attr_state.attr,
  	&dev_attr_flags.attr,
@@@ -378,8 -486,26 +489,27 @@@
  	NULL,
  };
  
++<<<<<<< HEAD
++=======
+ static umode_t nvdimm_visible(struct kobject *kobj, struct attribute *a, int n)
+ {
+ 	struct device *dev = container_of(kobj, typeof(*dev), kobj);
+ 	struct nvdimm *nvdimm = to_nvdimm(dev);
+ 
+ 	if (a != &dev_attr_security.attr)
+ 		return a->mode;
+ 	if (nvdimm->sec.state < 0)
+ 		return 0;
+ 	/* Are there any state mutation ops? */
+ 	if (nvdimm->sec.ops->freeze || nvdimm->sec.ops->disable
+ 			|| nvdimm->sec.ops->change_key)
+ 		return a->mode;
+ 	return 0444;
+ }
+ 
++>>>>>>> d2a4ac73f56a (acpi/nfit, libnvdimm: Add enable/update passphrase support for Intel nvdimms)
  struct attribute_group nvdimm_attribute_group = {
  	.attrs = nvdimm_attributes,
 -	.is_visible = nvdimm_visible,
  };
  EXPORT_SYMBOL_GPL(nvdimm_attribute_group);
  
diff --cc drivers/nvdimm/nd-core.h
index ff26876e6ea3,c2567f9ae07b..000000000000
--- a/drivers/nvdimm/nd-core.h
+++ b/drivers/nvdimm/nd-core.h
@@@ -42,8 -42,38 +42,37 @@@ struct nvdimm 
  	int id, num_flush;
  	struct resource *flush_wpq;
  	const char *dimm_id;
 -	struct {
 -		const struct nvdimm_security_ops *ops;
 -		enum nvdimm_security_state state;
 -	} sec;
  };
  
++<<<<<<< HEAD
++=======
+ static inline enum nvdimm_security_state nvdimm_security_state(
+ 		struct nvdimm *nvdimm)
+ {
+ 	if (!nvdimm->sec.ops)
+ 		return -ENXIO;
+ 
+ 	return nvdimm->sec.ops->state(nvdimm);
+ }
+ int nvdimm_security_freeze(struct nvdimm *nvdimm);
+ #if IS_ENABLED(CONFIG_NVDIMM_KEYS)
+ int nvdimm_security_disable(struct nvdimm *nvdimm, unsigned int keyid);
+ int nvdimm_security_update(struct nvdimm *nvdimm, unsigned int keyid,
+ 		unsigned int new_keyid);
+ #else
+ static inline int nvdimm_security_disable(struct nvdimm *nvdimm,
+ 		unsigned int keyid)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ static inline int nvdimm_security_update(struct nvdimm *nvdimm, unsigned int keyid,
+ 		unsigned int new_keyid)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ #endif
+ 
++>>>>>>> d2a4ac73f56a (acpi/nfit, libnvdimm: Add enable/update passphrase support for Intel nvdimms)
  /**
   * struct blk_alloc_info - tracking info for BLK dpa scanning
   * @nd_mapping: blk region mapping boundaries
* Unmerged path drivers/nvdimm/security.c
* Unmerged path drivers/nvdimm/dimm_devs.c
* Unmerged path drivers/nvdimm/nd-core.h
* Unmerged path drivers/nvdimm/security.c
