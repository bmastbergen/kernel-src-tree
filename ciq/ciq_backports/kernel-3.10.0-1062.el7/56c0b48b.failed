powerpc/powernv: process all OPAL event interrupts with kopald

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [powerpc] powernv: process all OPAL event interrupts with kopald (Gustavo Duarte) [1577105]
Rebuild_FUZZ: 93.10%
commit-author Nicholas Piggin <npiggin@gmail.com>
commit 56c0b48b1e443efa5d6f4d60513302c934e55b17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/56c0b48b.failed

Using irq_work for processing OPAL event interrupts is not necessary.
irq_work is typically used to schedule work from NMI context, a
softirq may be more appropriate. However OPAL events are not
particularly performance or latency critical, so they can all be
invoked by kopald.

This patch removes the irq_work queueing, and instead wakes up
kopald when there is an event to be processed. kopald processes
interrupts individually, enabling irqs and calling cond_resched
between each one to minimise latencies.

Event handlers themselves should still use threaded handlers,
workqueues, etc. as necessary to avoid high interrupts-off latencies
within any single interrupt.

	Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 56c0b48b1e443efa5d6f4d60513302c934e55b17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/opal-irqchip.c
#	arch/powerpc/platforms/powernv/opal.c
#	arch/powerpc/platforms/powernv/powernv.h
diff --cc arch/powerpc/platforms/powernv/opal.c
index 20dc06f5b2a8,0d539c661748..000000000000
--- a/arch/powerpc/platforms/powernv/opal.c
+++ b/arch/powerpc/platforms/powernv/opal.c
@@@ -609,9 -548,7 +605,13 @@@ int opal_handle_hmi_exception(struct pt
  		return 0;
  
  	local_paca->hmi_event_available = 0;
++<<<<<<< HEAD
 +	rc = opal_poll_events(&evt);
 +	if (rc == OPAL_SUCCESS && evt)
 +		opal_do_notifier(be64_to_cpu(evt));
++=======
+ 	opal_wake_poller();
++>>>>>>> 56c0b48b1e44 (powerpc/powernv: process all OPAL event interrupts with kopald)
  
  	return 1;
  }
@@@ -737,11 -750,20 +737,28 @@@ static void opal_pdev_init(struct devic
  
  static int kopald(void *unused)
  {
++<<<<<<< HEAD
 +	set_freezable();
 +	do {
 +		try_to_freeze();
 +		opal_poll_events(NULL);
 +		msleep_interruptible(opal_heartbeat);
++=======
+ 	unsigned long timeout = msecs_to_jiffies(opal_heartbeat) + 1;
+ 
+ 	set_freezable();
+ 	do {
+ 		try_to_freeze();
+ 
+ 		opal_handle_events();
+ 
+ 		set_current_state(TASK_INTERRUPTIBLE);
+ 		if (opal_have_pending_events())
+ 			__set_current_state(TASK_RUNNING);
+ 		else
+ 			schedule_timeout(timeout);
+ 
++>>>>>>> 56c0b48b1e44 (powerpc/powernv: process all OPAL event interrupts with kopald)
  	} while (!kthread_should_stop());
  
  	return 0;
diff --cc arch/powerpc/platforms/powernv/powernv.h
index 1e56962df621,fd4a1c5a6369..000000000000
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@@ -27,6 -24,10 +27,13 @@@ extern u32 pnv_get_supported_cpuidle_st
  
  extern void pnv_lpc_init(void);
  
++<<<<<<< HEAD
++=======
+ extern void opal_handle_events(void);
+ extern bool opal_have_pending_events(void);
+ extern void opal_event_shutdown(void);
+ 
++>>>>>>> 56c0b48b1e44 (powerpc/powernv: process all OPAL event interrupts with kopald)
  bool cpu_core_split_required(void);
  
  #endif /* _POWERNV_H */
* Unmerged path arch/powerpc/platforms/powernv/opal-irqchip.c
* Unmerged path arch/powerpc/platforms/powernv/opal-irqchip.c
* Unmerged path arch/powerpc/platforms/powernv/opal.c
* Unmerged path arch/powerpc/platforms/powernv/powernv.h
