PCI: hv: Fix 2 hang issues in hv_compose_msi_msg()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [pci] hv: Fix 2 hang issues in hv_compose_msi_msg() (Mohammed Gamal) [1636237]
Rebuild_FUZZ: 94.74%
commit-author Dexuan Cui <decui@microsoft.com>
commit de0aa7b2f97d348ba7d1e17a00744c989baa0cb6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/de0aa7b2.failed

1. With the patch "x86/vector/msi: Switch to global reservation mode",
the recent v4.15 and newer kernels always hang for 1-vCPU Hyper-V VM
with SR-IOV. This is because when we reach hv_compose_msi_msg() by
request_irq() -> request_threaded_irq() ->__setup_irq()->irq_startup()
-> __irq_startup() -> irq_domain_activate_irq() -> ... ->
msi_domain_activate() -> ... -> hv_compose_msi_msg(), local irq is
disabled in __setup_irq().

Note: when we reach hv_compose_msi_msg() by another code path:
pci_enable_msix_range() -> ... -> irq_domain_activate_irq() -> ... ->
hv_compose_msi_msg(), local irq is not disabled.

hv_compose_msi_msg() depends on an interrupt from the host.
With interrupts disabled, a UP VM always hangs in the busy loop in
the function, because the interrupt callback hv_pci_onchannelcallback()
can not be called.

We can do nothing but work it around by polling the channel. This
is ugly, but we don't have any other choice.

2. If the host is ejecting the VF device before we reach
hv_compose_msi_msg(), in a UP VM, we can hang in hv_compose_msi_msg()
forever, because at this time the host doesn't respond to the
CREATE_INTERRUPT request. This issue exists the first day the
pci-hyperv driver appears in the kernel.

Luckily, this can also by worked around by polling the channel
for the PCI_EJECT message and hpdev->state, and by checking the
PCI vendor ID.

Note: actually the above 2 issues also happen to a SMP VM, if
"hbus->hdev->channel->target_cpu == smp_processor_id()" is true.

Fixes: 4900be83602b ("x86/vector/msi: Switch to global reservation mode")
	Tested-by: Adrian Suhov <v-adsuho@microsoft.com>
	Tested-by: Chris Valean <v-chvale@microsoft.com>
	Signed-off-by: Dexuan Cui <decui@microsoft.com>
	Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
	Acked-by: Haiyang Zhang <haiyangz@microsoft.com>
	Cc: <stable@vger.kernel.org>
	Cc: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: K. Y. Srinivasan <kys@microsoft.com>
	Cc: Vitaly Kuznetsov <vkuznets@redhat.com>
	Cc: Jack Morgenstein <jackm@mellanox.com>
(cherry picked from commit de0aa7b2f97d348ba7d1e17a00744c989baa0cb6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci-hyperv.c
diff --cc drivers/pci/pci-hyperv.c
index 8cf730c4cdb4,cb694d2a1228..000000000000
--- a/drivers/pci/pci-hyperv.c
+++ b/drivers/pci/pci-hyperv.c
@@@ -523,7 -521,7 +523,11 @@@ struct hv_pci_compl 
  	s32 completion_status;
  };
  
++<<<<<<< HEAD:drivers/pci/pci-hyperv.c
 +struct x86_msi_ops hv_msi;
++=======
+ static void hv_pci_onchannelcallback(void *context);
++>>>>>>> de0aa7b2f97d (PCI: hv: Fix 2 hang issues in hv_compose_msi_msg()):drivers/pci/host/pci-hyperv.c
  
  /**
   * hv_pci_generic_compl() - Invoked for a completion packet
@@@ -1063,12 -1134,42 +1092,41 @@@ static void hv_compose_msi_msg(struct p
  	 * Since this function is called with IRQ locks held, can't
  	 * do normal wait for completion; instead poll.
  	 */
- 	while (!try_wait_for_completion(&comp.comp_pkt.host_event))
+ 	while (!try_wait_for_completion(&comp.comp_pkt.host_event)) {
+ 		/* 0xFFFF means an invalid PCI VENDOR ID. */
+ 		if (hv_pcifront_get_vendor_id(hpdev) == 0xFFFF) {
+ 			dev_err_once(&hbus->hdev->device,
+ 				     "the device has gone\n");
+ 			goto free_int_desc;
+ 		}
+ 
+ 		/*
+ 		 * When the higher level interrupt code calls us with
+ 		 * interrupt disabled, we must poll the channel by calling
+ 		 * the channel callback directly when channel->target_cpu is
+ 		 * the current CPU. When the higher level interrupt code
+ 		 * calls us with interrupt enabled, let's add the
+ 		 * local_bh_disable()/enable() to avoid race.
+ 		 */
+ 		local_bh_disable();
+ 
+ 		if (hbus->hdev->channel->target_cpu == smp_processor_id())
+ 			hv_pci_onchannelcallback(hbus);
+ 
+ 		local_bh_enable();
+ 
+ 		if (hpdev->state == hv_pcichild_ejecting) {
+ 			dev_err_once(&hbus->hdev->device,
+ 				     "the device is being ejected\n");
+ 			goto free_int_desc;
+ 		}
+ 
  		udelay(100);
+ 	}
  
  	if (comp.comp_pkt.completion_status < 0) {
 -		dev_err(&hbus->hdev->device,
 -			"Request for interrupt failed: 0x%x",
 -			comp.comp_pkt.completion_status);
 +		pr_err("Request for interrupt failed: 0x%x",
 +		       comp.comp_pkt.completion_status);
  		goto free_int_desc;
  	}
  
* Unmerged path drivers/pci/pci-hyperv.c
