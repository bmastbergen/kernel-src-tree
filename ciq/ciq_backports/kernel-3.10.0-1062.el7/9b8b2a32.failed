IB/ipoib: Use dev_port to expose network interface port numbers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Arseny Maslennikov <ar@cs.msu.ru>
commit 9b8b2a323008aedd39a8debb861b825707f01420
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9b8b2a32.failed

Some InfiniBand network devices have multiple ports on the same PCI
function. This initializes the `dev_port' sysfs field of those
network interfaces with their port number.

Prior to this the kernel erroneously used the `dev_id' sysfs
field of those network interfaces to convey the port number to userspace.

The use of `dev_id' was considered correct until Linux 3.15,
when another field, `dev_port', was defined for this particular
purpose and `dev_id' was reserved for distinguishing stacked ifaces
(e.g: VLANs) with the same hardware address as their parent device.

Similar fixes to net/mlx4_en and many other drivers, which started
exporting this information through `dev_id' before 3.15, were accepted
into the kernel 4 years ago.
See 76a066f2a2a0 (`net/mlx4_en: Expose port number through sysfs').

	Signed-off-by: Arseny Maslennikov <ar@cs.msu.ru>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 9b8b2a323008aedd39a8debb861b825707f01420)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/ipoib/ipoib_main.c
diff --cc drivers/infiniband/ulp/ipoib/ipoib_main.c
index 7e4e2a9adc93,a046076670e6..000000000000
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@@ -1819,10 -1810,145 +1819,146 @@@ out
  	return ret;
  }
  
 -/*
 - * This must be called before doing an unregister_netdev on a parent device to
 - * shutdown the IB event handler.
 - */
 -static void ipoib_parent_unregister_pre(struct net_device *ndev)
 +void ipoib_dev_cleanup(struct net_device *dev)
  {
++<<<<<<< HEAD
 +	struct ipoib_dev_priv *priv = ipoib_priv(dev), *cpriv, *tcpriv;
 +	LIST_HEAD(head);
++=======
+ 	struct ipoib_dev_priv *priv = ipoib_priv(ndev);
+ 
+ 	/*
+ 	 * ipoib_set_mac checks netif_running before pushing work, clearing
+ 	 * running ensures the it will not add more work.
+ 	 */
+ 	rtnl_lock();
+ 	dev_change_flags(priv->dev, priv->dev->flags & ~IFF_UP);
+ 	rtnl_unlock();
+ 
+ 	/* ipoib_event() cannot be running once this returns */
+ 	ib_unregister_event_handler(&priv->event_handler);
+ 
+ 	/*
+ 	 * Work on the queue grabs the rtnl lock, so this cannot be done while
+ 	 * also holding it.
+ 	 */
+ 	flush_workqueue(ipoib_workqueue);
+ }
+ 
+ static void ipoib_set_dev_features(struct ipoib_dev_priv *priv)
+ {
+ 	priv->hca_caps = priv->ca->attrs.device_cap_flags;
+ 
+ 	if (priv->hca_caps & IB_DEVICE_UD_IP_CSUM) {
+ 		priv->dev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM;
+ 
+ 		if (priv->hca_caps & IB_DEVICE_UD_TSO)
+ 			priv->dev->hw_features |= NETIF_F_TSO;
+ 
+ 		priv->dev->features |= priv->dev->hw_features;
+ 	}
+ }
+ 
+ static int ipoib_parent_init(struct net_device *ndev)
+ {
+ 	struct ipoib_dev_priv *priv = ipoib_priv(ndev);
+ 	struct ib_port_attr attr;
+ 	int result;
+ 
+ 	result = ib_query_port(priv->ca, priv->port, &attr);
+ 	if (result) {
+ 		pr_warn("%s: ib_query_port %d failed\n", priv->ca->name,
+ 			priv->port);
+ 		return result;
+ 	}
+ 	priv->max_ib_mtu = ib_mtu_enum_to_int(attr.max_mtu);
+ 
+ 	result = ib_query_pkey(priv->ca, priv->port, 0, &priv->pkey);
+ 	if (result) {
+ 		pr_warn("%s: ib_query_pkey port %d failed (ret = %d)\n",
+ 			priv->ca->name, priv->port, result);
+ 		return result;
+ 	}
+ 
+ 	result = rdma_query_gid(priv->ca, priv->port, 0, &priv->local_gid);
+ 	if (result) {
+ 		pr_warn("%s: rdma_query_gid port %d failed (ret = %d)\n",
+ 			priv->ca->name, priv->port, result);
+ 		return result;
+ 	}
+ 	memcpy(priv->dev->dev_addr + 4, priv->local_gid.raw,
+ 	       sizeof(union ib_gid));
+ 
+ 	SET_NETDEV_DEV(priv->dev, priv->ca->dev.parent);
+ 	priv->dev->dev_port = priv->port - 1;
+ 	/* Let's set this one too for backwards compatibility. */
+ 	priv->dev->dev_id = priv->port - 1;
+ 
+ 	return 0;
+ }
+ 
+ static void ipoib_child_init(struct net_device *ndev)
+ {
+ 	struct ipoib_dev_priv *priv = ipoib_priv(ndev);
+ 	struct ipoib_dev_priv *ppriv = ipoib_priv(priv->parent);
+ 
+ 	dev_hold(priv->parent);
+ 
+ 	down_write(&ppriv->vlan_rwsem);
+ 	list_add_tail(&priv->list, &ppriv->child_intfs);
+ 	up_write(&ppriv->vlan_rwsem);
+ 
+ 	priv->max_ib_mtu = ppriv->max_ib_mtu;
+ 	set_bit(IPOIB_FLAG_SUBINTERFACE, &priv->flags);
+ 	memcpy(priv->dev->dev_addr, ppriv->dev->dev_addr, INFINIBAND_ALEN);
+ 	memcpy(&priv->local_gid, &ppriv->local_gid, sizeof(priv->local_gid));
+ }
+ 
+ static int ipoib_ndo_init(struct net_device *ndev)
+ {
+ 	struct ipoib_dev_priv *priv = ipoib_priv(ndev);
+ 	int rc;
+ 
+ 	if (priv->parent) {
+ 		ipoib_child_init(ndev);
+ 	} else {
+ 		rc = ipoib_parent_init(ndev);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	/* MTU will be reset when mcast join happens */
+ 	ndev->mtu = IPOIB_UD_MTU(priv->max_ib_mtu);
+ 	priv->mcast_mtu = priv->admin_mtu = ndev->mtu;
+ 	ndev->max_mtu = IPOIB_CM_MTU;
+ 
+ 	ndev->neigh_priv_len = sizeof(struct ipoib_neigh);
+ 
+ 	/*
+ 	 * Set the full membership bit, so that we join the right
+ 	 * broadcast group, etc.
+ 	 */
+ 	priv->pkey |= 0x8000;
+ 
+ 	ndev->broadcast[8] = priv->pkey >> 8;
+ 	ndev->broadcast[9] = priv->pkey & 0xff;
+ 	set_bit(IPOIB_FLAG_DEV_ADDR_SET, &priv->flags);
+ 
+ 	ipoib_set_dev_features(priv);
+ 
+ 	rc = ipoib_dev_init(ndev);
+ 	if (rc) {
+ 		pr_warn("%s: failed to initialize device: %s port %d (ret = %d)\n",
+ 			priv->ca->name, priv->dev->name, priv->port, rc);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void ipoib_ndo_uninit(struct net_device *dev)
+ {
+ 	struct ipoib_dev_priv *priv = ipoib_priv(dev);
++>>>>>>> 9b8b2a323008 (IB/ipoib: Use dev_port to expose network interface port numbers)
  
  	ASSERT_RTNL();
  
* Unmerged path drivers/infiniband/ulp/ipoib/ipoib_main.c
