xfrm: Use __skb_queue_tail in xfrm_trans_queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit d16b46e4fd8bc6063624605f25b8c0835bb1fbe3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d16b46e4.failed

We do not need locking in xfrm_trans_queue because it is designed
to use per-CPU buffers.  However, the original code incorrectly
used skb_queue_tail which takes the lock.  This patch switches
it to __skb_queue_tail instead.

Reported-and-tested-by: Artem Savkov <asavkov@redhat.com>
Fixes: acf568ee859f ("xfrm: Reinject transport-mode packets...")
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit d16b46e4fd8bc6063624605f25b8c0835bb1fbe3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xfrm/xfrm_input.c
diff --cc net/xfrm/xfrm_input.c
index f7368e09f8ad,5b2409746ae0..000000000000
--- a/net/xfrm/xfrm_input.c
+++ b/net/xfrm/xfrm_input.c
@@@ -387,8 -493,47 +387,42 @@@ int xfrm_input_resume(struct sk_buff *s
  }
  EXPORT_SYMBOL(xfrm_input_resume);
  
++<<<<<<< HEAD
++=======
+ static void xfrm_trans_reinject(unsigned long data)
+ {
+ 	struct xfrm_trans_tasklet *trans = (void *)data;
+ 	struct sk_buff_head queue;
+ 	struct sk_buff *skb;
+ 
+ 	__skb_queue_head_init(&queue);
+ 	skb_queue_splice_init(&trans->queue, &queue);
+ 
+ 	while ((skb = __skb_dequeue(&queue)))
+ 		XFRM_TRANS_SKB_CB(skb)->finish(dev_net(skb->dev), NULL, skb);
+ }
+ 
+ int xfrm_trans_queue(struct sk_buff *skb,
+ 		     int (*finish)(struct net *, struct sock *,
+ 				   struct sk_buff *))
+ {
+ 	struct xfrm_trans_tasklet *trans;
+ 
+ 	trans = this_cpu_ptr(&xfrm_trans_tasklet);
+ 
+ 	if (skb_queue_len(&trans->queue) >= netdev_max_backlog)
+ 		return -ENOBUFS;
+ 
+ 	XFRM_TRANS_SKB_CB(skb)->finish = finish;
+ 	__skb_queue_tail(&trans->queue, skb);
+ 	tasklet_schedule(&trans->tasklet);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(xfrm_trans_queue);
+ 
++>>>>>>> d16b46e4fd8b (xfrm: Use __skb_queue_tail in xfrm_trans_queue)
  void __init xfrm_input_init(void)
  {
 -	int err;
 -	int i;
 -
 -	init_dummy_netdev(&xfrm_napi_dev);
 -	err = gro_cells_init(&gro_cells, &xfrm_napi_dev);
 -	if (err)
 -		gro_cells.cells = NULL;
 -
  	secpath_cachep = kmem_cache_create("secpath_cache",
  					   sizeof(struct sec_path),
  					   0, SLAB_HWCACHE_ALIGN|SLAB_PANIC,
* Unmerged path net/xfrm/xfrm_input.c
