xfs: remove if_rdev

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 66f364649d870c7541c30a2f02a32fd4c88684f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/66f36464.failed

We can simply use the i_rdev field in the Linux inode and just convert
to and from the XFS dev_t when reading or logging/writing the inode.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 66f364649d870c7541c30a2f02a32fd4c88684f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_fork.c
diff --cc fs/xfs/libxfs/xfs_inode_fork.c
index f83028029221,b1e69734c450..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@@ -61,13 -67,71 +67,70 @@@ xfs_iformat_fork
  	int			error = 0;
  	xfs_fsize_t             di_size;
  
++<<<<<<< HEAD
 +	switch (VFS_I(ip)->i_mode & S_IFMT) {
++=======
+ 	if (unlikely(be32_to_cpu(dip->di_nextents) +
+ 		     be16_to_cpu(dip->di_anextents) >
+ 		     be64_to_cpu(dip->di_nblocks))) {
+ 		xfs_warn(ip->i_mount,
+ 			"corrupt dinode %Lu, extent total = %d, nblocks = %Lu.",
+ 			(unsigned long long)ip->i_ino,
+ 			(int)(be32_to_cpu(dip->di_nextents) +
+ 			      be16_to_cpu(dip->di_anextents)),
+ 			(unsigned long long)
+ 				be64_to_cpu(dip->di_nblocks));
+ 		XFS_CORRUPTION_ERROR("xfs_iformat(1)", XFS_ERRLEVEL_LOW,
+ 				     ip->i_mount, dip);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (unlikely(dip->di_forkoff > ip->i_mount->m_sb.sb_inodesize)) {
+ 		xfs_warn(ip->i_mount, "corrupt dinode %Lu, forkoff = 0x%x.",
+ 			(unsigned long long)ip->i_ino,
+ 			dip->di_forkoff);
+ 		XFS_CORRUPTION_ERROR("xfs_iformat(2)", XFS_ERRLEVEL_LOW,
+ 				     ip->i_mount, dip);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (unlikely((ip->i_d.di_flags & XFS_DIFLAG_REALTIME) &&
+ 		     !ip->i_mount->m_rtdev_targp)) {
+ 		xfs_warn(ip->i_mount,
+ 			"corrupt dinode %Lu, has realtime flag set.",
+ 			ip->i_ino);
+ 		XFS_CORRUPTION_ERROR("xfs_iformat(realtime)",
+ 				     XFS_ERRLEVEL_LOW, ip->i_mount, dip);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (unlikely(xfs_is_reflink_inode(ip) && !S_ISREG(inode->i_mode))) {
+ 		xfs_warn(ip->i_mount,
+ 			"corrupt dinode %llu, wrong file type for reflink.",
+ 			ip->i_ino);
+ 		XFS_CORRUPTION_ERROR("xfs_iformat(reflink)",
+ 				     XFS_ERRLEVEL_LOW, ip->i_mount, dip);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if (unlikely(xfs_is_reflink_inode(ip) &&
+ 	    (ip->i_d.di_flags & XFS_DIFLAG_REALTIME))) {
+ 		xfs_warn(ip->i_mount,
+ 			"corrupt dinode %llu, has reflink+realtime flag set.",
+ 			ip->i_ino);
+ 		XFS_CORRUPTION_ERROR("xfs_iformat(reflink)",
+ 				     XFS_ERRLEVEL_LOW, ip->i_mount, dip);
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	switch (inode->i_mode & S_IFMT) {
++>>>>>>> 66f364649d87 (xfs: remove if_rdev)
  	case S_IFIFO:
  	case S_IFCHR:
  	case S_IFBLK:
  	case S_IFSOCK:
 -		if (unlikely(dip->di_format != XFS_DINODE_FMT_DEV)) {
 -			XFS_CORRUPTION_ERROR("xfs_iformat(3)", XFS_ERRLEVEL_LOW,
 -					      ip->i_mount, dip);
 -			return -EFSCORRUPTED;
 -		}
  		ip->i_d.di_size = 0;
- 		ip->i_df.if_u2.if_rdev = xfs_dinode_get_rdev(dip);
+ 		inode->i_rdev = xfs_to_linux_dev_t(xfs_dinode_get_rdev(dip));
  		break;
  
  	case S_IFREG:
@@@ -91,15 -182,14 +154,14 @@@
  		break;
  
  	default:
 -		XFS_ERROR_REPORT("xfs_iformat(7)", XFS_ERRLEVEL_LOW, ip->i_mount);
  		return -EFSCORRUPTED;
  	}
 -	if (error)
 +	if (error) {
  		return error;
 +	}
  
  	/* Check inline dir contents. */
- 	if (S_ISDIR(VFS_I(ip)->i_mode) &&
- 	    dip->di_format == XFS_DINODE_FMT_LOCAL) {
+ 	if (S_ISDIR(inode->i_mode) && dip->di_format == XFS_DINODE_FMT_LOCAL) {
  		error = xfs_dir2_sf_verify(ip);
  		if (error) {
  			xfs_idestroy_fork(ip, XFS_DATA_FORK);
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.c
diff --git a/fs/xfs/libxfs/xfs_inode_fork.h b/fs/xfs/libxfs/xfs_inode_fork.h
index a53b7ced7b58..f72db905c5f4 100644
--- a/fs/xfs/libxfs/xfs_inode_fork.h
+++ b/fs/xfs/libxfs/xfs_inode_fork.h
@@ -69,7 +69,6 @@ typedef struct xfs_ifork {
 						/* very small file extents */
 		char		if_inline_data[XFS_INLINE_DATA];
 						/* very small file data */
-		xfs_dev_t	if_rdev;	/* dev number if special */
 	} if_u2;
 } xfs_ifork_t;
 
diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c
index 9c6a8d2625e6..567a90a084c4 100644
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@ -743,7 +743,7 @@ xfs_ialloc(
 	xfs_inode_t	*pip,
 	umode_t		mode,
 	xfs_nlink_t	nlink,
-	xfs_dev_t	rdev,
+	dev_t		rdev,
 	prid_t		prid,
 	int		okalloc,
 	xfs_buf_t	**ialloc_context,
@@ -795,6 +795,7 @@ xfs_ialloc(
 	set_nlink(inode, nlink);
 	ip->i_d.di_uid = xfs_kuid_to_uid(current_fsuid());
 	ip->i_d.di_gid = xfs_kgid_to_gid(current_fsgid());
+	inode->i_rdev = rdev;
 	xfs_set_projid(ip, prid);
 
 	if (pip && XFS_INHERIT_GID(pip)) {
@@ -842,7 +843,6 @@ xfs_ialloc(
 	case S_IFBLK:
 	case S_IFSOCK:
 		ip->i_d.di_format = XFS_DINODE_FMT_DEV;
-		ip->i_df.if_u2.if_rdev = rdev;
 		ip->i_df.if_flags = 0;
 		flags |= XFS_ILOG_DEV;
 		break;
@@ -934,7 +934,7 @@ xfs_dir_ialloc(
 					   the inode. */
 	umode_t		mode,
 	xfs_nlink_t	nlink,
-	xfs_dev_t	rdev,
+	dev_t		rdev,
 	prid_t		prid,		/* project id */
 	int		okalloc,	/* ok to allocate new space */
 	xfs_inode_t	**ipp,		/* pointer to inode; it will be
@@ -1106,7 +1106,7 @@ xfs_create(
 	xfs_inode_t		*dp,
 	struct xfs_name		*name,
 	umode_t			mode,
-	xfs_dev_t		rdev,
+	dev_t			rdev,
 	xfs_inode_t		**ipp)
 {
 	int			is_dir = S_ISDIR(mode);
@@ -1143,7 +1143,6 @@ xfs_create(
 		return error;
 
 	if (is_dir) {
-		rdev = 0;
 		resblks = XFS_MKDIR_SPACE_RES(mp, name->len);
 		tres = &M_RES(mp)->tr_mkdir;
 	} else {
diff --git a/fs/xfs/xfs_inode.h b/fs/xfs/xfs_inode.h
index 472d1d9dcd6e..7148492ae857 100644
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@ -396,7 +396,7 @@ void		xfs_inactive(struct xfs_inode *ip);
 int		xfs_lookup(struct xfs_inode *dp, struct xfs_name *name,
 			   struct xfs_inode **ipp, struct xfs_name *ci_name);
 int		xfs_create(struct xfs_inode *dp, struct xfs_name *name,
-			   umode_t mode, xfs_dev_t rdev, struct xfs_inode **ipp);
+			   umode_t mode, dev_t rdev, struct xfs_inode **ipp);
 int		xfs_create_tmpfile(struct xfs_inode *dp, struct dentry *dentry,
 			   umode_t mode, struct xfs_inode **ipp);
 int		xfs_remove(struct xfs_inode *dp, struct xfs_name *name,
@@ -432,7 +432,7 @@ void		xfs_lock_two_inodes(xfs_inode_t *, xfs_inode_t *, uint);
 xfs_extlen_t	xfs_get_extsz_hint(struct xfs_inode *ip);
 
 int		xfs_dir_ialloc(struct xfs_trans **, struct xfs_inode *, umode_t,
-			       xfs_nlink_t, xfs_dev_t, prid_t, int,
+			       xfs_nlink_t, dev_t, prid_t, int,
 			       struct xfs_inode **, int *);
 
 /* from xfs_file.c */
diff --git a/fs/xfs/xfs_inode_item.c b/fs/xfs/xfs_inode_item.c
index ea0c762d4a3a..79db9fbab75b 100644
--- a/fs/xfs/xfs_inode_item.c
+++ b/fs/xfs/xfs_inode_item.c
@@ -222,7 +222,7 @@ xfs_inode_item_format_data_fork(
 		iip->ili_fields &=
 			~(XFS_ILOG_DDATA | XFS_ILOG_DBROOT | XFS_ILOG_DEXT);
 		if (iip->ili_fields & XFS_ILOG_DEV)
-			ilf->ilf_u.ilfu_rdev = ip->i_df.if_u2.if_rdev;
+			ilf->ilf_u.ilfu_rdev = sysv_encode_dev(VFS_I(ip)->i_rdev);
 		break;
 	default:
 		ASSERT(0);
diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c
index 97397367e04d..a15780121ecf 100644
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@ -161,7 +161,6 @@ xfs_generic_create(
 	if (S_ISCHR(mode) || S_ISBLK(mode)) {
 		if (unlikely(!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff))
 			return -EINVAL;
-		rdev = sysv_encode_dev(rdev);
 	} else {
 		rdev = 0;
 	}
@@ -525,8 +524,7 @@ xfs_vn_getattr(
 	case S_IFBLK:
 	case S_IFCHR:
 		stat->blksize = BLKDEV_IOSIZE;
-		stat->rdev = MKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,
-				   sysv_minor(ip->i_df.if_u2.if_rdev));
+		stat->rdev = inode->i_rdev;
 		break;
 	default:
 		if (XFS_IS_REALTIME_INODE(ip)) {
@@ -1257,18 +1255,6 @@ xfs_setup_inode(
 	inode->i_uid    = xfs_uid_to_kuid(ip->i_d.di_uid);
 	inode->i_gid    = xfs_gid_to_kgid(ip->i_d.di_gid);
 
-	switch (inode->i_mode & S_IFMT) {
-	case S_IFBLK:
-	case S_IFCHR:
-		inode->i_rdev =
-			MKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,
-			      sysv_minor(ip->i_df.if_u2.if_rdev));
-		break;
-	default:
-		inode->i_rdev = 0;
-		break;
-	}
-
 	i_size_write(inode, ip->i_d.di_size);
 	xfs_diflags_to_iflags(inode, ip);
 
diff --git a/fs/xfs/xfs_itable.c b/fs/xfs/xfs_itable.c
index 3c755ce36bed..e00e93c25c3b 100644
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@ -103,7 +103,7 @@ xfs_bulkstat_one_int(
 
 	switch (dic->di_format) {
 	case XFS_DINODE_FMT_DEV:
-		buf->bs_rdev = ip->i_df.if_u2.if_rdev;
+		buf->bs_rdev = sysv_encode_dev(inode->i_rdev);
 		buf->bs_blksize = BLKDEV_IOSIZE;
 		buf->bs_blocks = 0;
 		break;
