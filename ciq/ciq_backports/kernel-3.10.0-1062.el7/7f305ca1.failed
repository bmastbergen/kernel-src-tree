fuse: clean up fuse_writepage_in_flight()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 7f305ca1928d8b7db69f428b10988a3aa3e81053
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7f305ca1.failed

Restructure the function to better separate the locked and the unlocked
parts.  Use the "old_req" local variable to mean only the queued request,
and not any auxiliary requests added onto its misc.write.next list.  These
changes are in preparation for the following patch.

Also turn BUG_ON instances into WARN_ON and add a header comment explaining
what the function does.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 7f305ca1928d8b7db69f428b10988a3aa3e81053)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/file.c
diff --cc fs/fuse/file.c
index d851e606d416,8342df29815d..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -1782,10 -1758,8 +1789,13 @@@ static bool fuse_writepage_in_flight(st
  	struct fuse_inode *fi = get_fuse_inode(new_req->inode);
  	struct fuse_req *tmp;
  	struct fuse_req *old_req;
++<<<<<<< HEAD
 +	bool found = false;
 +	pgoff_t curr_index;
++=======
++>>>>>>> 7f305ca1928d (fuse: clean up fuse_writepage_in_flight())
  
- 	BUG_ON(new_req->num_pages != 0);
+ 	WARN_ON(new_req->num_pages != 0);
  
  	spin_lock(&fc->lock);
  	list_del(&new_req->writepages_entry);
@@@ -1805,35 -1772,35 +1815,56 @@@
  
  	new_req->num_pages = 1;
  	for (tmp = old_req; tmp != NULL; tmp = tmp->misc.write.next) {
++<<<<<<< HEAD
 +		BUG_ON(tmp->inode != new_req->inode);
 +		curr_index = tmp->misc.write.in.offset >> PAGE_CACHE_SHIFT;
 +		if (tmp->num_pages == 1 &&
 +		    curr_index == page->index) {
 +			old_req = tmp;
 +		}
 +	}
 +
 +	if (old_req->num_pages == 1 && (old_req->state == FUSE_REQ_INIT ||
 +					old_req->state == FUSE_REQ_PENDING)) {
 +		struct backing_dev_info *bdi = page->mapping->backing_dev_info;
++=======
+ 		pgoff_t curr_index;
  
- 		copy_highpage(old_req->pages[0], page);
- 		spin_unlock(&fc->lock);
+ 		WARN_ON(tmp->inode != new_req->inode);
+ 		curr_index = tmp->misc.write.in.offset >> PAGE_SHIFT;
+ 		if (tmp->num_pages == 1 && curr_index == page->index &&
+ 		    test_bit(FR_PENDING, &tmp->flags)) {
+ 			copy_highpage(tmp->pages[0], page);
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (!tmp) {
+ 		new_req->misc.write.next = old_req->misc.write.next;
+ 		old_req->misc.write.next = new_req;
+ 	}
++>>>>>>> 7f305ca1928d (fuse: clean up fuse_writepage_in_flight())
+ 
+ 	spin_unlock(&fc->lock);
+ 
+ 	if (tmp) {
+ 		struct backing_dev_info *bdi = inode_to_bdi(new_req->inode);
  
 -		dec_wb_stat(&bdi->wb, WB_WRITEBACK);
 -		dec_node_page_state(new_req->pages[0], NR_WRITEBACK_TEMP);
 -		wb_writeout_inc(&bdi->wb);
 +		dec_bdi_stat(bdi, BDI_WRITEBACK);
 +		dec_zone_page_state(page, NR_WRITEBACK_TEMP);
 +		bdi_writeout_inc(bdi);
  		fuse_writepage_free(fc, new_req);
  		fuse_request_free(new_req);
- 		goto out;
- 	} else {
- 		new_req->misc.write.next = old_req->misc.write.next;
- 		old_req->misc.write.next = new_req;
  	}
++<<<<<<< HEAD
 +out_unlock:
 +	spin_unlock(&fc->lock);
 +out:
 +	return found;
++=======
+ 
+ 	return true;
++>>>>>>> 7f305ca1928d (fuse: clean up fuse_writepage_in_flight())
  }
  
  static int fuse_writepages_fill(struct page *page,
* Unmerged path fs/fuse/file.c
