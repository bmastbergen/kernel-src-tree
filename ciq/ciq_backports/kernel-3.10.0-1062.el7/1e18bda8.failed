fuse: add .write_inode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 1e18bda86e2dcc4ecb176213ee34649c93ad1396
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/1e18bda8.failed

...and flush mtime from this.  This allows us to use the kernel
infrastructure for writing out dirty metadata (mtime at this point, but
ctime in the next patches and also maybe atime).

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit 1e18bda86e2dcc4ecb176213ee34649c93ad1396)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dir.c
#	fs/fuse/file.c
#	fs/fuse/fuse_i.h
diff --cc fs/fuse/dir.c
index 3e1c8cd01fea,8c233834591f..000000000000
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@@ -1645,6 -1576,57 +1645,60 @@@ void fuse_release_nowrite(struct inode 
  	spin_unlock(&fc->lock);
  }
  
++<<<<<<< HEAD
++=======
+ static void fuse_setattr_fill(struct fuse_conn *fc, struct fuse_req *req,
+ 			      struct inode *inode,
+ 			      struct fuse_setattr_in *inarg_p,
+ 			      struct fuse_attr_out *outarg_p)
+ {
+ 	req->in.h.opcode = FUSE_SETATTR;
+ 	req->in.h.nodeid = get_node_id(inode);
+ 	req->in.numargs = 1;
+ 	req->in.args[0].size = sizeof(*inarg_p);
+ 	req->in.args[0].value = inarg_p;
+ 	req->out.numargs = 1;
+ 	if (fc->minor < 9)
+ 		req->out.args[0].size = FUSE_COMPAT_ATTR_OUT_SIZE;
+ 	else
+ 		req->out.args[0].size = sizeof(*outarg_p);
+ 	req->out.args[0].value = outarg_p;
+ }
+ 
+ /*
+  * Flush inode->i_mtime to the server
+  */
+ int fuse_flush_mtime(struct inode *inode, struct fuse_file *ff)
+ {
+ 	struct fuse_conn *fc = get_fuse_conn(inode);
+ 	struct fuse_req *req;
+ 	struct fuse_setattr_in inarg;
+ 	struct fuse_attr_out outarg;
+ 	int err;
+ 
+ 	req = fuse_get_req_nopages(fc);
+ 	if (IS_ERR(req))
+ 		return PTR_ERR(req);
+ 
+ 	memset(&inarg, 0, sizeof(inarg));
+ 	memset(&outarg, 0, sizeof(outarg));
+ 
+ 	inarg.valid |= FATTR_MTIME;
+ 	inarg.mtime = inode->i_mtime.tv_sec;
+ 	inarg.mtimensec = inode->i_mtime.tv_nsec;
+ 	if (ff) {
+ 		inarg.valid |= FATTR_FH;
+ 		inarg.fh = ff->fh;
+ 	}
+ 	fuse_setattr_fill(fc, req, inode, &inarg, &outarg);
+ 	fuse_request_send(fc, req);
+ 	err = req->out.h.error;
+ 	fuse_put_request(fc, req);
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 1e18bda86e2d (fuse: add .write_inode)
  /*
   * Set attributes, and at the same time refresh them.
   *
@@@ -1733,6 -1706,12 +1787,15 @@@ int fuse_do_setattr(struct inode *inode
  	}
  
  	spin_lock(&fc->lock);
++<<<<<<< HEAD
++=======
+ 	/* the kernel maintains i_mtime locally */
+ 	if (trust_local_mtime && (attr->ia_valid & ATTR_MTIME)) {
+ 		inode->i_mtime = attr->ia_mtime;
+ 		/* FIXME: clear I_DIRTY_SYNC? */
+ 	}
+ 
++>>>>>>> 1e18bda86e2d (fuse: add .write_inode)
  	fuse_change_attributes_common(inode, &outarg.attr,
  				      attr_timeout(&outarg));
  	oldsize = inode->i_size;
@@@ -1963,8 -1942,18 +2026,23 @@@ static int fuse_removexattr(struct dent
  	return err;
  }
  
++<<<<<<< HEAD
 +static const struct inode_operations_wrapper fuse_dir_inode_operations = {
 +	.ops = {
++=======
+ static int fuse_update_time(struct inode *inode, struct timespec *now,
+ 			    int flags)
+ {
+ 	if (flags & S_MTIME) {
+ 		inode->i_mtime = *now;
+ 		mark_inode_dirty_sync(inode);
+ 		BUG_ON(!S_ISREG(inode->i_mode));
+ 	}
+ 	return 0;
+ }
+ 
+ static const struct inode_operations fuse_dir_inode_operations = {
++>>>>>>> 1e18bda86e2d (fuse: add .write_inode)
  	.lookup		= fuse_lookup,
  	.mkdir		= fuse_mkdir,
  	.symlink	= fuse_symlink,
diff --cc fs/fuse/file.c
index 109621a5f183,d228c3962ffd..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -318,6 -320,12 +318,15 @@@ static int fuse_open(struct inode *inod
  
  static int fuse_release(struct inode *inode, struct file *file)
  {
++<<<<<<< HEAD
++=======
+ 	struct fuse_conn *fc = get_fuse_conn(inode);
+ 
+ 	/* see fuse_vma_close() for !writeback_cache case */
+ 	if (fc->writeback_cache)
+ 		write_inode_now(inode, 1);
+ 
++>>>>>>> 1e18bda86e2d (fuse: add .write_inode)
  	fuse_release_common(file, FUSE_RELEASE);
  
  	/* return value is ignored by VFS */
@@@ -498,7 -499,13 +507,16 @@@ int fuse_fsync_common(struct file *file
  		goto out;
  
  	fuse_sync_writes(inode);
+ 	err = sync_inode_metadata(inode, 1);
+ 	if (err)
+ 		goto out;
  
++<<<<<<< HEAD
++=======
+ 	if ((!isdir && fc->no_fsync) || (isdir && fc->no_fsyncdir))
+ 		goto out;
+ 
++>>>>>>> 1e18bda86e2d (fuse: add .write_inode)
  	req = fuse_get_req_nopages(fc);
  	if (IS_ERR(req)) {
  		err = PTR_ERR(req);
diff --cc fs/fuse/fuse_i.h
index a6fe9fdc6997,d2f10054b9a1..000000000000
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@@ -900,7 -887,10 +900,14 @@@ long fuse_ioctl_common(struct file *fil
  unsigned fuse_file_poll(struct file *file, poll_table *wait);
  int fuse_dev_release(struct inode *inode, struct file *file);
  
++<<<<<<< HEAD
 +void fuse_write_update_size(struct inode *inode, loff_t pos);
++=======
+ bool fuse_write_update_size(struct inode *inode, loff_t pos);
+ 
+ int fuse_flush_mtime(struct inode *inode, struct fuse_file *ff);
+ int fuse_write_inode(struct inode *inode, struct writeback_control *wbc);
++>>>>>>> 1e18bda86e2d (fuse: add .write_inode)
  
  int fuse_do_setattr(struct inode *inode, struct iattr *attr,
  		    struct file *file);
* Unmerged path fs/fuse/dir.c
* Unmerged path fs/fuse/file.c
* Unmerged path fs/fuse/fuse_i.h
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index 4fc9c23e42fa..0fdca2fc887c 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -785,6 +785,7 @@ static const struct super_operations fuse_super_operations = {
 	.alloc_inode    = fuse_alloc_inode,
 	.destroy_inode  = fuse_destroy_inode,
 	.evict_inode	= fuse_evict_inode,
+	.write_inode	= fuse_write_inode,
 	.drop_inode	= generic_delete_inode,
 	.remount_fs	= fuse_remount_fs,
 	.put_super	= fuse_put_super,
