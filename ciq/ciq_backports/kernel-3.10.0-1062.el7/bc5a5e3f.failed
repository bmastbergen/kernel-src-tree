n_tty: Don't wrap input buffer indices at buffer size

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Peter Hurley <peter@hurleysoftware.com>
commit bc5a5e3f45d047844830233fb95b19a95c864a0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/bc5a5e3f.failed

Wrap read_buf indices (read_head, read_tail, canon_head) at
max representable value, instead of at the N_TTY_BUF_SIZE. This step
is necessary to allow lockless reads of these shared variables
(by updating the variables atomically).

	Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit bc5a5e3f45d047844830233fb95b19a95c864a0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/n_tty.c
diff --cc drivers/tty/n_tty.c
index 107aa433e80a,b2fef10a0c62..000000000000
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@@ -112,6 -115,21 +112,24 @@@ struct n_tty_data 
  	raw_spinlock_t read_lock;
  };
  
++<<<<<<< HEAD
++=======
+ static inline size_t read_cnt(struct n_tty_data *ldata)
+ {
+ 	return ldata->read_cnt;
+ }
+ 
+ static inline unsigned char read_buf(struct n_tty_data *ldata, size_t i)
+ {
+ 	return ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];
+ }
+ 
+ static inline unsigned char *read_buf_addr(struct n_tty_data *ldata, size_t i)
+ {
+ 	return &ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];
+ }
+ 
++>>>>>>> bc5a5e3f45d0 (n_tty: Don't wrap input buffer indices at buffer size)
  static inline int tty_put_user(struct tty_struct *tty, unsigned char x,
  			       unsigned char __user *ptr)
  {
@@@ -183,9 -195,9 +201,15 @@@ static void n_tty_set_room(struct tty_s
  
  static void put_tty_queue_nolock(unsigned char c, struct n_tty_data *ldata)
  {
++<<<<<<< HEAD
 +	if (ldata->read_cnt < N_TTY_BUF_SIZE) {
 +		ldata->read_buf[ldata->read_head] = c;
 +		ldata->read_head = (ldata->read_head + 1) & (N_TTY_BUF_SIZE-1);
++=======
+ 	if (read_cnt(ldata) < N_TTY_BUF_SIZE) {
+ 		*read_buf_addr(ldata, ldata->read_head) = c;
+ 		ldata->read_head++;
++>>>>>>> bc5a5e3f45d0 (n_tty: Don't wrap input buffer indices at buffer size)
  		ldata->read_cnt++;
  	}
  }
@@@ -287,13 -299,10 +311,20 @@@ static ssize_t chars_in_buffer(struct t
  	ssize_t n = 0;
  
  	raw_spin_lock_irqsave(&ldata->read_lock, flags);
++<<<<<<< HEAD
 +	if (!ldata->icanon) {
 +		n = ldata->read_cnt;
 +	} else if (ldata->canon_data) {
 +		n = (ldata->canon_head > ldata->read_tail) ?
 +			ldata->canon_head - ldata->read_tail :
 +			ldata->canon_head + (N_TTY_BUF_SIZE - ldata->read_tail);
 +	}
++=======
+ 	if (!ldata->icanon)
+ 		n = read_cnt(ldata);
+ 	else
+ 		n = ldata->canon_head - ldata->read_tail;
++>>>>>>> bc5a5e3f45d0 (n_tty: Don't wrap input buffer indices at buffer size)
  	raw_spin_unlock_irqrestore(&ldata->read_lock, flags);
  	return n;
  }
@@@ -1433,20 -1443,20 +1465,30 @@@ static void n_tty_receive_buf(struct tt
  
  	if (ldata->real_raw) {
  		raw_spin_lock_irqsave(&ldata->read_lock, cpuflags);
++<<<<<<< HEAD
 +		i = min(N_TTY_BUF_SIZE - ldata->read_cnt,
 +			N_TTY_BUF_SIZE - ldata->read_head);
++=======
+ 		i = min(N_TTY_BUF_SIZE - read_cnt(ldata),
+ 			N_TTY_BUF_SIZE - (ldata->read_head & (N_TTY_BUF_SIZE - 1)));
++>>>>>>> bc5a5e3f45d0 (n_tty: Don't wrap input buffer indices at buffer size)
  		i = min(count, i);
- 		memcpy(ldata->read_buf + ldata->read_head, cp, i);
- 		ldata->read_head = (ldata->read_head + i) & (N_TTY_BUF_SIZE-1);
+ 		memcpy(read_buf_addr(ldata, ldata->read_head), cp, i);
+ 		ldata->read_head += i;
  		ldata->read_cnt += i;
  		cp += i;
  		count -= i;
  
++<<<<<<< HEAD
 +		i = min(N_TTY_BUF_SIZE - ldata->read_cnt,
 +			N_TTY_BUF_SIZE - ldata->read_head);
++=======
+ 		i = min(N_TTY_BUF_SIZE - read_cnt(ldata),
+ 			N_TTY_BUF_SIZE - (ldata->read_head & (N_TTY_BUF_SIZE - 1)));
++>>>>>>> bc5a5e3f45d0 (n_tty: Don't wrap input buffer indices at buffer size)
  		i = min(count, i);
- 		memcpy(ldata->read_buf + ldata->read_head, cp, i);
- 		ldata->read_head = (ldata->read_head + i) & (N_TTY_BUF_SIZE-1);
+ 		memcpy(read_buf_addr(ldata, ldata->read_head), cp, i);
+ 		ldata->read_head += i;
  		ldata->read_cnt += i;
  		raw_spin_unlock_irqrestore(&ldata->read_lock, cpuflags);
  	} else {
@@@ -1720,21 -1751,20 +1763,24 @@@ static int copy_from_read_buf(struct tt
  
  	retval = 0;
  	raw_spin_lock_irqsave(&ldata->read_lock, flags);
++<<<<<<< HEAD
 +	n = min(ldata->read_cnt, N_TTY_BUF_SIZE - ldata->read_tail);
++=======
+ 	n = min(read_cnt(ldata), N_TTY_BUF_SIZE - tail);
++>>>>>>> bc5a5e3f45d0 (n_tty: Don't wrap input buffer indices at buffer size)
  	n = min(*nr, n);
  	raw_spin_unlock_irqrestore(&ldata->read_lock, flags);
  	if (n) {
- 		retval = copy_to_user(*b, &ldata->read_buf[ldata->read_tail], n);
+ 		retval = copy_to_user(*b, read_buf_addr(ldata, tail), n);
  		n -= retval;
- 		is_eof = n == 1 &&
- 			ldata->read_buf[ldata->read_tail] == EOF_CHAR(tty);
- 		tty_audit_add_data(tty, &ldata->read_buf[ldata->read_tail], n,
+ 		is_eof = n == 1 && read_buf(ldata, tail) == EOF_CHAR(tty);
+ 		tty_audit_add_data(tty, read_buf_addr(ldata, tail), n,
  				ldata->icanon);
  		raw_spin_lock_irqsave(&ldata->read_lock, flags);
- 		ldata->read_tail = (ldata->read_tail + n) & (N_TTY_BUF_SIZE-1);
+ 		ldata->read_tail += n;
  		ldata->read_cnt -= n;
  		/* Turn single EOF into zero-length read */
 -		if (L_EXTPROC(tty) && ldata->icanon && is_eof && !read_cnt(ldata))
 +		if (L_EXTPROC(tty) && ldata->icanon && is_eof && !ldata->read_cnt)
  			n = 0;
  		raw_spin_unlock_irqrestore(&ldata->read_lock, flags);
  		*b += n;
* Unmerged path drivers/tty/n_tty.c
