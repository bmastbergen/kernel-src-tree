perf/core: Fix perf_pmu_unregister() locking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit a9f9772114c8b07ae75bcb3654bd017461248095
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a9f97721.failed

When we unregister a PMU, we fail to serialize the @pmu_idr properly.
Fix that by doing the entire thing under pmu_lock.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
Fixes: 2e80a82a49c4 ("perf: Dynamic pmu types")
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a9f9772114c8b07ae75bcb3654bd017461248095)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/core.c
diff --cc kernel/events/core.c
index 49e3e6f05f32,dfb1d951789e..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -9069,38 -9421,17 +9069,42 @@@ static struct perf_cpu_context __percp
  	return NULL;
  }
  
 +static void update_pmu_context(struct pmu *pmu, struct pmu *old_pmu)
 +{
 +	int cpu;
 +
 +	for_each_possible_cpu(cpu) {
 +		struct perf_cpu_context *cpuctx;
 +
 +		cpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);
 +
 +		if (cpuctx->unique_pmu == old_pmu)
 +			cpuctx->unique_pmu = pmu;
 +	}
 +}
 +
  static void free_pmu_context(struct pmu *pmu)
  {
 +	struct pmu *i;
 +
++<<<<<<< HEAD
 +	mutex_lock(&pmus_lock);
  	/*
 -	 * Static contexts such as perf_sw_context have a global lifetime
 -	 * and may be shared between different PMUs. Avoid freeing them
 -	 * when a single PMU is going away.
 +	 * Like a real lame refcount.
  	 */
 -	if (pmu->task_ctx_nr > perf_invalid_context)
 -		return;
 +	list_for_each_entry(i, &pmus, entry) {
 +		if (i->pmu_cpu_context == pmu->pmu_cpu_context) {
 +			update_pmu_context(i, pmu);
 +			goto out;
 +		}
 +	}
  
  	free_percpu(pmu->pmu_cpu_context);
 +out:
 +	mutex_unlock(&pmus_lock);
++=======
++	free_percpu(pmu->pmu_cpu_context);
++>>>>>>> a9f9772114c8 (perf/core: Fix perf_pmu_unregister() locking)
  }
  
  /*
* Unmerged path kernel/events/core.c
