ovl: grab reference to workbasedir early

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 95e6d4177cb7a2d7a760180e13f32adaf4188833
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/95e6d417.failed

and related cleanups.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 95e6d4177cb7a2d7a760180e13f32adaf4188833)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index 19e9eb0f1d4f,255c0523148f..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -870,6 -827,305 +870,308 @@@ static const struct xattr_handler *ovl_
  	NULL
  };
  
++<<<<<<< HEAD
++=======
+ static int ovl_get_upperpath(struct ovl_fs *ufs, struct path *upperpath)
+ {
+ 	int err;
+ 
+ 	err = ovl_mount_dir(ufs->config.upperdir, upperpath);
+ 	if (err)
+ 		goto out;
+ 
+ 	/* Upper fs should not be r/o */
+ 	if (sb_rdonly(upperpath->mnt->mnt_sb)) {
+ 		pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	err = ovl_check_namelen(upperpath, ufs, ufs->config.upperdir);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = -EBUSY;
+ 	if (ovl_inuse_trylock(upperpath->dentry)) {
+ 		ufs->upperdir_locked = true;
+ 	} else if (ufs->config.index) {
+ 		pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
+ 		goto out;
+ 	} else {
+ 		pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
+ 	}
+ 	err = 0;
+ out:
+ 	return err;
+ }
+ 
+ static int ovl_get_workpath(struct ovl_fs *ufs, struct path *upperpath,
+ 			    struct path *workpath)
+ {
+ 	int err;
+ 
+ 	err = ovl_mount_dir(ufs->config.workdir, workpath);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = -EINVAL;
+ 	if (upperpath->mnt != workpath->mnt) {
+ 		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
+ 		goto out;
+ 	}
+ 	if (!ovl_workdir_ok(workpath->dentry, upperpath->dentry)) {
+ 		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
+ 		goto out;
+ 	}
+ 
+ 	err = -EBUSY;
+ 	if (ovl_inuse_trylock(workpath->dentry)) {
+ 		ufs->workdir_locked = true;
+ 	} else if (ufs->config.index) {
+ 		pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
+ 		goto out;
+ 	} else {
+ 		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
+ 	}
+ 
+ 	ufs->workbasedir = dget(workpath->dentry);
+ 	err = 0;
+ out:
+ 	return err;
+ }
+ 
+ static int ovl_get_upper(struct ovl_fs *ufs, struct path *upperpath)
+ {
+ 	struct vfsmount *upper_mnt;
+ 
+ 	upper_mnt = clone_private_mount(upperpath);
+ 	if (IS_ERR(upper_mnt)) {
+ 		pr_err("overlayfs: failed to clone upperpath\n");
+ 		return PTR_ERR(upper_mnt);
+ 	}
+ 
+ 	/* Don't inherit atime flags */
+ 	upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
+ 	ufs->upper_mnt = upper_mnt;
+ 
+ 	return 0;
+ }
+ 
+ static int ovl_get_workdir(struct super_block *sb, struct ovl_fs *ufs,
+ 			   struct path *workpath)
+ {
+ 	struct dentry *temp;
+ 	int err;
+ 
+ 	ufs->workdir = ovl_workdir_create(sb, ufs, ufs->workbasedir,
+ 					  OVL_WORKDIR_NAME, false);
+ 	if (!ufs->workdir)
+ 		return 0;
+ 
+ 	/*
+ 	 * Upper should support d_type, else whiteouts are visible.  Given
+ 	 * workdir and upper are on same fs, we can do iterate_dir() on
+ 	 * workdir. This check requires successful creation of workdir in
+ 	 * previous step.
+ 	 */
+ 	err = ovl_check_d_type_supported(workpath);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/*
+ 	 * We allowed this configuration and don't want to break users over
+ 	 * kernel upgrade. So warn instead of erroring out.
+ 	 */
+ 	if (!err)
+ 		pr_warn("overlayfs: upper fs needs to support d_type.\n");
+ 
+ 	/* Check if upper/work fs supports O_TMPFILE */
+ 	temp = ovl_do_tmpfile(ufs->workdir, S_IFREG | 0);
+ 	ufs->tmpfile = !IS_ERR(temp);
+ 	if (ufs->tmpfile)
+ 		dput(temp);
+ 	else
+ 		pr_warn("overlayfs: upper fs does not support tmpfile.\n");
+ 
+ 	/*
+ 	 * Check if upper/work fs supports trusted.overlay.* xattr
+ 	 */
+ 	err = ovl_do_setxattr(ufs->workdir, OVL_XATTR_OPAQUE, "0", 1, 0);
+ 	if (err) {
+ 		ufs->noxattr = true;
+ 		pr_warn("overlayfs: upper fs does not support xattr.\n");
+ 	} else {
+ 		vfs_removexattr(ufs->workdir, OVL_XATTR_OPAQUE);
+ 	}
+ 
+ 	/* Check if upper/work fs supports file handles */
+ 	if (ufs->config.index &&
+ 	    !ovl_can_decode_fh(ufs->workdir->d_sb)) {
+ 		ufs->config.index = false;
+ 		pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int ovl_get_indexdir(struct super_block *sb, struct ovl_fs *ufs,
+ 			    struct ovl_entry *oe,
+ 			    struct path *upperpath)
+ {
+ 	int err;
+ 
+ 	/* Verify lower root is upper root origin */
+ 	err = ovl_verify_origin(upperpath->dentry,
+ 				oe->lowerstack[0].layer->mnt,
+ 				oe->lowerstack[0].dentry,
+ 				false, true);
+ 	if (err) {
+ 		pr_err("overlayfs: failed to verify upper root origin\n");
+ 		goto out;
+ 	}
+ 
+ 	ufs->indexdir = ovl_workdir_create(sb, ufs, ufs->workbasedir,
+ 					   OVL_INDEXDIR_NAME, true);
+ 	if (ufs->indexdir) {
+ 		/* Verify upper root is index dir origin */
+ 		err = ovl_verify_origin(ufs->indexdir, ufs->upper_mnt,
+ 					upperpath->dentry, true, true);
+ 		if (err)
+ 			pr_err("overlayfs: failed to verify index dir origin\n");
+ 
+ 		/* Cleanup bad/stale/orphan index entries */
+ 		if (!err)
+ 			err = ovl_indexdir_cleanup(ufs->indexdir,
+ 						   ufs->upper_mnt,
+ 						   oe->lowerstack,
+ 						   oe->numlower);
+ 	}
+ 	if (err || !ufs->indexdir)
+ 		pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
+ 
+ out:
+ 	return err;
+ }
+ 
+ static int ovl_get_lowerstack(struct super_block *sb, struct ovl_fs *ufs,
+ 			      struct path **stackp, unsigned int *stacklenp)
+ {
+ 	int err;
+ 	char *lowertmp, *lower;
+ 	struct path *stack;
+ 	unsigned int stacklen, numlower, i;
+ 	bool remote = false;
+ 
+ 	err = -ENOMEM;
+ 	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
+ 	if (!lowertmp)
+ 		goto out;
+ 
+ 	err = -EINVAL;
+ 	stacklen = ovl_split_lowerdirs(lowertmp);
+ 	if (stacklen > OVL_MAX_STACK) {
+ 		pr_err("overlayfs: too many lower directories, limit is %d\n",
+ 		       OVL_MAX_STACK);
+ 		goto out;
+ 	} else if (!ufs->config.upperdir && stacklen == 1) {
+ 		pr_err("overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n");
+ 		goto out;
+ 	}
+ 
+ 	err = -ENOMEM;
+ 	stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);
+ 	if (!stack)
+ 		goto out;
+ 
+ 	err = -EINVAL;
+ 	lower = lowertmp;
+ 	for (numlower = 0; numlower < stacklen; numlower++) {
+ 		err = ovl_lower_dir(lower, &stack[numlower], ufs,
+ 				    &sb->s_stack_depth, &remote);
+ 		if (err)
+ 			goto out_free_stack;
+ 
+ 		lower = strchr(lower, '\0') + 1;
+ 	}
+ 
+ 	err = -EINVAL;
+ 	sb->s_stack_depth++;
+ 	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
+ 		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
+ 		goto out_free_stack;
+ 	}
+ 
+ 	*stackp = stack;
+ 	*stacklenp = numlower;
+ 
+ 	if (remote)
+ 		sb->s_d_op = &ovl_reval_dentry_operations;
+ 	else
+ 		sb->s_d_op = &ovl_dentry_operations;
+ 
+ 	err = 0;
+ 
+ out:
+ 	kfree(lowertmp);
+ 	return err;
+ 
+ out_free_stack:
+ 	for (i = 0; i < numlower; i++)
+ 		path_put(&stack[i]);
+ 	kfree(stack);
+ 	goto out;
+ }
+ 
+ static int ovl_get_lower_layers(struct ovl_fs *ufs, struct path *stack,
+ 				unsigned int numlower)
+ {
+ 	int err;
+ 	unsigned int i;
+ 
+ 	err = -ENOMEM;
+ 	ufs->lower_layers = kcalloc(numlower, sizeof(struct ovl_layer),
+ 				    GFP_KERNEL);
+ 	if (ufs->lower_layers == NULL)
+ 		goto out;
+ 	for (i = 0; i < numlower; i++) {
+ 		struct vfsmount *mnt;
+ 		dev_t dev;
+ 
+ 		err = get_anon_bdev(&dev);
+ 		if (err) {
+ 			pr_err("overlayfs: failed to get anonymous bdev for lowerpath\n");
+ 			goto out;
+ 		}
+ 
+ 		mnt = clone_private_mount(&stack[i]);
+ 		err = PTR_ERR(mnt);
+ 		if (IS_ERR(mnt)) {
+ 			pr_err("overlayfs: failed to clone lowerpath\n");
+ 			free_anon_bdev(dev);
+ 			goto out;
+ 		}
+ 		/*
+ 		 * Make lower layers R/O.  That way fchmod/fchown on lower file
+ 		 * will fail instead of modifying lower fs.
+ 		 */
+ 		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
+ 
+ 		ufs->lower_layers[ufs->numlower].mnt = mnt;
+ 		ufs->lower_layers[ufs->numlower].pseudo_dev = dev;
+ 		ufs->numlower++;
+ 
+ 		/* Check if all lower layers are on same sb */
+ 		if (i == 0)
+ 			ufs->same_sb = mnt->mnt_sb;
+ 		else if (ufs->same_sb != mnt->mnt_sb)
+ 			ufs->same_sb = NULL;
+ 	}
+ 	err = 0;
+ out:
+ 	return err;
+ }
+ 
++>>>>>>> 95e6d4177cb7 (ovl: grab reference to workbasedir early)
  static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
  	struct path upperpath = { };
@@@ -1119,32 -1201,18 +1421,36 @@@
  	else if (ufs->upper_mnt->mnt_sb != ufs->same_sb)
  		ufs->same_sb = NULL;
  
 -	err = -ENOMEM;
 -	oe = ovl_alloc_entry(numlower);
 -	if (!oe)
 -		goto out_put_lower_layers;
 +	if (!(ovl_force_readonly(ufs)) && ufs->config.index) {
++<<<<<<< HEAD
 +		/* Verify lower root is upper root origin */
 +		err = ovl_verify_origin(upperpath.dentry, ufs->lower_mnt[0],
 +					stack[0].dentry, false, true);
 +		if (err) {
 +			pr_err("overlayfs: failed to verify upper root origin\n");
 +			goto out_put_lower_mnt;
 +		}
  
 -	for (i = 0; i < numlower; i++) {
 -		oe->lowerstack[i].dentry = stack[i].dentry;
 -		oe->lowerstack[i].layer = &(ufs->lower_layers[i]);
 -	}
 +		ufs->indexdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 +						   OVL_INDEXDIR_NAME, true);
 +		if (ufs->indexdir) {
 +			/* Verify upper root is index dir origin */
 +			err = ovl_verify_origin(ufs->indexdir, ufs->upper_mnt,
 +						upperpath.dentry, true, true);
 +			if (err)
 +				pr_err("overlayfs: failed to verify index dir origin\n");
  
 -	if (!(ovl_force_readonly(ufs)) && ufs->config.index) {
 +			/* Cleanup bad/stale/orphan index entries */
 +			if (!err)
 +				err = ovl_indexdir_cleanup(ufs->indexdir,
 +							   ufs->upper_mnt,
 +							   stack, numlower);
 +		}
 +		if (err || !ufs->indexdir)
 +			pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
++=======
+ 		err = ovl_get_indexdir(sb, ufs, oe, &upperpath);
++>>>>>>> 95e6d4177cb7 (ovl: grab reference to workbasedir early)
  		if (err)
  			goto out_put_indexdir;
  	}
@@@ -1184,8 -1242,8 +1490,13 @@@
  	mntput(upperpath.mnt);
  	for (i = 0; i < numlower; i++)
  		mntput(stack[i].mnt);
++<<<<<<< HEAD
 +	mntput(workpath.mnt);
 +	kfree(lowertmp);
++=======
+ 	kfree(stack);
+ 	path_put(&workpath);
++>>>>>>> 95e6d4177cb7 (ovl: grab reference to workbasedir early)
  
  	if (upperpath.dentry) {
  		oe->has_upper = true;
@@@ -1226,12 -1281,10 +1537,17 @@@ out_put_lowerpath
  	for (i = 0; i < numlower; i++)
  		path_put(&stack[i]);
  	kfree(stack);
 +out_free_lowertmp:
 +	kfree(lowertmp);
  out_unlock_workdentry:
  	if (ufs->workdir_locked)
++<<<<<<< HEAD
 +		ovl_inuse_unlock(workpath.dentry);
 +out_put_workpath:
++=======
+ 		ovl_inuse_unlock(ufs->workbasedir);
+ 	dput(ufs->workbasedir);
++>>>>>>> 95e6d4177cb7 (ovl: grab reference to workbasedir early)
  	path_put(&workpath);
  out_unlock_upperdentry:
  	if (ufs->upperdir_locked)
* Unmerged path fs/overlayfs/super.c
