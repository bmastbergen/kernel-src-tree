RCU, workqueue: Implement rcu_work

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Tejun Heo <tj@kernel.org>
commit 05f0fe6b74dbd7690a4cbd61810948b7d575576a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/05f0fe6b.failed

There are cases where RCU callback needs to be bounced to a sleepable
context.  This is currently done by the RCU callback queueing a work
item, which can be cumbersome to write and confusing to read.

This patch introduces rcu_work, a workqueue work variant which gets
executed after a RCU grace period, and converts the open coded
bouncing in fs/aio and kernel/cgroup.

v3: Dropped queue_rcu_work_on().  Documented rcu grace period behavior
    after queue_rcu_work().

v2: Use rcu_barrier() instead of synchronize_rcu() to wait for
    completion of previously queued rcu callback as per Paul.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Acked-by: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 05f0fe6b74dbd7690a4cbd61810948b7d575576a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/workqueue.h
#	kernel/workqueue.c
diff --cc include/linux/workqueue.h
index fe516e9255b5,d026f8f818cc..000000000000
--- a/include/linux/workqueue.h
+++ b/include/linux/workqueue.h
@@@ -119,18 -121,38 +120,31 @@@ struct delayed_work 
  	int cpu;
  };
  
++<<<<<<< HEAD
 +/*
 + * A struct for workqueue attributes.  This can be used to change
 + * attributes of an unbound workqueue.
++=======
+ struct rcu_work {
+ 	struct work_struct work;
+ 	struct rcu_head rcu;
+ 
+ 	/* target workqueue ->rcu uses to queue ->work */
+ 	struct workqueue_struct *wq;
+ };
+ 
+ /**
+  * struct workqueue_attrs - A struct for workqueue attributes.
++>>>>>>> 05f0fe6b74db (RCU, workqueue: Implement rcu_work)
   *
 - * This can be used to change attributes of an unbound workqueue.
 + * Unlike other fields, ->no_numa isn't a property of a worker_pool.  It
 + * only modifies how apply_workqueue_attrs() select pools and thus doesn't
 + * participate in pool hash calculations or equality comparisons.
   */
  struct workqueue_attrs {
 -	/**
 -	 * @nice: nice level
 -	 */
 -	int nice;
 -
 -	/**
 -	 * @cpumask: allowed CPUs
 -	 */
 -	cpumask_var_t cpumask;
 -
 -	/**
 -	 * @no_numa: disable NUMA affinity
 -	 *
 -	 * Unlike other fields, ``no_numa`` isn't a property of a worker_pool. It
 -	 * only modifies how :c:func:`apply_workqueue_attrs` select pools and thus
 -	 * doesn't participate in pool hash calculations or equality comparisons.
 -	 */
 -	bool no_numa;
 +	int			nice;		/* nice level */
 +	cpumask_var_t		cpumask;	/* allowed CPUs */
 +	bool			no_numa;	/* disable NUMA affinity */
  };
  
  static inline struct delayed_work *to_delayed_work(struct work_struct *work)
diff --cc kernel/workqueue.c
index ddaafa97bdb8,7df85fa9f651..000000000000
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@@ -3024,6 -3035,51 +3058,54 @@@ bool flush_delayed_work(struct delayed_
  }
  EXPORT_SYMBOL(flush_delayed_work);
  
++<<<<<<< HEAD
++=======
+ /**
+  * flush_rcu_work - wait for a rwork to finish executing the last queueing
+  * @rwork: the rcu work to flush
+  *
+  * Return:
+  * %true if flush_rcu_work() waited for the work to finish execution,
+  * %false if it was already idle.
+  */
+ bool flush_rcu_work(struct rcu_work *rwork)
+ {
+ 	if (test_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(&rwork->work))) {
+ 		rcu_barrier();
+ 		flush_work(&rwork->work);
+ 		return true;
+ 	} else {
+ 		return flush_work(&rwork->work);
+ 	}
+ }
+ EXPORT_SYMBOL(flush_rcu_work);
+ 
+ static bool __cancel_work(struct work_struct *work, bool is_dwork)
+ {
+ 	unsigned long flags;
+ 	int ret;
+ 
+ 	do {
+ 		ret = try_to_grab_pending(work, is_dwork, &flags);
+ 	} while (unlikely(ret == -EAGAIN));
+ 
+ 	if (unlikely(ret < 0))
+ 		return false;
+ 
+ 	set_work_pool_and_clear_pending(work, get_work_pool_id(work));
+ 	local_irq_restore(flags);
+ 	return ret;
+ }
+ 
+ /*
+  * See cancel_delayed_work()
+  */
+ bool cancel_work(struct work_struct *work)
+ {
+ 	return __cancel_work(work, false);
+ }
+ 
++>>>>>>> 05f0fe6b74db (RCU, workqueue: Implement rcu_work)
  /**
   * cancel_delayed_work - cancel a delayed work
   * @dwork: delayed_work to cancel
* Unmerged path include/linux/workqueue.h
* Unmerged path kernel/workqueue.c
