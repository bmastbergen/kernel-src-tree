s390/bpf: fix recache skb->data/hlen for skb_vlan_push/pop

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [s390] bpf: fix recache skb->data/hlen for skb_vlan_push/pop (Jiri Olsa) [1657679]
Rebuild_FUZZ: 95.50%
commit-author Michael Holzheu <holzheu@linux.vnet.ibm.com>
commit 6edf0aa4f8bbdfbb4d6d786892fa02728d05dc36
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6edf0aa4.failed

In case of usage of skb_vlan_push/pop, in the prologue we store
the SKB pointer on the stack and restore it after BPF_JMP_CALL
to skb_vlan_push/pop.

Unfortunately currently there are two bugs in the code:

 1) The wrong stack slot (offset 170 instead of 176) is used
 2) The wrong register (W1 instead of B1) is saved

So fix this and use correct stack slot and register.

Fixes: 9db7f2b81880 ("s390/bpf: recache skb->data/hlen for skb_vlan_push/pop")
	Cc: stable@vger.kernel.org # 4.3+
	Signed-off-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 6edf0aa4f8bbdfbb4d6d786892fa02728d05dc36)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/net/bpf_jit.h
#	arch/s390/net/bpf_jit_comp.c
diff --cc arch/s390/net/bpf_jit_comp.c
index 15be4f92e665,bee281f3163d..000000000000
--- a/arch/s390/net/bpf_jit_comp.c
+++ b/arch/s390/net/bpf_jit_comp.c
@@@ -186,29 -429,34 +186,38 @@@ static void bpf_jit_prologue(struct bpf
  	/* Setup literal pool */
  	if (jit->seen & SEEN_LITERAL) {
  		/* basr %r13,0 */
 -		EMIT2(0x0d00, REG_L, REG_0);
 +		EMIT2(0x0dd0);
  		jit->base_ip = jit->prg;
  	}
 -	/* Setup stack and backchain */
 -	if (jit->seen & SEEN_STACK) {
 -		if (jit->seen & SEEN_FUNC)
 -			/* lgr %w1,%r15 (backchain) */
 -			EMIT4(0xb9040000, REG_W1, REG_15);
 -		/* la %bfp,STK_160_UNUSED(%r15) (BPF frame pointer) */
 -		EMIT4_DISP(0x41000000, BPF_REG_FP, REG_15, STK_160_UNUSED);
 -		/* aghi %r15,-STK_OFF */
 -		EMIT4_IMM(0xa70b0000, REG_15, -STK_OFF);
 -		if (jit->seen & SEEN_FUNC)
 -			/* stg %w1,152(%r15) (backchain) */
 -			EMIT6_DISP_LH(0xe3000000, 0x0024, REG_W1, REG_0,
 -				      REG_15, 152);
 +	jit->off_load_word = EMIT_FN_CONST(SEEN_LOAD_WORD, sk_load_word);
 +	jit->off_load_half = EMIT_FN_CONST(SEEN_LOAD_HALF, sk_load_half);
 +	jit->off_load_byte = EMIT_FN_CONST(SEEN_LOAD_BYTE, sk_load_byte);
 +	jit->off_load_bmsh = EMIT_FN_CONST(SEEN_LOAD_BMSH, sk_load_byte_msh);
 +	jit->off_load_iword = EMIT_FN_CONST(SEEN_LOAD_IWORD, sk_load_word_ind);
 +	jit->off_load_ihalf = EMIT_FN_CONST(SEEN_LOAD_IHALF, sk_load_half_ind);
 +	jit->off_load_ibyte = EMIT_FN_CONST(SEEN_LOAD_IBYTE, sk_load_byte_ind);
 +
 +	/* Filter needs to access skb data */
 +	if (jit->seen & SEEN_DATAREF) {
 +		/* l %r11,<len>(%r2) */
 +		EMIT4_DISP(0x58b02000, offsetof(struct sk_buff, len));
 +		/* s %r11,<data_len>(%r2) */
 +		EMIT4_DISP(0x5bb02000, offsetof(struct sk_buff, data_len));
 +		/* lg %r10,<data>(%r2) */
 +		EMIT6_DISP(0xe3a02000, 0x0004,
 +			   offsetof(struct sk_buff, data));
  	}
++<<<<<<< HEAD
++=======
+ 	if (jit->seen & SEEN_SKB)
+ 		emit_load_skb_data_hlen(jit);
+ 	if (jit->seen & SEEN_SKB_CHANGE)
+ 		/* stg %b1,ST_OFF_SKBP(%r0,%r15) */
+ 		EMIT6_DISP_LH(0xe3000000, 0x0024, BPF_REG_1, REG_0, REG_15,
+ 			      STK_OFF_SKBP);
++>>>>>>> 6edf0aa4f8bb (s390/bpf: fix recache skb->data/hlen for skb_vlan_push/pop)
  }
  
 -/*
 - * Function epilogue
 - */
  static void bpf_jit_epilogue(struct bpf_jit *jit)
  {
  	/* Return 0 */
* Unmerged path arch/s390/net/bpf_jit.h
* Unmerged path arch/s390/net/bpf_jit.h
* Unmerged path arch/s390/net/bpf_jit_comp.c
