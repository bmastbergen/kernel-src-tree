vfs: add flags to d_real()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 495e642939114478a5237a7d91661ba93b76f15a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/495e6429.failed

Add a separate flags argument (in addition to the open flags) to control
the behavior of d_real().

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 495e642939114478a5237a7d91661ba93b76f15a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/open.c
#	include/linux/dcache.h
#	include/linux/fs.h
diff --cc fs/open.c
index 877b114748a0,6d5c9a9b8c8d..000000000000
--- a/fs/open.c
+++ b/fs/open.c
@@@ -850,6 -842,30 +850,33 @@@ int finish_no_open(struct file *file, s
  }
  EXPORT_SYMBOL(finish_no_open);
  
++<<<<<<< HEAD
++=======
+ char *file_path(struct file *filp, char *buf, int buflen)
+ {
+ 	return d_path(&filp->f_path, buf, buflen);
+ }
+ EXPORT_SYMBOL(file_path);
+ 
+ /**
+  * vfs_open - open the file at the given path
+  * @path: path to open
+  * @file: newly allocated file with f_flag initialized
+  * @cred: credentials to use
+  */
+ int vfs_open(const struct path *path, struct file *file,
+ 	     const struct cred *cred)
+ {
+ 	struct dentry *dentry = d_real(path->dentry, NULL, file->f_flags, 0);
+ 
+ 	if (IS_ERR(dentry))
+ 		return PTR_ERR(dentry);
+ 
+ 	file->f_path = *path;
+ 	return do_dentry_open(file, d_backing_inode(dentry), NULL, cred);
+ }
+ 
++>>>>>>> 495e64293911 (vfs: add flags to d_real())
  struct file *dentry_open(const struct path *path, int flags,
  			 const struct cred *cred)
  {
diff --cc include/linux/dcache.h
index d021d2f76e5c,fd0721e520f4..000000000000
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@@ -157,18 -145,9 +157,18 @@@ struct dentry_operations 
  	void (*d_iput)(struct dentry *, struct inode *);
  	char *(*d_dname)(struct dentry *, char *, int);
  	struct vfsmount *(*d_automount)(struct path *);
 -	int (*d_manage)(const struct path *, bool);
 +	RH_KABI_REPLACE(int (*d_manage)(struct dentry *, bool),
 +			int (*d_manage)(const struct path *, bool))
 +} ____cacheline_aligned;
 +
 +typedef struct dentry* (*dop_real_t) (struct dentry *, const struct inode *, unsigned int);
 +
 +struct dentry_operations_wrapper {
 +	struct dentry_operations ops;
 +	size_t size;
 +
  	struct dentry *(*d_real)(struct dentry *, const struct inode *,
- 				 unsigned int);
+ 				 unsigned int, unsigned int);
  } ____cacheline_aligned;
  
  /*
@@@ -570,9 -562,44 +570,47 @@@ static inline struct dentry *d_backing_
  	return upper;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * d_real - Return the real dentry
+  * @dentry: the dentry to query
+  * @inode: inode to select the dentry from multiple layers (can be NULL)
+  * @open_flags: open flags to control copy-up behavior
+  * @flags: flags to control what is returned by this function
+  *
+  * If dentry is on a union/overlay, then return the underlying, real dentry.
+  * Otherwise return the dentry itself.
+  *
+  * See also: Documentation/filesystems/vfs.txt
+  */
+ static inline struct dentry *d_real(struct dentry *dentry,
+ 				    const struct inode *inode,
+ 				    unsigned int open_flags, unsigned int flags)
+ {
+ 	if (unlikely(dentry->d_flags & DCACHE_OP_REAL))
+ 		return dentry->d_op->d_real(dentry, inode, open_flags, flags);
+ 	else
+ 		return dentry;
+ }
+ 
+ /**
+  * d_real_inode - Return the real inode
+  * @dentry: The dentry to query
+  *
+  * If dentry is on a union/overlay, then return the underlying, real inode.
+  * Otherwise return d_inode().
+  */
+ static inline struct inode *d_real_inode(const struct dentry *dentry)
+ {
+ 	/* This usage of d_real() results in const dentry */
+ 	return d_backing_inode(d_real((struct dentry *) dentry, NULL, 0, 0));
+ }
+ 
++>>>>>>> 495e64293911 (vfs: add flags to d_real())
  struct name_snapshot {
 -	const unsigned char *name;
 -	unsigned char inline_name[DNAME_INLINE_LEN];
 +	const char *name;
 +	char inline_name[DNAME_INLINE_LEN];
  };
  void take_dentry_name_snapshot(struct name_snapshot *, struct dentry *);
  void release_dentry_name_snapshot(struct name_snapshot *);
diff --cc include/linux/fs.h
index 8faf318cc440,ee1db83c39cb..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -1354,14 -1231,9 +1354,18 @@@ static inline struct inode *file_inode(
  	return f->f_inode;
  }
  
 -static inline struct dentry *file_dentry(const struct file *file)
 +static inline int posix_lock_file_wait(struct file *filp, struct file_lock *fl)
  {
++<<<<<<< HEAD
 +	return posix_lock_inode_wait(locks_inode(filp), fl);
 +}
 +
 +static inline int flock_lock_file_wait(struct file *filp, struct file_lock *fl)
 +{
 +	return flock_lock_inode_wait(locks_inode(filp), fl);
++=======
+ 	return d_real(file->f_path.dentry, file_inode(file), 0, 0);
++>>>>>>> 495e64293911 (vfs: add flags to d_real())
  }
  
  static inline int locks_lock_file_wait(struct file *filp, struct file_lock *fl)
diff --git a/Documentation/filesystems/Locking b/Documentation/filesystems/Locking
index ab6b59a61bcb..d01ed0edbe6f 100644
--- a/Documentation/filesystems/Locking
+++ b/Documentation/filesystems/Locking
@@ -21,7 +21,7 @@ prototypes:
 	struct vfsmount *(*d_automount)(struct path *path);
 	int (*d_manage)(const struct path *, bool);
 	struct dentry *(*d_real)(struct dentry *, const struct inode *,
-				 unsigned int);
+				 unsigned int, unsigned int);
 
 locking rules:
 		rename_lock	->d_lock	may block	rcu-walk
diff --git a/Documentation/filesystems/vfs.txt b/Documentation/filesystems/vfs.txt
index 8d5db43697a0..776043990061 100644
--- a/Documentation/filesystems/vfs.txt
+++ b/Documentation/filesystems/vfs.txt
@@ -928,7 +928,7 @@ struct dentry_operations {
 	struct vfsmount *(*d_automount)(struct path *);
 	int (*d_manage)(const struct path *, bool);
 	struct dentry *(*d_real)(struct dentry *, const struct inode *,
-				 unsigned int);
+				 unsigned int, unsigned int);
 };
 
   d_revalidate: called when the VFS needs to revalidate a dentry. This
* Unmerged path fs/open.c
diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c
index 1736d21e7c3f..9704c8fa71e9 100644
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -78,7 +78,7 @@ static int ovl_check_append_only(struct inode *inode, int flag)
 
 static struct dentry *ovl_d_real(struct dentry *dentry,
 				 const struct inode *inode,
-				 unsigned int open_flags)
+				 unsigned int open_flags, unsigned int flags)
 {
 	struct dentry *real;
 	int err;
@@ -110,7 +110,7 @@ static struct dentry *ovl_d_real(struct dentry *dentry,
 		goto bug;
 
 	/* Handle recursion */
-	real = d_real(real, inode, open_flags);
+	real = d_real(real, inode, open_flags, 0);
 
 	if (!inode || inode == d_inode(real))
 		return real;
* Unmerged path include/linux/dcache.h
* Unmerged path include/linux/fs.h
