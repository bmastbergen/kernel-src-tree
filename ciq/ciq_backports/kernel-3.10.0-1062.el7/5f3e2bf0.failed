tcp: add tcp_min_snd_mss sysctl

jira LE-1907
cve CVE-2019-11479
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 5f3e2bf008c2221478101ee72f5cb4654b9fc363
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/5f3e2bf0.failed

Some TCP peers announce a very small MSS option in their SYN and/or
SYN/ACK messages.

This forces the stack to send packets with a very high network/cpu
overhead.

Linux has enforced a minimal value of 48. Since this value includes
the size of TCP options, and that the options can consume up to 40
bytes, this means that each segment can include only 8 bytes of payload.

In some cases, it can be useful to increase the minimal value
to a saner value.

We still let the default to 48 (TCP_MIN_SND_MSS), for compatibility
reasons.

Note that TCP_MAXSEG socket option enforces a minimal value
of (TCP_MIN_MSS). David Miller increased this minimal value
in commit c39508d6f118 ("tcp: Make TCP_MAXSEG minimum more correct.")
from 64 to 88.

We might in the future merge TCP_MIN_SND_MSS and TCP_MIN_MSS.

CVE-2019-11479 -- tcp mss hardcoded to 48

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Suggested-by: Jonathan Looney <jtl@netflix.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Cc: Yuchung Cheng <ycheng@google.com>
	Cc: Tyler Hicks <tyhicks@canonical.com>
	Cc: Bruce Curtis <brucec@netflix.com>
	Cc: Jonathan Lemon <jonathan.lemon@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5f3e2bf008c2221478101ee72f5cb4654b9fc363)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netns/ipv4.h
#	net/ipv4/sysctl_net_ipv4.c
#	net/ipv4/tcp_ipv4.c
#	net/ipv4/tcp_output.c
diff --cc include/net/netns/ipv4.h
index 79c995f4a025,623cfbb7b8dc..000000000000
--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@@ -70,13 -91,113 +70,111 @@@ struct netns_ipv4 
  	int sysctl_icmp_ratemask;
  	int sysctl_icmp_errors_use_inbound_ifaddr;
  
 -	struct local_ports ip_local_ports;
 -
  	int sysctl_tcp_ecn;
 -	int sysctl_tcp_ecn_fallback;
  
++<<<<<<< HEAD
 +	kgid_t sysctl_ping_group_range[2];
 +	long sysctl_tcp_mem[3];
++=======
+ 	int sysctl_ip_default_ttl;
+ 	int sysctl_ip_no_pmtu_disc;
+ 	int sysctl_ip_fwd_use_pmtu;
+ 	int sysctl_ip_fwd_update_priority;
+ 	int sysctl_ip_nonlocal_bind;
+ 	/* Shall we try to damage output packets if routing dev changes? */
+ 	int sysctl_ip_dynaddr;
+ 	int sysctl_ip_early_demux;
+ #ifdef CONFIG_NET_L3_MASTER_DEV
+ 	int sysctl_raw_l3mdev_accept;
+ #endif
+ 	int sysctl_tcp_early_demux;
+ 	int sysctl_udp_early_demux;
+ 
+ 	int sysctl_fwmark_reflect;
+ 	int sysctl_tcp_fwmark_accept;
+ #ifdef CONFIG_NET_L3_MASTER_DEV
+ 	int sysctl_tcp_l3mdev_accept;
+ #endif
+ 	int sysctl_tcp_mtu_probing;
+ 	int sysctl_tcp_base_mss;
+ 	int sysctl_tcp_min_snd_mss;
+ 	int sysctl_tcp_probe_threshold;
+ 	u32 sysctl_tcp_probe_interval;
+ 
+ 	int sysctl_tcp_keepalive_time;
+ 	int sysctl_tcp_keepalive_probes;
+ 	int sysctl_tcp_keepalive_intvl;
+ 
+ 	int sysctl_tcp_syn_retries;
+ 	int sysctl_tcp_synack_retries;
+ 	int sysctl_tcp_syncookies;
+ 	int sysctl_tcp_reordering;
+ 	int sysctl_tcp_retries1;
+ 	int sysctl_tcp_retries2;
+ 	int sysctl_tcp_orphan_retries;
+ 	int sysctl_tcp_fin_timeout;
+ 	unsigned int sysctl_tcp_notsent_lowat;
+ 	int sysctl_tcp_tw_reuse;
+ 	int sysctl_tcp_sack;
+ 	int sysctl_tcp_window_scaling;
+ 	int sysctl_tcp_timestamps;
+ 	int sysctl_tcp_early_retrans;
+ 	int sysctl_tcp_recovery;
+ 	int sysctl_tcp_thin_linear_timeouts;
+ 	int sysctl_tcp_slow_start_after_idle;
+ 	int sysctl_tcp_retrans_collapse;
+ 	int sysctl_tcp_stdurg;
+ 	int sysctl_tcp_rfc1337;
+ 	int sysctl_tcp_abort_on_overflow;
+ 	int sysctl_tcp_fack;
+ 	int sysctl_tcp_max_reordering;
+ 	int sysctl_tcp_dsack;
+ 	int sysctl_tcp_app_win;
+ 	int sysctl_tcp_adv_win_scale;
+ 	int sysctl_tcp_frto;
+ 	int sysctl_tcp_nometrics_save;
+ 	int sysctl_tcp_moderate_rcvbuf;
+ 	int sysctl_tcp_tso_win_divisor;
+ 	int sysctl_tcp_workaround_signed_windows;
+ 	int sysctl_tcp_limit_output_bytes;
+ 	int sysctl_tcp_challenge_ack_limit;
+ 	int sysctl_tcp_min_tso_segs;
+ 	int sysctl_tcp_min_rtt_wlen;
+ 	int sysctl_tcp_autocorking;
+ 	int sysctl_tcp_invalid_ratelimit;
+ 	int sysctl_tcp_pacing_ss_ratio;
+ 	int sysctl_tcp_pacing_ca_ratio;
+ 	int sysctl_tcp_wmem[3];
+ 	int sysctl_tcp_rmem[3];
+ 	int sysctl_tcp_comp_sack_nr;
+ 	unsigned long sysctl_tcp_comp_sack_delay_ns;
+ 	struct inet_timewait_death_row tcp_death_row;
+ 	int sysctl_max_syn_backlog;
+ 	int sysctl_tcp_fastopen;
+ 	const struct tcp_congestion_ops __rcu  *tcp_congestion_control;
+ 	struct tcp_fastopen_context __rcu *tcp_fastopen_ctx;
+ 	spinlock_t tcp_fastopen_ctx_lock;
+ 	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
+ 	atomic_t tfo_active_disable_times;
+ 	unsigned long tfo_active_disable_stamp;
+ 
+ 	int sysctl_udp_wmem_min;
+ 	int sysctl_udp_rmem_min;
+ 
+ #ifdef CONFIG_NET_L3_MASTER_DEV
+ 	int sysctl_udp_l3mdev_accept;
+ #endif
+ 
+ 	int sysctl_igmp_max_memberships;
+ 	int sysctl_igmp_max_msf;
+ 	int sysctl_igmp_llm_reports;
+ 	int sysctl_igmp_qrv;
+ 
+ 	struct ping_group_range ping_group_range;
++>>>>>>> 5f3e2bf008c2 (tcp: add tcp_min_snd_mss sysctl)
  
  	atomic_t dev_addr_genid;
 -
 -#ifdef CONFIG_SYSCTL
 -	unsigned long *sysctl_local_reserved_ports;
 -	int sysctl_ip_prot_sock;
 -#endif
 +	RH_KABI_FILL_HOLE(unsigned int	fib_seq)	/* protected by rtnl_mutex */
  
  #ifdef CONFIG_IP_MROUTE
  #ifndef CONFIG_IP_MROUTE_MULTIPLE_TABLES
diff --cc net/ipv4/sysctl_net_ipv4.c
index 7c1f370c2eaa,9e5257251163..000000000000
--- a/net/ipv4/sysctl_net_ipv4.c
+++ b/net/ipv4/sysctl_net_ipv4.c
@@@ -36,6 -39,10 +36,13 @@@ static int ip_local_port_range_min[] = 
  static int ip_local_port_range_max[] = { 65535, 65535 };
  static int tcp_adv_win_scale_min = -31;
  static int tcp_adv_win_scale_max = 31;
++<<<<<<< HEAD
++=======
+ static int tcp_min_snd_mss_min = TCP_MIN_SND_MSS;
+ static int tcp_min_snd_mss_max = 65535;
+ static int ip_privileged_port_min;
+ static int ip_privileged_port_max = 65535;
++>>>>>>> 5f3e2bf008c2 (tcp: add tcp_min_snd_mss sysctl)
  static int ip_ttl_min = 1;
  static int ip_ttl_max = 255;
  static int tcp_syn_retries_min = 1;
@@@ -933,25 -1155,125 +940,122 @@@ static struct ctl_table ipv4_net_table[
  		.proc_handler	= proc_dointvec,
  	},
  	{
 -		.procname	= "tcp_workaround_signed_windows",
 -		.data		= &init_net.ipv4.sysctl_tcp_workaround_signed_windows,
++<<<<<<< HEAD
++=======
++		.procname	= "tcp_fwmark_accept",
++		.data		= &init_net.ipv4.sysctl_tcp_fwmark_accept,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
 -		.proc_handler	= proc_dointvec
++		.proc_handler	= proc_dointvec,
+ 	},
++#ifdef CONFIG_NET_L3_MASTER_DEV
+ 	{
 -		.procname	= "tcp_limit_output_bytes",
 -		.data		= &init_net.ipv4.sysctl_tcp_limit_output_bytes,
++		.procname	= "tcp_l3mdev_accept",
++		.data		= &init_net.ipv4.sysctl_tcp_l3mdev_accept,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
 -		.proc_handler	= proc_dointvec
++		.proc_handler	= proc_dointvec_minmax,
++		.extra1		= &zero,
++		.extra2		= &one,
+ 	},
++#endif
+ 	{
 -		.procname	= "tcp_challenge_ack_limit",
 -		.data		= &init_net.ipv4.sysctl_tcp_challenge_ack_limit,
++		.procname	= "tcp_mtu_probing",
++		.data		= &init_net.ipv4.sysctl_tcp_mtu_probing,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
 -		.proc_handler	= proc_dointvec
++		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
 -		.procname	= "tcp_min_tso_segs",
 -		.data		= &init_net.ipv4.sysctl_tcp_min_tso_segs,
++		.procname	= "tcp_base_mss",
++		.data		= &init_net.ipv4.sysctl_tcp_base_mss,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &one,
 -		.extra2		= &gso_max_segs,
++		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
 -		.procname	= "tcp_min_rtt_wlen",
 -		.data		= &init_net.ipv4.sysctl_tcp_min_rtt_wlen,
++		.procname	= "tcp_min_snd_mss",
++		.data		= &init_net.ipv4.sysctl_tcp_min_snd_mss,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &zero,
 -		.extra2		= &one_day_secs
++		.extra1		= &tcp_min_snd_mss_min,
++		.extra2		= &tcp_min_snd_mss_max,
+ 	},
+ 	{
 -		.procname	= "tcp_autocorking",
 -		.data		= &init_net.ipv4.sysctl_tcp_autocorking,
++		.procname	= "tcp_probe_threshold",
++		.data		= &init_net.ipv4.sysctl_tcp_probe_threshold,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &zero,
 -		.extra2		= &one,
++		.proc_handler	= proc_dointvec,
+ 	},
+ 	{
 -		.procname	= "tcp_invalid_ratelimit",
 -		.data		= &init_net.ipv4.sysctl_tcp_invalid_ratelimit,
 -		.maxlen		= sizeof(int),
++		.procname	= "tcp_probe_interval",
++		.data		= &init_net.ipv4.sysctl_tcp_probe_interval,
++		.maxlen		= sizeof(u32),
+ 		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_ms_jiffies,
++		.proc_handler	= proc_douintvec_minmax,
++		.extra2		= &u32_max_div_HZ,
+ 	},
+ 	{
 -		.procname	= "tcp_pacing_ss_ratio",
 -		.data		= &init_net.ipv4.sysctl_tcp_pacing_ss_ratio,
++		.procname	= "igmp_link_local_mcast_reports",
++		.data		= &init_net.ipv4.sysctl_igmp_llm_reports,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &zero,
 -		.extra2		= &thousand,
++		.proc_handler	= proc_dointvec
+ 	},
+ 	{
 -		.procname	= "tcp_pacing_ca_ratio",
 -		.data		= &init_net.ipv4.sysctl_tcp_pacing_ca_ratio,
++		.procname	= "igmp_max_memberships",
++		.data		= &init_net.ipv4.sysctl_igmp_max_memberships,
+ 		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &zero,
 -		.extra2		= &thousand,
++		.proc_handler	= proc_dointvec
+ 	},
+ 	{
 -		.procname	= "tcp_wmem",
 -		.data		= &init_net.ipv4.sysctl_tcp_wmem,
 -		.maxlen		= sizeof(init_net.ipv4.sysctl_tcp_wmem),
++		.procname	= "igmp_max_msf",
++		.data		= &init_net.ipv4.sysctl_igmp_max_msf,
++		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &one,
++		.proc_handler	= proc_dointvec
+ 	},
++#ifdef CONFIG_IP_MULTICAST
+ 	{
 -		.procname	= "tcp_rmem",
 -		.data		= &init_net.ipv4.sysctl_tcp_rmem,
 -		.maxlen		= sizeof(init_net.ipv4.sysctl_tcp_rmem),
++		.procname	= "igmp_qrv",
++		.data		= &init_net.ipv4.sysctl_igmp_qrv,
++		.maxlen		= sizeof(int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &one,
++		.extra1		= &one
+ 	},
++#endif
+ 	{
 -		.procname	= "tcp_comp_sack_delay_ns",
 -		.data		= &init_net.ipv4.sysctl_tcp_comp_sack_delay_ns,
 -		.maxlen		= sizeof(unsigned long),
++		.procname	= "tcp_congestion_control",
++		.data		= &init_net.ipv4.tcp_congestion_control,
+ 		.mode		= 0644,
 -		.proc_handler	= proc_doulongvec_minmax,
++		.maxlen		= TCP_CA_NAME_MAX,
++		.proc_handler	= proc_tcp_congestion_control,
+ 	},
+ 	{
 -		.procname	= "tcp_comp_sack_nr",
 -		.data		= &init_net.ipv4.sysctl_tcp_comp_sack_nr,
++>>>>>>> 5f3e2bf008c2 (tcp: add tcp_min_snd_mss sysctl)
 +		.procname	= "tcp_keepalive_time",
 +		.data		= &init_net.ipv4_sysctl_tcp_keepalive_time,
  		.maxlen		= sizeof(int),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &zero,
 -		.extra2		= &comp_sack_nr_max,
 +		.proc_handler	= proc_dointvec_jiffies,
  	},
  	{
 -		.procname	= "udp_rmem_min",
 -		.data		= &init_net.ipv4.sysctl_udp_rmem_min,
 -		.maxlen		= sizeof(init_net.ipv4.sysctl_udp_rmem_min),
 +		.procname	= "tcp_keepalive_probes",
 +		.data		= &init_net.ipv4_sysctl_tcp_keepalive_probes,
 +		.maxlen		= sizeof(int),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &one
 +		.proc_handler	= proc_dointvec
  	},
  	{
 -		.procname	= "udp_wmem_min",
 -		.data		= &init_net.ipv4.sysctl_udp_wmem_min,
 -		.maxlen		= sizeof(init_net.ipv4.sysctl_udp_wmem_min),
 +		.procname	= "tcp_keepalive_intvl",
 +		.data		= &init_net.ipv4_sysctl_tcp_keepalive_intvl,
 +		.maxlen		= sizeof(int),
  		.mode		= 0644,
 -		.proc_handler	= proc_dointvec_minmax,
 -		.extra1		= &one
 +		.proc_handler	= proc_dointvec_jiffies,
  	},
  	{ }
  };
diff --cc net/ipv4/tcp_ipv4.c
index 2efc1b2188fd,cfa81190a1b1..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -2515,16 -2614,95 +2515,93 @@@ static int __net_init tcp_sk_init(struc
  					   IPPROTO_TCP, net);
  		if (res)
  			goto fail;
 -		sock_set_flag(sk, SOCK_USE_WRITE_QUEUE);
 -
 -		/* Please enforce IP_DF and IPID==0 for RST and
 -		 * ACK sent in SYN-RECV and TIME-WAIT state.
 -		 */
 -		inet_sk(sk)->pmtudisc = IP_PMTUDISC_DO;
 -
 -		*per_cpu_ptr(net->ipv4.tcp_sk, cpu) = sk;
 +		*per_cpu_ptr(net->ipv4_tcp_sk, cpu) = sk;
  	}
 -
  	net->ipv4.sysctl_tcp_ecn = 2;
 -	net->ipv4.sysctl_tcp_ecn_fallback = 1;
  
++<<<<<<< HEAD
 +	net->ipv4_sysctl_tcp_keepalive_time = TCP_KEEPALIVE_TIME;
 +	net->ipv4_sysctl_tcp_keepalive_probes = TCP_KEEPALIVE_PROBES;
 +	net->ipv4_sysctl_tcp_keepalive_intvl = TCP_KEEPALIVE_INTVL;
++=======
+ 	net->ipv4.sysctl_tcp_base_mss = TCP_BASE_MSS;
+ 	net->ipv4.sysctl_tcp_min_snd_mss = TCP_MIN_SND_MSS;
+ 	net->ipv4.sysctl_tcp_probe_threshold = TCP_PROBE_THRESHOLD;
+ 	net->ipv4.sysctl_tcp_probe_interval = TCP_PROBE_INTERVAL;
+ 
+ 	net->ipv4.sysctl_tcp_keepalive_time = TCP_KEEPALIVE_TIME;
+ 	net->ipv4.sysctl_tcp_keepalive_probes = TCP_KEEPALIVE_PROBES;
+ 	net->ipv4.sysctl_tcp_keepalive_intvl = TCP_KEEPALIVE_INTVL;
+ 
+ 	net->ipv4.sysctl_tcp_syn_retries = TCP_SYN_RETRIES;
+ 	net->ipv4.sysctl_tcp_synack_retries = TCP_SYNACK_RETRIES;
+ 	net->ipv4.sysctl_tcp_syncookies = 1;
+ 	net->ipv4.sysctl_tcp_reordering = TCP_FASTRETRANS_THRESH;
+ 	net->ipv4.sysctl_tcp_retries1 = TCP_RETR1;
+ 	net->ipv4.sysctl_tcp_retries2 = TCP_RETR2;
+ 	net->ipv4.sysctl_tcp_orphan_retries = 0;
+ 	net->ipv4.sysctl_tcp_fin_timeout = TCP_FIN_TIMEOUT;
+ 	net->ipv4.sysctl_tcp_notsent_lowat = UINT_MAX;
+ 	net->ipv4.sysctl_tcp_tw_reuse = 2;
+ 
+ 	cnt = tcp_hashinfo.ehash_mask + 1;
+ 	net->ipv4.tcp_death_row.sysctl_max_tw_buckets = cnt / 2;
+ 	net->ipv4.tcp_death_row.hashinfo = &tcp_hashinfo;
+ 
+ 	net->ipv4.sysctl_max_syn_backlog = max(128, cnt / 256);
+ 	net->ipv4.sysctl_tcp_sack = 1;
+ 	net->ipv4.sysctl_tcp_window_scaling = 1;
+ 	net->ipv4.sysctl_tcp_timestamps = 1;
+ 	net->ipv4.sysctl_tcp_early_retrans = 3;
+ 	net->ipv4.sysctl_tcp_recovery = TCP_RACK_LOSS_DETECTION;
+ 	net->ipv4.sysctl_tcp_slow_start_after_idle = 1; /* By default, RFC2861 behavior.  */
+ 	net->ipv4.sysctl_tcp_retrans_collapse = 1;
+ 	net->ipv4.sysctl_tcp_max_reordering = 300;
+ 	net->ipv4.sysctl_tcp_dsack = 1;
+ 	net->ipv4.sysctl_tcp_app_win = 31;
+ 	net->ipv4.sysctl_tcp_adv_win_scale = 1;
+ 	net->ipv4.sysctl_tcp_frto = 2;
+ 	net->ipv4.sysctl_tcp_moderate_rcvbuf = 1;
+ 	/* This limits the percentage of the congestion window which we
+ 	 * will allow a single TSO frame to consume.  Building TSO frames
+ 	 * which are too large can cause TCP streams to be bursty.
+ 	 */
+ 	net->ipv4.sysctl_tcp_tso_win_divisor = 3;
+ 	/* Default TSQ limit of 16 TSO segments */
+ 	net->ipv4.sysctl_tcp_limit_output_bytes = 16 * 65536;
+ 	/* rfc5961 challenge ack rate limiting */
+ 	net->ipv4.sysctl_tcp_challenge_ack_limit = 1000;
+ 	net->ipv4.sysctl_tcp_min_tso_segs = 2;
+ 	net->ipv4.sysctl_tcp_min_rtt_wlen = 300;
+ 	net->ipv4.sysctl_tcp_autocorking = 1;
+ 	net->ipv4.sysctl_tcp_invalid_ratelimit = HZ/2;
+ 	net->ipv4.sysctl_tcp_pacing_ss_ratio = 200;
+ 	net->ipv4.sysctl_tcp_pacing_ca_ratio = 120;
+ 	if (net != &init_net) {
+ 		memcpy(net->ipv4.sysctl_tcp_rmem,
+ 		       init_net.ipv4.sysctl_tcp_rmem,
+ 		       sizeof(init_net.ipv4.sysctl_tcp_rmem));
+ 		memcpy(net->ipv4.sysctl_tcp_wmem,
+ 		       init_net.ipv4.sysctl_tcp_wmem,
+ 		       sizeof(init_net.ipv4.sysctl_tcp_wmem));
+ 	}
+ 	net->ipv4.sysctl_tcp_comp_sack_delay_ns = NSEC_PER_MSEC;
+ 	net->ipv4.sysctl_tcp_comp_sack_nr = 44;
+ 	net->ipv4.sysctl_tcp_fastopen = TFO_CLIENT_ENABLE;
+ 	spin_lock_init(&net->ipv4.tcp_fastopen_ctx_lock);
+ 	net->ipv4.sysctl_tcp_fastopen_blackhole_timeout = 60 * 60;
+ 	atomic_set(&net->ipv4.tfo_active_disable_times, 0);
+ 
+ 	/* Reno is always built in */
+ 	if (!net_eq(net, &init_net) &&
+ 	    try_module_get(init_net.ipv4.tcp_congestion_control->owner))
+ 		net->ipv4.tcp_congestion_control = init_net.ipv4.tcp_congestion_control;
+ 	else
+ 		net->ipv4.tcp_congestion_control = &tcp_reno;
++>>>>>>> 5f3e2bf008c2 (tcp: add tcp_min_snd_mss sysctl)
  
  	return 0;
 +
  fail:
  	tcp_sk_exit(net);
  
diff --cc net/ipv4/tcp_output.c
index 52f0e3183733,00c01a01b547..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -1294,8 -1459,7 +1294,12 @@@ static inline int __tcp_mtu_to_mss(stru
  	mss_now -= icsk->icsk_ext_hdr_len;
  
  	/* Then reserve room for full set of TCP options and 8 bytes of data */
++<<<<<<< HEAD
 +	if (mss_now < 48)
 +		mss_now = 48;
++=======
+ 	mss_now = max(mss_now, sock_net(sk)->ipv4.sysctl_tcp_min_snd_mss);
++>>>>>>> 5f3e2bf008c2 (tcp: add tcp_min_snd_mss sysctl)
  	return mss_now;
  }
  
diff --git a/Documentation/networking/ip-sysctl.txt b/Documentation/networking/ip-sysctl.txt
index f7eb40bc7baf..26620bb80540 100644
--- a/Documentation/networking/ip-sysctl.txt
+++ b/Documentation/networking/ip-sysctl.txt
@@ -214,6 +214,14 @@ tcp_base_mss - INTEGER
 	Path MTU discovery (MTU probing).  If MTU probing is enabled,
 	this is the initial MSS used by the connection.
 
+tcp_min_snd_mss - INTEGER
+	TCP SYN and SYNACK messages usually advertise an ADVMSS option,
+	as described in RFC 1122 and RFC 6691.
+	If this ADVMSS option is smaller than tcp_min_snd_mss,
+	it is silently capped to tcp_min_snd_mss.
+
+	Default : 48 (at least 8 bytes of payload per segment)
+
 tcp_congestion_control - STRING
 	Set the congestion control algorithm to be used for new
 	connections. The algorithm "reno" is always available, but
* Unmerged path include/net/netns/ipv4.h
* Unmerged path net/ipv4/sysctl_net_ipv4.c
* Unmerged path net/ipv4/tcp_ipv4.c
* Unmerged path net/ipv4/tcp_output.c
