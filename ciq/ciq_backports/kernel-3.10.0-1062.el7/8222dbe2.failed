sched/preempt, mm/fault: Decouple preemption from the page fault logic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author David Hildenbrand <dahi@linux.vnet.ibm.com>
commit 8222dbe21e79338de92d5e1956cd1e3994cc9f93
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/8222dbe2.failed

As the fault handlers now all rely on the pagefault_disabled() checks
and implicit preempt_disable() calls by pagefault_disable() have been
made explicit, we can completely rely on the pagefault_disableD counter.

So let's no longer touch the preempt count when disabling/enabling
pagefaults. After a call to pagefault_disable(), pagefault_disabled()
will return true, but in_atomic() won't.

Reviewed-and-tested-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: David Hildenbrand <dahi@linux.vnet.ibm.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: David.Laight@ACULAB.COM
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: airlied@linux.ie
	Cc: akpm@linux-foundation.org
	Cc: benh@kernel.crashing.org
	Cc: bigeasy@linutronix.de
	Cc: borntraeger@de.ibm.com
	Cc: daniel.vetter@intel.com
	Cc: heiko.carstens@de.ibm.com
	Cc: herbert@gondor.apana.org.au
	Cc: hocko@suse.cz
	Cc: hughd@google.com
	Cc: mst@redhat.com
	Cc: paulus@samba.org
	Cc: ralf@linux-mips.org
	Cc: schwidefsky@de.ibm.com
	Cc: yang.shi@windriver.com
Link: http://lkml.kernel.org/r/1431359540-32227-16-git-send-email-dahi@linux.vnet.ibm.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 8222dbe21e79338de92d5e1956cd1e3994cc9f93)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/uaccess.h
diff --cc include/linux/uaccess.h
index 0497c0dedb93,ae572c138607..000000000000
--- a/include/linux/uaccess.h
+++ b/include/linux/uaccess.h
@@@ -1,24 -1,30 +1,39 @@@
  #ifndef __LINUX_UACCESS_H__
  #define __LINUX_UACCESS_H__
  
++<<<<<<< HEAD
 +#include <linux/preempt.h>
 +#ifndef __GENKSYMS__
++=======
++>>>>>>> 8222dbe21e79 (sched/preempt, mm/fault: Decouple preemption from the page fault logic)
  #include <linux/sched.h>
 +#endif
  #include <asm/uaccess.h>
  
 -static __always_inline void pagefault_disabled_inc(void)
 -{
 -	current->pagefault_disabled++;
 -}
 -
 -static __always_inline void pagefault_disabled_dec(void)
 -{
 -	current->pagefault_disabled--;
 -	WARN_ON(current->pagefault_disabled < 0);
 -}
 -
  /*
++<<<<<<< HEAD
 + * These routines enable/disable the pagefault handler in that
 + * it will not take any locks and go straight to the fixup table.
 + *
 + * They have great resemblance to the preempt_disable/enable calls
 + * and in fact they are identical; this is because currently there is
 + * no other way to make the pagefault handlers do this. So we do
 + * disable preemption but we don't necessarily care about that.
 + */
 +static inline void pagefault_disable(void)
 +{
 +	inc_preempt_count();
++=======
+  * These routines enable/disable the pagefault handler. If disabled, it will
+  * not take any locks and go straight to the fixup table.
+  *
+  * User access methods will not sleep when called from a pagefault_disabled()
+  * environment.
+  */
+ static inline void pagefault_disable(void)
+ {
+ 	pagefault_disabled_inc();
++>>>>>>> 8222dbe21e79 (sched/preempt, mm/fault: Decouple preemption from the page fault logic)
  	/*
  	 * make sure to have issued the store before a pagefault
  	 * can hit.
@@@ -33,14 -39,26 +48,18 @@@ static inline void pagefault_enable(voi
  	 * the pagefault handler again.
  	 */
  	barrier();
++<<<<<<< HEAD
 +	dec_preempt_count();
 +	/*
 +	 * make sure we do..
 +	 */
 +	barrier();
 +	preempt_check_resched();
++=======
+ 	pagefault_disabled_dec();
++>>>>>>> 8222dbe21e79 (sched/preempt, mm/fault: Decouple preemption from the page fault logic)
  }
  
 -/*
 - * Is the pagefault handler disabled? If so, user access methods will not sleep.
 - */
 -#define pagefault_disabled() (current->pagefault_disabled != 0)
 -
 -/*
 - * The pagefault handler is in general disabled by pagefault_disable() or
 - * when in irq context (via in_atomic()).
 - *
 - * This function should only be used by the fault handlers. Other users should
 - * stick to pagefault_disabled().
 - * Please NEVER use preempt_disable() to disable the fault handler. With
 - * !CONFIG_PREEMPT_COUNT, this is like a NOP. So the handler won't be disabled.
 - * in_atomic() will report different values based on !CONFIG_PREEMPT_COUNT.
 - */
 -#define faulthandler_disabled() (pagefault_disabled() || in_atomic())
 -
  #ifndef ARCH_HAS_NOCACHE_UACCESS
  
  static inline unsigned long __copy_from_user_inatomic_nocache(void *to,
* Unmerged path include/linux/uaccess.h
