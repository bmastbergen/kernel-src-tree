fib_rules: fix suppressor names and default values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Stefan Tomanek <stefan.tomanek@wertarbyte.de>
commit 73f5698e77219bfc3ea1903759fe8e20ab5b285e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/73f5698e.failed

This change brings the suppressor attribute names into line; it also changes
the data types to provide a more consistent interface.

While -1 indicates that the suppressor is not enabled, values >= 0 for
suppress_prefixlen or suppress_ifgroup  reject routing decisions violating the
constraint.

This changes the previously presented behaviour of suppress_prefixlen, where a
prefix length _less_ than the attribute value was rejected. After this change,
a prefix length less than *or* equal to the value is considered a violation of
the rule constraint.

It also changes the default values for default and newly added rules (disabling
any suppression for those).

	Signed-off-by: Stefan Tomanek <stefan.tomanek@wertarbyte.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 73f5698e77219bfc3ea1903759fe8e20ab5b285e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/fib_rules.h
#	include/uapi/linux/fib_rules.h
#	net/core/fib_rules.c
#	net/ipv4/fib_rules.c
#	net/ipv6/fib6_rules.c
diff --cc include/net/fib_rules.h
index c606297c9c82,9d0fcbaa9cbb..000000000000
--- a/include/net/fib_rules.h
+++ b/include/net/fib_rules.h
@@@ -19,7 -18,8 +19,12 @@@ struct fib_rule 
  	u32			pref;
  	u32			flags;
  	u32			table;
++<<<<<<< HEAD
 +	u8			table_prefixlen_min;
++=======
+ 	int			suppress_ifgroup;
+ 	int			suppress_prefixlen;
++>>>>>>> 73f5698e7721 (fib_rules: fix suppressor names and default values)
  	u8			action;
  	u32			target;
  	struct fib_rule __rcu	*ctarget;
@@@ -97,7 -84,8 +102,12 @@@ struct fib_rule_notifier_info 
  	[FRA_FWMARK]	= { .type = NLA_U32 }, \
  	[FRA_FWMASK]	= { .type = NLA_U32 }, \
  	[FRA_TABLE]     = { .type = NLA_U32 }, \
++<<<<<<< HEAD
 +	[FRA_TABLE_PREFIXLEN_MIN] = { .type = NLA_U8 }, \
++=======
+ 	[FRA_SUPPRESS_PREFIXLEN] = { .type = NLA_U32 }, \
+ 	[FRA_SUPPRESS_IFGROUP] = { .type = NLA_U32 }, \
++>>>>>>> 73f5698e7721 (fib_rules: fix suppressor names and default values)
  	[FRA_GOTO]	= { .type = NLA_U32 }
  
  static inline void fib_rule_get(struct fib_rule *rule)
diff --cc include/uapi/linux/fib_rules.h
index ba7dbdbd2b1f,2b82d7e30974..000000000000
--- a/include/uapi/linux/fib_rules.h
+++ b/include/uapi/linux/fib_rules.h
@@@ -43,9 -43,9 +43,15 @@@ enum 
  	FRA_UNUSED5,
  	FRA_FWMARK,	/* mark */
  	FRA_FLOW,	/* flow/class id */
++<<<<<<< HEAD
 +	FRA_TUN_ID,
 +	FRA_UNUSED7,
 +	FRA_TABLE_PREFIXLEN_MIN,
++=======
+ 	FRA_UNUSED6,
+ 	FRA_SUPPRESS_IFGROUP,
+ 	FRA_SUPPRESS_PREFIXLEN,
++>>>>>>> 73f5698e7721 (fib_rules: fix suppressor names and default values)
  	FRA_TABLE,	/* Extended table id */
  	FRA_FWMASK,	/* mask for netfilter mark */
  	FRA_OIFNAME,
diff --cc net/core/fib_rules.c
index 3780988ae823,2e654138433c..000000000000
--- a/net/core/fib_rules.c
+++ b/net/core/fib_rules.c
@@@ -48,8 -31,11 +48,11 @@@ int fib_default_rule_add(struct fib_rul
  	r->pref = pref;
  	r->table = table;
  	r->flags = flags;
 -	r->fr_net = hold_net(ops->fro_net);
 +	r->fr_net = ops->fro_net;
  
+ 	r->suppress_prefixlen = -1;
+ 	r->suppress_ifgroup = -1;
+ 
  	/* The lock is not required here, the list in unreacheable
  	 * at the moment this function is called */
  	list_add_tail(&r->list, &ops->rules_list);
@@@ -413,9 -343,19 +416,22 @@@ static int fib_nl_newrule(struct sk_buf
  	rule->action = frh->action;
  	rule->flags = frh->flags;
  	rule->table = frh_get_table(frh, tb);
- 	if (tb[FRA_TABLE_PREFIXLEN_MIN])
- 		rule->table_prefixlen_min = nla_get_u8(tb[FRA_TABLE_PREFIXLEN_MIN]);
+ 	if (tb[FRA_SUPPRESS_PREFIXLEN])
+ 		rule->suppress_prefixlen = nla_get_u32(tb[FRA_SUPPRESS_PREFIXLEN]);
+ 	else
+ 		rule->suppress_prefixlen = -1;
+ 
++<<<<<<< HEAD
++=======
+ 	if (tb[FRA_SUPPRESS_IFGROUP])
+ 		rule->suppress_ifgroup = nla_get_u32(tb[FRA_SUPPRESS_IFGROUP]);
+ 	else
+ 		rule->suppress_ifgroup = -1;
+ 
+ 	if (!tb[FRA_PRIORITY] && ops->default_pref)
+ 		rule->pref = ops->default_pref(ops);
  
++>>>>>>> 73f5698e7721 (fib_rules: fix suppressor names and default values)
  	err = -EINVAL;
  	if (tb[FRA_GOTO]) {
  		if (rule->action != FR_ACT_GOTO)
@@@ -614,10 -538,10 +630,15 @@@ static inline size_t fib_rule_nlmsg_siz
  			 + nla_total_size(IFNAMSIZ) /* FRA_OIFNAME */
  			 + nla_total_size(4) /* FRA_PRIORITY */
  			 + nla_total_size(4) /* FRA_TABLE */
++<<<<<<< HEAD
 +			 + nla_total_size(1) /* FRA_TABLE_PREFIXLEN_MIN */
++=======
+ 			 + nla_total_size(4) /* FRA_SUPPRESS_PREFIXLEN */
+ 			 + nla_total_size(4) /* FRA_SUPPRESS_IFGROUP */
++>>>>>>> 73f5698e7721 (fib_rules: fix suppressor names and default values)
  			 + nla_total_size(4) /* FRA_FWMARK */
 -			 + nla_total_size(4); /* FRA_FWMASK */
 +			 + nla_total_size(4) /* FRA_FWMASK */
 +			 + nla_total_size_64bit(8); /* FRA_TUN_ID */
  
  	if (ops->nlmsg_payload)
  		payload += ops->nlmsg_payload(rule);
diff --cc net/ipv4/fib_rules.c
index 59f3aaf49b80,523be38e37de..000000000000
--- a/net/ipv4/fib_rules.c
+++ b/net/ipv4/fib_rules.c
@@@ -138,13 -106,24 +138,25 @@@ static bool fib4_rule_suppress(struct f
  	/* do not accept result if the route does
  	 * not meet the required prefix length
  	 */
++<<<<<<< HEAD
 +	struct fib_result *result = (struct fib_result *) arg->result;
 +	if (result->prefixlen < rule->table_prefixlen_min) {
 +		if (!(arg->flags & FIB_LOOKUP_NOREF))
 +			fib_info_put(result->fi);
 +		return true;
 +	}
++=======
+ 	if (result->prefixlen <= rule->suppress_prefixlen)
+ 		goto suppress_route;
+ 
+ 	/* do not accept result if the route uses a device
+ 	 * belonging to a forbidden interface group
+ 	 */
+ 	if (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)
+ 		goto suppress_route;
+ 
++>>>>>>> 73f5698e7721 (fib_rules: fix suppressor names and default values)
  	return false;
 -
 -suppress_route:
 -	if (!(arg->flags & FIB_LOOKUP_NOREF))
 -		fib_info_put(result->fi);
 -	return true;
  }
  
  static int fib4_rule_match(struct fib_rule *rule, struct flowi *fl, int flags)
diff --cc net/ipv6/fib6_rules.c
index 8a288677aacb,a6c58ce43d34..000000000000
--- a/net/ipv6/fib6_rules.c
+++ b/net/ipv6/fib6_rules.c
@@@ -159,11 -125,21 +159,26 @@@ static bool fib6_rule_suppress(struct f
  	/* do not accept result if the route does
  	 * not meet the required prefix length
  	 */
++<<<<<<< HEAD
 +	if (rt->rt6i_dst.plen < rule->table_prefixlen_min) {
++=======
+ 	if (rt->rt6i_dst.plen <= rule->suppress_prefixlen)
+ 		goto suppress_route;
+ 
+ 	/* do not accept result if the route uses a device
+ 	 * belonging to a forbidden interface group
+ 	 */
+ 	if (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)
+ 		goto suppress_route;
+ 
+ 	return false;
+ 
+ suppress_route:
++>>>>>>> 73f5698e7721 (fib_rules: fix suppressor names and default values)
  		ip6_rt_put(rt);
  		return true;
 +	}
 +	return false;
  }
  
  static int fib6_rule_match(struct fib_rule *rule, struct flowi *fl, int flags)
* Unmerged path include/net/fib_rules.h
* Unmerged path include/uapi/linux/fib_rules.h
* Unmerged path net/core/fib_rules.c
* Unmerged path net/ipv4/fib_rules.c
* Unmerged path net/ipv6/fib6_rules.c
