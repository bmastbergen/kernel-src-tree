PCI: hv: Refactor hv_irq_unmask() to use cpumask_to_vpset()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [pci] hv: Refactor hv_irq_unmask() to use cpumask_to_vpset() (Vitaly Kuznetsov) [1661654]
Rebuild_FUZZ: 95.58%
commit-author Maya Nakamura <m.maya.nakamura@gmail.com>
commit c8ccf7599ddac5fa48e06104c44b24709e21eed5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c8ccf759.failed

Remove the duplicate implementation of cpumask_to_vpset() and use the
shared implementation. Export hv_max_vp_index, which is required by
cpumask_to_vpset().

	Signed-off-by: Maya Nakamura <m.maya.nakamura@gmail.com>
	Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Tested-by: Vitaly Kuznetsov <vkuznets@redhat.com>
(cherry picked from commit c8ccf7599ddac5fa48e06104c44b24709e21eed5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci-hyperv.c
diff --cc drivers/pci/pci-hyperv.c
index 3a3d3c5d60fd,95441a35eceb..000000000000
--- a/drivers/pci/pci-hyperv.c
+++ b/drivers/pci/pci-hyperv.c
@@@ -394,14 -391,6 +394,17 @@@ struct hv_interrupt_entry 
  	u32	data;
  };
  
++<<<<<<< HEAD:drivers/pci/pci-hyperv.c
 +#define HV_VP_SET_BANK_COUNT_MAX	5 /* current implementation limit */
 +
 +struct hv_vp_set {
 +	u64	format;			/* 0 (HvGenericSetSparse4k) */
 +	u64	valid_banks;
 +	u64	masks[HV_VP_SET_BANK_COUNT_MAX];
 +};
 +
++=======
++>>>>>>> c8ccf7599dda (PCI: hv: Refactor hv_irq_unmask() to use cpumask_to_vpset()):drivers/pci/controller/pci-hyperv.c
  /*
   * flags for hv_device_interrupt_target.flags
   */
@@@ -814,20 -882,40 +817,29 @@@ static int hv_set_affinity(struct irq_d
  	struct irq_cfg *cfg = irqd_cfg(data);
  	struct retarget_msi_interrupt *params;
  	struct hv_pcibus_device *hbus;
++<<<<<<< HEAD:drivers/pci/pci-hyperv.c
++=======
+ 	struct cpumask *dest;
+ 	cpumask_var_t tmp;
++>>>>>>> c8ccf7599dda (PCI: hv: Refactor hv_irq_unmask() to use cpumask_to_vpset()):drivers/pci/controller/pci-hyperv.c
  	struct pci_bus *pbus;
  	struct pci_dev *pdev;
 +	int cpu, ret;
 +	unsigned int dest_id;
  	unsigned long flags;
  	u32 var_size = 0;
++<<<<<<< HEAD:drivers/pci/pci-hyperv.c
 +	int cpu_vmbus;
++=======
+ 	int cpu, nr_bank;
++>>>>>>> c8ccf7599dda (PCI: hv: Refactor hv_irq_unmask() to use cpumask_to_vpset()):drivers/pci/controller/pci-hyperv.c
  	u64 res;
  
 -	dest = irq_data_get_effective_affinity_mask(data);
 -	pdev = msi_desc_to_pci_dev(msi_desc);
 +	ret = __ioapic_set_affinity(data, dest, &dest_id);
 +	if (ret)
 +		return ret;
 +
 +	pdev = msi_desc_to_pci_dev(data->msi_desc);
  	pbus = pdev->bus;
  	hbus = container_of(pbus->sysdata, struct hv_pcibus_device, sysdata);
  
@@@ -863,29 -951,29 +875,50 @@@
  		 */
  		params->int_target.flags |=
  			HV_DEVICE_INTERRUPT_TARGET_PROCESSOR_SET;
++<<<<<<< HEAD:drivers/pci/pci-hyperv.c
 +		params->int_target.vp_set.valid_banks =
 +			(1ull << HV_VP_SET_BANK_COUNT_MAX) - 1;
++=======
+ 
+ 		if (!alloc_cpumask_var(&tmp, GFP_ATOMIC)) {
+ 			res = 1;
+ 			goto exit_unlock;
+ 		}
+ 
+ 		cpumask_and(tmp, dest, cpu_online_mask);
+ 		nr_bank = cpumask_to_vpset(&params->int_target.vp_set, tmp);
+ 		free_cpumask_var(tmp);
+ 
+ 		if (nr_bank <= 0) {
+ 			res = 1;
+ 			goto exit_unlock;
+ 		}
++>>>>>>> c8ccf7599dda (PCI: hv: Refactor hv_irq_unmask() to use cpumask_to_vpset()):drivers/pci/controller/pci-hyperv.c
  
  		/*
  		 * var-sized hypercall, var-size starts after vp_mask (thus
 -		 * vp_set.format does not count, but vp_set.valid_bank_mask
 -		 * does).
 +		 * vp_set.format does not count, but vp_set.valid_banks does).
  		 */
++<<<<<<< HEAD:drivers/pci/pci-hyperv.c
 +		var_size = 1 + HV_VP_SET_BANK_COUNT_MAX;
 +
 +		for_each_cpu_and(cpu, cfg->domain, cpu_online_mask) {
 +			cpu_vmbus = hv_cpu_number_to_vp_number(cpu);
 +
 +			if (cpu_vmbus >= HV_VP_SET_BANK_COUNT_MAX * 64) {
 +				dev_err(&hbus->hdev->device,
 +					"too high CPU %d", cpu_vmbus);
 +				res = 1;
 +				goto exit_unlock;
 +			}
 +			params->int_target.vp_set.masks[cpu_vmbus / 64] |=
 +				(1ULL << (cpu_vmbus & 63));
 +		}
++=======
+ 		var_size = 1 + nr_bank;
++>>>>>>> c8ccf7599dda (PCI: hv: Refactor hv_irq_unmask() to use cpumask_to_vpset()):drivers/pci/controller/pci-hyperv.c
  	} else {
 -		for_each_cpu_and(cpu, dest, cpu_online_mask) {
 +		for_each_cpu_and(cpu, cfg->domain, cpu_online_mask) {
  			params->int_target.vp_mask |=
  				(1ULL << hv_cpu_number_to_vp_number(cpu));
  		}
diff --git a/arch/x86/hyperv/hv_init.c b/arch/x86/hyperv/hv_init.c
index d319f711dbe1..07419cd9da16 100644
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@ -88,6 +88,7 @@ u32 *hv_vp_index;
 EXPORT_SYMBOL_GPL(hv_vp_index);
 
 u32 hv_max_vp_index;
+EXPORT_SYMBOL_GPL(hv_max_vp_index);
 
 static void hv_cpu_init(void *arg)
 {
* Unmerged path drivers/pci/pci-hyperv.c
