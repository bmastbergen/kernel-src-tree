xfs: iterate over extents in xfs_iextents_copy

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 71565f4b92048321ba3078877dd1a1149a23550d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/71565f4b.failed

This actually makes the function very slightly less efficient for now as we
detour through the expanded irect format between the in-core extent format
and the on-disk one instead of just endian swapping them.  But with the
incore extent btree the in-core one will use a different format and the
representation will be entirely hidden.  It also happens to make the
function a whole more readable.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 71565f4b92048321ba3078877dd1a1149a23550d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_fork.c
diff --cc fs/xfs/libxfs/xfs_inode_fork.c
index f83028029221,7dd77b497fc2..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@@ -654,53 -733,31 +651,69 @@@ xfs_iext_count(struct xfs_ifork *ifp
   */
  int
  xfs_iextents_copy(
- 	xfs_inode_t		*ip,
- 	xfs_bmbt_rec_t		*dp,
+ 	struct xfs_inode	*ip,
+ 	struct xfs_bmbt_rec	*dp,
  	int			whichfork)
  {
++<<<<<<< HEAD
 +	int			copied;
 +	int			i;
 +	xfs_ifork_t		*ifp;
 +	int			nrecs;
 +	xfs_fsblock_t		start_block;
++=======
+ 	int			state = xfs_bmap_fork_to_state(whichfork);
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	struct xfs_bmbt_irec	rec;
+ 	int			copied = 0, i = 0;
++>>>>>>> 71565f4b9204 (xfs: iterate over extents in xfs_iextents_copy)
  
- 	ifp = XFS_IFORK_PTR(ip, whichfork);
- 	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));
+ 	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL | XFS_ILOCK_SHARED));
  	ASSERT(ifp->if_bytes > 0);
  
++<<<<<<< HEAD
 +	nrecs = xfs_iext_count(ifp);
 +	XFS_BMAP_TRACE_EXLIST(ip, nrecs, whichfork);
 +	ASSERT(nrecs > 0);
 +
 +	/*
 +	 * There are some delayed allocation extents in the
 +	 * inode, so copy the extents one at a time and skip
 +	 * the delayed ones.  There must be at least one
 +	 * non-delayed extent.
 +	 */
 +	copied = 0;
 +	for (i = 0; i < nrecs; i++) {
 +		xfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);
 +
 +		ASSERT(xfs_bmbt_validate_extent(ip->i_mount, whichfork, ep));
 +
 +		start_block = xfs_bmbt_get_startblock(ep);
 +		if (isnullstartblock(start_block)) {
 +			/*
 +			 * It's a delayed allocation extent, so skip it.
 +			 */
 +			continue;
 +		}
 +
 +		/* Translate to on disk format */
 +		put_unaligned_be64(ep->l0, &dp->l0);
 +		put_unaligned_be64(ep->l1, &dp->l1);
++=======
+ 	while (xfs_iext_get_extent(ifp, i++, &rec)) {
+ 		if (isnullstartblock(rec.br_startblock))
+ 			continue;
+ 		xfs_bmbt_disk_set_all(dp, &rec);
+ 		trace_xfs_write_extent(ip, i, state, _RET_IP_);
+ 		ASSERT(xfs_bmbt_validate_extent(ip->i_mount, whichfork, dp));
+ 		copied += sizeof(struct xfs_bmbt_rec);
++>>>>>>> 71565f4b9204 (xfs: iterate over extents in xfs_iextents_copy)
  		dp++;
- 		copied++;
  	}
- 	ASSERT(copied != 0);
  
- 	return (copied * (uint)sizeof(xfs_bmbt_rec_t));
+ 	ASSERT(copied > 0);
+ 	ASSERT(copied <= ifp->if_bytes);
+ 	return copied;
  }
  
  /*
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.c
