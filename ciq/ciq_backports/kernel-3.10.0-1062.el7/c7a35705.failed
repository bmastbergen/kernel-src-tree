scsi: mpt3sas: Split _base_reset_handler(), mpt3sas_scsih_reset_handler() and mpt3sas_ctl_reset_handler()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] mpt3sas: Split _base_reset_handler(), mpt3sas_scsih_reset_handler() and mpt3sas_ctl_reset_handler() (Tomas Henzl) [1642370]
Rebuild_FUZZ: 97.06%
commit-author Bart Van Assche <bart.vanassche@wdc.com>
commit c7a357058882637548dd0908b743c674a23ce0e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c7a35705.failed

Split each of these functions in three functions - one function per reset
phase. This patch does not change any functionality but makes the code
easier to read.

Note: it is much easier to review the git diff -w output after having
applied this patch than by reviewing the patch itself.

	Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
	Cc: Sathya Prakash <sathya.prakash@broadcom.com>
	Cc: Chaitra P B <chaitra.basappa@broadcom.com>
	Cc: Suganath Prabu Subramani <suganath-prabu.subramani@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c7a357058882637548dd0908b743c674a23ce0e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt3sas/mpt3sas_base.h
#	drivers/scsi/mpt3sas/mpt3sas_scsih.c
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.h
index 4895498db08b,96dc15e90bd8..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h
@@@ -136,11 -140,20 +136,28 @@@
  
  #define FW_IMG_HDR_READ_TIMEOUT	15
  /*
++<<<<<<< HEAD
 + * reset phases
 + */
 +#define MPT3_IOC_PRE_RESET		1 /* prior to host reset */
 +#define MPT3_IOC_AFTER_RESET		2 /* just after host reset */
 +#define MPT3_IOC_DONE_RESET		3 /* links re-initialized */
++=======
+  * NVMe defines
+  */
+ #define	NVME_PRP_SIZE			8	/* PRP size */
+ #define	NVME_ERROR_RESPONSE_SIZE	16	/* Max NVME Error Response */
+ #define NVME_TASK_ABORT_MIN_TIMEOUT	6
+ #define NVME_TASK_ABORT_MAX_TIMEOUT	60
+ #define NVME_TASK_MNGT_CUSTOM_MASK	(0x0010)
+ #define	NVME_PRP_PAGE_SIZE		4096	/* Page size */
+ 
+ struct mpt3sas_nvme_cmd {
+ 	u8	rsvd[24];
+ 	__le64	prp1;
+ 	__le64	prp2;
+ };
++>>>>>>> c7a357058882 (scsi: mpt3sas: Split _base_reset_handler(), mpt3sas_scsih_reset_handler() and mpt3sas_ctl_reset_handler())
  
  /*
   * logging format
@@@ -1412,16 -1482,19 +1429,18 @@@ u8 mpt3sas_base_check_cmd_timeout(struc
  	u8 status, void *mpi_request, int sz);
  
  /* scsih shared API */
 -struct scsi_cmnd *mpt3sas_scsih_scsi_lookup_get(struct MPT3SAS_ADAPTER *ioc,
 -	u16 smid);
  u8 mpt3sas_scsih_event_callback(struct MPT3SAS_ADAPTER *ioc, u8 msix_index,
  	u32 reply);
- void mpt3sas_scsih_reset_handler(struct MPT3SAS_ADAPTER *ioc, int reset_phase);
+ void mpt3sas_scsih_pre_reset_handler(struct MPT3SAS_ADAPTER *ioc);
+ void mpt3sas_scsih_after_reset_handler(struct MPT3SAS_ADAPTER *ioc);
+ void mpt3sas_scsih_reset_done_handler(struct MPT3SAS_ADAPTER *ioc);
  
 -int mpt3sas_scsih_issue_tm(struct MPT3SAS_ADAPTER *ioc, u16 handle, u64 lun,
 -	u8 type, u16 smid_task, u16 msix_task, u8 timeout, u8 tr_method);
 +int mpt3sas_scsih_issue_tm(struct MPT3SAS_ADAPTER *ioc, u16 handle,
 +	uint channel, uint id, uint lun, u8 type, u16 smid_task,
 +	ulong timeout);
  int mpt3sas_scsih_issue_locked_tm(struct MPT3SAS_ADAPTER *ioc, u16 handle,
 -	u64 lun, u8 type, u16 smid_task, u16 msix_task,
 -	u8 timeout, u8 tr_method);
 +	uint channel, uint id, uint lun, u8 type, u16 smid_task,
 +	ulong timeout);
  
  void mpt3sas_scsih_set_tm_flag(struct MPT3SAS_ADAPTER *ioc, u16 handle);
  void mpt3sas_scsih_clear_tm_flag(struct MPT3SAS_ADAPTER *ioc, u16 handle);
diff --cc drivers/scsi/mpt3sas/mpt3sas_scsih.c
index 9086915b17c4,74dfbaf21814..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@@ -9469,56 -9426,64 +9470,77 @@@ _scsih_scan_for_devices_after_reset(str
  /**
   * mpt3sas_scsih_reset_handler - reset callback handler (for scsih)
   * @ioc: per adapter object
-  * @reset_phase: phase
   *
   * The handler for doing any required cleanup or initialization.
+  */
+ void mpt3sas_scsih_pre_reset_handler(struct MPT3SAS_ADAPTER *ioc)
+ {
+ 	dtmprintk(ioc, pr_info(MPT3SAS_FMT
+ 			"%s: MPT3_IOC_PRE_RESET\n", ioc->name, __func__));
+ }
+ 
+ /**
+  * mpt3sas_scsih_after_reset_handler - reset callback handler (for scsih)
+  * @ioc: per adapter object
   *
-  * The reset phase can be MPT3_IOC_PRE_RESET, MPT3_IOC_AFTER_RESET,
-  * MPT3_IOC_DONE_RESET
-  *
-  * Return nothing.
+  * The handler for doing any required cleanup or initialization.
   */
  void
- mpt3sas_scsih_reset_handler(struct MPT3SAS_ADAPTER *ioc, int reset_phase)
+ mpt3sas_scsih_after_reset_handler(struct MPT3SAS_ADAPTER *ioc)
  {
- 	switch (reset_phase) {
- 	case MPT3_IOC_PRE_RESET:
- 		dtmprintk(ioc, pr_info(MPT3SAS_FMT
- 			"%s: MPT3_IOC_PRE_RESET\n", ioc->name, __func__));
- 		break;
- 	case MPT3_IOC_AFTER_RESET:
- 		dtmprintk(ioc, pr_info(MPT3SAS_FMT
+ 	dtmprintk(ioc, pr_info(MPT3SAS_FMT
  			"%s: MPT3_IOC_AFTER_RESET\n", ioc->name, __func__));
- 		if (ioc->scsih_cmds.status & MPT3_CMD_PENDING) {
- 			ioc->scsih_cmds.status |= MPT3_CMD_RESET;
- 			mpt3sas_base_free_smid(ioc, ioc->scsih_cmds.smid);
- 			complete(&ioc->scsih_cmds.done);
- 		}
- 		if (ioc->tm_cmds.status & MPT3_CMD_PENDING) {
- 			ioc->tm_cmds.status |= MPT3_CMD_RESET;
- 			mpt3sas_base_free_smid(ioc, ioc->tm_cmds.smid);
- 			complete(&ioc->tm_cmds.done);
- 		}
+ 	if (ioc->scsih_cmds.status & MPT3_CMD_PENDING) {
+ 		ioc->scsih_cmds.status |= MPT3_CMD_RESET;
+ 		mpt3sas_base_free_smid(ioc, ioc->scsih_cmds.smid);
+ 		complete(&ioc->scsih_cmds.done);
+ 	}
+ 	if (ioc->tm_cmds.status & MPT3_CMD_PENDING) {
+ 		ioc->tm_cmds.status |= MPT3_CMD_RESET;
+ 		mpt3sas_base_free_smid(ioc, ioc->tm_cmds.smid);
+ 		complete(&ioc->tm_cmds.done);
+ 	}
  
- 		memset(ioc->pend_os_device_add, 0, ioc->pend_os_device_add_sz);
- 		memset(ioc->device_remove_in_progress, 0,
- 		       ioc->device_remove_in_progress_sz);
- 		_scsih_fw_event_cleanup_queue(ioc);
- 		_scsih_flush_running_cmds(ioc);
- 		break;
- 	case MPT3_IOC_DONE_RESET:
- 		dtmprintk(ioc, pr_info(MPT3SAS_FMT
+ 	memset(ioc->pend_os_device_add, 0, ioc->pend_os_device_add_sz);
+ 	memset(ioc->device_remove_in_progress, 0,
+ 	       ioc->device_remove_in_progress_sz);
+ 	_scsih_fw_event_cleanup_queue(ioc);
+ 	_scsih_flush_running_cmds(ioc);
+ }
+ 
+ /**
+  * mpt3sas_scsih_reset_handler - reset callback handler (for scsih)
+  * @ioc: per adapter object
+  *
+  * The handler for doing any required cleanup or initialization.
+  */
+ void
+ mpt3sas_scsih_reset_done_handler(struct MPT3SAS_ADAPTER *ioc)
+ {
+ 	dtmprintk(ioc, pr_info(MPT3SAS_FMT
  			"%s: MPT3_IOC_DONE_RESET\n", ioc->name, __func__));
++<<<<<<< HEAD
 +		if ((!ioc->is_driver_loading) && !(disable_discovery > 0 &&
 +		    !ioc->sas_hba.num_phys)) {
 +			_scsih_prep_device_scan(ioc);
 +			_scsih_search_responding_sas_devices(ioc);
 +			_scsih_search_responding_pcie_devices(ioc);
 +			_scsih_search_responding_raid_devices(ioc);
 +			_scsih_search_responding_expanders(ioc);
 +			_scsih_error_recovery_delete_devices(ioc);
 +		}
 +		break;
++=======
+ 	if ((!ioc->is_driver_loading) && !(disable_discovery > 0 &&
+ 					   !ioc->sas_hba.num_phys)) {
+ 		_scsih_prep_device_scan(ioc);
+ 		_scsih_create_enclosure_list_after_reset(ioc);
+ 		_scsih_search_responding_sas_devices(ioc);
+ 		_scsih_search_responding_pcie_devices(ioc);
+ 		_scsih_search_responding_raid_devices(ioc);
+ 		_scsih_search_responding_expanders(ioc);
+ 		_scsih_error_recovery_delete_devices(ioc);
++>>>>>>> c7a357058882 (scsi: mpt3sas: Split _base_reset_handler(), mpt3sas_scsih_reset_handler() and mpt3sas_ctl_reset_handler())
  	}
  }
  
diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.c b/drivers/scsi/mpt3sas/mpt3sas_base.c
index 80f2689dcb34..8484c3ecf8e5 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@ -5848,65 +5848,69 @@ mpt3sas_base_detach(struct MPT3SAS_ADAPTER *ioc)
 }
 
 /**
- * _base_reset_handler - reset callback handler (for base)
+ * _base_pre_reset_handler - pre reset handler
  * @ioc: per adapter object
- * @reset_phase: phase
- *
- * The handler for doing any required cleanup or initialization.
- *
- * The reset phase can be MPT3_IOC_PRE_RESET, MPT3_IOC_AFTER_RESET,
- * MPT3_IOC_DONE_RESET
- *
- * Return nothing.
  */
-static void
-_base_reset_handler(struct MPT3SAS_ADAPTER *ioc, int reset_phase)
+static void _base_pre_reset_handler(struct MPT3SAS_ADAPTER *ioc)
 {
-	mpt3sas_scsih_reset_handler(ioc, reset_phase);
-	mpt3sas_ctl_reset_handler(ioc, reset_phase);
-	switch (reset_phase) {
-	case MPT3_IOC_PRE_RESET:
-		dtmprintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: MPT3_IOC_PRE_RESET\n", ioc->name, __func__));
-		break;
-	case MPT3_IOC_AFTER_RESET:
-		dtmprintk(ioc, pr_info(MPT3SAS_FMT
-		"%s: MPT3_IOC_AFTER_RESET\n", ioc->name, __func__));
-		if (ioc->transport_cmds.status & MPT3_CMD_PENDING) {
-			ioc->transport_cmds.status |= MPT3_CMD_RESET;
-			mpt3sas_base_free_smid(ioc, ioc->transport_cmds.smid);
-			complete(&ioc->transport_cmds.done);
-		}
-		if (ioc->base_cmds.status & MPT3_CMD_PENDING) {
-			ioc->base_cmds.status |= MPT3_CMD_RESET;
-			mpt3sas_base_free_smid(ioc, ioc->base_cmds.smid);
-			complete(&ioc->base_cmds.done);
-		}
-		if (ioc->port_enable_cmds.status & MPT3_CMD_PENDING) {
-			ioc->port_enable_failed = 1;
-			ioc->port_enable_cmds.status |= MPT3_CMD_RESET;
-			mpt3sas_base_free_smid(ioc, ioc->port_enable_cmds.smid);
-			if (ioc->is_driver_loading) {
-				ioc->start_scan_failed =
-				    MPI2_IOCSTATUS_INTERNAL_ERROR;
-				ioc->start_scan = 0;
-				ioc->port_enable_cmds.status =
-				    MPT3_CMD_NOT_USED;
-			} else
-				complete(&ioc->port_enable_cmds.done);
-		}
-		if (ioc->config_cmds.status & MPT3_CMD_PENDING) {
-			ioc->config_cmds.status |= MPT3_CMD_RESET;
-			mpt3sas_base_free_smid(ioc, ioc->config_cmds.smid);
-			ioc->config_cmds.smid = USHRT_MAX;
-			complete(&ioc->config_cmds.done);
+	mpt3sas_scsih_pre_reset_handler(ioc);
+	mpt3sas_ctl_pre_reset_handler(ioc);
+	dtmprintk(ioc, pr_info(MPT3SAS_FMT
+			"%s: MPT3_IOC_PRE_RESET\n", ioc->name, __func__));
+}
+
+/**
+ * _base_after_reset_handler - after reset handler
+ * @ioc: per adapter object
+ */
+static void _base_after_reset_handler(struct MPT3SAS_ADAPTER *ioc)
+{
+	mpt3sas_scsih_after_reset_handler(ioc);
+	mpt3sas_ctl_after_reset_handler(ioc);
+	dtmprintk(ioc, pr_info(MPT3SAS_FMT
+			"%s: MPT3_IOC_AFTER_RESET\n", ioc->name, __func__));
+	if (ioc->transport_cmds.status & MPT3_CMD_PENDING) {
+		ioc->transport_cmds.status |= MPT3_CMD_RESET;
+		mpt3sas_base_free_smid(ioc, ioc->transport_cmds.smid);
+		complete(&ioc->transport_cmds.done);
+	}
+	if (ioc->base_cmds.status & MPT3_CMD_PENDING) {
+		ioc->base_cmds.status |= MPT3_CMD_RESET;
+		mpt3sas_base_free_smid(ioc, ioc->base_cmds.smid);
+		complete(&ioc->base_cmds.done);
+	}
+	if (ioc->port_enable_cmds.status & MPT3_CMD_PENDING) {
+		ioc->port_enable_failed = 1;
+		ioc->port_enable_cmds.status |= MPT3_CMD_RESET;
+		mpt3sas_base_free_smid(ioc, ioc->port_enable_cmds.smid);
+		if (ioc->is_driver_loading) {
+			ioc->start_scan_failed =
+				MPI2_IOCSTATUS_INTERNAL_ERROR;
+			ioc->start_scan = 0;
+			ioc->port_enable_cmds.status =
+				MPT3_CMD_NOT_USED;
+		} else {
+			complete(&ioc->port_enable_cmds.done);
 		}
-		break;
-	case MPT3_IOC_DONE_RESET:
-		dtmprintk(ioc, pr_info(MPT3SAS_FMT
-			"%s: MPT3_IOC_DONE_RESET\n", ioc->name, __func__));
-		break;
 	}
+	if (ioc->config_cmds.status & MPT3_CMD_PENDING) {
+		ioc->config_cmds.status |= MPT3_CMD_RESET;
+		mpt3sas_base_free_smid(ioc, ioc->config_cmds.smid);
+		ioc->config_cmds.smid = USHRT_MAX;
+		complete(&ioc->config_cmds.done);
+	}
+}
+
+/**
+ * _base_reset_done_handler - reset done handler
+ * @ioc: per adapter object
+ */
+static void _base_reset_done_handler(struct MPT3SAS_ADAPTER *ioc)
+{
+	mpt3sas_scsih_reset_done_handler(ioc);
+	mpt3sas_ctl_reset_done_handler(ioc);
+	dtmprintk(ioc, pr_info(MPT3SAS_FMT
+			"%s: MPT3_IOC_DONE_RESET\n", ioc->name, __func__));
 }
 
 /**
@@ -5982,13 +5986,13 @@ mpt3sas_base_hard_reset_handler(struct MPT3SAS_ADAPTER *ioc,
 		if ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT)
 			is_fault = 1;
 	}
-	_base_reset_handler(ioc, MPT3_IOC_PRE_RESET);
+	_base_pre_reset_handler(ioc);
 	mpt3sas_wait_for_commands_to_complete(ioc);
 	_base_mask_interrupts(ioc);
 	r = _base_make_ioc_ready(ioc, type);
 	if (r)
 		goto out;
-	_base_reset_handler(ioc, MPT3_IOC_AFTER_RESET);
+	_base_after_reset_handler(ioc);
 
 	/* If this hard reset is called while port enable is active, then
 	 * there is no reason to call make_ioc_operational
@@ -6009,7 +6013,7 @@ mpt3sas_base_hard_reset_handler(struct MPT3SAS_ADAPTER *ioc,
 
 	r = _base_make_ioc_operational(ioc);
 	if (!r)
-		_base_reset_handler(ioc, MPT3_IOC_DONE_RESET);
+		_base_reset_done_handler(ioc);
 
  out:
 	dtmprintk(ioc, pr_info(MPT3SAS_FMT "%s: %s\n",
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.h
diff --git a/drivers/scsi/mpt3sas/mpt3sas_ctl.c b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
index bdd5dacbbbc9..87509ae4c36e 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_ctl.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
@@ -446,57 +446,66 @@ out:
 /**
  * mpt3sas_ctl_reset_handler - reset callback handler (for ctl)
  * @ioc: per adapter object
- * @reset_phase: phase
  *
  * The handler for doing any required cleanup or initialization.
- *
- * The reset phase can be MPT3_IOC_PRE_RESET, MPT3_IOC_AFTER_RESET,
- * MPT3_IOC_DONE_RESET
  */
-void
-mpt3sas_ctl_reset_handler(struct MPT3SAS_ADAPTER *ioc, int reset_phase)
+void mpt3sas_ctl_pre_reset_handler(struct MPT3SAS_ADAPTER *ioc)
 {
 	int i;
 	u8 issue_reset;
 
-	switch (reset_phase) {
-	case MPT3_IOC_PRE_RESET:
-		dtmprintk(ioc, pr_info(MPT3SAS_FMT
+	dtmprintk(ioc, pr_info(MPT3SAS_FMT
 			"%s: MPT3_IOC_PRE_RESET\n", ioc->name, __func__));
-		for (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {
-			if (!(ioc->diag_buffer_status[i] &
-			    MPT3_DIAG_BUFFER_IS_REGISTERED))
-				continue;
-			if ((ioc->diag_buffer_status[i] &
-			    MPT3_DIAG_BUFFER_IS_RELEASED))
-				continue;
-			mpt3sas_send_diag_release(ioc, i, &issue_reset);
-		}
-		break;
-	case MPT3_IOC_AFTER_RESET:
-		dtmprintk(ioc, pr_info(MPT3SAS_FMT
+	for (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {
+		if (!(ioc->diag_buffer_status[i] &
+		      MPT3_DIAG_BUFFER_IS_REGISTERED))
+			continue;
+		if ((ioc->diag_buffer_status[i] &
+		     MPT3_DIAG_BUFFER_IS_RELEASED))
+			continue;
+		mpt3sas_send_diag_release(ioc, i, &issue_reset);
+	}
+}
+
+/**
+ * mpt3sas_ctl_reset_handler - reset callback handler (for ctl)
+ * @ioc: per adapter object
+ *
+ * The handler for doing any required cleanup or initialization.
+ */
+void mpt3sas_ctl_after_reset_handler(struct MPT3SAS_ADAPTER *ioc)
+{
+	dtmprintk(ioc, pr_info(MPT3SAS_FMT
 			"%s: MPT3_IOC_AFTER_RESET\n", ioc->name, __func__));
-		if (ioc->ctl_cmds.status & MPT3_CMD_PENDING) {
-			ioc->ctl_cmds.status |= MPT3_CMD_RESET;
-			mpt3sas_base_free_smid(ioc, ioc->ctl_cmds.smid);
-			complete(&ioc->ctl_cmds.done);
-		}
-		break;
-	case MPT3_IOC_DONE_RESET:
-		dtmprintk(ioc, pr_info(MPT3SAS_FMT
+	if (ioc->ctl_cmds.status & MPT3_CMD_PENDING) {
+		ioc->ctl_cmds.status |= MPT3_CMD_RESET;
+		mpt3sas_base_free_smid(ioc, ioc->ctl_cmds.smid);
+		complete(&ioc->ctl_cmds.done);
+	}
+}
+
+/**
+ * mpt3sas_ctl_reset_handler - reset callback handler (for ctl)
+ * @ioc: per adapter object
+ *
+ * The handler for doing any required cleanup or initialization.
+ */
+void mpt3sas_ctl_reset_done_handler(struct MPT3SAS_ADAPTER *ioc)
+{
+	int i;
+
+	dtmprintk(ioc, pr_info(MPT3SAS_FMT
 			"%s: MPT3_IOC_DONE_RESET\n", ioc->name, __func__));
 
-		for (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {
-			if (!(ioc->diag_buffer_status[i] &
-			    MPT3_DIAG_BUFFER_IS_REGISTERED))
-				continue;
-			if ((ioc->diag_buffer_status[i] &
-			    MPT3_DIAG_BUFFER_IS_RELEASED))
-				continue;
-			ioc->diag_buffer_status[i] |=
-			    MPT3_DIAG_BUFFER_IS_DIAG_RESET;
-		}
-		break;
+	for (i = 0; i < MPI2_DIAG_BUF_TYPE_COUNT; i++) {
+		if (!(ioc->diag_buffer_status[i] &
+		      MPT3_DIAG_BUFFER_IS_REGISTERED))
+			continue;
+		if ((ioc->diag_buffer_status[i] &
+		     MPT3_DIAG_BUFFER_IS_RELEASED))
+			continue;
+		ioc->diag_buffer_status[i] |=
+			MPT3_DIAG_BUFFER_IS_DIAG_RESET;
 	}
 }
 
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_scsih.c
