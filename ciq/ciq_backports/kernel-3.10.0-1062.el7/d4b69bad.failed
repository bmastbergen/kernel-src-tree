nfp: flower: remove unnecessary code in flow lookup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author John Hurley <john.hurley@netronome.com>
commit d4b69bad61e0fc4055c108fa28846ae981948d54
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d4b69bad.failed

Recent changes to NFP mean that stats updates from fw to driver no longer
require a flow lookup and (because egdev offload has been removed) the
ingress netdev for a lookup is now always known.

Remove obsolete code in a flow lookup that matches on host context and
that allows for a netdev to be NULL.

	Signed-off-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d4b69bad61e0fc4055c108fa28846ae981948d54)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/main.h
#	drivers/net/ethernet/netronome/nfp/flower/metadata.c
#	drivers/net/ethernet/netronome/nfp/flower/offload.c
diff --cc drivers/net/ethernet/netronome/nfp/flower/main.h
index 90cc96d4eae4,b858bac47621..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/main.h
+++ b/drivers/net/ethernet/netronome/nfp/flower/main.h
@@@ -49,10 -20,8 +49,15 @@@ struct tc_to_netdev
  struct net_device;
  struct nfp_app;
  
++<<<<<<< HEAD
 +#define NFP_FL_STATS_ENTRY_RS		BIT(20)
 +#define NFP_FL_STATS_ELEM_RS		4
 +#define NFP_FL_REPEATED_HASH_MAX	BIT(17)
 +#define NFP_FLOWER_HASH_BITS		19
++=======
+ #define NFP_FL_STATS_ELEM_RS		FIELD_SIZEOF(struct nfp_fl_stats_id, \
+ 						     init_unalloc)
++>>>>>>> d4b69bad61e0 (nfp: flower: remove unnecessary code in flow lookup)
  #define NFP_FLOWER_MASK_ENTRY_RS	256
  #define NFP_FLOWER_MASK_ELEMENT_RS	1
  #define NFP_FLOWER_MASK_HASH_BITS	10
@@@ -275,7 -240,8 +280,12 @@@ int nfp_modify_flow_metadata(struct nfp
  			     struct nfp_fl_payload *nfp_flow);
  
  struct nfp_fl_payload *
++<<<<<<< HEAD
 +nfp_flower_search_fl_table(struct nfp_app *app, unsigned long tc_flower_cookie);
++=======
+ nfp_flower_search_fl_table(struct nfp_app *app, unsigned long tc_flower_cookie,
+ 			   struct net_device *netdev);
++>>>>>>> d4b69bad61e0 (nfp: flower: remove unnecessary code in flow lookup)
  struct nfp_fl_payload *
  nfp_flower_remove_fl_table(struct nfp_app *app, unsigned long tc_flower_cookie);
  
diff --cc drivers/net/ethernet/netronome/nfp/flower/metadata.c
index c748aceb17bb,573a4400a26c..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/metadata.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/metadata.c
@@@ -48,6 -18,11 +48,14 @@@ struct nfp_mask_id_table 
  	u8 mask_id;
  };
  
++<<<<<<< HEAD
++=======
+ struct nfp_fl_flow_table_cmp_arg {
+ 	struct net_device *netdev;
+ 	unsigned long cookie;
+ };
+ 
++>>>>>>> d4b69bad61e0 (nfp: flower: remove unnecessary code in flow lookup)
  static int nfp_release_stats_entry(struct nfp_app *app, u32 stats_context_id)
  {
  	struct nfp_flower_priv *priv = app->priv;
@@@ -99,44 -74,17 +107,54 @@@ static int nfp_get_stats_entry(struct n
  
  /* Must be called with either RTNL or rcu_read_lock */
  struct nfp_fl_payload *
++<<<<<<< HEAD
 +nfp_flower_search_fl_table(struct nfp_app *app, unsigned long tc_flower_cookie)
++=======
+ nfp_flower_search_fl_table(struct nfp_app *app, unsigned long tc_flower_cookie,
+ 			   struct net_device *netdev)
++>>>>>>> d4b69bad61e0 (nfp: flower: remove unnecessary code in flow lookup)
  {
 -	struct nfp_fl_flow_table_cmp_arg flower_cmp_arg;
 +	unsigned long fl_key = nfp_flower_fl_key(tc_flower_cookie);
  	struct nfp_flower_priv *priv = app->priv;
 -
 +	struct nfp_fl_payload *flower_entry;
 +
++<<<<<<< HEAD
 +	hash_for_each_possible_rcu(priv->flow_table, flower_entry, link,
 +				   fl_key)
 +		if (flower_entry->tc_flower_cookie == tc_flower_cookie)
 +			return flower_entry;
++=======
+ 	flower_cmp_arg.netdev = netdev;
+ 	flower_cmp_arg.cookie = tc_flower_cookie;
++>>>>>>> d4b69bad61e0 (nfp: flower: remove unnecessary code in flow lookup)
 +
 +	return NULL;
 +}
 +
 +static void
 +nfp_flower_update_stats(struct nfp_app *app, struct nfp_fl_stats_frame *stats)
 +{
 +	struct nfp_fl_payload *nfp_flow;
 +	unsigned long flower_cookie;
 +
 +	flower_cookie = be64_to_cpu(stats->stats_cookie);
 +
 +	rcu_read_lock();
 +	nfp_flow = nfp_flower_search_fl_table(app, flower_cookie);
 +	if (!nfp_flow)
 +		goto exit_rcu_unlock;
 +
 +	if (nfp_flow->meta.host_ctx_id != stats->stats_con_id)
 +		goto exit_rcu_unlock;
  
 -	return rhashtable_lookup_fast(&priv->flow_table, &flower_cmp_arg,
 -				      nfp_flower_table_params);
 +	spin_lock(&nfp_flow->lock);
 +	nfp_flow->stats.pkts += be32_to_cpu(stats->pkt_count);
 +	nfp_flow->stats.bytes += be64_to_cpu(stats->byte_count);
 +	nfp_flow->stats.used = jiffies;
 +	spin_unlock(&nfp_flow->lock);
 +
 +exit_rcu_unlock:
 +	rcu_read_unlock();
  }
  
  void nfp_flower_rx_flow_stats(struct nfp_app *app, struct sk_buff *skb)
@@@ -343,11 -301,11 +361,15 @@@ int nfp_compile_flow_metadata(struct nf
  
  	/* Update flow payload with mask ids. */
  	nfp_flow->unmasked_data[NFP_FL_MASK_ID_LOCATION] = new_mask_id;
 -	priv->stats[stats_cxt].pkts = 0;
 -	priv->stats[stats_cxt].bytes = 0;
 -	priv->stats[stats_cxt].used = jiffies;
 +	nfp_flow->stats.pkts = 0;
 +	nfp_flow->stats.bytes = 0;
 +	nfp_flow->stats.used = jiffies;
  
++<<<<<<< HEAD
 +	check_entry = nfp_flower_search_fl_table(app, flow->cookie);
++=======
+ 	check_entry = nfp_flower_search_fl_table(app, flow->cookie, netdev);
++>>>>>>> d4b69bad61e0 (nfp: flower: remove unnecessary code in flow lookup)
  	if (check_entry) {
  		if (nfp_release_stats_entry(app, stats_cxt))
  			return -EINVAL;
@@@ -386,12 -344,54 +408,53 @@@ int nfp_modify_flow_metadata(struct nfp
  	return nfp_release_stats_entry(app, temp_ctx_id);
  }
  
++<<<<<<< HEAD
 +int nfp_flower_metadata_init(struct nfp_app *app)
++=======
+ static int nfp_fl_obj_cmpfn(struct rhashtable_compare_arg *arg,
+ 			    const void *obj)
+ {
+ 	const struct nfp_fl_flow_table_cmp_arg *cmp_arg = arg->key;
+ 	const struct nfp_fl_payload *flow_entry = obj;
+ 
+ 	if (flow_entry->ingress_dev == cmp_arg->netdev)
+ 		return flow_entry->tc_flower_cookie != cmp_arg->cookie;
+ 
+ 	return 1;
+ }
+ 
+ static u32 nfp_fl_obj_hashfn(const void *data, u32 len, u32 seed)
+ {
+ 	const struct nfp_fl_payload *flower_entry = data;
+ 
+ 	return jhash2((u32 *)&flower_entry->tc_flower_cookie,
+ 		      sizeof(flower_entry->tc_flower_cookie) / sizeof(u32),
+ 		      seed);
+ }
+ 
+ static u32 nfp_fl_key_hashfn(const void *data, u32 len, u32 seed)
+ {
+ 	const struct nfp_fl_flow_table_cmp_arg *cmp_arg = data;
+ 
+ 	return jhash2((u32 *)&cmp_arg->cookie,
+ 		      sizeof(cmp_arg->cookie) / sizeof(u32), seed);
+ }
+ 
+ const struct rhashtable_params nfp_flower_table_params = {
+ 	.head_offset		= offsetof(struct nfp_fl_payload, fl_node),
+ 	.hashfn			= nfp_fl_key_hashfn,
+ 	.obj_cmpfn		= nfp_fl_obj_cmpfn,
+ 	.obj_hashfn		= nfp_fl_obj_hashfn,
+ 	.automatic_shrinking	= true,
+ };
+ 
+ int nfp_flower_metadata_init(struct nfp_app *app, u64 host_ctx_count)
++>>>>>>> d4b69bad61e0 (nfp: flower: remove unnecessary code in flow lookup)
  {
  	struct nfp_flower_priv *priv = app->priv;
 -	int err;
  
  	hash_init(priv->mask_table);
 -
 -	err = rhashtable_init(&priv->flow_table, &nfp_flower_table_params);
 -	if (err)
 -		return err;
 -
 +	hash_init(priv->flow_table);
  	get_random_bytes(&priv->mask_id_seed, sizeof(priv->mask_id_seed));
  
  	/* Init ring buffer and unallocated mask_ids. */
diff --cc drivers/net/ethernet/netronome/nfp/flower/offload.c
index 970ddbd64602,545d94168874..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/offload.c
@@@ -533,11 -504,15 +533,18 @@@ static in
  nfp_flower_del_offload(struct nfp_app *app, struct net_device *netdev,
  		       struct tc_cls_flower_offload *flow)
  {
 -	struct nfp_flower_priv *priv = app->priv;
 +	struct nfp_port *port = nfp_port_from_netdev(netdev);
  	struct nfp_fl_payload *nfp_flow;
 -	struct nfp_port *port = NULL;
  	int err;
  
++<<<<<<< HEAD
 +	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie);
++=======
+ 	if (nfp_netdev_is_nfp_repr(netdev))
+ 		port = nfp_port_from_netdev(netdev);
+ 
+ 	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie, netdev);
++>>>>>>> d4b69bad61e0 (nfp: flower: remove unnecessary code in flow lookup)
  	if (!nfp_flow)
  		return -ENOENT;
  
@@@ -574,11 -553,14 +581,15 @@@ err_free_flow
   * Return: negative value on error, 0 if stats populated successfully.
   */
  static int
 -nfp_flower_get_stats(struct nfp_app *app, struct net_device *netdev,
 -		     struct tc_cls_flower_offload *flow)
 +nfp_flower_get_stats(struct nfp_app *app, struct tc_cls_flower_offload *flow)
  {
 -	struct nfp_flower_priv *priv = app->priv;
  	struct nfp_fl_payload *nfp_flow;
 -	u32 ctx_id;
  
++<<<<<<< HEAD
 +	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie);
++=======
+ 	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie, netdev);
++>>>>>>> d4b69bad61e0 (nfp: flower: remove unnecessary code in flow lookup)
  	if (!nfp_flow)
  		return -EINVAL;
  
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/main.h
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/metadata.c
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/offload.c
