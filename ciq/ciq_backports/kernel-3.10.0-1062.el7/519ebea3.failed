mm: memcontrol: factor out reclaim iterator loading and updating

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [mm] memcontrol: factor out reclaim iterator loading and updating (Aristeu Rozanski) [1595932]
Rebuild_FUZZ: 96.77%
commit-author Johannes Weiner <hannes@cmpxchg.org>
commit 519ebea3bf6df45439e79c54bda1d9e29fe13a64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/519ebea3.failed

mem_cgroup_iter() is too hard to follow.  Factor out the lockless reclaim
iterator loading and updating so it's easier to follow the big picture.

Also document the iterator invalidation mechanism a bit more extensively.

	Signed-off-by: Johannes Weiner <hannes@cmpxchg.org>
	Reported-by: Tejun Heo <tj@kernel.org>
	Reviewed-by: Tejun Heo <tj@kernel.org>
	Acked-by: Michal Hocko <mhocko@suse.cz>
	Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
	Cc: Glauber Costa <glommer@parallels.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 519ebea3bf6df45439e79c54bda1d9e29fe13a64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index 6eda6e4d5fc7,2e851f453814..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -1226,37 -1256,13 +1278,45 @@@ struct mem_cgroup *mem_cgroup_iter(stru
  				goto out_unlock;
  			}
  
++<<<<<<< HEAD
 +			/*
 +			 * If the dead_count mismatches, a destruction
 +			 * has happened or is happening concurrently.
 +			 * If the dead_count matches, a destruction
 +			 * might still happen concurrently, but since
 +			 * we checked under RCU, that destruction
 +			 * won't free the object until we release the
 +			 * RCU reader lock.  Thus, the dead_count
 +			 * check verifies the pointer is still valid,
 +			 * css_tryget() verifies the cgroup pointed to
 +			 * is alive.
 +			 */
 +			dead_count = atomic_read(&root->dead_count);
 +			if (dead_count == iter->last_dead_count) {
 +				smp_rmb();
 +				last_visited = iter->last_visited;
 +				if (last_visited && last_visited != root &&
 +				    !css_tryget(&last_visited->css))
 +					last_visited = NULL;
 +			}
++=======
+ 			last_visited = mem_cgroup_iter_load(iter, root, &seq);
++>>>>>>> 519ebea3bf6d (mm: memcontrol: factor out reclaim iterator loading and updating)
  		}
  
  		memcg = __mem_cgroup_iter_next(root, last_visited);
  
  		if (reclaim) {
++<<<<<<< HEAD
 +			if (last_visited && last_visited != root)
 +				css_put(&last_visited->css);
 +
 +			iter->last_visited = memcg;
 +			smp_wmb();
 +			iter->last_dead_count = dead_count;
++=======
+ 			mem_cgroup_iter_update(iter, last_visited, memcg, seq);
++>>>>>>> 519ebea3bf6d (mm: memcontrol: factor out reclaim iterator loading and updating)
  
  			if (!memcg)
  				iter->generation++;
* Unmerged path mm/memcontrol.c
