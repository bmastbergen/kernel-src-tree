ovl: simplify arguments to ovl_check_origin_fh()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 1eff1a1deec727bacead79ec64554c1df190f43c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/1eff1a1d.failed

Pass the fs instance with lower_layers array instead of the dentry
lowerstack array to ovl_check_origin_fh(), because the dentry members
of lowerstack play no role in this helper.

This change simplifies the argument list of ovl_check_origin(),
ovl_cleanup_index() and ovl_verify_index().

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 1eff1a1deec727bacead79ec64554c1df190f43c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/readdir.c
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/namei.c
index 0afb8ae29e9b,27f25a61f6e4..000000000000
--- a/fs/overlayfs/namei.c
+++ b/fs/overlayfs/namei.c
@@@ -284,21 -291,15 +284,31 @@@ static int ovl_lookup_layer(struct dent
  }
  
  
++<<<<<<< HEAD
 +static int ovl_check_origin(struct dentry *upperdentry,
 +			    struct path *lowerstack, unsigned int numlower,
 +			    struct path **stackp, unsigned int *ctrp)
++=======
+ static int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh,
+ 			       struct dentry *upperdentry,
+ 			       struct ovl_path **stackp)
++>>>>>>> 1eff1a1deec7 (ovl: simplify arguments to ovl_check_origin_fh())
  {
- 	struct vfsmount *mnt;
  	struct dentry *origin = NULL;
  	int i;
  
++<<<<<<< HEAD
 +
 +	for (i = 0; i < numlower; i++) {
 +		mnt = lowerstack[i].mnt;
 +		origin = ovl_get_origin(upperdentry, mnt);
 +		if (IS_ERR(origin))
 +			return PTR_ERR(origin);
 +
++=======
+ 	for (i = 0; i < ofs->numlower; i++) {
+ 		origin = ovl_decode_fh(fh, ofs->lower_layers[i].mnt);
++>>>>>>> 1eff1a1deec7 (ovl: simplify arguments to ovl_check_origin_fh())
  		if (origin)
  			break;
  	}
@@@ -313,9 -319,43 +323,48 @@@
  		dput(origin);
  		return -ENOMEM;
  	}
++<<<<<<< HEAD
 +	**stackp = (struct path) { .dentry = origin, .mnt = mnt };
++=======
+ 	**stackp = (struct ovl_path){
+ 		.dentry = origin,
+ 		.layer = &ofs->lower_layers[i]
+ 	};
+ 
+ 	return 0;
+ 
+ invalid:
+ 	pr_warn_ratelimited("overlayfs: invalid origin (%pd2, ftype=%x, origin ftype=%x).\n",
+ 			    upperdentry, d_inode(upperdentry)->i_mode & S_IFMT,
+ 			    d_inode(origin)->i_mode & S_IFMT);
+ 	dput(origin);
+ 	return -EIO;
+ }
+ 
+ static int ovl_check_origin(struct ovl_fs *ofs, struct dentry *upperdentry,
+ 			    struct ovl_path **stackp, unsigned int *ctrp)
+ {
+ 	struct ovl_fh *fh = ovl_get_origin_fh(upperdentry);
+ 	int err;
+ 
+ 	if (IS_ERR_OR_NULL(fh))
+ 		return PTR_ERR(fh);
+ 
+ 	err = ovl_check_origin_fh(ofs, fh, upperdentry, stackp);
+ 	kfree(fh);
+ 
+ 	if (err) {
+ 		if (err == -ESTALE)
+ 			return 0;
+ 		return err;
+ 	}
+ 
+ 	if (WARN_ON(*ctrp))
+ 		return -EIO;
+ 
++>>>>>>> 1eff1a1deec7 (ovl: simplify arguments to ovl_check_origin_fh())
  	*ctrp = 1;
 +
  	return 0;
  }
  
@@@ -383,8 -423,7 +432,12 @@@ fail
   * OVL_XATTR_ORIGIN and that origin file handle can be decoded to lower path.
   * Return 0 on match, -ESTALE on mismatch or stale origin, < 0 on error.
   */
++<<<<<<< HEAD
 +int ovl_verify_index(struct dentry *index, struct path *lowerstack,
 +		     unsigned int numlower)
++=======
+ int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index)
++>>>>>>> 1eff1a1deec7 (ovl: simplify arguments to ovl_check_origin_fh())
  {
  	struct ovl_fh *fh = NULL;
  	size_t len;
@@@ -428,9 -470,7 +481,13 @@@
  	if (err)
  		goto fail;
  
++<<<<<<< HEAD
 +	err = ovl_check_origin(index, lowerstack, numlower, &stack, &ctr);
 +	if (!err && !ctr)
 +		err = -ESTALE;
++=======
+ 	err = ovl_check_origin_fh(ofs, fh, index, &stack);
++>>>>>>> 1eff1a1deec7 (ovl: simplify arguments to ovl_check_origin_fh())
  	if (err)
  		goto fail;
  
diff --cc fs/overlayfs/overlayfs.h
index 79baeaeaf3d6,d55afb6646b0..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -246,13 -249,13 +246,20 @@@ static inline bool ovl_is_impuredir(str
  
  
  /* namei.c */
++<<<<<<< HEAD
 +int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 +		      struct dentry *origin, bool is_upper, bool set);
 +int ovl_verify_index(struct dentry *index, struct path *lowerstack,
 +		     unsigned int numlower);
++=======
+ int ovl_verify_origin(struct dentry *dentry, struct dentry *origin,
+ 		      bool is_upper, bool set);
+ int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
++>>>>>>> 1eff1a1deec7 (ovl: simplify arguments to ovl_check_origin_fh())
  int ovl_get_index_name(struct dentry *origin, struct qstr *name);
  int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
- struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
+ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
+ 			  unsigned int flags);
  bool ovl_lower_positive(struct dentry *dentry);
  
  /* readdir.c */
@@@ -264,8 -267,7 +271,12 @@@ void ovl_dir_cache_free(struct inode *i
  int ovl_check_d_type_supported(struct path *realpath);
  void ovl_workdir_cleanup(struct inode *dir, struct vfsmount *mnt,
  			 struct dentry *dentry, int level);
++<<<<<<< HEAD
 +int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
 +			 struct path *lowerstack, unsigned int numlower);
++=======
+ int ovl_indexdir_cleanup(struct ovl_fs *ofs);
++>>>>>>> 1eff1a1deec7 (ovl: simplify arguments to ovl_check_origin_fh())
  
  /* inode.c */
  int ovl_set_nlink_upper(struct dentry *dentry);
diff --cc fs/overlayfs/readdir.c
index f15029442198,4c660c7085b7..000000000000
--- a/fs/overlayfs/readdir.c
+++ b/fs/overlayfs/readdir.c
@@@ -1032,13 -1030,13 +1032,18 @@@ void ovl_workdir_cleanup(struct inode *
  	}
  }
  
++<<<<<<< HEAD
 +int ovl_indexdir_cleanup(struct dentry *dentry, struct vfsmount *mnt,
 +			 struct path *lowerstack, unsigned int numlower)
++=======
+ int ovl_indexdir_cleanup(struct ovl_fs *ofs)
++>>>>>>> 1eff1a1deec7 (ovl: simplify arguments to ovl_check_origin_fh())
  {
  	int err;
+ 	struct dentry *indexdir = ofs->indexdir;
  	struct dentry *index = NULL;
- 	struct inode *dir = dentry->d_inode;
- 	struct path path = { .mnt = mnt, .dentry = dentry };
+ 	struct inode *dir = indexdir->d_inode;
+ 	struct path path = { .mnt = ofs->upper_mnt, .dentry = indexdir };
  	LIST_HEAD(list);
  	struct rb_root root = RB_ROOT;
  	struct ovl_cache_entry *p;
@@@ -1068,7 -1066,7 +1073,11 @@@
  			index = NULL;
  			break;
  		}
++<<<<<<< HEAD
 +		err = ovl_verify_index(index, lowerstack, numlower);
++=======
+ 		err = ovl_verify_index(ofs, index);
++>>>>>>> 1eff1a1deec7 (ovl: simplify arguments to ovl_check_origin_fh())
  		/* Cleanup stale and orphan index entries */
  		if (err && (err == -ESTALE || err == -ENOENT))
  			err = ovl_cleanup(dir, index);
diff --cc fs/overlayfs/super.c
index d3038555ac46,4345c3f83fde..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -871,121 -879,258 +871,155 @@@ static const struct xattr_handler *ovl_
  	NULL
  };
  
 -static int ovl_get_upper(struct ovl_fs *ofs, struct path *upperpath)
 -{
 -	struct vfsmount *upper_mnt;
 -	int err;
 -
 -	err = ovl_mount_dir(ofs->config.upperdir, upperpath);
 -	if (err)
 -		goto out;
 -
 -	/* Upper fs should not be r/o */
 -	if (sb_rdonly(upperpath->mnt->mnt_sb)) {
 -		pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 -		err = -EINVAL;
 -		goto out;
 -	}
 -
 -	err = ovl_check_namelen(upperpath, ofs, ofs->config.upperdir);
 -	if (err)
 -		goto out;
 -
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(upperpath->dentry)) {
 -		ofs->upperdir_locked = true;
 -	} else if (ofs->config.index) {
 -		pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 -	}
 -
 -	upper_mnt = clone_private_mount(upperpath);
 -	err = PTR_ERR(upper_mnt);
 -	if (IS_ERR(upper_mnt)) {
 -		pr_err("overlayfs: failed to clone upperpath\n");
 -		goto out;
 -	}
 -
 -	/* Don't inherit atime flags */
 -	upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
 -	ofs->upper_mnt = upper_mnt;
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static int ovl_make_workdir(struct ovl_fs *ofs, struct path *workpath)
 +static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
 -	struct vfsmount *mnt = ofs->upper_mnt;
 -	struct dentry *temp;
 +	struct path upperpath = { };
 +	struct path workpath = { };
 +	struct dentry *root_dentry;
 +	struct ovl_entry *oe;
 +	struct ovl_fs *ufs;
 +	const int *upper_stack_depth;
 +	int *overlay_stack_depth;
 +	struct path *stack = NULL;
 +	char *lowertmp;
 +	char *lower;
 +	unsigned int numlower;
 +	unsigned int stacklen = 0;
 +	unsigned int i;
 +	bool remote = false;
 +	struct cred *cred;
  	int err;
  
 -	err = mnt_want_write(mnt);
 -	if (err)
 -		return err;
 -
 -	ofs->workdir = ovl_workdir_create(ofs, OVL_WORKDIR_NAME, false);
 -	if (!ofs->workdir)
 -		goto out;
 -
 -	/*
 -	 * Upper should support d_type, else whiteouts are visible.  Given
 -	 * workdir and upper are on same fs, we can do iterate_dir() on
 -	 * workdir. This check requires successful creation of workdir in
 -	 * previous step.
 -	 */
 -	err = ovl_check_d_type_supported(workpath);
 -	if (err < 0)
 +	err = -ENOMEM;
 +	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
 +	if (!ufs)
  		goto out;
  
 -	/*
 -	 * We allowed this configuration and don't want to break users over
 -	 * kernel upgrade. So warn instead of erroring out.
 -	 */
 -	if (!err)
 -		pr_warn("overlayfs: upper fs needs to support d_type.\n");
 -
 -	/* Check if upper/work fs supports O_TMPFILE */
 -	temp = ovl_do_tmpfile(ofs->workdir, S_IFREG | 0);
 -	ofs->tmpfile = !IS_ERR(temp);
 -	if (ofs->tmpfile)
 -		dput(temp);
 -	else
 -		pr_warn("overlayfs: upper fs does not support tmpfile.\n");
 -
 -	/*
 -	 * Check if upper/work fs supports trusted.overlay.* xattr
 -	 */
 -	err = ovl_do_setxattr(ofs->workdir, OVL_XATTR_OPAQUE, "0", 1, 0);
 -	if (err) {
 -		ofs->noxattr = true;
 -		ofs->config.index = false;
 -		pr_warn("overlayfs: upper fs does not support xattr, falling back to index=off.\n");
 -		err = 0;
 -	} else {
 -		vfs_removexattr(ofs->workdir, OVL_XATTR_OPAQUE);
 -	}
 -
 -	/* Check if upper/work fs supports file handles */
 -	if (ofs->config.index &&
 -	    !ovl_can_decode_fh(ofs->workdir->d_sb)) {
 -		ofs->config.index = false;
 -		pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
 -	}
 -
 -out:
 -	mnt_drop_write(mnt);
 -	return err;
 -}
 -
 -static int ovl_get_workdir(struct ovl_fs *ofs, struct path *upperpath)
 -{
 -	int err;
 -	struct path workpath = { };
 -
 -	err = ovl_mount_dir(ofs->config.workdir, &workpath);
 +	ufs->config.index = ovl_index_def;
 +	err = ovl_parse_opt((char *) data, &ufs->config);
  	if (err)
 -		goto out;
 +		goto out_free_config;
  
  	err = -EINVAL;
 -	if (upperpath->mnt != workpath.mnt) {
 -		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 -		goto out;
 -	}
 -	if (!ovl_workdir_ok(workpath.dentry, upperpath->dentry)) {
 -		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 -		goto out;
 +	if (!ufs->config.lowerdir) {
 +		if (!silent)
 +			pr_err("overlayfs: missing 'lowerdir'\n");
 +		goto out_free_config;
  	}
  
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(workpath.dentry)) {
 -		ofs->workdir_locked = true;
 -	} else if (ofs->config.index) {
 -		pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_free_config;
  	}
 +	*overlay_stack_depth = 0;
  
 -	ofs->workbasedir = dget(workpath.dentry);
 -	err = ovl_make_workdir(ofs, &workpath);
 -	if (err)
 -		goto out;
 -
 -	err = 0;
 -out:
 -	path_put(&workpath);
 -
 -	return err;
 -}
 -
 -static int ovl_get_indexdir(struct ovl_fs *ofs, struct ovl_entry *oe,
 -			    struct path *upperpath)
 -{
 -	struct vfsmount *mnt = ofs->upper_mnt;
 -	int err;
 -
 -	err = mnt_want_write(mnt);
 -	if (err)
 -		return err;
 -
 -	/* Verify lower root is upper root origin */
 -	err = ovl_verify_origin(upperpath->dentry, oe->lowerstack[0].dentry,
 -				false, true);
 -	if (err) {
 -		pr_err("overlayfs: failed to verify upper root origin\n");
 -		goto out;
 -	}
 +	sb->s_maxbytes = MAX_LFS_FILESIZE;
 +	if (ufs->config.upperdir) {
 +		if (!ufs->config.workdir) {
 +			pr_err("overlayfs: missing 'workdir'\n");
 +			goto out_free_config;
 +		}
  
 -	ofs->indexdir = ovl_workdir_create(ofs, OVL_INDEXDIR_NAME, true);
 -	if (ofs->indexdir) {
 -		/* Verify upper root is index dir origin */
 -		err = ovl_verify_origin(ofs->indexdir, upperpath->dentry,
 -					true, true);
 +		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
  		if (err)
 -			pr_err("overlayfs: failed to verify index dir origin\n");
 -
 +			goto out_free_config;
 +
++<<<<<<< HEAD
 +		/* Upper fs should not be r/o */
 +		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
 +			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 +			err = -EINVAL;
 +			goto out_put_upperpath;
++=======
+ 		/* Cleanup bad/stale/orphan index entries */
+ 		if (!err)
+ 			err = ovl_indexdir_cleanup(ofs);
+ 	}
+ 	if (err || !ofs->indexdir)
+ 		pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
+ 
+ out:
+ 	mnt_drop_write(mnt);
+ 	return err;
+ }
+ 
+ static int ovl_get_lower_layers(struct ovl_fs *ofs, struct path *stack,
+ 				unsigned int numlower)
+ {
+ 	int err;
+ 	unsigned int i;
+ 
+ 	err = -ENOMEM;
+ 	ofs->lower_layers = kcalloc(numlower, sizeof(struct ovl_layer),
+ 				    GFP_KERNEL);
+ 	if (ofs->lower_layers == NULL)
+ 		goto out;
+ 	for (i = 0; i < numlower; i++) {
+ 		struct vfsmount *mnt;
+ 		dev_t dev;
+ 
+ 		err = get_anon_bdev(&dev);
+ 		if (err) {
+ 			pr_err("overlayfs: failed to get anonymous bdev for lowerpath\n");
+ 			goto out;
++>>>>>>> 1eff1a1deec7 (ovl: simplify arguments to ovl_check_origin_fh())
  		}
  
 -		mnt = clone_private_mount(&stack[i]);
 -		err = PTR_ERR(mnt);
 -		if (IS_ERR(mnt)) {
 -			pr_err("overlayfs: failed to clone lowerpath\n");
 -			free_anon_bdev(dev);
 -			goto out;
 +		err = ovl_check_namelen(&upperpath, ufs, ufs->config.upperdir);
 +		if (err)
 +			goto out_put_upperpath;
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(upperpath.dentry)) {
 +			ufs->upperdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 +			goto out_put_upperpath;
 +		} else {
 +			pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
  		}
 -		/*
 -		 * Make lower layers R/O.  That way fchmod/fchown on lower file
 -		 * will fail instead of modifying lower fs.
 -		 */
 -		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
  
 -		ofs->lower_layers[ofs->numlower].mnt = mnt;
 -		ofs->lower_layers[ofs->numlower].pseudo_dev = dev;
 -		ofs->lower_layers[ofs->numlower].idx = i + 1;
 -		ofs->numlower++;
 +		err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +		if (err)
 +			goto out_unlock_upperdentry;
  
 -		/* Check if all lower layers are on same sb */
 -		if (i == 0)
 -			ofs->same_sb = mnt->mnt_sb;
 -		else if (ofs->same_sb != mnt->mnt_sb)
 -			ofs->same_sb = NULL;
 -	}
 -	err = 0;
 -out:
 -	return err;
 -}
 +		err = -EINVAL;
 +		if (upperpath.mnt != workpath.mnt) {
 +			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +			goto out_put_workpath;
 +		}
 +		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +			goto out_put_workpath;
 +		}
  
 -static struct ovl_entry *ovl_get_lowerstack(struct super_block *sb,
 -					    struct ovl_fs *ofs)
 -{
 -	int err;
 -	char *lowertmp, *lower;
 -	struct path *stack = NULL;
 -	unsigned int stacklen, numlower = 0, i;
 -	bool remote = false;
 -	struct ovl_entry *oe;
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(workpath.dentry)) {
 +			ufs->workdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 +			goto out_put_workpath;
 +		} else {
 +			pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
 +
 +		ufs->workbasedir = workpath.dentry;
 +		upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +		err = -EOPNOTSUPP;
 +		if (!upper_stack_depth) {
 +			pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +			goto out_put_workpath;
 +		}
 +
 +		*overlay_stack_depth = *upper_stack_depth;
 +	}
  
  	err = -ENOMEM;
 -	lowertmp = kstrdup(ofs->config.lowerdir, GFP_KERNEL);
 +	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
  	if (!lowertmp)
 -		goto out_err;
 +		goto out_unlock_workdentry;
  
  	err = -EINVAL;
  	stacklen = ovl_split_lowerdirs(lowertmp);
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/readdir.c
* Unmerged path fs/overlayfs/super.c
