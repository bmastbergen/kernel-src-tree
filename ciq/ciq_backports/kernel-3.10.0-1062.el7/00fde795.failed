net: phy: core: use genphy version of callbacks read_status and config_aneg per default

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [kernel] phy: core: use genphy version of callbacks read_status and config_aneg per default (Ivan Vecera) [1655590]
Rebuild_FUZZ: 97.04%
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit 00fde79532d66d18cd0b21fdbd515f4b14078ccf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/00fde795.failed

read_status and config_aneg are the only mandatory callbacks and most
of the time the generic implementation is used by drivers.
So make the core fall back to the generic version if a driver doesn't
implement the respective callback.

Also currently the core doesn't seem to verify that drivers implement
the mandatory calls. If a driver doesn't do so we'd just get a NPE.
With this patch this potential issue doesn't exit any longer.

	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 00fde79532d66d18cd0b21fdbd515f4b14078ccf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/phy.h
diff --cc include/linux/phy.h
index 9542c61131f8,4962af37722a..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -429,20 -497,27 +429,20 @@@ struct phy_device 
   * flags: A bitfield defining certain other features this PHY
   *   supports (like interrupts)
   *
-  * The drivers must implement config_aneg and read_status.  All
-  * other functions are optional. Note that none of these
-  * functions should be called from interrupt time.  The goal is
-  * for the bus read/write functions to be able to block when the
-  * bus transaction is happening, and be freed up by an interrupt
-  * (The MPC85xx has this ability, though it is not currently
-  * supported in the driver).
+  * All functions are optional. If config_aneg or read_status
+  * are not implemented, the phy core uses the genphy versions.
+  * Note that none of these functions should be called from
+  * interrupt time. The goal is for the bus read/write functions
+  * to be able to block when the bus transaction is happening,
+  * and be freed up by an interrupt (The MPC85xx has this ability,
+  * though it is not currently supported in the driver).
   */
  struct phy_driver {
 -	struct mdio_driver_common mdiodrv;
  	u32 phy_id;
  	char *name;
 -	u32 phy_id_mask;
 +	unsigned int phy_id_mask;
  	u32 features;
  	u32 flags;
 -	const void *driver_data;
 -
 -	/*
 -	 * Called to issue a PHY software reset
 -	 */
 -	int (*soft_reset)(struct phy_device *phydev);
  
  	/*
  	 * Called to initialize the PHY,
@@@ -663,12 -839,26 +663,33 @@@ int phy_start_aneg(struct phy_device *p
  int phy_aneg_done(struct phy_device *phydev);
  
  int phy_stop_interrupts(struct phy_device *phydev);
 -int phy_restart_aneg(struct phy_device *phydev);
  
++<<<<<<< HEAD
 +static inline int phy_read_status(struct phy_device *phydev)
 +{
 +	return phydev->drv->read_status(phydev);
 +}
 +
++=======
+ #define phydev_err(_phydev, format, args...)	\
+ 	dev_err(&_phydev->mdio.dev, format, ##args)
+ 
+ #define phydev_dbg(_phydev, format, args...)	\
+ 	dev_dbg(&_phydev->mdio.dev, format, ##args)
+ 
+ static inline const char *phydev_name(const struct phy_device *phydev)
+ {
+ 	return dev_name(&phydev->mdio.dev);
+ }
+ 
+ void phy_attached_print(struct phy_device *phydev, const char *fmt, ...)
+ 	__printf(2, 3);
+ void phy_attached_info(struct phy_device *phydev);
+ 
+ /* Clause 22 PHY */
+ int genphy_config_init(struct phy_device *phydev);
+ int genphy_setup_forced(struct phy_device *phydev);
++>>>>>>> 00fde79532d6 (net: phy: core: use genphy version of callbacks read_status and config_aneg per default)
  int genphy_restart_aneg(struct phy_device *phydev);
  int genphy_config_aneg(struct phy_device *phydev);
  int genphy_aneg_done(struct phy_device *phydev);
@@@ -676,13 -866,41 +697,41 @@@ int genphy_update_link(struct phy_devic
  int genphy_read_status(struct phy_device *phydev);
  int genphy_suspend(struct phy_device *phydev);
  int genphy_resume(struct phy_device *phydev);
 -int genphy_loopback(struct phy_device *phydev, bool enable);
  int genphy_soft_reset(struct phy_device *phydev);
++<<<<<<< HEAD
++=======
+ static inline int genphy_no_soft_reset(struct phy_device *phydev)
+ {
+ 	return 0;
+ }
+ 
+ /* Clause 45 PHY */
+ int genphy_c45_restart_aneg(struct phy_device *phydev);
+ int genphy_c45_aneg_done(struct phy_device *phydev);
+ int genphy_c45_read_link(struct phy_device *phydev, u32 mmd_mask);
+ int genphy_c45_read_lpa(struct phy_device *phydev);
+ int genphy_c45_read_pma(struct phy_device *phydev);
+ int genphy_c45_pma_setup_forced(struct phy_device *phydev);
+ int genphy_c45_an_disable_aneg(struct phy_device *phydev);
+ 
+ static inline int phy_read_status(struct phy_device *phydev)
+ {
+ 	if (!phydev->drv)
+ 		return -EIO;
+ 
+ 	if (phydev->drv->read_status)
+ 		return phydev->drv->read_status(phydev);
+ 	else
+ 		return genphy_read_status(phydev);
+ }
+ 
++>>>>>>> 00fde79532d6 (net: phy: core: use genphy version of callbacks read_status and config_aneg per default)
  void phy_driver_unregister(struct phy_driver *drv);
  void phy_drivers_unregister(struct phy_driver *drv, int n);
 -int phy_driver_register(struct phy_driver *new_driver, struct module *owner);
 -int phy_drivers_register(struct phy_driver *new_driver, int n,
 -			 struct module *owner);
 +int phy_driver_register(struct phy_driver *new_driver);
 +int phy_drivers_register(struct phy_driver *new_driver, int n);
  void phy_state_machine(struct work_struct *work);
 -void phy_change(struct phy_device *phydev);
 -void phy_change_work(struct work_struct *work);
 +void phy_change(struct work_struct *work);
  void phy_mac_interrupt(struct phy_device *phydev, int new_link);
  void phy_start_machine(struct phy_device *phydev);
  void phy_stop_machine(struct phy_device *phydev);
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 9e5ca8eeda8a..aacf8aceab15 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -482,7 +482,10 @@ int phy_start_aneg(struct phy_device *phydev)
 	/* Invalidate LP advertising flags */
 	phydev->lp_advertising = 0;
 
-	err = phydev->drv->config_aneg(phydev);
+	if (phydev->drv->config_aneg)
+		err = phydev->drv->config_aneg(phydev);
+	else
+		err = genphy_config_aneg(phydev);
 	if (err < 0)
 		goto out_unlock;
 
* Unmerged path include/linux/phy.h
