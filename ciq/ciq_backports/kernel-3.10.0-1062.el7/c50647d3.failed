nfp: flower: ignore duplicate cb requests for same rule

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author John Hurley <john.hurley@netronome.com>
commit c50647d3e8fd4149ecd78e9a234336e727f48107
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c50647d3.failed

If a flower rule has a repr both as ingress and egress port then 2
callbacks may be generated for the same rule request.

Add an indicator to each flow as to whether or not it was added from an
ingress registered cb. If so then ignore add/del/stat requests to it from
an egress cb.

	Signed-off-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c50647d3e8fd4149ecd78e9a234336e727f48107)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/offload.c
diff --cc drivers/net/ethernet/netronome/nfp/flower/offload.c
index a384628b25b8,70ec9d821b91..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/offload.c
@@@ -402,9 -404,20 +404,24 @@@ nfp_flower_add_offload(struct nfp_app *
  	struct nfp_flower_priv *priv = app->priv;
  	struct nfp_fl_payload *flow_pay;
  	struct nfp_fl_key_ls *key_layer;
++<<<<<<< HEAD
 +	unsigned long fl_key;
++=======
+ 	struct net_device *ingr_dev;
++>>>>>>> c50647d3e8fd (nfp: flower: ignore duplicate cb requests for same rule)
  	int err;
  
+ 	ingr_dev = egress ? NULL : netdev;
+ 	flow_pay = nfp_flower_search_fl_table(app, flow->cookie, ingr_dev,
+ 					      NFP_FL_STATS_CTX_DONT_CARE);
+ 	if (flow_pay) {
+ 		/* Ignore as duplicate if it has been added by different cb. */
+ 		if (flow_pay->ingress_offload && egress)
+ 			return 0;
+ 		else
+ 			return -EOPNOTSUPP;
+ 	}
+ 
  	key_layer = kmalloc(sizeof(*key_layer), GFP_KERNEL);
  	if (!key_layer)
  		return -ENOMEM;
@@@ -476,11 -492,14 +493,11 @@@ nfp_flower_del_offload(struct nfp_app *
  {
  	struct nfp_port *port = nfp_port_from_netdev(netdev);
  	struct nfp_fl_payload *nfp_flow;
 -	struct net_device *ingr_dev;
  	int err;
  
 -	ingr_dev = egress ? NULL : netdev;
 -	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie, ingr_dev,
 -					      NFP_FL_STATS_CTX_DONT_CARE);
 +	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie);
  	if (!nfp_flow)
- 		return -ENOENT;
+ 		return egress ? 0 : -ENOENT;
  
  	err = nfp_modify_flow_metadata(app, nfp_flow);
  	if (err)
diff --git a/drivers/net/ethernet/netronome/nfp/flower/main.h b/drivers/net/ethernet/netronome/nfp/flower/main.h
index 4906612ceb9a..eecbb25fc530 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/main.h
+++ b/drivers/net/ethernet/netronome/nfp/flower/main.h
@@ -196,6 +196,7 @@ struct nfp_fl_payload {
 	char *unmasked_data;
 	char *mask_data;
 	char *action_data;
+	bool ingress_offload;
 };
 
 struct nfp_fl_stats_frame {
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/offload.c
