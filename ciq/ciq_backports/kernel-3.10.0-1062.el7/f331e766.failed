x86/platform/UV: Use efi_runtime_lock to serialise BIOS calls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] platform/uv: Use efi_runtime_lock to serialise BIOS calls (Frank Ramsay) [1677704]
Rebuild_FUZZ: 96.61%
commit-author Hedi Berriche <hedi.berriche@hpe.com>
commit f331e766c4be33f4338574f3c9f7f77e98ab4571
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f331e766.failed

Calls into UV firmware must be protected against concurrency, expose the
efi_runtime_lock to the UV platform, and use it to serialise UV BIOS
calls.

	Signed-off-by: Hedi Berriche <hedi.berriche@hpe.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Reviewed-by: Russ Anderson <rja@hpe.com>
	Reviewed-by: Dimitri Sivanich <sivanich@hpe.com>
	Reviewed-by: Mike Travis <mike.travis@hpe.com>
	Cc: Andy Shevchenko <andy@infradead.org>
	Cc: Bhupesh Sharma <bhsharma@redhat.com>
	Cc: Darren Hart <dvhart@infradead.org>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: linux-efi <linux-efi@vger.kernel.org>
	Cc: platform-driver-x86@vger.kernel.org
	Cc: stable@vger.kernel.org # v4.9+
	Cc: Steve Wahl <steve.wahl@hpe.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: x86-ml <x86@kernel.org>
Link: https://lkml.kernel.org/r/20190213193413.25560-5-hedi.berriche@hpe.com
(cherry picked from commit f331e766c4be33f4338574f3c9f7f77e98ab4571)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/runtime-wrappers.c
diff --cc drivers/firmware/efi/runtime-wrappers.c
index dcc976822484,e2abfdb5cee6..000000000000
--- a/drivers/firmware/efi/runtime-wrappers.c
+++ b/drivers/firmware/efi/runtime-wrappers.c
@@@ -43,12 -105,136 +43,106 @@@ void efi_call_virt_check_flags(unsigne
  	local_irq_restore(flags);
  }
  
 -/*
 - * According to section 7.1 of the UEFI spec, Runtime Services are not fully
 - * reentrant, and there are particular combinations of calls that need to be
 - * serialized. (source: UEFI Specification v2.4A)
 - *
 - * Table 31. Rules for Reentry Into Runtime Services
 - * +------------------------------------+-------------------------------+
 - * | If previous call is busy in	| Forbidden to call		|
 - * +------------------------------------+-------------------------------+
 - * | Any				| SetVirtualAddressMap()	|
 - * +------------------------------------+-------------------------------+
 - * | ConvertPointer()			| ConvertPointer()		|
 - * +------------------------------------+-------------------------------+
 - * | SetVariable()			| ResetSystem()			|
 - * | UpdateCapsule()			|				|
 - * | SetTime()				|				|
 - * | SetWakeupTime()			|				|
 - * | GetNextHighMonotonicCount()	|				|
 - * +------------------------------------+-------------------------------+
 - * | GetVariable()			| GetVariable()			|
 - * | GetNextVariableName()		| GetNextVariableName()		|
 - * | SetVariable()			| SetVariable()			|
 - * | QueryVariableInfo()		| QueryVariableInfo()		|
 - * | UpdateCapsule()			| UpdateCapsule()		|
 - * | QueryCapsuleCapabilities()		| QueryCapsuleCapabilities()	|
 - * | GetNextHighMonotonicCount()	| GetNextHighMonotonicCount()	|
 - * +------------------------------------+-------------------------------+
 - * | GetTime()				| GetTime()			|
 - * | SetTime()				| SetTime()			|
 - * | GetWakeupTime()			| GetWakeupTime()		|
 - * | SetWakeupTime()			| SetWakeupTime()		|
 - * +------------------------------------+-------------------------------+
 - *
 - * Due to the fact that the EFI pstore may write to the variable store in
 - * interrupt context, we need to use a lock for at least the groups that
 - * contain SetVariable() and QueryVariableInfo(). That leaves little else, as
 - * none of the remaining functions are actually ever called at runtime.
 - * So let's just use a single lock to serialize all Runtime Services calls.
 +/* As per commit ef68c8f87ed1 ("x86: Serialize EFI time accesses on rtc_lock"),
 + * the EFI specification requires that callers of the time related runtime
 + * functions serialize with other CMOS accesses in the kernel, as the EFI time
 + * functions may choose to also use the legacy CMOS RTC.
   */
++<<<<<<< HEAD
 +__weak DEFINE_SPINLOCK(rtc_lock);
++=======
+ static DEFINE_SEMAPHORE(efi_runtime_lock);
+ 
+ /*
+  * Expose the EFI runtime lock to the UV platform
+  */
+ #ifdef CONFIG_X86_UV
+ extern struct semaphore __efi_uv_runtime_lock __alias(efi_runtime_lock);
+ #endif
+ 
+ /*
+  * Calls the appropriate efi_runtime_service() with the appropriate
+  * arguments.
+  *
+  * Semantics followed by efi_call_rts() to understand efi_runtime_work:
+  * 1. If argument was a pointer, recast it from void pointer to original
+  * pointer type.
+  * 2. If argument was a value, recast it from void pointer to original
+  * pointer type and dereference it.
+  */
+ static void efi_call_rts(struct work_struct *work)
+ {
+ 	void *arg1, *arg2, *arg3, *arg4, *arg5;
+ 	efi_status_t status = EFI_NOT_FOUND;
+ 
+ 	arg1 = efi_rts_work.arg1;
+ 	arg2 = efi_rts_work.arg2;
+ 	arg3 = efi_rts_work.arg3;
+ 	arg4 = efi_rts_work.arg4;
+ 	arg5 = efi_rts_work.arg5;
+ 
+ 	switch (efi_rts_work.efi_rts_id) {
+ 	case GET_TIME:
+ 		status = efi_call_virt(get_time, (efi_time_t *)arg1,
+ 				       (efi_time_cap_t *)arg2);
+ 		break;
+ 	case SET_TIME:
+ 		status = efi_call_virt(set_time, (efi_time_t *)arg1);
+ 		break;
+ 	case GET_WAKEUP_TIME:
+ 		status = efi_call_virt(get_wakeup_time, (efi_bool_t *)arg1,
+ 				       (efi_bool_t *)arg2, (efi_time_t *)arg3);
+ 		break;
+ 	case SET_WAKEUP_TIME:
+ 		status = efi_call_virt(set_wakeup_time, *(efi_bool_t *)arg1,
+ 				       (efi_time_t *)arg2);
+ 		break;
+ 	case GET_VARIABLE:
+ 		status = efi_call_virt(get_variable, (efi_char16_t *)arg1,
+ 				       (efi_guid_t *)arg2, (u32 *)arg3,
+ 				       (unsigned long *)arg4, (void *)arg5);
+ 		break;
+ 	case GET_NEXT_VARIABLE:
+ 		status = efi_call_virt(get_next_variable, (unsigned long *)arg1,
+ 				       (efi_char16_t *)arg2,
+ 				       (efi_guid_t *)arg3);
+ 		break;
+ 	case SET_VARIABLE:
+ 		status = efi_call_virt(set_variable, (efi_char16_t *)arg1,
+ 				       (efi_guid_t *)arg2, *(u32 *)arg3,
+ 				       *(unsigned long *)arg4, (void *)arg5);
+ 		break;
+ 	case QUERY_VARIABLE_INFO:
+ 		status = efi_call_virt(query_variable_info, *(u32 *)arg1,
+ 				       (u64 *)arg2, (u64 *)arg3, (u64 *)arg4);
+ 		break;
+ 	case GET_NEXT_HIGH_MONO_COUNT:
+ 		status = efi_call_virt(get_next_high_mono_count, (u32 *)arg1);
+ 		break;
+ 	case UPDATE_CAPSULE:
+ 		status = efi_call_virt(update_capsule,
+ 				       (efi_capsule_header_t **)arg1,
+ 				       *(unsigned long *)arg2,
+ 				       *(unsigned long *)arg3);
+ 		break;
+ 	case QUERY_CAPSULE_CAPS:
+ 		status = efi_call_virt(query_capsule_caps,
+ 				       (efi_capsule_header_t **)arg1,
+ 				       *(unsigned long *)arg2, (u64 *)arg3,
+ 				       (int *)arg4);
+ 		break;
+ 	default:
+ 		/*
+ 		 * Ideally, we should never reach here because a caller of this
+ 		 * function should have put the right efi_runtime_service()
+ 		 * function identifier into efi_rts_work->efi_rts_id
+ 		 */
+ 		pr_err("Requested executing invalid EFI Runtime Service.\n");
+ 	}
+ 	efi_rts_work.status = status;
+ 	complete(&efi_rts_work.efi_rts_comp);
+ }
++>>>>>>> f331e766c4be (x86/platform/UV: Use efi_runtime_lock to serialise BIOS calls)
  
  static efi_status_t virt_efi_get_time(efi_time_t *tm, efi_time_cap_t *tc)
  {
diff --git a/arch/x86/include/asm/uv/bios.h b/arch/x86/include/asm/uv/bios.h
index 8c6ac271b5b3..8cfccc3cbbf4 100644
--- a/arch/x86/include/asm/uv/bios.h
+++ b/arch/x86/include/asm/uv/bios.h
@@ -48,7 +48,8 @@ enum {
 	BIOS_STATUS_SUCCESS		=  0,
 	BIOS_STATUS_UNIMPLEMENTED	= -ENOSYS,
 	BIOS_STATUS_EINVAL		= -EINVAL,
-	BIOS_STATUS_UNAVAIL		= -EBUSY
+	BIOS_STATUS_UNAVAIL		= -EBUSY,
+	BIOS_STATUS_ABORT		= -EINTR,
 };
 
 /* Address map parameters */
@@ -162,4 +163,9 @@ extern long system_serial_number;
 
 extern struct kobject *sgi_uv_kobj;	/* /sys/firmware/sgi_uv */
 
+/*
+ * EFI runtime lock; cf. firmware/efi/runtime-wrappers.c for details
+ */
+extern struct semaphore __efi_uv_runtime_lock;
+
 #endif /* _ASM_X86_UV_BIOS_H */
diff --git a/arch/x86/platform/uv/bios_uv.c b/arch/x86/platform/uv/bios_uv.c
index 3b368cd38329..ae549b74c9c9 100644
--- a/arch/x86/platform/uv/bios_uv.c
+++ b/arch/x86/platform/uv/bios_uv.c
@@ -29,7 +29,8 @@
 
 struct uv_systab *uv_systab;
 
-s64 uv_bios_call(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3, u64 a4, u64 a5)
+static s64 __uv_bios_call(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3,
+			u64 a4, u64 a5)
 {
 	struct uv_systab *tab = uv_systab;
 	s64 ret;
@@ -51,6 +52,19 @@ s64 uv_bios_call(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3, u64 a4, u64 a5)
 
 	return ret;
 }
+
+s64 uv_bios_call(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3, u64 a4, u64 a5)
+{
+	s64 ret;
+
+	if (down_interruptible(&__efi_uv_runtime_lock))
+		return BIOS_STATUS_ABORT;
+
+	ret = __uv_bios_call(which, a1, a2, a3, a4, a5);
+	up(&__efi_uv_runtime_lock);
+
+	return ret;
+}
 EXPORT_SYMBOL_GPL(uv_bios_call);
 
 s64 uv_bios_call_irqsave(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3,
@@ -59,10 +73,15 @@ s64 uv_bios_call_irqsave(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3,
 	unsigned long bios_flags;
 	s64 ret;
 
+	if (down_interruptible(&__efi_uv_runtime_lock))
+		return BIOS_STATUS_ABORT;
+
 	local_irq_save(bios_flags);
-	ret = uv_bios_call(which, a1, a2, a3, a4, a5);
+	ret = __uv_bios_call(which, a1, a2, a3, a4, a5);
 	local_irq_restore(bios_flags);
 
+	up(&__efi_uv_runtime_lock);
+
 	return ret;
 }
 
* Unmerged path drivers/firmware/efi/runtime-wrappers.c
