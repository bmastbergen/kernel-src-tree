IB/mlx4: Create slave AH's directly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit 5e62d5ff1b9a6573d0d6b411893b1c17ccc21ce7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/5e62d5ff.failed

Since slave GID's do not exist in the core gid table we can no longer use
the core code to help do this without creating inconsistencies. Directly
create the AH using mlx4 internal APIs.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Reviewed-by: Jack Morgenstein <jackm@dev.mellanox.co.il>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 5e62d5ff1b9a6573d0d6b411893b1c17ccc21ce7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx4/ah.c
diff --cc drivers/infiniband/hw/mlx4/ah.c
index efff794c66a1,e9e3a6f390db..000000000000
--- a/drivers/infiniband/hw/mlx4/ah.c
+++ b/drivers/infiniband/hw/mlx4/ah.c
@@@ -96,17 -95,26 +96,39 @@@ static struct ib_ah *create_iboe_ah(str
  		is_mcast = 1;
  
  	memcpy(ah->av.eth.mac, ah_attr->roce.dmac, ETH_ALEN);
 +	ret = ib_get_cached_gid(pd->device, rdma_ah_get_port_num(ah_attr),
 +				grh->sgid_index, &sgid, &gid_attr);
 +	if (ret)
 +		return ERR_PTR(ret);
  	eth_zero_addr(ah->av.eth.s_mac);
++<<<<<<< HEAD
 +	if (gid_attr.ndev) {
 +		if (is_vlan_dev(gid_attr.ndev))
 +			vlan_tag = vlan_dev_vlan_id(gid_attr.ndev);
 +		memcpy(ah->av.eth.s_mac, gid_attr.ndev->dev_addr, ETH_ALEN);
 +		dev_put(gid_attr.ndev);
 +	}
++=======
+ 
+ 	/*
+ 	 * If sgid_attr is NULL we are being called by mlx4_ib_create_ah_slave
+ 	 * and we are directly creating an AV for a slave's gid_index.
+ 	 */
+ 	gid_attr = ah_attr->grh.sgid_attr;
+ 	if (gid_attr) {
+ 		if (is_vlan_dev(gid_attr->ndev))
+ 			vlan_tag = vlan_dev_vlan_id(gid_attr->ndev);
+ 		memcpy(ah->av.eth.s_mac, gid_attr->ndev->dev_addr, ETH_ALEN);
+ 		ret = mlx4_ib_gid_index_to_real_index(ibdev, gid_attr);
+ 		if (ret < 0)
+ 			return ERR_PTR(ret);
+ 		ah->av.eth.gid_index = ret;
+ 	} else {
+ 		/* mlx4_ib_create_ah_slave fills in the s_mac and the vlan */
+ 		ah->av.eth.gid_index = ah_attr->grh.sgid_index;
+ 	}
+ 
++>>>>>>> 5e62d5ff1b9a (IB/mlx4: Create slave AH's directly)
  	if (vlan_tag < 0x1000)
  		vlan_tag |= (rdma_ah_get_sl(ah_attr) & 7) << 13;
  	ah->av.eth.port_pd = cpu_to_be32(to_mpd(pd)->pdn |
* Unmerged path drivers/infiniband/hw/mlx4/ah.c
diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c
index d604b3d5aa3e..ae3a951ac63e 100644
--- a/drivers/infiniband/hw/mlx4/mad.c
+++ b/drivers/infiniband/hw/mlx4/mad.c
@@ -1367,13 +1367,10 @@ int mlx4_ib_send_to_wire(struct mlx4_ib_dev *dev, int slave, u8 port,
 	struct mlx4_mad_snd_buf *sqp_mad;
 	struct ib_ah *ah;
 	struct ib_qp *send_qp = NULL;
-	struct ib_global_route *grh;
 	unsigned wire_tx_ix = 0;
 	int ret = 0;
 	u16 wire_pkey_ix;
 	int src_qpnum;
-	u8 sgid_index;
-
 
 	sqp_ctx = dev->sriov.sqps[port-1];
 
@@ -1394,16 +1391,11 @@ int mlx4_ib_send_to_wire(struct mlx4_ib_dev *dev, int slave, u8 port,
 	send_qp = sqp->qp;
 
 	/* create ah */
-	grh = rdma_ah_retrieve_grh(attr);
-	sgid_index = grh->sgid_index;
-	grh->sgid_index = 0;
-	ah = rdma_create_ah(sqp_ctx->pd, attr);
+	ah = mlx4_ib_create_ah_slave(sqp_ctx->pd, attr,
+				     rdma_ah_retrieve_grh(attr)->sgid_index,
+				     s_mac, vlan_id);
 	if (IS_ERR(ah))
 		return -ENOMEM;
-	grh->sgid_index = sgid_index;
-	to_mah(ah)->av.ib.gid_index = sgid_index;
-	/* get rid of force-loopback bit */
-	to_mah(ah)->av.ib.port_pd &= cpu_to_be32(0x7FFFFFFF);
 	spin_lock(&sqp->tx_lock);
 	if (sqp->tx_ix_head - sqp->tx_ix_tail >=
 	    (MLX4_NUM_TUNNEL_BUFS - 1))
@@ -1445,12 +1437,6 @@ int mlx4_ib_send_to_wire(struct mlx4_ib_dev *dev, int slave, u8 port,
 	wr.wr.num_sge = 1;
 	wr.wr.opcode = IB_WR_SEND;
 	wr.wr.send_flags = IB_SEND_SIGNALED;
-	if (s_mac)
-		memcpy(to_mah(ah)->av.eth.s_mac, s_mac, 6);
-	if (vlan_id < 0x1000)
-		vlan_id |= (rdma_ah_get_sl(attr) & 7) << 13;
-	to_mah(ah)->av.eth.vlan = cpu_to_be16(vlan_id);
-
 
 	ret = ib_post_send(send_qp, &wr.wr, &bad_wr);
 	if (!ret)
@@ -1461,7 +1447,7 @@ int mlx4_ib_send_to_wire(struct mlx4_ib_dev *dev, int slave, u8 port,
 	spin_unlock(&sqp->tx_lock);
 	sqp->tx_ring[wire_tx_ix].ah = NULL;
 out:
-	rdma_destroy_ah(ah);
+	mlx4_ib_destroy_ah(ah);
 	return ret;
 }
 
diff --git a/drivers/infiniband/hw/mlx4/mlx4_ib.h b/drivers/infiniband/hw/mlx4/mlx4_ib.h
index e5a365bdbe45..1a0fad30633b 100644
--- a/drivers/infiniband/hw/mlx4/mlx4_ib.h
+++ b/drivers/infiniband/hw/mlx4/mlx4_ib.h
@@ -760,6 +760,10 @@ void mlx4_ib_cq_clean(struct mlx4_ib_cq *cq, u32 qpn, struct mlx4_ib_srq *srq);
 
 struct ib_ah *mlx4_ib_create_ah(struct ib_pd *pd, struct rdma_ah_attr *ah_attr,
 				struct ib_udata *udata);
+struct ib_ah *mlx4_ib_create_ah_slave(struct ib_pd *pd,
+				      struct rdma_ah_attr *ah_attr,
+				      int slave_sgid_index, u8 *s_mac,
+				      u16 vlan_tag);
 int mlx4_ib_query_ah(struct ib_ah *ibah, struct rdma_ah_attr *ah_attr);
 int mlx4_ib_destroy_ah(struct ib_ah *ah);
 
