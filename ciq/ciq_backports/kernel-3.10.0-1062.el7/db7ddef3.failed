mm: move tlb_table_flush to tlb_flush_mmu_free

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [mm] move tlb_table_flush to tlb_flush_mmu_free (Vitaly Kuznetsov) [1448188]
Rebuild_FUZZ: 95.45%
commit-author Nicholas Piggin <npiggin@gmail.com>
commit db7ddef301128dad394f1c0f77027f86ee9a4edb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/db7ddef3.failed

There is no need to call this from tlb_flush_mmu_tlbonly, it logically
belongs with tlb_flush_mmu_free.  This makes future fixes simpler.

[ This was originally done to allow code consolidation for the
  mmu_notifier fix, but it also ends up helping simplify the
  HAVE_RCU_TABLE_INVALIDATE fix.    - Linus ]

	Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
	Acked-by: Will Deacon <will.deacon@arm.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: stable@kernel.org
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit db7ddef301128dad394f1c0f77027f86ee9a4edb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory.c
diff --cc mm/memory.c
index 992044080678,9b135a35f99c..000000000000
--- a/mm/memory.c
+++ b/mm/memory.c
@@@ -245,22 -233,29 +245,36 @@@ void tlb_gather_mmu(struct mmu_gather *
  #ifdef CONFIG_HAVE_RCU_TABLE_FREE
  	tlb->batch = NULL;
  #endif
 -	tlb->page_size = 0;
 -
 -	__tlb_reset_range(tlb);
  }
  
 -static void tlb_flush_mmu_tlbonly(struct mmu_gather *tlb)
 +void tlb_flush_mmu(struct mmu_gather *tlb)
  {
 -	if (!tlb->end)
 -		return;
 +	struct mmu_gather_batch *batch;
  
 +	if (!tlb->need_flush)
 +		return;
 +	tlb->need_flush = 0;
  	tlb_flush(tlb);
  	mmu_notifier_invalidate_range(tlb->mm, tlb->start, tlb->end);
++<<<<<<< HEAD
 +#ifdef CONFIG_HAVE_RCU_TABLE_FREE
 +	tlb_table_flush(tlb);
 +#endif
 +
 +	for (batch = &tlb->local; batch; batch = batch->next) {
++=======
+ 	__tlb_reset_range(tlb);
+ }
+ 
+ static void tlb_flush_mmu_free(struct mmu_gather *tlb)
+ {
+ 	struct mmu_gather_batch *batch;
+ 
+ #ifdef CONFIG_HAVE_RCU_TABLE_FREE
+ 	tlb_table_flush(tlb);
+ #endif
+ 	for (batch = &tlb->local; batch && batch->nr; batch = batch->next) {
++>>>>>>> db7ddef30112 (mm: move tlb_table_flush to tlb_flush_mmu_free)
  		free_pages_and_swap_cache(batch->pages, batch->nr);
  		batch->nr = 0;
  	}
* Unmerged path mm/memory.c
