geneve, vxlan: Don't set exceptions if skb->len < mtu

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Stefano Brivio <sbrivio@redhat.com>
commit 6b4f92af3d59e882d3ba04c44a815266890d188f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6b4f92af.failed

We shouldn't abuse exceptions: if the destination MTU is already higher
than what we're transmitting, no exception should be created.

Fixes: 52a589d51f10 ("geneve: update skb dst pmtu on tx path")
Fixes: a93bf0ff4490 ("vxlan: update skb dst pmtu on tx path")
	Signed-off-by: Stefano Brivio <sbrivio@redhat.com>
	Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6b4f92af3d59e882d3ba04c44a815266890d188f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
#	drivers/net/vxlan.c
#	include/net/dst.h
diff --cc drivers/net/geneve.c
index 33df2da67472,493cd382b8aa..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -879,12 -830,8 +879,17 @@@ static int geneve_xmit_skb(struct sk_bu
  	if (IS_ERR(rt))
  		return PTR_ERR(rt);
  
++<<<<<<< HEAD
 +	if (skb_dst(skb)) {
 +		int mtu = dst_mtu(&rt->dst) - GENEVE_IPV4_HLEN -
 +			  info->options_len;
 +
 +		skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL, skb, mtu);
 +	}
++=======
+ 	skb_tunnel_check_pmtu(skb, &rt->dst,
+ 			      GENEVE_IPV4_HLEN + info->options_len);
++>>>>>>> 6b4f92af3d59 (geneve, vxlan: Don't set exceptions if skb->len < mtu)
  
  	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
  	if (geneve->collect_md) {
@@@ -925,11 -872,7 +930,15 @@@ static int geneve6_xmit_skb(struct sk_b
  	if (IS_ERR(dst))
  		return PTR_ERR(dst);
  
++<<<<<<< HEAD
 +	if (skb_dst(skb)) {
 +		int mtu = dst_mtu(dst) - GENEVE_IPV6_HLEN - info->options_len;
 +
 +		skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL, skb, mtu);
 +	}
++=======
+ 	skb_tunnel_check_pmtu(skb, dst, GENEVE_IPV6_HLEN + info->options_len);
++>>>>>>> 6b4f92af3d59 (geneve, vxlan: Don't set exceptions if skb->len < mtu)
  
  	sport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);
  	if (geneve->collect_md) {
diff --cc drivers/net/vxlan.c
index e093c26c92e0,27bd586b94b0..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -2164,12 -2194,7 +2164,16 @@@ static void vxlan_xmit_one(struct sk_bu
  		}
  
  		ndst = &rt->dst;
++<<<<<<< HEAD
 +		if (skb_dst(skb)) {
 +			int mtu = dst_mtu(ndst) - VXLAN_HEADROOM;
 +
 +			skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL,
 +						       skb, mtu);
 +		}
++=======
+ 		skb_tunnel_check_pmtu(skb, ndst, VXLAN_HEADROOM);
++>>>>>>> 6b4f92af3d59 (geneve, vxlan: Don't set exceptions if skb->len < mtu)
  
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
@@@ -2206,12 -2231,7 +2210,16 @@@
  				goto out_unlock;
  		}
  
++<<<<<<< HEAD
 +		if (skb_dst(skb)) {
 +			int mtu = dst_mtu(ndst) - VXLAN6_HEADROOM;
 +
 +			skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL,
 +						       skb, mtu);
 +		}
++=======
+ 		skb_tunnel_check_pmtu(skb, ndst, VXLAN6_HEADROOM);
++>>>>>>> 6b4f92af3d59 (geneve, vxlan: Don't set exceptions if skb->len < mtu)
  
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip6_dst_hoplimit(ndst);
diff --cc include/net/dst.h
index c7e9ba7e97b4,6cf0870414c7..000000000000
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@@ -588,4 -519,22 +588,25 @@@ static inline struct xfrm_state *dst_xf
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ static inline void skb_dst_update_pmtu(struct sk_buff *skb, u32 mtu)
+ {
+ 	struct dst_entry *dst = skb_dst(skb);
+ 
+ 	if (dst && dst->ops->update_pmtu)
+ 		dst->ops->update_pmtu(dst, NULL, skb, mtu);
+ }
+ 
+ static inline void skb_tunnel_check_pmtu(struct sk_buff *skb,
+ 					 struct dst_entry *encap_dst,
+ 					 int headroom)
+ {
+ 	u32 encap_mtu = dst_mtu(encap_dst);
+ 
+ 	if (skb->len > encap_mtu - headroom)
+ 		skb_dst_update_pmtu(skb, encap_mtu - headroom);
+ }
+ 
++>>>>>>> 6b4f92af3d59 (geneve, vxlan: Don't set exceptions if skb->len < mtu)
  #endif /* _NET_DST_H */
* Unmerged path drivers/net/geneve.c
* Unmerged path drivers/net/vxlan.c
* Unmerged path include/net/dst.h
