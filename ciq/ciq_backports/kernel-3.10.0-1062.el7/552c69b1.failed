KVM: nVMX: Do not inherit quadrant and invalid for the root shadow EPT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 552c69b1dc714854a5f4e27d37a43c6d797adf7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/552c69b1.failed

Explicitly zero out quadrant and invalid instead of inheriting them from
the root_mmu.  Functionally, this patch is a nop as we (should) never
set quadrant for a direct mapped (EPT) root_mmu and nested EPT is only
allowed if EPT is used for L1, and the root_mmu will never be invalid at
this point.

Explicitly setting flags sets the stage for repurposing the legacy
paging bits in role, e.g. nxe, cr0_wp, and sm{a,e}p_andnot_wp, at which
point 'smm' would be the only flag to be inherited from root_mmu.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 552c69b1dc714854a5f4e27d37a43c6d797adf7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu.c
diff --cc arch/x86/kvm/mmu.c
index d16e6f650c80,01bb090aaa5c..000000000000
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@@ -4497,14 -4914,47 +4497,43 @@@ void kvm_init_shadow_mmu(struct kvm_vcp
  }
  EXPORT_SYMBOL_GPL(kvm_init_shadow_mmu);
  
++<<<<<<< HEAD
++=======
+ static union kvm_mmu_role
+ kvm_calc_shadow_ept_root_page_role(struct kvm_vcpu *vcpu, bool accessed_dirty,
+ 				   bool execonly)
+ {
+ 	union kvm_mmu_role role = {0};
+ 	union kvm_mmu_page_role root_base = vcpu->arch.root_mmu.mmu_role.base;
+ 
+ 	/* Legacy paging and SMM flags are inherited from root_mmu */
+ 	role.base.smm = root_base.smm;
+ 	role.base.nxe = root_base.nxe;
+ 	role.base.cr0_wp = root_base.cr0_wp;
+ 	role.base.smep_andnot_wp = root_base.smep_andnot_wp;
+ 	role.base.smap_andnot_wp = root_base.smap_andnot_wp;
+ 
+ 	role.base.level = PT64_ROOT_4LEVEL;
+ 	role.base.direct = false;
+ 	role.base.ad_disabled = !accessed_dirty;
+ 	role.base.guest_mode = true;
+ 	role.base.access = ACC_ALL;
+ 
+ 	role.ext = kvm_calc_mmu_role_ext(vcpu);
+ 	role.ext.execonly = execonly;
+ 
+ 	return role;
+ }
+ 
++>>>>>>> 552c69b1dc71 (KVM: nVMX: Do not inherit quadrant and invalid for the root shadow EPT)
  void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly,
 -			     bool accessed_dirty, gpa_t new_eptp)
 +			     bool accessed_dirty)
  {
 -	struct kvm_mmu *context = vcpu->arch.mmu;
 -	union kvm_mmu_role new_role =
 -		kvm_calc_shadow_ept_root_page_role(vcpu, accessed_dirty,
 -						   execonly);
 +	struct kvm_mmu *context = &vcpu->arch.mmu;
  
 -	__kvm_mmu_new_cr3(vcpu, new_eptp, new_role.base, false);
 +	MMU_WARN_ON(VALID_PAGE(context->root_hpa));
  
 -	new_role.base.word &= mmu_base_role_mask.word;
 -	if (new_role.as_u64 == context->mmu_role.as_u64)
 -		return;
 -
 -	context->shadow_root_level = PT64_ROOT_4LEVEL;
 +	context->shadow_root_level = kvm_x86_ops->get_tdp_level();
  
  	context->nx = true;
  	context->ept_ad = accessed_dirty;
* Unmerged path arch/x86/kvm/mmu.c
