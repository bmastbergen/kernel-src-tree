selinux: overhaul sidtab to fix bug and improve performance

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ondrej Mosnacek <omosnace@redhat.com>
commit ee1a84fdfeedfd7362e9a8a8f15fedc3482ade2d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ee1a84fd.failed

Before this patch, during a policy reload the sidtab would become frozen
and trying to map a new context to SID would be unable to add a new
entry to sidtab and fail with -ENOMEM.

Such failures are usually propagated into userspace, which has no way of
distignuishing them from actual allocation failures and thus doesn't
handle them gracefully. Such situation can be triggered e.g. by the
following reproducer:

    while true; do load_policy; echo -n .; sleep 0.1; done &
    for (( i = 0; i < 1024; i++ )); do
        runcon -l s0:c$i echo -n x || break
        # or:
        # chcon -l s0:c$i <some_file> || break
    done

This patch overhauls the sidtab so it doesn't need to be frozen during
policy reload, thus solving the above problem.

The new SID table leverages the fact that SIDs are allocated
sequentially and are never invalidated and stores them in linear buckets
indexed by a tree structure. This brings several advantages:
  1. Fast SID -> context lookup - this lookup can now be done in
     logarithmic time complexity (usually in less than 4 array lookups)
     and can still be done safely without locking.
  2. No need to re-search the whole table on reverse lookup miss - after
     acquiring the spinlock only the newly added entries need to be
     searched, which means that reverse lookups that end up inserting a
     new entry are now about twice as fast.
  3. No need to freeze sidtab during policy reload - it is now possible
     to handle insertion of new entries even during sidtab conversion.

The tree structure of the new sidtab is able to grow automatically to up
to about 2^31 entries (at which point it should not have more than about
4 tree levels). The old sidtab had a theoretical capacity of almost 2^32
entries, but half of that is still more than enough since by that point
the reverse table lookups would become unusably slow anyway...

The number of entries per tree node is selected automatically so that
each node fits into a single page, which should be the easiest size for
kmalloc() to handle.

Note that the cache for reverse lookup is preserved with equivalent
logic. The only difference is that instead of storing pointers to the
hash table nodes it stores just the indices of the cached entries.

The new cache ensures that the indices are loaded/stored atomically, but
it still has the drawback that concurrent cache updates may mess up the
contents of the cache. Such situation however only reduces its
effectivity, not the correctness of lookups.

Tested by selinux-testsuite and thoroughly tortured by this simple
stress test:
```
function rand_cat() {
	echo $(( $RANDOM % 1024 ))
}

function do_work() {
	while true; do
		echo -n "system_u:system_r:kernel_t:s0:c$(rand_cat),c$(rand_cat)" \
			>/sys/fs/selinux/context 2>/dev/null || true
	done
}

do_work >/dev/null &
do_work >/dev/null &
do_work >/dev/null &

while load_policy; do echo -n .; sleep 0.1; done

kill %1
kill %2
kill %3
```

Link: https://github.com/SELinuxProject/selinux-kernel/issues/38

	Reported-by: Orion Poplawski <orion@nwra.com>
	Reported-by: Li Kun <hw.likun@huawei.com>
	Signed-off-by: Ondrej Mosnacek <omosnace@redhat.com>
	Reviewed-by: Stephen Smalley <sds@tycho.nsa.gov>
[PM: most of sidtab.c merged by hand due to conflicts]
[PM: checkpatch fixes in mls.c, services.c, sidtab.c]
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit ee1a84fdfeedfd7362e9a8a8f15fedc3482ade2d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/ss/services.c
#	security/selinux/ss/sidtab.c
#	security/selinux/ss/sidtab.h
diff --cc security/selinux/ss/services.c
index f2e85744961c,dd44126c8d14..000000000000
--- a/security/selinux/ss/services.c
+++ b/security/selinux/ss/services.c
@@@ -1865,39 -1926,33 +1862,52 @@@ static int convert_context(struct conte
  
  	args = p;
  
- 	if (c->str) {
- 		struct context ctx;
- 
- 		rc = -ENOMEM;
- 		s = kstrdup(c->str, GFP_KERNEL);
+ 	if (oldc->str) {
+ 		s = kstrdup(oldc->str, GFP_KERNEL);
  		if (!s)
- 			goto out;
+ 			return -ENOMEM;
  
  		rc = string_to_context_struct(args->newp, NULL, s,
++<<<<<<< HEAD
 +					      c->len, &ctx, SECSID_NULL);
 +		kfree(s);
 +		if (!rc) {
 +			printk(KERN_INFO "SELinux:  Context %s became valid (mapped).\n",
 +			       c->str);
 +			/* Replace string with mapped representation. */
 +			kfree(c->str);
 +			memcpy(c, &ctx, sizeof(*c));
 +			goto out;
 +		} else if (rc == -EINVAL) {
++=======
+ 					      newc, SECSID_NULL);
+ 		if (rc == -EINVAL) {
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  			/* Retain string representation for later mapping. */
- 			rc = 0;
- 			goto out;
- 		} else {
+ 			context_init(newc);
+ 			newc->str = s;
+ 			newc->len = oldc->len;
+ 			return 0;
+ 		}
+ 		kfree(s);
+ 		if (rc) {
  			/* Other error condition, e.g. ENOMEM. */
++<<<<<<< HEAD
 +			printk(KERN_ERR "SELinux:   Unable to map context %s, rc = %d.\n",
 +			       c->str, -rc);
 +			goto out;
++=======
+ 			pr_err("SELinux:   Unable to map context %s, rc = %d.\n",
+ 			       oldc->str, -rc);
+ 			return rc;
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  		}
+ 		pr_info("SELinux:  Context %s became valid (mapped).\n",
+ 			oldc->str);
+ 		return 0;
  	}
  
- 	rc = context_cpy(&oldc, c);
- 	if (rc)
- 		goto out;
+ 	context_init(newc);
  
  	/* Convert the user. */
  	rc = -EINVAL;
@@@ -1959,47 -2008,49 +1963,60 @@@
  	}
  
  	/* Check the validity of the new context. */
++<<<<<<< HEAD
 +	if (!policydb_context_isvalid(args->newp, c)) {
 +		rc = convert_context_handle_invalid_context(&oldc);
++=======
+ 	if (!policydb_context_isvalid(args->newp, newc)) {
+ 		rc = convert_context_handle_invalid_context(args->state, oldc);
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  		if (rc)
  			goto bad;
  	}
  
- 	context_destroy(&oldc);
- 
- 	rc = 0;
- out:
- 	return rc;
+ 	return 0;
  bad:
  	/* Map old representation to string and save it. */
++<<<<<<< HEAD
 +	rc = context_struct_to_string(&oldc, &s, &len);
 +	if (rc)
 +		return rc;
 +	context_destroy(&oldc);
 +	context_destroy(c);
 +	c->str = s;
 +	c->len = len;
 +	printk(KERN_INFO "SELinux:  Context %s became invalid (unmapped).\n",
 +	       c->str);
 +	rc = 0;
 +	goto out;
++=======
+ 	rc = context_struct_to_string(args->oldp, oldc, &s, &len);
+ 	if (rc)
+ 		return rc;
+ 	context_destroy(newc);
+ 	newc->str = s;
+ 	newc->len = len;
+ 	pr_info("SELinux:  Context %s became invalid (unmapped).\n",
+ 		newc->str);
+ 	return 0;
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  }
  
 -static void security_load_policycaps(struct selinux_state *state)
 +static void security_load_policycaps(void)
  {
 -	struct policydb *p = &state->ss->policydb;
 -	unsigned int i;
 -	struct ebitmap_node *node;
 -
 -	for (i = 0; i < ARRAY_SIZE(state->policycap); i++)
 -		state->policycap[i] = ebitmap_get_bit(&p->policycaps, i);
 -
 -	for (i = 0; i < ARRAY_SIZE(selinux_policycap_names); i++)
 -		pr_info("SELinux:  policy capability %s=%d\n",
 -			selinux_policycap_names[i],
 -			ebitmap_get_bit(&p->policycaps, i));
 -
 -	ebitmap_for_each_positive_bit(&p->policycaps, node, i) {
 -		if (i >= ARRAY_SIZE(selinux_policycap_names))
 -			pr_info("SELinux:  unknown policy capability %u\n",
 -				i);
 -	}
 +	selinux_policycap_netpeer = ebitmap_get_bit(&policydb.policycaps,
 +						  POLICYDB_CAPABILITY_NETPEER);
 +	selinux_policycap_openperm = ebitmap_get_bit(&policydb.policycaps,
 +						  POLICYDB_CAPABILITY_OPENPERM);
 +	selinux_policycap_cgroupseclabel =
 +		ebitmap_get_bit(&policydb.policycaps,
 +				POLICYDB_CAPABILITY_CGROUPSECLABEL);
 +	selinux_policycap_nnp_nosuid_transition =
 +		ebitmap_get_bit(&policydb.policycaps,
 +				POLICYDB_CAPABILITY_NNP_NOSUID_TRANSITION);
  }
  
 -static int security_preserve_bools(struct selinux_state *state,
 -				   struct policydb *newpolicydb);
 +static int security_preserve_bools(struct policydb *p);
  
  /**
   * security_load_policy - Load a security policy configuration.
@@@ -2011,14 -2062,16 +2028,20 @@@
   * This function will flush the access vector cache after
   * loading the new policy.
   */
 -int security_load_policy(struct selinux_state *state, void *data, size_t len)
 +int security_load_policy(void *data, size_t len)
  {
 -	struct policydb *policydb;
 -	struct sidtab *oldsidtab, *newsidtab;
  	struct policydb *oldpolicydb, *newpolicydb;
++<<<<<<< HEAD
 +	struct sidtab oldsidtab, newsidtab;
 +	struct selinux_mapping *oldmap, *map = NULL;
++=======
+ 	struct selinux_mapping *oldmapping;
+ 	struct selinux_map newmap;
+ 	struct sidtab_convert_params convert_params;
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  	struct convert_context_args args;
  	u32 seqno;
 +	u16 map_size;
  	int rc = 0;
  	struct policy_file file = { data, len }, *fp = &file;
  
@@@ -2066,13 -2126,11 +2089,16 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +#if 0
 +	sidtab_hash_eval(&sidtab, "sids");
 +#endif
 +
++=======
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  	rc = policydb_read(newpolicydb, fp);
 -	if (rc) {
 -		kfree(newsidtab);
 +	if (rc)
  		goto out;
 -	}
  
  	newpolicydb->len = len;
  	/* If switching between different policy types, log MLS status */
@@@ -2098,22 -2157,23 +2124,35 @@@
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	/* Clone the SID table. */
 +	sidtab_shutdown(&sidtab);
 +
 +	rc = sidtab_map(&sidtab, clone_sid, &newsidtab);
 +	if (rc)
 +		goto err;
++=======
+ 	oldsidtab = state->ss->sidtab;
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  
  	/*
  	 * Convert the internal representations of contexts
  	 * in the new SID table.
  	 */
 -	args.state = state;
 -	args.oldp = policydb;
 +	args.oldp = &policydb;
  	args.newp = newpolicydb;
++<<<<<<< HEAD
 +	rc = sidtab_map(&newsidtab, convert_context, &args);
++=======
+ 
+ 	convert_params.func = convert_context;
+ 	convert_params.args = &args;
+ 	convert_params.target = newsidtab;
+ 
+ 	rc = sidtab_convert(oldsidtab, &convert_params);
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  	if (rc) {
 -		pr_err("SELinux:  unable to convert the internal"
 +		printk(KERN_ERR "SELinux:  unable to convert the internal"
  			" representation of contexts in the new SID"
  			" table\n");
  		goto err;
diff --cc security/selinux/ss/sidtab.c
index 5840a35155fc,e63a90ff2728..000000000000
--- a/security/selinux/ss/sidtab.c
+++ b/security/selinux/ss/sidtab.c
@@@ -1,115 -1,165 +1,258 @@@
  /*
   * Implementation of the SID table type.
   *
++<<<<<<< HEAD
 + * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
++=======
+  * Original author: Stephen Smalley, <sds@tycho.nsa.gov>
+  * Author: Ondrej Mosnacek, <omosnacek@gmail.com>
+  *
+  * Copyright (C) 2018 Red Hat, Inc.
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
   */
+ #include <linux/errno.h>
  #include <linux/kernel.h>
  #include <linux/slab.h>
+ #include <linux/sched.h>
  #include <linux/spinlock.h>
- #include <linux/errno.h>
+ #include <linux/atomic.h>
  #include "flask.h"
  #include "security.h"
  #include "sidtab.h"
  
- #define SIDTAB_HASH(sid) \
- (sid & SIDTAB_HASH_MASK)
- 
  int sidtab_init(struct sidtab *s)
  {
- 	int i;
+ 	u32 i;
  
++<<<<<<< HEAD
 +	s->htable = kmalloc(sizeof(*(s->htable)) * SIDTAB_SIZE, GFP_ATOMIC);
 +	if (!s->htable)
 +		return -ENOMEM;
 +	for (i = 0; i < SIDTAB_SIZE; i++)
 +		s->htable[i] = NULL;
 +	s->nel = 0;
 +	s->next_sid = 1;
 +	s->shutdown = 0;
++=======
+ 	memset(s->roots, 0, sizeof(s->roots));
+ 
+ 	for (i = 0; i < SIDTAB_RCACHE_SIZE; i++)
+ 		atomic_set(&s->rcache[i], -1);
+ 
+ 	for (i = 0; i < SECINITSID_NUM; i++)
+ 		s->isids[i].set = 0;
+ 
+ 	atomic_set(&s->count, 0);
+ 
+ 	s->convert = NULL;
+ 
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  	spin_lock_init(&s->lock);
  	return 0;
  }
  
++<<<<<<< HEAD
 +int sidtab_insert(struct sidtab *s, u32 sid, struct context *context)
 +{
 +	int hvalue, rc = 0;
 +	struct sidtab_node *prev, *cur, *newnode;
 +
 +	if (!s) {
 +		rc = -ENOMEM;
 +		goto out;
 +	}
 +
 +	hvalue = SIDTAB_HASH(sid);
 +	prev = NULL;
 +	cur = s->htable[hvalue];
 +	while (cur && sid > cur->sid) {
 +		prev = cur;
 +		cur = cur->next;
 +	}
 +
 +	if (cur && sid == cur->sid) {
 +		rc = -EEXIST;
 +		goto out;
 +	}
 +
 +	newnode = kmalloc(sizeof(*newnode), GFP_ATOMIC);
 +	if (newnode == NULL) {
 +		rc = -ENOMEM;
 +		goto out;
 +	}
 +	newnode->sid = sid;
 +	if (context_cpy(&newnode->context, context)) {
 +		kfree(newnode);
 +		rc = -ENOMEM;
 +		goto out;
 +	}
 +
 +	if (prev) {
 +		newnode->next = prev->next;
 +		wmb();
 +		prev->next = newnode;
 +	} else {
 +		newnode->next = s->htable[hvalue];
 +		wmb();
 +		s->htable[hvalue] = newnode;
 +	}
 +
 +	s->nel++;
 +	if (sid >= s->next_sid)
 +		s->next_sid = sid + 1;
 +out:
 +	return rc;
 +}
 +
 +static struct context *sidtab_search_core(struct sidtab *s, u32 sid, int force)
++=======
+ int sidtab_set_initial(struct sidtab *s, u32 sid, struct context *context)
  {
- 	int hvalue;
- 	struct sidtab_node *cur;
+ 	struct sidtab_isid_entry *entry;
+ 	int rc;
+ 
+ 	if (sid == 0 || sid > SECINITSID_NUM)
+ 		return -EINVAL;
+ 
+ 	entry = &s->isids[sid - 1];
+ 
+ 	rc = context_cpy(&entry->context, context);
+ 	if (rc)
+ 		return rc;
+ 
+ 	entry->set = 1;
+ 	return 0;
+ }
  
+ static u32 sidtab_level_from_count(u32 count)
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
+ {
+ 	u32 capacity = SIDTAB_LEAF_ENTRIES;
+ 	u32 level = 0;
+ 
++<<<<<<< HEAD
 +	if (!s)
 +		return NULL;
 +
 +	hvalue = SIDTAB_HASH(sid);
 +	cur = s->htable[hvalue];
 +	while (cur && sid > cur->sid)
 +		cur = cur->next;
 +
 +	if (force && cur && sid == cur->sid && cur->context.len)
 +		return &cur->context;
 +
 +	if (cur == NULL || sid != cur->sid || cur->context.len) {
 +		/* Remap invalid SIDs to the unlabeled SID. */
 +		sid = SECINITSID_UNLABELED;
 +		hvalue = SIDTAB_HASH(sid);
 +		cur = s->htable[hvalue];
 +		while (cur && sid > cur->sid)
 +			cur = cur->next;
 +		if (!cur || sid != cur->sid)
 +			return NULL;
++=======
+ 	while (count > capacity) {
+ 		capacity <<= SIDTAB_INNER_SHIFT;
+ 		++level;
+ 	}
+ 	return level;
+ }
+ 
+ static int sidtab_alloc_roots(struct sidtab *s, u32 level)
+ {
+ 	u32 l;
+ 
+ 	if (!s->roots[0].ptr_leaf) {
+ 		s->roots[0].ptr_leaf = kzalloc(SIDTAB_NODE_ALLOC_SIZE,
+ 					       GFP_ATOMIC);
+ 		if (!s->roots[0].ptr_leaf)
+ 			return -ENOMEM;
+ 	}
+ 	for (l = 1; l <= level; ++l)
+ 		if (!s->roots[l].ptr_inner) {
+ 			s->roots[l].ptr_inner = kzalloc(SIDTAB_NODE_ALLOC_SIZE,
+ 							GFP_ATOMIC);
+ 			if (!s->roots[l].ptr_inner)
+ 				return -ENOMEM;
+ 			s->roots[l].ptr_inner->entries[0] = s->roots[l - 1];
+ 		}
+ 	return 0;
+ }
+ 
+ static struct context *sidtab_do_lookup(struct sidtab *s, u32 index, int alloc)
+ {
+ 	union sidtab_entry_inner *entry;
+ 	u32 level, capacity_shift, leaf_index = index / SIDTAB_LEAF_ENTRIES;
+ 
+ 	/* find the level of the subtree we need */
+ 	level = sidtab_level_from_count(index + 1);
+ 	capacity_shift = level * SIDTAB_INNER_SHIFT;
+ 
+ 	/* allocate roots if needed */
+ 	if (alloc && sidtab_alloc_roots(s, level) != 0)
+ 		return NULL;
+ 
+ 	/* lookup inside the subtree */
+ 	entry = &s->roots[level];
+ 	while (level != 0) {
+ 		capacity_shift -= SIDTAB_INNER_SHIFT;
+ 		--level;
+ 
+ 		entry = &entry->ptr_inner->entries[leaf_index >> capacity_shift];
+ 		leaf_index &= ((u32)1 << capacity_shift) - 1;
+ 
+ 		if (!entry->ptr_inner) {
+ 			if (alloc)
+ 				entry->ptr_inner = kzalloc(SIDTAB_NODE_ALLOC_SIZE,
+ 							   GFP_ATOMIC);
+ 			if (!entry->ptr_inner)
+ 				return NULL;
+ 		}
+ 	}
+ 	if (!entry->ptr_leaf) {
+ 		if (alloc)
+ 			entry->ptr_leaf = kzalloc(SIDTAB_NODE_ALLOC_SIZE,
+ 						  GFP_ATOMIC);
+ 		if (!entry->ptr_leaf)
+ 			return NULL;
+ 	}
+ 	return &entry->ptr_leaf->entries[index % SIDTAB_LEAF_ENTRIES].context;
+ }
+ 
+ static struct context *sidtab_lookup(struct sidtab *s, u32 index)
+ {
+ 	u32 count = (u32)atomic_read(&s->count);
+ 
+ 	if (index >= count)
+ 		return NULL;
+ 
+ 	/* read entries after reading count */
+ 	smp_rmb();
+ 
+ 	return sidtab_do_lookup(s, index, 0);
+ }
+ 
+ static struct context *sidtab_lookup_initial(struct sidtab *s, u32 sid)
+ {
+ 	return s->isids[sid - 1].set ? &s->isids[sid - 1].context : NULL;
+ }
+ 
+ static struct context *sidtab_search_core(struct sidtab *s, u32 sid, int force)
+ {
+ 	struct context *context;
+ 
+ 	if (sid != 0) {
+ 		if (sid > SECINITSID_NUM)
+ 			context = sidtab_lookup(s, sid - (SECINITSID_NUM + 1));
+ 		else
+ 			context = sidtab_lookup_initial(s, sid);
+ 		if (context && (!context->len || force))
+ 			return context;
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  	}
  
 -	return sidtab_lookup_initial(s, SECINITSID_UNLABELED);
 +	return &cur->context;
  }
  
  struct context *sidtab_search(struct sidtab *s, u32 sid)
@@@ -122,192 -172,324 +265,461 @@@ struct context *sidtab_search_force(str
  	return sidtab_search_core(s, sid, 1);
  }
  
++<<<<<<< HEAD
 +int sidtab_map(struct sidtab *s,
 +	       int (*apply) (u32 sid,
 +			     struct context *context,
 +			     void *args),
 +	       void *args)
 +{
 +	int i, rc = 0;
 +	struct sidtab_node *cur;
 +
 +	if (!s)
 +		goto out;
 +
 +	for (i = 0; i < SIDTAB_SIZE; i++) {
 +		cur = s->htable[i];
 +		while (cur) {
 +			rc = apply(cur->sid, &cur->context, args);
 +			if (rc)
 +				goto out;
 +			cur = cur->next;
 +		}
 +	}
 +out:
 +	return rc;
 +}
 +
 +static void sidtab_update_cache(struct sidtab *s, struct sidtab_node *n, int loc)
 +{
 +	BUG_ON(loc >= SIDTAB_CACHE_LEN);
 +
 +	while (loc > 0) {
 +		s->cache[loc] = s->cache[loc - 1];
 +		loc--;
 +	}
 +	s->cache[0] = n;
 +}
 +
 +static inline u32 sidtab_search_context(struct sidtab *s,
 +						  struct context *context)
 +{
 +	int i;
 +	struct sidtab_node *cur;
 +
 +	for (i = 0; i < SIDTAB_SIZE; i++) {
 +		cur = s->htable[i];
 +		while (cur) {
 +			if (context_cmp(&cur->context, context)) {
 +				sidtab_update_cache(s, cur, SIDTAB_CACHE_LEN - 1);
 +				return cur->sid;
++=======
+ static int sidtab_find_context(union sidtab_entry_inner entry,
+ 			       u32 *pos, u32 count, u32 level,
+ 			       struct context *context, u32 *index)
+ {
+ 	int rc;
+ 	u32 i;
+ 
+ 	if (level != 0) {
+ 		struct sidtab_node_inner *node = entry.ptr_inner;
+ 
+ 		i = 0;
+ 		while (i < SIDTAB_INNER_ENTRIES && *pos < count) {
+ 			rc = sidtab_find_context(node->entries[i],
+ 						 pos, count, level - 1,
+ 						 context, index);
+ 			if (rc == 0)
+ 				return 0;
+ 			i++;
+ 		}
+ 	} else {
+ 		struct sidtab_node_leaf *node = entry.ptr_leaf;
+ 
+ 		i = 0;
+ 		while (i < SIDTAB_LEAF_ENTRIES && *pos < count) {
+ 			if (context_cmp(&node->entries[i].context, context)) {
+ 				*index = *pos;
+ 				return 0;
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  			}
- 			cur = cur->next;
+ 			(*pos)++;
+ 			i++;
  		}
  	}
 -	return -ENOENT;
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)
++=======
+ static void sidtab_rcache_update(struct sidtab *s, u32 index, u32 pos)
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  {
- 	int i;
- 	struct sidtab_node *node;
+ 	while (pos > 0) {
+ 		atomic_set(&s->rcache[pos], atomic_read(&s->rcache[pos - 1]));
+ 		--pos;
+ 	}
+ 	atomic_set(&s->rcache[0], (int)index);
+ }
  
++<<<<<<< HEAD
 +	for (i = 0; i < SIDTAB_CACHE_LEN; i++) {
 +		node = s->cache[i];
 +		if (unlikely(!node))
 +			return 0;
 +		if (context_cmp(&node->context, context)) {
 +			sidtab_update_cache(s, node, i);
 +			return node->sid;
++=======
+ static void sidtab_rcache_push(struct sidtab *s, u32 index)
+ {
+ 	sidtab_rcache_update(s, index, SIDTAB_RCACHE_SIZE - 1);
+ }
+ 
+ static int sidtab_rcache_search(struct sidtab *s, struct context *context,
+ 				u32 *index)
+ {
+ 	u32 i;
+ 
+ 	for (i = 0; i < SIDTAB_RCACHE_SIZE; i++) {
+ 		int v = atomic_read(&s->rcache[i]);
+ 
+ 		if (v < 0)
+ 			continue;
+ 
+ 		if (context_cmp(sidtab_do_lookup(s, (u32)v, 0), context)) {
+ 			sidtab_rcache_update(s, (u32)v, i);
+ 			*index = (u32)v;
+ 			return 0;
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  		}
  	}
 -	return -ENOENT;
 +	return 0;
  }
  
++<<<<<<< HEAD
 +int sidtab_context_to_sid(struct sidtab *s,
 +			  struct context *context,
 +			  u32 *out_sid)
 +{
 +	u32 sid;
 +	int ret = 0;
++=======
+ static int sidtab_reverse_lookup(struct sidtab *s, struct context *context,
+ 				 u32 *index)
+ {
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  	unsigned long flags;
+ 	u32 count = (u32)atomic_read(&s->count);
+ 	u32 count_locked, level, pos;
+ 	struct sidtab_convert_params *convert;
+ 	struct context *dst, *dst_convert;
+ 	int rc;
  
++<<<<<<< HEAD
 +	*out_sid = SECSID_NULL;
 +
 +	sid  = sidtab_search_cache(s, context);
 +	if (!sid)
 +		sid = sidtab_search_context(s, context);
 +	if (!sid) {
 +		spin_lock_irqsave(&s->lock, flags);
 +		/* Rescan now that we hold the lock. */
 +		sid = sidtab_search_context(s, context);
 +		if (sid)
 +			goto unlock_out;
 +		/* No SID exists for the context.  Allocate a new one. */
 +		if (s->next_sid == UINT_MAX || s->shutdown) {
 +			ret = -ENOMEM;
 +			goto unlock_out;
 +		}
 +		sid = s->next_sid++;
 +		if (context->len)
 +			printk(KERN_INFO
 +		       "SELinux:  Context %s is not valid (left unmapped).\n",
 +			       context->str);
 +		ret = sidtab_insert(s, sid, context);
 +		if (ret)
 +			s->next_sid--;
 +unlock_out:
 +		spin_unlock_irqrestore(&s->lock, flags);
 +	}
 +
 +	if (ret)
 +		return ret;
++=======
+ 	rc = sidtab_rcache_search(s, context, index);
+ 	if (rc == 0)
+ 		return 0;
+ 
+ 	level = sidtab_level_from_count(count);
+ 
+ 	/* read entries after reading count */
+ 	smp_rmb();
+ 
+ 	pos = 0;
+ 	rc = sidtab_find_context(s->roots[level], &pos, count, level,
+ 				 context, index);
+ 	if (rc == 0) {
+ 		sidtab_rcache_push(s, *index);
+ 		return 0;
+ 	}
+ 
+ 	/* lock-free search failed: lock, re-search, and insert if not found */
+ 	spin_lock_irqsave(&s->lock, flags);
+ 
+ 	convert = s->convert;
+ 	count_locked = (u32)atomic_read(&s->count);
+ 	level = sidtab_level_from_count(count_locked);
+ 
+ 	/* if count has changed before we acquired the lock, then catch up */
+ 	while (count < count_locked) {
+ 		if (context_cmp(sidtab_do_lookup(s, count, 0), context)) {
+ 			sidtab_rcache_push(s, count);
+ 			*index = count;
+ 			rc = 0;
+ 			goto out_unlock;
+ 		}
+ 		++count;
+ 	}
+ 
+ 	/* insert context into new entry */
+ 	rc = -ENOMEM;
+ 	dst = sidtab_do_lookup(s, count, 1);
+ 	if (!dst)
+ 		goto out_unlock;
+ 
+ 	rc = context_cpy(dst, context);
+ 	if (rc)
+ 		goto out_unlock;
+ 
+ 	/*
+ 	 * if we are building a new sidtab, we need to convert the context
+ 	 * and insert it there as well
+ 	 */
+ 	if (convert) {
+ 		rc = -ENOMEM;
+ 		dst_convert = sidtab_do_lookup(convert->target, count, 1);
+ 		if (!dst_convert) {
+ 			context_destroy(dst);
+ 			goto out_unlock;
+ 		}
+ 
+ 		rc = convert->func(context, dst_convert, convert->args);
+ 		if (rc) {
+ 			context_destroy(dst);
+ 			goto out_unlock;
+ 		}
+ 
+ 		/* at this point we know the insert won't fail */
+ 		atomic_set(&convert->target->count, count + 1);
+ 	}
+ 
+ 	if (context->len)
+ 		pr_info("SELinux:  Context %s is not valid (left unmapped).\n",
+ 			context->str);
+ 
+ 	sidtab_rcache_push(s, count);
+ 	*index = count;
+ 
+ 	/* write entries before writing new count */
+ 	smp_wmb();
+ 
+ 	atomic_set(&s->count, count + 1);
+ 
+ 	rc = 0;
+ out_unlock:
+ 	spin_unlock_irqrestore(&s->lock, flags);
+ 	return rc;
+ }
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  
 -int sidtab_context_to_sid(struct sidtab *s, struct context *context, u32 *sid)
 -{
 -	int rc;
 -	u32 i;
 -
 -	for (i = 0; i < SECINITSID_NUM; i++) {
 -		struct sidtab_isid_entry *entry = &s->isids[i];
 -
 -		if (entry->set && context_cmp(context, &entry->context)) {
 -			*sid = i + 1;
 -			return 0;
 -		}
 -	}
 -
 -	rc = sidtab_reverse_lookup(s, context, sid);
 -	if (rc)
 -		return rc;
 -	*sid += SECINITSID_NUM + 1;
 +	*out_sid = sid;
  	return 0;
  }
  
- void sidtab_hash_eval(struct sidtab *h, char *tag)
+ static int sidtab_convert_tree(union sidtab_entry_inner *edst,
+ 			       union sidtab_entry_inner *esrc,
+ 			       u32 *pos, u32 count, u32 level,
+ 			       struct sidtab_convert_params *convert)
  {
- 	int i, chain_len, slots_used, max_chain_len;
- 	struct sidtab_node *cur;
+ 	int rc;
+ 	u32 i;
+ 
+ 	if (level != 0) {
+ 		if (!edst->ptr_inner) {
+ 			edst->ptr_inner = kzalloc(SIDTAB_NODE_ALLOC_SIZE,
+ 						  GFP_KERNEL);
+ 			if (!edst->ptr_inner)
+ 				return -ENOMEM;
+ 		}
+ 		i = 0;
+ 		while (i < SIDTAB_INNER_ENTRIES && *pos < count) {
+ 			rc = sidtab_convert_tree(&edst->ptr_inner->entries[i],
+ 						 &esrc->ptr_inner->entries[i],
+ 						 pos, count, level - 1,
+ 						 convert);
+ 			if (rc)
+ 				return rc;
+ 			i++;
+ 		}
+ 	} else {
+ 		if (!edst->ptr_leaf) {
+ 			edst->ptr_leaf = kzalloc(SIDTAB_NODE_ALLOC_SIZE,
+ 						 GFP_KERNEL);
+ 			if (!edst->ptr_leaf)
+ 				return -ENOMEM;
+ 		}
+ 		i = 0;
+ 		while (i < SIDTAB_LEAF_ENTRIES && *pos < count) {
+ 			rc = convert->func(&esrc->ptr_leaf->entries[i].context,
+ 					   &edst->ptr_leaf->entries[i].context,
+ 					   convert->args);
+ 			if (rc)
+ 				return rc;
+ 			(*pos)++;
+ 			i++;
+ 		}
+ 		cond_resched();
+ 	}
+ 	return 0;
+ }
  
- 	slots_used = 0;
- 	max_chain_len = 0;
- 	for (i = 0; i < SIDTAB_SIZE; i++) {
- 		cur = h->htable[i];
- 		if (cur) {
- 			slots_used++;
- 			chain_len = 0;
- 			while (cur) {
- 				chain_len++;
- 				cur = cur->next;
- 			}
+ int sidtab_convert(struct sidtab *s, struct sidtab_convert_params *params)
+ {
+ 	unsigned long flags;
+ 	u32 count, level, pos;
+ 	int rc;
  
- 			if (chain_len > max_chain_len)
- 				max_chain_len = chain_len;
- 		}
+ 	spin_lock_irqsave(&s->lock, flags);
+ 
+ 	/* concurrent policy loads are not allowed */
+ 	if (s->convert) {
+ 		spin_unlock_irqrestore(&s->lock, flags);
+ 		return -EBUSY;
  	}
  
++<<<<<<< HEAD
 +	printk(KERN_DEBUG "%s:  %d entries and %d/%d buckets used, longest "
 +	       "chain length %d\n", tag, h->nel, slots_used, SIDTAB_SIZE,
 +	       max_chain_len);
++=======
+ 	count = (u32)atomic_read(&s->count);
+ 	level = sidtab_level_from_count(count);
+ 
+ 	/* allocate last leaf in the new sidtab (to avoid race with
+ 	 * live convert)
+ 	 */
+ 	rc = sidtab_do_lookup(params->target, count - 1, 1) ? 0 : -ENOMEM;
+ 	if (rc) {
+ 		spin_unlock_irqrestore(&s->lock, flags);
+ 		return rc;
+ 	}
+ 
+ 	/* set count in case no new entries are added during conversion */
+ 	atomic_set(&params->target->count, count);
+ 
+ 	/* enable live convert of new entries */
+ 	s->convert = params;
+ 
+ 	/* we can safely do the rest of the conversion outside the lock */
+ 	spin_unlock_irqrestore(&s->lock, flags);
+ 
+ 	pr_info("SELinux:  Converting %u SID table entries...\n", count);
+ 
+ 	/* convert all entries not covered by live convert */
+ 	pos = 0;
+ 	rc = sidtab_convert_tree(&params->target->roots[level],
+ 				 &s->roots[level], &pos, count, level, params);
+ 	if (rc) {
+ 		/* we need to keep the old table - disable live convert */
+ 		spin_lock_irqsave(&s->lock, flags);
+ 		s->convert = NULL;
+ 		spin_unlock_irqrestore(&s->lock, flags);
+ 	}
+ 	return rc;
  }
  
- void sidtab_destroy(struct sidtab *s)
+ static void sidtab_destroy_tree(union sidtab_entry_inner entry, u32 level)
  {
- 	int i;
- 	struct sidtab_node *cur, *temp;
+ 	u32 i;
  
- 	if (!s)
- 		return;
+ 	if (level != 0) {
+ 		struct sidtab_node_inner *node = entry.ptr_inner;
+ 
+ 		if (!node)
+ 			return;
+ 
+ 		for (i = 0; i < SIDTAB_INNER_ENTRIES; i++)
+ 			sidtab_destroy_tree(node->entries[i], level - 1);
+ 		kfree(node);
+ 	} else {
+ 		struct sidtab_node_leaf *node = entry.ptr_leaf;
+ 
+ 		if (!node)
+ 			return;
  
+ 		for (i = 0; i < SIDTAB_LEAF_ENTRIES; i++)
+ 			context_destroy(&node->entries[i].context);
+ 		kfree(node);
+ 	}
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
+ }
+ 
+ void sidtab_destroy(struct sidtab *s)
+ {
+ 	u32 i, level;
+ 
++<<<<<<< HEAD
 +	for (i = 0; i < SIDTAB_SIZE; i++) {
 +		cur = s->htable[i];
 +		while (cur) {
 +			temp = cur;
 +			cur = cur->next;
 +			context_destroy(&temp->context);
 +			kfree(temp);
 +		}
 +		s->htable[i] = NULL;
 +	}
 +	kfree(s->htable);
 +	s->htable = NULL;
 +	s->nel = 0;
 +	s->next_sid = 1;
++=======
+ 	for (i = 0; i < SECINITSID_NUM; i++)
+ 		if (s->isids[i].set)
+ 			context_destroy(&s->isids[i].context);
+ 
+ 	level = SIDTAB_MAX_LEVEL;
+ 	while (level && !s->roots[level].ptr_inner)
+ 		--level;
+ 
+ 	sidtab_destroy_tree(s->roots[level], level);
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
 +}
 +
 +void sidtab_set(struct sidtab *dst, struct sidtab *src)
 +{
 +	unsigned long flags;
 +	int i;
 +
 +	spin_lock_irqsave(&src->lock, flags);
 +	dst->htable = src->htable;
 +	dst->nel = src->nel;
 +	dst->next_sid = src->next_sid;
 +	dst->shutdown = 0;
 +	for (i = 0; i < SIDTAB_CACHE_LEN; i++)
 +		dst->cache[i] = NULL;
 +	spin_unlock_irqrestore(&src->lock, flags);
 +}
 +
 +void sidtab_shutdown(struct sidtab *s)
 +{
 +	unsigned long flags;
 +
 +	spin_lock_irqsave(&s->lock, flags);
 +	s->shutdown = 1;
 +	spin_unlock_irqrestore(&s->lock, flags);
  }
diff --cc security/selinux/ss/sidtab.h
index 84dc154d9389,bbd5c0d1f3bd..000000000000
--- a/security/selinux/ss/sidtab.h
+++ b/security/selinux/ss/sidtab.h
@@@ -1,34 -1,84 +1,93 @@@
 -/* SPDX-License-Identifier: GPL-2.0 */
  /*
-  * A security identifier table (sidtab) is a hash table
+  * A security identifier table (sidtab) is a lookup table
   * of security context structures indexed by SID value.
   *
++<<<<<<< HEAD
 + * Author : Stephen Smalley, <sds@epoch.ncsc.mil>
++=======
+  * Original author: Stephen Smalley, <sds@tycho.nsa.gov>
+  * Author: Ondrej Mosnacek, <omosnacek@gmail.com>
+  *
+  * Copyright (C) 2018 Red Hat, Inc.
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
   */
  #ifndef _SS_SIDTAB_H_
  #define _SS_SIDTAB_H_
  
+ #include <linux/spinlock_types.h>
+ #include <linux/log2.h>
+ 
  #include "context.h"
  
- struct sidtab_node {
- 	u32 sid;		/* security identifier */
- 	struct context context;	/* security context structure */
- 	struct sidtab_node *next;
+ struct sidtab_entry_leaf {
+ 	struct context context;
+ };
+ 
+ struct sidtab_node_inner;
+ struct sidtab_node_leaf;
+ 
+ union sidtab_entry_inner {
+ 	struct sidtab_node_inner *ptr_inner;
+ 	struct sidtab_node_leaf  *ptr_leaf;
+ };
+ 
+ /* align node size to page boundary */
+ #define SIDTAB_NODE_ALLOC_SHIFT PAGE_SHIFT
+ #define SIDTAB_NODE_ALLOC_SIZE  PAGE_SIZE
+ 
+ #define size_to_shift(size) ((size) == 1 ? 1 : (const_ilog2((size) - 1) + 1))
+ 
+ #define SIDTAB_INNER_SHIFT \
+ 	(SIDTAB_NODE_ALLOC_SHIFT - size_to_shift(sizeof(union sidtab_entry_inner)))
+ #define SIDTAB_INNER_ENTRIES ((size_t)1 << SIDTAB_INNER_SHIFT)
+ #define SIDTAB_LEAF_ENTRIES \
+ 	(SIDTAB_NODE_ALLOC_SIZE / sizeof(struct sidtab_entry_leaf))
+ 
+ #define SIDTAB_MAX_BITS 31 /* limited to INT_MAX due to atomic_t range */
+ #define SIDTAB_MAX (((u32)1 << SIDTAB_MAX_BITS) - 1)
+ /* ensure enough tree levels for SIDTAB_MAX entries */
+ #define SIDTAB_MAX_LEVEL \
+ 	DIV_ROUND_UP(SIDTAB_MAX_BITS - size_to_shift(SIDTAB_LEAF_ENTRIES), \
+ 		     SIDTAB_INNER_SHIFT)
+ 
+ struct sidtab_node_leaf {
+ 	struct sidtab_entry_leaf entries[SIDTAB_LEAF_ENTRIES];
  };
  
- #define SIDTAB_HASH_BITS 7
- #define SIDTAB_HASH_BUCKETS (1 << SIDTAB_HASH_BITS)
- #define SIDTAB_HASH_MASK (SIDTAB_HASH_BUCKETS-1)
+ struct sidtab_node_inner {
+ 	union sidtab_entry_inner entries[SIDTAB_INNER_ENTRIES];
+ };
  
- #define SIDTAB_SIZE SIDTAB_HASH_BUCKETS
++<<<<<<< HEAD
++=======
+ struct sidtab_isid_entry {
+ 	int set;
+ 	struct context context;
+ };
  
+ struct sidtab_convert_params {
+ 	int (*func)(struct context *oldc, struct context *newc, void *args);
+ 	void *args;
+ 	struct sidtab *target;
+ };
+ 
+ #define SIDTAB_RCACHE_SIZE 3
+ 
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  struct sidtab {
- 	struct sidtab_node **htable;
- 	unsigned int nel;	/* number of elements */
- 	unsigned int next_sid;	/* next SID to allocate */
- 	unsigned char shutdown;
- #define SIDTAB_CACHE_LEN	3
- 	struct sidtab_node *cache[SIDTAB_CACHE_LEN];
+ 	union sidtab_entry_inner roots[SIDTAB_MAX_LEVEL + 1];
+ 	atomic_t count;
+ 	struct sidtab_convert_params *convert;
  	spinlock_t lock;
++<<<<<<< HEAD
++=======
+ 
+ 	/* reverse lookup cache */
+ 	atomic_t rcache[SIDTAB_RCACHE_SIZE];
+ 
+ 	/* index == SID - 1 (no entry for SECSID_NULL) */
+ 	struct sidtab_isid_entry isids[SECINITSID_NUM];
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  };
  
  int sidtab_init(struct sidtab *s);
@@@ -36,20 -86,11 +95,23 @@@ int sidtab_insert(struct sidtab *s, u3
  struct context *sidtab_search(struct sidtab *s, u32 sid);
  struct context *sidtab_search_force(struct sidtab *s, u32 sid);
  
++<<<<<<< HEAD
 +int sidtab_map(struct sidtab *s,
 +	       int (*apply) (u32 sid,
 +			     struct context *context,
 +			     void *args),
 +	       void *args);
++=======
+ int sidtab_convert(struct sidtab *s, struct sidtab_convert_params *params);
++>>>>>>> ee1a84fdfeed (selinux: overhaul sidtab to fix bug and improve performance)
  
 -int sidtab_context_to_sid(struct sidtab *s, struct context *context, u32 *sid);
 +int sidtab_context_to_sid(struct sidtab *s,
 +			  struct context *context,
 +			  u32 *sid);
  
- void sidtab_hash_eval(struct sidtab *h, char *tag);
  void sidtab_destroy(struct sidtab *s);
 +void sidtab_set(struct sidtab *dst, struct sidtab *src);
 +void sidtab_shutdown(struct sidtab *s);
  
  #endif	/* _SS_SIDTAB_H_ */
  
diff --git a/security/selinux/ss/mls.c b/security/selinux/ss/mls.c
index d307b37ddc2b..c3635d839d96 100644
--- a/security/selinux/ss/mls.c
+++ b/security/selinux/ss/mls.c
@@ -456,16 +456,17 @@ int mls_setup_user_range(struct context *fromcon, struct user_datum *user,
 
 /*
  * Convert the MLS fields in the security context
- * structure `c' from the values specified in the
- * policy `oldp' to the values specified in the policy `newp'.
+ * structure `oldc' from the values specified in the
+ * policy `oldp' to the values specified in the policy `newp',
+ * storing the resulting context in `newc'.
  */
 int mls_convert_context(struct policydb *oldp,
 			struct policydb *newp,
-			struct context *c)
+			struct context *oldc,
+			struct context *newc)
 {
 	struct level_datum *levdatum;
 	struct cat_datum *catdatum;
-	struct ebitmap bitmap;
 	struct ebitmap_node *node;
 	int l, i;
 
@@ -475,28 +476,25 @@ int mls_convert_context(struct policydb *oldp,
 	for (l = 0; l < 2; l++) {
 		levdatum = hashtab_search(newp->p_levels.table,
 					  sym_name(oldp, SYM_LEVELS,
-						   c->range.level[l].sens - 1));
+						   oldc->range.level[l].sens - 1));
 
 		if (!levdatum)
 			return -EINVAL;
-		c->range.level[l].sens = levdatum->level->sens;
+		newc->range.level[l].sens = levdatum->level->sens;
 
-		ebitmap_init(&bitmap);
-		ebitmap_for_each_positive_bit(&c->range.level[l].cat, node, i) {
+		ebitmap_for_each_positive_bit(&oldc->range.level[l].cat,
+					      node, i) {
 			int rc;
 
 			catdatum = hashtab_search(newp->p_cats.table,
 						  sym_name(oldp, SYM_CATS, i));
 			if (!catdatum)
 				return -EINVAL;
-			rc = ebitmap_set_bit(&bitmap, catdatum->value - 1, 1);
+			rc = ebitmap_set_bit(&newc->range.level[l].cat,
+					     catdatum->value - 1, 1);
 			if (rc)
 				return rc;
-
-			cond_resched();
 		}
-		ebitmap_destroy(&c->range.level[l].cat);
-		c->range.level[l].cat = bitmap;
 	}
 
 	return 0;
diff --git a/security/selinux/ss/mls.h b/security/selinux/ss/mls.h
index e4369e3e6366..f1e54018da50 100644
--- a/security/selinux/ss/mls.h
+++ b/security/selinux/ss/mls.h
@@ -43,7 +43,8 @@ int mls_range_set(struct context *context, struct mls_range *range);
 
 int mls_convert_context(struct policydb *oldp,
 			struct policydb *newp,
-			struct context *context);
+			struct context *oldc,
+			struct context *newc);
 
 int mls_compute_sid(struct context *scontext,
 		    struct context *tcontext,
* Unmerged path security/selinux/ss/services.c
* Unmerged path security/selinux/ss/sidtab.c
* Unmerged path security/selinux/ss/sidtab.h
