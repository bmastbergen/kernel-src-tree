kvm: nVMX: Fetch VM_INSTRUCTION_ERROR from vmcs02 on vmx->fail

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jim Mattson <jmattson@google.com>
commit cf3215d9394aa115d0b34d1c93512f53e425db97
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/cf3215d9.failed

When forwarding a hardware VM-entry failure to L1, fetch the
VM_INSTRUCTION_ERROR field from vmcs02 before loading vmcs01.

(Note that there is an implicit assumption that the VM-entry failure was
on the first VM-entry to vmcs02 after nested_vmx_run; otherwise, L1 is
going to be very confused.)

	Signed-off-by: Jim Mattson <jmattson@google.com>
	Reviewed-by: Peter Feiner <pfeiner@google.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit cf3215d9394aa115d0b34d1c93512f53e425db97)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index d78ed04d2c89,6fcc819c945f..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -11297,17 -10768,13 +11298,24 @@@ static void nested_vmx_vmexit(struct kv
  				 vmcs12->vm_exit_msr_store_count))
  		nested_vmx_abort(vcpu, VMX_ABORT_SAVE_GUEST_MSR_FAIL);
  
++<<<<<<< HEAD
 +	vmx_switch_vmcs(vcpu, &vmx->vmcs01);
++=======
+ 	if (unlikely(vmx->fail))
+ 		vm_inst_error = vmcs_read32(VM_INSTRUCTION_ERROR);
+ 
+ 	vmx_load_vmcs01(vcpu);
++>>>>>>> cf3215d9394a (kvm: nVMX: Fetch VM_INSTRUCTION_ERROR from vmcs02 on vmx->fail)
  
 -	if ((exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT)
 -	    && nested_exit_intr_ack_set(vcpu)) {
 +	/*
 +	 * TODO: SDM says that with acknowledge interrupt on exit, bit 31 of
 +	 * the VM-exit interrupt information (valid interrupt) is always set to
 +	 * 1 on EXIT_REASON_EXTERNAL_INTERRUPT, so we shouldn't need
 +	 * kvm_cpu_has_interrupt().  See the commit message for details.
 +	 */
 +	if (nested_exit_intr_ack_set(vcpu) &&
 +	    exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT &&
 +	    kvm_cpu_has_interrupt(vcpu)) {
  		int irq = kvm_cpu_get_interrupt(vcpu);
  		WARN_ON(irq < 0);
  		vmcs12->vm_exit_intr_info = irq |
@@@ -11378,10 -10847,10 +11386,10 @@@
  	 */
  	if (unlikely(vmx->fail)) {
  		vmx->fail = 0;
- 		nested_vmx_failValid(vcpu, vmcs_read32(VM_INSTRUCTION_ERROR));
+ 		nested_vmx_failValid(vcpu, vm_inst_error);
  	} else
  		nested_vmx_succeed(vcpu);
 -	if (enable_shadow_vmcs)
 +	if (enable_shadow_vmcs && exit_reason != -1)
  		vmx->nested.sync_shadow_vmcs = true;
  
  	/* in case we halted in L2 */
* Unmerged path arch/x86/kvm/vmx.c
