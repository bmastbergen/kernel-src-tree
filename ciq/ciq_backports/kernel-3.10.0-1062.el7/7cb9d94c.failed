ALSA: hda/ca0132: add alt_select_in/out for R3Di + SBZ

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit 7cb9d94c05de9eef0af53bf7fcb0168b2e0e2267
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7cb9d94c.failed

Add functions ca0132_alt_select_out and ca0132_alt_select_in for
switching outputs and inputs for r3di and sbz. Also, add enumerated
controls for selecting output and input source.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 7cb9d94c05de9eef0af53bf7fcb0168b2e0e2267)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index 267302056b78,60e8a0ce530e..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -47,6 -49,8 +47,11 @@@
  #define FLOAT_ZERO	0x00000000
  #define FLOAT_ONE	0x3f800000
  #define FLOAT_TWO	0x40000000
++<<<<<<< HEAD
++=======
+ #define FLOAT_THREE     0x40400000
+ #define FLOAT_EIGHT     0x41000000
++>>>>>>> 7cb9d94c05de (ALSA: hda/ca0132: add alt_select_in/out for R3Di + SBZ)
  #define FLOAT_MINUS_5	0xc0a00000
  
  #define UNSOL_TAG_DSP	0x16
@@@ -80,13 -84,19 +85,15 @@@
  
  #ifdef CONFIG_SND_HDA_CODEC_CA0132_DSP
  MODULE_FIRMWARE(EFX_FILE);
 -MODULE_FIRMWARE(SBZ_EFX_FILE);
 -MODULE_FIRMWARE(R3DI_EFX_FILE);
  #endif
  
 -static const char *dirstr[2] = { "Playback", "Capture" };
 +static char *dirstr[2] = { "Playback", "Capture" };
  
+ #define NUM_OF_OUTPUTS 3
  enum {
  	SPEAKER_OUT,
- 	HEADPHONE_OUT
+ 	HEADPHONE_OUT,
+ 	SURROUND_OUT
  };
  
  enum {
@@@ -2733,6 -2926,170 +2797,173 @@@ static bool dspload_wait_loaded(struct 
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Setup GPIO for the other variants of Core3D.
+  */
+ 
+ /*
+  * Sets up the GPIO pins so that they are discoverable. If this isn't done,
+  * the card shows as having no GPIO pins.
+  */
+ static void ca0132_gpio_init(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x793, 0x00);
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x794, 0x53);
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x790, 0x23);
+ 		break;
+ 	case QUIRK_R3DI:
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x793, 0x00);
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x794, 0x5B);
+ 		break;
+ 	}
+ 
+ }
+ 
+ /* Sets the GPIO for audio output. */
+ static void ca0132_gpio_setup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DIRECTION, 0x07);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_MASK, 0x07);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DATA, 0x04);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DATA, 0x06);
+ 		break;
+ 	case QUIRK_R3DI:
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DIRECTION, 0x1E);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_MASK, 0x1F);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DATA, 0x0C);
+ 		break;
+ 	}
+ }
+ 
+ /*
+  * GPIO control functions for the Recon3D integrated.
+  */
+ 
+ enum r3di_gpio_bit {
+ 	/* Bit 1 - Switch between front/rear mic. 0 = rear, 1 = front */
+ 	R3DI_MIC_SELECT_BIT = 1,
+ 	/* Bit 2 - Switch between headphone/line out. 0 = Headphone, 1 = Line */
+ 	R3DI_OUT_SELECT_BIT = 2,
+ 	/*
+ 	 * I dunno what this actually does, but it stays on until the dsp
+ 	 * is downloaded.
+ 	 */
+ 	R3DI_GPIO_DSP_DOWNLOADING = 3,
+ 	/*
+ 	 * Same as above, no clue what it does, but it comes on after the dsp
+ 	 * is downloaded.
+ 	 */
+ 	R3DI_GPIO_DSP_DOWNLOADED = 4
+ };
+ 
+ enum r3di_mic_select {
+ 	/* Set GPIO bit 1 to 0 for rear mic */
+ 	R3DI_REAR_MIC = 0,
+ 	/* Set GPIO bit 1 to 1 for front microphone*/
+ 	R3DI_FRONT_MIC = 1
+ };
+ 
+ enum r3di_out_select {
+ 	/* Set GPIO bit 2 to 0 for headphone */
+ 	R3DI_HEADPHONE_OUT = 0,
+ 	/* Set GPIO bit 2 to 1 for speaker */
+ 	R3DI_LINE_OUT = 1
+ };
+ enum r3di_dsp_status {
+ 	/* Set GPIO bit 3 to 1 until DSP is downloaded */
+ 	R3DI_DSP_DOWNLOADING = 0,
+ 	/* Set GPIO bit 4 to 1 once DSP is downloaded */
+ 	R3DI_DSP_DOWNLOADED = 1
+ };
+ 
+ 
+ static void r3di_gpio_mic_set(struct hda_codec *codec,
+ 		enum r3di_mic_select cur_mic)
+ {
+ 	unsigned int cur_gpio;
+ 
+ 	/* Get the current GPIO Data setup */
+ 	cur_gpio = snd_hda_codec_read(codec, 0x01, 0, AC_VERB_GET_GPIO_DATA, 0);
+ 
+ 	switch (cur_mic) {
+ 	case R3DI_REAR_MIC:
+ 		cur_gpio &= ~(1 << R3DI_MIC_SELECT_BIT);
+ 		break;
+ 	case R3DI_FRONT_MIC:
+ 		cur_gpio |= (1 << R3DI_MIC_SELECT_BIT);
+ 		break;
+ 	}
+ 	snd_hda_codec_write(codec, codec->core.afg, 0,
+ 			    AC_VERB_SET_GPIO_DATA, cur_gpio);
+ }
+ 
+ static void r3di_gpio_out_set(struct hda_codec *codec,
+ 		enum r3di_out_select cur_out)
+ {
+ 	unsigned int cur_gpio;
+ 
+ 	/* Get the current GPIO Data setup */
+ 	cur_gpio = snd_hda_codec_read(codec, 0x01, 0, AC_VERB_GET_GPIO_DATA, 0);
+ 
+ 	switch (cur_out) {
+ 	case R3DI_HEADPHONE_OUT:
+ 		cur_gpio &= ~(1 << R3DI_OUT_SELECT_BIT);
+ 		break;
+ 	case R3DI_LINE_OUT:
+ 		cur_gpio |= (1 << R3DI_OUT_SELECT_BIT);
+ 		break;
+ 	}
+ 	snd_hda_codec_write(codec, codec->core.afg, 0,
+ 			    AC_VERB_SET_GPIO_DATA, cur_gpio);
+ }
+ 
+ static void r3di_gpio_dsp_status_set(struct hda_codec *codec,
+ 		enum r3di_dsp_status dsp_status)
+ {
+ 	unsigned int cur_gpio;
+ 
+ 	/* Get the current GPIO Data setup */
+ 	cur_gpio = snd_hda_codec_read(codec, 0x01, 0, AC_VERB_GET_GPIO_DATA, 0);
+ 
+ 	switch (dsp_status) {
+ 	case R3DI_DSP_DOWNLOADING:
+ 		cur_gpio |= (1 << R3DI_GPIO_DSP_DOWNLOADING);
+ 		snd_hda_codec_write(codec, codec->core.afg, 0,
+ 				AC_VERB_SET_GPIO_DATA, cur_gpio);
+ 		break;
+ 	case R3DI_DSP_DOWNLOADED:
+ 		/* Set DOWNLOADING bit to 0. */
+ 		cur_gpio &= ~(1 << R3DI_GPIO_DSP_DOWNLOADING);
+ 
+ 		snd_hda_codec_write(codec, codec->core.afg, 0,
+ 				AC_VERB_SET_GPIO_DATA, cur_gpio);
+ 
+ 		cur_gpio |= (1 << R3DI_GPIO_DSP_DOWNLOADED);
+ 		break;
+ 	}
+ 
+ 	snd_hda_codec_write(codec, codec->core.afg, 0,
+ 			    AC_VERB_SET_GPIO_DATA, cur_gpio);
+ }
+ 
+ /*
++>>>>>>> 7cb9d94c05de (ALSA: hda/ca0132: add alt_select_in/out for R3Di + SBZ)
   * PCM callbacks
   */
  static int ca0132_playback_pcm_prepare(struct hda_pcm_stream *hinfo,
@@@ -3485,6 -4154,46 +4028,49 @@@ static int ca0132_effects_set(struct hd
  		/* Voice Focus applies to 2-ch Mic, Digital Mic */
  		if ((nid == VOICE_FOCUS) && (spec->cur_mic_type != DIGITAL_MIC))
  			val = 0;
++<<<<<<< HEAD
++=======
+ 
+ 		/* If Voice Focus on SBZ, set to two channel. */
+ 		if ((nid == VOICE_FOCUS) && (spec->quirk == QUIRK_SBZ)
+ 				&& (spec->cur_mic_type != REAR_LINE_IN)) {
+ 			if (spec->effects_switch[CRYSTAL_VOICE -
+ 						 EFFECT_START_NID]) {
+ 
+ 				if (spec->effects_switch[VOICE_FOCUS -
+ 							 EFFECT_START_NID]) {
+ 					tmp = FLOAT_TWO;
+ 					val = 1;
+ 				} else
+ 					tmp = FLOAT_ONE;
+ 
+ 				dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 			}
+ 		}
+ 		/*
+ 		 * For SBZ noise reduction, there's an extra command
+ 		 * to module ID 0x47. No clue why.
+ 		 */
+ 		if ((nid == NOISE_REDUCTION) && (spec->quirk == QUIRK_SBZ)
+ 				&& (spec->cur_mic_type != REAR_LINE_IN)) {
+ 			if (spec->effects_switch[CRYSTAL_VOICE -
+ 						 EFFECT_START_NID]) {
+ 				if (spec->effects_switch[NOISE_REDUCTION -
+ 							 EFFECT_START_NID])
+ 					tmp = FLOAT_ONE;
+ 				else
+ 					tmp = FLOAT_ZERO;
+ 			} else
+ 				tmp = FLOAT_ZERO;
+ 
+ 			dspio_set_uint_param(codec, 0x47, 0x00, tmp);
+ 		}
+ 
+ 		/* If rear line in disable effects. */
+ 		if (spec->use_alt_functions &&
+ 				spec->in_enum_val == REAR_LINE_IN)
+ 			val = 0;
++>>>>>>> 7cb9d94c05de (ALSA: hda/ca0132: add alt_select_in/out for R3Di + SBZ)
  	}
  
  	codec_dbg(codec, "ca0132_effect_set: nid=0x%x, val=%ld\n",
@@@ -4746,11 -6264,33 +5491,37 @@@ static int ca0132_init(struct hda_code
  
  	init_input(codec, cfg->dig_in_pin, spec->dig_in);
  
++<<<<<<< HEAD
 +	snd_hda_sequence_write(codec, spec->chip_init_verbs);
- 	snd_hda_sequence_write(codec, spec->spec_init_verbs);
++=======
+ 	if (!spec->use_alt_functions) {
+ 		snd_hda_sequence_write(codec, spec->chip_init_verbs);
+ 		snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PARAM_EX_ID_SET, 0x0D);
+ 		snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PARAM_EX_VALUE_SET, 0x20);
+ 	}
  
- 	ca0132_select_out(codec);
- 	ca0132_select_mic(codec);
+ 	if (spec->quirk == QUIRK_SBZ)
+ 		ca0132_gpio_setup(codec);
+ 
++>>>>>>> 7cb9d94c05de (ALSA: hda/ca0132: add alt_select_in/out for R3Di + SBZ)
+ 	snd_hda_sequence_write(codec, spec->spec_init_verbs);
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 		sbz_setup_defaults(codec);
+ 		ca0132_alt_select_out(codec);
+ 		ca0132_alt_select_in(codec);
+ 		break;
+ 	case QUIRK_R3DI:
+ 		ca0132_alt_select_out(codec);
+ 		ca0132_alt_select_in(codec);
+ 		break;
+ 	default:
+ 		ca0132_select_out(codec);
+ 		ca0132_select_mic(codec);
+ 		break;
+ 	}
  
  	snd_hda_jack_report_sync(codec);
  
* Unmerged path sound/pci/hda/patch_ca0132.c
