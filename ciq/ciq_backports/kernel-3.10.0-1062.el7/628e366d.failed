gfs2: Iomap cleanups and improvements

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 628e366df11c0a61487522ec1d4bca5c77fe9083
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/628e366d.failed

Clean up gfs2_iomap_alloc and gfs2_iomap_get.  Document how
gfs2_iomap_alloc works: it now needs to be called separately after
gfs2_iomap_get where necessary; this will be used later by iomap write.
Move gfs2_iomap_ops into bmap.c.

Introduce a new gfs2_iomap_get_alloc helper and use it in
fallocate_chunk: gfs2_iomap_begin will become unsuitable for fallocate
with proper iomap write support.

In gfs2_block_map and fallocate_chunk, zero-initialize struct iomap.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 628e366df11c0a61487522ec1d4bca5c77fe9083)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/bmap.c
#	fs/gfs2/inode.c
diff --cc fs/gfs2/bmap.c
index 2b54e62ca6f7,a7b586e02693..000000000000
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@@ -422,20 -436,140 +422,157 @@@ static inline unsigned int gfs2_extent_
  	return (ptr - first);
  }
  
++<<<<<<< HEAD
 +static inline void bmap_lock(struct gfs2_inode *ip, int create)
 +{
 +	if (create)
 +		down_write(&ip->i_rw_mutex);
 +	else
 +		down_read(&ip->i_rw_mutex);
 +}
 +
 +static inline void bmap_unlock(struct gfs2_inode *ip, int create)
 +{
 +	if (create)
 +		up_write(&ip->i_rw_mutex);
 +	else
 +		up_read(&ip->i_rw_mutex);
++=======
+ typedef const __be64 *(*gfs2_metadata_walker)(
+ 		struct metapath *mp,
+ 		const __be64 *start, const __be64 *end,
+ 		u64 factor, void *data);
+ 
+ #define WALK_STOP ((__be64 *)0)
+ #define WALK_NEXT ((__be64 *)1)
+ 
+ static int gfs2_walk_metadata(struct inode *inode, sector_t lblock,
+ 		u64 len, struct metapath *mp, gfs2_metadata_walker walker,
+ 		void *data)
+ {
+ 	struct metapath clone;
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 	struct gfs2_sbd *sdp = GFS2_SB(inode);
+ 	const __be64 *start, *end, *ptr;
+ 	u64 factor = 1;
+ 	unsigned int hgt;
+ 	int ret = 0;
+ 
+ 	for (hgt = ip->i_height - 1; hgt >= mp->mp_aheight; hgt--)
+ 		factor *= sdp->sd_inptrs;
+ 
+ 	for (;;) {
+ 		u64 step;
+ 
+ 		/* Walk indirect block. */
+ 		start = metapointer(hgt, mp);
+ 		end = metaend(hgt, mp);
+ 
+ 		step = (end - start) * factor;
+ 		if (step > len)
+ 			end = start + DIV_ROUND_UP_ULL(len, factor);
+ 
+ 		ptr = walker(mp, start, end, factor, data);
+ 		if (ptr == WALK_STOP)
+ 			break;
+ 		if (step >= len)
+ 			break;
+ 		len -= step;
+ 		if (ptr != WALK_NEXT) {
+ 			BUG_ON(!*ptr);
+ 			mp->mp_list[hgt] += ptr - start;
+ 			goto fill_up_metapath;
+ 		}
+ 
+ lower_metapath:
+ 		/* Decrease height of metapath. */
+ 		if (mp != &clone) {
+ 			clone_metapath(&clone, mp);
+ 			mp = &clone;
+ 		}
+ 		brelse(mp->mp_bh[hgt]);
+ 		mp->mp_bh[hgt] = NULL;
+ 		if (!hgt)
+ 			break;
+ 		hgt--;
+ 		factor *= sdp->sd_inptrs;
+ 
+ 		/* Advance in metadata tree. */
+ 		(mp->mp_list[hgt])++;
+ 		start = metapointer(hgt, mp);
+ 		end = metaend(hgt, mp);
+ 		if (start >= end) {
+ 			mp->mp_list[hgt] = 0;
+ 			if (!hgt)
+ 				break;
+ 			goto lower_metapath;
+ 		}
+ 
+ fill_up_metapath:
+ 		/* Increase height of metapath. */
+ 		if (mp != &clone) {
+ 			clone_metapath(&clone, mp);
+ 			mp = &clone;
+ 		}
+ 		ret = fillup_metapath(ip, mp, ip->i_height - 1);
+ 		if (ret < 0)
+ 			break;
+ 		hgt += ret;
+ 		for (; ret; ret--)
+ 			do_div(factor, sdp->sd_inptrs);
+ 		mp->mp_aheight = hgt + 1;
+ 	}
+ 	if (mp == &clone)
+ 		release_metapath(mp);
+ 	return ret;
+ }
+ 
+ struct gfs2_hole_walker_args {
+ 	u64 blocks;
+ };
+ 
+ static const __be64 *gfs2_hole_walker(struct metapath *mp,
+ 		const __be64 *start, const __be64 *end,
+ 		u64 factor, void *data)
+ {
+ 	struct gfs2_hole_walker_args *args = data;
+ 	const __be64 *ptr;
+ 
+ 	for (ptr = start; ptr < end; ptr++) {
+ 		if (*ptr) {
+ 			args->blocks += (ptr - start) * factor;
+ 			if (mp->mp_aheight == mp->mp_fheight)
+ 				return WALK_STOP;
+ 			return ptr;  /* increase height */
+ 		}
+ 	}
+ 	args->blocks += (end - start) * factor;
+ 	return WALK_NEXT;
+ }
+ 
+ /**
+  * gfs2_hole_size - figure out the size of a hole
+  * @inode: The inode
+  * @lblock: The logical starting block number
+  * @len: How far to look (in blocks)
+  * @mp: The metapath at lblock
+  * @iomap: The iomap to store the hole size in
+  *
+  * This function modifies @mp.
+  *
+  * Returns: errno on error
+  */
+ static int gfs2_hole_size(struct inode *inode, sector_t lblock, u64 len,
+ 			  struct metapath *mp, struct iomap *iomap)
+ {
+ 	struct gfs2_hole_walker_args args = { };
+ 	int ret = 0;
+ 
+ 	ret = gfs2_walk_metadata(inode, lblock, len, mp, gfs2_hole_walker, &args);
+ 	if (!ret)
+ 		iomap->length = args.blocks << inode->i_blkbits;
+ 	return ret;
++>>>>>>> 628e366df11c (gfs2: Iomap cleanups and improvements)
  }
  
  static inline __be64 *gfs2_indirect_init(struct metapath *mp,
@@@ -463,23 -597,12 +600,19 @@@ enum alloc_state 
  	/* ALLOC_UNSTUFF = 3,   TBD and rather complicated */
  };
  
 +static inline unsigned int hptrs(struct gfs2_sbd *sdp, const unsigned int hgt)
 +{
 +	if (hgt)
 +		return sdp->sd_inptrs;
 +	return sdp->sd_diptrs;
 +}
 +
  /**
-  * gfs2_bmap_alloc - Build a metadata tree of the requested height
+  * gfs2_iomap_alloc - Build a metadata tree of the requested height
   * @inode: The GFS2 inode
-  * @lblock: The logical starting block of the extent
-  * @bh_map: This is used to return the mapping details
-  * @zero_new: True if newly allocated blocks should be zeroed
+  * @iomap: The iomap structure
+  * @flags: iomap flags
   * @mp: The metapath, with proper height information calculated
-  * @maxlen: The max number of data blocks to alloc
-  * @dblock: Pointer to return the resulting new block
-  * @dblks: Pointer to return the number of blocks allocated
   *
   * In this routine we may have to alloc:
   *   i) Indirect blocks to grow the metadata tree height
@@@ -621,66 -753,12 +763,68 @@@ static int gfs2_iomap_alloc(struct inod
  	iomap->length = (u64)dblks << inode->i_blkbits;
  	ip->i_height = mp->mp_fheight;
  	gfs2_add_inode_blocks(&ip->i_inode, alloced);
- 	gfs2_dinode_out(ip, mp->mp_bh[0]->b_data);
- 	return 0;
+ 	gfs2_dinode_out(ip, dibh->b_data);
+ out:
+ 	up_write(&ip->i_rw_mutex);
+ 	return ret;
  }
  
 +/**
 + * hole_size - figure out the size of a hole
 + * @inode: The inode
 + * @lblock: The logical starting block number
 + * @mp: The metapath
 + *
 + * Returns: The hole size in bytes
 + *
 + */
 +static u64 hole_size(struct inode *inode, sector_t lblock, struct metapath *mp)
 +{
 +	struct gfs2_inode *ip = GFS2_I(inode);
 +	struct gfs2_sbd *sdp = GFS2_SB(inode);
 +	struct metapath mp_eof;
 +	u64 factor = 1;
 +	int hgt;
 +	u64 holesz = 0;
 +	const __be64 *first, *end, *ptr;
 +	const struct buffer_head *bh;
 +	u64 lblock_stop = (i_size_read(inode) - 1) >> inode->i_blkbits;
 +	int zeroptrs;
 +	bool done = false;
 +
 +	/* Get another metapath, to the very last byte */
 +	find_metapath(sdp, lblock_stop, &mp_eof, ip->i_height);
 +	for (hgt = ip->i_height - 1; hgt >= 0 && !done; hgt--) {
 +		bh = mp->mp_bh[hgt];
 +		if (bh) {
 +			zeroptrs = 0;
 +			first = metapointer(hgt, mp);
 +			end = (const __be64 *)(bh->b_data + bh->b_size);
 +
 +			for (ptr = first; ptr < end; ptr++) {
 +				if (*ptr) {
 +					done = true;
 +					break;
 +				} else {
 +					zeroptrs++;
 +				}
 +			}
 +		} else {
 +			zeroptrs = sdp->sd_inptrs;
 +		}
 +		if (factor * zeroptrs >= lblock_stop - lblock + 1) {
 +			holesz = lblock_stop - lblock + 1;
 +			break;
 +		}
 +		holesz += factor * zeroptrs;
 +
 +		factor *= sdp->sd_inptrs;
 +		if (hgt && (mp->mp_list[hgt - 1] < mp_eof.mp_list[hgt - 1]))
 +			(mp->mp_list[hgt - 1])++;
 +	}
 +	return holesz << inode->i_blkbits;
 +}
 +
  static void gfs2_stuffed_iomap(struct inode *inode, struct iomap *iomap)
  {
  	struct gfs2_inode *ip = GFS2_I(inode);
@@@ -733,20 -809,16 +875,21 @@@ static int gfs2_iomap_get(struct inode 
  		}
  		BUG_ON(!(flags & IOMAP_WRITE));
  	}
- 
  	lblock = pos >> inode->i_blkbits;
++<<<<<<< HEAD
 +	lend = (pos + length + sdp->sd_sb.sb_bsize - 1) >> inode->i_blkbits;
 +
++=======
++>>>>>>> 628e366df11c (gfs2: Iomap cleanups and improvements)
  	iomap->offset = lblock << inode->i_blkbits;
- 	iomap->addr = IOMAP_NULL_ADDR;
- 	iomap->type = IOMAP_HOLE;
- 	iomap->length = (u64)(lend - lblock) << inode->i_blkbits;
- 	iomap->flags = IOMAP_F_MERGED;
- 	bmap_lock(ip, flags & IOMAP_WRITE);
+ 	lblock_stop = (pos + length - 1) >> inode->i_blkbits;
+ 	len = lblock_stop - lblock + 1;
+ 
+ 	down_read(&ip->i_rw_mutex);
  
- 	ret = gfs2_meta_inode_buffer(ip, &mp.mp_bh[0]);
+ 	ret = gfs2_meta_inode_buffer(ip, &mp->mp_bh[0]);
  	if (ret)
- 		goto out_release;
+ 		goto unlock;
  
  	height = ip->i_height;
  	while ((lblock + 1) * sdp->sd_sb.sb_bsize > sdp->sd_heightsize[height])
@@@ -789,16 -863,41 +934,46 @@@ do_alloc
  		loff_t size = i_size_read(inode);
  		if (pos >= size)
  			ret = -ENOENT;
++<<<<<<< HEAD
 +		else if (height <= ip->i_height)
 +			iomap->length = hole_size(inode, lblock, &mp);
++=======
+ 		else if (height == ip->i_height)
+ 			ret = gfs2_hole_size(inode, lblock, len, mp, iomap);
++>>>>>>> 628e366df11c (gfs2: Iomap cleanups and improvements)
  		else
  			iomap->length = size - pos;
  	}
- 	goto out_release;
+ 	goto out;
+ }
+ 
+ static int gfs2_iomap_begin(struct inode *inode, loff_t pos, loff_t length,
+ 			    unsigned flags, struct iomap *iomap)
+ {
+ 	struct gfs2_inode *ip = GFS2_I(inode);
+ 	struct metapath mp = { .mp_aheight = 1, };
+ 	int ret;
+ 
+ 	trace_gfs2_iomap_start(ip, pos, length, flags);
+ 	if (flags & IOMAP_WRITE) {
+ 		ret = gfs2_iomap_get(inode, pos, length, flags, iomap, &mp);
+ 		if (!ret && iomap->type == IOMAP_HOLE)
+ 			ret = gfs2_iomap_alloc(inode, iomap, flags, &mp);
+ 		release_metapath(&mp);
+ 	} else {
+ 		ret = gfs2_iomap_get(inode, pos, length, flags, iomap, &mp);
+ 		release_metapath(&mp);
+ 	}
+ 	trace_gfs2_iomap_end(ip, iomap, ret);
+ 	return ret;
  }
  
+ const struct iomap_ops gfs2_iomap_ops = {
+ 	.iomap_begin = gfs2_iomap_begin,
+ };
+ 
  /**
 - * gfs2_block_map - Map one or more blocks of an inode to a disk block
 + * gfs2_block_map - Map a block from an inode to a disk block
   * @inode: The inode
   * @lblock: The logical block number
   * @bh_map: The bh to be mapped
diff --cc fs/gfs2/inode.c
index 95f62655c159,feda55f67050..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -1936,71 -2006,6 +1936,74 @@@ static int gfs2_getattr(struct vfsmoun
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int gfs2_setxattr(struct dentry *dentry, const char *name,
 +			 const void *data, size_t size, int flags)
 +{
 +	struct inode *inode = dentry->d_inode;
 +	struct gfs2_inode *ip = GFS2_I(inode);
 +	struct gfs2_holder gh;
 +	int ret;
 +
 +	gfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);
 +	ret = gfs2_glock_nq(&gh);
 +	if (ret == 0) {
 +		ret = gfs2_rsqa_alloc(ip);
 +		if (ret == 0)
 +			ret = generic_setxattr(dentry, name, data, size, flags);
 +		gfs2_glock_dq(&gh);
 +	}
 +	gfs2_holder_uninit(&gh);
 +	return ret;
 +}
 +
 +static ssize_t gfs2_getxattr(struct dentry *dentry, const char *name,
 +			     void *data, size_t size)
 +{
 +	struct inode *inode = dentry->d_inode;
 +	struct gfs2_inode *ip = GFS2_I(inode);
 +	struct gfs2_holder gh;
 +	int ret;
 +
 +	/* For selinux during lookup */
 +	if (gfs2_glock_is_locked_by_me(ip->i_gl))
 +		return generic_getxattr(dentry, name, data, size);
 +
 +	gfs2_holder_init(ip->i_gl, LM_ST_SHARED, LM_FLAG_ANY, &gh);
 +	ret = gfs2_glock_nq(&gh);
 +	if (ret == 0) {
 +		ret = generic_getxattr(dentry, name, data, size);
 +		gfs2_glock_dq(&gh);
 +	}
 +	gfs2_holder_uninit(&gh);
 +	return ret;
 +}
 +
 +static int gfs2_removexattr(struct dentry *dentry, const char *name)
 +{
 +	struct inode *inode = dentry->d_inode;
 +	struct gfs2_inode *ip = GFS2_I(inode);
 +	struct gfs2_holder gh;
 +	int ret;
 +
 +	gfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);
 +	ret = gfs2_glock_nq(&gh);
 +	if (ret == 0) {
 +		ret = gfs2_rsqa_alloc(ip);
 +		if (ret == 0)
 +			ret = generic_removexattr(dentry, name);
 +		gfs2_glock_dq(&gh);
 +	}
 +	gfs2_holder_uninit(&gh);
 +	return ret;
 +}
 +
 +const struct iomap_ops gfs2_iomap_ops = {
 +	.iomap_begin = gfs2_iomap_begin,
 +};
 +
++=======
++>>>>>>> 628e366df11c (gfs2: Iomap cleanups and improvements)
  static int gfs2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
  		       u64 start, u64 len)
  {
* Unmerged path fs/gfs2/bmap.c
diff --git a/fs/gfs2/bmap.h b/fs/gfs2/bmap.h
index ae77fbf8b45f..822ba98cffb1 100644
--- a/fs/gfs2/bmap.h
+++ b/fs/gfs2/bmap.h
@@ -46,11 +46,13 @@ static inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,
 	}
 }
 
+extern const struct iomap_ops gfs2_iomap_ops;
+
 extern int gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page);
 extern int gfs2_block_map(struct inode *inode, sector_t lblock,
 			  struct buffer_head *bh, int create);
-extern int gfs2_iomap_begin(struct inode *inode, loff_t pos, loff_t length,
-			    unsigned flags, struct iomap *iomap);
+extern int gfs2_iomap_get_alloc(struct inode *inode, loff_t pos, loff_t length,
+				struct iomap *iomap);
 extern int gfs2_extent_map(struct inode *inode, u64 lblock, int *new,
 			   u64 *dblock, unsigned *extlen);
 extern int gfs2_setattr_size(struct inode *inode, u64 size);
diff --git a/fs/gfs2/file.c b/fs/gfs2/file.c
index 8ac5e297cd6d..6c96005746a9 100644
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@ -739,7 +739,7 @@ static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,
 	struct gfs2_inode *ip = GFS2_I(inode);
 	loff_t end = offset + len;
 	struct buffer_head *dibh;
-	struct iomap iomap;
+	struct iomap iomap = { };
 	int error;
 
 	error = gfs2_meta_inode_buffer(ip, &dibh);
@@ -755,8 +755,8 @@ static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,
 	}
 
 	while (offset < end) {
-		error = gfs2_iomap_begin(inode, offset, end - offset,
-					 IOMAP_WRITE, &iomap);
+		error = gfs2_iomap_get_alloc(inode, offset, end - offset,
+					     &iomap);
 		if (error)
 			goto out;
 		offset = iomap.offset + iomap.length;
* Unmerged path fs/gfs2/inode.c
