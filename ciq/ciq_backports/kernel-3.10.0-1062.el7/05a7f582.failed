net: phy: add locking to phy_read_mmd_indirect()/phy_write_mmd_indirect()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] phy: add locking to phy_read_mmd_indirect()/phy_write_mmd_indirect() (Ivan Vecera) [1655590]
Rebuild_FUZZ: 96.45%
commit-author Russell King <rmk+kernel@arm.linux.org.uk>
commit 05a7f582be961824d62a7f4a817f3783148b5f8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/05a7f582.failed

The phy layer is missing locking for the above two functions - it
has been observed that two threads (userspace and the phy worker
thread) can race, entering the bus ->write or ->read functions
simultaneously.

This causes the FEC driver to initialise a completion while another
thread is waiting on it or while the interrupt is calling complete()
on it, which causes spinlock unlock-without-lock, spinlock lockups,
and completion timeouts.

Fixes: a59a4d192 ("phy: add the EEE support and the way to access to the MMD registers.")
Fixes: 0c1d77dfb ("net: libphy: Add phy specific function to access mmd phy registers")
	Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
	Acked-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 05a7f582be961824d62a7f4a817f3783148b5f8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phy.c
diff --cc drivers/net/phy/phy.c
index 72b4ef80a369,34fe339f4e80..000000000000
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@@ -939,14 -1031,27 +939,30 @@@ static inline void mmd_phy_indirect(str
   * 3) Write reg 13 // MMD Data Command for MMD DEVAD
   * 3) Read  reg 14 // Read MMD data
   */
 -int phy_read_mmd_indirect(struct phy_device *phydev, int prtad,
 -				 int devad, int addr)
 +static int phy_read_mmd_indirect(struct mii_bus *bus, int prtad, int devad,
 +				 int addr)
  {
 -	struct phy_driver *phydrv = phydev->drv;
 -	int value = -1;
 +	mmd_phy_indirect(bus, prtad, devad, addr);
  
++<<<<<<< HEAD
 +	/* Read the content of the MMD's selected register */
 +	return bus->read(bus, addr, MII_MMD_DATA);
++=======
+ 	if (phydrv->read_mmd_indirect == NULL) {
+ 		struct mii_bus *bus = phydev->bus;
+ 
+ 		mutex_lock(&bus->mdio_lock);
+ 		mmd_phy_indirect(bus, prtad, devad, addr);
+ 
+ 		/* Read the content of the MMD's selected register */
+ 		value = bus->read(bus, addr, MII_MMD_DATA);
+ 		mutex_unlock(&bus->mdio_lock);
+ 	} else {
+ 		value = phydrv->read_mmd_indirect(phydev, prtad, devad, addr);
+ 	}
+ 	return value;
++>>>>>>> 05a7f582be96 (net: phy: add locking to phy_read_mmd_indirect()/phy_write_mmd_indirect())
  }
 -EXPORT_SYMBOL(phy_read_mmd_indirect);
  
  /**
   * phy_write_mmd_indirect - writes data to the MMD registers
@@@ -964,14 -1069,25 +980,29 @@@
   * 3) Write reg 13 // MMD Data Command for MMD DEVAD
   * 3) Write reg 14 // Write MMD data
   */
 -void phy_write_mmd_indirect(struct phy_device *phydev, int prtad,
 -				   int devad, int addr, u32 data)
 +static void phy_write_mmd_indirect(struct mii_bus *bus, int prtad, int devad,
 +				   int addr, u32 data)
  {
 -	struct phy_driver *phydrv = phydev->drv;
 +	mmd_phy_indirect(bus, prtad, devad, addr);
  
++<<<<<<< HEAD
 +	/* Write the data into MMD's selected register */
 +	bus->write(bus, addr, MII_MMD_DATA, data);
++=======
+ 	if (phydrv->write_mmd_indirect == NULL) {
+ 		struct mii_bus *bus = phydev->bus;
+ 
+ 		mutex_lock(&bus->mdio_lock);
+ 		mmd_phy_indirect(bus, prtad, devad, addr);
+ 
+ 		/* Write the data into MMD's selected register */
+ 		bus->write(bus, addr, MII_MMD_DATA, data);
+ 		mutex_unlock(&bus->mdio_lock);
+ 	} else {
+ 		phydrv->write_mmd_indirect(phydev, prtad, devad, addr, data);
+ 	}
++>>>>>>> 05a7f582be96 (net: phy: add locking to phy_read_mmd_indirect()/phy_write_mmd_indirect())
  }
 -EXPORT_SYMBOL(phy_write_mmd_indirect);
  
  /**
   * phy_init_eee - init and check the EEE feature
* Unmerged path drivers/net/phy/phy.c
