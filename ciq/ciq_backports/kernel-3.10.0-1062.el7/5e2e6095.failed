ixgbe: implement flush flag for ndo_xdp_xmit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jesper Dangaard Brouer <brouer@redhat.com>
commit 5e2e609522d67750d4b3c0321d1917bb109ac41b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/5e2e6095.failed

When passed the XDP_XMIT_FLUSH flag ixgbe_xdp_xmit now performs the
same kind of ring tail update as in ixgbe_xdp_flush.  The update tail
code in ixgbe_xdp_flush is generalized and shared with ixgbe_xdp_xmit.

	Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
	Acked-by: Song Liu <songliubraving@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 5e2e609522d67750d4b3c0321d1917bb109ac41b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 234a73d7e0c5,4fd77c9067f2..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -9931,8 -10022,74 +9931,78 @@@ static int ixgbe_xdp(struct net_device 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void ixgbe_xdp_ring_update_tail(struct ixgbe_ring *ring)
+ {
+ 	/* Force memory writes to complete before letting h/w know there
+ 	 * are new descriptors to fetch.
+ 	 */
+ 	wmb();
+ 	writel(ring->next_to_use, ring->tail);
+ }
+ 
+ static int ixgbe_xdp_xmit(struct net_device *dev, int n,
+ 			  struct xdp_frame **frames, u32 flags)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 	struct ixgbe_ring *ring;
+ 	int drops = 0;
+ 	int i;
+ 
+ 	if (unlikely(test_bit(__IXGBE_DOWN, &adapter->state)))
+ 		return -ENETDOWN;
+ 
+ 	if (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))
+ 		return -EINVAL;
+ 
+ 	/* During program transitions its possible adapter->xdp_prog is assigned
+ 	 * but ring has not been configured yet. In this case simply abort xmit.
+ 	 */
+ 	ring = adapter->xdp_prog ? adapter->xdp_ring[smp_processor_id()] : NULL;
+ 	if (unlikely(!ring))
+ 		return -ENXIO;
+ 
+ 	for (i = 0; i < n; i++) {
+ 		struct xdp_frame *xdpf = frames[i];
+ 		int err;
+ 
+ 		err = ixgbe_xmit_xdp_ring(adapter, xdpf);
+ 		if (err != IXGBE_XDP_TX) {
+ 			xdp_return_frame_rx_napi(xdpf);
+ 			drops++;
+ 		}
+ 	}
+ 
+ 	if (unlikely(flags & XDP_XMIT_FLUSH))
+ 		ixgbe_xdp_ring_update_tail(ring);
+ 
+ 	return n - drops;
+ }
+ 
+ static void ixgbe_xdp_flush(struct net_device *dev)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 	struct ixgbe_ring *ring;
+ 
+ 	/* Its possible the device went down between xdp xmit and flush so
+ 	 * we need to ensure device is still up.
+ 	 */
+ 	if (unlikely(test_bit(__IXGBE_DOWN, &adapter->state)))
+ 		return;
+ 
+ 	ring = adapter->xdp_prog ? adapter->xdp_ring[smp_processor_id()] : NULL;
+ 	if (unlikely(!ring))
+ 		return;
+ 
+ 	ixgbe_xdp_ring_update_tail(ring);
+ 
+ 	return;
+ }
+ 
++>>>>>>> 5e2e609522d6 (ixgbe: implement flush flag for ndo_xdp_xmit)
  static const struct net_device_ops ixgbe_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
  	.ndo_open		= ixgbe_open,
  	.ndo_stop		= ixgbe_close,
  	.ndo_start_xmit		= ixgbe_xmit_frame,
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
