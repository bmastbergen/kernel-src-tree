IB/umad: Avoid destroying device while it is accessed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Parav Pandit <parav@mellanox.com>
commit cf7ad3030271c55a7119a8c2162563e3f6e93879
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/cf7ad303.failed

ib_umad_reg_agent2() and ib_umad_reg_agent() access the device name in
dev_notice(), while concurrently, ib_umad_kill_port() can destroy the
device using device_destroy().

        cpu-0                               cpu-1
        -----                               -----
    ib_umad_ioctl()
        [...]                            ib_umad_kill_port()
                                              device_destroy(dev)

        ib_umad_reg_agent()
            dev_notice(dev)

Therefore, first mark ib_dev as NULL, to block any further access in file
ops, unregister the mad agent and destroy the device at the end after
mutex is unlocked.

This ensures that device doesn't get destroyed, while it may get accessed.

Fixes: 0f29b46d49b0 ("IB/mad: add new ioctl to ABI to support new registration options")
	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Jack Morgenstein <jackm@mellanox.com>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit cf7ad3030271c55a7119a8c2162563e3f6e93879)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/user_mad.c
diff --cc drivers/infiniband/core/user_mad.c
index a4ddcc96e8b7,0204a4fefd13..000000000000
--- a/drivers/infiniband/core/user_mad.c
+++ b/drivers/infiniband/core/user_mad.c
@@@ -1268,7 -1262,17 +1262,21 @@@ static void ib_umad_kill_port(struct ib
  	}
  
  	mutex_unlock(&port->file_mutex);
++<<<<<<< HEAD
 +	clear_bit(port->dev_num, dev_map);
++=======
+ 
+ 	dev_set_drvdata(port->dev,    NULL);
+ 	dev_set_drvdata(port->sm_dev, NULL);
+ 
+ 	device_destroy(&umad_class, port->cdev.dev);
+ 	device_destroy(&umad_class, port->sm_cdev.dev);
+ 
+ 	cdev_del(&port->cdev);
+ 	cdev_del(&port->sm_cdev);
+ 
+ 	ida_free(&umad_ida, port->dev_num);
++>>>>>>> cf7ad3030271 (IB/umad: Avoid destroying device while it is accessed)
  }
  
  static void ib_umad_add_one(struct ib_device *device)
* Unmerged path drivers/infiniband/core/user_mad.c
