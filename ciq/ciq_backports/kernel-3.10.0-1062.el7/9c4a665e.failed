ALSA: hda/ca0132: make array ca0132_alt_chmaps static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Colin Ian King <colin.king@canonical.com>
commit 9c4a665ed83462039461dd34282e22160fb447ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9c4a665e.failed

The array ca0132_alt_chmaps is local to the source and does not
need to be in global scope, so make it static.

Cleans up sparse warning:
warning: symbol 'ca0132_alt_chmaps' was not declared. Should it be
static?

	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 9c4a665ed83462039461dd34282e22160fb447ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index 2b8dca7fa057,4ff5320378e2..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -3972,6 -5571,136 +3972,139 @@@ static int add_voicefx(struct hda_code
  	return snd_hda_ctl_add(codec, VOICEFX, snd_ctl_new1(&knew, codec));
  }
  
++<<<<<<< HEAD
++=======
+ /* Create the EQ Preset control */
+ static int add_ca0132_alt_eq_presets(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO(ca0132_alt_eq_enum.name,
+ 				    EQ_PRESET_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ca0132_alt_eq_preset_info;
+ 	knew.get = ca0132_alt_eq_preset_get;
+ 	knew.put = ca0132_alt_eq_preset_put;
+ 	return snd_hda_ctl_add(codec, EQ_PRESET_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Add enumerated control for the three different settings of the smart volume
+  * output effect. Normal just uses the slider value, and loud and night are
+  * their own things that ignore that value.
+  */
+ static int ca0132_alt_add_svm_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("FX: Smart Volume Setting",
+ 				    SMART_VOLUME_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ca0132_alt_svm_setting_info;
+ 	knew.get = ca0132_alt_svm_setting_get;
+ 	knew.put = ca0132_alt_svm_setting_put;
+ 	return snd_hda_ctl_add(codec, SMART_VOLUME_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ 
+ }
+ 
+ /*
+  * Create an Output Select enumerated control for codecs with surround
+  * out capabilities.
+  */
+ static int ca0132_alt_add_output_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("Output Select",
+ 				    OUTPUT_SOURCE_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ca0132_alt_output_select_get_info;
+ 	knew.get = ca0132_alt_output_select_get;
+ 	knew.put = ca0132_alt_output_select_put;
+ 	return snd_hda_ctl_add(codec, OUTPUT_SOURCE_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Create an Input Source enumerated control for the alternate ca0132 codecs
+  * because the front microphone has no auto-detect, and Line-in has to be set
+  * somehow.
+  */
+ static int ca0132_alt_add_input_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("Input Source",
+ 				    INPUT_SOURCE_ENUM, 1, 0, HDA_INPUT);
+ 	knew.info = ca0132_alt_input_source_info;
+ 	knew.get = ca0132_alt_input_source_get;
+ 	knew.put = ca0132_alt_input_source_put;
+ 	return snd_hda_ctl_add(codec, INPUT_SOURCE_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Add mic boost enumerated control. Switches through 0dB to 30dB. This adds
+  * more control than the original mic boost, which is either full 30dB or off.
+  */
+ static int ca0132_alt_add_mic_boost_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("Mic Boost Capture Switch",
+ 				    MIC_BOOST_ENUM, 1, 0, HDA_INPUT);
+ 	knew.info = ca0132_alt_mic_boost_info;
+ 	knew.get = ca0132_alt_mic_boost_get;
+ 	knew.put = ca0132_alt_mic_boost_put;
+ 	return snd_hda_ctl_add(codec, MIC_BOOST_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ 
+ }
+ 
+ /*
+  * Need to create slave controls for the alternate codecs that have surround
+  * capabilities.
+  */
+ static const char * const ca0132_alt_slave_pfxs[] = {
+ 	"Front", "Surround", "Center", "LFE", NULL,
+ };
+ 
+ /*
+  * Also need special channel map, because the default one is incorrect.
+  * I think this has to do with the pin for rear surround being 0x11,
+  * and the center/lfe being 0x10. Usually the pin order is the opposite.
+  */
+ static const struct snd_pcm_chmap_elem ca0132_alt_chmaps[] = {
+ 	{ .channels = 2,
+ 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
+ 	{ .channels = 4,
+ 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+ 		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+ 	{ .channels = 6,
+ 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+ 		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,
+ 		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+ 	{ }
+ };
+ 
+ /* Add the correct chmap for streams with 6 channels. */
+ static void ca0132_alt_add_chmap_ctls(struct hda_codec *codec)
+ {
+ 	int err = 0;
+ 	struct hda_pcm *pcm;
+ 
+ 	list_for_each_entry(pcm, &codec->pcm_list_head, list) {
+ 		struct hda_pcm_stream *hinfo =
+ 			&pcm->stream[SNDRV_PCM_STREAM_PLAYBACK];
+ 		struct snd_pcm_chmap *chmap;
+ 		const struct snd_pcm_chmap_elem *elem;
+ 
+ 		elem = ca0132_alt_chmaps;
+ 		if (hinfo->channels_max == 6) {
+ 			err = snd_pcm_add_chmap_ctls(pcm->pcm,
+ 					SNDRV_PCM_STREAM_PLAYBACK,
+ 					elem, hinfo->channels_max, 0, &chmap);
+ 			if (err < 0)
+ 				codec_dbg(codec, "snd_pcm_add_chmap_ctls failed!");
+ 		}
+ 	}
+ }
+ 
++>>>>>>> 9c4a665ed834 (ALSA: hda/ca0132: make array ca0132_alt_chmaps static)
  /*
   * When changing Node IDs for Mixer Controls below, make sure to update
   * Node IDs in ca0132_config() as well.
* Unmerged path sound/pci/hda/patch_ca0132.c
