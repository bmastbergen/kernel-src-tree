x86/MCE: Make correctable error detection look at the Deferred bit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] mce: Make correctable error detection look at the Deferred bit (Jeff Moyer) [1662229]
Rebuild_FUZZ: 96.88%
commit-author Yazen Ghannam <yazen.ghannam@amd.com>
commit 179eb850ac57c06edaed67fc744ba9d902172f96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/179eb850.failed

AMD systems may log Deferred errors. These are errors that are uncorrected
but which do not need immediate action. The MCA_STATUS[UC] bit may not be
set for Deferred errors.

Flag the error as not correctable when MCA_STATUS[Deferred] is set and
do not feed it into the Correctable Errors Collector.

[ bp: Massage commit message. ]

	Signed-off-by: Yazen Ghannam <yazen.ghannam@amd.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20171212165143.27475-1-Yazen.Ghannam@amd.com

(cherry picked from commit 179eb850ac57c06edaed67fc744ba9d902172f96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/mcheck/mce.c
diff --cc arch/x86/kernel/cpu/mcheck/mce.c
index f4e26139f488,1b2c11473376..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce.c
+++ b/arch/x86/kernel/cpu/mcheck/mce.c
@@@ -553,6 -499,87 +553,89 @@@ static int mce_usable_address(struct mc
  	return 1;
  }
  
++<<<<<<< HEAD
++=======
+ bool mce_is_memory_error(struct mce *m)
+ {
+ 	if (m->cpuvendor == X86_VENDOR_AMD) {
+ 		return amd_mce_is_memory_error(m);
+ 
+ 	} else if (m->cpuvendor == X86_VENDOR_INTEL) {
+ 		/*
+ 		 * Intel SDM Volume 3B - 15.9.2 Compound Error Codes
+ 		 *
+ 		 * Bit 7 of the MCACOD field of IA32_MCi_STATUS is used for
+ 		 * indicating a memory error. Bit 8 is used for indicating a
+ 		 * cache hierarchy error. The combination of bit 2 and bit 3
+ 		 * is used for indicating a `generic' cache hierarchy error
+ 		 * But we can't just blindly check the above bits, because if
+ 		 * bit 11 is set, then it is a bus/interconnect error - and
+ 		 * either way the above bits just gives more detail on what
+ 		 * bus/interconnect error happened. Note that bit 12 can be
+ 		 * ignored, as it's the "filter" bit.
+ 		 */
+ 		return (m->status & 0xef80) == BIT(7) ||
+ 		       (m->status & 0xef00) == BIT(8) ||
+ 		       (m->status & 0xeffc) == 0xc;
+ 	}
+ 
+ 	return false;
+ }
+ EXPORT_SYMBOL_GPL(mce_is_memory_error);
+ 
+ static bool mce_is_correctable(struct mce *m)
+ {
+ 	if (m->cpuvendor == X86_VENDOR_AMD && m->status & MCI_STATUS_DEFERRED)
+ 		return false;
+ 
+ 	if (m->status & MCI_STATUS_UC)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static bool cec_add_mce(struct mce *m)
+ {
+ 	if (!m)
+ 		return false;
+ 
+ 	/* We eat only correctable DRAM errors with usable addresses. */
+ 	if (mce_is_memory_error(m) &&
+ 	    mce_is_correctable(m)  &&
+ 	    mce_usable_address(m))
+ 		if (!cec_add_elem(m->addr >> PAGE_SHIFT))
+ 			return true;
+ 
+ 	return false;
+ }
+ 
+ static int mce_first_notifier(struct notifier_block *nb, unsigned long val,
+ 			      void *data)
+ {
+ 	struct mce *m = (struct mce *)data;
+ 
+ 	if (!m)
+ 		return NOTIFY_DONE;
+ 
+ 	if (cec_add_mce(m))
+ 		return NOTIFY_STOP;
+ 
+ 	/* Emit the trace record: */
+ 	trace_mce_record(m);
+ 
+ 	set_bit(0, &mce_need_notify);
+ 
+ 	mce_notify_irq();
+ 
+ 	return NOTIFY_DONE;
+ }
+ 
+ static struct notifier_block first_nb = {
+ 	.notifier_call	= mce_first_notifier,
+ 	.priority	= MCE_PRIO_FIRST,
+ };
+ 
++>>>>>>> 179eb850ac57 (x86/MCE: Make correctable error detection look at the Deferred bit)
  static int srao_decode_notifier(struct notifier_block *nb, unsigned long val,
  				void *data)
  {
* Unmerged path arch/x86/kernel/cpu/mcheck/mce.c
