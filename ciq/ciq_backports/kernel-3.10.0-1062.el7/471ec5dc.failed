ovl: struct cattr cleanups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 471ec5dcf4e712ea81bf431a57c98d4b67416d30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/471ec5dc.failed

* Rename to ovl_cattr

* Fold ovl_create_real() hardlink argument into struct ovl_cattr

* Create macro OVL_CATTR() to initialize struct ovl_cattr from mode

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 471ec5dcf4e712ea81bf431a57c98d4b67416d30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/dir.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/copy_up.c
index 5bfbfc122918,5f4c78b1bbeb..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -540,8 -509,7 +540,12 @@@ static int ovl_get_tmpfile(struct ovl_c
  		if (IS_ERR(temp))
  			goto temp_err;
  
++<<<<<<< HEAD
 +		err = ovl_create_real(d_inode(c->workdir), temp, &cattr,
 +				      NULL, true);
++=======
+ 		err = ovl_create_real(d_inode(c->workdir), temp, &cattr);
++>>>>>>> 471ec5dcf4e7 (ovl: struct cattr cleanups)
  		if (err) {
  			dput(temp);
  			goto out;
diff --cc fs/overlayfs/dir.c
index de117ec8c92e,0fb3ef85f298..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -115,15 -115,15 +115,24 @@@ kill_whiteout
  }
  
  int ovl_create_real(struct inode *dir, struct dentry *newdentry,
++<<<<<<< HEAD
 +		    struct cattr *attr, struct dentry *hardlink, bool debug)
++=======
+ 		    struct ovl_cattr *attr)
++>>>>>>> 471ec5dcf4e7 (ovl: struct cattr cleanups)
  {
  	int err;
  
  	if (newdentry->d_inode)
  		return -ESTALE;
  
++<<<<<<< HEAD
 +	if (hardlink) {
 +		err = ovl_do_link(hardlink, dir, newdentry, debug);
++=======
+ 	if (attr->hardlink) {
+ 		err = ovl_do_link(attr->hardlink, dir, newdentry);
++>>>>>>> 471ec5dcf4e7 (ovl: struct cattr cleanups)
  	} else {
  		switch (attr->mode & S_IFMT) {
  		case S_IFREG:
@@@ -220,16 -220,16 +229,20 @@@ static int ovl_create_upper(struct dent
  	struct dentry *newdentry;
  	int err;
  
- 	if (!hardlink && !IS_POSIXACL(udir))
+ 	if (!attr->hardlink && !IS_POSIXACL(udir))
  		attr->mode &= ~current_umask();
  
 -	inode_lock_nested(udir, I_MUTEX_PARENT);
 +	mutex_lock_nested(&udir->i_mutex, I_MUTEX_PARENT);
  	newdentry = lookup_one_len(dentry->d_name.name, upperdir,
  				   dentry->d_name.len);
  	err = PTR_ERR(newdentry);
  	if (IS_ERR(newdentry))
  		goto out_unlock;
++<<<<<<< HEAD
 +	err = ovl_create_real(udir, newdentry, attr, hardlink, false);
++=======
+ 	err = ovl_create_real(udir, newdentry, attr);
++>>>>>>> 471ec5dcf4e7 (ovl: struct cattr cleanups)
  	if (err)
  		goto out_dput;
  
@@@ -284,8 -285,7 +297,12 @@@ static struct dentry *ovl_clear_empty(s
  	if (IS_ERR(opaquedir))
  		goto out_unlock;
  
++<<<<<<< HEAD
 +	err = ovl_create_real(wdir, opaquedir,
 +			      &(struct cattr){.mode = stat.mode}, NULL, true);
++=======
+ 	err = ovl_create_real(wdir, opaquedir, OVL_CATTR(stat.mode));
++>>>>>>> 471ec5dcf4e7 (ovl: struct cattr cleanups)
  	if (err)
  		goto out_dput;
  
@@@ -352,53 -352,8 +369,52 @@@ out_free
  	return err;
  }
  
 +static int ovl_posix_acl_create(struct inode *dir, umode_t *mode,
 +				struct posix_acl **default_acl,
 +				struct posix_acl **acl)
 +{
 +	struct posix_acl *p;
 +	struct posix_acl *clone;
 +	int ret;
 +
 +	*acl = NULL;
 +	*default_acl = NULL;
 +
 +	if (S_ISLNK(*mode) || !IS_POSIXACL(dir))
 +		return 0;
 +
 +	p = ovl_get_acl(dir, ACL_TYPE_DEFAULT);
 +	if (!p || p == ERR_PTR(-EOPNOTSUPP)) {
 +		*mode &= ~current_umask();
 +		return 0;
 +	}
 +	if (IS_ERR(p))
 +		return PTR_ERR(p);
 +
 +	clone = posix_acl_dup(p);
 +	ret = posix_acl_create(&clone, GFP_NOFS, mode);
 +	if (ret)
 +		goto err_release;
 +
 +	if (ret == 0)
 +		posix_acl_release(clone);
 +	else
 +		*acl = clone;
 +
 +	if (!S_ISDIR(*mode))
 +		posix_acl_release(p);
 +	else
 +		*default_acl = p;
 +
 +	return 0;
 +
 +err_release:
 +	posix_acl_release(p);
 +	return ret;
 +}
 +
  static int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,
- 				    struct cattr *cattr,
- 				    struct dentry *hardlink)
+ 				    struct ovl_cattr *cattr)
  {
  	struct dentry *workdir = ovl_workdir(dentry);
  	struct inode *wdir = workdir->d_inode;
@@@ -407,7 -362,8 +423,12 @@@
  	struct dentry *upper;
  	struct dentry *newdentry;
  	int err;
++<<<<<<< HEAD
 +	struct posix_acl *uninitialized_var(acl), *uninitialized_var(default_acl);
++=======
+ 	struct posix_acl *acl, *default_acl;
+ 	bool hardlink = !!cattr->hardlink;
++>>>>>>> 471ec5dcf4e7 (ovl: struct cattr cleanups)
  
  	if (WARN_ON(!workdir))
  		return -EROFS;
@@@ -434,7 -390,7 +455,11 @@@
  	if (IS_ERR(upper))
  		goto out_dput;
  
++<<<<<<< HEAD
 +	err = ovl_create_real(wdir, newdentry, cattr, hardlink, true);
++=======
+ 	err = ovl_create_real(wdir, newdentry, cattr);
++>>>>>>> 471ec5dcf4e7 (ovl: struct cattr cleanups)
  	if (err)
  		goto out_dput2;
  
diff --cc fs/overlayfs/overlayfs.h
index 403c48960f89,aa8286419133..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -311,10 -353,13 +311,18 @@@ struct ovl_cattr 
  	dev_t rdev;
  	umode_t mode;
  	const char *link;
+ 	struct dentry *hardlink;
  };
+ 
+ #define OVL_CATTR(m) (&(struct ovl_cattr) { .mode = (m) })
+ 
  int ovl_create_real(struct inode *dir, struct dentry *newdentry,
++<<<<<<< HEAD
 +		    struct cattr *attr,
 +		    struct dentry *hardlink, bool debug);
++=======
+ 		    struct ovl_cattr *attr);
++>>>>>>> 471ec5dcf4e7 (ovl: struct cattr cleanups)
  int ovl_cleanup(struct inode *dir, struct dentry *dentry);
  
  /* copy_up.c */
diff --cc fs/overlayfs/super.c
index b0392d1737a3,286d36772e9c..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -533,9 -611,7 +533,13 @@@ retry
  			goto retry;
  		}
  
++<<<<<<< HEAD
 +		err = ovl_create_real(dir, work,
 +				      &(struct cattr){.mode = S_IFDIR | 0},
 +				      NULL, true);
++=======
+ 		err = ovl_create_real(dir, work, OVL_CATTR(attr.ia_mode));
++>>>>>>> 471ec5dcf4e7 (ovl: struct cattr cleanups)
  		if (err)
  			goto out_dput;
  
* Unmerged path fs/overlayfs/copy_up.c
* Unmerged path fs/overlayfs/dir.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/super.c
