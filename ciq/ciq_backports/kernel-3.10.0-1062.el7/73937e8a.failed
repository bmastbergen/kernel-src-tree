RDMA/nldev: helper functions to add driver attributes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Steve Wise <swise@opengridcomputing.com>
commit 73937e8a030b046c6b0fa73868bee25647a29be4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/73937e8a.failed

These help rdma drivers to fill out the driver entries.

	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 73937e8a030b046c6b0fa73868bee25647a29be4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/rdma/restrack.h
diff --cc include/rdma/restrack.h
index 7513d0d8b9da,637968589922..000000000000
--- a/include/rdma/restrack.h
+++ b/include/rdma/restrack.h
@@@ -11,6 -11,8 +11,11 @@@
  #include <linux/sched.h>
  #include <linux/kref.h>
  #include <linux/completion.h>
++<<<<<<< HEAD
++=======
+ #include <linux/sched/task.h>
+ #include <uapi/rdma/rdma_netlink.h>
++>>>>>>> 73937e8a030b (RDMA/nldev: helper functions to add driver attributes)
  
  /**
   * enum rdma_restrack_type - HW objects to track
@@@ -150,4 -169,29 +155,32 @@@ int __must_check rdma_restrack_get(stru
   * @res:  resource entry
   */
  int rdma_restrack_put(struct rdma_restrack_entry *res);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * rdma_restrack_set_task() - set the task for this resource
+  * @res:  resource entry
+  * @task: task struct
+  */
+ static inline void rdma_restrack_set_task(struct rdma_restrack_entry *res,
+ 					  struct task_struct *task)
+ {
+ 	if (res->task)
+ 		put_task_struct(res->task);
+ 	get_task_struct(task);
+ 	res->task = task;
+ }
+ 
+ /*
+  * Helper functions for rdma drivers when filling out
+  * nldev driver attributes.
+  */
+ int rdma_nl_put_driver_u32(struct sk_buff *msg, const char *name, u32 value);
+ int rdma_nl_put_driver_u32_hex(struct sk_buff *msg, const char *name,
+ 			       u32 value);
+ int rdma_nl_put_driver_u64(struct sk_buff *msg, const char *name, u64 value);
+ int rdma_nl_put_driver_u64_hex(struct sk_buff *msg, const char *name,
+ 			       u64 value);
++>>>>>>> 73937e8a030b (RDMA/nldev: helper functions to add driver attributes)
  #endif /* _RDMA_RESTRACK_H_ */
diff --git a/drivers/infiniband/core/nldev.c b/drivers/infiniband/core/nldev.c
index 67368b6847cb..d55b80a28f5a 100644
--- a/drivers/infiniband/core/nldev.c
+++ b/drivers/infiniband/core/nldev.c
@@ -73,6 +73,72 @@ static const struct nla_policy nldev_policy[RDMA_NLDEV_ATTR_MAX] = {
 						    .len = TASK_COMM_LEN },
 };
 
+static int put_driver_name_print_type(struct sk_buff *msg, const char *name,
+				      enum rdma_nldev_print_type print_type)
+{
+	if (nla_put_string(msg, RDMA_NLDEV_ATTR_DRIVER_STRING, name))
+		return -EMSGSIZE;
+	if (print_type != RDMA_NLDEV_PRINT_TYPE_UNSPEC &&
+	    nla_put_u8(msg, RDMA_NLDEV_ATTR_DRIVER_PRINT_TYPE, print_type))
+		return -EMSGSIZE;
+
+	return 0;
+}
+
+static int _rdma_nl_put_driver_u32(struct sk_buff *msg, const char *name,
+				   enum rdma_nldev_print_type print_type,
+				   u32 value)
+{
+	if (put_driver_name_print_type(msg, name, print_type))
+		return -EMSGSIZE;
+	if (nla_put_u32(msg, RDMA_NLDEV_ATTR_DRIVER_U32, value))
+		return -EMSGSIZE;
+
+	return 0;
+}
+
+static int _rdma_nl_put_driver_u64(struct sk_buff *msg, const char *name,
+				   enum rdma_nldev_print_type print_type,
+				   u64 value)
+{
+	if (put_driver_name_print_type(msg, name, print_type))
+		return -EMSGSIZE;
+	if (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_DRIVER_U64, value,
+			      RDMA_NLDEV_ATTR_PAD))
+		return -EMSGSIZE;
+
+	return 0;
+}
+
+int rdma_nl_put_driver_u32(struct sk_buff *msg, const char *name, u32 value)
+{
+	return _rdma_nl_put_driver_u32(msg, name, RDMA_NLDEV_PRINT_TYPE_UNSPEC,
+				       value);
+}
+EXPORT_SYMBOL(rdma_nl_put_driver_u32);
+
+int rdma_nl_put_driver_u32_hex(struct sk_buff *msg, const char *name,
+			       u32 value)
+{
+	return _rdma_nl_put_driver_u32(msg, name, RDMA_NLDEV_PRINT_TYPE_HEX,
+				       value);
+}
+EXPORT_SYMBOL(rdma_nl_put_driver_u32_hex);
+
+int rdma_nl_put_driver_u64(struct sk_buff *msg, const char *name, u64 value)
+{
+	return _rdma_nl_put_driver_u64(msg, name, RDMA_NLDEV_PRINT_TYPE_UNSPEC,
+				       value);
+}
+EXPORT_SYMBOL(rdma_nl_put_driver_u64);
+
+int rdma_nl_put_driver_u64_hex(struct sk_buff *msg, const char *name, u64 value)
+{
+	return _rdma_nl_put_driver_u64(msg, name, RDMA_NLDEV_PRINT_TYPE_HEX,
+				       value);
+}
+EXPORT_SYMBOL(rdma_nl_put_driver_u64_hex);
+
 static int fill_nldev_handle(struct sk_buff *msg, struct ib_device *device)
 {
 	if (nla_put_u32(msg, RDMA_NLDEV_ATTR_DEV_INDEX, device->index))
* Unmerged path include/rdma/restrack.h
