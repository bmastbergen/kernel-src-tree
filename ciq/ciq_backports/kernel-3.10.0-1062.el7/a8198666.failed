xfs: automatic dfops inode relogging

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Brian Foster <bfoster@redhat.com>
commit a8198666fb755e129c2fe92819774256ec26c79c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a8198666.failed

Inodes that are held across deferred operations are explicitly
joined to the dfops structure to ensure appropriate relogging.
While inodes are currently joined explicitly, we can detect the
conditions that require relogging at dfops finish time by inspecting
the transaction item list for inodes with ili_lock_flags == 0.

Replace the xfs_defer_ijoin() infrastructure with such detection and
automatic relogging of held inodes. This eliminates the need for the
per-dfops inode list, replaced by an on-stack variant in
xfs_defer_trans_roll().

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit a8198666fb755e129c2fe92819774256ec26c79c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_attr.c
#	fs/xfs/libxfs/xfs_attr_remote.c
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_defer.c
#	fs/xfs/libxfs/xfs_defer.h
#	fs/xfs/xfs_bmap_util.c
#	fs/xfs/xfs_inode.c
#	fs/xfs/xfs_iomap.c
#	fs/xfs/xfs_reflink.c
#	fs/xfs/xfs_symlink.c
#	fs/xfs/xfs_trans.h
diff --cc fs/xfs/libxfs/xfs_attr.c
index 3e8597157ebe,3190dfc21b60..000000000000
--- a/fs/xfs/libxfs/xfs_attr.c
+++ b/fs/xfs/libxfs/xfs_attr.c
@@@ -326,15 -311,18 +326,29 @@@ xfs_attr_set
  		 * It won't fit in the shortform, transform to a leaf block.
  		 * GROT: another possible req'mt for a double-split btree op.
  		 */
++<<<<<<< HEAD
 +		xfs_defer_init(args.dfops, args.firstblock);
 +		error = xfs_attr_shortform_to_leaf(&args);
 +		if (!error)
 +			error = xfs_defer_finish(&args.trans, args.dfops, dp);
 +		if (error) {
 +			args.trans = NULL;
 +			xfs_defer_cancel(&dfops);
++=======
+ 		error = xfs_attr_shortform_to_leaf(&args, &leaf_bp);
+ 		if (error)
+ 			goto out;
+ 		/*
+ 		 * Prevent the leaf buffer from being unlocked so that a
+ 		 * concurrent AIL push cannot grab the half-baked leaf
+ 		 * buffer and run into problems with the write verifier.
+ 		 */
+ 		xfs_trans_bhold(args.trans, leaf_bp);
+ 		error = xfs_defer_finish(&args.trans);
+ 		if (error)
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  			goto out;
 +		}
  
  		/*
  		 * Commit the leaf transformation.  We'll need another (linked)
@@@ -598,15 -585,12 +612,23 @@@ xfs_attr_leaf_addname(xfs_da_args_t *ar
  		 * Commit that transaction so that the node_addname() call
  		 * can manage its own transactions.
  		 */
 +		xfs_defer_init(args->dfops, args->firstblock);
  		error = xfs_attr3_leaf_to_node(args);
++<<<<<<< HEAD
 +		if (!error)
 +			error = xfs_defer_finish(&args->trans, args->dfops, dp);
 +		if (error) {
 +			args->trans = NULL;
 +			xfs_defer_cancel(args->dfops);
 +			return error;
 +		}
++=======
+ 		if (error)
+ 			goto out_defer_cancel;
+ 		error = xfs_defer_finish(&args->trans);
+ 		if (error)
+ 			goto out_defer_cancel;
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  
  		/*
  		 * Commit the current trans (including the inode) and start
@@@ -688,17 -672,13 +710,25 @@@
  		 * If the result is small enough, shrink it all into the inode.
  		 */
  		if ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {
 +			xfs_defer_init(args->dfops, args->firstblock);
  			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
  			/* bp is gone due to xfs_da_shrink_inode */
++<<<<<<< HEAD
 +			if (!error)
 +				error = xfs_defer_finish(&args->trans,
 +							args->dfops, dp);
 +			if (error) {
 +				args->trans = NULL;
 +				xfs_defer_cancel(args->dfops);
 +				return error;
 +			}
++=======
+ 			if (error)
+ 				goto out_defer_cancel;
+ 			error = xfs_defer_finish(&args->trans);
+ 			if (error)
+ 				goto out_defer_cancel;
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  		}
  
  		/*
@@@ -751,18 -735,18 +781,26 @@@ xfs_attr_leaf_removename(xfs_da_args_t 
  	 * If the result is small enough, shrink it all into the inode.
  	 */
  	if ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {
 +		xfs_defer_init(args->dfops, args->firstblock);
  		error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
  		/* bp is gone due to xfs_da_shrink_inode */
++<<<<<<< HEAD
 +		if (!error)
 +			error = xfs_defer_finish(&args->trans, args->dfops, dp);
 +		if (error) {
 +			args->trans = NULL;
 +			xfs_defer_cancel(args->dfops);
 +			return error;
 +		}
++=======
+ 		if (error)
+ 			goto out_defer_cancel;
+ 		error = xfs_defer_finish(&args->trans);
+ 		if (error)
+ 			goto out_defer_cancel;
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  	}
  	return 0;
 -out_defer_cancel:
 -	xfs_defer_cancel(args->trans);
 -	return error;
  }
  
  /*
@@@ -877,16 -862,12 +915,24 @@@ restart
  			 */
  			xfs_da_state_free(state);
  			state = NULL;
 +			xfs_defer_init(args->dfops, args->firstblock);
  			error = xfs_attr3_leaf_to_node(args);
++<<<<<<< HEAD
 +			if (!error)
 +				error = xfs_defer_finish(&args->trans,
 +							args->dfops, dp);
 +			if (error) {
 +				args->trans = NULL;
 +				xfs_defer_cancel(args->dfops);
 +				goto out;
 +			}
++=======
+ 			if (error)
+ 				goto out_defer_cancel;
+ 			error = xfs_defer_finish(&args->trans);
+ 			if (error)
+ 				goto out_defer_cancel;
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  
  			/*
  			 * Commit the node conversion and start the next
@@@ -905,15 -886,12 +951,23 @@@
  		 * in the index/blkno/rmtblkno/rmtblkcnt fields and
  		 * in the index2/blkno2/rmtblkno2/rmtblkcnt2 fields.
  		 */
 +		xfs_defer_init(args->dfops, args->firstblock);
  		error = xfs_da3_split(state);
++<<<<<<< HEAD
 +		if (!error)
 +			error = xfs_defer_finish(&args->trans, args->dfops, dp);
 +		if (error) {
 +			args->trans = NULL;
 +			xfs_defer_cancel(args->dfops);
 +			goto out;
 +		}
++=======
+ 		if (error)
+ 			goto out_defer_cancel;
+ 		error = xfs_defer_finish(&args->trans);
+ 		if (error)
+ 			goto out_defer_cancel;
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  	} else {
  		/*
  		 * Addition succeeded, update Btree hashvals.
@@@ -1004,16 -982,12 +1058,24 @@@
  		 * Check to see if the tree needs to be collapsed.
  		 */
  		if (retval && (state->path.active > 1)) {
 +			xfs_defer_init(args->dfops, args->firstblock);
  			error = xfs_da3_join(state);
++<<<<<<< HEAD
 +			if (!error)
 +				error = xfs_defer_finish(&args->trans,
 +							args->dfops, dp);
 +			if (error) {
 +				args->trans = NULL;
 +				xfs_defer_cancel(args->dfops);
 +				goto out;
 +			}
++=======
+ 			if (error)
+ 				goto out_defer_cancel;
+ 			error = xfs_defer_finish(&args->trans);
+ 			if (error)
+ 				goto out_defer_cancel;
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  		}
  
  		/*
@@@ -1127,15 -1105,12 +1189,23 @@@ xfs_attr_node_removename(xfs_da_args_t 
  	 * Check to see if the tree needs to be collapsed.
  	 */
  	if (retval && (state->path.active > 1)) {
 +		xfs_defer_init(args->dfops, args->firstblock);
  		error = xfs_da3_join(state);
++<<<<<<< HEAD
 +		if (!error)
 +			error = xfs_defer_finish(&args->trans, args->dfops, dp);
 +		if (error) {
 +			args->trans = NULL;
 +			xfs_defer_cancel(args->dfops);
 +			goto out;
 +		}
++=======
+ 		if (error)
+ 			goto out_defer_cancel;
+ 		error = xfs_defer_finish(&args->trans);
+ 		if (error)
+ 			goto out_defer_cancel;
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  		/*
  		 * Commit the Btree join operation and start a new trans.
  		 */
@@@ -1160,17 -1135,13 +1230,25 @@@
  			goto out;
  
  		if ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {
 +			xfs_defer_init(args->dfops, args->firstblock);
  			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
  			/* bp is gone due to xfs_da_shrink_inode */
++<<<<<<< HEAD
 +			if (!error)
 +				error = xfs_defer_finish(&args->trans,
 +							args->dfops, dp);
 +			if (error) {
 +				args->trans = NULL;
 +				xfs_defer_cancel(args->dfops);
 +				goto out;
 +			}
++=======
+ 			if (error)
+ 				goto out_defer_cancel;
+ 			error = xfs_defer_finish(&args->trans);
+ 			if (error)
+ 				goto out_defer_cancel;
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  		} else
  			xfs_trans_brelse(args->trans, bp);
  	}
diff --cc fs/xfs/libxfs/xfs_attr_remote.c
index 433c36714e40,f52552313773..000000000000
--- a/fs/xfs/libxfs/xfs_attr_remote.c
+++ b/fs/xfs/libxfs/xfs_attr_remote.c
@@@ -462,18 -480,15 +462,28 @@@ xfs_attr_rmtval_set
  		 * extent and then crash then the block may not contain the
  		 * correct metadata after log recovery occurs.
  		 */
 +		xfs_defer_init(args->dfops, args->firstblock);
  		nmap = 1;
  		error = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,
++<<<<<<< HEAD
 +				  blkcnt, XFS_BMAPI_ATTRFORK, args->firstblock,
 +				  args->total, &map, &nmap, args->dfops);
 +		if (!error)
 +			error = xfs_defer_finish(&args->trans, args->dfops, dp);
 +		if (error) {
 +			args->trans = NULL;
 +			xfs_defer_cancel(args->dfops);
 +			return error;
 +		}
++=======
+ 				  blkcnt, XFS_BMAPI_ATTRFORK, args->total, &map,
+ 				  &nmap);
+ 		if (error)
+ 			goto out_defer_cancel;
+ 		error = xfs_defer_finish(&args->trans);
+ 		if (error)
+ 			goto out_defer_cancel;
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  
  		ASSERT(nmap == 1);
  		ASSERT((map.br_startblock != DELAYSTARTBLOCK) &&
@@@ -605,18 -622,13 +615,27 @@@ xfs_attr_rmtval_remove
  	blkcnt = args->rmtblkcnt;
  	done = 0;
  	while (!done) {
 +		xfs_defer_init(args->dfops, args->firstblock);
  		error = xfs_bunmapi(args->trans, args->dp, lblkno, blkcnt,
++<<<<<<< HEAD
 +				    XFS_BMAPI_ATTRFORK, 1, args->firstblock,
 +				    args->dfops, &done);
 +		if (!error)
 +			error = xfs_defer_finish(&args->trans, args->dfops,
 +						args->dp);
 +		if (error) {
 +			args->trans = NULL;
 +			xfs_defer_cancel(args->dfops);
 +			return error;
 +		}
++=======
+ 				    XFS_BMAPI_ATTRFORK, 1, &done);
+ 		if (error)
+ 			goto out_defer_cancel;
+ 		error = xfs_defer_finish(&args->trans);
+ 		if (error)
+ 			goto out_defer_cancel;
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  
  		/*
  		 * Close out trans and start the next one in the chain.
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 59769f7334d7,5cd490dc891a..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -1151,9 -1119,6 +1151,12 @@@ xfs_bmap_add_attrfork
  			xfs_log_sb(tp);
  	}
  
++<<<<<<< HEAD
 +	error = xfs_defer_finish(&tp, &dfops, NULL);
 +	if (error)
 +		goto bmap_cancel;
++=======
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  	error = xfs_trans_commit(tp);
  	xfs_iunlock(ip, XFS_ILOCK_EXCL);
  	return error;
@@@ -5667,6 -5936,155 +5670,158 @@@ del_cursor
  
  	if (logflags)
  		xfs_trans_log_inode(tp, ip, logflags);
++<<<<<<< HEAD
++=======
+ 	return error;
+ }
+ 
+ int
+ xfs_bmap_split_extent(
+ 	struct xfs_inode        *ip,
+ 	xfs_fileoff_t           split_fsb)
+ {
+ 	struct xfs_mount        *mp = ip->i_mount;
+ 	struct xfs_trans        *tp;
+ 	int                     error;
+ 
+ 	error = xfs_trans_alloc(mp, &M_RES(mp)->tr_write,
+ 			XFS_DIOSTRAT_SPACE_RES(mp, 0), 0, 0, &tp);
+ 	if (error)
+ 		return error;
+ 
+ 	xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
+ 
+ 	error = xfs_bmap_split_extent_at(tp, ip, split_fsb);
+ 	if (error)
+ 		goto out;
+ 
+ 	return xfs_trans_commit(tp);
+ 
+ out:
+ 	xfs_trans_cancel(tp);
+ 	return error;
+ }
+ 
+ /* Deferred mapping is only for real extents in the data fork. */
+ static bool
+ xfs_bmap_is_update_needed(
+ 	struct xfs_bmbt_irec	*bmap)
+ {
+ 	return  bmap->br_startblock != HOLESTARTBLOCK &&
+ 		bmap->br_startblock != DELAYSTARTBLOCK;
+ }
+ 
+ /* Record a bmap intent. */
+ static int
+ __xfs_bmap_add(
+ 	struct xfs_mount		*mp,
+ 	struct xfs_defer_ops		*dfops,
+ 	enum xfs_bmap_intent_type	type,
+ 	struct xfs_inode		*ip,
+ 	int				whichfork,
+ 	struct xfs_bmbt_irec		*bmap)
+ {
+ 	struct xfs_bmap_intent		*bi;
+ 
+ 	trace_xfs_bmap_defer(mp,
+ 			XFS_FSB_TO_AGNO(mp, bmap->br_startblock),
+ 			type,
+ 			XFS_FSB_TO_AGBNO(mp, bmap->br_startblock),
+ 			ip->i_ino, whichfork,
+ 			bmap->br_startoff,
+ 			bmap->br_blockcount,
+ 			bmap->br_state);
+ 
+ 	bi = kmem_alloc(sizeof(struct xfs_bmap_intent), KM_SLEEP | KM_NOFS);
+ 	INIT_LIST_HEAD(&bi->bi_list);
+ 	bi->bi_type = type;
+ 	bi->bi_owner = ip;
+ 	bi->bi_whichfork = whichfork;
+ 	bi->bi_bmap = *bmap;
+ 
+ 	xfs_defer_add(dfops, XFS_DEFER_OPS_TYPE_BMAP, &bi->bi_list);
+ 	return 0;
+ }
+ 
+ /* Map an extent into a file. */
+ int
+ xfs_bmap_map_extent(
+ 	struct xfs_mount	*mp,
+ 	struct xfs_defer_ops	*dfops,
+ 	struct xfs_inode	*ip,
+ 	struct xfs_bmbt_irec	*PREV)
+ {
+ 	if (!xfs_bmap_is_update_needed(PREV))
+ 		return 0;
+ 
+ 	return __xfs_bmap_add(mp, dfops, XFS_BMAP_MAP, ip,
+ 			XFS_DATA_FORK, PREV);
+ }
+ 
+ /* Unmap an extent out of a file. */
+ int
+ xfs_bmap_unmap_extent(
+ 	struct xfs_mount	*mp,
+ 	struct xfs_defer_ops	*dfops,
+ 	struct xfs_inode	*ip,
+ 	struct xfs_bmbt_irec	*PREV)
+ {
+ 	if (!xfs_bmap_is_update_needed(PREV))
+ 		return 0;
+ 
+ 	return __xfs_bmap_add(mp, dfops, XFS_BMAP_UNMAP, ip,
+ 			XFS_DATA_FORK, PREV);
+ }
+ 
+ /*
+  * Process one of the deferred bmap operations.  We pass back the
+  * btree cursor to maintain our lock on the bmapbt between calls.
+  */
+ int
+ xfs_bmap_finish_one(
+ 	struct xfs_trans		*tp,
+ 	struct xfs_defer_ops		*dfops,
+ 	struct xfs_inode		*ip,
+ 	enum xfs_bmap_intent_type	type,
+ 	int				whichfork,
+ 	xfs_fileoff_t			startoff,
+ 	xfs_fsblock_t			startblock,
+ 	xfs_filblks_t			*blockcount,
+ 	xfs_exntst_t			state)
+ {
+ 	int				error = 0;
+ 
+ 	ASSERT(tp->t_firstblock == NULLFSBLOCK);
+ 
+ 	trace_xfs_bmap_deferred(tp->t_mountp,
+ 			XFS_FSB_TO_AGNO(tp->t_mountp, startblock), type,
+ 			XFS_FSB_TO_AGBNO(tp->t_mountp, startblock),
+ 			ip->i_ino, whichfork, startoff, *blockcount, state);
+ 
+ 	if (WARN_ON_ONCE(whichfork != XFS_DATA_FORK))
+ 		return -EFSCORRUPTED;
+ 
+ 	if (XFS_TEST_ERROR(false, tp->t_mountp,
+ 			XFS_ERRTAG_BMAP_FINISH_ONE))
+ 		return -EIO;
+ 
+ 	switch (type) {
+ 	case XFS_BMAP_MAP:
+ 		ASSERT(dfops == tp->t_dfops);
+ 		error = xfs_bmapi_remap(tp, ip, startoff, *blockcount,
+ 				startblock, 0);
+ 		*blockcount = 0;
+ 		break;
+ 	case XFS_BMAP_UNMAP:
+ 		error = __xfs_bunmapi(tp, ip, startoff, blockcount,
+ 				XFS_BMAPI_REMAP, 1);
+ 		break;
+ 	default:
+ 		ASSERT(0);
+ 		error = -EFSCORRUPTED;
+ 	}
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  
  	return error;
  }
diff --cc fs/xfs/libxfs/xfs_defer.c
index 606e68286320,1e7073252a5e..000000000000
--- a/fs/xfs/libxfs/xfs_defer.c
+++ b/fs/xfs/libxfs/xfs_defer.c
@@@ -28,6 -14,9 +28,12 @@@
  #include "xfs_mount.h"
  #include "xfs_defer.h"
  #include "xfs_trans.h"
++<<<<<<< HEAD
++=======
+ #include "xfs_buf_item.h"
+ #include "xfs_inode.h"
+ #include "xfs_inode_item.h"
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  #include "xfs_trace.h"
  
  /*
@@@ -239,17 -228,51 +245,63 @@@ xfs_defer_trans_abort
  /* Roll a transaction so we can do some deferred op processing. */
  STATIC int
  xfs_defer_trans_roll(
 -	struct xfs_trans		**tp)
 +	struct xfs_trans		**tp,
 +	struct xfs_defer_ops		*dop)
  {
++<<<<<<< HEAD
 +	int				i;
 +	int				error;
 +
 +	/* Log all the joined inodes. */
 +	for (i = 0; i < XFS_DEFER_OPS_NR_INODES && dop->dop_inodes[i]; i++)
 +		xfs_trans_log_inode(*tp, dop->dop_inodes[i], XFS_ILOG_CORE);
 +
 +	trace_xfs_defer_trans_roll((*tp)->t_mountp, dop);
++=======
+ 	struct xfs_defer_ops		*dop = (*tp)->t_dfops;
+ 	struct xfs_buf_log_item		*bli;
+ 	struct xfs_inode_log_item	*ili;
+ 	struct xfs_log_item		*lip;
+ 	struct xfs_buf			*bplist[XFS_DEFER_OPS_NR_BUFS];
+ 	struct xfs_inode		*iplist[XFS_DEFER_OPS_NR_INODES];
+ 	int				bpcount = 0, ipcount = 0;
+ 	int				i;
+ 	int				error;
+ 
+ 	list_for_each_entry(lip, &(*tp)->t_items, li_trans) {
+ 		switch (lip->li_type) {
+ 		case XFS_LI_BUF:
+ 			bli = container_of(lip, struct xfs_buf_log_item,
+ 					   bli_item);
+ 			if (bli->bli_flags & XFS_BLI_HOLD) {
+ 				if (bpcount >= XFS_DEFER_OPS_NR_BUFS) {
+ 					ASSERT(0);
+ 					return -EFSCORRUPTED;
+ 				}
+ 				xfs_trans_dirty_buf(*tp, bli->bli_buf);
+ 				bplist[bpcount++] = bli->bli_buf;
+ 			}
+ 			break;
+ 		case XFS_LI_INODE:
+ 			ili = container_of(lip, struct xfs_inode_log_item,
+ 					   ili_item);
+ 			if (ili->ili_lock_flags == 0) {
+ 				if (ipcount >= XFS_DEFER_OPS_NR_INODES) {
+ 					ASSERT(0);
+ 					return -EFSCORRUPTED;
+ 				}
+ 				xfs_trans_log_inode(*tp, ili->ili_inode,
+ 						    XFS_ILOG_CORE);
+ 				iplist[ipcount++] = ili->ili_inode;
+ 			}
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
+ 	trace_xfs_defer_trans_roll((*tp)->t_mountp, dop, _RET_IP_);
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  
  	/* Roll the transaction. */
  	error = xfs_trans_roll(tp);
@@@ -258,12 -282,17 +310,12 @@@
  		xfs_defer_trans_abort(*tp, dop, error);
  		return error;
  	}
 +	dop->dop_committed = true;
  
  	/* Rejoin the joined inodes. */
- 	for (i = 0; i < XFS_DEFER_OPS_NR_INODES && dop->dop_inodes[i]; i++)
- 		xfs_trans_ijoin(*tp, dop->dop_inodes[i], 0);
+ 	for (i = 0; i < ipcount; i++)
+ 		xfs_trans_ijoin(*tp, iplist[i], 0);
  
 -	/* Rejoin the buffers and dirty them so the log moves forward. */
 -	for (i = 0; i < bpcount; i++) {
 -		xfs_trans_bjoin(*tp, bplist[i]);
 -		xfs_trans_bhold(*tp, bplist[i]);
 -	}
 -
  	return error;
  }
  
@@@ -276,27 -305,19 +328,43 @@@ xfs_defer_has_unfinished_work
  }
  
  /*
++<<<<<<< HEAD
 + * Add this inode to the deferred op.  Each joined inode is relogged
 + * each time we roll the transaction, in addition to any inode passed
 + * to xfs_defer_finish().
 + */
 +int
 +xfs_defer_join(
 +	struct xfs_defer_ops		*dop,
 +	struct xfs_inode		*ip)
 +{
 +	int				i;
 +
 +	for (i = 0; i < XFS_DEFER_OPS_NR_INODES; i++) {
 +		if (dop->dop_inodes[i] == ip)
 +			return 0;
 +		else if (dop->dop_inodes[i] == NULL) {
 +			dop->dop_inodes[i] = ip;
 +			return 0;
 +		}
 +	}
 +
 +	return -EFSCORRUPTED;
++=======
+  * Reset an already used dfops after finish.
+  */
+ static void
+ xfs_defer_reset(
+ 	struct xfs_trans	*tp)
+ {
+ 	ASSERT(!xfs_defer_has_unfinished_work(tp->t_dfops));
+ 
+ 	/*
+ 	 * Low mode state transfers across transaction rolls to mirror dfops
+ 	 * lifetime. Clear it now that dfops is reset.
+ 	 */
+ 	tp->t_flags &= ~XFS_TRANS_LOWMODE;
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  }
  
  /*
@@@ -500,14 -540,46 +568,51 @@@ xfs_defer_init_op_type
  /* Initialize a deferred operation. */
  void
  xfs_defer_init(
 -	struct xfs_trans		*tp,
 -	struct xfs_defer_ops		*dop)
 +	struct xfs_defer_ops		*dop,
 +	xfs_fsblock_t			*fbp)
  {
 -	struct xfs_mount		*mp = NULL;
 -
 -	memset(dop, 0, sizeof(struct xfs_defer_ops));
 +	dop->dop_committed = false;
 +	dop->dop_low = false;
 +	memset(&dop->dop_inodes, 0, sizeof(dop->dop_inodes));
 +	*fbp = NULLFSBLOCK;
  	INIT_LIST_HEAD(&dop->dop_intake);
  	INIT_LIST_HEAD(&dop->dop_pending);
++<<<<<<< HEAD
 +	trace_xfs_defer_init(NULL, dop);
++=======
+ 	if (tp) {
+ 		ASSERT(tp->t_firstblock == NULLFSBLOCK);
+ 		tp->t_dfops = dop;
+ 		mp = tp->t_mountp;
+ 	}
+ 	trace_xfs_defer_init(mp, dop, _RET_IP_);
+ }
+ 
+ /*
+  * Move state from one xfs_defer_ops to another and reset the source to initial
+  * state. This is primarily used to carry state forward across transaction rolls
+  * with internal dfops.
+  */
+ void
+ xfs_defer_move(
+ 	struct xfs_trans	*dtp,
+ 	struct xfs_trans	*stp)
+ {
+ 	struct xfs_defer_ops	*dst = dtp->t_dfops;
+ 	struct xfs_defer_ops	*src = stp->t_dfops;
+ 	ASSERT(dst != src);
+ 
+ 	list_splice_init(&src->dop_intake, &dst->dop_intake);
+ 	list_splice_init(&src->dop_pending, &dst->dop_pending);
+ 
+ 	/*
+ 	 * Low free space mode was historically controlled by a dfops field.
+ 	 * This meant that low mode state potentially carried across multiple
+ 	 * transaction rolls. Transfer low mode on a dfops move to preserve
+ 	 * that behavior.
+ 	 */
+ 	dtp->t_flags |= (stp->t_flags & XFS_TRANS_LOWMODE);
+ 
+ 	xfs_defer_reset(stp);
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  }
diff --cc fs/xfs/libxfs/xfs_defer.h
index 9319f67487ea,bf1e9f78561e..000000000000
--- a/fs/xfs/libxfs/xfs_defer.h
+++ b/fs/xfs/libxfs/xfs_defer.h
@@@ -55,26 -34,15 +55,30 @@@ enum xfs_defer_ops_type 
  	XFS_DEFER_OPS_TYPE_MAX,
  };
  
 +#define XFS_DEFER_OPS_NR_INODES	2	/* join up to two inodes */
 +
 +struct xfs_defer_ops {
 +	bool			dop_committed;	/* did any trans commit? */
 +	bool			dop_low;	/* alloc in low mode */
 +	struct list_head	dop_intake;	/* unlogged pending work */
 +	struct list_head	dop_pending;	/* logged pending work */
 +
 +	/* relog these inodes with each roll */
 +	struct xfs_inode	*dop_inodes[XFS_DEFER_OPS_NR_INODES];
 +};
 +
  void xfs_defer_add(struct xfs_defer_ops *dop, enum xfs_defer_ops_type type,
  		struct list_head *h);
 -int xfs_defer_finish_noroll(struct xfs_trans **tp);
 -int xfs_defer_finish(struct xfs_trans **tp);
 -void xfs_defer_cancel(struct xfs_trans *);
 -void xfs_defer_init(struct xfs_trans *tp, struct xfs_defer_ops *dop);
 +int xfs_defer_finish(struct xfs_trans **tp, struct xfs_defer_ops *dop,
 +		struct xfs_inode *ip);
 +void xfs_defer_cancel(struct xfs_defer_ops *dop);
 +void xfs_defer_init(struct xfs_defer_ops *dop, xfs_fsblock_t *fbp);
  bool xfs_defer_has_unfinished_work(struct xfs_defer_ops *dop);
++<<<<<<< HEAD
 +int xfs_defer_join(struct xfs_defer_ops *dop, struct xfs_inode *ip);
++=======
+ void xfs_defer_move(struct xfs_trans *dtp, struct xfs_trans *stp);
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  
  /* Description of a deferred type. */
  struct xfs_defer_op_type {
diff --cc fs/xfs/xfs_bmap_util.c
index ad7a1ab465c3,30ac1300dc49..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -996,10 -979,6 +996,13 @@@ xfs_alloc_file_space
  		/*
  		 * Complete the transaction
  		 */
++<<<<<<< HEAD
 +		error = xfs_defer_finish(&tp, &dfops, NULL);
 +		if (error)
 +			goto error0;
 +
++=======
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  		error = xfs_trans_commit(tp);
  		xfs_iunlock(ip, XFS_ILOCK_EXCL);
  		if (error)
@@@ -1056,16 -1032,10 +1059,19 @@@ xfs_unmap_extent
  
  	xfs_trans_ijoin(tp, ip, 0);
  
 -	error = xfs_bunmapi(tp, ip, startoffset_fsb, len_fsb, 0, 2, done);
 +	xfs_defer_init(&dfops, &firstfsb);
 +	error = xfs_bunmapi(tp, ip, startoffset_fsb, len_fsb, 0, 2, &firstfsb,
 +			&dfops, done);
  	if (error)
 -		goto out_trans_cancel;
 +		goto out_bmap_cancel;
  
++<<<<<<< HEAD
 +	error = xfs_defer_finish(&tp, &dfops, ip);
 +	if (error)
 +		goto out_bmap_cancel;
 +
++=======
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  	error = xfs_trans_commit(tp);
  out_unlock:
  	xfs_iunlock(ip, XFS_ILOCK_EXCL);
@@@ -1472,6 -1524,131 +1478,134 @@@ xfs_swap_extent_flush
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Move extents from one file to another, when rmap is enabled.
+  */
+ STATIC int
+ xfs_swap_extent_rmap(
+ 	struct xfs_trans		**tpp,
+ 	struct xfs_inode		*ip,
+ 	struct xfs_inode		*tip)
+ {
+ 	struct xfs_trans		*tp = *tpp;
+ 	struct xfs_mount		*mp = tp->t_mountp;
+ 	struct xfs_bmbt_irec		irec;
+ 	struct xfs_bmbt_irec		uirec;
+ 	struct xfs_bmbt_irec		tirec;
+ 	xfs_fileoff_t			offset_fsb;
+ 	xfs_fileoff_t			end_fsb;
+ 	xfs_filblks_t			count_fsb;
+ 	int				error;
+ 	xfs_filblks_t			ilen;
+ 	xfs_filblks_t			rlen;
+ 	int				nimaps;
+ 	uint64_t			tip_flags2;
+ 
+ 	/*
+ 	 * If the source file has shared blocks, we must flag the donor
+ 	 * file as having shared blocks so that we get the shared-block
+ 	 * rmap functions when we go to fix up the rmaps.  The flags
+ 	 * will be switch for reals later.
+ 	 */
+ 	tip_flags2 = tip->i_d.di_flags2;
+ 	if (ip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK)
+ 		tip->i_d.di_flags2 |= XFS_DIFLAG2_REFLINK;
+ 
+ 	offset_fsb = 0;
+ 	end_fsb = XFS_B_TO_FSB(ip->i_mount, i_size_read(VFS_I(ip)));
+ 	count_fsb = (xfs_filblks_t)(end_fsb - offset_fsb);
+ 
+ 	while (count_fsb) {
+ 		/* Read extent from the donor file */
+ 		nimaps = 1;
+ 		error = xfs_bmapi_read(tip, offset_fsb, count_fsb, &tirec,
+ 				&nimaps, 0);
+ 		if (error)
+ 			goto out;
+ 		ASSERT(nimaps == 1);
+ 		ASSERT(tirec.br_startblock != DELAYSTARTBLOCK);
+ 
+ 		trace_xfs_swap_extent_rmap_remap(tip, &tirec);
+ 		ilen = tirec.br_blockcount;
+ 
+ 		/* Unmap the old blocks in the source file. */
+ 		while (tirec.br_blockcount) {
+ 			ASSERT(tp->t_firstblock == NULLFSBLOCK);
+ 			trace_xfs_swap_extent_rmap_remap_piece(tip, &tirec);
+ 
+ 			/* Read extent from the source file */
+ 			nimaps = 1;
+ 			error = xfs_bmapi_read(ip, tirec.br_startoff,
+ 					tirec.br_blockcount, &irec,
+ 					&nimaps, 0);
+ 			if (error)
+ 				goto out_defer;
+ 			ASSERT(nimaps == 1);
+ 			ASSERT(tirec.br_startoff == irec.br_startoff);
+ 			trace_xfs_swap_extent_rmap_remap_piece(ip, &irec);
+ 
+ 			/* Trim the extent. */
+ 			uirec = tirec;
+ 			uirec.br_blockcount = rlen = min_t(xfs_filblks_t,
+ 					tirec.br_blockcount,
+ 					irec.br_blockcount);
+ 			trace_xfs_swap_extent_rmap_remap_piece(tip, &uirec);
+ 
+ 			/* Remove the mapping from the donor file. */
+ 			error = xfs_bmap_unmap_extent(mp, tp->t_dfops, tip,
+ 					&uirec);
+ 			if (error)
+ 				goto out_defer;
+ 
+ 			/* Remove the mapping from the source file. */
+ 			error = xfs_bmap_unmap_extent(mp, tp->t_dfops, ip,
+ 					&irec);
+ 			if (error)
+ 				goto out_defer;
+ 
+ 			/* Map the donor file's blocks into the source file. */
+ 			error = xfs_bmap_map_extent(mp, tp->t_dfops, ip,
+ 					&uirec);
+ 			if (error)
+ 				goto out_defer;
+ 
+ 			/* Map the source file's blocks into the donor file. */
+ 			error = xfs_bmap_map_extent(mp, tp->t_dfops, tip,
+ 					&irec);
+ 			if (error)
+ 				goto out_defer;
+ 
+ 			error = xfs_defer_finish(tpp);
+ 			tp = *tpp;
+ 			if (error)
+ 				goto out_defer;
+ 
+ 			tirec.br_startoff += rlen;
+ 			if (tirec.br_startblock != HOLESTARTBLOCK &&
+ 			    tirec.br_startblock != DELAYSTARTBLOCK)
+ 				tirec.br_startblock += rlen;
+ 			tirec.br_blockcount -= rlen;
+ 		}
+ 
+ 		/* Roll on... */
+ 		count_fsb -= ilen;
+ 		offset_fsb += ilen;
+ 	}
+ 
+ 	tip->i_d.di_flags2 = tip_flags2;
+ 	return 0;
+ 
+ out_defer:
+ 	xfs_defer_cancel(tp);
+ out:
+ 	trace_xfs_swap_extent_rmap_error(ip, error, _RET_IP_);
+ 	tip->i_d.di_flags2 = tip_flags2;
+ 	return error;
+ }
+ 
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  /* Swap the extents of two files by swapping data forks. */
  STATIC int
  xfs_swap_extent_forks(
diff --cc fs/xfs/xfs_inode.c
index 41eb4395c514,7bb46a0eecfc..000000000000
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@@ -1548,7 -1569,7 +1548,11 @@@ xfs_itruncate_extents
  		 * Duplicate the transaction that has the permanent
  		 * reservation and commit the old transaction.
  		 */
++<<<<<<< HEAD
 +		error = xfs_defer_finish(&tp, &dfops, ip);
++=======
+ 		error = xfs_defer_finish(&tp);
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  		if (error)
  			goto out_bmap_cancel;
  
@@@ -1781,12 -1809,6 +1785,15 @@@ xfs_inactive_ifree
  	 * Just ignore errors at this point.  There is nothing we can do except
  	 * to try to keep going. Make sure it's not a silent error.
  	 */
++<<<<<<< HEAD
 +	error = xfs_defer_finish(&tp, &dfops, NULL);
 +	if (error) {
 +		xfs_notice(mp, "%s: xfs_defer_finish returned error %d",
 +			__func__, error);
 +		xfs_defer_cancel(&dfops);
 +	}
++=======
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  	error = xfs_trans_commit(tp);
  	if (error)
  		xfs_notice(mp, "%s: xfs_trans_commit returned error %d",
diff --cc fs/xfs/xfs_iomap.c
index baefbc31c374,3282575e2df4..000000000000
--- a/fs/xfs/xfs_iomap.c
+++ b/fs/xfs/xfs_iomap.c
@@@ -275,10 -261,6 +275,13 @@@ xfs_iomap_write_direct
  	/*
  	 * Complete the transaction
  	 */
++<<<<<<< HEAD
 +	error = xfs_defer_finish(&tp, &dfops, NULL);
 +	if (error)
 +		goto out_bmap_cancel;
 +
++=======
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  	error = xfs_trans_commit(tp);
  	if (error)
  		goto out_unlock;
@@@ -912,10 -882,6 +915,13 @@@ xfs_iomap_write_unwritten
  			xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
  		}
  
++<<<<<<< HEAD
 +		error = xfs_defer_finish(&tp, &dfops, NULL);
 +		if (error)
 +			goto error_on_bmapi_transaction;
 +
++=======
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  		error = xfs_trans_commit(tp);
  		xfs_iunlock(ip, XFS_ILOCK_EXCL);
  		if (error)
diff --cc fs/xfs/xfs_symlink.c
index 6610cde35f9c,a3e98c64b6e3..000000000000
--- a/fs/xfs/xfs_symlink.c
+++ b/fs/xfs/xfs_symlink.c
@@@ -493,27 -445,16 +493,30 @@@ xfs_inactive_symlink_rmt
  	/*
  	 * Unmap the dead block(s) to the dfops.
  	 */
 -	error = xfs_bunmapi(tp, ip, 0, size, 0, nmaps, &done);
 +	error = xfs_bunmapi(tp, ip, 0, size, 0, nmaps,
 +			    &first_block, &dfops, &done);
  	if (error)
 -		goto error_trans_cancel;
 +		goto error_bmap_cancel;
  	ASSERT(done);
 -
  	/*
 -	 * Commit the transaction. This first logs the EFI and the inode, then
 -	 * rolls and commits the transaction that frees the extents.
 +	 * Commit the first transaction.  This logs the EFI and the inode.
  	 */
++<<<<<<< HEAD
 +	error = xfs_defer_finish(&tp, &dfops, ip);
 +	if (error)
 +		goto error_bmap_cancel;
 +	/*
 +	 * The first xact was committed, so add the inode to the new one.
 +	 * Mark it dirty so it will be logged and moved forward in the log as
 +	 * part of every commit.
 +	 */
 +	xfs_trans_ijoin(tp, ip, 0);
++=======
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 +	/*
 +	 * Commit the transaction containing extent freeing and EFDs.
 +	 */
  	error = xfs_trans_commit(tp);
  	if (error) {
  		ASSERT(XFS_FORCED_SHUTDOWN(mp));
diff --cc fs/xfs/xfs_trans.h
index ea0c951470ba,8665d45b82c6..000000000000
--- a/fs/xfs/xfs_trans.h
+++ b/fs/xfs/xfs_trans.h
@@@ -88,6 -89,15 +88,18 @@@ void	xfs_log_item_init(struct xfs_moun
  #define XFS_ITEM_LOCKED		2
  #define XFS_ITEM_FLUSHING	3
  
++<<<<<<< HEAD
++=======
+ /*
+  * Deferred operations tracking structure.
+  */
+ #define XFS_DEFER_OPS_NR_INODES	2	/* join up to two inodes */
+ #define XFS_DEFER_OPS_NR_BUFS	2	/* join up to two buffers */
+ struct xfs_defer_ops {
+ 	struct list_head	dop_intake;	/* unlogged pending work */
+ 	struct list_head	dop_pending;	/* logged pending work */
+ };
++>>>>>>> a8198666fb75 (xfs: automatic dfops inode relogging)
  
  /*
   * This is the structure maintained for every active transaction.
* Unmerged path fs/xfs/xfs_reflink.c
* Unmerged path fs/xfs/libxfs/xfs_attr.c
* Unmerged path fs/xfs/libxfs/xfs_attr_remote.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_defer.c
* Unmerged path fs/xfs/libxfs/xfs_defer.h
* Unmerged path fs/xfs/xfs_bmap_util.c
* Unmerged path fs/xfs/xfs_inode.c
* Unmerged path fs/xfs/xfs_iomap.c
* Unmerged path fs/xfs/xfs_reflink.c
* Unmerged path fs/xfs/xfs_symlink.c
* Unmerged path fs/xfs/xfs_trans.h
