KVM: nVMX: do not fill vm_exit_intr_error_code in prepare_vmcs12

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 7313c698050387a11c21afb0c6b4c61f21f7c042
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7313c698.failed

Do this in the caller of nested_vmx_vmexit instead.

nested_vmx_check_exception was doing a vmwrite to the vmcs02's
VM_EXIT_INTR_ERROR_CODE field, so that prepare_vmcs12 would move
the field to vmcs12->vm_exit_intr_error_code.  However that isn't
possible on pre-Haswell machines.  Moving the vmcs12 write to the
callers fixes it.

	Reported-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
[Changed nested_vmx_reflect_vmexit() return type to (int)1 from (bool)1,
 thanks to fengguang.wu@intel.com]
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 7313c698050387a11c21afb0c6b4c61f21f7c042)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index e9f488a93e48,19465b73cc07..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -2640,13 -2432,25 +2640,26 @@@ static void skip_emulated_instruction(s
   * KVM wants to inject page-faults which it got to the guest. This function
   * checks whether in a nested guest, we need to inject them to L1 or L2.
   */
 -static int nested_vmx_check_exception(struct kvm_vcpu *vcpu)
 +static int nested_vmx_check_exception(struct kvm_vcpu *vcpu, unsigned nr)
  {
  	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
 -	unsigned int nr = vcpu->arch.exception.nr;
  
 -	if (!((vmcs12->exception_bitmap & (1u << nr)) ||
 -		(nr == PF_VECTOR && vcpu->arch.exception.nested_apf)))
 +	if (!(vmcs12->exception_bitmap & (1u << nr)))
  		return 0;
  
++<<<<<<< HEAD
++=======
+ 	if (vcpu->arch.exception.nested_apf) {
+ 		vmcs12->vm_exit_intr_error_code = vcpu->arch.exception.error_code;
+ 		nested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,
+ 			PF_VECTOR | INTR_TYPE_HARD_EXCEPTION |
+ 			INTR_INFO_DELIVER_CODE_MASK | INTR_INFO_VALID_MASK,
+ 			vcpu->arch.apf.nested_apf_token);
+ 		return 1;
+ 	}
+ 
+ 	vmcs12->vm_exit_intr_error_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);
++>>>>>>> 7313c6980503 (KVM: nVMX: do not fill vm_exit_intr_error_code in prepare_vmcs12)
  	nested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,
  			  vmcs_read32(VM_EXIT_INTR_INFO),
  			  vmcs_readl(EXIT_QUALIFICATION));
* Unmerged path arch/x86/kvm/vmx.c
