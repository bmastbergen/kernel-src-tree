netfilter: nf_nat: skip nat clash resolution for same-origin entries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Martynas Pumputis <martynas@weave.works>
commit 4e35c1cb9460240e983a01745b5f29fe3a4d8e39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4e35c1cb.failed

It is possible that two concurrent packets originating from the same
socket of a connection-less protocol (e.g. UDP) can end up having
different IP_CT_DIR_REPLY tuples which results in one of the packets
being dropped.

To illustrate this, consider the following simplified scenario:

1. Packet A and B are sent at the same time from two different threads
   by same UDP socket.  No matching conntrack entry exists yet.
   Both packets cause allocation of a new conntrack entry.
2. get_unique_tuple gets called for A.  No clashing entry found.
   conntrack entry for A is added to main conntrack table.
3. get_unique_tuple is called for B and will find that the reply
   tuple of B is already taken by A.
   It will allocate a new UDP source port for B to resolve the clash.
4. conntrack entry for B cannot be added to main conntrack table
   because its ORIGINAL direction is clashing with A and the REPLY
   directions of A and B are not the same anymore due to UDP source
   port reallocation done in step 3.

This patch modifies nf_conntrack_tuple_taken so it doesn't consider
colliding reply tuples if the IP_CT_DIR_ORIGINAL tuples are equal.

[ Florian: simplify patch to not use .allow_clash setting
  and always ignore identical flows ]

	Signed-off-by: Martynas Pumputis <martynas@weave.works>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 4e35c1cb9460240e983a01745b5f29fe3a4d8e39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_core.c
diff --cc net/netfilter/nf_conntrack_core.c
index 5a73e052c209,db4d46332e86..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -786,16 -997,44 +786,47 @@@ nf_conntrack_tuple_taken(const struct n
  
  	hlist_nulls_for_each_entry_rcu(h, n, &ct_hash[hash], hnnode) {
  		ct = nf_ct_tuplehash_to_ctrack(h);
++<<<<<<< HEAD
 +		if (ct != ignored_conntrack &&
 +		    nf_ct_tuple_equal(tuple, &h->tuple) &&
 +		    nf_ct_zone_equal(ct, zone, NF_CT_DIRECTION(h))) {
 +			NF_CT_STAT_INC(net, found);
 +			rcu_read_unlock_bh();
++=======
+ 
+ 		if (ct == ignored_conntrack)
+ 			continue;
+ 
+ 		if (nf_ct_is_expired(ct)) {
+ 			nf_ct_gc_expired(ct);
+ 			continue;
+ 		}
+ 
+ 		if (nf_ct_key_equal(h, tuple, zone, net)) {
+ 			/* Tuple is taken already, so caller will need to find
+ 			 * a new source port to use.
+ 			 *
+ 			 * Only exception:
+ 			 * If the *original tuples* are identical, then both
+ 			 * conntracks refer to the same flow.
+ 			 * This is a rare situation, it can occur e.g. when
+ 			 * more than one UDP packet is sent from same socket
+ 			 * in different threads.
+ 			 *
+ 			 * Let nf_ct_resolve_clash() deal with this later.
+ 			 */
+ 			if (nf_ct_tuple_equal(&ignored_conntrack->tuplehash[IP_CT_DIR_ORIGINAL].tuple,
+ 					      &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple))
+ 				continue;
+ 
+ 			NF_CT_STAT_INC_ATOMIC(net, found);
+ 			rcu_read_unlock();
++>>>>>>> 4e35c1cb9460 (netfilter: nf_nat: skip nat clash resolution for same-origin entries)
  			return 1;
  		}
 +		NF_CT_STAT_INC(net, searched);
  	}
 -
 -	if (get_nulls_value(n) != hash) {
 -		NF_CT_STAT_INC_ATOMIC(net, search_restart);
 -		goto begin;
 -	}
 -
 -	rcu_read_unlock();
 +	rcu_read_unlock_bh();
  
  	return 0;
  }
* Unmerged path net/netfilter/nf_conntrack_core.c
