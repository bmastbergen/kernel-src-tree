usb: typec: mux: Get the mux identifier from function parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [usb] typec: mux: Get the mux identifier from function parameter (Torez Smith) [1657401]
Rebuild_FUZZ: 95.87%
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit 93dd2112c7b2fa5512cc4aff2c449420487fcb68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/93dd2112.failed

In order for the muxes to be usable with alternate modes,
the alternate mode devices will need also to be able to get
a handle to the muxes on top of the port devices. To make
that possible, the muxes need to be possible to request with
an identifier.

This will change the API so that the mux identifier is given
as a function parameter to typec_mux_get(), and the hard-coded
"typec-mux" is replaced with that value.

	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Tested-by: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 93dd2112c7b2fa5512cc4aff2c449420487fcb68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/typec/mux.c
#	drivers/usb/typec/typec.c
#	include/linux/usb/typec_mux.h
diff --cc drivers/usb/typec/typec.c
index a0a95ac4685a,784e928303d7..000000000000
--- a/drivers/usb/typec/typec.c
+++ b/drivers/usb/typec/typec.c
@@@ -1296,21 -1401,48 +1296,32 @@@ struct typec_port *typec_register_port(
  		return ERR_PTR(id);
  	}
  
 -	port->sw = typec_switch_get(cap->fwnode ? &port->dev : parent);
 -	if (IS_ERR(port->sw)) {
 -		ret = PTR_ERR(port->sw);
 -		goto err_switch;
 -	}
 +	if (cap->type == TYPEC_PORT_DFP)
 +		role = TYPEC_SOURCE;
 +	else if (cap->type == TYPEC_PORT_UFP)
 +		role = TYPEC_SINK;
 +	else
 +		role = cap->prefer_role;
  
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +	if (role == TYPEC_SOURCE) {
 +		port->data_role = TYPEC_HOST;
++=======
+ 	port->mux = typec_mux_get(parent, "typec-mux");
+ 	if (IS_ERR(port->mux)) {
+ 		ret = PTR_ERR(port->mux);
+ 		goto err_mux;
+ 	}
+ 
+ 	switch (cap->type) {
+ 	case TYPEC_PORT_SRC:
++>>>>>>> 93dd2112c7b2 (usb: typec: mux: Get the mux identifier from function parameter):drivers/usb/typec/class.c
  		port->pwr_role = TYPEC_SOURCE;
  		port->vconn_role = TYPEC_SOURCE;
 -		break;
 -	case TYPEC_PORT_SNK:
 +	} else {
 +		port->data_role = TYPEC_DEVICE;
  		port->pwr_role = TYPEC_SINK;
  		port->vconn_role = TYPEC_SINK;
 -		break;
 -	case TYPEC_PORT_DRP:
 -		if (cap->prefer_role != TYPEC_NO_PREFERRED_ROLE)
 -			port->pwr_role = cap->prefer_role;
 -		else
 -			port->pwr_role = TYPEC_SINK;
 -		break;
 -	}
 -
 -	switch (cap->data) {
 -	case TYPEC_PORT_DFP:
 -		port->data_role = TYPEC_HOST;
 -		break;
 -	case TYPEC_PORT_UFP:
 -		port->data_role = TYPEC_DEVICE;
 -		break;
 -	case TYPEC_PORT_DRD:
 -		if (cap->prefer_role == TYPEC_SOURCE)
 -			port->data_role = TYPEC_HOST;
 -		else
 -			port->data_role = TYPEC_DEVICE;
 -		break;
  	}
  
  	port->id = id;
* Unmerged path drivers/usb/typec/mux.c
* Unmerged path include/linux/usb/typec_mux.h
* Unmerged path drivers/usb/typec/mux.c
* Unmerged path drivers/usb/typec/typec.c
* Unmerged path include/linux/usb/typec_mux.h
