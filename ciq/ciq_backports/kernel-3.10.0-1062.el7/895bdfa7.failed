hrtimer: Keep pointer to first timer and simplify __remove_hrtimer()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 895bdfa793f6e912d1a58fc445b3dd4d686f7bd3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/895bdfa7.failed

__remove_hrtimer() needs to evaluate the expiry time to figure out
whether the timer which is removed is eventually the first expiring
timer on the cpu. Keep a pointer to it, which is lazily updated, so we
can avoid the evaluation dance and retrieve the information from there.

Generates slightly better code.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Peter Zijlstra <peterz@infradead.org>
	Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
	Cc: Viresh Kumar <viresh.kumar@linaro.org>
	Cc: Marcelo Tosatti <mtosatti@redhat.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
Link: http://lkml.kernel.org/r/20150414203501.752838019@linutronix.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 895bdfa793f6e912d1a58fc445b3dd4d686f7bd3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/hrtimer.h
#	kernel/hrtimer.c
diff --cc include/linux/hrtimer.h
index 2cda5837a253,d194c1dacdaa..000000000000
--- a/include/linux/hrtimer.h
+++ b/include/linux/hrtimer.h
@@@ -164,12 -167,13 +164,17 @@@ enum  hrtimer_base_type 
   * struct hrtimer_cpu_base - the per cpu clock bases
   * @lock:		lock protecting the base and associated clock bases
   *			and timers
 - * @cpu:		cpu number
   * @active_bases:	Bitfield to mark bases with active timers
 - * @clock_was_set_seq:	Sequence counter of clock was set events
 + * @clock_was_set:	Sequence counter of clock was set events
 + *			Note that in RHEL7 clock_was_set is upstream's
 + *			clock_was_set_seq (KABI).
   * @expires_next:	absolute time of the next event which was scheduled
   *			via clock_set_next_event()
++<<<<<<< HEAD
++=======
+  * @next_timer:		Pointer to the first expiring timer
+  * @in_hrtirq:		hrtimer_interrupt() is currently executing
++>>>>>>> 895bdfa793f6 (hrtimer: Keep pointer to first timer and simplify __remove_hrtimer())
   * @hres_active:	State of high resolution mode
   * @hang_detected:	The last hrtimer interrupt detected a hang
   * @nr_events:		Total number of hrtimer interrupt events
@@@ -177,30 -181,29 +182,45 @@@
   * @nr_hangs:		Total number of hrtimer interrupt hangs
   * @max_hang_time:	Maximum time spent in hrtimer_interrupt
   * @clock_base:		array of clock bases for this cpu
++<<<<<<< HEAD
 + * @cpu:		cpu number
 + * @in_hrtirq:		hrtimer_interrupt() is currently executing
 + * @migration_enabled: The migration of hrtimers to other cpus is enabled
 + * @nohz_active:	The nohz functionality is enabled
++=======
+  *
+  * Note: next_timer is just an optimization for __remove_hrtimer().
+  *	 Do not dereference the pointer because it is not reliable on
+  *	 cross cpu removals.
++>>>>>>> 895bdfa793f6 (hrtimer: Keep pointer to first timer and simplify __remove_hrtimer())
   */
  struct hrtimer_cpu_base {
  	raw_spinlock_t			lock;
 -	unsigned int			cpu;
  	unsigned int			active_bases;
 -	unsigned int			clock_was_set_seq;
 +	unsigned int			clock_was_set; /* clock_was_set_seq */
  #ifdef CONFIG_HIGH_RES_TIMERS
 -	unsigned int			in_hrtirq	: 1,
 -					hres_active	: 1,
 -					hang_detected	: 1;
  	ktime_t				expires_next;
++<<<<<<< HEAD
 +	int				hres_active;
 +	int				hang_detected;
 +	unsigned long			nr_events;
 +	unsigned long			nr_retries;
 +	unsigned long			nr_hangs;
 +	ktime_t				max_hang_time;
++=======
+ 	struct hrtimer			*next_timer;
+ 	unsigned int			nr_events;
+ 	unsigned int			nr_retries;
+ 	unsigned int			nr_hangs;
+ 	unsigned int			max_hang_time;
++>>>>>>> 895bdfa793f6 (hrtimer: Keep pointer to first timer and simplify __remove_hrtimer())
  #endif
  	struct hrtimer_clock_base	clock_base[HRTIMER_MAX_CLOCK_BASES];
 -} ____cacheline_aligned;
 +	RH_KABI_EXTEND(int cpu)
 +	RH_KABI_EXTEND(int in_hrtirq)
 +	RH_KABI_EXTEND(bool migration_enabled)
 +	RH_KABI_EXTEND(bool nohz_active)
 +};
  
  static inline void hrtimer_set_expires(struct hrtimer *timer, ktime_t time)
  {
diff --cc kernel/hrtimer.c
index 73950eb59457,30178d0656cf..000000000000
--- a/kernel/hrtimer.c
+++ b/kernel/hrtimer.c
@@@ -492,7 -415,15 +492,19 @@@ static inline void debug_deactivate(str
  }
  
  #if defined(CONFIG_NO_HZ_COMMON) || defined(CONFIG_HIGH_RES_TIMERS)
++<<<<<<< HEAD:kernel/hrtimer.c
 +ktime_t __hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base)
++=======
+ static inline void hrtimer_update_next_timer(struct hrtimer_cpu_base *cpu_base,
+ 					     struct hrtimer *timer)
+ {
+ #ifdef CONFIG_HIGH_RES_TIMERS
+ 	cpu_base->next_timer = timer;
+ #endif
+ }
+ 
+ static ktime_t __hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base)
++>>>>>>> 895bdfa793f6 (hrtimer: Keep pointer to first timer and simplify __remove_hrtimer()):kernel/time/hrtimer.c
  {
  	struct hrtimer_clock_base *base = cpu_base->clock_base;
  	ktime_t expires, expires_next = { .tv64 = KTIME_MAX };
@@@ -648,14 -589,27 +663,16 @@@ static void hrtimer_reprogram(struct hr
  
  	/*
  	 * CLOCK_REALTIME timer might be requested with an absolute
 -	 * expiry time which is less than base->offset. Nothing wrong
 -	 * about that, just avoid to call into the tick code, which
 -	 * has now objections against negative expiry values.
 +	 * expiry time which is less than base->offset. Set it to 0.
  	 */
  	if (expires.tv64 < 0)
 -		return -ETIME;
 +		expires.tv64 = 0;
  
  	if (expires.tv64 >= cpu_base->expires_next.tv64)
 -		return 0;
 -
 -	/*
 -	 * When the target cpu of the timer is currently executing
 -	 * hrtimer_interrupt(), then we do not touch the clock event
 -	 * device. hrtimer_interrupt() will reevaluate all clock bases
 -	 * before reprogramming the device.
 -	 */
 -	if (cpu_base->in_hrtirq)
 -		return 0;
 +		return;
  
+ 	cpu_base->next_timer = timer;
+ 
  	/*
  	 * If a hang was detected in the last timer interrupt then we
  	 * do not schedule a timer which is earlier than the expiry
@@@ -911,30 -880,28 +928,51 @@@ static void __remove_hrtimer(struct hrt
  			     struct hrtimer_clock_base *base,
  			     unsigned long newstate, int reprogram)
  {
++<<<<<<< HEAD:kernel/hrtimer.c
 +	struct timerqueue_node *next_timer;
 +	if (!(timer->state & HRTIMER_STATE_ENQUEUED))
 +		goto out;
 +
 +	next_timer = timerqueue_getnext(&base->active);
 +	timerqueue_del(&base->active, &timer->node);
 +	if (!timerqueue_getnext(&base->active))
 +		base->cpu_base->active_bases &= ~(1 << base->index);
++=======
+ 	struct hrtimer_cpu_base *cpu_base = base->cpu_base;
+ 	unsigned int state = timer->state;
+ 
+ 	timer->state = newstate;
+ 	if (!(state & HRTIMER_STATE_ENQUEUED))
+ 		return;
+ 
+ 	if (!timerqueue_del(&base->active, &timer->node))
+ 		cpu_base->active_bases &= ~(1 << base->index);
++>>>>>>> 895bdfa793f6 (hrtimer: Keep pointer to first timer and simplify __remove_hrtimer()):kernel/time/hrtimer.c
  
- 	if (&timer->node == next_timer) {
  #ifdef CONFIG_HIGH_RES_TIMERS
++<<<<<<< HEAD:kernel/hrtimer.c
 +		/* Reprogram the clock event device. if enabled */
 +		if (reprogram && hrtimer_hres_active()) {
 +			ktime_t expires;
 +
 +			expires = ktime_sub(hrtimer_get_expires(timer),
 +					    base->offset);
 +			if (base->cpu_base->expires_next.tv64 == expires.tv64)
 +				hrtimer_force_reprogram(base->cpu_base, 1);
 +		}
++=======
+ 	/*
+ 	 * Note: If reprogram is false we do not update
+ 	 * cpu_base->next_timer. This happens when we remove the first
+ 	 * timer on a remote cpu. No harm as we never dereference
+ 	 * cpu_base->next_timer. So the worst thing what can happen is
+ 	 * an superflous call to hrtimer_force_reprogram() on the
+ 	 * remote cpu later on if the same timer gets enqueued again.
+ 	 */
+ 	if (reprogram && timer == cpu_base->next_timer)
+ 		hrtimer_force_reprogram(cpu_base, 1);
++>>>>>>> 895bdfa793f6 (hrtimer: Keep pointer to first timer and simplify __remove_hrtimer()):kernel/time/hrtimer.c
  #endif
- 	}
- out:
- 	timer->state = newstate;
  }
  
  /*
* Unmerged path include/linux/hrtimer.h
* Unmerged path kernel/hrtimer.c
