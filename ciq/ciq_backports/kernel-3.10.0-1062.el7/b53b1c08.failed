RDMA/uverbs: Use device.groups to initialize device attributes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Parav Pandit <parav@mellanox.com>
commit b53b1c08a23eb1091982daacb2122f90a7094a77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b53b1c08.failed

Instead of explicitly adding device attribute files and handling such
error conditions, depend on device core layer to create device attributes
files based group pointer NULL terminated array.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Daniel Jurgens <danielj@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit b53b1c08a23eb1091982daacb2122f90a7094a77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs.h
#	drivers/infiniband/core/uverbs_main.c
diff --cc drivers/infiniband/core/uverbs.h
index cbf36c75d546,7199c275ab79..000000000000
--- a/drivers/infiniband/core/uverbs.h
+++ b/drivers/infiniband/core/uverbs.h
@@@ -100,7 -100,9 +100,13 @@@ struct ib_uverbs_device 
  	atomic_t				refcount;
  	int					num_comp_vectors;
  	struct completion			comp;
++<<<<<<< HEAD
 +	struct device			       *dev;
++=======
+ 	struct device				dev;
+ 	/* First group for device attributes, NULL terminated array */
+ 	const struct attribute_group		*groups[2];
++>>>>>>> b53b1c08a23e (RDMA/uverbs: Use device.groups to initialize device attributes)
  	struct ib_device	__rcu	       *ib_dev;
  	int					devnum;
  	struct cdev			        cdev;
diff --cc drivers/infiniband/core/uverbs_main.c
index c6574da6ac18,16e5f714ca53..000000000000
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@@ -966,17 -947,15 +966,17 @@@ static struct ib_client uverbs_client 
  	.remove = ib_uverbs_remove_one
  };
  
- static ssize_t show_ibdev(struct device *device, struct device_attribute *attr,
+ static ssize_t ibdev_show(struct device *device, struct device_attribute *attr,
  			  char *buf)
  {
 -	struct ib_uverbs_device *dev =
 -			container_of(device, struct ib_uverbs_device, dev);
  	int ret = -ENODEV;
  	int srcu_key;
 +	struct ib_uverbs_device *dev = dev_get_drvdata(device);
  	struct ib_device *ib_dev;
  
 +	if (!dev)
 +		return -ENODEV;
 +
  	srcu_key = srcu_read_lock(&dev->disassociate_srcu);
  	ib_dev = srcu_dereference(dev->ib_dev, &dev->disassociate_srcu);
  	if (ib_dev)
@@@ -985,12 -964,13 +985,12 @@@
  
  	return ret;
  }
- static DEVICE_ATTR(ibdev, S_IRUGO, show_ibdev, NULL);
+ static DEVICE_ATTR_RO(ibdev);
  
- static ssize_t show_dev_abi_version(struct device *device,
- 				    struct device_attribute *attr, char *buf)
+ static ssize_t abi_version_show(struct device *device,
+ 				struct device_attribute *attr, char *buf)
  {
 -	struct ib_uverbs_device *dev =
 -			container_of(device, struct ib_uverbs_device, dev);
 +	struct ib_uverbs_device *dev = dev_get_drvdata(device);
  	int ret = -ENODEV;
  	int srcu_key;
  	struct ib_device *ib_dev;
@@@ -1052,48 -1052,34 +1062,70 @@@ static void ib_uverbs_add_one(struct ib
  	rcu_assign_pointer(uverbs_dev->ib_dev, device);
  	uverbs_dev->num_comp_vectors = device->num_comp_vectors;
  
++<<<<<<< HEAD
 +	cdev_init(&uverbs_dev->cdev, NULL);
++=======
+ 	if (ib_uverbs_create_uapi(device, uverbs_dev))
+ 		goto err_uapi;
+ 
+ 	device_initialize(&uverbs_dev->dev);
+ 	uverbs_dev->dev.class = uverbs_class;
+ 	uverbs_dev->dev.parent = device->dev.parent;
+ 	uverbs_dev->dev.devt = base;
+ 	uverbs_dev->dev.release = ib_uverbs_release_dev;
+ 	uverbs_dev->groups[0] = &dev_attr_group;
+ 	uverbs_dev->dev.groups = uverbs_dev->groups;
+ 	dev_set_name(&uverbs_dev->dev, "uverbs%d", uverbs_dev->devnum);
+ 
+ 	cdev_init(&uverbs_dev->cdev,
+ 		  device->mmap ? &uverbs_mmap_fops : &uverbs_fops);
++>>>>>>> b53b1c08a23e (RDMA/uverbs: Use device.groups to initialize device attributes)
  	uverbs_dev->cdev.owner = THIS_MODULE;
 +	uverbs_dev->cdev.ops = device->mmap ? &uverbs_mmap_fops : &uverbs_fops;
 +	cdev_set_parent(&uverbs_dev->cdev, &uverbs_dev->kobj);
 +	kobject_set_name(&uverbs_dev->cdev.kobj, "uverbs%d", uverbs_dev->devnum);
 +	if (cdev_add(&uverbs_dev->cdev, base, 1))
 +		goto err_cdev;
  
 -	ret = cdev_device_add(&uverbs_dev->cdev, &uverbs_dev->dev);
 -	if (ret)
++<<<<<<< HEAD
 +	uverbs_dev->dev = device_create(uverbs_class, device->dev.parent,
 +					uverbs_dev->cdev.dev, uverbs_dev,
 +					"uverbs%d", uverbs_dev->devnum);
 +	if (IS_ERR(uverbs_dev->dev))
  		goto err_cdev;
  
 +	if (device_create_file(uverbs_dev->dev, &dev_attr_ibdev))
 +		goto err_class;
 +	if (device_create_file(uverbs_dev->dev, &dev_attr_abi_version))
 +		goto err_class;
 +
 +	if (!device->specs_root) {
 +		const struct uverbs_object_tree_def *default_root[] = {
 +			uverbs_default_get_objects()};
 +
 +		uverbs_dev->specs_root = uverbs_alloc_spec_tree(1,
 +								default_root);
 +		if (IS_ERR(uverbs_dev->specs_root))
 +			goto err_class;
 +
 +		device->specs_root = uverbs_dev->specs_root;
 +	}
 +
++=======
++>>>>>>> b53b1c08a23e (RDMA/uverbs: Use device.groups to initialize device attributes)
  	ib_set_client_data(device, &uverbs_client, uverbs_dev);
- 
  	return;
  
++<<<<<<< HEAD
 +err_class:
 +	device_destroy(uverbs_class, uverbs_dev->cdev.dev);
 +
++=======
++>>>>>>> b53b1c08a23e (RDMA/uverbs: Use device.groups to initialize device attributes)
  err_cdev:
  	cdev_del(&uverbs_dev->cdev);
 -	put_device(&uverbs_dev->dev);
 -err_uapi:
  	clear_bit(devnum, dev_map);
 +
  err:
  	if (atomic_dec_and_test(&uverbs_dev->refcount))
  		ib_uverbs_comp_dev(uverbs_dev);
* Unmerged path drivers/infiniband/core/uverbs.h
* Unmerged path drivers/infiniband/core/uverbs_main.c
