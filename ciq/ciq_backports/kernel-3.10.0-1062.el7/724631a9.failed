IB/core: Introduce and use rdma_gid_table()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Parav Pandit <parav@mellanox.com>
commit 724631a9c6e98e39480c70047cc3fe2d1f25e1fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/724631a9.failed

There are several places a gid table is accessed.
Have a helper tiny function rdma_gid_table() to avoid code
duplication at such places.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 724631a9c6e98e39480c70047cc3fe2d1f25e1fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/cache.c
diff --cc drivers/infiniband/core/cache.c
index 4c2ac07789ad,0d11538c2a25..000000000000
--- a/drivers/infiniband/core/cache.c
+++ b/drivers/infiniband/core/cache.c
@@@ -163,65 -159,62 +163,75 @@@ int ib_cache_gid_parse_type_str(const c
  }
  EXPORT_SYMBOL(ib_cache_gid_parse_type_str);
  
++<<<<<<< HEAD
 +/* This function expects that rwlock will be write locked in all
 + * scenarios and that lock will be locked in sleep-able (RoCE)
 + * scenarios.
 + */
 +static int write_gid(struct ib_device *ib_dev, u8 port,
 +		     struct ib_gid_table *table, int ix,
 +		     const union ib_gid *gid,
 +		     const struct ib_gid_attr *attr,
 +		     enum gid_table_write_action action,
 +		     bool  default_gid)
 +	__releases(&table->rwlock) __acquires(&table->rwlock)
++=======
+ static struct ib_gid_table *rdma_gid_table(struct ib_device *device, u8 port)
+ {
+ 	return device->cache.ports[port - rdma_start_port(device)].gid;
+ }
+ 
+ static void del_roce_gid(struct ib_device *device, u8 port_num,
+ 			 struct ib_gid_table *table, int ix)
++>>>>>>> 724631a9c6e9 (IB/core: Introduce and use rdma_gid_table())
  {
 -	pr_debug("%s device=%s port=%d index=%d gid %pI6\n", __func__,
 -		 device->name, port_num, ix,
 -		 table->data_vec[ix].gid.raw);
 -
 -	if (rdma_cap_roce_gid_table(device, port_num))
 -		device->del_gid(&table->data_vec[ix].attr,
 -				&table->data_vec[ix].context);
 -	dev_put(table->data_vec[ix].attr.ndev);
 -}
 -
 -static int add_roce_gid(struct ib_gid_table *table,
 -			const union ib_gid *gid,
 -			const struct ib_gid_attr *attr)
 -{
 -	struct ib_gid_table_entry *entry;
 -	int ix = attr->index;
  	int ret = 0;
 +	struct net_device *old_net_dev;
 +	enum ib_gid_type old_gid_type;
  
 -	if (!attr->ndev) {
 -		pr_err("%s NULL netdev device=%s port=%d index=%d\n",
 -		       __func__, attr->device->name, attr->port_num,
 -		       attr->index);
 -		return -EINVAL;
 +	/* in rdma_cap_roce_gid_table, this funciton should be protected by a
 +	 * sleep-able lock.
 +	 */
 +
 +	if (rdma_cap_roce_gid_table(ib_dev, port)) {
 +		table->data_vec[ix].props |= GID_TABLE_ENTRY_INVALID;
 +		write_unlock_irq(&table->rwlock);
 +		/* GID_TABLE_WRITE_ACTION_MODIFY currently isn't supported by
 +		 * RoCE providers and thus only updates the cache.
 +		 */
 +		if (action == GID_TABLE_WRITE_ACTION_ADD)
 +			ret = ib_dev->add_gid(ib_dev, port, ix, gid, attr,
 +					      &table->data_vec[ix].context);
 +		else if (action == GID_TABLE_WRITE_ACTION_DEL)
 +			ret = ib_dev->del_gid(ib_dev, port, ix,
 +					      &table->data_vec[ix].context);
 +		write_lock_irq(&table->rwlock);
  	}
  
 -	entry = &table->data_vec[ix];
 -	if ((entry->props & GID_TABLE_ENTRY_INVALID) == 0) {
 -		WARN(1, "GID table corruption device=%s port=%d index=%d\n",
 -		     attr->device->name, attr->port_num,
 -		     attr->index);
 -		return -EINVAL;
 +	old_net_dev = table->data_vec[ix].attr.ndev;
 +	old_gid_type = table->data_vec[ix].attr.gid_type;
 +	if (old_net_dev && old_net_dev != attr->ndev)
 +		dev_put(old_net_dev);
 +	/* if modify_gid failed, just delete the old gid */
 +	if (ret || action == GID_TABLE_WRITE_ACTION_DEL) {
 +		gid = &zgid;
 +		attr = &zattr;
 +		table->data_vec[ix].context = NULL;
  	}
  
 -	if (rdma_cap_roce_gid_table(attr->device, attr->port_num)) {
 -		ret = attr->device->add_gid(gid, attr, &entry->context);
 -		if (ret) {
 -			pr_err("%s GID add failed device=%s port=%d index=%d\n",
 -			       __func__, attr->device->name, attr->port_num,
 -			       attr->index);
 -			goto add_err;
 -		}
 +	memcpy(&table->data_vec[ix].gid, gid, sizeof(*gid));
 +	memcpy(&table->data_vec[ix].attr, attr, sizeof(*attr));
 +	if (default_gid) {
 +		table->data_vec[ix].props |= GID_TABLE_ENTRY_DEFAULT;
 +		if (action == GID_TABLE_WRITE_ACTION_DEL)
 +			table->data_vec[ix].attr.gid_type = old_gid_type;
  	}
 -	dev_hold(attr->ndev);
 +	if (table->data_vec[ix].attr.ndev &&
 +	    table->data_vec[ix].attr.ndev != old_net_dev)
 +		dev_hold(table->data_vec[ix].attr.ndev);
 +
 +	table->data_vec[ix].props &= ~GID_TABLE_ENTRY_INVALID;
  
 -add_err:
 -	if (!ret)
 -		pr_debug("%s device=%s port=%d index=%d gid %pI6\n", __func__,
 -			 attr->device->name, attr->port_num, ix, gid->raw);
  	return ret;
  }
  
@@@ -310,6 -365,49 +320,52 @@@ static void make_default_gid(struct  ne
  	addrconf_ifid_eui48(&gid->raw[8], dev);
  }
  
++<<<<<<< HEAD
++=======
+ static int __ib_cache_gid_add(struct ib_device *ib_dev, u8 port,
+ 			      union ib_gid *gid, struct ib_gid_attr *attr,
+ 			      unsigned long mask, bool default_gid)
+ {
+ 	struct ib_gid_table *table;
+ 	int ret = 0;
+ 	int empty;
+ 	int ix;
+ 
+ 	/* Do not allow adding zero GID in support of
+ 	 * IB spec version 1.3 section 4.1.1 point (6) and
+ 	 * section 12.7.10 and section 12.7.20
+ 	 */
+ 	if (rdma_is_zero_gid(gid))
+ 		return -EINVAL;
+ 
+ 	table = rdma_gid_table(ib_dev, port);
+ 
+ 	mutex_lock(&table->lock);
+ 
+ 	ix = find_gid(table, gid, attr, default_gid, mask, &empty);
+ 	if (ix >= 0)
+ 		goto out_unlock;
+ 
+ 	if (empty < 0) {
+ 		ret = -ENOSPC;
+ 		goto out_unlock;
+ 	}
+ 	attr->device = ib_dev;
+ 	attr->index = empty;
+ 	attr->port_num = port;
+ 	ret = add_modify_gid(table, gid, attr);
+ 	if (!ret)
+ 		dispatch_gid_change_event(ib_dev, port);
+ 
+ out_unlock:
+ 	mutex_unlock(&table->lock);
+ 	if (ret)
+ 		pr_warn("%s: unable to add gid %pI6 error=%d\n",
+ 			__func__, gid->raw, ret);
+ 	return ret;
+ }
+ 
++>>>>>>> 724631a9c6e9 (IB/core: Introduce and use rdma_gid_table())
  int ib_cache_gid_add(struct ib_device *ib_dev, u8 port,
  		     union ib_gid *gid, struct ib_gid_attr *attr)
  {
@@@ -340,17 -431,30 +396,39 @@@
  			dev_put(idev);
  	}
  
++<<<<<<< HEAD
++=======
+ 	mask = GID_ATTR_FIND_MASK_GID |
+ 	       GID_ATTR_FIND_MASK_GID_TYPE |
+ 	       GID_ATTR_FIND_MASK_NETDEV;
+ 
+ 	ret = __ib_cache_gid_add(ib_dev, port, gid, attr, mask, false);
+ 	return ret;
+ }
+ 
+ static int
+ _ib_cache_gid_del(struct ib_device *ib_dev, u8 port,
+ 		  union ib_gid *gid, struct ib_gid_attr *attr,
+ 		  unsigned long mask, bool default_gid)
+ {
+ 	struct ib_gid_table *table;
+ 	int ret = 0;
+ 	int ix;
+ 
+ 	table = rdma_gid_table(ib_dev, port);
+ 
++>>>>>>> 724631a9c6e9 (IB/core: Introduce and use rdma_gid_table())
  	mutex_lock(&table->lock);
 +	write_lock_irq(&table->rwlock);
  
 -	ix = find_gid(table, gid, attr, default_gid, mask, NULL);
 -	if (ix < 0) {
 -		ret = -EINVAL;
 +	ix = find_gid(table, gid, attr, false, GID_ATTR_FIND_MASK_GID |
 +		      GID_ATTR_FIND_MASK_GID_TYPE |
 +		      GID_ATTR_FIND_MASK_NETDEV, &empty);
 +	if (ix >= 0)
 +		goto out_unlock;
 +
 +	if (empty < 0) {
 +		ret = -ENOSPC;
  		goto out_unlock;
  	}
  
@@@ -400,19 -487,17 +478,19 @@@ int ib_cache_gid_del_all_netdev_gids(st
  	int ix;
  	bool deleted = false;
  
- 	table = ib_dev->cache.ports[port - rdma_start_port(ib_dev)].gid;
+ 	table = rdma_gid_table(ib_dev, port);
  
  	mutex_lock(&table->lock);
 +	write_lock_irq(&table->rwlock);
  
 -	for (ix = 0; ix < table->sz; ix++) {
 -		if (table->data_vec[ix].attr.ndev == ndev) {
 -			del_gid(ib_dev, port, table, ix);
 -			deleted = true;
 -		}
 -	}
 +	for (ix = 0; ix < table->sz; ix++)
 +		if (table->data_vec[ix].attr.ndev == ndev)
 +			if (!del_gid(ib_dev, port, table, ix,
 +				     !!(table->data_vec[ix].props &
 +					GID_TABLE_ENTRY_DEFAULT)))
 +				deleted = true;
  
 +	write_unlock_irq(&table->rwlock);
  	mutex_unlock(&table->lock);
  
  	if (deleted)
@@@ -666,15 -755,17 +744,15 @@@ void ib_cache_gid_set_default_gid(struc
  				  unsigned long gid_type_mask,
  				  enum ib_cache_gid_default_mode mode)
  {
 -	union ib_gid gid = { };
 +	union ib_gid gid;
  	struct ib_gid_attr gid_attr;
 +	struct ib_gid_attr zattr_type = zattr;
  	struct ib_gid_table *table;
  	unsigned int gid_type;
 -	unsigned long mask;
  
- 	table = ib_dev->cache.ports[port - rdma_start_port(ib_dev)].gid;
+ 	table = rdma_gid_table(ib_dev, port);
  
 -	mask = GID_ATTR_FIND_MASK_GID_TYPE |
 -	       GID_ATTR_FIND_MASK_DEFAULT |
 -	       GID_ATTR_FIND_MASK_NETDEV;
 +	make_default_gid(ndev, &gid);
  	memset(&gid_attr, 0, sizeof(gid_attr));
  	gid_attr.ndev = ndev;
  
@@@ -1039,6 -1089,37 +1117,40 @@@ int ib_get_cached_port_state(struct ib_
  }
  EXPORT_SYMBOL(ib_get_cached_port_state);
  
++<<<<<<< HEAD
++=======
+ static int config_non_roce_gid_cache(struct ib_device *device,
+ 				     u8 port, int gid_tbl_len)
+ {
+ 	struct ib_gid_attr gid_attr = {};
+ 	struct ib_gid_table *table;
+ 	union ib_gid gid;
+ 	int ret = 0;
+ 	int i;
+ 
+ 	gid_attr.device = device;
+ 	gid_attr.port_num = port;
+ 	table = rdma_gid_table(device, port);
+ 
+ 	mutex_lock(&table->lock);
+ 	for (i = 0; i < gid_tbl_len; ++i) {
+ 		if (!device->query_gid)
+ 			continue;
+ 		ret = device->query_gid(device, port, i, &gid);
+ 		if (ret) {
+ 			pr_warn("query_gid failed (%d) for %s (index %d)\n",
+ 				ret, device->name, i);
+ 			goto err;
+ 		}
+ 		gid_attr.index = i;
+ 		add_modify_gid(table, &gid, &gid_attr);
+ 	}
+ err:
+ 	mutex_unlock(&table->lock);
+ 	return ret;
+ }
+ 
++>>>>>>> 724631a9c6e9 (IB/core: Introduce and use rdma_gid_table())
  static void ib_cache_update(struct ib_device *device,
  			    u8                port,
  			    bool	      enforce_security)
@@@ -1057,8 -1133,7 +1169,12 @@@
  	if (!rdma_is_port_valid(device, port))
  		return;
  
++<<<<<<< HEAD
 +	use_roce_gid_table = rdma_protocol_roce(device, port);
 +	table = device->cache.ports[port - rdma_start_port(device)].gid;
++=======
+ 	table = rdma_gid_table(device, port);
++>>>>>>> 724631a9c6e9 (IB/core: Introduce and use rdma_gid_table())
  
  	tprops = kmalloc(sizeof *tprops, GFP_KERNEL);
  	if (!tprops)
* Unmerged path drivers/infiniband/core/cache.c
