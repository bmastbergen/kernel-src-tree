s390/sclp: Allow to request adapter reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [s390] sclp: Allow to request adapter reset (Hendrik Brueckner) [1640682]
Rebuild_FUZZ: 93.51%
commit-author Jan Höppner <hoeppner@linux.ibm.com>
commit 6779df406b27ce44d989e965169db39fb58a7efa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6779df40.failed

The SCLP event 24 "Adapter Error Notification" supports three different
action qualifier of which 'adapter reset' is currently not enabled in
the sysfs interface. However, userspace tools might want to be able
to use the reset functionality as well. Enable the 'adapter reset'
qualifier.

	Signed-off-by: Jan Höppner <hoeppner@linux.ibm.com>
	Reviewed-by: Sebastian Ott <sebott@linux.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 6779df406b27ce44d989e965169db39fb58a7efa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/sclp.h
#	drivers/s390/char/sclp_pci.c
diff --cc arch/s390/include/asm/sclp.h
index 21049d84cc3d,5d9420bbe165..000000000000
--- a/arch/s390/include/asm/sclp.h
+++ b/arch/s390/include/asm/sclp.h
@@@ -44,19 -54,67 +44,80 @@@ struct sclp_cpu_info 
  	unsigned int configured;
  	unsigned int standby;
  	unsigned int combined;
 -	struct sclp_core_entry core[SCLP_MAX_CORES];
 +	int has_cpu_type;
 +	struct sclp_cpu_entry cpu[MAX_CPU_ADDRESS + 1];
  };
  
++<<<<<<< HEAD
 +int sclp_get_cpu_info(struct sclp_cpu_info *info);
 +int sclp_cpu_configure(u8 cpu);
 +int sclp_cpu_deconfigure(u8 cpu);
 +unsigned long long sclp_get_rnmax(void);
 +unsigned long long sclp_get_rzm(void);
 +unsigned int sclp_get_max_cpu(void);
 +unsigned int sclp_get_mtid(u8 cpu_type);
 +unsigned int sclp_get_mtid_max(void);
 +unsigned int sclp_get_mtid_prev(void);
++=======
+ struct sclp_info {
+ 	unsigned char has_linemode : 1;
+ 	unsigned char has_vt220 : 1;
+ 	unsigned char has_siif : 1;
+ 	unsigned char has_sigpif : 1;
+ 	unsigned char has_core_type : 1;
+ 	unsigned char has_sprp : 1;
+ 	unsigned char has_hvs : 1;
+ 	unsigned char has_esca : 1;
+ 	unsigned char has_sief2 : 1;
+ 	unsigned char has_64bscao : 1;
+ 	unsigned char has_gpere : 1;
+ 	unsigned char has_cmma : 1;
+ 	unsigned char has_gsls : 1;
+ 	unsigned char has_ib : 1;
+ 	unsigned char has_cei : 1;
+ 	unsigned char has_pfmfi : 1;
+ 	unsigned char has_ibs : 1;
+ 	unsigned char has_skey : 1;
+ 	unsigned char has_kss : 1;
+ 	unsigned char has_gisaf : 1;
+ 	unsigned int ibc;
+ 	unsigned int mtid;
+ 	unsigned int mtid_cp;
+ 	unsigned int mtid_prev;
+ 	unsigned long rzm;
+ 	unsigned long rnmax;
+ 	unsigned long hamax;
+ 	unsigned int max_cores;
+ 	unsigned long hsa_size;
+ 	unsigned long facilities;
+ 	unsigned int hmfai;
+ };
+ extern struct sclp_info sclp;
+ 
+ struct zpci_report_error_header {
+ 	u8 version;	/* Interface version byte */
+ 	u8 action;	/* Action qualifier byte
+ 			 * 0: Adapter Reset Request
+ 			 * 1: Deconfigure and repair action requested
+ 			 *	(OpenCrypto Problem Call Home)
+ 			 * 2: Informational Report
+ 			 *	(OpenCrypto Successful Diagnostics Execution)
+ 			 */
+ 	u16 length;	/* Length of Subsequent Data (up to 4K – SCLP header */
+ 	u8 data[0];	/* Subsequent Data passed verbatim to SCLP ET 24 */
+ } __packed;
+ 
+ int sclp_early_get_core_info(struct sclp_core_info *info);
+ void sclp_early_get_ipl_info(struct sclp_ipl_info *info);
+ void sclp_early_detect(void);
+ void sclp_early_printk(const char *s);
+ void sclp_early_printk_force(const char *s);
+ void __sclp_early_printk(const char *s, unsigned int len, unsigned int force);
+ 
+ int _sclp_get_core_info(struct sclp_core_info *info);
+ int sclp_core_configure(u8 core);
+ int sclp_core_deconfigure(u8 core);
++>>>>>>> 6779df406b27 (s390/sclp: Allow to request adapter reset)
  int sclp_sdias_blk_count(void);
  int sclp_sdias_copy(void *dest, int blk_num, int nr_blks);
  int sclp_chp_configure(struct chp_id chpid);
diff --cc drivers/s390/char/sclp_pci.c
index 943e92539e65,995e9196852e..000000000000
--- a/drivers/s390/char/sclp_pci.c
+++ b/drivers/s390/char/sclp_pci.c
@@@ -20,7 -22,30 +20,34 @@@
  #define SCLP_CMDW_CONFIGURE_PCI			0x001a0001
  #define SCLP_CMDW_DECONFIGURE_PCI		0x001b0001
  
++<<<<<<< HEAD
 +#define SCLP_RECONFIG_PCI_ATPYE			2
++=======
+ #define SCLP_ATYPE_PCI				2
+ 
+ #define SCLP_ERRNOTIFY_AQ_RESET			0
+ #define SCLP_ERRNOTIFY_AQ_REPAIR		1
+ #define SCLP_ERRNOTIFY_AQ_INFO_LOG		2
+ 
+ static DEFINE_MUTEX(sclp_pci_mutex);
+ static struct sclp_register sclp_pci_event = {
+ 	.send_mask = EVTYP_ERRNOTIFY_MASK,
+ };
+ 
+ struct err_notify_evbuf {
+ 	struct evbuf_header header;
+ 	u8 action;
+ 	u8 atype;
+ 	u32 fh;
+ 	u32 fid;
+ 	u8 data[0];
+ } __packed;
+ 
+ struct err_notify_sccb {
+ 	struct sccb_header header;
+ 	struct err_notify_evbuf evbuf;
+ } __packed;
++>>>>>>> 6779df406b27 (s390/sclp: Allow to request adapter reset)
  
  struct pci_cfg_sccb {
  	struct sccb_header header;
@@@ -74,3 -99,102 +101,105 @@@ int sclp_pci_deconfigure(u32 fid
  	return do_pci_configure(SCLP_CMDW_DECONFIGURE_PCI, fid);
  }
  EXPORT_SYMBOL(sclp_pci_deconfigure);
++<<<<<<< HEAD
++=======
+ 
+ static void sclp_pci_callback(struct sclp_req *req, void *data)
+ {
+ 	struct completion *completion = data;
+ 
+ 	complete(completion);
+ }
+ 
+ static int sclp_pci_check_report(struct zpci_report_error_header *report)
+ {
+ 	if (report->version != 1)
+ 		return -EINVAL;
+ 
+ 	switch (report->action) {
+ 	case SCLP_ERRNOTIFY_AQ_RESET:
+ 	case SCLP_ERRNOTIFY_AQ_REPAIR:
+ 	case SCLP_ERRNOTIFY_AQ_INFO_LOG:
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (report->length > (PAGE_SIZE - sizeof(struct err_notify_sccb)))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ int sclp_pci_report(struct zpci_report_error_header *report, u32 fh, u32 fid)
+ {
+ 	DECLARE_COMPLETION_ONSTACK(completion);
+ 	struct err_notify_sccb *sccb;
+ 	struct sclp_req req;
+ 	int ret;
+ 
+ 	ret = sclp_pci_check_report(report);
+ 	if (ret)
+ 		return ret;
+ 
+ 	mutex_lock(&sclp_pci_mutex);
+ 	ret = sclp_register(&sclp_pci_event);
+ 	if (ret)
+ 		goto out_unlock;
+ 
+ 	if (!(sclp_pci_event.sclp_receive_mask & EVTYP_ERRNOTIFY_MASK)) {
+ 		ret = -EOPNOTSUPP;
+ 		goto out_unregister;
+ 	}
+ 
+ 	sccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);
+ 	if (!sccb) {
+ 		ret = -ENOMEM;
+ 		goto out_unregister;
+ 	}
+ 
+ 	memset(&req, 0, sizeof(req));
+ 	req.callback_data = &completion;
+ 	req.callback = sclp_pci_callback;
+ 	req.command = SCLP_CMDW_WRITE_EVENT_DATA;
+ 	req.status = SCLP_REQ_FILLED;
+ 	req.sccb = sccb;
+ 
+ 	sccb->evbuf.header.length = sizeof(sccb->evbuf) + report->length;
+ 	sccb->evbuf.header.type = EVTYP_ERRNOTIFY;
+ 	sccb->header.length = sizeof(sccb->header) + sccb->evbuf.header.length;
+ 
+ 	sccb->evbuf.action = report->action;
+ 	sccb->evbuf.atype = SCLP_ATYPE_PCI;
+ 	sccb->evbuf.fh = fh;
+ 	sccb->evbuf.fid = fid;
+ 
+ 	memcpy(sccb->evbuf.data, report->data, report->length);
+ 
+ 	ret = sclp_add_request(&req);
+ 	if (ret)
+ 		goto out_free_req;
+ 
+ 	wait_for_completion(&completion);
+ 	if (req.status != SCLP_REQ_DONE) {
+ 		pr_warn("request failed (status=0x%02x)\n",
+ 			req.status);
+ 		ret = -EIO;
+ 		goto out_free_req;
+ 	}
+ 
+ 	if (sccb->header.response_code != 0x0020) {
+ 		pr_warn("request failed with response code 0x%x\n",
+ 			sccb->header.response_code);
+ 		ret = -EIO;
+ 	}
+ 
+ out_free_req:
+ 	free_page((unsigned long) sccb);
+ out_unregister:
+ 	sclp_unregister(&sclp_pci_event);
+ out_unlock:
+ 	mutex_unlock(&sclp_pci_mutex);
+ 	return ret;
+ }
++>>>>>>> 6779df406b27 (s390/sclp: Allow to request adapter reset)
* Unmerged path arch/s390/include/asm/sclp.h
* Unmerged path drivers/s390/char/sclp_pci.c
