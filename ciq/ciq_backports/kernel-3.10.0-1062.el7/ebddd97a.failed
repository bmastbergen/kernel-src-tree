cxgb4: add support to display DCB info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ganesh Goudar <ganeshgr@chelsio.com>
commit ebddd97afb89cb1e88cc037aef2913ad4723a59f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ebddd97a.failed

display Data Center bridging information in debug
fs.

	Signed-off-by: Casey Leedom <leedom@chelsio.com>
	Signed-off-by: Ganesh Goudar <ganeshgr@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ebddd97afb89cb1e88cc037aef2913ad4723a59f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
index 89ab12baaaa7,0f72f9c4ec74..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
@@@ -2414,6 -2414,234 +2414,237 @@@ static const struct file_operations rss
  	.release = seq_release_private
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CHELSIO_T4_DCB
+ extern char *dcb_ver_array[];
+ 
+ /* Data Center Briging information for each port.
+  */
+ static int dcb_info_show(struct seq_file *seq, void *v)
+ {
+ 	struct adapter *adap = seq->private;
+ 
+ 	if (v == SEQ_START_TOKEN) {
+ 		seq_puts(seq, "Data Center Bridging Information\n");
+ 	} else {
+ 		int port = (uintptr_t)v - 2;
+ 		struct net_device *dev = adap->port[port];
+ 		struct port_info *pi = netdev2pinfo(dev);
+ 		struct port_dcb_info *dcb = &pi->dcb;
+ 
+ 		seq_puts(seq, "\n");
+ 		seq_printf(seq, "Port: %d (DCB negotiated: %s)\n",
+ 			   port,
+ 			   cxgb4_dcb_enabled(dev) ? "yes" : "no");
+ 
+ 		if (cxgb4_dcb_enabled(dev))
+ 			seq_printf(seq, "[ DCBx Version %s ]\n",
+ 				   dcb_ver_array[dcb->dcb_version]);
+ 
+ 		if (dcb->msgs) {
+ 			int i;
+ 
+ 			seq_puts(seq, "\n  Index\t\t\t  :\t");
+ 			for (i = 0; i < 8; i++)
+ 				seq_printf(seq, " %3d", i);
+ 			seq_puts(seq, "\n\n");
+ 		}
+ 
+ 		if (dcb->msgs & CXGB4_DCB_FW_PGID) {
+ 			int prio, pgid;
+ 
+ 			seq_puts(seq, "  Priority Group IDs\t  :\t");
+ 			for (prio = 0; prio < 8; prio++) {
+ 				pgid = (dcb->pgid >> 4 * (7 - prio)) & 0xf;
+ 				seq_printf(seq, " %3d", pgid);
+ 			}
+ 			seq_puts(seq, "\n");
+ 		}
+ 
+ 		if (dcb->msgs & CXGB4_DCB_FW_PGRATE) {
+ 			int pg;
+ 
+ 			seq_puts(seq, "  Priority Group BW(%)\t  :\t");
+ 			for (pg = 0; pg < 8; pg++)
+ 				seq_printf(seq, " %3d", dcb->pgrate[pg]);
+ 			seq_puts(seq, "\n");
+ 
+ 			if (dcb->dcb_version == FW_PORT_DCB_VER_IEEE) {
+ 				seq_puts(seq, "  TSA Algorithm\t\t  :\t");
+ 				for (pg = 0; pg < 8; pg++)
+ 					seq_printf(seq, " %3d", dcb->tsa[pg]);
+ 				seq_puts(seq, "\n");
+ 			}
+ 
+ 			seq_printf(seq, "  Max PG Traffic Classes  [%3d  ]\n",
+ 				   dcb->pg_num_tcs_supported);
+ 
+ 			seq_puts(seq, "\n");
+ 		}
+ 
+ 		if (dcb->msgs & CXGB4_DCB_FW_PRIORATE) {
+ 			int prio;
+ 
+ 			seq_puts(seq, "  Priority Rate\t:\t");
+ 			for (prio = 0; prio < 8; prio++)
+ 				seq_printf(seq, " %3d", dcb->priorate[prio]);
+ 			seq_puts(seq, "\n");
+ 		}
+ 
+ 		if (dcb->msgs & CXGB4_DCB_FW_PFC) {
+ 			int prio;
+ 
+ 			seq_puts(seq, "  Priority Flow Control   :\t");
+ 			for (prio = 0; prio < 8; prio++) {
+ 				int pfcen = (dcb->pfcen >> 1 * (7 - prio))
+ 					    & 0x1;
+ 				seq_printf(seq, " %3d", pfcen);
+ 			}
+ 			seq_puts(seq, "\n");
+ 
+ 			seq_printf(seq, "  Max PFC Traffic Classes [%3d  ]\n",
+ 				   dcb->pfc_num_tcs_supported);
+ 
+ 			seq_puts(seq, "\n");
+ 		}
+ 
+ 		if (dcb->msgs & CXGB4_DCB_FW_APP_ID) {
+ 			int app, napps;
+ 
+ 			seq_puts(seq, "  Application Information:\n");
+ 			seq_puts(seq, "  App    Priority    Selection         Protocol\n");
+ 			seq_puts(seq, "  Index  Map         Field             ID\n");
+ 			for (app = 0, napps = 0;
+ 			     app < CXGB4_MAX_DCBX_APP_SUPPORTED; app++) {
+ 				struct app_priority *ap;
+ 				static const char * const sel_names[] = {
+ 					"Ethertype",
+ 					"Socket TCP",
+ 					"Socket UDP",
+ 					"Socket All",
+ 				};
+ 				const char *sel_name;
+ 
+ 				ap = &dcb->app_priority[app];
+ 				/* skip empty slots */
+ 				if (ap->protocolid == 0)
+ 					continue;
+ 				napps++;
+ 
+ 				if (ap->sel_field < ARRAY_SIZE(sel_names))
+ 					sel_name = sel_names[ap->sel_field];
+ 				else
+ 					sel_name = "UNKNOWN";
+ 
+ 				seq_printf(seq, "  %3d    %#04x        %-10s (%d)    %#06x (%d)\n",
+ 					   app,
+ 					   ap->user_prio_map,
+ 					   sel_name, ap->sel_field,
+ 					   ap->protocolid, ap->protocolid);
+ 			}
+ 			if (napps == 0)
+ 				seq_puts(seq, "    --- None ---\n");
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ static inline void *dcb_info_get_idx(struct adapter *adap, loff_t pos)
+ {
+ 	return (pos <= adap->params.nports
+ 		? (void *)((uintptr_t)pos + 1)
+ 		: NULL);
+ }
+ 
+ static void *dcb_info_start(struct seq_file *seq, loff_t *pos)
+ {
+ 	struct adapter *adap = seq->private;
+ 
+ 	return (*pos
+ 		? dcb_info_get_idx(adap, *pos)
+ 		: SEQ_START_TOKEN);
+ }
+ 
+ static void dcb_info_stop(struct seq_file *seq, void *v)
+ {
+ }
+ 
+ static void *dcb_info_next(struct seq_file *seq, void *v, loff_t *pos)
+ {
+ 	struct adapter *adap = seq->private;
+ 
+ 	(*pos)++;
+ 	return dcb_info_get_idx(adap, *pos);
+ }
+ 
+ static const struct seq_operations dcb_info_seq_ops = {
+ 	.start = dcb_info_start,
+ 	.next  = dcb_info_next,
+ 	.stop  = dcb_info_stop,
+ 	.show  = dcb_info_show
+ };
+ 
+ static int dcb_info_open(struct inode *inode, struct file *file)
+ {
+ 	int res = seq_open(file, &dcb_info_seq_ops);
+ 
+ 	if (!res) {
+ 		struct seq_file *seq = file->private_data;
+ 
+ 		seq->private = inode->i_private;
+ 	}
+ 	return res;
+ }
+ 
+ static const struct file_operations dcb_info_debugfs_fops = {
+ 	.owner   = THIS_MODULE,
+ 	.open    = dcb_info_open,
+ 	.read    = seq_read,
+ 	.llseek  = seq_lseek,
+ 	.release = seq_release,
+ };
+ #endif /* CONFIG_CHELSIO_T4_DCB */
+ 
+ static int resources_show(struct seq_file *seq, void *v)
+ {
+ 	struct adapter *adapter = seq->private;
+ 	struct pf_resources *pfres = &adapter->params.pfres;
+ 
+ 	#define S(desc, fmt, var) \
+ 		seq_printf(seq, "%-60s " fmt "\n", \
+ 			   desc " (" #var "):", pfres->var)
+ 
+ 	S("Virtual Interfaces", "%d", nvi);
+ 	S("Egress Queues", "%d", neq);
+ 	S("Ethernet Control", "%d", nethctrl);
+ 	S("Ingress Queues/w Free Lists/Interrupts", "%d", niqflint);
+ 	S("Ingress Queues", "%d", niq);
+ 	S("Traffic Class", "%d", tc);
+ 	S("Port Access Rights Mask", "%#x", pmask);
+ 	S("MAC Address Filters", "%d", nexactf);
+ 	S("Firmware Command Read Capabilities", "%#x", r_caps);
+ 	S("Firmware Command Write/Execute Capabilities", "%#x", wx_caps);
+ 
+ 	#undef S
+ 
+ 	return 0;
+ }
+ 
+ static int resources_open(struct inode *inode, struct file *file)
+ {
+ 	return single_open(file, resources_show, inode->i_private);
+ }
+ 
+ static const struct file_operations resources_debugfs_fops = {
+ 	.owner   = THIS_MODULE,
+ 	.open    = resources_open,
+ 	.read    = seq_read,
+ 	.llseek  = seq_lseek,
+ 	.release = seq_release,
+ };
+ 
++>>>>>>> ebddd97afb89 (cxgb4: add support to display DCB info)
  /**
   * ethqset2pinfo - return port_info of an Ethernet Queue Set
   * @adap: the adapter
@@@ -3216,58 -3598,63 +3447,110 @@@ int t4_setup_debugfs(struct adapter *ad
  	struct dentry *de;
  
  	static struct t4_debugfs_entry t4_debugfs_files[] = {
++<<<<<<< HEAD
 +		{ "cim_la", &cim_la_fops, S_IRUSR, 0 },
 +		{ "cim_pif_la", &cim_pif_la_fops, S_IRUSR, 0 },
 +		{ "cim_ma_la", &cim_ma_la_fops, S_IRUSR, 0 },
 +		{ "cim_qcfg", &cim_qcfg_fops, S_IRUSR, 0 },
 +		{ "clk", &clk_debugfs_fops, S_IRUSR, 0 },
 +		{ "devlog", &devlog_fops, S_IRUSR, 0 },
 +		{ "mboxlog", &mboxlog_fops, S_IRUSR, 0 },
 +		{ "mbox0", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 0 },
 +		{ "mbox1", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 1 },
 +		{ "mbox2", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 2 },
 +		{ "mbox3", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 3 },
 +		{ "mbox4", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 4 },
 +		{ "mbox5", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 5 },
 +		{ "mbox6", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 6 },
 +		{ "mbox7", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 7 },
 +		{ "trace0", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 0 },
 +		{ "trace1", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 1 },
 +		{ "trace2", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 2 },
 +		{ "trace3", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 3 },
 +		{ "l2t", &t4_l2t_fops, S_IRUSR, 0},
 +		{ "mps_tcam", &mps_tcam_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss", &rss_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss_config", &rss_config_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss_key", &rss_key_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss_pf_config", &rss_pf_config_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss_vf_config", &rss_vf_config_debugfs_fops, S_IRUSR, 0 },
 +		{ "sge_qinfo", &sge_qinfo_debugfs_fops, S_IRUSR, 0 },
 +		{ "ibq_tp0",  &cim_ibq_fops, S_IRUSR, 0 },
 +		{ "ibq_tp1",  &cim_ibq_fops, S_IRUSR, 1 },
 +		{ "ibq_ulp",  &cim_ibq_fops, S_IRUSR, 2 },
 +		{ "ibq_sge0", &cim_ibq_fops, S_IRUSR, 3 },
 +		{ "ibq_sge1", &cim_ibq_fops, S_IRUSR, 4 },
 +		{ "ibq_ncsi", &cim_ibq_fops, S_IRUSR, 5 },
 +		{ "obq_ulp0", &cim_obq_fops, S_IRUSR, 0 },
 +		{ "obq_ulp1", &cim_obq_fops, S_IRUSR, 1 },
 +		{ "obq_ulp2", &cim_obq_fops, S_IRUSR, 2 },
 +		{ "obq_ulp3", &cim_obq_fops, S_IRUSR, 3 },
 +		{ "obq_sge",  &cim_obq_fops, S_IRUSR, 4 },
 +		{ "obq_ncsi", &cim_obq_fops, S_IRUSR, 5 },
 +		{ "tp_la", &tp_la_fops, S_IRUSR, 0 },
 +		{ "ulprx_la", &ulprx_la_fops, S_IRUSR, 0 },
 +		{ "sensors", &sensors_debugfs_fops, S_IRUSR, 0 },
 +		{ "pm_stats", &pm_stats_debugfs_fops, S_IRUSR, 0 },
 +		{ "tx_rate", &tx_rate_debugfs_fops, S_IRUSR, 0 },
 +		{ "cctrl", &cctrl_tbl_debugfs_fops, S_IRUSR, 0 },
++=======
+ 		{ "cim_la", &cim_la_fops, 0400, 0 },
+ 		{ "cim_pif_la", &cim_pif_la_fops, 0400, 0 },
+ 		{ "cim_ma_la", &cim_ma_la_fops, 0400, 0 },
+ 		{ "cim_qcfg", &cim_qcfg_fops, 0400, 0 },
+ 		{ "clk", &clk_debugfs_fops, 0400, 0 },
+ 		{ "devlog", &devlog_fops, 0400, 0 },
+ 		{ "mboxlog", &mboxlog_fops, 0400, 0 },
+ 		{ "mbox0", &mbox_debugfs_fops, 0600, 0 },
+ 		{ "mbox1", &mbox_debugfs_fops, 0600, 1 },
+ 		{ "mbox2", &mbox_debugfs_fops, 0600, 2 },
+ 		{ "mbox3", &mbox_debugfs_fops, 0600, 3 },
+ 		{ "mbox4", &mbox_debugfs_fops, 0600, 4 },
+ 		{ "mbox5", &mbox_debugfs_fops, 0600, 5 },
+ 		{ "mbox6", &mbox_debugfs_fops, 0600, 6 },
+ 		{ "mbox7", &mbox_debugfs_fops, 0600, 7 },
+ 		{ "trace0", &mps_trc_debugfs_fops, 0600, 0 },
+ 		{ "trace1", &mps_trc_debugfs_fops, 0600, 1 },
+ 		{ "trace2", &mps_trc_debugfs_fops, 0600, 2 },
+ 		{ "trace3", &mps_trc_debugfs_fops, 0600, 3 },
+ 		{ "l2t", &t4_l2t_fops, 0400, 0},
+ 		{ "mps_tcam", &mps_tcam_debugfs_fops, 0400, 0 },
+ 		{ "rss", &rss_debugfs_fops, 0400, 0 },
+ 		{ "rss_config", &rss_config_debugfs_fops, 0400, 0 },
+ 		{ "rss_key", &rss_key_debugfs_fops, 0400, 0 },
+ 		{ "rss_pf_config", &rss_pf_config_debugfs_fops, 0400, 0 },
+ 		{ "rss_vf_config", &rss_vf_config_debugfs_fops, 0400, 0 },
+ 		{ "resources", &resources_debugfs_fops, 0400, 0 },
+ #ifdef CONFIG_CHELSIO_T4_DCB
+ 		{ "dcb_info", &dcb_info_debugfs_fops, 0400, 0 },
+ #endif
+ 		{ "sge_qinfo", &sge_qinfo_debugfs_fops, 0400, 0 },
+ 		{ "ibq_tp0",  &cim_ibq_fops, 0400, 0 },
+ 		{ "ibq_tp1",  &cim_ibq_fops, 0400, 1 },
+ 		{ "ibq_ulp",  &cim_ibq_fops, 0400, 2 },
+ 		{ "ibq_sge0", &cim_ibq_fops, 0400, 3 },
+ 		{ "ibq_sge1", &cim_ibq_fops, 0400, 4 },
+ 		{ "ibq_ncsi", &cim_ibq_fops, 0400, 5 },
+ 		{ "obq_ulp0", &cim_obq_fops, 0400, 0 },
+ 		{ "obq_ulp1", &cim_obq_fops, 0400, 1 },
+ 		{ "obq_ulp2", &cim_obq_fops, 0400, 2 },
+ 		{ "obq_ulp3", &cim_obq_fops, 0400, 3 },
+ 		{ "obq_sge",  &cim_obq_fops, 0400, 4 },
+ 		{ "obq_ncsi", &cim_obq_fops, 0400, 5 },
+ 		{ "tp_la", &tp_la_fops, 0400, 0 },
+ 		{ "ulprx_la", &ulprx_la_fops, 0400, 0 },
+ 		{ "sensors", &sensors_debugfs_fops, 0400, 0 },
+ 		{ "pm_stats", &pm_stats_debugfs_fops, 0400, 0 },
+ 		{ "tx_rate", &tx_rate_debugfs_fops, 0400, 0 },
+ 		{ "cctrl", &cctrl_tbl_debugfs_fops, 0400, 0 },
++>>>>>>> ebddd97afb89 (cxgb4: add support to display DCB info)
  #if IS_ENABLED(CONFIG_IPV6)
 -		{ "clip_tbl", &clip_tbl_debugfs_fops, 0400, 0 },
 +		{ "clip_tbl", &clip_tbl_debugfs_fops, S_IRUSR, 0 },
  #endif
 -		{ "tids", &tid_info_debugfs_fops, 0400, 0},
 -		{ "blocked_fl", &blocked_fl_fops, 0600, 0 },
 -		{ "meminfo", &meminfo_fops, 0400, 0 },
 -		{ "crypto", &chcr_stats_debugfs_fops, 0400, 0 },
 -		{ "tp_stats", &tp_stats_debugfs_fops, 0400, 0 },
 +		{ "tids", &tid_info_debugfs_fops, S_IRUSR, 0},
 +		{ "blocked_fl", &blocked_fl_fops, S_IRUSR | S_IWUSR, 0 },
 +		{ "meminfo", &meminfo_fops, S_IRUSR, 0 },
 +		{ "crypto", &chcr_stats_debugfs_fops, S_IRUSR, 0 },
  	};
  
  	/* Debug FS nodes common to all T5 and later adapters.
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index 9ea4a4c716a2..c7df9be28fb4 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@ -1828,4 +1828,5 @@ void cxgb4_write_sgl(const struct sk_buff *skb, struct sge_txq *q,
 void cxgb4_ring_tx_db(struct adapter *adap, struct sge_txq *q, int n);
 int t4_set_vlan_acl(struct adapter *adap, unsigned int mbox, unsigned int vf,
 		    u16 vlan);
+int cxgb4_dcb_enabled(const struct net_device *dev);
 #endif /* __CXGB4_H__ */
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
index 6652df23e667..3f45d61f9670 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c
@@ -22,7 +22,7 @@
 
 /* DCBx version control
  */
-static const char * const dcb_ver_array[] = {
+const char * const dcb_ver_array[] = {
 	"Unknown",
 	"DCBx-CIN",
 	"DCBx-CEE 1.01",
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 7ccf9c448013..9165a5c5dc34 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -268,7 +268,7 @@ static void dcb_tx_queue_prio_enable(struct net_device *dev, int enable)
 	}
 }
 
-static int cxgb4_dcb_enabled(const struct net_device *dev)
+int cxgb4_dcb_enabled(const struct net_device *dev)
 {
 	struct port_info *pi = netdev_priv(dev);
 
@@ -5593,6 +5593,7 @@ static int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 #ifdef CONFIG_CHELSIO_T4_DCB
 		netdev->dcbnl_ops = &cxgb4_dcb_ops;
 		cxgb4_dcb_state_init(netdev);
+		cxgb4_dcb_version_init(netdev);
 #endif
 		cxgb4_set_ethtool_ops(netdev);
 	}
