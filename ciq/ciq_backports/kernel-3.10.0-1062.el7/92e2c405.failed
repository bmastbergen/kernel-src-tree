flow_dissector: allow dissection of tunnel options from metadata

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Simon Horman <simon.horman@netronome.com>
commit 92e2c4053623f21d61a683f7ef7bd61c8300ac7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/92e2c405.failed

Allow the existing 'dissection' of tunnel metadata to 'dissect'
options already present in tunnel metadata. This dissection is
controlled by a new dissector key, FLOW_DISSECTOR_KEY_ENC_OPTS.

This dissection only occurs when skb_flow_dissect_tunnel_info()
is called, currently only the Flower classifier makes that call.
So there should be no impact on other users of the flow dissector.

This is in preparation for allowing the flower classifier to
match on Geneve options.

	Signed-off-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 92e2c4053623f21d61a683f7ef7bd61c8300ac7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_dissector.h
#	net/core/flow_dissector.c
diff --cc include/net/flow_dissector.h
index e783eb6e2773,6a4586dcdede..000000000000
--- a/include/net/flow_dissector.h
+++ b/include/net/flow_dissector.h
@@@ -206,6 -222,8 +221,11 @@@ enum flow_dissector_key_id 
  	FLOW_DISSECTOR_KEY_TCP, /* struct flow_dissector_key_tcp */
  	FLOW_DISSECTOR_KEY_IP, /* struct flow_dissector_key_ip */
  	FLOW_DISSECTOR_KEY_CVLAN, /* struct flow_dissector_key_flow_vlan */
++<<<<<<< HEAD
++=======
+ 	FLOW_DISSECTOR_KEY_ENC_IP, /* struct flow_dissector_key_ip */
+ 	FLOW_DISSECTOR_KEY_ENC_OPTS, /* struct flow_dissector_key_enc_opts */
++>>>>>>> 92e2c4053623 (flow_dissector: allow dissection of tunnel options from metadata)
  
  	FLOW_DISSECTOR_KEY_MAX,
  };
diff --cc net/core/flow_dissector.c
index ec6a8d0a3cc7,ce9eeeb7c024..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -116,6 -118,132 +116,135 @@@ __be32 __skb_flow_get_ports(const struc
  }
  EXPORT_SYMBOL(__skb_flow_get_ports);
  
++<<<<<<< HEAD
++=======
+ static void
+ skb_flow_dissect_set_enc_addr_type(enum flow_dissector_key_id type,
+ 				   struct flow_dissector *flow_dissector,
+ 				   void *target_container)
+ {
+ 	struct flow_dissector_key_control *ctrl;
+ 
+ 	if (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_CONTROL))
+ 		return;
+ 
+ 	ctrl = skb_flow_dissector_target(flow_dissector,
+ 					 FLOW_DISSECTOR_KEY_ENC_CONTROL,
+ 					 target_container);
+ 	ctrl->addr_type = type;
+ }
+ 
+ void
+ skb_flow_dissect_tunnel_info(const struct sk_buff *skb,
+ 			     struct flow_dissector *flow_dissector,
+ 			     void *target_container)
+ {
+ 	struct ip_tunnel_info *info;
+ 	struct ip_tunnel_key *key;
+ 
+ 	/* A quick check to see if there might be something to do. */
+ 	if (!dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_KEYID) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_CONTROL) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_PORTS) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_IP) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_OPTS))
+ 		return;
+ 
+ 	info = skb_tunnel_info(skb);
+ 	if (!info)
+ 		return;
+ 
+ 	key = &info->key;
+ 
+ 	switch (ip_tunnel_info_af(info)) {
+ 	case AF_INET:
+ 		skb_flow_dissect_set_enc_addr_type(FLOW_DISSECTOR_KEY_IPV4_ADDRS,
+ 						   flow_dissector,
+ 						   target_container);
+ 		if (dissector_uses_key(flow_dissector,
+ 				       FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS)) {
+ 			struct flow_dissector_key_ipv4_addrs *ipv4;
+ 
+ 			ipv4 = skb_flow_dissector_target(flow_dissector,
+ 							 FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS,
+ 							 target_container);
+ 			ipv4->src = key->u.ipv4.src;
+ 			ipv4->dst = key->u.ipv4.dst;
+ 		}
+ 		break;
+ 	case AF_INET6:
+ 		skb_flow_dissect_set_enc_addr_type(FLOW_DISSECTOR_KEY_IPV6_ADDRS,
+ 						   flow_dissector,
+ 						   target_container);
+ 		if (dissector_uses_key(flow_dissector,
+ 				       FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS)) {
+ 			struct flow_dissector_key_ipv6_addrs *ipv6;
+ 
+ 			ipv6 = skb_flow_dissector_target(flow_dissector,
+ 							 FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS,
+ 							 target_container);
+ 			ipv6->src = key->u.ipv6.src;
+ 			ipv6->dst = key->u.ipv6.dst;
+ 		}
+ 		break;
+ 	}
+ 
+ 	if (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_KEYID)) {
+ 		struct flow_dissector_key_keyid *keyid;
+ 
+ 		keyid = skb_flow_dissector_target(flow_dissector,
+ 						  FLOW_DISSECTOR_KEY_ENC_KEYID,
+ 						  target_container);
+ 		keyid->keyid = tunnel_id_to_key32(key->tun_id);
+ 	}
+ 
+ 	if (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_PORTS)) {
+ 		struct flow_dissector_key_ports *tp;
+ 
+ 		tp = skb_flow_dissector_target(flow_dissector,
+ 					       FLOW_DISSECTOR_KEY_ENC_PORTS,
+ 					       target_container);
+ 		tp->src = key->tp_src;
+ 		tp->dst = key->tp_dst;
+ 	}
+ 
+ 	if (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_IP)) {
+ 		struct flow_dissector_key_ip *ip;
+ 
+ 		ip = skb_flow_dissector_target(flow_dissector,
+ 					       FLOW_DISSECTOR_KEY_ENC_IP,
+ 					       target_container);
+ 		ip->tos = key->tos;
+ 		ip->ttl = key->ttl;
+ 	}
+ 
+ 	if (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_OPTS)) {
+ 		struct flow_dissector_key_enc_opts *enc_opt;
+ 
+ 		enc_opt = skb_flow_dissector_target(flow_dissector,
+ 						    FLOW_DISSECTOR_KEY_ENC_OPTS,
+ 						    target_container);
+ 
+ 		if (info->options_len) {
+ 			enc_opt->len = info->options_len;
+ 			ip_tunnel_info_opts_get(enc_opt->data, info);
+ 			enc_opt->dst_opt_type = info->key.tun_flags &
+ 						TUNNEL_OPTIONS_PRESENT;
+ 		}
+ 	}
+ }
+ EXPORT_SYMBOL(skb_flow_dissect_tunnel_info);
+ 
++>>>>>>> 92e2c4053623 (flow_dissector: allow dissection of tunnel options from metadata)
  static enum flow_dissect_ret
  __skb_flow_dissect_mpls(const struct sk_buff *skb,
  			struct flow_dissector *flow_dissector,
* Unmerged path include/net/flow_dissector.h
* Unmerged path net/core/flow_dissector.c
