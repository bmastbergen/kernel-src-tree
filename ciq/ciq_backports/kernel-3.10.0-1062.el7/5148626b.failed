ovl: allocate anon bdev per unique lower fs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 5148626b806a74dd219f2bce5f204abf909f6930
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/5148626b.failed

Instead of allocating an anonymous bdev per lower layer, allocate
one anonymous bdev per every unique lower fs that is different than
upper fs.

Every unique lower fs is assigned an fsid > 0 and the number of
unique lower fs are stored in ofs->numlowerfs.

The assigned fsid is stored in the lower layer struct and will be
used also for inode number multiplexing.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 5148626b806a74dd219f2bce5f204abf909f6930)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
#	fs/overlayfs/ovl_entry.h
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/inode.c
index 24ce49ae057f,cfccd91c51e3..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -66,9 -59,48 +66,51 @@@ out
  	return err;
  }
  
 -static int ovl_map_dev_ino(struct dentry *dentry, struct kstat *stat,
 -			   struct ovl_layer *lower_layer)
 +int ovl_getattr(struct vfsmount *mnt, struct dentry *dentry,
 +		struct kstat *stat)
  {
++<<<<<<< HEAD
++=======
+ 	bool samefs = ovl_same_sb(dentry->d_sb);
+ 
+ 	if (samefs) {
+ 		/*
+ 		 * When all layers are on the same fs, all real inode
+ 		 * number are unique, so we use the overlay st_dev,
+ 		 * which is friendly to du -x.
+ 		 */
+ 		stat->dev = dentry->d_sb->s_dev;
+ 	} else if (S_ISDIR(dentry->d_inode->i_mode)) {
+ 		/*
+ 		 * Always use the overlay st_dev for directories, so 'find
+ 		 * -xdev' will scan the entire overlay mount and won't cross the
+ 		 * overlay mount boundaries.
+ 		 *
+ 		 * If not all layers are on the same fs the pair {real st_ino;
+ 		 * overlay st_dev} is not unique, so use the non persistent
+ 		 * overlay st_ino for directories.
+ 		 */
+ 		stat->dev = dentry->d_sb->s_dev;
+ 		stat->ino = dentry->d_inode->i_ino;
+ 	} else if (lower_layer && lower_layer->fsid) {
+ 		/*
+ 		 * For non-samefs setup, if we cannot map all layers st_ino
+ 		 * to a unified address space, we need to make sure that st_dev
+ 		 * is unique per lower fs. Upper layer uses real st_dev and
+ 		 * lower layers use the unique anonymous bdev assigned to the
+ 		 * lower fs.
+ 		 */
+ 		stat->dev = lower_layer->fs->pseudo_dev;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int ovl_getattr(const struct path *path, struct kstat *stat,
+ 		u32 request_mask, unsigned int flags)
+ {
+ 	struct dentry *dentry = path->dentry;
++>>>>>>> 5148626b806a (ovl: allocate anon bdev per unique lower fs)
  	enum ovl_path_type type;
  	struct path realpath;
  	const struct cred *old_cred;
diff --cc fs/overlayfs/ovl_entry.h
index ec700f861f1b,e1c838c27a74..000000000000
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@@ -17,13 -17,36 +17,44 @@@ struct ovl_config 
  	bool redirect_follow;
  	const char *redirect_mode;
  	bool index;
++<<<<<<< HEAD
++=======
+ 	bool nfs_export;
+ };
+ 
+ struct ovl_sb {
+ 	struct super_block *sb;
+ 	dev_t pseudo_dev;
+ };
+ 
+ struct ovl_layer {
+ 	struct vfsmount *mnt;
+ 	struct ovl_sb *fs;
+ 	/* Index of this layer in fs root (upper idx == 0) */
+ 	int idx;
+ 	/* One fsid per unique underlying sb (upper fsid == 0) */
+ 	int fsid;
+ };
+ 
+ struct ovl_path {
+ 	struct ovl_layer *layer;
+ 	struct dentry *dentry;
++>>>>>>> 5148626b806a (ovl: allocate anon bdev per unique lower fs)
  };
  
  /* private information held for overlayfs's superblock */
  struct ovl_fs {
  	struct vfsmount *upper_mnt;
++<<<<<<< HEAD
 +	unsigned numlower;
 +	struct vfsmount **lower_mnt;
++=======
+ 	unsigned int numlower;
+ 	/* Number of unique lower sb that differ from upper sb */
+ 	unsigned int numlowerfs;
+ 	struct ovl_layer *lower_layers;
+ 	struct ovl_sb *lower_fs;
++>>>>>>> 5148626b806a (ovl: allocate anon bdev per unique lower fs)
  	/* workbasedir is the path at workdir= mount option */
  	struct dentry *workbasedir;
  	/* workdir is the 'work' directory under workbasedir */
diff --cc fs/overlayfs/super.c
index b0392d1737a3,7d97d30cad39..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -219,34 -224,45 +219,65 @@@ static void ovl_destroy_inode(struct in
  	call_rcu(&inode->i_rcu, ovl_i_callback);
  }
  
++<<<<<<< HEAD
++=======
+ static void ovl_free_fs(struct ovl_fs *ofs)
+ {
+ 	unsigned i;
+ 
+ 	dput(ofs->indexdir);
+ 	dput(ofs->workdir);
+ 	if (ofs->workdir_locked)
+ 		ovl_inuse_unlock(ofs->workbasedir);
+ 	dput(ofs->workbasedir);
+ 	if (ofs->upperdir_locked)
+ 		ovl_inuse_unlock(ofs->upper_mnt->mnt_root);
+ 	mntput(ofs->upper_mnt);
+ 	for (i = 0; i < ofs->numlower; i++)
+ 		mntput(ofs->lower_layers[i].mnt);
+ 	for (i = 0; i < ofs->numlowerfs; i++)
+ 		free_anon_bdev(ofs->lower_fs[i].pseudo_dev);
+ 	kfree(ofs->lower_layers);
+ 	kfree(ofs->lower_fs);
+ 
+ 	kfree(ofs->config.lowerdir);
+ 	kfree(ofs->config.upperdir);
+ 	kfree(ofs->config.workdir);
+ 	kfree(ofs->config.redirect_mode);
+ 	if (ofs->creator_cred)
+ 		put_cred(ofs->creator_cred);
+ 	kfree(ofs);
+ }
+ 
++>>>>>>> 5148626b806a (ovl: allocate anon bdev per unique lower fs)
  static void ovl_put_super(struct super_block *sb)
  {
 -	struct ovl_fs *ofs = sb->s_fs_info;
 +	struct ovl_fs *ufs = sb->s_fs_info;
 +	unsigned i;
  
 -	ovl_free_fs(ofs);
 +	dput(ufs->indexdir);
 +	dput(ufs->workdir);
 +	if (ufs->workdir_locked)
 +		ovl_inuse_unlock(ufs->workbasedir);
 +	dput(ufs->workbasedir);
 +	if (ufs->upper_mnt && ufs->upperdir_locked)
 +		ovl_inuse_unlock(ufs->upper_mnt->mnt_root);
 +	mntput(ufs->upper_mnt);
 +	for (i = 0; i < ufs->numlower; i++)
 +		mntput(ufs->lower_mnt[i]);
 +	kfree(ufs->lower_mnt);
 +
 +	kfree(ufs->config.lowerdir);
 +	kfree(ufs->config.upperdir);
 +	kfree(ufs->config.workdir);
 +	kfree(ufs->config.redirect_mode);
 +	put_cred(ufs->creator_cred);
 +	kfree(ufs);
  }
  
 -/* Sync real dirty inodes in upper filesystem (if it exists) */
  static int ovl_sync_fs(struct super_block *sb, int wait)
  {
 -	struct ovl_fs *ofs = sb->s_fs_info;
 +	struct ovl_fs *ufs = sb->s_fs_info;
  	struct super_block *upper_sb;
  	int ret;
  
@@@ -871,121 -903,307 +902,211 @@@ static const struct xattr_handler *ovl_
  	NULL
  };
  
 -static int ovl_get_upper(struct ovl_fs *ofs, struct path *upperpath)
 -{
 -	struct vfsmount *upper_mnt;
 -	int err;
 -
 -	err = ovl_mount_dir(ofs->config.upperdir, upperpath);
 -	if (err)
 -		goto out;
 -
 -	/* Upper fs should not be r/o */
 -	if (sb_rdonly(upperpath->mnt->mnt_sb)) {
 -		pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 -		err = -EINVAL;
 -		goto out;
 -	}
 -
 -	err = ovl_check_namelen(upperpath, ofs, ofs->config.upperdir);
 -	if (err)
 -		goto out;
 -
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(upperpath->dentry)) {
 -		ofs->upperdir_locked = true;
 -	} else if (ofs->config.index) {
 -		pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 -	}
 -
 -	upper_mnt = clone_private_mount(upperpath);
 -	err = PTR_ERR(upper_mnt);
 -	if (IS_ERR(upper_mnt)) {
 -		pr_err("overlayfs: failed to clone upperpath\n");
 -		goto out;
 -	}
 -
 -	/* Don't inherit atime flags */
 -	upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
 -	ofs->upper_mnt = upper_mnt;
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static int ovl_make_workdir(struct ovl_fs *ofs, struct path *workpath)
 +static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
 -	struct vfsmount *mnt = ofs->upper_mnt;
 -	struct dentry *temp;
 +	struct path upperpath = { };
 +	struct path workpath = { };
 +	struct dentry *root_dentry;
 +	struct ovl_entry *oe;
 +	struct ovl_fs *ufs;
 +	const int *upper_stack_depth;
 +	int *overlay_stack_depth;
 +	struct path *stack = NULL;
 +	char *lowertmp;
 +	char *lower;
 +	unsigned int numlower;
 +	unsigned int stacklen = 0;
 +	unsigned int i;
 +	bool remote = false;
 +	struct cred *cred;
  	int err;
  
 -	err = mnt_want_write(mnt);
 -	if (err)
 -		return err;
 -
 -	ofs->workdir = ovl_workdir_create(ofs, OVL_WORKDIR_NAME, false);
 -	if (!ofs->workdir)
 -		goto out;
 -
 -	/*
 -	 * Upper should support d_type, else whiteouts are visible.  Given
 -	 * workdir and upper are on same fs, we can do iterate_dir() on
 -	 * workdir. This check requires successful creation of workdir in
 -	 * previous step.
 -	 */
 -	err = ovl_check_d_type_supported(workpath);
 -	if (err < 0)
 +	err = -ENOMEM;
 +	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
 +	if (!ufs)
  		goto out;
  
 -	/*
 -	 * We allowed this configuration and don't want to break users over
 -	 * kernel upgrade. So warn instead of erroring out.
 -	 */
 -	if (!err)
 -		pr_warn("overlayfs: upper fs needs to support d_type.\n");
 -
 -	/* Check if upper/work fs supports O_TMPFILE */
 -	temp = ovl_do_tmpfile(ofs->workdir, S_IFREG | 0);
 -	ofs->tmpfile = !IS_ERR(temp);
 -	if (ofs->tmpfile)
 -		dput(temp);
 -	else
 -		pr_warn("overlayfs: upper fs does not support tmpfile.\n");
 -
 -	/*
 -	 * Check if upper/work fs supports trusted.overlay.* xattr
 -	 */
 -	err = ovl_do_setxattr(ofs->workdir, OVL_XATTR_OPAQUE, "0", 1, 0);
 -	if (err) {
 -		ofs->noxattr = true;
 -		ofs->config.index = false;
 -		pr_warn("overlayfs: upper fs does not support xattr, falling back to index=off.\n");
 -		err = 0;
 -	} else {
 -		vfs_removexattr(ofs->workdir, OVL_XATTR_OPAQUE);
 -	}
 -
 -	/* Check if upper/work fs supports file handles */
 -	if (ofs->config.index &&
 -	    !ovl_can_decode_fh(ofs->workdir->d_sb)) {
 -		ofs->config.index = false;
 -		pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
 -	}
 -
 -	/* NFS export of r/w mount depends on index */
 -	if (ofs->config.nfs_export && !ofs->config.index) {
 -		pr_warn("overlayfs: NFS export requires \"index=on\", falling back to nfs_export=off.\n");
 -		ofs->config.nfs_export = false;
 -	}
 -
 -out:
 -	mnt_drop_write(mnt);
 -	return err;
 -}
 -
 -static int ovl_get_workdir(struct ovl_fs *ofs, struct path *upperpath)
 -{
 -	int err;
 -	struct path workpath = { };
 -
 -	err = ovl_mount_dir(ofs->config.workdir, &workpath);
 +	ufs->config.index = ovl_index_def;
 +	err = ovl_parse_opt((char *) data, &ufs->config);
  	if (err)
 -		goto out;
 +		goto out_free_config;
  
  	err = -EINVAL;
 -	if (upperpath->mnt != workpath.mnt) {
 -		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 -		goto out;
 -	}
 -	if (!ovl_workdir_ok(workpath.dentry, upperpath->dentry)) {
 -		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 -		goto out;
 +	if (!ufs->config.lowerdir) {
 +		if (!silent)
 +			pr_err("overlayfs: missing 'lowerdir'\n");
 +		goto out_free_config;
  	}
  
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(workpath.dentry)) {
 -		ofs->workdir_locked = true;
 -	} else if (ofs->config.index) {
 -		pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_free_config;
  	}
 +	*overlay_stack_depth = 0;
  
 -	ofs->workbasedir = dget(workpath.dentry);
 -	err = ovl_make_workdir(ofs, &workpath);
 -	if (err)
 -		goto out;
 +	sb->s_maxbytes = MAX_LFS_FILESIZE;
 +	if (ufs->config.upperdir) {
 +		if (!ufs->config.workdir) {
 +			pr_err("overlayfs: missing 'workdir'\n");
 +			goto out_free_config;
 +		}
  
 -	err = 0;
 -out:
 -	path_put(&workpath);
 +		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 +		if (err)
 +			goto out_free_config;
 +
++<<<<<<< HEAD
 +		/* Upper fs should not be r/o */
 +		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
 +			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 +			err = -EINVAL;
 +			goto out_put_upperpath;
 +		}
  
 -	return err;
 -}
 +		err = ovl_check_namelen(&upperpath, ufs, ufs->config.upperdir);
 +		if (err)
 +			goto out_put_upperpath;
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(upperpath.dentry)) {
 +			ufs->upperdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 +			goto out_put_upperpath;
 +		} else {
 +			pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
  
 -static int ovl_get_indexdir(struct ovl_fs *ofs, struct ovl_entry *oe,
 -			    struct path *upperpath)
 -{
 -	struct vfsmount *mnt = ofs->upper_mnt;
 -	int err;
 +		err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +		if (err)
 +			goto out_unlock_upperdentry;
  
 -	err = mnt_want_write(mnt);
 -	if (err)
 -		return err;
 +		err = -EINVAL;
 +		if (upperpath.mnt != workpath.mnt) {
 +			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +			goto out_put_workpath;
 +		}
 +		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +			goto out_put_workpath;
 +		}
  
 -	/* Verify lower root is upper root origin */
 -	err = ovl_verify_origin(upperpath->dentry, oe->lowerstack[0].dentry,
 -				true);
 -	if (err) {
 -		pr_err("overlayfs: failed to verify upper root origin\n");
 -		goto out;
 -	}
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(workpath.dentry)) {
 +			ufs->workdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 +			goto out_put_workpath;
 +		} else {
 +			pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
  
 -	ofs->indexdir = ovl_workdir_create(ofs, OVL_INDEXDIR_NAME, true);
 -	if (ofs->indexdir) {
 -		/*
 -		 * Verify upper root is exclusively associated with index dir.
 -		 * Older kernels stored upper fh in "trusted.overlay.origin"
 -		 * xattr. If that xattr exists, verify that it is a match to
 -		 * upper dir file handle. In any case, verify or set xattr
 -		 * "trusted.overlay.upper" to indicate that index may have
 -		 * directory entries.
 -		 */
 -		if (ovl_check_origin_xattr(ofs->indexdir)) {
 -			err = ovl_verify_set_fh(ofs->indexdir, OVL_XATTR_ORIGIN,
 -						upperpath->dentry, true, false);
 -			if (err)
 -				pr_err("overlayfs: failed to verify index dir 'origin' xattr\n");
 +		ufs->workbasedir = workpath.dentry;
 +		upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +		err = -EOPNOTSUPP;
 +		if (!upper_stack_depth) {
 +			pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +			goto out_put_workpath;
  		}
 -		err = ovl_verify_upper(ofs->indexdir, upperpath->dentry, true);
 -		if (err)
 -			pr_err("overlayfs: failed to verify index dir 'upper' xattr\n");
  
 +		*overlay_stack_depth = *upper_stack_depth;
++=======
+ 		/* Cleanup bad/stale/orphan index entries */
+ 		if (!err)
+ 			err = ovl_indexdir_cleanup(ofs);
+ 	}
+ 	if (err || !ofs->indexdir)
+ 		pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
+ 
+ out:
+ 	mnt_drop_write(mnt);
+ 	return err;
+ }
+ 
+ /* Get a unique fsid for the layer */
+ static int ovl_get_fsid(struct ovl_fs *ofs, struct super_block *sb)
+ {
+ 	unsigned int i;
+ 	dev_t dev;
+ 	int err;
+ 
+ 	/* fsid 0 is reserved for upper fs even with non upper overlay */
+ 	if (ofs->upper_mnt && ofs->upper_mnt->mnt_sb == sb)
+ 		return 0;
+ 
+ 	for (i = 0; i < ofs->numlowerfs; i++) {
+ 		if (ofs->lower_fs[i].sb == sb)
+ 			return i + 1;
+ 	}
+ 
+ 	err = get_anon_bdev(&dev);
+ 	if (err) {
+ 		pr_err("overlayfs: failed to get anonymous bdev for lowerpath\n");
+ 		return err;
+ 	}
+ 
+ 	ofs->lower_fs[ofs->numlowerfs].sb = sb;
+ 	ofs->lower_fs[ofs->numlowerfs].pseudo_dev = dev;
+ 	ofs->numlowerfs++;
+ 
+ 	return ofs->numlowerfs;
+ }
+ 
+ static int ovl_get_lower_layers(struct ovl_fs *ofs, struct path *stack,
+ 				unsigned int numlower)
+ {
+ 	int err;
+ 	unsigned int i;
+ 
+ 	err = -ENOMEM;
+ 	ofs->lower_layers = kcalloc(numlower, sizeof(struct ovl_layer),
+ 				    GFP_KERNEL);
+ 	if (ofs->lower_layers == NULL)
+ 		goto out;
+ 
+ 	ofs->lower_fs = kcalloc(numlower, sizeof(struct ovl_sb),
+ 				GFP_KERNEL);
+ 	if (ofs->lower_fs == NULL)
+ 		goto out;
+ 
+ 	for (i = 0; i < numlower; i++) {
+ 		struct vfsmount *mnt;
+ 		int fsid;
+ 
+ 		err = fsid = ovl_get_fsid(ofs, stack[i].mnt->mnt_sb);
+ 		if (err < 0)
+ 			goto out;
+ 
+ 		mnt = clone_private_mount(&stack[i]);
+ 		err = PTR_ERR(mnt);
+ 		if (IS_ERR(mnt)) {
+ 			pr_err("overlayfs: failed to clone lowerpath\n");
+ 			goto out;
+ 		}
+ 
+ 		/*
+ 		 * Make lower layers R/O.  That way fchmod/fchown on lower file
+ 		 * will fail instead of modifying lower fs.
+ 		 */
+ 		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
+ 
+ 		ofs->lower_layers[ofs->numlower].mnt = mnt;
+ 		ofs->lower_layers[ofs->numlower].idx = i + 1;
+ 		ofs->lower_layers[ofs->numlower].fsid = fsid;
+ 		if (fsid) {
+ 			ofs->lower_layers[ofs->numlower].fs =
+ 				&ofs->lower_fs[fsid - 1];
+ 		}
+ 		ofs->numlower++;
++>>>>>>> 5148626b806a (ovl: allocate anon bdev per unique lower fs)
  	}
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static struct ovl_entry *ovl_get_lowerstack(struct super_block *sb,
 -					    struct ovl_fs *ofs)
 -{
 -	int err;
 -	char *lowertmp, *lower;
 -	struct path *stack = NULL;
 -	unsigned int stacklen, numlower = 0, i;
 -	bool remote = false;
 -	struct ovl_entry *oe;
  
  	err = -ENOMEM;
 -	lowertmp = kstrdup(ofs->config.lowerdir, GFP_KERNEL);
 +	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
  	if (!lowertmp)
 -		goto out_err;
 +		goto out_unlock_workdentry;
  
  	err = -EINVAL;
  	stacklen = ovl_split_lowerdirs(lowertmp);
@@@ -1015,155 -1237,130 +1136,160 @@@
  	}
  
  	err = -EINVAL;
 -	sb->s_stack_depth++;
 -	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 +	*overlay_stack_depth += 1;
 +	if (*overlay_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
  		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 -		goto out_err;
 +		goto out_put_lowerpath;
  	}
  
 -	err = ovl_get_lower_layers(ofs, stack, numlower);
 -	if (err)
 -		goto out_err;
 -
 -	err = -ENOMEM;
 -	oe = ovl_alloc_entry(numlower);
 -	if (!oe)
 -		goto out_err;
 -
 -	for (i = 0; i < numlower; i++) {
 -		oe->lowerstack[i].dentry = dget(stack[i].dentry);
 -		oe->lowerstack[i].layer = &ofs->lower_layers[i];
 -	}
 -
 -	if (remote)
 -		sb->s_d_op = &ovl_reval_dentry_operations;
 -	else
 -		sb->s_d_op = &ovl_dentry_operations;
 +	if (ufs->config.upperdir) {
 +		ufs->upper_mnt = clone_private_mount(&upperpath);
 +		err = PTR_ERR(ufs->upper_mnt);
 +		if (IS_ERR(ufs->upper_mnt)) {
 +			pr_err("overlayfs: failed to clone upperpath\n");
 +			goto out_put_lowerpath;
 +		}
  
 -out:
 -	for (i = 0; i < numlower; i++)
 -		path_put(&stack[i]);
 -	kfree(stack);
 -	kfree(lowertmp);
 +		/* Don't inherit atime flags */
 +		ufs->upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
  
 -	return oe;
 +		sb->s_time_gran = ufs->upper_mnt->mnt_sb->s_time_gran;
  
 -out_err:
 -	oe = ERR_PTR(err);
 -	goto out;
 -}
 +		ufs->workdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 +						  OVL_WORKDIR_NAME, false);
 +		/*
 +		 * Upper should support d_type, else whiteouts are visible.
 +		 * Given workdir and upper are on same fs, we can do
 +		 * iterate_dir() on workdir. This check requires successful
 +		 * creation of workdir in previous step.
 +		 */
 +		if (ufs->workdir) {
 +			struct dentry *temp;
 +
 +			err = ovl_check_d_type_supported(&workpath);
 +			if (err < 0)
 +				goto out_put_workdir;
 +
 +			/*
 +			 * Warn instead of error to avoid breaking previously
 +			 * working configurations over upgrade. If d_type
 +			 * is not supported, whiteouts will become visible
 +			 * to user space.
 +			 */
 +			if (!err)
 +				pr_warn("overlayfs: upper fs needs to support d_type. This is an invalid configuration.\n");
 +
 +			/* Check if upper/work fs supports O_TMPFILE */
 +			temp = ovl_do_tmpfile(ufs->workdir, S_IFREG | 0);
 +			ufs->tmpfile = !IS_ERR(temp);
 +			if (ufs->tmpfile)
 +				dput(temp);
 +
 +			/*
 +			 * Check if upper/work fs supports trusted.overlay.*
 +			 * xattr
 +			 */
 +			err = ovl_do_setxattr(ufs->workdir, OVL_XATTR_OPAQUE,
 +					      "0", 1, 0);
 +			if (err) {
 +				ufs->noxattr = true;
 +				pr_warn("overlayfs: upper fs does not support xattr.\n");
 +			} else {
 +				vfs_removexattr(ufs->workdir, OVL_XATTR_OPAQUE);
 +			}
  
 -static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 -{
 -	struct path upperpath = { };
 -	struct dentry *root_dentry;
 -	struct ovl_entry *oe;
 -	struct ovl_fs *ofs;
 -	struct cred *cred;
 -	int err;
 +			/* Check if upper/work fs supports file handles */
 +			if (ufs->config.index &&
 +			    !ovl_can_decode_fh(ufs->workdir->d_sb)) {
 +				ufs->config.index = false;
 +				pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
 +			}
 +		}
 +	}
  
  	err = -ENOMEM;
 -	ofs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
 -	if (!ofs)
 -		goto out;
 -
 -	ofs->creator_cred = cred = prepare_creds();
 -	if (!cred)
 -		goto out_err;
 -
 -	ofs->config.index = ovl_index_def;
 -	ofs->config.nfs_export = ovl_nfs_export_def;
 -	err = ovl_parse_opt((char *) data, &ofs->config);
 -	if (err)
 -		goto out_err;
 -
 -	err = -EINVAL;
 -	if (!ofs->config.lowerdir) {
 -		if (!silent)
 -			pr_err("overlayfs: missing 'lowerdir'\n");
 -		goto out_err;
 -	}
 +	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
 +	if (ufs->lower_mnt == NULL)
 +		goto out_put_workdir;
 +	for (i = 0; i < numlower; i++) {
 +		struct vfsmount *mnt = clone_private_mount(&stack[i]);
  
 -	sb->s_stack_depth = 0;
 -	sb->s_maxbytes = MAX_LFS_FILESIZE;
 -	if (ofs->config.upperdir) {
 -		if (!ofs->config.workdir) {
 -			pr_err("overlayfs: missing 'workdir'\n");
 -			goto out_err;
 +		err = PTR_ERR(mnt);
 +		if (IS_ERR(mnt)) {
 +			pr_err("overlayfs: failed to clone lowerpath\n");
 +			goto out_put_lower_mnt;
  		}
 +		/*
 +		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 +		 * will fail instead of modifying lower fs.
 +		 */
 +		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
  
 -		err = ovl_get_upper(ofs, &upperpath);
 -		if (err)
 -			goto out_err;
 -
 -		err = ovl_get_workdir(ofs, &upperpath);
 -		if (err)
 -			goto out_err;
 -
 -		if (!ofs->workdir)
 -			sb->s_flags |= SB_RDONLY;
 -
 -		sb->s_stack_depth = ofs->upper_mnt->mnt_sb->s_stack_depth;
 -		sb->s_time_gran = ofs->upper_mnt->mnt_sb->s_time_gran;
 +		ufs->lower_mnt[ufs->numlower] = mnt;
 +		ufs->numlower++;
  
 +		/* Check if all lower layers are on same sb */
 +		if (i == 0)
 +			ufs->same_sb = mnt->mnt_sb;
 +		else if (ufs->same_sb != mnt->mnt_sb)
 +			ufs->same_sb = NULL;
  	}
 -	oe = ovl_get_lowerstack(sb, ofs);
 -	err = PTR_ERR(oe);
 -	if (IS_ERR(oe))
 -		goto out_err;
  
  	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
++<<<<<<< HEAD
 +	if (!ufs->upper_mnt)
 +		sb->s_flags |= MS_RDONLY;
 +	else if (ufs->upper_mnt->mnt_sb != ufs->same_sb)
 +		ufs->same_sb = NULL;
++=======
+ 	if (!ofs->upper_mnt)
+ 		sb->s_flags |= SB_RDONLY;
 -
 -	if (!(ovl_force_readonly(ofs)) && ofs->config.index) {
 -		err = ovl_get_indexdir(ofs, oe, &upperpath);
 -		if (err)
 -			goto out_free_oe;
 -
 -		/* Force r/o mount with no index dir */
 -		if (!ofs->indexdir) {
 -			dput(ofs->workdir);
 -			ofs->workdir = NULL;
 -			sb->s_flags |= SB_RDONLY;
++>>>>>>> 5148626b806a (ovl: allocate anon bdev per unique lower fs)
 +
 +	if (!(ovl_force_readonly(ufs)) && ufs->config.index) {
 +		/* Verify lower root is upper root origin */
 +		err = ovl_verify_origin(upperpath.dentry, ufs->lower_mnt[0],
 +					stack[0].dentry, false, true);
 +		if (err) {
 +			pr_err("overlayfs: failed to verify upper root origin\n");
 +			goto out_put_lower_mnt;
  		}
  
 -	}
 +		ufs->indexdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 +						   OVL_INDEXDIR_NAME, true);
 +		if (ufs->indexdir) {
 +			/* Verify upper root is index dir origin */
 +			err = ovl_verify_origin(ufs->indexdir, ufs->upper_mnt,
 +						upperpath.dentry, true, true);
 +			if (err)
 +				pr_err("overlayfs: failed to verify index dir origin\n");
  
 -	/* Show index=off in /proc/mounts for forced r/o mount */
 -	if (!ofs->indexdir) {
 -		ofs->config.index = false;
 -		if (ofs->upper_mnt && ofs->config.nfs_export) {
 -			pr_warn("overlayfs: NFS export requires an index dir, falling back to nfs_export=off.\n");
 -			ofs->config.nfs_export = false;
 +			/* Cleanup bad/stale/orphan index entries */
 +			if (!err)
 +				err = ovl_indexdir_cleanup(ufs->indexdir,
 +							   ufs->upper_mnt,
 +							   stack, numlower);
  		}
 +		if (err || !ufs->indexdir)
 +			pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
 +		if (err)
 +			goto out_put_indexdir;
  	}
  
 +	/* Show index=off/on in /proc/mounts for any of the reasons above */
 +	if (!ufs->indexdir)
 +		ufs->config.index = false;
 +
 +	if (remote)
 +		sb->s_d_op = &ovl_reval_dentry_operations.ops;
 +	else
 +		sb->s_d_op = &ovl_dentry_operations.ops;
 +
 +	err = -ENOMEM;
 +	ufs->creator_cred = cred = prepare_creds();
 +	if (!cred)
 +		goto out_put_indexdir;
 +
  	if (ofs->config.nfs_export)
  		sb->s_export_op = &ovl_export_operations;
  
* Unmerged path fs/overlayfs/inode.c
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/super.c
diff --git a/fs/overlayfs/util.c b/fs/overlayfs/util.c
index 92f3412841eb..2cbd8f6e2939 100644
--- a/fs/overlayfs/util.c
+++ b/fs/overlayfs/util.c
@@ -48,7 +48,12 @@ struct super_block *ovl_same_sb(struct super_block *sb)
 {
 	struct ovl_fs *ofs = sb->s_fs_info;
 
-	return ofs->same_sb;
+	if (!ofs->numlowerfs)
+		return ofs->upper_mnt->mnt_sb;
+	else if (ofs->numlowerfs == 1 && !ofs->upper_mnt)
+		return ofs->lower_fs[0].sb;
+	else
+		return NULL;
 }
 
 bool ovl_can_decode_fh(struct super_block *sb)
