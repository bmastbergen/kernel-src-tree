x86/intel_rdt/mba_sc: Add initialization support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] intel_rdt/mba_sc: Add initialization support (Prarit Bhargava) [1620320]
Rebuild_FUZZ: 95.65%
commit-author Vikas Shivappa <vikas.shivappa@linux.intel.com>
commit 1bd2a63b4f0deefe745aa0fd969c07b2eb9ee99e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/1bd2a63b.failed

When MBA software controller is enabled, a per domain storage is required
for user specified bandwidth in "MBps" and the "percentage" values which
are programmed into the IA32_MBA_THRTL_MSR. Add support for these data
structures and initialization.

The MBA percentage values have a default max value of 100 but however the
max value in MBps is not available from the hardware so it's set to
U32_MAX.

This simply says that the control group can use all bandwidth by default
but does not say what is the actual max bandwidth available. The actual
bandwidth that is available may depend on lot of factors like QPI link,
number of memory channels, memory channel frequency, its width and memory
speed, how many channels are configured and also if memory interleaving is
enabled. So there is no way to determine the maximum at runtime reliably.

	Signed-off-by: Vikas Shivappa <vikas.shivappa@linux.intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: ravi.v.shankar@intel.com
	Cc: tony.luck@intel.com
	Cc: fenghua.yu@intel.com
	Cc: vikas.shivappa@intel.com
	Cc: ak@linux.intel.com
	Cc: hpa@zytor.com
Link: https://lkml.kernel.org/r/1524263781-14267-4-git-send-email-vikas.shivappa@linux.intel.com

(cherry picked from commit 1bd2a63b4f0deefe745aa0fd969c07b2eb9ee99e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel_rdt.c
diff --cc arch/x86/kernel/cpu/intel_rdt.c
index 5997d990905f,8c09e9db2fc6..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt.c
+++ b/arch/x86/kernel/cpu/intel_rdt.c
@@@ -431,32 -440,44 +432,51 @@@ struct rdt_domain *rdt_find_domain(stru
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static int domain_setup_ctrlval(struct rdt_resource *r, struct rdt_domain *d,
 +				bool notifier)
++=======
+ void setup_default_ctrlval(struct rdt_resource *r, u32 *dc, u32 *dm)
  {
- 	struct msr_param m;
- 	u32 *dc;
  	int i;
  
- 	dc = kmalloc_array(r->num_closid, sizeof(*d->ctrl_val), GFP_KERNEL);
- 	if (!dc)
- 		return -ENOMEM;
- 
- 	d->ctrl_val = dc;
- 
  	/*
  	 * Initialize the Control MSRs to having no control.
  	 * For Cache Allocation: Set all bits in cbm
- 	 * For Memory Allocation: Set b/w requested to 100
+ 	 * For Memory Allocation: Set b/w requested to 100%
+ 	 * and the bandwidth in MBps to U32_MAX
  	 */
- 	for (i = 0; i < r->num_closid; i++, dc++)
+ 	for (i = 0; i < r->num_closid; i++, dc++, dm++) {
  		*dc = r->default_ctrl;
+ 		*dm = MBA_MAX_MBPS;
+ 	}
+ }
+ 
+ static int domain_setup_ctrlval(struct rdt_resource *r, struct rdt_domain *d)
++>>>>>>> 1bd2a63b4f0d (x86/intel_rdt/mba_sc: Add initialization support)
+ {
+ 	struct msr_param m;
+ 	u32 *dc, *dm;
+ 
+ 	dc = kmalloc_array(r->num_closid, sizeof(*d->ctrl_val), GFP_KERNEL);
+ 	if (!dc)
+ 		return -ENOMEM;
+ 
+ 	dm = kmalloc_array(r->num_closid, sizeof(*d->mbps_val), GFP_KERNEL);
+ 	if (!dm) {
+ 		kfree(dc);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	d->ctrl_val = dc;
+ 	d->mbps_val = dm;
+ 	setup_default_ctrlval(r, dc, dm);
  
 -	m.low = 0;
 -	m.high = r->num_closid;
 -	r->msr_update(d, &m, r);
 +	if (notifier) {
 +		m.low = 0;
 +		m.high = r->num_closid;
 +		r->msr_update(d, &m, r);
 +	}
  	return 0;
  }
  
* Unmerged path arch/x86/kernel/cpu/intel_rdt.c
diff --git a/arch/x86/kernel/cpu/intel_rdt.h b/arch/x86/kernel/cpu/intel_rdt.h
index ccaecbac52d1..6a40caae50de 100644
--- a/arch/x86/kernel/cpu/intel_rdt.h
+++ b/arch/x86/kernel/cpu/intel_rdt.h
@@ -201,6 +201,7 @@ struct mbm_state {
  * @cqm_work_cpu:
  *		worker cpu for CQM h/w counters
  * @ctrl_val:	array of cache or mem ctrl values (indexed by CLOSID)
+ * @mbps_val:	When mba_sc is enabled, this holds the bandwidth in MBps
  * @new_ctrl:	new ctrl value to be loaded
  * @have_new_ctrl: did user provide new_ctrl for this domain
  */
@@ -216,6 +217,7 @@ struct rdt_domain {
 	int			mbm_work_cpu;
 	int			cqm_work_cpu;
 	u32			*ctrl_val;
+	u32			*mbps_val;
 	u32			new_ctrl;
 	bool			have_new_ctrl;
 };
@@ -447,6 +449,7 @@ void mbm_setup_overflow_handler(struct rdt_domain *dom,
 				unsigned long delay_ms);
 void mbm_handle_overflow(struct work_struct *work);
 bool is_mba_sc(struct rdt_resource *r);
+void setup_default_ctrlval(struct rdt_resource *r, u32 *dc, u32 *dm);
 void cqm_setup_limbo_handler(struct rdt_domain *dom, unsigned long delay_ms);
 void cqm_handle_limbo(struct work_struct *work);
 bool has_busy_rmid(struct rdt_resource *r, struct rdt_domain *d);
diff --git a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
index 7e833c2536e1..770f808c1824 100644
--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
@@ -1054,12 +1054,15 @@ static int set_cache_qos_cfg(int level, bool enable)
 static int set_mba_sc(bool mba_sc)
 {
 	struct rdt_resource *r = &rdt_resources_all[RDT_RESOURCE_MBA];
+	struct rdt_domain *d;
 
 	if (!is_mbm_enabled() || !is_mba_linear() ||
 	    mba_sc == is_mba_sc(r))
 		return -EINVAL;
 
 	r->membw.mba_sc = mba_sc;
+	list_for_each_entry(d, &r->domains, list)
+		setup_default_ctrlval(r, d->ctrl_val, d->mbps_val);
 
 	return 0;
 }
