xfrm: make local error reporting more robust

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit 628e341f319f1a64a4639088faba952e4ec8f0a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/628e341f.failed

In xfrm4 and xfrm6 we need to take care about sockets of the other
address family. This could happen because a 6in4 or 4in6 tunnel could
get protected by ipsec.

Because we don't want to have a run-time dependency on ipv6 when only
using ipv4 xfrm we have to embed a pointer to the correct local_error
function in xfrm_state_afinet and look it up when returning an error
depending on the socket address family.

Thanks to vi0ss for the great bug report:
<https://bugzilla.kernel.org/show_bug.cgi?id=58691>

v2:
a) fix two more unsafe interpretations of skb->sk as ipv6 socket
   (xfrm6_local_dontfrag and __xfrm6_output)
v3:
a) add an EXPORT_SYMBOL_GPL(xfrm_local_error) to fix a link error when
   building ipv6 as a module (thanks to Steffen Klassert)

	Reported-by: <vi0oss@gmail.com>
	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 628e341f319f1a64a4639088faba952e4ec8f0a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/xfrm.h
#	net/ipv6/xfrm6_output.c
diff --cc include/net/xfrm.h
index 7b755d854c35,e823786e7c66..000000000000
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@@ -344,22 -341,15 +344,30 @@@ struct xfrm_state_afinfo 
  						  struct sk_buff *skb);
  	int			(*transport_finish)(struct sk_buff *skb,
  						    int async);
+ 	void			(*local_error)(struct sk_buff *skb, u32 mtu);
  };
  
++<<<<<<< HEAD
 +int xfrm_state_register_afinfo(struct xfrm_state_afinfo *afinfo);
 +int xfrm_state_unregister_afinfo(struct xfrm_state_afinfo *afinfo);
++=======
+ extern int xfrm_state_register_afinfo(struct xfrm_state_afinfo *afinfo);
+ extern int xfrm_state_unregister_afinfo(struct xfrm_state_afinfo *afinfo);
+ extern struct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned int family);
+ extern void xfrm_state_put_afinfo(struct xfrm_state_afinfo *afinfo);
++>>>>>>> 628e341f319f (xfrm: make local error reporting more robust)
 +
 +struct xfrm_input_afinfo {
 +	unsigned int		family;
 +	struct module		*owner;
 +	int			(*callback)(struct sk_buff *skb, u8 protocol,
 +					    int err);
 +};
  
 -extern void xfrm_state_delete_tunnel(struct xfrm_state *x);
 +int xfrm_input_register_afinfo(struct xfrm_input_afinfo *afinfo);
 +int xfrm_input_unregister_afinfo(struct xfrm_input_afinfo *afinfo);
 +
 +void xfrm_state_delete_tunnel(struct xfrm_state *x);
  
  struct xfrm_type {
  	char			*description;
@@@ -1500,75 -1462,68 +1508,133 @@@ struct xfrmk_spdinfo 
  	u32 spdhmcnt;
  };
  
++<<<<<<< HEAD
 +struct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq);
 +int xfrm_state_delete(struct xfrm_state *x);
 +int xfrm_state_flush(struct net *net, u8 proto, struct xfrm_audit *audit_info);
 +void xfrm_sad_getinfo(struct net *net, struct xfrmk_sadinfo *si);
 +void xfrm_spd_getinfo(struct net *net, struct xfrmk_spdinfo *si);
 +u32 xfrm_replay_seqhi(struct xfrm_state *x, __be32 net_seq);
 +int xfrm_init_replay(struct xfrm_state *x);
 +int xfrm_state_mtu(struct xfrm_state *x, int mtu);
 +int __xfrm_init_state(struct xfrm_state *x, bool init_replay);
 +int xfrm_init_state(struct xfrm_state *x);
 +int xfrm_prepare_input(struct xfrm_state *x, struct sk_buff *skb);
 +int xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type);
 +int xfrm_input_resume(struct sk_buff *skb, int nexthdr);
 +int xfrm_output_resume(struct sk_buff *skb, int err);
 +int xfrm_output(struct sock *sk, struct sk_buff *skb);
 +int xfrm_inner_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +int xfrm4_extract_header(struct sk_buff *skb);
 +int xfrm4_extract_input(struct xfrm_state *x, struct sk_buff *skb);
 +int xfrm4_rcv_encap(struct sk_buff *skb, int nexthdr, __be32 spi,
 +		    int encap_type);
 +int xfrm4_transport_finish(struct sk_buff *skb, int async);
 +int xfrm4_rcv(struct sk_buff *skb);
++=======
+ extern struct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark,
+ 					      u32 seq);
+ extern int xfrm_state_delete(struct xfrm_state *x);
+ extern int xfrm_state_flush(struct net *net, u8 proto, struct xfrm_audit *audit_info);
+ extern void xfrm_sad_getinfo(struct net *net, struct xfrmk_sadinfo *si);
+ extern void xfrm_spd_getinfo(struct net *net, struct xfrmk_spdinfo *si);
+ extern u32 xfrm_replay_seqhi(struct xfrm_state *x, __be32 net_seq);
+ extern int xfrm_init_replay(struct xfrm_state *x);
+ extern int xfrm_state_mtu(struct xfrm_state *x, int mtu);
+ extern int __xfrm_init_state(struct xfrm_state *x, bool init_replay);
+ extern int xfrm_init_state(struct xfrm_state *x);
+ extern int xfrm_prepare_input(struct xfrm_state *x, struct sk_buff *skb);
+ extern int xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi,
+ 		      int encap_type);
+ extern int xfrm_input_resume(struct sk_buff *skb, int nexthdr);
+ extern int xfrm_output_resume(struct sk_buff *skb, int err);
+ extern int xfrm_output(struct sk_buff *skb);
+ extern int xfrm_inner_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ extern void xfrm_local_error(struct sk_buff *skb, int mtu);
+ extern int xfrm4_extract_header(struct sk_buff *skb);
+ extern int xfrm4_extract_input(struct xfrm_state *x, struct sk_buff *skb);
+ extern int xfrm4_rcv_encap(struct sk_buff *skb, int nexthdr, __be32 spi,
+ 			   int encap_type);
+ extern int xfrm4_transport_finish(struct sk_buff *skb, int async);
+ extern int xfrm4_rcv(struct sk_buff *skb);
++>>>>>>> 628e341f319f (xfrm: make local error reporting more robust)
  
  static inline int xfrm4_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi)
  {
 -	return xfrm4_rcv_encap(skb, nexthdr, spi, 0);
 -}
 -
 +	XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;
 +	XFRM_SPI_SKB_CB(skb)->family = AF_INET;
 +	XFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);
 +	return xfrm_input(skb, nexthdr, spi, 0);
 +}
 +
++<<<<<<< HEAD
 +int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 +int xfrm4_output(struct sock *sk, struct sk_buff *skb);
 +int xfrm4_output_finish(struct sock *sk, struct sk_buff *skb);
 +int xfrm4_rcv_cb(struct sk_buff *skb, u8 protocol, int err);
 +int xfrm4_protocol_register(struct xfrm4_protocol *handler, unsigned char protocol);
 +int xfrm4_protocol_deregister(struct xfrm4_protocol *handler, unsigned char protocol);
 +int xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);
 +int xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);
 +int xfrm6_mode_tunnel_input_register(struct xfrm_tunnel_notifier *handler);
 +int xfrm6_mode_tunnel_input_deregister(struct xfrm_tunnel_notifier *handler);
 +int xfrm6_extract_header(struct sk_buff *skb);
 +int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);
 +int xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi,
 +		  struct ip6_tnl *t);
 +int xfrm6_transport_finish(struct sk_buff *skb, int async);
 +int xfrm6_rcv_tnl(struct sk_buff *skb, struct ip6_tnl *t);
 +int xfrm6_rcv(struct sk_buff *skb);
 +int xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,
 +		     xfrm_address_t *saddr, u8 proto);
 +int xfrm6_rcv_cb(struct sk_buff *skb, u8 protocol, int err);
 +int xfrm6_protocol_register(struct xfrm6_protocol *handler, unsigned char protocol);
 +int xfrm6_protocol_deregister(struct xfrm6_protocol *handler, unsigned char protocol);
 +int xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);
 +int xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family);
 +__be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);
 +__be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);
 +int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 +int xfrm6_output(struct sock *sk, struct sk_buff *skb);
 +int xfrm6_output_finish(struct sock *sk, struct sk_buff *skb);
 +int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
 +			  u8 **prevhdr);
++=======
+ extern int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ extern int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
+ extern int xfrm4_output(struct sk_buff *skb);
+ extern int xfrm4_output_finish(struct sk_buff *skb);
+ extern int xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);
+ extern int xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);
+ extern int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel *handler);
+ extern int xfrm4_mode_tunnel_input_deregister(struct xfrm_tunnel *handler);
+ extern void xfrm4_local_error(struct sk_buff *skb, u32 mtu);
+ extern int xfrm6_extract_header(struct sk_buff *skb);
+ extern int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);
+ extern int xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi);
+ extern int xfrm6_transport_finish(struct sk_buff *skb, int async);
+ extern int xfrm6_rcv(struct sk_buff *skb);
+ extern int xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,
+ 			    xfrm_address_t *saddr, u8 proto);
+ extern int xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);
+ extern int xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family);
+ extern __be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);
+ extern __be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);
+ extern int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ extern int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
+ extern int xfrm6_output(struct sk_buff *skb);
+ extern int xfrm6_output_finish(struct sk_buff *skb);
+ extern int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
+ 				 u8 **prevhdr);
+ extern void xfrm6_local_error(struct sk_buff *skb, u32 mtu);
++>>>>>>> 628e341f319f (xfrm: make local error reporting more robust)
  
  #ifdef CONFIG_XFRM
 -extern int xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);
 -extern int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen);
 +int xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);
 +int xfrm_user_policy(struct sock *sk, int optname,
 +		     u8 __user *optval, int optlen);
  #else
  static inline int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen)
  {
diff --cc net/ipv6/xfrm6_output.c
index c8c86890fffe,b64fff30eb06..000000000000
--- a/net/ipv6/xfrm6_output.c
+++ b/net/ipv6/xfrm6_output.c
@@@ -132,31 -138,13 +134,36 @@@ static int __xfrm6_output(struct sock *
  {
  	struct dst_entry *dst = skb_dst(skb);
  	struct xfrm_state *x = dst->xfrm;
 -	int mtu = ip6_skb_dst_mtu(skb);
 +	int mtu;
 +	bool toobig;
  
 -	if (skb->len > mtu && xfrm6_local_dontfrag(skb)) {
 +#ifdef CONFIG_NETFILTER
 +	if (!x) {
 +		IP6CB(skb)->flags |= IP6SKB_REROUTED;
 +		return dst_output_sk(sk, skb);
 +	}
 +#endif
 +
 +	if (x->props.mode != XFRM_MODE_TUNNEL)
 +		goto skip_frag;
 +
 +	if (skb->protocol == htons(ETH_P_IPV6))
 +		mtu = ip6_skb_dst_mtu(skb);
 +	else
 +		mtu = dst_mtu(skb_dst(skb));
 +
 +	toobig = skb->len > mtu && !skb_is_gso(skb);
 +
 +	if (toobig && xfrm6_local_dontfrag(skb)) {
  		xfrm6_local_rxpmtu(skb, mtu);
  		return -EMSGSIZE;
++<<<<<<< HEAD
 +	} else if (!skb->ignore_df && toobig && skb->sk) {
 +		xfrm6_local_error(skb, mtu);
++=======
+ 	} else if (!skb->local_df && skb->len > mtu && skb->sk) {
+ 		xfrm_local_error(skb, mtu);
++>>>>>>> 628e341f319f (xfrm: make local error reporting more robust)
  		return -EMSGSIZE;
  	}
  
* Unmerged path include/net/xfrm.h
diff --git a/net/ipv4/xfrm4_output.c b/net/ipv4/xfrm4_output.c
index 0ab9469815dd..2d0fe4f71158 100644
--- a/net/ipv4/xfrm4_output.c
+++ b/net/ipv4/xfrm4_output.c
@@ -31,8 +31,7 @@ static int xfrm4_tunnel_check_size(struct sk_buff *skb)
 	mtu = dst_mtu(skb_dst(skb));
 	if (skb->len > mtu) {
 		if (skb->sk)
-			ip_local_error(skb->sk, EMSGSIZE, ip_hdr(skb)->daddr,
-				       inet_sk(skb->sk)->inet_dport, mtu);
+			xfrm_local_error(skb, mtu);
 		else
 			icmp_send(skb, ICMP_DEST_UNREACH,
 				  ICMP_FRAG_NEEDED, htonl(mtu));
@@ -101,3 +100,12 @@ int xfrm4_output(struct sock *sk, struct sk_buff *skb)
 			    NULL, skb_dst(skb)->dev, __xfrm4_output,
 			    !(IPCB(skb)->flags & IPSKB_REROUTED));
 }
+
+void xfrm4_local_error(struct sk_buff *skb, u32 mtu)
+{
+	struct iphdr *hdr;
+
+	hdr = skb->encapsulation ? inner_ip_hdr(skb) : ip_hdr(skb);
+	ip_local_error(skb->sk, EMSGSIZE, hdr->daddr,
+		       inet_sk(skb->sk)->inet_dport, mtu);
+}
diff --git a/net/ipv4/xfrm4_state.c b/net/ipv4/xfrm4_state.c
index 8fdfb2e69ab5..0b66700e18c5 100644
--- a/net/ipv4/xfrm4_state.c
+++ b/net/ipv4/xfrm4_state.c
@@ -83,6 +83,7 @@ static struct xfrm_state_afinfo xfrm4_state_afinfo = {
 	.extract_input		= xfrm4_extract_input,
 	.extract_output		= xfrm4_extract_output,
 	.transport_finish	= xfrm4_transport_finish,
+	.local_error		= xfrm4_local_error,
 };
 
 void __init xfrm4_state_init(void)
* Unmerged path net/ipv6/xfrm6_output.c
diff --git a/net/ipv6/xfrm6_state.c b/net/ipv6/xfrm6_state.c
index d8c70b8efc24..3fc970135fc6 100644
--- a/net/ipv6/xfrm6_state.c
+++ b/net/ipv6/xfrm6_state.c
@@ -183,6 +183,7 @@ static struct xfrm_state_afinfo xfrm6_state_afinfo = {
 	.extract_input		= xfrm6_extract_input,
 	.extract_output		= xfrm6_extract_output,
 	.transport_finish	= xfrm6_transport_finish,
+	.local_error		= xfrm6_local_error,
 };
 
 int __init xfrm6_state_init(void)
diff --git a/net/xfrm/xfrm_output.c b/net/xfrm/xfrm_output.c
index 6a63b59285e9..65a0e1a9ac98 100644
--- a/net/xfrm/xfrm_output.c
+++ b/net/xfrm/xfrm_output.c
@@ -222,5 +222,18 @@ int xfrm_inner_extract_output(struct xfrm_state *x, struct sk_buff *skb)
 	return inner_mode->afinfo->extract_output(x, skb);
 }
 
+void xfrm_local_error(struct sk_buff *skb, int mtu)
+{
+	struct xfrm_state_afinfo *afinfo;
+
+	afinfo = xfrm_state_get_afinfo(skb->sk->sk_family);
+	if (!afinfo)
+		return;
+
+	afinfo->local_error(skb, mtu);
+	xfrm_state_put_afinfo(afinfo);
+}
+
 EXPORT_SYMBOL_GPL(xfrm_output);
 EXPORT_SYMBOL_GPL(xfrm_inner_extract_output);
+EXPORT_SYMBOL_GPL(xfrm_local_error);
diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c
index 0c4d95b4bc81..32da845a2dbb 100644
--- a/net/xfrm/xfrm_state.c
+++ b/net/xfrm/xfrm_state.c
@@ -37,9 +37,6 @@
 
 static unsigned int xfrm_state_hashmax __read_mostly = 1 * 1024 * 1024;
 
-static struct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned int family);
-static void xfrm_state_put_afinfo(struct xfrm_state_afinfo *afinfo);
-
 static inline unsigned int xfrm_dst_hash(struct net *net,
 					 const xfrm_address_t *daddr,
 					 const xfrm_address_t *saddr,
@@ -1952,7 +1949,7 @@ int xfrm_state_unregister_afinfo(struct xfrm_state_afinfo *afinfo)
 }
 EXPORT_SYMBOL(xfrm_state_unregister_afinfo);
 
-static struct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned int family)
+struct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned int family)
 {
 	struct xfrm_state_afinfo *afinfo;
 	if (unlikely(family >= NPROTO))
@@ -1964,7 +1961,7 @@ static struct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned int family)
 	return afinfo;
 }
 
-static void xfrm_state_put_afinfo(struct xfrm_state_afinfo *afinfo)
+void xfrm_state_put_afinfo(struct xfrm_state_afinfo *afinfo)
 {
 	rcu_read_unlock();
 }
