x86/resctrl: Prevent NULL pointer dereference when local MBM is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] resctrl: Prevent NULL pointer dereference when local MBM is disabled (Prarit Bhargava) [1713547]
Rebuild_FUZZ: 97.14%
commit-author Prarit Bhargava <prarit@redhat.com>
commit c7563e62a6d720aa3b068e26ddffab5f0df29263
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c7563e62.failed

Booting with kernel parameter "rdt=cmt,mbmtotal,memlocal,l3cat,mba" and
executing "mount -t resctrl resctrl -o mba_MBps /sys/fs/resctrl" results in
a NULL pointer dereference on systems which do not have local MBM support
enabled..

BUG: kernel NULL pointer dereference, address: 0000000000000020
PGD 0 P4D 0
Oops: 0000 [#1] SMP PTI
CPU: 0 PID: 722 Comm: kworker/0:3 Not tainted 5.2.0-0.rc3.git0.1.el7_UNSUPPORTED.x86_64 #2
Workqueue: events mbm_handle_overflow
RIP: 0010:mbm_handle_overflow+0x150/0x2b0

Only enter the bandwith update loop if the system has local MBM enabled.

Fixes: de73f38f7680 ("x86/intel_rdt/mba_sc: Feedback loop to dynamically update mem bandwidth")
	Signed-off-by: Prarit Bhargava <prarit@redhat.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Fenghua Yu <fenghua.yu@intel.com>
	Cc: Reinette Chatre <reinette.chatre@intel.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: stable@vger.kernel.org
Link: https://lkml.kernel.org/r/20190610171544.13474-1-prarit@redhat.com

(cherry picked from commit c7563e62a6d720aa3b068e26ddffab5f0df29263)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/intel_rdt_monitor.c
diff --cc arch/x86/kernel/cpu/intel_rdt_monitor.c
index 51ac181fbdf1,ff6e8e561405..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt_monitor.c
+++ b/arch/x86/kernel/cpu/intel_rdt_monitor.c
@@@ -329,6 -326,121 +329,124 @@@ void mon_event_count(void *info
  	}
  }
  
++<<<<<<< HEAD:arch/x86/kernel/cpu/intel_rdt_monitor.c
++=======
+ /*
+  * Feedback loop for MBA software controller (mba_sc)
+  *
+  * mba_sc is a feedback loop where we periodically read MBM counters and
+  * adjust the bandwidth percentage values via the IA32_MBA_THRTL_MSRs so
+  * that:
+  *
+  *   current bandwdith(cur_bw) < user specified bandwidth(user_bw)
+  *
+  * This uses the MBM counters to measure the bandwidth and MBA throttle
+  * MSRs to control the bandwidth for a particular rdtgrp. It builds on the
+  * fact that resctrl rdtgroups have both monitoring and control.
+  *
+  * The frequency of the checks is 1s and we just tag along the MBM overflow
+  * timer. Having 1s interval makes the calculation of bandwidth simpler.
+  *
+  * Although MBA's goal is to restrict the bandwidth to a maximum, there may
+  * be a need to increase the bandwidth to avoid uncecessarily restricting
+  * the L2 <-> L3 traffic.
+  *
+  * Since MBA controls the L2 external bandwidth where as MBM measures the
+  * L3 external bandwidth the following sequence could lead to such a
+  * situation.
+  *
+  * Consider an rdtgroup which had high L3 <-> memory traffic in initial
+  * phases -> mba_sc kicks in and reduced bandwidth percentage values -> but
+  * after some time rdtgroup has mostly L2 <-> L3 traffic.
+  *
+  * In this case we may restrict the rdtgroup's L2 <-> L3 traffic as its
+  * throttle MSRs already have low percentage values.  To avoid
+  * unnecessarily restricting such rdtgroups, we also increase the bandwidth.
+  */
+ static void update_mba_bw(struct rdtgroup *rgrp, struct rdt_domain *dom_mbm)
+ {
+ 	u32 closid, rmid, cur_msr, cur_msr_val, new_msr_val;
+ 	struct mbm_state *pmbm_data, *cmbm_data;
+ 	u32 cur_bw, delta_bw, user_bw;
+ 	struct rdt_resource *r_mba;
+ 	struct rdt_domain *dom_mba;
+ 	struct list_head *head;
+ 	struct rdtgroup *entry;
+ 
+ 	if (!is_mbm_local_enabled())
+ 		return;
+ 
+ 	r_mba = &rdt_resources_all[RDT_RESOURCE_MBA];
+ 	closid = rgrp->closid;
+ 	rmid = rgrp->mon.rmid;
+ 	pmbm_data = &dom_mbm->mbm_local[rmid];
+ 
+ 	dom_mba = get_domain_from_cpu(smp_processor_id(), r_mba);
+ 	if (!dom_mba) {
+ 		pr_warn_once("Failure to get domain for MBA update\n");
+ 		return;
+ 	}
+ 
+ 	cur_bw = pmbm_data->prev_bw;
+ 	user_bw = dom_mba->mbps_val[closid];
+ 	delta_bw = pmbm_data->delta_bw;
+ 	cur_msr_val = dom_mba->ctrl_val[closid];
+ 
+ 	/*
+ 	 * For Ctrl groups read data from child monitor groups.
+ 	 */
+ 	head = &rgrp->mon.crdtgrp_list;
+ 	list_for_each_entry(entry, head, mon.crdtgrp_list) {
+ 		cmbm_data = &dom_mbm->mbm_local[entry->mon.rmid];
+ 		cur_bw += cmbm_data->prev_bw;
+ 		delta_bw += cmbm_data->delta_bw;
+ 	}
+ 
+ 	/*
+ 	 * Scale up/down the bandwidth linearly for the ctrl group.  The
+ 	 * bandwidth step is the bandwidth granularity specified by the
+ 	 * hardware.
+ 	 *
+ 	 * The delta_bw is used when increasing the bandwidth so that we
+ 	 * dont alternately increase and decrease the control values
+ 	 * continuously.
+ 	 *
+ 	 * For ex: consider cur_bw = 90MBps, user_bw = 100MBps and if
+ 	 * bandwidth step is 20MBps(> user_bw - cur_bw), we would keep
+ 	 * switching between 90 and 110 continuously if we only check
+ 	 * cur_bw < user_bw.
+ 	 */
+ 	if (cur_msr_val > r_mba->membw.min_bw && user_bw < cur_bw) {
+ 		new_msr_val = cur_msr_val - r_mba->membw.bw_gran;
+ 	} else if (cur_msr_val < MAX_MBA_BW &&
+ 		   (user_bw > (cur_bw + delta_bw))) {
+ 		new_msr_val = cur_msr_val + r_mba->membw.bw_gran;
+ 	} else {
+ 		return;
+ 	}
+ 
+ 	cur_msr = r_mba->msr_base + closid;
+ 	wrmsrl(cur_msr, delay_bw_map(new_msr_val, r_mba));
+ 	dom_mba->ctrl_val[closid] = new_msr_val;
+ 
+ 	/*
+ 	 * Delta values are updated dynamically package wise for each
+ 	 * rdtgrp everytime the throttle MSR changes value.
+ 	 *
+ 	 * This is because (1)the increase in bandwidth is not perfectly
+ 	 * linear and only "approximately" linear even when the hardware
+ 	 * says it is linear.(2)Also since MBA is a core specific
+ 	 * mechanism, the delta values vary based on number of cores used
+ 	 * by the rdtgrp.
+ 	 */
+ 	pmbm_data->delta_comp = true;
+ 	list_for_each_entry(entry, head, mon.crdtgrp_list) {
+ 		cmbm_data = &dom_mbm->mbm_local[entry->mon.rmid];
+ 		cmbm_data->delta_comp = true;
+ 	}
+ }
+ 
++>>>>>>> c7563e62a6d7 (x86/resctrl: Prevent NULL pointer dereference when local MBM is disabled):arch/x86/kernel/cpu/resctrl/monitor.c
  static void mbm_update(struct rdt_domain *d, int rmid)
  {
  	struct rmid_read rr;
* Unmerged path arch/x86/kernel/cpu/intel_rdt_monitor.c
