tcp: enforce tcp_min_snd_mss in tcp_mtu_probing()

jira LE-1907
cve CVE-2019-11479
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 967c05aee439e6e5d7d805e195b3a20ef5c433d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/967c05ae.failed

If mtu probing is enabled tcp_mtu_probing() could very well end up
with a too small MSS.

Use the new sysctl tcp_min_snd_mss to make sure MSS search
is performed in an acceptable range.

CVE-2019-11479 -- tcp mss hardcoded to 48

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: Jonathan Lemon <jonathan.lemon@gmail.com>
	Cc: Jonathan Looney <jtl@netflix.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Cc: Yuchung Cheng <ycheng@google.com>
	Cc: Tyler Hicks <tyhicks@canonical.com>
	Cc: Bruce Curtis <brucec@netflix.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 967c05aee439e6e5d7d805e195b3a20ef5c433d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_timer.c
diff --cc net/ipv4/tcp_timer.c
index 728fbbc3c868,c801cd37cc2a..000000000000
--- a/net/ipv4/tcp_timer.c
+++ b/net/ipv4/tcp_timer.c
@@@ -98,28 -141,52 +98,40 @@@ static int tcp_orphan_retries(struct so
  
  static void tcp_mtu_probing(struct inet_connection_sock *icsk, struct sock *sk)
  {
 -	const struct net *net = sock_net(sk);
 -	int mss;
 -
  	/* Black hole detection */
 -	if (!net->ipv4.sysctl_tcp_mtu_probing)
 -		return;
 -
 +	if (sysctl_tcp_mtu_probing) {
 +		if (!icsk->icsk_mtup.enabled) {
 +			icsk->icsk_mtup.enabled = 1;
 +			tcp_sync_mss(sk, icsk->icsk_pmtu_cookie);
 +		} else {
 +			struct tcp_sock *tp = tcp_sk(sk);
 +			int mss;
 +
++<<<<<<< HEAD
 +			mss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;
 +			mss = min(sysctl_tcp_base_mss, mss);
 +			mss = max(mss, 68 - tp->tcp_header_len);
 +			icsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);
 +			tcp_sync_mss(sk, icsk->icsk_pmtu_cookie);
 +		}
++=======
+ 	if (!icsk->icsk_mtup.enabled) {
+ 		icsk->icsk_mtup.enabled = 1;
+ 		icsk->icsk_mtup.probe_timestamp = tcp_jiffies32;
+ 	} else {
+ 		mss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;
+ 		mss = min(net->ipv4.sysctl_tcp_base_mss, mss);
+ 		mss = max(mss, 68 - tcp_sk(sk)->tcp_header_len);
+ 		mss = max(mss, net->ipv4.sysctl_tcp_min_snd_mss);
+ 		icsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);
++>>>>>>> 967c05aee439 (tcp: enforce tcp_min_snd_mss in tcp_mtu_probing())
  	}
 -	tcp_sync_mss(sk, icsk->icsk_pmtu_cookie);
  }
  
 -static unsigned int tcp_model_timeout(struct sock *sk,
 -				      unsigned int boundary,
 -				      unsigned int rto_base)
 -{
 -	unsigned int linear_backoff_thresh, timeout;
 -
 -	linear_backoff_thresh = ilog2(TCP_RTO_MAX / rto_base);
 -	if (boundary <= linear_backoff_thresh)
 -		timeout = ((2 << boundary) - 1) * rto_base;
 -	else
 -		timeout = ((2 << linear_backoff_thresh) - 1) * rto_base +
 -			(boundary - linear_backoff_thresh) * TCP_RTO_MAX;
 -	return jiffies_to_msecs(timeout);
 -}
 -/**
 - *  retransmits_timed_out() - returns true if this connection has timed out
 - *  @sk:       The current socket
 - *  @boundary: max number of retransmissions
 - *  @timeout:  A custom timeout value.
 - *             If set to 0 the default timeout is calculated and used.
 - *             Using TCP_RTO_MIN and the number of unsuccessful retransmits.
 - *
 - * The default "timeout" value this function can calculate and use
 - * is equivalent to the timeout of a TCP Connection
 - * after "boundary" unsuccessful, exponentially backed-off
 - * retransmissions with an initial RTO of TCP_RTO_MIN.
 +/* This function calculates a "timeout" which is equivalent to the timeout of a
 + * TCP connection after "boundary" unsuccessful, exponentially backed-off
 + * retransmissions with an initial RTO of TCP_RTO_MIN or TCP_TIMEOUT_INIT if
 + * syn_set flag is set.
   */
  static bool retransmits_timed_out(struct sock *sk,
  				  unsigned int boundary,
* Unmerged path net/ipv4/tcp_timer.c
