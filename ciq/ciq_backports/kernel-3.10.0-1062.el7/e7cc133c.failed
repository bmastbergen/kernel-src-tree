fuse: Flush files on wb close

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Pavel Emelyanov <xemul@openvz.org>
commit e7cc133c370f541fa16723ad7df24de375c26fce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e7cc133c.failed

Any write request requires a file handle to report to the userspace. Thus
when we close a file (and free the fuse_file with this info) we have to
flush all the outstanding dirty pages.

filemap_write_and_wait() is enough because every page under fuse writeback
is accounted in ff->count. This delays actual close until all fuse wb is
completed.

In case of "write cache" turned off, the flush is ensured by fuse_vma_close().

	Signed-off-by: Maxim Patlasov <MPatlasov@parallels.com>
	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit e7cc133c370f541fa16723ad7df24de375c26fce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/file.c
diff --cc fs/fuse/file.c
index 2063be2e547a,530b1e804a32..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -308,6 -308,15 +308,18 @@@ static int fuse_open(struct inode *inod
  
  static int fuse_release(struct inode *inode, struct file *file)
  {
++<<<<<<< HEAD
++=======
+ 	struct fuse_conn *fc = get_fuse_conn(inode);
+ 
+ 	/* see fuse_vma_close() for !writeback_cache case */
+ 	if (fc->writeback_cache)
+ 		filemap_write_and_wait(file->f_mapping);
+ 
+ 	if (test_bit(FUSE_I_MTIME_DIRTY, &get_fuse_inode(inode)->state))
+ 		fuse_flush_mtime(file, true);
+ 
++>>>>>>> e7cc133c370f (fuse: Flush files on wb close)
  	fuse_release_common(file, FUSE_RELEASE);
  
  	/* return value is ignored by VFS */
* Unmerged path fs/fuse/file.c
