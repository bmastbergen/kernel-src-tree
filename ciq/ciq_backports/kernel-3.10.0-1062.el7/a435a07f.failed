net: ipv6: fallback to full lookup if table lookup is unsuitable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [net] ipv6: fallback to full lookup if table lookup is unsuitable (Guillaume Nault) [1535977]
Rebuild_FUZZ: 95.93%
commit-author Vincent Bernat <vincent@bernat.im>
commit a435a07f9164dda7c0c26e8ad758881f4bafc127
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a435a07f.failed

Commit 8c14586fc320 ("net: ipv6: Use passed in table for nexthop
lookups") introduced a regression: insertion of an IPv6 route in a table
not containing the appropriate connected route for the gateway but which
contained a non-connected route (like a default gateway) fails while it
was previously working:

    $ ip link add eth0 type dummy
    $ ip link set up dev eth0
    $ ip addr add 2001:db8::1/64 dev eth0
    $ ip route add ::/0 via 2001:db8::5 dev eth0 table 20
    $ ip route add 2001:db8:cafe::1/128 via 2001:db8::6 dev eth0 table 20
    RTNETLINK answers: No route to host
    $ ip -6 route show table 20
    default via 2001:db8::5 dev eth0  metric 1024  pref medium

After this patch, we get:

    $ ip route add 2001:db8:cafe::1/128 via 2001:db8::6 dev eth0 table 20
    $ ip -6 route show table 20
    2001:db8:cafe::1 via 2001:db8::6 dev eth0  metric 1024  pref medium
    default via 2001:db8::5 dev eth0  metric 1024  pref medium

Fixes: 8c14586fc320 ("net: ipv6: Use passed in table for nexthop lookups")
	Signed-off-by: Vincent Bernat <vincent@bernat.im>
	Acked-by: David Ahern <dsa@cumulusnetworks.com>
	Tested-by: David Ahern <dsa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a435a07f9164dda7c0c26e8ad758881f4bafc127)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/route.c
diff --cc net/ipv6/route.c
index 9ee2312eaf73,e3a224b97905..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -1955,7 -1986,21 +1955,25 @@@ int ip6_route_info_create(struct fib6_c
  			if (!(gwa_type & IPV6_ADDR_UNICAST))
  				goto out;
  
++<<<<<<< HEAD
 +			grt = rt6_lookup(net, gw_addr, NULL, cfg->fc_ifindex, 1);
++=======
+ 			if (cfg->fc_table) {
+ 				grt = ip6_nh_lookup_table(net, cfg, gw_addr);
+ 
+ 				if (grt) {
+ 					if (grt->rt6i_flags & RTF_GATEWAY ||
+ 					    (dev && dev != grt->dst.dev)) {
+ 						ip6_rt_put(grt);
+ 						grt = NULL;
+ 					}
+ 				}
+ 			}
+ 
+ 			if (!grt)
+ 				grt = rt6_lookup(net, gw_addr, NULL,
+ 						 cfg->fc_ifindex, 1);
++>>>>>>> a435a07f9164 (net: ipv6: fallback to full lookup if table lookup is unsuitable)
  
  			err = -EHOSTUNREACH;
  			if (!grt)
* Unmerged path net/ipv6/route.c
