perf tools: Make fetch_kernel_version() publicly available

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit 07bc5c699a3d8fe5e26dbcd72e4103c7988055ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/07bc5c69.failed

There are 2 places in llvm-utils.c which find kernel version information
through uname. This patch extracts the uname related code into a
fetch_kernel_version() function and puts it into util.h so it can be
reused.

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/1446818135-87310-1-git-send-email-wangnan0@huawei.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 07bc5c699a3d8fe5e26dbcd72e4103c7988055ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/llvm-utils.c
#	tools/perf/util/util.c
diff --cc tools/perf/util/llvm-utils.c
index 1094f8780b7a,00724d496d38..000000000000
--- a/tools/perf/util/llvm-utils.c
+++ b/tools/perf/util/llvm-utils.c
@@@ -3,22 -3,19 +3,26 @@@
   * Copyright (C) 2015, Huawei Inc.
   */
  
 +#include <errno.h>
 +#include <limits.h>
  #include <stdio.h>
++<<<<<<< HEAD
 +#include <sys/utsname.h>
++=======
+ #include "util.h"
++>>>>>>> 07bc5c699a3d (perf tools: Make fetch_kernel_version() publicly available)
  #include "debug.h"
  #include "llvm-utils.h"
 -#include "cache.h"
 +#include "config.h"
 +#include <stdlib.h>
 +#include "util.h"
 +#include <sys/wait.h>
  
  #define CLANG_BPF_CMD_DEFAULT_TEMPLATE				\
 -		"$CLANG_EXEC -D__KERNEL__ -D__NR_CPUS__=$NR_CPUS "\
 -		"-DLINUX_VERSION_CODE=$LINUX_VERSION_CODE "	\
 -		"$CLANG_OPTIONS $KERNEL_INC_OPTIONS "		\
 -		"-Wno-unused-value -Wno-pointer-sign "		\
 -		"-working-directory $WORKING_DIR "		\
 -		"-c \"$CLANG_SOURCE\" -target bpf -O2 -o -"
 +		"$CLANG_EXEC -D__KERNEL__ $CLANG_OPTIONS "	\
 +		"$KERNEL_INC_OPTIONS -Wno-unused-value "	\
 +		"-Wno-pointer-sign -working-directory "		\
 +		"$WORKING_DIR -c \"$CLANG_SOURCE\" -target bpf -O2 -o -"
  
  struct llvm_param llvm_param = {
  	.clang_path = "clang",
@@@ -330,22 -328,16 +335,31 @@@ get_kbuild_opts(char **kbuild_dir, cha
  int llvm__compile_bpf(const char *path, void **p_obj_buf,
  		      size_t *p_obj_buf_sz)
  {
++<<<<<<< HEAD
 +	int err;
 +	const char *clang_opt = llvm_param.clang_opt;
 +	char clang_path[PATH_MAX], abspath[PATH_MAX];
 +	char serr[STRERR_BUFSIZE];
 +	const char *template = llvm_param.clang_bpf_cmd_template;
- 	char *kbuild_dir = NULL, *kbuild_include_opts = NULL;
- 	void *obj_buf = NULL;
++=======
  	size_t obj_buf_sz;
+ 	void *obj_buf = NULL;
+ 	int err, nr_cpus_avail;
+ 	unsigned int kernel_version;
+ 	char linux_version_code_str[64];
+ 	const char *clang_opt = llvm_param.clang_opt;
+ 	char clang_path[PATH_MAX], nr_cpus_avail_str[64];
++>>>>>>> 07bc5c699a3d (perf tools: Make fetch_kernel_version() publicly available)
+ 	char *kbuild_dir = NULL, *kbuild_include_opts = NULL;
+ 	const char *template = llvm_param.clang_bpf_cmd_template;
  
 +	if (path[0] != '-' && realpath(path, abspath) == NULL) {
 +		err = errno;
 +		pr_err("ERROR: problems with path %s: %s\n",
 +		       path, strerror_r(err, serr, sizeof(serr)));
 +		return -err;
 +	}
 +
  	if (!template)
  		template = CLANG_BPF_CMD_DEFAULT_TEMPLATE;
  
@@@ -366,6 -358,24 +380,27 @@@
  	 */
  	get_kbuild_opts(&kbuild_dir, &kbuild_include_opts);
  
++<<<<<<< HEAD
++=======
+ 	nr_cpus_avail = sysconf(_SC_NPROCESSORS_CONF);
+ 	if (nr_cpus_avail <= 0) {
+ 		pr_err(
+ "WARNING:\tunable to get available CPUs in this system: %s\n"
+ "        \tUse 128 instead.\n", strerror(errno));
+ 		nr_cpus_avail = 128;
+ 	}
+ 	snprintf(nr_cpus_avail_str, sizeof(nr_cpus_avail_str), "%d",
+ 		 nr_cpus_avail);
+ 
+ 	if (fetch_kernel_version(&kernel_version, NULL, 0))
+ 		kernel_version = 0;
+ 
+ 	snprintf(linux_version_code_str, sizeof(linux_version_code_str),
+ 		 "0x%x", kernel_version);
+ 
+ 	force_set_env("NR_CPUS", nr_cpus_avail_str);
+ 	force_set_env("LINUX_VERSION_CODE", linux_version_code_str);
++>>>>>>> 07bc5c699a3d (perf tools: Make fetch_kernel_version() publicly available)
  	force_set_env("CLANG_EXEC", clang_path);
  	force_set_env("CLANG_OPTIONS", clang_opt);
  	force_set_env("KERNEL_INC_OPTIONS", kbuild_include_opts);
diff --cc tools/perf/util/util.c
index 3a30fd6eb68d,47b1e36c7ea0..000000000000
--- a/tools/perf/util/util.c
+++ b/tools/perf/util/util.c
@@@ -3,11 -3,10 +3,18 @@@
  #include "debug.h"
  #include <api/fs/fs.h>
  #include <sys/mman.h>
++<<<<<<< HEAD
 +#include <sys/stat.h>
 +#include <dirent.h>
 +#include <fcntl.h>
 +#include <inttypes.h>
 +#include <signal.h>
++=======
+ #include <sys/utsname.h>
+ #ifdef HAVE_BACKTRACE_SUPPORT
+ #include <execinfo.h>
+ #endif
++>>>>>>> 07bc5c699a3d (perf tools: Make fetch_kernel_version() publicly available)
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
@@@ -358,30 -610,88 +365,59 @@@ int perf_event_paranoid(void
  	return value;
  }
  
 -void mem_bswap_32(void *src, int byte_size)
 -{
 -	u32 *m = src;
 -	while (byte_size > 0) {
 -		*m = bswap_32(*m);
 -		byte_size -= sizeof(u32);
 -		++m;
 -	}
 -}
 -
 -void mem_bswap_64(void *src, int byte_size)
 +const char *perf_tip(const char *dirpath)
  {
 -	u64 *m = src;
 -
 -	while (byte_size > 0) {
 -		*m = bswap_64(*m);
 -		byte_size -= sizeof(u64);
 -		++m;
 -	}
 -}
 -
 -bool find_process(const char *name)
 -{
 -	size_t len = strlen(name);
 -	DIR *dir;
 -	struct dirent *d;
 -	int ret = -1;
 -
 -	dir = opendir(procfs__mountpoint());
 -	if (!dir)
 -		return false;
 -
 -	/* Walk through the directory. */
 -	while (ret && (d = readdir(dir)) != NULL) {
 -		char path[PATH_MAX];
 -		char *data;
 -		size_t size;
 -
 -		if ((d->d_type != DT_DIR) ||
 -		     !strcmp(".", d->d_name) ||
 -		     !strcmp("..", d->d_name))
 -			continue;
 +	struct strlist *tips;
 +	struct str_node *node;
 +	char *tip = NULL;
 +	struct strlist_config conf = {
 +		.dirname = dirpath,
 +		.file_only = true,
 +	};
 +
 +	tips = strlist__new("tips.txt", &conf);
 +	if (tips == NULL)
 +		return errno == ENOENT ? NULL :
 +			"Tip: check path of tips.txt or get more memory! ;-p";
 +
 +	if (strlist__nr_entries(tips) == 0)
 +		goto out;
  
 -		scnprintf(path, sizeof(path), "%s/%s/comm",
 -			  procfs__mountpoint(), d->d_name);
 +	node = strlist__entry(tips, random() % strlist__nr_entries(tips));
 +	if (asprintf(&tip, "Tip: %s", node->s) < 0)
 +		tip = (char *)"Tip: get more memory! ;-)";
  
 -		if (filename__read_str(path, &data, &size))
 -			continue;
 -
 -		ret = strncmp(name, data, len);
 -		free(data);
 -	}
 +out:
 +	strlist__delete(tips);
  
 -	closedir(dir);
 -	return ret ? false : true;
 +	return tip;
  }
+ 
+ int
+ fetch_kernel_version(unsigned int *puint, char *str,
+ 		     size_t str_size)
+ {
+ 	struct utsname utsname;
+ 	int version, patchlevel, sublevel, err;
+ 
+ 	if (uname(&utsname))
+ 		return -1;
+ 
+ 	if (str && str_size) {
+ 		strncpy(str, utsname.release, str_size);
+ 		str[str_size - 1] = '\0';
+ 	}
+ 
+ 	err = sscanf(utsname.release, "%d.%d.%d",
+ 		     &version, &patchlevel, &sublevel);
+ 
+ 	if (err != 3) {
+ 		pr_debug("Unablt to get kernel version from uname '%s'\n",
+ 			 utsname.release);
+ 		return -1;
+ 	}
+ 
+ 	if (puint)
+ 		*puint = (version << 16) + (patchlevel << 8) + sublevel;
+ 	return 0;
+ }
* Unmerged path tools/perf/util/llvm-utils.c
* Unmerged path tools/perf/util/util.c
diff --git a/tools/perf/util/util.h b/tools/perf/util/util.h
index 9e6e8607d8e3..26559cb9cf08 100644
--- a/tools/perf/util/util.h
+++ b/tools/perf/util/util.h
@@ -57,4 +57,7 @@ extern bool perf_singlethreaded;
 void perf_set_singlethreaded(void);
 void perf_set_multithreaded(void);
 
+int fetch_kernel_version(unsigned int *puint,
+			 char *str, size_t str_sz);
+
 #endif /* GIT_COMPAT_UTIL_H */
