s390/qeth: cancel close_dev work before removing a card

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [s390] qeth: cancel close_dev work before removing a card (Hendrik Brueckner) [1686040]
Rebuild_FUZZ: 95.24%
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit c2780c1a3fb724560b1d44f7976e0de17bf153c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c2780c1a.failed

A card's close_dev work is scheduled on a driver-wide workqueue. If the
card is removed and freed while the work is still active, this causes a
use-after-free.
So make sure that the work is completed before freeing the card.

Fixes: 0f54761d167f ("qeth: Support VEPA mode")
	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c2780c1a3fb724560b1d44f7976e0de17bf153c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core.h
#	drivers/s390/net/qeth_l2_main.c
#	drivers/s390/net/qeth_l3_main.c
diff --cc drivers/s390/net/qeth_core.h
index d4437aa7c289,1cf45ace0dd0..000000000000
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@@ -18,6 -19,10 +18,13 @@@
  #include <linux/bitops.h>
  #include <linux/seq_file.h>
  #include <linux/ethtool.h>
++<<<<<<< HEAD
++=======
+ #include <linux/hashtable.h>
+ #include <linux/ip.h>
+ #include <linux/refcount.h>
+ #include <linux/workqueue.h>
++>>>>>>> c2780c1a3fb7 (s390/qeth: cancel close_dev work before removing a card)
  
  #include <net/ipv6.h>
  #include <net/if_inet6.h>
diff --cc drivers/s390/net/qeth_l2_main.c
index b9852de25f9b,9fec0117fc00..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -1027,12 -802,9 +1027,17 @@@ static void qeth_l2_remove_device(struc
  	if (cgdev->state == CCWGROUP_ONLINE)
  		qeth_l2_set_offline(cgdev);
  
++<<<<<<< HEAD
 +	if (card->dev) {
++=======
+ 	cancel_work_sync(&card->close_dev_work);
+ 	if (qeth_netdev_is_registered(card->dev))
++>>>>>>> c2780c1a3fb7 (s390/qeth: cancel close_dev work before removing a card)
  		unregister_netdev(card->dev);
 +		free_netdev(card->dev);
 +		card->dev = NULL;
 +	}
 +	return;
  }
  
  static const struct ethtool_ops qeth_l2_ethtool_ops = {
diff --cc drivers/s390/net/qeth_l3_main.c
index faa467771068,5e810561cb12..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -3226,15 -2338,11 +3226,20 @@@ static void qeth_l3_remove_device(struc
  	if (cgdev->state == CCWGROUP_ONLINE)
  		qeth_l3_set_offline(cgdev);
  
++<<<<<<< HEAD
 +	if (card->dev) {
++=======
+ 	cancel_work_sync(&card->close_dev_work);
+ 	if (qeth_netdev_is_registered(card->dev))
++>>>>>>> c2780c1a3fb7 (s390/qeth: cancel close_dev work before removing a card)
  		unregister_netdev(card->dev);
 -	qeth_l3_clear_ip_htable(card, 0);
 +		free_netdev(card->dev);
 +		card->dev = NULL;
 +	}
 +
 +	qeth_l3_clear_ip_list(card, 0);
  	qeth_l3_clear_ipato_list(card);
 +	return;
  }
  
  static int __qeth_l3_set_online(struct ccwgroup_device *gdev, int recovery_mode)
* Unmerged path drivers/s390/net/qeth_core.h
* Unmerged path drivers/s390/net/qeth_l2_main.c
* Unmerged path drivers/s390/net/qeth_l3_main.c
