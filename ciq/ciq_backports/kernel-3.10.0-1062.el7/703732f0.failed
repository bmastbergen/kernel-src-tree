r8169: replace mii_bus member with phy_device member in struct rtl8169_private

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit 703732f0058bd48842aa882217c26a3b3ed30216
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/703732f0.failed

Accessing the phy_device indirectly via the netdevice causes few issues:
- Accessing the phy_device when it's not attached may cause a NPE.
- If we have to access the phy_device when it's not attached we have
  to use mdiobus_get_phy() to get a reference to the phy_device.

Therefore store a phy_device reference in struct rtl8169_private directly.

	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 703732f0058bd48842aa882217c26a3b3ed30216)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/realtek/r8169.c
diff --cc drivers/net/ethernet/realtek/r8169.c
index 8e2332fe4a17,07984f7e3e21..000000000000
--- a/drivers/net/ethernet/realtek/r8169.c
+++ b/drivers/net/ethernet/realtek/r8169.c
@@@ -734,7 -679,7 +735,11 @@@ struct rtl8169_private 
  		struct work_struct work;
  	} wk;
  
++<<<<<<< HEAD
 +	struct mii_if_info mii;
++=======
+ 	unsigned supports_gmii:1;
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  	dma_addr_t counters_phys_addr;
  	struct rtl8169_counters *counters;
  	struct rtl8169_tc_offsets tc_offset;
@@@ -4224,23 -3998,18 +4229,38 @@@ static void rtl8169_init_phy(struct net
  		RTL_W8(tp, 0x82, 0x01);
  	}
  
++<<<<<<< HEAD
 +	if (tp->mac_version == RTL_GIGA_MAC_VER_02) {
 +		netif_dbg(tp, drv, dev,
 +			  "Set MAC Reg C+CR Offset 0x82h = 0x01h\n");
 +		RTL_W8(tp, 0x82, 0x01);
 +		netif_dbg(tp, drv, dev,
 +			  "Set PHY Reg 0x0bh = 0x00h\n");
 +		rtl_writephy(tp, 0x0b, 0x0000); //w 0x0b 15 0 0
 +	}
 +
 +	rtl8169_phy_reset(dev, tp);
 +
 +	rtl8169_set_speed(dev, AUTONEG_ENABLE, SPEED_1000, DUPLEX_FULL,
 +			  ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
 +			  ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
 +			  (tp->mii.supports_gmii ?
 +			   ADVERTISED_1000baseT_Half |
 +			   ADVERTISED_1000baseT_Full : 0));
++=======
+ 	/* We may have called phy_speed_down before */
+ 	phy_speed_up(tp->phydev);
+ 
+ 	genphy_soft_reset(tp->phydev);
+ 
+ 	/* It was reported that several chips end up with 10MBit/Half on a
+ 	 * 1GBit link after resuming from S3. For whatever reason the PHY on
+ 	 * these chips doesn't properly start a renegotiation when soft-reset.
+ 	 * Explicitly requesting a renegotiation fixes this.
+ 	 */
+ 	if (tp->phydev->autoneg == AUTONEG_ENABLE)
+ 		phy_restart_aneg(tp->phydev);
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  }
  
  static void rtl_rar_set(struct rtl8169_private *tp, u8 *addr)
@@@ -4361,10 -4108,10 +4383,17 @@@ static void rtl_wol_suspend_quirk(struc
  
  static bool rtl_wol_pll_power_down(struct rtl8169_private *tp)
  {
++<<<<<<< HEAD
 +	if (!netif_running(tp->dev) || !__rtl8169_get_wol(tp))
 +		return false;
 +
 +	rtl_speed_down(tp);
++=======
+ 	if (!__rtl8169_get_wol(tp))
+ 		return false;
+ 
+ 	phy_speed_down(tp->phydev, false);
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  	rtl_wol_suspend_quirk(tp);
  
  	return true;
@@@ -4473,7 -4180,9 +4502,13 @@@ static void r8168_pll_power_up(struct r
  		break;
  	}
  
++<<<<<<< HEAD
 +	r8168_phy_power_up(tp);
++=======
+ 	phy_resume(tp->phydev);
+ 	/* give MAC/PHY some time to resume */
+ 	msleep(20);
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  }
  
  static void rtl_pll_power_down(struct rtl8169_private *tp)
@@@ -6696,13 -6401,33 +6731,37 @@@ release_descriptor
  static irqreturn_t rtl8169_interrupt(int irq, void *dev_instance)
  {
  	struct rtl8169_private *tp = dev_instance;
 -	u16 status = RTL_R16(tp, IntrStatus);
 -	u16 irq_mask = RTL_R16(tp, IntrMask);
 +	u16 status = rtl_get_events(tp);
  
 -	if (status == 0xffff || !(status & irq_mask))
 +	if (status == 0xffff || !(status & (RTL_EVENT_NAPI | tp->event_slow)))
  		return IRQ_NONE;
  
++<<<<<<< HEAD
 +	rtl_irq_disable(tp);
 +	napi_schedule_irqoff(&tp->napi);
++=======
+ 	if (unlikely(status & SYSErr)) {
+ 		rtl8169_pcierr_interrupt(tp->dev);
+ 		goto out;
+ 	}
+ 
+ 	if (status & LinkChg)
+ 		phy_mac_interrupt(tp->phydev);
+ 
+ 	if (unlikely(status & RxFIFOOver &&
+ 	    tp->mac_version == RTL_GIGA_MAC_VER_11)) {
+ 		netif_stop_queue(tp->dev);
+ 		/* XXX - Hack alert. See rtl_task(). */
+ 		set_bit(RTL_FLAG_TASK_RESET_PENDING, tp->wk.flags);
+ 	}
+ 
+ 	if (status & RTL_EVENT_NAPI) {
+ 		rtl_irq_disable(tp);
+ 		napi_schedule_irqoff(&tp->napi);
+ 	}
+ out:
+ 	rtl_ack_events(tp, status);
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  
  	return IRQ_HANDLED;
  }
@@@ -6814,10 -6492,52 +6873,58 @@@ static void rtl8169_rx_missed(struct ne
  	RTL_W32(tp, RxMissed, 0);
  }
  
++<<<<<<< HEAD
++=======
+ static void r8169_phylink_handler(struct net_device *ndev)
+ {
+ 	struct rtl8169_private *tp = netdev_priv(ndev);
+ 
+ 	if (netif_carrier_ok(ndev)) {
+ 		rtl_link_chg_patch(tp);
+ 		pm_request_resume(&tp->pci_dev->dev);
+ 	} else {
+ 		pm_runtime_idle(&tp->pci_dev->dev);
+ 	}
+ 
+ 	if (net_ratelimit())
+ 		phy_print_status(tp->phydev);
+ }
+ 
+ static int r8169_phy_connect(struct rtl8169_private *tp)
+ {
+ 	struct phy_device *phydev = tp->phydev;
+ 	phy_interface_t phy_mode;
+ 	int ret;
+ 
+ 	phy_mode = tp->supports_gmii ? PHY_INTERFACE_MODE_GMII :
+ 		   PHY_INTERFACE_MODE_MII;
+ 
+ 	ret = phy_connect_direct(tp->dev, phydev, r8169_phylink_handler,
+ 				 phy_mode);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (!tp->supports_gmii)
+ 		phy_set_max_speed(phydev, SPEED_100);
+ 
+ 	/* Ensure to advertise everything, incl. pause */
+ 	linkmode_copy(phydev->advertising, phydev->supported);
+ 
+ 	phy_attached_info(phydev);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  static void rtl8169_down(struct net_device *dev)
  {
  	struct rtl8169_private *tp = netdev_priv(dev);
  
++<<<<<<< HEAD
++=======
+ 	phy_stop(tp->phydev);
+ 
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  	napi_disable(&tp->napi);
  	netif_stop_queue(dev);
  
@@@ -6858,6 -6578,8 +6965,11 @@@ static int rtl8169_close(struct net_dev
  
  	cancel_work_sync(&tp->wk.work);
  
++<<<<<<< HEAD
++=======
+ 	phy_disconnect(tp->phydev);
+ 
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  	pci_free_irq(pdev, 0, tp);
  
  	dma_free_coherent(&pdev->dev, R8169_RX_RING_BYTES, tp->RxDescArray,
@@@ -6929,6 -6655,7 +7041,10 @@@ static int rtl_open(struct net_device *
  	if (!rtl8169_init_counter_offsets(tp))
  		netif_warn(tp, hw, dev, "counter reset/update failed\n");
  
++<<<<<<< HEAD
++=======
+ 	phy_start(tp->phydev);
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  	netif_start_queue(dev);
  
  	rtl_unlock_work(tp);
@@@ -7017,6 -6744,7 +7133,10 @@@ static void rtl8169_net_suspend(struct 
  	if (!netif_running(dev))
  		return;
  
++<<<<<<< HEAD
++=======
+ 	phy_stop(tp->phydev);
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  	netif_device_detach(dev);
  
  	rtl_lock_work(tp);
@@@ -7051,6 -6779,8 +7171,11 @@@ static void __rtl8169_resume(struct net
  	rtl_pll_power_up(tp);
  	rtl8169_init_phy(dev, tp);
  
++<<<<<<< HEAD
++=======
+ 	phy_start(tp->phydev);
+ 
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  	rtl_lock_work(tp);
  	napi_enable(&tp->napi);
  	set_bit(RTL_FLAG_TASK_ENABLED, tp->wk.flags);
@@@ -7194,6 -6922,7 +7319,10 @@@ static void rtl_remove_one(struct pci_d
  	netif_napi_del(&tp->napi);
  
  	unregister_netdev(dev);
++<<<<<<< HEAD
++=======
+ 	mdiobus_unregister(tp->phydev->mdio.bus);
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  
  	rtl_release_firmware(tp);
  
@@@ -7274,6 -7003,65 +7403,68 @@@ DECLARE_RTL_COND(rtl_rxtx_empty_cond
  	return (RTL_R8(tp, MCU) & RXTX_EMPTY) == RXTX_EMPTY;
  }
  
++<<<<<<< HEAD
++=======
+ static int r8169_mdio_read_reg(struct mii_bus *mii_bus, int phyaddr, int phyreg)
+ {
+ 	struct rtl8169_private *tp = mii_bus->priv;
+ 
+ 	if (phyaddr > 0)
+ 		return -ENODEV;
+ 
+ 	return rtl_readphy(tp, phyreg);
+ }
+ 
+ static int r8169_mdio_write_reg(struct mii_bus *mii_bus, int phyaddr,
+ 				int phyreg, u16 val)
+ {
+ 	struct rtl8169_private *tp = mii_bus->priv;
+ 
+ 	if (phyaddr > 0)
+ 		return -ENODEV;
+ 
+ 	rtl_writephy(tp, phyreg, val);
+ 
+ 	return 0;
+ }
+ 
+ static int r8169_mdio_register(struct rtl8169_private *tp)
+ {
+ 	struct pci_dev *pdev = tp->pci_dev;
+ 	struct mii_bus *new_bus;
+ 	int ret;
+ 
+ 	new_bus = devm_mdiobus_alloc(&pdev->dev);
+ 	if (!new_bus)
+ 		return -ENOMEM;
+ 
+ 	new_bus->name = "r8169";
+ 	new_bus->priv = tp;
+ 	new_bus->parent = &pdev->dev;
+ 	new_bus->irq[0] = PHY_IGNORE_INTERRUPT;
+ 	snprintf(new_bus->id, MII_BUS_ID_SIZE, "r8169-%x",
+ 		 PCI_DEVID(pdev->bus->number, pdev->devfn));
+ 
+ 	new_bus->read = r8169_mdio_read_reg;
+ 	new_bus->write = r8169_mdio_write_reg;
+ 
+ 	ret = mdiobus_register(new_bus);
+ 	if (ret)
+ 		return ret;
+ 
+ 	tp->phydev = mdiobus_get_phy(new_bus, 0);
+ 	if (!tp->phydev) {
+ 		mdiobus_unregister(new_bus);
+ 		return -ENODEV;
+ 	}
+ 
+ 	/* PHY will be woken up in rtl_open() */
+ 	phy_suspend(tp->phydev);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  static void rtl_hw_init_8168g(struct rtl8169_private *tp)
  {
  	u32 data;
@@@ -7545,6 -7389,10 +7736,13 @@@ static int rtl_init_one(struct pci_dev 
  		pm_runtime_put_sync(&pdev->dev);
  
  	return 0;
++<<<<<<< HEAD
++=======
+ 
+ err_mdio_unregister:
+ 	mdiobus_unregister(tp->phydev->mdio.bus);
+ 	return rc;
++>>>>>>> 703732f0058b (r8169: replace mii_bus member with phy_device member in struct rtl8169_private)
  }
  
  static struct pci_driver rtl8169_pci_driver = {
* Unmerged path drivers/net/ethernet/realtek/r8169.c
