net/mlx5e: Added 'raw_errors_laneX' fields to ethtool statistics

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Added 'raw_errors_laneX' fields to ethtool statistics (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 96.77%
commit-author Shay Agroskin <shayag@mellanox.com>
commit 4cb4e98e5bba6dce058582d78cc993fef6f0755a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4cb4e98e.failed

These are counters for errors received on rx side, such as
FEC errors.

	Signed-off-by: Shay Agroskin <shayag@mellanox.com>
	Reviewed-by: Eran Ben Elisha <eranbe@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 4cb4e98e5bba6dce058582d78cc993fef6f0755a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_stats.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_stats.c
index 525df44c9b3c,1e55b9c27ffc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_stats.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_stats.c
@@@ -569,35 -614,82 +569,106 @@@ static const struct counter_desc pport_
  	{ "rx_corrected_bits_phy", PPORT_PHY_STATISTICAL_OFF(phy_corrected_bits) },
  };
  
++<<<<<<< HEAD
 +#define NUM_PPORT_PHY_COUNTERS		ARRAY_SIZE(pport_phy_statistical_stats_desc)
 +
 +static int mlx5e_grp_phy_get_num_stats(struct mlx5e_priv *priv)
 +{
 +	return MLX5_CAP_PCAM_FEATURE((priv)->mdev, ppcnt_statistical_group) ?
 +		NUM_PPORT_PHY_COUNTERS : 0;
++=======
+ static const struct counter_desc
+ pport_phy_statistical_err_lanes_stats_desc[] = {
+ 	{ "rx_err_lane_0_phy", PPORT_PHY_STATISTICAL_OFF(phy_corrected_bits_lane0) },
+ 	{ "rx_err_lane_1_phy", PPORT_PHY_STATISTICAL_OFF(phy_corrected_bits_lane1) },
+ 	{ "rx_err_lane_2_phy", PPORT_PHY_STATISTICAL_OFF(phy_corrected_bits_lane2) },
+ 	{ "rx_err_lane_3_phy", PPORT_PHY_STATISTICAL_OFF(phy_corrected_bits_lane3) },
+ };
+ 
+ #define NUM_PPORT_PHY_STATISTICAL_COUNTERS \
+ 	ARRAY_SIZE(pport_phy_statistical_stats_desc)
+ #define NUM_PPORT_PHY_STATISTICAL_PER_LANE_COUNTERS \
+ 	ARRAY_SIZE(pport_phy_statistical_err_lanes_stats_desc)
+ 
+ static int mlx5e_grp_phy_get_num_stats(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	int num_stats;
+ 
+ 	/* "1" for link_down_events special counter */
+ 	num_stats = 1;
+ 
+ 	num_stats += MLX5_CAP_PCAM_FEATURE(mdev, ppcnt_statistical_group) ?
+ 		     NUM_PPORT_PHY_STATISTICAL_COUNTERS : 0;
+ 
+ 	num_stats += MLX5_CAP_PCAM_FEATURE(mdev, per_lane_error_counters) ?
+ 		     NUM_PPORT_PHY_STATISTICAL_PER_LANE_COUNTERS : 0;
+ 
+ 	return num_stats;
++>>>>>>> 4cb4e98e5bba (net/mlx5e: Added 'raw_errors_laneX' fields to ethtool statistics)
  }
  
  static int mlx5e_grp_phy_fill_strings(struct mlx5e_priv *priv, u8 *data,
  				      int idx)
  {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
  	int i;
  
++<<<<<<< HEAD
 +	if (MLX5_CAP_PCAM_FEATURE((priv)->mdev, ppcnt_statistical_group))
 +		for (i = 0; i < NUM_PPORT_PHY_COUNTERS; i++)
 +			strcpy(data + (idx++) * ETH_GSTRING_LEN,
 +			       pport_phy_statistical_stats_desc[i].format);
++=======
+ 	strcpy(data + (idx++) * ETH_GSTRING_LEN, "link_down_events_phy");
+ 
+ 	if (!MLX5_CAP_PCAM_FEATURE(mdev, ppcnt_statistical_group))
+ 		return idx;
+ 
+ 	for (i = 0; i < NUM_PPORT_PHY_STATISTICAL_COUNTERS; i++)
+ 		strcpy(data + (idx++) * ETH_GSTRING_LEN,
+ 		       pport_phy_statistical_stats_desc[i].format);
+ 
+ 	if (MLX5_CAP_PCAM_FEATURE(mdev, per_lane_error_counters))
+ 		for (i = 0; i < NUM_PPORT_PHY_STATISTICAL_PER_LANE_COUNTERS; i++)
+ 			strcpy(data + (idx++) * ETH_GSTRING_LEN,
+ 			       pport_phy_statistical_err_lanes_stats_desc[i].format);
+ 
++>>>>>>> 4cb4e98e5bba (net/mlx5e: Added 'raw_errors_laneX' fields to ethtool statistics)
  	return idx;
  }
  
  static int mlx5e_grp_phy_fill_stats(struct mlx5e_priv *priv, u64 *data, int idx)
  {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
  	int i;
  
++<<<<<<< HEAD
 +	if (MLX5_CAP_PCAM_FEATURE((priv)->mdev, ppcnt_statistical_group))
 +		for (i = 0; i < NUM_PPORT_PHY_COUNTERS; i++)
 +			data[idx++] =
 +				MLX5E_READ_CTR64_BE(&priv->stats.pport.phy_statistical_counters,
 +						    pport_phy_statistical_stats_desc, i);
++=======
+ 	/* link_down_events_phy has special handling since it is not stored in __be64 format */
+ 	data[idx++] = MLX5_GET(ppcnt_reg, priv->stats.pport.phy_counters,
+ 			       counter_set.phys_layer_cntrs.link_down_events);
+ 
+ 	if (!MLX5_CAP_PCAM_FEATURE(mdev, ppcnt_statistical_group))
+ 		return idx;
+ 
+ 	for (i = 0; i < NUM_PPORT_PHY_STATISTICAL_COUNTERS; i++)
+ 		data[idx++] =
+ 			MLX5E_READ_CTR64_BE(&priv->stats.pport.phy_statistical_counters,
+ 					    pport_phy_statistical_stats_desc, i);
+ 
+ 	if (MLX5_CAP_PCAM_FEATURE(mdev, per_lane_error_counters))
+ 		for (i = 0; i < NUM_PPORT_PHY_STATISTICAL_PER_LANE_COUNTERS; i++)
+ 			data[idx++] =
+ 				MLX5E_READ_CTR64_BE(&priv->stats.pport.phy_statistical_counters,
+ 						    pport_phy_statistical_err_lanes_stats_desc,
+ 						    i);
++>>>>>>> 4cb4e98e5bba (net/mlx5e: Added 'raw_errors_laneX' fields to ethtool statistics)
  	return idx;
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_stats.c
