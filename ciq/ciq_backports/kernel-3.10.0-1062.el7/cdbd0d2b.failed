net/mlx5: Mkey creation command adjustments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [infiniband] mlx5: Mkey creation command adjustments (Alaa Hleihel) [1641349 1642498]
Rebuild_FUZZ: 95.12%
commit-author Ariel Levkovich <lariel@mellanox.com>
commit cdbd0d2bae14566cf875595180b91527b4431df8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/cdbd0d2b.failed

This change updates the mlx5 interface to create mkey
on the device.

The updates in the command mailbox include increasing the
access mode type field to 5 bits in order to support additional
types such as MLX5_MKC_ACCESS_MODE_MEMIC which represents device
memory access type and will be used when registering MR on allocated
device memory.

All the places that use the old access mode format are adjusted as
well.

	Signed-off-by: Ariel Levkovich <lariel@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit cdbd0d2bae14566cf875595180b91527b4431df8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/cmd.c
diff --cc drivers/infiniband/hw/mlx5/cmd.c
index 6f6712f87a73,188512bf46e6..000000000000
--- a/drivers/infiniband/hw/mlx5/cmd.c
+++ b/drivers/infiniband/hw/mlx5/cmd.c
@@@ -66,3 -66,107 +66,110 @@@ int mlx5_cmd_modify_cong_params(struct 
  
  	return mlx5_cmd_exec(dev, in, in_size, out, sizeof(out));
  }
++<<<<<<< HEAD
++=======
+ 
+ int mlx5_cmd_alloc_memic(struct mlx5_memic *memic, phys_addr_t *addr,
+ 			  u64 length, u32 alignment)
+ {
+ 	struct mlx5_core_dev *dev = memic->dev;
+ 	u64 num_memic_hw_pages = MLX5_CAP_DEV_MEM(dev, memic_bar_size)
+ 					>> PAGE_SHIFT;
+ 	u64 hw_start_addr = MLX5_CAP64_DEV_MEM(dev, memic_bar_start_addr);
+ 	u32 max_alignment = MLX5_CAP_DEV_MEM(dev, log_max_memic_addr_alignment);
+ 	u32 num_pages = DIV_ROUND_UP(length, PAGE_SIZE);
+ 	u32 out[MLX5_ST_SZ_DW(alloc_memic_out)] = {};
+ 	u32 in[MLX5_ST_SZ_DW(alloc_memic_in)] = {};
+ 	u32 mlx5_alignment;
+ 	u64 page_idx = 0;
+ 	int ret = 0;
+ 
+ 	if (!length || (length & MLX5_MEMIC_ALLOC_SIZE_MASK))
+ 		return -EINVAL;
+ 
+ 	/* mlx5 device sets alignment as 64*2^driver_value
+ 	 * so normalizing is needed.
+ 	 */
+ 	mlx5_alignment = (alignment < MLX5_MEMIC_BASE_ALIGN) ? 0 :
+ 			 alignment - MLX5_MEMIC_BASE_ALIGN;
+ 	if (mlx5_alignment > max_alignment)
+ 		return -EINVAL;
+ 
+ 	MLX5_SET(alloc_memic_in, in, opcode, MLX5_CMD_OP_ALLOC_MEMIC);
+ 	MLX5_SET(alloc_memic_in, in, range_size, num_pages * PAGE_SIZE);
+ 	MLX5_SET(alloc_memic_in, in, memic_size, length);
+ 	MLX5_SET(alloc_memic_in, in, log_memic_addr_alignment,
+ 		 mlx5_alignment);
+ 
+ 	while (page_idx < num_memic_hw_pages) {
+ 		spin_lock(&memic->memic_lock);
+ 		page_idx = bitmap_find_next_zero_area(memic->memic_alloc_pages,
+ 						      num_memic_hw_pages,
+ 						      page_idx,
+ 						      num_pages, 0);
+ 
+ 		if (page_idx < num_memic_hw_pages)
+ 			bitmap_set(memic->memic_alloc_pages,
+ 				   page_idx, num_pages);
+ 
+ 		spin_unlock(&memic->memic_lock);
+ 
+ 		if (page_idx >= num_memic_hw_pages)
+ 			break;
+ 
+ 		MLX5_SET64(alloc_memic_in, in, range_start_addr,
+ 			   hw_start_addr + (page_idx * PAGE_SIZE));
+ 
+ 		ret = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
+ 		if (ret) {
+ 			spin_lock(&memic->memic_lock);
+ 			bitmap_clear(memic->memic_alloc_pages,
+ 				     page_idx, num_pages);
+ 			spin_unlock(&memic->memic_lock);
+ 
+ 			if (ret == -EAGAIN) {
+ 				page_idx++;
+ 				continue;
+ 			}
+ 
+ 			return ret;
+ 		}
+ 
+ 		*addr = pci_resource_start(dev->pdev, 0) +
+ 			MLX5_GET64(alloc_memic_out, out, memic_start_addr);
+ 
+ 		return 0;
+ 	}
+ 
+ 	return -ENOMEM;
+ }
+ 
+ int mlx5_cmd_dealloc_memic(struct mlx5_memic *memic, u64 addr, u64 length)
+ {
+ 	struct mlx5_core_dev *dev = memic->dev;
+ 	u64 hw_start_addr = MLX5_CAP64_DEV_MEM(dev, memic_bar_start_addr);
+ 	u32 num_pages = DIV_ROUND_UP(length, PAGE_SIZE);
+ 	u32 out[MLX5_ST_SZ_DW(dealloc_memic_out)] = {0};
+ 	u32 in[MLX5_ST_SZ_DW(dealloc_memic_in)] = {0};
+ 	u64 start_page_idx;
+ 	int err;
+ 
+ 	addr -= pci_resource_start(dev->pdev, 0);
+ 	start_page_idx = (addr - hw_start_addr) >> PAGE_SHIFT;
+ 
+ 	MLX5_SET(dealloc_memic_in, in, opcode, MLX5_CMD_OP_DEALLOC_MEMIC);
+ 	MLX5_SET64(dealloc_memic_in, in, memic_start_addr, addr);
+ 	MLX5_SET(dealloc_memic_in, in, memic_size, length);
+ 
+ 	err =  mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
+ 
+ 	if (!err) {
+ 		spin_lock(&memic->memic_lock);
+ 		bitmap_clear(memic->memic_alloc_pages,
+ 			     start_page_idx, num_pages);
+ 		spin_unlock(&memic->memic_lock);
+ 	}
+ 
+ 	return err;
+ }
++>>>>>>> cdbd0d2bae14 (net/mlx5: Mkey creation command adjustments)
* Unmerged path drivers/infiniband/hw/mlx5/cmd.c
diff --git a/drivers/infiniband/hw/mlx5/mr.c b/drivers/infiniband/hw/mlx5/mr.c
index e6f0b2f89fc3..9d8b147dabbf 100644
--- a/drivers/infiniband/hw/mlx5/mr.c
+++ b/drivers/infiniband/hw/mlx5/mr.c
@@ -204,7 +204,9 @@ static int add_keys(struct mlx5_ib_dev *dev, int c, int num)
 
 		MLX5_SET(mkc, mkc, free, 1);
 		MLX5_SET(mkc, mkc, umr_en, 1);
-		MLX5_SET(mkc, mkc, access_mode, ent->access_mode);
+		MLX5_SET(mkc, mkc, access_mode_1_0, ent->access_mode & 0x3);
+		MLX5_SET(mkc, mkc, access_mode_4_2,
+			 (ent->access_mode >> 2) & 0x7);
 
 		MLX5_SET(mkc, mkc, qpn, 0xffffff);
 		MLX5_SET(mkc, mkc, translations_octword_size, ent->xlt);
@@ -807,7 +809,7 @@ struct ib_mr *mlx5_ib_get_dma_mr(struct ib_pd *pd, int acc)
 
 	mkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);
 
-	MLX5_SET(mkc, mkc, access_mode, MLX5_MKC_ACCESS_MODE_PA);
+	MLX5_SET(mkc, mkc, access_mode_1_0, MLX5_MKC_ACCESS_MODE_PA);
 	MLX5_SET(mkc, mkc, a, !!(acc & IB_ACCESS_REMOTE_ATOMIC));
 	MLX5_SET(mkc, mkc, rw, !!(acc & IB_ACCESS_REMOTE_WRITE));
 	MLX5_SET(mkc, mkc, rr, !!(acc & IB_ACCESS_REMOTE_READ));
@@ -1174,7 +1176,7 @@ static struct mlx5_ib_mr *reg_create(struct ib_mr *ibmr, struct ib_pd *pd,
 
 	mkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);
 	MLX5_SET(mkc, mkc, free, !populate);
-	MLX5_SET(mkc, mkc, access_mode, MLX5_MKC_ACCESS_MODE_MTT);
+	MLX5_SET(mkc, mkc, access_mode_1_0, MLX5_MKC_ACCESS_MODE_MTT);
 	MLX5_SET(mkc, mkc, a, !!(access_flags & IB_ACCESS_REMOTE_ATOMIC));
 	MLX5_SET(mkc, mkc, rw, !!(access_flags & IB_ACCESS_REMOTE_WRITE));
 	MLX5_SET(mkc, mkc, rr, !!(access_flags & IB_ACCESS_REMOTE_READ));
@@ -1672,7 +1674,8 @@ struct ib_mr *mlx5_ib_alloc_mr(struct ib_pd *pd,
 		goto err_free_in;
 	}
 
-	MLX5_SET(mkc, mkc, access_mode, mr->access_mode);
+	MLX5_SET(mkc, mkc, access_mode_1_0, mr->access_mode & 0x3);
+	MLX5_SET(mkc, mkc, access_mode_4_2, (mr->access_mode >> 2) & 0x7);
 	MLX5_SET(mkc, mkc, umr_en, 1);
 
 	mr->ibmr.device = pd->device;
@@ -1753,7 +1756,7 @@ struct ib_mw *mlx5_ib_alloc_mw(struct ib_pd *pd, enum ib_mw_type type,
 	MLX5_SET(mkc, mkc, pd, to_mpd(pd)->pdn);
 	MLX5_SET(mkc, mkc, umr_en, 1);
 	MLX5_SET(mkc, mkc, lr, 1);
-	MLX5_SET(mkc, mkc, access_mode, MLX5_MKC_ACCESS_MODE_KLMS);
+	MLX5_SET(mkc, mkc, access_mode_1_0, MLX5_MKC_ACCESS_MODE_KLMS);
 	MLX5_SET(mkc, mkc, en_rinval, !!((type == IB_MW_TYPE_2)));
 	MLX5_SET(mkc, mkc, qpn, 0xffffff);
 
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_common.c b/drivers/net/ethernet/mellanox/mlx5/core/en_common.c
index 784e282803db..db3278cc052b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_common.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_common.c
@@ -70,7 +70,7 @@ static int mlx5e_create_mkey(struct mlx5_core_dev *mdev, u32 pdn,
 		return -ENOMEM;
 
 	mkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);
-	MLX5_SET(mkc, mkc, access_mode, MLX5_MKC_ACCESS_MODE_PA);
+	MLX5_SET(mkc, mkc, access_mode_1_0, MLX5_MKC_ACCESS_MODE_PA);
 	MLX5_SET(mkc, mkc, lw, 1);
 	MLX5_SET(mkc, mkc, lr, 1);
 
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 257706f992fc..0905f7e2b93c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -371,7 +371,7 @@ static int mlx5e_create_umr_mkey(struct mlx5_core_dev *mdev,
 	MLX5_SET(mkc, mkc, umr_en, 1);
 	MLX5_SET(mkc, mkc, lw, 1);
 	MLX5_SET(mkc, mkc, lr, 1);
-	MLX5_SET(mkc, mkc, access_mode, MLX5_MKC_ACCESS_MODE_MTT);
+	MLX5_SET(mkc, mkc, access_mode_1_0, MLX5_MKC_ACCESS_MODE_MTT);
 
 	MLX5_SET(mkc, mkc, qpn, 0xffffff);
 	MLX5_SET(mkc, mkc, pd, mdev->mlx5e_res.pdn);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c b/drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c
index e6175f8ac0e4..de7fe087d6fe 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fpga/conn.c
@@ -232,7 +232,7 @@ static int mlx5_fpga_conn_create_mkey(struct mlx5_core_dev *mdev, u32 pdn,
 		return -ENOMEM;
 
 	mkc = MLX5_ADDR_OF(create_mkey_in, in, memory_key_mkey_entry);
-	MLX5_SET(mkc, mkc, access_mode, MLX5_MKC_ACCESS_MODE_PA);
+	MLX5_SET(mkc, mkc, access_mode_1_0, MLX5_MKC_ACCESS_MODE_PA);
 	MLX5_SET(mkc, mkc, lw, 1);
 	MLX5_SET(mkc, mkc, lr, 1);
 
diff --git a/include/linux/mlx5/mlx5_ifc.h b/include/linux/mlx5/mlx5_ifc.h
index 4a01909336e7..0b1981c6da89 100644
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@ -2753,12 +2753,17 @@ enum {
 	MLX5_MKC_ACCESS_MODE_MTT   = 0x1,
 	MLX5_MKC_ACCESS_MODE_KLMS  = 0x2,
 	MLX5_MKC_ACCESS_MODE_KSM   = 0x3,
+	MLX5_MKC_ACCESS_MODE_MEMIC = 0x5,
 };
 
 struct mlx5_ifc_mkc_bits {
 	u8         reserved_at_0[0x1];
 	u8         free[0x1];
-	u8         reserved_at_2[0xd];
+	u8         reserved_at_2[0x1];
+	u8         access_mode_4_2[0x3];
+	u8         reserved_at_6[0x7];
+	u8         relaxed_ordering_write[0x1];
+	u8         reserved_at_e[0x1];
 	u8         small_fence_on_rdma_read_response[0x1];
 	u8         umr_en[0x1];
 	u8         a[0x1];
@@ -2766,7 +2771,7 @@ struct mlx5_ifc_mkc_bits {
 	u8         rr[0x1];
 	u8         lw[0x1];
 	u8         lr[0x1];
-	u8         access_mode[0x2];
+	u8         access_mode_1_0[0x2];
 	u8         reserved_at_18[0x8];
 
 	u8         qpn[0x18];
