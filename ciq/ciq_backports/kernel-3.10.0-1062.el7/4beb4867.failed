scsi: mpt3sas: Improve kernel-doc headers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] mpt3sas: Improve kernel-doc headers (Tomas Henzl) [1642370]
Rebuild_FUZZ: 92.11%
commit-author Bart Van Assche <bart.vanassche@wdc.com>
commit 4beb4867f049aea801a93a8fc97801250e32d700
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4beb4867.failed

Avoids that warnings about the kernel headers appear when building with
W=1. Remove useless "@Returns - Nothing" clauses. Change "@Return - " into
"Return: ".

	Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
	Cc: Sathya Prakash <sathya.prakash@broadcom.com>
	Cc: Chaitra P B <chaitra.basappa@broadcom.com>
	Cc: Suganath Prabu Subramani <suganath-prabu.subramani@broadcom.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 4beb4867f049aea801a93a8fc97801250e32d700)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt3sas/mpt3sas_base.c
#	drivers/scsi/mpt3sas/mpt3sas_ctl.c
#	drivers/scsi/mpt3sas/mpt3sas_scsih.c
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.c
index 80f2689dcb34,2053970fc9f8..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@@ -130,10 -131,13 +130,13 @@@ mpt3sas_base_check_cmd_timeout(struct M
  
  /**
   * _scsih_set_fwfault_debug - global setting of ioc->fwfault_debug.
+  * @val: ?
+  * @kp: ?
   *
+  * Return: ?
   */
  static int
 -_scsih_set_fwfault_debug(const char *val, const struct kernel_param *kp)
 +_scsih_set_fwfault_debug(const char *val, struct kernel_param *kp)
  {
  	int ret = param_set_int(val, kp);
  	struct MPT3SAS_ADAPTER *ioc;
@@@ -153,6 -157,68 +156,71 @@@ module_param_call(mpt3sas_fwfault_debug
  	param_get_int, &mpt3sas_fwfault_debug, 0644);
  
  /**
++<<<<<<< HEAD
++=======
+  * _base_clone_reply_to_sys_mem - copies reply to reply free iomem
+  *				  in BAR0 space.
+  *
+  * @ioc: per adapter object
+  * @reply: reply message frame(lower 32bit addr)
+  * @index: System request message index.
+  */
+ static void
+ _base_clone_reply_to_sys_mem(struct MPT3SAS_ADAPTER *ioc, u32 reply,
+ 		u32 index)
+ {
+ 	/*
+ 	 * 256 is offset within sys register.
+ 	 * 256 offset MPI frame starts. Max MPI frame supported is 32.
+ 	 * 32 * 128 = 4K. From here, Clone of reply free for mcpu starts
+ 	 */
+ 	u16 cmd_credit = ioc->facts.RequestCredit + 1;
+ 	void __iomem *reply_free_iomem = (void __iomem *)ioc->chip +
+ 			MPI_FRAME_START_OFFSET +
+ 			(cmd_credit * ioc->request_sz) + (index * sizeof(u32));
+ 
+ 	writel(reply, reply_free_iomem);
+ }
+ 
+ /**
+  * _base_clone_mpi_to_sys_mem - Writes/copies MPI frames
+  *				to system/BAR0 region.
+  *
+  * @dst_iomem: Pointer to the destination location in BAR0 space.
+  * @src: Pointer to the Source data.
+  * @size: Size of data to be copied.
+  */
+ static void
+ _base_clone_mpi_to_sys_mem(void *dst_iomem, void *src, u32 size)
+ {
+ 	int i;
+ 	u32 *src_virt_mem = (u32 *)src;
+ 
+ 	for (i = 0; i < size/4; i++)
+ 		writel((u32)src_virt_mem[i],
+ 				(void __iomem *)dst_iomem + (i * 4));
+ }
+ 
+ /**
+  * _base_clone_to_sys_mem - Writes/copies data to system/BAR0 region
+  *
+  * @dst_iomem: Pointer to the destination location in BAR0 space.
+  * @src: Pointer to the Source data.
+  * @size: Size of data to be copied.
+  */
+ static void
+ _base_clone_to_sys_mem(void __iomem *dst_iomem, void *src, u32 size)
+ {
+ 	int i;
+ 	u32 *src_virt_mem = (u32 *)(src);
+ 
+ 	for (i = 0; i < size/4; i++)
+ 		writel((u32)src_virt_mem[i],
+ 			(void __iomem *)dst_iomem + (i * 4));
+ }
+ 
+ /**
++>>>>>>> 4beb4867f049 (scsi: mpt3sas: Improve kernel-doc headers)
   * _base_get_chain - Calculates and Returns virtual chain address
   *			 for the provided smid in BAR0 space.
   *
@@@ -186,9 -252,9 +254,9 @@@ _base_get_chain(struct MPT3SAS_ADAPTER 
   * @smid: system request message index
   * @sge_chain_count: Scatter gather chain count.
   *
-  * @Return - Physical chain address.
+  * Return: Physical chain address.
   */
 -static inline phys_addr_t
 +static inline void *
  _base_get_chain_phys(struct MPT3SAS_ADAPTER *ioc, u16 smid,
  		u8 sge_chain_count)
  {
@@@ -233,9 -299,9 +301,9 @@@ _base_get_buffer_bar0(struct MPT3SAS_AD
   * @ioc: per adapter object
   * @smid: system request message index
   *
-  * @Returns - Pointer to buffer location in BAR0.
+  * Return: Pointer to buffer location in BAR0.
   */
 -static phys_addr_t
 +static void *
  _base_get_buffer_phys_bar0(struct MPT3SAS_ADAPTER *ioc, u16 smid)
  {
  	u16 cmd_credit = ioc->facts.RequestCredit + 1;
@@@ -246,6 -312,214 +314,217 @@@
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * _base_get_chain_buffer_dma_to_chain_buffer - Iterates chain
+  *			lookup list and Provides chain_buffer
+  *			address for the matching dma address.
+  *			(Each smid can have 64K starts from 17024)
+  *
+  * @ioc: per adapter object
+  * @chain_buffer_dma: Chain buffer dma address.
+  *
+  * Return: Pointer to chain buffer. Or Null on Failure.
+  */
+ static void *
+ _base_get_chain_buffer_dma_to_chain_buffer(struct MPT3SAS_ADAPTER *ioc,
+ 		dma_addr_t chain_buffer_dma)
+ {
+ 	u16 index, j;
+ 	struct chain_tracker *ct;
+ 
+ 	for (index = 0; index < ioc->scsiio_depth; index++) {
+ 		for (j = 0; j < ioc->chains_needed_per_io; j++) {
+ 			ct = &ioc->chain_lookup[index].chains_per_smid[j];
+ 			if (ct && ct->chain_buffer_dma == chain_buffer_dma)
+ 				return ct->chain_buffer;
+ 		}
+ 	}
+ 	pr_info(MPT3SAS_FMT
+ 	    "Provided chain_buffer_dma address is not in the lookup list\n",
+ 	    ioc->name);
+ 	return NULL;
+ }
+ 
+ /**
+  * _clone_sg_entries -	MPI EP's scsiio and config requests
+  *			are handled here. Base function for
+  *			double buffering, before submitting
+  *			the requests.
+  *
+  * @ioc: per adapter object.
+  * @mpi_request: mf request pointer.
+  * @smid: system request message index.
+  */
+ static void _clone_sg_entries(struct MPT3SAS_ADAPTER *ioc,
+ 		void *mpi_request, u16 smid)
+ {
+ 	Mpi2SGESimple32_t *sgel, *sgel_next;
+ 	u32  sgl_flags, sge_chain_count = 0;
+ 	bool is_write = 0;
+ 	u16 i = 0;
+ 	void __iomem *buffer_iomem;
+ 	phys_addr_t buffer_iomem_phys;
+ 	void __iomem *buff_ptr;
+ 	phys_addr_t buff_ptr_phys;
+ 	void __iomem *dst_chain_addr[MCPU_MAX_CHAINS_PER_IO];
+ 	void *src_chain_addr[MCPU_MAX_CHAINS_PER_IO];
+ 	phys_addr_t dst_addr_phys;
+ 	MPI2RequestHeader_t *request_hdr;
+ 	struct scsi_cmnd *scmd;
+ 	struct scatterlist *sg_scmd = NULL;
+ 	int is_scsiio_req = 0;
+ 
+ 	request_hdr = (MPI2RequestHeader_t *) mpi_request;
+ 
+ 	if (request_hdr->Function == MPI2_FUNCTION_SCSI_IO_REQUEST) {
+ 		Mpi25SCSIIORequest_t *scsiio_request =
+ 			(Mpi25SCSIIORequest_t *)mpi_request;
+ 		sgel = (Mpi2SGESimple32_t *) &scsiio_request->SGL;
+ 		is_scsiio_req = 1;
+ 	} else if (request_hdr->Function == MPI2_FUNCTION_CONFIG) {
+ 		Mpi2ConfigRequest_t  *config_req =
+ 			(Mpi2ConfigRequest_t *)mpi_request;
+ 		sgel = (Mpi2SGESimple32_t *) &config_req->PageBufferSGE;
+ 	} else
+ 		return;
+ 
+ 	/* From smid we can get scsi_cmd, once we have sg_scmd,
+ 	 * we just need to get sg_virt and sg_next to get virual
+ 	 * address associated with sgel->Address.
+ 	 */
+ 
+ 	if (is_scsiio_req) {
+ 		/* Get scsi_cmd using smid */
+ 		scmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);
+ 		if (scmd == NULL) {
+ 			pr_err(MPT3SAS_FMT "scmd is NULL\n", ioc->name);
+ 			return;
+ 		}
+ 
+ 		/* Get sg_scmd from scmd provided */
+ 		sg_scmd = scsi_sglist(scmd);
+ 	}
+ 
+ 	/*
+ 	 * 0 - 255	System register
+ 	 * 256 - 4352	MPI Frame. (This is based on maxCredit 32)
+ 	 * 4352 - 4864	Reply_free pool (512 byte is reserved
+ 	 *		considering maxCredit 32. Reply need extra
+ 	 *		room, for mCPU case kept four times of
+ 	 *		maxCredit).
+ 	 * 4864 - 17152	SGE chain element. (32cmd * 3 chain of
+ 	 *		128 byte size = 12288)
+ 	 * 17152 - x	Host buffer mapped with smid.
+ 	 *		(Each smid can have 64K Max IO.)
+ 	 * BAR0+Last 1K MSIX Addr and Data
+ 	 * Total size in use 2113664 bytes of 4MB BAR0
+ 	 */
+ 
+ 	buffer_iomem = _base_get_buffer_bar0(ioc, smid);
+ 	buffer_iomem_phys = _base_get_buffer_phys_bar0(ioc, smid);
+ 
+ 	buff_ptr = buffer_iomem;
+ 	buff_ptr_phys = buffer_iomem_phys;
+ 	WARN_ON(buff_ptr_phys > U32_MAX);
+ 
+ 	if (le32_to_cpu(sgel->FlagsLength) &
+ 			(MPI2_SGE_FLAGS_HOST_TO_IOC << MPI2_SGE_FLAGS_SHIFT))
+ 		is_write = 1;
+ 
+ 	for (i = 0; i < MPT_MIN_PHYS_SEGMENTS + ioc->facts.MaxChainDepth; i++) {
+ 
+ 		sgl_flags =
+ 		    (le32_to_cpu(sgel->FlagsLength) >> MPI2_SGE_FLAGS_SHIFT);
+ 
+ 		switch (sgl_flags & MPI2_SGE_FLAGS_ELEMENT_MASK) {
+ 		case MPI2_SGE_FLAGS_CHAIN_ELEMENT:
+ 			/*
+ 			 * Helper function which on passing
+ 			 * chain_buffer_dma returns chain_buffer. Get
+ 			 * the virtual address for sgel->Address
+ 			 */
+ 			sgel_next =
+ 				_base_get_chain_buffer_dma_to_chain_buffer(ioc,
+ 						le32_to_cpu(sgel->Address));
+ 			if (sgel_next == NULL)
+ 				return;
+ 			/*
+ 			 * This is coping 128 byte chain
+ 			 * frame (not a host buffer)
+ 			 */
+ 			dst_chain_addr[sge_chain_count] =
+ 				_base_get_chain(ioc,
+ 					smid, sge_chain_count);
+ 			src_chain_addr[sge_chain_count] =
+ 						(void *) sgel_next;
+ 			dst_addr_phys = _base_get_chain_phys(ioc,
+ 						smid, sge_chain_count);
+ 			WARN_ON(dst_addr_phys > U32_MAX);
+ 			sgel->Address =
+ 				cpu_to_le32(lower_32_bits(dst_addr_phys));
+ 			sgel = sgel_next;
+ 			sge_chain_count++;
+ 			break;
+ 		case MPI2_SGE_FLAGS_SIMPLE_ELEMENT:
+ 			if (is_write) {
+ 				if (is_scsiio_req) {
+ 					_base_clone_to_sys_mem(buff_ptr,
+ 					    sg_virt(sg_scmd),
+ 					    (le32_to_cpu(sgel->FlagsLength) &
+ 					    0x00ffffff));
+ 					/*
+ 					 * FIXME: this relies on a a zero
+ 					 * PCI mem_offset.
+ 					 */
+ 					sgel->Address =
+ 					    cpu_to_le32((u32)buff_ptr_phys);
+ 				} else {
+ 					_base_clone_to_sys_mem(buff_ptr,
+ 					    ioc->config_vaddr,
+ 					    (le32_to_cpu(sgel->FlagsLength) &
+ 					    0x00ffffff));
+ 					sgel->Address =
+ 					    cpu_to_le32((u32)buff_ptr_phys);
+ 				}
+ 			}
+ 			buff_ptr += (le32_to_cpu(sgel->FlagsLength) &
+ 			    0x00ffffff);
+ 			buff_ptr_phys += (le32_to_cpu(sgel->FlagsLength) &
+ 			    0x00ffffff);
+ 			if ((le32_to_cpu(sgel->FlagsLength) &
+ 			    (MPI2_SGE_FLAGS_END_OF_BUFFER
+ 					<< MPI2_SGE_FLAGS_SHIFT)))
+ 				goto eob_clone_chain;
+ 			else {
+ 				/*
+ 				 * Every single element in MPT will have
+ 				 * associated sg_next. Better to sanity that
+ 				 * sg_next is not NULL, but it will be a bug
+ 				 * if it is null.
+ 				 */
+ 				if (is_scsiio_req) {
+ 					sg_scmd = sg_next(sg_scmd);
+ 					if (sg_scmd)
+ 						sgel++;
+ 					else
+ 						goto eob_clone_chain;
+ 				}
+ 			}
+ 			break;
+ 		}
+ 	}
+ 
+ eob_clone_chain:
+ 	for (i = 0; i < sge_chain_count; i++) {
+ 		if (is_scsiio_req)
+ 			_base_clone_to_sys_mem(dst_chain_addr[i],
+ 				src_chain_addr[i], ioc->request_sz);
+ 	}
+ }
+ 
+ /**
++>>>>>>> 4beb4867f049 (scsi: mpt3sas: Improve kernel-doc headers)
   *  mpt3sas_remove_dead_ioc_func - kthread context to remove dead ioc
   * @arg: input argument, used to derive ioc
   *
@@@ -1418,31 -1684,26 +1671,36 @@@ _base_add_sg_single_64(void *paddr, u3
  /**
   * _base_get_chain_buffer_tracker - obtain chain tracker
   * @ioc: per adapter object
 - * @scmd: SCSI commands of the IO request
 + * @smid: smid associated to an IO request
   *
++<<<<<<< HEAD
 + * Returns chain tracker(from ioc->free_chain_list)
++=======
+  * Return: chain tracker from chain_lookup table using key as
+  * smid and smid's chain_offset.
++>>>>>>> 4beb4867f049 (scsi: mpt3sas: Improve kernel-doc headers)
   */
  static struct chain_tracker *
 -_base_get_chain_buffer_tracker(struct MPT3SAS_ADAPTER *ioc,
 -			       struct scsi_cmnd *scmd)
 +_base_get_chain_buffer_tracker(struct MPT3SAS_ADAPTER *ioc, u16 smid)
  {
  	struct chain_tracker *chain_req;
 -	struct scsiio_tracker *st = scsi_cmd_priv(scmd);
 -	u16 smid = st->smid;
 -	u8 chain_offset =
 -	   atomic_read(&ioc->chain_lookup[smid - 1].chain_offset);
 +	struct scsiio_tracker *st;
 +	unsigned long flags;
  
 -	if (chain_offset == ioc->chains_needed_per_io)
 +	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
 +	if (list_empty(&ioc->free_chain_list)) {
 +		spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
 +		dfailprintk(ioc, pr_warn(MPT3SAS_FMT
 +			"chain buffers not available\n", ioc->name));
  		return NULL;
 -
 -	chain_req = &ioc->chain_lookup[smid - 1].chains_per_smid[chain_offset];
 -	atomic_inc(&ioc->chain_lookup[smid - 1].chain_offset);
 +	}
 +	chain_req = list_entry(ioc->free_chain_list.next,
 +	    struct chain_tracker, tracker_list);
 +	list_del_init(&chain_req->tracker_list);
 +	st = mpt3sas_get_st_from_smid(ioc, smid);
 +	if (st)
 +		list_add_tail(&chain_req->tracker_list, &st->chain_list);
 +	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
  	return chain_req;
  }
  
@@@ -1508,6 -1767,422 +1764,425 @@@ _base_build_sg(struct MPT3SAS_ADAPTER *
  /* IEEE format sgls */
  
  /**
++<<<<<<< HEAD
++=======
+  * _base_build_nvme_prp - This function is called for NVMe end devices to build
+  * a native SGL (NVMe PRP). The native SGL is built starting in the first PRP
+  * entry of the NVMe message (PRP1).  If the data buffer is small enough to be
+  * described entirely using PRP1, then PRP2 is not used.  If needed, PRP2 is
+  * used to describe a larger data buffer.  If the data buffer is too large to
+  * describe using the two PRP entriess inside the NVMe message, then PRP1
+  * describes the first data memory segment, and PRP2 contains a pointer to a PRP
+  * list located elsewhere in memory to describe the remaining data memory
+  * segments.  The PRP list will be contiguous.
+  *
+  * The native SGL for NVMe devices is a Physical Region Page (PRP).  A PRP
+  * consists of a list of PRP entries to describe a number of noncontigous
+  * physical memory segments as a single memory buffer, just as a SGL does.  Note
+  * however, that this function is only used by the IOCTL call, so the memory
+  * given will be guaranteed to be contiguous.  There is no need to translate
+  * non-contiguous SGL into a PRP in this case.  All PRPs will describe
+  * contiguous space that is one page size each.
+  *
+  * Each NVMe message contains two PRP entries.  The first (PRP1) either contains
+  * a PRP list pointer or a PRP element, depending upon the command.  PRP2
+  * contains the second PRP element if the memory being described fits within 2
+  * PRP entries, or a PRP list pointer if the PRP spans more than two entries.
+  *
+  * A PRP list pointer contains the address of a PRP list, structured as a linear
+  * array of PRP entries.  Each PRP entry in this list describes a segment of
+  * physical memory.
+  *
+  * Each 64-bit PRP entry comprises an address and an offset field.  The address
+  * always points at the beginning of a 4KB physical memory page, and the offset
+  * describes where within that 4KB page the memory segment begins.  Only the
+  * first element in a PRP list may contain a non-zero offest, implying that all
+  * memory segments following the first begin at the start of a 4KB page.
+  *
+  * Each PRP element normally describes 4KB of physical memory, with exceptions
+  * for the first and last elements in the list.  If the memory being described
+  * by the list begins at a non-zero offset within the first 4KB page, then the
+  * first PRP element will contain a non-zero offset indicating where the region
+  * begins within the 4KB page.  The last memory segment may end before the end
+  * of the 4KB segment, depending upon the overall size of the memory being
+  * described by the PRP list.
+  *
+  * Since PRP entries lack any indication of size, the overall data buffer length
+  * is used to determine where the end of the data memory buffer is located, and
+  * how many PRP entries are required to describe it.
+  *
+  * @ioc: per adapter object
+  * @smid: system request message index for getting asscociated SGL
+  * @nvme_encap_request: the NVMe request msg frame pointer
+  * @data_out_dma: physical address for WRITES
+  * @data_out_sz: data xfer size for WRITES
+  * @data_in_dma: physical address for READS
+  * @data_in_sz: data xfer size for READS
+  */
+ static void
+ _base_build_nvme_prp(struct MPT3SAS_ADAPTER *ioc, u16 smid,
+ 	Mpi26NVMeEncapsulatedRequest_t *nvme_encap_request,
+ 	dma_addr_t data_out_dma, size_t data_out_sz, dma_addr_t data_in_dma,
+ 	size_t data_in_sz)
+ {
+ 	int		prp_size = NVME_PRP_SIZE;
+ 	__le64		*prp_entry, *prp1_entry, *prp2_entry;
+ 	__le64		*prp_page;
+ 	dma_addr_t	prp_entry_dma, prp_page_dma, dma_addr;
+ 	u32		offset, entry_len;
+ 	u32		page_mask_result, page_mask;
+ 	size_t		length;
+ 	struct mpt3sas_nvme_cmd *nvme_cmd =
+ 		(void *)nvme_encap_request->NVMe_Command;
+ 
+ 	/*
+ 	 * Not all commands require a data transfer. If no data, just return
+ 	 * without constructing any PRP.
+ 	 */
+ 	if (!data_in_sz && !data_out_sz)
+ 		return;
+ 	prp1_entry = &nvme_cmd->prp1;
+ 	prp2_entry = &nvme_cmd->prp2;
+ 	prp_entry = prp1_entry;
+ 	/*
+ 	 * For the PRP entries, use the specially allocated buffer of
+ 	 * contiguous memory.
+ 	 */
+ 	prp_page = (__le64 *)mpt3sas_base_get_pcie_sgl(ioc, smid);
+ 	prp_page_dma = mpt3sas_base_get_pcie_sgl_dma(ioc, smid);
+ 
+ 	/*
+ 	 * Check if we are within 1 entry of a page boundary we don't
+ 	 * want our first entry to be a PRP List entry.
+ 	 */
+ 	page_mask = ioc->page_size - 1;
+ 	page_mask_result = (uintptr_t)((u8 *)prp_page + prp_size) & page_mask;
+ 	if (!page_mask_result) {
+ 		/* Bump up to next page boundary. */
+ 		prp_page = (__le64 *)((u8 *)prp_page + prp_size);
+ 		prp_page_dma = prp_page_dma + prp_size;
+ 	}
+ 
+ 	/*
+ 	 * Set PRP physical pointer, which initially points to the current PRP
+ 	 * DMA memory page.
+ 	 */
+ 	prp_entry_dma = prp_page_dma;
+ 
+ 	/* Get physical address and length of the data buffer. */
+ 	if (data_in_sz) {
+ 		dma_addr = data_in_dma;
+ 		length = data_in_sz;
+ 	} else {
+ 		dma_addr = data_out_dma;
+ 		length = data_out_sz;
+ 	}
+ 
+ 	/* Loop while the length is not zero. */
+ 	while (length) {
+ 		/*
+ 		 * Check if we need to put a list pointer here if we are at
+ 		 * page boundary - prp_size (8 bytes).
+ 		 */
+ 		page_mask_result = (prp_entry_dma + prp_size) & page_mask;
+ 		if (!page_mask_result) {
+ 			/*
+ 			 * This is the last entry in a PRP List, so we need to
+ 			 * put a PRP list pointer here.  What this does is:
+ 			 *   - bump the current memory pointer to the next
+ 			 *     address, which will be the next full page.
+ 			 *   - set the PRP Entry to point to that page.  This
+ 			 *     is now the PRP List pointer.
+ 			 *   - bump the PRP Entry pointer the start of the
+ 			 *     next page.  Since all of this PRP memory is
+ 			 *     contiguous, no need to get a new page - it's
+ 			 *     just the next address.
+ 			 */
+ 			prp_entry_dma++;
+ 			*prp_entry = cpu_to_le64(prp_entry_dma);
+ 			prp_entry++;
+ 		}
+ 
+ 		/* Need to handle if entry will be part of a page. */
+ 		offset = dma_addr & page_mask;
+ 		entry_len = ioc->page_size - offset;
+ 
+ 		if (prp_entry == prp1_entry) {
+ 			/*
+ 			 * Must fill in the first PRP pointer (PRP1) before
+ 			 * moving on.
+ 			 */
+ 			*prp1_entry = cpu_to_le64(dma_addr);
+ 
+ 			/*
+ 			 * Now point to the second PRP entry within the
+ 			 * command (PRP2).
+ 			 */
+ 			prp_entry = prp2_entry;
+ 		} else if (prp_entry == prp2_entry) {
+ 			/*
+ 			 * Should the PRP2 entry be a PRP List pointer or just
+ 			 * a regular PRP pointer?  If there is more than one
+ 			 * more page of data, must use a PRP List pointer.
+ 			 */
+ 			if (length > ioc->page_size) {
+ 				/*
+ 				 * PRP2 will contain a PRP List pointer because
+ 				 * more PRP's are needed with this command. The
+ 				 * list will start at the beginning of the
+ 				 * contiguous buffer.
+ 				 */
+ 				*prp2_entry = cpu_to_le64(prp_entry_dma);
+ 
+ 				/*
+ 				 * The next PRP Entry will be the start of the
+ 				 * first PRP List.
+ 				 */
+ 				prp_entry = prp_page;
+ 			} else {
+ 				/*
+ 				 * After this, the PRP Entries are complete.
+ 				 * This command uses 2 PRP's and no PRP list.
+ 				 */
+ 				*prp2_entry = cpu_to_le64(dma_addr);
+ 			}
+ 		} else {
+ 			/*
+ 			 * Put entry in list and bump the addresses.
+ 			 *
+ 			 * After PRP1 and PRP2 are filled in, this will fill in
+ 			 * all remaining PRP entries in a PRP List, one per
+ 			 * each time through the loop.
+ 			 */
+ 			*prp_entry = cpu_to_le64(dma_addr);
+ 			prp_entry++;
+ 			prp_entry_dma++;
+ 		}
+ 
+ 		/*
+ 		 * Bump the phys address of the command's data buffer by the
+ 		 * entry_len.
+ 		 */
+ 		dma_addr += entry_len;
+ 
+ 		/* Decrement length accounting for last partial page. */
+ 		if (entry_len > length)
+ 			length = 0;
+ 		else
+ 			length -= entry_len;
+ 	}
+ }
+ 
+ /**
+  * base_make_prp_nvme -
+  * Prepare PRPs(Physical Region Page)- SGLs specific to NVMe drives only
+  *
+  * @ioc:		per adapter object
+  * @scmd:		SCSI command from the mid-layer
+  * @mpi_request:	mpi request
+  * @smid:		msg Index
+  * @sge_count:		scatter gather element count.
+  *
+  * Return:		true: PRPs are built
+  *			false: IEEE SGLs needs to be built
+  */
+ static void
+ base_make_prp_nvme(struct MPT3SAS_ADAPTER *ioc,
+ 		struct scsi_cmnd *scmd,
+ 		Mpi25SCSIIORequest_t *mpi_request,
+ 		u16 smid, int sge_count)
+ {
+ 	int sge_len, num_prp_in_chain = 0;
+ 	Mpi25IeeeSgeChain64_t *main_chain_element, *ptr_first_sgl;
+ 	__le64 *curr_buff;
+ 	dma_addr_t msg_dma, sge_addr, offset;
+ 	u32 page_mask, page_mask_result;
+ 	struct scatterlist *sg_scmd;
+ 	u32 first_prp_len;
+ 	int data_len = scsi_bufflen(scmd);
+ 	u32 nvme_pg_size;
+ 
+ 	nvme_pg_size = max_t(u32, ioc->page_size, NVME_PRP_PAGE_SIZE);
+ 	/*
+ 	 * Nvme has a very convoluted prp format.  One prp is required
+ 	 * for each page or partial page. Driver need to split up OS sg_list
+ 	 * entries if it is longer than one page or cross a page
+ 	 * boundary.  Driver also have to insert a PRP list pointer entry as
+ 	 * the last entry in each physical page of the PRP list.
+ 	 *
+ 	 * NOTE: The first PRP "entry" is actually placed in the first
+ 	 * SGL entry in the main message as IEEE 64 format.  The 2nd
+ 	 * entry in the main message is the chain element, and the rest
+ 	 * of the PRP entries are built in the contiguous pcie buffer.
+ 	 */
+ 	page_mask = nvme_pg_size - 1;
+ 
+ 	/*
+ 	 * Native SGL is needed.
+ 	 * Put a chain element in main message frame that points to the first
+ 	 * chain buffer.
+ 	 *
+ 	 * NOTE:  The ChainOffset field must be 0 when using a chain pointer to
+ 	 *        a native SGL.
+ 	 */
+ 
+ 	/* Set main message chain element pointer */
+ 	main_chain_element = (pMpi25IeeeSgeChain64_t)&mpi_request->SGL;
+ 	/*
+ 	 * For NVMe the chain element needs to be the 2nd SG entry in the main
+ 	 * message.
+ 	 */
+ 	main_chain_element = (Mpi25IeeeSgeChain64_t *)
+ 		((u8 *)main_chain_element + sizeof(MPI25_IEEE_SGE_CHAIN64));
+ 
+ 	/*
+ 	 * For the PRP entries, use the specially allocated buffer of
+ 	 * contiguous memory.  Normal chain buffers can't be used
+ 	 * because each chain buffer would need to be the size of an OS
+ 	 * page (4k).
+ 	 */
+ 	curr_buff = mpt3sas_base_get_pcie_sgl(ioc, smid);
+ 	msg_dma = mpt3sas_base_get_pcie_sgl_dma(ioc, smid);
+ 
+ 	main_chain_element->Address = cpu_to_le64(msg_dma);
+ 	main_chain_element->NextChainOffset = 0;
+ 	main_chain_element->Flags = MPI2_IEEE_SGE_FLAGS_CHAIN_ELEMENT |
+ 			MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR |
+ 			MPI26_IEEE_SGE_FLAGS_NSF_NVME_PRP;
+ 
+ 	/* Build first prp, sge need not to be page aligned*/
+ 	ptr_first_sgl = (pMpi25IeeeSgeChain64_t)&mpi_request->SGL;
+ 	sg_scmd = scsi_sglist(scmd);
+ 	sge_addr = sg_dma_address(sg_scmd);
+ 	sge_len = sg_dma_len(sg_scmd);
+ 
+ 	offset = sge_addr & page_mask;
+ 	first_prp_len = nvme_pg_size - offset;
+ 
+ 	ptr_first_sgl->Address = cpu_to_le64(sge_addr);
+ 	ptr_first_sgl->Length = cpu_to_le32(first_prp_len);
+ 
+ 	data_len -= first_prp_len;
+ 
+ 	if (sge_len > first_prp_len) {
+ 		sge_addr += first_prp_len;
+ 		sge_len -= first_prp_len;
+ 	} else if (data_len && (sge_len == first_prp_len)) {
+ 		sg_scmd = sg_next(sg_scmd);
+ 		sge_addr = sg_dma_address(sg_scmd);
+ 		sge_len = sg_dma_len(sg_scmd);
+ 	}
+ 
+ 	for (;;) {
+ 		offset = sge_addr & page_mask;
+ 
+ 		/* Put PRP pointer due to page boundary*/
+ 		page_mask_result = (uintptr_t)(curr_buff + 1) & page_mask;
+ 		if (unlikely(!page_mask_result)) {
+ 			scmd_printk(KERN_NOTICE,
+ 				scmd, "page boundary curr_buff: 0x%p\n",
+ 				curr_buff);
+ 			msg_dma += 8;
+ 			*curr_buff = cpu_to_le64(msg_dma);
+ 			curr_buff++;
+ 			num_prp_in_chain++;
+ 		}
+ 
+ 		*curr_buff = cpu_to_le64(sge_addr);
+ 		curr_buff++;
+ 		msg_dma += 8;
+ 		num_prp_in_chain++;
+ 
+ 		sge_addr += nvme_pg_size;
+ 		sge_len -= nvme_pg_size;
+ 		data_len -= nvme_pg_size;
+ 
+ 		if (data_len <= 0)
+ 			break;
+ 
+ 		if (sge_len > 0)
+ 			continue;
+ 
+ 		sg_scmd = sg_next(sg_scmd);
+ 		sge_addr = sg_dma_address(sg_scmd);
+ 		sge_len = sg_dma_len(sg_scmd);
+ 	}
+ 
+ 	main_chain_element->Length =
+ 		cpu_to_le32(num_prp_in_chain * sizeof(u64));
+ 	return;
+ }
+ 
+ static bool
+ base_is_prp_possible(struct MPT3SAS_ADAPTER *ioc,
+ 	struct _pcie_device *pcie_device, struct scsi_cmnd *scmd, int sge_count)
+ {
+ 	u32 data_length = 0;
+ 	bool build_prp = true;
+ 
+ 	data_length = scsi_bufflen(scmd);
+ 
+ 	/* If Datalenth is <= 16K and number of SGE’s entries are <= 2
+ 	 * we built IEEE SGL
+ 	 */
+ 	if ((data_length <= NVME_PRP_PAGE_SIZE*4) && (sge_count <= 2))
+ 		build_prp = false;
+ 
+ 	return build_prp;
+ }
+ 
+ /**
+  * _base_check_pcie_native_sgl - This function is called for PCIe end devices to
+  * determine if the driver needs to build a native SGL.  If so, that native
+  * SGL is built in the special contiguous buffers allocated especially for
+  * PCIe SGL creation.  If the driver will not build a native SGL, return
+  * TRUE and a normal IEEE SGL will be built.  Currently this routine
+  * supports NVMe.
+  * @ioc: per adapter object
+  * @mpi_request: mf request pointer
+  * @smid: system request message index
+  * @scmd: scsi command
+  * @pcie_device: points to the PCIe device's info
+  *
+  * Return: 0 if native SGL was built, 1 if no SGL was built
+  */
+ static int
+ _base_check_pcie_native_sgl(struct MPT3SAS_ADAPTER *ioc,
+ 	Mpi25SCSIIORequest_t *mpi_request, u16 smid, struct scsi_cmnd *scmd,
+ 	struct _pcie_device *pcie_device)
+ {
+ 	int sges_left;
+ 
+ 	/* Get the SG list pointer and info. */
+ 	sges_left = scsi_dma_map(scmd);
+ 	if (sges_left < 0) {
+ 		sdev_printk(KERN_ERR, scmd->device,
+ 			"scsi_dma_map failed: request for %d bytes!\n",
+ 			scsi_bufflen(scmd));
+ 		return 1;
+ 	}
+ 
+ 	/* Check if we need to build a native SG list. */
+ 	if (base_is_prp_possible(ioc, pcie_device,
+ 				scmd, sges_left) == 0) {
+ 		/* We built a native SG list, just return. */
+ 		goto out;
+ 	}
+ 
+ 	/*
+ 	 * Build native NVMe PRP.
+ 	 */
+ 	base_make_prp_nvme(ioc, scmd, mpi_request,
+ 			smid, sges_left);
+ 
+ 	return 0;
+ out:
+ 	scsi_dma_unmap(scmd);
+ 	return 1;
+ }
+ 
+ /**
++>>>>>>> 4beb4867f049 (scsi: mpt3sas: Improve kernel-doc headers)
   * _base_add_sg_single_ieee - add sg element for IEEE format
   * @paddr: virtual address for SGE
   * @flags: SGE flags
@@@ -2429,6 -3113,32 +3098,35 @@@ mpt3sas_base_get_sense_buffer_dma(struc
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mpt3sas_base_get_pcie_sgl - obtain a PCIe SGL virt addr
+  * @ioc: per adapter object
+  * @smid: system request message index
+  *
+  * Return: virt pointer to a PCIe SGL.
+  */
+ void *
+ mpt3sas_base_get_pcie_sgl(struct MPT3SAS_ADAPTER *ioc, u16 smid)
+ {
+ 	return (void *)(ioc->pcie_sg_lookup[smid - 1].pcie_sgl);
+ }
+ 
+ /**
+  * mpt3sas_base_get_pcie_sgl_dma - obtain a PCIe SGL dma addr
+  * @ioc: per adapter object
+  * @smid: system request message index
+  *
+  * Return: phys pointer to the address of the PCIe buffer.
+  */
+ dma_addr_t
+ mpt3sas_base_get_pcie_sgl_dma(struct MPT3SAS_ADAPTER *ioc, u16 smid)
+ {
+ 	return ioc->pcie_sg_lookup[smid - 1].pcie_sgl_dma;
+ }
+ 
+ /**
++>>>>>>> 4beb4867f049 (scsi: mpt3sas: Improve kernel-doc headers)
   * mpt3sas_base_get_reply_virt_addr - obtain reply frames virt address
   * @ioc: per adapter object
   * @phys_addr: lower 32 physical addr of the reply
@@@ -2601,9 -3306,32 +3297,8 @@@ mpt3sas_base_free_smid(struct MPT3SAS_A
  	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
  }
  
 -/**
 - * _base_mpi_ep_writeq - 32 bit write to MMIO
 - * @b: data payload
 - * @addr: address in MMIO space
 - * @writeq_lock: spin lock
 - *
 - * This special handling for MPI EP to take care of 32 bit
 - * environment where its not quarenteed to send the entire word
 - * in one transfer.
 - */
 -static inline void
 -_base_mpi_ep_writeq(__u64 b, volatile void __iomem *addr,
 -					spinlock_t *writeq_lock)
 -{
 -	unsigned long flags;
 -	__u64 data_out = b;
 -
 -	spin_lock_irqsave(writeq_lock, flags);
 -	writel((u32)(data_out), addr);
 -	writel((u32)(data_out >> 32), (addr + 4));
 -	mmiowb();
 -	spin_unlock_irqrestore(writeq_lock, flags);
 -}
 -
  /**
   * _base_writeq - 64 bit write to MMIO
-  * @ioc: per adapter object
   * @b: data payload
   * @addr: address in MMIO space
   * @writeq_lock: spin lock
@@@ -2633,6 -3355,34 +3328,37 @@@ _base_writeq(__u64 b, volatile void __i
  #endif
  
  /**
++<<<<<<< HEAD
++=======
+  * _base_put_smid_mpi_ep_scsi_io - send SCSI_IO request to firmware
+  * @ioc: per adapter object
+  * @smid: system request message index
+  * @handle: device handle
+  */
+ static void
+ _base_put_smid_mpi_ep_scsi_io(struct MPT3SAS_ADAPTER *ioc, u16 smid, u16 handle)
+ {
+ 	Mpi2RequestDescriptorUnion_t descriptor;
+ 	u64 *request = (u64 *)&descriptor;
+ 	void *mpi_req_iomem;
+ 	__le32 *mfp = (__le32 *)mpt3sas_base_get_msg_frame(ioc, smid);
+ 
+ 	_clone_sg_entries(ioc, (void *) mfp, smid);
+ 	mpi_req_iomem = (void __force *)ioc->chip +
+ 			MPI_FRAME_START_OFFSET + (smid * ioc->request_sz);
+ 	_base_clone_mpi_to_sys_mem(mpi_req_iomem, (void *)mfp,
+ 					ioc->request_sz);
+ 	descriptor.SCSIIO.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO;
+ 	descriptor.SCSIIO.MSIxIndex =  _base_get_msix_index(ioc);
+ 	descriptor.SCSIIO.SMID = cpu_to_le16(smid);
+ 	descriptor.SCSIIO.DevHandle = cpu_to_le16(handle);
+ 	descriptor.SCSIIO.LMID = 0;
+ 	_base_mpi_ep_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
+ 	    &ioc->scsi_lookup_lock);
+ }
+ 
+ /**
++>>>>>>> 4beb4867f049 (scsi: mpt3sas: Improve kernel-doc headers)
   * _base_put_smid_scsi_io - send SCSI_IO request to firmware
   * @ioc: per adapter object
   * @smid: system request message index
@@@ -2701,6 -3460,33 +3422,36 @@@ mpt3sas_base_put_smid_hi_priority(struc
  	descriptor.HighPriority.SMID = cpu_to_le16(smid);
  	descriptor.HighPriority.LMID = 0;
  	descriptor.HighPriority.Reserved1 = 0;
++<<<<<<< HEAD
++=======
+ 	if (ioc->is_mcpu_endpoint)
+ 		_base_mpi_ep_writeq(*request,
+ 				&ioc->chip->RequestDescriptorPostLow,
+ 				&ioc->scsi_lookup_lock);
+ 	else
+ 		_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
+ 		    &ioc->scsi_lookup_lock);
+ }
+ 
+ /**
+  * mpt3sas_base_put_smid_nvme_encap - send NVMe encapsulated request to
+  *  firmware
+  * @ioc: per adapter object
+  * @smid: system request message index
+  */
+ void
+ mpt3sas_base_put_smid_nvme_encap(struct MPT3SAS_ADAPTER *ioc, u16 smid)
+ {
+ 	Mpi2RequestDescriptorUnion_t descriptor;
+ 	u64 *request = (u64 *)&descriptor;
+ 
+ 	descriptor.Default.RequestFlags =
+ 		MPI26_REQ_DESCRIPT_FLAGS_PCIE_ENCAPSULATED;
+ 	descriptor.Default.MSIxIndex =  _base_get_msix_index(ioc);
+ 	descriptor.Default.SMID = cpu_to_le16(smid);
+ 	descriptor.Default.LMID = 0;
+ 	descriptor.Default.DescriptorTypeDependent = 0;
++>>>>>>> 4beb4867f049 (scsi: mpt3sas: Improve kernel-doc headers)
  	_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
  	    &ioc->scsi_lookup_lock);
  }
@@@ -3344,6 -4156,25 +4086,28 @@@ _base_static_config_pages(struct MPT3SA
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * mpt3sas_free_enclosure_list - release memory
+  * @ioc: per adapter object
+  *
+  * Free memory allocated during encloure add.
+  */
+ void
+ mpt3sas_free_enclosure_list(struct MPT3SAS_ADAPTER *ioc)
+ {
+ 	struct _enclosure_node *enclosure_dev, *enclosure_dev_next;
+ 
+ 	/* Free enclosure list */
+ 	list_for_each_entry_safe(enclosure_dev,
+ 			enclosure_dev_next, &ioc->enclosure_list, list) {
+ 		list_del(&enclosure_dev->list);
+ 		kfree(enclosure_dev);
+ 	}
+ }
+ 
+ /**
++>>>>>>> 4beb4867f049 (scsi: mpt3sas: Improve kernel-doc headers)
   * _base_release_memory_pools - release memory
   * @ioc: per adapter object
   *
diff --cc drivers/scsi/mpt3sas/mpt3sas_ctl.c
index bdd5dacbbbc9,5e8c059ce2c9..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_ctl.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
@@@ -516,11 -537,11 +514,11 @@@ _ctl_fasync(int fd, struct file *filep
  
  /**
   * _ctl_poll -
-  * @file -
-  * @wait -
+  * @filep: ?
+  * @wait: ?
   *
   */
 -static __poll_t
 +static unsigned int
  _ctl_poll(struct file *filep, poll_table *wait)
  {
  	struct MPT3SAS_ADAPTER *ioc;
@@@ -3413,6 -3526,47 +3447,50 @@@ _ctl_device_handle_show(struct device *
  }
  static DEVICE_ATTR(sas_device_handle, S_IRUGO, _ctl_device_handle_show, NULL);
  
++<<<<<<< HEAD
++=======
+ /**
+  * _ctl_device_ncq_io_prio_show - send prioritized io commands to device
+  * @dev: pointer to embedded device
+  * @attr: ?
+  * @buf: the buffer returned
+  *
+  * A sysfs 'read/write' sdev attribute, only works with SATA
+  */
+ static ssize_t
+ _ctl_device_ncq_prio_enable_show(struct device *dev,
+ 				 struct device_attribute *attr, char *buf)
+ {
+ 	struct scsi_device *sdev = to_scsi_device(dev);
+ 	struct MPT3SAS_DEVICE *sas_device_priv_data = sdev->hostdata;
+ 
+ 	return snprintf(buf, PAGE_SIZE, "%d\n",
+ 			sas_device_priv_data->ncq_prio_enable);
+ }
+ 
+ static ssize_t
+ _ctl_device_ncq_prio_enable_store(struct device *dev,
+ 				  struct device_attribute *attr,
+ 				  const char *buf, size_t count)
+ {
+ 	struct scsi_device *sdev = to_scsi_device(dev);
+ 	struct MPT3SAS_DEVICE *sas_device_priv_data = sdev->hostdata;
+ 	bool ncq_prio_enable = 0;
+ 
+ 	if (kstrtobool(buf, &ncq_prio_enable))
+ 		return -EINVAL;
+ 
+ 	if (!scsih_ncq_prio_supp(sdev))
+ 		return -EINVAL;
+ 
+ 	sas_device_priv_data->ncq_prio_enable = ncq_prio_enable;
+ 	return strlen(buf);
+ }
+ static DEVICE_ATTR(sas_ncq_prio_enable, S_IRUGO | S_IWUSR,
+ 		   _ctl_device_ncq_prio_enable_show,
+ 		   _ctl_device_ncq_prio_enable_store);
+ 
++>>>>>>> 4beb4867f049 (scsi: mpt3sas: Improve kernel-doc headers)
  struct device_attribute *mpt3sas_dev_attrs[] = {
  	&dev_attr_sas_address,
  	&dev_attr_sas_device_handle,
diff --cc drivers/scsi/mpt3sas/mpt3sas_scsih.c
index 9086915b17c4,061736f8025b..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@@ -1474,142 -1466,38 +1467,146 @@@ _scsih_is_nvme_device(u32 device_info
   * @ioc: per adapter object
   * @smid: system request message index
   *
-  * Returns the smid stored scmd pointer.
+  * Return: the smid stored scmd pointer.
   * Then will dereference the stored scmd pointer.
   */
 -struct scsi_cmnd *
 -mpt3sas_scsih_scsi_lookup_get(struct MPT3SAS_ADAPTER *ioc, u16 smid)
 +static inline struct scsi_cmnd *
 +__scsih_scsi_lookup_get_clear(struct MPT3SAS_ADAPTER *ioc,
 +		u16 smid)
  {
  	struct scsi_cmnd *scmd = NULL;
 -	struct scsiio_tracker *st;
  
 -	if (smid > 0  &&
 -	    smid <= ioc->scsiio_depth - INTERNAL_SCSIIO_CMDS_COUNT) {
 -		u32 unique_tag = smid - 1;
 +	swap(scmd, ioc->scsi_lookup[smid - 1].scmd);
  
 -		scmd = scsi_host_find_tag(ioc->shost, unique_tag);
 -		if (scmd) {
 -			st = scsi_cmd_priv(scmd);
 -			if (st->cb_idx == 0xFF)
 -				scmd = NULL;
 -		}
 -	}
  	return scmd;
  }
  
  /**
 - * scsih_change_queue_depth - setting device queue depth
 - * @sdev: scsi device struct
 - * @qdepth: requested queue depth
 + * _scsih_scsi_lookup_get_clear - returns scmd entry
 + * @ioc: per adapter object
 + * @smid: system request message index
   *
++<<<<<<< HEAD
 + * Returns the smid stored scmd pointer.
 + * Then will derefrence the stored scmd pointer.
++=======
+  * Return: queue depth.
++>>>>>>> 4beb4867f049 (scsi: mpt3sas: Improve kernel-doc headers)
   */
 -static int
 -scsih_change_queue_depth(struct scsi_device *sdev, int qdepth)
 +static inline struct scsi_cmnd *
 +_scsih_scsi_lookup_get_clear(struct MPT3SAS_ADAPTER *ioc, u16 smid)
 +{
 +	unsigned long flags;
 +	struct scsi_cmnd *scmd;
 +
 +	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
 +	scmd = __scsih_scsi_lookup_get_clear(ioc, smid);
 +	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
 +
 +	return scmd;
 +}
 +
 +/**
 + * _scsih_scsi_lookup_find_by_scmd - scmd lookup
 + * @ioc: per adapter object
 + * @smid: system request message index
 + * @scmd: pointer to scsi command object
 + * Context: This function will acquire ioc->scsi_lookup_lock.
 + *
 + * This will search for a scmd pointer in the scsi_lookup array,
 + * returning the revelent smid.  A returned value of zero means invalid.
 + */
 +static u16
 +_scsih_scsi_lookup_find_by_scmd(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd
 +	*scmd)
 +{
 +	u16 smid;
 +	unsigned long	flags;
 +	int i;
 +
 +	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
 +	smid = 0;
 +	for (i = 0; i < ioc->scsiio_depth; i++) {
 +		if (ioc->scsi_lookup[i].scmd == scmd) {
 +			smid = ioc->scsi_lookup[i].smid;
 +			goto out;
 +		}
 +	}
 + out:
 +	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
 +	return smid;
 +}
 +
 +/**
 + * _scsih_scsi_lookup_find_by_target - search for matching channel:id
 + * @ioc: per adapter object
 + * @id: target id
 + * @channel: channel
 + * Context: This function will acquire ioc->scsi_lookup_lock.
 + *
 + * This will search for a matching channel:id in the scsi_lookup array,
 + * returning 1 if found.
 + */
 +static u8
 +_scsih_scsi_lookup_find_by_target(struct MPT3SAS_ADAPTER *ioc, int id,
 +	int channel)
 +{
 +	u8 found;
 +	unsigned long	flags;
 +	int i;
 +
 +	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
 +	found = 0;
 +	for (i = 0 ; i < ioc->scsiio_depth; i++) {
 +		if (ioc->scsi_lookup[i].scmd &&
 +		    (ioc->scsi_lookup[i].scmd->device->id == id &&
 +		    ioc->scsi_lookup[i].scmd->device->channel == channel)) {
 +			found = 1;
 +			goto out;
 +		}
 +	}
 + out:
 +	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
 +	return found;
 +}
 +
 +/**
 + * _scsih_scsi_lookup_find_by_lun - search for matching channel:id:lun
 + * @ioc: per adapter object
 + * @id: target id
 + * @lun: lun number
 + * @channel: channel
 + * Context: This function will acquire ioc->scsi_lookup_lock.
 + *
 + * This will search for a matching channel:id:lun in the scsi_lookup array,
 + * returning 1 if found.
 + */
 +static u8
 +_scsih_scsi_lookup_find_by_lun(struct MPT3SAS_ADAPTER *ioc, int id,
 +	unsigned int lun, int channel)
 +{
 +	u8 found;
 +	unsigned long	flags;
 +	int i;
 +
 +	spin_lock_irqsave(&ioc->scsi_lookup_lock, flags);
 +	found = 0;
 +	for (i = 0 ; i < ioc->scsiio_depth; i++) {
 +		if (ioc->scsi_lookup[i].scmd &&
 +		    (ioc->scsi_lookup[i].scmd->device->id == id &&
 +		    ioc->scsi_lookup[i].scmd->device->channel == channel &&
 +		    ioc->scsi_lookup[i].scmd->device->lun == lun)) {
 +			found = 1;
 +			goto out;
 +		}
 +	}
 + out:
 +	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
 +	return found;
 +}
 +
 +static void
 +_scsih_adjust_queue_depth(struct scsi_device *sdev, int qdepth)
  {
  	struct Scsi_Host *shost = sdev->host;
  	int max_depth;
@@@ -2745,12 -2623,13 +2735,12 @@@ mpt3sas_scsih_clear_tm_flag(struct MPT3
   * A generic API for sending task management requests to firmware.
   *
   * The callback index is set inside `ioc->tm_cb_idx`.
 - * The caller is responsible to check for outstanding commands.
   *
-  * Return SUCCESS or FAILED.
+  * Return: SUCCESS or FAILED.
   */
  int
 -mpt3sas_scsih_issue_tm(struct MPT3SAS_ADAPTER *ioc, u16 handle, u64 lun,
 -	u8 type, u16 smid_task, u16 msix_task, u8 timeout, u8 tr_method)
 +mpt3sas_scsih_issue_tm(struct MPT3SAS_ADAPTER *ioc, u16 handle, uint channel,
 +	uint id, uint lun, u8 type, u16 smid_task, ulong timeout)
  {
  	Mpi2SCSITaskManagementRequest_t *mpi_request;
  	Mpi2SCSITaskManagementReply_t *mpi_reply;
@@@ -8645,6 -8454,50 +8536,53 @@@ Mpi2SasDevicePage0_t *sas_device_pg0
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * _scsih_create_enclosure_list_after_reset - Free Existing list,
+  *	And create enclosure list by scanning all Enclosure Page(0)s
+  * @ioc: per adapter object
+  */
+ static void
+ _scsih_create_enclosure_list_after_reset(struct MPT3SAS_ADAPTER *ioc)
+ {
+ 	struct _enclosure_node *enclosure_dev;
+ 	Mpi2ConfigReply_t mpi_reply;
+ 	u16 enclosure_handle;
+ 	int rc;
+ 
+ 	/* Free existing enclosure list */
+ 	mpt3sas_free_enclosure_list(ioc);
+ 
+ 	/* Re constructing enclosure list after reset*/
+ 	enclosure_handle = 0xFFFF;
+ 	do {
+ 		enclosure_dev =
+ 			kzalloc(sizeof(struct _enclosure_node), GFP_KERNEL);
+ 		if (!enclosure_dev) {
+ 			pr_err(MPT3SAS_FMT
+ 				"failure at %s:%d/%s()!\n", ioc->name,
+ 				__FILE__, __LINE__, __func__);
+ 			return;
+ 		}
+ 		rc = mpt3sas_config_get_enclosure_pg0(ioc, &mpi_reply,
+ 				&enclosure_dev->pg0,
+ 				MPI2_SAS_ENCLOS_PGAD_FORM_GET_NEXT_HANDLE,
+ 				enclosure_handle);
+ 
+ 		if (rc || (le16_to_cpu(mpi_reply.IOCStatus) &
+ 						MPI2_IOCSTATUS_MASK)) {
+ 			kfree(enclosure_dev);
+ 			return;
+ 		}
+ 		list_add_tail(&enclosure_dev->list,
+ 						&ioc->enclosure_list);
+ 		enclosure_handle =
+ 			le16_to_cpu(enclosure_dev->pg0.EnclosureHandle);
+ 	} while (1);
+ }
+ 
+ /**
++>>>>>>> 4beb4867f049 (scsi: mpt3sas: Improve kernel-doc headers)
   * _scsih_search_responding_sas_devices -
   * @ioc: per adapter object
   *
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.c
diff --git a/drivers/scsi/mpt3sas/mpt3sas_config.c b/drivers/scsi/mpt3sas/mpt3sas_config.c
index d3efe533b710..1c3888f40284 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_config.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_config.c
@@ -198,7 +198,7 @@ _config_display_some_debug(struct MPT3SAS_ADAPTER *ioc, u16 smid,
  *
  * A wrapper for obtaining dma-able memory for config page request.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 static int
 _config_alloc_config_dma_memory(struct MPT3SAS_ADAPTER *ioc,
@@ -229,7 +229,7 @@ _config_alloc_config_dma_memory(struct MPT3SAS_ADAPTER *ioc,
  *
  * A wrapper to free dma-able memory when using _config_alloc_config_dma_memory.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 static void
 _config_free_config_dma_memory(struct MPT3SAS_ADAPTER *ioc,
@@ -250,8 +250,8 @@ _config_free_config_dma_memory(struct MPT3SAS_ADAPTER *ioc,
  *
  * The callback handler when using _config_request.
  *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
+ * Return: 1 meaning mf should be freed from _base_interrupt
+ *         0 means the mf is freed from this function.
  */
 u8
 mpt3sas_config_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
@@ -294,7 +294,7 @@ mpt3sas_config_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
  *
  * The callback index is set inside `ioc->config_cb_idx.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 static int
 _config_request(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigRequest_t
@@ -517,7 +517,7 @@ _config_request(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigRequest_t
  * @config_page: contents of the config page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_manufacturing_pg0(struct MPT3SAS_ADAPTER *ioc,
@@ -554,7 +554,7 @@ mpt3sas_config_get_manufacturing_pg0(struct MPT3SAS_ADAPTER *ioc,
  * @sz: size of buffer passed in config_page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_manufacturing_pg7(struct MPT3SAS_ADAPTER *ioc,
@@ -591,7 +591,7 @@ mpt3sas_config_get_manufacturing_pg7(struct MPT3SAS_ADAPTER *ioc,
  * @config_page: contents of the config page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_manufacturing_pg10(struct MPT3SAS_ADAPTER *ioc,
@@ -628,7 +628,7 @@ mpt3sas_config_get_manufacturing_pg10(struct MPT3SAS_ADAPTER *ioc,
  * @config_page: contents of the config page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_manufacturing_pg11(struct MPT3SAS_ADAPTER *ioc,
@@ -665,7 +665,7 @@ mpt3sas_config_get_manufacturing_pg11(struct MPT3SAS_ADAPTER *ioc,
  * @config_page: contents of the config page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_set_manufacturing_pg11(struct MPT3SAS_ADAPTER *ioc,
@@ -706,7 +706,7 @@ mpt3sas_config_set_manufacturing_pg11(struct MPT3SAS_ADAPTER *ioc,
  * @config_page: contents of the config page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_bios_pg2(struct MPT3SAS_ADAPTER *ioc,
@@ -742,7 +742,7 @@ mpt3sas_config_get_bios_pg2(struct MPT3SAS_ADAPTER *ioc,
  * @config_page: contents of the config page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_bios_pg3(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
@@ -778,7 +778,7 @@ mpt3sas_config_get_bios_pg3(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
  * @config_page: contents of the config page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_iounit_pg0(struct MPT3SAS_ADAPTER *ioc,
@@ -814,7 +814,7 @@ mpt3sas_config_get_iounit_pg0(struct MPT3SAS_ADAPTER *ioc,
  * @config_page: contents of the config page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_iounit_pg1(struct MPT3SAS_ADAPTER *ioc,
@@ -850,7 +850,7 @@ mpt3sas_config_get_iounit_pg1(struct MPT3SAS_ADAPTER *ioc,
  * @config_page: contents of the config page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_set_iounit_pg1(struct MPT3SAS_ADAPTER *ioc,
@@ -887,7 +887,7 @@ mpt3sas_config_set_iounit_pg1(struct MPT3SAS_ADAPTER *ioc,
  * @sz: size of buffer passed in config_page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_iounit_pg3(struct MPT3SAS_ADAPTER *ioc,
@@ -922,7 +922,7 @@ mpt3sas_config_get_iounit_pg3(struct MPT3SAS_ADAPTER *ioc,
  * @config_page: contents of the config page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_iounit_pg8(struct MPT3SAS_ADAPTER *ioc,
@@ -958,7 +958,7 @@ mpt3sas_config_get_iounit_pg8(struct MPT3SAS_ADAPTER *ioc,
  * @config_page: contents of the config page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_ioc_pg8(struct MPT3SAS_ADAPTER *ioc,
@@ -996,7 +996,7 @@ mpt3sas_config_get_ioc_pg8(struct MPT3SAS_ADAPTER *ioc,
  * @handle: device handle
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_sas_device_pg0(struct MPT3SAS_ADAPTER *ioc,
@@ -1037,7 +1037,7 @@ mpt3sas_config_get_sas_device_pg0(struct MPT3SAS_ADAPTER *ioc,
  * @handle: device handle
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_sas_device_pg1(struct MPT3SAS_ADAPTER *ioc,
@@ -1078,7 +1078,7 @@ mpt3sas_config_get_sas_device_pg1(struct MPT3SAS_ADAPTER *ioc,
  * @handle: device handle
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_pcie_device_pg0(struct MPT3SAS_ADAPTER *ioc,
@@ -1119,7 +1119,7 @@ out:
  * @handle: device handle
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_pcie_device_pg2(struct MPT3SAS_ADAPTER *ioc,
@@ -1157,7 +1157,7 @@ out:
  * @num_phys: pointer returned with the number of phys
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_number_hba_phys(struct MPT3SAS_ADAPTER *ioc, u8 *num_phys)
@@ -1207,7 +1207,7 @@ mpt3sas_config_get_number_hba_phys(struct MPT3SAS_ADAPTER *ioc, u8 *num_phys)
  * Calling function should call config_get_number_hba_phys prior to
  * this function, so enough memory is allocated for config_page.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_sas_iounit_pg0(struct MPT3SAS_ADAPTER *ioc,
@@ -1248,7 +1248,7 @@ mpt3sas_config_get_sas_iounit_pg0(struct MPT3SAS_ADAPTER *ioc,
  * Calling function should call config_get_number_hba_phys prior to
  * this function, so enough memory is allocated for config_page.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_sas_iounit_pg1(struct MPT3SAS_ADAPTER *ioc,
@@ -1289,7 +1289,7 @@ mpt3sas_config_get_sas_iounit_pg1(struct MPT3SAS_ADAPTER *ioc,
  * Calling function should call config_get_number_hba_phys prior to
  * this function, so enough memory is allocated for config_page.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_set_sas_iounit_pg1(struct MPT3SAS_ADAPTER *ioc,
@@ -1331,7 +1331,7 @@ mpt3sas_config_set_sas_iounit_pg1(struct MPT3SAS_ADAPTER *ioc,
  * @handle: expander handle
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_expander_pg0(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
@@ -1371,7 +1371,7 @@ mpt3sas_config_get_expander_pg0(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
  * @handle: expander handle
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_expander_pg1(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
@@ -1414,7 +1414,7 @@ mpt3sas_config_get_expander_pg1(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
  * @handle: expander handle
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_enclosure_pg0(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
@@ -1453,7 +1453,7 @@ mpt3sas_config_get_enclosure_pg0(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
  * @phy_number: phy number
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_phy_pg0(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
@@ -1493,7 +1493,7 @@ mpt3sas_config_get_phy_pg0(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
  * @phy_number: phy number
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_phy_pg1(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
@@ -1534,7 +1534,7 @@ mpt3sas_config_get_phy_pg1(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
  * @handle: volume handle
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_raid_volume_pg1(struct MPT3SAS_ADAPTER *ioc,
@@ -1572,7 +1572,7 @@ mpt3sas_config_get_raid_volume_pg1(struct MPT3SAS_ADAPTER *ioc,
  * @num_pds: returns pds count
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_number_pds(struct MPT3SAS_ADAPTER *ioc, u16 handle,
@@ -1624,7 +1624,7 @@ mpt3sas_config_get_number_pds(struct MPT3SAS_ADAPTER *ioc, u16 handle,
  * @sz: size of buffer passed in config_page
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_raid_volume_pg0(struct MPT3SAS_ADAPTER *ioc,
@@ -1663,7 +1663,7 @@ mpt3sas_config_get_raid_volume_pg0(struct MPT3SAS_ADAPTER *ioc,
  * @form_specific: specific to the form
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_phys_disk_pg0(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
@@ -1702,7 +1702,7 @@ mpt3sas_config_get_phys_disk_pg0(struct MPT3SAS_ADAPTER *ioc, Mpi2ConfigReply_t
  * @volume_handle: volume handle
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_volume_handle(struct MPT3SAS_ADAPTER *ioc, u16 pd_handle,
@@ -1792,7 +1792,7 @@ mpt3sas_config_get_volume_handle(struct MPT3SAS_ADAPTER *ioc, u16 pd_handle,
  * @wwid: volume wwid
  * Context: sleep.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_config_get_volume_wwid(struct MPT3SAS_ADAPTER *ioc, u16 volume_handle,
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_ctl.c
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_scsih.c
diff --git a/drivers/scsi/mpt3sas/mpt3sas_transport.c b/drivers/scsi/mpt3sas/mpt3sas_transport.c
index e56990fd083f..293f514c3601 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_transport.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_transport.c
@@ -134,7 +134,7 @@ _transport_convert_phy_link_rate(u8 link_rate)
  *
  * Populates sas identify info.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 static int
 _transport_set_identify(struct MPT3SAS_ADAPTER *ioc, u16 handle,
@@ -226,8 +226,8 @@ _transport_set_identify(struct MPT3SAS_ADAPTER *ioc, u16 handle,
  * Callback handler when sending internal generated transport cmds.
  * The callback index passed is `ioc->transport_cb_idx`
  *
- * Return 1 meaning mf should be freed from _base_interrupt
- *        0 means the mf is freed from this function.
+ * Return: 1 meaning mf should be freed from _base_interrupt
+ *         0 means the mf is freed from this function.
  */
 u8
 mpt3sas_transport_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
@@ -287,7 +287,7 @@ struct rep_manu_reply {
  *
  * Fills in the sas_expander_device object when SMP port is created.
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 static int
 _transport_expander_report_manufacture(struct MPT3SAS_ADAPTER *ioc,
@@ -460,8 +460,6 @@ _transport_expander_report_manufacture(struct MPT3SAS_ADAPTER *ioc,
  * _transport_delete_port - helper function to removing a port
  * @ioc: per adapter object
  * @mpt3sas_port: mpt3sas per port object
- *
- * Returns nothing.
  */
 static void
 _transport_delete_port(struct MPT3SAS_ADAPTER *ioc,
@@ -489,8 +487,6 @@ _transport_delete_port(struct MPT3SAS_ADAPTER *ioc,
  * @ioc: per adapter object
  * @mpt3sas_port: mpt3sas per port object
  * @mpt3sas_phy: mpt3sas per phy object
- *
- * Returns nothing.
  */
 static void
 _transport_delete_phy(struct MPT3SAS_ADAPTER *ioc,
@@ -513,8 +509,6 @@ _transport_delete_phy(struct MPT3SAS_ADAPTER *ioc,
  * @ioc: per adapter object
  * @mpt3sas_port: mpt3sas per port object
  * @mpt3sas_phy: mpt3sas per phy object
- *
- * Returns nothing.
  */
 static void
 _transport_add_phy(struct MPT3SAS_ADAPTER *ioc, struct _sas_port *mpt3sas_port,
@@ -538,8 +532,6 @@ _transport_add_phy(struct MPT3SAS_ADAPTER *ioc, struct _sas_port *mpt3sas_port,
  * @sas_node: sas node object (either expander or sas host)
  * @mpt3sas_phy: mpt3sas per phy object
  * @sas_address: sas address of device/expander were phy needs to be added to
- *
- * Returns nothing.
  */
 static void
 _transport_add_phy_to_an_existing_port(struct MPT3SAS_ADAPTER *ioc,
@@ -573,8 +565,6 @@ _transport_add_phy_to_an_existing_port(struct MPT3SAS_ADAPTER *ioc,
  * @ioc: per adapter object
  * @sas_node: sas node object (either expander or sas host)
  * @mpt3sas_phy: mpt3sas per phy object
- *
- * Returns nothing.
  */
 static void
 _transport_del_phy_from_an_existing_port(struct MPT3SAS_ADAPTER *ioc,
@@ -635,7 +625,7 @@ _transport_sanity_check(struct MPT3SAS_ADAPTER *ioc, struct _sas_node *sas_node,
  *
  * Adding new port object to the sas_node->sas_port_list.
  *
- * Returns mpt3sas_port.
+ * Return: mpt3sas_port.
  */
 struct _sas_port *
 mpt3sas_transport_port_add(struct MPT3SAS_ADAPTER *ioc, u16 handle,
@@ -794,8 +784,6 @@ mpt3sas_transport_port_add(struct MPT3SAS_ADAPTER *ioc, u16 handle,
  *
  * Removing object and freeing associated memory from the
  * ioc->sas_port_list.
- *
- * Return nothing.
  */
 void
 mpt3sas_transport_port_remove(struct MPT3SAS_ADAPTER *ioc, u64 sas_address,
@@ -860,7 +848,7 @@ mpt3sas_transport_port_remove(struct MPT3SAS_ADAPTER *ioc, u64 sas_address,
  * @phy_pg0: sas phy page 0
  * @parent_dev: parent device class object
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_transport_add_host_phy(struct MPT3SAS_ADAPTER *ioc, struct _sas_phy
@@ -928,7 +916,7 @@ mpt3sas_transport_add_host_phy(struct MPT3SAS_ADAPTER *ioc, struct _sas_phy
  * @expander_pg1: expander page 1
  * @parent_dev: parent device class object
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 int
 mpt3sas_transport_add_expander_phy(struct MPT3SAS_ADAPTER *ioc, struct _sas_phy
@@ -995,10 +983,8 @@ mpt3sas_transport_add_expander_phy(struct MPT3SAS_ADAPTER *ioc, struct _sas_phy
  * @ioc: per adapter object
  * @sas_address: sas address of parent expander or sas host
  * @handle: attached device handle
- * @phy_numberv: phy number
+ * @phy_number: phy number
  * @link_rate: new link rate
- *
- * Returns nothing.
  */
 void
 mpt3sas_transport_update_links(struct MPT3SAS_ADAPTER *ioc,
@@ -1090,7 +1076,7 @@ struct phy_error_log_reply {
  * @ioc: per adapter object
  * @phy: The sas phy object
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  *
  */
 static int
@@ -1262,7 +1248,7 @@ _transport_get_expander_phy_error_log(struct MPT3SAS_ADAPTER *ioc,
  * _transport_get_linkerrors - return phy counters for both hba and expanders
  * @phy: The sas phy object
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  *
  */
 static int
@@ -1311,10 +1297,11 @@ _transport_get_linkerrors(struct sas_phy *phy)
 
 /**
  * _transport_get_enclosure_identifier -
- * @phy: The sas phy object
+ * @rphy: The sas phy object
+ * @identifier: ?
  *
  * Obtain the enclosure logical id for an expander.
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 static int
 _transport_get_enclosure_identifier(struct sas_rphy *rphy, u64 *identifier)
@@ -1342,9 +1329,9 @@ _transport_get_enclosure_identifier(struct sas_rphy *rphy, u64 *identifier)
 
 /**
  * _transport_get_bay_identifier -
- * @phy: The sas phy object
+ * @rphy: The sas phy object
  *
- * Returns the slot id for a device that resides inside an enclosure.
+ * Return: the slot id for a device that resides inside an enclosure.
  */
 static int
 _transport_get_bay_identifier(struct sas_rphy *rphy)
@@ -1400,8 +1387,9 @@ struct phy_control_reply {
  * _transport_expander_phy_control - expander phy control
  * @ioc: per adapter object
  * @phy: The sas phy object
+ * @phy_operation: ?
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  *
  */
 static int
@@ -1571,7 +1559,7 @@ _transport_expander_phy_control(struct MPT3SAS_ADAPTER *ioc,
  * @phy: The sas phy object
  * @hard_reset:
  *
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 static int
 _transport_phy_reset(struct sas_phy *phy, int hard_reset)
@@ -1623,7 +1611,7 @@ _transport_phy_reset(struct sas_phy *phy, int hard_reset)
  * @enable: enable phy when true
  *
  * Only support sas_host direct attached phys.
- * Returns 0 for success, non-zero for failure.
+ * Return: 0 for success, non-zero for failure.
  */
 static int
 _transport_phy_enable(struct sas_phy *phy, int enable)
@@ -1761,7 +1749,8 @@ _transport_phy_enable(struct sas_phy *phy, int enable)
  * @rates: rates defined in sas_phy_linkrates
  *
  * Only support sas_host direct attached phys.
- * Returns 0 for success, non-zero for failure.
+ *
+ * Return: 0 for success, non-zero for failure.
  */
 static int
 _transport_phy_speed(struct sas_phy *phy, struct sas_phy_linkrates *rates)
@@ -1872,9 +1861,9 @@ _transport_phy_speed(struct sas_phy *phy, struct sas_phy_linkrates *rates)
 
 /**
  * _transport_smp_handler - transport portal for smp passthru
+ * @job: ?
  * @shost: shost object
  * @rphy: sas transport rphy object
- * @req:
  *
  * This used primarily for smp_utils.
  * Example:
diff --git a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
index b60fd7a3b571..cae7c1eaef34 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c
@@ -62,7 +62,7 @@
 /**
  * _mpt3sas_raise_sigio - notifiy app
  * @ioc: per adapter object
- * @event_data:
+ * @event_data: ?
  */
 static void
 _mpt3sas_raise_sigio(struct MPT3SAS_ADAPTER *ioc,
@@ -107,7 +107,7 @@ _mpt3sas_raise_sigio(struct MPT3SAS_ADAPTER *ioc,
 /**
  * mpt3sas_process_trigger_data - process the event data for the trigger
  * @ioc: per adapter object
- * @event_data:
+ * @event_data: ?
  */
 void
 mpt3sas_process_trigger_data(struct MPT3SAS_ADAPTER *ioc,
@@ -209,8 +209,8 @@ mpt3sas_trigger_master(struct MPT3SAS_ADAPTER *ioc, u32 trigger_bitmask)
 /**
  * mpt3sas_trigger_event - Event trigger handler
  * @ioc: per adapter object
- * @event:
- * @log_entry_qualifier:
+ * @event: ?
+ * @log_entry_qualifier: ?
  *
  */
 void
@@ -288,9 +288,9 @@ mpt3sas_trigger_event(struct MPT3SAS_ADAPTER *ioc, u16 event,
 /**
  * mpt3sas_trigger_scsi - SCSI trigger handler
  * @ioc: per adapter object
- * @sense_key:
- * @asc:
- * @ascq:
+ * @sense_key: ?
+ * @asc: ?
+ * @ascq: ?
  *
  */
 void
@@ -364,8 +364,8 @@ mpt3sas_trigger_scsi(struct MPT3SAS_ADAPTER *ioc, u8 sense_key, u8 asc,
 /**
  * mpt3sas_trigger_mpi - MPI trigger handler
  * @ioc: per adapter object
- * @ioc_status:
- * @loginfo:
+ * @ioc_status: ?
+ * @loginfo: ?
  *
  */
 void
diff --git a/drivers/scsi/mpt3sas/mpt3sas_warpdrive.c b/drivers/scsi/mpt3sas/mpt3sas_warpdrive.c
index 06e3f7d634b2..1b756055836d 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_warpdrive.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_warpdrive.c
@@ -295,9 +295,6 @@ mpt3sas_scsi_direct_io_set(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 direct_io)
  * @scmd: pointer to scsi command object
  * @raid_device: pointer to raid device data structure
  * @mpi_request: pointer to the SCSI_IO reqest message frame
- * @smid: system request message index
- *
- * Returns nothing
  */
 void
 mpt3sas_setup_direct_io(struct MPT3SAS_ADAPTER *ioc, struct scsi_cmnd *scmd,
