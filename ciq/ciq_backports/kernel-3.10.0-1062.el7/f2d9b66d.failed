drivers: base: Unified device connection lookup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [base] base: Unified device connection lookup (Torez Smith) [1657401]
Rebuild_FUZZ: 89.41%
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit f2d9b66d84f3ff5ea3aff111e6a403e04fa8bf37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f2d9b66d.failed

Several frameworks - clk, gpio, phy, pmw, etc. - maintain
lookup tables for describing connections and provide custom
API for handling them. This introduces a single generic
lookup table and API for the connections.

The motivation for this commit is centralizing the
connection lookup, but the goal is to ultimately extract the
connection descriptions also from firmware by using the
fwnode_graph_* functions and other mechanisms that are
available.

	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit f2d9b66d84f3ff5ea3aff111e6a403e04fa8bf37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/device_connection.rst
#	drivers/base/Makefile
#	include/linux/device.h
diff --cc drivers/base/Makefile
index 53c3fe1aeb29,12a7f64d35a9..000000000000
--- a/drivers/base/Makefile
+++ b/drivers/base/Makefile
@@@ -4,7 -5,8 +4,12 @@@ obj-y			:= component.o core.o bus.o dd.
  			   driver.o class.o platform.o \
  			   cpu.o firmware.o init.o map.o devres.o \
  			   attribute_container.o transport_class.o \
++<<<<<<< HEAD
 +			   topology.o container.o property.o
++=======
+ 			   topology.o container.o property.o cacheinfo.o \
+ 			   devcon.o
++>>>>>>> f2d9b66d84f3 (drivers: base: Unified device connection lookup)
  obj-$(CONFIG_DEVTMPFS)	+= devtmpfs.o
  obj-$(CONFIG_DMA_CMA) += dma-contiguous.o
  obj-y			+= power/
diff --cc include/linux/device.h
index c63101a20b87,204ff64279fd..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -701,12 -729,80 +701,54 @@@ struct device_dma_parameters 
  	unsigned long segment_boundary_mask;
  };
  
++<<<<<<< HEAD
 +/* RHEL7: Do not use this struct.  It is only here for KABI purposes. */
 +struct acpi_dev_node {
 +#ifdef CONFIG_ACPI
 +	RH_KABI_REPLACE(void	*handle,
 +		          struct acpi_device *companion)
++=======
+ /**
+  * struct device_connection - Device Connection Descriptor
+  * @endpoint: The names of the two devices connected together
+  * @id: Unique identifier for the connection
+  * @list: List head, private, for internal use only
+  */
+ struct device_connection {
+ 	const char		*endpoint[2];
+ 	const char		*id;
+ 	struct list_head	list;
+ };
+ 
+ void *device_connection_find_match(struct device *dev, const char *con_id,
+ 				void *data,
+ 				void *(*match)(struct device_connection *con,
+ 					       int ep, void *data));
+ 
+ struct device *device_connection_find(struct device *dev, const char *con_id);
+ 
+ void device_connection_add(struct device_connection *con);
+ void device_connection_remove(struct device_connection *con);
+ 
+ /**
+  * enum device_link_state - Device link states.
+  * @DL_STATE_NONE: The presence of the drivers is not being tracked.
+  * @DL_STATE_DORMANT: None of the supplier/consumer drivers is present.
+  * @DL_STATE_AVAILABLE: The supplier driver is present, but the consumer is not.
+  * @DL_STATE_CONSUMER_PROBE: The consumer is probing (supplier driver present).
+  * @DL_STATE_ACTIVE: Both the supplier and consumer drivers are present.
+  * @DL_STATE_SUPPLIER_UNBIND: The supplier driver is unbinding.
+  */
+ enum device_link_state {
+ 	DL_STATE_NONE = -1,
+ 	DL_STATE_DORMANT = 0,
+ 	DL_STATE_AVAILABLE,
+ 	DL_STATE_CONSUMER_PROBE,
+ 	DL_STATE_ACTIVE,
+ 	DL_STATE_SUPPLIER_UNBIND,
+ };
++>>>>>>> f2d9b66d84f3 (drivers: base: Unified device connection lookup)
  
 -/*
 - * Device link flags.
 - *
 - * STATELESS: The core won't track the presence of supplier/consumer drivers.
 - * AUTOREMOVE: Remove this link automatically on consumer driver unbind.
 - * PM_RUNTIME: If set, the runtime PM framework will use this link.
 - * RPM_ACTIVE: Run pm_runtime_get_sync() on the supplier during link creation.
 - */
 -#define DL_FLAG_STATELESS	BIT(0)
 -#define DL_FLAG_AUTOREMOVE	BIT(1)
 -#define DL_FLAG_PM_RUNTIME	BIT(2)
 -#define DL_FLAG_RPM_ACTIVE	BIT(3)
 -
 -/**
 - * struct device_link - Device link representation.
 - * @supplier: The device on the supplier end of the link.
 - * @s_node: Hook to the supplier device's list of links to consumers.
 - * @consumer: The device on the consumer end of the link.
 - * @c_node: Hook to the consumer device's list of links to suppliers.
 - * @status: The state of the link (with respect to the presence of drivers).
 - * @flags: Link flags.
 - * @rpm_active: Whether or not the consumer device is runtime-PM-active.
 - * @rcu_head: An RCU head to use for deferred execution of SRCU callbacks.
 - */
 -struct device_link {
 -	struct device *supplier;
 -	struct list_head s_node;
 -	struct device *consumer;
 -	struct list_head c_node;
 -	enum device_link_state status;
 -	u32 flags;
 -	bool rpm_active;
 -#ifdef CONFIG_SRCU
 -	struct rcu_head rcu_head;
  #endif
  };
  
* Unmerged path Documentation/device_connection.rst
* Unmerged path Documentation/device_connection.rst
* Unmerged path drivers/base/Makefile
diff --git a/drivers/base/devcon.c b/drivers/base/devcon.c
new file mode 100644
index 000000000000..d427e806cd73
--- /dev/null
+++ b/drivers/base/devcon.c
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0
+/**
+ * Device connections
+ *
+ * Copyright (C) 2018 Intel Corporation
+ * Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
+ */
+
+#include <linux/device.h>
+
+static DEFINE_MUTEX(devcon_lock);
+static LIST_HEAD(devcon_list);
+
+/**
+ * device_connection_find_match - Find physical connection to a device
+ * @dev: Device with the connection
+ * @con_id: Identifier for the connection
+ * @data: Data for the match function
+ * @match: Function to check and convert the connection description
+ *
+ * Find a connection with unique identifier @con_id between @dev and another
+ * device. @match will be used to convert the connection description to data the
+ * caller is expecting to be returned.
+ */
+void *device_connection_find_match(struct device *dev, const char *con_id,
+			       void *data,
+			       void *(*match)(struct device_connection *con,
+					      int ep, void *data))
+{
+	const char *devname = dev_name(dev);
+	struct device_connection *con;
+	void *ret = NULL;
+	int ep;
+
+	if (!match)
+		return NULL;
+
+	mutex_lock(&devcon_lock);
+
+	list_for_each_entry(con, &devcon_list, list) {
+		ep = match_string(con->endpoint, 2, devname);
+		if (ep < 0)
+			continue;
+
+		if (con_id && strcmp(con->id, con_id))
+			continue;
+
+		ret = match(con, !ep, data);
+		if (ret)
+			break;
+	}
+
+	mutex_unlock(&devcon_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(device_connection_find_match);
+
+extern struct bus_type platform_bus_type;
+extern struct bus_type pci_bus_type;
+extern struct bus_type i2c_bus_type;
+extern struct bus_type spi_bus_type;
+
+static struct bus_type *generic_match_buses[] = {
+	&platform_bus_type,
+#ifdef CONFIG_PCI
+	&pci_bus_type,
+#endif
+#ifdef CONFIG_I2C
+	&i2c_bus_type,
+#endif
+#ifdef CONFIG_SPI_MASTER
+	&spi_bus_type,
+#endif
+	NULL,
+};
+
+/* This tries to find the device from the most common bus types by name. */
+static void *generic_match(struct device_connection *con, int ep, void *data)
+{
+	struct bus_type *bus;
+	struct device *dev;
+
+	for (bus = generic_match_buses[0]; bus; bus++) {
+		dev = bus_find_device_by_name(bus, NULL, con->endpoint[ep]);
+		if (dev)
+			return dev;
+	}
+
+	/*
+	 * We only get called if a connection was found, tell the caller to
+	 * wait for the other device to show up.
+	 */
+	return ERR_PTR(-EPROBE_DEFER);
+}
+
+/**
+ * device_connection_find - Find two devices connected together
+ * @dev: Device with the connection
+ * @con_id: Identifier for the connection
+ *
+ * Find a connection with unique identifier @con_id between @dev and
+ * another device. On success returns handle to the device that is connected
+ * to @dev, with the reference count for the found device incremented. Returns
+ * NULL if no matching connection was found, or ERR_PTR(-EPROBE_DEFER) when a
+ * connection was found but the other device has not been enumerated yet.
+ */
+struct device *device_connection_find(struct device *dev, const char *con_id)
+{
+	return device_connection_find_match(dev, con_id, NULL, generic_match);
+}
+EXPORT_SYMBOL_GPL(device_connection_find);
+
+/**
+ * device_connection_add - Register a connection description
+ * @con: The connection description to be registered
+ */
+void device_connection_add(struct device_connection *con)
+{
+	mutex_lock(&devcon_lock);
+	list_add_tail(&con->list, &devcon_list);
+	mutex_unlock(&devcon_lock);
+}
+EXPORT_SYMBOL_GPL(device_connection_add);
+
+/**
+ * device_connections_remove - Unregister connection description
+ * @con: The connection description to be unregistered
+ */
+void device_connection_remove(struct device_connection *con)
+{
+	mutex_lock(&devcon_lock);
+	list_del(&con->list);
+	mutex_unlock(&devcon_lock);
+}
+EXPORT_SYMBOL_GPL(device_connection_remove);
* Unmerged path include/linux/device.h
