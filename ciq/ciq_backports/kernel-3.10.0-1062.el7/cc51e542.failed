x86/speculation/l1tf: Increase l1tf memory limit for Nehalem+

jira LE-1907
cve CVE-2019-11091
cve CVE-2018-12130
cve CVE-2018-12127
cve CVE-2018-12126
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] speculation/l1tf: Increase l1tf memory limit for Nehalem+ (Waiman Long) [1709296 1690358 1690348 1690335] {CVE-2018-12126 CVE-2018-12127 CVE-2018-12130 CVE-2019-11091}
Rebuild_FUZZ: 96.61%
commit-author Andi Kleen <ak@linux.intel.com>
commit cc51e5428ea54f575d49cfcede1d4cb3a72b4ec4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/cc51e542.failed

On Nehalem and newer core CPUs the CPU cache internally uses 44 bits
physical address space. The L1TF workaround is limited by this internal
cache address width, and needs to have one bit free there for the
mitigation to work.

Older client systems report only 36bit physical address space so the range
check decides that L1TF is not mitigated for a 36bit phys/32GB system with
some memory holes.

But since these actually have the larger internal cache width this warning
is bogus because it would only really be needed if the system had more than
43bits of memory.

Add a new internal x86_cache_bits field. Normally it is the same as the
physical bits field reported by CPUID, but for Nehalem and newerforce it to
be at least 44bits.

Change the L1TF memory size warning to use the new cache_bits field to
avoid bogus warnings and remove the bogus comment about memory size.

Fixes: 17dbca119312 ("x86/speculation/l1tf: Add sysfs reporting for l1tf")
	Reported-by: George Anchev <studio@anchev.net>
	Reported-by: Christopher Snowhill <kode54@gmail.com>
	Signed-off-by: Andi Kleen <ak@linux.intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: x86@kernel.org
	Cc: linux-kernel@vger.kernel.org
	Cc: Michael Hocko <mhocko@suse.com>
	Cc: vbabka@suse.cz
	Cc: stable@vger.kernel.org
Link: https://lkml.kernel.org/r/20180824170351.34874-1-andi@firstfloor.org

(cherry picked from commit cc51e5428ea54f575d49cfcede1d4cb3a72b4ec4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/processor.h
#	arch/x86/kernel/cpu/common.c
diff --cc arch/x86/include/asm/processor.h
index 1cec5508cffb,d53c54b842da..000000000000
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@@ -140,7 -132,10 +140,14 @@@ struct cpuinfo_x86 
  	/* Index into per_cpu list: */
  	u16			cpu_index;
  	u32			microcode;
++<<<<<<< HEAD
 +} __attribute__((__aligned__(SMP_CACHE_BYTES)));
++=======
+ 	/* Address space bits used by the cache internally */
+ 	u8			x86_cache_bits;
+ 	unsigned		initialized : 1;
+ } __randomize_layout;
++>>>>>>> cc51e5428ea5 (x86/speculation/l1tf: Increase l1tf memory limit for Nehalem+)
  
  struct cpuid_regs {
  	u32 eax, ebx, ecx, edx;
@@@ -191,9 -183,9 +198,13 @@@ extern const struct seq_operations cpui
  
  extern void cpu_detect(struct cpuinfo_x86 *c);
  
 -static inline unsigned long long l1tf_pfn_limit(void)
 +static inline unsigned long l1tf_pfn_limit(void)
  {
++<<<<<<< HEAD
 +	return BIT(boot_cpu_data.x86_phys_bits - 1 - PAGE_SHIFT) - 1;
++=======
+ 	return BIT_ULL(boot_cpu_data.x86_cache_bits - 1 - PAGE_SHIFT);
++>>>>>>> cc51e5428ea5 (x86/speculation/l1tf: Increase l1tf memory limit for Nehalem+)
  }
  
  extern void early_cpu_init(void);
diff --cc arch/x86/kernel/cpu/common.c
index dcd159d0c4dc,44c4ef3d989b..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -860,12 -919,7 +860,16 @@@ void get_cpu_cap(struct cpuinfo_x86 *c
  	else if (cpu_has(c, X86_FEATURE_PAE) || cpu_has(c, X86_FEATURE_PSE36))
  		c->x86_phys_bits = 36;
  #endif
++<<<<<<< HEAD
 +
 +	if (c->extended_cpuid_level >= 0x8000000a)
 +		c->x86_capability[15] = cpuid_edx(0x8000000a);
 +
 +	init_scattered_cpuid_features(c);
 +	init_speculation_control(c);
++=======
+ 	c->x86_cache_bits = c->x86_phys_bits;
++>>>>>>> cc51e5428ea5 (x86/speculation/l1tf: Increase l1tf memory limit for Nehalem+)
  }
  
  static void identify_cpu_without_cpuid(struct cpuinfo_x86 *c)
* Unmerged path arch/x86/include/asm/processor.h
diff --git a/arch/x86/kernel/cpu/bugs.c b/arch/x86/kernel/cpu/bugs.c
index 6ec1d2da76d1..8faa413b9237 100644
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@ -507,6 +507,45 @@ enum vmx_l1d_flush_state l1tf_vmx_mitigation = VMENTER_L1D_FLUSH_AUTO;
 EXPORT_SYMBOL_GPL(l1tf_vmx_mitigation);
 #endif
 
+/*
+ * These CPUs all support 44bits physical address space internally in the
+ * cache but CPUID can report a smaller number of physical address bits.
+ *
+ * The L1TF mitigation uses the top most address bit for the inversion of
+ * non present PTEs. When the installed memory reaches into the top most
+ * address bit due to memory holes, which has been observed on machines
+ * which report 36bits physical address bits and have 32G RAM installed,
+ * then the mitigation range check in l1tf_select_mitigation() triggers.
+ * This is a false positive because the mitigation is still possible due to
+ * the fact that the cache uses 44bit internally. Use the cache bits
+ * instead of the reported physical bits and adjust them on the affected
+ * machines to 44bit if the reported bits are less than 44.
+ */
+static void override_cache_bits(struct cpuinfo_x86 *c)
+{
+	if (c->x86 != 6)
+		return;
+
+	switch (c->x86_model) {
+	case INTEL_FAM6_NEHALEM:
+	case INTEL_FAM6_WESTMERE:
+	case INTEL_FAM6_SANDYBRIDGE:
+	case INTEL_FAM6_IVYBRIDGE:
+	case INTEL_FAM6_HASWELL_CORE:
+	case INTEL_FAM6_HASWELL_ULT:
+	case INTEL_FAM6_HASWELL_GT3E:
+	case INTEL_FAM6_BROADWELL_CORE:
+	case INTEL_FAM6_BROADWELL_GT3E:
+	case INTEL_FAM6_SKYLAKE_MOBILE:
+	case INTEL_FAM6_SKYLAKE_DESKTOP:
+	case INTEL_FAM6_KABYLAKE_MOBILE:
+	case INTEL_FAM6_KABYLAKE_DESKTOP:
+		if (c->x86_cache_bits < 44)
+			c->x86_cache_bits = 44;
+		break;
+	}
+}
+
 static void __init l1tf_select_mitigation(void)
 {
 	u64 half_pa;
@@ -514,6 +553,8 @@ static void __init l1tf_select_mitigation(void)
 	if (!boot_cpu_has_bug(X86_BUG_L1TF))
 		return;
 
+	override_cache_bits(&boot_cpu_data);
+
 	switch (l1tf_mitigation) {
 	case L1TF_MITIGATION_OFF:
 	case L1TF_MITIGATION_FLUSH_NOWARN:
@@ -533,11 +574,6 @@ static void __init l1tf_select_mitigation(void)
 	return;
 #endif
 
-	/*
-	 * This is extremely unlikely to happen because almost all
-	 * systems have far more MAX_PA/2 than RAM can be fit into
-	 * DIMM slots.
-	 */
 	half_pa = (u64)l1tf_pfn_limit() << PAGE_SHIFT;
 	if (e820_any_mapped(half_pa, ULLONG_MAX - half_pa, E820_RAM)) {
 		pr_warn("System has more than MAX_PA/2 memory. L1TF mitigation not effective.\n");
* Unmerged path arch/x86/kernel/cpu/common.c
