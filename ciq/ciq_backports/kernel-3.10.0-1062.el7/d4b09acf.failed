sunrpc: use-after-free in svc_process_common()

jira LE-1907
cve CVE-2018-16884
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Vasily Averin <vvs@virtuozzo.com>
commit d4b09acf924b84bae77cad090a9d108e70b43643
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d4b09acf.failed

if node have NFSv41+ mounts inside several net namespaces
it can lead to use-after-free in svc_process_common()

svc_process_common()
        /* Setup reply header */
        rqstp->rq_xprt->xpt_ops->xpo_prep_reply_hdr(rqstp); <<< HERE

svc_process_common() can use incorrect rqstp->rq_xprt,
its caller function bc_svc_process() takes it from serv->sv_bc_xprt.
The problem is that serv is global structure but sv_bc_xprt
is assigned per-netnamespace.

According to Trond, the whole "let's set up rqstp->rq_xprt
for the back channel" is nothing but a giant hack in order
to work around the fact that svc_process_common() uses it
to find the xpt_ops, and perform a couple of (meaningless
for the back channel) tests of xpt_flags.

All we really need in svc_process_common() is to be able to run
rqstp->rq_xprt->xpt_ops->xpo_prep_reply_hdr()

Bruce J Fields points that this xpo_prep_reply_hdr() call
is an awfully roundabout way just to do "svc_putnl(resv, 0);"
in the tcp case.

This patch does not initialiuze rqstp->rq_xprt in bc_svc_process(),
now it calls svc_process_common() with rqstp->rq_xprt = NULL.

To adjust reply header svc_process_common() just check
rqstp->rq_prot and calls svc_tcp_prep_reply_hdr() for tcp case.

To handle rqstp->rq_xprt = NULL case in functions called from
svc_process_common() patch intruduces net namespace pointer
svc_rqst->rq_bc_net and adjust SVC_NET() definition.
Some other function was also adopted to properly handle described case.

	Signed-off-by: Vasily Averin <vvs@virtuozzo.com>
	Cc: stable@vger.kernel.org
Fixes: 23c20ecd4475 ("NFS: callback up - users counting cleanup")
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit d4b09acf924b84bae77cad090a9d108e70b43643)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/sunrpc.h
#	net/sunrpc/svc.c
diff --cc include/trace/events/sunrpc.h
index c184df1b7502,8617f4fd6b70..000000000000
--- a/include/trace/events/sunrpc.h
+++ b/include/trace/events/sunrpc.h
@@@ -449,6 -559,34 +449,37 @@@ TRACE_EVENT(svc_recv
  			show_rqstp_flags(__entry->flags))
  );
  
++<<<<<<< HEAD
++=======
+ TRACE_EVENT(svc_process,
+ 	TP_PROTO(const struct svc_rqst *rqst, const char *name),
+ 
+ 	TP_ARGS(rqst, name),
+ 
+ 	TP_STRUCT__entry(
+ 		__field(u32, xid)
+ 		__field(u32, vers)
+ 		__field(u32, proc)
+ 		__string(service, name)
+ 		__string(addr, rqst->rq_xprt ?
+ 			 rqst->rq_xprt->xpt_remotebuf : "(null)")
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->xid = be32_to_cpu(rqst->rq_xid);
+ 		__entry->vers = rqst->rq_vers;
+ 		__entry->proc = rqst->rq_proc;
+ 		__assign_str(service, name);
+ 		__assign_str(addr, rqst->rq_xprt ?
+ 			     rqst->rq_xprt->xpt_remotebuf : "(null)");
+ 	),
+ 
+ 	TP_printk("addr=%s xid=0x%08x service=%s vers=%u proc=%u",
+ 			__get_str(addr), __entry->xid,
+ 			__get_str(service), __entry->vers, __entry->proc)
+ );
+ 
++>>>>>>> d4b09acf924b (sunrpc: use-after-free in svc_process_common())
  DECLARE_EVENT_CLASS(svc_rqst_event,
  
  	TP_PROTO(struct svc_rqst *rqst),
diff --cc net/sunrpc/svc.c
index 53f377d334c0,fb647bc01fc5..000000000000
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@@ -1152,6 -1234,21 +1153,24 @@@ svc_process_common(struct svc_rqst *rqs
  	  !(versp = progp->pg_vers[vers]))
  		goto err_bad_vers;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Some protocol versions (namely NFSv4) require some form of
+ 	 * congestion control.  (See RFC 7530 section 3.1 paragraph 2)
+ 	 * In other words, UDP is not allowed. We mark those when setting
+ 	 * up the svc_xprt, and verify that here.
+ 	 *
+ 	 * The spec is not very clear about what error should be returned
+ 	 * when someone tries to access a server that is listening on UDP
+ 	 * for lower versions. RPC_PROG_MISMATCH seems to be the closest
+ 	 * fit.
+ 	 */
+ 	if (versp->vs_need_cong_ctrl && rqstp->rq_xprt &&
+ 	    !test_bit(XPT_CONG_CTRL, &rqstp->rq_xprt->xpt_flags))
+ 		goto err_bad_vers;
+ 
++>>>>>>> d4b09acf924b (sunrpc: use-after-free in svc_process_common())
  	procp = versp->vs_proc + proc;
  	if (proc >= versp->vs_nproc || !procp->pc_func)
  		goto err_bad_proc;
diff --git a/include/linux/sunrpc/svc.h b/include/linux/sunrpc/svc.h
index 14b79000d085..2175c3a338ca 100644
--- a/include/linux/sunrpc/svc.h
+++ b/include/linux/sunrpc/svc.h
@@ -292,9 +292,12 @@ struct svc_rqst {
 	struct svc_cacherep *	rq_cacherep;	/* cache info */
 	struct task_struct	*rq_task;	/* service thread */
 	spinlock_t		rq_lock;	/* per-request lock */
+	struct net		*rq_bc_net;	/* pointer to backchannel's
+						 * net namespace
+						 */
 };
 
-#define SVC_NET(svc_rqst)	(svc_rqst->rq_xprt->xpt_net)
+#define SVC_NET(rqst) (rqst->rq_xprt ? rqst->rq_xprt->xpt_net : rqst->rq_bc_net)
 
 /*
  * Rigorous type checking on sockaddr type conversions
* Unmerged path include/trace/events/sunrpc.h
* Unmerged path net/sunrpc/svc.c
diff --git a/net/sunrpc/svc_xprt.c b/net/sunrpc/svc_xprt.c
index b60c1501c425..d5428d1022ff 100644
--- a/net/sunrpc/svc_xprt.c
+++ b/net/sunrpc/svc_xprt.c
@@ -472,10 +472,11 @@ out:
  */
 void svc_reserve(struct svc_rqst *rqstp, int space)
 {
+	struct svc_xprt *xprt = rqstp->rq_xprt;
+
 	space += rqstp->rq_res.head[0].iov_len;
 
-	if (space < rqstp->rq_reserved) {
-		struct svc_xprt *xprt = rqstp->rq_xprt;
+	if (xprt && space < rqstp->rq_reserved) {
 		atomic_sub((rqstp->rq_reserved - space), &xprt->xpt_reserved);
 		rqstp->rq_reserved = space;
 
diff --git a/net/sunrpc/svcsock.c b/net/sunrpc/svcsock.c
index 8150ebcac91f..c9e71a3904f4 100644
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@ -1211,7 +1211,7 @@ static int svc_tcp_sendto(struct svc_rqst *rqstp)
 /*
  * Setup response header. TCP has a 4B record length field.
  */
-static void svc_tcp_prep_reply_hdr(struct svc_rqst *rqstp)
+void svc_tcp_prep_reply_hdr(struct svc_rqst *rqstp)
 {
 	struct kvec *resv = &rqstp->rq_res.head[0];
 
