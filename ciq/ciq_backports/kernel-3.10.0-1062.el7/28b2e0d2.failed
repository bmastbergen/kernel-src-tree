net: phy: remove parameter new_link from phy_mac_interrupt()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] phy: remove parameter new_link from phy_mac_interrupt() (Ivan Vecera) [1655590]
Rebuild_FUZZ: 95.65%
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit 28b2e0d2cd132284ad69fcea4b7cf6b7d0662c2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/28b2e0d2.failed

I see two issues with parameter new_link:

1. It's not needed. See also phy_interrupt(), works w/o this parameter.
   phy_mac_interrupt sets the state to PHY_CHANGELINK and triggers the
   state machine which then calls phy_read_status. And phy_read_status
   updates the link state.

2. phy_mac_interrupt is used in interrupt context and getting the link
   state may sleep (at least when having to access the PHY registers
   via MDIO bus).

So let's remove it.

	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Tested-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 28b2e0d2cd132284ad69fcea4b7cf6b7d0662c2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/genet/bcmgenet.c
#	drivers/net/phy/phy.c
#	include/linux/phy.h
diff --cc drivers/net/phy/phy.c
index 9e5ca8eeda8a,f3313a129531..000000000000
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@@ -990,10 -1054,15 +990,19 @@@ void phy_state_machine(struct work_stru
  				   PHY_STATE_TIME * HZ);
  }
  
++<<<<<<< HEAD
 +void phy_mac_interrupt(struct phy_device *phydev, int new_link)
++=======
+ /**
+  * phy_mac_interrupt - MAC says the link has changed
+  * @phydev: phy_device struct with changed link
+  *
+  * The MAC layer is able to indicate there has been a change in the PHY link
+  * status. Trigger the state machine and work a work queue.
+  */
+ void phy_mac_interrupt(struct phy_device *phydev)
++>>>>>>> 28b2e0d2cd13 (net: phy: remove parameter new_link from phy_mac_interrupt())
  {
- 	phydev->link = new_link;
- 
  	/* Trigger a state machine change */
  	queue_work(system_power_efficient_wq, &phydev->phy_queue);
  }
diff --cc include/linux/phy.h
index 9542c61131f8,47715a3115b0..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -676,20 -928,49 +676,26 @@@ int genphy_update_link(struct phy_devic
  int genphy_read_status(struct phy_device *phydev);
  int genphy_suspend(struct phy_device *phydev);
  int genphy_resume(struct phy_device *phydev);
 -int genphy_loopback(struct phy_device *phydev, bool enable);
  int genphy_soft_reset(struct phy_device *phydev);
 -static inline int genphy_no_soft_reset(struct phy_device *phydev)
 -{
 -	return 0;
 -}
 -
 -/* Clause 45 PHY */
 -int genphy_c45_restart_aneg(struct phy_device *phydev);
 -int genphy_c45_aneg_done(struct phy_device *phydev);
 -int genphy_c45_read_link(struct phy_device *phydev, u32 mmd_mask);
 -int genphy_c45_read_lpa(struct phy_device *phydev);
 -int genphy_c45_read_pma(struct phy_device *phydev);
 -int genphy_c45_pma_setup_forced(struct phy_device *phydev);
 -int genphy_c45_an_disable_aneg(struct phy_device *phydev);
 -int genphy_c45_read_mdix(struct phy_device *phydev);
 -
 -static inline int phy_read_status(struct phy_device *phydev)
 -{
 -	if (!phydev->drv)
 -		return -EIO;
 -
 -	if (phydev->drv->read_status)
 -		return phydev->drv->read_status(phydev);
 -	else
 -		return genphy_read_status(phydev);
 -}
 -
  void phy_driver_unregister(struct phy_driver *drv);
  void phy_drivers_unregister(struct phy_driver *drv, int n);
 -int phy_driver_register(struct phy_driver *new_driver, struct module *owner);
 -int phy_drivers_register(struct phy_driver *new_driver, int n,
 -			 struct module *owner);
 +int phy_driver_register(struct phy_driver *new_driver);
 +int phy_drivers_register(struct phy_driver *new_driver, int n);
  void phy_state_machine(struct work_struct *work);
++<<<<<<< HEAD
 +void phy_change(struct work_struct *work);
 +void phy_mac_interrupt(struct phy_device *phydev, int new_link);
++=======
+ void phy_change(struct phy_device *phydev);
+ void phy_change_work(struct work_struct *work);
+ void phy_mac_interrupt(struct phy_device *phydev);
++>>>>>>> 28b2e0d2cd13 (net: phy: remove parameter new_link from phy_mac_interrupt())
  void phy_start_machine(struct phy_device *phydev);
  void phy_stop_machine(struct phy_device *phydev);
 -void phy_trigger_machine(struct phy_device *phydev, bool sync);
  int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 -void phy_ethtool_ksettings_get(struct phy_device *phydev,
 -			       struct ethtool_link_ksettings *cmd);
 +int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 +int phy_ethtool_ksettings_get(struct phy_device *phydev,
 +			      struct ethtool_link_ksettings *cmd);
  int phy_ethtool_ksettings_set(struct phy_device *phydev,
  			      const struct ethtool_link_ksettings *cmd);
  int phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd);
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmgenet.c
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmgenet.c
* Unmerged path drivers/net/phy/phy.c
* Unmerged path include/linux/phy.h
