kernel/module.c: Only return -EEXIST for modules that have finished loading

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [kernel] modules: Only return -EEXIST for modules that have finished loading (Prarit Bhargava) [1658812]
Rebuild_FUZZ: 92.96%
commit-author Prarit Bhargava <prarit@redhat.com>
commit 6e6de3dee51a439f76eb73c22ae2ffd2c9384712
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6e6de3de.failed

Microsoft HyperV disables the X86_FEATURE_SMCA bit on AMD systems, and
linux guests boot with repeated errors:

amd64_edac_mod: Unknown symbol amd_unregister_ecc_decoder (err -2)
amd64_edac_mod: Unknown symbol amd_register_ecc_decoder (err -2)
amd64_edac_mod: Unknown symbol amd_report_gart_errors (err -2)
amd64_edac_mod: Unknown symbol amd_unregister_ecc_decoder (err -2)
amd64_edac_mod: Unknown symbol amd_register_ecc_decoder (err -2)
amd64_edac_mod: Unknown symbol amd_report_gart_errors (err -2)

The warnings occur because the module code erroneously returns -EEXIST
for modules that have failed to load and are in the process of being
removed from the module list.

module amd64_edac_mod has a dependency on module edac_mce_amd.  Using
modules.dep, systemd will load edac_mce_amd for every request of
amd64_edac_mod.  When the edac_mce_amd module loads, the module has
state MODULE_STATE_UNFORMED and once the module load fails and the state
becomes MODULE_STATE_GOING.  Another request for edac_mce_amd module
executes and add_unformed_module() will erroneously return -EEXIST even
though the previous instance of edac_mce_amd has MODULE_STATE_GOING.
Upon receiving -EEXIST, systemd attempts to load amd64_edac_mod, which
fails because of unknown symbols from edac_mce_amd.

add_unformed_module() must wait to return for any case other than
MODULE_STATE_LIVE to prevent a race between multiple loads of
dependent modules.

	Signed-off-by: Prarit Bhargava <prarit@redhat.com>
	Signed-off-by: Barret Rhoden <brho@google.com>
	Cc: David Arcari <darcari@redhat.com>
	Cc: Jessica Yu <jeyu@kernel.org>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Jessica Yu <jeyu@kernel.org>
(cherry picked from commit 6e6de3dee51a439f76eb73c22ae2ffd2c9384712)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/module.c
diff --cc kernel/module.c
index 0d9ef67fd99a,1e7dcbe527af..000000000000
--- a/kernel/module.c
+++ b/kernel/module.c
@@@ -3331,10 -3389,15 +3331,15 @@@ static bool finished_loading(const cha
  	struct module *mod;
  	bool ret;
  
 -	/*
 -	 * The module_mutex should not be a heavily contended lock;
 -	 * if we get the occasional sleep here, we'll go an extra iteration
 -	 * in the wait_event_interruptible(), which is harmless.
 -	 */
 -	sched_annotate_sleep();
  	mutex_lock(&module_mutex);
++<<<<<<< HEAD
 +	mod = find_module_all(name, true);
 +	ret = !mod || mod->state == MODULE_STATE_LIVE
 +		|| mod->state == MODULE_STATE_GOING;
++=======
+ 	mod = find_module_all(name, strlen(name), true);
+ 	ret = !mod || mod->state == MODULE_STATE_LIVE;
++>>>>>>> 6e6de3dee51a (kernel/module.c: Only return -EEXIST for modules that have finished loading)
  	mutex_unlock(&module_mutex);
  
  	return ret;
@@@ -3457,9 -3585,9 +3462,15 @@@ static int add_unformed_module(struct m
  
  again:
  	mutex_lock(&module_mutex);
++<<<<<<< HEAD
 +	if ((old = find_module_all(mod->name, true)) != NULL) {
 +		if (old->state == MODULE_STATE_COMING
 +		    || old->state == MODULE_STATE_UNFORMED) {
++=======
+ 	old = find_module_all(mod->name, strlen(mod->name), true);
+ 	if (old != NULL) {
+ 		if (old->state != MODULE_STATE_LIVE) {
++>>>>>>> 6e6de3dee51a (kernel/module.c: Only return -EEXIST for modules that have finished loading)
  			/* Wait in case it fails to load. */
  			mutex_unlock(&module_mutex);
  			err = wait_event_interruptible(module_wq,
* Unmerged path kernel/module.c
