ipmi: Use more common logging styles

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Joe Perches <joe@perches.com>
commit 25880f7d61a4f2fdda29cadae55985431df82c5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/25880f7d.failed

Add and use #define pr_fmt/dev_fmt, and remove #define PFX

This also prefixes some messages that were not previously prefixed.

Miscellanea:

o Convert printk(KERN_<level> to pr_<level>(
o Use %s, __func__ where appropriate

	Signed-off-by: Joe Perches <joe@perches.com>
	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 25880f7d61a4f2fdda29cadae55985431df82c5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_hotmod.c
#	drivers/char/ipmi/ipmi_si_intf.c
#	drivers/char/ipmi/ipmi_watchdog.c
diff --cc drivers/char/ipmi/ipmi_si_hotmod.c
index 280585feb6d1,c0067fd0480d..000000000000
--- a/drivers/char/ipmi/ipmi_si_hotmod.c
+++ b/drivers/char/ipmi/ipmi_si_hotmod.c
@@@ -4,15 -5,14 +4,22 @@@
   * Handling for dynamically adding/removing IPMI devices through
   * a module parameter (and thus sysfs).
   */
+ 
+ #define pr_fmt(fmt) "ipmi_hotmod: " fmt
+ 
  #include <linux/moduleparam.h>
  #include <linux/ipmi.h>
 +#include <linux/ctype.h>
 +#include <linux/slab.h>
  #include "ipmi_si.h"
  
++<<<<<<< HEAD
 +#define PFX "ipmi_hotmod: "
 +
 +static int hotmod_handler(const char *val, struct kernel_param *kp);
++=======
+ static int hotmod_handler(const char *val, const struct kernel_param *kp);
++>>>>>>> 25880f7d61a4 (ipmi: Use more common logging styles)
  
  module_param_call(hotmod, hotmod_handler, NULL, NULL, 0200);
  MODULE_PARM_DESC(hotmod, "Add and remove interfaces.  See"
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 56b014f8c087,132bb508cd19..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -2047,10 -1922,9 +2047,10 @@@ static int try_smi_init(struct smi_inf
  {
  	int rv = 0;
  	int i;
 +	struct ipmi_shadow_smi_handlers *shadow_handlers;
  	char *init_name = NULL;
  
- 	pr_info(PFX "Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n",
+ 	pr_info("Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n",
  		ipmi_addr_src_to_str(new_smi->io.addr_source),
  		si_to_str[new_smi->io.si_type],
  		addr_space_to_str[new_smi->io.addr_type],
@@@ -2088,9 -1962,9 +2088,9 @@@
  		 * else (like PCI), then register a new one.
  		 */
  		new_smi->pdev = platform_device_alloc("ipmi_si",
 -						      new_smi->si_num);
 +						      new_smi->intf_num);
  		if (!new_smi->pdev) {
- 			pr_err(PFX "Unable to allocate platform device\n");
+ 			pr_err("Unable to allocate platform device\n");
  			rv = -ENOMEM;
  			goto out_err;
  		}
@@@ -2267,17 -2097,7 +2267,21 @@@ static int init_ipmi_si(void
  	if (initialized)
  		return 0;
  
++<<<<<<< HEAD
 +	/* RHEL7-only - Init ipmi_shadow_smi_handlers
 +	 * The instance of struct ipmi_shadow_smi_handlers is located in
 +	 * ipmi_msghandler.c. Locating it in this file would cause a
 +	 * module dependency loop, because ipmi_msghandler would then
 +	 * depend on ipmi_si, which already depends on ipmi_msghandler.
 +	 */
 +	shadow_handlers = ipmi_get_shadow_smi_handlers();
 +	shadow_handlers->handlers = &handlers;
 +	shadow_handlers->set_need_watch = set_need_watch;
 +
 +	pr_info("IPMI System Interface driver.\n");
++=======
+ 	pr_info("IPMI System Interface driver\n");
++>>>>>>> 25880f7d61a4 (ipmi: Use more common logging styles)
  
  	/* If the user gave us a device, they presumably want us to use it */
  	if (!ipmi_si_hardcode_find_bmc())
diff --cc drivers/char/ipmi/ipmi_watchdog.c
index 711c15af34d3,2924a4bc4a32..000000000000
--- a/drivers/char/ipmi/ipmi_watchdog.c
+++ b/drivers/char/ipmi/ipmi_watchdog.c
@@@ -8,29 -9,10 +8,31 @@@
   *         source@mvista.com
   *
   * Copyright 2002 MontaVista Software Inc.
 + *
 + *  This program is free software; you can redistribute it and/or modify it
 + *  under the terms of the GNU General Public License as published by the
 + *  Free Software Foundation; either version 2 of the License, or (at your
 + *  option) any later version.
 + *
 + *
 + *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 + *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 + *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 + *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 + *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 + *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 + *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 + *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 + *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 + *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 + *
 + *  You should have received a copy of the GNU General Public License along
 + *  with this program; if not, write to the Free Software Foundation, Inc.,
 + *  675 Mass Ave, Cambridge, MA 02139, USA.
   */
  
+ #define pr_fmt(fmt) "IPMI Watchdog: " fmt
+ 
  #include <linux/module.h>
  #include <linux/moduleparam.h>
  #include <linux/ipmi.h>
@@@ -437,13 -406,10 +437,20 @@@ static int i_ipmi_set_timeout(struct ip
  				      smi_msg,
  				      recv_msg,
  				      1);
++<<<<<<< HEAD
 +	if (rv) {
 +		printk(KERN_WARNING PFX "set timeout error: %d\n",
 +		       rv);
 +	}
++=======
+ 	if (rv)
+ 		pr_warn("set timeout error: %d\n", rv);
+ 	else if (send_heartbeat_now)
+ 		*send_heartbeat_now = hbnow;
++>>>>>>> 25880f7d61a4 (ipmi: Use more common logging styles)
 +
 +	if (send_heartbeat_now)
 +	    *send_heartbeat_now = hbnow;
  
  	return rv;
  }
@@@ -645,26 -569,23 +652,34 @@@ restart
  				      0,
  				      &msg,
  				      NULL,
 -				      &smi_msg,
 -				      &recv_msg,
 +				      &heartbeat_smi_msg,
 +				      &heartbeat_recv_msg,
  				      1);
  	if (rv) {
++<<<<<<< HEAD
 +		mutex_unlock(&heartbeat_lock);
 +		printk(KERN_WARNING PFX "heartbeat failure: %d\n",
 +		       rv);
++=======
+ 		pr_warn("heartbeat send failure: %d\n", rv);
++>>>>>>> 25880f7d61a4 (ipmi: Use more common logging styles)
  		return rv;
  	}
  
  	/* Wait for the heartbeat to be sent. */
 -	wait_for_completion(&msg_wait);
 +	wait_for_completion(&heartbeat_wait);
  
 -	if (recv_msg.msg.data[0] == IPMI_WDOG_TIMER_NOT_INIT_RESP)  {
 +	if (heartbeat_recv_msg.msg.data[0] == IPMI_WDOG_TIMER_NOT_INIT_RESP)  {
  		timeout_retries++;
  		if (timeout_retries > 3) {
++<<<<<<< HEAD
 +			printk(KERN_ERR PFX ": Unable to restore the IPMI"
 +			       " watchdog's settings, giving up.\n");
++=======
+ 			pr_err("Unable to restore the IPMI watchdog's settings, giving up\n");
++>>>>>>> 25880f7d61a4 (ipmi: Use more common logging styles)
  			rv = -EIO;
 -			goto out;
 +			goto out_unlock;
  		}
  
  		/*
@@@ -673,18 -594,17 +688,23 @@@
  		 * to restore the timer's info.  Note that we still hold
  		 * the heartbeat lock, to keep a heartbeat from happening
  		 * in this process, so must say no heartbeat to avoid a
 -		 * deadlock on this mutex
 +		 * deadlock on this mutex.
  		 */
 -		rv = _ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);
 +		rv = ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);
  		if (rv) {
++<<<<<<< HEAD
 +			printk(KERN_ERR PFX ": Unable to send the command to"
 +			       " set the watchdog's settings, giving up.\n");
 +			goto out_unlock;
++=======
+ 			pr_err("Unable to send the command to set the watchdog's settings, giving up\n");
+ 			goto out;
++>>>>>>> 25880f7d61a4 (ipmi: Use more common logging styles)
  		}
  
 -		/* Might need a heartbeat send, go ahead and do it. */
 +		/* We might need a new heartbeat, so do it now */
  		goto restart;
 -	} else if (recv_msg.msg.data[0] != 0) {
 +	} else if (heartbeat_recv_msg.msg.data[0] != 0) {
  		/*
  		 * Got an error in the heartbeat response.  It was already
  		 * reported in ipmi_wdog_msg_handler, but we should return
@@@ -916,11 -871,12 +936,10 @@@ static int ipmi_close(struct inode *ino
  {
  	if (iminor(ino) == WATCHDOG_MINOR) {
  		if (expect_close == 42) {
 -			mutex_lock(&ipmi_watchdog_mutex);
  			ipmi_watchdog_state = WDOG_TIMEOUT_NONE;
 -			_ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);
 -			mutex_unlock(&ipmi_watchdog_mutex);
 +			ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);
  		} else {
- 			pr_crit(PFX
- 				"Unexpected close, not stopping watchdog!\n");
+ 			pr_crit("Unexpected close, not stopping watchdog!\n");
  			ipmi_heartbeat();
  		}
  		clear_bit(0, &ipmi_wdog_open);
@@@ -1095,19 -1077,20 +1114,25 @@@ static void ipmi_unregister_watchdog(in
  	 * pointers to our buffers, we want to make sure they are done before
  	 * we release our memory.
  	 */
 -	while (atomic_read(&msg_tofree))
 -		msg_free_smi(NULL);
 -
 -	mutex_lock(&ipmi_watchdog_mutex);
 +	while (atomic_read(&set_timeout_tofree))
 +		schedule_timeout_uninterruptible(1);
  
  	/* Disconnect from IPMI. */
++<<<<<<< HEAD
 +	rv = ipmi_destroy_user(watchdog_user);
 +	if (rv) {
 +		printk(KERN_WARNING PFX "error unlinking from IPMI: %d\n",
 +		       rv);
 +	}
 +	watchdog_user = NULL;
++=======
+ 	rv = ipmi_destroy_user(loc_user);
+ 	if (rv)
+ 		pr_warn("error unlinking from IPMI: %d\n",  rv);
++>>>>>>> 25880f7d61a4 (ipmi: Use more common logging styles)
  
 -	/* If it comes back, restart it properly. */
 -	ipmi_start_timer_on_heartbeat = 1;
 -
 -	mutex_unlock(&ipmi_watchdog_mutex);
 + out:
 +	return;
  }
  
  #ifdef HAVE_DIE_NMI
@@@ -1141,9 -1124,9 +1166,9 @@@ ipmi_nmi(unsigned int val, struct pt_re
  		/* On some machines, the heartbeat will give
  		   an error and not work unless we re-enable
  		   the timer.   So do so. */
 -		atomic_set(&pretimeout_since_last_heartbeat, 1);
 +		pretimeout_since_last_heartbeat = 1;
  		if (atomic_inc_and_test(&preop_panic_excl))
- 			nmi_panic(regs, PFX "pre-timeout");
+ 			nmi_panic(regs, "pre-timeout");
  	}
  
  	return NMI_HANDLED;
@@@ -1358,10 -1308,8 +1382,10 @@@ static int __init ipmi_wdog_init(void
  		if (nmi_handler_registered)
  			unregister_nmi_handler(NMI_UNKNOWN, "ipmi");
  #endif
 +		atomic_notifier_chain_unregister(&panic_notifier_list,
 +						 &wdog_panic_notifier);
  		unregister_reboot_notifier(&wdog_reboot_notifier);
- 		pr_warn(PFX "can't register smi watcher\n");
+ 		pr_warn("can't register smi watcher\n");
  		return rv;
  	}
  
diff --git a/drivers/char/ipmi/ipmi_poweroff.c b/drivers/char/ipmi/ipmi_poweroff.c
index 2919367089bc..3aeb9288e656 100644
--- a/drivers/char/ipmi/ipmi_poweroff.c
+++ b/drivers/char/ipmi/ipmi_poweroff.c
@@ -31,6 +31,9 @@
  *  with this program; if not, write to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
+
+#define pr_fmt(fmt) "IPMI poweroff: " fmt
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/proc_fs.h>
@@ -41,8 +44,6 @@
 #include <linux/ipmi.h>
 #include <linux/ipmi_smi.h>
 
-#define PFX "IPMI poweroff: "
-
 static void ipmi_po_smi_gone(int if_num);
 static void ipmi_po_new_smi(int if_num, struct device *device);
 
@@ -212,7 +213,7 @@ static void pps_poweroff_atca(ipmi_user_t user)
 	smi_addr.channel = IPMI_BMC_CHANNEL;
 	smi_addr.lun = 0;
 
-	printk(KERN_INFO PFX "PPS powerdown hook used");
+	pr_info("PPS powerdown hook used\n");
 
 	send_msg.netfn = IPMI_NETFN_OEM;
 	send_msg.cmd = IPMI_ATCA_PPS_GRACEFUL_RESTART;
@@ -221,10 +222,9 @@ static void pps_poweroff_atca(ipmi_user_t user)
 	rv = ipmi_request_in_rc_mode(user,
 				     (struct ipmi_addr *) &smi_addr,
 				     &send_msg);
-	if (rv && rv != IPMI_UNKNOWN_ERR_COMPLETION_CODE) {
-		printk(KERN_ERR PFX "Unable to send ATCA ,"
-		       " IPMI error 0x%x\n", rv);
-	}
+	if (rv && rv != IPMI_UNKNOWN_ERR_COMPLETION_CODE)
+		pr_err("Unable to send ATCA, IPMI error 0x%x\n", rv);
+
 	return;
 }
 
@@ -254,12 +254,10 @@ static int ipmi_atca_detect(ipmi_user_t user)
 					    (struct ipmi_addr *) &smi_addr,
 					    &send_msg);
 
-	printk(KERN_INFO PFX "ATCA Detect mfg 0x%X prod 0x%X\n",
-	       mfg_id, prod_id);
+	pr_info("ATCA Detect mfg 0x%X prod 0x%X\n", mfg_id, prod_id);
 	if ((mfg_id == IPMI_MOTOROLA_MANUFACTURER_ID)
 	    && (prod_id == IPMI_MOTOROLA_PPS_IPMC_PRODUCT_ID)) {
-		printk(KERN_INFO PFX
-		       "Installing Pigeon Point Systems Poweroff Hook\n");
+		pr_info("Installing Pigeon Point Systems Poweroff Hook\n");
 		atca_oem_poweroff_hook = pps_poweroff_atca;
 	}
 	return !rv;
@@ -279,7 +277,7 @@ static void ipmi_poweroff_atca(ipmi_user_t user)
 	smi_addr.channel = IPMI_BMC_CHANNEL;
 	smi_addr.lun = 0;
 
-	printk(KERN_INFO PFX "Powering down via ATCA power command\n");
+	pr_info("Powering down via ATCA power command\n");
 
 	/*
 	 * Power down
@@ -302,8 +300,8 @@ static void ipmi_poweroff_atca(ipmi_user_t user)
 	 * return code
 	 */
 	if (rv && rv != IPMI_UNKNOWN_ERR_COMPLETION_CODE) {
-		printk(KERN_ERR PFX "Unable to send ATCA powerdown message,"
-		       " IPMI error 0x%x\n", rv);
+		pr_err("Unable to send ATCA powerdown message, IPMI error 0x%x\n",
+		       rv);
 		goto out;
 	}
 
@@ -354,7 +352,7 @@ static void ipmi_poweroff_cpi1(ipmi_user_t user)
 	smi_addr.channel = IPMI_BMC_CHANNEL;
 	smi_addr.lun = 0;
 
-	printk(KERN_INFO PFX "Powering down via CPI1 power command\n");
+	pr_info("Powering down via CPI1 power command\n");
 
 	/*
 	 * Get IPMI ipmb address
@@ -502,7 +500,7 @@ static void ipmi_poweroff_chassis(ipmi_user_t user)
 	smi_addr.lun = 0;
 
  powercyclefailed:
-	printk(KERN_INFO PFX "Powering %s via IPMI chassis control command\n",
+	pr_info("Powering %s via IPMI chassis control command\n",
 		(poweroff_powercycle ? "cycle" : "down"));
 
 	/*
@@ -522,14 +520,14 @@ static void ipmi_poweroff_chassis(ipmi_user_t user)
 	if (rv) {
 		if (poweroff_powercycle) {
 			/* power cycle failed, default to power down */
-			printk(KERN_ERR PFX "Unable to send chassis power " \
-			       "cycle message, IPMI error 0x%x\n", rv);
+			pr_err("Unable to send chassis power cycle message, IPMI error 0x%x\n",
+			       rv);
 			poweroff_powercycle = 0;
 			goto powercyclefailed;
 		}
 
-		printk(KERN_ERR PFX "Unable to send chassis power " \
-		       "down message, IPMI error 0x%x\n", rv);
+		pr_err("Unable to send chassis power down message, IPMI error 0x%x\n",
+		       rv);
 	}
 }
 
@@ -591,8 +589,7 @@ static void ipmi_po_new_smi(int if_num, struct device *device)
 	rv = ipmi_create_user(if_num, &ipmi_poweroff_handler, NULL,
 			      &ipmi_user);
 	if (rv) {
-		printk(KERN_ERR PFX "could not create IPMI user, error %d\n",
-		       rv);
+		pr_err("could not create IPMI user, error %d\n", rv);
 		return;
 	}
 
@@ -614,14 +611,13 @@ static void ipmi_po_new_smi(int if_num, struct device *device)
 					    (struct ipmi_addr *) &smi_addr,
 					    &send_msg);
 	if (rv) {
-		printk(KERN_ERR PFX "Unable to send IPMI get device id info,"
-		       " IPMI error 0x%x\n", rv);
+		pr_err("Unable to send IPMI get device id info, IPMI error 0x%x\n",
+		       rv);
 		goto out_err;
 	}
 
 	if (halt_recv_msg.msg.data_len < 12) {
-		printk(KERN_ERR PFX "(chassis) IPMI get device id info too,"
-		       " short, was %d bytes, needed %d bytes\n",
+		pr_err("(chassis) IPMI get device id info too short, was %d bytes, needed %d bytes\n",
 		       halt_recv_msg.msg.data_len, 12);
 		goto out_err;
 	}
@@ -642,14 +638,13 @@ static void ipmi_po_new_smi(int if_num, struct device *device)
 	}
 
  out_err:
-	printk(KERN_ERR PFX "Unable to find a poweroff function that"
-	       " will work, giving up\n");
+	pr_err("Unable to find a poweroff function that will work, giving up\n");
 	ipmi_destroy_user(ipmi_user);
 	return;
 
  found:
-	printk(KERN_INFO PFX "Found a %s style poweroff function\n",
-	       poweroff_functions[i].platform_type);
+	pr_info("Found a %s style poweroff function\n",
+		poweroff_functions[i].platform_type);
 	specific_poweroff_func = poweroff_functions[i].poweroff_func;
 	old_poweroff_func = pm_power_off;
 	pm_power_off = ipmi_poweroff_function;
@@ -712,16 +707,15 @@ static int __init ipmi_poweroff_init(void)
 {
 	int rv;
 
-	printk(KERN_INFO "Copyright (C) 2004 MontaVista Software -"
-	       " IPMI Powerdown via sys_reboot.\n");
+	pr_info("Copyright (C) 2004 MontaVista Software - IPMI Powerdown via sys_reboot\n");
 
 	if (poweroff_powercycle)
-		printk(KERN_INFO PFX "Power cycle is enabled.\n");
+		pr_info("Power cycle is enabled\n");
 
 #ifdef CONFIG_PROC_FS
 	ipmi_table_header = register_sysctl_table(ipmi_root_table);
 	if (!ipmi_table_header) {
-		printk(KERN_ERR PFX "Unable to register powercycle sysctl\n");
+		pr_err("Unable to register powercycle sysctl\n");
 		rv = -ENOMEM;
 		goto out_err;
 	}
@@ -732,7 +726,7 @@ static int __init ipmi_poweroff_init(void)
 #ifdef CONFIG_PROC_FS
 	if (rv) {
 		unregister_sysctl_table(ipmi_table_header);
-		printk(KERN_ERR PFX "Unable to register SMI watcher: %d\n", rv);
+		pr_err("Unable to register SMI watcher: %d\n", rv);
 		goto out_err;
 	}
 
@@ -755,8 +749,7 @@ static void __exit ipmi_poweroff_cleanup(void)
 	if (ready) {
 		rv = ipmi_destroy_user(ipmi_user);
 		if (rv)
-			printk(KERN_ERR PFX "could not cleanup the IPMI"
-			       " user: 0x%x\n", rv);
+			pr_err("could not cleanup the IPMI user: 0x%x\n", rv);
 		pm_power_off = old_poweroff_func;
 	}
 }
diff --git a/drivers/char/ipmi/ipmi_si_hardcode.c b/drivers/char/ipmi/ipmi_si_hardcode.c
index 6383058dcd0d..262de65be8f2 100644
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@ -1,8 +1,9 @@
 
+#define pr_fmt(fmt) "ipmi_hardcode: " fmt
+
 #include <linux/moduleparam.h>
 #include "ipmi_si.h"
 
-#define PFX "ipmi_hardcode: "
 /*
  * There can be 4 IO ports passed in (with or without IRQs), 4 addresses,
  * a default IO port, and 1 ACPI/SPMI address.  That sets SI_MAX_DRIVERS.
@@ -99,7 +100,7 @@ int ipmi_si_hardcode_find_bmc(void)
 			continue;
 
 		io.addr_source = SI_HARDCODED;
-		pr_info(PFX "probing via hardcoded address\n");
+		pr_info("probing via hardcoded address\n");
 
 		if (!si_type[i] || strcmp(si_type[i], "kcs") == 0) {
 			io.si_type = SI_KCS;
@@ -108,7 +109,7 @@ int ipmi_si_hardcode_find_bmc(void)
 		} else if (strcmp(si_type[i], "bt") == 0) {
 			io.si_type = SI_BT;
 		} else {
-			pr_warn(PFX "Interface type specified for interface %d, was invalid: %s\n",
+			pr_warn("Interface type specified for interface %d, was invalid: %s\n",
 				i, si_type[i]);
 			continue;
 		}
@@ -122,7 +123,7 @@ int ipmi_si_hardcode_find_bmc(void)
 			io.addr_data = addrs[i];
 			io.addr_type = IPMI_MEM_ADDR_SPACE;
 		} else {
-			pr_warn(PFX "Interface type specified for interface %d, but port and address were not set or set to zero.\n",
+			pr_warn("Interface type specified for interface %d, but port and address were not set or set to zero\n",
 				i);
 			continue;
 		}
* Unmerged path drivers/char/ipmi/ipmi_si_hotmod.c
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
diff --git a/drivers/char/ipmi/ipmi_si_pci.c b/drivers/char/ipmi/ipmi_si_pci.c
index 88423cba866e..14474f303b11 100644
--- a/drivers/char/ipmi/ipmi_si_pci.c
+++ b/drivers/char/ipmi/ipmi_si_pci.c
@@ -3,12 +3,13 @@
  *
  * Handling for IPMI devices on the PCI bus.
  */
+
+#define pr_fmt(fmt) "ipmi_pci: " fmt
+
 #include <linux/module.h>
 #include <linux/pci.h>
 #include "ipmi_si.h"
 
-#define PFX "ipmi_pci: "
-
 static bool pci_registered;
 
 static bool si_trypci = true;
@@ -39,8 +40,7 @@ static int ipmi_pci_probe_regspacing(struct si_sm_io *io)
 		for (regspacing = DEFAULT_REGSPACING; regspacing <= 16;) {
 			io->regspacing = regspacing;
 			if (io->io_setup(io)) {
-				dev_err(io->dev,
-					"Could not setup I/O space\n");
+				dev_err(io->dev, "Could not setup I/O space\n");
 				return DEFAULT_REGSPACING;
 			}
 			/* write invalid cmd */
@@ -125,7 +125,7 @@ static int ipmi_pci_probe(struct pci_dev *pdev,
 	io.dev = &pdev->dev;
 
 	dev_info(&pdev->dev, "%pR regsize %d spacing %d irq %d\n",
-		&pdev->resource[0], io.regsize, io.regspacing, io.irq);
+		 &pdev->resource[0], io.regsize, io.regspacing, io.irq);
 
 	rv = ipmi_si_add_smi(&io);
 	if (rv)
@@ -160,7 +160,7 @@ void ipmi_si_pci_init(void)
 	if (si_trypci) {
 		int rv = pci_register_driver(&ipmi_pci_driver);
 		if (rv)
-			pr_err(PFX "Unable to register PCI driver: %d\n", rv);
+			pr_err("Unable to register PCI driver: %d\n", rv);
 		else
 			pci_registered = true;
 	}
diff --git a/drivers/char/ipmi/ipmi_si_platform.c b/drivers/char/ipmi/ipmi_si_platform.c
index f807009a6a13..a03fb4510bba 100644
--- a/drivers/char/ipmi/ipmi_si_platform.c
+++ b/drivers/char/ipmi/ipmi_si_platform.c
@@ -4,6 +4,10 @@
  * Handling for platform devices in IPMI (ACPI, OF, and things
  * coming from the platform.
  */
+
+#define pr_fmt(fmt) "ipmi_platform: " fmt
+#define dev_fmt pr_fmt
+
 #include <linux/types.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
@@ -14,8 +18,6 @@
 #include "ipmi_si.h"
 #include "ipmi_dmi.h"
 
-#define PFX "ipmi_platform: "
-
 static bool si_tryplatform = true;
 #ifdef CONFIG_ACPI
 static bool          si_tryacpi = true;
@@ -161,7 +163,7 @@ static int platform_ipmi_probe(struct platform_device *pdev)
 
 	memset(&io, 0, sizeof(io));
 	io.addr_source = addr_source;
-	dev_info(&pdev->dev, PFX "probing via %s\n",
+	dev_info(&pdev->dev, "probing via %s\n",
 		 ipmi_addr_src_to_str(addr_source));
 
 	switch (type) {
@@ -239,25 +241,25 @@ static int of_ipmi_probe(struct platform_device *pdev)
 
 	ret = of_address_to_resource(np, 0, &resource);
 	if (ret) {
-		dev_warn(&pdev->dev, PFX "invalid address from OF\n");
+		dev_warn(&pdev->dev, "invalid address from OF\n");
 		return ret;
 	}
 
 	regsize = of_get_property(np, "reg-size", &proplen);
 	if (regsize && proplen != 4) {
-		dev_warn(&pdev->dev, PFX "invalid regsize from OF\n");
+		dev_warn(&pdev->dev, "invalid regsize from OF\n");
 		return -EINVAL;
 	}
 
 	regspacing = of_get_property(np, "reg-spacing", &proplen);
 	if (regspacing && proplen != 4) {
-		dev_warn(&pdev->dev, PFX "invalid regspacing from OF\n");
+		dev_warn(&pdev->dev, "invalid regspacing from OF\n");
 		return -EINVAL;
 	}
 
 	regshift = of_get_property(np, "reg-shift", &proplen);
 	if (regshift && proplen != 4) {
-		dev_warn(&pdev->dev, PFX "invalid regshift from OF\n");
+		dev_warn(&pdev->dev, "invalid regshift from OF\n");
 		return -EINVAL;
 	}
 
@@ -329,7 +331,7 @@ static int acpi_ipmi_probe(struct platform_device *pdev)
 
 	memset(&io, 0, sizeof(io));
 	io.addr_source = SI_ACPI;
-	dev_info(&pdev->dev, PFX "probing via ACPI\n");
+	dev_info(&pdev->dev, "probing via ACPI\n");
 
 	io.addr_info.acpi_info.acpi_handle = handle;
 
@@ -434,7 +436,7 @@ void ipmi_si_platform_init(void)
 {
 	int rv = platform_driver_register(&ipmi_platform_driver);
 	if (rv)
-		pr_err(PFX "Unable to register driver: %d\n", rv);
+		pr_err("Unable to register driver: %d\n", rv);
 }
 
 void ipmi_si_platform_shutdown(void)
diff --git a/drivers/char/ipmi/ipmi_ssif.c b/drivers/char/ipmi/ipmi_ssif.c
index d9d3ef1e266a..270ba9968f3c 100644
--- a/drivers/char/ipmi/ipmi_ssif.c
+++ b/drivers/char/ipmi/ipmi_ssif.c
@@ -31,6 +31,8 @@
  * interface into the I2C driver, I believe.
  */
 
+#define pr_fmt(fmt) "ipmi_ssif: " fmt
+
 #if defined(MODVERSIONS)
 #include <linux/modversions.h>
 #endif
@@ -56,7 +58,6 @@
 #include "ipmi_si_sm.h"
 #include "ipmi_dmi.h"
 
-#define PFX "ipmi_ssif: "
 #define DEVICE_NAME "ipmi_ssif"
 
 #define IPMI_GET_SYSTEM_INTERFACE_CAPABILITIES_CMD	0x57
@@ -330,9 +331,8 @@ static void deliver_recv_msg(struct ssif_info *ssif_info,
 		ipmi_free_smi_msg(msg);
 	} else if (msg->rsp_size < 0) {
 		return_hosed_msg(ssif_info, msg);
-		pr_err(PFX
-		       "Malformed message in deliver_recv_msg: rsp_size = %d\n",
-		       msg->rsp_size);
+		pr_err("%s: Malformed message: rsp_size = %d\n",
+		       __func__, msg->rsp_size);
 	} else {
 		ipmi_smi_msg_received(intf, msg);
 	}
@@ -668,7 +668,7 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 		if (len == 0) {
 			result = -EIO;
 			if (ssif_info->ssif_debug & SSIF_DEBUG_MSG)
-				pr_info(PFX "Middle message with no data\n");
+				pr_info("Middle message with no data\n");
 
 			goto continue_op;
 		}
@@ -712,8 +712,7 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 					   I2C_SMBUS_BLOCK_DATA);
 			if (rv < 0) {
 				if (ssif_info->ssif_debug & SSIF_DEBUG_MSG)
-					pr_info(PFX
-						"Error from ssif_i2c_send\n");
+					pr_info("Error from ssif_i2c_send\n");
 
 				result = -EIO;
 			} else
@@ -731,7 +730,7 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 
  continue_op:
 	if (ssif_info->ssif_debug & SSIF_DEBUG_STATE)
-		pr_info(PFX "DONE 1: state = %d, result=%d.\n",
+		pr_info("DONE 1: state = %d, result=%d\n",
 			ssif_info->ssif_state, result);
 
 	flags = ipmi_ssif_lock_cond(ssif_info, &oflags);
@@ -765,8 +764,8 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 			 */
 			ssif_info->ssif_state = SSIF_NORMAL;
 			ipmi_ssif_unlock_cond(ssif_info, flags);
-			pr_warn(PFX "Error getting flags: %d %d, %x\n",
-			       result, len, (len >= 3) ? data[2] : 0);
+			pr_warn("Error getting flags: %d %d, %x\n",
+				result, len, (len >= 3) ? data[2] : 0);
 		} else if (data[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2
 			   || data[1] != IPMI_GET_MSG_FLAGS_CMD) {
 			/*
@@ -774,7 +773,7 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 			 * response to a previous command.
 			 */
 			ipmi_ssif_unlock_cond(ssif_info, flags);
-			pr_warn(PFX "Invalid response getting flags: %x %x\n",
+			pr_warn("Invalid response getting flags: %x %x\n",
 				data[0], data[1]);
 		} else {
 			ssif_inc_stat(ssif_info, flag_fetches);
@@ -787,11 +786,11 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 		/* We cleared the flags. */
 		if ((result < 0) || (len < 3) || (data[2] != 0)) {
 			/* Error clearing flags */
-			pr_warn(PFX "Error clearing flags: %d %d, %x\n",
-			       result, len, (len >= 3) ? data[2] : 0);
+			pr_warn("Error clearing flags: %d %d, %x\n",
+				result, len, (len >= 3) ? data[2] : 0);
 		} else if (data[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2
 			   || data[1] != IPMI_CLEAR_MSG_FLAGS_CMD) {
-			pr_warn(PFX "Invalid response clearing flags: %x %x\n",
+			pr_warn("Invalid response clearing flags: %x %x\n",
 				data[0], data[1]);
 		}
 		ssif_info->ssif_state = SSIF_NORMAL;
@@ -808,7 +807,7 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 			handle_flags(ssif_info, flags);
 		} else if (msg->rsp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2
 			   || msg->rsp[1] != IPMI_READ_EVENT_MSG_BUFFER_CMD) {
-			pr_warn(PFX "Invalid response getting events: %x %x\n",
+			pr_warn("Invalid response getting events: %x %x\n",
 				msg->rsp[0], msg->rsp[1]);
 			msg->done(msg);
 			/* Take off the event flag. */
@@ -831,7 +830,7 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 			handle_flags(ssif_info, flags);
 		} else if (msg->rsp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2
 			   || msg->rsp[1] != IPMI_GET_MSG_CMD) {
-			pr_warn(PFX "Invalid response clearing flags: %x %x\n",
+			pr_warn("Invalid response clearing flags: %x %x\n",
 				msg->rsp[0], msg->rsp[1]);
 			msg->done(msg);
 
@@ -858,7 +857,7 @@ static void msg_done_handler(struct ssif_info *ssif_info, int result,
 		ipmi_ssif_unlock_cond(ssif_info, flags);
 
 	if (ssif_info->ssif_debug & SSIF_DEBUG_STATE)
-		pr_info(PFX "DONE 2: state = %d.\n", ssif_info->ssif_state);
+		pr_info("DONE 2: state = %d.\n", ssif_info->ssif_state);
 }
 
 static void msg_written_handler(struct ssif_info *ssif_info, int result,
@@ -878,8 +877,7 @@ static void msg_written_handler(struct ssif_info *ssif_info, int result,
 			ssif_inc_stat(ssif_info, send_errors);
 
 			if (ssif_info->ssif_debug & SSIF_DEBUG_MSG)
-				pr_info(PFX
-					"Out of retries in msg_written_handler\n");
+				pr_info("%s: Out of retries\n", __func__);
 			msg_done_handler(ssif_info, -EIO, NULL, 0);
 			return;
 		}
@@ -1060,8 +1058,8 @@ static void sender(void                *send_info,
 
 		ktime_get_real_ts64(&t);
 		pr_info("**Enqueue %02x %02x: %lld.%6.6ld\n",
-		       msg->data[0], msg->data[1],
-		       (long long) t.tv_sec, (long) t.tv_nsec / NSEC_PER_USEC);
+			msg->data[0], msg->data[1],
+			(long long)t.tv_sec, (long)t.tv_nsec / NSEC_PER_USEC);
 	}
 }
 
@@ -1545,9 +1543,9 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 
 	slave_addr = find_slave_address(client, slave_addr);
 
-	pr_info(PFX "Trying %s-specified SSIF interface at i2c address 0x%x, adapter %s, slave address 0x%x\n",
-	       ipmi_addr_src_to_str(ssif_info->addr_source),
-	       client->addr, client->adapter->name, slave_addr);
+	pr_info("Trying %s-specified SSIF interface at i2c address 0x%x, adapter %s, slave address 0x%x\n",
+		ipmi_addr_src_to_str(ssif_info->addr_source),
+		client->addr, client->adapter->name, slave_addr);
 
 	/*
 	 * Do a Get Device ID command, since it comes back with some
@@ -1575,7 +1573,7 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	if (!rv && (len >= 3) && (resp[2] == 0)) {
 		if (len < 7) {
 			if (ssif_dbg_probe)
-				pr_info(PFX "SSIF info too short: %d\n", len);
+				pr_info("SSIF info too short: %d\n", len);
 			goto no_support;
 		}
 
@@ -1631,8 +1629,8 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	} else {
  no_support:
 		/* Assume no multi-part or PEC support */
-		pr_info(PFX "Error fetching SSIF: %d %d %2.2x, your system probably doesn't support this command so using defaults\n",
-		       rv, len, resp[2]);
+		pr_info("Error fetching SSIF: %d %d %2.2x, your system probably doesn't support this command so using defaults\n",
+			rv, len, resp[2]);
 
 		ssif_info->max_xmit_msg_size = 32;
 		ssif_info->max_recv_msg_size = 32;
@@ -1646,7 +1644,7 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	msg[2] = WDT_PRE_TIMEOUT_INT;
 	rv = do_cmd(client, 3, msg, &len, resp);
 	if (rv || (len < 3) || (resp[2] != 0))
-		pr_warn(PFX "Unable to clear message flags: %d %d %2.2x\n",
+		pr_warn("Unable to clear message flags: %d %d %2.2x\n",
 			rv, len, resp[2]);
 
 	/* Attempt to enable the event buffer. */
@@ -1654,7 +1652,7 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	msg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;
 	rv = do_cmd(client, 2, msg, &len, resp);
 	if (rv || (len < 4) || (resp[2] != 0)) {
-		pr_warn(PFX "Error getting global enables: %d %d %2.2x\n",
+		pr_warn("Error getting global enables: %d %d %2.2x\n",
 			rv, len, resp[2]);
 		rv = 0; /* Not fatal */
 		goto found;
@@ -1673,7 +1671,7 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	msg[2] = ssif_info->global_enables | IPMI_BMC_EVT_MSG_BUFF;
 	rv = do_cmd(client, 3, msg, &len, resp);
 	if (rv || (len < 2)) {
-		pr_warn(PFX "Error setting global enables: %d %d %2.2x\n",
+		pr_warn("Error setting global enables: %d %d %2.2x\n",
 			rv, len, resp[2]);
 		rv = 0; /* Not fatal */
 		goto found;
@@ -1694,7 +1692,7 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	msg[2] = ssif_info->global_enables | IPMI_BMC_RCV_MSG_INTR;
 	rv = do_cmd(client, 3, msg, &len, resp);
 	if (rv || (len < 2)) {
-		pr_warn(PFX "Error setting global enables: %d %d %2.2x\n",
+		pr_warn("Error setting global enables: %d %d %2.2x\n",
 			rv, len, resp[2]);
 		rv = 0; /* Not fatal */
 		goto found;
@@ -1768,7 +1766,7 @@ static int ssif_probe(struct i2c_client *client, const struct i2c_device_id *id)
 			       "ssif",
 			       slave_addr);
 	 if (rv) {
-		pr_err(PFX "Unable to register device: error %d\n", rv);
+		pr_err("Unable to register device: error %d\n", rv);
 		goto out_remove_attr;
 	}
 
@@ -1943,7 +1941,7 @@ static int dmi_ipmi_probe(struct platform_device *pdev)
 
 	rv = device_property_read_u16(&pdev->dev, "i2c-addr", &i2c_addr);
 	if (rv) {
-		dev_warn(&pdev->dev, PFX "No i2c-addr property\n");
+		dev_warn(&pdev->dev, "No i2c-addr property\n");
 		return -ENODEV;
 	}
 
@@ -2024,8 +2022,7 @@ static int init_ipmi_ssif(void)
 				     dbg[i], slave_addrs[i],
 				     SI_HARDCODED, NULL);
 		if (rv)
-			pr_err(PFX
-			       "Couldn't add hardcoded device at addr 0x%x\n",
+			pr_err("Couldn't add hardcoded device at addr 0x%x\n",
 			       addr[i]);
 	}
 
@@ -2036,7 +2033,7 @@ static int init_ipmi_ssif(void)
 	if (ssif_trydmi) {
 		rv = platform_driver_register(&ipmi_driver);
 		if (rv)
-			pr_err(PFX "Unable to register driver: %d\n", rv);
+			pr_err("Unable to register driver: %d\n", rv);
 	}
 
 	ssif_i2c_driver.address_list = ssif_address_list();
* Unmerged path drivers/char/ipmi/ipmi_watchdog.c
