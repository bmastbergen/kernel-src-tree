fs: factor out a __generic_write_end helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit a6d639da63aeb838d5c0b7dc50598f2eac4014a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a6d639da.failed

Bits of the buffer.c based write_end implementations that don't know
about buffer_heads and can be reused by other implementations.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit a6d639da63aeb838d5c0b7dc50598f2eac4014a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/buffer.c
diff --cc fs/buffer.c
index d4d8ca8b872a,aba2a948b235..000000000000
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@@ -2097,39 -2150,8 +2131,39 @@@ int generic_write_end(struct file *file
  			loff_t pos, unsigned len, unsigned copied,
  			struct page *page, void *fsdata)
  {
- 	struct inode *inode = mapping->host;
- 	loff_t old_size = inode->i_size;
- 	int i_size_changed = 0;
- 
  	copied = block_write_end(file, mapping, pos, len, copied, page, fsdata);
++<<<<<<< HEAD
 +
 +	/*
 +	 * No need to use i_size_read() here, the i_size
 +	 * cannot change under us because we hold i_mutex.
 +	 *
 +	 * But it's important to update i_size while still holding page lock:
 +	 * page writeout could otherwise come in and zero beyond i_size.
 +	 */
 +	if (pos+copied > inode->i_size) {
 +		i_size_write(inode, pos+copied);
 +		i_size_changed = 1;
 +	}
 +
 +	unlock_page(page);
 +	page_cache_release(page);
 +
 +	if (old_size < pos)
 +		pagecache_isize_extended(inode, old_size, pos);
 +	/*
 +	 * Don't mark the inode dirty under page lock. First, it unnecessarily
 +	 * makes the holding time of page lock longer. Second, it forces lock
 +	 * ordering of page lock and transaction start for journaling
 +	 * filesystems.
 +	 */
 +	if (i_size_changed)
 +		mark_inode_dirty(inode);
 +
 +	return copied;
++=======
+ 	return __generic_write_end(mapping->host, pos, copied, page);
++>>>>>>> a6d639da63ae (fs: factor out a __generic_write_end helper)
  }
  EXPORT_SYMBOL(generic_write_end);
  
* Unmerged path fs/buffer.c
diff --git a/fs/internal.h b/fs/internal.h
index d79fb55fe7ce..4f4356a42895 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -44,6 +44,8 @@ static inline int __sync_blockdev(struct block_device *bdev, int wait)
 extern void guard_bio_eod(int rw, struct bio *bio);
 extern int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,
 		get_block_t *get_block, struct iomap *iomap);
+int __generic_write_end(struct inode *inode, loff_t pos, unsigned copied,
+		struct page *page);
 
 /*
  * char_dev.c
