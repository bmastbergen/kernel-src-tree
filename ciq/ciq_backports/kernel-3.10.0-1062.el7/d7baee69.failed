powerpc/iommu: Stop using @current in mm_iommu_xxx

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Alexey Kardashevskiy <aik@ozlabs.ru>
commit d7baee6901b34c4895eb78efdbf13a49079d7404
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d7baee69.failed

This changes mm_iommu_xxx helpers to take mm_struct as a parameter
instead of getting it from @current which in some situations may
not have a valid reference to mm.

This changes helpers to receive @mm and moves all references to @current
to the caller, including checks for !current and !current->mm;
checks in mm_iommu_preregistered() are removed as there is no caller
yet.

This moves the mm_iommu_adjust_locked_vm() call to the caller as
it receives mm_iommu_table_group_mem_t but it needs mm.

This should cause no behavioral change.

	Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Acked-by: Alex Williamson <alex.williamson@redhat.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit d7baee6901b34c4895eb78efdbf13a49079d7404)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/mmu_context.h
#	arch/powerpc/mm/mmu_context_iommu.c
diff --cc arch/powerpc/include/asm/mmu_context.h
index 884fe3a8d621,b9e3f0aca261..000000000000
--- a/arch/powerpc/include/asm/mmu_context.h
+++ b/arch/powerpc/include/asm/mmu_context.h
@@@ -19,16 -19,18 +19,28 @@@ extern void destroy_context(struct mm_s
  struct mm_iommu_table_group_mem_t;
  
  extern int isolate_lru_page(struct page *page);	/* from internal.h */
- extern bool mm_iommu_preregistered(void);
- extern long mm_iommu_get(unsigned long ua, unsigned long entries,
+ extern bool mm_iommu_preregistered(struct mm_struct *mm);
+ extern long mm_iommu_get(struct mm_struct *mm,
+ 		unsigned long ua, unsigned long entries,
  		struct mm_iommu_table_group_mem_t **pmem);
++<<<<<<< HEAD
 +extern long mm_iommu_put(struct mm_iommu_table_group_mem_t *mem);
 +extern void mm_iommu_init(mm_context_t *ctx);
 +extern void mm_iommu_cleanup(mm_context_t *ctx);
 +extern struct mm_iommu_table_group_mem_t *mm_iommu_lookup(unsigned long ua,
 +		unsigned long size);
 +extern struct mm_iommu_table_group_mem_t *mm_iommu_find(unsigned long ua,
 +		unsigned long entries);
++=======
+ extern long mm_iommu_put(struct mm_struct *mm,
+ 		struct mm_iommu_table_group_mem_t *mem);
+ extern void mm_iommu_init(struct mm_struct *mm);
+ extern void mm_iommu_cleanup(struct mm_struct *mm);
+ extern struct mm_iommu_table_group_mem_t *mm_iommu_lookup(struct mm_struct *mm,
+ 		unsigned long ua, unsigned long size);
+ extern struct mm_iommu_table_group_mem_t *mm_iommu_find(struct mm_struct *mm,
+ 		unsigned long ua, unsigned long entries);
++>>>>>>> d7baee6901b3 (powerpc/iommu: Stop using @current in mm_iommu_xxx)
  extern long mm_iommu_ua_to_hpa(struct mm_iommu_table_group_mem_t *mem,
  		unsigned long ua, unsigned long *hpa);
  extern long mm_iommu_mapped_inc(struct mm_iommu_table_group_mem_t *mem);
diff --cc arch/powerpc/mm/mmu_context_iommu.c
index f68c12901fa8,4c6db09e77ad..000000000000
--- a/arch/powerpc/mm/mmu_context_iommu.c
+++ b/arch/powerpc/mm/mmu_context_iommu.c
@@@ -66,12 -66,9 +66,16 @@@ static long mm_iommu_adjust_locked_vm(s
  	return ret;
  }
  
- bool mm_iommu_preregistered(void)
+ bool mm_iommu_preregistered(struct mm_struct *mm)
  {
++<<<<<<< HEAD
 +	if (!current || !current->mm)
 +		return false;
 +
 +	return !list_empty(&current->mm->iommu_group_mem_list);
++=======
+ 	return !list_empty(&mm->context.iommu_group_mem_list);
++>>>>>>> d7baee6901b3 (powerpc/iommu: Stop using @current in mm_iommu_xxx)
  }
  EXPORT_SYMBOL_GPL(mm_iommu_preregistered);
  
@@@ -131,12 -128,9 +135,13 @@@ long mm_iommu_get(struct mm_struct *mm
  	long i, j, ret = 0, locked_entries = 0;
  	struct page *page = NULL;
  
- 	if (!current || !current->mm)
- 		return -ESRCH; /* process exited */
- 
  	mutex_lock(&mem_list_mutex);
  
++<<<<<<< HEAD
 +	list_for_each_entry_rcu(mem, &current->mm->iommu_group_mem_list,
++=======
+ 	list_for_each_entry_rcu(mem, &mm->context.iommu_group_mem_list,
++>>>>>>> d7baee6901b3 (powerpc/iommu: Stop using @current in mm_iommu_xxx)
  			next) {
  		if ((mem->ua == ua) && (mem->entries == entries)) {
  			++mem->used;
@@@ -215,7 -209,7 +220,11 @@@ populate
  	mem->entries = entries;
  	*pmem = mem;
  
++<<<<<<< HEAD
 +	list_add_rcu(&mem->next, &current->mm->iommu_group_mem_list);
++=======
+ 	list_add_rcu(&mem->next, &mm->context.iommu_group_mem_list);
++>>>>>>> d7baee6901b3 (powerpc/iommu: Stop using @current in mm_iommu_xxx)
  
  unlock_exit:
  	if (locked_entries && ret)
@@@ -309,9 -301,7 +316,13 @@@ struct mm_iommu_table_group_mem_t *mm_i
  {
  	struct mm_iommu_table_group_mem_t *mem, *ret = NULL;
  
++<<<<<<< HEAD
 +	list_for_each_entry_rcu(mem,
 +			&current->mm->iommu_group_mem_list,
 +			next) {
++=======
+ 	list_for_each_entry_rcu(mem, &mm->context.iommu_group_mem_list, next) {
++>>>>>>> d7baee6901b3 (powerpc/iommu: Stop using @current in mm_iommu_xxx)
  		if ((mem->ua <= ua) &&
  				(ua + size <= mem->ua +
  				 (mem->entries << PAGE_SHIFT))) {
@@@ -329,9 -319,7 +340,13 @@@ struct mm_iommu_table_group_mem_t *mm_i
  {
  	struct mm_iommu_table_group_mem_t *mem, *ret = NULL;
  
++<<<<<<< HEAD
 +	list_for_each_entry_rcu(mem,
 +			&current->mm->iommu_group_mem_list,
 +			next) {
++=======
+ 	list_for_each_entry_rcu(mem, &mm->context.iommu_group_mem_list, next) {
++>>>>>>> d7baee6901b3 (powerpc/iommu: Stop using @current in mm_iommu_xxx)
  		if ((mem->ua == ua) && (mem->entries == entries)) {
  			ret = mem;
  			break;
* Unmerged path arch/powerpc/include/asm/mmu_context.h
* Unmerged path arch/powerpc/mm/mmu_context_iommu.c
diff --git a/drivers/vfio/vfio_iommu_spapr_tce.c b/drivers/vfio/vfio_iommu_spapr_tce.c
index 7aa2428d2fd0..4113a0a5c013 100644
--- a/drivers/vfio/vfio_iommu_spapr_tce.c
+++ b/drivers/vfio/vfio_iommu_spapr_tce.c
@@ -108,14 +108,17 @@ static long tce_iommu_unregister_pages(struct tce_container *container,
 {
 	struct mm_iommu_table_group_mem_t *mem;
 
+	if (!current || !current->mm)
+		return -ESRCH; /* process exited */
+
 	if ((vaddr & ~PAGE_MASK) || (size & ~PAGE_MASK))
 		return -EINVAL;
 
-	mem = mm_iommu_find(vaddr, size >> PAGE_SHIFT);
+	mem = mm_iommu_find(current->mm, vaddr, size >> PAGE_SHIFT);
 	if (!mem)
 		return -ENOENT;
 
-	return mm_iommu_put(mem);
+	return mm_iommu_put(current->mm, mem);
 }
 
 static long tce_iommu_register_pages(struct tce_container *container,
@@ -125,11 +128,14 @@ static long tce_iommu_register_pages(struct tce_container *container,
 	struct mm_iommu_table_group_mem_t *mem = NULL;
 	unsigned long entries = size >> PAGE_SHIFT;
 
+	if (!current || !current->mm)
+		return -ESRCH; /* process exited */
+
 	if ((vaddr & ~PAGE_MASK) || (size & ~PAGE_MASK) ||
 			((vaddr + size) < vaddr))
 		return -EINVAL;
 
-	ret = mm_iommu_get(vaddr, entries, &mem);
+	ret = mm_iommu_get(current->mm, vaddr, entries, &mem);
 	if (ret)
 		return ret;
 
@@ -376,7 +382,7 @@ static int tce_iommu_prereg_ua_to_hpa(unsigned long tce, unsigned long size,
 	long ret = 0;
 	struct mm_iommu_table_group_mem_t *mem;
 
-	mem = mm_iommu_lookup(tce, size);
+	mem = mm_iommu_lookup(current->mm, tce, size);
 	if (!mem)
 		return -EINVAL;
 
