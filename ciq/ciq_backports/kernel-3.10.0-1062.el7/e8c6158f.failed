mm: consolidate all page-flags helpers in <linux/page-flags.h>

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
commit e8c6158fef15a1532bd5242a0cd88565eedabe61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e8c6158f.failed

Currently we take a naive approach to page flags on compound pages - we
set the flag on the page without consideration if the flag makes sense
for tail page or for compound page in general.  This patchset try to
sort this out by defining per-flag policy on what need to be done if
page-flag helper operate on compound page.

The last patch in the patchset also sanitizes usege of page->mapping for
tail pages.  We don't define the meaning of page->mapping for tail
pages.  Currently it's always NULL, which can be inconsistent with head
page and potentially lead to problems.

For now I caught one case of illegal usage of page flags or ->mapping:
sound subsystem allocates pages with __GFP_COMP and maps them with PTEs.
It leads to setting dirty bit on tail pages and access to tail_page's
->mapping.  I don't see any bad behaviour caused by this, but worth
fixing anyway.

This patchset makes more sense if you take my THP refcounting into
account: we will see more compound pages mapped with PTEs and we need to
define behaviour of flags on compound pages to avoid bugs.

This patch (of 16):

We have page-flags helper function declarations/definitions spread over
several header files.  Let's consolidate them in <linux/page-flags.h>.

	Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Acked-by: Hugh Dickins <hughd@google.com>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Steve Capper <steve.capper@linaro.org>
	Cc: "Aneesh Kumar K.V" <aneesh.kumar@linux.vnet.ibm.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@suse.cz>
	Cc: Jerome Marchand <jmarchan@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e8c6158fef15a1532bd5242a0cd88565eedabe61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/hugetlb.h
#	include/linux/mm.h
diff --cc include/linux/hugetlb.h
index 82806ff6437f,1a782733a420..000000000000
--- a/include/linux/hugetlb.h
+++ b/include/linux/hugetlb.h
@@@ -48,13 -38,9 +48,16 @@@ extern int hugetlb_max_hstate __read_mo
  #define for_each_hstate(h) \
  	for ((h) = hstates; (h) < &hstates[hugetlb_max_hstate]; (h)++)
  
 -struct hugepage_subpool *hugepage_new_subpool(long nr_blocks);
 +struct hugepage_subpool *hugepage_new_subpool(struct hstate *h, long max_hpages,
 +						long min_hpages);
  void hugepage_put_subpool(struct hugepage_subpool *spool);
  
++<<<<<<< HEAD
 +int PageHuge(struct page *page);
 +bool page_huge_active(struct page *page);
 +
++=======
++>>>>>>> e8c6158fef15 (mm: consolidate all page-flags helpers in <linux/page-flags.h>)
  void reset_vma_resv_huge_pages(struct vm_area_struct *vma);
  int hugetlb_sysctl_handler(struct ctl_table *, int, void __user *, size_t *, loff_t *);
  int hugetlb_overcommit_handler(struct ctl_table *, int, void __user *, size_t *, loff_t *);
@@@ -135,16 -107,6 +138,19 @@@ unsigned long hugetlb_change_protection
  
  #else /* !CONFIG_HUGETLB_PAGE */
  
++<<<<<<< HEAD
 +static inline int PageHuge(struct page *page)
 +{
 +	return 0;
 +}
 +
 +static inline bool page_huge_active(struct page *page)
 +{
 +	return 0;
 +}
 +
++=======
++>>>>>>> e8c6158fef15 (mm: consolidate all page-flags helpers in <linux/page-flags.h>)
  static inline void reset_vma_resv_huge_pages(struct vm_area_struct *vma)
  {
  }
diff --cc include/linux/mm.h
index 1160912f4a0f,fb1fc38b01ce..000000000000
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@@ -585,18 -485,15 +585,9 @@@ static inline void page_mapcount_reset(
  
  static inline int page_mapcount(struct page *page)
  {
 -	VM_BUG_ON_PAGE(PageSlab(page), page);
 -	return atomic_read(&page->_mapcount) + 1;
 -}
 -
 -static inline int page_count(struct page *page)
 -{
 -	return atomic_read(&compound_head(page)->_count);
 +	return atomic_read(&(page)->_mapcount) + 1;
  }
  
- #ifdef CONFIG_HUGETLB_PAGE
- extern int PageHeadHuge(struct page *page_head);
- #else /* CONFIG_HUGETLB_PAGE */
- static inline int PageHeadHuge(struct page *page_head)
- {
- 	return 0;
- }
- #endif /* CONFIG_HUGETLB_PAGE */
- 
  static inline bool __compound_tail_refcounted(struct page *page)
  {
  	return !PageSlab(page) && !PageHeadHuge(page);
@@@ -628,59 -525,44 +619,63 @@@ static inline void get_huge_page_tail(s
  		atomic_inc(&page->_mapcount);
  }
  
 -extern bool __get_page_tail(struct page *page);
 +static inline struct page *virt_to_head_page(const void *x)
 +{
 +	struct page *page = virt_to_page(x);
 +	return compound_head(page);
 +}
  
 -static inline void get_page(struct page *page)
++<<<<<<< HEAD
 +/*
 + * PageBuddy() indicate that the page is free and in the buddy system
 + * (see mm/page_alloc.c).
 + *
 + * PAGE_BUDDY_MAPCOUNT_VALUE must be <= -2 but better not too close to
 + * -2 so that an underflow of the page_mapcount() won't be mistaken
 + * for a genuine PAGE_BUDDY_MAPCOUNT_VALUE. -128 can be created very
 + * efficiently by most CPU architectures.
 + */
 +#define PAGE_BUDDY_MAPCOUNT_VALUE (-128)
 +
 +static inline int PageBuddy(struct page *page)
  {
 -	if (unlikely(PageTail(page)))
 -		if (likely(__get_page_tail(page)))
 -			return;
 -	/*
 -	 * Getting a normal page or the head of a compound page
 -	 * requires to already have an elevated page->_count.
 -	 */
 -	VM_BUG_ON_PAGE(atomic_read(&page->_count) <= 0, page);
 -	atomic_inc(&page->_count);
 +	return atomic_read(&page->_mapcount) == PAGE_BUDDY_MAPCOUNT_VALUE;
  }
  
 -static inline struct page *virt_to_head_page(const void *x)
 +static inline void __SetPageBuddy(struct page *page)
  {
 -	struct page *page = virt_to_page(x);
 +	VM_BUG_ON_PAGE(atomic_read(&page->_mapcount) != -1, page);
 +	atomic_set(&page->_mapcount, PAGE_BUDDY_MAPCOUNT_VALUE);
 +}
  
 -	/*
 -	 * We don't need to worry about synchronization of tail flag
 -	 * when we call virt_to_head_page() since it is only called for
 -	 * already allocated page and this page won't be freed until
 -	 * this virt_to_head_page() is finished. So use _fast variant.
 -	 */
 -	return compound_head_fast(page);
 +static inline void __ClearPageBuddy(struct page *page)
 +{
 +	VM_BUG_ON_PAGE(!PageBuddy(page), page);
 +	atomic_set(&page->_mapcount, -1);
  }
  
 -/*
 - * Setup the page count before being freed into the page allocator for
 - * the first time (boot or memory hotplug)
 - */
 -static inline void init_page_count(struct page *page)
 +#define PAGE_BALLOON_MAPCOUNT_VALUE (-256)
 +
 +static inline int PageBalloon(struct page *page)
 +{
 +	return atomic_read(&page->_mapcount) == PAGE_BALLOON_MAPCOUNT_VALUE;
 +}
 +
 +static inline void __SetPageBalloon(struct page *page)
  {
 -	atomic_set(&page->_count, 1);
 +	VM_BUG_ON_PAGE(atomic_read(&page->_mapcount) != -1, page);
 +	atomic_set(&page->_mapcount, PAGE_BALLOON_MAPCOUNT_VALUE);
  }
  
 +static inline void __ClearPageBalloon(struct page *page)
 +{
 +	VM_BUG_ON_PAGE(!PageBalloon(page), page);
 +	atomic_set(&page->_mapcount, -1);
 +}
 +
++=======
+ void put_page(struct page *page);
++>>>>>>> e8c6158fef15 (mm: consolidate all page-flags helpers in <linux/page-flags.h>)
  void put_pages_list(struct list_head *pages);
  
  void split_page(struct page *page, unsigned int order);
* Unmerged path include/linux/hugetlb.h
diff --git a/include/linux/ksm.h b/include/linux/ksm.h
index 3be6bb18562d..7ae216a39c9e 100644
--- a/include/linux/ksm.h
+++ b/include/linux/ksm.h
@@ -35,18 +35,6 @@ static inline void ksm_exit(struct mm_struct *mm)
 		__ksm_exit(mm);
 }
 
-/*
- * A KSM page is one of those write-protected "shared pages" or "merged pages"
- * which KSM maps into multiple mms, wherever identical anonymous page content
- * is found in VM_MERGEABLE vmas.  It's a PageAnon page, pointing not to any
- * anon_vma, but to that page's node of the stable tree.
- */
-static inline int PageKsm(struct page *page)
-{
-	return ((unsigned long)page->mapping & PAGE_MAPPING_FLAGS) ==
-				(PAGE_MAPPING_ANON | PAGE_MAPPING_KSM);
-}
-
 static inline struct stable_node *page_stable_node(struct page *page)
 {
 	return PageKsm(page) ? page_rmapping(page) : NULL;
@@ -87,11 +75,6 @@ static inline void ksm_exit(struct mm_struct *mm)
 {
 }
 
-static inline int PageKsm(struct page *page)
-{
-	return 0;
-}
-
 #ifdef CONFIG_MMU
 static inline int ksm_madvise(struct vm_area_struct *vma, unsigned long start,
 		unsigned long end, int advice, unsigned long *vm_flags)
* Unmerged path include/linux/mm.h
diff --git a/include/linux/page-flags.h b/include/linux/page-flags.h
index a12b531c03b4..5259aaec3f8d 100644
--- a/include/linux/page-flags.h
+++ b/include/linux/page-flags.h
@@ -283,6 +283,47 @@ PAGEFLAG_FALSE(HWPoison)
 #define __PG_HWPOISON 0
 #endif
 
+/*
+ * On an anonymous page mapped into a user virtual memory area,
+ * page->mapping points to its anon_vma, not to a struct address_space;
+ * with the PAGE_MAPPING_ANON bit set to distinguish it.  See rmap.h.
+ *
+ * On an anonymous page in a VM_MERGEABLE area, if CONFIG_KSM is enabled,
+ * the PAGE_MAPPING_KSM bit may be set along with the PAGE_MAPPING_ANON bit;
+ * and then page->mapping points, not to an anon_vma, but to a private
+ * structure which KSM associates with that merged page.  See ksm.h.
+ *
+ * PAGE_MAPPING_KSM without PAGE_MAPPING_ANON is currently never used.
+ *
+ * Please note that, confusingly, "page_mapping" refers to the inode
+ * address_space which maps the page from disk; whereas "page_mapped"
+ * refers to user virtual address space into which the page is mapped.
+ */
+#define PAGE_MAPPING_ANON	1
+#define PAGE_MAPPING_KSM	2
+#define PAGE_MAPPING_FLAGS	(PAGE_MAPPING_ANON | PAGE_MAPPING_KSM)
+
+static inline int PageAnon(struct page *page)
+{
+	return ((unsigned long)page->mapping & PAGE_MAPPING_ANON) != 0;
+}
+
+#ifdef CONFIG_KSM
+/*
+ * A KSM page is one of those write-protected "shared pages" or "merged pages"
+ * which KSM maps into multiple mms, wherever identical anonymous page content
+ * is found in VM_MERGEABLE vmas.  It's a PageAnon page, pointing not to any
+ * anon_vma, but to that page's node of the stable tree.
+ */
+static inline int PageKsm(struct page *page)
+{
+	return ((unsigned long)page->mapping & PAGE_MAPPING_FLAGS) ==
+				(PAGE_MAPPING_ANON | PAGE_MAPPING_KSM);
+}
+#else
+TESTPAGEFLAG_FALSE(Ksm)
+#endif
+
 u64 stable_page_flags(struct page *page);
 
 static inline int PageUptodate(struct page *page)
@@ -420,6 +461,14 @@ static inline void ClearPageCompound(struct page *page)
 
 #endif /* !PAGEFLAGS_EXTENDED */
 
+#ifdef CONFIG_HUGETLB_PAGE
+int PageHuge(struct page *page);
+int PageHeadHuge(struct page *page);
+#else
+TESTPAGEFLAG_FALSE(Huge)
+TESTPAGEFLAG_FALSE(HeadHuge)
+#endif
+
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 /*
  * PageHuge() only returns true for hugetlbfs pages, but not for
@@ -473,6 +522,53 @@ static inline int PageTransTail(struct page *page)
 }
 #endif
 
+/*
+ * PageBuddy() indicate that the page is free and in the buddy system
+ * (see mm/page_alloc.c).
+ *
+ * PAGE_BUDDY_MAPCOUNT_VALUE must be <= -2 but better not too close to
+ * -2 so that an underflow of the page_mapcount() won't be mistaken
+ * for a genuine PAGE_BUDDY_MAPCOUNT_VALUE. -128 can be created very
+ * efficiently by most CPU architectures.
+ */
+#define PAGE_BUDDY_MAPCOUNT_VALUE (-128)
+
+static inline int PageBuddy(struct page *page)
+{
+	return atomic_read(&page->_mapcount) == PAGE_BUDDY_MAPCOUNT_VALUE;
+}
+
+static inline void __SetPageBuddy(struct page *page)
+{
+	VM_BUG_ON_PAGE(atomic_read(&page->_mapcount) != -1, page);
+	atomic_set(&page->_mapcount, PAGE_BUDDY_MAPCOUNT_VALUE);
+}
+
+static inline void __ClearPageBuddy(struct page *page)
+{
+	VM_BUG_ON_PAGE(!PageBuddy(page), page);
+	atomic_set(&page->_mapcount, -1);
+}
+
+#define PAGE_BALLOON_MAPCOUNT_VALUE (-256)
+
+static inline int PageBalloon(struct page *page)
+{
+	return atomic_read(&page->_mapcount) == PAGE_BALLOON_MAPCOUNT_VALUE;
+}
+
+static inline void __SetPageBalloon(struct page *page)
+{
+	VM_BUG_ON_PAGE(atomic_read(&page->_mapcount) != -1, page);
+	atomic_set(&page->_mapcount, PAGE_BALLOON_MAPCOUNT_VALUE);
+}
+
+static inline void __ClearPageBalloon(struct page *page)
+{
+	VM_BUG_ON_PAGE(!PageBalloon(page), page);
+	atomic_set(&page->_mapcount, -1);
+}
+
 /*
  * If network-based swap is enabled, sl*b must keep track of whether pages
  * were allocated from pfmemalloc reserves.
