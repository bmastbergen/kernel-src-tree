xfs: remove support for inlining data/extents into the inode fork

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 43518812d297179ae1e432d5cd640ec168596283
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/43518812.failed

Supporting a small bit of data inside the inode fork blows up the fork size
a lot, removing the 32 bytes of inline data halves the effective size of
the inode fork (and it still has a lot of unused padding left), and the
performance of a single kmalloc doesn't show up compared to the size to read
an inode or create one.

It also simplifies the fork management code a lot.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 43518812d297179ae1e432d5cd640ec168596283)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_inode_fork.c
#	fs/xfs/libxfs/xfs_inode_fork.h
diff --cc fs/xfs/libxfs/xfs_inode_fork.c
index f83028029221,c5dbcaea01e0..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@@ -157,19 -256,28 +157,31 @@@ xfs_init_local_fork
  	int			size)
  {
  	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
 -	int			mem_size = size, real_size = 0;
 -	bool			zero_terminate;
 +	int			real_size = 0;
  
 -	/*
 -	 * If we are using the local fork to store a symlink body we need to
 -	 * zero-terminate it so that we can pass it back to the VFS directly.
 -	 * Overallocate the in-memory fork by one for that and add a zero
 -	 * to terminate it below.
 -	 */
 -	zero_terminate = S_ISLNK(VFS_I(ip)->i_mode);
 -	if (zero_terminate)
 -		mem_size++;
++<<<<<<< HEAD
 +	if (size == 0)
 +		ifp->if_u1.if_data = NULL;
 +	else if (size <= sizeof(ifp->if_u2.if_inline_data))
 +		ifp->if_u1.if_data = ifp->if_u2.if_inline_data;
 +	else {
 +		real_size = roundup(size, 4);
 +		ifp->if_u1.if_data = kmem_alloc(real_size, KM_SLEEP | KM_NOFS);
 +	}
  
 +	if (size)
 +		memcpy(ifp->if_u1.if_data, data, size);
++=======
+ 	if (size) {
+ 		real_size = roundup(mem_size, 4);
+ 		ifp->if_u1.if_data = kmem_alloc(real_size, KM_SLEEP | KM_NOFS);
+ 		memcpy(ifp->if_u1.if_data, data, size);
+ 		if (zero_terminate)
+ 			ifp->if_u1.if_data[size] = '\0';
+ 	} else {
+ 		ifp->if_u1.if_data = NULL;
+ 	}
++>>>>>>> 43518812d297 (xfs: remove support for inlining data/extents into the inode fork)
  
  	ifp->if_bytes = size;
  	ifp->if_real_bytes = real_size;
@@@ -1092,11 -1113,9 +1053,15 @@@ xfs_iext_remove
  	if (new_size == 0) {
  		xfs_iext_destroy(ifp);
  	} else if (ifp->if_flags & XFS_IFEXTIREC) {
 -		xfs_iext_remove_indirect(ifp, cur->idx, ext_diff);
 +		xfs_iext_remove_indirect(ifp, idx, ext_diff);
  	} else if (ifp->if_real_bytes) {
++<<<<<<< HEAD
 +		xfs_iext_remove_direct(ifp, idx, ext_diff);
 +	} else {
 +		xfs_iext_remove_inline(ifp, idx, ext_diff);
++=======
+ 		xfs_iext_remove_direct(ifp, cur->idx, ext_diff);
++>>>>>>> 43518812d297 (xfs: remove support for inlining data/extents into the inode fork)
  	}
  	ifp->if_bytes = new_size;
  }
diff --cc fs/xfs/libxfs/xfs_inode_fork.h
index a53b7ced7b58,cf9885a2471f..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.h
+++ b/fs/xfs/libxfs/xfs_inode_fork.h
@@@ -64,13 -62,6 +62,16 @@@ typedef struct xfs_ifork 
  		xfs_ext_irec_t	*if_ext_irec;	/* irec map file exts */
  		char		*if_data;	/* inline file data */
  	} if_u1;
++<<<<<<< HEAD
 +	union {
 +		xfs_bmbt_rec_host_t if_inline_ext[XFS_INLINE_EXTS];
 +						/* very small file extents */
 +		char		if_inline_data[XFS_INLINE_DATA];
 +						/* very small file data */
 +		xfs_dev_t	if_rdev;	/* dev number if special */
 +	} if_u2;
++=======
++>>>>>>> 43518812d297 (xfs: remove support for inlining data/extents into the inode fork)
  } xfs_ifork_t;
  
  /*
@@@ -143,8 -148,8 +144,13 @@@ void		xfs_iext_insert(struct xfs_inode 
  void		xfs_iext_add(struct xfs_ifork *, xfs_extnum_t, int);
  void		xfs_iext_add_indirect_multi(struct xfs_ifork *, int,
  					    xfs_extnum_t, int);
++<<<<<<< HEAD
 +void		xfs_iext_remove(struct xfs_inode *, xfs_extnum_t, int, int);
 +void		xfs_iext_remove_inline(struct xfs_ifork *, xfs_extnum_t, int);
++=======
+ void		xfs_iext_remove(struct xfs_inode *, struct xfs_iext_cursor *,
+ 			int, int);
++>>>>>>> 43518812d297 (xfs: remove support for inlining data/extents into the inode fork)
  void		xfs_iext_remove_direct(struct xfs_ifork *, xfs_extnum_t, int);
  void		xfs_iext_remove_indirect(struct xfs_ifork *, xfs_extnum_t, int);
  void		xfs_iext_realloc_direct(struct xfs_ifork *, int);
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.c
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.h
diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c
index ad7a1ab465c3..12f762b0a3f0 100644
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@ -1560,13 +1560,6 @@ xfs_swap_extent_forks(
 
 	switch (ip->i_d.di_format) {
 	case XFS_DINODE_FMT_EXTENTS:
-		/*
-		 * If the extents fit in the inode, fix the pointer.  Otherwise
-		 * it's already NULL or pointing to the extent.
-		 */
-		nextents = xfs_iext_count(&ip->i_df);
-		if (nextents <= XFS_INLINE_EXTS)
-			ifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;
 		(*src_log_flags) |= XFS_ILOG_DEXT;
 		break;
 	case XFS_DINODE_FMT_BTREE:
@@ -1578,13 +1571,6 @@ xfs_swap_extent_forks(
 
 	switch (tip->i_d.di_format) {
 	case XFS_DINODE_FMT_EXTENTS:
-		/*
-		 * If the extents fit in the inode, fix the pointer.  Otherwise
-		 * it's already NULL or pointing to the extent.
-		 */
-		nextents = xfs_iext_count(&tip->i_df);
-		if (nextents <= XFS_INLINE_EXTS)
-			tifp->if_u1.if_extents = tifp->if_u2.if_inline_ext;
 		(*target_log_flags) |= XFS_ILOG_DEXT;
 		break;
 	case XFS_DINODE_FMT_BTREE:
