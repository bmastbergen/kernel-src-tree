net/mlx5: Allow/disallow LAG according to pre-req only

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Allow/disallow LAG according to pre-req only (Alaa Hleihel) [1642355 1642498]
Rebuild_FUZZ: 96.15%
commit-author Rabie Loulou <rabiel@mellanox.com>
commit eff849b2c669ebf0df88762f082bcb252f8e883c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/eff849b2.failed

Remove the lag forbid/allow functions, change the lag prereq check to
run in the do-bond logic, so every change in the prereq state will
cause LAG to be disabled/enabled accordingly after the next do-bond run.

Add lag update function, so every component which changes the prereq
state and want the LAG to re-calc the conditions can call the update
function.

	Signed-off-by: Rabie Loulou <rabiel@mellanox.com>
	Signed-off-by: Aviv Heller <avivh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit eff849b2c669ebf0df88762f082bcb252f8e883c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 21bc97b70ed9,9c89eea9b2c3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -274,12 -338,22 +274,15 @@@ int mlx5_eswitch_del_vlan_action(struc
  int __mlx5_eswitch_set_vport_vlan(struct mlx5_eswitch *esw,
  				  int vport, u16 vlan, u8 qos, u8 set_flags);
  
 -static inline bool mlx5_eswitch_vlan_actions_supported(struct mlx5_core_dev *dev,
 -						       u8 vlan_depth)
 +static inline bool mlx5_eswitch_vlan_actions_supported(struct mlx5_core_dev *dev)
  {
 -	bool ret = MLX5_CAP_ESW_FLOWTABLE_FDB(dev, pop_vlan) &&
 -		   MLX5_CAP_ESW_FLOWTABLE_FDB(dev, push_vlan);
 -
 -	if (vlan_depth == 1)
 -		return ret;
 -
 -	return  ret && MLX5_CAP_ESW_FLOWTABLE_FDB(dev, pop_vlan_2) &&
 -		MLX5_CAP_ESW_FLOWTABLE_FDB(dev, push_vlan_2);
 +	return MLX5_CAP_ESW_FLOWTABLE_FDB(dev, pop_vlan) &&
 +	       MLX5_CAP_ESW_FLOWTABLE_FDB(dev, push_vlan);
  }
  
+ bool mlx5_esw_lag_prereq(struct mlx5_core_dev *dev0,
+ 			 struct mlx5_core_dev *dev1);
+ 
  #define MLX5_DEBUG_ESWITCH_MASK BIT(3)
  
  #define esw_info(dev, format, ...)				\
@@@ -294,9 -368,14 +297,18 @@@
  /* eswitch API stubs */
  static inline int  mlx5_eswitch_init(struct mlx5_core_dev *dev) { return 0; }
  static inline void mlx5_eswitch_cleanup(struct mlx5_eswitch *esw) {}
 +static inline void mlx5_eswitch_vport_event(struct mlx5_eswitch *esw, struct mlx5_eqe *eqe) {}
  static inline int  mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode) { return 0; }
  static inline void mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw) {}
++<<<<<<< HEAD
++=======
+ static inline bool mlx5_esw_lag_prereq(struct mlx5_core_dev *dev0, struct mlx5_core_dev *dev1) { return true; }
+ 
+ #define FDB_MAX_CHAIN 1
+ #define FDB_SLOW_PATH_CHAIN (FDB_MAX_CHAIN + 1)
+ #define FDB_MAX_PRIO 1
+ 
++>>>>>>> eff849b2c669 (net/mlx5: Allow/disallow LAG according to pre-req only)
  #endif /* CONFIG_MLX5_ESWITCH */
  
  #endif /* __MLX5_ESWITCH_H__ */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index 2ac07968015d,73bf46599ec6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@@ -203,8 -185,16 +203,19 @@@ static inline int mlx5_lag_is_lacp_owne
  		    MLX5_CAP_GEN(dev, lag_master);
  }
  
- int mlx5_lag_allow(struct mlx5_core_dev *dev);
- int mlx5_lag_forbid(struct mlx5_core_dev *dev);
- 
  void mlx5_reload_interface(struct mlx5_core_dev *mdev, int protocol);
++<<<<<<< HEAD
++=======
+ void mlx5_lag_update(struct mlx5_core_dev *dev);
+ 
+ enum {
+ 	MLX5_NIC_IFC_FULL		= 0,
+ 	MLX5_NIC_IFC_DISABLED		= 1,
+ 	MLX5_NIC_IFC_NO_DRAM_NIC	= 2,
+ 	MLX5_NIC_IFC_INVALID		= 3
+ };
+ 
+ u8 mlx5_get_nic_state(struct mlx5_core_dev *dev);
+ void mlx5_set_nic_state(struct mlx5_core_dev *dev, u8 state);
++>>>>>>> eff849b2c669 (net/mlx5: Allow/disallow LAG according to pre-req only)
  #endif /* __MLX5_CORE_H__ */
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 8798f4084ee6..256e90b825f0 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -1617,6 +1617,8 @@ int mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs, int mode)
 	esw_info(esw->dev, "E-Switch enable SRIOV: nvfs(%d) mode (%d)\n", nvfs, mode);
 	esw->mode = mode;
 
+	mlx5_lag_update(esw->dev);
+
 	if (mode == SRIOV_LEGACY) {
 		err = esw_create_legacy_fdb_table(esw);
 	} else {
@@ -1685,6 +1687,8 @@ void mlx5_eswitch_disable_sriov(struct mlx5_eswitch *esw)
 	old_mode = esw->mode;
 	esw->mode = SRIOV_NONE;
 
+	mlx5_lag_update(esw->dev);
+
 	if (old_mode == SRIOV_OFFLOADS)
 		mlx5_reload_interface(esw->dev, MLX5_INTERFACE_PROTOCOL_IB);
 }
@@ -2220,3 +2224,12 @@ u8 mlx5_eswitch_mode(struct mlx5_eswitch *esw)
 	return ESW_ALLOWED(esw) ? esw->mode : SRIOV_NONE;
 }
 EXPORT_SYMBOL_GPL(mlx5_eswitch_mode);
+
+bool mlx5_esw_lag_prereq(struct mlx5_core_dev *dev0, struct mlx5_core_dev *dev1)
+{
+	if (dev0->priv.eswitch->mode == SRIOV_NONE &&
+	    dev1->priv.eswitch->mode == SRIOV_NONE)
+		return true;
+
+	return false;
+}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag.c b/drivers/net/ethernet/mellanox/mlx5/core/lag.c
index b22ba13a9522..07e869ccb2b6 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag.c
@@ -62,11 +62,6 @@ struct mlx5_lag {
 	struct lag_tracker        tracker;
 	struct delayed_work       bond_work;
 	struct notifier_block     nb;
-
-	/* Admin state. Allow lag only if allowed is true
-	 * even if network conditions for lag were met
-	 */
-	bool                      allowed;
 };
 
 /* General purpose, use for short periods of time.
@@ -254,6 +249,16 @@ static void mlx5_deactivate_lag(struct mlx5_lag *ldev)
 			      err);
 }
 
+static bool mlx5_lag_check_prereq(struct mlx5_lag *ldev)
+{
+	if (ldev->pf[0].dev &&
+	    ldev->pf[1].dev &&
+	    mlx5_esw_lag_prereq(ldev->pf[0].dev, ldev->pf[1].dev))
+		return true;
+	else
+		return false;
+}
+
 static void mlx5_do_bond(struct mlx5_lag *ldev)
 {
 	struct mlx5_core_dev *dev0 = ldev->pf[0].dev;
@@ -271,7 +276,7 @@ static void mlx5_do_bond(struct mlx5_lag *ldev)
 	tracker = ldev->tracker;
 	mutex_unlock(&lag_mutex);
 
-	do_bond = tracker.is_bonded && ldev->allowed;
+	do_bond = tracker.is_bonded && mlx5_lag_check_prereq(ldev);
 
 	if (do_bond && !mlx5_lag_is_bonded(ldev)) {
 		if (!sriov_enabled)
@@ -449,15 +454,6 @@ static int mlx5_lag_netdev_event(struct notifier_block *this,
 	return NOTIFY_DONE;
 }
 
-static bool mlx5_lag_check_prereq(struct mlx5_lag *ldev)
-{
-	if ((ldev->pf[0].dev && mlx5_sriov_is_enabled(ldev->pf[0].dev)) ||
-	    (ldev->pf[1].dev && mlx5_sriov_is_enabled(ldev->pf[1].dev)))
-		return false;
-	else
-		return true;
-}
-
 static struct mlx5_lag *mlx5_lag_dev_alloc(void)
 {
 	struct mlx5_lag *ldev;
@@ -467,7 +463,6 @@ static struct mlx5_lag *mlx5_lag_dev_alloc(void)
 		return NULL;
 
 	INIT_DELAYED_WORK(&ldev->bond_work, mlx5_do_bond_work);
-	ldev->allowed = mlx5_lag_check_prereq(ldev);
 
 	return ldev;
 }
@@ -492,7 +487,6 @@ static void mlx5_lag_dev_add_pf(struct mlx5_lag *ldev,
 	ldev->tracker.netdev_state[fn].link_up = 0;
 	ldev->tracker.netdev_state[fn].tx_enabled = 0;
 
-	ldev->allowed = mlx5_lag_check_prereq(ldev);
 	dev->priv.lag = ldev;
 
 	mutex_unlock(&lag_mutex);
@@ -514,7 +508,6 @@ static void mlx5_lag_dev_remove_pf(struct mlx5_lag *ldev,
 	memset(&ldev->pf[i], 0, sizeof(*ldev->pf));
 
 	dev->priv.lag = NULL;
-	ldev->allowed = mlx5_lag_check_prereq(ldev);
 	mutex_unlock(&lag_mutex);
 }
 
@@ -593,42 +586,19 @@ bool mlx5_lag_is_active(struct mlx5_core_dev *dev)
 }
 EXPORT_SYMBOL(mlx5_lag_is_active);
 
-static int mlx5_lag_set_state(struct mlx5_core_dev *dev, bool allow)
+void mlx5_lag_update(struct mlx5_core_dev *dev)
 {
 	struct mlx5_lag *ldev;
-	int ret = 0;
-	bool lag_active;
 
 	mlx5_dev_list_lock();
-
 	ldev = mlx5_lag_dev_get(dev);
-	if (!ldev) {
-		ret = -ENODEV;
-		goto unlock;
-	}
-	lag_active = mlx5_lag_is_bonded(ldev);
-	if (!mlx5_lag_check_prereq(ldev) && allow) {
-		ret = -EINVAL;
-		goto unlock;
-	}
-	if (ldev->allowed == allow)
+	if (!ldev)
 		goto unlock;
-	ldev->allowed = allow;
-	if ((lag_active && !allow) || allow)
-		mlx5_do_bond(ldev);
-unlock:
-	mlx5_dev_list_unlock();
-	return ret;
-}
 
-int mlx5_lag_forbid(struct mlx5_core_dev *dev)
-{
-	return mlx5_lag_set_state(dev, false);
-}
+	mlx5_do_bond(ldev);
 
-int mlx5_lag_allow(struct mlx5_core_dev *dev)
-{
-	return mlx5_lag_set_state(dev, true);
+unlock:
+	mlx5_dev_list_unlock();
 }
 
 struct net_device *mlx5_lag_get_roce_netdev(struct mlx5_core_dev *dev)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/sriov.c b/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
index a0674962f02c..6e178030d8fb 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
@@ -216,20 +216,10 @@ int mlx5_core_sriov_configure(struct pci_dev *pdev, int num_vfs)
 	if (!mlx5_core_is_pf(dev))
 		return -EPERM;
 
-	if (num_vfs) {
-		int ret;
-
-		ret = mlx5_lag_forbid(dev);
-		if (ret && (ret != -ENODEV))
-			return ret;
-	}
-
-	if (num_vfs) {
+	if (num_vfs)
 		err = mlx5_sriov_enable(pdev, num_vfs);
-	} else {
+	else
 		mlx5_sriov_disable(pdev);
-		mlx5_lag_allow(dev);
-	}
 
 	return err ? err : num_vfs;
 }
