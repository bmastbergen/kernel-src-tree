usb: typec: Bus type for alternate modes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [usb] typec: Bus type for alternate modes (Torez Smith) [1657401]
Rebuild_FUZZ: 93.33%
commit-author Heikki Krogerus <heikki.krogerus@linux.intel.com>
commit 8a37d87d72f0c69f837229c04d2fcd7117ea57e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/8a37d87d.failed

Introducing a simple bus for the alternate modes. Bus allows
binding drivers to the discovered alternate modes the
partners support.

	Signed-off-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
	Tested-by: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 8a37d87d72f0c69f837229c04d2fcd7117ea57e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/usb/typec_bus.rst
#	drivers/usb/typec/Makefile
#	drivers/usb/typec/typec.c
#	include/linux/mod_devicetable.h
#	include/linux/usb/typec.h
diff --cc drivers/usb/typec/Makefile
index d54a5e7149dd,335ee06748fc..000000000000
--- a/drivers/usb/typec/Makefile
+++ b/drivers/usb/typec/Makefile
@@@ -1,5 -1,6 +1,9 @@@
  # SPDX-License-Identifier: GPL-2.0
  obj-$(CONFIG_TYPEC)		+= typec.o
++<<<<<<< HEAD
++=======
+ typec-y				:= class.o mux.o bus.o
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes)
  obj-$(CONFIG_TYPEC_TCPM)	+= tcpm.o
  obj-y				+= fusb302/
  obj-$(CONFIG_TYPEC_WCOVE)	+= typec_wcove.o
diff --cc drivers/usb/typec/typec.c
index a0a95ac4685a,c202975f8097..000000000000
--- a/drivers/usb/typec/typec.c
+++ b/drivers/usb/typec/typec.c
@@@ -10,37 -10,8 +10,42 @@@
  #include <linux/module.h>
  #include <linux/mutex.h>
  #include <linux/slab.h>
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +#include <linux/usb/typec.h>
 +#include <linux/idr.h>
 +#include <linux/string.h>
 +
 +
 +struct typec_mode {
 +	int				index;
 +	u32				vdo;
 +	char				*desc;
 +	enum typec_port_type		roles;
 +
 +	struct typec_altmode		*alt_mode;
 +
 +	unsigned int			active:1;
 +
 +	char				group_name[6];
 +	struct attribute_group		group;
 +	struct attribute		*attrs[5];
 +	struct device_attribute		vdo_attr;
 +	struct device_attribute		desc_attr;
 +	struct device_attribute		active_attr;
 +	struct device_attribute		roles_attr;
 +};
 +
 +struct typec_altmode {
 +	struct device			dev;
 +	u16				svid;
 +	int				n_modes;
 +	struct typec_mode		modes[ALTMODE_MAX_MODES];
 +	const struct attribute_group	*mode_groups[ALTMODE_MAX_MODES];
 +};
++=======
+ 
+ #include "bus.h"
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  
  struct typec_plug {
  	struct device			dev;
@@@ -171,28 -147,148 +176,169 @@@ static void typec_report_identity(struc
  /* ------------------------------------------------------------------------- */
  /* Alternate Modes */
  
+ static int altmode_match(struct device *dev, void *data)
+ {
+ 	struct typec_altmode *adev = to_typec_altmode(dev);
+ 	struct typec_device_id *id = data;
+ 
+ 	if (!is_typec_altmode(dev))
+ 		return 0;
+ 
+ 	return ((adev->svid == id->svid) && (adev->mode == id->mode));
+ }
+ 
+ static void typec_altmode_set_partner(struct altmode *altmode)
+ {
+ 	struct typec_altmode *adev = &altmode->adev;
+ 	struct typec_device_id id = { adev->svid, adev->mode, };
+ 	struct typec_port *port = typec_altmode2port(adev);
+ 	struct altmode *partner;
+ 	struct device *dev;
+ 
+ 	dev = device_find_child(&port->dev, &id, altmode_match);
+ 	if (!dev)
+ 		return;
+ 
+ 	/* Bind the port alt mode to the partner/plug alt mode. */
+ 	partner = to_altmode(to_typec_altmode(dev));
+ 	altmode->partner = partner;
+ 
+ 	/* Bind the partner/plug alt mode to the port alt mode. */
+ 	if (is_typec_plug(adev->dev.parent)) {
+ 		struct typec_plug *plug = to_typec_plug(adev->dev.parent);
+ 
+ 		partner->plug[plug->index] = altmode;
+ 	} else {
+ 		partner->partner = altmode;
+ 	}
+ }
+ 
+ static void typec_altmode_put_partner(struct altmode *altmode)
+ {
+ 	struct altmode *partner = altmode->partner;
+ 	struct typec_altmode *adev;
+ 
+ 	if (!partner)
+ 		return;
+ 
+ 	adev = &partner->adev;
+ 
+ 	if (is_typec_plug(adev->dev.parent)) {
+ 		struct typec_plug *plug = to_typec_plug(adev->dev.parent);
+ 
+ 		partner->plug[plug->index] = NULL;
+ 	} else {
+ 		partner->partner = NULL;
+ 	}
+ 	put_device(&adev->dev);
+ }
+ 
+ static int __typec_port_match(struct device *dev, const void *name)
+ {
+ 	return !strcmp((const char *)name, dev_name(dev));
+ }
+ 
+ static void *typec_port_match(struct device_connection *con, int ep, void *data)
+ {
+ 	return class_find_device(typec_class, NULL, con->endpoint[ep],
+ 				 __typec_port_match);
+ }
+ 
+ struct typec_altmode *
+ typec_altmode_register_notifier(struct device *dev, u16 svid, u8 mode,
+ 				struct notifier_block *nb)
+ {
+ 	struct typec_device_id id = { svid, mode, };
+ 	struct device *altmode_dev;
+ 	struct device *port_dev;
+ 	struct altmode *altmode;
+ 	int ret;
+ 
+ 	/* Find the port linked to the caller */
+ 	port_dev = device_connection_find_match(dev, NULL, NULL,
+ 						typec_port_match);
+ 	if (IS_ERR_OR_NULL(port_dev))
+ 		return port_dev ? ERR_CAST(port_dev) : ERR_PTR(-ENODEV);
+ 
+ 	/* Find the altmode with matching svid */
+ 	altmode_dev = device_find_child(port_dev, &id, altmode_match);
+ 
+ 	put_device(port_dev);
+ 
+ 	if (!altmode_dev)
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	altmode = to_altmode(to_typec_altmode(altmode_dev));
+ 
+ 	/* Register notifier */
+ 	ret = blocking_notifier_chain_register(&altmode->nh, nb);
+ 	if (ret) {
+ 		put_device(altmode_dev);
+ 		return ERR_PTR(ret);
+ 	}
+ 
+ 	return &altmode->adev;
+ }
+ EXPORT_SYMBOL_GPL(typec_altmode_register_notifier);
+ 
+ void typec_altmode_unregister_notifier(struct typec_altmode *adev,
+ 				       struct notifier_block *nb)
+ {
+ 	struct altmode *altmode = to_altmode(adev);
+ 
+ 	blocking_notifier_chain_unregister(&altmode->nh, nb);
+ 	put_device(&adev->dev);
+ }
+ EXPORT_SYMBOL_GPL(typec_altmode_unregister_notifier);
+ 
  /**
   * typec_altmode_update_active - Report Enter/Exit mode
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 + * @alt: Handle to the alternate mode
 + * @mode: Mode index
++=======
+  * @adev: Handle to the alternate mode
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
   * @active: True when the mode has been entered
   *
   * If a partner or cable plug executes Enter/Exit Mode command successfully, the
   * drivers use this routine to report the updated state of the mode.
   */
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +void typec_altmode_update_active(struct typec_altmode *alt, int mode,
 +				 bool active)
++=======
+ void typec_altmode_update_active(struct typec_altmode *adev, bool active)
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  {
 +	struct typec_mode *m = &alt->modes[mode];
  	char dir[6];
  
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +	if (m->active == active)
 +		return;
 +
 +	m->active = active;
 +	snprintf(dir, sizeof(dir), "mode%d", mode);
 +	sysfs_notify(&alt->dev.kobj, dir, "active");
 +	kobject_uevent(&alt->dev.kobj, KOBJ_CHANGE);
++=======
+ 	if (adev->active == active)
+ 		return;
+ 
+ 	if (!is_typec_port(adev->dev.parent)) {
+ 		if (!active)
+ 			module_put(adev->dev.driver->owner);
+ 		else
+ 			WARN_ON(!try_module_get(adev->dev.driver->owner));
+ 	}
+ 
+ 	adev->active = active;
+ 	snprintf(dir, sizeof(dir), "mode%d", adev->mode);
+ 	sysfs_notify(&adev->dev.kobj, dir, "active");
+ 	sysfs_notify(&adev->dev.kobj, NULL, "active");
+ 	kobject_uevent(&adev->dev.kobj, KOBJ_CHANGE);
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  }
  EXPORT_SYMBOL_GPL(typec_altmode_update_active);
  
@@@ -217,72 -313,82 +363,116 @@@ struct typec_port *typec_altmode2port(s
  EXPORT_SYMBOL_GPL(typec_altmode2port);
  
  static ssize_t
 -vdo_show(struct device *dev, struct device_attribute *attr, char *buf)
 +typec_altmode_vdo_show(struct device *dev, struct device_attribute *attr,
 +		       char *buf)
  {
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +	struct typec_mode *mode = container_of(attr, struct typec_mode,
 +					       vdo_attr);
++=======
+ 	struct typec_altmode *alt = to_typec_altmode(dev);
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  
 -	return sprintf(buf, "0x%08x\n", alt->vdo);
 +	return sprintf(buf, "0x%08x\n", mode->vdo);
  }
 -static DEVICE_ATTR_RO(vdo);
  
  static ssize_t
 -description_show(struct device *dev, struct device_attribute *attr, char *buf)
 +typec_altmode_desc_show(struct device *dev, struct device_attribute *attr,
 +			char *buf)
  {
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +	struct typec_mode *mode = container_of(attr, struct typec_mode,
 +					       desc_attr);
++=======
+ 	struct typec_altmode *alt = to_typec_altmode(dev);
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  
 -	return sprintf(buf, "%s\n", alt->desc ? alt->desc : "");
 +	return sprintf(buf, "%s\n", mode->desc ? mode->desc : "");
  }
 -static DEVICE_ATTR_RO(description);
  
  static ssize_t
 -active_show(struct device *dev, struct device_attribute *attr, char *buf)
 +typec_altmode_active_show(struct device *dev, struct device_attribute *attr,
 +			  char *buf)
  {
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +	struct typec_mode *mode = container_of(attr, struct typec_mode,
 +					       active_attr);
++=======
+ 	struct typec_altmode *alt = to_typec_altmode(dev);
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  
 -	return sprintf(buf, "%s\n", alt->active ? "yes" : "no");
 +	return sprintf(buf, "%s\n", mode->active ? "yes" : "no");
  }
  
 -static ssize_t active_store(struct device *dev, struct device_attribute *attr,
 -			    const char *buf, size_t size)
 -{
 +static ssize_t
 +typec_altmode_active_store(struct device *dev, struct device_attribute *attr,
 +			   const char *buf, size_t size)
 +{
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +	struct typec_mode *mode = container_of(attr, struct typec_mode,
 +					       active_attr);
 +	struct typec_port *port = typec_altmode2port(mode->alt_mode);
 +	bool activate;
++=======
+ 	struct typec_altmode *adev = to_typec_altmode(dev);
+ 	struct altmode *altmode = to_altmode(adev);
+ 	bool enter;
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  	int ret;
  
- 	if (!port->cap->activate_mode)
- 		return -EOPNOTSUPP;
- 
- 	ret = kstrtobool(buf, &activate);
+ 	ret = kstrtobool(buf, &enter);
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +	ret = port->cap->activate_mode(port->cap, mode->index, activate);
 +	if (ret)
 +		return ret;
++=======
+ 	if (adev->active == enter)
+ 		return size;
+ 
+ 	if (is_typec_port(adev->dev.parent)) {
+ 		typec_altmode_update_active(adev, enter);
+ 
+ 		/* Make sure that the partner exits the mode before disabling */
+ 		if (altmode->partner && !enter && altmode->partner->adev.active)
+ 			typec_altmode_exit(&altmode->partner->adev);
+ 	} else if (altmode->partner) {
+ 		if (enter && !altmode->partner->adev.active) {
+ 			dev_warn(dev, "port has the mode disabled\n");
+ 			return -EPERM;
+ 		}
+ 	}
+ 
+ 	/* Note: If there is no driver, the mode will not be entered */
+ 	if (adev->ops && adev->ops->activate) {
+ 		ret = adev->ops->activate(adev, enter);
+ 		if (ret)
+ 			return ret;
+ 	}
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  
  	return size;
  }
 -static DEVICE_ATTR_RW(active);
  
  static ssize_t
 -supported_roles_show(struct device *dev, struct device_attribute *attr,
 -		     char *buf)
 +typec_altmode_roles_show(struct device *dev, struct device_attribute *attr,
 +			 char *buf)
  {
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +	struct typec_mode *mode = container_of(attr, struct typec_mode,
 +					       roles_attr);
++=======
+ 	struct altmode *alt = to_altmode(to_typec_altmode(dev));
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  	ssize_t ret;
  
 -	switch (alt->roles) {
 -	case TYPEC_PORT_SRC:
 +	switch (mode->roles) {
 +	case TYPEC_PORT_DFP:
  		ret = sprintf(buf, "source\n");
  		break;
 -	case TYPEC_PORT_SNK:
 +	case TYPEC_PORT_UFP:
  		ret = sprintf(buf, "sink\n");
  		break;
  	case TYPEC_PORT_DRP:
@@@ -292,69 -398,23 +482,79 @@@
  	}
  	return ret;
  }
 -static DEVICE_ATTR_RO(supported_roles);
  
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +static void typec_init_modes(struct typec_altmode *alt,
 +			     const struct typec_mode_desc *desc, bool is_port)
 +{
 +	int i;
 +
 +	for (i = 0; i < alt->n_modes; i++, desc++) {
 +		struct typec_mode *mode = &alt->modes[i];
 +
 +		/* Not considering the human readable description critical */
 +		mode->desc = kstrdup(desc->desc, GFP_KERNEL);
 +		if (desc->desc && !mode->desc)
 +			dev_err(&alt->dev, "failed to copy mode%d desc\n", i);
 +
 +		mode->alt_mode = alt;
 +		mode->vdo = desc->vdo;
 +		mode->roles = desc->roles;
 +		mode->index = desc->index;
 +		sprintf(mode->group_name, "mode%d", desc->index);
 +
 +		sysfs_attr_init(&mode->vdo_attr.attr);
 +		mode->vdo_attr.attr.name = "vdo";
 +		mode->vdo_attr.attr.mode = 0444;
 +		mode->vdo_attr.show = typec_altmode_vdo_show;
 +
 +		sysfs_attr_init(&mode->desc_attr.attr);
 +		mode->desc_attr.attr.name = "description";
 +		mode->desc_attr.attr.mode = 0444;
 +		mode->desc_attr.show = typec_altmode_desc_show;
 +
 +		sysfs_attr_init(&mode->active_attr.attr);
 +		mode->active_attr.attr.name = "active";
 +		mode->active_attr.attr.mode = 0644;
 +		mode->active_attr.show = typec_altmode_active_show;
 +		mode->active_attr.store = typec_altmode_active_store;
 +
 +		mode->attrs[0] = &mode->vdo_attr.attr;
 +		mode->attrs[1] = &mode->desc_attr.attr;
 +		mode->attrs[2] = &mode->active_attr.attr;
 +
 +		/* With ports, list the roles that the mode is supported with */
 +		if (is_port) {
 +			sysfs_attr_init(&mode->roles_attr.attr);
 +			mode->roles_attr.attr.name = "supported_roles";
 +			mode->roles_attr.attr.mode = 0444;
 +			mode->roles_attr.show = typec_altmode_roles_show;
 +
 +			mode->attrs[3] = &mode->roles_attr.attr;
 +		}
 +
 +		mode->group.attrs = mode->attrs;
 +		mode->group.name = mode->group_name;
 +
 +		alt->mode_groups[i] = &mode->group;
 +	}
++=======
+ static ssize_t
+ mode_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct typec_altmode *adev = to_typec_altmode(dev);
+ 
+ 	return sprintf(buf, "%u\n", adev->mode);
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  }
+ static DEVICE_ATTR_RO(mode);
  
- static ssize_t svid_show(struct device *dev, struct device_attribute *attr,
- 			 char *buf)
+ static ssize_t
+ svid_show(struct device *dev, struct device_attribute *attr, char *buf)
  {
- 	struct typec_altmode *alt = to_altmode(dev);
+ 	struct typec_altmode *adev = to_typec_altmode(dev);
  
- 	return sprintf(buf, "%04x\n", alt->svid);
+ 	return sprintf(buf, "%04x\n", adev->svid);
  }
  static DEVICE_ATTR_RO(svid);
  
@@@ -364,17 -427,45 +567,59 @@@ static struct attribute *typec_altmode_
  };
  ATTRIBUTE_GROUPS(typec_altmode);
  
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +static void typec_altmode_release(struct device *dev)
 +{
 +	struct typec_altmode *alt = to_altmode(dev);
 +	int i;
 +
 +	for (i = 0; i < alt->n_modes; i++)
 +		kfree(alt->modes[i].desc);
 +	kfree(alt);
 +}
 +
 +static const struct device_type typec_altmode_dev_type = {
++=======
+ static int altmode_id_get(struct device *dev)
+ {
+ 	struct ida *ids;
+ 
+ 	if (is_typec_partner(dev))
+ 		ids = &to_typec_partner(dev)->mode_ids;
+ 	else if (is_typec_plug(dev))
+ 		ids = &to_typec_plug(dev)->mode_ids;
+ 	else
+ 		ids = &to_typec_port(dev)->mode_ids;
+ 
+ 	return ida_simple_get(ids, 0, 0, GFP_KERNEL);
+ }
+ 
+ static void altmode_id_remove(struct device *dev, int id)
+ {
+ 	struct ida *ids;
+ 
+ 	if (is_typec_partner(dev))
+ 		ids = &to_typec_partner(dev)->mode_ids;
+ 	else if (is_typec_plug(dev))
+ 		ids = &to_typec_plug(dev)->mode_ids;
+ 	else
+ 		ids = &to_typec_port(dev)->mode_ids;
+ 
+ 	ida_simple_remove(ids, id);
+ }
+ 
+ static void typec_altmode_release(struct device *dev)
+ {
+ 	struct altmode *alt = to_altmode(to_typec_altmode(dev));
+ 
+ 	typec_altmode_put_partner(alt);
+ 
+ 	altmode_id_remove(alt->adev.dev.parent, alt->id);
+ 	kfree(alt);
+ }
+ 
+ const struct device_type typec_altmode_dev_type = {
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  	.name = "typec_alternate_mode",
  	.groups = typec_altmode_groups,
  	.release = typec_altmode_release,
@@@ -391,16 -484,42 +638,53 @@@ typec_register_altmode(struct device *p
  	if (!alt)
  		return ERR_PTR(-ENOMEM);
  
++<<<<<<< HEAD:drivers/usb/typec/typec.c
 +	alt->svid = desc->svid;
 +	alt->n_modes = desc->n_modes;
 +	typec_init_modes(alt, desc->modes, is_typec_port(parent));
 +
 +	alt->dev.parent = parent;
 +	alt->dev.groups = alt->mode_groups;
 +	alt->dev.type = &typec_altmode_dev_type;
 +	dev_set_name(&alt->dev, "svid-%04x", alt->svid);
++=======
+ 	alt->adev.svid = desc->svid;
+ 	alt->adev.mode = desc->mode;
+ 	alt->adev.vdo = desc->vdo;
+ 	alt->roles = desc->roles;
+ 	alt->id = id;
+ 
+ 	alt->attrs[0] = &dev_attr_vdo.attr;
+ 	alt->attrs[1] = &dev_attr_description.attr;
+ 	alt->attrs[2] = &dev_attr_active.attr;
+ 
+ 	if (is_port) {
+ 		alt->attrs[3] = &dev_attr_supported_roles.attr;
+ 		alt->adev.active = true; /* Enabled by default */
+ 	}
  
- 	ret = device_register(&alt->dev);
+ 	sprintf(alt->group_name, "mode%d", desc->mode);
+ 	alt->group.name = alt->group_name;
+ 	alt->group.attrs = alt->attrs;
+ 	alt->groups[0] = &alt->group;
+ 
+ 	alt->adev.dev.parent = parent;
+ 	alt->adev.dev.groups = alt->groups;
+ 	alt->adev.dev.type = &typec_altmode_dev_type;
+ 	dev_set_name(&alt->adev.dev, "%s.%u", dev_name(parent), id);
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
+ 
+ 	/* Link partners and plugs with the ports */
+ 	if (is_port)
+ 		BLOCKING_INIT_NOTIFIER_HEAD(&alt->nh);
+ 	else
+ 		typec_altmode_set_partner(alt);
+ 
+ 	/* The partners are bind to drivers */
+ 	if (is_typec_partner(parent))
+ 		alt->adev.dev.bus = &typec_bus;
+ 
+ 	ret = device_register(&alt->adev.dev);
  	if (ret) {
  		dev_err(parent, "failed to register alternate mode (%d)\n",
  			ret);
@@@ -1140,6 -1269,9 +1430,12 @@@ static void typec_release(struct devic
  	struct typec_port *port = to_typec_port(dev);
  
  	ida_simple_remove(&typec_index_ida, port->id);
++<<<<<<< HEAD:drivers/usb/typec/typec.c
++=======
+ 	ida_destroy(&port->mode_ids);
+ 	typec_switch_put(port->sw);
+ 	typec_mux_put(port->mux);
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  	kfree(port);
  }
  
@@@ -1249,6 -1381,103 +1545,106 @@@ void typec_set_pwr_opmode(struct typec_
  }
  EXPORT_SYMBOL_GPL(typec_set_pwr_opmode);
  
++<<<<<<< HEAD:drivers/usb/typec/typec.c
++=======
+ /**
+  * typec_find_port_power_role - Get the typec port power capability
+  * @name: port power capability string
+  *
+  * This routine is used to find the typec_port_type by its string name.
+  *
+  * Returns typec_port_type if success, otherwise negative error code.
+  */
+ int typec_find_port_power_role(const char *name)
+ {
+ 	return match_string(typec_port_power_roles,
+ 			    ARRAY_SIZE(typec_port_power_roles), name);
+ }
+ EXPORT_SYMBOL_GPL(typec_find_port_power_role);
+ 
+ /**
+  * typec_find_power_role - Find the typec one specific power role
+  * @name: power role string
+  *
+  * This routine is used to find the typec_role by its string name.
+  *
+  * Returns typec_role if success, otherwise negative error code.
+  */
+ int typec_find_power_role(const char *name)
+ {
+ 	return match_string(typec_roles, ARRAY_SIZE(typec_roles), name);
+ }
+ EXPORT_SYMBOL_GPL(typec_find_power_role);
+ 
+ /**
+  * typec_find_port_data_role - Get the typec port data capability
+  * @name: port data capability string
+  *
+  * This routine is used to find the typec_port_data by its string name.
+  *
+  * Returns typec_port_data if success, otherwise negative error code.
+  */
+ int typec_find_port_data_role(const char *name)
+ {
+ 	return match_string(typec_port_data_roles,
+ 			    ARRAY_SIZE(typec_port_data_roles), name);
+ }
+ EXPORT_SYMBOL_GPL(typec_find_port_data_role);
+ 
+ /* ------------------------------------------ */
+ /* API for Multiplexer/DeMultiplexer Switches */
+ 
+ /**
+  * typec_set_orientation - Set USB Type-C cable plug orientation
+  * @port: USB Type-C Port
+  * @orientation: USB Type-C cable plug orientation
+  *
+  * Set cable plug orientation for @port.
+  */
+ int typec_set_orientation(struct typec_port *port,
+ 			  enum typec_orientation orientation)
+ {
+ 	int ret;
+ 
+ 	if (port->sw) {
+ 		ret = port->sw->set(port->sw, orientation);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	port->orientation = orientation;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(typec_set_orientation);
+ 
+ /**
+  * typec_get_orientation - Get USB Type-C cable plug orientation
+  * @port: USB Type-C Port
+  *
+  * Get current cable plug orientation for @port.
+  */
+ enum typec_orientation typec_get_orientation(struct typec_port *port)
+ {
+ 	return port->orientation;
+ }
+ EXPORT_SYMBOL_GPL(typec_get_orientation);
+ 
+ /**
+  * typec_set_mode - Set mode of operation for USB Type-C connector
+  * @port: USB Type-C connector
+  * @mode: Accessory Mode, USB Operation or Safe State
+  *
+  * Configure @port for Accessory Mode @mode. This function will configure the
+  * muxes needed for @mode.
+  */
+ int typec_set_mode(struct typec_port *port, int mode)
+ {
+ 	return port->mux ? port->mux->set(port->mux, mode) : 0;
+ }
+ EXPORT_SYMBOL_GPL(typec_set_mode);
+ 
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes):drivers/usb/typec/class.c
  /* --------------------------------------- */
  
  /**
@@@ -1296,23 -1541,53 +1709,26 @@@ struct typec_port *typec_register_port(
  		return ERR_PTR(id);
  	}
  
 -	port->sw = typec_switch_get(cap->fwnode ? &port->dev : parent);
 -	if (IS_ERR(port->sw)) {
 -		ret = PTR_ERR(port->sw);
 -		goto err_switch;
 -	}
 -
 -	port->mux = typec_mux_get(parent, "typec-mux");
 -	if (IS_ERR(port->mux)) {
 -		ret = PTR_ERR(port->mux);
 -		goto err_mux;
 -	}
 +	if (cap->type == TYPEC_PORT_DFP)
 +		role = TYPEC_SOURCE;
 +	else if (cap->type == TYPEC_PORT_UFP)
 +		role = TYPEC_SINK;
 +	else
 +		role = cap->prefer_role;
  
 -	switch (cap->type) {
 -	case TYPEC_PORT_SRC:
 +	if (role == TYPEC_SOURCE) {
 +		port->data_role = TYPEC_HOST;
  		port->pwr_role = TYPEC_SOURCE;
  		port->vconn_role = TYPEC_SOURCE;
 -		break;
 -	case TYPEC_PORT_SNK:
 +	} else {
 +		port->data_role = TYPEC_DEVICE;
  		port->pwr_role = TYPEC_SINK;
  		port->vconn_role = TYPEC_SINK;
 -		break;
 -	case TYPEC_PORT_DRP:
 -		if (cap->prefer_role != TYPEC_NO_PREFERRED_ROLE)
 -			port->pwr_role = cap->prefer_role;
 -		else
 -			port->pwr_role = TYPEC_SINK;
 -		break;
 -	}
 -
 -	switch (cap->data) {
 -	case TYPEC_PORT_DFP:
 -		port->data_role = TYPEC_HOST;
 -		break;
 -	case TYPEC_PORT_UFP:
 -		port->data_role = TYPEC_DEVICE;
 -		break;
 -	case TYPEC_PORT_DRD:
 -		if (cap->prefer_role == TYPEC_SOURCE)
 -			port->data_role = TYPEC_HOST;
 -		else
 -			port->data_role = TYPEC_DEVICE;
 -		break;
  	}
  
+ 	ida_init(&port->mode_ids);
+ 	mutex_init(&port->port_type_lock);
+ 
  	port->id = id;
  	port->cap = cap;
  	port->port_type = cap->type;
diff --cc include/linux/mod_devicetable.h
index 99955ace3ecd,1298a7daa57d..000000000000
--- a/include/linux/mod_devicetable.h
+++ b/include/linux/mod_devicetable.h
@@@ -637,4 -706,59 +637,62 @@@ struct ulpi_device_id 
  	kernel_ulong_t driver_data;
  };
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct fsl_mc_device_id - MC object device identifier
+  * @vendor: vendor ID
+  * @obj_type: MC object type
+  *
+  * Type of entries in the "device Id" table for MC object devices supported by
+  * a MC object device driver. The last entry of the table has vendor set to 0x0
+  */
+ struct fsl_mc_device_id {
+ 	__u16 vendor;
+ 	const char obj_type[16];
+ };
+ 
+ /**
+  * struct tb_service_id - Thunderbolt service identifiers
+  * @match_flags: Flags used to match the structure
+  * @protocol_key: Protocol key the service supports
+  * @protocol_id: Protocol id the service supports
+  * @protocol_version: Version of the protocol
+  * @protocol_revision: Revision of the protocol software
+  * @driver_data: Driver specific data
+  *
+  * Thunderbolt XDomain services are exposed as devices where each device
+  * carries the protocol information the service supports. Thunderbolt
+  * XDomain service drivers match against that information.
+  */
+ struct tb_service_id {
+ 	__u32 match_flags;
+ 	char protocol_key[8 + 1];
+ 	__u32 protocol_id;
+ 	__u32 protocol_version;
+ 	__u32 protocol_revision;
+ 	kernel_ulong_t driver_data;
+ };
+ 
+ #define TBSVC_MATCH_PROTOCOL_KEY	0x0001
+ #define TBSVC_MATCH_PROTOCOL_ID		0x0002
+ #define TBSVC_MATCH_PROTOCOL_VERSION	0x0004
+ #define TBSVC_MATCH_PROTOCOL_REVISION	0x0008
+ 
+ /* USB Type-C Alternate Modes */
+ 
+ #define TYPEC_ANY_MODE	0x7
+ 
+ /**
+  * struct typec_device_id - USB Type-C alternate mode identifiers
+  * @svid: Standard or Vendor ID
+  * @mode: Mode index
+  */
+ struct typec_device_id {
+ 	__u16 svid;
+ 	__u8 mode;
+ 	kernel_ulong_t driver_data;
+ };
+ 
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes)
  #endif /* LINUX_MOD_DEVICETABLE_H */
diff --cc include/linux/usb/typec.h
index 0d44ce6af08f,7df4ecabc78a..000000000000
--- a/include/linux/usb/typec.h
+++ b/include/linux/usb/typec.h
@@@ -20,11 -16,18 +16,12 @@@ struct typec_plug
  struct typec_port;
  
  struct fwnode_handle;
+ struct device;
  
  enum typec_port_type {
 -	TYPEC_PORT_SRC,
 -	TYPEC_PORT_SNK,
 -	TYPEC_PORT_DRP,
 -};
 -
 -enum typec_port_data {
  	TYPEC_PORT_DFP,
  	TYPEC_PORT_UFP,
 -	TYPEC_PORT_DRD,
 +	TYPEC_PORT_DRP,
  };
  
  enum typec_plug_type {
@@@ -112,8 -101,10 +109,15 @@@ struct typec_mode_desc 
   */
  struct typec_altmode_desc {
  	u16			svid;
++<<<<<<< HEAD
 +	int			n_modes;
 +	struct typec_mode_desc	modes[ALTMODE_MAX_MODES];
++=======
+ 	u8			mode;
+ 	u32			vdo;
+ 	/* Only used with ports */
+ 	enum typec_port_data	roles;
++>>>>>>> 8a37d87d72f0 (usb: typec: Bus type for alternate modes)
  };
  
  struct typec_altmode
* Unmerged path Documentation/usb/typec_bus.rst
diff --git a/Documentation/ABI/obsolete/sysfs-class-typec b/Documentation/ABI/obsolete/sysfs-class-typec
new file mode 100644
index 000000000000..32623514ee87
--- /dev/null
+++ b/Documentation/ABI/obsolete/sysfs-class-typec
@@ -0,0 +1,48 @@
+These files are deprecated and will be removed. The same files are available
+under /sys/bus/typec (see Documentation/ABI/testing/sysfs-bus-typec).
+
+What:		/sys/class/typec/<port|partner|cable>/<dev>/svid
+Date:		April 2017
+Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
+Description:
+		The SVID (Standard or Vendor ID) assigned by USB-IF for this
+		alternate mode.
+
+What:		/sys/class/typec/<port|partner|cable>/<dev>/mode<index>/
+Date:		April 2017
+Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
+Description:
+		Every supported mode will have its own directory. The name of
+		a mode will be "mode<index>" (for example mode1), where <index>
+		is the actual index to the mode VDO returned by Discover Modes
+		USB power delivery command.
+
+What:		/sys/class/typec/<port|partner|cable>/<dev>/mode<index>/description
+Date:		April 2017
+Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
+Description:
+		Shows description of the mode. The description is optional for
+		the drivers, just like with the Billboard Devices.
+
+What:		/sys/class/typec/<port|partner|cable>/<dev>/mode<index>/vdo
+Date:		April 2017
+Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
+Description:
+		Shows the VDO in hexadecimal returned by Discover Modes command
+		for this mode.
+
+What:		/sys/class/typec/<port|partner|cable>/<dev>/mode<index>/active
+Date:		April 2017
+Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
+Description:
+		Shows if the mode is active or not. The attribute can be used
+		for entering/exiting the mode with partners and cable plugs, and
+		with the port alternate modes it can be used for disabling
+		support for specific alternate modes. Entering/exiting modes is
+		supported as synchronous operation so write(2) to the attribute
+		does not return until the enter/exit mode operation has
+		finished. The attribute is notified when the mode is
+		entered/exited so poll(2) on the attribute wakes up.
+		Entering/exiting a mode will also generate uevent KOBJ_CHANGE.
+
+		Valid values: yes, no
diff --git a/Documentation/ABI/testing/sysfs-bus-typec b/Documentation/ABI/testing/sysfs-bus-typec
new file mode 100644
index 000000000000..205d9c91e2e1
--- /dev/null
+++ b/Documentation/ABI/testing/sysfs-bus-typec
@@ -0,0 +1,51 @@
+What:		/sys/bus/typec/devices/.../active
+Date:		July 2018
+Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
+Description:
+		Shows if the mode is active or not. The attribute can be used
+		for entering/exiting the mode. Entering/exiting modes is
+		supported as synchronous operation so write(2) to the attribute
+		does not return until the enter/exit mode operation has
+		finished. The attribute is notified when the mode is
+		entered/exited so poll(2) on the attribute wakes up.
+		Entering/exiting a mode will also generate uevent KOBJ_CHANGE.
+
+		Valid values are boolean.
+
+What:		/sys/bus/typec/devices/.../description
+Date:		July 2018
+Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
+Description:
+		Shows description of the mode. The description is optional for
+		the drivers, just like with the Billboard Devices.
+
+What:		/sys/bus/typec/devices/.../mode
+Date:		July 2018
+Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
+Description:
+		The index number of the mode returned by Discover Modes USB
+		Power Delivery command. Depending on the alternate mode, the
+		mode index may be significant.
+
+		With some alternate modes (SVIDs), the mode index is assigned
+		for specific functionality in the specification for that
+		alternate mode.
+
+		With other alternate modes, the mode index values are not
+		assigned, and can not be therefore used for identification. When
+		the mode index is not assigned, identifying the alternate mode
+		must be done with either mode VDO or the description.
+
+What:		/sys/bus/typec/devices/.../svid
+Date:		July 2018
+Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
+Description:
+		The Standard or Vendor ID (SVID) assigned by USB-IF for this
+		alternate mode.
+
+What:		/sys/bus/typec/devices/.../vdo
+Date:		July 2018
+Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
+Description:
+		Shows the VDO in hexadecimal returned by Discover Modes command
+		for this mode.
diff --git a/Documentation/ABI/testing/sysfs-class-typec b/Documentation/ABI/testing/sysfs-class-typec
index 5be552e255e9..d7647b258c3c 100644
--- a/Documentation/ABI/testing/sysfs-class-typec
+++ b/Documentation/ABI/testing/sysfs-class-typec
@@ -222,70 +222,12 @@ Description:
 		available. The value can be polled.
 
 
-Alternate Mode devices.
+USB Type-C port alternate mode devices.
 
-The alternate modes will have Standard or Vendor ID (SVID) assigned by USB-IF.
-The ports, partners and cable plugs can have alternate modes. A supported SVID
-will consist of a set of modes. Every SVID a port/partner/plug supports will
-have a device created for it, and every supported mode for a supported SVID will
-have its own directory under that device. Below <dev> refers to the device for
-the alternate mode.
-
-What:		/sys/class/typec/<port|partner|cable>/<dev>/svid
-Date:		April 2017
-Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
-Description:
-		The SVID (Standard or Vendor ID) assigned by USB-IF for this
-		alternate mode.
-
-What:		/sys/class/typec/<port|partner|cable>/<dev>/mode<index>/
-Date:		April 2017
-Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
-Description:
-		Every supported mode will have its own directory. The name of
-		a mode will be "mode<index>" (for example mode1), where <index>
-		is the actual index to the mode VDO returned by Discover Modes
-		USB power delivery command.
-
-What:		/sys/class/typec/<port|partner|cable>/<dev>/mode<index>/description
-Date:		April 2017
-Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
-Description:
-		Shows description of the mode. The description is optional for
-		the drivers, just like with the Billboard Devices.
-
-What:		/sys/class/typec/<port|partner|cable>/<dev>/mode<index>/vdo
-Date:		April 2017
-Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
-Description:
-		Shows the VDO in hexadecimal returned by Discover Modes command
-		for this mode.
-
-What:		/sys/class/typec/<port|partner|cable>/<dev>/mode<index>/active
-Date:		April 2017
-Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
-Description:
-		Shows if the mode is active or not. The attribute can be used
-		for entering/exiting the mode with partners and cable plugs, and
-		with the port alternate modes it can be used for disabling
-		support for specific alternate modes. Entering/exiting modes is
-		supported as synchronous operation so write(2) to the attribute
-		does not return until the enter/exit mode operation has
-		finished. The attribute is notified when the mode is
-		entered/exited so poll(2) on the attribute wakes up.
-		Entering/exiting a mode will also generate uevent KOBJ_CHANGE.
-
-		Valid values: yes, no
-
-What:		/sys/class/typec/<port>/<dev>/mode<index>/supported_roles
+What:		/sys/class/typec/<port>/<alt mode>/supported_roles
 Date:		April 2017
 Contact:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
 Description:
 		Space separated list of the supported roles.
 
-		This attribute is available for the devices describing the
-		alternate modes a port supports, and it will not be exposed with
-		the devices presenting the alternate modes the partners or cable
-		plugs support.
-
 		Valid values: source, sink
* Unmerged path Documentation/usb/typec_bus.rst
diff --git a/MAINTAINERS b/MAINTAINERS
index 5132c623c58a..8f641ebc8d6d 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -9308,7 +9308,7 @@ L:	linux-usb@vger.kernel.org
 S:	Maintained
 F:	drivers/usb/typec/mux/pi3usb30532.c
 
-USB TYPEC SUBSYSTEM
+USB TYPEC CLASS
 M:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
 L:	linux-usb@vger.kernel.org
 S:	Maintained
@@ -9317,6 +9317,15 @@ F:	Documentation/usb/typec.rst
 F:	drivers/usb/typec/
 F:	include/linux/usb/typec.h
 
+USB TYPEC BUS FOR ALTERNATE MODES
+M:	Heikki Krogerus <heikki.krogerus@linux.intel.com>
+L:	linux-usb@vger.kernel.org
+S:	Maintained
+F:	Documentation/ABI/testing/sysfs-bus-typec
+F:	Documentation/driver-api/usb/typec_bus.rst
+F:	drivers/usb/typec/altmodes/
+F:	include/linux/usb/typec_altmode.h
+
 USB UHCI DRIVER
 M:	Alan Stern <stern@rowland.harvard.edu>
 L:	linux-usb@vger.kernel.org
* Unmerged path drivers/usb/typec/Makefile
diff --git a/drivers/usb/typec/bus.c b/drivers/usb/typec/bus.c
new file mode 100644
index 000000000000..999d7904172a
--- /dev/null
+++ b/drivers/usb/typec/bus.c
@@ -0,0 +1,401 @@
+// SPDX-License-Identifier: GPL-2.0
+/**
+ * Bus for USB Type-C Alternate Modes
+ *
+ * Copyright (C) 2018 Intel Corporation
+ * Author: Heikki Krogerus <heikki.krogerus@linux.intel.com>
+ */
+
+#include <linux/usb/pd_vdo.h>
+
+#include "bus.h"
+
+static inline int typec_altmode_set_mux(struct altmode *alt, u8 state)
+{
+	return alt->mux ? alt->mux->set(alt->mux, state) : 0;
+}
+
+static int typec_altmode_set_state(struct typec_altmode *adev, int state)
+{
+	bool is_port = is_typec_port(adev->dev.parent);
+	struct altmode *port_altmode;
+	int ret;
+
+	port_altmode = is_port ? to_altmode(adev) : to_altmode(adev)->partner;
+
+	ret = typec_altmode_set_mux(port_altmode, state);
+	if (ret)
+		return ret;
+
+	blocking_notifier_call_chain(&port_altmode->nh, state, NULL);
+
+	return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+/* Common API */
+
+/**
+ * typec_altmode_notify - Communication between the OS and alternate mode driver
+ * @adev: Handle to the alternate mode
+ * @conf: Alternate mode specific configuration value
+ * @data: Alternate mode specific data
+ *
+ * The primary purpose for this function is to allow the alternate mode drivers
+ * to tell which pin configuration has been negotiated with the partner. That
+ * information will then be used for example to configure the muxes.
+ * Communication to the other direction is also possible, and low level device
+ * drivers can also send notifications to the alternate mode drivers. The actual
+ * communication will be specific for every SVID.
+ */
+int typec_altmode_notify(struct typec_altmode *adev,
+			 unsigned long conf, void *data)
+{
+	bool is_port = is_typec_port(adev->dev.parent);
+	struct altmode *altmode;
+	struct altmode *partner;
+	int ret;
+
+	if (!adev)
+		return 0;
+
+	altmode = to_altmode(adev);
+
+	if (!altmode->partner)
+		return -ENODEV;
+
+	partner = altmode->partner;
+
+	ret = typec_altmode_set_mux(is_port ? altmode : partner, (u8)conf);
+	if (ret)
+		return ret;
+
+	blocking_notifier_call_chain(is_port ? &altmode->nh : &partner->nh,
+				     conf, data);
+
+	if (partner->adev.ops && partner->adev.ops->notify)
+		return partner->adev.ops->notify(&partner->adev, conf, data);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(typec_altmode_notify);
+
+/**
+ * typec_altmode_enter - Enter Mode
+ * @adev: The alternate mode
+ *
+ * The alternate mode drivers use this function to enter mode. The port drivers
+ * use this to inform the alternate mode drivers that the partner has initiated
+ * Enter Mode command.
+ */
+int typec_altmode_enter(struct typec_altmode *adev)
+{
+	struct altmode *partner = to_altmode(adev)->partner;
+	struct typec_altmode *pdev = &partner->adev;
+	int ret;
+
+	if (!adev || adev->active)
+		return 0;
+
+	if (!pdev->ops || !pdev->ops->enter)
+		return -EOPNOTSUPP;
+
+	/* Moving to USB Safe State */
+	ret = typec_altmode_set_state(adev, TYPEC_STATE_SAFE);
+	if (ret)
+		return ret;
+
+	/* Enter Mode */
+	return pdev->ops->enter(pdev);
+}
+EXPORT_SYMBOL_GPL(typec_altmode_enter);
+
+/**
+ * typec_altmode_exit - Exit Mode
+ * @adev: The alternate mode
+ *
+ * The partner of @adev has initiated Exit Mode command.
+ */
+int typec_altmode_exit(struct typec_altmode *adev)
+{
+	struct altmode *partner = to_altmode(adev)->partner;
+	struct typec_altmode *pdev = &partner->adev;
+	int ret;
+
+	if (!adev || !adev->active)
+		return 0;
+
+	if (!pdev->ops || !pdev->ops->enter)
+		return -EOPNOTSUPP;
+
+	/* Moving to USB Safe State */
+	ret = typec_altmode_set_state(adev, TYPEC_STATE_SAFE);
+	if (ret)
+		return ret;
+
+	/* Exit Mode command */
+	return pdev->ops->exit(pdev);
+}
+EXPORT_SYMBOL_GPL(typec_altmode_exit);
+
+/**
+ * typec_altmode_attention - Attention command
+ * @adev: The alternate mode
+ * @vdo: VDO for the Attention command
+ *
+ * Notifies the partner of @adev about Attention command.
+ */
+void typec_altmode_attention(struct typec_altmode *adev, u32 vdo)
+{
+	struct typec_altmode *pdev = &to_altmode(adev)->partner->adev;
+
+	if (pdev->ops && pdev->ops->attention)
+		pdev->ops->attention(pdev, vdo);
+}
+EXPORT_SYMBOL_GPL(typec_altmode_attention);
+
+/**
+ * typec_altmode_vdm - Send Vendor Defined Messages (VDM) to the partner
+ * @adev: Alternate mode handle
+ * @header: VDM Header
+ * @vdo: Array of Vendor Defined Data Objects
+ * @count: Number of Data Objects
+ *
+ * The alternate mode drivers use this function for SVID specific communication
+ * with the partner. The port drivers use it to deliver the Structured VDMs
+ * received from the partners to the alternate mode drivers.
+ */
+int typec_altmode_vdm(struct typec_altmode *adev,
+		      const u32 header, const u32 *vdo, int count)
+{
+	struct typec_altmode *pdev;
+	struct altmode *altmode;
+
+	if (!adev)
+		return 0;
+
+	altmode = to_altmode(adev);
+
+	if (!altmode->partner)
+		return -ENODEV;
+
+	pdev = &altmode->partner->adev;
+
+	if (!pdev->ops || !pdev->ops->vdm)
+		return -EOPNOTSUPP;
+
+	return pdev->ops->vdm(pdev, header, vdo, count);
+}
+EXPORT_SYMBOL_GPL(typec_altmode_vdm);
+
+const struct typec_altmode *
+typec_altmode_get_partner(struct typec_altmode *adev)
+{
+	return &to_altmode(adev)->partner->adev;
+}
+EXPORT_SYMBOL_GPL(typec_altmode_get_partner);
+
+/* -------------------------------------------------------------------------- */
+/* API for the alternate mode drivers */
+
+/**
+ * typec_altmode_get_plug - Find cable plug alternate mode
+ * @adev: Handle to partner alternate mode
+ * @index: Cable plug index
+ *
+ * Increment reference count for cable plug alternate mode device. Returns
+ * handle to the cable plug alternate mode, or NULL if none is found.
+ */
+struct typec_altmode *typec_altmode_get_plug(struct typec_altmode *adev,
+					     enum typec_plug_index index)
+{
+	struct altmode *port = to_altmode(adev)->partner;
+
+	if (port->plug[index]) {
+		get_device(&port->plug[index]->adev.dev);
+		return &port->plug[index]->adev;
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(typec_altmode_get_plug);
+
+/**
+ * typec_altmode_put_plug - Decrement cable plug alternate mode reference count
+ * @plug: Handle to the cable plug alternate mode
+ */
+void typec_altmode_put_plug(struct typec_altmode *plug)
+{
+	if (plug)
+		put_device(&plug->dev);
+}
+EXPORT_SYMBOL_GPL(typec_altmode_put_plug);
+
+int __typec_altmode_register_driver(struct typec_altmode_driver *drv,
+				    struct module *module)
+{
+	if (!drv->probe)
+		return -EINVAL;
+
+	drv->driver.owner = module;
+	drv->driver.bus = &typec_bus;
+
+	return driver_register(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(__typec_altmode_register_driver);
+
+void typec_altmode_unregister_driver(struct typec_altmode_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(typec_altmode_unregister_driver);
+
+/* -------------------------------------------------------------------------- */
+/* API for the port drivers */
+
+/**
+ * typec_match_altmode - Match SVID to an array of alternate modes
+ * @altmodes: Array of alternate modes
+ * @n: Number of elements in the array, or -1 for NULL termiated arrays
+ * @svid: Standard or Vendor ID to match with
+ *
+ * Return pointer to an alternate mode with SVID mathing @svid, or NULL when no
+ * match is found.
+ */
+struct typec_altmode *typec_match_altmode(struct typec_altmode **altmodes,
+					  size_t n, u16 svid, u8 mode)
+{
+	int i;
+
+	for (i = 0; i < n; i++) {
+		if (!altmodes[i])
+			break;
+		if (altmodes[i]->svid == svid && altmodes[i]->mode == mode)
+			return altmodes[i];
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(typec_match_altmode);
+
+/* -------------------------------------------------------------------------- */
+
+static ssize_t
+description_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct typec_altmode *alt = to_typec_altmode(dev);
+
+	return sprintf(buf, "%s\n", alt->desc ? alt->desc : "");
+}
+static DEVICE_ATTR_RO(description);
+
+static struct attribute *typec_attrs[] = {
+	&dev_attr_description.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(typec);
+
+static int typec_match(struct device *dev, struct device_driver *driver)
+{
+	struct typec_altmode_driver *drv = to_altmode_driver(driver);
+	struct typec_altmode *altmode = to_typec_altmode(dev);
+	const struct typec_device_id *id;
+
+	for (id = drv->id_table; id->svid; id++)
+		if (id->svid == altmode->svid &&
+		    (id->mode == TYPEC_ANY_MODE || id->mode == altmode->mode))
+			return 1;
+	return 0;
+}
+
+static int typec_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct typec_altmode *altmode = to_typec_altmode(dev);
+
+	if (add_uevent_var(env, "SVID=%04X", altmode->svid))
+		return -ENOMEM;
+
+	if (add_uevent_var(env, "MODE=%u", altmode->mode))
+		return -ENOMEM;
+
+	return add_uevent_var(env, "MODALIAS=typec:id%04Xm%02X",
+			      altmode->svid, altmode->mode);
+}
+
+static int typec_altmode_create_links(struct altmode *alt)
+{
+	struct device *port_dev = &alt->partner->adev.dev;
+	struct device *dev = &alt->adev.dev;
+	int err;
+
+	err = sysfs_create_link(&dev->kobj, &port_dev->kobj, "port");
+	if (err)
+		return err;
+
+	err = sysfs_create_link(&port_dev->kobj, &dev->kobj, "partner");
+	if (err)
+		sysfs_remove_link(&dev->kobj, "port");
+
+	return err;
+}
+
+static void typec_altmode_remove_links(struct altmode *alt)
+{
+	sysfs_remove_link(&alt->partner->adev.dev.kobj, "partner");
+	sysfs_remove_link(&alt->adev.dev.kobj, "port");
+}
+
+static int typec_probe(struct device *dev)
+{
+	struct typec_altmode_driver *drv = to_altmode_driver(dev->driver);
+	struct typec_altmode *adev = to_typec_altmode(dev);
+	struct altmode *altmode = to_altmode(adev);
+	int ret;
+
+	/* Fail if the port does not support the alternate mode */
+	if (!altmode->partner)
+		return -ENODEV;
+
+	ret = typec_altmode_create_links(altmode);
+	if (ret) {
+		dev_warn(dev, "failed to create symlinks\n");
+		return ret;
+	}
+
+	ret = drv->probe(adev);
+	if (ret)
+		typec_altmode_remove_links(altmode);
+
+	return ret;
+}
+
+static int typec_remove(struct device *dev)
+{
+	struct typec_altmode_driver *drv = to_altmode_driver(dev->driver);
+	struct typec_altmode *adev = to_typec_altmode(dev);
+	struct altmode *altmode = to_altmode(adev);
+
+	typec_altmode_remove_links(altmode);
+
+	if (drv->remove)
+		drv->remove(to_typec_altmode(dev));
+
+	if (adev->active) {
+		WARN_ON(typec_altmode_set_state(adev, TYPEC_STATE_SAFE));
+		typec_altmode_update_active(adev, false);
+	}
+
+	adev->desc = NULL;
+	adev->ops = NULL;
+
+	return 0;
+}
+
+struct bus_type typec_bus = {
+	.name = "typec",
+	.dev_groups = typec_groups,
+	.match = typec_match,
+	.uevent = typec_uevent,
+	.probe = typec_probe,
+	.remove = typec_remove,
+};
diff --git a/drivers/usb/typec/bus.h b/drivers/usb/typec/bus.h
new file mode 100644
index 000000000000..62aaf8b56bde
--- /dev/null
+++ b/drivers/usb/typec/bus.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __USB_TYPEC_ALTMODE_H__
+#define __USB_TYPEC_ALTMODE_H__
+
+#include <linux/usb/typec_altmode.h>
+#include <linux/usb/typec_mux.h>
+
+struct bus_type;
+
+struct altmode {
+	unsigned int			id;
+	struct typec_altmode		adev;
+	struct typec_mux		*mux;
+
+	enum typec_port_data		roles;
+
+	struct attribute		*attrs[5];
+	char				group_name[6];
+	struct attribute_group		group;
+	const struct attribute_group	*groups[2];
+
+	struct altmode			*partner;
+	struct altmode			*plug[2];
+
+	struct blocking_notifier_head	nh;
+};
+
+#define to_altmode(d) container_of(d, struct altmode, adev)
+
+extern struct bus_type typec_bus;
+extern const struct device_type typec_altmode_dev_type;
+extern const struct device_type typec_port_dev_type;
+
+#define is_typec_altmode(_dev_) (_dev_->type == &typec_altmode_dev_type)
+#define is_typec_port(_dev_) (_dev_->type == &typec_port_dev_type)
+
+#endif /* __USB_TYPEC_ALTMODE_H__ */
* Unmerged path drivers/usb/typec/typec.c
* Unmerged path include/linux/mod_devicetable.h
* Unmerged path include/linux/usb/typec.h
diff --git a/include/linux/usb/typec_altmode.h b/include/linux/usb/typec_altmode.h
new file mode 100644
index 000000000000..9a88c74a1d0d
--- /dev/null
+++ b/include/linux/usb/typec_altmode.h
@@ -0,0 +1,160 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __USB_TYPEC_ALTMODE_H
+#define __USB_TYPEC_ALTMODE_H
+
+#include <linux/mod_devicetable.h>
+#include <linux/usb/typec.h>
+#include <linux/device.h>
+
+#define MODE_DISCOVERY_MAX	6
+
+struct typec_altmode_ops;
+
+/**
+ * struct typec_altmode - USB Type-C alternate mode device
+ * @dev: Driver model's view of this device
+ * @svid: Standard or Vendor ID (SVID) of the alternate mode
+ * @mode: Index of the Mode
+ * @vdo: VDO returned by Discover Modes USB PD command
+ * @active: Tells has the mode been entered or not
+ * @desc: Optional human readable description of the mode
+ * @ops: Operations vector from the driver
+ */
+struct typec_altmode {
+	struct device			dev;
+	u16				svid;
+	int				mode;
+	u32				vdo;
+	unsigned int			active:1;
+
+	char				*desc;
+	const struct typec_altmode_ops	*ops;
+};
+
+#define to_typec_altmode(d) container_of(d, struct typec_altmode, dev)
+
+static inline void typec_altmode_set_drvdata(struct typec_altmode *altmode,
+					     void *data)
+{
+	dev_set_drvdata(&altmode->dev, data);
+}
+
+static inline void *typec_altmode_get_drvdata(struct typec_altmode *altmode)
+{
+	return dev_get_drvdata(&altmode->dev);
+}
+
+/**
+ * struct typec_altmode_ops - Alternate mode specific operations vector
+ * @enter: Operations to be executed with Enter Mode Command
+ * @exit: Operations to be executed with Exit Mode Command
+ * @attention: Callback for Attention Command
+ * @vdm: Callback for SVID specific commands
+ * @notify: Communication channel for platform and the alternate mode
+ * @activate: User callback for Enter/Exit Mode
+ */
+struct typec_altmode_ops {
+	int (*enter)(struct typec_altmode *altmode);
+	int (*exit)(struct typec_altmode *altmode);
+	void (*attention)(struct typec_altmode *altmode, u32 vdo);
+	int (*vdm)(struct typec_altmode *altmode, const u32 hdr,
+		   const u32 *vdo, int cnt);
+	int (*notify)(struct typec_altmode *altmode, unsigned long conf,
+		      void *data);
+	int (*activate)(struct typec_altmode *altmode, int activate);
+};
+
+int typec_altmode_enter(struct typec_altmode *altmode);
+int typec_altmode_exit(struct typec_altmode *altmode);
+void typec_altmode_attention(struct typec_altmode *altmode, u32 vdo);
+int typec_altmode_vdm(struct typec_altmode *altmode,
+		      const u32 header, const u32 *vdo, int count);
+int typec_altmode_notify(struct typec_altmode *altmode, unsigned long conf,
+			 void *data);
+const struct typec_altmode *
+typec_altmode_get_partner(struct typec_altmode *altmode);
+
+/*
+ * These are the connector states (USB, Safe and Alt Mode) defined in USB Type-C
+ * Specification. SVID specific connector states are expected to follow and
+ * start from the value TYPEC_STATE_MODAL.
+ */
+enum {
+	TYPEC_STATE_SAFE,	/* USB Safe State */
+	TYPEC_STATE_USB,	/* USB Operation */
+	TYPEC_STATE_MODAL,	/* Alternate Modes */
+};
+
+/*
+ * For the muxes there is no difference between Accessory Modes and Alternate
+ * Modes, so the Accessory Modes are supplied with specific modal state values
+ * here. Unlike with Alternate Modes, where the mux will be linked with the
+ * alternate mode device, the mux for Accessory Modes will be linked with the
+ * port device instead.
+ *
+ * Port drivers can use TYPEC_MODE_AUDIO and TYPEC_MODE_DEBUG as the mode
+ * value for typec_set_mode() when accessory modes are supported.
+ */
+enum {
+	TYPEC_MODE_AUDIO = TYPEC_STATE_MODAL,	/* Audio Accessory */
+	TYPEC_MODE_DEBUG,			/* Debug Accessory */
+};
+
+#define TYPEC_MODAL_STATE(_state_)	((_state_) + TYPEC_STATE_MODAL)
+
+struct typec_altmode *typec_altmode_get_plug(struct typec_altmode *altmode,
+					     enum typec_plug_index index);
+void typec_altmode_put_plug(struct typec_altmode *plug);
+
+struct typec_altmode *typec_match_altmode(struct typec_altmode **altmodes,
+					  size_t n, u16 svid, u8 mode);
+
+struct typec_altmode *
+typec_altmode_register_notifier(struct device *dev, u16 svid, u8 mode,
+				struct notifier_block *nb);
+
+void typec_altmode_unregister_notifier(struct typec_altmode *adev,
+				       struct notifier_block *nb);
+
+/**
+ * typec_altmode_get_orientation - Get cable plug orientation
+ * altmode: Handle to the alternate mode
+ */
+static inline enum typec_orientation
+typec_altmode_get_orientation(struct typec_altmode *altmode)
+{
+	return typec_get_orientation(typec_altmode2port(altmode));
+}
+
+/**
+ * struct typec_altmode_driver - USB Type-C alternate mode device driver
+ * @id_table: Null terminated array of SVIDs
+ * @probe: Callback for device binding
+ * @remove: Callback for device unbinding
+ * @driver: Device driver model driver
+ *
+ * These drivers will be bind to the partner alternate mode devices. They will
+ * handle all SVID specific communication.
+ */
+struct typec_altmode_driver {
+	const struct typec_device_id *id_table;
+	int (*probe)(struct typec_altmode *altmode);
+	void (*remove)(struct typec_altmode *altmode);
+	struct device_driver driver;
+};
+
+#define to_altmode_driver(d) container_of(d, struct typec_altmode_driver, \
+					  driver)
+
+#define typec_altmode_register_driver(drv) \
+		__typec_altmode_register_driver(drv, THIS_MODULE)
+int __typec_altmode_register_driver(struct typec_altmode_driver *drv,
+				    struct module *module);
+void typec_altmode_unregister_driver(struct typec_altmode_driver *drv);
+
+#define module_typec_altmode_driver(__typec_altmode_driver) \
+	module_driver(__typec_altmode_driver, typec_altmode_register_driver, \
+		      typec_altmode_unregister_driver)
+
+#endif /* __USB_TYPEC_ALTMODE_H */
diff --git a/scripts/mod/devicetable-offsets.c b/scripts/mod/devicetable-offsets.c
index 0df560c57dae..ed04a02ecdc1 100644
--- a/scripts/mod/devicetable-offsets.c
+++ b/scripts/mod/devicetable-offsets.c
@@ -195,5 +195,9 @@ int main(void)
 	DEVID_FIELD(tb_service_id, protocol_version);
 	DEVID_FIELD(tb_service_id, protocol_revision);
 
+	DEVID(typec_device_id);
+	DEVID_FIELD(typec_device_id, svid);
+	DEVID_FIELD(typec_device_id, mode);
+
 	return 0;
 }
diff --git a/scripts/mod/file2alias.c b/scripts/mod/file2alias.c
index 825bcf37392f..a48a00c0062d 100644
--- a/scripts/mod/file2alias.c
+++ b/scripts/mod/file2alias.c
@@ -1220,6 +1220,19 @@ static int do_tbsvc_entry(const char *filename, void *symval, char *alias)
 }
 ADD_TO_DEVTABLE("tbsvc", tb_service_id, do_tbsvc_entry);
 
+/* Looks like: typec:idNmN */
+static int do_typec_entry(const char *filename, void *symval, char *alias)
+{
+	DEF_FIELD(symval, typec_device_id, svid);
+	DEF_FIELD(symval, typec_device_id, mode);
+
+	sprintf(alias, "typec:id%04X", svid);
+	ADD(alias, "m", mode != TYPEC_ANY_MODE, mode);
+
+	return 1;
+}
+ADD_TO_DEVTABLE("typec", typec_device_id, do_typec_entry);
+
 /* Does namelen bytes of name exactly match the symbol? */
 static bool sym_is(const char *name, unsigned namelen, const char *symbol)
 {
