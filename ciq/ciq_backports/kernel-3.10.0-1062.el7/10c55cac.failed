HID: wacom: generic: support LEDs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [hid] wacom: generic: support LEDs (Benjamin Tissoires) [1710890]
Rebuild_FUZZ: 91.80%
commit-author Aaron Armstrong Skomra <skomra@gmail.com>
commit 10c55cacb8b20518fddf92de43fbfb198f288eb2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/10c55cac.failed

Add support for the LEDs around the mode switch to the generic code path in
support of the second generation Intuos Pro.

	Signed-off-by: Aaron Skomra <aaron.skomra@wacom.com>
	Reviewed-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 10c55cacb8b20518fddf92de43fbfb198f288eb2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom.h
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom.h
index f6642077e87a,d0d7dc1572ca..000000000000
--- a/drivers/hid/wacom.h
+++ b/drivers/hid/wacom.h
@@@ -168,7 -168,7 +168,11 @@@ struct wacom 
  	struct work_struct remote_work;
  	struct delayed_work init_work;
  	struct wacom_remote *remote;
++<<<<<<< HEAD
 +	struct work_struct mode_change_work;
++=======
+ 	bool generic_has_leds;
++>>>>>>> 10c55cacb8b2 (HID: wacom: generic: support LEDs)
  	struct wacom_leds {
  		struct wacom_group_leds *groups;
  		unsigned int count;
@@@ -219,5 -216,10 +223,6 @@@ void wacom_wac_event(struct hid_device 
  		struct hid_usage *usage, __s32 value);
  void wacom_wac_report(struct hid_device *hdev, struct hid_report *report);
  void wacom_battery_work(struct work_struct *work);
 -enum led_brightness wacom_leds_brightness_get(struct wacom_led *led);
 -struct wacom_led *wacom_led_find(struct wacom *wacom, unsigned int group,
 -				 unsigned int id);
 -struct wacom_led *wacom_led_next(struct wacom *wacom, struct wacom_led *cur);
  int wacom_equivalent_usage(int usage);
+ int wacom_initialize_leds(struct wacom *wacom);
  #endif
diff --cc drivers/hid/wacom_wac.c
index 382b17828205,0dad786d2135..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1917,8 -1801,9 +1921,13 @@@ static void wacom_wac_pad_event(struct 
  	struct wacom *wacom = hid_get_drvdata(hdev);
  	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
  	struct input_dev *input = wacom_wac->pad_input;
+ 	struct wacom_features *features = &wacom_wac->features;
  	unsigned equivalent_usage = wacom_equivalent_usage(usage->hid);
++<<<<<<< HEAD
 +	bool do_report = false;
++=======
+ 	int i;
++>>>>>>> 10c55cacb8b2 (HID: wacom: generic: support LEDs)
  
  	/*
  	 * Avoid reporting this event and setting inrange_state if this usage
@@@ -1976,22 -1830,16 +1985,33 @@@
  			input_sync(wacom_wac->shared->touch_input);
  		}
  		break;
++<<<<<<< HEAD
 +	case WACOM_HID_WD_MODE_CHANGE:
 +		if (wacom_wac->is_direct_mode != value) {
 +			wacom_wac->is_direct_mode = value;
 +			wacom_schedule_work(&wacom->wacom_wac, WACOM_WORKER_MODE_CHANGE);
 +		}
++=======
+ 
+ 	case WACOM_HID_WD_BUTTONCENTER:
+ 		for (i = 0; i < wacom->led.count; i++)
+ 			wacom_update_led(wacom, features->numbered_buttons,
+ 					 value, i);
+ 		 /* fall through*/
+ 	default:
+ 		input_event(input, usage->type, usage->code, value);
++>>>>>>> 10c55cacb8b2 (HID: wacom: generic: support LEDs)
 +		break;
 +	default:
 +		do_report = true;
  		break;
  	}
 +
 +	if (do_report) {
 +		input_event(input, usage->type, usage->code, value);
 +		if (value)
 +			wacom_wac->hid_data.pad_input_event_flag = true;
 +	}
  }
  
  static void wacom_wac_pad_pre_report(struct hid_device *hdev,
* Unmerged path drivers/hid/wacom.h
diff --git a/drivers/hid/wacom_sys.c b/drivers/hid/wacom_sys.c
index e5c8b50d277b..1e9414ff2e23 100644
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@ -801,8 +801,13 @@ static int wacom_led_control(struct wacom *wacom)
 	if (!buf)
 		return -ENOMEM;
 
-	if (wacom->wacom_wac.features.type >= INTUOS5S &&
-	    wacom->wacom_wac.features.type <= INTUOSPL) {
+	if (wacom->wacom_wac.features.type == HID_GENERIC) {
+		buf[0] = WAC_CMD_LED_CONTROL_GENERIC;
+		buf[1] = wacom->led.llv;
+		buf[2] = wacom->led.groups[0].select & 0x03;
+
+	} else if ((wacom->wacom_wac.features.type >= INTUOS5S &&
+	    wacom->wacom_wac.features.type <= INTUOSPL)) {
 		/*
 		 * Touch Ring and crop mark LED luminance may take on
 		 * one of four values:
@@ -1072,6 +1077,17 @@ static struct attribute_group intuos5_led_attr_group = {
 	.attrs = intuos5_led_attrs,
 };
 
+static struct attribute *generic_led_attrs[] = {
+	&dev_attr_status0_luminance.attr,
+	&dev_attr_status_led0_select.attr,
+	NULL
+};
+
+static struct attribute_group generic_led_attr_group = {
+	.name = "wacom_led",
+	.attrs = generic_led_attrs,
+};
+
 struct wacom_sysfs_group_devres {
 	struct attribute_group *group;
 	struct kobject *root;
@@ -1311,7 +1327,7 @@ static int wacom_leds_alloc_and_register(struct wacom *wacom, int group_count,
 	return 0;
 }
 
-static int wacom_initialize_leds(struct wacom *wacom)
+int wacom_initialize_leds(struct wacom *wacom)
 {
 	int error;
 
@@ -1320,6 +1336,23 @@ static int wacom_initialize_leds(struct wacom *wacom)
 
 	/* Initialize default values */
 	switch (wacom->wacom_wac.features.type) {
+	case HID_GENERIC:
+		if (!wacom->generic_has_leds)
+			return 0;
+		wacom->led.llv = 100;
+		wacom->led.max_llv = 100;
+
+		error = wacom_leds_alloc_and_register(wacom, 1, 4, false);
+		if (error) {
+			hid_err(wacom->hdev,
+				"cannot create leds err: %d\n", error);
+			return error;
+		}
+
+		error = wacom_devm_sysfs_create_group(wacom,
+						      &generic_led_attr_group);
+		break;
+
 	case INTUOS4S:
 	case INTUOS4:
 	case INTUOS4WL:
* Unmerged path drivers/hid/wacom_wac.c
diff --git a/drivers/hid/wacom_wac.h b/drivers/hid/wacom_wac.h
index de412632b71d..64d8f014602e 100644
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@ -79,6 +79,7 @@
 #define WAC_CMD_ICON_XFER               0x23
 #define WAC_CMD_ICON_BT_XFER            0x26
 #define WAC_CMD_DELETE_PAIRING          0x20
+#define WAC_CMD_LED_CONTROL_GENERIC     0x32
 #define WAC_CMD_UNPAIR_ALL              0xFF
 #define WAC_CMD_WL_INTUOSP2             0x82
 
