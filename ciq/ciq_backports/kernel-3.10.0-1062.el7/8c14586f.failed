net: ipv6: Use passed in table for nexthop lookups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [net] ipv6: Use passed in table for nexthop lookups (Guillaume Nault) [1535977]
Rebuild_FUZZ: 94.74%
commit-author David Ahern <dsa@cumulusnetworks.com>
commit 8c14586fc320acfed8a0048eb21d1f2e2856fc36
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/8c14586f.failed

Similar to 3bfd847203c6 ("net: Use passed in table for nexthop lookups")
for IPv4, if the route spec contains a table id use that to lookup the
next hop first and fall back to a full lookup if it fails (per the fix
4c9bcd117918b ("net: Fix nexthop lookups")).

Example:

    root@kenny:~# ip -6 ro ls table red
    local 2100:1::1 dev lo  proto none  metric 0  pref medium
    2100:1::/120 dev eth1  proto kernel  metric 256  pref medium
    local 2100:2::1 dev lo  proto none  metric 0  pref medium
    2100:2::/120 dev eth2  proto kernel  metric 256  pref medium
    local fe80::e0:f9ff:fe09:3cac dev lo  proto none  metric 0  pref medium
    local fe80::e0:f9ff:fe1c:b974 dev lo  proto none  metric 0  pref medium
    fe80::/64 dev eth1  proto kernel  metric 256  pref medium
    fe80::/64 dev eth2  proto kernel  metric 256  pref medium
    ff00::/8 dev red  metric 256  pref medium
    ff00::/8 dev eth1  metric 256  pref medium
    ff00::/8 dev eth2  metric 256  pref medium
    unreachable default dev lo  metric 240  error -113 pref medium

    root@kenny:~# ip -6 ro add table red 2100:3::/64 via 2100:1::64
    RTNETLINK answers: No route to host

Route add fails even though 2100:1::64 is a reachable next hop:
    root@kenny:~# ping6 -I red  2100:1::64
    ping6: Warning: source address might be selected on device other than red.
    PING 2100:1::64(2100:1::64) from 2100:1::1 red: 56 data bytes
    64 bytes from 2100:1::64: icmp_seq=1 ttl=64 time=1.33 ms

With this patch:
    root@kenny:~# ip -6 ro add table red 2100:3::/64 via 2100:1::64
    root@kenny:~# ip -6 ro ls table red
    local 2100:1::1 dev lo  proto none  metric 0  pref medium
    2100:1::/120 dev eth1  proto kernel  metric 256  pref medium
    local 2100:2::1 dev lo  proto none  metric 0  pref medium
    2100:2::/120 dev eth2  proto kernel  metric 256  pref medium
    2100:3::/64 via 2100:1::64 dev eth1  metric 1024  pref medium
    local fe80::e0:f9ff:fe09:3cac dev lo  proto none  metric 0  pref medium
    local fe80::e0:f9ff:fe1c:b974 dev lo  proto none  metric 0  pref medium
    fe80::/64 dev eth1  proto kernel  metric 256  pref medium
    fe80::/64 dev eth2  proto kernel  metric 256  pref medium
    ff00::/8 dev red  metric 256  pref medium
    ff00::/8 dev eth1  metric 256  pref medium
    ff00::/8 dev eth2  metric 256  pref medium
    unreachable default dev lo  metric 240  error -113 pref medium

	Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8c14586fc320acfed8a0048eb21d1f2e2856fc36)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/route.c
diff --cc net/ipv6/route.c
index 9ee2312eaf73,af46e19205f5..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -1772,9 -1769,39 +1772,44 @@@ static int ip6_convert_metrics(struct m
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
 +int ip6_route_info_create(struct fib6_config *cfg, struct rt6_info **rt_ret)
++=======
+ static struct rt6_info *ip6_nh_lookup_table(struct net *net,
+ 					    struct fib6_config *cfg,
+ 					    const struct in6_addr *gw_addr)
+ {
+ 	struct flowi6 fl6 = {
+ 		.flowi6_oif = cfg->fc_ifindex,
+ 		.daddr = *gw_addr,
+ 		.saddr = cfg->fc_prefsrc,
+ 	};
+ 	struct fib6_table *table;
+ 	struct rt6_info *rt;
+ 	int flags = 0;
+ 
+ 	table = fib6_get_table(net, cfg->fc_table);
+ 	if (!table)
+ 		return NULL;
+ 
+ 	if (!ipv6_addr_any(&cfg->fc_prefsrc))
+ 		flags |= RT6_LOOKUP_F_HAS_SADDR;
+ 
+ 	rt = ip6_pol_route(net, table, cfg->fc_ifindex, &fl6, flags);
+ 
+ 	/* if table lookup failed, fall back to full lookup */
+ 	if (rt == net->ipv6.ip6_null_entry) {
+ 		ip6_rt_put(rt);
+ 		rt = NULL;
+ 	}
+ 
+ 	return rt;
+ }
+ 
+ static struct rt6_info *ip6_route_info_create(struct fib6_config *cfg)
++>>>>>>> 8c14586fc320 (net: ipv6: Use passed in table for nexthop lookups)
  {
 +	int err;
  	struct net *net = cfg->fc_nlinfo.nl_net;
  	struct rt6_info *rt = NULL;
  	struct net_device *dev = NULL;
* Unmerged path net/ipv6/route.c
