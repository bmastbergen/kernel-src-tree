xfs: update i_size after unwritten conversion in dio completion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eryu Guan <eguan@redhat.com>
commit ee70daaba82d70766d0723b743d9fdeb3b06102a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ee70daab.failed

Since commit d531d91d6990 ("xfs: always use unwritten extents for
direct I/O writes"), we start allocating unwritten extents for all
direct writes to allow appending aio in XFS.

But for dio writes that could extend file size we update the in-core
inode size first, then convert the unwritten extents to real
allocations at dio completion time in xfs_dio_write_end_io(). Thus a
racing direct read could see the new i_size and find the unwritten
extents first and read zeros instead of actual data, if the direct
writer also takes a shared iolock.

Fix it by updating the in-core inode size after the unwritten extent
conversion. To do this, introduce a new boolean argument to
xfs_iomap_write_unwritten() to tell if we want to update in-core
i_size or not.

	Suggested-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Eryu Guan <eguan@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit ee70daaba82d70766d0723b743d9fdeb3b06102a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_file.c
diff --cc fs/xfs/xfs_file.c
index 374d446488ef,309e26c9dddb..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -615,6 -425,63 +615,66 @@@ restart
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ xfs_dio_write_end_io(
+ 	struct kiocb		*iocb,
+ 	ssize_t			size,
+ 	unsigned		flags)
+ {
+ 	struct inode		*inode = file_inode(iocb->ki_filp);
+ 	struct xfs_inode	*ip = XFS_I(inode);
+ 	loff_t			offset = iocb->ki_pos;
+ 	int			error = 0;
+ 
+ 	trace_xfs_end_io_direct_write(ip, offset, size);
+ 
+ 	if (XFS_FORCED_SHUTDOWN(ip->i_mount))
+ 		return -EIO;
+ 
+ 	if (size <= 0)
+ 		return size;
+ 
+ 	if (flags & IOMAP_DIO_COW) {
+ 		error = xfs_reflink_end_cow(ip, offset, size);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	/*
+ 	 * Unwritten conversion updates the in-core isize after extent
+ 	 * conversion but before updating the on-disk size. Updating isize any
+ 	 * earlier allows a racing dio read to find unwritten extents before
+ 	 * they are converted.
+ 	 */
+ 	if (flags & IOMAP_DIO_UNWRITTEN)
+ 		return xfs_iomap_write_unwritten(ip, offset, size, true);
+ 
+ 	/*
+ 	 * We need to update the in-core inode size here so that we don't end up
+ 	 * with the on-disk inode size being outside the in-core inode size. We
+ 	 * have no other method of updating EOF for AIO, so always do it here
+ 	 * if necessary.
+ 	 *
+ 	 * We need to lock the test/set EOF update as we can be racing with
+ 	 * other IO completions here to update the EOF. Failing to serialise
+ 	 * here can result in EOF moving backwards and Bad Things Happen when
+ 	 * that occurs.
+ 	 */
+ 	spin_lock(&ip->i_flags_lock);
+ 	if (offset + size > i_size_read(inode)) {
+ 		i_size_write(inode, offset + size);
+ 		spin_unlock(&ip->i_flags_lock);
+ 		error = xfs_setfilesize(ip, offset, size);
+ 	} else {
+ 		spin_unlock(&ip->i_flags_lock);
+ 	}
+ 
+ 	return error;
+ }
+ 
++>>>>>>> ee70daaba82d (xfs: update i_size after unwritten conversion in dio completion)
  /*
   * xfs_file_dio_aio_write - handle direct IO writes
   *
diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c
index c7e277f1d00a..f6eda63afc1c 100644
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@ -314,7 +314,8 @@ xfs_end_io(
 	 */
 	switch (ioend->io_type) {
 	case XFS_IO_UNWRITTEN:
-		error = xfs_iomap_write_unwritten(ip, offset, size);
+		/* writeback should never update isize */
+		error = xfs_iomap_write_unwritten(ip, offset, size, false);
 		break;
 	default:
 		ASSERT(!xfs_ioend_is_append(ioend) || ioend->io_append_trans);
* Unmerged path fs/xfs/xfs_file.c
diff --git a/fs/xfs/xfs_iomap.c b/fs/xfs/xfs_iomap.c
index ed8041673da9..40083781239d 100644
--- a/fs/xfs/xfs_iomap.c
+++ b/fs/xfs/xfs_iomap.c
@@ -835,7 +835,8 @@ int
 xfs_iomap_write_unwritten(
 	xfs_inode_t	*ip,
 	xfs_off_t	offset,
-	xfs_off_t	count)
+	xfs_off_t	count,
+	bool		update_isize)
 {
 	xfs_mount_t	*mp = ip->i_mount;
 	xfs_fileoff_t	offset_fsb;
@@ -846,6 +847,7 @@ xfs_iomap_write_unwritten(
 	xfs_trans_t	*tp;
 	xfs_bmbt_irec_t imap;
 	struct xfs_defer_ops dfops;
+	struct inode	*inode = VFS_I(ip);
 	xfs_fsize_t	i_size;
 	uint		resblks;
 	int		error;
@@ -905,7 +907,8 @@ xfs_iomap_write_unwritten(
 		i_size = XFS_FSB_TO_B(mp, offset_fsb + count_fsb);
 		if (i_size > offset + count)
 			i_size = offset + count;
-
+		if (update_isize && i_size > i_size_read(inode))
+			i_size_write(inode, i_size);
 		i_size = xfs_new_eof(ip, i_size);
 		if (i_size) {
 			ip->i_d.di_size = i_size;
diff --git a/fs/xfs/xfs_iomap.h b/fs/xfs/xfs_iomap.h
index a7234f6c473e..9afa99323125 100644
--- a/fs/xfs/xfs_iomap.h
+++ b/fs/xfs/xfs_iomap.h
@@ -29,7 +29,7 @@ int xfs_iomap_write_delay(struct xfs_inode *, xfs_off_t, size_t,
 			struct xfs_bmbt_irec *, struct iomap *);
 int xfs_iomap_write_allocate(struct xfs_inode *, xfs_off_t,
 			struct xfs_bmbt_irec *);
-int xfs_iomap_write_unwritten(struct xfs_inode *, xfs_off_t, xfs_off_t);
+int xfs_iomap_write_unwritten(struct xfs_inode *, xfs_off_t, xfs_off_t, bool);
 
 void xfs_bmbt_to_iomap(struct xfs_inode *, struct iomap *,
 		struct xfs_bmbt_irec *);
diff --git a/fs/xfs/xfs_pnfs.c b/fs/xfs/xfs_pnfs.c
index 21365dce347d..46e277c7166c 100644
--- a/fs/xfs/xfs_pnfs.c
+++ b/fs/xfs/xfs_pnfs.c
@@ -273,7 +273,7 @@ xfs_fs_commit_blocks(
 					(end - 1) >> PAGE_CACHE_SHIFT);
 		WARN_ON_ONCE(error);
 
-		error = xfs_iomap_write_unwritten(ip, start, length);
+		error = xfs_iomap_write_unwritten(ip, start, length, false);
 		if (error)
 			goto out_drop_iolock;
 	}
