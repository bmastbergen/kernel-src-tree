scsi: mpt3sas: Don't access the structure after decrementing it's instance reference count.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] mpt3sas: Don't access the structure after decrementing it's instance reference count (Tomas Henzl) [1642370]
Rebuild_FUZZ: 96.00%
commit-author Chaitra P B <chaitra.basappa@broadcom.com>
commit 20a044332dc47e91045670311f9f9dcb1e32483f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/20a04433.failed

While configuring of NVMe device handling, _pcie_device structure member
was accessed after its reference count is decremented/put. Hence modified
code to access member of _pcie_device structure before its reference count
is decremented/put.

	Signed-off-by: Chaitra P B <chaitra.basappa@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 20a044332dc47e91045670311f9f9dcb1e32483f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt3sas/mpt3sas_scsih.c
diff --cc drivers/scsi/mpt3sas/mpt3sas_scsih.c
index 5ce347355951,bf578271a844..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@@ -2490,6 -2334,56 +2490,59 @@@ scsih_slave_configure(struct scsi_devic
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* PCIe handling */
+ 	if (sas_target_priv_data->flags & MPT_TARGET_FLAGS_PCIE_DEVICE) {
+ 		spin_lock_irqsave(&ioc->pcie_device_lock, flags);
+ 		pcie_device = __mpt3sas_get_pdev_by_wwid(ioc,
+ 				sas_device_priv_data->sas_target->sas_address);
+ 		if (!pcie_device) {
+ 			spin_unlock_irqrestore(&ioc->pcie_device_lock, flags);
+ 			dfailprintk(ioc, pr_warn(MPT3SAS_FMT
+ 				"failure at %s:%d/%s()!\n", ioc->name, __FILE__,
+ 				__LINE__, __func__));
+ 			return 1;
+ 		}
+ 
+ 		qdepth = MPT3SAS_NVME_QUEUE_DEPTH;
+ 		ds = "NVMe";
+ 		sdev_printk(KERN_INFO, sdev,
+ 			"%s: handle(0x%04x), wwid(0x%016llx), port(%d)\n",
+ 			ds, handle, (unsigned long long)pcie_device->wwid,
+ 			pcie_device->port_num);
+ 		if (pcie_device->enclosure_handle != 0)
+ 			sdev_printk(KERN_INFO, sdev,
+ 			"%s: enclosure logical id(0x%016llx), slot(%d)\n",
+ 			ds,
+ 			(unsigned long long)pcie_device->enclosure_logical_id,
+ 			pcie_device->slot);
+ 		if (pcie_device->connector_name[0] != '\0')
+ 			sdev_printk(KERN_INFO, sdev,
+ 				"%s: enclosure level(0x%04x),"
+ 				"connector name( %s)\n", ds,
+ 				pcie_device->enclosure_level,
+ 				pcie_device->connector_name);
+ 
+ 		if (pcie_device->nvme_mdts)
+ 			blk_queue_max_hw_sectors(sdev->request_queue,
+ 					pcie_device->nvme_mdts/512);
+ 
+ 		pcie_device_put(pcie_device);
+ 		spin_unlock_irqrestore(&ioc->pcie_device_lock, flags);
+ 		scsih_change_queue_depth(sdev, qdepth);
+ 		/* Enable QUEUE_FLAG_NOMERGES flag, so that IOs won't be
+ 		 ** merged and can eliminate holes created during merging
+ 		 ** operation.
+ 		 **/
+ 		blk_queue_flag_set(QUEUE_FLAG_NOMERGES,
+ 				sdev->request_queue);
+ 		blk_queue_virt_boundary(sdev->request_queue,
+ 				ioc->page_size - 1);
+ 		return 0;
+ 	}
+ 
++>>>>>>> 20a044332dc4 (scsi: mpt3sas: Don't access the structure after decrementing it's instance reference count.)
  	spin_lock_irqsave(&ioc->sas_device_lock, flags);
  	sas_device = __mpt3sas_get_sdev_by_addr(ioc,
  	   sas_device_priv_data->sas_target->sas_address);
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_scsih.c
