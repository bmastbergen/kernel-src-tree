ovl: add support for "xino" mount and config options

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 795939a93e600587e52c34fe02402b27ddda6017
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/795939a9.failed

With mount option "xino=on", mounter declares that there are enough
free high bits in underlying fs to hold the layer fsid.
If overlayfs does encounter underlying inodes using the high xino
bits reserved for layer fsid, a warning will be emitted and the original
inode number will be used.

The mount option name "xino" goes after a similar meaning mount option
of aufs, but in overlayfs case, the mapping is stateless.

An example for a use case of "xino=on" is when upper/lower is on an xfs
filesystem. xfs uses 64bit inode numbers, but it currently never uses the
upper 8bit for inode numbers exposed via stat(2) and that is not likely to
change in the future without user opting-in for a new xfs feature. The
actual number of unused upper bit is much larger and determined by the xfs
filesystem geometry (64 - agno_log - agblklog - inopblog). That means
that for all practical purpose, there are enough unused bits in xfs
inode numbers for more than OVL_MAX_STACK unique fsid's.

Another use case of "xino=on" is when upper/lower is on tmpfs. tmpfs inode
numbers are allocated sequentially since boot, so they will practially
never use the high inode number bits.

For compatibility with applications that expect 32bit inodes, the feature
can be disabled with "xino=off". The option "xino=auto" automatically
detects underlying filesystem that use 32bit inodes and enables the
feature. The Kconfig option OVERLAY_FS_XINO_AUTO and module parameter of
the same name, determine if the default mode for overlayfs mount is
"xino=auto" or "xino=off".

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 795939a93e600587e52c34fe02402b27ddda6017)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/Kconfig
#	fs/overlayfs/ovl_entry.h
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/Kconfig
index 9eac01c3e21e,17032631c5cf..000000000000
--- a/fs/overlayfs/Kconfig
+++ b/fs/overlayfs/Kconfig
@@@ -50,3 -57,49 +50,52 @@@ config OVERLAY_FS_INDE
  	  Note, that the inodes index feature is not backward compatible.
  	  That is, mounting an overlay which has an inodes index on a kernel
  	  that doesn't support this feature will have unexpected results.
++<<<<<<< HEAD
++=======
+ 
+ 	  If unsure, say N.
+ 
+ config OVERLAY_FS_NFS_EXPORT
+ 	bool "Overlayfs: turn on NFS export feature by default"
+ 	depends on OVERLAY_FS
+ 	depends on OVERLAY_FS_INDEX
+ 	help
+ 	  If this config option is enabled then overlay filesystems will use
+ 	  the inodes index dir to decode overlay NFS file handles by default.
+ 	  In this case, it is still possible to turn off NFS export support
+ 	  globally with the "nfs_export=off" module option or on a filesystem
+ 	  instance basis with the "nfs_export=off" mount option.
+ 
+ 	  The NFS export feature creates an index on copy up of every file and
+ 	  directory.  This full index is used to detect overlay filesystems
+ 	  inconsistencies on lookup, like redirect from multiple upper dirs to
+ 	  the same lower dir.  The full index may incur some overhead on mount
+ 	  time, especially when verifying that directory file handles are not
+ 	  stale.
+ 
+ 	  Note, that the NFS export feature is not backward compatible.
+ 	  That is, mounting an overlay which has a full index on a kernel
+ 	  that doesn't support this feature will have unexpected results.
+ 
+ 	  Most users should say N here and enable this feature on a case-by-
+ 	  case basis with the "nfs_export=on" mount option.
+ 
+ 	  Say N unless you fully understand the consequences.
+ 
+ config OVERLAY_FS_XINO_AUTO
+ 	bool "Overlayfs: auto enable inode number mapping"
+ 	default n
+ 	depends on OVERLAY_FS
+ 	help
+ 	  If this config option is enabled then overlay filesystems will use
+ 	  unused high bits in undelying filesystem inode numbers to map all
+ 	  inodes to a unified address space.  The mapped 64bit inode numbers
+ 	  might not be compatible with applications that expect 32bit inodes.
+ 
+ 	  If compatibility with applications that expect 32bit inodes is not an
+ 	  issue, then it is safe and recommended to say Y here.
+ 
+ 	  For more information, see Documentation/filesystems/overlayfs.txt
+ 
+ 	  If unsure, say N.
++>>>>>>> 795939a93e60 (ovl: add support for "xino" mount and config options)
diff --cc fs/overlayfs/ovl_entry.h
index ec700f861f1b,41655a7d6894..000000000000
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@@ -17,6 -17,27 +17,30 @@@ struct ovl_config 
  	bool redirect_follow;
  	const char *redirect_mode;
  	bool index;
++<<<<<<< HEAD
++=======
+ 	bool nfs_export;
+ 	int xino;
+ };
+ 
+ struct ovl_sb {
+ 	struct super_block *sb;
+ 	dev_t pseudo_dev;
+ };
+ 
+ struct ovl_layer {
+ 	struct vfsmount *mnt;
+ 	struct ovl_sb *fs;
+ 	/* Index of this layer in fs root (upper idx == 0) */
+ 	int idx;
+ 	/* One fsid per unique underlying sb (upper fsid == 0) */
+ 	int fsid;
+ };
+ 
+ struct ovl_path {
+ 	struct ovl_layer *layer;
+ 	struct dentry *dentry;
++>>>>>>> 795939a93e60 (ovl: add support for "xino" mount and config options)
  };
  
  /* private information held for overlayfs's superblock */
diff --cc fs/overlayfs/super.c
index b0392d1737a3,e8551c97de51..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -46,6 -46,24 +46,27 @@@ module_param_named(index, ovl_index_def
  MODULE_PARM_DESC(ovl_index_def,
  		 "Default to on or off for the inodes index feature");
  
++<<<<<<< HEAD
++=======
+ static bool ovl_nfs_export_def = IS_ENABLED(CONFIG_OVERLAY_FS_NFS_EXPORT);
+ module_param_named(nfs_export, ovl_nfs_export_def, bool, 0644);
+ MODULE_PARM_DESC(ovl_nfs_export_def,
+ 		 "Default to on or off for the NFS export feature");
+ 
+ static bool ovl_xino_auto_def = IS_ENABLED(CONFIG_OVERLAY_FS_XINO_AUTO);
+ module_param_named(xino_auto, ovl_xino_auto_def, bool, 0644);
+ MODULE_PARM_DESC(ovl_xino_auto_def,
+ 		 "Auto enable xino feature");
+ 
+ static void ovl_entry_stack_free(struct ovl_entry *oe)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < oe->numlower; i++)
+ 		dput(oe->lowerstack[i].dentry);
+ }
+ 
++>>>>>>> 795939a93e60 (ovl: add support for "xino" mount and config options)
  static void ovl_dentry_release(struct dentry *dentry)
  {
  	struct ovl_entry *oe = dentry->d_fsdata;
@@@ -309,19 -358,24 +347,31 @@@ static inline int ovl_xino_def(void
  static int ovl_show_options(struct seq_file *m, struct dentry *dentry)
  {
  	struct super_block *sb = dentry->d_sb;
 -	struct ovl_fs *ofs = sb->s_fs_info;
 +	struct ovl_fs *ufs = sb->s_fs_info;
  
 -	seq_show_option(m, "lowerdir", ofs->config.lowerdir);
 -	if (ofs->config.upperdir) {
 -		seq_show_option(m, "upperdir", ofs->config.upperdir);
 -		seq_show_option(m, "workdir", ofs->config.workdir);
 +	seq_show_option(m, "lowerdir", ufs->config.lowerdir);
 +	if (ufs->config.upperdir) {
 +		seq_show_option(m, "upperdir", ufs->config.upperdir);
 +		seq_show_option(m, "workdir", ufs->config.workdir);
  	}
 -	if (ofs->config.default_permissions)
 +	if (ufs->config.default_permissions)
  		seq_puts(m, ",default_permissions");
++<<<<<<< HEAD
 +	if (strcmp(ufs->config.redirect_mode, ovl_redirect_mode_def()) != 0)
 +		seq_printf(m, ",redirect_dir=%s", ufs->config.redirect_mode);
 +	if (ufs->config.index != ovl_index_def)
 +		seq_printf(m, ",index=%s", ufs->config.index ? "on" : "off");
++=======
+ 	if (strcmp(ofs->config.redirect_mode, ovl_redirect_mode_def()) != 0)
+ 		seq_printf(m, ",redirect_dir=%s", ofs->config.redirect_mode);
+ 	if (ofs->config.index != ovl_index_def)
+ 		seq_printf(m, ",index=%s", ofs->config.index ? "on" : "off");
+ 	if (ofs->config.nfs_export != ovl_nfs_export_def)
+ 		seq_printf(m, ",nfs_export=%s", ofs->config.nfs_export ?
+ 						"on" : "off");
+ 	if (ofs->config.xino != ovl_xino_def())
+ 		seq_printf(m, ",xino=%s", ovl_xino_str[ofs->config.xino]);
++>>>>>>> 795939a93e60 (ovl: add support for "xino" mount and config options)
  	return 0;
  }
  
@@@ -354,6 -408,11 +404,14 @@@ enum 
  	OPT_REDIRECT_DIR,
  	OPT_INDEX_ON,
  	OPT_INDEX_OFF,
++<<<<<<< HEAD
++=======
+ 	OPT_NFS_EXPORT_ON,
+ 	OPT_NFS_EXPORT_OFF,
+ 	OPT_XINO_ON,
+ 	OPT_XINO_OFF,
+ 	OPT_XINO_AUTO,
++>>>>>>> 795939a93e60 (ovl: add support for "xino" mount and config options)
  	OPT_ERR,
  };
  
@@@ -365,6 -424,11 +423,14 @@@ static const match_table_t ovl_tokens 
  	{OPT_REDIRECT_DIR,		"redirect_dir=%s"},
  	{OPT_INDEX_ON,			"index=on"},
  	{OPT_INDEX_OFF,			"index=off"},
++<<<<<<< HEAD
++=======
+ 	{OPT_NFS_EXPORT_ON,		"nfs_export=on"},
+ 	{OPT_NFS_EXPORT_OFF,		"nfs_export=off"},
+ 	{OPT_XINO_ON,			"xino=on"},
+ 	{OPT_XINO_OFF,			"xino=off"},
+ 	{OPT_XINO_AUTO,			"xino=auto"},
++>>>>>>> 795939a93e60 (ovl: add support for "xino" mount and config options)
  	{OPT_ERR,			NULL}
  };
  
@@@ -471,6 -535,26 +537,29 @@@ static int ovl_parse_opt(char *opt, str
  			config->index = false;
  			break;
  
++<<<<<<< HEAD
++=======
+ 		case OPT_NFS_EXPORT_ON:
+ 			config->nfs_export = true;
+ 			break;
+ 
+ 		case OPT_NFS_EXPORT_OFF:
+ 			config->nfs_export = false;
+ 			break;
+ 
+ 		case OPT_XINO_ON:
+ 			config->xino = OVL_XINO_ON;
+ 			break;
+ 
+ 		case OPT_XINO_OFF:
+ 			config->xino = OVL_XINO_OFF;
+ 			break;
+ 
+ 		case OPT_XINO_AUTO:
+ 			config->xino = OVL_XINO_AUTO;
+ 			break;
+ 
++>>>>>>> 795939a93e60 (ovl: add support for "xino" mount and config options)
  		default:
  			pr_err("overlayfs: unrecognized mount option \"%s\" or missing value\n", p);
  			return -EINVAL;
@@@ -871,121 -951,339 +960,165 @@@ static const struct xattr_handler *ovl_
  	NULL
  };
  
 -static int ovl_get_upper(struct ovl_fs *ofs, struct path *upperpath)
 -{
 -	struct vfsmount *upper_mnt;
 -	int err;
 -
 -	err = ovl_mount_dir(ofs->config.upperdir, upperpath);
 -	if (err)
 -		goto out;
 -
 -	/* Upper fs should not be r/o */
 -	if (sb_rdonly(upperpath->mnt->mnt_sb)) {
 -		pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 -		err = -EINVAL;
 -		goto out;
 -	}
 -
 -	err = ovl_check_namelen(upperpath, ofs, ofs->config.upperdir);
 -	if (err)
 -		goto out;
 -
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(upperpath->dentry)) {
 -		ofs->upperdir_locked = true;
 -	} else if (ofs->config.index) {
 -		pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 -	}
 -
 -	upper_mnt = clone_private_mount(upperpath);
 -	err = PTR_ERR(upper_mnt);
 -	if (IS_ERR(upper_mnt)) {
 -		pr_err("overlayfs: failed to clone upperpath\n");
 -		goto out;
 -	}
 -
 -	/* Don't inherit atime flags */
 -	upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
 -	ofs->upper_mnt = upper_mnt;
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static int ovl_make_workdir(struct ovl_fs *ofs, struct path *workpath)
 +static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
 -	struct vfsmount *mnt = ofs->upper_mnt;
 -	struct dentry *temp;
 -	int fh_type;
 +	struct path upperpath = { };
 +	struct path workpath = { };
 +	struct dentry *root_dentry;
 +	struct ovl_entry *oe;
 +	struct ovl_fs *ufs;
 +	const int *upper_stack_depth;
 +	int *overlay_stack_depth;
 +	struct path *stack = NULL;
 +	char *lowertmp;
 +	char *lower;
 +	unsigned int numlower;
 +	unsigned int stacklen = 0;
 +	unsigned int i;
 +	bool remote = false;
 +	struct cred *cred;
  	int err;
  
 -	err = mnt_want_write(mnt);
 -	if (err)
 -		return err;
 -
 -	ofs->workdir = ovl_workdir_create(ofs, OVL_WORKDIR_NAME, false);
 -	if (!ofs->workdir)
 -		goto out;
 -
 -	/*
 -	 * Upper should support d_type, else whiteouts are visible.  Given
 -	 * workdir and upper are on same fs, we can do iterate_dir() on
 -	 * workdir. This check requires successful creation of workdir in
 -	 * previous step.
 -	 */
 -	err = ovl_check_d_type_supported(workpath);
 -	if (err < 0)
 +	err = -ENOMEM;
 +	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
 +	if (!ufs)
  		goto out;
  
 -	/*
 -	 * We allowed this configuration and don't want to break users over
 -	 * kernel upgrade. So warn instead of erroring out.
 -	 */
 -	if (!err)
 -		pr_warn("overlayfs: upper fs needs to support d_type.\n");
 -
 -	/* Check if upper/work fs supports O_TMPFILE */
 -	temp = ovl_do_tmpfile(ofs->workdir, S_IFREG | 0);
 -	ofs->tmpfile = !IS_ERR(temp);
 -	if (ofs->tmpfile)
 -		dput(temp);
 -	else
 -		pr_warn("overlayfs: upper fs does not support tmpfile.\n");
 -
 -	/*
 -	 * Check if upper/work fs supports trusted.overlay.* xattr
 -	 */
 -	err = ovl_do_setxattr(ofs->workdir, OVL_XATTR_OPAQUE, "0", 1, 0);
 -	if (err) {
 -		ofs->noxattr = true;
 -		ofs->config.index = false;
 -		pr_warn("overlayfs: upper fs does not support xattr, falling back to index=off.\n");
 -		err = 0;
 -	} else {
 -		vfs_removexattr(ofs->workdir, OVL_XATTR_OPAQUE);
 -	}
 -
 -	/* Check if upper/work fs supports file handles */
 -	fh_type = ovl_can_decode_fh(ofs->workdir->d_sb);
 -	if (ofs->config.index && !fh_type) {
 -		ofs->config.index = false;
 -		pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
 -	}
 -
 -	/* Check if upper fs has 32bit inode numbers */
 -	if (fh_type != FILEID_INO32_GEN)
 -		ofs->xino_bits = 0;
 -
 -	/* NFS export of r/w mount depends on index */
 -	if (ofs->config.nfs_export && !ofs->config.index) {
 -		pr_warn("overlayfs: NFS export requires \"index=on\", falling back to nfs_export=off.\n");
 -		ofs->config.nfs_export = false;
 -	}
 -
 -out:
 -	mnt_drop_write(mnt);
 -	return err;
 -}
 -
 -static int ovl_get_workdir(struct ovl_fs *ofs, struct path *upperpath)
 -{
 -	int err;
 -	struct path workpath = { };
 -
 -	err = ovl_mount_dir(ofs->config.workdir, &workpath);
 +	ufs->config.index = ovl_index_def;
 +	err = ovl_parse_opt((char *) data, &ufs->config);
  	if (err)
 -		goto out;
 +		goto out_free_config;
  
  	err = -EINVAL;
 -	if (upperpath->mnt != workpath.mnt) {
 -		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 -		goto out;
 -	}
 -	if (!ovl_workdir_ok(workpath.dentry, upperpath->dentry)) {
 -		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 -		goto out;
 -	}
 -
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(workpath.dentry)) {
 -		ofs->workdir_locked = true;
 -	} else if (ofs->config.index) {
 -		pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +	if (!ufs->config.lowerdir) {
 +		if (!silent)
 +			pr_err("overlayfs: missing 'lowerdir'\n");
 +		goto out_free_config;
  	}
  
 -	ofs->workbasedir = dget(workpath.dentry);
 -	err = ovl_make_workdir(ofs, &workpath);
 -	if (err)
 -		goto out;
 -
 -	err = 0;
 -out:
 -	path_put(&workpath);
 -
 -	return err;
 -}
 -
 -static int ovl_get_indexdir(struct ovl_fs *ofs, struct ovl_entry *oe,
 -			    struct path *upperpath)
 -{
 -	struct vfsmount *mnt = ofs->upper_mnt;
 -	int err;
 -
 -	err = mnt_want_write(mnt);
 -	if (err)
 -		return err;
 -
 -	/* Verify lower root is upper root origin */
 -	err = ovl_verify_origin(upperpath->dentry, oe->lowerstack[0].dentry,
 -				true);
 -	if (err) {
 -		pr_err("overlayfs: failed to verify upper root origin\n");
 -		goto out;
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_free_config;
  	}
 +	*overlay_stack_depth = 0;
  
 -	ofs->indexdir = ovl_workdir_create(ofs, OVL_INDEXDIR_NAME, true);
 -	if (ofs->indexdir) {
 -		/*
 -		 * Verify upper root is exclusively associated with index dir.
 -		 * Older kernels stored upper fh in "trusted.overlay.origin"
 -		 * xattr. If that xattr exists, verify that it is a match to
 -		 * upper dir file handle. In any case, verify or set xattr
 -		 * "trusted.overlay.upper" to indicate that index may have
 -		 * directory entries.
 -		 */
 -		if (ovl_check_origin_xattr(ofs->indexdir)) {
 -			err = ovl_verify_set_fh(ofs->indexdir, OVL_XATTR_ORIGIN,
 -						upperpath->dentry, true, false);
 -			if (err)
 -				pr_err("overlayfs: failed to verify index dir 'origin' xattr\n");
 +	sb->s_maxbytes = MAX_LFS_FILESIZE;
 +	if (ufs->config.upperdir) {
 +		if (!ufs->config.workdir) {
 +			pr_err("overlayfs: missing 'workdir'\n");
 +			goto out_free_config;
  		}
 -		err = ovl_verify_upper(ofs->indexdir, upperpath->dentry, true);
 -		if (err)
 -			pr_err("overlayfs: failed to verify index dir 'upper' xattr\n");
 -
 -		/* Cleanup bad/stale/orphan index entries */
 -		if (!err)
 -			err = ovl_indexdir_cleanup(ofs);
 -	}
 -	if (err || !ofs->indexdir)
 -		pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
 -
 -out:
 -	mnt_drop_write(mnt);
 -	return err;
 -}
 -
 -/* Get a unique fsid for the layer */
 -static int ovl_get_fsid(struct ovl_fs *ofs, struct super_block *sb)
 -{
 -	unsigned int i;
 -	dev_t dev;
 -	int err;
 -
 -	/* fsid 0 is reserved for upper fs even with non upper overlay */
 -	if (ofs->upper_mnt && ofs->upper_mnt->mnt_sb == sb)
 -		return 0;
 -
 -	for (i = 0; i < ofs->numlowerfs; i++) {
 -		if (ofs->lower_fs[i].sb == sb)
 -			return i + 1;
 -	}
 -
 -	err = get_anon_bdev(&dev);
 -	if (err) {
 -		pr_err("overlayfs: failed to get anonymous bdev for lowerpath\n");
 -		return err;
 -	}
 -
 -	ofs->lower_fs[ofs->numlowerfs].sb = sb;
 -	ofs->lower_fs[ofs->numlowerfs].pseudo_dev = dev;
 -	ofs->numlowerfs++;
 -
 -	return ofs->numlowerfs;
 -}
  
 -static int ovl_get_lower_layers(struct ovl_fs *ofs, struct path *stack,
 -				unsigned int numlower)
 -{
 -	int err;
 -	unsigned int i;
 -
 -	err = -ENOMEM;
 -	ofs->lower_layers = kcalloc(numlower, sizeof(struct ovl_layer),
 -				    GFP_KERNEL);
 -	if (ofs->lower_layers == NULL)
 -		goto out;
 +		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 +		if (err)
 +			goto out_free_config;
  
 -	ofs->lower_fs = kcalloc(numlower, sizeof(struct ovl_sb),
 -				GFP_KERNEL);
 -	if (ofs->lower_fs == NULL)
 -		goto out;
 +		/* Upper fs should not be r/o */
 +		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
 +			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 +			err = -EINVAL;
 +			goto out_put_upperpath;
 +		}
  
 -	for (i = 0; i < numlower; i++) {
 -		struct vfsmount *mnt;
 -		int fsid;
 +		err = ovl_check_namelen(&upperpath, ufs, ufs->config.upperdir);
 +		if (err)
 +			goto out_put_upperpath;
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(upperpath.dentry)) {
 +			ufs->upperdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 +			goto out_put_upperpath;
 +		} else {
 +			pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
  
 -		err = fsid = ovl_get_fsid(ofs, stack[i].mnt->mnt_sb);
 -		if (err < 0)
 -			goto out;
 +		err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +		if (err)
 +			goto out_unlock_upperdentry;
  
 -		mnt = clone_private_mount(&stack[i]);
 -		err = PTR_ERR(mnt);
 -		if (IS_ERR(mnt)) {
 -			pr_err("overlayfs: failed to clone lowerpath\n");
 -			goto out;
 +		err = -EINVAL;
 +		if (upperpath.mnt != workpath.mnt) {
 +			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +			goto out_put_workpath;
 +		}
 +		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +			goto out_put_workpath;
  		}
  
 -		/*
 -		 * Make lower layers R/O.  That way fchmod/fchown on lower file
 -		 * will fail instead of modifying lower fs.
 -		 */
 -		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(workpath.dentry)) {
 +			ufs->workdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 +			goto out_put_workpath;
 +		} else {
 +			pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
  
 -		ofs->lower_layers[ofs->numlower].mnt = mnt;
 -		ofs->lower_layers[ofs->numlower].idx = i + 1;
 -		ofs->lower_layers[ofs->numlower].fsid = fsid;
 -		if (fsid) {
 -			ofs->lower_layers[ofs->numlower].fs =
 -				&ofs->lower_fs[fsid - 1];
 +		ufs->workbasedir = workpath.dentry;
 +		upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +		err = -EOPNOTSUPP;
 +		if (!upper_stack_depth) {
 +			pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +			goto out_put_workpath;
  		}
 -		ofs->numlower++;
 +
 +		*overlay_stack_depth = *upper_stack_depth;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * When all layers on same fs, overlay can use real inode numbers.
+ 	 * With mount option "xino=on", mounter declares that there are enough
+ 	 * free high bits in underlying fs to hold the unique fsid.
+ 	 * If overlayfs does encounter underlying inodes using the high xino
+ 	 * bits reserved for fsid, it emits a warning and uses the original
+ 	 * inode number.
+ 	 */
+ 	if (!ofs->numlowerfs || (ofs->numlowerfs == 1 && !ofs->upper_mnt)) {
+ 		ofs->xino_bits = 0;
+ 		ofs->config.xino = OVL_XINO_OFF;
+ 	} else if (ofs->config.xino == OVL_XINO_ON && !ofs->xino_bits) {
+ 		/*
+ 		 * This is a roundup of number of bits needed for numlowerfs+1
+ 		 * (i.e. ilog2(numlowerfs+1 - 1) + 1). fsid 0 is reserved for
+ 		 * upper fs even with non upper overlay.
+ 		 */
+ 		BUILD_BUG_ON(ilog2(OVL_MAX_STACK) > 31);
+ 		ofs->xino_bits = ilog2(ofs->numlowerfs) + 1;
+ 	}
+ 
+ 	if (ofs->xino_bits) {
+ 		pr_info("overlayfs: \"xino\" feature enabled using %d upper inode bits.\n",
+ 			ofs->xino_bits);
+ 	}
+ 
+ 	err = 0;
+ out:
+ 	return err;
+ }
+ 
+ static struct ovl_entry *ovl_get_lowerstack(struct super_block *sb,
+ 					    struct ovl_fs *ofs)
+ {
+ 	int err;
+ 	char *lowertmp, *lower;
+ 	struct path *stack = NULL;
+ 	unsigned int stacklen, numlower = 0, i;
+ 	bool remote = false;
+ 	struct ovl_entry *oe;
+ 
++>>>>>>> 795939a93e60 (ovl: add support for "xino" mount and config options)
  	err = -ENOMEM;
 -	lowertmp = kstrdup(ofs->config.lowerdir, GFP_KERNEL);
 +	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
  	if (!lowertmp)
 -		goto out_err;
 +		goto out_unlock_workdentry;
  
  	err = -EINVAL;
  	stacklen = ovl_split_lowerdirs(lowertmp);
@@@ -1015,155 -1317,135 +1148,232 @@@
  	}
  
  	err = -EINVAL;
 -	sb->s_stack_depth++;
 -	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 +	*overlay_stack_depth += 1;
 +	if (*overlay_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
  		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 -		goto out_err;
 +		goto out_put_lowerpath;
  	}
  
++<<<<<<< HEAD
 +	if (ufs->config.upperdir) {
 +		ufs->upper_mnt = clone_private_mount(&upperpath);
 +		err = PTR_ERR(ufs->upper_mnt);
 +		if (IS_ERR(ufs->upper_mnt)) {
 +			pr_err("overlayfs: failed to clone upperpath\n");
 +			goto out_put_lowerpath;
++=======
+ 	err = ovl_get_lower_layers(ofs, stack, numlower);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	err = -ENOMEM;
+ 	oe = ovl_alloc_entry(numlower);
+ 	if (!oe)
+ 		goto out_err;
+ 
+ 	for (i = 0; i < numlower; i++) {
+ 		oe->lowerstack[i].dentry = dget(stack[i].dentry);
+ 		oe->lowerstack[i].layer = &ofs->lower_layers[i];
+ 	}
+ 
+ 	if (remote)
+ 		sb->s_d_op = &ovl_reval_dentry_operations;
+ 	else
+ 		sb->s_d_op = &ovl_dentry_operations;
+ 
+ out:
+ 	for (i = 0; i < numlower; i++)
+ 		path_put(&stack[i]);
+ 	kfree(stack);
+ 	kfree(lowertmp);
+ 
+ 	return oe;
+ 
+ out_err:
+ 	oe = ERR_PTR(err);
+ 	goto out;
+ }
+ 
+ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
+ {
+ 	struct path upperpath = { };
+ 	struct dentry *root_dentry;
+ 	struct ovl_entry *oe;
+ 	struct ovl_fs *ofs;
+ 	struct cred *cred;
+ 	int err;
+ 
+ 	err = -ENOMEM;
+ 	ofs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
+ 	if (!ofs)
+ 		goto out;
+ 
+ 	ofs->creator_cred = cred = prepare_creds();
+ 	if (!cred)
+ 		goto out_err;
+ 
+ 	ofs->config.index = ovl_index_def;
+ 	ofs->config.nfs_export = ovl_nfs_export_def;
+ 	ofs->config.xino = ovl_xino_def();
+ 	err = ovl_parse_opt((char *) data, &ofs->config);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	err = -EINVAL;
+ 	if (!ofs->config.lowerdir) {
+ 		if (!silent)
+ 			pr_err("overlayfs: missing 'lowerdir'\n");
+ 		goto out_err;
+ 	}
+ 
+ 	sb->s_stack_depth = 0;
+ 	sb->s_maxbytes = MAX_LFS_FILESIZE;
+ 	/* Assume underlaying fs uses 32bit inodes unless proven otherwise */
+ 	if (ofs->config.xino != OVL_XINO_OFF)
+ 		ofs->xino_bits = BITS_PER_LONG - 32;
+ 
+ 	if (ofs->config.upperdir) {
+ 		if (!ofs->config.workdir) {
+ 			pr_err("overlayfs: missing 'workdir'\n");
+ 			goto out_err;
++>>>>>>> 795939a93e60 (ovl: add support for "xino" mount and config options)
  		}
  
 -		err = ovl_get_upper(ofs, &upperpath);
 -		if (err)
 -			goto out_err;
 -
 -		err = ovl_get_workdir(ofs, &upperpath);
 -		if (err)
 -			goto out_err;
 +		/* Don't inherit atime flags */
 +		ufs->upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
  
 -		if (!ofs->workdir)
 -			sb->s_flags |= SB_RDONLY;
 +		sb->s_time_gran = ufs->upper_mnt->mnt_sb->s_time_gran;
  
 -		sb->s_stack_depth = ofs->upper_mnt->mnt_sb->s_stack_depth;
 -		sb->s_time_gran = ofs->upper_mnt->mnt_sb->s_time_gran;
 +		ufs->workdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 +						  OVL_WORKDIR_NAME, false);
 +		/*
 +		 * Upper should support d_type, else whiteouts are visible.
 +		 * Given workdir and upper are on same fs, we can do
 +		 * iterate_dir() on workdir. This check requires successful
 +		 * creation of workdir in previous step.
 +		 */
 +		if (ufs->workdir) {
 +			struct dentry *temp;
 +
 +			err = ovl_check_d_type_supported(&workpath);
 +			if (err < 0)
 +				goto out_put_workdir;
 +
 +			/*
 +			 * Warn instead of error to avoid breaking previously
 +			 * working configurations over upgrade. If d_type
 +			 * is not supported, whiteouts will become visible
 +			 * to user space.
 +			 */
 +			if (!err)
 +				pr_warn("overlayfs: upper fs needs to support d_type. This is an invalid configuration.\n");
 +
 +			/* Check if upper/work fs supports O_TMPFILE */
 +			temp = ovl_do_tmpfile(ufs->workdir, S_IFREG | 0);
 +			ufs->tmpfile = !IS_ERR(temp);
 +			if (ufs->tmpfile)
 +				dput(temp);
 +
 +			/*
 +			 * Check if upper/work fs supports trusted.overlay.*
 +			 * xattr
 +			 */
 +			err = ovl_do_setxattr(ufs->workdir, OVL_XATTR_OPAQUE,
 +					      "0", 1, 0);
 +			if (err) {
 +				ufs->noxattr = true;
 +				pr_warn("overlayfs: upper fs does not support xattr.\n");
 +			} else {
 +				vfs_removexattr(ufs->workdir, OVL_XATTR_OPAQUE);
 +			}
  
 +			/* Check if upper/work fs supports file handles */
 +			if (ufs->config.index &&
 +			    !ovl_can_decode_fh(ufs->workdir->d_sb)) {
 +				ufs->config.index = false;
 +				pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
 +			}
 +		}
  	}
 -	oe = ovl_get_lowerstack(sb, ofs);
 -	err = PTR_ERR(oe);
 -	if (IS_ERR(oe))
 -		goto out_err;
 -
 -	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
 -	if (!ofs->upper_mnt)
 -		sb->s_flags |= SB_RDONLY;
  
 -	if (!(ovl_force_readonly(ofs)) && ofs->config.index) {
 -		err = ovl_get_indexdir(ofs, oe, &upperpath);
 -		if (err)
 -			goto out_free_oe;
 +	err = -ENOMEM;
 +	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
 +	if (ufs->lower_mnt == NULL)
 +		goto out_put_workdir;
 +	for (i = 0; i < numlower; i++) {
 +		struct vfsmount *mnt = clone_private_mount(&stack[i]);
  
 -		/* Force r/o mount with no index dir */
 -		if (!ofs->indexdir) {
 -			dput(ofs->workdir);
 -			ofs->workdir = NULL;
 -			sb->s_flags |= SB_RDONLY;
 +		err = PTR_ERR(mnt);
 +		if (IS_ERR(mnt)) {
 +			pr_err("overlayfs: failed to clone lowerpath\n");
 +			goto out_put_lower_mnt;
  		}
 +		/*
 +		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 +		 * will fail instead of modifying lower fs.
 +		 */
 +		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
  
 +		ufs->lower_mnt[ufs->numlower] = mnt;
 +		ufs->numlower++;
 +
 +		/* Check if all lower layers are on same sb */
 +		if (i == 0)
 +			ufs->same_sb = mnt->mnt_sb;
 +		else if (ufs->same_sb != mnt->mnt_sb)
 +			ufs->same_sb = NULL;
  	}
  
 -	/* Show index=off in /proc/mounts for forced r/o mount */
 -	if (!ofs->indexdir) {
 -		ofs->config.index = false;
 -		if (ofs->upper_mnt && ofs->config.nfs_export) {
 -			pr_warn("overlayfs: NFS export requires an index dir, falling back to nfs_export=off.\n");
 -			ofs->config.nfs_export = false;
 +	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
 +	if (!ufs->upper_mnt)
 +		sb->s_flags |= MS_RDONLY;
 +	else if (ufs->upper_mnt->mnt_sb != ufs->same_sb)
 +		ufs->same_sb = NULL;
 +
 +	if (!(ovl_force_readonly(ufs)) && ufs->config.index) {
 +		/* Verify lower root is upper root origin */
 +		err = ovl_verify_origin(upperpath.dentry, ufs->lower_mnt[0],
 +					stack[0].dentry, false, true);
 +		if (err) {
 +			pr_err("overlayfs: failed to verify upper root origin\n");
 +			goto out_put_lower_mnt;
  		}
 +
 +		ufs->indexdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 +						   OVL_INDEXDIR_NAME, true);
 +		if (ufs->indexdir) {
 +			/* Verify upper root is index dir origin */
 +			err = ovl_verify_origin(ufs->indexdir, ufs->upper_mnt,
 +						upperpath.dentry, true, true);
 +			if (err)
 +				pr_err("overlayfs: failed to verify index dir origin\n");
 +
 +			/* Cleanup bad/stale/orphan index entries */
 +			if (!err)
 +				err = ovl_indexdir_cleanup(ufs->indexdir,
 +							   ufs->upper_mnt,
 +							   stack, numlower);
 +		}
 +		if (err || !ufs->indexdir)
 +			pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
 +		if (err)
 +			goto out_put_indexdir;
  	}
  
 +	/* Show index=off/on in /proc/mounts for any of the reasons above */
 +	if (!ufs->indexdir)
 +		ufs->config.index = false;
 +
 +	if (remote)
 +		sb->s_d_op = &ovl_reval_dentry_operations.ops;
 +	else
 +		sb->s_d_op = &ovl_dentry_operations.ops;
 +
 +	err = -ENOMEM;
 +	ufs->creator_cred = cred = prepare_creds();
 +	if (!cred)
 +		goto out_put_indexdir;
 +
  	if (ofs->config.nfs_export)
  		sb->s_export_op = &ovl_export_operations;
  
* Unmerged path fs/overlayfs/Kconfig
* Unmerged path fs/overlayfs/ovl_entry.h
* Unmerged path fs/overlayfs/super.c
