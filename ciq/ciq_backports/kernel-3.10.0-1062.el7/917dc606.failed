KVM: nVMX: Fix vmx_check_nested_events() return value in case an event was reinjected to L2

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Liran Alon <liran.alon@oracle.com>
commit 917dc6068bc12a2dafffcf0e9d405ddb1b8780cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/917dc606.failed

vmx_check_nested_events() should return -EBUSY only in case there is a
pending L1 event which requires a VMExit from L2 to L1 but such a
VMExit is currently blocked. Such VMExits are blocked either
because nested_run_pending=1 or an event was reinjected to L2.
vmx_check_nested_events() should return 0 in case there are no
pending L1 events which requires a VMExit from L2 to L1 or if
a VMExit from L2 to L1 was done internally.

However, upstream commit which introduced blocking in case an event was
reinjected to L2 (commit acc9ab601327 ("KVM: nVMX: Fix pending events
injection")) contains a bug: It returns -EBUSY even if there are no
pending L1 events which requires VMExit from L2 to L1.

This commit fix this issue.

Fixes: acc9ab601327 ("KVM: nVMX: Fix pending events injection")

	Signed-off-by: Liran Alon <liran.alon@oracle.com>
	Reviewed-by: Nikita Leshenko <nikita.leshchenko@oracle.com>
	Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 917dc6068bc12a2dafffcf0e9d405ddb1b8780cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 6e24c4e66a69,be4724b5d434..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -10924,13 -11104,22 +10924,29 @@@ static void vmcs12_save_pending_event(s
  static int vmx_check_nested_events(struct kvm_vcpu *vcpu, bool external_intr)
  {
  	struct vcpu_vmx *vmx = to_vmx(vcpu);
++<<<<<<< HEAD
 +
 +	if (kvm_event_needs_reinjection(vcpu))
 +		return -EBUSY;
 +
++=======
+ 	unsigned long exit_qual;
+ 	bool block_nested_events =
+ 	    vmx->nested.nested_run_pending || kvm_event_needs_reinjection(vcpu);
+ 
+ 	if (vcpu->arch.exception.pending &&
+ 		nested_vmx_check_exception(vcpu, &exit_qual)) {
+ 		if (block_nested_events)
+ 			return -EBUSY;
+ 		nested_vmx_inject_exception_vmexit(vcpu, exit_qual);
+ 		vcpu->arch.exception.pending = false;
+ 		return 0;
+ 	}
+ 
++>>>>>>> 917dc6068bc1 (KVM: nVMX: Fix vmx_check_nested_events() return value in case an event was reinjected to L2)
  	if (nested_cpu_has_preemption_timer(get_vmcs12(vcpu)) &&
  	    vmx->nested.preemption_timer_expired) {
- 		if (vmx->nested.nested_run_pending)
+ 		if (block_nested_events)
  			return -EBUSY;
  		nested_vmx_vmexit(vcpu, EXIT_REASON_PREEMPTION_TIMER, 0, 0);
  		return 0;
* Unmerged path arch/x86/kvm/vmx.c
