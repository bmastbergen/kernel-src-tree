xfs: fix bmv_count confusion w/ shared extents

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit c364b6d0b6cda1cd5d9ab689489adda3e82529aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c364b6d0.failed

In a bmapx call, bmv_count is the total size of the array, including the
zeroth element that userspace uses to supply the search key.  The output
array starts at offset 1 so that we can set up the user for the next
invocation.  Since we now can split an extent into multiple bmap records
due to shared/unshared status, we have to be careful that we don't
overflow the output array.

In the original patch f86f403794b ("xfs: teach get_bmapx about shared
extents and the CoW fork") I used cur_ext (the output index) to check
for overflows, albeit with an off-by-one error.  Since nexleft no longer
describes the number of unfilled slots in the output, we can rip all
that out and use cur_ext for the overflow check directly.

Failure to do this causes heap corruption in bmapx callers such as
xfs_io and xfs_scrub.  xfs/328 can reproduce this problem.

	Reviewed-by: Eric Sandeen <sandeen@redhat.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit c364b6d0b6cda1cd5d9ab689489adda3e82529aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/xfs_bmap_util.c
index ad7a1ab465c3,c1417919ab0a..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -601,7 -694,8 +598,12 @@@ xfs_getbmap
  			goto out_free_map;
  		ASSERT(nmap <= subnex);
  
++<<<<<<< HEAD
 +		for (i = 0; i < nmap && nexleft && bmv->bmv_length; i++) {
++=======
+ 		for (i = 0; i < nmap && bmv->bmv_length &&
+ 				cur_ext < bmv->bmv_count - 1; i++) {
++>>>>>>> c364b6d0b6cd (xfs: fix bmv_count confusion w/ shared extents)
  			out[cur_ext].bmv_oflags = 0;
  			if (map[i].br_state == XFS_EXT_UNWRITTEN)
  				out[cur_ext].bmv_oflags |= BMV_OF_PREALLOC;
@@@ -656,11 -757,27 +658,35 @@@
  				continue;
  			}
  
++<<<<<<< HEAD
 +			nexleft--;
 +			bmv->bmv_entries++;
 +			cur_ext++;
 +		}
 +	} while (nmap && nexleft && bmv->bmv_length);
++=======
+ 			/*
+ 			 * In order to report shared extents accurately,
+ 			 * we report each distinct shared/unshared part
+ 			 * of a single bmbt record using multiple bmap
+ 			 * extents.  To make that happen, we iterate the
+ 			 * same map array item multiple times, each
+ 			 * time trimming out the subextent that we just
+ 			 * reported.
+ 			 *
+ 			 * Because of this, we must check the out array
+ 			 * index (cur_ext) directly against bmv_count-1
+ 			 * to avoid overflows.
+ 			 */
+ 			if (inject_map.br_startblock != NULLFSBLOCK) {
+ 				map[i] = inject_map;
+ 				i--;
+ 			}
+ 			bmv->bmv_entries++;
+ 			cur_ext++;
+ 		}
+ 	} while (nmap && bmv->bmv_length && cur_ext < bmv->bmv_count - 1);
++>>>>>>> c364b6d0b6cd (xfs: fix bmv_count confusion w/ shared extents)
  
   out_free_map:
  	kmem_free(map);
* Unmerged path fs/xfs/xfs_bmap_util.c
