xfs: prevent creating negative-sized file via INSERT_RANGE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 7d83fb14258b9961920cd86f0b921caaeb3ebe85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7d83fb14.failed


During the "insert range" fallocate operation, i_size grows by the
specified 'len' bytes.  XFS verifies that i_size + len < s_maxbytes, as
it should.  But this comparison is done using the signed 'loff_t', and
'i_size + len' can wrap around to a negative value, causing the check to
incorrectly pass, resulting in an inode with "negative" i_size.  This is
possible on 64-bit platforms, where XFS sets s_maxbytes = LLONG_MAX.
ext4 and f2fs don't run into this because they set a smaller s_maxbytes.

Fix it by using subtraction instead.

Reproducer:
    xfs_io -f file -c "truncate $(((1<<63)-1))" -c "finsert 0 4096"

Fixes: a904b1ca5751 ("xfs: Add support FALLOC_FL_INSERT_RANGE for fallocate")
	Cc: <stable@vger.kernel.org> # v4.1+
Originally-From: Eric Biggers <ebiggers@google.com>
	Signed-off-by: Eric Biggers <ebiggers@google.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
[darrick: fix signed integer addition overflow too]
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 7d83fb14258b9961920cd86f0b921caaeb3ebe85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_file.c
diff --cc fs/xfs/xfs_file.c
index 374d446488ef,eed073cc4778..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -1018,6 -777,31 +1018,34 @@@ xfs_file_fallocate
  		error = xfs_collapse_file_space(ip, offset, len);
  		if (error)
  			goto out_unlock;
++<<<<<<< HEAD
++=======
+ 	} else if (mode & FALLOC_FL_INSERT_RANGE) {
+ 		unsigned int	blksize_mask = i_blocksize(inode) - 1;
+ 		loff_t		isize = i_size_read(inode);
+ 
+ 		if (offset & blksize_mask || len & blksize_mask) {
+ 			error = -EINVAL;
+ 			goto out_unlock;
+ 		}
+ 
+ 		/*
+ 		 * New inode size must not exceed ->s_maxbytes, accounting for
+ 		 * possible signed overflow.
+ 		 */
+ 		if (inode->i_sb->s_maxbytes - isize < len) {
+ 			error = -EFBIG;
+ 			goto out_unlock;
+ 		}
+ 		new_size = isize + len;
+ 
+ 		/* Offset should be less than i_size */
+ 		if (offset >= isize) {
+ 			error = -EINVAL;
+ 			goto out_unlock;
+ 		}
+ 		do_file_insert = true;
++>>>>>>> 7d83fb14258b (xfs: prevent creating negative-sized file via INSERT_RANGE)
  	} else {
  		flags |= XFS_PREALLOC_SET;
  
* Unmerged path fs/xfs/xfs_file.c
