IB/mlx5: Add flow counters binding support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Raed Salem <raeds@mellanox.com>
commit 3b3233fbf02ee4c5de4d635ca6c4f2566d9716df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3b3233fb.failed

Associates a counters with a flow when IB_FLOW_SPEC_ACTION_COUNT is part
of the flow specifications.

The counters user space placements of location and description (index,
description) pairs are passed as private data of the counters flow
specification.

	Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Raed Salem <raeds@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 3b3233fbf02ee4c5de4d635ca6c4f2566d9716df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
#	drivers/infiniband/hw/mlx5/mlx5_ib.h
diff --cc drivers/infiniband/hw/mlx5/main.c
index 1726b9447b75,c52841bad4e7..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -2319,7 -2449,7 +2319,11 @@@ static int check_mpls_supp_fields(u32 f
  #define LAST_TUNNEL_FIELD tunnel_id
  #define LAST_FLOW_TAG_FIELD tag_id
  #define LAST_DROP_FIELD size
++<<<<<<< HEAD
 +#define LAST_DROP_FIELD size
++=======
+ #define LAST_COUNTERS_FIELD counters
++>>>>>>> 3b3233fbf02e (IB/mlx5: Add flow counters binding support)
  
  /* Field is the last supported field */
  #define FIELDS_NOT_SUPPORTED(filter, field)\
@@@ -2849,8 -2911,11 +2876,15 @@@ static int mlx5_ib_destroy_flow(struct 
  
  	mlx5_del_flow_rules(handler->rule);
  	put_flow_table(dev, handler->prio, true);
++<<<<<<< HEAD
 +	mutex_unlock(&dev->flow_db.lock);
++=======
+ 	if (handler->ibcounters &&
+ 	    atomic_read(&handler->ibcounters->usecnt) == 1)
+ 		counters_clear_description(handler->ibcounters);
++>>>>>>> 3b3233fbf02e (IB/mlx5: Add flow counters binding support)
  
+ 	mutex_unlock(&dev->flow_db->lock);
  	kfree(handler);
  
  	return 0;
@@@ -2980,12 -3150,12 +3119,13 @@@ static struct mlx5_ib_flow_handler *_cr
  	struct mlx5_ib_flow_handler *handler;
  	struct mlx5_flow_act flow_act = {.flow_tag = MLX5_FS_DEFAULT_FLOW_TAG};
  	struct mlx5_flow_spec *spec;
- 	struct mlx5_flow_destination *rule_dst = dst;
+ 	struct mlx5_flow_destination dest_arr[2] = {};
+ 	struct mlx5_flow_destination *rule_dst = dest_arr;
  	const void *ib_flow = (const void *)flow_attr + sizeof(*flow_attr);
  	unsigned int spec_index;
 +	u32 prev_type = 0;
  	int err = 0;
- 	int dest_num = 1;
+ 	int dest_num = 0;
  	bool is_egress = flow_attr->flags & IB_FLOW_ATTR_FLAGS_EGRESS;
  
  	if (!is_valid_attr(dev->mdev, flow_attr))
@@@ -3299,8 -3521,9 +3493,9 @@@ static struct ib_flow *mlx5_ib_create_f
  		goto destroy_ft;
  	}
  
 -	mutex_unlock(&dev->flow_db->lock);
 +	mutex_unlock(&dev->flow_db.lock);
  	kfree(dst);
+ 	kfree(ucmd);
  
  	return &handler->ibflow;
  
@@@ -3309,8 -3532,9 +3504,9 @@@ destroy_ft
  	if (ft_prio_tx)
  		put_flow_table(dev, ft_prio_tx, false);
  unlock:
 -	mutex_unlock(&dev->flow_db->lock);
 +	mutex_unlock(&dev->flow_db.lock);
  	kfree(dst);
+ 	kfree(ucmd);
  	kfree(handler);
  	return ERR_PTR(err);
  }
@@@ -4766,7 -5154,76 +4962,80 @@@ static void mlx5_ib_cleanup_multiport_m
  	mlx5_nic_vport_disable_roce(dev->mdev);
  }
  
++<<<<<<< HEAD
 +static void mlx5_ib_stage_init_cleanup(struct mlx5_ib_dev *dev)
++=======
+ ADD_UVERBS_ATTRIBUTES_SIMPLE(mlx5_ib_dm, UVERBS_OBJECT_DM,
+ 			     UVERBS_METHOD_DM_ALLOC,
+ 			     &UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_START_OFFSET,
+ 						  UVERBS_ATTR_TYPE(u64),
+ 						  UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 			     &UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_PAGE_INDEX,
+ 						  UVERBS_ATTR_TYPE(u16),
+ 						  UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+ 
+ ADD_UVERBS_ATTRIBUTES_SIMPLE(mlx5_ib_flow_action, UVERBS_OBJECT_FLOW_ACTION,
+ 			     UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
+ 			     &UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_FLOW_ACTION_FLAGS,
+ 						 UVERBS_ATTR_TYPE(u64),
+ 						 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+ 
+ #define NUM_TREES	2
+ static int populate_specs_root(struct mlx5_ib_dev *dev)
+ {
+ 	const struct uverbs_object_tree_def *default_root[NUM_TREES + 1] = {
+ 		uverbs_default_get_objects()};
+ 	size_t num_trees = 1;
+ 
+ 	if (mlx5_accel_ipsec_device_caps(dev->mdev) & MLX5_ACCEL_IPSEC_CAP_DEVICE &&
+ 	    !WARN_ON(num_trees >= ARRAY_SIZE(default_root)))
+ 		default_root[num_trees++] = &mlx5_ib_flow_action;
+ 
+ 	if (MLX5_CAP_DEV_MEM(dev->mdev, memic) &&
+ 	    !WARN_ON(num_trees >= ARRAY_SIZE(default_root)))
+ 		default_root[num_trees++] = &mlx5_ib_dm;
+ 
+ 	dev->ib_dev.specs_root =
+ 		uverbs_alloc_spec_tree(num_trees, default_root);
+ 
+ 	return PTR_ERR_OR_ZERO(dev->ib_dev.specs_root);
+ }
+ 
+ static void depopulate_specs_root(struct mlx5_ib_dev *dev)
+ {
+ 	uverbs_free_spec_tree(dev->ib_dev.specs_root);
+ }
+ 
+ static int mlx5_ib_destroy_counters(struct ib_counters *counters)
+ {
+ 	struct mlx5_ib_mcounters *mcounters = to_mcounters(counters);
+ 
+ 	counters_clear_description(counters);
+ 	if (mcounters->hw_cntrs_hndl)
+ 		mlx5_fc_destroy(to_mdev(counters->device)->mdev,
+ 				mcounters->hw_cntrs_hndl);
+ 
+ 	kfree(mcounters);
+ 
+ 	return 0;
+ }
+ 
+ static struct ib_counters *mlx5_ib_create_counters(struct ib_device *device,
+ 						   struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_mcounters *mcounters;
+ 
+ 	mcounters = kzalloc(sizeof(*mcounters), GFP_KERNEL);
+ 	if (!mcounters)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	mutex_init(&mcounters->mcntrs_mutex);
+ 
+ 	return &mcounters->ibcntrs;
+ }
+ 
+ void mlx5_ib_stage_init_cleanup(struct mlx5_ib_dev *dev)
++>>>>>>> 3b3233fbf02e (IB/mlx5: Add flow counters binding support)
  {
  	mlx5_ib_cleanup_multiport_master(dev);
  #ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
diff --cc drivers/infiniband/hw/mlx5/mlx5_ib.h
index 7653bfad9f25,155bca627222..000000000000
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@@ -772,6 -798,46 +773,49 @@@ struct mlx5_ib_multiport_info 
  	bool unaffiliate;
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5_ib_flow_action {
+ 	struct ib_flow_action		ib_action;
+ 	union {
+ 		struct {
+ 			u64			    ib_flags;
+ 			struct mlx5_accel_esp_xfrm *ctx;
+ 		} esp_aes_gcm;
+ 	};
+ };
+ 
+ struct mlx5_memic {
+ 	struct mlx5_core_dev *dev;
+ 	spinlock_t		memic_lock;
+ 	DECLARE_BITMAP(memic_alloc_pages, MLX5_MAX_MEMIC_PAGES);
+ };
+ 
+ enum mlx5_ib_counters_type {
+ 	MLX5_IB_COUNTERS_FLOW,
+ };
+ 
+ struct mlx5_ib_mcounters {
+ 	struct ib_counters ibcntrs;
+ 	enum mlx5_ib_counters_type type;
+ 	void *hw_cntrs_hndl;
+ 	/* max index set as part of create_flow */
+ 	u32 cntrs_max_index;
+ 	/* number of counters data entries (<description,index> pair) */
+ 	u32 ncounters;
+ 	/* counters data array for descriptions and indexes */
+ 	struct mlx5_ib_flow_counters_desc *counters_data;
+ 	/* protects access to mcounters internal data */
+ 	struct mutex mcntrs_mutex;
+ };
+ 
+ static inline struct mlx5_ib_mcounters *
+ to_mcounters(struct ib_counters *ibcntrs)
+ {
+ 	return container_of(ibcntrs, struct mlx5_ib_mcounters, ibcntrs);
+ }
+ 
++>>>>>>> 3b3233fbf02e (IB/mlx5: Add flow counters binding support)
  struct mlx5_ib_dev {
  	struct ib_device		ib_dev;
  	struct mlx5_core_dev		*mdev;
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path drivers/infiniband/hw/mlx5/mlx5_ib.h
diff --git a/include/linux/mlx5/fs.h b/include/linux/mlx5/fs.h
index 471501d4c3c1..53d6b852962a 100644
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@ -157,6 +157,7 @@ struct mlx5_flow_act {
 	u32 encap_id;
 	u32 modify_id;
 	struct mlx5_fs_vlan vlan;
+	struct ib_counters *counters;
 };
 
 #define MLX5_DECLARE_FLOW_ACT(name) \
diff --git a/include/uapi/rdma/mlx5-abi.h b/include/uapi/rdma/mlx5-abi.h
index 9c99cfe01569..b92cbebe0150 100644
--- a/include/uapi/rdma/mlx5-abi.h
+++ b/include/uapi/rdma/mlx5-abi.h
@@ -35,6 +35,7 @@
 
 #include <linux/types.h>
 #include <linux/if_ether.h>	/* For ETH_ALEN. */
+#include <rdma/ib_user_ioctl_verbs.h>
 
 enum {
 	MLX5_QP_FLAG_SIGNATURE		= 1 << 0,
@@ -441,4 +442,27 @@ enum {
 enum {
 	MLX5_IB_CLOCK_INFO_V1              = 0,
 };
+
+struct mlx5_ib_flow_counters_desc {
+	__u32	description;
+	__u32	index;
+};
+
+struct mlx5_ib_flow_counters_data {
+	RDMA_UAPI_PTR(struct mlx5_ib_flow_counters_desc *, counters_data);
+	__u32   ncounters;
+	__u32   reserved;
+};
+
+struct mlx5_ib_create_flow {
+	__u32   ncounters_data;
+	__u32   reserved;
+	/*
+	 * Following are counters data based on ncounters_data, each
+	 * entry in the data[] should match a corresponding counter object
+	 * that was pointed by a counters spec upon the flow creation
+	 */
+	struct mlx5_ib_flow_counters_data data[];
+};
+
 #endif /* MLX5_ABI_USER_H */
