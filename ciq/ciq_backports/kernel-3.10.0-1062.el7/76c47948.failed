nfsd: encode stat->mtime for getattr instead of inode->i_mtime

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 76c479480b9afff4c585a17e19a1efe3457a2d9b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/76c47948.failed

The values of stat->mtime and inode->i_mtime may differ for overlayfs
and stat->mtime is the correct value to use when encoding getattr.
This is also consistent with the fact that other attr times are also
encoded from stat values.

Both callers of lease_get_mtime() already have the value of stat->mtime,
so the only needed change is that lease_get_mtime() will not overwrite
this value with inode->i_mtime in case the inode does not have an
exclusive lease.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 76c479480b9afff4c585a17e19a1efe3457a2d9b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/locks.c
#	fs/nfsd/nfsxdr.c
diff --cc fs/locks.c
index a3072b4762e2,db374a025811..000000000000
--- a/fs/locks.c
+++ b/fs/locks.c
@@@ -1463,11 -1564,22 +1463,30 @@@ EXPORT_SYMBOL(__break_lease)
   */
  void lease_get_mtime(struct inode *inode, struct timespec *time)
  {
++<<<<<<< HEAD
 +	struct file_lock *flock = inode->i_flock;
 +	if (flock && IS_LEASE(flock) && (flock->fl_type == F_WRLCK))
 +		*time = current_fs_time(inode->i_sb);
 +	else
 +		*time = inode->i_mtime;
++=======
+ 	bool has_lease = false;
+ 	struct file_lock_context *ctx;
+ 	struct file_lock *fl;
+ 
+ 	ctx = smp_load_acquire(&inode->i_flctx);
+ 	if (ctx && !list_empty_careful(&ctx->flc_lease)) {
+ 		spin_lock(&ctx->flc_lock);
+ 		fl = list_first_entry_or_null(&ctx->flc_lease,
+ 					      struct file_lock, fl_list);
+ 		if (fl && (fl->fl_type == F_WRLCK))
+ 			has_lease = true;
+ 		spin_unlock(&ctx->flc_lock);
+ 	}
+ 
+ 	if (has_lease)
+ 		*time = current_time(inode);
++>>>>>>> 76c479480b9a (nfsd: encode stat->mtime for getattr instead of inode->i_mtime)
  }
  
  EXPORT_SYMBOL(lease_get_mtime);
diff --cc fs/nfsd/nfsxdr.c
index 8f7b690dd4ae,79b6064f8977..000000000000
--- a/fs/nfsd/nfsxdr.c
+++ b/fs/nfsd/nfsxdr.c
@@@ -187,7 -188,8 +187,12 @@@ encode_fattr(struct svc_rqst *rqstp, __
  	*p++ = htonl((u32) stat->ino);
  	*p++ = htonl((u32) stat->atime.tv_sec);
  	*p++ = htonl(stat->atime.tv_nsec ? stat->atime.tv_nsec / 1000 : 0);
++<<<<<<< HEAD
 +	lease_get_mtime(dentry->d_inode, &time); 
++=======
+ 	time = stat->mtime;
+ 	lease_get_mtime(d_inode(dentry), &time); 
++>>>>>>> 76c479480b9a (nfsd: encode stat->mtime for getattr instead of inode->i_mtime)
  	*p++ = htonl((u32) time.tv_sec);
  	*p++ = htonl(time.tv_nsec ? time.tv_nsec / 1000 : 0); 
  	*p++ = htonl((u32) stat->ctime.tv_sec);
* Unmerged path fs/locks.c
* Unmerged path fs/nfsd/nfsxdr.c
