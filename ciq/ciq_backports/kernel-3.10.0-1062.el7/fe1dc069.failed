net/mlx5e: don't set CHECKSUM_COMPLETE on SCTP packets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: don't set CHECKSUM_COMPLETE on SCTP packets (Alaa Hleihel) [1467290 1642498]
Rebuild_FUZZ: 96.15%
commit-author Alaa Hleihel <alaa@mellanox.com>
commit fe1dc069990c1f290ef6b99adb46332c03258f38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fe1dc069.failed

CHECKSUM_COMPLETE is not applicable to SCTP protocol.
Setting it for SCTP packets leads to CRC32c validation failure.

Fixes: bbceefce9adf ("net/mlx5e: Support RX CHECKSUM_COMPLETE")
	Signed-off-by: Alaa Hleihel <alaa@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit fe1dc069990c1f290ef6b99adb46332c03258f38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
index 3631c4f3022b,424bc89184c6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
@@@ -635,14 -691,78 +635,22 @@@ static inline void mlx5e_skb_set_hash(s
  	skb_set_hash(skb, be32_to_cpu(cqe->rss_hash_result), ht);
  }
  
 -static inline bool is_last_ethertype_ip(struct sk_buff *skb, int *network_depth,
 -					__be16 *proto)
 +static inline bool is_last_ethertype_ip(struct sk_buff *skb, int *network_depth)
  {
 -	*proto = ((struct ethhdr *)skb->data)->h_proto;
 -	*proto = __vlan_get_protocol(skb, *proto, network_depth);
 -	return (*proto == htons(ETH_P_IP) || *proto == htons(ETH_P_IPV6));
 -}
 -
 -static inline void mlx5e_enable_ecn(struct mlx5e_rq *rq, struct sk_buff *skb)
 -{
 -	int network_depth = 0;
 -	__be16 proto;
 -	void *ip;
 -	int rc;
 +	__be16 ethertype = ((struct ethhdr *)skb->data)->h_proto;
  
 -	if (unlikely(!is_last_ethertype_ip(skb, &network_depth, &proto)))
 -		return;
 -
 -	ip = skb->data + network_depth;
 -	rc = ((proto == htons(ETH_P_IP)) ? IP_ECN_set_ce((struct iphdr *)ip) :
 -					 IP6_ECN_set_ce(skb, (struct ipv6hdr *)ip));
 -
 -	rq->stats->ecn_mark += !!rc;
 -}
 -
 -static __be32 mlx5e_get_fcs(struct sk_buff *skb)
 -{
 -	int last_frag_sz, bytes_in_prev, nr_frags;
 -	u8 *fcs_p1, *fcs_p2;
 -	skb_frag_t *last_frag;
 -	__be32 fcs_bytes;
 -
 -	if (!skb_is_nonlinear(skb))
 -		return *(__be32 *)(skb->data + skb->len - ETH_FCS_LEN);
 -
 -	nr_frags = skb_shinfo(skb)->nr_frags;
 -	last_frag = &skb_shinfo(skb)->frags[nr_frags - 1];
 -	last_frag_sz = skb_frag_size(last_frag);
 -
 -	/* If all FCS data is in last frag */
 -	if (last_frag_sz >= ETH_FCS_LEN)
 -		return *(__be32 *)(skb_frag_address(last_frag) +
 -				   last_frag_sz - ETH_FCS_LEN);
 -
 -	fcs_p2 = (u8 *)skb_frag_address(last_frag);
 -	bytes_in_prev = ETH_FCS_LEN - last_frag_sz;
 -
 -	/* Find where the other part of the FCS is - Linear or another frag */
 -	if (nr_frags == 1) {
 -		fcs_p1 = skb_tail_pointer(skb);
 -	} else {
 -		skb_frag_t *prev_frag = &skb_shinfo(skb)->frags[nr_frags - 2];
 -
 -		fcs_p1 = skb_frag_address(prev_frag) +
 -			    skb_frag_size(prev_frag);
 -	}
 -	fcs_p1 -= bytes_in_prev;
 -
 -	memcpy(&fcs_bytes, fcs_p1, bytes_in_prev);
 -	memcpy(((u8 *)&fcs_bytes) + bytes_in_prev, fcs_p2, last_frag_sz);
 -
 -	return fcs_bytes;
 +	ethertype = __vlan_get_protocol(skb, ethertype, network_depth);
 +	return (ethertype == htons(ETH_P_IP) || ethertype == htons(ETH_P_IPV6));
  }
  
+ static u8 get_ip_proto(struct sk_buff *skb, __be16 proto)
+ {
+ 	void *ip_p = skb->data + sizeof(struct ethhdr);
+ 
+ 	return (proto == htons(ETH_P_IP)) ? ((struct iphdr *)ip_p)->protocol :
+ 					    ((struct ipv6hdr *)ip_p)->nexthdr;
+ }
+ 
  static inline void mlx5e_handle_csum(struct net_device *netdev,
  				     struct mlx5_cqe64 *cqe,
  				     struct mlx5e_rq *rq,
@@@ -661,7 -782,10 +669,14 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	if (likely(is_last_ethertype_ip(skb, &network_depth))) {
++=======
+ 	if (likely(is_last_ethertype_ip(skb, &network_depth, &proto))) {
+ 		if (unlikely(get_ip_proto(skb, proto) == IPPROTO_SCTP))
+ 			goto csum_unnecessary;
+ 
++>>>>>>> fe1dc069990c (net/mlx5e: don't set CHECKSUM_COMPLETE on SCTP packets)
  		skb->ip_summed = CHECKSUM_COMPLETE;
  		skb->csum = csum_unfold((__force __sum16)cqe->check_sum);
  		if (network_depth > ETH_HLEN)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
