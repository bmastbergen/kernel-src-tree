perf test: Add 'perf test BPF'

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit ba1fae431e74bb427a699187434142fd3fe98390
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ba1fae43.failed

This patch adds BPF testcase for testing BPF event filtering.

By utilizing the result of 'perf test LLVM', this patch compiles the
eBPF sample program then test its ability. The BPF script in 'perf test
LLVM' lets only 50% samples generated by epoll_pwait() to be captured.
This patch runs that system call for 111 times, so the result should
contain 56 samples.

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/1446817783-86722-8-git-send-email-wangnan0@huawei.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit ba1fae431e74bb427a699187434142fd3fe98390)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/tests/Build
#	tools/perf/tests/tests.h
#	tools/perf/util/bpf-loader.c
diff --cc tools/perf/tests/Build
index 40bdfc01aafe,f41ebf8849fe..000000000000
--- a/tools/perf/tests/Build
+++ b/tools/perf/tests/Build
@@@ -31,21 -31,25 +31,26 @@@ perf-y += sample-parsing.
  perf-y += parse-no-sample-id-all.o
  perf-y += kmod-path.o
  perf-y += thread-map.o
++<<<<<<< HEAD
++=======
+ perf-y += llvm.o llvm-src-base.o llvm-src-kbuild.o
+ perf-y += bpf.o
++>>>>>>> ba1fae431e74 (perf test: Add 'perf test BPF')
  perf-y += topology.o
 +perf-y += mem.o
 +perf-y += cpumap.o
 +perf-y += stat.o
 +perf-y += event_update.o
 +perf-y += event-times.o
 +perf-y += expr.o
 +perf-y += backward-ring-buffer.o
 +perf-y += sdt.o
 +perf-y += is_printable_array.o
 +perf-y += bitmap.o
 +perf-y += perf-hooks.o
 +perf-y += unit_number__scnprintf.o
  
 -$(OUTPUT)tests/llvm-src-base.c: tests/bpf-script-example.c
 -	$(call rule_mkdir)
 -	$(Q)echo '#include <tests/llvm.h>' > $@
 -	$(Q)echo 'const char test_llvm__bpf_base_prog[] =' >> $@
 -	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
 -	$(Q)echo ';' >> $@
 -
 -$(OUTPUT)tests/llvm-src-kbuild.c: tests/bpf-script-test-kbuild.c
 -	$(call rule_mkdir)
 -	$(Q)echo '#include <tests/llvm.h>' > $@
 -	$(Q)echo 'const char test_llvm__bpf_test_kbuild_prog[] =' >> $@
 -	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
 -	$(Q)echo ';' >> $@
 -
 -ifeq ($(ARCH),$(filter $(ARCH),x86 arm arm64))
 +ifeq ($(SRCARCH),$(filter $(SRCARCH),x86 arm arm64 powerpc))
  perf-$(CONFIG_DWARF_UNWIND) += dwarf-unwind.o
  endif
  
diff --cc tools/perf/tests/tests.h
index ebc72c7359d4,3c8734a3abbc..000000000000
--- a/tools/perf/tests/tests.h
+++ b/tools/perf/tests/tests.h
@@@ -39,61 -30,44 +39,102 @@@ struct test 
  };
  
  /* Tests */
++<<<<<<< HEAD
 +int test__vmlinux_matches_kallsyms(struct test *test, int subtest);
 +int test__openat_syscall_event(struct test *test, int subtest);
 +int test__openat_syscall_event_on_all_cpus(struct test *test, int subtest);
 +int test__basic_mmap(struct test *test, int subtest);
 +int test__PERF_RECORD(struct test *test, int subtest);
 +int test__perf_evsel__roundtrip_name_test(struct test *test, int subtest);
 +int test__perf_evsel__tp_sched_test(struct test *test, int subtest);
 +int test__syscall_openat_tp_fields(struct test *test, int subtest);
 +int test__pmu(struct test *test, int subtest);
 +int test__attr(struct test *test, int subtest);
 +int test__dso_data(struct test *test, int subtest);
 +int test__dso_data_cache(struct test *test, int subtest);
 +int test__dso_data_reopen(struct test *test, int subtest);
 +int test__parse_events(struct test *test, int subtest);
 +int test__hists_link(struct test *test, int subtest);
 +int test__python_use(struct test *test, int subtest);
 +int test__bp_signal(struct test *test, int subtest);
 +int test__bp_signal_overflow(struct test *test, int subtest);
 +int test__task_exit(struct test *test, int subtest);
 +int test__mem(struct test *test, int subtest);
 +int test__sw_clock_freq(struct test *test, int subtest);
 +int test__code_reading(struct test *test, int subtest);
 +int test__sample_parsing(struct test *test, int subtest);
 +int test__keep_tracking(struct test *test, int subtest);
 +int test__parse_no_sample_id_all(struct test *test, int subtest);
 +int test__dwarf_unwind(struct test *test, int subtest);
 +int test__expr(struct test *test, int subtest);
 +int test__hists_filter(struct test *test, int subtest);
 +int test__mmap_thread_lookup(struct test *test, int subtest);
 +int test__thread_mg_share(struct test *test, int subtest);
 +int test__hists_output(struct test *test, int subtest);
 +int test__hists_cumulate(struct test *test, int subtest);
 +int test__switch_tracking(struct test *test, int subtest);
 +int test__fdarray__filter(struct test *test, int subtest);
 +int test__fdarray__add(struct test *test, int subtest);
 +int test__kmod_path__parse(struct test *test, int subtest);
 +int test__thread_map(struct test *test, int subtest);
 +int test__session_topology(struct test *test, int subtest);
 +int test__thread_map_synthesize(struct test *test, int subtest);
 +int test__thread_map_remove(struct test *test, int subtest);
 +int test__cpu_map_synthesize(struct test *test, int subtest);
 +int test__synthesize_stat_config(struct test *test, int subtest);
 +int test__synthesize_stat(struct test *test, int subtest);
 +int test__synthesize_stat_round(struct test *test, int subtest);
 +int test__event_update(struct test *test, int subtest);
 +int test__event_times(struct test *test, int subtest);
 +int test__backward_ring_buffer(struct test *test, int subtest);
 +int test__cpu_map_print(struct test *test, int subtest);
 +int test__sdt_event(struct test *test, int subtest);
 +int test__is_printable_array(struct test *test, int subtest);
 +int test__bitmap_print(struct test *test, int subtest);
 +int test__perf_hooks(struct test *test, int subtest);
 +int test__unit_number__scnprint(struct test *test, int subtest);
 +
 +bool test__bp_signal_is_supported(void);
++=======
+ int test__vmlinux_matches_kallsyms(void);
+ int test__openat_syscall_event(void);
+ int test__openat_syscall_event_on_all_cpus(void);
+ int test__basic_mmap(void);
+ int test__PERF_RECORD(void);
+ int test__perf_evsel__roundtrip_name_test(void);
+ int test__perf_evsel__tp_sched_test(void);
+ int test__syscall_openat_tp_fields(void);
+ int test__pmu(void);
+ int test__attr(void);
+ int test__dso_data(void);
+ int test__dso_data_cache(void);
+ int test__dso_data_reopen(void);
+ int test__parse_events(void);
+ int test__hists_link(void);
+ int test__python_use(void);
+ int test__bp_signal(void);
+ int test__bp_signal_overflow(void);
+ int test__task_exit(void);
+ int test__sw_clock_freq(void);
+ int test__code_reading(void);
+ int test__sample_parsing(void);
+ int test__keep_tracking(void);
+ int test__parse_no_sample_id_all(void);
+ int test__dwarf_unwind(void);
+ int test__hists_filter(void);
+ int test__mmap_thread_lookup(void);
+ int test__thread_mg_share(void);
+ int test__hists_output(void);
+ int test__hists_cumulate(void);
+ int test__switch_tracking(void);
+ int test__fdarray__filter(void);
+ int test__fdarray__add(void);
+ int test__kmod_path__parse(void);
+ int test__thread_map(void);
+ int test__llvm(void);
+ int test__bpf(void);
+ int test_session_topology(void);
++>>>>>>> ba1fae431e74 (perf test: Add 'perf test BPF')
  
  #if defined(__arm__) || defined(__aarch64__)
  #ifdef HAVE_DWARF_UNWIND_SUPPORT
diff --cc tools/perf/util/bpf-loader.c
index 39bf9252ae96,4c50411371db..000000000000
--- a/tools/perf/util/bpf-loader.c
+++ b/tools/perf/util/bpf-loader.c
@@@ -27,10 -30,36 +27,40 @@@ DEFINE_PRINT_FN(warning, 1
  DEFINE_PRINT_FN(info, 1)
  DEFINE_PRINT_FN(debug, 1)
  
++<<<<<<< HEAD
 +struct bpf_object *bpf__prepare_load(const char *filename)
++=======
+ struct bpf_prog_priv {
+ 	struct perf_probe_event pev;
+ };
+ 
+ static bool libbpf_initialized;
+ 
+ struct bpf_object *
+ bpf__prepare_load_buffer(void *obj_buf, size_t obj_buf_sz, const char *name)
+ {
+ 	struct bpf_object *obj;
+ 
+ 	if (!libbpf_initialized) {
+ 		libbpf_set_print(libbpf_warning,
+ 				 libbpf_info,
+ 				 libbpf_debug);
+ 		libbpf_initialized = true;
+ 	}
+ 
+ 	obj = bpf_object__open_buffer(obj_buf, obj_buf_sz, name);
+ 	if (IS_ERR(obj)) {
+ 		pr_debug("bpf: failed to load buffer\n");
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	return obj;
+ }
+ 
+ struct bpf_object *bpf__prepare_load(const char *filename, bool source)
++>>>>>>> ba1fae431e74 (perf test: Add 'perf test BPF')
  {
  	struct bpf_object *obj;
- 	static bool libbpf_initialized;
  
  	if (!libbpf_initialized) {
  		libbpf_set_print(libbpf_warning,
* Unmerged path tools/perf/tests/Build
diff --git a/tools/perf/tests/bpf.c b/tools/perf/tests/bpf.c
new file mode 100644
index 000000000000..ec16f7812c8b
--- /dev/null
+++ b/tools/perf/tests/bpf.c
@@ -0,0 +1,209 @@
+#include <stdio.h>
+#include <sys/epoll.h>
+#include <util/bpf-loader.h>
+#include <util/evlist.h>
+#include "tests.h"
+#include "llvm.h"
+#include "debug.h"
+#define NR_ITERS       111
+
+#ifdef HAVE_LIBBPF_SUPPORT
+
+static int epoll_pwait_loop(void)
+{
+	int i;
+
+	/* Should fail NR_ITERS times */
+	for (i = 0; i < NR_ITERS; i++)
+		epoll_pwait(-(i + 1), NULL, 0, 0, NULL);
+	return 0;
+}
+
+static struct {
+	enum test_llvm__testcase prog_id;
+	const char *desc;
+	const char *name;
+	const char *msg_compile_fail;
+	const char *msg_load_fail;
+	int (*target_func)(void);
+	int expect_result;
+} bpf_testcase_table[] = {
+	{
+		LLVM_TESTCASE_BASE,
+		"Test basic BPF filtering",
+		"[basic_bpf_test]",
+		"fix 'perf test LLVM' first",
+		"load bpf object failed",
+		&epoll_pwait_loop,
+		(NR_ITERS + 1) / 2,
+	},
+};
+
+static int do_test(struct bpf_object *obj, int (*func)(void),
+		   int expect)
+{
+	struct record_opts opts = {
+		.target = {
+			.uid = UINT_MAX,
+			.uses_mmap = true,
+		},
+		.freq	      = 0,
+		.mmap_pages   = 256,
+		.default_interval = 1,
+	};
+
+	char pid[16];
+	char sbuf[STRERR_BUFSIZE];
+	struct perf_evlist *evlist;
+	int i, ret = TEST_FAIL, err = 0, count = 0;
+
+	struct parse_events_evlist parse_evlist;
+	struct parse_events_error parse_error;
+
+	bzero(&parse_error, sizeof(parse_error));
+	bzero(&parse_evlist, sizeof(parse_evlist));
+	parse_evlist.error = &parse_error;
+	INIT_LIST_HEAD(&parse_evlist.list);
+
+	err = parse_events_load_bpf_obj(&parse_evlist, &parse_evlist.list, obj);
+	if (err || list_empty(&parse_evlist.list)) {
+		pr_debug("Failed to add events selected by BPF\n");
+		if (!err)
+			return TEST_FAIL;
+	}
+
+	snprintf(pid, sizeof(pid), "%d", getpid());
+	pid[sizeof(pid) - 1] = '\0';
+	opts.target.tid = opts.target.pid = pid;
+
+	/* Instead of perf_evlist__new_default, don't add default events */
+	evlist = perf_evlist__new();
+	if (!evlist) {
+		pr_debug("No ehough memory to create evlist\n");
+		return TEST_FAIL;
+	}
+
+	err = perf_evlist__create_maps(evlist, &opts.target);
+	if (err < 0) {
+		pr_debug("Not enough memory to create thread/cpu maps\n");
+		goto out_delete_evlist;
+	}
+
+	perf_evlist__splice_list_tail(evlist, &parse_evlist.list);
+	evlist->nr_groups = parse_evlist.nr_groups;
+
+	perf_evlist__config(evlist, &opts);
+
+	err = perf_evlist__open(evlist);
+	if (err < 0) {
+		pr_debug("perf_evlist__open: %s\n",
+			 strerror_r(errno, sbuf, sizeof(sbuf)));
+		goto out_delete_evlist;
+	}
+
+	err = perf_evlist__mmap(evlist, opts.mmap_pages, false);
+	if (err < 0) {
+		pr_debug("perf_evlist__mmap: %s\n",
+			 strerror_r(errno, sbuf, sizeof(sbuf)));
+		goto out_delete_evlist;
+	}
+
+	perf_evlist__enable(evlist);
+	(*func)();
+	perf_evlist__disable(evlist);
+
+	for (i = 0; i < evlist->nr_mmaps; i++) {
+		union perf_event *event;
+
+		while ((event = perf_evlist__mmap_read(evlist, i)) != NULL) {
+			const u32 type = event->header.type;
+
+			if (type == PERF_RECORD_SAMPLE)
+				count ++;
+		}
+	}
+
+	if (count != expect)
+		pr_debug("BPF filter result incorrect\n");
+
+	ret = TEST_OK;
+
+out_delete_evlist:
+	perf_evlist__delete(evlist);
+	return ret;
+}
+
+static struct bpf_object *
+prepare_bpf(void *obj_buf, size_t obj_buf_sz, const char *name)
+{
+	struct bpf_object *obj;
+
+	obj = bpf__prepare_load_buffer(obj_buf, obj_buf_sz, name);
+	if (IS_ERR(obj)) {
+		pr_debug("Compile BPF program failed.\n");
+		return NULL;
+	}
+	return obj;
+}
+
+static int __test__bpf(int index)
+{
+	int ret;
+	void *obj_buf;
+	size_t obj_buf_sz;
+	struct bpf_object *obj;
+
+	ret = test_llvm__fetch_bpf_obj(&obj_buf, &obj_buf_sz,
+				       bpf_testcase_table[index].prog_id,
+				       true);
+	if (ret != TEST_OK || !obj_buf || !obj_buf_sz) {
+		pr_debug("Unable to get BPF object, %s\n",
+			 bpf_testcase_table[index].msg_compile_fail);
+		if (index == 0)
+			return TEST_SKIP;
+		else
+			return TEST_FAIL;
+	}
+
+	obj = prepare_bpf(obj_buf, obj_buf_sz,
+			  bpf_testcase_table[index].name);
+	if (!obj) {
+		ret = TEST_FAIL;
+		goto out;
+	}
+
+	ret = do_test(obj,
+		      bpf_testcase_table[index].target_func,
+		      bpf_testcase_table[index].expect_result);
+out:
+	bpf__clear();
+	return ret;
+}
+
+int test__bpf(void)
+{
+	unsigned int i;
+	int err;
+
+	if (geteuid() != 0) {
+		pr_debug("Only root can run BPF test\n");
+		return TEST_SKIP;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(bpf_testcase_table); i++) {
+		err = __test__bpf(i);
+
+		if (err != TEST_OK)
+			return err;
+	}
+
+	return TEST_OK;
+}
+
+#else
+int test__bpf(void)
+{
+	pr_debug("Skip BPF test because BPF support is not compiled\n");
+	return TEST_SKIP;
+}
+#endif
diff --git a/tools/perf/tests/builtin-test.c b/tools/perf/tests/builtin-test.c
index aacfc58dac2b..4bc0574ddf43 100644
--- a/tools/perf/tests/builtin-test.c
+++ b/tools/perf/tests/builtin-test.c
@@ -242,6 +242,10 @@ static struct test generic_tests[] = {
 		.desc = "unit_number__scnprintf",
 		.func = test__unit_number__scnprint,
 	},
+	{
+		.desc = "Test BPF filter",
+		.func = test__bpf,
+	},
 	{
 		.func = NULL,
 	},
* Unmerged path tools/perf/tests/tests.h
* Unmerged path tools/perf/util/bpf-loader.c
diff --git a/tools/perf/util/bpf-loader.h b/tools/perf/util/bpf-loader.h
index f402d7c8c288..88b36859a0a7 100644
--- a/tools/perf/util/bpf-loader.h
+++ b/tools/perf/util/bpf-loader.h
@@ -15,6 +15,9 @@ struct bpf_object;
 #ifdef HAVE_LIBBPF_SUPPORT
 struct bpf_object *bpf__prepare_load(const char *filename);
 
+struct bpf_object *bpf__prepare_load_buffer(void *obj_buf, size_t obj_buf_sz,
+					    const char *name);
+
 void bpf__clear(void);
 #else
 static inline struct bpf_object *
@@ -24,6 +27,13 @@ bpf__prepare_load(const char *filename __maybe_unused)
 	return ERR_PTR(-ENOTSUP);
 }
 
+static inline struct bpf_object *
+bpf__prepare_load_buffer(void *obj_buf __maybe_unused,
+					   size_t obj_buf_sz __maybe_unused)
+{
+	return ERR_PTR(-ENOTSUP);
+}
+
 static inline void bpf__clear(void) { }
 #endif
 #endif
