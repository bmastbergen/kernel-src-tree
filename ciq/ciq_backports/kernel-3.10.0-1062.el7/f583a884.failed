watchdog: iTCO_wdt: cleanup set/unset no_reboot_bit functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [watchdog] itco_wdt: cleanup set/unset no_reboot_bit functions (David Arcari) [1645537]
Rebuild_FUZZ: 91.07%
commit-author Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
commit f583a884afecb16fcb8200ebb9956ea369aff57f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f583a884.failed

iTCO_wdt no_reboot_bit set/unset functions has lot of common code between
them. So merging these two functions into a single update function would
remove these unnecessary code duplications. This patch fixes this issue
by creating a no_reboot_bit update function to handle both set/unset
functions.

Also checking for iTCO version every time you make no_reboot_bit set/unset
call is inefficient and makes the code look complex. This can be improved
by performing this check once during device probe and selecting the
appropriate no_reboot_bit update function. This patch fixes this issue
by splitting the update function into multiple helper functions.

	Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
	Reviewed-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
(cherry picked from commit f583a884afecb16fcb8200ebb9956ea369aff57f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/watchdog/iTCO_wdt.c
diff --cc drivers/watchdog/iTCO_wdt.c
index 8dfafe4078c8,a62993381c52..000000000000
--- a/drivers/watchdog/iTCO_wdt.c
+++ b/drivers/watchdog/iTCO_wdt.c
@@@ -102,12 -102,13 +102,18 @@@ static struct {		/* this is private dat
  	unsigned long __iomem *gcs_pmc;
  	/* the lock for io operations */
  	spinlock_t io_lock;
 +	struct platform_device *dev;
  	/* the PCI-device */
 -	struct pci_dev *pci_dev;
 +	struct pci_dev *pdev;
  	/* whether or not the watchdog has been suspended */
  	bool suspended;
++<<<<<<< HEAD
 +} iTCO_wdt_private;
++=======
+ 	/* no reboot update function pointer */
+ 	int (*update_no_reboot_bit)(void *p, bool set);
+ };
++>>>>>>> f583a884afec (watchdog: iTCO_wdt: cleanup set/unset no_reboot_bit functions)
  
  /* module parameters */
  #define WATCHDOG_TIMEOUT 30	/* 30 sec default heartbeat */
@@@ -169,59 -172,73 +175,117 @@@ static inline u32 no_reboot_bit(void
  	return enable_bit;
  }
  
++<<<<<<< HEAD
 +static void iTCO_wdt_set_NO_REBOOT_bit(void)
 +{
 +	u32 val32;
 +
 +	/* Set the NO_REBOOT bit: this disables reboots */
 +	if (iTCO_wdt_private.iTCO_version >= 2) {
 +		val32 = readl(iTCO_wdt_private.gcs_pmc);
 +		val32 |= no_reboot_bit();
 +		writel(val32, iTCO_wdt_private.gcs_pmc);
 +	} else if (iTCO_wdt_private.iTCO_version == 1) {
 +		pci_read_config_dword(iTCO_wdt_private.pdev, 0xd4, &val32);
 +		val32 |= no_reboot_bit();
 +		pci_write_config_dword(iTCO_wdt_private.pdev, 0xd4, val32);
 +	}
 +}
 +
 +static int iTCO_wdt_unset_NO_REBOOT_bit(void)
 +{
 +	u32 enable_bit = no_reboot_bit();
 +	u32 val32 = 0;
 +
 +	/* Unset the NO_REBOOT bit: this enables reboots */
 +	if (iTCO_wdt_private.iTCO_version >= 2) {
 +		val32 = readl(iTCO_wdt_private.gcs_pmc);
 +		val32 &= ~enable_bit;
 +		writel(val32, iTCO_wdt_private.gcs_pmc);
 +
 +		val32 = readl(iTCO_wdt_private.gcs_pmc);
 +	} else if (iTCO_wdt_private.iTCO_version == 1) {
 +		pci_read_config_dword(iTCO_wdt_private.pdev, 0xd4, &val32);
 +		val32 &= ~enable_bit;
 +		pci_write_config_dword(iTCO_wdt_private.pdev, 0xd4, val32);
 +
 +		pci_read_config_dword(iTCO_wdt_private.pdev, 0xd4, &val32);
 +	}
 +
 +	if (val32 & enable_bit)
++=======
+ static int update_no_reboot_bit_def(void *priv, bool set)
+ {
+ 	return 0;
+ }
+ 
+ static int update_no_reboot_bit_pci(void *priv, bool set)
+ {
+ 	struct iTCO_wdt_private *p = priv;
+ 	u32 val32 = 0, newval32 = 0;
+ 
+ 	pci_read_config_dword(p->pci_dev, 0xd4, &val32);
+ 	if (set)
+ 		val32 |= no_reboot_bit(p);
+ 	else
+ 		val32 &= ~no_reboot_bit(p);
+ 	pci_write_config_dword(p->pci_dev, 0xd4, val32);
+ 	pci_read_config_dword(p->pci_dev, 0xd4, &newval32);
+ 
+ 	/* make sure the update is successful */
+ 	if (val32 != newval32)
++>>>>>>> f583a884afec (watchdog: iTCO_wdt: cleanup set/unset no_reboot_bit functions)
+ 		return -EIO;
+ 
+ 	return 0;
+ }
+ 
+ static int update_no_reboot_bit_mem(void *priv, bool set)
+ {
+ 	struct iTCO_wdt_private *p = priv;
+ 	u32 val32 = 0, newval32 = 0;
+ 
+ 	val32 = readl(p->gcs_pmc);
+ 	if (set)
+ 		val32 |= no_reboot_bit(p);
+ 	else
+ 		val32 &= ~no_reboot_bit(p);
+ 	writel(val32, p->gcs_pmc);
+ 	newval32 = readl(p->gcs_pmc);
+ 
+ 	/* make sure the update is successful */
+ 	if (val32 != newval32)
  		return -EIO;
  
  	return 0;
  }
  
+ static void iTCO_wdt_no_reboot_bit_setup(struct iTCO_wdt_private *p)
+ {
+ 	if (p->iTCO_version >= 2)
+ 		p->update_no_reboot_bit = update_no_reboot_bit_mem;
+ 	else if (p->iTCO_version == 1)
+ 		p->update_no_reboot_bit = update_no_reboot_bit_pci;
+ 	else
+ 		p->update_no_reboot_bit = update_no_reboot_bit_def;
+ }
+ 
  static int iTCO_wdt_start(struct watchdog_device *wd_dev)
  {
 -	struct iTCO_wdt_private *p = watchdog_get_drvdata(wd_dev);
  	unsigned int val;
  
 -	spin_lock(&p->io_lock);
 +	spin_lock(&iTCO_wdt_private.io_lock);
  
 -	iTCO_vendor_pre_start(p->smi_res, wd_dev->timeout);
 +	iTCO_vendor_pre_start(iTCO_wdt_private.smi_res, wd_dev->timeout);
  
  	/* disable chipset's NO_REBOOT bit */
++<<<<<<< HEAD
 +	if (iTCO_wdt_unset_NO_REBOOT_bit()) {
 +		spin_unlock(&iTCO_wdt_private.io_lock);
++=======
+ 	if (p->update_no_reboot_bit(p, false)) {
+ 		spin_unlock(&p->io_lock);
++>>>>>>> f583a884afec (watchdog: iTCO_wdt: cleanup set/unset no_reboot_bit functions)
  		pr_err("failed to reset NO_REBOOT flag, reboot disabled by hardware/BIOS\n");
  		return -EIO;
  	}
@@@ -247,22 -264,23 +311,26 @@@
  
  static int iTCO_wdt_stop(struct watchdog_device *wd_dev)
  {
 -	struct iTCO_wdt_private *p = watchdog_get_drvdata(wd_dev);
  	unsigned int val;
  
 -	spin_lock(&p->io_lock);
 +	spin_lock(&iTCO_wdt_private.io_lock);
  
 -	iTCO_vendor_pre_stop(p->smi_res);
 +	iTCO_vendor_pre_stop(iTCO_wdt_private.smi_res);
  
  	/* Bit 11: TCO Timer Halt -> 1 = The TCO timer is disabled */
 -	val = inw(TCO1_CNT(p));
 +	val = inw(TCO1_CNT);
  	val |= 0x0800;
 -	outw(val, TCO1_CNT(p));
 -	val = inw(TCO1_CNT(p));
 +	outw(val, TCO1_CNT);
 +	val = inw(TCO1_CNT);
  
  	/* Set the NO_REBOOT bit to prevent later reboots, just for sure */
++<<<<<<< HEAD
 +	iTCO_wdt_set_NO_REBOOT_bit();
++=======
+ 	p->update_no_reboot_bit(p, true);
++>>>>>>> f583a884afec (watchdog: iTCO_wdt: cleanup set/unset no_reboot_bit functions)
  
 -	spin_unlock(&p->io_lock);
 +	spin_unlock(&iTCO_wdt_private.io_lock);
  
  	if ((val & 0x0800) == 0)
  		return -1;
@@@ -398,57 -415,36 +466,59 @@@ static struct watchdog_device iTCO_wdt_
   *	Init & exit routines
   */
  
 -static int iTCO_wdt_probe(struct platform_device *pdev)
 +static void iTCO_wdt_cleanup(void)
 +{
 +	/* Stop the timer before we leave */
 +	if (!nowayout)
 +		iTCO_wdt_stop(&iTCO_wdt_watchdog_dev);
 +
 +	/* Deregister */
 +	watchdog_unregister_device(&iTCO_wdt_watchdog_dev);
 +
 +	/* release resources */
 +	release_region(iTCO_wdt_private.tco_res->start,
 +			resource_size(iTCO_wdt_private.tco_res));
 +	release_region(iTCO_wdt_private.smi_res->start,
 +			resource_size(iTCO_wdt_private.smi_res));
 +	if (iTCO_wdt_private.iTCO_version >= 2) {
 +		iounmap(iTCO_wdt_private.gcs_pmc);
 +		release_mem_region(iTCO_wdt_private.gcs_pmc_res->start,
 +				resource_size(iTCO_wdt_private.gcs_pmc_res));
 +	}
 +
 +	iTCO_wdt_private.tco_res = NULL;
 +	iTCO_wdt_private.smi_res = NULL;
 +	iTCO_wdt_private.gcs_pmc_res = NULL;
 +	iTCO_wdt_private.gcs_pmc = NULL;
 +}
 +
 +static int iTCO_wdt_probe(struct platform_device *dev)
  {
 -	struct device *dev = &pdev->dev;
 -	struct itco_wdt_platform_data *pdata = dev_get_platdata(dev);
 -	struct iTCO_wdt_private *p;
 +	int ret = -ENODEV;
  	unsigned long val32;
 -	int ret;
 +	struct itco_wdt_platform_data *pdata = dev->dev.platform_data;
  
  	if (!pdata)
 -		return -ENODEV;
 -
 -	p = devm_kzalloc(dev, sizeof(*p), GFP_KERNEL);
 -	if (!p)
 -		return -ENOMEM;
 +		goto out;
  
 -	spin_lock_init(&p->io_lock);
 +	spin_lock_init(&iTCO_wdt_private.io_lock);
  
 -	p->tco_res = platform_get_resource(pdev, IORESOURCE_IO, ICH_RES_IO_TCO);
 -	if (!p->tco_res)
 -		return -ENODEV;
 +	iTCO_wdt_private.tco_res =
 +		platform_get_resource(dev, IORESOURCE_IO, ICH_RES_IO_TCO);
 +	if (!iTCO_wdt_private.tco_res)
 +		goto out;
  
 -	p->smi_res = platform_get_resource(pdev, IORESOURCE_IO, ICH_RES_IO_SMI);
 -	if (!p->smi_res)
 -		return -ENODEV;
 +	iTCO_wdt_private.smi_res =
 +		platform_get_resource(dev, IORESOURCE_IO, ICH_RES_IO_SMI);
 +	if (!iTCO_wdt_private.smi_res)
 +		goto out;
  
 -	p->iTCO_version = pdata->version;
 -	p->pci_dev = to_pci_dev(dev->parent);
 +	iTCO_wdt_private.iTCO_version = pdata->version;
 +	iTCO_wdt_private.dev = dev;
 +	iTCO_wdt_private.pdev = to_pci_dev(dev->dev.parent);
  
+ 	iTCO_wdt_no_reboot_bit_setup(p);
+ 
  	/*
  	 * Get the Memory-Mapped GCS or PMC register, we need it for the
  	 * NO_REBOOT flag (TCO v2 and v3).
@@@ -475,24 -459,24 +545,33 @@@
  	}
  
  	/* Check chipset's NO_REBOOT bit */
++<<<<<<< HEAD
 +	if (iTCO_wdt_unset_NO_REBOOT_bit() && iTCO_vendor_check_noreboot_on()) {
++=======
+ 	if (p->update_no_reboot_bit(p, false) &&
+ 	    iTCO_vendor_check_noreboot_on()) {
++>>>>>>> f583a884afec (watchdog: iTCO_wdt: cleanup set/unset no_reboot_bit functions)
  		pr_info("unable to reset NO_REBOOT flag, device disabled by hardware/BIOS\n");
 -		return -ENODEV;	/* Cannot reset NO_REBOOT bit */
 +		ret = -ENODEV;	/* Cannot reset NO_REBOOT bit */
 +		goto unmap_gcs_pmc;
  	}
  
  	/* Set the NO_REBOOT bit to prevent later reboots, just for sure */
++<<<<<<< HEAD
 +	iTCO_wdt_set_NO_REBOOT_bit();
++=======
+ 	p->update_no_reboot_bit(p, true);
++>>>>>>> f583a884afec (watchdog: iTCO_wdt: cleanup set/unset no_reboot_bit functions)
  
  	/* The TCO logic uses the TCO_EN bit in the SMI_EN register */
 -	if (!devm_request_region(dev, p->smi_res->start,
 -				 resource_size(p->smi_res),
 -				 pdev->name)) {
 +	if (!request_region(iTCO_wdt_private.smi_res->start,
 +			resource_size(iTCO_wdt_private.smi_res), dev->name)) {
  		pr_err("I/O address 0x%04llx already in use, device disabled\n",
 -		       (u64)SMI_EN(p));
 -		return -EBUSY;
 +		       (u64)SMI_EN);
 +		ret = -EBUSY;
 +		goto unmap_gcs_pmc;
  	}
 -	if (turn_SMI_watchdog_clear_off >= p->iTCO_version) {
 +	if (turn_SMI_watchdog_clear_off >= iTCO_wdt_private.iTCO_version) {
  		/*
  		 * Bit 13: TCO_EN -> 0
  		 * Disables TCO logic generating an SMI#
* Unmerged path drivers/watchdog/iTCO_wdt.c
