RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit 3a6532c9af1a7836da2d597f1aaca73cb16c3b97
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3a6532c9.failed

Now that we have metadata describing the command format the core code can
directly compute the udata pointers and all the really ugly
ib_uverbs_init_udata() calls can be removed from the handlers.

This means all the write() handlers are no longer sensitive to the layout
of the command buffer.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 3a6532c9af1a7836da2d597f1aaca73cb16c3b97)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/uverbs_main.c
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 507521d53e3f,8ee9e94e25fe..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -90,15 -97,14 +90,23 @@@ ssize_t ib_uverbs_get_context(struct ib
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	ucontext = ib_dev->alloc_ucontext(ib_dev, &udata);
++=======
+ 	ret = ib_rdmacg_try_charge(&cg_obj, ib_dev, RDMACG_RESOURCE_HCA_HANDLE);
+ 	if (ret)
+ 		goto err;
+ 
+ 	ucontext = ib_dev->alloc_ucontext(ib_dev, &attrs->driver_udata);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  	if (IS_ERR(ucontext)) {
  		ret = PTR_ERR(ucontext);
 -		goto err_alloc;
 +		goto err;
  	}
  
  	ucontext->device = ib_dev;
@@@ -308,12 -347,7 +316,16 @@@ ssize_t ib_uverbs_alloc_pd(struct ib_uv
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +                   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +                   out_len - sizeof(resp));
 +
 +	uobj  = uobj_alloc(UVERBS_OBJECT_PD, file->ucontext);
++=======
+ 	uobj = uobj_alloc(UVERBS_OBJECT_PD, attrs, &ib_dev);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -471,12 -499,7 +483,16 @@@ ssize_t ib_uverbs_open_xrcd(struct ib_u
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +                   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +                   out_len - sizeof(resp));
 +
 +	mutex_lock(&file->device->xrcd_tree_mutex);
++=======
+ 	mutex_lock(&ibudev->xrcd_tree_mutex);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  
  	if (cmd.fd != -1) {
  		/* search for file descriptor */
@@@ -627,11 -648,6 +643,14 @@@ ssize_t ib_uverbs_reg_mr(struct ib_uver
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +                   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +                   out_len - sizeof(resp));
 +
++=======
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  	if ((cmd.start & ~PAGE_MASK) != (cmd.hca_va & ~PAGE_MASK))
  		return -EINVAL;
  
@@@ -720,11 -733,6 +739,14 @@@ ssize_t ib_uverbs_rereg_mr(struct ib_uv
  	if (copy_from_user(&cmd, buf, sizeof(cmd)))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +                   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +                   out_len - sizeof(resp));
 +
++=======
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  	if (cmd.flags & ~IB_MR_REREG_SUPPORTED || !cmd.flags)
  		return -EINVAL;
  
@@@ -835,12 -838,7 +857,16 @@@ ssize_t ib_uverbs_alloc_mw(struct ib_uv
  		goto err_free;
  	}
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	mw = pd->device->alloc_mw(pd, cmd.mw_type, &udata);
++=======
+ 	mw = pd->device->alloc_mw(pd, cmd.mw_type, &attrs->driver_udata);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  	if (IS_ERR(mw)) {
  		ret = PTR_ERR(mw);
  		goto err_put;
@@@ -1054,11 -1040,6 +1080,14 @@@ ssize_t ib_uverbs_create_cq(struct ib_u
  	ib_uverbs_init_udata(&ucore, buf, u64_to_user_ptr(cmd.response),
  			     sizeof(cmd), sizeof(resp));
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&uhw, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
++=======
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  	memset(&cmd_ex, 0, sizeof(cmd_ex));
  	cmd_ex.user_handle = cmd.user_handle;
  	cmd_ex.cqe = cmd.cqe;
@@@ -1135,12 -1110,7 +1164,16 @@@ ssize_t ib_uverbs_resize_cq(struct ib_u
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, file->ucontext);
++=======
+ 	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  	if (!cq)
  		return -EINVAL;
  
@@@ -1615,10 -1561,6 +1648,13 @@@ ssize_t ib_uverbs_create_qp(struct ib_u
  
  	ib_uverbs_init_udata(&ucore, buf, u64_to_user_ptr(cmd.response),
  		   sizeof(cmd), resp_size);
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&uhw, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + resp_size,
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - resp_size);
++=======
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  
  	memset(&cmd_ex, 0, sizeof(cmd_ex));
  	cmd_ex.user_handle = cmd.user_handle;
@@@ -1713,13 -1651,8 +1749,18 @@@ ssize_t ib_uverbs_open_qp(struct ib_uve
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	obj  = (struct ib_uqp_object *)uobj_alloc(UVERBS_OBJECT_QP,
 +						  file->ucontext);
++=======
+ 	obj = (struct ib_uqp_object *)uobj_alloc(UVERBS_OBJECT_QP, attrs,
+ 						 &ib_dev);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  	if (IS_ERR(obj))
  		return PTR_ERR(obj);
  
@@@ -2094,21 -2018,11 +2135,25 @@@ ssize_t ib_uverbs_modify_qp(struct ib_u
  	    ~((IB_USER_LEGACY_LAST_QP_ATTR_MASK << 1) - 1))
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd.base), NULL,
 +		   in_len - sizeof(cmd.base) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len);
 +
 +	ret = modify_qp(file, &cmd, &udata);
 +	if (ret)
 +		return ret;
 +
 +	return in_len;
++=======
+ 	return modify_qp(attrs, &cmd);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  }
  
 -static int ib_uverbs_ex_modify_qp(struct uverbs_attr_bundle *attrs,
 -				  struct ib_udata *ucore)
 +int ib_uverbs_ex_modify_qp(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   struct ib_udata *ucore,
 +			   struct ib_udata *uhw)
  {
  	struct ib_uverbs_ex_modify_qp cmd = {};
  	int ret;
@@@ -2593,15 -2486,7 +2638,19 @@@ ssize_t ib_uverbs_create_ah(struct ib_u
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	if (!rdma_is_port_valid(ib_dev, cmd.attr.port_num))
 +		return -EINVAL;
 +
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	uobj  = uobj_alloc(UVERBS_OBJECT_AH, file->ucontext);
++=======
+ 	uobj = uobj_alloc(UVERBS_OBJECT_AH, attrs, &ib_dev);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -3857,21 -3688,12 +3906,25 @@@ ssize_t ib_uverbs_create_srq(struct ib_
  	xcmd.max_sge	 = cmd.max_sge;
  	xcmd.srq_limit	 = cmd.srq_limit;
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	ret = __uverbs_create_xsrq(file, ib_dev, &xcmd, &udata);
 +	if (ret)
 +		return ret;
 +
 +	return in_len;
++=======
+ 	return __uverbs_create_xsrq(attrs, &xcmd, &attrs->driver_udata);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  }
  
 -static int ib_uverbs_create_xsrq(struct uverbs_attr_bundle *attrs,
 -				 const char __user *buf, int in_len,
 -				 int out_len)
 +ssize_t ib_uverbs_create_xsrq(struct ib_uverbs_file *file,
 +			      struct ib_device *ib_dev,
 +			      const char __user *buf, int in_len, int out_len)
  {
  	struct ib_uverbs_create_xsrq     cmd;
  	struct ib_uverbs_create_srq_resp resp;
@@@ -3884,25 -3704,13 +3937,29 @@@
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	ret = __uverbs_create_xsrq(file, ib_dev, &cmd, &udata);
 +	if (ret)
 +		return ret;
 +
 +	return in_len;
++=======
+ 	return __uverbs_create_xsrq(attrs, &cmd, &attrs->driver_udata);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  }
  
 -static int ib_uverbs_modify_srq(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_modify_srq(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
  {
  	struct ib_uverbs_modify_srq cmd;
 +	struct ib_udata             udata;
  	struct ib_srq              *srq;
  	struct ib_srq_attr          attr;
  	int                         ret;
@@@ -3910,10 -3718,7 +3967,14 @@@
  	if (copy_from_user(&cmd, buf, sizeof cmd))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	ib_uverbs_init_udata(&udata, buf + sizeof cmd, NULL, in_len - sizeof cmd,
 +		   out_len);
 +
 +	srq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, file->ucontext);
++=======
+ 	srq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, attrs);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  	if (!srq)
  		return -EINVAL;
  
diff --cc drivers/infiniband/core/uverbs_main.c
index 8cc3600913c7,be049546cee2..000000000000
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@@ -776,13 -691,55 +776,63 @@@ static ssize_t ib_uverbs_write(struct f
  
  	buf += sizeof(hdr);
  
++<<<<<<< HEAD
 +	if (!extended) {
 +		ret = uverbs_cmd_table[command](file, ib_dev, buf,
 +						hdr.in_words * 4,
 +						hdr.out_words * 4);
++=======
+ 	bundle.ufile = file;
+ 	if (!method_elm->is_ex) {
+ 		size_t in_len = hdr.in_words * 4 - sizeof(hdr);
+ 		size_t out_len = hdr.out_words * 4;
+ 
+ 		if (method_elm->has_udata) {
+ 			bundle.driver_udata.inlen =
+ 				in_len - method_elm->req_size;
+ 			in_len = method_elm->req_size;
+ 			if (bundle.driver_udata.inlen)
+ 				bundle.driver_udata.inbuf = buf + in_len;
+ 			else
+ 				bundle.driver_udata.inbuf = NULL;
+ 		} else {
+ 			memset(&bundle.driver_udata, 0,
+ 			       sizeof(bundle.driver_udata));
+ 		}
+ 
+ 		if (method_elm->has_resp) {
+ 			u64 response;
+ 
+ 			/*
+ 			 * The macros check that if has_resp is set
+ 			 * then the command request structure starts
+ 			 * with a '__aligned u64 response' member.
+ 			 */
+ 			ret = get_user(response, (const u64 *)buf);
+ 			if (ret)
+ 				goto out_unlock;
+ 
+ 			if (method_elm->has_udata) {
+ 				bundle.driver_udata.outlen =
+ 					out_len - method_elm->resp_size;
+ 				out_len = method_elm->resp_size;
+ 				if (bundle.driver_udata.outlen)
+ 					bundle.driver_udata.outbuf =
+ 						u64_to_user_ptr(response +
+ 								out_len);
+ 				else
+ 					bundle.driver_udata.outbuf = NULL;
+ 			}
+ 		} else {
+ 			bundle.driver_udata.outlen = 0;
+ 			bundle.driver_udata.outbuf = NULL;
+ 		}
+ 
+ 		ret = method_elm->handler(&bundle, buf, in_len, out_len);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  	} else {
  		struct ib_udata ucore;
 +		struct ib_udata uhw;
  
  		buf += sizeof(ex_hdr);
  
@@@ -796,10 -753,29 +846,33 @@@
  					ex_hdr.provider_in_words * 8,
  					ex_hdr.provider_out_words * 8);
  
 -		ret = method_elm->handler_ex(&bundle, &ucore);
 +		ret = uverbs_ex_cmd_table[command](file, ib_dev, &ucore, &uhw);
 +		ret = (ret) ? : count;
  	}
  
++<<<<<<< HEAD
++=======
+ out_unlock:
+ 	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
+ 	return (ret) ? : count;
+ }
+ 
+ static int ib_uverbs_mmap(struct file *filp, struct vm_area_struct *vma)
+ {
+ 	struct ib_uverbs_file *file = filp->private_data;
+ 	struct ib_ucontext *ucontext;
+ 	int ret = 0;
+ 	int srcu_key;
+ 
+ 	srcu_key = srcu_read_lock(&file->device->disassociate_srcu);
+ 	ucontext = ib_uverbs_get_ucontext_file(file);
+ 	if (IS_ERR(ucontext)) {
+ 		ret = PTR_ERR(ucontext);
+ 		goto out;
+ 	}
+ 
+ 	ret = ucontext->device->mmap(ucontext, vma);
++>>>>>>> 3a6532c9af1a (RDMA/uverbs: Use uverbs_attr_bundle to pass udata for write)
  out:
  	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
  	return ret;
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path drivers/infiniband/core/uverbs_main.c
