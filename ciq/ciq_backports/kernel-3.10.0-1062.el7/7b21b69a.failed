IB/uverbs: Fix OOPs in uverbs_user_mmap_disassociate

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Yishai Hadas <yishaih@mellanox.com>
commit 7b21b69ab203136fdc153c7707fa6c409e523c2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7b21b69a.failed

The vma->vm_mm can become impossible to get before rdma_umap_close() is
called, in this case we must not try to get an mm that is already
undergoing process exit. In this case there is no need to wait for
anything as the VMA will be destroyed by another thread soon and is
already effectively 'unreachable' by userspace.

 BUG: unable to handle kernel NULL pointer dereference at 0000000000000000
 PGD 800000012bc50067 P4D 800000012bc50067 PUD 129db5067 PMD 0
 Oops: 0000 [#1] SMP PTI
 CPU: 1 PID: 2050 Comm: bash Tainted: G        W  OE 4.20.0-rc6+ #3
 Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011
 RIP: 0010:__rb_erase_color+0xb9/0x280
 Code: 84 17 01 00 00 48 3b 68 10 0f 84 15 01 00 00 48 89
               58 08 48 89 de 48 89 ef 4c 89 e3 e8 90 84 22 00 e9 60 ff ff ff 48 8b 5d
               10 <f6> 03 01 0f 84 9c 00 00 00 48 8b 43 10 48 85 c0 74 09 f6 00 01 0f
 RSP: 0018:ffffbecfc090bab8 EFLAGS: 00010246
 RAX: ffff97616346cf30 RBX: 0000000000000000 RCX: 0000000000000101
 RDX: 0000000000000000 RSI: ffff97623b6ca828 RDI: ffff97621ef10828
 RBP: ffff97621ef10828 R08: ffff97621ef10828 R09: 0000000000000000
 R10: 0000000000000000 R11: 0000000000000000 R12: ffff97623b6ca838
 R13: ffffffffbb3fef50 R14: ffff97623b6ca828 R15: 0000000000000000
 FS:  00007f7a5c31d740(0000) GS:ffff97623bb00000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 0000000000000000 CR3: 000000011255a000 CR4: 00000000000006e0
 Call Trace:
  unlink_file_vma+0x3b/0x50
  free_pgtables+0xa1/0x110
  exit_mmap+0xca/0x1a0
  ? mlx5_ib_dealloc_pd+0x28/0x30 [mlx5_ib]
  mmput+0x54/0x140
  uverbs_user_mmap_disassociate+0xcc/0x160 [ib_uverbs]
  uverbs_destroy_ufile_hw+0xf7/0x120 [ib_uverbs]
  ib_uverbs_remove_one+0xea/0x240 [ib_uverbs]
  ib_unregister_device+0xfb/0x200 [ib_core]
  mlx5_ib_remove+0x51/0xe0 [mlx5_ib]
  mlx5_remove_device+0xc1/0xd0 [mlx5_core]
  mlx5_unregister_device+0x3d/0xb0 [mlx5_core]
  remove_one+0x2a/0x90 [mlx5_core]
  pci_device_remove+0x3b/0xc0
  device_release_driver_internal+0x16d/0x240
  unbind_store+0xb2/0x100
  kernfs_fop_write+0x102/0x180
  __vfs_write+0x36/0x1a0
  ? __alloc_fd+0xa9/0x170
  ? set_close_on_exec+0x49/0x70
  vfs_write+0xad/0x1a0
  ksys_write+0x52/0xc0
  do_syscall_64+0x5b/0x180
  entry_SYSCALL_64_after_hwframe+0x44/0xa9

	Cc: <stable@vger.kernel.org> # 4.19
Fixes: 5f9794dc94f5 ("RDMA/ucontext: Add a core API for mmaping driver IO memory")
	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 7b21b69ab203136fdc153c7707fa6c409e523c2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_main.c
diff --cc drivers/infiniband/core/uverbs_main.c
index 8cc3600913c7,5f366838b7ff..000000000000
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@@ -820,13 -777,238 +820,103 @@@ static int ib_uverbs_mmap(struct file *
  		goto out;
  	}
  
 -	ret = ucontext->device->ops.mmap(ucontext, vma);
++<<<<<<< HEAD
 +	if (!file->ucontext)
 +		ret = -ENODEV;
 +	else
 +		ret = ib_dev->mmap(file->ucontext, vma);
  out:
  	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
  	return ret;
 -}
 -
 -/*
 - * Each time we map IO memory into user space this keeps track of the mapping.
 - * When the device is hot-unplugged we 'zap' the mmaps in user space to point
 - * to the zero page and allow the hot unplug to proceed.
 - *
 - * This is necessary for cases like PCI physical hot unplug as the actual BAR
 - * memory may vanish after this and access to it from userspace could MCE.
 - *
 - * RDMA drivers supporting disassociation must have their user space designed
 - * to cope in some way with their IO pages going to the zero page.
 - */
 -struct rdma_umap_priv {
 -	struct vm_area_struct *vma;
 -	struct list_head list;
 -};
 -
 -static const struct vm_operations_struct rdma_umap_ops;
 -
 -static void rdma_umap_priv_init(struct rdma_umap_priv *priv,
 -				struct vm_area_struct *vma)
 -{
 -	struct ib_uverbs_file *ufile = vma->vm_file->private_data;
 -
 -	priv->vma = vma;
 -	vma->vm_private_data = priv;
 -	vma->vm_ops = &rdma_umap_ops;
 -
 -	mutex_lock(&ufile->umap_lock);
 -	list_add(&priv->list, &ufile->umaps);
 -	mutex_unlock(&ufile->umap_lock);
 -}
 -
 -/*
 - * The VMA has been dup'd, initialize the vm_private_data with a new tracking
 - * struct
 - */
 -static void rdma_umap_open(struct vm_area_struct *vma)
 -{
 -	struct ib_uverbs_file *ufile = vma->vm_file->private_data;
 -	struct rdma_umap_priv *opriv = vma->vm_private_data;
 -	struct rdma_umap_priv *priv;
 -
 -	if (!opriv)
 -		return;
 -
 -	/* We are racing with disassociation */
 -	if (!down_read_trylock(&ufile->hw_destroy_rwsem))
 -		goto out_zap;
 -	/*
 -	 * Disassociation already completed, the VMA should already be zapped.
 -	 */
 -	if (!ufile->ucontext)
 -		goto out_unlock;
 -
 -	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 -	if (!priv)
 -		goto out_unlock;
 -	rdma_umap_priv_init(priv, vma);
 -
 -	up_read(&ufile->hw_destroy_rwsem);
 -	return;
 -
 -out_unlock:
 -	up_read(&ufile->hw_destroy_rwsem);
 -out_zap:
 -	/*
 -	 * We can't allow the VMA to be created with the actual IO pages, that
 -	 * would break our API contract, and it can't be stopped at this
 -	 * point, so zap it.
 -	 */
 -	vma->vm_private_data = NULL;
 -	zap_vma_ptes(vma, vma->vm_start, vma->vm_end - vma->vm_start);
 -}
 -
 -static void rdma_umap_close(struct vm_area_struct *vma)
 -{
 -	struct ib_uverbs_file *ufile = vma->vm_file->private_data;
 -	struct rdma_umap_priv *priv = vma->vm_private_data;
 -
 -	if (!priv)
 -		return;
 -
 -	/*
 -	 * The vma holds a reference on the struct file that created it, which
 -	 * in turn means that the ib_uverbs_file is guaranteed to exist at
 -	 * this point.
 -	 */
 -	mutex_lock(&ufile->umap_lock);
 -	list_del(&priv->list);
 -	mutex_unlock(&ufile->umap_lock);
 -	kfree(priv);
 -}
 -
 -static const struct vm_operations_struct rdma_umap_ops = {
 -	.open = rdma_umap_open,
 -	.close = rdma_umap_close,
 -};
 -
 -static struct rdma_umap_priv *rdma_user_mmap_pre(struct ib_ucontext *ucontext,
 -						 struct vm_area_struct *vma,
 -						 unsigned long size)
 -{
 -	struct ib_uverbs_file *ufile = ucontext->ufile;
 -	struct rdma_umap_priv *priv;
 -
 -	if (vma->vm_end - vma->vm_start != size)
 -		return ERR_PTR(-EINVAL);
 -
 -	/* Driver is using this wrong, must be called by ib_uverbs_mmap */
 -	if (WARN_ON(!vma->vm_file ||
 -		    vma->vm_file->private_data != ufile))
 -		return ERR_PTR(-EINVAL);
 -	lockdep_assert_held(&ufile->device->disassociate_srcu);
 -
 -	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 -	if (!priv)
 -		return ERR_PTR(-ENOMEM);
 -	return priv;
 -}
 -
 -/*
 - * Map IO memory into a process. This is to be called by drivers as part of
 - * their mmap() functions if they wish to send something like PCI-E BAR memory
 - * to userspace.
 - */
 -int rdma_user_mmap_io(struct ib_ucontext *ucontext, struct vm_area_struct *vma,
 -		      unsigned long pfn, unsigned long size, pgprot_t prot)
 -{
 -	struct rdma_umap_priv *priv = rdma_user_mmap_pre(ucontext, vma, size);
 -
 -	if (IS_ERR(priv))
 -		return PTR_ERR(priv);
 -
 -	vma->vm_page_prot = prot;
 -	if (io_remap_pfn_range(vma, vma->vm_start, pfn, size, prot)) {
 -		kfree(priv);
 -		return -EAGAIN;
 -	}
 -
++=======
+ 	rdma_umap_priv_init(priv, vma);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(rdma_user_mmap_io);
+ 
+ /*
+  * The page case is here for a slightly different reason, the driver expects
+  * to be able to free the page it is sharing to user space when it destroys
+  * its ucontext, which means we need to zap the user space references.
+  *
+  * We could handle this differently by providing an API to allocate a shared
+  * page and then only freeing the shared page when the last ufile is
+  * destroyed.
+  */
+ int rdma_user_mmap_page(struct ib_ucontext *ucontext,
+ 			struct vm_area_struct *vma, struct page *page,
+ 			unsigned long size)
+ {
+ 	struct rdma_umap_priv *priv = rdma_user_mmap_pre(ucontext, vma, size);
+ 
+ 	if (IS_ERR(priv))
+ 		return PTR_ERR(priv);
+ 
+ 	if (remap_pfn_range(vma, vma->vm_start, page_to_pfn(page), size,
+ 			    vma->vm_page_prot)) {
+ 		kfree(priv);
+ 		return -EAGAIN;
+ 	}
+ 
+ 	rdma_umap_priv_init(priv, vma);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(rdma_user_mmap_page);
+ 
+ void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)
+ {
+ 	struct rdma_umap_priv *priv, *next_priv;
+ 
+ 	lockdep_assert_held(&ufile->hw_destroy_rwsem);
+ 
+ 	while (1) {
+ 		struct mm_struct *mm = NULL;
+ 
+ 		/* Get an arbitrary mm pointer that hasn't been cleaned yet */
+ 		mutex_lock(&ufile->umap_lock);
+ 		while (!list_empty(&ufile->umaps)) {
+ 			int ret;
+ 
+ 			priv = list_first_entry(&ufile->umaps,
+ 						struct rdma_umap_priv, list);
+ 			mm = priv->vma->vm_mm;
+ 			ret = mmget_not_zero(mm);
+ 			if (!ret) {
+ 				list_del_init(&priv->list);
+ 				mm = NULL;
+ 				continue;
+ 			}
+ 			break;
+ 		}
+ 		mutex_unlock(&ufile->umap_lock);
+ 		if (!mm)
+ 			return;
+ 
+ 		/*
+ 		 * The umap_lock is nested under mmap_sem since it used within
+ 		 * the vma_ops callbacks, so we have to clean the list one mm
+ 		 * at a time to get the lock ordering right. Typically there
+ 		 * will only be one mm, so no big deal.
+ 		 */
+ 		down_write(&mm->mmap_sem);
+ 		mutex_lock(&ufile->umap_lock);
+ 		list_for_each_entry_safe (priv, next_priv, &ufile->umaps,
+ 					  list) {
+ 			struct vm_area_struct *vma = priv->vma;
+ 
+ 			if (vma->vm_mm != mm)
+ 				continue;
+ 			list_del_init(&priv->list);
+ 
+ 			zap_vma_ptes(vma, vma->vm_start,
+ 				     vma->vm_end - vma->vm_start);
+ 			vma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);
+ 		}
+ 		mutex_unlock(&ufile->umap_lock);
+ 		up_write(&mm->mmap_sem);
+ 		mmput(mm);
+ 	}
++>>>>>>> 7b21b69ab203 (IB/uverbs: Fix OOPs in uverbs_user_mmap_disassociate)
  }
  
  /*
* Unmerged path drivers/infiniband/core/uverbs_main.c
