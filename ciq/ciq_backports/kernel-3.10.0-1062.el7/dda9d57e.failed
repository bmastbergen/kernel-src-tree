fm10k: remove ndo_poll_controller

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eric Dumazet <edumazet@google.com>
commit dda9d57e2d4245c0d8e309ee7399bf2ebfca64ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/dda9d57e.failed

As diagnosed by Song Liu, ndo_poll_controller() can
be very dangerous on loaded hosts, since the cpu
calling ndo_poll_controller() might steal all NAPI
contexts (for all RX/TX queues of the NIC). This capture
lasts for unlimited amount of time, since one
cpu is generally not able to drain all the queues under load.

fm10k uses NAPI for TX completions, so we better let core
networking stack call the napi->poll() to avoid the capture.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dda9d57e2d4245c0d8e309ee7399bf2ebfca64ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
diff --cc drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
index d2c9568f1f34,538a8467f434..000000000000
--- a/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
@@@ -1623,20 -1639,16 +1623,28 @@@ static const struct net_device_ops fm10
  	.ndo_vlan_rx_kill_vid	= fm10k_vlan_rx_kill_vid,
  	.ndo_set_rx_mode	= fm10k_set_rx_mode,
  	.ndo_get_stats64	= fm10k_get_stats64,
 -	.ndo_setup_tc		= __fm10k_setup_tc,
 +	.extended.ndo_setup_tc_rh = __fm10k_setup_tc,
  	.ndo_set_vf_mac		= fm10k_ndo_set_vf_mac,
 -	.ndo_set_vf_vlan	= fm10k_ndo_set_vf_vlan,
 -	.ndo_set_vf_rate	= fm10k_ndo_set_vf_bw,
 +	.extended.ndo_set_vf_vlan	= fm10k_ndo_set_vf_vlan,
 +	.ndo_set_vf_tx_rate	= fm10k_ndo_set_vf_bw,
  	.ndo_get_vf_config	= fm10k_ndo_get_vf_config,
++<<<<<<< HEAD
 +	.extended.ndo_udp_tunnel_add	= fm10k_add_vxlan_port,
 +	.extended.ndo_udp_tunnel_del	= fm10k_del_vxlan_port,
 +#if 0
 +	.extended.ndo_dfwd_add_station	= fm10k_dfwd_add_station,
 +	.extended.ndo_dfwd_del_station	= fm10k_dfwd_del_station,
 +#endif
 +#ifdef CONFIG_NET_POLL_CONTROLLER
 +	.ndo_poll_controller	= fm10k_netpoll,
 +#endif
++=======
+ 	.ndo_udp_tunnel_add	= fm10k_udp_tunnel_add,
+ 	.ndo_udp_tunnel_del	= fm10k_udp_tunnel_del,
+ 	.ndo_dfwd_add_station	= fm10k_dfwd_add_station,
+ 	.ndo_dfwd_del_station	= fm10k_dfwd_del_station,
+ 	.ndo_features_check	= fm10k_features_check,
++>>>>>>> dda9d57e2d42 (fm10k: remove ndo_poll_controller)
  };
  
  #define DEFAULT_DEBUG_LEVEL_SHIFT 3
diff --git a/drivers/net/ethernet/intel/fm10k/fm10k.h b/drivers/net/ethernet/intel/fm10k/fm10k.h
index 064c7d73a273..a77f6bc27709 100644
--- a/drivers/net/ethernet/intel/fm10k/fm10k.h
+++ b/drivers/net/ethernet/intel/fm10k/fm10k.h
@@ -521,9 +521,6 @@ void fm10k_update_stats(struct fm10k_intfc *interface);
 void fm10k_service_event_schedule(struct fm10k_intfc *interface);
 void fm10k_macvlan_schedule(struct fm10k_intfc *interface);
 void fm10k_update_rx_drop_en(struct fm10k_intfc *interface);
-#ifdef CONFIG_NET_POLL_CONTROLLER
-void fm10k_netpoll(struct net_device *netdev);
-#endif
 
 /* Netdev */
 struct net_device *fm10k_alloc_netdev(const struct fm10k_info *info);
* Unmerged path drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_pci.c b/drivers/net/ethernet/intel/fm10k/fm10k_pci.c
index f7ecd630e49f..5921872ff94a 100644
--- a/drivers/net/ethernet/intel/fm10k/fm10k_pci.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_pci.c
@@ -1227,28 +1227,6 @@ static irqreturn_t fm10k_msix_mbx_vf(int __always_unused irq, void *data)
 	return IRQ_HANDLED;
 }
 
-#ifdef CONFIG_NET_POLL_CONTROLLER
-/**
- *  fm10k_netpoll - A Polling 'interrupt' handler
- *  @netdev: network interface device structure
- *
- *  This is used by netconsole to send skbs without having to re-enable
- *  interrupts. It's not called while the normal interrupt routine is executing.
- **/
-void fm10k_netpoll(struct net_device *netdev)
-{
-	struct fm10k_intfc *interface = netdev_priv(netdev);
-	int i;
-
-	/* if interface is down do nothing */
-	if (test_bit(__FM10K_DOWN, interface->state))
-		return;
-
-	for (i = 0; i < interface->num_q_vectors; i++)
-		fm10k_msix_clean_rings(0, interface->q_vector[i]);
-}
-
-#endif
 #define FM10K_ERR_MSG(type) case (type): error = #type; break
 static void fm10k_handle_fault(struct fm10k_intfc *interface, int type,
 			       struct fm10k_fault *fault)
