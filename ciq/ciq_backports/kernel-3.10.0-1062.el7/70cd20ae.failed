IB/uverbs: Add IDRs array attribute type to ioctl() interface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Guy Levi <guyle@mellanox.com>
commit 70cd20aed00f719f3536154df02596106e431e45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/70cd20ae.failed

Methods sometimes need to get a flexible set of IDRs and not a strict set
as can be achieved today by the conventional IDR attribute. Add a new
IDRS_ARRAY attribute to the generic uverbs ioctl layer.

IDRS_ARRAY points to array of idrs of the same object type and same access
rights, only write and read are supported.

	Signed-off-by: Guy Levi <guyle@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>``
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 70cd20aed00f719f3536154df02596106e431e45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_ioctl.c
#	drivers/infiniband/core/uverbs_uapi.c
#	include/rdma/uverbs_ioctl.h
#	include/uapi/rdma/rdma_user_ioctl_cmds.h
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index ec7b453e622b,0e95a5888274..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -35,6 -35,104 +35,107 @@@
  #include "rdma_core.h"
  #include "uverbs.h"
  
++<<<<<<< HEAD
++=======
+ struct bundle_alloc_head {
+ 	struct bundle_alloc_head *next;
+ 	u8 data[];
+ };
+ 
+ struct bundle_priv {
+ 	/* Must be first */
+ 	struct bundle_alloc_head alloc_head;
+ 	struct bundle_alloc_head *allocated_mem;
+ 	size_t internal_avail;
+ 	size_t internal_used;
+ 
+ 	struct radix_tree_root *radix;
+ 	const struct uverbs_api_ioctl_method *method_elm;
+ 	void __rcu **radix_slots;
+ 	unsigned long radix_slots_len;
+ 	u32 method_key;
+ 
+ 	struct ib_uverbs_attr __user *user_attrs;
+ 	struct ib_uverbs_attr *uattrs;
+ 
+ 	DECLARE_BITMAP(uobj_finalize, UVERBS_API_ATTR_BKEY_LEN);
+ 	DECLARE_BITMAP(spec_finalize, UVERBS_API_ATTR_BKEY_LEN);
+ 
+ 	/*
+ 	 * Must be last. bundle ends in a flex array which overlaps
+ 	 * internal_buffer.
+ 	 */
+ 	struct uverbs_attr_bundle bundle;
+ 	u64 internal_buffer[32];
+ };
+ 
+ /*
+  * Each method has an absolute minimum amount of memory it needs to allocate,
+  * precompute that amount and determine if the onstack memory can be used or
+  * if allocation is need.
+  */
+ void uapi_compute_bundle_size(struct uverbs_api_ioctl_method *method_elm,
+ 			      unsigned int num_attrs)
+ {
+ 	struct bundle_priv *pbundle;
+ 	size_t bundle_size =
+ 		offsetof(struct bundle_priv, internal_buffer) +
+ 		sizeof(*pbundle->bundle.attrs) * method_elm->key_bitmap_len +
+ 		sizeof(*pbundle->uattrs) * num_attrs;
+ 
+ 	method_elm->use_stack = bundle_size <= sizeof(*pbundle);
+ 	method_elm->bundle_size =
+ 		ALIGN(bundle_size + 256, sizeof(*pbundle->internal_buffer));
+ 
+ 	/* Do not want order-2 allocations for this. */
+ 	WARN_ON_ONCE(method_elm->bundle_size > PAGE_SIZE);
+ }
+ 
+ /**
+  * uverbs_alloc() - Quickly allocate memory for use with a bundle
+  * @bundle: The bundle
+  * @size: Number of bytes to allocate
+  * @flags: Allocator flags
+  *
+  * The bundle allocator is intended for allocations that are connected with
+  * processing the system call related to the bundle. The allocated memory is
+  * always freed once the system call completes, and cannot be freed any other
+  * way.
+  *
+  * This tries to use a small pool of pre-allocated memory for performance.
+  */
+ __malloc void *_uverbs_alloc(struct uverbs_attr_bundle *bundle, size_t size,
+ 			     gfp_t flags)
+ {
+ 	struct bundle_priv *pbundle =
+ 		container_of(bundle, struct bundle_priv, bundle);
+ 	size_t new_used;
+ 	void *res;
+ 
+ 	if (check_add_overflow(size, pbundle->internal_used, &new_used))
+ 		return ERR_PTR(-EOVERFLOW);
+ 
+ 	if (new_used > pbundle->internal_avail) {
+ 		struct bundle_alloc_head *buf;
+ 
+ 		buf = kvmalloc(struct_size(buf, data, size), flags);
+ 		if (!buf)
+ 			return ERR_PTR(-ENOMEM);
+ 		buf->next = pbundle->allocated_mem;
+ 		pbundle->allocated_mem = buf;
+ 		return buf->data;
+ 	}
+ 
+ 	res = (void *)pbundle->internal_buffer + pbundle->internal_used;
+ 	pbundle->internal_used =
+ 		ALIGN(new_used, sizeof(*pbundle->internal_buffer));
+ 	if (flags & __GFP_ZERO)
+ 		memset(res, 0, size);
+ 	return res;
+ }
+ EXPORT_SYMBOL(_uverbs_alloc);
+ 
++>>>>>>> 70cd20aed00f (IB/uverbs: Add IDRs array attribute type to ioctl() interface)
  static bool uverbs_is_attr_cleared(const struct ib_uverbs_attr *uattr,
  				   u16 len)
  {
@@@ -46,35 -144,94 +147,121 @@@
  			   0, uattr->len - len);
  }
  
++<<<<<<< HEAD
 +static int uverbs_process_attr(struct ib_device *ibdev,
 +			       struct ib_ucontext *ucontext,
 +			       const struct ib_uverbs_attr *uattr,
 +			       u16 attr_id,
 +			       const struct uverbs_attr_spec_hash *attr_spec_bucket,
 +			       struct uverbs_attr_bundle_hash *attr_bundle_h,
 +			       struct ib_uverbs_attr __user *uattr_ptr)
++=======
+ static int uverbs_process_idrs_array(struct bundle_priv *pbundle,
+ 				     const struct uverbs_api_attr *attr_uapi,
+ 				     struct uverbs_objs_arr_attr *attr,
+ 				     struct ib_uverbs_attr *uattr,
+ 				     u32 attr_bkey)
+ {
+ 	const struct uverbs_attr_spec *spec = &attr_uapi->spec;
+ 	size_t array_len;
+ 	u32 *idr_vals;
+ 	int ret = 0;
+ 	size_t i;
+ 
+ 	if (uattr->attr_data.reserved)
+ 		return -EINVAL;
+ 
+ 	if (uattr->len % sizeof(u32))
+ 		return -EINVAL;
+ 
+ 	array_len = uattr->len / sizeof(u32);
+ 	if (array_len < spec->u2.objs_arr.min_len ||
+ 	    array_len > spec->u2.objs_arr.max_len)
+ 		return -EINVAL;
+ 
+ 	attr->uobjects =
+ 		uverbs_alloc(&pbundle->bundle,
+ 			     array_size(array_len, sizeof(*attr->uobjects)));
+ 	if (IS_ERR(attr->uobjects))
+ 		return PTR_ERR(attr->uobjects);
+ 
+ 	/*
+ 	 * Since idr is 4B and *uobjects is >= 4B, we can use attr->uobjects
+ 	 * to store idrs array and avoid additional memory allocation. The
+ 	 * idrs array is offset to the end of the uobjects array so we will be
+ 	 * able to read idr and replace with a pointer.
+ 	 */
+ 	idr_vals = (u32 *)(attr->uobjects + array_len) - array_len;
+ 
+ 	if (uattr->len > sizeof(uattr->data)) {
+ 		ret = copy_from_user(idr_vals, u64_to_user_ptr(uattr->data),
+ 				     uattr->len);
+ 		if (ret)
+ 			return -EFAULT;
+ 	} else {
+ 		memcpy(idr_vals, &uattr->data, uattr->len);
+ 	}
+ 
+ 	for (i = 0; i != array_len; i++) {
+ 		attr->uobjects[i] = uverbs_get_uobject_from_file(
+ 			spec->u2.objs_arr.obj_type, pbundle->bundle.ufile,
+ 			spec->u2.objs_arr.access, idr_vals[i]);
+ 		if (IS_ERR(attr->uobjects[i])) {
+ 			ret = PTR_ERR(attr->uobjects[i]);
+ 			break;
+ 		}
+ 	}
+ 
+ 	attr->len = i;
+ 	__set_bit(attr_bkey, pbundle->spec_finalize);
+ 	return ret;
+ }
+ 
+ static int uverbs_free_idrs_array(const struct uverbs_api_attr *attr_uapi,
+ 				  struct uverbs_objs_arr_attr *attr,
+ 				  bool commit)
+ {
+ 	const struct uverbs_attr_spec *spec = &attr_uapi->spec;
+ 	int current_ret;
+ 	int ret = 0;
+ 	size_t i;
+ 
+ 	for (i = 0; i != attr->len; i++) {
+ 		current_ret = uverbs_finalize_object(
+ 			attr->uobjects[i], spec->u2.objs_arr.access, commit);
+ 		if (!ret)
+ 			ret = current_ret;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int uverbs_process_attr(struct bundle_priv *pbundle,
+ 			       const struct uverbs_api_attr *attr_uapi,
+ 			       struct ib_uverbs_attr *uattr, u32 attr_bkey)
++>>>>>>> 70cd20aed00f (IB/uverbs: Add IDRs array attribute type to ioctl() interface)
  {
 -	const struct uverbs_attr_spec *spec = &attr_uapi->spec;
 -	struct uverbs_attr *e = &pbundle->bundle.attrs[attr_bkey];
 -	const struct uverbs_attr_spec *val_spec = spec;
 +	const struct uverbs_attr_spec *spec;
 +	const struct uverbs_attr_spec *val_spec;
 +	struct uverbs_attr *e;
 +	const struct uverbs_object_spec *object;
  	struct uverbs_obj_attr *o_attr;
 +	struct uverbs_attr *elements = attr_bundle_h->attrs;
 +
 +	if (attr_id >= attr_spec_bucket->num_attrs) {
 +		if (uattr->flags & UVERBS_ATTR_F_MANDATORY)
 +			return -EINVAL;
 +		else
 +			return 0;
 +	}
 +
 +	if (test_bit(attr_id, attr_bundle_h->valid_bitmap))
 +		return -EINVAL;
 +
 +	spec = &attr_spec_bucket->attrs[attr_id];
 +	val_spec = spec;
 +	e = &elements[attr_id];
 +	e->uattr = uattr_ptr;
  
  	switch (spec->type) {
  	case UVERBS_ATTR_TYPE_ENUM_IN:
@@@ -410,18 -456,133 +602,141 @@@ static long ib_uverbs_cmd_verbs(struct 
  	 * EPROTONOSUPPORT is ONLY to be returned if the ioctl framework can
  	 * not invoke the method because the request is not supported.  No
  	 * other cases should return this code.
 -	 */
 -	if (WARN_ON_ONCE(ret == -EPROTONOSUPPORT))
 -		return -EINVAL;
 -
 -	return ret;
 +	*/
 +	if (unlikely(err == -EPROTONOSUPPORT)) {
 +		WARN_ON_ONCE(err == -EPROTONOSUPPORT);
 +		err = -EINVAL;
 +	}
 +out:
 +	if (ctx != (void *)data)
 +		kfree(ctx);
 +	return err;
  }
  
++<<<<<<< HEAD
 +#define IB_UVERBS_MAX_CMD_SZ 4096
++=======
+ static int bundle_destroy(struct bundle_priv *pbundle, bool commit)
+ {
+ 	unsigned int key_bitmap_len = pbundle->method_elm->key_bitmap_len;
+ 	struct bundle_alloc_head *memblock;
+ 	unsigned int i;
+ 	int ret = 0;
+ 
+ 	/* fast path for simple uobjects */
+ 	i = -1;
+ 	while ((i = find_next_bit(pbundle->uobj_finalize, key_bitmap_len,
+ 				  i + 1)) < key_bitmap_len) {
+ 		struct uverbs_attr *attr = &pbundle->bundle.attrs[i];
+ 		int current_ret;
+ 
+ 		current_ret = uverbs_finalize_object(
+ 			attr->obj_attr.uobject,
+ 			attr->obj_attr.attr_elm->spec.u.obj.access, commit);
+ 		if (!ret)
+ 			ret = current_ret;
+ 	}
+ 
+ 	i = -1;
+ 	while ((i = find_next_bit(pbundle->spec_finalize, key_bitmap_len,
+ 				  i + 1)) < key_bitmap_len) {
+ 		struct uverbs_attr *attr = &pbundle->bundle.attrs[i];
+ 		const struct uverbs_api_attr *attr_uapi;
+ 		void __rcu **slot;
+ 		int current_ret;
+ 
+ 		slot = uapi_get_attr_for_method(
+ 			pbundle,
+ 			pbundle->method_key | uapi_bkey_to_key_attr(i));
+ 		if (WARN_ON(!slot))
+ 			continue;
+ 
+ 		attr_uapi = srcu_dereference(
+ 			*slot,
+ 			&pbundle->bundle.ufile->device->disassociate_srcu);
+ 
+ 		if (attr_uapi->spec.type == UVERBS_ATTR_TYPE_IDRS_ARRAY) {
+ 			current_ret = uverbs_free_idrs_array(
+ 				attr_uapi, &attr->objs_arr_attr, commit);
+ 			if (!ret)
+ 				ret = current_ret;
+ 		}
+ 	}
+ 
+ 	for (memblock = pbundle->allocated_mem; memblock;) {
+ 		struct bundle_alloc_head *tmp = memblock;
+ 
+ 		memblock = memblock->next;
+ 		kvfree(tmp);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int ib_uverbs_cmd_verbs(struct ib_uverbs_file *ufile,
+ 			       struct ib_uverbs_ioctl_hdr *hdr,
+ 			       struct ib_uverbs_attr __user *user_attrs)
+ {
+ 	const struct uverbs_api_ioctl_method *method_elm;
+ 	struct uverbs_api *uapi = ufile->device->uapi;
+ 	struct radix_tree_iter attrs_iter;
+ 	struct bundle_priv *pbundle;
+ 	struct bundle_priv onstack;
+ 	void __rcu **slot;
+ 	int destroy_ret;
+ 	int ret;
+ 
+ 	if (unlikely(hdr->driver_id != uapi->driver_id))
+ 		return -EINVAL;
+ 
+ 	slot = radix_tree_iter_lookup(
+ 		&uapi->radix, &attrs_iter,
+ 		uapi_key_obj(hdr->object_id) |
+ 			uapi_key_ioctl_method(hdr->method_id));
+ 	if (unlikely(!slot))
+ 		return -EPROTONOSUPPORT;
+ 	method_elm = srcu_dereference(*slot, &ufile->device->disassociate_srcu);
+ 
+ 	if (!method_elm->use_stack) {
+ 		pbundle = kmalloc(method_elm->bundle_size, GFP_KERNEL);
+ 		if (!pbundle)
+ 			return -ENOMEM;
+ 		pbundle->internal_avail =
+ 			method_elm->bundle_size -
+ 			offsetof(struct bundle_priv, internal_buffer);
+ 		pbundle->alloc_head.next = NULL;
+ 		pbundle->allocated_mem = &pbundle->alloc_head;
+ 	} else {
+ 		pbundle = &onstack;
+ 		pbundle->internal_avail = sizeof(pbundle->internal_buffer);
+ 		pbundle->allocated_mem = NULL;
+ 	}
+ 
+ 	/* Space for the pbundle->bundle.attrs flex array */
+ 	pbundle->method_elm = method_elm;
+ 	pbundle->method_key = attrs_iter.index;
+ 	pbundle->bundle.ufile = ufile;
+ 	pbundle->radix = &uapi->radix;
+ 	pbundle->radix_slots = slot;
+ 	pbundle->radix_slots_len = radix_tree_chunk_size(&attrs_iter);
+ 	pbundle->user_attrs = user_attrs;
+ 
+ 	pbundle->internal_used = ALIGN(pbundle->method_elm->key_bitmap_len *
+ 					       sizeof(*pbundle->bundle.attrs),
+ 				       sizeof(*pbundle->internal_buffer));
+ 	memset(pbundle->bundle.attr_present, 0,
+ 	       sizeof(pbundle->bundle.attr_present));
+ 	memset(pbundle->uobj_finalize, 0, sizeof(pbundle->uobj_finalize));
+ 	memset(pbundle->spec_finalize, 0, sizeof(pbundle->spec_finalize));
+ 
+ 	ret = ib_uverbs_run_method(pbundle, hdr->num_attrs);
+ 	destroy_ret = bundle_destroy(pbundle, ret == 0);
+ 	if (unlikely(destroy_ret && !ret))
+ 		return destroy_ret;
+ 
+ 	return ret;
+ }
++>>>>>>> 70cd20aed00f (IB/uverbs: Add IDRs array attribute type to ioctl() interface)
  
  long ib_uverbs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
  {
diff --cc include/rdma/uverbs_ioctl.h
index 2cc45699a237,84d3d15f1f38..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -93,72 -93,181 +94,103 @@@ struct uverbs_attr_spec 
  			 * higher bits mean the namespace and lower bits mean
  			 * the type id within the namespace.
  			 */
 -			u16 obj_type;
 -			u8 access;
 +			u16			obj_type;
 +			u8			access;
  		} obj;
++<<<<<<< HEAD
++=======
+ 
+ 		struct {
+ 			u8 num_elems;
+ 		} enum_def;
+ 	} u;
+ 
+ 	/* This weird split lets us remove some padding */
+ 	union {
++>>>>>>> 70cd20aed00f (IB/uverbs: Add IDRs array attribute type to ioctl() interface)
  		struct {
 +			enum uverbs_attr_type		type;
 +			/* Combination of bits from enum UVERBS_ATTR_SPEC_F_XXXX */
 +			u8				flags;
 +			u8				num_elems;
  			/*
  			 * The enum attribute can select one of the attributes
  			 * contained in the ids array. Currently only PTR_IN
  			 * attributes are supported in the ids array.
  			 */
 -			const struct uverbs_attr_spec *ids;
 +			const struct uverbs_attr_spec	*ids;
  		} enum_def;
++<<<<<<< HEAD
 +	};
++=======
+ 
+ 		struct {
+ 			/*
+ 			 * higher bits mean the namespace and lower bits mean
+ 			 * the type id within the namespace.
+ 			 */
+ 			u16				obj_type;
+ 			u16				min_len;
+ 			u16				max_len;
+ 			u8				access;
+ 		} objs_arr;
+ 	} u2;
++>>>>>>> 70cd20aed00f (IB/uverbs: Add IDRs array attribute type to ioctl() interface)
  };
  
 -/*
 - * Information about the API is loaded into a radix tree. For IOCTL we start
 - * with a tuple of:
 - *  object_id, attr_id, method_id
 - *
 - * Which is a 48 bit value, with most of the bits guaranteed to be zero. Based
 - * on the current kernel support this is compressed into 16 bit key for the
 - * radix tree. Since this compression is entirely internal to the kernel the
 - * below limits can be revised if the kernel gains additional data.
 - *
 - * With 64 leafs per node this is a 3 level radix tree.
 - *
 - * The tree encodes multiple types, and uses a scheme where OBJ_ID,0,0 returns
 - * the object slot, and OBJ_ID,METH_ID,0 and returns the method slot.
 - */
 -enum uapi_radix_data {
 -	UVERBS_API_NS_FLAG = 1U << UVERBS_ID_NS_SHIFT,
 -
 -	UVERBS_API_ATTR_KEY_BITS = 6,
 -	UVERBS_API_ATTR_KEY_MASK = GENMASK(UVERBS_API_ATTR_KEY_BITS - 1, 0),
 -	UVERBS_API_ATTR_BKEY_LEN = (1 << UVERBS_API_ATTR_KEY_BITS) - 1,
 -
 -	UVERBS_API_METHOD_KEY_BITS = 5,
 -	UVERBS_API_METHOD_KEY_SHIFT = UVERBS_API_ATTR_KEY_BITS,
 -	UVERBS_API_METHOD_KEY_NUM_CORE = 24,
 -	UVERBS_API_METHOD_KEY_NUM_DRIVER = (1 << UVERBS_API_METHOD_KEY_BITS) -
 -					   UVERBS_API_METHOD_KEY_NUM_CORE,
 -	UVERBS_API_METHOD_KEY_MASK = GENMASK(
 -		UVERBS_API_METHOD_KEY_BITS + UVERBS_API_METHOD_KEY_SHIFT - 1,
 -		UVERBS_API_METHOD_KEY_SHIFT),
 -
 -	UVERBS_API_OBJ_KEY_BITS = 5,
 -	UVERBS_API_OBJ_KEY_SHIFT =
 -		UVERBS_API_METHOD_KEY_BITS + UVERBS_API_METHOD_KEY_SHIFT,
 -	UVERBS_API_OBJ_KEY_NUM_CORE = 24,
 -	UVERBS_API_OBJ_KEY_NUM_DRIVER =
 -		(1 << UVERBS_API_OBJ_KEY_BITS) - UVERBS_API_OBJ_KEY_NUM_CORE,
 -	UVERBS_API_OBJ_KEY_MASK = GENMASK(31, UVERBS_API_OBJ_KEY_SHIFT),
 -
 -	/* This id guaranteed to not exist in the radix tree */
 -	UVERBS_API_KEY_ERR = 0xFFFFFFFF,
 +struct uverbs_attr_spec_hash {
 +	size_t				num_attrs;
 +	unsigned long			*mandatory_attrs_bitmask;
 +	struct uverbs_attr_spec		attrs[0];
  };
  
 -static inline __attribute_const__ u32 uapi_key_obj(u32 id)
 -{
 -	if (id & UVERBS_API_NS_FLAG) {
 -		id &= ~UVERBS_API_NS_FLAG;
 -		if (id >= UVERBS_API_OBJ_KEY_NUM_DRIVER)
 -			return UVERBS_API_KEY_ERR;
 -		id = id + UVERBS_API_OBJ_KEY_NUM_CORE;
 -	} else {
 -		if (id >= UVERBS_API_OBJ_KEY_NUM_CORE)
 -			return UVERBS_API_KEY_ERR;
 -	}
 -
 -	return id << UVERBS_API_OBJ_KEY_SHIFT;
 -}
 -
 -static inline __attribute_const__ bool uapi_key_is_object(u32 key)
 -{
 -	return (key & ~UVERBS_API_OBJ_KEY_MASK) == 0;
 -}
 -
 -static inline __attribute_const__ u32 uapi_key_ioctl_method(u32 id)
 -{
 -	if (id & UVERBS_API_NS_FLAG) {
 -		id &= ~UVERBS_API_NS_FLAG;
 -		if (id >= UVERBS_API_METHOD_KEY_NUM_DRIVER)
 -			return UVERBS_API_KEY_ERR;
 -		id = id + UVERBS_API_METHOD_KEY_NUM_CORE;
 -	} else {
 -		id++;
 -		if (id >= UVERBS_API_METHOD_KEY_NUM_CORE)
 -			return UVERBS_API_KEY_ERR;
 -	}
 -
 -	return id << UVERBS_API_METHOD_KEY_SHIFT;
 -}
 -
 -static inline __attribute_const__ u32 uapi_key_attr_to_method(u32 attr_key)
 -{
 -	return attr_key &
 -	       (UVERBS_API_OBJ_KEY_MASK | UVERBS_API_METHOD_KEY_MASK);
 -}
 -
 -static inline __attribute_const__ bool uapi_key_is_ioctl_method(u32 key)
 -{
 -	return (key & UVERBS_API_METHOD_KEY_MASK) != 0 &&
 -	       (key & UVERBS_API_ATTR_KEY_MASK) == 0;
 -}
 -
 -static inline __attribute_const__ u32 uapi_key_attrs_start(u32 ioctl_method_key)
 -{
 -	/* 0 is the method slot itself */
 -	return ioctl_method_key + 1;
 -}
 +struct uverbs_attr_bundle;
 +struct ib_uverbs_file;
  
 -static inline __attribute_const__ u32 uapi_key_attr(u32 id)
 -{
 +enum {
  	/*
 -	 * The attr is designed to fit in the typical single radix tree node
 -	 * of 64 entries. Since allmost all methods have driver attributes we
 -	 * organize things so that the driver and core attributes interleave to
 -	 * reduce the length of the attributes array in typical cases.
 +	 * Action marked with this flag creates a context (or root for all
 +	 * objects).
  	 */
 -	if (id & UVERBS_API_NS_FLAG) {
 -		id &= ~UVERBS_API_NS_FLAG;
 -		id++;
 -		if (id >= 1 << (UVERBS_API_ATTR_KEY_BITS - 1))
 -			return UVERBS_API_KEY_ERR;
 -		id = (id << 1) | 0;
 -	} else {
 -		if (id >= 1 << (UVERBS_API_ATTR_KEY_BITS - 1))
 -			return UVERBS_API_KEY_ERR;
 -		id = (id << 1) | 1;
 -	}
 +	UVERBS_ACTION_FLAG_CREATE_ROOT = 1U << 0,
 +};
  
 -	return id;
 -}
 +struct uverbs_method_spec {
 +	/* Combination of bits from enum UVERBS_ACTION_FLAG_XXXX */
 +	u32						flags;
 +	size_t						num_buckets;
 +	size_t						num_child_attrs;
 +	int (*handler)(struct ib_device *ib_dev, struct ib_uverbs_file *ufile,
 +		       struct uverbs_attr_bundle *ctx);
 +	struct uverbs_attr_spec_hash		*attr_buckets[0];
 +};
  
 -static inline __attribute_const__ bool uapi_key_is_attr(u32 key)
 -{
 -	return (key & UVERBS_API_METHOD_KEY_MASK) != 0 &&
 -	       (key & UVERBS_API_ATTR_KEY_MASK) != 0;
 -}
 +struct uverbs_method_spec_hash {
 +	size_t					num_methods;
 +	struct uverbs_method_spec		*methods[0];
 +};
  
 -/*
 - * This returns a value in the range [0 to UVERBS_API_ATTR_BKEY_LEN),
 - * basically it undoes the reservation of 0 in the ID numbering. attr_key
 - * must already be masked with UVERBS_API_ATTR_KEY_MASK, or be the output of
 - * uapi_key_attr().
 - */
 -static inline __attribute_const__ u32 uapi_bkey_attr(u32 attr_key)
 -{
 -	return attr_key - 1;
 -}
 +struct uverbs_object_spec {
 +	const struct uverbs_obj_type		*type_attrs;
 +	size_t					num_buckets;
 +	struct uverbs_method_spec_hash		*method_buckets[0];
 +};
 +
 +struct uverbs_object_spec_hash {
 +	size_t					num_objects;
 +	struct uverbs_object_spec		*objects[0];
 +};
 +
 +struct uverbs_root_spec {
 +	size_t					num_buckets;
 +	struct uverbs_object_spec_hash		*object_buckets[0];
 +};
  
+ static inline __attribute_const__ u32 uapi_bkey_to_key_attr(u32 attr_bkey)
+ {
+ 	return attr_bkey + 1;
+ }
+ 
  /*
   * =======================================
   *	Verbs definitions
@@@ -192,132 -301,157 +224,228 @@@ struct uverbs_object_tree_def 
  	const struct uverbs_object_def * const (*objects)[];
  };
  
 -/*
 - * =======================================
 - *	Attribute Specifications
 - * =======================================
 - */
 +#define UA_FLAGS(_flags)  .flags = _flags
 +#define __UVERBS_ATTR0(_id, _type, _fld, _attr, ...)              \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, .flags = 0, } }, } })
 +#define __UVERBS_ATTR1(_id, _type, _fld, _attr, _extra1, ...)      \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, _extra1 } },} })
 +#define __UVERBS_ATTR2(_id, _type, _fld, _attr, _extra1, _extra2)    \
 +	((const struct uverbs_attr_def)				  \
 +	 {.id = _id, .attr = {{._fld = {.type = _type, _attr, _extra1, _extra2 } },} })
 +#define __UVERBS_ATTR(_id, _type, _fld, _attr, _extra1, _extra2, _n, ...)	\
 +	__UVERBS_ATTR##_n(_id, _type, _fld, _attr, _extra1, _extra2)
  
 -#define UVERBS_ATTR_SIZE(_min_len, _len)			\
 -	.u.ptr.min_len = _min_len, .u.ptr.len = _len
 -
 -#define UVERBS_ATTR_NO_DATA() UVERBS_ATTR_SIZE(0, 0)
 -
 -/*
 - * Specifies a uapi structure that cannot be extended. The user must always
 - * supply the whole structure and nothing more. The structure must be declared
 - * in a header under include/uapi/rdma.
 - */
  #define UVERBS_ATTR_TYPE(_type)					\
++<<<<<<< HEAD
 +	.min_len = sizeof(_type), .len = sizeof(_type)
 +#define UVERBS_ATTR_STRUCT(_type, _last)			\
 +	.min_len = ((uintptr_t)(&((_type *)0)->_last + 1)), .len = sizeof(_type)
 +#define UVERBS_ATTR_SIZE(_min_len, _len)			\
 +	.min_len = _min_len, .len = _len
 +#define UVERBS_ATTR_MIN_SIZE(_min_len)				\
 +	UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
++=======
+ 	.u.ptr.min_len = sizeof(_type), .u.ptr.len = sizeof(_type)
+ /*
+  * Specifies a uapi structure where the user must provide at least up to
+  * member 'last'.  Anything after last and up until the end of the structure
+  * can be non-zero, anything longer than the end of the structure must be
+  * zero. The structure must be declared in a header under include/uapi/rdma.
+  */
+ #define UVERBS_ATTR_STRUCT(_type, _last)                                       \
+ 	.zero_trailing = 1,                                                    \
+ 	UVERBS_ATTR_SIZE(((uintptr_t)(&((_type *)0)->_last + 1)),              \
+ 			 sizeof(_type))
+ /*
+  * Specifies at least min_len bytes must be passed in, but the amount can be
+  * larger, up to the protocol maximum size. No check for zeroing is done.
+  */
+ #define UVERBS_ATTR_MIN_SIZE(_min_len) UVERBS_ATTR_SIZE(_min_len, USHRT_MAX)
+ 
+ /* Must be used in the '...' of any UVERBS_ATTR */
+ #define UA_ALLOC_AND_COPY .alloc_and_copy = 1
+ #define UA_MANDATORY .mandatory = 1
+ #define UA_OPTIONAL .mandatory = 0
+ 
+ /*
+  * min_len must be bigger than 0 and _max_len must be smaller than 4095.  Only
+  * READ\WRITE accesses are supported.
+  */
+ #define UVERBS_ATTR_IDRS_ARR(_attr_id, _idr_type, _access, _min_len, _max_len, \
+ 			     ...)                                              \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = (_attr_id) +                                             \
+ 		      BUILD_BUG_ON_ZERO((_min_len) == 0 ||                     \
+ 					(_max_len) >                           \
+ 						PAGE_SIZE / sizeof(void *) ||  \
+ 					(_min_len) > (_max_len) ||             \
+ 					(_access) == UVERBS_ACCESS_NEW ||      \
+ 					(_access) == UVERBS_ACCESS_DESTROY),   \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_IDRS_ARRAY,                 \
+ 			  .u2.objs_arr.obj_type = _idr_type,                   \
+ 			  .u2.objs_arr.access = _access,                       \
+ 			  .u2.objs_arr.min_len = _min_len,                     \
+ 			  .u2.objs_arr.max_len = _max_len,                     \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_IDR(_attr_id, _idr_type, _access, ...)                     \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_IDR,                        \
+ 			  .u.obj.obj_type = _idr_type,                         \
+ 			  .u.obj.access = _access,                             \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_FD(_attr_id, _fd_type, _access, ...)                       \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = (_attr_id) +                                             \
+ 		      BUILD_BUG_ON_ZERO((_access) != UVERBS_ACCESS_NEW &&      \
+ 					(_access) != UVERBS_ACCESS_READ),      \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_FD,                         \
+ 			  .u.obj.obj_type = _fd_type,                          \
+ 			  .u.obj.access = _access,                             \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_PTR_IN(_attr_id, _type, ...)                               \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_PTR_IN,                     \
+ 			  _type,                                               \
+ 			  __VA_ARGS__ } })
+ 
+ #define UVERBS_ATTR_PTR_OUT(_attr_id, _type, ...)                              \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_PTR_OUT,                    \
+ 			  _type,                                               \
+ 			  __VA_ARGS__ } })
+ 
+ /* _enum_arry should be a 'static const union uverbs_attr_spec[]' */
+ #define UVERBS_ATTR_ENUM_IN(_attr_id, _enum_arr, ...)                          \
+ 	(&(const struct uverbs_attr_def){                                      \
+ 		.id = _attr_id,                                                \
+ 		.attr = { .type = UVERBS_ATTR_TYPE_ENUM_IN,                    \
+ 			  .u2.enum_def.ids = _enum_arr,                        \
+ 			  .u.enum_def.num_elems = ARRAY_SIZE(_enum_arr),       \
+ 			  __VA_ARGS__ },                                       \
+ 	})
+ 
+ /* An input value that is a member in the enum _enum_type. */
+ #define UVERBS_ATTR_CONST_IN(_attr_id, _enum_type, ...)                        \
+ 	UVERBS_ATTR_PTR_IN(                                                    \
+ 		_attr_id,                                                      \
+ 		UVERBS_ATTR_SIZE(                                              \
+ 			sizeof(u64) + BUILD_BUG_ON_ZERO(!sizeof(_enum_type)),  \
+ 			sizeof(u64)),                                          \
+ 		__VA_ARGS__)
++>>>>>>> 70cd20aed00f (IB/uverbs: Add IDRs array attribute type to ioctl() interface)
  
  /*
 - * An input value that is a bitwise combination of values of _enum_type.
 - * This permits the flag value to be passed as either a u32 or u64, it must
 - * be retrieved via uverbs_get_flag().
 + * In new compiler, UVERBS_ATTR could be simplified by declaring it as
 + * [_id] = {.type = _type, .len = _len, ##__VA_ARGS__}
 + * But since we support older compilers too, we need the more complex code.
   */
 -#define UVERBS_ATTR_FLAGS_IN(_attr_id, _enum_type, ...)                        \
 -	UVERBS_ATTR_PTR_IN(                                                    \
 -		_attr_id,                                                      \
 -		UVERBS_ATTR_SIZE(sizeof(u32) + BUILD_BUG_ON_ZERO(              \
 -						       !sizeof(_enum_type *)), \
 -				 sizeof(u64)),                                 \
 -		__VA_ARGS__)
 +#define UVERBS_ATTR(_id, _type, _fld, _attr, ...)			\
 +	__UVERBS_ATTR(_id, _type, _fld, _attr, ##__VA_ARGS__, 2, 1, 0)
 +#define UVERBS_ATTR_PTR_IN_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_IN, ptr, _len, ##__VA_ARGS__)
 +/* If sizeof(_type) <= sizeof(u64), this will be inlined rather than a pointer */
 +#define UVERBS_ATTR_PTR_IN(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_IN_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT_SZ(_id, _len, ...)				\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_PTR_OUT, ptr, _len, ##__VA_ARGS__)
 +#define UVERBS_ATTR_PTR_OUT(_id, _type, ...)				\
 +	UVERBS_ATTR_PTR_OUT_SZ(_id, _type, ##__VA_ARGS__)
 +#define UVERBS_ATTR_ENUM_IN(_id, _enum_arr, ...)			\
 +	UVERBS_ATTR(_id, UVERBS_ATTR_TYPE_ENUM_IN, enum_def,		\
 +		    .ids = (_enum_arr),					\
 +		    .num_elems = ARRAY_SIZE(_enum_arr), ##__VA_ARGS__)
  
  /*
 - * This spec is used in order to pass information to the hardware driver in a
 - * legacy way. Every verb that could get driver specific data should get this
 - * spec.
 - */
 -#define UVERBS_ATTR_UHW()                                                      \
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_UHW_IN,                                 \
 -			   UVERBS_ATTR_MIN_SIZE(0),			       \
 -			   UA_OPTIONAL),				       \
 -	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_UHW_OUT,                               \
 -			    UVERBS_ATTR_MIN_SIZE(0),			       \
 -			    UA_OPTIONAL)
 -
 -/*
 - * =======================================
 - *	Declaration helpers
 - * =======================================
 + * In new compiler, UVERBS_ATTR_IDR (and FD) could be simplified by declaring
 + * it as
 + * {.id = _id,								\
 + *  .attr {.type = __obj_class,						\
 + *         .obj = {.obj_type = _idr_type,				\
 + *                       .access = _access                              \
 + *                }, ##__VA_ARGS__ } }
 + * But since we support older compilers too, we need the more complex code.
   */
 -
 -#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)                                 \
 -	static const struct uverbs_object_def *const _name##_ptr[] = {         \
 -		__VA_ARGS__,                                                   \
 -	};                                                                     \
 -	static const struct uverbs_object_tree_def _name = {                   \
 -		.num_objects = ARRAY_SIZE(_name##_ptr),                        \
 -		.objects = &_name##_ptr,                                       \
 +#define ___UVERBS_ATTR_OBJ0(_id, _obj_class, _obj_type, _access, ...)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	 .attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			    .access = _access, .flags = 0 } }, } })
 +#define ___UVERBS_ATTR_OBJ1(_id, _obj_class, _obj_type, _access, _flags)\
 +	((const struct uverbs_attr_def)					\
 +	{.id = _id,							\
 +	.attr = { {.obj = {.type = _obj_class, .obj_type = _obj_type,	\
 +			   .access = _access, _flags} }, } })
 +#define ___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, _flags, \
 +			   _n, ...)					\
 +	___UVERBS_ATTR_OBJ##_n(_id, _obj_class, _obj_type, _access, _flags)
 +#define __UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access, ...)	\
 +	___UVERBS_ATTR_OBJ(_id, _obj_class, _obj_type, _access,		\
 +			   ##__VA_ARGS__, 1, 0)
 +#define UVERBS_ATTR_IDR(_id, _idr_type, _access, ...)			 \
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_IDR, _idr_type, _access,\
 +			  ##__VA_ARGS__)
 +#define UVERBS_ATTR_FD(_id, _fd_type, _access, ...)			\
 +	__UVERBS_ATTR_OBJ(_id, UVERBS_ATTR_TYPE_FD, _fd_type,		\
 +			  (_access) + BUILD_BUG_ON_ZERO(		\
 +				(_access) != UVERBS_ACCESS_NEW &&	\
 +				(_access) != UVERBS_ACCESS_READ),	\
 +			  ##__VA_ARGS__)
 +#define DECLARE_UVERBS_ATTR_SPEC(_name, ...)				\
 +	const struct uverbs_attr_def _name = __VA_ARGS__
 +
 +#define DECLARE_UVERBS_ENUM(_name, ...)					\
 +	const struct uverbs_enum_spec _name = {				\
 +		.len = ARRAY_SIZE(((struct uverbs_attr_spec[]){__VA_ARGS__})),\
 +		.ids = {__VA_ARGS__},					\
  	}
 +#define _UVERBS_METHOD_ATTRS_SZ(...)					\
 +	(sizeof((const struct uverbs_attr_def * const []){__VA_ARGS__}) /\
 +	 sizeof(const struct uverbs_attr_def *))
 +#define _UVERBS_METHOD(_id, _handler, _flags, ...)			\
 +	((const struct uverbs_method_def) {				\
 +	 .id = _id,							\
 +	 .flags = _flags,						\
 +	 .handler = _handler,						\
 +	 .num_attrs = _UVERBS_METHOD_ATTRS_SZ(__VA_ARGS__),		\
 +	 .attrs = &(const struct uverbs_attr_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_METHOD(_name, _id, _handler, ...)		\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler, 0, ##__VA_ARGS__)
 +#define DECLARE_UVERBS_CTX_METHOD(_name, _id, _handler, _flags, ...)	\
 +	const struct uverbs_method_def _name =				\
 +		_UVERBS_METHOD(_id, _handler,				\
 +			       UVERBS_ACTION_FLAG_CREATE_ROOT,		\
 +			       ##__VA_ARGS__)
 +#define _UVERBS_OBJECT_METHODS_SZ(...)					\
 +	(sizeof((const struct uverbs_method_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_method_def *))
 +#define _UVERBS_OBJECT(_id, _type_attrs, ...)				\
 +	((const struct uverbs_object_def) {				\
 +	 .id = _id,							\
 +	 .type_attrs = _type_attrs,					\
 +	 .num_methods = _UVERBS_OBJECT_METHODS_SZ(__VA_ARGS__),		\
 +	 .methods = &(const struct uverbs_method_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT(_name, _id, _type_attrs, ...)		\
 +	const struct uverbs_object_def _name =				\
 +		_UVERBS_OBJECT(_id, _type_attrs, ##__VA_ARGS__)
 +#define _UVERBS_TREE_OBJECTS_SZ(...)					\
 +	(sizeof((const struct uverbs_object_def * const []){__VA_ARGS__}) / \
 +	 sizeof(const struct uverbs_object_def *))
 +#define _UVERBS_OBJECT_TREE(...)					\
 +	((const struct uverbs_object_tree_def) {			\
 +	 .num_objects = _UVERBS_TREE_OBJECTS_SZ(__VA_ARGS__),		\
 +	 .objects = &(const struct uverbs_object_def * const []){__VA_ARGS__} })
 +#define DECLARE_UVERBS_OBJECT_TREE(_name, ...)				\
 +	const struct uverbs_object_tree_def _name =			\
 +		_UVERBS_OBJECT_TREE(__VA_ARGS__)
  
  /* =================================================
   *              Parsing infrastructure
@@@ -334,14 -475,15 +462,19 @@@ struct uverbs_ptr_attr 
  
  struct uverbs_obj_attr {
  	struct ib_uobject		*uobject;
 -	const struct uverbs_api_attr	*attr_elm;
  };
  
+ struct uverbs_objs_arr_attr {
+ 	struct ib_uobject **uobjects;
+ 	u16 len;
+ };
+ 
  struct uverbs_attr {
 +	/*
 +	 * pointer to the user-space given attribute, in order to write the
 +	 * new uobject's id or update flags.
 +	 */
 +	struct ib_uverbs_attr __user	*uattr;
  	union {
  		struct uverbs_ptr_attr	ptr_attr;
  		struct uverbs_obj_attr	obj_attr;
@@@ -406,27 -526,65 +540,52 @@@ static inline int uverbs_attr_get_enum_
  	return attr->ptr_attr.enum_id;
  }
  
 -static inline void *uverbs_attr_get_obj(const struct uverbs_attr_bundle *attrs_bundle,
 -					u16 idx)
 -{
 -	const struct uverbs_attr *attr;
 -
 -	attr = uverbs_attr_get(attrs_bundle, idx);
 -	if (IS_ERR(attr))
 -		return ERR_CAST(attr);
 -
 -	return attr->obj_attr.uobject->object;
 -}
 -
 -static inline struct ib_uobject *uverbs_attr_get_uobject(const struct uverbs_attr_bundle *attrs_bundle,
 -							 u16 idx)
 +static inline int uverbs_copy_to(const struct uverbs_attr_bundle *attrs_bundle,
 +				 size_t idx, const void *from, size_t size)
  {
  	const struct uverbs_attr *attr = uverbs_attr_get(attrs_bundle, idx);
 +	u16 flags;
 +	size_t min_size;
  
  	if (IS_ERR(attr))
 -		return ERR_CAST(attr);
 -
 -	return attr->obj_attr.uobject;
 -}
 +		return PTR_ERR(attr);
  
 -static inline int
 -uverbs_attr_get_len(const struct uverbs_attr_bundle *attrs_bundle, u16 idx)
 -{
 -	const struct uverbs_attr *attr = uverbs_attr_get(attrs_bundle, idx);
 +	min_size = min_t(size_t, attr->ptr_attr.len, size);
 +	if (copy_to_user(u64_to_user_ptr(attr->ptr_attr.data), from, min_size))
 +		return -EFAULT;
  
 -	if (IS_ERR(attr))
 -		return PTR_ERR(attr);
 +	flags = attr->ptr_attr.flags | UVERBS_ATTR_F_VALID_OUTPUT;
 +	if (put_user(flags, &attr->uattr->flags))
 +		return -EFAULT;
  
 -	return attr->ptr_attr.len;
 +	return 0;
  }
  
+ /**
+  * uverbs_attr_get_uobjs_arr() - Provides array's properties for attribute for
+  * UVERBS_ATTR_TYPE_IDRS_ARRAY.
+  * @arr: Returned pointer to array of pointers for uobjects or NULL if
+  *       the attribute isn't provided.
+  *
+  * Return: The array length or 0 if no attribute was provided.
+  */
+ static inline int uverbs_attr_get_uobjs_arr(
+ 	const struct uverbs_attr_bundle *attrs_bundle, u16 attr_idx,
+ 	struct ib_uobject ***arr)
+ {
+ 	const struct uverbs_attr *attr =
+ 			uverbs_attr_get(attrs_bundle, attr_idx);
+ 
+ 	if (IS_ERR(attr)) {
+ 		*arr = NULL;
+ 		return 0;
+ 	}
+ 
+ 	*arr = attr->objs_arr_attr.uobjects;
+ 
+ 	return attr->objs_arr_attr.len;
+ }
+ 
  static inline bool uverbs_attr_ptr_is_inline(const struct uverbs_attr *attr)
  {
  	return attr->ptr_attr.len <= sizeof(attr->ptr_attr.data);
diff --cc include/uapi/rdma/rdma_user_ioctl_cmds.h
index e39b37a830e2,06c34d99be85..000000000000
--- a/include/uapi/rdma/rdma_user_ioctl_cmds.h
+++ b/include/uapi/rdma/rdma_user_ioctl_cmds.h
@@@ -62,7 -62,15 +62,19 @@@ struct ib_uverbs_attr 
  		} enum_data;
  		__u16 reserved;
  	} attr_data;
++<<<<<<< HEAD
 +	__aligned_u64 data;	/* ptr to command, inline data or idr/fd */
++=======
+ 	union {
+ 		/*
+ 		 * ptr to command, inline data, idr/fd or
+ 		 * ptr to __u32 array of IDRs
+ 		 */
+ 		__aligned_u64 data;
+ 		/* Used by FD_IN and FD_OUT */
+ 		__s64 data_s64;
+ 	};
++>>>>>>> 70cd20aed00f (IB/uverbs: Add IDRs array attribute type to ioctl() interface)
  };
  
  struct ib_uverbs_ioctl_hdr {
* Unmerged path drivers/infiniband/core/uverbs_uapi.c
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
* Unmerged path drivers/infiniband/core/uverbs_uapi.c
* Unmerged path include/rdma/uverbs_ioctl.h
* Unmerged path include/uapi/rdma/rdma_user_ioctl_cmds.h
