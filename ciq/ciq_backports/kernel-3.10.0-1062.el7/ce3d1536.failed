uio_hv_generic: fix subchannel ring mmap

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Stephen Hemminger <stephen@networkplumber.org>
commit ce3d1536acabbdcdc3c945c3c078dd4ed1b8edfa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ce3d1536.failed

The fault method of handling subchannel ring, did not work correctly
(it only worked for the first page).

Since ring buffer is physically contiguous, using the vm helper
function is simpler and handles more cases.

Fixes: 37b96a4931db ("uio_hv_generic: support sub-channels")
	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit ce3d1536acabbdcdc3c945c3c078dd4ed1b8edfa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/uio/uio_hv_generic.c
diff --cc drivers/uio/uio_hv_generic.c
index d608865b1e1e,c690d100adcd..000000000000
--- a/drivers/uio/uio_hv_generic.c
+++ b/drivers/uio/uio_hv_generic.c
@@@ -91,6 -104,92 +91,95 @@@ static void hv_uio_channel_cb(void *con
  	uio_event_notify(&pdata->info);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Callback from vmbus_event when channel is rescinded.
+  */
+ static void hv_uio_rescind(struct vmbus_channel *channel)
+ {
+ 	struct hv_device *hv_dev = channel->primary_channel->device_obj;
+ 	struct hv_uio_private_data *pdata = hv_get_drvdata(hv_dev);
+ 
+ 	/*
+ 	 * Turn off the interrupt file handle
+ 	 * Next read for event will return -EIO
+ 	 */
+ 	pdata->info.irq = 0;
+ 
+ 	/* Wake up reader */
+ 	uio_event_notify(&pdata->info);
+ }
+ 
+ /* Sysfs API to allow mmap of the ring buffers
+  * The ring buffer is allocated as contiguous memory by vmbus_open
+  */
+ static int hv_uio_ring_mmap(struct file *filp, struct kobject *kobj,
+ 			    struct bin_attribute *attr,
+ 			    struct vm_area_struct *vma)
+ {
+ 	struct vmbus_channel *channel
+ 		= container_of(kobj, struct vmbus_channel, kobj);
+ 	struct hv_device *dev = channel->primary_channel->device_obj;
+ 	u16 q_idx = channel->offermsg.offer.sub_channel_index;
+ 
+ 	dev_dbg(&dev->device, "mmap channel %u pages %#lx at %#lx\n",
+ 		q_idx, vma_pages(vma), vma->vm_pgoff);
+ 
+ 	return vm_iomap_memory(vma, virt_to_phys(channel->ringbuffer_pages),
+ 			       channel->ringbuffer_pagecount << PAGE_SHIFT);
+ }
+ 
+ static const struct bin_attribute ring_buffer_bin_attr = {
+ 	.attr = {
+ 		.name = "ring",
+ 		.mode = 0600,
+ 	},
+ 	.size = 2 * HV_RING_SIZE * PAGE_SIZE,
+ 	.mmap = hv_uio_ring_mmap,
+ };
+ 
+ /* Callback from VMBUS subsystem when new channel created. */
+ static void
+ hv_uio_new_channel(struct vmbus_channel *new_sc)
+ {
+ 	struct hv_device *hv_dev = new_sc->primary_channel->device_obj;
+ 	struct device *device = &hv_dev->device;
+ 	const size_t ring_bytes = HV_RING_SIZE * PAGE_SIZE;
+ 	int ret;
+ 
+ 	/* Create host communication ring */
+ 	ret = vmbus_open(new_sc, ring_bytes, ring_bytes, NULL, 0,
+ 			 hv_uio_channel_cb, new_sc);
+ 	if (ret) {
+ 		dev_err(device, "vmbus_open subchannel failed: %d\n", ret);
+ 		return;
+ 	}
+ 
+ 	/* Disable interrupts on sub channel */
+ 	new_sc->inbound.ring_buffer->interrupt_mask = 1;
+ 	set_channel_read_mode(new_sc, HV_CALL_ISR);
+ 
+ 	ret = sysfs_create_bin_file(&new_sc->kobj, &ring_buffer_bin_attr);
+ 	if (ret) {
+ 		dev_err(device, "sysfs create ring bin file failed; %d\n", ret);
+ 		vmbus_close(new_sc);
+ 	}
+ }
+ 
+ static void
+ hv_uio_cleanup(struct hv_device *dev, struct hv_uio_private_data *pdata)
+ {
+ 	if (pdata->send_gpadl)
+ 		vmbus_teardown_gpadl(dev->channel, pdata->send_gpadl);
+ 	vfree(pdata->send_buf);
+ 
+ 	if (pdata->recv_gpadl)
+ 		vmbus_teardown_gpadl(dev->channel, pdata->recv_gpadl);
+ 	vfree(pdata->recv_buf);
+ }
+ 
++>>>>>>> ce3d1536acab (uio_hv_generic: fix subchannel ring mmap)
  static int
  hv_uio_probe(struct hv_device *dev,
  	     const struct hv_vmbus_device_id *dev_id)
* Unmerged path drivers/uio/uio_hv_generic.c
