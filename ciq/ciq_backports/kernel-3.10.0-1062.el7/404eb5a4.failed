perf thread: Make thread__find_map() search all maps

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 404eb5a436c4cbdc3b76896a28a3b72b7ad9294e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/404eb5a4.failed

We still have the split internally, but users don't see it anymore,
simplifying the growing number of cases where we end up searching
in the MAP__VARIABLE maps.

This further paves the way for ditching the split.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: https://lkml.kernel.org/n/tip-86mfxrztf310konutxvhr5ua@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 404eb5a436c4cbdc3b76896a28a3b72b7ad9294e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-script.c
#	tools/perf/util/event.c
#	tools/perf/util/thread.h
#	tools/perf/util/unwind-libdw.c
#	tools/perf/util/unwind-libunwind-local.c
diff --cc tools/perf/builtin-script.c
index a9b367022c45,fa2c7a288750..000000000000
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@@ -872,10 -927,8 +872,15 @@@ static int ip__fprintf_sym(uint64_t add
  
  	memset(&al, 0, sizeof(al));
  
++<<<<<<< HEAD
 +	thread__find_addr_map(thread, cpumode, MAP__FUNCTION, addr, &al);
 +	if (!al.map)
 +		thread__find_addr_map(thread, cpumode, MAP__VARIABLE,
 +				      addr, &al);
++=======
+ 	thread__find_map(thread, cpumode, addr, &al);
+ 
++>>>>>>> 404eb5a436c4 (perf thread: Make thread__find_map() search all maps)
  	if ((*lastsym) && al.addr >= (*lastsym)->start && al.addr < (*lastsym)->end)
  		return 0;
  
diff --cc tools/perf/util/event.c
index 8a7576df2c3b,7831c2266118..000000000000
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@@ -1342,9 -1488,8 +1342,14 @@@ int perf_event__process(struct perf_too
  	return machine__process_event(machine, event, sample);
  }
  
++<<<<<<< HEAD
 +void thread__find_addr_map(struct thread *thread, u8 cpumode,
 +			   enum map_type type, u64 addr,
 +			   struct addr_location *al)
++=======
+ static struct map *__thread__find_map(struct thread *thread, u8 cpumode, enum map_type type,
+ 				      u64 addr, struct addr_location *al)
++>>>>>>> 404eb5a436c4 (perf thread: Make thread__find_map() search all maps)
  {
  	struct map_groups *mg = thread->mg;
  	struct machine *machine = mg->machine;
@@@ -1416,17 -1561,24 +1421,32 @@@ try_again
  			map__load(al->map);
  		al->addr = al->map->map_ip(al->map, al->addr);
  	}
 -
 -	return al->map;
  }
  
++<<<<<<< HEAD
 +void __thread__find_symbol(struct thread *thread, u8 cpumode,
 +			   enum map_type type, u64 addr,
 +			   struct addr_location *al)
 +{
 +	thread__find_addr_map(thread, cpumode, type, addr, al);
 +	if (al->map != NULL)
++=======
+ struct map *thread__find_map(struct thread *thread, u8 cpumode, u64 addr,
+ 			     struct addr_location *al)
+ {
+ 	struct map *map = __thread__find_map(thread, cpumode, MAP__FUNCTION, addr, al);
+ 	return map ?: __thread__find_map(thread, cpumode, MAP__VARIABLE, addr, al);
+ }
+ 
+ struct symbol *thread__find_symbol(struct thread *thread, u8 cpumode,
+ 				   u64 addr, struct addr_location *al)
+ {
+ 	al->sym = NULL;
+ 	if (thread__find_map(thread, cpumode, addr, al))
++>>>>>>> 404eb5a436c4 (perf thread: Make thread__find_map() search all maps)
  		al->sym = map__find_symbol(al->map, al->addr);
 -	return al->sym;
 +	else
 +		al->sym = NULL;
  }
  
  /*
@@@ -1522,10 -1674,7 +1542,14 @@@ bool sample_addr_correlates_sym(struct 
  void thread__resolve(struct thread *thread, struct addr_location *al,
  		     struct perf_sample *sample)
  {
++<<<<<<< HEAD
 +	thread__find_addr_map(thread, sample->cpumode, MAP__FUNCTION, sample->addr, al);
 +	if (!al->map)
 +		thread__find_addr_map(thread, sample->cpumode, MAP__VARIABLE,
 +				      sample->addr, al);
++=======
+ 	thread__find_map(thread, sample->cpumode, sample->addr, al);
++>>>>>>> 404eb5a436c4 (perf thread: Make thread__find_map() search all maps)
  
  	al->cpu = sample->cpu;
  	al->sym = NULL;
diff --cc tools/perf/util/thread.h
index 6720c6d2aae4,07606aa6998d..000000000000
--- a/tools/perf/util/thread.h
+++ b/tools/perf/util/thread.h
@@@ -83,18 -92,11 +83,23 @@@ size_t thread__fprintf(struct thread *t
  
  struct thread *thread__main_thread(struct machine *machine, struct thread *thread);
  
++<<<<<<< HEAD
 +void thread__find_addr_map(struct thread *thread,
 +			   u8 cpumode, enum map_type type, u64 addr,
 +			   struct addr_location *al);
 +
 +void __thread__find_symbol(struct thread *thread, u8 cpumode, enum map_type type,
 +			   u64 addr, struct addr_location *al);
 +
 +static inline void thread__find_symbol(struct thread *thread, u8 cpumode,
 +				       u64 addr, struct addr_location *al)
 +{
 +	return __thread__find_symbol(thread, cpumode, MAP__FUNCTION, addr, al);
 +}
++=======
+ struct map *thread__find_map(struct thread *thread, u8 cpumode, u64 addr,
+ 			     struct addr_location *al);
 -
 -struct symbol *thread__find_symbol(struct thread *thread, u8 cpumode,
 -				   u64 addr, struct addr_location *al);
++>>>>>>> 404eb5a436c4 (perf thread: Make thread__find_map() search all maps)
  
  void thread__find_cpumode_addr_location(struct thread *thread, u64 addr,
  					struct addr_location *al);
diff --cc tools/perf/util/unwind-libdw.c
index 6d9d8927c469,538db4e5d1e6..000000000000
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@@ -103,19 -104,7 +103,23 @@@ static int access_dso_mem(struct unwind
  	struct addr_location al;
  	ssize_t size;
  
++<<<<<<< HEAD
 +	thread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,
 +			      MAP__FUNCTION, addr, &al);
 +	if (!al.map) {
 +		/*
 +		 * We've seen cases (softice) where DWARF unwinder went
 +		 * through non executable mmaps, which we need to lookup
 +		 * in MAP__VARIABLE tree.
 +		 */
 +		thread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,
 +				      MAP__VARIABLE, addr, &al);
 +	}
 +
 +	if (!al.map) {
++=======
+ 	if (!thread__find_map(ui->thread, PERF_RECORD_MISC_USER, addr, &al)) {
++>>>>>>> 404eb5a436c4 (perf thread: Make thread__find_map() search all maps)
  		pr_debug("unwind: no map for %lx\n", (unsigned long)addr);
  		return -1;
  	}
diff --cc tools/perf/util/unwind-libunwind-local.c
index 1e7f7f1b7fec,6a11bc7e6b27..000000000000
--- a/tools/perf/util/unwind-libunwind-local.c
+++ b/tools/perf/util/unwind-libunwind-local.c
@@@ -365,19 -366,7 +365,23 @@@ static int read_unwind_spec_debug_frame
  static struct map *find_map(unw_word_t ip, struct unwind_info *ui)
  {
  	struct addr_location al;
++<<<<<<< HEAD
 +
 +	thread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,
 +			      MAP__FUNCTION, ip, &al);
 +	if (!al.map) {
 +		/*
 +		 * We've seen cases (softice) where DWARF unwinder went
 +		 * through non executable mmaps, which we need to lookup
 +		 * in MAP__VARIABLE tree.
 +		 */
 +		thread__find_addr_map(ui->thread, PERF_RECORD_MISC_USER,
 +				      MAP__VARIABLE, ip, &al);
 +	}
 +	return al.map;
++=======
+ 	return thread__find_map(ui->thread, PERF_RECORD_MISC_USER, ip, &al);
++>>>>>>> 404eb5a436c4 (perf thread: Make thread__find_map() search all maps)
  }
  
  static int
* Unmerged path tools/perf/builtin-script.c
* Unmerged path tools/perf/util/event.c
* Unmerged path tools/perf/util/thread.h
* Unmerged path tools/perf/util/unwind-libdw.c
* Unmerged path tools/perf/util/unwind-libunwind-local.c
