perf clang: Add builtin clang support ant test case

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit 00b86691c77c6576861b82a3cfe4d609800758fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/00b86691.failed

Add basic clang support in clang.cpp and test__clang() testcase. The
first testcase checks if builtin clang is able to generate LLVM IR.

tests/clang.c is a proxy. Real testcase resides in
utils/c++/clang-test.cpp in c++ and exports C interface to perf test
subsystem.

Test result:

   $ perf test -v clang
   51: builtin clang support                               :
   51.1: Test builtin clang compile C source to IR              :
   --- start ---
   test child forked, pid 13215
   test child finished with 0
   ---- end ----
   Test builtin clang support subtest 0: Ok

Committer note:

Make sure you've enabled CLANG and LLVM builtin support by setting
the LIBCLANGLLVM variable on the make command line, e.g.:

  make LIBCLANGLLVM=1 O=/tmp/build/perf -C tools/perf install-bin

Otherwise you'll get this when trying to do the 'perf test' call above:

  # perf test clang
  51: builtin clang support                      : Skip (not compiled in)
  #

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexei Starovoitov <ast@fb.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Joe Stringer <joe@ovn.org>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/20161126070354.141764-11-wangnan0@huawei.com
[ Removed "Test" from descriptions, redundant and already removed from all the other entries ]
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 00b86691c77c6576861b82a3cfe4d609800758fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/tests/Build
#	tools/perf/tests/builtin-test.c
#	tools/perf/tests/tests.h
diff --cc tools/perf/tests/Build
index 40bdfc01aafe,6676c2dd6dcb..000000000000
--- a/tools/perf/tests/Build
+++ b/tools/perf/tests/Build
@@@ -43,9 -43,37 +43,13 @@@ perf-y += sdt.
  perf-y += is_printable_array.o
  perf-y += bitmap.o
  perf-y += perf-hooks.o
++<<<<<<< HEAD
 +perf-y += unit_number__scnprintf.o
++=======
+ perf-y += clang.o
++>>>>>>> 00b86691c77c (perf clang: Add builtin clang support ant test case)
  
 -$(OUTPUT)tests/llvm-src-base.c: tests/bpf-script-example.c tests/Build
 -	$(call rule_mkdir)
 -	$(Q)echo '#include <tests/llvm.h>' > $@
 -	$(Q)echo 'const char test_llvm__bpf_base_prog[] =' >> $@
 -	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
 -	$(Q)echo ';' >> $@
 -
 -$(OUTPUT)tests/llvm-src-kbuild.c: tests/bpf-script-test-kbuild.c tests/Build
 -	$(call rule_mkdir)
 -	$(Q)echo '#include <tests/llvm.h>' > $@
 -	$(Q)echo 'const char test_llvm__bpf_test_kbuild_prog[] =' >> $@
 -	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
 -	$(Q)echo ';' >> $@
 -
 -$(OUTPUT)tests/llvm-src-prologue.c: tests/bpf-script-test-prologue.c tests/Build
 -	$(call rule_mkdir)
 -	$(Q)echo '#include <tests/llvm.h>' > $@
 -	$(Q)echo 'const char test_llvm__bpf_test_prologue_prog[] =' >> $@
 -	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
 -	$(Q)echo ';' >> $@
 -
 -$(OUTPUT)tests/llvm-src-relocation.c: tests/bpf-script-test-relocation.c tests/Build
 -	$(call rule_mkdir)
 -	$(Q)echo '#include <tests/llvm.h>' > $@
 -	$(Q)echo 'const char test_llvm__bpf_test_relocation[] =' >> $@
 -	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
 -	$(Q)echo ';' >> $@
 -
 -ifeq ($(ARCH),$(filter $(ARCH),x86 arm arm64 powerpc))
 +ifeq ($(SRCARCH),$(filter $(SRCARCH),x86 arm arm64 powerpc))
  perf-$(CONFIG_DWARF_UNWIND) += dwarf-unwind.o
  endif
  
diff --cc tools/perf/tests/builtin-test.c
index aacfc58dac2b,23605202d4a1..000000000000
--- a/tools/perf/tests/builtin-test.c
+++ b/tools/perf/tests/builtin-test.c
@@@ -239,8 -234,13 +239,18 @@@ static struct test generic_tests[] = 
  		.func = test__perf_hooks,
  	},
  	{
++<<<<<<< HEAD
 +		.desc = "unit_number__scnprintf",
 +		.func = test__unit_number__scnprint,
++=======
+ 		.desc = "builtin clang support",
+ 		.func = test__clang,
+ 		.subtest = {
+ 			.skip_if_fail	= true,
+ 			.get_nr		= test__clang_subtest_get_nr,
+ 			.get_desc	= test__clang_subtest_get_desc,
+ 		}
++>>>>>>> 00b86691c77c (perf clang: Add builtin clang support ant test case)
  	},
  	{
  		.func = NULL,
diff --cc tools/perf/tests/tests.h
index ebc72c7359d4,0d7b251305af..000000000000
--- a/tools/perf/tests/tests.h
+++ b/tools/perf/tests/tests.h
@@@ -39,61 -37,64 +39,122 @@@ struct test 
  };
  
  /* Tests */
++<<<<<<< HEAD
 +int test__vmlinux_matches_kallsyms(struct test *test, int subtest);
 +int test__openat_syscall_event(struct test *test, int subtest);
 +int test__openat_syscall_event_on_all_cpus(struct test *test, int subtest);
 +int test__basic_mmap(struct test *test, int subtest);
 +int test__PERF_RECORD(struct test *test, int subtest);
 +int test__perf_evsel__roundtrip_name_test(struct test *test, int subtest);
 +int test__perf_evsel__tp_sched_test(struct test *test, int subtest);
 +int test__syscall_openat_tp_fields(struct test *test, int subtest);
 +int test__pmu(struct test *test, int subtest);
 +int test__attr(struct test *test, int subtest);
 +int test__dso_data(struct test *test, int subtest);
 +int test__dso_data_cache(struct test *test, int subtest);
 +int test__dso_data_reopen(struct test *test, int subtest);
 +int test__parse_events(struct test *test, int subtest);
 +int test__hists_link(struct test *test, int subtest);
 +int test__python_use(struct test *test, int subtest);
 +int test__bp_signal(struct test *test, int subtest);
 +int test__bp_signal_overflow(struct test *test, int subtest);
 +int test__task_exit(struct test *test, int subtest);
 +int test__mem(struct test *test, int subtest);
 +int test__sw_clock_freq(struct test *test, int subtest);
 +int test__code_reading(struct test *test, int subtest);
 +int test__sample_parsing(struct test *test, int subtest);
 +int test__keep_tracking(struct test *test, int subtest);
 +int test__parse_no_sample_id_all(struct test *test, int subtest);
 +int test__dwarf_unwind(struct test *test, int subtest);
 +int test__expr(struct test *test, int subtest);
 +int test__hists_filter(struct test *test, int subtest);
 +int test__mmap_thread_lookup(struct test *test, int subtest);
 +int test__thread_mg_share(struct test *test, int subtest);
 +int test__hists_output(struct test *test, int subtest);
 +int test__hists_cumulate(struct test *test, int subtest);
 +int test__switch_tracking(struct test *test, int subtest);
 +int test__fdarray__filter(struct test *test, int subtest);
 +int test__fdarray__add(struct test *test, int subtest);
 +int test__kmod_path__parse(struct test *test, int subtest);
 +int test__thread_map(struct test *test, int subtest);
 +int test__session_topology(struct test *test, int subtest);
 +int test__thread_map_synthesize(struct test *test, int subtest);
 +int test__thread_map_remove(struct test *test, int subtest);
 +int test__cpu_map_synthesize(struct test *test, int subtest);
 +int test__synthesize_stat_config(struct test *test, int subtest);
 +int test__synthesize_stat(struct test *test, int subtest);
 +int test__synthesize_stat_round(struct test *test, int subtest);
 +int test__event_update(struct test *test, int subtest);
 +int test__event_times(struct test *test, int subtest);
 +int test__backward_ring_buffer(struct test *test, int subtest);
 +int test__cpu_map_print(struct test *test, int subtest);
 +int test__sdt_event(struct test *test, int subtest);
 +int test__is_printable_array(struct test *test, int subtest);
 +int test__bitmap_print(struct test *test, int subtest);
 +int test__perf_hooks(struct test *test, int subtest);
 +int test__unit_number__scnprint(struct test *test, int subtest);
 +
 +bool test__bp_signal_is_supported(void);
++=======
+ int test__vmlinux_matches_kallsyms(int subtest);
+ int test__openat_syscall_event(int subtest);
+ int test__openat_syscall_event_on_all_cpus(int subtest);
+ int test__basic_mmap(int subtest);
+ int test__PERF_RECORD(int subtest);
+ int test__perf_evsel__roundtrip_name_test(int subtest);
+ int test__perf_evsel__tp_sched_test(int subtest);
+ int test__syscall_openat_tp_fields(int subtest);
+ int test__pmu(int subtest);
+ int test__attr(int subtest);
+ int test__dso_data(int subtest);
+ int test__dso_data_cache(int subtest);
+ int test__dso_data_reopen(int subtest);
+ int test__parse_events(int subtest);
+ int test__hists_link(int subtest);
+ int test__python_use(int subtest);
+ int test__bp_signal(int subtest);
+ int test__bp_signal_overflow(int subtest);
+ int test__task_exit(int subtest);
+ int test__sw_clock_freq(int subtest);
+ int test__code_reading(int subtest);
+ int test__sample_parsing(int subtest);
+ int test__keep_tracking(int subtest);
+ int test__parse_no_sample_id_all(int subtest);
+ int test__dwarf_unwind(int subtest);
+ int test__hists_filter(int subtest);
+ int test__mmap_thread_lookup(int subtest);
+ int test__thread_mg_share(int subtest);
+ int test__hists_output(int subtest);
+ int test__hists_cumulate(int subtest);
+ int test__switch_tracking(int subtest);
+ int test__fdarray__filter(int subtest);
+ int test__fdarray__add(int subtest);
+ int test__kmod_path__parse(int subtest);
+ int test__thread_map(int subtest);
+ int test__llvm(int subtest);
+ const char *test__llvm_subtest_get_desc(int subtest);
+ int test__llvm_subtest_get_nr(void);
+ int test__bpf(int subtest);
+ const char *test__bpf_subtest_get_desc(int subtest);
+ int test__bpf_subtest_get_nr(void);
+ int test_session_topology(int subtest);
+ int test__thread_map_synthesize(int subtest);
+ int test__cpu_map_synthesize(int subtest);
+ int test__synthesize_stat_config(int subtest);
+ int test__synthesize_stat(int subtest);
+ int test__synthesize_stat_round(int subtest);
+ int test__event_update(int subtest);
+ int test__event_times(int subtest);
+ int test__backward_ring_buffer(int subtest);
+ int test__cpu_map_print(int subtest);
+ int test__sdt_event(int subtest);
+ int test__is_printable_array(int subtest);
+ int test__bitmap_print(int subtest);
+ int test__perf_hooks(int subtest);
+ int test__clang(int subtest);
+ const char *test__clang_subtest_get_desc(int subtest);
+ int test__clang_subtest_get_nr(void);
++>>>>>>> 00b86691c77c (perf clang: Add builtin clang support ant test case)
  
  #if defined(__arm__) || defined(__aarch64__)
  #ifdef HAVE_DWARF_UNWIND_SUPPORT
* Unmerged path tools/perf/tests/Build
* Unmerged path tools/perf/tests/builtin-test.c
diff --git a/tools/perf/tests/clang.c b/tools/perf/tests/clang.c
new file mode 100644
index 000000000000..636d6d0e9037
--- /dev/null
+++ b/tools/perf/tests/clang.c
@@ -0,0 +1,42 @@
+#include "tests.h"
+#include "debug.h"
+#include "util.h"
+#include "c++/clang-c.h"
+
+static struct {
+	int (*func)(void);
+	const char *desc;
+} clang_testcase_table[] = {
+#ifdef HAVE_LIBCLANGLLVM_SUPPORT
+	{
+		.func = test__clang_to_IR,
+		.desc = "builtin clang compile C source to IR",
+	},
+#endif
+};
+
+int test__clang_subtest_get_nr(void)
+{
+	return (int)ARRAY_SIZE(clang_testcase_table);
+}
+
+const char *test__clang_subtest_get_desc(int i)
+{
+	if (i < 0 || i >= (int)ARRAY_SIZE(clang_testcase_table))
+		return NULL;
+	return clang_testcase_table[i].desc;
+}
+
+#ifndef HAVE_LIBCLANGLLVM_SUPPORT
+int test__clang(int i __maybe_unused)
+{
+	return TEST_SKIP;
+}
+#else
+int test__clang(int i __maybe_unused)
+{
+	if (i < 0 || i >= (int)ARRAY_SIZE(clang_testcase_table))
+		return TEST_FAIL;
+	return clang_testcase_table[i].func();
+}
+#endif
* Unmerged path tools/perf/tests/tests.h
diff --git a/tools/perf/util/Build b/tools/perf/util/Build
index 6be76ae5c66f..ac20d238d9ca 100644
--- a/tools/perf/util/Build
+++ b/tools/perf/util/Build
@@ -137,6 +137,8 @@ endif
 
 libperf-y += perf-hooks.o
 
+libperf-$(CONFIG_CXX) += c++/
+
 CFLAGS_config.o   += -DETC_PERFCONFIG="BUILD_STR($(ETC_PERFCONFIG_SQ))"
 # avoid compiler warnings in 32-bit mode
 CFLAGS_genelf_debug.o  += -Wno-packed
diff --git a/tools/perf/util/c++/Build b/tools/perf/util/c++/Build
new file mode 100644
index 000000000000..988fef1b11d7
--- /dev/null
+++ b/tools/perf/util/c++/Build
@@ -0,0 +1,2 @@
+libperf-$(CONFIG_CLANGLLVM) += clang.o
+libperf-$(CONFIG_CLANGLLVM) += clang-test.o
diff --git a/tools/perf/util/c++/clang-c.h b/tools/perf/util/c++/clang-c.h
new file mode 100644
index 000000000000..dcde4b564f3b
--- /dev/null
+++ b/tools/perf/util/c++/clang-c.h
@@ -0,0 +1,16 @@
+#ifndef PERF_UTIL_CLANG_C_H
+#define PERF_UTIL_CLANG_C_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void perf_clang__init(void);
+extern void perf_clang__cleanup(void);
+
+extern int test__clang_to_IR(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/tools/perf/util/c++/clang-test.cpp b/tools/perf/util/c++/clang-test.cpp
new file mode 100644
index 000000000000..3da6bfa4bc54
--- /dev/null
+++ b/tools/perf/util/c++/clang-test.cpp
@@ -0,0 +1,31 @@
+#include "clang.h"
+#include "clang-c.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/LLVMContext.h"
+
+class perf_clang_scope {
+public:
+	explicit perf_clang_scope() {perf_clang__init();}
+	~perf_clang_scope() {perf_clang__cleanup();}
+};
+
+extern "C" {
+
+int test__clang_to_IR(void)
+{
+	perf_clang_scope _scope;
+
+	std::unique_ptr<llvm::Module> M =
+		perf::getModuleFromSource("perf-test.c",
+					  "int myfunc(void) {return 1;}");
+
+	if (!M)
+		return -1;
+
+	for (llvm::Function& F : *M)
+		if (F.getName() == "myfunc")
+			return 0;
+	return -1;
+}
+
+}
diff --git a/tools/perf/util/c++/clang.cpp b/tools/perf/util/c++/clang.cpp
new file mode 100644
index 000000000000..c17b1176e25d
--- /dev/null
+++ b/tools/perf/util/c++/clang.cpp
@@ -0,0 +1,96 @@
+/*
+ * llvm C frontend for perf. Support dynamically compile C file
+ *
+ * Inspired by clang example code:
+ * http://llvm.org/svn/llvm-project/cfe/trunk/examples/clang-interpreter/main.cpp
+ *
+ * Copyright (C) 2016 Wang Nan <wangnan0@huawei.com>
+ * Copyright (C) 2016 Huawei Inc.
+ */
+
+#include "clang/CodeGen/CodeGenAction.h"
+#include "clang/Frontend/CompilerInvocation.h"
+#include "clang/Frontend/CompilerInstance.h"
+#include "clang/Frontend/TextDiagnosticPrinter.h"
+#include "clang/Tooling/Tooling.h"
+#include "llvm/IR/Module.h"
+#include "llvm/Option/Option.h"
+#include "llvm/Support/ManagedStatic.h"
+#include <memory>
+
+#include "clang.h"
+#include "clang-c.h"
+
+namespace perf {
+
+static std::unique_ptr<llvm::LLVMContext> LLVMCtx;
+
+using namespace clang;
+
+static vfs::InMemoryFileSystem *
+buildVFS(StringRef& Name, StringRef& Content)
+{
+	vfs::InMemoryFileSystem *VFS = new vfs::InMemoryFileSystem(true);
+	VFS->addFile(Twine(Name), 0, llvm::MemoryBuffer::getMemBuffer(Content));
+	return VFS;
+}
+
+static CompilerInvocation *
+createCompilerInvocation(StringRef& Path, DiagnosticsEngine& Diags)
+{
+	llvm::opt::ArgStringList CCArgs {
+		"-cc1",
+		"-triple", "bpf-pc-linux",
+		"-fsyntax-only",
+		"-ferror-limit", "19",
+		"-fmessage-length", "127",
+		"-O2",
+		"-nostdsysteminc",
+		"-nobuiltininc",
+		"-vectorize-loops",
+		"-vectorize-slp",
+		"-Wno-unused-value",
+		"-Wno-pointer-sign",
+		"-x", "c"};
+	CompilerInvocation *CI = tooling::newInvocation(&Diags, CCArgs);
+
+	FrontendOptions& Opts = CI->getFrontendOpts();
+	Opts.Inputs.clear();
+	Opts.Inputs.emplace_back(Path, IK_C);
+	return CI;
+}
+
+std::unique_ptr<llvm::Module>
+getModuleFromSource(StringRef Name, StringRef Content)
+{
+	CompilerInstance Clang;
+	Clang.createDiagnostics();
+
+	IntrusiveRefCntPtr<vfs::FileSystem> VFS = buildVFS(Name, Content);
+	Clang.setVirtualFileSystem(&*VFS);
+
+	IntrusiveRefCntPtr<CompilerInvocation> CI =
+		createCompilerInvocation(Name, Clang.getDiagnostics());
+	Clang.setInvocation(&*CI);
+
+	std::unique_ptr<CodeGenAction> Act(new EmitLLVMOnlyAction(&*LLVMCtx));
+	if (!Clang.ExecuteAction(*Act))
+		return std::unique_ptr<llvm::Module>(nullptr);
+
+	return Act->takeModule();
+}
+
+}
+
+extern "C" {
+void perf_clang__init(void)
+{
+	perf::LLVMCtx.reset(new llvm::LLVMContext());
+}
+
+void perf_clang__cleanup(void)
+{
+	perf::LLVMCtx.reset(nullptr);
+	llvm::llvm_shutdown();
+}
+}
diff --git a/tools/perf/util/c++/clang.h b/tools/perf/util/c++/clang.h
new file mode 100644
index 000000000000..f64483be43d0
--- /dev/null
+++ b/tools/perf/util/c++/clang.h
@@ -0,0 +1,16 @@
+#ifndef PERF_UTIL_CLANG_H
+#define PERF_UTIL_CLANG_H
+
+#include "llvm/ADT/StringRef.h"
+#include "llvm/IR/LLVMContext.h"
+#include "llvm/IR/Module.h"
+#include <memory>
+namespace perf {
+
+using namespace llvm;
+
+std::unique_ptr<Module>
+getModuleFromSource(StringRef Name, StringRef Content);
+
+}
+#endif
