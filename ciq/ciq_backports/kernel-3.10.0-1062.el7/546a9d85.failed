rcu: Export debug_init_rcu_head() and and debug_init_rcu_head()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Paul E. McKenney <paulmck@linux.vnet.ibm.com>
commit 546a9d8519ed137b2804a3f5a3659003039dd49c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/546a9d85.failed

Currently, call_rcu() relies on implicit allocation and initialization
for the debug-objects handling of RCU callbacks.  If you hammer the
kernel hard enough with Sasha's modified version of trinity, you can end
up with the sl*b allocators recursing into themselves via this implicit
call_rcu() allocation.

This commit therefore exports the debug_init_rcu_head() and
debug_rcu_head_free() functions, which permits the allocators to allocated
and pre-initialize the debug-objects information, so that there no longer
any need for call_rcu() to do that initialization, which in turn prevents
the recursion into the memory allocators.

	Reported-by: Sasha Levin <sasha.levin@oracle.com>
	Suggested-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Acked-by: Thomas Gleixner <tglx@linutronix.de>
Looks-good-to: Christoph Lameter <cl@linux.com>
(cherry picked from commit 546a9d8519ed137b2804a3f5a3659003039dd49c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/rcupdate.h
diff --cc include/linux/rcupdate.h
index 68df10240cb4,13bbfbde41b9..000000000000
--- a/include/linux/rcupdate.h
+++ b/include/linux/rcupdate.h
@@@ -314,9 -358,19 +314,24 @@@ void wait_rcu_gp(call_rcu_func_t crf)
   * initialization.
   */
  #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD
++<<<<<<< HEAD
 +extern void init_rcu_head_on_stack(struct rcu_head *head);
 +extern void destroy_rcu_head_on_stack(struct rcu_head *head);
++=======
+ void init_rcu_head(struct rcu_head *head);
+ void destroy_rcu_head(struct rcu_head *head);
+ void init_rcu_head_on_stack(struct rcu_head *head);
+ void destroy_rcu_head_on_stack(struct rcu_head *head);
++>>>>>>> 546a9d8519ed (rcu: Export debug_init_rcu_head() and and debug_init_rcu_head())
  #else /* !CONFIG_DEBUG_OBJECTS_RCU_HEAD */
+ static inline void init_rcu_head(struct rcu_head *head)
+ {
+ }
+ 
+ static inline void destroy_rcu_head(struct rcu_head *head)
+ {
+ }
+ 
  static inline void init_rcu_head_on_stack(struct rcu_head *head)
  {
  }
* Unmerged path include/linux/rcupdate.h
diff --git a/kernel/rcupdate.c b/kernel/rcupdate.c
index 913f1fe04ecc..8addc0894f24 100644
--- a/kernel/rcupdate.c
+++ b/kernel/rcupdate.c
@@ -228,12 +228,12 @@ EXPORT_SYMBOL_GPL(rcu_my_thread_group_empty);
 #endif /* #ifdef CONFIG_PROVE_RCU */
 
 #ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD
-static inline void debug_init_rcu_head(struct rcu_head *head)
+void init_rcu_head(struct rcu_head *head)
 {
 	debug_object_init(head, &rcuhead_debug_descr);
 }
 
-static inline void debug_rcu_head_free(struct rcu_head *head)
+void destroy_rcu_head(struct rcu_head *head)
 {
 	debug_object_free(head, &rcuhead_debug_descr);
 }
