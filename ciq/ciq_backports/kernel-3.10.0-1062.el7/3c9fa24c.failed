kvm: x86: use correct privilege level for sgdt/sidt/fxsave/fxrstor access

jira LE-1907
cve CVE-2018-10853
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 3c9fa24ca7c9c47605672916491f79e8ccacb9e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3c9fa24c.failed

The functions that were used in the emulation of fxrstor, fxsave, sgdt and
sidt were originally meant for task switching, and as such they did not
check privilege levels.  This is very bad when the same functions are used
in the emulation of unprivileged instructions.  This is CVE-2018-10853.

The obvious fix is to add a new argument to ops->read_std and ops->write_std,
which decides whether the access is a "system" access or should use the
processor's CPL.

Fixes: 129a72a0d3c8 ("KVM: x86: Introduce segmented_write_std", 2017-01-12)
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 3c9fa24ca7c9c47605672916491f79e8ccacb9e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index bc19a3517278,439fb0c7dbc0..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -4350,12 -4809,17 +4350,23 @@@ int kvm_read_guest_virt(struct x86_emul
  }
  EXPORT_SYMBOL_GPL(kvm_read_guest_virt);
  
++<<<<<<< HEAD
 +static int kvm_read_guest_virt_system(struct x86_emulate_ctxt *ctxt,
 +				      gva_t addr, void *val, unsigned int bytes,
 +				      struct x86_exception *exception)
++=======
+ static int emulator_read_std(struct x86_emulate_ctxt *ctxt,
+ 			     gva_t addr, void *val, unsigned int bytes,
+ 			     struct x86_exception *exception, bool system)
++>>>>>>> 3c9fa24ca7c9 (kvm: x86: use correct privilege level for sgdt/sidt/fxsave/fxrstor access)
  {
  	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);
- 	return kvm_read_guest_virt_helper(addr, val, bytes, vcpu, 0, exception);
+ 	u32 access = 0;
+ 
+ 	if (!system && kvm_x86_ops->get_cpl(vcpu) == 3)
+ 		access |= PFERR_USER_MASK;
+ 
+ 	return kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access, exception);
  }
  
  static int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,
@@@ -4402,8 -4861,68 +4413,73 @@@ int kvm_write_guest_virt_system(struct 
  out:
  	return r;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(kvm_write_guest_virt_system);
 +
++=======
+ 
+ static int emulator_write_std(struct x86_emulate_ctxt *ctxt, gva_t addr, void *val,
+ 			      unsigned int bytes, struct x86_exception *exception,
+ 			      bool system)
+ {
+ 	struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);
+ 	u32 access = PFERR_WRITE_MASK;
+ 
+ 	if (!system && kvm_x86_ops->get_cpl(vcpu) == 3)
+ 		access |= PFERR_USER_MASK;
+ 
+ 	return kvm_write_guest_virt_helper(addr, val, bytes, vcpu,
+ 					   access, exception);
+ }
+ 
+ int kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val,
+ 				unsigned int bytes, struct x86_exception *exception)
+ {
+ 	return kvm_write_guest_virt_helper(addr, val, bytes, vcpu,
+ 					   PFERR_WRITE_MASK, exception);
+ }
+ EXPORT_SYMBOL_GPL(kvm_write_guest_virt_system);
+ 
+ int handle_ud(struct kvm_vcpu *vcpu)
+ {
+ 	int emul_type = EMULTYPE_TRAP_UD;
+ 	enum emulation_result er;
+ 	char sig[5]; /* ud2; .ascii "kvm" */
+ 	struct x86_exception e;
+ 
+ 	if (force_emulation_prefix &&
+ 	    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),
+ 				sig, sizeof(sig), &e) == 0 &&
+ 	    memcmp(sig, "\xf\xbkvm", sizeof(sig)) == 0) {
+ 		kvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig));
+ 		emul_type = 0;
+ 	}
+ 
+ 	er = emulate_instruction(vcpu, emul_type);
+ 	if (er == EMULATE_USER_EXIT)
+ 		return 0;
+ 	if (er != EMULATE_DONE)
+ 		kvm_queue_exception(vcpu, UD_VECTOR);
+ 	return 1;
+ }
+ EXPORT_SYMBOL_GPL(handle_ud);
+ 
+ static int vcpu_is_mmio_gpa(struct kvm_vcpu *vcpu, unsigned long gva,
+ 			    gpa_t gpa, bool write)
+ {
+ 	/* For APIC access vmexit */
+ 	if ((gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)
+ 		return 1;
+ 
+ 	if (vcpu_match_mmio_gpa(vcpu, gpa)) {
+ 		trace_vcpu_match_mmio(gva, gpa, write, true);
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 3c9fa24ca7c9 (kvm: x86: use correct privilege level for sgdt/sidt/fxsave/fxrstor access)
  static int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,
  				gpa_t *gpa, struct x86_exception *exception,
  				bool write)
diff --git a/arch/x86/include/asm/kvm_emulate.h b/arch/x86/include/asm/kvm_emulate.h
index 74d8b1afca6a..321ab10efe85 100644
--- a/arch/x86/include/asm/kvm_emulate.h
+++ b/arch/x86/include/asm/kvm_emulate.h
@@ -105,11 +105,12 @@ struct x86_emulate_ops {
 	 *  @addr:  [IN ] Linear address from which to read.
 	 *  @val:   [OUT] Value read from memory, zero-extended to 'u_long'.
 	 *  @bytes: [IN ] Number of bytes to read from memory.
+	 *  @system:[IN ] Whether the access is forced to be at CPL0.
 	 */
 	int (*read_std)(struct x86_emulate_ctxt *ctxt,
 			unsigned long addr, void *val,
 			unsigned int bytes,
-			struct x86_exception *fault);
+			struct x86_exception *fault, bool system);
 
 	/*
 	 * read_phys: Read bytes of standard (non-emulated/special) memory.
@@ -127,10 +128,11 @@ struct x86_emulate_ops {
 	 *  @addr:  [IN ] Linear address to which to write.
 	 *  @val:   [OUT] Value write to memory, zero-extended to 'u_long'.
 	 *  @bytes: [IN ] Number of bytes to write to memory.
+	 *  @system:[IN ] Whether the access is forced to be at CPL0.
 	 */
 	int (*write_std)(struct x86_emulate_ctxt *ctxt,
 			 unsigned long addr, void *val, unsigned int bytes,
-			 struct x86_exception *fault);
+			 struct x86_exception *fault, bool system);
 	/*
 	 * fetch: Read bytes of standard (non-emulated/special) memory.
 	 *        Used for instruction fetch.
diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index 1bb59fe472ae..d0c22fefcd63 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -829,14 +829,14 @@ static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)
 static int linear_read_system(struct x86_emulate_ctxt *ctxt, ulong linear,
 			      void *data, unsigned size)
 {
-	return ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception);
+	return ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception, true);
 }
 
 static int linear_write_system(struct x86_emulate_ctxt *ctxt,
 			       ulong linear, void *data,
 			       unsigned int size)
 {
-	return ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception);
+	return ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception, true);
 }
 
 static int segmented_read_std(struct x86_emulate_ctxt *ctxt,
@@ -850,7 +850,7 @@ static int segmented_read_std(struct x86_emulate_ctxt *ctxt,
 	rc = linearize(ctxt, addr, size, false, &linear);
 	if (rc != X86EMUL_CONTINUE)
 		return rc;
-	return ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception);
+	return ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception, false);
 }
 
 static int segmented_write_std(struct x86_emulate_ctxt *ctxt,
@@ -864,7 +864,7 @@ static int segmented_write_std(struct x86_emulate_ctxt *ctxt,
 	rc = linearize(ctxt, addr, size, true, &linear);
 	if (rc != X86EMUL_CONTINUE)
 		return rc;
-	return ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception);
+	return ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception, false);
 }
 
 /*
@@ -2945,12 +2945,12 @@ static bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,
 #ifdef CONFIG_X86_64
 	base |= ((u64)base3) << 32;
 #endif
-	r = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);
+	r = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL, true);
 	if (r != X86EMUL_CONTINUE)
 		return false;
 	if (io_bitmap_ptr + port/8 > desc_limit_scaled(&tr_seg))
 		return false;
-	r = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL);
+	r = ops->read_std(ctxt, base + io_bitmap_ptr + port/8, &perm, 2, NULL, true);
 	if (r != X86EMUL_CONTINUE)
 		return false;
 	if ((perm >> bit_idx) & mask)
* Unmerged path arch/x86/kvm/x86.c
