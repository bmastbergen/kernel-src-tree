fuse: clear FUSE_I_CTIME_DIRTY flag on setattr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Maxim Patlasov <MPatlasov@parallels.com>
commit 3ad22c62dd23ad26c8737c300f455de60ba01f40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3ad22c62.failed

The patch addresses two use-cases when the flag may be safely cleared:

1. fuse_do_setattr() is called with ATTR_CTIME flag set in attr->ia_valid.
In this case attr->ia_ctime bears actual value. In-kernel fuse must send it
to the userspace server and then assign the value to inode->i_ctime.

2. fuse_do_setattr() is called with ATTR_SIZE flag set in attr->ia_valid,
whereas ATTR_CTIME is not set (truncate(2)).
In this case in-kernel fuse must sent "now" to the userspace server and then
assign the value to inode->i_ctime.

In both cases we could clear I_DIRTY_SYNC, but that needs more thought.

	Signed-off-by: Maxim Patlasov <MPatlasov@parallels.com>
	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit 3ad22c62dd23ad26c8737c300f455de60ba01f40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dir.c
diff --cc fs/fuse/dir.c
index 3e1c8cd01fea,843dcf1222eb..000000000000
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@@ -1573,7 -1517,8 +1573,12 @@@ static bool update_mtime(unsigned ivali
  	return true;
  }
  
++<<<<<<< HEAD
 +static void iattr_to_fattr(struct iattr *iattr, struct fuse_setattr_in *arg)
++=======
+ static void iattr_to_fattr(struct iattr *iattr, struct fuse_setattr_in *arg,
+ 			   bool trust_local_cmtime)
++>>>>>>> 3ad22c62dd23 (fuse: clear FUSE_I_CTIME_DIRTY flag on setattr)
  {
  	unsigned ivalid = iattr->ia_valid;
  
@@@ -1592,13 -1537,18 +1597,26 @@@
  		if (!(ivalid & ATTR_ATIME_SET))
  			arg->valid |= FATTR_ATIME_NOW;
  	}
++<<<<<<< HEAD
 +	if ((ivalid & ATTR_MTIME) && update_mtime(ivalid)) {
 +		arg->valid |= FATTR_MTIME;
 +		arg->mtime = iattr->ia_mtime.tv_sec;
 +		arg->mtimensec = iattr->ia_mtime.tv_nsec;
 +		if (!(ivalid & ATTR_MTIME_SET))
++=======
+ 	if ((ivalid & ATTR_MTIME) && update_mtime(ivalid, trust_local_cmtime)) {
+ 		arg->valid |= FATTR_MTIME;
+ 		arg->mtime = iattr->ia_mtime.tv_sec;
+ 		arg->mtimensec = iattr->ia_mtime.tv_nsec;
+ 		if (!(ivalid & ATTR_MTIME_SET) && !trust_local_cmtime)
++>>>>>>> 3ad22c62dd23 (fuse: clear FUSE_I_CTIME_DIRTY flag on setattr)
  			arg->valid |= FATTR_MTIME_NOW;
  	}
+ 	if ((ivalid & ATTR_CTIME) && trust_local_cmtime) {
+ 		arg->valid |= FATTR_CTIME;
+ 		arg->ctime = iattr->ia_ctime.tv_sec;
+ 		arg->ctimensec = iattr->ia_ctime.tv_nsec;
+ 	}
  }
  
  /*
@@@ -1665,6 -1671,7 +1683,10 @@@ int fuse_do_setattr(struct inode *inode
  	bool is_wb = fc->writeback_cache;
  	loff_t oldsize;
  	int err;
++<<<<<<< HEAD
++=======
+ 	bool trust_local_cmtime = is_wb && S_ISREG(inode->i_mode);
++>>>>>>> 3ad22c62dd23 (fuse: clear FUSE_I_CTIME_DIRTY flag on setattr)
  
  	if (!(fc->flags & FUSE_DEFAULT_PERMISSIONS))
  		attr->ia_valid |= ATTR_FORCE;
@@@ -1695,7 -1702,7 +1717,11 @@@
  
  	memset(&inarg, 0, sizeof(inarg));
  	memset(&outarg, 0, sizeof(outarg));
++<<<<<<< HEAD
 +	iattr_to_fattr(attr, &inarg);
++=======
+ 	iattr_to_fattr(attr, &inarg, trust_local_cmtime);
++>>>>>>> 3ad22c62dd23 (fuse: clear FUSE_I_CTIME_DIRTY flag on setattr)
  	if (file) {
  		struct fuse_file *ff = file->private_data;
  		inarg.valid |= FATTR_FH;
@@@ -1733,6 -1730,15 +1759,18 @@@
  	}
  
  	spin_lock(&fc->lock);
++<<<<<<< HEAD
++=======
+ 	/* the kernel maintains i_mtime locally */
+ 	if (trust_local_cmtime) {
+ 		if (attr->ia_valid & ATTR_MTIME)
+ 			inode->i_mtime = attr->ia_mtime;
+ 		if (attr->ia_valid & ATTR_CTIME)
+ 			inode->i_ctime = attr->ia_ctime;
+ 		/* FIXME: clear I_DIRTY_SYNC? */
+ 	}
+ 
++>>>>>>> 3ad22c62dd23 (fuse: clear FUSE_I_CTIME_DIRTY flag on setattr)
  	fuse_change_attributes_common(inode, &outarg.attr,
  				      attr_timeout(&outarg));
  	oldsize = inode->i_size;
* Unmerged path fs/fuse/dir.c
