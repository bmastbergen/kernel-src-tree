memcg, kmem: use cache_from_memcg_idx instead of hard code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Qiang Huang <h.huangqiang@huawei.com>
commit 7a67d7abcc8da30a16ed64c3909d3fea004bde93
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7a67d7ab.failed

	Signed-off-by: Qiang Huang <h.huangqiang@huawei.com>
	Reviewed-by: Pekka Enberg <penberg@kernel.org>
	Acked-by: David Rientjes <rientjes@google.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@suse.cz>
	Cc: Glauber Costa <glommer@parallels.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 7a67d7abcc8da30a16ed64c3909d3fea004bde93)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index 5a271ae6c0ad,3d4bb07c7679..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -3454,7 -3389,15 +3454,15 @@@ static struct kmem_cache *memcg_create_
  
  	BUG_ON(!memcg_can_account_kmem(memcg));
  
 -	idx = memcg_cache_id(memcg);
 -
  	mutex_lock(&memcg_cache_mutex);
++<<<<<<< HEAD
++=======
+ 	new_cachep = cache_from_memcg_idx(cachep, idx);
+ 	if (new_cachep) {
+ 		css_put(&memcg->css);
+ 		goto out;
+ 	}
++>>>>>>> 7a67d7abcc8d (memcg, kmem: use cache_from_memcg_idx instead of hard code)
  
  	new_cachep = kmem_cache_dup(memcg, cachep);
  	if (new_cachep == NULL) {
@@@ -3482,11 -3436,11 +3490,17 @@@ int __kmem_cache_destroy_memcg_children
  	 *
  	 * Still, we don't want anyone else freeing memcg_caches under our
  	 * noses, which can happen if a new memcg comes to life. As usual,
 -	 * we'll take the set_limit_mutex to protect ourselves against this.
 +	 * we'll take the memcg_limit_mutex to protect ourselves against this.
  	 */
++<<<<<<< HEAD
 +	mutex_lock(&memcg_limit_mutex);
 +	for (i = 0; i < memcg_limited_groups_array_size; i++) {
 +		c = s->memcg_params->memcg_caches[i];
++=======
+ 	mutex_lock(&set_limit_mutex);
+ 	for_each_memcg_cache_index(i) {
+ 		c = cache_from_memcg_idx(s, i);
++>>>>>>> 7a67d7abcc8d (memcg, kmem: use cache_from_memcg_idx instead of hard code)
  		if (!c)
  			continue;
  
* Unmerged path mm/memcontrol.c
