autofs: add AUTOFS_EXP_FORCED flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ian Kent <raven@themaw.net>
commit cbf6898fd69455092c43cd573b38d42c86ddb1e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/cbf6898f.failed

The userspace automount(8) daemon is meant to perform a forced expire when
sent a SIGUSR2.

But since the expiration is routed through the kernel and the kernel
doesn't send an expire request if the mount is busy this hasn't worked at
least since autofs version 5.

Add an AUTOFS_EXP_FORCED flag to allow implemention of the feature and
bump the protocol version so user space can check if it's implemented if
needed.

Link: http://lkml.kernel.org/r/152937734715.21213.6594007182776598970.stgit@pluto.themaw.net
	Signed-off-by: Ian Kent <raven@themaw.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit cbf6898fd69455092c43cd573b38d42c86ddb1e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/autofs4/expire.c
#	include/uapi/linux/auto_fs.h
diff --cc fs/autofs4/expire.c
index 0f4f1d4ac0bf,d441244b79df..000000000000
--- a/fs/autofs4/expire.c
+++ b/fs/autofs4/expire.c
@@@ -29,7 -29,8 +29,12 @@@ static inline int autofs4_can_expire(st
  }
  
  /* Check a mount point for busyness */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +static int autofs4_mount_busy(struct vfsmount *mnt, struct dentry *dentry)
++=======
+ static int autofs_mount_busy(struct vfsmount *mnt,
+ 			     struct dentry *dentry, unsigned int how)
++>>>>>>> cbf6898fd694 (autofs: add AUTOFS_EXP_FORCED flag):fs/autofs/expire.c
  {
  	struct dentry *top = dentry;
  	struct path path = {.mnt = mnt, .dentry = dentry};
@@@ -235,7 -246,7 +250,11 @@@ static int autofs4_tree_busy(struct vfs
  		 * If the fs is busy update the expiry counter.
  		 */
  		if (d_mountpoint(p)) {
++<<<<<<< HEAD:fs/autofs4/expire.c
 +			if (autofs4_mount_busy(mnt, p)) {
++=======
+ 			if (autofs_mount_busy(mnt, p, how)) {
++>>>>>>> cbf6898fd694 (autofs: add AUTOFS_EXP_FORCED flag):fs/autofs/expire.c
  				top_ino->last_used = jiffies;
  				dput(p);
  				return 1;
@@@ -258,8 -269,12 +277,12 @@@
  		}
  	}
  
+ 	/* Forced expire, user space handles busy mounts */
+ 	if (how & AUTOFS_EXP_FORCED)
+ 		return 0;
+ 
  	/* Timeout of a tree mount is ultimately determined by its top dentry */
 -	if (!autofs_can_expire(top, timeout, how))
 +	if (!autofs4_can_expire(top, timeout, do_now))
  		return 1;
  
  	return 0;
@@@ -280,11 -295,17 +303,21 @@@ static struct dentry *autofs4_check_lea
  
  		if (d_mountpoint(p)) {
  			/* Can we umount this guy */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +			if (autofs4_mount_busy(mnt, p))
++=======
+ 			if (autofs_mount_busy(mnt, p, how))
++>>>>>>> cbf6898fd694 (autofs: add AUTOFS_EXP_FORCED flag):fs/autofs/expire.c
  				continue;
  
+ 			/* This isn't a submount so if a forced expire
+ 			 * has been requested, user space handles busy
+ 			 * mounts */
+ 			if (how & AUTOFS_EXP_FORCED)
+ 				return p;
+ 
  			/* Can we expire this guy */
 -			if (autofs_can_expire(p, timeout, how))
 +			if (autofs4_can_expire(p, timeout, do_now))
  				return p;
  		}
  	}
@@@ -364,11 -382,17 +397,21 @@@ static struct dentry *should_expire(str
  		pr_debug("checking mountpoint %p %pd\n", dentry, dentry);
  
  		/* Can we umount this guy */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +		if (autofs4_mount_busy(mnt, dentry))
++=======
+ 		if (autofs_mount_busy(mnt, dentry, how))
++>>>>>>> cbf6898fd694 (autofs: add AUTOFS_EXP_FORCED flag):fs/autofs/expire.c
  			return NULL;
  
+ 		/* This isn't a submount so if a forced expire
+ 		 * has been requested, user space handles busy
+ 		 * mounts */
+ 		if (how & AUTOFS_EXP_FORCED)
+ 			return dentry;
+ 
  		/* Can we expire this guy */
 -		if (autofs_can_expire(dentry, timeout, how))
 +		if (autofs4_can_expire(dentry, timeout, do_now))
  			return dentry;
  		return NULL;
  	}
@@@ -388,27 -417,33 +436,41 @@@
  		return NULL;
  
  	/* Case 2: tree mount, expire iff entire tree is not busy */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +	if (!exp_leaves) {
 +		/* Path walk currently on this dentry? */
 +		ino_count = atomic_read(&ino->count) + 1;
 +		if (d_count(dentry) > ino_count)
 +			return NULL;
++=======
+ 	if (!(how & AUTOFS_EXP_LEAVES)) {
+ 		/* Not a forced expire? */
+ 		if (!(how & AUTOFS_EXP_FORCED)) {
+ 			/* ref-walk currently on this dentry? */
+ 			ino_count = atomic_read(&ino->count) + 1;
+ 			if (d_count(dentry) > ino_count)
+ 				return NULL;
+ 		}
++>>>>>>> cbf6898fd694 (autofs: add AUTOFS_EXP_FORCED flag):fs/autofs/expire.c
  
 -		if (!autofs_tree_busy(mnt, dentry, timeout, how))
 +		if (!autofs4_tree_busy(mnt, dentry, timeout, do_now))
  			return dentry;
  	/*
  	 * Case 3: pseudo direct mount, expire individual leaves
  	 *	   (autofs-4.1).
  	 */
  	} else {
- 		/* Path walk currently on this dentry? */
  		struct dentry *expired;
  
- 		ino_count = atomic_read(&ino->count) + 1;
- 		if (d_count(dentry) > ino_count)
- 			return NULL;
+ 		/* Not a forced expire? */
+ 		if (!(how & AUTOFS_EXP_FORCED)) {
+ 			/* ref-walk currently on this dentry? */
+ 			ino_count = atomic_read(&ino->count) + 1;
+ 			if (d_count(dentry) > ino_count)
+ 				return NULL;
+ 		}
  
 -		expired = autofs_check_leaves(mnt, dentry, timeout, how);
 +		expired = autofs4_check_leaves(mnt, dentry, timeout, do_now);
  		if (expired) {
  			if (expired == dentry)
  				dput(dentry);
diff --cc include/uapi/linux/auto_fs.h
index aa63451ef20a,df31aa9c9a8c..000000000000
--- a/include/uapi/linux/auto_fs.h
+++ b/include/uapi/linux/auto_fs.h
@@@ -17,13 -19,11 +17,17 @@@
  #include <sys/ioctl.h>
  #endif /* __KERNEL__ */
  
 -#define AUTOFS_PROTO_VERSION		5
 -#define AUTOFS_MIN_PROTO_VERSION	3
 -#define AUTOFS_MAX_PROTO_VERSION	5
  
++<<<<<<< HEAD
 +/* This file describes autofs v3 */
 +#define AUTOFS_PROTO_VERSION	3
 +
 +/* Range of protocol versions defined */
 +#define AUTOFS_MAX_PROTO_VERSION	AUTOFS_PROTO_VERSION
 +#define AUTOFS_MIN_PROTO_VERSION	AUTOFS_PROTO_VERSION
++=======
+ #define AUTOFS_PROTO_SUBVERSION		3
++>>>>>>> cbf6898fd694 (autofs: add AUTOFS_EXP_FORCED flag)
  
  /*
   * The wait_queue_token (autofs_wqt_t) is part of a structure which is passed
@@@ -75,9 -75,157 +79,164 @@@ enum 
  #define AUTOFS_IOC_READY        _IO(AUTOFS_IOCTL, AUTOFS_IOC_READY_CMD)
  #define AUTOFS_IOC_FAIL         _IO(AUTOFS_IOCTL, AUTOFS_IOC_FAIL_CMD)
  #define AUTOFS_IOC_CATATONIC    _IO(AUTOFS_IOCTL, AUTOFS_IOC_CATATONIC_CMD)
++<<<<<<< HEAD
 +#define AUTOFS_IOC_PROTOVER     _IOR(AUTOFS_IOCTL, AUTOFS_IOC_PROTOVER_CMD, int)
 +#define AUTOFS_IOC_SETTIMEOUT32 _IOWR(AUTOFS_IOCTL, AUTOFS_IOC_SETTIMEOUT_CMD, compat_ulong_t)
 +#define AUTOFS_IOC_SETTIMEOUT   _IOWR(AUTOFS_IOCTL, AUTOFS_IOC_SETTIMEOUT_CMD, unsigned long)
 +#define AUTOFS_IOC_EXPIRE       _IOR(AUTOFS_IOCTL, AUTOFS_IOC_EXPIRE_CMD, struct autofs_packet_expire)
++=======
+ #define AUTOFS_IOC_PROTOVER     _IOR(AUTOFS_IOCTL, \
+ 				     AUTOFS_IOC_PROTOVER_CMD, int)
+ #define AUTOFS_IOC_SETTIMEOUT32 _IOWR(AUTOFS_IOCTL, \
+ 				      AUTOFS_IOC_SETTIMEOUT_CMD, \
+ 				      compat_ulong_t)
+ #define AUTOFS_IOC_SETTIMEOUT   _IOWR(AUTOFS_IOCTL, \
+ 				      AUTOFS_IOC_SETTIMEOUT_CMD, \
+ 				      unsigned long)
+ #define AUTOFS_IOC_EXPIRE       _IOR(AUTOFS_IOCTL, \
+ 				     AUTOFS_IOC_EXPIRE_CMD, \
+ 				     struct autofs_packet_expire)
+ 
+ /* autofs version 4 and later definitions */
+ 
+ /* Mask for expire behaviour */
+ #define AUTOFS_EXP_NORMAL		0x00
+ #define AUTOFS_EXP_IMMEDIATE		0x01
+ #define AUTOFS_EXP_LEAVES		0x02
+ #define AUTOFS_EXP_FORCED		0x04
+ 
+ #define AUTOFS_TYPE_ANY			0U
+ #define AUTOFS_TYPE_INDIRECT		1U
+ #define AUTOFS_TYPE_DIRECT		2U
+ #define AUTOFS_TYPE_OFFSET		4U
+ 
+ static inline void set_autofs_type_indirect(unsigned int *type)
+ {
+ 	*type = AUTOFS_TYPE_INDIRECT;
+ }
+ 
+ static inline unsigned int autofs_type_indirect(unsigned int type)
+ {
+ 	return (type == AUTOFS_TYPE_INDIRECT);
+ }
+ 
+ static inline void set_autofs_type_direct(unsigned int *type)
+ {
+ 	*type = AUTOFS_TYPE_DIRECT;
+ }
+ 
+ static inline unsigned int autofs_type_direct(unsigned int type)
+ {
+ 	return (type == AUTOFS_TYPE_DIRECT);
+ }
+ 
+ static inline void set_autofs_type_offset(unsigned int *type)
+ {
+ 	*type = AUTOFS_TYPE_OFFSET;
+ }
+ 
+ static inline unsigned int autofs_type_offset(unsigned int type)
+ {
+ 	return (type == AUTOFS_TYPE_OFFSET);
+ }
+ 
+ static inline unsigned int autofs_type_trigger(unsigned int type)
+ {
+ 	return (type == AUTOFS_TYPE_DIRECT || type == AUTOFS_TYPE_OFFSET);
+ }
+ 
+ /*
+  * This isn't really a type as we use it to say "no type set" to
+  * indicate we want to search for "any" mount in the
+  * autofs_dev_ioctl_ismountpoint() device ioctl function.
+  */
+ static inline void set_autofs_type_any(unsigned int *type)
+ {
+ 	*type = AUTOFS_TYPE_ANY;
+ }
+ 
+ static inline unsigned int autofs_type_any(unsigned int type)
+ {
+ 	return (type == AUTOFS_TYPE_ANY);
+ }
+ 
+ /* Daemon notification packet types */
+ enum autofs_notify {
+ 	NFY_NONE,
+ 	NFY_MOUNT,
+ 	NFY_EXPIRE
+ };
+ 
+ /* Kernel protocol version 4 packet types */
+ 
+ /* Expire entry (umount request) */
+ #define autofs_ptype_expire_multi	2
+ 
+ /* Kernel protocol version 5 packet types */
+ 
+ /* Indirect mount missing and expire requests. */
+ #define autofs_ptype_missing_indirect	3
+ #define autofs_ptype_expire_indirect	4
+ 
+ /* Direct mount missing and expire requests */
+ #define autofs_ptype_missing_direct	5
+ #define autofs_ptype_expire_direct	6
+ 
+ /* v4 multi expire (via pipe) */
+ struct autofs_packet_expire_multi {
+ 	struct autofs_packet_hdr hdr;
+ 	autofs_wqt_t wait_queue_token;
+ 	int len;
+ 	char name[NAME_MAX+1];
+ };
+ 
+ union autofs_packet_union {
+ 	struct autofs_packet_hdr hdr;
+ 	struct autofs_packet_missing missing;
+ 	struct autofs_packet_expire expire;
+ 	struct autofs_packet_expire_multi expire_multi;
+ };
+ 
+ /* autofs v5 common packet struct */
+ struct autofs_v5_packet {
+ 	struct autofs_packet_hdr hdr;
+ 	autofs_wqt_t wait_queue_token;
+ 	__u32 dev;
+ 	__u64 ino;
+ 	__u32 uid;
+ 	__u32 gid;
+ 	__u32 pid;
+ 	__u32 tgid;
+ 	__u32 len;
+ 	char name[NAME_MAX+1];
+ };
+ 
+ typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;
+ typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;
+ typedef struct autofs_v5_packet autofs_packet_missing_direct_t;
+ typedef struct autofs_v5_packet autofs_packet_expire_direct_t;
+ 
+ union autofs_v5_packet_union {
+ 	struct autofs_packet_hdr hdr;
+ 	struct autofs_v5_packet v5_packet;
+ 	autofs_packet_missing_indirect_t missing_indirect;
+ 	autofs_packet_expire_indirect_t expire_indirect;
+ 	autofs_packet_missing_direct_t missing_direct;
+ 	autofs_packet_expire_direct_t expire_direct;
+ };
+ 
+ enum {
+ 	AUTOFS_IOC_EXPIRE_MULTI_CMD = 0x66, /* AUTOFS_IOC_EXPIRE_CMD + 1 */
+ 	AUTOFS_IOC_PROTOSUBVER_CMD,
+ 	AUTOFS_IOC_ASKUMOUNT_CMD = 0x70, /* AUTOFS_DEV_IOCTL_VERSION_CMD - 1 */
+ };
+ 
+ #define AUTOFS_IOC_EXPIRE_MULTI		_IOW(AUTOFS_IOCTL, \
+ 					     AUTOFS_IOC_EXPIRE_MULTI_CMD, int)
+ #define AUTOFS_IOC_PROTOSUBVER		_IOR(AUTOFS_IOCTL, \
+ 					     AUTOFS_IOC_PROTOSUBVER_CMD, int)
+ #define AUTOFS_IOC_ASKUMOUNT		_IOR(AUTOFS_IOCTL, \
+ 					     AUTOFS_IOC_ASKUMOUNT_CMD, int)
++>>>>>>> cbf6898fd694 (autofs: add AUTOFS_EXP_FORCED flag)
  
  #endif /* _UAPI_LINUX_AUTO_FS_H */
* Unmerged path fs/autofs4/expire.c
* Unmerged path include/uapi/linux/auto_fs.h
