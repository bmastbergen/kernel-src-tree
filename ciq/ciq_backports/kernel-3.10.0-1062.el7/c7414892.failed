ext4: fix dir_nlink behaviour

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Andreas Dilger <adilger@dilger.ca>
commit c7414892067204fcb8f8ebb4309d0fdd8c7242fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c7414892.failed

The dir_nlink feature has been enabled by default for new ext4
filesystems since e2fsprogs-1.41 in 2008, and was automatically
enabled by the kernel for older ext4 filesystems since the
dir_nlink feature was added with ext4 in kernel 2.6.28+ when
the subdirectory count exceeded EXT4_LINK_MAX-1.

Automatically adding the file system features such as dir_nlink is
generally frowned upon, since it could cause the file system to not be
mountable on older kernel, thus preventing the administrator from
rolling back to an older kernel if necessary.

In this case, the administrator might also want to disable the feature
because glibc's fts_read() function does not correctly optimize
directory traversal for directories that use st_nlinks field of 1 to
indicate that the number of links in the directory are not tracked by
the file system, and could fail to traverse the full directory
hierarchy.  Fortunately, in the past ten years very few users have
complained about incomplete file system traversal by glibc's
fts_read().

This commit also changes ext4_inc_count() to allow i_nlinks to reach
the full EXT4_LINK_MAX links on the parent directory (including "."
and "..") before changing i_links_count to be 1.

Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=196405
	Signed-off-by: Andreas Dilger <adilger@dilger.ca>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit c7414892067204fcb8f8ebb4309d0fdd8c7242fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/namei.c
diff --cc fs/ext4/namei.c
index a0806208a4c0,cc986b824181..000000000000
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@@ -2196,14 -2408,9 +2203,20 @@@ out
  static void ext4_inc_count(handle_t *handle, struct inode *inode)
  {
  	inc_nlink(inode);
++<<<<<<< HEAD
 +	if (is_dx(inode) && inode->i_nlink > 1) {
 +		/* limit is 16-bit i_links_count */
 +		if (inode->i_nlink >= EXT4_LINK_MAX || inode->i_nlink == 2) {
 +			set_nlink(inode, 1);
 +			EXT4_SET_RO_COMPAT_FEATURE(inode->i_sb,
 +					      EXT4_FEATURE_RO_COMPAT_DIR_NLINK);
 +		}
 +	}
++=======
+ 	if (is_dx(inode) &&
+ 	    (inode->i_nlink > EXT4_LINK_MAX || inode->i_nlink == 2))
+ 		set_nlink(inode, 1);
++>>>>>>> c74148920672 (ext4: fix dir_nlink behaviour)
  }
  
  /*
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 7d97ec136014..7d775710c64e 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1774,7 +1774,8 @@ static inline __le16 ext4_rec_len_to_disk(unsigned len, unsigned blocksize)
 #define is_dx(dir) (EXT4_HAS_COMPAT_FEATURE(dir->i_sb, \
 				      EXT4_FEATURE_COMPAT_DIR_INDEX) && \
 		    ext4_test_inode_flag((dir), EXT4_INODE_INDEX))
-#define EXT4_DIR_LINK_MAX(dir) (!is_dx(dir) && (dir)->i_nlink >= EXT4_LINK_MAX)
+#define EXT4_DIR_LINK_MAX(dir) unlikely((dir)->i_nlink >= EXT4_LINK_MAX && \
+		    !(ext4_has_feature_dir_nlink((dir)->i_sb) && is_dx(dir)))
 #define EXT4_DIR_LINK_EMPTY(dir) ((dir)->i_nlink == 2 || (dir)->i_nlink == 1)
 
 /* Legal values for the dx_root hash_version field: */
* Unmerged path fs/ext4/namei.c
