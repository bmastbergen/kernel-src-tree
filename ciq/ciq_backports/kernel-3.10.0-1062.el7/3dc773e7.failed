x86/kvm/mmu.c: set get_pdptr hook in kvm_init_shadow_ept_mmu()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] kvm/mmu.c: set get_pdptr hook in kvm_init_shadow_ept_mmu() (Vitaly Kuznetsov) [1565739 1497611]
Rebuild_FUZZ: 96.67%
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 3dc773e745234d904b09da37075200ec46af4e7a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3dc773e7.failed

kvm_init_shadow_ept_mmu() doesn't set get_pdptr() hook and is this
not a problem just because MMU context is already initialized and this
hook points to kvm_pdptr_read(). As we're intended to use a dedicated
MMU for shadow EPT MMU set this hook explicitly.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
	Reviewed-by: Sean Christopherson <sean.j.christopherson@intel.com>
(cherry picked from commit 3dc773e745234d904b09da37075200ec46af4e7a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu.c
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/mmu.c
index e7052d2c946d,5b14dcbd248a..000000000000
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@@ -4513,11 -4859,10 +4513,16 @@@ void kvm_init_shadow_ept_mmu(struct kvm
  	context->sync_page = ept_sync_page;
  	context->invlpg = ept_invlpg;
  	context->update_pte = ept_update_pte;
 -	context->root_level = PT64_ROOT_4LEVEL;
 +	context->root_level = context->shadow_root_level;
 +	context->root_hpa = INVALID_PAGE;
  	context->direct_map = false;
++<<<<<<< HEAD
 +	context->base_role.ad_disabled = !accessed_dirty;
 +	context->base_role.guest_mode = 1;
++=======
+ 	context->base_role.word = root_page_role.word & mmu_base_role_mask.word;
+ 
++>>>>>>> 3dc773e74523 (x86/kvm/mmu.c: set get_pdptr hook in kvm_init_shadow_ept_mmu())
  	update_permission_bitmask(vcpu, context, true);
  	update_pkru_bitmask(vcpu, context, true);
  	update_last_nonleaf_level(vcpu, context);
diff --cc arch/x86/kvm/vmx.c
index 5501a1957de2,fa7e46210a0d..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9704,23 -11296,21 +9704,32 @@@ static unsigned long nested_ept_get_cr3
  	return get_vmcs12(vcpu)->ept_pointer;
  }
  
 -static void nested_ept_init_mmu_context(struct kvm_vcpu *vcpu)
 +static int nested_ept_init_mmu_context(struct kvm_vcpu *vcpu)
  {
  	WARN_ON(mmu_is_nested(vcpu));
 +	if (!valid_ept_address(vcpu, nested_ept_get_cr3(vcpu)))
 +		return 1;
  
 +	kvm_mmu_unload(vcpu);
  	kvm_init_shadow_ept_mmu(vcpu,
 -			to_vmx(vcpu)->nested.msrs.ept_caps &
 +			to_vmx(vcpu)->nested.nested_vmx_ept_caps &
  			VMX_EPT_EXECUTE_ONLY_BIT,
++<<<<<<< HEAD
 +			nested_ept_ad_enabled(vcpu));
 +	vcpu->arch.mmu.set_cr3           = vmx_set_cr3;
 +	vcpu->arch.mmu.get_cr3           = nested_ept_get_cr3;
 +	vcpu->arch.mmu.inject_page_fault = nested_ept_inject_page_fault;
++=======
+ 			nested_ept_ad_enabled(vcpu),
+ 			nested_ept_get_cr3(vcpu));
+ 	vcpu->arch.mmu->set_cr3           = vmx_set_cr3;
+ 	vcpu->arch.mmu->get_cr3           = nested_ept_get_cr3;
+ 	vcpu->arch.mmu->inject_page_fault = nested_ept_inject_page_fault;
+ 	vcpu->arch.mmu->get_pdptr         = kvm_pdptr_read;
++>>>>>>> 3dc773e74523 (x86/kvm/mmu.c: set get_pdptr hook in kvm_init_shadow_ept_mmu())
  
  	vcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;
 +	return 0;
  }
  
  static void nested_ept_uninit_mmu_context(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/mmu.c
* Unmerged path arch/x86/kvm/vmx.c
