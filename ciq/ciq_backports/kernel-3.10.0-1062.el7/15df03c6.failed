netfilter: ipv6: Don't preserve original oif for loopback address

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eli Cooper <elicooper@gmx.com>
commit 15df03c661cb362366ecfc3a21820cb934f3e4ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/15df03c6.failed

Commit 508b09046c0f ("netfilter: ipv6: Preserve link scope traffic
original oif") made ip6_route_me_harder() keep the original oif for
link-local and multicast packets. However, it also affected packets
for the loopback address because it used rt6_need_strict().

REDIRECT rules in the OUTPUT chain rewrite the destination to loopback
address; thus its oif should not be preserved. This commit fixes the bug
that redirected local packets are being dropped. Actually the packet was
not exactly dropped; Instead it was sent out to the original oif rather
than lo. When a packet with daddr ::1 is sent to the router, it is
effectively dropped.

Fixes: 508b09046c0f ("netfilter: ipv6: Preserve link scope traffic original oif")
	Signed-off-by: Eli Cooper <elicooper@gmx.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 15df03c661cb362366ecfc3a21820cb934f3e4ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/netfilter.c
diff --cc net/ipv6/netfilter.c
index a9957c7115a9,6d0b1f3e927b..000000000000
--- a/net/ipv6/netfilter.c
+++ b/net/ipv6/netfilter.c
@@@ -15,18 -15,21 +15,25 @@@
  #include <net/ipv6.h>
  #include <net/ip6_route.h>
  #include <net/xfrm.h>
 +#include <net/ip6_checksum.h>
  #include <net/netfilter/nf_queue.h>
  
 -int ip6_route_me_harder(struct net *net, struct sk_buff *skb)
 +int ip6_route_me_harder(struct sk_buff *skb)
  {
 +	struct net *net = dev_net(skb_dst(skb)->dev);
  	const struct ipv6hdr *iph = ipv6_hdr(skb);
 -	struct sock *sk = sk_to_full_sk(skb->sk);
  	unsigned int hh_len;
  	struct dst_entry *dst;
+ 	int strict = (ipv6_addr_type(&iph->daddr) &
+ 		      (IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL));
  	struct flowi6 fl6 = {
++<<<<<<< HEAD
 +		.flowi6_oif = skb->sk ? skb->sk->sk_bound_dev_if : 0,
++=======
+ 		.flowi6_oif = sk && sk->sk_bound_dev_if ? sk->sk_bound_dev_if :
+ 			strict ? skb_dst(skb)->dev->ifindex : 0,
++>>>>>>> 15df03c661cb (netfilter: ipv6: Don't preserve original oif for loopback address)
  		.flowi6_mark = skb->mark,
 -		.flowi6_uid = sock_net_uid(net, sk),
  		.daddr = iph->daddr,
  		.saddr = iph->saddr,
  	};
* Unmerged path net/ipv6/netfilter.c
