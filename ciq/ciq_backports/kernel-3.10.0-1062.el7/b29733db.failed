ALSA: hda/ca0132 - Add ZxR quirks + new quirk check function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit b29733db3b761684c90cb5ea195d9e47462059b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b29733db.failed

This patch adds quirk ID's for the ZxR and it's daughter board, the
DBPro. It also adds a function for determining the quirk for each board
through HDA subsytem ID's instead of PCI subsystem ID's.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit b29733db3b761684c90cb5ea195d9e47462059b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index fe65633ba745,08dd85db2953..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -769,7 -1069,13 +769,17 @@@ struct ca0132_spec 
  enum {
  	QUIRK_NONE,
  	QUIRK_ALIENWARE,
++<<<<<<< HEAD
 +	QUIRK_GENERIC_PARSER,
++=======
+ 	QUIRK_ALIENWARE_M17XR4,
+ 	QUIRK_SBZ,
+ 	QUIRK_ZXR,
+ 	QUIRK_ZXR_DBPRO,
+ 	QUIRK_R3DI,
+ 	QUIRK_R3D,
+ 	QUIRK_AE5,
++>>>>>>> b29733db3b76 (ALSA: hda/ca0132 - Add ZxR quirks + new quirk check function)
  };
  
  static const struct hda_pintbl alienware_pincfgs[] = {
@@@ -5071,84 -8379,28 +5081,109 @@@ static int ca0132_prepare_verbs(struct 
  }
  
  /*
++<<<<<<< HEAD
 + * CA0132 codec support using generic parser;
 + * This mode is a kind of fallback mode as the provided DSP has some
 + * hard-coding mapping and we can't fix it.  That is, the board works
 + * just like a normal HD-audio, and of course, without any effects.
 + */
 +
 +#define REG_CODEC_MUTE          0x18b014
 +#define REG_CODEC_HP_VOL_L      0x18b070
 +#define REG_CODEC_HP_VOL_R      0x18b074
 +
 +enum {
 +	CA0132_GEN_FIXUP_SBZ,
 +};
 +
 +static const struct hda_fixup ca0132_gen_fixups[] = {
 +	[CA0132_GEN_FIXUP_SBZ] = {
 +		.type = HDA_FIXUP_PINS,
 +		.v.pins = (const struct hda_pintbl[]) {
 +			{ 0x0b, 0x411111f0 },
 +			{ 0x0c, 0x411111f0 },
 +			{ 0x0d, 0x90170110 }, /* lineout */
 +			{ 0x0e, 0x411111f0 },
 +			{ 0x0f, 0x0321101f }, /* HP */
 +			{ 0x10, 0x411111f0 },
 +			{ 0x11, 0x03a11021 }, /* mic */
 +			{ 0x12, 0xd5a30140 }, /* mic */
 +			{ 0x13, 0x50d000f0 },
 +			{ 0x18, 0x500000f0 },
 +			{}
 +		},
 +	},
 +};
 +
 +static const struct snd_pci_quirk ca0132_gen_fixup_tbl[] = {
 +	SND_PCI_QUIRK(0x1102, 0x0010, "Sound Blaster Z", CA0132_GEN_FIXUP_SBZ),
 +	SND_PCI_QUIRK(0x1102, 0x0023, "Sound Blaster Z", CA0132_GEN_FIXUP_SBZ),
 +	SND_PCI_QUIRK(0x1102, 0x0024, "Sound Blaster Z", CA0132_GEN_FIXUP_SBZ),
 +	SND_PCI_QUIRK(0x1102, 0x0025, "Sound Blaster Zx", CA0132_GEN_FIXUP_SBZ),
 +	SND_PCI_QUIRK(0x1102, 0x0027, "Sound Blaster Z", CA0132_GEN_FIXUP_SBZ),
 +};
 +
 +static const struct hda_codec_ops ca0132_gen_patch_ops = {
 +	.build_controls = snd_hda_gen_build_controls,
 +	.build_pcms = snd_hda_gen_build_pcms,
 +	.init = snd_hda_gen_init,
 +	.free = snd_hda_gen_free,
 +	.unsol_event = snd_hda_jack_unsol_event,
 +};
 +
 +static int parse_ca0132_generic(struct hda_codec *codec)
 +{
 +	struct ca0132_spec *spec = codec->spec;
 +	struct auto_pin_cfg *cfg = &spec->gen.autocfg;
 +	int err;
 +
 +	codec_dbg(codec, "Using generic parser for CA0132\n");
 +	snd_hda_gen_spec_init(&spec->gen);
 +	codec->patch_ops = ca0132_gen_patch_ops;
 +	snd_hda_pick_fixup(codec, NULL, ca0132_gen_fixup_tbl,
 +			   ca0132_gen_fixups);
 +	snd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);
 +
 +	err = snd_hda_parse_pin_def_config(codec, cfg, NULL);
 +	if (err < 0)
 +		goto error;
 +	err = snd_hda_gen_parse_auto_config(codec, cfg);
 +	if (err < 0)
 +		goto error;
 +
 +	snd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);
 +	return 0;
 +
 + error:
 +	snd_hda_gen_free(codec);
 +	return err;
 +}
 +
 +/* common probe entry */
++=======
+  * The Sound Blaster ZxR shares the same PCI subsystem ID as some regular
+  * Sound Blaster Z cards. However, they have different HDA codec subsystem
+  * ID's. So, we check for the ZxR's subsystem ID, as well as the DBPro
+  * daughter boards ID.
+  */
+ static void sbz_detect_quirk(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	switch (codec->core.subsystem_id) {
+ 	case 0x11020033:
+ 		spec->quirk = QUIRK_ZXR;
+ 		break;
+ 	case 0x1102003f:
+ 		spec->quirk = QUIRK_ZXR_DBPRO;
+ 		break;
+ 	default:
+ 		spec->quirk = QUIRK_SBZ;
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> b29733db3b76 (ALSA: hda/ca0132 - Add ZxR quirks + new quirk check function)
  static int patch_ca0132(struct hda_codec *codec)
  {
  	struct ca0132_spec *spec;
@@@ -5173,10 -8426,8 +5208,15 @@@
  	else
  		spec->quirk = QUIRK_NONE;
  
++<<<<<<< HEAD
 +	if (spec->quirk == QUIRK_GENERIC_PARSER)
 +		return parse_ca0132_generic(codec);
 +
 +	codec->patch_ops = ca0132_patch_ops;
++=======
+ 	if (spec->quirk == QUIRK_SBZ)
+ 		sbz_detect_quirk(codec);
++>>>>>>> b29733db3b76 (ALSA: hda/ca0132 - Add ZxR quirks + new quirk check function)
  
  	spec->dsp_state = DSP_DOWNLOAD_INIT;
  	spec->num_mixers = 1;
* Unmerged path sound/pci/hda/patch_ca0132.c
