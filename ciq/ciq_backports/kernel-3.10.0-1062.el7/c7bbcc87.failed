watchdog: iTCO_wdt: Use device managed resources

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [watchdog] itco_wdt: Use device managed resources (David Arcari) [1645537]
Rebuild_FUZZ: 88.37%
commit-author Guenter Roeck <linux@roeck-us.net>
commit c7bbcc87ac98c340cb6e68c70ea4b600734a04d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c7bbcc87.failed

Using device managed resources simplifies error handling and cleanup,
and to reduce the likelyhood of errors.

	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
(cherry picked from commit c7bbcc87ac98c340cb6e68c70ea4b600734a04d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/watchdog/iTCO_wdt.c
diff --cc drivers/watchdog/iTCO_wdt.c
index 247fd1d7ca0d,eed1dee6de19..000000000000
--- a/drivers/watchdog/iTCO_wdt.c
+++ b/drivers/watchdog/iTCO_wdt.c
@@@ -398,116 -401,81 +398,146 @@@ static struct watchdog_device iTCO_wdt_
   *	Init & exit routines
   */
  
++<<<<<<< HEAD
 +static void iTCO_wdt_cleanup(void)
 +{
 +	/* Stop the timer before we leave */
 +	if (!nowayout)
 +		iTCO_wdt_stop(&iTCO_wdt_watchdog_dev);
 +
 +	/* Deregister */
 +	watchdog_unregister_device(&iTCO_wdt_watchdog_dev);
 +
 +	/* release resources */
 +	release_region(iTCO_wdt_private.tco_res->start,
 +			resource_size(iTCO_wdt_private.tco_res));
 +	release_region(iTCO_wdt_private.smi_res->start,
 +			resource_size(iTCO_wdt_private.smi_res));
 +	if (iTCO_wdt_private.iTCO_version >= 2) {
 +		iounmap(iTCO_wdt_private.gcs_pmc);
 +		release_mem_region(iTCO_wdt_private.gcs_pmc_res->start,
 +				resource_size(iTCO_wdt_private.gcs_pmc_res));
 +	}
 +
 +	iTCO_wdt_private.tco_res = NULL;
 +	iTCO_wdt_private.smi_res = NULL;
 +	iTCO_wdt_private.gcs_pmc_res = NULL;
 +	iTCO_wdt_private.gcs_pmc = NULL;
 +}
 +
++=======
++>>>>>>> c7bbcc87ac98 (watchdog: iTCO_wdt: Use device managed resources)
  static int iTCO_wdt_probe(struct platform_device *dev)
  {
 -	struct itco_wdt_platform_data *pdata = dev_get_platdata(&dev->dev);
 -	struct iTCO_wdt_private *p;
 +	int ret = -ENODEV;
  	unsigned long val32;
 -	int ret;
 +	struct itco_wdt_platform_data *pdata = dev->dev.platform_data;
  
  	if (!pdata)
 -		return -ENODEV;
 +		goto out;
  
 -	p = devm_kzalloc(&dev->dev, sizeof(*p), GFP_KERNEL);
 -	if (!p)
 -		return -ENOMEM;
 +	spin_lock_init(&iTCO_wdt_private.io_lock);
  
 -	spin_lock_init(&p->io_lock);
 +	iTCO_wdt_private.tco_res =
 +		platform_get_resource(dev, IORESOURCE_IO, ICH_RES_IO_TCO);
 +	if (!iTCO_wdt_private.tco_res)
 +		goto out;
  
 -	p->tco_res = platform_get_resource(dev, IORESOURCE_IO, ICH_RES_IO_TCO);
 -	if (!p->tco_res)
 -		return -ENODEV;
 +	iTCO_wdt_private.smi_res =
 +		platform_get_resource(dev, IORESOURCE_IO, ICH_RES_IO_SMI);
 +	if (!iTCO_wdt_private.smi_res)
 +		goto out;
  
 -	p->smi_res = platform_get_resource(dev, IORESOURCE_IO, ICH_RES_IO_SMI);
 -	if (!p->smi_res)
 -		return -ENODEV;
 -
 -	p->iTCO_version = pdata->version;
 -	p->dev = dev;
 -	p->pdev = to_pci_dev(dev->dev.parent);
 +	iTCO_wdt_private.iTCO_version = pdata->version;
 +	iTCO_wdt_private.dev = dev;
 +	iTCO_wdt_private.pdev = to_pci_dev(dev->dev.parent);
  
  	/*
  	 * Get the Memory-Mapped GCS or PMC register, we need it for the
  	 * NO_REBOOT flag (TCO v2 and v3).
  	 */
++<<<<<<< HEAD
 +	if (iTCO_wdt_private.iTCO_version >= 2) {
 +		iTCO_wdt_private.gcs_pmc_res = platform_get_resource(dev,
 +							IORESOURCE_MEM,
 +							ICH_RES_MEM_GCS_PMC);
 +
 +		if (!iTCO_wdt_private.gcs_pmc_res)
 +			goto out;
 +
 +		if (!request_mem_region(iTCO_wdt_private.gcs_pmc_res->start,
 +			resource_size(iTCO_wdt_private.gcs_pmc_res), dev->name)) {
 +			ret = -EBUSY;
 +			goto out;
 +		}
 +		iTCO_wdt_private.gcs_pmc = ioremap(iTCO_wdt_private.gcs_pmc_res->start,
 +			resource_size(iTCO_wdt_private.gcs_pmc_res));
 +		if (!iTCO_wdt_private.gcs_pmc) {
 +			ret = -EIO;
 +			goto unreg_gcs_pmc;
 +		}
++=======
+ 	if (p->iTCO_version >= 2) {
+ 		p->gcs_pmc_res = platform_get_resource(dev,
+ 						       IORESOURCE_MEM,
+ 						       ICH_RES_MEM_GCS_PMC);
+ 		p->gcs_pmc = devm_ioremap_resource(&dev->dev, p->gcs_pmc_res);
+ 		if (IS_ERR(p->gcs_pmc))
+ 			return PTR_ERR(p->gcs_pmc);
++>>>>>>> c7bbcc87ac98 (watchdog: iTCO_wdt: Use device managed resources)
  	}
  
  	/* Check chipset's NO_REBOOT bit */
 -	if (iTCO_wdt_unset_NO_REBOOT_bit(p) &&
 -	    iTCO_vendor_check_noreboot_on()) {
 +	if (iTCO_wdt_unset_NO_REBOOT_bit() && iTCO_vendor_check_noreboot_on()) {
  		pr_info("unable to reset NO_REBOOT flag, device disabled by hardware/BIOS\n");
- 		ret = -ENODEV;	/* Cannot reset NO_REBOOT bit */
- 		goto unmap_gcs_pmc;
+ 		return -ENODEV;	/* Cannot reset NO_REBOOT bit */
  	}
  
  	/* Set the NO_REBOOT bit to prevent later reboots, just for sure */
 -	iTCO_wdt_set_NO_REBOOT_bit(p);
 +	iTCO_wdt_set_NO_REBOOT_bit();
  
  	/* The TCO logic uses the TCO_EN bit in the SMI_EN register */
++<<<<<<< HEAD
 +	if (!request_region(iTCO_wdt_private.smi_res->start,
 +			resource_size(iTCO_wdt_private.smi_res), dev->name)) {
 +		pr_err("I/O address 0x%04llx already in use, device disabled\n",
 +		       (u64)SMI_EN);
 +		ret = -EBUSY;
 +		goto unmap_gcs_pmc;
++=======
+ 	if (!devm_request_region(&dev->dev, p->smi_res->start,
+ 				 resource_size(p->smi_res),
+ 				 dev->name)) {
+ 		pr_err("I/O address 0x%04llx already in use, device disabled\n",
+ 		       (u64)SMI_EN(p));
+ 		return -EBUSY;
++>>>>>>> c7bbcc87ac98 (watchdog: iTCO_wdt: Use device managed resources)
  	}
 -	if (turn_SMI_watchdog_clear_off >= p->iTCO_version) {
 +	if (turn_SMI_watchdog_clear_off >= iTCO_wdt_private.iTCO_version) {
  		/*
  		 * Bit 13: TCO_EN -> 0
  		 * Disables TCO logic generating an SMI#
  		 */
 -		val32 = inl(SMI_EN(p));
 +		val32 = inl(SMI_EN);
  		val32 &= 0xffffdfff;	/* Turn off SMI clearing watchdog */
 -		outl(val32, SMI_EN(p));
 +		outl(val32, SMI_EN);
  	}
  
++<<<<<<< HEAD
 +	if (!request_region(iTCO_wdt_private.tco_res->start,
 +			resource_size(iTCO_wdt_private.tco_res), dev->name)) {
 +		pr_err("I/O address 0x%04llx already in use, device disabled\n",
 +		       (u64)TCOBASE);
 +		ret = -EBUSY;
 +		goto unreg_smi;
++=======
+ 	if (!devm_request_region(&dev->dev, p->tco_res->start,
+ 				 resource_size(p->tco_res),
+ 				 dev->name)) {
+ 		pr_err("I/O address 0x%04llx already in use, device disabled\n",
+ 		       (u64)TCOBASE(p));
+ 		return -EBUSY;
++>>>>>>> c7bbcc87ac98 (watchdog: iTCO_wdt: Use device managed resources)
  	}
  
  	pr_info("Found a %s TCO device (Version=%d, TCOBASE=0x%04llx)\n",
@@@ -548,43 -521,25 +578,58 @@@
  			WATCHDOG_TIMEOUT);
  	}
  
++<<<<<<< HEAD
 +	ret = watchdog_register_device(&iTCO_wdt_watchdog_dev);
++=======
+ 	ret = devm_watchdog_register_device(&dev->dev, &p->wddev);
++>>>>>>> c7bbcc87ac98 (watchdog: iTCO_wdt: Use device managed resources)
  	if (ret != 0) {
  		pr_err("cannot register watchdog device (err=%d)\n", ret);
- 		goto unreg_tco;
+ 		return ret;
  	}
  
  	pr_info("initialized. heartbeat=%d sec (nowayout=%d)\n",
  		heartbeat, nowayout);
  
  	return 0;
++<<<<<<< HEAD
 +
 +unreg_tco:
 +	release_region(iTCO_wdt_private.tco_res->start,
 +			resource_size(iTCO_wdt_private.tco_res));
 +unreg_smi:
 +	release_region(iTCO_wdt_private.smi_res->start,
 +			resource_size(iTCO_wdt_private.smi_res));
 +unmap_gcs_pmc:
 +	if (iTCO_wdt_private.iTCO_version >= 2)
 +		iounmap(iTCO_wdt_private.gcs_pmc);
 +unreg_gcs_pmc:
 +	if (iTCO_wdt_private.iTCO_version >= 2)
 +		release_mem_region(iTCO_wdt_private.gcs_pmc_res->start,
 +				resource_size(iTCO_wdt_private.gcs_pmc_res));
 +out:
 +	iTCO_wdt_private.tco_res = NULL;
 +	iTCO_wdt_private.smi_res = NULL;
 +	iTCO_wdt_private.gcs_pmc_res = NULL;
 +	iTCO_wdt_private.gcs_pmc = NULL;
 +
 +	return ret;
++=======
++>>>>>>> c7bbcc87ac98 (watchdog: iTCO_wdt: Use device managed resources)
  }
  
  static int iTCO_wdt_remove(struct platform_device *dev)
  {
++<<<<<<< HEAD
 +	if (iTCO_wdt_private.tco_res || iTCO_wdt_private.smi_res)
 +		iTCO_wdt_cleanup();
++=======
+ 	struct iTCO_wdt_private *p = platform_get_drvdata(dev);
+ 
+ 	/* Stop the timer before we leave */
+ 	if (!nowayout)
+ 		iTCO_wdt_stop(&p->wddev);
++>>>>>>> c7bbcc87ac98 (watchdog: iTCO_wdt: Use device managed resources)
  
  	return 0;
  }
* Unmerged path drivers/watchdog/iTCO_wdt.c
