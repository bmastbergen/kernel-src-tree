memcg: fix possible NULL deref while traversing memcg_slab_caches list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Vladimir Davydov <vdavydov@parallels.com>
commit 96403da244443d9842dbf290c2a02390b78a158e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/96403da2.failed

All caches of the same memory cgroup are linked in the memcg_slab_caches
list via kmem_cache::memcg_params::list.  This list is traversed, for
example, when we read memory.kmem.slabinfo.

Since the list actually consists of memcg_cache_params objects, we have
to convert an element of the list to a kmem_cache object using
memcg_params_to_cache(), which obtains the pointer to the cache from the
memcg_params::memcg_caches array of the corresponding root cache.  That
said the pointer to a kmem_cache in its parent's memcg_params must be
initialized before adding the cache to the list, and cleared only after
it has been unlinked.  Currently it is vice-versa, which can result in a
NULL ptr dereference while traversing the memcg_slab_caches list.  This
patch restores the correct order.

	Signed-off-by: Vladimir Davydov <vdavydov@parallels.com>
	Cc: Michal Hocko <mhocko@suse.cz>
	Cc: Glauber Costa <glommer@gmail.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Balbir Singh <bsingharora@gmail.com>
	Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 96403da244443d9842dbf290c2a02390b78a158e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memcontrol.c
diff --cc mm/memcontrol.c
index 5a271ae6c0ad,014a4f1acf1c..000000000000
--- a/mm/memcontrol.c
+++ b/mm/memcontrol.c
@@@ -3255,17 -3268,26 +3255,40 @@@ void memcg_register_cache(struct kmem_c
  	memcg = s->memcg_params->memcg;
  	id = memcg_cache_id(memcg);
  
++<<<<<<< HEAD
 +	mutex_lock(&memcg->slab_caches_mutex);
 +	list_add(&s->memcg_params->list, &memcg->memcg_slab_caches);
 +	mutex_unlock(&memcg->slab_caches_mutex);
 +
 +	VM_BUG_ON(root->memcg_params->memcg_caches[id]);
 +	root->memcg_params->memcg_caches[id] = s;
 +	/*
 +	 * the readers won't lock, make sure everybody sees the updated value,
 +	 * so they won't put stuff in the queue again for no reason
 +	 */
 +	wmb();
++=======
+ 	css_get(&memcg->css);
+ 
+ 
+ 	/*
+ 	 * Since readers won't lock (see cache_from_memcg_idx()), we need a
+ 	 * barrier here to ensure nobody will see the kmem_cache partially
+ 	 * initialized.
+ 	 */
+ 	smp_wmb();
+ 
+ 	/*
+ 	 * Initialize the pointer to this cache in its parent's memcg_params
+ 	 * before adding it to the memcg_slab_caches list, otherwise we can
+ 	 * fail to convert memcg_params_to_cache() while traversing the list.
+ 	 */
+ 	root->memcg_params->memcg_caches[id] = s;
+ 
+ 	mutex_lock(&memcg->slab_caches_mutex);
+ 	list_add(&s->memcg_params->list, &memcg->memcg_slab_caches);
+ 	mutex_unlock(&memcg->slab_caches_mutex);
++>>>>>>> 96403da24444 (memcg: fix possible NULL deref while traversing memcg_slab_caches list)
  }
  
  void memcg_unregister_cache(struct kmem_cache *s)
@@@ -3274,34 -3296,25 +3297,51 @@@
  	struct mem_cgroup *memcg;
  	int id;
  
 -	if (is_root_cache(s))
 +	/*
 +	 * This happens, for instance, when a root cache goes away before we
 +	 * add any memcg.
 +	 */
 +	if (!s->memcg_params)
 +		return;
 +
++<<<<<<< HEAD
 +	if (s->memcg_params->is_root_cache)
  		return;
  
 +	/*
 +	 * Holding the slab_mutex assures nobody will touch the memcg_caches
 +	 * array while we are modifying it.
 +	 */
 +	lockdep_assert_held(&slab_mutex);
 +
 +	memcg = s->memcg_params->memcg;
 +	id  = memcg_cache_id(memcg);
 +
 +	root = s->memcg_params->root_cache;
 +	VM_BUG_ON(!root->memcg_params->memcg_caches[id]);
 +	root->memcg_params->memcg_caches[id] = NULL;
++=======
+ 	root = s->memcg_params->root_cache;
+ 	memcg = s->memcg_params->memcg;
+ 	id = memcg_cache_id(memcg);
++>>>>>>> 96403da24444 (memcg: fix possible NULL deref while traversing memcg_slab_caches list)
  
  	mutex_lock(&memcg->slab_caches_mutex);
  	list_del(&s->memcg_params->list);
  	mutex_unlock(&memcg->slab_caches_mutex);
  
++<<<<<<< HEAD
 +	mem_cgroup_put(memcg);
++=======
+ 	/*
+ 	 * Clear the pointer to this cache in its parent's memcg_params only
+ 	 * after removing it from the memcg_slab_caches list, otherwise we can
+ 	 * fail to convert memcg_params_to_cache() while traversing the list.
+ 	 */
+ 	root->memcg_params->memcg_caches[id] = NULL;
+ 
+ 	css_put(&memcg->css);
++>>>>>>> 96403da24444 (memcg: fix possible NULL deref while traversing memcg_slab_caches list)
  }
  
  /*
* Unmerged path mm/memcontrol.c
