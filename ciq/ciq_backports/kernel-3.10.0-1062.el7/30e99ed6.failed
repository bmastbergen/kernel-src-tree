net: sched: act_pedit: fix possible memory leak in tcf_pedit_init()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [net] sched: act_pedit: fix possible memory leak in tcf_pedit_init() (Davide Caratti) [1706158]
Rebuild_FUZZ: 96.12%
commit-author Wei Yongjun <weiyongjun1@huawei.com>
commit 30e99ed6dbdde68f5ad23db3a5872c3c247526b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/30e99ed6.failed

'keys_ex' is malloced by tcf_pedit_keys_ex_parse() in tcf_pedit_init()
but not all of the error handle path free it, this may cause memory
leak. This patch fix it.

Fixes: 71d0ed7079df ("net/act_pedit: Support using offset relative to the conventional network headers")
	Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
	Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 30e99ed6dbdde68f5ad23db3a5872c3c247526b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_pedit.c
diff --cc net/sched/act_pedit.c
index 5a988cff963f,e43aef28fdac..000000000000
--- a/net/sched/act_pedit.c
+++ b/net/sched/act_pedit.c
@@@ -167,18 -173,21 +167,26 @@@ static int tcf_pedit_init(struct net *n
  		return PTR_ERR(keys_ex);
  
  	if (!tcf_idr_check(tn, parm->index, a, bind)) {
++<<<<<<< HEAD
 +		if (!parm->nkeys)
 +			return -EINVAL;
++=======
+ 		if (!parm->nkeys) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Pedit requires keys to be passed");
+ 			ret = -EINVAL;
+ 			goto out_free;
+ 		}
++>>>>>>> 30e99ed6dbdd (net: sched: act_pedit: fix possible memory leak in tcf_pedit_init())
  		ret = tcf_idr_create(tn, parm->index, est, a,
  				     &act_pedit_ops, bind, false);
  		if (ret)
- 			return ret;
+ 			goto out_free;
  		p = to_pedit(*a);
  		keys = kmalloc(ksize, GFP_KERNEL);
 -		if (!keys) {
 +		if (keys == NULL) {
  			tcf_idr_release(*a, bind);
- 			kfree(keys_ex);
- 			return -ENOMEM;
+ 			ret = -ENOMEM;
+ 			goto out_free;
  		}
  		ret = ACT_P_CREATED;
  	} else {
@@@ -214,9 -225,13 +224,13 @@@
  	if (ret == ACT_P_CREATED)
  		tcf_idr_insert(tn, *a);
  	return ret;
+ out_free:
+ 	kfree(keys_ex);
+ 	return ret;
+ 
  }
  
 -static void tcf_pedit_cleanup(struct tc_action *a)
 +static void tcf_pedit_cleanup(struct tc_action *a, int bind)
  {
  	struct tcf_pedit *p = to_pedit(a);
  	struct tc_pedit_key *keys = p->tcfp_keys;
* Unmerged path net/sched/act_pedit.c
