perf stat: Pass 'struct perf_stat_config' argument to local print functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit f3ca50e61ff4aebfbefc666be2e064d277ad524c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f3ca50e6.failed

Add 'struct perf_stat_config' argument to print functions, so that those
functions can be moved out of the 'perf stat' command to a generic class
in the following patches.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20180830063252.23729-19-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit f3ca50e61ff4aebfbefc666be2e064d277ad524c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-stat.c
diff --cc tools/perf/builtin-stat.c
index a3a835604d08,f56da22abccc..000000000000
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@@ -1121,8 -990,10 +1124,15 @@@ static bool is_mixed_hw_group(struct pe
  	return false;
  }
  
++<<<<<<< HEAD
 +static void printout(int id, int nr, struct perf_evsel *counter, double uval,
 +		     char *prefix, u64 run, u64 ena, double noise)
++=======
+ static void printout(struct perf_stat_config *config, int id, int nr,
+ 		     struct perf_evsel *counter, double uval,
+ 		     char *prefix, u64 run, u64 ena, double noise,
+ 		     struct runtime_stat *st)
++>>>>>>> f3ca50e61ff4 (perf stat: Pass 'struct perf_stat_config' argument to local print functions)
  {
  	struct perf_stat_output_ctx out;
  	struct outstate os = {
@@@ -1218,10 -1085,10 +1228,10 @@@
  
  	perf_stat__print_shadow_stats(counter, uval,
  				first_shadow_cpu(counter, id),
 -				&out, &metric_events, st);
 +				&out, &metric_events);
  	if (!csv_output && !metric_only) {
- 		print_noise(counter, noise);
- 		print_running(run, ena);
+ 		print_noise(config, counter, noise);
+ 		print_running(config, run, ena);
  	}
  }
  
@@@ -1392,7 -1261,8 +1403,12 @@@ static void print_aggr(struct perf_stat
  				fprintf(output, "%s", prefix);
  
  			uval = val * counter->scale;
++<<<<<<< HEAD
 +			printout(id, nr, counter, uval, prefix, run, ena, 1.0);
++=======
+ 			printout(config, id, nr, counter, uval, prefix,
+ 				 run, ena, 1.0, &rt_stat);
++>>>>>>> f3ca50e61ff4 (perf stat: Pass 'struct perf_stat_config' argument to local print functions)
  			if (!metric_only)
  				fputc('\n', output);
  		}
@@@ -1418,13 -1299,64 +1434,70 @@@ static void print_aggr_thread(struct pe
  			run += perf_counts(counter->counts, cpu, thread)->run;
  		}
  
++<<<<<<< HEAD
 +		if (prefix)
 +			fprintf(output, "%s", prefix);
 +
 +		uval = val * counter->scale;
 +		printout(thread, 0, counter, uval, prefix, run, ena, 1.0);
++=======
+ 		uval = val * counter->scale;
+ 
+ 		/*
+ 		 * Skip value 0 when enabling --per-thread globally,
+ 		 * otherwise too many 0 output.
+ 		 */
+ 		if (uval == 0.0 && target__has_per_thread(&target))
+ 			continue;
+ 
+ 		buf[i].counter = counter;
+ 		buf[i].id = thread;
+ 		buf[i].uval = uval;
+ 		buf[i].val = val;
+ 		buf[i].run = run;
+ 		buf[i].ena = ena;
+ 		i++;
+ 	}
+ 
+ 	qsort(buf, i, sizeof(struct perf_aggr_thread_value), cmp_val);
+ 
+ 	if (ret)
+ 		*ret = i;
+ 
+ 	return buf;
+ }
+ 
+ static void print_aggr_thread(struct perf_stat_config *config,
+ 			      struct perf_evsel *counter, char *prefix)
+ {
+ 	FILE *output = config->output;
+ 	int nthreads = thread_map__nr(counter->threads);
+ 	int ncpus = cpu_map__nr(counter->cpus);
+ 	int thread, sorted_threads, id;
+ 	struct perf_aggr_thread_value *buf;
+ 
+ 	buf = sort_aggr_thread(counter, nthreads, ncpus, &sorted_threads);
+ 	if (!buf) {
+ 		perror("cannot sort aggr thread");
+ 		return;
+ 	}
+ 
+ 	for (thread = 0; thread < sorted_threads; thread++) {
+ 		if (prefix)
+ 			fprintf(output, "%s", prefix);
+ 
+ 		id = buf[thread].id;
+ 		if (config->stats)
+ 			printout(config, id, 0, buf[thread].counter, buf[thread].uval,
+ 				 prefix, buf[thread].run, buf[thread].ena, 1.0,
+ 				 &config->stats[id]);
+ 		else
+ 			printout(config, id, 0, buf[thread].counter, buf[thread].uval,
+ 				 prefix, buf[thread].run, buf[thread].ena, 1.0,
+ 				 &rt_stat);
++>>>>>>> f3ca50e61ff4 (perf stat: Pass 'struct perf_stat_config' argument to local print functions)
  		fputc('\n', output);
  	}
 -
 -	free(buf);
  }
  
  struct caggr_data {
@@@ -1459,7 -1392,8 +1533,12 @@@ static void print_counter_aggr(struct p
  		fprintf(output, "%s", prefix);
  
  	uval = cd.avg * counter->scale;
++<<<<<<< HEAD
 +	printout(-1, 0, counter, uval, prefix, cd.avg_running, cd.avg_enabled, cd.avg);
++=======
+ 	printout(config, -1, 0, counter, uval, prefix, cd.avg_running, cd.avg_enabled,
+ 		 cd.avg, &rt_stat);
++>>>>>>> f3ca50e61ff4 (perf stat: Pass 'struct perf_stat_config' argument to local print functions)
  	if (!metric_only)
  		fprintf(output, "\n");
  }
@@@ -1498,7 -1433,8 +1578,12 @@@ static void print_counter(struct perf_s
  			fprintf(output, "%s", prefix);
  
  		uval = val * counter->scale;
++<<<<<<< HEAD
 +		printout(cpu, 0, counter, uval, prefix, run, ena, 1.0);
++=======
+ 		printout(config, cpu, 0, counter, uval, prefix, run, ena, 1.0,
+ 			 &rt_stat);
++>>>>>>> f3ca50e61ff4 (perf stat: Pass 'struct perf_stat_config' argument to local print functions)
  
  		fputc('\n', output);
  	}
@@@ -1530,9 -1467,10 +1616,14 @@@ static void print_no_aggr_metric(struc
  			run = perf_counts(counter->counts, cpu, 0)->run;
  
  			uval = val * counter->scale;
++<<<<<<< HEAD
 +			printout(cpu, 0, counter, uval, prefix, run, ena, 1.0);
++=======
+ 			printout(config, cpu, 0, counter, uval, prefix, run, ena, 1.0,
+ 				 &rt_stat);
++>>>>>>> f3ca50e61ff4 (perf stat: Pass 'struct perf_stat_config' argument to local print functions)
  		}
- 		fputc('\n', stat_config.output);
+ 		fputc('\n', config->output);
  	}
  }
  
@@@ -1586,14 -1524,16 +1677,15 @@@ static void print_metric_headers(struc
  		perf_stat__print_shadow_stats(counter, 0,
  					      0,
  					      &out,
 -					      &metric_events,
 -					      &rt_stat);
 +					      &metric_events);
  	}
- 	fputc('\n', stat_config.output);
+ 	fputc('\n', config->output);
  }
  
- static void print_interval(char *prefix, struct timespec *ts)
+ static void print_interval(struct perf_stat_config *config,
+ 			   char *prefix, struct timespec *ts)
  {
- 	FILE *output = stat_config.output;
+ 	FILE *output = config->output;
  	static int num_print_interval;
  
  	if (interval_clear)
* Unmerged path tools/perf/builtin-stat.c
