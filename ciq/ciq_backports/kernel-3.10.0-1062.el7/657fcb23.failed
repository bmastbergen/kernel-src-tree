xfs: treat idx as a cursor in xfs_bmap_del_extent_*

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 657fcb23362c9e8a72593b3e4755135f003a7a74
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/657fcb23.failed

Stop poking before and after the index and just increment or decrement
it while doing our operations on it to prepare for a new extent list
implementation.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 657fcb23362c9e8a72593b3e4755135f003a7a74)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 905742f2f1f9,f64b6b74daa9..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -4645,12 -4644,213 +4645,216 @@@ xfs_bmap_split_indlen
  	return stolen;
  }
  
++<<<<<<< HEAD
++=======
+ int
+ xfs_bmap_del_extent_delay(
+ 	struct xfs_inode	*ip,
+ 	int			whichfork,
+ 	xfs_extnum_t		*idx,
+ 	struct xfs_bmbt_irec	*got,
+ 	struct xfs_bmbt_irec	*del)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	struct xfs_bmbt_irec	new;
+ 	int64_t			da_old, da_new, da_diff = 0;
+ 	xfs_fileoff_t		del_endoff, got_endoff;
+ 	xfs_filblks_t		got_indlen, new_indlen, stolen;
+ 	int			state = xfs_bmap_fork_to_state(whichfork);
+ 	int			error = 0;
+ 	bool			isrt;
+ 
+ 	XFS_STATS_INC(mp, xs_del_exlist);
+ 
+ 	isrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);
+ 	del_endoff = del->br_startoff + del->br_blockcount;
+ 	got_endoff = got->br_startoff + got->br_blockcount;
+ 	da_old = startblockval(got->br_startblock);
+ 	da_new = 0;
+ 
+ 	ASSERT(*idx >= 0);
+ 	ASSERT(*idx <= xfs_iext_count(ifp));
+ 	ASSERT(del->br_blockcount > 0);
+ 	ASSERT(got->br_startoff <= del->br_startoff);
+ 	ASSERT(got_endoff >= del_endoff);
+ 
+ 	if (isrt) {
+ 		uint64_t rtexts = XFS_FSB_TO_B(mp, del->br_blockcount);
+ 
+ 		do_div(rtexts, mp->m_sb.sb_rextsize);
+ 		xfs_mod_frextents(mp, rtexts);
+ 	}
+ 
+ 	/*
+ 	 * Update the inode delalloc counter now and wait to update the
+ 	 * sb counters as we might have to borrow some blocks for the
+ 	 * indirect block accounting.
+ 	 */
+ 	error = xfs_trans_reserve_quota_nblks(NULL, ip,
+ 			-((long)del->br_blockcount), 0,
+ 			isrt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);
+ 	if (error)
+ 		return error;
+ 	ip->i_delayed_blks -= del->br_blockcount;
+ 
+ 	if (got->br_startoff == del->br_startoff)
+ 		state |= BMAP_LEFT_FILLING;
+ 	if (got_endoff == del_endoff)
+ 		state |= BMAP_RIGHT_FILLING;
+ 
+ 	switch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {
+ 	case BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Matches the whole extent.  Delete the entry.
+ 		 */
+ 		xfs_iext_remove(ip, *idx, 1, state);
+ 		--*idx;
+ 		break;
+ 	case BMAP_LEFT_FILLING:
+ 		/*
+ 		 * Deleting the first part of the extent.
+ 		 */
+ 		got->br_startoff = del_endoff;
+ 		got->br_blockcount -= del->br_blockcount;
+ 		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
+ 				got->br_blockcount), da_old);
+ 		got->br_startblock = nullstartblock((int)da_new);
+ 		xfs_iext_update_extent(ip, state, *idx, got);
+ 		break;
+ 	case BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Deleting the last part of the extent.
+ 		 */
+ 		got->br_blockcount = got->br_blockcount - del->br_blockcount;
+ 		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
+ 				got->br_blockcount), da_old);
+ 		got->br_startblock = nullstartblock((int)da_new);
+ 		xfs_iext_update_extent(ip, state, *idx, got);
+ 		break;
+ 	case 0:
+ 		/*
+ 		 * Deleting the middle of the extent.
+ 		 *
+ 		 * Distribute the original indlen reservation across the two new
+ 		 * extents.  Steal blocks from the deleted extent if necessary.
+ 		 * Stealing blocks simply fudges the fdblocks accounting below.
+ 		 * Warn if either of the new indlen reservations is zero as this
+ 		 * can lead to delalloc problems.
+ 		 */
+ 		got->br_blockcount = del->br_startoff - got->br_startoff;
+ 		got_indlen = xfs_bmap_worst_indlen(ip, got->br_blockcount);
+ 
+ 		new.br_blockcount = got_endoff - del_endoff;
+ 		new_indlen = xfs_bmap_worst_indlen(ip, new.br_blockcount);
+ 
+ 		WARN_ON_ONCE(!got_indlen || !new_indlen);
+ 		stolen = xfs_bmap_split_indlen(da_old, &got_indlen, &new_indlen,
+ 						       del->br_blockcount);
+ 
+ 		got->br_startblock = nullstartblock((int)got_indlen);
+ 
+ 		new.br_startoff = del_endoff;
+ 		new.br_state = got->br_state;
+ 		new.br_startblock = nullstartblock((int)new_indlen);
+ 
+ 		xfs_iext_update_extent(ip, state, *idx, got);
+ 		++*idx;
+ 		xfs_iext_insert(ip, *idx, 1, &new, state);
+ 
+ 		da_new = got_indlen + new_indlen - stolen;
+ 		del->br_blockcount -= stolen;
+ 		break;
+ 	}
+ 
+ 	ASSERT(da_old >= da_new);
+ 	da_diff = da_old - da_new;
+ 	if (!isrt)
+ 		da_diff += del->br_blockcount;
+ 	if (da_diff)
+ 		xfs_mod_fdblocks(mp, da_diff, false);
+ 	return error;
+ }
+ 
+ void
+ xfs_bmap_del_extent_cow(
+ 	struct xfs_inode	*ip,
+ 	xfs_extnum_t		*idx,
+ 	struct xfs_bmbt_irec	*got,
+ 	struct xfs_bmbt_irec	*del)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, XFS_COW_FORK);
+ 	struct xfs_bmbt_irec	new;
+ 	xfs_fileoff_t		del_endoff, got_endoff;
+ 	int			state = BMAP_COWFORK;
+ 
+ 	XFS_STATS_INC(mp, xs_del_exlist);
+ 
+ 	del_endoff = del->br_startoff + del->br_blockcount;
+ 	got_endoff = got->br_startoff + got->br_blockcount;
+ 
+ 	ASSERT(*idx >= 0);
+ 	ASSERT(*idx <= xfs_iext_count(ifp));
+ 	ASSERT(del->br_blockcount > 0);
+ 	ASSERT(got->br_startoff <= del->br_startoff);
+ 	ASSERT(got_endoff >= del_endoff);
+ 	ASSERT(!isnullstartblock(got->br_startblock));
+ 
+ 	if (got->br_startoff == del->br_startoff)
+ 		state |= BMAP_LEFT_FILLING;
+ 	if (got_endoff == del_endoff)
+ 		state |= BMAP_RIGHT_FILLING;
+ 
+ 	switch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {
+ 	case BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Matches the whole extent.  Delete the entry.
+ 		 */
+ 		xfs_iext_remove(ip, *idx, 1, state);
+ 		--*idx;
+ 		break;
+ 	case BMAP_LEFT_FILLING:
+ 		/*
+ 		 * Deleting the first part of the extent.
+ 		 */
+ 		got->br_startoff = del_endoff;
+ 		got->br_blockcount -= del->br_blockcount;
+ 		got->br_startblock = del->br_startblock + del->br_blockcount;
+ 		xfs_iext_update_extent(ip, state, *idx, got);
+ 		break;
+ 	case BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Deleting the last part of the extent.
+ 		 */
+ 		got->br_blockcount -= del->br_blockcount;
+ 		xfs_iext_update_extent(ip, state, *idx, got);
+ 		break;
+ 	case 0:
+ 		/*
+ 		 * Deleting the middle of the extent.
+ 		 */
+ 		got->br_blockcount = del->br_startoff - got->br_startoff;
+ 
+ 		new.br_startoff = del_endoff;
+ 		new.br_blockcount = got_endoff - del_endoff;
+ 		new.br_state = got->br_state;
+ 		new.br_startblock = del->br_startblock + del->br_blockcount;
+ 
+ 		xfs_iext_update_extent(ip, state, *idx, got);
+ 		++*idx;
+ 		xfs_iext_insert(ip, *idx, 1, &new, state);
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 657fcb23362c (xfs: treat idx as a cursor in xfs_bmap_del_extent_*)
  /*
   * Called by xfs_bmapi to update file extent records and the btree
 - * after removing space.
 + * after removing space (or undoing a delayed allocation).
   */
  STATIC int				/* error */
 -xfs_bmap_del_extent_real(
 +xfs_bmap_del_extent(
  	xfs_inode_t		*ip,	/* incore inode pointer */
  	xfs_trans_t		*tp,	/* current transaction pointer */
  	xfs_extnum_t		*idx,	/* extent number to update/delete */
@@@ -4842,101 -4997,73 +5046,126 @@@
  		/*
  		 * Deleting the middle of the extent.
  		 */
 -		old = got;
 -
 -		got.br_blockcount = del->br_startoff - got.br_startoff;
 -		xfs_iext_update_extent(ip, state, *idx, &got);
 -
 +		temp = del->br_startoff - got.br_startoff;
 +		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
 +		xfs_bmbt_set_blockcount(ep, temp);
  		new.br_startoff = del_endoff;
 -		new.br_blockcount = got_endoff - del_endoff;
 +		temp2 = got_endoff - del_endoff;
 +		new.br_blockcount = temp2;
  		new.br_state = got.br_state;
 -		new.br_startblock = del_endblock;
 -
 -		flags |= XFS_ILOG_CORE;
 -		if (cur) {
 -			error = xfs_bmbt_update(cur, &got);
 -			if (error)
 -				goto done;
 -			error = xfs_btree_increment(cur, 0, &i);
 -			if (error)
 -				goto done;
 -			cur->bc_rec.b = new;
 -			error = xfs_btree_insert(cur, &i);
 -			if (error && error != -ENOSPC)
 -				goto done;
 -			/*
 -			 * If get no-space back from btree insert, it tried a
 -			 * split, and we have a zero block reservation.  Fix up
 -			 * our state and return the error.
 -			 */
 -			if (error == -ENOSPC) {
 +		if (!delay) {
 +			new.br_startblock = del_endblock;
 +			flags |= XFS_ILOG_CORE;
 +			if (cur) {
 +				if ((error = xfs_bmbt_update(cur,
 +						got.br_startoff,
 +						got.br_startblock, temp,
 +						got.br_state)))
 +					goto done;
 +				if ((error = xfs_btree_increment(cur, 0, &i)))
 +					goto done;
 +				cur->bc_rec.b = new;
 +				error = xfs_btree_insert(cur, &i);
 +				if (error && error != -ENOSPC)
 +					goto done;
  				/*
 -				 * Reset the cursor, don't trust it after any
 -				 * insert operation.
 +				 * If get no-space back from btree insert,
 +				 * it tried a split, and we have a zero
 +				 * block reservation.
 +				 * Fix up our state and return the error.
  				 */
 -				error = xfs_bmbt_lookup_eq(cur, &got, &i);
 -				if (error)
 +				if (error == -ENOSPC) {
 +					/*
 +					 * Reset the cursor, don't trust
 +					 * it after any insert operation.
 +					 */
 +					if ((error = xfs_bmbt_lookup_eq(cur,
 +							got.br_startoff,
 +							got.br_startblock,
 +							temp, &i)))
 +						goto done;
 +					XFS_WANT_CORRUPTED_GOTO(mp,
 +								i == 1, done);
 +					/*
 +					 * Update the btree record back
 +					 * to the original value.
 +					 */
 +					if ((error = xfs_bmbt_update(cur,
 +							got.br_startoff,
 +							got.br_startblock,
 +							got.br_blockcount,
 +							got.br_state)))
 +						goto done;
 +					/*
 +					 * Reset the extent record back
 +					 * to the original value.
 +					 */
 +					xfs_bmbt_set_blockcount(ep,
 +						got.br_blockcount);
 +					flags = 0;
 +					error = -ENOSPC;
  					goto done;
 +				}
  				XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
++<<<<<<< HEAD
 +			} else
 +				flags |= xfs_ilog_fext(whichfork);
 +			XFS_IFORK_NEXT_SET(ip, whichfork,
 +				XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
 +		} else {
 +			xfs_filblks_t	stolen;
 +			ASSERT(whichfork == XFS_DATA_FORK);
 +
 +			/*
 +			 * Distribute the original indlen reservation across the
 +			 * two new extents. Steal blocks from the deleted extent
 +			 * if necessary. Stealing blocks simply fudges the
 +			 * fdblocks accounting in xfs_bunmapi().
 +			 */
 +			temp = xfs_bmap_worst_indlen(ip, got.br_blockcount);
 +			temp2 = xfs_bmap_worst_indlen(ip, new.br_blockcount);
 +			stolen = xfs_bmap_split_indlen(da_old, &temp, &temp2,
 +						       del->br_blockcount);
 +			da_new = temp + temp2 - stolen;
 +			del->br_blockcount -= stolen;
 +
 +			/*
 +			 * Set the reservation for each extent. Warn if either
 +			 * is zero as this can lead to delalloc problems.
 +			 */
 +			WARN_ON_ONCE(!temp || !temp2);
 +			xfs_bmbt_set_startblock(ep, nullstartblock((int)temp));
 +			new.br_startblock = nullstartblock((int)temp2);
 +		}
 +		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
 +		xfs_iext_insert(ip, *idx + 1, 1, &new, state);
++=======
+ 				/*
+ 				 * Update the btree record back
+ 				 * to the original value.
+ 				 */
+ 				error = xfs_bmbt_update(cur, &old);
+ 				if (error)
+ 					goto done;
+ 				/*
+ 				 * Reset the extent record back
+ 				 * to the original value.
+ 				 */
+ 				xfs_iext_update_extent(ip, state, *idx, &old);
+ 				flags = 0;
+ 				error = -ENOSPC;
+ 				goto done;
+ 			}
+ 			XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
+ 		} else
+ 			flags |= xfs_ilog_fext(whichfork);
+ 		XFS_IFORK_NEXT_SET(ip, whichfork,
+ 			XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
++>>>>>>> 657fcb23362c (xfs: treat idx as a cursor in xfs_bmap_del_extent_*)
  		++*idx;
+ 		xfs_iext_insert(ip, *idx, 1, &new, state);
  		break;
  	}
 -
 -	/* remove reverse mapping */
 -	error = xfs_rmap_unmap_extent(mp, dfops, ip, whichfork, del);
 -	if (error)
 -		goto done;
 -
  	/*
  	 * If we need to, add to list of extents to delete.
  	 */
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
