perf tools: Enable BPF object configure syntax

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit a34f3be70cdf986850552e62b9f22d659bfbcef3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a34f3be7.failed

This patch adds the final step for BPF map configuration. A new syntax
is appended into parser so user can config BPF objects through '/' '/'
enclosed config terms.

After this patch, following syntax is available:

  # perf record -e ./test_bpf_map_1.c/map:channel.value=10/ ...

It would takes effect after appling following commits.

Test result:

  # cat ./test_bpf_map_1.c
  /************************ BEGIN **************************/
  #include <uapi/linux/bpf.h>
  #define SEC(NAME) __attribute__((section(NAME), used))
  struct bpf_map_def {
      unsigned int type;
      unsigned int key_size;
      unsigned int value_size;
      unsigned int max_entries;
  };
  static void *(*map_lookup_elem)(struct bpf_map_def *, void *) =
      (void *)BPF_FUNC_map_lookup_elem;
  static int (*trace_printk)(const char *fmt, int fmt_size, ...) =
      (void *)BPF_FUNC_trace_printk;
  struct bpf_map_def SEC("maps") channel = {
      .type = BPF_MAP_TYPE_ARRAY,
      .key_size = sizeof(int),
      .value_size = sizeof(int),
      .max_entries = 1,
  };
  SEC("func=sys_nanosleep")
  int func(void *ctx)
  {
      int key = 0;
      char fmt[] = "%d\n";
      int *pval = map_lookup_elem(&channel, &key);
      if (!pval)
          return 0;
      trace_printk(fmt, sizeof(fmt), *pval);
      return 0;
  }
  char _license[] SEC("license") = "GPL";
  int _version SEC("version") = LINUX_VERSION_CODE;
  /************************* END ***************************/

 - Normal case:
  # ./perf record -e './test_bpf_map_1.c/map:channel.value=10/' usleep 10
  [ perf record: Woken up 1 times to write data ]
  [ perf record: Captured and wrote 0.012 MB perf.data ]

 - Error case:

  # ./perf record -e './test_bpf_map_1.c/map:channel.value/' usleep 10
  event syntax error: '..ps:channel:value/'
                                   \___ Config value not set (missing '=')
  Hint:	Valid config term:
         map:[<arraymap>]:value=[value]
         (add -v to see detail)
  Run 'perf list' for a list of valid events

  Usage: perf record [<options>] [<command>]
     or: perf record [<options>] -- <command> [<options>]

     -e, --event <event>   event selector. use 'perf list' to list available events

  # ./perf record -e './test_bpf_map_1.c/xmap:channel.value=10/' usleep 10
  event syntax error: '..pf_map_1.c/xmap:channel.value=10/'
                                    \___ Invalid object config option
  [SNIP]

  # ./perf record -e './test_bpf_map_1.c/map:xchannel.value=10/' usleep 10
  event syntax error: '..p_1.c/map:xchannel.value=10/'
                                    \___ Target map not exist
  [SNIP]

  # ./perf record -e './test_bpf_map_1.c/map:channel.xvalue=10/' usleep 10
  event syntax error: '..ps:channel.xvalue=10/'
                                    \___ Invalid object map config option
  [SNIP]

  # ./perf record -e './test_bpf_map_1.c/map:channel.value=x10/' usleep 10
  event syntax error: '..nnel.value=x10/'
                                    \___ Incorrect value type for map
  [SNIP]

  Change BPF_MAP_TYPE_ARRAY to '1' in test_bpf_map_1.c:

  # ./perf record -e './test_bpf_map_1.c/map:channel.value=10/' usleep 10
  event syntax error: '..ps:channel.value=10/'
                                    \___ Can't use this config term to this type of map

  Hint:	Valid config term:
      	map:[<arraymap>].value=[value]
      	(add -v to see detail)

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
[for parser part]
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
	Cc: Cody P Schafer <dev@codyps.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Jeremie Galarneau <jeremie.galarneau@efficios.com>
	Cc: Kirill Smelkov <kirr@nexedi.com>
	Cc: Li Zefan <lizefan@huawei.com>
	Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/1456132275-98875-5-git-send-email-wangnan0@huawei.com
	Signed-off-by: He Kuang <hekuang@huawei.com>
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit a34f3be70cdf986850552e62b9f22d659bfbcef3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/parse-events.c
#	tools/perf/util/parse-events.h
#	tools/perf/util/parse-events.l
#	tools/perf/util/parse-events.y
diff --cc tools/perf/util/parse-events.c
index 3a234b74d6ff,a5dd6703a56b..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -590,6 -578,180 +590,183 @@@ static int add_tracepoint_multi_sys(str
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ struct __add_bpf_event_param {
+ 	struct parse_events_evlist *data;
+ 	struct list_head *list;
+ };
+ 
+ static int add_bpf_event(struct probe_trace_event *tev, int fd,
+ 			 void *_param)
+ {
+ 	LIST_HEAD(new_evsels);
+ 	struct __add_bpf_event_param *param = _param;
+ 	struct parse_events_evlist *evlist = param->data;
+ 	struct list_head *list = param->list;
+ 	struct perf_evsel *pos;
+ 	int err;
+ 
+ 	pr_debug("add bpf event %s:%s and attach bpf program %d\n",
+ 		 tev->group, tev->event, fd);
+ 
+ 	err = parse_events_add_tracepoint(&new_evsels, &evlist->idx, tev->group,
+ 					  tev->event, evlist->error, NULL);
+ 	if (err) {
+ 		struct perf_evsel *evsel, *tmp;
+ 
+ 		pr_debug("Failed to add BPF event %s:%s\n",
+ 			 tev->group, tev->event);
+ 		list_for_each_entry_safe(evsel, tmp, &new_evsels, node) {
+ 			list_del(&evsel->node);
+ 			perf_evsel__delete(evsel);
+ 		}
+ 		return err;
+ 	}
+ 	pr_debug("adding %s:%s\n", tev->group, tev->event);
+ 
+ 	list_for_each_entry(pos, &new_evsels, node) {
+ 		pr_debug("adding %s:%s to %p\n",
+ 			 tev->group, tev->event, pos);
+ 		pos->bpf_fd = fd;
+ 	}
+ 	list_splice(&new_evsels, list);
+ 	return 0;
+ }
+ 
+ int parse_events_load_bpf_obj(struct parse_events_evlist *data,
+ 			      struct list_head *list,
+ 			      struct bpf_object *obj)
+ {
+ 	int err;
+ 	char errbuf[BUFSIZ];
+ 	struct __add_bpf_event_param param = {data, list};
+ 	static bool registered_unprobe_atexit = false;
+ 
+ 	if (IS_ERR(obj) || !obj) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Internal error: load bpf obj with NULL");
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 
+ 	/*
+ 	 * Register atexit handler before calling bpf__probe() so
+ 	 * bpf__probe() don't need to unprobe probe points its already
+ 	 * created when failure.
+ 	 */
+ 	if (!registered_unprobe_atexit) {
+ 		atexit(bpf__clear);
+ 		registered_unprobe_atexit = true;
+ 	}
+ 
+ 	err = bpf__probe(obj);
+ 	if (err) {
+ 		bpf__strerror_probe(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__load(obj);
+ 	if (err) {
+ 		bpf__strerror_load(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__foreach_tev(obj, add_bpf_event, &param);
+ 	if (err) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Attach events in BPF object failed");
+ 		goto errout;
+ 	}
+ 
+ 	return 0;
+ errout:
+ 	data->error->help = strdup("(add -v to see detail)");
+ 	data->error->str = strdup(errbuf);
+ 	return err;
+ }
+ 
+ static int
+ parse_events_config_bpf(struct parse_events_evlist *data,
+ 			struct bpf_object *obj,
+ 			struct list_head *head_config)
+ {
+ 	struct parse_events_term *term;
+ 	int error_pos;
+ 
+ 	if (!head_config || list_empty(head_config))
+ 		return 0;
+ 
+ 	list_for_each_entry(term, head_config, list) {
+ 		char errbuf[BUFSIZ];
+ 		int err;
+ 
+ 		if (term->type_term != PARSE_EVENTS__TERM_TYPE_USER) {
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "Invalid config term for BPF object");
+ 			errbuf[BUFSIZ - 1] = '\0';
+ 
+ 			data->error->idx = term->err_term;
+ 			data->error->str = strdup(errbuf);
+ 			return -EINVAL;
+ 		}
+ 
+ 		err = bpf__config_obj(obj, term, NULL, &error_pos);
+ 		if (err) {
+ 			bpf__strerror_config_obj(obj, term, NULL,
+ 						 &error_pos, err, errbuf,
+ 						 sizeof(errbuf));
+ 			data->error->help = strdup(
+ "Hint:\tValid config term:\n"
+ "     \tmap:[<arraymap>].value=[value]\n"
+ "     \t(add -v to see detail)");
+ 			data->error->str = strdup(errbuf);
+ 			if (err == -BPF_LOADER_ERRNO__OBJCONF_MAP_VALUE)
+ 				data->error->idx = term->err_val;
+ 			else
+ 				data->error->idx = term->err_term + error_pos;
+ 			return err;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ int parse_events_load_bpf(struct parse_events_evlist *data,
+ 			  struct list_head *list,
+ 			  char *bpf_file_name,
+ 			  bool source,
+ 			  struct list_head *head_config)
+ {
+ 	struct bpf_object *obj;
+ 	int err;
+ 
+ 	obj = bpf__prepare_load(bpf_file_name, source);
+ 	if (IS_ERR(obj)) {
+ 		char errbuf[BUFSIZ];
+ 
+ 		err = PTR_ERR(obj);
+ 
+ 		if (err == -ENOTSUP)
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "BPF support is not compiled");
+ 		else
+ 			bpf__strerror_prepare_load(bpf_file_name,
+ 						   source,
+ 						   -err, errbuf,
+ 						   sizeof(errbuf));
+ 
+ 		data->error->help = strdup("(add -v to see detail)");
+ 		data->error->str = strdup(errbuf);
+ 		return err;
+ 	}
+ 
+ 	err = parse_events_load_bpf_obj(data, list, obj);
+ 	if (err)
+ 		return err;
+ 	return parse_events_config_bpf(data, obj, head_config);
+ }
+ 
++>>>>>>> a34f3be70cdf (perf tools: Enable BPF object configure syntax)
  static int
  parse_breakpoint_type(const char *type, struct perf_event_attr *attr)
  {
diff --cc tools/perf/util/parse-events.h
index 411808bd5db5,c48377ad4e82..000000000000
--- a/tools/perf/util/parse-events.h
+++ b/tools/perf/util/parse-events.h
@@@ -128,10 -123,20 +128,24 @@@ int parse_events__modifier_event(struc
  int parse_events__modifier_group(struct list_head *list, char *event_mod);
  int parse_events_name(struct list_head *list, char *name);
  int parse_events_add_tracepoint(struct list_head *list, int *idx,
 -				char *sys, char *event,
 +				const char *sys, const char *event,
  				struct parse_events_error *error,
  				struct list_head *head_config);
++<<<<<<< HEAD
 +int parse_events_add_numeric(struct parse_events_state *parse_state,
++=======
+ int parse_events_load_bpf(struct parse_events_evlist *data,
+ 			  struct list_head *list,
+ 			  char *bpf_file_name,
+ 			  bool source,
+ 			  struct list_head *head_config);
+ /* Provide this function for perf test */
+ struct bpf_object;
+ int parse_events_load_bpf_obj(struct parse_events_evlist *data,
+ 			      struct list_head *list,
+ 			      struct bpf_object *obj);
+ int parse_events_add_numeric(struct parse_events_evlist *data,
++>>>>>>> a34f3be70cdf (perf tools: Enable BPF object configure syntax)
  			     struct list_head *list,
  			     u32 type, u64 config,
  			     struct list_head *head_config);
diff --cc tools/perf/util/parse-events.l
index 32c8c241ab5c,0cc6b84a740a..000000000000
--- a/tools/perf/util/parse-events.l
+++ b/tools/perf/util/parse-events.l
@@@ -140,10 -122,9 +140,14 @@@ num_dec		[0-9]
  num_hex		0x[a-fA-F0-9]+
  num_raw_hex	[a-fA-F0-9]+
  name		[a-zA-Z_*?][a-zA-Z0-9_*?.]*
++<<<<<<< HEAD
 +name_minus	[a-zA-Z_*?][a-zA-Z0-9\-_*?.]*
 +drv_cfg_term	[a-zA-Z0-9_\.]+(=[a-zA-Z0-9_*?\.:]+)?
++=======
+ name_minus	[a-zA-Z_*?][a-zA-Z0-9\-_*?.:]*
++>>>>>>> a34f3be70cdf (perf tools: Enable BPF object configure syntax)
  /* If you add a modifier you need to update check_modifier() */
 -modifier_event	[ukhpPGHSDI]+
 +modifier_event	[ukhpPGHSDIW]+
  modifier_bp	[rwx]{1,3}
  
  %%
diff --cc tools/perf/util/parse-events.y
index b7975dc972b1,0e2d433e4ffa..000000000000
--- a/tools/perf/util/parse-events.y
+++ b/tools/perf/util/parse-events.y
@@@ -438,6 -436,30 +438,33 @@@ PE_RAW opt_event_confi
  	$$ = list;
  }
  
++<<<<<<< HEAD
++=======
+ event_bpf_file:
+ PE_BPF_OBJECT opt_event_config
+ {
+ 	struct parse_events_evlist *data = _data;
+ 	struct parse_events_error *error = data->error;
+ 	struct list_head *list;
+ 
+ 	ALLOC_LIST(list);
+ 	ABORT_ON(parse_events_load_bpf(data, list, $1, false, $2));
+ 	parse_events_terms__delete($2);
+ 	$$ = list;
+ }
+ |
+ PE_BPF_SOURCE opt_event_config
+ {
+ 	struct parse_events_evlist *data = _data;
+ 	struct list_head *list;
+ 
+ 	ALLOC_LIST(list);
+ 	ABORT_ON(parse_events_load_bpf(data, list, $1, true, $2));
+ 	parse_events_terms__delete($2);
+ 	$$ = list;
+ }
+ 
++>>>>>>> a34f3be70cdf (perf tools: Enable BPF object configure syntax)
  opt_event_config:
  '/' event_config '/'
  {
* Unmerged path tools/perf/util/parse-events.c
* Unmerged path tools/perf/util/parse-events.h
* Unmerged path tools/perf/util/parse-events.l
* Unmerged path tools/perf/util/parse-events.y
