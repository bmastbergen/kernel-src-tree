kvm: nVMX: Eliminate APIC access page sharing between L1 and L2

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jim Mattson <jmattson@google.com>
commit ab5df31cee7f8f17adb59717cf569d315ec02644
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ab5df31c.failed

It is only possible to share the APIC access page between L1 and L2 if
they also share the virtual-APIC page.  If L2 has its own virtual-APIC
page, then MMIO accesses to L1's TPR from L2 will access L2's TPR
instead.  Moreover, L1's local APIC has to be in xAPIC mode, which is
another condition that hasn't been checked.

	Signed-off-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit ab5df31cee7f8f17adb59717cf569d315ec02644)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 5501a1957de2,ea098131dcce..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -8747,25 -9329,10 +8749,29 @@@ static void vmx_set_virtual_x2apic_mode
  
  static void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu, hpa_t hpa)
  {
++<<<<<<< HEAD
 +	struct vcpu_vmx *vmx = to_vmx(vcpu);
 +
 +	/*
 +	 * Currently we do not handle the nested case where L2 has an
 +	 * APIC access page of its own; that page is still pinned.
 +	 * Hence, we skip the case where the VCPU is in guest mode _and_
 +	 * L1 prepared an APIC access page for L2.
 +	 *
 +	 * For the case where L1 and L2 share the same APIC access page
 +	 * (flexpriority=Y but SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES clear
 +	 * in the vmcs12), this function will only update either the vmcs01
 +	 * or the vmcs02.  If the former, the vmcs02 will be updated by
 +	 * prepare_vmcs02.  If the latter, the vmcs01 will be updated in
 +	 * the next L2->L1 exit.
 +	 */
 +	if (!is_guest_mode(vcpu) ||
 +	    !nested_cpu_has2(get_vmcs12(&vmx->vcpu),
 +			     SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))
++=======
+ 	if (!is_guest_mode(vcpu)) {
++>>>>>>> ab5df31cee7f (kvm: nVMX: Eliminate APIC access page sharing between L1 and L2)
  		vmcs_write64(APIC_ACCESS_ADDR, hpa);
 -		vmx_flush_tlb(vcpu, true);
 -	}
  }
  
  static void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)
* Unmerged path arch/x86/kvm/vmx.c
