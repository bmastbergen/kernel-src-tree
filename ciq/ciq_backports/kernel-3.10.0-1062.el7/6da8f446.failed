ALSA: hda/ca0132 - Optimize for non-PCI configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 6da8f44624ad99fbd10f9e8e87a46aa3a61c1e9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6da8f446.failed

All the recent support of Creative boards and onboard audio depend on
PCI, but they can't be trimmed easily even if you build without
CONFIG_PCI, since the quirk is detected dynamically and the code has
many branches with the flag check like spec->quirk type or
spec->use_alt_functions.

This patch makes these checks static for CONFIG_PCI=n case so that the
compiler optimizes out.  The access to flags are replaced with macros
that are replaced with a static value for CONFIG_PCI=n.

The macros look slightly ugly for avoiding compiler warnings wrt
unused variables, and some additional default-case handlings for
another compiler warnings, but the rest are very straightforward
changes.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 6da8f44624ad99fbd10f9e8e87a46aa3a61c1e9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index e10b8cea0b28,9c0b94ba786e..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -769,9 -1072,27 +769,21 @@@ struct ca0132_spec 
  enum {
  	QUIRK_NONE,
  	QUIRK_ALIENWARE,
 -	QUIRK_ALIENWARE_M17XR4,
 -	QUIRK_SBZ,
 -	QUIRK_ZXR,
 -	QUIRK_ZXR_DBPRO,
 -	QUIRK_R3DI,
 -	QUIRK_R3D,
 -	QUIRK_AE5,
 +	QUIRK_GENERIC_PARSER,
  };
  
+ #ifdef CONFIG_PCI
+ #define ca0132_quirk(spec)		((spec)->quirk)
+ #define ca0132_use_pci_mmio(spec)	((spec)->use_pci_mmio)
+ #define ca0132_use_alt_functions(spec)	((spec)->use_alt_functions)
+ #define ca0132_use_alt_controls(spec)	((spec)->use_alt_controls)
+ #else
+ #define ca0132_quirk(spec)		({ (void)(spec); QUIRK_NONE; })
+ #define ca0132_use_alt_functions(spec)	({ (void)(spec); false; })
+ #define ca0132_use_pci_mmio(spec)	({ (void)(spec); false; })
+ #define ca0132_use_alt_controls(spec)	({ (void)(spec); false; })
+ #endif
+ 
  static const struct hda_pintbl alienware_pincfgs[] = {
  	{ 0x0b, 0x90170110 }, /* Builtin Speaker */
  	{ 0x0c, 0x411111f0 }, /* N/A */
@@@ -2663,14 -3110,16 +2675,21 @@@ exit
   */
  static void dspload_post_setup(struct hda_codec *codec)
  {
 -	struct ca0132_spec *spec = codec->spec;
  	codec_dbg(codec, "---- dspload_post_setup ------\n");
++<<<<<<< HEAD
++=======
+ 	if (!ca0132_use_alt_functions(spec)) {
+ 		/*set DSP speaker to 2.0 configuration*/
+ 		chipio_write(codec, XRAM_XRAM_INST_OFFSET(0x18), 0x08080080);
+ 		chipio_write(codec, XRAM_XRAM_INST_OFFSET(0x19), 0x3f800000);
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  
 -		/*update write pointer*/
 -		chipio_write(codec, XRAM_XRAM_INST_OFFSET(0x29), 0x00000002);
 -	}
 +	/*set DSP speaker to 2.0 configuration*/
 +	chipio_write(codec, XRAM_XRAM_INST_OFFSET(0x18), 0x08080080);
 +	chipio_write(codec, XRAM_XRAM_INST_OFFSET(0x19), 0x3f800000);
 +
 +	/*update write pointer*/
 +	chipio_write(codec, XRAM_XRAM_INST_OFFSET(0x29), 0x00000002);
  }
  
  /**
@@@ -2778,6 -3227,281 +2797,284 @@@ static bool dspload_wait_loaded(struct 
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * ca0113 related functions. The ca0113 acts as the HDA bus for the pci-e
+  * based cards, and has a second mmio region, region2, that's used for special
+  * commands.
+  */
+ 
+ /*
+  * For cards with PCI-E region2 (Sound Blaster Z/ZxR, Recon3D, and AE-5)
+  * the mmio address 0x320 is used to set GPIO pins. The format for the data
+  * The first eight bits are just the number of the pin. So far, I've only seen
+  * this number go to 7.
+  * AE-5 note: The AE-5 seems to use pins 2 and 3 to somehow set the color value
+  * of the on-card LED. It seems to use pin 2 for data, then toggles 3 to on and
+  * then off to send that bit.
+  */
+ static void ca0113_mmio_gpio_set(struct hda_codec *codec, unsigned int gpio_pin,
+ 		bool enable)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned short gpio_data;
+ 
+ 	gpio_data = gpio_pin & 0xF;
+ 	gpio_data |= ((enable << 8) & 0x100);
+ 
+ 	writew(gpio_data, spec->mem_base + 0x320);
+ }
+ 
+ /*
+  * Special pci region2 commands that are only used by the AE-5. They follow
+  * a set format, and require reads at certain points to seemingly 'clear'
+  * the response data. My first tests didn't do these reads, and would cause
+  * the card to get locked up until the memory was read. These commands
+  * seem to work with three distinct values that I've taken to calling group,
+  * target-id, and value.
+  */
+ static void ca0113_mmio_command_set(struct hda_codec *codec, unsigned int group,
+ 		unsigned int target, unsigned int value)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int write_val;
+ 
+ 	writel(0x0000007e, spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 	writel(0x0000005a, spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 
+ 	writel(0x00800005, spec->mem_base + 0x20c);
+ 	writel(group, spec->mem_base + 0x804);
+ 
+ 	writel(0x00800005, spec->mem_base + 0x20c);
+ 	write_val = (target & 0xff);
+ 	write_val |= (value << 8);
+ 
+ 
+ 	writel(write_val, spec->mem_base + 0x204);
+ 	/*
+ 	 * Need delay here or else it goes too fast and works inconsistently.
+ 	 */
+ 	msleep(20);
+ 
+ 	readl(spec->mem_base + 0x860);
+ 	readl(spec->mem_base + 0x854);
+ 	readl(spec->mem_base + 0x840);
+ 
+ 	writel(0x00800004, spec->mem_base + 0x20c);
+ 	writel(0x00000000, spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ }
+ 
+ /*
+  * This second type of command is used for setting the sound filter type.
+  */
+ static void ca0113_mmio_command_set_type2(struct hda_codec *codec,
+ 		unsigned int group, unsigned int target, unsigned int value)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int write_val;
+ 
+ 	writel(0x0000007e, spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 	writel(0x0000005a, spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 
+ 	writel(0x00800003, spec->mem_base + 0x20c);
+ 	writel(group, spec->mem_base + 0x804);
+ 
+ 	writel(0x00800005, spec->mem_base + 0x20c);
+ 	write_val = (target & 0xff);
+ 	write_val |= (value << 8);
+ 
+ 
+ 	writel(write_val, spec->mem_base + 0x204);
+ 	msleep(20);
+ 	readl(spec->mem_base + 0x860);
+ 	readl(spec->mem_base + 0x854);
+ 	readl(spec->mem_base + 0x840);
+ 
+ 	writel(0x00800004, spec->mem_base + 0x20c);
+ 	writel(0x00000000, spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ 	readl(spec->mem_base + 0x210);
+ }
+ 
+ /*
+  * Setup GPIO for the other variants of Core3D.
+  */
+ 
+ /*
+  * Sets up the GPIO pins so that they are discoverable. If this isn't done,
+  * the card shows as having no GPIO pins.
+  */
+ static void ca0132_gpio_init(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	switch (ca0132_quirk(spec)) {
+ 	case QUIRK_SBZ:
+ 	case QUIRK_AE5:
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x793, 0x00);
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x794, 0x53);
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x790, 0x23);
+ 		break;
+ 	case QUIRK_R3DI:
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x793, 0x00);
+ 		snd_hda_codec_write(codec, 0x01, 0, 0x794, 0x5B);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ }
+ 
+ /* Sets the GPIO for audio output. */
+ static void ca0132_gpio_setup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	switch (ca0132_quirk(spec)) {
+ 	case QUIRK_SBZ:
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DIRECTION, 0x07);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_MASK, 0x07);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DATA, 0x04);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DATA, 0x06);
+ 		break;
+ 	case QUIRK_R3DI:
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DIRECTION, 0x1E);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_MASK, 0x1F);
+ 		snd_hda_codec_write(codec, 0x01, 0,
+ 				AC_VERB_SET_GPIO_DATA, 0x0C);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ /*
+  * GPIO control functions for the Recon3D integrated.
+  */
+ 
+ enum r3di_gpio_bit {
+ 	/* Bit 1 - Switch between front/rear mic. 0 = rear, 1 = front */
+ 	R3DI_MIC_SELECT_BIT = 1,
+ 	/* Bit 2 - Switch between headphone/line out. 0 = Headphone, 1 = Line */
+ 	R3DI_OUT_SELECT_BIT = 2,
+ 	/*
+ 	 * I dunno what this actually does, but it stays on until the dsp
+ 	 * is downloaded.
+ 	 */
+ 	R3DI_GPIO_DSP_DOWNLOADING = 3,
+ 	/*
+ 	 * Same as above, no clue what it does, but it comes on after the dsp
+ 	 * is downloaded.
+ 	 */
+ 	R3DI_GPIO_DSP_DOWNLOADED = 4
+ };
+ 
+ enum r3di_mic_select {
+ 	/* Set GPIO bit 1 to 0 for rear mic */
+ 	R3DI_REAR_MIC = 0,
+ 	/* Set GPIO bit 1 to 1 for front microphone*/
+ 	R3DI_FRONT_MIC = 1
+ };
+ 
+ enum r3di_out_select {
+ 	/* Set GPIO bit 2 to 0 for headphone */
+ 	R3DI_HEADPHONE_OUT = 0,
+ 	/* Set GPIO bit 2 to 1 for speaker */
+ 	R3DI_LINE_OUT = 1
+ };
+ enum r3di_dsp_status {
+ 	/* Set GPIO bit 3 to 1 until DSP is downloaded */
+ 	R3DI_DSP_DOWNLOADING = 0,
+ 	/* Set GPIO bit 4 to 1 once DSP is downloaded */
+ 	R3DI_DSP_DOWNLOADED = 1
+ };
+ 
+ 
+ static void r3di_gpio_mic_set(struct hda_codec *codec,
+ 		enum r3di_mic_select cur_mic)
+ {
+ 	unsigned int cur_gpio;
+ 
+ 	/* Get the current GPIO Data setup */
+ 	cur_gpio = snd_hda_codec_read(codec, 0x01, 0, AC_VERB_GET_GPIO_DATA, 0);
+ 
+ 	switch (cur_mic) {
+ 	case R3DI_REAR_MIC:
+ 		cur_gpio &= ~(1 << R3DI_MIC_SELECT_BIT);
+ 		break;
+ 	case R3DI_FRONT_MIC:
+ 		cur_gpio |= (1 << R3DI_MIC_SELECT_BIT);
+ 		break;
+ 	}
+ 	snd_hda_codec_write(codec, codec->core.afg, 0,
+ 			    AC_VERB_SET_GPIO_DATA, cur_gpio);
+ }
+ 
+ static void r3di_gpio_out_set(struct hda_codec *codec,
+ 		enum r3di_out_select cur_out)
+ {
+ 	unsigned int cur_gpio;
+ 
+ 	/* Get the current GPIO Data setup */
+ 	cur_gpio = snd_hda_codec_read(codec, 0x01, 0, AC_VERB_GET_GPIO_DATA, 0);
+ 
+ 	switch (cur_out) {
+ 	case R3DI_HEADPHONE_OUT:
+ 		cur_gpio &= ~(1 << R3DI_OUT_SELECT_BIT);
+ 		break;
+ 	case R3DI_LINE_OUT:
+ 		cur_gpio |= (1 << R3DI_OUT_SELECT_BIT);
+ 		break;
+ 	}
+ 	snd_hda_codec_write(codec, codec->core.afg, 0,
+ 			    AC_VERB_SET_GPIO_DATA, cur_gpio);
+ }
+ 
+ static void r3di_gpio_dsp_status_set(struct hda_codec *codec,
+ 		enum r3di_dsp_status dsp_status)
+ {
+ 	unsigned int cur_gpio;
+ 
+ 	/* Get the current GPIO Data setup */
+ 	cur_gpio = snd_hda_codec_read(codec, 0x01, 0, AC_VERB_GET_GPIO_DATA, 0);
+ 
+ 	switch (dsp_status) {
+ 	case R3DI_DSP_DOWNLOADING:
+ 		cur_gpio |= (1 << R3DI_GPIO_DSP_DOWNLOADING);
+ 		snd_hda_codec_write(codec, codec->core.afg, 0,
+ 				AC_VERB_SET_GPIO_DATA, cur_gpio);
+ 		break;
+ 	case R3DI_DSP_DOWNLOADED:
+ 		/* Set DOWNLOADING bit to 0. */
+ 		cur_gpio &= ~(1 << R3DI_GPIO_DSP_DOWNLOADING);
+ 
+ 		snd_hda_codec_write(codec, codec->core.afg, 0,
+ 				AC_VERB_SET_GPIO_DATA, cur_gpio);
+ 
+ 		cur_gpio |= (1 << R3DI_GPIO_DSP_DOWNLOADED);
+ 		break;
+ 	}
+ 
+ 	snd_hda_codec_write(codec, codec->core.afg, 0,
+ 			    AC_VERB_SET_GPIO_DATA, cur_gpio);
+ }
+ 
+ /*
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
   * PCM callbacks
   */
  static int ca0132_playback_pcm_prepare(struct hda_pcm_stream *hinfo,
@@@ -3339,13 -4160,318 +3636,325 @@@ exit
  	return err < 0 ? err : 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int ae5_headphone_gain_set(struct hda_codec *codec, long val);
+ static int zxr_headphone_gain_set(struct hda_codec *codec, long val);
+ static int ca0132_effects_set(struct hda_codec *codec, hda_nid_t nid, long val);
+ 
+ static void ae5_mmio_select_out(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < AE5_CA0113_OUT_SET_COMMANDS; i++)
+ 		ca0113_mmio_command_set(codec,
+ 			ae5_ca0113_output_presets[spec->cur_out_type].group[i],
+ 			ae5_ca0113_output_presets[spec->cur_out_type].target[i],
+ 			ae5_ca0113_output_presets[spec->cur_out_type].vals[i]);
+ }
+ 
+ /*
+  * These are the commands needed to setup output on each of the different card
+  * types.
+  */
+ static void ca0132_alt_select_out_quirk_handler(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	switch (spec->cur_out_type) {
+ 	case SPEAKER_OUT:
+ 		switch (ca0132_quirk(spec)) {
+ 		case QUIRK_SBZ:
+ 			ca0113_mmio_gpio_set(codec, 7, false);
+ 			ca0113_mmio_gpio_set(codec, 4, true);
+ 			ca0113_mmio_gpio_set(codec, 1, true);
+ 			chipio_set_control_param(codec, 0x0d, 0x18);
+ 			break;
+ 		case QUIRK_ZXR:
+ 			ca0113_mmio_gpio_set(codec, 2, true);
+ 			ca0113_mmio_gpio_set(codec, 3, true);
+ 			ca0113_mmio_gpio_set(codec, 5, false);
+ 			zxr_headphone_gain_set(codec, 0);
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			break;
+ 		case QUIRK_R3DI:
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			r3di_gpio_out_set(codec, R3DI_LINE_OUT);
+ 			break;
+ 		case QUIRK_R3D:
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			ca0113_mmio_gpio_set(codec, 1, true);
+ 			break;
+ 		case QUIRK_AE5:
+ 			ae5_mmio_select_out(codec);
+ 			ae5_headphone_gain_set(codec, 2);
+ 			tmp = FLOAT_ZERO;
+ 			dspio_set_uint_param(codec, 0x96, 0x29, tmp);
+ 			dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
+ 			chipio_set_control_param(codec, 0x0d, 0xa4);
+ 			chipio_write(codec, 0x18b03c, 0x00000012);
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		break;
+ 	case HEADPHONE_OUT:
+ 		switch (ca0132_quirk(spec)) {
+ 		case QUIRK_SBZ:
+ 			ca0113_mmio_gpio_set(codec, 7, true);
+ 			ca0113_mmio_gpio_set(codec, 4, true);
+ 			ca0113_mmio_gpio_set(codec, 1, false);
+ 			chipio_set_control_param(codec, 0x0d, 0x12);
+ 			break;
+ 		case QUIRK_ZXR:
+ 			ca0113_mmio_gpio_set(codec, 2, false);
+ 			ca0113_mmio_gpio_set(codec, 3, false);
+ 			ca0113_mmio_gpio_set(codec, 5, true);
+ 			zxr_headphone_gain_set(codec, spec->zxr_gain_set);
+ 			chipio_set_control_param(codec, 0x0d, 0x21);
+ 			break;
+ 		case QUIRK_R3DI:
+ 			chipio_set_control_param(codec, 0x0d, 0x21);
+ 			r3di_gpio_out_set(codec, R3DI_HEADPHONE_OUT);
+ 			break;
+ 		case QUIRK_R3D:
+ 			chipio_set_control_param(codec, 0x0d, 0x21);
+ 			ca0113_mmio_gpio_set(codec, 0x1, false);
+ 			break;
+ 		case QUIRK_AE5:
+ 			ae5_mmio_select_out(codec);
+ 			ae5_headphone_gain_set(codec,
+ 					spec->ae5_headphone_gain_val);
+ 			tmp = FLOAT_ONE;
+ 			dspio_set_uint_param(codec, 0x96, 0x29, tmp);
+ 			dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
+ 			chipio_set_control_param(codec, 0x0d, 0xa1);
+ 			chipio_write(codec, 0x18b03c, 0x00000012);
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		break;
+ 	case SURROUND_OUT:
+ 		switch (ca0132_quirk(spec)) {
+ 		case QUIRK_SBZ:
+ 			ca0113_mmio_gpio_set(codec, 7, false);
+ 			ca0113_mmio_gpio_set(codec, 4, true);
+ 			ca0113_mmio_gpio_set(codec, 1, true);
+ 			chipio_set_control_param(codec, 0x0d, 0x18);
+ 			break;
+ 		case QUIRK_ZXR:
+ 			ca0113_mmio_gpio_set(codec, 2, true);
+ 			ca0113_mmio_gpio_set(codec, 3, true);
+ 			ca0113_mmio_gpio_set(codec, 5, false);
+ 			zxr_headphone_gain_set(codec, 0);
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			break;
+ 		case QUIRK_R3DI:
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			r3di_gpio_out_set(codec, R3DI_LINE_OUT);
+ 			break;
+ 		case QUIRK_R3D:
+ 			ca0113_mmio_gpio_set(codec, 1, true);
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			break;
+ 		case QUIRK_AE5:
+ 			ae5_mmio_select_out(codec);
+ 			ae5_headphone_gain_set(codec, 2);
+ 			tmp = FLOAT_ZERO;
+ 			dspio_set_uint_param(codec, 0x96, 0x29, tmp);
+ 			dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
+ 			chipio_set_control_param(codec, 0x0d, 0xa4);
+ 			chipio_write(codec, 0x18b03c, 0x00000012);
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		break;
+ 	}
+ }
+ 
+ /*
+  * This function behaves similarly to the ca0132_select_out funciton above,
+  * except with a few differences. It adds the ability to select the current
+  * output with an enumerated control "output source" if the auto detect
+  * mute switch is set to off. If the auto detect mute switch is enabled, it
+  * will detect either headphone or lineout(SPEAKER_OUT) from jack detection.
+  * It also adds the ability to auto-detect the front headphone port. The only
+  * way to select surround is to disable auto detect, and set Surround with the
+  * enumerated control.
+  */
+ static int ca0132_alt_select_out(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int pin_ctl;
+ 	int jack_present;
+ 	int auto_jack;
+ 	unsigned int i;
+ 	unsigned int tmp;
+ 	int err;
+ 	/* Default Headphone is rear headphone */
+ 	hda_nid_t headphone_nid = spec->out_pins[1];
+ 
+ 	codec_dbg(codec, "%s\n", __func__);
+ 
+ 	snd_hda_power_up_pm(codec);
+ 
+ 	auto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
+ 
+ 	/*
+ 	 * If headphone rear or front is plugged in, set to headphone.
+ 	 * If neither is plugged in, set to rear line out. Only if
+ 	 * hp/speaker auto detect is enabled.
+ 	 */
+ 	if (auto_jack) {
+ 		jack_present = snd_hda_jack_detect(codec, spec->unsol_tag_hp) ||
+ 			   snd_hda_jack_detect(codec, spec->unsol_tag_front_hp);
+ 
+ 		if (jack_present)
+ 			spec->cur_out_type = HEADPHONE_OUT;
+ 		else
+ 			spec->cur_out_type = SPEAKER_OUT;
+ 	} else
+ 		spec->cur_out_type = spec->out_enum_val;
+ 
+ 	/* Begin DSP output switch */
+ 	tmp = FLOAT_ONE;
+ 	err = dspio_set_uint_param(codec, 0x96, 0x3A, tmp);
+ 	if (err < 0)
+ 		goto exit;
+ 
+ 	ca0132_alt_select_out_quirk_handler(codec);
+ 
+ 	switch (spec->cur_out_type) {
+ 	case SPEAKER_OUT:
+ 		codec_dbg(codec, "%s speaker\n", __func__);
+ 
+ 		/* disable headphone node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[1],
+ 				    pin_ctl & ~PIN_HP);
+ 		/* enable line-out node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
+ 				AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
+ 				    pin_ctl | PIN_OUT);
+ 		/* Enable EAPD */
+ 		snd_hda_codec_write(codec, spec->out_pins[0], 0,
+ 			AC_VERB_SET_EAPD_BTLENABLE, 0x01);
+ 
+ 		/* If PlayEnhancement is enabled, set different source */
+ 		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
+ 		else
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_EIGHT);
+ 		break;
+ 	case HEADPHONE_OUT:
+ 		codec_dbg(codec, "%s hp\n", __func__);
+ 
+ 		snd_hda_codec_write(codec, spec->out_pins[0], 0,
+ 			AC_VERB_SET_EAPD_BTLENABLE, 0x00);
+ 
+ 		/* disable speaker*/
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
+ 				pin_ctl & ~PIN_HP);
+ 
+ 		/* enable headphone, either front or rear */
+ 
+ 		if (snd_hda_jack_detect(codec, spec->unsol_tag_front_hp))
+ 			headphone_nid = spec->out_pins[2];
+ 		else if (snd_hda_jack_detect(codec, spec->unsol_tag_hp))
+ 			headphone_nid = spec->out_pins[1];
+ 
+ 		pin_ctl = snd_hda_codec_read(codec, headphone_nid, 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, headphone_nid,
+ 				    pin_ctl | PIN_HP);
+ 
+ 		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
+ 		else
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ZERO);
+ 		break;
+ 	case SURROUND_OUT:
+ 		codec_dbg(codec, "%s surround\n", __func__);
+ 
+ 		/* enable line out node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
+ 				AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
+ 						pin_ctl | PIN_OUT);
+ 		/* Disable headphone out */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[1],
+ 				    pin_ctl & ~PIN_HP);
+ 		/* Enable EAPD on line out */
+ 		snd_hda_codec_write(codec, spec->out_pins[0], 0,
+ 			AC_VERB_SET_EAPD_BTLENABLE, 0x01);
+ 		/* enable center/lfe out node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[2], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[2],
+ 				    pin_ctl | PIN_OUT);
+ 		/* Now set rear surround node as out. */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[3], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[3],
+ 				    pin_ctl | PIN_OUT);
+ 
+ 		dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_EIGHT);
+ 		break;
+ 	}
+ 	/*
+ 	 * Surround always sets it's scp command to req 0x04 to FLOAT_EIGHT.
+ 	 * With this set though, X_BASS cannot be enabled. So, if we have OutFX
+ 	 * enabled, we need to make sure X_BASS is off, otherwise everything
+ 	 * sounds all muffled. Running ca0132_effects_set with X_BASS as the
+ 	 * effect should sort this out.
+ 	 */
+ 	if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
+ 		ca0132_effects_set(codec, X_BASS,
+ 			spec->effects_switch[X_BASS - EFFECT_START_NID]);
+ 
+ 	/* run through the output dsp commands for the selected output. */
+ 	for (i = 0; i < alt_out_presets[spec->cur_out_type].commands; i++) {
+ 		err = dspio_set_uint_param(codec,
+ 		alt_out_presets[spec->cur_out_type].mids[i],
+ 		alt_out_presets[spec->cur_out_type].reqs[i],
+ 		alt_out_presets[spec->cur_out_type].vals[i]);
+ 
+ 		if (err < 0)
+ 			goto exit;
+ 	}
+ 
+ exit:
+ 	snd_hda_power_down_pm(codec);
+ 
+ 	return err < 0 ? err : 0;
+ }
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  static void ca0132_unsol_hp_delayed(struct work_struct *work)
  {
  	struct ca0132_spec *spec = container_of(
  		to_delayed_work(work), struct ca0132_spec, unsol_hp_work);
  	struct hda_jack_tbl *jack;
  
++<<<<<<< HEAD
 +	ca0132_select_out(spec->codec);
++=======
+ 	if (ca0132_use_alt_functions(spec))
+ 		ca0132_alt_select_out(spec->codec);
+ 	else
+ 		ca0132_select_out(spec->codec);
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	jack = snd_hda_jack_tbl_get(spec->codec, spec->unsol_tag_hp);
  	if (jack) {
  		jack->block_report = 0;
@@@ -3398,13 -4527,78 +4007,81 @@@ static int ca0132_set_vipsource(struct 
  	return 1;
  }
  
- /*
-  * Select the active microphone.
-  * If autodetect is enabled, mic will be selected based on jack detection.
-  * If jack inserted, ext.mic will be selected, else built-in mic
-  * If autodetect is disabled, mic will be selected based on selection.
-  */
- static int ca0132_select_mic(struct hda_codec *codec)
++<<<<<<< HEAD
++=======
+ static int ca0132_alt_set_vipsource(struct hda_codec *codec, int val)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "%s\n", __func__);
+ 
+ 	chipio_set_stream_control(codec, 0x03, 0);
+ 	chipio_set_stream_control(codec, 0x04, 0);
+ 
+ 	/* if CrystalVoice is off, vipsource should be 0 */
+ 	if (!spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] ||
+ 	    (val == 0) || spec->in_enum_val == REAR_LINE_IN) {
+ 		codec_dbg(codec, "%s: off.", __func__);
+ 		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, 0);
+ 
+ 		tmp = FLOAT_ZERO;
+ 		dspio_set_uint_param(codec, 0x80, 0x05, tmp);
+ 
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 		if (ca0132_quirk(spec) == QUIRK_R3DI)
+ 			chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 
+ 
+ 		if (spec->in_enum_val == REAR_LINE_IN)
+ 			tmp = FLOAT_ZERO;
+ 		else {
+ 			if (ca0132_quirk(spec) == QUIRK_SBZ)
+ 				tmp = FLOAT_THREE;
+ 			else
+ 				tmp = FLOAT_ONE;
+ 		}
+ 
+ 		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 	} else {
+ 		codec_dbg(codec, "%s: on.", __func__);
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_16_000);
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_16_000);
+ 		if (ca0132_quirk(spec) == QUIRK_R3DI)
+ 			chipio_set_conn_rate(codec, 0x0F, SR_16_000);
+ 
+ 		if (spec->effects_switch[VOICE_FOCUS - EFFECT_START_NID])
+ 			tmp = FLOAT_TWO;
+ 		else
+ 			tmp = FLOAT_ONE;
+ 		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 		tmp = FLOAT_ONE;
+ 		dspio_set_uint_param(codec, 0x80, 0x05, tmp);
+ 
+ 		msleep(20);
+ 		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, val);
+ 	}
+ 
+ 	chipio_set_stream_control(codec, 0x03, 1);
+ 	chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 	return 1;
+ }
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
+ /*
+  * Select the active microphone.
+  * If autodetect is enabled, mic will be selected based on jack detection.
+  * If jack inserted, ext.mic will be selected, else built-in mic
+  * If autodetect is disabled, mic will be selected based on selection.
+  */
+ static int ca0132_select_mic(struct hda_codec *codec)
  {
  	struct ca0132_spec *spec = codec->spec;
  	int jack_present;
@@@ -3451,6 -4645,166 +4128,169 @@@
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Select the active input.
+  * Mic detection isn't used, because it's kind of pointless on the SBZ.
+  * The front mic has no jack-detection, so the only way to switch to it
+  * is to do it manually in alsamixer.
+  */
+ static int ca0132_alt_select_in(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	codec_dbg(codec, "%s\n", __func__);
+ 
+ 	snd_hda_power_up_pm(codec);
+ 
+ 	chipio_set_stream_control(codec, 0x03, 0);
+ 	chipio_set_stream_control(codec, 0x04, 0);
+ 
+ 	spec->cur_mic_type = spec->in_enum_val;
+ 
+ 	switch (spec->cur_mic_type) {
+ 	case REAR_MIC:
+ 		switch (ca0132_quirk(spec)) {
+ 		case QUIRK_SBZ:
+ 		case QUIRK_R3D:
+ 			ca0113_mmio_gpio_set(codec, 0, false);
+ 			tmp = FLOAT_THREE;
+ 			break;
+ 		case QUIRK_ZXR:
+ 			tmp = FLOAT_THREE;
+ 			break;
+ 		case QUIRK_R3DI:
+ 			r3di_gpio_mic_set(codec, R3DI_REAR_MIC);
+ 			tmp = FLOAT_ONE;
+ 			break;
+ 		case QUIRK_AE5:
+ 			ca0113_mmio_command_set(codec, 0x48, 0x28, 0x00);
+ 			tmp = FLOAT_THREE;
+ 			break;
+ 		default:
+ 			tmp = FLOAT_ONE;
+ 			break;
+ 		}
+ 
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 		if (ca0132_quirk(spec) == QUIRK_R3DI)
+ 			chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 
+ 		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 		chipio_set_stream_control(codec, 0x03, 1);
+ 		chipio_set_stream_control(codec, 0x04, 1);
+ 		switch (ca0132_quirk(spec)) {
+ 		case QUIRK_SBZ:
+ 			chipio_write(codec, 0x18B098, 0x0000000C);
+ 			chipio_write(codec, 0x18B09C, 0x0000000C);
+ 			break;
+ 		case QUIRK_ZXR:
+ 			chipio_write(codec, 0x18B098, 0x0000000C);
+ 			chipio_write(codec, 0x18B09C, 0x000000CC);
+ 			break;
+ 		case QUIRK_AE5:
+ 			chipio_write(codec, 0x18B098, 0x0000000C);
+ 			chipio_write(codec, 0x18B09C, 0x0000004C);
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		ca0132_alt_mic_boost_set(codec, spec->mic_boost_enum_val);
+ 		break;
+ 	case REAR_LINE_IN:
+ 		ca0132_mic_boost_set(codec, 0);
+ 		switch (ca0132_quirk(spec)) {
+ 		case QUIRK_SBZ:
+ 		case QUIRK_R3D:
+ 			ca0113_mmio_gpio_set(codec, 0, false);
+ 			break;
+ 		case QUIRK_R3DI:
+ 			r3di_gpio_mic_set(codec, R3DI_REAR_MIC);
+ 			break;
+ 		case QUIRK_AE5:
+ 			ca0113_mmio_command_set(codec, 0x48, 0x28, 0x00);
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 		if (ca0132_quirk(spec) == QUIRK_R3DI)
+ 			chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 
+ 		tmp = FLOAT_ZERO;
+ 		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 		switch (ca0132_quirk(spec)) {
+ 		case QUIRK_SBZ:
+ 		case QUIRK_AE5:
+ 			chipio_write(codec, 0x18B098, 0x00000000);
+ 			chipio_write(codec, 0x18B09C, 0x00000000);
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		chipio_set_stream_control(codec, 0x03, 1);
+ 		chipio_set_stream_control(codec, 0x04, 1);
+ 		break;
+ 	case FRONT_MIC:
+ 		switch (ca0132_quirk(spec)) {
+ 		case QUIRK_SBZ:
+ 		case QUIRK_R3D:
+ 			ca0113_mmio_gpio_set(codec, 0, true);
+ 			ca0113_mmio_gpio_set(codec, 5, false);
+ 			tmp = FLOAT_THREE;
+ 			break;
+ 		case QUIRK_R3DI:
+ 			r3di_gpio_mic_set(codec, R3DI_FRONT_MIC);
+ 			tmp = FLOAT_ONE;
+ 			break;
+ 		case QUIRK_AE5:
+ 			ca0113_mmio_command_set(codec, 0x48, 0x28, 0x3f);
+ 			tmp = FLOAT_THREE;
+ 			break;
+ 		default:
+ 			tmp = FLOAT_ONE;
+ 			break;
+ 		}
+ 
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 		if (ca0132_quirk(spec) == QUIRK_R3DI)
+ 			chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 
+ 		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 		chipio_set_stream_control(codec, 0x03, 1);
+ 		chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 		switch (ca0132_quirk(spec)) {
+ 		case QUIRK_SBZ:
+ 			chipio_write(codec, 0x18B098, 0x0000000C);
+ 			chipio_write(codec, 0x18B09C, 0x000000CC);
+ 			break;
+ 		case QUIRK_AE5:
+ 			chipio_write(codec, 0x18B098, 0x0000000C);
+ 			chipio_write(codec, 0x18B09C, 0x0000004C);
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		ca0132_alt_mic_boost_set(codec, spec->mic_boost_enum_val);
+ 		break;
+ 	}
+ 	ca0132_cvoice_switch_set(codec);
+ 
+ 	snd_hda_power_down_pm(codec);
+ 	return 0;
+ }
+ 
+ /*
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
   * Check if VNODE settings take effect immediately.
   */
  static bool ca0132_is_vnode_effective(struct hda_codec *codec,
@@@ -3530,6 -4886,46 +4370,49 @@@ static int ca0132_effects_set(struct hd
  		/* Voice Focus applies to 2-ch Mic, Digital Mic */
  		if ((nid == VOICE_FOCUS) && (spec->cur_mic_type != DIGITAL_MIC))
  			val = 0;
++<<<<<<< HEAD
++=======
+ 
+ 		/* If Voice Focus on SBZ, set to two channel. */
+ 		if ((nid == VOICE_FOCUS) && ca0132_use_pci_mmio(spec)
+ 				&& (spec->cur_mic_type != REAR_LINE_IN)) {
+ 			if (spec->effects_switch[CRYSTAL_VOICE -
+ 						 EFFECT_START_NID]) {
+ 
+ 				if (spec->effects_switch[VOICE_FOCUS -
+ 							 EFFECT_START_NID]) {
+ 					tmp = FLOAT_TWO;
+ 					val = 1;
+ 				} else
+ 					tmp = FLOAT_ONE;
+ 
+ 				dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 			}
+ 		}
+ 		/*
+ 		 * For SBZ noise reduction, there's an extra command
+ 		 * to module ID 0x47. No clue why.
+ 		 */
+ 		if ((nid == NOISE_REDUCTION) && ca0132_use_pci_mmio(spec)
+ 				&& (spec->cur_mic_type != REAR_LINE_IN)) {
+ 			if (spec->effects_switch[CRYSTAL_VOICE -
+ 						 EFFECT_START_NID]) {
+ 				if (spec->effects_switch[NOISE_REDUCTION -
+ 							 EFFECT_START_NID])
+ 					tmp = FLOAT_ONE;
+ 				else
+ 					tmp = FLOAT_ZERO;
+ 			} else
+ 				tmp = FLOAT_ZERO;
+ 
+ 			dspio_set_uint_param(codec, 0x47, 0x00, tmp);
+ 		}
+ 
+ 		/* If rear line in disable effects. */
+ 		if (ca0132_use_alt_functions(spec) &&
+ 				spec->in_enum_val == REAR_LINE_IN)
+ 			val = 0;
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	}
  
  	codec_dbg(codec, "ca0132_effect_set: nid=0x%x, val=%ld\n",
@@@ -3557,6 -4953,9 +4440,12 @@@ static int ca0132_pe_switch_set(struct 
  	codec_dbg(codec, "ca0132_pe_switch_set: val=%ld\n",
  		    spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID]);
  
++<<<<<<< HEAD
++=======
+ 	if (ca0132_use_alt_functions(spec))
+ 		ca0132_alt_select_out(codec);
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	i = OUT_EFFECT_START_NID - EFFECT_START_NID;
  	nid = OUT_EFFECT_START_NID;
  	/* PE affects all out effects */
@@@ -3614,7 -5013,10 +4503,14 @@@ static int ca0132_cvoice_switch_set(str
  
  	/* set correct vipsource */
  	oldval = stop_mic1(codec);
++<<<<<<< HEAD
 +	ret |= ca0132_set_vipsource(codec, 1);
++=======
+ 	if (ca0132_use_alt_functions(spec))
+ 		ret |= ca0132_alt_set_vipsource(codec, 1);
+ 	else
+ 		ret |= ca0132_set_vipsource(codec, 1);
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	resume_mic1(codec, oldval);
  	return ret;
  }
@@@ -3648,8 -5081,12 +4544,17 @@@ static int ca0132_vnode_switch_set(stru
  	if (nid == VNID_HP_SEL) {
  		auto_jack =
  			spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
++<<<<<<< HEAD
 +		if (!auto_jack)
 +			ca0132_select_out(codec);
++=======
+ 		if (!auto_jack) {
+ 			if (ca0132_use_alt_functions(spec))
+ 				ca0132_alt_select_out(codec);
+ 			else
+ 				ca0132_select_out(codec);
+ 		}
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  		return 1;
  	}
  
@@@ -3662,7 -5099,10 +4567,14 @@@
  	}
  
  	if (nid == VNID_HP_ASEL) {
++<<<<<<< HEAD
 +		ca0132_select_out(codec);
++=======
+ 		if (ca0132_use_alt_functions(spec))
+ 			ca0132_alt_select_out(codec);
+ 		else
+ 			ca0132_select_out(codec);
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  		return 1;
  	}
  
@@@ -3841,10 -5813,25 +4753,31 @@@ static int ca0132_switch_put(struct snd
  	/* mic boost */
  	if (nid == spec->input_pins[0]) {
  		spec->cur_mic_boost = *valp;
++<<<<<<< HEAD
++=======
+ 		if (ca0132_use_alt_functions(spec)) {
+ 			if (spec->in_enum_val != REAR_LINE_IN)
+ 				changed = ca0132_mic_boost_set(codec, *valp);
+ 		} else {
+ 			/* Mic boost does not apply to Digital Mic */
+ 			if (spec->cur_mic_type != DIGITAL_MIC)
+ 				changed = ca0132_mic_boost_set(codec, *valp);
+ 		}
+ 
+ 		goto exit;
+ 	}
+ 
+ 	if (nid == ZXR_HEADPHONE_GAIN) {
+ 		spec->zxr_gain_set = *valp;
+ 		if (spec->cur_out_type == HEADPHONE_OUT)
+ 			changed = zxr_headphone_gain_set(codec, *valp);
+ 		else
+ 			changed = 0;
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  
 +		/* Mic boost does not apply to Digital Mic */
 +		if (spec->cur_mic_type != DIGITAL_MIC)
 +			changed = ca0132_mic_boost_set(codec, *valp);
  		goto exit;
  	}
  
@@@ -4002,7 -6106,14 +4935,18 @@@ static int add_fx_switch(struct hda_cod
  	int type = dir ? HDA_INPUT : HDA_OUTPUT;
  	struct snd_kcontrol_new knew =
  		CA0132_CODEC_MUTE_MONO(namestr, nid, 1, type);
++<<<<<<< HEAD
 +	sprintf(namestr, "%s %s Switch", pfx, dirstr[dir]);
++=======
+ 	/* If using alt_controls, add FX: prefix. But, don't add FX:
+ 	 * prefix to OutFX or InFX enable controls.
+ 	 */
+ 	if (ca0132_use_alt_controls(spec) && (nid <= IN_EFFECT_END_NID))
+ 		sprintf(namestr, "FX: %s %s Switch", pfx, dirstr[dir]);
+ 	else
+ 		sprintf(namestr, "%s %s Switch", pfx, dirstr[dir]);
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	return snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));
  }
  
@@@ -4055,29 -6385,130 +4999,108 @@@ static int ca0132_build_controls(struc
  		if (err < 0)
  			return err;
  	}
++<<<<<<< HEAD
++=======
+ 	/* Setup vmaster with surround slaves for desktop ca0132 devices */
+ 	if (ca0132_use_alt_functions(spec)) {
+ 		snd_hda_set_vmaster_tlv(codec, spec->dacs[0], HDA_OUTPUT,
+ 					spec->tlv);
+ 		snd_hda_add_vmaster(codec, "Master Playback Volume",
+ 					spec->tlv, ca0132_alt_slave_pfxs,
+ 					"Playback Volume");
+ 		err = __snd_hda_add_vmaster(codec, "Master Playback Switch",
+ 					    NULL, ca0132_alt_slave_pfxs,
+ 					    "Playback Switch",
+ 					    true, &spec->vmaster_mute.sw_kctl);
+ 		if (err < 0)
+ 			return err;
+ 	}
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  
  	/* Add in and out effects controls.
  	 * VoiceFX, PE and CrystalVoice are added separately.
  	 */
  	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT;
  	for (i = 0; i < num_fx; i++) {
++<<<<<<< HEAD
++=======
+ 		/* Desktop cards break if Echo Cancellation is used. */
+ 		if (ca0132_use_pci_mmio(spec)) {
+ 			if (i == (ECHO_CANCELLATION - IN_EFFECT_START_NID +
+ 						OUT_EFFECTS_COUNT))
+ 				continue;
+ 		}
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  		err = add_fx_switch(codec, ca0132_effects[i].nid,
  				    ca0132_effects[i].name,
  				    ca0132_effects[i].direct);
  		if (err < 0)
  			return err;
  	}
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * If codec has use_alt_controls set to true, add effect level sliders,
+ 	 * EQ presets, and Smart Volume presets. Also, change names to add FX
+ 	 * prefix, and change PlayEnhancement and CrystalVoice to match.
+ 	 */
+ 	if (ca0132_use_alt_controls(spec)) {
+ 		err = ca0132_alt_add_svm_enum(codec);
+ 		if (err < 0)
+ 			return err;
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  
 -		err = add_ca0132_alt_eq_presets(codec);
 -		if (err < 0)
 -			return err;
 -
 -		err = add_fx_switch(codec, PLAY_ENHANCEMENT,
 -					"Enable OutFX", 0);
 -		if (err < 0)
 -			return err;
 -
 -		err = add_fx_switch(codec, CRYSTAL_VOICE,
 -					"Enable InFX", 1);
 -		if (err < 0)
 -			return err;
 -
 -		num_sliders = OUT_EFFECTS_COUNT - 1;
 -		for (i = 0; i < num_sliders; i++) {
 -			err = ca0132_alt_add_effect_slider(codec,
 -					    ca0132_effects[i].nid,
 -					    ca0132_effects[i].name,
 -					    ca0132_effects[i].direct);
 -			if (err < 0)
 -				return err;
 -		}
 -
 -		err = ca0132_alt_add_effect_slider(codec, XBASS_XOVER,
 -					"X-Bass Crossover", EFX_DIR_OUT);
 -
 -		if (err < 0)
 -			return err;
 -	} else {
 -		err = add_fx_switch(codec, PLAY_ENHANCEMENT,
 -					"PlayEnhancement", 0);
 -		if (err < 0)
 -			return err;
 +	err = add_fx_switch(codec, PLAY_ENHANCEMENT, "PlayEnhancement", 0);
 +	if (err < 0)
 +		return err;
  
 -		err = add_fx_switch(codec, CRYSTAL_VOICE,
 -					"CrystalVoice", 1);
 -		if (err < 0)
 -			return err;
 -	}
 -	err = add_voicefx(codec);
++<<<<<<< HEAD
 +	err = add_fx_switch(codec, CRYSTAL_VOICE, "CrystalVoice", 1);
  	if (err < 0)
  		return err;
  
 +	add_voicefx(codec);
 +
++=======
+ 	/*
+ 	 * If the codec uses alt_functions, you need the enumerated controls
+ 	 * to select the new outputs and inputs, plus add the new mic boost
+ 	 * setting control.
+ 	 */
+ 	if (ca0132_use_alt_functions(spec)) {
+ 		err = ca0132_alt_add_output_enum(codec);
+ 		if (err < 0)
+ 			return err;
+ 		err = ca0132_alt_add_mic_boost_enum(codec);
+ 		if (err < 0)
+ 			return err;
+ 		/*
+ 		 * ZxR only has microphone input, there is no front panel
+ 		 * header on the card, and aux-in is handled by the DBPro board.
+ 		 */
+ 		if (ca0132_quirk(spec) != QUIRK_ZXR) {
+ 			err = ca0132_alt_add_input_enum(codec);
+ 			if (err < 0)
+ 				return err;
+ 		}
+ 	}
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_AE5) {
+ 		err = ae5_add_headphone_gain_enum(codec);
+ 		if (err < 0)
+ 			return err;
+ 		err = ae5_add_sound_filter_enum(codec);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_ZXR) {
+ 		err = zxr_add_headphone_gain_switch(codec);
+ 		if (err < 0)
+ 			return err;
+ 	}
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  #ifdef ENABLE_TUNING_CONTROLS
  	add_tuning_ctls(codec);
  #endif
@@@ -4102,6 -6533,31 +5125,34 @@@
  		if (err < 0)
  			return err;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (ca0132_use_alt_functions(spec))
+ 		ca0132_alt_add_chmap_ctls(codec);
+ 
+ 	return 0;
+ }
+ 
+ static int dbpro_build_controls(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int err = 0;
+ 
+ 	if (spec->dig_out) {
+ 		err = snd_hda_create_spdif_out_ctls(codec, spec->dig_out,
+ 				spec->dig_out);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	if (spec->dig_in) {
+ 		err = snd_hda_create_spdif_in_ctls(codec, spec->dig_in);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	return 0;
  }
  
@@@ -4156,6 -6612,11 +5207,14 @@@ static int ca0132_build_pcms(struct hda
  	info = snd_hda_codec_pcm_new(codec, "CA0132 Analog");
  	if (!info)
  		return -ENOMEM;
++<<<<<<< HEAD
++=======
+ 	if (ca0132_use_alt_functions(spec)) {
+ 		info->own_chmap = true;
+ 		info->stream[SNDRV_PCM_STREAM_PLAYBACK].chmap
+ 			= ca0132_alt_chmaps;
+ 	}
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	info->stream[SNDRV_PCM_STREAM_PLAYBACK] = ca0132_pcm_analog_playback;
  	info->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dacs[0];
  	info->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =
@@@ -4164,12 -6625,16 +5223,25 @@@
  	info->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;
  	info->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[0];
  
++<<<<<<< HEAD
 +	info = snd_hda_codec_pcm_new(codec, "CA0132 Analog Mic-In2");
 +	if (!info)
 +		return -ENOMEM;
 +	info->stream[SNDRV_PCM_STREAM_CAPTURE] = ca0132_pcm_analog_capture;
 +	info->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;
 +	info->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[1];
++=======
+ 	/* With the DSP enabled, desktops don't use this ADC. */
+ 	if (!ca0132_use_alt_functions(spec)) {
+ 		info = snd_hda_codec_pcm_new(codec, "CA0132 Analog Mic-In2");
+ 		if (!info)
+ 			return -ENOMEM;
+ 		info->stream[SNDRV_PCM_STREAM_CAPTURE] =
+ 			ca0132_pcm_analog_capture;
+ 		info->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;
+ 		info->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[1];
+ 	}
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  
  	info = snd_hda_codec_pcm_new(codec, "CA0132 What U Hear");
  	if (!info)
@@@ -4325,7 -6824,10 +5397,14 @@@ static void ca0132_init_dmic(struct hda
  	 * Bit   6: set to select Data2, clear for Data1
  	 * Bit   7: set to enable DMic, clear for AMic
  	 */
++<<<<<<< HEAD
 +	val = 0x23;
++=======
+ 	if (ca0132_quirk(spec) == QUIRK_ALIENWARE_M17XR4)
+ 		val = 0x33;
+ 	else
+ 		val = 0x23;
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	/* keep a copy of dmic ctl val for enable/disable dmic purpuse */
  	spec->dmic_ctl = val;
  	snd_hda_codec_write(codec, spec->input_pins[0], 0,
@@@ -4376,60 -6878,605 +5455,620 @@@ static void ca0132_refresh_widget_caps(
  }
  
  /*
-  * Setup default parameters for DSP
++<<<<<<< HEAD
++=======
+  * Creates a dummy stream to bind the output to. This seems to have to be done
+  * after changing the main outputs source and destination streams.
   */
- static void ca0132_setup_defaults(struct hda_codec *codec)
+ static void ca0132_alt_create_dummy_stream(struct hda_codec *codec)
  {
  	struct ca0132_spec *spec = codec->spec;
- 	unsigned int tmp;
- 	int num_fx;
- 	int idx, i;
+ 	unsigned int stream_format;
  
- 	if (spec->dsp_state != DSP_DOWNLOADED)
- 		return;
+ 	stream_format = snd_hdac_calc_stream_format(48000, 2,
+ 			SNDRV_PCM_FORMAT_S32_LE, 32, 0);
  
- 	/* out, in effects + voicefx */
- 	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;
- 	for (idx = 0; idx < num_fx; idx++) {
- 		for (i = 0; i <= ca0132_effects[idx].params; i++) {
- 			dspio_set_uint_param(codec, ca0132_effects[idx].mid,
- 					     ca0132_effects[idx].reqs[i],
- 					     ca0132_effects[idx].def_vals[i]);
- 		}
- 	}
+ 	snd_hda_codec_setup_stream(codec, spec->dacs[0], spec->dsp_stream_id,
+ 					0, stream_format);
  
- 	/*remove DSP headroom*/
- 	tmp = FLOAT_ZERO;
- 	dspio_set_uint_param(codec, 0x96, 0x3C, tmp);
+ 	snd_hda_codec_cleanup_stream(codec, spec->dacs[0]);
+ }
  
- 	/*set speaker EQ bypass attenuation*/
- 	dspio_set_uint_param(codec, 0x8f, 0x01, tmp);
+ /*
+  * Initialize mic for non-chromebook ca0132 implementations.
+  */
+ static void ca0132_alt_init_analog_mics(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
  
- 	/* set AMic1 and AMic2 as mono mic */
- 	tmp = FLOAT_ONE;
+ 	/* Mic 1 Setup */
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 	if (ca0132_quirk(spec) == QUIRK_R3DI) {
+ 		chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 		tmp = FLOAT_ONE;
+ 	} else
+ 		tmp = FLOAT_THREE;
  	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 	/* Mic 2 setup (not present on desktop cards) */
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN2, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT2, SR_96_000);
+ 	if (ca0132_quirk(spec) == QUIRK_R3DI)
+ 		chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 	tmp = FLOAT_ZERO;
  	dspio_set_uint_param(codec, 0x80, 0x01, tmp);
+ }
  
- 	/* set AMic1 as CrystalVoice input */
- 	tmp = FLOAT_ONE;
- 	dspio_set_uint_param(codec, 0x80, 0x05, tmp);
+ /*
+  * Sets the source of stream 0x14 to connpointID 0x48, and the destination
+  * connpointID to 0x91. If this isn't done, the destination is 0x71, and
+  * you get no sound. I'm guessing this has to do with the Sound Blaster Z
+  * having an updated DAC, which changes the destination to that DAC.
+  */
+ static void sbz_connect_streams(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
  
- 	/* set WUH source */
- 	tmp = FLOAT_TWO;
- 	dspio_set_uint_param(codec, 0x31, 0x00, tmp);
+ 	mutex_lock(&spec->chipio_mutex);
+ 
+ 	codec_dbg(codec, "Connect Streams entered, mutex locked and loaded.\n");
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 
+ 	/* This value is 0x43 for 96khz, and 0x83 for 192khz. */
+ 	chipio_write_no_mutex(codec, 0x18a020, 0x00000043);
+ 
+ 	/* Setup stream 0x14 with it's source and destination points */
+ 	chipio_set_stream_source_dest(codec, 0x14, 0x48, 0x91);
+ 	chipio_set_conn_rate_no_mutex(codec, 0x48, SR_96_000);
+ 	chipio_set_conn_rate_no_mutex(codec, 0x91, SR_96_000);
+ 	chipio_set_stream_channels(codec, 0x14, 2);
+ 	chipio_set_stream_control(codec, 0x14, 1);
+ 
+ 	codec_dbg(codec, "Connect Streams exited, mutex released.\n");
+ 
+ 	mutex_unlock(&spec->chipio_mutex);
  }
  
  /*
-  * Initialization of flags in chip
+  * Write data through ChipIO to setup proper stream destinations.
+  * Not sure how it exactly works, but it seems to direct data
+  * to different destinations. Example is f8 to c0, e0 to c0.
+  * All I know is, if you don't set these, you get no sound.
   */
- static void ca0132_init_flags(struct hda_codec *codec)
+ static void sbz_chipio_startup_data(struct hda_codec *codec)
  {
- 	chipio_set_control_flag(codec, CONTROL_FLAG_IDLE_ENABLE, 0);
- 	chipio_set_control_flag(codec, CONTROL_FLAG_PORT_A_COMMON_MODE, 0);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 	codec_dbg(codec, "Startup Data entered, mutex locked and loaded.\n");
+ 
+ 	/* These control audio output */
+ 	chipio_write_no_mutex(codec, 0x190060, 0x0001f8c0);
+ 	chipio_write_no_mutex(codec, 0x190064, 0x0001f9c1);
+ 	chipio_write_no_mutex(codec, 0x190068, 0x0001fac6);
+ 	chipio_write_no_mutex(codec, 0x19006c, 0x0001fbc7);
+ 	/* Signal to update I think */
+ 	chipio_write_no_mutex(codec, 0x19042c, 0x00000001);
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 	/* No clue what these control */
+ 	if (ca0132_quirk(spec) == QUIRK_SBZ) {
+ 		chipio_write_no_mutex(codec, 0x190030, 0x0001e0c0);
+ 		chipio_write_no_mutex(codec, 0x190034, 0x0001e1c1);
+ 		chipio_write_no_mutex(codec, 0x190038, 0x0001e4c2);
+ 		chipio_write_no_mutex(codec, 0x19003c, 0x0001e5c3);
+ 		chipio_write_no_mutex(codec, 0x190040, 0x0001e2c4);
+ 		chipio_write_no_mutex(codec, 0x190044, 0x0001e3c5);
+ 		chipio_write_no_mutex(codec, 0x190048, 0x0001e8c6);
+ 		chipio_write_no_mutex(codec, 0x19004c, 0x0001e9c7);
+ 		chipio_write_no_mutex(codec, 0x190050, 0x0001ecc8);
+ 		chipio_write_no_mutex(codec, 0x190054, 0x0001edc9);
+ 		chipio_write_no_mutex(codec, 0x190058, 0x0001eaca);
+ 		chipio_write_no_mutex(codec, 0x19005c, 0x0001ebcb);
+ 	} else if (ca0132_quirk(spec) == QUIRK_ZXR) {
+ 		chipio_write_no_mutex(codec, 0x190038, 0x000140c2);
+ 		chipio_write_no_mutex(codec, 0x19003c, 0x000141c3);
+ 		chipio_write_no_mutex(codec, 0x190040, 0x000150c4);
+ 		chipio_write_no_mutex(codec, 0x190044, 0x000151c5);
+ 		chipio_write_no_mutex(codec, 0x190050, 0x000142c8);
+ 		chipio_write_no_mutex(codec, 0x190054, 0x000143c9);
+ 		chipio_write_no_mutex(codec, 0x190058, 0x000152ca);
+ 		chipio_write_no_mutex(codec, 0x19005c, 0x000153cb);
+ 	}
+ 	chipio_write_no_mutex(codec, 0x19042c, 0x00000001);
+ 
+ 	codec_dbg(codec, "Startup Data exited, mutex released.\n");
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ /*
+  * Custom DSP SCP commands where the src value is 0x00 instead of 0x20. This is
+  * done after the DSP is loaded.
+  */
+ static void ca0132_alt_dsp_scp_startup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp, i;
+ 
+ 	/*
+ 	 * Gotta run these twice, or else mic works inconsistently. Not clear
+ 	 * why this is, but multiple tests have confirmed it.
+ 	 */
+ 	for (i = 0; i < 2; i++) {
+ 		switch (ca0132_quirk(spec)) {
+ 		case QUIRK_SBZ:
+ 		case QUIRK_AE5:
+ 			tmp = 0x00000003;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			tmp = 0x00000000;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0A, tmp);
+ 			tmp = 0x00000001;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0B, tmp);
+ 			tmp = 0x00000004;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			tmp = 0x00000005;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			tmp = 0x00000000;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			break;
+ 		case QUIRK_R3D:
+ 		case QUIRK_R3DI:
+ 			tmp = 0x00000000;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0A, tmp);
+ 			tmp = 0x00000001;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0B, tmp);
+ 			tmp = 0x00000004;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			tmp = 0x00000005;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			tmp = 0x00000000;
+ 			dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		msleep(100);
+ 	}
+ }
+ 
+ static void ca0132_alt_dsp_initial_mic_setup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	chipio_set_stream_control(codec, 0x03, 0);
+ 	chipio_set_stream_control(codec, 0x04, 0);
+ 
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 
+ 	tmp = FLOAT_THREE;
+ 	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 	chipio_set_stream_control(codec, 0x03, 1);
+ 	chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 	switch (ca0132_quirk(spec)) {
+ 	case QUIRK_SBZ:
+ 		chipio_write(codec, 0x18b098, 0x0000000c);
+ 		chipio_write(codec, 0x18b09C, 0x0000000c);
+ 		break;
+ 	case QUIRK_AE5:
+ 		chipio_write(codec, 0x18b098, 0x0000000c);
+ 		chipio_write(codec, 0x18b09c, 0x0000004c);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void ae5_post_dsp_register_set(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	chipio_8051_write_direct(codec, 0x93, 0x10);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x44);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc2);
+ 
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 
+ 	ca0113_mmio_command_set(codec, 0x30, 0x2b, 0x3f);
+ 	ca0113_mmio_command_set(codec, 0x30, 0x2d, 0x3f);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);
+ }
+ 
+ static void ae5_post_dsp_param_setup(struct hda_codec *codec)
+ {
+ 	/*
+ 	 * Param3 in the 8051's memory is represented by the ascii string 'mch'
+ 	 * which seems to be 'multichannel'. This is also mentioned in the
+ 	 * AE-5's registry values in Windows.
+ 	 */
+ 	chipio_set_control_param(codec, 3, 0);
+ 	/*
+ 	 * I believe ASI is 'audio serial interface' and that it's used to
+ 	 * change colors on the external LED strip connected to the AE-5.
+ 	 */
+ 	chipio_set_control_flag(codec, CONTROL_FLAG_ASI_96KHZ, 1);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x724, 0x83);
+ 	chipio_set_control_param(codec, CONTROL_PARAM_ASI, 0);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x92);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_HIGH, 0xfa);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_DATA_WRITE, 0x22);
+ }
+ 
+ static void ae5_post_dsp_pll_setup(struct hda_codec *codec)
+ {
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x41);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc8);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x45);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xcc);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x40);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xcb);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x43);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc7);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x51);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0x8d);
+ }
+ 
+ static void ae5_post_dsp_stream_setup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x725, 0x81);
+ 
+ 	chipio_set_conn_rate_no_mutex(codec, 0x70, SR_96_000);
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 
+ 	chipio_set_stream_source_dest(codec, 0x5, 0x43, 0x0);
+ 
+ 	chipio_set_stream_source_dest(codec, 0x18, 0x9, 0xd0);
+ 	chipio_set_conn_rate_no_mutex(codec, 0xd0, SR_96_000);
+ 	chipio_set_stream_channels(codec, 0x18, 6);
+ 	chipio_set_stream_control(codec, 0x18, 1);
+ 
+ 	chipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 4);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x43);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc7);
+ 
+ 	ca0113_mmio_command_set(codec, 0x48, 0x01, 0x80);
+ 
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ static void ae5_post_dsp_startup_data(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 
+ 	chipio_write_no_mutex(codec, 0x189000, 0x0001f101);
+ 	chipio_write_no_mutex(codec, 0x189004, 0x0001f101);
+ 	chipio_write_no_mutex(codec, 0x189024, 0x00014004);
+ 	chipio_write_no_mutex(codec, 0x189028, 0x0002000f);
+ 
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0a, 0x05);
+ 	chipio_set_control_param_no_mutex(codec, CONTROL_PARAM_ASI, 7);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0b, 0x12);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x04, 0x00);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x06, 0x48);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0a, 0x05);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0f, 0x00);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x10, 0x00);
+ 	ca0113_mmio_gpio_set(codec, 0, true);
+ 	ca0113_mmio_gpio_set(codec, 1, true);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x80);
+ 
+ 	chipio_write_no_mutex(codec, 0x18b03c, 0x00000012);
+ 
+ 	ca0113_mmio_command_set(codec, 0x48, 0x0f, 0x00);
+ 	ca0113_mmio_command_set(codec, 0x48, 0x10, 0x00);
+ 
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ /*
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
+  * Setup default parameters for DSP
+  */
+ static void ca0132_setup_defaults(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 	int num_fx;
+ 	int idx, i;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return;
+ 
+ 	/* out, in effects + voicefx */
+ 	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;
+ 	for (idx = 0; idx < num_fx; idx++) {
+ 		for (i = 0; i <= ca0132_effects[idx].params; i++) {
+ 			dspio_set_uint_param(codec, ca0132_effects[idx].mid,
+ 					     ca0132_effects[idx].reqs[i],
+ 					     ca0132_effects[idx].def_vals[i]);
+ 		}
+ 	}
+ 
+ 	/*remove DSP headroom*/
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x3C, tmp);
+ 
+ 	/*set speaker EQ bypass attenuation*/
+ 	dspio_set_uint_param(codec, 0x8f, 0x01, tmp);
+ 
+ 	/* set AMic1 and AMic2 as mono mic */
+ 	tmp = FLOAT_ONE;
+ 	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 	dspio_set_uint_param(codec, 0x80, 0x01, tmp);
+ 
+ 	/* set AMic1 as CrystalVoice input */
+ 	tmp = FLOAT_ONE;
+ 	dspio_set_uint_param(codec, 0x80, 0x05, tmp);
+ 
+ 	/* set WUH source */
+ 	tmp = FLOAT_TWO;
+ 	dspio_set_uint_param(codec, 0x31, 0x00, tmp);
+ }
+ 
+ /*
++<<<<<<< HEAD
++=======
+  * Setup default parameters for Recon3D/Recon3Di DSP.
+  */
+ 
+ static void r3d_setup_defaults(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 	int num_fx;
+ 	int idx, i;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return;
+ 
+ 	ca0132_alt_dsp_scp_startup(codec);
+ 	ca0132_alt_init_analog_mics(codec);
+ 
+ 	/*remove DSP headroom*/
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x3C, tmp);
+ 
+ 	/* set WUH source */
+ 	tmp = FLOAT_TWO;
+ 	dspio_set_uint_param(codec, 0x31, 0x00, tmp);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);
+ 
+ 	/* Set speaker source? */
+ 	dspio_set_uint_param(codec, 0x32, 0x00, tmp);
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_R3DI)
+ 		r3di_gpio_dsp_status_set(codec, R3DI_DSP_DOWNLOADED);
+ 
+ 	/* Setup effect defaults */
+ 	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;
+ 	for (idx = 0; idx < num_fx; idx++) {
+ 		for (i = 0; i <= ca0132_effects[idx].params; i++) {
+ 			dspio_set_uint_param(codec,
+ 					ca0132_effects[idx].mid,
+ 					ca0132_effects[idx].reqs[i],
+ 					ca0132_effects[idx].def_vals[i]);
+ 		}
+ 	}
+ }
+ 
+ /*
+  * Setup default parameters for the Sound Blaster Z DSP. A lot more going on
+  * than the Chromebook setup.
+  */
+ static void sbz_setup_defaults(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 	int num_fx;
+ 	int idx, i;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return;
+ 
+ 	ca0132_alt_dsp_scp_startup(codec);
+ 	ca0132_alt_init_analog_mics(codec);
+ 	sbz_connect_streams(codec);
+ 	sbz_chipio_startup_data(codec);
+ 
+ 	chipio_set_stream_control(codec, 0x03, 1);
+ 	chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 	/*
+ 	 * Sets internal input loopback to off, used to have a switch to
+ 	 * enable input loopback, but turned out to be way too buggy.
+ 	 */
+ 	tmp = FLOAT_ONE;
+ 	dspio_set_uint_param(codec, 0x37, 0x08, tmp);
+ 	dspio_set_uint_param(codec, 0x37, 0x10, tmp);
+ 
+ 	/*remove DSP headroom*/
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x3C, tmp);
+ 
+ 	/* set WUH source */
+ 	tmp = FLOAT_TWO;
+ 	dspio_set_uint_param(codec, 0x31, 0x00, tmp);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);
+ 
+ 	/* Set speaker source? */
+ 	dspio_set_uint_param(codec, 0x32, 0x00, tmp);
+ 
+ 	ca0132_alt_dsp_initial_mic_setup(codec);
+ 
+ 	/* out, in effects + voicefx */
+ 	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;
+ 	for (idx = 0; idx < num_fx; idx++) {
+ 		for (i = 0; i <= ca0132_effects[idx].params; i++) {
+ 			dspio_set_uint_param(codec,
+ 					ca0132_effects[idx].mid,
+ 					ca0132_effects[idx].reqs[i],
+ 					ca0132_effects[idx].def_vals[i]);
+ 		}
+ 	}
+ 
+ 	ca0132_alt_create_dummy_stream(codec);
+ }
+ 
+ /*
+  * Setup default parameters for the Sound BlasterX AE-5 DSP.
+  */
+ static void ae5_setup_defaults(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 	int num_fx;
+ 	int idx, i;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return;
+ 
+ 	ca0132_alt_dsp_scp_startup(codec);
+ 	ca0132_alt_init_analog_mics(codec);
+ 	chipio_set_stream_control(codec, 0x03, 1);
+ 	chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 	/* New, unknown SCP req's */
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x29, tmp);
+ 	dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
+ 	dspio_set_uint_param(codec, 0x80, 0x0d, tmp);
+ 	dspio_set_uint_param(codec, 0x80, 0x0e, tmp);
+ 
+ 	ca0113_mmio_command_set(codec, 0x30, 0x2e, 0x3f);
+ 	ca0113_mmio_gpio_set(codec, 0, false);
+ 	ca0113_mmio_command_set(codec, 0x30, 0x28, 0x00);
+ 
+ 	/* Internal loopback off */
+ 	tmp = FLOAT_ONE;
+ 	dspio_set_uint_param(codec, 0x37, 0x08, tmp);
+ 	dspio_set_uint_param(codec, 0x37, 0x10, tmp);
+ 
+ 	/*remove DSP headroom*/
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x3C, tmp);
+ 
+ 	/* set WUH source */
+ 	tmp = FLOAT_TWO;
+ 	dspio_set_uint_param(codec, 0x31, 0x00, tmp);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);
+ 
+ 	/* Set speaker source? */
+ 	dspio_set_uint_param(codec, 0x32, 0x00, tmp);
+ 
+ 	ca0132_alt_dsp_initial_mic_setup(codec);
+ 	ae5_post_dsp_register_set(codec);
+ 	ae5_post_dsp_param_setup(codec);
+ 	ae5_post_dsp_pll_setup(codec);
+ 	ae5_post_dsp_stream_setup(codec);
+ 	ae5_post_dsp_startup_data(codec);
+ 
+ 	/* out, in effects + voicefx */
+ 	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;
+ 	for (idx = 0; idx < num_fx; idx++) {
+ 		for (i = 0; i <= ca0132_effects[idx].params; i++) {
+ 			dspio_set_uint_param(codec,
+ 					ca0132_effects[idx].mid,
+ 					ca0132_effects[idx].reqs[i],
+ 					ca0132_effects[idx].def_vals[i]);
+ 		}
+ 	}
+ 
+ 	ca0132_alt_create_dummy_stream(codec);
+ }
+ 
+ /*
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
+  * Initialization of flags in chip
+  */
+ static void ca0132_init_flags(struct hda_codec *codec)
+ {
++<<<<<<< HEAD
++	chipio_set_control_flag(codec, CONTROL_FLAG_IDLE_ENABLE, 0);
++	chipio_set_control_flag(codec, CONTROL_FLAG_PORT_A_COMMON_MODE, 0);
 +	chipio_set_control_flag(codec, CONTROL_FLAG_PORT_D_COMMON_MODE, 0);
 +	chipio_set_control_flag(codec, CONTROL_FLAG_PORT_A_10KOHM_LOAD, 0);
 +	chipio_set_control_flag(codec, CONTROL_FLAG_PORT_D_10KOHM_LOAD, 0);
 +	chipio_set_control_flag(codec, CONTROL_FLAG_ADC_C_HIGH_PASS, 1);
++=======
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	if (ca0132_use_alt_functions(spec)) {
+ 		chipio_set_control_flag(codec, CONTROL_FLAG_DSP_96KHZ, 1);
+ 		chipio_set_control_flag(codec, CONTROL_FLAG_DAC_96KHZ, 1);
+ 		chipio_set_control_flag(codec, CONTROL_FLAG_ADC_B_96KHZ, 1);
+ 		chipio_set_control_flag(codec, CONTROL_FLAG_ADC_C_96KHZ, 1);
+ 		chipio_set_control_flag(codec, CONTROL_FLAG_SRC_RATE_96KHZ, 1);
+ 		chipio_set_control_flag(codec, CONTROL_FLAG_IDLE_ENABLE, 0);
+ 		chipio_set_control_flag(codec, CONTROL_FLAG_SPDIF2OUT, 0);
+ 		chipio_set_control_flag(codec,
+ 				CONTROL_FLAG_PORT_D_10KOHM_LOAD, 0);
+ 		chipio_set_control_flag(codec,
+ 				CONTROL_FLAG_PORT_A_10KOHM_LOAD, 1);
+ 	} else {
+ 		chipio_set_control_flag(codec, CONTROL_FLAG_IDLE_ENABLE, 0);
+ 		chipio_set_control_flag(codec,
+ 				CONTROL_FLAG_PORT_A_COMMON_MODE, 0);
+ 		chipio_set_control_flag(codec,
+ 				CONTROL_FLAG_PORT_D_COMMON_MODE, 0);
+ 		chipio_set_control_flag(codec,
+ 				CONTROL_FLAG_PORT_A_10KOHM_LOAD, 0);
+ 		chipio_set_control_flag(codec,
+ 				CONTROL_FLAG_PORT_D_10KOHM_LOAD, 0);
+ 		chipio_set_control_flag(codec, CONTROL_FLAG_ADC_C_HIGH_PASS, 1);
+ 	}
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  }
  
  /*
@@@ -4437,6 -7484,16 +6076,19 @@@
   */
  static void ca0132_init_params(struct hda_codec *codec)
  {
++<<<<<<< HEAD
++=======
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	if (ca0132_use_alt_functions(spec)) {
+ 		chipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);
+ 		chipio_set_conn_rate(codec, 0x0B, SR_48_000);
+ 		chipio_set_control_param(codec, CONTROL_PARAM_SPDIF1_SOURCE, 0);
+ 		chipio_set_control_param(codec, 0, 0);
+ 		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, 0);
+ 	}
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	chipio_set_control_param(codec, CONTROL_PARAM_PORTA_160OHM_GAIN, 6);
  	chipio_set_control_param(codec, CONTROL_PARAM_PORTD_160OHM_GAIN, 6);
  }
@@@ -4458,11 -7515,51 +6110,56 @@@ static void ca0132_set_dsp_msr(struct h
  static bool ca0132_download_dsp_images(struct hda_codec *codec)
  {
  	bool dsp_loaded = false;
 -	struct ca0132_spec *spec = codec->spec;
  	const struct dsp_image_seg *dsp_os_image;
  	const struct firmware *fw_entry;
++<<<<<<< HEAD
 +
 +	if (request_firmware(&fw_entry, EFX_FILE, codec->card->dev) != 0)
 +		return false;
++=======
+ 	/*
+ 	 * Alternate firmwares for different variants. The Recon3Di apparently
+ 	 * can use the default firmware, but I'll leave the option in case
+ 	 * it needs it again.
+ 	 */
+ 	switch (ca0132_quirk(spec)) {
+ 	case QUIRK_SBZ:
+ 	case QUIRK_R3D:
+ 	case QUIRK_AE5:
+ 		if (request_firmware(&fw_entry, DESKTOP_EFX_FILE,
+ 					codec->card->dev) != 0) {
+ 			codec_dbg(codec, "Desktop firmware not found.");
+ 			spec->alt_firmware_present = false;
+ 		} else {
+ 			codec_dbg(codec, "Desktop firmware selected.");
+ 			spec->alt_firmware_present = true;
+ 		}
+ 		break;
+ 	case QUIRK_R3DI:
+ 		if (request_firmware(&fw_entry, R3DI_EFX_FILE,
+ 					codec->card->dev) != 0) {
+ 			codec_dbg(codec, "Recon3Di alt firmware not detected.");
+ 			spec->alt_firmware_present = false;
+ 		} else {
+ 			codec_dbg(codec, "Recon3Di firmware selected.");
+ 			spec->alt_firmware_present = true;
+ 		}
+ 		break;
+ 	default:
+ 		spec->alt_firmware_present = false;
+ 		break;
+ 	}
+ 	/*
+ 	 * Use default ctefx.bin if no alt firmware is detected, or if none
+ 	 * exists for your particular codec.
+ 	 */
+ 	if (!spec->alt_firmware_present) {
+ 		codec_dbg(codec, "Default firmware selected.");
+ 		if (request_firmware(&fw_entry, EFX_FILE,
+ 					codec->card->dev) != 0)
+ 			return false;
+ 	}
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  
  	dsp_os_image = (struct dsp_image_seg *)(fw_entry->data);
  	if (dspload_image(codec, dsp_os_image, 0, 0, true, 0)) {
@@@ -4490,13 -7587,17 +6187,24 @@@ static void ca0132_download_dsp(struct 
  		return; /* don't retry failures */
  
  	chipio_enable_clocks(codec);
 -	if (spec->dsp_state != DSP_DOWNLOADED) {
 -		spec->dsp_state = DSP_DOWNLOADING;
 +	spec->dsp_state = DSP_DOWNLOADING;
 +	if (!ca0132_download_dsp_images(codec))
 +		spec->dsp_state = DSP_DOWNLOAD_FAILED;
 +	else
 +		spec->dsp_state = DSP_DOWNLOADED;
  
++<<<<<<< HEAD
 +	if (spec->dsp_state == DSP_DOWNLOADED)
++=======
+ 		if (!ca0132_download_dsp_images(codec))
+ 			spec->dsp_state = DSP_DOWNLOAD_FAILED;
+ 		else
+ 			spec->dsp_state = DSP_DOWNLOADED;
+ 	}
+ 
+ 	/* For codecs using alt functions, this is already done earlier */
+ 	if (spec->dsp_state == DSP_DOWNLOADED && !ca0132_use_alt_functions(spec))
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  		ca0132_set_dsp_msr(codec, true);
  }
  
@@@ -4548,7 -7649,7 +6256,11 @@@ static void ca0132_init_unsol(struct hd
  	snd_hda_jack_detect_enable_callback(codec, UNSOL_TAG_DSP,
  					    ca0132_process_dsp_response);
  	/* Front headphone jack detection */
++<<<<<<< HEAD
 +	if (spec->quirk == QUIRK_SBZ || spec->quirk == QUIRK_R3DI)
++=======
+ 	if (ca0132_use_alt_functions(spec))
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  		snd_hda_jack_detect_enable_callback(codec,
  			spec->unsol_tag_front_hp, hp_callback);
  }
@@@ -4618,7 -7739,11 +6330,15 @@@ static void ca0132_init_chip(struct hda
  	mutex_init(&spec->chipio_mutex);
  
  	spec->cur_out_type = SPEAKER_OUT;
++<<<<<<< HEAD
 +	spec->cur_mic_type = DIGITAL_MIC;
++=======
+ 	if (!ca0132_use_alt_functions(spec))
+ 		spec->cur_mic_type = DIGITAL_MIC;
+ 	else
+ 		spec->cur_mic_type = REAR_MIC;
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	spec->cur_mic_boost = 0;
  
  	for (i = 0; i < VNODES_COUNT; i++) {
@@@ -4636,11 -7761,28 +6356,34 @@@
  		on = (unsigned int)ca0132_effects[i].reqs[0];
  		spec->effects_switch[i] = on ? 1 : 0;
  	}
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Sets defaults for the effect slider controls, only for alternative
+ 	 * ca0132 codecs. Also sets x-bass crossover frequency to 80hz.
+ 	 */
+ 	if (ca0132_use_alt_controls(spec)) {
+ 		spec->xbass_xover_freq = 8;
+ 		for (i = 0; i < EFFECT_LEVEL_SLIDERS; i++)
+ 			spec->fx_ctl_val[i] = effect_slider_defaults[i];
+ 	}
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  
  	spec->voicefx_val = 0;
  	spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID] = 1;
  	spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] = 0;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * The ZxR doesn't have a front panel header, and it's line-in is on
+ 	 * the daughter board. So, there is no input enum control, and we need
+ 	 * to make sure that spec->in_enum_val is set properly.
+ 	 */
+ 	if (ca0132_quirk(spec) == QUIRK_ZXR)
+ 		spec->in_enum_val = REAR_MIC;
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  #ifdef ENABLE_TUNING_CONTROLS
  	ca0132_init_tuning_defaults(codec);
  #endif
@@@ -4819,28 -7972,392 +6562,411 @@@ static void ca0132_exit_chip(struct hda
  		dsp_reset(codec);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * This fixes a problem that was hard to reproduce. Very rarely, I would
+  * boot up, and there would be no sound, but the DSP indicated it had loaded
+  * properly. I did a few memory dumps to see if anything was different, and
+  * there were a few areas of memory uninitialized with a1a2a3a4. This function
+  * checks if those areas are uninitialized, and if they are, it'll attempt to
+  * reload the card 3 times. Usually it fixes by the second.
+  */
+ static void sbz_dsp_startup_check(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int dsp_data_check[4];
+ 	unsigned int cur_address = 0x390;
+ 	unsigned int i;
+ 	unsigned int failure = 0;
+ 	unsigned int reload = 3;
+ 
+ 	if (spec->startup_check_entered)
+ 		return;
+ 
+ 	spec->startup_check_entered = true;
+ 
+ 	for (i = 0; i < 4; i++) {
+ 		chipio_read(codec, cur_address, &dsp_data_check[i]);
+ 		cur_address += 0x4;
+ 	}
+ 	for (i = 0; i < 4; i++) {
+ 		if (dsp_data_check[i] == 0xa1a2a3a4)
+ 			failure = 1;
+ 	}
+ 
+ 	codec_dbg(codec, "Startup Check: %d ", failure);
+ 	if (failure)
+ 		codec_info(codec, "DSP not initialized properly. Attempting to fix.");
+ 	/*
+ 	 * While the failure condition is true, and we haven't reached our
+ 	 * three reload limit, continue trying to reload the driver and
+ 	 * fix the issue.
+ 	 */
+ 	while (failure && (reload != 0)) {
+ 		codec_info(codec, "Reloading... Tries left: %d", reload);
+ 		sbz_exit_chip(codec);
+ 		spec->dsp_state = DSP_DOWNLOAD_INIT;
+ 		codec->patch_ops.init(codec);
+ 		failure = 0;
+ 		for (i = 0; i < 4; i++) {
+ 			chipio_read(codec, cur_address, &dsp_data_check[i]);
+ 			cur_address += 0x4;
+ 		}
+ 		for (i = 0; i < 4; i++) {
+ 			if (dsp_data_check[i] == 0xa1a2a3a4)
+ 				failure = 1;
+ 		}
+ 		reload--;
+ 	}
+ 
+ 	if (!failure && reload < 3)
+ 		codec_info(codec, "DSP fixed.");
+ 
+ 	if (!failure)
+ 		return;
+ 
+ 	codec_info(codec, "DSP failed to initialize properly. Either try a full shutdown or a suspend to clear the internal memory.");
+ }
+ 
+ /*
+  * This is for the extra volume verbs 0x797 (left) and 0x798 (right). These add
+  * extra precision for decibel values. If you had the dB value in floating point
+  * you would take the value after the decimal point, multiply by 64, and divide
+  * by 2. So for 8.59, it's (59 * 64) / 100. Useful if someone wanted to
+  * implement fixed point or floating point dB volumes. For now, I'll set them
+  * to 0 just incase a value has lingered from a boot into Windows.
+  */
+ static void ca0132_alt_vol_setup(struct hda_codec *codec)
+ {
+ 	snd_hda_codec_write(codec, 0x02, 0, 0x797, 0x00);
+ 	snd_hda_codec_write(codec, 0x02, 0, 0x798, 0x00);
+ 	snd_hda_codec_write(codec, 0x03, 0, 0x797, 0x00);
+ 	snd_hda_codec_write(codec, 0x03, 0, 0x798, 0x00);
+ 	snd_hda_codec_write(codec, 0x04, 0, 0x797, 0x00);
+ 	snd_hda_codec_write(codec, 0x04, 0, 0x798, 0x00);
+ 	snd_hda_codec_write(codec, 0x07, 0, 0x797, 0x00);
+ 	snd_hda_codec_write(codec, 0x07, 0, 0x798, 0x00);
+ }
+ 
+ /*
+  * Extra commands that don't really fit anywhere else.
+  */
+ static void sbz_pre_dsp_setup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	writel(0x00820680, spec->mem_base + 0x01C);
+ 	writel(0x00820680, spec->mem_base + 0x01C);
+ 
+ 	chipio_write(codec, 0x18b0a4, 0x000000c2);
+ 
+ 	snd_hda_codec_write(codec, 0x11, 0,
+ 			AC_VERB_SET_PIN_WIDGET_CONTROL, 0x44);
+ }
+ 
+ static void r3d_pre_dsp_setup(struct hda_codec *codec)
+ {
+ 	chipio_write(codec, 0x18b0a4, 0x000000c2);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x1E);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_HIGH, 0x1C);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_DATA_WRITE, 0x5B);
+ 
+ 	snd_hda_codec_write(codec, 0x11, 0,
+ 			AC_VERB_SET_PIN_WIDGET_CONTROL, 0x44);
+ }
+ 
+ static void r3di_pre_dsp_setup(struct hda_codec *codec)
+ {
+ 	chipio_write(codec, 0x18b0a4, 0x000000c2);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x1E);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_HIGH, 0x1C);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_DATA_WRITE, 0x5B);
+ 
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x20);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_HIGH, 0x19);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_DATA_WRITE, 0x00);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_DATA_WRITE, 0x40);
+ 
+ 	snd_hda_codec_write(codec, 0x11, 0,
+ 			AC_VERB_SET_PIN_WIDGET_CONTROL, 0x04);
+ }
+ 
+ /*
+  * These are sent before the DSP is downloaded. Not sure
+  * what they do, or if they're necessary. Could possibly
+  * be removed. Figure they're better to leave in.
+  */
+ static void ca0132_mmio_init(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_AE5)
+ 		writel(0x00000001, spec->mem_base + 0x400);
+ 	else
+ 		writel(0x00000000, spec->mem_base + 0x400);
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_AE5)
+ 		writel(0x00000001, spec->mem_base + 0x408);
+ 	else
+ 		writel(0x00000000, spec->mem_base + 0x408);
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_AE5)
+ 		writel(0x00000001, spec->mem_base + 0x40c);
+ 	else
+ 		writel(0x00000000, spec->mem_base + 0x40C);
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_ZXR)
+ 		writel(0x00880640, spec->mem_base + 0x01C);
+ 	else
+ 		writel(0x00880680, spec->mem_base + 0x01C);
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_AE5)
+ 		writel(0x00000080, spec->mem_base + 0xC0C);
+ 	else
+ 		writel(0x00000083, spec->mem_base + 0xC0C);
+ 
+ 	writel(0x00000030, spec->mem_base + 0xC00);
+ 	writel(0x00000000, spec->mem_base + 0xC04);
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_AE5)
+ 		writel(0x00000000, spec->mem_base + 0xC0C);
+ 	else
+ 		writel(0x00000003, spec->mem_base + 0xC0C);
+ 
+ 	writel(0x00000003, spec->mem_base + 0xC0C);
+ 	writel(0x00000003, spec->mem_base + 0xC0C);
+ 	writel(0x00000003, spec->mem_base + 0xC0C);
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_AE5)
+ 		writel(0x00000001, spec->mem_base + 0xC08);
+ 	else
+ 		writel(0x000000C1, spec->mem_base + 0xC08);
+ 
+ 	writel(0x000000F1, spec->mem_base + 0xC08);
+ 	writel(0x00000001, spec->mem_base + 0xC08);
+ 	writel(0x000000C7, spec->mem_base + 0xC08);
+ 	writel(0x000000C1, spec->mem_base + 0xC08);
+ 	writel(0x00000080, spec->mem_base + 0xC04);
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_AE5) {
+ 		writel(0x00000000, spec->mem_base + 0x42c);
+ 		writel(0x00000000, spec->mem_base + 0x46c);
+ 		writel(0x00000000, spec->mem_base + 0x4ac);
+ 		writel(0x00000000, spec->mem_base + 0x4ec);
+ 		writel(0x00000000, spec->mem_base + 0x43c);
+ 		writel(0x00000000, spec->mem_base + 0x47c);
+ 		writel(0x00000000, spec->mem_base + 0x4bc);
+ 		writel(0x00000000, spec->mem_base + 0x4fc);
+ 		writel(0x00000600, spec->mem_base + 0x100);
+ 		writel(0x00000014, spec->mem_base + 0x410);
+ 		writel(0x0000060f, spec->mem_base + 0x100);
+ 		writel(0x0000070f, spec->mem_base + 0x100);
+ 		writel(0x00000aff, spec->mem_base + 0x830);
+ 		writel(0x00000000, spec->mem_base + 0x86c);
+ 		writel(0x0000006b, spec->mem_base + 0x800);
+ 		writel(0x00000001, spec->mem_base + 0x86c);
+ 		writel(0x0000006b, spec->mem_base + 0x800);
+ 		writel(0x00000057, spec->mem_base + 0x804);
+ 		writel(0x00800000, spec->mem_base + 0x20c);
+ 	}
+ }
+ 
+ /*
+  * This function writes to some SFR's, does some region2 writes, and then
+  * eventually resets the codec with the 0x7ff verb. Not quite sure why it does
+  * what it does.
+  */
+ static void ae5_register_set(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	chipio_8051_write_direct(codec, 0x93, 0x10);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x44);
+ 	snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PLL_PMU_WRITE, 0xc2);
+ 
+ 	writeb(0x0f, spec->mem_base + 0x304);
+ 	writeb(0x0f, spec->mem_base + 0x304);
+ 	writeb(0x0f, spec->mem_base + 0x304);
+ 	writeb(0x0f, spec->mem_base + 0x304);
+ 	writeb(0x0e, spec->mem_base + 0x100);
+ 	writeb(0x1f, spec->mem_base + 0x304);
+ 	writeb(0x0c, spec->mem_base + 0x100);
+ 	writeb(0x3f, spec->mem_base + 0x304);
+ 	writeb(0x08, spec->mem_base + 0x100);
+ 	writeb(0x7f, spec->mem_base + 0x304);
+ 	writeb(0x00, spec->mem_base + 0x100);
+ 	writeb(0xff, spec->mem_base + 0x304);
+ 
+ 	ca0113_mmio_command_set(codec, 0x30, 0x2d, 0x3f);
+ 
+ 	chipio_8051_write_direct(codec, 0x90, 0x00);
+ 	chipio_8051_write_direct(codec, 0x90, 0x10);
+ 
+ 	ca0113_mmio_command_set(codec, 0x48, 0x07, 0x83);
+ 
+ 	chipio_write(codec, 0x18b0a4, 0x000000c2);
+ 
+ 	snd_hda_codec_write(codec, 0x01, 0, 0x7ff, 0x00);
+ 	snd_hda_codec_write(codec, 0x01, 0, 0x7ff, 0x00);
+ }
+ 
+ /*
+  * Extra init functions for alternative ca0132 codecs. Done
+  * here so they don't clutter up the main ca0132_init function
+  * anymore than they have to.
+  */
+ static void ca0132_alt_init(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ca0132_alt_vol_setup(codec);
+ 
+ 	switch (ca0132_quirk(spec)) {
+ 	case QUIRK_SBZ:
+ 		codec_dbg(codec, "SBZ alt_init");
+ 		ca0132_gpio_init(codec);
+ 		sbz_pre_dsp_setup(codec);
+ 		snd_hda_sequence_write(codec, spec->chip_init_verbs);
+ 		snd_hda_sequence_write(codec, spec->desktop_init_verbs);
+ 		break;
+ 	case QUIRK_R3DI:
+ 		codec_dbg(codec, "R3DI alt_init");
+ 		ca0132_gpio_init(codec);
+ 		ca0132_gpio_setup(codec);
+ 		r3di_gpio_dsp_status_set(codec, R3DI_DSP_DOWNLOADING);
+ 		r3di_pre_dsp_setup(codec);
+ 		snd_hda_sequence_write(codec, spec->chip_init_verbs);
+ 		snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0, 0x6FF, 0xC4);
+ 		break;
+ 	case QUIRK_R3D:
+ 		r3d_pre_dsp_setup(codec);
+ 		snd_hda_sequence_write(codec, spec->chip_init_verbs);
+ 		snd_hda_sequence_write(codec, spec->desktop_init_verbs);
+ 		break;
+ 	case QUIRK_AE5:
+ 		ca0132_gpio_init(codec);
+ 		snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 				VENDOR_CHIPIO_8051_ADDRESS_LOW, 0x49);
+ 		snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 				VENDOR_CHIPIO_PLL_PMU_WRITE, 0x88);
+ 		chipio_write(codec, 0x18b030, 0x00000020);
+ 		snd_hda_sequence_write(codec, spec->chip_init_verbs);
+ 		snd_hda_sequence_write(codec, spec->desktop_init_verbs);
+ 		ca0113_mmio_command_set(codec, 0x30, 0x32, 0x3f);
+ 		break;
+ 	case QUIRK_ZXR:
+ 		snd_hda_sequence_write(codec, spec->chip_init_verbs);
+ 		snd_hda_sequence_write(codec, spec->desktop_init_verbs);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  static int ca0132_init(struct hda_codec *codec)
  {
  	struct ca0132_spec *spec = codec->spec;
 -	struct auto_pin_cfg *cfg = &spec->autocfg;
 +	struct auto_pin_cfg *cfg = &spec->gen.autocfg;
  	int i;
++<<<<<<< HEAD
++=======
+ 	bool dsp_loaded;
+ 
+ 	/*
+ 	 * If the DSP is already downloaded, and init has been entered again,
+ 	 * there's only two reasons for it. One, the codec has awaken from a
+ 	 * suspended state, and in that case dspload_is_loaded will return
+ 	 * false, and the init will be ran again. The other reason it gets
+ 	 * re entered is on startup for some reason it triggers a suspend and
+ 	 * resume state. In this case, it will check if the DSP is downloaded,
+ 	 * and not run the init function again. For codecs using alt_functions,
+ 	 * it will check if the DSP is loaded properly.
+ 	 */
+ 	if (spec->dsp_state == DSP_DOWNLOADED) {
+ 		dsp_loaded = dspload_is_loaded(codec);
+ 		if (!dsp_loaded) {
+ 			spec->dsp_reload = true;
+ 			spec->dsp_state = DSP_DOWNLOAD_INIT;
+ 		} else {
+ 			if (ca0132_quirk(spec) == QUIRK_SBZ)
+ 				sbz_dsp_startup_check(codec);
+ 			return 0;
+ 		}
+ 	}
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  
  	if (spec->dsp_state != DSP_DOWNLOAD_FAILED)
  		spec->dsp_state = DSP_DOWNLOAD_INIT;
  	spec->curr_chip_addx = INVALID_CHIP_ADDRESS;
  
++<<<<<<< HEAD
++	snd_hda_power_up_pm(codec);
++
++=======
+ 	if (ca0132_use_pci_mmio(spec))
+ 		ca0132_mmio_init(codec);
+ 
  	snd_hda_power_up_pm(codec);
  
+ 	if (ca0132_quirk(spec) == QUIRK_AE5)
+ 		ae5_register_set(codec);
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	ca0132_init_unsol(codec);
 +
  	ca0132_init_params(codec);
  	ca0132_init_flags(codec);
 -
  	snd_hda_sequence_write(codec, spec->base_init_verbs);
++<<<<<<< HEAD
++=======
+ 
+ 	if (ca0132_use_alt_functions(spec))
+ 		ca0132_alt_init(codec);
+ 
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	ca0132_download_dsp(codec);
 -
  	ca0132_refresh_widget_caps(codec);
++<<<<<<< HEAD
 +	ca0132_setup_defaults(codec);
 +	ca0132_init_analog_mic2(codec);
 +	ca0132_init_dmic(codec);
++=======
+ 
+ 	switch (ca0132_quirk(spec)) {
+ 	case QUIRK_R3DI:
+ 	case QUIRK_R3D:
+ 		r3d_setup_defaults(codec);
+ 		break;
+ 	case QUIRK_SBZ:
+ 	case QUIRK_ZXR:
+ 		sbz_setup_defaults(codec);
+ 		break;
+ 	case QUIRK_AE5:
+ 		ae5_setup_defaults(codec);
+ 		break;
+ 	default:
+ 		ca0132_setup_defaults(codec);
+ 		ca0132_init_analog_mic2(codec);
+ 		ca0132_init_dmic(codec);
+ 		break;
+ 	}
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  
  	for (i = 0; i < spec->num_outputs; i++)
  		init_output(codec, spec->out_pins[i], spec->dacs[0]);
@@@ -4852,11 -8369,25 +6978,33 @@@
  
  	init_input(codec, cfg->dig_in_pin, spec->dig_in);
  
++<<<<<<< HEAD
 +	snd_hda_sequence_write(codec, spec->chip_init_verbs);
 +	snd_hda_sequence_write(codec, spec->spec_init_verbs);
 +
 +	ca0132_select_out(codec);
 +	ca0132_select_mic(codec);
++=======
+ 	if (!ca0132_use_alt_functions(spec)) {
+ 		snd_hda_sequence_write(codec, spec->chip_init_verbs);
+ 		snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PARAM_EX_ID_SET, 0x0D);
+ 		snd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,
+ 			    VENDOR_CHIPIO_PARAM_EX_VALUE_SET, 0x20);
+ 	}
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_SBZ)
+ 		ca0132_gpio_setup(codec);
+ 
+ 	snd_hda_sequence_write(codec, spec->spec_init_verbs);
+ 	if (ca0132_use_alt_functions(spec)) {
+ 		ca0132_alt_select_out(codec);
+ 		ca0132_alt_select_in(codec);
+ 	} else {
+ 		ca0132_select_out(codec);
+ 		ca0132_select_mic(codec);
+ 	}
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  
  	snd_hda_jack_report_sync(codec);
  
@@@ -4923,7 -8498,7 +7073,11 @@@ static void ca0132_config(struct hda_co
  	spec->multiout.dac_nids = spec->dacs;
  	spec->multiout.num_dacs = 3;
  
++<<<<<<< HEAD
 +	if (spec->quirk == QUIRK_NONE || spec->quirk == QUIRK_ALIENWARE)
++=======
+ 	if (!ca0132_use_alt_functions(spec))
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  		spec->multiout.max_channels = 2;
  	else
  		spec->multiout.max_channels = 6;
@@@ -5125,7 -8689,15 +7281,19 @@@ static int ca0132_prepare_verbs(struct 
  	struct ca0132_spec *spec = codec->spec;
  
  	spec->chip_init_verbs = ca0132_init_verbs0;
++<<<<<<< HEAD
 +	spec->spec_init_verbs = kzalloc(sizeof(struct hda_verb) * NUM_SPEC_VERBS, GFP_KERNEL);
++=======
+ 	/*
+ 	 * Since desktop cards use pci_mmio, this can be used to determine
+ 	 * whether or not to use these verbs instead of a separate bool.
+ 	 */
+ 	if (ca0132_use_pci_mmio(spec))
+ 		spec->desktop_init_verbs = ca0132_init_verbs1;
+ 	spec->spec_init_verbs = kcalloc(NUM_SPEC_VERBS,
+ 					sizeof(struct hda_verb),
+ 					GFP_KERNEL);
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  	if (!spec->spec_init_verbs)
  		return -ENOMEM;
  
@@@ -5255,15 -8768,81 +7423,92 @@@ static int patch_ca0132(struct hda_code
  		spec->quirk = quirk->value;
  	else
  		spec->quirk = QUIRK_NONE;
++<<<<<<< HEAD
 +
 +	if (spec->quirk == QUIRK_GENERIC_PARSER)
 +		return parse_ca0132_generic(codec);
++=======
+ 	if (ca0132_quirk(spec) == QUIRK_SBZ)
+ 		sbz_detect_quirk(codec);
+ 
+ 	if (ca0132_quirk(spec) == QUIRK_ZXR_DBPRO)
+ 		codec->patch_ops = dbpro_patch_ops;
+ 	else
+ 		codec->patch_ops = ca0132_patch_ops;
+ 
+ 	codec->pcm_format_first = 1;
+ 	codec->no_sticky_stream = 1;
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  
 +	codec->patch_ops = ca0132_patch_ops;
  
  	spec->dsp_state = DSP_DOWNLOAD_INIT;
  	spec->num_mixers = 1;
++<<<<<<< HEAD
 +	spec->mixers[0] = ca0132_mixer;
++=======
+ 
+ 	/* Set which mixers each quirk uses. */
+ 	switch (ca0132_quirk(spec)) {
+ 	case QUIRK_SBZ:
+ 		spec->mixers[0] = desktop_mixer;
+ 		snd_hda_codec_set_name(codec, "Sound Blaster Z");
+ 		break;
+ 	case QUIRK_ZXR:
+ 		spec->mixers[0] = desktop_mixer;
+ 		snd_hda_codec_set_name(codec, "Sound Blaster ZxR");
+ 		break;
+ 	case QUIRK_ZXR_DBPRO:
+ 		break;
+ 	case QUIRK_R3D:
+ 		spec->mixers[0] = desktop_mixer;
+ 		snd_hda_codec_set_name(codec, "Recon3D");
+ 		break;
+ 	case QUIRK_R3DI:
+ 		spec->mixers[0] = r3di_mixer;
+ 		snd_hda_codec_set_name(codec, "Recon3Di");
+ 		break;
+ 	case QUIRK_AE5:
+ 		spec->mixers[0] = desktop_mixer;
+ 		snd_hda_codec_set_name(codec, "Sound BlasterX AE-5");
+ 		break;
+ 	default:
+ 		spec->mixers[0] = ca0132_mixer;
+ 		break;
+ 	}
+ 
+ 	/* Setup whether or not to use alt functions/controls/pci_mmio */
+ 	switch (ca0132_quirk(spec)) {
+ 	case QUIRK_SBZ:
+ 	case QUIRK_R3D:
+ 	case QUIRK_AE5:
+ 	case QUIRK_ZXR:
+ 		spec->use_alt_controls = true;
+ 		spec->use_alt_functions = true;
+ 		spec->use_pci_mmio = true;
+ 		break;
+ 	case QUIRK_R3DI:
+ 		spec->use_alt_controls = true;
+ 		spec->use_alt_functions = true;
+ 		spec->use_pci_mmio = false;
+ 		break;
+ 	default:
+ 		spec->use_alt_controls = false;
+ 		spec->use_alt_functions = false;
+ 		spec->use_pci_mmio = false;
+ 		break;
+ 	}
+ 
+ #ifdef CONFIG_PCI
+ 	if (spec->use_pci_mmio) {
+ 		spec->mem_base = pci_iomap(codec->bus->pci, 2, 0xC20);
+ 		if (spec->mem_base == NULL) {
+ 			codec_warn(codec, "pci_iomap failed! Setting quirk to QUIRK_NONE.");
+ 			spec->quirk = QUIRK_NONE;
+ 		}
+ 	}
+ #endif
++>>>>>>> 6da8f44624ad (ALSA: hda/ca0132 - Optimize for non-PCI configuration)
  
  	spec->base_init_verbs = ca0132_base_init_verbs;
  	spec->base_exit_verbs = ca0132_base_exit_verbs;
* Unmerged path sound/pci/hda/patch_ca0132.c
