efi: Runtime-wrapper: Get rid of the rtc_lock spinlock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ard Biesheuvel <ard.biesheuvel@linaro.org>
commit 1bb6936473c07b5a7c8daced1000893b7145bb14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/1bb69364.failed

The rtc_lock spinlock aims to serialize access to the CMOS RTC
between the UEFI firmware and the kernel drivers that use it
directly. However, x86 is the only arch that performs such
direct accesses, and that never uses the time related UEFI
runtime services. Since no other UEFI enlightened architectures
have a legcay CMOS RTC anyway, we can remove the rtc_lock
spinlock entirely.

	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
Link: http://lkml.kernel.org/r/1454364428-494-7-git-send-email-matt@codeblueprint.co.uk
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 1bb6936473c07b5a7c8daced1000893b7145bb14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/runtime-wrappers.c
diff --cc drivers/firmware/efi/runtime-wrappers.c
index dcc976822484,7b8b2f2702ca..000000000000
--- a/drivers/firmware/efi/runtime-wrappers.c
+++ b/drivers/firmware/efi/runtime-wrappers.c
@@@ -19,45 -21,54 +19,54 @@@
  #include <asm/efi.h>
  
  /*
 - * According to section 7.1 of the UEFI spec, Runtime Services are not fully
 - * reentrant, and there are particular combinations of calls that need to be
 - * serialized. (source: UEFI Specification v2.4A)
 - *
 - * Table 31. Rules for Reentry Into Runtime Services
 - * +------------------------------------+-------------------------------+
 - * | If previous call is busy in	| Forbidden to call		|
 - * +------------------------------------+-------------------------------+
 - * | Any				| SetVirtualAddressMap()	|
 - * +------------------------------------+-------------------------------+
 - * | ConvertPointer()			| ConvertPointer()		|
 - * +------------------------------------+-------------------------------+
 - * | SetVariable()			| ResetSystem()			|
 - * | UpdateCapsule()			|				|
 - * | SetTime()				|				|
 - * | SetWakeupTime()			|				|
 - * | GetNextHighMonotonicCount()	|				|
 - * +------------------------------------+-------------------------------+
 - * | GetVariable()			| GetVariable()			|
 - * | GetNextVariableName()		| GetNextVariableName()		|
 - * | SetVariable()			| SetVariable()			|
 - * | QueryVariableInfo()		| QueryVariableInfo()		|
 - * | UpdateCapsule()			| UpdateCapsule()		|
 - * | QueryCapsuleCapabilities()		| QueryCapsuleCapabilities()	|
 - * | GetNextHighMonotonicCount()	| GetNextHighMonotonicCount()	|
 - * +------------------------------------+-------------------------------+
 - * | GetTime()				| GetTime()			|
 - * | SetTime()				| SetTime()			|
 - * | GetWakeupTime()			| GetWakeupTime()		|
 - * | SetWakeupTime()			| SetWakeupTime()		|
 - * +------------------------------------+-------------------------------+
 - *
 - * Due to the fact that the EFI pstore may write to the variable store in
 - * interrupt context, we need to use a spinlock for at least the groups that
 - * contain SetVariable() and QueryVariableInfo(). That leaves little else, as
 - * none of the remaining functions are actually ever called at runtime.
 - * So let's just use a single spinlock to serialize all Runtime Services calls.
 + * Wrap around the new efi_call_virt_generic() macros so that the
 + * code doesn't get too cluttered:
   */
 -static DEFINE_SPINLOCK(efi_runtime_lock);
 +#define efi_call_virt(f, args...)   \
 +	efi_call_virt_pointer(efi.systab->runtime, f, args)
 +#define __efi_call_virt(f, args...) \
 +	__efi_call_virt_pointer(efi.systab->runtime, f, args)
 +
++<<<<<<< HEAD
 +void efi_call_virt_check_flags(unsigned long flags, const char *call)
 +{
 +	unsigned long cur_flags, mismatch;
 +
 +	local_save_flags(cur_flags);
  
 +	mismatch = flags ^ cur_flags;
 +	if (!WARN_ON_ONCE(mismatch & ARCH_EFI_IRQ_FLAGS_MASK))
 +		return;
 +
 +	add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_NOW_UNRELIABLE);
 +	pr_err_ratelimited(FW_BUG "IRQ flags corrupted (0x%08lx=>0x%08lx) by EFI %s\n",
 +			   flags, cur_flags, call);
 +	local_irq_restore(flags);
 +}
 +
 +/* As per commit ef68c8f87ed1 ("x86: Serialize EFI time accesses on rtc_lock"),
 + * the EFI specification requires that callers of the time related runtime
 + * functions serialize with other CMOS accesses in the kernel, as the EFI time
 + * functions may choose to also use the legacy CMOS RTC.
 + */
 +__weak DEFINE_SPINLOCK(rtc_lock);
 +
++=======
++>>>>>>> 1bb6936473c0 (efi: Runtime-wrapper: Get rid of the rtc_lock spinlock)
  static efi_status_t virt_efi_get_time(efi_time_t *tm, efi_time_cap_t *tc)
  {
  	unsigned long flags;
  	efi_status_t status;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	status = efi_call_virt(get_time, tm, tc);
 +	spin_unlock_irqrestore(&rtc_lock, flags);
++=======
+ 	spin_lock_irqsave(&efi_runtime_lock, flags);
+ 	status = efi_call_virt(get_time, tm, tc);
+ 	spin_unlock_irqrestore(&efi_runtime_lock, flags);
++>>>>>>> 1bb6936473c0 (efi: Runtime-wrapper: Get rid of the rtc_lock spinlock)
  	return status;
  }
  
@@@ -66,9 -77,9 +75,15 @@@ static efi_status_t virt_efi_set_time(e
  	unsigned long flags;
  	efi_status_t status;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	status = efi_call_virt(set_time, tm);
 +	spin_unlock_irqrestore(&rtc_lock, flags);
++=======
+ 	spin_lock_irqsave(&efi_runtime_lock, flags);
+ 	status = efi_call_virt(set_time, tm);
+ 	spin_unlock_irqrestore(&efi_runtime_lock, flags);
++>>>>>>> 1bb6936473c0 (efi: Runtime-wrapper: Get rid of the rtc_lock spinlock)
  	return status;
  }
  
@@@ -79,9 -90,9 +94,15 @@@ static efi_status_t virt_efi_get_wakeup
  	unsigned long flags;
  	efi_status_t status;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	status = efi_call_virt(get_wakeup_time, enabled, pending, tm);
 +	spin_unlock_irqrestore(&rtc_lock, flags);
++=======
+ 	spin_lock_irqsave(&efi_runtime_lock, flags);
+ 	status = efi_call_virt(get_wakeup_time, enabled, pending, tm);
+ 	spin_unlock_irqrestore(&efi_runtime_lock, flags);
++>>>>>>> 1bb6936473c0 (efi: Runtime-wrapper: Get rid of the rtc_lock spinlock)
  	return status;
  }
  
@@@ -90,9 -101,9 +111,15 @@@ static efi_status_t virt_efi_set_wakeup
  	unsigned long flags;
  	efi_status_t status;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&rtc_lock, flags);
 +	status = efi_call_virt(set_wakeup_time, enabled, tm);
 +	spin_unlock_irqrestore(&rtc_lock, flags);
++=======
+ 	spin_lock_irqsave(&efi_runtime_lock, flags);
+ 	status = efi_call_virt(set_wakeup_time, enabled, tm);
+ 	spin_unlock_irqrestore(&efi_runtime_lock, flags);
++>>>>>>> 1bb6936473c0 (efi: Runtime-wrapper: Get rid of the rtc_lock spinlock)
  	return status;
  }
  
* Unmerged path drivers/firmware/efi/runtime-wrappers.c
