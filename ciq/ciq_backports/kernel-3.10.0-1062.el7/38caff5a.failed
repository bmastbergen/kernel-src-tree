r8169: handle all interrupt events in the hard irq handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit 38caff5a445bf7cc6b312b9925320ae969b796c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/38caff5a.failed

Having a separate "slow event" handler isn't needed because all
interrupt events trigger asynchronous activity. And in case of SYSErr
we have bigger problems than performance anyway.
This patch also allows to get rid of acking interrupt events in the
NAPI poll callback.

	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 38caff5a445bf7cc6b312b9925320ae969b796c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/realtek/r8169.c
diff --cc drivers/net/ethernet/realtek/r8169.c
index b884c766fbf3,114bd9e54924..000000000000
--- a/drivers/net/ethernet/realtek/r8169.c
+++ b/drivers/net/ethernet/realtek/r8169.c
@@@ -6738,42 -6451,29 +6737,33 @@@ static irqreturn_t rtl8169_interrupt(in
  	if (status == 0xffff || !(status & (RTL_EVENT_NAPI | tp->event_slow)))
  		return IRQ_NONE;
  
- 	rtl_irq_disable(tp);
- 	napi_schedule_irqoff(&tp->napi);
- 
- 	return IRQ_HANDLED;
- }
- 
- /*
-  * Workqueue context.
-  */
- static void rtl_slow_event_work(struct rtl8169_private *tp)
- {
- 	struct net_device *dev = tp->dev;
- 	u16 status;
- 
- 	status = rtl_get_events(tp) & tp->event_slow;
- 	rtl_ack_events(tp, status);
- 
- 	if (unlikely(status & RxFIFOOver)) {
- 		switch (tp->mac_version) {
- 		/* Work around for rx fifo overflow */
- 		case RTL_GIGA_MAC_VER_11:
- 			netif_stop_queue(dev);
- 			/* XXX - Hack alert. See rtl_task(). */
- 			set_bit(RTL_FLAG_TASK_RESET_PENDING, tp->wk.flags);
- 		default:
- 			break;
- 		}
+ 	if (unlikely(status & SYSErr)) {
+ 		rtl8169_pcierr_interrupt(tp->dev);
+ 		goto out;
  	}
  
- 	if (unlikely(status & SYSErr))
- 		rtl8169_pcierr_interrupt(dev);
- 
  	if (status & LinkChg)
++<<<<<<< HEAD
 +		rtl8169_check_link_status(dev, tp);
++=======
+ 		phy_mac_interrupt(tp->dev->phydev);
++>>>>>>> 38caff5a445b (r8169: handle all interrupt events in the hard irq handler)
+ 
+ 	if (unlikely(status & RxFIFOOver &&
+ 	    tp->mac_version == RTL_GIGA_MAC_VER_11)) {
+ 		netif_stop_queue(tp->dev);
+ 		/* XXX - Hack alert. See rtl_task(). */
+ 		set_bit(RTL_FLAG_TASK_RESET_PENDING, tp->wk.flags);
+ 	}
  
- 	rtl_irq_enable_all(tp);
+ 	if (status & RTL_EVENT_NAPI) {
+ 		rtl_irq_disable(tp);
+ 		napi_schedule_irqoff(&tp->napi);
+ 	}
+ out:
+ 	rtl_ack_events(tp, status);
+ 
+ 	return IRQ_HANDLED;
  }
  
  static void rtl_task(struct work_struct *work)
* Unmerged path drivers/net/ethernet/realtek/r8169.c
