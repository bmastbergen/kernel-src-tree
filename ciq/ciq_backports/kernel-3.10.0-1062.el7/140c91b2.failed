watchdog: iTCO_wdt: Add PMC specific noreboot update api

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [watchdog] itco_wdt: Add PMC specific noreboot update api (David Arcari) [1645537]
Rebuild_FUZZ: 90.20%
commit-author Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
commit 140c91b26ebc48d80c6ac3ef06953b17d7fb3785
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/140c91b2.failed

In some SoCs, setting noreboot bit needs modification to
PMC GC registers. But not all PMC drivers allow other drivers
to memory map their GC region. This could create mem request
conflict in watchdog driver. So this patch adds facility to allow
PMC drivers to pass noreboot update function to watchdog
drivers via platform data.

	Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
	Acked-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
(cherry picked from commit 140c91b26ebc48d80c6ac3ef06953b17d7fb3785)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/watchdog/iTCO_wdt.c
diff --cc drivers/watchdog/iTCO_wdt.c
index 8dfafe4078c8,347f0389b089..000000000000
--- a/drivers/watchdog/iTCO_wdt.c
+++ b/drivers/watchdog/iTCO_wdt.c
@@@ -102,12 -102,15 +102,20 @@@ static struct {		/* this is private dat
  	unsigned long __iomem *gcs_pmc;
  	/* the lock for io operations */
  	spinlock_t io_lock;
 +	struct platform_device *dev;
  	/* the PCI-device */
 -	struct pci_dev *pci_dev;
 +	struct pci_dev *pdev;
  	/* whether or not the watchdog has been suspended */
  	bool suspended;
++<<<<<<< HEAD
 +} iTCO_wdt_private;
++=======
+ 	/* no reboot API private data */
+ 	void *no_reboot_priv;
+ 	/* no reboot update function pointer */
+ 	int (*update_no_reboot_bit)(void *p, bool set);
+ };
++>>>>>>> 140c91b26ebc (watchdog: iTCO_wdt: Add PMC specific noreboot update api)
  
  /* module parameters */
  #define WATCHDOG_TIMEOUT 30	/* 30 sec default heartbeat */
@@@ -211,17 -199,57 +219,64 @@@ static int iTCO_wdt_unset_NO_REBOOT_bit
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int update_no_reboot_bit_mem(void *priv, bool set)
+ {
+ 	struct iTCO_wdt_private *p = priv;
+ 	u32 val32 = 0, newval32 = 0;
+ 
+ 	val32 = readl(p->gcs_pmc);
+ 	if (set)
+ 		val32 |= no_reboot_bit(p);
+ 	else
+ 		val32 &= ~no_reboot_bit(p);
+ 	writel(val32, p->gcs_pmc);
+ 	newval32 = readl(p->gcs_pmc);
+ 
+ 	/* make sure the update is successful */
+ 	if (val32 != newval32)
+ 		return -EIO;
+ 
+ 	return 0;
+ }
+ 
+ static void iTCO_wdt_no_reboot_bit_setup(struct iTCO_wdt_private *p,
+ 		struct itco_wdt_platform_data *pdata)
+ {
+ 	if (pdata->update_no_reboot_bit) {
+ 		p->update_no_reboot_bit = pdata->update_no_reboot_bit;
+ 		p->no_reboot_priv = pdata->no_reboot_priv;
+ 		return;
+ 	}
+ 
+ 	if (p->iTCO_version >= 2)
+ 		p->update_no_reboot_bit = update_no_reboot_bit_mem;
+ 	else if (p->iTCO_version == 1)
+ 		p->update_no_reboot_bit = update_no_reboot_bit_pci;
+ 	else
+ 		p->update_no_reboot_bit = update_no_reboot_bit_def;
+ 
+ 	p->no_reboot_priv = p;
+ }
+ 
++>>>>>>> 140c91b26ebc (watchdog: iTCO_wdt: Add PMC specific noreboot update api)
  static int iTCO_wdt_start(struct watchdog_device *wd_dev)
  {
 -	struct iTCO_wdt_private *p = watchdog_get_drvdata(wd_dev);
  	unsigned int val;
  
 -	spin_lock(&p->io_lock);
 +	spin_lock(&iTCO_wdt_private.io_lock);
  
 -	iTCO_vendor_pre_start(p->smi_res, wd_dev->timeout);
 +	iTCO_vendor_pre_start(iTCO_wdt_private.smi_res, wd_dev->timeout);
  
  	/* disable chipset's NO_REBOOT bit */
++<<<<<<< HEAD
 +	if (iTCO_wdt_unset_NO_REBOOT_bit()) {
 +		spin_unlock(&iTCO_wdt_private.io_lock);
++=======
+ 	if (p->update_no_reboot_bit(p->no_reboot_priv, false)) {
+ 		spin_unlock(&p->io_lock);
++>>>>>>> 140c91b26ebc (watchdog: iTCO_wdt: Add PMC specific noreboot update api)
  		pr_err("failed to reset NO_REBOOT flag, reboot disabled by hardware/BIOS\n");
  		return -EIO;
  	}
@@@ -247,22 -275,23 +302,26 @@@
  
  static int iTCO_wdt_stop(struct watchdog_device *wd_dev)
  {
 -	struct iTCO_wdt_private *p = watchdog_get_drvdata(wd_dev);
  	unsigned int val;
  
 -	spin_lock(&p->io_lock);
 +	spin_lock(&iTCO_wdt_private.io_lock);
  
 -	iTCO_vendor_pre_stop(p->smi_res);
 +	iTCO_vendor_pre_stop(iTCO_wdt_private.smi_res);
  
  	/* Bit 11: TCO Timer Halt -> 1 = The TCO timer is disabled */
 -	val = inw(TCO1_CNT(p));
 +	val = inw(TCO1_CNT);
  	val |= 0x0800;
 -	outw(val, TCO1_CNT(p));
 -	val = inw(TCO1_CNT(p));
 +	outw(val, TCO1_CNT);
 +	val = inw(TCO1_CNT);
  
  	/* Set the NO_REBOOT bit to prevent later reboots, just for sure */
++<<<<<<< HEAD
 +	iTCO_wdt_set_NO_REBOOT_bit();
++=======
+ 	p->update_no_reboot_bit(p->no_reboot_priv, true);
++>>>>>>> 140c91b26ebc (watchdog: iTCO_wdt: Add PMC specific noreboot update api)
  
 -	spin_unlock(&p->io_lock);
 +	spin_unlock(&iTCO_wdt_private.io_lock);
  
  	if ((val & 0x0800) == 0)
  		return -1;
@@@ -398,101 -426,68 +457,131 @@@ static struct watchdog_device iTCO_wdt_
   *	Init & exit routines
   */
  
 -static int iTCO_wdt_probe(struct platform_device *pdev)
 +static void iTCO_wdt_cleanup(void)
  {
 -	struct device *dev = &pdev->dev;
 -	struct itco_wdt_platform_data *pdata = dev_get_platdata(dev);
 -	struct iTCO_wdt_private *p;
 +	/* Stop the timer before we leave */
 +	if (!nowayout)
 +		iTCO_wdt_stop(&iTCO_wdt_watchdog_dev);
 +
 +	/* Deregister */
 +	watchdog_unregister_device(&iTCO_wdt_watchdog_dev);
 +
 +	/* release resources */
 +	release_region(iTCO_wdt_private.tco_res->start,
 +			resource_size(iTCO_wdt_private.tco_res));
 +	release_region(iTCO_wdt_private.smi_res->start,
 +			resource_size(iTCO_wdt_private.smi_res));
 +	if (iTCO_wdt_private.iTCO_version >= 2) {
 +		iounmap(iTCO_wdt_private.gcs_pmc);
 +		release_mem_region(iTCO_wdt_private.gcs_pmc_res->start,
 +				resource_size(iTCO_wdt_private.gcs_pmc_res));
 +	}
 +
 +	iTCO_wdt_private.tco_res = NULL;
 +	iTCO_wdt_private.smi_res = NULL;
 +	iTCO_wdt_private.gcs_pmc_res = NULL;
 +	iTCO_wdt_private.gcs_pmc = NULL;
 +}
 +
 +static int iTCO_wdt_probe(struct platform_device *dev)
 +{
 +	int ret = -ENODEV;
  	unsigned long val32;
 -	int ret;
 +	struct itco_wdt_platform_data *pdata = dev->dev.platform_data;
  
  	if (!pdata)
 -		return -ENODEV;
 +		goto out;
  
 -	p = devm_kzalloc(dev, sizeof(*p), GFP_KERNEL);
 -	if (!p)
 -		return -ENOMEM;
 +	spin_lock_init(&iTCO_wdt_private.io_lock);
  
 -	spin_lock_init(&p->io_lock);
 +	iTCO_wdt_private.tco_res =
 +		platform_get_resource(dev, IORESOURCE_IO, ICH_RES_IO_TCO);
 +	if (!iTCO_wdt_private.tco_res)
 +		goto out;
  
 -	p->tco_res = platform_get_resource(pdev, IORESOURCE_IO, ICH_RES_IO_TCO);
 -	if (!p->tco_res)
 -		return -ENODEV;
 +	iTCO_wdt_private.smi_res =
 +		platform_get_resource(dev, IORESOURCE_IO, ICH_RES_IO_SMI);
 +	if (!iTCO_wdt_private.smi_res)
 +		goto out;
  
++<<<<<<< HEAD
 +	iTCO_wdt_private.iTCO_version = pdata->version;
 +	iTCO_wdt_private.dev = dev;
 +	iTCO_wdt_private.pdev = to_pci_dev(dev->dev.parent);
++=======
+ 	p->smi_res = platform_get_resource(pdev, IORESOURCE_IO, ICH_RES_IO_SMI);
+ 	if (!p->smi_res)
+ 		return -ENODEV;
+ 
+ 	p->iTCO_version = pdata->version;
+ 	p->pci_dev = to_pci_dev(dev->parent);
+ 
+ 	iTCO_wdt_no_reboot_bit_setup(p, pdata);
++>>>>>>> 140c91b26ebc (watchdog: iTCO_wdt: Add PMC specific noreboot update api)
  
  	/*
  	 * Get the Memory-Mapped GCS or PMC register, we need it for the
  	 * NO_REBOOT flag (TCO v2 and v3).
  	 */
++<<<<<<< HEAD
 +	if (iTCO_wdt_private.iTCO_version >= 2) {
 +		iTCO_wdt_private.gcs_pmc_res = platform_get_resource(dev,
 +							IORESOURCE_MEM,
 +							ICH_RES_MEM_GCS_PMC);
 +
 +		if (!iTCO_wdt_private.gcs_pmc_res)
 +			goto out;
 +
 +		if (!request_mem_region(iTCO_wdt_private.gcs_pmc_res->start,
 +			resource_size(iTCO_wdt_private.gcs_pmc_res), dev->name)) {
 +			ret = -EBUSY;
 +			goto out;
 +		}
 +		iTCO_wdt_private.gcs_pmc = ioremap(iTCO_wdt_private.gcs_pmc_res->start,
 +			resource_size(iTCO_wdt_private.gcs_pmc_res));
 +		if (!iTCO_wdt_private.gcs_pmc) {
 +			ret = -EIO;
 +			goto unreg_gcs_pmc;
 +		}
 +	}
 +
 +	/* Check chipset's NO_REBOOT bit */
 +	if (iTCO_wdt_unset_NO_REBOOT_bit() && iTCO_vendor_check_noreboot_on()) {
++=======
+ 	if (p->iTCO_version >= 2 && !pdata->update_no_reboot_bit) {
+ 		p->gcs_pmc_res = platform_get_resource(pdev,
+ 						       IORESOURCE_MEM,
+ 						       ICH_RES_MEM_GCS_PMC);
+ 		p->gcs_pmc = devm_ioremap_resource(dev, p->gcs_pmc_res);
+ 		if (IS_ERR(p->gcs_pmc))
+ 			return PTR_ERR(p->gcs_pmc);
+ 	}
+ 
+ 	/* Check chipset's NO_REBOOT bit */
+ 	if (p->update_no_reboot_bit(p->no_reboot_priv, false) &&
+ 	    iTCO_vendor_check_noreboot_on()) {
++>>>>>>> 140c91b26ebc (watchdog: iTCO_wdt: Add PMC specific noreboot update api)
  		pr_info("unable to reset NO_REBOOT flag, device disabled by hardware/BIOS\n");
 -		return -ENODEV;	/* Cannot reset NO_REBOOT bit */
 +		ret = -ENODEV;	/* Cannot reset NO_REBOOT bit */
 +		goto unmap_gcs_pmc;
  	}
  
  	/* Set the NO_REBOOT bit to prevent later reboots, just for sure */
++<<<<<<< HEAD
 +	iTCO_wdt_set_NO_REBOOT_bit();
++=======
+ 	p->update_no_reboot_bit(p->no_reboot_priv, true);
++>>>>>>> 140c91b26ebc (watchdog: iTCO_wdt: Add PMC specific noreboot update api)
  
  	/* The TCO logic uses the TCO_EN bit in the SMI_EN register */
 -	if (!devm_request_region(dev, p->smi_res->start,
 -				 resource_size(p->smi_res),
 -				 pdev->name)) {
 +	if (!request_region(iTCO_wdt_private.smi_res->start,
 +			resource_size(iTCO_wdt_private.smi_res), dev->name)) {
  		pr_err("I/O address 0x%04llx already in use, device disabled\n",
 -		       (u64)SMI_EN(p));
 -		return -EBUSY;
 +		       (u64)SMI_EN);
 +		ret = -EBUSY;
 +		goto unmap_gcs_pmc;
  	}
 -	if (turn_SMI_watchdog_clear_off >= p->iTCO_version) {
 +	if (turn_SMI_watchdog_clear_off >= iTCO_wdt_private.iTCO_version) {
  		/*
  		 * Bit 13: TCO_EN -> 0
  		 * Disables TCO logic generating an SMI#
* Unmerged path drivers/watchdog/iTCO_wdt.c
diff --git a/include/linux/platform_data/itco_wdt.h b/include/linux/platform_data/itco_wdt.h
index f16542c77ff7..0e95527edf25 100644
--- a/include/linux/platform_data/itco_wdt.h
+++ b/include/linux/platform_data/itco_wdt.h
@@ -14,6 +14,10 @@
 struct itco_wdt_platform_data {
 	char name[32];
 	unsigned int version;
+	/* private data to be passed to update_no_reboot_bit API */
+	void *no_reboot_priv;
+	/* pointer for platform specific no reboot update function */
+	int (*update_no_reboot_bit)(void *priv, bool set);
 };
 
 #endif /* _ITCO_WDT_H_ */
