ovl: cleanup temp index entries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 9ee60ce2491166c73a381e5f04dc4c3a147e169d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9ee60ce2.failed

A previous failed attempt to create or whiteout a directory index may
leave index entries named '#%x' in the index dir. Cleanup those temp
entries on mount instead of failing the mount.

In the future, we may drop 'work' dir and use 'index' dir instead.
This change is enough for cleaning up copy up leftovers 'from the future',
but it is not enough for cleaning up rmdir leftovers 'from the future'
(i.e. temp dir containing whiteouts).

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 9ee60ce2491166c73a381e5f04dc4c3a147e169d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/namei.c
diff --cc fs/overlayfs/namei.c
index 0afb8ae29e9b,7f27ec5999ea..000000000000
--- a/fs/overlayfs/namei.c
+++ b/fs/overlayfs/namei.c
@@@ -8,9 -8,10 +8,14 @@@
   */
  
  #include <linux/fs.h>
++<<<<<<< HEAD
++=======
+ #include <linux/cred.h>
+ #include <linux/ctype.h>
++>>>>>>> 9ee60ce24911 (ovl: cleanup temp index entries)
  #include <linux/namei.h>
  #include <linux/xattr.h>
 +#include <linux/cred.h>
  #include <linux/ratelimit.h>
  #include <linux/mount.h>
  #include <linux/exportfs.h>
@@@ -378,6 -439,41 +383,44 @@@ fail
  	goto out;
  }
  
++<<<<<<< HEAD
++=======
+ /* Get upper dentry from index */
+ static struct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index)
+ {
+ 	struct ovl_fh *fh;
+ 	struct dentry *upper;
+ 
+ 	if (!d_is_dir(index))
+ 		return dget(index);
+ 
+ 	fh = ovl_get_fh(index, OVL_XATTR_UPPER);
+ 	if (IS_ERR_OR_NULL(fh))
+ 		return ERR_CAST(fh);
+ 
+ 	upper = ovl_decode_fh(fh, ofs->upper_mnt);
+ 	kfree(fh);
+ 
+ 	if (IS_ERR_OR_NULL(upper))
+ 		return upper ?: ERR_PTR(-ESTALE);
+ 
+ 	if (!d_is_dir(upper)) {
+ 		pr_warn_ratelimited("overlayfs: invalid index upper (%pd2, upper=%pd2).\n",
+ 				    index, upper);
+ 		dput(upper);
+ 		return ERR_PTR(-EIO);
+ 	}
+ 
+ 	return upper;
+ }
+ 
+ /* Is this a leftover from create/whiteout of directory index entry? */
+ static bool ovl_is_temp_index(struct dentry *index)
+ {
+ 	return index->d_name.name[0] == '#';
+ }
+ 
++>>>>>>> 9ee60ce24911 (ovl: cleanup temp index entries)
  /*
   * Verify that an index entry name matches the origin file handle stored in
   * OVL_XATTR_ORIGIN and that origin file handle can be decoded to lower path.
@@@ -396,21 -491,12 +439,29 @@@ int ovl_verify_index(struct dentry *ind
  	if (!d_inode(index))
  		return 0;
  
++<<<<<<< HEAD
 +	/*
 +	 * Directory index entries are going to be used for looking up
 +	 * redirected upper dirs by lower dir fh when decoding an overlay
 +	 * file handle of a merge dir. Whiteout index entries are going to be
 +	 * used as an indication that an exported overlay file handle should
 +	 * be treated as stale (i.e. after unlink of the overlay inode).
 +	 * We don't know the verification rules for directory and whiteout
 +	 * index entries, because they have not been implemented yet, so return
 +	 * EINVAL if those entries are found to abort the mount to avoid
 +	 * corrupting an index that was created by a newer kernel.
 +	 */
++=======
+ 	/* Cleanup leftover from index create/cleanup attempt */
+ 	err = -ESTALE;
+ 	if (ovl_is_temp_index(index))
+ 		goto fail;
+ 
++>>>>>>> 9ee60ce24911 (ovl: cleanup temp index entries)
  	err = -EINVAL;
 +	if (d_is_dir(index) || ovl_is_whiteout(index))
 +		goto fail;
 +
  	if (index->d_name.len < sizeof(struct ovl_fh)*2)
  		goto fail;
  
* Unmerged path fs/overlayfs/namei.c
