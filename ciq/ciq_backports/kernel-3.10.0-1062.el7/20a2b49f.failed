tcp: properly scale window in tcp_v[46]_reqsk_send_ack()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 20a2b49fc538540819a0c552877086548cff8d8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/20a2b49f.failed

When sending an ack in SYN_RECV state, we must scale the offered
window if wscale option was negotiated and accepted.

Tested:
 Following packetdrill test demonstrates the issue :

0.000 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3
+0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0

+0 bind(3, ..., ...) = 0
+0 listen(3, 1) = 0

// Establish a connection.
+0 < S 0:0(0) win 20000 <mss 1000,sackOK,wscale 7, nop, TS val 100 ecr 0>
+0 > S. 0:0(0) ack 1 win 28960 <mss 1460,sackOK, TS val 100 ecr 100, nop, wscale 7>

+0 < . 1:11(10) ack 1 win 156 <nop,nop,TS val 99 ecr 100>
// check that window is properly scaled !
+0 > . 1:1(0) ack 1 win 226 <nop,nop,TS val 200 ecr 100>

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Yuchung Cheng <ycheng@google.com>
	Cc: Neal Cardwell <ncardwell@google.com>
	Acked-by: Yuchung Cheng <ycheng@google.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 20a2b49fc538540819a0c552877086548cff8d8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_ipv4.c
#	net/ipv6/tcp_ipv6.c
diff --cc net/ipv4/tcp_ipv4.c
index 2efc1b2188fd,7158d4f8dae4..000000000000
--- a/net/ipv4/tcp_ipv4.c
+++ b/net/ipv4/tcp_ipv4.c
@@@ -820,9 -811,17 +820,23 @@@ static void tcp_v4_reqsk_send_ack(struc
  	/* sk->sk_state == TCP_LISTEN -> for regular TCP_SYN_RECV
  	 * sk->sk_state == TCP_SYN_RECV -> for Fast Open.
  	 */
++<<<<<<< HEAD
 +	tcp_v4_send_ack(skb, (sk->sk_state == TCP_LISTEN) ?
 +			tcp_rsk(req)->snt_isn + 1 : tcp_sk(sk)->snd_nxt,
 +			tcp_rsk(req)->rcv_nxt, req->rcv_wnd,
++=======
+ 	u32 seq = (sk->sk_state == TCP_LISTEN) ? tcp_rsk(req)->snt_isn + 1 :
+ 					     tcp_sk(sk)->snd_nxt;
+ 
+ 	/* RFC 7323 2.3
+ 	 * The window field (SEG.WND) of every outgoing segment, with the
+ 	 * exception of <SYN> segments, MUST be right-shifted by
+ 	 * Rcv.Wind.Shift bits:
+ 	 */
+ 	tcp_v4_send_ack(sock_net(sk), skb, seq,
+ 			tcp_rsk(req)->rcv_nxt,
+ 			req->rsk_rcv_wnd >> inet_rsk(req)->rcv_wscale,
++>>>>>>> 20a2b49fc538 (tcp: properly scale window in tcp_v[46]_reqsk_send_ack())
  			tcp_time_stamp,
  			req->ts_recent,
  			0,
diff --cc net/ipv6/tcp_ipv6.c
index eafbe1403cdc,94f4f89d73e7..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -990,9 -944,15 +990,19 @@@ static void tcp_v6_reqsk_send_ack(struc
  	/* sk->sk_state == TCP_LISTEN -> for regular TCP_SYN_RECV
  	 * sk->sk_state == TCP_SYN_RECV -> for Fast Open.
  	 */
+ 	/* RFC 7323 2.3
+ 	 * The window field (SEG.WND) of every outgoing segment, with the
+ 	 * exception of <SYN> segments, MUST be right-shifted by
+ 	 * Rcv.Wind.Shift bits:
+ 	 */
  	tcp_v6_send_ack(sk, skb, (sk->sk_state == TCP_LISTEN) ?
  			tcp_rsk(req)->snt_isn + 1 : tcp_sk(sk)->snd_nxt,
++<<<<<<< HEAD
 +			tcp_rsk(req)->rcv_nxt, req->rcv_wnd,
++=======
+ 			tcp_rsk(req)->rcv_nxt,
+ 			req->rsk_rcv_wnd >> inet_rsk(req)->rcv_wscale,
++>>>>>>> 20a2b49fc538 (tcp: properly scale window in tcp_v[46]_reqsk_send_ack())
  			tcp_time_stamp, req->ts_recent, sk->sk_bound_dev_if,
  			tcp_v6_md5_do_lookup(sk, &ipv6_hdr(skb)->daddr),
  			0, 0);
* Unmerged path net/ipv4/tcp_ipv4.c
* Unmerged path net/ipv6/tcp_ipv6.c
