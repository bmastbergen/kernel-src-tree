fuse: don't need GETATTR after every READ

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 802dc0497be2b538ca4300704b45b59bffe29585
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/802dc049.failed

If 'auto_inval_data' mode is active, then fuse_file_read_iter() will call
fuse_update_attributes(), which will check the attribute validity and send
a GETATTR request if some of the attributes are no longer valid.  The page
cache is then invalidated if the size or mtime have changed.

Then, if a READ request was sent and reply received (which is the case if
the data wasn't cached yet, or if the file is opened for O_DIRECT), the
atime attribute is invalidated.

This will result in the next read() also triggering a GETATTR, ...

This can be fixed by only sending GETATTR if the mode or size are invalid,
we don't need to do a refresh if only atime is invalid.

More generally, none of the callers of fuse_update_attributes() need an
up-to-date atime value, so for now just remove STATX_ATIME from the request
mask when attributes are updated for internal use.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 802dc0497be2b538ca4300704b45b59bffe29585)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/dir.c
diff --cc fs/fuse/dir.c
index 74f2476dec4f,7b8f63e7489f..000000000000
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@@ -987,30 -921,40 +987,38 @@@ static int fuse_do_getattr(struct inod
  	return err;
  }
  
 -static int fuse_update_get_attr(struct inode *inode, struct file *file,
 -				struct kstat *stat, u32 request_mask,
 -				unsigned int flags)
 +int fuse_update_attributes(struct inode *inode, struct kstat *stat,
 +			   struct file *file, bool *refreshed)
  {
  	struct fuse_inode *fi = get_fuse_inode(inode);
 -	int err = 0;
 -	bool sync;
 -
 -	if (flags & AT_STATX_FORCE_SYNC)
 -		sync = true;
 -	else if (flags & AT_STATX_DONT_SYNC)
 -		sync = false;
 -	else if (request_mask & READ_ONCE(fi->inval_mask))
 -		sync = true;
 -	else
 -		sync = time_before64(fi->i_time, get_jiffies_64());
 +	int err;
 +	bool r;
  
 -	if (sync) {
 -		forget_all_cached_acls(inode);
 +	if (time_before64(fi->i_time, get_jiffies_64())) {
 +		r = true;
  		err = fuse_do_getattr(inode, stat, file);
 -	} else if (stat) {
 -		generic_fillattr(inode, stat);
 -		stat->mode = fi->orig_i_mode;
 -		stat->ino = fi->orig_ino;
 +	} else {
 +		r = false;
 +		err = 0;
 +		if (stat) {
 +			generic_fillattr(inode, stat);
 +			stat->mode = fi->orig_i_mode;
 +			stat->ino = fi->orig_ino;
 +		}
  	}
  
 -	return err;
 -}
 +	if (refreshed != NULL)
 +		*refreshed = r;
  
++<<<<<<< HEAD
 +	return err;
++=======
+ int fuse_update_attributes(struct inode *inode, struct file *file)
+ {
+ 	/* Do *not* need to get atime for internal purposes */
+ 	return fuse_update_get_attr(inode, file, NULL,
+ 				    STATX_BASIC_STATS & ~STATX_ATIME, 0);
++>>>>>>> 802dc0497be2 (fuse: don't need GETATTR after every READ)
  }
  
  int fuse_reverse_inval_entry(struct super_block *sb, u64 parent_nodeid,
* Unmerged path fs/fuse/dir.c
