nvme: register ns_id attributes as default sysfs groups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [nvme] register ns_id attributes as default sysfs groups (Ming Lei) [1635708]
Rebuild_FUZZ: 94.23%
commit-author Hannes Reinecke <hare@suse.de>
commit 33b14f67a4e1eabd219fd6543da8f15ed86b641c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/33b14f67.failed

We should be registering the ns_id attribute as default sysfs
attribute groups, otherwise we have a race condition between
the uevent and the attributes appearing in sysfs.

	Suggested-by: Bart van Assche <bvanassche@acm.org>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 33b14f67a4e1eabd219fd6543da8f15ed86b641c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
#	drivers/nvme/host/lightnvm.c
#	drivers/nvme/host/multipath.c
#	drivers/nvme/host/nvme.h
diff --cc drivers/nvme/host/core.c
index cb5cd8fffb1e,e0a9e1c5b30e..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -2218,11 -2728,20 +2218,19 @@@ static umode_t nvme_ns_attrs_are_visibl
  	return a->mode;
  }
  
 -const struct attribute_group nvme_ns_id_attr_group = {
 -	.attrs		= nvme_ns_id_attrs,
 -	.is_visible	= nvme_ns_id_attrs_are_visible,
 +static const struct attribute_group nvme_ns_attr_group = {
 +	.attrs		= nvme_ns_attrs,
 +	.is_visible	= nvme_ns_attrs_are_visible,
  };
  
+ const struct attribute_group *nvme_ns_id_attr_groups[] = {
+ 	&nvme_ns_id_attr_group,
+ #ifdef CONFIG_NVM
+ 	&nvme_nvm_attr_group,
+ #endif
+ 	NULL,
+ };
+ 
  #define nvme_show_str_function(field)						\
  static ssize_t  field##_show(struct device *dev,				\
  			    struct device_attribute *attr, char *buf)		\
@@@ -2428,18 -3107,21 +2436,27 @@@ static void nvme_alloc_ns(struct nvme_c
  
  	nvme_get_ctrl(ctrl);
  
++<<<<<<< HEAD
 +	add_disk(ns->disk);
 +	if (sysfs_create_group(&disk_to_dev(ns->disk)->kobj,
 +					&nvme_ns_attr_group))
 +		pr_warn("%s: failed to create sysfs group for identification\n",
 +			ns->disk->disk_name);
++=======
+ 	device_add_disk(ctrl->device, ns->disk, nvme_ns_id_attr_groups);
+ 
+ 	nvme_mpath_add_disk(ns, id);
+ 	nvme_fault_inject_init(ns);
+ 	kfree(id);
+ 
++>>>>>>> 33b14f67a4e1 (nvme: register ns_id attributes as default sysfs groups)
  	return;
 - out_unlink_ns:
 -	mutex_lock(&ctrl->subsys->lock);
 -	list_del_rcu(&ns->siblings);
 -	mutex_unlock(&ctrl->subsys->lock);
 - out_free_id:
 -	kfree(id);
 + out_free_disk:
 +	kfree(disk);
   out_free_queue:
  	blk_cleanup_queue(ns->queue);
 + out_release_instance:
 +	ida_simple_remove(&ctrl->ns_ida, ns->instance);
   out_free_ns:
  	kfree(ns);
  }
@@@ -2449,9 -3131,8 +2466,14 @@@ static void nvme_ns_remove(struct nvme_
  	if (test_and_set_bit(NVME_NS_REMOVING, &ns->flags))
  		return;
  
++<<<<<<< HEAD
 +	if (ns->disk->flags & GENHD_FL_UP) {
 +		sysfs_remove_group(&disk_to_dev(ns->disk)->kobj,
 +					&nvme_ns_attr_group);
++=======
+ 	nvme_fault_inject_fini(ns);
+ 	if (ns->disk && ns->disk->flags & GENHD_FL_UP) {
++>>>>>>> 33b14f67a4e1 (nvme: register ns_id attributes as default sysfs groups)
  		del_gendisk(ns->disk);
  		blk_cleanup_queue(ns->queue);
  		if (blk_get_integrity(ns->disk))
diff --cc drivers/nvme/host/nvme.h
index 1df52e285852,2503f8fd54da..000000000000
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@@ -351,14 -456,123 +351,131 @@@ int nvme_reset_ctrl_sync(struct nvme_ct
  int nvme_delete_ctrl(struct nvme_ctrl *ctrl);
  int nvme_delete_ctrl_sync(struct nvme_ctrl *ctrl);
  
 -int nvme_get_log(struct nvme_ctrl *ctrl, u32 nsid, u8 log_page, u8 lsp,
 -		void *log, size_t size, u64 offset);
 +int nvme_get_log_ext(struct nvme_ctrl *ctrl, struct nvme_ns *ns,
 +		u8 log_page, void *log, size_t size, u64 offset);
 +
++<<<<<<< HEAD
 +struct sg_io_hdr;
  
 +int nvme_sg_io(struct nvme_ns *ns, struct sg_io_hdr __user *u_hdr);
 +int nvme_sg_io32(struct nvme_ns *ns, unsigned long arg);
 +int nvme_sg_get_version_num(int __user *ip);
++=======
+ extern const struct attribute_group *nvme_ns_id_attr_groups[];
+ extern const struct block_device_operations nvme_ns_head_ops;
+ 
+ #ifdef CONFIG_NVME_MULTIPATH
+ bool nvme_ctrl_use_ana(struct nvme_ctrl *ctrl);
+ void nvme_set_disk_name(char *disk_name, struct nvme_ns *ns,
+ 			struct nvme_ctrl *ctrl, int *flags);
+ void nvme_failover_req(struct request *req);
+ void nvme_kick_requeue_lists(struct nvme_ctrl *ctrl);
+ int nvme_mpath_alloc_disk(struct nvme_ctrl *ctrl,struct nvme_ns_head *head);
+ void nvme_mpath_add_disk(struct nvme_ns *ns, struct nvme_id_ns *id);
+ void nvme_mpath_remove_disk(struct nvme_ns_head *head);
+ int nvme_mpath_init(struct nvme_ctrl *ctrl, struct nvme_id_ctrl *id);
+ void nvme_mpath_uninit(struct nvme_ctrl *ctrl);
+ void nvme_mpath_stop(struct nvme_ctrl *ctrl);
+ 
+ static inline void nvme_mpath_clear_current_path(struct nvme_ns *ns)
+ {
+ 	struct nvme_ns_head *head = ns->head;
+ 
+ 	if (head && ns == rcu_access_pointer(head->current_path))
+ 		rcu_assign_pointer(head->current_path, NULL);
+ }
+ struct nvme_ns *nvme_find_path(struct nvme_ns_head *head);
+ 
+ static inline void nvme_mpath_check_last_path(struct nvme_ns *ns)
+ {
+ 	struct nvme_ns_head *head = ns->head;
+ 
+ 	if (head->disk && list_empty(&head->list))
+ 		kblockd_schedule_work(&head->requeue_work);
+ }
+ 
+ extern struct device_attribute dev_attr_ana_grpid;
+ extern struct device_attribute dev_attr_ana_state;
+ 
+ #else
+ static inline bool nvme_ctrl_use_ana(struct nvme_ctrl *ctrl)
+ {
+ 	return false;
+ }
+ /*
+  * Without the multipath code enabled, multiple controller per subsystems are
+  * visible as devices and thus we cannot use the subsystem instance.
+  */
+ static inline void nvme_set_disk_name(char *disk_name, struct nvme_ns *ns,
+ 				      struct nvme_ctrl *ctrl, int *flags)
+ {
+ 	sprintf(disk_name, "nvme%dn%d", ctrl->instance, ns->head->instance);
+ }
+ 
+ static inline void nvme_failover_req(struct request *req)
+ {
+ }
+ static inline void nvme_kick_requeue_lists(struct nvme_ctrl *ctrl)
+ {
+ }
+ static inline int nvme_mpath_alloc_disk(struct nvme_ctrl *ctrl,
+ 		struct nvme_ns_head *head)
+ {
+ 	return 0;
+ }
+ static inline void nvme_mpath_add_disk(struct nvme_ns *ns,
+ 		struct nvme_id_ns *id)
+ {
+ }
+ static inline void nvme_mpath_remove_disk(struct nvme_ns_head *head)
+ {
+ }
+ static inline void nvme_mpath_clear_current_path(struct nvme_ns *ns)
+ {
+ }
+ static inline void nvme_mpath_check_last_path(struct nvme_ns *ns)
+ {
+ }
+ static inline int nvme_mpath_init(struct nvme_ctrl *ctrl,
+ 		struct nvme_id_ctrl *id)
+ {
+ 	return 0;
+ }
+ static inline void nvme_mpath_uninit(struct nvme_ctrl *ctrl)
+ {
+ }
+ static inline void nvme_mpath_stop(struct nvme_ctrl *ctrl)
+ {
+ }
+ #endif /* CONFIG_NVME_MULTIPATH */
+ 
+ #ifdef CONFIG_NVM
+ void nvme_nvm_update_nvm_info(struct nvme_ns *ns);
+ int nvme_nvm_register(struct nvme_ns *ns, char *disk_name, int node);
+ void nvme_nvm_unregister(struct nvme_ns *ns);
+ extern const struct attribute_group nvme_nvm_attr_group;
+ int nvme_nvm_ioctl(struct nvme_ns *ns, unsigned int cmd, unsigned long arg);
+ #else
+ static inline void nvme_nvm_update_nvm_info(struct nvme_ns *ns) {};
+ static inline int nvme_nvm_register(struct nvme_ns *ns, char *disk_name,
+ 				    int node)
+ {
+ 	return 0;
+ }
+ 
+ static inline void nvme_nvm_unregister(struct nvme_ns *ns) {};
+ static inline int nvme_nvm_ioctl(struct nvme_ns *ns, unsigned int cmd,
+ 							unsigned long arg)
+ {
+ 	return -ENOTTY;
+ }
+ #endif /* CONFIG_NVM */
+ 
+ static inline struct nvme_ns *nvme_get_ns_from_dev(struct device *dev)
+ {
+ 	return dev_to_disk(dev)->private_data;
+ }
++>>>>>>> 33b14f67a4e1 (nvme: register ns_id attributes as default sysfs groups)
  
  int __init nvme_core_init(void);
  void nvme_core_exit(void);
* Unmerged path drivers/nvme/host/lightnvm.c
* Unmerged path drivers/nvme/host/multipath.c
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/lightnvm.c
* Unmerged path drivers/nvme/host/multipath.c
* Unmerged path drivers/nvme/host/nvme.h
