x86/speculation: Support 'mitigations=' cmdline option

jira LE-1907
cve CVE-2019-11091
cve CVE-2018-12130
cve CVE-2018-12127
cve CVE-2018-12126
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit d68be4c4d31295ff6ae34a8ddfaa4c1a8ff42812
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d68be4c4.failed

Configure x86 runtime CPU speculation bug mitigations in accordance with
the 'mitigations=' cmdline option.  This affects Meltdown, Spectre v2,
Speculative Store Bypass, and L1TF.

The default behavior is unchanged.

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Jiri Kosina <jkosina@suse.cz> (on x86)
	Reviewed-by: Jiri Kosina <jkosina@suse.cz>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: "H . Peter Anvin" <hpa@zytor.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Jiri Kosina <jikos@kernel.org>
	Cc: Waiman Long <longman@redhat.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Jon Masters <jcm@redhat.com>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: linuxppc-dev@lists.ozlabs.org
	Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: linux-s390@vger.kernel.org
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: linux-arm-kernel@lists.infradead.org
	Cc: linux-arch@vger.kernel.org
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Tyler Hicks <tyhicks@canonical.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Steven Price <steven.price@arm.com>
	Cc: Phil Auld <pauld@redhat.com>
Link: https://lkml.kernel.org/r/6616d0ae169308516cfdf5216bedd169f8a8291b.1555085500.git.jpoimboe@redhat.com

(cherry picked from commit d68be4c4d31295ff6ae34a8ddfaa4c1a8ff42812)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/kernel-parameters.txt
#	arch/x86/kernel/cpu/bugs.c
#	arch/x86/mm/pti.c
diff --cc Documentation/kernel-parameters.txt
index f6852ae416ce,779ddeb2929c..000000000000
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@@ -1989,6 -2513,36 +1989,39 @@@ bytes respectively. Such letter suffixe
  			in the "bleeding edge" mini2440 support kernel at
  			http://repo.or.cz/w/linux-2.6/mini2440.git
  
++<<<<<<< HEAD:Documentation/kernel-parameters.txt
++=======
+ 	mitigations=
+ 			[X86] Control optional mitigations for CPU
+ 			vulnerabilities.  This is a set of curated,
+ 			arch-independent options, each of which is an
+ 			aggregation of existing arch-specific options.
+ 
+ 			off
+ 				Disable all optional CPU mitigations.  This
+ 				improves system performance, but it may also
+ 				expose users to several CPU vulnerabilities.
+ 				Equivalent to: nopti [X86]
+ 					       nospectre_v2 [X86]
+ 					       spectre_v2_user=off [X86]
+ 					       spec_store_bypass_disable=off [X86]
+ 					       l1tf=off [X86]
+ 
+ 			auto (default)
+ 				Mitigate all CPU vulnerabilities, but leave SMT
+ 				enabled, even if it's vulnerable.  This is for
+ 				users who don't want to be surprised by SMT
+ 				getting disabled across kernel upgrades, or who
+ 				have other ways of avoiding SMT-based attacks.
+ 				Equivalent to: (default behavior)
+ 
+ 			auto,nosmt
+ 				Mitigate all CPU vulnerabilities, disabling SMT
+ 				if needed.  This is for users who always want to
+ 				be fully mitigated, even if it means losing SMT.
+ 				Equivalent to: l1tf=flush,nosmt [X86]
+ 
++>>>>>>> d68be4c4d312 (x86/speculation: Support 'mitigations=' cmdline option):Documentation/admin-guide/kernel-parameters.txt
  	mminit_loglevel=
  			[KNL] When CONFIG_DEBUG_MEMORY_INIT is set, this
  			parameter allows control of the logging verbosity for
diff --cc arch/x86/kernel/cpu/bugs.c
index 6ec1d2da76d1,435c078c2948..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -173,16 -319,171 +173,177 @@@ static enum spectre_v2_mitigation_cmd s
  		}
  	}
  
 -	pr_err("Unknown user space protection option (%s). Switching to AUTO select\n", arg);
 -	return SPECTRE_V2_USER_CMD_AUTO;
 +	if (!cmdline_find_option_bool(boot_command_line, "nospectre_v2"))
 +		return SPECTRE_V2_CMD_AUTO;
 +disable:
 +	return SPECTRE_V2_CMD_NONE;
  }
  
 -static void __init
 -spectre_v2_user_select_mitigation(enum spectre_v2_mitigation_cmd v2_cmd)
 +void __spectre_v2_select_mitigation(void)
  {
++<<<<<<< HEAD
 +	const bool full_retpoline = IS_ENABLED(CONFIG_RETPOLINE) && retp_compiler();
 +	enum spectre_v2_mitigation_cmd cmd = spectre_v2_cmd;
++=======
+ 	enum spectre_v2_user_mitigation mode = SPECTRE_V2_USER_NONE;
+ 	bool smt_possible = IS_ENABLED(CONFIG_SMP);
+ 	enum spectre_v2_user_cmd cmd;
+ 
+ 	if (!boot_cpu_has(X86_FEATURE_IBPB) && !boot_cpu_has(X86_FEATURE_STIBP))
+ 		return;
+ 
+ 	if (cpu_smt_control == CPU_SMT_FORCE_DISABLED ||
+ 	    cpu_smt_control == CPU_SMT_NOT_SUPPORTED)
+ 		smt_possible = false;
+ 
+ 	cmd = spectre_v2_parse_user_cmdline(v2_cmd);
+ 	switch (cmd) {
+ 	case SPECTRE_V2_USER_CMD_NONE:
+ 		goto set_mode;
+ 	case SPECTRE_V2_USER_CMD_FORCE:
+ 		mode = SPECTRE_V2_USER_STRICT;
+ 		break;
+ 	case SPECTRE_V2_USER_CMD_PRCTL:
+ 	case SPECTRE_V2_USER_CMD_PRCTL_IBPB:
+ 		mode = SPECTRE_V2_USER_PRCTL;
+ 		break;
+ 	case SPECTRE_V2_USER_CMD_AUTO:
+ 	case SPECTRE_V2_USER_CMD_SECCOMP:
+ 	case SPECTRE_V2_USER_CMD_SECCOMP_IBPB:
+ 		if (IS_ENABLED(CONFIG_SECCOMP))
+ 			mode = SPECTRE_V2_USER_SECCOMP;
+ 		else
+ 			mode = SPECTRE_V2_USER_PRCTL;
+ 		break;
+ 	}
+ 
+ 	/*
+ 	 * At this point, an STIBP mode other than "off" has been set.
+ 	 * If STIBP support is not being forced, check if STIBP always-on
+ 	 * is preferred.
+ 	 */
+ 	if (mode != SPECTRE_V2_USER_STRICT &&
+ 	    boot_cpu_has(X86_FEATURE_AMD_STIBP_ALWAYS_ON))
+ 		mode = SPECTRE_V2_USER_STRICT_PREFERRED;
+ 
+ 	/* Initialize Indirect Branch Prediction Barrier */
+ 	if (boot_cpu_has(X86_FEATURE_IBPB)) {
+ 		setup_force_cpu_cap(X86_FEATURE_USE_IBPB);
+ 
+ 		switch (cmd) {
+ 		case SPECTRE_V2_USER_CMD_FORCE:
+ 		case SPECTRE_V2_USER_CMD_PRCTL_IBPB:
+ 		case SPECTRE_V2_USER_CMD_SECCOMP_IBPB:
+ 			static_branch_enable(&switch_mm_always_ibpb);
+ 			break;
+ 		case SPECTRE_V2_USER_CMD_PRCTL:
+ 		case SPECTRE_V2_USER_CMD_AUTO:
+ 		case SPECTRE_V2_USER_CMD_SECCOMP:
+ 			static_branch_enable(&switch_mm_cond_ibpb);
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 
+ 		pr_info("mitigation: Enabling %s Indirect Branch Prediction Barrier\n",
+ 			static_key_enabled(&switch_mm_always_ibpb) ?
+ 			"always-on" : "conditional");
+ 	}
+ 
+ 	/* If enhanced IBRS is enabled no STIBP required */
+ 	if (spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)
+ 		return;
+ 
+ 	/*
+ 	 * If SMT is not possible or STIBP is not available clear the STIBP
+ 	 * mode.
+ 	 */
+ 	if (!smt_possible || !boot_cpu_has(X86_FEATURE_STIBP))
+ 		mode = SPECTRE_V2_USER_NONE;
+ set_mode:
+ 	spectre_v2_user = mode;
+ 	/* Only print the STIBP mode when SMT possible */
+ 	if (smt_possible)
+ 		pr_info("%s\n", spectre_v2_user_strings[mode]);
+ }
+ 
+ static const char * const spectre_v2_strings[] = {
+ 	[SPECTRE_V2_NONE]			= "Vulnerable",
+ 	[SPECTRE_V2_RETPOLINE_GENERIC]		= "Mitigation: Full generic retpoline",
+ 	[SPECTRE_V2_RETPOLINE_AMD]		= "Mitigation: Full AMD retpoline",
+ 	[SPECTRE_V2_IBRS_ENHANCED]		= "Mitigation: Enhanced IBRS",
+ };
+ 
+ static const struct {
+ 	const char *option;
+ 	enum spectre_v2_mitigation_cmd cmd;
+ 	bool secure;
+ } mitigation_options[] __initdata = {
+ 	{ "off",		SPECTRE_V2_CMD_NONE,		  false },
+ 	{ "on",			SPECTRE_V2_CMD_FORCE,		  true  },
+ 	{ "retpoline",		SPECTRE_V2_CMD_RETPOLINE,	  false },
+ 	{ "retpoline,amd",	SPECTRE_V2_CMD_RETPOLINE_AMD,	  false },
+ 	{ "retpoline,generic",	SPECTRE_V2_CMD_RETPOLINE_GENERIC, false },
+ 	{ "auto",		SPECTRE_V2_CMD_AUTO,		  false },
+ };
+ 
+ static void __init spec_v2_print_cond(const char *reason, bool secure)
+ {
+ 	if (boot_cpu_has_bug(X86_BUG_SPECTRE_V2) != secure)
+ 		pr_info("%s selected on command line.\n", reason);
+ }
+ 
+ static enum spectre_v2_mitigation_cmd __init spectre_v2_parse_cmdline(void)
+ {
+ 	enum spectre_v2_mitigation_cmd cmd = SPECTRE_V2_CMD_AUTO;
+ 	char arg[20];
+ 	int ret, i;
+ 
+ 	if (cmdline_find_option_bool(boot_command_line, "nospectre_v2") ||
+ 	    cpu_mitigations_off())
+ 		return SPECTRE_V2_CMD_NONE;
+ 
+ 	ret = cmdline_find_option(boot_command_line, "spectre_v2", arg, sizeof(arg));
+ 	if (ret < 0)
+ 		return SPECTRE_V2_CMD_AUTO;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(mitigation_options); i++) {
+ 		if (!match_option(arg, ret, mitigation_options[i].option))
+ 			continue;
+ 		cmd = mitigation_options[i].cmd;
+ 		break;
+ 	}
+ 
+ 	if (i >= ARRAY_SIZE(mitigation_options)) {
+ 		pr_err("unknown option (%s). Switching to AUTO select\n", arg);
+ 		return SPECTRE_V2_CMD_AUTO;
+ 	}
+ 
+ 	if ((cmd == SPECTRE_V2_CMD_RETPOLINE ||
+ 	     cmd == SPECTRE_V2_CMD_RETPOLINE_AMD ||
+ 	     cmd == SPECTRE_V2_CMD_RETPOLINE_GENERIC) &&
+ 	    !IS_ENABLED(CONFIG_RETPOLINE)) {
+ 		pr_err("%s selected but not compiled in. Switching to AUTO select\n", mitigation_options[i].option);
+ 		return SPECTRE_V2_CMD_AUTO;
+ 	}
+ 
+ 	if (cmd == SPECTRE_V2_CMD_RETPOLINE_AMD &&
+ 	    boot_cpu_data.x86_vendor != X86_VENDOR_HYGON &&
+ 	    boot_cpu_data.x86_vendor != X86_VENDOR_AMD) {
+ 		pr_err("retpoline,amd selected but CPU is not AMD. Switching to AUTO select\n");
+ 		return SPECTRE_V2_CMD_AUTO;
+ 	}
+ 
+ 	spec_v2_print_cond(mitigation_options[i].option,
+ 			   mitigation_options[i].secure);
+ 	return cmd;
+ }
+ 
+ static void __init spectre_v2_select_mitigation(void)
+ {
+ 	enum spectre_v2_mitigation_cmd cmd = spectre_v2_parse_cmdline();
+ 	enum spectre_v2_mitigation mode = SPECTRE_V2_NONE;
++>>>>>>> d68be4c4d312 (x86/speculation: Support 'mitigations=' cmdline option)
  
  	/*
  	 * If the CPU is not affected and the command line mode is NONE or AUTO
@@@ -288,9 -673,10 +449,14 @@@ static enum ssb_mitigation_cmd __init _
  	char arg[20];
  	int ret, i;
  
++<<<<<<< HEAD
 +	if (cmdline_find_option_bool(boot_command_line, "nospec_store_bypass_disable"))
++=======
+ 	if (cmdline_find_option_bool(boot_command_line, "nospec_store_bypass_disable") ||
+ 	    cpu_mitigations_off()) {
++>>>>>>> d68be4c4d312 (x86/speculation: Support 'mitigations=' cmdline option)
  		return SPEC_STORE_BYPASS_CMD_NONE;
 -	} else {
 +	else {
  		ret = cmdline_find_option(boot_command_line, "spec_store_bypass_disable",
  					  arg, sizeof(arg));
  		if (ret < 0)
@@@ -514,6 -998,13 +680,16 @@@ static void __init l1tf_select_mitigati
  	if (!boot_cpu_has_bug(X86_BUG_L1TF))
  		return;
  
++<<<<<<< HEAD
++=======
+ 	if (cpu_mitigations_off())
+ 		l1tf_mitigation = L1TF_MITIGATION_OFF;
+ 	else if (cpu_mitigations_auto_nosmt())
+ 		l1tf_mitigation = L1TF_MITIGATION_FLUSH_NOSMT;
+ 
+ 	override_cache_bits(&boot_cpu_data);
+ 
++>>>>>>> d68be4c4d312 (x86/speculation: Support 'mitigations=' cmdline option)
  	switch (l1tf_mitigation) {
  	case L1TF_MITIGATION_OFF:
  	case L1TF_MITIGATION_FLUSH_NOWARN:
* Unmerged path arch/x86/mm/pti.c
* Unmerged path Documentation/kernel-parameters.txt
* Unmerged path arch/x86/kernel/cpu/bugs.c
* Unmerged path arch/x86/mm/pti.c
