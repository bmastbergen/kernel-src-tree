net: phy: remove the indirect MMD read/write methods

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] phy: remove the indirect MMD read/write methods (Ivan Vecera) [1655590]
Rebuild_FUZZ: 94.95%
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit 3b85d8df2655a4a5831ee8233108b53e69efa1ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3b85d8df.failed

Remove the indirect MMD read/write methods which are now no longer
necessary.

	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3b85d8df2655a4a5831ee8233108b53e69efa1ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phy-core.c
#	include/linux/phy.h
diff --cc include/linux/phy.h
index 9542c61131f8,2efca6b39fba..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -523,16 -578,63 +523,66 @@@ struct phy_driver 
  	/* See set_wol, but for checking whether Wake on LAN is enabled. */
  	void (*get_wol)(struct phy_device *dev, struct ethtool_wolinfo *wol);
  
 -	/*
 -	 * Called to inform a PHY device driver when the core is about to
 -	 * change the link state. This callback is supposed to be used as
 -	 * fixup hook for drivers that need to take action when the link
 -	 * state changes. Drivers are by no means allowed to mess with the
 -	 * PHY device structure in their implementations.
 +	struct device_driver driver;
 +
 +	/* Determines the auto negotiation result */
 +	RH_KABI_EXTEND(int (*aneg_done)(struct phy_device *phydev))
 +
 +	/* PHY API is not on symbol whitelist now so we can extend
 +	 * this structure directly via simple RH_KABI_EXTEND.
  	 */
++<<<<<<< HEAD
++=======
+ 	void (*link_change_notify)(struct phy_device *dev);
+ 
+ 	/*
+ 	 * Phy specific driver override for reading a MMD register.
+ 	 * This function is optional for PHY specific drivers.  When
+ 	 * not provided, the default MMD read function will be used
+ 	 * by phy_read_mmd(), which will use either a direct read for
+ 	 * Clause 45 PHYs or an indirect read for Clause 22 PHYs.
+ 	 *  devnum is the MMD device number within the PHY device,
+ 	 *  regnum is the register within the selected MMD device.
+ 	 */
+ 	int (*read_mmd)(struct phy_device *dev, int devnum, u16 regnum);
+ 
+ 	/*
+ 	 * Phy specific driver override for writing a MMD register.
+ 	 * This function is optional for PHY specific drivers.  When
+ 	 * not provided, the default MMD write function will be used
+ 	 * by phy_write_mmd(), which will use either a direct write for
+ 	 * Clause 45 PHYs, or an indirect write for Clause 22 PHYs.
+ 	 *  devnum is the MMD device number within the PHY device,
+ 	 *  regnum is the register within the selected MMD device.
+ 	 *  val is the value to be written.
+ 	 */
+ 	int (*write_mmd)(struct phy_device *dev, int devnum, u16 regnum,
+ 			 u16 val);
+ 
+ 	/* Get the size and type of the eeprom contained within a plug-in
+ 	 * module */
+ 	int (*module_info)(struct phy_device *dev,
+ 			   struct ethtool_modinfo *modinfo);
+ 
+ 	/* Get the eeprom information from the plug-in module */
+ 	int (*module_eeprom)(struct phy_device *dev,
+ 			     struct ethtool_eeprom *ee, u8 *data);
+ 
+ 	/* Get statistics from the phy using ethtool */
+ 	int (*get_sset_count)(struct phy_device *dev);
+ 	void (*get_strings)(struct phy_device *dev, u8 *data);
+ 	void (*get_stats)(struct phy_device *dev,
+ 			  struct ethtool_stats *stats, u64 *data);
+ 
+ 	/* Get and Set PHY tunables */
+ 	int (*get_tunable)(struct phy_device *dev,
+ 			   struct ethtool_tunable *tuna, void *data);
+ 	int (*set_tunable)(struct phy_device *dev,
+ 			    struct ethtool_tunable *tuna,
+ 			    const void *data);
++>>>>>>> 3b85d8df2655 (net: phy: remove the indirect MMD read/write methods)
  };
 -#define to_phy_driver(d) container_of(to_mdio_common_driver(d),		\
 -				      struct phy_driver, mdiodrv)
 +#define to_phy_driver(d) container_of(d, struct phy_driver, driver)
  
  #define PHY_ANY_ID "MATCH ANY PHY"
  #define PHY_ANY_UID 0xffffffff
@@@ -555,15 -657,8 +605,18 @@@ struct phy_fixup 
   *
   * Same rules as for phy_read();
   */
 -int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum);
 +static inline int phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum)
 +{
 +	if (!phydev->is_c45)
 +		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	return mdiobus_read(phydev->bus, phydev->addr,
 +			    MII_ADDR_C45 | (devad << 16) | (regnum & 0xffff));
 +}
 +
++=======
++>>>>>>> 3b85d8df2655 (net: phy: remove the indirect MMD read/write methods)
  /**
   * phy_read - Convenience function for reading a given PHY register
   * @phydev: the phy_device struct
@@@ -624,17 -740,8 +677,20 @@@ static inline bool phy_is_internal(stru
   *
   * Same rules as for phy_write();
   */
 -int phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val);
 +static inline int phy_write_mmd(struct phy_device *phydev, int devad,
 +				u32 regnum, u16 val)
 +{
 +	if (!phydev->is_c45)
 +		return -EOPNOTSUPP;
 +
++<<<<<<< HEAD
 +	regnum = MII_ADDR_C45 | ((devad & 0x1f) << 16) | (regnum & 0xffff);
  
 +	return mdiobus_write(phydev->bus, phydev->addr, regnum, val);
 +}
 +
++=======
++>>>>>>> 3b85d8df2655 (net: phy: remove the indirect MMD read/write methods)
  struct phy_device *phy_device_create(struct mii_bus *bus, int addr, int phy_id,
  				     bool is_c45,
  				     struct phy_c45_device_ids *c45_ids);
* Unmerged path drivers/net/phy/phy-core.c
* Unmerged path drivers/net/phy/phy-core.c
* Unmerged path include/linux/phy.h
