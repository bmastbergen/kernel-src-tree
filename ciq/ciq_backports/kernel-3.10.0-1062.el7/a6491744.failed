net/mlx5: Fix LAG requirement when CONFIG_MLX5_ESWITCH is off

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Fix LAG requirement when CONFIG_MLX5_ESWITCH is off (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 96.61%
commit-author Aviv Heller <avivh@mellanox.com>
commit a64917446eafc7212e962561622d697fce04e9a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a6491744.failed

If CONFIG_MLX5_ESWITCH is not defined, test for SR-IOV being disabled,
instead of calling e-switch LAG prereq routine.

Since LAG with SRIOV is allowed only when switchdev mode is on.

Fixes: eff849b2c669 ("net/mlx5: Allow/disallow LAG according to pre-req only")
	Signed-off-by: Aviv Heller <avivh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a64917446eafc7212e962561622d697fce04e9a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/lag.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/lag.c
index 10a4532b7144,3a6baed722d8..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag.c
@@@ -233,25 -241,85 +233,73 @@@ static int mlx5_create_lag(struct mlx5_
  	return err;
  }
  
 -static int mlx5_activate_lag(struct mlx5_lag *ldev,
 -			     struct lag_tracker *tracker,
 -			     u8 flags)
 +static void mlx5_activate_lag(struct mlx5_lag *ldev,
 +			      struct lag_tracker *tracker)
  {
 -	bool roce_lag = !!(flags & MLX5_LAG_FLAG_ROCE);
 -	struct mlx5_core_dev *dev0 = ldev->pf[0].dev;
 -	int err;
 -
 -	err = mlx5_create_lag(ldev, tracker);
 -	if (err) {
 -		if (roce_lag) {
 -			mlx5_core_err(dev0,
 -				      "Failed to activate RoCE LAG\n");
 -		} else {
 -			mlx5_core_err(dev0,
 -				      "Failed to activate VF LAG\n"
 -				      "Make sure all VFs are unbound prior to VF LAG activation or deactivation\n");
 -		}
 -		return err;
 -	}
 -
 -	ldev->flags |= flags;
 -	return 0;
 +	ldev->flags |= MLX5_LAG_FLAG_BONDED;
 +	mlx5_create_lag(ldev, tracker);
  }
  
 -static int mlx5_deactivate_lag(struct mlx5_lag *ldev)
 +static void mlx5_deactivate_lag(struct mlx5_lag *ldev)
  {
  	struct mlx5_core_dev *dev0 = ldev->pf[0].dev;
 -	bool roce_lag = __mlx5_lag_is_roce(ldev);
  	int err;
  
 -	ldev->flags &= ~MLX5_LAG_MODE_FLAGS;
 +	ldev->flags &= ~MLX5_LAG_FLAG_BONDED;
  
  	err = mlx5_cmd_destroy_lag(dev0);
++<<<<<<< HEAD
 +	if (err)
 +		mlx5_core_err(dev0,
 +			      "Failed to destroy LAG (%d)\n",
 +			      err);
++=======
+ 	if (err) {
+ 		if (roce_lag) {
+ 			mlx5_core_err(dev0,
+ 				      "Failed to deactivate RoCE LAG; driver restart required\n");
+ 		} else {
+ 			mlx5_core_err(dev0,
+ 				      "Failed to deactivate VF LAG; driver restart required\n"
+ 				      "Make sure all VFs are unbound prior to VF LAG activation or deactivation\n");
+ 		}
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static bool mlx5_lag_check_prereq(struct mlx5_lag *ldev)
+ {
+ 	if (!ldev->pf[0].dev || !ldev->pf[1].dev)
+ 		return false;
+ 
+ #ifdef CONFIG_MLX5_ESWITCH
+ 	return mlx5_esw_lag_prereq(ldev->pf[0].dev, ldev->pf[1].dev);
+ #else
+ 	return (!mlx5_sriov_is_enabled(ldev->pf[0].dev) &&
+ 		!mlx5_sriov_is_enabled(ldev->pf[1].dev));
+ #endif
+ }
+ 
+ static void mlx5_lag_add_ib_devices(struct mlx5_lag *ldev)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MLX5_MAX_PORTS; i++)
+ 		if (ldev->pf[i].dev)
+ 			mlx5_add_dev_by_protocol(ldev->pf[i].dev,
+ 						 MLX5_INTERFACE_PROTOCOL_IB);
+ }
+ 
+ static void mlx5_lag_remove_ib_devices(struct mlx5_lag *ldev)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MLX5_MAX_PORTS; i++)
+ 		if (ldev->pf[i].dev)
+ 			mlx5_remove_dev_by_protocol(ldev->pf[i].dev,
+ 						    MLX5_INTERFACE_PROTOCOL_IB);
++>>>>>>> a64917446eaf (net/mlx5: Fix LAG requirement when CONFIG_MLX5_ESWITCH is off)
  }
  
  static void mlx5_do_bond(struct mlx5_lag *ldev)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lag.c
