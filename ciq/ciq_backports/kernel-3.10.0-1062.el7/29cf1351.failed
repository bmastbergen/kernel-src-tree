RDMA/nldev: provide detailed PD information

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Steve Wise <swise@opengridcomputing.com>
commit 29cf1351d450f95957eb0ef2e8cc0c7765fc5785
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/29cf1351.failed

Implement the RDMA nldev netlink interface for dumping detailed PD
information.

	Reviewed-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 29cf1351d450f95957eb0ef2e8cc0c7765fc5785)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/nldev.c
#	include/uapi/rdma/rdma_netlink.h
diff --cc drivers/infiniband/core/nldev.c
index 67368b6847cb,192084c78352..000000000000
--- a/drivers/infiniband/core/nldev.c
+++ b/drivers/infiniband/core/nldev.c
@@@ -71,6 -73,28 +71,31 @@@ static const struct nla_policy nldev_po
  	[RDMA_NLDEV_ATTR_RES_PID]		= { .type = NLA_U32 },
  	[RDMA_NLDEV_ATTR_RES_KERN_NAME]		= { .type = NLA_NUL_STRING,
  						    .len = TASK_COMM_LEN },
++<<<<<<< HEAD
++=======
+ 	[RDMA_NLDEV_ATTR_RES_CM_ID]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CM_ID_ENTRY]	= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_PS]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_SRC_ADDR]	= {
+ 			.len = sizeof(struct __kernel_sockaddr_storage) },
+ 	[RDMA_NLDEV_ATTR_RES_DST_ADDR]	= {
+ 			.len = sizeof(struct __kernel_sockaddr_storage) },
+ 	[RDMA_NLDEV_ATTR_RES_CQ]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CQ_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_CQE]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_USECNT]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_RES_POLL_CTX]		= { .type = NLA_U8 },
+ 	[RDMA_NLDEV_ATTR_RES_MR]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_MR_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_RKEY]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_LKEY]		= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_IOVA]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_RES_MRLEN]		= { .type = NLA_U64 },
+ 	[RDMA_NLDEV_ATTR_RES_PD]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_PD_ENTRY]		= { .type = NLA_NESTED },
+ 	[RDMA_NLDEV_ATTR_RES_LOCAL_DMA_LKEY]	= { .type = NLA_U32 },
+ 	[RDMA_NLDEV_ATTR_RES_UNSAFE_GLOBAL_RKEY] = { .type = NLA_U32 },
++>>>>>>> 29cf1351d450 (RDMA/nldev: provide detailed PD information)
  };
  
  static int fill_nldev_handle(struct sk_buff *msg, struct ib_device *device)
@@@ -284,7 -375,115 +309,119 @@@ out
  	return -EMSGSIZE;
  }
  
++<<<<<<< HEAD
 +static int nldev_get_doit(struct sk_buff *skb, struct nlmsghdr *nlh)
++=======
+ static int fill_res_cq_entry(struct sk_buff *msg, struct netlink_callback *cb,
+ 			     struct rdma_restrack_entry *res, uint32_t port)
+ {
+ 	struct ib_cq *cq = container_of(res, struct ib_cq, res);
+ 	struct nlattr *entry_attr;
+ 
+ 	entry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_CQ_ENTRY);
+ 	if (!entry_attr)
+ 		goto out;
+ 
+ 	if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CQE, cq->cqe))
+ 		goto err;
+ 	if (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_USECNT,
+ 			      atomic_read(&cq->usecnt), 0))
+ 		goto err;
+ 
+ 	/* Poll context is only valid for kernel CQs */
+ 	if (rdma_is_kernel_res(res) &&
+ 	    nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_POLL_CTX, cq->poll_ctx))
+ 		goto err;
+ 
+ 	if (fill_res_name_pid(msg, res))
+ 		goto err;
+ 
+ 	nla_nest_end(msg, entry_attr);
+ 	return 0;
+ 
+ err:
+ 	nla_nest_cancel(msg, entry_attr);
+ out:
+ 	return -EMSGSIZE;
+ }
+ 
+ static int fill_res_mr_entry(struct sk_buff *msg, struct netlink_callback *cb,
+ 			     struct rdma_restrack_entry *res, uint32_t port)
+ {
+ 	struct ib_mr *mr = container_of(res, struct ib_mr, res);
+ 	struct nlattr *entry_attr;
+ 
+ 	entry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_MR_ENTRY);
+ 	if (!entry_attr)
+ 		goto out;
+ 
+ 	if (netlink_capable(cb->skb, CAP_NET_ADMIN)) {
+ 		if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_RKEY, mr->rkey))
+ 			goto err;
+ 		if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LKEY, mr->lkey))
+ 			goto err;
+ 		if (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_IOVA,
+ 				      mr->iova, 0))
+ 			goto err;
+ 	}
+ 
+ 	if (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_MRLEN, mr->length, 0))
+ 		goto err;
+ 
+ 	if (fill_res_name_pid(msg, res))
+ 		goto err;
+ 
+ 	nla_nest_end(msg, entry_attr);
+ 	return 0;
+ 
+ err:
+ 	nla_nest_cancel(msg, entry_attr);
+ out:
+ 	return -EMSGSIZE;
+ }
+ 
+ static int fill_res_pd_entry(struct sk_buff *msg, struct netlink_callback *cb,
+ 			     struct rdma_restrack_entry *res, uint32_t port)
+ {
+ 	struct ib_pd *pd = container_of(res, struct ib_pd, res);
+ 	struct nlattr *entry_attr;
+ 
+ 	entry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_PD_ENTRY);
+ 	if (!entry_attr)
+ 		goto out;
+ 
+ 	if (netlink_capable(cb->skb, CAP_NET_ADMIN)) {
+ 		if (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LOCAL_DMA_LKEY,
+ 				pd->local_dma_lkey))
+ 			goto err;
+ 		if ((pd->flags & IB_PD_UNSAFE_GLOBAL_RKEY) &&
+ 		    nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_UNSAFE_GLOBAL_RKEY,
+ 				pd->unsafe_global_rkey))
+ 			goto err;
+ 	}
+ 	if (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_USECNT,
+ 			      atomic_read(&pd->usecnt), 0))
+ 		goto err;
+ 	if ((pd->flags & IB_PD_UNSAFE_GLOBAL_RKEY) &&
+ 	    nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_UNSAFE_GLOBAL_RKEY,
+ 			pd->unsafe_global_rkey))
+ 		goto err;
+ 
+ 	if (fill_res_name_pid(msg, res))
+ 		goto err;
+ 
+ 	nla_nest_end(msg, entry_attr);
+ 	return 0;
+ 
+ err:
+ 	nla_nest_cancel(msg, entry_attr);
+ out:
+ 	return -EMSGSIZE;
+ }
+ 
+ static int nldev_get_doit(struct sk_buff *skb, struct nlmsghdr *nlh,
+ 			  struct netlink_ext_ack *extack)
++>>>>>>> 29cf1351d450 (RDMA/nldev: provide detailed PD information)
  {
  	struct nlattr *tb[RDMA_NLDEV_ATTR_MAX];
  	struct ib_device *device;
@@@ -568,6 -769,26 +705,29 @@@ static const struct nldev_fill_res_entr
  		.nldev_cmd = RDMA_NLDEV_CMD_RES_QP_GET,
  		.nldev_attr = RDMA_NLDEV_ATTR_RES_QP,
  	},
++<<<<<<< HEAD
++=======
+ 	[RDMA_RESTRACK_CM_ID] = {
+ 		.fill_res_func = fill_res_cm_id_entry,
+ 		.nldev_cmd = RDMA_NLDEV_CMD_RES_CM_ID_GET,
+ 		.nldev_attr = RDMA_NLDEV_ATTR_RES_CM_ID,
+ 	},
+ 	[RDMA_RESTRACK_CQ] = {
+ 		.fill_res_func = fill_res_cq_entry,
+ 		.nldev_cmd = RDMA_NLDEV_CMD_RES_CQ_GET,
+ 		.nldev_attr = RDMA_NLDEV_ATTR_RES_CQ,
+ 	},
+ 	[RDMA_RESTRACK_MR] = {
+ 		.fill_res_func = fill_res_mr_entry,
+ 		.nldev_cmd = RDMA_NLDEV_CMD_RES_MR_GET,
+ 		.nldev_attr = RDMA_NLDEV_ATTR_RES_MR,
+ 	},
+ 	[RDMA_RESTRACK_PD] = {
+ 		.fill_res_func = fill_res_pd_entry,
+ 		.nldev_cmd = RDMA_NLDEV_CMD_RES_PD_GET,
+ 		.nldev_attr = RDMA_NLDEV_ATTR_RES_PD,
+ 	},
++>>>>>>> 29cf1351d450 (RDMA/nldev: provide detailed PD information)
  };
  
  static int res_get_common_dumpit(struct sk_buff *skb,
@@@ -710,6 -931,30 +870,33 @@@ static int nldev_res_get_qp_dumpit(stru
  	return res_get_common_dumpit(skb, cb, RDMA_RESTRACK_QP);
  }
  
++<<<<<<< HEAD
++=======
+ static int nldev_res_get_cm_id_dumpit(struct sk_buff *skb,
+ 				      struct netlink_callback *cb)
+ {
+ 	return res_get_common_dumpit(skb, cb, RDMA_RESTRACK_CM_ID);
+ }
+ 
+ static int nldev_res_get_cq_dumpit(struct sk_buff *skb,
+ 				   struct netlink_callback *cb)
+ {
+ 	return res_get_common_dumpit(skb, cb, RDMA_RESTRACK_CQ);
+ }
+ 
+ static int nldev_res_get_mr_dumpit(struct sk_buff *skb,
+ 				   struct netlink_callback *cb)
+ {
+ 	return res_get_common_dumpit(skb, cb, RDMA_RESTRACK_MR);
+ }
+ 
+ static int nldev_res_get_pd_dumpit(struct sk_buff *skb,
+ 				   struct netlink_callback *cb)
+ {
+ 	return res_get_common_dumpit(skb, cb, RDMA_RESTRACK_PD);
+ }
+ 
++>>>>>>> 29cf1351d450 (RDMA/nldev: provide detailed PD information)
  static const struct rdma_nl_cbs nldev_cb_table[RDMA_NLDEV_NUM_OPS] = {
  	[RDMA_NLDEV_CMD_GET] = {
  		.doit = nldev_get_doit,
@@@ -736,6 -981,18 +923,21 @@@
  		 * too.
  		 */
  	},
++<<<<<<< HEAD
++=======
+ 	[RDMA_NLDEV_CMD_RES_CM_ID_GET] = {
+ 		.dump = nldev_res_get_cm_id_dumpit,
+ 	},
+ 	[RDMA_NLDEV_CMD_RES_CQ_GET] = {
+ 		.dump = nldev_res_get_cq_dumpit,
+ 	},
+ 	[RDMA_NLDEV_CMD_RES_MR_GET] = {
+ 		.dump = nldev_res_get_mr_dumpit,
+ 	},
+ 	[RDMA_NLDEV_CMD_RES_PD_GET] = {
+ 		.dump = nldev_res_get_pd_dumpit,
+ 	},
++>>>>>>> 29cf1351d450 (RDMA/nldev: provide detailed PD information)
  };
  
  void __init nldev_init(void)
diff --cc include/uapi/rdma/rdma_netlink.h
index b90c8cd4c303,351139c7e2e7..000000000000
--- a/include/uapi/rdma/rdma_netlink.h
+++ b/include/uapi/rdma/rdma_netlink.h
@@@ -237,6 -238,14 +237,17 @@@ enum rdma_nldev_command 
  
  	RDMA_NLDEV_CMD_RES_QP_GET, /* can dump */
  
++<<<<<<< HEAD
++=======
+ 	RDMA_NLDEV_CMD_RES_CM_ID_GET, /* can dump */
+ 
+ 	RDMA_NLDEV_CMD_RES_CQ_GET, /* can dump */
+ 
+ 	RDMA_NLDEV_CMD_RES_MR_GET, /* can dump */
+ 
+ 	RDMA_NLDEV_CMD_RES_PD_GET, /* can dump */
+ 
++>>>>>>> 29cf1351d450 (RDMA/nldev: provide detailed PD information)
  	RDMA_NLDEV_NUM_OPS
  };
  
@@@ -349,6 -358,36 +360,39 @@@ enum rdma_nldev_attr 
  	 */
  	RDMA_NLDEV_ATTR_RES_KERN_NAME,		/* string */
  
++<<<<<<< HEAD
++=======
+ 	RDMA_NLDEV_ATTR_RES_CM_ID,		/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_CM_ID_ENTRY,	/* nested table */
+ 	/*
+ 	 * rdma_cm_id port space.
+ 	 */
+ 	RDMA_NLDEV_ATTR_RES_PS,			/* u32 */
+ 	/*
+ 	 * Source and destination socket addresses
+ 	 */
+ 	RDMA_NLDEV_ATTR_RES_SRC_ADDR,		/* __kernel_sockaddr_storage */
+ 	RDMA_NLDEV_ATTR_RES_DST_ADDR,		/* __kernel_sockaddr_storage */
+ 
+ 	RDMA_NLDEV_ATTR_RES_CQ,			/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_CQ_ENTRY,		/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_CQE,		/* u32 */
+ 	RDMA_NLDEV_ATTR_RES_USECNT,		/* u64 */
+ 	RDMA_NLDEV_ATTR_RES_POLL_CTX,		/* u8 */
+ 
+ 	RDMA_NLDEV_ATTR_RES_MR,			/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_MR_ENTRY,		/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_RKEY,		/* u32 */
+ 	RDMA_NLDEV_ATTR_RES_LKEY,		/* u32 */
+ 	RDMA_NLDEV_ATTR_RES_IOVA,		/* u64 */
+ 	RDMA_NLDEV_ATTR_RES_MRLEN,		/* u64 */
+ 
+ 	RDMA_NLDEV_ATTR_RES_PD,			/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_PD_ENTRY,		/* nested table */
+ 	RDMA_NLDEV_ATTR_RES_LOCAL_DMA_LKEY,	/* u32 */
+ 	RDMA_NLDEV_ATTR_RES_UNSAFE_GLOBAL_RKEY,	/* u32 */
+ 
++>>>>>>> 29cf1351d450 (RDMA/nldev: provide detailed PD information)
  	RDMA_NLDEV_ATTR_MAX
  };
  #endif /* _UAPI_RDMA_NETLINK_H */
* Unmerged path drivers/infiniband/core/nldev.c
* Unmerged path include/uapi/rdma/rdma_netlink.h
