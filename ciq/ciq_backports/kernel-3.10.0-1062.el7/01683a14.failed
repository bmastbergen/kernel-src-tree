net: sched: refactor flower walk to iterate over idr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [net] sched: refactor flower walk to iterate over idr (Ivan Vecera) [1655892 1614816]
Rebuild_FUZZ: 94.95%
commit-author Vlad Buslov <vladbu@mellanox.com>
commit 01683a1469995cc7aaf833d6f8b3f1c1d2fc3b92
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/01683a14.failed

Extend struct tcf_walker with additional 'cookie' field. It is intended to
be used by classifier walk implementations to continue iteration directly
from particular filter, instead of iterating 'skip' number of times.

Change flower walk implementation to save filter handle in 'cookie'. Each
time flower walk is called, it looks up filter with saved handle directly
with idr, instead of iterating over filter linked list 'skip' number of
times. This change improves complexity of dumping flower classifier from
quadratic to linearithmic. (assuming idr lookup has logarithmic complexity)

	Reviewed-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Vlad Buslov <vladbu@mellanox.com>
	Reported-by: Simon Horman <simon.horman@netronome.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 01683a1469995cc7aaf833d6f8b3f1c1d2fc3b92)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_flower.c
diff --cc net/sched/cls_flower.c
index eb4e6a91f3e1,c53fdd411f90..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -1061,14 -1100,15 +1061,25 @@@ static void fl_walk(struct tcf_proto *t
  	struct cls_fl_head *head = rtnl_dereference(tp->root);
  	struct cls_fl_filter *f;
  
++<<<<<<< HEAD
 +	list_for_each_entry_rcu(f, &head->filters, list) {
 +		if (arg->count < arg->skip)
 +			goto skip;
++=======
+ 	arg->count = arg->skip;
+ 
+ 	while ((f = idr_get_next_ul(&head->handle_idr,
+ 				    &arg->cookie)) != NULL) {
++>>>>>>> 01683a146999 (net: sched: refactor flower walk to iterate over idr)
  		if (arg->fn(tp, f, arg) < 0) {
  			arg->stop = 1;
  			break;
  		}
++<<<<<<< HEAD
 +skip:
++=======
+ 		arg->cookie = f->handle + 1;
++>>>>>>> 01683a146999 (net: sched: refactor flower walk to iterate over idr)
  		arg->count++;
  	}
  }
diff --git a/include/net/pkt_cls.h b/include/net/pkt_cls.h
index 4ce9437e911a..1b652d3cd698 100644
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@ -12,6 +12,7 @@ struct tcf_walker {
 	int	stop;
 	int	skip;
 	int	count;
+	unsigned long cookie;
 	int	(*fn)(struct tcf_proto *, void *node, struct tcf_walker *);
 };
 
diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c
index c5c5c61d0859..b437d391a9a7 100644
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@ -1271,7 +1271,9 @@ static bool tcf_chain_dump(struct tcf_chain *chain, struct Qdisc *q, u32 parent,
 		arg.w.stop = 0;
 		arg.w.skip = cb->args[1] - 1;
 		arg.w.count = 0;
+		arg.w.cookie = cb->args[2];
 		tp->ops->walk(tp, &arg.w);
+		cb->args[2] = arg.w.cookie;
 		cb->args[1] = arg.w.count + 1;
 		if (arg.w.stop)
 			return false;
* Unmerged path net/sched/cls_flower.c
