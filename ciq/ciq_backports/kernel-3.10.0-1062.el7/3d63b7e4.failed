n_tty: Fix stall at n_tty_receive_char_special().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [tty] n_tty: Fix stall at n_tty_receive_char_special() (Christoph von Recklinghausen) [1649343]
Rebuild_FUZZ: 98.97%
commit-author Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
commit 3d63b7e4ae0dc5e02d28ddd2fa1f945defc68d81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3d63b7e4.failed

syzbot is reporting stalls at n_tty_receive_char_special() [1]. This is
because comparison is not working as expected since ldata->read_head can
change at any moment. Mitigate this by explicitly masking with buffer size
when checking condition for "while" loops.

[1] https://syzkaller.appspot.com/bug?id=3d7481a346958d9469bebbeb0537d5f056bdd6e8

	Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Reported-by: syzbot <syzbot+18df353d7540aa6b5467@syzkaller.appspotmail.com>
Fixes: bc5a5e3f45d04784 ("n_tty: Don't wrap input buffer indices at buffer size")
	Cc: stable <stable@vger.kernel.org>
	Cc: Peter Hurley <peter@hurleysoftware.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 3d63b7e4ae0dc5e02d28ddd2fa1f945defc68d81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/n_tty.c
diff --cc drivers/tty/n_tty.c
index 4181bb27f72e,b279f8730e04..000000000000
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@@ -108,17 -121,56 +108,49 @@@ struct n_tty_data 
  
  	struct mutex atomic_read_lock;
  	struct mutex output_lock;
 +	struct mutex echo_lock;
 +	raw_spinlock_t read_lock;
  };
  
++<<<<<<< HEAD
 +static inline int tty_put_user(struct tty_struct *tty, unsigned char x,
 +			       unsigned char __user *ptr)
++=======
+ #define MASK(x) ((x) & (N_TTY_BUF_SIZE - 1))
+ 
+ static inline size_t read_cnt(struct n_tty_data *ldata)
+ {
+ 	return ldata->read_head - ldata->read_tail;
+ }
+ 
+ static inline unsigned char read_buf(struct n_tty_data *ldata, size_t i)
+ {
+ 	return ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];
+ }
+ 
+ static inline unsigned char *read_buf_addr(struct n_tty_data *ldata, size_t i)
+ {
+ 	return &ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];
+ }
+ 
+ static inline unsigned char echo_buf(struct n_tty_data *ldata, size_t i)
+ {
+ 	return ldata->echo_buf[i & (N_TTY_BUF_SIZE - 1)];
+ }
+ 
+ static inline unsigned char *echo_buf_addr(struct n_tty_data *ldata, size_t i)
+ {
+ 	return &ldata->echo_buf[i & (N_TTY_BUF_SIZE - 1)];
+ }
+ 
+ static int tty_copy_to_user(struct tty_struct *tty, void __user *to,
+ 			    size_t tail, size_t n)
++>>>>>>> 3d63b7e4ae0d (n_tty: Fix stall at n_tty_receive_char_special().)
  {
  	struct n_tty_data *ldata = tty->disc_data;
 -	size_t size = N_TTY_BUF_SIZE - tail;
 -	const void *from = read_buf_addr(ldata, tail);
 -	int uncopied;
 -
 -	if (n > size) {
 -		tty_audit_add_data(tty, from, size);
 -		uncopied = copy_to_user(to, from, size);
 -		if (uncopied)
 -			return uncopied;
 -		to += size;
 -		n -= size;
 -		from = ldata->read_buf;
 -	}
  
 -	tty_audit_add_data(tty, from, n);
 -	return copy_to_user(to, from, n);
 +	tty_audit_add_data(tty, &x, 1, ldata->icanon);
 +	return put_user(x, ptr);
  }
  
  /**
@@@ -954,15 -980,15 +986,26 @@@ static void eraser(unsigned char c, str
  	}
  
  	seen_alnums = 0;
++<<<<<<< HEAD
 +	/* FIXME: Locking ?? */
 +	while (ldata->read_head != ldata->canon_head) {
++=======
+ 	while (MASK(ldata->read_head) != MASK(ldata->canon_head)) {
++>>>>>>> 3d63b7e4ae0d (n_tty: Fix stall at n_tty_receive_char_special().)
  		head = ldata->read_head;
  
  		/* erase a single possibly multibyte character */
  		do {
++<<<<<<< HEAD
 +			head = (head - 1) & (N_TTY_BUF_SIZE-1);
 +			c = ldata->read_buf[head];
 +		} while (is_continuation(c, tty) && head != ldata->canon_head);
++=======
+ 			head--;
+ 			c = read_buf(ldata, head);
+ 		} while (is_continuation(c, tty) &&
+ 			 MASK(head) != MASK(ldata->canon_head));
++>>>>>>> 3d63b7e4ae0d (n_tty: Fix stall at n_tty_receive_char_special().)
  
  		/* do not partially erase */
  		if (is_continuation(c, tty))
@@@ -1008,9 -1030,9 +1051,15 @@@
  				 * This info is used to go back the correct
  				 * number of columns.
  				 */
++<<<<<<< HEAD
 +				while (tail != ldata->canon_head) {
 +					tail = (tail-1) & (N_TTY_BUF_SIZE-1);
 +					c = ldata->read_buf[tail];
++=======
+ 				while (MASK(tail) != MASK(ldata->canon_head)) {
+ 					tail--;
+ 					c = read_buf(ldata, tail);
++>>>>>>> 3d63b7e4ae0d (n_tty: Fix stall at n_tty_receive_char_special().)
  					if (c == '\t') {
  						after_tab = 1;
  						break;
@@@ -1299,22 -1305,17 +1348,28 @@@ send_signal
  			finish_erasing(ldata);
  			echo_char(c, tty);
  			echo_char_raw('\n', ldata);
++<<<<<<< HEAD
 +			while (tail != ldata->read_head) {
 +				echo_char(ldata->read_buf[tail], tty);
 +				tail = (tail+1) & (N_TTY_BUF_SIZE-1);
++=======
+ 			while (MASK(tail) != MASK(ldata->read_head)) {
+ 				echo_char(read_buf(ldata, tail), tty);
+ 				tail++;
++>>>>>>> 3d63b7e4ae0d (n_tty: Fix stall at n_tty_receive_char_special().)
  			}
 -			commit_echoes(tty);
 -			return 0;
 +			process_echoes(tty);
 +			return;
  		}
  		if (c == '\n') {
 +			if (ldata->read_cnt >= N_TTY_BUF_SIZE) {
 +				if (L_ECHO(tty))
 +					process_output('\a', tty);
 +				return;
 +			}
  			if (L_ECHO(tty) || L_ECHONL(tty)) {
  				echo_char_raw('\n', ldata);
 -				commit_echoes(tty);
 +				process_echoes(tty);
  			}
  			goto handle_newline;
  		}
@@@ -2221,13 -2412,13 +2276,19 @@@ static unsigned long inq_canon(struct n
  		return 0;
  	head = ldata->canon_head;
  	tail = ldata->read_tail;
 -	nr = head - tail;
 +	nr = (head - tail) & (N_TTY_BUF_SIZE-1);
  	/* Skip EOF-chars.. */
++<<<<<<< HEAD
 +	while (head != tail) {
 +		if (test_bit(tail, ldata->read_flags) &&
 +		    ldata->read_buf[tail] == __DISABLED_CHAR)
++=======
+ 	while (MASK(head) != MASK(tail)) {
+ 		if (test_bit(tail & (N_TTY_BUF_SIZE - 1), ldata->read_flags) &&
+ 		    read_buf(ldata, tail) == __DISABLED_CHAR)
++>>>>>>> 3d63b7e4ae0d (n_tty: Fix stall at n_tty_receive_char_special().)
  			nr--;
 -		tail++;
 +		tail = (tail+1) & (N_TTY_BUF_SIZE-1);
  	}
  	return nr;
  }
* Unmerged path drivers/tty/n_tty.c
