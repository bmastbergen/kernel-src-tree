net/mlx5: Add a no-append flow insertion mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [kernel] mlx5: Add a no-append flow insertion mode (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 95.35%
commit-author Paul Blakey <paulb@mellanox.com>
commit d5634fee245f9e92787e3a34ef621fc12b2cbf16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d5634fee.failed

If no-append flag is set, we will add a new FTE, instead of appending
the actions of the inserted rule when the same match already exists.

While here, move the has_flow_tag boolean indicator to be a flag too.

This patch doesn't change any functionality.

	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanmox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit d5634fee245f9e92787e3a34ef621fc12b2cbf16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c
#	include/linux/mlx5/fs.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 3a01f0d3c372,a9c68b7859b4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -676,12 -684,11 +676,16 @@@ mlx5e_tc_add_nic_flow(struct mlx5e_pri
  	struct mlx5_flow_destination dest[2] = {};
  	struct mlx5_flow_act flow_act = {
  		.action = attr->action,
- 		.has_flow_tag = true,
  		.flow_tag = attr->flow_tag,
++<<<<<<< HEAD
 +		.encap_id = 0,
++=======
+ 		.reformat_id = 0,
+ 		.flags    = FLOW_ACT_HAS_TAG,
++>>>>>>> d5634fee245f (net/mlx5: Add a no-append flow insertion mode)
  	};
  	struct mlx5_fc *counter = NULL;
 +	struct mlx5_flow_handle *rule;
  	bool table_created = false;
  	int err, dest_ix = 0;
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c
index 5243c60ef173,28aa8c968a80..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c
@@@ -517,6 -535,127 +517,130 @@@ mlx5_fpga_ipsec_build_hw_sa(struct mlx5
  		hw_sa->ipsec_sa_v1.flags |= MLX5_FPGA_IPSEC_SA_IPV6;
  }
  
++<<<<<<< HEAD
++=======
+ static bool is_full_mask(const void *p, size_t len)
+ {
+ 	WARN_ON(len % 4);
+ 
+ 	return !memchr_inv(p, 0xff, len);
+ }
+ 
+ static bool validate_fpga_full_mask(struct mlx5_core_dev *dev,
+ 				    const u32 *match_c,
+ 				    const u32 *match_v)
+ {
+ 	const void *misc_params_c = MLX5_ADDR_OF(fte_match_param,
+ 						 match_c,
+ 						 misc_parameters);
+ 	const void *headers_c = MLX5_ADDR_OF(fte_match_param,
+ 					     match_c,
+ 					     outer_headers);
+ 	const void *headers_v = MLX5_ADDR_OF(fte_match_param,
+ 					     match_v,
+ 					     outer_headers);
+ 
+ 	if (mlx5_fs_is_outer_ipv4_flow(dev, headers_c, headers_v)) {
+ 		const void *s_ipv4_c = MLX5_ADDR_OF(fte_match_set_lyr_2_4,
+ 						    headers_c,
+ 						    src_ipv4_src_ipv6.ipv4_layout.ipv4);
+ 		const void *d_ipv4_c = MLX5_ADDR_OF(fte_match_set_lyr_2_4,
+ 						    headers_c,
+ 						    dst_ipv4_dst_ipv6.ipv4_layout.ipv4);
+ 
+ 		if (!is_full_mask(s_ipv4_c, MLX5_FLD_SZ_BYTES(ipv4_layout,
+ 							      ipv4)) ||
+ 		    !is_full_mask(d_ipv4_c, MLX5_FLD_SZ_BYTES(ipv4_layout,
+ 							      ipv4)))
+ 			return false;
+ 	} else {
+ 		const void *s_ipv6_c = MLX5_ADDR_OF(fte_match_set_lyr_2_4,
+ 						    headers_c,
+ 						    src_ipv4_src_ipv6.ipv6_layout.ipv6);
+ 		const void *d_ipv6_c = MLX5_ADDR_OF(fte_match_set_lyr_2_4,
+ 						    headers_c,
+ 						    dst_ipv4_dst_ipv6.ipv6_layout.ipv6);
+ 
+ 		if (!is_full_mask(s_ipv6_c, MLX5_FLD_SZ_BYTES(ipv6_layout,
+ 							      ipv6)) ||
+ 		    !is_full_mask(d_ipv6_c, MLX5_FLD_SZ_BYTES(ipv6_layout,
+ 							      ipv6)))
+ 			return false;
+ 	}
+ 
+ 	if (!is_full_mask(MLX5_ADDR_OF(fte_match_set_misc, misc_params_c,
+ 				       outer_esp_spi),
+ 			  MLX5_FLD_SZ_BYTES(fte_match_set_misc, outer_esp_spi)))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static bool mlx5_is_fpga_ipsec_rule(struct mlx5_core_dev *dev,
+ 				    u8 match_criteria_enable,
+ 				    const u32 *match_c,
+ 				    const u32 *match_v)
+ {
+ 	u32 ipsec_dev_caps = mlx5_accel_ipsec_device_caps(dev);
+ 	bool ipv6_flow;
+ 
+ 	ipv6_flow = mlx5_fs_is_outer_ipv6_flow(dev, match_c, match_v);
+ 
+ 	if (!(match_criteria_enable & MLX5_MATCH_OUTER_HEADERS) ||
+ 	    mlx5_fs_is_outer_udp_flow(match_c, match_v) ||
+ 	    mlx5_fs_is_outer_tcp_flow(match_c, match_v) ||
+ 	    mlx5_fs_is_vxlan_flow(match_c) ||
+ 	    !(mlx5_fs_is_outer_ipv4_flow(dev, match_c, match_v) ||
+ 	      ipv6_flow))
+ 		return false;
+ 
+ 	if (!(ipsec_dev_caps & MLX5_ACCEL_IPSEC_CAP_DEVICE))
+ 		return false;
+ 
+ 	if (!(ipsec_dev_caps & MLX5_ACCEL_IPSEC_CAP_ESP) &&
+ 	    mlx5_fs_is_outer_ipsec_flow(match_c))
+ 		return false;
+ 
+ 	if (!(ipsec_dev_caps & MLX5_ACCEL_IPSEC_CAP_IPV6) &&
+ 	    ipv6_flow)
+ 		return false;
+ 
+ 	if (!validate_fpga_full_mask(dev, match_c, match_v))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static bool mlx5_is_fpga_egress_ipsec_rule(struct mlx5_core_dev *dev,
+ 					   u8 match_criteria_enable,
+ 					   const u32 *match_c,
+ 					   const u32 *match_v,
+ 					   struct mlx5_flow_act *flow_act)
+ {
+ 	const void *outer_c = MLX5_ADDR_OF(fte_match_param, match_c,
+ 					   outer_headers);
+ 	bool is_dmac = MLX5_GET(fte_match_set_lyr_2_4, outer_c, dmac_47_16) ||
+ 			MLX5_GET(fte_match_set_lyr_2_4, outer_c, dmac_15_0);
+ 	bool is_smac = MLX5_GET(fte_match_set_lyr_2_4, outer_c, smac_47_16) ||
+ 			MLX5_GET(fte_match_set_lyr_2_4, outer_c, smac_15_0);
+ 	int ret;
+ 
+ 	ret = mlx5_is_fpga_ipsec_rule(dev, match_criteria_enable, match_c,
+ 				      match_v);
+ 	if (!ret)
+ 		return ret;
+ 
+ 	if (is_dmac || is_smac ||
+ 	    (match_criteria_enable &
+ 	     ~(MLX5_MATCH_OUTER_HEADERS | MLX5_MATCH_MISC_PARAMETERS)) ||
+ 	    (flow_act->action & ~(MLX5_FLOW_CONTEXT_ACTION_ENCRYPT | MLX5_FLOW_CONTEXT_ACTION_ALLOW)) ||
+ 	     (flow_act->flags & FLOW_ACT_HAS_TAG))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
++>>>>>>> d5634fee245f (net/mlx5: Add a no-append flow insertion mode)
  void *mlx5_fpga_ipsec_create_sa_ctx(struct mlx5_core_dev *mdev,
  				    struct mlx5_accel_esp_xfrm *accel_xfrm,
  				    const __be32 saddr[4],
diff --cc include/linux/mlx5/fs.h
index 7035fec2adf8,5660f07d3be0..000000000000
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@@ -152,13 -156,22 +152,29 @@@ struct mlx5_fs_vlan 
          u8  prio;
  };
  
++<<<<<<< HEAD
++=======
+ #define MLX5_FS_VLAN_DEPTH	2
+ 
+ enum {
+ 	FLOW_ACT_HAS_TAG   = BIT(0),
+ 	FLOW_ACT_NO_APPEND = BIT(1),
+ };
+ 
++>>>>>>> d5634fee245f (net/mlx5: Add a no-append flow insertion mode)
  struct mlx5_flow_act {
  	u32 action;
- 	bool has_flow_tag;
  	u32 flow_tag;
 -	u32 reformat_id;
 +	u32 encap_id;
  	u32 modify_id;
++<<<<<<< HEAD
 +	struct mlx5_fs_vlan vlan;
++=======
+ 	uintptr_t esp_id;
+ 	u32 flags;
+ 	struct mlx5_fs_vlan vlan[MLX5_FS_VLAN_DEPTH];
+ 	struct ib_counters *counters;
++>>>>>>> d5634fee245f (net/mlx5: Add a no-append flow insertion mode)
  };
  
  #define MLX5_DECLARE_FLOW_ACT(name) \
diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c
index b529cb4f76e1..827f4c474ed8 100644
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@ -2711,7 +2711,7 @@ static int parse_flow_attr(struct mlx5_core_dev *mdev, u32 *match_c,
 			return -EINVAL;
 
 		action->flow_tag = ib_spec->flow_tag.tag_id;
-		action->has_flow_tag = true;
+		action->flags |= FLOW_ACT_HAS_TAG;
 		break;
 	case IB_FLOW_SPEC_ACTION_DROP:
 		if (FIELDS_NOT_SUPPORTED(ib_spec->drop,
@@ -2792,7 +2792,7 @@ is_valid_esp_aes_gcm(struct mlx5_core_dev *mdev,
 		return egress ? VALID_SPEC_INVALID : VALID_SPEC_NA;
 
 	return is_crypto && is_ipsec &&
-		(!egress || (!is_drop && !flow_act->has_flow_tag)) ?
+		(!egress || (!is_drop && !(flow_act->flags & FLOW_ACT_HAS_TAG))) ?
 		VALID_SPEC_VALID : VALID_SPEC_INVALID;
 }
 
@@ -3088,7 +3088,7 @@ static struct mlx5_ib_flow_handler *_create_flow_rule(struct mlx5_ib_dev *dev,
 					MLX5_FLOW_CONTEXT_ACTION_FWD_NEXT_PRIO;
 	}
 
-	if (flow_act.has_flow_tag &&
+	if ((flow_act.flags & FLOW_ACT_HAS_TAG)  &&
 	    (flow_attr->type == IB_FLOW_ATTR_ALL_DEFAULT ||
 	     flow_attr->type == IB_FLOW_ATTR_MC_DEFAULT)) {
 		mlx5_ib_warn(dev, "Flow tag %u and attribute type %x isn't allowed in leftovers\n",
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fpga/ipsec.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index 72297c31a849..60a45436c065 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@ -1406,7 +1406,7 @@ static int check_conflicting_ftes(struct fs_fte *fte, const struct mlx5_flow_act
 		return -EEXIST;
 	}
 
-	if (flow_act->has_flow_tag &&
+	if ((flow_act->flags & FLOW_ACT_HAS_TAG) &&
 	    fte->action.flow_tag != flow_act->flow_tag) {
 		mlx5_core_warn(get_dev(&fte->node),
 			       "FTE flow tag %u already exists with different flow tag %u\n",
@@ -1627,6 +1627,8 @@ try_add_to_existing_fg(struct mlx5_flow_table *ft,
 
 search_again_locked:
 	version = matched_fgs_get_version(match_head);
+	if (flow_act->flags & FLOW_ACT_NO_APPEND)
+		goto skip_search;
 	/* Try to find a fg that already contains a matching fte */
 	list_for_each_entry(iter, match_head, list) {
 		struct fs_fte *fte_tmp;
@@ -1643,6 +1645,11 @@ search_again_locked:
 		return rule;
 	}
 
+skip_search:
+	/* No group with matching fte found, or we skipped the search.
+	 * Try to add a new fte to any matching fg.
+	 */
+
 	/* Check the ft version, for case that new flow group
 	 * was added while the fgs weren't locked
 	 */
* Unmerged path include/linux/mlx5/fs.h
