bpf: add new jited info fields in bpf_dev_offload and bpf_prog_info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jiong Wang <jiong.wang@netronome.com>
commit fcfb126defda3cee3f1d9460dbe9a2ccac4fbd21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fcfb126d.failed

For host JIT, there are "jited_len"/"bpf_func" fields in struct bpf_prog
used by all host JIT targets to get jited image and it's length. While for
offload, targets are likely to have different offload mechanisms that these
info are kept in device private data fields.

Therefore, BPF_OBJ_GET_INFO_BY_FD syscall needs an unified way to get JIT
length and contents info for offload targets.

One way is to introduce new callback to parse device private data then fill
those fields in bpf_prog_info. This might be a little heavy, the other way
is to add generic fields which will be initialized by all offload targets.

This patch follow the second approach to introduce two new fields in
struct bpf_dev_offload and teach bpf_prog_get_info_by_fd about them to fill
correct jited_prog_len and jited_prog_insns in bpf_prog_info.

	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: Jiong Wang <jiong.wang@netronome.com>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit fcfb126defda3cee3f1d9460dbe9a2ccac4fbd21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/offload.c
#	kernel/bpf/syscall.c
diff --cc include/linux/bpf.h
index 58d1e56b2ab5,025b1c2f8053..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -195,6 -222,22 +195,25 @@@ struct bpf_verifier_ops 
  				  struct bpf_prog *prog, u32 *target_size);
  };
  
++<<<<<<< HEAD
++=======
+ struct bpf_prog_offload_ops {
+ 	int (*insn_hook)(struct bpf_verifier_env *env,
+ 			 int insn_idx, int prev_insn_idx);
+ };
+ 
+ struct bpf_prog_offload {
+ 	struct bpf_prog		*prog;
+ 	struct net_device	*netdev;
+ 	void			*dev_priv;
+ 	struct list_head	offloads;
+ 	bool			dev_state;
+ 	const struct bpf_prog_offload_ops *dev_ops;
+ 	void			*jited_image;
+ 	u32			jited_len;
+ };
+ 
++>>>>>>> fcfb126defda (bpf: add new jited info fields in bpf_dev_offload and bpf_prog_info)
  struct bpf_prog_aux {
  	atomic_t refcnt;
  	u32 used_map_cnt;
diff --cc kernel/bpf/syscall.c
index f8f3ed8bef67,c28524483bf4..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -1625,6 -1745,30 +1612,33 @@@ static int bpf_prog_get_info_by_fd(stru
  			return -EFAULT;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (bpf_prog_is_dev_bound(prog->aux)) {
+ 		err = bpf_prog_offload_info_fill(&info, prog);
+ 		if (err)
+ 			return err;
+ 		goto done;
+ 	}
+ 
+ 	/* NOTE: the following code is supposed to be skipped for offload.
+ 	 * bpf_prog_offload_info_fill() is the place to fill similar fields
+ 	 * for offload.
+ 	 */
+ 	ulen = info.jited_prog_len;
+ 	info.jited_prog_len = prog->jited_len;
+ 	if (info.jited_prog_len && ulen) {
+ 		if (bpf_dump_raw_ok()) {
+ 			uinsns = u64_to_user_ptr(info.jited_prog_insns);
+ 			ulen = min_t(u32, info.jited_prog_len, ulen);
+ 			if (copy_to_user(uinsns, prog->bpf_func, ulen))
+ 				return -EFAULT;
+ 		} else {
+ 			info.jited_prog_insns = 0;
+ 		}
+ 	}
+ 
++>>>>>>> fcfb126defda (bpf: add new jited info fields in bpf_dev_offload and bpf_prog_info)
  done:
  	if (copy_to_user(uinfo, &info, info_len) ||
  	    put_user(info_len, &uattr->info.info_len))
* Unmerged path kernel/bpf/offload.c
* Unmerged path include/linux/bpf.h
* Unmerged path kernel/bpf/offload.c
* Unmerged path kernel/bpf/syscall.c
