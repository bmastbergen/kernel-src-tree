ext4: fix quota inconsistency during orphan cleanup for read-only mounts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author zhangyi (F) <yi.zhang@huawei.com>
commit 95f1fda47c9d8738f858c3861add7bf0a36a7c0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/95f1fda4.failed

Quota does not get enabled for read-only mounts if filesystem
has quota feature, so that quotas cannot updated during orphan
cleanup, which will lead to quota inconsistency.

This patch turn on quotas during orphan cleanup for this case,
make sure quotas can be updated correctly.

	Reported-by: Jan Kara <jack@suse.cz>
	Signed-off-by: zhangyi (F) <yi.zhang@huawei.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Cc: stable@vger.kernel.org # 3.18+
(cherry picked from commit 95f1fda47c9d8738f858c3861add7bf0a36a7c0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/super.c
diff --cc fs/ext4/super.c
index 10def714f6cf,c9e7be58756b..000000000000
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@@ -2242,8 -2402,9 +2242,9 @@@ static void ext4_orphan_cleanup(struct 
  				struct ext4_super_block *es)
  {
  	unsigned int s_flags = sb->s_flags;
 -	int ret, nr_orphans = 0, nr_truncates = 0;
 +	int nr_orphans = 0, nr_truncates = 0;
  #ifdef CONFIG_QUOTA
+ 	int quota_update = 0;
  	int i;
  #endif
  	if (!es->s_last_orphan) {
@@@ -2282,14 -2443,32 +2283,37 @@@
  #ifdef CONFIG_QUOTA
  	/* Needed for iput() to work correctly and not trash data */
  	sb->s_flags |= MS_ACTIVE;
++<<<<<<< HEAD
 +	/* Turn on quotas so that they are updated correctly */
 +	for (i = 0; i < MAXQUOTAS; i++) {
++=======
+ 
+ 	/*
+ 	 * Turn on quotas which were not enabled for read-only mounts if
+ 	 * filesystem has quota feature, so that they are updated correctly.
+ 	 */
+ 	if (ext4_has_feature_quota(sb) && (s_flags & MS_RDONLY)) {
+ 		int ret = ext4_enable_quotas(sb);
+ 
+ 		if (!ret)
+ 			quota_update = 1;
+ 		else
+ 			ext4_msg(sb, KERN_ERR,
+ 				"Cannot turn on quotas: error %d", ret);
+ 	}
+ 
+ 	/* Turn on journaled quotas used for old sytle */
+ 	for (i = 0; i < EXT4_MAXQUOTAS; i++) {
++>>>>>>> 95f1fda47c9d (ext4: fix quota inconsistency during orphan cleanup for read-only mounts)
  		if (EXT4_SB(sb)->s_qf_names[i]) {
  			int ret = ext4_quota_on_mount(sb, i);
- 			if (ret < 0)
+ 
+ 			if (!ret)
+ 				quota_update = 1;
+ 			else
  				ext4_msg(sb, KERN_ERR,
  					"Cannot turn on journaled "
- 					"quota: error %d", ret);
+ 					"quota: type %d: error %d", i, ret);
  		}
  	}
  #endif
@@@ -2348,10 -2529,12 +2372,19 @@@
  		ext4_msg(sb, KERN_INFO, "%d truncate%s cleaned up",
  		       PLURAL(nr_truncates));
  #ifdef CONFIG_QUOTA
++<<<<<<< HEAD
 +	/* Turn quotas off */
 +	for (i = 0; i < MAXQUOTAS; i++) {
 +		if (sb_dqopt(sb)->files[i])
 +			dquot_quota_off(sb, i);
++=======
+ 	/* Turn off quotas if they were enabled for orphan cleanup */
+ 	if (quota_update) {
+ 		for (i = 0; i < EXT4_MAXQUOTAS; i++) {
+ 			if (sb_dqopt(sb)->files[i])
+ 				dquot_quota_off(sb, i);
+ 		}
++>>>>>>> 95f1fda47c9d (ext4: fix quota inconsistency during orphan cleanup for read-only mounts)
  	}
  #endif
  	sb->s_flags = s_flags; /* Restore MS_RDONLY status */
@@@ -5497,11 -5527,15 +5530,14 @@@ static int ext4_enable_quotas(struct su
  	};
  
  	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE;
 -	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
 +	for (type = 0; type < MAXQUOTAS; type++) {
  		if (qf_inums[type]) {
  			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
 -				DQUOT_USAGE_ENABLED |
 -				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
 +						DQUOT_USAGE_ENABLED);
  			if (err) {
+ 				for (type--; type >= 0; type--)
+ 					dquot_quota_off(sb, type);
+ 
  				ext4_warning(sb,
  					"Failed to enable quota tracking "
  					"(type=%d, err=%d). Please run "
* Unmerged path fs/ext4/super.c
