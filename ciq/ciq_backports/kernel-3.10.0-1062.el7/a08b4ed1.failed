net/mlx5: Add support to ext_* fields introduced in Port Type and Speed register

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Add support to ext_* fields introduced in Port Type and Speed register (Alaa Hleihel) [1590191]
Rebuild_FUZZ: 97.44%
commit-author Aya Levin <ayal@mellanox.com>
commit a08b4ed1373dc59e3e15029bc6f135ba0f53c9a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a08b4ed1.failed

This patch exposes new link modes (including 50Gbps per lane), and ext_*
fields which describes the new link modes in Port Type and Speed
register (PTYS).
Access functions, translation functions (speed <-> HW bits) and
link max speed function were modified.

	Signed-off-by: Aya Levin <ayal@mellanox.com>
	Reviewed-by: Eran Ben Elisha <eranbe@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a08b4ed1373dc59e3e15029bc6f135ba0f53c9a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/port.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
diff --cc drivers/infiniband/hw/mlx5/main.c
index db7406c6b74d,3677c00fa3bb..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -398,10 -417,12 +398,15 @@@ static int mlx5_query_port_roce(struct 
  	/* Possible bad flows are checked before filling out props so in case
  	 * of an error it will still be zeroed out.
  	 */
 -	err = mlx5_query_port_ptys(mdev, out, sizeof(out), MLX5_PTYS_EN,
 -				   mdev_port_num);
 +	err = mlx5_query_port_eth_proto_oper(mdev, &eth_prot_oper,
 +					     mdev_port_num);
  	if (err)
  		goto out;
++<<<<<<< HEAD
++=======
+ 	eth_prot_oper = MLX5_GET_ETH_PROTO(ptys_reg, out, false,
+ 					   eth_proto_oper);
++>>>>>>> a08b4ed1373d (net/mlx5: Add support to ext_* fields introduced in Port Type and Speed register)
  
  	props->active_width     = IB_WIDTH_4X;
  	props->active_speed     = IB_SPEED_QDR;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index 889e7668b711,8343cf7d292c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -763,20 -695,21 +763,31 @@@ static void get_speed_duplex(struct net
  			     u32 eth_proto_oper,
  			     struct ethtool_link_ksettings *link_ksettings)
  {
++<<<<<<< HEAD
 +	int i;
++=======
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
++>>>>>>> a08b4ed1373d (net/mlx5: Add support to ext_* fields introduced in Port Type and Speed register)
  	u32 speed = SPEED_UNKNOWN;
  	u8 duplex = DUPLEX_UNKNOWN;
  
  	if (!netif_carrier_ok(netdev))
  		goto out;
  
++<<<<<<< HEAD
 +	for (i = 0; i < MLX5E_LINK_MODES_NUMBER; ++i) {
 +		if (eth_proto_oper & MLX5E_PROT_MASK(i)) {
 +			speed = ptys2ethtool_table[i].speed;
 +			duplex = DUPLEX_FULL;
 +			break;
 +		}
++=======
+ 	speed = mlx5e_port_ptys2speed(priv->mdev, eth_proto_oper);
+ 	if (!speed) {
+ 		speed = SPEED_UNKNOWN;
+ 		goto out;
++>>>>>>> a08b4ed1373d (net/mlx5: Add support to ext_* fields introduced in Port Type and Speed register)
  	}
 -
 -	duplex = DUPLEX_FULL;
 -
  out:
  	link_ksettings->base.speed = speed;
  	link_ksettings->base.duplex = duplex;
@@@ -970,11 -897,11 +981,17 @@@ static int mlx5e_set_link_ksettings(str
  
  	link_modes = link_ksettings->base.autoneg == AUTONEG_ENABLE ?
  		mlx5e_ethtool2ptys_adver_link(link_ksettings->link_modes.advertising) :
++<<<<<<< HEAD
 +		mlx5e_ethtool2ptys_speed_link(speed);
 +
 +	err = mlx5_query_port_proto_cap(mdev, &eth_proto_cap, MLX5_PTYS_EN);
++=======
+ 		mlx5e_port_speed2linkmodes(mdev, speed);
+ 
+ 	err = mlx5_port_query_eth_proto(mdev, 1, false, &eproto);
++>>>>>>> a08b4ed1373d (net/mlx5: Add support to ext_* fields introduced in Port Type and Speed register)
  	if (err) {
 -		netdev_err(priv->netdev, "%s: query port eth proto failed: %d\n",
 +		netdev_err(netdev, "%s: query port eth proto cap failed: %d\n",
  			   __func__, err);
  		goto out;
  	}
@@@ -1001,10 -921,10 +1018,14 @@@
  	an_changes = ((!an_disable && an_disable_admin) ||
  		      (an_disable && !an_disable_admin));
  
 -	if (!an_changes && link_modes == eproto.admin)
 +	if (!an_changes && link_modes == eth_proto_admin)
  		goto out;
  
++<<<<<<< HEAD
 +	mlx5_set_port_ptys(mdev, an_disable, link_modes, MLX5_PTYS_EN);
++=======
+ 	mlx5_port_set_eth_ptys(mdev, an_disable, link_modes, false);
++>>>>>>> a08b4ed1373d (net/mlx5: Add support to ext_* fields introduced in Port Type and Speed register)
  	mlx5_toggle_port_link(mdev);
  
  out:
diff --cc drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
index 6b38b6fbd030,70f536ec51c4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
@@@ -35,18 -36,37 +35,31 @@@
  #include <linux/mlx5/driver.h>
  #include "en.h"
  
 -struct mlx5e_port_eth_proto {
 -	u32 cap;
 -	u32 admin;
 -	u32 oper;
 -};
 +struct mlx5_vxlan_port;
  
++<<<<<<< HEAD:drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
 +static inline bool mlx5e_vxlan_allowed(struct mlx5_core_dev *mdev)
 +{
 +	return (MLX5_CAP_ETH(mdev, tunnel_stateless_vxlan) &&
 +		mlx5_core_is_pf(mdev));
 +}
++=======
+ int mlx5_port_query_eth_proto(struct mlx5_core_dev *dev, u8 port, bool ext,
+ 			      struct mlx5e_port_eth_proto *eproto);
+ void mlx5_port_query_eth_autoneg(struct mlx5_core_dev *dev, u8 *an_status,
+ 				 u8 *an_disable_cap, u8 *an_disable_admin);
+ int mlx5_port_set_eth_ptys(struct mlx5_core_dev *dev, bool an_disable,
+ 			   u32 proto_admin, bool ext);
+ u32 mlx5e_port_ptys2speed(struct mlx5_core_dev *mdev, u32 eth_proto_oper);
+ int mlx5e_port_linkspeed(struct mlx5_core_dev *mdev, u32 *speed);
+ int mlx5e_port_max_linkspeed(struct mlx5_core_dev *mdev, u32 *speed);
+ u32 mlx5e_port_speed2linkmodes(struct mlx5_core_dev *mdev, u32 speed);
++>>>>>>> a08b4ed1373d (net/mlx5: Add support to ext_* fields introduced in Port Type and Speed register):drivers/net/ethernet/mellanox/mlx5/core/en/port.h
  
 -int mlx5e_port_query_pbmc(struct mlx5_core_dev *mdev, void *out);
 -int mlx5e_port_set_pbmc(struct mlx5_core_dev *mdev, void *in);
 -int mlx5e_port_query_priority2buffer(struct mlx5_core_dev *mdev, u8 *buffer);
 -int mlx5e_port_set_priority2buffer(struct mlx5_core_dev *mdev, u8 *buffer);
 -
 -int mlx5e_get_fec_caps(struct mlx5_core_dev *dev, u8 *fec_caps);
 -int mlx5e_get_fec_mode(struct mlx5_core_dev *dev, u32 *fec_mode_active,
 -		       u8 *fec_configured_mode);
 -int mlx5e_set_fec_mode(struct mlx5_core_dev *dev, u8 fec_policy);
 -
 -enum {
 -	MLX5E_FEC_NOFEC,
 -	MLX5E_FEC_FIRECODE,
 -	MLX5E_FEC_RS_528_514,
 -};
 +void mlx5e_vxlan_init(struct mlx5e_priv *priv);
 +void mlx5e_vxlan_cleanup(struct mlx5e_priv *priv);
 +void mlx5e_vxlan_add_port(struct mlx5e_priv *priv, u16 port);
 +void mlx5e_vxlan_del_port(struct mlx5e_priv *priv, u16 port);
 +struct mlx5_vxlan_port *mlx5e_vxlan_lookup_port(struct mlx5e_priv *priv, u16 port);
  
 -#endif
 +#endif /* __MLX5_VXLAN_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/port.c
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/port.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
diff --git a/include/linux/mlx5/port.h b/include/linux/mlx5/port.h
index 34aed6032f86..978f65fb4e1f 100644
--- a/include/linux/mlx5/port.h
+++ b/include/linux/mlx5/port.h
@@ -92,6 +92,22 @@ enum mlx5e_link_mode {
 	MLX5E_LINK_MODES_NUMBER,
 };
 
+enum mlx5e_ext_link_mode {
+	MLX5E_SGMII_100M			= 0,
+	MLX5E_1000BASE_X_SGMII			= 1,
+	MLX5E_5GBASE_R				= 3,
+	MLX5E_10GBASE_XFI_XAUI_1		= 4,
+	MLX5E_40GBASE_XLAUI_4_XLPPI_4		= 5,
+	MLX5E_25GAUI_1_25GBASE_CR_KR		= 6,
+	MLX5E_50GAUI_2_LAUI_2_50GBASE_CR2_KR2	= 7,
+	MLX5E_50GAUI_1_LAUI_1_50GBASE_CR_KR	= 8,
+	MLX5E_CAUI_4_100GBASE_CR4_KR4		= 9,
+	MLX5E_100GAUI_2_100GBASE_CR2_KR2	= 10,
+	MLX5E_200GAUI_4_200GBASE_CR4_KR4	= 12,
+	MLX5E_400GAUI_8				= 15,
+	MLX5E_EXT_LINK_MODES_NUMBER,
+};
+
 enum mlx5e_connector_type {
 	MLX5E_PORT_UNKNOWN	= 0,
 	MLX5E_PORT_NONE			= 1,
@@ -106,6 +122,9 @@ enum mlx5e_connector_type {
 };
 
 #define MLX5E_PROT_MASK(link_mode) (1 << link_mode)
+#define MLX5_GET_ETH_PROTO(reg, out, ext, field)	\
+	(ext ? MLX5_GET(reg, out, ext_##field) :	\
+	MLX5_GET(reg, out, field))
 
 #define PORT_MODULE_EVENT_MODULE_STATUS_MASK 0xF
 #define PORT_MODULE_EVENT_ERROR_TYPE_MASK         0xF
