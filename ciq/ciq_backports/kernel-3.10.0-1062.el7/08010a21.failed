netfilter: add API to manage NAT helpers.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Flavio Leitner <fbl@redhat.com>
commit 08010a21602678932894c5e87014a282af0079cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/08010a21.failed

The API allows a conntrack helper to indicate its corresponding
NAT helper which then can be loaded and reference counted.

	Signed-off-by: Flavio Leitner <fbl@redhat.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 08010a21602678932894c5e87014a282af0079cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_conntrack_helper.h
#	net/netfilter/nf_conntrack_ftp.c
#	net/netfilter/nf_conntrack_helper.c
#	net/netfilter/nf_conntrack_sane.c
#	net/netfilter/nf_conntrack_sip.c
#	net/netfilter/nf_conntrack_tftp.c
diff --cc include/net/netfilter/nf_conntrack_helper.h
index 75a098c80e75,44b5a00a9c64..000000000000
--- a/include/net/netfilter/nf_conntrack_helper.h
+++ b/include/net/netfilter/nf_conntrack_helper.h
@@@ -53,9 -54,35 +54,19 @@@ struct nf_conntrack_helper 
  	unsigned int expect_class_max;
  
  	unsigned int flags;
++<<<<<<< HEAD
 +	unsigned int queue_num;		/* For user-space helpers. */
++=======
+ 
+ 	/* For user-space helpers: */
+ 	unsigned int queue_num;
+ 	/* length of userspace private data stored in nf_conn_help->data */
+ 	u16 data_len;
+ 	/* name of NAT helper module */
+ 	char nat_mod_name[NF_CT_HELPER_NAME_LEN];
++>>>>>>> 08010a216026 (netfilter: add API to manage NAT helpers.)
  };
  
 -/* Must be kept in sync with the classes defined by helpers */
 -#define NF_CT_MAX_EXPECT_CLASSES	4
 -
 -/* nf_conn feature for connections that have a helper */
 -struct nf_conn_help {
 -	/* Helper. if any */
 -	struct nf_conntrack_helper __rcu *helper;
 -
 -	struct hlist_head expectations;
 -
 -	/* Current number of expected connections */
 -	u8 expecting[NF_CT_MAX_EXPECT_CLASSES];
 -
 -	/* private helper information. */
 -	char data[32] __aligned(8);
 -};
 -
 -#define NF_CT_HELPER_BUILD_BUG_ON(structsize) \
 -	BUILD_BUG_ON((structsize) > FIELD_SIZEOF(struct nf_conn_help, data))
 -
  struct nf_conntrack_helper *__nf_conntrack_helper_find(const char *name,
  						       u16 l3num, u8 protonum);
  
diff --cc net/netfilter/nf_conntrack_ftp.c
index 008eb2e1d59a,32aeac1c4760..000000000000
--- a/net/netfilter/nf_conntrack_ftp.c
+++ b/net/netfilter/nf_conntrack_ftp.c
@@@ -600,13 -590,13 +602,23 @@@ static int __init nf_conntrack_ftp_init
  	/* FIXME should be configurable whether IPv4 and IPv6 FTP connections
  		 are tracked or not - YK */
  	for (i = 0; i < ports_c; i++) {
++<<<<<<< HEAD
 +		nf_ct_helper_init(&ftp[2 * i], AF_INET, IPPROTO_TCP, "ftp",
 +				  FTP_PORT, ports[i], ports[i], &ftp_exp_policy,
 +				  0, sizeof(struct nf_ct_ftp_master), help,
 +				  nf_ct_ftp_from_nlattr, THIS_MODULE);
 +		nf_ct_helper_init(&ftp[2 * i + 1], AF_INET6, IPPROTO_TCP, "ftp",
 +				  FTP_PORT, ports[i], ports[i], &ftp_exp_policy,
 +				  0, sizeof(struct nf_ct_ftp_master), help,
++=======
+ 		nf_ct_helper_init(&ftp[2 * i], AF_INET, IPPROTO_TCP,
+ 				  HELPER_NAME, FTP_PORT, ports[i], ports[i],
+ 				  &ftp_exp_policy, 0, help,
+ 				  nf_ct_ftp_from_nlattr, THIS_MODULE);
+ 		nf_ct_helper_init(&ftp[2 * i + 1], AF_INET6, IPPROTO_TCP,
+ 				  HELPER_NAME, FTP_PORT, ports[i], ports[i],
+ 				  &ftp_exp_policy, 0, help,
++>>>>>>> 08010a216026 (netfilter: add API to manage NAT helpers.)
  				  nf_ct_ftp_from_nlattr, THIS_MODULE);
  	}
  
diff --cc net/netfilter/nf_conntrack_helper.c
index 09d6b67a8f86,918df7f71c8f..000000000000
--- a/net/netfilter/nf_conntrack_helper.c
+++ b/net/netfilter/nf_conntrack_helper.c
@@@ -38,72 -37,14 +38,75 @@@ unsigned int nf_ct_helper_hsize __read_
  EXPORT_SYMBOL_GPL(nf_ct_helper_hsize);
  static unsigned int nf_ct_helper_count __read_mostly;
  
 -static bool nf_ct_auto_assign_helper __read_mostly = false;
 +static bool nf_ct_auto_assign_helper __read_mostly = true;
  module_param_named(nf_conntrack_helper, nf_ct_auto_assign_helper, bool, 0644);
  MODULE_PARM_DESC(nf_conntrack_helper,
 -		 "Enable automatic conntrack helper assignment (default 0)");
 +		 "Enable automatic conntrack helper assignment (default 1)");
 +
 +#ifdef CONFIG_SYSCTL
 +static struct ctl_table helper_sysctl_table[] = {
 +	{
 +		.procname	= "nf_conntrack_helper",
 +		.data		= &init_net.ct.sysctl_auto_assign_helper,
 +		.maxlen		= sizeof(unsigned int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec,
 +	},
 +	{}
 +};
 +
 +static int nf_conntrack_helper_init_sysctl(struct net *net)
 +{
 +	struct ctl_table *table;
 +
 +	table = kmemdup(helper_sysctl_table, sizeof(helper_sysctl_table),
 +			GFP_KERNEL);
 +	if (!table)
 +		goto out;
 +
 +	table[0].data = &net->ct.sysctl_auto_assign_helper;
 +
 +	/* Don't export sysctls to unprivileged users */
 +	if (net->user_ns != &init_user_ns)
 +		table[0].procname = NULL;
 +
 +	net->ct.helper_sysctl_header =
 +		register_net_sysctl(net, "net/netfilter", table);
 +
 +	if (!net->ct.helper_sysctl_header) {
 +		pr_err("nf_conntrack_helper: can't register to sysctl.\n");
 +		goto out_register;
 +	}
 +	return 0;
 +
 +out_register:
 +	kfree(table);
 +out:
 +	return -ENOMEM;
 +}
 +
 +static void nf_conntrack_helper_fini_sysctl(struct net *net)
 +{
 +	struct ctl_table *table;
 +
 +	table = net->ct.helper_sysctl_header->ctl_table_arg;
 +	unregister_net_sysctl_table(net->ct.helper_sysctl_header);
 +	kfree(table);
 +}
 +#else
 +static int nf_conntrack_helper_init_sysctl(struct net *net)
 +{
 +	return 0;
 +}
 +
 +static void nf_conntrack_helper_fini_sysctl(struct net *net)
 +{
 +}
 +#endif /* CONFIG_SYSCTL */
  
+ static DEFINE_MUTEX(nf_ct_nat_helpers_mutex);
+ static struct list_head nf_ct_nat_helpers __read_mostly;
+ 
  /* Stupid hash, but collision free for the default registrations of the
   * helpers currently in the kernel. */
  static unsigned int helper_hash(const struct nf_conntrack_tuple *tuple)
@@@ -167,9 -126,79 +170,83 @@@ nf_conntrack_helper_try_module_get(cons
  }
  EXPORT_SYMBOL_GPL(nf_conntrack_helper_try_module_get);
  
++<<<<<<< HEAD
++=======
+ void nf_conntrack_helper_put(struct nf_conntrack_helper *helper)
+ {
+ 	refcount_dec(&helper->refcnt);
+ 	module_put(helper->me);
+ }
+ EXPORT_SYMBOL_GPL(nf_conntrack_helper_put);
+ 
+ static struct nf_conntrack_nat_helper *
+ nf_conntrack_nat_helper_find(const char *mod_name)
+ {
+ 	struct nf_conntrack_nat_helper *cur;
+ 	bool found = false;
+ 
+ 	list_for_each_entry_rcu(cur, &nf_ct_nat_helpers, list) {
+ 		if (!strcmp(cur->mod_name, mod_name)) {
+ 			found = true;
+ 			break;
+ 		}
+ 	}
+ 	return found ? cur : NULL;
+ }
+ 
+ int
+ nf_nat_helper_try_module_get(const char *name, u16 l3num, u8 protonum)
+ {
+ 	struct nf_conntrack_helper *h;
+ 	struct nf_conntrack_nat_helper *nat;
+ 	char mod_name[NF_CT_HELPER_NAME_LEN];
+ 	int ret = 0;
+ 
+ 	rcu_read_lock();
+ 	h = __nf_conntrack_helper_find(name, l3num, protonum);
+ 	if (!h) {
+ 		rcu_read_unlock();
+ 		return -ENOENT;
+ 	}
+ 
+ 	nat = nf_conntrack_nat_helper_find(h->nat_mod_name);
+ 	if (!nat) {
+ 		snprintf(mod_name, sizeof(mod_name), "%s", h->nat_mod_name);
+ 		rcu_read_unlock();
+ 		request_module(mod_name);
+ 
+ 		rcu_read_lock();
+ 		nat = nf_conntrack_nat_helper_find(mod_name);
+ 		if (!nat) {
+ 			rcu_read_unlock();
+ 			return -ENOENT;
+ 		}
+ 	}
+ 
+ 	if (!try_module_get(nat->module))
+ 		ret = -ENOENT;
+ 
+ 	rcu_read_unlock();
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(nf_nat_helper_try_module_get);
+ 
+ void nf_nat_helper_put(struct nf_conntrack_helper *helper)
+ {
+ 	struct nf_conntrack_nat_helper *nat;
+ 
+ 	nat = nf_conntrack_nat_helper_find(helper->nat_mod_name);
+ 	if (WARN_ON_ONCE(!nat))
+ 		return;
+ 
+ 	module_put(nat->module);
+ }
+ EXPORT_SYMBOL_GPL(nf_nat_helper_put);
+ 
++>>>>>>> 08010a216026 (netfilter: add API to manage NAT helpers.)
  struct nf_conn_help *
 -nf_ct_helper_ext_add(struct nf_conn *ct, gfp_t gfp)
 +nf_ct_helper_ext_add(struct nf_conn *ct,
 +		     struct nf_conntrack_helper *helper, gfp_t gfp)
  {
  	struct nf_conn_help *help;
  
@@@ -506,7 -535,23 +585,27 @@@ void nf_conntrack_helpers_unregister(st
  }
  EXPORT_SYMBOL_GPL(nf_conntrack_helpers_unregister);
  
++<<<<<<< HEAD
 +static struct nf_ct_ext_type helper_extend __read_mostly = {
++=======
+ void nf_nat_helper_register(struct nf_conntrack_nat_helper *nat)
+ {
+ 	mutex_lock(&nf_ct_nat_helpers_mutex);
+ 	list_add_rcu(&nat->list, &nf_ct_nat_helpers);
+ 	mutex_unlock(&nf_ct_nat_helpers_mutex);
+ }
+ EXPORT_SYMBOL_GPL(nf_nat_helper_register);
+ 
+ void nf_nat_helper_unregister(struct nf_conntrack_nat_helper *nat)
+ {
+ 	mutex_lock(&nf_ct_nat_helpers_mutex);
+ 	list_del_rcu(&nat->list);
+ 	mutex_unlock(&nf_ct_nat_helpers_mutex);
+ }
+ EXPORT_SYMBOL_GPL(nf_nat_helper_unregister);
+ 
+ static const struct nf_ct_ext_type helper_extend = {
++>>>>>>> 08010a216026 (netfilter: add API to manage NAT helpers.)
  	.len	= sizeof(struct nf_conn_help),
  	.align	= __alignof__(struct nf_conn_help),
  	.id	= NF_CT_EXT_HELPER,
@@@ -538,9 -578,10 +637,10 @@@ int nf_conntrack_helper_init(void
  		goto out_extend;
  	}
  
+ 	INIT_LIST_HEAD(&nf_ct_nat_helpers);
  	return 0;
  out_extend:
 -	kvfree(nf_ct_helper_hash);
 +	nf_ct_free_hashtable(nf_ct_helper_hash, nf_ct_helper_hsize);
  	return ret;
  }
  
diff --cc net/netfilter/nf_conntrack_sane.c
index 9dcb9ee9b97d,83306648dd0f..000000000000
--- a/net/netfilter/nf_conntrack_sane.c
+++ b/net/netfilter/nf_conntrack_sane.c
@@@ -194,15 -197,13 +196,25 @@@ static int __init nf_conntrack_sane_ini
  	/* FIXME should be configurable whether IPv4 and IPv6 connections
  		 are tracked or not - YK */
  	for (i = 0; i < ports_c; i++) {
++<<<<<<< HEAD
 +		nf_ct_helper_init(&sane[2 * i], AF_INET, IPPROTO_TCP, "sane",
 +				  SANE_PORT, ports[i], ports[i],
 +				  &sane_exp_policy, 0,
 +				  sizeof(struct nf_ct_sane_master), help, NULL,
 +				  THIS_MODULE);
 +		nf_ct_helper_init(&sane[2 * i + 1], AF_INET6, IPPROTO_TCP, "sane",
 +				  SANE_PORT, ports[i], ports[i],
 +				  &sane_exp_policy, 0,
 +				  sizeof(struct nf_ct_sane_master), help, NULL,
++=======
+ 		nf_ct_helper_init(&sane[2 * i], AF_INET, IPPROTO_TCP,
+ 				  HELPER_NAME, SANE_PORT, ports[i], ports[i],
+ 				  &sane_exp_policy, 0, help, NULL,
+ 				  THIS_MODULE);
+ 		nf_ct_helper_init(&sane[2 * i + 1], AF_INET6, IPPROTO_TCP,
+ 				  HELPER_NAME, SANE_PORT, ports[i], ports[i],
+ 				  &sane_exp_policy, 0, help, NULL,
++>>>>>>> 08010a216026 (netfilter: add API to manage NAT helpers.)
  				  THIS_MODULE);
  	}
  
diff --cc net/netfilter/nf_conntrack_sip.c
index c3b867d895e4,c30c883c370b..000000000000
--- a/net/netfilter/nf_conntrack_sip.c
+++ b/net/netfilter/nf_conntrack_sip.c
@@@ -1682,25 -1671,21 +1684,43 @@@ static int __init nf_conntrack_sip_init
  		ports[ports_c++] = SIP_PORT;
  
  	for (i = 0; i < ports_c; i++) {
++<<<<<<< HEAD
 +		nf_ct_helper_init(&sip[4 * i], AF_INET, IPPROTO_UDP, "sip",
 +				  SIP_PORT, ports[i], i, sip_exp_policy,
 +				  SIP_EXPECT_MAX,
 +				  sizeof(struct nf_ct_sip_master), sip_help_udp,
 +				  NULL, THIS_MODULE);
 +		nf_ct_helper_init(&sip[4 * i + 1], AF_INET, IPPROTO_TCP, "sip",
 +				  SIP_PORT, ports[i], i, sip_exp_policy,
 +				  SIP_EXPECT_MAX,
 +				  sizeof(struct nf_ct_sip_master), sip_help_tcp,
 +				  NULL, THIS_MODULE);
 +		nf_ct_helper_init(&sip[4 * i + 2], AF_INET6, IPPROTO_UDP, "sip",
 +				  SIP_PORT, ports[i], i, sip_exp_policy,
 +				  SIP_EXPECT_MAX,
 +				  sizeof(struct nf_ct_sip_master), sip_help_udp,
 +				  NULL, THIS_MODULE);
 +		nf_ct_helper_init(&sip[4 * i + 3], AF_INET6, IPPROTO_TCP, "sip",
 +				  SIP_PORT, ports[i], i, sip_exp_policy,
 +				  SIP_EXPECT_MAX,
 +				  sizeof(struct nf_ct_sip_master), sip_help_tcp,
++=======
+ 		nf_ct_helper_init(&sip[4 * i], AF_INET, IPPROTO_UDP,
+ 				  HELPER_NAME, SIP_PORT, ports[i], i,
+ 				  sip_exp_policy, SIP_EXPECT_MAX, sip_help_udp,
+ 				  NULL, THIS_MODULE);
+ 		nf_ct_helper_init(&sip[4 * i + 1], AF_INET, IPPROTO_TCP,
+ 				  HELPER_NAME, SIP_PORT, ports[i], i,
+ 				  sip_exp_policy, SIP_EXPECT_MAX, sip_help_tcp,
+ 				  NULL, THIS_MODULE);
+ 		nf_ct_helper_init(&sip[4 * i + 2], AF_INET6, IPPROTO_UDP,
+ 				  HELPER_NAME, SIP_PORT, ports[i], i,
+ 				  sip_exp_policy, SIP_EXPECT_MAX, sip_help_udp,
+ 				  NULL, THIS_MODULE);
+ 		nf_ct_helper_init(&sip[4 * i + 3], AF_INET6, IPPROTO_TCP,
+ 				  HELPER_NAME, SIP_PORT, ports[i], i,
+ 				  sip_exp_policy, SIP_EXPECT_MAX, sip_help_tcp,
++>>>>>>> 08010a216026 (netfilter: add API to manage NAT helpers.)
  				  NULL, THIS_MODULE);
  	}
  
diff --cc net/netfilter/nf_conntrack_tftp.c
index b1227dc6f75e,6977cb91ae9a..000000000000
--- a/net/netfilter/nf_conntrack_tftp.c
+++ b/net/netfilter/nf_conntrack_tftp.c
@@@ -117,12 -121,14 +119,23 @@@ static int __init nf_conntrack_tftp_ini
  		ports[ports_c++] = TFTP_PORT;
  
  	for (i = 0; i < ports_c; i++) {
++<<<<<<< HEAD
 +		nf_ct_helper_init(&tftp[2 * i], AF_INET, IPPROTO_UDP, "tftp",
 +				  TFTP_PORT, ports[i], i, &tftp_exp_policy,
 +				  0, 0, tftp_help, NULL, THIS_MODULE);
 +		nf_ct_helper_init(&tftp[2 * i + 1], AF_INET6, IPPROTO_UDP, "tftp",
 +				  TFTP_PORT, ports[i], i, &tftp_exp_policy,
 +				  0, 0, tftp_help, NULL, THIS_MODULE);
++=======
+ 		nf_ct_helper_init(&tftp[2 * i], AF_INET, IPPROTO_UDP,
+ 				  HELPER_NAME, TFTP_PORT, ports[i], i,
+ 				  &tftp_exp_policy, 0, tftp_help, NULL,
+ 				  THIS_MODULE);
+ 		nf_ct_helper_init(&tftp[2 * i + 1], AF_INET6, IPPROTO_UDP,
+ 				  HELPER_NAME, TFTP_PORT, ports[i], i,
+ 				  &tftp_exp_policy, 0, tftp_help, NULL,
+ 				  THIS_MODULE);
++>>>>>>> 08010a216026 (netfilter: add API to manage NAT helpers.)
  	}
  
  	ret = nf_conntrack_helpers_register(tftp, ports_c * 2);
* Unmerged path include/net/netfilter/nf_conntrack_helper.h
diff --git a/net/netfilter/nf_conntrack_amanda.c b/net/netfilter/nf_conntrack_amanda.c
index 57a26cc90c9f..5641f9cbc71f 100644
--- a/net/netfilter/nf_conntrack_amanda.c
+++ b/net/netfilter/nf_conntrack_amanda.c
@@ -28,11 +28,13 @@
 static unsigned int master_timeout __read_mostly = 300;
 static char *ts_algo = "kmp";
 
+#define HELPER_NAME "amanda"
+
 MODULE_AUTHOR("Brian J. Murrell <netfilter@interlinx.bc.ca>");
 MODULE_DESCRIPTION("Amanda connection tracking module");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("ip_conntrack_amanda");
-MODULE_ALIAS_NFCT_HELPER("amanda");
+MODULE_ALIAS_NFCT_HELPER(HELPER_NAME);
 
 module_param(master_timeout, uint, 0600);
 MODULE_PARM_DESC(master_timeout, "timeout for the master connection");
@@ -174,13 +176,14 @@ static const struct nf_conntrack_expect_policy amanda_exp_policy = {
 
 static struct nf_conntrack_helper amanda_helper[2] __read_mostly = {
 	{
-		.name			= "amanda",
+		.name			= HELPER_NAME,
 		.me			= THIS_MODULE,
 		.help			= amanda_help,
 		.tuple.src.l3num	= AF_INET,
 		.tuple.src.u.udp.port	= cpu_to_be16(10080),
 		.tuple.dst.protonum	= IPPROTO_UDP,
 		.expect_policy		= &amanda_exp_policy,
+		.nat_mod_name		= NF_NAT_HELPER_NAME(HELPER_NAME),
 	},
 	{
 		.name			= "amanda",
@@ -190,6 +193,7 @@ static struct nf_conntrack_helper amanda_helper[2] __read_mostly = {
 		.tuple.src.u.udp.port	= cpu_to_be16(10080),
 		.tuple.dst.protonum	= IPPROTO_UDP,
 		.expect_policy		= &amanda_exp_policy,
+		.nat_mod_name		= NF_NAT_HELPER_NAME(HELPER_NAME),
 	},
 };
 
* Unmerged path net/netfilter/nf_conntrack_ftp.c
* Unmerged path net/netfilter/nf_conntrack_helper.c
diff --git a/net/netfilter/nf_conntrack_irc.c b/net/netfilter/nf_conntrack_irc.c
index 1972a149f958..0bc277a1440e 100644
--- a/net/netfilter/nf_conntrack_irc.c
+++ b/net/netfilter/nf_conntrack_irc.c
@@ -42,11 +42,13 @@ unsigned int (*nf_nat_irc_hook)(struct sk_buff *skb,
 				struct nf_conntrack_expect *exp) __read_mostly;
 EXPORT_SYMBOL_GPL(nf_nat_irc_hook);
 
+#define HELPER_NAME "irc"
+
 MODULE_AUTHOR("Harald Welte <laforge@netfilter.org>");
 MODULE_DESCRIPTION("IRC (DCC) connection tracking helper");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("ip_conntrack_irc");
-MODULE_ALIAS_NFCT_HELPER("irc");
+MODULE_ALIAS_NFCT_HELPER(HELPER_NAME);
 
 module_param_array(ports, ushort, &ports_c, 0400);
 MODULE_PARM_DESC(ports, "port numbers of IRC servers");
@@ -255,7 +257,7 @@ static int __init nf_conntrack_irc_init(void)
 		ports[ports_c++] = IRC_PORT;
 
 	for (i = 0; i < ports_c; i++) {
-		nf_ct_helper_init(&irc[i], AF_INET, IPPROTO_TCP, "irc",
+		nf_ct_helper_init(&irc[i], AF_INET, IPPROTO_TCP, HELPER_NAME,
 				  IRC_PORT, ports[i], i, &irc_exp_policy,
 				  0, 0, help, NULL, THIS_MODULE);
 	}
* Unmerged path net/netfilter/nf_conntrack_sane.c
* Unmerged path net/netfilter/nf_conntrack_sip.c
* Unmerged path net/netfilter/nf_conntrack_tftp.c
