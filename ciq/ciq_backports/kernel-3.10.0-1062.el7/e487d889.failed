ovl: constant st_ino for non-samefs with xino

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit e487d889b7e3e8ec4091eb83bc4f7e67c7f05e27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e487d889.failed

On 64bit systems, when overlay layers are not all on the same fs, but
all inode numbers of underlying fs are not using the high bits, use the
high bits to partition the overlay st_ino address space.  The high bits
hold the fsid (upper fsid is 0).  This way overlay inode numbers are unique
and all inodes use overlay st_dev.  Inode numbers are also persistent
for a given layer configuration.

Currently, our only indication for available high ino bits is from a
filesystem that supports file handles and uses the default encode_fh()
operation, which encodes a 32bit inode number.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit e487d889b7e3e8ec4091eb83bc4f7e67c7f05e27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
#	fs/overlayfs/super.c
#	fs/overlayfs/util.c
diff --cc fs/overlayfs/inode.c
index 24ce49ae057f,51d780898d89..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -66,9 -59,73 +66,76 @@@ out
  	return err;
  }
  
 -static int ovl_map_dev_ino(struct dentry *dentry, struct kstat *stat,
 -			   struct ovl_layer *lower_layer)
 +int ovl_getattr(struct vfsmount *mnt, struct dentry *dentry,
 +		struct kstat *stat)
  {
++<<<<<<< HEAD
++=======
+ 	bool samefs = ovl_same_sb(dentry->d_sb);
+ 	unsigned int xinobits = ovl_xino_bits(dentry->d_sb);
+ 
+ 	if (samefs) {
+ 		/*
+ 		 * When all layers are on the same fs, all real inode
+ 		 * number are unique, so we use the overlay st_dev,
+ 		 * which is friendly to du -x.
+ 		 */
+ 		stat->dev = dentry->d_sb->s_dev;
+ 		return 0;
+ 	} else if (xinobits) {
+ 		unsigned int shift = 64 - xinobits;
+ 		/*
+ 		 * All inode numbers of underlying fs should not be using the
+ 		 * high xinobits, so we use high xinobits to partition the
+ 		 * overlay st_ino address space. The high bits holds the fsid
+ 		 * (upper fsid is 0). This way overlay inode numbers are unique
+ 		 * and all inodes use overlay st_dev. Inode numbers are also
+ 		 * persistent for a given layer configuration.
+ 		 */
+ 		if (stat->ino >> shift) {
+ 			pr_warn_ratelimited("overlayfs: inode number too big (%pd2, ino=%llu, xinobits=%d)\n",
+ 					    dentry, stat->ino, xinobits);
+ 		} else {
+ 			if (lower_layer)
+ 				stat->ino |= ((u64)lower_layer->fsid) << shift;
+ 
+ 			stat->dev = dentry->d_sb->s_dev;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	/* The inode could not be mapped to a unified st_ino address space */
+ 	if (S_ISDIR(dentry->d_inode->i_mode)) {
+ 		/*
+ 		 * Always use the overlay st_dev for directories, so 'find
+ 		 * -xdev' will scan the entire overlay mount and won't cross the
+ 		 * overlay mount boundaries.
+ 		 *
+ 		 * If not all layers are on the same fs the pair {real st_ino;
+ 		 * overlay st_dev} is not unique, so use the non persistent
+ 		 * overlay st_ino for directories.
+ 		 */
+ 		stat->dev = dentry->d_sb->s_dev;
+ 		stat->ino = dentry->d_inode->i_ino;
+ 	} else if (lower_layer && lower_layer->fsid) {
+ 		/*
+ 		 * For non-samefs setup, if we cannot map all layers st_ino
+ 		 * to a unified address space, we need to make sure that st_dev
+ 		 * is unique per lower fs. Upper layer uses real st_dev and
+ 		 * lower layers use the unique anonymous bdev assigned to the
+ 		 * lower fs.
+ 		 */
+ 		stat->dev = lower_layer->fs->pseudo_dev;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int ovl_getattr(const struct path *path, struct kstat *stat,
+ 		u32 request_mask, unsigned int flags)
+ {
+ 	struct dentry *dentry = path->dentry;
++>>>>>>> e487d889b7e3 (ovl: constant st_ino for non-samefs with xino)
  	enum ovl_path_type type;
  	struct path realpath;
  	const struct cred *old_cred;
@@@ -83,18 -141,24 +150,32 @@@
  		goto out;
  
  	/*
++<<<<<<< HEAD
 +	 * For non-dir or same fs, we use st_ino of the copy up origin, if we
 +	 * know it. This guaranties constant st_dev/st_ino across copy up.
++=======
+ 	 * For non-dir or same fs, we use st_ino of the copy up origin.
+ 	 * This guaranties constant st_dev/st_ino across copy up.
+ 	 * With xino feature and non-samefs, we use st_ino of the copy up
+ 	 * origin masked with high bits that represent the layer id.
++>>>>>>> e487d889b7e3 (ovl: constant st_ino for non-samefs with xino)
  	 *
 -	 * If lower filesystem supports NFS file handles, this also guaranties
 +	 * If filesystem supports NFS export ops, this also guaranties
  	 * persistent st_ino across mount cycle.
  	 */
++<<<<<<< HEAD
 +	if (!is_dir || samefs) {
 +		if (OVL_TYPE_ORIGIN(type)) {
++=======
+ 	if (!is_dir || samefs || ovl_xino_bits(dentry->d_sb)) {
+ 		if (!OVL_TYPE_UPPER(type)) {
+ 			lower_layer = ovl_layer_lower(dentry);
+ 		} else if (OVL_TYPE_ORIGIN(type)) {
++>>>>>>> e487d889b7e3 (ovl: constant st_ino for non-samefs with xino)
  			struct kstat lowerstat;
 -			u32 lowermask = STATX_INO | (!is_dir ? STATX_NLINK : 0);
  
  			ovl_path_lower(dentry, &realpath);
 -			err = vfs_getattr(&realpath, &lowerstat,
 -					  lowermask, flags);
 +			err = vfs_getattr(&realpath, &lowerstat);
  			if (err)
  				goto out;
  
diff --cc fs/overlayfs/super.c
index b0392d1737a3,d7284444f404..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -15,9 -16,8 +15,13 @@@
  #include <linux/module.h>
  #include <linux/statfs.h>
  #include <linux/seq_file.h>
 +#include <linux/magic.h>
  #include <linux/posix_acl_xattr.h>
++<<<<<<< HEAD
 +#include <linux/cred.h>
++=======
+ #include <linux/exportfs.h>
++>>>>>>> e487d889b7e3 (ovl: constant st_ino for non-samefs with xino)
  #include "overlayfs.h"
  
  MODULE_AUTHOR("Miklos Szeredi <miklos@szeredi.hu>");
@@@ -668,8 -702,8 +672,9 @@@ static int ovl_check_namelen(struct pat
  static int ovl_lower_dir(const char *name, struct path *path,
  			 struct ovl_fs *ofs, int *stack_depth, bool *remote)
  {
+ 	int fh_type;
  	int err;
 +	const int *lower_stack_depth;
  
  	err = ovl_mount_dir_noesc(name, path);
  	if (err)
@@@ -692,14 -719,22 +697,24 @@@
  		*remote = true;
  
  	/*
 -	 * The inodes index feature and NFS export need to encode and decode
 -	 * file handles, so they require that all layers support them.
 +	 * The inodes index feature needs to encode and decode file
 +	 * handles, so it requires that all layers support them.
  	 */
++<<<<<<< HEAD
 +	if (ofs->config.index && !ovl_can_decode_fh(path->dentry->d_sb)) {
++=======
+ 	fh_type = ovl_can_decode_fh(path->dentry->d_sb);
+ 	if ((ofs->config.nfs_export ||
+ 	     (ofs->config.index && ofs->config.upperdir)) && !fh_type) {
++>>>>>>> e487d889b7e3 (ovl: constant st_ino for non-samefs with xino)
  		ofs->config.index = false;
 -		ofs->config.nfs_export = false;
 -		pr_warn("overlayfs: fs on '%s' does not support file handles, falling back to index=off,nfs_export=off.\n",
 -			name);
 +		pr_warn("overlayfs: fs on '%s' does not support file handles, falling back to index=off.\n", name);
  	}
  
+ 	/* Check if lower fs has 32bit inode numbers */
+ 	if (fh_type != FILEID_INO32_GEN)
+ 		ofs->xino_bits = 0;
+ 
  	return 0;
  
  out_put:
@@@ -871,121 -909,317 +886,259 @@@ static const struct xattr_handler *ovl_
  	NULL
  };
  
 -static int ovl_get_upper(struct ovl_fs *ofs, struct path *upperpath)
 +static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
++<<<<<<< HEAD
 +	struct path upperpath = { };
++=======
+ 	struct vfsmount *upper_mnt;
+ 	int err;
+ 
+ 	err = ovl_mount_dir(ofs->config.upperdir, upperpath);
+ 	if (err)
+ 		goto out;
+ 
+ 	/* Upper fs should not be r/o */
+ 	if (sb_rdonly(upperpath->mnt->mnt_sb)) {
+ 		pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	err = ovl_check_namelen(upperpath, ofs, ofs->config.upperdir);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = -EBUSY;
+ 	if (ovl_inuse_trylock(upperpath->dentry)) {
+ 		ofs->upperdir_locked = true;
+ 	} else if (ofs->config.index) {
+ 		pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
+ 		goto out;
+ 	} else {
+ 		pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
+ 	}
+ 
+ 	upper_mnt = clone_private_mount(upperpath);
+ 	err = PTR_ERR(upper_mnt);
+ 	if (IS_ERR(upper_mnt)) {
+ 		pr_err("overlayfs: failed to clone upperpath\n");
+ 		goto out;
+ 	}
+ 
+ 	/* Don't inherit atime flags */
+ 	upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
+ 	ofs->upper_mnt = upper_mnt;
+ 	err = 0;
+ out:
+ 	return err;
+ }
+ 
+ static int ovl_make_workdir(struct ovl_fs *ofs, struct path *workpath)
+ {
+ 	struct vfsmount *mnt = ofs->upper_mnt;
+ 	struct dentry *temp;
+ 	int fh_type;
+ 	int err;
+ 
+ 	err = mnt_want_write(mnt);
+ 	if (err)
+ 		return err;
+ 
+ 	ofs->workdir = ovl_workdir_create(ofs, OVL_WORKDIR_NAME, false);
+ 	if (!ofs->workdir)
+ 		goto out;
+ 
+ 	/*
+ 	 * Upper should support d_type, else whiteouts are visible.  Given
+ 	 * workdir and upper are on same fs, we can do iterate_dir() on
+ 	 * workdir. This check requires successful creation of workdir in
+ 	 * previous step.
+ 	 */
+ 	err = ovl_check_d_type_supported(workpath);
+ 	if (err < 0)
+ 		goto out;
+ 
+ 	/*
+ 	 * We allowed this configuration and don't want to break users over
+ 	 * kernel upgrade. So warn instead of erroring out.
+ 	 */
+ 	if (!err)
+ 		pr_warn("overlayfs: upper fs needs to support d_type.\n");
+ 
+ 	/* Check if upper/work fs supports O_TMPFILE */
+ 	temp = ovl_do_tmpfile(ofs->workdir, S_IFREG | 0);
+ 	ofs->tmpfile = !IS_ERR(temp);
+ 	if (ofs->tmpfile)
+ 		dput(temp);
+ 	else
+ 		pr_warn("overlayfs: upper fs does not support tmpfile.\n");
+ 
+ 	/*
+ 	 * Check if upper/work fs supports trusted.overlay.* xattr
+ 	 */
+ 	err = ovl_do_setxattr(ofs->workdir, OVL_XATTR_OPAQUE, "0", 1, 0);
+ 	if (err) {
+ 		ofs->noxattr = true;
+ 		ofs->config.index = false;
+ 		pr_warn("overlayfs: upper fs does not support xattr, falling back to index=off.\n");
+ 		err = 0;
+ 	} else {
+ 		vfs_removexattr(ofs->workdir, OVL_XATTR_OPAQUE);
+ 	}
+ 
+ 	/* Check if upper/work fs supports file handles */
+ 	fh_type = ovl_can_decode_fh(ofs->workdir->d_sb);
+ 	if (ofs->config.index && !fh_type) {
+ 		ofs->config.index = false;
+ 		pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
+ 	}
+ 
+ 	/* Check if upper fs has 32bit inode numbers */
+ 	if (fh_type != FILEID_INO32_GEN)
+ 		ofs->xino_bits = 0;
+ 
+ 	/* NFS export of r/w mount depends on index */
+ 	if (ofs->config.nfs_export && !ofs->config.index) {
+ 		pr_warn("overlayfs: NFS export requires \"index=on\", falling back to nfs_export=off.\n");
+ 		ofs->config.nfs_export = false;
+ 	}
+ 
+ out:
+ 	mnt_drop_write(mnt);
+ 	return err;
+ }
+ 
+ static int ovl_get_workdir(struct ovl_fs *ofs, struct path *upperpath)
+ {
+ 	int err;
++>>>>>>> e487d889b7e3 (ovl: constant st_ino for non-samefs with xino)
  	struct path workpath = { };
 -
 -	err = ovl_mount_dir(ofs->config.workdir, &workpath);
 -	if (err)
 -		goto out;
 -
 -	err = -EINVAL;
 -	if (upperpath->mnt != workpath.mnt) {
 -		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 -		goto out;
 -	}
 -	if (!ovl_workdir_ok(workpath.dentry, upperpath->dentry)) {
 -		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 -		goto out;
 -	}
 -
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(workpath.dentry)) {
 -		ofs->workdir_locked = true;
 -	} else if (ofs->config.index) {
 -		pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 -	}
 -
 -	ofs->workbasedir = dget(workpath.dentry);
 -	err = ovl_make_workdir(ofs, &workpath);
 -	if (err)
 -		goto out;
 -
 -	err = 0;
 -out:
 -	path_put(&workpath);
 -
 -	return err;
 -}
 -
 -static int ovl_get_indexdir(struct ovl_fs *ofs, struct ovl_entry *oe,
 -			    struct path *upperpath)
 -{
 -	struct vfsmount *mnt = ofs->upper_mnt;
 +	struct dentry *root_dentry;
 +	struct ovl_entry *oe;
 +	struct ovl_fs *ufs;
 +	const int *upper_stack_depth;
 +	int *overlay_stack_depth;
 +	struct path *stack = NULL;
 +	char *lowertmp;
 +	char *lower;
 +	unsigned int numlower;
 +	unsigned int stacklen = 0;
 +	unsigned int i;
 +	bool remote = false;
 +	struct cred *cred;
  	int err;
  
 -	err = mnt_want_write(mnt);
 -	if (err)
 -		return err;
 -
 -	/* Verify lower root is upper root origin */
 -	err = ovl_verify_origin(upperpath->dentry, oe->lowerstack[0].dentry,
 -				true);
 -	if (err) {
 -		pr_err("overlayfs: failed to verify upper root origin\n");
 +	err = -ENOMEM;
 +	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
 +	if (!ufs)
  		goto out;
 -	}
 -
 -	ofs->indexdir = ovl_workdir_create(ofs, OVL_INDEXDIR_NAME, true);
 -	if (ofs->indexdir) {
 -		/*
 -		 * Verify upper root is exclusively associated with index dir.
 -		 * Older kernels stored upper fh in "trusted.overlay.origin"
 -		 * xattr. If that xattr exists, verify that it is a match to
 -		 * upper dir file handle. In any case, verify or set xattr
 -		 * "trusted.overlay.upper" to indicate that index may have
 -		 * directory entries.
 -		 */
 -		if (ovl_check_origin_xattr(ofs->indexdir)) {
 -			err = ovl_verify_set_fh(ofs->indexdir, OVL_XATTR_ORIGIN,
 -						upperpath->dentry, true, false);
 -			if (err)
 -				pr_err("overlayfs: failed to verify index dir 'origin' xattr\n");
 -		}
 -		err = ovl_verify_upper(ofs->indexdir, upperpath->dentry, true);
 -		if (err)
 -			pr_err("overlayfs: failed to verify index dir 'upper' xattr\n");
 -
 -		/* Cleanup bad/stale/orphan index entries */
 -		if (!err)
 -			err = ovl_indexdir_cleanup(ofs);
 -	}
 -	if (err || !ofs->indexdir)
 -		pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
  
 -out:
 -	mnt_drop_write(mnt);
 -	return err;
 -}
 -
 -/* Get a unique fsid for the layer */
 -static int ovl_get_fsid(struct ovl_fs *ofs, struct super_block *sb)
 -{
 -	unsigned int i;
 -	dev_t dev;
 -	int err;
 -
 -	/* fsid 0 is reserved for upper fs even with non upper overlay */
 -	if (ofs->upper_mnt && ofs->upper_mnt->mnt_sb == sb)
 -		return 0;
 +	ufs->config.index = ovl_index_def;
 +	err = ovl_parse_opt((char *) data, &ufs->config);
 +	if (err)
 +		goto out_free_config;
  
 -	for (i = 0; i < ofs->numlowerfs; i++) {
 -		if (ofs->lower_fs[i].sb == sb)
 -			return i + 1;
 +	err = -EINVAL;
 +	if (!ufs->config.lowerdir) {
 +		if (!silent)
 +			pr_err("overlayfs: missing 'lowerdir'\n");
 +		goto out_free_config;
  	}
  
 -	err = get_anon_bdev(&dev);
 -	if (err) {
 -		pr_err("overlayfs: failed to get anonymous bdev for lowerpath\n");
 -		return err;
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_free_config;
  	}
 +	*overlay_stack_depth = 0;
  
 -	ofs->lower_fs[ofs->numlowerfs].sb = sb;
 -	ofs->lower_fs[ofs->numlowerfs].pseudo_dev = dev;
 -	ofs->numlowerfs++;
 -
 -	return ofs->numlowerfs;
 -}
 -
 -static int ovl_get_lower_layers(struct ovl_fs *ofs, struct path *stack,
 -				unsigned int numlower)
 -{
 -	int err;
 -	unsigned int i;
 -
 -	err = -ENOMEM;
 -	ofs->lower_layers = kcalloc(numlower, sizeof(struct ovl_layer),
 -				    GFP_KERNEL);
 -	if (ofs->lower_layers == NULL)
 -		goto out;
 -
 -	ofs->lower_fs = kcalloc(numlower, sizeof(struct ovl_sb),
 -				GFP_KERNEL);
 -	if (ofs->lower_fs == NULL)
 -		goto out;
 -
 -	for (i = 0; i < numlower; i++) {
 -		struct vfsmount *mnt;
 -		int fsid;
 +	sb->s_maxbytes = MAX_LFS_FILESIZE;
 +	if (ufs->config.upperdir) {
 +		if (!ufs->config.workdir) {
 +			pr_err("overlayfs: missing 'workdir'\n");
 +			goto out_free_config;
 +		}
  
 -		err = fsid = ovl_get_fsid(ofs, stack[i].mnt->mnt_sb);
 -		if (err < 0)
 -			goto out;
 +		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 +		if (err)
 +			goto out_free_config;
  
 -		mnt = clone_private_mount(&stack[i]);
 -		err = PTR_ERR(mnt);
 -		if (IS_ERR(mnt)) {
 -			pr_err("overlayfs: failed to clone lowerpath\n");
 -			goto out;
 +		/* Upper fs should not be r/o */
 +		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
 +			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 +			err = -EINVAL;
 +			goto out_put_upperpath;
  		}
  
 -		/*
 -		 * Make lower layers R/O.  That way fchmod/fchown on lower file
 -		 * will fail instead of modifying lower fs.
 -		 */
 -		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
 -
 -		ofs->lower_layers[ofs->numlower].mnt = mnt;
 -		ofs->lower_layers[ofs->numlower].idx = i + 1;
 -		ofs->lower_layers[ofs->numlower].fsid = fsid;
 -		if (fsid) {
 -			ofs->lower_layers[ofs->numlower].fs =
 -				&ofs->lower_fs[fsid - 1];
 +		err = ovl_check_namelen(&upperpath, ufs, ufs->config.upperdir);
 +		if (err)
 +			goto out_put_upperpath;
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(upperpath.dentry)) {
 +			ufs->upperdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 +			goto out_put_upperpath;
 +		} else {
 +			pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
  		}
++<<<<<<< HEAD
++=======
+ 		ofs->numlower++;
+ 	}
+ 
+ 	/* When all layers on same fs, overlay can use real inode numbers */
+ 	if (!ofs->numlowerfs || (ofs->numlowerfs == 1 && !ofs->upper_mnt))
+ 		ofs->xino_bits = 0;
+ 
+ 	err = 0;
+ out:
+ 	return err;
+ }
++>>>>>>> e487d889b7e3 (ovl: constant st_ino for non-samefs with xino)
  
 -static struct ovl_entry *ovl_get_lowerstack(struct super_block *sb,
 -					    struct ovl_fs *ofs)
 -{
 -	int err;
 -	char *lowertmp, *lower;
 -	struct path *stack = NULL;
 -	unsigned int stacklen, numlower = 0, i;
 -	bool remote = false;
 -	struct ovl_entry *oe;
 +		err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +		if (err)
 +			goto out_unlock_upperdentry;
 +
 +		err = -EINVAL;
 +		if (upperpath.mnt != workpath.mnt) {
 +			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +			goto out_put_workpath;
 +		}
 +		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +			goto out_put_workpath;
 +		}
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(workpath.dentry)) {
 +			ufs->workdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 +			goto out_put_workpath;
 +		} else {
 +			pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
 +
 +		ufs->workbasedir = workpath.dentry;
 +		upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +		err = -EOPNOTSUPP;
 +		if (!upper_stack_depth) {
 +			pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +			goto out_put_workpath;
 +		}
 +
 +		*overlay_stack_depth = *upper_stack_depth;
 +	}
  
  	err = -ENOMEM;
 -	lowertmp = kstrdup(ofs->config.lowerdir, GFP_KERNEL);
 +	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
  	if (!lowertmp)
 -		goto out_err;
 +		goto out_unlock_workdentry;
  
  	err = -EINVAL;
  	stacklen = ovl_split_lowerdirs(lowertmp);
@@@ -1015,155 -1253,132 +1168,229 @@@
  	}
  
  	err = -EINVAL;
 -	sb->s_stack_depth++;
 -	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 +	*overlay_stack_depth += 1;
 +	if (*overlay_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
  		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 -		goto out_err;
 +		goto out_put_lowerpath;
  	}
  
++<<<<<<< HEAD
 +	if (ufs->config.upperdir) {
 +		ufs->upper_mnt = clone_private_mount(&upperpath);
 +		err = PTR_ERR(ufs->upper_mnt);
 +		if (IS_ERR(ufs->upper_mnt)) {
 +			pr_err("overlayfs: failed to clone upperpath\n");
 +			goto out_put_lowerpath;
++=======
+ 	err = ovl_get_lower_layers(ofs, stack, numlower);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	err = -ENOMEM;
+ 	oe = ovl_alloc_entry(numlower);
+ 	if (!oe)
+ 		goto out_err;
+ 
+ 	for (i = 0; i < numlower; i++) {
+ 		oe->lowerstack[i].dentry = dget(stack[i].dentry);
+ 		oe->lowerstack[i].layer = &ofs->lower_layers[i];
+ 	}
+ 
+ 	if (remote)
+ 		sb->s_d_op = &ovl_reval_dentry_operations;
+ 	else
+ 		sb->s_d_op = &ovl_dentry_operations;
+ 
+ out:
+ 	for (i = 0; i < numlower; i++)
+ 		path_put(&stack[i]);
+ 	kfree(stack);
+ 	kfree(lowertmp);
+ 
+ 	return oe;
+ 
+ out_err:
+ 	oe = ERR_PTR(err);
+ 	goto out;
+ }
+ 
+ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
+ {
+ 	struct path upperpath = { };
+ 	struct dentry *root_dentry;
+ 	struct ovl_entry *oe;
+ 	struct ovl_fs *ofs;
+ 	struct cred *cred;
+ 	int err;
+ 
+ 	err = -ENOMEM;
+ 	ofs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
+ 	if (!ofs)
+ 		goto out;
+ 
+ 	ofs->creator_cred = cred = prepare_creds();
+ 	if (!cred)
+ 		goto out_err;
+ 
+ 	ofs->config.index = ovl_index_def;
+ 	ofs->config.nfs_export = ovl_nfs_export_def;
+ 	err = ovl_parse_opt((char *) data, &ofs->config);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	err = -EINVAL;
+ 	if (!ofs->config.lowerdir) {
+ 		if (!silent)
+ 			pr_err("overlayfs: missing 'lowerdir'\n");
+ 		goto out_err;
+ 	}
+ 
+ 	sb->s_stack_depth = 0;
+ 	sb->s_maxbytes = MAX_LFS_FILESIZE;
+ 	/* Assume underlaying fs uses 32bit inodes unless proven otherwise */
+ 	ofs->xino_bits = BITS_PER_LONG - 32;
+ 	if (ofs->config.upperdir) {
+ 		if (!ofs->config.workdir) {
+ 			pr_err("overlayfs: missing 'workdir'\n");
+ 			goto out_err;
++>>>>>>> e487d889b7e3 (ovl: constant st_ino for non-samefs with xino)
  		}
  
 -		err = ovl_get_upper(ofs, &upperpath);
 -		if (err)
 -			goto out_err;
 +		/* Don't inherit atime flags */
 +		ufs->upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
  
 -		err = ovl_get_workdir(ofs, &upperpath);
 -		if (err)
 -			goto out_err;
 -
 -		if (!ofs->workdir)
 -			sb->s_flags |= SB_RDONLY;
 +		sb->s_time_gran = ufs->upper_mnt->mnt_sb->s_time_gran;
  
 -		sb->s_stack_depth = ofs->upper_mnt->mnt_sb->s_stack_depth;
 -		sb->s_time_gran = ofs->upper_mnt->mnt_sb->s_time_gran;
 +		ufs->workdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 +						  OVL_WORKDIR_NAME, false);
 +		/*
 +		 * Upper should support d_type, else whiteouts are visible.
 +		 * Given workdir and upper are on same fs, we can do
 +		 * iterate_dir() on workdir. This check requires successful
 +		 * creation of workdir in previous step.
 +		 */
 +		if (ufs->workdir) {
 +			struct dentry *temp;
 +
 +			err = ovl_check_d_type_supported(&workpath);
 +			if (err < 0)
 +				goto out_put_workdir;
 +
 +			/*
 +			 * Warn instead of error to avoid breaking previously
 +			 * working configurations over upgrade. If d_type
 +			 * is not supported, whiteouts will become visible
 +			 * to user space.
 +			 */
 +			if (!err)
 +				pr_warn("overlayfs: upper fs needs to support d_type. This is an invalid configuration.\n");
 +
 +			/* Check if upper/work fs supports O_TMPFILE */
 +			temp = ovl_do_tmpfile(ufs->workdir, S_IFREG | 0);
 +			ufs->tmpfile = !IS_ERR(temp);
 +			if (ufs->tmpfile)
 +				dput(temp);
 +
 +			/*
 +			 * Check if upper/work fs supports trusted.overlay.*
 +			 * xattr
 +			 */
 +			err = ovl_do_setxattr(ufs->workdir, OVL_XATTR_OPAQUE,
 +					      "0", 1, 0);
 +			if (err) {
 +				ufs->noxattr = true;
 +				pr_warn("overlayfs: upper fs does not support xattr.\n");
 +			} else {
 +				vfs_removexattr(ufs->workdir, OVL_XATTR_OPAQUE);
 +			}
  
 +			/* Check if upper/work fs supports file handles */
 +			if (ufs->config.index &&
 +			    !ovl_can_decode_fh(ufs->workdir->d_sb)) {
 +				ufs->config.index = false;
 +				pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
 +			}
 +		}
  	}
 -	oe = ovl_get_lowerstack(sb, ofs);
 -	err = PTR_ERR(oe);
 -	if (IS_ERR(oe))
 -		goto out_err;
  
 -	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
 -	if (!ofs->upper_mnt)
 -		sb->s_flags |= SB_RDONLY;
 -
 -	if (!(ovl_force_readonly(ofs)) && ofs->config.index) {
 -		err = ovl_get_indexdir(ofs, oe, &upperpath);
 -		if (err)
 -			goto out_free_oe;
 +	err = -ENOMEM;
 +	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
 +	if (ufs->lower_mnt == NULL)
 +		goto out_put_workdir;
 +	for (i = 0; i < numlower; i++) {
 +		struct vfsmount *mnt = clone_private_mount(&stack[i]);
  
 -		/* Force r/o mount with no index dir */
 -		if (!ofs->indexdir) {
 -			dput(ofs->workdir);
 -			ofs->workdir = NULL;
 -			sb->s_flags |= SB_RDONLY;
 +		err = PTR_ERR(mnt);
 +		if (IS_ERR(mnt)) {
 +			pr_err("overlayfs: failed to clone lowerpath\n");
 +			goto out_put_lower_mnt;
  		}
 +		/*
 +		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 +		 * will fail instead of modifying lower fs.
 +		 */
 +		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
 +
 +		ufs->lower_mnt[ufs->numlower] = mnt;
 +		ufs->numlower++;
  
 +		/* Check if all lower layers are on same sb */
 +		if (i == 0)
 +			ufs->same_sb = mnt->mnt_sb;
 +		else if (ufs->same_sb != mnt->mnt_sb)
 +			ufs->same_sb = NULL;
  	}
  
 -	/* Show index=off in /proc/mounts for forced r/o mount */
 -	if (!ofs->indexdir) {
 -		ofs->config.index = false;
 -		if (ofs->upper_mnt && ofs->config.nfs_export) {
 -			pr_warn("overlayfs: NFS export requires an index dir, falling back to nfs_export=off.\n");
 -			ofs->config.nfs_export = false;
 +	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
 +	if (!ufs->upper_mnt)
 +		sb->s_flags |= MS_RDONLY;
 +	else if (ufs->upper_mnt->mnt_sb != ufs->same_sb)
 +		ufs->same_sb = NULL;
 +
 +	if (!(ovl_force_readonly(ufs)) && ufs->config.index) {
 +		/* Verify lower root is upper root origin */
 +		err = ovl_verify_origin(upperpath.dentry, ufs->lower_mnt[0],
 +					stack[0].dentry, false, true);
 +		if (err) {
 +			pr_err("overlayfs: failed to verify upper root origin\n");
 +			goto out_put_lower_mnt;
  		}
 +
 +		ufs->indexdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 +						   OVL_INDEXDIR_NAME, true);
 +		if (ufs->indexdir) {
 +			/* Verify upper root is index dir origin */
 +			err = ovl_verify_origin(ufs->indexdir, ufs->upper_mnt,
 +						upperpath.dentry, true, true);
 +			if (err)
 +				pr_err("overlayfs: failed to verify index dir origin\n");
 +
 +			/* Cleanup bad/stale/orphan index entries */
 +			if (!err)
 +				err = ovl_indexdir_cleanup(ufs->indexdir,
 +							   ufs->upper_mnt,
 +							   stack, numlower);
 +		}
 +		if (err || !ufs->indexdir)
 +			pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
 +		if (err)
 +			goto out_put_indexdir;
  	}
  
 +	/* Show index=off/on in /proc/mounts for any of the reasons above */
 +	if (!ufs->indexdir)
 +		ufs->config.index = false;
 +
 +	if (remote)
 +		sb->s_d_op = &ovl_reval_dentry_operations.ops;
 +	else
 +		sb->s_d_op = &ovl_dentry_operations.ops;
 +
 +	err = -ENOMEM;
 +	ufs->creator_cred = cred = prepare_creds();
 +	if (!cred)
 +		goto out_put_indexdir;
 +
  	if (ofs->config.nfs_export)
  		sb->s_export_op = &ovl_export_operations;
  
diff --cc fs/overlayfs/util.c
index 92f3412841eb,6f1078028c66..000000000000
--- a/fs/overlayfs/util.c
+++ b/fs/overlayfs/util.c
@@@ -48,15 -47,29 +48,31 @@@ struct super_block *ovl_same_sb(struct 
  {
  	struct ovl_fs *ofs = sb->s_fs_info;
  
 -	if (!ofs->numlowerfs)
 -		return ofs->upper_mnt->mnt_sb;
 -	else if (ofs->numlowerfs == 1 && !ofs->upper_mnt)
 -		return ofs->lower_fs[0].sb;
 -	else
 -		return NULL;
 +	return ofs->same_sb;
  }
  
- bool ovl_can_decode_fh(struct super_block *sb)
+ /*
+  * Check if underlying fs supports file handles and try to determine encoding
+  * type, in order to deduce maximum inode number used by fs.
+  *
+  * Return 0 if file handles are not supported.
+  * Return 1 (FILEID_INO32_GEN) if fs uses the default 32bit inode encoding.
+  * Return -1 if fs uses a non default encoding with unknown inode size.
+  */
+ int ovl_can_decode_fh(struct super_block *sb)
  {
++<<<<<<< HEAD
 +	uuid_be *uuid = (uuid_be *) &sb->s_uuid;
 +
 +	return (sb->s_export_op && sb->s_export_op->fh_to_dentry &&
 +		uuid_be_cmp(*uuid, NULL_UUID_BE));
++=======
+ 	if (!sb->s_export_op || !sb->s_export_op->fh_to_dentry ||
+ 	    uuid_is_null(&sb->s_uuid))
+ 		return 0;
+ 
+ 	return sb->s_export_op->encode_fh ? -1 : FILEID_INO32_GEN;
++>>>>>>> e487d889b7e3 (ovl: constant st_ino for non-samefs with xino)
  }
  
  struct dentry *ovl_indexdir(struct super_block *sb)
* Unmerged path fs/overlayfs/inode.c
diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 403c48960f89..9761b9e8f8fc 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -189,7 +189,7 @@ void ovl_drop_write(struct dentry *dentry);
 struct dentry *ovl_workdir(struct dentry *dentry);
 const struct cred *ovl_override_creds(struct super_block *sb);
 struct super_block *ovl_same_sb(struct super_block *sb);
-bool ovl_can_decode_fh(struct super_block *sb);
+int ovl_can_decode_fh(struct super_block *sb);
 struct dentry *ovl_indexdir(struct super_block *sb);
 struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
 bool ovl_dentry_remote(struct dentry *dentry);
@@ -245,6 +245,13 @@ static inline bool ovl_is_impuredir(struct dentry *dentry)
 	return ovl_check_dir_xattr(dentry, OVL_XATTR_IMPURE);
 }
 
+static inline unsigned int ovl_xino_bits(struct super_block *sb)
+{
+	struct ovl_fs *ofs = sb->s_fs_info;
+
+	return ofs->xino_bits;
+}
+
 
 /* namei.c */
 int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index ec700f861f1b..5caebd02e28f 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -42,6 +42,8 @@ struct ovl_fs {
 	/* Did we take the inuse lock? */
 	bool upperdir_locked;
 	bool workdir_locked;
+	/* Inode numbers in all layers do not use the high xino_bits */
+	unsigned int xino_bits;
 };
 
 /* private information held for every overlayfs dentry */
* Unmerged path fs/overlayfs/super.c
* Unmerged path fs/overlayfs/util.c
