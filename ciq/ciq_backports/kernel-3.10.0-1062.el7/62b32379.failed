flow_dissector: dissect tunnel info outside __skb_flow_dissect()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Simon Horman <simon.horman@netronome.com>
commit 62b32379fd124fea521484ba7e220d8a449f0b59
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/62b32379.failed

Move dissection of tunnel info to outside of the main flow dissection
function, __skb_flow_dissect(). The sole user of this feature, the flower
classifier, is updated to call tunnel info dissection directly, using
skb_flow_dissect_tunnel_info().

This results in a slightly less complex implementation of
__skb_flow_dissect(), in particular removing logic from that call path
which is not used by the majority of users. The expense of this is borne by
the flower classifier which now has to make an extra call for tunnel info
dissection.

This patch should not result in any behavioural change.

	Signed-off-by: Simon Horman <simon.horman@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 62b32379fd124fea521484ba7e220d8a449f0b59)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index ec6a8d0a3cc7,cc75488d3653..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -116,6 -117,103 +116,106 @@@ __be32 __skb_flow_get_ports(const struc
  }
  EXPORT_SYMBOL(__skb_flow_get_ports);
  
++<<<<<<< HEAD
++=======
+ static void
+ skb_flow_dissect_set_enc_addr_type(enum flow_dissector_key_id type,
+ 				   struct flow_dissector *flow_dissector,
+ 				   void *target_container)
+ {
+ 	struct flow_dissector_key_control *ctrl;
+ 
+ 	if (!dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_CONTROL))
+ 		return;
+ 
+ 	ctrl = skb_flow_dissector_target(flow_dissector,
+ 					 FLOW_DISSECTOR_KEY_ENC_CONTROL,
+ 					 target_container);
+ 	ctrl->addr_type = type;
+ }
+ 
+ void
+ skb_flow_dissect_tunnel_info(const struct sk_buff *skb,
+ 			     struct flow_dissector *flow_dissector,
+ 			     void *target_container)
+ {
+ 	struct ip_tunnel_info *info;
+ 	struct ip_tunnel_key *key;
+ 
+ 	/* A quick check to see if there might be something to do. */
+ 	if (!dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_KEYID) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_CONTROL) &&
+ 	    !dissector_uses_key(flow_dissector,
+ 				FLOW_DISSECTOR_KEY_ENC_PORTS))
+ 		return;
+ 
+ 	info = skb_tunnel_info(skb);
+ 	if (!info)
+ 		return;
+ 
+ 	key = &info->key;
+ 
+ 	switch (ip_tunnel_info_af(info)) {
+ 	case AF_INET:
+ 		skb_flow_dissect_set_enc_addr_type(FLOW_DISSECTOR_KEY_IPV4_ADDRS,
+ 						   flow_dissector,
+ 						   target_container);
+ 		if (dissector_uses_key(flow_dissector,
+ 				       FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS)) {
+ 			struct flow_dissector_key_ipv4_addrs *ipv4;
+ 
+ 			ipv4 = skb_flow_dissector_target(flow_dissector,
+ 							 FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS,
+ 							 target_container);
+ 			ipv4->src = key->u.ipv4.src;
+ 			ipv4->dst = key->u.ipv4.dst;
+ 		}
+ 		break;
+ 	case AF_INET6:
+ 		skb_flow_dissect_set_enc_addr_type(FLOW_DISSECTOR_KEY_IPV6_ADDRS,
+ 						   flow_dissector,
+ 						   target_container);
+ 		if (dissector_uses_key(flow_dissector,
+ 				       FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS)) {
+ 			struct flow_dissector_key_ipv6_addrs *ipv6;
+ 
+ 			ipv6 = skb_flow_dissector_target(flow_dissector,
+ 							 FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS,
+ 							 target_container);
+ 			ipv6->src = key->u.ipv6.src;
+ 			ipv6->dst = key->u.ipv6.dst;
+ 		}
+ 		break;
+ 	}
+ 
+ 	if (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_KEYID)) {
+ 		struct flow_dissector_key_keyid *keyid;
+ 
+ 		keyid = skb_flow_dissector_target(flow_dissector,
+ 						  FLOW_DISSECTOR_KEY_ENC_KEYID,
+ 						  target_container);
+ 		keyid->keyid = tunnel_id_to_key32(key->tun_id);
+ 	}
+ 
+ 	if (dissector_uses_key(flow_dissector, FLOW_DISSECTOR_KEY_ENC_PORTS)) {
+ 		struct flow_dissector_key_ports *tp;
+ 
+ 		tp = skb_flow_dissector_target(flow_dissector,
+ 					       FLOW_DISSECTOR_KEY_ENC_PORTS,
+ 					       target_container);
+ 		tp->src = key->tp_src;
+ 		tp->dst = key->tp_dst;
+ 	}
+ }
+ EXPORT_SYMBOL(skb_flow_dissect_tunnel_info);
+ 
++>>>>>>> 62b32379fd12 (flow_dissector: dissect tunnel info outside __skb_flow_dissect())
  static enum flow_dissect_ret
  __skb_flow_dissect_mpls(const struct sk_buff *skb,
  			struct flow_dissector *flow_dissector,
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 58515be85153..5e447cc8007d 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -1192,6 +1192,11 @@ static inline bool skb_flow_dissect_flow_keys_buf(struct flow_keys *flow,
 				  data, proto, nhoff, hlen, flags);
 }
 
+void
+skb_flow_dissect_tunnel_info(const struct sk_buff *skb,
+			     struct flow_dissector *flow_dissector,
+			     void *target_container);
+
 static inline __u32 skb_get_hash(struct sk_buff *skb)
 {
 	if (!skb->l4_hash && !skb->sw_hash)
* Unmerged path net/core/flow_dissector.c
diff --git a/net/sched/cls_flower.c b/net/sched/cls_flower.c
index fe81e54c0234..9c4caab5172e 100644
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@ -191,6 +191,7 @@ static int fl_classify(struct sk_buff *skb, const struct tcf_proto *tp,
 	 * so do it rather here.
 	 */
 	skb_key.basic.n_proto = skb->protocol;
+	skb_flow_dissect_tunnel_info(skb, &head->dissector, &skb_key);
 	skb_flow_dissect(skb, &head->dissector, &skb_key, 0);
 
 	fl_set_masked_key(&skb_mkey, &skb_key, &head->mask);
