nvmet: mask pending AENs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 55fdd6b6134fc91d4722149fa8e4f2df24c428fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/55fdd6b6.failed

Per section 5.2 of the NVMe 1.3 spec:

  "When the controller posts a completion queue entry for an outstanding
  Asynchronous Event Request command and thus reports an asynchronous
  event, subsequent events of that event type are automatically masked by
  the controller until the host clears that event. An event is cleared by
  reading the log page associated with that event using the Get Log Page
  command (see section 5.14)."

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
(cherry picked from commit 55fdd6b6134fc91d4722149fa8e4f2df24c428fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/admin-cmd.c
#	drivers/nvme/target/core.c
#	drivers/nvme/target/nvmet.h
diff --cc drivers/nvme/target/admin-cmd.c
index 4adff15ff6c3,ead8fbe6922e..000000000000
--- a/drivers/nvme/target/admin-cmd.c
+++ b/drivers/nvme/target/admin-cmd.c
@@@ -116,13 -126,28 +116,32 @@@ out
  	nvmet_req_complete(req, status);
  }
  
 -static void nvmet_execute_get_log_changed_ns(struct nvmet_req *req)
 +static void copy_and_pad(char *dst, int dst_len, const char *src, int src_len)
  {
 -	struct nvmet_ctrl *ctrl = req->sq->ctrl;
 -	u16 status = NVME_SC_INTERNAL;
 -	size_t len;
 +	int len = min(src_len, dst_len);
  
++<<<<<<< HEAD
 +	memcpy(dst, src, len);
 +	if (dst_len > len)
 +		memset(dst + len, ' ', dst_len - len);
++=======
+ 	if (req->data_len != NVME_MAX_CHANGED_NAMESPACES * sizeof(__le32))
+ 		goto out;
+ 
+ 	mutex_lock(&ctrl->lock);
+ 	if (ctrl->nr_changed_ns == U32_MAX)
+ 		len = sizeof(__le32);
+ 	else
+ 		len = ctrl->nr_changed_ns * sizeof(__le32);
+ 	status = nvmet_copy_to_sgl(req, 0, ctrl->changed_ns_list, len);
+ 	if (!status)
+ 		status = nvmet_zero_sgl(req, len, req->data_len - len);
+ 	ctrl->nr_changed_ns = 0;
+ 	clear_bit(NVME_AEN_CFG_NS_ATTR, &ctrl->aen_masked);
+ 	mutex_unlock(&ctrl->lock);
+ out:
+ 	nvmet_req_complete(req, status);
++>>>>>>> 55fdd6b6134f (nvmet: mask pending AENs)
  }
  
  static void nvmet_execute_identify_ctrl(struct nvmet_req *req)
diff --cc drivers/nvme/target/core.c
index 81b808ef54e8,a03da764ecae..000000000000
--- a/drivers/nvme/target/core.c
+++ b/drivers/nvme/target/core.c
@@@ -142,6 -144,51 +142,54 @@@ static void nvmet_add_async_event(struc
  	schedule_work(&ctrl->async_event_work);
  }
  
++<<<<<<< HEAD
++=======
+ static bool nvmet_aen_disabled(struct nvmet_ctrl *ctrl, u32 aen)
+ {
+ 	if (!(READ_ONCE(ctrl->aen_enabled) & aen))
+ 		return true;
+ 	return test_and_set_bit(aen, &ctrl->aen_masked);
+ }
+ 
+ static void nvmet_add_to_changed_ns_log(struct nvmet_ctrl *ctrl, __le32 nsid)
+ {
+ 	u32 i;
+ 
+ 	mutex_lock(&ctrl->lock);
+ 	if (ctrl->nr_changed_ns > NVME_MAX_CHANGED_NAMESPACES)
+ 		goto out_unlock;
+ 
+ 	for (i = 0; i < ctrl->nr_changed_ns; i++) {
+ 		if (ctrl->changed_ns_list[i] == nsid)
+ 			goto out_unlock;
+ 	}
+ 
+ 	if (ctrl->nr_changed_ns == NVME_MAX_CHANGED_NAMESPACES) {
+ 		ctrl->changed_ns_list[0] = cpu_to_le32(0xffffffff);
+ 		ctrl->nr_changed_ns = U32_MAX;
+ 		goto out_unlock;
+ 	}
+ 
+ 	ctrl->changed_ns_list[ctrl->nr_changed_ns++] = nsid;
+ out_unlock:
+ 	mutex_unlock(&ctrl->lock);
+ }
+ 
+ static void nvmet_ns_changed(struct nvmet_subsys *subsys, u32 nsid)
+ {
+ 	struct nvmet_ctrl *ctrl;
+ 
+ 	list_for_each_entry(ctrl, &subsys->ctrls, subsys_entry) {
+ 		nvmet_add_to_changed_ns_log(ctrl, cpu_to_le32(nsid));
+ 		if (nvmet_aen_disabled(ctrl, NVME_AEN_CFG_NS_ATTR))
+ 			continue;
+ 		nvmet_add_async_event(ctrl, NVME_AER_TYPE_NOTICE,
+ 				NVME_AER_NOTICE_NS_CHANGED,
+ 				NVME_LOG_CHANGED_NS);
+ 	}
+ }
+ 
++>>>>>>> 55fdd6b6134f (nvmet: mask pending AENs)
  int nvmet_register_transport(const struct nvmet_fabrics_ops *ops)
  {
  	int ret = 0;
diff --cc drivers/nvme/target/nvmet.h
index 292d4d16ab7f,480dfe10fad9..000000000000
--- a/drivers/nvme/target/nvmet.h
+++ b/drivers/nvme/target/nvmet.h
@@@ -120,6 -138,8 +120,11 @@@ struct nvmet_ctrl 
  	u16			cntlid;
  	u32			kato;
  
++<<<<<<< HEAD
++=======
+ 	u32			aen_enabled;
+ 	unsigned long		aen_masked;
++>>>>>>> 55fdd6b6134f (nvmet: mask pending AENs)
  	struct nvmet_req	*async_event_cmds[NVMET_ASYNC_EVENTS];
  	unsigned int		nr_async_event_cmds;
  	struct list_head	async_events;
* Unmerged path drivers/nvme/target/admin-cmd.c
* Unmerged path drivers/nvme/target/core.c
* Unmerged path drivers/nvme/target/nvmet.h
