n_tty: Remove read_cnt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Peter Hurley <peter@hurleysoftware.com>
commit a2f73be8ee36e48f11f89ab705beb3c587a2f320
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a2f73be8.failed

Storing the read_cnt creates an unnecessary shared variable
between the single-producer (n_tty_receive_buf()) and the
single-consumer (n_tty_read()).

Compute read_cnt from head & tail instead of storing.

	Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a2f73be8ee36e48f11f89ab705beb3c587a2f320)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/tty/n_tty.c
diff --cc drivers/tty/n_tty.c
index 107aa433e80a,d159059560e8..000000000000
--- a/drivers/tty/n_tty.c
+++ b/drivers/tty/n_tty.c
@@@ -93,9 -96,8 +93,14 @@@ struct n_tty_data 
  	DECLARE_BITMAP(read_flags, N_TTY_BUF_SIZE);
  
  	char *read_buf;
++<<<<<<< HEAD
 +	int read_head;
 +	int read_tail;
 +	int read_cnt;
++=======
+ 	size_t read_head;
+ 	size_t read_tail;
++>>>>>>> a2f73be8ee36 (n_tty: Remove read_cnt)
  	int minimum_to_wake;
  
  	unsigned char *echo_buf;
@@@ -112,6 -114,21 +117,24 @@@
  	raw_spinlock_t read_lock;
  };
  
++<<<<<<< HEAD
++=======
+ static inline size_t read_cnt(struct n_tty_data *ldata)
+ {
+ 	return ldata->read_head - ldata->read_tail;
+ }
+ 
+ static inline unsigned char read_buf(struct n_tty_data *ldata, size_t i)
+ {
+ 	return ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];
+ }
+ 
+ static inline unsigned char *read_buf_addr(struct n_tty_data *ldata, size_t i)
+ {
+ 	return &ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];
+ }
+ 
++>>>>>>> a2f73be8ee36 (n_tty: Remove read_cnt)
  static inline int tty_put_user(struct tty_struct *tty, unsigned char x,
  			       unsigned char __user *ptr)
  {
@@@ -183,10 -194,9 +206,16 @@@ static void n_tty_set_room(struct tty_s
  
  static void put_tty_queue_nolock(unsigned char c, struct n_tty_data *ldata)
  {
++<<<<<<< HEAD
 +	if (ldata->read_cnt < N_TTY_BUF_SIZE) {
 +		ldata->read_buf[ldata->read_head] = c;
 +		ldata->read_head = (ldata->read_head + 1) & (N_TTY_BUF_SIZE-1);
 +		ldata->read_cnt++;
++=======
+ 	if (read_cnt(ldata) < N_TTY_BUF_SIZE) {
+ 		*read_buf_addr(ldata, ldata->read_head) = c;
+ 		ldata->read_head++;
++>>>>>>> a2f73be8ee36 (n_tty: Remove read_cnt)
  	}
  }
  
@@@ -975,10 -980,9 +1000,9 @@@ static void eraser(unsigned char c, str
  			else if (seen_alnums)
  				break;
  		}
 -		cnt = ldata->read_head - head;
 +		cnt = (ldata->read_head - head) & (N_TTY_BUF_SIZE-1);
  		raw_spin_lock_irqsave(&ldata->read_lock, flags);
  		ldata->read_head = head;
- 		ldata->read_cnt -= cnt;
  		raw_spin_unlock_irqrestore(&ldata->read_lock, flags);
  		if (L_ECHO(tty)) {
  			if (L_ECHOPRT(tty)) {
@@@ -1433,21 -1436,19 +1457,31 @@@ static void n_tty_receive_buf(struct tt
  
  	if (ldata->real_raw) {
  		raw_spin_lock_irqsave(&ldata->read_lock, cpuflags);
 -		i = min(N_TTY_BUF_SIZE - read_cnt(ldata),
 -			N_TTY_BUF_SIZE - (ldata->read_head & (N_TTY_BUF_SIZE - 1)));
 +		i = min(N_TTY_BUF_SIZE - ldata->read_cnt,
 +			N_TTY_BUF_SIZE - ldata->read_head);
  		i = min(count, i);
++<<<<<<< HEAD
 +		memcpy(ldata->read_buf + ldata->read_head, cp, i);
 +		ldata->read_head = (ldata->read_head + i) & (N_TTY_BUF_SIZE-1);
 +		ldata->read_cnt += i;
++=======
+ 		memcpy(read_buf_addr(ldata, ldata->read_head), cp, i);
+ 		ldata->read_head += i;
++>>>>>>> a2f73be8ee36 (n_tty: Remove read_cnt)
  		cp += i;
  		count -= i;
  
 -		i = min(N_TTY_BUF_SIZE - read_cnt(ldata),
 -			N_TTY_BUF_SIZE - (ldata->read_head & (N_TTY_BUF_SIZE - 1)));
 +		i = min(N_TTY_BUF_SIZE - ldata->read_cnt,
 +			N_TTY_BUF_SIZE - ldata->read_head);
  		i = min(count, i);
++<<<<<<< HEAD
 +		memcpy(ldata->read_buf + ldata->read_head, cp, i);
 +		ldata->read_head = (ldata->read_head + i) & (N_TTY_BUF_SIZE-1);
 +		ldata->read_cnt += i;
++=======
+ 		memcpy(read_buf_addr(ldata, ldata->read_head), cp, i);
+ 		ldata->read_head += i;
++>>>>>>> a2f73be8ee36 (n_tty: Remove read_cnt)
  		raw_spin_unlock_irqrestore(&ldata->read_lock, cpuflags);
  	} else {
  		for (i = count, p = cp, f = fp; i; i--, p++) {
@@@ -1724,17 -1746,15 +1758,21 @@@ static int copy_from_read_buf(struct tt
  	n = min(*nr, n);
  	raw_spin_unlock_irqrestore(&ldata->read_lock, flags);
  	if (n) {
 -		retval = copy_to_user(*b, read_buf_addr(ldata, tail), n);
 +		retval = copy_to_user(*b, &ldata->read_buf[ldata->read_tail], n);
  		n -= retval;
 -		is_eof = n == 1 && read_buf(ldata, tail) == EOF_CHAR(tty);
 -		tty_audit_add_data(tty, read_buf_addr(ldata, tail), n,
 +		is_eof = n == 1 &&
 +			ldata->read_buf[ldata->read_tail] == EOF_CHAR(tty);
 +		tty_audit_add_data(tty, &ldata->read_buf[ldata->read_tail], n,
  				ldata->icanon);
  		raw_spin_lock_irqsave(&ldata->read_lock, flags);
++<<<<<<< HEAD
 +		ldata->read_tail = (ldata->read_tail + n) & (N_TTY_BUF_SIZE-1);
 +		ldata->read_cnt -= n;
++=======
+ 		ldata->read_tail += n;
++>>>>>>> a2f73be8ee36 (n_tty: Remove read_cnt)
  		/* Turn single EOF into zero-length read */
 -		if (L_EXTPROC(tty) && ldata->icanon && is_eof && !read_cnt(ldata))
 +		if (L_EXTPROC(tty) && ldata->icanon && is_eof && !ldata->read_cnt)
  			n = 0;
  		raw_spin_unlock_irqrestore(&ldata->read_lock, flags);
  		*b += n;
@@@ -1818,8 -1839,7 +1856,12 @@@ static int canon_copy_from_read_buf(str
  	*nr -= n;
  
  	raw_spin_lock_irqsave(&ldata->read_lock, flags);
++<<<<<<< HEAD
 +	ldata->read_tail = (ldata->read_tail + c) & (N_TTY_BUF_SIZE - 1);
 +	ldata->read_cnt -= c;
++=======
+ 	ldata->read_tail += c;
++>>>>>>> a2f73be8ee36 (n_tty: Remove read_cnt)
  	if (found) {
  		__clear_bit(eol, ldata->read_flags);
  		/* this test should be redundant:
* Unmerged path drivers/tty/n_tty.c
