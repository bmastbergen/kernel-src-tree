perf stat: Move *_aggr_* data to 'struct perf_stat_config'

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 6f6b6594b5f380b0a972b66b275caa6c54bb1fea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6f6b6594.failed

Move the *_aggr_* global variables to 'struct perf_stat_config', so that
it can be passed around and used outside 'perf stat' command.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20180830063252.23729-37-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 6f6b6594b5f380b0a972b66b275caa6c54bb1fea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-stat.c
#	tools/perf/util/stat.h
diff --cc tools/perf/builtin-stat.c
index 13693124ed08,2f606f76b66a..000000000000
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@@ -143,13 -143,9 +143,11 @@@ static struct target target = 
  	.uid	= UINT_MAX,
  };
  
- typedef int (*aggr_get_id_t)(struct cpu_map *m, int cpu);
- 
  #define METRIC_ONLY_LEN 20
  
 +static int			run_count			=  1;
  static volatile pid_t		child_pid			= -1;
 +static bool			null_run			=  false;
  static int			detailed_run			=  0;
  static bool			transaction_run;
  static bool			topdown_run			= false;
@@@ -170,19 -162,11 +168,17 @@@ static bool			force_metric_only		= fals
  static bool			no_merge			= false;
  static bool			walltime_run_table		= false;
  static struct timespec		ref_time;
- static struct cpu_map		*aggr_map;
- static aggr_get_id_t		aggr_get_id;
  static bool			append_file;
  static bool			interval_count;
 +static bool			interval_clear;
  static const char		*output_name;
  static int			output_fd;
 +static int			print_free_counters_hint;
 +static int			print_mixed_hw_group_error;
  static u64			*walltime_run;
 +static bool			ru_display			= false;
 +static struct rusage		ru_data;
 +static unsigned int		metric_only_len			= METRIC_ONLY_LEN;
  
  struct perf_stat {
  	bool			 record;
@@@ -1049,13 -916,13 +1045,13 @@@ static int first_shadow_cpu(struct perf
  {
  	int i;
  
- 	if (!aggr_get_id)
+ 	if (!config->aggr_get_id)
  		return 0;
  
 -	if (config->aggr_mode == AGGR_NONE)
 +	if (stat_config.aggr_mode == AGGR_NONE)
  		return id;
  
 -	if (config->aggr_mode == AGGR_GLOBAL)
 +	if (stat_config.aggr_mode == AGGR_GLOBAL)
  		return 0;
  
  	for (i = 0; i < perf_evsel__nr_cpus(evsel); i++) {
@@@ -1231,12 -1098,12 +1227,18 @@@ static void aggr_update_shadow(void
  	u64 val;
  	struct perf_evsel *counter;
  
++<<<<<<< HEAD
 +	for (s = 0; s < aggr_map->nr; s++) {
 +		id = aggr_map->map[s];
 +		evlist__for_each_entry(evsel_list, counter) {
++=======
+ 	for (s = 0; s < config->aggr_map->nr; s++) {
+ 		id = config->aggr_map->map[s];
+ 		evlist__for_each_entry(evlist, counter) {
++>>>>>>> 6f6b6594b5f3 (perf stat: Move *_aggr_* data to 'struct perf_stat_config')
  			val = 0;
  			for (cpu = 0; cpu < perf_evsel__nr_cpus(counter); cpu++) {
- 				s2 = aggr_get_id(evsel_list->cpus, cpu);
+ 				s2 = config->aggr_get_id(config, evsel_list->cpus, cpu);
  				if (s2 != id)
  					continue;
  				val += perf_counts(counter->counts, cpu, 0)->val;
@@@ -1289,10 -1157,10 +1291,10 @@@ static void collect_all_aliases(struct 
  		    alias->scale != counter->scale ||
  		    alias->cgrp != counter->cgrp ||
  		    strcmp(alias->unit, counter->unit) ||
 -		    perf_evsel__is_clock(alias) != perf_evsel__is_clock(counter))
 +		    nsec_counter(alias) != nsec_counter(counter))
  			break;
  		alias->merged_stat = true;
- 		cb(alias, data, false);
+ 		cb(config, alias, data, false);
  	}
  }
  
@@@ -1357,10 -1229,10 +1360,10 @@@ static void print_aggr(char *prefix
  	u64 ena, run, val;
  	bool first;
  
- 	if (!(aggr_map || aggr_get_id))
+ 	if (!(config->aggr_map || config->aggr_get_id))
  		return;
  
 -	aggr_update_shadow(config, evlist);
 +	aggr_update_shadow();
  
  	/*
  	 * With metric_only everything is on a single line.
@@@ -1371,9 -1243,9 +1374,9 @@@
  		if (prefix && metric_only)
  			fprintf(output, "%s", prefix);
  
- 		ad.id = id = aggr_map->map[s];
+ 		ad.id = id = config->aggr_map->map[s];
  		first = true;
 -		evlist__for_each_entry(evlist, counter) {
 +		evlist__for_each_entry(evsel_list, counter) {
  			if (is_duration_time(counter))
  				continue;
  
diff --cc tools/perf/util/stat.h
index 4b88aef959fb,be202b066e62..000000000000
--- a/tools/perf/util/stat.h
+++ b/tools/perf/util/stat.h
@@@ -93,9 -107,20 +96,18 @@@ struct perf_stat_config 
  	unsigned int		 interval;
  	unsigned int		 timeout;
  	unsigned int		 initial_delay;
 -	unsigned int		 unit_width;
 -	unsigned int		 metric_only_len;
  	int			 times;
 -	int			 run_count;
 -	int			 print_free_counters_hint;
 -	int			 print_mixed_hw_group_error;
  	struct runtime_stat	*stats;
  	int			 stats_num;
++<<<<<<< HEAD
++=======
+ 	const char		*csv_sep;
+ 	struct stats		*walltime_nsecs_stats;
+ 	struct rusage		 ru_data;
+ 	struct cpu_map		*aggr_map;
+ 	aggr_get_id_t		 aggr_get_id;
+ 	struct cpu_map		*cpus_aggr_map;
++>>>>>>> 6f6b6594b5f3 (perf stat: Move *_aggr_* data to 'struct perf_stat_config')
  };
  
  void update_stats(struct stats *stats, u64 val);
* Unmerged path tools/perf/builtin-stat.c
* Unmerged path tools/perf/util/stat.h
