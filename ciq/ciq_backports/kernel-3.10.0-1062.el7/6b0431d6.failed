scsi: qla2xxx: Fix out of order Termination and ABTS response

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix out of order Termination and ABTS response (Himanshu Madhani) [1628301]
Rebuild_FUZZ: 94.83%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 6b0431d6fa20bd1b600a1e6df76bf7425fe178b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6b0431d6.failed

Following changes are added by this patch

- Prevent ABTS Response from getting in front of Termination of exchange.
  Firmware requires driver to cleanup exchanges before ABTS response can be
  sent. This reduces ABTS response error which triggers extra command
  re-termination and re-sending of ABTS response.

- Add bits in driver and tracks CTIO/ATIO attribute bits for proper command
  Termination. A copy of the ATTR bits will be kept in the ABTS task
  management command as a back up copy, if an ABTS response encounters an
  error.

	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 6b0431d6fa20bd1b600a1e6df76bf7425fe178b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_target.c
#	drivers/scsi/qla2xxx/qla_target.h
diff --cc drivers/scsi/qla2xxx/qla_target.c
index 1de1bf228cff,c2076758a4b6..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.c
+++ b/drivers/scsi/qla2xxx/qla_target.c
@@@ -1922,46 -2016,84 +2004,122 @@@ static void abort_cmds_for_lun(struct s
  	spin_unlock_irqrestore(&vha->cmd_list_lock, flags);
  }
  
++<<<<<<< HEAD
++=======
+ static struct qla_qpair_hint *qlt_find_qphint(struct scsi_qla_host *vha,
+     uint64_t unpacked_lun)
+ {
+ 	struct qla_tgt *tgt = vha->vha_tgt.qla_tgt;
+ 	struct qla_qpair_hint *h = NULL;
+ 
+ 	if (vha->flags.qpairs_available) {
+ 		h = btree_lookup64(&tgt->lun_qpair_map, unpacked_lun);
+ 		if (!h)
+ 			h = &tgt->qphints[0];
+ 	} else {
+ 		h = &tgt->qphints[0];
+ 	}
+ 
+ 	return h;
+ }
+ 
+ static void qlt_do_tmr_work(struct work_struct *work)
+ {
+ 	struct qla_tgt_mgmt_cmd *mcmd =
+ 		container_of(work, struct qla_tgt_mgmt_cmd, work);
+ 	struct qla_hw_data *ha = mcmd->vha->hw;
+ 	int rc = EIO;
+ 	uint32_t tag;
+ 	unsigned long flags;
+ 
+ 	switch (mcmd->tmr_func) {
+ 	case QLA_TGT_ABTS:
+ 		tag = mcmd->orig_iocb.abts.exchange_addr_to_abort;
+ 		break;
+ 	default:
+ 		tag = 0;
+ 		break;
+ 	}
+ 
+ 	rc = ha->tgt.tgt_ops->handle_tmr(mcmd, mcmd->unpacked_lun,
+ 	    mcmd->tmr_func, tag);
+ 
+ 	if (rc != 0) {
+ 		spin_lock_irqsave(mcmd->qpair->qp_lock_ptr, flags);
+ 		switch (mcmd->tmr_func) {
+ 		case QLA_TGT_ABTS:
+ 			mcmd->fc_tm_rsp = FCP_TMF_REJECTED;
+ 			qlt_build_abts_resp_iocb(mcmd);
+ 			break;
+ 		case QLA_TGT_LUN_RESET:
+ 		case QLA_TGT_CLEAR_TS:
+ 		case QLA_TGT_ABORT_TS:
+ 		case QLA_TGT_CLEAR_ACA:
+ 		case QLA_TGT_TARGET_RESET:
+ 			qlt_send_busy(mcmd->qpair, &mcmd->orig_iocb.atio,
+ 			    qla_sam_status);
+ 			break;
+ 
+ 		case QLA_TGT_ABORT_ALL:
+ 		case QLA_TGT_NEXUS_LOSS_SESS:
+ 		case QLA_TGT_NEXUS_LOSS:
+ 			qlt_send_notify_ack(mcmd->qpair,
+ 			    &mcmd->orig_iocb.imm_ntfy, 0, 0, 0, 0, 0, 0);
+ 			break;
+ 		}
+ 		spin_unlock_irqrestore(mcmd->qpair->qp_lock_ptr, flags);
+ 
+ 		ql_dbg(ql_dbg_tgt_mgt, mcmd->vha, 0xf052,
+ 		    "qla_target(%d):  tgt_ops->handle_tmr() failed: %d\n",
+ 		    mcmd->vha->vp_idx, rc);
+ 		mempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);
+ 	}
+ }
+ 
++>>>>>>> 6b0431d6fa20 (scsi: qla2xxx: Fix out of order Termination and ABTS response)
  /* ha->hardware_lock supposed to be held on entry */
  static int __qlt_24xx_handle_abts(struct scsi_qla_host *vha,
  	struct abts_recv_from_24xx *abts, struct fc_port *sess)
  {
  	struct qla_hw_data *ha = vha->hw;
 +	struct se_session *se_sess = sess->se_sess;
  	struct qla_tgt_mgmt_cmd *mcmd;
 -	struct qla_qpair_hint *h = &vha->vha_tgt.qla_tgt->qphints[0];
 +	struct se_cmd *se_cmd;
 +	u64 lun = 0;
 +	int rc;
 +	bool found_lun = false;
 +	unsigned long flags;
 +
++<<<<<<< HEAD
 +	spin_lock_irqsave(&se_sess->sess_cmd_lock, flags);
 +	list_for_each_entry(se_cmd, &se_sess->sess_cmd_list, se_cmd_list) {
 +		struct qla_tgt_cmd *cmd =
 +			container_of(se_cmd, struct qla_tgt_cmd, se_cmd);
 +		if (se_cmd->tag == abts->exchange_addr_to_abort) {
 +			lun = cmd->unpacked_lun;
 +			found_lun = true;
 +			break;
 +		}
 +	}
 +	spin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);
 +
 +	/* cmd not in LIO lists, look in qla list */
 +	if (!found_lun) {
 +		if (abort_cmd_for_tag(vha, abts->exchange_addr_to_abort)) {
 +			/* send TASK_ABORT response immediately */
 +			qlt_24xx_send_abts_resp(ha->base_qpair, abts,
 +			    FCP_TMF_CMPL, false);
 +			return 0;
 +		} else {
 +			ql_dbg(ql_dbg_tgt_mgt, vha, 0xf081,
 +			    "unable to find cmd in driver or LIO for tag 0x%x\n",
 +			    abts->exchange_addr_to_abort);
 +			return -ENOENT;
 +		}
 +	}
  
++=======
++>>>>>>> 6b0431d6fa20 (scsi: qla2xxx: Fix out of order Termination and ABTS response)
  	ql_dbg(ql_dbg_tgt_mgt, vha, 0xf00f,
  	    "qla_target(%d): task abort (tag=%d)\n",
  	    vha->vp_idx, abts->exchange_addr_to_abort);
@@@ -1979,19 -2111,31 +2137,39 @@@
  	memcpy(&mcmd->orig_iocb.abts, abts, sizeof(mcmd->orig_iocb.abts));
  	mcmd->reset_count = ha->base_qpair->chip_reset;
  	mcmd->tmr_func = QLA_TGT_ABTS;
 -	mcmd->qpair = h->qpair;
 +	mcmd->qpair = ha->base_qpair;
  	mcmd->vha = vha;
  
++<<<<<<< HEAD
 +	rc = ha->tgt.tgt_ops->handle_tmr(mcmd, lun, mcmd->tmr_func,
 +	    abts->exchange_addr_to_abort);
 +	if (rc != 0) {
 +		ql_dbg(ql_dbg_tgt_mgt, vha, 0xf052,
 +		    "qla_target(%d):  tgt_ops->handle_tmr()"
 +		    " failed: %d", vha->vp_idx, rc);
 +		mempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);
 +		return -EFAULT;
++=======
+ 	/*
+ 	 * LUN is looked up by target-core internally based on the passed
+ 	 * abts->exchange_addr_to_abort tag.
+ 	 */
+ 	mcmd->se_cmd.cpuid = h->cpuid;
+ 
+ 	if (ha->tgt.tgt_ops->find_cmd_by_tag) {
+ 		struct qla_tgt_cmd *abort_cmd;
+ 
+ 		abort_cmd = ha->tgt.tgt_ops->find_cmd_by_tag(sess,
+ 		    abts->exchange_addr_to_abort);
+ 		if (abort_cmd && abort_cmd->qpair) {
+ 			mcmd->qpair = abort_cmd->qpair;
+ 			mcmd->se_cmd.cpuid = abort_cmd->se_cmd.cpuid;
+ 			mcmd->abort_io_attr = abort_cmd->atio.u.isp24.attr;
+ 			mcmd->flags = QLA24XX_MGMT_ABORT_IO_ATTR_VALID;
+ 		}
++>>>>>>> 6b0431d6fa20 (scsi: qla2xxx: Fix out of order Termination and ABTS response)
  	}
  
 -	INIT_WORK(&mcmd->work, qlt_do_tmr_work);
 -	queue_work_on(mcmd->se_cmd.cpuid, qla_tgt_wq, &mcmd->work);
 -
  	return 0;
  }
  
diff --cc drivers/scsi/qla2xxx/qla_target.h
index c64dc562cbae,6a59c99a63da..000000000000
--- a/drivers/scsi/qla2xxx/qla_target.h
+++ b/drivers/scsi/qla2xxx/qla_target.h
@@@ -966,8 -968,11 +969,15 @@@ struct qla_tgt_mgmt_cmd 
  	struct se_cmd se_cmd;
  	struct work_struct free_work;
  	unsigned int flags;
+ #define QLA24XX_MGMT_SEND_NACK	BIT_0
+ #define QLA24XX_MGMT_ABORT_IO_ATTR_VALID BIT_1
  	uint32_t reset_count;
++<<<<<<< HEAD
 +#define QLA24XX_MGMT_SEND_NACK	1
++=======
+ 	struct work_struct work;
+ 	uint64_t unpacked_lun;
++>>>>>>> 6b0431d6fa20 (scsi: qla2xxx: Fix out of order Termination and ABTS response)
  	union {
  		struct atio_from_isp atio;
  		struct imm_ntfy_from_isp imm_ntfy;
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 3d4cdf4444af..50c3a68e36e1 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -526,6 +526,7 @@ struct srb_iocb {
 enum {
 	TYPE_SRB,
 	TYPE_TGT_CMD,
+	TYPE_TGT_TMCMD,		/* task management */
 };
 
 typedef struct srb {
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index 2f76757b3740..f58d01dac490 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -1728,64 +1728,84 @@ __qla2x00_abort_all_cmds(struct qla_qpair *qp, int res)
 		sp = req->outstanding_cmds[cnt];
 		if (sp) {
 			req->outstanding_cmds[cnt] = NULL;
-			if (sp->cmd_type == TYPE_SRB) {
-				if (sp->type == SRB_NVME_CMD ||
-				    sp->type == SRB_NVME_LS) {
-					sp_get(sp);
-					spin_unlock_irqrestore(qp->qp_lock_ptr,
-					    flags);
-					qla_nvme_abort(ha, sp, res);
-					spin_lock_irqsave(qp->qp_lock_ptr,
-					    flags);
-				} else if (GET_CMD_SP(sp) &&
-				    !ha->flags.eeh_busy &&
-				    (!test_bit(ABORT_ISP_ACTIVE,
-					&vha->dpc_flags)) &&
-				    (sp->type == SRB_SCSI_CMD)) {
-					/*
-					 * Don't abort commands in
-					 * adapter during EEH
-					 * recovery as it's not
-					 * accessible/responding.
-					 *
-					 * Get a reference to the sp
-					 * and drop the lock. The
-					 * reference ensures this
-					 * sp->done() call and not the
-					 * call in qla2xxx_eh_abort()
-					 * ends the SCSI command (with
-					 * result 'res').
-					 */
-					sp_get(sp);
-					spin_unlock_irqrestore(qp->qp_lock_ptr,
-					    flags);
-					status = qla2xxx_eh_abort(
-					    GET_CMD_SP(sp));
-					spin_lock_irqsave(qp->qp_lock_ptr,
-					    flags);
+			switch (sp->cmd_type) {
+			case TYPE_SRB:
+				if (sp->cmd_type == TYPE_SRB) {
+					if (sp->type == SRB_NVME_CMD ||
+					    sp->type == SRB_NVME_LS) {
+						sp_get(sp);
+						spin_unlock_irqrestore
+							(qp->qp_lock_ptr,
+							 flags);
+						qla_nvme_abort(ha, sp, res);
+						spin_lock_irqsave
+							(qp->qp_lock_ptr,
+							 flags);
+					} else if (GET_CMD_SP(sp) &&
+					    !ha->flags.eeh_busy &&
+					    (!test_bit(ABORT_ISP_ACTIVE,
+						&vha->dpc_flags)) &&
+					    (sp->type == SRB_SCSI_CMD)) {
+						/*
+						 * Don't abort commands in
+						 * adapter during EEH
+						 * recovery as it's not
+						 * accessible/responding.
+						 *
+						 * Get a reference to the sp
+						 * and drop the lock. The
+						 * reference ensures this
+						 * sp->done() call and not the
+						 * call in qla2xxx_eh_abort()
+						 * ends the SCSI command (with
+						 * result 'res').
+						 */
+						sp_get(sp);
+						spin_unlock_irqrestore
+							(qp->qp_lock_ptr,
+							 flags);
+						status = qla2xxx_eh_abort(
+						    GET_CMD_SP(sp));
+						spin_lock_irqsave
+							(qp->qp_lock_ptr,
+							 flags);
+						/*
+						 * Get rid of extra reference
+						 * if immediate exit from
+						 * ql2xxx_eh_abort
+						 */
+						if (status == FAILED &&
+						    (qla2x00_isp_reg_stat(ha)))
+							atomic_dec(
+							    &sp->ref_count);
+					}
+					sp->done(sp, res);
+					break;
+				case TYPE_TGT_CMD:
+					if (!vha->hw->tgt.tgt_ops ||
+					    !tgt || qla_ini_mode_enabled(vha)) {
+						if (!trace)
+							ql_dbg(ql_dbg_tgt_mgt,
+							    vha, 0xf003,
+							    "HOST-ABORT-HNDLR: dpc_flags=%lx. Target mode disabled\n",
+							    vha->dpc_flags);
+						continue;
+					}
+					cmd = (struct qla_tgt_cmd *)sp;
+					qlt_abort_cmd_on_host_reset(cmd->vha,
+					    cmd);
+					break;
+				case TYPE_TGT_TMCMD:
 					/*
-					 * Get rid of extra reference
-					 * if immediate exit from
-					 * ql2xxx_eh_abort
+					 * Currently, only ABTS response gets on
+					 * the outstanding_cmds[]
 					 */
-					if (status == FAILED &&
-					    (qla2x00_isp_reg_stat(ha)))
-						atomic_dec(
-						    &sp->ref_count);
-				}
-				sp->done(sp, res);
-			} else {
-				if (!vha->hw->tgt.tgt_ops || !tgt ||
-				    qla_ini_mode_enabled(vha)) {
-					if (!trace)
-						ql_dbg(ql_dbg_tgt_mgt,
-						    vha, 0xf003,
-						    "HOST-ABORT-HNDLR: dpc_flags=%lx. Target mode disabled\n",
-						    vha->dpc_flags);
-					continue;
+					ha->tgt.tgt_ops->free_mcmd(
+					    (struct qla_tgt_mgmt_cmd *)sp);
+					break;
+				default:
+					break;
 				}
-				cmd = (struct qla_tgt_cmd *)sp;
-				qlt_abort_cmd_on_host_reset(cmd->vha, cmd);
 			}
 		}
 	}
* Unmerged path drivers/scsi/qla2xxx/qla_target.c
* Unmerged path drivers/scsi/qla2xxx/qla_target.h
