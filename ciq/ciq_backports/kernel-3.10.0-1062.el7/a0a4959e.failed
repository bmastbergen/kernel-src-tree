ALSA: usb-audio: Operate UAC3 Power Domains in PCM callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jorge Sanjuan <jorge.sanjuan@codethink.co.uk>
commit a0a4959eb4e94ce98ee5549dd7d1296d41162ca8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a0a4959e.failed

Make use of UAC3 Power Domains associated to an Audio Streaming
path within the PCM's logic. This means, when there is no audio
being transferred (pcm is closed), the host will set the Power Domain
associated to that substream to state D1. When audio is being transferred
(from hw_params onwards), the Power Domain will be set to D0 state.

This is the way the host lets the device know which Terminal
is going to be actively used and it is for the device to
manage its own internal resources on that UAC3 Power Domain.

Note the resume method now sets the Power Domain to D1 state as
resuming the device doesn't mean audio streaming will occur.

	Signed-off-by: Jorge Sanjuan <jorge.sanjuan@codethink.co.uk>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit a0a4959eb4e94ce98ee5549dd7d1296d41162ca8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/stream.c
diff --cc sound/usb/stream.c
index d16e1c23f4e9,8fe3b0e00e45..000000000000
--- a/sound/usb/stream.c
+++ b/sound/usb/stream.c
@@@ -106,6 -109,15 +106,18 @@@ static void snd_usb_init_substream(stru
  	subs->ep_num = fp->endpoint;
  	if (fp->channels > subs->channels_max)
  		subs->channels_max = fp->channels;
++<<<<<<< HEAD
++=======
+ 
+ 	if (pd) {
+ 		subs->str_pd = pd;
+ 		/* Initialize Power Domain to idle status D1 */
+ 		snd_usb_power_domain_set(subs->stream->chip, pd,
+ 					 UAC3_PD_STATE_D1);
+ 	}
+ 
+ 	snd_usb_preallocate_buffer(subs);
++>>>>>>> a0a4959eb4e9 (ALSA: usb-audio: Operate UAC3 Power Domains in PCM callbacks)
  }
  
  /* kctl callbacks for usb-audio channel maps */
diff --git a/sound/usb/pcm.c b/sound/usb/pcm.c
index 5a1e2f0b856b..9b37f10f1383 100644
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@ -748,11 +748,11 @@ int snd_usb_pcm_resume(struct snd_usb_stream *as)
 {
 	int ret;
 
-	ret = snd_usb_pcm_change_state(&as->substream[0], UAC3_PD_STATE_D0);
+	ret = snd_usb_pcm_change_state(&as->substream[0], UAC3_PD_STATE_D1);
 	if (ret < 0)
 		return ret;
 
-	ret = snd_usb_pcm_change_state(&as->substream[1], UAC3_PD_STATE_D0);
+	ret = snd_usb_pcm_change_state(&as->substream[1], UAC3_PD_STATE_D1);
 	if (ret < 0)
 		return ret;
 
@@ -799,16 +799,22 @@ static int snd_usb_hw_params(struct snd_pcm_substream *substream,
 	ret = snd_usb_lock_shutdown(subs->stream->chip);
 	if (ret < 0)
 		return ret;
+
+	ret = snd_usb_pcm_change_state(subs, UAC3_PD_STATE_D0);
+	if (ret < 0)
+		goto unlock;
+
 	ret = set_format(subs, fmt);
-	snd_usb_unlock_shutdown(subs->stream->chip);
 	if (ret < 0)
-		return ret;
+		goto unlock;
 
 	subs->interface = fmt->iface;
 	subs->altset_idx = fmt->altset_idx;
 	subs->need_setup_ep = true;
 
-	return 0;
+ unlock:
+	snd_usb_unlock_shutdown(subs->stream->chip);
+	return ret;
 }
 
 /*
@@ -861,6 +867,10 @@ static int snd_usb_pcm_prepare(struct snd_pcm_substream *substream)
 	snd_usb_endpoint_sync_pending_stop(subs->sync_endpoint);
 	snd_usb_endpoint_sync_pending_stop(subs->data_endpoint);
 
+	ret = snd_usb_pcm_change_state(subs, UAC3_PD_STATE_D0);
+	if (ret < 0)
+		goto unlock;
+
 	ret = set_format(subs, subs->cur_audiofmt);
 	if (ret < 0)
 		goto unlock;
@@ -1305,6 +1315,7 @@ static int snd_usb_pcm_close(struct snd_pcm_substream *substream)
 	int direction = substream->stream;
 	struct snd_usb_stream *as = snd_pcm_substream_chip(substream);
 	struct snd_usb_substream *subs = &as->substream[direction];
+	int ret;
 
 	stop_endpoints(subs, true);
 
@@ -1313,7 +1324,10 @@ static int snd_usb_pcm_close(struct snd_pcm_substream *substream)
 	    !snd_usb_lock_shutdown(subs->stream->chip)) {
 		usb_set_interface(subs->dev, subs->interface, 0);
 		subs->interface = -1;
+		ret = snd_usb_pcm_change_state(subs, UAC3_PD_STATE_D1);
 		snd_usb_unlock_shutdown(subs->stream->chip);
+		if (ret < 0)
+			return ret;
 	}
 
 	subs->pcm_substream = NULL;
* Unmerged path sound/usb/stream.c
