ALSA: hda/ca0132: constify read-only members of string array

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Takashi Sakamoto <o-takashi@sakamocchi.jp>
commit 3a03f83b168b19f715cd043dc3a4600bd99f08ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3a03f83b.failed

This module has some strings just for printk therefore they can be
read-only.

This commit applies this optimization.

	Signed-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 3a03f83b168b19f715cd043dc3a4600bd99f08ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index 267302056b78,8295bd06af66..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -80,13 -84,19 +80,17 @@@
  
  #ifdef CONFIG_SND_HDA_CODEC_CA0132_DSP
  MODULE_FIRMWARE(EFX_FILE);
 -MODULE_FIRMWARE(SBZ_EFX_FILE);
 -MODULE_FIRMWARE(R3DI_EFX_FILE);
  #endif
  
++<<<<<<< HEAD
 +static char *dirstr[2] = { "Playback", "Capture" };
++=======
+ static const char *const dirstr[2] = { "Playback", "Capture" };
++>>>>>>> 3a03f83b168b (ALSA: hda/ca0132: constify read-only members of string array)
  
 -#define NUM_OF_OUTPUTS 3
  enum {
  	SPEAKER_OUT,
 -	HEADPHONE_OUT,
 -	SURROUND_OUT
 +	HEADPHONE_OUT
  };
  
  enum {
@@@ -94,6 -104,15 +98,18 @@@
  	LINE_MIC_IN
  };
  
++<<<<<<< HEAD
++=======
+ /* Strings for Input Source Enum Control */
+ static const char *const in_src_str[3] = {"Rear Mic", "Line", "Front Mic" };
+ #define IN_SRC_NUM_OF_INPUTS 3
+ enum {
+ 	REAR_MIC,
+ 	REAR_LINE_IN,
+ 	FRONT_MIC,
+ };
+ 
++>>>>>>> 3a03f83b168b (ALSA: hda/ca0132: constify read-only members of string array)
  enum {
  #define VNODE_START_NID    0x80
  	VNID_SPK = VNODE_START_NID,			/* Speaker vnid */
@@@ -3645,6 -4686,432 +3661,435 @@@ static int ca0132_vnode_switch_set(stru
  	return ret;
  }
  /* End of control change helpers. */
++<<<<<<< HEAD
++=======
+ /*
+  * Below I've added controls to mess with the effect levels, I've only enabled
+  * them on the Sound Blaster Z, but they would probably also work on the
+  * Chromebook. I figured they were probably tuned specifically for it, and left
+  * out for a reason.
+  */
+ 
+ /* Sets DSP effect level from the sliders above the controls */
+ static int ca0132_alt_slider_ctl_set(struct hda_codec *codec, hda_nid_t nid,
+ 			  const unsigned int *lookup, int idx)
+ {
+ 	int i = 0;
+ 	unsigned int y;
+ 	/*
+ 	 * For X_BASS, req 2 is actually crossover freq instead of
+ 	 * effect level
+ 	 */
+ 	if (nid == X_BASS)
+ 		y = 2;
+ 	else
+ 		y = 1;
+ 
+ 	snd_hda_power_up(codec);
+ 	if (nid == XBASS_XOVER) {
+ 		for (i = 0; i < OUT_EFFECTS_COUNT; i++)
+ 			if (ca0132_effects[i].nid == X_BASS)
+ 				break;
+ 
+ 		dspio_set_param(codec, ca0132_effects[i].mid, 0x20,
+ 				ca0132_effects[i].reqs[1],
+ 				&(lookup[idx - 1]), sizeof(unsigned int));
+ 	} else {
+ 		/* Find the actual effect structure */
+ 		for (i = 0; i < OUT_EFFECTS_COUNT; i++)
+ 			if (nid == ca0132_effects[i].nid)
+ 				break;
+ 
+ 		dspio_set_param(codec, ca0132_effects[i].mid, 0x20,
+ 				ca0132_effects[i].reqs[y],
+ 				&(lookup[idx]), sizeof(unsigned int));
+ 	}
+ 
+ 	snd_hda_power_down(codec);
+ 
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_xbass_xover_slider_ctl_get(struct snd_kcontrol *kcontrol,
+ 			  struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	long *valp = ucontrol->value.integer.value;
+ 
+ 	*valp = spec->xbass_xover_freq;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_slider_ctl_get(struct snd_kcontrol *kcontrol,
+ 			  struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	hda_nid_t nid = get_amp_nid(kcontrol);
+ 	long *valp = ucontrol->value.integer.value;
+ 	int idx = nid - OUT_EFFECT_START_NID;
+ 
+ 	*valp = spec->fx_ctl_val[idx];
+ 	return 0;
+ }
+ 
+ /*
+  * The X-bass crossover starts at 10hz, so the min is 1. The
+  * frequency is set in multiples of 10.
+  */
+ static int ca0132_alt_xbass_xover_slider_info(struct snd_kcontrol *kcontrol,
+ 		struct snd_ctl_elem_info *uinfo)
+ {
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+ 	uinfo->count = 1;
+ 	uinfo->value.integer.min = 1;
+ 	uinfo->value.integer.max = 100;
+ 	uinfo->value.integer.step = 1;
+ 
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_effect_slider_info(struct snd_kcontrol *kcontrol,
+ 		struct snd_ctl_elem_info *uinfo)
+ {
+ 	int chs = get_amp_channels(kcontrol);
+ 
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+ 	uinfo->count = chs == 3 ? 2 : 1;
+ 	uinfo->value.integer.min = 0;
+ 	uinfo->value.integer.max = 100;
+ 	uinfo->value.integer.step = 1;
+ 
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_xbass_xover_slider_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	hda_nid_t nid = get_amp_nid(kcontrol);
+ 	long *valp = ucontrol->value.integer.value;
+ 	int idx;
+ 
+ 	/* any change? */
+ 	if (spec->xbass_xover_freq == *valp)
+ 		return 0;
+ 
+ 	spec->xbass_xover_freq = *valp;
+ 
+ 	idx = *valp;
+ 	ca0132_alt_slider_ctl_set(codec, nid, float_xbass_xover_lookup, idx);
+ 
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_effect_slider_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	hda_nid_t nid = get_amp_nid(kcontrol);
+ 	long *valp = ucontrol->value.integer.value;
+ 	int idx;
+ 
+ 	idx = nid - EFFECT_START_NID;
+ 	/* any change? */
+ 	if (spec->fx_ctl_val[idx] == *valp)
+ 		return 0;
+ 
+ 	spec->fx_ctl_val[idx] = *valp;
+ 
+ 	idx = *valp;
+ 	ca0132_alt_slider_ctl_set(codec, nid, float_zero_to_one_lookup, idx);
+ 
+ 	return 0;
+ }
+ 
+ 
+ /*
+  * Mic Boost Enum for alternative ca0132 codecs. I didn't like that the original
+  * only has off or full 30 dB, and didn't like making a volume slider that has
+  * traditional 0-100 in alsamixer that goes in big steps. I like enum better.
+  */
+ #define MIC_BOOST_NUM_OF_STEPS 4
+ #define MIC_BOOST_ENUM_MAX_STRLEN 10
+ 
+ static int ca0132_alt_mic_boost_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	char *sfx = "dB";
+ 	char namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+ 
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = MIC_BOOST_NUM_OF_STEPS;
+ 	if (uinfo->value.enumerated.item >= MIC_BOOST_NUM_OF_STEPS)
+ 		uinfo->value.enumerated.item = MIC_BOOST_NUM_OF_STEPS - 1;
+ 	sprintf(namestr, "%d %s", (uinfo->value.enumerated.item * 10), sfx);
+ 	strcpy(uinfo->value.enumerated.name, namestr);
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_mic_boost_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->mic_boost_enum_val;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_mic_boost_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = MIC_BOOST_NUM_OF_STEPS;
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "ca0132_alt_mic_boost: boost=%d\n",
+ 		    sel);
+ 
+ 	spec->mic_boost_enum_val = sel;
+ 
+ 	if (spec->in_enum_val != REAR_LINE_IN)
+ 		ca0132_alt_mic_boost_set(codec, spec->mic_boost_enum_val);
+ 
+ 	return 1;
+ }
+ 
+ 
+ /*
+  * Input Select Control for alternative ca0132 codecs. This exists because
+  * front microphone has no auto-detect, and we need a way to set the rear
+  * as line-in
+  */
+ static int ca0132_alt_input_source_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = IN_SRC_NUM_OF_INPUTS;
+ 	if (uinfo->value.enumerated.item >= IN_SRC_NUM_OF_INPUTS)
+ 		uinfo->value.enumerated.item = IN_SRC_NUM_OF_INPUTS - 1;
+ 	strcpy(uinfo->value.enumerated.name,
+ 			in_src_str[uinfo->value.enumerated.item]);
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_input_source_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->in_enum_val;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_input_source_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = IN_SRC_NUM_OF_INPUTS;
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "ca0132_alt_input_select: sel=%d, preset=%s\n",
+ 		    sel, in_src_str[sel]);
+ 
+ 	spec->in_enum_val = sel;
+ 
+ 	ca0132_alt_select_in(codec);
+ 
+ 	return 1;
+ }
+ 
+ /* Sound Blaster Z Output Select Control */
+ static int ca0132_alt_output_select_get_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = NUM_OF_OUTPUTS;
+ 	if (uinfo->value.enumerated.item >= NUM_OF_OUTPUTS)
+ 		uinfo->value.enumerated.item = NUM_OF_OUTPUTS - 1;
+ 	strcpy(uinfo->value.enumerated.name,
+ 			alt_out_presets[uinfo->value.enumerated.item].name);
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_output_select_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->out_enum_val;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_output_select_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = NUM_OF_OUTPUTS;
+ 	unsigned int auto_jack;
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "ca0132_alt_output_select: sel=%d, preset=%s\n",
+ 		    sel, alt_out_presets[sel].name);
+ 
+ 	spec->out_enum_val = sel;
+ 
+ 	auto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
+ 
+ 	if (!auto_jack)
+ 		ca0132_alt_select_out(codec);
+ 
+ 	return 1;
+ }
+ 
+ /*
+  * Smart Volume output setting control. Three different settings, Normal,
+  * which takes the value from the smart volume slider. The two others, loud
+  * and night, disregard the slider value and have uneditable values.
+  */
+ #define NUM_OF_SVM_SETTINGS 3
+ static const char *const out_svm_set_enum_str[3] = {"Normal", "Loud", "Night" };
+ 
+ static int ca0132_alt_svm_setting_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = NUM_OF_SVM_SETTINGS;
+ 	if (uinfo->value.enumerated.item >= NUM_OF_SVM_SETTINGS)
+ 		uinfo->value.enumerated.item = NUM_OF_SVM_SETTINGS - 1;
+ 	strcpy(uinfo->value.enumerated.name,
+ 			out_svm_set_enum_str[uinfo->value.enumerated.item]);
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_svm_setting_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->smart_volume_setting;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_svm_setting_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = NUM_OF_SVM_SETTINGS;
+ 	unsigned int idx = SMART_VOLUME - EFFECT_START_NID;
+ 	unsigned int tmp;
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "ca0132_alt_svm_setting: sel=%d, preset=%s\n",
+ 		    sel, out_svm_set_enum_str[sel]);
+ 
+ 	spec->smart_volume_setting = sel;
+ 
+ 	switch (sel) {
+ 	case 0:
+ 		tmp = FLOAT_ZERO;
+ 		break;
+ 	case 1:
+ 		tmp = FLOAT_ONE;
+ 		break;
+ 	case 2:
+ 		tmp = FLOAT_TWO;
+ 		break;
+ 	default:
+ 		tmp = FLOAT_ZERO;
+ 		break;
+ 	}
+ 	/* Req 2 is the Smart Volume Setting req. */
+ 	dspio_set_uint_param(codec, ca0132_effects[idx].mid,
+ 			ca0132_effects[idx].reqs[2], tmp);
+ 	return 1;
+ }
+ 
+ /* Sound Blaster Z EQ preset controls */
+ static int ca0132_alt_eq_preset_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	unsigned int items = ARRAY_SIZE(ca0132_alt_eq_presets);
+ 
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = items;
+ 	if (uinfo->value.enumerated.item >= items)
+ 		uinfo->value.enumerated.item = items - 1;
+ 	strcpy(uinfo->value.enumerated.name,
+ 		ca0132_alt_eq_presets[uinfo->value.enumerated.item].name);
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_eq_preset_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->eq_preset_val;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_eq_preset_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int i, err = 0;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = ARRAY_SIZE(ca0132_alt_eq_presets);
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "%s: sel=%d, preset=%s\n", __func__, sel,
+ 			ca0132_alt_eq_presets[sel].name);
+ 	/*
+ 	 * Idx 0 is default.
+ 	 * Default needs to qualify with CrystalVoice state.
+ 	 */
+ 	for (i = 0; i < EQ_PRESET_MAX_PARAM_COUNT; i++) {
+ 		err = dspio_set_uint_param(codec, ca0132_alt_eq_enum.mid,
+ 				ca0132_alt_eq_enum.reqs[i],
+ 				ca0132_alt_eq_presets[sel].vals[i]);
+ 		if (err < 0)
+ 			break;
+ 	}
+ 
+ 	if (err >= 0)
+ 		spec->eq_preset_val = sel;
+ 
+ 	return 1;
+ }
++>>>>>>> 3a03f83b168b (ALSA: hda/ca0132: constify read-only members of string array)
  
  static int ca0132_voicefx_info(struct snd_kcontrol *kcontrol,
  				 struct snd_ctl_elem_info *uinfo)
* Unmerged path sound/pci/hda/patch_ca0132.c
