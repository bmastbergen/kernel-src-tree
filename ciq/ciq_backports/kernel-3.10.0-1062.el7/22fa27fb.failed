IB/uverbs: Fix locking around struct ib_uverbs_file ucontext

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit 22fa27fbc64d01cbbe1e4da751e64cc22d24a6e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/22fa27fb.failed

We have a parallel unlocked reader and writer with ib_uverbs_get_context()
vs everything else, and nothing guarantees this works properly.

Audit and fix all of the places that access ucontext to use one of the
following locking schemes:
- Call ib_uverbs_get_ucontext() under SRCU and check for failure
- Access the ucontext through an struct ib_uobject context member
  while holding a READ or WRITE lock on the uobject.
  This value cannot be NULL and has no race.
- Hold the ucontext_lock and check for ufile->ucontext !NULL

This also re-implements ib_uverbs_get_ucontext() in a way that is safe
against concurrent ib_uverbs_get_context() and disassociation.

As a side effect, every access to ucontext in the commands is via
ib_uverbs_get_context() with an error check, or via the uobject, so there
is no longer any need for the core code to check ucontext on every command
call. These checks are also removed.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 22fa27fbc64d01cbbe1e4da751e64cc22d24a6e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/rdma_core.c
#	drivers/infiniband/core/uverbs.h
#	drivers/infiniband/core/uverbs_cmd.c
#	drivers/infiniband/core/uverbs_ioctl.c
#	drivers/infiniband/core/uverbs_std_types_cq.c
#	drivers/infiniband/core/uverbs_std_types_dm.c
#	drivers/infiniband/hw/mlx5/devx.c
diff --cc drivers/infiniband/core/rdma_core.c
index 586f179a9de6,a63844ba8414..000000000000
--- a/drivers/infiniband/core/rdma_core.c
+++ b/drivers/infiniband/core/rdma_core.c
@@@ -150,18 -151,26 +150,30 @@@ int __uobj_perform_destroy(const struc
  	return success_res;
  }
  
 -static struct ib_uobject *alloc_uobj(struct ib_uverbs_file *ufile,
 +static struct ib_uobject *alloc_uobj(struct ib_ucontext *context,
  				     const struct uverbs_obj_type *type)
  {
- 	struct ib_uobject *uobj = kzalloc(type->obj_size, GFP_KERNEL);
+ 	struct ib_uobject *uobj;
+ 	struct ib_ucontext *ucontext;
  
+ 	ucontext = ib_uverbs_get_ucontext(ufile);
+ 	if (IS_ERR(ucontext))
+ 		return ERR_CAST(ucontext);
+ 
+ 	uobj = kzalloc(type->obj_size, GFP_KERNEL);
  	if (!uobj)
  		return ERR_PTR(-ENOMEM);
  	/*
  	 * user_handle should be filled by the handler,
  	 * The object is added to the list in the commit stage.
  	 */
++<<<<<<< HEAD
 +	uobj->context = context;
++=======
+ 	uobj->ufile = ufile;
+ 	uobj->context = ucontext;
+ 	INIT_LIST_HEAD(&uobj->list);
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  	uobj->type = type;
  	/*
  	 * Allocated objects start out as write locked to deny any other
@@@ -312,9 -315,17 +324,17 @@@ static struct ib_uobject *alloc_begin_i
  	if (ret)
  		goto uobj_put;
  
++<<<<<<< HEAD
++=======
+ 	ret = ib_rdmacg_try_charge(&uobj->cg_obj, uobj->context->device,
+ 				   RDMACG_RESOURCE_HCA_OBJECT);
+ 	if (ret)
+ 		goto idr_remove;
+ 
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  	return uobj;
  
 -idr_remove:
 -	spin_lock(&ufile->idr_lock);
 -	idr_remove(&ufile->idr, uobj->id);
 -	spin_unlock(&ufile->idr_lock);
 +	uverbs_idr_remove_uobj(uobj);
  uobj_put:
  	uverbs_uobject_put(uobj);
  	return ERR_PTR(ret);
@@@ -648,80 -692,188 +668,101 @@@ unlock
  
  void uverbs_close_fd(struct file *f)
  {
 -	struct ib_uobject *uobj = f->private_data;
 -	struct ib_uverbs_file *ufile = uobj->ufile;
 +	struct ib_uobject_file *uobj_file = f->private_data;
 +	struct kref *uverbs_file_ref = &uobj_file->ufile->ref;
  
 -	if (down_read_trylock(&ufile->hw_destroy_rwsem)) {
 -		_uverbs_close_fd(uobj);
 -		up_read(&ufile->hw_destroy_rwsem);
 -	}
 +	_uverbs_close_fd(uobj_file);
 +	uverbs_uobject_put(&uobj_file->uobj);
 +	kref_put(uverbs_file_ref, ib_uverbs_release_file);
 +}
  
 -	uobj->object = NULL;
 -	/* Matches the get in alloc_begin_fd_uobject */
 -	kref_put(&ufile->ref, ib_uverbs_release_file);
 +void uverbs_cleanup_ucontext(struct ib_ucontext *ucontext, bool device_removed)
 +{
 +	enum rdma_remove_reason reason = device_removed ?
 +		RDMA_REMOVE_DRIVER_REMOVE : RDMA_REMOVE_CLOSE;
 +	unsigned int cur_order = 0;
  
 -	/* Pairs with filp->private_data in alloc_begin_fd_uobject */
 -	uverbs_uobject_put(uobj);
 -}
 +	ucontext->cleanup_reason = reason;
 +	/*
 +	 * Waits for all remove_commit and alloc_commit to finish. Logically, We
 +	 * want to hold this forever as the context is going to be destroyed,
 +	 * but we'll release it since it causes a "held lock freed" BUG message.
 +	 */
 +	down_write(&ucontext->cleanup_rwsem);
  
 -static void ufile_disassociate_ucontext(struct ib_ucontext *ibcontext)
 -{
 -	struct ib_device *ib_dev = ibcontext->device;
 -	struct task_struct *owning_process  = NULL;
 -	struct mm_struct   *owning_mm       = NULL;
 -
 -	owning_process = get_pid_task(ibcontext->tgid, PIDTYPE_PID);
 -	if (!owning_process)
 -		return;
 -
 -	owning_mm = get_task_mm(owning_process);
 -	if (!owning_mm) {
 -		pr_info("no mm, disassociate ucontext is pending task termination\n");
 -		while (1) {
 -			put_task_struct(owning_process);
 -			usleep_range(1000, 2000);
 -			owning_process = get_pid_task(ibcontext->tgid,
 -						      PIDTYPE_PID);
 -			if (!owning_process ||
 -			    owning_process->state == TASK_DEAD) {
 -				pr_info("disassociate ucontext done, task was terminated\n");
 -				/* in case task was dead need to release the
 -				 * task struct.
 +	while (!list_empty(&ucontext->uobjects)) {
 +		struct ib_uobject *obj, *next_obj;
 +		unsigned int next_order = UINT_MAX;
 +
 +		/*
 +		 * This shouldn't run while executing other commands on this
 +		 * context. Thus, the only thing we should take care of is
 +		 * releasing a FD while traversing this list. The FD could be
 +		 * closed and released from the _release fop of this FD.
 +		 * In order to mitigate this, we add a lock.
 +		 * We take and release the lock per order traversal in order
 +		 * to let other threads (which might still use the FDs) chance
 +		 * to run.
 +		 */
 +		mutex_lock(&ucontext->uobjects_lock);
 +		list_for_each_entry_safe(obj, next_obj, &ucontext->uobjects,
 +					 list) {
 +			if (obj->type->destroy_order == cur_order) {
 +				int ret;
 +
 +				/*
 +				 * if we hit this WARN_ON, that means we are
 +				 * racing with a lookup_get.
  				 */
 -				if (owning_process)
 -					put_task_struct(owning_process);
 -				return;
 +				WARN_ON(uverbs_try_lock_object(obj, true));
 +				ret = obj->type->type_class->remove_commit(obj,
 +									   reason);
 +				list_del(&obj->list);
 +				if (ret)
 +					pr_warn("ib_uverbs: failed to remove uobject id %d order %u\n",
 +						obj->id, cur_order);
 +				/* put the ref we took when we created the object */
 +				uverbs_uobject_put(obj);
 +			} else {
 +				next_order = min(next_order,
 +						 obj->type->destroy_order);
  			}
  		}
 +		mutex_unlock(&ucontext->uobjects_lock);
 +		cur_order = next_order;
  	}
 -
 -	down_write(&owning_mm->mmap_sem);
 -	ib_dev->disassociate_ucontext(ibcontext);
 -	up_write(&owning_mm->mmap_sem);
 -	mmput(owning_mm);
 -	put_task_struct(owning_process);
 +	up_write(&ucontext->cleanup_rwsem);
  }
  
 -/*
 - * Drop the ucontext off the ufile and completely disconnect it from the
 - * ib_device
 - */
 -static void ufile_destroy_ucontext(struct ib_uverbs_file *ufile,
 -				   enum rdma_remove_reason reason)
 +void uverbs_initialize_ucontext(struct ib_ucontext *ucontext)
  {
++<<<<<<< HEAD
 +	ucontext->cleanup_reason = 0;
 +	mutex_init(&ucontext->uobjects_lock);
 +	INIT_LIST_HEAD(&ucontext->uobjects);
 +	init_rwsem(&ucontext->cleanup_rwsem);
++=======
+ 	struct ib_ucontext *ucontext = ufile->ucontext;
+ 	int ret;
+ 
+ 	if (reason == RDMA_REMOVE_DRIVER_REMOVE)
+ 		ufile_disassociate_ucontext(ucontext);
+ 
+ 	put_pid(ucontext->tgid);
+ 	ib_rdmacg_uncharge(&ucontext->cg_obj, ucontext->device,
+ 			   RDMACG_RESOURCE_HCA_HANDLE);
+ 
+ 	/*
+ 	 * FIXME: Drivers are not permitted to fail dealloc_ucontext, remove
+ 	 * the error return.
+ 	 */
+ 	ret = ucontext->device->dealloc_ucontext(ucontext);
+ 	WARN_ON(ret);
+ 
+ 	ufile->ucontext = NULL;
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  }
 -
 -static int __uverbs_cleanup_ufile(struct ib_uverbs_file *ufile,
 -				  enum rdma_remove_reason reason)
 -{
 -	struct ib_uobject *obj, *next_obj;
 -	int ret = -EINVAL;
 -	int err = 0;
 -
 -	/*
 -	 * This shouldn't run while executing other commands on this
 -	 * context. Thus, the only thing we should take care of is
 -	 * releasing a FD while traversing this list. The FD could be
 -	 * closed and released from the _release fop of this FD.
 -	 * In order to mitigate this, we add a lock.
 -	 * We take and release the lock per traversal in order to let
 -	 * other threads (which might still use the FDs) chance to run.
 -	 */
 -	list_for_each_entry_safe(obj, next_obj, &ufile->uobjects, list) {
 -		/*
 -		 * if we hit this WARN_ON, that means we are
 -		 * racing with a lookup_get.
 -		 */
 -		WARN_ON(uverbs_try_lock_object(obj, true));
 -		err = obj->type->type_class->remove_commit(obj, reason);
 -
 -		if (ib_is_destroy_retryable(err, reason, obj)) {
 -			pr_debug("ib_uverbs: failed to remove uobject id %d err %d\n",
 -				 obj->id, err);
 -			atomic_set(&obj->usecnt, 0);
 -			continue;
 -		}
 -
 -		if (err)
 -			pr_err("ib_uverbs: unable to remove uobject id %d err %d\n",
 -				obj->id, err);
 -
 -		list_del(&obj->list);
 -		/* Pairs with the get in rdma_alloc_commit_uobject() */
 -		uverbs_uobject_put(obj);
 -		ret = 0;
 -	}
 -	return ret;
 -}
 -
 -/*
 - * Destroy the uncontext and every uobject associated with it. If called with
 - * reason != RDMA_REMOVE_CLOSE this will not return until the destruction has
 - * been completed and ufile->ucontext is NULL.
 - *
 - * This is internally locked and can be called in parallel from multiple
 - * contexts.
 - */
 -void uverbs_destroy_ufile_hw(struct ib_uverbs_file *ufile,
 -			     enum rdma_remove_reason reason)
 -{
 -	if (reason == RDMA_REMOVE_CLOSE) {
 -		/*
 -		 * During destruction we might trigger something that
 -		 * synchronously calls release on any file descriptor. For
 -		 * this reason all paths that come from file_operations
 -		 * release must use try_lock. They can progress knowing that
 -		 * there is an ongoing uverbs_destroy_ufile_hw that will clean
 -		 * up the driver resources.
 -		 */
 -		if (!mutex_trylock(&ufile->ucontext_lock))
 -			return;
 -
 -	} else {
 -		mutex_lock(&ufile->ucontext_lock);
 -	}
 -
 -	down_write(&ufile->hw_destroy_rwsem);
 -
 -	/*
 -	 * If a ucontext was never created then we can't have any uobjects to
 -	 * cleanup, nothing to do.
 -	 */
 -	if (!ufile->ucontext)
 -		goto done;
 -
 -	ufile->ucontext->closing = true;
 -	ufile->ucontext->cleanup_retryable = true;
 -	while (!list_empty(&ufile->uobjects))
 -		if (__uverbs_cleanup_ufile(ufile, reason)) {
 -			/*
 -			 * No entry was cleaned-up successfully during this
 -			 * iteration
 -			 */
 -			break;
 -		}
 -
 -	ufile->ucontext->cleanup_retryable = false;
 -	if (!list_empty(&ufile->uobjects))
 -		__uverbs_cleanup_ufile(ufile, reason);
 -
 -	ufile_destroy_ucontext(ufile, reason);
 -
 -done:
 -	up_write(&ufile->hw_destroy_rwsem);
 -	mutex_unlock(&ufile->ucontext_lock);
 -}
 -
 + 
  const struct uverbs_obj_type_class uverbs_fd_class = {
  	.alloc_begin = alloc_begin_fd_uobject,
  	.lookup_get = lookup_get_fd_uobject,
diff --cc drivers/infiniband/core/uverbs.h
index cbf36c75d546,cf02b433000c..000000000000
--- a/drivers/infiniband/core/uverbs.h
+++ b/drivers/infiniband/core/uverbs.h
@@@ -136,9 -136,12 +136,17 @@@ struct ib_uverbs_completion_event_file 
  
  struct ib_uverbs_file {
  	struct kref				ref;
 +	struct mutex				mutex;
 +	struct mutex                            cleanup_mutex; /* protect cleanup */
  	struct ib_uverbs_device		       *device;
++<<<<<<< HEAD
++=======
+ 	struct mutex				ucontext_lock;
+ 	/*
+ 	 * ucontext must be accessed via ib_uverbs_get_ucontext() or with
+ 	 * ucontext_lock held
+ 	 */
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  	struct ib_ucontext		       *ucontext;
  	struct ib_event_handler			event_handler;
  	struct ib_uverbs_async_event_file       *async_file;
diff --cc drivers/infiniband/core/uverbs_cmd.c
index f1558e6f86c4,38d7de3f9b2f..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -140,11 -146,15 +140,19 @@@ ssize_t ib_uverbs_get_context(struct ib
  		goto err_file;
  	}
  
- 	file->ucontext = ucontext;
- 
  	fd_install(resp.async_fd, filp);
  
++<<<<<<< HEAD
 +	mutex_unlock(&file->mutex);
++=======
+ 	/*
+ 	 * Make sure that ib_uverbs_get_ucontext() sees the pointer update
+ 	 * only after all writes to setup the ucontext have completed
+ 	 */
+ 	smp_store_release(&file->ucontext, ucontext);
+ 
+ 	mutex_unlock(&file->ucontext_lock);
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  
  	return in_len;
  
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index ec7b453e622b,db7a92ea5dbe..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -127,7 -140,7 +127,11 @@@ static int uverbs_process_attr(struct i
  		if (uattr->attr_data.reserved)
  			return -EINVAL;
  
++<<<<<<< HEAD
 +		if (uattr->len != 0 || !ucontext || uattr->data > INT_MAX)
++=======
+ 		if (uattr->len != 0)
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  			return -EINVAL;
  
  		o_attr = &e->obj_attr;
diff --cc drivers/infiniband/core/uverbs_std_types_cq.c
index b0dbae9dd0d7,c71305fc0433..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_cq.c
+++ b/drivers/infiniband/core/uverbs_std_types_cq.c
@@@ -114,7 -113,7 +114,11 @@@ static int UVERBS_HANDLER(UVERBS_METHOD
  	/* Temporary, only until drivers get the new uverbs_attr_bundle */
  	create_udata(attrs, &uhw);
  
++<<<<<<< HEAD
 +	cq = ib_dev->create_cq(ib_dev, &attr, ucontext, &uhw);
++=======
+ 	cq = ib_dev->create_cq(ib_dev, &attr, obj->uobject.context, &uhw);
++>>>>>>> 22fa27fbc64d (IB/uverbs: Fix locking around struct ib_uverbs_file ucontext)
  	if (IS_ERR(cq)) {
  		ret = PTR_ERR(cq);
  		goto err_event_file;
* Unmerged path drivers/infiniband/core/uverbs_std_types_dm.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/core/rdma_core.c
* Unmerged path drivers/infiniband/core/uverbs.h
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c
index 9b53f7b4a4a8..4f99ae8db3cb 100644
--- a/drivers/infiniband/core/uverbs_main.c
+++ b/drivers/infiniband/core/uverbs_main.c
@@ -138,9 +138,27 @@ static int (*uverbs_ex_cmd_table[])(struct ib_uverbs_file *file,
 static void ib_uverbs_add_one(struct ib_device *device);
 static void ib_uverbs_remove_one(struct ib_device *device, void *client_data);
 
+/*
+ * Must be called with the ufile->device->disassociate_srcu held, and the lock
+ * must be held until use of the ucontext is finished.
+ */
 struct ib_ucontext *ib_uverbs_get_ucontext(struct ib_uverbs_file *ufile)
 {
-	return ufile->ucontext;
+	/*
+	 * We do not hold the hw_destroy_rwsem lock for this flow, instead
+	 * srcu is used. It does not matter if someone races this with
+	 * get_context, we get NULL or valid ucontext.
+	 */
+	struct ib_ucontext *ucontext = smp_load_acquire(&ufile->ucontext);
+
+	if (!srcu_dereference(ufile->device->ib_dev,
+			      &ufile->device->disassociate_srcu))
+		return ERR_PTR(-EIO);
+
+	if (!ucontext)
+		return ERR_PTR(-EINVAL);
+
+	return ucontext;
 }
 EXPORT_SYMBOL(ib_uverbs_get_ucontext);
 
@@ -807,22 +825,18 @@ out:
 static int ib_uverbs_mmap(struct file *filp, struct vm_area_struct *vma)
 {
 	struct ib_uverbs_file *file = filp->private_data;
-	struct ib_device *ib_dev;
+	struct ib_ucontext *ucontext;
 	int ret = 0;
 	int srcu_key;
 
 	srcu_key = srcu_read_lock(&file->device->disassociate_srcu);
-	ib_dev = srcu_dereference(file->device->ib_dev,
-				  &file->device->disassociate_srcu);
-	if (!ib_dev) {
-		ret = -EIO;
+	ucontext = ib_uverbs_get_ucontext(file);
+	if (IS_ERR(ucontext)) {
+		ret = PTR_ERR(ucontext);
 		goto out;
 	}
 
-	if (!file->ucontext)
-		ret = -ENODEV;
-	else
-		ret = ib_dev->mmap(file->ucontext, vma);
+	ret = ucontext->device->mmap(ucontext, vma);
 out:
 	srcu_read_unlock(&file->device->disassociate_srcu, srcu_key);
 	return ret;
* Unmerged path drivers/infiniband/core/uverbs_std_types_cq.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_dm.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
diff --git a/include/rdma/uverbs_ioctl.h b/include/rdma/uverbs_ioctl.h
index 2cc45699a237..771ac3261519 100644
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@ -120,14 +120,6 @@ struct uverbs_attr_spec_hash {
 struct uverbs_attr_bundle;
 struct ib_uverbs_file;
 
-enum {
-	/*
-	 * Action marked with this flag creates a context (or root for all
-	 * objects).
-	 */
-	UVERBS_ACTION_FLAG_CREATE_ROOT = 1U << 0,
-};
-
 struct uverbs_method_spec {
 	/* Combination of bits from enum UVERBS_ACTION_FLAG_XXXX */
 	u32						flags;
