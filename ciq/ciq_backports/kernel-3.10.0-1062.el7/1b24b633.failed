xfs: move some more code into xfs_bmap_del_extent_real

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 1b24b633aafe4729c468f4144246709cdbda0f35
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/1b24b633.failed

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 1b24b633aafe4729c468f4144246709cdbda0f35)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 7800126fabda,717e7e4bbc34..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -4712,64 -5109,57 +4712,103 @@@ xfs_bmap_del_extent
  	del_endoff = del->br_startoff + del->br_blockcount;
  	got_endoff = got.br_startoff + got.br_blockcount;
  	ASSERT(got_endoff >= del_endoff);
++<<<<<<< HEAD
 +	delay = isnullstartblock(got.br_startblock);
 +	ASSERT(isnullstartblock(del->br_startblock) == delay);
 +	flags = 0;
++=======
+ 	ASSERT(!isnullstartblock(got.br_startblock));
++>>>>>>> 1b24b633aafe (xfs: move some more code into xfs_bmap_del_extent_real)
  	qfield = 0;
  	error = 0;
 -
 +	/*
 +	 * If deleting a real allocation, must free up the disk space.
 +	 */
 +	if (!delay) {
 +		flags = XFS_ILOG_CORE;
 +		/*
 +		 * Realtime allocation.  Free it and record di_nblocks update.
 +		 */
 +		if (whichfork == XFS_DATA_FORK && XFS_IS_REALTIME_INODE(ip)) {
 +			xfs_fsblock_t	bno;
 +			xfs_filblks_t	len;
 +
++<<<<<<< HEAD
 +			ASSERT(do_mod(del->br_blockcount,
 +				      mp->m_sb.sb_rextsize) == 0);
 +			ASSERT(do_mod(del->br_startblock,
 +				      mp->m_sb.sb_rextsize) == 0);
 +			bno = del->br_startblock;
 +			len = del->br_blockcount;
 +			do_div(bno, mp->m_sb.sb_rextsize);
 +			do_div(len, mp->m_sb.sb_rextsize);
 +			error = xfs_rtfree_extent(tp, bno, (xfs_extlen_t)len);
 +			if (error)
 +				goto done;
 +			do_fx = 0;
 +			nblks = len * mp->m_sb.sb_rextsize;
 +			qfield = XFS_TRANS_DQ_RTBCOUNT;
 +		}
 +		/*
 +		 * Ordinary allocation.
 +		 */
 +		else {
 +			do_fx = 1;
 +			nblks = del->br_blockcount;
 +			qfield = XFS_TRANS_DQ_BCOUNT;
 +		}
 +		/*
 +		 * Set up del_endblock and cur for later.
 +		 */
 +		del_endblock = del->br_startblock + del->br_blockcount;
 +		if (cur) {
 +			if ((error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
 +					got.br_startblock, got.br_blockcount,
 +					&i)))
 +				goto done;
 +			XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
 +		}
 +		da_old = da_new = 0;
++=======
+ 	/*
+ 	 * If it's the case where the directory code is running with no block
+ 	 * reservation, and the deleted block is in the middle of its extent,
+ 	 * and the resulting insert of an extent would cause transformation to
+ 	 * btree format, then reject it.  The calling code will then swap blocks
+ 	 * around instead.  We have to do this now, rather than waiting for the
+ 	 * conversion to btree format, since the transaction will be dirty then.
+ 	 */
+ 	if (tp->t_blk_res == 0 &&
+ 	    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&
+ 	    XFS_IFORK_NEXTENTS(ip, whichfork) >=
+ 			XFS_IFORK_MAXEXT(ip, whichfork) &&
+ 	    del->br_startoff > got.br_startoff && del_endoff < got_endoff)
+ 		return -ENOSPC;
+ 
+ 	flags = XFS_ILOG_CORE;
+ 	if (whichfork == XFS_DATA_FORK && XFS_IS_REALTIME_INODE(ip)) {
+ 		xfs_fsblock_t	bno;
+ 		xfs_filblks_t	len;
+ 
+ 		ASSERT(do_mod(del->br_blockcount, mp->m_sb.sb_rextsize) == 0);
+ 		ASSERT(do_mod(del->br_startblock, mp->m_sb.sb_rextsize) == 0);
+ 		bno = del->br_startblock;
+ 		len = del->br_blockcount;
+ 		do_div(bno, mp->m_sb.sb_rextsize);
+ 		do_div(len, mp->m_sb.sb_rextsize);
+ 		error = xfs_rtfree_extent(tp, bno, (xfs_extlen_t)len);
+ 		if (error)
+ 			goto done;
+ 		do_fx = 0;
+ 		nblks = len * mp->m_sb.sb_rextsize;
+ 		qfield = XFS_TRANS_DQ_RTBCOUNT;
++>>>>>>> 1b24b633aafe (xfs: move some more code into xfs_bmap_del_extent_real)
  	} else {
 -		do_fx = 1;
 -		nblks = del->br_blockcount;
 -		qfield = XFS_TRANS_DQ_BCOUNT;
 +		da_old = startblockval(got.br_startblock);
 +		da_new = 0;
 +		nblks = 0;
 +		do_fx = 0;
  	}
 -
 -	del_endblock = del->br_startblock + del->br_blockcount;
 -	if (cur) {
 -		error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
 -				got.br_startblock, got.br_blockcount, &i);
 -		if (error)
 -			goto done;
 -		XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
 -	}
 -
  	/*
  	 * Set flag value to use in switch statement.
  	 * Left-contig is 2, right-contig is 1.
@@@ -5240,58 -5610,16 +5279,69 @@@ __xfs_bunmapi
  			}
  		}
  
++<<<<<<< HEAD
 +		/*
 +		 * If it's the case where the directory code is running
 +		 * with no block reservation, and the deleted block is in
 +		 * the middle of its extent, and the resulting insert
 +		 * of an extent would cause transformation to btree format,
 +		 * then reject it.  The calling code will then swap
 +		 * blocks around instead.
 +		 * We have to do this now, rather than waiting for the
 +		 * conversion to btree format, since the transaction
 +		 * will be dirty.
 +		 */
 +		if (!wasdel && tp->t_blk_res == 0 &&
 +		    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&
 +		    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */
 +			XFS_IFORK_MAXEXT(ip, whichfork) &&
 +		    del.br_startoff > got.br_startoff &&
 +		    del.br_startoff + del.br_blockcount <
 +		    got.br_startoff + got.br_blockcount) {
 +			error = -ENOSPC;
 +			goto error0;
++=======
+ 		if (wasdel) {
+ 			error = xfs_bmap_del_extent_delay(ip, whichfork, &lastx,
+ 					&got, &del);
+ 		} else {
+ 			error = xfs_bmap_del_extent_real(ip, tp, &lastx, dfops,
+ 					cur, &del, &tmp_logflags, whichfork,
+ 					flags);
+ 			logflags |= tmp_logflags;
++>>>>>>> 1b24b633aafe (xfs: move some more code into xfs_bmap_del_extent_real)
 +		}
 +
 +		/*
 +		 * Unreserve quota and update realtime free space, if
 +		 * appropriate. If delayed allocation, update the inode delalloc
 +		 * counter now and wait to update the sb counters as
 +		 * xfs_bmap_del_extent() might need to borrow some blocks.
 +		 */
 +		if (wasdel) {
 +			ASSERT(startblockval(del.br_startblock) > 0);
 +			if (isrt) {
 +				xfs_filblks_t rtexts;
 +
 +				rtexts = XFS_FSB_TO_B(mp, del.br_blockcount);
 +				do_div(rtexts, mp->m_sb.sb_rextsize);
 +				xfs_mod_frextents(mp, (int64_t)rtexts);
 +				error = xfs_trans_reserve_quota_nblks(NULL,
 +						ip, -((long)del.br_blockcount),
 +						0, XFS_QMOPT_RES_RTBLKS);
 +			} else {
 +				error = xfs_trans_reserve_quota_nblks(NULL,
 +						ip, -((long)del.br_blockcount),
 +						0, XFS_QMOPT_RES_REGBLKS);
 +			}
 +			if (error)
 +				goto error0;
 +			ip->i_delayed_blks -= del.br_blockcount;
  		}
  
 +		error = xfs_bmap_del_extent(ip, tp, &lastx, dfops, cur, &del,
 +				&tmp_logflags, whichfork);
 +		logflags |= tmp_logflags;
  		if (error)
  			goto error0;
  
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
