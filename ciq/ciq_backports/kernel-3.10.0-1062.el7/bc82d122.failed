vfio/spapr: Reference mm in tce_container

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [vfio] spapr: Reference mm in tce_container (David Gibson) [1612677]
Rebuild_FUZZ: 93.51%
commit-author Alexey Kardashevskiy <aik@ozlabs.ru>
commit bc82d122ae4a0e9f971f13403995898fcfa0c09e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/bc82d122.failed

In some situations the userspace memory context may live longer than
the userspace process itself so if we need to do proper memory context
cleanup, we better have tce_container take a reference to mm_struct and
use it later when the process is gone (@current or @current->mm is NULL).

This references mm and stores the pointer in the container; this is done
in a new helper - tce_iommu_mm_set() - when one of the following happens:
- a container is enabled (IOMMU v1);
- a first attempt to pre-register memory is made (IOMMU v2);
- a DMA window is created (IOMMU v2).
The @mm stays referenced till the container is destroyed.

This replaces current->mm with container->mm everywhere except debug
prints.

This adds a check that current->mm is the same as the one stored in
the container to prevent userspace from making changes to a memory
context of other processes.

DMA map/unmap ioctls() do not check for @mm as they already check
for @enabled which is set after tce_iommu_mm_set() is called.

This does not reference a task as multiple threads within the same mm
are allowed to ioctl() to vfio and supposedly they will have same limits
and capabilities and if they do not, we'll just fail with no harm made.

	Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Acked-by: Alex Williamson <alex.williamson@redhat.com>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit bc82d122ae4a0e9f971f13403995898fcfa0c09e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vfio/vfio_iommu_spapr_tce.c
diff --cc drivers/vfio/vfio_iommu_spapr_tce.c
index ea54ab856f66,4c03c8525c26..000000000000
--- a/drivers/vfio/vfio_iommu_spapr_tce.c
+++ b/drivers/vfio/vfio_iommu_spapr_tce.c
@@@ -111,11 -126,11 +126,19 @@@ static long tce_iommu_unregister_pages(
  	if ((vaddr & ~PAGE_MASK) || (size & ~PAGE_MASK))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	mem = mm_iommu_find(vaddr, size >> PAGE_SHIFT);
 +	if (!mem)
 +		return -ENOENT;
 +
 +	return mm_iommu_put(mem);
++=======
+ 	mem = mm_iommu_find(container->mm, vaddr, size >> PAGE_SHIFT);
+ 	if (!mem)
+ 		return -ENOENT;
+ 
+ 	return mm_iommu_put(container->mm, mem);
++>>>>>>> bc82d122ae4a (vfio/spapr: Reference mm in tce_container)
  }
  
  static long tce_iommu_register_pages(struct tce_container *container,
@@@ -129,7 -144,7 +152,11 @@@
  			((vaddr + size) < vaddr))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	ret = mm_iommu_get(vaddr, entries, &mem);
++=======
+ 	ret = mm_iommu_get(container->mm, vaddr, entries, &mem);
++>>>>>>> bc82d122ae4a (vfio/spapr: Reference mm in tce_container)
  	if (ret)
  		return ret;
  
@@@ -376,7 -396,7 +408,11 @@@ static int tce_iommu_prereg_ua_to_hpa(s
  	long ret = 0;
  	struct mm_iommu_table_group_mem_t *mem;
  
++<<<<<<< HEAD
 +	mem = mm_iommu_lookup(tce, size);
++=======
+ 	mem = mm_iommu_lookup(container->mm, tce, size);
++>>>>>>> bc82d122ae4a (vfio/spapr: Reference mm in tce_container)
  	if (!mem)
  		return -EINVAL;
  
* Unmerged path drivers/vfio/vfio_iommu_spapr_tce.c
