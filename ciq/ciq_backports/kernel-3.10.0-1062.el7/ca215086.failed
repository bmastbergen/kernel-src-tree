mm: convert PG_balloon to PG_offline

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author David Hildenbrand <david@redhat.com>
commit ca215086b14b89a0e70fc211314944aa6ce50020
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ca215086.failed

PG_balloon was introduced to implement page migration/compaction for
pages inflated in virtio-balloon.  Nowadays, it is only a marker that a
page is part of virtio-balloon and therefore logically offline.

We also want to make use of this flag in other balloon drivers - for
inflated pages or when onlining a section but keeping some pages offline
(e.g.  used right now by XEN and Hyper-V via set_online_page_callback()).

We are going to expose this flag to dump tools like makedumpfile.  But
instead of exposing PG_balloon, let's generalize the concept of marking
pages as logically offline, so it can be reused for other purposes later
on.

Rename PG_balloon to PG_offline.  This is an indicator that the page is
logically offline, the content stale and that it should not be touched
(e.g.  a hypervisor would have to allocate backing storage in order for
the guest to dump an unused page).  We can then e.g.  exclude such pages
from dumps.

We replace and reuse KPF_BALLOON (23), as this shouldn't really harm
(and for now the semantics stay the same).  In following patches, we
will make use of this bit also in other balloon drivers.  While at it,
document PGTABLE.

[akpm@linux-foundation.org: fix comment text, per David]
Link: http://lkml.kernel.org/r/20181119101616.8901-3-david@redhat.com
	Signed-off-by: David Hildenbrand <david@redhat.com>
	Acked-by: Konstantin Khlebnikov <koct9i@gmail.com>
	Acked-by: Michael S. Tsirkin <mst@redhat.com>
	Acked-by: Pankaj gupta <pagupta@redhat.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Alexey Dobriyan <adobriyan@gmail.com>
	Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Cc: Christian Hansen <chansen3@cisco.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Stephen Rothwell <sfr@canb.auug.org.au>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Pavel Tatashin <pasha.tatashin@oracle.com>
	Cc: Alexander Duyck <alexander.h.duyck@linux.intel.com>
	Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Miles Chen <miles.chen@mediatek.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Kazuhito Hagio <k-hagio@ab.jp.nec.com>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Baoquan He <bhe@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Haiyang Zhang <haiyangz@microsoft.com>
	Cc: Juergen Gross <jgross@suse.com>
	Cc: Julien Freche <jfreche@vmware.com>
	Cc: Kairui Song <kasong@redhat.com>
	Cc: "K. Y. Srinivasan" <kys@microsoft.com>
	Cc: Len Brown <len.brown@intel.com>
	Cc: Lianbo Jiang <lijiang@redhat.com>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Nadav Amit <namit@vmware.com>
	Cc: Omar Sandoval <osandov@fb.com>
	Cc: Pavel Machek <pavel@ucw.cz>
	Cc: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
	Cc: Stefano Stabellini <sstabellini@kernel.org>
	Cc: Stephen Hemminger <sthemmin@microsoft.com>
	Cc: Vitaly Kuznetsov <vkuznets@redhat.com>
	Cc: Xavier Deguillard <xdeguillard@vmware.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ca215086b14b89a0e70fc211314944aa6ce50020)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/admin-guide/mm/pagemap.rst
#	fs/proc/page.c
#	include/linux/balloon_compaction.h
#	include/linux/page-flags.h
#	include/uapi/linux/kernel-page-flags.h
#	tools/vm/page-types.c
diff --cc fs/proc/page.c
index 4bb8e0142f7a,544d1ee15aee..000000000000
--- a/fs/proc/page.c
+++ b/fs/proc/page.c
@@@ -132,9 -149,16 +132,19 @@@ u64 stable_page_flags(struct page *page
  	 */
  	if (PageBuddy(page))
  		u |= 1 << KPF_BUDDY;
 -	else if (page_count(page) == 0 && is_free_buddy_page(page))
 -		u |= 1 << KPF_BUDDY;
  
++<<<<<<< HEAD
 +	if (PageBalloon(page))
 +		u |= 1 << KPF_BALLOON;
++=======
+ 	if (PageOffline(page))
+ 		u |= 1 << KPF_OFFLINE;
+ 	if (PageTable(page))
+ 		u |= 1 << KPF_PGTABLE;
+ 
+ 	if (page_is_idle(page))
+ 		u |= 1 << KPF_IDLE;
++>>>>>>> ca215086b14b (mm: convert PG_balloon to PG_offline)
  
  	u |= kpf_copy_bit(k, KPF_LOCKED,	PG_locked);
  
diff --cc include/linux/balloon_compaction.h
index 26062ab9b759,f111c780ef1d..000000000000
--- a/include/linux/balloon_compaction.h
+++ b/include/linux/balloon_compaction.h
@@@ -126,8 -95,8 +126,13 @@@ static inline bool isolated_balloon_pag
  static inline void balloon_page_insert(struct balloon_dev_info *balloon,
  				       struct page *page)
  {
++<<<<<<< HEAD
 +	__SetPageBalloon(page);
 +	SetPagePrivate(page);
++=======
+ 	__SetPageOffline(page);
+ 	__SetPageMovable(page, balloon->inode->i_mapping);
++>>>>>>> ca215086b14b (mm: convert PG_balloon to PG_offline)
  	set_page_private(page, (unsigned long)balloon);
  	list_add(&page->lru, &balloon->pages);
  }
@@@ -142,12 -111,15 +147,17 @@@
   */
  static inline void balloon_page_delete(struct page *page)
  {
++<<<<<<< HEAD
 +	__ClearPageBalloon(page);
++=======
+ 	__ClearPageOffline(page);
+ 	__ClearPageMovable(page);
++>>>>>>> ca215086b14b (mm: convert PG_balloon to PG_offline)
  	set_page_private(page, 0);
 -	/*
 -	 * No touch page.lru field once @page has been isolated
 -	 * because VM is using the field.
 -	 */
 -	if (!PageIsolated(page))
 +	if (PagePrivate(page)) {
 +		ClearPagePrivate(page);
  		list_del(&page->lru);
 +	}
  }
  
  /*
diff --cc include/linux/page-flags.h
index a12b531c03b4,808b4183e30d..000000000000
--- a/include/linux/page-flags.h
+++ b/include/linux/page-flags.h
@@@ -455,23 -607,127 +455,79 @@@ static inline int PageTransTail(struct 
  	return PageTail(page);
  }
  
 -/*
 - * PageDoubleMap indicates that the compound page is mapped with PTEs as well
 - * as PMDs.
 - *
 - * This is required for optimization of rmap operations for THP: we can postpone
 - * per small page mapcount accounting (and its overhead from atomic operations)
 - * until the first PMD split.
 - *
 - * For the page PageDoubleMap means ->_mapcount in all sub-pages is offset up
 - * by one. This reference will go away with last compound_mapcount.
 - *
 - * See also __split_huge_pmd_locked() and page_remove_anon_compound_rmap().
 - */
 -static inline int PageDoubleMap(struct page *page)
 -{
 -	return PageHead(page) && test_bit(PG_double_map, &page[1].flags);
 -}
 -
 -static inline void SetPageDoubleMap(struct page *page)
 -{
 -	VM_BUG_ON_PAGE(!PageHead(page), page);
 -	set_bit(PG_double_map, &page[1].flags);
 -}
 -
 -static inline void ClearPageDoubleMap(struct page *page)
 -{
 -	VM_BUG_ON_PAGE(!PageHead(page), page);
 -	clear_bit(PG_double_map, &page[1].flags);
 -}
 -static inline int TestSetPageDoubleMap(struct page *page)
 -{
 -	VM_BUG_ON_PAGE(!PageHead(page), page);
 -	return test_and_set_bit(PG_double_map, &page[1].flags);
 -}
 -
 -static inline int TestClearPageDoubleMap(struct page *page)
 -{
 -	VM_BUG_ON_PAGE(!PageHead(page), page);
 -	return test_and_clear_bit(PG_double_map, &page[1].flags);
 -}
 -
  #else
 -TESTPAGEFLAG_FALSE(TransHuge)
 -TESTPAGEFLAG_FALSE(TransCompound)
 -TESTPAGEFLAG_FALSE(TransCompoundMap)
 -TESTPAGEFLAG_FALSE(TransTail)
 -PAGEFLAG_FALSE(DoubleMap)
 -	TESTSETFLAG_FALSE(DoubleMap)
 -	TESTCLEARFLAG_FALSE(DoubleMap)
 -#endif
  
++<<<<<<< HEAD
 +static inline int PageTransHuge(struct page *page)
++=======
+ /*
+  * For pages that are never mapped to userspace (and aren't PageSlab),
+  * page_type may be used.  Because it is initialised to -1, we invert the
+  * sense of the bit, so __SetPageFoo *clears* the bit used for PageFoo, and
+  * __ClearPageFoo *sets* the bit used for PageFoo.  We reserve a few high and
+  * low bits so that an underflow or overflow of page_mapcount() won't be
+  * mistaken for a page type value.
+  */
+ 
+ #define PAGE_TYPE_BASE	0xf0000000
+ /* Reserve		0x0000007f to catch underflows of page_mapcount */
+ #define PAGE_MAPCOUNT_RESERVE	-128
+ #define PG_buddy	0x00000080
+ #define PG_offline	0x00000100
+ #define PG_kmemcg	0x00000200
+ #define PG_table	0x00000400
+ 
+ #define PageType(page, flag)						\
+ 	((page->page_type & (PAGE_TYPE_BASE | flag)) == PAGE_TYPE_BASE)
+ 
+ static inline int page_has_type(struct page *page)
++>>>>>>> ca215086b14b (mm: convert PG_balloon to PG_offline)
  {
 -	return (int)page->page_type < PAGE_MAPCOUNT_RESERVE;
 +	return 0;
  }
  
 -#define PAGE_TYPE_OPS(uname, lname)					\
 -static __always_inline int Page##uname(struct page *page)		\
 -{									\
 -	return PageType(page, PG_##lname);				\
 -}									\
 -static __always_inline void __SetPage##uname(struct page *page)		\
 -{									\
 -	VM_BUG_ON_PAGE(!PageType(page, 0), page);			\
 -	page->page_type &= ~PG_##lname;					\
 -}									\
 -static __always_inline void __ClearPage##uname(struct page *page)	\
 -{									\
 -	VM_BUG_ON_PAGE(!Page##uname(page), page);			\
 -	page->page_type |= PG_##lname;					\
 +static inline int PageTransCompound(struct page *page)
 +{
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static inline int PageTransTail(struct page *page)
 +{
 +	return 0;
 +}
 +#endif
++=======
+ /*
+  * PageBuddy() indicates that the page is free and in the buddy system
+  * (see mm/page_alloc.c).
+  */
+ PAGE_TYPE_OPS(Buddy, buddy)
+ 
+ /*
+  * PageOffline() indicates that the page is logically offline although the
+  * containing section is online. (e.g. inflated in a balloon driver or
+  * not onlined when onlining the section).
+  * The content of these pages is effectively stale. Such pages should not
+  * be touched (read/write/dump/save) except by their owner.
+  */
+ PAGE_TYPE_OPS(Offline, offline)
+ 
+ /*
+  * If kmemcg is enabled, the buddy allocator will set PageKmemcg() on
+  * pages allocated with __GFP_ACCOUNT. It gets cleared on page free.
+  */
+ PAGE_TYPE_OPS(Kmemcg, kmemcg)
+ 
+ /*
+  * Marks pages in use as page tables.
+  */
+ PAGE_TYPE_OPS(Table, table)
+ 
+ extern bool is_free_buddy_page(struct page *page);
+ 
+ __PAGEFLAG(Isolated, isolated, PF_ANY);
++>>>>>>> ca215086b14b (mm: convert PG_balloon to PG_offline)
  
  /*
   * If network-based swap is enabled, sl*b must keep track of whether pages
diff --cc include/uapi/linux/kernel-page-flags.h
index 2f96d233c980,6f2f2720f3ac..000000000000
--- a/include/uapi/linux/kernel-page-flags.h
+++ b/include/uapi/linux/kernel-page-flags.h
@@@ -31,7 -32,9 +31,14 @@@
  
  #define KPF_KSM			21
  #define KPF_THP			22
++<<<<<<< HEAD
 +#define KPF_BALLOON		23
 +
++=======
+ #define KPF_OFFLINE		23
+ #define KPF_ZERO_PAGE		24
+ #define KPF_IDLE		25
+ #define KPF_PGTABLE		26
++>>>>>>> ca215086b14b (mm: convert PG_balloon to PG_offline)
  
  #endif /* _UAPILINUX_KERNEL_PAGE_FLAGS_H */
diff --cc tools/vm/page-types.c
index cc32f303d504,6f64b2b93234..000000000000
--- a/tools/vm/page-types.c
+++ b/tools/vm/page-types.c
@@@ -126,7 -133,10 +126,14 @@@ static const char * const page_flag_nam
  	[KPF_NOPAGE]		= "n:nopage",
  	[KPF_KSM]		= "x:ksm",
  	[KPF_THP]		= "t:thp",
++<<<<<<< HEAD
 +	[KPF_BALLOON]		= "o:balloon",
++=======
+ 	[KPF_OFFLINE]		= "o:offline",
+ 	[KPF_PGTABLE]		= "g:pgtable",
+ 	[KPF_ZERO_PAGE]		= "z:zero_page",
+ 	[KPF_IDLE]              = "i:idle_page",
++>>>>>>> ca215086b14b (mm: convert PG_balloon to PG_offline)
  
  	[KPF_RESERVED]		= "r:reserved",
  	[KPF_MLOCKED]		= "m:mlocked",
* Unmerged path Documentation/admin-guide/mm/pagemap.rst
* Unmerged path Documentation/admin-guide/mm/pagemap.rst
* Unmerged path fs/proc/page.c
* Unmerged path include/linux/balloon_compaction.h
* Unmerged path include/linux/page-flags.h
* Unmerged path include/uapi/linux/kernel-page-flags.h
* Unmerged path tools/vm/page-types.c
