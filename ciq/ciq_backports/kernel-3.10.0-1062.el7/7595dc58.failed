iommu/iova: Simplify domain destruction

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [iommu] iova: Simplify domain destruction (Jerry Snitselaar) [1615865]
Rebuild_FUZZ: 91.67%
commit-author Robin Murphy <robin.murphy@arm.com>
commit 7595dc588a39c37091ddf65f6c0a3cd40f128e7a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7595dc58.failed

All put_iova_domain() should have to worry about is freeing memory - by
that point the domain must no longer be live, so the act of cleaning up
doesn't need to be concurrency-safe or maintain the rbtree in a
self-consistent state. There's no need to waste time with locking or
emptying the rcache magazines, and we can just use the postorder
traversal helper to clear out the remaining rbtree entries in-place.

	Signed-off-by: Robin Murphy <robin.murphy@arm.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 7595dc588a39c37091ddf65f6c0a3cd40f128e7a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iova.c
diff --cc drivers/iommu/iova.c
index 1a0166896ba6,ca21196c1f2d..000000000000
--- a/drivers/iommu/iova.c
+++ b/drivers/iommu/iova.c
@@@ -637,16 -587,8 +636,17 @@@ void put_iova_domain(struct iova_domai
  
  	free_iova_flush_queue(iovad);
  	free_iova_rcaches(iovad);
++<<<<<<< HEAD
 +	spin_lock_irqsave(&iovad->iova_rbtree_lock, flags);
 +	node = rb_first(&iovad->rbroot);
 +	while (node) {
 +		struct iova *iova = container_of(node, struct iova, node);
 +
 +		rb_erase(node, &iovad->rbroot);
++=======
+ 	rbtree_postorder_for_each_entry_safe(iova, tmp, &iovad->rbroot, node)
++>>>>>>> 7595dc588a39 (iommu/iova: Simplify domain destruction)
  		free_iova_mem(iova);
- 		node = rb_first(&iovad->rbroot);
- 	}
- 	spin_unlock_irqrestore(&iovad->iova_rbtree_lock, flags);
  }
  EXPORT_SYMBOL_GPL(put_iova_domain);
  
* Unmerged path drivers/iommu/iova.c
