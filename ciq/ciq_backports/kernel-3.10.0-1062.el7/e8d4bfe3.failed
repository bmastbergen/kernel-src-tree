ovl: Sync upper dirty data when syncing overlayfs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Chengguang Xu <cgxu@mykernel.net>
commit e8d4bfe3a71537284a90561f77c85dea6c154369
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e8d4bfe3.failed

When executing filesystem sync or umount on overlayfs,
dirty data does not get synced as expected on upper filesystem.
This patch fixes sync filesystem method to keep data consistency
for overlayfs.

	Signed-off-by: Chengguang Xu <cgxu@mykernel.net>
Fixes: e593b2bf513d ("ovl: properly implement sync_filesystem()")
	Cc: <stable@vger.kernel.org> #4.11
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit e8d4bfe3a71537284a90561f77c85dea6c154369)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index 19e9eb0f1d4f,76440feb79f6..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -218,47 -218,67 +218,63 @@@ static void ovl_destroy_inode(struct in
  	call_rcu(&inode->i_rcu, ovl_i_callback);
  }
  
 -static void ovl_free_fs(struct ovl_fs *ofs)
 -{
 -	unsigned i;
 -
 -	dput(ofs->indexdir);
 -	dput(ofs->workdir);
 -	if (ofs->workdir_locked)
 -		ovl_inuse_unlock(ofs->workbasedir);
 -	dput(ofs->workbasedir);
 -	if (ofs->upperdir_locked)
 -		ovl_inuse_unlock(ofs->upper_mnt->mnt_root);
 -	mntput(ofs->upper_mnt);
 -	for (i = 0; i < ofs->numlower; i++) {
 -		mntput(ofs->lower_layers[i].mnt);
 -		free_anon_bdev(ofs->lower_layers[i].pseudo_dev);
 -	}
 -	kfree(ofs->lower_layers);
 -
 -	kfree(ofs->config.lowerdir);
 -	kfree(ofs->config.upperdir);
 -	kfree(ofs->config.workdir);
 -	kfree(ofs->config.redirect_mode);
 -	if (ofs->creator_cred)
 -		put_cred(ofs->creator_cred);
 -	kfree(ofs);
 -}
 -
  static void ovl_put_super(struct super_block *sb)
  {
 -	struct ovl_fs *ofs = sb->s_fs_info;
 +	struct ovl_fs *ufs = sb->s_fs_info;
 +	unsigned i;
  
 -	ovl_free_fs(ofs);
 +	dput(ufs->indexdir);
 +	dput(ufs->workdir);
 +	if (ufs->workdir_locked)
 +		ovl_inuse_unlock(ufs->workbasedir);
 +	dput(ufs->workbasedir);
 +	if (ufs->upper_mnt && ufs->upperdir_locked)
 +		ovl_inuse_unlock(ufs->upper_mnt->mnt_root);
 +	mntput(ufs->upper_mnt);
 +	for (i = 0; i < ufs->numlower; i++)
 +		mntput(ufs->lower_mnt[i]);
 +	kfree(ufs->lower_mnt);
 +
 +	kfree(ufs->config.lowerdir);
 +	kfree(ufs->config.upperdir);
 +	kfree(ufs->config.workdir);
 +	kfree(ufs->config.redirect_mode);
 +	put_cred(ufs->creator_cred);
 +	kfree(ufs);
  }
  
+ /* Sync real dirty inodes in upper filesystem (if it exists) */
  static int ovl_sync_fs(struct super_block *sb, int wait)
  {
 -	struct ovl_fs *ofs = sb->s_fs_info;
 +	struct ovl_fs *ufs = sb->s_fs_info;
  	struct super_block *upper_sb;
  	int ret;
  
 -	if (!ofs->upper_mnt)
 +	if (!ufs->upper_mnt)
  		return 0;
++<<<<<<< HEAD
 +	upper_sb = ufs->upper_mnt->mnt_sb;
 +	if (!upper_sb->s_op->sync_fs)
++=======
+ 
+ 	/*
+ 	 * If this is a sync(2) call or an emergency sync, all the super blocks
+ 	 * will be iterated, including upper_sb, so no need to do anything.
+ 	 *
+ 	 * If this is a syncfs(2) call, then we do need to call
+ 	 * sync_filesystem() on upper_sb, but enough if we do it when being
+ 	 * called with wait == 1.
+ 	 */
+ 	if (!wait)
++>>>>>>> e8d4bfe3a715 (ovl: Sync upper dirty data when syncing overlayfs)
  		return 0;
  
- 	/* real inodes have already been synced by sync_filesystem(ovl_sb) */
+ 	upper_sb = ofs->upper_mnt->mnt_sb;
+ 
  	down_read(&upper_sb->s_umount);
- 	ret = upper_sb->s_op->sync_fs(upper_sb, wait);
+ 	ret = sync_filesystem(upper_sb);
  	up_read(&upper_sb->s_umount);
+ 
  	return ret;
  }
  
* Unmerged path fs/overlayfs/super.c
