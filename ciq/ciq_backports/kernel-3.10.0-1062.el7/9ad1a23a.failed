xfs: add asserts for the mmap lock in xfs_{insert,collapse}_file_space

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [fs] xfs: add asserts for the mmap lock in xfs_{insert, collapse}_file_space (Brian Foster) [1613405]
Rebuild_FUZZ: 99.29%
commit-author Christoph Hellwig <hch@lst.de>
commit 9ad1a23afb6c561acfa62850934ddc6c70c35994
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9ad1a23a.failed

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 9ad1a23afb6c561acfa62850934ddc6c70c35994)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/xfs_bmap_util.c
index ad7a1ab465c3,170b74c7f2d5..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -1271,11 -1327,14 +1271,15 @@@ xfs_collapse_file_space
  	int			error;
  	struct xfs_defer_ops	dfops;
  	xfs_fsblock_t		first_block;
 -	xfs_fileoff_t		stop_fsb = XFS_B_TO_FSB(mp, VFS_I(ip)->i_size);
 -	xfs_fileoff_t		next_fsb = XFS_B_TO_FSB(mp, offset + len);
 -	xfs_fileoff_t		shift_fsb = XFS_B_TO_FSB(mp, len);
 -	uint			resblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);
 -	bool			done = false;
 +	xfs_fileoff_t		start_fsb;
 +	xfs_fileoff_t		next_fsb;
 +	xfs_fileoff_t		shift_fsb;
  
  	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));
++<<<<<<< HEAD
++=======
+ 	ASSERT(xfs_isilocked(ip, XFS_MMAPLOCK_EXCL));
++>>>>>>> 9ad1a23afb6c (xfs: add asserts for the mmap lock in xfs_{insert,collapse}_file_space)
  
  	trace_xfs_collapse_file_space(ip);
  
@@@ -1361,7 -1378,80 +1365,84 @@@ out_bmap_cancel
  	xfs_defer_cancel(&dfops);
  out_trans_cancel:
  	xfs_trans_cancel(tp);
++<<<<<<< HEAD
 +	xfs_iunlock(ip, XFS_ILOCK_EXCL);
++=======
+ 	return error;
+ }
+ 
+ /*
+  * xfs_insert_file_space()
+  *	This routine create hole space by shifting extents for the given file.
+  *	The first thing we do is to sync dirty data and invalidate page cache
+  *	over the region on which insert range is working. And split an extent
+  *	to two extents at given offset by calling xfs_bmap_split_extent.
+  *	And shift all extent records which are laying between [offset,
+  *	last allocated extent] to the right to reserve hole range.
+  * RETURNS:
+  *	0 on success
+  *	errno on error
+  */
+ int
+ xfs_insert_file_space(
+ 	struct xfs_inode	*ip,
+ 	loff_t			offset,
+ 	loff_t			len)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_trans	*tp;
+ 	int			error;
+ 	struct xfs_defer_ops	dfops;
+ 	xfs_fsblock_t		first_block;
+ 	xfs_fileoff_t		stop_fsb = XFS_B_TO_FSB(mp, offset);
+ 	xfs_fileoff_t		next_fsb = NULLFSBLOCK;
+ 	xfs_fileoff_t		shift_fsb = XFS_B_TO_FSB(mp, len);
+ 	bool			done = false;
+ 
+ 	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));
+ 	ASSERT(xfs_isilocked(ip, XFS_MMAPLOCK_EXCL));
+ 
+ 	trace_xfs_insert_file_space(ip);
+ 
+ 	error = xfs_prepare_shift(ip, offset);
+ 	if (error)
+ 		return error;
+ 
+ 	/*
+ 	 * The extent shifting code works on extent granularity. So, if stop_fsb
+ 	 * is not the starting block of extent, we need to split the extent at
+ 	 * stop_fsb.
+ 	 */
+ 	error = xfs_bmap_split_extent(ip, stop_fsb);
+ 	if (error)
+ 		return error;
+ 
+ 	while (!error && !done) {
+ 		error = xfs_trans_alloc(mp, &M_RES(mp)->tr_write, 0, 0, 0,
+ 					&tp);
+ 		if (error)
+ 			break;
+ 
+ 		xfs_ilock(ip, XFS_ILOCK_EXCL);
+ 		xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
+ 		xfs_defer_init(&dfops, &first_block);
+ 		error = xfs_bmap_insert_extents(tp, ip, &next_fsb, shift_fsb,
+ 				&done, stop_fsb, &first_block, &dfops);
+ 		if (error)
+ 			goto out_bmap_cancel;
+ 
+ 		error = xfs_defer_finish(&tp, &dfops);
+ 		if (error)
+ 			goto out_bmap_cancel;
+ 		error = xfs_trans_commit(tp);
+ 	}
+ 
+ 	return error;
+ 
+ out_bmap_cancel:
+ 	xfs_defer_cancel(&dfops);
+ 	xfs_trans_cancel(tp);
++>>>>>>> 9ad1a23afb6c (xfs: add asserts for the mmap lock in xfs_{insert,collapse}_file_space)
  	return error;
  }
  
* Unmerged path fs/xfs/xfs_bmap_util.c
