RDMA/uverbs: Use uverbs_request() for request copying

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit 3c2c20947ddbb897a1459f149509ac03e35043e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3c2c2094.failed

This function properly zero-extends, and zero-checks if the user
buffer is not the same size as the kernel command struct.

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 3c2c20947ddbb897a1459f149509ac03e35043e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_cmd.c
diff --cc drivers/infiniband/core/uverbs_cmd.c
index 507521d53e3f,173b8e83782e..000000000000
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@@ -47,12 -47,64 +47,68 @@@
  #include "uverbs.h"
  #include "core_priv.h"
  
++<<<<<<< HEAD
++=======
+ /*
+  * Copy a response to userspace. If the provided 'resp' is larger than the
+  * user buffer it is silently truncated. If the user provided a larger buffer
+  * then the trailing portion is zero filled.
+  *
+  * These semantics are intended to support future extension of the output
+  * structures.
+  */
+ static int uverbs_response(struct uverbs_attr_bundle *attrs, const void *resp,
+ 			   size_t resp_len)
+ {
+ 	u8 __user *cur = attrs->ucore.outbuf + resp_len;
+ 	u8 __user *end = attrs->ucore.outbuf + attrs->ucore.outlen;
+ 	int ret;
+ 
+ 	if (copy_to_user(attrs->ucore.outbuf, resp,
+ 			 min(attrs->ucore.outlen, resp_len)))
+ 		return -EFAULT;
+ 
+ 	/* Zero fill any extra memory that user space might have provided */
+ 	for (; cur < end; cur++) {
+ 		ret = put_user(0, cur);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Copy a request from userspace. If the provided 'req' is larger than the
+  * user buffer then the user buffer is zero extended into the 'req'. If 'req'
+  * is smaller than the user buffer then the uncopied bytes in the user buffer
+  * must be zero.
+  */
+ static int uverbs_request(struct uverbs_attr_bundle *attrs, void *req,
+ 			  size_t req_len)
+ {
+ 	if (copy_from_user(req, attrs->ucore.inbuf,
+ 			   min(attrs->ucore.inlen, req_len)))
+ 		return -EFAULT;
+ 
+ 	if (attrs->ucore.inlen < req_len) {
+ 		memset(req + attrs->ucore.inlen, 0,
+ 		       req_len - attrs->ucore.inlen);
+ 	} else if (attrs->ucore.inlen > req_len) {
+ 		if (!ib_is_buffer_cleared(attrs->ucore.inbuf + req_len,
+ 					  attrs->ucore.inlen - req_len))
+ 			return -EOPNOTSUPP;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  static struct ib_uverbs_completion_event_file *
 -_ib_uverbs_lookup_comp_file(s32 fd, const struct uverbs_attr_bundle *attrs)
 +ib_uverbs_lookup_comp_file(int fd, struct ib_ucontext *context)
  {
 -	struct ib_uobject *uobj = ufd_get_read(UVERBS_OBJECT_COMP_CHANNEL,
 -					       fd, attrs);
 +	struct ib_uobject *uobj = uobj_get_read(UVERBS_OBJECT_COMP_CHANNEL,
 +						fd, context);
 +	struct ib_uobject_file *uobj_file;
  
  	if (IS_ERR(uobj))
  		return (void *)uobj;
@@@ -60,30 -112,36 +116,36 @@@
  	uverbs_uobject_get(uobj);
  	uobj_put_read(uobj);
  
 -	return container_of(uobj, struct ib_uverbs_completion_event_file,
 -			    uobj);
 +	uobj_file = container_of(uobj, struct ib_uobject_file, uobj);
 +	return container_of(uobj_file, struct ib_uverbs_completion_event_file,
 +			    uobj_file);
  }
 -#define ib_uverbs_lookup_comp_file(_fd, _ufile)                                \
 -	_ib_uverbs_lookup_comp_file((_fd)*typecheck(s32, _fd), _ufile)
  
 -static int ib_uverbs_get_context(struct uverbs_attr_bundle *attrs,
 -				 const char __user *buf, int in_len,
 -				 int out_len)
 +ssize_t ib_uverbs_get_context(struct ib_uverbs_file *file,
 +			      struct ib_device *ib_dev,
 +			      const char __user *buf,
 +			      int in_len, int out_len)
  {
 -	struct ib_uverbs_file *file = attrs->ufile;
  	struct ib_uverbs_get_context      cmd;
  	struct ib_uverbs_get_context_resp resp;
 +	struct ib_udata                   udata;
  	struct ib_ucontext		 *ucontext;
  	struct file			 *filp;
 -	struct ib_rdmacg_object		 cg_obj;
 -	struct ib_device *ib_dev;
  	int ret;
  
++<<<<<<< HEAD
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
 +
 +	if (copy_from_user(&cmd, buf, sizeof cmd))
 +		return -EFAULT;
++=======
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
 -	mutex_lock(&file->ucontext_lock);
 -	ib_dev = srcu_dereference(file->device->ib_dev,
 -				  &file->device->disassociate_srcu);
 -	if (!ib_dev) {
 -		ret = -EIO;
 -		goto err;
 -	}
 +	mutex_lock(&file->mutex);
  
  	if (file->ucontext) {
  		ret = -EINVAL;
@@@ -218,37 -275,62 +280,44 @@@ ssize_t ib_uverbs_query_device(struct i
  {
  	struct ib_uverbs_query_device      cmd;
  	struct ib_uverbs_query_device_resp resp;
++<<<<<<< HEAD
++=======
+ 	struct ib_ucontext *ucontext;
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
 -	ucontext = ib_uverbs_get_ucontext(attrs);
 -	if (IS_ERR(ucontext))
 -		return PTR_ERR(ucontext);
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
  	memset(&resp, 0, sizeof resp);
 -	copy_query_dev_fields(ucontext, &resp, &ucontext->device->attrs);
 -
 -	return uverbs_response(attrs, &resp, sizeof(resp));
 -}
 -
 -/*
 - * ib_uverbs_query_port_resp.port_cap_flags started out as just a copy of the
 - * PortInfo CapabilityMask, but was extended with unique bits.
 - */
 -static u32 make_port_cap_flags(const struct ib_port_attr *attr)
 -{
 -	u32 res;
 -
 -	/* All IBA CapabilityMask bits are passed through here, except bit 26,
 -	 * which is overridden with IP_BASED_GIDS. This is due to a historical
 -	 * mistake in the implementation of IP_BASED_GIDS. Otherwise all other
 -	 * bits match the IBA definition across all kernel versions.
 -	 */
 -	res = attr->port_cap_flags & ~(u32)IB_UVERBS_PCF_IP_BASED_GIDS;
 +	copy_query_dev_fields(file, ib_dev, &resp, &ib_dev->attrs);
  
 -	if (attr->ip_gids)
 -		res |= IB_UVERBS_PCF_IP_BASED_GIDS;
 +	if (copy_to_user(u64_to_user_ptr(cmd.response), &resp, sizeof resp))
 +		return -EFAULT;
  
 -	return res;
 +	return in_len;
  }
  
 -static int ib_uverbs_query_port(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_query_port(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf,
 +			     int in_len, int out_len)
  {
  	struct ib_uverbs_query_port      cmd;
  	struct ib_uverbs_query_port_resp resp;
  	struct ib_port_attr              attr;
  	int                              ret;
 -	struct ib_ucontext *ucontext;
 -	struct ib_device *ib_dev;
  
 -	ucontext = ib_uverbs_get_ucontext(attrs);
 -	if (IS_ERR(ucontext))
 -		return PTR_ERR(ucontext);
 -	ib_dev = ucontext->device;
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
  	ret = ib_query_port(ib_dev, cmd.port_num, &attr);
  	if (ret)
@@@ -301,19 -380,13 +370,20 @@@ ssize_t ib_uverbs_alloc_pd(struct ib_uv
  	struct ib_uobject             *uobj;
  	struct ib_pd                  *pd;
  	int                            ret;
 -	struct ib_device *ib_dev;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_alloc(UVERBS_OBJECT_PD, attrs, &ib_dev);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +                   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +                   out_len - sizeof(resp));
 +
 +	uobj  = uobj_alloc(UVERBS_OBJECT_PD, file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -351,18 -421,17 +421,20 @@@ err
  	return ret;
  }
  
 -static int ib_uverbs_dealloc_pd(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_dealloc_pd(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf,
 +			     int in_len, int out_len)
  {
  	struct ib_uverbs_dealloc_pd cmd;
+ 	int ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_PD, cmd.pd_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_PD, cmd.pd_handle, file,
 +				    in_len);
  }
  
  struct xrcd_table_entry {
@@@ -464,19 -531,13 +536,20 @@@ ssize_t ib_uverbs_open_xrcd(struct ib_u
  	struct inode                   *inode = NULL;
  	int				ret = 0;
  	int				new_xrcd = 0;
 -	struct ib_device *ib_dev;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	mutex_lock(&ibudev->xrcd_tree_mutex);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +                   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +                   out_len - sizeof(resp));
 +
 +	mutex_lock(&file->device->xrcd_tree_mutex);
  
  	if (cmd.fd != -1) {
  		/* search for file descriptor */
@@@ -573,21 -632,20 +646,23 @@@ err_tree_mutex_unlock
  	return ret;
  }
  
 -static int ib_uverbs_close_xrcd(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_close_xrcd(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
  {
  	struct ib_uverbs_close_xrcd cmd;
+ 	int ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_XRCD, cmd.xrcd_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_XRCD, cmd.xrcd_handle, file,
 +				    in_len);
  }
  
 -int ib_uverbs_dealloc_xrcd(struct ib_uobject *uobject,
 +int ib_uverbs_dealloc_xrcd(struct ib_uverbs_device *dev,
  			   struct ib_xrcd *xrcd,
  			   enum rdma_remove_reason why)
  {
@@@ -620,18 -679,12 +695,19 @@@ ssize_t ib_uverbs_reg_mr(struct ib_uver
  	struct ib_pd                *pd;
  	struct ib_mr                *mr;
  	int                          ret;
 -	struct ib_device *ib_dev;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +                   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +                   out_len - sizeof(resp));
 +
  	if ((cmd.start & ~PAGE_MASK) != (cmd.hca_va & ~PAGE_MASK))
  		return -EINVAL;
  
@@@ -714,16 -763,9 +790,22 @@@ ssize_t ib_uverbs_rereg_mr(struct ib_uv
  	int                          ret;
  	struct ib_uobject	    *uobj;
  
++<<<<<<< HEAD
 +	if (out_len < sizeof(resp))
 +		return -ENOSPC;
 +
 +	if (copy_from_user(&cmd, buf, sizeof(cmd)))
 +		return -EFAULT;
++=======
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
 +
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +                   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +                   out_len - sizeof(resp));
  
  	if (cmd.flags & ~IB_MR_REREG_SUPPORTED || !cmd.flags)
  		return -EINVAL;
@@@ -792,40 -831,35 +874,43 @@@ put_uobjs
  	return ret;
  }
  
 -static int ib_uverbs_dereg_mr(struct uverbs_attr_bundle *attrs,
 -			      const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_dereg_mr(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   const char __user *buf, int in_len,
 +			   int out_len)
  {
  	struct ib_uverbs_dereg_mr cmd;
+ 	int ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_MR, cmd.mr_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_MR, cmd.mr_handle, file,
 +				    in_len);
  }
  
 -static int ib_uverbs_alloc_mw(struct uverbs_attr_bundle *attrs,
 -			      const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_alloc_mw(struct ib_uverbs_file *file,
 +			   struct ib_device *ib_dev,
 +			   const char __user *buf, int in_len,
 +			   int out_len)
  {
  	struct ib_uverbs_alloc_mw      cmd;
  	struct ib_uverbs_alloc_mw_resp resp;
  	struct ib_uobject             *uobj;
  	struct ib_pd                  *pd;
  	struct ib_mw                  *mw;
 +	struct ib_udata		       udata;
  	int                            ret;
 -	struct ib_device *ib_dev;
 +
 +	if (out_len < sizeof(resp))
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof(cmd)))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_alloc(UVERBS_OBJECT_MW, attrs, &ib_dev);
 +	uobj  = uobj_alloc(UVERBS_OBJECT_MW, file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -876,37 -902,35 +961,40 @@@ err_free
  	return ret;
  }
  
 -static int ib_uverbs_dealloc_mw(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_dealloc_mw(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
  {
  	struct ib_uverbs_dealloc_mw cmd;
+ 	int ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof(cmd)))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_MW, cmd.mw_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_MW, cmd.mw_handle, file,
 +				    in_len);
  }
  
 -static int ib_uverbs_create_comp_channel(struct uverbs_attr_bundle *attrs,
 -					 const char __user *buf, int in_len,
 -					 int out_len)
 +ssize_t ib_uverbs_create_comp_channel(struct ib_uverbs_file *file,
 +				      struct ib_device *ib_dev,
 +				      const char __user *buf, int in_len,
 +				      int out_len)
  {
  	struct ib_uverbs_create_comp_channel	   cmd;
  	struct ib_uverbs_create_comp_channel_resp  resp;
  	struct ib_uobject			  *uobj;
  	struct ib_uverbs_completion_event_file	  *ev_file;
 -	struct ib_device *ib_dev;
 -	int ret;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_alloc(UVERBS_OBJECT_COMP_CHANNEL, attrs, &ib_dev);
 +	uobj = uobj_alloc(UVERBS_OBJECT_COMP_CHANNEL, file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -1040,24 -1039,12 +1128,31 @@@ ssize_t ib_uverbs_create_cq(struct ib_u
  {
  	struct ib_uverbs_create_cq      cmd;
  	struct ib_uverbs_ex_create_cq	cmd_ex;
 +	struct ib_uverbs_create_cq_resp resp;
 +	struct ib_udata                 ucore;
 +	struct ib_udata                 uhw;
  	struct ib_ucq_object           *obj;
+ 	int ret;
  
++<<<<<<< HEAD
 +	if (out_len < sizeof(resp))
 +		return -ENOSPC;
 +
 +	if (copy_from_user(&cmd, buf, sizeof(cmd)))
 +		return -EFAULT;
++=======
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
 +
 +	ib_uverbs_init_udata(&ucore, buf, u64_to_user_ptr(cmd.response),
 +			     sizeof(cmd), sizeof(resp));
 +
 +	ib_uverbs_init_udata(&uhw, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
  
  	memset(&cmd_ex, 0, sizeof(cmd_ex));
  	cmd_ex.user_handle = cmd.user_handle;
@@@ -1132,15 -1095,11 +1227,16 @@@ ssize_t ib_uverbs_resize_cq(struct ib_u
  	struct ib_cq			*cq;
  	int				ret = -EINVAL;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, file->ucontext);
  	if (!cq)
  		return -EINVAL;
  
@@@ -1202,10 -1157,11 +1298,11 @@@ ssize_t ib_uverbs_poll_cq(struct ib_uve
  	struct ib_wc                   wc;
  	int                            ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);
 +	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, file->ucontext);
  	if (!cq)
  		return -EINVAL;
  
@@@ -1248,11 -1203,13 +1345,13 @@@ ssize_t ib_uverbs_req_notify_cq(struct 
  {
  	struct ib_uverbs_req_notify_cq cmd;
  	struct ib_cq                  *cq;
+ 	int ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);
 +	cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, file->ucontext);
  	if (!cq)
  		return -EINVAL;
  
@@@ -1272,15 -1227,14 +1371,20 @@@ ssize_t ib_uverbs_destroy_cq(struct ib_
  	struct ib_uverbs_destroy_cq      cmd;
  	struct ib_uverbs_destroy_cq_resp resp;
  	struct ib_uobject		*uobj;
 +	struct ib_cq               	*cq;
  	struct ib_ucq_object        	*obj;
++<<<<<<< HEAD
 +	int                        	 ret = -EINVAL;
++=======
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_get_destroy(UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);
 +	uobj  = uobj_get_write(UVERBS_OBJECT_CQ, cmd.cq_handle,
 +			       file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -1602,24 -1520,12 +1706,29 @@@ ssize_t ib_uverbs_create_qp(struct ib_u
  {
  	struct ib_uverbs_create_qp      cmd;
  	struct ib_uverbs_ex_create_qp	cmd_ex;
++<<<<<<< HEAD
 +	struct ib_udata			ucore;
 +	struct ib_udata			uhw;
 +	ssize_t resp_size = sizeof(struct ib_uverbs_create_qp_resp);
 +	int				err;
 +
 +	if (out_len < resp_size)
 +		return -ENOSPC;
++=======
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
- 	if (copy_from_user(&cmd, buf, sizeof(cmd)))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 +	ib_uverbs_init_udata(&ucore, buf, u64_to_user_ptr(cmd.response),
 +		   sizeof(cmd), resp_size);
 +	ib_uverbs_init_udata(&uhw, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + resp_size,
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - resp_size);
 +
  	memset(&cmd_ex, 0, sizeof(cmd_ex));
  	cmd_ex.user_handle = cmd.user_handle;
  	cmd_ex.pd_handle = cmd.pd_handle;
@@@ -1706,20 -1584,14 +1815,21 @@@ ssize_t ib_uverbs_open_qp(struct ib_uve
  	struct ib_qp                   *qp;
  	struct ib_qp_open_attr          attr;
  	int ret;
 -	struct ib_device *ib_dev;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	obj = (struct ib_uqp_object *)uobj_alloc(UVERBS_OBJECT_QP, attrs,
 -						 &ib_dev);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	obj  = (struct ib_uqp_object *)uobj_alloc(UVERBS_OBJECT_QP,
 +						  file->ucontext);
  	if (IS_ERR(obj))
  		return PTR_ERR(obj);
  
@@@ -2078,17 -1944,15 +2189,21 @@@ out
  	return ret;
  }
  
 -static int ib_uverbs_modify_qp(struct uverbs_attr_bundle *attrs,
 -			       const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_modify_qp(struct ib_uverbs_file *file,
 +			    struct ib_device *ib_dev,
 +			    const char __user *buf, int in_len,
 +			    int out_len)
  {
  	struct ib_uverbs_ex_modify_qp cmd = {};
++<<<<<<< HEAD
 +	struct ib_udata udata;
++=======
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  	int ret;
  
- 	if (copy_from_user(&cmd.base, buf, sizeof(cmd.base)))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd.base, sizeof(cmd.base));
+ 	if (ret)
+ 		return ret;
  
  	if (cmd.base.attr_mask &
  	    ~((IB_USER_LEGACY_LAST_QP_ATTR_MASK << 1) - 1))
@@@ -2150,15 -2002,13 +2265,20 @@@ ssize_t ib_uverbs_destroy_qp(struct ib_
  	struct ib_uverbs_destroy_qp_resp resp;
  	struct ib_uobject		*uobj;
  	struct ib_uqp_object        	*obj;
++<<<<<<< HEAD
 +	int                        	 ret = -EINVAL;
++=======
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_get_destroy(UVERBS_OBJECT_QP, cmd.qp_handle, attrs);
 +	memset(&resp, 0, sizeof resp);
 +
 +	uobj  = uobj_get_write(UVERBS_OBJECT_QP, cmd.qp_handle,
 +			       file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -2585,23 -2423,13 +2705,24 @@@ ssize_t ib_uverbs_create_ah(struct ib_u
  	struct ib_ah			*ah;
  	struct rdma_ah_attr		attr = {};
  	int ret;
 -	struct ib_device *ib_dev;
 +	struct ib_udata                   udata;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_alloc(UVERBS_OBJECT_AH, attrs, &ib_dev);
 +	if (!rdma_is_port_valid(ib_dev, cmd.attr.port_num))
 +		return -EINVAL;
 +
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	uobj  = uobj_alloc(UVERBS_OBJECT_AH, file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
@@@ -2662,23 -2492,22 +2783,25 @@@ err
  	return ret;
  }
  
 -static int ib_uverbs_destroy_ah(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_destroy_ah(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len, int out_len)
  {
  	struct ib_uverbs_destroy_ah cmd;
+ 	int ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	return uobj_perform_destroy(UVERBS_OBJECT_AH, cmd.ah_handle, attrs);
 +	return uobj_perform_destroy(UVERBS_OBJECT_AH, cmd.ah_handle, file,
 +				    in_len);
  }
  
 -static int ib_uverbs_attach_mcast(struct uverbs_attr_bundle *attrs,
 -				  const char __user *buf, int in_len,
 -				  int out_len)
 +ssize_t ib_uverbs_attach_mcast(struct ib_uverbs_file *file,
 +			       struct ib_device *ib_dev,
 +			       const char __user *buf, int in_len,
 +			       int out_len)
  {
  	struct ib_uverbs_attach_mcast cmd;
  	struct ib_qp                 *qp;
@@@ -2686,10 -2515,11 +2809,11 @@@
  	struct ib_uverbs_mcast_entry *mcast;
  	int                           ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	qp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, attrs);
 +	qp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, file->ucontext);
  	if (!qp)
  		return -EINVAL;
  
@@@ -2737,10 -2566,11 +2861,11 @@@ ssize_t ib_uverbs_detach_mcast(struct i
  	int                           ret = -EINVAL;
  	bool                          found = false;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	qp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, attrs);
 +	qp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, file->ucontext);
  	if (!qp)
  		return -EINVAL;
  
@@@ -3838,15 -3612,11 +3963,20 @@@ ssize_t ib_uverbs_create_srq(struct ib_
  {
  	struct ib_uverbs_create_srq      cmd;
  	struct ib_uverbs_create_xsrq     xcmd;
++<<<<<<< HEAD
 +	struct ib_uverbs_create_srq_resp resp;
 +	struct ib_udata                  udata;
 +	int ret;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
++=======
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
  	memset(&xcmd, 0, sizeof(xcmd));
  	xcmd.response	 = cmd.response;
@@@ -3857,63 -3627,36 +3987,69 @@@
  	xcmd.max_sge	 = cmd.max_sge;
  	xcmd.srq_limit	 = cmd.srq_limit;
  
 -	return __uverbs_create_xsrq(attrs, &xcmd, &attrs->driver_udata);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	ret = __uverbs_create_xsrq(file, ib_dev, &xcmd, &udata);
 +	if (ret)
 +		return ret;
 +
 +	return in_len;
  }
  
 -static int ib_uverbs_create_xsrq(struct uverbs_attr_bundle *attrs,
 -				 const char __user *buf, int in_len,
 -				 int out_len)
 +ssize_t ib_uverbs_create_xsrq(struct ib_uverbs_file *file,
 +			      struct ib_device *ib_dev,
 +			      const char __user *buf, int in_len, int out_len)
  {
  	struct ib_uverbs_create_xsrq     cmd;
++<<<<<<< HEAD
 +	struct ib_uverbs_create_srq_resp resp;
 +	struct ib_udata                  udata;
 +	int ret;
 +
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
++=======
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	return __uverbs_create_xsrq(attrs, &cmd, &attrs->driver_udata);
 +	ib_uverbs_init_udata(&udata, buf + sizeof(cmd),
 +		   u64_to_user_ptr(cmd.response) + sizeof(resp),
 +		   in_len - sizeof(cmd) - sizeof(struct ib_uverbs_cmd_hdr),
 +		   out_len - sizeof(resp));
 +
 +	ret = __uverbs_create_xsrq(file, ib_dev, &cmd, &udata);
 +	if (ret)
 +		return ret;
 +
 +	return in_len;
  }
  
 -static int ib_uverbs_modify_srq(struct uverbs_attr_bundle *attrs,
 -				const char __user *buf, int in_len, int out_len)
 +ssize_t ib_uverbs_modify_srq(struct ib_uverbs_file *file,
 +			     struct ib_device *ib_dev,
 +			     const char __user *buf, int in_len,
 +			     int out_len)
  {
  	struct ib_uverbs_modify_srq cmd;
 +	struct ib_udata             udata;
  	struct ib_srq              *srq;
  	struct ib_srq_attr          attr;
  	int                         ret;
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	srq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, attrs);
 +	ib_uverbs_init_udata(&udata, buf + sizeof cmd, NULL, in_len - sizeof cmd,
 +		   out_len);
 +
 +	srq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, file->ucontext);
  	if (!srq)
  		return -EINVAL;
  
@@@ -3938,13 -3680,11 +4074,19 @@@ ssize_t ib_uverbs_query_srq(struct ib_u
  	struct ib_srq                   *srq;
  	int                             ret;
  
++<<<<<<< HEAD
 +	if (out_len < sizeof resp)
 +		return -ENOSPC;
 +
 +	if (copy_from_user(&cmd, buf, sizeof cmd))
 +		return -EFAULT;
++=======
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
 -	srq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, attrs);
 +	srq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, file->ucontext);
  	if (!srq)
  		return -EINVAL;
  
@@@ -3976,13 -3712,13 +4118,18 @@@ ssize_t ib_uverbs_destroy_srq(struct ib
  	struct ib_uverbs_destroy_srq_resp resp;
  	struct ib_uobject		 *uobj;
  	struct ib_uevent_object        	 *obj;
++<<<<<<< HEAD
 +	int                         	  ret = -EINVAL;
++=======
+ 	int ret;
++>>>>>>> 3c2c20947ddb (RDMA/uverbs: Use uverbs_request() for request copying)
  
- 	if (copy_from_user(&cmd, buf, sizeof cmd))
- 		return -EFAULT;
+ 	ret = uverbs_request(attrs, &cmd, sizeof(cmd));
+ 	if (ret)
+ 		return ret;
  
 -	uobj = uobj_get_destroy(UVERBS_OBJECT_SRQ, cmd.srq_handle, attrs);
 +	uobj  = uobj_get_write(UVERBS_OBJECT_SRQ, cmd.srq_handle,
 +			       file->ucontext);
  	if (IS_ERR(uobj))
  		return PTR_ERR(uobj);
  
* Unmerged path drivers/infiniband/core/uverbs_cmd.c
