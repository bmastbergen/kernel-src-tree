ovl: add support for "nfs_export" configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit f168f1098dd9038daaf9f7be5f81cdea4985886a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f168f109.failed

Introduce the "nfs_export" config, module and mount options.

The NFS export feature depends on the "index" feature and enables two
implicit overlayfs features: "index_all" and "verify_lower".
The "index_all" feature creates an index on copy up of every file and
directory. The "verify_lower" feature uses the full index to detect
overlay filesystems inconsistencies on lookup, like redirect from
multiple upper dirs to the same lower dir.

NFS export can be enabled for non-upper mount with no index. However,
because lower layer redirects cannot be verified with the index, enabling
NFS export support on an overlay with no upper layer requires turning off
redirect follow (e.g. "redirect_dir=nofollow").

The full index may incur some overhead on mount time, especially when
verifying that lower directory file handles are not stale.

NFS export support, full index and consistency verification will be
implemented by following patches.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit f168f1098dd9038daaf9f7be5f81cdea4985886a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index d3038555ac46,1d538be87fa0..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -46,6 -45,19 +46,22 @@@ module_param_named(index, ovl_index_def
  MODULE_PARM_DESC(ovl_index_def,
  		 "Default to on or off for the inodes index feature");
  
++<<<<<<< HEAD
++=======
+ static bool ovl_nfs_export_def = IS_ENABLED(CONFIG_OVERLAY_FS_NFS_EXPORT);
+ module_param_named(nfs_export, ovl_nfs_export_def, bool, 0644);
+ MODULE_PARM_DESC(ovl_nfs_export_def,
+ 		 "Default to on or off for the NFS export feature");
+ 
+ static void ovl_entry_stack_free(struct ovl_entry *oe)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < oe->numlower; i++)
+ 		dput(oe->lowerstack[i].dentry);
+ }
+ 
++>>>>>>> f168f1098dd9 (ovl: add support for "nfs_export" configuration)
  static void ovl_dentry_release(struct dentry *dentry)
  {
  	struct ovl_entry *oe = dentry->d_fsdata;
@@@ -309,19 -334,22 +325,29 @@@ static const char *ovl_redirect_mode_de
  static int ovl_show_options(struct seq_file *m, struct dentry *dentry)
  {
  	struct super_block *sb = dentry->d_sb;
 -	struct ovl_fs *ofs = sb->s_fs_info;
 +	struct ovl_fs *ufs = sb->s_fs_info;
  
 -	seq_show_option(m, "lowerdir", ofs->config.lowerdir);
 -	if (ofs->config.upperdir) {
 -		seq_show_option(m, "upperdir", ofs->config.upperdir);
 -		seq_show_option(m, "workdir", ofs->config.workdir);
 +	seq_show_option(m, "lowerdir", ufs->config.lowerdir);
 +	if (ufs->config.upperdir) {
 +		seq_show_option(m, "upperdir", ufs->config.upperdir);
 +		seq_show_option(m, "workdir", ufs->config.workdir);
  	}
 -	if (ofs->config.default_permissions)
 +	if (ufs->config.default_permissions)
  		seq_puts(m, ",default_permissions");
++<<<<<<< HEAD
 +	if (strcmp(ufs->config.redirect_mode, ovl_redirect_mode_def()) != 0)
 +		seq_printf(m, ",redirect_dir=%s", ufs->config.redirect_mode);
 +	if (ufs->config.index != ovl_index_def)
 +		seq_printf(m, ",index=%s", ufs->config.index ? "on" : "off");
++=======
+ 	if (strcmp(ofs->config.redirect_mode, ovl_redirect_mode_def()) != 0)
+ 		seq_printf(m, ",redirect_dir=%s", ofs->config.redirect_mode);
+ 	if (ofs->config.index != ovl_index_def)
+ 		seq_printf(m, ",index=%s", ofs->config.index ? "on" : "off");
+ 	if (ofs->config.nfs_export != ovl_nfs_export_def)
+ 		seq_printf(m, ",nfs_export=%s", ofs->config.nfs_export ?
+ 						"on" : "off");
++>>>>>>> f168f1098dd9 (ovl: add support for "nfs_export" configuration)
  	return 0;
  }
  
@@@ -692,12 -716,16 +730,20 @@@ static int ovl_lower_dir(const char *na
  		*remote = true;
  
  	/*
- 	 * The inodes index feature needs to encode and decode file
- 	 * handles, so it requires that all layers support them.
+ 	 * The inodes index feature and NFS export need to encode and decode
+ 	 * file handles, so they require that all layers support them.
  	 */
++<<<<<<< HEAD
 +	if (ofs->config.index && !ovl_can_decode_fh(path->dentry->d_sb)) {
++=======
+ 	if ((ofs->config.nfs_export ||
+ 	     (ofs->config.index && ofs->config.upperdir)) &&
+ 	    !ovl_can_decode_fh(path->dentry->d_sb)) {
++>>>>>>> f168f1098dd9 (ovl: add support for "nfs_export" configuration)
  		ofs->config.index = false;
- 		pr_warn("overlayfs: fs on '%s' does not support file handles, falling back to index=off.\n", name);
+ 		ofs->config.nfs_export = false;
+ 		pr_warn("overlayfs: fs on '%s' does not support file handles, falling back to index=off,nfs_export=off.\n",
+ 			name);
  	}
  
  	return 0;
@@@ -871,131 -902,278 +917,258 @@@ static const struct xattr_handler *ovl_
  	NULL
  };
  
 -static int ovl_get_upper(struct ovl_fs *ofs, struct path *upperpath)
 +static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
++<<<<<<< HEAD
 +	struct path upperpath = { };
++=======
+ 	struct vfsmount *upper_mnt;
+ 	int err;
+ 
+ 	err = ovl_mount_dir(ofs->config.upperdir, upperpath);
+ 	if (err)
+ 		goto out;
+ 
+ 	/* Upper fs should not be r/o */
+ 	if (sb_rdonly(upperpath->mnt->mnt_sb)) {
+ 		pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	err = ovl_check_namelen(upperpath, ofs, ofs->config.upperdir);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = -EBUSY;
+ 	if (ovl_inuse_trylock(upperpath->dentry)) {
+ 		ofs->upperdir_locked = true;
+ 	} else if (ofs->config.index) {
+ 		pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
+ 		goto out;
+ 	} else {
+ 		pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
+ 	}
+ 
+ 	upper_mnt = clone_private_mount(upperpath);
+ 	err = PTR_ERR(upper_mnt);
+ 	if (IS_ERR(upper_mnt)) {
+ 		pr_err("overlayfs: failed to clone upperpath\n");
+ 		goto out;
+ 	}
+ 
+ 	/* Don't inherit atime flags */
+ 	upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
+ 	ofs->upper_mnt = upper_mnt;
+ 	err = 0;
+ out:
+ 	return err;
+ }
+ 
+ static int ovl_make_workdir(struct ovl_fs *ofs, struct path *workpath)
+ {
+ 	struct vfsmount *mnt = ofs->upper_mnt;
+ 	struct dentry *temp;
+ 	int err;
+ 
+ 	err = mnt_want_write(mnt);
+ 	if (err)
+ 		return err;
+ 
+ 	ofs->workdir = ovl_workdir_create(ofs, OVL_WORKDIR_NAME, false);
+ 	if (!ofs->workdir)
+ 		goto out;
+ 
+ 	/*
+ 	 * Upper should support d_type, else whiteouts are visible.  Given
+ 	 * workdir and upper are on same fs, we can do iterate_dir() on
+ 	 * workdir. This check requires successful creation of workdir in
+ 	 * previous step.
+ 	 */
+ 	err = ovl_check_d_type_supported(workpath);
+ 	if (err < 0)
+ 		goto out;
+ 
+ 	/*
+ 	 * We allowed this configuration and don't want to break users over
+ 	 * kernel upgrade. So warn instead of erroring out.
+ 	 */
+ 	if (!err)
+ 		pr_warn("overlayfs: upper fs needs to support d_type.\n");
+ 
+ 	/* Check if upper/work fs supports O_TMPFILE */
+ 	temp = ovl_do_tmpfile(ofs->workdir, S_IFREG | 0);
+ 	ofs->tmpfile = !IS_ERR(temp);
+ 	if (ofs->tmpfile)
+ 		dput(temp);
+ 	else
+ 		pr_warn("overlayfs: upper fs does not support tmpfile.\n");
+ 
+ 	/*
+ 	 * Check if upper/work fs supports trusted.overlay.* xattr
+ 	 */
+ 	err = ovl_do_setxattr(ofs->workdir, OVL_XATTR_OPAQUE, "0", 1, 0);
+ 	if (err) {
+ 		ofs->noxattr = true;
+ 		ofs->config.index = false;
+ 		pr_warn("overlayfs: upper fs does not support xattr, falling back to index=off.\n");
+ 		err = 0;
+ 	} else {
+ 		vfs_removexattr(ofs->workdir, OVL_XATTR_OPAQUE);
+ 	}
+ 
+ 	/* Check if upper/work fs supports file handles */
+ 	if (ofs->config.index &&
+ 	    !ovl_can_decode_fh(ofs->workdir->d_sb)) {
+ 		ofs->config.index = false;
+ 		pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
+ 	}
+ 
+ 	/* NFS export of r/w mount depends on index */
+ 	if (ofs->config.nfs_export && !ofs->config.index) {
+ 		pr_warn("overlayfs: NFS export requires \"index=on\", falling back to nfs_export=off.\n");
+ 		ofs->config.nfs_export = false;
+ 	}
+ 
+ out:
+ 	mnt_drop_write(mnt);
+ 	return err;
+ }
+ 
+ static int ovl_get_workdir(struct ovl_fs *ofs, struct path *upperpath)
+ {
+ 	int err;
++>>>>>>> f168f1098dd9 (ovl: add support for "nfs_export" configuration)
  	struct path workpath = { };
 +	struct dentry *root_dentry;
 +	struct ovl_entry *oe;
 +	struct ovl_fs *ufs;
 +	const int *upper_stack_depth;
 +	int *overlay_stack_depth;
 +	struct path *stack = NULL;
 +	char *lowertmp;
 +	char *lower;
 +	unsigned int numlower;
 +	unsigned int stacklen = 0;
 +	unsigned int i;
 +	bool remote = false;
 +	struct cred *cred;
 +	int err;
  
 -	err = ovl_mount_dir(ofs->config.workdir, &workpath);
 -	if (err)
 +	err = -ENOMEM;
 +	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
 +	if (!ufs)
  		goto out;
  
 +	ufs->config.index = ovl_index_def;
 +	err = ovl_parse_opt((char *) data, &ufs->config);
 +	if (err)
 +		goto out_free_config;
 +
  	err = -EINVAL;
 -	if (upperpath->mnt != workpath.mnt) {
 -		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 -		goto out;
 -	}
 -	if (!ovl_workdir_ok(workpath.dentry, upperpath->dentry)) {
 -		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 -		goto out;
 +	if (!ufs->config.lowerdir) {
 +		if (!silent)
 +			pr_err("overlayfs: missing 'lowerdir'\n");
 +		goto out_free_config;
  	}
  
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(workpath.dentry)) {
 -		ofs->workdir_locked = true;
 -	} else if (ofs->config.index) {
 -		pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_free_config;
  	}
 +	*overlay_stack_depth = 0;
  
 -	ofs->workbasedir = dget(workpath.dentry);
 -	err = ovl_make_workdir(ofs, &workpath);
 -	if (err)
 -		goto out;
 -
 -	err = 0;
 -out:
 -	path_put(&workpath);
 -
 -	return err;
 -}
 -
 -static int ovl_get_indexdir(struct ovl_fs *ofs, struct ovl_entry *oe,
 -			    struct path *upperpath)
 -{
 -	struct vfsmount *mnt = ofs->upper_mnt;
 -	int err;
 -
 -	err = mnt_want_write(mnt);
 -	if (err)
 -		return err;
 -
 -	/* Verify lower root is upper root origin */
 -	err = ovl_verify_origin(upperpath->dentry, oe->lowerstack[0].dentry,
 -				true);
 -	if (err) {
 -		pr_err("overlayfs: failed to verify upper root origin\n");
 -		goto out;
 -	}
 +	sb->s_maxbytes = MAX_LFS_FILESIZE;
 +	if (ufs->config.upperdir) {
 +		if (!ufs->config.workdir) {
 +			pr_err("overlayfs: missing 'workdir'\n");
 +			goto out_free_config;
 +		}
  
 -	ofs->indexdir = ovl_workdir_create(ofs, OVL_INDEXDIR_NAME, true);
 -	if (ofs->indexdir) {
 -		/* Verify upper root is exclusively associated with index dir */
 -		err = ovl_verify_set_fh(ofs->indexdir, OVL_XATTR_ORIGIN,
 -					upperpath->dentry, true, true);
 +		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
  		if (err)
 -			pr_err("overlayfs: failed to verify index dir origin\n");
 +			goto out_free_config;
  
 -		/* Cleanup bad/stale/orphan index entries */
 -		if (!err)
 -			err = ovl_indexdir_cleanup(ofs);
 -	}
 -	if (err || !ofs->indexdir)
 -		pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
 -
 -out:
 -	mnt_drop_write(mnt);
 -	return err;
 -}
 +		/* Upper fs should not be r/o */
 +		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
 +			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 +			err = -EINVAL;
 +			goto out_put_upperpath;
 +		}
  
 -static int ovl_get_lower_layers(struct ovl_fs *ofs, struct path *stack,
 -				unsigned int numlower)
 -{
 -	int err;
 -	unsigned int i;
 +		err = ovl_check_namelen(&upperpath, ufs, ufs->config.upperdir);
 +		if (err)
 +			goto out_put_upperpath;
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(upperpath.dentry)) {
 +			ufs->upperdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 +			goto out_put_upperpath;
 +		} else {
 +			pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
  
 -	err = -ENOMEM;
 -	ofs->lower_layers = kcalloc(numlower, sizeof(struct ovl_layer),
 -				    GFP_KERNEL);
 -	if (ofs->lower_layers == NULL)
 -		goto out;
 -	for (i = 0; i < numlower; i++) {
 -		struct vfsmount *mnt;
 -		dev_t dev;
 +		err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +		if (err)
 +			goto out_unlock_upperdentry;
  
 -		err = get_anon_bdev(&dev);
 -		if (err) {
 -			pr_err("overlayfs: failed to get anonymous bdev for lowerpath\n");
 -			goto out;
 +		err = -EINVAL;
 +		if (upperpath.mnt != workpath.mnt) {
 +			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +			goto out_put_workpath;
 +		}
 +		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +			goto out_put_workpath;
  		}
  
 -		mnt = clone_private_mount(&stack[i]);
 -		err = PTR_ERR(mnt);
 -		if (IS_ERR(mnt)) {
 -			pr_err("overlayfs: failed to clone lowerpath\n");
 -			free_anon_bdev(dev);
 -			goto out;
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(workpath.dentry)) {
 +			ufs->workdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 +			goto out_put_workpath;
 +		} else {
 +			pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
  		}
 -		/*
 -		 * Make lower layers R/O.  That way fchmod/fchown on lower file
 -		 * will fail instead of modifying lower fs.
 -		 */
 -		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
  
 -		ofs->lower_layers[ofs->numlower].mnt = mnt;
 -		ofs->lower_layers[ofs->numlower].pseudo_dev = dev;
 -		ofs->lower_layers[ofs->numlower].idx = i + 1;
 -		ofs->numlower++;
 +		ufs->workbasedir = workpath.dentry;
 +		upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +		err = -EOPNOTSUPP;
 +		if (!upper_stack_depth) {
 +			pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +			goto out_put_workpath;
 +		}
  
 -		/* Check if all lower layers are on same sb */
 -		if (i == 0)
 -			ofs->same_sb = mnt->mnt_sb;
 -		else if (ofs->same_sb != mnt->mnt_sb)
 -			ofs->same_sb = NULL;
 +		*overlay_stack_depth = *upper_stack_depth;
  	}
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static struct ovl_entry *ovl_get_lowerstack(struct super_block *sb,
 -					    struct ovl_fs *ofs)
 -{
 -	int err;
 -	char *lowertmp, *lower;
 -	struct path *stack = NULL;
 -	unsigned int stacklen, numlower = 0, i;
 -	bool remote = false;
 -	struct ovl_entry *oe;
  
  	err = -ENOMEM;
 -	lowertmp = kstrdup(ofs->config.lowerdir, GFP_KERNEL);
 +	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
  	if (!lowertmp)
 -		goto out_err;
 +		goto out_unlock_workdentry;
  
  	err = -EINVAL;
  	stacklen = ovl_split_lowerdirs(lowertmp);
  	if (stacklen > OVL_MAX_STACK) {
  		pr_err("overlayfs: too many lower directories, limit is %d\n",
  		       OVL_MAX_STACK);
 -		goto out_err;
 -	} else if (!ofs->config.upperdir && stacklen == 1) {
 +		goto out_free_lowertmp;
 +	} else if (!ufs->config.upperdir && stacklen == 1) {
  		pr_err("overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n");
++<<<<<<< HEAD
 +		goto out_free_lowertmp;
++=======
+ 		goto out_err;
+ 	} else if (!ofs->config.upperdir && ofs->config.nfs_export &&
+ 		   ofs->config.redirect_follow) {
+ 		pr_warn("overlayfs: NFS export requires \"redirect_dir=nofollow\" on non-upper mount, falling back to nfs_export=off.\n");
+ 		ofs->config.nfs_export = false;
++>>>>>>> f168f1098dd9 (ovl: add support for "nfs_export" configuration)
  	}
  
  	err = -ENOMEM;
@@@ -1015,154 -1193,131 +1188,237 @@@
  	}
  
  	err = -EINVAL;
 -	sb->s_stack_depth++;
 -	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 +	*overlay_stack_depth += 1;
 +	if (*overlay_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
  		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 -		goto out_err;
 +		goto out_put_lowerpath;
  	}
  
++<<<<<<< HEAD
 +	if (ufs->config.upperdir) {
 +		ufs->upper_mnt = clone_private_mount(&upperpath);
 +		err = PTR_ERR(ufs->upper_mnt);
 +		if (IS_ERR(ufs->upper_mnt)) {
 +			pr_err("overlayfs: failed to clone upperpath\n");
 +			goto out_put_lowerpath;
++=======
+ 	err = ovl_get_lower_layers(ofs, stack, numlower);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	err = -ENOMEM;
+ 	oe = ovl_alloc_entry(numlower);
+ 	if (!oe)
+ 		goto out_err;
+ 
+ 	for (i = 0; i < numlower; i++) {
+ 		oe->lowerstack[i].dentry = dget(stack[i].dentry);
+ 		oe->lowerstack[i].layer = &ofs->lower_layers[i];
+ 	}
+ 
+ 	if (remote)
+ 		sb->s_d_op = &ovl_reval_dentry_operations;
+ 	else
+ 		sb->s_d_op = &ovl_dentry_operations;
+ 
+ out:
+ 	for (i = 0; i < numlower; i++)
+ 		path_put(&stack[i]);
+ 	kfree(stack);
+ 	kfree(lowertmp);
+ 
+ 	return oe;
+ 
+ out_err:
+ 	oe = ERR_PTR(err);
+ 	goto out;
+ }
+ 
+ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
+ {
+ 	struct path upperpath = { };
+ 	struct dentry *root_dentry;
+ 	struct ovl_entry *oe;
+ 	struct ovl_fs *ofs;
+ 	struct cred *cred;
+ 	int err;
+ 
+ 	err = -ENOMEM;
+ 	ofs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
+ 	if (!ofs)
+ 		goto out;
+ 
+ 	ofs->creator_cred = cred = prepare_creds();
+ 	if (!cred)
+ 		goto out_err;
+ 
+ 	ofs->config.index = ovl_index_def;
+ 	ofs->config.nfs_export = ovl_nfs_export_def;
+ 	err = ovl_parse_opt((char *) data, &ofs->config);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	err = -EINVAL;
+ 	if (!ofs->config.lowerdir) {
+ 		if (!silent)
+ 			pr_err("overlayfs: missing 'lowerdir'\n");
+ 		goto out_err;
+ 	}
+ 
+ 	sb->s_stack_depth = 0;
+ 	sb->s_maxbytes = MAX_LFS_FILESIZE;
+ 	if (ofs->config.upperdir) {
+ 		if (!ofs->config.workdir) {
+ 			pr_err("overlayfs: missing 'workdir'\n");
+ 			goto out_err;
++>>>>>>> f168f1098dd9 (ovl: add support for "nfs_export" configuration)
  		}
  
 -		err = ovl_get_upper(ofs, &upperpath);
 -		if (err)
 -			goto out_err;
 +		/* Don't inherit atime flags */
 +		ufs->upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
  
 -		err = ovl_get_workdir(ofs, &upperpath);
 -		if (err)
 -			goto out_err;
 +		sb->s_time_gran = ufs->upper_mnt->mnt_sb->s_time_gran;
 +
 +		ufs->workdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 +						  OVL_WORKDIR_NAME, false);
 +		/*
 +		 * Upper should support d_type, else whiteouts are visible.
 +		 * Given workdir and upper are on same fs, we can do
 +		 * iterate_dir() on workdir. This check requires successful
 +		 * creation of workdir in previous step.
 +		 */
 +		if (ufs->workdir) {
 +			struct dentry *temp;
 +
 +			err = ovl_check_d_type_supported(&workpath);
 +			if (err < 0)
 +				goto out_put_workdir;
 +
 +			/*
 +			 * Warn instead of error to avoid breaking previously
 +			 * working configurations over upgrade. If d_type
 +			 * is not supported, whiteouts will become visible
 +			 * to user space.
 +			 */
 +			if (!err)
 +				pr_warn("overlayfs: upper fs needs to support d_type. This is an invalid configuration.\n");
 +
 +			/* Check if upper/work fs supports O_TMPFILE */
 +			temp = ovl_do_tmpfile(ufs->workdir, S_IFREG | 0);
 +			ufs->tmpfile = !IS_ERR(temp);
 +			if (ufs->tmpfile)
 +				dput(temp);
 +
 +			/*
 +			 * Check if upper/work fs supports trusted.overlay.*
 +			 * xattr
 +			 */
 +			err = ovl_do_setxattr(ufs->workdir, OVL_XATTR_OPAQUE,
 +					      "0", 1, 0);
 +			if (err) {
 +				ufs->noxattr = true;
 +				pr_warn("overlayfs: upper fs does not support xattr.\n");
 +			} else {
 +				vfs_removexattr(ufs->workdir, OVL_XATTR_OPAQUE);
 +			}
 +
 +			/* Check if upper/work fs supports file handles */
 +			if (ufs->config.index &&
 +			    !ovl_can_decode_fh(ufs->workdir->d_sb)) {
 +				ufs->config.index = false;
 +				pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
 +			}
 +		}
 +	}
 +
 +	err = -ENOMEM;
 +	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
 +	if (ufs->lower_mnt == NULL)
 +		goto out_put_workdir;
 +	for (i = 0; i < numlower; i++) {
 +		struct vfsmount *mnt = clone_private_mount(&stack[i]);
  
 -		if (!ofs->workdir)
 -			sb->s_flags |= SB_RDONLY;
 +		err = PTR_ERR(mnt);
 +		if (IS_ERR(mnt)) {
 +			pr_err("overlayfs: failed to clone lowerpath\n");
 +			goto out_put_lower_mnt;
 +		}
 +		/*
 +		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 +		 * will fail instead of modifying lower fs.
 +		 */
 +		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
  
 -		sb->s_stack_depth = ofs->upper_mnt->mnt_sb->s_stack_depth;
 -		sb->s_time_gran = ofs->upper_mnt->mnt_sb->s_time_gran;
 +		ufs->lower_mnt[ufs->numlower] = mnt;
 +		ufs->numlower++;
  
 +		/* Check if all lower layers are on same sb */
 +		if (i == 0)
 +			ufs->same_sb = mnt->mnt_sb;
 +		else if (ufs->same_sb != mnt->mnt_sb)
 +			ufs->same_sb = NULL;
  	}
 -	oe = ovl_get_lowerstack(sb, ofs);
 -	err = PTR_ERR(oe);
 -	if (IS_ERR(oe))
 -		goto out_err;
  
  	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
 -	if (!ofs->upper_mnt)
 -		sb->s_flags |= SB_RDONLY;
 -	else if (ofs->upper_mnt->mnt_sb != ofs->same_sb)
 -		ofs->same_sb = NULL;
 +	if (!ufs->upper_mnt)
 +		sb->s_flags |= MS_RDONLY;
 +	else if (ufs->upper_mnt->mnt_sb != ufs->same_sb)
 +		ufs->same_sb = NULL;
 +
 +	if (!(ovl_force_readonly(ufs)) && ufs->config.index) {
 +		/* Verify lower root is upper root origin */
 +		err = ovl_verify_origin(upperpath.dentry, ufs->lower_mnt[0],
 +					stack[0].dentry, false, true);
 +		if (err) {
 +			pr_err("overlayfs: failed to verify upper root origin\n");
 +			goto out_put_lower_mnt;
 +		}
  
 -	if (!(ovl_force_readonly(ofs)) && ofs->config.index) {
 -		err = ovl_get_indexdir(ofs, oe, &upperpath);
 -		if (err)
 -			goto out_free_oe;
 +		ufs->indexdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 +						   OVL_INDEXDIR_NAME, true);
 +		if (ufs->indexdir) {
 +			/* Verify upper root is index dir origin */
 +			err = ovl_verify_origin(ufs->indexdir, ufs->upper_mnt,
 +						upperpath.dentry, true, true);
 +			if (err)
 +				pr_err("overlayfs: failed to verify index dir origin\n");
  
 -		/* Force r/o mount with no index dir */
 -		if (!ofs->indexdir) {
 -			dput(ofs->workdir);
 -			ofs->workdir = NULL;
 -			sb->s_flags |= SB_RDONLY;
 +			/* Cleanup bad/stale/orphan index entries */
 +			if (!err)
 +				err = ovl_indexdir_cleanup(ufs->indexdir,
 +							   ufs->upper_mnt,
 +							   stack, numlower);
  		}
 -
 +		if (err || !ufs->indexdir)
 +			pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
 +		if (err)
 +			goto out_put_indexdir;
  	}
  
++<<<<<<< HEAD
 +	/* Show index=off/on in /proc/mounts for any of the reasons above */
 +	if (!ufs->indexdir)
 +		ufs->config.index = false;
 +
 +	if (remote)
 +		sb->s_d_op = &ovl_reval_dentry_operations.ops;
 +	else
 +		sb->s_d_op = &ovl_dentry_operations.ops;
 +
 +	err = -ENOMEM;
 +	ufs->creator_cred = cred = prepare_creds();
 +	if (!cred)
 +		goto out_put_indexdir;
++=======
+ 	/* Show index=off in /proc/mounts for forced r/o mount */
+ 	if (!ofs->indexdir) {
+ 		ofs->config.index = false;
+ 		if (ofs->upper_mnt && ofs->config.nfs_export) {
+ 			pr_warn("overlayfs: NFS export requires an index dir, falling back to nfs_export=off.\n");
+ 			ofs->config.nfs_export = false;
+ 		}
+ 	}
++>>>>>>> f168f1098dd9 (ovl: add support for "nfs_export" configuration)
  
  	/* Never override disk quota limits or use reserved space */
  	cap_lower(cred->cap_effective, CAP_SYS_RESOURCE);
diff --git a/Documentation/filesystems/overlayfs.txt b/Documentation/filesystems/overlayfs.txt
index 213547cb6d36..7a05329844d2 100644
--- a/Documentation/filesystems/overlayfs.txt
+++ b/Documentation/filesystems/overlayfs.txt
@@ -190,6 +190,24 @@ Mount options:
     Redirects are not created and not followed (equivalent to "redirect_dir=off"
     if "redirect_always_follow" feature is not enabled).
 
+When the NFS export feature is enabled, every copied up directory is
+indexed by the file handle of the lower inode and a file handle of the
+upper directory is stored in a "trusted.overlay.upper" extended attribute
+on the index entry.  On lookup of a merged directory, if the upper
+directory does not match the file handle stores in the index, that is an
+indication that multiple upper directories may be redirected to the same
+lower directory.  In that case, lookup returns an error and warns about
+a possible inconsistency.
+
+Because lower layer redirects cannot be verified with the index, enabling
+NFS export support on an overlay filesystem with no upper layer requires
+turning off redirect follow (e.g. "redirect_dir=nofollow").
+
+When the NFS export feature is enabled, all directory index entries are
+verified on mount time to check that upper file handles are not stale.
+This verification may cause significant overhead in some cases.
+
+
 Non-directories
 ---------------
 
@@ -299,6 +317,23 @@ filesystem are not allowed.  If the underlying filesystem is changed,
 the behavior of the overlay is undefined, though it will not result in
 a crash or deadlock.
 
+When the overlay NFS export feature is enabled, overlay filesystems
+behavior on offline changes of the underlying lower layer is different
+than the behavior when NFS export is disabled.
+
+On every copy_up, an NFS file handle of the lower inode, along with the
+UUID of the lower filesystem, are encoded and stored in an extended
+attribute "trusted.overlay.origin" on the upper inode.
+
+When the NFS export feature is enabled, a lookup of a merged directory,
+that found a lower directory at the lookup path or at the path pointed
+to by the "trusted.overlay.redirect" extended attribute, will verify
+that the found lower directory file handle and lower filesystem UUID
+match the origin file handle that was stored at copy_up time.  If a
+found lower directory does not match the stored origin, that directory
+will not be merged with the upper directory.
+
+
 Testsuite
 ---------
 
diff --git a/fs/overlayfs/Kconfig b/fs/overlayfs/Kconfig
index 9eac01c3e21e..406e72de88f6 100644
--- a/fs/overlayfs/Kconfig
+++ b/fs/overlayfs/Kconfig
@@ -50,3 +50,25 @@ config OVERLAY_FS_INDEX
 	  Note, that the inodes index feature is not backward compatible.
 	  That is, mounting an overlay which has an inodes index on a kernel
 	  that doesn't support this feature will have unexpected results.
+
+config OVERLAY_FS_NFS_EXPORT
+	bool "Overlayfs: turn on NFS export feature by default"
+	depends on OVERLAY_FS
+	depends on OVERLAY_FS_INDEX
+	help
+	  If this config option is enabled then overlay filesystems will use
+	  the inodes index dir to decode overlay NFS file handles by default.
+	  In this case, it is still possible to turn off NFS export support
+	  globally with the "nfs_export=off" module option or on a filesystem
+	  instance basis with the "nfs_export=off" mount option.
+
+	  The NFS export feature creates an index on copy up of every file and
+	  directory.  This full index is used to detect overlay filesystems
+	  inconsistencies on lookup, like redirect from multiple upper dirs to
+	  the same lower dir.  The full index may incur some overhead on mount
+	  time, especially when verifying that directory file handles are not
+	  stale.
+
+	  Note, that the NFS export feature is not backward compatible.
+	  That is, mounting an overlay which has a full index on a kernel
+	  that doesn't support this feature will have unexpected results.
diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 79baeaeaf3d6..061981c282db 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -191,6 +191,8 @@ const struct cred *ovl_override_creds(struct super_block *sb);
 struct super_block *ovl_same_sb(struct super_block *sb);
 bool ovl_can_decode_fh(struct super_block *sb);
 struct dentry *ovl_indexdir(struct super_block *sb);
+bool ovl_index_all(struct super_block *sb);
+bool ovl_verify_lower(struct super_block *sb);
 struct ovl_entry *ovl_alloc_entry(unsigned int numlower);
 bool ovl_dentry_remote(struct dentry *dentry);
 bool ovl_dentry_weird(struct dentry *dentry);
diff --git a/fs/overlayfs/ovl_entry.h b/fs/overlayfs/ovl_entry.h
index ec700f861f1b..01381aefa28f 100644
--- a/fs/overlayfs/ovl_entry.h
+++ b/fs/overlayfs/ovl_entry.h
@@ -17,6 +17,7 @@ struct ovl_config {
 	bool redirect_follow;
 	const char *redirect_mode;
 	bool index;
+	bool nfs_export;
 };
 
 /* private information held for overlayfs's superblock */
* Unmerged path fs/overlayfs/super.c
diff --git a/fs/overlayfs/util.c b/fs/overlayfs/util.c
index bc47cf517de9..b1903dfc206b 100644
--- a/fs/overlayfs/util.c
+++ b/fs/overlayfs/util.c
@@ -66,6 +66,22 @@ struct dentry *ovl_indexdir(struct super_block *sb)
 	return ofs->indexdir;
 }
 
+/* Index all files on copy up. For now only enabled for NFS export */
+bool ovl_index_all(struct super_block *sb)
+{
+	struct ovl_fs *ofs = sb->s_fs_info;
+
+	return ofs->config.nfs_export && ofs->config.index;
+}
+
+/* Verify lower origin on lookup. For now only enabled for NFS export */
+bool ovl_verify_lower(struct super_block *sb)
+{
+	struct ovl_fs *ofs = sb->s_fs_info;
+
+	return ofs->config.nfs_export && ofs->config.index;
+}
+
 struct ovl_entry *ovl_alloc_entry(unsigned int numlower)
 {
 	size_t size = offsetof(struct ovl_entry, lowerstack[numlower]);
