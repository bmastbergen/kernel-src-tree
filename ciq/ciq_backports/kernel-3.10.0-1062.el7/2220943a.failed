phy: Centralise print about attached phy

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Andrew Lunn <andrew@lunn.ch>
commit 2220943a21e26d97d7fd8f83c004b947326b469d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/2220943a.failed

Many Ethernet drivers contain the same netdev_info() print statement
about the attached phy. Move it into the phy device code. Additionally
add a varargs function which can be used to append additional
information.

	Signed-off-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2220943a21e26d97d7fd8f83c004b947326b469d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/adi/bfin_mac.c
#	drivers/net/ethernet/amd/au1000_eth.c
#	drivers/net/ethernet/broadcom/b44.c
#	drivers/net/ethernet/broadcom/tg3.c
#	drivers/net/ethernet/cadence/macb.c
#	drivers/net/ethernet/dnet.c
#	drivers/net/ethernet/lantiq_etop.c
#	drivers/net/ethernet/nxp/lpc_eth.c
#	drivers/net/ethernet/rdc/r6040.c
#	drivers/net/ethernet/renesas/ravb_main.c
#	drivers/net/ethernet/renesas/sh_eth.c
#	drivers/net/ethernet/smsc/smsc911x.c
#	drivers/net/ethernet/smsc/smsc9420.c
#	drivers/net/ethernet/synopsys/dwc_eth_qos.c
#	drivers/net/ethernet/ti/davinci_emac.c
#	drivers/net/ethernet/toshiba/tc35815.c
#	drivers/staging/et131x/et131x.c
#	drivers/staging/netlogic/xlr_net.c
#	include/linux/phy.h
#	net/dsa/slave.c
diff --cc drivers/net/ethernet/adi/bfin_mac.c
index dada66bfe0d6,ed5c78cb7239..000000000000
--- a/drivers/net/ethernet/adi/bfin_mac.c
+++ b/drivers/net/ethernet/adi/bfin_mac.c
@@@ -449,10 -444,8 +449,15 @@@ static int mii_probe(struct net_device 
  	lp->old_duplex = -1;
  	lp->phydev = phydev;
  
++<<<<<<< HEAD
 +	pr_info("attached PHY driver [%s] "
 +	        "(mii_bus:phy_addr=%s, irq=%d, mdc_clk=%dHz(mdc_div=%d)@sclk=%dMHz)\n",
 +	        phydev->drv->name, dev_name(&phydev->dev), phydev->irq,
 +	        MDC_CLK, mdc_div, sclk/1000000);
++=======
+ 	phy_attached_print(phydev, "mdc_clk=%dHz(mdc_div=%d)@sclk=%dMHz)\n",
+ 			   MDC_CLK, mdc_div, sclk / 1000000);
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  
  	return 0;
  }
diff --cc drivers/net/ethernet/amd/au1000_eth.c
index 3d31deb2deac,114618d357d5..000000000000
--- a/drivers/net/ethernet/amd/au1000_eth.c
+++ b/drivers/net/ethernet/amd/au1000_eth.c
@@@ -462,9 -583,7 +462,13 @@@ static int au1000_mii_probe(struct net_
  	aup->old_duplex = -1;
  	aup->phy_dev = phydev;
  
++<<<<<<< HEAD
 +	netdev_info(dev, "attached PHY driver [%s] "
 +	       "(mii_bus:phy_addr=%s, irq=%d)\n",
 +	       phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
++=======
+ 	phy_attached_info(phydev);
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  
  	return 0;
  }
diff --cc drivers/net/ethernet/broadcom/b44.c
index 468c4c17635e,e7d9308d6760..000000000000
--- a/drivers/net/ethernet/broadcom/b44.c
+++ b/drivers/net/ethernet/broadcom/b44.c
@@@ -2135,6 -2203,145 +2135,148 @@@ static const struct net_device_ops b44_
  #endif
  };
  
++<<<<<<< HEAD
++=======
+ static void b44_adjust_link(struct net_device *dev)
+ {
+ 	struct b44 *bp = netdev_priv(dev);
+ 	struct phy_device *phydev = bp->phydev;
+ 	bool status_changed = 0;
+ 
+ 	BUG_ON(!phydev);
+ 
+ 	if (bp->old_link != phydev->link) {
+ 		status_changed = 1;
+ 		bp->old_link = phydev->link;
+ 	}
+ 
+ 	/* reflect duplex change */
+ 	if (phydev->link) {
+ 		if ((phydev->duplex == DUPLEX_HALF) &&
+ 		    (bp->flags & B44_FLAG_FULL_DUPLEX)) {
+ 			status_changed = 1;
+ 			bp->flags &= ~B44_FLAG_FULL_DUPLEX;
+ 		} else if ((phydev->duplex == DUPLEX_FULL) &&
+ 			   !(bp->flags & B44_FLAG_FULL_DUPLEX)) {
+ 			status_changed = 1;
+ 			bp->flags |= B44_FLAG_FULL_DUPLEX;
+ 		}
+ 	}
+ 
+ 	if (status_changed) {
+ 		u32 val = br32(bp, B44_TX_CTRL);
+ 		if (bp->flags & B44_FLAG_FULL_DUPLEX)
+ 			val |= TX_CTRL_DUPLEX;
+ 		else
+ 			val &= ~TX_CTRL_DUPLEX;
+ 		bw32(bp, B44_TX_CTRL, val);
+ 		phy_print_status(phydev);
+ 	}
+ }
+ 
+ static int b44_register_phy_one(struct b44 *bp)
+ {
+ 	struct mii_bus *mii_bus;
+ 	struct ssb_device *sdev = bp->sdev;
+ 	struct phy_device *phydev;
+ 	char bus_id[MII_BUS_ID_SIZE + 3];
+ 	struct ssb_sprom *sprom = &sdev->bus->sprom;
+ 	int err;
+ 
+ 	mii_bus = mdiobus_alloc();
+ 	if (!mii_bus) {
+ 		dev_err(sdev->dev, "mdiobus_alloc() failed\n");
+ 		err = -ENOMEM;
+ 		goto err_out;
+ 	}
+ 
+ 	mii_bus->priv = bp;
+ 	mii_bus->read = b44_mdio_read_phylib;
+ 	mii_bus->write = b44_mdio_write_phylib;
+ 	mii_bus->name = "b44_eth_mii";
+ 	mii_bus->parent = sdev->dev;
+ 	mii_bus->phy_mask = ~(1 << bp->phy_addr);
+ 	snprintf(mii_bus->id, MII_BUS_ID_SIZE, "%x", instance);
+ 	mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
+ 	if (!mii_bus->irq) {
+ 		dev_err(sdev->dev, "mii_bus irq allocation failed\n");
+ 		err = -ENOMEM;
+ 		goto err_out_mdiobus;
+ 	}
+ 
+ 	memset(mii_bus->irq, PHY_POLL, sizeof(int) * PHY_MAX_ADDR);
+ 
+ 	bp->mii_bus = mii_bus;
+ 
+ 	err = mdiobus_register(mii_bus);
+ 	if (err) {
+ 		dev_err(sdev->dev, "failed to register MII bus\n");
+ 		goto err_out_mdiobus_irq;
+ 	}
+ 
+ 	if (!bp->mii_bus->phy_map[bp->phy_addr] &&
+ 	    (sprom->boardflags_lo & (B44_BOARDFLAG_ROBO | B44_BOARDFLAG_ADM))) {
+ 
+ 		dev_info(sdev->dev,
+ 			 "could not find PHY at %i, use fixed one\n",
+ 			 bp->phy_addr);
+ 
+ 		bp->phy_addr = 0;
+ 		snprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, "fixed-0",
+ 			 bp->phy_addr);
+ 	} else {
+ 		snprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, mii_bus->id,
+ 			 bp->phy_addr);
+ 	}
+ 
+ 	phydev = phy_connect(bp->dev, bus_id, &b44_adjust_link,
+ 			     PHY_INTERFACE_MODE_MII);
+ 	if (IS_ERR(phydev)) {
+ 		dev_err(sdev->dev, "could not attach PHY at %i\n",
+ 			bp->phy_addr);
+ 		err = PTR_ERR(phydev);
+ 		goto err_out_mdiobus_unregister;
+ 	}
+ 
+ 	/* mask with MAC supported features */
+ 	phydev->supported &= (SUPPORTED_100baseT_Half |
+ 			      SUPPORTED_100baseT_Full |
+ 			      SUPPORTED_Autoneg |
+ 			      SUPPORTED_MII);
+ 	phydev->advertising = phydev->supported;
+ 
+ 	bp->phydev = phydev;
+ 	bp->old_link = 0;
+ 	bp->phy_addr = phydev->addr;
+ 
+ 	phy_attached_info(phydev);
+ 
+ 	return 0;
+ 
+ err_out_mdiobus_unregister:
+ 	mdiobus_unregister(mii_bus);
+ 
+ err_out_mdiobus_irq:
+ 	kfree(mii_bus->irq);
+ 
+ err_out_mdiobus:
+ 	mdiobus_free(mii_bus);
+ 
+ err_out:
+ 	return err;
+ }
+ 
+ static void b44_unregister_phy_one(struct b44 *bp)
+ {
+ 	struct mii_bus *mii_bus = bp->mii_bus;
+ 
+ 	phy_disconnect(bp->phydev);
+ 	mdiobus_unregister(mii_bus);
+ 	kfree(mii_bus->irq);
+ 	mdiobus_free(mii_bus);
+ }
+ 
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  static int b44_init_one(struct ssb_device *sdev,
  			const struct ssb_device_id *ent)
  {
diff --cc drivers/net/ethernet/broadcom/tg3.c
index 34c729a025a9,07c067590caa..000000000000
--- a/drivers/net/ethernet/broadcom/tg3.c
+++ b/drivers/net/ethernet/broadcom/tg3.c
@@@ -17961,13 -17900,7 +17963,17 @@@ static int tg3_init_one(struct pci_dev 
  		    tg3_bus_string(tp, str),
  		    dev->dev_addr);
  
++<<<<<<< HEAD
 +	if (tp->phy_flags & TG3_PHYFLG_IS_CONNECTED) {
 +		struct phy_device *phydev;
 +		phydev = tp->mdio_bus->phy_map[tp->phy_addr];
 +		netdev_info(dev,
 +			    "attached PHY driver [%s] (mii_bus:phy_addr=%s)\n",
 +			    phydev->drv->name, dev_name(&phydev->dev));
 +	} else {
++=======
+ 	if (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED)) {
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  		char *ethtype;
  
  		if (tp->phy_flags & TG3_PHYFLG_10_100_ONLY)
diff --cc drivers/net/ethernet/cadence/macb.c
index a07dfe433fae,98df33b7a395..000000000000
--- a/drivers/net/ethernet/cadence/macb.c
+++ b/drivers/net/ethernet/cadence/macb.c
@@@ -1620,17 -2943,14 +1620,21 @@@ static int __init macb_probe(struct pla
  	if (err)
  		goto err_out_unregister_netdev;
  
 +	platform_set_drvdata(pdev, dev);
 +
  	netif_carrier_off(dev);
  
 -	netdev_info(dev, "Cadence %s rev 0x%08x at 0x%08lx irq %d (%pM)\n",
 -		    macb_is_gem(bp) ? "GEM" : "MACB", macb_readl(bp, MID),
 -		    dev->base_addr, dev->irq, dev->dev_addr);
 +	netdev_info(dev, "Cadence %s at 0x%08lx irq %d (%pM)\n",
 +		    macb_is_gem(bp) ? "GEM" : "MACB", dev->base_addr,
 +		    dev->irq, dev->dev_addr);
  
  	phydev = bp->phy_dev;
++<<<<<<< HEAD
 +	netdev_info(dev, "attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
 +		    phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
++=======
+ 	phy_attached_info(phydev);
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  
  	return 0;
  
diff --cc drivers/net/ethernet/dnet.c
index e7b99a0f862c,6557460cf028..000000000000
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@@ -922,9 -886,7 +922,13 @@@ static int dnet_probe(struct platform_d
  	       (bp->capabilities & DNET_HAS_GIGABIT) ? "" : "no ",
  	       (bp->capabilities & DNET_HAS_DMA) ? "" : "no ");
  	phydev = bp->phy_dev;
++<<<<<<< HEAD
 +	dev_info(&pdev->dev, "attached PHY driver [%s] "
 +	       "(mii_bus:phy_addr=%s, irq=%d)\n",
 +	       phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
++=======
+ 	phy_attached_info(phydev);
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  
  	return 0;
  
diff --cc drivers/net/ethernet/lantiq_etop.c
index fb233ce6801f,86238a5eaddf..000000000000
--- a/drivers/net/ethernet/lantiq_etop.c
+++ b/drivers/net/ethernet/lantiq_etop.c
@@@ -411,9 -408,7 +411,13 @@@ ltq_etop_mdio_probe(struct net_device *
  
  	phydev->advertising = phydev->supported;
  	priv->phydev = phydev;
++<<<<<<< HEAD
 +	pr_info("%s: attached PHY [%s] (phy_addr=%s, irq=%d)\n",
 +	       dev->name, phydev->drv->name,
 +	       dev_name(&phydev->dev), phydev->irq);
++=======
+ 	phy_attached_info(phydev);
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  
  	return 0;
  }
diff --cc drivers/net/ethernet/nxp/lpc_eth.c
index 55a5548d6add,024bc3675573..000000000000
--- a/drivers/net/ethernet/nxp/lpc_eth.c
+++ b/drivers/net/ethernet/nxp/lpc_eth.c
@@@ -818,9 -816,8 +818,14 @@@ static int lpc_mii_probe(struct net_dev
  	pldat->duplex = -1;
  	pldat->phy_dev = phydev;
  
++<<<<<<< HEAD
 +	netdev_info(ndev,
 +		"attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
 +		phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
++=======
+ 	phy_attached_info(phydev);
+ 
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  	return 0;
  }
  
diff --cc drivers/net/ethernet/rdc/r6040.c
index cc9d9b19a798,174dea787caf..000000000000
--- a/drivers/net/ethernet/rdc/r6040.c
+++ b/drivers/net/ethernet/rdc/r6040.c
@@@ -1065,9 -1061,7 +1065,13 @@@ static int r6040_mii_probe(struct net_d
  	lp->old_link = 0;
  	lp->old_duplex = -1;
  
++<<<<<<< HEAD
 +	dev_info(&lp->pdev->dev, "attached PHY driver [%s] "
 +		"(mii_bus:phy_addr=%s)\n",
 +		phydev->drv->name, dev_name(&phydev->dev));
++=======
+ 	phy_attached_info(phydev);
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  
  	return 0;
  }
diff --cc drivers/net/ethernet/renesas/sh_eth.c
index 4f5addaf2979,94581be64d65..000000000000
--- a/drivers/net/ethernet/renesas/sh_eth.c
+++ b/drivers/net/ethernet/renesas/sh_eth.c
@@@ -1746,8 -1826,7 +1746,12 @@@ static int sh_eth_phy_init(struct net_d
  		return PTR_ERR(phydev);
  	}
  
++<<<<<<< HEAD
 +	dev_info(&ndev->dev, "attached phy %i to driver %s\n",
 +		phydev->addr, phydev->drv->name);
++=======
+ 	phy_attached_info(phydev);
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  
  	mdp->phydev = phydev;
  
diff --cc drivers/net/ethernet/smsc/smsc911x.c
index 5b897f599a11,139b99b04099..000000000000
--- a/drivers/net/ethernet/smsc/smsc911x.c
+++ b/drivers/net/ethernet/smsc/smsc911x.c
@@@ -1032,9 -1031,7 +1032,13 @@@ static int smsc911x_mii_probe(struct ne
  		return ret;
  	}
  
++<<<<<<< HEAD
 +	netdev_info(dev,
 +		    "attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
 +		    phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
++=======
+ 	phy_attached_info(phydev);
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  
  	/* mask with MAC supported features */
  	phydev->supported &= (PHY_BASIC_FEATURES | SUPPORTED_Pause |
diff --cc drivers/net/ethernet/smsc/smsc9420.c
index 64fda33cebb1,fa8893a804f7..000000000000
--- a/drivers/net/ethernet/smsc/smsc9420.c
+++ b/drivers/net/ethernet/smsc/smsc9420.c
@@@ -1172,11 -1163,7 +1172,15 @@@ static int smsc9420_mii_probe(struct ne
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	phydev = pd->mii_bus->phy_map[1];
 +	smsc_info(PROBE, "PHY addr %d, phy_id 0x%08X", phydev->addr,
 +		phydev->phy_id);
 +
 +	phydev = phy_connect(dev, dev_name(&phydev->dev),
++=======
+ 	phydev = phy_connect(dev, phydev_name(phydev),
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  			     smsc9420_phy_adjust_link, PHY_INTERFACE_MODE_MII);
  
  	if (IS_ERR(phydev)) {
@@@ -1184,9 -1171,6 +1188,12 @@@
  		return PTR_ERR(phydev);
  	}
  
++<<<<<<< HEAD
 +	pr_info("%s: attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
 +		dev->name, phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
 +
++=======
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  	/* mask with MAC supported features */
  	phydev->supported &= (PHY_BASIC_FEATURES | SUPPORTED_Pause |
  			      SUPPORTED_Asym_Pause);
diff --cc drivers/net/ethernet/ti/davinci_emac.c
index fb5c51c665a8,5d9abedd6b75..000000000000
--- a/drivers/net/ethernet/ti/davinci_emac.c
+++ b/drivers/net/ethernet/ti/davinci_emac.c
@@@ -1614,11 -1644,10 +1614,18 @@@ static int emac_dev_open(struct net_dev
  		priv->speed = 0;
  		priv->duplex = ~0;
  
++<<<<<<< HEAD
 +		dev_info(emac_dev, "attached PHY driver [%s] "
 +			"(mii_bus:phy_addr=%s, id=%x)\n",
 +			priv->phydev->drv->name, dev_name(&priv->phydev->dev),
 +			priv->phydev->phy_id);
 +	} else {
++=======
+ 		phy_attached_info(priv->phydev);
+ 	}
+ 
+ 	if (!priv->phydev) {
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  		/* No PHY , fix the link, speed and duplex settings */
  		dev_notice(emac_dev, "no phy, defaulting to 100/full\n");
  		priv->link = 1;
diff --cc drivers/net/ethernet/toshiba/tc35815.c
index c53ca489092f,8fd5e0ba718c..000000000000
--- a/drivers/net/ethernet/toshiba/tc35815.c
+++ b/drivers/net/ethernet/toshiba/tc35815.c
@@@ -639,10 -638,8 +639,15 @@@ static int tc_mii_probe(struct net_devi
  		printk(KERN_ERR "%s: Could not attach to PHY\n", dev->name);
  		return PTR_ERR(phydev);
  	}
++<<<<<<< HEAD
 +	printk(KERN_INFO "%s: attached PHY driver [%s] "
 +		"(mii_bus:phy_addr=%s, id=%x)\n",
 +		dev->name, phydev->drv->name, dev_name(&phydev->dev),
 +		phydev->phy_id);
++=======
+ 
+ 	phy_attached_info(phydev);
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  
  	/* mask with MAC supported features */
  	phydev->supported &= PHY_BASIC_FEATURES;
diff --cc drivers/staging/et131x/et131x.c
index f73e58f5ef8d,825da3af806a..000000000000
--- a/drivers/staging/et131x/et131x.c
+++ b/drivers/staging/et131x/et131x.c
@@@ -3881,22 -3273,23 +3881,26 @@@ static int et131x_mii_probe(struct net_
  		return PTR_ERR(phydev);
  	}
  
 -	phydev->supported &= (SUPPORTED_10baseT_Half |
 -			      SUPPORTED_10baseT_Full |
 -			      SUPPORTED_100baseT_Half |
 -			      SUPPORTED_100baseT_Full |
 -			      SUPPORTED_Autoneg |
 -			      SUPPORTED_MII |
 -			      SUPPORTED_TP);
 +	phydev->supported &= (SUPPORTED_10baseT_Half
 +				| SUPPORTED_10baseT_Full
 +				| SUPPORTED_100baseT_Half
 +				| SUPPORTED_100baseT_Full
 +				| SUPPORTED_Autoneg
 +				| SUPPORTED_MII
 +				| SUPPORTED_TP);
  
  	if (adapter->pdev->device != ET131X_PCI_DEVICE_ID_FAST)
 -		phydev->supported |= SUPPORTED_1000baseT_Half |
 -				     SUPPORTED_1000baseT_Full;
 +		phydev->supported |= SUPPORTED_1000baseT_Full;
  
  	phydev->advertising = phydev->supported;
 -	phydev->autoneg = AUTONEG_ENABLE;
  	adapter->phydev = phydev;
  
++<<<<<<< HEAD:drivers/staging/et131x/et131x.c
 +	dev_info(&adapter->pdev->dev, "attached PHY driver [%s] (mii_bus:phy_addr=%s)\n",
 +		 phydev->drv->name, dev_name(&phydev->dev));
++=======
+ 	phy_attached_info(phydev);
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy):drivers/net/ethernet/agere/et131x.c
  
  	return 0;
  }
diff --cc drivers/staging/netlogic/xlr_net.c
index 6dae9a492cfe,cbc25b7e70a2..000000000000
--- a/drivers/staging/netlogic/xlr_net.c
+++ b/drivers/staging/netlogic/xlr_net.c
@@@ -856,8 -854,7 +856,12 @@@ static int xlr_mii_probe(struct xlr_net
  				| ADVERTISED_MII);
  
  	phydev->advertising = phydev->supported;
++<<<<<<< HEAD
 +	pr_info("attached PHY driver [%s] (mii_bus:phy_addr=%s\n",
 +		phydev->drv->name, dev_name(&phydev->dev));
++=======
+ 	phy_attached_info(phydev);
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  	return 0;
  }
  
diff --cc include/linux/phy.h
index 4477c1bcd079,ecbf6382ba29..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -669,6 -775,22 +670,25 @@@ static inline int phy_read_status(struc
  	return phydev->drv->read_status(phydev);
  }
  
++<<<<<<< HEAD
++=======
+ #define phydev_err(_phydev, format, args...)	\
+ 	dev_err(&_phydev->dev, format, ##args)
+ 
+ #define phydev_dbg(_phydev, format, args...)	\
+ 	dev_dbg(&_phydev->dev, format, ##args)
+ 
+ static inline const char *phydev_name(const struct phy_device *phydev)
+ {
+ 	return dev_name(&phydev->dev);
+ }
+ 
+ void phy_attached_print(struct phy_device *phydev, const char *fmt, ...)
+ 	__printf(2, 3);
+ void phy_attached_info(struct phy_device *phydev);
+ int genphy_config_init(struct phy_device *phydev);
+ int genphy_setup_forced(struct phy_device *phydev);
++>>>>>>> 2220943a21e2 (phy: Centralise print about attached phy)
  int genphy_restart_aneg(struct phy_device *phydev);
  int genphy_config_aneg(struct phy_device *phydev);
  int genphy_aneg_done(struct phy_device *phydev);
* Unmerged path drivers/net/ethernet/renesas/ravb_main.c
* Unmerged path drivers/net/ethernet/synopsys/dwc_eth_qos.c
* Unmerged path net/dsa/slave.c
* Unmerged path drivers/net/ethernet/adi/bfin_mac.c
* Unmerged path drivers/net/ethernet/amd/au1000_eth.c
* Unmerged path drivers/net/ethernet/broadcom/b44.c
diff --git a/drivers/net/ethernet/broadcom/bcm63xx_enet.c b/drivers/net/ethernet/broadcom/bcm63xx_enet.c
index 1f7233bbb0e3..819cee3a202a 100644
--- a/drivers/net/ethernet/broadcom/bcm63xx_enet.c
+++ b/drivers/net/ethernet/broadcom/bcm63xx_enet.c
@@ -822,8 +822,7 @@ static int bcm_enet_open(struct net_device *dev)
 		else
 			phydev->advertising &= ~SUPPORTED_Pause;
 
-		dev_info(kdev, "attached PHY at address %d [%s]\n",
-			 phydev->addr, phydev->drv->name);
+		phy_attached_info(phydev);
 
 		priv->old_link = 0;
 		priv->old_duplex = -1;
diff --git a/drivers/net/ethernet/broadcom/sb1250-mac.c b/drivers/net/ethernet/broadcom/sb1250-mac.c
index 8be89b05a490..1f03935020a7 100644
--- a/drivers/net/ethernet/broadcom/sb1250-mac.c
+++ b/drivers/net/ethernet/broadcom/sb1250-mac.c
@@ -2400,11 +2400,10 @@ static int sbmac_mii_probe(struct net_device *dev)
 			      SUPPORTED_MII |
 			      SUPPORTED_Pause |
 			      SUPPORTED_Asym_Pause;
-	phy_dev->advertising = phy_dev->supported;
 
-	pr_info("%s: attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
-		dev->name, phy_dev->drv->name,
-		dev_name(&phy_dev->dev), phy_dev->irq);
+	phy_attached_info(phydev);
+
+	phy_dev->advertising = phy_dev->supported;
 
 	sc->phy_dev = phy_dev;
 
* Unmerged path drivers/net/ethernet/broadcom/tg3.c
* Unmerged path drivers/net/ethernet/cadence/macb.c
* Unmerged path drivers/net/ethernet/dnet.c
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index 5039c86e13f6..1cd69d63c461 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -1222,9 +1222,7 @@ static int fec_enet_mii_probe(struct net_device *ndev)
 	fep->link = 0;
 	fep->full_duplex = 0;
 
-	netdev_info(ndev, "Freescale FEC PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
-		    fep->phy_dev->drv->name, dev_name(&fep->phy_dev->dev),
-		    fep->phy_dev->irq);
+	phy_attached_info(phy_dev);
 
 	return 0;
 }
* Unmerged path drivers/net/ethernet/lantiq_etop.c
* Unmerged path drivers/net/ethernet/nxp/lpc_eth.c
* Unmerged path drivers/net/ethernet/rdc/r6040.c
* Unmerged path drivers/net/ethernet/renesas/ravb_main.c
* Unmerged path drivers/net/ethernet/renesas/sh_eth.c
* Unmerged path drivers/net/ethernet/smsc/smsc911x.c
* Unmerged path drivers/net/ethernet/smsc/smsc9420.c
* Unmerged path drivers/net/ethernet/synopsys/dwc_eth_qos.c
diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 11a2c779af33..552f511b6486 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -823,8 +823,8 @@ static void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)
 			slave->data->phy_id, slave->slave_num);
 		slave->phy = NULL;
 	} else {
-		dev_info(priv->dev, "phy found : id is : 0x%x\n",
-			 slave->phy->phy_id);
+		phy_attached_info(slave->phy);
+
 		phy_start(slave->phy);
 	}
 }
* Unmerged path drivers/net/ethernet/ti/davinci_emac.c
* Unmerged path drivers/net/ethernet/toshiba/tc35815.c
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index 8dd3432c8c20..0c8c63b8967e 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -569,6 +569,33 @@ int phy_init_hw(struct phy_device *phydev)
 }
 EXPORT_SYMBOL(phy_init_hw);
 
+void phy_attached_info(struct phy_device *phydev)
+{
+	phy_attached_print(phydev, NULL);
+}
+EXPORT_SYMBOL(phy_attached_info);
+
+#define ATTACHED_FMT "attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)"
+void phy_attached_print(struct phy_device *phydev, const char *fmt, ...)
+{
+	if (!fmt) {
+		dev_info(&phydev->dev, ATTACHED_FMT "\n",
+			 phydev->drv->name, phydev_name(phydev),
+			 phydev->irq);
+	} else {
+		va_list ap;
+
+		dev_info(&phydev->dev, ATTACHED_FMT,
+			 phydev->drv->name, phydev_name(phydev),
+			 phydev->irq);
+
+		va_start(ap, fmt);
+		vprintk(fmt, ap);
+		va_end(ap);
+	}
+}
+EXPORT_SYMBOL(phy_attached_print);
+
 /**
  * phy_attach_direct - attach a network device to a given PHY device pointer
  * @dev: network device to attach
* Unmerged path drivers/staging/et131x/et131x.c
* Unmerged path drivers/staging/netlogic/xlr_net.c
* Unmerged path include/linux/phy.h
* Unmerged path net/dsa/slave.c
