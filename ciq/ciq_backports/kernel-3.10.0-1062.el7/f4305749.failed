scsi: mpt3sas: Separate out mpt3sas_wait_for_ioc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] mpt3sas: Separate out mpt3sas_wait_for_ioc (Tomas Henzl) [1642370]
Rebuild_FUZZ: 93.33%
commit-author Suganath Prabu <suganath-prabu.subramani@broadcom.com>
commit f4305749cafa93167f0f80d76c788dc75f65318b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f4305749.failed

No functional changes. This section of code "wait for IOC to be
operational" is used in many places across the driver.  Factor this code
out into a new mpt3sas_wait_for_ioc().

	Signed-off-by: Suganath Prabu <suganath-prabu.subramani@broadcom.com>
	Reviewed-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit f4305749cafa93167f0f80d76c788dc75f65318b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt3sas/mpt3sas_base.c
#	drivers/scsi/mpt3sas/mpt3sas_config.c
#	drivers/scsi/mpt3sas/mpt3sas_ctl.c
#	drivers/scsi/mpt3sas/mpt3sas_transport.c
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.c
index 909e8d966528,3b5f28a8fbcc..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@@ -4377,11 -5249,8 +4412,9 @@@ mpt3sas_base_sas_iounit_control(struct 
  	u8 issue_reset = 0;
  	int rc;
  	void *request;
- 	u16 wait_state_count;
  
 -	dinitprintk(ioc, ioc_info(ioc, "%s\n", __func__));
 +	dinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,
 +	    __func__));
  
  	mutex_lock(&ioc->base_cmds.mutex);
  
@@@ -4392,22 -5260,9 +4425,28 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	wait_state_count = 0;
 +	ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 +		if (wait_state_count++ == 10) {
 +			pr_err(MPT3SAS_FMT
 +			    "%s: failed due to ioc not operational\n",
 +			    ioc->name, __func__);
 +			rc = -EFAULT;
 +			goto out;
 +		}
 +		ssleep(1);
 +		ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +		pr_info(MPT3SAS_FMT
 +			"%s: waiting for operational state(count=%d)\n",
 +			ioc->name, __func__, wait_state_count);
 +	}
++=======
+ 	rc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);
+ 	if (rc)
+ 		goto out;
++>>>>>>> f4305749cafa (scsi: mpt3sas: Separate out mpt3sas_wait_for_ioc)
  
  	smid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);
  	if (!smid) {
@@@ -4477,11 -5331,8 +4516,9 @@@ mpt3sas_base_scsi_enclosure_processor(s
  	u8 issue_reset = 0;
  	int rc;
  	void *request;
- 	u16 wait_state_count;
  
 -	dinitprintk(ioc, ioc_info(ioc, "%s\n", __func__));
 +	dinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,
 +	    __func__));
  
  	mutex_lock(&ioc->base_cmds.mutex);
  
@@@ -4492,23 -5342,9 +4529,29 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	wait_state_count = 0;
 +	ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 +		if (wait_state_count++ == 10) {
 +			pr_err(MPT3SAS_FMT
 +			    "%s: failed due to ioc not operational\n",
 +			    ioc->name, __func__);
 +			rc = -EFAULT;
 +			goto out;
 +		}
 +		ssleep(1);
 +		ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +		pr_info(MPT3SAS_FMT
 +			"%s: waiting for operational state(count=%d)\n",
 +			ioc->name,
 +		    __func__, wait_state_count);
 +	}
++=======
+ 	rc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);
+ 	if (rc)
+ 		goto out;
++>>>>>>> f4305749cafa (scsi: mpt3sas: Separate out mpt3sas_wait_for_ioc)
  
  	smid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);
  	if (!smid) {
diff --cc drivers/scsi/mpt3sas/mpt3sas_config.c
index aac8c5669a47,257b66f6b5d4..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_config.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_config.c
@@@ -361,29 -356,13 +359,36 @@@ _config_request(struct MPT3SAS_ADAPTER 
  			r = -EFAULT;
  			goto free_mem;
  		}
 -		ioc_info(ioc, "%s: attempting retry (%d)\n",
 -			 __func__, retry_count);
 +		pr_info(MPT3SAS_FMT "%s: attempting retry (%d)\n",
 +		    ioc->name, __func__, retry_count);
  	}
++<<<<<<< HEAD
 +	wait_state_count = 0;
 +	ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 +		if (wait_state_count++ == MPT3_CONFIG_PAGE_DEFAULT_TIMEOUT) {
 +			pr_err(MPT3SAS_FMT
 +			    "%s: failed due to ioc not operational\n",
 +			    ioc->name, __func__);
 +			ioc->config_cmds.status = MPT3_CMD_NOT_USED;
 +			r = -EFAULT;
 +			goto free_mem;
 +		}
 +		ssleep(1);
 +		ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +		pr_info(MPT3SAS_FMT
 +			"%s: waiting for operational state(count=%d)\n",
 +			ioc->name, __func__, wait_state_count);
 +	}
 +	if (wait_state_count)
 +		pr_info(MPT3SAS_FMT "%s: ioc is operational\n",
 +		    ioc->name, __func__);
++=======
+ 
+ 	r = mpt3sas_wait_for_ioc(ioc, MPT3_CONFIG_PAGE_DEFAULT_TIMEOUT);
+ 	if (r)
+ 		goto free_mem;
++>>>>>>> f4305749cafa (scsi: mpt3sas: Separate out mpt3sas_wait_for_ioc)
  
  	smid = mpt3sas_base_get_smid(ioc, ioc->config_cb_idx);
  	if (!smid) {
diff --cc drivers/scsi/mpt3sas/mpt3sas_ctl.c
index bdd5dacbbbc9,b2bb47c14d35..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_ctl.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_ctl.c
@@@ -630,11 -639,12 +630,16 @@@ _ctl_do_mpt_command(struct MPT3SAS_ADAP
  {
  	MPI2RequestHeader_t *mpi_request = NULL, *request;
  	MPI2DefaultReply_t *mpi_reply;
++<<<<<<< HEAD
 +	u32 ioc_state;
++=======
+ 	Mpi26NVMeEncapsulatedRequest_t *nvme_encap_request = NULL;
+ 	struct _pcie_device *pcie_device = NULL;
++>>>>>>> f4305749cafa (scsi: mpt3sas: Separate out mpt3sas_wait_for_ioc)
  	u16 smid;
 -	u8 timeout;
 +	unsigned long timeout;
  	u8 issue_reset;
 -	u32 sz, sz_arg;
 +	u32 sz;
  	void *psge;
  	void *data_out = NULL;
  	dma_addr_t data_out_dma = 0;
@@@ -643,8 -653,8 +648,7 @@@
  	dma_addr_t data_in_dma = 0;
  	size_t data_in_sz = 0;
  	long ret;
- 	u16 wait_state_count;
  	u16 device_handle = MPT3SAS_INVALID_DEVICE_HANDLE;
 -	u8 tr_method = MPI26_SCSITASKMGMT_MSGFLAGS_PROTOCOL_LVL_RST_PCIE;
  
  	issue_reset = 0;
  
@@@ -655,26 -664,9 +659,32 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	wait_state_count = 0;
 +	ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 +		if (wait_state_count++ == 10) {
 +			pr_err(MPT3SAS_FMT
 +			    "%s: failed due to ioc not operational\n",
 +			    ioc->name, __func__);
 +			ret = -EFAULT;
 +			goto out;
 +		}
 +		ssleep(1);
 +		ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +		pr_info(MPT3SAS_FMT
 +			"%s: waiting for operational state(count=%d)\n",
 +			ioc->name,
 +		    __func__, wait_state_count);
 +	}
 +	if (wait_state_count)
 +		pr_info(MPT3SAS_FMT "%s: ioc is operational\n",
 +		    ioc->name, __func__);
++=======
+ 	ret = mpt3sas_wait_for_ioc(ioc,	IOC_OPERATIONAL_WAIT_COUNT);
+ 	if (ret)
+ 		goto out;
++>>>>>>> f4305749cafa (scsi: mpt3sas: Separate out mpt3sas_wait_for_ioc)
  
  	mpi_request = kzalloc(ioc->request_sz, GFP_KERNEL);
  	if (!mpi_request) {
diff --cc drivers/scsi/mpt3sas/mpt3sas_transport.c
index 2bfb87b6c163,9685c8700c59..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_transport.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_transport.c
@@@ -307,11 -303,9 +306,10 @@@ _transport_expander_report_manufacture(
  	dma_addr_t data_in_dma;
  	size_t data_in_sz;
  	size_t data_out_sz;
- 	u16 wait_state_count;
  
  	if (ioc->shost_recovery || ioc->pci_error_recovery) {
 -		ioc_info(ioc, "%s: host reset in progress!\n", __func__);
 +		pr_info(MPT3SAS_FMT "%s: host reset in progress!\n",
 +		    __func__, ioc->name);
  		return -EFAULT;
  	}
  
@@@ -325,25 -318,9 +323,31 @@@
  	}
  	ioc->transport_cmds.status = MPT3_CMD_PENDING;
  
++<<<<<<< HEAD
 +	wait_state_count = 0;
 +	ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 +		if (wait_state_count++ == 10) {
 +			pr_err(MPT3SAS_FMT
 +			    "%s: failed due to ioc not operational\n",
 +			    ioc->name, __func__);
 +			rc = -EFAULT;
 +			goto out;
 +		}
 +		ssleep(1);
 +		ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +		pr_info(MPT3SAS_FMT
 +			"%s: waiting for operational state(count=%d)\n",
 +			ioc->name, __func__, wait_state_count);
 +	}
 +	if (wait_state_count)
 +		pr_info(MPT3SAS_FMT "%s: ioc is operational\n",
 +		    ioc->name, __func__);
++=======
+ 	rc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);
+ 	if (rc)
+ 		goto out;
++>>>>>>> f4305749cafa (scsi: mpt3sas: Separate out mpt3sas_wait_for_ioc)
  
  	smid = mpt3sas_base_get_smid(ioc, ioc->transport_cb_idx);
  	if (!smid) {
@@@ -1109,11 -1066,9 +1112,10 @@@ _transport_get_expander_phy_error_log(s
  	void *data_out = NULL;
  	dma_addr_t data_out_dma;
  	u32 sz;
- 	u16 wait_state_count;
  
  	if (ioc->shost_recovery || ioc->pci_error_recovery) {
 -		ioc_info(ioc, "%s: host reset in progress!\n", __func__);
 +		pr_info(MPT3SAS_FMT "%s: host reset in progress!\n",
 +		    __func__, ioc->name);
  		return -EFAULT;
  	}
  
@@@ -1127,25 -1081,9 +1129,31 @@@
  	}
  	ioc->transport_cmds.status = MPT3_CMD_PENDING;
  
++<<<<<<< HEAD
 +	wait_state_count = 0;
 +	ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 +		if (wait_state_count++ == 10) {
 +			pr_err(MPT3SAS_FMT
 +			    "%s: failed due to ioc not operational\n",
 +			    ioc->name, __func__);
 +			rc = -EFAULT;
 +			goto out;
 +		}
 +		ssleep(1);
 +		ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +		pr_info(MPT3SAS_FMT
 +			"%s: waiting for operational state(count=%d)\n",
 +			ioc->name, __func__, wait_state_count);
 +	}
 +	if (wait_state_count)
 +		pr_info(MPT3SAS_FMT "%s: ioc is operational\n",
 +		    ioc->name, __func__);
++=======
+ 	rc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);
+ 	if (rc)
+ 		goto out;
++>>>>>>> f4305749cafa (scsi: mpt3sas: Separate out mpt3sas_wait_for_ioc)
  
  	smid = mpt3sas_base_get_smid(ioc, ioc->transport_cb_idx);
  	if (!smid) {
@@@ -1420,11 -1356,9 +1427,10 @@@ _transport_expander_phy_control(struct 
  	void *data_out = NULL;
  	dma_addr_t data_out_dma;
  	u32 sz;
- 	u16 wait_state_count;
  
  	if (ioc->shost_recovery || ioc->pci_error_recovery) {
 -		ioc_info(ioc, "%s: host reset in progress!\n", __func__);
 +		pr_info(MPT3SAS_FMT "%s: host reset in progress!\n",
 +		    __func__, ioc->name);
  		return -EFAULT;
  	}
  
@@@ -1438,25 -1371,9 +1444,31 @@@
  	}
  	ioc->transport_cmds.status = MPT3_CMD_PENDING;
  
++<<<<<<< HEAD
 +	wait_state_count = 0;
 +	ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 +		if (wait_state_count++ == 10) {
 +			pr_err(MPT3SAS_FMT
 +			    "%s: failed due to ioc not operational\n",
 +			    ioc->name, __func__);
 +			rc = -EFAULT;
 +			goto out;
 +		}
 +		ssleep(1);
 +		ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +		pr_info(MPT3SAS_FMT
 +			"%s: waiting for operational state(count=%d)\n",
 +			ioc->name, __func__, wait_state_count);
 +	}
 +	if (wait_state_count)
 +		pr_info(MPT3SAS_FMT "%s: ioc is operational\n",
 +		    ioc->name, __func__);
++=======
+ 	rc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);
+ 	if (rc)
+ 		goto out;
++>>>>>>> f4305749cafa (scsi: mpt3sas: Separate out mpt3sas_wait_for_ioc)
  
  	smid = mpt3sas_base_get_smid(ioc, ioc->transport_cb_idx);
  	if (!smid) {
@@@ -1887,31 -1833,21 +1899,40 @@@ _transport_smp_handler(struct Scsi_Hos
  	struct MPT3SAS_ADAPTER *ioc = shost_priv(shost);
  	Mpi2SmpPassthroughRequest_t *mpi_request;
  	Mpi2SmpPassthroughReply_t *mpi_reply;
 -	int rc;
 +	int rc, i;
  	u16 smid;
- 	u32 ioc_state;
  	void *psge;
++<<<<<<< HEAD
 +	u8 issue_reset = 0;
 +	dma_addr_t dma_addr_in = 0;
 +	dma_addr_t dma_addr_out = 0;
 +	dma_addr_t pci_dma_in = 0;
 +	dma_addr_t pci_dma_out = 0;
 +	void *pci_addr_in = NULL;
 +	void *pci_addr_out = NULL;
 +	u16 wait_state_count;
 +	struct request *rsp = req->next_rq;
 +	struct bio_vec *bvec = NULL;
 +
 +	if (!rsp) {
 +		pr_err(MPT3SAS_FMT "%s: the smp response space is missing\n",
 +			ioc->name, __func__);
 +		return -EINVAL;
 +	}
++=======
+ 	dma_addr_t dma_addr_in;
+ 	dma_addr_t dma_addr_out;
+ 	void *addr_in = NULL;
+ 	void *addr_out = NULL;
+ 	size_t dma_len_in;
+ 	size_t dma_len_out;
+ 	unsigned int reslen = 0;
++>>>>>>> f4305749cafa (scsi: mpt3sas: Separate out mpt3sas_wait_for_ioc)
  
  	if (ioc->shost_recovery || ioc->pci_error_recovery) {
 -		ioc_info(ioc, "%s: host reset in progress!\n", __func__);
 -		rc = -EFAULT;
 -		goto job_done;
 +		pr_info(MPT3SAS_FMT "%s: host reset in progress!\n",
 +		    __func__, ioc->name);
 +		return -EFAULT;
  	}
  
  	rc = mutex_lock_interruptible(&ioc->transport_cmds.mutex);
@@@ -1926,78 -1862,24 +1947,84 @@@
  	}
  	ioc->transport_cmds.status = MPT3_CMD_PENDING;
  
 -	rc = _transport_map_smp_buffer(&ioc->pdev->dev, &job->request_payload,
 -			&dma_addr_out, &dma_len_out, &addr_out);
 -	if (rc)
 -		goto out;
 -	if (addr_out) {
 -		sg_copy_to_buffer(job->request_payload.sg_list,
 -				job->request_payload.sg_cnt, addr_out,
 -				job->request_payload.payload_len);
 +	/* Check if the request is split across multiple segments */
 +	if (req->bio->bi_vcnt > 1) {
 +		u32 offset = 0;
 +
 +		/* Allocate memory and copy the request */
 +		pci_addr_out = pci_alloc_consistent(ioc->pdev,
 +		    blk_rq_bytes(req), &pci_dma_out);
 +		if (!pci_addr_out) {
 +			pr_info(MPT3SAS_FMT "%s(): PCI Addr out = NULL\n",
 +			    ioc->name, __func__);
 +			rc = -ENOMEM;
 +			goto out;
 +		}
 +
 +		bio_for_each_segment(bvec, req->bio, i) {
 +			memcpy(pci_addr_out + offset,
 +			    page_address(bvec->bv_page) + bvec->bv_offset,
 +			    bvec->bv_len);
 +			offset += bvec->bv_len;
 +		}
 +	} else {
 +		dma_addr_out = pci_map_single(ioc->pdev, bio_data(req->bio),
 +		    blk_rq_bytes(req), PCI_DMA_BIDIRECTIONAL);
 +		if (pci_dma_mapping_error(ioc->pdev, dma_addr_out)) {
 +			pr_info(MPT3SAS_FMT "%s(): DMA Addr out = NULL\n",
 +			    ioc->name, __func__);
 +			rc = -ENOMEM;
 +			goto free_pci;
 +		}
  	}
  
 -	rc = _transport_map_smp_buffer(&ioc->pdev->dev, &job->reply_payload,
 -			&dma_addr_in, &dma_len_in, &addr_in);
 -	if (rc)
 -		goto unmap_out;
 +	/* Check if the response needs to be populated across
 +	 * multiple segments */
 +	if (rsp->bio->bi_vcnt > 1) {
 +		pci_addr_in = pci_alloc_consistent(ioc->pdev, blk_rq_bytes(rsp),
 +		    &pci_dma_in);
 +		if (!pci_addr_in) {
 +			pr_info(MPT3SAS_FMT "%s(): PCI Addr in = NULL\n",
 +			    ioc->name, __func__);
 +			rc = -ENOMEM;
 +			goto unmap;
 +		}
 +	} else {
 +		dma_addr_in =  pci_map_single(ioc->pdev, bio_data(rsp->bio),
 +		    blk_rq_bytes(rsp), PCI_DMA_BIDIRECTIONAL);
 +		if (pci_dma_mapping_error(ioc->pdev, dma_addr_in)) {
 +			pr_info(MPT3SAS_FMT "%s(): DMA Addr in = NULL\n",
 +			    ioc->name, __func__);
 +			rc = -ENOMEM;
 +			goto unmap;
 +		}
 +	}
  
++<<<<<<< HEAD
 +	wait_state_count = 0;
 +	ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +	while (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {
 +		if (wait_state_count++ == 10) {
 +			pr_err(MPT3SAS_FMT
 +			    "%s: failed due to ioc not operational\n",
 +			    ioc->name, __func__);
 +			rc = -EFAULT;
 +			goto unmap;
 +		}
 +		ssleep(1);
 +		ioc_state = mpt3sas_base_get_iocstate(ioc, 1);
 +		pr_info(MPT3SAS_FMT
 +			"%s: waiting for operational state(count=%d)\n",
 +			ioc->name, __func__, wait_state_count);
 +	}
 +	if (wait_state_count)
 +		pr_info(MPT3SAS_FMT "%s: ioc is operational\n",
 +		    ioc->name, __func__);
++=======
+ 	rc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);
+ 	if (rc)
+ 		goto unmap_in;
++>>>>>>> f4305749cafa (scsi: mpt3sas: Separate out mpt3sas_wait_for_ioc)
  
  	smid = mpt3sas_base_get_smid(ioc, ioc->transport_cb_idx);
  	if (!smid) {
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.c
diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.h b/drivers/scsi/mpt3sas/mpt3sas_base.h
index 1cadd2c700a9..d11b6b3a0c1e 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_base.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h
@@ -1417,6 +1417,7 @@ mpt3sas_wait_for_commands_to_complete(struct MPT3SAS_ADAPTER *ioc);
 
 u8 mpt3sas_base_check_cmd_timeout(struct MPT3SAS_ADAPTER *ioc,
 	u8 status, void *mpi_request, int sz);
+int mpt3sas_wait_for_ioc(struct MPT3SAS_ADAPTER *ioc, int wait_count);
 
 /* scsih shared API */
 u8 mpt3sas_scsih_event_callback(struct MPT3SAS_ADAPTER *ioc, u8 msix_index,
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_config.c
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_ctl.c
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_transport.c
