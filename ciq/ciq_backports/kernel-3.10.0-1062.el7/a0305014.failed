usb: core: Copy parameter string correctly and remove superfluous null check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [usb] core: Copy parameter string correctly and remove superfluous null check (Torez Smith) [1657401]
Rebuild_FUZZ: 96.60%
commit-author Kai-Heng Feng <kai.heng.feng@canonical.com>
commit a030501499b032bd218e1d01c07677bab6a0d53f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a0305014.failed

strsep() slices string, so the string gets copied by
param_set_copystring() at the end of quirks_param_set() is not the
original value.
Fix that by calling param_set_copystring() earlier.

The null check for val is unnecessary, the caller of quirks_param_set()
does not pass null string.
Remove the superfluous null check. This is found by Smatch.

Fixes: 027bd6cafd9a ("usb: core: Add "quirks" parameter for usbcore")
	Cc: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Kai-Heng Feng <kai.heng.feng@canonical.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a030501499b032bd218e1d01c07677bab6a0d53f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/core/quirks.c
diff --cc drivers/usb/core/quirks.c
index 54b019e267c5,29e5f32b38df..000000000000
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@@ -11,6 -12,148 +11,151 @@@
  #include <linux/usb/hcd.h>
  #include "usb.h"
  
++<<<<<<< HEAD
++=======
+ struct quirk_entry {
+ 	u16 vid;
+ 	u16 pid;
+ 	u32 flags;
+ };
+ 
+ static DEFINE_MUTEX(quirk_mutex);
+ 
+ static struct quirk_entry *quirk_list;
+ static unsigned int quirk_count;
+ 
+ static char quirks_param[128];
+ 
+ static int quirks_param_set(const char *val, const struct kernel_param *kp)
+ {
+ 	char *p, *field;
+ 	u16 vid, pid;
+ 	u32 flags;
+ 	size_t i;
+ 	int err;
+ 
+ 	err = param_set_copystring(val, kp);
+ 	if (err)
+ 		return err;
+ 
+ 	mutex_lock(&quirk_mutex);
+ 
+ 	if (!*val) {
+ 		quirk_count = 0;
+ 		kfree(quirk_list);
+ 		quirk_list = NULL;
+ 		goto unlock;
+ 	}
+ 
+ 	for (quirk_count = 1, i = 0; val[i]; i++)
+ 		if (val[i] == ',')
+ 			quirk_count++;
+ 
+ 	if (quirk_list) {
+ 		kfree(quirk_list);
+ 		quirk_list = NULL;
+ 	}
+ 
+ 	quirk_list = kcalloc(quirk_count, sizeof(struct quirk_entry),
+ 			     GFP_KERNEL);
+ 	if (!quirk_list) {
+ 		mutex_unlock(&quirk_mutex);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	for (i = 0, p = (char *)val; p && *p;) {
+ 		/* Each entry consists of VID:PID:flags */
+ 		field = strsep(&p, ":");
+ 		if (!field)
+ 			break;
+ 
+ 		if (kstrtou16(field, 16, &vid))
+ 			break;
+ 
+ 		field = strsep(&p, ":");
+ 		if (!field)
+ 			break;
+ 
+ 		if (kstrtou16(field, 16, &pid))
+ 			break;
+ 
+ 		field = strsep(&p, ",");
+ 		if (!field || !*field)
+ 			break;
+ 
+ 		/* Collect the flags */
+ 		for (flags = 0; *field; field++) {
+ 			switch (*field) {
+ 			case 'a':
+ 				flags |= USB_QUIRK_STRING_FETCH_255;
+ 				break;
+ 			case 'b':
+ 				flags |= USB_QUIRK_RESET_RESUME;
+ 				break;
+ 			case 'c':
+ 				flags |= USB_QUIRK_NO_SET_INTF;
+ 				break;
+ 			case 'd':
+ 				flags |= USB_QUIRK_CONFIG_INTF_STRINGS;
+ 				break;
+ 			case 'e':
+ 				flags |= USB_QUIRK_RESET;
+ 				break;
+ 			case 'f':
+ 				flags |= USB_QUIRK_HONOR_BNUMINTERFACES;
+ 				break;
+ 			case 'g':
+ 				flags |= USB_QUIRK_DELAY_INIT;
+ 				break;
+ 			case 'h':
+ 				flags |= USB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL;
+ 				break;
+ 			case 'i':
+ 				flags |= USB_QUIRK_DEVICE_QUALIFIER;
+ 				break;
+ 			case 'j':
+ 				flags |= USB_QUIRK_IGNORE_REMOTE_WAKEUP;
+ 				break;
+ 			case 'k':
+ 				flags |= USB_QUIRK_NO_LPM;
+ 				break;
+ 			case 'l':
+ 				flags |= USB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL;
+ 				break;
+ 			case 'm':
+ 				flags |= USB_QUIRK_DISCONNECT_SUSPEND;
+ 				break;
+ 			/* Ignore unrecognized flag characters */
+ 			}
+ 		}
+ 
+ 		quirk_list[i++] = (struct quirk_entry)
+ 			{ .vid = vid, .pid = pid, .flags = flags };
+ 	}
+ 
+ 	if (i < quirk_count)
+ 		quirk_count = i;
+ 
+ unlock:
+ 	mutex_unlock(&quirk_mutex);
+ 
+ 	return 0;
+ }
+ 
+ static const struct kernel_param_ops quirks_param_ops = {
+ 	.set = quirks_param_set,
+ 	.get = param_get_string,
+ };
+ 
+ static struct kparam_string quirks_param_string = {
+ 	.maxlen = sizeof(quirks_param),
+ 	.string = quirks_param,
+ };
+ 
+ module_param_cb(quirks, &quirks_param_ops, &quirks_param_string, 0644);
+ MODULE_PARM_DESC(quirks, "Add/modify USB quirks by specifying quirks=vendorID:productID:quirks");
+ 
++>>>>>>> a030501499b0 (usb: core: Copy parameter string correctly and remove superfluous null check)
  /* Lists of quirky USB devices, split in device quirks and interface quirks.
   * Device quirks are applied at the very beginning of the enumeration process,
   * right after reading the device descriptor. They can thus only match on device
* Unmerged path drivers/usb/core/quirks.c
