usb: usbtmc: Support Read Status Byte with SRQ per file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [usb] usbtmc: Support Read Status Byte with SRQ per file (Torez Smith) [1657401]
Rebuild_FUZZ: 95.24%
commit-author Guido Kiener <guido@kiener-muenchen.de>
commit 4f3c8d6eddc272b386464524235440a418ed2029
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4f3c8d6e.failed

Add 'struct usbtmc_file_data' for each file handle to cache last
srq_byte (=Status Byte with SRQ) received by usbtmc_interrupt(..)

usbtmc488_ioctl_read_stb returns cached srq_byte when available for
each file handle to avoid race conditions of concurrent applications.

SRQ now sets EPOLLPRI instead of EPOLLIN since EPOLLIN is now reserved
for asynchronous reads

	Tested-by: Dave Penkler <dpenkler@gmail.com>
	Reviewed-by: Steve Bayless <steve_bayless@keysight.com>
	Signed-off-by: Guido Kiener <guido.kiener@rohde-schwarz.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 4f3c8d6eddc272b386464524235440a418ed2029)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/class/usbtmc.c
diff --cc drivers/usb/class/usbtmc.c
index 8cdc399a7357,db58b84d43ee..000000000000
--- a/drivers/usb/class/usbtmc.c
+++ b/drivers/usb/class/usbtmc.c
@@@ -1210,15 -1265,16 +1265,21 @@@ skip_io_on_zombie
  
  static int usbtmc_fasync(int fd, struct file *file, int on)
  {
- 	struct usbtmc_device_data *data = file->private_data;
+ 	struct usbtmc_file_data *file_data = file->private_data;
  
- 	return fasync_helper(fd, file, on, &data->fasync);
+ 	return fasync_helper(fd, file, on, &file_data->data->fasync);
  }
  
 -static __poll_t usbtmc_poll(struct file *file, poll_table *wait)
 +static unsigned int usbtmc_poll(struct file *file, poll_table *wait)
  {
++<<<<<<< HEAD
 +	struct usbtmc_device_data *data = file->private_data;
 +	unsigned int mask;
++=======
+ 	struct usbtmc_file_data *file_data = file->private_data;
+ 	struct usbtmc_device_data *data = file_data->data;
+ 	__poll_t mask;
++>>>>>>> 4f3c8d6eddc2 (usb: usbtmc: Support Read Status Byte with SRQ per file)
  
  	mutex_lock(&data->io_mutex);
  
@@@ -1229,7 -1285,7 +1290,11 @@@
  
  	poll_wait(file, &data->waitq, wait);
  
++<<<<<<< HEAD
 +	mask = (atomic_read(&data->srq_asserted)) ? POLLIN | POLLRDNORM : 0;
++=======
+ 	mask = (atomic_read(&file_data->srq_asserted)) ? EPOLLPRI : 0;
++>>>>>>> 4f3c8d6eddc2 (usb: usbtmc: Support Read Status Byte with SRQ per file)
  
  no_poll:
  	mutex_unlock(&data->io_mutex);
* Unmerged path drivers/usb/class/usbtmc.c
