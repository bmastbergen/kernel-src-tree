Add primitives for manipulating bitfields both in host- and fixed-endian.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [kernel] Add primitives for manipulating bitfields both in host- and fixed-endian (Stanislaw Gruszka) [1487002 1487018]
Rebuild_FUZZ: 99.31%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 00b0c9b82663ac42e5a09f58ce960f81f29d64ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/00b0c9b8.failed

The following primitives are defined in linux/bitfield.h:

* u32 le32_get_bits(__le32 val, u32 field) extracts the contents of the
  bitfield specified by @field in little-endian 32bit object @val and
  converts it to host-endian.

* void le32p_replace_bits(__le32 *p, u32 v, u32 field) replaces
  the contents of the bitfield specified by @field in little-endian
  32bit object pointed to by @p with the value of @v.  New value is
  given in host-endian and stored as little-endian.

* __le32 le32_replace_bits(__le32 old, u32 v, u32 field) is equivalent to
  ({__le32 tmp = old; le32p_replace_bits(&tmp, v, field); tmp;})
  In other words, instead of modifying an object in memory, it takes
  the initial value and returns the modified one.

* __le32 le32_encode_bits(u32 v, u32 field) is equivalent to
  le32_replace_bits(0, v, field).  In other words, it returns a little-endian
  32bit object with the bitfield specified by @field containing the
  value of @v and all bits outside that bitfield being zero.

Such set of helpers is defined for each of little-, big- and host-endian
types; e.g. u64_get_bits(val, field) will return the contents of the bitfield
specified by @field in host-endian 64bit object @val, etc.  Of course, for
host-endian no conversion is involved.

Fields to access are specified as GENMASK() values - an N-bit field
starting at bit #M is encoded as GENMASK(M + N - 1, M).  Note that
bit numbers refer to endianness of the object we are working with -
e.g. GENMASK(11, 0) in __be16 refers to the second byte and the lower
4 bits of the first byte.  In __le16 it would refer to the first byte
and the lower 4 bits of the second byte, etc.

Field specification must be a constant; __builtin_constant_p() doesn't
have to be true for it, but compiler must be able to evaluate it at
build time.  If it cannot or if the value does not encode any bitfield,
the build will fail.

If the value being stored in a bitfield is a constant that does not fit
into that bitfield, a warning will be generated at compile time.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 00b0c9b82663ac42e5a09f58ce960f81f29d64ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bitfield.h
diff --cc include/linux/bitfield.h
index 8b9d6fff002d,cf2588d81148..000000000000
--- a/include/linux/bitfield.h
+++ b/include/linux/bitfield.h
@@@ -15,7 -15,8 +15,12 @@@
  #ifndef _LINUX_BITFIELD_H
  #define _LINUX_BITFIELD_H
  
++<<<<<<< HEAD
 +#include <linux/bug.h>
++=======
+ #include <linux/build_bug.h>
+ #include <asm/byteorder.h>
++>>>>>>> 00b0c9b82663 (Add primitives for manipulating bitfields both in host- and fixed-endian.)
  
  /*
   * Bitfield access macros
* Unmerged path include/linux/bitfield.h
