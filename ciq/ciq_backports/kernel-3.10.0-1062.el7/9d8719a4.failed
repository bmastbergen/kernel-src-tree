autofs: change catatonic setting to a bit flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ian Kent <raven@themaw.net>
commit 9d8719a42e4671cfe27733d82b5a071295ab9975
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9d8719a4.failed

Change the superblock info.  catatonic setting to be part of a flags bit
field.

Link: http://lkml.kernel.org/r/154296973142.9889.17275721668508589639.stgit@pluto-themaw-net
	Signed-off-by: Ian Kent <raven@themaw.net>
	Cc: Al Viro <viro@ZenIV.linux.org.uk>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 9d8719a42e4671cfe27733d82b5a071295ab9975)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/autofs4/root.c
diff --cc fs/autofs4/root.c
index 4975f663a9f2,164ccd3402cf..000000000000
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@@ -513,13 -507,14 +513,19 @@@ static struct dentry *autofs4_lookup(st
  	if (dentry->d_name.len > NAME_MAX)
  		return ERR_PTR(-ENAMETOOLONG);
  
 -	sbi = autofs_sbi(dir->i_sb);
 +	sbi = autofs4_sbi(dir->i_sb);
  
  	pr_debug("pid = %u, pgrp = %u, catatonic = %d, oz_mode = %d\n",
++<<<<<<< HEAD:fs/autofs4/root.c
 +		 current->pid, task_pgrp_nr(current), sbi->catatonic,
 +		 autofs4_oz_mode(sbi));
++=======
+ 		 current->pid, task_pgrp_nr(current),
+ 		 sbi->flags & AUTOFS_SBI_CATATONIC,
+ 		 autofs_oz_mode(sbi));
++>>>>>>> 9d8719a42e46 (autofs: change catatonic setting to a bit flag):fs/autofs/root.c
  
 -	active = autofs_lookup_active(dentry);
 +	active = autofs4_lookup_active(dentry);
  	if (active)
  		return active;
  	else {
@@@ -562,7 -557,14 +568,18 @@@ static int autofs4_dir_symlink(struct i
  
  	pr_debug("%s <- %pd\n", symname, dentry);
  
++<<<<<<< HEAD:fs/autofs4/root.c
 +	if (!autofs4_oz_mode(sbi))
++=======
+ 	if (!autofs_oz_mode(sbi))
+ 		return -EACCES;
+ 
+ 	/* autofs_oz_mode() needs to allow path walks when the
+ 	 * autofs mount is catatonic but the state of an autofs
+ 	 * file system needs to be preserved over restarts.
+ 	 */
+ 	if (sbi->flags & AUTOFS_SBI_CATATONIC)
++>>>>>>> 9d8719a42e46 (autofs: change catatonic setting to a bit flag):fs/autofs/root.c
  		return -EACCES;
  
  	BUG_ON(!ino);
@@@ -610,20 -612,26 +627,32 @@@
   * If a process is blocked on the dentry waiting for the expire to finish,
   * it will invalidate the dentry and try to mount with a new one.
   *
 - * Also see autofs_dir_rmdir()..
 + * Also see autofs4_dir_rmdir()..
   */
 -static int autofs_dir_unlink(struct inode *dir, struct dentry *dentry)
 +static int autofs4_dir_unlink(struct inode *dir, struct dentry *dentry)
  {
 -	struct autofs_sb_info *sbi = autofs_sbi(dir->i_sb);
 -	struct autofs_info *ino = autofs_dentry_ino(dentry);
 +	struct autofs_sb_info *sbi = autofs4_sbi(dir->i_sb);
 +	struct autofs_info *ino = autofs4_dentry_ino(dentry);
  	struct autofs_info *p_ino;
  
++<<<<<<< HEAD:fs/autofs4/root.c
 +	/* This allows root to remove symlinks */
 +	if (!autofs4_oz_mode(sbi) && !capable(CAP_SYS_ADMIN))
 +		return -EPERM;
++=======
+ 	if (!autofs_oz_mode(sbi))
+ 		return -EACCES;
+ 
+ 	/* autofs_oz_mode() needs to allow path walks when the
+ 	 * autofs mount is catatonic but the state of an autofs
+ 	 * file system needs to be preserved over restarts.
+ 	 */
+ 	if (sbi->flags & AUTOFS_SBI_CATATONIC)
+ 		return -EACCES;
++>>>>>>> 9d8719a42e46 (autofs: change catatonic setting to a bit flag):fs/autofs/root.c
  
  	if (atomic_dec_and_test(&ino->count)) {
 -		p_ino = autofs_dentry_ino(dentry->d_parent);
 +		p_ino = autofs4_dentry_ino(dentry->d_parent);
  		if (p_ino && !IS_ROOT(dentry))
  			atomic_dec(&p_ino->count);
  	}
@@@ -700,7 -708,14 +729,18 @@@ static int autofs4_dir_rmdir(struct ino
  
  	pr_debug("dentry %p, removing %pd\n", dentry, dentry);
  
++<<<<<<< HEAD:fs/autofs4/root.c
 +	if (!autofs4_oz_mode(sbi))
++=======
+ 	if (!autofs_oz_mode(sbi))
+ 		return -EACCES;
+ 
+ 	/* autofs_oz_mode() needs to allow path walks when the
+ 	 * autofs mount is catatonic but the state of an autofs
+ 	 * file system needs to be preserved over restarts.
+ 	 */
+ 	if (sbi->flags & AUTOFS_SBI_CATATONIC)
++>>>>>>> 9d8719a42e46 (autofs: change catatonic setting to a bit flag):fs/autofs/root.c
  		return -EACCES;
  
  	spin_lock(&sbi->lookup_lock);
@@@ -738,7 -753,14 +778,18 @@@ static int autofs4_dir_mkdir(struct ino
  	struct autofs_info *p_ino;
  	struct inode *inode;
  
++<<<<<<< HEAD:fs/autofs4/root.c
 +	if (!autofs4_oz_mode(sbi))
++=======
+ 	if (!autofs_oz_mode(sbi))
+ 		return -EACCES;
+ 
+ 	/* autofs_oz_mode() needs to allow path walks when the
+ 	 * autofs mount is catatonic but the state of an autofs
+ 	 * file system needs to be preserved over restarts.
+ 	 */
+ 	if (sbi->flags & AUTOFS_SBI_CATATONIC)
++>>>>>>> 9d8719a42e46 (autofs: change catatonic setting to a bit flag):fs/autofs/root.c
  		return -EACCES;
  
  	pr_debug("dentry %p, creating %pd\n", dentry, dentry);
diff --git a/fs/autofs4/autofs_i.h b/fs/autofs4/autofs_i.h
index 7e44fa72be46..91eec34f219d 100644
--- a/fs/autofs4/autofs_i.h
+++ b/fs/autofs4/autofs_i.h
@@ -98,16 +98,18 @@ struct autofs_wait_queue {
 
 #define AUTOFS_SBI_MAGIC 0x6d4a556d
 
+#define AUTOFS_SBI_CATATONIC	0x0001
+
 struct autofs_sb_info {
 	u32 magic;
 	int pipefd;
 	struct file *pipe;
 	struct pid *oz_pgrp;
-	int catatonic;
 	int version;
 	int sub_version;
 	int min_proto;
 	int max_proto;
+	unsigned int flags;
 	unsigned long exp_timeout;
 	unsigned int type;
 	struct super_block *sb;
@@ -137,7 +139,8 @@ static inline struct autofs_info *autofs4_dentry_ino(struct dentry *dentry)
  */
 static inline int autofs4_oz_mode(struct autofs_sb_info *sbi)
 {
-	return sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;
+	return ((sbi->flags & AUTOFS_SBI_CATATONIC) ||
+		 task_pgrp(current) == sbi->oz_pgrp);
 }
 
 struct inode *autofs4_get_inode(struct super_block *, umode_t);
diff --git a/fs/autofs4/dev-ioctl.c b/fs/autofs4/dev-ioctl.c
index 64cab87d7825..51b38c1da80f 100644
--- a/fs/autofs4/dev-ioctl.c
+++ b/fs/autofs4/dev-ioctl.c
@@ -373,7 +373,7 @@ static int autofs_dev_ioctl_setpipefd(struct file *fp,
 	pipefd = param->setpipefd.pipefd;
 
 	mutex_lock(&sbi->wq_mutex);
-	if (!sbi->catatonic) {
+	if (!(sbi->flags & AUTOFS_SBI_CATATONIC)) {
 		mutex_unlock(&sbi->wq_mutex);
 		return -EBUSY;
 	} else {
@@ -400,7 +400,7 @@ static int autofs_dev_ioctl_setpipefd(struct file *fp,
 		swap(sbi->oz_pgrp, new_pid);
 		sbi->pipefd = pipefd;
 		sbi->pipe = pipe;
-		sbi->catatonic = 0;
+		sbi->flags &= ~AUTOFS_SBI_CATATONIC;
 	}
 out:
 	put_pid(new_pid);
diff --git a/fs/autofs4/inode.c b/fs/autofs4/inode.c
index daa9be09297c..645164f0368d 100644
--- a/fs/autofs4/inode.c
+++ b/fs/autofs4/inode.c
@@ -232,12 +232,12 @@ int autofs4_fill_super(struct super_block *s, void *data, int silent)
 	sbi->magic = AUTOFS_SBI_MAGIC;
 	sbi->pipefd = -1;
 	sbi->pipe = NULL;
-	sbi->catatonic = 1;
 	sbi->exp_timeout = 0;
 	sbi->oz_pgrp = NULL;
 	sbi->sb = s;
 	sbi->version = 0;
 	sbi->sub_version = 0;
+	sbi->flags = AUTOFS_SBI_CATATONIC;
 	set_autofs_type_indirect(&sbi->type);
 	sbi->min_proto = 0;
 	sbi->max_proto = 0;
@@ -323,7 +323,7 @@ int autofs4_fill_super(struct super_block *s, void *data, int silent)
 	if (ret < 0)
 		goto fail_fput;
 	sbi->pipe = pipe;
-	sbi->catatonic = 0;
+	sbi->flags &= ~AUTOFS_SBI_CATATONIC;
 
 	/*
 	 * Success! Install the root dentry now to indicate completion.
* Unmerged path fs/autofs4/root.c
diff --git a/fs/autofs4/waitq.c b/fs/autofs4/waitq.c
index 6d2c44463a84..f319bbec7bec 100644
--- a/fs/autofs4/waitq.c
+++ b/fs/autofs4/waitq.c
@@ -26,14 +26,14 @@ void autofs4_catatonic_mode(struct autofs_sb_info *sbi)
 	struct autofs_wait_queue *wq, *nwq;
 
 	mutex_lock(&sbi->wq_mutex);
-	if (sbi->catatonic) {
+	if (sbi->flags & AUTOFS_SBI_CATATONIC) {
 		mutex_unlock(&sbi->wq_mutex);
 		return;
 	}
 
 	pr_debug("entering catatonic mode\n");
 
-	sbi->catatonic = 1;
+	sbi->flags |= AUTOFS_SBI_CATATONIC;
 	wq = sbi->queues;
 	sbi->queues = NULL;	/* Erase all wait queues */
 	while (wq) {
@@ -256,7 +256,7 @@ static int validate_request(struct autofs_wait_queue **wait,
 	struct autofs_wait_queue *wq;
 	struct autofs_info *ino;
 
-	if (sbi->catatonic)
+	if (sbi->flags & AUTOFS_SBI_CATATONIC)
 		return -ENOENT;
 
 	/* Wait in progress, continue; */
@@ -291,7 +291,7 @@ static int validate_request(struct autofs_wait_queue **wait,
 			if (mutex_lock_interruptible(&sbi->wq_mutex))
 				return -EINTR;
 
-			if (sbi->catatonic)
+			if (sbi->flags & AUTOFS_SBI_CATATONIC)
 				return -ENOENT;
 
 			wq = autofs4_find_wait(sbi, qstr);
@@ -360,7 +360,7 @@ int autofs4_wait(struct autofs_sb_info *sbi,
 	pid_t tgid;
 
 	/* In catatonic mode, we don't wait for nobody */
-	if (sbi->catatonic)
+	if (sbi->flags & AUTOFS_SBI_CATATONIC)
 		return -ENOENT;
 
 	/*
