netfilter: nft_set: introduce nft_{hash, rbtree}_deactivate_one()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 37df5301a3ae903c5b1aa90cae37c6c669dfc386
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/37df5301.failed

This new function allows us to deactivate one single element, this is
required by the set flush command that comes in a follow up patch.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 37df5301a3ae903c5b1aa90cae37c6c669dfc386)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_rbtree.c
#	net/netfilter/nft_set_hash.c
diff --cc net/netfilter/nft_rbtree.c
index 1c30f41cff5b,5580bb64dc0f..000000000000
--- a/net/netfilter/nft_rbtree.c
+++ b/net/netfilter/nft_rbtree.c
@@@ -137,10 -168,20 +137,24 @@@ static void nft_rbtree_activate(const s
  {
  	struct nft_rbtree_elem *rbe = elem->priv;
  
 -	nft_set_elem_change_active(net, set, &rbe->ext);
 +	nft_set_elem_change_active(set, &rbe->ext);
  }
  
++<<<<<<< HEAD:net/netfilter/nft_rbtree.c
 +static void *nft_rbtree_deactivate(const struct nft_set *set,
++=======
+ static bool nft_rbtree_deactivate_one(const struct net *net,
+ 				      const struct nft_set *set, void *priv)
+ {
+ 	struct nft_rbtree_elem *rbe = priv;
+ 
+ 	nft_set_elem_change_active(net, set, &rbe->ext);
+ 	return true;
+ }
+ 
+ static void *nft_rbtree_deactivate(const struct net *net,
+ 				   const struct nft_set *set,
++>>>>>>> 37df5301a3ae (netfilter: nft_set: introduce nft_{hash, rbtree}_deactivate_one()):net/netfilter/nft_set_rbtree.c
  				   const struct nft_set_elem *elem)
  {
  	const struct nft_rbtree *priv = nft_set_priv(set);
@@@ -163,7 -204,16 +177,20 @@@
  				parent = parent->rb_left;
  				continue;
  			}
++<<<<<<< HEAD:net/netfilter/nft_rbtree.c
 +			nft_set_elem_change_active(set, &rbe->ext);
++=======
+ 			if (nft_rbtree_interval_end(rbe) &&
+ 			    !nft_rbtree_interval_end(this)) {
+ 				parent = parent->rb_left;
+ 				continue;
+ 			} else if (!nft_rbtree_interval_end(rbe) &&
+ 				   nft_rbtree_interval_end(this)) {
+ 				parent = parent->rb_right;
+ 				continue;
+ 			}
+ 			nft_rbtree_deactivate_one(net, set, rbe);
++>>>>>>> 37df5301a3ae (netfilter: nft_set: introduce nft_{hash, rbtree}_deactivate_one()):net/netfilter/nft_set_rbtree.c
  			return rbe;
  		}
  	}
* Unmerged path net/netfilter/nft_set_hash.c
* Unmerged path net/netfilter/nft_rbtree.c
* Unmerged path net/netfilter/nft_set_hash.c
