net: added netdevice operation for Tx

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [net] added netdevice operation for Tx (Petr Oros) [1647135]
Rebuild_FUZZ: 92.75%
commit-author Magnus Karlsson <magnus.karlsson@intel.com>
commit e3760c7e50ac6cdf1188fec44938dd7e6e6eef61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e3760c7e.failed

Added ndo_xsk_async_xmit. This ndo "kicks" the netdev to start to pull
userland AF_XDP Tx frames from a NAPI context.

	Signed-off-by: Magnus Karlsson <magnus.karlsson@intel.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit e3760c7e50ac6cdf1188fec44938dd7e6e6eef61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
diff --cc include/linux/netdevice.h
index 63a3866ea81e,03ffeadf8a41..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1439,77 -1360,37 +1439,98 @@@ struct net_device_ops 
  						      bool new_carrier);
  	int			(*ndo_get_phys_port_id)(struct net_device *dev,
  							struct netdev_phys_item_id *ppid);
 -	int			(*ndo_get_phys_port_name)(struct net_device *dev,
 -							  char *name, size_t len);
 -	void			(*ndo_udp_tunnel_add)(struct net_device *dev,
 -						      struct udp_tunnel_info *ti);
 -	void			(*ndo_udp_tunnel_del)(struct net_device *dev,
 -						      struct udp_tunnel_info *ti);
 -	void*			(*ndo_dfwd_add_station)(struct net_device *pdev,
 -							struct net_device *dev);
 -	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
 -							void *priv);
 +	void			(*ndo_add_vxlan_port)(struct  net_device *dev,
 +						      sa_family_t sa_family,
 +						      __be16 port);
 +	void			(*ndo_del_vxlan_port)(struct  net_device *dev,
 +						      sa_family_t sa_family,
 +						      __be16 port);
 +
++<<<<<<< HEAD
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, int	(*ndo_get_iflink)(const struct net_device *dev))
 +	RH_KABI_USE_P(2, netdev_features_t
 +				(*ndo_features_check)(struct sk_buff *skb,
 +						      struct net_device *dev,
 +						      netdev_features_t features))
 +	RH_KABI_USE_P(3, int	(*ndo_set_vf_rate)(struct net_device *dev,
 +						   int vf, int min_tx_rate,
 +						   int max_tx_rate))
 +	RH_KABI_USE_P(4, int	(*ndo_get_vf_stats)(struct net_device *dev,
 +						    int vf,
 +						    struct ifla_vf_stats
 +						    *vf_stats))
 +	RH_KABI_USE_P(5, int    (*ndo_set_vf_rss_query_en)(struct net_device *dev,
 +							   int vf, bool setting))
  
 +	RH_KABI_USE_P(6, int	(*ndo_fdb_add)(struct ndmsg *ndm,
 +					       struct nlattr *tb[],
 +					       struct net_device *dev,
 +					       const unsigned char *addr,
 +					       u16 vid,
 +					       u16 flags))
 +	RH_KABI_USE_P(7,int	(*ndo_setup_tc_rh74)(struct net_device *dev,
 +						     u32 handle,
 +						     __be16 protocol,
 +						     struct tc_to_netdev_rh74 *tc))
 +	RH_KABI_USE_P(8, int	(*ndo_fill_metadata_dst)(struct net_device *dev,
 +						       struct sk_buff *skb))
 +	RH_KABI_USE_P(9, void	(*ndo_add_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_USE_P(10, void	(*ndo_del_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_USE_P(16, size_t ndo_size)
 +	/* RHEL: put all new non-performance critical ndo's into
 +	 * net_device_ops_extended. The reserved slots above can be used
 +	 * only for performance critical operations.
 +	 * Drivers may access the extended fields directly from
 +	 * net_device_ops, if they allocated the net_device_ops structure
 +	 * themselves (usually statically). The kernel core and drivers
 +	 * using others' net_device_ops must access the extended fields
 +	 * using the get_ndo_ext macro.
 +	 */
 +	RH_KABI_EXTEND(struct net_device_ops_extended extended)
++=======
+ 	int			(*ndo_get_lock_subclass)(struct net_device *dev);
+ 	int			(*ndo_set_tx_maxrate)(struct net_device *dev,
+ 						      int queue_index,
+ 						      u32 maxrate);
+ 	int			(*ndo_get_iflink)(const struct net_device *dev);
+ 	int			(*ndo_change_proto_down)(struct net_device *dev,
+ 							 bool proto_down);
+ 	int			(*ndo_fill_metadata_dst)(struct net_device *dev,
+ 						       struct sk_buff *skb);
+ 	void			(*ndo_set_rx_headroom)(struct net_device *dev,
+ 						       int needed_headroom);
+ 	int			(*ndo_bpf)(struct net_device *dev,
+ 					   struct netdev_bpf *bpf);
+ 	int			(*ndo_xdp_xmit)(struct net_device *dev, int n,
+ 						struct xdp_frame **xdp,
+ 						u32 flags);
+ 	int			(*ndo_xsk_async_xmit)(struct net_device *dev,
+ 						      u32 queue_id);
++>>>>>>> e3760c7e50ac (net: added netdevice operation for Tx)
  };
  
 +#define get_ndo_ext(ops, field)		({				\
 +	const struct net_device_ops *__ops = (ops);			\
 +	size_t __off = offsetof(struct net_device_ops, extended.field);	\
 +	__ops->ndo_size > __off ? __ops->extended.field : NULL;		\
 +	})
 +
  /**
   * enum net_device_priv_flags - &struct net_device priv_flags
   *
* Unmerged path include/linux/netdevice.h
