tcp: fastopen: avoid negative sk_forward_alloc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 76061f631c2ea4ab9c4d66f3a96ecc5737f5aaf7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/76061f63.failed

When DATA and/or FIN are carried in a SYN/ACK message or SYN message,
we append an skb in socket receive queue, but we forget to call
sk_forced_mem_schedule().

Effect is that the socket has a negative sk->sk_forward_alloc as long as
the message is not read by the application.

Josh Hunt fixed a similar issue in commit d22e15371811 ("tcp: fix tcp
fin memory accounting")

Fixes: 168a8f58059a ("tcp: TCP Fast Open Server - main code path")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reviewed-by: Josh Hunt <johunt@akamai.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 76061f631c2ea4ab9c4d66f3a96ecc5737f5aaf7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_fastopen.c
diff --cc net/ipv4/tcp_fastopen.c
index 39316c1633b4,4e777a3243f9..000000000000
--- a/net/ipv4/tcp_fastopen.c
+++ b/net/ipv4/tcp_fastopen.c
@@@ -126,14 -125,59 +126,60 @@@ static bool tcp_fastopen_cookie_gen(str
  	return false;
  }
  
 -
 -/* If an incoming SYN or SYNACK frame contains a payload and/or FIN,
 - * queue this additional data / FIN.
 - */
 -void tcp_fastopen_add_skb(struct sock *sk, struct sk_buff *skb)
 +static bool tcp_fastopen_create_child(struct sock *sk,
 +				      struct sk_buff *skb,
 +				      struct dst_entry *dst,
 +				      struct request_sock *req)
  {
  	struct tcp_sock *tp = tcp_sk(sk);
++<<<<<<< HEAD
++=======
+ 
+ 	if (TCP_SKB_CB(skb)->end_seq == tp->rcv_nxt)
+ 		return;
+ 
+ 	skb = skb_clone(skb, GFP_ATOMIC);
+ 	if (!skb)
+ 		return;
+ 
+ 	skb_dst_drop(skb);
+ 	/* segs_in has been initialized to 1 in tcp_create_openreq_child().
+ 	 * Hence, reset segs_in to 0 before calling tcp_segs_in()
+ 	 * to avoid double counting.  Also, tcp_segs_in() expects
+ 	 * skb->len to include the tcp_hdrlen.  Hence, it should
+ 	 * be called before __skb_pull().
+ 	 */
+ 	tp->segs_in = 0;
+ 	tcp_segs_in(tp, skb);
+ 	__skb_pull(skb, tcp_hdrlen(skb));
+ 	sk_forced_mem_schedule(sk, skb->truesize);
+ 	skb_set_owner_r(skb, sk);
+ 
+ 	TCP_SKB_CB(skb)->seq++;
+ 	TCP_SKB_CB(skb)->tcp_flags &= ~TCPHDR_SYN;
+ 
+ 	tp->rcv_nxt = TCP_SKB_CB(skb)->end_seq;
+ 	__skb_queue_tail(&sk->sk_receive_queue, skb);
+ 	tp->syn_data_acked = 1;
+ 
+ 	/* u64_stats_update_begin(&tp->syncp) not needed here,
+ 	 * as we certainly are not changing upper 32bit value (0)
+ 	 */
+ 	tp->bytes_received = skb->len;
+ 
+ 	if (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)
+ 		tcp_fin(sk);
+ }
+ 
+ static struct sock *tcp_fastopen_create_child(struct sock *sk,
+ 					      struct sk_buff *skb,
+ 					      struct dst_entry *dst,
+ 					      struct request_sock *req)
+ {
+ 	struct tcp_sock *tp;
++>>>>>>> 76061f631c2e (tcp: fastopen: avoid negative sk_forward_alloc)
  	struct request_sock_queue *queue = &inet_csk(sk)->icsk_accept_queue;
  	struct sock *child;
 -	bool own_req;
  
  	req->num_retrans = 0;
  	req->num_timeout = 0;
* Unmerged path net/ipv4/tcp_fastopen.c
