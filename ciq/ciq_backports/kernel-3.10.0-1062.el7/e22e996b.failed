net/phy: add trace events for mdio accesses

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [trace] phy: add trace events for mdio accesses (Ivan Vecera) [1685646]
Rebuild_FUZZ: 95.12%
commit-author Uwe Kleine-König <uwe@kleine-koenig.org>
commit e22e996b72d47c7bf5bb6b17071b2e9d3db462d4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e22e996b.failed

Make it possible to generate trace events for mdio read and write accesses.

	Signed-off-by: Uwe Kleine-König <uwe@kleine-koenig.org>
	Acked-by: Steven Rostedt <rostedt@goodmis.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e22e996b72d47c7bf5bb6b17071b2e9d3db462d4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/mdio_bus.c
diff --cc drivers/net/phy/mdio_bus.c
index 1dbef80dbf2d,653d076eafe5..000000000000
--- a/drivers/net/phy/mdio_bus.c
+++ b/drivers/net/phy/mdio_bus.c
@@@ -36,10 -33,55 +36,58 @@@
  #include <linux/mii.h>
  #include <linux/ethtool.h>
  #include <linux/phy.h>
 -#include <linux/io.h>
 -#include <linux/uaccess.h>
  
 +#include <asm/io.h>
  #include <asm/irq.h>
++<<<<<<< HEAD
 +#include <asm/uaccess.h>
++=======
+ 
+ #define CREATE_TRACE_POINTS
+ #include <trace/events/mdio.h>
+ 
+ int mdiobus_register_device(struct mdio_device *mdiodev)
+ {
+ 	if (mdiodev->bus->mdio_map[mdiodev->addr])
+ 		return -EBUSY;
+ 
+ 	mdiodev->bus->mdio_map[mdiodev->addr] = mdiodev;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(mdiobus_register_device);
+ 
+ int mdiobus_unregister_device(struct mdio_device *mdiodev)
+ {
+ 	if (mdiodev->bus->mdio_map[mdiodev->addr] != mdiodev)
+ 		return -EINVAL;
+ 
+ 	mdiodev->bus->mdio_map[mdiodev->addr] = NULL;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(mdiobus_unregister_device);
+ 
+ struct phy_device *mdiobus_get_phy(struct mii_bus *bus, int addr)
+ {
+ 	struct mdio_device *mdiodev = bus->mdio_map[addr];
+ 
+ 	if (!mdiodev)
+ 		return NULL;
+ 
+ 	if (!(mdiodev->flags & MDIO_DEVICE_FLAG_PHY))
+ 		return NULL;
+ 
+ 	return container_of(mdiodev, struct phy_device, mdio);
+ }
+ EXPORT_SYMBOL(mdiobus_get_phy);
+ 
+ bool mdiobus_is_registered_device(struct mii_bus *bus, int addr)
+ {
+ 	return bus->mdio_map[addr];
+ }
+ EXPORT_SYMBOL(mdiobus_is_registered_device);
++>>>>>>> e22e996b72d4 (net/phy: add trace events for mdio accesses)
  
  /**
   * mdiobus_alloc_size - allocate a mii_bus structure
* Unmerged path drivers/net/phy/mdio_bus.c
diff --git a/include/trace/events/mdio.h b/include/trace/events/mdio.h
new file mode 100644
index 000000000000..00d85f5f54e4
--- /dev/null
+++ b/include/trace/events/mdio.h
@@ -0,0 +1,42 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM mdio
+
+#if !defined(_TRACE_MDIO_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_MDIO_H
+
+#include <linux/tracepoint.h>
+
+TRACE_EVENT_CONDITION(mdio_access,
+
+	TP_PROTO(struct mii_bus *bus, char read,
+		 u8 addr, unsigned regnum, u16 val, int err),
+
+	TP_ARGS(bus, read, addr, regnum, val, err),
+
+	TP_CONDITION(err >= 0),
+
+	TP_STRUCT__entry(
+		__array(char, busid, MII_BUS_ID_SIZE)
+		__field(char, read)
+		__field(u8, addr)
+		__field(u16, val)
+		__field(unsigned, regnum)
+	),
+
+	TP_fast_assign(
+		strncpy(__entry->busid, bus->id, MII_BUS_ID_SIZE);
+		__entry->read = read;
+		__entry->addr = addr;
+		__entry->regnum = regnum;
+		__entry->val = val;
+	),
+
+	TP_printk("%s %-5s phy:0x%02hhx reg:0x%02x val:0x%04hx",
+		  __entry->busid, __entry->read ? "read" : "write",
+		  __entry->addr, __entry->regnum, __entry->val)
+);
+
+#endif /* if !defined(_TRACE_MDIO_H) || defined(TRACE_HEADER_MULTI_READ) */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
