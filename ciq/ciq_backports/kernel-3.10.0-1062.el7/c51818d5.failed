bpf, xdp, i40e: fix i40e_build_skb skb reserve and truesize

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit c51818d5b793302b0923ade9856574ac28b9333b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c51818d5.failed

Using skb_reserve(skb, I40E_SKB_PAD + (xdp->data - xdp->data_hard_start))
is clearly wrong since I40E_SKB_PAD already points to the offset where
the original xdp->data was sitting since xdp->data_hard_start is defined
as xdp->data - i40e_rx_offset(rx_ring) where latter offsets to I40E_SKB_PAD
when build skb is used.

However, also before cc5b114dcf98 ("bpf, i40e: add meta data support")
this seems broken since bpf_xdp_adjust_head() helper could have been used
to alter headroom and enlarge / shrink the frame and with that the assumption
that the xdp->data remains unchanged does not hold and would push a bogus
packet to upper stack.

ixgbe got this right in 924708081629 ("ixgbe: add XDP support for pass and
drop actions"). In any case, fix it by removing the I40E_SKB_PAD from both
skb_reserve() and truesize calculation.

Fixes: cc5b114dcf98 ("bpf, i40e: add meta data support")
Fixes: 0c8493d90b6b ("i40e: add XDP support for pass and drop actions")
	Reported-by: Keith Busch <keith.busch@linux.intel.com>
	Reported-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Cc: Björn Töpel <bjorn.topel@intel.com>
	Cc: John Fastabend <john.fastabend@gmail.com>
	Tested-by: Keith Busch <keith.busch@linux.intel.com>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
	Acked-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c51818d5b793302b0923ade9856574ac28b9333b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_txrx.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 4edb18c5a04c,ed6dbcfd4e96..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@@ -2094,7 -2103,8 +2094,12 @@@ static struct sk_buff *i40e_build_skb(s
  	unsigned int truesize = i40e_rx_pg_size(rx_ring) / 2;
  #else
  	unsigned int truesize = SKB_DATA_ALIGN(sizeof(struct skb_shared_info)) +
++<<<<<<< HEAD
 +				SKB_DATA_ALIGN(I40E_SKB_PAD + size);
++=======
+ 				SKB_DATA_ALIGN(xdp->data_end -
+ 					       xdp->data_hard_start);
++>>>>>>> c51818d5b793 (bpf, xdp, i40e: fix i40e_build_skb skb reserve and truesize)
  #endif
  	struct sk_buff *skb;
  
@@@ -2109,8 -2123,10 +2114,15 @@@
  		return NULL;
  
  	/* update pointers within the skb to store the data */
++<<<<<<< HEAD
 +	skb_reserve(skb, I40E_SKB_PAD);
 +	__skb_put(skb, size);
++=======
+ 	skb_reserve(skb, xdp->data - xdp->data_hard_start);
+ 	__skb_put(skb, xdp->data_end - xdp->data);
+ 	if (metasize)
+ 		skb_metadata_set(skb, metasize);
++>>>>>>> c51818d5b793 (bpf, xdp, i40e: fix i40e_build_skb skb reserve and truesize)
  
  	/* buffer is used by skb, update page_offset */
  #if (PAGE_SIZE < 8192)
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_txrx.c
