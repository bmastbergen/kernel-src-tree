IB/hfi1: set_intr_bits uses incorrect source for register modification

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Michael J. Ruhl <michael.j.ruhl@intel.com>
commit b53ae6bc7e397930ff20221d1a5976677e0dc85b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b53ae6bc.failed

HFI IRQ enable bits are not being set correctly.  Send context error and
DC IRQs are not being enabled correctly.  In addition, send context error
IRQs are not being delivered.

Because of this, send context errors are not being handled correctly when
they occur.

When setting the IRQ bits, if an IRQ range is used, and the last bit is on
a register boundary (bit 63), the calculated index for the final register
modification is incorrect (index + 1 vs. index).

The incorrect index calculation causes incorrect IRQ bits to be set.  In
this case the send context error IRQ is NOT enabled.

Fix by using the 'last' value rather than the counted 'src' value to
determine the final index to use.  This satisfies all cases.

Fixes: a2f7bbdc2dba ("IB/hfi1: Rework the IRQ API to be more flexible")
	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit b53ae6bc7e397930ff20221d1a5976677e0dc85b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/chip.c
diff --cc drivers/infiniband/hw/hfi1/chip.c
index c45025a8232c,290c3b5b22f3..000000000000
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@@ -12963,57 -12956,65 +12963,63 @@@ int hfi1_tempsense_rd(struct hfi1_devda
  	return ret;
  }
  
 -/* ========================================================================= */
 -
  /**
 - * read_mod_write() - Calculate the IRQ register index and set/clear the bits
 - * @dd: valid devdata
 - * @src: IRQ source to determine register index from
 - * @bits: the bits to set or clear
 - * @set: true == set the bits, false == clear the bits
 + * get_int_mask - get 64 bit int mask
 + * @dd - the devdata
 + * @i - the csr (relative to CCE_INT_MASK)
   *
 + * Returns the mask with the urgent interrupt mask
 + * bit clear for kernel receive contexts.
   */
 -static void read_mod_write(struct hfi1_devdata *dd, u16 src, u64 bits,
 -			   bool set)
 +static u64 get_int_mask(struct hfi1_devdata *dd, u32 i)
  {
 -	u64 reg;
 -	u16 idx = src / BITS_PER_REGISTER;
 +	u64 mask = U64_MAX; /* default to no change */
  
 -	spin_lock(&dd->irq_src_lock);
 -	reg = read_csr(dd, CCE_INT_MASK + (8 * idx));
 -	if (set)
 -		reg |= bits;
 -	else
 -		reg &= ~bits;
 -	write_csr(dd, CCE_INT_MASK + (8 * idx), reg);
 -	spin_unlock(&dd->irq_src_lock);
 +	if (i >= (IS_RCVURGENT_START / 64) && i < (IS_RCVURGENT_END / 64)) {
 +		int j = (i - (IS_RCVURGENT_START / 64)) * 64;
 +		int k = !j ? IS_RCVURGENT_START % 64 : 0;
 +
 +		if (j)
 +			j -= IS_RCVURGENT_START % 64;
 +		/* j = 0..dd->first_dyn_alloc_ctxt - 1,k = 0..63 */
 +		for (; j < dd->first_dyn_alloc_ctxt && k < 64; j++, k++)
 +			/* convert to bit in mask and clear */
 +			mask &= ~BIT_ULL(k);
 +	}
 +	return mask;
  }
  
 -/**
 - * set_intr_bits() - Enable/disable a range (one or more) IRQ sources
 - * @dd: valid devdata
 - * @first: first IRQ source to set/clear
 - * @last: last IRQ source (inclusive) to set/clear
 - * @set: true == set the bits, false == clear the bits
 - *
 - * If first == last, set the exact source.
 +/* ========================================================================= */
 +
 +/*
 + * Enable/disable chip from delivering interrupts.
   */
 -int set_intr_bits(struct hfi1_devdata *dd, u16 first, u16 last, bool set)
 +void set_intr_state(struct hfi1_devdata *dd, u32 enable)
  {
 -	u64 bits = 0;
 -	u64 bit;
 -	u16 src;
 -
 -	if (first > NUM_INTERRUPT_SOURCES || last > NUM_INTERRUPT_SOURCES)
 -		return -EINVAL;
 +	int i;
  
 -	if (last < first)
 -		return -ERANGE;
 +	/*
 +	 * In HFI, the mask needs to be 1 to allow interrupts.
 +	 */
 +	if (enable) {
 +		/* enable all interrupts but urgent on kernel contexts */
 +		for (i = 0; i < CCE_NUM_INT_CSRS; i++) {
 +			u64 mask = get_int_mask(dd, i);
  
 -	for (src = first; src <= last; src++) {
 -		bit = src % BITS_PER_REGISTER;
 -		/* wrapped to next register? */
 -		if (!bit && bits) {
 -			read_mod_write(dd, src - 1, bits, set);
 -			bits = 0;
 +			write_csr(dd, CCE_INT_MASK + (8 * i), mask);
  		}
++<<<<<<< HEAD
++=======
+ 		bits |= BIT_ULL(bit);
+ 	}
+ 	read_mod_write(dd, last, bits, set);
++>>>>>>> b53ae6bc7e39 (IB/hfi1: set_intr_bits uses incorrect source for register modification)
  
 -	return 0;
 +		init_qsfp_int(dd);
 +	} else {
 +		for (i = 0; i < CCE_NUM_INT_CSRS; i++)
 +			write_csr(dd, CCE_INT_MASK + (8 * i), 0ull);
 +	}
  }
  
  /*
* Unmerged path drivers/infiniband/hw/hfi1/chip.c
