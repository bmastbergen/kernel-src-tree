ovl: factor out ovl_free_fs() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit a9075cdb467dd3b01b57f8786e6ea1eca05a76b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a9075cdb.failed

This can be called both from ovl_put_super() and in the error cleanup path
from ovl_fill_super().

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit a9075cdb467dd3b01b57f8786e6ea1eca05a76b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index 19e9eb0f1d4f,5a5b41c542fb..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -228,18 -215,20 +227,23 @@@ static void ovl_free_fs(struct ovl_fs *
  	if (ufs->workdir_locked)
  		ovl_inuse_unlock(ufs->workbasedir);
  	dput(ufs->workbasedir);
- 	if (ufs->upper_mnt && ufs->upperdir_locked)
+ 	if (ufs->upperdir_locked)
  		ovl_inuse_unlock(ufs->upper_mnt->mnt_root);
  	mntput(ufs->upper_mnt);
 -	for (i = 0; i < ufs->numlower; i++) {
 -		mntput(ufs->lower_layers[i].mnt);
 -		free_anon_bdev(ufs->lower_layers[i].pseudo_dev);
 -	}
 -	kfree(ufs->lower_layers);
 +	for (i = 0; i < ufs->numlower; i++)
 +		mntput(ufs->lower_mnt[i]);
 +	kfree(ufs->lower_mnt);
  
  	kfree(ufs->config.lowerdir);
  	kfree(ufs->config.upperdir);
  	kfree(ufs->config.workdir);
++<<<<<<< HEAD
 +	kfree(ufs->config.redirect_mode);
 +	put_cred(ufs->creator_cred);
++=======
+ 	if (ufs->creator_cred)
+ 		put_cred(ufs->creator_cred);
++>>>>>>> a9075cdb467d (ovl: factor out ovl_free_fs() helper)
  	kfree(ufs);
  }
  
@@@ -870,121 -834,200 +881,133 @@@ static const struct xattr_handler *ovl_
  	NULL
  };
  
 -static int ovl_get_upperpath(struct ovl_fs *ufs, struct path *upperpath)
 +static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
 +	struct path upperpath = { };
 +	struct path workpath = { };
 +	struct dentry *root_dentry;
- 	struct ovl_entry *oe;
++	struct ovl_entry *oe = NULL;
 +	struct ovl_fs *ufs;
 +	const int *upper_stack_depth;
 +	int *overlay_stack_depth;
 +	struct path *stack = NULL;
 +	char *lowertmp;
 +	char *lower;
 +	unsigned int numlower;
 +	unsigned int stacklen = 0;
 +	unsigned int i;
 +	bool remote = false;
 +	struct cred *cred;
  	int err;
  
 -	err = ovl_mount_dir(ufs->config.upperdir, upperpath);
 -	if (err)
 -		goto out;
 -
 -	/* Upper fs should not be r/o */
 -	if (sb_rdonly(upperpath->mnt->mnt_sb)) {
 -		pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 -		err = -EINVAL;
 -		goto out;
 -	}
 -
 -	err = ovl_check_namelen(upperpath, ufs, ufs->config.upperdir);
 -	if (err)
 +	err = -ENOMEM;
 +	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
 +	if (!ufs)
  		goto out;
  
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(upperpath->dentry)) {
 -		ufs->upperdir_locked = true;
 -	} else if (ufs->config.index) {
 -		pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 -	}
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static int ovl_get_workpath(struct ovl_fs *ufs, struct path *upperpath,
 -			    struct path *workpath)
 -{
 -	int err;
 -
 -	err = ovl_mount_dir(ufs->config.workdir, workpath);
 +	ufs->config.index = ovl_index_def;
 +	err = ovl_parse_opt((char *) data, &ufs->config);
  	if (err)
- 		goto out_free_config;
 -		goto out;
++		goto out_err;
  
  	err = -EINVAL;
 -	if (upperpath->mnt != workpath->mnt) {
 -		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 -		goto out;
 -	}
 -	if (!ovl_workdir_ok(workpath->dentry, upperpath->dentry)) {
 -		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 -		goto out;
 -	}
 -
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(workpath->dentry)) {
 -		ufs->workdir_locked = true;
 -	} else if (ufs->config.index) {
 -		pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 -	}
 -
 -	ufs->workbasedir = dget(workpath->dentry);
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static int ovl_get_upper(struct ovl_fs *ufs, struct path *upperpath)
 -{
 -	struct vfsmount *upper_mnt;
 -
 -	upper_mnt = clone_private_mount(upperpath);
 -	if (IS_ERR(upper_mnt)) {
 -		pr_err("overlayfs: failed to clone upperpath\n");
 -		return PTR_ERR(upper_mnt);
 +	if (!ufs->config.lowerdir) {
 +		if (!silent)
 +			pr_err("overlayfs: missing 'lowerdir'\n");
- 		goto out_free_config;
++		goto out_err;
  	}
  
 -	/* Don't inherit atime flags */
 -	upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
 -	ufs->upper_mnt = upper_mnt;
 -
 -	return 0;
 -}
 -
 -static int ovl_get_workdir(struct super_block *sb, struct ovl_fs *ufs,
 -			   struct path *workpath)
 -{
 -	struct dentry *temp;
 -	int err;
 -
 -	ufs->workdir = ovl_workdir_create(sb, ufs, ufs->workbasedir,
 -					  OVL_WORKDIR_NAME, false);
 -	if (!ufs->workdir)
 -		return 0;
 -
 -	/*
 -	 * Upper should support d_type, else whiteouts are visible.  Given
 -	 * workdir and upper are on same fs, we can do iterate_dir() on
 -	 * workdir. This check requires successful creation of workdir in
 -	 * previous step.
 -	 */
 -	err = ovl_check_d_type_supported(workpath);
 -	if (err < 0)
 -		return err;
 -
 -	/*
 -	 * We allowed this configuration and don't want to break users over
 -	 * kernel upgrade. So warn instead of erroring out.
 -	 */
 -	if (!err)
 -		pr_warn("overlayfs: upper fs needs to support d_type.\n");
 -
 -	/* Check if upper/work fs supports O_TMPFILE */
 -	temp = ovl_do_tmpfile(ufs->workdir, S_IFREG | 0);
 -	ufs->tmpfile = !IS_ERR(temp);
 -	if (ufs->tmpfile)
 -		dput(temp);
 -	else
 -		pr_warn("overlayfs: upper fs does not support tmpfile.\n");
 -
 -	/*
 -	 * Check if upper/work fs supports trusted.overlay.* xattr
 -	 */
 -	err = ovl_do_setxattr(ufs->workdir, OVL_XATTR_OPAQUE, "0", 1, 0);
 -	if (err) {
 -		ufs->noxattr = true;
 -		pr_warn("overlayfs: upper fs does not support xattr.\n");
 -	} else {
 -		vfs_removexattr(ufs->workdir, OVL_XATTR_OPAQUE);
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_free_config;
  	}
 +	*overlay_stack_depth = 0;
  
 -	/* Check if upper/work fs supports file handles */
 -	if (ufs->config.index &&
 -	    !ovl_can_decode_fh(ufs->workdir->d_sb)) {
 -		ufs->config.index = false;
 -		pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
 -	}
 +	sb->s_maxbytes = MAX_LFS_FILESIZE;
 +	if (ufs->config.upperdir) {
 +		if (!ufs->config.workdir) {
 +			pr_err("overlayfs: missing 'workdir'\n");
- 			goto out_free_config;
++			goto out_err;
 +		}
  
 -	return 0;
 -}
 +		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 +		if (err)
 +			goto out_free_config;
  
 -static int ovl_get_indexdir(struct super_block *sb, struct ovl_fs *ufs,
 -			    struct ovl_entry *oe,
 -			    struct path *upperpath)
 -{
 -	int err;
 +		/* Upper fs should not be r/o */
 +		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
 +			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 +			err = -EINVAL;
 +			goto out_put_upperpath;
 +		}
  
 -	/* Verify lower root is upper root origin */
 -	err = ovl_verify_origin(upperpath->dentry,
 -				oe->lowerstack[0].layer->mnt,
 -				oe->lowerstack[0].dentry,
 -				false, true);
 -	if (err) {
 -		pr_err("overlayfs: failed to verify upper root origin\n");
 -		goto out;
 -	}
 +		err = ovl_check_namelen(&upperpath, ufs, ufs->config.upperdir);
 +		if (err)
 +			goto out_put_upperpath;
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(upperpath.dentry)) {
 +			ufs->upperdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 +			goto out_put_upperpath;
 +		} else {
 +			pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
  
 -	ufs->indexdir = ovl_workdir_create(sb, ufs, ufs->workbasedir,
 -					   OVL_INDEXDIR_NAME, true);
 -	if (ufs->indexdir) {
 -		/* Verify upper root is index dir origin */
 -		err = ovl_verify_origin(ufs->indexdir, ufs->upper_mnt,
 -					upperpath->dentry, true, true);
 +		err = ovl_mount_dir(ufs->config.workdir, &workpath);
  		if (err)
- 			goto out_unlock_upperdentry;
 -			pr_err("overlayfs: failed to verify index dir origin\n");
++			goto out_err;
  
 -		/* Cleanup bad/stale/orphan index entries */
 -		if (!err)
 -			err = ovl_indexdir_cleanup(ufs->indexdir,
 -						   ufs->upper_mnt,
 -						   oe->lowerstack,
 -						   oe->numlower);
 -	}
 -	if (err || !ufs->indexdir)
 -		pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
++<<<<<<< HEAD
 +		err = -EINVAL;
 +		if (upperpath.mnt != workpath.mnt) {
 +			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +			goto out_put_workpath;
 +		}
 +		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +			goto out_put_workpath;
 +		}
++=======
++		err = ovl_get_workpath(ufs, &upperpath, &workpath);
++		if (err)
++			goto out_err;
++>>>>>>> a9075cdb467d (ovl: factor out ovl_free_fs() helper)
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(workpath.dentry)) {
 +			ufs->workdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 +			goto out_put_workpath;
 +		} else {
 +			pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
  
 -out:
 -	return err;
 -}
 +		ufs->workbasedir = workpath.dentry;
 +		upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +		err = -EOPNOTSUPP;
 +		if (!upper_stack_depth) {
 +			pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +			goto out_put_workpath;
 +		}
  
 -static int ovl_get_lowerstack(struct super_block *sb, struct ovl_fs *ufs,
 -			      struct path **stackp, unsigned int *stacklenp)
 -{
 -	int err;
 -	char *lowertmp, *lower;
 -	struct path *stack;
 -	unsigned int stacklen, numlower, i;
 -	bool remote = false;
 +		*overlay_stack_depth = *upper_stack_depth;
 +	}
++<<<<<<< HEAD
  
  	err = -ENOMEM;
  	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
  	if (!lowertmp)
 -		goto out;
 +		goto out_unlock_workdentry;
++=======
++	err = ovl_get_lowerstack(sb, ufs, &stack, &numlower);
++	if (err)
++		goto out_err;
++>>>>>>> a9075cdb467d (ovl: factor out ovl_free_fs() helper)
  
  	err = -EINVAL;
  	stacklen = ovl_split_lowerdirs(lowertmp);
@@@ -1006,10 -1049,10 +1029,11 @@@
  	lower = lowertmp;
  	for (numlower = 0; numlower < stacklen; numlower++) {
  		err = ovl_lower_dir(lower, &stack[numlower], ufs,
 -				    &sb->s_stack_depth, &remote);
 +				    overlay_stack_depth, &remote);
  		if (err)
- 			goto out_put_lowerpath;
 -			goto out_free_stack;
++			goto out_err;
  
++<<<<<<< HEAD
  		lower = strchr(lower, '\0') + 1;
  	}
  
@@@ -1112,6 -1128,79 +1136,18 @@@
  		else if (ufs->same_sb != mnt->mnt_sb)
  			ufs->same_sb = NULL;
  	}
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 -{
 -	struct path upperpath = { };
 -	struct path workpath = { };
 -	struct dentry *root_dentry;
 -	struct ovl_entry *oe = NULL;
 -	struct ovl_fs *ufs;
 -	struct path *stack = NULL;
 -	unsigned int numlower = 0;
 -	unsigned int i;
 -	struct cred *cred;
 -	int err;
 -
 -	err = -ENOMEM;
 -	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
 -	if (!ufs)
 -		goto out;
 -
 -	ufs->config.redirect_dir = ovl_redirect_dir_def;
 -	ufs->config.index = ovl_index_def;
 -	err = ovl_parse_opt((char *) data, &ufs->config);
 -	if (err)
 -		goto out_err;
 -
 -	err = -EINVAL;
 -	if (!ufs->config.lowerdir) {
 -		if (!silent)
 -			pr_err("overlayfs: missing 'lowerdir'\n");
 -		goto out_err;
 -	}
 -
 -	sb->s_stack_depth = 0;
 -	sb->s_maxbytes = MAX_LFS_FILESIZE;
 -	if (ufs->config.upperdir) {
 -		if (!ufs->config.workdir) {
 -			pr_err("overlayfs: missing 'workdir'\n");
 -			goto out_err;
 -		}
 -
 -		err = ovl_get_upperpath(ufs, &upperpath);
 -		if (err)
 -			goto out_err;
 -
 -		err = ovl_get_workpath(ufs, &upperpath, &workpath);
 -		if (err)
 -			goto out_err;
 -
 -		sb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth;
 -	}
 -	err = ovl_get_lowerstack(sb, ufs, &stack, &numlower);
 -	if (err)
 -		goto out_err;
 -
 -	if (ufs->config.upperdir) {
 -		err = ovl_get_upper(ufs, &upperpath);
 -		if (err)
 -			goto out_err;
 -
++=======
+ 		sb->s_time_gran = ufs->upper_mnt->mnt_sb->s_time_gran;
+ 
+ 		err = ovl_get_workdir(sb, ufs, &workpath);
+ 		if (err)
+ 			goto out_err;
+ 	}
+ 
+ 	err = ovl_get_lower_layers(ufs, stack, numlower);
+ 	if (err)
+ 		goto out_err;
++>>>>>>> a9075cdb467d (ovl: factor out ovl_free_fs() helper)
  
  	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
  	if (!ufs->upper_mnt)
@@@ -1119,34 -1208,20 +1155,47 @@@
  	else if (ufs->upper_mnt->mnt_sb != ufs->same_sb)
  		ufs->same_sb = NULL;
  
++<<<<<<< HEAD
++=======
+ 	err = -ENOMEM;
+ 	oe = ovl_alloc_entry(numlower);
+ 	if (!oe)
+ 		goto out_err;
+ 
+ 	for (i = 0; i < numlower; i++) {
+ 		oe->lowerstack[i].dentry = stack[i].dentry;
+ 		oe->lowerstack[i].layer = &(ufs->lower_layers[i]);
+ 	}
+ 
++>>>>>>> a9075cdb467d (ovl: factor out ovl_free_fs() helper)
  	if (!(ovl_force_readonly(ufs)) && ufs->config.index) {
 -		err = ovl_get_indexdir(sb, ufs, oe, &upperpath);
 +		/* Verify lower root is upper root origin */
 +		err = ovl_verify_origin(upperpath.dentry, ufs->lower_mnt[0],
 +					stack[0].dentry, false, true);
 +		if (err) {
 +			pr_err("overlayfs: failed to verify upper root origin\n");
 +			goto out_put_lower_mnt;
 +		}
 +
 +		ufs->indexdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 +						   OVL_INDEXDIR_NAME, true);
 +		if (ufs->indexdir) {
 +			/* Verify upper root is index dir origin */
 +			err = ovl_verify_origin(ufs->indexdir, ufs->upper_mnt,
 +						upperpath.dentry, true, true);
 +			if (err)
 +				pr_err("overlayfs: failed to verify index dir origin\n");
 +
 +			/* Cleanup bad/stale/orphan index entries */
 +			if (!err)
 +				err = ovl_indexdir_cleanup(ufs->indexdir,
 +							   ufs->upper_mnt,
 +							   stack, numlower);
 +		}
 +		if (err || !ufs->indexdir)
 +			pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
  		if (err)
- 			goto out_put_indexdir;
+ 			goto out_err;
  	}
  
  	/* Show index=off/on in /proc/mounts for any of the reasons above */
@@@ -1179,7 -1244,7 +1228,11 @@@
  
  	root_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR, 0));
  	if (!root_dentry)
++<<<<<<< HEAD
 +		goto out_free_oe;
++=======
+ 		goto out_err;
++>>>>>>> a9075cdb467d (ovl: factor out ovl_free_fs() helper)
  
  	mntput(upperpath.mnt);
  	for (i = 0; i < numlower; i++)
@@@ -1209,41 -1269,14 +1262,52 @@@
  
  	return 0;
  
++<<<<<<< HEAD
 +out_free_oe:
 +	kfree(oe);
 +out_put_cred:
 +	put_cred(ufs->creator_cred);
 +out_put_indexdir:
 +	dput(ufs->indexdir);
 +out_put_lower_mnt:
 +	for (i = 0; i < ufs->numlower; i++)
 +		mntput(ufs->lower_mnt[i]);
 +	kfree(ufs->lower_mnt);
 +out_put_workdir:
 +	dput(ufs->workdir);
 +	mntput(ufs->upper_mnt);
 +out_put_lowerpath:
 +	for (i = 0; i < numlower; i++)
 +		path_put(&stack[i]);
 +	kfree(stack);
 +out_free_lowertmp:
 +	kfree(lowertmp);
 +out_unlock_workdentry:
 +	if (ufs->workdir_locked)
 +		ovl_inuse_unlock(workpath.dentry);
 +out_put_workpath:
 +	path_put(&workpath);
 +out_unlock_upperdentry:
 +	if (ufs->upperdir_locked)
 +		ovl_inuse_unlock(upperpath.dentry);
 +out_put_upperpath:
 +	path_put(&upperpath);
 +out_free_config:
 +	kfree(ufs->config.lowerdir);
 +	kfree(ufs->config.upperdir);
 +	kfree(ufs->config.workdir);
 +	kfree(ufs->config.redirect_mode);
 +	kfree(ufs);
++=======
+ out_err:
+ 	kfree(oe);
+ 	for (i = 0; i < numlower; i++)
+ 		path_put(&stack[i]);
+ 	kfree(stack);
+ 	path_put(&workpath);
+ 	path_put(&upperpath);
+ 	ovl_free_fs(ufs);
++>>>>>>> a9075cdb467d (ovl: factor out ovl_free_fs() helper)
  out:
  	return err;
  }
* Unmerged path fs/overlayfs/super.c
