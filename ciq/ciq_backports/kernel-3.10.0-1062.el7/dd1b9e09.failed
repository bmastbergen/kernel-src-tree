net/mlx5: ethtool, Allow legacy link-modes configuration via non-extended ptys

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5: ethtool, Allow legacy link-modes configuration via non-extended ptys (Alaa Hleihel) [1695493]
Rebuild_FUZZ: 97.37%
commit-author Aya Levin <ayal@mellanox.com>
commit dd1b9e09c12b4231148f446c2eefd886ef6e3ddd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/dd1b9e09.failed

Allow configuration of legacy link-modes even when extended link-modes
are supported. This requires reading of legacy advertisement even when
extended link-modes are supported. Since legacy and extended
advertisement are mutually excluded, wait for empty reply from extended
advertisement before reading legacy advertisement.

Fixes: 6a897372417e ("net/mlx5: ethtool, Add ethtool support for 50Gbps per lane link modes")
	Signed-off-by: Aya Levin <ayal@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit dd1b9e09c12b4231148f446c2eefd886ef6e3ddd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/port.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index 889e7668b711,5efce4a3ff79..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -587,14 -604,20 +587,26 @@@ static void ptys2ethtool_supported_link
  }
  
  static void ptys2ethtool_adver_link(unsigned long *advertising_modes,
++<<<<<<< HEAD
 +				    u32 eth_proto_cap)
++=======
+ 				    u32 eth_proto_cap, bool ext)
++>>>>>>> dd1b9e09c12b (net/mlx5: ethtool, Allow legacy link-modes configuration via non-extended ptys)
  {
  	unsigned long proto_cap = eth_proto_cap;
 -	struct ptys2ethtool_config *table;
 -	u32 max_size;
  	int proto;
  
++<<<<<<< HEAD
 +	for_each_set_bit(proto, &proto_cap, MLX5E_LINK_MODES_NUMBER)
++=======
+ 	table = ext ? ptys2ext_ethtool_table : ptys2legacy_ethtool_table;
+ 	max_size = ext ? ARRAY_SIZE(ptys2ext_ethtool_table) :
+ 			 ARRAY_SIZE(ptys2legacy_ethtool_table);
+ 
+ 	for_each_set_bit(proto, &proto_cap, max_size)
++>>>>>>> dd1b9e09c12b (net/mlx5: ethtool, Allow legacy link-modes configuration via non-extended ptys)
  		bitmap_or(advertising_modes, advertising_modes,
 -			  table[proto].advertised,
 +			  ptys2ethtool_table[proto].advertised,
  			  __ETHTOOL_LINK_MODE_MASK_NBITS);
  }
  
@@@ -791,13 -796,13 +803,22 @@@ static void get_supported(u32 eth_proto
  	ethtool_link_ksettings_add_link_mode(link_ksettings, supported, Pause);
  }
  
++<<<<<<< HEAD
 +static void get_advertising(u32 eth_proto_cap, u8 tx_pause,
 +			    u8 rx_pause,
 +			    struct ethtool_link_ksettings *link_ksettings)
 +{
 +	unsigned long *advertising = link_ksettings->link_modes.advertising;
++=======
+ static void get_advertising(u32 eth_proto_cap, u8 tx_pause, u8 rx_pause,
+ 			    struct ethtool_link_ksettings *link_ksettings,
+ 			    bool ext)
+ {
+ 	unsigned long *advertising = link_ksettings->link_modes.advertising;
+ 	ptys2ethtool_adver_link(advertising, eth_proto_cap, ext);
++>>>>>>> dd1b9e09c12b (net/mlx5: ethtool, Allow legacy link-modes configuration via non-extended ptys)
  
 +	ptys2ethtool_adver_link(advertising, eth_proto_cap);
  	if (rx_pause)
  		ethtool_link_ksettings_add_link_mode(link_ksettings, advertising, Pause);
  	if (tx_pause ^ rx_pause)
@@@ -851,14 -856,14 +872,19 @@@ static void get_lp_advertising(u32 eth_
  			       struct ethtool_link_ksettings *link_ksettings)
  {
  	unsigned long *lp_advertising = link_ksettings->link_modes.lp_advertising;
+ 	bool ext = MLX5_CAP_PCAM_FEATURE(mdev, ptys_extended_ethernet);
  
++<<<<<<< HEAD
 +	ptys2ethtool_adver_link(lp_advertising, eth_proto_lp);
++=======
+ 	ptys2ethtool_adver_link(lp_advertising, eth_proto_lp, ext);
++>>>>>>> dd1b9e09c12b (net/mlx5: ethtool, Allow legacy link-modes configuration via non-extended ptys)
  }
  
 -int mlx5e_ethtool_get_link_ksettings(struct mlx5e_priv *priv,
 -				     struct ethtool_link_ksettings *link_ksettings)
 +static int mlx5e_get_link_ksettings(struct net_device *netdev,
 +				    struct ethtool_link_ksettings *link_ksettings)
  {
 +	struct mlx5e_priv *priv    = netdev_priv(netdev);
  	struct mlx5_core_dev *mdev = priv->mdev;
  	u32 out[MLX5_ST_SZ_DW(ptys_reg)] = {0};
  	u32 rx_pause = 0;
@@@ -870,6 -875,8 +896,11 @@@
  	u8 an_disable_admin;
  	u8 an_status;
  	u8 connector_type;
++<<<<<<< HEAD
++=======
+ 	bool admin_ext;
+ 	bool ext;
++>>>>>>> dd1b9e09c12b (net/mlx5: ethtool, Allow legacy link-modes configuration via non-extended ptys)
  	int err;
  
  	err = mlx5_query_port_ptys(mdev, out, sizeof(out), MLX5_PTYS_EN, 1);
@@@ -878,23 -885,40 +909,57 @@@
  			   __func__, err);
  		goto err_query_regs;
  	}
++<<<<<<< HEAD
 +
 +	eth_proto_cap    = MLX5_GET(ptys_reg, out, eth_proto_capability);
 +	eth_proto_admin  = MLX5_GET(ptys_reg, out, eth_proto_admin);
 +	eth_proto_oper   = MLX5_GET(ptys_reg, out, eth_proto_oper);
 +	eth_proto_lp     = MLX5_GET(ptys_reg, out, eth_proto_lp_advertise);
 +	an_disable_admin = MLX5_GET(ptys_reg, out, an_disable_admin);
 +	an_status        = MLX5_GET(ptys_reg, out, an_status);
 +	connector_type   = MLX5_GET(ptys_reg, out, connector_type);
++=======
+ 	ext = MLX5_CAP_PCAM_FEATURE(mdev, ptys_extended_ethernet);
+ 	eth_proto_cap    = MLX5_GET_ETH_PROTO(ptys_reg, out, ext,
+ 					      eth_proto_capability);
+ 	eth_proto_admin  = MLX5_GET_ETH_PROTO(ptys_reg, out, ext,
+ 					      eth_proto_admin);
+ 	/* Fields: eth_proto_admin and ext_eth_proto_admin  are
+ 	 * mutually exclusive. Hence try reading legacy advertising
+ 	 * when extended advertising is zero.
+ 	 * admin_ext indicates how eth_proto_admin should be
+ 	 * interpreted
+ 	 */
+ 	admin_ext = ext;
+ 	if (ext && !eth_proto_admin) {
+ 		eth_proto_admin  = MLX5_GET_ETH_PROTO(ptys_reg, out, false,
+ 						      eth_proto_admin);
+ 		admin_ext = false;
+ 	}
+ 
+ 	eth_proto_oper   = MLX5_GET_ETH_PROTO(ptys_reg, out, ext,
+ 					      eth_proto_oper);
+ 	eth_proto_lp	    = MLX5_GET(ptys_reg, out, eth_proto_lp_advertise);
+ 	an_disable_admin    = MLX5_GET(ptys_reg, out, an_disable_admin);
+ 	an_status	    = MLX5_GET(ptys_reg, out, an_status);
+ 	connector_type	    = MLX5_GET(ptys_reg, out, connector_type);
++>>>>>>> dd1b9e09c12b (net/mlx5: ethtool, Allow legacy link-modes configuration via non-extended ptys)
  
  	mlx5_query_port_pause(mdev, &rx_pause, &tx_pause);
  
  	ethtool_link_ksettings_zero_link_mode(link_ksettings, supported);
  	ethtool_link_ksettings_zero_link_mode(link_ksettings, advertising);
  
++<<<<<<< HEAD
 +	get_supported(eth_proto_cap, link_ksettings);
 +	get_advertising(eth_proto_admin, tx_pause, rx_pause, link_ksettings);
 +	get_speed_duplex(netdev, eth_proto_oper, link_ksettings);
++=======
+ 	get_supported(mdev, eth_proto_cap, link_ksettings);
+ 	get_advertising(eth_proto_admin, tx_pause, rx_pause, link_ksettings,
+ 			admin_ext);
+ 	get_speed_duplex(priv->netdev, eth_proto_oper, link_ksettings);
++>>>>>>> dd1b9e09c12b (net/mlx5: ethtool, Allow legacy link-modes configuration via non-extended ptys)
  
  	eth_proto_oper = eth_proto_oper ? eth_proto_oper : eth_proto_cap;
  
@@@ -966,15 -1011,23 +1031,33 @@@ static int mlx5e_set_link_ksettings(str
  	u32 speed;
  	int err;
  
++<<<<<<< HEAD
 +	speed = link_ksettings->base.speed;
 +
 +	link_modes = link_ksettings->base.autoneg == AUTONEG_ENABLE ?
 +		mlx5e_ethtool2ptys_adver_link(link_ksettings->link_modes.advertising) :
 +		mlx5e_ethtool2ptys_speed_link(speed);
 +
 +	err = mlx5_query_port_proto_cap(mdev, &eth_proto_cap, MLX5_PTYS_EN);
++=======
+ 	u32 (*ethtool2ptys_adver_func)(const unsigned long *adver);
+ 
+ #define MLX5E_PTYS_EXT ((1ULL << ETHTOOL_LINK_MODE_50000baseKR_Full_BIT) - 1)
+ 
+ 	ext_requested = !!(link_ksettings->link_modes.advertising[0] >
+ 			MLX5E_PTYS_EXT ||
+ 			link_ksettings->link_modes.advertising[1]);
+ 	ext_supported = MLX5_CAP_PCAM_FEATURE(mdev, ptys_extended_ethernet);
+ 	ext_requested &= ext_supported;
+ 
+ 	speed = link_ksettings->base.speed;
+ 	ethtool2ptys_adver_func = ext_requested ?
+ 				  mlx5e_ethtool2ptys_ext_adver_link :
+ 				  mlx5e_ethtool2ptys_adver_link;
+ 	err = mlx5_port_query_eth_proto(mdev, 1, ext_requested, &eproto);
++>>>>>>> dd1b9e09c12b (net/mlx5: ethtool, Allow legacy link-modes configuration via non-extended ptys)
  	if (err) {
 -		netdev_err(priv->netdev, "%s: query port eth proto failed: %d\n",
 +		netdev_err(netdev, "%s: query port eth proto cap failed: %d\n",
  			   __func__, err);
  		goto out;
  	}
@@@ -1001,10 -1050,10 +1084,14 @@@
  	an_changes = ((!an_disable && an_disable_admin) ||
  		      (an_disable && !an_disable_admin));
  
 -	if (!an_changes && link_modes == eproto.admin)
 +	if (!an_changes && link_modes == eth_proto_admin)
  		goto out;
  
++<<<<<<< HEAD
 +	mlx5_set_port_ptys(mdev, an_disable, link_modes, MLX5_PTYS_EN);
++=======
+ 	mlx5_port_set_eth_ptys(mdev, an_disable, link_modes, ext_requested);
++>>>>>>> dd1b9e09c12b (net/mlx5: ethtool, Allow legacy link-modes configuration via non-extended ptys)
  	mlx5_toggle_port_link(mdev);
  
  out:
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/port.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/port.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
