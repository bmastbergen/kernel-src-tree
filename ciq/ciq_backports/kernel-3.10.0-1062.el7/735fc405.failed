xdp: change ndo_xdp_xmit API to support bulking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jesper Dangaard Brouer <brouer@redhat.com>
commit 735fc4054b3a25034445c6713d259da0f96f8131
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/735fc405.failed

This patch change the API for ndo_xdp_xmit to support bulking
xdp_frames.

When kernel is compiled with CONFIG_RETPOLINE, XDP sees a huge slowdown.
Most of the slowdown is caused by DMA API indirect function calls, but
also the net_device->ndo_xdp_xmit() call.

Benchmarked patch with CONFIG_RETPOLINE, using xdp_redirect_map with
single flow/core test (CPU E5-1650 v4 @ 3.60GHz), showed
performance improved:
 for driver ixgbe: 6,042,682 pps -> 6,853,768 pps = +811,086 pps
 for driver i40e : 6,187,169 pps -> 6,724,519 pps = +537,350 pps

With frames avail as a bulk inside the driver ndo_xdp_xmit call,
further optimizations are possible, like bulk DMA-mapping for TX.

Testing without CONFIG_RETPOLINE show the same performance for
physical NIC drivers.

The virtual NIC driver tun sees a huge performance boost, as it can
avoid doing per frame producer locking, but instead amortize the
locking cost over the bulk.

V2: Fix compile errors reported by kbuild test robot <lkp@intel.com>
V4: Isolated ndo, driver changes and callers.

	Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit 735fc4054b3a25034445c6713d259da0f96f8131)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
#	drivers/net/tun.c
#	drivers/net/virtio_net.c
#	include/linux/netdevice.h
#	kernel/bpf/devmap.c
#	net/core/filter.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 3bced659a341,9645619f7729..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -9932,8 -10017,63 +9932,67 @@@ static int ixgbe_xdp(struct net_device 
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int ixgbe_xdp_xmit(struct net_device *dev, int n,
+ 			  struct xdp_frame **frames)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 	struct ixgbe_ring *ring;
+ 	int drops = 0;
+ 	int i;
+ 
+ 	if (unlikely(test_bit(__IXGBE_DOWN, &adapter->state)))
+ 		return -ENETDOWN;
+ 
+ 	/* During program transitions its possible adapter->xdp_prog is assigned
+ 	 * but ring has not been configured yet. In this case simply abort xmit.
+ 	 */
+ 	ring = adapter->xdp_prog ? adapter->xdp_ring[smp_processor_id()] : NULL;
+ 	if (unlikely(!ring))
+ 		return -ENXIO;
+ 
+ 	for (i = 0; i < n; i++) {
+ 		struct xdp_frame *xdpf = frames[i];
+ 		int err;
+ 
+ 		err = ixgbe_xmit_xdp_ring(adapter, xdpf);
+ 		if (err != IXGBE_XDP_TX) {
+ 			xdp_return_frame_rx_napi(xdpf);
+ 			drops++;
+ 		}
+ 	}
+ 
+ 	return n - drops;
+ }
+ 
+ static void ixgbe_xdp_flush(struct net_device *dev)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 	struct ixgbe_ring *ring;
+ 
+ 	/* Its possible the device went down between xdp xmit and flush so
+ 	 * we need to ensure device is still up.
+ 	 */
+ 	if (unlikely(test_bit(__IXGBE_DOWN, &adapter->state)))
+ 		return;
+ 
+ 	ring = adapter->xdp_prog ? adapter->xdp_ring[smp_processor_id()] : NULL;
+ 	if (unlikely(!ring))
+ 		return;
+ 
+ 	/* Force memory writes to complete before letting h/w know there
+ 	 * are new descriptors to fetch.
+ 	 */
+ 	wmb();
+ 	writel(ring->next_to_use, ring->tail);
+ 
+ 	return;
+ }
+ 
++>>>>>>> 735fc4054b3a (xdp: change ndo_xdp_xmit API to support bulking)
  static const struct net_device_ops ixgbe_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
  	.ndo_open		= ixgbe_open,
  	.ndo_stop		= ixgbe_close,
  	.ndo_start_xmit		= ixgbe_xmit_frame,
diff --cc drivers/net/tun.c
index 35cc09f13a24,d3dcfcb1c4b3..000000000000
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@@ -69,10 -70,16 +69,16 @@@
  #include <net/netns/generic.h>
  #include <net/rtnetlink.h>
  #include <net/sock.h>
++<<<<<<< HEAD
++=======
+ #include <net/xdp.h>
+ #include <linux/seq_file.h>
+ #include <linux/uio.h>
++>>>>>>> 735fc4054b3a (xdp: change ndo_xdp_xmit API to support bulking)
  #include <linux/skb_array.h>
 -#include <linux/bpf.h>
 -#include <linux/bpf_trace.h>
 -#include <linux/mutex.h>
 +#include <linux/seq_file.h>
  
 -#include <linux/uaccess.h>
 -#include <linux/proc_fs.h>
 +#include <asm/uaccess.h>
  
  /* Uncomment to enable debugging */
  /* #define TUN_DEBUG 1 */
@@@ -999,6 -1291,79 +1005,82 @@@ static const struct net_device_ops tun_
  	.ndo_get_stats64	= tun_net_get_stats64,
  };
  
++<<<<<<< HEAD
++=======
+ static int tun_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames)
+ {
+ 	struct tun_struct *tun = netdev_priv(dev);
+ 	struct tun_file *tfile;
+ 	u32 numqueues;
+ 	int drops = 0;
+ 	int cnt = n;
+ 	int i;
+ 
+ 	rcu_read_lock();
+ 
+ 	numqueues = READ_ONCE(tun->numqueues);
+ 	if (!numqueues) {
+ 		rcu_read_unlock();
+ 		return -ENXIO; /* Caller will free/return all frames */
+ 	}
+ 
+ 	tfile = rcu_dereference(tun->tfiles[smp_processor_id() %
+ 					    numqueues]);
+ 
+ 	spin_lock(&tfile->tx_ring.producer_lock);
+ 	for (i = 0; i < n; i++) {
+ 		struct xdp_frame *xdp = frames[i];
+ 		/* Encode the XDP flag into lowest bit for consumer to differ
+ 		 * XDP buffer from sk_buff.
+ 		 */
+ 		void *frame = tun_xdp_to_ptr(xdp);
+ 
+ 		if (__ptr_ring_produce(&tfile->tx_ring, frame)) {
+ 			this_cpu_inc(tun->pcpu_stats->tx_dropped);
+ 			xdp_return_frame_rx_napi(xdp);
+ 			drops++;
+ 		}
+ 	}
+ 	spin_unlock(&tfile->tx_ring.producer_lock);
+ 
+ 	rcu_read_unlock();
+ 	return cnt - drops;
+ }
+ 
+ static int tun_xdp_tx(struct net_device *dev, struct xdp_buff *xdp)
+ {
+ 	struct xdp_frame *frame = convert_to_xdp_frame(xdp);
+ 
+ 	if (unlikely(!frame))
+ 		return -EOVERFLOW;
+ 
+ 	return tun_xdp_xmit(dev, 1, &frame);
+ }
+ 
+ static void tun_xdp_flush(struct net_device *dev)
+ {
+ 	struct tun_struct *tun = netdev_priv(dev);
+ 	struct tun_file *tfile;
+ 	u32 numqueues;
+ 
+ 	rcu_read_lock();
+ 
+ 	numqueues = READ_ONCE(tun->numqueues);
+ 	if (!numqueues)
+ 		goto out;
+ 
+ 	tfile = rcu_dereference(tun->tfiles[smp_processor_id() %
+ 					    numqueues]);
+ 	/* Notify and wake up reader process */
+ 	if (tfile->flags & TUN_FASYNC)
+ 		kill_fasync(&tfile->fasync, SIGIO, POLL_IN);
+ 	tfile->socket.sk->sk_data_ready(tfile->socket.sk);
+ 
+ out:
+ 	rcu_read_unlock();
+ }
+ 
++>>>>>>> 735fc4054b3a (xdp: change ndo_xdp_xmit API to support bulking)
  static const struct net_device_ops tap_netdev_ops = {
  	.ndo_uninit		= tun_net_uninit,
  	.ndo_open		= tun_net_open,
diff --cc drivers/net/virtio_net.c
index da63bcba4f5b,39a0783d1cde..000000000000
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@@ -288,14 -407,293 +288,294 @@@ static struct sk_buff *page_to_skb(stru
  	return skb;
  }
  
 -static void virtnet_xdp_flush(struct net_device *dev)
 +static struct sk_buff *receive_small(struct virtnet_info *vi, void *buf, unsigned int len)
  {
++<<<<<<< HEAD
 +	struct sk_buff * skb = buf;
++=======
+ 	struct virtnet_info *vi = netdev_priv(dev);
+ 	struct send_queue *sq;
+ 	unsigned int qp;
+ 
+ 	qp = vi->curr_queue_pairs - vi->xdp_queue_pairs + smp_processor_id();
+ 	sq = &vi->sq[qp];
+ 
+ 	virtqueue_kick(sq->vq);
+ }
+ 
+ static int __virtnet_xdp_xmit_one(struct virtnet_info *vi,
+ 				   struct send_queue *sq,
+ 				   struct xdp_frame *xdpf)
+ {
+ 	struct virtio_net_hdr_mrg_rxbuf *hdr;
+ 	int err;
+ 
+ 	/* virtqueue want to use data area in-front of packet */
+ 	if (unlikely(xdpf->metasize > 0))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (unlikely(xdpf->headroom < vi->hdr_len))
+ 		return -EOVERFLOW;
+ 
+ 	/* Make room for virtqueue hdr (also change xdpf->headroom?) */
+ 	xdpf->data -= vi->hdr_len;
+ 	/* Zero header and leave csum up to XDP layers */
+ 	hdr = xdpf->data;
+ 	memset(hdr, 0, vi->hdr_len);
+ 	xdpf->len   += vi->hdr_len;
+ 
+ 	sg_init_one(sq->sg, xdpf->data, xdpf->len);
+ 
+ 	err = virtqueue_add_outbuf(sq->vq, sq->sg, 1, xdpf, GFP_ATOMIC);
+ 	if (unlikely(err))
+ 		return -ENOSPC; /* Caller handle free/refcnt */
+ 
+ 	return 0;
+ }
+ 
+ static int __virtnet_xdp_tx_xmit(struct virtnet_info *vi,
+ 				   struct xdp_frame *xdpf)
+ {
+ 	struct xdp_frame *xdpf_sent;
+ 	struct send_queue *sq;
+ 	unsigned int len;
+ 	unsigned int qp;
+ 
+ 	qp = vi->curr_queue_pairs - vi->xdp_queue_pairs + smp_processor_id();
+ 	sq = &vi->sq[qp];
+ 
+ 	/* Free up any pending old buffers before queueing new ones. */
+ 	while ((xdpf_sent = virtqueue_get_buf(sq->vq, &len)) != NULL)
+ 		xdp_return_frame(xdpf_sent);
+ 
+ 	return __virtnet_xdp_xmit_one(vi, sq, xdpf);
+ }
+ 
+ static int virtnet_xdp_xmit(struct net_device *dev,
+ 			    int n, struct xdp_frame **frames)
+ {
+ 	struct virtnet_info *vi = netdev_priv(dev);
+ 	struct receive_queue *rq = vi->rq;
+ 	struct xdp_frame *xdpf_sent;
+ 	struct bpf_prog *xdp_prog;
+ 	struct send_queue *sq;
+ 	unsigned int len;
+ 	unsigned int qp;
+ 	int drops = 0;
+ 	int err;
+ 	int i;
+ 
+ 	qp = vi->curr_queue_pairs - vi->xdp_queue_pairs + smp_processor_id();
+ 	sq = &vi->sq[qp];
+ 
+ 	/* Only allow ndo_xdp_xmit if XDP is loaded on dev, as this
+ 	 * indicate XDP resources have been successfully allocated.
+ 	 */
+ 	xdp_prog = rcu_dereference(rq->xdp_prog);
+ 	if (!xdp_prog)
+ 		return -ENXIO;
+ 
+ 	/* Free up any pending old buffers before queueing new ones. */
+ 	while ((xdpf_sent = virtqueue_get_buf(sq->vq, &len)) != NULL)
+ 		xdp_return_frame(xdpf_sent);
+ 
+ 	for (i = 0; i < n; i++) {
+ 		struct xdp_frame *xdpf = frames[i];
+ 
+ 		err = __virtnet_xdp_xmit_one(vi, sq, xdpf);
+ 		if (err) {
+ 			xdp_return_frame_rx_napi(xdpf);
+ 			drops++;
+ 		}
+ 	}
+ 	return n - drops;
+ }
+ 
+ static unsigned int virtnet_get_headroom(struct virtnet_info *vi)
+ {
+ 	return vi->xdp_queue_pairs ? VIRTIO_XDP_HEADROOM : 0;
+ }
+ 
+ /* We copy the packet for XDP in the following cases:
+  *
+  * 1) Packet is scattered across multiple rx buffers.
+  * 2) Headroom space is insufficient.
+  *
+  * This is inefficient but it's a temporary condition that
+  * we hit right after XDP is enabled and until queue is refilled
+  * with large buffers with sufficient headroom - so it should affect
+  * at most queue size packets.
+  * Afterwards, the conditions to enable
+  * XDP should preclude the underlying device from sending packets
+  * across multiple buffers (num_buf > 1), and we make sure buffers
+  * have enough headroom.
+  */
+ static struct page *xdp_linearize_page(struct receive_queue *rq,
+ 				       u16 *num_buf,
+ 				       struct page *p,
+ 				       int offset,
+ 				       int page_off,
+ 				       unsigned int *len)
+ {
+ 	struct page *page = alloc_page(GFP_ATOMIC);
+ 
+ 	if (!page)
+ 		return NULL;
+ 
+ 	memcpy(page_address(page) + page_off, page_address(p) + offset, *len);
+ 	page_off += *len;
+ 
+ 	while (--*num_buf) {
+ 		int tailroom = SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
+ 		unsigned int buflen;
+ 		void *buf;
+ 		int off;
+ 
+ 		buf = virtqueue_get_buf(rq->vq, &buflen);
+ 		if (unlikely(!buf))
+ 			goto err_buf;
+ 
+ 		p = virt_to_head_page(buf);
+ 		off = buf - page_address(p);
+ 
+ 		/* guard against a misconfigured or uncooperative backend that
+ 		 * is sending packet larger than the MTU.
+ 		 */
+ 		if ((page_off + buflen + tailroom) > PAGE_SIZE) {
+ 			put_page(p);
+ 			goto err_buf;
+ 		}
+ 
+ 		memcpy(page_address(page) + page_off,
+ 		       page_address(p) + off, buflen);
+ 		page_off += buflen;
+ 		put_page(p);
+ 	}
+ 
+ 	/* Headroom does not contribute to packet length */
+ 	*len = page_off - VIRTIO_XDP_HEADROOM;
+ 	return page;
+ err_buf:
+ 	__free_pages(page, 0);
+ 	return NULL;
+ }
+ 
+ static struct sk_buff *receive_small(struct net_device *dev,
+ 				     struct virtnet_info *vi,
+ 				     struct receive_queue *rq,
+ 				     void *buf, void *ctx,
+ 				     unsigned int len,
+ 				     bool *xdp_xmit)
+ {
+ 	struct sk_buff *skb;
+ 	struct bpf_prog *xdp_prog;
+ 	unsigned int xdp_headroom = (unsigned long)ctx;
+ 	unsigned int header_offset = VIRTNET_RX_PAD + xdp_headroom;
+ 	unsigned int headroom = vi->hdr_len + header_offset;
+ 	unsigned int buflen = SKB_DATA_ALIGN(GOOD_PACKET_LEN + headroom) +
+ 			      SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
+ 	struct page *page = virt_to_head_page(buf);
+ 	unsigned int delta = 0;
+ 	struct page *xdp_page;
+ 	int err;
++>>>>>>> 735fc4054b3a (xdp: change ndo_xdp_xmit API to support bulking)
  
  	len -= vi->hdr_len;
 +	skb_trim(skb, len);
  
++<<<<<<< HEAD
++=======
+ 	rcu_read_lock();
+ 	xdp_prog = rcu_dereference(rq->xdp_prog);
+ 	if (xdp_prog) {
+ 		struct virtio_net_hdr_mrg_rxbuf *hdr = buf + header_offset;
+ 		struct xdp_frame *xdpf;
+ 		struct xdp_buff xdp;
+ 		void *orig_data;
+ 		u32 act;
+ 
+ 		if (unlikely(hdr->hdr.gso_type))
+ 			goto err_xdp;
+ 
+ 		if (unlikely(xdp_headroom < virtnet_get_headroom(vi))) {
+ 			int offset = buf - page_address(page) + header_offset;
+ 			unsigned int tlen = len + vi->hdr_len;
+ 			u16 num_buf = 1;
+ 
+ 			xdp_headroom = virtnet_get_headroom(vi);
+ 			header_offset = VIRTNET_RX_PAD + xdp_headroom;
+ 			headroom = vi->hdr_len + header_offset;
+ 			buflen = SKB_DATA_ALIGN(GOOD_PACKET_LEN + headroom) +
+ 				 SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
+ 			xdp_page = xdp_linearize_page(rq, &num_buf, page,
+ 						      offset, header_offset,
+ 						      &tlen);
+ 			if (!xdp_page)
+ 				goto err_xdp;
+ 
+ 			buf = page_address(xdp_page);
+ 			put_page(page);
+ 			page = xdp_page;
+ 		}
+ 
+ 		xdp.data_hard_start = buf + VIRTNET_RX_PAD + vi->hdr_len;
+ 		xdp.data = xdp.data_hard_start + xdp_headroom;
+ 		xdp_set_data_meta_invalid(&xdp);
+ 		xdp.data_end = xdp.data + len;
+ 		xdp.rxq = &rq->xdp_rxq;
+ 		orig_data = xdp.data;
+ 		act = bpf_prog_run_xdp(xdp_prog, &xdp);
+ 
+ 		switch (act) {
+ 		case XDP_PASS:
+ 			/* Recalculate length in case bpf program changed it */
+ 			delta = orig_data - xdp.data;
+ 			len = xdp.data_end - xdp.data;
+ 			break;
+ 		case XDP_TX:
+ 			xdpf = convert_to_xdp_frame(&xdp);
+ 			if (unlikely(!xdpf))
+ 				goto err_xdp;
+ 			err = __virtnet_xdp_tx_xmit(vi, xdpf);
+ 			if (unlikely(err)) {
+ 				trace_xdp_exception(vi->dev, xdp_prog, act);
+ 				goto err_xdp;
+ 			}
+ 			*xdp_xmit = true;
+ 			rcu_read_unlock();
+ 			goto xdp_xmit;
+ 		case XDP_REDIRECT:
+ 			err = xdp_do_redirect(dev, &xdp, xdp_prog);
+ 			if (err)
+ 				goto err_xdp;
+ 			*xdp_xmit = true;
+ 			rcu_read_unlock();
+ 			goto xdp_xmit;
+ 		default:
+ 			bpf_warn_invalid_xdp_action(act);
+ 		case XDP_ABORTED:
+ 			trace_xdp_exception(vi->dev, xdp_prog, act);
+ 		case XDP_DROP:
+ 			goto err_xdp;
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	skb = build_skb(buf, buflen);
+ 	if (!skb) {
+ 		put_page(page);
+ 		goto err;
+ 	}
+ 	skb_reserve(skb, headroom - delta);
+ 	skb_put(skb, len);
+ 	if (!delta) {
+ 		buf += header_offset;
+ 		memcpy(skb_vnet_hdr(skb), buf, vi->hdr_len);
+ 	} /* keep zeroed vnet hdr since packet was changed by bpf */
+ 
+ err:
++>>>>>>> 735fc4054b3a (xdp: change ndo_xdp_xmit API to support bulking)
  	return skb;
 -
 -err_xdp:
 -	rcu_read_unlock();
 -	dev->stats.rx_dropped++;
 -	put_page(page);
 -xdp_xmit:
 -	return NULL;
  }
  
  static struct sk_buff *receive_big(struct net_device *dev,
@@@ -321,31 -720,155 +601,152 @@@ static struct sk_buff *receive_mergeabl
  					 struct virtnet_info *vi,
  					 struct receive_queue *rq,
  					 void *buf,
 -					 void *ctx,
 -					 unsigned int len,
 -					 bool *xdp_xmit)
 +					 unsigned int len)
  {
 -	struct virtio_net_hdr_mrg_rxbuf *hdr = buf;
 -	u16 num_buf = virtio16_to_cpu(vi->vdev, hdr->num_buffers);
 -	struct page *page = virt_to_head_page(buf);
 -	int offset = buf - page_address(page);
 -	struct sk_buff *head_skb, *curr_skb;
 -	struct bpf_prog *xdp_prog;
 -	unsigned int truesize;
 -	unsigned int headroom = mergeable_ctx_to_headroom(ctx);
 -	int err;
 +	struct virtio_net_hdr_mrg_rxbuf *hdr = page_address(buf);
 +	u16 num_buf = virtio16_to_cpu(rq->vq->vdev, hdr->num_buffers);
 +	struct page *page = buf;
 +	struct sk_buff *skb = page_to_skb(vi, rq, page, len);
 +	int i;
  
++<<<<<<< HEAD
 +	if (unlikely(!skb))
++=======
+ 	head_skb = NULL;
+ 
+ 	rcu_read_lock();
+ 	xdp_prog = rcu_dereference(rq->xdp_prog);
+ 	if (xdp_prog) {
+ 		struct xdp_frame *xdpf;
+ 		struct page *xdp_page;
+ 		struct xdp_buff xdp;
+ 		void *data;
+ 		u32 act;
+ 
+ 		/* This happens when rx buffer size is underestimated
+ 		 * or headroom is not enough because of the buffer
+ 		 * was refilled before XDP is set. This should only
+ 		 * happen for the first several packets, so we don't
+ 		 * care much about its performance.
+ 		 */
+ 		if (unlikely(num_buf > 1 ||
+ 			     headroom < virtnet_get_headroom(vi))) {
+ 			/* linearize data for XDP */
+ 			xdp_page = xdp_linearize_page(rq, &num_buf,
+ 						      page, offset,
+ 						      VIRTIO_XDP_HEADROOM,
+ 						      &len);
+ 			if (!xdp_page)
+ 				goto err_xdp;
+ 			offset = VIRTIO_XDP_HEADROOM;
+ 		} else {
+ 			xdp_page = page;
+ 		}
+ 
+ 		/* Transient failure which in theory could occur if
+ 		 * in-flight packets from before XDP was enabled reach
+ 		 * the receive path after XDP is loaded. In practice I
+ 		 * was not able to create this condition.
+ 		 */
+ 		if (unlikely(hdr->hdr.gso_type))
+ 			goto err_xdp;
+ 
+ 		/* Allow consuming headroom but reserve enough space to push
+ 		 * the descriptor on if we get an XDP_TX return code.
+ 		 */
+ 		data = page_address(xdp_page) + offset;
+ 		xdp.data_hard_start = data - VIRTIO_XDP_HEADROOM + vi->hdr_len;
+ 		xdp.data = data + vi->hdr_len;
+ 		xdp_set_data_meta_invalid(&xdp);
+ 		xdp.data_end = xdp.data + (len - vi->hdr_len);
+ 		xdp.rxq = &rq->xdp_rxq;
+ 
+ 		act = bpf_prog_run_xdp(xdp_prog, &xdp);
+ 
+ 		switch (act) {
+ 		case XDP_PASS:
+ 			/* recalculate offset to account for any header
+ 			 * adjustments. Note other cases do not build an
+ 			 * skb and avoid using offset
+ 			 */
+ 			offset = xdp.data -
+ 					page_address(xdp_page) - vi->hdr_len;
+ 
+ 			/* recalculate len if xdp.data or xdp.data_end were
+ 			 * adjusted
+ 			 */
+ 			len = xdp.data_end - xdp.data + vi->hdr_len;
+ 			/* We can only create skb based on xdp_page. */
+ 			if (unlikely(xdp_page != page)) {
+ 				rcu_read_unlock();
+ 				put_page(page);
+ 				head_skb = page_to_skb(vi, rq, xdp_page,
+ 						       offset, len, PAGE_SIZE);
+ 				return head_skb;
+ 			}
+ 			break;
+ 		case XDP_TX:
+ 			xdpf = convert_to_xdp_frame(&xdp);
+ 			if (unlikely(!xdpf))
+ 				goto err_xdp;
+ 			err = __virtnet_xdp_tx_xmit(vi, xdpf);
+ 			if (unlikely(err)) {
+ 				trace_xdp_exception(vi->dev, xdp_prog, act);
+ 				if (unlikely(xdp_page != page))
+ 					put_page(xdp_page);
+ 				goto err_xdp;
+ 			}
+ 			*xdp_xmit = true;
+ 			if (unlikely(xdp_page != page))
+ 				goto err_xdp;
+ 			rcu_read_unlock();
+ 			goto xdp_xmit;
+ 		case XDP_REDIRECT:
+ 			err = xdp_do_redirect(dev, &xdp, xdp_prog);
+ 			if (err) {
+ 				if (unlikely(xdp_page != page))
+ 					put_page(xdp_page);
+ 				goto err_xdp;
+ 			}
+ 			*xdp_xmit = true;
+ 			if (unlikely(xdp_page != page))
+ 				goto err_xdp;
+ 			rcu_read_unlock();
+ 			goto xdp_xmit;
+ 		default:
+ 			bpf_warn_invalid_xdp_action(act);
+ 		case XDP_ABORTED:
+ 			trace_xdp_exception(vi->dev, xdp_prog, act);
+ 		case XDP_DROP:
+ 			if (unlikely(xdp_page != page))
+ 				__free_pages(xdp_page, 0);
+ 			goto err_xdp;
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	truesize = mergeable_ctx_to_truesize(ctx);
+ 	if (unlikely(len > truesize)) {
+ 		pr_debug("%s: rx error: len %u exceeds truesize %lu\n",
+ 			 dev->name, len, (unsigned long)ctx);
+ 		dev->stats.rx_length_errors++;
++>>>>>>> 735fc4054b3a (xdp: change ndo_xdp_xmit API to support bulking)
  		goto err_skb;
 -	}
 -
 -	head_skb = page_to_skb(vi, rq, page, offset, len, truesize);
 -	curr_skb = head_skb;
  
 -	if (unlikely(!curr_skb))
 -		goto err_skb;
  	while (--num_buf) {
 -		int num_skb_frags;
 -
 -		buf = virtqueue_get_buf_ctx(rq->vq, &len, &ctx);
 -		if (unlikely(!buf)) {
 -			pr_debug("%s: rx error: %d buffers out of %d missing\n",
 -				 dev->name, num_buf,
 -				 virtio16_to_cpu(vi->vdev,
 -						 hdr->num_buffers));
 +		i = skb_shinfo(skb)->nr_frags;
 +		if (i >= MAX_SKB_FRAGS) {
 +			pr_debug("%s: packet too long\n", skb->dev->name);
 +			skb->dev->stats.rx_length_errors++;
 +			return NULL;
 +		}
 +		page = virtqueue_get_buf(rq->vq, &len);
 +		if (!page) {
 +			pr_debug("%s: rx error: %d buffers %d missing\n",
 +				 dev->name,
 +				 virtio16_to_cpu(rq->vq->vdev,
 +						 hdr->num_buffers),
 +				 num_buf);
  			dev->stats.rx_length_errors++;
  			goto err_buf;
  		}
diff --cc include/linux/netdevice.h
index ef45e698a4e4,debdb6286170..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1304,6 -1175,26 +1304,29 @@@ struct netdev_xdp 
   *	This function is used to get egress tunnel information for given skb.
   *	This is useful for retrieving outer tunnel header parameters while
   *	sampling packet.
++<<<<<<< HEAD
++=======
+  * void (*ndo_set_rx_headroom)(struct net_device *dev, int needed_headroom);
+  *	This function is used to specify the headroom that the skb must
+  *	consider when allocation skb during packet reception. Setting
+  *	appropriate rx headroom value allows avoiding skb head copy on
+  *	forward. Setting a negative value resets the rx headroom to the
+  *	default value.
+  * int (*ndo_bpf)(struct net_device *dev, struct netdev_bpf *bpf);
+  *	This function is used to set or query state related to XDP on the
+  *	netdevice and manage BPF offload. See definition of
+  *	enum bpf_netdev_command for details.
+  * int (*ndo_xdp_xmit)(struct net_device *dev, int n, struct xdp_frame **xdp);
+  *	This function is used to submit @n XDP packets for transmit on a
+  *	netdevice. Returns number of frames successfully transmitted, frames
+  *	that got dropped are freed/returned via xdp_return_frame().
+  *	Returns negative number, means general error invoking ndo, meaning
+  *	no frames were xmit'ed and core-caller will free all frames.
+  *	TODO: Consider add flag to allow sending flush operation.
+  * void (*ndo_xdp_flush)(struct net_device *dev);
+  *	This function is used to inform the driver to flush a particular
+  *	xdp tx queue. Must be called on same CPU as xdp_xmit.
++>>>>>>> 735fc4054b3a (xdp: change ndo_xdp_xmit API to support bulking)
   */
  struct net_device_ops {
  	int			(*ndo_init)(struct net_device *dev);
@@@ -1465,77 -1355,35 +1488,96 @@@
  						      bool new_carrier);
  	int			(*ndo_get_phys_port_id)(struct net_device *dev,
  							struct netdev_phys_item_id *ppid);
 -	int			(*ndo_get_phys_port_name)(struct net_device *dev,
 -							  char *name, size_t len);
 -	void			(*ndo_udp_tunnel_add)(struct net_device *dev,
 -						      struct udp_tunnel_info *ti);
 -	void			(*ndo_udp_tunnel_del)(struct net_device *dev,
 -						      struct udp_tunnel_info *ti);
 -	void*			(*ndo_dfwd_add_station)(struct net_device *pdev,
 -							struct net_device *dev);
 -	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
 -							void *priv);
 +	void			(*ndo_add_vxlan_port)(struct  net_device *dev,
 +						      sa_family_t sa_family,
 +						      __be16 port);
 +	void			(*ndo_del_vxlan_port)(struct  net_device *dev,
 +						      sa_family_t sa_family,
 +						      __be16 port);
 +
++<<<<<<< HEAD
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, int	(*ndo_get_iflink)(const struct net_device *dev))
 +	RH_KABI_USE_P(2, netdev_features_t
 +				(*ndo_features_check)(struct sk_buff *skb,
 +						      struct net_device *dev,
 +						      netdev_features_t features))
 +	RH_KABI_USE_P(3, int	(*ndo_set_vf_rate)(struct net_device *dev,
 +						   int vf, int min_tx_rate,
 +						   int max_tx_rate))
 +	RH_KABI_USE_P(4, int	(*ndo_get_vf_stats)(struct net_device *dev,
 +						    int vf,
 +						    struct ifla_vf_stats
 +						    *vf_stats))
 +	RH_KABI_USE_P(5, int    (*ndo_set_vf_rss_query_en)(struct net_device *dev,
 +							   int vf, bool setting))
  
 +	RH_KABI_USE_P(6, int	(*ndo_fdb_add)(struct ndmsg *ndm,
 +					       struct nlattr *tb[],
 +					       struct net_device *dev,
 +					       const unsigned char *addr,
 +					       u16 vid,
 +					       u16 flags))
 +	RH_KABI_USE_P(7,int	(*ndo_setup_tc_rh74)(struct net_device *dev,
 +						     u32 handle,
 +						     __be16 protocol,
 +						     struct tc_to_netdev_rh74 *tc))
 +	RH_KABI_USE_P(8, int	(*ndo_fill_metadata_dst)(struct net_device *dev,
 +						       struct sk_buff *skb))
 +	RH_KABI_USE_P(9, void	(*ndo_add_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_USE_P(10, void	(*ndo_del_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_USE_P(16, size_t ndo_size)
 +	/* RHEL: put all new non-performance critical ndo's into
 +	 * net_device_ops_extended. The reserved slots above can be used
 +	 * only for performance critical operations.
 +	 * Drivers may access the extended fields directly from
 +	 * net_device_ops, if they allocated the net_device_ops structure
 +	 * themselves (usually statically). The kernel core and drivers
 +	 * using others' net_device_ops must access the extended fields
 +	 * using the get_ndo_ext macro.
 +	 */
 +	RH_KABI_EXTEND(struct net_device_ops_extended extended)
++=======
+ 	int			(*ndo_get_lock_subclass)(struct net_device *dev);
+ 	int			(*ndo_set_tx_maxrate)(struct net_device *dev,
+ 						      int queue_index,
+ 						      u32 maxrate);
+ 	int			(*ndo_get_iflink)(const struct net_device *dev);
+ 	int			(*ndo_change_proto_down)(struct net_device *dev,
+ 							 bool proto_down);
+ 	int			(*ndo_fill_metadata_dst)(struct net_device *dev,
+ 						       struct sk_buff *skb);
+ 	void			(*ndo_set_rx_headroom)(struct net_device *dev,
+ 						       int needed_headroom);
+ 	int			(*ndo_bpf)(struct net_device *dev,
+ 					   struct netdev_bpf *bpf);
+ 	int			(*ndo_xdp_xmit)(struct net_device *dev, int n,
+ 						struct xdp_frame **xdp);
+ 	void			(*ndo_xdp_flush)(struct net_device *dev);
++>>>>>>> 735fc4054b3a (xdp: change ndo_xdp_xmit API to support bulking)
  };
  
 +#define get_ndo_ext(ops, field)		({				\
 +	const struct net_device_ops *__ops = (ops);			\
 +	size_t __off = offsetof(struct net_device_ops, extended.field);	\
 +	__ops->ndo_size > __off ? __ops->extended.field : NULL;		\
 +	})
 +
  /**
   * enum net_device_priv_flags - &struct net_device priv_flags
   *
diff --cc kernel/bpf/devmap.c
index 644098c7566a,77908311ec98..000000000000
--- a/kernel/bpf/devmap.c
+++ b/kernel/bpf/devmap.c
@@@ -156,6 -208,91 +156,94 @@@ static int dev_map_get_next_key(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ void __dev_map_insert_ctx(struct bpf_map *map, u32 bit)
+ {
+ 	struct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);
+ 	unsigned long *bitmap = this_cpu_ptr(dtab->flush_needed);
+ 
+ 	__set_bit(bit, bitmap);
+ }
+ 
+ static int bq_xmit_all(struct bpf_dtab_netdev *obj,
+ 			 struct xdp_bulk_queue *bq)
+ {
+ 	struct net_device *dev = obj->dev;
+ 	int sent = 0, drops = 0;
+ 	int i;
+ 
+ 	if (unlikely(!bq->count))
+ 		return 0;
+ 
+ 	for (i = 0; i < bq->count; i++) {
+ 		struct xdp_frame *xdpf = bq->q[i];
+ 
+ 		prefetch(xdpf);
+ 	}
+ 
+ 	sent = dev->netdev_ops->ndo_xdp_xmit(dev, bq->count, bq->q);
+ 	if (sent < 0) {
+ 		sent = 0;
+ 		goto error;
+ 	}
+ 	drops = bq->count - sent;
+ out:
+ 	bq->count = 0;
+ 
+ 	trace_xdp_devmap_xmit(&obj->dtab->map, obj->bit,
+ 			      sent, drops, bq->dev_rx, dev);
+ 	bq->dev_rx = NULL;
+ 	return 0;
+ error:
+ 	/* If ndo_xdp_xmit fails with an errno, no frames have been
+ 	 * xmit'ed and it's our responsibility to them free all.
+ 	 */
+ 	for (i = 0; i < bq->count; i++) {
+ 		struct xdp_frame *xdpf = bq->q[i];
+ 
+ 		/* RX path under NAPI protection, can return frames faster */
+ 		xdp_return_frame_rx_napi(xdpf);
+ 		drops++;
+ 	}
+ 	goto out;
+ }
+ 
+ /* __dev_map_flush is called from xdp_do_flush_map() which _must_ be signaled
+  * from the driver before returning from its napi->poll() routine. The poll()
+  * routine is called either from busy_poll context or net_rx_action signaled
+  * from NET_RX_SOFTIRQ. Either way the poll routine must complete before the
+  * net device can be torn down. On devmap tear down we ensure the ctx bitmap
+  * is zeroed before completing to ensure all flush operations have completed.
+  */
+ void __dev_map_flush(struct bpf_map *map)
+ {
+ 	struct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);
+ 	unsigned long *bitmap = this_cpu_ptr(dtab->flush_needed);
+ 	u32 bit;
+ 
+ 	for_each_set_bit(bit, bitmap, map->max_entries) {
+ 		struct bpf_dtab_netdev *dev = READ_ONCE(dtab->netdev_map[bit]);
+ 		struct xdp_bulk_queue *bq;
+ 		struct net_device *netdev;
+ 
+ 		/* This is possible if the dev entry is removed by user space
+ 		 * between xdp redirect and flush op.
+ 		 */
+ 		if (unlikely(!dev))
+ 			continue;
+ 
+ 		__clear_bit(bit, bitmap);
+ 
+ 		bq = this_cpu_ptr(dev->bulkq);
+ 		bq_xmit_all(dev, bq);
+ 		netdev = dev->dev;
+ 		if (likely(netdev->netdev_ops->ndo_xdp_flush))
+ 			netdev->netdev_ops->ndo_xdp_flush(netdev);
+ 	}
+ }
+ 
++>>>>>>> 735fc4054b3a (xdp: change ndo_xdp_xmit API to support bulking)
  /* rcu_read_lock (from syscall and BPF contexts) ensures that if a delete and/or
   * update happens in parallel here a dev_put wont happen until after reading the
   * ifindex.
diff --cc net/core/filter.c
index d9b11f9993e7,1d75f9322275..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -763,6 -1525,5170 +763,5173 @@@ int sk_attach_filter(struct sock_fprog 
  }
  EXPORT_SYMBOL_GPL(sk_attach_filter);
  
++<<<<<<< HEAD
++=======
+ int sk_reuseport_attach_filter(struct sock_fprog *fprog, struct sock *sk)
+ {
+ 	struct bpf_prog *prog = __get_filter(fprog, sk);
+ 	int err;
+ 
+ 	if (IS_ERR(prog))
+ 		return PTR_ERR(prog);
+ 
+ 	err = __reuseport_attach_prog(prog, sk);
+ 	if (err < 0) {
+ 		__bpf_prog_release(prog);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static struct bpf_prog *__get_bpf(u32 ufd, struct sock *sk)
+ {
+ 	if (sock_flag(sk, SOCK_FILTER_LOCKED))
+ 		return ERR_PTR(-EPERM);
+ 
+ 	return bpf_prog_get_type(ufd, BPF_PROG_TYPE_SOCKET_FILTER);
+ }
+ 
+ int sk_attach_bpf(u32 ufd, struct sock *sk)
+ {
+ 	struct bpf_prog *prog = __get_bpf(ufd, sk);
+ 	int err;
+ 
+ 	if (IS_ERR(prog))
+ 		return PTR_ERR(prog);
+ 
+ 	err = __sk_attach_prog(prog, sk);
+ 	if (err < 0) {
+ 		bpf_prog_put(prog);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int sk_reuseport_attach_bpf(u32 ufd, struct sock *sk)
+ {
+ 	struct bpf_prog *prog = __get_bpf(ufd, sk);
+ 	int err;
+ 
+ 	if (IS_ERR(prog))
+ 		return PTR_ERR(prog);
+ 
+ 	err = __reuseport_attach_prog(prog, sk);
+ 	if (err < 0) {
+ 		bpf_prog_put(prog);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ struct bpf_scratchpad {
+ 	union {
+ 		__be32 diff[MAX_BPF_STACK / sizeof(__be32)];
+ 		u8     buff[MAX_BPF_STACK];
+ 	};
+ };
+ 
+ static DEFINE_PER_CPU(struct bpf_scratchpad, bpf_sp);
+ 
+ static inline int __bpf_try_make_writable(struct sk_buff *skb,
+ 					  unsigned int write_len)
+ {
+ 	return skb_ensure_writable(skb, write_len);
+ }
+ 
+ static inline int bpf_try_make_writable(struct sk_buff *skb,
+ 					unsigned int write_len)
+ {
+ 	int err = __bpf_try_make_writable(skb, write_len);
+ 
+ 	bpf_compute_data_pointers(skb);
+ 	return err;
+ }
+ 
+ static int bpf_try_make_head_writable(struct sk_buff *skb)
+ {
+ 	return bpf_try_make_writable(skb, skb_headlen(skb));
+ }
+ 
+ static inline void bpf_push_mac_rcsum(struct sk_buff *skb)
+ {
+ 	if (skb_at_tc_ingress(skb))
+ 		skb_postpush_rcsum(skb, skb_mac_header(skb), skb->mac_len);
+ }
+ 
+ static inline void bpf_pull_mac_rcsum(struct sk_buff *skb)
+ {
+ 	if (skb_at_tc_ingress(skb))
+ 		skb_postpull_rcsum(skb, skb_mac_header(skb), skb->mac_len);
+ }
+ 
+ BPF_CALL_5(bpf_skb_store_bytes, struct sk_buff *, skb, u32, offset,
+ 	   const void *, from, u32, len, u64, flags)
+ {
+ 	void *ptr;
+ 
+ 	if (unlikely(flags & ~(BPF_F_RECOMPUTE_CSUM | BPF_F_INVALIDATE_HASH)))
+ 		return -EINVAL;
+ 	if (unlikely(offset > 0xffff))
+ 		return -EFAULT;
+ 	if (unlikely(bpf_try_make_writable(skb, offset + len)))
+ 		return -EFAULT;
+ 
+ 	ptr = skb->data + offset;
+ 	if (flags & BPF_F_RECOMPUTE_CSUM)
+ 		__skb_postpull_rcsum(skb, ptr, len, offset);
+ 
+ 	memcpy(ptr, from, len);
+ 
+ 	if (flags & BPF_F_RECOMPUTE_CSUM)
+ 		__skb_postpush_rcsum(skb, ptr, len, offset);
+ 	if (flags & BPF_F_INVALIDATE_HASH)
+ 		skb_clear_hash(skb);
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_store_bytes_proto = {
+ 	.func		= bpf_skb_store_bytes,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_PTR_TO_MEM,
+ 	.arg4_type	= ARG_CONST_SIZE,
+ 	.arg5_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_4(bpf_skb_load_bytes, const struct sk_buff *, skb, u32, offset,
+ 	   void *, to, u32, len)
+ {
+ 	void *ptr;
+ 
+ 	if (unlikely(offset > 0xffff))
+ 		goto err_clear;
+ 
+ 	ptr = skb_header_pointer(skb, offset, len, to);
+ 	if (unlikely(!ptr))
+ 		goto err_clear;
+ 	if (ptr != to)
+ 		memcpy(to, ptr, len);
+ 
+ 	return 0;
+ err_clear:
+ 	memset(to, 0, len);
+ 	return -EFAULT;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_load_bytes_proto = {
+ 	.func		= bpf_skb_load_bytes,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg4_type	= ARG_CONST_SIZE,
+ };
+ 
+ BPF_CALL_5(bpf_skb_load_bytes_relative, const struct sk_buff *, skb,
+ 	   u32, offset, void *, to, u32, len, u32, start_header)
+ {
+ 	u8 *ptr;
+ 
+ 	if (unlikely(offset > 0xffff || len > skb_headlen(skb)))
+ 		goto err_clear;
+ 
+ 	switch (start_header) {
+ 	case BPF_HDR_START_MAC:
+ 		ptr = skb_mac_header(skb) + offset;
+ 		break;
+ 	case BPF_HDR_START_NET:
+ 		ptr = skb_network_header(skb) + offset;
+ 		break;
+ 	default:
+ 		goto err_clear;
+ 	}
+ 
+ 	if (likely(ptr >= skb_mac_header(skb) &&
+ 		   ptr + len <= skb_tail_pointer(skb))) {
+ 		memcpy(to, ptr, len);
+ 		return 0;
+ 	}
+ 
+ err_clear:
+ 	memset(to, 0, len);
+ 	return -EFAULT;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_load_bytes_relative_proto = {
+ 	.func		= bpf_skb_load_bytes_relative,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg4_type	= ARG_CONST_SIZE,
+ 	.arg5_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_2(bpf_skb_pull_data, struct sk_buff *, skb, u32, len)
+ {
+ 	/* Idea is the following: should the needed direct read/write
+ 	 * test fail during runtime, we can pull in more data and redo
+ 	 * again, since implicitly, we invalidate previous checks here.
+ 	 *
+ 	 * Or, since we know how much we need to make read/writeable,
+ 	 * this can be done once at the program beginning for direct
+ 	 * access case. By this we overcome limitations of only current
+ 	 * headroom being accessible.
+ 	 */
+ 	return bpf_try_make_writable(skb, len ? : skb_headlen(skb));
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_pull_data_proto = {
+ 	.func		= bpf_skb_pull_data,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_5(bpf_l3_csum_replace, struct sk_buff *, skb, u32, offset,
+ 	   u64, from, u64, to, u64, flags)
+ {
+ 	__sum16 *ptr;
+ 
+ 	if (unlikely(flags & ~(BPF_F_HDR_FIELD_MASK)))
+ 		return -EINVAL;
+ 	if (unlikely(offset > 0xffff || offset & 1))
+ 		return -EFAULT;
+ 	if (unlikely(bpf_try_make_writable(skb, offset + sizeof(*ptr))))
+ 		return -EFAULT;
+ 
+ 	ptr = (__sum16 *)(skb->data + offset);
+ 	switch (flags & BPF_F_HDR_FIELD_MASK) {
+ 	case 0:
+ 		if (unlikely(from != 0))
+ 			return -EINVAL;
+ 
+ 		csum_replace_by_diff(ptr, to);
+ 		break;
+ 	case 2:
+ 		csum_replace2(ptr, from, to);
+ 		break;
+ 	case 4:
+ 		csum_replace4(ptr, from, to);
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_l3_csum_replace_proto = {
+ 	.func		= bpf_l3_csum_replace,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_ANYTHING,
+ 	.arg5_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_5(bpf_l4_csum_replace, struct sk_buff *, skb, u32, offset,
+ 	   u64, from, u64, to, u64, flags)
+ {
+ 	bool is_pseudo = flags & BPF_F_PSEUDO_HDR;
+ 	bool is_mmzero = flags & BPF_F_MARK_MANGLED_0;
+ 	bool do_mforce = flags & BPF_F_MARK_ENFORCE;
+ 	__sum16 *ptr;
+ 
+ 	if (unlikely(flags & ~(BPF_F_MARK_MANGLED_0 | BPF_F_MARK_ENFORCE |
+ 			       BPF_F_PSEUDO_HDR | BPF_F_HDR_FIELD_MASK)))
+ 		return -EINVAL;
+ 	if (unlikely(offset > 0xffff || offset & 1))
+ 		return -EFAULT;
+ 	if (unlikely(bpf_try_make_writable(skb, offset + sizeof(*ptr))))
+ 		return -EFAULT;
+ 
+ 	ptr = (__sum16 *)(skb->data + offset);
+ 	if (is_mmzero && !do_mforce && !*ptr)
+ 		return 0;
+ 
+ 	switch (flags & BPF_F_HDR_FIELD_MASK) {
+ 	case 0:
+ 		if (unlikely(from != 0))
+ 			return -EINVAL;
+ 
+ 		inet_proto_csum_replace_by_diff(ptr, skb, to, is_pseudo);
+ 		break;
+ 	case 2:
+ 		inet_proto_csum_replace2(ptr, skb, from, to, is_pseudo);
+ 		break;
+ 	case 4:
+ 		inet_proto_csum_replace4(ptr, skb, from, to, is_pseudo);
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (is_mmzero && !*ptr)
+ 		*ptr = CSUM_MANGLED_0;
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_l4_csum_replace_proto = {
+ 	.func		= bpf_l4_csum_replace,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_ANYTHING,
+ 	.arg5_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_5(bpf_csum_diff, __be32 *, from, u32, from_size,
+ 	   __be32 *, to, u32, to_size, __wsum, seed)
+ {
+ 	struct bpf_scratchpad *sp = this_cpu_ptr(&bpf_sp);
+ 	u32 diff_size = from_size + to_size;
+ 	int i, j = 0;
+ 
+ 	/* This is quite flexible, some examples:
+ 	 *
+ 	 * from_size == 0, to_size > 0,  seed := csum --> pushing data
+ 	 * from_size > 0,  to_size == 0, seed := csum --> pulling data
+ 	 * from_size > 0,  to_size > 0,  seed := 0    --> diffing data
+ 	 *
+ 	 * Even for diffing, from_size and to_size don't need to be equal.
+ 	 */
+ 	if (unlikely(((from_size | to_size) & (sizeof(__be32) - 1)) ||
+ 		     diff_size > sizeof(sp->diff)))
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < from_size / sizeof(__be32); i++, j++)
+ 		sp->diff[j] = ~from[i];
+ 	for (i = 0; i <   to_size / sizeof(__be32); i++, j++)
+ 		sp->diff[j] = to[i];
+ 
+ 	return csum_partial(sp->diff, diff_size, seed);
+ }
+ 
+ static const struct bpf_func_proto bpf_csum_diff_proto = {
+ 	.func		= bpf_csum_diff,
+ 	.gpl_only	= false,
+ 	.pkt_access	= true,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_MEM_OR_NULL,
+ 	.arg2_type	= ARG_CONST_SIZE_OR_ZERO,
+ 	.arg3_type	= ARG_PTR_TO_MEM_OR_NULL,
+ 	.arg4_type	= ARG_CONST_SIZE_OR_ZERO,
+ 	.arg5_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_2(bpf_csum_update, struct sk_buff *, skb, __wsum, csum)
+ {
+ 	/* The interface is to be used in combination with bpf_csum_diff()
+ 	 * for direct packet writes. csum rotation for alignment as well
+ 	 * as emulating csum_sub() can be done from the eBPF program.
+ 	 */
+ 	if (skb->ip_summed == CHECKSUM_COMPLETE)
+ 		return (skb->csum = csum_add(skb->csum, csum));
+ 
+ 	return -ENOTSUPP;
+ }
+ 
+ static const struct bpf_func_proto bpf_csum_update_proto = {
+ 	.func		= bpf_csum_update,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ };
+ 
+ static inline int __bpf_rx_skb(struct net_device *dev, struct sk_buff *skb)
+ {
+ 	return dev_forward_skb(dev, skb);
+ }
+ 
+ static inline int __bpf_rx_skb_no_mac(struct net_device *dev,
+ 				      struct sk_buff *skb)
+ {
+ 	int ret = ____dev_forward_skb(dev, skb);
+ 
+ 	if (likely(!ret)) {
+ 		skb->dev = dev;
+ 		ret = netif_rx(skb);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static inline int __bpf_tx_skb(struct net_device *dev, struct sk_buff *skb)
+ {
+ 	int ret;
+ 
+ 	if (unlikely(__this_cpu_read(xmit_recursion) > XMIT_RECURSION_LIMIT)) {
+ 		net_crit_ratelimited("bpf: recursion limit reached on datapath, buggy bpf program?\n");
+ 		kfree_skb(skb);
+ 		return -ENETDOWN;
+ 	}
+ 
+ 	skb->dev = dev;
+ 
+ 	__this_cpu_inc(xmit_recursion);
+ 	ret = dev_queue_xmit(skb);
+ 	__this_cpu_dec(xmit_recursion);
+ 
+ 	return ret;
+ }
+ 
+ static int __bpf_redirect_no_mac(struct sk_buff *skb, struct net_device *dev,
+ 				 u32 flags)
+ {
+ 	/* skb->mac_len is not set on normal egress */
+ 	unsigned int mlen = skb->network_header - skb->mac_header;
+ 
+ 	__skb_pull(skb, mlen);
+ 
+ 	/* At ingress, the mac header has already been pulled once.
+ 	 * At egress, skb_pospull_rcsum has to be done in case that
+ 	 * the skb is originated from ingress (i.e. a forwarded skb)
+ 	 * to ensure that rcsum starts at net header.
+ 	 */
+ 	if (!skb_at_tc_ingress(skb))
+ 		skb_postpull_rcsum(skb, skb_mac_header(skb), mlen);
+ 	skb_pop_mac_header(skb);
+ 	skb_reset_mac_len(skb);
+ 	return flags & BPF_F_INGRESS ?
+ 	       __bpf_rx_skb_no_mac(dev, skb) : __bpf_tx_skb(dev, skb);
+ }
+ 
+ static int __bpf_redirect_common(struct sk_buff *skb, struct net_device *dev,
+ 				 u32 flags)
+ {
+ 	/* Verify that a link layer header is carried */
+ 	if (unlikely(skb->mac_header >= skb->network_header)) {
+ 		kfree_skb(skb);
+ 		return -ERANGE;
+ 	}
+ 
+ 	bpf_push_mac_rcsum(skb);
+ 	return flags & BPF_F_INGRESS ?
+ 	       __bpf_rx_skb(dev, skb) : __bpf_tx_skb(dev, skb);
+ }
+ 
+ static int __bpf_redirect(struct sk_buff *skb, struct net_device *dev,
+ 			  u32 flags)
+ {
+ 	if (dev_is_mac_header_xmit(dev))
+ 		return __bpf_redirect_common(skb, dev, flags);
+ 	else
+ 		return __bpf_redirect_no_mac(skb, dev, flags);
+ }
+ 
+ BPF_CALL_3(bpf_clone_redirect, struct sk_buff *, skb, u32, ifindex, u64, flags)
+ {
+ 	struct net_device *dev;
+ 	struct sk_buff *clone;
+ 	int ret;
+ 
+ 	if (unlikely(flags & ~(BPF_F_INGRESS)))
+ 		return -EINVAL;
+ 
+ 	dev = dev_get_by_index_rcu(dev_net(skb->dev), ifindex);
+ 	if (unlikely(!dev))
+ 		return -EINVAL;
+ 
+ 	clone = skb_clone(skb, GFP_ATOMIC);
+ 	if (unlikely(!clone))
+ 		return -ENOMEM;
+ 
+ 	/* For direct write, we need to keep the invariant that the skbs
+ 	 * we're dealing with need to be uncloned. Should uncloning fail
+ 	 * here, we need to free the just generated clone to unclone once
+ 	 * again.
+ 	 */
+ 	ret = bpf_try_make_head_writable(skb);
+ 	if (unlikely(ret)) {
+ 		kfree_skb(clone);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	return __bpf_redirect(clone, dev, flags);
+ }
+ 
+ static const struct bpf_func_proto bpf_clone_redirect_proto = {
+ 	.func           = bpf_clone_redirect,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ 	.arg2_type      = ARG_ANYTHING,
+ 	.arg3_type      = ARG_ANYTHING,
+ };
+ 
+ struct redirect_info {
+ 	u32 ifindex;
+ 	u32 flags;
+ 	struct bpf_map *map;
+ 	struct bpf_map *map_to_flush;
+ 	unsigned long   map_owner;
+ };
+ 
+ static DEFINE_PER_CPU(struct redirect_info, redirect_info);
+ 
+ BPF_CALL_2(bpf_redirect, u32, ifindex, u64, flags)
+ {
+ 	struct redirect_info *ri = this_cpu_ptr(&redirect_info);
+ 
+ 	if (unlikely(flags & ~(BPF_F_INGRESS)))
+ 		return TC_ACT_SHOT;
+ 
+ 	ri->ifindex = ifindex;
+ 	ri->flags = flags;
+ 
+ 	return TC_ACT_REDIRECT;
+ }
+ 
+ int skb_do_redirect(struct sk_buff *skb)
+ {
+ 	struct redirect_info *ri = this_cpu_ptr(&redirect_info);
+ 	struct net_device *dev;
+ 
+ 	dev = dev_get_by_index_rcu(dev_net(skb->dev), ri->ifindex);
+ 	ri->ifindex = 0;
+ 	if (unlikely(!dev)) {
+ 		kfree_skb(skb);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return __bpf_redirect(skb, dev, ri->flags);
+ }
+ 
+ static const struct bpf_func_proto bpf_redirect_proto = {
+ 	.func           = bpf_redirect,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_ANYTHING,
+ 	.arg2_type      = ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_4(bpf_sk_redirect_hash, struct sk_buff *, skb,
+ 	   struct bpf_map *, map, void *, key, u64, flags)
+ {
+ 	struct tcp_skb_cb *tcb = TCP_SKB_CB(skb);
+ 
+ 	/* If user passes invalid input drop the packet. */
+ 	if (unlikely(flags & ~(BPF_F_INGRESS)))
+ 		return SK_DROP;
+ 
+ 	tcb->bpf.flags = flags;
+ 	tcb->bpf.sk_redir = __sock_hash_lookup_elem(map, key);
+ 	if (!tcb->bpf.sk_redir)
+ 		return SK_DROP;
+ 
+ 	return SK_PASS;
+ }
+ 
+ static const struct bpf_func_proto bpf_sk_redirect_hash_proto = {
+ 	.func           = bpf_sk_redirect_hash,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type      = ARG_CONST_MAP_PTR,
+ 	.arg3_type      = ARG_PTR_TO_MAP_KEY,
+ 	.arg4_type      = ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_4(bpf_sk_redirect_map, struct sk_buff *, skb,
+ 	   struct bpf_map *, map, u32, key, u64, flags)
+ {
+ 	struct tcp_skb_cb *tcb = TCP_SKB_CB(skb);
+ 
+ 	/* If user passes invalid input drop the packet. */
+ 	if (unlikely(flags & ~(BPF_F_INGRESS)))
+ 		return SK_DROP;
+ 
+ 	tcb->bpf.flags = flags;
+ 	tcb->bpf.sk_redir = __sock_map_lookup_elem(map, key);
+ 	if (!tcb->bpf.sk_redir)
+ 		return SK_DROP;
+ 
+ 	return SK_PASS;
+ }
+ 
+ struct sock *do_sk_redirect_map(struct sk_buff *skb)
+ {
+ 	struct tcp_skb_cb *tcb = TCP_SKB_CB(skb);
+ 
+ 	return tcb->bpf.sk_redir;
+ }
+ 
+ static const struct bpf_func_proto bpf_sk_redirect_map_proto = {
+ 	.func           = bpf_sk_redirect_map,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type      = ARG_CONST_MAP_PTR,
+ 	.arg3_type      = ARG_ANYTHING,
+ 	.arg4_type      = ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_4(bpf_msg_redirect_hash, struct sk_msg_buff *, msg,
+ 	   struct bpf_map *, map, void *, key, u64, flags)
+ {
+ 	/* If user passes invalid input drop the packet. */
+ 	if (unlikely(flags & ~(BPF_F_INGRESS)))
+ 		return SK_DROP;
+ 
+ 	msg->flags = flags;
+ 	msg->sk_redir = __sock_hash_lookup_elem(map, key);
+ 	if (!msg->sk_redir)
+ 		return SK_DROP;
+ 
+ 	return SK_PASS;
+ }
+ 
+ static const struct bpf_func_proto bpf_msg_redirect_hash_proto = {
+ 	.func           = bpf_msg_redirect_hash,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type      = ARG_CONST_MAP_PTR,
+ 	.arg3_type      = ARG_PTR_TO_MAP_KEY,
+ 	.arg4_type      = ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_4(bpf_msg_redirect_map, struct sk_msg_buff *, msg,
+ 	   struct bpf_map *, map, u32, key, u64, flags)
+ {
+ 	/* If user passes invalid input drop the packet. */
+ 	if (unlikely(flags & ~(BPF_F_INGRESS)))
+ 		return SK_DROP;
+ 
+ 	msg->flags = flags;
+ 	msg->sk_redir = __sock_map_lookup_elem(map, key);
+ 	if (!msg->sk_redir)
+ 		return SK_DROP;
+ 
+ 	return SK_PASS;
+ }
+ 
+ struct sock *do_msg_redirect_map(struct sk_msg_buff *msg)
+ {
+ 	return msg->sk_redir;
+ }
+ 
+ static const struct bpf_func_proto bpf_msg_redirect_map_proto = {
+ 	.func           = bpf_msg_redirect_map,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type      = ARG_CONST_MAP_PTR,
+ 	.arg3_type      = ARG_ANYTHING,
+ 	.arg4_type      = ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_2(bpf_msg_apply_bytes, struct sk_msg_buff *, msg, u32, bytes)
+ {
+ 	msg->apply_bytes = bytes;
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_msg_apply_bytes_proto = {
+ 	.func           = bpf_msg_apply_bytes,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type      = ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_2(bpf_msg_cork_bytes, struct sk_msg_buff *, msg, u32, bytes)
+ {
+ 	msg->cork_bytes = bytes;
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_msg_cork_bytes_proto = {
+ 	.func           = bpf_msg_cork_bytes,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type      = ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_4(bpf_msg_pull_data,
+ 	   struct sk_msg_buff *, msg, u32, start, u32, end, u64, flags)
+ {
+ 	unsigned int len = 0, offset = 0, copy = 0;
+ 	struct scatterlist *sg = msg->sg_data;
+ 	int first_sg, last_sg, i, shift;
+ 	unsigned char *p, *to, *from;
+ 	int bytes = end - start;
+ 	struct page *page;
+ 
+ 	if (unlikely(flags || end <= start))
+ 		return -EINVAL;
+ 
+ 	/* First find the starting scatterlist element */
+ 	i = msg->sg_start;
+ 	do {
+ 		len = sg[i].length;
+ 		offset += len;
+ 		if (start < offset + len)
+ 			break;
+ 		i++;
+ 		if (i == MAX_SKB_FRAGS)
+ 			i = 0;
+ 	} while (i != msg->sg_end);
+ 
+ 	if (unlikely(start >= offset + len))
+ 		return -EINVAL;
+ 
+ 	if (!msg->sg_copy[i] && bytes <= len)
+ 		goto out;
+ 
+ 	first_sg = i;
+ 
+ 	/* At this point we need to linearize multiple scatterlist
+ 	 * elements or a single shared page. Either way we need to
+ 	 * copy into a linear buffer exclusively owned by BPF. Then
+ 	 * place the buffer in the scatterlist and fixup the original
+ 	 * entries by removing the entries now in the linear buffer
+ 	 * and shifting the remaining entries. For now we do not try
+ 	 * to copy partial entries to avoid complexity of running out
+ 	 * of sg_entry slots. The downside is reading a single byte
+ 	 * will copy the entire sg entry.
+ 	 */
+ 	do {
+ 		copy += sg[i].length;
+ 		i++;
+ 		if (i == MAX_SKB_FRAGS)
+ 			i = 0;
+ 		if (bytes < copy)
+ 			break;
+ 	} while (i != msg->sg_end);
+ 	last_sg = i;
+ 
+ 	if (unlikely(copy < end - start))
+ 		return -EINVAL;
+ 
+ 	page = alloc_pages(__GFP_NOWARN | GFP_ATOMIC, get_order(copy));
+ 	if (unlikely(!page))
+ 		return -ENOMEM;
+ 	p = page_address(page);
+ 	offset = 0;
+ 
+ 	i = first_sg;
+ 	do {
+ 		from = sg_virt(&sg[i]);
+ 		len = sg[i].length;
+ 		to = p + offset;
+ 
+ 		memcpy(to, from, len);
+ 		offset += len;
+ 		sg[i].length = 0;
+ 		put_page(sg_page(&sg[i]));
+ 
+ 		i++;
+ 		if (i == MAX_SKB_FRAGS)
+ 			i = 0;
+ 	} while (i != last_sg);
+ 
+ 	sg[first_sg].length = copy;
+ 	sg_set_page(&sg[first_sg], page, copy, 0);
+ 
+ 	/* To repair sg ring we need to shift entries. If we only
+ 	 * had a single entry though we can just replace it and
+ 	 * be done. Otherwise walk the ring and shift the entries.
+ 	 */
+ 	shift = last_sg - first_sg - 1;
+ 	if (!shift)
+ 		goto out;
+ 
+ 	i = first_sg + 1;
+ 	do {
+ 		int move_from;
+ 
+ 		if (i + shift >= MAX_SKB_FRAGS)
+ 			move_from = i + shift - MAX_SKB_FRAGS;
+ 		else
+ 			move_from = i + shift;
+ 
+ 		if (move_from == msg->sg_end)
+ 			break;
+ 
+ 		sg[i] = sg[move_from];
+ 		sg[move_from].length = 0;
+ 		sg[move_from].page_link = 0;
+ 		sg[move_from].offset = 0;
+ 
+ 		i++;
+ 		if (i == MAX_SKB_FRAGS)
+ 			i = 0;
+ 	} while (1);
+ 	msg->sg_end -= shift;
+ 	if (msg->sg_end < 0)
+ 		msg->sg_end += MAX_SKB_FRAGS;
+ out:
+ 	msg->data = sg_virt(&sg[i]) + start - offset;
+ 	msg->data_end = msg->data + bytes;
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_msg_pull_data_proto = {
+ 	.func		= bpf_msg_pull_data,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_1(bpf_get_cgroup_classid, const struct sk_buff *, skb)
+ {
+ 	return task_get_classid(skb);
+ }
+ 
+ static const struct bpf_func_proto bpf_get_cgroup_classid_proto = {
+ 	.func           = bpf_get_cgroup_classid,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ };
+ 
+ BPF_CALL_1(bpf_get_route_realm, const struct sk_buff *, skb)
+ {
+ 	return dst_tclassid(skb);
+ }
+ 
+ static const struct bpf_func_proto bpf_get_route_realm_proto = {
+ 	.func           = bpf_get_route_realm,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ };
+ 
+ BPF_CALL_1(bpf_get_hash_recalc, struct sk_buff *, skb)
+ {
+ 	/* If skb_clear_hash() was called due to mangling, we can
+ 	 * trigger SW recalculation here. Later access to hash
+ 	 * can then use the inline skb->hash via context directly
+ 	 * instead of calling this helper again.
+ 	 */
+ 	return skb_get_hash(skb);
+ }
+ 
+ static const struct bpf_func_proto bpf_get_hash_recalc_proto = {
+ 	.func		= bpf_get_hash_recalc,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ };
+ 
+ BPF_CALL_1(bpf_set_hash_invalid, struct sk_buff *, skb)
+ {
+ 	/* After all direct packet write, this can be used once for
+ 	 * triggering a lazy recalc on next skb_get_hash() invocation.
+ 	 */
+ 	skb_clear_hash(skb);
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_set_hash_invalid_proto = {
+ 	.func		= bpf_set_hash_invalid,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ };
+ 
+ BPF_CALL_2(bpf_set_hash, struct sk_buff *, skb, u32, hash)
+ {
+ 	/* Set user specified hash as L4(+), so that it gets returned
+ 	 * on skb_get_hash() call unless BPF prog later on triggers a
+ 	 * skb_clear_hash().
+ 	 */
+ 	__skb_set_sw_hash(skb, hash, true);
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_set_hash_proto = {
+ 	.func		= bpf_set_hash,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_3(bpf_skb_vlan_push, struct sk_buff *, skb, __be16, vlan_proto,
+ 	   u16, vlan_tci)
+ {
+ 	int ret;
+ 
+ 	if (unlikely(vlan_proto != htons(ETH_P_8021Q) &&
+ 		     vlan_proto != htons(ETH_P_8021AD)))
+ 		vlan_proto = htons(ETH_P_8021Q);
+ 
+ 	bpf_push_mac_rcsum(skb);
+ 	ret = skb_vlan_push(skb, vlan_proto, vlan_tci);
+ 	bpf_pull_mac_rcsum(skb);
+ 
+ 	bpf_compute_data_pointers(skb);
+ 	return ret;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_vlan_push_proto = {
+ 	.func           = bpf_skb_vlan_push,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ 	.arg2_type      = ARG_ANYTHING,
+ 	.arg3_type      = ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_1(bpf_skb_vlan_pop, struct sk_buff *, skb)
+ {
+ 	int ret;
+ 
+ 	bpf_push_mac_rcsum(skb);
+ 	ret = skb_vlan_pop(skb);
+ 	bpf_pull_mac_rcsum(skb);
+ 
+ 	bpf_compute_data_pointers(skb);
+ 	return ret;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_vlan_pop_proto = {
+ 	.func           = bpf_skb_vlan_pop,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ };
+ 
+ static int bpf_skb_generic_push(struct sk_buff *skb, u32 off, u32 len)
+ {
+ 	/* Caller already did skb_cow() with len as headroom,
+ 	 * so no need to do it here.
+ 	 */
+ 	skb_push(skb, len);
+ 	memmove(skb->data, skb->data + len, off);
+ 	memset(skb->data + off, 0, len);
+ 
+ 	/* No skb_postpush_rcsum(skb, skb->data + off, len)
+ 	 * needed here as it does not change the skb->csum
+ 	 * result for checksum complete when summing over
+ 	 * zeroed blocks.
+ 	 */
+ 	return 0;
+ }
+ 
+ static int bpf_skb_generic_pop(struct sk_buff *skb, u32 off, u32 len)
+ {
+ 	/* skb_ensure_writable() is not needed here, as we're
+ 	 * already working on an uncloned skb.
+ 	 */
+ 	if (unlikely(!pskb_may_pull(skb, off + len)))
+ 		return -ENOMEM;
+ 
+ 	skb_postpull_rcsum(skb, skb->data + off, len);
+ 	memmove(skb->data + len, skb->data, off);
+ 	__skb_pull(skb, len);
+ 
+ 	return 0;
+ }
+ 
+ static int bpf_skb_net_hdr_push(struct sk_buff *skb, u32 off, u32 len)
+ {
+ 	bool trans_same = skb->transport_header == skb->network_header;
+ 	int ret;
+ 
+ 	/* There's no need for __skb_push()/__skb_pull() pair to
+ 	 * get to the start of the mac header as we're guaranteed
+ 	 * to always start from here under eBPF.
+ 	 */
+ 	ret = bpf_skb_generic_push(skb, off, len);
+ 	if (likely(!ret)) {
+ 		skb->mac_header -= len;
+ 		skb->network_header -= len;
+ 		if (trans_same)
+ 			skb->transport_header = skb->network_header;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int bpf_skb_net_hdr_pop(struct sk_buff *skb, u32 off, u32 len)
+ {
+ 	bool trans_same = skb->transport_header == skb->network_header;
+ 	int ret;
+ 
+ 	/* Same here, __skb_push()/__skb_pull() pair not needed. */
+ 	ret = bpf_skb_generic_pop(skb, off, len);
+ 	if (likely(!ret)) {
+ 		skb->mac_header += len;
+ 		skb->network_header += len;
+ 		if (trans_same)
+ 			skb->transport_header = skb->network_header;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int bpf_skb_proto_4_to_6(struct sk_buff *skb)
+ {
+ 	const u32 len_diff = sizeof(struct ipv6hdr) - sizeof(struct iphdr);
+ 	u32 off = skb_mac_header_len(skb);
+ 	int ret;
+ 
+ 	/* SCTP uses GSO_BY_FRAGS, thus cannot adjust it. */
+ 	if (skb_is_gso(skb) && unlikely(skb_is_gso_sctp(skb)))
+ 		return -ENOTSUPP;
+ 
+ 	ret = skb_cow(skb, len_diff);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	ret = bpf_skb_net_hdr_push(skb, off, len_diff);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	if (skb_is_gso(skb)) {
+ 		struct skb_shared_info *shinfo = skb_shinfo(skb);
+ 
+ 		/* SKB_GSO_TCPV4 needs to be changed into
+ 		 * SKB_GSO_TCPV6.
+ 		 */
+ 		if (shinfo->gso_type & SKB_GSO_TCPV4) {
+ 			shinfo->gso_type &= ~SKB_GSO_TCPV4;
+ 			shinfo->gso_type |=  SKB_GSO_TCPV6;
+ 		}
+ 
+ 		/* Due to IPv6 header, MSS needs to be downgraded. */
+ 		skb_decrease_gso_size(shinfo, len_diff);
+ 		/* Header must be checked, and gso_segs recomputed. */
+ 		shinfo->gso_type |= SKB_GSO_DODGY;
+ 		shinfo->gso_segs = 0;
+ 	}
+ 
+ 	skb->protocol = htons(ETH_P_IPV6);
+ 	skb_clear_hash(skb);
+ 
+ 	return 0;
+ }
+ 
+ static int bpf_skb_proto_6_to_4(struct sk_buff *skb)
+ {
+ 	const u32 len_diff = sizeof(struct ipv6hdr) - sizeof(struct iphdr);
+ 	u32 off = skb_mac_header_len(skb);
+ 	int ret;
+ 
+ 	/* SCTP uses GSO_BY_FRAGS, thus cannot adjust it. */
+ 	if (skb_is_gso(skb) && unlikely(skb_is_gso_sctp(skb)))
+ 		return -ENOTSUPP;
+ 
+ 	ret = skb_unclone(skb, GFP_ATOMIC);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	ret = bpf_skb_net_hdr_pop(skb, off, len_diff);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	if (skb_is_gso(skb)) {
+ 		struct skb_shared_info *shinfo = skb_shinfo(skb);
+ 
+ 		/* SKB_GSO_TCPV6 needs to be changed into
+ 		 * SKB_GSO_TCPV4.
+ 		 */
+ 		if (shinfo->gso_type & SKB_GSO_TCPV6) {
+ 			shinfo->gso_type &= ~SKB_GSO_TCPV6;
+ 			shinfo->gso_type |=  SKB_GSO_TCPV4;
+ 		}
+ 
+ 		/* Due to IPv4 header, MSS can be upgraded. */
+ 		skb_increase_gso_size(shinfo, len_diff);
+ 		/* Header must be checked, and gso_segs recomputed. */
+ 		shinfo->gso_type |= SKB_GSO_DODGY;
+ 		shinfo->gso_segs = 0;
+ 	}
+ 
+ 	skb->protocol = htons(ETH_P_IP);
+ 	skb_clear_hash(skb);
+ 
+ 	return 0;
+ }
+ 
+ static int bpf_skb_proto_xlat(struct sk_buff *skb, __be16 to_proto)
+ {
+ 	__be16 from_proto = skb->protocol;
+ 
+ 	if (from_proto == htons(ETH_P_IP) &&
+ 	      to_proto == htons(ETH_P_IPV6))
+ 		return bpf_skb_proto_4_to_6(skb);
+ 
+ 	if (from_proto == htons(ETH_P_IPV6) &&
+ 	      to_proto == htons(ETH_P_IP))
+ 		return bpf_skb_proto_6_to_4(skb);
+ 
+ 	return -ENOTSUPP;
+ }
+ 
+ BPF_CALL_3(bpf_skb_change_proto, struct sk_buff *, skb, __be16, proto,
+ 	   u64, flags)
+ {
+ 	int ret;
+ 
+ 	if (unlikely(flags))
+ 		return -EINVAL;
+ 
+ 	/* General idea is that this helper does the basic groundwork
+ 	 * needed for changing the protocol, and eBPF program fills the
+ 	 * rest through bpf_skb_store_bytes(), bpf_lX_csum_replace()
+ 	 * and other helpers, rather than passing a raw buffer here.
+ 	 *
+ 	 * The rationale is to keep this minimal and without a need to
+ 	 * deal with raw packet data. F.e. even if we would pass buffers
+ 	 * here, the program still needs to call the bpf_lX_csum_replace()
+ 	 * helpers anyway. Plus, this way we keep also separation of
+ 	 * concerns, since f.e. bpf_skb_store_bytes() should only take
+ 	 * care of stores.
+ 	 *
+ 	 * Currently, additional options and extension header space are
+ 	 * not supported, but flags register is reserved so we can adapt
+ 	 * that. For offloads, we mark packet as dodgy, so that headers
+ 	 * need to be verified first.
+ 	 */
+ 	ret = bpf_skb_proto_xlat(skb, proto);
+ 	bpf_compute_data_pointers(skb);
+ 	return ret;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_change_proto_proto = {
+ 	.func		= bpf_skb_change_proto,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_2(bpf_skb_change_type, struct sk_buff *, skb, u32, pkt_type)
+ {
+ 	/* We only allow a restricted subset to be changed for now. */
+ 	if (unlikely(!skb_pkt_type_ok(skb->pkt_type) ||
+ 		     !skb_pkt_type_ok(pkt_type)))
+ 		return -EINVAL;
+ 
+ 	skb->pkt_type = pkt_type;
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_change_type_proto = {
+ 	.func		= bpf_skb_change_type,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ };
+ 
+ static u32 bpf_skb_net_base_len(const struct sk_buff *skb)
+ {
+ 	switch (skb->protocol) {
+ 	case htons(ETH_P_IP):
+ 		return sizeof(struct iphdr);
+ 	case htons(ETH_P_IPV6):
+ 		return sizeof(struct ipv6hdr);
+ 	default:
+ 		return ~0U;
+ 	}
+ }
+ 
+ static int bpf_skb_net_grow(struct sk_buff *skb, u32 len_diff)
+ {
+ 	u32 off = skb_mac_header_len(skb) + bpf_skb_net_base_len(skb);
+ 	int ret;
+ 
+ 	/* SCTP uses GSO_BY_FRAGS, thus cannot adjust it. */
+ 	if (skb_is_gso(skb) && unlikely(skb_is_gso_sctp(skb)))
+ 		return -ENOTSUPP;
+ 
+ 	ret = skb_cow(skb, len_diff);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	ret = bpf_skb_net_hdr_push(skb, off, len_diff);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	if (skb_is_gso(skb)) {
+ 		struct skb_shared_info *shinfo = skb_shinfo(skb);
+ 
+ 		/* Due to header grow, MSS needs to be downgraded. */
+ 		skb_decrease_gso_size(shinfo, len_diff);
+ 		/* Header must be checked, and gso_segs recomputed. */
+ 		shinfo->gso_type |= SKB_GSO_DODGY;
+ 		shinfo->gso_segs = 0;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int bpf_skb_net_shrink(struct sk_buff *skb, u32 len_diff)
+ {
+ 	u32 off = skb_mac_header_len(skb) + bpf_skb_net_base_len(skb);
+ 	int ret;
+ 
+ 	/* SCTP uses GSO_BY_FRAGS, thus cannot adjust it. */
+ 	if (skb_is_gso(skb) && unlikely(skb_is_gso_sctp(skb)))
+ 		return -ENOTSUPP;
+ 
+ 	ret = skb_unclone(skb, GFP_ATOMIC);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	ret = bpf_skb_net_hdr_pop(skb, off, len_diff);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	if (skb_is_gso(skb)) {
+ 		struct skb_shared_info *shinfo = skb_shinfo(skb);
+ 
+ 		/* Due to header shrink, MSS can be upgraded. */
+ 		skb_increase_gso_size(shinfo, len_diff);
+ 		/* Header must be checked, and gso_segs recomputed. */
+ 		shinfo->gso_type |= SKB_GSO_DODGY;
+ 		shinfo->gso_segs = 0;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u32 __bpf_skb_max_len(const struct sk_buff *skb)
+ {
+ 	return skb->dev->mtu + skb->dev->hard_header_len;
+ }
+ 
+ static int bpf_skb_adjust_net(struct sk_buff *skb, s32 len_diff)
+ {
+ 	bool trans_same = skb->transport_header == skb->network_header;
+ 	u32 len_cur, len_diff_abs = abs(len_diff);
+ 	u32 len_min = bpf_skb_net_base_len(skb);
+ 	u32 len_max = __bpf_skb_max_len(skb);
+ 	__be16 proto = skb->protocol;
+ 	bool shrink = len_diff < 0;
+ 	int ret;
+ 
+ 	if (unlikely(len_diff_abs > 0xfffU))
+ 		return -EFAULT;
+ 	if (unlikely(proto != htons(ETH_P_IP) &&
+ 		     proto != htons(ETH_P_IPV6)))
+ 		return -ENOTSUPP;
+ 
+ 	len_cur = skb->len - skb_network_offset(skb);
+ 	if (skb_transport_header_was_set(skb) && !trans_same)
+ 		len_cur = skb_network_header_len(skb);
+ 	if ((shrink && (len_diff_abs >= len_cur ||
+ 			len_cur - len_diff_abs < len_min)) ||
+ 	    (!shrink && (skb->len + len_diff_abs > len_max &&
+ 			 !skb_is_gso(skb))))
+ 		return -ENOTSUPP;
+ 
+ 	ret = shrink ? bpf_skb_net_shrink(skb, len_diff_abs) :
+ 		       bpf_skb_net_grow(skb, len_diff_abs);
+ 
+ 	bpf_compute_data_pointers(skb);
+ 	return ret;
+ }
+ 
+ BPF_CALL_4(bpf_skb_adjust_room, struct sk_buff *, skb, s32, len_diff,
+ 	   u32, mode, u64, flags)
+ {
+ 	if (unlikely(flags))
+ 		return -EINVAL;
+ 	if (likely(mode == BPF_ADJ_ROOM_NET))
+ 		return bpf_skb_adjust_net(skb, len_diff);
+ 
+ 	return -ENOTSUPP;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_adjust_room_proto = {
+ 	.func		= bpf_skb_adjust_room,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ static u32 __bpf_skb_min_len(const struct sk_buff *skb)
+ {
+ 	u32 min_len = skb_network_offset(skb);
+ 
+ 	if (skb_transport_header_was_set(skb))
+ 		min_len = skb_transport_offset(skb);
+ 	if (skb->ip_summed == CHECKSUM_PARTIAL)
+ 		min_len = skb_checksum_start_offset(skb) +
+ 			  skb->csum_offset + sizeof(__sum16);
+ 	return min_len;
+ }
+ 
+ static int bpf_skb_grow_rcsum(struct sk_buff *skb, unsigned int new_len)
+ {
+ 	unsigned int old_len = skb->len;
+ 	int ret;
+ 
+ 	ret = __skb_grow_rcsum(skb, new_len);
+ 	if (!ret)
+ 		memset(skb->data + old_len, 0, new_len - old_len);
+ 	return ret;
+ }
+ 
+ static int bpf_skb_trim_rcsum(struct sk_buff *skb, unsigned int new_len)
+ {
+ 	return __skb_trim_rcsum(skb, new_len);
+ }
+ 
+ BPF_CALL_3(bpf_skb_change_tail, struct sk_buff *, skb, u32, new_len,
+ 	   u64, flags)
+ {
+ 	u32 max_len = __bpf_skb_max_len(skb);
+ 	u32 min_len = __bpf_skb_min_len(skb);
+ 	int ret;
+ 
+ 	if (unlikely(flags || new_len > max_len || new_len < min_len))
+ 		return -EINVAL;
+ 	if (skb->encapsulation)
+ 		return -ENOTSUPP;
+ 
+ 	/* The basic idea of this helper is that it's performing the
+ 	 * needed work to either grow or trim an skb, and eBPF program
+ 	 * rewrites the rest via helpers like bpf_skb_store_bytes(),
+ 	 * bpf_lX_csum_replace() and others rather than passing a raw
+ 	 * buffer here. This one is a slow path helper and intended
+ 	 * for replies with control messages.
+ 	 *
+ 	 * Like in bpf_skb_change_proto(), we want to keep this rather
+ 	 * minimal and without protocol specifics so that we are able
+ 	 * to separate concerns as in bpf_skb_store_bytes() should only
+ 	 * be the one responsible for writing buffers.
+ 	 *
+ 	 * It's really expected to be a slow path operation here for
+ 	 * control message replies, so we're implicitly linearizing,
+ 	 * uncloning and drop offloads from the skb by this.
+ 	 */
+ 	ret = __bpf_try_make_writable(skb, skb->len);
+ 	if (!ret) {
+ 		if (new_len > skb->len)
+ 			ret = bpf_skb_grow_rcsum(skb, new_len);
+ 		else if (new_len < skb->len)
+ 			ret = bpf_skb_trim_rcsum(skb, new_len);
+ 		if (!ret && skb_is_gso(skb))
+ 			skb_gso_reset(skb);
+ 	}
+ 
+ 	bpf_compute_data_pointers(skb);
+ 	return ret;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_change_tail_proto = {
+ 	.func		= bpf_skb_change_tail,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_3(bpf_skb_change_head, struct sk_buff *, skb, u32, head_room,
+ 	   u64, flags)
+ {
+ 	u32 max_len = __bpf_skb_max_len(skb);
+ 	u32 new_len = skb->len + head_room;
+ 	int ret;
+ 
+ 	if (unlikely(flags || (!skb_is_gso(skb) && new_len > max_len) ||
+ 		     new_len < skb->len))
+ 		return -EINVAL;
+ 
+ 	ret = skb_cow(skb, head_room);
+ 	if (likely(!ret)) {
+ 		/* Idea for this helper is that we currently only
+ 		 * allow to expand on mac header. This means that
+ 		 * skb->protocol network header, etc, stay as is.
+ 		 * Compared to bpf_skb_change_tail(), we're more
+ 		 * flexible due to not needing to linearize or
+ 		 * reset GSO. Intention for this helper is to be
+ 		 * used by an L3 skb that needs to push mac header
+ 		 * for redirection into L2 device.
+ 		 */
+ 		__skb_push(skb, head_room);
+ 		memset(skb->data, 0, head_room);
+ 		skb_reset_mac_header(skb);
+ 	}
+ 
+ 	bpf_compute_data_pointers(skb);
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_change_head_proto = {
+ 	.func		= bpf_skb_change_head,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ };
+ 
+ static unsigned long xdp_get_metalen(const struct xdp_buff *xdp)
+ {
+ 	return xdp_data_meta_unsupported(xdp) ? 0 :
+ 	       xdp->data - xdp->data_meta;
+ }
+ 
+ BPF_CALL_2(bpf_xdp_adjust_head, struct xdp_buff *, xdp, int, offset)
+ {
+ 	void *xdp_frame_end = xdp->data_hard_start + sizeof(struct xdp_frame);
+ 	unsigned long metalen = xdp_get_metalen(xdp);
+ 	void *data_start = xdp_frame_end + metalen;
+ 	void *data = xdp->data + offset;
+ 
+ 	if (unlikely(data < data_start ||
+ 		     data > xdp->data_end - ETH_HLEN))
+ 		return -EINVAL;
+ 
+ 	if (metalen)
+ 		memmove(xdp->data_meta + offset,
+ 			xdp->data_meta, metalen);
+ 	xdp->data_meta += offset;
+ 	xdp->data = data;
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_xdp_adjust_head_proto = {
+ 	.func		= bpf_xdp_adjust_head,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_2(bpf_xdp_adjust_tail, struct xdp_buff *, xdp, int, offset)
+ {
+ 	void *data_end = xdp->data_end + offset;
+ 
+ 	/* only shrinking is allowed for now. */
+ 	if (unlikely(offset >= 0))
+ 		return -EINVAL;
+ 
+ 	if (unlikely(data_end < xdp->data + ETH_HLEN))
+ 		return -EINVAL;
+ 
+ 	xdp->data_end = data_end;
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_xdp_adjust_tail_proto = {
+ 	.func		= bpf_xdp_adjust_tail,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_2(bpf_xdp_adjust_meta, struct xdp_buff *, xdp, int, offset)
+ {
+ 	void *xdp_frame_end = xdp->data_hard_start + sizeof(struct xdp_frame);
+ 	void *meta = xdp->data_meta + offset;
+ 	unsigned long metalen = xdp->data - meta;
+ 
+ 	if (xdp_data_meta_unsupported(xdp))
+ 		return -ENOTSUPP;
+ 	if (unlikely(meta < xdp_frame_end ||
+ 		     meta > xdp->data))
+ 		return -EINVAL;
+ 	if (unlikely((metalen & (sizeof(__u32) - 1)) ||
+ 		     (metalen > 32)))
+ 		return -EACCES;
+ 
+ 	xdp->data_meta = meta;
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_xdp_adjust_meta_proto = {
+ 	.func		= bpf_xdp_adjust_meta,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ };
+ 
+ static int __bpf_tx_xdp(struct net_device *dev,
+ 			struct bpf_map *map,
+ 			struct xdp_buff *xdp,
+ 			u32 index)
+ {
+ 	struct xdp_frame *xdpf;
+ 	int sent;
+ 
+ 	if (!dev->netdev_ops->ndo_xdp_xmit) {
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	xdpf = convert_to_xdp_frame(xdp);
+ 	if (unlikely(!xdpf))
+ 		return -EOVERFLOW;
+ 
+ 	sent = dev->netdev_ops->ndo_xdp_xmit(dev, 1, &xdpf);
+ 	if (sent <= 0)
+ 		return sent;
+ 	dev->netdev_ops->ndo_xdp_flush(dev);
+ 	return 0;
+ }
+ 
+ static int __bpf_tx_xdp_map(struct net_device *dev_rx, void *fwd,
+ 			    struct bpf_map *map,
+ 			    struct xdp_buff *xdp,
+ 			    u32 index)
+ {
+ 	int err;
+ 
+ 	switch (map->map_type) {
+ 	case BPF_MAP_TYPE_DEVMAP: {
+ 		struct bpf_dtab_netdev *dst = fwd;
+ 
+ 		err = dev_map_enqueue(dst, xdp, dev_rx);
+ 		if (err)
+ 			return err;
+ 		__dev_map_insert_ctx(map, index);
+ 		break;
+ 	}
+ 	case BPF_MAP_TYPE_CPUMAP: {
+ 		struct bpf_cpu_map_entry *rcpu = fwd;
+ 
+ 		err = cpu_map_enqueue(rcpu, xdp, dev_rx);
+ 		if (err)
+ 			return err;
+ 		__cpu_map_insert_ctx(map, index);
+ 		break;
+ 	}
+ 	case BPF_MAP_TYPE_XSKMAP: {
+ 		struct xdp_sock *xs = fwd;
+ 
+ 		err = __xsk_map_redirect(map, xdp, xs);
+ 		return err;
+ 	}
+ 	default:
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ void xdp_do_flush_map(void)
+ {
+ 	struct redirect_info *ri = this_cpu_ptr(&redirect_info);
+ 	struct bpf_map *map = ri->map_to_flush;
+ 
+ 	ri->map_to_flush = NULL;
+ 	if (map) {
+ 		switch (map->map_type) {
+ 		case BPF_MAP_TYPE_DEVMAP:
+ 			__dev_map_flush(map);
+ 			break;
+ 		case BPF_MAP_TYPE_CPUMAP:
+ 			__cpu_map_flush(map);
+ 			break;
+ 		case BPF_MAP_TYPE_XSKMAP:
+ 			__xsk_map_flush(map);
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(xdp_do_flush_map);
+ 
+ static void *__xdp_map_lookup_elem(struct bpf_map *map, u32 index)
+ {
+ 	switch (map->map_type) {
+ 	case BPF_MAP_TYPE_DEVMAP:
+ 		return __dev_map_lookup_elem(map, index);
+ 	case BPF_MAP_TYPE_CPUMAP:
+ 		return __cpu_map_lookup_elem(map, index);
+ 	case BPF_MAP_TYPE_XSKMAP:
+ 		return __xsk_map_lookup_elem(map, index);
+ 	default:
+ 		return NULL;
+ 	}
+ }
+ 
+ static inline bool xdp_map_invalid(const struct bpf_prog *xdp_prog,
+ 				   unsigned long aux)
+ {
+ 	return (unsigned long)xdp_prog->aux != aux;
+ }
+ 
+ static int xdp_do_redirect_map(struct net_device *dev, struct xdp_buff *xdp,
+ 			       struct bpf_prog *xdp_prog)
+ {
+ 	struct redirect_info *ri = this_cpu_ptr(&redirect_info);
+ 	unsigned long map_owner = ri->map_owner;
+ 	struct bpf_map *map = ri->map;
+ 	u32 index = ri->ifindex;
+ 	void *fwd = NULL;
+ 	int err;
+ 
+ 	ri->ifindex = 0;
+ 	ri->map = NULL;
+ 	ri->map_owner = 0;
+ 
+ 	if (unlikely(xdp_map_invalid(xdp_prog, map_owner))) {
+ 		err = -EFAULT;
+ 		map = NULL;
+ 		goto err;
+ 	}
+ 
+ 	fwd = __xdp_map_lookup_elem(map, index);
+ 	if (!fwd) {
+ 		err = -EINVAL;
+ 		goto err;
+ 	}
+ 	if (ri->map_to_flush && ri->map_to_flush != map)
+ 		xdp_do_flush_map();
+ 
+ 	err = __bpf_tx_xdp_map(dev, fwd, map, xdp, index);
+ 	if (unlikely(err))
+ 		goto err;
+ 
+ 	ri->map_to_flush = map;
+ 	_trace_xdp_redirect_map(dev, xdp_prog, fwd, map, index);
+ 	return 0;
+ err:
+ 	_trace_xdp_redirect_map_err(dev, xdp_prog, fwd, map, index, err);
+ 	return err;
+ }
+ 
+ int xdp_do_redirect(struct net_device *dev, struct xdp_buff *xdp,
+ 		    struct bpf_prog *xdp_prog)
+ {
+ 	struct redirect_info *ri = this_cpu_ptr(&redirect_info);
+ 	struct net_device *fwd;
+ 	u32 index = ri->ifindex;
+ 	int err;
+ 
+ 	if (ri->map)
+ 		return xdp_do_redirect_map(dev, xdp, xdp_prog);
+ 
+ 	fwd = dev_get_by_index_rcu(dev_net(dev), index);
+ 	ri->ifindex = 0;
+ 	if (unlikely(!fwd)) {
+ 		err = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	err = __bpf_tx_xdp(fwd, NULL, xdp, 0);
+ 	if (unlikely(err))
+ 		goto err;
+ 
+ 	_trace_xdp_redirect(dev, xdp_prog, index);
+ 	return 0;
+ err:
+ 	_trace_xdp_redirect_err(dev, xdp_prog, index, err);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(xdp_do_redirect);
+ 
+ static int __xdp_generic_ok_fwd_dev(struct sk_buff *skb, struct net_device *fwd)
+ {
+ 	unsigned int len;
+ 
+ 	if (unlikely(!(fwd->flags & IFF_UP)))
+ 		return -ENETDOWN;
+ 
+ 	len = fwd->mtu + fwd->hard_header_len + VLAN_HLEN;
+ 	if (skb->len > len)
+ 		return -EMSGSIZE;
+ 
+ 	return 0;
+ }
+ 
+ static int xdp_do_generic_redirect_map(struct net_device *dev,
+ 				       struct sk_buff *skb,
+ 				       struct xdp_buff *xdp,
+ 				       struct bpf_prog *xdp_prog)
+ {
+ 	struct redirect_info *ri = this_cpu_ptr(&redirect_info);
+ 	unsigned long map_owner = ri->map_owner;
+ 	struct bpf_map *map = ri->map;
+ 	u32 index = ri->ifindex;
+ 	void *fwd = NULL;
+ 	int err = 0;
+ 
+ 	ri->ifindex = 0;
+ 	ri->map = NULL;
+ 	ri->map_owner = 0;
+ 
+ 	if (unlikely(xdp_map_invalid(xdp_prog, map_owner))) {
+ 		err = -EFAULT;
+ 		map = NULL;
+ 		goto err;
+ 	}
+ 	fwd = __xdp_map_lookup_elem(map, index);
+ 	if (unlikely(!fwd)) {
+ 		err = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	if (map->map_type == BPF_MAP_TYPE_DEVMAP) {
+ 		if (unlikely((err = __xdp_generic_ok_fwd_dev(skb, fwd))))
+ 			goto err;
+ 		skb->dev = fwd;
+ 		generic_xdp_tx(skb, xdp_prog);
+ 	} else if (map->map_type == BPF_MAP_TYPE_XSKMAP) {
+ 		struct xdp_sock *xs = fwd;
+ 
+ 		err = xsk_generic_rcv(xs, xdp);
+ 		if (err)
+ 			goto err;
+ 		consume_skb(skb);
+ 	} else {
+ 		/* TODO: Handle BPF_MAP_TYPE_CPUMAP */
+ 		err = -EBADRQC;
+ 		goto err;
+ 	}
+ 
+ 	_trace_xdp_redirect_map(dev, xdp_prog, fwd, map, index);
+ 	return 0;
+ err:
+ 	_trace_xdp_redirect_map_err(dev, xdp_prog, fwd, map, index, err);
+ 	return err;
+ }
+ 
+ int xdp_do_generic_redirect(struct net_device *dev, struct sk_buff *skb,
+ 			    struct xdp_buff *xdp, struct bpf_prog *xdp_prog)
+ {
+ 	struct redirect_info *ri = this_cpu_ptr(&redirect_info);
+ 	u32 index = ri->ifindex;
+ 	struct net_device *fwd;
+ 	int err = 0;
+ 
+ 	if (ri->map)
+ 		return xdp_do_generic_redirect_map(dev, skb, xdp, xdp_prog);
+ 
+ 	ri->ifindex = 0;
+ 	fwd = dev_get_by_index_rcu(dev_net(dev), index);
+ 	if (unlikely(!fwd)) {
+ 		err = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	if (unlikely((err = __xdp_generic_ok_fwd_dev(skb, fwd))))
+ 		goto err;
+ 
+ 	skb->dev = fwd;
+ 	_trace_xdp_redirect(dev, xdp_prog, index);
+ 	generic_xdp_tx(skb, xdp_prog);
+ 	return 0;
+ err:
+ 	_trace_xdp_redirect_err(dev, xdp_prog, index, err);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(xdp_do_generic_redirect);
+ 
+ BPF_CALL_2(bpf_xdp_redirect, u32, ifindex, u64, flags)
+ {
+ 	struct redirect_info *ri = this_cpu_ptr(&redirect_info);
+ 
+ 	if (unlikely(flags))
+ 		return XDP_ABORTED;
+ 
+ 	ri->ifindex = ifindex;
+ 	ri->flags = flags;
+ 	ri->map = NULL;
+ 	ri->map_owner = 0;
+ 
+ 	return XDP_REDIRECT;
+ }
+ 
+ static const struct bpf_func_proto bpf_xdp_redirect_proto = {
+ 	.func           = bpf_xdp_redirect,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_ANYTHING,
+ 	.arg2_type      = ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_4(bpf_xdp_redirect_map, struct bpf_map *, map, u32, ifindex, u64, flags,
+ 	   unsigned long, map_owner)
+ {
+ 	struct redirect_info *ri = this_cpu_ptr(&redirect_info);
+ 
+ 	if (unlikely(flags))
+ 		return XDP_ABORTED;
+ 
+ 	ri->ifindex = ifindex;
+ 	ri->flags = flags;
+ 	ri->map = map;
+ 	ri->map_owner = map_owner;
+ 
+ 	return XDP_REDIRECT;
+ }
+ 
+ /* Note, arg4 is hidden from users and populated by the verifier
+  * with the right pointer.
+  */
+ static const struct bpf_func_proto bpf_xdp_redirect_map_proto = {
+ 	.func           = bpf_xdp_redirect_map,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_CONST_MAP_PTR,
+ 	.arg2_type      = ARG_ANYTHING,
+ 	.arg3_type      = ARG_ANYTHING,
+ };
+ 
+ static unsigned long bpf_skb_copy(void *dst_buff, const void *skb,
+ 				  unsigned long off, unsigned long len)
+ {
+ 	void *ptr = skb_header_pointer(skb, off, len, dst_buff);
+ 
+ 	if (unlikely(!ptr))
+ 		return len;
+ 	if (ptr != dst_buff)
+ 		memcpy(dst_buff, ptr, len);
+ 
+ 	return 0;
+ }
+ 
+ BPF_CALL_5(bpf_skb_event_output, struct sk_buff *, skb, struct bpf_map *, map,
+ 	   u64, flags, void *, meta, u64, meta_size)
+ {
+ 	u64 skb_size = (flags & BPF_F_CTXLEN_MASK) >> 32;
+ 
+ 	if (unlikely(flags & ~(BPF_F_CTXLEN_MASK | BPF_F_INDEX_MASK)))
+ 		return -EINVAL;
+ 	if (unlikely(skb_size > skb->len))
+ 		return -EFAULT;
+ 
+ 	return bpf_event_output(map, flags, meta, meta_size, skb, skb_size,
+ 				bpf_skb_copy);
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_event_output_proto = {
+ 	.func		= bpf_skb_event_output,
+ 	.gpl_only	= true,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_CONST_MAP_PTR,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_PTR_TO_MEM,
+ 	.arg5_type	= ARG_CONST_SIZE_OR_ZERO,
+ };
+ 
+ static unsigned short bpf_tunnel_key_af(u64 flags)
+ {
+ 	return flags & BPF_F_TUNINFO_IPV6 ? AF_INET6 : AF_INET;
+ }
+ 
+ BPF_CALL_4(bpf_skb_get_tunnel_key, struct sk_buff *, skb, struct bpf_tunnel_key *, to,
+ 	   u32, size, u64, flags)
+ {
+ 	const struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	u8 compat[sizeof(struct bpf_tunnel_key)];
+ 	void *to_orig = to;
+ 	int err;
+ 
+ 	if (unlikely(!info || (flags & ~(BPF_F_TUNINFO_IPV6)))) {
+ 		err = -EINVAL;
+ 		goto err_clear;
+ 	}
+ 	if (ip_tunnel_info_af(info) != bpf_tunnel_key_af(flags)) {
+ 		err = -EPROTO;
+ 		goto err_clear;
+ 	}
+ 	if (unlikely(size != sizeof(struct bpf_tunnel_key))) {
+ 		err = -EINVAL;
+ 		switch (size) {
+ 		case offsetof(struct bpf_tunnel_key, tunnel_label):
+ 		case offsetof(struct bpf_tunnel_key, tunnel_ext):
+ 			goto set_compat;
+ 		case offsetof(struct bpf_tunnel_key, remote_ipv6[1]):
+ 			/* Fixup deprecated structure layouts here, so we have
+ 			 * a common path later on.
+ 			 */
+ 			if (ip_tunnel_info_af(info) != AF_INET)
+ 				goto err_clear;
+ set_compat:
+ 			to = (struct bpf_tunnel_key *)compat;
+ 			break;
+ 		default:
+ 			goto err_clear;
+ 		}
+ 	}
+ 
+ 	to->tunnel_id = be64_to_cpu(info->key.tun_id);
+ 	to->tunnel_tos = info->key.tos;
+ 	to->tunnel_ttl = info->key.ttl;
+ 
+ 	if (flags & BPF_F_TUNINFO_IPV6) {
+ 		memcpy(to->remote_ipv6, &info->key.u.ipv6.src,
+ 		       sizeof(to->remote_ipv6));
+ 		to->tunnel_label = be32_to_cpu(info->key.label);
+ 	} else {
+ 		to->remote_ipv4 = be32_to_cpu(info->key.u.ipv4.src);
+ 	}
+ 
+ 	if (unlikely(size != sizeof(struct bpf_tunnel_key)))
+ 		memcpy(to_orig, to, size);
+ 
+ 	return 0;
+ err_clear:
+ 	memset(to_orig, 0, size);
+ 	return err;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_get_tunnel_key_proto = {
+ 	.func		= bpf_skb_get_tunnel_key,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_3(bpf_skb_get_tunnel_opt, struct sk_buff *, skb, u8 *, to, u32, size)
+ {
+ 	const struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	int err;
+ 
+ 	if (unlikely(!info ||
+ 		     !(info->key.tun_flags & TUNNEL_OPTIONS_PRESENT))) {
+ 		err = -ENOENT;
+ 		goto err_clear;
+ 	}
+ 	if (unlikely(size < info->options_len)) {
+ 		err = -ENOMEM;
+ 		goto err_clear;
+ 	}
+ 
+ 	ip_tunnel_info_opts_get(to, info);
+ 	if (size > info->options_len)
+ 		memset(to + info->options_len, 0, size - info->options_len);
+ 
+ 	return info->options_len;
+ err_clear:
+ 	memset(to, 0, size);
+ 	return err;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_get_tunnel_opt_proto = {
+ 	.func		= bpf_skb_get_tunnel_opt,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ static struct metadata_dst __percpu *md_dst;
+ 
+ BPF_CALL_4(bpf_skb_set_tunnel_key, struct sk_buff *, skb,
+ 	   const struct bpf_tunnel_key *, from, u32, size, u64, flags)
+ {
+ 	struct metadata_dst *md = this_cpu_ptr(md_dst);
+ 	u8 compat[sizeof(struct bpf_tunnel_key)];
+ 	struct ip_tunnel_info *info;
+ 
+ 	if (unlikely(flags & ~(BPF_F_TUNINFO_IPV6 | BPF_F_ZERO_CSUM_TX |
+ 			       BPF_F_DONT_FRAGMENT | BPF_F_SEQ_NUMBER)))
+ 		return -EINVAL;
+ 	if (unlikely(size != sizeof(struct bpf_tunnel_key))) {
+ 		switch (size) {
+ 		case offsetof(struct bpf_tunnel_key, tunnel_label):
+ 		case offsetof(struct bpf_tunnel_key, tunnel_ext):
+ 		case offsetof(struct bpf_tunnel_key, remote_ipv6[1]):
+ 			/* Fixup deprecated structure layouts here, so we have
+ 			 * a common path later on.
+ 			 */
+ 			memcpy(compat, from, size);
+ 			memset(compat + size, 0, sizeof(compat) - size);
+ 			from = (const struct bpf_tunnel_key *) compat;
+ 			break;
+ 		default:
+ 			return -EINVAL;
+ 		}
+ 	}
+ 	if (unlikely((!(flags & BPF_F_TUNINFO_IPV6) && from->tunnel_label) ||
+ 		     from->tunnel_ext))
+ 		return -EINVAL;
+ 
+ 	skb_dst_drop(skb);
+ 	dst_hold((struct dst_entry *) md);
+ 	skb_dst_set(skb, (struct dst_entry *) md);
+ 
+ 	info = &md->u.tun_info;
+ 	memset(info, 0, sizeof(*info));
+ 	info->mode = IP_TUNNEL_INFO_TX;
+ 
+ 	info->key.tun_flags = TUNNEL_KEY | TUNNEL_CSUM | TUNNEL_NOCACHE;
+ 	if (flags & BPF_F_DONT_FRAGMENT)
+ 		info->key.tun_flags |= TUNNEL_DONT_FRAGMENT;
+ 	if (flags & BPF_F_ZERO_CSUM_TX)
+ 		info->key.tun_flags &= ~TUNNEL_CSUM;
+ 	if (flags & BPF_F_SEQ_NUMBER)
+ 		info->key.tun_flags |= TUNNEL_SEQ;
+ 
+ 	info->key.tun_id = cpu_to_be64(from->tunnel_id);
+ 	info->key.tos = from->tunnel_tos;
+ 	info->key.ttl = from->tunnel_ttl;
+ 
+ 	if (flags & BPF_F_TUNINFO_IPV6) {
+ 		info->mode |= IP_TUNNEL_INFO_IPV6;
+ 		memcpy(&info->key.u.ipv6.dst, from->remote_ipv6,
+ 		       sizeof(from->remote_ipv6));
+ 		info->key.label = cpu_to_be32(from->tunnel_label) &
+ 				  IPV6_FLOWLABEL_MASK;
+ 	} else {
+ 		info->key.u.ipv4.dst = cpu_to_be32(from->remote_ipv4);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_set_tunnel_key_proto = {
+ 	.func		= bpf_skb_set_tunnel_key,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_3(bpf_skb_set_tunnel_opt, struct sk_buff *, skb,
+ 	   const u8 *, from, u32, size)
+ {
+ 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
+ 	const struct metadata_dst *md = this_cpu_ptr(md_dst);
+ 
+ 	if (unlikely(info != &md->u.tun_info || (size & (sizeof(u32) - 1))))
+ 		return -EINVAL;
+ 	if (unlikely(size > IP_TUNNEL_OPTS_MAX))
+ 		return -ENOMEM;
+ 
+ 	ip_tunnel_info_opts_set(info, from, size);
+ 
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_set_tunnel_opt_proto = {
+ 	.func		= bpf_skb_set_tunnel_opt,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ static const struct bpf_func_proto *
+ bpf_get_skb_set_tunnel_proto(enum bpf_func_id which)
+ {
+ 	if (!md_dst) {
+ 		struct metadata_dst __percpu *tmp;
+ 
+ 		tmp = metadata_dst_alloc_percpu(IP_TUNNEL_OPTS_MAX,
+ 						METADATA_IP_TUNNEL,
+ 						GFP_KERNEL);
+ 		if (!tmp)
+ 			return NULL;
+ 		if (cmpxchg(&md_dst, NULL, tmp))
+ 			metadata_dst_free_percpu(tmp);
+ 	}
+ 
+ 	switch (which) {
+ 	case BPF_FUNC_skb_set_tunnel_key:
+ 		return &bpf_skb_set_tunnel_key_proto;
+ 	case BPF_FUNC_skb_set_tunnel_opt:
+ 		return &bpf_skb_set_tunnel_opt_proto;
+ 	default:
+ 		return NULL;
+ 	}
+ }
+ 
+ BPF_CALL_3(bpf_skb_under_cgroup, struct sk_buff *, skb, struct bpf_map *, map,
+ 	   u32, idx)
+ {
+ 	struct bpf_array *array = container_of(map, struct bpf_array, map);
+ 	struct cgroup *cgrp;
+ 	struct sock *sk;
+ 
+ 	sk = skb_to_full_sk(skb);
+ 	if (!sk || !sk_fullsock(sk))
+ 		return -ENOENT;
+ 	if (unlikely(idx >= array->map.max_entries))
+ 		return -E2BIG;
+ 
+ 	cgrp = READ_ONCE(array->ptrs[idx]);
+ 	if (unlikely(!cgrp))
+ 		return -EAGAIN;
+ 
+ 	return sk_under_cgroup_hierarchy(sk, cgrp);
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_under_cgroup_proto = {
+ 	.func		= bpf_skb_under_cgroup,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_CONST_MAP_PTR,
+ 	.arg3_type	= ARG_ANYTHING,
+ };
+ 
+ static unsigned long bpf_xdp_copy(void *dst_buff, const void *src_buff,
+ 				  unsigned long off, unsigned long len)
+ {
+ 	memcpy(dst_buff, src_buff + off, len);
+ 	return 0;
+ }
+ 
+ BPF_CALL_5(bpf_xdp_event_output, struct xdp_buff *, xdp, struct bpf_map *, map,
+ 	   u64, flags, void *, meta, u64, meta_size)
+ {
+ 	u64 xdp_size = (flags & BPF_F_CTXLEN_MASK) >> 32;
+ 
+ 	if (unlikely(flags & ~(BPF_F_CTXLEN_MASK | BPF_F_INDEX_MASK)))
+ 		return -EINVAL;
+ 	if (unlikely(xdp_size > (unsigned long)(xdp->data_end - xdp->data)))
+ 		return -EFAULT;
+ 
+ 	return bpf_event_output(map, flags, meta, meta_size, xdp->data,
+ 				xdp_size, bpf_xdp_copy);
+ }
+ 
+ static const struct bpf_func_proto bpf_xdp_event_output_proto = {
+ 	.func		= bpf_xdp_event_output,
+ 	.gpl_only	= true,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_CONST_MAP_PTR,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_PTR_TO_MEM,
+ 	.arg5_type	= ARG_CONST_SIZE_OR_ZERO,
+ };
+ 
+ BPF_CALL_1(bpf_get_socket_cookie, struct sk_buff *, skb)
+ {
+ 	return skb->sk ? sock_gen_cookie(skb->sk) : 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_get_socket_cookie_proto = {
+ 	.func           = bpf_get_socket_cookie,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ };
+ 
+ BPF_CALL_1(bpf_get_socket_uid, struct sk_buff *, skb)
+ {
+ 	struct sock *sk = sk_to_full_sk(skb->sk);
+ 	kuid_t kuid;
+ 
+ 	if (!sk || !sk_fullsock(sk))
+ 		return overflowuid;
+ 	kuid = sock_net_uid(sock_net(sk), sk);
+ 	return from_kuid_munged(sock_net(sk)->user_ns, kuid);
+ }
+ 
+ static const struct bpf_func_proto bpf_get_socket_uid_proto = {
+ 	.func           = bpf_get_socket_uid,
+ 	.gpl_only       = false,
+ 	.ret_type       = RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ };
+ 
+ BPF_CALL_5(bpf_setsockopt, struct bpf_sock_ops_kern *, bpf_sock,
+ 	   int, level, int, optname, char *, optval, int, optlen)
+ {
+ 	struct sock *sk = bpf_sock->sk;
+ 	int ret = 0;
+ 	int val;
+ 
+ 	if (!sk_fullsock(sk))
+ 		return -EINVAL;
+ 
+ 	if (level == SOL_SOCKET) {
+ 		if (optlen != sizeof(int))
+ 			return -EINVAL;
+ 		val = *((int *)optval);
+ 
+ 		/* Only some socketops are supported */
+ 		switch (optname) {
+ 		case SO_RCVBUF:
+ 			sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
+ 			sk->sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);
+ 			break;
+ 		case SO_SNDBUF:
+ 			sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
+ 			sk->sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);
+ 			break;
+ 		case SO_MAX_PACING_RATE:
+ 			sk->sk_max_pacing_rate = val;
+ 			sk->sk_pacing_rate = min(sk->sk_pacing_rate,
+ 						 sk->sk_max_pacing_rate);
+ 			break;
+ 		case SO_PRIORITY:
+ 			sk->sk_priority = val;
+ 			break;
+ 		case SO_RCVLOWAT:
+ 			if (val < 0)
+ 				val = INT_MAX;
+ 			sk->sk_rcvlowat = val ? : 1;
+ 			break;
+ 		case SO_MARK:
+ 			sk->sk_mark = val;
+ 			break;
+ 		default:
+ 			ret = -EINVAL;
+ 		}
+ #ifdef CONFIG_INET
+ 	} else if (level == SOL_IP) {
+ 		if (optlen != sizeof(int) || sk->sk_family != AF_INET)
+ 			return -EINVAL;
+ 
+ 		val = *((int *)optval);
+ 		/* Only some options are supported */
+ 		switch (optname) {
+ 		case IP_TOS:
+ 			if (val < -1 || val > 0xff) {
+ 				ret = -EINVAL;
+ 			} else {
+ 				struct inet_sock *inet = inet_sk(sk);
+ 
+ 				if (val == -1)
+ 					val = 0;
+ 				inet->tos = val;
+ 			}
+ 			break;
+ 		default:
+ 			ret = -EINVAL;
+ 		}
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	} else if (level == SOL_IPV6) {
+ 		if (optlen != sizeof(int) || sk->sk_family != AF_INET6)
+ 			return -EINVAL;
+ 
+ 		val = *((int *)optval);
+ 		/* Only some options are supported */
+ 		switch (optname) {
+ 		case IPV6_TCLASS:
+ 			if (val < -1 || val > 0xff) {
+ 				ret = -EINVAL;
+ 			} else {
+ 				struct ipv6_pinfo *np = inet6_sk(sk);
+ 
+ 				if (val == -1)
+ 					val = 0;
+ 				np->tclass = val;
+ 			}
+ 			break;
+ 		default:
+ 			ret = -EINVAL;
+ 		}
+ #endif
+ 	} else if (level == SOL_TCP &&
+ 		   sk->sk_prot->setsockopt == tcp_setsockopt) {
+ 		if (optname == TCP_CONGESTION) {
+ 			char name[TCP_CA_NAME_MAX];
+ 			bool reinit = bpf_sock->op > BPF_SOCK_OPS_NEEDS_ECN;
+ 
+ 			strncpy(name, optval, min_t(long, optlen,
+ 						    TCP_CA_NAME_MAX-1));
+ 			name[TCP_CA_NAME_MAX-1] = 0;
+ 			ret = tcp_set_congestion_control(sk, name, false,
+ 							 reinit);
+ 		} else {
+ 			struct tcp_sock *tp = tcp_sk(sk);
+ 
+ 			if (optlen != sizeof(int))
+ 				return -EINVAL;
+ 
+ 			val = *((int *)optval);
+ 			/* Only some options are supported */
+ 			switch (optname) {
+ 			case TCP_BPF_IW:
+ 				if (val <= 0 || tp->data_segs_out > 0)
+ 					ret = -EINVAL;
+ 				else
+ 					tp->snd_cwnd = val;
+ 				break;
+ 			case TCP_BPF_SNDCWND_CLAMP:
+ 				if (val <= 0) {
+ 					ret = -EINVAL;
+ 				} else {
+ 					tp->snd_cwnd_clamp = val;
+ 					tp->snd_ssthresh = val;
+ 				}
+ 				break;
+ 			default:
+ 				ret = -EINVAL;
+ 			}
+ 		}
+ #endif
+ 	} else {
+ 		ret = -EINVAL;
+ 	}
+ 	return ret;
+ }
+ 
+ static const struct bpf_func_proto bpf_setsockopt_proto = {
+ 	.func		= bpf_setsockopt,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_PTR_TO_MEM,
+ 	.arg5_type	= ARG_CONST_SIZE,
+ };
+ 
+ BPF_CALL_5(bpf_getsockopt, struct bpf_sock_ops_kern *, bpf_sock,
+ 	   int, level, int, optname, char *, optval, int, optlen)
+ {
+ 	struct sock *sk = bpf_sock->sk;
+ 
+ 	if (!sk_fullsock(sk))
+ 		goto err_clear;
+ 
+ #ifdef CONFIG_INET
+ 	if (level == SOL_TCP && sk->sk_prot->getsockopt == tcp_getsockopt) {
+ 		if (optname == TCP_CONGESTION) {
+ 			struct inet_connection_sock *icsk = inet_csk(sk);
+ 
+ 			if (!icsk->icsk_ca_ops || optlen <= 1)
+ 				goto err_clear;
+ 			strncpy(optval, icsk->icsk_ca_ops->name, optlen);
+ 			optval[optlen - 1] = 0;
+ 		} else {
+ 			goto err_clear;
+ 		}
+ 	} else if (level == SOL_IP) {
+ 		struct inet_sock *inet = inet_sk(sk);
+ 
+ 		if (optlen != sizeof(int) || sk->sk_family != AF_INET)
+ 			goto err_clear;
+ 
+ 		/* Only some options are supported */
+ 		switch (optname) {
+ 		case IP_TOS:
+ 			*((int *)optval) = (int)inet->tos;
+ 			break;
+ 		default:
+ 			goto err_clear;
+ 		}
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	} else if (level == SOL_IPV6) {
+ 		struct ipv6_pinfo *np = inet6_sk(sk);
+ 
+ 		if (optlen != sizeof(int) || sk->sk_family != AF_INET6)
+ 			goto err_clear;
+ 
+ 		/* Only some options are supported */
+ 		switch (optname) {
+ 		case IPV6_TCLASS:
+ 			*((int *)optval) = (int)np->tclass;
+ 			break;
+ 		default:
+ 			goto err_clear;
+ 		}
+ #endif
+ 	} else {
+ 		goto err_clear;
+ 	}
+ 	return 0;
+ #endif
+ err_clear:
+ 	memset(optval, 0, optlen);
+ 	return -EINVAL;
+ }
+ 
+ static const struct bpf_func_proto bpf_getsockopt_proto = {
+ 	.func		= bpf_getsockopt,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg5_type	= ARG_CONST_SIZE,
+ };
+ 
+ BPF_CALL_2(bpf_sock_ops_cb_flags_set, struct bpf_sock_ops_kern *, bpf_sock,
+ 	   int, argval)
+ {
+ 	struct sock *sk = bpf_sock->sk;
+ 	int val = argval & BPF_SOCK_OPS_ALL_CB_FLAGS;
+ 
+ 	if (!IS_ENABLED(CONFIG_INET) || !sk_fullsock(sk))
+ 		return -EINVAL;
+ 
+ 	if (val)
+ 		tcp_sk(sk)->bpf_sock_ops_cb_flags = val;
+ 
+ 	return argval & (~BPF_SOCK_OPS_ALL_CB_FLAGS);
+ }
+ 
+ static const struct bpf_func_proto bpf_sock_ops_cb_flags_set_proto = {
+ 	.func		= bpf_sock_ops_cb_flags_set,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ };
+ 
+ const struct ipv6_bpf_stub *ipv6_bpf_stub __read_mostly;
+ EXPORT_SYMBOL_GPL(ipv6_bpf_stub);
+ 
+ BPF_CALL_3(bpf_bind, struct bpf_sock_addr_kern *, ctx, struct sockaddr *, addr,
+ 	   int, addr_len)
+ {
+ #ifdef CONFIG_INET
+ 	struct sock *sk = ctx->sk;
+ 	int err;
+ 
+ 	/* Binding to port can be expensive so it's prohibited in the helper.
+ 	 * Only binding to IP is supported.
+ 	 */
+ 	err = -EINVAL;
+ 	if (addr->sa_family == AF_INET) {
+ 		if (addr_len < sizeof(struct sockaddr_in))
+ 			return err;
+ 		if (((struct sockaddr_in *)addr)->sin_port != htons(0))
+ 			return err;
+ 		return __inet_bind(sk, addr, addr_len, true, false);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	} else if (addr->sa_family == AF_INET6) {
+ 		if (addr_len < SIN6_LEN_RFC2133)
+ 			return err;
+ 		if (((struct sockaddr_in6 *)addr)->sin6_port != htons(0))
+ 			return err;
+ 		/* ipv6_bpf_stub cannot be NULL, since it's called from
+ 		 * bpf_cgroup_inet6_connect hook and ipv6 is already loaded
+ 		 */
+ 		return ipv6_bpf_stub->inet6_bind(sk, addr, addr_len, true, false);
+ #endif /* CONFIG_IPV6 */
+ 	}
+ #endif /* CONFIG_INET */
+ 
+ 	return -EAFNOSUPPORT;
+ }
+ 
+ static const struct bpf_func_proto bpf_bind_proto = {
+ 	.func		= bpf_bind,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_PTR_TO_MEM,
+ 	.arg3_type	= ARG_CONST_SIZE,
+ };
+ 
+ #ifdef CONFIG_XFRM
+ BPF_CALL_5(bpf_skb_get_xfrm_state, struct sk_buff *, skb, u32, index,
+ 	   struct bpf_xfrm_state *, to, u32, size, u64, flags)
+ {
+ 	const struct sec_path *sp = skb_sec_path(skb);
+ 	const struct xfrm_state *x;
+ 
+ 	if (!sp || unlikely(index >= sp->len || flags))
+ 		goto err_clear;
+ 
+ 	x = sp->xvec[index];
+ 
+ 	if (unlikely(size != sizeof(struct bpf_xfrm_state)))
+ 		goto err_clear;
+ 
+ 	to->reqid = x->props.reqid;
+ 	to->spi = x->id.spi;
+ 	to->family = x->props.family;
+ 	if (to->family == AF_INET6) {
+ 		memcpy(to->remote_ipv6, x->props.saddr.a6,
+ 		       sizeof(to->remote_ipv6));
+ 	} else {
+ 		to->remote_ipv4 = x->props.saddr.a4;
+ 	}
+ 
+ 	return 0;
+ err_clear:
+ 	memset(to, 0, size);
+ 	return -EINVAL;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_get_xfrm_state_proto = {
+ 	.func		= bpf_skb_get_xfrm_state,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_PTR_TO_UNINIT_MEM,
+ 	.arg4_type	= ARG_CONST_SIZE,
+ 	.arg5_type	= ARG_ANYTHING,
+ };
+ #endif
+ 
+ #if IS_ENABLED(CONFIG_INET) || IS_ENABLED(CONFIG_IPV6)
+ static int bpf_fib_set_fwd_params(struct bpf_fib_lookup *params,
+ 				  const struct neighbour *neigh,
+ 				  const struct net_device *dev)
+ {
+ 	memcpy(params->dmac, neigh->ha, ETH_ALEN);
+ 	memcpy(params->smac, dev->dev_addr, ETH_ALEN);
+ 	params->h_vlan_TCI = 0;
+ 	params->h_vlan_proto = 0;
+ 
+ 	return dev->ifindex;
+ }
+ #endif
+ 
+ #if IS_ENABLED(CONFIG_INET)
+ static int bpf_ipv4_fib_lookup(struct net *net, struct bpf_fib_lookup *params,
+ 			       u32 flags, bool check_mtu)
+ {
+ 	struct in_device *in_dev;
+ 	struct neighbour *neigh;
+ 	struct net_device *dev;
+ 	struct fib_result res;
+ 	struct fib_nh *nh;
+ 	struct flowi4 fl4;
+ 	int err;
+ 	u32 mtu;
+ 
+ 	dev = dev_get_by_index_rcu(net, params->ifindex);
+ 	if (unlikely(!dev))
+ 		return -ENODEV;
+ 
+ 	/* verify forwarding is enabled on this interface */
+ 	in_dev = __in_dev_get_rcu(dev);
+ 	if (unlikely(!in_dev || !IN_DEV_FORWARD(in_dev)))
+ 		return 0;
+ 
+ 	if (flags & BPF_FIB_LOOKUP_OUTPUT) {
+ 		fl4.flowi4_iif = 1;
+ 		fl4.flowi4_oif = params->ifindex;
+ 	} else {
+ 		fl4.flowi4_iif = params->ifindex;
+ 		fl4.flowi4_oif = 0;
+ 	}
+ 	fl4.flowi4_tos = params->tos & IPTOS_RT_MASK;
+ 	fl4.flowi4_scope = RT_SCOPE_UNIVERSE;
+ 	fl4.flowi4_flags = 0;
+ 
+ 	fl4.flowi4_proto = params->l4_protocol;
+ 	fl4.daddr = params->ipv4_dst;
+ 	fl4.saddr = params->ipv4_src;
+ 	fl4.fl4_sport = params->sport;
+ 	fl4.fl4_dport = params->dport;
+ 
+ 	if (flags & BPF_FIB_LOOKUP_DIRECT) {
+ 		u32 tbid = l3mdev_fib_table_rcu(dev) ? : RT_TABLE_MAIN;
+ 		struct fib_table *tb;
+ 
+ 		tb = fib_get_table(net, tbid);
+ 		if (unlikely(!tb))
+ 			return 0;
+ 
+ 		err = fib_table_lookup(tb, &fl4, &res, FIB_LOOKUP_NOREF);
+ 	} else {
+ 		fl4.flowi4_mark = 0;
+ 		fl4.flowi4_secid = 0;
+ 		fl4.flowi4_tun_key.tun_id = 0;
+ 		fl4.flowi4_uid = sock_net_uid(net, NULL);
+ 
+ 		err = fib_lookup(net, &fl4, &res, FIB_LOOKUP_NOREF);
+ 	}
+ 
+ 	if (err || res.type != RTN_UNICAST)
+ 		return 0;
+ 
+ 	if (res.fi->fib_nhs > 1)
+ 		fib_select_path(net, &res, &fl4, NULL);
+ 
+ 	if (check_mtu) {
+ 		mtu = ip_mtu_from_fib_result(&res, params->ipv4_dst);
+ 		if (params->tot_len > mtu)
+ 			return 0;
+ 	}
+ 
+ 	nh = &res.fi->fib_nh[res.nh_sel];
+ 
+ 	/* do not handle lwt encaps right now */
+ 	if (nh->nh_lwtstate)
+ 		return 0;
+ 
+ 	dev = nh->nh_dev;
+ 	if (unlikely(!dev))
+ 		return 0;
+ 
+ 	if (nh->nh_gw)
+ 		params->ipv4_dst = nh->nh_gw;
+ 
+ 	params->rt_metric = res.fi->fib_priority;
+ 
+ 	/* xdp and cls_bpf programs are run in RCU-bh so
+ 	 * rcu_read_lock_bh is not needed here
+ 	 */
+ 	neigh = __ipv4_neigh_lookup_noref(dev, (__force u32)params->ipv4_dst);
+ 	if (neigh)
+ 		return bpf_fib_set_fwd_params(params, neigh, dev);
+ 
+ 	return 0;
+ }
+ #endif
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static int bpf_ipv6_fib_lookup(struct net *net, struct bpf_fib_lookup *params,
+ 			       u32 flags, bool check_mtu)
+ {
+ 	struct in6_addr *src = (struct in6_addr *) params->ipv6_src;
+ 	struct in6_addr *dst = (struct in6_addr *) params->ipv6_dst;
+ 	struct neighbour *neigh;
+ 	struct net_device *dev;
+ 	struct inet6_dev *idev;
+ 	struct fib6_info *f6i;
+ 	struct flowi6 fl6;
+ 	int strict = 0;
+ 	int oif;
+ 	u32 mtu;
+ 
+ 	/* link local addresses are never forwarded */
+ 	if (rt6_need_strict(dst) || rt6_need_strict(src))
+ 		return 0;
+ 
+ 	dev = dev_get_by_index_rcu(net, params->ifindex);
+ 	if (unlikely(!dev))
+ 		return -ENODEV;
+ 
+ 	idev = __in6_dev_get_safely(dev);
+ 	if (unlikely(!idev || !net->ipv6.devconf_all->forwarding))
+ 		return 0;
+ 
+ 	if (flags & BPF_FIB_LOOKUP_OUTPUT) {
+ 		fl6.flowi6_iif = 1;
+ 		oif = fl6.flowi6_oif = params->ifindex;
+ 	} else {
+ 		oif = fl6.flowi6_iif = params->ifindex;
+ 		fl6.flowi6_oif = 0;
+ 		strict = RT6_LOOKUP_F_HAS_SADDR;
+ 	}
+ 	fl6.flowlabel = params->flowlabel;
+ 	fl6.flowi6_scope = 0;
+ 	fl6.flowi6_flags = 0;
+ 	fl6.mp_hash = 0;
+ 
+ 	fl6.flowi6_proto = params->l4_protocol;
+ 	fl6.daddr = *dst;
+ 	fl6.saddr = *src;
+ 	fl6.fl6_sport = params->sport;
+ 	fl6.fl6_dport = params->dport;
+ 
+ 	if (flags & BPF_FIB_LOOKUP_DIRECT) {
+ 		u32 tbid = l3mdev_fib_table_rcu(dev) ? : RT_TABLE_MAIN;
+ 		struct fib6_table *tb;
+ 
+ 		tb = ipv6_stub->fib6_get_table(net, tbid);
+ 		if (unlikely(!tb))
+ 			return 0;
+ 
+ 		f6i = ipv6_stub->fib6_table_lookup(net, tb, oif, &fl6, strict);
+ 	} else {
+ 		fl6.flowi6_mark = 0;
+ 		fl6.flowi6_secid = 0;
+ 		fl6.flowi6_tun_key.tun_id = 0;
+ 		fl6.flowi6_uid = sock_net_uid(net, NULL);
+ 
+ 		f6i = ipv6_stub->fib6_lookup(net, oif, &fl6, strict);
+ 	}
+ 
+ 	if (unlikely(IS_ERR_OR_NULL(f6i) || f6i == net->ipv6.fib6_null_entry))
+ 		return 0;
+ 
+ 	if (unlikely(f6i->fib6_flags & RTF_REJECT ||
+ 	    f6i->fib6_type != RTN_UNICAST))
+ 		return 0;
+ 
+ 	if (f6i->fib6_nsiblings && fl6.flowi6_oif == 0)
+ 		f6i = ipv6_stub->fib6_multipath_select(net, f6i, &fl6,
+ 						       fl6.flowi6_oif, NULL,
+ 						       strict);
+ 
+ 	if (check_mtu) {
+ 		mtu = ipv6_stub->ip6_mtu_from_fib6(f6i, dst, src);
+ 		if (params->tot_len > mtu)
+ 			return 0;
+ 	}
+ 
+ 	if (f6i->fib6_nh.nh_lwtstate)
+ 		return 0;
+ 
+ 	if (f6i->fib6_flags & RTF_GATEWAY)
+ 		*dst = f6i->fib6_nh.nh_gw;
+ 
+ 	dev = f6i->fib6_nh.nh_dev;
+ 	params->rt_metric = f6i->fib6_metric;
+ 
+ 	/* xdp and cls_bpf programs are run in RCU-bh so rcu_read_lock_bh is
+ 	 * not needed here. Can not use __ipv6_neigh_lookup_noref here
+ 	 * because we need to get nd_tbl via the stub
+ 	 */
+ 	neigh = ___neigh_lookup_noref(ipv6_stub->nd_tbl, neigh_key_eq128,
+ 				      ndisc_hashfn, dst, dev);
+ 	if (neigh)
+ 		return bpf_fib_set_fwd_params(params, neigh, dev);
+ 
+ 	return 0;
+ }
+ #endif
+ 
+ BPF_CALL_4(bpf_xdp_fib_lookup, struct xdp_buff *, ctx,
+ 	   struct bpf_fib_lookup *, params, int, plen, u32, flags)
+ {
+ 	if (plen < sizeof(*params))
+ 		return -EINVAL;
+ 
+ 	switch (params->family) {
+ #if IS_ENABLED(CONFIG_INET)
+ 	case AF_INET:
+ 		return bpf_ipv4_fib_lookup(dev_net(ctx->rxq->dev), params,
+ 					   flags, true);
+ #endif
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case AF_INET6:
+ 		return bpf_ipv6_fib_lookup(dev_net(ctx->rxq->dev), params,
+ 					   flags, true);
+ #endif
+ 	}
+ 	return 0;
+ }
+ 
+ static const struct bpf_func_proto bpf_xdp_fib_lookup_proto = {
+ 	.func		= bpf_xdp_fib_lookup,
+ 	.gpl_only	= true,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ 	.arg2_type      = ARG_PTR_TO_MEM,
+ 	.arg3_type      = ARG_CONST_SIZE,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ BPF_CALL_4(bpf_skb_fib_lookup, struct sk_buff *, skb,
+ 	   struct bpf_fib_lookup *, params, int, plen, u32, flags)
+ {
+ 	struct net *net = dev_net(skb->dev);
+ 	int index = 0;
+ 
+ 	if (plen < sizeof(*params))
+ 		return -EINVAL;
+ 
+ 	switch (params->family) {
+ #if IS_ENABLED(CONFIG_INET)
+ 	case AF_INET:
+ 		index = bpf_ipv4_fib_lookup(net, params, flags, false);
+ 		break;
+ #endif
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case AF_INET6:
+ 		index = bpf_ipv6_fib_lookup(net, params, flags, false);
+ 		break;
+ #endif
+ 	}
+ 
+ 	if (index > 0) {
+ 		struct net_device *dev;
+ 
+ 		dev = dev_get_by_index_rcu(net, index);
+ 		if (!is_skb_forwardable(dev, skb))
+ 			index = 0;
+ 	}
+ 
+ 	return index;
+ }
+ 
+ static const struct bpf_func_proto bpf_skb_fib_lookup_proto = {
+ 	.func		= bpf_skb_fib_lookup,
+ 	.gpl_only	= true,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type      = ARG_PTR_TO_CTX,
+ 	.arg2_type      = ARG_PTR_TO_MEM,
+ 	.arg3_type      = ARG_CONST_SIZE,
+ 	.arg4_type	= ARG_ANYTHING,
+ };
+ 
+ #if IS_ENABLED(CONFIG_IPV6_SEG6_BPF)
+ static int bpf_push_seg6_encap(struct sk_buff *skb, u32 type, void *hdr, u32 len)
+ {
+ 	int err;
+ 	struct ipv6_sr_hdr *srh = (struct ipv6_sr_hdr *)hdr;
+ 
+ 	if (!seg6_validate_srh(srh, len))
+ 		return -EINVAL;
+ 
+ 	switch (type) {
+ 	case BPF_LWT_ENCAP_SEG6_INLINE:
+ 		if (skb->protocol != htons(ETH_P_IPV6))
+ 			return -EBADMSG;
+ 
+ 		err = seg6_do_srh_inline(skb, srh);
+ 		break;
+ 	case BPF_LWT_ENCAP_SEG6:
+ 		skb_reset_inner_headers(skb);
+ 		skb->encapsulation = 1;
+ 		err = seg6_do_srh_encap(skb, srh, IPPROTO_IPV6);
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	bpf_compute_data_pointers(skb);
+ 	if (err)
+ 		return err;
+ 
+ 	ipv6_hdr(skb)->payload_len = htons(skb->len - sizeof(struct ipv6hdr));
+ 	skb_set_transport_header(skb, sizeof(struct ipv6hdr));
+ 
+ 	return seg6_lookup_nexthop(skb, NULL, 0);
+ }
+ #endif /* CONFIG_IPV6_SEG6_BPF */
+ 
+ BPF_CALL_4(bpf_lwt_push_encap, struct sk_buff *, skb, u32, type, void *, hdr,
+ 	   u32, len)
+ {
+ 	switch (type) {
+ #if IS_ENABLED(CONFIG_IPV6_SEG6_BPF)
+ 	case BPF_LWT_ENCAP_SEG6:
+ 	case BPF_LWT_ENCAP_SEG6_INLINE:
+ 		return bpf_push_seg6_encap(skb, type, hdr, len);
+ #endif
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ static const struct bpf_func_proto bpf_lwt_push_encap_proto = {
+ 	.func		= bpf_lwt_push_encap,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_PTR_TO_MEM,
+ 	.arg4_type	= ARG_CONST_SIZE
+ };
+ 
+ BPF_CALL_4(bpf_lwt_seg6_store_bytes, struct sk_buff *, skb, u32, offset,
+ 	   const void *, from, u32, len)
+ {
+ #if IS_ENABLED(CONFIG_IPV6_SEG6_BPF)
+ 	struct seg6_bpf_srh_state *srh_state =
+ 		this_cpu_ptr(&seg6_bpf_srh_states);
+ 	void *srh_tlvs, *srh_end, *ptr;
+ 	struct ipv6_sr_hdr *srh;
+ 	int srhoff = 0;
+ 
+ 	if (ipv6_find_hdr(skb, &srhoff, IPPROTO_ROUTING, NULL, NULL) < 0)
+ 		return -EINVAL;
+ 
+ 	srh = (struct ipv6_sr_hdr *)(skb->data + srhoff);
+ 	srh_tlvs = (void *)((char *)srh + ((srh->first_segment + 1) << 4));
+ 	srh_end = (void *)((char *)srh + sizeof(*srh) + srh_state->hdrlen);
+ 
+ 	ptr = skb->data + offset;
+ 	if (ptr >= srh_tlvs && ptr + len <= srh_end)
+ 		srh_state->valid = 0;
+ 	else if (ptr < (void *)&srh->flags ||
+ 		 ptr + len > (void *)&srh->segments)
+ 		return -EFAULT;
+ 
+ 	if (unlikely(bpf_try_make_writable(skb, offset + len)))
+ 		return -EFAULT;
+ 
+ 	memcpy(skb->data + offset, from, len);
+ 	return 0;
+ #else /* CONFIG_IPV6_SEG6_BPF */
+ 	return -EOPNOTSUPP;
+ #endif
+ }
+ 
+ static const struct bpf_func_proto bpf_lwt_seg6_store_bytes_proto = {
+ 	.func		= bpf_lwt_seg6_store_bytes,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_PTR_TO_MEM,
+ 	.arg4_type	= ARG_CONST_SIZE
+ };
+ 
+ BPF_CALL_4(bpf_lwt_seg6_action, struct sk_buff *, skb,
+ 	   u32, action, void *, param, u32, param_len)
+ {
+ #if IS_ENABLED(CONFIG_IPV6_SEG6_BPF)
+ 	struct seg6_bpf_srh_state *srh_state =
+ 		this_cpu_ptr(&seg6_bpf_srh_states);
+ 	struct ipv6_sr_hdr *srh;
+ 	int srhoff = 0;
+ 	int err;
+ 
+ 	if (ipv6_find_hdr(skb, &srhoff, IPPROTO_ROUTING, NULL, NULL) < 0)
+ 		return -EINVAL;
+ 	srh = (struct ipv6_sr_hdr *)(skb->data + srhoff);
+ 
+ 	if (!srh_state->valid) {
+ 		if (unlikely((srh_state->hdrlen & 7) != 0))
+ 			return -EBADMSG;
+ 
+ 		srh->hdrlen = (u8)(srh_state->hdrlen >> 3);
+ 		if (unlikely(!seg6_validate_srh(srh, (srh->hdrlen + 1) << 3)))
+ 			return -EBADMSG;
+ 
+ 		srh_state->valid = 1;
+ 	}
+ 
+ 	switch (action) {
+ 	case SEG6_LOCAL_ACTION_END_X:
+ 		if (param_len != sizeof(struct in6_addr))
+ 			return -EINVAL;
+ 		return seg6_lookup_nexthop(skb, (struct in6_addr *)param, 0);
+ 	case SEG6_LOCAL_ACTION_END_T:
+ 		if (param_len != sizeof(int))
+ 			return -EINVAL;
+ 		return seg6_lookup_nexthop(skb, NULL, *(int *)param);
+ 	case SEG6_LOCAL_ACTION_END_B6:
+ 		err = bpf_push_seg6_encap(skb, BPF_LWT_ENCAP_SEG6_INLINE,
+ 					  param, param_len);
+ 		if (!err)
+ 			srh_state->hdrlen =
+ 				((struct ipv6_sr_hdr *)param)->hdrlen << 3;
+ 		return err;
+ 	case SEG6_LOCAL_ACTION_END_B6_ENCAP:
+ 		err = bpf_push_seg6_encap(skb, BPF_LWT_ENCAP_SEG6,
+ 					  param, param_len);
+ 		if (!err)
+ 			srh_state->hdrlen =
+ 				((struct ipv6_sr_hdr *)param)->hdrlen << 3;
+ 		return err;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ #else /* CONFIG_IPV6_SEG6_BPF */
+ 	return -EOPNOTSUPP;
+ #endif
+ }
+ 
+ static const struct bpf_func_proto bpf_lwt_seg6_action_proto = {
+ 	.func		= bpf_lwt_seg6_action,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_PTR_TO_MEM,
+ 	.arg4_type	= ARG_CONST_SIZE
+ };
+ 
+ BPF_CALL_3(bpf_lwt_seg6_adjust_srh, struct sk_buff *, skb, u32, offset,
+ 	   s32, len)
+ {
+ #if IS_ENABLED(CONFIG_IPV6_SEG6_BPF)
+ 	struct seg6_bpf_srh_state *srh_state =
+ 		this_cpu_ptr(&seg6_bpf_srh_states);
+ 	void *srh_end, *srh_tlvs, *ptr;
+ 	struct ipv6_sr_hdr *srh;
+ 	struct ipv6hdr *hdr;
+ 	int srhoff = 0;
+ 	int ret;
+ 
+ 	if (ipv6_find_hdr(skb, &srhoff, IPPROTO_ROUTING, NULL, NULL) < 0)
+ 		return -EINVAL;
+ 	srh = (struct ipv6_sr_hdr *)(skb->data + srhoff);
+ 
+ 	srh_tlvs = (void *)((unsigned char *)srh + sizeof(*srh) +
+ 			((srh->first_segment + 1) << 4));
+ 	srh_end = (void *)((unsigned char *)srh + sizeof(*srh) +
+ 			srh_state->hdrlen);
+ 	ptr = skb->data + offset;
+ 
+ 	if (unlikely(ptr < srh_tlvs || ptr > srh_end))
+ 		return -EFAULT;
+ 	if (unlikely(len < 0 && (void *)((char *)ptr - len) > srh_end))
+ 		return -EFAULT;
+ 
+ 	if (len > 0) {
+ 		ret = skb_cow_head(skb, len);
+ 		if (unlikely(ret < 0))
+ 			return ret;
+ 
+ 		ret = bpf_skb_net_hdr_push(skb, offset, len);
+ 	} else {
+ 		ret = bpf_skb_net_hdr_pop(skb, offset, -1 * len);
+ 	}
+ 
+ 	bpf_compute_data_pointers(skb);
+ 	if (unlikely(ret < 0))
+ 		return ret;
+ 
+ 	hdr = (struct ipv6hdr *)skb->data;
+ 	hdr->payload_len = htons(skb->len - sizeof(struct ipv6hdr));
+ 
+ 	srh_state->hdrlen += len;
+ 	srh_state->valid = 0;
+ 	return 0;
+ #else /* CONFIG_IPV6_SEG6_BPF */
+ 	return -EOPNOTSUPP;
+ #endif
+ }
+ 
+ static const struct bpf_func_proto bpf_lwt_seg6_adjust_srh_proto = {
+ 	.func		= bpf_lwt_seg6_adjust_srh,
+ 	.gpl_only	= false,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_CTX,
+ 	.arg2_type	= ARG_ANYTHING,
+ 	.arg3_type	= ARG_ANYTHING,
+ };
+ 
+ bool bpf_helper_changes_pkt_data(void *func)
+ {
+ 	if (func == bpf_skb_vlan_push ||
+ 	    func == bpf_skb_vlan_pop ||
+ 	    func == bpf_skb_store_bytes ||
+ 	    func == bpf_skb_change_proto ||
+ 	    func == bpf_skb_change_head ||
+ 	    func == bpf_skb_change_tail ||
+ 	    func == bpf_skb_adjust_room ||
+ 	    func == bpf_skb_pull_data ||
+ 	    func == bpf_clone_redirect ||
+ 	    func == bpf_l3_csum_replace ||
+ 	    func == bpf_l4_csum_replace ||
+ 	    func == bpf_xdp_adjust_head ||
+ 	    func == bpf_xdp_adjust_meta ||
+ 	    func == bpf_msg_pull_data ||
+ 	    func == bpf_xdp_adjust_tail ||
+ 	    func == bpf_lwt_push_encap ||
+ 	    func == bpf_lwt_seg6_store_bytes ||
+ 	    func == bpf_lwt_seg6_adjust_srh ||
+ 	    func == bpf_lwt_seg6_action
+ 	    )
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static const struct bpf_func_proto *
+ bpf_base_func_proto(enum bpf_func_id func_id)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_map_lookup_elem:
+ 		return &bpf_map_lookup_elem_proto;
+ 	case BPF_FUNC_map_update_elem:
+ 		return &bpf_map_update_elem_proto;
+ 	case BPF_FUNC_map_delete_elem:
+ 		return &bpf_map_delete_elem_proto;
+ 	case BPF_FUNC_get_prandom_u32:
+ 		return &bpf_get_prandom_u32_proto;
+ 	case BPF_FUNC_get_smp_processor_id:
+ 		return &bpf_get_raw_smp_processor_id_proto;
+ 	case BPF_FUNC_get_numa_node_id:
+ 		return &bpf_get_numa_node_id_proto;
+ 	case BPF_FUNC_tail_call:
+ 		return &bpf_tail_call_proto;
+ 	case BPF_FUNC_ktime_get_ns:
+ 		return &bpf_ktime_get_ns_proto;
+ 	case BPF_FUNC_trace_printk:
+ 		if (capable(CAP_SYS_ADMIN))
+ 			return bpf_get_trace_printk_proto();
+ 	default:
+ 		return NULL;
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ sock_filter_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	/* inet and inet6 sockets are created in a process
+ 	 * context so there is always a valid uid/gid
+ 	 */
+ 	case BPF_FUNC_get_current_uid_gid:
+ 		return &bpf_get_current_uid_gid_proto;
+ 	default:
+ 		return bpf_base_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ sock_addr_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	/* inet and inet6 sockets are created in a process
+ 	 * context so there is always a valid uid/gid
+ 	 */
+ 	case BPF_FUNC_get_current_uid_gid:
+ 		return &bpf_get_current_uid_gid_proto;
+ 	case BPF_FUNC_bind:
+ 		switch (prog->expected_attach_type) {
+ 		case BPF_CGROUP_INET4_CONNECT:
+ 		case BPF_CGROUP_INET6_CONNECT:
+ 			return &bpf_bind_proto;
+ 		default:
+ 			return NULL;
+ 		}
+ 	default:
+ 		return bpf_base_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ sk_filter_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_skb_load_bytes:
+ 		return &bpf_skb_load_bytes_proto;
+ 	case BPF_FUNC_skb_load_bytes_relative:
+ 		return &bpf_skb_load_bytes_relative_proto;
+ 	case BPF_FUNC_get_socket_cookie:
+ 		return &bpf_get_socket_cookie_proto;
+ 	case BPF_FUNC_get_socket_uid:
+ 		return &bpf_get_socket_uid_proto;
+ 	default:
+ 		return bpf_base_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ tc_cls_act_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_skb_store_bytes:
+ 		return &bpf_skb_store_bytes_proto;
+ 	case BPF_FUNC_skb_load_bytes:
+ 		return &bpf_skb_load_bytes_proto;
+ 	case BPF_FUNC_skb_load_bytes_relative:
+ 		return &bpf_skb_load_bytes_relative_proto;
+ 	case BPF_FUNC_skb_pull_data:
+ 		return &bpf_skb_pull_data_proto;
+ 	case BPF_FUNC_csum_diff:
+ 		return &bpf_csum_diff_proto;
+ 	case BPF_FUNC_csum_update:
+ 		return &bpf_csum_update_proto;
+ 	case BPF_FUNC_l3_csum_replace:
+ 		return &bpf_l3_csum_replace_proto;
+ 	case BPF_FUNC_l4_csum_replace:
+ 		return &bpf_l4_csum_replace_proto;
+ 	case BPF_FUNC_clone_redirect:
+ 		return &bpf_clone_redirect_proto;
+ 	case BPF_FUNC_get_cgroup_classid:
+ 		return &bpf_get_cgroup_classid_proto;
+ 	case BPF_FUNC_skb_vlan_push:
+ 		return &bpf_skb_vlan_push_proto;
+ 	case BPF_FUNC_skb_vlan_pop:
+ 		return &bpf_skb_vlan_pop_proto;
+ 	case BPF_FUNC_skb_change_proto:
+ 		return &bpf_skb_change_proto_proto;
+ 	case BPF_FUNC_skb_change_type:
+ 		return &bpf_skb_change_type_proto;
+ 	case BPF_FUNC_skb_adjust_room:
+ 		return &bpf_skb_adjust_room_proto;
+ 	case BPF_FUNC_skb_change_tail:
+ 		return &bpf_skb_change_tail_proto;
+ 	case BPF_FUNC_skb_get_tunnel_key:
+ 		return &bpf_skb_get_tunnel_key_proto;
+ 	case BPF_FUNC_skb_set_tunnel_key:
+ 		return bpf_get_skb_set_tunnel_proto(func_id);
+ 	case BPF_FUNC_skb_get_tunnel_opt:
+ 		return &bpf_skb_get_tunnel_opt_proto;
+ 	case BPF_FUNC_skb_set_tunnel_opt:
+ 		return bpf_get_skb_set_tunnel_proto(func_id);
+ 	case BPF_FUNC_redirect:
+ 		return &bpf_redirect_proto;
+ 	case BPF_FUNC_get_route_realm:
+ 		return &bpf_get_route_realm_proto;
+ 	case BPF_FUNC_get_hash_recalc:
+ 		return &bpf_get_hash_recalc_proto;
+ 	case BPF_FUNC_set_hash_invalid:
+ 		return &bpf_set_hash_invalid_proto;
+ 	case BPF_FUNC_set_hash:
+ 		return &bpf_set_hash_proto;
+ 	case BPF_FUNC_perf_event_output:
+ 		return &bpf_skb_event_output_proto;
+ 	case BPF_FUNC_get_smp_processor_id:
+ 		return &bpf_get_smp_processor_id_proto;
+ 	case BPF_FUNC_skb_under_cgroup:
+ 		return &bpf_skb_under_cgroup_proto;
+ 	case BPF_FUNC_get_socket_cookie:
+ 		return &bpf_get_socket_cookie_proto;
+ 	case BPF_FUNC_get_socket_uid:
+ 		return &bpf_get_socket_uid_proto;
+ #ifdef CONFIG_XFRM
+ 	case BPF_FUNC_skb_get_xfrm_state:
+ 		return &bpf_skb_get_xfrm_state_proto;
+ #endif
+ 	case BPF_FUNC_fib_lookup:
+ 		return &bpf_skb_fib_lookup_proto;
+ 	default:
+ 		return bpf_base_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ xdp_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_perf_event_output:
+ 		return &bpf_xdp_event_output_proto;
+ 	case BPF_FUNC_get_smp_processor_id:
+ 		return &bpf_get_smp_processor_id_proto;
+ 	case BPF_FUNC_csum_diff:
+ 		return &bpf_csum_diff_proto;
+ 	case BPF_FUNC_xdp_adjust_head:
+ 		return &bpf_xdp_adjust_head_proto;
+ 	case BPF_FUNC_xdp_adjust_meta:
+ 		return &bpf_xdp_adjust_meta_proto;
+ 	case BPF_FUNC_redirect:
+ 		return &bpf_xdp_redirect_proto;
+ 	case BPF_FUNC_redirect_map:
+ 		return &bpf_xdp_redirect_map_proto;
+ 	case BPF_FUNC_xdp_adjust_tail:
+ 		return &bpf_xdp_adjust_tail_proto;
+ 	case BPF_FUNC_fib_lookup:
+ 		return &bpf_xdp_fib_lookup_proto;
+ 	default:
+ 		return bpf_base_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ sock_ops_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_setsockopt:
+ 		return &bpf_setsockopt_proto;
+ 	case BPF_FUNC_getsockopt:
+ 		return &bpf_getsockopt_proto;
+ 	case BPF_FUNC_sock_ops_cb_flags_set:
+ 		return &bpf_sock_ops_cb_flags_set_proto;
+ 	case BPF_FUNC_sock_map_update:
+ 		return &bpf_sock_map_update_proto;
+ 	case BPF_FUNC_sock_hash_update:
+ 		return &bpf_sock_hash_update_proto;
+ 	default:
+ 		return bpf_base_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ sk_msg_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_msg_redirect_map:
+ 		return &bpf_msg_redirect_map_proto;
+ 	case BPF_FUNC_msg_redirect_hash:
+ 		return &bpf_msg_redirect_hash_proto;
+ 	case BPF_FUNC_msg_apply_bytes:
+ 		return &bpf_msg_apply_bytes_proto;
+ 	case BPF_FUNC_msg_cork_bytes:
+ 		return &bpf_msg_cork_bytes_proto;
+ 	case BPF_FUNC_msg_pull_data:
+ 		return &bpf_msg_pull_data_proto;
+ 	default:
+ 		return bpf_base_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ sk_skb_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_skb_store_bytes:
+ 		return &bpf_skb_store_bytes_proto;
+ 	case BPF_FUNC_skb_load_bytes:
+ 		return &bpf_skb_load_bytes_proto;
+ 	case BPF_FUNC_skb_pull_data:
+ 		return &bpf_skb_pull_data_proto;
+ 	case BPF_FUNC_skb_change_tail:
+ 		return &bpf_skb_change_tail_proto;
+ 	case BPF_FUNC_skb_change_head:
+ 		return &bpf_skb_change_head_proto;
+ 	case BPF_FUNC_get_socket_cookie:
+ 		return &bpf_get_socket_cookie_proto;
+ 	case BPF_FUNC_get_socket_uid:
+ 		return &bpf_get_socket_uid_proto;
+ 	case BPF_FUNC_sk_redirect_map:
+ 		return &bpf_sk_redirect_map_proto;
+ 	case BPF_FUNC_sk_redirect_hash:
+ 		return &bpf_sk_redirect_hash_proto;
+ 	default:
+ 		return bpf_base_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ lwt_out_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_skb_load_bytes:
+ 		return &bpf_skb_load_bytes_proto;
+ 	case BPF_FUNC_skb_pull_data:
+ 		return &bpf_skb_pull_data_proto;
+ 	case BPF_FUNC_csum_diff:
+ 		return &bpf_csum_diff_proto;
+ 	case BPF_FUNC_get_cgroup_classid:
+ 		return &bpf_get_cgroup_classid_proto;
+ 	case BPF_FUNC_get_route_realm:
+ 		return &bpf_get_route_realm_proto;
+ 	case BPF_FUNC_get_hash_recalc:
+ 		return &bpf_get_hash_recalc_proto;
+ 	case BPF_FUNC_perf_event_output:
+ 		return &bpf_skb_event_output_proto;
+ 	case BPF_FUNC_get_smp_processor_id:
+ 		return &bpf_get_smp_processor_id_proto;
+ 	case BPF_FUNC_skb_under_cgroup:
+ 		return &bpf_skb_under_cgroup_proto;
+ 	default:
+ 		return bpf_base_func_proto(func_id);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ lwt_in_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_lwt_push_encap:
+ 		return &bpf_lwt_push_encap_proto;
+ 	default:
+ 		return lwt_out_func_proto(func_id, prog);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ lwt_xmit_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_skb_get_tunnel_key:
+ 		return &bpf_skb_get_tunnel_key_proto;
+ 	case BPF_FUNC_skb_set_tunnel_key:
+ 		return bpf_get_skb_set_tunnel_proto(func_id);
+ 	case BPF_FUNC_skb_get_tunnel_opt:
+ 		return &bpf_skb_get_tunnel_opt_proto;
+ 	case BPF_FUNC_skb_set_tunnel_opt:
+ 		return bpf_get_skb_set_tunnel_proto(func_id);
+ 	case BPF_FUNC_redirect:
+ 		return &bpf_redirect_proto;
+ 	case BPF_FUNC_clone_redirect:
+ 		return &bpf_clone_redirect_proto;
+ 	case BPF_FUNC_skb_change_tail:
+ 		return &bpf_skb_change_tail_proto;
+ 	case BPF_FUNC_skb_change_head:
+ 		return &bpf_skb_change_head_proto;
+ 	case BPF_FUNC_skb_store_bytes:
+ 		return &bpf_skb_store_bytes_proto;
+ 	case BPF_FUNC_csum_update:
+ 		return &bpf_csum_update_proto;
+ 	case BPF_FUNC_l3_csum_replace:
+ 		return &bpf_l3_csum_replace_proto;
+ 	case BPF_FUNC_l4_csum_replace:
+ 		return &bpf_l4_csum_replace_proto;
+ 	case BPF_FUNC_set_hash_invalid:
+ 		return &bpf_set_hash_invalid_proto;
+ 	default:
+ 		return lwt_out_func_proto(func_id, prog);
+ 	}
+ }
+ 
+ static const struct bpf_func_proto *
+ lwt_seg6local_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)
+ {
+ 	switch (func_id) {
+ 	case BPF_FUNC_lwt_seg6_store_bytes:
+ 		return &bpf_lwt_seg6_store_bytes_proto;
+ 	case BPF_FUNC_lwt_seg6_action:
+ 		return &bpf_lwt_seg6_action_proto;
+ 	case BPF_FUNC_lwt_seg6_adjust_srh:
+ 		return &bpf_lwt_seg6_adjust_srh_proto;
+ 	default:
+ 		return lwt_out_func_proto(func_id, prog);
+ 	}
+ }
+ 
+ static bool bpf_skb_is_valid_access(int off, int size, enum bpf_access_type type,
+ 				    const struct bpf_prog *prog,
+ 				    struct bpf_insn_access_aux *info)
+ {
+ 	const int size_default = sizeof(__u32);
+ 
+ 	if (off < 0 || off >= sizeof(struct __sk_buff))
+ 		return false;
+ 
+ 	/* The verifier guarantees that size > 0. */
+ 	if (off % size != 0)
+ 		return false;
+ 
+ 	switch (off) {
+ 	case bpf_ctx_range_till(struct __sk_buff, cb[0], cb[4]):
+ 		if (off + size > offsetofend(struct __sk_buff, cb[4]))
+ 			return false;
+ 		break;
+ 	case bpf_ctx_range_till(struct __sk_buff, remote_ip6[0], remote_ip6[3]):
+ 	case bpf_ctx_range_till(struct __sk_buff, local_ip6[0], local_ip6[3]):
+ 	case bpf_ctx_range_till(struct __sk_buff, remote_ip4, remote_ip4):
+ 	case bpf_ctx_range_till(struct __sk_buff, local_ip4, local_ip4):
+ 	case bpf_ctx_range(struct __sk_buff, data):
+ 	case bpf_ctx_range(struct __sk_buff, data_meta):
+ 	case bpf_ctx_range(struct __sk_buff, data_end):
+ 		if (size != size_default)
+ 			return false;
+ 		break;
+ 	default:
+ 		/* Only narrow read access allowed for now. */
+ 		if (type == BPF_WRITE) {
+ 			if (size != size_default)
+ 				return false;
+ 		} else {
+ 			bpf_ctx_record_field_size(info, size_default);
+ 			if (!bpf_ctx_narrow_access_ok(off, size, size_default))
+ 				return false;
+ 		}
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static bool sk_filter_is_valid_access(int off, int size,
+ 				      enum bpf_access_type type,
+ 				      const struct bpf_prog *prog,
+ 				      struct bpf_insn_access_aux *info)
+ {
+ 	switch (off) {
+ 	case bpf_ctx_range(struct __sk_buff, tc_classid):
+ 	case bpf_ctx_range(struct __sk_buff, data):
+ 	case bpf_ctx_range(struct __sk_buff, data_meta):
+ 	case bpf_ctx_range(struct __sk_buff, data_end):
+ 	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
+ 		return false;
+ 	}
+ 
+ 	if (type == BPF_WRITE) {
+ 		switch (off) {
+ 		case bpf_ctx_range_till(struct __sk_buff, cb[0], cb[4]):
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 	}
+ 
+ 	return bpf_skb_is_valid_access(off, size, type, prog, info);
+ }
+ 
+ static bool lwt_is_valid_access(int off, int size,
+ 				enum bpf_access_type type,
+ 				const struct bpf_prog *prog,
+ 				struct bpf_insn_access_aux *info)
+ {
+ 	switch (off) {
+ 	case bpf_ctx_range(struct __sk_buff, tc_classid):
+ 	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
+ 	case bpf_ctx_range(struct __sk_buff, data_meta):
+ 		return false;
+ 	}
+ 
+ 	if (type == BPF_WRITE) {
+ 		switch (off) {
+ 		case bpf_ctx_range(struct __sk_buff, mark):
+ 		case bpf_ctx_range(struct __sk_buff, priority):
+ 		case bpf_ctx_range_till(struct __sk_buff, cb[0], cb[4]):
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 	}
+ 
+ 	switch (off) {
+ 	case bpf_ctx_range(struct __sk_buff, data):
+ 		info->reg_type = PTR_TO_PACKET;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, data_end):
+ 		info->reg_type = PTR_TO_PACKET_END;
+ 		break;
+ 	}
+ 
+ 	return bpf_skb_is_valid_access(off, size, type, prog, info);
+ }
+ 
+ /* Attach type specific accesses */
+ static bool __sock_filter_check_attach_type(int off,
+ 					    enum bpf_access_type access_type,
+ 					    enum bpf_attach_type attach_type)
+ {
+ 	switch (off) {
+ 	case offsetof(struct bpf_sock, bound_dev_if):
+ 	case offsetof(struct bpf_sock, mark):
+ 	case offsetof(struct bpf_sock, priority):
+ 		switch (attach_type) {
+ 		case BPF_CGROUP_INET_SOCK_CREATE:
+ 			goto full_access;
+ 		default:
+ 			return false;
+ 		}
+ 	case bpf_ctx_range(struct bpf_sock, src_ip4):
+ 		switch (attach_type) {
+ 		case BPF_CGROUP_INET4_POST_BIND:
+ 			goto read_only;
+ 		default:
+ 			return false;
+ 		}
+ 	case bpf_ctx_range_till(struct bpf_sock, src_ip6[0], src_ip6[3]):
+ 		switch (attach_type) {
+ 		case BPF_CGROUP_INET6_POST_BIND:
+ 			goto read_only;
+ 		default:
+ 			return false;
+ 		}
+ 	case bpf_ctx_range(struct bpf_sock, src_port):
+ 		switch (attach_type) {
+ 		case BPF_CGROUP_INET4_POST_BIND:
+ 		case BPF_CGROUP_INET6_POST_BIND:
+ 			goto read_only;
+ 		default:
+ 			return false;
+ 		}
+ 	}
+ read_only:
+ 	return access_type == BPF_READ;
+ full_access:
+ 	return true;
+ }
+ 
+ static bool __sock_filter_check_size(int off, int size,
+ 				     struct bpf_insn_access_aux *info)
+ {
+ 	const int size_default = sizeof(__u32);
+ 
+ 	switch (off) {
+ 	case bpf_ctx_range(struct bpf_sock, src_ip4):
+ 	case bpf_ctx_range_till(struct bpf_sock, src_ip6[0], src_ip6[3]):
+ 		bpf_ctx_record_field_size(info, size_default);
+ 		return bpf_ctx_narrow_access_ok(off, size, size_default);
+ 	}
+ 
+ 	return size == size_default;
+ }
+ 
+ static bool sock_filter_is_valid_access(int off, int size,
+ 					enum bpf_access_type type,
+ 					const struct bpf_prog *prog,
+ 					struct bpf_insn_access_aux *info)
+ {
+ 	if (off < 0 || off >= sizeof(struct bpf_sock))
+ 		return false;
+ 	if (off % size != 0)
+ 		return false;
+ 	if (!__sock_filter_check_attach_type(off, type,
+ 					     prog->expected_attach_type))
+ 		return false;
+ 	if (!__sock_filter_check_size(off, size, info))
+ 		return false;
+ 	return true;
+ }
+ 
+ static int bpf_unclone_prologue(struct bpf_insn *insn_buf, bool direct_write,
+ 				const struct bpf_prog *prog, int drop_verdict)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	if (!direct_write)
+ 		return 0;
+ 
+ 	/* if (!skb->cloned)
+ 	 *       goto start;
+ 	 *
+ 	 * (Fast-path, otherwise approximation that we might be
+ 	 *  a clone, do the rest in helper.)
+ 	 */
+ 	*insn++ = BPF_LDX_MEM(BPF_B, BPF_REG_6, BPF_REG_1, CLONED_OFFSET());
+ 	*insn++ = BPF_ALU32_IMM(BPF_AND, BPF_REG_6, CLONED_MASK);
+ 	*insn++ = BPF_JMP_IMM(BPF_JEQ, BPF_REG_6, 0, 7);
+ 
+ 	/* ret = bpf_skb_pull_data(skb, 0); */
+ 	*insn++ = BPF_MOV64_REG(BPF_REG_6, BPF_REG_1);
+ 	*insn++ = BPF_ALU64_REG(BPF_XOR, BPF_REG_2, BPF_REG_2);
+ 	*insn++ = BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0,
+ 			       BPF_FUNC_skb_pull_data);
+ 	/* if (!ret)
+ 	 *      goto restore;
+ 	 * return TC_ACT_SHOT;
+ 	 */
+ 	*insn++ = BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2);
+ 	*insn++ = BPF_ALU32_IMM(BPF_MOV, BPF_REG_0, drop_verdict);
+ 	*insn++ = BPF_EXIT_INSN();
+ 
+ 	/* restore: */
+ 	*insn++ = BPF_MOV64_REG(BPF_REG_1, BPF_REG_6);
+ 	/* start: */
+ 	*insn++ = prog->insnsi[0];
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ static int bpf_gen_ld_abs(const struct bpf_insn *orig,
+ 			  struct bpf_insn *insn_buf)
+ {
+ 	bool indirect = BPF_MODE(orig->code) == BPF_IND;
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	/* We're guaranteed here that CTX is in R6. */
+ 	*insn++ = BPF_MOV64_REG(BPF_REG_1, BPF_REG_CTX);
+ 	if (!indirect) {
+ 		*insn++ = BPF_MOV64_IMM(BPF_REG_2, orig->imm);
+ 	} else {
+ 		*insn++ = BPF_MOV64_REG(BPF_REG_2, orig->src_reg);
+ 		if (orig->imm)
+ 			*insn++ = BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, orig->imm);
+ 	}
+ 
+ 	switch (BPF_SIZE(orig->code)) {
+ 	case BPF_B:
+ 		*insn++ = BPF_EMIT_CALL(bpf_skb_load_helper_8_no_cache);
+ 		break;
+ 	case BPF_H:
+ 		*insn++ = BPF_EMIT_CALL(bpf_skb_load_helper_16_no_cache);
+ 		break;
+ 	case BPF_W:
+ 		*insn++ = BPF_EMIT_CALL(bpf_skb_load_helper_32_no_cache);
+ 		break;
+ 	}
+ 
+ 	*insn++ = BPF_JMP_IMM(BPF_JSGE, BPF_REG_0, 0, 2);
+ 	*insn++ = BPF_ALU32_REG(BPF_XOR, BPF_REG_0, BPF_REG_0);
+ 	*insn++ = BPF_EXIT_INSN();
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ static int tc_cls_act_prologue(struct bpf_insn *insn_buf, bool direct_write,
+ 			       const struct bpf_prog *prog)
+ {
+ 	return bpf_unclone_prologue(insn_buf, direct_write, prog, TC_ACT_SHOT);
+ }
+ 
+ static bool tc_cls_act_is_valid_access(int off, int size,
+ 				       enum bpf_access_type type,
+ 				       const struct bpf_prog *prog,
+ 				       struct bpf_insn_access_aux *info)
+ {
+ 	if (type == BPF_WRITE) {
+ 		switch (off) {
+ 		case bpf_ctx_range(struct __sk_buff, mark):
+ 		case bpf_ctx_range(struct __sk_buff, tc_index):
+ 		case bpf_ctx_range(struct __sk_buff, priority):
+ 		case bpf_ctx_range(struct __sk_buff, tc_classid):
+ 		case bpf_ctx_range_till(struct __sk_buff, cb[0], cb[4]):
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 	}
+ 
+ 	switch (off) {
+ 	case bpf_ctx_range(struct __sk_buff, data):
+ 		info->reg_type = PTR_TO_PACKET;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, data_meta):
+ 		info->reg_type = PTR_TO_PACKET_META;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, data_end):
+ 		info->reg_type = PTR_TO_PACKET_END;
+ 		break;
+ 	case bpf_ctx_range_till(struct __sk_buff, family, local_port):
+ 		return false;
+ 	}
+ 
+ 	return bpf_skb_is_valid_access(off, size, type, prog, info);
+ }
+ 
+ static bool __is_valid_xdp_access(int off, int size)
+ {
+ 	if (off < 0 || off >= sizeof(struct xdp_md))
+ 		return false;
+ 	if (off % size != 0)
+ 		return false;
+ 	if (size != sizeof(__u32))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static bool xdp_is_valid_access(int off, int size,
+ 				enum bpf_access_type type,
+ 				const struct bpf_prog *prog,
+ 				struct bpf_insn_access_aux *info)
+ {
+ 	if (type == BPF_WRITE) {
+ 		if (bpf_prog_is_dev_bound(prog->aux)) {
+ 			switch (off) {
+ 			case offsetof(struct xdp_md, rx_queue_index):
+ 				return __is_valid_xdp_access(off, size);
+ 			}
+ 		}
+ 		return false;
+ 	}
+ 
+ 	switch (off) {
+ 	case offsetof(struct xdp_md, data):
+ 		info->reg_type = PTR_TO_PACKET;
+ 		break;
+ 	case offsetof(struct xdp_md, data_meta):
+ 		info->reg_type = PTR_TO_PACKET_META;
+ 		break;
+ 	case offsetof(struct xdp_md, data_end):
+ 		info->reg_type = PTR_TO_PACKET_END;
+ 		break;
+ 	}
+ 
+ 	return __is_valid_xdp_access(off, size);
+ }
+ 
+ void bpf_warn_invalid_xdp_action(u32 act)
+ {
+ 	const u32 act_max = XDP_REDIRECT;
+ 
+ 	WARN_ONCE(1, "%s XDP return value %u, expect packet loss!\n",
+ 		  act > act_max ? "Illegal" : "Driver unsupported",
+ 		  act);
+ }
+ EXPORT_SYMBOL_GPL(bpf_warn_invalid_xdp_action);
+ 
+ static bool sock_addr_is_valid_access(int off, int size,
+ 				      enum bpf_access_type type,
+ 				      const struct bpf_prog *prog,
+ 				      struct bpf_insn_access_aux *info)
+ {
+ 	const int size_default = sizeof(__u32);
+ 
+ 	if (off < 0 || off >= sizeof(struct bpf_sock_addr))
+ 		return false;
+ 	if (off % size != 0)
+ 		return false;
+ 
+ 	/* Disallow access to IPv6 fields from IPv4 contex and vise
+ 	 * versa.
+ 	 */
+ 	switch (off) {
+ 	case bpf_ctx_range(struct bpf_sock_addr, user_ip4):
+ 		switch (prog->expected_attach_type) {
+ 		case BPF_CGROUP_INET4_BIND:
+ 		case BPF_CGROUP_INET4_CONNECT:
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 		break;
+ 	case bpf_ctx_range_till(struct bpf_sock_addr, user_ip6[0], user_ip6[3]):
+ 		switch (prog->expected_attach_type) {
+ 		case BPF_CGROUP_INET6_BIND:
+ 		case BPF_CGROUP_INET6_CONNECT:
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 		break;
+ 	}
+ 
+ 	switch (off) {
+ 	case bpf_ctx_range(struct bpf_sock_addr, user_ip4):
+ 	case bpf_ctx_range_till(struct bpf_sock_addr, user_ip6[0], user_ip6[3]):
+ 		/* Only narrow read access allowed for now. */
+ 		if (type == BPF_READ) {
+ 			bpf_ctx_record_field_size(info, size_default);
+ 			if (!bpf_ctx_narrow_access_ok(off, size, size_default))
+ 				return false;
+ 		} else {
+ 			if (size != size_default)
+ 				return false;
+ 		}
+ 		break;
+ 	case bpf_ctx_range(struct bpf_sock_addr, user_port):
+ 		if (size != size_default)
+ 			return false;
+ 		break;
+ 	default:
+ 		if (type == BPF_READ) {
+ 			if (size != size_default)
+ 				return false;
+ 		} else {
+ 			return false;
+ 		}
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static bool sock_ops_is_valid_access(int off, int size,
+ 				     enum bpf_access_type type,
+ 				     const struct bpf_prog *prog,
+ 				     struct bpf_insn_access_aux *info)
+ {
+ 	const int size_default = sizeof(__u32);
+ 
+ 	if (off < 0 || off >= sizeof(struct bpf_sock_ops))
+ 		return false;
+ 
+ 	/* The verifier guarantees that size > 0. */
+ 	if (off % size != 0)
+ 		return false;
+ 
+ 	if (type == BPF_WRITE) {
+ 		switch (off) {
+ 		case offsetof(struct bpf_sock_ops, reply):
+ 		case offsetof(struct bpf_sock_ops, sk_txhash):
+ 			if (size != size_default)
+ 				return false;
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 	} else {
+ 		switch (off) {
+ 		case bpf_ctx_range_till(struct bpf_sock_ops, bytes_received,
+ 					bytes_acked):
+ 			if (size != sizeof(__u64))
+ 				return false;
+ 			break;
+ 		default:
+ 			if (size != size_default)
+ 				return false;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static int sk_skb_prologue(struct bpf_insn *insn_buf, bool direct_write,
+ 			   const struct bpf_prog *prog)
+ {
+ 	return bpf_unclone_prologue(insn_buf, direct_write, prog, SK_DROP);
+ }
+ 
+ static bool sk_skb_is_valid_access(int off, int size,
+ 				   enum bpf_access_type type,
+ 				   const struct bpf_prog *prog,
+ 				   struct bpf_insn_access_aux *info)
+ {
+ 	switch (off) {
+ 	case bpf_ctx_range(struct __sk_buff, tc_classid):
+ 	case bpf_ctx_range(struct __sk_buff, data_meta):
+ 		return false;
+ 	}
+ 
+ 	if (type == BPF_WRITE) {
+ 		switch (off) {
+ 		case bpf_ctx_range(struct __sk_buff, tc_index):
+ 		case bpf_ctx_range(struct __sk_buff, priority):
+ 			break;
+ 		default:
+ 			return false;
+ 		}
+ 	}
+ 
+ 	switch (off) {
+ 	case bpf_ctx_range(struct __sk_buff, mark):
+ 		return false;
+ 	case bpf_ctx_range(struct __sk_buff, data):
+ 		info->reg_type = PTR_TO_PACKET;
+ 		break;
+ 	case bpf_ctx_range(struct __sk_buff, data_end):
+ 		info->reg_type = PTR_TO_PACKET_END;
+ 		break;
+ 	}
+ 
+ 	return bpf_skb_is_valid_access(off, size, type, prog, info);
+ }
+ 
+ static bool sk_msg_is_valid_access(int off, int size,
+ 				   enum bpf_access_type type,
+ 				   const struct bpf_prog *prog,
+ 				   struct bpf_insn_access_aux *info)
+ {
+ 	if (type == BPF_WRITE)
+ 		return false;
+ 
+ 	switch (off) {
+ 	case offsetof(struct sk_msg_md, data):
+ 		info->reg_type = PTR_TO_PACKET;
+ 		if (size != sizeof(__u64))
+ 			return false;
+ 		break;
+ 	case offsetof(struct sk_msg_md, data_end):
+ 		info->reg_type = PTR_TO_PACKET_END;
+ 		if (size != sizeof(__u64))
+ 			return false;
+ 		break;
+ 	default:
+ 		if (size != sizeof(__u32))
+ 			return false;
+ 	}
+ 
+ 	if (off < 0 || off >= sizeof(struct sk_msg_md))
+ 		return false;
+ 	if (off % size != 0)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static u32 bpf_convert_ctx_access(enum bpf_access_type type,
+ 				  const struct bpf_insn *si,
+ 				  struct bpf_insn *insn_buf,
+ 				  struct bpf_prog *prog, u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 	int off;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct __sk_buff, len):
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 				      bpf_target_off(struct sk_buff, len, 4,
+ 						     target_size));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, protocol):
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->src_reg,
+ 				      bpf_target_off(struct sk_buff, protocol, 2,
+ 						     target_size));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, vlan_proto):
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->src_reg,
+ 				      bpf_target_off(struct sk_buff, vlan_proto, 2,
+ 						     target_size));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, priority):
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 					      bpf_target_off(struct sk_buff, priority, 4,
+ 							     target_size));
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 					      bpf_target_off(struct sk_buff, priority, 4,
+ 							     target_size));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, ingress_ifindex):
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 				      bpf_target_off(struct sk_buff, skb_iif, 4,
+ 						     target_size));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, ifindex):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, dev),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_buff, dev));
+ 		*insn++ = BPF_JMP_IMM(BPF_JEQ, si->dst_reg, 0, 1);
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      bpf_target_off(struct net_device, ifindex, 4,
+ 						     target_size));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, hash):
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 				      bpf_target_off(struct sk_buff, hash, 4,
+ 						     target_size));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, mark):
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 					      bpf_target_off(struct sk_buff, mark, 4,
+ 							     target_size));
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 					      bpf_target_off(struct sk_buff, mark, 4,
+ 							     target_size));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, pkt_type):
+ 		*target_size = 1;
+ 		*insn++ = BPF_LDX_MEM(BPF_B, si->dst_reg, si->src_reg,
+ 				      PKT_TYPE_OFFSET());
+ 		*insn++ = BPF_ALU32_IMM(BPF_AND, si->dst_reg, PKT_TYPE_MAX);
+ #ifdef __BIG_ENDIAN_BITFIELD
+ 		*insn++ = BPF_ALU32_IMM(BPF_RSH, si->dst_reg, 5);
+ #endif
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, queue_mapping):
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->src_reg,
+ 				      bpf_target_off(struct sk_buff, queue_mapping, 2,
+ 						     target_size));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, vlan_present):
+ 	case offsetof(struct __sk_buff, vlan_tci):
+ 		BUILD_BUG_ON(VLAN_TAG_PRESENT != 0x1000);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->src_reg,
+ 				      bpf_target_off(struct sk_buff, vlan_tci, 2,
+ 						     target_size));
+ 		if (si->off == offsetof(struct __sk_buff, vlan_tci)) {
+ 			*insn++ = BPF_ALU32_IMM(BPF_AND, si->dst_reg,
+ 						~VLAN_TAG_PRESENT);
+ 		} else {
+ 			*insn++ = BPF_ALU32_IMM(BPF_RSH, si->dst_reg, 12);
+ 			*insn++ = BPF_ALU32_IMM(BPF_AND, si->dst_reg, 1);
+ 		}
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, cb[0]) ...
+ 	     offsetofend(struct __sk_buff, cb[4]) - 1:
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct qdisc_skb_cb, data) < 20);
+ 		BUILD_BUG_ON((offsetof(struct sk_buff, cb) +
+ 			      offsetof(struct qdisc_skb_cb, data)) %
+ 			     sizeof(__u64));
+ 
+ 		prog->cb_access = 1;
+ 		off  = si->off;
+ 		off -= offsetof(struct __sk_buff, cb[0]);
+ 		off += offsetof(struct sk_buff, cb);
+ 		off += offsetof(struct qdisc_skb_cb, data);
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_SIZE(si->code), si->dst_reg,
+ 					      si->src_reg, off);
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_SIZE(si->code), si->dst_reg,
+ 					      si->src_reg, off);
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, tc_classid):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct qdisc_skb_cb, tc_classid) != 2);
+ 
+ 		off  = si->off;
+ 		off -= offsetof(struct __sk_buff, tc_classid);
+ 		off += offsetof(struct sk_buff, cb);
+ 		off += offsetof(struct qdisc_skb_cb, tc_classid);
+ 		*target_size = 2;
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_H, si->dst_reg,
+ 					      si->src_reg, off);
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg,
+ 					      si->src_reg, off);
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, data):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, data),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_buff, data));
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, data_meta):
+ 		off  = si->off;
+ 		off -= offsetof(struct __sk_buff, data_meta);
+ 		off += offsetof(struct sk_buff, cb);
+ 		off += offsetof(struct bpf_skb_data_end, data_meta);
+ 		*insn++ = BPF_LDX_MEM(BPF_SIZEOF(void *), si->dst_reg,
+ 				      si->src_reg, off);
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, data_end):
+ 		off  = si->off;
+ 		off -= offsetof(struct __sk_buff, data_end);
+ 		off += offsetof(struct sk_buff, cb);
+ 		off += offsetof(struct bpf_skb_data_end, data_end);
+ 		*insn++ = BPF_LDX_MEM(BPF_SIZEOF(void *), si->dst_reg,
+ 				      si->src_reg, off);
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, tc_index):
+ #ifdef CONFIG_NET_SCHED
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_H, si->dst_reg, si->src_reg,
+ 					      bpf_target_off(struct sk_buff, tc_index, 2,
+ 							     target_size));
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->src_reg,
+ 					      bpf_target_off(struct sk_buff, tc_index, 2,
+ 							     target_size));
+ #else
+ 		*target_size = 2;
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_MOV64_REG(si->dst_reg, si->dst_reg);
+ 		else
+ 			*insn++ = BPF_MOV64_IMM(si->dst_reg, 0);
+ #endif
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, napi_id):
+ #if defined(CONFIG_NET_RX_BUSY_POLL)
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 				      bpf_target_off(struct sk_buff, napi_id, 4,
+ 						     target_size));
+ 		*insn++ = BPF_JMP_IMM(BPF_JGE, si->dst_reg, MIN_NAPI_ID, 1);
+ 		*insn++ = BPF_MOV64_IMM(si->dst_reg, 0);
+ #else
+ 		*target_size = 4;
+ 		*insn++ = BPF_MOV64_IMM(si->dst_reg, 0);
+ #endif
+ 		break;
+ 	case offsetof(struct __sk_buff, family):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_family) != 2);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->dst_reg,
+ 				      bpf_target_off(struct sock_common,
+ 						     skc_family,
+ 						     2, target_size));
+ 		break;
+ 	case offsetof(struct __sk_buff, remote_ip4):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_daddr) != 4);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      bpf_target_off(struct sock_common,
+ 						     skc_daddr,
+ 						     4, target_size));
+ 		break;
+ 	case offsetof(struct __sk_buff, local_ip4):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common,
+ 					  skc_rcv_saddr) != 4);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      bpf_target_off(struct sock_common,
+ 						     skc_rcv_saddr,
+ 						     4, target_size));
+ 		break;
+ 	case offsetof(struct __sk_buff, remote_ip6[0]) ...
+ 	     offsetof(struct __sk_buff, remote_ip6[3]):
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common,
+ 					  skc_v6_daddr.s6_addr32[0]) != 4);
+ 
+ 		off = si->off;
+ 		off -= offsetof(struct __sk_buff, remote_ip6[0]);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common,
+ 					       skc_v6_daddr.s6_addr32[0]) +
+ 				      off);
+ #else
+ 		*insn++ = BPF_MOV32_IMM(si->dst_reg, 0);
+ #endif
+ 		break;
+ 	case offsetof(struct __sk_buff, local_ip6[0]) ...
+ 	     offsetof(struct __sk_buff, local_ip6[3]):
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common,
+ 					  skc_v6_rcv_saddr.s6_addr32[0]) != 4);
+ 
+ 		off = si->off;
+ 		off -= offsetof(struct __sk_buff, local_ip6[0]);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common,
+ 					       skc_v6_rcv_saddr.s6_addr32[0]) +
+ 				      off);
+ #else
+ 		*insn++ = BPF_MOV32_IMM(si->dst_reg, 0);
+ #endif
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, remote_port):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_dport) != 2);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->dst_reg,
+ 				      bpf_target_off(struct sock_common,
+ 						     skc_dport,
+ 						     2, target_size));
+ #ifndef __BIG_ENDIAN_BITFIELD
+ 		*insn++ = BPF_ALU32_IMM(BPF_LSH, si->dst_reg, 16);
+ #endif
+ 		break;
+ 
+ 	case offsetof(struct __sk_buff, local_port):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_num) != 2);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->dst_reg,
+ 				      bpf_target_off(struct sock_common,
+ 						     skc_num, 2, target_size));
+ 		break;
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ static u32 sock_filter_convert_ctx_access(enum bpf_access_type type,
+ 					  const struct bpf_insn *si,
+ 					  struct bpf_insn *insn_buf,
+ 					  struct bpf_prog *prog, u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 	int off;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct bpf_sock, bound_dev_if):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock, sk_bound_dev_if) != 4);
+ 
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 					offsetof(struct sock, sk_bound_dev_if));
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 				      offsetof(struct sock, sk_bound_dev_if));
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock, mark):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock, sk_mark) != 4);
+ 
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 					offsetof(struct sock, sk_mark));
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 				      offsetof(struct sock, sk_mark));
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock, priority):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock, sk_priority) != 4);
+ 
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 					offsetof(struct sock, sk_priority));
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 				      offsetof(struct sock, sk_priority));
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock, family):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock, sk_family) != 2);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->src_reg,
+ 				      offsetof(struct sock, sk_family));
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock, type):
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 				      offsetof(struct sock, __sk_flags_offset));
+ 		*insn++ = BPF_ALU32_IMM(BPF_AND, si->dst_reg, SK_FL_TYPE_MASK);
+ 		*insn++ = BPF_ALU32_IMM(BPF_RSH, si->dst_reg, SK_FL_TYPE_SHIFT);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock, protocol):
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 				      offsetof(struct sock, __sk_flags_offset));
+ 		*insn++ = BPF_ALU32_IMM(BPF_AND, si->dst_reg, SK_FL_PROTO_MASK);
+ 		*insn++ = BPF_ALU32_IMM(BPF_RSH, si->dst_reg, SK_FL_PROTO_SHIFT);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock, src_ip4):
+ 		*insn++ = BPF_LDX_MEM(
+ 			BPF_SIZE(si->code), si->dst_reg, si->src_reg,
+ 			bpf_target_off(struct sock_common, skc_rcv_saddr,
+ 				       FIELD_SIZEOF(struct sock_common,
+ 						    skc_rcv_saddr),
+ 				       target_size));
+ 		break;
+ 
+ 	case bpf_ctx_range_till(struct bpf_sock, src_ip6[0], src_ip6[3]):
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		off = si->off;
+ 		off -= offsetof(struct bpf_sock, src_ip6[0]);
+ 		*insn++ = BPF_LDX_MEM(
+ 			BPF_SIZE(si->code), si->dst_reg, si->src_reg,
+ 			bpf_target_off(
+ 				struct sock_common,
+ 				skc_v6_rcv_saddr.s6_addr32[0],
+ 				FIELD_SIZEOF(struct sock_common,
+ 					     skc_v6_rcv_saddr.s6_addr32[0]),
+ 				target_size) + off);
+ #else
+ 		(void)off;
+ 		*insn++ = BPF_MOV32_IMM(si->dst_reg, 0);
+ #endif
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock, src_port):
+ 		*insn++ = BPF_LDX_MEM(
+ 			BPF_FIELD_SIZEOF(struct sock_common, skc_num),
+ 			si->dst_reg, si->src_reg,
+ 			bpf_target_off(struct sock_common, skc_num,
+ 				       FIELD_SIZEOF(struct sock_common,
+ 						    skc_num),
+ 				       target_size));
+ 		break;
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ static u32 tc_cls_act_convert_ctx_access(enum bpf_access_type type,
+ 					 const struct bpf_insn *si,
+ 					 struct bpf_insn *insn_buf,
+ 					 struct bpf_prog *prog, u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct __sk_buff, ifindex):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_buff, dev),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_buff, dev));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      bpf_target_off(struct net_device, ifindex, 4,
+ 						     target_size));
+ 		break;
+ 	default:
+ 		return bpf_convert_ctx_access(type, si, insn_buf, prog,
+ 					      target_size);
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ static u32 xdp_convert_ctx_access(enum bpf_access_type type,
+ 				  const struct bpf_insn *si,
+ 				  struct bpf_insn *insn_buf,
+ 				  struct bpf_prog *prog, u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct xdp_md, data):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct xdp_buff, data),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct xdp_buff, data));
+ 		break;
+ 	case offsetof(struct xdp_md, data_meta):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct xdp_buff, data_meta),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct xdp_buff, data_meta));
+ 		break;
+ 	case offsetof(struct xdp_md, data_end):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct xdp_buff, data_end),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct xdp_buff, data_end));
+ 		break;
+ 	case offsetof(struct xdp_md, ingress_ifindex):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct xdp_buff, rxq),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct xdp_buff, rxq));
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct xdp_rxq_info, dev),
+ 				      si->dst_reg, si->dst_reg,
+ 				      offsetof(struct xdp_rxq_info, dev));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct net_device, ifindex));
+ 		break;
+ 	case offsetof(struct xdp_md, rx_queue_index):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct xdp_buff, rxq),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct xdp_buff, rxq));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct xdp_rxq_info,
+ 					       queue_index));
+ 		break;
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ /* SOCK_ADDR_LOAD_NESTED_FIELD() loads Nested Field S.F.NF where S is type of
+  * context Structure, F is Field in context structure that contains a pointer
+  * to Nested Structure of type NS that has the field NF.
+  *
+  * SIZE encodes the load size (BPF_B, BPF_H, etc). It's up to caller to make
+  * sure that SIZE is not greater than actual size of S.F.NF.
+  *
+  * If offset OFF is provided, the load happens from that offset relative to
+  * offset of NF.
+  */
+ #define SOCK_ADDR_LOAD_NESTED_FIELD_SIZE_OFF(S, NS, F, NF, SIZE, OFF)	       \
+ 	do {								       \
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(S, F), si->dst_reg,     \
+ 				      si->src_reg, offsetof(S, F));	       \
+ 		*insn++ = BPF_LDX_MEM(					       \
+ 			SIZE, si->dst_reg, si->dst_reg,			       \
+ 			bpf_target_off(NS, NF, FIELD_SIZEOF(NS, NF),	       \
+ 				       target_size)			       \
+ 				+ OFF);					       \
+ 	} while (0)
+ 
+ #define SOCK_ADDR_LOAD_NESTED_FIELD(S, NS, F, NF)			       \
+ 	SOCK_ADDR_LOAD_NESTED_FIELD_SIZE_OFF(S, NS, F, NF,		       \
+ 					     BPF_FIELD_SIZEOF(NS, NF), 0)
+ 
+ /* SOCK_ADDR_STORE_NESTED_FIELD_OFF() has semantic similar to
+  * SOCK_ADDR_LOAD_NESTED_FIELD_SIZE_OFF() but for store operation.
+  *
+  * It doesn't support SIZE argument though since narrow stores are not
+  * supported for now.
+  *
+  * In addition it uses Temporary Field TF (member of struct S) as the 3rd
+  * "register" since two registers available in convert_ctx_access are not
+  * enough: we can't override neither SRC, since it contains value to store, nor
+  * DST since it contains pointer to context that may be used by later
+  * instructions. But we need a temporary place to save pointer to nested
+  * structure whose field we want to store to.
+  */
+ #define SOCK_ADDR_STORE_NESTED_FIELD_OFF(S, NS, F, NF, OFF, TF)		       \
+ 	do {								       \
+ 		int tmp_reg = BPF_REG_9;				       \
+ 		if (si->src_reg == tmp_reg || si->dst_reg == tmp_reg)	       \
+ 			--tmp_reg;					       \
+ 		if (si->src_reg == tmp_reg || si->dst_reg == tmp_reg)	       \
+ 			--tmp_reg;					       \
+ 		*insn++ = BPF_STX_MEM(BPF_DW, si->dst_reg, tmp_reg,	       \
+ 				      offsetof(S, TF));			       \
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(S, F), tmp_reg,	       \
+ 				      si->dst_reg, offsetof(S, F));	       \
+ 		*insn++ = BPF_STX_MEM(					       \
+ 			BPF_FIELD_SIZEOF(NS, NF), tmp_reg, si->src_reg,	       \
+ 			bpf_target_off(NS, NF, FIELD_SIZEOF(NS, NF),	       \
+ 				       target_size)			       \
+ 				+ OFF);					       \
+ 		*insn++ = BPF_LDX_MEM(BPF_DW, tmp_reg, si->dst_reg,	       \
+ 				      offsetof(S, TF));			       \
+ 	} while (0)
+ 
+ #define SOCK_ADDR_LOAD_OR_STORE_NESTED_FIELD_SIZE_OFF(S, NS, F, NF, SIZE, OFF, \
+ 						      TF)		       \
+ 	do {								       \
+ 		if (type == BPF_WRITE) {				       \
+ 			SOCK_ADDR_STORE_NESTED_FIELD_OFF(S, NS, F, NF, OFF,    \
+ 							 TF);		       \
+ 		} else {						       \
+ 			SOCK_ADDR_LOAD_NESTED_FIELD_SIZE_OFF(		       \
+ 				S, NS, F, NF, SIZE, OFF);  \
+ 		}							       \
+ 	} while (0)
+ 
+ #define SOCK_ADDR_LOAD_OR_STORE_NESTED_FIELD(S, NS, F, NF, TF)		       \
+ 	SOCK_ADDR_LOAD_OR_STORE_NESTED_FIELD_SIZE_OFF(			       \
+ 		S, NS, F, NF, BPF_FIELD_SIZEOF(NS, NF), 0, TF)
+ 
+ static u32 sock_addr_convert_ctx_access(enum bpf_access_type type,
+ 					const struct bpf_insn *si,
+ 					struct bpf_insn *insn_buf,
+ 					struct bpf_prog *prog, u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 	int off;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct bpf_sock_addr, user_family):
+ 		SOCK_ADDR_LOAD_NESTED_FIELD(struct bpf_sock_addr_kern,
+ 					    struct sockaddr, uaddr, sa_family);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_addr, user_ip4):
+ 		SOCK_ADDR_LOAD_OR_STORE_NESTED_FIELD_SIZE_OFF(
+ 			struct bpf_sock_addr_kern, struct sockaddr_in, uaddr,
+ 			sin_addr, BPF_SIZE(si->code), 0, tmp_reg);
+ 		break;
+ 
+ 	case bpf_ctx_range_till(struct bpf_sock_addr, user_ip6[0], user_ip6[3]):
+ 		off = si->off;
+ 		off -= offsetof(struct bpf_sock_addr, user_ip6[0]);
+ 		SOCK_ADDR_LOAD_OR_STORE_NESTED_FIELD_SIZE_OFF(
+ 			struct bpf_sock_addr_kern, struct sockaddr_in6, uaddr,
+ 			sin6_addr.s6_addr32[0], BPF_SIZE(si->code), off,
+ 			tmp_reg);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_addr, user_port):
+ 		/* To get port we need to know sa_family first and then treat
+ 		 * sockaddr as either sockaddr_in or sockaddr_in6.
+ 		 * Though we can simplify since port field has same offset and
+ 		 * size in both structures.
+ 		 * Here we check this invariant and use just one of the
+ 		 * structures if it's true.
+ 		 */
+ 		BUILD_BUG_ON(offsetof(struct sockaddr_in, sin_port) !=
+ 			     offsetof(struct sockaddr_in6, sin6_port));
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sockaddr_in, sin_port) !=
+ 			     FIELD_SIZEOF(struct sockaddr_in6, sin6_port));
+ 		SOCK_ADDR_LOAD_OR_STORE_NESTED_FIELD(struct bpf_sock_addr_kern,
+ 						     struct sockaddr_in6, uaddr,
+ 						     sin6_port, tmp_reg);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_addr, family):
+ 		SOCK_ADDR_LOAD_NESTED_FIELD(struct bpf_sock_addr_kern,
+ 					    struct sock, sk, sk_family);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_addr, type):
+ 		SOCK_ADDR_LOAD_NESTED_FIELD_SIZE_OFF(
+ 			struct bpf_sock_addr_kern, struct sock, sk,
+ 			__sk_flags_offset, BPF_W, 0);
+ 		*insn++ = BPF_ALU32_IMM(BPF_AND, si->dst_reg, SK_FL_TYPE_MASK);
+ 		*insn++ = BPF_ALU32_IMM(BPF_RSH, si->dst_reg, SK_FL_TYPE_SHIFT);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_addr, protocol):
+ 		SOCK_ADDR_LOAD_NESTED_FIELD_SIZE_OFF(
+ 			struct bpf_sock_addr_kern, struct sock, sk,
+ 			__sk_flags_offset, BPF_W, 0);
+ 		*insn++ = BPF_ALU32_IMM(BPF_AND, si->dst_reg, SK_FL_PROTO_MASK);
+ 		*insn++ = BPF_ALU32_IMM(BPF_RSH, si->dst_reg,
+ 					SK_FL_PROTO_SHIFT);
+ 		break;
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ static u32 sock_ops_convert_ctx_access(enum bpf_access_type type,
+ 				       const struct bpf_insn *si,
+ 				       struct bpf_insn *insn_buf,
+ 				       struct bpf_prog *prog,
+ 				       u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 	int off;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct bpf_sock_ops, op) ...
+ 	     offsetof(struct bpf_sock_ops, replylong[3]):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct bpf_sock_ops, op) !=
+ 			     FIELD_SIZEOF(struct bpf_sock_ops_kern, op));
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct bpf_sock_ops, reply) !=
+ 			     FIELD_SIZEOF(struct bpf_sock_ops_kern, reply));
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct bpf_sock_ops, replylong) !=
+ 			     FIELD_SIZEOF(struct bpf_sock_ops_kern, replylong));
+ 		off = si->off;
+ 		off -= offsetof(struct bpf_sock_ops, op);
+ 		off += offsetof(struct bpf_sock_ops_kern, op);
+ 		if (type == BPF_WRITE)
+ 			*insn++ = BPF_STX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 					      off);
+ 		else
+ 			*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->src_reg,
+ 					      off);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, family):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_family) != 2);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 					      struct bpf_sock_ops_kern, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct bpf_sock_ops_kern, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common, skc_family));
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, remote_ip4):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_daddr) != 4);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct bpf_sock_ops_kern, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct bpf_sock_ops_kern, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common, skc_daddr));
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, local_ip4):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common,
+ 					  skc_rcv_saddr) != 4);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 					      struct bpf_sock_ops_kern, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct bpf_sock_ops_kern, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common,
+ 					       skc_rcv_saddr));
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, remote_ip6[0]) ...
+ 	     offsetof(struct bpf_sock_ops, remote_ip6[3]):
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common,
+ 					  skc_v6_daddr.s6_addr32[0]) != 4);
+ 
+ 		off = si->off;
+ 		off -= offsetof(struct bpf_sock_ops, remote_ip6[0]);
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct bpf_sock_ops_kern, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct bpf_sock_ops_kern, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common,
+ 					       skc_v6_daddr.s6_addr32[0]) +
+ 				      off);
+ #else
+ 		*insn++ = BPF_MOV32_IMM(si->dst_reg, 0);
+ #endif
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, local_ip6[0]) ...
+ 	     offsetof(struct bpf_sock_ops, local_ip6[3]):
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common,
+ 					  skc_v6_rcv_saddr.s6_addr32[0]) != 4);
+ 
+ 		off = si->off;
+ 		off -= offsetof(struct bpf_sock_ops, local_ip6[0]);
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct bpf_sock_ops_kern, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct bpf_sock_ops_kern, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common,
+ 					       skc_v6_rcv_saddr.s6_addr32[0]) +
+ 				      off);
+ #else
+ 		*insn++ = BPF_MOV32_IMM(si->dst_reg, 0);
+ #endif
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, remote_port):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_dport) != 2);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct bpf_sock_ops_kern, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct bpf_sock_ops_kern, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common, skc_dport));
+ #ifndef __BIG_ENDIAN_BITFIELD
+ 		*insn++ = BPF_ALU32_IMM(BPF_LSH, si->dst_reg, 16);
+ #endif
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, local_port):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_num) != 2);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct bpf_sock_ops_kern, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct bpf_sock_ops_kern, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common, skc_num));
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, is_fullsock):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct bpf_sock_ops_kern,
+ 						is_fullsock),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct bpf_sock_ops_kern,
+ 					       is_fullsock));
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, state):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_state) != 1);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct bpf_sock_ops_kern, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct bpf_sock_ops_kern, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_B, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common, skc_state));
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, rtt_min):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct tcp_sock, rtt_min) !=
+ 			     sizeof(struct minmax));
+ 		BUILD_BUG_ON(sizeof(struct minmax) <
+ 			     sizeof(struct minmax_sample));
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct bpf_sock_ops_kern, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct bpf_sock_ops_kern, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct tcp_sock, rtt_min) +
+ 				      FIELD_SIZEOF(struct minmax_sample, t));
+ 		break;
+ 
+ /* Helper macro for adding read access to tcp_sock or sock fields. */
+ #define SOCK_OPS_GET_FIELD(BPF_FIELD, OBJ_FIELD, OBJ)			      \
+ 	do {								      \
+ 		BUILD_BUG_ON(FIELD_SIZEOF(OBJ, OBJ_FIELD) >		      \
+ 			     FIELD_SIZEOF(struct bpf_sock_ops, BPF_FIELD));   \
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(			      \
+ 						struct bpf_sock_ops_kern,     \
+ 						is_fullsock),		      \
+ 				      si->dst_reg, si->src_reg,		      \
+ 				      offsetof(struct bpf_sock_ops_kern,      \
+ 					       is_fullsock));		      \
+ 		*insn++ = BPF_JMP_IMM(BPF_JEQ, si->dst_reg, 0, 2);	      \
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(			      \
+ 						struct bpf_sock_ops_kern, sk),\
+ 				      si->dst_reg, si->src_reg,		      \
+ 				      offsetof(struct bpf_sock_ops_kern, sk));\
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(OBJ,		      \
+ 						       OBJ_FIELD),	      \
+ 				      si->dst_reg, si->dst_reg,		      \
+ 				      offsetof(OBJ, OBJ_FIELD));	      \
+ 	} while (0)
+ 
+ /* Helper macro for adding write access to tcp_sock or sock fields.
+  * The macro is called with two registers, dst_reg which contains a pointer
+  * to ctx (context) and src_reg which contains the value that should be
+  * stored. However, we need an additional register since we cannot overwrite
+  * dst_reg because it may be used later in the program.
+  * Instead we "borrow" one of the other register. We first save its value
+  * into a new (temp) field in bpf_sock_ops_kern, use it, and then restore
+  * it at the end of the macro.
+  */
+ #define SOCK_OPS_SET_FIELD(BPF_FIELD, OBJ_FIELD, OBJ)			      \
+ 	do {								      \
+ 		int reg = BPF_REG_9;					      \
+ 		BUILD_BUG_ON(FIELD_SIZEOF(OBJ, OBJ_FIELD) >		      \
+ 			     FIELD_SIZEOF(struct bpf_sock_ops, BPF_FIELD));   \
+ 		if (si->dst_reg == reg || si->src_reg == reg)		      \
+ 			reg--;						      \
+ 		if (si->dst_reg == reg || si->src_reg == reg)		      \
+ 			reg--;						      \
+ 		*insn++ = BPF_STX_MEM(BPF_DW, si->dst_reg, reg,		      \
+ 				      offsetof(struct bpf_sock_ops_kern,      \
+ 					       temp));			      \
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(			      \
+ 						struct bpf_sock_ops_kern,     \
+ 						is_fullsock),		      \
+ 				      reg, si->dst_reg,			      \
+ 				      offsetof(struct bpf_sock_ops_kern,      \
+ 					       is_fullsock));		      \
+ 		*insn++ = BPF_JMP_IMM(BPF_JEQ, reg, 0, 2);		      \
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(			      \
+ 						struct bpf_sock_ops_kern, sk),\
+ 				      reg, si->dst_reg,			      \
+ 				      offsetof(struct bpf_sock_ops_kern, sk));\
+ 		*insn++ = BPF_STX_MEM(BPF_FIELD_SIZEOF(OBJ, OBJ_FIELD),	      \
+ 				      reg, si->src_reg,			      \
+ 				      offsetof(OBJ, OBJ_FIELD));	      \
+ 		*insn++ = BPF_LDX_MEM(BPF_DW, reg, si->dst_reg,		      \
+ 				      offsetof(struct bpf_sock_ops_kern,      \
+ 					       temp));			      \
+ 	} while (0)
+ 
+ #define SOCK_OPS_GET_OR_SET_FIELD(BPF_FIELD, OBJ_FIELD, OBJ, TYPE)	      \
+ 	do {								      \
+ 		if (TYPE == BPF_WRITE)					      \
+ 			SOCK_OPS_SET_FIELD(BPF_FIELD, OBJ_FIELD, OBJ);	      \
+ 		else							      \
+ 			SOCK_OPS_GET_FIELD(BPF_FIELD, OBJ_FIELD, OBJ);	      \
+ 	} while (0)
+ 
+ 	case offsetof(struct bpf_sock_ops, snd_cwnd):
+ 		SOCK_OPS_GET_FIELD(snd_cwnd, snd_cwnd, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, srtt_us):
+ 		SOCK_OPS_GET_FIELD(srtt_us, srtt_us, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, bpf_sock_ops_cb_flags):
+ 		SOCK_OPS_GET_FIELD(bpf_sock_ops_cb_flags, bpf_sock_ops_cb_flags,
+ 				   struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, snd_ssthresh):
+ 		SOCK_OPS_GET_FIELD(snd_ssthresh, snd_ssthresh, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, rcv_nxt):
+ 		SOCK_OPS_GET_FIELD(rcv_nxt, rcv_nxt, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, snd_nxt):
+ 		SOCK_OPS_GET_FIELD(snd_nxt, snd_nxt, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, snd_una):
+ 		SOCK_OPS_GET_FIELD(snd_una, snd_una, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, mss_cache):
+ 		SOCK_OPS_GET_FIELD(mss_cache, mss_cache, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, ecn_flags):
+ 		SOCK_OPS_GET_FIELD(ecn_flags, ecn_flags, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, rate_delivered):
+ 		SOCK_OPS_GET_FIELD(rate_delivered, rate_delivered,
+ 				   struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, rate_interval_us):
+ 		SOCK_OPS_GET_FIELD(rate_interval_us, rate_interval_us,
+ 				   struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, packets_out):
+ 		SOCK_OPS_GET_FIELD(packets_out, packets_out, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, retrans_out):
+ 		SOCK_OPS_GET_FIELD(retrans_out, retrans_out, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, total_retrans):
+ 		SOCK_OPS_GET_FIELD(total_retrans, total_retrans,
+ 				   struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, segs_in):
+ 		SOCK_OPS_GET_FIELD(segs_in, segs_in, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, data_segs_in):
+ 		SOCK_OPS_GET_FIELD(data_segs_in, data_segs_in, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, segs_out):
+ 		SOCK_OPS_GET_FIELD(segs_out, segs_out, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, data_segs_out):
+ 		SOCK_OPS_GET_FIELD(data_segs_out, data_segs_out,
+ 				   struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, lost_out):
+ 		SOCK_OPS_GET_FIELD(lost_out, lost_out, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, sacked_out):
+ 		SOCK_OPS_GET_FIELD(sacked_out, sacked_out, struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, sk_txhash):
+ 		SOCK_OPS_GET_OR_SET_FIELD(sk_txhash, sk_txhash,
+ 					  struct sock, type);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, bytes_received):
+ 		SOCK_OPS_GET_FIELD(bytes_received, bytes_received,
+ 				   struct tcp_sock);
+ 		break;
+ 
+ 	case offsetof(struct bpf_sock_ops, bytes_acked):
+ 		SOCK_OPS_GET_FIELD(bytes_acked, bytes_acked, struct tcp_sock);
+ 		break;
+ 
+ 	}
+ 	return insn - insn_buf;
+ }
+ 
+ static u32 sk_skb_convert_ctx_access(enum bpf_access_type type,
+ 				     const struct bpf_insn *si,
+ 				     struct bpf_insn *insn_buf,
+ 				     struct bpf_prog *prog, u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 	int off;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct __sk_buff, data_end):
+ 		off  = si->off;
+ 		off -= offsetof(struct __sk_buff, data_end);
+ 		off += offsetof(struct sk_buff, cb);
+ 		off += offsetof(struct tcp_skb_cb, bpf.data_end);
+ 		*insn++ = BPF_LDX_MEM(BPF_SIZEOF(void *), si->dst_reg,
+ 				      si->src_reg, off);
+ 		break;
+ 	default:
+ 		return bpf_convert_ctx_access(type, si, insn_buf, prog,
+ 					      target_size);
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ static u32 sk_msg_convert_ctx_access(enum bpf_access_type type,
+ 				     const struct bpf_insn *si,
+ 				     struct bpf_insn *insn_buf,
+ 				     struct bpf_prog *prog, u32 *target_size)
+ {
+ 	struct bpf_insn *insn = insn_buf;
+ 	int off;
+ 
+ 	switch (si->off) {
+ 	case offsetof(struct sk_msg_md, data):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_msg_buff, data),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_msg_buff, data));
+ 		break;
+ 	case offsetof(struct sk_msg_md, data_end):
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(struct sk_msg_buff, data_end),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_msg_buff, data_end));
+ 		break;
+ 	case offsetof(struct sk_msg_md, family):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_family) != 2);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 					      struct sk_msg_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_msg_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common, skc_family));
+ 		break;
+ 
+ 	case offsetof(struct sk_msg_md, remote_ip4):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_daddr) != 4);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct sk_msg_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_msg_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common, skc_daddr));
+ 		break;
+ 
+ 	case offsetof(struct sk_msg_md, local_ip4):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common,
+ 					  skc_rcv_saddr) != 4);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 					      struct sk_msg_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_msg_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common,
+ 					       skc_rcv_saddr));
+ 		break;
+ 
+ 	case offsetof(struct sk_msg_md, remote_ip6[0]) ...
+ 	     offsetof(struct sk_msg_md, remote_ip6[3]):
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common,
+ 					  skc_v6_daddr.s6_addr32[0]) != 4);
+ 
+ 		off = si->off;
+ 		off -= offsetof(struct sk_msg_md, remote_ip6[0]);
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct sk_msg_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_msg_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common,
+ 					       skc_v6_daddr.s6_addr32[0]) +
+ 				      off);
+ #else
+ 		*insn++ = BPF_MOV32_IMM(si->dst_reg, 0);
+ #endif
+ 		break;
+ 
+ 	case offsetof(struct sk_msg_md, local_ip6[0]) ...
+ 	     offsetof(struct sk_msg_md, local_ip6[3]):
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common,
+ 					  skc_v6_rcv_saddr.s6_addr32[0]) != 4);
+ 
+ 		off = si->off;
+ 		off -= offsetof(struct sk_msg_md, local_ip6[0]);
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct sk_msg_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_msg_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_W, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common,
+ 					       skc_v6_rcv_saddr.s6_addr32[0]) +
+ 				      off);
+ #else
+ 		*insn++ = BPF_MOV32_IMM(si->dst_reg, 0);
+ #endif
+ 		break;
+ 
+ 	case offsetof(struct sk_msg_md, remote_port):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_dport) != 2);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct sk_msg_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_msg_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common, skc_dport));
+ #ifndef __BIG_ENDIAN_BITFIELD
+ 		*insn++ = BPF_ALU32_IMM(BPF_LSH, si->dst_reg, 16);
+ #endif
+ 		break;
+ 
+ 	case offsetof(struct sk_msg_md, local_port):
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sock_common, skc_num) != 2);
+ 
+ 		*insn++ = BPF_LDX_MEM(BPF_FIELD_SIZEOF(
+ 						struct sk_msg_buff, sk),
+ 				      si->dst_reg, si->src_reg,
+ 				      offsetof(struct sk_msg_buff, sk));
+ 		*insn++ = BPF_LDX_MEM(BPF_H, si->dst_reg, si->dst_reg,
+ 				      offsetof(struct sock_common, skc_num));
+ 		break;
+ 	}
+ 
+ 	return insn - insn_buf;
+ }
+ 
+ const struct bpf_verifier_ops sk_filter_verifier_ops = {
+ 	.get_func_proto		= sk_filter_func_proto,
+ 	.is_valid_access	= sk_filter_is_valid_access,
+ 	.convert_ctx_access	= bpf_convert_ctx_access,
+ 	.gen_ld_abs		= bpf_gen_ld_abs,
+ };
+ 
+ const struct bpf_prog_ops sk_filter_prog_ops = {
+ 	.test_run		= bpf_prog_test_run_skb,
+ };
+ 
+ const struct bpf_verifier_ops tc_cls_act_verifier_ops = {
+ 	.get_func_proto		= tc_cls_act_func_proto,
+ 	.is_valid_access	= tc_cls_act_is_valid_access,
+ 	.convert_ctx_access	= tc_cls_act_convert_ctx_access,
+ 	.gen_prologue		= tc_cls_act_prologue,
+ 	.gen_ld_abs		= bpf_gen_ld_abs,
+ };
+ 
+ const struct bpf_prog_ops tc_cls_act_prog_ops = {
+ 	.test_run		= bpf_prog_test_run_skb,
+ };
+ 
+ const struct bpf_verifier_ops xdp_verifier_ops = {
+ 	.get_func_proto		= xdp_func_proto,
+ 	.is_valid_access	= xdp_is_valid_access,
+ 	.convert_ctx_access	= xdp_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops xdp_prog_ops = {
+ 	.test_run		= bpf_prog_test_run_xdp,
+ };
+ 
+ const struct bpf_verifier_ops cg_skb_verifier_ops = {
+ 	.get_func_proto		= sk_filter_func_proto,
+ 	.is_valid_access	= sk_filter_is_valid_access,
+ 	.convert_ctx_access	= bpf_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops cg_skb_prog_ops = {
+ 	.test_run		= bpf_prog_test_run_skb,
+ };
+ 
+ const struct bpf_verifier_ops lwt_in_verifier_ops = {
+ 	.get_func_proto		= lwt_in_func_proto,
+ 	.is_valid_access	= lwt_is_valid_access,
+ 	.convert_ctx_access	= bpf_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops lwt_in_prog_ops = {
+ 	.test_run		= bpf_prog_test_run_skb,
+ };
+ 
+ const struct bpf_verifier_ops lwt_out_verifier_ops = {
+ 	.get_func_proto		= lwt_out_func_proto,
+ 	.is_valid_access	= lwt_is_valid_access,
+ 	.convert_ctx_access	= bpf_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops lwt_out_prog_ops = {
+ 	.test_run		= bpf_prog_test_run_skb,
+ };
+ 
+ const struct bpf_verifier_ops lwt_xmit_verifier_ops = {
+ 	.get_func_proto		= lwt_xmit_func_proto,
+ 	.is_valid_access	= lwt_is_valid_access,
+ 	.convert_ctx_access	= bpf_convert_ctx_access,
+ 	.gen_prologue		= tc_cls_act_prologue,
+ };
+ 
+ const struct bpf_prog_ops lwt_xmit_prog_ops = {
+ 	.test_run		= bpf_prog_test_run_skb,
+ };
+ 
+ const struct bpf_verifier_ops lwt_seg6local_verifier_ops = {
+ 	.get_func_proto		= lwt_seg6local_func_proto,
+ 	.is_valid_access	= lwt_is_valid_access,
+ 	.convert_ctx_access	= bpf_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops lwt_seg6local_prog_ops = {
+ 	.test_run		= bpf_prog_test_run_skb,
+ };
+ 
+ const struct bpf_verifier_ops cg_sock_verifier_ops = {
+ 	.get_func_proto		= sock_filter_func_proto,
+ 	.is_valid_access	= sock_filter_is_valid_access,
+ 	.convert_ctx_access	= sock_filter_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops cg_sock_prog_ops = {
+ };
+ 
+ const struct bpf_verifier_ops cg_sock_addr_verifier_ops = {
+ 	.get_func_proto		= sock_addr_func_proto,
+ 	.is_valid_access	= sock_addr_is_valid_access,
+ 	.convert_ctx_access	= sock_addr_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops cg_sock_addr_prog_ops = {
+ };
+ 
+ const struct bpf_verifier_ops sock_ops_verifier_ops = {
+ 	.get_func_proto		= sock_ops_func_proto,
+ 	.is_valid_access	= sock_ops_is_valid_access,
+ 	.convert_ctx_access	= sock_ops_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops sock_ops_prog_ops = {
+ };
+ 
+ const struct bpf_verifier_ops sk_skb_verifier_ops = {
+ 	.get_func_proto		= sk_skb_func_proto,
+ 	.is_valid_access	= sk_skb_is_valid_access,
+ 	.convert_ctx_access	= sk_skb_convert_ctx_access,
+ 	.gen_prologue		= sk_skb_prologue,
+ };
+ 
+ const struct bpf_prog_ops sk_skb_prog_ops = {
+ };
+ 
+ const struct bpf_verifier_ops sk_msg_verifier_ops = {
+ 	.get_func_proto		= sk_msg_func_proto,
+ 	.is_valid_access	= sk_msg_is_valid_access,
+ 	.convert_ctx_access	= sk_msg_convert_ctx_access,
+ };
+ 
+ const struct bpf_prog_ops sk_msg_prog_ops = {
+ };
+ 
++>>>>>>> 735fc4054b3a (xdp: change ndo_xdp_xmit API to support bulking)
  int sk_detach_filter(struct sock *sk)
  {
  	int ret = -ENOENT;
diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.c b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 8c9afe24bd84..c766b71a9c41 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@ -3673,14 +3673,19 @@ netdev_tx_t i40e_lan_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
  * @dev: netdev
  * @xdp: XDP buffer
  *
- * Returns Zero if sent, else an error code
+ * Returns number of frames successfully sent. Frames that fail are
+ * free'ed via XDP return API.
+ *
+ * For error cases, a negative errno code is returned and no-frames
+ * are transmitted (caller must handle freeing frames).
  **/
-int i40e_xdp_xmit(struct net_device *dev, struct xdp_frame *xdpf)
+int i40e_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames)
 {
 	struct i40e_netdev_priv *np = netdev_priv(dev);
 	unsigned int queue_index = smp_processor_id();
 	struct i40e_vsi *vsi = np->vsi;
-	int err;
+	int drops = 0;
+	int i;
 
 	if (test_bit(__I40E_VSI_DOWN, vsi->state))
 		return -ENETDOWN;
@@ -3688,11 +3693,18 @@ int i40e_xdp_xmit(struct net_device *dev, struct xdp_frame *xdpf)
 	if (!i40e_enabled_xdp_vsi(vsi) || queue_index >= vsi->num_queue_pairs)
 		return -ENXIO;
 
-	err = i40e_xmit_xdp_ring(xdpf, vsi->xdp_rings[queue_index]);
-	if (err != I40E_XDP_TX)
-		return -ENOSPC;
+	for (i = 0; i < n; i++) {
+		struct xdp_frame *xdpf = frames[i];
+		int err;
 
-	return 0;
+		err = i40e_xmit_xdp_ring(xdpf, vsi->xdp_rings[queue_index]);
+		if (err != I40E_XDP_TX) {
+			xdp_return_frame_rx_napi(xdpf);
+			drops++;
+		}
+	}
+
+	return n - drops;
 }
 
 /**
diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.h b/drivers/net/ethernet/intel/i40e/i40e_txrx.h
index 04d0b64f884b..99c6a7f0cd0e 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.h
@@ -495,7 +495,7 @@ u32 i40e_get_tx_pending(struct i40e_ring *ring, bool in_sw);
 void i40e_detect_recover_hung(struct i40e_vsi *vsi);
 int __i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size);
 bool __i40e_chk_linearize(struct sk_buff *skb);
-int i40e_xdp_xmit(struct net_device *dev, struct xdp_frame *xdpf);
+int i40e_xdp_xmit(struct net_device *dev, int n, struct xdp_frame **frames);
 void i40e_xdp_flush(struct net_device *dev);
 
 /**
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
* Unmerged path drivers/net/tun.c
* Unmerged path drivers/net/virtio_net.c
* Unmerged path include/linux/netdevice.h
* Unmerged path kernel/bpf/devmap.c
* Unmerged path net/core/filter.c
