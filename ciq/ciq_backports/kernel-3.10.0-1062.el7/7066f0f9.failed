mm: thp: fix mmu_notifier in migrate_misplaced_transhuge_page()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [mm] thp: fix mmu_notifier in migrate_misplaced_transhuge_page() (Andrea Arcangeli) [1636066]
Rebuild_FUZZ: 96.72%
commit-author Andrea Arcangeli <aarcange@redhat.com>
commit 7066f0f933a1fd707bb38781866657769cff7efc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7066f0f9.failed

change_huge_pmd() after arming the numa/protnone pmd doesn't flush the TLB
right away.  do_huge_pmd_numa_page() flushes the TLB before calling
migrate_misplaced_transhuge_page().  By the time do_huge_pmd_numa_page()
runs some CPU could still access the page through the TLB.

change_huge_pmd() before arming the numa/protnone transhuge pmd calls
mmu_notifier_invalidate_range_start().  So there's no need of
mmu_notifier_invalidate_range_start()/mmu_notifier_invalidate_range_only_end()
sequence in migrate_misplaced_transhuge_page() too, because by the time
migrate_misplaced_transhuge_page() runs, the pmd mapping has already been
invalidated in the secondary MMUs.  It has to or if a secondary MMU can
still write to the page, the migrate_page_copy() would lose data.

However an explicit mmu_notifier_invalidate_range() is needed before
migrate_misplaced_transhuge_page() starts copying the data of the
transhuge page or the below can happen for MMU notifier users sharing the
primary MMU pagetables and only implementing ->invalidate_range:

CPU0		CPU1		GPU sharing linux pagetables using
                                only ->invalidate_range
-----------	------------	---------
				GPU secondary MMU writes to the page
				mapped by the transhuge pmd
change_pmd_range()
mmu..._range_start()
->invalidate_range_start() noop
change_huge_pmd()
set_pmd_at(numa/protnone)
pmd_unlock()
		do_huge_pmd_numa_page()
		CPU TLB flush globally (1)
		CPU cannot write to page
		migrate_misplaced_transhuge_page()
				GPU writes to the page...
		migrate_page_copy()
				...GPU stops writing to the page
CPU TLB flush (2)
mmu..._range_end() (3)
->invalidate_range_stop() noop
->invalidate_range()
				GPU secondary MMU is invalidated
				and cannot write to the page anymore
				(too late)

Just like we need a CPU TLB flush (1) because the TLB flush (2) arrives
too late, we also need a mmu_notifier_invalidate_range() before calling
migrate_misplaced_transhuge_page(), because the ->invalidate_range() in
(3) also arrives too late.

This requirement is the result of the lazy optimization in
change_huge_pmd() that releases the pmd_lock without first flushing the
TLB and without first calling mmu_notifier_invalidate_range().

Even converting the removed mmu_notifier_invalidate_range_only_end() into
a mmu_notifier_invalidate_range_end() would not have been enough to fix
this, because it run after migrate_page_copy().

After the hugepage data copy is done migrate_misplaced_transhuge_page()
can proceed and call set_pmd_at without having to flush the TLB nor any
secondary MMUs because the secondary MMU invalidate, just like the CPU TLB
flush, has to happen before the migrate_page_copy() is called or it would
be a bug in the first place (and it was for drivers using
->invalidate_range()).

KVM is unaffected because it doesn't implement ->invalidate_range().

The standard PAGE_SIZEd migrate_misplaced_page is less accelerated and
uses the generic migrate_pages which transitions the pte from
numa/protnone to a migration entry in try_to_unmap_one() and flushes TLBs
and all mmu notifiers there before copying the page.

Link: http://lkml.kernel.org/r/20181013002430.698-3-aarcange@redhat.com
	Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
	Acked-by: Mel Gorman <mgorman@suse.de>
	Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Reviewed-by: Aaron Tomlin <atomlin@redhat.com>
	Cc: Jerome Glisse <jglisse@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 7066f0f933a1fd707bb38781866657769cff7efc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/huge_memory.c
#	mm/migrate.c
diff --cc mm/huge_memory.c
index 5d69a0fbfd2c,25ef59b7ee34..000000000000
--- a/mm/huge_memory.c
+++ b/mm/huge_memory.c
@@@ -1720,12 -1548,39 +1720,41 @@@ int do_huge_pmd_numa_page(struct vm_fau
  	}
  
  	/*
++<<<<<<< HEAD
++=======
+ 	 * Since we took the NUMA fault, we must have observed the !accessible
+ 	 * bit. Make sure all other CPUs agree with that, to avoid them
+ 	 * modifying the page we're about to migrate.
+ 	 *
+ 	 * Must be done under PTL such that we'll observe the relevant
+ 	 * inc_tlb_flush_pending().
+ 	 *
+ 	 * We are not sure a pending tlb flush here is for a huge page
+ 	 * mapping or not. Hence use the tlb range variant
+ 	 */
+ 	if (mm_tlb_flush_pending(vma->vm_mm)) {
+ 		flush_tlb_range(vma, haddr, haddr + HPAGE_PMD_SIZE);
+ 		/*
+ 		 * change_huge_pmd() released the pmd lock before
+ 		 * invalidating the secondary MMUs sharing the primary
+ 		 * MMU pagetables (with ->invalidate_range()). The
+ 		 * mmu_notifier_invalidate_range_end() (which
+ 		 * internally calls ->invalidate_range()) in
+ 		 * change_pmd_range() will run after us, so we can't
+ 		 * rely on it here and we need an explicit invalidate.
+ 		 */
+ 		mmu_notifier_invalidate_range(vma->vm_mm, haddr,
+ 					      haddr + HPAGE_PMD_SIZE);
+ 	}
+ 
+ 	/*
++>>>>>>> 7066f0f933a1 (mm: thp: fix mmu_notifier in migrate_misplaced_transhuge_page())
  	 * Migrate the THP to the requested node, returns with page unlocked
 -	 * and access rights restored.
 +	 * and pmd_numa cleared.
  	 */
 -	spin_unlock(vmf->ptl);
 -
 -	migrated = migrate_misplaced_transhuge_page(vma->vm_mm, vma,
 -				vmf->pmd, pmd, vmf->address, page, target_nid);
 +	spin_unlock(ptl);
 +	migrated = migrate_misplaced_transhuge_page(mm, vma,
 +				vmf->pmd, orig_pmd, addr, page, target_nid);
  	if (migrated) {
  		flags |= TNF_MIGRATED;
  		page_nid = target_nid;
diff --cc mm/migrate.c
index dc35415df847,905c2264c788..000000000000
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@@ -1787,22 -1974,12 +1787,27 @@@ int migrate_misplaced_transhuge_page(st
  	pg_data_t *pgdat = NODE_DATA(node);
  	int isolated = 0;
  	struct page *new_page = NULL;
 +	struct mem_cgroup *memcg = NULL;
  	int page_lru = page_is_file_cache(page);
++<<<<<<< HEAD
 +	unsigned long mmun_start = address & HPAGE_PMD_MASK;
 +	unsigned long mmun_end = mmun_start + HPAGE_PMD_SIZE;
 +	pmd_t orig_entry;
 +
 +	/*
 +	 * Rate-limit the amount of data that is being migrated to a node.
 +	 * Optimal placement is no good if the memory bus is saturated and
 +	 * all the time is being spent migrating!
 +	 */
 +	if (numamigrate_update_ratelimit(pgdat, HPAGE_PMD_NR))
 +		goto out_dropref;
++=======
+ 	unsigned long start = address & HPAGE_PMD_MASK;
+ 	unsigned long end = start + HPAGE_PMD_SIZE;
++>>>>>>> 7066f0f933a1 (mm: thp: fix mmu_notifier in migrate_misplaced_transhuge_page())
  
  	new_page = alloc_pages_node(node,
 -		(GFP_TRANSHUGE_LIGHT | __GFP_THISNODE),
 +		(GFP_TRANSHUGE | __GFP_THISNODE) & ~__GFP_WAIT,
  		HPAGE_PMD_ORDER);
  	if (!new_page)
  		goto out_fail;
@@@ -1827,12 -2003,9 +1832,10 @@@
  	WARN_ON(PageLRU(new_page));
  
  	/* Recheck the target PMD */
- 	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);
  	ptl = pmd_lock(mm, pmd);
 -	if (unlikely(!pmd_same(*pmd, entry) || !page_ref_freeze(page, 2))) {
 +	if (unlikely(!pmd_same(*pmd, entry) || page_count(page) != 2)) {
 +fail_putback:
  		spin_unlock(ptl);
- 		mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
  
  		/* Reverse changes made by migrate_page_copy() */
  		if (TestClearPageActive(new_page))
@@@ -1869,39 -2029,39 +1872,60 @@@
  	entry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);
  
  	/*
 -	 * Overwrite the old entry under pagetable lock and establish
 -	 * the new PTE. Any parallel GUP will either observe the old
 -	 * page blocking on the page lock, block on the page table
 -	 * lock or observe the new page. The SetPageUptodate on the
 -	 * new page and page_add_new_anon_rmap guarantee the copy is
 -	 * visible before the pagetable update.
 +	 * Clear the old entry under pagetable lock and establish the new PTE.
 +	 * Any parallel GUP will either observe the old page blocking on the
 +	 * page lock, block on the page table lock or observe the new page.
 +	 * The SetPageUptodate on the new page and page_add_new_anon_rmap
 +	 * guarantee the copy is visible before the pagetable update.
  	 */
++<<<<<<< HEAD
 +	flush_cache_range(vma, mmun_start, mmun_end);
 +	page_add_new_anon_rmap(new_page, vma, mmun_start);
 +	pmdp_clear_flush_notify(vma, mmun_start, pmd);
 +	set_pmd_at(mm, mmun_start, pmd, entry);
 +	flush_tlb_range(vma, mmun_start, mmun_end);
++=======
+ 	flush_cache_range(vma, start, end);
+ 	page_add_anon_rmap(new_page, vma, start, true);
+ 	/*
+ 	 * At this point the pmd is numa/protnone (i.e. non present) and the TLB
+ 	 * has already been flushed globally.  So no TLB can be currently
+ 	 * caching this non present pmd mapping.  There's no need to clear the
+ 	 * pmd before doing set_pmd_at(), nor to flush the TLB after
+ 	 * set_pmd_at().  Clearing the pmd here would introduce a race
+ 	 * condition against MADV_DONTNEED, because MADV_DONTNEED only holds the
+ 	 * mmap_sem for reading.  If the pmd is set to NULL at any given time,
+ 	 * MADV_DONTNEED won't wait on the pmd lock and it'll skip clearing this
+ 	 * pmd.
+ 	 */
+ 	set_pmd_at(mm, start, pmd, entry);
++>>>>>>> 7066f0f933a1 (mm: thp: fix mmu_notifier in migrate_misplaced_transhuge_page())
  	update_mmu_cache_pmd(vma, address, &entry);
  
 -	page_ref_unfreeze(page, 2);
 +	if (page_count(page) != 2) {
 +		set_pmd_at(mm, mmun_start, pmd, orig_entry);
 +		flush_tlb_range(vma, mmun_start, mmun_end);
 +		mmu_notifier_invalidate_range(mm, mmun_start, mmun_end);
 +		update_mmu_cache_pmd(vma, address, &entry);
 +		page_remove_rmap(new_page);
 +		goto fail_putback;
 +	}
 +
  	mlock_migrate_page(new_page, page);
 -	page_remove_rmap(page, true);
 -	set_page_owner_migrate_reason(new_page, MR_NUMA_MISPLACED);
 +	page_remove_rmap(page);
  
++<<<<<<< HEAD
 +	/*
 +	 * Finish the charge transaction under the page table lock to
 +	 * prevent split_huge_page() from dividing up the charge
 +	 * before it's fully transferred to the new page.
 +	 */
 +	mem_cgroup_end_migration(memcg, page, new_page, true);
  	spin_unlock(ptl);
 -
 -	/* Take an "isolate" reference and put new page on the LRU. */
 -	get_page(new_page);
 -	putback_lru_page(new_page);
 +	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
++=======
++	spin_unlock(ptl);
++>>>>>>> 7066f0f933a1 (mm: thp: fix mmu_notifier in migrate_misplaced_transhuge_page())
  
  	unlock_page(new_page);
  	unlock_page(page);
@@@ -1918,11 -2078,10 +1942,16 @@@
  
  out_fail:
  	count_vm_events(PGMIGRATE_FAIL, HPAGE_PMD_NR);
 +out_dropref:
  	ptl = pmd_lock(mm, pmd);
  	if (pmd_same(*pmd, entry)) {
++<<<<<<< HEAD
 +		entry = pmd_mknonnuma(entry);
 +		set_pmd_at(mm, mmun_start, pmd, entry);
++=======
+ 		entry = pmd_modify(entry, vma->vm_page_prot);
+ 		set_pmd_at(mm, start, pmd, entry);
++>>>>>>> 7066f0f933a1 (mm: thp: fix mmu_notifier in migrate_misplaced_transhuge_page())
  		update_mmu_cache_pmd(vma, address, &entry);
  	}
  	spin_unlock(ptl);
* Unmerged path mm/huge_memory.c
* Unmerged path mm/migrate.c
