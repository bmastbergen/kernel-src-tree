scsi: mpt3sas: clarify mmio pointer types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] mpt3sas: clarify mmio pointer types (Tomas Henzl) [1513855]
Rebuild_FUZZ: 92.11%
commit-author Arnd Bergmann <arnd@arndb.de>
commit 6f9e09fd6488de7661ee20efb5d8ab4e05a59735
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6f9e09fd.failed

The newly added code mixes up phys_addr_t/resource_size_t with dma_addr_t
and void pointers, as seen from these compiler warning:

drivers/scsi/mpt3sas/mpt3sas_base.c: In function '_base_get_chain_phys':
drivers/scsi/mpt3sas/mpt3sas_base.c:235:21: error: cast to pointer from integer of different size [-Werror=int-to-pointer-cast]
  base_chain_phys  = (void *)ioc->chip_phys + MPI_FRAME_START_OFFSET +
                     ^
drivers/scsi/mpt3sas/mpt3sas_base.c: In function '_clone_sg_entries':
drivers/scsi/mpt3sas/mpt3sas_base.c:427:20: error: cast from pointer to integer of different size [-Werror=pointer-to-int-cast]
    sgel->Address = (dma_addr_t)dst_addr_phys;
                    ^
drivers/scsi/mpt3sas/mpt3sas_base.c:438:7: error: cast from pointer to integer of different size [-Werror=pointer-to-int-cast]
       (dma_addr_t)buff_ptr_phys;
       ^
drivers/scsi/mpt3sas/mpt3sas_base.c:444:10: error: cast from pointer to integer of different size [-Werror=pointer-to-int-cast]
          (dma_addr_t)buff_ptr_phys;

Both dma_addr_t and phys_addr_t may be wider than a pointer, so we must
avoid the conversion to pointer types. This also helps readability.

A second problem is treating MMIO addresses from a 'struct resource'
as addresses that can be used for DMA on that device. In almost all
cases, those are the same, but on some of the more obscure architectures,
PCI memory address 0 is mapped into the CPU address space at a nonzero
offset. I don't have a good fix for that, so I'm adding a comment here,
plus a WARN_ON() that triggers whenever the phys_addr_t number is
outside of the low 32-bit address space and causes a straight overflow
when assigned to the 32-bit sgel->Address.

Fixes: 182ac784b41f ("scsi: mpt3sas: Introduce Base function for cloning.")
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Acked-by: Sreekanth Reddy <Sreekanth.Reddy@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 6f9e09fd6488de7661ee20efb5d8ab4e05a59735)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt3sas/mpt3sas_base.c
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.c
index 2d5e2fd11ddb,0a0e7aad0ca4..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@@ -218,6 -283,205 +218,208 @@@ _base_get_buffer_phys_bar0(struct MPT3S
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * _base_get_chain_buffer_dma_to_chain_buffer - Iterates chain
+  *			lookup list and Provides chain_buffer
+  *			address for the matching dma address.
+  *			(Each smid can have 64K starts from 17024)
+  *
+  * @ioc: per adapter object
+  * @chain_buffer_dma: Chain buffer dma address.
+  *
+  * @Returns - Pointer to chain buffer. Or Null on Failure.
+  */
+ static void *
+ _base_get_chain_buffer_dma_to_chain_buffer(struct MPT3SAS_ADAPTER *ioc,
+ 		dma_addr_t chain_buffer_dma)
+ {
+ 	u16 index;
+ 
+ 	for (index = 0; index < ioc->chain_depth; index++) {
+ 		if (ioc->chain_lookup[index].chain_buffer_dma ==
+ 				chain_buffer_dma)
+ 			return ioc->chain_lookup[index].chain_buffer;
+ 	}
+ 	pr_info(MPT3SAS_FMT
+ 	    "Provided chain_buffer_dma address is not in the lookup list\n",
+ 	    ioc->name);
+ 	return NULL;
+ }
+ 
+ /**
+  * _clone_sg_entries -	MPI EP's scsiio and config requests
+  *			are handled here. Base function for
+  *			double buffering, before submitting
+  *			the requests.
+  *
+  * @ioc: per adapter object.
+  * @mpi_request: mf request pointer.
+  * @smid: system request message index.
+  *
+  * @Returns: Nothing.
+  */
+ static void _clone_sg_entries(struct MPT3SAS_ADAPTER *ioc,
+ 		void *mpi_request, u16 smid)
+ {
+ 	Mpi2SGESimple32_t *sgel, *sgel_next;
+ 	u32  sgl_flags, sge_chain_count = 0;
+ 	bool is_write = 0;
+ 	u16 i = 0;
+ 	void __iomem *buffer_iomem;
+ 	phys_addr_t buffer_iomem_phys;
+ 	void __iomem *buff_ptr;
+ 	phys_addr_t buff_ptr_phys;
+ 	void __iomem *dst_chain_addr[MCPU_MAX_CHAINS_PER_IO];
+ 	void *src_chain_addr[MCPU_MAX_CHAINS_PER_IO];
+ 	phys_addr_t dst_addr_phys;
+ 	MPI2RequestHeader_t *request_hdr;
+ 	struct scsi_cmnd *scmd;
+ 	struct scatterlist *sg_scmd = NULL;
+ 	int is_scsiio_req = 0;
+ 
+ 	request_hdr = (MPI2RequestHeader_t *) mpi_request;
+ 
+ 	if (request_hdr->Function == MPI2_FUNCTION_SCSI_IO_REQUEST) {
+ 		Mpi25SCSIIORequest_t *scsiio_request =
+ 			(Mpi25SCSIIORequest_t *)mpi_request;
+ 		sgel = (Mpi2SGESimple32_t *) &scsiio_request->SGL;
+ 		is_scsiio_req = 1;
+ 	} else if (request_hdr->Function == MPI2_FUNCTION_CONFIG) {
+ 		Mpi2ConfigRequest_t  *config_req =
+ 			(Mpi2ConfigRequest_t *)mpi_request;
+ 		sgel = (Mpi2SGESimple32_t *) &config_req->PageBufferSGE;
+ 	} else
+ 		return;
+ 
+ 	/* From smid we can get scsi_cmd, once we have sg_scmd,
+ 	 * we just need to get sg_virt and sg_next to get virual
+ 	 * address associated with sgel->Address.
+ 	 */
+ 
+ 	if (is_scsiio_req) {
+ 		/* Get scsi_cmd using smid */
+ 		scmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);
+ 		if (scmd == NULL) {
+ 			pr_err(MPT3SAS_FMT "scmd is NULL\n", ioc->name);
+ 			return;
+ 		}
+ 
+ 		/* Get sg_scmd from scmd provided */
+ 		sg_scmd = scsi_sglist(scmd);
+ 	}
+ 
+ 	/*
+ 	 * 0 - 255	System register
+ 	 * 256 - 4352	MPI Frame. (This is based on maxCredit 32)
+ 	 * 4352 - 4864	Reply_free pool (512 byte is reserved
+ 	 *		considering maxCredit 32. Reply need extra
+ 	 *		room, for mCPU case kept four times of
+ 	 *		maxCredit).
+ 	 * 4864 - 17152	SGE chain element. (32cmd * 3 chain of
+ 	 *		128 byte size = 12288)
+ 	 * 17152 - x	Host buffer mapped with smid.
+ 	 *		(Each smid can have 64K Max IO.)
+ 	 * BAR0+Last 1K MSIX Addr and Data
+ 	 * Total size in use 2113664 bytes of 4MB BAR0
+ 	 */
+ 
+ 	buffer_iomem = _base_get_buffer_bar0(ioc, smid);
+ 	buffer_iomem_phys = _base_get_buffer_phys_bar0(ioc, smid);
+ 
+ 	buff_ptr = buffer_iomem;
+ 	buff_ptr_phys = buffer_iomem_phys;
+ 	WARN_ON(buff_ptr_phys > U32_MAX);
+ 
+ 	if (sgel->FlagsLength &
+ 			(MPI2_SGE_FLAGS_HOST_TO_IOC << MPI2_SGE_FLAGS_SHIFT))
+ 		is_write = 1;
+ 
+ 	for (i = 0; i < MPT_MIN_PHYS_SEGMENTS + ioc->facts.MaxChainDepth; i++) {
+ 
+ 		sgl_flags = (sgel->FlagsLength >> MPI2_SGE_FLAGS_SHIFT);
+ 
+ 		switch (sgl_flags & MPI2_SGE_FLAGS_ELEMENT_MASK) {
+ 		case MPI2_SGE_FLAGS_CHAIN_ELEMENT:
+ 			/*
+ 			 * Helper function which on passing
+ 			 * chain_buffer_dma returns chain_buffer. Get
+ 			 * the virtual address for sgel->Address
+ 			 */
+ 			sgel_next =
+ 				_base_get_chain_buffer_dma_to_chain_buffer(ioc,
+ 						sgel->Address);
+ 			if (sgel_next == NULL)
+ 				return;
+ 			/*
+ 			 * This is coping 128 byte chain
+ 			 * frame (not a host buffer)
+ 			 */
+ 			dst_chain_addr[sge_chain_count] =
+ 				_base_get_chain(ioc,
+ 					smid, sge_chain_count);
+ 			src_chain_addr[sge_chain_count] =
+ 						(void *) sgel_next;
+ 			dst_addr_phys = _base_get_chain_phys(ioc,
+ 						smid, sge_chain_count);
+ 			WARN_ON(dst_addr_phys > U32_MAX);
+ 			sgel->Address = (u32)dst_addr_phys;
+ 			sgel = sgel_next;
+ 			sge_chain_count++;
+ 			break;
+ 		case MPI2_SGE_FLAGS_SIMPLE_ELEMENT:
+ 			if (is_write) {
+ 				if (is_scsiio_req) {
+ 					_base_clone_to_sys_mem(buff_ptr,
+ 					    sg_virt(sg_scmd),
+ 					    (sgel->FlagsLength & 0x00ffffff));
+ 					/*
+ 					 * FIXME: this relies on a a zero
+ 					 * PCI mem_offset.
+ 					 */
+ 					sgel->Address = (u32)buff_ptr_phys;
+ 				} else {
+ 					_base_clone_to_sys_mem(buff_ptr,
+ 					    ioc->config_vaddr,
+ 					    (sgel->FlagsLength & 0x00ffffff));
+ 					sgel->Address = (u32)buff_ptr_phys;
+ 				}
+ 			}
+ 			buff_ptr += (sgel->FlagsLength & 0x00ffffff);
+ 			buff_ptr_phys += (sgel->FlagsLength & 0x00ffffff);
+ 			if ((sgel->FlagsLength &
+ 			    (MPI2_SGE_FLAGS_END_OF_BUFFER
+ 					<< MPI2_SGE_FLAGS_SHIFT)))
+ 				goto eob_clone_chain;
+ 			else {
+ 				/*
+ 				 * Every single element in MPT will have
+ 				 * associated sg_next. Better to sanity that
+ 				 * sg_next is not NULL, but it will be a bug
+ 				 * if it is null.
+ 				 */
+ 				if (is_scsiio_req) {
+ 					sg_scmd = sg_next(sg_scmd);
+ 					if (sg_scmd)
+ 						sgel++;
+ 					else
+ 						goto eob_clone_chain;
+ 				}
+ 			}
+ 			break;
+ 		}
+ 	}
+ 
+ eob_clone_chain:
+ 	for (i = 0; i < sge_chain_count; i++) {
+ 		if (is_scsiio_req)
+ 			_base_clone_to_sys_mem(dst_chain_addr[i],
+ 				src_chain_addr[i], ioc->request_sz);
+ 	}
+ }
+ 
+ /**
++>>>>>>> 6f9e09fd6488 (scsi: mpt3sas: clarify mmio pointer types)
   *  mpt3sas_remove_dead_ioc_func - kthread context to remove dead ioc
   * @arg: input argument, used to derive ioc
   *
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.c
diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.h b/drivers/scsi/mpt3sas/mpt3sas_base.h
index ad008c86cc10..2c9ee0753431 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_base.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h
@@ -1073,7 +1073,7 @@ struct MPT3SAS_ADAPTER {
 	char		tmp_string[MPT_STRING_LENGTH];
 	struct pci_dev	*pdev;
 	Mpi2SystemInterfaceRegs_t __iomem *chip;
-	resource_size_t	chip_phys;
+	phys_addr_t	chip_phys;
 	int		logging_level;
 	int		fwfault_debug;
 	u8		ir_firmware;
