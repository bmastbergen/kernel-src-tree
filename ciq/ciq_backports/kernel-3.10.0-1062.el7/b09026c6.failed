cxgb4: remove DEFINE_SIMPLE_DEBUGFS_FILE()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Yangtao Li <tiny.windzz@gmail.com>
commit b09026c6913eeef1b21914a9d441ba275df40f27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b09026c6.failed

We already have the DEFINE_SHOW_ATTRIBUTE. There is no need to define
such a macro, so remove DEFINE_SIMPLE_DEBUGFS_FILE. Also use the
DEFINE_SHOW_ATTRIBUTE macro to simplify some code.

	Signed-off-by: Yangtao Li <tiny.windzz@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b09026c6913eeef1b21914a9d441ba275df40f27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
#	drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
index 40d23d65ec14,b0ff9fa183f4..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
@@@ -2414,6 -2386,222 +2386,225 @@@ static const struct file_operations rss
  	.release = seq_release_private
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CHELSIO_T4_DCB
+ extern char *dcb_ver_array[];
+ 
+ /* Data Center Briging information for each port.
+  */
+ static int dcb_info_show(struct seq_file *seq, void *v)
+ {
+ 	struct adapter *adap = seq->private;
+ 
+ 	if (v == SEQ_START_TOKEN) {
+ 		seq_puts(seq, "Data Center Bridging Information\n");
+ 	} else {
+ 		int port = (uintptr_t)v - 2;
+ 		struct net_device *dev = adap->port[port];
+ 		struct port_info *pi = netdev2pinfo(dev);
+ 		struct port_dcb_info *dcb = &pi->dcb;
+ 
+ 		seq_puts(seq, "\n");
+ 		seq_printf(seq, "Port: %d (DCB negotiated: %s)\n",
+ 			   port,
+ 			   cxgb4_dcb_enabled(dev) ? "yes" : "no");
+ 
+ 		if (cxgb4_dcb_enabled(dev))
+ 			seq_printf(seq, "[ DCBx Version %s ]\n",
+ 				   dcb_ver_array[dcb->dcb_version]);
+ 
+ 		if (dcb->msgs) {
+ 			int i;
+ 
+ 			seq_puts(seq, "\n  Index\t\t\t  :\t");
+ 			for (i = 0; i < 8; i++)
+ 				seq_printf(seq, " %3d", i);
+ 			seq_puts(seq, "\n\n");
+ 		}
+ 
+ 		if (dcb->msgs & CXGB4_DCB_FW_PGID) {
+ 			int prio, pgid;
+ 
+ 			seq_puts(seq, "  Priority Group IDs\t  :\t");
+ 			for (prio = 0; prio < 8; prio++) {
+ 				pgid = (dcb->pgid >> 4 * (7 - prio)) & 0xf;
+ 				seq_printf(seq, " %3d", pgid);
+ 			}
+ 			seq_puts(seq, "\n");
+ 		}
+ 
+ 		if (dcb->msgs & CXGB4_DCB_FW_PGRATE) {
+ 			int pg;
+ 
+ 			seq_puts(seq, "  Priority Group BW(%)\t  :\t");
+ 			for (pg = 0; pg < 8; pg++)
+ 				seq_printf(seq, " %3d", dcb->pgrate[pg]);
+ 			seq_puts(seq, "\n");
+ 
+ 			if (dcb->dcb_version == FW_PORT_DCB_VER_IEEE) {
+ 				seq_puts(seq, "  TSA Algorithm\t\t  :\t");
+ 				for (pg = 0; pg < 8; pg++)
+ 					seq_printf(seq, " %3d", dcb->tsa[pg]);
+ 				seq_puts(seq, "\n");
+ 			}
+ 
+ 			seq_printf(seq, "  Max PG Traffic Classes  [%3d  ]\n",
+ 				   dcb->pg_num_tcs_supported);
+ 
+ 			seq_puts(seq, "\n");
+ 		}
+ 
+ 		if (dcb->msgs & CXGB4_DCB_FW_PRIORATE) {
+ 			int prio;
+ 
+ 			seq_puts(seq, "  Priority Rate\t:\t");
+ 			for (prio = 0; prio < 8; prio++)
+ 				seq_printf(seq, " %3d", dcb->priorate[prio]);
+ 			seq_puts(seq, "\n");
+ 		}
+ 
+ 		if (dcb->msgs & CXGB4_DCB_FW_PFC) {
+ 			int prio;
+ 
+ 			seq_puts(seq, "  Priority Flow Control   :\t");
+ 			for (prio = 0; prio < 8; prio++) {
+ 				int pfcen = (dcb->pfcen >> 1 * (7 - prio))
+ 					    & 0x1;
+ 				seq_printf(seq, " %3d", pfcen);
+ 			}
+ 			seq_puts(seq, "\n");
+ 
+ 			seq_printf(seq, "  Max PFC Traffic Classes [%3d  ]\n",
+ 				   dcb->pfc_num_tcs_supported);
+ 
+ 			seq_puts(seq, "\n");
+ 		}
+ 
+ 		if (dcb->msgs & CXGB4_DCB_FW_APP_ID) {
+ 			int app, napps;
+ 
+ 			seq_puts(seq, "  Application Information:\n");
+ 			seq_puts(seq, "  App    Priority    Selection         Protocol\n");
+ 			seq_puts(seq, "  Index  Map         Field             ID\n");
+ 			for (app = 0, napps = 0;
+ 			     app < CXGB4_MAX_DCBX_APP_SUPPORTED; app++) {
+ 				struct app_priority *ap;
+ 				static const char * const sel_names[] = {
+ 					"Ethertype",
+ 					"Socket TCP",
+ 					"Socket UDP",
+ 					"Socket All",
+ 				};
+ 				const char *sel_name;
+ 
+ 				ap = &dcb->app_priority[app];
+ 				/* skip empty slots */
+ 				if (ap->protocolid == 0)
+ 					continue;
+ 				napps++;
+ 
+ 				if (ap->sel_field < ARRAY_SIZE(sel_names))
+ 					sel_name = sel_names[ap->sel_field];
+ 				else
+ 					sel_name = "UNKNOWN";
+ 
+ 				seq_printf(seq, "  %3d    %#04x        %-10s (%d)    %#06x (%d)\n",
+ 					   app,
+ 					   ap->user_prio_map,
+ 					   sel_name, ap->sel_field,
+ 					   ap->protocolid, ap->protocolid);
+ 			}
+ 			if (napps == 0)
+ 				seq_puts(seq, "    --- None ---\n");
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ static inline void *dcb_info_get_idx(struct adapter *adap, loff_t pos)
+ {
+ 	return (pos <= adap->params.nports
+ 		? (void *)((uintptr_t)pos + 1)
+ 		: NULL);
+ }
+ 
+ static void *dcb_info_start(struct seq_file *seq, loff_t *pos)
+ {
+ 	struct adapter *adap = seq->private;
+ 
+ 	return (*pos
+ 		? dcb_info_get_idx(adap, *pos)
+ 		: SEQ_START_TOKEN);
+ }
+ 
+ static void dcb_info_stop(struct seq_file *seq, void *v)
+ {
+ }
+ 
+ static void *dcb_info_next(struct seq_file *seq, void *v, loff_t *pos)
+ {
+ 	struct adapter *adap = seq->private;
+ 
+ 	(*pos)++;
+ 	return dcb_info_get_idx(adap, *pos);
+ }
+ 
+ static const struct seq_operations dcb_info_seq_ops = {
+ 	.start = dcb_info_start,
+ 	.next  = dcb_info_next,
+ 	.stop  = dcb_info_stop,
+ 	.show  = dcb_info_show
+ };
+ 
+ static int dcb_info_open(struct inode *inode, struct file *file)
+ {
+ 	int res = seq_open(file, &dcb_info_seq_ops);
+ 
+ 	if (!res) {
+ 		struct seq_file *seq = file->private_data;
+ 
+ 		seq->private = inode->i_private;
+ 	}
+ 	return res;
+ }
+ 
+ static const struct file_operations dcb_info_debugfs_fops = {
+ 	.owner   = THIS_MODULE,
+ 	.open    = dcb_info_open,
+ 	.read    = seq_read,
+ 	.llseek  = seq_lseek,
+ 	.release = seq_release,
+ };
+ #endif /* CONFIG_CHELSIO_T4_DCB */
+ 
+ static int resources_show(struct seq_file *seq, void *v)
+ {
+ 	struct adapter *adapter = seq->private;
+ 	struct pf_resources *pfres = &adapter->params.pfres;
+ 
+ 	#define S(desc, fmt, var) \
+ 		seq_printf(seq, "%-60s " fmt "\n", \
+ 			   desc " (" #var "):", pfres->var)
+ 
+ 	S("Virtual Interfaces", "%d", nvi);
+ 	S("Egress Queues", "%d", neq);
+ 	S("Ethernet Control", "%d", nethctrl);
+ 	S("Ingress Queues/w Free Lists/Interrupts", "%d", niqflint);
+ 	S("Ingress Queues", "%d", niq);
+ 	S("Traffic Class", "%d", tc);
+ 	S("Port Access Rights Mask", "%#x", pmask);
+ 	S("MAC Address Filters", "%d", nexactf);
+ 	S("Firmware Command Read Capabilities", "%#x", r_caps);
+ 	S("Firmware Command Write/Execute Capabilities", "%#x", wx_caps);
+ 
+ 	#undef S
+ 
+ 	return 0;
+ }
+ DEFINE_SHOW_ATTRIBUTE(resources);
+ 
++>>>>>>> b09026c6913e (cxgb4: remove DEFINE_SIMPLE_DEBUGFS_FILE())
  /**
   * ethqset2pinfo - return port_info of an Ethernet Queue Set
   * @adap: the adapter
@@@ -3180,20 -3346,169 +3358,186 @@@ static int chcr_stats_show(struct seq_f
  		   atomic_read(&adap->chcr_stats.ipsec_cnt));
  	return 0;
  }
++<<<<<<< HEAD
 +
 +
 +static int chcr_stats_open(struct inode *inode, struct file *file)
 +{
 +        return single_open(file, chcr_show, inode->i_private);
 +}
 +
 +static const struct file_operations chcr_stats_debugfs_fops = {
 +        .owner   = THIS_MODULE,
 +        .open    = chcr_stats_open,
 +        .read    = seq_read,
 +        .llseek  = seq_lseek,
 +        .release = single_release,
 +};
++=======
+ DEFINE_SHOW_ATTRIBUTE(chcr_stats);
+ 
+ #define PRINT_ADAP_STATS(string, value) \
+ 	seq_printf(seq, "%-25s %-20llu\n", (string), \
+ 		   (unsigned long long)(value))
+ 
+ #define PRINT_CH_STATS(string, value) \
+ do { \
+ 	seq_printf(seq, "%-25s ", (string)); \
+ 	for (i = 0; i < adap->params.arch.nchan; i++) \
+ 		seq_printf(seq, "%-20llu ", \
+ 			   (unsigned long long)stats.value[i]); \
+ 	seq_printf(seq, "\n"); \
+ } while (0)
+ 
+ #define PRINT_CH_STATS2(string, value) \
+ do { \
+ 	seq_printf(seq, "%-25s ", (string)); \
+ 	for (i = 0; i < adap->params.arch.nchan; i++) \
+ 		seq_printf(seq, "%-20llu ", \
+ 			   (unsigned long long)stats[i].value); \
+ 	seq_printf(seq, "\n"); \
+ } while (0)
+ 
+ static void show_tcp_stats(struct seq_file *seq)
+ {
+ 	struct adapter *adap = seq->private;
+ 	struct tp_tcp_stats v4, v6;
+ 
+ 	spin_lock(&adap->stats_lock);
+ 	t4_tp_get_tcp_stats(adap, &v4, &v6, false);
+ 	spin_unlock(&adap->stats_lock);
+ 
+ 	PRINT_ADAP_STATS("tcp_ipv4_out_rsts:", v4.tcp_out_rsts);
+ 	PRINT_ADAP_STATS("tcp_ipv4_in_segs:", v4.tcp_in_segs);
+ 	PRINT_ADAP_STATS("tcp_ipv4_out_segs:", v4.tcp_out_segs);
+ 	PRINT_ADAP_STATS("tcp_ipv4_retrans_segs:", v4.tcp_retrans_segs);
+ 	PRINT_ADAP_STATS("tcp_ipv6_out_rsts:", v6.tcp_out_rsts);
+ 	PRINT_ADAP_STATS("tcp_ipv6_in_segs:", v6.tcp_in_segs);
+ 	PRINT_ADAP_STATS("tcp_ipv6_out_segs:", v6.tcp_out_segs);
+ 	PRINT_ADAP_STATS("tcp_ipv6_retrans_segs:", v6.tcp_retrans_segs);
+ }
+ 
+ static void show_ddp_stats(struct seq_file *seq)
+ {
+ 	struct adapter *adap = seq->private;
+ 	struct tp_usm_stats stats;
+ 
+ 	spin_lock(&adap->stats_lock);
+ 	t4_get_usm_stats(adap, &stats, false);
+ 	spin_unlock(&adap->stats_lock);
+ 
+ 	PRINT_ADAP_STATS("usm_ddp_frames:", stats.frames);
+ 	PRINT_ADAP_STATS("usm_ddp_octets:", stats.octets);
+ 	PRINT_ADAP_STATS("usm_ddp_drops:", stats.drops);
+ }
+ 
+ static void show_rdma_stats(struct seq_file *seq)
+ {
+ 	struct adapter *adap = seq->private;
+ 	struct tp_rdma_stats stats;
+ 
+ 	spin_lock(&adap->stats_lock);
+ 	t4_tp_get_rdma_stats(adap, &stats, false);
+ 	spin_unlock(&adap->stats_lock);
+ 
+ 	PRINT_ADAP_STATS("rdma_no_rqe_mod_defer:", stats.rqe_dfr_mod);
+ 	PRINT_ADAP_STATS("rdma_no_rqe_pkt_defer:", stats.rqe_dfr_pkt);
+ }
+ 
+ static void show_tp_err_adapter_stats(struct seq_file *seq)
+ {
+ 	struct adapter *adap = seq->private;
+ 	struct tp_err_stats stats;
+ 
+ 	spin_lock(&adap->stats_lock);
+ 	t4_tp_get_err_stats(adap, &stats, false);
+ 	spin_unlock(&adap->stats_lock);
+ 
+ 	PRINT_ADAP_STATS("tp_err_ofld_no_neigh:", stats.ofld_no_neigh);
+ 	PRINT_ADAP_STATS("tp_err_ofld_cong_defer:", stats.ofld_cong_defer);
+ }
+ 
+ static void show_cpl_stats(struct seq_file *seq)
+ {
+ 	struct adapter *adap = seq->private;
+ 	struct tp_cpl_stats stats;
+ 	u8 i;
+ 
+ 	spin_lock(&adap->stats_lock);
+ 	t4_tp_get_cpl_stats(adap, &stats, false);
+ 	spin_unlock(&adap->stats_lock);
+ 
+ 	PRINT_CH_STATS("tp_cpl_requests:", req);
+ 	PRINT_CH_STATS("tp_cpl_responses:", rsp);
+ }
+ 
+ static void show_tp_err_channel_stats(struct seq_file *seq)
+ {
+ 	struct adapter *adap = seq->private;
+ 	struct tp_err_stats stats;
+ 	u8 i;
+ 
+ 	spin_lock(&adap->stats_lock);
+ 	t4_tp_get_err_stats(adap, &stats, false);
+ 	spin_unlock(&adap->stats_lock);
+ 
+ 	PRINT_CH_STATS("tp_mac_in_errs:", mac_in_errs);
+ 	PRINT_CH_STATS("tp_hdr_in_errs:", hdr_in_errs);
+ 	PRINT_CH_STATS("tp_tcp_in_errs:", tcp_in_errs);
+ 	PRINT_CH_STATS("tp_tcp6_in_errs:", tcp6_in_errs);
+ 	PRINT_CH_STATS("tp_tnl_cong_drops:", tnl_cong_drops);
+ 	PRINT_CH_STATS("tp_tnl_tx_drops:", tnl_tx_drops);
+ 	PRINT_CH_STATS("tp_ofld_vlan_drops:", ofld_vlan_drops);
+ 	PRINT_CH_STATS("tp_ofld_chan_drops:", ofld_chan_drops);
+ }
+ 
+ static void show_fcoe_stats(struct seq_file *seq)
+ {
+ 	struct adapter *adap = seq->private;
+ 	struct tp_fcoe_stats stats[NCHAN];
+ 	u8 i;
+ 
+ 	spin_lock(&adap->stats_lock);
+ 	for (i = 0; i < adap->params.arch.nchan; i++)
+ 		t4_get_fcoe_stats(adap, i, &stats[i], false);
+ 	spin_unlock(&adap->stats_lock);
+ 
+ 	PRINT_CH_STATS2("fcoe_octets_ddp", octets_ddp);
+ 	PRINT_CH_STATS2("fcoe_frames_ddp", frames_ddp);
+ 	PRINT_CH_STATS2("fcoe_frames_drop", frames_drop);
+ }
+ 
+ #undef PRINT_CH_STATS2
+ #undef PRINT_CH_STATS
+ #undef PRINT_ADAP_STATS
+ 
+ static int tp_stats_show(struct seq_file *seq, void *v)
+ {
+ 	struct adapter *adap = seq->private;
+ 
+ 	seq_puts(seq, "\n--------Adapter Stats--------\n");
+ 	show_tcp_stats(seq);
+ 	show_ddp_stats(seq);
+ 	show_rdma_stats(seq);
+ 	show_tp_err_adapter_stats(seq);
+ 
+ 	seq_puts(seq, "\n-------- Channel Stats --------\n");
+ 	if (adap->params.arch.nchan == NCHAN)
+ 		seq_printf(seq, "%-25s %-20s %-20s %-20s %-20s\n",
+ 			   " ", "channel 0", "channel 1",
+ 			   "channel 2", "channel 3");
+ 	else
+ 		seq_printf(seq, "%-25s %-20s %-20s\n",
+ 			   " ", "channel 0", "channel 1");
+ 	show_cpl_stats(seq);
+ 	show_tp_err_channel_stats(seq);
+ 	show_fcoe_stats(seq);
+ 
+ 	return 0;
+ }
+ DEFINE_SHOW_ATTRIBUTE(tp_stats);
+ 
++>>>>>>> b09026c6913e (cxgb4: remove DEFINE_SIMPLE_DEBUGFS_FILE())
  /* Add an array of Debug FS files.
   */
  void add_debugfs_files(struct adapter *adap,
@@@ -3217,58 -3532,63 +3561,118 @@@ int t4_setup_debugfs(struct adapter *ad
  	struct dentry *de;
  
  	static struct t4_debugfs_entry t4_debugfs_files[] = {
++<<<<<<< HEAD
 +		{ "cim_la", &cim_la_fops, S_IRUSR, 0 },
 +		{ "cim_pif_la", &cim_pif_la_fops, S_IRUSR, 0 },
 +		{ "cim_ma_la", &cim_ma_la_fops, S_IRUSR, 0 },
 +		{ "cim_qcfg", &cim_qcfg_fops, S_IRUSR, 0 },
 +		{ "clk", &clk_debugfs_fops, S_IRUSR, 0 },
 +		{ "devlog", &devlog_fops, S_IRUSR, 0 },
 +		{ "mboxlog", &mboxlog_fops, S_IRUSR, 0 },
 +		{ "mbox0", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 0 },
 +		{ "mbox1", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 1 },
 +		{ "mbox2", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 2 },
 +		{ "mbox3", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 3 },
 +		{ "mbox4", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 4 },
 +		{ "mbox5", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 5 },
 +		{ "mbox6", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 6 },
 +		{ "mbox7", &mbox_debugfs_fops, S_IRUSR | S_IWUSR, 7 },
 +		{ "trace0", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 0 },
 +		{ "trace1", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 1 },
 +		{ "trace2", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 2 },
 +		{ "trace3", &mps_trc_debugfs_fops, S_IRUSR | S_IWUSR, 3 },
 +		{ "l2t", &t4_l2t_fops, S_IRUSR, 0},
 +		{ "mps_tcam", &mps_tcam_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss", &rss_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss_config", &rss_config_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss_key", &rss_key_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss_pf_config", &rss_pf_config_debugfs_fops, S_IRUSR, 0 },
 +		{ "rss_vf_config", &rss_vf_config_debugfs_fops, S_IRUSR, 0 },
 +		{ "sge_qinfo", &sge_qinfo_debugfs_fops, S_IRUSR, 0 },
 +		{ "ibq_tp0",  &cim_ibq_fops, S_IRUSR, 0 },
 +		{ "ibq_tp1",  &cim_ibq_fops, S_IRUSR, 1 },
 +		{ "ibq_ulp",  &cim_ibq_fops, S_IRUSR, 2 },
 +		{ "ibq_sge0", &cim_ibq_fops, S_IRUSR, 3 },
 +		{ "ibq_sge1", &cim_ibq_fops, S_IRUSR, 4 },
 +		{ "ibq_ncsi", &cim_ibq_fops, S_IRUSR, 5 },
 +		{ "obq_ulp0", &cim_obq_fops, S_IRUSR, 0 },
 +		{ "obq_ulp1", &cim_obq_fops, S_IRUSR, 1 },
 +		{ "obq_ulp2", &cim_obq_fops, S_IRUSR, 2 },
 +		{ "obq_ulp3", &cim_obq_fops, S_IRUSR, 3 },
 +		{ "obq_sge",  &cim_obq_fops, S_IRUSR, 4 },
 +		{ "obq_ncsi", &cim_obq_fops, S_IRUSR, 5 },
 +		{ "tp_la", &tp_la_fops, S_IRUSR, 0 },
 +		{ "ulprx_la", &ulprx_la_fops, S_IRUSR, 0 },
 +		{ "sensors", &sensors_debugfs_fops, S_IRUSR, 0 },
 +		{ "pm_stats", &pm_stats_debugfs_fops, S_IRUSR, 0 },
 +		{ "tx_rate", &tx_rate_debugfs_fops, S_IRUSR, 0 },
 +		{ "cctrl", &cctrl_tbl_debugfs_fops, S_IRUSR, 0 },
 +#if IS_ENABLED(CONFIG_IPV6)
 +		{ "clip_tbl", &clip_tbl_debugfs_fops, S_IRUSR, 0 },
 +#endif
 +		{ "tids", &tid_info_debugfs_fops, S_IRUSR, 0},
 +		{ "blocked_fl", &blocked_fl_fops, S_IRUSR | S_IWUSR, 0 },
 +		{ "meminfo", &meminfo_fops, S_IRUSR, 0 },
 +		{ "crypto", &chcr_stats_debugfs_fops, S_IRUSR, 0 },
++=======
+ 		{ "cim_la", &cim_la_fops, 0400, 0 },
+ 		{ "cim_pif_la", &cim_pif_la_fops, 0400, 0 },
+ 		{ "cim_ma_la", &cim_ma_la_fops, 0400, 0 },
+ 		{ "cim_qcfg", &cim_qcfg_fops, 0400, 0 },
+ 		{ "clk", &clk_fops, 0400, 0 },
+ 		{ "devlog", &devlog_fops, 0400, 0 },
+ 		{ "mboxlog", &mboxlog_fops, 0400, 0 },
+ 		{ "mbox0", &mbox_debugfs_fops, 0600, 0 },
+ 		{ "mbox1", &mbox_debugfs_fops, 0600, 1 },
+ 		{ "mbox2", &mbox_debugfs_fops, 0600, 2 },
+ 		{ "mbox3", &mbox_debugfs_fops, 0600, 3 },
+ 		{ "mbox4", &mbox_debugfs_fops, 0600, 4 },
+ 		{ "mbox5", &mbox_debugfs_fops, 0600, 5 },
+ 		{ "mbox6", &mbox_debugfs_fops, 0600, 6 },
+ 		{ "mbox7", &mbox_debugfs_fops, 0600, 7 },
+ 		{ "trace0", &mps_trc_debugfs_fops, 0600, 0 },
+ 		{ "trace1", &mps_trc_debugfs_fops, 0600, 1 },
+ 		{ "trace2", &mps_trc_debugfs_fops, 0600, 2 },
+ 		{ "trace3", &mps_trc_debugfs_fops, 0600, 3 },
+ 		{ "l2t", &t4_l2t_fops, 0400, 0},
+ 		{ "mps_tcam", &mps_tcam_debugfs_fops, 0400, 0 },
+ 		{ "rss", &rss_debugfs_fops, 0400, 0 },
+ 		{ "rss_config", &rss_config_fops, 0400, 0 },
+ 		{ "rss_key", &rss_key_debugfs_fops, 0400, 0 },
+ 		{ "rss_pf_config", &rss_pf_config_debugfs_fops, 0400, 0 },
+ 		{ "rss_vf_config", &rss_vf_config_debugfs_fops, 0400, 0 },
+ 		{ "resources", &resources_fops, 0400, 0 },
+ #ifdef CONFIG_CHELSIO_T4_DCB
+ 		{ "dcb_info", &dcb_info_debugfs_fops, 0400, 0 },
+ #endif
+ 		{ "sge_qinfo", &sge_qinfo_debugfs_fops, 0400, 0 },
+ 		{ "ibq_tp0",  &cim_ibq_fops, 0400, 0 },
+ 		{ "ibq_tp1",  &cim_ibq_fops, 0400, 1 },
+ 		{ "ibq_ulp",  &cim_ibq_fops, 0400, 2 },
+ 		{ "ibq_sge0", &cim_ibq_fops, 0400, 3 },
+ 		{ "ibq_sge1", &cim_ibq_fops, 0400, 4 },
+ 		{ "ibq_ncsi", &cim_ibq_fops, 0400, 5 },
+ 		{ "obq_ulp0", &cim_obq_fops, 0400, 0 },
+ 		{ "obq_ulp1", &cim_obq_fops, 0400, 1 },
+ 		{ "obq_ulp2", &cim_obq_fops, 0400, 2 },
+ 		{ "obq_ulp3", &cim_obq_fops, 0400, 3 },
+ 		{ "obq_sge",  &cim_obq_fops, 0400, 4 },
+ 		{ "obq_ncsi", &cim_obq_fops, 0400, 5 },
+ 		{ "tp_la", &tp_la_fops, 0400, 0 },
+ 		{ "ulprx_la", &ulprx_la_fops, 0400, 0 },
+ 		{ "sensors", &sensors_fops, 0400, 0 },
+ 		{ "pm_stats", &pm_stats_debugfs_fops, 0400, 0 },
+ 		{ "tx_rate", &tx_rate_fops, 0400, 0 },
+ 		{ "cctrl", &cctrl_tbl_fops, 0400, 0 },
+ #if IS_ENABLED(CONFIG_IPV6)
+ 		{ "clip_tbl", &clip_tbl_fops, 0400, 0 },
+ #endif
+ 		{ "tids", &tid_info_fops, 0400, 0},
+ 		{ "blocked_fl", &blocked_fl_fops, 0600, 0 },
+ 		{ "meminfo", &meminfo_fops, 0400, 0 },
+ 		{ "crypto", &chcr_stats_fops, 0400, 0 },
+ 		{ "tp_stats", &tp_stats_fops, 0400, 0 },
++>>>>>>> b09026c6913e (cxgb4: remove DEFINE_SIMPLE_DEBUGFS_FILE())
  	};
  
  	/* Debug FS nodes common to all T5 and later adapters.
diff --cc drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
index 296dbfe60d6d,2fab87e86561..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
@@@ -2420,11 -2404,11 +2408,19 @@@ struct cxgb4vf_debugfs_entry 
  };
  
  static struct cxgb4vf_debugfs_entry debugfs_files[] = {
++<<<<<<< HEAD
 +	{ "mboxlog",    S_IRUGO, &mboxlog_fops },
 +	{ "sge_qinfo",  S_IRUGO, &sge_qinfo_debugfs_fops },
 +	{ "sge_qstats", S_IRUGO, &sge_qstats_proc_fops },
 +	{ "resources",  S_IRUGO, &resources_proc_fops },
 +	{ "interfaces", S_IRUGO, &interfaces_proc_fops },
++=======
+ 	{ "mboxlog",    0444, &mboxlog_fops },
+ 	{ "sge_qinfo",  0444, &sge_qinfo_debugfs_fops },
+ 	{ "sge_qstats", 0444, &sge_qstats_proc_fops },
+ 	{ "resources",  0444, &resources_fops },
+ 	{ "interfaces", 0444, &interfaces_proc_fops },
++>>>>>>> b09026c6913e (cxgb4: remove DEFINE_SIMPLE_DEBUGFS_FILE())
  };
  
  /*
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.h
index 23f43a0f8950..ba95e13d52da 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.h
@@ -37,19 +37,6 @@
 
 #include <linux/export.h>
 
-#define DEFINE_SIMPLE_DEBUGFS_FILE(name) \
-static int name##_open(struct inode *inode, struct file *file) \
-{ \
-	return single_open(file, name##_show, inode->i_private); \
-} \
-static const struct file_operations name##_debugfs_fops = { \
-	.owner   = THIS_MODULE, \
-	.open    = name##_open, \
-	.read    = seq_read, \
-	.llseek  = seq_lseek, \
-	.release = single_release \
-}
-
 struct t4_debugfs_entry {
 	const char *name;
 	const struct file_operations *ops;
* Unmerged path drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
