new primitive: vmemdup_user()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [mm] alsa: new primitive: vmemdup_user() (Jaroslav Kysela) [1657855]
Rebuild_FUZZ: 90.62%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 50fd2f298bef9d1f69ac755f1fdf70cd98746be2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/50fd2f29.failed

similar to memdup_user(), but does *not* guarantee that result will
be physically contiguous; use only in cases where that's not a requirement
and free it with kvfree().

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 50fd2f298bef9d1f69ac755f1fdf70cd98746be2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/util.c
diff --cc mm/util.c
index d7dcad111e23,c1250501364f..000000000000
--- a/mm/util.c
+++ b/mm/util.c
@@@ -150,96 -170,31 +151,124 @@@ void *memdup_user(const void __user *sr
  }
  EXPORT_SYMBOL(memdup_user);
  
++<<<<<<< HEAD
 +static __always_inline void *__do_krealloc(const void *p, size_t new_size,
 +					   gfp_t flags)
 +{
 +	void *ret;
 +	size_t ks = 0;
 +
 +	if (p)
 +		ks = ksize(p);
 +
 +	if (ks >= new_size)
 +		return (void *)p;
 +
 +	ret = kmalloc_track_caller(new_size, flags);
 +	if (ret && p)
 +		memcpy(ret, p, ks);
 +
 +	return ret;
 +}
 +
 +/**
 + * __krealloc - like krealloc() but don't free @p.
 + * @p: object to reallocate memory for.
 + * @new_size: how many bytes of memory are required.
 + * @flags: the type of memory to allocate.
 + *
 + * This function is like krealloc() except it never frees the originally
 + * allocated buffer. Use this if you don't want to free the buffer immediately
 + * like, for example, with RCU.
 + */
 +void *__krealloc(const void *p, size_t new_size, gfp_t flags)
 +{
 +	if (unlikely(!new_size))
 +		return ZERO_SIZE_PTR;
 +
 +	return __do_krealloc(p, new_size, flags);
 +
 +}
 +EXPORT_SYMBOL(__krealloc);
 +
 +/**
 + * krealloc - reallocate memory. The contents will remain unchanged.
 + * @p: object to reallocate memory for.
 + * @new_size: how many bytes of memory are required.
 + * @flags: the type of memory to allocate.
 + *
 + * The contents of the object pointed to are preserved up to the
 + * lesser of the new and old sizes.  If @p is %NULL, krealloc()
 + * behaves exactly like kmalloc().  If @new_size is 0 and @p is not a
 + * %NULL pointer, the object pointed to is freed.
 + */
 +void *krealloc(const void *p, size_t new_size, gfp_t flags)
 +{
 +	void *ret;
 +
 +	if (unlikely(!new_size)) {
 +		kfree(p);
 +		return ZERO_SIZE_PTR;
 +	}
 +
 +	ret = __do_krealloc(p, new_size, flags);
 +	if (ret && p != ret)
 +		kfree(p);
 +
 +	return ret;
 +}
 +EXPORT_SYMBOL(krealloc);
 +
 +/**
 + * kzfree - like kfree but zero memory
 + * @p: object to free memory of
 + *
 + * The memory of the object @p points to is zeroed before freed.
 + * If @p is %NULL, kzfree() does nothing.
 + *
 + * Note: this function zeroes the whole allocated buffer which can be a good
 + * deal bigger than the requested buffer size passed to kmalloc(). So be
 + * careful when using this function in performance sensitive code.
 + */
 +void kzfree(const void *p)
 +{
 +	size_t ks;
 +	void *mem = (void *)p;
 +
 +	if (unlikely(ZERO_OR_NULL_PTR(mem)))
 +		return;
 +	ks = ksize(mem);
 +	memset(mem, 0, ks);
 +	kfree(mem);
 +}
 +EXPORT_SYMBOL(kzfree);
++=======
+ /**
+  * vmemdup_user - duplicate memory region from user space
+  *
+  * @src: source address in user space
+  * @len: number of bytes to copy
+  *
+  * Returns an ERR_PTR() on failure.  Result may be not
+  * physically contiguous.  Use kvfree() to free.
+  */
+ void *vmemdup_user(const void __user *src, size_t len)
+ {
+ 	void *p;
+ 
+ 	p = kvmalloc(len, GFP_USER);
+ 	if (!p)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	if (copy_from_user(p, src, len)) {
+ 		kvfree(p);
+ 		return ERR_PTR(-EFAULT);
+ 	}
+ 
+ 	return p;
+ }
+ EXPORT_SYMBOL(vmemdup_user);
++>>>>>>> 50fd2f298bef (new primitive: vmemdup_user())
  
  /*
   * strndup_user - duplicate an existing string from user space
diff --git a/include/linux/string.h b/include/linux/string.h
index 31c64befcec8..f1ed10e8eae3 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -10,6 +10,7 @@
 
 extern char *strndup_user(const char __user *, long);
 extern void *memdup_user(const void __user *, size_t);
+extern void *vmemdup_user(const void __user *, size_t);
 extern void *memdup_user_nul(const void __user *, size_t);
 
 /*
* Unmerged path mm/util.c
