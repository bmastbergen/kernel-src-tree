tipc: remove an unnecessary NULL check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] lpfc: remove an unnecessary NULL check (Dick Kennedy) [1642905]
Rebuild_FUZZ: 94.74%
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit b43586576e54609f7970096478cf4113de18a4db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b4358657.failed

This is never called with a NULL "buf" and anyway, we dereference 's' on
the lines before so it would Oops before we reach the check.

	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Acked-by: Ying Xue <ying.xue@windriver.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b43586576e54609f7970096478cf4113de18a4db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tipc/subscr.c
diff --cc net/tipc/subscr.c
index 6b42d47029af,0dd02244e21d..000000000000
--- a/net/tipc/subscr.c
+++ b/net/tipc/subscr.c
@@@ -348,196 -275,110 +348,200 @@@ static struct tipc_subscription *subscr
  	return sub;
  }
  
 -static void tipc_subscrp_subscribe(struct net *net, struct tipc_subscr *s,
 -				   struct tipc_subscriber *subscriber, int swap)
 +/**
 + * subscr_conn_shutdown_event - handle termination request from subscriber
 + *
 + * Called with subscriber's server port unlocked.
 + */
 +static void subscr_conn_shutdown_event(void *usr_handle,
 +				       u32 port_ref,
 +				       struct sk_buff **buf,
 +				       unsigned char const *data,
 +				       unsigned int size,
 +				       int reason)
  {
 -	struct tipc_net *tn = net_generic(net, tipc_net_id);
 -	struct tipc_subscription *sub = NULL;
 -	u32 timeout;
 -
 -	sub = tipc_subscrp_create(net, s, swap);
 -	if (!sub)
 -		return tipc_conn_terminate(tn->topsrv, subscriber->conid);
 -
 -	spin_lock_bh(&subscriber->lock);
 -	list_add(&sub->subscrp_list, &subscriber->subscrp_list);
 -	tipc_subscrb_get(subscriber);
 -	sub->subscriber = subscriber;
 -	tipc_nametbl_subscribe(sub);
 -	spin_unlock_bh(&subscriber->lock);
 -
 -	timeout = htohl(sub->evt.s.timeout, swap);
 -	if (timeout == TIPC_WAIT_FOREVER)
 +	struct tipc_subscriber *subscriber = usr_handle;
 +	spinlock_t *subscriber_lock;
 +
 +	if (tipc_port_lock(port_ref) == NULL)
  		return;
  
 -	setup_timer(&sub->timer, tipc_subscrp_timeout, (unsigned long)sub);
 -	mod_timer(&sub->timer, jiffies + msecs_to_jiffies(timeout));
 +	subscriber_lock = subscriber->lock;
 +	subscr_terminate(subscriber);
 +	spin_unlock_bh(subscriber_lock);
  }
  
 -/* Handle one termination request for the subscriber */
 -static void tipc_subscrb_release_cb(int conid, void *usr_data)
 +/**
 + * subscr_conn_msg_event - handle new subscription request from subscriber
 + *
 + * Called with subscriber's server port unlocked.
 + */
 +static void subscr_conn_msg_event(void *usr_handle,
 +				  u32 port_ref,
 +				  struct sk_buff **buf,
 +				  const unchar *data,
 +				  u32 size)
  {
 -	tipc_subscrb_delete((struct tipc_subscriber *)usr_data);
 +	struct tipc_subscriber *subscriber = usr_handle;
 +	spinlock_t *subscriber_lock;
 +	struct tipc_subscription *sub;
 +
 +	/*
 +	 * Lock subscriber's server port (& make a local copy of lock pointer,
 +	 * in case subscriber is deleted while processing subscription request)
 +	 */
 +	if (tipc_port_lock(port_ref) == NULL)
 +		return;
 +
 +	subscriber_lock = subscriber->lock;
 +
 +	if (size != sizeof(struct tipc_subscr)) {
 +		subscr_terminate(subscriber);
 +		spin_unlock_bh(subscriber_lock);
 +	} else {
 +		sub = subscr_subscribe((struct tipc_subscr *)data, subscriber);
 +		spin_unlock_bh(subscriber_lock);
 +		if (sub != NULL) {
 +
 +			/*
 +			 * We must release the server port lock before adding a
 +			 * subscription to the name table since TIPC needs to be
 +			 * able to (re)acquire the port lock if an event message
 +			 * issued by the subscription process is rejected and
 +			 * returned.  The subscription cannot be deleted while
 +			 * it is being added to the name table because:
 +			 * a) the single-threading of the native API port code
 +			 *    ensures the subscription cannot be cancelled and
 +			 *    the subscriber connection cannot be broken, and
 +			 * b) the name table lock ensures the subscription
 +			 *    timeout code cannot delete the subscription,
 +			 * so the subscription object is still protected.
 +			 */
 +			tipc_nametbl_subscribe(sub);
 +		}
 +	}
  }
  
 -/* Handle one request to create a new subscription for the subscriber */
 -static void tipc_subscrb_rcv_cb(struct net *net, int conid,
 -				struct sockaddr_tipc *addr, void *usr_data,
 -				void *buf, size_t len)
 +/**
 + * subscr_named_msg_event - handle request to establish a new subscriber
 + */
 +static void subscr_named_msg_event(void *usr_handle,
 +				   u32 port_ref,
 +				   struct sk_buff **buf,
 +				   const unchar *data,
 +				   u32 size,
 +				   u32 importance,
 +				   struct tipc_portid const *orig,
 +				   struct tipc_name_seq const *dest)
  {
 -	struct tipc_subscriber *subscriber = usr_data;
 -	struct tipc_subscr *s = (struct tipc_subscr *)buf;
 -	int swap;
 -
 -	/* Determine subscriber's endianness */
 -	swap = !(s->filter & (TIPC_SUB_PORTS | TIPC_SUB_SERVICE |
 -			      TIPC_SUB_CANCEL));
 +	struct tipc_subscriber *subscriber;
 +	u32 server_port_ref;
  
 -	/* Detect & process a subscription cancellation request */
 -	if (s->filter & htohl(TIPC_SUB_CANCEL, swap)) {
 -		s->filter &= ~htohl(TIPC_SUB_CANCEL, swap);
 -		return tipc_subscrp_cancel(s, subscriber);
 +	/* Create subscriber object */
 +	subscriber = kzalloc(sizeof(struct tipc_subscriber), GFP_ATOMIC);
 +	if (subscriber == NULL) {
 +		pr_warn("Subscriber rejected, no memory\n");
 +		return;
 +	}
 +	INIT_LIST_HEAD(&subscriber->subscription_list);
 +	INIT_LIST_HEAD(&subscriber->subscriber_list);
 +
 +	/* Create server port & establish connection to subscriber */
 +	tipc_createport(subscriber,
 +			importance,
 +			NULL,
 +			NULL,
 +			subscr_conn_shutdown_event,
 +			NULL,
 +			NULL,
 +			subscr_conn_msg_event,
 +			NULL,
 +			&subscriber->port_ref);
 +	if (subscriber->port_ref == 0) {
 +		pr_warn("Subscriber rejected, unable to create port\n");
 +		kfree(subscriber);
 +		return;
  	}
 +	tipc_connect(subscriber->port_ref, orig);
  
 -	tipc_subscrp_subscribe(net, s, subscriber, swap);
 -}
 +	/* Lock server port (& save lock address for future use) */
 +	subscriber->lock = tipc_port_lock(subscriber->port_ref)->lock;
  
 -/* Handle one request to establish a new subscriber */
 -static void *tipc_subscrb_connect_cb(int conid)
 -{
 -	return (void *)tipc_subscrb_create(conid);
 +	/* Add subscriber to topology server's subscriber list */
 +	spin_lock_bh(&topsrv.lock);
 +	list_add(&subscriber->subscriber_list, &topsrv.subscriber_list);
 +	spin_unlock_bh(&topsrv.lock);
 +
 +	/* Unlock server port */
 +	server_port_ref = subscriber->port_ref;
 +	spin_unlock_bh(subscriber->lock);
 +
 +	/* Send an ACK- to complete connection handshaking */
 +	tipc_send(server_port_ref, 0, NULL, 0);
 +
 +	/* Handle optional subscription request */
 +	if (size != 0) {
 +		subscr_conn_msg_event(subscriber, server_port_ref,
 +				      buf, data, size);
 +	}
  }
  
 -int tipc_topsrv_start(struct net *net)
 +int tipc_subscr_start(void)
  {
 -	struct tipc_net *tn = net_generic(net, tipc_net_id);
 -	const char name[] = "topology_server";
 -	struct tipc_server *topsrv;
 -	struct sockaddr_tipc *saddr;
 -
 -	saddr = kzalloc(sizeof(*saddr), GFP_ATOMIC);
 -	if (!saddr)
 -		return -ENOMEM;
 -	saddr->family			= AF_TIPC;
 -	saddr->addrtype			= TIPC_ADDR_NAMESEQ;
 -	saddr->addr.nameseq.type	= TIPC_TOP_SRV;
 -	saddr->addr.nameseq.lower	= TIPC_TOP_SRV;
 -	saddr->addr.nameseq.upper	= TIPC_TOP_SRV;
 -	saddr->scope			= TIPC_NODE_SCOPE;
 -
 -	topsrv = kzalloc(sizeof(*topsrv), GFP_ATOMIC);
 -	if (!topsrv) {
 -		kfree(saddr);
 -		return -ENOMEM;
 +	struct tipc_name_seq seq = {TIPC_TOP_SRV, TIPC_TOP_SRV, TIPC_TOP_SRV};
 +	int res;
 +
 +	spin_lock_init(&topsrv.lock);
 +	INIT_LIST_HEAD(&topsrv.subscriber_list);
 +
 +	res = tipc_createport(NULL,
 +			      TIPC_CRITICAL_IMPORTANCE,
 +			      NULL,
 +			      NULL,
 +			      NULL,
 +			      NULL,
 +			      subscr_named_msg_event,
 +			      NULL,
 +			      NULL,
 +			      &topsrv.setup_port);
 +	if (res)
 +		goto failed;
 +
 +	res = tipc_publish(topsrv.setup_port, TIPC_NODE_SCOPE, &seq);
 +	if (res) {
 +		tipc_deleteport(topsrv.setup_port);
 +		topsrv.setup_port = 0;
 +		goto failed;
  	}
 -	topsrv->net			= net;
 -	topsrv->saddr			= saddr;
 -	topsrv->imp			= TIPC_CRITICAL_IMPORTANCE;
 -	topsrv->type			= SOCK_SEQPACKET;
 -	topsrv->max_rcvbuf_size		= sizeof(struct tipc_subscr);
 -	topsrv->tipc_conn_recvmsg	= tipc_subscrb_rcv_cb;
 -	topsrv->tipc_conn_new		= tipc_subscrb_connect_cb;
 -	topsrv->tipc_conn_release	= tipc_subscrb_release_cb;
 -
 -	strncpy(topsrv->name, name, strlen(name) + 1);
 -	tn->topsrv = topsrv;
 -	atomic_set(&tn->subscription_count, 0);
 -
 -	return tipc_server_start(topsrv);
 +
++<<<<<<< HEAD
 +	return 0;
 +
 +failed:
 +	pr_err("Failed to create subscription service\n");
 +	return res;
++=======
++	tipc_subscrp_subscribe(net, s, subscriber, swap);
++>>>>>>> b43586576e54 (tipc: remove an unnecessary NULL check)
  }
  
 -void tipc_topsrv_stop(struct net *net)
 +void tipc_subscr_stop(void)
  {
 -	struct tipc_net *tn = net_generic(net, tipc_net_id);
 -	struct tipc_server *topsrv = tn->topsrv;
 -
 -	tipc_server_stop(topsrv);
 -	kfree(topsrv->saddr);
 -	kfree(topsrv);
 +	struct tipc_subscriber *subscriber;
 +	struct tipc_subscriber *subscriber_temp;
 +	spinlock_t *subscriber_lock;
 +
 +	if (topsrv.setup_port) {
 +		tipc_deleteport(topsrv.setup_port);
 +		topsrv.setup_port = 0;
 +
 +		list_for_each_entry_safe(subscriber, subscriber_temp,
 +					 &topsrv.subscriber_list,
 +					 subscriber_list) {
 +			subscriber_lock = subscriber->lock;
 +			spin_lock_bh(subscriber_lock);
 +			subscr_terminate(subscriber);
 +			spin_unlock_bh(subscriber_lock);
 +		}
 +	}
  }
* Unmerged path net/tipc/subscr.c
