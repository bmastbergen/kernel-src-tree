s390/bitops: add for_each_set_bit_inv helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [s390] bitops: add for_each_set_bit_inv helper (Yauheni Kaliuta) [1691710]
Rebuild_FUZZ: 93.98%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit 09214545c4a40943ecb6cedc511cd4bd709c85a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/09214545.failed

Same helper function like for_each_set_bit in generic code.

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 09214545c4a40943ecb6cedc511cd4bd709c85a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/bitops.h
diff --cc arch/s390/include/asm/bitops.h
index 6038349c8410,e7a185407182..000000000000
--- a/arch/s390/include/asm/bitops.h
+++ b/arch/s390/include/asm/bitops.h
@@@ -439,18 -245,96 +439,57 @@@ static inline unsigned long __load_ulon
  }
  
  /*
 - * Functions which use MSB0 bit numbering.
 - * The bits are numbered:
 - *   |0..............63|64............127|128...........191|192...........255|
 + * The various find bit functions.
   */
 -unsigned long find_first_bit_inv(const unsigned long *addr, unsigned long size);
 -unsigned long find_next_bit_inv(const unsigned long *addr, unsigned long size,
 -				unsigned long offset);
  
++<<<<<<< HEAD
 +/*
 + * ffz - find first zero in word.
 + * @word: The word to search
++=======
+ #define for_each_set_bit_inv(bit, addr, size)				\
+ 	for ((bit) = find_first_bit_inv((addr), (size));		\
+ 	     (bit) < (size);						\
+ 	     (bit) = find_next_bit_inv((addr), (size), (bit) + 1))
+ 
+ static inline void set_bit_inv(unsigned long nr, volatile unsigned long *ptr)
+ {
+ 	return set_bit(nr ^ (BITS_PER_LONG - 1), ptr);
+ }
+ 
+ static inline void clear_bit_inv(unsigned long nr, volatile unsigned long *ptr)
+ {
+ 	return clear_bit(nr ^ (BITS_PER_LONG - 1), ptr);
+ }
+ 
+ static inline void __set_bit_inv(unsigned long nr, volatile unsigned long *ptr)
+ {
+ 	return __set_bit(nr ^ (BITS_PER_LONG - 1), ptr);
+ }
+ 
+ static inline void __clear_bit_inv(unsigned long nr, volatile unsigned long *ptr)
+ {
+ 	return __clear_bit(nr ^ (BITS_PER_LONG - 1), ptr);
+ }
+ 
+ static inline int test_bit_inv(unsigned long nr,
+ 			       const volatile unsigned long *ptr)
+ {
+ 	return test_bit(nr ^ (BITS_PER_LONG - 1), ptr);
+ }
+ 
+ #ifdef CONFIG_HAVE_MARCH_Z9_109_FEATURES
+ 
+ /**
+  * __flogr - find leftmost one
+  * @word - The word to search
++>>>>>>> 09214545c4a4 (s390/bitops: add for_each_set_bit_inv helper)
   *
 - * Returns the bit number of the most significant bit set,
 - * where the most significant bit has bit number 0.
 - * If no bit is set this function returns 64.
 + * Undefined if no zero exists, so code should check against ~0UL first.
   */
 -static inline unsigned char __flogr(unsigned long word)
 -{
 -	if (__builtin_constant_p(word)) {
 -		unsigned long bit = 0;
 -
 -		if (!word)
 -			return 64;
 -		if (!(word & 0xffffffff00000000UL)) {
 -			word <<= 32;
 -			bit += 32;
 -		}
 -		if (!(word & 0xffff000000000000UL)) {
 -			word <<= 16;
 -			bit += 16;
 -		}
 -		if (!(word & 0xff00000000000000UL)) {
 -			word <<= 8;
 -			bit += 8;
 -		}
 -		if (!(word & 0xf000000000000000UL)) {
 -			word <<= 4;
 -			bit += 4;
 -		}
 -		if (!(word & 0xc000000000000000UL)) {
 -			word <<= 2;
 -			bit += 2;
 -		}
 -		if (!(word & 0x8000000000000000UL)) {
 -			word <<= 1;
 -			bit += 1;
 -		}
 -		return bit;
 -	} else {
 -		register unsigned long bit asm("4") = word;
 -		register unsigned long out asm("5");
 -
 -		asm volatile(
 -			"       flogr   %[bit],%[bit]\n"
 -			: [bit] "+d" (bit), [out] "=d" (out) : : "cc");
 -		return bit;
 -	}
 +static inline unsigned long ffz(unsigned long word)
 +{
 +	return __ffz_word(0, word);
  }
  
  /**
* Unmerged path arch/s390/include/asm/bitops.h
