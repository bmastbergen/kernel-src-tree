netfilter: nat: limit port clash resolution attempts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Florian Westphal <fw@strlen.de>
commit a504b703bb1da526a01593da0e4be2af9d9f5fa8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a504b703.failed

In case almost or all available ports are taken, clash resolution can
take a very long time, resulting in soft lockup.

This can happen when many to-be-natted hosts connect to same
destination:port (e.g. a proxy) and all connections pass the same SNAT.

Pick a random offset in the acceptable range, then try ever smaller
number of adjacent port numbers, until either the limit is reached or a
useable port was found.  This results in at most 248 attempts
(128 + 64 + 32 + 16 + 8, i.e. 4 restarts with new search offset)
instead of 64000+,

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit a504b703bb1da526a01593da0e4be2af9d9f5fa8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_nat_proto_common.c
diff --cc net/netfilter/nf_nat_proto_common.c
index 932d8a1a91d1,dcb5d11688a1..000000000000
--- a/net/netfilter/nf_nat_proto_common.c
+++ b/net/netfilter/nf_nat_proto_common.c
@@@ -36,14 -36,14 +36,15 @@@ EXPORT_SYMBOL_GPL(nf_nat_l4proto_in_ran
  
  void nf_nat_l4proto_unique_tuple(const struct nf_nat_l3proto *l3proto,
  				 struct nf_conntrack_tuple *tuple,
 -				 const struct nf_nat_range2 *range,
 +				 const struct nf_nat_range *range,
  				 enum nf_nat_manip_type maniptype,
 -				 const struct nf_conn *ct)
 +				 const struct nf_conn *ct,
 +				 u16 *rover)
  {
- 	unsigned int range_size, min, max, i;
+ 	unsigned int range_size, min, max, i, attempts;
  	__be16 *portptr;
- 	u_int16_t off;
+ 	u16 off;
+ 	static const unsigned int max_attempts = 128;
  
  	if (maniptype == NF_NAT_MANIP_SRC)
  		portptr = &tuple->src.u.all;
@@@ -81,20 -81,34 +82,42 @@@
  		off = l3proto->secure_port(tuple, maniptype == NF_NAT_MANIP_SRC
  						  ? tuple->dst.u.all
  						  : tuple->src.u.all);
 -	} else if (range->flags & NF_NAT_RANGE_PROTO_OFFSET) {
 -		off = (ntohs(*portptr) - ntohs(range->base_proto.all));
 -	} else {
 +	} else if (range->flags & NF_NAT_RANGE_PROTO_RANDOM_FULLY) {
  		off = prandom_u32();
 +	} else {
 +		off = *rover;
  	}
  
- 	for (i = 0; ; ++off) {
+ 	attempts = range_size;
+ 	if (attempts > max_attempts)
+ 		attempts = max_attempts;
+ 
+ 	/* We are in softirq; doing a search of the entire range risks
+ 	 * soft lockup when all tuples are already used.
+ 	 *
+ 	 * If we can't find any free port from first offset, pick a new
+ 	 * one and try again, with ever smaller search window.
+ 	 */
+ another_round:
+ 	for (i = 0; i < attempts; i++, off++) {
  		*portptr = htons(min + off % range_size);
++<<<<<<< HEAD
 +		if (++i != range_size && nf_nat_used_tuple(tuple, ct))
 +			continue;
 +		if (!(range->flags & NF_NAT_RANGE_PROTO_RANDOM_ALL))
 +			*rover = off;
 +		return;
++=======
+ 		if (!nf_nat_used_tuple(tuple, ct))
+ 			return;
++>>>>>>> a504b703bb1d (netfilter: nat: limit port clash resolution attempts)
  	}
+ 
+ 	if (attempts >= range_size || attempts < 16)
+ 		return;
+ 	attempts /= 2;
+ 	off = prandom_u32();
+ 	goto another_round;
  }
  EXPORT_SYMBOL_GPL(nf_nat_l4proto_unique_tuple);
  
* Unmerged path net/netfilter/nf_nat_proto_common.c
