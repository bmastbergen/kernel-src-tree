treewide: Use array_size() in vzalloc()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Kees Cook <keescook@chromium.org>
commit fad953ce0b22cfd352a9a90b070c34b8791e6868
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fad953ce.failed

The vzalloc() function has no 2-factor argument form, so multiplication
factors need to be wrapped in array_size(). This patch replaces cases of:

        vzalloc(a * b)

with:
        vzalloc(array_size(a, b))

as well as handling cases of:

        vzalloc(a * b * c)

with:

        vzalloc(array3_size(a, b, c))

This does, however, attempt to ignore constant size factors like:

        vzalloc(4 * 1024)

though any constants defined via macros get caught up in the conversion.

Any factors with a sizeof() of "unsigned char", "char", and "u8" were
dropped, since they're redundant.

The Coccinelle script used for this was:

// Fix redundant parens around sizeof().
@@
type TYPE;
expression THING, E;
@@

(
  vzalloc(
-	(sizeof(TYPE)) * E
+	sizeof(TYPE) * E
  , ...)
|
  vzalloc(
-	(sizeof(THING)) * E
+	sizeof(THING) * E
  , ...)
)

// Drop single-byte sizes and redundant parens.
@@
expression COUNT;
typedef u8;
typedef __u8;
@@

(
  vzalloc(
-	sizeof(u8) * (COUNT)
+	COUNT
  , ...)
|
  vzalloc(
-	sizeof(__u8) * (COUNT)
+	COUNT
  , ...)
|
  vzalloc(
-	sizeof(char) * (COUNT)
+	COUNT
  , ...)
|
  vzalloc(
-	sizeof(unsigned char) * (COUNT)
+	COUNT
  , ...)
|
  vzalloc(
-	sizeof(u8) * COUNT
+	COUNT
  , ...)
|
  vzalloc(
-	sizeof(__u8) * COUNT
+	COUNT
  , ...)
|
  vzalloc(
-	sizeof(char) * COUNT
+	COUNT
  , ...)
|
  vzalloc(
-	sizeof(unsigned char) * COUNT
+	COUNT
  , ...)
)

// 2-factor product with sizeof(type/expression) and identifier or constant.
@@
type TYPE;
expression THING;
identifier COUNT_ID;
constant COUNT_CONST;
@@

(
  vzalloc(
-	sizeof(TYPE) * (COUNT_ID)
+	array_size(COUNT_ID, sizeof(TYPE))
  , ...)
|
  vzalloc(
-	sizeof(TYPE) * COUNT_ID
+	array_size(COUNT_ID, sizeof(TYPE))
  , ...)
|
  vzalloc(
-	sizeof(TYPE) * (COUNT_CONST)
+	array_size(COUNT_CONST, sizeof(TYPE))
  , ...)
|
  vzalloc(
-	sizeof(TYPE) * COUNT_CONST
+	array_size(COUNT_CONST, sizeof(TYPE))
  , ...)
|
  vzalloc(
-	sizeof(THING) * (COUNT_ID)
+	array_size(COUNT_ID, sizeof(THING))
  , ...)
|
  vzalloc(
-	sizeof(THING) * COUNT_ID
+	array_size(COUNT_ID, sizeof(THING))
  , ...)
|
  vzalloc(
-	sizeof(THING) * (COUNT_CONST)
+	array_size(COUNT_CONST, sizeof(THING))
  , ...)
|
  vzalloc(
-	sizeof(THING) * COUNT_CONST
+	array_size(COUNT_CONST, sizeof(THING))
  , ...)
)

// 2-factor product, only identifiers.
@@
identifier SIZE, COUNT;
@@

  vzalloc(
-	SIZE * COUNT
+	array_size(COUNT, SIZE)
  , ...)

// 3-factor product with 1 sizeof(type) or sizeof(expression), with
// redundant parens removed.
@@
expression THING;
identifier STRIDE, COUNT;
type TYPE;
@@

(
  vzalloc(
-	sizeof(TYPE) * (COUNT) * (STRIDE)
+	array3_size(COUNT, STRIDE, sizeof(TYPE))
  , ...)
|
  vzalloc(
-	sizeof(TYPE) * (COUNT) * STRIDE
+	array3_size(COUNT, STRIDE, sizeof(TYPE))
  , ...)
|
  vzalloc(
-	sizeof(TYPE) * COUNT * (STRIDE)
+	array3_size(COUNT, STRIDE, sizeof(TYPE))
  , ...)
|
  vzalloc(
-	sizeof(TYPE) * COUNT * STRIDE
+	array3_size(COUNT, STRIDE, sizeof(TYPE))
  , ...)
|
  vzalloc(
-	sizeof(THING) * (COUNT) * (STRIDE)
+	array3_size(COUNT, STRIDE, sizeof(THING))
  , ...)
|
  vzalloc(
-	sizeof(THING) * (COUNT) * STRIDE
+	array3_size(COUNT, STRIDE, sizeof(THING))
  , ...)
|
  vzalloc(
-	sizeof(THING) * COUNT * (STRIDE)
+	array3_size(COUNT, STRIDE, sizeof(THING))
  , ...)
|
  vzalloc(
-	sizeof(THING) * COUNT * STRIDE
+	array3_size(COUNT, STRIDE, sizeof(THING))
  , ...)
)

// 3-factor product with 2 sizeof(variable), with redundant parens removed.
@@
expression THING1, THING2;
identifier COUNT;
type TYPE1, TYPE2;
@@

(
  vzalloc(
-	sizeof(TYPE1) * sizeof(TYPE2) * COUNT
+	array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
  , ...)
|
  vzalloc(
-	sizeof(TYPE1) * sizeof(THING2) * (COUNT)
+	array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
  , ...)
|
  vzalloc(
-	sizeof(THING1) * sizeof(THING2) * COUNT
+	array3_size(COUNT, sizeof(THING1), sizeof(THING2))
  , ...)
|
  vzalloc(
-	sizeof(THING1) * sizeof(THING2) * (COUNT)
+	array3_size(COUNT, sizeof(THING1), sizeof(THING2))
  , ...)
|
  vzalloc(
-	sizeof(TYPE1) * sizeof(THING2) * COUNT
+	array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
  , ...)
|
  vzalloc(
-	sizeof(TYPE1) * sizeof(THING2) * (COUNT)
+	array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
  , ...)
)

// 3-factor product, only identifiers, with redundant parens removed.
@@
identifier STRIDE, SIZE, COUNT;
@@

(
  vzalloc(
-	(COUNT) * STRIDE * SIZE
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  vzalloc(
-	COUNT * (STRIDE) * SIZE
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  vzalloc(
-	COUNT * STRIDE * (SIZE)
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  vzalloc(
-	(COUNT) * (STRIDE) * SIZE
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  vzalloc(
-	COUNT * (STRIDE) * (SIZE)
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  vzalloc(
-	(COUNT) * STRIDE * (SIZE)
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  vzalloc(
-	(COUNT) * (STRIDE) * (SIZE)
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  vzalloc(
-	COUNT * STRIDE * SIZE
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
)

// Any remaining multi-factor products, first at least 3-factor products
// when they're not all constants...
@@
expression E1, E2, E3;
constant C1, C2, C3;
@@

(
  vzalloc(C1 * C2 * C3, ...)
|
  vzalloc(
-	E1 * E2 * E3
+	array3_size(E1, E2, E3)
  , ...)
)

// And then all remaining 2 factors products when they're not all constants.
@@
expression E1, E2;
constant C1, C2;
@@

(
  vzalloc(C1 * C2, ...)
|
  vzalloc(
-	E1 * E2
+	array_size(E1, E2)
  , ...)
)

	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit fad953ce0b22cfd352a9a90b070c34b8791e6868)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/zram/zram_drv.c
#	drivers/dma/mic_x100_dma.c
#	drivers/infiniband/hw/hns/hns_roce_mr.c
#	drivers/lightnvm/pblk-init.c
#	drivers/lightnvm/pblk-recovery.c
#	drivers/md/bcache/super.c
#	drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
#	drivers/media/pci/cx23885/cx23885-alsa.c
#	drivers/media/pci/cx25821/cx25821-alsa.c
#	drivers/media/pci/cx88/cx88-alsa.c
#	drivers/media/pci/saa7134/saa7134-alsa.c
#	drivers/media/platform/vivid/vivid-core.c
#	drivers/mtd/nand/nandsim.c
#	drivers/net/ethernet/broadcom/bnx2.c
#	drivers/net/ethernet/hisilicon/hns/hns_dsaf_main.c
#	drivers/net/ethernet/huawei/hinic/hinic_hw_cmdq.c
#	drivers/net/xen-netback/xenbus.c
#	drivers/s390/char/sclp_sd.c
#	drivers/soc/fsl/qbman/qman.c
#	drivers/staging/rtl8188eu/core/rtw_mlme.c
#	drivers/staging/rtl8723bs/core/rtw_mlme.c
#	drivers/staging/rts5208/rtsx_chip.c
#	fs/nfsd/nfscache.c
#	kernel/kexec_file.c
#	lib/test_firmware.c
#	lib/test_kmod.c
#	lib/test_rhashtable.c
#	net/core/ethtool.c
#	net/packet/af_packet.c
diff --cc drivers/block/zram/zram_drv.c
index 4987c3f4bb80,7436b2d27fa3..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -460,49 -886,31 +460,65 @@@ static void zram_meta_free(struct zram_
  	size_t index;
  
  	/* Free all pages that are still in this zram device */
 -	for (index = 0; index < num_pages; index++)
 -		zram_free_page(zram, index);
 +	for (index = 0; index < num_pages; index++) {
 +		unsigned long handle = meta->table[index].handle;
  
 -	zs_destroy_pool(zram->mem_pool);
 -	vfree(zram->table);
 -}
 +		if (!handle)
 +			continue;
  
++<<<<<<< HEAD
 +		zs_free(meta->mem_pool, handle);
++=======
+ static bool zram_meta_alloc(struct zram *zram, u64 disksize)
+ {
+ 	size_t num_pages;
+ 
+ 	num_pages = disksize >> PAGE_SHIFT;
+ 	zram->table = vzalloc(array_size(num_pages, sizeof(*zram->table)));
+ 	if (!zram->table)
+ 		return false;
+ 
+ 	zram->mem_pool = zs_create_pool(zram->disk->disk_name);
+ 	if (!zram->mem_pool) {
+ 		vfree(zram->table);
+ 		return false;
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
 +	}
 +
 +	zs_destroy_pool(meta->mem_pool);
 +	vfree(meta->table);
 +	kfree(meta);
 +}
 +
 +static struct zram_meta *zram_meta_alloc(int device_id, u64 disksize)
 +{
 +	size_t num_pages;
 +	char pool_name[8];
 +	struct zram_meta *meta = kmalloc(sizeof(*meta), GFP_KERNEL);
 +
 +	if (!meta)
 +		return NULL;
 +
 +	num_pages = disksize >> PAGE_SHIFT;
 +	meta->table = vzalloc(num_pages * sizeof(*meta->table));
 +	if (!meta->table) {
 +		pr_err("Error allocating zram address table\n");
 +		goto out_error;
 +	}
 +
 +	snprintf(pool_name, sizeof(pool_name), "zram%d", device_id);
 +	meta->mem_pool = zs_create_pool(pool_name, GFP_NOIO | __GFP_HIGHMEM);
 +	if (!meta->mem_pool) {
 +		pr_err("Error creating memory pool\n");
 +		goto out_error;
  	}
  
 -	if (!huge_class_size)
 -		huge_class_size = zs_huge_class_size(zram->mem_pool);
 -	return true;
 +	return meta;
 +
 +out_error:
 +	vfree(meta->table);
 +	kfree(meta);
 +	return NULL;
  }
  
  /*
diff --cc drivers/md/bcache/super.c
index b4713cea1913,fa4058e43202..000000000000
--- a/drivers/md/bcache/super.c
+++ b/drivers/md/bcache/super.c
@@@ -1720,26 -2021,32 +1720,35 @@@ static int cache_alloc(struct cache_sb 
  	__module_get(THIS_MODULE);
  	kobject_init(&ca->kobj, &bch_cache_ktype);
  
 -	bio_init(&ca->journal.bio, ca->journal.bio.bi_inline_vecs, 8);
 +	INIT_LIST_HEAD(&ca->discards);
  
 -	/*
 -	 * when ca->sb.njournal_buckets is not zero, journal exists,
 -	 * and in bch_journal_replay(), tree node may split,
 -	 * so bucket of RESERVE_BTREE type is needed,
 -	 * the worst situation is all journal buckets are valid journal,
 -	 * and all the keys need to replay,
 -	 * so the number of  RESERVE_BTREE type buckets should be as much
 -	 * as journal buckets
 -	 */
 -	btree_buckets = ca->sb.njournal_buckets ?: 8;
 -	free = roundup_pow_of_two(ca->sb.nbuckets) >> 10;
 +	bio_init(&ca->journal.bio);
 +	ca->journal.bio.bi_max_vecs = 8;
 +	ca->journal.bio.bi_io_vec = ca->journal.bio.bi_inline_vecs;
  
 -	if (!init_fifo(&ca->free[RESERVE_BTREE], btree_buckets, GFP_KERNEL) ||
 -	    !init_fifo_exact(&ca->free[RESERVE_PRIO], prio_buckets(ca), GFP_KERNEL) ||
 -	    !init_fifo(&ca->free[RESERVE_MOVINGGC], free, GFP_KERNEL) ||
 -	    !init_fifo(&ca->free[RESERVE_NONE], free, GFP_KERNEL) ||
 +	free = roundup_pow_of_two(ca->sb.nbuckets) >> 9;
 +	free = max_t(size_t, free, (prio_buckets(ca) + 8) * 2);
 +
 +	if (!init_fifo(&ca->free,	free, GFP_KERNEL) ||
  	    !init_fifo(&ca->free_inc,	free << 2, GFP_KERNEL) ||
 +	    !init_fifo(&ca->unused,	free << 2, GFP_KERNEL) ||
  	    !init_heap(&ca->heap,	free << 3, GFP_KERNEL) ||
++<<<<<<< HEAD
 +	    !(ca->buckets	= vzalloc(sizeof(struct bucket) *
 +					  ca->sb.nbuckets)) ||
 +	    !(ca->prio_buckets	= kzalloc(sizeof(uint64_t) * prio_buckets(ca) *
 +					  2, GFP_KERNEL)) ||
 +	    !(ca->disk_buckets	= alloc_bucket_pages(GFP_KERNEL, ca)) ||
 +	    !(ca->alloc_workqueue = alloc_workqueue("bch_allocator", 0, 1)) ||
 +	    bio_split_pool_init(&ca->bio_split_hook))
++=======
+ 	    !(ca->buckets	= vzalloc(array_size(sizeof(struct bucket),
+ 						     ca->sb.nbuckets))) ||
+ 	    !(ca->prio_buckets	= kzalloc(array3_size(sizeof(uint64_t),
+ 						      prio_buckets(ca), 2),
+ 					  GFP_KERNEL)) ||
+ 	    !(ca->disk_buckets	= alloc_bucket_pages(GFP_KERNEL, ca)))
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  		return -ENOMEM;
  
  	ca->prio_last_buckets = ca->prio_buckets + prio_buckets(ca);
diff --cc drivers/media/pci/cx23885/cx23885-alsa.c
index 554798dcedd0,db1e8ff35474..000000000000
--- a/drivers/media/pci/cx23885/cx23885-alsa.c
+++ b/drivers/media/pci/cx23885/cx23885-alsa.c
@@@ -84,6 -77,81 +84,84 @@@ MODULE_PARM_DESC(audio_debug, "enable d
  #define AUD_INT_MCHG_IRQ        (1 << 21)
  #define GP_COUNT_CONTROL_RESET	0x3
  
++<<<<<<< HEAD
++=======
+ static int cx23885_alsa_dma_init(struct cx23885_audio_dev *chip, int nr_pages)
+ {
+ 	struct cx23885_audio_buffer *buf = chip->buf;
+ 	struct page *pg;
+ 	int i;
+ 
+ 	buf->vaddr = vmalloc_32(nr_pages << PAGE_SHIFT);
+ 	if (NULL == buf->vaddr) {
+ 		dprintk(1, "vmalloc_32(%d pages) failed\n", nr_pages);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	dprintk(1, "vmalloc is at addr %p, size=%d\n",
+ 		buf->vaddr, nr_pages << PAGE_SHIFT);
+ 
+ 	memset(buf->vaddr, 0, nr_pages << PAGE_SHIFT);
+ 	buf->nr_pages = nr_pages;
+ 
+ 	buf->sglist = vzalloc(array_size(sizeof(*buf->sglist), buf->nr_pages));
+ 	if (NULL == buf->sglist)
+ 		goto vzalloc_err;
+ 
+ 	sg_init_table(buf->sglist, buf->nr_pages);
+ 	for (i = 0; i < buf->nr_pages; i++) {
+ 		pg = vmalloc_to_page(buf->vaddr + i * PAGE_SIZE);
+ 		if (NULL == pg)
+ 			goto vmalloc_to_page_err;
+ 		sg_set_page(&buf->sglist[i], pg, PAGE_SIZE, 0);
+ 	}
+ 	return 0;
+ 
+ vmalloc_to_page_err:
+ 	vfree(buf->sglist);
+ 	buf->sglist = NULL;
+ vzalloc_err:
+ 	vfree(buf->vaddr);
+ 	buf->vaddr = NULL;
+ 	return -ENOMEM;
+ }
+ 
+ static int cx23885_alsa_dma_map(struct cx23885_audio_dev *dev)
+ {
+ 	struct cx23885_audio_buffer *buf = dev->buf;
+ 
+ 	buf->sglen = dma_map_sg(&dev->pci->dev, buf->sglist,
+ 			buf->nr_pages, PCI_DMA_FROMDEVICE);
+ 
+ 	if (0 == buf->sglen) {
+ 		pr_warn("%s: cx23885_alsa_map_sg failed\n", __func__);
+ 		return -ENOMEM;
+ 	}
+ 	return 0;
+ }
+ 
+ static int cx23885_alsa_dma_unmap(struct cx23885_audio_dev *dev)
+ {
+ 	struct cx23885_audio_buffer *buf = dev->buf;
+ 
+ 	if (!buf->sglen)
+ 		return 0;
+ 
+ 	dma_unmap_sg(&dev->pci->dev, buf->sglist, buf->sglen, PCI_DMA_FROMDEVICE);
+ 	buf->sglen = 0;
+ 	return 0;
+ }
+ 
+ static int cx23885_alsa_dma_free(struct cx23885_audio_buffer *buf)
+ {
+ 	vfree(buf->sglist);
+ 	buf->sglist = NULL;
+ 	vfree(buf->vaddr);
+ 	buf->vaddr = NULL;
+ 	return 0;
+ }
+ 
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  /*
   * BOARD Specific: Sets audio DMA
   */
diff --cc drivers/media/pci/cx25821/cx25821-alsa.c
index 2dd5bcaa7e53,ef6380651c10..000000000000
--- a/drivers/media/pci/cx25821/cx25821-alsa.c
+++ b/drivers/media/pci/cx25821/cx25821-alsa.c
@@@ -142,6 -139,83 +142,86 @@@ MODULE_PARM_DESC(debug, "enable debug m
  
  #define PCI_MSK_AUD_EXT   (1 <<  4)
  #define PCI_MSK_AUD_INT   (1 <<  3)
++<<<<<<< HEAD
++=======
+ 
+ static int cx25821_alsa_dma_init(struct cx25821_audio_dev *chip, int nr_pages)
+ {
+ 	struct cx25821_audio_buffer *buf = chip->buf;
+ 	struct page *pg;
+ 	int i;
+ 
+ 	buf->vaddr = vmalloc_32(nr_pages << PAGE_SHIFT);
+ 	if (NULL == buf->vaddr) {
+ 		dprintk(1, "vmalloc_32(%d pages) failed\n", nr_pages);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	dprintk(1, "vmalloc is at addr 0x%p, size=%d\n",
+ 				buf->vaddr,
+ 				nr_pages << PAGE_SHIFT);
+ 
+ 	memset(buf->vaddr, 0, nr_pages << PAGE_SHIFT);
+ 	buf->nr_pages = nr_pages;
+ 
+ 	buf->sglist = vzalloc(array_size(sizeof(*buf->sglist), buf->nr_pages));
+ 	if (NULL == buf->sglist)
+ 		goto vzalloc_err;
+ 
+ 	sg_init_table(buf->sglist, buf->nr_pages);
+ 	for (i = 0; i < buf->nr_pages; i++) {
+ 		pg = vmalloc_to_page(buf->vaddr + i * PAGE_SIZE);
+ 		if (NULL == pg)
+ 			goto vmalloc_to_page_err;
+ 		sg_set_page(&buf->sglist[i], pg, PAGE_SIZE, 0);
+ 	}
+ 	return 0;
+ 
+ vmalloc_to_page_err:
+ 	vfree(buf->sglist);
+ 	buf->sglist = NULL;
+ vzalloc_err:
+ 	vfree(buf->vaddr);
+ 	buf->vaddr = NULL;
+ 	return -ENOMEM;
+ }
+ 
+ static int cx25821_alsa_dma_map(struct cx25821_audio_dev *dev)
+ {
+ 	struct cx25821_audio_buffer *buf = dev->buf;
+ 
+ 	buf->sglen = dma_map_sg(&dev->pci->dev, buf->sglist,
+ 			buf->nr_pages, PCI_DMA_FROMDEVICE);
+ 
+ 	if (0 == buf->sglen) {
+ 		pr_warn("%s: cx25821_alsa_map_sg failed\n", __func__);
+ 		return -ENOMEM;
+ 	}
+ 	return 0;
+ }
+ 
+ static int cx25821_alsa_dma_unmap(struct cx25821_audio_dev *dev)
+ {
+ 	struct cx25821_audio_buffer *buf = dev->buf;
+ 
+ 	if (!buf->sglen)
+ 		return 0;
+ 
+ 	dma_unmap_sg(&dev->pci->dev, buf->sglist, buf->sglen, PCI_DMA_FROMDEVICE);
+ 	buf->sglen = 0;
+ 	return 0;
+ }
+ 
+ static int cx25821_alsa_dma_free(struct cx25821_audio_buffer *buf)
+ {
+ 	vfree(buf->sglist);
+ 	buf->sglist = NULL;
+ 	vfree(buf->vaddr);
+ 	buf->vaddr = NULL;
+ 	return 0;
+ }
+ 
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  /*
   * BOARD Specific: Sets audio DMA
   */
diff --cc drivers/media/pci/cx88/cx88-alsa.c
index 6cbe6891569e,e5c3387cd1e8..000000000000
--- a/drivers/media/pci/cx88/cx88-alsa.c
+++ b/drivers/media/pci/cx88/cx88-alsa.c
@@@ -290,19 -280,97 +290,104 @@@ static irqreturn_t cx8801_irq(int irq, 
  	return IRQ_RETVAL(handled);
  }
  
 -static int cx88_alsa_dma_init(struct cx88_audio_dev *chip, int nr_pages)
 -{
 -	struct cx88_audio_buffer *buf = chip->buf;
 -	struct page *pg;
 -	int i;
  
 +static int dsp_buffer_free(snd_cx88_card_t *chip)
 +{
 +	BUG_ON(!chip->dma_size);
 +
++<<<<<<< HEAD
 +	dprintk(2,"Freeing buffer\n");
 +	videobuf_dma_unmap(&chip->pci->dev, chip->dma_risc);
 +	videobuf_dma_free(chip->dma_risc);
 +	btcx_riscmem_free(chip->pci,&chip->buf->risc);
++=======
+ 	buf->vaddr = vmalloc_32(nr_pages << PAGE_SHIFT);
+ 	if (!buf->vaddr) {
+ 		dprintk(1, "vmalloc_32(%d pages) failed\n", nr_pages);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	dprintk(1, "vmalloc is at addr %p, size=%d\n",
+ 		buf->vaddr, nr_pages << PAGE_SHIFT);
+ 
+ 	memset(buf->vaddr, 0, nr_pages << PAGE_SHIFT);
+ 	buf->nr_pages = nr_pages;
+ 
+ 	buf->sglist = vzalloc(array_size(sizeof(*buf->sglist), buf->nr_pages));
+ 	if (!buf->sglist)
+ 		goto vzalloc_err;
+ 
+ 	sg_init_table(buf->sglist, buf->nr_pages);
+ 	for (i = 0; i < buf->nr_pages; i++) {
+ 		pg = vmalloc_to_page(buf->vaddr + i * PAGE_SIZE);
+ 		if (!pg)
+ 			goto vmalloc_to_page_err;
+ 		sg_set_page(&buf->sglist[i], pg, PAGE_SIZE, 0);
+ 	}
+ 	return 0;
+ 
+ vmalloc_to_page_err:
+ 	vfree(buf->sglist);
+ 	buf->sglist = NULL;
+ vzalloc_err:
+ 	vfree(buf->vaddr);
+ 	buf->vaddr = NULL;
+ 	return -ENOMEM;
+ }
+ 
+ static int cx88_alsa_dma_map(struct cx88_audio_dev *dev)
+ {
+ 	struct cx88_audio_buffer *buf = dev->buf;
+ 
+ 	buf->sglen = dma_map_sg(&dev->pci->dev, buf->sglist,
+ 			buf->nr_pages, PCI_DMA_FROMDEVICE);
+ 
+ 	if (buf->sglen == 0) {
+ 		pr_warn("%s: cx88_alsa_map_sg failed\n", __func__);
+ 		return -ENOMEM;
+ 	}
+ 	return 0;
+ }
+ 
+ static int cx88_alsa_dma_unmap(struct cx88_audio_dev *dev)
+ {
+ 	struct cx88_audio_buffer *buf = dev->buf;
+ 
+ 	if (!buf->sglen)
+ 		return 0;
+ 
+ 	dma_unmap_sg(&dev->pci->dev, buf->sglist, buf->sglen,
+ 		     PCI_DMA_FROMDEVICE);
+ 	buf->sglen = 0;
+ 	return 0;
+ }
+ 
+ static int cx88_alsa_dma_free(struct cx88_audio_buffer *buf)
+ {
+ 	vfree(buf->sglist);
+ 	buf->sglist = NULL;
+ 	vfree(buf->vaddr);
+ 	buf->vaddr = NULL;
+ 	return 0;
+ }
+ 
+ static int dsp_buffer_free(struct cx88_audio_dev *chip)
+ {
+ 	struct cx88_riscmem *risc = &chip->buf->risc;
+ 
+ 	WARN_ON(!chip->dma_size);
+ 
+ 	dprintk(2, "Freeing buffer\n");
+ 	cx88_alsa_dma_unmap(chip);
+ 	cx88_alsa_dma_free(chip->buf);
+ 	if (risc->cpu)
+ 		pci_free_consistent(chip->pci, risc->size,
+ 				    risc->cpu, risc->dma);
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  	kfree(chip->buf);
  
 -	chip->buf = NULL;
 +	chip->dma_risc = NULL;
 +	chip->dma_size = 0;
  
  	return 0;
  }
diff --cc drivers/media/pci/saa7134/saa7134-alsa.c
index ea6980e6a2fa,b90cfde6e301..000000000000
--- a/drivers/media/pci/saa7134/saa7134-alsa.c
+++ b/drivers/media/pci/saa7134/saa7134-alsa.c
@@@ -274,6 -261,81 +274,84 @@@ static int snd_card_saa7134_capture_tri
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int saa7134_alsa_dma_init(struct saa7134_dev *dev, int nr_pages)
+ {
+ 	struct saa7134_dmasound *dma = &dev->dmasound;
+ 	struct page *pg;
+ 	int i;
+ 
+ 	dma->vaddr = vmalloc_32(nr_pages << PAGE_SHIFT);
+ 	if (NULL == dma->vaddr) {
+ 		pr_debug("vmalloc_32(%d pages) failed\n", nr_pages);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	pr_debug("vmalloc is at addr %p, size=%d\n",
+ 		 dma->vaddr, nr_pages << PAGE_SHIFT);
+ 
+ 	memset(dma->vaddr, 0, nr_pages << PAGE_SHIFT);
+ 	dma->nr_pages = nr_pages;
+ 
+ 	dma->sglist = vzalloc(array_size(sizeof(*dma->sglist), dma->nr_pages));
+ 	if (NULL == dma->sglist)
+ 		goto vzalloc_err;
+ 
+ 	sg_init_table(dma->sglist, dma->nr_pages);
+ 	for (i = 0; i < dma->nr_pages; i++) {
+ 		pg = vmalloc_to_page(dma->vaddr + i * PAGE_SIZE);
+ 		if (NULL == pg)
+ 			goto vmalloc_to_page_err;
+ 		sg_set_page(&dma->sglist[i], pg, PAGE_SIZE, 0);
+ 	}
+ 	return 0;
+ 
+ vmalloc_to_page_err:
+ 	vfree(dma->sglist);
+ 	dma->sglist = NULL;
+ vzalloc_err:
+ 	vfree(dma->vaddr);
+ 	dma->vaddr = NULL;
+ 	return -ENOMEM;
+ }
+ 
+ static int saa7134_alsa_dma_map(struct saa7134_dev *dev)
+ {
+ 	struct saa7134_dmasound *dma = &dev->dmasound;
+ 
+ 	dma->sglen = dma_map_sg(&dev->pci->dev, dma->sglist,
+ 			dma->nr_pages, PCI_DMA_FROMDEVICE);
+ 
+ 	if (0 == dma->sglen) {
+ 		pr_warn("%s: saa7134_alsa_map_sg failed\n", __func__);
+ 		return -ENOMEM;
+ 	}
+ 	return 0;
+ }
+ 
+ static int saa7134_alsa_dma_unmap(struct saa7134_dev *dev)
+ {
+ 	struct saa7134_dmasound *dma = &dev->dmasound;
+ 
+ 	if (!dma->sglen)
+ 		return 0;
+ 
+ 	dma_unmap_sg(&dev->pci->dev, dma->sglist, dma->sglen, PCI_DMA_FROMDEVICE);
+ 	dma->sglen = 0;
+ 	return 0;
+ }
+ 
+ static int saa7134_alsa_dma_free(struct saa7134_dmasound *dma)
+ {
+ 	vfree(dma->sglist);
+ 	dma->sglist = NULL;
+ 	vfree(dma->vaddr);
+ 	dma->vaddr = NULL;
+ 	return 0;
+ }
+ 
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  /*
   * DMA buffer initialization
   *
diff --cc drivers/mtd/nand/nandsim.c
index cb38f3d94218,f8edacde49ab..000000000000
--- a/drivers/mtd/nand/nandsim.c
+++ b/drivers/mtd/nand/nandsim.c
@@@ -586,7 -565,9 +586,13 @@@ static int alloc_device(struct nandsim 
  			err = -EINVAL;
  			goto err_close;
  		}
++<<<<<<< HEAD:drivers/mtd/nand/nandsim.c
 +		ns->pages_written = vzalloc(ns->geom.pgnum);
++=======
+ 		ns->pages_written =
+ 			vzalloc(array_size(sizeof(unsigned long),
+ 					   BITS_TO_LONGS(ns->geom.pgnum)));
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc()):drivers/mtd/nand/raw/nandsim.c
  		if (!ns->pages_written) {
  			NS_ERR("alloc_device: unable to allocate pages written array\n");
  			err = -ENOMEM;
diff --cc drivers/net/ethernet/broadcom/bnx2.c
index 6b838496bd1a,122fdb80a789..000000000000
--- a/drivers/net/ethernet/broadcom/bnx2.c
+++ b/drivers/net/ethernet/broadcom/bnx2.c
@@@ -778,8 -778,8 +778,13 @@@ bnx2_alloc_rx_mem(struct bnx2 *bp
  		int j;
  
  		rxr->rx_buf_ring =
++<<<<<<< HEAD
 +			vzalloc(SW_RXBD_RING_SIZE * bp->rx_max_ring);
 +		if (rxr->rx_buf_ring == NULL)
++=======
+ 			vzalloc(array_size(SW_RXBD_RING_SIZE, bp->rx_max_ring));
+ 		if (!rxr->rx_buf_ring)
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  			return -ENOMEM;
  
  		for (j = 0; j < bp->rx_max_ring; j++) {
@@@ -794,9 -794,10 +799,16 @@@
  		}
  
  		if (bp->rx_pg_ring_size) {
++<<<<<<< HEAD
 +			rxr->rx_pg_ring = vzalloc(SW_RXPG_RING_SIZE *
 +						  bp->rx_max_pg_ring);
 +			if (rxr->rx_pg_ring == NULL)
++=======
+ 			rxr->rx_pg_ring =
+ 				vzalloc(array_size(SW_RXPG_RING_SIZE,
+ 						   bp->rx_max_pg_ring));
+ 			if (!rxr->rx_pg_ring)
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  				return -ENOMEM;
  
  		}
diff --cc drivers/net/xen-netback/xenbus.c
index 8a9e8750703f,cd51492ae6c2..000000000000
--- a/drivers/net/xen-netback/xenbus.c
+++ b/drivers/net/xen-netback/xenbus.c
@@@ -471,9 -965,78 +471,84 @@@ static void connect(struct backend_inf
  		return;
  	}
  
++<<<<<<< HEAD
 +	xen_net_read_rate(dev, &be->vif->credit_bytes,
 +			  &be->vif->credit_usec);
 +	be->vif->remaining_credit = be->vif->credit_bytes;
++=======
+ 	xen_net_read_rate(dev, &credit_bytes, &credit_usec);
+ 	xen_unregister_watchers(be->vif);
+ 	xen_register_watchers(dev, be->vif);
+ 	read_xenbus_vif_flags(be);
+ 
+ 	err = connect_ctrl_ring(be);
+ 	if (err) {
+ 		xenbus_dev_fatal(dev, err, "connecting control ring");
+ 		return;
+ 	}
+ 
+ 	/* Use the number of queues requested by the frontend */
+ 	be->vif->queues = vzalloc(array_size(requested_num_queues,
+ 					     sizeof(struct xenvif_queue)));
+ 	if (!be->vif->queues) {
+ 		xenbus_dev_fatal(dev, -ENOMEM,
+ 				 "allocating queues");
+ 		return;
+ 	}
+ 
+ 	be->vif->num_queues = requested_num_queues;
+ 	be->vif->stalled_queues = requested_num_queues;
+ 
+ 	for (queue_index = 0; queue_index < requested_num_queues; ++queue_index) {
+ 		queue = &be->vif->queues[queue_index];
+ 		queue->vif = be->vif;
+ 		queue->id = queue_index;
+ 		snprintf(queue->name, sizeof(queue->name), "%s-q%u",
+ 				be->vif->dev->name, queue->id);
+ 
+ 		err = xenvif_init_queue(queue);
+ 		if (err) {
+ 			/* xenvif_init_queue() cleans up after itself on
+ 			 * failure, but we need to clean up any previously
+ 			 * initialised queues. Set num_queues to i so that
+ 			 * earlier queues can be destroyed using the regular
+ 			 * disconnect logic.
+ 			 */
+ 			be->vif->num_queues = queue_index;
+ 			goto err;
+ 		}
+ 
+ 		queue->credit_bytes = credit_bytes;
+ 		queue->remaining_credit = credit_bytes;
+ 		queue->credit_usec = credit_usec;
+ 
+ 		err = connect_data_rings(be, queue);
+ 		if (err) {
+ 			/* connect_data_rings() cleans up after itself on
+ 			 * failure, but we need to clean up after
+ 			 * xenvif_init_queue() here, and also clean up any
+ 			 * previously initialised queues.
+ 			 */
+ 			xenvif_deinit_queue(queue);
+ 			be->vif->num_queues = queue_index;
+ 			goto err;
+ 		}
+ 	}
+ 
+ #ifdef CONFIG_DEBUG_FS
+ 	xenvif_debugfs_addif(be->vif);
+ #endif /* CONFIG_DEBUG_FS */
+ 
+ 	/* Initialisation completed, tell core driver the number of
+ 	 * active queues.
+ 	 */
+ 	rtnl_lock();
+ 	netif_set_real_num_tx_queues(be->vif->dev, requested_num_queues);
+ 	netif_set_real_num_rx_queues(be->vif->dev, requested_num_queues);
+ 	rtnl_unlock();
+ 
+ 	xenvif_carrier_on(be->vif);
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  
  	unregister_hotplug_status_watch(be);
  	err = xenbus_watch_pathfmt(dev, &be->hotplug_status_watch,
diff --cc fs/nfsd/nfscache.c
index 574ad4591c06,223b3b2dff87..000000000000
--- a/fs/nfsd/nfscache.c
+++ b/fs/nfsd/nfscache.c
@@@ -175,8 -176,13 +175,18 @@@ int nfsd_reply_cache_init(void
  		goto out_nomem;
  
  	drc_hashtbl = kcalloc(hashsize, sizeof(*drc_hashtbl), GFP_KERNEL);
++<<<<<<< HEAD
 +	if (!drc_hashtbl)
 +		goto out_nomem;
++=======
+ 	if (!drc_hashtbl) {
+ 		drc_hashtbl = vzalloc(array_size(hashsize,
+ 						 sizeof(*drc_hashtbl)));
+ 		if (!drc_hashtbl)
+ 			goto out_nomem;
+ 	}
+ 
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  	for (i = 0; i < hashsize; i++) {
  		INIT_LIST_HEAD(&drc_hashtbl[i].lru_head);
  		spin_lock_init(&drc_hashtbl[i].cache_lock);
diff --cc kernel/kexec_file.c
index 1de52cf9520e,c6a3b6851372..000000000000
--- a/kernel/kexec_file.c
+++ b/kernel/kexec_file.c
@@@ -790,12 -764,50 +790,54 @@@ static int __kexec_load_purgatory(struc
  	if (ret)
  		goto out;
  
++<<<<<<< HEAD
 +	/* Load SHF_ALLOC sections */
 +	buf_addr = purgatory_buf;
 +	load_addr = curr_load_addr = pi->purgatory_load_addr;
 +	bss_addr = load_addr + buf_sz + bss_pad;
++=======
+ 	return 0;
+ out:
+ 	vfree(pi->purgatory_buf);
+ 	pi->purgatory_buf = NULL;
+ 	return ret;
+ }
+ 
+ /*
+  * kexec_purgatory_setup_sechdrs - prepares the pi->sechdrs buffer.
+  * @pi:		Purgatory to be loaded.
+  * @kbuf:	Buffer prepared to store purgatory.
+  *
+  * Allocates the memory needed for the buffer. Caller is responsible to free
+  * the memory after use.
+  *
+  * Return: 0 on success, negative errno on error.
+  */
+ static int kexec_purgatory_setup_sechdrs(struct purgatory_info *pi,
+ 					 struct kexec_buf *kbuf)
+ {
+ 	unsigned long bss_addr;
+ 	unsigned long offset;
+ 	Elf_Shdr *sechdrs;
+ 	int i;
+ 
+ 	/*
+ 	 * The section headers in kexec_purgatory are read-only. In order to
+ 	 * have them modifiable make a temporary copy.
+ 	 */
+ 	sechdrs = vzalloc(array_size(sizeof(Elf_Shdr), pi->ehdr->e_shnum));
+ 	if (!sechdrs)
+ 		return -ENOMEM;
+ 	memcpy(sechdrs, (void *)pi->ehdr + pi->ehdr->e_shoff,
+ 	       pi->ehdr->e_shnum * sizeof(Elf_Shdr));
+ 	pi->sechdrs = sechdrs;
+ 
+ 	offset = 0;
+ 	bss_addr = kbuf->mem + kbuf->bufsz;
+ 	kbuf->image->start = pi->ehdr->e_entry;
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  
  	for (i = 0; i < pi->ehdr->e_shnum; i++) {
 -		unsigned long align;
 -		void *src, *dst;
 -
  		if (!(sechdrs[i].sh_flags & SHF_ALLOC))
  			continue;
  
diff --cc lib/test_rhashtable.c
index 64e899b63337,fb6968109113..000000000000
--- a/lib/test_rhashtable.c
+++ b/lib/test_rhashtable.c
@@@ -235,6 -273,331 +235,334 @@@ static s64 __init test_rhashtable(struc
  }
  
  static struct rhashtable ht;
++<<<<<<< HEAD
++=======
+ static struct rhltable rhlt;
+ 
+ static int __init test_rhltable(unsigned int entries)
+ {
+ 	struct test_obj_rhl *rhl_test_objects;
+ 	unsigned long *obj_in_table;
+ 	unsigned int i, j, k;
+ 	int ret, err;
+ 
+ 	if (entries == 0)
+ 		entries = 1;
+ 
+ 	rhl_test_objects = vzalloc(array_size(entries,
+ 					      sizeof(*rhl_test_objects)));
+ 	if (!rhl_test_objects)
+ 		return -ENOMEM;
+ 
+ 	ret = -ENOMEM;
+ 	obj_in_table = vzalloc(array_size(sizeof(unsigned long),
+ 					  BITS_TO_LONGS(entries)));
+ 	if (!obj_in_table)
+ 		goto out_free;
+ 
+ 	/* nulls_base not supported in rhlist interface */
+ 	test_rht_params.nulls_base = 0;
+ 	err = rhltable_init(&rhlt, &test_rht_params);
+ 	if (WARN_ON(err))
+ 		goto out_free;
+ 
+ 	k = prandom_u32();
+ 	ret = 0;
+ 	for (i = 0; i < entries; i++) {
+ 		rhl_test_objects[i].value.id = k;
+ 		err = rhltable_insert(&rhlt, &rhl_test_objects[i].list_node,
+ 				      test_rht_params);
+ 		if (WARN(err, "error %d on element %d\n", err, i))
+ 			break;
+ 		if (err == 0)
+ 			set_bit(i, obj_in_table);
+ 	}
+ 
+ 	if (err)
+ 		ret = err;
+ 
+ 	pr_info("test %d add/delete pairs into rhlist\n", entries);
+ 	for (i = 0; i < entries; i++) {
+ 		struct rhlist_head *h, *pos;
+ 		struct test_obj_rhl *obj;
+ 		struct test_obj_val key = {
+ 			.id = k,
+ 		};
+ 		bool found;
+ 
+ 		rcu_read_lock();
+ 		h = rhltable_lookup(&rhlt, &key, test_rht_params);
+ 		if (WARN(!h, "key not found during iteration %d of %d", i, entries)) {
+ 			rcu_read_unlock();
+ 			break;
+ 		}
+ 
+ 		if (i) {
+ 			j = i - 1;
+ 			rhl_for_each_entry_rcu(obj, pos, h, list_node) {
+ 				if (WARN(pos == &rhl_test_objects[j].list_node, "old element found, should be gone"))
+ 					break;
+ 			}
+ 		}
+ 
+ 		cond_resched_rcu();
+ 
+ 		found = false;
+ 
+ 		rhl_for_each_entry_rcu(obj, pos, h, list_node) {
+ 			if (pos == &rhl_test_objects[i].list_node) {
+ 				found = true;
+ 				break;
+ 			}
+ 		}
+ 
+ 		rcu_read_unlock();
+ 
+ 		if (WARN(!found, "element %d not found", i))
+ 			break;
+ 
+ 		err = rhltable_remove(&rhlt, &rhl_test_objects[i].list_node, test_rht_params);
+ 		WARN(err, "rhltable_remove: err %d for iteration %d\n", err, i);
+ 		if (err == 0)
+ 			clear_bit(i, obj_in_table);
+ 	}
+ 
+ 	if (ret == 0 && err)
+ 		ret = err;
+ 
+ 	for (i = 0; i < entries; i++) {
+ 		WARN(test_bit(i, obj_in_table), "elem %d allegedly still present", i);
+ 
+ 		err = rhltable_insert(&rhlt, &rhl_test_objects[i].list_node,
+ 				      test_rht_params);
+ 		if (WARN(err, "error %d on element %d\n", err, i))
+ 			break;
+ 		if (err == 0)
+ 			set_bit(i, obj_in_table);
+ 	}
+ 
+ 	pr_info("test %d random rhlist add/delete operations\n", entries);
+ 	for (j = 0; j < entries; j++) {
+ 		u32 i = prandom_u32_max(entries);
+ 		u32 prand = prandom_u32();
+ 
+ 		cond_resched();
+ 
+ 		if (prand == 0)
+ 			prand = prandom_u32();
+ 
+ 		if (prand & 1) {
+ 			prand >>= 1;
+ 			continue;
+ 		}
+ 
+ 		err = rhltable_remove(&rhlt, &rhl_test_objects[i].list_node, test_rht_params);
+ 		if (test_bit(i, obj_in_table)) {
+ 			clear_bit(i, obj_in_table);
+ 			if (WARN(err, "cannot remove element at slot %d", i))
+ 				continue;
+ 		} else {
+ 			if (WARN(err != -ENOENT, "removed non-existant element %d, error %d not %d",
+ 			     i, err, -ENOENT))
+ 				continue;
+ 		}
+ 
+ 		if (prand & 1) {
+ 			prand >>= 1;
+ 			continue;
+ 		}
+ 
+ 		err = rhltable_insert(&rhlt, &rhl_test_objects[i].list_node, test_rht_params);
+ 		if (err == 0) {
+ 			if (WARN(test_and_set_bit(i, obj_in_table), "succeeded to insert same object %d", i))
+ 				continue;
+ 		} else {
+ 			if (WARN(!test_bit(i, obj_in_table), "failed to insert object %d", i))
+ 				continue;
+ 		}
+ 
+ 		if (prand & 1) {
+ 			prand >>= 1;
+ 			continue;
+ 		}
+ 
+ 		i = prandom_u32_max(entries);
+ 		if (test_bit(i, obj_in_table)) {
+ 			err = rhltable_remove(&rhlt, &rhl_test_objects[i].list_node, test_rht_params);
+ 			WARN(err, "cannot remove element at slot %d", i);
+ 			if (err == 0)
+ 				clear_bit(i, obj_in_table);
+ 		} else {
+ 			err = rhltable_insert(&rhlt, &rhl_test_objects[i].list_node, test_rht_params);
+ 			WARN(err, "failed to insert object %d", i);
+ 			if (err == 0)
+ 				set_bit(i, obj_in_table);
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < entries; i++) {
+ 		cond_resched();
+ 		err = rhltable_remove(&rhlt, &rhl_test_objects[i].list_node, test_rht_params);
+ 		if (test_bit(i, obj_in_table)) {
+ 			if (WARN(err, "cannot remove element at slot %d", i))
+ 				continue;
+ 		} else {
+ 			if (WARN(err != -ENOENT, "removed non-existant element, error %d not %d",
+ 				 err, -ENOENT))
+ 			continue;
+ 		}
+ 	}
+ 
+ 	rhltable_destroy(&rhlt);
+ out_free:
+ 	vfree(rhl_test_objects);
+ 	vfree(obj_in_table);
+ 	return ret;
+ }
+ 
+ static int __init test_rhashtable_max(struct test_obj *array,
+ 				      unsigned int entries)
+ {
+ 	unsigned int i, insert_retries = 0;
+ 	int err;
+ 
+ 	test_rht_params.max_size = roundup_pow_of_two(entries / 8);
+ 	err = rhashtable_init(&ht, &test_rht_params);
+ 	if (err)
+ 		return err;
+ 
+ 	for (i = 0; i < ht.max_elems; i++) {
+ 		struct test_obj *obj = &array[i];
+ 
+ 		obj->value.id = i * 2;
+ 		err = insert_retry(&ht, obj, test_rht_params);
+ 		if (err > 0)
+ 			insert_retries += err;
+ 		else if (err)
+ 			return err;
+ 	}
+ 
+ 	err = insert_retry(&ht, &array[ht.max_elems], test_rht_params);
+ 	if (err == -E2BIG) {
+ 		err = 0;
+ 	} else {
+ 		pr_info("insert element %u should have failed with %d, got %d\n",
+ 				ht.max_elems, -E2BIG, err);
+ 		if (err == 0)
+ 			err = -1;
+ 	}
+ 
+ 	rhashtable_destroy(&ht);
+ 
+ 	return err;
+ }
+ 
+ static unsigned int __init print_ht(struct rhltable *rhlt)
+ {
+ 	struct rhashtable *ht;
+ 	const struct bucket_table *tbl;
+ 	char buff[512] = "";
+ 	unsigned int i, cnt = 0;
+ 
+ 	ht = &rhlt->ht;
+ 	tbl = rht_dereference(ht->tbl, ht);
+ 	for (i = 0; i < tbl->size; i++) {
+ 		struct rhash_head *pos, *next;
+ 		struct test_obj_rhl *p;
+ 
+ 		pos = rht_dereference(tbl->buckets[i], ht);
+ 		next = !rht_is_a_nulls(pos) ? rht_dereference(pos->next, ht) : NULL;
+ 
+ 		if (!rht_is_a_nulls(pos)) {
+ 			sprintf(buff, "%s\nbucket[%d] -> ", buff, i);
+ 		}
+ 
+ 		while (!rht_is_a_nulls(pos)) {
+ 			struct rhlist_head *list = container_of(pos, struct rhlist_head, rhead);
+ 			sprintf(buff, "%s[[", buff);
+ 			do {
+ 				pos = &list->rhead;
+ 				list = rht_dereference(list->next, ht);
+ 				p = rht_obj(ht, pos);
+ 
+ 				sprintf(buff, "%s val %d (tid=%d)%s", buff, p->value.id, p->value.tid,
+ 					list? ", " : " ");
+ 				cnt++;
+ 			} while (list);
+ 
+ 			pos = next,
+ 			next = !rht_is_a_nulls(pos) ?
+ 				rht_dereference(pos->next, ht) : NULL;
+ 
+ 			sprintf(buff, "%s]]%s", buff, !rht_is_a_nulls(pos) ? " -> " : "");
+ 		}
+ 	}
+ 	printk(KERN_ERR "\n---- ht: ----%s\n-------------\n", buff);
+ 
+ 	return cnt;
+ }
+ 
+ static int __init test_insert_dup(struct test_obj_rhl *rhl_test_objects,
+ 				  int cnt, bool slow)
+ {
+ 	struct rhltable rhlt;
+ 	unsigned int i, ret;
+ 	const char *key;
+ 	int err = 0;
+ 
+ 	err = rhltable_init(&rhlt, &test_rht_params_dup);
+ 	if (WARN_ON(err))
+ 		return err;
+ 
+ 	for (i = 0; i < cnt; i++) {
+ 		rhl_test_objects[i].value.tid = i;
+ 		key = rht_obj(&rhlt.ht, &rhl_test_objects[i].list_node.rhead);
+ 		key += test_rht_params_dup.key_offset;
+ 
+ 		if (slow) {
+ 			err = PTR_ERR(rhashtable_insert_slow(&rhlt.ht, key,
+ 							     &rhl_test_objects[i].list_node.rhead));
+ 			if (err == -EAGAIN)
+ 				err = 0;
+ 		} else
+ 			err = rhltable_insert(&rhlt,
+ 					      &rhl_test_objects[i].list_node,
+ 					      test_rht_params_dup);
+ 		if (WARN(err, "error %d on element %d/%d (%s)\n", err, i, cnt, slow? "slow" : "fast"))
+ 			goto skip_print;
+ 	}
+ 
+ 	ret = print_ht(&rhlt);
+ 	WARN(ret != cnt, "missing rhltable elements (%d != %d, %s)\n", ret, cnt, slow? "slow" : "fast");
+ 
+ skip_print:
+ 	rhltable_destroy(&rhlt);
+ 
+ 	return 0;
+ }
+ 
+ static int __init test_insert_duplicates_run(void)
+ {
+ 	struct test_obj_rhl rhl_test_objects[3] = {};
+ 
+ 	pr_info("test inserting duplicates\n");
+ 
+ 	/* two different values that map to same bucket */
+ 	rhl_test_objects[0].value.id = 1;
+ 	rhl_test_objects[1].value.id = 21;
+ 
+ 	/* and another duplicate with same as [0] value
+ 	 * which will be second on the bucket list */
+ 	rhl_test_objects[2].value.id = rhl_test_objects[0].value.id;
+ 
+ 	test_insert_dup(rhl_test_objects, 2, false);
+ 	test_insert_dup(rhl_test_objects, 3, false);
+ 	test_insert_dup(rhl_test_objects, 2, true);
+ 	test_insert_dup(rhl_test_objects, 3, true);
+ 
+ 	return 0;
+ }
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  
  static int thread_lookup_test(struct thread_data *tdata)
  {
@@@ -336,6 -708,11 +664,14 @@@ static int __init test_rht_init(void
  	test_rht_params.max_size = max_size ? : roundup_pow_of_two(entries);
  	test_rht_params.nelem_hint = size;
  
++<<<<<<< HEAD
++=======
+ 	objs = vzalloc(array_size(sizeof(struct test_obj),
+ 				  test_rht_params.max_size + 1));
+ 	if (!objs)
+ 		return -ENOMEM;
+ 
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  	pr_info("Running rhashtable test nelem=%d, max_size=%d, shrinking=%d\n",
  		size, max_size, shrinking);
  
diff --cc net/core/ethtool.c
index 396a7c77a080,e677a20180cf..000000000000
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@@ -1875,11 -1847,13 +1875,16 @@@ static int ethtool_get_strings(struct n
  	ret = __ethtool_get_sset_count(dev, gstrings.string_set);
  	if (ret < 0)
  		return ret;
 -	if (ret > S32_MAX / ETH_GSTRING_LEN)
 -		return -ENOMEM;
 -	WARN_ON_ONCE(!ret);
  
  	gstrings.len = ret;
++<<<<<<< HEAD
 +
 +	data = kcalloc(gstrings.len, ETH_GSTRING_LEN, GFP_USER);
 +	if (!data)
++=======
+ 	data = vzalloc(array_size(gstrings.len, ETH_GSTRING_LEN));
+ 	if (gstrings.len && !data)
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  		return -ENOMEM;
  
  	__ethtool_get_strings(dev, gstrings.string_set, data);
@@@ -1976,8 -1952,8 +1981,13 @@@ static int ethtool_get_stats(struct net
  		return -EFAULT;
  
  	stats.n_stats = n_stats;
++<<<<<<< HEAD
 +	data = kmalloc(n_stats * sizeof(u64), GFP_USER);
 +	if (!data)
++=======
+ 	data = vzalloc(array_size(n_stats, sizeof(u64)));
+ 	if (n_stats && !data)
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  		return -ENOMEM;
  
  	ops->get_ethtool_stats(dev, &stats, data);
@@@ -1991,7 -1967,57 +2001,61 @@@
  	ret = 0;
  
   out:
++<<<<<<< HEAD
 +	kfree(data);
++=======
+ 	vfree(data);
+ 	return ret;
+ }
+ 
+ static int ethtool_get_phy_stats(struct net_device *dev, void __user *useraddr)
+ {
+ 	const struct ethtool_ops *ops = dev->ethtool_ops;
+ 	struct phy_device *phydev = dev->phydev;
+ 	struct ethtool_stats stats;
+ 	u64 *data;
+ 	int ret, n_stats;
+ 
+ 	if (!phydev && (!ops->get_ethtool_phy_stats || !ops->get_sset_count))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (dev->phydev && !ops->get_ethtool_phy_stats)
+ 		n_stats = phy_ethtool_get_sset_count(dev->phydev);
+ 	else
+ 		n_stats = ops->get_sset_count(dev, ETH_SS_PHY_STATS);
+ 	if (n_stats < 0)
+ 		return n_stats;
+ 	if (n_stats > S32_MAX / sizeof(u64))
+ 		return -ENOMEM;
+ 	WARN_ON_ONCE(!n_stats);
+ 
+ 	if (copy_from_user(&stats, useraddr, sizeof(stats)))
+ 		return -EFAULT;
+ 
+ 	stats.n_stats = n_stats;
+ 	data = vzalloc(array_size(n_stats, sizeof(u64)));
+ 	if (n_stats && !data)
+ 		return -ENOMEM;
+ 
+ 	if (dev->phydev && !ops->get_ethtool_phy_stats) {
+ 		ret = phy_ethtool_get_stats(dev->phydev, &stats, data);
+ 		if (ret < 0)
+ 			return ret;
+ 	} else {
+ 		ops->get_ethtool_phy_stats(dev, &stats, data);
+ 	}
+ 
+ 	ret = -EFAULT;
+ 	if (copy_to_user(useraddr, &stats, sizeof(stats)))
+ 		goto out;
+ 	useraddr += sizeof(stats);
+ 	if (n_stats && copy_to_user(useraddr, data, n_stats * sizeof(u64)))
+ 		goto out;
+ 	ret = 0;
+ 
+  out:
+ 	vfree(data);
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  	return ret;
  }
  
diff --cc net/packet/af_packet.c
index d41f5d797983,50809748c127..000000000000
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@@ -3725,11 -4160,8 +3725,16 @@@ static char *alloc_one_pg_vec_page(unsi
  	if (buffer)
  		return buffer;
  
++<<<<<<< HEAD
 +	/*
 +	 * __get_free_pages failed, fall back to vmalloc
 +	 */
 +	buffer = vzalloc((1 << order) * PAGE_SIZE);
 +
++=======
+ 	/* __get_free_pages failed, fall back to vmalloc */
+ 	buffer = vzalloc(array_size((1 << order), PAGE_SIZE));
++>>>>>>> fad953ce0b22 (treewide: Use array_size() in vzalloc())
  	if (buffer)
  		return buffer;
  
* Unmerged path drivers/dma/mic_x100_dma.c
* Unmerged path drivers/infiniband/hw/hns/hns_roce_mr.c
* Unmerged path drivers/lightnvm/pblk-init.c
* Unmerged path drivers/lightnvm/pblk-recovery.c
* Unmerged path drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
* Unmerged path drivers/media/platform/vivid/vivid-core.c
* Unmerged path drivers/net/ethernet/hisilicon/hns/hns_dsaf_main.c
* Unmerged path drivers/net/ethernet/huawei/hinic/hinic_hw_cmdq.c
* Unmerged path drivers/s390/char/sclp_sd.c
* Unmerged path drivers/soc/fsl/qbman/qman.c
* Unmerged path drivers/staging/rtl8188eu/core/rtw_mlme.c
* Unmerged path drivers/staging/rtl8723bs/core/rtw_mlme.c
* Unmerged path drivers/staging/rts5208/rtsx_chip.c
* Unmerged path lib/test_firmware.c
* Unmerged path lib/test_kmod.c
diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c
index f962976f1ab3..6ea0f16649c2 100644
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@ -2939,7 +2939,7 @@ static void kvmppc_core_free_memslot_hv(struct kvm_memory_slot *free,
 static int kvmppc_core_create_memslot_hv(struct kvm_memory_slot *slot,
 					 unsigned long npages)
 {
-	slot->arch.rmap = vzalloc(npages * sizeof(*slot->arch.rmap));
+	slot->arch.rmap = vzalloc(array_size(npages, sizeof(*slot->arch.rmap)));
 	if (!slot->arch.rmap)
 		return -ENOMEM;
 
diff --git a/arch/powerpc/mm/mmu_context_iommu.c b/arch/powerpc/mm/mmu_context_iommu.c
index f68c12901fa8..b84c1d26cac2 100644
--- a/arch/powerpc/mm/mmu_context_iommu.c
+++ b/arch/powerpc/mm/mmu_context_iommu.c
@@ -166,7 +166,7 @@ long mm_iommu_get(unsigned long ua, unsigned long entries,
 		goto unlock_exit;
 	}
 
-	mem->hpas = vzalloc(entries * sizeof(mem->hpas[0]));
+	mem->hpas = vzalloc(array_size(entries, sizeof(mem->hpas[0])));
 	if (!mem->hpas) {
 		kfree(mem);
 		ret = -ENOMEM;
diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c
index af94ebee7c2e..c1e9a60c192c 100644
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@ -759,7 +759,8 @@ int kvm_dev_ioctl_get_cpuid(struct kvm_cpuid2 *cpuid,
 		return -EINVAL;
 
 	r = -ENOMEM;
-	cpuid_entries = vzalloc(sizeof(struct kvm_cpuid_entry2) * cpuid->nent);
+	cpuid_entries = vzalloc(array_size(sizeof(struct kvm_cpuid_entry2),
+					   cpuid->nent));
 	if (!cpuid_entries)
 		goto out;
 
diff --git a/block/partitions/check.c b/block/partitions/check.c
index a484a0c37323..f18e2fa31f77 100644
--- a/block/partitions/check.c
+++ b/block/partitions/check.c
@@ -117,7 +117,7 @@ static struct parsed_partitions *allocate_partitions(struct gendisk *hd)
 		return NULL;
 
 	nr = disk_max_parts(hd);
-	state->parts = vzalloc(nr * sizeof(state->parts[0]));
+	state->parts = vzalloc(array_size(nr, sizeof(state->parts[0])));
 	if (!state->parts) {
 		kfree(state);
 		return NULL;
* Unmerged path drivers/block/zram/zram_drv.c
diff --git a/drivers/char/raw.c b/drivers/char/raw.c
index ef397f5b823d..af4dc1da8616 100644
--- a/drivers/char/raw.c
+++ b/drivers/char/raw.c
@@ -324,7 +324,8 @@ static int __init raw_init(void)
 		max_raw_minors = MAX_RAW_MINORS;
 	}
 
-	raw_devices = vzalloc(sizeof(struct raw_device_data) * max_raw_minors);
+	raw_devices = vzalloc(array_size(max_raw_minors,
+					 sizeof(struct raw_device_data)));
 	if (!raw_devices) {
 		printk(KERN_ERR "Not enough memory for raw device structures\n");
 		ret = -ENOMEM;
diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c
index 43c7d59b35ef..94c221ba931a 100644
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@ -2511,7 +2511,7 @@ hwp_cpu_matched:
 
 	pr_info("Intel P-state driver initializing\n");
 
-	all_cpu_data = vzalloc(sizeof(void *) * num_possible_cpus());
+	all_cpu_data = vzalloc(array_size(sizeof(void *), num_possible_cpus()));
 	if (!all_cpu_data)
 		return -ENOMEM;
 
* Unmerged path drivers/dma/mic_x100_dma.c
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c
index d2c897d6e8f3..77ea18c22dad 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c
@@ -361,7 +361,8 @@ int amdgpu_gart_init(struct amdgpu_device *adev)
 
 #ifdef CONFIG_DRM_AMDGPU_GART_DEBUGFS
 	/* Allocate pages table */
-	adev->gart.pages = vzalloc(sizeof(void *) * adev->gart.num_cpu_pages);
+	adev->gart.pages = vzalloc(array_size(sizeof(void *),
+					      adev->gart.num_cpu_pages));
 	if (adev->gart.pages == NULL)
 		return -ENOMEM;
 #endif
diff --git a/drivers/gpu/drm/drm_hashtab.c b/drivers/gpu/drm/drm_hashtab.c
index dae18e58e79b..c92b00d42ece 100644
--- a/drivers/gpu/drm/drm_hashtab.c
+++ b/drivers/gpu/drm/drm_hashtab.c
@@ -47,7 +47,7 @@ int drm_ht_create(struct drm_open_hash *ht, unsigned int order)
 	if (size <= PAGE_SIZE / sizeof(*ht->table))
 		ht->table = kcalloc(size, sizeof(*ht->table), GFP_KERNEL);
 	else
-		ht->table = vzalloc(size*sizeof(*ht->table));
+		ht->table = vzalloc(array_size(size, sizeof(*ht->table)));
 	if (!ht->table) {
 		DRM_ERROR("Out of memory for hash table\n");
 		return -ENOMEM;
diff --git a/drivers/gpu/drm/i915/gvt/gtt.c b/drivers/gpu/drm/i915/gvt/gtt.c
index b4d8a7deeb82..4efec8fa6c1d 100644
--- a/drivers/gpu/drm/i915/gvt/gtt.c
+++ b/drivers/gpu/drm/i915/gvt/gtt.c
@@ -1585,8 +1585,9 @@ static struct intel_vgpu_mm *intel_vgpu_create_ggtt_mm(struct intel_vgpu *vgpu)
 	mm->type = INTEL_GVT_MM_GGTT;
 
 	nr_entries = gvt_ggtt_gm_sz(vgpu->gvt) >> I915_GTT_PAGE_SHIFT;
-	mm->ggtt_mm.virtual_ggtt = vzalloc(nr_entries *
-					vgpu->gvt->device_info.gtt_entry_size);
+	mm->ggtt_mm.virtual_ggtt =
+		vzalloc(array_size(nr_entries,
+				   vgpu->gvt->device_info.gtt_entry_size));
 	if (!mm->ggtt_mm.virtual_ggtt) {
 		vgpu_free_mm(mm);
 		return ERR_PTR(-ENOMEM);
diff --git a/drivers/gpu/drm/i915/gvt/mmio.c b/drivers/gpu/drm/i915/gvt/mmio.c
index 11b71b33f1c0..da40b8027dc9 100644
--- a/drivers/gpu/drm/i915/gvt/mmio.c
+++ b/drivers/gpu/drm/i915/gvt/mmio.c
@@ -269,7 +269,7 @@ int intel_vgpu_init_mmio(struct intel_vgpu *vgpu)
 {
 	const struct intel_gvt_device_info *info = &vgpu->gvt->device_info;
 
-	vgpu->mmio.vreg = vzalloc(info->mmio_size * 2);
+	vgpu->mmio.vreg = vzalloc(array_size(info->mmio_size, 2));
 	if (!vgpu->mmio.vreg)
 		return -ENOMEM;
 
diff --git a/drivers/gpu/drm/radeon/radeon_gart.c b/drivers/gpu/drm/radeon/radeon_gart.c
index c4777c8d0312..7c7b2b1d76a6 100644
--- a/drivers/gpu/drm/radeon/radeon_gart.c
+++ b/drivers/gpu/drm/radeon/radeon_gart.c
@@ -344,7 +344,8 @@ int radeon_gart_init(struct radeon_device *rdev)
 	DRM_INFO("GART: num cpu pages %u, num gpu pages %u\n",
 		 rdev->gart.num_cpu_pages, rdev->gart.num_gpu_pages);
 	/* Allocate pages table */
-	rdev->gart.pages = vzalloc(sizeof(void *) * rdev->gart.num_cpu_pages);
+	rdev->gart.pages = vzalloc(array_size(sizeof(void *),
+				   rdev->gart.num_cpu_pages));
 	if (rdev->gart.pages == NULL) {
 		radeon_gart_fini(rdev);
 		return -ENOMEM;
diff --git a/drivers/gpu/drm/selftests/test-drm_mm.c b/drivers/gpu/drm/selftests/test-drm_mm.c
index 7cc935d7b7aa..7fad9ba12968 100644
--- a/drivers/gpu/drm/selftests/test-drm_mm.c
+++ b/drivers/gpu/drm/selftests/test-drm_mm.c
@@ -389,7 +389,7 @@ static int __igt_reserve(unsigned int count, u64 size)
 	if (!order)
 		goto err;
 
-	nodes = vzalloc(sizeof(*nodes) * count);
+	nodes = vzalloc(array_size(count, sizeof(*nodes)));
 	if (!nodes)
 		goto err_order;
 
@@ -889,7 +889,7 @@ static int __igt_insert_range(unsigned int count, u64 size, u64 start, u64 end)
 	 */
 
 	ret = -ENOMEM;
-	nodes = vzalloc(count * sizeof(*nodes));
+	nodes = vzalloc(array_size(count, sizeof(*nodes)));
 	if (!nodes)
 		goto err;
 
@@ -1046,7 +1046,7 @@ static int igt_align(void *ignored)
 	 * meets our requirements.
 	 */
 
-	nodes = vzalloc(max_count * sizeof(*nodes));
+	nodes = vzalloc(array_size(max_count, sizeof(*nodes)));
 	if (!nodes)
 		goto err;
 
@@ -1416,7 +1416,7 @@ static int igt_evict(void *ignored)
 	 */
 
 	ret = -ENOMEM;
-	nodes = vzalloc(size * sizeof(*nodes));
+	nodes = vzalloc(array_size(size, sizeof(*nodes)));
 	if (!nodes)
 		goto err;
 
@@ -1526,7 +1526,7 @@ static int igt_evict_range(void *ignored)
 	 */
 
 	ret = -ENOMEM;
-	nodes = vzalloc(size * sizeof(*nodes));
+	nodes = vzalloc(array_size(size, sizeof(*nodes)));
 	if (!nodes)
 		goto err;
 
@@ -1627,7 +1627,7 @@ static int igt_topdown(void *ignored)
 	 */
 
 	ret = -ENOMEM;
-	nodes = vzalloc(count * sizeof(*nodes));
+	nodes = vzalloc(array_size(count, sizeof(*nodes)));
 	if (!nodes)
 		goto err;
 
@@ -1741,7 +1741,7 @@ static int igt_bottomup(void *ignored)
 	 */
 
 	ret = -ENOMEM;
-	nodes = vzalloc(count * sizeof(*nodes));
+	nodes = vzalloc(array_size(count, sizeof(*nodes)));
 	if (!nodes)
 		goto err;
 
@@ -2098,7 +2098,7 @@ static int igt_color_evict(void *ignored)
 	 */
 
 	ret = -ENOMEM;
-	nodes = vzalloc(total_size * sizeof(*nodes));
+	nodes = vzalloc(array_size(total_size, sizeof(*nodes)));
 	if (!nodes)
 		goto err;
 
@@ -2199,7 +2199,7 @@ static int igt_color_evict_range(void *ignored)
 	 */
 
 	ret = -ENOMEM;
-	nodes = vzalloc(total_size * sizeof(*nodes));
+	nodes = vzalloc(array_size(total_size, sizeof(*nodes)));
 	if (!nodes)
 		goto err;
 
diff --git a/drivers/gpu/drm/via/via_dmablit.c b/drivers/gpu/drm/via/via_dmablit.c
index d6e84a589ef1..345bda4494e1 100644
--- a/drivers/gpu/drm/via/via_dmablit.c
+++ b/drivers/gpu/drm/via/via_dmablit.c
@@ -235,7 +235,7 @@ via_lock_all_dma_pages(drm_via_sg_info_t *vsg,  drm_via_dmablit_t *xfer)
 	vsg->num_pages = VIA_PFN(xfer->mem_addr + (xfer->num_lines * xfer->mem_stride - 1)) -
 		first_pfn + 1;
 
-	vsg->pages = vzalloc(sizeof(struct page *) * vsg->num_pages);
+	vsg->pages = vzalloc(array_size(sizeof(struct page *), vsg->num_pages));
 	if (NULL == vsg->pages)
 		return -ENOMEM;
 	ret = get_user_pages_fast((unsigned long)xfer->mem_addr,
diff --git a/drivers/infiniband/core/umem_odp.c b/drivers/infiniband/core/umem_odp.c
index 4bcc39142243..601cd996237e 100644
--- a/drivers/infiniband/core/umem_odp.c
+++ b/drivers/infiniband/core/umem_odp.c
@@ -283,13 +283,15 @@ struct ib_umem *ib_alloc_odp_umem(struct ib_ucontext *context,
 	mutex_init(&odp_data->umem_mutex);
 	init_completion(&odp_data->notifier_completion);
 
-	odp_data->page_list = vzalloc(pages * sizeof(*odp_data->page_list));
+	odp_data->page_list =
+		vzalloc(array_size(pages, sizeof(*odp_data->page_list)));
 	if (!odp_data->page_list) {
 		ret = -ENOMEM;
 		goto out_odp_data;
 	}
 
-	odp_data->dma_list = vzalloc(pages * sizeof(*odp_data->dma_list));
+	odp_data->dma_list =
+		vzalloc(array_size(pages, sizeof(*odp_data->dma_list)));
 	if (!odp_data->dma_list) {
 		ret = -ENOMEM;
 		goto out_page_list;
@@ -369,15 +371,17 @@ int ib_umem_odp_get(struct ib_ucontext *context, struct ib_umem *umem,
 	init_completion(&umem->odp_data->notifier_completion);
 
 	if (ib_umem_num_pages(umem)) {
-		umem->odp_data->page_list = vzalloc(ib_umem_num_pages(umem) *
-					    sizeof(*umem->odp_data->page_list));
+		umem->odp_data->page_list =
+			vzalloc(array_size(sizeof(*umem->odp_data->page_list),
+					   ib_umem_num_pages(umem)));
 		if (!umem->odp_data->page_list) {
 			ret_val = -ENOMEM;
 			goto out_odp_data;
 		}
 
-		umem->odp_data->dma_list = vzalloc(ib_umem_num_pages(umem) *
-					  sizeof(*umem->odp_data->dma_list));
+		umem->odp_data->dma_list =
+			vzalloc(array_size(sizeof(*umem->odp_data->dma_list),
+					   ib_umem_num_pages(umem)));
 		if (!umem->odp_data->dma_list) {
 			ret_val = -ENOMEM;
 			goto out_page_list;
* Unmerged path drivers/infiniband/hw/hns/hns_roce_mr.c
diff --git a/drivers/infiniband/hw/qib/qib_init.c b/drivers/infiniband/hw/qib/qib_init.c
index 5020bffa16b5..d6f0d6662e21 100644
--- a/drivers/infiniband/hw/qib/qib_init.c
+++ b/drivers/infiniband/hw/qib/qib_init.c
@@ -378,11 +378,13 @@ static void init_shadow_tids(struct qib_devdata *dd)
 	struct page **pages;
 	dma_addr_t *addrs;
 
-	pages = vzalloc(dd->cfgctxts * dd->rcvtidcnt * sizeof(struct page *));
+	pages = vzalloc(array_size(sizeof(struct page *),
+				   dd->cfgctxts * dd->rcvtidcnt));
 	if (!pages)
 		goto bail;
 
-	addrs = vzalloc(dd->cfgctxts * dd->rcvtidcnt * sizeof(dma_addr_t));
+	addrs = vzalloc(array_size(sizeof(dma_addr_t),
+				   dd->cfgctxts * dd->rcvtidcnt));
 	if (!addrs)
 		goto bail_free;
 
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c
index ea3f3a5baf7e..1b71401b7dce 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c
@@ -357,7 +357,8 @@ static int ipoib_cm_nonsrq_init_rx(struct net_device *dev, struct ib_cm_id *cm_i
 	int ret;
 	int i;
 
-	rx->rx_ring = vzalloc(ipoib_recvq_size * sizeof *rx->rx_ring);
+	rx->rx_ring = vzalloc(array_size(ipoib_recvq_size,
+					 sizeof(*rx->rx_ring)));
 	if (!rx->rx_ring)
 		return -ENOMEM;
 
@@ -1144,7 +1145,7 @@ static int ipoib_cm_tx_init(struct ipoib_cm_tx *p, u32 qpn,
 	int ret;
 
 	noio_flag = memalloc_noio_save();
-	p->tx_ring = vzalloc(ipoib_sendq_size * sizeof(*p->tx_ring));
+	p->tx_ring = vzalloc(array_size(ipoib_sendq_size, sizeof(*p->tx_ring)));
 	if (!p->tx_ring) {
 		memalloc_noio_restore(noio_flag);
 		ret = -ENOMEM;
@@ -1570,7 +1571,8 @@ static void ipoib_cm_create_srq(struct net_device *dev, int max_sge)
 		return;
 	}
 
-	priv->cm.srq_ring = vzalloc(ipoib_recvq_size * sizeof *priv->cm.srq_ring);
+	priv->cm.srq_ring = vzalloc(array_size(ipoib_recvq_size,
+					       sizeof(*priv->cm.srq_ring)));
 	if (!priv->cm.srq_ring) {
 		ib_destroy_srq(priv->cm.srq);
 		priv->cm.srq = NULL;
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c
index ca0b43540156..159acaf26ffd 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -1712,7 +1712,8 @@ static int ipoib_dev_init_default(struct net_device *dev)
 	if (!priv->rx_ring)
 		goto out;
 
-	priv->tx_ring = vzalloc(ipoib_sendq_size * sizeof *priv->tx_ring);
+	priv->tx_ring = vzalloc(array_size(ipoib_sendq_size,
+					   sizeof(*priv->tx_ring)));
 	if (!priv->tx_ring) {
 		pr_warn("%s: failed to allocate TX ring (%d entries)\n",
 			priv->ca->name, ipoib_sendq_size);
* Unmerged path drivers/lightnvm/pblk-init.c
* Unmerged path drivers/lightnvm/pblk-recovery.c
* Unmerged path drivers/md/bcache/super.c
diff --git a/drivers/md/dm-cache-policy-smq.c b/drivers/md/dm-cache-policy-smq.c
index 4ab23d0075f6..d0c27855e106 100644
--- a/drivers/md/dm-cache-policy-smq.c
+++ b/drivers/md/dm-cache-policy-smq.c
@@ -69,7 +69,7 @@ static int space_init(struct entry_space *es, unsigned nr_entries)
 		return 0;
 	}
 
-	es->begin = vzalloc(sizeof(struct entry) * nr_entries);
+	es->begin = vzalloc(array_size(nr_entries, sizeof(struct entry)));
 	if (!es->begin)
 		return -ENOMEM;
 
* Unmerged path drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
* Unmerged path drivers/media/pci/cx23885/cx23885-alsa.c
* Unmerged path drivers/media/pci/cx25821/cx25821-alsa.c
* Unmerged path drivers/media/pci/cx88/cx88-alsa.c
* Unmerged path drivers/media/pci/saa7134/saa7134-alsa.c
* Unmerged path drivers/media/platform/vivid/vivid-core.c
diff --git a/drivers/media/v4l2-core/videobuf-dma-sg.c b/drivers/media/v4l2-core/videobuf-dma-sg.c
index f18f766aeb59..e7cb861b713c 100644
--- a/drivers/media/v4l2-core/videobuf-dma-sg.c
+++ b/drivers/media/v4l2-core/videobuf-dma-sg.c
@@ -69,7 +69,7 @@ static struct scatterlist *videobuf_vmalloc_to_sg(unsigned char *virt,
 	struct page *pg;
 	int i;
 
-	sglist = vzalloc(nr_pages * sizeof(*sglist));
+	sglist = vzalloc(array_size(nr_pages, sizeof(*sglist)));
 	if (NULL == sglist)
 		return NULL;
 	sg_init_table(sglist, nr_pages);
* Unmerged path drivers/mtd/nand/nandsim.c
* Unmerged path drivers/net/ethernet/broadcom/bnx2.c
diff --git a/drivers/net/ethernet/cavium/liquidio/octeon_droq.c b/drivers/net/ethernet/cavium/liquidio/octeon_droq.c
index f044718cea52..5b5b6228d495 100644
--- a/drivers/net/ethernet/cavium/liquidio/octeon_droq.c
+++ b/drivers/net/ethernet/cavium/liquidio/octeon_droq.c
@@ -286,8 +286,8 @@ int octeon_init_droq(struct octeon_device *oct,
 						numa_node);
 	if (!droq->recv_buf_list)
 		droq->recv_buf_list = (struct octeon_recv_buffer *)
-				      vzalloc(droq->max_count *
-						OCT_DROQ_RECVBUF_SIZE);
+		      vzalloc(array_size(droq->max_count,
+					 OCT_DROQ_RECVBUF_SIZE));
 	if (!droq->recv_buf_list) {
 		dev_err(&oct->pci_dev->dev, "Output queue recv buf list alloc failed\n");
 		goto init_droq_fail;
* Unmerged path drivers/net/ethernet/hisilicon/hns/hns_dsaf_main.c
* Unmerged path drivers/net/ethernet/huawei/hinic/hinic_hw_cmdq.c
diff --git a/drivers/net/ethernet/neterion/vxge/vxge-config.c b/drivers/net/ethernet/neterion/vxge/vxge-config.c
index fbe5363cb89c..ebfe273169bc 100644
--- a/drivers/net/ethernet/neterion/vxge/vxge-config.c
+++ b/drivers/net/ethernet/neterion/vxge/vxge-config.c
@@ -2568,7 +2568,7 @@ __vxge_hw_mempool_grow(struct vxge_hw_mempool *mempool, u32 num_allocate,
 		 * allocate new memblock and its private part at once.
 		 * This helps to minimize memory usage a lot. */
 		mempool->memblocks_priv_arr[i] =
-				vzalloc(mempool->items_priv_size * n_items);
+			vzalloc(array_size(mempool->items_priv_size, n_items));
 		if (mempool->memblocks_priv_arr[i] == NULL) {
 			status = VXGE_HW_ERR_OUT_OF_MEMORY;
 			goto exit;
@@ -2668,7 +2668,7 @@ __vxge_hw_mempool_create(struct __vxge_hw_device *devh,
 
 	/* allocate array of memblocks */
 	mempool->memblocks_arr =
-		vzalloc(sizeof(void *) * mempool->memblocks_max);
+		vzalloc(array_size(sizeof(void *), mempool->memblocks_max));
 	if (mempool->memblocks_arr == NULL) {
 		__vxge_hw_mempool_destroy(mempool);
 		status = VXGE_HW_ERR_OUT_OF_MEMORY;
@@ -2678,7 +2678,7 @@ __vxge_hw_mempool_create(struct __vxge_hw_device *devh,
 
 	/* allocate array of private parts of items per memblocks */
 	mempool->memblocks_priv_arr =
-		vzalloc(sizeof(void *) * mempool->memblocks_max);
+		vzalloc(array_size(sizeof(void *), mempool->memblocks_max));
 	if (mempool->memblocks_priv_arr == NULL) {
 		__vxge_hw_mempool_destroy(mempool);
 		status = VXGE_HW_ERR_OUT_OF_MEMORY;
@@ -2688,8 +2688,8 @@ __vxge_hw_mempool_create(struct __vxge_hw_device *devh,
 
 	/* allocate array of memblocks DMA objects */
 	mempool->memblocks_dma_arr =
-		vzalloc(sizeof(struct vxge_hw_mempool_dma) *
-			mempool->memblocks_max);
+		vzalloc(array_size(sizeof(struct vxge_hw_mempool_dma),
+				   mempool->memblocks_max));
 	if (mempool->memblocks_dma_arr == NULL) {
 		__vxge_hw_mempool_destroy(mempool);
 		status = VXGE_HW_ERR_OUT_OF_MEMORY;
@@ -2698,7 +2698,8 @@ __vxge_hw_mempool_create(struct __vxge_hw_device *devh,
 	}
 
 	/* allocate hash array of items */
-	mempool->items_arr = vzalloc(sizeof(void *) * mempool->items_max);
+	mempool->items_arr = vzalloc(array_size(sizeof(void *),
+						mempool->items_max));
 	if (mempool->items_arr == NULL) {
 		__vxge_hw_mempool_destroy(mempool);
 		status = VXGE_HW_ERR_OUT_OF_MEMORY;
diff --git a/drivers/net/ethernet/qlogic/qed/qed_l2.c b/drivers/net/ethernet/qlogic/qed/qed_l2.c
index b31b40083420..618d09765be9 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_l2.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_l2.c
@@ -2406,7 +2406,7 @@ static int qed_update_vport(struct qed_dev *cdev,
 	if (!cdev)
 		return -ENODEV;
 
-	rss = vzalloc(sizeof(*rss) * cdev->num_hwfns);
+	rss = vzalloc(array_size(sizeof(*rss), cdev->num_hwfns));
 	if (!rss)
 		return -ENOMEM;
 
diff --git a/drivers/net/ethernet/qlogic/qede/qede_filter.c b/drivers/net/ethernet/qlogic/qede/qede_filter.c
index eab48e829077..cbea6d1d47f4 100644
--- a/drivers/net/ethernet/qlogic/qede/qede_filter.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_filter.c
@@ -323,8 +323,9 @@ int qede_alloc_arfs(struct qede_dev *edev)
 	for (i = 0; i <= QEDE_RFS_FLW_MASK; i++)
 		INIT_HLIST_HEAD(QEDE_ARFS_BUCKET_HEAD(edev, i));
 
-	edev->arfs->arfs_fltr_bmap = vzalloc(BITS_TO_LONGS(QEDE_RFS_MAX_FLTR) *
-					     sizeof(long));
+	edev->arfs->arfs_fltr_bmap =
+		vzalloc(array_size(sizeof(long),
+				   BITS_TO_LONGS(QEDE_RFS_MAX_FLTR)));
 	if (!edev->arfs->arfs_fltr_bmap) {
 		vfree(edev->arfs);
 		edev->arfs = NULL;
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
index bdc40da94a7a..a0559b07ed02 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
@@ -386,8 +386,9 @@ int qlcnic_83xx_setup_intr(struct qlcnic_adapter *adapter)
 	}
 
 	/* setup interrupt mapping table for fw */
-	ahw->intr_tbl = vzalloc(num_msix *
-				sizeof(struct qlcnic_intrpt_config));
+	ahw->intr_tbl =
+		vzalloc(array_size(num_msix,
+				   sizeof(struct qlcnic_intrpt_config)));
 	if (!ahw->intr_tbl)
 		return -ENOMEM;
 
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index 238395f5b308..eb19c804ac41 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@ -914,8 +914,9 @@ int qlcnic_82xx_mq_intrpt(struct qlcnic_adapter *adapter, int op_type)
 	if (qlcnic_check_multi_tx(adapter) &&
 	    !ahw->diag_test &&
 	    (adapter->flags & QLCNIC_MSIX_ENABLED)) {
-		ahw->intr_tbl = vzalloc(ahw->num_msix *
-					sizeof(struct qlcnic_intrpt_config));
+		ahw->intr_tbl =
+			vzalloc(array_size(sizeof(struct qlcnic_intrpt_config),
+					   ahw->num_msix));
 		if (!ahw->intr_tbl)
 			return -ENOMEM;
 
diff --git a/drivers/net/ethernet/sfc/ef10.c b/drivers/net/ethernet/sfc/ef10.c
index b4a06d7ff07e..5b655d9ebad1 100644
--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@ -4996,7 +4996,8 @@ static int efx_ef10_filter_table_probe(struct efx_nic *efx)
 		net_dev->hw_features &= ~NETIF_F_HW_VLAN_CTAG_FILTER;
 	}
 
-	table->entry = vzalloc(HUNT_FILTER_TBL_ROWS * sizeof(*table->entry));
+	table->entry = vzalloc(array_size(HUNT_FILTER_TBL_ROWS,
+					  sizeof(*table->entry)));
 	if (!table->entry) {
 		rc = -ENOMEM;
 		goto fail;
diff --git a/drivers/net/ethernet/sfc/falcon/farch.c b/drivers/net/ethernet/sfc/falcon/farch.c
index 05916c710d8c..41281ff4007a 100644
--- a/drivers/net/ethernet/sfc/falcon/farch.c
+++ b/drivers/net/ethernet/sfc/falcon/farch.c
@@ -2755,7 +2755,8 @@ int ef4_farch_filter_table_probe(struct ef4_nic *efx)
 					     GFP_KERNEL);
 		if (!table->used_bitmap)
 			goto fail;
-		table->spec = vzalloc(table->size * sizeof(*table->spec));
+		table->spec = vzalloc(array_size(sizeof(*table->spec),
+						 table->size));
 		if (!table->spec)
 			goto fail;
 	}
diff --git a/drivers/net/ethernet/sfc/farch.c b/drivers/net/ethernet/sfc/farch.c
index 8a60b5e4d6ff..88111eef83a1 100644
--- a/drivers/net/ethernet/sfc/farch.c
+++ b/drivers/net/ethernet/sfc/farch.c
@@ -2827,7 +2827,8 @@ int efx_farch_filter_table_probe(struct efx_nic *efx)
 					     GFP_KERNEL);
 		if (!table->used_bitmap)
 			goto fail;
-		table->spec = vzalloc(table->size * sizeof(*table->spec));
+		table->spec = vzalloc(array_size(sizeof(*table->spec),
+						 table->size));
 		if (!table->spec)
 			goto fail;
 	}
diff --git a/drivers/net/ppp/pptp.c b/drivers/net/ppp/pptp.c
index 2cb8f2ee2349..fd1a19083bd0 100644
--- a/drivers/net/ppp/pptp.c
+++ b/drivers/net/ppp/pptp.c
@@ -635,7 +635,7 @@ static int __init pptp_init_module(void)
 	int err = 0;
 	pr_info("PPTP driver version " PPTP_DRIVER_VERSION "\n");
 
-	callid_sock = vzalloc((MAX_CALLID + 1) * sizeof(void *));
+	callid_sock = vzalloc(array_size(sizeof(void *), (MAX_CALLID + 1)));
 	if (!callid_sock)
 		return -ENOMEM;
 
* Unmerged path drivers/net/xen-netback/xenbus.c
* Unmerged path drivers/s390/char/sclp_sd.c
diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c
index 9d95a8b71bed..49347130651f 100644
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@ -4838,8 +4838,9 @@ megasas_alloc_fusion_context(struct megasas_instance *instance)
 		(PLD_SPAN_INFO)__get_free_pages(GFP_KERNEL | __GFP_ZERO,
 						fusion->log_to_span_pages);
 	if (!fusion->log_to_span) {
-		fusion->log_to_span = vzalloc(MAX_LOGICAL_DRIVES_EXT *
-					      sizeof(LD_SPAN_INFO));
+		fusion->log_to_span =
+			vzalloc(array_size(MAX_LOGICAL_DRIVES_EXT,
+					   sizeof(LD_SPAN_INFO)));
 		if (!fusion->log_to_span) {
 			dev_err(&instance->pdev->dev, "Failed from %s %d\n",
 				__func__, __LINE__);
@@ -4853,8 +4854,9 @@ megasas_alloc_fusion_context(struct megasas_instance *instance)
 		(struct LD_LOAD_BALANCE_INFO *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,
 		fusion->load_balance_info_pages);
 	if (!fusion->load_balance_info) {
-		fusion->load_balance_info = vzalloc(MAX_LOGICAL_DRIVES_EXT *
-			sizeof(struct LD_LOAD_BALANCE_INFO));
+		fusion->load_balance_info =
+			vzalloc(array_size(MAX_LOGICAL_DRIVES_EXT,
+					   sizeof(struct LD_LOAD_BALANCE_INFO)));
 		if (!fusion->load_balance_info)
 			dev_err(&instance->pdev->dev, "Failed to allocate load_balance_info, "
 				"continuing without Load Balance support\n");
diff --git a/drivers/scsi/qla2xxx/tcm_qla2xxx.c b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
index a92e580047a9..c60041d39b5a 100644
--- a/drivers/scsi/qla2xxx/tcm_qla2xxx.c
+++ b/drivers/scsi/qla2xxx/tcm_qla2xxx.c
@@ -1621,7 +1621,9 @@ static int tcm_qla2xxx_init_lport(struct tcm_qla2xxx_lport *lport)
 		return rc;
 	}
 
-	lport->lport_loopid_map = vzalloc(sizeof(struct tcm_qla2xxx_fc_loopid) * 65536);
+	lport->lport_loopid_map =
+		vzalloc(array_size(65536,
+				   sizeof(struct tcm_qla2xxx_fc_loopid)));
 	if (!lport->lport_loopid_map) {
 		pr_err("Unable to allocate lport->lport_loopid_map of %zu bytes\n",
 		    sizeof(struct tcm_qla2xxx_fc_loopid) * 65536);
* Unmerged path drivers/soc/fsl/qbman/qman.c
* Unmerged path drivers/staging/rtl8188eu/core/rtw_mlme.c
* Unmerged path drivers/staging/rtl8723bs/core/rtw_mlme.c
* Unmerged path drivers/staging/rts5208/rtsx_chip.c
diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c
index afae31608fa9..68ae8d32ba41 100644
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@ -255,7 +255,7 @@ int transport_alloc_session_tags(struct se_session *se_sess,
 	se_sess->sess_cmd_map = kzalloc(tag_num * tag_size,
 					GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);
 	if (!se_sess->sess_cmd_map) {
-		se_sess->sess_cmd_map = vzalloc(tag_num * tag_size);
+		se_sess->sess_cmd_map = vzalloc(array_size(tag_size, tag_num));
 		if (!se_sess->sess_cmd_map) {
 			pr_err("Unable to allocate se_sess->sess_cmd_map\n");
 			return -ENOMEM;
* Unmerged path fs/nfsd/nfscache.c
diff --git a/fs/reiserfs/journal.c b/fs/reiserfs/journal.c
index 742fdd4c209a..41ce414b6711 100644
--- a/fs/reiserfs/journal.c
+++ b/fs/reiserfs/journal.c
@@ -351,7 +351,8 @@ static struct reiserfs_journal_cnode *allocate_cnodes(int num_cnodes)
 	if (num_cnodes <= 0) {
 		return NULL;
 	}
-	head = vzalloc(num_cnodes * sizeof(struct reiserfs_journal_cnode));
+	head = vzalloc(array_size(num_cnodes,
+				  sizeof(struct reiserfs_journal_cnode)));
 	if (!head) {
 		return NULL;
 	}
diff --git a/fs/reiserfs/resize.c b/fs/reiserfs/resize.c
index 3ce02cff5e90..7086dc612b2d 100644
--- a/fs/reiserfs/resize.c
+++ b/fs/reiserfs/resize.c
@@ -110,7 +110,8 @@ int reiserfs_resize(struct super_block *s, unsigned long block_count_new)
 		/* allocate additional bitmap blocks, reallocate array of bitmap
 		 * block pointers */
 		bitmap =
-		    vzalloc(sizeof(struct reiserfs_bitmap_info) * bmap_nr_new);
+		    vzalloc(array_size(bmap_nr_new,
+				       sizeof(struct reiserfs_bitmap_info)));
 		if (!bitmap) {
 			/* Journal bitmaps are still supersized, but the memory isn't
 			 * leaked, so I guess it's ok */
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index 38f6885d32ed..def4825bfc5b 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -5071,7 +5071,8 @@ static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,
 
 	if (cnt == 1)
 		return 0;
-	new_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);
+	new_data = vzalloc(array_size(prog_len,
+				      sizeof(struct bpf_insn_aux_data)));
 	if (!new_data)
 		return -ENOMEM;
 	memcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);
@@ -5703,8 +5704,9 @@ int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)
 		return -ENOMEM;
 	log = &env->log;
 
-	env->insn_aux_data = vzalloc(sizeof(struct bpf_insn_aux_data) *
-				     (*prog)->len);
+	env->insn_aux_data =
+		vzalloc(array_size(sizeof(struct bpf_insn_aux_data),
+				   (*prog)->len));
 	ret = -ENOMEM;
 	if (!env->insn_aux_data)
 		goto err_free_env;
* Unmerged path kernel/kexec_file.c
* Unmerged path lib/test_firmware.c
* Unmerged path lib/test_kmod.c
* Unmerged path lib/test_rhashtable.c
* Unmerged path net/core/ethtool.c
* Unmerged path net/packet/af_packet.c
