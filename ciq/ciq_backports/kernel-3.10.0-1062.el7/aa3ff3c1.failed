ovl: copy up of disconnected dentries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit aa3ff3c152ff94ef045ed802db7535167f8a21ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/aa3ff3c1.failed

With NFS export, some operations on decoded file handles (e.g. open,
link, setattr, xattr_set) may call copy up with a disconnected non-dir.
In this case, we will copy up lower inode to index dir without
linking it to upper dir.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit aa3ff3c152ff94ef045ed802db7535167f8a21ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
diff --cc fs/overlayfs/copy_up.c
index 5bfbfc122918,d855f508fa20..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -748,13 -731,17 +762,23 @@@ static int ovl_copy_up_one(struct dentr
  	if (err)
  		return err;
  
- 	ovl_path_upper(parent, &parentpath);
- 	ctx.destdir = parentpath.dentry;
- 	ctx.destname = dentry->d_name;
+ 	if (parent) {
+ 		ovl_path_upper(parent, &parentpath);
+ 		ctx.destdir = parentpath.dentry;
+ 		ctx.destname = dentry->d_name;
  
++<<<<<<< HEAD
 +	err = vfs_getattr(&parentpath, &ctx.pstat);
 +	if (err)
 +		return err;
++=======
+ 		err = vfs_getattr(&parentpath, &ctx.pstat,
+ 				  STATX_ATIME | STATX_MTIME,
+ 				  AT_STATX_SYNC_AS_STAT);
+ 		if (err)
+ 			return err;
+ 	}
++>>>>>>> aa3ff3c152ff (ovl: copy up of disconnected dentries)
  
  	/* maybe truncate regular file. this has no effect on dirs */
  	if (flags & O_TRUNC)
* Unmerged path fs/overlayfs/copy_up.c
diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c
index 7f9756cc00a1..8ed17c13b7e2 100644
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@ -386,8 +386,10 @@ struct posix_acl *ovl_get_acl(struct inode *inode, int type)
 
 static bool ovl_open_need_copy_up(struct dentry *dentry, int flags)
 {
+	/* Copy up of disconnected dentry does not set upper alias */
 	if (ovl_dentry_upper(dentry) &&
-	    ovl_dentry_has_upper_alias(dentry))
+	    (ovl_dentry_has_upper_alias(dentry) ||
+	     (dentry->d_flags & DCACHE_DISCONNECTED)))
 		return false;
 
 	if (special_file(d_inode(dentry)->i_mode))
diff --git a/fs/overlayfs/util.c b/fs/overlayfs/util.c
index 4e2084dd51e3..7482beb54f47 100644
--- a/fs/overlayfs/util.c
+++ b/fs/overlayfs/util.c
@@ -211,9 +211,10 @@ void ovl_dentry_set_opaque(struct dentry *dentry)
 }
 
 /*
- * For hard links it's possible for ovl_dentry_upper() to return positive, while
- * there's no actual upper alias for the inode.  Copy up code needs to know
- * about the existence of the upper alias, so it can't use ovl_dentry_upper().
+ * For hard links and decoded file handles, it's possible for ovl_dentry_upper()
+ * to return positive, while there's no actual upper alias for the inode.
+ * Copy up code needs to know about the existence of the upper alias, so it
+ * can't use ovl_dentry_upper().
  */
 bool ovl_dentry_has_upper_alias(struct dentry *dentry)
 {
