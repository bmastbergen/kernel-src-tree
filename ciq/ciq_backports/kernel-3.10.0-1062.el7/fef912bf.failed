block: genhd: add 'groups' argument to device_add_disk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [block] genhd: add 'groups' argument to device_add_disk (Ming Lei) [1635708]
Rebuild_FUZZ: 93.07%
commit-author Hannes Reinecke <hare@suse.de>
commit fef912bf860e8e7e48a2bfb978a356bba743a8b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fef912bf.failed

Update device_add_disk() to take an 'groups' argument so that
individual drivers can register a device with additional sysfs
attributes.
This avoids race condition the driver would otherwise have if these
groups were to be created with sysfs_add_groups().

	Signed-off-by: Martin Wilck <martin.wilck@suse.com>
	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Bart Van Assche <bvanassche@acm.org>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit fef912bf860e8e7e48a2bfb978a356bba743a8b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/um/drivers/ubd_kern.c
#	block/genhd.c
#	drivers/block/floppy.c
#	drivers/block/mtip32xx/mtip32xx.c
#	drivers/block/ps3disk.c
#	drivers/block/ps3vram.c
#	drivers/block/rsxx/dev.c
#	drivers/block/skd_main.c
#	drivers/block/sunvdc.c
#	drivers/block/virtio_blk.c
#	drivers/block/xen-blkfront.c
#	drivers/ide/ide-cd.c
#	drivers/ide/ide-gd.c
#	drivers/memstick/core/ms_block.c
#	drivers/memstick/core/mspro_block.c
#	drivers/mmc/core/block.c
#	drivers/mtd/mtd_blkdevs.c
#	drivers/nvdimm/blk.c
#	drivers/nvdimm/btt.c
#	drivers/nvdimm/pmem.c
#	drivers/nvme/host/core.c
#	drivers/nvme/host/multipath.c
#	drivers/s390/block/dasd_genhd.c
#	drivers/s390/block/dcssblk.c
#	drivers/s390/block/scm_blk.c
#	drivers/scsi/sd.c
#	drivers/scsi/sr.c
#	include/linux/genhd.h
diff --cc arch/um/drivers/ubd_kern.c
index 879990cb66c6,6ee4c56032f7..000000000000
--- a/arch/um/drivers/ubd_kern.c
+++ b/arch/um/drivers/ubd_kern.c
@@@ -832,7 -891,7 +832,11 @@@ static int ubd_disk_register(int major
  
  	disk->private_data = &ubd_devs[unit];
  	disk->queue = ubd_devs[unit].queue;
++<<<<<<< HEAD
 +	add_disk(disk);
++=======
+ 	device_add_disk(parent, disk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  
  	*disk_out = disk;
  	return 0;
diff --cc block/genhd.c
index a01c5185b066,ef0936184d69..000000000000
--- a/block/genhd.c
+++ b/block/genhd.c
@@@ -556,7 -567,8 +556,12 @@@ static int exact_lock(dev_t devt, void 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void register_disk(struct gendisk *disk)
++=======
+ static void register_disk(struct device *parent, struct gendisk *disk,
+ 			  const struct attribute_group **groups)
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  {
  	struct device *ddev = disk_to_dev(disk);
  	struct block_device *bdev;
@@@ -623,8 -644,15 +632,9 @@@ exit
  }
  
  /**
 - * __device_add_disk - add disk information to kernel list
 - * @parent: parent device for the disk
 + * __add_disk - add partitioning information to kernel list
   * @disk: per-device partitioning information
+  * @groups: Additional per-device sysfs groups
   * @register_queue: register the queue if set to true
   *
   * This function registers the partitioning information in @disk
@@@ -632,9 -660,10 +642,15 @@@
   *
   * FIXME: error handling
   */
++<<<<<<< HEAD
 +static void __add_disk(struct gendisk *disk, bool register_queue)
++=======
+ static void __device_add_disk(struct device *parent, struct gendisk *disk,
+ 			      const struct attribute_group **groups,
+ 			      bool register_queue)
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  {
 +	struct backing_dev_info *bdi;
  	dev_t devt;
  	int retval;
  
@@@ -662,13 -687,25 +678,25 @@@
  
  	disk_alloc_events(disk);
  
 -	if (disk->flags & GENHD_FL_HIDDEN) {
 -		/*
 -		 * Don't let hidden disks show up in /proc/partitions,
 -		 * and don't bother scanning for partitions either.
 -		 */
 -		disk->flags |= GENHD_FL_SUPPRESS_PARTITION_INFO;
 -		disk->flags |= GENHD_FL_NO_PART_SCAN;
 -	} else {
 -		int ret;
 +	/* Register BDI before referencing it from bdev */
 +	bdi = &disk->queue->backing_dev_info;
 +	bdi_register_dev(bdi, disk_devt(disk));
  
++<<<<<<< HEAD
 +	blk_register_region(disk_devt(disk), disk->minors, NULL,
 +			    exact_match, exact_lock, disk);
 +	register_disk(disk);
++=======
+ 		/* Register BDI before referencing it from bdev */
+ 		disk_to_dev(disk)->devt = devt;
+ 		ret = bdi_register_owner(disk->queue->backing_dev_info,
+ 						disk_to_dev(disk));
+ 		WARN_ON(ret);
+ 		blk_register_region(disk_devt(disk), disk->minors, NULL,
+ 				    exact_match, exact_lock, disk);
+ 	}
+ 	register_disk(parent, disk, groups);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	if (register_queue)
  		blk_register_queue(disk);
  
@@@ -678,24 -715,23 +706,36 @@@
  	 */
  	WARN_ON_ONCE(!blk_get_queue(disk->queue));
  
 +	retval = sysfs_create_link(&disk_to_dev(disk)->kobj, &bdi->dev->kobj,
 +				   "bdi");
 +	WARN_ON(retval);
 +
  	disk_add_events(disk);
 -	blk_integrity_add(disk);
  }
  
++<<<<<<< HEAD
 +void add_disk(struct gendisk *disk)
 +{
 +	__add_disk(disk, true);
++=======
+ void device_add_disk(struct device *parent, struct gendisk *disk,
+ 		     const struct attribute_group **groups)
+ 
+ {
+ 	__device_add_disk(parent, disk, groups, true);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  }
 -EXPORT_SYMBOL(device_add_disk);
 +EXPORT_SYMBOL(add_disk);
  
 -void device_add_disk_no_queue_reg(struct device *parent, struct gendisk *disk)
 +void add_disk_no_queue_reg(struct gendisk *disk)
  {
++<<<<<<< HEAD
 +	__add_disk(disk, false);
++=======
+ 	__device_add_disk(parent, disk, NULL, false);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  }
 -EXPORT_SYMBOL(device_add_disk_no_queue_reg);
 +EXPORT_SYMBOL(add_disk_no_queue_reg);
  
  void del_gendisk(struct gendisk *disk)
  {
diff --cc drivers/block/floppy.c
index 5066fd80a6b6,1bc99e9dfaee..000000000000
--- a/drivers/block/floppy.c
+++ b/drivers/block/floppy.c
@@@ -4308,8 -4676,7 +4308,12 @@@ static int __init do_floppy_init(void
  		/* to be cleaned up... */
  		disks[drive]->private_data = (void *)(long)drive;
  		disks[drive]->flags |= GENHD_FL_REMOVABLE;
++<<<<<<< HEAD
 +		disks[drive]->driverfs_dev = &floppy_device[drive].dev;
 +		add_disk(disks[drive]);
++=======
+ 		device_add_disk(&floppy_device[drive].dev, disks[drive], NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	}
  
  	return 0;
diff --cc drivers/block/mtip32xx/mtip32xx.c
index 7b858c0dd825,1d7d48d8a205..000000000000
--- a/drivers/block/mtip32xx/mtip32xx.c
+++ b/drivers/block/mtip32xx/mtip32xx.c
@@@ -4034,7 -3861,7 +4034,11 @@@ skip_create_disk
  	set_capacity(dd->disk, capacity);
  
  	/* Enable the block device and add it to /dev */
++<<<<<<< HEAD
 +	add_disk(dd->disk);
++=======
+ 	device_add_disk(&dd->pdev->dev, dd->disk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  
  	dd->bdev = bdget_disk(dd->disk, 0);
  	/*
diff --cc drivers/block/ps3disk.c
index d754a88d7585,29a4419e8ba3..000000000000
--- a/drivers/block/ps3disk.c
+++ b/drivers/block/ps3disk.c
@@@ -500,7 -500,7 +500,11 @@@ static int ps3disk_probe(struct ps3_sys
  		 gendisk->disk_name, priv->model, priv->raw_capacity >> 11,
  		 get_capacity(gendisk) >> 11);
  
++<<<<<<< HEAD
 +	add_disk(gendisk);
++=======
+ 	device_add_disk(&dev->sbd.core, gendisk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	return 0;
  
  fail_cleanup_queue:
diff --cc drivers/block/ps3vram.c
index 06a2e53e5f37,c0c50816a10b..000000000000
--- a/drivers/block/ps3vram.c
+++ b/drivers/block/ps3vram.c
@@@ -775,7 -769,7 +775,11 @@@ static int ps3vram_probe(struct ps3_sys
  	dev_info(&dev->core, "%s: Using %lu MiB of GPU memory\n",
  		 gendisk->disk_name, get_capacity(gendisk) >> 11);
  
++<<<<<<< HEAD
 +	add_disk(gendisk);
++=======
+ 	device_add_disk(&dev->core, gendisk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	return 0;
  
  fail_cleanup_queue:
diff --cc drivers/block/rsxx/dev.c
index 7f5426009d76,3894aa0f350b..000000000000
--- a/drivers/block/rsxx/dev.c
+++ b/drivers/block/rsxx/dev.c
@@@ -243,8 -226,7 +243,12 @@@ int rsxx_attach_dev(struct rsxx_cardinf
  			set_capacity(card->gendisk, card->size8 >> 9);
  		else
  			set_capacity(card->gendisk, 0);
++<<<<<<< HEAD
 +		add_disk(card->gendisk);
 +
++=======
+ 		device_add_disk(CARD_TO_DEV(card), card->gendisk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  		card->bdev_attached = 1;
  	}
  
diff --cc drivers/block/sunvdc.c
index 5814deb6963d,09409edce384..000000000000
--- a/drivers/block/sunvdc.c
+++ b/drivers/block/sunvdc.c
@@@ -704,11 -821,36 +704,15 @@@ static int probe_disk(struct vdc_port *
  
  	set_capacity(g, port->vdisk_size);
  
 -	if (vdc_version_supported(port, 1, 1)) {
 -		switch (port->vdisk_mtype) {
 -		case VD_MEDIA_TYPE_CD:
 -			pr_info(PFX "Virtual CDROM %s\n", port->disk_name);
 -			g->flags |= GENHD_FL_CD;
 -			g->flags |= GENHD_FL_REMOVABLE;
 -			set_disk_ro(g, 1);
 -			break;
 -
 -		case VD_MEDIA_TYPE_DVD:
 -			pr_info(PFX "Virtual DVD %s\n", port->disk_name);
 -			g->flags |= GENHD_FL_CD;
 -			g->flags |= GENHD_FL_REMOVABLE;
 -			set_disk_ro(g, 1);
 -			break;
 -
 -		case VD_MEDIA_TYPE_FIXED:
 -			pr_info(PFX "Virtual Hard disk %s\n", port->disk_name);
 -			break;
 -		}
 -	}
 -
 -	blk_queue_physical_block_size(q, port->vdisk_phys_blksz);
 -
 -	pr_info(PFX "%s: %u sectors (%u MB) protocol %d.%d\n",
 +	printk(KERN_INFO PFX "%s: %u sectors (%u MB)\n",
  	       g->disk_name,
 -	       port->vdisk_size, (port->vdisk_size >> (20 - 9)),
 -	       port->vio.ver.major, port->vio.ver.minor);
 +	       port->vdisk_size, (port->vdisk_size >> (20 - 9)));
  
++<<<<<<< HEAD
 +	add_disk(g);
++=======
+ 	device_add_disk(&port->vio.vdev->dev, g, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  
  	return 0;
  }
diff --cc drivers/block/virtio_blk.c
index d71d1da44f3e,fe80560000a1..000000000000
--- a/drivers/block/virtio_blk.c
+++ b/drivers/block/virtio_blk.c
@@@ -732,7 -780,7 +732,11 @@@ static int virtblk_probe(struct virtio_
  	virtblk_update_capacity(vblk, false);
  	virtio_device_ready(vdev);
  
++<<<<<<< HEAD
 +	add_disk(vblk->disk);
++=======
+ 	device_add_disk(&vdev->dev, vblk->disk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	err = device_create_file(disk_to_dev(vblk->disk), &dev_attr_serial);
  	if (err)
  		goto out_del_disk;
diff --cc drivers/block/xen-blkfront.c
index 5cb25b62d3a8,e5e40272d233..000000000000
--- a/drivers/block/xen-blkfront.c
+++ b/drivers/block/xen-blkfront.c
@@@ -1881,14 -2416,18 +1881,18 @@@ static void blkfront_connect(struct blk
  	xenbus_switch_state(info->xbdev, XenbusStateConnected);
  
  	/* Kick pending requests. */
 +	spin_lock_irq(&info->io_lock);
  	info->connected = BLKIF_STATE_CONNECTED;
 -	for (i = 0; i < info->nr_rings; i++)
 -		kick_pending_request_queues(&info->rinfo[i]);
 +	kick_pending_request_queues(info);
 +	spin_unlock_irq(&info->io_lock);
  
++<<<<<<< HEAD
 +	add_disk(info->gd);
++=======
+ 	device_add_disk(&info->xbdev->dev, info->gd, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  
  	info->is_ready = 1;
 -	return;
 -
 -fail:
 -	blkif_free(info, 0);
 -	return;
  }
  
  /**
diff --cc drivers/ide/ide-cd.c
index 99cb9fa2d135,f9b59d41813f..000000000000
--- a/drivers/ide/ide-cd.c
+++ b/drivers/ide/ide-cd.c
@@@ -1779,10 -1781,10 +1779,14 @@@ static int ide_cd_probe(ide_drive_t *dr
  		goto failed;
  	}
  
 -	ide_cd_read_toc(drive);
 +	ide_cd_read_toc(drive, &sense);
  	g->fops = &idecd_ops;
  	g->flags |= GENHD_FL_REMOVABLE | GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;
++<<<<<<< HEAD
 +	add_disk(g);
++=======
+ 	device_add_disk(&drive->gendev, g, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	return 0;
  
  out_free_disk:
diff --cc drivers/ide/ide-gd.c
index 838996a0039e,04e008e8f6f9..000000000000
--- a/drivers/ide/ide-gd.c
+++ b/drivers/ide/ide-gd.c
@@@ -417,7 -416,7 +417,11 @@@ static int ide_gd_probe(ide_drive_t *dr
  	if (drive->dev_flags & IDE_DFLAG_REMOVABLE)
  		g->flags = GENHD_FL_REMOVABLE;
  	g->fops = &ide_gd_ops;
++<<<<<<< HEAD
 +	add_disk(g);
++=======
+ 	device_add_disk(&drive->gendev, g, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	return 0;
  
  out_free_disk:
diff --cc drivers/memstick/core/mspro_block.c
index f4176ca3a794,0cd30dcb6801..000000000000
--- a/drivers/memstick/core/mspro_block.c
+++ b/drivers/memstick/core/mspro_block.c
@@@ -1255,7 -1236,7 +1255,11 @@@ static int mspro_block_init_disk(struc
  	set_capacity(msb->disk, capacity);
  	dev_dbg(&card->dev, "capacity set %ld\n", capacity);
  
++<<<<<<< HEAD
 +	add_disk(msb->disk);
++=======
+ 	device_add_disk(&card->dev, msb->disk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	msb->active = 1;
  	return 0;
  
diff --cc drivers/mmc/core/block.c
index 138097e112ef,de8e1a8be690..000000000000
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@@ -2682,7 -2698,7 +2682,11 @@@ static int mmc_add_disk(struct mmc_blk_
  	int ret;
  	struct mmc_card *card = md->queue.card;
  
++<<<<<<< HEAD
 +	add_disk(md->disk);
++=======
+ 	device_add_disk(md->parent, md->disk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	md->force_ro.show = force_ro_show;
  	md->force_ro.store = force_ro_store;
  	sysfs_attr_init(&md->force_ro.attr);
diff --cc drivers/mtd/mtd_blkdevs.c
index 942627ebcf0e,6a41dfa3c36b..000000000000
--- a/drivers/mtd/mtd_blkdevs.c
+++ b/drivers/mtd/mtd_blkdevs.c
@@@ -434,7 -447,7 +434,11 @@@ int add_mtd_blktrans_dev(struct mtd_blk
  	if (new->readonly)
  		set_disk_ro(gd, 1);
  
++<<<<<<< HEAD
 +	add_disk(gd);
++=======
+ 	device_add_disk(&new->mtd->dev, gd, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  
  	if (new->disk_attributes) {
  		ret = sysfs_create_group(&disk_to_dev(gd)->kobj,
diff --cc drivers/nvdimm/blk.c
index ab9ea3365928,db45c6bbb7bb..000000000000
--- a/drivers/nvdimm/blk.c
+++ b/drivers/nvdimm/blk.c
@@@ -289,6 -282,16 +289,19 @@@ static int nsblk_attach_disk(struct nd_
  	if (devm_add_action_or_reset(dev, nd_blk_release_disk, disk))
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	if (nsblk_meta_size(nsblk)) {
+ 		int rc = nd_integrity_init(disk, nsblk_meta_size(nsblk));
+ 
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	set_capacity(disk, available_disk_size >> SECTOR_SHIFT);
+ 	device_add_disk(dev, disk, NULL);
+ 	revalidate_disk(disk);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	return 0;
  }
  
diff --cc drivers/nvdimm/btt.c
index 27547be90e5a,b123b0dcf274..000000000000
--- a/drivers/nvdimm/btt.c
+++ b/drivers/nvdimm/btt.c
@@@ -1540,28 -1542,23 +1540,32 @@@ static int btt_blk_init(struct btt *btt
  	blk_queue_make_request(btt->btt_queue, btt_make_request);
  	blk_queue_logical_block_size(btt->btt_queue, btt->sector_size);
  	blk_queue_max_hw_sectors(btt->btt_queue, UINT_MAX);
 -	blk_queue_flag_set(QUEUE_FLAG_NONROT, btt->btt_queue);
 +	blk_queue_bounce_limit(btt->btt_queue, BLK_BOUNCE_ANY);
 +	queue_flag_set_unlocked(QUEUE_FLAG_NONROT, btt->btt_queue);
  	btt->btt_queue->queuedata = btt;
  
 -	if (btt_meta_size(btt)) {
 -		int rc = nd_integrity_init(btt->btt_disk, btt_meta_size(btt));
 -
 -		if (rc) {
 -			del_gendisk(btt->btt_disk);
 -			put_disk(btt->btt_disk);
 -			blk_cleanup_queue(btt->btt_queue);
 -			return rc;
 -		}
 -	}
  	set_capacity(btt->btt_disk, btt->nlba * btt->sector_size >> 9);
++<<<<<<< HEAD
++=======
+ 	device_add_disk(&btt->nd_btt->dev, btt->btt_disk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	btt->nd_btt->size = btt->nlba * (u64)btt->sector_size;
 -	revalidate_disk(btt->btt_disk);
 +	add_disk(btt->btt_disk);
 +	/*
 +	 * The btt driver from RHEL 7.5 onward does not support DIF/DIX.
 +	 * If there is an existing btt devices with a non-standard sector
 +	 * size, allow the admin to read the data from it.  Writes would
 +	 * also be possible, but we wouldn't write protection information,
 +	 * which would result in check errors when reading under an older
 +	 * (or upstream) kernel.  Note that the admin can still override
 +	 * the read-only setting at his or her own peril.
 +	 */
 +	if (!btt_lbasize_is_supported(nd_btt->lbasize)) {
 +		set_disk_ro(btt->btt_disk, 1);
 +		dev_warn(&nd_btt->dev, "Unsupported sector size: %lu. Integrity "
 +			 "checking is disabled.  Marking device read-only.\n",
 +			 nd_btt->lbasize);
 +	}
  
  	return 0;
  }
diff --cc drivers/nvdimm/pmem.c
index ea3654f15d99,a75d10c23d80..000000000000
--- a/drivers/nvdimm/pmem.c
+++ b/drivers/nvdimm/pmem.c
@@@ -413,7 -474,7 +413,11 @@@ static int pmem_attach_disk(struct devi
  	gendev = disk_to_dev(disk);
  	gendev->groups = pmem_attribute_groups;
  
++<<<<<<< HEAD
 +	add_disk(disk);
++=======
+ 	device_add_disk(dev, disk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	if (devm_add_action_or_reset(dev, pmem_release_disk, pmem))
  		return -ENOMEM;
  
diff --cc drivers/nvme/host/core.c
index cb5cd8fffb1e,0e824e8c8fd7..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -2428,18 -3099,28 +2428,22 @@@ static void nvme_alloc_ns(struct nvme_c
  
  	nvme_get_ctrl(ctrl);
  
++<<<<<<< HEAD
 +	add_disk(ns->disk);
++=======
+ 	device_add_disk(ctrl->device, ns->disk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	if (sysfs_create_group(&disk_to_dev(ns->disk)->kobj,
 -					&nvme_ns_id_attr_group))
 +					&nvme_ns_attr_group))
  		pr_warn("%s: failed to create sysfs group for identification\n",
  			ns->disk->disk_name);
 -	if (ns->ndev && nvme_nvm_register_sysfs(ns))
 -		pr_warn("%s: failed to register lightnvm sysfs group for identification\n",
 -			ns->disk->disk_name);
 -
 -	nvme_mpath_add_disk(ns, id);
 -	nvme_fault_inject_init(ns);
 -	kfree(id);
 -
  	return;
 - out_unlink_ns:
 -	mutex_lock(&ctrl->subsys->lock);
 -	list_del_rcu(&ns->siblings);
 -	mutex_unlock(&ctrl->subsys->lock);
 - out_free_id:
 -	kfree(id);
 + out_free_disk:
 +	kfree(disk);
   out_free_queue:
  	blk_cleanup_queue(ns->queue);
 + out_release_instance:
 +	ida_simple_remove(&ctrl->ns_ida, ns->instance);
   out_free_ns:
  	kfree(ns);
  }
diff --cc drivers/s390/block/dasd_genhd.c
index f601480268d2,5542d9eadfe0..000000000000
--- a/drivers/s390/block/dasd_genhd.c
+++ b/drivers/s390/block/dasd_genhd.c
@@@ -76,7 -76,7 +76,11 @@@ int dasd_gendisk_alloc(struct dasd_bloc
  	gdp->queue = block->request_queue;
  	block->gdp = gdp;
  	set_capacity(block->gdp, 0);
++<<<<<<< HEAD
 +	add_disk(block->gdp);
++=======
+ 	device_add_disk(&base->cdev->dev, block->gdp, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	return 0;
  }
  
diff --cc drivers/s390/block/dcssblk.c
index 44a7bf955842,4e8aedd50cb0..000000000000
--- a/drivers/s390/block/dcssblk.c
+++ b/drivers/s390/block/dcssblk.c
@@@ -680,7 -685,7 +680,11 @@@ dcssblk_add_store(struct device *dev, s
  	}
  
  	get_device(&dev_info->dev);
++<<<<<<< HEAD
 +	add_disk(dev_info->gd);
++=======
+ 	device_add_disk(&dev_info->dev, dev_info->gd, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  
  	switch (dev_info->segment_type) {
  		case SEG_TYPE_SR:
diff --cc drivers/s390/block/scm_blk.c
index 595ea9b1f8ce,e01889394c84..000000000000
--- a/drivers/s390/block/scm_blk.c
+++ b/drivers/s390/block/scm_blk.c
@@@ -527,7 -500,7 +527,11 @@@ int scm_blk_dev_setup(struct scm_blk_de
  
  	/* 512 byte sectors */
  	set_capacity(bdev->gendisk, scmdev->size >> 9);
++<<<<<<< HEAD
 +	add_disk(bdev->gendisk);
++=======
+ 	device_add_disk(&scmdev->dev, bdev->gendisk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	return 0;
  
  out_queue:
diff --cc drivers/scsi/sd.c
index 248f420c9060,67ed5906b462..000000000000
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@@ -3009,7 -3272,7 +3009,11 @@@ static void sd_probe_async(void *data, 
  	}
  
  	blk_pm_runtime_init(sdp->request_queue, dev);
++<<<<<<< HEAD
 +	add_disk(gd);
++=======
+ 	device_add_disk(dev, gd, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  	if (sdkp->capacity)
  		sd_dif_config_host(sdkp);
  
diff --cc drivers/scsi/sr.c
index 1b512aa15509,54dd70ae9731..000000000000
--- a/drivers/scsi/sr.c
+++ b/drivers/scsi/sr.c
@@@ -757,9 -751,15 +757,13 @@@ static int sr_probe(struct device *dev
  	if (register_cdrom(&cd->cdi))
  		goto fail_put;
  
 -	/*
 -	 * Initialize block layer runtime PM stuffs before the
 -	 * periodic event checking request gets started in add_disk.
 -	 */
 -	blk_pm_runtime_init(sdev->request_queue, dev);
 -
  	dev_set_drvdata(dev, cd);
  	disk->flags |= GENHD_FL_REMOVABLE;
++<<<<<<< HEAD
 +	add_disk(disk);
++=======
+ 	device_add_disk(&sdev->sdev_gendev, disk, NULL);
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  
  	sdev_printk(KERN_DEBUG, sdev,
  		    "Attached scsi CD-ROM %s\n", cd->cdi.name);
diff --cc include/linux/genhd.h
index c146ec8530b7,0b820ff05839..000000000000
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@@ -408,8 -399,18 +408,23 @@@ static inline void free_part_info(struc
  extern void part_round_stats(struct request_queue *q, int cpu, struct hd_struct *part);
  
  /* block/genhd.c */
++<<<<<<< HEAD
 +extern void add_disk(struct gendisk *disk);
 +extern void add_disk_no_queue_reg(struct gendisk *disk);
++=======
+ extern void device_add_disk(struct device *parent, struct gendisk *disk,
+ 			    const struct attribute_group **groups);
+ static inline void add_disk(struct gendisk *disk)
+ {
+ 	device_add_disk(NULL, disk, NULL);
+ }
+ extern void device_add_disk_no_queue_reg(struct device *parent, struct gendisk *disk);
+ static inline void add_disk_no_queue_reg(struct gendisk *disk)
+ {
+ 	device_add_disk_no_queue_reg(NULL, disk);
+ }
+ 
++>>>>>>> fef912bf860e (block: genhd: add 'groups' argument to device_add_disk)
  extern void del_gendisk(struct gendisk *gp);
  extern struct gendisk *get_gendisk(dev_t dev, int *partno);
  extern struct block_device *bdget_disk(struct gendisk *disk, int partno);
* Unmerged path drivers/block/skd_main.c
* Unmerged path drivers/memstick/core/ms_block.c
* Unmerged path drivers/nvme/host/multipath.c
* Unmerged path arch/um/drivers/ubd_kern.c
* Unmerged path block/genhd.c
* Unmerged path drivers/block/floppy.c
* Unmerged path drivers/block/mtip32xx/mtip32xx.c
* Unmerged path drivers/block/ps3disk.c
* Unmerged path drivers/block/ps3vram.c
* Unmerged path drivers/block/rsxx/dev.c
* Unmerged path drivers/block/skd_main.c
* Unmerged path drivers/block/sunvdc.c
* Unmerged path drivers/block/virtio_blk.c
* Unmerged path drivers/block/xen-blkfront.c
* Unmerged path drivers/ide/ide-cd.c
* Unmerged path drivers/ide/ide-gd.c
* Unmerged path drivers/memstick/core/ms_block.c
* Unmerged path drivers/memstick/core/mspro_block.c
* Unmerged path drivers/mmc/core/block.c
* Unmerged path drivers/mtd/mtd_blkdevs.c
* Unmerged path drivers/nvdimm/blk.c
* Unmerged path drivers/nvdimm/btt.c
* Unmerged path drivers/nvdimm/pmem.c
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/multipath.c
* Unmerged path drivers/s390/block/dasd_genhd.c
* Unmerged path drivers/s390/block/dcssblk.c
* Unmerged path drivers/s390/block/scm_blk.c
* Unmerged path drivers/scsi/sd.c
* Unmerged path drivers/scsi/sr.c
* Unmerged path include/linux/genhd.h
