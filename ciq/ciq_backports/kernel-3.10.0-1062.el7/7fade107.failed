nfp: flower: use stats array instead of storing stats per flow

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
commit 7fade1077c5056a9a489110516143bbdf5a013c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7fade107.failed

Make use of an array stats instead of storing stats per flow which
would require a hash lookup at critical times.

	Signed-off-by: Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7fade1077c5056a9a489110516143bbdf5a013c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/main.h
#	drivers/net/ethernet/netronome/nfp/flower/metadata.c
#	drivers/net/ethernet/netronome/nfp/flower/offload.c
diff --cc drivers/net/ethernet/netronome/nfp/flower/main.h
index 90cc96d4eae4,2f01f2479d7c..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/main.h
+++ b/drivers/net/ethernet/netronome/nfp/flower/main.h
@@@ -173,7 -173,9 +175,13 @@@ struct nfp_flower_priv 
  	struct nfp_fl_stats_id stats_ids;
  	struct nfp_fl_mask_id mask_ids;
  	DECLARE_HASHTABLE(mask_table, NFP_FLOWER_MASK_HASH_BITS);
++<<<<<<< HEAD
 +	DECLARE_HASHTABLE(flow_table, NFP_FLOWER_HASH_BITS);
++=======
+ 	struct rhashtable flow_table;
+ 	struct nfp_fl_stats *stats;
+ 	spinlock_t stats_lock; /* lock stats */
++>>>>>>> 7fade1077c50 (nfp: flower: use stats array instead of storing stats per flow)
  	struct work_struct cmsg_work;
  	struct sk_buff_head cmsg_skbs_high;
  	struct sk_buff_head cmsg_skbs_low;
@@@ -229,11 -231,10 +237,9 @@@ struct nfp_fl_stats 
  struct nfp_fl_payload {
  	struct nfp_fl_rule_metadata meta;
  	unsigned long tc_flower_cookie;
 -	struct rhash_head fl_node;
 +	struct hlist_node link;
  	struct rcu_head rcu;
- 	spinlock_t lock; /* lock stats */
- 	struct nfp_fl_stats stats;
  	__be32 nfp_tun_ipv4_addr;
 -	struct net_device *ingress_dev;
  	char *unmasked_data;
  	char *mask_data;
  	char *action_data;
diff --cc drivers/net/ethernet/netronome/nfp/flower/metadata.c
index c748aceb17bb,f0db7f9122d2..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/metadata.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/metadata.c
@@@ -99,46 -105,20 +99,49 @@@ static int nfp_get_stats_entry(struct n
  
  /* Must be called with either RTNL or rcu_read_lock */
  struct nfp_fl_payload *
 -nfp_flower_search_fl_table(struct nfp_app *app, unsigned long tc_flower_cookie,
 -			   struct net_device *netdev, __be32 host_ctx)
 +nfp_flower_search_fl_table(struct nfp_app *app, unsigned long tc_flower_cookie)
  {
 -	struct nfp_fl_flow_table_cmp_arg flower_cmp_arg;
 +	unsigned long fl_key = nfp_flower_fl_key(tc_flower_cookie);
  	struct nfp_flower_priv *priv = app->priv;
 +	struct nfp_fl_payload *flower_entry;
  
 -	flower_cmp_arg.netdev = netdev;
 -	flower_cmp_arg.cookie = tc_flower_cookie;
 -	flower_cmp_arg.host_ctx = host_ctx;
 +	hash_for_each_possible_rcu(priv->flow_table, flower_entry, link,
 +				   fl_key)
 +		if (flower_entry->tc_flower_cookie == tc_flower_cookie)
 +			return flower_entry;
  
 -	return rhashtable_lookup_fast(&priv->flow_table, &flower_cmp_arg,
 -				      nfp_flower_table_params);
 +	return NULL;
  }
  
++<<<<<<< HEAD
 +static void
 +nfp_flower_update_stats(struct nfp_app *app, struct nfp_fl_stats_frame *stats)
 +{
 +	struct nfp_fl_payload *nfp_flow;
 +	unsigned long flower_cookie;
 +
 +	flower_cookie = be64_to_cpu(stats->stats_cookie);
 +
 +	rcu_read_lock();
 +	nfp_flow = nfp_flower_search_fl_table(app, flower_cookie);
 +	if (!nfp_flow)
 +		goto exit_rcu_unlock;
 +
 +	if (nfp_flow->meta.host_ctx_id != stats->stats_con_id)
 +		goto exit_rcu_unlock;
 +
 +	spin_lock(&nfp_flow->lock);
 +	nfp_flow->stats.pkts += be32_to_cpu(stats->pkt_count);
 +	nfp_flow->stats.bytes += be64_to_cpu(stats->byte_count);
 +	nfp_flow->stats.used = jiffies;
 +	spin_unlock(&nfp_flow->lock);
 +
 +exit_rcu_unlock:
 +	rcu_read_unlock();
 +}
 +
++=======
++>>>>>>> 7fade1077c50 (nfp: flower: use stats array instead of storing stats per flow)
  void nfp_flower_rx_flow_stats(struct nfp_app *app, struct sk_buff *skb)
  {
  	unsigned int msg_len = nfp_flower_cmsg_get_data_len(skb);
@@@ -343,11 -332,12 +354,11 @@@ int nfp_compile_flow_metadata(struct nf
  
  	/* Update flow payload with mask ids. */
  	nfp_flow->unmasked_data[NFP_FL_MASK_ID_LOCATION] = new_mask_id;
- 	nfp_flow->stats.pkts = 0;
- 	nfp_flow->stats.bytes = 0;
- 	nfp_flow->stats.used = jiffies;
+ 	priv->stats[stats_cxt].pkts = 0;
+ 	priv->stats[stats_cxt].bytes = 0;
+ 	priv->stats[stats_cxt].used = jiffies;
  
 -	check_entry = nfp_flower_search_fl_table(app, flow->cookie, netdev,
 -						 NFP_FL_STATS_CTX_DONT_CARE);
 +	check_entry = nfp_flower_search_fl_table(app, flow->cookie);
  	if (check_entry) {
  		if (nfp_release_stats_entry(app, stats_cxt))
  			return -EINVAL;
@@@ -434,6 -480,9 +454,12 @@@ void nfp_flower_metadata_cleanup(struc
  	if (!priv)
  		return;
  
++<<<<<<< HEAD
++=======
+ 	rhashtable_free_and_destroy(&priv->flow_table,
+ 				    nfp_check_rhashtable_empty, NULL);
+ 	kvfree(priv->stats);
++>>>>>>> 7fade1077c50 (nfp: flower: use stats array instead of storing stats per flow)
  	kfree(priv->mask_ids.mask_id_free_list.buf);
  	kfree(priv->mask_ids.last_used);
  	vfree(priv->stats_ids.free_list.buf);
diff --cc drivers/net/ethernet/netronome/nfp/flower/offload.c
index 970ddbd64602,efe7a41e1a3e..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/offload.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/offload.c
@@@ -428,7 -428,7 +428,11 @@@ nfp_flower_allocate_new(struct nfp_fl_k
  
  	flow_pay->nfp_tun_ipv4_addr = 0;
  	flow_pay->meta.flags = 0;
++<<<<<<< HEAD
 +	spin_lock_init(&flow_pay->lock);
++=======
+ 	flow_pay->ingress_offload = !egress;
++>>>>>>> 7fade1077c50 (nfp: flower: use stats array instead of storing stats per flow)
  
  	return flow_pay;
  
@@@ -574,21 -599,33 +578,39 @@@ err_free_flow
   * Return: negative value on error, 0 if stats populated successfully.
   */
  static int
 -nfp_flower_get_stats(struct nfp_app *app, struct net_device *netdev,
 -		     struct tc_cls_flower_offload *flow, bool egress)
 +nfp_flower_get_stats(struct nfp_app *app, struct tc_cls_flower_offload *flow)
  {
+ 	struct nfp_flower_priv *priv = app->priv;
  	struct nfp_fl_payload *nfp_flow;
++<<<<<<< HEAD
++=======
+ 	struct net_device *ingr_dev;
+ 	u32 ctx_id;
++>>>>>>> 7fade1077c50 (nfp: flower: use stats array instead of storing stats per flow)
  
 -	ingr_dev = egress ? NULL : netdev;
 -	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie, ingr_dev,
 -					      NFP_FL_STATS_CTX_DONT_CARE);
 +	nfp_flow = nfp_flower_search_fl_table(app, flow->cookie);
  	if (!nfp_flow)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	spin_lock_bh(&nfp_flow->lock);
 +	tcf_exts_stats_update(flow->exts, nfp_flow->stats.bytes,
 +			      nfp_flow->stats.pkts, nfp_flow->stats.used);
++=======
+ 	if (nfp_flow->ingress_offload && egress)
+ 		return 0;
+ 
+ 	ctx_id = be32_to_cpu(nfp_flow->meta.host_ctx_id);
++>>>>>>> 7fade1077c50 (nfp: flower: use stats array instead of storing stats per flow)
+ 
+ 	spin_lock_bh(&priv->stats_lock);
+ 	tcf_exts_stats_update(flow->exts, priv->stats[ctx_id].bytes,
+ 			      priv->stats[ctx_id].pkts,
+ 			      priv->stats[ctx_id].used);
  
- 	nfp_flow->stats.pkts = 0;
- 	nfp_flow->stats.bytes = 0;
- 	spin_unlock_bh(&nfp_flow->lock);
+ 	priv->stats[ctx_id].pkts = 0;
+ 	priv->stats[ctx_id].bytes = 0;
+ 	spin_unlock_bh(&priv->stats_lock);
  
  	return 0;
  }
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/main.h
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/metadata.c
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/offload.c
