scsi: qla2xxx: Use complete switch scan for RSCN events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Use complete switch scan for RSCN events (Himanshu Madhani) [1655965]
Rebuild_FUZZ: 94.23%
commit-author Quinn Tran <qtran@marvell.com>
commit 1560bafdff9ed54857ac3a03c4c8d8f10d791ba6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/1560bafd.failed

This patch removes unnecessary code to handle RSCN, instead performs full
scan everytime driver receives RSCN

Fixes: d4f7a16aeca6f ("scsi: qla2xxx: Remove ASYNC GIDPN switch command")
	Cc: stable@vger.kernel.org #4.19
	Signed-off-by: Quinn Tran <qtran@marvell.com>
	Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 1560bafdff9ed54857ac3a03c4c8d8f10d791ba6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_init.c
diff --cc drivers/scsi/qla2xxx/qla_init.c
index 1c4bb984c354,8307eac796a2..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -1373,11 -1525,18 +1350,14 @@@ void qla24xx_handle_relogin_event(scsi_
  	qla24xx_fcport_handle_login(vha, fcport);
  }
  
 -
 -static void qla_handle_els_plogi_done(scsi_qla_host_t *vha,
 -				      struct event_arg *ea)
 -{
 -	ql_dbg(ql_dbg_disc, vha, 0x2118,
 -	    "%s %d %8phC post PRLI\n",
 -	    __func__, __LINE__, ea->fcport->port_name);
 -	qla24xx_post_prli_work(vha, ea->fcport);
 -}
 -
  void qla2x00_fcport_event_handler(scsi_qla_host_t *vha, struct event_arg *ea)
  {
++<<<<<<< HEAD
 +	fc_port_t *f, *tf;
 +	uint32_t id = 0, mask, rid;
 +	unsigned long flags;
++=======
++>>>>>>> 1560bafdff9e (scsi: qla2xxx: Use complete switch scan for RSCN events)
  	fc_port_t *fcport;
  
  	switch (ea->event) {
@@@ -1390,12 -1549,14 +1370,17 @@@
  	case FCME_RSCN:
  		if (test_bit(UNLOADING, &vha->dpc_flags))
  			return;
++<<<<<<< HEAD
 +		switch (ea->id.b.rsvd_1) {
 +		case RSCN_PORT_ADDR:
++=======
+ 		{
+ 			unsigned long flags;
++>>>>>>> 1560bafdff9e (scsi: qla2xxx: Use complete switch scan for RSCN events)
  			fcport = qla2x00_find_fcport_by_nportid
  				(vha, &ea->id, 1);
 -			if (fcport) {
 -				fcport->scan_needed = 1;
 -				fcport->rscn_gen++;
 -			}
 +			if (fcport)
 +				fcport->rscn_rcvd = 1;
  
  			spin_lock_irqsave(&vha->work_lock, flags);
  			if (vha->scan.scan_flags == 0) {
@@@ -1405,45 -1566,8 +1390,48 @@@
  				schedule_delayed_work(&vha->scan.scan_work, 5);
  			}
  			spin_unlock_irqrestore(&vha->work_lock, flags);
++<<<<<<< HEAD
 +
 +			break;
 +		case RSCN_AREA_ADDR:
 +		case RSCN_DOM_ADDR:
 +			if (ea->id.b.rsvd_1 == RSCN_AREA_ADDR) {
 +				mask = 0xffff00;
 +				ql_dbg(ql_dbg_async, vha, 0x5044,
 +				    "RSCN: Area 0x%06x was affected\n",
 +				    ea->id.b24);
 +			} else {
 +				mask = 0xff0000;
 +				ql_dbg(ql_dbg_async, vha, 0x507a,
 +				    "RSCN: Domain 0x%06x was affected\n",
 +				    ea->id.b24);
 +			}
 +
 +			rid = ea->id.b24 & mask;
 +			list_for_each_entry_safe(f, tf, &vha->vp_fcports,
 +			    list) {
 +				id = f->d_id.b24 & mask;
 +				if (rid == id) {
 +					ea->fcport = f;
 +					qla24xx_handle_rscn_event(f, ea);
 +				}
 +			}
 +			break;
 +		case RSCN_FAB_ADDR:
 +		default:
 +			ql_log(ql_log_warn, vha, 0xd045,
 +			    "RSCN: Fabric was affected. Addr format %d\n",
 +			    ea->id.b.rsvd_1);
 +			qla2x00_mark_all_devices_lost(vha, 1);
 +			set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
 +			set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
++=======
++>>>>>>> 1560bafdff9e (scsi: qla2xxx: Use complete switch scan for RSCN events)
  		}
  		break;
 +	case FCME_GIDPN_DONE:
 +		qla24xx_handle_gidpn_event(vha, ea);
 +		break;
  	case FCME_GNL_DONE:
  		qla24xx_handle_gnl_done_event(vha, ea);
  		break;
@@@ -1480,6 -1607,30 +1468,33 @@@
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * RSCN(s) came in for this fcport, but the RSCN(s) was not able
+  * to be consumed by the fcport
+  */
+ void qla_rscn_replay(fc_port_t *fcport)
+ {
+        struct event_arg ea;
+ 
+        switch (fcport->disc_state) {
+        case DSC_DELETE_PEND:
+                return;
+        default:
+                break;
+        }
+ 
+        if (fcport->scan_needed) {
+                memset(&ea, 0, sizeof(ea));
+                ea.event = FCME_RSCN;
+                ea.id = fcport->d_id;
+                ea.id.b.rsvd_1 = RSCN_PORT_ADDR;
+                qla2x00_fcport_event_handler(fcport->vha, &ea);
+ 	}
+ }
+ 
++>>>>>>> 1560bafdff9e (scsi: qla2xxx: Use complete switch scan for RSCN events)
  static void
  qla2x00_tmf_iocb_timeout(void *data)
  {
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
