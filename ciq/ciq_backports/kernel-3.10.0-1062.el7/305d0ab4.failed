KVM: nVMX: Fix nested #PF intends to break L1's vmlauch/vmresume

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wanpeng Li <wanpeng.li@hotmail.com>
commit 305d0ab4764d36a02c8e7cddb67099aca65351ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/305d0ab4.failed

------------[ cut here ]------------
 WARNING: CPU: 4 PID: 5280 at /home/kernel/linux/arch/x86/kvm//vmx.c:11394 nested_vmx_vmexit+0xc2b/0xd70 [kvm_intel]
 CPU: 4 PID: 5280 Comm: qemu-system-x86 Tainted: G        W  OE   4.13.0+ #17
 RIP: 0010:nested_vmx_vmexit+0xc2b/0xd70 [kvm_intel]
 Call Trace:
  ? emulator_read_emulated+0x15/0x20 [kvm]
  ? segmented_read+0xae/0xf0 [kvm]
  vmx_inject_page_fault_nested+0x60/0x70 [kvm_intel]
  ? vmx_inject_page_fault_nested+0x60/0x70 [kvm_intel]
  x86_emulate_instruction+0x733/0x810 [kvm]
  vmx_handle_exit+0x2f4/0xda0 [kvm_intel]
  ? kvm_arch_vcpu_ioctl_run+0xd2f/0x1c60 [kvm]
  kvm_arch_vcpu_ioctl_run+0xdab/0x1c60 [kvm]
  ? kvm_arch_vcpu_load+0x62/0x230 [kvm]
  kvm_vcpu_ioctl+0x340/0x700 [kvm]
  ? kvm_vcpu_ioctl+0x340/0x700 [kvm]
  ? __fget+0xfc/0x210
  do_vfs_ioctl+0xa4/0x6a0
  ? __fget+0x11d/0x210
  SyS_ioctl+0x79/0x90
  entry_SYSCALL_64_fastpath+0x23/0xc2

A nested #PF is triggered during L0 emulating instruction for L2. However, it
doesn't consider we should not break L1's vmlauch/vmresme. This patch fixes
it by queuing the #PF exception instead ,requesting an immediate VM exit from
L2 and keeping the exception for L1 pending for a subsequent nested VM exit.

This should actually work all the time, making vmx_inject_page_fault_nested
totally unnecessary.  However, that's not working yet, so this patch can work
around the issue in the meanwhile.

	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Wanpeng Li <wanpeng.li@hotmail.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 305d0ab4764d36a02c8e7cddb67099aca65351ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index c5d9f414275b,5bfa353f6354..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9733,12 -9845,16 +9733,23 @@@ static void vmx_inject_page_fault_neste
  
  	WARN_ON(!is_guest_mode(vcpu));
  
++<<<<<<< HEAD
 +	if (nested_vmx_is_page_fault_vmexit(vmcs12, fault->error_code))
 +		nested_vmx_vmexit(vcpu, to_vmx(vcpu)->exit_reason,
 +				  vmcs_read32(VM_EXIT_INTR_INFO),
 +				  vmcs_readl(EXIT_QUALIFICATION));
 +	else
++=======
+ 	if (nested_vmx_is_page_fault_vmexit(vmcs12, fault->error_code) &&
+ 		!to_vmx(vcpu)->nested.nested_run_pending) {
+ 		vmcs12->vm_exit_intr_error_code = fault->error_code;
+ 		nested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,
+ 				  PF_VECTOR | INTR_TYPE_HARD_EXCEPTION |
+ 				  INTR_INFO_DELIVER_CODE_MASK | INTR_INFO_VALID_MASK,
+ 				  fault->address);
+ 	} else {
++>>>>>>> 305d0ab4764d (KVM: nVMX: Fix nested #PF intends to break L1's vmlauch/vmresume)
  		kvm_inject_page_fault(vcpu, fault);
 -	}
  }
  
  static inline bool nested_vmx_merge_msr_bitmap(struct kvm_vcpu *vcpu,
* Unmerged path arch/x86/kvm/vmx.c
