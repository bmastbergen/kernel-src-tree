perf stat: Print per-thread shadow stats

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jin Yao <yao.jin@linux.intel.com>
commit e0128b30dbfb2884530251b4accdffdbf55a6b72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e0128b30.failed

The function perf_stat__print_shadow_stats() is called to print the
shadow stats on a set of static variables.

But the static variables are the limitations to support
per-thread shadow stats.

This patch lets the perf_stat__print_shadow_stats() support
to print the shadow stats from a input parameter 'st'.

It will not directly get value from static variable. Instead,
it now uses runtime_stat_avg() and runtime_stat_n() to get and
compute the values.

	Signed-off-by: Jin Yao <yao.jin@linux.intel.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Kan Liang <kan.liang@intel.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1512482591-4646-6-git-send-email-yao.jin@linux.intel.com
[ Rename 'stat' variables to 'st' to build on centos:{5,6} and others where it shadows a global declaration ]
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit e0128b30dbfb2884530251b4accdffdbf55a6b72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-script.c
#	tools/perf/util/stat-shadow.c
diff --cc tools/perf/builtin-script.c
index 42693597ec82,fac6f053e4da..000000000000
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@@ -1388,6 -1482,88 +1388,91 @@@ static int data_src__fprintf(u64 data_s
  	return fprintf(fp, "%-*s", maxlen, out);
  }
  
++<<<<<<< HEAD
++=======
+ struct metric_ctx {
+ 	struct perf_sample	*sample;
+ 	struct thread		*thread;
+ 	struct perf_evsel	*evsel;
+ 	FILE 			*fp;
+ };
+ 
+ static void script_print_metric(void *ctx, const char *color,
+ 			        const char *fmt,
+ 			        const char *unit, double val)
+ {
+ 	struct metric_ctx *mctx = ctx;
+ 
+ 	if (!fmt)
+ 		return;
+ 	perf_sample__fprintf_start(mctx->sample, mctx->thread, mctx->evsel,
+ 				   mctx->fp);
+ 	fputs("\tmetric: ", mctx->fp);
+ 	if (color)
+ 		color_fprintf(mctx->fp, color, fmt, val);
+ 	else
+ 		printf(fmt, val);
+ 	fprintf(mctx->fp, " %s\n", unit);
+ }
+ 
+ static void script_new_line(void *ctx)
+ {
+ 	struct metric_ctx *mctx = ctx;
+ 
+ 	perf_sample__fprintf_start(mctx->sample, mctx->thread, mctx->evsel,
+ 				   mctx->fp);
+ 	fputs("\tmetric: ", mctx->fp);
+ }
+ 
+ static void perf_sample__fprint_metric(struct perf_script *script,
+ 				       struct thread *thread,
+ 				       struct perf_evsel *evsel,
+ 				       struct perf_sample *sample,
+ 				       FILE *fp)
+ {
+ 	struct perf_stat_output_ctx ctx = {
+ 		.print_metric = script_print_metric,
+ 		.new_line = script_new_line,
+ 		.ctx = &(struct metric_ctx) {
+ 				.sample = sample,
+ 				.thread = thread,
+ 				.evsel  = evsel,
+ 				.fp     = fp,
+ 			 },
+ 		.force_header = false,
+ 	};
+ 	struct perf_evsel *ev2;
+ 	static bool init;
+ 	u64 val;
+ 
+ 	if (!init) {
+ 		perf_stat__init_shadow_stats();
+ 		init = true;
+ 	}
+ 	if (!evsel->stats)
+ 		perf_evlist__alloc_stats(script->session->evlist, false);
+ 	if (evsel_script(evsel->leader)->gnum++ == 0)
+ 		perf_stat__reset_shadow_stats();
+ 	val = sample->period * evsel->scale;
+ 	perf_stat__update_shadow_stats(evsel,
+ 				       val,
+ 				       sample->cpu,
+ 				       &rt_stat);
+ 	evsel_script(evsel)->val = val;
+ 	if (evsel_script(evsel->leader)->gnum == evsel->leader->nr_members) {
+ 		for_each_group_member (ev2, evsel->leader) {
+ 			perf_stat__print_shadow_stats(ev2,
+ 						      evsel_script(ev2)->val,
+ 						      sample->cpu,
+ 						      &ctx,
+ 						      NULL,
+ 						      &rt_stat);
+ 		}
+ 		evsel_script(evsel->leader)->gnum = 0;
+ 	}
+ }
+ 
++>>>>>>> e0128b30dbfb (perf stat: Print per-thread shadow stats)
  static void process_event(struct perf_script *script,
  			  struct perf_sample *sample, struct perf_evsel *evsel,
  			  struct addr_location *al,
diff --cc tools/perf/util/stat-shadow.c
index b29877d9b2f4,a95c4fe991aa..000000000000
--- a/tools/perf/util/stat-shadow.c
+++ b/tools/perf/util/stat-shadow.c
@@@ -693,7 -762,8 +732,12 @@@ static void generic_metric(const char *
  			stats = &walltime_nsecs_stats;
  			scale = 1e-9;
  		} else {
++<<<<<<< HEAD
 +			v = saved_value_lookup(metric_events[i], cpu, false);
++=======
+ 			v = saved_value_lookup(metric_events[i], cpu, false,
+ 					       STAT_NONE, 0, st);
++>>>>>>> e0128b30dbfb (perf stat: Print per-thread shadow stats)
  			if (!v)
  				break;
  			stats = &v->stats;
* Unmerged path tools/perf/builtin-script.c
diff --git a/tools/perf/builtin-stat.c b/tools/perf/builtin-stat.c
index a027b4712e48..811b1c27bf7b 100644
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@ -1097,7 +1097,8 @@ static void abs_printout(int id, int nr, struct perf_evsel *evsel, double avg)
 }
 
 static void printout(int id, int nr, struct perf_evsel *counter, double uval,
-		     char *prefix, u64 run, u64 ena, double noise)
+		     char *prefix, u64 run, u64 ena, double noise,
+		     struct runtime_stat *st)
 {
 	struct perf_stat_output_ctx out;
 	struct outstate os = {
@@ -1190,7 +1191,7 @@ static void printout(int id, int nr, struct perf_evsel *counter, double uval,
 
 	perf_stat__print_shadow_stats(counter, uval,
 				first_shadow_cpu(counter, id),
-				&out, &metric_events);
+				&out, &metric_events, st);
 	if (!csv_output && !metric_only) {
 		print_noise(counter, noise);
 		print_running(run, ena);
@@ -1334,7 +1335,8 @@ static void print_aggr(char *prefix)
 				fprintf(output, "%s", prefix);
 
 			uval = val * counter->scale;
-			printout(id, nr, counter, uval, prefix, run, ena, 1.0);
+			printout(id, nr, counter, uval, prefix, run, ena, 1.0,
+				 &rt_stat);
 			if (!metric_only)
 				fputc('\n', output);
 		}
@@ -1364,7 +1366,8 @@ static void print_aggr_thread(struct perf_evsel *counter, char *prefix)
 			fprintf(output, "%s", prefix);
 
 		uval = val * counter->scale;
-		printout(thread, 0, counter, uval, prefix, run, ena, 1.0);
+		printout(thread, 0, counter, uval, prefix, run, ena, 1.0,
+			 &rt_stat);
 		fputc('\n', output);
 	}
 }
@@ -1401,7 +1404,8 @@ static void print_counter_aggr(struct perf_evsel *counter, char *prefix)
 		fprintf(output, "%s", prefix);
 
 	uval = cd.avg * counter->scale;
-	printout(-1, 0, counter, uval, prefix, cd.avg_running, cd.avg_enabled, cd.avg);
+	printout(-1, 0, counter, uval, prefix, cd.avg_running, cd.avg_enabled,
+		 cd.avg, &rt_stat);
 	if (!metric_only)
 		fprintf(output, "\n");
 }
@@ -1440,7 +1444,8 @@ static void print_counter(struct perf_evsel *counter, char *prefix)
 			fprintf(output, "%s", prefix);
 
 		uval = val * counter->scale;
-		printout(cpu, 0, counter, uval, prefix, run, ena, 1.0);
+		printout(cpu, 0, counter, uval, prefix, run, ena, 1.0,
+			 &rt_stat);
 
 		fputc('\n', output);
 	}
@@ -1472,7 +1477,8 @@ static void print_no_aggr_metric(char *prefix)
 			run = perf_counts(counter->counts, cpu, 0)->run;
 
 			uval = val * counter->scale;
-			printout(cpu, 0, counter, uval, prefix, run, ena, 1.0);
+			printout(cpu, 0, counter, uval, prefix, run, ena, 1.0,
+				 &rt_stat);
 		}
 		fputc('\n', stat_config.output);
 	}
@@ -1528,7 +1534,8 @@ static void print_metric_headers(const char *prefix, bool no_indent)
 		perf_stat__print_shadow_stats(counter, 0,
 					      0,
 					      &out,
-					      &metric_events);
+					      &metric_events,
+					      &rt_stat);
 	}
 	fputc('\n', stat_config.output);
 }
* Unmerged path tools/perf/util/stat-shadow.c
diff --git a/tools/perf/util/stat.h b/tools/perf/util/stat.h
index 9070605f80e5..d51ad81717b7 100644
--- a/tools/perf/util/stat.h
+++ b/tools/perf/util/stat.h
@@ -139,7 +139,8 @@ struct perf_stat_output_ctx {
 void perf_stat__print_shadow_stats(struct perf_evsel *evsel,
 				   double avg, int cpu,
 				   struct perf_stat_output_ctx *out,
-				   struct rblist *metric_events);
+				   struct rblist *metric_events,
+				   struct runtime_stat *st);
 void perf_stat__collect_metric_expr(struct perf_evlist *);
 
 int perf_evlist__alloc_stats(struct perf_evlist *evlist, bool alloc_raw);
