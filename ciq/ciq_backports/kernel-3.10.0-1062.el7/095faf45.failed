netfilter: nat: fix double register in masquerade modules

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Taehee Yoo <ap420073@gmail.com>
commit 095faf45e64be00bff4da2d6182dface3d69c9b7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/095faf45.failed

There is a reference counter to ensure that masquerade modules register
notifiers only once. However, the existing reference counter approach is
not safe, test commands are:

   while :
   do
   	   modprobe ip6t_MASQUERADE &
	   modprobe nft_masq_ipv6 &
	   modprobe -rv ip6t_MASQUERADE &
	   modprobe -rv nft_masq_ipv6 &
   done

numbers below represent the reference counter.
--------------------------------------------------------
CPU0        CPU1        CPU2        CPU3        CPU4
[insmod]    [insmod]    [rmmod]     [rmmod]     [insmod]
--------------------------------------------------------
0->1
register    1->2
            returns     2->1
			returns     1->0
                                                0->1
                                                register <--
                                    unregister
--------------------------------------------------------

The unregistation of CPU3 should be processed before the
registration of CPU4.

In order to fix this, use a mutex instead of reference counter.

splat looks like:
[  323.869557] watchdog: BUG: soft lockup - CPU#0 stuck for 22s! [modprobe:1381]
[  323.869574] Modules linked in: nf_tables(+) nf_nat_ipv6(-) nf_nat nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 n]
[  323.869574] irq event stamp: 194074
[  323.898930] hardirqs last  enabled at (194073): [<ffffffff90004a0d>] trace_hardirqs_on_thunk+0x1a/0x1c
[  323.898930] hardirqs last disabled at (194074): [<ffffffff90004a29>] trace_hardirqs_off_thunk+0x1a/0x1c
[  323.898930] softirqs last  enabled at (182132): [<ffffffff922006ec>] __do_softirq+0x6ec/0xa3b
[  323.898930] softirqs last disabled at (182109): [<ffffffff90193426>] irq_exit+0x1a6/0x1e0
[  323.898930] CPU: 0 PID: 1381 Comm: modprobe Not tainted 4.20.0-rc2+ #27
[  323.898930] RIP: 0010:raw_notifier_chain_register+0xea/0x240
[  323.898930] Code: 3c 03 0f 8e f2 00 00 00 44 3b 6b 10 7f 4d 49 bc 00 00 00 00 00 fc ff df eb 22 48 8d 7b 10 488
[  323.898930] RSP: 0018:ffff888101597218 EFLAGS: 00000206 ORIG_RAX: ffffffffffffff13
[  323.898930] RAX: 0000000000000000 RBX: ffffffffc04361c0 RCX: 0000000000000000
[  323.898930] RDX: 1ffffffff26132ae RSI: ffffffffc04aa3c0 RDI: ffffffffc04361d0
[  323.898930] RBP: ffffffffc04361c8 R08: 0000000000000000 R09: 0000000000000001
[  323.898930] R10: ffff8881015972b0 R11: fffffbfff26132c4 R12: dffffc0000000000
[  323.898930] R13: 0000000000000000 R14: 1ffff110202b2e44 R15: ffffffffc04aa3c0
[  323.898930] FS:  00007f813ed41540(0000) GS:ffff88811ae00000(0000) knlGS:0000000000000000
[  323.898930] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  323.898930] CR2: 0000559bf2c9f120 CR3: 000000010bc80000 CR4: 00000000001006f0
[  323.898930] Call Trace:
[  323.898930]  ? atomic_notifier_chain_register+0x2d0/0x2d0
[  323.898930]  ? down_read+0x150/0x150
[  323.898930]  ? sched_clock_cpu+0x126/0x170
[  323.898930]  ? nf_tables_core_module_init+0xe4/0xe4 [nf_tables]
[  323.898930]  ? nf_tables_core_module_init+0xe4/0xe4 [nf_tables]
[  323.898930]  register_netdevice_notifier+0xbb/0x790
[  323.898930]  ? __dev_close_many+0x2d0/0x2d0
[  323.898930]  ? __mutex_unlock_slowpath+0x17f/0x740
[  323.898930]  ? wait_for_completion+0x710/0x710
[  323.898930]  ? nf_tables_core_module_init+0xe4/0xe4 [nf_tables]
[  323.898930]  ? up_write+0x6c/0x210
[  323.898930]  ? nf_tables_core_module_init+0xe4/0xe4 [nf_tables]
[  324.127073]  ? nf_tables_core_module_init+0xe4/0xe4 [nf_tables]
[  324.127073]  nft_chain_filter_init+0x1e/0xe8a [nf_tables]
[  324.127073]  nf_tables_module_init+0x37/0x92 [nf_tables]
[ ... ]

Fixes: 8dd33cc93ec9 ("netfilter: nf_nat: generalize IPv4 masquerading support for nf_tables")
Fixes: be6b635cd674 ("netfilter: nf_nat: generalize IPv6 masquerading support for nf_tables")
	Signed-off-by: Taehee Yoo <ap420073@gmail.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 095faf45e64be00bff4da2d6182dface3d69c9b7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
#	net/ipv6/netfilter/nf_nat_masquerade_ipv6.c
diff --cc net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
index 9811b21304dd,41327bb99093..000000000000
--- a/net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
+++ b/net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
@@@ -131,31 -147,50 +131,61 @@@ static struct notifier_block masq_inet_
  	.notifier_call	= masq_inet_event,
  };
  
- static atomic_t masquerade_notifier_refcount = ATOMIC_INIT(0);
+ static int masq_refcnt;
+ static DEFINE_MUTEX(masq_mutex);
  
 -int nf_nat_masquerade_ipv4_register_notifier(void)
 +void nf_nat_masquerade_ipv4_register_notifier(void)
  {
++<<<<<<< HEAD
 +	/* check if the notifier was already set */
 +	if (atomic_inc_return(&masquerade_notifier_refcount) > 1)
 +		return;
++=======
+ 	int ret = 0;
+ 
+ 	mutex_lock(&masq_mutex);
+ 	/* check if the notifier was already set */
+ 	if (++masq_refcnt > 1)
+ 		goto out_unlock;
++>>>>>>> 095faf45e64b (netfilter: nat: fix double register in masquerade modules)
  
  	/* Register for device down reports */
 -	ret = register_netdevice_notifier(&masq_dev_notifier);
 -	if (ret)
 -		goto err_dec;
 +	register_netdevice_notifier_rh(&masq_dev_notifier);
  	/* Register IP address change reports */
++<<<<<<< HEAD
 +	register_inetaddr_notifier(&masq_inet_notifier);
++=======
+ 	ret = register_inetaddr_notifier(&masq_inet_notifier);
+ 	if (ret)
+ 		goto err_unregister;
+ 
+ 	mutex_unlock(&masq_mutex);
+ 	return ret;
+ 
+ err_unregister:
+ 	unregister_netdevice_notifier(&masq_dev_notifier);
+ err_dec:
+ 	masq_refcnt--;
+ out_unlock:
+ 	mutex_unlock(&masq_mutex);
+ 	return ret;
++>>>>>>> 095faf45e64b (netfilter: nat: fix double register in masquerade modules)
  }
  EXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv4_register_notifier);
  
  void nf_nat_masquerade_ipv4_unregister_notifier(void)
  {
+ 	mutex_lock(&masq_mutex);
  	/* check if the notifier still has clients */
- 	if (atomic_dec_return(&masquerade_notifier_refcount) > 0)
- 		return;
+ 	if (--masq_refcnt > 0)
+ 		goto out_unlock;
  
 -	unregister_netdevice_notifier(&masq_dev_notifier);
 +	unregister_netdevice_notifier_rh(&masq_dev_notifier);
  	unregister_inetaddr_notifier(&masq_inet_notifier);
+ out_unlock:
+ 	mutex_unlock(&masq_mutex);
  }
  EXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv4_unregister_notifier);
 +
 +MODULE_LICENSE("GPL");
 +MODULE_AUTHOR("Rusty Russell <rusty@rustcorp.com.au>");
diff --cc net/ipv6/netfilter/nf_nat_masquerade_ipv6.c
index 1411f281e473,0ad0da5a2600..000000000000
--- a/net/ipv6/netfilter/nf_nat_masquerade_ipv6.c
+++ b/net/ipv6/netfilter/nf_nat_masquerade_ipv6.c
@@@ -78,43 -84,140 +78,80 @@@ static struct notifier_block masq_dev_n
  	.notifier_call	= masq_device_event,
  };
  
 -struct masq_dev_work {
 -	struct work_struct work;
 -	struct net *net;
 -	struct in6_addr addr;
 -	int ifindex;
 -};
 -
 -static int inet_cmp(struct nf_conn *ct, void *work)
 -{
 -	struct masq_dev_work *w = (struct masq_dev_work *)work;
 -	struct nf_conntrack_tuple *tuple;
 -
 -	if (!device_cmp(ct, (void *)(long)w->ifindex))
 -		return 0;
 -
 -	tuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;
 -
 -	return ipv6_addr_equal(&w->addr, &tuple->dst.u3.in6);
 -}
 -
 -static void iterate_cleanup_work(struct work_struct *work)
 -{
 -	struct masq_dev_work *w;
 -
 -	w = container_of(work, struct masq_dev_work, work);
 -
 -	nf_ct_iterate_cleanup_net(w->net, inet_cmp, (void *)w, 0, 0);
 -
 -	put_net(w->net);
 -	kfree(w);
 -	atomic_dec(&v6_worker_count);
 -	module_put(THIS_MODULE);
 -}
 -
 -/* ipv6 inet notifier is an atomic notifier, i.e. we cannot
 - * schedule.
 - *
 - * Unfortunately, nf_ct_iterate_cleanup_net can run for a long
 - * time if there are lots of conntracks and the system
 - * handles high softirq load, so it frequently calls cond_resched
 - * while iterating the conntrack table.
 - *
 - * So we defer nf_ct_iterate_cleanup_net walk to the system workqueue.
 - *
 - * As we can have 'a lot' of inet_events (depending on amount
 - * of ipv6 addresses being deleted), we also need to add an upper
 - * limit to the number of queued work items.
 - */
 -static int masq_inet6_event(struct notifier_block *this,
 -			    unsigned long event, void *ptr)
 +static int masq_inet_event(struct notifier_block *this,
 +			   unsigned long event, void *ptr)
  {
  	struct inet6_ifaddr *ifa = ptr;
 -	const struct net_device *dev;
 -	struct masq_dev_work *w;
 -	struct net *net;
 -
 -	if (event != NETDEV_DOWN ||
 -	    atomic_read(&v6_worker_count) >= MAX_WORK_COUNT)
 -		return NOTIFY_DONE;
 -
 -	dev = ifa->idev->dev;
 -	net = maybe_get_net(dev_net(dev));
 -	if (!net)
 -		return NOTIFY_DONE;
 -
 -	if (!try_module_get(THIS_MODULE))
 -		goto err_module;
 -
 -	w = kmalloc(sizeof(*w), GFP_ATOMIC);
 -	if (w) {
 -		atomic_inc(&v6_worker_count);
 -
 -		INIT_WORK(&w->work, iterate_cleanup_work);
 -		w->ifindex = dev->ifindex;
 -		w->net = net;
 -		w->addr = ifa->addr;
 -		schedule_work(&w->work);
 -
 -		return NOTIFY_DONE;
 -	}
 -
 -	module_put(THIS_MODULE);
 - err_module:
 -	put_net(net);
 -	return NOTIFY_DONE;
 +	struct netdev_notifier_info info;
 +
 +	netdev_notifier_info_init(&info, ifa->idev->dev);
 +	return masq_device_event(this, event, &info);
  }
  
 -static struct notifier_block masq_inet6_notifier = {
 -	.notifier_call	= masq_inet6_event,
 +static struct notifier_block masq_inet_notifier = {
 +	.notifier_call	= masq_inet_event,
  };
  
- static atomic_t masquerade_notifier_refcount = ATOMIC_INIT(0);
+ static int masq_refcnt;
+ static DEFINE_MUTEX(masq_mutex);
  
 -int nf_nat_masquerade_ipv6_register_notifier(void)
 +void nf_nat_masquerade_ipv6_register_notifier(void)
  {
++<<<<<<< HEAD
 +	/* check if the notifier is already set */
 +	if (atomic_inc_return(&masquerade_notifier_refcount) > 1)
 +		return;
 +
 +	register_netdevice_notifier_rh(&masq_dev_notifier);
 +	register_inet6addr_notifier(&masq_inet_notifier);
++=======
+ 	int ret = 0;
+ 
+ 	mutex_lock(&masq_mutex);
+ 	/* check if the notifier is already set */
+ 	if (++masq_refcnt > 1)
+ 		goto out_unlock;
+ 
+ 	ret = register_netdevice_notifier(&masq_dev_notifier);
+ 	if (ret)
+ 		goto err_dec;
+ 
+ 	ret = register_inet6addr_notifier(&masq_inet6_notifier);
+ 	if (ret)
+ 		goto err_unregister;
+ 
+ 	mutex_unlock(&masq_mutex);
+ 	return ret;
+ 
+ err_unregister:
+ 	unregister_netdevice_notifier(&masq_dev_notifier);
+ err_dec:
+ 	masq_refcnt--;
+ out_unlock:
+ 	mutex_unlock(&masq_mutex);
+ 	return ret;
++>>>>>>> 095faf45e64b (netfilter: nat: fix double register in masquerade modules)
  }
  EXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv6_register_notifier);
  
  void nf_nat_masquerade_ipv6_unregister_notifier(void)
  {
+ 	mutex_lock(&masq_mutex);
  	/* check if the notifier still has clients */
- 	if (atomic_dec_return(&masquerade_notifier_refcount) > 0)
- 		return;
+ 	if (--masq_refcnt > 0)
+ 		goto out_unlock;
  
++<<<<<<< HEAD
 +	unregister_inet6addr_notifier(&masq_inet_notifier);
 +	unregister_netdevice_notifier_rh(&masq_dev_notifier);
++=======
+ 	unregister_inet6addr_notifier(&masq_inet6_notifier);
+ 	unregister_netdevice_notifier(&masq_dev_notifier);
+ out_unlock:
+ 	mutex_unlock(&masq_mutex);
++>>>>>>> 095faf45e64b (netfilter: nat: fix double register in masquerade modules)
  }
  EXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv6_unregister_notifier);
 +
 +MODULE_LICENSE("GPL");
 +MODULE_AUTHOR("Patrick McHardy <kaber@trash.net>");
* Unmerged path net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_nat_masquerade_ipv6.c
