xfs: reset dfops to initial state after finish

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 509308b413c9e4e3140b4bc524522255d126787e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/509308b4.failed

xfs_defer_init() is currently used in two particular situations. The
first and most obvious case is raw initialization of an
xfs_defer_ops struct. The other case is partial reinit of
xfs_defer_ops on reuse due to iteration.

Most instances of the first case will be replaced by a single init
of a dfops embedded in the transaction. Init calls are still
technically required for the second case because the dfops may have
low space mode enabled or have joined items that need to be reset
before the dfops should be reused.

Since the current dfops usage expects either a final transaction
commit after xfs_defer_finish() or xfs_defer_init() if dfops is to
be reused, we can shift some of the init logic into
xfs_defer_finish() such that the latter returns with a reinitialized
dfops. This eliminates the second dependency noted above such that a
dfops is immediately ready for reuse after an xfs_defer_finish()
without the need to change any calling code.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Bill O'Donnell <billodo@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 509308b413c9e4e3140b4bc524522255d126787e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_defer.c
diff --cc fs/xfs/libxfs/xfs_defer.c
index 606e68286320,23f2a52b088e..000000000000
--- a/fs/xfs/libxfs/xfs_defer.c
+++ b/fs/xfs/libxfs/xfs_defer.c
@@@ -400,13 -435,18 +413,21 @@@ xfs_defer_finish
  	 * Roll the transaction once more to avoid returning to the caller
  	 * with a dirty transaction.
  	 */
 -	if ((*tp)->t_flags & XFS_TRANS_DIRTY) {
 -		error = xfs_defer_trans_roll(tp);
 -		dop = (*tp)->t_dfops;
 -	}
 +	if ((*tp)->t_flags & XFS_TRANS_DIRTY)
 +		error = xfs_defer_trans_roll(tp, dop);
  out:
- 	if (error)
+ 	if (error) {
  		trace_xfs_defer_finish_error((*tp)->t_mountp, dop, error);
++<<<<<<< HEAD
 +	else
 +		trace_xfs_defer_finish_done((*tp)->t_mountp, dop);
++=======
+ 	} else {
+ 		trace_xfs_defer_finish_done((*tp)->t_mountp, dop, _RET_IP_);
+ 		xfs_defer_reset(dop);
+ 	}
+ 
++>>>>>>> 509308b413c9 (xfs: reset dfops to initial state after finish)
  	return error;
  }
  
* Unmerged path fs/xfs/libxfs/xfs_defer.c
