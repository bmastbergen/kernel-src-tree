net/mlx5: E-Switch, Change vhca id valid bool field to bit flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Change vhca id valid bool field to bit flag (Alaa Hleihel) [1642383 1642498]
Rebuild_FUZZ: 96.72%
commit-author Eli Britstein <elibr@mellanox.com>
commit aa39c2c0e44d16b5804f8fb6b5350cdf4e33b4c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/aa39c2c0.failed

Change the driver flow destination struct to use bit flags with the vhca
id valid being the 1st one. The flags field is more extendable and will
be used in downstream patch.

	Signed-off-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit aa39c2c0e44d16b5804f8fb6b5350cdf4e33b4c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 84864631953e,4d7b65df32ef..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -70,23 -107,34 +70,49 @@@ mlx5_eswitch_add_offloaded_rule(struct 
  	}
  
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {
++<<<<<<< HEAD
 +		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
 +		dest[i].vport.num = attr->out_rep->vport;
 +		if (MLX5_CAP_ESW(esw->dev, merged_eswitch)) {
 +			dest[i].vport.vhca_id =
 +				MLX5_CAP_GEN(attr->out_mdev, vhca_id);
 +			dest[i].vport.vhca_id_valid = 1;
++=======
+ 		if (attr->dest_chain) {
+ 			struct mlx5_flow_table *ft;
+ 
+ 			ft = esw_get_prio_table(esw, attr->dest_chain, 1, 0);
+ 			if (IS_ERR(ft)) {
+ 				rule = ERR_CAST(ft);
+ 				goto err_create_goto_table;
+ 			}
+ 
+ 			dest[i].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 			dest[i].ft = ft;
+ 			i++;
+ 		} else {
+ 			for (j = attr->mirror_count; j < attr->out_count; j++) {
+ 				dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
+ 				dest[i].vport.num = attr->out_rep[j]->vport;
+ 				dest[i].vport.vhca_id =
+ 					MLX5_CAP_GEN(attr->out_mdev[j], vhca_id);
+ 				if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 					dest[i].vport.flags |=
+ 						MLX5_FLOW_DEST_VPORT_VHCA_ID;
+ 				i++;
+ 			}
++>>>>>>> aa39c2c0e44d (net/mlx5: E-Switch, Change vhca id valid bool field to bit flag)
  		}
 +		i++;
  	}
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {
 +		counter = mlx5_fc_create(esw->dev, true);
 +		if (IS_ERR(counter)) {
 +			rule = ERR_CAST(counter);
 +			goto err_counter_alloc;
 +		}
  		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;
 -		dest[i].counter_id = mlx5_fc_id(attr->counter);
 +		dest[i].counter = counter;
  		i++;
  	}
  
@@@ -134,6 -190,101 +160,104 @@@ err_counter_alloc
  	return rule;
  }
  
++<<<<<<< HEAD
++=======
+ struct mlx5_flow_handle *
+ mlx5_eswitch_add_fwd_rule(struct mlx5_eswitch *esw,
+ 			  struct mlx5_flow_spec *spec,
+ 			  struct mlx5_esw_flow_attr *attr)
+ {
+ 	struct mlx5_flow_destination dest[MLX5_MAX_FLOW_FWD_VPORTS + 1] = {};
+ 	struct mlx5_flow_act flow_act = { .flags = FLOW_ACT_NO_APPEND, };
+ 	struct mlx5_flow_table *fast_fdb;
+ 	struct mlx5_flow_table *fwd_fdb;
+ 	struct mlx5_flow_handle *rule;
+ 	void *misc;
+ 	int i;
+ 
+ 	fast_fdb = esw_get_prio_table(esw, attr->chain, attr->prio, 0);
+ 	if (IS_ERR(fast_fdb)) {
+ 		rule = ERR_CAST(fast_fdb);
+ 		goto err_get_fast;
+ 	}
+ 
+ 	fwd_fdb = esw_get_prio_table(esw, attr->chain, attr->prio, 1);
+ 	if (IS_ERR(fwd_fdb)) {
+ 		rule = ERR_CAST(fwd_fdb);
+ 		goto err_get_fwd;
+ 	}
+ 
+ 	flow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
+ 	for (i = 0; i < attr->mirror_count; i++) {
+ 		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
+ 		dest[i].vport.num = attr->out_rep[i]->vport;
+ 		dest[i].vport.vhca_id =
+ 			MLX5_CAP_GEN(attr->out_mdev[i], vhca_id);
+ 		if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 			dest[i].vport.flags |= MLX5_FLOW_DEST_VPORT_VHCA_ID;
+ 	}
+ 	dest[i].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 	dest[i].ft = fwd_fdb,
+ 	i++;
+ 
+ 	misc = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters);
+ 	MLX5_SET(fte_match_set_misc, misc, source_port, attr->in_rep->vport);
+ 
+ 	if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 		MLX5_SET(fte_match_set_misc, misc,
+ 			 source_eswitch_owner_vhca_id,
+ 			 MLX5_CAP_GEN(attr->in_mdev, vhca_id));
+ 
+ 	misc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);
+ 	MLX5_SET_TO_ONES(fte_match_set_misc, misc, source_port);
+ 	if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 		MLX5_SET_TO_ONES(fte_match_set_misc, misc,
+ 				 source_eswitch_owner_vhca_id);
+ 
+ 	if (attr->match_level == MLX5_MATCH_NONE)
+ 		spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS;
+ 	else
+ 		spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS |
+ 					      MLX5_MATCH_MISC_PARAMETERS;
+ 
+ 	rule = mlx5_add_flow_rules(fast_fdb, spec, &flow_act, dest, i);
+ 
+ 	if (IS_ERR(rule))
+ 		goto add_err;
+ 
+ 	esw->offloads.num_flows++;
+ 
+ 	return rule;
+ add_err:
+ 	esw_put_prio_table(esw, attr->chain, attr->prio, 1);
+ err_get_fwd:
+ 	esw_put_prio_table(esw, attr->chain, attr->prio, 0);
+ err_get_fast:
+ 	return rule;
+ }
+ 
+ static void
+ __mlx5_eswitch_del_rule(struct mlx5_eswitch *esw,
+ 			struct mlx5_flow_handle *rule,
+ 			struct mlx5_esw_flow_attr *attr,
+ 			bool fwd_rule)
+ {
+ 	bool mirror = (attr->mirror_count > 0);
+ 
+ 	mlx5_del_flow_rules(rule);
+ 	esw->offloads.num_flows--;
+ 
+ 	if (fwd_rule)  {
+ 		esw_put_prio_table(esw, attr->chain, attr->prio, 1);
+ 		esw_put_prio_table(esw, attr->chain, attr->prio, 0);
+ 	} else {
+ 		esw_put_prio_table(esw, attr->chain, attr->prio, !!mirror);
+ 		if (attr->dest_chain)
+ 			esw_put_prio_table(esw, attr->dest_chain, 1, 0);
+ 	}
+ }
+ 
++>>>>>>> aa39c2c0e44d (net/mlx5: E-Switch, Change vhca id valid bool field to bit flag)
  void
  mlx5_eswitch_del_offloaded_rule(struct mlx5_eswitch *esw,
  				struct mlx5_flow_handle *rule,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
index 684c8251931c..8c4a823a24c7 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
@@ -380,7 +380,8 @@ static int mlx5_cmd_set_fte(struct mlx5_core_dev *dev,
 				id = dst->dest_attr.vport.num;
 				MLX5_SET(dest_format_struct, in_dests,
 					 destination_eswitch_owner_vhca_id_valid,
-					 dst->dest_attr.vport.vhca_id_valid);
+					 !!(dst->dest_attr.vport.flags &
+					    MLX5_FLOW_DEST_VPORT_VHCA_ID));
 				MLX5_SET(dest_format_struct, in_dests,
 					 destination_eswitch_owner_vhca_id,
 					 dst->dest_attr.vport.vhca_id);
diff --git a/include/linux/mlx5/fs.h b/include/linux/mlx5/fs.h
index 7035fec2adf8..c5540f575f1c 100644
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@ -84,6 +84,10 @@ struct mlx5_flow_spec {
 	u32  match_value[MLX5_ST_SZ_DW(fte_match_param)];
 };
 
+enum {
+	MLX5_FLOW_DEST_VPORT_VHCA_ID      = BIT(0),
+};
+
 struct mlx5_flow_destination {
 	enum mlx5_flow_destination_type	type;
 	union {
@@ -94,7 +98,7 @@ struct mlx5_flow_destination {
 		struct {
 			u16		num;
 			u16		vhca_id;
-			bool		vhca_id_valid;
+			u8		flags;
 		} vport;
 	};
 };
