netfilter: nf_tables: Use pkt->net instead of computing net from the passed net_devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 88182a0e0c665cbd2f01af743c7f88e494924246
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/88182a0e.failed

	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 88182a0e0c665cbd2f01af743c7f88e494924246)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_core.c
diff --cc net/netfilter/nf_tables_core.c
index 7f1a318d68a3,e5c1f332e45e..000000000000
--- a/net/netfilter/nf_tables_core.c
+++ b/net/netfilter/nf_tables_core.c
@@@ -38,21 -44,11 +38,25 @@@ static struct nf_loginfo trace_loginfo 
  	},
  };
  
 -static void __nft_trace_packet(const struct nft_pktinfo *pkt,
 -			       const struct nft_chain *chain,
 -			       int rulenum, enum nft_trace type)
 +static noinline void __nft_trace_packet(struct nft_traceinfo *info,
 +					const struct nft_chain *chain,
 +					int rulenum, enum nft_trace_types type)
  {
++<<<<<<< HEAD
 +	const struct nft_pktinfo *pkt = info->pkt;
 +
 +	if (!info->trace || !pkt->skb->nf_trace)
 +		return;
 +
 +	info->chain = chain;
 +	info->type = type;
 +
 +	nft_trace_notify(info);
 +
 +	nf_log_trace(pkt_net(pkt), pkt->pf, pkt->hook, pkt->skb, pkt->in,
++=======
+ 	nf_log_trace(pkt->net, pkt->pf, pkt->hook, pkt->skb, pkt->in,
++>>>>>>> 88182a0e0c66 (netfilter: nf_tables: Use pkt->net instead of computing net from the passed net_devices)
  		     pkt->out, &trace_loginfo, "TRACE: %s:%s:%s:%u ",
  		     chain->table->name, chain->name, comments[type],
  		     rulenum);
@@@ -120,8 -112,7 +124,12 @@@ unsigned in
  nft_do_chain(struct nft_pktinfo *pkt, const struct nf_hook_ops *ops)
  {
  	const struct nft_chain *chain = ops->priv, *basechain = chain;
++<<<<<<< HEAD
 +	const struct net *chain_net = read_pnet(&nft_base_chain(basechain)->pnet);
 +	const struct net *net = dev_net(pkt->in ? pkt->in : pkt->out);
++=======
+ 	const struct net *net = pkt->net;
++>>>>>>> 88182a0e0c66 (netfilter: nf_tables: Use pkt->net instead of computing net from the passed net_devices)
  	const struct nft_rule *rule;
  	const struct nft_expr *expr, *last;
  	struct nft_regs regs;
diff --git a/net/bridge/netfilter/nft_reject_bridge.c b/net/bridge/netfilter/nft_reject_bridge.c
index 63db6a0ed327..494320b48acc 100644
--- a/net/bridge/netfilter/nft_reject_bridge.c
+++ b/net/bridge/netfilter/nft_reject_bridge.c
@@ -256,7 +256,6 @@ static void nft_reject_bridge_eval(const struct nft_expr *expr,
 				   const struct nft_pktinfo *pkt)
 {
 	struct nft_reject *priv = nft_expr_priv(expr);
-	struct net *net = dev_net((pkt->in != NULL) ? pkt->in : pkt->out);
 	const unsigned char *dest = eth_hdr(pkt->skb)->h_dest;
 
 	if (is_broadcast_ether_addr(dest) ||
@@ -285,17 +284,17 @@ static void nft_reject_bridge_eval(const struct nft_expr *expr,
 	case htons(ETH_P_IPV6):
 		switch (priv->type) {
 		case NFT_REJECT_ICMP_UNREACH:
-			nft_reject_br_send_v6_unreach(net, pkt->skb, pkt->in,
-						      pkt->hook,
+			nft_reject_br_send_v6_unreach(pkt->net, pkt->skb,
+						      pkt->in, pkt->hook,
 						      priv->icmp_code);
 			break;
 		case NFT_REJECT_TCP_RST:
-			nft_reject_br_send_v6_tcp_reset(net, pkt->skb, pkt->in,
-							pkt->hook);
+			nft_reject_br_send_v6_tcp_reset(pkt->net, pkt->skb,
+							pkt->in, pkt->hook);
 			break;
 		case NFT_REJECT_ICMPX_UNREACH:
-			nft_reject_br_send_v6_unreach(net, pkt->skb, pkt->in,
-						      pkt->hook,
+			nft_reject_br_send_v6_unreach(pkt->net, pkt->skb,
+						      pkt->in, pkt->hook,
 						      nft_reject_icmpv6_code(priv->icmp_code));
 			break;
 		}
diff --git a/net/ipv6/netfilter/nft_reject_ipv6.c b/net/ipv6/netfilter/nft_reject_ipv6.c
index 0abb30cc68c3..92bda9908bb9 100644
--- a/net/ipv6/netfilter/nft_reject_ipv6.c
+++ b/net/ipv6/netfilter/nft_reject_ipv6.c
@@ -24,14 +24,14 @@ static void nft_reject_ipv6_eval(const struct nft_expr *expr,
 				 const struct nft_pktinfo *pkt)
 {
 	struct nft_reject *priv = nft_expr_priv(expr);
-	struct net *net = dev_net((pkt->in != NULL) ? pkt->in : pkt->out);
 
 	switch (priv->type) {
 	case NFT_REJECT_ICMP_UNREACH:
-		nf_send_unreach6(net, pkt->skb, priv->icmp_code, pkt->hook);
+		nf_send_unreach6(pkt->net, pkt->skb, priv->icmp_code,
+				 pkt->hook);
 		break;
 	case NFT_REJECT_TCP_RST:
-		nf_send_reset6(net, pkt->skb, pkt->hook);
+		nf_send_reset6(pkt->net, pkt->skb, pkt->hook);
 		break;
 	default:
 		break;
* Unmerged path net/netfilter/nf_tables_core.c
diff --git a/net/netfilter/nft_log.c b/net/netfilter/nft_log.c
index af868c1dc6ae..b2db41b2cfc4 100644
--- a/net/netfilter/nft_log.c
+++ b/net/netfilter/nft_log.c
@@ -31,9 +31,8 @@ static void nft_log_eval(const struct nft_expr *expr,
 			 const struct nft_pktinfo *pkt)
 {
 	const struct nft_log *priv = nft_expr_priv(expr);
-	struct net *net = dev_net(pkt->in ? pkt->in : pkt->out);
 
-	nf_log_packet(net, pkt->pf, pkt->hook, pkt->skb, pkt->in,
+	nf_log_packet(pkt->net, pkt->pf, pkt->hook, pkt->skb, pkt->in,
 		      pkt->out, &priv->loginfo, "%s", priv->prefix);
 }
 
diff --git a/net/netfilter/nft_reject_inet.c b/net/netfilter/nft_reject_inet.c
index 912bf65f32e3..317ef2f27cd0 100644
--- a/net/netfilter/nft_reject_inet.c
+++ b/net/netfilter/nft_reject_inet.c
@@ -22,7 +22,6 @@ static void nft_reject_inet_eval(const struct nft_expr *expr,
 				 const struct nft_pktinfo *pkt)
 {
 	struct nft_reject *priv = nft_expr_priv(expr);
-	struct net *net = dev_net((pkt->in != NULL) ? pkt->in : pkt->out);
 
 	switch (pkt->pf) {
 	case NFPROTO_IPV4:
@@ -44,14 +43,14 @@ static void nft_reject_inet_eval(const struct nft_expr *expr,
 	case NFPROTO_IPV6:
 		switch (priv->type) {
 		case NFT_REJECT_ICMP_UNREACH:
-			nf_send_unreach6(net, pkt->skb, priv->icmp_code,
+			nf_send_unreach6(pkt->net, pkt->skb, priv->icmp_code,
 					 pkt->hook);
 			break;
 		case NFT_REJECT_TCP_RST:
-			nf_send_reset6(net, pkt->skb, pkt->hook);
+			nf_send_reset6(pkt->net, pkt->skb, pkt->hook);
 			break;
 		case NFT_REJECT_ICMPX_UNREACH:
-			nf_send_unreach6(net, pkt->skb,
+			nf_send_unreach6(pkt->net, pkt->skb,
 					 nft_reject_icmpv6_code(priv->icmp_code),
 					 pkt->hook);
 			break;
