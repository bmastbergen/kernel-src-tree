qed/qede: qede_setup_tc() can be static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author kbuild test robot <fengguang.wu@intel.com>
commit 1e7953bc560451302dcb5d5b3fafd1949447579a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/1e7953bc.failed

Fixes: 5e7baf0fcb2a ("qed/qede: Multi CoS support.")
	Signed-off-by: kbuild test robot <fengguang.wu@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1e7953bc560451302dcb5d5b3fafd1949447579a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qede/qede_main.c
diff --cc drivers/net/ethernet/qlogic/qede/qede_main.c
index d722a020894c,46d0f2eaa0c0..000000000000
--- a/drivers/net/ethernet/qlogic/qede/qede_main.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_main.c
@@@ -533,8 -536,98 +533,102 @@@ static int qede_ioctl(struct net_devic
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int qede_setup_tc(struct net_device *ndev, u8 num_tc)
+ {
+ 	struct qede_dev *edev = netdev_priv(ndev);
+ 	int cos, count, offset;
+ 
+ 	if (num_tc > edev->dev_info.num_tc)
+ 		return -EINVAL;
+ 
+ 	netdev_reset_tc(ndev);
+ 	netdev_set_num_tc(ndev, num_tc);
+ 
+ 	for_each_cos_in_txq(edev, cos) {
+ 		count = QEDE_TSS_COUNT(edev);
+ 		offset = cos * QEDE_TSS_COUNT(edev);
+ 		netdev_set_tc_queue(ndev, cos, count, offset);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qede_set_flower(struct qede_dev *edev, struct tc_cls_flower_offload *f,
+ 		__be16 proto)
+ {
+ 	switch (f->command) {
+ 	case TC_CLSFLOWER_REPLACE:
+ 		return qede_add_tc_flower_fltr(edev, proto, f);
+ 	case TC_CLSFLOWER_DESTROY:
+ 		return qede_delete_flow_filter(edev, f->cookie);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int qede_setup_tc_block_cb(enum tc_setup_type type, void *type_data,
+ 				  void *cb_priv)
+ {
+ 	struct tc_cls_flower_offload *f;
+ 	struct qede_dev *edev = cb_priv;
+ 
+ 	if (!tc_cls_can_offload_and_chain0(edev->ndev, type_data))
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (type) {
+ 	case TC_SETUP_CLSFLOWER:
+ 		f = type_data;
+ 		return qede_set_flower(edev, f, f->common.protocol);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int qede_setup_tc_block(struct qede_dev *edev,
+ 			       struct tc_block_offload *f)
+ {
+ 	if (f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (f->command) {
+ 	case TC_BLOCK_BIND:
+ 		return tcf_block_cb_register(f->block,
+ 					     qede_setup_tc_block_cb,
+ 					     edev, edev, f->extack);
+ 	case TC_BLOCK_UNBIND:
+ 		tcf_block_cb_unregister(f->block, qede_setup_tc_block_cb, edev);
+ 		return 0;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
+ static int
+ qede_setup_tc_offload(struct net_device *dev, enum tc_setup_type type,
+ 		      void *type_data)
+ {
+ 	struct qede_dev *edev = netdev_priv(dev);
+ 	struct tc_mqprio_qopt *mqprio;
+ 
+ 	switch (type) {
+ 	case TC_SETUP_BLOCK:
+ 		return qede_setup_tc_block(edev, type_data);
+ 	case TC_SETUP_QDISC_MQPRIO:
+ 		mqprio = type_data;
+ 
+ 		mqprio->hw = TC_MQPRIO_HW_OFFLOAD_TCS;
+ 		return qede_setup_tc(dev, mqprio->num_tc);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
++>>>>>>> 1e7953bc5604 (qed/qede: qede_setup_tc() can be static)
  static const struct net_device_ops qede_netdev_ops = {
 +	.ndo_size = sizeof(struct net_device_ops),
  	.ndo_open = qede_open,
  	.ndo_stop = qede_close,
  	.ndo_start_xmit = qede_start_xmit,
* Unmerged path drivers/net/ethernet/qlogic/qede/qede_main.c
