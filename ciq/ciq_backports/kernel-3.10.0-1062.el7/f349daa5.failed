iavf: rename i40e_hw to iavf_hw

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit f349daa58809ae3aee1c0f22184c1a9c317d016f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f349daa5.failed

Fix up the i40e_hw names to new name, including versions
inside other strings.

	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit f349daa58809ae3aee1c0f22184c1a9c317d016f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40evf/i40e_adminq.c
#	drivers/net/ethernet/intel/i40evf/i40e_alloc.h
#	drivers/net/ethernet/intel/i40evf/i40e_common.c
#	drivers/net/ethernet/intel/i40evf/i40evf_main.c
#	drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
#	drivers/net/ethernet/intel/iavf/i40e_prototype.h
#	drivers/net/ethernet/intel/iavf/i40e_type.h
#	drivers/net/ethernet/intel/iavf/iavf.h
diff --cc drivers/net/ethernet/intel/i40evf/i40e_adminq.c
index 35630356cd6a,87e68d7894df..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_adminq.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_adminq.c
@@@ -23,30 -13,28 +23,34 @@@ static inline bool i40e_is_nvm_update_o
   *
   *  This assumes the alloc_asq and alloc_arq functions have already been called
   **/
- static void i40e_adminq_init_regs(struct i40e_hw *hw)
+ static void i40e_adminq_init_regs(struct iavf_hw *hw)
  {
  	/* set head and tail registers in our local struct */
 -	hw->aq.asq.tail = IAVF_VF_ATQT1;
 -	hw->aq.asq.head = IAVF_VF_ATQH1;
 -	hw->aq.asq.len  = IAVF_VF_ATQLEN1;
 -	hw->aq.asq.bal  = IAVF_VF_ATQBAL1;
 -	hw->aq.asq.bah  = IAVF_VF_ATQBAH1;
 -	hw->aq.arq.tail = IAVF_VF_ARQT1;
 -	hw->aq.arq.head = IAVF_VF_ARQH1;
 -	hw->aq.arq.len  = IAVF_VF_ARQLEN1;
 -	hw->aq.arq.bal  = IAVF_VF_ARQBAL1;
 -	hw->aq.arq.bah  = IAVF_VF_ARQBAH1;
 +	if (i40e_is_vf(hw)) {
 +		hw->aq.asq.tail = I40E_VF_ATQT1;
 +		hw->aq.asq.head = I40E_VF_ATQH1;
 +		hw->aq.asq.len  = I40E_VF_ATQLEN1;
 +		hw->aq.asq.bal  = I40E_VF_ATQBAL1;
 +		hw->aq.asq.bah  = I40E_VF_ATQBAH1;
 +		hw->aq.arq.tail = I40E_VF_ARQT1;
 +		hw->aq.arq.head = I40E_VF_ARQH1;
 +		hw->aq.arq.len  = I40E_VF_ARQLEN1;
 +		hw->aq.arq.bal  = I40E_VF_ARQBAL1;
 +		hw->aq.arq.bah  = I40E_VF_ARQBAH1;
 +	}
  }
  
  /**
   *  i40e_alloc_adminq_asq_ring - Allocate Admin Queue send rings
   *  @hw: pointer to the hardware structure
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +static i40e_status i40e_alloc_adminq_asq_ring(struct i40e_hw *hw)
++=======
+ static iavf_status i40e_alloc_adminq_asq_ring(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 -	iavf_status ret_code;
 +	i40e_status ret_code;
  
  	ret_code = i40e_allocate_dma_mem(hw, &hw->aq.asq.desc_buf,
  					 i40e_mem_atq_ring,
@@@ -71,9 -59,9 +75,13 @@@
   *  i40e_alloc_adminq_arq_ring - Allocate Admin Queue receive rings
   *  @hw: pointer to the hardware structure
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +static i40e_status i40e_alloc_adminq_arq_ring(struct i40e_hw *hw)
++=======
+ static iavf_status i40e_alloc_adminq_arq_ring(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 -	iavf_status ret_code;
 +	i40e_status ret_code;
  
  	ret_code = i40e_allocate_dma_mem(hw, &hw->aq.arq.desc_buf,
  					 i40e_mem_arq_ring,
@@@ -112,11 -100,11 +120,15 @@@ static void i40e_free_adminq_arq(struc
   *  i40e_alloc_arq_bufs - Allocate pre-posted buffers for the receive queue
   *  @hw: pointer to the hardware structure
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +static i40e_status i40e_alloc_arq_bufs(struct i40e_hw *hw)
++=======
+ static iavf_status i40e_alloc_arq_bufs(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 +	i40e_status ret_code;
  	struct i40e_aq_desc *desc;
  	struct i40e_dma_mem *bi;
 -	iavf_status ret_code;
  	int i;
  
  	/* We'll be allocating the buffer info memory first, then we can
@@@ -179,10 -168,10 +191,14 @@@ unwind_alloc_arq_bufs
   *  i40e_alloc_asq_bufs - Allocate empty buffer structs for the send queue
   *  @hw: pointer to the hardware structure
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +static i40e_status i40e_alloc_asq_bufs(struct i40e_hw *hw)
++=======
+ static iavf_status i40e_alloc_asq_bufs(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 +	i40e_status ret_code;
  	struct i40e_dma_mem *bi;
 -	iavf_status ret_code;
  	int i;
  
  	/* No mapped memory needed yet, just the buffer info structures */
@@@ -263,9 -253,9 +279,13 @@@ static void i40e_free_asq_bufs(struct i
   *
   *  Configure base address and length registers for the transmit queue
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +static i40e_status i40e_config_asq_regs(struct i40e_hw *hw)
++=======
+ static iavf_status i40e_config_asq_regs(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 -	iavf_status ret_code = 0;
 +	i40e_status ret_code = 0;
  	u32 reg = 0;
  
  	/* Clear Head and Tail */
@@@ -292,9 -282,9 +312,13 @@@
   *
   * Configure base address and length registers for the receive (event queue)
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +static i40e_status i40e_config_arq_regs(struct i40e_hw *hw)
++=======
+ static iavf_status i40e_config_arq_regs(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 -	iavf_status ret_code = 0;
 +	i40e_status ret_code = 0;
  	u32 reg = 0;
  
  	/* Clear Head and Tail */
@@@ -331,9 -321,9 +355,13 @@@
   *  Do *NOT* hold the lock when calling this as the memory allocation routines
   *  called are not going to be atomic context safe
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +static i40e_status i40e_init_asq(struct i40e_hw *hw)
++=======
+ static iavf_status i40e_init_asq(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 -	iavf_status ret_code = 0;
 +	i40e_status ret_code = 0;
  
  	if (hw->aq.asq.count > 0) {
  		/* queue already initialized */
@@@ -390,9 -380,9 +418,13 @@@ init_adminq_exit
   *  Do *NOT* hold the lock when calling this as the memory allocation routines
   *  called are not going to be atomic context safe
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +static i40e_status i40e_init_arq(struct i40e_hw *hw)
++=======
+ static iavf_status i40e_init_arq(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 -	iavf_status ret_code = 0;
 +	i40e_status ret_code = 0;
  
  	if (hw->aq.arq.count > 0) {
  		/* queue already initialized */
@@@ -442,9 -432,9 +474,13 @@@ init_adminq_exit
   *
   *  The main shutdown routine for the Admin Send Queue
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +static i40e_status i40e_shutdown_asq(struct i40e_hw *hw)
++=======
+ static iavf_status i40e_shutdown_asq(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 -	iavf_status ret_code = 0;
 +	i40e_status ret_code = 0;
  
  	mutex_lock(&hw->aq.asq_mutex);
  
@@@ -476,9 -466,9 +512,13 @@@ shutdown_asq_out
   *
   *  The main shutdown routine for the Admin Receive Queue
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +static i40e_status i40e_shutdown_arq(struct i40e_hw *hw)
++=======
+ static iavf_status i40e_shutdown_arq(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 -	iavf_status ret_code = 0;
 +	i40e_status ret_code = 0;
  
  	mutex_lock(&hw->aq.arq_mutex);
  
@@@ -515,9 -505,9 +555,13 @@@ shutdown_arq_out
   *     - hw->aq.arq_buf_size
   *     - hw->aq.asq_buf_size
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +i40e_status i40evf_init_adminq(struct i40e_hw *hw)
++=======
+ iavf_status iavf_init_adminq(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 -	iavf_status ret_code;
 +	i40e_status ret_code;
  
  	/* verify input for valid configuration */
  	if ((hw->aq.num_arq_entries == 0) ||
@@@ -556,15 -546,15 +600,19 @@@ init_adminq_exit
  }
  
  /**
 - *  iavf_shutdown_adminq - shutdown routine for the Admin Queue
 + *  i40evf_shutdown_adminq - shutdown routine for the Admin Queue
   *  @hw: pointer to the hardware structure
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +i40e_status i40evf_shutdown_adminq(struct i40e_hw *hw)
++=======
+ iavf_status iavf_shutdown_adminq(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 -	iavf_status ret_code = 0;
 +	i40e_status ret_code = 0;
  
 -	if (iavf_check_asq_alive(hw))
 -		iavf_aq_queue_shutdown(hw, true);
 +	if (i40evf_check_asq_alive(hw))
 +		i40evf_aq_queue_shutdown(hw, true);
  
  	i40e_shutdown_asq(hw);
  	i40e_shutdown_arq(hw);
@@@ -581,9 -568,9 +629,9 @@@
   *
   *  returns the number of free desc
   **/
- static u16 i40e_clean_asq(struct i40e_hw *hw)
+ static u16 i40e_clean_asq(struct iavf_hw *hw)
  {
 -	struct i40e_adminq_ring *asq = &hw->aq.asq;
 +	struct i40e_adminq_ring *asq = &(hw->aq.asq);
  	struct i40e_asq_cmd_details *details;
  	u16 ntc = asq->next_to_clean;
  	struct i40e_aq_desc desc_cb;
@@@ -623,7 -610,7 +671,11 @@@
   *  Returns true if the firmware has processed all descriptors on the
   *  admin send queue. Returns false if there are still requests pending.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +bool i40evf_asq_done(struct i40e_hw *hw)
++=======
+ bool iavf_asq_done(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
  	/* AQ designers suggest use of head for better
  	 * timing reliability than DD bit
@@@ -643,13 -629,12 +695,20 @@@
   *  This is the main send command driver routine for the Admin Queue send
   *  queue.  It runs the queue, cleans the queue, etc
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +i40e_status i40evf_asq_send_command(struct i40e_hw *hw,
 +				struct i40e_aq_desc *desc,
 +				void *buff, /* can be NULL */
 +				u16  buff_size,
 +				struct i40e_asq_cmd_details *cmd_details)
++=======
+ iavf_status iavf_asq_send_command(struct iavf_hw *hw, struct i40e_aq_desc *desc,
+ 				  void *buff, /* can be NULL */
+ 				  u16  buff_size,
+ 				  struct i40e_asq_cmd_details *cmd_details)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 -	iavf_status status = 0;
 +	i40e_status status = 0;
  	struct i40e_dma_mem *dma_buff = NULL;
  	struct i40e_asq_cmd_details *details;
  	struct i40e_aq_desc *desc_on_ring;
@@@ -858,13 -841,13 +917,19 @@@ void i40evf_fill_default_direct_cmd_des
   *  the contents through e.  It can also return how many events are
   *  left to process through 'pending'
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +i40e_status i40evf_clean_arq_element(struct i40e_hw *hw,
 +					     struct i40e_arq_event_info *e,
 +					     u16 *pending)
++=======
+ iavf_status iavf_clean_arq_element(struct iavf_hw *hw,
+ 				   struct i40e_arq_event_info *e,
+ 				   u16 *pending)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
 +	i40e_status ret_code = 0;
  	u16 ntc = hw->aq.arq.next_to_clean;
  	struct i40e_aq_desc *desc;
 -	iavf_status ret_code = 0;
  	struct i40e_dma_mem *bi;
  	u16 desc_idx;
  	u16 datalen;
diff --cc drivers/net/ethernet/intel/i40evf/i40e_alloc.h
index cb8689222c8b,c1e02a32ca9d..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_alloc.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_alloc.h
@@@ -20,16 -20,12 +20,26 @@@ enum i40e_memory_type 
  };
  
  /* prototype for functions used for dynamic memory allocation */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_alloc.h
 +i40e_status i40e_allocate_dma_mem(struct i40e_hw *hw,
 +					    struct i40e_dma_mem *mem,
 +					    enum i40e_memory_type type,
 +					    u64 size, u32 alignment);
 +i40e_status i40e_free_dma_mem(struct i40e_hw *hw,
 +					struct i40e_dma_mem *mem);
 +i40e_status i40e_allocate_virt_mem(struct i40e_hw *hw,
 +					     struct i40e_virt_mem *mem,
 +					     u32 size);
 +i40e_status i40e_free_virt_mem(struct i40e_hw *hw,
 +					 struct i40e_virt_mem *mem);
++=======
+ iavf_status i40e_allocate_dma_mem(struct iavf_hw *hw, struct i40e_dma_mem *mem,
+ 				  enum i40e_memory_type type,
+ 				  u64 size, u32 alignment);
+ iavf_status i40e_free_dma_mem(struct iavf_hw *hw, struct i40e_dma_mem *mem);
+ iavf_status i40e_allocate_virt_mem(struct iavf_hw *hw,
+ 				   struct i40e_virt_mem *mem, u32 size);
+ iavf_status i40e_free_virt_mem(struct iavf_hw *hw, struct i40e_virt_mem *mem);
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_alloc.h
  
  #endif /* _I40E_ALLOC_H_ */
diff --cc drivers/net/ethernet/intel/i40evf/i40e_common.c
index eea280ba411e,97eb06616cc0..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_common.c
@@@ -13,9 -13,9 +13,13 @@@
   * This function sets the mac type of the adapter based on the
   * vendor ID and device ID stored in the hw structure.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40e_set_mac_type(struct i40e_hw *hw)
++=======
+ iavf_status i40e_set_mac_type(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
 -	iavf_status status = 0;
 +	i40e_status status = 0;
  
  	if (hw->vendor_id == PCI_VENDOR_ID_INTEL) {
  		switch (hw->device_id) {
@@@ -66,7 -44,7 +70,11 @@@
   * @hw: pointer to the HW structure
   * @aq_err: the AQ error code to convert
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +const char *i40evf_aq_str(struct i40e_hw *hw, enum i40e_admin_queue_err aq_err)
++=======
+ const char *iavf_aq_str(struct iavf_hw *hw, enum i40e_admin_queue_err aq_err)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	switch (aq_err) {
  	case I40E_AQ_RC_OK:
@@@ -126,7 -104,7 +134,11 @@@
   * @hw: pointer to the HW structure
   * @stat_err: the status error code to convert
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +const char *i40evf_stat_str(struct i40e_hw *hw, i40e_status stat_err)
++=======
+ const char *iavf_stat_str(struct iavf_hw *hw, iavf_status stat_err)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	switch (stat_err) {
  	case 0:
@@@ -279,7 -257,7 +291,11 @@@
   *
   * Dumps debug log about adminq command with descriptor contents.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +void i40evf_debug_aq(struct i40e_hw *hw, enum i40e_debug_mask mask, void *desc,
++=======
+ void iavf_debug_aq(struct iavf_hw *hw, enum i40e_debug_mask mask, void *desc,
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  		   void *buffer, u16 buf_len)
  {
  	struct i40e_aq_desc *aq_desc = (struct i40e_aq_desc *)desc;
@@@ -332,7 -310,7 +348,11 @@@
   *
   * Returns true if Queue is enabled else false.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +bool i40evf_check_asq_alive(struct i40e_hw *hw)
++=======
+ bool iavf_check_asq_alive(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	if (hw->aq.asq.len)
  		return !!(rd32(hw, hw->aq.asq.len) &
@@@ -349,8 -327,7 +369,12 @@@
   * Tell the Firmware that we're shutting down the AdminQ and whether
   * or not the driver is unloading as well.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40evf_aq_queue_shutdown(struct i40e_hw *hw,
 +					     bool unloading)
++=======
+ iavf_status iavf_aq_queue_shutdown(struct iavf_hw *hw, bool unloading)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	struct i40e_aq_desc desc;
  	struct i40e_aqc_queue_shutdown *cmd =
@@@ -378,7 -354,7 +402,11 @@@
   *
   * Internal function to get or set RSS look up table
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +static i40e_status i40e_aq_get_set_rss_lut(struct i40e_hw *hw,
++=======
+ static iavf_status i40e_aq_get_set_rss_lut(struct iavf_hw *hw,
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  					   u16 vsi_id, bool pf_lut,
  					   u8 *lut, u16 lut_size,
  					   bool set)
@@@ -431,8 -407,8 +459,13 @@@
   *
   * get the RSS lookup table, PF or VSI type
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40evf_aq_get_rss_lut(struct i40e_hw *hw, u16 vsi_id,
 +				  bool pf_lut, u8 *lut, u16 lut_size)
++=======
+ iavf_status iavf_aq_get_rss_lut(struct iavf_hw *hw, u16 vsi_id,
+ 				bool pf_lut, u8 *lut, u16 lut_size)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	return i40e_aq_get_set_rss_lut(hw, vsi_id, pf_lut, lut, lut_size,
  				       false);
@@@ -448,8 -424,8 +481,13 @@@
   *
   * set the RSS lookup table, PF or VSI type
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40evf_aq_set_rss_lut(struct i40e_hw *hw, u16 vsi_id,
 +				  bool pf_lut, u8 *lut, u16 lut_size)
++=======
+ iavf_status iavf_aq_set_rss_lut(struct iavf_hw *hw, u16 vsi_id,
+ 				bool pf_lut, u8 *lut, u16 lut_size)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	return i40e_aq_get_set_rss_lut(hw, vsi_id, pf_lut, lut, lut_size, true);
  }
@@@ -463,12 -439,12 +501,19 @@@
   *
   * get the RSS key per VSI
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +static i40e_status i40e_aq_get_set_rss_key(struct i40e_hw *hw,
 +				      u16 vsi_id,
 +				      struct i40e_aqc_get_set_rss_key_data *key,
 +				      bool set)
++=======
+ static
+ iavf_status i40e_aq_get_set_rss_key(struct iavf_hw *hw, u16 vsi_id,
+ 				    struct i40e_aqc_get_set_rss_key_data *key,
+ 				    bool set)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
 -	iavf_status status;
 +	i40e_status status;
  	struct i40e_aq_desc desc;
  	struct i40e_aqc_get_set_rss_key *cmd_resp =
  			(struct i40e_aqc_get_set_rss_key *)&desc.params.raw;
@@@ -503,9 -479,8 +548,14 @@@
   * @key: pointer to key info struct
   *
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40evf_aq_get_rss_key(struct i40e_hw *hw,
 +				  u16 vsi_id,
 +				  struct i40e_aqc_get_set_rss_key_data *key)
++=======
+ iavf_status iavf_aq_get_rss_key(struct iavf_hw *hw, u16 vsi_id,
+ 				struct i40e_aqc_get_set_rss_key_data *key)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	return i40e_aq_get_set_rss_key(hw, vsi_id, key, false);
  }
@@@ -518,9 -493,8 +568,14 @@@
   *
   * set the RSS key per VSI
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40evf_aq_set_rss_key(struct i40e_hw *hw,
 +				  u16 vsi_id,
 +				  struct i40e_aqc_get_set_rss_key_data *key)
++=======
+ iavf_status iavf_aq_set_rss_key(struct iavf_hw *hw, u16 vsi_id,
+ 				struct i40e_aqc_get_set_rss_key_data *key)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	return i40e_aq_get_set_rss_key(hw, vsi_id, key, true);
  }
@@@ -1030,20 -874,19 +1085,27 @@@ do_retry
   * @cmd_details: pointer to command details
   *
   * Send message to PF driver using admin queue. By default, this message
 - * is sent asynchronously, i.e. iavf_asq_send_command() does not wait for
 + * is sent asynchronously, i.e. i40evf_asq_send_command() does not wait for
   * completion before returning.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40e_aq_send_msg_to_pf(struct i40e_hw *hw,
 +				enum virtchnl_ops v_opcode,
 +				i40e_status v_retval,
 +				u8 *msg, u16 msglen,
 +				struct i40e_asq_cmd_details *cmd_details)
++=======
+ iavf_status iavf_aq_send_msg_to_pf(struct iavf_hw *hw,
+ 				   enum virtchnl_ops v_opcode,
+ 				   iavf_status v_retval, u8 *msg, u16 msglen,
+ 				   struct i40e_asq_cmd_details *cmd_details)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
 -	struct i40e_asq_cmd_details details;
  	struct i40e_aq_desc desc;
 -	iavf_status status;
 +	struct i40e_asq_cmd_details details;
 +	i40e_status status;
  
 -	iavf_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_send_msg_to_pf);
 +	i40evf_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_send_msg_to_pf);
  	desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_SI);
  	desc.cookie_high = cpu_to_le32(v_opcode);
  	desc.cookie_low = cpu_to_le32(v_retval);
@@@ -1071,7 -914,7 +1133,11 @@@
   * Given a VF resource message from the PF, populate the hw struct
   * with appropriate information.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +void i40e_vf_parse_hw_config(struct i40e_hw *hw,
++=======
+ void iavf_vf_parse_hw_config(struct iavf_hw *hw,
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  			     struct virtchnl_vf_resource *msg)
  {
  	struct virtchnl_vsi_resource *vsi_res;
@@@ -1105,216 -948,8 +1171,220 @@@
   * as none will be forthcoming. Immediately after calling this function,
   * the admin queue should be shut down and (optionally) reinitialized.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40e_vf_reset(struct i40e_hw *hw)
++=======
+ iavf_status iavf_vf_reset(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
 -	return iavf_aq_send_msg_to_pf(hw, VIRTCHNL_OP_RESET_VF,
 +	return i40e_aq_send_msg_to_pf(hw, VIRTCHNL_OP_RESET_VF,
  				      0, NULL, 0, NULL);
  }
 +
 +/**
 + * i40evf_aq_write_ddp - Write dynamic device personalization (ddp)
 + * @hw: pointer to the hw struct
 + * @buff: command buffer (size in bytes = buff_size)
 + * @buff_size: buffer size in bytes
 + * @track_id: package tracking id
 + * @error_offset: returns error offset
 + * @error_info: returns error information
 + * @cmd_details: pointer to command details structure or NULL
 + **/
 +enum
 +i40e_status_code i40evf_aq_write_ddp(struct i40e_hw *hw, void *buff,
 +				     u16 buff_size, u32 track_id,
 +				     u32 *error_offset, u32 *error_info,
 +				     struct i40e_asq_cmd_details *cmd_details)
 +{
 +	struct i40e_aq_desc desc;
 +	struct i40e_aqc_write_personalization_profile *cmd =
 +		(struct i40e_aqc_write_personalization_profile *)
 +		&desc.params.raw;
 +	struct i40e_aqc_write_ddp_resp *resp;
 +	i40e_status status;
 +
 +	i40evf_fill_default_direct_cmd_desc(&desc,
 +					    i40e_aqc_opc_write_personalization_profile);
 +
 +	desc.flags |= cpu_to_le16(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD);
 +	if (buff_size > I40E_AQ_LARGE_BUF)
 +		desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);
 +
 +	desc.datalen = cpu_to_le16(buff_size);
 +
 +	cmd->profile_track_id = cpu_to_le32(track_id);
 +
 +	status = i40evf_asq_send_command(hw, &desc, buff, buff_size, cmd_details);
 +	if (!status) {
 +		resp = (struct i40e_aqc_write_ddp_resp *)&desc.params.raw;
 +		if (error_offset)
 +			*error_offset = le32_to_cpu(resp->error_offset);
 +		if (error_info)
 +			*error_info = le32_to_cpu(resp->error_info);
 +	}
 +
 +	return status;
 +}
 +
 +/**
 + * i40evf_aq_get_ddp_list - Read dynamic device personalization (ddp)
 + * @hw: pointer to the hw struct
 + * @buff: command buffer (size in bytes = buff_size)
 + * @buff_size: buffer size in bytes
 + * @flags: AdminQ command flags
 + * @cmd_details: pointer to command details structure or NULL
 + **/
 +enum
 +i40e_status_code i40evf_aq_get_ddp_list(struct i40e_hw *hw, void *buff,
 +					u16 buff_size, u8 flags,
 +				       struct i40e_asq_cmd_details *cmd_details)
 +{
 +	struct i40e_aq_desc desc;
 +	struct i40e_aqc_get_applied_profiles *cmd =
 +		(struct i40e_aqc_get_applied_profiles *)&desc.params.raw;
 +	i40e_status status;
 +
 +	i40evf_fill_default_direct_cmd_desc(&desc,
 +					    i40e_aqc_opc_get_personalization_profile_list);
 +
 +	desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);
 +	if (buff_size > I40E_AQ_LARGE_BUF)
 +		desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);
 +	desc.datalen = cpu_to_le16(buff_size);
 +
 +	cmd->flags = flags;
 +
 +	status = i40evf_asq_send_command(hw, &desc, buff, buff_size, cmd_details);
 +
 +	return status;
 +}
 +
 +/**
 + * i40evf_find_segment_in_package
 + * @segment_type: the segment type to search for (i.e., SEGMENT_TYPE_I40E)
 + * @pkg_hdr: pointer to the package header to be searched
 + *
 + * This function searches a package file for a particular segment type. On
 + * success it returns a pointer to the segment header, otherwise it will
 + * return NULL.
 + **/
 +struct i40e_generic_seg_header *
 +i40evf_find_segment_in_package(u32 segment_type,
 +			       struct i40e_package_header *pkg_hdr)
 +{
 +	struct i40e_generic_seg_header *segment;
 +	u32 i;
 +
 +	/* Search all package segments for the requested segment type */
 +	for (i = 0; i < pkg_hdr->segment_count; i++) {
 +		segment =
 +			(struct i40e_generic_seg_header *)((u8 *)pkg_hdr +
 +			 pkg_hdr->segment_offset[i]);
 +
 +		if (segment->type == segment_type)
 +			return segment;
 +	}
 +
 +	return NULL;
 +}
 +
 +/**
 + * i40evf_write_profile
 + * @hw: pointer to the hardware structure
 + * @profile: pointer to the profile segment of the package to be downloaded
 + * @track_id: package tracking id
 + *
 + * Handles the download of a complete package.
 + */
 +enum i40e_status_code
 +i40evf_write_profile(struct i40e_hw *hw, struct i40e_profile_segment *profile,
 +		     u32 track_id)
 +{
 +	i40e_status status = 0;
 +	struct i40e_section_table *sec_tbl;
 +	struct i40e_profile_section_header *sec = NULL;
 +	u32 dev_cnt;
 +	u32 vendor_dev_id;
 +	u32 *nvm;
 +	u32 section_size = 0;
 +	u32 offset = 0, info = 0;
 +	u32 i;
 +
 +	dev_cnt = profile->device_table_count;
 +
 +	for (i = 0; i < dev_cnt; i++) {
 +		vendor_dev_id = profile->device_table[i].vendor_dev_id;
 +		if ((vendor_dev_id >> 16) == PCI_VENDOR_ID_INTEL)
 +			if (hw->device_id == (vendor_dev_id & 0xFFFF))
 +				break;
 +	}
 +	if (i == dev_cnt) {
 +		i40e_debug(hw, I40E_DEBUG_PACKAGE, "Device doesn't support DDP");
 +		return I40E_ERR_DEVICE_NOT_SUPPORTED;
 +	}
 +
 +	nvm = (u32 *)&profile->device_table[dev_cnt];
 +	sec_tbl = (struct i40e_section_table *)&nvm[nvm[0] + 1];
 +
 +	for (i = 0; i < sec_tbl->section_count; i++) {
 +		sec = (struct i40e_profile_section_header *)((u8 *)profile +
 +					     sec_tbl->section_offset[i]);
 +
 +		/* Skip 'AQ', 'note' and 'name' sections */
 +		if (sec->section.type != SECTION_TYPE_MMIO)
 +			continue;
 +
 +		section_size = sec->section.size +
 +			sizeof(struct i40e_profile_section_header);
 +
 +		/* Write profile */
 +		status = i40evf_aq_write_ddp(hw, (void *)sec, (u16)section_size,
 +					     track_id, &offset, &info, NULL);
 +		if (status) {
 +			i40e_debug(hw, I40E_DEBUG_PACKAGE,
 +				   "Failed to write profile: offset %d, info %d",
 +				   offset, info);
 +			break;
 +		}
 +	}
 +	return status;
 +}
 +
 +/**
 + * i40evf_add_pinfo_to_list
 + * @hw: pointer to the hardware structure
 + * @profile: pointer to the profile segment of the package
 + * @profile_info_sec: buffer for information section
 + * @track_id: package tracking id
 + *
 + * Register a profile to the list of loaded profiles.
 + */
 +enum i40e_status_code
 +i40evf_add_pinfo_to_list(struct i40e_hw *hw,
 +			 struct i40e_profile_segment *profile,
 +			 u8 *profile_info_sec, u32 track_id)
 +{
 +	i40e_status status = 0;
 +	struct i40e_profile_section_header *sec = NULL;
 +	struct i40e_profile_info *pinfo;
 +	u32 offset = 0, info = 0;
 +
 +	sec = (struct i40e_profile_section_header *)profile_info_sec;
 +	sec->tbl_size = 1;
 +	sec->data_end = sizeof(struct i40e_profile_section_header) +
 +			sizeof(struct i40e_profile_info);
 +	sec->section.type = SECTION_TYPE_INFO;
 +	sec->section.offset = sizeof(struct i40e_profile_section_header);
 +	sec->section.size = sizeof(struct i40e_profile_info);
 +	pinfo = (struct i40e_profile_info *)(profile_info_sec +
 +					     sec->section.offset);
 +	pinfo->track_id = track_id;
 +	pinfo->version = profile->version;
 +	pinfo->op = I40E_DDP_ADD_TRACKID;
 +	memcpy(pinfo->name, profile->name, I40E_DDP_NAME_SIZE);
 +
 +	status = i40evf_aq_write_ddp(hw, (void *)sec, sec->data_end,
 +				     track_id, &offset, &info, NULL);
 +	return status;
 +}
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_main.c
index 950c8aeb0fc9,5d5a65483e23..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@@ -65,11 -66,11 +65,17 @@@ static struct workqueue_struct *i40evf_
   * @size: size of memory requested
   * @alignment: what to align the allocation to
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +i40e_status i40evf_allocate_dma_mem_d(struct i40e_hw *hw,
 +				      struct i40e_dma_mem *mem,
 +				      u64 size, u32 alignment)
++=======
+ iavf_status iavf_allocate_dma_mem_d(struct iavf_hw *hw,
+ 				    struct i40e_dma_mem *mem,
+ 				    u64 size, u32 alignment)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/iavf_main.c
  {
 -	struct iavf_adapter *adapter = (struct iavf_adapter *)hw->back;
 +	struct i40evf_adapter *adapter = (struct i40evf_adapter *)hw->back;
  
  	if (!mem)
  		return I40E_ERR_PARAM;
@@@ -88,9 -89,9 +94,13 @@@
   * @hw:   pointer to the HW structure
   * @mem:  ptr to mem struct to free
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +i40e_status i40evf_free_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem)
++=======
+ iavf_status iavf_free_dma_mem_d(struct iavf_hw *hw, struct i40e_dma_mem *mem)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/iavf_main.c
  {
 -	struct iavf_adapter *adapter = (struct iavf_adapter *)hw->back;
 +	struct i40evf_adapter *adapter = (struct i40evf_adapter *)hw->back;
  
  	if (!mem || !mem->va)
  		return I40E_ERR_PARAM;
@@@ -105,8 -106,8 +115,13 @@@
   * @mem:  ptr to mem struct to fill out
   * @size: size of memory requested
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +i40e_status i40evf_allocate_virt_mem_d(struct i40e_hw *hw,
 +				       struct i40e_virt_mem *mem, u32 size)
++=======
+ iavf_status iavf_allocate_virt_mem_d(struct iavf_hw *hw,
+ 				     struct i40e_virt_mem *mem, u32 size)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/iavf_main.c
  {
  	if (!mem)
  		return I40E_ERR_PARAM;
@@@ -125,8 -126,8 +140,13 @@@
   * @hw:   pointer to the HW structure
   * @mem:  ptr to mem struct to free
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +i40e_status i40evf_free_virt_mem_d(struct i40e_hw *hw,
 +				   struct i40e_virt_mem *mem)
++=======
+ iavf_status iavf_free_virt_mem_d(struct iavf_hw *hw,
+ 				 struct i40e_virt_mem *mem)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/iavf_main.c
  {
  	if (!mem)
  		return I40E_ERR_PARAM;
@@@ -185,12 -186,12 +205,12 @@@ static void i40evf_tx_timeout(struct ne
  }
  
  /**
 - * iavf_misc_irq_disable - Mask off interrupt generation on the NIC
 + * i40evf_misc_irq_disable - Mask off interrupt generation on the NIC
   * @adapter: board private structure
   **/
 -static void iavf_misc_irq_disable(struct iavf_adapter *adapter)
 +static void i40evf_misc_irq_disable(struct i40evf_adapter *adapter)
  {
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  
  	if (!adapter->msix_entries)
  		return;
@@@ -204,29 -204,28 +224,29 @@@
  }
  
  /**
 - * iavf_misc_irq_enable - Enable default interrupt generation settings
 + * i40evf_misc_irq_enable - Enable default interrupt generation settings
   * @adapter: board private structure
   **/
 -static void iavf_misc_irq_enable(struct iavf_adapter *adapter)
 +static void i40evf_misc_irq_enable(struct i40evf_adapter *adapter)
  {
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  
 -	wr32(hw, IAVF_VFINT_DYN_CTL01, IAVF_VFINT_DYN_CTL01_INTENA_MASK |
 -				       IAVF_VFINT_DYN_CTL01_ITR_INDX_MASK);
 -	wr32(hw, IAVF_VFINT_ICR0_ENA1, IAVF_VFINT_ICR0_ENA1_ADMINQ_MASK);
 +	wr32(hw, I40E_VFINT_DYN_CTL01, I40E_VFINT_DYN_CTL01_INTENA_MASK |
 +				       I40E_VFINT_DYN_CTL01_ITR_INDX_MASK);
 +	wr32(hw, I40E_VFINT_ICR0_ENA1, I40E_VFINT_ICR0_ENA1_ADMINQ_MASK);
  
 -	iavf_flush(hw);
 +	/* read flush */
 +	rd32(hw, I40E_VFGEN_RSTAT);
  }
  
  /**
 - * iavf_irq_disable - Mask off interrupt generation on the NIC
 + * i40evf_irq_disable - Mask off interrupt generation on the NIC
   * @adapter: board private structure
   **/
 -static void iavf_irq_disable(struct iavf_adapter *adapter)
 +static void i40evf_irq_disable(struct i40evf_adapter *adapter)
  {
  	int i;
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  
  	if (!adapter->msix_entries)
  		return;
@@@ -244,9 -242,9 +264,9 @@@
   * @adapter: board private structure
   * @mask: bitmap of queues to enable
   **/
 -void iavf_irq_enable_queues(struct iavf_adapter *adapter, u32 mask)
 +void i40evf_irq_enable_queues(struct i40evf_adapter *adapter, u32 mask)
  {
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  	int i;
  
  	for (i = 1; i < adapter->num_msix_vectors; i++) {
@@@ -263,15 -261,15 +283,15 @@@
   * @adapter: board private structure
   * @flush: boolean value whether to run rd32()
   **/
 -void iavf_irq_enable(struct iavf_adapter *adapter, bool flush)
 +void i40evf_irq_enable(struct i40evf_adapter *adapter, bool flush)
  {
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  
 -	iavf_misc_irq_enable(adapter);
 -	iavf_irq_enable_queues(adapter, ~0);
 +	i40evf_misc_irq_enable(adapter);
 +	i40evf_irq_enable_queues(adapter, ~0);
  
  	if (flush)
 -		iavf_flush(hw);
 +		rd32(hw, I40E_VFGEN_RSTAT);
  }
  
  /**
@@@ -279,15 -277,15 +299,20 @@@
   * @irq: interrupt number
   * @data: pointer to netdev
   **/
 -static irqreturn_t iavf_msix_aq(int irq, void *data)
 +static irqreturn_t i40evf_msix_aq(int irq, void *data)
  {
  	struct net_device *netdev = data;
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	struct i40evf_adapter *adapter = netdev_priv(netdev);
 +	struct i40e_hw *hw = &adapter->hw;
++=======
+ 	struct iavf_adapter *adapter = netdev_priv(netdev);
+ 	struct iavf_hw *hw = &adapter->hw;
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/iavf_main.c
  
  	/* handle non-queue interrupts, these reads clear the registers */
 -	rd32(hw, IAVF_VFINT_ICR01);
 -	rd32(hw, IAVF_VFINT_ICR0_ENA1);
 +	rd32(hw, I40E_VFINT_ICR01);
 +	rd32(hw, I40E_VFINT_ICR0_ENA1);
  
  	/* schedule work on the private workqueue */
  	schedule_work(&adapter->adminq_task);
@@@ -593,9 -592,9 +618,9 @@@ static void i40evf_free_misc_irq(struc
   *
   * Configure the Tx unit of the MAC after a reset.
   **/
 -static void iavf_configure_tx(struct iavf_adapter *adapter)
 +static void i40evf_configure_tx(struct i40evf_adapter *adapter)
  {
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  	int i;
  
  	for (i = 0; i < adapter->num_active_queues; i++)
@@@ -608,10 -607,10 +633,10 @@@
   *
   * Configure the Rx unit of the MAC after a reset.
   **/
 -static void iavf_configure_rx(struct iavf_adapter *adapter)
 +static void i40evf_configure_rx(struct i40evf_adapter *adapter)
  {
  	unsigned int rx_buf_len = I40E_RXBUFFER_2048;
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  	int i;
  
  	/* Legacy Rx will always default to a 2048 buffer size. */
@@@ -820,11 -819,11 +845,17 @@@ i40evf_mac_filter *i40evf_add_filter(st
   *
   * Returns 0 on success, negative on failure
   **/
 -static int iavf_set_mac(struct net_device *netdev, void *p)
 +static int i40evf_set_mac(struct net_device *netdev, void *p)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	struct i40evf_adapter *adapter = netdev_priv(netdev);
 +	struct i40e_hw *hw = &adapter->hw;
 +	struct i40evf_mac_filter *f;
++=======
+ 	struct iavf_adapter *adapter = netdev_priv(netdev);
+ 	struct iavf_hw *hw = &adapter->hw;
+ 	struct iavf_mac_filter *f;
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/iavf_main.c
  	struct sockaddr *addr = p;
  
  	if (!is_valid_ether_addr(addr->sa_data))
@@@ -1291,9 -1290,9 +1322,9 @@@ static int i40evf_config_rss_aq(struct 
   *
   * Returns 0 on success, negative on failure
   **/
 -static int iavf_config_rss_reg(struct iavf_adapter *adapter)
 +static int i40evf_config_rss_reg(struct i40evf_adapter *adapter)
  {
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  	u32 *dw;
  	u16 i;
  
@@@ -1348,9 -1347,9 +1379,9 @@@ static void i40evf_fill_rss_lut(struct 
   *
   * Return 0 on success, negative on failure
   **/
 -static int iavf_init_rss(struct iavf_adapter *adapter)
 +static int i40evf_init_rss(struct i40evf_adapter *adapter)
  {
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  	int ret;
  
  	if (!RSS_PF(adapter)) {
@@@ -1569,23 -1569,23 +1600,23 @@@ static void i40evf_watchdog_timer(unsig
  }
  
  /**
 - * iavf_watchdog_task - Periodic call-back task
 + * i40evf_watchdog_task - Periodic call-back task
   * @work: pointer to work_struct
   **/
 -static void iavf_watchdog_task(struct work_struct *work)
 +static void i40evf_watchdog_task(struct work_struct *work)
  {
 -	struct iavf_adapter *adapter = container_of(work,
 -						      struct iavf_adapter,
 +	struct i40evf_adapter *adapter = container_of(work,
 +						      struct i40evf_adapter,
  						      watchdog_task);
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  	u32 reg_val;
  
 -	if (test_and_set_bit(__IAVF_IN_CRITICAL_TASK, &adapter->crit_section))
 +	if (test_and_set_bit(__I40EVF_IN_CRITICAL_TASK, &adapter->crit_section))
  		goto restart_watchdog;
  
 -	if (adapter->flags & IAVF_FLAG_PF_COMMS_FAILED) {
 -		reg_val = rd32(hw, IAVF_VFGEN_RSTAT) &
 -			  IAVF_VFGEN_RSTAT_VFR_STATE_MASK;
 +	if (adapter->flags & I40EVF_FLAG_PF_COMMS_FAILED) {
 +		reg_val = rd32(hw, I40E_VFGEN_RSTAT) &
 +			  I40E_VFGEN_RSTAT_VFR_STATE_MASK;
  		if ((reg_val == VIRTCHNL_VFR_VFACTIVE) ||
  		    (reg_val == VIRTCHNL_VFR_COMPLETED)) {
  			/* A chance for redemption! */
@@@ -1848,10 -1848,10 +1879,17 @@@ static void i40evf_reset_task(struct wo
  						      reset_task);
  	struct virtchnl_vf_resource *vfres = adapter->vf_res;
  	struct net_device *netdev = adapter->netdev;
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	struct i40e_hw *hw = &adapter->hw;
 +	struct i40evf_vlan_filter *vlf;
 +	struct i40evf_cloud_filter *cf;
 +	struct i40evf_mac_filter *f;
++=======
+ 	struct iavf_hw *hw = &adapter->hw;
+ 	struct iavf_vlan_filter *vlf;
+ 	struct iavf_cloud_filter *cf;
+ 	struct iavf_mac_filter *f;
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/iavf_main.c
  	u32 reg_val;
  	int i = 0, err;
  	bool running;
@@@ -2037,17 -2036,17 +2075,23 @@@ reset_err
  }
  
  /**
 - * iavf_adminq_task - worker thread to clean the admin queue
 + * i40evf_adminq_task - worker thread to clean the admin queue
   * @work: pointer to work_struct containing our data
   **/
 -static void iavf_adminq_task(struct work_struct *work)
 +static void i40evf_adminq_task(struct work_struct *work)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	struct i40evf_adapter *adapter =
 +		container_of(work, struct i40evf_adapter, adminq_task);
 +	struct i40e_hw *hw = &adapter->hw;
++=======
+ 	struct iavf_adapter *adapter =
+ 		container_of(work, struct iavf_adapter, adminq_task);
+ 	struct iavf_hw *hw = &adapter->hw;
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/iavf_main.c
  	struct i40e_arq_event_info event;
  	enum virtchnl_ops v_op;
 -	iavf_status ret, v_ret;
 +	i40e_status ret, v_ret;
  	u32 val, oldval;
  	u16 pending;
  
@@@ -3242,7 -3240,7 +3286,11 @@@ static const struct net_device_ops i40e
   *
   * Returns 0 if device is ready to use, or -EBUSY if it's in reset.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +static int i40evf_check_reset_complete(struct i40e_hw *hw)
++=======
+ static int iavf_check_reset_complete(struct iavf_hw *hw)
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/iavf_main.c
  {
  	u32 rstat;
  	int i;
@@@ -3409,13 -3407,13 +3457,13 @@@ int i40evf_process_config(struct i40evf
   * communications with the PF driver and set up our netdev, the watchdog
   * takes over.
   **/
 -static void iavf_init_task(struct work_struct *work)
 +static void i40evf_init_task(struct work_struct *work)
  {
 -	struct iavf_adapter *adapter = container_of(work,
 -						      struct iavf_adapter,
 +	struct i40evf_adapter *adapter = container_of(work,
 +						      struct i40evf_adapter,
  						      init_task.work);
  	struct net_device *netdev = adapter->netdev;
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  	struct pci_dev *pdev = adapter->pdev;
  	int err, bufsz;
  
@@@ -3662,11 -3659,11 +3710,16 @@@ static void i40evf_shutdown(struct pci_
   * The OS initialization, configuring of the adapter private structure,
   * and a hardware reset occur.
   **/
 -static int iavf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 +static int i40evf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
  {
  	struct net_device *netdev;
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	struct i40evf_adapter *adapter = NULL;
 +	struct i40e_hw *hw = NULL;
++=======
+ 	struct iavf_adapter *adapter = NULL;
+ 	struct iavf_hw *hw = NULL;
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/iavf_main.c
  	int err;
  
  	err = pci_enable_device(pdev);
@@@ -3865,17 -3862,17 +3918,25 @@@ static int i40evf_resume(struct pci_de
   * Hot-Plug event, or because the driver is going to be removed from
   * memory.
   **/
 -static void iavf_remove(struct pci_dev *pdev)
 +static void i40evf_remove(struct pci_dev *pdev)
  {
  	struct net_device *netdev = pci_get_drvdata(pdev);
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +	struct i40evf_adapter *adapter = netdev_priv(netdev);
 +	struct i40evf_vlan_filter *vlf, *vlftmp;
 +	struct i40evf_mac_filter *f, *ftmp;
 +	struct i40evf_cloud_filter *cf, *cftmp;
 +	struct i40e_hw *hw = &adapter->hw;
++=======
+ 	struct iavf_adapter *adapter = netdev_priv(netdev);
+ 	struct iavf_vlan_filter *vlf, *vlftmp;
+ 	struct iavf_mac_filter *f, *ftmp;
+ 	struct iavf_cloud_filter *cf, *cftmp;
+ 	struct iavf_hw *hw = &adapter->hw;
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/iavf_main.c
  	int err;
  	/* Indicate we are in remove and not to run reset_task */
 -	set_bit(__IAVF_IN_REMOVE_TASK, &adapter->crit_section);
 +	set_bit(__I40EVF_IN_REMOVE_TASK, &adapter->crit_section);
  	cancel_delayed_work_sync(&adapter->init_task);
  	cancel_work_sync(&adapter->reset_task);
  	cancel_delayed_work_sync(&adapter->client_task);
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
index 6579dabab78c,04fbb74169a2..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
@@@ -18,20 -18,20 +18,25 @@@
   *
   * Send message to PF and print status if failure.
   **/
 -static int iavf_send_pf_msg(struct iavf_adapter *adapter,
 -			    enum virtchnl_ops op, u8 *msg, u16 len)
 +static int i40evf_send_pf_msg(struct i40evf_adapter *adapter,
 +			      enum virtchnl_ops op, u8 *msg, u16 len)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
 +	struct i40e_hw *hw = &adapter->hw;
 +	i40e_status err;
++=======
+ 	struct iavf_hw *hw = &adapter->hw;
+ 	iavf_status err;
++>>>>>>> f349daa58809 (iavf: rename i40e_hw to iavf_hw):drivers/net/ethernet/intel/iavf/iavf_virtchnl.c
  
 -	if (adapter->flags & IAVF_FLAG_PF_COMMS_FAILED)
 +	if (adapter->flags & I40EVF_FLAG_PF_COMMS_FAILED)
  		return 0; /* nothing to see here, move along */
  
 -	err = iavf_aq_send_msg_to_pf(hw, op, 0, msg, len, NULL);
 +	err = i40e_aq_send_msg_to_pf(hw, op, 0, msg, len, NULL);
  	if (err)
  		dev_dbg(&adapter->pdev->dev, "Unable to send opcode %d to PF, err %s, aq_err %s\n",
 -			op, iavf_stat_str(hw, err),
 -			iavf_aq_str(hw, hw->aq.asq_last_status));
 +			op, i40evf_stat_str(hw, err),
 +			i40evf_aq_str(hw, hw->aq.asq_last_status));
  	return err;
  }
  
@@@ -63,15 -63,15 +68,15 @@@ int i40evf_send_api_ver(struct i40evf_a
   * I40E_ERR_ADMIN_QUEUE_NO_WORK if the admin queue is empty, and any errors
   * from the firmware are propagated.
   **/
 -int iavf_verify_api_ver(struct iavf_adapter *adapter)
 +int i40evf_verify_api_ver(struct i40evf_adapter *adapter)
  {
  	struct virtchnl_version_info *pf_vvi;
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  	struct i40e_arq_event_info event;
  	enum virtchnl_ops op;
 -	iavf_status err;
 +	i40e_status err;
  
 -	event.buf_len = IAVF_MAX_AQ_BUF_SIZE;
 +	event.buf_len = I40EVF_MAX_AQ_BUF_SIZE;
  	event.msg_buf = kzalloc(event.buf_len, GFP_KERNEL);
  	if (!event.msg_buf) {
  		err = -ENOMEM;
@@@ -188,12 -186,12 +193,12 @@@ static void i40evf_validate_num_queues(
   * with maximum timeout. Response from PF is returned in the buffer for further
   * processing by the caller.
   **/
 -int iavf_get_vf_config(struct iavf_adapter *adapter)
 +int i40evf_get_vf_config(struct i40evf_adapter *adapter)
  {
- 	struct i40e_hw *hw = &adapter->hw;
+ 	struct iavf_hw *hw = &adapter->hw;
  	struct i40e_arq_event_info event;
  	enum virtchnl_ops op;
 -	iavf_status err;
 +	i40e_status err;
  	u16 len;
  
  	len =  sizeof(struct virtchnl_vf_resource) +
* Unmerged path drivers/net/ethernet/intel/iavf/i40e_prototype.h
* Unmerged path drivers/net/ethernet/intel/iavf/i40e_type.h
* Unmerged path drivers/net/ethernet/intel/iavf/iavf.h
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_adminq.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_alloc.h
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_common.c
diff --git a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
index 800d621606e8..91aeaa43b398 100644
--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c
@@ -1637,7 +1637,7 @@ static inline u32 i40e_buildreg_itr(const int type, u16 itr)
 static inline void i40e_update_enable_itr(struct i40e_vsi *vsi,
 					  struct i40e_q_vector *q_vector)
 {
-	struct i40e_hw *hw = &vsi->back->hw;
+	struct iavf_hw *hw = &vsi->back->hw;
 	u32 intval;
 
 	/* These will do nothing if dynamic updates are not enabled */
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_main.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
* Unmerged path drivers/net/ethernet/intel/iavf/i40e_prototype.h
* Unmerged path drivers/net/ethernet/intel/iavf/i40e_type.h
* Unmerged path drivers/net/ethernet/intel/iavf/iavf.h
