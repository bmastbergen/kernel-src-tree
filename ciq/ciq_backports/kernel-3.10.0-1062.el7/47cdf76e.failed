ALSA: hda/ca0132: Add new control changes for SBZ + R3Di

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit 47cdf76e44e87d25b91c0f0d0539944c932941ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/47cdf76e.failed

This patch adds new controls to set the effect levels on the R3Di and
SBZ. It also adds vmaster controls to control all surround sound
channels. So that Surround effect switch doesn't conflict with Surround
volume, FX: prefix added to all effect related switches.

	Tested-by: Mariusz Ceier <mceier+kernel@gmail.com>
	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 47cdf76e44e87d25b91c0f0d0539944c932941ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index 267302056b78,0fa67f45241d..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -127,7 -146,13 +127,17 @@@ enum 
  	VOICEFX = IN_EFFECT_END_NID,
  	PLAY_ENHANCEMENT,
  	CRYSTAL_VOICE,
++<<<<<<< HEAD
 +	EFFECT_END_NID
++=======
+ 	EFFECT_END_NID,
+ 	OUTPUT_SOURCE_ENUM,
+ 	INPUT_SOURCE_ENUM,
+ 	XBASS_XOVER,
+ 	EQ_PRESET_ENUM,
+ 	SMART_VOLUME_ENUM,
+ 	MIC_BOOST_ENUM
++>>>>>>> 47cdf76e44e8 (ALSA: hda/ca0132: Add new control changes for SBZ + R3Di)
  #define EFFECTS_COUNT  (EFFECT_END_NID - EFFECT_START_NID)
  };
  
@@@ -477,6 -511,161 +496,164 @@@ static struct ct_voicefx_preset ca0132_
  	}
  };
  
++<<<<<<< HEAD
++=======
+ /* ca0132 EQ presets, taken from Windows Sound Blaster Z Driver */
+ 
+ #define EQ_PRESET_MAX_PARAM_COUNT 11
+ 
+ struct ct_eq {
+ 	char *name;
+ 	hda_nid_t nid;
+ 	int mid;
+ 	int reqs[EQ_PRESET_MAX_PARAM_COUNT]; /*effect module request*/
+ };
+ 
+ struct ct_eq_preset {
+ 	char *name; /*preset name*/
+ 	unsigned int vals[EQ_PRESET_MAX_PARAM_COUNT];
+ };
+ 
+ static struct ct_eq ca0132_alt_eq_enum = {
+ 	.name = "FX: Equalizer Preset Switch",
+ 	.nid = EQ_PRESET_ENUM,
+ 	.mid = 0x96,
+ 	.reqs = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
+ };
+ 
+ 
+ static struct ct_eq_preset ca0132_alt_eq_presets[] = {
+ 	{ .name = "Flat",
+ 	 .vals = { 0x00000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x00000000	     }
+ 	},
+ 	{ .name = "Acoustic",
+ 	 .vals = { 0x00000000, 0x00000000, 0x3F8CCCCD,
+ 		   0x40000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x00000000, 0x40000000,
+ 		   0x40000000, 0x40000000	     }
+ 	},
+ 	{ .name = "Classical",
+ 	 .vals = { 0x00000000, 0x00000000, 0x40C00000,
+ 		   0x40C00000, 0x40466666, 0x00000000,
+ 		   0x00000000, 0x00000000, 0x00000000,
+ 		   0x40466666, 0x40466666	     }
+ 	},
+ 	{ .name = "Country",
+ 	 .vals = { 0x00000000, 0xBF99999A, 0x00000000,
+ 		   0x3FA66666, 0x3FA66666, 0x3F8CCCCD,
+ 		   0x00000000, 0x00000000, 0x40000000,
+ 		   0x40466666, 0x40800000	     }
+ 	},
+ 	{ .name = "Dance",
+ 	 .vals = { 0x00000000, 0xBF99999A, 0x40000000,
+ 		   0x40466666, 0x40866666, 0xBF99999A,
+ 		   0xBF99999A, 0x00000000, 0x00000000,
+ 		   0x40800000, 0x40800000	     }
+ 	},
+ 	{ .name = "Jazz",
+ 	 .vals = { 0x00000000, 0x00000000, 0x00000000,
+ 		   0x3F8CCCCD, 0x40800000, 0x40800000,
+ 		   0x40800000, 0x00000000, 0x3F8CCCCD,
+ 		   0x40466666, 0x40466666	     }
+ 	},
+ 	{ .name = "New Age",
+ 	 .vals = { 0x00000000, 0x00000000, 0x40000000,
+ 		   0x40000000, 0x00000000, 0x00000000,
+ 		   0x00000000, 0x3F8CCCCD, 0x40000000,
+ 		   0x40000000, 0x40000000	     }
+ 	},
+ 	{ .name = "Pop",
+ 	 .vals = { 0x00000000, 0xBFCCCCCD, 0x00000000,
+ 		   0x40000000, 0x40000000, 0x00000000,
+ 		   0xBF99999A, 0xBF99999A, 0x00000000,
+ 		   0x40466666, 0x40C00000	     }
+ 	},
+ 	{ .name = "Rock",
+ 	 .vals = { 0x00000000, 0xBF99999A, 0xBF99999A,
+ 		   0x3F8CCCCD, 0x40000000, 0xBF99999A,
+ 		   0xBF99999A, 0x00000000, 0x00000000,
+ 		   0x40800000, 0x40800000	     }
+ 	},
+ 	{ .name = "Vocal",
+ 	 .vals = { 0x00000000, 0xC0000000, 0xBF99999A,
+ 		   0xBF99999A, 0x00000000, 0x40466666,
+ 		   0x40800000, 0x40466666, 0x00000000,
+ 		   0x00000000, 0x3F8CCCCD	     }
+ 	}
+ };
+ 
+ /* DSP command sequences for ca0132_alt_select_out */
+ #define ALT_OUT_SET_MAX_COMMANDS 9 /* Max number of commands in sequence */
+ struct ca0132_alt_out_set {
+ 	char *name; /*preset name*/
+ 	unsigned char commands;
+ 	unsigned int mids[ALT_OUT_SET_MAX_COMMANDS];
+ 	unsigned int reqs[ALT_OUT_SET_MAX_COMMANDS];
+ 	unsigned int vals[ALT_OUT_SET_MAX_COMMANDS];
+ };
+ 
+ static const struct ca0132_alt_out_set alt_out_presets[] = {
+ 	{ .name = "Line Out",
+ 	  .commands = 7,
+ 	  .mids = { 0x96, 0x96, 0x96, 0x8F,
+ 		    0x96, 0x96, 0x96 },
+ 	  .reqs = { 0x19, 0x17, 0x18, 0x01,
+ 		    0x1F, 0x15, 0x3A },
+ 	  .vals = { 0x3F000000, 0x42A00000, 0x00000000,
+ 		    0x00000000, 0x00000000, 0x00000000,
+ 		    0x00000000 }
+ 	},
+ 	{ .name = "Headphone",
+ 	  .commands = 7,
+ 	  .mids = { 0x96, 0x96, 0x96, 0x8F,
+ 		    0x96, 0x96, 0x96 },
+ 	  .reqs = { 0x19, 0x17, 0x18, 0x01,
+ 		    0x1F, 0x15, 0x3A },
+ 	  .vals = { 0x3F000000, 0x42A00000, 0x00000000,
+ 		    0x00000000, 0x00000000, 0x00000000,
+ 		    0x00000000 }
+ 	},
+ 	{ .name = "Surround",
+ 	  .commands = 8,
+ 	  .mids = { 0x96, 0x8F, 0x96, 0x96,
+ 		    0x96, 0x96, 0x96, 0x96 },
+ 	  .reqs = { 0x18, 0x01, 0x1F, 0x15,
+ 		    0x3A, 0x1A, 0x1B, 0x1C },
+ 	  .vals = { 0x00000000, 0x00000000, 0x00000000,
+ 		    0x00000000, 0x00000000, 0x00000000,
+ 		    0x00000000, 0x00000000 }
+ 	}
+ };
+ 
+ /*
+  * DSP volume setting structs. Req 1 is left volume, req 2 is right volume,
+  * and I don't know what the third req is, but it's always zero. I assume it's
+  * some sort of update or set command to tell the DSP there's new volume info.
+  */
+ #define DSP_VOL_OUT 0
+ #define DSP_VOL_IN  1
+ 
+ struct ct_dsp_volume_ctl {
+ 	hda_nid_t vnid;
+ 	int mid; /* module ID*/
+ 	unsigned int reqs[3]; /* scp req ID */
+ };
+ 
+ static struct ct_dsp_volume_ctl ca0132_alt_vol_ctls[] = {
+ 	{ .vnid = VNID_SPK,
+ 	  .mid = 0x32,
+ 	  .reqs = {3, 4, 2}
+ 	},
+ 	{ .vnid = VNID_MIC,
+ 	  .mid = 0x37,
+ 	  .reqs = {2, 3, 1}
+ 	}
+ };
+ 
++>>>>>>> 47cdf76e44e8 (ALSA: hda/ca0132: Add new control changes for SBZ + R3Di)
  enum hda_cmd_vendor_io {
  	/* for DspIO node */
  	VENDOR_DSPIO_SCP_WRITE_DATA_LOW      = 0x000,
@@@ -753,6 -945,17 +930,20 @@@ struct ca0132_spec 
  	long effects_switch[EFFECTS_COUNT];
  	long voicefx_val;
  	long cur_mic_boost;
++<<<<<<< HEAD
++=======
+ 	/* ca0132_alt control related values */
+ 	unsigned char in_enum_val;
+ 	unsigned char out_enum_val;
+ 	unsigned char mic_boost_enum_val;
+ 	unsigned char smart_volume_setting;
+ 	long fx_ctl_val[EFFECT_LEVEL_SLIDERS];
+ 	long xbass_xover_freq;
+ 	long eq_preset_val;
+ 	unsigned int tlv[4];
+ 	struct hda_vmaster_mute_hook vmaster_mute;
+ 
++>>>>>>> 47cdf76e44e8 (ALSA: hda/ca0132: Add new control changes for SBZ + R3Di)
  
  	struct hda_codec *codec;
  	struct delayed_work unsol_hp_work;
@@@ -761,6 -964,25 +952,28 @@@
  #ifdef ENABLE_TUNING_CONTROLS
  	long cur_ctl_vals[TUNING_CTLS_COUNT];
  #endif
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Sound Blaster Z PCI region 2 iomem, used for input and output
+ 	 * switching, and other unknown commands.
+ 	 */
+ 	void __iomem *mem_base;
+ 
+ 	/*
+ 	 * Whether or not to use the alt functions like alt_select_out,
+ 	 * alt_select_in, etc. Only used on desktop codecs for now, because of
+ 	 * surround sound support.
+ 	 */
+ 	bool use_alt_functions;
+ 
+ 	/*
+ 	 * Whether or not to use alt controls:	volume effect sliders, EQ
+ 	 * presets, smart volume presets, and new control names with FX prefix.
+ 	 * Renames PlayEnhancement and CrystalVoice too.
+ 	 */
+ 	bool use_alt_controls;
++>>>>>>> 47cdf76e44e8 (ALSA: hda/ca0132: Add new control changes for SBZ + R3Di)
  };
  
  /*
@@@ -2910,7 -3425,86 +3123,88 @@@ static unsigned int ca0132_capture_pcm_
  #define CA0132_CODEC_MUTE(xname, nid, dir) \
  	CA0132_CODEC_MUTE_MONO(xname, nid, 3, dir)
  
++<<<<<<< HEAD
 +/* The followings are for tuning of products */
++=======
+ /* lookup tables */
+ /*
+  * Lookup table with decibel values for the DSP. When volume is changed in
+  * Windows, the DSP is also sent the dB value in floating point. In Windows,
+  * these values have decimal points, probably because the Windows driver
+  * actually uses floating point. We can't here, so I made a lookup table of
+  * values -90 to 9. -90 is the lowest decibel value for both the ADC's and the
+  * DAC's, and 9 is the maximum.
+  */
+ static const unsigned int float_vol_db_lookup[] = {
+ 0xC2B40000, 0xC2B20000, 0xC2B00000, 0xC2AE0000, 0xC2AC0000, 0xC2AA0000,
+ 0xC2A80000, 0xC2A60000, 0xC2A40000, 0xC2A20000, 0xC2A00000, 0xC29E0000,
+ 0xC29C0000, 0xC29A0000, 0xC2980000, 0xC2960000, 0xC2940000, 0xC2920000,
+ 0xC2900000, 0xC28E0000, 0xC28C0000, 0xC28A0000, 0xC2880000, 0xC2860000,
+ 0xC2840000, 0xC2820000, 0xC2800000, 0xC27C0000, 0xC2780000, 0xC2740000,
+ 0xC2700000, 0xC26C0000, 0xC2680000, 0xC2640000, 0xC2600000, 0xC25C0000,
+ 0xC2580000, 0xC2540000, 0xC2500000, 0xC24C0000, 0xC2480000, 0xC2440000,
+ 0xC2400000, 0xC23C0000, 0xC2380000, 0xC2340000, 0xC2300000, 0xC22C0000,
+ 0xC2280000, 0xC2240000, 0xC2200000, 0xC21C0000, 0xC2180000, 0xC2140000,
+ 0xC2100000, 0xC20C0000, 0xC2080000, 0xC2040000, 0xC2000000, 0xC1F80000,
+ 0xC1F00000, 0xC1E80000, 0xC1E00000, 0xC1D80000, 0xC1D00000, 0xC1C80000,
+ 0xC1C00000, 0xC1B80000, 0xC1B00000, 0xC1A80000, 0xC1A00000, 0xC1980000,
+ 0xC1900000, 0xC1880000, 0xC1800000, 0xC1700000, 0xC1600000, 0xC1500000,
+ 0xC1400000, 0xC1300000, 0xC1200000, 0xC1100000, 0xC1000000, 0xC0E00000,
+ 0xC0C00000, 0xC0A00000, 0xC0800000, 0xC0400000, 0xC0000000, 0xBF800000,
+ 0x00000000, 0x3F800000, 0x40000000, 0x40400000, 0x40800000, 0x40A00000,
+ 0x40C00000, 0x40E00000, 0x41000000, 0x41100000
+ };
+ 
+ /*
+  * This table counts from float 0 to 1 in increments of .01, which is
+  * useful for a few different sliders.
+  */
+ static const unsigned int float_zero_to_one_lookup[] = {
+ 0x00000000, 0x3C23D70A, 0x3CA3D70A, 0x3CF5C28F, 0x3D23D70A, 0x3D4CCCCD,
+ 0x3D75C28F, 0x3D8F5C29, 0x3DA3D70A, 0x3DB851EC, 0x3DCCCCCD, 0x3DE147AE,
+ 0x3DF5C28F, 0x3E051EB8, 0x3E0F5C29, 0x3E19999A, 0x3E23D70A, 0x3E2E147B,
+ 0x3E3851EC, 0x3E428F5C, 0x3E4CCCCD, 0x3E570A3D, 0x3E6147AE, 0x3E6B851F,
+ 0x3E75C28F, 0x3E800000, 0x3E851EB8, 0x3E8A3D71, 0x3E8F5C29, 0x3E947AE1,
+ 0x3E99999A, 0x3E9EB852, 0x3EA3D70A, 0x3EA8F5C3, 0x3EAE147B, 0x3EB33333,
+ 0x3EB851EC, 0x3EBD70A4, 0x3EC28F5C, 0x3EC7AE14, 0x3ECCCCCD, 0x3ED1EB85,
+ 0x3ED70A3D, 0x3EDC28F6, 0x3EE147AE, 0x3EE66666, 0x3EEB851F, 0x3EF0A3D7,
+ 0x3EF5C28F, 0x3EFAE148, 0x3F000000, 0x3F028F5C, 0x3F051EB8, 0x3F07AE14,
+ 0x3F0A3D71, 0x3F0CCCCD, 0x3F0F5C29, 0x3F11EB85, 0x3F147AE1, 0x3F170A3D,
+ 0x3F19999A, 0x3F1C28F6, 0x3F1EB852, 0x3F2147AE, 0x3F23D70A, 0x3F266666,
+ 0x3F28F5C3, 0x3F2B851F, 0x3F2E147B, 0x3F30A3D7, 0x3F333333, 0x3F35C28F,
+ 0x3F3851EC, 0x3F3AE148, 0x3F3D70A4, 0x3F400000, 0x3F428F5C, 0x3F451EB8,
+ 0x3F47AE14, 0x3F4A3D71, 0x3F4CCCCD, 0x3F4F5C29, 0x3F51EB85, 0x3F547AE1,
+ 0x3F570A3D, 0x3F59999A, 0x3F5C28F6, 0x3F5EB852, 0x3F6147AE, 0x3F63D70A,
+ 0x3F666666, 0x3F68F5C3, 0x3F6B851F, 0x3F6E147B, 0x3F70A3D7, 0x3F733333,
+ 0x3F75C28F, 0x3F7851EC, 0x3F7AE148, 0x3F7D70A4, 0x3F800000
+ };
+ 
+ /*
+  * This table counts from float 10 to 1000, which is the range of the x-bass
+  * crossover slider in Windows.
+  */
+ static const unsigned int float_xbass_xover_lookup[] = {
+ 0x41200000, 0x41A00000, 0x41F00000, 0x42200000, 0x42480000, 0x42700000,
+ 0x428C0000, 0x42A00000, 0x42B40000, 0x42C80000, 0x42DC0000, 0x42F00000,
+ 0x43020000, 0x430C0000, 0x43160000, 0x43200000, 0x432A0000, 0x43340000,
+ 0x433E0000, 0x43480000, 0x43520000, 0x435C0000, 0x43660000, 0x43700000,
+ 0x437A0000, 0x43820000, 0x43870000, 0x438C0000, 0x43910000, 0x43960000,
+ 0x439B0000, 0x43A00000, 0x43A50000, 0x43AA0000, 0x43AF0000, 0x43B40000,
+ 0x43B90000, 0x43BE0000, 0x43C30000, 0x43C80000, 0x43CD0000, 0x43D20000,
+ 0x43D70000, 0x43DC0000, 0x43E10000, 0x43E60000, 0x43EB0000, 0x43F00000,
+ 0x43F50000, 0x43FA0000, 0x43FF0000, 0x44020000, 0x44048000, 0x44070000,
+ 0x44098000, 0x440C0000, 0x440E8000, 0x44110000, 0x44138000, 0x44160000,
+ 0x44188000, 0x441B0000, 0x441D8000, 0x44200000, 0x44228000, 0x44250000,
+ 0x44278000, 0x442A0000, 0x442C8000, 0x442F0000, 0x44318000, 0x44340000,
+ 0x44368000, 0x44390000, 0x443B8000, 0x443E0000, 0x44408000, 0x44430000,
+ 0x44458000, 0x44480000, 0x444A8000, 0x444D0000, 0x444F8000, 0x44520000,
+ 0x44548000, 0x44570000, 0x44598000, 0x445C0000, 0x445E8000, 0x44610000,
+ 0x44638000, 0x44660000, 0x44688000, 0x446B0000, 0x446D8000, 0x44700000,
+ 0x44728000, 0x44750000, 0x44778000, 0x447A0000
+ };
+ 
+ /* The following are for tuning of products */
++>>>>>>> 47cdf76e44e8 (ALSA: hda/ca0132: Add new control changes for SBZ + R3Di)
  #ifdef ENABLE_TUNING_CONTROLS
  
  static unsigned int voice_focus_vals_lookup[] = {
@@@ -3294,82 -3888,347 +3588,89 @@@ exit
  	return err < 0 ? err : 0;
  }
  
 +static void ca0132_unsol_hp_delayed(struct work_struct *work)
 +{
 +	struct ca0132_spec *spec = container_of(
 +		to_delayed_work(work), struct ca0132_spec, unsol_hp_work);
 +	struct hda_jack_tbl *jack;
 +
 +	ca0132_select_out(spec->codec);
 +	jack = snd_hda_jack_tbl_get(spec->codec, spec->unsol_tag_hp);
 +	if (jack) {
 +		jack->block_report = 0;
 +		snd_hda_jack_report_sync(spec->codec);
 +	}
 +}
 +
 +static void ca0132_set_dmic(struct hda_codec *codec, int enable);
 +static int ca0132_mic_boost_set(struct hda_codec *codec, long val);
 +static int ca0132_effects_set(struct hda_codec *codec, hda_nid_t nid, long val);
++<<<<<<< HEAD
++=======
++static void resume_mic1(struct hda_codec *codec, unsigned int oldval);
++static int stop_mic1(struct hda_codec *codec);
++static int ca0132_cvoice_switch_set(struct hda_codec *codec);
++static int ca0132_alt_mic_boost_set(struct hda_codec *codec, long val);
++>>>>>>> 47cdf76e44e8 (ALSA: hda/ca0132: Add new control changes for SBZ + R3Di)
 +
  /*
 - * This function behaves similarly to the ca0132_select_out funciton above,
 - * except with a few differences. It adds the ability to select the current
 - * output with an enumerated control "output source" if the auto detect
 - * mute switch is set to off. If the auto detect mute switch is enabled, it
 - * will detect either headphone or lineout(SPEAKER_OUT) from jack detection.
 - * It also adds the ability to auto-detect the front headphone port. The only
 - * way to select surround is to disable auto detect, and set Surround with the
 - * enumerated control.
 + * Select the active VIP source
   */
 -static int ca0132_alt_select_out(struct hda_codec *codec)
 +static int ca0132_set_vipsource(struct hda_codec *codec, int val)
  {
  	struct ca0132_spec *spec = codec->spec;
 -	unsigned int pin_ctl;
 -	int jack_present;
 -	int auto_jack;
 -	unsigned int i;
  	unsigned int tmp;
 -	int err;
 -	/* Default Headphone is rear headphone */
 -	hda_nid_t headphone_nid = spec->out_pins[1];
  
 -	codec_dbg(codec, "%s\n", __func__);
 +	if (spec->dsp_state != DSP_DOWNLOADED)
 +		return 0;
  
 -	snd_hda_power_up_pm(codec);
 +	/* if CrystalVoice if off, vipsource should be 0 */
 +	if (!spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] ||
 +	    (val == 0)) {
 +		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, 0);
 +		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
 +		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
 +		if (spec->cur_mic_type == DIGITAL_MIC)
 +			tmp = FLOAT_TWO;
 +		else
 +			tmp = FLOAT_ONE;
 +		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
 +		tmp = FLOAT_ZERO;
 +		dspio_set_uint_param(codec, 0x80, 0x05, tmp);
 +	} else {
 +		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_16_000);
 +		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_16_000);
 +		if (spec->cur_mic_type == DIGITAL_MIC)
 +			tmp = FLOAT_TWO;
 +		else
 +			tmp = FLOAT_ONE;
 +		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
 +		tmp = FLOAT_ONE;
 +		dspio_set_uint_param(codec, 0x80, 0x05, tmp);
 +		msleep(20);
 +		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, val);
 +	}
  
 -	auto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
 +	return 1;
 +}
  
 -	/*
 -	 * If headphone rear or front is plugged in, set to headphone.
 -	 * If neither is plugged in, set to rear line out. Only if
 -	 * hp/speaker auto detect is enabled.
 -	 */
 -	if (auto_jack) {
 -		jack_present = snd_hda_jack_detect(codec, spec->unsol_tag_hp) ||
 -			   snd_hda_jack_detect(codec, spec->unsol_tag_front_hp);
 +/*
 + * Select the active microphone.
 + * If autodetect is enabled, mic will be selected based on jack detection.
 + * If jack inserted, ext.mic will be selected, else built-in mic
 + * If autodetect is disabled, mic will be selected based on selection.
 + */
 +static int ca0132_select_mic(struct hda_codec *codec)
 +{
 +	struct ca0132_spec *spec = codec->spec;
 +	int jack_present;
 +	int auto_jack;
  
 -		if (jack_present)
 -			spec->cur_out_type = HEADPHONE_OUT;
 -		else
 -			spec->cur_out_type = SPEAKER_OUT;
 -	} else
 -		spec->cur_out_type = spec->out_enum_val;
 +	codec_dbg(codec, "ca0132_select_mic\n");
  
 -	/* Begin DSP output switch */
 -	tmp = FLOAT_ONE;
 -	err = dspio_set_uint_param(codec, 0x96, 0x3A, tmp);
 -	if (err < 0)
 -		goto exit;
 +	snd_hda_power_up_pm(codec);
  
 -	switch (spec->cur_out_type) {
 -	case SPEAKER_OUT:
 -		codec_dbg(codec, "%s speaker\n", __func__);
 -		/*speaker out config*/
 -		switch (spec->quirk) {
 -		case QUIRK_SBZ:
 -			writew(0x0007, spec->mem_base + 0x320);
 -			writew(0x0104, spec->mem_base + 0x320);
 -			writew(0x0101, spec->mem_base + 0x320);
 -			chipio_set_control_param(codec, 0x0D, 0x18);
 -			break;
 -		case QUIRK_R3DI:
 -			chipio_set_control_param(codec, 0x0D, 0x24);
 -			r3di_gpio_out_set(codec, R3DI_LINE_OUT);
 -			break;
 -		}
 -
 -		/* disable headphone node */
 -		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,
 -					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
 -		snd_hda_set_pin_ctl(codec, spec->out_pins[1],
 -				    pin_ctl & ~PIN_HP);
 -		/* enable line-out node */
 -		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
 -				AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
 -		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
 -				    pin_ctl | PIN_OUT);
 -		/* Enable EAPD */
 -		snd_hda_codec_write(codec, spec->out_pins[0], 0,
 -			AC_VERB_SET_EAPD_BTLENABLE, 0x01);
 -
 -		/* If PlayEnhancement is enabled, set different source */
 -		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
 -			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
 -		else
 -			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_EIGHT);
 -		break;
 -	case HEADPHONE_OUT:
 -		codec_dbg(codec, "%s hp\n", __func__);
 -		/* Headphone out config*/
 -		switch (spec->quirk) {
 -		case QUIRK_SBZ:
 -			writew(0x0107, spec->mem_base + 0x320);
 -			writew(0x0104, spec->mem_base + 0x320);
 -			writew(0x0001, spec->mem_base + 0x320);
 -			chipio_set_control_param(codec, 0x0D, 0x12);
 -			break;
 -		case QUIRK_R3DI:
 -			chipio_set_control_param(codec, 0x0D, 0x21);
 -			r3di_gpio_out_set(codec, R3DI_HEADPHONE_OUT);
 -			break;
 -		}
 -
 -		snd_hda_codec_write(codec, spec->out_pins[0], 0,
 -			AC_VERB_SET_EAPD_BTLENABLE, 0x00);
 -
 -		/* disable speaker*/
 -		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
 -					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
 -		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
 -				pin_ctl & ~PIN_HP);
 -
 -		/* enable headphone, either front or rear */
 -
 -		if (snd_hda_jack_detect(codec, spec->unsol_tag_front_hp))
 -			headphone_nid = spec->out_pins[2];
 -		else if (snd_hda_jack_detect(codec, spec->unsol_tag_hp))
 -			headphone_nid = spec->out_pins[1];
 -
 -		pin_ctl = snd_hda_codec_read(codec, headphone_nid, 0,
 -					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
 -		snd_hda_set_pin_ctl(codec, headphone_nid,
 -				    pin_ctl | PIN_HP);
 -
 -		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
 -			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
 -		else
 -			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ZERO);
 -		break;
 -	case SURROUND_OUT:
 -		codec_dbg(codec, "%s surround\n", __func__);
 -		/* Surround out config*/
 -		switch (spec->quirk) {
 -		case QUIRK_SBZ:
 -			writew(0x0007, spec->mem_base + 0x320);
 -			writew(0x0104, spec->mem_base + 0x320);
 -			writew(0x0101, spec->mem_base + 0x320);
 -			chipio_set_control_param(codec, 0x0D, 0x18);
 -			break;
 -		case QUIRK_R3DI:
 -			chipio_set_control_param(codec, 0x0D, 0x24);
 -			r3di_gpio_out_set(codec, R3DI_LINE_OUT);
 -			break;
 -		}
 -		/* enable line out node */
 -		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
 -				AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
 -		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
 -						pin_ctl | PIN_OUT);
 -		/* Disable headphone out */
 -		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,
 -					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
 -		snd_hda_set_pin_ctl(codec, spec->out_pins[1],
 -				    pin_ctl & ~PIN_HP);
 -		/* Enable EAPD on line out */
 -		snd_hda_codec_write(codec, spec->out_pins[0], 0,
 -			AC_VERB_SET_EAPD_BTLENABLE, 0x01);
 -		/* enable center/lfe out node */
 -		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[2], 0,
 -					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
 -		snd_hda_set_pin_ctl(codec, spec->out_pins[2],
 -				    pin_ctl | PIN_OUT);
 -		/* Now set rear surround node as out. */
 -		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[3], 0,
 -					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
 -		snd_hda_set_pin_ctl(codec, spec->out_pins[3],
 -				    pin_ctl | PIN_OUT);
 -
 -		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
 -			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
 -		else
 -			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_EIGHT);
 -		break;
 -	}
 -
 -	/* run through the output dsp commands for line-out */
 -	for (i = 0; i < alt_out_presets[spec->cur_out_type].commands; i++) {
 -		err = dspio_set_uint_param(codec,
 -		alt_out_presets[spec->cur_out_type].mids[i],
 -		alt_out_presets[spec->cur_out_type].reqs[i],
 -		alt_out_presets[spec->cur_out_type].vals[i]);
 -
 -		if (err < 0)
 -			goto exit;
 -	}
 -
 -exit:
 -	snd_hda_power_down_pm(codec);
 -
 -	return err < 0 ? err : 0;
 -}
 -
 -static void ca0132_unsol_hp_delayed(struct work_struct *work)
 -{
 -	struct ca0132_spec *spec = container_of(
 -		to_delayed_work(work), struct ca0132_spec, unsol_hp_work);
 -	struct hda_jack_tbl *jack;
 -
 -	if (spec->use_alt_functions)
 -		ca0132_alt_select_out(spec->codec);
 -	else
 -		ca0132_select_out(spec->codec);
 -
 -	jack = snd_hda_jack_tbl_get(spec->codec, spec->unsol_tag_hp);
 -	if (jack) {
 -		jack->block_report = 0;
 -		snd_hda_jack_report_sync(spec->codec);
 -	}
 -}
 -
 -static void ca0132_set_dmic(struct hda_codec *codec, int enable);
 -static int ca0132_mic_boost_set(struct hda_codec *codec, long val);
 -static int ca0132_effects_set(struct hda_codec *codec, hda_nid_t nid, long val);
 -static void resume_mic1(struct hda_codec *codec, unsigned int oldval);
 -static int stop_mic1(struct hda_codec *codec);
 -static int ca0132_cvoice_switch_set(struct hda_codec *codec);
 -static int ca0132_alt_mic_boost_set(struct hda_codec *codec, long val);
 -
 -/*
 - * Select the active VIP source
 - */
 -static int ca0132_set_vipsource(struct hda_codec *codec, int val)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -	unsigned int tmp;
 -
 -	if (spec->dsp_state != DSP_DOWNLOADED)
 -		return 0;
 -
 -	/* if CrystalVoice if off, vipsource should be 0 */
 -	if (!spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] ||
 -	    (val == 0)) {
 -		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, 0);
 -		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
 -		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
 -		if (spec->cur_mic_type == DIGITAL_MIC)
 -			tmp = FLOAT_TWO;
 -		else
 -			tmp = FLOAT_ONE;
 -		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
 -		tmp = FLOAT_ZERO;
 -		dspio_set_uint_param(codec, 0x80, 0x05, tmp);
 -	} else {
 -		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_16_000);
 -		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_16_000);
 -		if (spec->cur_mic_type == DIGITAL_MIC)
 -			tmp = FLOAT_TWO;
 -		else
 -			tmp = FLOAT_ONE;
 -		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
 -		tmp = FLOAT_ONE;
 -		dspio_set_uint_param(codec, 0x80, 0x05, tmp);
 -		msleep(20);
 -		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, val);
 -	}
 -
 -	return 1;
 -}
 -
 -static int ca0132_alt_set_vipsource(struct hda_codec *codec, int val)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -	unsigned int tmp;
 -
 -	if (spec->dsp_state != DSP_DOWNLOADED)
 -		return 0;
 -
 -	codec_dbg(codec, "%s\n", __func__);
 -
 -	chipio_set_stream_control(codec, 0x03, 0);
 -	chipio_set_stream_control(codec, 0x04, 0);
 -
 -	/* if CrystalVoice is off, vipsource should be 0 */
 -	if (!spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] ||
 -	    (val == 0) || spec->in_enum_val == REAR_LINE_IN) {
 -		codec_dbg(codec, "%s: off.", __func__);
 -		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, 0);
 -
 -		tmp = FLOAT_ZERO;
 -		dspio_set_uint_param(codec, 0x80, 0x05, tmp);
 -
 -		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
 -		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
 -		if (spec->quirk == QUIRK_R3DI)
 -			chipio_set_conn_rate(codec, 0x0F, SR_96_000);
 -
 -
 -		if (spec->in_enum_val == REAR_LINE_IN)
 -			tmp = FLOAT_ZERO;
 -		else {
 -			if (spec->quirk == QUIRK_SBZ)
 -				tmp = FLOAT_THREE;
 -			else
 -				tmp = FLOAT_ONE;
 -		}
 -
 -		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
 -
 -	} else {
 -		codec_dbg(codec, "%s: on.", __func__);
 -		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_16_000);
 -		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_16_000);
 -		if (spec->quirk == QUIRK_R3DI)
 -			chipio_set_conn_rate(codec, 0x0F, SR_16_000);
 -
 -		if (spec->effects_switch[VOICE_FOCUS - EFFECT_START_NID])
 -			tmp = FLOAT_TWO;
 -		else
 -			tmp = FLOAT_ONE;
 -		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
 -
 -		tmp = FLOAT_ONE;
 -		dspio_set_uint_param(codec, 0x80, 0x05, tmp);
 -
 -		msleep(20);
 -		chipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, val);
 -	}
 -
 -	chipio_set_stream_control(codec, 0x03, 1);
 -	chipio_set_stream_control(codec, 0x04, 1);
 -
 -	return 1;
 -}
 -
 -/*
 - * Select the active microphone.
 - * If autodetect is enabled, mic will be selected based on jack detection.
 - * If jack inserted, ext.mic will be selected, else built-in mic
 - * If autodetect is disabled, mic will be selected based on selection.
 - */
 -static int ca0132_select_mic(struct hda_codec *codec)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -	int jack_present;
 -	int auto_jack;
 -
 -	codec_dbg(codec, "ca0132_select_mic\n");
 -
 -	snd_hda_power_up_pm(codec);
 -
 -	auto_jack = spec->vnode_lswitch[VNID_AMIC1_ASEL - VNODE_START_NID];
 +	auto_jack = spec->vnode_lswitch[VNID_AMIC1_ASEL - VNODE_START_NID];
  
  	if (auto_jack)
  		jack_present = snd_hda_jack_detect(codec, spec->unsol_tag_amic1);
@@@ -3406,6 -4265,125 +3707,128 @@@
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Select the active input.
+  * Mic detection isn't used, because it's kind of pointless on the SBZ.
+  * The front mic has no jack-detection, so the only way to switch to it
+  * is to do it manually in alsamixer.
+  */
+ static int ca0132_alt_select_in(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	codec_dbg(codec, "%s\n", __func__);
+ 
+ 	snd_hda_power_up_pm(codec);
+ 
+ 	chipio_set_stream_control(codec, 0x03, 0);
+ 	chipio_set_stream_control(codec, 0x04, 0);
+ 
+ 	spec->cur_mic_type = spec->in_enum_val;
+ 
+ 	switch (spec->cur_mic_type) {
+ 	case REAR_MIC:
+ 		switch (spec->quirk) {
+ 		case QUIRK_SBZ:
+ 			writew(0x0000, spec->mem_base + 0x320);
+ 			tmp = FLOAT_THREE;
+ 			break;
+ 		case QUIRK_R3DI:
+ 			r3di_gpio_mic_set(codec, R3DI_REAR_MIC);
+ 			tmp = FLOAT_ONE;
+ 			break;
+ 		default:
+ 			tmp = FLOAT_ONE;
+ 			break;
+ 		}
+ 
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 		if (spec->quirk == QUIRK_R3DI)
+ 			chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 
+ 		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 		chipio_set_stream_control(codec, 0x03, 1);
+ 		chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 		if (spec->quirk == QUIRK_SBZ) {
+ 			chipio_write(codec, 0x18B098, 0x0000000C);
+ 			chipio_write(codec, 0x18B09C, 0x0000000C);
+ 		}
+ 		ca0132_alt_mic_boost_set(codec, spec->mic_boost_enum_val);
+ 		break;
+ 	case REAR_LINE_IN:
+ 		ca0132_mic_boost_set(codec, 0);
+ 		switch (spec->quirk) {
+ 		case QUIRK_SBZ:
+ 			writew(0x0000, spec->mem_base + 0x320);
+ 			break;
+ 		case QUIRK_R3DI:
+ 			r3di_gpio_mic_set(codec, R3DI_REAR_MIC);
+ 			break;
+ 		}
+ 
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 		if (spec->quirk == QUIRK_R3DI)
+ 			chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 
+ 		tmp = FLOAT_ZERO;
+ 		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 		if (spec->quirk == QUIRK_SBZ) {
+ 			chipio_write(codec, 0x18B098, 0x00000000);
+ 			chipio_write(codec, 0x18B09C, 0x00000000);
+ 		}
+ 
+ 		chipio_set_stream_control(codec, 0x03, 1);
+ 		chipio_set_stream_control(codec, 0x04, 1);
+ 		break;
+ 	case FRONT_MIC:
+ 		switch (spec->quirk) {
+ 		case QUIRK_SBZ:
+ 			writew(0x0100, spec->mem_base + 0x320);
+ 			writew(0x0005, spec->mem_base + 0x320);
+ 			tmp = FLOAT_THREE;
+ 			break;
+ 		case QUIRK_R3DI:
+ 			r3di_gpio_mic_set(codec, R3DI_FRONT_MIC);
+ 			tmp = FLOAT_ONE;
+ 			break;
+ 		default:
+ 			tmp = FLOAT_ONE;
+ 			break;
+ 		}
+ 
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 		chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 		if (spec->quirk == QUIRK_R3DI)
+ 			chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 
+ 		dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 		chipio_set_stream_control(codec, 0x03, 1);
+ 		chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 		if (spec->quirk == QUIRK_SBZ) {
+ 			chipio_write(codec, 0x18B098, 0x0000000C);
+ 			chipio_write(codec, 0x18B09C, 0x000000CC);
+ 		}
+ 		ca0132_alt_mic_boost_set(codec, spec->mic_boost_enum_val);
+ 		break;
+ 	}
+ 	ca0132_cvoice_switch_set(codec);
+ 
+ 	snd_hda_power_down_pm(codec);
+ 	return 0;
+ 
+ }
+ 
+ /*
++>>>>>>> 47cdf76e44e8 (ALSA: hda/ca0132: Add new control changes for SBZ + R3Di)
   * Check if VNODE settings take effect immediately.
   */
  static bool ca0132_is_vnode_effective(struct hda_codec *codec,
@@@ -3712,27 -4793,415 +4185,418 @@@ static int ca0132_alt_xbass_xover_slide
  	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
  	struct ca0132_spec *spec = codec->spec;
  	hda_nid_t nid = get_amp_nid(kcontrol);
- 	int ch = get_amp_channels(kcontrol);
  	long *valp = ucontrol->value.integer.value;
+ 	int idx;
  
- 	/* vnode */
- 	if ((nid >= VNODE_START_NID) && (nid < VNODE_END_NID)) {
- 		if (ch & 1) {
- 			*valp = spec->vnode_lswitch[nid - VNODE_START_NID];
- 			valp++;
- 		}
- 		if (ch & 2) {
- 			*valp = spec->vnode_rswitch[nid - VNODE_START_NID];
- 			valp++;
- 		}
+ 	/* any change? */
+ 	if (spec->xbass_xover_freq == *valp)
  		return 0;
- 	}
  
- 	/* effects, include PE and CrystalVoice */
- 	if ((nid >= EFFECT_START_NID) && (nid < EFFECT_END_NID)) {
- 		*valp = spec->effects_switch[nid - EFFECT_START_NID];
- 		return 0;
- 	}
+ 	spec->xbass_xover_freq = *valp;
+ 
+ 	idx = *valp;
+ 	ca0132_alt_slider_ctl_set(codec, nid, float_xbass_xover_lookup, idx);
+ 
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_effect_slider_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	hda_nid_t nid = get_amp_nid(kcontrol);
+ 	long *valp = ucontrol->value.integer.value;
+ 	int idx;
+ 
+ 	idx = nid - EFFECT_START_NID;
+ 	/* any change? */
+ 	if (spec->fx_ctl_val[idx] == *valp)
+ 		return 0;
+ 
+ 	spec->fx_ctl_val[idx] = *valp;
+ 
+ 	idx = *valp;
+ 	ca0132_alt_slider_ctl_set(codec, nid, float_zero_to_one_lookup, idx);
+ 
+ 	return 0;
+ }
+ 
+ 
+ /*
+  * Mic Boost Enum for alternative ca0132 codecs. I didn't like that the original
+  * only has off or full 30 dB, and didn't like making a volume slider that has
+  * traditional 0-100 in alsamixer that goes in big steps. I like enum better.
+  */
+ #define MIC_BOOST_NUM_OF_STEPS 4
+ #define MIC_BOOST_ENUM_MAX_STRLEN 10
+ 
+ static int ca0132_alt_mic_boost_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	char *sfx = "dB";
+ 	char namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
+ 
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = MIC_BOOST_NUM_OF_STEPS;
+ 	if (uinfo->value.enumerated.item >= MIC_BOOST_NUM_OF_STEPS)
+ 		uinfo->value.enumerated.item = MIC_BOOST_NUM_OF_STEPS - 1;
+ 	sprintf(namestr, "%d %s", (uinfo->value.enumerated.item * 10), sfx);
+ 	strcpy(uinfo->value.enumerated.name, namestr);
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_mic_boost_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->mic_boost_enum_val;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_mic_boost_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = MIC_BOOST_NUM_OF_STEPS;
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "ca0132_alt_mic_boost: boost=%d\n",
+ 		    sel);
+ 
+ 	spec->mic_boost_enum_val = sel;
+ 
+ 	if (spec->in_enum_val != REAR_LINE_IN)
+ 		ca0132_alt_mic_boost_set(codec, spec->mic_boost_enum_val);
+ 
+ 	return 1;
+ }
+ 
+ 
++<<<<<<< HEAD
++=======
+ /*
+  * Input Select Control for alternative ca0132 codecs. This exists because
+  * front microphone has no auto-detect, and we need a way to set the rear
+  * as line-in
+  */
+ static int ca0132_alt_input_source_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = IN_SRC_NUM_OF_INPUTS;
+ 	if (uinfo->value.enumerated.item >= IN_SRC_NUM_OF_INPUTS)
+ 		uinfo->value.enumerated.item = IN_SRC_NUM_OF_INPUTS - 1;
+ 	strcpy(uinfo->value.enumerated.name,
+ 			in_src_str[uinfo->value.enumerated.item]);
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_input_source_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->in_enum_val;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_input_source_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = IN_SRC_NUM_OF_INPUTS;
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "ca0132_alt_input_select: sel=%d, preset=%s\n",
+ 		    sel, in_src_str[sel]);
+ 
+ 	spec->in_enum_val = sel;
+ 
+ 	ca0132_alt_select_in(codec);
+ 
+ 	return 1;
+ }
+ 
+ /* Sound Blaster Z Output Select Control */
+ static int ca0132_alt_output_select_get_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = NUM_OF_OUTPUTS;
+ 	if (uinfo->value.enumerated.item >= NUM_OF_OUTPUTS)
+ 		uinfo->value.enumerated.item = NUM_OF_OUTPUTS - 1;
+ 	strcpy(uinfo->value.enumerated.name,
+ 			alt_out_presets[uinfo->value.enumerated.item].name);
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_output_select_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->out_enum_val;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_output_select_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = NUM_OF_OUTPUTS;
+ 	unsigned int auto_jack;
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "ca0132_alt_output_select: sel=%d, preset=%s\n",
+ 		    sel, alt_out_presets[sel].name);
+ 
+ 	spec->out_enum_val = sel;
+ 
+ 	auto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
+ 
+ 	if (!auto_jack)
+ 		ca0132_alt_select_out(codec);
+ 
+ 	return 1;
+ }
+ 
+ /*
+  * Smart Volume output setting control. Three different settings, Normal,
+  * which takes the value from the smart volume slider. The two others, loud
+  * and night, disregard the slider value and have uneditable values.
+  */
+ #define NUM_OF_SVM_SETTINGS 3
+ static const char *out_svm_set_enum_str[3] = {"Normal", "Loud", "Night" };
+ 
+ static int ca0132_alt_svm_setting_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = NUM_OF_SVM_SETTINGS;
+ 	if (uinfo->value.enumerated.item >= NUM_OF_SVM_SETTINGS)
+ 		uinfo->value.enumerated.item = NUM_OF_SVM_SETTINGS - 1;
+ 	strcpy(uinfo->value.enumerated.name,
+ 			out_svm_set_enum_str[uinfo->value.enumerated.item]);
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_svm_setting_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->smart_volume_setting;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_svm_setting_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = NUM_OF_SVM_SETTINGS;
+ 	unsigned int idx = SMART_VOLUME - EFFECT_START_NID;
+ 	unsigned int tmp;
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "ca0132_alt_svm_setting: sel=%d, preset=%s\n",
+ 		    sel, out_svm_set_enum_str[sel]);
+ 
+ 	spec->smart_volume_setting = sel;
+ 
+ 	switch (sel) {
+ 	case 0:
+ 		tmp = FLOAT_ZERO;
+ 		break;
+ 	case 1:
+ 		tmp = FLOAT_ONE;
+ 		break;
+ 	case 2:
+ 		tmp = FLOAT_TWO;
+ 		break;
+ 	default:
+ 		tmp = FLOAT_ZERO;
+ 		break;
+ 	}
+ 	/* Req 2 is the Smart Volume Setting req. */
+ 	dspio_set_uint_param(codec, ca0132_effects[idx].mid,
+ 			ca0132_effects[idx].reqs[2], tmp);
+ 	return 1;
+ }
+ 
+ /* Sound Blaster Z EQ preset controls */
+ static int ca0132_alt_eq_preset_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	unsigned int items = sizeof(ca0132_alt_eq_presets)
+ 				/ sizeof(struct ct_eq_preset);
+ 
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = items;
+ 	if (uinfo->value.enumerated.item >= items)
+ 		uinfo->value.enumerated.item = items - 1;
+ 	strcpy(uinfo->value.enumerated.name,
+ 		ca0132_alt_eq_presets[uinfo->value.enumerated.item].name);
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_eq_preset_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->eq_preset_val;
+ 	return 0;
+ }
+ 
+ static int ca0132_alt_eq_preset_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int i, err = 0;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 	unsigned int items = sizeof(ca0132_alt_eq_presets)
+ 				/ sizeof(struct ct_eq_preset);
+ 
+ 	if (sel >= items)
+ 		return 0;
+ 
+ 	codec_dbg(codec, "%s: sel=%d, preset=%s\n", __func__, sel,
+ 			ca0132_alt_eq_presets[sel].name);
+ 	/*
+ 	 * Idx 0 is default.
+ 	 * Default needs to qualify with CrystalVoice state.
+ 	 */
+ 	for (i = 0; i < EQ_PRESET_MAX_PARAM_COUNT; i++) {
+ 		err = dspio_set_uint_param(codec, ca0132_alt_eq_enum.mid,
+ 				ca0132_alt_eq_enum.reqs[i],
+ 				ca0132_alt_eq_presets[sel].vals[i]);
+ 		if (err < 0)
+ 			break;
+ 	}
+ 
+ 	if (err >= 0)
+ 		spec->eq_preset_val = sel;
+ 
+ 	return 1;
+ }
+ 
++>>>>>>> 47cdf76e44e8 (ALSA: hda/ca0132: Add new control changes for SBZ + R3Di)
+ static int ca0132_voicefx_info(struct snd_kcontrol *kcontrol,
+ 				 struct snd_ctl_elem_info *uinfo)
+ {
+ 	unsigned int items = ARRAY_SIZE(ca0132_voicefx_presets);
+ 
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+ 	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = items;
+ 	if (uinfo->value.enumerated.item >= items)
+ 		uinfo->value.enumerated.item = items - 1;
+ 	strcpy(uinfo->value.enumerated.name,
+ 	       ca0132_voicefx_presets[uinfo->value.enumerated.item].name);
+ 	return 0;
+ }
+ 
+ static int ca0132_voicefx_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	ucontrol->value.enumerated.item[0] = spec->voicefx_val;
+ 	return 0;
+ }
+ 
+ static int ca0132_voicefx_put(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int i, err = 0;
+ 	int sel = ucontrol->value.enumerated.item[0];
+ 
+ 	if (sel >= ARRAY_SIZE(ca0132_voicefx_presets))
+ 		return 0;
+ 
+ 	codec_dbg(codec, "ca0132_voicefx_put: sel=%d, preset=%s\n",
+ 		    sel, ca0132_voicefx_presets[sel].name);
+ 
+ 	/*
+ 	 * Idx 0 is default.
+ 	 * Default needs to qualify with CrystalVoice state.
+ 	 */
+ 	for (i = 0; i < VOICEFX_MAX_PARAM_COUNT; i++) {
+ 		err = dspio_set_uint_param(codec, ca0132_voicefx.mid,
+ 				ca0132_voicefx.reqs[i],
+ 				ca0132_voicefx_presets[sel].vals[i]);
+ 		if (err < 0)
+ 			break;
+ 	}
+ 
+ 	if (err >= 0) {
+ 		spec->voicefx_val = sel;
+ 		/* enable voice fx */
+ 		ca0132_voicefx_set(codec, (sel ? 1 : 0));
+ 	}
+ 
+ 	return 1;
+ }
+ 
+ static int ca0132_switch_get(struct snd_kcontrol *kcontrol,
+ 				struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
+ 	struct ca0132_spec *spec = codec->spec;
+ 	hda_nid_t nid = get_amp_nid(kcontrol);
+ 	int ch = get_amp_channels(kcontrol);
+ 	long *valp = ucontrol->value.integer.value;
+ 
+ 	/* vnode */
+ 	if ((nid >= VNODE_START_NID) && (nid < VNODE_END_NID)) {
+ 		if (ch & 1) {
+ 			*valp = spec->vnode_lswitch[nid - VNODE_START_NID];
+ 			valp++;
+ 		}
+ 		if (ch & 2) {
+ 			*valp = spec->vnode_rswitch[nid - VNODE_START_NID];
+ 			valp++;
+ 		}
+ 		return 0;
+ 	}
+ 
+ 	/* effects, include PE and CrystalVoice */
+ 	if ((nid >= EFFECT_START_NID) && (nid < EFFECT_END_NID)) {
+ 		*valp = spec->effects_switch[nid - EFFECT_START_NID];
+ 		return 0;
+ 	}
  
  	/* mic boost */
  	if (nid == spec->input_pins[0]) {
@@@ -3972,7 -5573,137 +4883,140 @@@ static int add_voicefx(struct hda_code
  	return snd_hda_ctl_add(codec, VOICEFX, snd_ctl_new1(&knew, codec));
  }
  
+ /* Create the EQ Preset control */
+ static int add_ca0132_alt_eq_presets(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO(ca0132_alt_eq_enum.name,
+ 				    EQ_PRESET_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ca0132_alt_eq_preset_info;
+ 	knew.get = ca0132_alt_eq_preset_get;
+ 	knew.put = ca0132_alt_eq_preset_put;
+ 	return snd_hda_ctl_add(codec, EQ_PRESET_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Add enumerated control for the three different settings of the smart volume
+  * output effect. Normal just uses the slider value, and loud and night are
+  * their own things that ignore that value.
+  */
+ static int ca0132_alt_add_svm_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("FX: Smart Volume Setting",
+ 				    SMART_VOLUME_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ca0132_alt_svm_setting_info;
+ 	knew.get = ca0132_alt_svm_setting_get;
+ 	knew.put = ca0132_alt_svm_setting_put;
+ 	return snd_hda_ctl_add(codec, SMART_VOLUME_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ 
+ }
+ 
+ /*
++<<<<<<< HEAD
++=======
+  * Create an Output Select enumerated control for codecs with surround
+  * out capabilities.
+  */
+ static int ca0132_alt_add_output_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("Output Select",
+ 				    OUTPUT_SOURCE_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ca0132_alt_output_select_get_info;
+ 	knew.get = ca0132_alt_output_select_get;
+ 	knew.put = ca0132_alt_output_select_put;
+ 	return snd_hda_ctl_add(codec, OUTPUT_SOURCE_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Create an Input Source enumerated control for the alternate ca0132 codecs
+  * because the front microphone has no auto-detect, and Line-in has to be set
+  * somehow.
+  */
+ static int ca0132_alt_add_input_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("Input Source",
+ 				    INPUT_SOURCE_ENUM, 1, 0, HDA_INPUT);
+ 	knew.info = ca0132_alt_input_source_info;
+ 	knew.get = ca0132_alt_input_source_get;
+ 	knew.put = ca0132_alt_input_source_put;
+ 	return snd_hda_ctl_add(codec, INPUT_SOURCE_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Add mic boost enumerated control. Switches through 0dB to 30dB. This adds
+  * more control than the original mic boost, which is either full 30dB or off.
+  */
+ static int ca0132_alt_add_mic_boost_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("Mic Boost Capture Switch",
+ 				    MIC_BOOST_ENUM, 1, 0, HDA_INPUT);
+ 	knew.info = ca0132_alt_mic_boost_info;
+ 	knew.get = ca0132_alt_mic_boost_get;
+ 	knew.put = ca0132_alt_mic_boost_put;
+ 	return snd_hda_ctl_add(codec, MIC_BOOST_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ 
+ }
+ 
+ /*
+  * Need to create slave controls for the alternate codecs that have surround
+  * capabilities.
+  */
+ static const char * const ca0132_alt_slave_pfxs[] = {
+ 	"Front", "Surround", "Center", "LFE", NULL,
+ };
+ 
+ /*
+  * Also need special channel map, because the default one is incorrect.
+  * I think this has to do with the pin for rear surround being 0x11,
+  * and the center/lfe being 0x10. Usually the pin order is the opposite.
+  */
+ const struct snd_pcm_chmap_elem ca0132_alt_chmaps[] = {
+ 	{ .channels = 2,
+ 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
+ 	{ .channels = 4,
+ 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+ 		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+ 	{ .channels = 6,
+ 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+ 		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,
+ 		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+ 	{ }
+ };
+ 
+ /* Add the correct chmap for streams with 6 channels. */
+ static void ca0132_alt_add_chmap_ctls(struct hda_codec *codec)
+ {
+ 	int err = 0;
+ 	struct hda_pcm *pcm;
+ 
+ 	list_for_each_entry(pcm, &codec->pcm_list_head, list) {
+ 		struct hda_pcm_stream *hinfo =
+ 			&pcm->stream[SNDRV_PCM_STREAM_PLAYBACK];
+ 		struct snd_pcm_chmap *chmap;
+ 		const struct snd_pcm_chmap_elem *elem;
+ 
+ 		elem = ca0132_alt_chmaps;
+ 		if (hinfo->channels_max == 6) {
+ 			err = snd_pcm_add_chmap_ctls(pcm->pcm,
+ 					SNDRV_PCM_STREAM_PLAYBACK,
+ 					elem, hinfo->channels_max, 0, &chmap);
+ 			if (err < 0)
+ 				codec_dbg(codec, "snd_pcm_add_chmap_ctls failed!");
+ 		}
+ 	}
+ }
+ 
  /*
++>>>>>>> 47cdf76e44e8 (ALSA: hda/ca0132: Add new control changes for SBZ + R3Di)
   * When changing Node IDs for Mixer Controls below, make sure to update
   * Node IDs in ca0132_config() as well.
   */
@@@ -3998,6 -5729,51 +5042,54 @@@ static struct snd_kcontrol_new ca0132_m
  	{ } /* end */
  };
  
++<<<<<<< HEAD
++=======
+ /*
+  * SBZ specific control mixer. Removes auto-detect for mic, and adds surround
+  * controls. Also sets both the Front Playback and Capture Volume controls to
+  * alt so they set the DSP's decibel level.
+  */
+ static struct snd_kcontrol_new sbz_mixer[] = {
+ 	CA0132_ALT_CODEC_VOL("Front Playback Volume", 0x02, HDA_OUTPUT),
+ 	CA0132_CODEC_MUTE("Front Playback Switch", VNID_SPK, HDA_OUTPUT),
+ 	HDA_CODEC_VOLUME("Surround Playback Volume", 0x04, 0, HDA_OUTPUT),
+ 	HDA_CODEC_MUTE("Surround Playback Switch", 0x04, 0, HDA_OUTPUT),
+ 	HDA_CODEC_VOLUME_MONO("Center Playback Volume", 0x03, 1, 0, HDA_OUTPUT),
+ 	HDA_CODEC_MUTE_MONO("Center Playback Switch", 0x03, 1, 0, HDA_OUTPUT),
+ 	HDA_CODEC_VOLUME_MONO("LFE Playback Volume", 0x03, 2, 0, HDA_OUTPUT),
+ 	HDA_CODEC_MUTE_MONO("LFE Playback Switch", 0x03, 2, 0, HDA_OUTPUT),
+ 	CA0132_ALT_CODEC_VOL("Capture Volume", 0x07, HDA_INPUT),
+ 	CA0132_CODEC_MUTE("Capture Switch", VNID_MIC, HDA_INPUT),
+ 	HDA_CODEC_VOLUME("What U Hear Capture Volume", 0x0a, 0, HDA_INPUT),
+ 	HDA_CODEC_MUTE("What U Hear Capture Switch", 0x0a, 0, HDA_INPUT),
+ 	CA0132_CODEC_MUTE_MONO("HP/Speaker Auto Detect Playback Switch",
+ 				VNID_HP_ASEL, 1, HDA_OUTPUT),
+ 	{ } /* end */
+ };
+ 
+ /*
+  * Same as the Sound Blaster Z, except doesn't use the alt volume for capture
+  * because it doesn't set decibel levels for the DSP for capture.
+  */
+ static struct snd_kcontrol_new r3di_mixer[] = {
+ 	CA0132_ALT_CODEC_VOL("Front Playback Volume", 0x02, HDA_OUTPUT),
+ 	CA0132_CODEC_MUTE("Front Playback Switch", VNID_SPK, HDA_OUTPUT),
+ 	HDA_CODEC_VOLUME("Surround Playback Volume", 0x04, 0, HDA_OUTPUT),
+ 	HDA_CODEC_MUTE("Surround Playback Switch", 0x04, 0, HDA_OUTPUT),
+ 	HDA_CODEC_VOLUME_MONO("Center Playback Volume", 0x03, 1, 0, HDA_OUTPUT),
+ 	HDA_CODEC_MUTE_MONO("Center Playback Switch", 0x03, 1, 0, HDA_OUTPUT),
+ 	HDA_CODEC_VOLUME_MONO("LFE Playback Volume", 0x03, 2, 0, HDA_OUTPUT),
+ 	HDA_CODEC_MUTE_MONO("LFE Playback Switch", 0x03, 2, 0, HDA_OUTPUT),
+ 	CA0132_CODEC_VOL("Capture Volume", VNID_MIC, HDA_INPUT),
+ 	CA0132_CODEC_MUTE("Capture Switch", VNID_MIC, HDA_INPUT),
+ 	HDA_CODEC_VOLUME("What U Hear Capture Volume", 0x0a, 0, HDA_INPUT),
+ 	HDA_CODEC_MUTE("What U Hear Capture Switch", 0x0a, 0, HDA_INPUT),
+ 	CA0132_CODEC_MUTE_MONO("HP/Speaker Auto Detect Playback Switch",
+ 				VNID_HP_ASEL, 1, HDA_OUTPUT),
+ 	{ } /* end */
+ };
+ 
++>>>>>>> 47cdf76e44e8 (ALSA: hda/ca0132: Add new control changes for SBZ + R3Di)
  static int ca0132_build_controls(struct hda_codec *codec)
  {
  	struct ca0132_spec *spec = codec->spec;
@@@ -4022,17 -5818,62 +5134,65 @@@
  		if (err < 0)
  			return err;
  	}
+ 	/*
+ 	 * If codec has use_alt_controls set to true, add effect level sliders,
+ 	 * EQ presets, and Smart Volume presets. Also, change names to add FX
+ 	 * prefix, and change PlayEnhancement and CrystalVoice to match.
+ 	 */
+ 	if (spec->use_alt_controls) {
+ 		ca0132_alt_add_svm_enum(codec);
+ 		add_ca0132_alt_eq_presets(codec);
+ 		err = add_fx_switch(codec, PLAY_ENHANCEMENT,
+ 					"Enable OutFX", 0);
+ 		if (err < 0)
+ 			return err;
  
- 	err = add_fx_switch(codec, PLAY_ENHANCEMENT, "PlayEnhancement", 0);
- 	if (err < 0)
- 		return err;
+ 		err = add_fx_switch(codec, CRYSTAL_VOICE,
+ 					"Enable InFX", 1);
+ 		if (err < 0)
+ 			return err;
  
- 	err = add_fx_switch(codec, CRYSTAL_VOICE, "CrystalVoice", 1);
- 	if (err < 0)
- 		return err;
+ 		num_sliders = OUT_EFFECTS_COUNT - 1;
+ 		for (i = 0; i < num_sliders; i++) {
+ 			err = ca0132_alt_add_effect_slider(codec,
+ 					    ca0132_effects[i].nid,
+ 					    ca0132_effects[i].name,
+ 					    ca0132_effects[i].direct);
+ 			if (err < 0)
+ 				return err;
+ 		}
  
+ 		err = ca0132_alt_add_effect_slider(codec, XBASS_XOVER,
+ 					"X-Bass Crossover", EFX_DIR_OUT);
+ 
+ 		if (err < 0)
+ 			return err;
+ 	} else {
+ 		err = add_fx_switch(codec, PLAY_ENHANCEMENT,
+ 					"PlayEnhancement", 0);
+ 		if (err < 0)
+ 			return err;
+ 
+ 		err = add_fx_switch(codec, CRYSTAL_VOICE,
+ 					"CrystalVoice", 1);
+ 		if (err < 0)
+ 			return err;
+ 	}
  	add_voicefx(codec);
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * If the codec uses alt_functions, you need the enumerated controls
+ 	 * to select the new outputs and inputs, plus add the new mic boost
+ 	 * setting control.
+ 	 */
+ 	if (spec->use_alt_functions) {
+ 		ca0132_alt_add_output_enum(codec);
+ 		ca0132_alt_add_input_enum(codec);
+ 		ca0132_alt_add_mic_boost_enum(codec);
+ 	}
++>>>>>>> 47cdf76e44e8 (ALSA: hda/ca0132: Add new control changes for SBZ + R3Di)
  #ifdef ENABLE_TUNING_CONTROLS
  	add_tuning_ctls(codec);
  #endif
@@@ -5086,7 -7561,34 +6264,38 @@@ static int patch_ca0132(struct hda_code
  
  	spec->dsp_state = DSP_DOWNLOAD_INIT;
  	spec->num_mixers = 1;
++<<<<<<< HEAD
 +	spec->mixers[0] = ca0132_mixer;
++=======
+ 
+ 	/* Set which mixers each quirk uses. */
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 		spec->mixers[0] = sbz_mixer;
+ 		snd_hda_codec_set_name(codec, "Sound Blaster Z");
+ 		break;
+ 	case QUIRK_R3DI:
+ 		spec->mixers[0] = r3di_mixer;
+ 		snd_hda_codec_set_name(codec, "Recon3Di");
+ 		break;
+ 	default:
+ 		spec->mixers[0] = ca0132_mixer;
+ 		break;
+ 	}
+ 
+ 	/* Setup whether or not to use alt functions/controls */
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 	case QUIRK_R3DI:
+ 		spec->use_alt_controls = true;
+ 		spec->use_alt_functions = true;
+ 		break;
+ 	default:
+ 		spec->use_alt_controls = false;
+ 		spec->use_alt_functions = false;
+ 		break;
+ 	}
++>>>>>>> 47cdf76e44e8 (ALSA: hda/ca0132: Add new control changes for SBZ + R3Di)
  
  	spec->base_init_verbs = ca0132_base_init_verbs;
  	spec->base_exit_verbs = ca0132_base_exit_verbs;
* Unmerged path sound/pci/hda/patch_ca0132.c
