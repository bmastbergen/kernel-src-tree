ovl: create helper ovl_create_temp()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 137ec526a20c4e4d21d658a6581b471d39860911
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/137ec526.failed

Also used ovl_create_temp() in ovl_create_index() instead of calling
ovl_do_mkdir() directly, so now all callers of ovl_do_mkdir() are routed
through ovl_create_real(), which paves the way for Al's fix for non-hashed
result from vfs_mkdir().

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 137ec526a20c4e4d21d658a6581b471d39860911)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/dir.c
#	fs/overlayfs/overlayfs.h
diff --cc fs/overlayfs/copy_up.c
index 5bfbfc122918,1b442c14c531..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -402,10 -369,6 +402,13 @@@ static int ovl_create_index(struct dent
  	if (IS_ERR(temp))
  		goto temp_err;
  
++<<<<<<< HEAD
 +	err = ovl_do_mkdir(dir, temp, S_IFDIR, true);
 +	if (err)
 +		goto out;
 +
++=======
++>>>>>>> 137ec526a20c (ovl: create helper ovl_create_temp())
  	err = ovl_set_upper_fh(upper, temp);
  	if (err)
  		goto out_cleanup;
@@@ -531,22 -496,12 +534,29 @@@ static int ovl_get_tmpfile(struct ovl_c
  	if (new_creds)
  		old_creds = override_creds(new_creds);
  
- 	if (c->tmpfile) {
+ 	if (c->tmpfile)
  		temp = ovl_do_tmpfile(c->workdir, c->stat.mode);
++<<<<<<< HEAD
 +		if (IS_ERR(temp))
 +			goto temp_err;
 +	} else {
 +		temp = ovl_lookup_temp(c->workdir);
 +		if (IS_ERR(temp))
 +			goto temp_err;
 +
 +		err = ovl_create_real(d_inode(c->workdir), temp, &cattr,
 +				      NULL, true);
 +		if (err) {
 +			dput(temp);
 +			goto out;
 +		}
 +	}
++=======
+ 	else
+ 		temp = ovl_create_temp(c->workdir, &cattr);
+ 	if (IS_ERR(temp))
+ 		goto temp_err;
++>>>>>>> 137ec526a20c (ovl: create helper ovl_create_temp())
  	err = 0;
  	*tempp = temp;
  out:
diff --cc fs/overlayfs/dir.c
index de117ec8c92e,1b181292a624..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -157,9 -161,20 +157,15 @@@ int ovl_create_real(struct inode *dir, 
  		 */
  		err = -ENOENT;
  	}
 -out:
 -	if (err) {
 -		dput(newdentry);
 -		return ERR_PTR(err);
 -	}
 -	return newdentry;
 +	return err;
  }
  
+ struct dentry *ovl_create_temp(struct dentry *workdir, struct ovl_cattr *attr)
+ {
+ 	return ovl_create_real(d_inode(workdir), ovl_lookup_temp(workdir),
+ 			       attr);
+ }
+ 
  static int ovl_set_opaque_xerr(struct dentry *dentry, struct dentry *upper,
  			       int xerr)
  {
@@@ -279,7 -293,7 +285,11 @@@ static struct dentry *ovl_clear_empty(s
  	if (upper->d_parent->d_inode != udir)
  		goto out_unlock;
  
++<<<<<<< HEAD
 +	opaquedir = ovl_lookup_temp(workdir);
++=======
+ 	opaquedir = ovl_create_temp(workdir, OVL_CATTR(stat.mode));
++>>>>>>> 137ec526a20c (ovl: create helper ovl_create_temp())
  	err = PTR_ERR(opaquedir);
  	if (IS_ERR(opaquedir))
  		goto out_unlock;
@@@ -432,12 -391,13 +442,20 @@@ static int ovl_create_over_whiteout(str
  			       dentry->d_name.len);
  	err = PTR_ERR(upper);
  	if (IS_ERR(upper))
++<<<<<<< HEAD
++=======
+ 		goto out_unlock;
+ 
+ 	newdentry = ovl_create_temp(workdir, cattr);
+ 	err = PTR_ERR(newdentry);
+ 	if (IS_ERR(newdentry))
++>>>>>>> 137ec526a20c (ovl: create helper ovl_create_temp())
  		goto out_dput;
  
 +	err = ovl_create_real(wdir, newdentry, cattr, hardlink, true);
 +	if (err)
 +		goto out_dput2;
 +
  	/*
  	 * mode could have been mutilated due to umask (e.g. sgid directory)
  	 */
diff --cc fs/overlayfs/overlayfs.h
index 403c48960f89,3f13d0965e03..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -303,19 -345,22 +303,24 @@@ static inline void ovl_copyattr(struct 
  }
  
  /* dir.c */
++<<<<<<< HEAD
 +extern const struct inode_operations_wrapper ovl_dir_inode_operations;
 +struct dentry *ovl_lookup_temp(struct dentry *workdir);
++=======
+ extern const struct inode_operations ovl_dir_inode_operations;
++>>>>>>> 137ec526a20c (ovl: create helper ovl_create_temp())
  int ovl_cleanup_and_whiteout(struct dentry *workdir, struct inode *dir,
  			     struct dentry *dentry);
 -struct ovl_cattr {
 +struct cattr {
  	dev_t rdev;
  	umode_t mode;
  	const char *link;
 -	struct dentry *hardlink;
  };
 -
 -#define OVL_CATTR(m) (&(struct ovl_cattr) { .mode = (m) })
 -
 -struct dentry *ovl_create_real(struct inode *dir, struct dentry *newdentry,
 -			       struct ovl_cattr *attr);
 +int ovl_create_real(struct inode *dir, struct dentry *newdentry,
 +		    struct cattr *attr,
 +		    struct dentry *hardlink, bool debug);
  int ovl_cleanup(struct inode *dir, struct dentry *dentry);
+ struct dentry *ovl_create_temp(struct dentry *workdir, struct ovl_cattr *attr);
  
  /* copy_up.c */
  int ovl_copy_up(struct dentry *dentry);
* Unmerged path fs/overlayfs/copy_up.c
* Unmerged path fs/overlayfs/dir.c
* Unmerged path fs/overlayfs/overlayfs.h
