x86/speculation/mds: Add SMT warning message

jira LE-1907
cve CVE-2019-11091
cve CVE-2018-12130
cve CVE-2018-12127
cve CVE-2018-12126
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] speculation/mds: Add SMT warning message (Waiman Long) [1709296 1690358 1690348 1690335] {CVE-2018-12126 CVE-2018-12127 CVE-2018-12130 CVE-2019-11091}
Rebuild_FUZZ: 95.24%
commit-author Josh Poimboeuf <jpoimboe@redhat.com>
commit 39226ef02bfb43248b7db12a4fdccb39d95318e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/39226ef0.failed

MDS is vulnerable with SMT.  Make that clear with a one-time printk
whenever SMT first gets enabled.

	Signed-off-by: Josh Poimboeuf <jpoimboe@redhat.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Tyler Hicks <tyhicks@canonical.com>
	Acked-by: Jiri Kosina <jkosina@suse.cz>

(cherry picked from commit 39226ef02bfb43248b7db12a4fdccb39d95318e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/kernel/cpu/bugs.c
index 6ec1d2da76d1,22a14d4b68a2..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -199,52 -565,172 +199,118 @@@ void __spectre_v2_select_mitigation(voi
  	case SPECTRE_V2_CMD_FORCE:
  	case SPECTRE_V2_CMD_AUTO:
  		if (boot_cpu_has(X86_FEATURE_IBRS_ENHANCED)) {
 -			mode = SPECTRE_V2_IBRS_ENHANCED;
 -			/* Force it so VMEXIT will restore correctly */
 -			x86_spec_ctrl_base |= SPEC_CTRL_IBRS;
 -			wrmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base);
 -			goto specv2_set_mode;
 +			spec_ctrl_enable_ibrs_enhanced();
 +			return;
  		}
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_auto;
 -		break;
 -	case SPECTRE_V2_CMD_RETPOLINE_AMD:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_amd;
 -		break;
 -	case SPECTRE_V2_CMD_RETPOLINE_GENERIC:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_generic;
 -		break;
 -	case SPECTRE_V2_CMD_RETPOLINE:
 -		if (IS_ENABLED(CONFIG_RETPOLINE))
 -			goto retpoline_auto;
  		break;
 -	}
 -	pr_err("Spectre mitigation: kernel not compiled with retpoline; no mitigation available!");
 -	return;
 -
 -retpoline_auto:
 -	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD ||
 -	    boot_cpu_data.x86_vendor == X86_VENDOR_HYGON) {
 -	retpoline_amd:
 -		if (!boot_cpu_has(X86_FEATURE_LFENCE_RDTSC)) {
 -			pr_err("Spectre mitigation: LFENCE not serializing, switching to generic retpoline\n");
 -			goto retpoline_generic;
 -		}
 -		mode = SPECTRE_V2_RETPOLINE_AMD;
 -		setup_force_cpu_cap(X86_FEATURE_RETPOLINE_AMD);
 -		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
 -	} else {
 -	retpoline_generic:
 -		mode = SPECTRE_V2_RETPOLINE_GENERIC;
 -		setup_force_cpu_cap(X86_FEATURE_RETPOLINE);
 -	}
 -
 -specv2_set_mode:
 -	spectre_v2_enabled = mode;
 -	pr_info("%s\n", spectre_v2_strings[mode]);
 -
 -	/*
 -	 * If spectre v2 protection has been enabled, unconditionally fill
 -	 * RSB during a context switch; this protects against two independent
 -	 * issues:
 -	 *
 -	 *	- RSB underflow (and switch to BTB) on Skylake+
 -	 *	- SpectreRSB variant of spectre v2 on X86_BUG_SPECTRE_V2 CPUs
 -	 */
 -	setup_force_cpu_cap(X86_FEATURE_RSB_CTXSW);
 -	pr_info("Spectre v2 / SpectreRSB mitigation: Filling RSB on context switch\n");
 -
 -	/*
 -	 * Retpoline means the kernel is safe because it has no indirect
 -	 * branches. Enhanced IBRS protects firmware too, so, enable restricted
 -	 * speculation around firmware calls only when Enhanced IBRS isn't
 -	 * supported.
 -	 *
 -	 * Use "mode" to check Enhanced IBRS instead of boot_cpu_has(), because
 -	 * the user might select retpoline on the kernel command line and if
 -	 * the CPU supports Enhanced IBRS, kernel might un-intentionally not
 -	 * enable IBRS around firmware calls.
 -	 */
 -	if (boot_cpu_has(X86_FEATURE_IBRS) && mode != SPECTRE_V2_IBRS_ENHANCED) {
 -		setup_force_cpu_cap(X86_FEATURE_USE_IBRS_FW);
 -		pr_info("Enabling Restricted Speculation for firmware calls\n");
 -	}
 -
 -	/* Set up IBPB and STIBP depending on the general spectre V2 command */
 -	spectre_v2_user_select_mitigation(cmd);
 -}
 -
 -static void update_stibp_msr(void * __unused)
 -{
 -	wrmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base);
 -}
  
 -/* Update x86_spec_ctrl_base in case SMT state changed. */
 -static void update_stibp_strict(void)
 -{
 -	u64 mask = x86_spec_ctrl_base & ~SPEC_CTRL_STIBP;
 -
 -	if (sched_smt_active())
 -		mask |= SPEC_CTRL_STIBP;
 -
 -	if (mask == x86_spec_ctrl_base)
 +	case SPECTRE_V2_CMD_RETPOLINE:
 +		spec_ctrl_enable_retpoline();
  		return;
  
++<<<<<<< HEAD
 +	case SPECTRE_V2_CMD_IBRS:
 +		if (spec_ctrl_force_enable_ibrs())
 +			return;
++=======
+ 	pr_info("Update user space SMT mitigation: STIBP %s\n",
+ 		mask & SPEC_CTRL_STIBP ? "always-on" : "off");
+ 	x86_spec_ctrl_base = mask;
+ 	on_each_cpu(update_stibp_msr, NULL, 1);
+ }
+ 
+ /* Update the static key controlling the evaluation of TIF_SPEC_IB */
+ static void update_indir_branch_cond(void)
+ {
+ 	if (sched_smt_active())
+ 		static_branch_enable(&switch_to_cond_stibp);
+ 	else
+ 		static_branch_disable(&switch_to_cond_stibp);
+ }
+ 
+ #undef pr_fmt
+ #define pr_fmt(fmt) fmt
+ 
+ /* Update the static key controlling the MDS CPU buffer clear in idle */
+ static void update_mds_branch_idle(void)
+ {
+ 	/*
+ 	 * Enable the idle clearing if SMT is active on CPUs which are
+ 	 * affected only by MSBDS and not any other MDS variant.
+ 	 *
+ 	 * The other variants cannot be mitigated when SMT is enabled, so
+ 	 * clearing the buffers on idle just to prevent the Store Buffer
+ 	 * repartitioning leak would be a window dressing exercise.
+ 	 */
+ 	if (!boot_cpu_has_bug(X86_BUG_MSBDS_ONLY))
+ 		return;
+ 
+ 	if (sched_smt_active())
+ 		static_branch_enable(&mds_idle_clear);
+ 	else
+ 		static_branch_disable(&mds_idle_clear);
+ }
+ 
+ #define MDS_MSG_SMT "MDS CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/mds.html for more details.\n"
+ 
+ void arch_smt_update(void)
+ {
+ 	/* Enhanced IBRS implies STIBP. No update required. */
+ 	if (spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)
+ 		return;
+ 
+ 	mutex_lock(&spec_ctrl_mutex);
+ 
+ 	switch (spectre_v2_user) {
+ 	case SPECTRE_V2_USER_NONE:
++>>>>>>> 39226ef02bfb (x86/speculation/mds: Add SMT warning message)
  		break;
 -	case SPECTRE_V2_USER_STRICT:
 -	case SPECTRE_V2_USER_STRICT_PREFERRED:
 -		update_stibp_strict();
 +
 +	case SPECTRE_V2_CMD_IBRS_ALWAYS:
 +		if (spec_ctrl_enable_ibrs_always() ||
 +		    spec_ctrl_force_enable_ibp_disabled())
 +			return;
  		break;
 -	case SPECTRE_V2_USER_PRCTL:
 -	case SPECTRE_V2_USER_SECCOMP:
 -		update_indir_branch_cond();
 +
 +	case SPECTRE_V2_CMD_RETPOLINE_IBRS_USER:
 +		if (spec_ctrl_enable_retpoline_ibrs_user())
 +			return;
  		break;
  	}
  
++<<<<<<< HEAD
 +	if (spec_ctrl_cond_enable_ibrs(full_retpoline))
 +		return;
++=======
+ 	switch (mds_mitigation) {
+ 	case MDS_MITIGATION_FULL:
+ 	case MDS_MITIGATION_VMWERV:
+ 		if (sched_smt_active() && !boot_cpu_has(X86_BUG_MSBDS_ONLY))
+ 			pr_warn_once(MDS_MSG_SMT);
+ 		update_mds_branch_idle();
+ 		break;
+ 	case MDS_MITIGATION_OFF:
+ 		break;
+ 	}
++>>>>>>> 39226ef02bfb (x86/speculation/mds: Add SMT warning message)
  
 -	mutex_unlock(&spec_ctrl_mutex);
 +	if (spec_ctrl_cond_enable_ibp_disabled())
 +		return;
 +
 +	spec_ctrl_enable_retpoline();
 +}
 +
 +void spectre_v2_print_mitigation(void)
 +{
 +
 +	pr_info("%s\n", spectre_v2_strings[spec_ctrl_get_mitigation()]);
 +}
 +
 +static void __init spectre_v2_select_mitigation(void)
 +{
 +	spectre_v2_cmd = spectre_v2_parse_cmdline();
 +	__spectre_v2_select_mitigation();
 +	spectre_v2_print_mitigation();
  }
  
  #undef pr_fmt
* Unmerged path arch/x86/kernel/cpu/bugs.c
