tun: support receiving skb through msg_control

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jason Wang <jasowang@redhat.com>
commit ac77cfd4258fb8174766a92d118436da7f9dabf1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ac77cfd4.failed

This patch makes tun_recvmsg() can receive from skb from its caller
through msg_control. Vhost_net will be the first user.

	Signed-off-by: Jason Wang <jasowang@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ac77cfd4258fb8174766a92d118436da7f9dabf1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/tun.c
diff --cc drivers/net/tun.c
index 35cc09f13a24,f8041f9c7e65..000000000000
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@@ -1650,24 -1509,25 +1650,37 @@@ out
  }
  
  static ssize_t tun_do_read(struct tun_struct *tun, struct tun_file *tfile,
++<<<<<<< HEAD
 +			   struct kiocb *iocb, const struct iovec *iv,
 +			   ssize_t len, int noblock)
++=======
+ 			   struct iov_iter *to,
+ 			   int noblock, struct sk_buff *skb)
++>>>>>>> ac77cfd4258f (tun: support receiving skb through msg_control)
  {
- 	struct sk_buff *skb;
  	ssize_t ret;
  	int err;
  
  	tun_debug(KERN_INFO, tun, "tun_do_read\n");
  
 -	if (!iov_iter_count(to))
 +	if (!len)
  		return 0;
  
++<<<<<<< HEAD
 +	/* Read frames from ring */
 +	skb = tun_ring_recv(tun, tfile, noblock, &err);
 +	if (!skb)
 +		return err;
++=======
+ 	if (!skb) {
+ 		/* Read frames from ring */
+ 		skb = tun_ring_recv(tfile, noblock, &err);
+ 		if (!skb)
+ 			return err;
+ 	}
++>>>>>>> ac77cfd4258f (tun: support receiving skb through msg_control)
  
 -	ret = tun_put_user(tun, tfile, skb, to);
 +	ret = tun_put_user(tun, tfile, skb, iv, len);
  	if (unlikely(ret < 0))
  		kfree_skb(skb);
  	else
@@@ -1686,16 -1545,10 +1699,20 @@@ static ssize_t tun_chr_aio_read(struct 
  
  	if (!tun)
  		return -EBADFD;
++<<<<<<< HEAD
 +	len = iov_length(iv, count);
 +	if (len < 0) {
 +		ret = -EINVAL;
 +		goto out;
 +	}
 +
 +	ret = tun_do_read(tun, tfile, iocb, iv, len,
 +			  file->f_flags & O_NONBLOCK);
++=======
+ 	ret = tun_do_read(tun, tfile, to, file->f_flags & O_NONBLOCK, NULL);
++>>>>>>> ac77cfd4258f (tun: support receiving skb through msg_control)
  	ret = min_t(ssize_t, ret, len);
 -	if (ret > 0)
 -		iocb->ki_pos = ret;
 +out:
  	tun_put(tun);
  	return ret;
  }
@@@ -1847,9 -1642,14 +1864,20 @@@ static int tun_recvmsg(struct kiocb *io
  		ret = -EINVAL;
  		goto out;
  	}
++<<<<<<< HEAD
 +	ret = tun_do_read(tun, tfile, iocb, m->msg_iov, total_len,
 +			  flags & MSG_DONTWAIT);
 +	if (ret > total_len) {
++=======
+ 	if (flags & MSG_ERRQUEUE) {
+ 		ret = sock_recv_errqueue(sock->sk, m, total_len,
+ 					 SOL_PACKET, TUN_TX_TIMESTAMP);
+ 		goto out;
+ 	}
+ 	ret = tun_do_read(tun, tfile, &m->msg_iter, flags & MSG_DONTWAIT,
+ 			  m->msg_control);
+ 	if (ret > (ssize_t)total_len) {
++>>>>>>> ac77cfd4258f (tun: support receiving skb through msg_control)
  		m->msg_flags |= MSG_TRUNC;
  		ret = flags & MSG_TRUNC ? ret : total_len;
  	}
* Unmerged path drivers/net/tun.c
