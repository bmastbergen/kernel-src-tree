IB/hfi1: Remove INTx support and simplify MSIx usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Michael J. Ruhl <michael.j.ruhl@intel.com>
commit 70324739ac5e0332dc053eaeaba773f5ab755879
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/70324739.failed

The INTx IRQ support does not work for all HF1 IRQ handlers
(specifically the receive data IRQs).

Remove all supporting code for the INTx IRQ.

If the requested MSIx vector request is unsuccessful, do not allow the
driver to continue.

	Reviewed-by: Mike Marciniszyn <mike.marciniszyn@intel.com>
	Reviewed-by: Kamenee Arumugam <kamenee.arumugam@intel.com>
	Reviewed-by: Sadanand Warrier <sadanand.warrier@intel.com>
	Signed-off-by: Michael J. Ruhl <michael.j.ruhl@intel.com>
	Signed-off-by: Dennis Dalessandro <dennis.dalessandro@intel.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 70324739ac5e0332dc053eaeaba773f5ab755879)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hfi1/chip.c
#	drivers/infiniband/hw/hfi1/hfi.h
diff --cc drivers/infiniband/hw/hfi1/chip.c
index 56344d372b1b,5d03c780c780..000000000000
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@@ -13044,32 -13044,21 +13042,46 @@@ static void clear_all_interrupts(struc
  void hfi1_clean_up_interrupts(struct hfi1_devdata *dd)
  {
  	int i;
+ 	struct hfi1_msix_entry *me = dd->msix_entries;
  
  	/* remove irqs - must happen before disabling/turning off */
++<<<<<<< HEAD
 +	if (dd->num_msix_entries) {
 +		/* MSI-X */
 +		struct hfi1_msix_entry *me = dd->msix_entries;
 +
 +		for (i = 0; i < dd->num_msix_entries; i++, me++) {
 +			if (!me->arg) /* => no irq, no affinity */
 +				continue;
 +			hfi1_put_irq_affinity(dd, me);
 +			free_irq(me->irq, me->arg);
 +		}
 +
 +		/* clean structures */
 +		kfree(dd->msix_entries);
 +		dd->msix_entries = NULL;
 +		dd->num_msix_entries = 0;
 +	} else {
 +		/* INTx */
 +		if (dd->requested_intx_irq) {
 +			free_irq(dd->pcidev->irq, dd);
 +			dd->requested_intx_irq = 0;
 +		}
 +		disable_intx(dd->pcidev);
++=======
+ 	for (i = 0; i < dd->num_msix_entries; i++, me++) {
+ 		if (!me->arg) /* => no irq, no affinity */
+ 			continue;
+ 		hfi1_put_irq_affinity(dd, me);
+ 		pci_free_irq(dd->pcidev, i, me->arg);
++>>>>>>> 70324739ac5e (IB/hfi1: Remove INTx support and simplify MSIx usage)
  	}
  
+ 	/* clean structures */
+ 	kfree(dd->msix_entries);
+ 	dd->msix_entries = NULL;
+ 	dd->num_msix_entries = 0;
+ 
  	pci_free_irq_vectors(dd->pcidev);
  }
  
@@@ -13119,22 -13108,6 +13131,25 @@@ static void remap_sdma_interrupts(struc
  		   msix_intr);
  }
  
++<<<<<<< HEAD
 +static int request_intx_irq(struct hfi1_devdata *dd)
 +{
 +	int ret;
 +
 +	snprintf(dd->intx_name, sizeof(dd->intx_name), DRIVER_NAME "_%d",
 +		 dd->unit);
 +	ret = request_irq(dd->pcidev->irq, general_interrupt,
 +			  IRQF_SHARED, dd->intx_name, dd);
 +	if (ret)
 +		dd_dev_err(dd, "unable to request INTx interrupt, err %d\n",
 +			   ret);
 +	else
 +		dd->requested_intx_irq = 1;
 +	return ret;
 +}
 +
++=======
++>>>>>>> 70324739ac5e (IB/hfi1: Remove INTx support and simplify MSIx usage)
  static int request_msix_irqs(struct hfi1_devdata *dd)
  {
  	int first_general, last_general;
@@@ -13260,11 -13226,6 +13275,14 @@@ void hfi1_vnic_synchronize_irq(struct h
  {
  	int i;
  
++<<<<<<< HEAD
 +	if (!dd->num_msix_entries) {
 +		synchronize_irq(dd->pcidev->irq);
 +		return;
 +	}
 +
++=======
++>>>>>>> 70324739ac5e (IB/hfi1: Remove INTx support and simplify MSIx usage)
  	for (i = 0; i < dd->vnic.num_ctxt; i++) {
  		struct hfi1_ctxtdata *rcd = dd->vnic.ctxt[i];
  		struct hfi1_msix_entry *me = &dd->msix_entries[rcd->msix_intr];
diff --cc drivers/infiniband/hw/hfi1/hfi.h
index d83062c16532,d9470317983f..000000000000
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@@ -1226,10 -1210,6 +1226,13 @@@ struct hfi1_devdata 
  	u32 num_msix_entries;
  	u32 first_dyn_msix_idx;
  
++<<<<<<< HEAD
 +	/* INTx information */
 +	u32 requested_intx_irq;		/* did we request one? */
 +	char intx_name[MAX_NAME_SIZE];	/* INTx name */
 +
++=======
++>>>>>>> 70324739ac5e (IB/hfi1: Remove INTx support and simplify MSIx usage)
  	/* general interrupt: mask of handled interrupts */
  	u64 gi_mask[CCE_NUM_INT_CSRS];
  
* Unmerged path drivers/infiniband/hw/hfi1/chip.c
* Unmerged path drivers/infiniband/hw/hfi1/hfi.h
diff --git a/drivers/infiniband/hw/hfi1/pcie.c b/drivers/infiniband/hw/hfi1/pcie.c
index 87bd6b60cb53..bfe6a467f772 100644
--- a/drivers/infiniband/hw/hfi1/pcie.c
+++ b/drivers/infiniband/hw/hfi1/pcie.c
@@ -351,15 +351,13 @@ int pcie_speeds(struct hfi1_devdata *dd)
 /*
  * Returns:
  *	- actual number of interrupts allocated or
- *	- 0 if fell back to INTx.
  *      - error
  */
 int request_msix(struct hfi1_devdata *dd, u32 msireq)
 {
 	int nvec;
 
-	nvec = pci_alloc_irq_vectors(dd->pcidev, 1, msireq,
-				     PCI_IRQ_MSIX | PCI_IRQ_LEGACY);
+	nvec = pci_alloc_irq_vectors(dd->pcidev, msireq, msireq, PCI_IRQ_MSIX);
 	if (nvec < 0) {
 		dd_dev_err(dd, "pci_alloc_irq_vectors() failed: %d\n", nvec);
 		return nvec;
@@ -367,10 +365,6 @@ int request_msix(struct hfi1_devdata *dd, u32 msireq)
 
 	tune_pcie_caps(dd);
 
-	/* check for legacy IRQ */
-	if (nvec == 1 && !dd->pcidev->msix_enabled)
-		return 0;
-
 	return nvec;
 }
 
diff --git a/drivers/infiniband/hw/hfi1/vnic_main.c b/drivers/infiniband/hw/hfi1/vnic_main.c
index f298ee097aa6..1bd788bb71cd 100644
--- a/drivers/infiniband/hw/hfi1/vnic_main.c
+++ b/drivers/infiniband/hw/hfi1/vnic_main.c
@@ -1,5 +1,5 @@
 /*
- * Copyright(c) 2017 Intel Corporation.
+ * Copyright(c) 2017 - 2018 Intel Corporation.
  *
  * This file is provided under a dual BSD/GPLv2 license.  When using or
  * redistributing this file, you may do so under either license.
@@ -120,8 +120,7 @@ static int allocate_vnic_ctxt(struct hfi1_devdata *dd,
 	uctxt->seq_cnt = 1;
 	uctxt->is_vnic = true;
 
-	if (dd->num_msix_entries)
-		hfi1_set_vnic_msix_info(uctxt);
+	hfi1_set_vnic_msix_info(uctxt);
 
 	hfi1_stats.sps_ctxts++;
 	dd_dev_dbg(dd, "created vnic context %d\n", uctxt->ctxt);
@@ -136,8 +135,7 @@ static void deallocate_vnic_ctxt(struct hfi1_devdata *dd,
 	dd_dev_dbg(dd, "closing vnic context %d\n", uctxt->ctxt);
 	flush_wc();
 
-	if (dd->num_msix_entries)
-		hfi1_reset_vnic_msix_info(uctxt);
+	hfi1_reset_vnic_msix_info(uctxt);
 
 	/*
 	 * Disable receive context and interrupt available, reset all
