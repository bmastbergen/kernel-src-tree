ixgbe: don't clear_bit on xdp_ring->state if xdp_ring is null

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Colin Ian King <colin.king@canonical.com>
commit 0db4a47c05e6b5f7dda2a5d8b213ade5373afa49
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0db4a47c.failed

There is an earlier check to see if xdp_ring is null when configuring
the tx ring, so assuming that it can still be null, the clearing of
the xdp_ring->state currently could end up with a null pointer
dereference.  Fix this by only clearing the bit if xdp_ring is not null.

Detected by CoverityScan, CID#1473795 ("Dereference after null check")

Fixes: 024aa5800f32 ("ixgbe: added Rx/Tx ring disable/enable functions")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 0db4a47c05e6b5f7dda2a5d8b213ade5373afa49)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 30242b0c1e0a,aeda1834e66a..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -10201,14 -10357,170 +10201,171 @@@ static const struct net_device_ops ixgb
  	.ndo_fdb_add		= ixgbe_ndo_fdb_add,
  	.ndo_bridge_setlink	= ixgbe_ndo_bridge_setlink,
  	.ndo_bridge_getlink	= ixgbe_ndo_bridge_getlink,
 -	.ndo_dfwd_add_station	= ixgbe_fwd_add,
 -	.ndo_dfwd_del_station	= ixgbe_fwd_del,
 -	.ndo_udp_tunnel_add	= ixgbe_add_udp_tunnel_port,
 -	.ndo_udp_tunnel_del	= ixgbe_del_udp_tunnel_port,
 +	.extended.ndo_udp_tunnel_add	= ixgbe_add_udp_tunnel_port,
 +	.extended.ndo_udp_tunnel_del	= ixgbe_del_udp_tunnel_port,
  	.ndo_features_check	= ixgbe_features_check,
 -	.ndo_bpf		= ixgbe_xdp,
 -	.ndo_xdp_xmit		= ixgbe_xdp_xmit,
 -	.ndo_xsk_async_xmit	= ixgbe_xsk_async_xmit,
 +	.extended.ndo_dfwd_add_station	= ixgbe_fwd_add,
 +	.extended.ndo_dfwd_del_station	= ixgbe_fwd_del,
 +	.extended.ndo_bpf	= ixgbe_xdp,
  };
  
++<<<<<<< HEAD
++=======
+ static void ixgbe_disable_txr_hw(struct ixgbe_adapter *adapter,
+ 				 struct ixgbe_ring *tx_ring)
+ {
+ 	unsigned long wait_delay, delay_interval;
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	u8 reg_idx = tx_ring->reg_idx;
+ 	int wait_loop;
+ 	u32 txdctl;
+ 
+ 	IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(reg_idx), IXGBE_TXDCTL_SWFLSH);
+ 
+ 	/* delay mechanism from ixgbe_disable_tx */
+ 	delay_interval = ixgbe_get_completion_timeout(adapter) / 100;
+ 
+ 	wait_loop = IXGBE_MAX_RX_DESC_POLL;
+ 	wait_delay = delay_interval;
+ 
+ 	while (wait_loop--) {
+ 		usleep_range(wait_delay, wait_delay + 10);
+ 		wait_delay += delay_interval * 2;
+ 		txdctl = IXGBE_READ_REG(hw, IXGBE_TXDCTL(reg_idx));
+ 
+ 		if (!(txdctl & IXGBE_TXDCTL_ENABLE))
+ 			return;
+ 	}
+ 
+ 	e_err(drv, "TXDCTL.ENABLE not cleared within the polling period\n");
+ }
+ 
+ static void ixgbe_disable_txr(struct ixgbe_adapter *adapter,
+ 			      struct ixgbe_ring *tx_ring)
+ {
+ 	set_bit(__IXGBE_TX_DISABLED, &tx_ring->state);
+ 	ixgbe_disable_txr_hw(adapter, tx_ring);
+ }
+ 
+ static void ixgbe_disable_rxr_hw(struct ixgbe_adapter *adapter,
+ 				 struct ixgbe_ring *rx_ring)
+ {
+ 	unsigned long wait_delay, delay_interval;
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	u8 reg_idx = rx_ring->reg_idx;
+ 	int wait_loop;
+ 	u32 rxdctl;
+ 
+ 	rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
+ 	rxdctl &= ~IXGBE_RXDCTL_ENABLE;
+ 	rxdctl |= IXGBE_RXDCTL_SWFLSH;
+ 
+ 	/* write value back with RXDCTL.ENABLE bit cleared */
+ 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
+ 
+ 	/* RXDCTL.EN may not change on 82598 if link is down, so skip it */
+ 	if (hw->mac.type == ixgbe_mac_82598EB &&
+ 	    !(IXGBE_READ_REG(hw, IXGBE_LINKS) & IXGBE_LINKS_UP))
+ 		return;
+ 
+ 	/* delay mechanism from ixgbe_disable_rx */
+ 	delay_interval = ixgbe_get_completion_timeout(adapter) / 100;
+ 
+ 	wait_loop = IXGBE_MAX_RX_DESC_POLL;
+ 	wait_delay = delay_interval;
+ 
+ 	while (wait_loop--) {
+ 		usleep_range(wait_delay, wait_delay + 10);
+ 		wait_delay += delay_interval * 2;
+ 		rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
+ 
+ 		if (!(rxdctl & IXGBE_RXDCTL_ENABLE))
+ 			return;
+ 	}
+ 
+ 	e_err(drv, "RXDCTL.ENABLE not cleared within the polling period\n");
+ }
+ 
+ static void ixgbe_reset_txr_stats(struct ixgbe_ring *tx_ring)
+ {
+ 	memset(&tx_ring->stats, 0, sizeof(tx_ring->stats));
+ 	memset(&tx_ring->tx_stats, 0, sizeof(tx_ring->tx_stats));
+ }
+ 
+ static void ixgbe_reset_rxr_stats(struct ixgbe_ring *rx_ring)
+ {
+ 	memset(&rx_ring->stats, 0, sizeof(rx_ring->stats));
+ 	memset(&rx_ring->rx_stats, 0, sizeof(rx_ring->rx_stats));
+ }
+ 
+ /**
+  * ixgbe_txrx_ring_disable - Disable Rx/Tx/XDP Tx rings
+  * @adapter: adapter structure
+  * @ring: ring index
+  *
+  * This function disables a certain Rx/Tx/XDP Tx ring. The function
+  * assumes that the netdev is running.
+  **/
+ void ixgbe_txrx_ring_disable(struct ixgbe_adapter *adapter, int ring)
+ {
+ 	struct ixgbe_ring *rx_ring, *tx_ring, *xdp_ring;
+ 
+ 	rx_ring = adapter->rx_ring[ring];
+ 	tx_ring = adapter->tx_ring[ring];
+ 	xdp_ring = adapter->xdp_ring[ring];
+ 
+ 	ixgbe_disable_txr(adapter, tx_ring);
+ 	if (xdp_ring)
+ 		ixgbe_disable_txr(adapter, xdp_ring);
+ 	ixgbe_disable_rxr_hw(adapter, rx_ring);
+ 
+ 	if (xdp_ring)
+ 		synchronize_sched();
+ 
+ 	/* Rx/Tx/XDP Tx share the same napi context. */
+ 	napi_disable(&rx_ring->q_vector->napi);
+ 
+ 	ixgbe_clean_tx_ring(tx_ring);
+ 	if (xdp_ring)
+ 		ixgbe_clean_tx_ring(xdp_ring);
+ 	ixgbe_clean_rx_ring(rx_ring);
+ 
+ 	ixgbe_reset_txr_stats(tx_ring);
+ 	if (xdp_ring)
+ 		ixgbe_reset_txr_stats(xdp_ring);
+ 	ixgbe_reset_rxr_stats(rx_ring);
+ }
+ 
+ /**
+  * ixgbe_txrx_ring_enable - Enable Rx/Tx/XDP Tx rings
+  * @adapter: adapter structure
+  * @ring: ring index
+  *
+  * This function enables a certain Rx/Tx/XDP Tx ring. The function
+  * assumes that the netdev is running.
+  **/
+ void ixgbe_txrx_ring_enable(struct ixgbe_adapter *adapter, int ring)
+ {
+ 	struct ixgbe_ring *rx_ring, *tx_ring, *xdp_ring;
+ 
+ 	rx_ring = adapter->rx_ring[ring];
+ 	tx_ring = adapter->tx_ring[ring];
+ 	xdp_ring = adapter->xdp_ring[ring];
+ 
+ 	/* Rx/Tx/XDP Tx share the same napi context. */
+ 	napi_enable(&rx_ring->q_vector->napi);
+ 
+ 	ixgbe_configure_tx_ring(adapter, tx_ring);
+ 	if (xdp_ring)
+ 		ixgbe_configure_tx_ring(adapter, xdp_ring);
+ 	ixgbe_configure_rx_ring(adapter, rx_ring);
+ 
+ 	clear_bit(__IXGBE_TX_DISABLED, &tx_ring->state);
+ 	if (xdp_ring)
+ 		clear_bit(__IXGBE_TX_DISABLED, &xdp_ring->state);
+ }
+ 
++>>>>>>> 0db4a47c05e6 (ixgbe: don't clear_bit on xdp_ring->state if xdp_ring is null)
  /**
   * ixgbe_enumerate_functions - Get the number of ports this device has
   * @adapter: adapter structure
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
