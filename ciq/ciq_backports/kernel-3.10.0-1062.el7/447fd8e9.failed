ALSA: hda/ca0132: add the ability to set src_id on scp commands

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit 447fd8e9a88e466326a07c85c1344e45d3a6cddf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/447fd8e9.failed

This patch adds the ability to change the src_id on scp commands, which
is used in the dsp setup of the Recon3Di and the Sound Blaster Z. It
also makes sure to maintain backwards compatibility with the older
dspio_set_uint_param function, and sets it's src to the default 0x20.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 447fd8e9a88e466326a07c85c1344e45d3a6cddf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index 267302056b78,3b83f07e8be7..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -4331,6 -4624,196 +4342,199 @@@ static void ca0132_refresh_widget_caps(
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Recon3Di r3di_setup_defaults sub functions.
+  */
+ 
+ static void r3di_dsp_scp_startup(struct hda_codec *codec)
+ {
+ 	unsigned int tmp;
+ 
+ 	tmp = 0x00000000;
+ 	dspio_set_uint_param_no_source(codec, 0x80, 0x0A, tmp);
+ 
+ 	tmp = 0x00000001;
+ 	dspio_set_uint_param_no_source(codec, 0x80, 0x0B, tmp);
+ 
+ 	tmp = 0x00000004;
+ 	dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 
+ 	tmp = 0x00000005;
+ 	dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 
+ 	tmp = 0x00000000;
+ 	dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 
+ }
+ 
+ static void r3di_dsp_initial_mic_setup(struct hda_codec *codec)
+ {
+ 	unsigned int tmp;
+ 
+ 	/* Mic 1 Setup */
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 	/* This ConnPointID is unique to Recon3Di. Haven't seen it elsewhere */
+ 	chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 	tmp = FLOAT_ONE;
+ 	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 	/* Mic 2 Setup, even though it isn't connected on SBZ */
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN2, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT2, SR_96_000);
+ 	chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x80, 0x01, tmp);
+ }
+ 
+ /*
+  * Initialize Sound Blaster Z analog microphones.
+  */
+ static void sbz_init_analog_mics(struct hda_codec *codec)
+ {
+ 	unsigned int tmp;
+ 
+ 	/* Mic 1 Setup */
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 	tmp = FLOAT_THREE;
+ 	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 	/* Mic 2 Setup, even though it isn't connected on SBZ */
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN2, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT2, SR_96_000);
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x80, 0x01, tmp);
+ 
+ }
+ 
+ /*
+  * Sets the source of stream 0x14 to connpointID 0x48, and the destination
+  * connpointID to 0x91. If this isn't done, the destination is 0x71, and
+  * you get no sound. I'm guessing this has to do with the Sound Blaster Z
+  * having an updated DAC, which changes the destination to that DAC.
+  */
+ static void sbz_connect_streams(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 
+ 	codec_dbg(codec, "Connect Streams entered, mutex locked and loaded.\n");
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 
+ 	/* This value is 0x43 for 96khz, and 0x83 for 192khz. */
+ 	chipio_write_no_mutex(codec, 0x18a020, 0x00000043);
+ 
+ 	/* Setup stream 0x14 with it's source and destination points */
+ 	chipio_set_stream_source_dest(codec, 0x14, 0x48, 0x91);
+ 	chipio_set_conn_rate_no_mutex(codec, 0x48, SR_96_000);
+ 	chipio_set_conn_rate_no_mutex(codec, 0x91, SR_96_000);
+ 	chipio_set_stream_channels(codec, 0x14, 2);
+ 	chipio_set_stream_control(codec, 0x14, 1);
+ 
+ 	codec_dbg(codec, "Connect Streams exited, mutex released.\n");
+ 
+ 	mutex_unlock(&spec->chipio_mutex);
+ 
+ }
+ 
+ /*
+  * Write data through ChipIO to setup proper stream destinations.
+  * Not sure how it exactly works, but it seems to direct data
+  * to different destinations. Example is f8 to c0, e0 to c0.
+  * All I know is, if you don't set these, you get no sound.
+  */
+ static void sbz_chipio_startup_data(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 	codec_dbg(codec, "Startup Data entered, mutex locked and loaded.\n");
+ 
+ 	/* These control audio output */
+ 	chipio_write_no_mutex(codec, 0x190060, 0x0001f8c0);
+ 	chipio_write_no_mutex(codec, 0x190064, 0x0001f9c1);
+ 	chipio_write_no_mutex(codec, 0x190068, 0x0001fac6);
+ 	chipio_write_no_mutex(codec, 0x19006c, 0x0001fbc7);
+ 	/* Signal to update I think */
+ 	chipio_write_no_mutex(codec, 0x19042c, 0x00000001);
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 	/* No clue what these control */
+ 	chipio_write_no_mutex(codec, 0x190030, 0x0001e0c0);
+ 	chipio_write_no_mutex(codec, 0x190034, 0x0001e1c1);
+ 	chipio_write_no_mutex(codec, 0x190038, 0x0001e4c2);
+ 	chipio_write_no_mutex(codec, 0x19003c, 0x0001e5c3);
+ 	chipio_write_no_mutex(codec, 0x190040, 0x0001e2c4);
+ 	chipio_write_no_mutex(codec, 0x190044, 0x0001e3c5);
+ 	chipio_write_no_mutex(codec, 0x190048, 0x0001e8c6);
+ 	chipio_write_no_mutex(codec, 0x19004c, 0x0001e9c7);
+ 	chipio_write_no_mutex(codec, 0x190050, 0x0001ecc8);
+ 	chipio_write_no_mutex(codec, 0x190054, 0x0001edc9);
+ 	chipio_write_no_mutex(codec, 0x190058, 0x0001eaca);
+ 	chipio_write_no_mutex(codec, 0x19005c, 0x0001ebcb);
+ 
+ 	chipio_write_no_mutex(codec, 0x19042c, 0x00000001);
+ 
+ 	codec_dbg(codec, "Startup Data exited, mutex released.\n");
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ /*
+  * Sound Blaster Z uses these after DSP is loaded. Weird SCP commands
+  * without a 0x20 source like normal.
+  */
+ static void sbz_dsp_scp_startup(struct hda_codec *codec)
+ {
+ 	unsigned int tmp;
+ 
+ 	tmp = 0x00000003;
+ 	dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 
+ 	tmp = 0x00000000;
+ 	dspio_set_uint_param_no_source(codec, 0x80, 0x0A, tmp);
+ 
+ 	tmp = 0x00000001;
+ 	dspio_set_uint_param_no_source(codec, 0x80, 0x0B, tmp);
+ 
+ 	tmp = 0x00000004;
+ 	dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 
+ 	tmp = 0x00000005;
+ 	dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 
+ 	tmp = 0x00000000;
+ 	dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 
+ }
+ 
+ static void sbz_dsp_initial_mic_setup(struct hda_codec *codec)
+ {
+ 	unsigned int tmp;
+ 
+ 	chipio_set_stream_control(codec, 0x03, 0);
+ 	chipio_set_stream_control(codec, 0x04, 0);
+ 
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 
+ 	tmp = FLOAT_THREE;
+ 	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 	chipio_set_stream_control(codec, 0x03, 1);
+ 	chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 	chipio_write(codec, 0x18b098, 0x0000000c);
+ 	chipio_write(codec, 0x18b09C, 0x0000000c);
+ }
+ 
+ /*
++>>>>>>> 447fd8e9a88e (ALSA: hda/ca0132: add the ability to set src_id on scp commands)
   * Setup default parameters for DSP
   */
  static void ca0132_setup_defaults(struct hda_codec *codec)
@@@ -4375,6 -4858,129 +4579,132 @@@
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Setup default parameters for Recon3Di DSP.
+  */
+ 
+ static void r3di_setup_defaults(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 	int num_fx;
+ 	int idx, i;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return;
+ 
+ 	r3di_dsp_scp_startup(codec);
+ 
+ 	r3di_dsp_initial_mic_setup(codec);
+ 
+ 	/*remove DSP headroom*/
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x3C, tmp);
+ 
+ 	/* set WUH source */
+ 	tmp = FLOAT_TWO;
+ 	dspio_set_uint_param(codec, 0x31, 0x00, tmp);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);
+ 
+ 	/* Set speaker source? */
+ 	dspio_set_uint_param(codec, 0x32, 0x00, tmp);
+ 
+ 	r3di_gpio_dsp_status_set(codec, R3DI_DSP_DOWNLOADED);
+ 
+ 	/* Setup effect defaults */
+ 	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;
+ 	for (idx = 0; idx < num_fx; idx++) {
+ 		for (i = 0; i <= ca0132_effects[idx].params; i++) {
+ 			dspio_set_uint_param(codec,
+ 					ca0132_effects[idx].mid,
+ 					ca0132_effects[idx].reqs[i],
+ 					ca0132_effects[idx].def_vals[i]);
+ 		}
+ 	}
+ 
+ }
+ 
+ /*
+  * Setup default parameters for the Sound Blaster Z DSP. A lot more going on
+  * than the Chromebook setup.
+  */
+ static void sbz_setup_defaults(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp, stream_format;
+ 	int num_fx;
+ 	int idx, i;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return;
+ 
+ 	sbz_dsp_scp_startup(codec);
+ 
+ 	sbz_init_analog_mics(codec);
+ 
+ 	sbz_connect_streams(codec);
+ 
+ 	sbz_chipio_startup_data(codec);
+ 
+ 	chipio_set_stream_control(codec, 0x03, 1);
+ 	chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 	/*
+ 	 * Sets internal input loopback to off, used to have a switch to
+ 	 * enable input loopback, but turned out to be way too buggy.
+ 	 */
+ 	tmp = FLOAT_ONE;
+ 	dspio_set_uint_param(codec, 0x37, 0x08, tmp);
+ 	dspio_set_uint_param(codec, 0x37, 0x10, tmp);
+ 
+ 	/*remove DSP headroom*/
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x3C, tmp);
+ 
+ 	/* set WUH source */
+ 	tmp = FLOAT_TWO;
+ 	dspio_set_uint_param(codec, 0x31, 0x00, tmp);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);
+ 
+ 	/* Set speaker source? */
+ 	dspio_set_uint_param(codec, 0x32, 0x00, tmp);
+ 
+ 	sbz_dsp_initial_mic_setup(codec);
+ 
+ 
+ 	/* out, in effects + voicefx */
+ 	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;
+ 	for (idx = 0; idx < num_fx; idx++) {
+ 		for (i = 0; i <= ca0132_effects[idx].params; i++) {
+ 			dspio_set_uint_param(codec,
+ 					ca0132_effects[idx].mid,
+ 					ca0132_effects[idx].reqs[i],
+ 					ca0132_effects[idx].def_vals[i]);
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Have to make a stream to bind the sound output to, otherwise
+ 	 * you'll get dead audio. Before I did this, it would bind to an
+ 	 * audio input, and would never work
+ 	 */
+ 	stream_format = snd_hdac_calc_stream_format(48000, 2,
+ 			SNDRV_PCM_FORMAT_S32_LE, 32, 0);
+ 
+ 	snd_hda_codec_setup_stream(codec, spec->dacs[0], spec->dsp_stream_id,
+ 					0, stream_format);
+ 
+ 	snd_hda_codec_cleanup_stream(codec, spec->dacs[0]);
+ 
+ 	snd_hda_codec_setup_stream(codec, spec->dacs[0], spec->dsp_stream_id,
+ 					0, stream_format);
+ 
+ 	snd_hda_codec_cleanup_stream(codec, spec->dacs[0]);
+ }
+ 
+ /*
++>>>>>>> 447fd8e9a88e (ALSA: hda/ca0132: add the ability to set src_id on scp commands)
   * Initialization of flags in chip
   */
  static void ca0132_init_flags(struct hda_codec *codec)
* Unmerged path sound/pci/hda/patch_ca0132.c
