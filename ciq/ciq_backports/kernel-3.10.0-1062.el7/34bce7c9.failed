x86/speculation: Disable STIBP when enhanced IBRS is in use

jira LE-1907
cve CVE-2019-11091
cve CVE-2018-12130
cve CVE-2018-12127
cve CVE-2018-12126
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] speculation: Disable STIBP when enhanced IBRS is in use (Waiman Long) [1709296 1690358 1690348 1690335] {CVE-2018-12126 CVE-2018-12127 CVE-2018-12130 CVE-2019-11091}
Rebuild_FUZZ: 96.49%
commit-author Tim Chen <tim.c.chen@linux.intel.com>
commit 34bce7c9690b1d897686aac89604ba7adc365556
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/34bce7c9.failed

If enhanced IBRS is active, STIBP is redundant for mitigating Spectre v2
user space exploits from hyperthread sibling.

Disable STIBP when enhanced IBRS is used.

	Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Ingo Molnar <mingo@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Jiri Kosina <jkosina@suse.cz>
	Cc: Tom Lendacky <thomas.lendacky@amd.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: David Woodhouse <dwmw@amazon.co.uk>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Dave Hansen <dave.hansen@intel.com>
	Cc: Casey Schaufler <casey.schaufler@intel.com>
	Cc: Asit Mallick <asit.k.mallick@intel.com>
	Cc: Arjan van de Ven <arjan@linux.intel.com>
	Cc: Jon Masters <jcm@redhat.com>
	Cc: Waiman Long <longman9394@gmail.com>
	Cc: Greg KH <gregkh@linuxfoundation.org>
	Cc: Dave Stewart <david.c.stewart@intel.com>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: stable@vger.kernel.org
Link: https://lkml.kernel.org/r/20181125185003.966801480@linutronix.de


(cherry picked from commit 34bce7c9690b1d897686aac89604ba7adc365556)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/kernel/cpu/bugs.c
index 12a489be7869,924cd06dd43b..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -148,41 -255,115 +148,90 @@@ static inline bool match_option(const c
  	return len == arglen && !strncmp(arg, opt, len);
  }
  
 -static const struct {
 -	const char *option;
 -	enum spectre_v2_mitigation_cmd cmd;
 -	bool secure;
 -} mitigation_options[] = {
 -	{ "off",               SPECTRE_V2_CMD_NONE,              false },
 -	{ "on",                SPECTRE_V2_CMD_FORCE,             true },
 -	{ "retpoline",         SPECTRE_V2_CMD_RETPOLINE,         false },
 -	{ "retpoline,amd",     SPECTRE_V2_CMD_RETPOLINE_AMD,     false },
 -	{ "retpoline,generic", SPECTRE_V2_CMD_RETPOLINE_GENERIC, false },
 -	{ "auto",              SPECTRE_V2_CMD_AUTO,              false },
 -};
 -
 -static enum spectre_v2_mitigation_cmd __init spectre_v2_parse_cmdline(void)
 +static enum spectre_v2_mitigation_cmd spectre_v2_parse_cmdline(void)
  {
  	char arg[20];
 -	int ret, i;
 -	enum spectre_v2_mitigation_cmd cmd = SPECTRE_V2_CMD_AUTO;
 -
 -	if (cmdline_find_option_bool(boot_command_line, "nospectre_v2"))
 -		return SPECTRE_V2_CMD_NONE;
 -
 -	ret = cmdline_find_option(boot_command_line, "spectre_v2", arg, sizeof(arg));
 -	if (ret < 0)
 -		return SPECTRE_V2_CMD_AUTO;
 -
 -	for (i = 0; i < ARRAY_SIZE(mitigation_options); i++) {
 -		if (!match_option(arg, ret, mitigation_options[i].option))
 -			continue;
 -		cmd = mitigation_options[i].cmd;
 -		break;
 -	}
 -
 -	if (i >= ARRAY_SIZE(mitigation_options)) {
 -		pr_err("unknown option (%s). Switching to AUTO select\n", arg);
 -		return SPECTRE_V2_CMD_AUTO;
 -	}
 -
 -	if ((cmd == SPECTRE_V2_CMD_RETPOLINE ||
 -	     cmd == SPECTRE_V2_CMD_RETPOLINE_AMD ||
 -	     cmd == SPECTRE_V2_CMD_RETPOLINE_GENERIC) &&
 -	    !IS_ENABLED(CONFIG_RETPOLINE)) {
 -		pr_err("%s selected but not compiled in. Switching to AUTO select\n", mitigation_options[i].option);
 -		return SPECTRE_V2_CMD_AUTO;
 +	int ret;
 +
 +	ret = cmdline_find_option(boot_command_line, "spectre_v2", arg,
 +				  sizeof(arg));
 +	if (ret > 0)  {
 +		if (match_option(arg, ret, "off")) {
 +			goto disable;
 +		} else if (match_option(arg, ret, "on")) {
 +			return SPECTRE_V2_CMD_FORCE;
 +		} else if (match_option(arg, ret, "retpoline")) {
 +			return SPECTRE_V2_CMD_RETPOLINE;
 +		} else if (match_option(arg, ret, "retpoline,ibrs_user")) {
 +			return SPECTRE_V2_CMD_RETPOLINE_IBRS_USER;
 +		} else if (match_option(arg, ret, "ibrs")) {
 +			return SPECTRE_V2_CMD_IBRS;
 +		} else if (match_option(arg, ret, "ibrs_always")) {
 +			return SPECTRE_V2_CMD_IBRS_ALWAYS;
 +		} else if (match_option(arg, ret, "auto")) {
 +			return SPECTRE_V2_CMD_AUTO;
 +		}
  	}
  
 -	if (cmd == SPECTRE_V2_CMD_RETPOLINE_AMD &&
 -	    boot_cpu_data.x86_vendor != X86_VENDOR_HYGON &&
 -	    boot_cpu_data.x86_vendor != X86_VENDOR_AMD) {
 -		pr_err("retpoline,amd selected but CPU is not AMD. Switching to AUTO select\n");
 +	if (!cmdline_find_option_bool(boot_command_line, "nospectre_v2"))
  		return SPECTRE_V2_CMD_AUTO;
 -	}
 -
 -	if (mitigation_options[i].secure)
 -		spec2_print_if_secure(mitigation_options[i].option);
 -	else
 -		spec2_print_if_insecure(mitigation_options[i].option);
 -
 -	return cmd;
 +disable:
 +	return SPECTRE_V2_CMD_NONE;
  }
  
 -static bool stibp_needed(void)
 +void __spectre_v2_select_mitigation(void)
  {
++<<<<<<< HEAD
 +	const bool full_retpoline = IS_ENABLED(CONFIG_RETPOLINE) && retp_compiler();
 +	enum spectre_v2_mitigation_cmd cmd = spectre_v2_cmd;
++=======
+ 	if (spectre_v2_enabled == SPECTRE_V2_NONE)
+ 		return false;
+ 
+ 	/* Enhanced IBRS makes using STIBP unnecessary. */
+ 	if (spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)
+ 		return false;
+ 
+ 	if (!boot_cpu_has(X86_FEATURE_STIBP))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static void update_stibp_msr(void *info)
+ {
+ 	wrmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base);
+ }
+ 
+ void arch_smt_update(void)
+ {
+ 	u64 mask;
+ 
+ 	if (!stibp_needed())
+ 		return;
+ 
+ 	mutex_lock(&spec_ctrl_mutex);
+ 	mask = x86_spec_ctrl_base;
+ 	if (cpu_smt_control == CPU_SMT_ENABLED)
+ 		mask |= SPEC_CTRL_STIBP;
+ 	else
+ 		mask &= ~SPEC_CTRL_STIBP;
+ 
+ 	if (mask != x86_spec_ctrl_base) {
+ 		pr_info("Spectre v2 cross-process SMT mitigation: %s STIBP\n",
+ 				cpu_smt_control == CPU_SMT_ENABLED ?
+ 				"Enabling" : "Disabling");
+ 		x86_spec_ctrl_base = mask;
+ 		on_each_cpu(update_stibp_msr, NULL, 1);
+ 	}
+ 	mutex_unlock(&spec_ctrl_mutex);
+ }
+ 
+ static void __init spectre_v2_select_mitigation(void)
+ {
+ 	enum spectre_v2_mitigation_cmd cmd = spectre_v2_parse_cmdline();
+ 	enum spectre_v2_mitigation mode = SPECTRE_V2_NONE;
++>>>>>>> 34bce7c9690b (x86/speculation: Disable STIBP when enhanced IBRS is in use)
  
  	/*
  	 * If the CPU is not affected and the command line mode is NONE or AUTO
@@@ -604,8 -848,27 +653,30 @@@ static ssize_t l1tf_show_state(char *bu
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ static char *stibp_state(void)
+ {
+ 	if (spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)
+ 		return "";
+ 
+ 	if (x86_spec_ctrl_base & SPEC_CTRL_STIBP)
+ 		return ", STIBP";
+ 	else
+ 		return "";
+ }
+ 
+ static char *ibpb_state(void)
+ {
+ 	if (boot_cpu_has(X86_FEATURE_USE_IBPB))
+ 		return ", IBPB";
+ 	else
+ 		return "";
+ }
+ 
++>>>>>>> 34bce7c9690b (x86/speculation: Disable STIBP when enhanced IBRS is in use)
  static ssize_t cpu_show_common(struct device *dev, struct device_attribute *attr,
 -			       char *buf, unsigned int bug)
 +			char *buf, unsigned int bug)
  {
  	if (!boot_cpu_has_bug(bug))
  		return sprintf(buf, "Not affected\n");
* Unmerged path arch/x86/kernel/cpu/bugs.c
