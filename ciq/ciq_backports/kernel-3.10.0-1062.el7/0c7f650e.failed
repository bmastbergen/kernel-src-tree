KVM: nVMX: Enforce NMI controls on vmentry of L2 guests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Krish Sadhukhan <krish.sadhukhan@oracle.com>
commit 0c7f650e106c3f045d9f8d1c1c7eb6f5596508b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0c7f650e.failed

According to Intel SDM 26.2.1.1, the following rules should be enforced
on vmentry:

 *  If the "NMI exiting" VM-execution control is 0, "Virtual NMIs"
    VM-execution control must be 0.
 *  If the “virtual NMIs” VM-execution control is 0, the “NMI-window
    exiting” VM-execution control must be 0.

This patch enforces these rules when entering an L2 guest.

	Signed-off-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>
	Reviewed-by: Liran Alon <liran.alon@oracle.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 0c7f650e106c3f045d9f8d1c1c7eb6f5596508b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index e0eeb7f8160f,5726cee43f4f..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -10635,25 -11028,43 +10657,48 @@@ static int check_vmentry_prereqs(struc
  		return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
  
  	if (!vmx_control_verify(vmcs12->cpu_based_vm_exec_control,
 -				vmx->nested.msrs.procbased_ctls_low,
 -				vmx->nested.msrs.procbased_ctls_high) ||
 +				vmx->nested.nested_vmx_true_procbased_ctls_low,
 +				vmx->nested.nested_vmx_procbased_ctls_high) ||
  	    (nested_cpu_has(vmcs12, CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&
  	     !vmx_control_verify(vmcs12->secondary_vm_exec_control,
 -				 vmx->nested.msrs.secondary_ctls_low,
 -				 vmx->nested.msrs.secondary_ctls_high)) ||
 +				 vmx->nested.nested_vmx_secondary_ctls_low,
 +				 vmx->nested.nested_vmx_secondary_ctls_high)) ||
  	    !vmx_control_verify(vmcs12->pin_based_vm_exec_control,
 -				vmx->nested.msrs.pinbased_ctls_low,
 -				vmx->nested.msrs.pinbased_ctls_high) ||
 +				vmx->nested.nested_vmx_pinbased_ctls_low,
 +				vmx->nested.nested_vmx_pinbased_ctls_high) ||
  	    !vmx_control_verify(vmcs12->vm_exit_controls,
 -				vmx->nested.msrs.exit_ctls_low,
 -				vmx->nested.msrs.exit_ctls_high) ||
 +				vmx->nested.nested_vmx_true_exit_ctls_low,
 +				vmx->nested.nested_vmx_exit_ctls_high) ||
  	    !vmx_control_verify(vmcs12->vm_entry_controls,
 -				vmx->nested.msrs.entry_ctls_low,
 -				vmx->nested.msrs.entry_ctls_high))
 +				vmx->nested.nested_vmx_true_entry_ctls_low,
 +				vmx->nested.nested_vmx_entry_ctls_high))
  		return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
  
++<<<<<<< HEAD
 +	if (((vmcs12->host_cr0 & VMXON_CR0_ALWAYSON) != VMXON_CR0_ALWAYSON) ||
 +	    ((vmcs12->host_cr4 & VMXON_CR4_ALWAYSON) != VMXON_CR4_ALWAYSON) ||
++=======
+ 	if (nested_vmx_check_nmi_controls(vmcs12))
+ 		return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
+ 
+ 	if (nested_cpu_has_vmfunc(vmcs12)) {
+ 		if (vmcs12->vm_function_control &
+ 		    ~vmx->nested.msrs.vmfunc_controls)
+ 			return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
+ 
+ 		if (nested_cpu_has_eptp_switching(vmcs12)) {
+ 			if (!nested_cpu_has_ept(vmcs12) ||
+ 			    !page_address_valid(vcpu, vmcs12->eptp_list_address))
+ 				return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
+ 		}
+ 	}
+ 
+ 	if (vmcs12->cr3_target_count > nested_cpu_vmx_misc_cr3_count(vcpu))
+ 		return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
+ 
+ 	if (!nested_host_cr0_valid(vcpu, vmcs12->host_cr0) ||
+ 	    !nested_host_cr4_valid(vcpu, vmcs12->host_cr4) ||
++>>>>>>> 0c7f650e106c (KVM: nVMX: Enforce NMI controls on vmentry of L2 guests)
  	    !nested_cr3_valid(vcpu, vmcs12->host_cr3))
  		return VMXERR_ENTRY_INVALID_HOST_STATE_FIELD;
  
* Unmerged path arch/x86/kvm/vmx.c
