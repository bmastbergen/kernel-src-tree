xfs: use correct state defines in xfs_bmap_del_extent_{cow,delay}

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [fs] xfs: use correct state defines in xfs_bmap_del_extent_{cow, delay} (Brian Foster) [1613405]
Rebuild_FUZZ: 99.24%
commit-author Christoph Hellwig <hch@lst.de>
commit 0173c689ff4c0855e24ceb898274af1339b5db48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0173c689.failed

Use the _FILLING values to match the usage in the xfs_bmap_add_extent_*
helpers.  No change in behavior, just better naming in the code and
tracepoint output.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reported-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 0173c689ff4c0855e24ceb898274af1339b5db48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 7800126fabda,8c5b7e624917..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -4660,12 -4841,228 +4660,231 @@@ xfs_bmap_split_indlen
  	return stolen;
  }
  
++<<<<<<< HEAD
++=======
+ int
+ xfs_bmap_del_extent_delay(
+ 	struct xfs_inode	*ip,
+ 	int			whichfork,
+ 	xfs_extnum_t		*idx,
+ 	struct xfs_bmbt_irec	*got,
+ 	struct xfs_bmbt_irec	*del)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	struct xfs_bmbt_irec	new;
+ 	int64_t			da_old, da_new, da_diff = 0;
+ 	xfs_fileoff_t		del_endoff, got_endoff;
+ 	xfs_filblks_t		got_indlen, new_indlen, stolen;
+ 	int			error = 0, state = 0;
+ 	bool			isrt;
+ 
+ 	XFS_STATS_INC(mp, xs_del_exlist);
+ 
+ 	isrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);
+ 	del_endoff = del->br_startoff + del->br_blockcount;
+ 	got_endoff = got->br_startoff + got->br_blockcount;
+ 	da_old = startblockval(got->br_startblock);
+ 	da_new = 0;
+ 
+ 	ASSERT(*idx >= 0);
+ 	ASSERT(*idx <= xfs_iext_count(ifp));
+ 	ASSERT(del->br_blockcount > 0);
+ 	ASSERT(got->br_startoff <= del->br_startoff);
+ 	ASSERT(got_endoff >= del_endoff);
+ 
+ 	if (isrt) {
+ 		uint64_t rtexts = XFS_FSB_TO_B(mp, del->br_blockcount);
+ 
+ 		do_div(rtexts, mp->m_sb.sb_rextsize);
+ 		xfs_mod_frextents(mp, rtexts);
+ 	}
+ 
+ 	/*
+ 	 * Update the inode delalloc counter now and wait to update the
+ 	 * sb counters as we might have to borrow some blocks for the
+ 	 * indirect block accounting.
+ 	 */
+ 	error = xfs_trans_reserve_quota_nblks(NULL, ip,
+ 			-((long)del->br_blockcount), 0,
+ 			isrt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);
+ 	if (error)
+ 		return error;
+ 	ip->i_delayed_blks -= del->br_blockcount;
+ 
+ 	if (whichfork == XFS_COW_FORK)
+ 		state |= BMAP_COWFORK;
+ 
+ 	if (got->br_startoff == del->br_startoff)
+ 		state |= BMAP_LEFT_FILLING;
+ 	if (got_endoff == del_endoff)
+ 		state |= BMAP_RIGHT_FILLING;
+ 
+ 	switch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {
+ 	case BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Matches the whole extent.  Delete the entry.
+ 		 */
+ 		xfs_iext_remove(ip, *idx, 1, state);
+ 		--*idx;
+ 		break;
+ 	case BMAP_LEFT_FILLING:
+ 		/*
+ 		 * Deleting the first part of the extent.
+ 		 */
+ 		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
+ 		got->br_startoff = del_endoff;
+ 		got->br_blockcount -= del->br_blockcount;
+ 		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
+ 				got->br_blockcount), da_old);
+ 		got->br_startblock = nullstartblock((int)da_new);
+ 		xfs_iext_update_extent(ifp, *idx, got);
+ 		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
+ 		break;
+ 	case BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Deleting the last part of the extent.
+ 		 */
+ 		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
+ 		got->br_blockcount = got->br_blockcount - del->br_blockcount;
+ 		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
+ 				got->br_blockcount), da_old);
+ 		got->br_startblock = nullstartblock((int)da_new);
+ 		xfs_iext_update_extent(ifp, *idx, got);
+ 		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
+ 		break;
+ 	case 0:
+ 		/*
+ 		 * Deleting the middle of the extent.
+ 		 *
+ 		 * Distribute the original indlen reservation across the two new
+ 		 * extents.  Steal blocks from the deleted extent if necessary.
+ 		 * Stealing blocks simply fudges the fdblocks accounting below.
+ 		 * Warn if either of the new indlen reservations is zero as this
+ 		 * can lead to delalloc problems.
+ 		 */
+ 		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
+ 
+ 		got->br_blockcount = del->br_startoff - got->br_startoff;
+ 		got_indlen = xfs_bmap_worst_indlen(ip, got->br_blockcount);
+ 
+ 		new.br_blockcount = got_endoff - del_endoff;
+ 		new_indlen = xfs_bmap_worst_indlen(ip, new.br_blockcount);
+ 
+ 		WARN_ON_ONCE(!got_indlen || !new_indlen);
+ 		stolen = xfs_bmap_split_indlen(da_old, &got_indlen, &new_indlen,
+ 						       del->br_blockcount);
+ 
+ 		got->br_startblock = nullstartblock((int)got_indlen);
+ 		xfs_iext_update_extent(ifp, *idx, got);
+ 		trace_xfs_bmap_post_update(ip, *idx, 0, _THIS_IP_);
+ 
+ 		new.br_startoff = del_endoff;
+ 		new.br_state = got->br_state;
+ 		new.br_startblock = nullstartblock((int)new_indlen);
+ 
+ 		++*idx;
+ 		xfs_iext_insert(ip, *idx, 1, &new, state);
+ 
+ 		da_new = got_indlen + new_indlen - stolen;
+ 		del->br_blockcount -= stolen;
+ 		break;
+ 	}
+ 
+ 	ASSERT(da_old >= da_new);
+ 	da_diff = da_old - da_new;
+ 	if (!isrt)
+ 		da_diff += del->br_blockcount;
+ 	if (da_diff)
+ 		xfs_mod_fdblocks(mp, da_diff, false);
+ 	return error;
+ }
+ 
+ void
+ xfs_bmap_del_extent_cow(
+ 	struct xfs_inode	*ip,
+ 	xfs_extnum_t		*idx,
+ 	struct xfs_bmbt_irec	*got,
+ 	struct xfs_bmbt_irec	*del)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, XFS_COW_FORK);
+ 	struct xfs_bmbt_irec	new;
+ 	xfs_fileoff_t		del_endoff, got_endoff;
+ 	int			state = BMAP_COWFORK;
+ 
+ 	XFS_STATS_INC(mp, xs_del_exlist);
+ 
+ 	del_endoff = del->br_startoff + del->br_blockcount;
+ 	got_endoff = got->br_startoff + got->br_blockcount;
+ 
+ 	ASSERT(*idx >= 0);
+ 	ASSERT(*idx <= xfs_iext_count(ifp));
+ 	ASSERT(del->br_blockcount > 0);
+ 	ASSERT(got->br_startoff <= del->br_startoff);
+ 	ASSERT(got_endoff >= del_endoff);
+ 	ASSERT(!isnullstartblock(got->br_startblock));
+ 
+ 	if (got->br_startoff == del->br_startoff)
+ 		state |= BMAP_LEFT_FILLING;
+ 	if (got_endoff == del_endoff)
+ 		state |= BMAP_RIGHT_FILLING;
+ 
+ 	switch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {
+ 	case BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Matches the whole extent.  Delete the entry.
+ 		 */
+ 		xfs_iext_remove(ip, *idx, 1, state);
+ 		--*idx;
+ 		break;
+ 	case BMAP_LEFT_FILLING:
+ 		/*
+ 		 * Deleting the first part of the extent.
+ 		 */
+ 		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
+ 		got->br_startoff = del_endoff;
+ 		got->br_blockcount -= del->br_blockcount;
+ 		got->br_startblock = del->br_startblock + del->br_blockcount;
+ 		xfs_iext_update_extent(ifp, *idx, got);
+ 		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
+ 		break;
+ 	case BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Deleting the last part of the extent.
+ 		 */
+ 		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
+ 		got->br_blockcount -= del->br_blockcount;
+ 		xfs_iext_update_extent(ifp, *idx, got);
+ 		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
+ 		break;
+ 	case 0:
+ 		/*
+ 		 * Deleting the middle of the extent.
+ 		 */
+ 		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
+ 		got->br_blockcount = del->br_startoff - got->br_startoff;
+ 		xfs_iext_update_extent(ifp, *idx, got);
+ 		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
+ 
+ 		new.br_startoff = del_endoff;
+ 		new.br_blockcount = got_endoff - del_endoff;
+ 		new.br_state = got->br_state;
+ 		new.br_startblock = del->br_startblock + del->br_blockcount;
+ 
+ 		++*idx;
+ 		xfs_iext_insert(ip, *idx, 1, &new, state);
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 0173c689ff4c (xfs: use correct state defines in xfs_bmap_del_extent_{cow,delay})
  /*
   * Called by xfs_bmapi to update file extent records and the btree
 - * after removing space.
 + * after removing space (or undoing a delayed allocation).
   */
  STATIC int				/* error */
 -xfs_bmap_del_extent_real(
 +xfs_bmap_del_extent(
  	xfs_inode_t		*ip,	/* incore inode pointer */
  	xfs_trans_t		*tp,	/* current transaction pointer */
  	xfs_extnum_t		*idx,	/* extent number to update/delete */
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
