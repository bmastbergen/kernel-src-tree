rtnetlink: add helpers to dump netnsid information

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Florian Westphal <fw@strlen.de>
commit b1e66b9a67d67d0e73091b04b51e524581c8c887
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b1e66b9a.failed

	Reviewed-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b1e66b9a67d67d0e73091b04b51e524581c8c887)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/rtnetlink.c
diff --cc net/core/rtnetlink.c
index c70e7cdc57f8,d524609c587c..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1365,12 -1337,52 +1365,58 @@@ static u32 rtnl_get_event(unsigned lon
  	return rtnl_event_type;
  }
  
++<<<<<<< HEAD
 +static int rtnl_fill_ifinfo(struct sk_buff *skb,
 +			    struct net_device *dev, struct net *src_net,
++=======
+ static int put_master_ifindex(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	const struct net_device *upper_dev;
+ 	int ret = 0;
+ 
+ 	rcu_read_lock();
+ 
+ 	upper_dev = netdev_master_upper_dev_get_rcu(dev);
+ 	if (upper_dev)
+ 		ret = nla_put_u32(skb, IFLA_MASTER, upper_dev->ifindex);
+ 
+ 	rcu_read_unlock();
+ 	return ret;
+ }
+ 
+ static int nla_put_iflink(struct sk_buff *skb, const struct net_device *dev)
+ {
+ 	int ifindex = dev_get_iflink(dev);
+ 
+ 	if (dev->ifindex == ifindex)
+ 		return 0;
+ 
+ 	return nla_put_u32(skb, IFLA_LINK, ifindex);
+ }
+ 
+ static int rtnl_fill_link_netnsid(struct sk_buff *skb,
+ 				  const struct net_device *dev)
+ {
+ 	if (dev->rtnl_link_ops && dev->rtnl_link_ops->get_link_net) {
+ 		struct net *link_net = dev->rtnl_link_ops->get_link_net(dev);
+ 
+ 		if (!net_eq(dev_net(dev), link_net)) {
+ 			int id = peernet2id_alloc(dev_net(dev), link_net);
+ 
+ 			if (nla_put_s32(skb, IFLA_LINK_NETNSID, id))
+ 				return -EMSGSIZE;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
++>>>>>>> b1e66b9a67d6 (rtnetlink: add helpers to dump netnsid information)
  			    int type, u32 pid, u32 seq, u32 change,
  			    unsigned int flags, u32 ext_filter_mask,
 -			    u32 event)
 +			    u32 event, int *new_nsid, int new_ifindex,
 +			    int tgt_netnsid)
  {
  	struct ifinfomsg *ifm;
  	struct nlmsghdr *nlh;
@@@ -1477,25 -1468,8 +1523,30 @@@
  			goto nla_put_failure;
  	}
  
++<<<<<<< HEAD
 +	if (dev->rtnl_link_ops &&
 +	    dev->rtnl_link_ops->get_link_net) {
 +		struct net *link_net = dev->rtnl_link_ops->get_link_net(dev);
 +
 +		if (!net_eq(dev_net(dev), link_net)) {
 +			int id = peernet2id_alloc(src_net, link_net);
 +
 +			if (nla_put_s32(skb, IFLA_LINK_NETNSID, id))
 +				goto nla_put_failure;
 +		}
 +	}
++=======
+ 	if (rtnl_fill_link_netnsid(skb, dev))
+ 		goto nla_put_failure;
++>>>>>>> b1e66b9a67d6 (rtnetlink: add helpers to dump netnsid information)
 +
 +	if (new_nsid &&
 +	    nla_put_s32(skb, IFLA_NEW_NETNSID, *new_nsid) < 0)
 +		goto nla_put_failure;
 +	if (new_ifindex &&
 +	    nla_put_s32(skb, IFLA_NEW_IFINDEX, new_ifindex) < 0)
 +		goto nla_put_failure;
 +
  
  	if (!(af_spec = nla_nest_start(skb, IFLA_AF_SPEC)))
  		goto nla_put_failure;
* Unmerged path net/core/rtnetlink.c
