perf tests: Add LLVM test for eBPF on-the-fly compiling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit 9bc898c7019383b6aa2ae6cb2928c4ca926449f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9bc898c7.failed

Previous patches introduce llvm__compile_bpf() to compile source file to
eBPF object. This patch adds testcase to test it. It also tests libbpf
by opening generated object after applying next patch which introduces
HAVE_LIBBPF_SUPPORT option.

Since llvm__compile_bpf() prints long messages which users who don't
explicitly test llvm doesn't care, this patch set verbose to -1 to
suppress all debug, warning and error message, and hint user use 'perf
test -v' to see the full output.

For the same reason, if clang is not found in PATH and there's no [llvm]
section in .perfconfig, skip this test.

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Acked-by: Alexei Starovoitov <ast@plumgrid.com>
	Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
	Cc: Daniel Borkmann <daniel@iogearbox.net>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Kaixu Xia <xiakaixu@huawei.com>
	Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/n/1436445342-1402-17-git-send-email-wangnan0@huawei.com
[ Add tools/lib/bpf/ to tools/perf/MANIFEST, so that the tarball targets build ]
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 9bc898c7019383b6aa2ae6cb2928c4ca926449f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/MANIFEST
#	tools/perf/tests/Build
#	tools/perf/tests/builtin-test.c
#	tools/perf/tests/tests.h
#	tools/perf/util/llvm-utils.c
#	tools/perf/util/llvm-utils.h
diff --cc tools/perf/MANIFEST
index a668348ae289,f31f15a5f873..000000000000
--- a/tools/perf/MANIFEST
+++ b/tools/perf/MANIFEST
@@@ -1,17 -1,82 +1,21 @@@
  tools/perf
 -tools/arch/alpha/include/asm/barrier.h
 -tools/arch/arm/include/asm/barrier.h
 -tools/arch/ia64/include/asm/barrier.h
 -tools/arch/mips/include/asm/barrier.h
 -tools/arch/powerpc/include/asm/barrier.h
 -tools/arch/s390/include/asm/barrier.h
 -tools/arch/sh/include/asm/barrier.h
 -tools/arch/sparc/include/asm/barrier.h
 -tools/arch/sparc/include/asm/barrier_32.h
 -tools/arch/sparc/include/asm/barrier_64.h
 -tools/arch/tile/include/asm/barrier.h
 -tools/arch/x86/include/asm/barrier.h
 -tools/arch/xtensa/include/asm/barrier.h
 +tools/arch
  tools/scripts
  tools/build
 -tools/arch/x86/include/asm/atomic.h
 -tools/arch/x86/include/asm/rmwcc.h
 +tools/include
  tools/lib/traceevent
  tools/lib/api
++<<<<<<< HEAD
 +tools/lib/subcmd
++=======
+ tools/lib/bpf
++>>>>>>> 9bc898c70193 (perf tests: Add LLVM test for eBPF on-the-fly compiling)
  tools/lib/hweight.c
  tools/lib/rbtree.c
 +tools/lib/string.c
  tools/lib/symbol/kallsyms.c
  tools/lib/symbol/kallsyms.h
 -tools/lib/util/find_next_bit.c
 -tools/include/asm/atomic.h
 -tools/include/asm/barrier.h
 -tools/include/asm/bug.h
 -tools/include/asm-generic/barrier.h
 -tools/include/asm-generic/bitops/arch_hweight.h
 -tools/include/asm-generic/bitops/atomic.h
 -tools/include/asm-generic/bitops/const_hweight.h
 -tools/include/asm-generic/bitops/__ffs.h
 -tools/include/asm-generic/bitops/__fls.h
 -tools/include/asm-generic/bitops/find.h
 -tools/include/asm-generic/bitops/fls64.h
 -tools/include/asm-generic/bitops/fls.h
 -tools/include/asm-generic/bitops/hweight.h
 -tools/include/asm-generic/bitops.h
 -tools/include/linux/atomic.h
 -tools/include/linux/bitops.h
 -tools/include/linux/compiler.h
 -tools/include/linux/export.h
 -tools/include/linux/hash.h
 -tools/include/linux/kernel.h
 -tools/include/linux/list.h
 -tools/include/linux/log2.h
 -tools/include/linux/poison.h
 -tools/include/linux/rbtree.h
 -tools/include/linux/rbtree_augmented.h
 -tools/include/linux/types.h
 -include/asm-generic/bitops/arch_hweight.h
 -include/asm-generic/bitops/const_hweight.h
 -include/asm-generic/bitops/fls64.h
 -include/asm-generic/bitops/__fls.h
 -include/asm-generic/bitops/fls.h
 -include/linux/perf_event.h
 -include/linux/list.h
 -include/linux/hash.h
 -include/linux/stringify.h
 -include/linux/swab.h
 -arch/*/include/asm/unistd*.h
 -arch/*/include/uapi/asm/unistd*.h
 -arch/*/include/uapi/asm/perf_regs.h
 -arch/*/lib/memcpy*.S
 -arch/*/lib/memset*.S
 -include/linux/poison.h
 -include/linux/hw_breakpoint.h
 -include/uapi/linux/perf_event.h
 -include/uapi/linux/const.h
 -include/uapi/linux/swab.h
 -include/uapi/linux/hw_breakpoint.h
 -arch/x86/include/asm/svm.h
 -arch/x86/include/asm/vmx.h
 -arch/x86/include/asm/kvm_host.h
 -arch/x86/include/uapi/asm/svm.h
 -arch/x86/include/uapi/asm/vmx.h
 -arch/x86/include/uapi/asm/kvm.h
 -arch/x86/include/uapi/asm/kvm_perf.h
 -arch/s390/include/uapi/asm/sie.h
 -arch/s390/include/uapi/asm/kvm_perf.h
 +tools/lib/find_bit.c
 +tools/lib/bitmap.c
 +tools/lib/str_error_r.c
 +tools/lib/vsprintf.c
diff --cc tools/perf/tests/Build
index 40bdfc01aafe,c1518bdd0f1b..000000000000
--- a/tools/perf/tests/Build
+++ b/tools/perf/tests/Build
@@@ -31,21 -32,11 +31,25 @@@ perf-y += sample-parsing.
  perf-y += parse-no-sample-id-all.o
  perf-y += kmod-path.o
  perf-y += thread-map.o
++<<<<<<< HEAD
 +perf-y += topology.o
 +perf-y += mem.o
 +perf-y += cpumap.o
 +perf-y += stat.o
 +perf-y += event_update.o
 +perf-y += event-times.o
 +perf-y += expr.o
 +perf-y += backward-ring-buffer.o
 +perf-y += sdt.o
 +perf-y += is_printable_array.o
 +perf-y += bitmap.o
 +perf-y += perf-hooks.o
 +perf-y += unit_number__scnprintf.o
++=======
+ perf-y += llvm.o
++>>>>>>> 9bc898c70193 (perf tests: Add LLVM test for eBPF on-the-fly compiling)
  
 -perf-$(CONFIG_X86) += perf-time-to-tsc.o
 -
 -ifeq ($(ARCH),$(filter $(ARCH),x86 arm arm64))
 +ifeq ($(SRCARCH),$(filter $(SRCARCH),x86 arm arm64 powerpc))
  perf-$(CONFIG_DWARF_UNWIND) += dwarf-unwind.o
  endif
  
diff --cc tools/perf/tests/builtin-test.c
index aacfc58dac2b,136cd934be66..000000000000
--- a/tools/perf/tests/builtin-test.c
+++ b/tools/perf/tests/builtin-test.c
@@@ -179,68 -175,8 +179,73 @@@ static struct test generic_tests[] = 
  		.func = test__thread_map,
  	},
  	{
++<<<<<<< HEAD
 +		.desc = "Session topology",
 +		.func = test__session_topology,
 +	},
 +	{
 +		.desc = "Synthesize thread map",
 +		.func = test__thread_map_synthesize,
 +	},
 +	{
 +		.desc = "Remove thread map",
 +		.func = test__thread_map_remove,
 +	},
 +	{
 +		.desc = "Synthesize cpu map",
 +		.func = test__cpu_map_synthesize,
 +	},
 +	{
 +		.desc = "Synthesize stat config",
 +		.func = test__synthesize_stat_config,
 +	},
 +	{
 +		.desc = "Synthesize stat",
 +		.func = test__synthesize_stat,
 +	},
 +	{
 +		.desc = "Synthesize stat round",
 +		.func = test__synthesize_stat_round,
 +	},
 +	{
 +		.desc = "Synthesize attr update",
 +		.func = test__event_update,
 +	},
 +	{
 +		.desc = "Event times",
 +		.func = test__event_times,
 +	},
 +	{
 +		.desc = "Read backward ring buffer",
 +		.func = test__backward_ring_buffer,
 +	},
 +	{
 +		.desc = "Print cpu map",
 +		.func = test__cpu_map_print,
 +	},
 +	{
 +		.desc = "Test SDT event probing",
 +		.func = test__sdt_event,
 +	},
 +	{
 +		.desc = "is_printable_array",
 +		.func = test__is_printable_array,
 +	},
 +	{
 +		.desc = "Print bitmap",
 +		.func = test__bitmap_print,
 +	},
 +	{
 +		.desc = "perf hooks",
 +		.func = test__perf_hooks,
 +	},
 +	{
 +		.desc = "unit_number__scnprintf",
 +		.func = test__unit_number__scnprint,
++=======
+ 		.desc = "Test LLVM searching and compiling",
+ 		.func = test__llvm,
++>>>>>>> 9bc898c70193 (perf tests: Add LLVM test for eBPF on-the-fly compiling)
  	},
  	{
  		.func = NULL,
diff --cc tools/perf/tests/tests.h
index ebc72c7359d4,bf113a247987..000000000000
--- a/tools/perf/tests/tests.h
+++ b/tools/perf/tests/tests.h
@@@ -26,76 -24,47 +26,118 @@@ enum 
  	TEST_SKIP = -2,
  };
  
++<<<<<<< HEAD
 +struct test {
 +	const char *desc;
 +	int (*func)(struct test *test, int subtest);
 +	struct {
 +		bool skip_if_fail;
 +		int (*get_nr)(void);
 +		const char *(*get_desc)(int subtest);
 +	} subtest;
 +	bool (*is_supported)(void);
 +	void *priv;
 +};
++=======
+ /* Tests */
+ int test__vmlinux_matches_kallsyms(void);
+ int test__openat_syscall_event(void);
+ int test__openat_syscall_event_on_all_cpus(void);
+ int test__basic_mmap(void);
+ int test__PERF_RECORD(void);
+ int test__rdpmc(void);
+ int test__perf_evsel__roundtrip_name_test(void);
+ int test__perf_evsel__tp_sched_test(void);
+ int test__syscall_openat_tp_fields(void);
+ int test__pmu(void);
+ int test__attr(void);
+ int test__dso_data(void);
+ int test__dso_data_cache(void);
+ int test__dso_data_reopen(void);
+ int test__parse_events(void);
+ int test__hists_link(void);
+ int test__python_use(void);
+ int test__bp_signal(void);
+ int test__bp_signal_overflow(void);
+ int test__task_exit(void);
+ int test__sw_clock_freq(void);
+ int test__perf_time_to_tsc(void);
+ int test__code_reading(void);
+ int test__sample_parsing(void);
+ int test__keep_tracking(void);
+ int test__parse_no_sample_id_all(void);
+ int test__dwarf_unwind(void);
+ int test__hists_filter(void);
+ int test__mmap_thread_lookup(void);
+ int test__thread_mg_share(void);
+ int test__hists_output(void);
+ int test__hists_cumulate(void);
+ int test__switch_tracking(void);
+ int test__fdarray__filter(void);
+ int test__fdarray__add(void);
+ int test__kmod_path__parse(void);
+ int test__thread_map(void);
+ int test__llvm(void);
++>>>>>>> 9bc898c70193 (perf tests: Add LLVM test for eBPF on-the-fly compiling)
 +
 +/* Tests */
 +int test__vmlinux_matches_kallsyms(struct test *test, int subtest);
 +int test__openat_syscall_event(struct test *test, int subtest);
 +int test__openat_syscall_event_on_all_cpus(struct test *test, int subtest);
 +int test__basic_mmap(struct test *test, int subtest);
 +int test__PERF_RECORD(struct test *test, int subtest);
 +int test__perf_evsel__roundtrip_name_test(struct test *test, int subtest);
 +int test__perf_evsel__tp_sched_test(struct test *test, int subtest);
 +int test__syscall_openat_tp_fields(struct test *test, int subtest);
 +int test__pmu(struct test *test, int subtest);
 +int test__attr(struct test *test, int subtest);
 +int test__dso_data(struct test *test, int subtest);
 +int test__dso_data_cache(struct test *test, int subtest);
 +int test__dso_data_reopen(struct test *test, int subtest);
 +int test__parse_events(struct test *test, int subtest);
 +int test__hists_link(struct test *test, int subtest);
 +int test__python_use(struct test *test, int subtest);
 +int test__bp_signal(struct test *test, int subtest);
 +int test__bp_signal_overflow(struct test *test, int subtest);
 +int test__task_exit(struct test *test, int subtest);
 +int test__mem(struct test *test, int subtest);
 +int test__sw_clock_freq(struct test *test, int subtest);
 +int test__code_reading(struct test *test, int subtest);
 +int test__sample_parsing(struct test *test, int subtest);
 +int test__keep_tracking(struct test *test, int subtest);
 +int test__parse_no_sample_id_all(struct test *test, int subtest);
 +int test__dwarf_unwind(struct test *test, int subtest);
 +int test__expr(struct test *test, int subtest);
 +int test__hists_filter(struct test *test, int subtest);
 +int test__mmap_thread_lookup(struct test *test, int subtest);
 +int test__thread_mg_share(struct test *test, int subtest);
 +int test__hists_output(struct test *test, int subtest);
 +int test__hists_cumulate(struct test *test, int subtest);
 +int test__switch_tracking(struct test *test, int subtest);
 +int test__fdarray__filter(struct test *test, int subtest);
 +int test__fdarray__add(struct test *test, int subtest);
 +int test__kmod_path__parse(struct test *test, int subtest);
 +int test__thread_map(struct test *test, int subtest);
 +int test__session_topology(struct test *test, int subtest);
 +int test__thread_map_synthesize(struct test *test, int subtest);
 +int test__thread_map_remove(struct test *test, int subtest);
 +int test__cpu_map_synthesize(struct test *test, int subtest);
 +int test__synthesize_stat_config(struct test *test, int subtest);
 +int test__synthesize_stat(struct test *test, int subtest);
 +int test__synthesize_stat_round(struct test *test, int subtest);
 +int test__event_update(struct test *test, int subtest);
 +int test__event_times(struct test *test, int subtest);
 +int test__backward_ring_buffer(struct test *test, int subtest);
 +int test__cpu_map_print(struct test *test, int subtest);
 +int test__sdt_event(struct test *test, int subtest);
 +int test__is_printable_array(struct test *test, int subtest);
 +int test__bitmap_print(struct test *test, int subtest);
 +int test__perf_hooks(struct test *test, int subtest);
 +int test__unit_number__scnprint(struct test *test, int subtest);
 +
 +bool test__bp_signal_is_supported(void);
  
 -#if defined(__x86_64__) || defined(__i386__) || defined(__arm__) || defined(__aarch64__)
 +#if defined(__arm__) || defined(__aarch64__)
  #ifdef HAVE_DWARF_UNWIND_SUPPORT
  struct thread;
  struct perf_sample;
diff --cc tools/perf/util/llvm-utils.c
index 1094f8780b7a,4f6a4780bd5f..000000000000
--- a/tools/perf/util/llvm-utils.c
+++ b/tools/perf/util/llvm-utils.c
@@@ -44,10 -41,9 +45,14 @@@ int perf_llvm_config(const char *var, c
  		llvm_param.kbuild_dir = strdup(value);
  	else if (!strcmp(var, "kbuild-opts"))
  		llvm_param.kbuild_opts = strdup(value);
 -	else
 +	else {
 +		pr_debug("Invalid LLVM config option: %s\n", value);
  		return -1;
++<<<<<<< HEAD
 +	}
++=======
+ 	llvm_param.user_set_param = true;
++>>>>>>> 9bc898c70193 (perf tests: Add LLVM test for eBPF on-the-fly compiling)
  	return 0;
  }
  
diff --cc tools/perf/util/llvm-utils.h
index 5861fbff0c0d,5b3cf1c229e2..000000000000
--- a/tools/perf/util/llvm-utils.h
+++ b/tools/perf/util/llvm-utils.h
@@@ -32,11 -39,11 +39,19 @@@ struct llvm_param 
  };
  
  extern struct llvm_param llvm_param;
 -extern int perf_llvm_config(const char *var, const char *value);
 +int perf_llvm_config(const char *var, const char *value);
  
++<<<<<<< HEAD
 +int llvm__compile_bpf(const char *path, void **p_obj_buf,
 +		     size_t *p_obj_buf_sz);
 +
 +/* This function is for test__llvm() use only */
 +int llvm__search_clang(void);
++=======
+ extern int llvm__compile_bpf(const char *path, void **p_obj_buf,
+ 			     size_t *p_obj_buf_sz);
+ 
+ /* This function is for test__llvm() use only */
+ extern int llvm__search_clang(void);
++>>>>>>> 9bc898c70193 (perf tests: Add LLVM test for eBPF on-the-fly compiling)
  #endif
* Unmerged path tools/perf/MANIFEST
* Unmerged path tools/perf/tests/Build
* Unmerged path tools/perf/tests/builtin-test.c
diff --git a/tools/perf/tests/llvm.c b/tools/perf/tests/llvm.c
new file mode 100644
index 000000000000..a337356fd979
--- /dev/null
+++ b/tools/perf/tests/llvm.c
@@ -0,0 +1,98 @@
+#include <stdio.h>
+#include <bpf/libbpf.h>
+#include <util/llvm-utils.h>
+#include <util/cache.h>
+#include "tests.h"
+#include "debug.h"
+
+static int perf_config_cb(const char *var, const char *val,
+			  void *arg __maybe_unused)
+{
+	return perf_default_config(var, val, arg);
+}
+
+/*
+ * Randomly give it a "version" section since we don't really load it
+ * into kernel
+ */
+static const char test_bpf_prog[] =
+	"__attribute__((section(\"do_fork\"), used)) "
+	"int fork(void *ctx) {return 0;} "
+	"char _license[] __attribute__((section(\"license\"), used)) = \"GPL\";"
+	"int _version __attribute__((section(\"version\"), used)) = 0x40100;";
+
+#ifdef HAVE_LIBBPF_SUPPORT
+static int test__bpf_parsing(void *obj_buf, size_t obj_buf_sz)
+{
+	struct bpf_object *obj;
+
+	obj = bpf_object__open_buffer(obj_buf, obj_buf_sz);
+	if (!obj)
+		return -1;
+	bpf_object__close(obj);
+	return 0;
+}
+#else
+static int test__bpf_parsing(void *obj_buf __maybe_unused,
+			     size_t obj_buf_sz __maybe_unused)
+{
+	fprintf(stderr, " (skip bpf parsing)");
+	return 0;
+}
+#endif
+
+int test__llvm(void)
+{
+	char *tmpl_new, *clang_opt_new;
+	void *obj_buf;
+	size_t obj_buf_sz;
+	int err, old_verbose;
+
+	perf_config(perf_config_cb, NULL);
+
+	/*
+	 * Skip this test if user's .perfconfig doesn't set [llvm] section
+	 * and clang is not found in $PATH, and this is not perf test -v
+	 */
+	if (verbose == 0 && !llvm_param.user_set_param && llvm__search_clang()) {
+		fprintf(stderr, " (no clang, try 'perf test -v LLVM')");
+		return TEST_SKIP;
+	}
+
+	old_verbose = verbose;
+	/*
+	 * llvm is verbosity when error. Suppress all error output if
+	 * not 'perf test -v'.
+	 */
+	if (verbose == 0)
+		verbose = -1;
+
+	if (!llvm_param.clang_bpf_cmd_template)
+		return -1;
+
+	if (!llvm_param.clang_opt)
+		llvm_param.clang_opt = strdup("");
+
+	err = asprintf(&tmpl_new, "echo '%s' | %s", test_bpf_prog,
+		       llvm_param.clang_bpf_cmd_template);
+	if (err < 0)
+		return -1;
+	err = asprintf(&clang_opt_new, "-xc %s", llvm_param.clang_opt);
+	if (err < 0)
+		return -1;
+
+	llvm_param.clang_bpf_cmd_template = tmpl_new;
+	llvm_param.clang_opt = clang_opt_new;
+	err = llvm__compile_bpf("-", &obj_buf, &obj_buf_sz);
+
+	verbose = old_verbose;
+	if (err) {
+		if (!verbose)
+			fprintf(stderr, " (use -v to see error message)");
+		return -1;
+	}
+
+	err = test__bpf_parsing(obj_buf, obj_buf_sz);
+	free(obj_buf);
+	return err;
+}
* Unmerged path tools/perf/tests/tests.h
* Unmerged path tools/perf/util/llvm-utils.c
* Unmerged path tools/perf/util/llvm-utils.h
