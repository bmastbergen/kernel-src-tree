xfs: refactor xfs_del_extent_real

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 48fd52b16d74b937f44f87f942ddaff5e3e3db64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/48fd52b1.failed

Use xfs_iext_update_extent to update entries in the in-core extent list.
This isolates the function from the detailed layout of the extent list,
and generally makes the code a lot more readable.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 48fd52b16d74b937f44f87f942ddaff5e3e3db64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 7800126fabda,6d1efe387cf0..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -4673,18 -5070,15 +4673,22 @@@ xfs_bmap_del_extent
  	xfs_btree_cur_t		*cur,	/* if null, not a btree */
  	xfs_bmbt_irec_t		*del,	/* data to remove from extents */
  	int			*logflagsp, /* inode logging flags */
 -	int			whichfork, /* data or attr fork */
 -	int			bflags)	/* bmapi flags */
 +	int			whichfork) /* data or attr fork */
  {
 +	xfs_filblks_t		da_new;	/* new delay-alloc indirect blocks */
 +	xfs_filblks_t		da_old;	/* old delay-alloc indirect blocks */
  	xfs_fsblock_t		del_endblock=0;	/* first block past del */
  	xfs_fileoff_t		del_endoff;	/* first offset past del */
 +	int			delay;	/* current block is delayed allocated */
  	int			do_fx;	/* free extent at end of routine */
- 	xfs_bmbt_rec_host_t	*ep;	/* current extent entry pointer */
  	int			error;	/* error return value */
++<<<<<<< HEAD
 +	int			flags;	/* inode logging flags */
 +	xfs_bmbt_irec_t		got;	/* current extent entry */
++=======
+ 	int			flags = 0;/* inode logging flags */
+ 	struct xfs_bmbt_irec	got;	/* current extent entry */
++>>>>>>> 48fd52b16d74 (xfs: refactor xfs_del_extent_real)
  	xfs_fileoff_t		got_endoff;	/* first offset past got */
  	int			i;	/* temp state */
  	xfs_ifork_t		*ifp;	/* inode fork pointer */
@@@ -4803,150 -5188,106 +4805,222 @@@
  		 * Deleting the first part of the extent.
  		 */
  		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
++<<<<<<< HEAD
 +		xfs_bmbt_set_startoff(ep, del_endoff);
 +		temp = got.br_blockcount - del->br_blockcount;
 +		xfs_bmbt_set_blockcount(ep, temp);
 +		if (delay) {
 +			temp = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),
 +				da_old);
 +			xfs_bmbt_set_startblock(ep, nullstartblock((int)temp));
 +			trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
 +			da_new = temp;
 +			break;
 +		}
 +		xfs_bmbt_set_startblock(ep, del_endblock);
++=======
+ 		got.br_startoff = del_endoff;
+ 		got.br_startblock = del_endblock;
+ 		got.br_blockcount -= del->br_blockcount;
+ 		xfs_iext_update_extent(ifp, *idx, &got);
++>>>>>>> 48fd52b16d74 (xfs: refactor xfs_del_extent_real)
  		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
  		if (!cur) {
  			flags |= xfs_ilog_fext(whichfork);
  			break;
  		}
- 		if ((error = xfs_bmbt_update(cur, del_endoff, del_endblock,
- 				got.br_blockcount - del->br_blockcount,
- 				got.br_state)))
+ 		error = xfs_bmbt_update(cur, got.br_startoff, got.br_startblock,
+ 				got.br_blockcount, got.br_state);
+ 		if (error)
  			goto done;
  		break;
 -	case BMAP_RIGHT_FILLING:
 +
 +	case 1:
  		/*
  		 * Deleting the last part of the extent.
  		 */
- 		temp = got.br_blockcount - del->br_blockcount;
  		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
++<<<<<<< HEAD
 +		xfs_bmbt_set_blockcount(ep, temp);
 +		if (delay) {
 +			temp = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),
 +				da_old);
 +			xfs_bmbt_set_startblock(ep, nullstartblock((int)temp));
 +			trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
 +			da_new = temp;
 +			break;
 +		}
++=======
+ 		got.br_blockcount -= del->br_blockcount;
+ 		xfs_iext_update_extent(ifp, *idx, &got);
++>>>>>>> 48fd52b16d74 (xfs: refactor xfs_del_extent_real)
  		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
  		if (!cur) {
  			flags |= xfs_ilog_fext(whichfork);
  			break;
  		}
- 		if ((error = xfs_bmbt_update(cur, got.br_startoff,
- 				got.br_startblock,
- 				got.br_blockcount - del->br_blockcount,
- 				got.br_state)))
+ 		error = xfs_bmbt_update(cur, got.br_startoff, got.br_startblock,
+ 				got.br_blockcount, got.br_state);
+ 		if (error)
  			goto done;
  		break;
 +
  	case 0:
  		/*
  		 * Deleting the middle of the extent.
  		 */
- 		temp = del->br_startoff - got.br_startoff;
  		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
- 		xfs_bmbt_set_blockcount(ep, temp);
+ 
+ 		old = got;
+ 		got.br_blockcount = del->br_startoff - got.br_startoff;
+ 		xfs_iext_update_extent(ifp, *idx, &got);
+ 
  		new.br_startoff = del_endoff;
- 		temp2 = got_endoff - del_endoff;
- 		new.br_blockcount = temp2;
+ 		new.br_blockcount = got_endoff - del_endoff;
  		new.br_state = got.br_state;
++<<<<<<< HEAD
 +		if (!delay) {
 +			new.br_startblock = del_endblock;
 +			flags |= XFS_ILOG_CORE;
 +			if (cur) {
 +				if ((error = xfs_bmbt_update(cur,
 +						got.br_startoff,
 +						got.br_startblock, temp,
 +						got.br_state)))
++=======
+ 		new.br_startblock = del_endblock;
+ 
+ 		flags |= XFS_ILOG_CORE;
+ 		if (cur) {
+ 			error = xfs_bmbt_update(cur, got.br_startoff,
+ 					got.br_startblock, got.br_blockcount,
+ 					got.br_state);
+ 			if (error)
+ 				goto done;
+ 			error = xfs_btree_increment(cur, 0, &i);
+ 			if (error)
+ 				goto done;
+ 			cur->bc_rec.b = new;
+ 			error = xfs_btree_insert(cur, &i);
+ 			if (error && error != -ENOSPC)
+ 				goto done;
+ 			/*
+ 			 * If get no-space back from btree insert, it tried a
+ 			 * split, and we have a zero block reservation.  Fix up
+ 			 * our state and return the error.
+ 			 */
+ 			if (error == -ENOSPC) {
+ 				/*
+ 				 * Reset the cursor, don't trust it after any
+ 				 * insert operation.
+ 				 */
+ 				error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
+ 						got.br_startblock,
+ 						got.br_blockcount, &i);
+ 				if (error)
++>>>>>>> 48fd52b16d74 (xfs: refactor xfs_del_extent_real)
 +					goto done;
 +				if ((error = xfs_btree_increment(cur, 0, &i)))
  					goto done;
 +				cur->bc_rec.b = new;
 +				error = xfs_btree_insert(cur, &i);
 +				if (error && error != -ENOSPC)
 +					goto done;
 +				/*
 +				 * If get no-space back from btree insert,
 +				 * it tried a split, and we have a zero
 +				 * block reservation.
 +				 * Fix up our state and return the error.
 +				 */
 +				if (error == -ENOSPC) {
 +					/*
 +					 * Reset the cursor, don't trust
 +					 * it after any insert operation.
 +					 */
 +					if ((error = xfs_bmbt_lookup_eq(cur,
 +							got.br_startoff,
 +							got.br_startblock,
 +							temp, &i)))
 +						goto done;
 +					XFS_WANT_CORRUPTED_GOTO(mp,
 +								i == 1, done);
 +					/*
 +					 * Update the btree record back
 +					 * to the original value.
 +					 */
 +					if ((error = xfs_bmbt_update(cur,
 +							got.br_startoff,
 +							got.br_startblock,
 +							got.br_blockcount,
 +							got.br_state)))
 +						goto done;
 +					/*
 +					 * Reset the extent record back
 +					 * to the original value.
 +					 */
 +					xfs_bmbt_set_blockcount(ep,
 +						got.br_blockcount);
 +					flags = 0;
 +					error = -ENOSPC;
 +					goto done;
 +				}
  				XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
++<<<<<<< HEAD
 +			} else
 +				flags |= xfs_ilog_fext(whichfork);
 +			XFS_IFORK_NEXT_SET(ip, whichfork,
 +				XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
 +		} else {
 +			xfs_filblks_t	stolen;
 +			ASSERT(whichfork == XFS_DATA_FORK);
 +
 +			/*
 +			 * Distribute the original indlen reservation across the
 +			 * two new extents. Steal blocks from the deleted extent
 +			 * if necessary. Stealing blocks simply fudges the
 +			 * fdblocks accounting in xfs_bunmapi().
 +			 */
 +			temp = xfs_bmap_worst_indlen(ip, got.br_blockcount);
 +			temp2 = xfs_bmap_worst_indlen(ip, new.br_blockcount);
 +			stolen = xfs_bmap_split_indlen(da_old, &temp, &temp2,
 +						       del->br_blockcount);
 +			da_new = temp + temp2 - stolen;
 +			del->br_blockcount -= stolen;
 +
 +			/*
 +			 * Set the reservation for each extent. Warn if either
 +			 * is zero as this can lead to delalloc problems.
 +			 */
 +			WARN_ON_ONCE(!temp || !temp2);
 +			xfs_bmbt_set_startblock(ep, nullstartblock((int)temp));
 +			new.br_startblock = nullstartblock((int)temp2);
 +		}
++=======
+ 				/*
+ 				 * Update the btree record back
+ 				 * to the original value.
+ 				 */
+ 				error = xfs_bmbt_update(cur, old.br_startoff,
+ 						old.br_startblock,
+ 						old.br_blockcount,
+ 						old.br_state);
+ 				if (error)
+ 					goto done;
+ 				/*
+ 				 * Reset the extent record back
+ 				 * to the original value.
+ 				 */
+ 				xfs_iext_update_extent(ifp, *idx, &old);
+ 				flags = 0;
+ 				error = -ENOSPC;
+ 				goto done;
+ 			}
+ 			XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
+ 		} else
+ 			flags |= xfs_ilog_fext(whichfork);
+ 		XFS_IFORK_NEXT_SET(ip, whichfork,
+ 			XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
++>>>>>>> 48fd52b16d74 (xfs: refactor xfs_del_extent_real)
  		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
  		xfs_iext_insert(ip, *idx + 1, 1, &new, state);
  		++*idx;
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
