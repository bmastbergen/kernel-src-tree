mm: clean up non-standard page->_mapcount users

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Vladimir Davydov <vdavydov@virtuozzo.com>
commit 632c0a1affd861f81abdd136c886418571e19a51
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/632c0a1a.failed

 - Add a proper comment to page->_mapcount.

 - Introduce a macro for generating helper functions.

 - Place all special page->_mapcount values next to each other so that
   readers can see all possible values and so we don't get duplicates.

Link: http://lkml.kernel.org/r/502f49000e0b63e6c62e338fac6b420bf34fb526.1464079537.git.vdavydov@virtuozzo.com
	Signed-off-by: Vladimir Davydov <vdavydov@virtuozzo.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Eric Dumazet <eric.dumazet@gmail.com>
	Cc: Minchan Kim <minchan@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 632c0a1affd861f81abdd136c886418571e19a51)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mm_types.h
#	include/linux/page-flags.h
#	scripts/tags.sh
diff --cc include/linux/mm_types.h
index ff35333d8d6c,79472b22d23f..000000000000
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@@ -46,80 -46,66 +46,112 @@@ struct page 
  	/* First double word block */
  	unsigned long flags;		/* Atomic flags, some possibly
  					 * updated asynchronously */
 -	union {
 -		struct address_space *mapping;	/* If low bit clear, points to
 -						 * inode address_space, or NULL.
 -						 * If page mapped as anonymous
 -						 * memory, low bit is set, and
 -						 * it points to anon_vma object:
 -						 * see PAGE_MAPPING_ANON below.
 -						 */
 -		void *s_mem;			/* slab first object */
 -		atomic_t compound_mapcount;	/* first tail page */
 -		/* page_deferred_list().next	 -- second tail page */
 -	};
 -
 +	struct address_space *mapping;	/* If low bit clear, points to
 +					 * inode address_space, or NULL.
 +					 * If page mapped as anonymous
 +					 * memory, low bit is set, and
 +					 * it points to anon_vma object:
 +					 * see PAGE_MAPPING_ANON below.
 +					 */
  	/* Second double word */
 -	union {
 -		pgoff_t index;		/* Our offset within mapping. */
 -		void *freelist;		/* sl[aou]b first free object */
 -		/* page_deferred_list().prev	-- second tail page */
 -	};
 +	struct {
 +		union {
 +			pgoff_t index;		/* Our offset within mapping. */
 +			void *freelist;		/* slub/slob first free object */
 +			RH_KABI_DEPRECATE(bool, pfmemalloc)
 +						/* If set by the page allocator,
 +						 * ALLOC_NO_WATERMARKS was set
 +						 * and the low watermark was not
 +						 * met implying that the system
 +						 * is under some pressure. The
 +						 * caller should try ensure
 +						 * this page is only used to
 +						 * free other pages.
 +						 */
 +#ifndef __GENKSYMS__ /* kABI bypass, the size of the union didn't change */
 +			atomic_t thp_mmu_gather; /* in first tailpage of THP */
 +#endif
 +#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && USE_SPLIT_PMD_PTLOCKS
 +		pgtable_t pmd_huge_pte; /* protected by page->ptl */
 +#endif
 +		};
  
 -	union {
 +		union {
  #if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \
  	defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)
 -		/* Used for cmpxchg_double in slub */
 -		unsigned long counters;
 +			/* Used for cmpxchg_double in slub */
 +			unsigned long counters;
  #else
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * Keep _refcount separate from slub cmpxchg_double data.
+ 		 * As the rest of the double word is protected by slab_lock
+ 		 * but _refcount is not.
+ 		 */
+ 		unsigned counters;
+ #endif
+ 		struct {
+ 
+ 			union {
+ 				/*
+ 				 * Count of ptes mapped in mms, to show when
+ 				 * page is mapped & limit reverse map searches.
+ 				 *
+ 				 * Extra information about page type may be
+ 				 * stored here for pages that are never mapped,
+ 				 * in which case the value MUST BE <= -2.
+ 				 * See page-flags.h for more details.
+ 				 */
+ 				atomic_t _mapcount;
+ 
+ 				unsigned int active;		/* SLAB */
+ 				struct {			/* SLUB */
+ 					unsigned inuse:16;
+ 					unsigned objects:15;
+ 					unsigned frozen:1;
+ 				};
+ 				int units;			/* SLOB */
+ 			};
++>>>>>>> 632c0a1affd8 (mm: clean up non-standard page->_mapcount users)
  			/*
 -			 * Usage count, *USE WRAPPER FUNCTION* when manual
 -			 * accounting. See page_ref.h
 +			 * Keep _count separate from slub cmpxchg_double data.
 +			 * As the rest of the double word is protected by
 +			 * slab_lock but _count is not.
  			 */
 -			atomic_t _refcount;
 +			unsigned counters;
 +#endif
 +
 +			struct {
 +
 +				union {
 +					/*
 +					 * Count of ptes mapped in
 +					 * mms, to show when page is
 +					 * mapped & limit reverse map
 +					 * searches.
 +					 *
 +					 * Used also for tail pages
 +					 * refcounting instead of
 +					 * _count. Tail pages cannot
 +					 * be mapped and keeping the
 +					 * tail page _count zero at
 +					 * all times guarantees
 +					 * get_page_unless_zero() will
 +					 * never succeed on tail
 +					 * pages.
 +					 */
 +					atomic_t _mapcount;
 +
 +					struct { /* SLUB */
 +						unsigned inuse:16;
 +						unsigned objects:15;
 +						unsigned frozen:1;
 +					};
 +					int units;	/* SLOB */
 +				};
 +				atomic_t _count;		/* Usage count, see below. */
 +			};
  		};
  	};
  
diff --cc include/linux/page-flags.h
index a12b531c03b4,96084ee74ee8..000000000000
--- a/include/linux/page-flags.h
+++ b/include/linux/page-flags.h
@@@ -474,6 -595,57 +474,51 @@@ static inline int PageTransTail(struct 
  #endif
  
  /*
++<<<<<<< HEAD
++=======
+  * For pages that are never mapped to userspace, page->mapcount may be
+  * used for storing extra information about page type. Any value used
+  * for this purpose must be <= -2, but it's better start not too close
+  * to -2 so that an underflow of the page_mapcount() won't be mistaken
+  * for a special page.
+  */
+ #define PAGE_MAPCOUNT_OPS(uname, lname)					\
+ static __always_inline int Page##uname(struct page *page)		\
+ {									\
+ 	return atomic_read(&page->_mapcount) ==				\
+ 				PAGE_##lname##_MAPCOUNT_VALUE;		\
+ }									\
+ static __always_inline void __SetPage##uname(struct page *page)		\
+ {									\
+ 	VM_BUG_ON_PAGE(atomic_read(&page->_mapcount) != -1, page);	\
+ 	atomic_set(&page->_mapcount, PAGE_##lname##_MAPCOUNT_VALUE);	\
+ }									\
+ static __always_inline void __ClearPage##uname(struct page *page)	\
+ {									\
+ 	VM_BUG_ON_PAGE(!Page##uname(page), page);			\
+ 	atomic_set(&page->_mapcount, -1);				\
+ }
+ 
+ /*
+  * PageBuddy() indicate that the page is free and in the buddy system
+  * (see mm/page_alloc.c).
+  */
+ #define PAGE_BUDDY_MAPCOUNT_VALUE		(-128)
+ PAGE_MAPCOUNT_OPS(Buddy, BUDDY)
+ 
+ /*
+  * PageBalloon() is set on pages that are on the balloon page list
+  * (see mm/balloon_compaction.c).
+  */
+ #define PAGE_BALLOON_MAPCOUNT_VALUE		(-256)
+ PAGE_MAPCOUNT_OPS(Balloon, BALLOON)
+ 
+ extern bool is_free_buddy_page(struct page *page);
+ 
+ __PAGEFLAG(Isolated, isolated, PF_ANY);
+ 
+ /*
++>>>>>>> 632c0a1affd8 (mm: clean up non-standard page->_mapcount users)
   * If network-based swap is enabled, sl*b must keep track of whether pages
   * were allocated from pfmemalloc reserves.
   */
diff --cc scripts/tags.sh
index 8dd288c0fd25,ed7eef24ef89..000000000000
--- a/scripts/tags.sh
+++ b/scripts/tags.sh
@@@ -147,12 -145,116 +147,118 @@@ dogtags(
  	all_target_sources | gtags -i -f -
  }
  
++<<<<<<< HEAD
++=======
+ # Basic regular expressions with an optional /kind-spec/ for ctags and
+ # the following limitations:
+ # - No regex modifiers
+ # - Use \{0,1\} instead of \?, because etags expects an unescaped ?
+ # - \s is not working with etags, use a space or [ \t]
+ # - \w works, but does not match underscores in etags
+ # - etags regular expressions have to match at the start of a line;
+ #   a ^[^#] is prepended by setup_regex unless an anchor is already present
+ regex_asm=(
+ 	'/^\(ENTRY\|_GLOBAL\)(\([[:alnum:]_\\]*\)).*/\2/'
+ )
+ regex_c=(
+ 	'/^SYSCALL_DEFINE[0-9](\([[:alnum:]_]*\).*/sys_\1/'
+ 	'/^COMPAT_SYSCALL_DEFINE[0-9](\([[:alnum:]_]*\).*/compat_sys_\1/'
+ 	'/^TRACE_EVENT(\([[:alnum:]_]*\).*/trace_\1/'
+ 	'/^TRACE_EVENT(\([[:alnum:]_]*\).*/trace_\1_rcuidle/'
+ 	'/^DEFINE_EVENT([^,)]*, *\([[:alnum:]_]*\).*/trace_\1/'
+ 	'/^DEFINE_EVENT([^,)]*, *\([[:alnum:]_]*\).*/trace_\1_rcuidle/'
+ 	'/^DEFINE_INSN_CACHE_OPS(\([[:alnum:]_]*\).*/get_\1_slot/'
+ 	'/^DEFINE_INSN_CACHE_OPS(\([[:alnum:]_]*\).*/free_\1_slot/'
+ 	'/^PAGEFLAG(\([[:alnum:]_]*\).*/Page\1/'
+ 	'/^PAGEFLAG(\([[:alnum:]_]*\).*/SetPage\1/'
+ 	'/^PAGEFLAG(\([[:alnum:]_]*\).*/ClearPage\1/'
+ 	'/^TESTSETFLAG(\([[:alnum:]_]*\).*/TestSetPage\1/'
+ 	'/^TESTPAGEFLAG(\([[:alnum:]_]*\).*/Page\1/'
+ 	'/^SETPAGEFLAG(\([[:alnum:]_]*\).*/SetPage\1/'
+ 	'/\<__SETPAGEFLAG(\([[:alnum:]_]*\).*/__SetPage\1/'
+ 	'/\<TESTCLEARFLAG(\([[:alnum:]_]*\).*/TestClearPage\1/'
+ 	'/\<__TESTCLEARFLAG(\([[:alnum:]_]*\).*/TestClearPage\1/'
+ 	'/\<CLEARPAGEFLAG(\([[:alnum:]_]*\).*/ClearPage\1/'
+ 	'/\<__CLEARPAGEFLAG(\([[:alnum:]_]*\).*/__ClearPage\1/'
+ 	'/^__PAGEFLAG(\([[:alnum:]_]*\).*/__SetPage\1/'
+ 	'/^__PAGEFLAG(\([[:alnum:]_]*\).*/__ClearPage\1/'
+ 	'/^PAGEFLAG_FALSE(\([[:alnum:]_]*\).*/Page\1/'
+ 	'/\<TESTSCFLAG(\([[:alnum:]_]*\).*/TestSetPage\1/'
+ 	'/\<TESTSCFLAG(\([[:alnum:]_]*\).*/TestClearPage\1/'
+ 	'/\<SETPAGEFLAG_NOOP(\([[:alnum:]_]*\).*/SetPage\1/'
+ 	'/\<CLEARPAGEFLAG_NOOP(\([[:alnum:]_]*\).*/ClearPage\1/'
+ 	'/\<__CLEARPAGEFLAG_NOOP(\([[:alnum:]_]*\).*/__ClearPage\1/'
+ 	'/\<TESTCLEARFLAG_FALSE(\([[:alnum:]_]*\).*/TestClearPage\1/'
+ 	'/^PAGE_MAPCOUNT_OPS(\([[:alnum:]_]*\).*/Page\1/'
+ 	'/^PAGE_MAPCOUNT_OPS(\([[:alnum:]_]*\).*/__SetPage\1/'
+ 	'/^PAGE_MAPCOUNT_OPS(\([[:alnum:]_]*\).*/__ClearPage\1/'
+ 	'/^TASK_PFA_TEST([^,]*, *\([[:alnum:]_]*\))/task_\1/'
+ 	'/^TASK_PFA_SET([^,]*, *\([[:alnum:]_]*\))/task_set_\1/'
+ 	'/^TASK_PFA_CLEAR([^,]*, *\([[:alnum:]_]*\))/task_clear_\1/'
+ 	'/^DEF_MMIO_\(IN\|OUT\)_[XD](\([[:alnum:]_]*\),[^)]*)/\2/'
+ 	'/^DEBUGGER_BOILERPLATE(\([[:alnum:]_]*\))/\1/'
+ 	'/^DEF_PCI_AC_\(\|NO\)RET(\([[:alnum:]_]*\).*/\2/'
+ 	'/^PCI_OP_READ(\(\w*\).*[1-4])/pci_bus_read_config_\1/'
+ 	'/^PCI_OP_WRITE(\(\w*\).*[1-4])/pci_bus_write_config_\1/'
+ 	'/\<DEFINE_\(MUTEX\|SEMAPHORE\|SPINLOCK\)(\([[:alnum:]_]*\)/\2/v/'
+ 	'/\<DEFINE_\(RAW_SPINLOCK\|RWLOCK\|SEQLOCK\)(\([[:alnum:]_]*\)/\2/v/'
+ 	'/\<DECLARE_\(RWSEM\|COMPLETION\)(\([[:alnum:]_]\+\)/\2/v/'
+ 	'/\<DECLARE_BITMAP(\([[:alnum:]_]*\)/\1/v/'
+ 	'/\(^\|\s\)\(\|L\|H\)LIST_HEAD(\([[:alnum:]_]*\)/\3/v/'
+ 	'/\(^\|\s\)RADIX_TREE(\([[:alnum:]_]*\)/\2/v/'
+ 	'/\<DEFINE_PER_CPU([^,]*, *\([[:alnum:]_]*\)/\1/v/'
+ 	'/\<DEFINE_PER_CPU_SHARED_ALIGNED([^,]*, *\([[:alnum:]_]*\)/\1/v/'
+ 	'/\<DECLARE_WAIT_QUEUE_HEAD(\([[:alnum:]_]*\)/\1/v/'
+ 	'/\<DECLARE_\(TASKLET\|WORK\|DELAYED_WORK\)(\([[:alnum:]_]*\)/\2/v/'
+ 	'/\<DEFINE_PCI_DEVICE_TABLE(\([[:alnum:]_]*\)/\1/v/'
+ 	'/\(^\s\)OFFSET(\([[:alnum:]_]*\)/\2/v/'
+ 	'/\(^\s\)DEFINE(\([[:alnum:]_]*\)/\2/v/'
+ 	'/\<DEFINE_HASHTABLE(\([[:alnum:]_]*\)/\1/v/'
+ )
+ regex_kconfig=(
+ 	'/^[[:blank:]]*\(menu\|\)config[[:blank:]]\+\([[:alnum:]_]\+\)/\2/'
+ 	'/^[[:blank:]]*\(menu\|\)config[[:blank:]]\+\([[:alnum:]_]\+\)/CONFIG_\2/'
+ )
+ setup_regex()
+ {
+ 	local mode=$1 lang tmp=() r
+ 	shift
+ 
+ 	regex=()
+ 	for lang; do
+ 		case "$lang" in
+ 		asm)       tmp=("${regex_asm[@]}") ;;
+ 		c)         tmp=("${regex_c[@]}") ;;
+ 		kconfig)   tmp=("${regex_kconfig[@]}") ;;
+ 		esac
+ 		for r in "${tmp[@]}"; do
+ 			if test "$mode" = "exuberant"; then
+ 				regex[${#regex[@]}]="--regex-$lang=${r}b"
+ 			else
+ 				# Remove ctags /kind-spec/
+ 				case "$r" in
+ 				/*/*/?/)
+ 					r=${r%?/}
+ 				esac
+ 				# Prepend ^[^#] unless already anchored
+ 				case "$r" in
+ 				/^*) ;;
+ 				*)
+ 					r="/^[^#]*${r#/}"
+ 				esac
+ 				regex[${#regex[@]}]="--regex=$r"
+ 			fi
+ 		done
+ 	done
+ }
+ 
++>>>>>>> 632c0a1affd8 (mm: clean up non-standard page->_mapcount users)
  exuberant()
  {
 -	setup_regex exuberant asm c
  	all_target_sources | xargs $1 -a                        \
 -	-I __initdata,__exitdata,__initconst,			\
 -	-I __initdata_memblock					\
 -	-I __refdata,__attribute,__maybe_unused,__always_unused \
 +	-I __initdata,__exitdata,__initconst,__devinitdata	\
 +	-I __devinitconst,__cpuinitdata,__initdata_memblock	\
 +	-I __refdata,__attribute				\
  	-I __acquires,__releases,__deprecated			\
  	-I __read_mostly,__aligned,____cacheline_aligned        \
  	-I ____cacheline_aligned_in_smp                         \
* Unmerged path include/linux/mm_types.h
* Unmerged path include/linux/page-flags.h
* Unmerged path scripts/tags.sh
