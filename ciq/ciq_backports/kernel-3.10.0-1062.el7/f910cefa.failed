bpf: unify main prog and subprog

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jiong Wang <jiong.wang@netronome.com>
commit f910cefa32b6cdabc96b126bcfc46d8940b1dc45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f910cefa.failed

Currently, verifier treat main prog and subprog differently. All subprogs
detected are kept in env->subprog_starts while main prog is not kept there.
Instead, main prog is implicitly defined as the prog start at 0.

There is actually no difference between main prog and subprog, it is better
to unify them, and register all progs detected into env->subprog_starts.

This could also help simplifying some code logic.

	Signed-off-by: Jiong Wang <jiong.wang@netronome.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit f910cefa32b6cdabc96b126bcfc46d8940b1dc45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index 9f1b98f148a8,8e8e582a7c03..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -3842,7 -3889,12 +3847,16 @@@ static int check_ld_abs(struct bpf_veri
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	if (env->subprog_cnt) {
++=======
+ 	if (!env->ops->gen_ld_abs) {
+ 		verbose(env, "bpf verifier is misconfigured\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (env->subprog_cnt > 1) {
++>>>>>>> f910cefa32b6 (bpf: unify main prog and subprog)
  		/* when program has LD_ABS insn JITs and interpreter assume
  		 * that r1 == ctx == skb which is not the case for callees
  		 * that can have arbitrary arguments. It's problematic
@@@ -5352,9 -5383,9 +5366,9 @@@ static int jit_subprogs(struct bpf_veri
  				__bpf_call_base;
  		}
  	}
- 	for (i = 0; i <= env->subprog_cnt; i++) {
+ 	for (i = 0; i < env->subprog_cnt; i++) {
  		old_bpf_func = func[i]->bpf_func;
 -		tmp = bpf_int_jit_compile(func[i]);
 +		tmp = trace_bpf_int_jit_compile(func[i]);
  		if (tmp != func[i] || func[i]->bpf_func != old_bpf_func) {
  			verbose(env, "JIT doesn't support bpf-to-bpf calls\n");
  			err = -EFAULT;
@@@ -5366,8 -5397,9 +5380,8 @@@
  	/* finally lock prog and jit images for all functions and
  	 * populate kallsysm
  	 */
- 	for (i = 0; i <= env->subprog_cnt; i++) {
+ 	for (i = 0; i < env->subprog_cnt; i++) {
  		bpf_prog_lock_ro(func[i]);
 -		bpf_prog_kallsyms_add(func[i]);
  	}
  
  	/* Last step: make now unused interpreter insns from main
@@@ -5391,12 -5423,12 +5405,12 @@@
  	prog->jited = 1;
  	prog->bpf_func = func[0]->bpf_func;
  	prog->aux->func = func;
- 	prog->aux->func_cnt = env->subprog_cnt + 1;
+ 	prog->aux->func_cnt = env->subprog_cnt;
  	return 0;
  out_free:
- 	for (i = 0; i <= env->subprog_cnt; i++)
+ 	for (i = 0; i < env->subprog_cnt; i++)
  		if (func[i])
 -			bpf_jit_free(func[i]);
 +			trace_bpf_jit_free(func[i]);
  	kfree(func);
  	/* cleanup main prog to be interpreted */
  	prog->jit_requested = 0;
diff --git a/include/linux/bpf_verifier.h b/include/linux/bpf_verifier.h
index 30a64bcc7a7d..439b7ed1dacf 100644
--- a/include/linux/bpf_verifier.h
+++ b/include/linux/bpf_verifier.h
@@ -195,7 +195,7 @@ struct bpf_verifier_env {
 	bool seen_direct_write;
 	struct bpf_insn_aux_data *insn_aux_data; /* array of per-insn state */
 	struct bpf_verifier_log log;
-	u32 subprog_starts[BPF_MAX_SUBPROGS];
+	u32 subprog_starts[BPF_MAX_SUBPROGS + 1];
 	/* computes the stack depth of each bpf function */
 	u16 subprog_stack_depth[BPF_MAX_SUBPROGS + 1];
 	u32 subprog_cnt;
* Unmerged path kernel/bpf/verifier.c
