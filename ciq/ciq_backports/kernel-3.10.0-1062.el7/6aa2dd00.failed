ipmi_devintf: Small lock rework

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit 6aa2dd0092d2762cc12cccf5142313858f4153a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6aa2dd00.failed

The mutex didn't really serve any useful purpose, from what I can
tell, and it would just get in the way.  So remove it.

Removing that required a mutex around the default value setting and
getting, so just use the receive mutex for that.

Also pull the fasync stuff outside of the lock for adding the data
to the queue, since it didn't need to be there.

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 6aa2dd0092d2762cc12cccf5142313858f4153a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_devintf.c
diff --cc drivers/char/ipmi/ipmi_devintf.c
index 5bc04673465f,71698365591f..000000000000
--- a/drivers/char/ipmi/ipmi_devintf.c
+++ b/drivers/char/ipmi/ipmi_devintf.c
@@@ -65,23 -44,21 +64,33 @@@ static void file_receive_handler(struc
  	int                      was_empty;
  	unsigned long            flags;
  
++<<<<<<< HEAD
 +	spin_lock_irqsave(&(priv->recv_msg_lock), flags);
 +
 +	was_empty = list_empty(&(priv->recv_msgs));
 +	list_add_tail(&(msg->link), &(priv->recv_msgs));
++=======
+ 	spin_lock_irqsave(&priv->recv_msg_lock, flags);
+ 	was_empty = list_empty(&priv->recv_msgs);
+ 	list_add_tail(&msg->link, &priv->recv_msgs);
+ 	spin_unlock_irqrestore(&priv->recv_msg_lock, flags);
++>>>>>>> 6aa2dd0092d2 (ipmi_devintf: Small lock rework)
  
  	if (was_empty) {
  		wake_up_interruptible(&priv->wait);
  		kill_fasync(&priv->fasync_queue, SIGIO, POLL_IN);
  	}
++<<<<<<< HEAD
 +
 +	spin_unlock_irqrestore(&(priv->recv_msg_lock), flags);
++=======
++>>>>>>> 6aa2dd0092d2 (ipmi_devintf: Small lock rework)
  }
  
 -static __poll_t ipmi_poll(struct file *file, poll_table *wait)
 +static unsigned int ipmi_poll(struct file *file, poll_table *wait)
  {
  	struct ipmi_file_private *priv = file->private_data;
 -	__poll_t             mask = 0;
 +	unsigned int             mask = 0;
  	unsigned long            flags;
  
  	poll_wait(file, &priv->wait, wait);
@@@ -99,16 -76,11 +108,11 @@@
  static int ipmi_fasync(int fd, struct file *file, int on)
  {
  	struct ipmi_file_private *priv = file->private_data;
- 	int                      result;
- 
- 	mutex_lock(&ipmi_mutex); /* could race against open() otherwise */
- 	result = fasync_helper(fd, file, on, &priv->fasync_queue);
- 	mutex_unlock(&ipmi_mutex);
  
- 	return (result);
+ 	return fasync_helper(fd, file, on, &priv->fasync_queue);
  }
  
 -static const struct ipmi_user_hndl ipmi_hndlrs =
 +static RH_KABI_CONST struct ipmi_user_hndl ipmi_hndlrs =
  {
  	.ipmi_recv_hndl	= file_receive_handler,
  };
* Unmerged path drivers/char/ipmi/ipmi_devintf.c
