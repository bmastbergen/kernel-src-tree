nfp: flower: add ipv6 set flow label and hop limit offload

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
commit 4234d62c27a633a089506f0b05040d7c6ff5fd6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4234d62c.failed

Add ipv6 set flow label and hop limit action offload. Since pedit sets
headers per 4 byte word, we need to ensure that setting either version,
priority, payload_len or nexthdr does not get offloaded.

	Signed-off-by: Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
	Reviewed-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4234d62c27a633a089506f0b05040d7c6ff5fd6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/flower/action.c
#	drivers/net/ethernet/netronome/nfp/flower/cmsg.h
diff --cc drivers/net/ethernet/netronome/nfp/flower/action.c
index 7e0903bc6007,cfea8f790f95..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/action.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/action.c
@@@ -453,18 -580,42 +499,28 @@@ nfp_fl_set_tport(const struct tc_actio
  	return 0;
  }
  
 -static u32 nfp_fl_csum_l4_to_flag(u8 ip_proto)
 -{
 -	switch (ip_proto) {
 -	case 0:
 -		/* Filter doesn't force proto match,
 -		 * both TCP and UDP will be updated if encountered
 -		 */
 -		return TCA_CSUM_UPDATE_FLAG_TCP | TCA_CSUM_UPDATE_FLAG_UDP;
 -	case IPPROTO_TCP:
 -		return TCA_CSUM_UPDATE_FLAG_TCP;
 -	case IPPROTO_UDP:
 -		return TCA_CSUM_UPDATE_FLAG_UDP;
 -	default:
 -		/* All other protocols will be ignored by FW */
 -		return 0;
 -	}
 -}
 -
  static int
 -nfp_fl_pedit(const struct tc_action *action, struct tc_cls_flower_offload *flow,
 -	     char *nfp_action, int *a_len, u32 *csum_updated)
 +nfp_fl_pedit(const struct tc_action *action, char *nfp_action, int *a_len)
  {
  	struct nfp_fl_set_ipv6_addr set_ip6_dst, set_ip6_src;
++<<<<<<< HEAD
++=======
+ 	struct nfp_fl_set_ipv6_tc_hl_fl set_ip6_tc_hl_fl;
+ 	struct nfp_fl_set_ip4_ttl_tos set_ip_ttl_tos;
++>>>>>>> 4234d62c27a6 (nfp: flower: add ipv6 set flow label and hop limit offload)
  	struct nfp_fl_set_ip4_addrs set_ip_addr;
  	struct nfp_fl_set_tport set_tport;
  	struct nfp_fl_set_eth set_eth;
  	enum pedit_header_type htype;
  	int idx, nkeys, err;
 -	size_t act_size = 0;
 +	size_t act_size;
  	u32 offset, cmd;
 -	u8 ip_proto = 0;
  
++<<<<<<< HEAD
++=======
+ 	memset(&set_ip6_tc_hl_fl, 0, sizeof(set_ip6_tc_hl_fl));
+ 	memset(&set_ip_ttl_tos, 0, sizeof(set_ip_ttl_tos));
++>>>>>>> 4234d62c27a6 (nfp: flower: add ipv6 set flow label and hop limit offload)
  	memset(&set_ip6_dst, 0, sizeof(set_ip6_dst));
  	memset(&set_ip6_src, 0, sizeof(set_ip6_src));
  	memset(&set_ip_addr, 0, sizeof(set_ip_addr));
@@@ -514,7 -687,21 +570,25 @@@
  		act_size = sizeof(set_ip_addr);
  		memcpy(nfp_action, &set_ip_addr, act_size);
  		*a_len += act_size;
++<<<<<<< HEAD
 +	} else if (set_ip6_dst.head.len_lw && set_ip6_src.head.len_lw) {
++=======
+ 
+ 		/* Hardware will automatically fix IPv4 and TCP/UDP checksum. */
+ 		*csum_updated |= TCA_CSUM_UPDATE_FLAG_IPV4HDR |
+ 				nfp_fl_csum_l4_to_flag(ip_proto);
+ 	}
+ 	if (set_ip6_tc_hl_fl.head.len_lw) {
+ 		nfp_action += act_size;
+ 		act_size = sizeof(set_ip6_tc_hl_fl);
+ 		memcpy(nfp_action, &set_ip6_tc_hl_fl, act_size);
+ 		*a_len += act_size;
+ 
+ 		/* Hardware will automatically fix TCP/UDP checksum. */
+ 		*csum_updated |= nfp_fl_csum_l4_to_flag(ip_proto);
+ 	}
+ 	if (set_ip6_dst.head.len_lw && set_ip6_src.head.len_lw) {
++>>>>>>> 4234d62c27a6 (nfp: flower: add ipv6 set flow label and hop limit offload)
  		/* TC compiles set src and dst IPv6 address as a single action,
  		 * the hardware requires this to be 2 separate actions.
  		 */
diff --cc drivers/net/ethernet/netronome/nfp/flower/cmsg.h
index 062d7040a0dc,3e391555e191..000000000000
--- a/drivers/net/ethernet/netronome/nfp/flower/cmsg.h
+++ b/drivers/net/ethernet/netronome/nfp/flower/cmsg.h
@@@ -95,10 -65,13 +95,11 @@@
  #define NFP_FL_ACTION_OPCODE_SET_IPV4_TUNNEL	6
  #define NFP_FL_ACTION_OPCODE_SET_ETHERNET	7
  #define NFP_FL_ACTION_OPCODE_SET_IPV4_ADDRS	9
 -#define NFP_FL_ACTION_OPCODE_SET_IPV4_TTL_TOS	10
  #define NFP_FL_ACTION_OPCODE_SET_IPV6_SRC	11
  #define NFP_FL_ACTION_OPCODE_SET_IPV6_DST	12
+ #define NFP_FL_ACTION_OPCODE_SET_IPV6_TC_HL_FL	13
  #define NFP_FL_ACTION_OPCODE_SET_UDP		14
  #define NFP_FL_ACTION_OPCODE_SET_TCP		15
 -#define NFP_FL_ACTION_OPCODE_PRE_LAG		16
  #define NFP_FL_ACTION_OPCODE_PRE_TUNNEL		17
  #define NFP_FL_ACTION_OPCODE_PUSH_GENEVE	26
  #define NFP_FL_ACTION_OPCODE_NUM		32
@@@ -111,6 -84,11 +112,14 @@@
  #define NFP_FL_PUSH_VLAN_CFI		BIT(12)
  #define NFP_FL_PUSH_VLAN_VID		GENMASK(11, 0)
  
++<<<<<<< HEAD
++=======
+ #define IPV6_FLOW_LABEL_MASK		cpu_to_be32(0x000fffff)
+ 
+ /* LAG ports */
+ #define NFP_FL_LAG_OUT			0xC0DE0000
+ 
++>>>>>>> 4234d62c27a6 (nfp: flower: add ipv6 set flow label and hop limit offload)
  /* Tunnel ports */
  #define NFP_FL_PORT_TYPE_TUN		0x50000000
  #define NFP_FL_IPV4_TUNNEL_TYPE		GENMASK(7, 4)
@@@ -151,6 -129,26 +160,29 @@@ struct nfp_fl_set_ip4_addrs 
  	__be32 ipv4_dst;
  };
  
++<<<<<<< HEAD
++=======
+ struct nfp_fl_set_ip4_ttl_tos {
+ 	struct nfp_fl_act_head head;
+ 	u8 ipv4_ttl_mask;
+ 	u8 ipv4_tos_mask;
+ 	u8 ipv4_ttl;
+ 	u8 ipv4_tos;
+ 	__be16 reserved;
+ };
+ 
+ struct nfp_fl_set_ipv6_tc_hl_fl {
+ 	struct nfp_fl_act_head head;
+ 	u8 ipv6_tc_mask;
+ 	u8 ipv6_hop_limit_mask;
+ 	__be16 reserved;
+ 	u8 ipv6_tc;
+ 	u8 ipv6_hop_limit;
+ 	__be32 ipv6_label_mask;
+ 	__be32 ipv6_label;
+ };
+ 
++>>>>>>> 4234d62c27a6 (nfp: flower: add ipv6 set flow label and hop limit offload)
  struct nfp_fl_set_ipv6_addr {
  	struct nfp_fl_act_head head;
  	__be16 reserved;
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/action.c
* Unmerged path drivers/net/ethernet/netronome/nfp/flower/cmsg.h
