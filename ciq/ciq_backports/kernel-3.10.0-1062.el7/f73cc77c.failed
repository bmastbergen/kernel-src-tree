ovl: make ovl_create_real() cope with vfs_mkdir() safely

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit f73cc77c3afffc9a90fad972fe34af52cdb72979
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f73cc77c.failed

vfs_mkdir() may succeed and leave the dentry passed to it unhashed and
negative.  ovl_create_real() is the last caller breaking when that
happens.

[amir: split re-factoring of ovl_create_temp() to prep patch
       add comment about unhashed dir after mkdir
       add pr_warn() if mkdir succeeds and lookup fails]

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit f73cc77c3afffc9a90fad972fe34af52cdb72979)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/dir.c
diff --cc fs/overlayfs/dir.c
index de117ec8c92e,1d59c466d199..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -114,8 -114,39 +114,44 @@@ kill_whiteout
  	goto out;
  }
  
++<<<<<<< HEAD
 +int ovl_create_real(struct inode *dir, struct dentry *newdentry,
 +		    struct cattr *attr, struct dentry *hardlink, bool debug)
++=======
+ static int ovl_mkdir_real(struct inode *dir, struct dentry **newdentry,
+ 			  umode_t mode)
+ {
+ 	int err;
+ 	struct dentry *d, *dentry = *newdentry;
+ 
+ 	err = ovl_do_mkdir(dir, dentry, mode);
+ 	if (err)
+ 		return err;
+ 
+ 	if (likely(!d_unhashed(dentry)))
+ 		return 0;
+ 
+ 	/*
+ 	 * vfs_mkdir() may succeed and leave the dentry passed
+ 	 * to it unhashed and negative. If that happens, try to
+ 	 * lookup a new hashed and positive dentry.
+ 	 */
+ 	d = lookup_one_len(dentry->d_name.name, dentry->d_parent,
+ 			   dentry->d_name.len);
+ 	if (IS_ERR(d)) {
+ 		pr_warn("overlayfs: failed lookup after mkdir (%pd2, err=%i).\n",
+ 			dentry, err);
+ 		return PTR_ERR(d);
+ 	}
+ 	dput(dentry);
+ 	*newdentry = d;
+ 
+ 	return 0;
+ }
+ 
+ struct dentry *ovl_create_real(struct inode *dir, struct dentry *newdentry,
+ 			       struct ovl_cattr *attr)
++>>>>>>> f73cc77c3aff (ovl: make ovl_create_real() cope with vfs_mkdir() safely)
  {
  	int err;
  
@@@ -131,7 -166,8 +167,12 @@@
  			break;
  
  		case S_IFDIR:
++<<<<<<< HEAD
 +			err = ovl_do_mkdir(dir, newdentry, attr->mode, debug);
++=======
+ 			/* mkdir is special... */
+ 			err =  ovl_mkdir_real(dir, &newdentry, attr->mode);
++>>>>>>> f73cc77c3aff (ovl: make ovl_create_real() cope with vfs_mkdir() safely)
  			break;
  
  		case S_IFCHR:
* Unmerged path fs/overlayfs/dir.c
