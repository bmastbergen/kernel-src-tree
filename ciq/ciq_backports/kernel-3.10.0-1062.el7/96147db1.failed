pinctrl: intel: Do pin translation in other GPIO operations as well

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [pinctrl] intel: Do pin translation in other GPIO operations as well (Benjamin Tissoires) [1609926 1544041]
Rebuild_FUZZ: 92.80%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 96147db1e1dff83679e71ac92193cbcab761a14c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/96147db1.failed

For some reason I thought GPIOLIB handles translation from GPIO ranges
to pinctrl pins but it turns out not to be the case. This means that
when GPIOs operations are performed for a pin controller having a custom
GPIO base such as Cannon Lake and Ice Lake incorrect pin number gets
used internally.

Fix this in the same way we did for lock/unlock IRQ operations and
translate the GPIO number to pin before using it.

Fixes: a60eac3239f0 ("pinctrl: intel: Allow custom GPIO base for pad groups")
	Reported-by: Rajat Jain <rajatja@google.com>
	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Tested-by: Rajat Jain <rajatja@google.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 96147db1e1dff83679e71ac92193cbcab761a14c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/intel/pinctrl-intel.c
diff --cc drivers/pinctrl/intel/pinctrl-intel.c
index 849966e04702,ec8dafc94694..000000000000
--- a/drivers/pinctrl/intel/pinctrl-intel.c
+++ b/drivers/pinctrl/intel/pinctrl-intel.c
@@@ -749,77 -747,6 +749,80 @@@ static const struct pinctrl_desc intel_
  	.owner = THIS_MODULE,
  };
  
++<<<<<<< HEAD
 +static int intel_gpio_request(struct gpio_chip *chip, unsigned offset)
 +{
 +	return pinctrl_request_gpio(chip->base + offset);
 +}
 +
 +static void intel_gpio_free(struct gpio_chip *chip, unsigned offset)
 +{
 +	pinctrl_free_gpio(chip->base + offset);
 +}
 +
 +static int intel_gpio_get(struct gpio_chip *chip, unsigned offset)
 +{
 +	struct intel_pinctrl *pctrl = gpiochip_get_data(chip);
 +	void __iomem *reg;
 +	u32 padcfg0;
 +
 +	reg = intel_get_padcfg(pctrl, offset, PADCFG0);
 +	if (!reg)
 +		return -EINVAL;
 +
 +	padcfg0 = readl(reg);
 +	if (!(padcfg0 & PADCFG0_GPIOTXDIS))
 +		return !!(padcfg0 & PADCFG0_GPIOTXSTATE);
 +
 +	return !!(padcfg0 & PADCFG0_GPIORXSTATE);
 +}
 +
 +static void intel_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 +{
 +	struct intel_pinctrl *pctrl = gpiochip_get_data(chip);
 +	void __iomem *reg;
 +
 +	reg = intel_get_padcfg(pctrl, offset, PADCFG0);
 +	if (reg) {
 +		unsigned long flags;
 +		u32 padcfg0;
 +
 +		raw_spin_lock_irqsave(&pctrl->lock, flags);
 +		padcfg0 = readl(reg);
 +		if (value)
 +			padcfg0 |= PADCFG0_GPIOTXSTATE;
 +		else
 +			padcfg0 &= ~PADCFG0_GPIOTXSTATE;
 +		writel(padcfg0, reg);
 +		raw_spin_unlock_irqrestore(&pctrl->lock, flags);
 +	}
 +}
 +
 +static int intel_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
 +{
 +	return pinctrl_gpio_direction_input(chip->base + offset);
 +}
 +
 +static int intel_gpio_direction_output(struct gpio_chip *chip, unsigned offset,
 +				       int value)
 +{
 +	intel_gpio_set(chip, offset, value);
 +	return pinctrl_gpio_direction_output(chip->base + offset);
 +}
 +
 +static const struct gpio_chip intel_gpio_chip = {
 +	.owner = THIS_MODULE,
 +	.request = intel_gpio_request,
 +	.free = intel_gpio_free,
 +	.direction_input = intel_gpio_direction_input,
 +	.direction_output = intel_gpio_direction_output,
 +	.get = intel_gpio_get,
 +	.set = intel_gpio_set,
 +	.set_config = gpiochip_generic_config,
 +};
 +
++=======
++>>>>>>> 96147db1e1df (pinctrl: intel: Do pin translation in other GPIO operations as well)
  /**
   * intel_gpio_to_pin() - Translate from GPIO offset to pin number
   * @pctrl: Pinctrl structure
@@@ -865,6 -792,131 +868,134 @@@ static int intel_gpio_to_pin(struct int
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ static int intel_gpio_get(struct gpio_chip *chip, unsigned offset)
+ {
+ 	struct intel_pinctrl *pctrl = gpiochip_get_data(chip);
+ 	void __iomem *reg;
+ 	u32 padcfg0;
+ 	int pin;
+ 
+ 	pin = intel_gpio_to_pin(pctrl, offset, NULL, NULL);
+ 	if (pin < 0)
+ 		return -EINVAL;
+ 
+ 	reg = intel_get_padcfg(pctrl, pin, PADCFG0);
+ 	if (!reg)
+ 		return -EINVAL;
+ 
+ 	padcfg0 = readl(reg);
+ 	if (!(padcfg0 & PADCFG0_GPIOTXDIS))
+ 		return !!(padcfg0 & PADCFG0_GPIOTXSTATE);
+ 
+ 	return !!(padcfg0 & PADCFG0_GPIORXSTATE);
+ }
+ 
+ static void intel_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+ {
+ 	struct intel_pinctrl *pctrl = gpiochip_get_data(chip);
+ 	unsigned long flags;
+ 	void __iomem *reg;
+ 	u32 padcfg0;
+ 	int pin;
+ 
+ 	pin = intel_gpio_to_pin(pctrl, offset, NULL, NULL);
+ 	if (pin < 0)
+ 		return;
+ 
+ 	reg = intel_get_padcfg(pctrl, pin, PADCFG0);
+ 	if (!reg)
+ 		return;
+ 
+ 	raw_spin_lock_irqsave(&pctrl->lock, flags);
+ 	padcfg0 = readl(reg);
+ 	if (value)
+ 		padcfg0 |= PADCFG0_GPIOTXSTATE;
+ 	else
+ 		padcfg0 &= ~PADCFG0_GPIOTXSTATE;
+ 	writel(padcfg0, reg);
+ 	raw_spin_unlock_irqrestore(&pctrl->lock, flags);
+ }
+ 
+ static int intel_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
+ {
+ 	struct intel_pinctrl *pctrl = gpiochip_get_data(chip);
+ 	void __iomem *reg;
+ 	u32 padcfg0;
+ 	int pin;
+ 
+ 	pin = intel_gpio_to_pin(pctrl, offset, NULL, NULL);
+ 	if (pin < 0)
+ 		return -EINVAL;
+ 
+ 	reg = intel_get_padcfg(pctrl, pin, PADCFG0);
+ 	if (!reg)
+ 		return -EINVAL;
+ 
+ 	padcfg0 = readl(reg);
+ 
+ 	if (padcfg0 & PADCFG0_PMODE_MASK)
+ 		return -EINVAL;
+ 
+ 	return !!(padcfg0 & PADCFG0_GPIOTXDIS);
+ }
+ 
+ static int intel_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+ {
+ 	return pinctrl_gpio_direction_input(chip->base + offset);
+ }
+ 
+ static int intel_gpio_direction_output(struct gpio_chip *chip, unsigned offset,
+ 				       int value)
+ {
+ 	intel_gpio_set(chip, offset, value);
+ 	return pinctrl_gpio_direction_output(chip->base + offset);
+ }
+ 
+ static const struct gpio_chip intel_gpio_chip = {
+ 	.owner = THIS_MODULE,
+ 	.request = gpiochip_generic_request,
+ 	.free = gpiochip_generic_free,
+ 	.get_direction = intel_gpio_get_direction,
+ 	.direction_input = intel_gpio_direction_input,
+ 	.direction_output = intel_gpio_direction_output,
+ 	.get = intel_gpio_get,
+ 	.set = intel_gpio_set,
+ 	.set_config = gpiochip_generic_config,
+ };
+ 
+ static int intel_gpio_irq_reqres(struct irq_data *d)
+ {
+ 	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+ 	struct intel_pinctrl *pctrl = gpiochip_get_data(gc);
+ 	int pin;
+ 	int ret;
+ 
+ 	pin = intel_gpio_to_pin(pctrl, irqd_to_hwirq(d), NULL, NULL);
+ 	if (pin >= 0) {
+ 		ret = gpiochip_lock_as_irq(gc, pin);
+ 		if (ret) {
+ 			dev_err(pctrl->dev, "unable to lock HW IRQ %d for IRQ\n",
+ 				pin);
+ 			return ret;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ static void intel_gpio_irq_relres(struct irq_data *d)
+ {
+ 	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+ 	struct intel_pinctrl *pctrl = gpiochip_get_data(gc);
+ 	int pin;
+ 
+ 	pin = intel_gpio_to_pin(pctrl, irqd_to_hwirq(d), NULL, NULL);
+ 	if (pin >= 0)
+ 		gpiochip_unlock_as_irq(gc, pin);
+ }
+ 
++>>>>>>> 96147db1e1df (pinctrl: intel: Do pin translation in other GPIO operations as well)
  static void intel_gpio_irq_ack(struct irq_data *d)
  {
  	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
* Unmerged path drivers/pinctrl/intel/pinctrl-intel.c
