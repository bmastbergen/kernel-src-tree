ovl: split out ovl_get_lowerstack() from ovl_fill_super()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 53dbb0b4787ef57834f74bdccfba4c63eb12da69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/53dbb0b4.failed

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 53dbb0b4787ef57834f74bdccfba4c63eb12da69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index 19e9eb0f1d4f,6c8703112b8f..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -870,6 -827,143 +870,146 @@@ static const struct xattr_handler *ovl_
  	NULL
  };
  
++<<<<<<< HEAD
++=======
+ static int ovl_get_upperpath(struct ovl_fs *ufs, struct path *upperpath)
+ {
+ 	int err;
+ 
+ 	err = ovl_mount_dir(ufs->config.upperdir, upperpath);
+ 	if (err)
+ 		goto out;
+ 
+ 	/* Upper fs should not be r/o */
+ 	if (sb_rdonly(upperpath->mnt->mnt_sb)) {
+ 		pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	err = ovl_check_namelen(upperpath, ufs, ufs->config.upperdir);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = -EBUSY;
+ 	if (ovl_inuse_trylock(upperpath->dentry)) {
+ 		ufs->upperdir_locked = true;
+ 	} else if (ufs->config.index) {
+ 		pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
+ 		goto out;
+ 	} else {
+ 		pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
+ 	}
+ 	err = 0;
+ out:
+ 	return err;
+ }
+ 
+ static int ovl_get_workpath(struct ovl_fs *ufs, struct path *upperpath,
+ 			    struct path *workpath)
+ {
+ 	int err;
+ 
+ 	err = ovl_mount_dir(ufs->config.workdir, workpath);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = -EINVAL;
+ 	if (upperpath->mnt != workpath->mnt) {
+ 		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
+ 		goto out;
+ 	}
+ 	if (!ovl_workdir_ok(workpath->dentry, upperpath->dentry)) {
+ 		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
+ 		goto out;
+ 	}
+ 
+ 	err = -EBUSY;
+ 	if (ovl_inuse_trylock(workpath->dentry)) {
+ 		ufs->workdir_locked = true;
+ 	} else if (ufs->config.index) {
+ 		pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
+ 		goto out;
+ 	} else {
+ 		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
+ 	}
+ 
+ 	ufs->workbasedir = workpath->dentry;
+ 	err = 0;
+ out:
+ 	return err;
+ }
+ 
+ static int ovl_get_lowerstack(struct super_block *sb, struct ovl_fs *ufs,
+ 			      struct path **stackp, unsigned int *stacklenp)
+ {
+ 	int err;
+ 	char *lowertmp, *lower;
+ 	struct path *stack;
+ 	unsigned int stacklen, numlower, i;
+ 	bool remote = false;
+ 
+ 	err = -ENOMEM;
+ 	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
+ 	if (!lowertmp)
+ 		goto out;
+ 
+ 	err = -EINVAL;
+ 	stacklen = ovl_split_lowerdirs(lowertmp);
+ 	if (stacklen > OVL_MAX_STACK) {
+ 		pr_err("overlayfs: too many lower directories, limit is %d\n",
+ 		       OVL_MAX_STACK);
+ 		goto out;
+ 	} else if (!ufs->config.upperdir && stacklen == 1) {
+ 		pr_err("overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n");
+ 		goto out;
+ 	}
+ 
+ 	err = -ENOMEM;
+ 	stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);
+ 	if (!stack)
+ 		goto out;
+ 
+ 	err = -EINVAL;
+ 	lower = lowertmp;
+ 	for (numlower = 0; numlower < stacklen; numlower++) {
+ 		err = ovl_lower_dir(lower, &stack[numlower], ufs,
+ 				    &sb->s_stack_depth, &remote);
+ 		if (err)
+ 			goto out_free_stack;
+ 
+ 		lower = strchr(lower, '\0') + 1;
+ 	}
+ 
+ 	err = -EINVAL;
+ 	sb->s_stack_depth++;
+ 	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
+ 		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
+ 		goto out_free_stack;
+ 	}
+ 
+ 	*stackp = stack;
+ 	*stacklenp = numlower;
+ 
+ 	if (remote)
+ 		sb->s_d_op = &ovl_reval_dentry_operations;
+ 	else
+ 		sb->s_d_op = &ovl_dentry_operations;
+ 
+ 	err = 0;
+ 
+ out:
+ 	kfree(lowertmp);
+ 	return err;
+ 
+ out_free_stack:
+ 	for (i = 0; i < numlower; i++)
+ 		path_put(&stack[i]);
+ 	kfree(stack);
+ 	goto out;
+ }
+ 
++>>>>>>> 53dbb0b4787e (ovl: split out ovl_get_lowerstack() from ovl_fill_super())
  static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
  	struct path upperpath = { };
@@@ -877,15 -971,9 +1017,11 @@@
  	struct dentry *root_dentry;
  	struct ovl_entry *oe;
  	struct ovl_fs *ufs;
 +	const int *upper_stack_depth;
 +	int *overlay_stack_depth;
  	struct path *stack = NULL;
- 	char *lowertmp;
- 	char *lower;
- 	unsigned int numlower;
- 	unsigned int stacklen = 0;
+ 	unsigned int numlower = 0;
  	unsigned int i;
- 	bool remote = false;
  	struct cred *cred;
  	int err;
  
@@@ -950,76 -1007,16 +1086,83 @@@
  		if (err)
  			goto out_unlock_upperdentry;
  
 -		err = ovl_get_workpath(ufs, &upperpath, &workpath);
 +		err = -EINVAL;
 +		if (upperpath.mnt != workpath.mnt) {
 +			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +			goto out_put_workpath;
 +		}
 +		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +			goto out_put_workpath;
 +		}
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(workpath.dentry)) {
 +			ufs->workdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 +			goto out_put_workpath;
 +		} else {
 +			pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
 +
 +		ufs->workbasedir = workpath.dentry;
 +		upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +		err = -EOPNOTSUPP;
 +		if (!upper_stack_depth) {
 +			pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +			goto out_put_workpath;
 +		}
 +
 +		*overlay_stack_depth = *upper_stack_depth;
 +	}
++<<<<<<< HEAD
 +
 +	err = -ENOMEM;
 +	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
 +	if (!lowertmp)
 +		goto out_unlock_workdentry;
 +
 +	err = -EINVAL;
 +	stacklen = ovl_split_lowerdirs(lowertmp);
 +	if (stacklen > OVL_MAX_STACK) {
 +		pr_err("overlayfs: too many lower directories, limit is %d\n",
 +		       OVL_MAX_STACK);
 +		goto out_free_lowertmp;
 +	} else if (!ufs->config.upperdir && stacklen == 1) {
 +		pr_err("overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n");
 +		goto out_free_lowertmp;
 +	}
 +
 +	err = -ENOMEM;
 +	stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);
 +	if (!stack)
 +		goto out_free_lowertmp;
 +
 +	err = -EINVAL;
 +	lower = lowertmp;
 +	for (numlower = 0; numlower < stacklen; numlower++) {
 +		err = ovl_lower_dir(lower, &stack[numlower], ufs,
 +				    overlay_stack_depth, &remote);
  		if (err)
 -			goto out_unlock_workdentry;
 +			goto out_put_lowerpath;
  
 -		sb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth;
 +		lower = strchr(lower, '\0') + 1;
  	}
 +
 +	err = -EINVAL;
 +	*overlay_stack_depth += 1;
 +	if (*overlay_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 +		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 +		goto out_put_lowerpath;
 +	}
 +
++=======
+ 	err = ovl_get_lowerstack(sb, ufs, &stack, &numlower);
+ 	if (err)
+ 		goto out_unlock_workdentry;
+ 
++>>>>>>> 53dbb0b4787e (ovl: split out ovl_get_lowerstack() from ovl_fill_super())
  	if (ufs->config.upperdir) {
  		ufs->upper_mnt = clone_private_mount(&upperpath);
  		err = PTR_ERR(ufs->upper_mnt);
@@@ -1153,11 -1175,6 +1296,14 @@@
  	if (!ufs->indexdir)
  		ufs->config.index = false;
  
++<<<<<<< HEAD
 +	if (remote)
 +		sb->s_d_op = &ovl_reval_dentry_operations.ops;
 +	else
 +		sb->s_d_op = &ovl_dentry_operations.ops;
 +
++=======
++>>>>>>> 53dbb0b4787e (ovl: split out ovl_get_lowerstack() from ovl_fill_super())
  	err = -ENOMEM;
  	ufs->creator_cred = cred = prepare_creds();
  	if (!cred)
@@@ -1184,8 -1196,8 +1330,7 @@@
  	mntput(upperpath.mnt);
  	for (i = 0; i < numlower; i++)
  		mntput(stack[i].mnt);
 -	kfree(stack);
  	mntput(workpath.mnt);
- 	kfree(lowertmp);
  
  	if (upperpath.dentry) {
  		oe->has_upper = true;
* Unmerged path fs/overlayfs/super.c
