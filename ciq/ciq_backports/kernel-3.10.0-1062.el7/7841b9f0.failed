gfs2: hole_size improvement

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 7841b9f08444b9c27090ec94101b96265572865f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7841b9f0.failed

Reimplement function hole_size based on a generic function for walking
the metadata tree and rename hole_size to gfs2_hole_size.  While
previously, multiple invocations of hole_size were sometimes needed to
walk across the entire hole, the new implementation always returns the
entire hole at once (provided that the caller is interested in the total
size).

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 7841b9f08444b9c27090ec94101b96265572865f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/bmap.c
diff --cc fs/gfs2/bmap.c
index 2b54e62ca6f7,69f846418ad5..000000000000
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@@ -279,15 -278,26 +279,34 @@@ static inline __be64 *metapointer(unsig
  	return p + mp->mp_list[height];
  }
  
++<<<<<<< HEAD
 +static void gfs2_metapath_ra(struct gfs2_glock *gl, struct metapath *mp,
 +			     unsigned int height)
++=======
+ static inline const __be64 *metaend(unsigned int height, const struct metapath *mp)
+ {
+ 	const struct buffer_head *bh = mp->mp_bh[height];
+ 	return (const __be64 *)(bh->b_data + bh->b_size);
+ }
+ 
+ static void clone_metapath(struct metapath *clone, struct metapath *mp)
+ {
+ 	unsigned int hgt;
+ 
+ 	*clone = *mp;
+ 	for (hgt = 0; hgt < mp->mp_aheight; hgt++)
+ 		get_bh(clone->mp_bh[hgt]);
+ }
+ 
+ static void gfs2_metapath_ra(struct gfs2_glock *gl, __be64 *start, __be64 *end)
++>>>>>>> 7841b9f08444 (gfs2: hole_size improvement)
  {
 +	struct buffer_head *bh = mp->mp_bh[height];
 +	const __be64 *pos = metapointer(height, mp);
 +	const __be64 *endp = (const __be64 *)(bh->b_data + bh->b_size);
  	const __be64 *t;
  
 -	for (t = start; t < end; t++) {
 +	for (t = pos; t < endp; t++) {
  		struct buffer_head *rabh;
  
  		if (!*t)
* Unmerged path fs/gfs2/bmap.c
