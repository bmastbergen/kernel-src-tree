thermal/intel_powerclamp: fix truncated kthread name

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [thermal] intel_powerclamp: fix truncated kthread name (David Arcari) [1716946]
Rebuild_FUZZ: 91.67%
commit-author Zhang Rui <rui.zhang@intel.com>
commit e925b5be5751f6a7286bbd9a4cbbc4ac90cc5fa6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e925b5be.failed

kthread name only allows 15 characters (TASK_COMMON_LEN is 16).
Thus rename the kthreads created by intel_powerclamp driver from
"kidle_inject/ + decimal cpuid" to "kidle_inj/ + decimal cpuid"
to avoid truncated kthead name for cpu 100 and later.

	Signed-off-by: Zhang Rui <rui.zhang@intel.com>
(cherry picked from commit e925b5be5751f6a7286bbd9a4cbbc4ac90cc5fa6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/thermal/intel_powerclamp.c
diff --cc drivers/thermal/intel_powerclamp.c
index 9c253c7b902f,9434f4eb421a..000000000000
--- a/drivers/thermal/intel_powerclamp.c
+++ b/drivers/thermal/intel_powerclamp.c
@@@ -508,6 -489,57 +508,60 @@@ static void poll_pkg_cstate(struct work
  		schedule_delayed_work(&poll_pkg_cstate_work, HZ);
  }
  
++<<<<<<< HEAD:drivers/thermal/intel_powerclamp.c
++=======
+ static void start_power_clamp_worker(unsigned long cpu)
+ {
+ 	struct powerclamp_worker_data *w_data = per_cpu_ptr(worker_data, cpu);
+ 	struct kthread_worker *worker;
+ 
+ 	worker = kthread_create_worker_on_cpu(cpu, 0, "kidle_inj/%ld", cpu);
+ 	if (IS_ERR(worker))
+ 		return;
+ 
+ 	w_data->worker = worker;
+ 	w_data->count = 0;
+ 	w_data->cpu = cpu;
+ 	w_data->clamping = true;
+ 	set_bit(cpu, cpu_clamping_mask);
+ 	sched_setscheduler(worker->task, SCHED_FIFO, &sparam);
+ 	kthread_init_work(&w_data->balancing_work, clamp_balancing_func);
+ 	kthread_init_delayed_work(&w_data->idle_injection_work,
+ 				  clamp_idle_injection_func);
+ 	kthread_queue_work(w_data->worker, &w_data->balancing_work);
+ }
+ 
+ static void stop_power_clamp_worker(unsigned long cpu)
+ {
+ 	struct powerclamp_worker_data *w_data = per_cpu_ptr(worker_data, cpu);
+ 
+ 	if (!w_data->worker)
+ 		return;
+ 
+ 	w_data->clamping = false;
+ 	/*
+ 	 * Make sure that all works that get queued after this point see
+ 	 * the clamping disabled. The counter part is not needed because
+ 	 * there is an implicit memory barrier when the queued work
+ 	 * is proceed.
+ 	 */
+ 	smp_wmb();
+ 	kthread_cancel_work_sync(&w_data->balancing_work);
+ 	kthread_cancel_delayed_work_sync(&w_data->idle_injection_work);
+ 	/*
+ 	 * The balancing work still might be queued here because
+ 	 * the handling of the "clapming" variable, cancel, and queue
+ 	 * operations are not synchronized via a lock. But it is not
+ 	 * a big deal. The balancing work is fast and destroy kthread
+ 	 * will wait for it.
+ 	 */
+ 	clear_bit(w_data->cpu, cpu_clamping_mask);
+ 	kthread_destroy_worker(w_data->worker);
+ 
+ 	w_data->worker = NULL;
+ }
+ 
++>>>>>>> e925b5be5751 (thermal/intel_powerclamp: fix truncated kthread name):drivers/thermal/intel/intel_powerclamp.c
  static int start_power_clamp(void)
  {
  	unsigned long cpu;
* Unmerged path drivers/thermal/intel_powerclamp.c
