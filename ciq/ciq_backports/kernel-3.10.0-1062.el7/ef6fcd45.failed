mlx5: fix get_ip_proto()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Cong Wang <xiyou.wangcong@gmail.com>
commit ef6fcd455278c2be3032a346cc66d9dd9866b787
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ef6fcd45.failed

IP header is not necessarily located right after struct ethhdr,
there could be multiple 802.1Q headers in between, this is why
we call __vlan_get_protocol().

Fixes: fe1dc069990c ("net/mlx5e: don't set CHECKSUM_COMPLETE on SCTP packets")
	Cc: Alaa Hleihel <alaa@mellanox.com>
	Cc: Or Gerlitz <ogerlitz@mellanox.com>
	Cc: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Reviewed-by: Tariq Toukan <tariqt@mellanox.com>
	Acked-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ef6fcd455278c2be3032a346cc66d9dd9866b787)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
index a60ee24e6b99,624eed345b5d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
@@@ -635,12 -688,48 +635,49 @@@ static inline void mlx5e_skb_set_hash(s
  	skb_set_hash(skb, be32_to_cpu(cqe->rss_hash_result), ht);
  }
  
 -static inline bool is_last_ethertype_ip(struct sk_buff *skb, int *network_depth,
 -					__be16 *proto)
 +static inline bool is_last_ethertype_ip(struct sk_buff *skb, int *network_depth)
  {
 -	*proto = ((struct ethhdr *)skb->data)->h_proto;
 -	*proto = __vlan_get_protocol(skb, *proto, network_depth);
 -	return (*proto == htons(ETH_P_IP) || *proto == htons(ETH_P_IPV6));
 -}
 +	__be16 ethertype = ((struct ethhdr *)skb->data)->h_proto;
  
++<<<<<<< HEAD
 +	ethertype = __vlan_get_protocol(skb, ethertype, network_depth);
 +	return (ethertype == htons(ETH_P_IP) || ethertype == htons(ETH_P_IPV6));
++=======
+ static inline void mlx5e_enable_ecn(struct mlx5e_rq *rq, struct sk_buff *skb)
+ {
+ 	int network_depth = 0;
+ 	__be16 proto;
+ 	void *ip;
+ 	int rc;
+ 
+ 	if (unlikely(!is_last_ethertype_ip(skb, &network_depth, &proto)))
+ 		return;
+ 
+ 	ip = skb->data + network_depth;
+ 	rc = ((proto == htons(ETH_P_IP)) ? IP_ECN_set_ce((struct iphdr *)ip) :
+ 					 IP6_ECN_set_ce(skb, (struct ipv6hdr *)ip));
+ 
+ 	rq->stats->ecn_mark += !!rc;
+ }
+ 
+ static u32 mlx5e_get_fcs(const struct sk_buff *skb)
+ {
+ 	const void *fcs_bytes;
+ 	u32 _fcs_bytes;
+ 
+ 	fcs_bytes = skb_header_pointer(skb, skb->len - ETH_FCS_LEN,
+ 				       ETH_FCS_LEN, &_fcs_bytes);
+ 
+ 	return __get_unaligned_cpu32(fcs_bytes);
+ }
+ 
+ static u8 get_ip_proto(struct sk_buff *skb, int network_depth, __be16 proto)
+ {
+ 	void *ip_p = skb->data + network_depth;
+ 
+ 	return (proto == htons(ETH_P_IP)) ? ((struct iphdr *)ip_p)->protocol :
+ 					    ((struct ipv6hdr *)ip_p)->nexthdr;
++>>>>>>> ef6fcd455278 (mlx5: fix get_ip_proto())
  }
  
  static inline void mlx5e_handle_csum(struct net_device *netdev,
@@@ -661,7 -751,13 +698,17 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	if (likely(is_last_ethertype_ip(skb, &network_depth))) {
++=======
+ 	if (unlikely(test_bit(MLX5E_RQ_STATE_NO_CSUM_COMPLETE, &rq->state)))
+ 		goto csum_unnecessary;
+ 
+ 	if (likely(is_last_ethertype_ip(skb, &network_depth, &proto))) {
+ 		if (unlikely(get_ip_proto(skb, network_depth, proto) == IPPROTO_SCTP))
+ 			goto csum_unnecessary;
+ 
++>>>>>>> ef6fcd455278 (mlx5: fix get_ip_proto())
  		skb->ip_summed = CHECKSUM_COMPLETE;
  		skb->csum = csum_unfold((__force __sum16)cqe->check_sum);
  		if (network_depth > ETH_HLEN)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
