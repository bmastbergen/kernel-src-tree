powerpc/64: Call setup_barrier_nospec() from setup_arch()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [powerpc] 64: Call setup_barrier_nospec() from setup_arch() (Gustavo Duarte) [1694459]
Rebuild_FUZZ: 92.45%
commit-author Michael Ellerman <mpe@ellerman.id.au>
commit af375eefbfb27cbb5b831984e66d724a40d26b5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/af375eef.failed

Currently we require platform code to call setup_barrier_nospec(). But
if we add an empty definition for the !CONFIG_PPC_BARRIER_NOSPEC case
then we can call it in setup_arch().

	Signed-off-by: Diana Craciun <diana.craciun@nxp.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit af375eefbfb27cbb5b831984e66d724a40d26b5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/setup.h
#	arch/powerpc/kernel/setup-common.c
diff --cc arch/powerpc/include/asm/setup.h
index cb1e56079d12,1a951b00465d..000000000000
--- a/arch/powerpc/include/asm/setup.h
+++ b/arch/powerpc/include/asm/setup.h
@@@ -40,6 -52,19 +40,22 @@@ enum l1d_flush_type 
  
  void setup_rfi_flush(enum l1d_flush_type, bool enable);
  void do_rfi_flush_fixups(enum l1d_flush_type types);
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PPC_BARRIER_NOSPEC
+ void setup_barrier_nospec(void);
+ #else
+ static inline void setup_barrier_nospec(void) { };
+ #endif
+ void do_barrier_nospec_fixups(bool enable);
+ extern bool barrier_nospec_enabled;
+ 
+ #ifdef CONFIG_PPC_BARRIER_NOSPEC
+ void do_barrier_nospec_fixups_range(bool enable, void *start, void *end);
+ #else
+ static inline void do_barrier_nospec_fixups_range(bool enable, void *start, void *end) { };
+ #endif
++>>>>>>> af375eefbfb2 (powerpc/64: Call setup_barrier_nospec() from setup_arch())
  
  #endif /* !__ASSEMBLY__ */
  
diff --cc arch/powerpc/kernel/setup-common.c
index a82612b417fc,93fa0c99681e..000000000000
--- a/arch/powerpc/kernel/setup-common.c
+++ b/arch/powerpc/kernel/setup-common.c
@@@ -773,5 -792,197 +773,201 @@@ void arch_setup_pdev_archdata(struct pl
  {
  	pdev->archdata.dma_mask = DMA_BIT_MASK(32);
  	pdev->dev.dma_mask = &pdev->archdata.dma_mask;
++<<<<<<< HEAD
 + 	set_dma_ops(&pdev->dev, &dma_direct_ops);
++=======
+  	set_dma_ops(&pdev->dev, &dma_nommu_ops);
+ }
+ 
+ static __init void print_system_info(void)
+ {
+ 	pr_info("-----------------------------------------------------\n");
+ #ifdef CONFIG_PPC_BOOK3S_64
+ 	pr_info("ppc64_pft_size    = 0x%llx\n", ppc64_pft_size);
+ #endif
+ #ifdef CONFIG_PPC_STD_MMU_32
+ 	pr_info("Hash_size         = 0x%lx\n", Hash_size);
+ #endif
+ 	pr_info("phys_mem_size     = 0x%llx\n",
+ 		(unsigned long long)memblock_phys_mem_size());
+ 
+ 	pr_info("dcache_bsize      = 0x%x\n", dcache_bsize);
+ 	pr_info("icache_bsize      = 0x%x\n", icache_bsize);
+ 	if (ucache_bsize != 0)
+ 		pr_info("ucache_bsize      = 0x%x\n", ucache_bsize);
+ 
+ 	pr_info("cpu_features      = 0x%016lx\n", cur_cpu_spec->cpu_features);
+ 	pr_info("  possible        = 0x%016lx\n",
+ 		(unsigned long)CPU_FTRS_POSSIBLE);
+ 	pr_info("  always          = 0x%016lx\n",
+ 		(unsigned long)CPU_FTRS_ALWAYS);
+ 	pr_info("cpu_user_features = 0x%08x 0x%08x\n",
+ 		cur_cpu_spec->cpu_user_features,
+ 		cur_cpu_spec->cpu_user_features2);
+ 	pr_info("mmu_features      = 0x%08x\n", cur_cpu_spec->mmu_features);
+ #ifdef CONFIG_PPC64
+ 	pr_info("firmware_features = 0x%016lx\n", powerpc_firmware_features);
+ #endif
+ 
+ #ifdef CONFIG_PPC_BOOK3S_64
+ 	if (htab_address)
+ 		pr_info("htab_address      = 0x%p\n", htab_address);
+ 	if (htab_hash_mask)
+ 		pr_info("htab_hash_mask    = 0x%lx\n", htab_hash_mask);
+ #endif
+ #ifdef CONFIG_PPC_STD_MMU_32
+ 	if (Hash)
+ 		pr_info("Hash              = 0x%p\n", Hash);
+ 	if (Hash_mask)
+ 		pr_info("Hash_mask         = 0x%lx\n", Hash_mask);
+ #endif
+ 
+ 	if (PHYSICAL_START > 0)
+ 		pr_info("physical_start    = 0x%llx\n",
+ 		       (unsigned long long)PHYSICAL_START);
+ 	pr_info("-----------------------------------------------------\n");
+ }
+ 
+ #ifdef CONFIG_SMP
+ static void smp_setup_pacas(void)
+ {
+ 	int cpu;
+ 
+ 	for_each_possible_cpu(cpu) {
+ 		if (cpu == smp_processor_id())
+ 			continue;
+ 		allocate_paca(cpu);
+ 		set_hard_smp_processor_id(cpu, cpu_to_phys_id[cpu]);
+ 	}
+ 
+ 	memblock_free(__pa(cpu_to_phys_id), nr_cpu_ids * sizeof(u32));
+ 	cpu_to_phys_id = NULL;
+ }
+ #endif
+ 
+ /*
+  * Called into from start_kernel this initializes memblock, which is used
+  * to manage page allocation until mem_init is called.
+  */
+ void __init setup_arch(char **cmdline_p)
+ {
+ 	*cmdline_p = boot_command_line;
+ 
+ 	/* Set a half-reasonable default so udelay does something sensible */
+ 	loops_per_jiffy = 500000000 / HZ;
+ 
+ 	/* Unflatten the device-tree passed by prom_init or kexec */
+ 	unflatten_device_tree();
+ 
+ 	/*
+ 	 * Initialize cache line/block info from device-tree (on ppc64) or
+ 	 * just cputable (on ppc32).
+ 	 */
+ 	initialize_cache_info();
+ 
+ 	/* Initialize RTAS if available. */
+ 	rtas_initialize();
+ 
+ 	/* Check if we have an initrd provided via the device-tree. */
+ 	check_for_initrd();
+ 
+ 	/* Probe the machine type, establish ppc_md. */
+ 	probe_machine();
+ 
+ 	/* Setup panic notifier if requested by the platform. */
+ 	setup_panic();
+ 
+ 	/*
+ 	 * Configure ppc_md.power_save (ppc32 only, 64-bit machines do
+ 	 * it from their respective probe() function.
+ 	 */
+ 	setup_power_save();
+ 
+ 	/* Discover standard serial ports. */
+ 	find_legacy_serial_ports();
+ 
+ 	/* Register early console with the printk subsystem. */
+ 	register_early_udbg_console();
+ 
+ 	/* Setup the various CPU maps based on the device-tree. */
+ 	smp_setup_cpu_maps();
+ 
+ 	/* Initialize xmon. */
+ 	xmon_setup();
+ 
+ 	/* Check the SMT related command line arguments (ppc64). */
+ 	check_smt_enabled();
+ 
+ 	/* Parse memory topology */
+ 	mem_topology_setup();
+ 
+ 	/*
+ 	 * Release secondary cpus out of their spinloops at 0x60 now that
+ 	 * we can map physical -> logical CPU ids.
+ 	 *
+ 	 * Freescale Book3e parts spin in a loop provided by firmware,
+ 	 * so smp_release_cpus() does nothing for them.
+ 	 */
+ #ifdef CONFIG_SMP
+ 	smp_setup_pacas();
+ 
+ 	/* On BookE, setup per-core TLB data structures. */
+ 	setup_tlb_core_data();
+ 
+ 	smp_release_cpus();
+ #endif
+ 
+ 	/* Print various info about the machine that has been gathered so far. */
+ 	print_system_info();
+ 
+ 	/* Reserve large chunks of memory for use by CMA for KVM. */
+ 	kvm_cma_reserve();
+ 
+ 	klp_init_thread_info(&init_thread_info);
+ 
+ 	init_mm.start_code = (unsigned long)_stext;
+ 	init_mm.end_code = (unsigned long) _etext;
+ 	init_mm.end_data = (unsigned long) _edata;
+ 	init_mm.brk = klimit;
+ 
+ #ifdef CONFIG_PPC_MM_SLICES
+ #ifdef CONFIG_PPC64
+ 	if (!radix_enabled())
+ 		init_mm.context.slb_addr_limit = DEFAULT_MAP_WINDOW_USER64;
+ #elif defined(CONFIG_PPC_8xx)
+ 	init_mm.context.slb_addr_limit = DEFAULT_MAP_WINDOW;
+ #else
+ #error	"context.addr_limit not initialized."
+ #endif
+ #endif
+ 
+ #ifdef CONFIG_SPAPR_TCE_IOMMU
+ 	mm_iommu_init(&init_mm);
+ #endif
+ 	irqstack_early_init();
+ 	exc_lvl_early_init();
+ 	emergency_stack_init();
+ 
+ 	initmem_init();
+ 
+ #ifdef CONFIG_DUMMY_CONSOLE
+ 	conswitchp = &dummy_con;
+ #endif
+ 	if (ppc_md.setup_arch)
+ 		ppc_md.setup_arch();
+ 
+ 	setup_barrier_nospec();
+ 
+ 	paging_init();
+ 
+ 	/* Initialize the MMU context management stuff. */
+ 	mmu_context_init();
+ 
+ #ifdef CONFIG_PPC64
+ 	/* Interrupt code needs to be 64K-aligned. */
+ 	if ((unsigned long)_stext & 0xffff)
+ 		panic("Kernelbase not 64K-aligned (0x%lx)!\n",
+ 		      (unsigned long)_stext);
+ #endif
++>>>>>>> af375eefbfb2 (powerpc/64: Call setup_barrier_nospec() from setup_arch())
  }
* Unmerged path arch/powerpc/include/asm/setup.h
* Unmerged path arch/powerpc/kernel/setup-common.c
