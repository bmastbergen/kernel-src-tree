RDMA/drivers: Use core provided API for registering device attributes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Parav Pandit <parav@mellanox.com>
commit 508a523f6bc6cdfbf7031d66559d4ad24956b741
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/508a523f.failed

Use rdma_set_device_sysfs_group() to register device attributes and
simplify the driver.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 508a523f6bc6cdfbf7031d66559d4ad24956b741)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/bnxt_re/main.c
#	drivers/infiniband/hw/cxgb3/iwch_provider.c
#	drivers/infiniband/hw/cxgb4/provider.c
#	drivers/infiniband/hw/hfi1/verbs.c
#	drivers/infiniband/hw/i40iw/i40iw_verbs.c
#	drivers/infiniband/hw/mlx4/main.c
#	drivers/infiniband/hw/mlx5/ib_rep.c
#	drivers/infiniband/hw/mlx5/main.c
#	drivers/infiniband/hw/mlx5/mlx5_ib.h
#	drivers/infiniband/hw/mthca/mthca_provider.c
#	drivers/infiniband/hw/nes/nes_verbs.c
#	drivers/infiniband/hw/ocrdma/ocrdma_main.c
#	drivers/infiniband/hw/qedr/main.c
#	drivers/infiniband/hw/usnic/usnic_ib_main.c
#	drivers/infiniband/hw/usnic/usnic_ib_sysfs.c
#	drivers/infiniband/sw/rxe/rxe_verbs.c
diff --cc drivers/infiniband/hw/bnxt_re/main.c
index 253964bbac4b,cf2282654210..000000000000
--- a/drivers/infiniband/hw/bnxt_re/main.c
+++ b/drivers/infiniband/hw/bnxt_re/main.c
@@@ -640,33 -666,11 +668,15 @@@ static int bnxt_re_register_ib(struct b
  	ibdev->get_hw_stats             = bnxt_re_ib_get_hw_stats;
  	ibdev->alloc_hw_stats           = bnxt_re_ib_alloc_hw_stats;
  
++<<<<<<< HEAD
 +	return ib_register_device(ibdev, NULL);
++=======
+ 	rdma_set_device_sysfs_group(ibdev, &bnxt_re_dev_attr_group);
+ 	ibdev->driver_id = RDMA_DRIVER_BNXT_RE;
+ 	return ib_register_device(ibdev, "bnxt_re%d", NULL);
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  }
  
- static ssize_t show_rev(struct device *device, struct device_attribute *attr,
- 			char *buf)
- {
- 	struct bnxt_re_dev *rdev = to_bnxt_re_dev(device, ibdev.dev);
- 
- 	return scnprintf(buf, PAGE_SIZE, "0x%x\n", rdev->en_dev->pdev->vendor);
- }
- 
- static ssize_t show_hca(struct device *device, struct device_attribute *attr,
- 			char *buf)
- {
- 	struct bnxt_re_dev *rdev = to_bnxt_re_dev(device, ibdev.dev);
- 
- 	return scnprintf(buf, PAGE_SIZE, "%s\n", rdev->ibdev.node_desc);
- }
- 
- static DEVICE_ATTR(hw_rev, 0444, show_rev, NULL);
- static DEVICE_ATTR(hca_type, 0444, show_hca, NULL);
- 
- static struct device_attribute *bnxt_re_attributes[] = {
- 	&dev_attr_hw_rev,
- 	&dev_attr_hca_type
- };
- 
  static void bnxt_re_dev_remove(struct bnxt_re_dev *rdev)
  {
  	dev_put(rdev->netdev);
diff --cc drivers/infiniband/hw/cxgb3/iwch_provider.c
index a723ed67a705,ebbec02cebe0..000000000000
--- a/drivers/infiniband/hw/cxgb3/iwch_provider.c
+++ b/drivers/infiniband/hw/cxgb3/iwch_provider.c
@@@ -1353,10 -1320,8 +1357,9 @@@ static void get_dev_fw_ver_str(struct i
  int iwch_register_device(struct iwch_dev *dev)
  {
  	int ret;
- 	int i;
  
  	pr_debug("%s iwch_dev %p\n", __func__, dev);
 +	strlcpy(dev->ibdev.name, "cxgb3_%d", IB_DEVICE_NAME_MAX);
  	memset(&dev->ibdev.node_guid, 0, sizeof(dev->ibdev.node_guid));
  	memcpy(&dev->ibdev.node_guid, dev->rdev.t3cdev_p->lldev->dev_addr, 6);
  	dev->ibdev.owner = THIS_MODULE;
@@@ -1443,22 -1403,11 +1446,15 @@@
  	memcpy(dev->ibdev.iwcm->ifname, dev->rdev.t3cdev_p->lldev->name,
  	       sizeof(dev->ibdev.iwcm->ifname));
  
++<<<<<<< HEAD
 +	ret = ib_register_device(&dev->ibdev, NULL);
++=======
+ 	dev->ibdev.driver_id = RDMA_DRIVER_CXGB3;
+ 	rdma_set_device_sysfs_group(&dev->ibdev, &iwch_attr_group);
+ 	ret = ib_register_device(&dev->ibdev, "cxgb3_%d", NULL);
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  	if (ret)
- 		goto bail1;
- 
- 	for (i = 0; i < ARRAY_SIZE(iwch_class_attributes); ++i) {
- 		ret = device_create_file(&dev->ibdev.dev,
- 					 iwch_class_attributes[i]);
- 		if (ret) {
- 			goto bail2;
- 		}
- 	}
- 	return 0;
- bail2:
- 	ib_unregister_device(&dev->ibdev);
- bail1:
- 	kfree(dev->ibdev.iwcm);
+ 		kfree(dev->ibdev.iwcm);
  	return ret;
  }
  
diff --cc drivers/infiniband/hw/cxgb4/provider.c
index 596ceaefacf4,cbb3c0ddd990..000000000000
--- a/drivers/infiniband/hw/cxgb4/provider.c
+++ b/drivers/infiniband/hw/cxgb4/provider.c
@@@ -648,19 -627,14 +651,17 @@@ void c4iw_register_device(struct work_s
  	memcpy(dev->ibdev.iwcm->ifname, dev->rdev.lldi.ports[0]->name,
  	       sizeof(dev->ibdev.iwcm->ifname));
  
++<<<<<<< HEAD
 +	ret = ib_register_device(&dev->ibdev, NULL);
++=======
+ 	rdma_set_device_sysfs_group(&dev->ibdev, &c4iw_attr_group);
+ 	dev->ibdev.driver_id = RDMA_DRIVER_CXGB4;
+ 	ret = ib_register_device(&dev->ibdev, "cxgb4_%d", NULL);
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  	if (ret)
  		goto err_kfree_iwcm;
- 
- 	for (i = 0; i < ARRAY_SIZE(c4iw_class_attributes); ++i) {
- 		ret = device_create_file(&dev->ibdev.dev,
- 					 c4iw_class_attributes[i]);
- 		if (ret)
- 			goto err_unregister_device;
- 	}
  	return;
- err_unregister_device:
- 	ib_unregister_device(&dev->ibdev);
+ 
  err_kfree_iwcm:
  	kfree(dev->ibdev.iwcm);
  err_dealloc_ctx:
diff --cc drivers/infiniband/hw/hfi1/verbs.c
index 1eb855337269,48e11e510358..000000000000
--- a/drivers/infiniband/hw/hfi1/verbs.c
+++ b/drivers/infiniband/hw/hfi1/verbs.c
@@@ -1951,7 -1751,10 +1951,14 @@@ int hfi1_register_ib_device(struct hfi1
  			      i,
  			      ppd->pkeys);
  
++<<<<<<< HEAD
 +	ret = rvt_register_device(&dd->verbs_dev.rdi);
++=======
+ 	rdma_set_device_sysfs_group(&dd->verbs_dev.rdi.ibdev,
+ 				    &ib_hfi1_attr_group);
+ 
+ 	ret = rvt_register_device(&dd->verbs_dev.rdi, RDMA_DRIVER_HFI1);
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  	if (ret)
  		goto err_verbs_txreq;
  
diff --cc drivers/infiniband/hw/i40iw/i40iw_verbs.c
index 60e004d2100e,102875872bea..000000000000
--- a/drivers/infiniband/hw/i40iw/i40iw_verbs.c
+++ b/drivers/infiniband/hw/i40iw/i40iw_verbs.c
@@@ -2926,8 -2883,9 +2915,14 @@@ int i40iw_register_rdma_device(struct i
  	if (!iwdev->iwibdev)
  		return -ENOMEM;
  	iwibdev = iwdev->iwibdev;
++<<<<<<< HEAD
 +
 +	ret = ib_register_device(&iwibdev->ibdev, NULL);
++=======
+ 	rdma_set_device_sysfs_group(&iwibdev->ibdev, &i40iw_attr_group);
+ 	iwibdev->ibdev.driver_id = RDMA_DRIVER_I40IW;
+ 	ret = ib_register_device(&iwibdev->ibdev, "i40iw%d", NULL);
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  	if (ret)
  		goto error;
  
diff --cc drivers/infiniband/hw/mlx4/main.c
index 4d672cfcddd2,0def2323459c..000000000000
--- a/drivers/infiniband/hw/mlx4/main.c
+++ b/drivers/infiniband/hw/mlx4/main.c
@@@ -2892,7 -2807,9 +2896,13 @@@ static void *mlx4_ib_add(struct mlx4_de
  	if (mlx4_ib_alloc_diag_counters(ibdev))
  		goto err_steer_free_bitmap;
  
++<<<<<<< HEAD
 +	if (ib_register_device(&ibdev->ib_dev, NULL))
++=======
+ 	rdma_set_device_sysfs_group(&ibdev->ib_dev, &mlx4_attr_group);
+ 	ibdev->ib_dev.driver_id = RDMA_DRIVER_MLX4;
+ 	if (ib_register_device(&ibdev->ib_dev, "mlx4_%d", NULL))
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  		goto err_diag_counters;
  
  	if (mlx4_ib_mad_init(ibdev))
diff --cc drivers/infiniband/hw/mlx5/main.c
index 7e6f22b16875,be701d40289e..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -4832,12 -6107,24 +4836,28 @@@ static void mlx5_ib_stage_bfrag_cleanup
  	mlx5_free_bfreg(dev->mdev, &dev->bfreg);
  }
  
 -static int mlx5_ib_stage_populate_specs(struct mlx5_ib_dev *dev)
 +static int mlx5_ib_stage_ib_reg_init(struct mlx5_ib_dev *dev)
  {
 -	return populate_specs_root(dev);
 +	return ib_register_device(&dev->ib_dev, NULL);
  }
  
++<<<<<<< HEAD
 +static void mlx5_ib_stage_pre_ib_reg_umr_cleanup(struct mlx5_ib_dev *dev)
++=======
+ int mlx5_ib_stage_ib_reg_init(struct mlx5_ib_dev *dev)
+ {
+ 	const char *name;
+ 
+ 	rdma_set_device_sysfs_group(&dev->ib_dev, &mlx5_attr_group);
+ 	if (!mlx5_lag_is_active(dev->mdev))
+ 		name = "mlx5_%d";
+ 	else
+ 		name = "mlx5_bond_%d";
+ 	return ib_register_device(&dev->ib_dev, name, NULL);
+ }
+ 
+ void mlx5_ib_stage_pre_ib_reg_umr_cleanup(struct mlx5_ib_dev *dev)
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  {
  	destroy_umrc_res(dev);
  }
@@@ -4864,24 -6151,21 +4884,41 @@@ static void mlx5_ib_stage_delay_drop_cl
  	cancel_delay_drop(dev);
  }
  
++<<<<<<< HEAD
 +static int mlx5_ib_stage_class_attr_init(struct mlx5_ib_dev *dev)
 +{
 +	int err;
 +	int i;
 +
 +	for (i = 0; i < ARRAY_SIZE(mlx5_class_attributes); i++) {
 +		err = device_create_file(&dev->ib_dev.dev,
 +					 mlx5_class_attributes[i]);
 +		if (err)
 +			return err;
 +	}
++=======
+ static int mlx5_ib_stage_rep_reg_init(struct mlx5_ib_dev *dev)
+ {
+ 	mlx5_ib_register_vport_reps(dev);
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void __mlx5_ib_remove(struct mlx5_ib_dev *dev,
 +			     const struct mlx5_ib_profile *profile,
 +			     int stage)
++=======
+ static void mlx5_ib_stage_rep_reg_cleanup(struct mlx5_ib_dev *dev)
+ {
+ 	mlx5_ib_unregister_vport_reps(dev);
+ }
+ 
+ void __mlx5_ib_remove(struct mlx5_ib_dev *dev,
+ 		      const struct mlx5_ib_profile *profile,
+ 		      int stage)
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  {
  	/* Number of stages to cleanup */
  	while (stage) {
@@@ -4971,12 -6258,54 +5008,58 @@@ static const struct mlx5_ib_profile pf_
  	STAGE_CREATE(MLX5_IB_STAGE_DELAY_DROP,
  		     mlx5_ib_stage_delay_drop_init,
  		     mlx5_ib_stage_delay_drop_cleanup),
- 	STAGE_CREATE(MLX5_IB_STAGE_CLASS_ATTR,
- 		     mlx5_ib_stage_class_attr_init,
- 		     NULL),
  };
  
++<<<<<<< HEAD
 +static void *mlx5_ib_add_slave_port(struct mlx5_core_dev *mdev, u8 port_num)
++=======
+ static const struct mlx5_ib_profile nic_rep_profile = {
+ 	STAGE_CREATE(MLX5_IB_STAGE_INIT,
+ 		     mlx5_ib_stage_init_init,
+ 		     mlx5_ib_stage_init_cleanup),
+ 	STAGE_CREATE(MLX5_IB_STAGE_FLOW_DB,
+ 		     mlx5_ib_stage_flow_db_init,
+ 		     mlx5_ib_stage_flow_db_cleanup),
+ 	STAGE_CREATE(MLX5_IB_STAGE_CAPS,
+ 		     mlx5_ib_stage_caps_init,
+ 		     NULL),
+ 	STAGE_CREATE(MLX5_IB_STAGE_NON_DEFAULT_CB,
+ 		     mlx5_ib_stage_rep_non_default_cb,
+ 		     NULL),
+ 	STAGE_CREATE(MLX5_IB_STAGE_ROCE,
+ 		     mlx5_ib_stage_rep_roce_init,
+ 		     mlx5_ib_stage_rep_roce_cleanup),
+ 	STAGE_CREATE(MLX5_IB_STAGE_DEVICE_RESOURCES,
+ 		     mlx5_ib_stage_dev_res_init,
+ 		     mlx5_ib_stage_dev_res_cleanup),
+ 	STAGE_CREATE(MLX5_IB_STAGE_COUNTERS,
+ 		     mlx5_ib_stage_counters_init,
+ 		     mlx5_ib_stage_counters_cleanup),
+ 	STAGE_CREATE(MLX5_IB_STAGE_UAR,
+ 		     mlx5_ib_stage_uar_init,
+ 		     mlx5_ib_stage_uar_cleanup),
+ 	STAGE_CREATE(MLX5_IB_STAGE_BFREG,
+ 		     mlx5_ib_stage_bfrag_init,
+ 		     mlx5_ib_stage_bfrag_cleanup),
+ 	STAGE_CREATE(MLX5_IB_STAGE_PRE_IB_REG_UMR,
+ 		     NULL,
+ 		     mlx5_ib_stage_pre_ib_reg_umr_cleanup),
+ 	STAGE_CREATE(MLX5_IB_STAGE_SPECS,
+ 		     mlx5_ib_stage_populate_specs,
+ 		     NULL),
+ 	STAGE_CREATE(MLX5_IB_STAGE_IB_REG,
+ 		     mlx5_ib_stage_ib_reg_init,
+ 		     mlx5_ib_stage_ib_reg_cleanup),
+ 	STAGE_CREATE(MLX5_IB_STAGE_POST_IB_REG_UMR,
+ 		     mlx5_ib_stage_post_ib_reg_umr_init,
+ 		     NULL),
+ 	STAGE_CREATE(MLX5_IB_STAGE_REP_REG,
+ 		     mlx5_ib_stage_rep_reg_init,
+ 		     mlx5_ib_stage_rep_reg_cleanup),
+ };
+ 
+ static void *mlx5_ib_add_slave_port(struct mlx5_core_dev *mdev)
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  {
  	struct mlx5_ib_multiport_info *mpi;
  	struct mlx5_ib_dev *dev;
diff --cc drivers/infiniband/hw/mlx5/mlx5_ib.h
index 15261eb5a7f6,8444ea78229a..000000000000
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@@ -1052,6 -1183,30 +1052,33 @@@ static inline void mlx5_odp_populate_kl
  
  #endif /* CONFIG_INFINIBAND_ON_DEMAND_PAGING */
  
++<<<<<<< HEAD
++=======
+ /* Needed for rep profile */
+ int mlx5_ib_stage_init_init(struct mlx5_ib_dev *dev);
+ void mlx5_ib_stage_init_cleanup(struct mlx5_ib_dev *dev);
+ int mlx5_ib_stage_rep_flow_db_init(struct mlx5_ib_dev *dev);
+ int mlx5_ib_stage_caps_init(struct mlx5_ib_dev *dev);
+ int mlx5_ib_stage_rep_non_default_cb(struct mlx5_ib_dev *dev);
+ int mlx5_ib_stage_rep_roce_init(struct mlx5_ib_dev *dev);
+ void mlx5_ib_stage_rep_roce_cleanup(struct mlx5_ib_dev *dev);
+ int mlx5_ib_stage_dev_res_init(struct mlx5_ib_dev *dev);
+ void mlx5_ib_stage_dev_res_cleanup(struct mlx5_ib_dev *dev);
+ int mlx5_ib_stage_counters_init(struct mlx5_ib_dev *dev);
+ void mlx5_ib_stage_counters_cleanup(struct mlx5_ib_dev *dev);
+ int mlx5_ib_stage_bfrag_init(struct mlx5_ib_dev *dev);
+ void mlx5_ib_stage_bfrag_cleanup(struct mlx5_ib_dev *dev);
+ void mlx5_ib_stage_pre_ib_reg_umr_cleanup(struct mlx5_ib_dev *dev);
+ int mlx5_ib_stage_ib_reg_init(struct mlx5_ib_dev *dev);
+ void mlx5_ib_stage_ib_reg_cleanup(struct mlx5_ib_dev *dev);
+ int mlx5_ib_stage_post_ib_reg_umr_init(struct mlx5_ib_dev *dev);
+ void __mlx5_ib_remove(struct mlx5_ib_dev *dev,
+ 		      const struct mlx5_ib_profile *profile,
+ 		      int stage);
+ void *__mlx5_ib_add(struct mlx5_ib_dev *dev,
+ 		    const struct mlx5_ib_profile *profile);
+ 
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  int mlx5_ib_get_vf_config(struct ib_device *device, int vf,
  			  u8 port, struct ifla_vf_info *info);
  int mlx5_ib_set_vf_link_state(struct ib_device *device, int vf,
diff --cc drivers/infiniband/hw/mthca/mthca_provider.c
index 7759795f66ff,691c6f048938..000000000000
--- a/drivers/infiniband/hw/mthca/mthca_provider.c
+++ b/drivers/infiniband/hw/mthca/mthca_provider.c
@@@ -1295,7 -1298,9 +1298,13 @@@ int mthca_register_device(struct mthca_
  
  	mutex_init(&dev->cap_mask_mutex);
  
++<<<<<<< HEAD
 +	ret = ib_register_device(&dev->ib_dev, NULL);
++=======
+ 	rdma_set_device_sysfs_group(&dev->ib_dev, &mthca_attr_group);
+ 	dev->ib_dev.driver_id = RDMA_DRIVER_MTHCA;
+ 	ret = ib_register_device(&dev->ib_dev, "mthca%d", NULL);
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  	if (ret)
  		return ret;
  
diff --cc drivers/infiniband/hw/nes/nes_verbs.c
index 989ad9f44435,92d1cadd4cfd..000000000000
--- a/drivers/infiniband/hw/nes/nes_verbs.c
+++ b/drivers/infiniband/hw/nes/nes_verbs.c
@@@ -3854,9 -3794,11 +3854,15 @@@ int nes_register_ofa_device(struct nes_
  	struct nes_vnic *nesvnic = nesibdev->nesvnic;
  	struct nes_device *nesdev = nesvnic->nesdev;
  	struct nes_adapter *nesadapter = nesdev->nesadapter;
- 	int i, ret;
+ 	int ret;
  
++<<<<<<< HEAD
 +	ret = ib_register_device(&nesvnic->nesibdev->ibdev, NULL);
++=======
+ 	rdma_set_device_sysfs_group(&nesvnic->nesibdev->ibdev, &nes_attr_group);
+ 	nesvnic->nesibdev->ibdev.driver_id = RDMA_DRIVER_NES;
+ 	ret = ib_register_device(&nesvnic->nesibdev->ibdev, "nes%d", NULL);
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  	if (ret) {
  		return ret;
  	}
diff --cc drivers/infiniband/hw/ocrdma/ocrdma_main.c
index 72c190ee9ffd,873cc7f6fe61..000000000000
--- a/drivers/infiniband/hw/ocrdma/ocrdma_main.c
+++ b/drivers/infiniband/hw/ocrdma/ocrdma_main.c
@@@ -114,9 -114,37 +114,38 @@@ static void get_dev_fw_str(struct ib_de
  	snprintf(str, IB_FW_VERSION_NAME_MAX, "%s", &dev->attr.fw_ver[0]);
  }
  
+ /* OCRDMA sysfs interface */
+ static ssize_t hw_rev_show(struct device *device,
+ 			   struct device_attribute *attr, char *buf)
+ {
+ 	struct ocrdma_dev *dev = dev_get_drvdata(device);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "0x%x\n", dev->nic_info.pdev->vendor);
+ }
+ static DEVICE_ATTR_RO(hw_rev);
+ 
+ static ssize_t hca_type_show(struct device *device,
+ 			     struct device_attribute *attr, char *buf)
+ {
+ 	struct ocrdma_dev *dev = dev_get_drvdata(device);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%s\n", &dev->model_number[0]);
+ }
+ static DEVICE_ATTR_RO(hca_type);
+ 
+ static struct attribute *ocrdma_attributes[] = {
+ 	&dev_attr_hw_rev.attr,
+ 	&dev_attr_hca_type.attr,
+ 	NULL
+ };
+ 
+ static const struct attribute_group ocrdma_attr_group = {
+ 	.attrs = ocrdma_attributes,
+ };
+ 
  static int ocrdma_register_device(struct ocrdma_dev *dev)
  {
 +	strlcpy(dev->ibdev.name, "ocrdma%d", IB_DEVICE_NAME_MAX);
  	ocrdma_get_guid(dev, (u8 *)&dev->ibdev.node_guid);
  	BUILD_BUG_ON(sizeof(OCRDMA_NODE_DESC) > IB_DEVICE_NODE_DESC_MAX);
  	memcpy(dev->ibdev.node_desc, OCRDMA_NODE_DESC,
@@@ -215,7 -241,9 +244,13 @@@
  		dev->ibdev.destroy_srq = ocrdma_destroy_srq;
  		dev->ibdev.post_srq_recv = ocrdma_post_srq_recv;
  	}
++<<<<<<< HEAD
 +	return ib_register_device(&dev->ibdev, NULL);
++=======
+ 	rdma_set_device_sysfs_group(&dev->ibdev, &ocrdma_attr_group);
+ 	dev->ibdev.driver_id = RDMA_DRIVER_OCRDMA;
+ 	return ib_register_device(&dev->ibdev, "ocrdma%d", NULL);
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  }
  
  static int ocrdma_alloc_resources(struct ocrdma_dev *dev)
diff --cc drivers/infiniband/hw/qedr/main.c
index 8f791881e4cb,8d6ff9df49fe..000000000000
--- a/drivers/infiniband/hw/qedr/main.c
+++ b/drivers/infiniband/hw/qedr/main.c
@@@ -253,8 -287,9 +280,14 @@@ static int qedr_register_device(struct 
  
  	dev->ibdev.get_link_layer = qedr_link_layer;
  	dev->ibdev.get_dev_fw_str = qedr_get_dev_fw_str;
++<<<<<<< HEAD
 +
 +	return ib_register_device(&dev->ibdev, NULL);
++=======
+ 	rdma_set_device_sysfs_group(&dev->ibdev, &qedr_attr_group);
+ 	dev->ibdev.driver_id = RDMA_DRIVER_QEDR;
+ 	return ib_register_device(&dev->ibdev, "qedr%d", NULL);
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  }
  
  /* This function allocates fast-path status block memory */
@@@ -394,92 -429,18 +427,61 @@@ err1
  	return rc;
  }
  
- /* QEDR sysfs interface */
- static ssize_t show_rev(struct device *device, struct device_attribute *attr,
- 			char *buf)
- {
- 	struct qedr_dev *dev = dev_get_drvdata(device);
- 
- 	return scnprintf(buf, PAGE_SIZE, "0x%x\n", dev->pdev->vendor);
- }
- 
- static ssize_t show_hca_type(struct device *device,
- 			     struct device_attribute *attr, char *buf)
- {
- 	return scnprintf(buf, PAGE_SIZE, "%s\n", "HCA_TYPE_TO_SET");
- }
- 
- static DEVICE_ATTR(hw_rev, S_IRUGO, show_rev, NULL);
- static DEVICE_ATTR(hca_type, S_IRUGO, show_hca_type, NULL);
- 
- static struct device_attribute *qedr_attributes[] = {
- 	&dev_attr_hw_rev,
- 	&dev_attr_hca_type
- };
- 
- static void qedr_remove_sysfiles(struct qedr_dev *dev)
- {
- 	int i;
- 
- 	for (i = 0; i < ARRAY_SIZE(qedr_attributes); i++)
- 		device_remove_file(&dev->ibdev.dev, qedr_attributes[i]);
- }
- 
  static void qedr_pci_set_atomic(struct qedr_dev *dev, struct pci_dev *pdev)
  {
 -	int rc = pci_enable_atomic_ops_to_root(pdev,
 -					       PCI_EXP_DEVCAP2_ATOMIC_COMP64);
 +	struct pci_dev *bridge;
 +	u32 ctl2, cap2;
 +	u16 flags;
 +	int rc;
  
 -	if (rc) {
 -		dev->atomic_cap = IB_ATOMIC_NONE;
 -		DP_DEBUG(dev, QEDR_MSG_INIT, "Atomic capability disabled\n");
 -	} else {
 -		dev->atomic_cap = IB_ATOMIC_GLOB;
 -		DP_DEBUG(dev, QEDR_MSG_INIT, "Atomic capability enabled\n");
 +	bridge = pdev->bus->self;
 +	if (!bridge)
 +		goto disable;
 +
 +	/* Check atomic routing support all the way to root complex */
 +	while (bridge->bus->parent) {
 +		rc = pcie_capability_read_word(bridge, PCI_EXP_FLAGS, &flags);
 +		if (rc || ((flags & PCI_EXP_FLAGS_VERS) < 2))
 +			goto disable;
 +
 +		rc = pcie_capability_read_dword(bridge, PCI_EXP_DEVCAP2, &cap2);
 +		if (rc)
 +			goto disable;
 +
 +		rc = pcie_capability_read_dword(bridge, PCI_EXP_DEVCTL2, &ctl2);
 +		if (rc)
 +			goto disable;
 +
 +		if (!(cap2 & PCI_EXP_DEVCAP2_ATOMIC_ROUTE) ||
 +		    (ctl2 & PCI_EXP_DEVCTL2_ATOMIC_EGRESS_BLOCK))
 +			goto disable;
 +		bridge = bridge->bus->parent->self;
  	}
 +
 +	rc = pcie_capability_read_word(bridge, PCI_EXP_FLAGS, &flags);
 +	if (rc || ((flags & PCI_EXP_FLAGS_VERS) < 2))
 +		goto disable;
 +
 +	rc = pcie_capability_read_dword(bridge, PCI_EXP_DEVCAP2, &cap2);
 +	if (rc || !(cap2 & PCI_EXP_DEVCAP2_ATOMIC_COMP64))
 +		goto disable;
 +
 +	/* Set atomic operations */
 +	pcie_capability_set_word(pdev, PCI_EXP_DEVCTL2,
 +				 PCI_EXP_DEVCTL2_ATOMIC_REQ);
 +	dev->atomic_cap = IB_ATOMIC_GLOB;
 +
 +	DP_DEBUG(dev, QEDR_MSG_INIT, "Atomic capability enabled\n");
 +
 +	return;
 +
 +disable:
 +	pcie_capability_clear_word(pdev, PCI_EXP_DEVCTL2,
 +				   PCI_EXP_DEVCTL2_ATOMIC_REQ);
 +	dev->atomic_cap = IB_ATOMIC_NONE;
 +
 +	DP_DEBUG(dev, QEDR_MSG_INIT, "Atomic capability disabled\n");
 +
  }
  
  static const struct qed_rdma_ops *qed_ops;
diff --cc drivers/infiniband/hw/usnic/usnic_ib_main.c
index bcca4bd599ef,73bd00f8d2c8..000000000000
--- a/drivers/infiniband/hw/usnic/usnic_ib_main.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_main.c
@@@ -433,7 -416,10 +433,14 @@@ static void *usnic_ib_device_add(struc
  	us_ibdev->ib_dev.get_dev_fw_str     = usnic_get_dev_fw_str;
  
  
++<<<<<<< HEAD
 +	if (ib_register_device(&us_ibdev->ib_dev, NULL))
++=======
+ 	us_ibdev->ib_dev.driver_id = RDMA_DRIVER_USNIC;
+ 	rdma_set_device_sysfs_group(&us_ibdev->ib_dev, &usnic_attr_group);
+ 
+ 	if (ib_register_device(&us_ibdev->ib_dev, "usnic_%d", NULL))
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  		goto err_fwd_dealloc;
  
  	usnic_fwd_set_mtu(us_ibdev->ufdev, us_ibdev->netdev->mtu);
diff --cc drivers/infiniband/hw/usnic/usnic_ib_sysfs.c
index 4210ca14014d,a7e4b2ccfaf8..000000000000
--- a/drivers/infiniband/hw/usnic/usnic_ib_sysfs.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_sysfs.c
@@@ -278,18 -276,6 +276,21 @@@ static struct kobj_type usnic_ib_qpn_ty
  
  int usnic_ib_sysfs_register_usdev(struct usnic_ib_dev *us_ibdev)
  {
++<<<<<<< HEAD
 +	int i;
 +	int err;
 +	for (i = 0; i < ARRAY_SIZE(usnic_class_attributes); ++i) {
 +		err = device_create_file(&us_ibdev->ib_dev.dev,
 +						usnic_class_attributes[i]);
 +		if (err) {
 +			usnic_err("Failed to create device file %d for %s eith err %d",
 +				i, us_ibdev->ib_dev.name, err);
 +			return -EINVAL;
 +		}
 +	}
 +
++=======
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  	/* create kernel object for looking at individual QPs */
  	kobject_get(&us_ibdev->ib_dev.dev.kobj);
  	us_ibdev->qpn_kobj = kobject_create_and_add("qpn",
diff --cc drivers/infiniband/sw/rxe/rxe_verbs.c
index 39cef3e024df,9c19f2027511..000000000000
--- a/drivers/infiniband/sw/rxe/rxe_verbs.c
+++ b/drivers/infiniband/sw/rxe/rxe_verbs.c
@@@ -1327,7 -1263,9 +1331,13 @@@ int rxe_register_device(struct rxe_dev 
  	}
  	rxe->tfm = tfm;
  
++<<<<<<< HEAD
 +	err = ib_register_device(dev, NULL);
++=======
+ 	rdma_set_device_sysfs_group(dev, &rxe_attr_group);
+ 	dev->driver_id = RDMA_DRIVER_RXE;
+ 	err = ib_register_device(dev, "rxe%d", NULL);
++>>>>>>> 508a523f6bc6 (RDMA/drivers: Use core provided API for registering device attributes)
  	if (err) {
  		pr_warn("%s failed with error %d\n", __func__, err);
  		goto err1;
* Unmerged path drivers/infiniband/hw/mlx5/ib_rep.c
* Unmerged path drivers/infiniband/hw/bnxt_re/main.c
* Unmerged path drivers/infiniband/hw/cxgb3/iwch_provider.c
* Unmerged path drivers/infiniband/hw/cxgb4/provider.c
diff --git a/drivers/infiniband/hw/hfi1/hfi.h b/drivers/infiniband/hw/hfi1/hfi.h
index 153d3a26bc7b..0fa33b1fd8e4 100644
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@ -1949,6 +1949,7 @@ static inline u32 get_rcvhdrtail(const struct hfi1_ctxtdata *rcd)
  */
 
 extern const char ib_hfi1_version[];
+extern const struct attribute_group ib_hfi1_attr_group;
 
 int hfi1_device_create(struct hfi1_devdata *dd);
 void hfi1_device_remove(struct hfi1_devdata *dd);
diff --git a/drivers/infiniband/hw/hfi1/sysfs.c b/drivers/infiniband/hw/hfi1/sysfs.c
index 25e867393463..2be513d4c9da 100644
--- a/drivers/infiniband/hw/hfi1/sysfs.c
+++ b/drivers/infiniband/hw/hfi1/sysfs.c
@@ -494,17 +494,18 @@ static struct kobj_type hfi1_vl2mtu_ktype = {
  * Start of per-unit (or driver, in some cases, but replicated
  * per unit) functions (these get a device *)
  */
-static ssize_t show_rev(struct device *device, struct device_attribute *attr,
-			char *buf)
+static ssize_t hw_rev_show(struct device *device, struct device_attribute *attr,
+			   char *buf)
 {
 	struct hfi1_ibdev *dev =
 		container_of(device, struct hfi1_ibdev, rdi.ibdev.dev);
 
 	return sprintf(buf, "%x\n", dd_from_dev(dev)->minrev);
 }
+static DEVICE_ATTR_RO(hw_rev);
 
-static ssize_t show_hfi(struct device *device, struct device_attribute *attr,
-			char *buf)
+static ssize_t board_id_show(struct device *device,
+			     struct device_attribute *attr, char *buf)
 {
 	struct hfi1_ibdev *dev =
 		container_of(device, struct hfi1_ibdev, rdi.ibdev.dev);
@@ -517,8 +518,9 @@ static ssize_t show_hfi(struct device *device, struct device_attribute *attr,
 		ret = scnprintf(buf, PAGE_SIZE, "%s\n", dd->boardname);
 	return ret;
 }
+static DEVICE_ATTR_RO(board_id);
 
-static ssize_t show_boardversion(struct device *device,
+static ssize_t boardversion_show(struct device *device,
 				 struct device_attribute *attr, char *buf)
 {
 	struct hfi1_ibdev *dev =
@@ -528,8 +530,9 @@ static ssize_t show_boardversion(struct device *device,
 	/* The string printed here is already newline-terminated. */
 	return scnprintf(buf, PAGE_SIZE, "%s", dd->boardversion);
 }
+static DEVICE_ATTR_RO(boardversion);
 
-static ssize_t show_nctxts(struct device *device,
+static ssize_t nctxts_show(struct device *device,
 			   struct device_attribute *attr, char *buf)
 {
 	struct hfi1_ibdev *dev =
@@ -546,8 +549,9 @@ static ssize_t show_nctxts(struct device *device,
 			 min(dd->num_user_contexts,
 			     (u32)dd->sc_sizes[SC_USER].count));
 }
+static DEVICE_ATTR_RO(nctxts);
 
-static ssize_t show_nfreectxts(struct device *device,
+static ssize_t nfreectxts_show(struct device *device,
 			       struct device_attribute *attr, char *buf)
 {
 	struct hfi1_ibdev *dev =
@@ -557,8 +561,9 @@ static ssize_t show_nfreectxts(struct device *device,
 	/* Return the number of free user ports (contexts) available. */
 	return scnprintf(buf, PAGE_SIZE, "%u\n", dd->freectxts);
 }
+static DEVICE_ATTR_RO(nfreectxts);
 
-static ssize_t show_serial(struct device *device,
+static ssize_t serial_show(struct device *device,
 			   struct device_attribute *attr, char *buf)
 {
 	struct hfi1_ibdev *dev =
@@ -567,8 +572,9 @@ static ssize_t show_serial(struct device *device,
 
 	return scnprintf(buf, PAGE_SIZE, "%s", dd->serial);
 }
+static DEVICE_ATTR_RO(serial);
 
-static ssize_t store_chip_reset(struct device *device,
+static ssize_t chip_reset_store(struct device *device,
 				struct device_attribute *attr, const char *buf,
 				size_t count)
 {
@@ -586,6 +592,7 @@ static ssize_t store_chip_reset(struct device *device,
 bail:
 	return ret < 0 ? ret : count;
 }
+static DEVICE_ATTR_WO(chip_reset);
 
 /*
  * Convert the reported temperature from an integer (reported in
@@ -598,7 +605,7 @@ bail:
 /*
  * Dump tempsense values, in decimal, to ease shell-scripts.
  */
-static ssize_t show_tempsense(struct device *device,
+static ssize_t tempsense_show(struct device *device,
 			      struct device_attribute *attr, char *buf)
 {
 	struct hfi1_ibdev *dev =
@@ -622,6 +629,7 @@ static ssize_t show_tempsense(struct device *device,
 	}
 	return ret;
 }
+static DEVICE_ATTR_RO(tempsense);
 
 /*
  * end of per-unit (or driver, in some cases, but replicated
@@ -629,24 +637,20 @@ static ssize_t show_tempsense(struct device *device,
  */
 
 /* start of per-unit file structures and support code */
-static DEVICE_ATTR(hw_rev, S_IRUGO, show_rev, NULL);
-static DEVICE_ATTR(board_id, S_IRUGO, show_hfi, NULL);
-static DEVICE_ATTR(nctxts, S_IRUGO, show_nctxts, NULL);
-static DEVICE_ATTR(nfreectxts, S_IRUGO, show_nfreectxts, NULL);
-static DEVICE_ATTR(serial, S_IRUGO, show_serial, NULL);
-static DEVICE_ATTR(boardversion, S_IRUGO, show_boardversion, NULL);
-static DEVICE_ATTR(tempsense, S_IRUGO, show_tempsense, NULL);
-static DEVICE_ATTR(chip_reset, S_IWUSR, NULL, store_chip_reset);
-
-static struct device_attribute *hfi1_attributes[] = {
-	&dev_attr_hw_rev,
-	&dev_attr_board_id,
-	&dev_attr_nctxts,
-	&dev_attr_nfreectxts,
-	&dev_attr_serial,
-	&dev_attr_boardversion,
-	&dev_attr_tempsense,
-	&dev_attr_chip_reset,
+static struct attribute *hfi1_attributes[] = {
+	&dev_attr_hw_rev.attr,
+	&dev_attr_board_id.attr,
+	&dev_attr_nctxts.attr,
+	&dev_attr_nfreectxts.attr,
+	&dev_attr_serial.attr,
+	&dev_attr_boardversion.attr,
+	&dev_attr_tempsense.attr,
+	&dev_attr_chip_reset.attr,
+	NULL,
+};
+
+const struct attribute_group ib_hfi1_attr_group = {
+	.attrs = hfi1_attributes,
 };
 
 int hfi1_create_port_files(struct ib_device *ibdev, u8 port_num,
@@ -832,12 +836,6 @@ int hfi1_verbs_register_sysfs(struct hfi1_devdata *dd)
 	struct device *class_dev = &dev->dev;
 	int i, j, ret;
 
-	for (i = 0; i < ARRAY_SIZE(hfi1_attributes); ++i) {
-		ret = device_create_file(&dev->dev, hfi1_attributes[i]);
-		if (ret)
-			goto bail;
-	}
-
 	for (i = 0; i < dd->num_sdma; i++) {
 		ret = kobject_init_and_add(&dd->per_sdma[i].kobj,
 					   &sde_ktype, &class_dev->kobj,
@@ -855,9 +853,6 @@ int hfi1_verbs_register_sysfs(struct hfi1_devdata *dd)
 
 	return 0;
 bail:
-	for (i = 0; i < ARRAY_SIZE(hfi1_attributes); ++i)
-		device_remove_file(&dev->dev, hfi1_attributes[i]);
-
 	for (i = 0; i < dd->num_sdma; i++)
 		kobject_del(&dd->per_sdma[i].kobj);
 
* Unmerged path drivers/infiniband/hw/hfi1/verbs.c
* Unmerged path drivers/infiniband/hw/i40iw/i40iw_verbs.c
* Unmerged path drivers/infiniband/hw/mlx4/main.c
* Unmerged path drivers/infiniband/hw/mlx5/ib_rep.c
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path drivers/infiniband/hw/mlx5/mlx5_ib.h
* Unmerged path drivers/infiniband/hw/mthca/mthca_provider.c
* Unmerged path drivers/infiniband/hw/nes/nes_verbs.c
* Unmerged path drivers/infiniband/hw/ocrdma/ocrdma_main.c
* Unmerged path drivers/infiniband/hw/qedr/main.c
diff --git a/drivers/infiniband/hw/qib/qib.h b/drivers/infiniband/hw/qib/qib.h
index 96735dce388c..e57eb1242159 100644
--- a/drivers/infiniband/hw/qib/qib.h
+++ b/drivers/infiniband/hw/qib/qib.h
@@ -1396,13 +1396,13 @@ static inline u32 qib_get_hdrqtail(const struct qib_ctxtdata *rcd)
  */
 
 extern const char ib_qib_version[];
+extern const struct attribute_group qib_attr_group;
 
 int qib_device_create(struct qib_devdata *);
 void qib_device_remove(struct qib_devdata *);
 
 int qib_create_port_files(struct ib_device *ibdev, u8 port_num,
 			  struct kobject *kobj);
-int qib_verbs_register_sysfs(struct qib_devdata *);
 void qib_verbs_unregister_sysfs(struct qib_devdata *);
 /* Hook for sysfs read of QSFP */
 extern int qib_qsfp_dump(struct qib_pportdata *ppd, char *buf, int len);
diff --git a/drivers/infiniband/hw/qib/qib_sysfs.c b/drivers/infiniband/hw/qib/qib_sysfs.c
index ca2638d8f35e..1cf4ca3f23e3 100644
--- a/drivers/infiniband/hw/qib/qib_sysfs.c
+++ b/drivers/infiniband/hw/qib/qib_sysfs.c
@@ -551,17 +551,18 @@ static struct kobj_type qib_diagc_ktype = {
  * Start of per-unit (or driver, in some cases, but replicated
  * per unit) functions (these get a device *)
  */
-static ssize_t show_rev(struct device *device, struct device_attribute *attr,
-			char *buf)
+static ssize_t hw_rev_show(struct device *device, struct device_attribute *attr,
+			   char *buf)
 {
 	struct qib_ibdev *dev =
 		container_of(device, struct qib_ibdev, rdi.ibdev.dev);
 
 	return sprintf(buf, "%x\n", dd_from_dev(dev)->minrev);
 }
+static DEVICE_ATTR_RO(hw_rev);
 
-static ssize_t show_hca(struct device *device, struct device_attribute *attr,
-			char *buf)
+static ssize_t hca_type_show(struct device *device,
+			     struct device_attribute *attr, char *buf)
 {
 	struct qib_ibdev *dev =
 		container_of(device, struct qib_ibdev, rdi.ibdev.dev);
@@ -574,15 +575,18 @@ static ssize_t show_hca(struct device *device, struct device_attribute *attr,
 		ret = scnprintf(buf, PAGE_SIZE, "%s\n", dd->boardname);
 	return ret;
 }
+static DEVICE_ATTR_RO(hca_type);
+static DEVICE_ATTR(board_id, 0444, hca_type_show, NULL);
 
-static ssize_t show_version(struct device *device,
+static ssize_t version_show(struct device *device,
 			    struct device_attribute *attr, char *buf)
 {
 	/* The string printed here is already newline-terminated. */
 	return scnprintf(buf, PAGE_SIZE, "%s", (char *)ib_qib_version);
 }
+static DEVICE_ATTR_RO(version);
 
-static ssize_t show_boardversion(struct device *device,
+static ssize_t boardversion_show(struct device *device,
 				 struct device_attribute *attr, char *buf)
 {
 	struct qib_ibdev *dev =
@@ -592,9 +596,9 @@ static ssize_t show_boardversion(struct device *device,
 	/* The string printed here is already newline-terminated. */
 	return scnprintf(buf, PAGE_SIZE, "%s", dd->boardversion);
 }
+static DEVICE_ATTR_RO(boardversion);
 
-
-static ssize_t show_localbus_info(struct device *device,
+static ssize_t localbus_info_show(struct device *device,
 				  struct device_attribute *attr, char *buf)
 {
 	struct qib_ibdev *dev =
@@ -604,9 +608,9 @@ static ssize_t show_localbus_info(struct device *device,
 	/* The string printed here is already newline-terminated. */
 	return scnprintf(buf, PAGE_SIZE, "%s", dd->lbus_info);
 }
+static DEVICE_ATTR_RO(localbus_info);
 
-
-static ssize_t show_nctxts(struct device *device,
+static ssize_t nctxts_show(struct device *device,
 			   struct device_attribute *attr, char *buf)
 {
 	struct qib_ibdev *dev =
@@ -620,9 +624,10 @@ static ssize_t show_nctxts(struct device *device,
 			(dd->first_user_ctxt > dd->cfgctxts) ? 0 :
 			(dd->cfgctxts - dd->first_user_ctxt));
 }
+static DEVICE_ATTR_RO(nctxts);
 
-static ssize_t show_nfreectxts(struct device *device,
-			   struct device_attribute *attr, char *buf)
+static ssize_t nfreectxts_show(struct device *device,
+			       struct device_attribute *attr, char *buf)
 {
 	struct qib_ibdev *dev =
 		container_of(device, struct qib_ibdev, rdi.ibdev.dev);
@@ -631,8 +636,9 @@ static ssize_t show_nfreectxts(struct device *device,
 	/* Return the number of free user ports (contexts) available. */
 	return scnprintf(buf, PAGE_SIZE, "%u\n", dd->freectxts);
 }
+static DEVICE_ATTR_RO(nfreectxts);
 
-static ssize_t show_serial(struct device *device,
+static ssize_t serial_show(struct device *device,
 			   struct device_attribute *attr, char *buf)
 {
 	struct qib_ibdev *dev =
@@ -644,8 +650,9 @@ static ssize_t show_serial(struct device *device,
 	strcat(buf, "\n");
 	return strlen(buf);
 }
+static DEVICE_ATTR_RO(serial);
 
-static ssize_t store_chip_reset(struct device *device,
+static ssize_t chip_reset_store(struct device *device,
 				struct device_attribute *attr, const char *buf,
 				size_t count)
 {
@@ -663,11 +670,12 @@ static ssize_t store_chip_reset(struct device *device,
 bail:
 	return ret < 0 ? ret : count;
 }
+static DEVICE_ATTR_WO(chip_reset);
 
 /*
  * Dump tempsense regs. in decimal, to ease shell-scripts.
  */
-static ssize_t show_tempsense(struct device *device,
+static ssize_t tempsense_show(struct device *device,
 			      struct device_attribute *attr, char *buf)
 {
 	struct qib_ibdev *dev =
@@ -695,6 +703,7 @@ static ssize_t show_tempsense(struct device *device,
 				*(signed char *)(regvals + 7));
 	return ret;
 }
+static DEVICE_ATTR_RO(tempsense);
 
 /*
  * end of per-unit (or driver, in some cases, but replicated
@@ -702,30 +711,23 @@ static ssize_t show_tempsense(struct device *device,
  */
 
 /* start of per-unit file structures and support code */
-static DEVICE_ATTR(hw_rev, S_IRUGO, show_rev, NULL);
-static DEVICE_ATTR(hca_type, S_IRUGO, show_hca, NULL);
-static DEVICE_ATTR(board_id, S_IRUGO, show_hca, NULL);
-static DEVICE_ATTR(version, S_IRUGO, show_version, NULL);
-static DEVICE_ATTR(nctxts, S_IRUGO, show_nctxts, NULL);
-static DEVICE_ATTR(nfreectxts, S_IRUGO, show_nfreectxts, NULL);
-static DEVICE_ATTR(serial, S_IRUGO, show_serial, NULL);
-static DEVICE_ATTR(boardversion, S_IRUGO, show_boardversion, NULL);
-static DEVICE_ATTR(tempsense, S_IRUGO, show_tempsense, NULL);
-static DEVICE_ATTR(localbus_info, S_IRUGO, show_localbus_info, NULL);
-static DEVICE_ATTR(chip_reset, S_IWUSR, NULL, store_chip_reset);
-
-static struct device_attribute *qib_attributes[] = {
-	&dev_attr_hw_rev,
-	&dev_attr_hca_type,
-	&dev_attr_board_id,
-	&dev_attr_version,
-	&dev_attr_nctxts,
-	&dev_attr_nfreectxts,
-	&dev_attr_serial,
-	&dev_attr_boardversion,
-	&dev_attr_tempsense,
-	&dev_attr_localbus_info,
-	&dev_attr_chip_reset,
+static struct attribute *qib_attributes[] = {
+	&dev_attr_hw_rev.attr,
+	&dev_attr_hca_type.attr,
+	&dev_attr_board_id.attr,
+	&dev_attr_version.attr,
+	&dev_attr_nctxts.attr,
+	&dev_attr_nfreectxts.attr,
+	&dev_attr_serial.attr,
+	&dev_attr_boardversion.attr,
+	&dev_attr_tempsense.attr,
+	&dev_attr_localbus_info.attr,
+	&dev_attr_chip_reset.attr,
+	NULL,
+};
+
+const struct attribute_group qib_attr_group = {
+	.attrs = qib_attributes,
 };
 
 int qib_create_port_files(struct ib_device *ibdev, u8 port_num,
@@ -826,27 +828,6 @@ bail:
 	return ret;
 }
 
-/*
- * Register and create our files in /sys/class/infiniband.
- */
-int qib_verbs_register_sysfs(struct qib_devdata *dd)
-{
-	struct ib_device *dev = &dd->verbs_dev.rdi.ibdev;
-	int i, ret;
-
-	for (i = 0; i < ARRAY_SIZE(qib_attributes); ++i) {
-		ret = device_create_file(&dev->dev, qib_attributes[i]);
-		if (ret)
-			goto bail;
-	}
-
-	return 0;
-bail:
-	for (i = 0; i < ARRAY_SIZE(qib_attributes); ++i)
-		device_remove_file(&dev->dev, qib_attributes[i]);
-	return ret;
-}
-
 /*
  * Unregister and remove our files in /sys/class/infiniband.
  */
diff --git a/drivers/infiniband/hw/qib/qib_verbs.c b/drivers/infiniband/hw/qib/qib_verbs.c
index 021a776bffe6..d51d7df519e9 100644
--- a/drivers/infiniband/hw/qib/qib_verbs.c
+++ b/drivers/infiniband/hw/qib/qib_verbs.c
@@ -1646,19 +1646,14 @@ int qib_register_ib_device(struct qib_devdata *dd)
 			      i,
 			      dd->rcd[ctxt]->pkeys);
 	}
+	rdma_set_device_sysfs_group(&dd->verbs_dev.rdi.ibdev, &qib_attr_group);
 
 	ret = rvt_register_device(&dd->verbs_dev.rdi);
 	if (ret)
 		goto err_tx;
 
-	ret = qib_verbs_register_sysfs(dd);
-	if (ret)
-		goto err_class;
-
 	return ret;
 
-err_class:
-	rvt_unregister_device(&dd->verbs_dev.rdi);
 err_tx:
 	while (!list_empty(&dev->txreq_free)) {
 		struct list_head *l = dev->txreq_free.next;
* Unmerged path drivers/infiniband/hw/usnic/usnic_ib_main.c
* Unmerged path drivers/infiniband/hw/usnic/usnic_ib_sysfs.c
diff --git a/drivers/infiniband/hw/usnic/usnic_ib_sysfs.h b/drivers/infiniband/hw/usnic/usnic_ib_sysfs.h
index 3d98e16cfeaf..b1f064cec850 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_sysfs.h
+++ b/drivers/infiniband/hw/usnic/usnic_ib_sysfs.h
@@ -41,4 +41,6 @@ void usnic_ib_sysfs_unregister_usdev(struct usnic_ib_dev *us_ibdev);
 void usnic_ib_sysfs_qpn_add(struct usnic_ib_qp_grp *qp_grp);
 void usnic_ib_sysfs_qpn_remove(struct usnic_ib_qp_grp *qp_grp);
 
+extern const struct attribute_group usnic_attr_group;
+
 #endif /* !USNIC_IB_SYSFS_H_ */
diff --git a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_main.c b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_main.c
index f493046158a6..382854ec5958 100644
--- a/drivers/infiniband/hw/vmw_pvrdma/pvrdma_main.c
+++ b/drivers/infiniband/hw/vmw_pvrdma/pvrdma_main.c
@@ -74,32 +74,36 @@ static int pvrdma_del_gid(struct ib_device *ibdev,
 			  void **context);
 
 
-static ssize_t show_hca(struct device *device, struct device_attribute *attr,
-			char *buf)
+static ssize_t hca_type_show(struct device *device,
+			     struct device_attribute *attr, char *buf)
 {
 	return sprintf(buf, "VMW_PVRDMA-%s\n", DRV_VERSION);
 }
+static DEVICE_ATTR_RO(hca_type);
 
-static ssize_t show_rev(struct device *device, struct device_attribute *attr,
-			char *buf)
+static ssize_t hw_rev_show(struct device *device,
+			   struct device_attribute *attr, char *buf)
 {
 	return sprintf(buf, "%d\n", PVRDMA_REV_ID);
 }
+static DEVICE_ATTR_RO(hw_rev);
 
-static ssize_t show_board(struct device *device, struct device_attribute *attr,
-			  char *buf)
+static ssize_t board_id_show(struct device *device,
+			     struct device_attribute *attr, char *buf)
 {
 	return sprintf(buf, "%d\n", PVRDMA_BOARD_ID);
 }
+static DEVICE_ATTR_RO(board_id);
 
-static DEVICE_ATTR(hw_rev,   S_IRUGO, show_rev,	   NULL);
-static DEVICE_ATTR(hca_type, S_IRUGO, show_hca,	   NULL);
-static DEVICE_ATTR(board_id, S_IRUGO, show_board,  NULL);
+static struct attribute *pvrdma_class_attributes[] = {
+	&dev_attr_hw_rev.attr,
+	&dev_attr_hca_type.attr,
+	&dev_attr_board_id.attr,
+	NULL,
+};
 
-static struct device_attribute *pvrdma_class_attributes[] = {
-	&dev_attr_hw_rev,
-	&dev_attr_hca_type,
-	&dev_attr_board_id
+static const struct attribute_group pvrdma_attr_group = {
+	.attrs = pvrdma_class_attributes,
 };
 
 static void pvrdma_get_fw_ver_str(struct ib_device *device, char *str)
@@ -169,7 +173,6 @@ static struct net_device *pvrdma_get_netdev(struct ib_device *ibdev,
 static int pvrdma_register_device(struct pvrdma_dev *dev)
 {
 	int ret = -1;
-	int i = 0;
 
 	strlcpy(dev->ib_dev.name, "vmw_pvrdma%d", IB_DEVICE_NAME_MAX);
 	dev->ib_dev.node_guid = dev->dsr->caps.node_guid;
@@ -277,24 +280,16 @@ static int pvrdma_register_device(struct pvrdma_dev *dev)
 			goto err_qp_free;
 	}
 	spin_lock_init(&dev->srq_tbl_lock);
+	rdma_set_device_sysfs_group(&dev->ib_dev, &pvrdma_attr_group);
 
 	ret = ib_register_device(&dev->ib_dev, NULL);
 	if (ret)
 		goto err_srq_free;
 
-	for (i = 0; i < ARRAY_SIZE(pvrdma_class_attributes); ++i) {
-		ret = device_create_file(&dev->ib_dev.dev,
-					 pvrdma_class_attributes[i]);
-		if (ret)
-			goto err_class;
-	}
-
 	dev->ib_active = true;
 
 	return 0;
 
-err_class:
-	ib_unregister_device(&dev->ib_dev);
 err_srq_free:
 	kfree(dev->srq_tbl);
 err_qp_free:
* Unmerged path drivers/infiniband/sw/rxe/rxe_verbs.c
