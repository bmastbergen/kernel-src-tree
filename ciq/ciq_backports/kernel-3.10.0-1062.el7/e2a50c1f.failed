userfaultfd: shmem: add i_size checks

jira LE-1907
cve CVE-2018-18397
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Andrea Arcangeli <aarcange@redhat.com>
commit e2a50c1f64145a04959df2442305d57307e5395a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e2a50c1f.failed

With MAP_SHARED: recheck the i_size after taking the PT lock, to
serialize against truncate with the PT lock.  Delete the page from the
pagecache if the i_size_read check fails.

With MAP_PRIVATE: check the i_size after the PT lock before mapping
anonymous memory or zeropages into the MAP_PRIVATE shmem mapping.

A mostly irrelevant cleanup: like we do the delete_from_page_cache()
pagecache removal after dropping the PT lock, the PT lock is a spinlock
so drop it before the sleepable page lock.

Link: http://lkml.kernel.org/r/20181126173452.26955-5-aarcange@redhat.com
Fixes: 4c27fe4c4c84 ("userfaultfd: shmem: add shmem_mcopy_atomic_pte for userfaultfd support")
	Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
	Reviewed-by: Mike Rapoport <rppt@linux.ibm.com>
	Reviewed-by: Hugh Dickins <hughd@google.com>
	Reported-by: Jann Horn <jannh@google.com>
	Cc: <stable@vger.kernel.org>
	Cc: "Dr. David Alan Gilbert" <dgilbert@redhat.com>
	Cc: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: Peter Xu <peterx@redhat.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit e2a50c1f64145a04959df2442305d57307e5395a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/shmem.c
diff --cc mm/shmem.c
index 5d44b78288a6,99d5867daadb..000000000000
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@@ -1612,8 -2254,13 +1613,18 @@@ static int shmem_mfill_atomic_pte(struc
  	__SetPageSwapBacked(page);
  	__SetPageUptodate(page);
  
++<<<<<<< HEAD
 +	ret = mem_cgroup_cache_charge(page, dst_mm,
 +				      gfp & GFP_RECLAIM_MASK);
++=======
+ 	ret = -EFAULT;
+ 	offset = linear_page_index(dst_vma, dst_addr);
+ 	max_off = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);
+ 	if (unlikely(offset >= max_off))
+ 		goto out_release;
+ 
+ 	ret = mem_cgroup_try_charge_delay(page, dst_mm, gfp, &memcg, false);
++>>>>>>> e2a50c1f6414 (userfaultfd: shmem: add i_size checks)
  	if (ret)
  		goto out_release;
  
@@@ -1655,8 -2307,9 +1672,9 @@@ out
  	return ret;
  out_release_uncharge_unlock:
  	pte_unmap_unlock(dst_pte, ptl);
+ 	delete_from_page_cache(page);
  out_release_uncharge:
 -	mem_cgroup_cancel_charge(page, memcg, false);
 +	mem_cgroup_uncharge_cache_page(page);
  out_release:
  	unlock_page(page);
  	put_page(page);
* Unmerged path mm/shmem.c
diff --git a/mm/userfaultfd.c b/mm/userfaultfd.c
index 1e454b75a72f..b3eb6d40ac62 100644
--- a/mm/userfaultfd.c
+++ b/mm/userfaultfd.c
@@ -32,6 +32,8 @@ static int mcopy_atomic_pte(struct mm_struct *dst_mm,
 	void *page_kaddr;
 	int ret;
 	struct page *page;
+	pgoff_t offset, max_off;
+	struct inode *inode;
 
 	if (!*pagep) {
 		ret = -ENOMEM;
@@ -72,8 +74,17 @@ static int mcopy_atomic_pte(struct mm_struct *dst_mm,
 	if (dst_vma->vm_flags & VM_WRITE)
 		_dst_pte = pte_mkwrite(pte_mkdirty(_dst_pte));
 
-	ret = -EEXIST;
 	dst_pte = pte_offset_map_lock(dst_mm, dst_pmd, dst_addr, &ptl);
+	if (dst_vma->vm_file) {
+		/* the shmem MAP_PRIVATE case requires checking the i_size */
+		inode = dst_vma->vm_file->f_inode;
+		offset = linear_page_index(dst_vma, dst_addr);
+		max_off = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);
+		ret = -EFAULT;
+		if (unlikely(offset >= max_off))
+			goto out_release_uncharge_unlock;
+	}
+	ret = -EEXIST;
 	if (!pte_none(*dst_pte))
 		goto out_release_uncharge_unlock;
 
@@ -105,11 +116,22 @@ static int mfill_zeropage_pte(struct mm_struct *dst_mm,
 	pte_t _dst_pte, *dst_pte;
 	spinlock_t *ptl;
 	int ret;
+	pgoff_t offset, max_off;
+	struct inode *inode;
 
 	_dst_pte = pte_mkspecial(pfn_pte(my_zero_pfn(dst_addr),
 					 dst_vma->vm_page_prot));
-	ret = -EEXIST;
 	dst_pte = pte_offset_map_lock(dst_mm, dst_pmd, dst_addr, &ptl);
+	if (dst_vma->vm_file) {
+		/* the shmem MAP_PRIVATE case requires checking the i_size */
+		inode = dst_vma->vm_file->f_inode;
+		offset = linear_page_index(dst_vma, dst_addr);
+		max_off = DIV_ROUND_UP(i_size_read(inode), PAGE_SIZE);
+		ret = -EFAULT;
+		if (unlikely(offset >= max_off))
+			goto out_unlock;
+	}
+	ret = -EEXIST;
 	if (!pte_none(*dst_pte))
 		goto out_unlock;
 	set_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);
