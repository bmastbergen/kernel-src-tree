sched/debug: Intruduce task_state_to_char() helper function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Xie XiuQi <xiexiuqi@huawei.com>
commit 20435d84e5f2041c64c792399ab6f2948a2c2252
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/20435d84.failed

Now that we have more than one place to get the task state,
intruduce the task_state_to_char() helper function to save some code.

No functionality changed.

	Signed-off-by: Xie XiuQi <xiexiuqi@huawei.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: <cj.chengjian@huawei.com>
	Cc: <huawei.libin@huawei.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/1502095463-160172-3-git-send-email-xiexiuqi@huawei.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 20435d84e5f2041c64c792399ab6f2948a2c2252)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/core.c
#	kernel/sched/debug.c
diff --cc kernel/sched/core.c
index 4685f09c1be7,f9f9948e2470..000000000000
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@@ -5687,22 -5107,14 +5685,32 @@@ void sched_show_task(struct task_struc
  {
  	unsigned long free = 0;
  	int ppid;
++<<<<<<< HEAD
 +	unsigned state;
 +
 +	state = p->state ? __ffs(p->state) + 1 : 0;
 +	printk(KERN_INFO "%-15.15s %c", p->comm,
 +		state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?');
 +#if BITS_PER_LONG == 32
 +	if (state == TASK_RUNNING)
 +		printk(KERN_CONT " running  ");
 +	else
 +		printk(KERN_CONT " %08lx ", thread_saved_pc(p));
 +#else
 +	if (state == TASK_RUNNING)
++=======
+ 
+ 	if (!try_get_task_stack(p))
+ 		return;
+ 
+ 	printk(KERN_INFO "%-15.15s %c", p->comm, task_state_to_char(p));
+ 
+ 	if (p->state == TASK_RUNNING)
++>>>>>>> 20435d84e5f2 (sched/debug: Intruduce task_state_to_char() helper function)
  		printk(KERN_CONT "  running task    ");
 +	else
 +		printk(KERN_CONT " %016lx ", thread_saved_pc(p));
 +#endif
  #ifdef CONFIG_DEBUG_STACK_USAGE
  	free = stack_not_used(p);
  #endif
diff --cc kernel/sched/debug.c
index 9179f4862aae,cfd84f79e075..000000000000
--- a/kernel/sched/debug.c
+++ b/kernel/sched/debug.c
@@@ -122,12 -427,12 +122,18 @@@ static voi
  print_task(struct seq_file *m, struct rq *rq, struct task_struct *p)
  {
  	if (rq->curr == p)
++<<<<<<< HEAD
 +		SEQ_printf(m, "R");
 +	else
 +		SEQ_printf(m, " ");
++=======
+ 		SEQ_printf(m, ">R");
+ 	else
+ 		SEQ_printf(m, " %c", task_state_to_char(p));
++>>>>>>> 20435d84e5f2 (sched/debug: Intruduce task_state_to_char() helper function)
  
  	SEQ_printf(m, "%15s %5d %9Ld.%06ld %9Ld %5d ",
 -		p->comm, task_pid_nr(p),
 +		p->comm, p->pid,
  		SPLIT_NS(p->se.vruntime),
  		(long long)(p->nvcsw + p->nivcsw),
  		p->prio);
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 83cd9508a135..c4809e4d5b0f 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1995,6 +1995,19 @@ static inline pid_t task_pgrp_nr(struct task_struct *tsk)
 	return task_pgrp_nr_ns(tsk, &init_pid_ns);
 }
 
+static inline char task_state_to_char(struct task_struct *task)
+{
+	const char stat_nam[] = TASK_STATE_TO_CHAR_STR;
+	unsigned long state = task->state;
+
+	state = state ? __ffs(state) + 1 : 0;
+
+	/* Make sure the string lines up properly with the number of task states: */
+	BUILD_BUG_ON(sizeof(TASK_STATE_TO_CHAR_STR)-1 != ilog2(TASK_STATE_MAX)+1);
+
+	return state < sizeof(stat_nam) - 1 ? stat_nam[state] : '?';
+}
+
 /**
  * pid_alive - check that a task structure is not stale
  * @p: Task structure to be checked.
* Unmerged path kernel/sched/core.c
* Unmerged path kernel/sched/debug.c
