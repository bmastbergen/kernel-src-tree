xfs: don't create overlapping extents in xfs_bmap_add_extent_delay_real

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 1bfd7618cbf2de630c845f60f5370671c2cd1c5d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/1bfd7618.failed

Two cases in xfs_bmap_add_extent_delay_real currently insert a new
extent before updating the existing one that is being split.  While
this works fine with a simple extent list, a more complex tree can't
easily cope with overlapping extent.  Reshuffle the code a bit to update
the slot of the existing delalloc extent to the new real extent before
inserting the shortened delalloc extent before or after it.  This
avoids the overlapping extents while still allowing to update the
br_startblock field of the delalloc extent with the updated indirect
block reservation.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 1bfd7618cbf2de630c845f60f5370671c2cd1c5d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 905742f2f1f9,db369653eb50..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -1827,12 -1791,8 +1827,17 @@@ xfs_bmap_add_extent_delay_real
  		 * Filling in the first part of a previous delayed allocation.
  		 * The left neighbor is not contiguous.
  		 */
++<<<<<<< HEAD
 +		trace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);
 +		xfs_bmbt_set_startoff(ep, new_endoff);
 +		temp = PREV.br_blockcount - new->br_blockcount;
 +		xfs_bmbt_set_blockcount(ep, temp);
 +		xfs_iext_insert(bma->ip, bma->idx, 1, new, state);
 +		bma->ip->i_d.di_nextents++;
++=======
+ 		xfs_iext_update_extent(bma->ip, state, bma->idx, new);
+ 		(*nextents)++;
++>>>>>>> 1bfd7618cbf2 (xfs: don't create overlapping extents in xfs_bmap_add_extent_delay_real)
  		if (bma->cur == NULL)
  			rval = XFS_ILOG_CORE | XFS_ILOG_DEXT;
  		else {
@@@ -1861,9 -1818,13 +1866,17 @@@
  		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),
  			startblockval(PREV.br_startblock) -
  			(bma->cur ? bma->cur->bc_private.b.allocated : 0));
++<<<<<<< HEAD
 +		ep = xfs_iext_get_ext(ifp, bma->idx + 1);
 +		xfs_bmbt_set_startblock(ep, nullstartblock(da_new));
 +		trace_xfs_bmap_post_update(bma->ip, bma->idx + 1, state, _THIS_IP_);
++=======
+ 
+ 		PREV.br_startoff = new_endoff;
+ 		PREV.br_blockcount = temp;
+ 		PREV.br_startblock = nullstartblock(da_new);
+ 		xfs_iext_insert(bma->ip, bma->idx + 1, 1, &PREV, state);
++>>>>>>> 1bfd7618cbf2 (xfs: don't create overlapping extents in xfs_bmap_add_extent_delay_real)
  		break;
  
  	case BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:
@@@ -1912,11 -1867,8 +1925,16 @@@
  		 * Filling in the last part of a previous delayed allocation.
  		 * The right neighbor is not contiguous.
  		 */
++<<<<<<< HEAD
 +		temp = PREV.br_blockcount - new->br_blockcount;
 +		trace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);
 +		xfs_bmbt_set_blockcount(ep, temp);
 +		xfs_iext_insert(bma->ip, bma->idx + 1, 1, new, state);
 +		bma->ip->i_d.di_nextents++;
++=======
+ 		xfs_iext_update_extent(bma->ip, state, bma->idx, new);
+ 		(*nextents)++;
++>>>>>>> 1bfd7618cbf2 (xfs: don't create overlapping extents in xfs_bmap_add_extent_delay_real)
  		if (bma->cur == NULL)
  			rval = XFS_ILOG_CORE | XFS_ILOG_DEXT;
  		else {
@@@ -1945,9 -1894,12 +1963,16 @@@
  		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),
  			startblockval(PREV.br_startblock) -
  			(bma->cur ? bma->cur->bc_private.b.allocated : 0));
++<<<<<<< HEAD
 +		ep = xfs_iext_get_ext(ifp, bma->idx);
 +		xfs_bmbt_set_startblock(ep, nullstartblock(da_new));
 +		trace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);
++=======
+ 
+ 		PREV.br_startblock = nullstartblock(da_new);
+ 		PREV.br_blockcount = temp;
+ 		xfs_iext_insert(bma->ip, bma->idx, 1, &PREV, state);
++>>>>>>> 1bfd7618cbf2 (xfs: don't create overlapping extents in xfs_bmap_add_extent_delay_real)
  
  		bma->idx++;
  		break;
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
