xhci: Add quirk to zero 64bit registers on Renesas PCIe controllers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Marc Zyngier <marc.zyngier@arm.com>
commit 12de0a35c996c3a75d050bff748815db3432849c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/12de0a35.failed

Some Renesas controllers get into a weird state if they are reset while
programmed with 64bit addresses (they will preserve the top half of the
address in internal, non visible registers).

You end up with half the address coming from the kernel, and the other
half coming from the firmware.

Also, changing the programming leads to extra accesses even if the
controller is supposed to be halted. The controller ends up with a fatal
fault, and is then ripe for being properly reset. On the flip side,
this is completely unsafe if the defvice isn't behind an IOMMU, so
we have to make sure that this is the case. Can you say "broken"?

This is an alternative method to the one introduced in 8466489ef5ba
("xhci: Reset Renesas uPD72020x USB controller for 32-bit DMA issue"),
which will subsequently be removed.

	Tested-by: Domenico Andreoli <domenico.andreoli@linux.com>
	Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
	Tested-by: Faiz Abbas <faiz_abbas@ti.com>
	Tested-by: Domenico Andreoli <domenico.andreoli@linux.com>
	Acked-by: Mathias Nyman <mathias.nyman@linux.intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 12de0a35c996c3a75d050bff748815db3432849c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/xhci.h
diff --cc drivers/usb/host/xhci.h
index 92ac662b64a2,939e2f86b595..000000000000
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@@ -1812,35 -1812,36 +1812,46 @@@ struct xhci_hcd 
   * commands, reset device commands, disable slot commands, and address device
   * commands.
   */
 -#define XHCI_EP_LIMIT_QUIRK	BIT_ULL(5)
 -#define XHCI_BROKEN_MSI		BIT_ULL(6)
 -#define XHCI_RESET_ON_RESUME	BIT_ULL(7)
 -#define	XHCI_SW_BW_CHECKING	BIT_ULL(8)
 -#define XHCI_AMD_0x96_HOST	BIT_ULL(9)
 -#define XHCI_TRUST_TX_LENGTH	BIT_ULL(10)
 -#define XHCI_LPM_SUPPORT	BIT_ULL(11)
 -#define XHCI_INTEL_HOST		BIT_ULL(12)
 -#define XHCI_SPURIOUS_REBOOT	BIT_ULL(13)
 -#define XHCI_COMP_MODE_QUIRK	BIT_ULL(14)
 -#define XHCI_AVOID_BEI		BIT_ULL(15)
 -#define XHCI_PLAT		BIT_ULL(16)
 -#define XHCI_SLOW_SUSPEND	BIT_ULL(17)
 -#define XHCI_SPURIOUS_WAKEUP	BIT_ULL(18)
 +#define XHCI_EP_LIMIT_QUIRK	(1 << 5)
 +#define XHCI_BROKEN_MSI		(1 << 6)
 +#define XHCI_RESET_ON_RESUME	(1 << 7)
 +#define	XHCI_SW_BW_CHECKING	(1 << 8)
 +#define XHCI_AMD_0x96_HOST	(1 << 9)
 +#define XHCI_TRUST_TX_LENGTH	(1 << 10)
 +#define XHCI_LPM_SUPPORT	(1 << 11)
 +#define XHCI_INTEL_HOST		(1 << 12)
 +#define XHCI_SPURIOUS_REBOOT	(1 << 13)
 +#define XHCI_COMP_MODE_QUIRK	(1 << 14)
 +#define XHCI_AVOID_BEI		(1 << 15)
 +#define XHCI_PLAT		(1 << 16)
 +#define XHCI_SLOW_SUSPEND	(1 << 17)
 +#define XHCI_SPURIOUS_WAKEUP	(1 << 18)
  /* For controllers with a broken beyond repair streams implementation */
 -#define XHCI_BROKEN_STREAMS	BIT_ULL(19)
 -#define XHCI_PME_STUCK_QUIRK	BIT_ULL(20)
 -#define XHCI_MTK_HOST		BIT_ULL(21)
 -#define XHCI_SSIC_PORT_UNUSED	BIT_ULL(22)
 -#define XHCI_NO_64BIT_SUPPORT	BIT_ULL(23)
 -#define XHCI_MISSING_CAS	BIT_ULL(24)
 +#define XHCI_BROKEN_STREAMS	(1 << 19)
 +#define XHCI_PME_STUCK_QUIRK	(1 << 20)
 +#define XHCI_MTK_HOST		(1 << 21)
 +#define XHCI_SSIC_PORT_UNUSED	(1 << 22)
 +#define XHCI_NO_64BIT_SUPPORT	(1 << 23)
 +#define XHCI_MISSING_CAS	(1 << 24)
  /* For controller with a broken Port Disable implementation */
++<<<<<<< HEAD
 +#define XHCI_BROKEN_PORT_PED	(1 << 25)
 +#define XHCI_LIMIT_ENDPOINT_INTERVAL_7	(1 << 26)
 +/* Reserved. It was XHCI_U2_DISABLE_WAKE */
 +#define XHCI_ASMEDIA_MODIFY_FLOWCONTROL	(1 << 28)
 +#define XHCI_HW_LPM_DISABLE	(1 << 29)
 +#define XHCI_SUSPEND_DELAY	(1 << 30)
 +#define XHCI_INTEL_USB_ROLE_SW	(1 << 31)
++=======
+ #define XHCI_BROKEN_PORT_PED	BIT_ULL(25)
+ #define XHCI_LIMIT_ENDPOINT_INTERVAL_7	BIT_ULL(26)
+ #define XHCI_U2_DISABLE_WAKE	BIT_ULL(27)
+ #define XHCI_ASMEDIA_MODIFY_FLOWCONTROL	BIT_ULL(28)
+ #define XHCI_HW_LPM_DISABLE	BIT_ULL(29)
+ #define XHCI_SUSPEND_DELAY	BIT_ULL(30)
+ #define XHCI_INTEL_USB_ROLE_SW	BIT_ULL(31)
+ #define XHCI_ZERO_64B_REGS	BIT_ULL(32)
++>>>>>>> 12de0a35c996 (xhci: Add quirk to zero 64bit registers on Renesas PCIe controllers)
  
  	unsigned int		num_active_eps;
  	unsigned int		limit_active_eps;
diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index eee065bef09f..6b0304496196 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -184,11 +184,15 @@ static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)
 		xhci->quirks |= XHCI_BROKEN_STREAMS;
 	}
 	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
-			pdev->device == 0x0014)
+	    pdev->device == 0x0014) {
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
+		xhci->quirks |= XHCI_ZERO_64B_REGS;
+	}
 	if (pdev->vendor == PCI_VENDOR_ID_RENESAS &&
-			pdev->device == 0x0015)
+	    pdev->device == 0x0015) {
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
+		xhci->quirks |= XHCI_ZERO_64B_REGS;
+	}
 	if (pdev->vendor == PCI_VENDOR_ID_VIA)
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index da858c1ad927..ac3e4051beac 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -209,6 +209,68 @@ int xhci_reset(struct xhci_hcd *xhci)
 	return ret;
 }
 
+static void xhci_zero_64b_regs(struct xhci_hcd *xhci)
+{
+	struct device *dev = xhci_to_hcd(xhci)->self.sysdev;
+	int err, i;
+	u64 val;
+
+	/*
+	 * Some Renesas controllers get into a weird state if they are
+	 * reset while programmed with 64bit addresses (they will preserve
+	 * the top half of the address in internal, non visible
+	 * registers). You end up with half the address coming from the
+	 * kernel, and the other half coming from the firmware. Also,
+	 * changing the programming leads to extra accesses even if the
+	 * controller is supposed to be halted. The controller ends up with
+	 * a fatal fault, and is then ripe for being properly reset.
+	 *
+	 * Special care is taken to only apply this if the device is behind
+	 * an iommu. Doing anything when there is no iommu is definitely
+	 * unsafe...
+	 */
+	if (!(xhci->quirks & XHCI_ZERO_64B_REGS) || !dev->iommu_group)
+		return;
+
+	xhci_info(xhci, "Zeroing 64bit base registers, expecting fault\n");
+
+	/* Clear HSEIE so that faults do not get signaled */
+	val = readl(&xhci->op_regs->command);
+	val &= ~CMD_HSEIE;
+	writel(val, &xhci->op_regs->command);
+
+	/* Clear HSE (aka FATAL) */
+	val = readl(&xhci->op_regs->status);
+	val |= STS_FATAL;
+	writel(val, &xhci->op_regs->status);
+
+	/* Now zero the registers, and brace for impact */
+	val = xhci_read_64(xhci, &xhci->op_regs->dcbaa_ptr);
+	if (upper_32_bits(val))
+		xhci_write_64(xhci, 0, &xhci->op_regs->dcbaa_ptr);
+	val = xhci_read_64(xhci, &xhci->op_regs->cmd_ring);
+	if (upper_32_bits(val))
+		xhci_write_64(xhci, 0, &xhci->op_regs->cmd_ring);
+
+	for (i = 0; i < HCS_MAX_INTRS(xhci->hcs_params1); i++) {
+		struct xhci_intr_reg __iomem *ir;
+
+		ir = &xhci->run_regs->ir_set[i];
+		val = xhci_read_64(xhci, &ir->erst_base);
+		if (upper_32_bits(val))
+			xhci_write_64(xhci, 0, &ir->erst_base);
+		val= xhci_read_64(xhci, &ir->erst_dequeue);
+		if (upper_32_bits(val))
+			xhci_write_64(xhci, 0, &ir->erst_dequeue);
+	}
+
+	/* Wait for the fault to appear. It will be cleared on reset */
+	err = xhci_handshake(&xhci->op_regs->status,
+			     STS_FATAL, STS_FATAL,
+			     XHCI_MAX_HALT_USEC);
+	if (!err)
+		xhci_info(xhci, "Fault detected\n");
+}
 
 #ifdef CONFIG_USB_PCI
 /*
@@ -1008,6 +1070,7 @@ int xhci_resume(struct xhci_hcd *xhci, bool hibernated)
 
 		xhci_dbg(xhci, "Stop HCD\n");
 		xhci_halt(xhci);
+		xhci_zero_64b_regs(xhci);
 		xhci_reset(xhci);
 		spin_unlock_irq(&xhci->lock);
 		xhci_cleanup_msix(xhci);
@@ -4919,6 +4982,8 @@ int xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks)
 	if (retval)
 		return retval;
 
+	xhci_zero_64b_regs(xhci);
+
 	xhci_dbg(xhci, "Resetting HCD\n");
 	/* Reset the internal HC memory state and registers. */
 	retval = xhci_reset(xhci);
* Unmerged path drivers/usb/host/xhci.h
