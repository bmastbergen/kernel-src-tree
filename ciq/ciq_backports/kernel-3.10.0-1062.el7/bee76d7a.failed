IB/uverbs: Add alloc/free dm uverbs ioctl support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ariel Levkovich <lariel@mellanox.com>
commit bee76d7ab5d270919e80e4764df7cd7e4f06ed24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/bee76d7a.failed

This change adds uverbs support for allocation/freeing
of device memory commands.

A new uverbs object is defined of type idr to represent
and track the new resource type allocation per context.

The API requires provider driver to implement 2 new ib_device
callbacks - one for allocation and one for deallocation which
return and accept (respectively) the ib_dm object which represents
the allocated memory on the device.

The support is added via the ioctl command infrastructure
only.

	Signed-off-by: Ariel Levkovich <lariel@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit bee76d7ab5d270919e80e4764df7cd7e4f06ed24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/Makefile
#	drivers/infiniband/core/uverbs.h
#	drivers/infiniband/core/uverbs_std_types.c
#	include/rdma/ib_verbs.h
#	include/uapi/rdma/ib_user_ioctl_cmds.h
diff --cc drivers/infiniband/core/Makefile
index c38d78c3c3ce,636da34f8308..000000000000
--- a/drivers/infiniband/core/Makefile
+++ b/drivers/infiniband/core/Makefile
@@@ -32,4 -34,5 +32,9 @@@ ib_ucm-y :=			ucm.
  
  ib_uverbs-y :=			uverbs_main.o uverbs_cmd.o uverbs_marshall.o \
  				rdma_core.o uverbs_std_types.o uverbs_ioctl.o \
++<<<<<<< HEAD
 +				uverbs_ioctl_merge.o uverbs_std_types_cq.o
++=======
+ 				uverbs_ioctl_merge.o uverbs_std_types_cq.o \
+ 				uverbs_std_types_flow_action.o uverbs_std_types_dm.o
++>>>>>>> bee76d7ab5d2 (IB/uverbs: Add alloc/free dm uverbs ioctl support)
diff --cc drivers/infiniband/core/uverbs.h
index 1be43bf189de,cfb51618ab7a..000000000000
--- a/drivers/infiniband/core/uverbs.h
+++ b/drivers/infiniband/core/uverbs.h
@@@ -282,6 -285,8 +282,11 @@@ extern const struct uverbs_object_def U
  extern const struct uverbs_object_def UVERBS_OBJECT(UVERBS_OBJECT_WQ);
  extern const struct uverbs_object_def UVERBS_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL);
  extern const struct uverbs_object_def UVERBS_OBJECT(UVERBS_OBJECT_XRCD);
++<<<<<<< HEAD
++=======
+ extern const struct uverbs_object_def UVERBS_OBJECT(UVERBS_OBJECT_FLOW_ACTION);
+ extern const struct uverbs_object_def UVERBS_OBJECT(UVERBS_OBJECT_DM);
++>>>>>>> bee76d7ab5d2 (IB/uverbs: Add alloc/free dm uverbs ioctl support)
  
  #define IB_UVERBS_DECLARE_CMD(name)					\
  	ssize_t ib_uverbs_##name(struct ib_uverbs_file *file,		\
diff --cc drivers/infiniband/core/uverbs_std_types.c
index bd10e94819b9,4fedf59ec396..000000000000
--- a/drivers/infiniband/core/uverbs_std_types.c
+++ b/drivers/infiniband/core/uverbs_std_types.c
@@@ -303,7 -310,9 +303,13 @@@ static DECLARE_UVERBS_OBJECT_TREE(uverb
  				  &UVERBS_OBJECT(UVERBS_OBJECT_FLOW),
  				  &UVERBS_OBJECT(UVERBS_OBJECT_WQ),
  				  &UVERBS_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL),
++<<<<<<< HEAD
 +				  &UVERBS_OBJECT(UVERBS_OBJECT_XRCD));
++=======
+ 				  &UVERBS_OBJECT(UVERBS_OBJECT_XRCD),
+ 				  &UVERBS_OBJECT(UVERBS_OBJECT_FLOW_ACTION),
+ 				  &UVERBS_OBJECT(UVERBS_OBJECT_DM));
++>>>>>>> bee76d7ab5d2 (IB/uverbs: Add alloc/free dm uverbs ioctl support)
  
  const struct uverbs_object_tree_def *uverbs_default_get_objects(void)
  {
diff --cc include/rdma/ib_verbs.h
index e4a3f200edb0,6806c4f5657a..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -2384,6 -2432,18 +2398,21 @@@ struct ib_device 
  							   struct ib_rwq_ind_table_init_attr *init_attr,
  							   struct ib_udata *udata);
  	int                        (*destroy_rwq_ind_table)(struct ib_rwq_ind_table *wq_ind_table);
++<<<<<<< HEAD
++=======
+ 	struct ib_flow_action *	   (*create_flow_action_esp)(struct ib_device *device,
+ 							     const struct ib_flow_action_attrs_esp *attr,
+ 							     struct uverbs_attr_bundle *attrs);
+ 	int			   (*destroy_flow_action)(struct ib_flow_action *action);
+ 	int			   (*modify_flow_action_esp)(struct ib_flow_action *action,
+ 							     const struct ib_flow_action_attrs_esp *attr,
+ 							     struct uverbs_attr_bundle *attrs);
+ 	struct ib_dm *             (*alloc_dm)(struct ib_device *device,
+ 					       struct ib_ucontext *context,
+ 					       struct ib_dm_alloc_attr *attr,
+ 					       struct uverbs_attr_bundle *attrs);
+ 	int                        (*dealloc_dm)(struct ib_dm *dm);
++>>>>>>> bee76d7ab5d2 (IB/uverbs: Add alloc/free dm uverbs ioctl support)
  	/**
  	 * rdma netdev operation
  	 *
diff --cc include/uapi/rdma/ib_user_ioctl_cmds.h
index 77bbbed17ed5,6034df2625c6..000000000000
--- a/include/uapi/rdma/ib_user_ioctl_cmds.h
+++ b/include/uapi/rdma/ib_user_ioctl_cmds.h
@@@ -53,6 -53,8 +53,11 @@@ enum uverbs_default_objects 
  	UVERBS_OBJECT_XRCD,
  	UVERBS_OBJECT_RWQ_IND_TBL,
  	UVERBS_OBJECT_WQ,
++<<<<<<< HEAD
++=======
+ 	UVERBS_OBJECT_FLOW_ACTION,
+ 	UVERBS_OBJECT_DM,
++>>>>>>> bee76d7ab5d2 (IB/uverbs: Add alloc/free dm uverbs ioctl support)
  };
  
  enum {
@@@ -80,4 -95,24 +85,27 @@@ enum uverbs_methods_cq 
  	UVERBS_METHOD_CQ_DESTROY,
  };
  
++<<<<<<< HEAD
++=======
+ enum uverbs_methods_actions_flow_action_ops {
+ 	UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
+ 	UVERBS_METHOD_FLOW_ACTION_DESTROY,
+ 	UVERBS_METHOD_FLOW_ACTION_ESP_MODIFY,
+ };
+ 
+ enum uverbs_attrs_alloc_dm_cmd_attr_ids {
+ 	UVERBS_ATTR_ALLOC_DM_HANDLE,
+ 	UVERBS_ATTR_ALLOC_DM_LENGTH,
+ 	UVERBS_ATTR_ALLOC_DM_ALIGNMENT,
+ };
+ 
+ enum uverbs_attrs_free_dm_cmd_attr_ids {
+ 	UVERBS_ATTR_FREE_DM_HANDLE,
+ };
+ 
+ enum uverbs_methods_dm {
+ 	UVERBS_METHOD_DM_ALLOC,
+ 	UVERBS_METHOD_DM_FREE,
+ };
++>>>>>>> bee76d7ab5d2 (IB/uverbs: Add alloc/free dm uverbs ioctl support)
  #endif
* Unmerged path drivers/infiniband/core/Makefile
* Unmerged path drivers/infiniband/core/uverbs.h
* Unmerged path drivers/infiniband/core/uverbs_std_types.c
diff --git a/drivers/infiniband/core/uverbs_std_types_dm.c b/drivers/infiniband/core/uverbs_std_types_dm.c
new file mode 100644
index 000000000000..8b681575b615
--- /dev/null
+++ b/drivers/infiniband/core/uverbs_std_types_dm.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2018, Mellanox Technologies inc.  All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include "uverbs.h"
+#include <rdma/uverbs_std_types.h>
+
+static int uverbs_free_dm(struct ib_uobject *uobject,
+			  enum rdma_remove_reason why)
+{
+	struct ib_dm *dm = uobject->object;
+
+	if (why == RDMA_REMOVE_DESTROY && atomic_read(&dm->usecnt))
+		return -EBUSY;
+
+	return dm->device->dealloc_dm(dm);
+}
+
+static int UVERBS_HANDLER(UVERBS_METHOD_DM_ALLOC)(struct ib_device *ib_dev,
+						  struct ib_uverbs_file *file,
+						  struct uverbs_attr_bundle *attrs)
+{
+	struct ib_ucontext *ucontext = file->ucontext;
+	struct ib_dm_alloc_attr attr = {};
+	struct ib_uobject *uobj;
+	struct ib_dm *dm;
+	int ret;
+
+	if (!ib_dev->alloc_dm)
+		return -EOPNOTSUPP;
+
+	ret = uverbs_copy_from(&attr.length, attrs,
+			       UVERBS_ATTR_ALLOC_DM_LENGTH);
+	if (ret)
+		return ret;
+
+	ret = uverbs_copy_from(&attr.alignment, attrs,
+			       UVERBS_ATTR_ALLOC_DM_ALIGNMENT);
+	if (ret)
+		return ret;
+
+	uobj = uverbs_attr_get(attrs, UVERBS_ATTR_ALLOC_DM_HANDLE)->obj_attr.uobject;
+
+	dm = ib_dev->alloc_dm(ib_dev, ucontext, &attr, attrs);
+	if (IS_ERR(dm))
+		return PTR_ERR(dm);
+
+	dm->device  = ib_dev;
+	dm->length  = attr.length;
+	dm->uobject = uobj;
+	atomic_set(&dm->usecnt, 0);
+
+	uobj->object = dm;
+
+	return 0;
+}
+
+static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_DM_ALLOC,
+	&UVERBS_ATTR_IDR(UVERBS_ATTR_ALLOC_DM_HANDLE, UVERBS_OBJECT_DM,
+			 UVERBS_ACCESS_NEW,
+			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_ALLOC_DM_LENGTH,
+			    UVERBS_ATTR_TYPE(u64),
+			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_ALLOC_DM_ALIGNMENT,
+			    UVERBS_ATTR_TYPE(u32),
+			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+
+static DECLARE_UVERBS_NAMED_METHOD_WITH_HANDLER(UVERBS_METHOD_DM_FREE,
+	uverbs_destroy_def_handler,
+	&UVERBS_ATTR_IDR(UVERBS_ATTR_FREE_DM_HANDLE,
+			 UVERBS_OBJECT_DM,
+			 UVERBS_ACCESS_DESTROY,
+			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+
+DECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_DM,
+			    /* 1 is used in order to free the DM after MRs */
+			    &UVERBS_TYPE_ALLOC_IDR(1, uverbs_free_dm),
+			    &UVERBS_METHOD(UVERBS_METHOD_DM_ALLOC),
+			    &UVERBS_METHOD(UVERBS_METHOD_DM_FREE));
* Unmerged path include/rdma/ib_verbs.h
* Unmerged path include/uapi/rdma/ib_user_ioctl_cmds.h
