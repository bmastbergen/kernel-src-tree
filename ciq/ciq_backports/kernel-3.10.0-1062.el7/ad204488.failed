ovl: rename ufs to ofs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit ad204488d3046b3baee2d2b1b05323d956a7c45b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ad204488.failed

Rename all "struct ovl_fs" pointers to "ofs".  The "ufs" name is historical
and can only be found in overlayfs/super.c.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit ad204488d3046b3baee2d2b1b05323d956a7c45b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index 19e9eb0f1d4f,3156e908423e..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -218,29 -211,37 +218,56 @@@ static void ovl_destroy_inode(struct in
  	call_rcu(&inode->i_rcu, ovl_i_callback);
  }
  
++<<<<<<< HEAD
 +static void ovl_put_super(struct super_block *sb)
++=======
+ static void ovl_free_fs(struct ovl_fs *ofs)
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  {
 +	struct ovl_fs *ufs = sb->s_fs_info;
  	unsigned i;
  
++<<<<<<< HEAD
 +	dput(ufs->indexdir);
 +	dput(ufs->workdir);
 +	if (ufs->workdir_locked)
 +		ovl_inuse_unlock(ufs->workbasedir);
 +	dput(ufs->workbasedir);
 +	if (ufs->upper_mnt && ufs->upperdir_locked)
 +		ovl_inuse_unlock(ufs->upper_mnt->mnt_root);
 +	mntput(ufs->upper_mnt);
 +	for (i = 0; i < ufs->numlower; i++)
 +		mntput(ufs->lower_mnt[i]);
 +	kfree(ufs->lower_mnt);
 +
 +	kfree(ufs->config.lowerdir);
 +	kfree(ufs->config.upperdir);
 +	kfree(ufs->config.workdir);
 +	kfree(ufs->config.redirect_mode);
 +	put_cred(ufs->creator_cred);
 +	kfree(ufs);
++=======
+ 	dput(ofs->indexdir);
+ 	dput(ofs->workdir);
+ 	if (ofs->workdir_locked)
+ 		ovl_inuse_unlock(ofs->workbasedir);
+ 	dput(ofs->workbasedir);
+ 	if (ofs->upperdir_locked)
+ 		ovl_inuse_unlock(ofs->upper_mnt->mnt_root);
+ 	mntput(ofs->upper_mnt);
+ 	for (i = 0; i < ofs->numlower; i++) {
+ 		mntput(ofs->lower_layers[i].mnt);
+ 		free_anon_bdev(ofs->lower_layers[i].pseudo_dev);
+ 	}
+ 	kfree(ofs->lower_layers);
+ 
+ 	kfree(ofs->config.lowerdir);
+ 	kfree(ofs->config.upperdir);
+ 	kfree(ofs->config.workdir);
+ 	if (ofs->creator_cred)
+ 		put_cred(ofs->creator_cred);
+ 	kfree(ofs);
 -}
 -
 -static void ovl_put_super(struct super_block *sb)
 -{
 -	struct ovl_fs *ofs = sb->s_fs_info;
 -
 -	ovl_free_fs(ofs);
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  }
  
  static int ovl_sync_fs(struct super_block *sb, int wait)
@@@ -289,16 -290,11 +316,16 @@@ static int ovl_statfs(struct dentry *de
  }
  
  /* Will this overlay be forced to mount/remount ro? */
- static bool ovl_force_readonly(struct ovl_fs *ufs)
+ static bool ovl_force_readonly(struct ovl_fs *ofs)
  {
- 	return (!ufs->upper_mnt || !ufs->workdir);
+ 	return (!ofs->upper_mnt || !ofs->workdir);
  }
  
 +static const char *ovl_redirect_mode_def(void)
 +{
 +	return ovl_redirect_dir_def ? "on" : "off";
 +}
 +
  /**
   * ovl_show_options
   *
@@@ -308,19 -304,21 +335,28 @@@
  static int ovl_show_options(struct seq_file *m, struct dentry *dentry)
  {
  	struct super_block *sb = dentry->d_sb;
- 	struct ovl_fs *ufs = sb->s_fs_info;
+ 	struct ovl_fs *ofs = sb->s_fs_info;
  
- 	seq_show_option(m, "lowerdir", ufs->config.lowerdir);
- 	if (ufs->config.upperdir) {
- 		seq_show_option(m, "upperdir", ufs->config.upperdir);
- 		seq_show_option(m, "workdir", ufs->config.workdir);
+ 	seq_show_option(m, "lowerdir", ofs->config.lowerdir);
+ 	if (ofs->config.upperdir) {
+ 		seq_show_option(m, "upperdir", ofs->config.upperdir);
+ 		seq_show_option(m, "workdir", ofs->config.workdir);
  	}
- 	if (ufs->config.default_permissions)
+ 	if (ofs->config.default_permissions)
  		seq_puts(m, ",default_permissions");
++<<<<<<< HEAD
 +	if (strcmp(ufs->config.redirect_mode, ovl_redirect_mode_def()) != 0)
 +		seq_printf(m, ",redirect_dir=%s", ufs->config.redirect_mode);
 +	if (ufs->config.index != ovl_index_def)
 +		seq_printf(m, ",index=%s", ufs->config.index ? "on" : "off");
++=======
+ 	if (ofs->config.redirect_dir != ovl_redirect_dir_def)
+ 		seq_printf(m, ",redirect_dir=%s",
+ 			   ofs->config.redirect_dir ? "on" : "off");
+ 	if (ofs->config.index != ovl_index_def)
+ 		seq_printf(m, ",index=%s",
+ 			   ofs->config.index ? "on" : "off");
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  	return 0;
  }
  
@@@ -490,13 -464,11 +526,21 @@@ static int ovl_parse_opt(char *opt, str
  #define OVL_WORKDIR_NAME "work"
  #define OVL_INDEXDIR_NAME "index"
  
++<<<<<<< HEAD
 +static struct dentry *ovl_workdir_create(struct super_block *sb,
 +					 struct ovl_fs *ufs,
 +					 struct dentry *dentry,
 +					 const char *name, bool persist)
 +{
 +	struct inode *dir = dentry->d_inode;
 +	struct vfsmount *mnt = ufs->upper_mnt;
++=======
+ static struct dentry *ovl_workdir_create(struct ovl_fs *ofs,
+ 					 const char *name, bool persist)
+ {
+ 	struct inode *dir =  ofs->workbasedir->d_inode;
+ 	struct vfsmount *mnt = ofs->upper_mnt;
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  	struct dentry *work;
  	int err;
  	bool retried = false;
@@@ -510,7 -482,7 +554,11 @@@
  	locked = true;
  
  retry:
++<<<<<<< HEAD
 +	work = lookup_one_len(name, dentry, strlen(name));
++=======
+ 	work = lookup_one_len(name, ofs->workbasedir, strlen(name));
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  
  	if (!IS_ERR(work)) {
  		struct iattr attr = {
@@@ -580,8 -552,7 +628,12 @@@ out_dput
  	dput(work);
  out_err:
  	pr_warn("overlayfs: failed to create directory %s/%s (errno: %i); mounting read-only\n",
++<<<<<<< HEAD
 +		ufs->config.workdir, name, -err);
 +	sb->s_flags |= MS_RDONLY;
++=======
+ 		ofs->config.workdir, name, -err);
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  	work = NULL;
  	goto out_unlock;
  }
@@@ -870,299 -836,392 +922,657 @@@ static const struct xattr_handler *ovl_
  	NULL
  };
  
++<<<<<<< HEAD
++=======
+ static int ovl_get_upper(struct ovl_fs *ofs, struct path *upperpath)
+ {
+ 	struct vfsmount *upper_mnt;
+ 	int err;
+ 
+ 	err = ovl_mount_dir(ofs->config.upperdir, upperpath);
+ 	if (err)
+ 		goto out;
+ 
+ 	/* Upper fs should not be r/o */
+ 	if (sb_rdonly(upperpath->mnt->mnt_sb)) {
+ 		pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	err = ovl_check_namelen(upperpath, ofs, ofs->config.upperdir);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = -EBUSY;
+ 	if (ovl_inuse_trylock(upperpath->dentry)) {
+ 		ofs->upperdir_locked = true;
+ 	} else if (ofs->config.index) {
+ 		pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
+ 		goto out;
+ 	} else {
+ 		pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
+ 	}
+ 
+ 	upper_mnt = clone_private_mount(upperpath);
+ 	err = PTR_ERR(upper_mnt);
+ 	if (IS_ERR(upper_mnt)) {
+ 		pr_err("overlayfs: failed to clone upperpath\n");
+ 		goto out;
+ 	}
+ 
+ 	/* Don't inherit atime flags */
+ 	upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
+ 	ofs->upper_mnt = upper_mnt;
+ 	err = 0;
+ out:
+ 	return err;
+ }
+ 
+ static int ovl_make_workdir(struct ovl_fs *ofs, struct path *workpath)
+ {
+ 	struct dentry *temp;
+ 	int err;
+ 
+ 	ofs->workdir = ovl_workdir_create(ofs, OVL_WORKDIR_NAME, false);
+ 	if (!ofs->workdir)
+ 		return 0;
+ 
+ 	/*
+ 	 * Upper should support d_type, else whiteouts are visible.  Given
+ 	 * workdir and upper are on same fs, we can do iterate_dir() on
+ 	 * workdir. This check requires successful creation of workdir in
+ 	 * previous step.
+ 	 */
+ 	err = ovl_check_d_type_supported(workpath);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/*
+ 	 * We allowed this configuration and don't want to break users over
+ 	 * kernel upgrade. So warn instead of erroring out.
+ 	 */
+ 	if (!err)
+ 		pr_warn("overlayfs: upper fs needs to support d_type.\n");
+ 
+ 	/* Check if upper/work fs supports O_TMPFILE */
+ 	temp = ovl_do_tmpfile(ofs->workdir, S_IFREG | 0);
+ 	ofs->tmpfile = !IS_ERR(temp);
+ 	if (ofs->tmpfile)
+ 		dput(temp);
+ 	else
+ 		pr_warn("overlayfs: upper fs does not support tmpfile.\n");
+ 
+ 	/*
+ 	 * Check if upper/work fs supports trusted.overlay.* xattr
+ 	 */
+ 	err = ovl_do_setxattr(ofs->workdir, OVL_XATTR_OPAQUE, "0", 1, 0);
+ 	if (err) {
+ 		ofs->noxattr = true;
+ 		pr_warn("overlayfs: upper fs does not support xattr.\n");
+ 	} else {
+ 		vfs_removexattr(ofs->workdir, OVL_XATTR_OPAQUE);
+ 	}
+ 
+ 	/* Check if upper/work fs supports file handles */
+ 	if (ofs->config.index &&
+ 	    !ovl_can_decode_fh(ofs->workdir->d_sb)) {
+ 		ofs->config.index = false;
+ 		pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int ovl_get_workdir(struct ovl_fs *ofs, struct path *upperpath)
+ {
+ 	int err;
+ 	struct path workpath = { };
+ 
+ 	err = ovl_mount_dir(ofs->config.workdir, &workpath);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = -EINVAL;
+ 	if (upperpath->mnt != workpath.mnt) {
+ 		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
+ 		goto out;
+ 	}
+ 	if (!ovl_workdir_ok(workpath.dentry, upperpath->dentry)) {
+ 		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
+ 		goto out;
+ 	}
+ 
+ 	err = -EBUSY;
+ 	if (ovl_inuse_trylock(workpath.dentry)) {
+ 		ofs->workdir_locked = true;
+ 	} else if (ofs->config.index) {
+ 		pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
+ 		goto out;
+ 	} else {
+ 		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
+ 	}
+ 
+ 	ofs->workbasedir = dget(workpath.dentry);
+ 	err = ovl_make_workdir(ofs, &workpath);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = 0;
+ out:
+ 	path_put(&workpath);
+ 
+ 	return err;
+ }
+ 
+ static int ovl_get_indexdir(struct ovl_fs *ofs, struct ovl_entry *oe,
+ 			    struct path *upperpath)
+ {
+ 	int err;
+ 
+ 	/* Verify lower root is upper root origin */
+ 	err = ovl_verify_origin(upperpath->dentry,
+ 				oe->lowerstack[0].layer->mnt,
+ 				oe->lowerstack[0].dentry,
+ 				false, true);
+ 	if (err) {
+ 		pr_err("overlayfs: failed to verify upper root origin\n");
+ 		goto out;
+ 	}
+ 
+ 	ofs->indexdir = ovl_workdir_create(ofs, OVL_INDEXDIR_NAME, true);
+ 	if (ofs->indexdir) {
+ 		/* Verify upper root is index dir origin */
+ 		err = ovl_verify_origin(ofs->indexdir, ofs->upper_mnt,
+ 					upperpath->dentry, true, true);
+ 		if (err)
+ 			pr_err("overlayfs: failed to verify index dir origin\n");
+ 
+ 		/* Cleanup bad/stale/orphan index entries */
+ 		if (!err)
+ 			err = ovl_indexdir_cleanup(ofs->indexdir,
+ 						   ofs->upper_mnt,
+ 						   oe->lowerstack,
+ 						   oe->numlower);
+ 	}
+ 	if (err || !ofs->indexdir)
+ 		pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
+ 
+ out:
+ 	return err;
+ }
+ 
+ static int ovl_get_lower_layers(struct ovl_fs *ofs, struct path *stack,
+ 				unsigned int numlower)
+ {
+ 	int err;
+ 	unsigned int i;
+ 
+ 	err = -ENOMEM;
+ 	ofs->lower_layers = kcalloc(numlower, sizeof(struct ovl_layer),
+ 				    GFP_KERNEL);
+ 	if (ofs->lower_layers == NULL)
+ 		goto out;
+ 	for (i = 0; i < numlower; i++) {
+ 		struct vfsmount *mnt;
+ 		dev_t dev;
+ 
+ 		err = get_anon_bdev(&dev);
+ 		if (err) {
+ 			pr_err("overlayfs: failed to get anonymous bdev for lowerpath\n");
+ 			goto out;
+ 		}
+ 
+ 		mnt = clone_private_mount(&stack[i]);
+ 		err = PTR_ERR(mnt);
+ 		if (IS_ERR(mnt)) {
+ 			pr_err("overlayfs: failed to clone lowerpath\n");
+ 			free_anon_bdev(dev);
+ 			goto out;
+ 		}
+ 		/*
+ 		 * Make lower layers R/O.  That way fchmod/fchown on lower file
+ 		 * will fail instead of modifying lower fs.
+ 		 */
+ 		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
+ 
+ 		ofs->lower_layers[ofs->numlower].mnt = mnt;
+ 		ofs->lower_layers[ofs->numlower].pseudo_dev = dev;
+ 		ofs->numlower++;
+ 
+ 		/* Check if all lower layers are on same sb */
+ 		if (i == 0)
+ 			ofs->same_sb = mnt->mnt_sb;
+ 		else if (ofs->same_sb != mnt->mnt_sb)
+ 			ofs->same_sb = NULL;
+ 	}
+ 	err = 0;
+ out:
+ 	return err;
+ }
+ 
+ static struct ovl_entry *ovl_get_lowerstack(struct super_block *sb,
+ 					    struct ovl_fs *ofs)
+ {
+ 	int err;
+ 	char *lowertmp, *lower;
+ 	struct path *stack = NULL;
+ 	unsigned int stacklen, numlower = 0, i;
+ 	bool remote = false;
+ 	struct ovl_entry *oe;
+ 
+ 	err = -ENOMEM;
+ 	lowertmp = kstrdup(ofs->config.lowerdir, GFP_KERNEL);
+ 	if (!lowertmp)
+ 		goto out_err;
+ 
+ 	err = -EINVAL;
+ 	stacklen = ovl_split_lowerdirs(lowertmp);
+ 	if (stacklen > OVL_MAX_STACK) {
+ 		pr_err("overlayfs: too many lower directories, limit is %d\n",
+ 		       OVL_MAX_STACK);
+ 		goto out_err;
+ 	} else if (!ofs->config.upperdir && stacklen == 1) {
+ 		pr_err("overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n");
+ 		goto out_err;
+ 	}
+ 
+ 	err = -ENOMEM;
+ 	stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);
+ 	if (!stack)
+ 		goto out_err;
+ 
+ 	err = -EINVAL;
+ 	lower = lowertmp;
+ 	for (numlower = 0; numlower < stacklen; numlower++) {
+ 		err = ovl_lower_dir(lower, &stack[numlower], ofs,
+ 				    &sb->s_stack_depth, &remote);
+ 		if (err)
+ 			goto out_err;
+ 
+ 		lower = strchr(lower, '\0') + 1;
+ 	}
+ 
+ 	err = -EINVAL;
+ 	sb->s_stack_depth++;
+ 	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
+ 		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
+ 		goto out_err;
+ 	}
+ 
+ 	err = ovl_get_lower_layers(ofs, stack, numlower);
+ 	if (err)
+ 		goto out_err;
+ 
+ 	err = -ENOMEM;
+ 	oe = ovl_alloc_entry(numlower);
+ 	if (!oe)
+ 		goto out_err;
+ 
+ 	for (i = 0; i < numlower; i++) {
+ 		oe->lowerstack[i].dentry = dget(stack[i].dentry);
+ 		oe->lowerstack[i].layer = &ofs->lower_layers[i];
+ 	}
+ 
+ 	if (remote)
+ 		sb->s_d_op = &ovl_reval_dentry_operations;
+ 	else
+ 		sb->s_d_op = &ovl_dentry_operations;
+ 
+ out:
+ 	for (i = 0; i < numlower; i++)
+ 		path_put(&stack[i]);
+ 	kfree(stack);
+ 	kfree(lowertmp);
+ 
+ 	return oe;
+ 
+ out_err:
+ 	oe = ERR_PTR(err);
+ 	goto out;
+ }
+ 
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
  	struct path upperpath = { };
 +	struct path workpath = { };
  	struct dentry *root_dentry;
  	struct ovl_entry *oe;
++<<<<<<< HEAD
 +	struct ovl_fs *ufs;
 +	const int *upper_stack_depth;
 +	int *overlay_stack_depth;
 +	struct path *stack = NULL;
 +	char *lowertmp;
 +	char *lower;
 +	unsigned int numlower;
 +	unsigned int stacklen = 0;
 +	unsigned int i;
 +	bool remote = false;
++=======
+ 	struct ovl_fs *ofs;
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  	struct cred *cred;
  	int err;
  
  	err = -ENOMEM;
- 	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
- 	if (!ufs)
+ 	ofs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
+ 	if (!ofs)
  		goto out;
  
++<<<<<<< HEAD
 +	ufs->config.index = ovl_index_def;
 +	err = ovl_parse_opt((char *) data, &ufs->config);
++=======
+ 	ofs->creator_cred = cred = prepare_creds();
+ 	if (!cred)
+ 		goto out_err;
+ 
+ 	ofs->config.redirect_dir = ovl_redirect_dir_def;
+ 	ofs->config.index = ovl_index_def;
+ 	err = ovl_parse_opt((char *) data, &ofs->config);
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  	if (err)
 -		goto out_err;
 +		goto out_free_config;
  
  	err = -EINVAL;
- 	if (!ufs->config.lowerdir) {
+ 	if (!ofs->config.lowerdir) {
  		if (!silent)
  			pr_err("overlayfs: missing 'lowerdir'\n");
 -		goto out_err;
 +		goto out_free_config;
  	}
  
 -	sb->s_stack_depth = 0;
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_free_config;
 +	}
 +	*overlay_stack_depth = 0;
 +
  	sb->s_maxbytes = MAX_LFS_FILESIZE;
- 	if (ufs->config.upperdir) {
- 		if (!ufs->config.workdir) {
+ 	if (ofs->config.upperdir) {
+ 		if (!ofs->config.workdir) {
  			pr_err("overlayfs: missing 'workdir'\n");
 -			goto out_err;
 +			goto out_free_config;
  		}
  
++<<<<<<< HEAD
 +		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
++=======
+ 		err = ovl_get_upper(ofs, &upperpath);
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  		if (err)
 -			goto out_err;
 +			goto out_free_config;
 +
++<<<<<<< HEAD
 +		/* Upper fs should not be r/o */
 +		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
 +			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 +			err = -EINVAL;
 +			goto out_put_upperpath;
 +		}
  
 +		err = ovl_check_namelen(&upperpath, ufs, ufs->config.upperdir);
++=======
+ 		err = ovl_get_workdir(ofs, &upperpath);
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  		if (err)
 -			goto out_err;
 +			goto out_put_upperpath;
 +
++<<<<<<< HEAD
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(upperpath.dentry)) {
 +			ufs->upperdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 +			goto out_put_upperpath;
 +		} else {
 +			pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
 +
 +		err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +		if (err)
 +			goto out_unlock_upperdentry;
 +
 +		err = -EINVAL;
 +		if (upperpath.mnt != workpath.mnt) {
 +			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +			goto out_put_workpath;
 +		}
 +		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +			goto out_put_workpath;
 +		}
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(workpath.dentry)) {
 +			ufs->workdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 +			goto out_put_workpath;
 +		} else {
 +			pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
 +
 +		ufs->workbasedir = workpath.dentry;
 +		upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +		err = -EOPNOTSUPP;
 +		if (!upper_stack_depth) {
 +			pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +			goto out_put_workpath;
 +		}
 +
 +		*overlay_stack_depth = *upper_stack_depth;
 +	}
 +
 +	err = -ENOMEM;
 +	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
 +	if (!lowertmp)
 +		goto out_unlock_workdentry;
 +
 +	err = -EINVAL;
 +	stacklen = ovl_split_lowerdirs(lowertmp);
 +	if (stacklen > OVL_MAX_STACK) {
 +		pr_err("overlayfs: too many lower directories, limit is %d\n",
 +		       OVL_MAX_STACK);
 +		goto out_free_lowertmp;
 +	} else if (!ufs->config.upperdir && stacklen == 1) {
 +		pr_err("overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n");
 +		goto out_free_lowertmp;
 +	}
 +
 +	err = -ENOMEM;
 +	stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);
 +	if (!stack)
 +		goto out_free_lowertmp;
 +
 +	err = -EINVAL;
 +	lower = lowertmp;
 +	for (numlower = 0; numlower < stacklen; numlower++) {
 +		err = ovl_lower_dir(lower, &stack[numlower], ufs,
 +				    overlay_stack_depth, &remote);
 +		if (err)
 +			goto out_put_lowerpath;
 +
 +		lower = strchr(lower, '\0') + 1;
 +	}
 +
 +	err = -EINVAL;
 +	*overlay_stack_depth += 1;
 +	if (*overlay_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 +		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 +		goto out_put_lowerpath;
 +	}
 +
 +	if (ufs->config.upperdir) {
 +		ufs->upper_mnt = clone_private_mount(&upperpath);
 +		err = PTR_ERR(ufs->upper_mnt);
 +		if (IS_ERR(ufs->upper_mnt)) {
 +			pr_err("overlayfs: failed to clone upperpath\n");
 +			goto out_put_lowerpath;
 +		}
  
 +		/* Don't inherit atime flags */
 +		ufs->upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
 +
 +		sb->s_time_gran = ufs->upper_mnt->mnt_sb->s_time_gran;
++=======
+ 		if (!ofs->workdir)
+ 			sb->s_flags |= MS_RDONLY;
+ 
+ 		sb->s_stack_depth = ofs->upper_mnt->mnt_sb->s_stack_depth;
+ 		sb->s_time_gran = ofs->upper_mnt->mnt_sb->s_time_gran;
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
 +
 +		ufs->workdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 +						  OVL_WORKDIR_NAME, false);
 +		/*
 +		 * Upper should support d_type, else whiteouts are visible.
 +		 * Given workdir and upper are on same fs, we can do
 +		 * iterate_dir() on workdir. This check requires successful
 +		 * creation of workdir in previous step.
 +		 */
 +		if (ufs->workdir) {
 +			struct dentry *temp;
 +
 +			err = ovl_check_d_type_supported(&workpath);
 +			if (err < 0)
 +				goto out_put_workdir;
 +
 +			/*
 +			 * Warn instead of error to avoid breaking previously
 +			 * working configurations over upgrade. If d_type
 +			 * is not supported, whiteouts will become visible
 +			 * to user space.
 +			 */
 +			if (!err)
 +				pr_warn("overlayfs: upper fs needs to support d_type. This is an invalid configuration.\n");
 +
 +			/* Check if upper/work fs supports O_TMPFILE */
 +			temp = ovl_do_tmpfile(ufs->workdir, S_IFREG | 0);
 +			ufs->tmpfile = !IS_ERR(temp);
 +			if (ufs->tmpfile)
 +				dput(temp);
 +
 +			/*
 +			 * Check if upper/work fs supports trusted.overlay.*
 +			 * xattr
 +			 */
 +			err = ovl_do_setxattr(ufs->workdir, OVL_XATTR_OPAQUE,
 +					      "0", 1, 0);
 +			if (err) {
 +				ufs->noxattr = true;
 +				pr_warn("overlayfs: upper fs does not support xattr.\n");
 +			} else {
 +				vfs_removexattr(ufs->workdir, OVL_XATTR_OPAQUE);
 +			}
 +
 +			/* Check if upper/work fs supports file handles */
 +			if (ufs->config.index &&
 +			    !ovl_can_decode_fh(ufs->workdir->d_sb)) {
 +				ufs->config.index = false;
 +				pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
 +			}
 +		}
 +	}
 +
 +	err = -ENOMEM;
 +	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
 +	if (ufs->lower_mnt == NULL)
 +		goto out_put_workdir;
 +	for (i = 0; i < numlower; i++) {
 +		struct vfsmount *mnt = clone_private_mount(&stack[i]);
 +
 +		err = PTR_ERR(mnt);
 +		if (IS_ERR(mnt)) {
 +			pr_err("overlayfs: failed to clone lowerpath\n");
 +			goto out_put_lower_mnt;
 +		}
 +		/*
 +		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 +		 * will fail instead of modifying lower fs.
 +		 */
 +		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
 +
 +		ufs->lower_mnt[ufs->numlower] = mnt;
 +		ufs->numlower++;
  
 +		/* Check if all lower layers are on same sb */
 +		if (i == 0)
 +			ufs->same_sb = mnt->mnt_sb;
 +		else if (ufs->same_sb != mnt->mnt_sb)
 +			ufs->same_sb = NULL;
  	}
++<<<<<<< HEAD
++=======
+ 	oe = ovl_get_lowerstack(sb, ofs);
+ 	err = PTR_ERR(oe);
+ 	if (IS_ERR(oe))
+ 		goto out_err;
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  
  	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
- 	if (!ufs->upper_mnt)
+ 	if (!ofs->upper_mnt)
  		sb->s_flags |= MS_RDONLY;
- 	else if (ufs->upper_mnt->mnt_sb != ufs->same_sb)
- 		ufs->same_sb = NULL;
+ 	else if (ofs->upper_mnt->mnt_sb != ofs->same_sb)
+ 		ofs->same_sb = NULL;
  
++<<<<<<< HEAD
 +	if (!(ovl_force_readonly(ufs)) && ufs->config.index) {
 +		/* Verify lower root is upper root origin */
 +		err = ovl_verify_origin(upperpath.dentry, ufs->lower_mnt[0],
 +					stack[0].dentry, false, true);
 +		if (err) {
 +			pr_err("overlayfs: failed to verify upper root origin\n");
 +			goto out_put_lower_mnt;
 +		}
 +
 +		ufs->indexdir = ovl_workdir_create(sb, ufs, workpath.dentry,
 +						   OVL_INDEXDIR_NAME, true);
 +		if (ufs->indexdir) {
 +			/* Verify upper root is index dir origin */
 +			err = ovl_verify_origin(ufs->indexdir, ufs->upper_mnt,
 +						upperpath.dentry, true, true);
 +			if (err)
 +				pr_err("overlayfs: failed to verify index dir origin\n");
 +
 +			/* Cleanup bad/stale/orphan index entries */
 +			if (!err)
 +				err = ovl_indexdir_cleanup(ufs->indexdir,
 +							   ufs->upper_mnt,
 +							   stack, numlower);
 +		}
 +		if (err || !ufs->indexdir)
 +			pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
 +		if (err)
 +			goto out_put_indexdir;
++=======
+ 	if (!(ovl_force_readonly(ofs)) && ofs->config.index) {
+ 		err = ovl_get_indexdir(ofs, oe, &upperpath);
+ 		if (err)
+ 			goto out_free_oe;
+ 
+ 		if (!ofs->indexdir)
+ 			sb->s_flags |= MS_RDONLY;
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  	}
  
  	/* Show index=off/on in /proc/mounts for any of the reasons above */
- 	if (!ufs->indexdir)
- 		ufs->config.index = false;
+ 	if (!ofs->indexdir)
+ 		ofs->config.index = false;
  
 +	if (remote)
 +		sb->s_d_op = &ovl_reval_dentry_operations.ops;
 +	else
 +		sb->s_d_op = &ovl_dentry_operations.ops;
 +
 +	err = -ENOMEM;
 +	ufs->creator_cred = cred = prepare_creds();
 +	if (!cred)
 +		goto out_put_indexdir;
 +
  	/* Never override disk quota limits or use reserved space */
  	cap_lower(cred->cap_effective, CAP_SYS_RESOURCE);
  
@@@ -1174,9 -1228,10 +1584,9 @@@
  	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
  	sb->s_op = &ovl_super_operations;
  	sb->s_xattr = ovl_xattr_handlers;
- 	sb->s_fs_info = ufs;
+ 	sb->s_fs_info = ofs;
  	sb->s_flags |= MS_POSIXACL | MS_NOREMOTELOCK;
  
 -	err = -ENOMEM;
  	root_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR, 0));
  	if (!root_dentry)
  		goto out_free_oe;
@@@ -1210,40 -1255,11 +1620,44 @@@
  	return 0;
  
  out_free_oe:
 -	ovl_entry_stack_free(oe);
  	kfree(oe);
 -out_err:
 +out_put_cred:
 +	put_cred(ufs->creator_cred);
 +out_put_indexdir:
 +	dput(ufs->indexdir);
 +out_put_lower_mnt:
 +	for (i = 0; i < ufs->numlower; i++)
 +		mntput(ufs->lower_mnt[i]);
 +	kfree(ufs->lower_mnt);
 +out_put_workdir:
 +	dput(ufs->workdir);
 +	mntput(ufs->upper_mnt);
 +out_put_lowerpath:
 +	for (i = 0; i < numlower; i++)
 +		path_put(&stack[i]);
 +	kfree(stack);
 +out_free_lowertmp:
 +	kfree(lowertmp);
 +out_unlock_workdentry:
 +	if (ufs->workdir_locked)
 +		ovl_inuse_unlock(workpath.dentry);
 +out_put_workpath:
 +	path_put(&workpath);
 +out_unlock_upperdentry:
 +	if (ufs->upperdir_locked)
 +		ovl_inuse_unlock(upperpath.dentry);
 +out_put_upperpath:
  	path_put(&upperpath);
++<<<<<<< HEAD
 +out_free_config:
 +	kfree(ufs->config.lowerdir);
 +	kfree(ufs->config.upperdir);
 +	kfree(ufs->config.workdir);
 +	kfree(ufs->config.redirect_mode);
 +	kfree(ufs);
++=======
+ 	ovl_free_fs(ofs);
++>>>>>>> ad204488d304 (ovl: rename ufs to ofs)
  out:
  	return err;
  }
* Unmerged path fs/overlayfs/super.c
