iommu/vt-d: Update register definitions to VT-d 3.0 specification

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Sohil Mehta <sohil.mehta@intel.com>
commit 4a2d80dbadb72b998641af32d8dd4b7b39e72aa0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4a2d80db.failed

Add new register definitions added in the VT-d 3.0 specification. Also
include registers that were missing previously.

	Cc: Lu Baolu <baolu.lu@linux.intel.com>
	Cc: Fenghua Yu <fenghua.yu@intel.com>
	Cc: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Cc: Ashok Raj <ashok.raj@intel.com>
	Cc: Gayatri Kammela <gayatri.kammela@intel.com>
	Signed-off-by: Sohil Mehta <sohil.mehta@intel.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 4a2d80dbadb72b998641af32d8dd4b7b39e72aa0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/intel-iommu.h
diff --cc include/linux/intel-iommu.h
index 446226a5cddb,3bdb9aa198af..000000000000
--- a/include/linux/intel-iommu.h
+++ b/include/linux/intel-iommu.h
@@@ -57,29 -64,55 +57,76 @@@
  #define DMAR_IQA_REG	0x90	/* Invalidation queue addr register */
  #define DMAR_ICS_REG	0x9c	/* Invalidation complete status register */
  #define DMAR_IRTA_REG	0xb8    /* Interrupt remapping table addr register */
++<<<<<<< HEAD
++=======
+ #define DMAR_PQH_REG	0xc0	/* Page request queue head register */
+ #define DMAR_PQT_REG	0xc8	/* Page request queue tail register */
+ #define DMAR_PQA_REG	0xd0	/* Page request queue address register */
+ #define DMAR_PRS_REG	0xdc	/* Page request status register */
+ #define DMAR_PECTL_REG	0xe0	/* Page request event control register */
+ #define	DMAR_PEDATA_REG	0xe4	/* Page request event interrupt data register */
+ #define	DMAR_PEADDR_REG	0xe8	/* Page request event interrupt addr register */
+ #define	DMAR_PEUADDR_REG 0xec	/* Page request event Upper address register */
+ #define DMAR_MTRRCAP_REG 0x100	/* MTRR capability register */
+ #define DMAR_MTRRDEF_REG 0x108	/* MTRR default type register */
+ #define DMAR_MTRR_FIX64K_00000_REG 0x120 /* MTRR Fixed range registers */
+ #define DMAR_MTRR_FIX16K_80000_REG 0x128
+ #define DMAR_MTRR_FIX16K_A0000_REG 0x130
+ #define DMAR_MTRR_FIX4K_C0000_REG 0x138
+ #define DMAR_MTRR_FIX4K_C8000_REG 0x140
+ #define DMAR_MTRR_FIX4K_D0000_REG 0x148
+ #define DMAR_MTRR_FIX4K_D8000_REG 0x150
+ #define DMAR_MTRR_FIX4K_E0000_REG 0x158
+ #define DMAR_MTRR_FIX4K_E8000_REG 0x160
+ #define DMAR_MTRR_FIX4K_F0000_REG 0x168
+ #define DMAR_MTRR_FIX4K_F8000_REG 0x170
+ #define DMAR_MTRR_PHYSBASE0_REG 0x180 /* MTRR Variable range registers */
+ #define DMAR_MTRR_PHYSMASK0_REG 0x188
+ #define DMAR_MTRR_PHYSBASE1_REG 0x190
+ #define DMAR_MTRR_PHYSMASK1_REG 0x198
+ #define DMAR_MTRR_PHYSBASE2_REG 0x1a0
+ #define DMAR_MTRR_PHYSMASK2_REG 0x1a8
+ #define DMAR_MTRR_PHYSBASE3_REG 0x1b0
+ #define DMAR_MTRR_PHYSMASK3_REG 0x1b8
+ #define DMAR_MTRR_PHYSBASE4_REG 0x1c0
+ #define DMAR_MTRR_PHYSMASK4_REG 0x1c8
+ #define DMAR_MTRR_PHYSBASE5_REG 0x1d0
+ #define DMAR_MTRR_PHYSMASK5_REG 0x1d8
+ #define DMAR_MTRR_PHYSBASE6_REG 0x1e0
+ #define DMAR_MTRR_PHYSMASK6_REG 0x1e8
+ #define DMAR_MTRR_PHYSBASE7_REG 0x1f0
+ #define DMAR_MTRR_PHYSMASK7_REG 0x1f8
+ #define DMAR_MTRR_PHYSBASE8_REG 0x200
+ #define DMAR_MTRR_PHYSMASK8_REG 0x208
+ #define DMAR_MTRR_PHYSBASE9_REG 0x210
+ #define DMAR_MTRR_PHYSMASK9_REG 0x218
+ #define DMAR_VCCAP_REG		0xe00 /* Virtual command capability register */
+ #define DMAR_VCMD_REG		0xe10 /* Virtual command register */
+ #define DMAR_VCRSP_REG		0xe20 /* Virtual command response register */
++>>>>>>> 4a2d80dbadb7 (iommu/vt-d: Update register definitions to VT-d 3.0 specification)
  
  #define OFFSET_STRIDE		(9)
 +/*
 +#define dmar_readl(dmar, reg) readl(dmar + reg)
 +#define dmar_readq(dmar, reg) ({ \
 +		u32 lo, hi; \
 +		lo = readl(dmar + reg); \
 +		hi = readl(dmar + reg + 4); \
 +		(((u64) hi) << 32) + lo; })
 +*/
 +static inline u64 dmar_readq(void __iomem *addr)
 +{
 +	u32 lo, hi;
 +	lo = readl(addr);
 +	hi = readl(addr + 4);
 +	return (((u64) hi) << 32) + lo;
 +}
  
 -#define dmar_readq(a) readq(a)
 -#define dmar_writeq(a,v) writeq(v,a)
 +static inline void dmar_writeq(void __iomem *addr, u64 val)
 +{
 +	writel((u32)val, addr);
 +	writel((u32)(val >> 32), addr + 4);
 +}
  
  #define DMAR_VER_MAJOR(v)		(((v) & 0xf0) >> 4)
  #define DMAR_VER_MINOR(v)		((v) & 0x0f)
* Unmerged path include/linux/intel-iommu.h
