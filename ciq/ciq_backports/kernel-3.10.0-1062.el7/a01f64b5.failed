ovl: document NFS export

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit a01f64b5c06ca1130b0b72ceb5e2a25e4d37ab08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a01f64b5.failed

Document NFS export design.
Followup patches will implement this design.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit a01f64b5c06ca1130b0b72ceb5e2a25e4d37ab08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/filesystems/overlayfs.txt
diff --cc Documentation/filesystems/overlayfs.txt
index 213547cb6d36,6ea1e64d1464..000000000000
--- a/Documentation/filesystems/overlayfs.txt
+++ b/Documentation/filesystems/overlayfs.txt
@@@ -190,6 -190,20 +190,23 @@@ Mount options
      Redirects are not created and not followed (equivalent to "redirect_dir=off"
      if "redirect_always_follow" feature is not enabled).
  
++<<<<<<< HEAD
++=======
+ When the NFS export feature is enabled, every copied up directory is
+ indexed by the file handle of the lower inode and a file handle of the
+ upper directory is stored in a "trusted.overlay.upper" extended attribute
+ on the index entry.  On lookup of a merged directory, if the upper
+ directory does not match the file handle stores in the index, that is an
+ indication that multiple upper directories may be redirected to the same
+ lower directory.  In that case, lookup returns an error and warns about
+ a possible inconsistency.
+ 
+ Because lower layer redirects cannot be verified with the index, enabling
+ NFS export support on an overlay filesystem with no upper layer requires
+ turning off redirect follow (e.g. "redirect_dir=nofollow").
+ 
+ 
++>>>>>>> a01f64b5c06c (ovl: document NFS export)
  Non-directories
  ---------------
  
@@@ -299,6 -313,92 +316,95 @@@ filesystem are not allowed.  If the und
  the behavior of the overlay is undefined, though it will not result in
  a crash or deadlock.
  
++<<<<<<< HEAD
++=======
+ When the overlay NFS export feature is enabled, overlay filesystems
+ behavior on offline changes of the underlying lower layer is different
+ than the behavior when NFS export is disabled.
+ 
+ On every copy_up, an NFS file handle of the lower inode, along with the
+ UUID of the lower filesystem, are encoded and stored in an extended
+ attribute "trusted.overlay.origin" on the upper inode.
+ 
+ When the NFS export feature is enabled, a lookup of a merged directory,
+ that found a lower directory at the lookup path or at the path pointed
+ to by the "trusted.overlay.redirect" extended attribute, will verify
+ that the found lower directory file handle and lower filesystem UUID
+ match the origin file handle that was stored at copy_up time.  If a
+ found lower directory does not match the stored origin, that directory
+ will not be merged with the upper directory.
+ 
+ 
+ 
+ NFS export
+ ----------
+ 
+ When the underlying filesystems supports NFS export and the "nfs_export"
+ feature is enabled, an overlay filesystem may be exported to NFS.
+ 
+ With the "nfs_export" feature, on copy_up of any lower object, an index
+ entry is created under the index directory.  The index entry name is the
+ hexadecimal representation of the copy up origin file handle.  For a
+ non-directory object, the index entry is a hard link to the upper inode.
+ For a directory object, the index entry has an extended attribute
+ "trusted.overlay.upper" with an encoded file handle of the upper
+ directory inode.
+ 
+ When encoding a file handle from an overlay filesystem object, the
+ following rules apply:
+ 
+ 1. For a non-upper object, encode a lower file handle from lower inode
+ 2. For an indexed object, encode a lower file handle from copy_up origin
+ 3. For a pure-upper object and for an existing non-indexed upper object,
+    encode an upper file handle from upper inode
+ 
+ The encoded overlay file handle includes:
+  - Header including path type information (e.g. lower/upper)
+  - UUID of the underlying filesystem
+  - Underlying filesystem encoding of underlying inode
+ 
+ This encoding format is identical to the encoding format file handles that
+ are stored in extended attribute "trusted.overlay.origin".
+ 
+ When decoding an overlay file handle, the following steps are followed:
+ 
+ 1. Find underlying layer by UUID and path type information.
+ 2. Decode the underlying filesystem file handle to underlying dentry.
+ 3. For a lower file handle, lookup the handle in index directory by name.
+ 4. If a whiteout is found in index, return ESTALE. This represents an
+    overlay object that was deleted after its file handle was encoded.
+ 5. For a non-directory, instantiate a disconnected overlay dentry from the
+    decoded underlying dentry, the path type and index inode, if found.
+ 6. For a directory, use the connected underlying decoded dentry, path type
+    and index, to lookup a connected overlay dentry.
+ 
+ Decoding a non-directory file handle may return a disconnected dentry.
+ copy_up of that disconnected dentry will create an upper index entry with
+ no upper alias.
+ 
+ When overlay filesystem has multiple lower layers, a middle layer
+ directory may have a "redirect" to lower directory.  Because middle layer
+ "redirects" are not indexed, a lower file handle that was encoded from the
+ "redirect" origin directory, cannot be used to find the middle or upper
+ layer directory.  Similarly, a lower file handle that was encoded from a
+ descendant of the "redirect" origin directory, cannot be used to
+ reconstruct a connected overlay path.  To mitigate the cases of
+ directories that cannot be decoded from a lower file handle, these
+ directories are copied up on encode and encoded as an upper file handle.
+ On an overlay filesystem with no upper layer this mitigation cannot be
+ used NFS export in this setup requires turning off redirect follow (e.g.
+ "redirect_dir=nofollow").
+ 
+ The overlay filesystem does not support non-directory connectable file
+ handles, so exporting with the 'subtree_check' exportfs configuration will
+ cause failures to lookup files over NFS.
+ 
+ When the NFS export feature is enabled, all directory index entries are
+ verified on mount time to check that upper file handles are not stale.
+ This verification may cause significant overhead in some cases.
+ 
+ 
++>>>>>>> a01f64b5c06c (ovl: document NFS export)
  Testsuite
  ---------
  
* Unmerged path Documentation/filesystems/overlayfs.txt
