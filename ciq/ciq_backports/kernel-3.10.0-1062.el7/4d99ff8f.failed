fuse: Turn writeback cache on

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Pavel Emelyanov <xemul@openvz.org>
commit 4d99ff8f12eb20c6cde292f185cb1c8c334ba0ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4d99ff8f.failed

Introduce a bit kernel and userspace exchange between each-other on
the init stage and turn writeback on if the userspace want this and
mount option 'allow_wbcache' is present (controlled by fusermount).

Also add each writable file into per-inode write list and call the
generic_file_aio_write to make use of the Linux page cache engine.

	Signed-off-by: Maxim Patlasov <MPatlasov@parallels.com>
	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit 4d99ff8f12eb20c6cde292f185cb1c8c334ba0ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/fuse.h
diff --cc include/uapi/linux/fuse.h
index 5d0f06afda03,cf4750e1bb49..000000000000
--- a/include/uapi/linux/fuse.h
+++ b/include/uapi/linux/fuse.h
@@@ -96,14 -96,6 +96,17 @@@
   *
   * 7.23
   *  - add FUSE_WRITEBACK_CACHE
++<<<<<<< HEAD
 + *  - add time_gran to fuse_init_out
 + *  - add reserved space to fuse_init_out
 + *  - add FATTR_CTIME
 + *  - add ctime and ctimensec to fuse_setattr_in
 + *  - add FUSE_RENAME2 request
 + *
 + *  7.24
 + *  - add FUSE_LSEEK for SEEK_HOLE and SEEK_DATA support
++=======
++>>>>>>> 4d99ff8f12eb (fuse: Turn writeback cache on)
   */
  
  #ifndef _LINUX_FUSE_H
diff --git a/fs/fuse/file.c b/fs/fuse/file.c
index 4f1b55e6b812..4a31a5c8fbeb 100644
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@ -224,6 +224,8 @@ void fuse_finish_open(struct inode *inode, struct file *file)
 		spin_unlock(&fc->lock);
 		fuse_invalidate_attr(inode);
 	}
+	if ((file->f_mode & FMODE_WRITE) && fc->writeback_cache)
+		fuse_link_write_file(file);
 }
 
 int fuse_open_common(struct inode *inode, struct file *file, bool isdir)
@@ -1175,6 +1177,15 @@ static ssize_t fuse_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 	struct iov_iter i;
 	loff_t endbyte = 0;
 
+	if (get_fuse_conn(inode)->writeback_cache) {
+		/* Update size (EOF optimization) and mode (SUID clearing) */
+		err = fuse_update_attributes(mapping->host, NULL, file, NULL);
+		if (err)
+			return err;
+
+		return generic_file_aio_write(iocb, iov, nr_segs, pos);
+	}
+
 	WARN_ON(iocb->ki_pos != pos);
 
 	ocount = 0;
diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c
index 4fc9c23e42fa..605391f30afa 100644
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@ -885,6 +885,8 @@ static void process_init_reply(struct fuse_conn *fc, struct fuse_req *req)
 			}
 			if (arg->flags & FUSE_ASYNC_DIO)
 				fc->async_dio = 1;
+			if (arg->flags & FUSE_WRITEBACK_CACHE)
+				fc->writeback_cache = 1;
 		} else {
 			ra_pages = fc->max_read / PAGE_CACHE_SIZE;
 			fc->no_lock = 1;
@@ -912,7 +914,8 @@ static void fuse_send_init(struct fuse_conn *fc, struct fuse_req *req)
 		FUSE_EXPORT_SUPPORT | FUSE_BIG_WRITES | FUSE_DONT_MASK |
 		FUSE_SPLICE_WRITE | FUSE_SPLICE_MOVE | FUSE_SPLICE_READ |
 		FUSE_FLOCK_LOCKS | FUSE_IOCTL_DIR | FUSE_AUTO_INVAL_DATA |
-		FUSE_DO_READDIRPLUS | FUSE_READDIRPLUS_AUTO | FUSE_ASYNC_DIO;
+		FUSE_DO_READDIRPLUS | FUSE_READDIRPLUS_AUTO | FUSE_ASYNC_DIO |
+		FUSE_WRITEBACK_CACHE;
 	req->in.h.opcode = FUSE_INIT;
 	req->in.numargs = 1;
 	req->in.args[0].size = sizeof(*arg);
* Unmerged path include/uapi/linux/fuse.h
