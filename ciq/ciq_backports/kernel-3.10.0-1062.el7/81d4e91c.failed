macvlan: Use software path for offloaded local, broadcast, and multicast traffic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Alexander Duyck <alexander.h.duyck@intel.com>
commit 81d4e91cd599ed7fd378ca5463d6d9b05214b8b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/81d4e91c.failed

This change makes it so that we use a software path for packets that are
going to be locally switched between two macvlan interfaces on the same
device. In addition we resort to software replication of broadcast and
multicast packets instead of offloading that to hardware.

The general idea is that using the device for east/west traffic local to
the system is extremely inefficient. We can only support up to whatever the
PCIe limit is for any given device so this caps us at somewhere around 20G
for devices supported by ixgbe. This is compounded even further when you
take broadcast and multicast into account as a single 10G port can come to
a crawl as a packet is replicated up to 60+ times in some cases. In order
to get away from that I am implementing changes so that we handle
broadcast/multicast replication and east/west local traffic all in
software.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 81d4e91cd599ed7fd378ca5463d6d9b05214b8b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/macvlan.c
diff --cc drivers/net/macvlan.c
index f1b5a8c2df9b,adde8fc45588..000000000000
--- a/drivers/net/macvlan.c
+++ b/drivers/net/macvlan.c
@@@ -358,27 -534,41 +359,41 @@@ static int macvlan_queue_xmit(struct sk
  		}
  	}
  
+ 	/* For packets that are non-multicast and not bridged we will pass
+ 	 * the necessary information so that the lowerdev can distinguish
+ 	 * the source of the packets via the accel_priv value.
+ 	 */
+ 	accel_priv = vlan->accel_priv;
  xmit_world:
  	skb->dev = vlan->lowerdev;
- 	return dev_queue_xmit(skb);
+ 	return dev_queue_xmit_accel(skb, accel_priv);
  }
  
 -static inline netdev_tx_t macvlan_netpoll_send_skb(struct macvlan_dev *vlan, struct sk_buff *skb)
 -{
 -#ifdef CONFIG_NET_POLL_CONTROLLER
 -	if (vlan->netpoll)
 -		netpoll_send_skb(vlan->netpoll, skb);
 -#else
 -	BUG();
 -#endif
 -	return NETDEV_TX_OK;
 -}
 -
 -static netdev_tx_t macvlan_start_xmit(struct sk_buff *skb,
 -				      struct net_device *dev)
 +netdev_tx_t macvlan_start_xmit(struct sk_buff *skb,
 +			       struct net_device *dev)
  {
+ 	struct macvlan_dev *vlan = netdev_priv(dev);
  	unsigned int len = skb->len;
  	int ret;
++<<<<<<< HEAD
 +	const struct macvlan_dev *vlan = netdev_priv(dev);
 +
 +	if (vlan->fwd_priv) {
 +		skb->dev = vlan->lowerdev;
 +		ret = dev_queue_xmit_accel(skb, vlan->fwd_priv);
 +	} else {
 +		ret = macvlan_queue_xmit(skb, dev);
 +	}
++=======
+ 
+ 	if (unlikely(netpoll_tx_running(dev)))
+ 		return macvlan_netpoll_send_skb(vlan, skb);
+ 
+ 	ret = macvlan_queue_xmit(skb, dev);
++>>>>>>> 81d4e91cd599 (macvlan: Use software path for offloaded local, broadcast, and multicast traffic)
  
  	if (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {
 -		struct vlan_pcpu_stats *pcpu_stats;
 +		struct macvlan_pcpu_stats *pcpu_stats;
  
  		pcpu_stats = this_cpu_ptr(vlan->pcpu_stats);
  		u64_stats_update_begin(&pcpu_stats->syncp);
@@@ -423,26 -614,27 +438,41 @@@ static int macvlan_open(struct net_devi
  		goto hash_add;
  	}
  
++<<<<<<< HEAD
 +	if (lowerdev->features & NETIF_F_HW_L2FW_DOFFLOAD) {
 +		vlan->fwd_priv =
 +		      get_ndo_ext(lowerdev->netdev_ops, ndo_dfwd_add_station)(lowerdev, dev);
 +
 +		/* If we get a NULL pointer back, or if we get an error
 +		 * then we should just fall through to the non accelerated path
 +		 */
 +		if (IS_ERR_OR_NULL(vlan->fwd_priv)) {
 +			vlan->fwd_priv = NULL;
 +		} else
 +			return 0;
- 	}
- 
++=======
  	err = -EBUSY;
  	if (macvlan_addr_busy(vlan->port, dev->dev_addr))
  		goto out;
  
- 	err = dev_uc_add(lowerdev, dev->dev_addr);
- 	if (err < 0)
- 		goto out;
+ 	/* Attempt to populate accel_priv which is used to offload the L2
+ 	 * forwarding requests for unicast packets.
+ 	 */
+ 	if (lowerdev->features & NETIF_F_HW_L2FW_DOFFLOAD)
+ 		vlan->accel_priv =
+ 		      lowerdev->netdev_ops->ndo_dfwd_add_station(lowerdev, dev);
+ 
+ 	/* If earlier attempt to offload failed, or accel_priv is not
+ 	 * populated we must add the unicast address to the lower device.
+ 	 */
+ 	if (IS_ERR_OR_NULL(vlan->accel_priv)) {
+ 		vlan->accel_priv = NULL;
+ 		err = dev_uc_add(lowerdev, dev->dev_addr);
+ 		if (err < 0)
+ 			goto out;
++>>>>>>> 81d4e91cd599 (macvlan: Use software path for offloaded local, broadcast, and multicast traffic)
+ 	}
+ 
  	if (dev->flags & IFF_ALLMULTI) {
  		err = dev_set_allmulti(lowerdev, 1);
  		if (err < 0)
@@@ -453,14 -651,18 +483,24 @@@ hash_add
  	macvlan_hash_add(vlan);
  	return 0;
  
 -clear_multi:
 -	if (dev->flags & IFF_ALLMULTI)
 -		dev_set_allmulti(lowerdev, -1);
  del_unicast:
++<<<<<<< HEAD
 +	dev_uc_del(lowerdev, dev->dev_addr);
 +out:
 +	if (vlan->fwd_priv) {
 +		get_ndo_ext(lowerdev->netdev_ops, ndo_dfwd_del_station)(lowerdev,
 +									vlan->fwd_priv);
 +		vlan->fwd_priv = NULL;
++=======
+ 	if (vlan->accel_priv) {
+ 		lowerdev->netdev_ops->ndo_dfwd_del_station(lowerdev,
+ 							   vlan->accel_priv);
+ 		vlan->accel_priv = NULL;
+ 	} else {
+ 		dev_uc_del(lowerdev, dev->dev_addr);
++>>>>>>> 81d4e91cd599 (macvlan: Use software path for offloaded local, broadcast, and multicast traffic)
  	}
+ out:
  	return err;
  }
  
@@@ -469,11 -671,10 +509,18 @@@ static int macvlan_stop(struct net_devi
  	struct macvlan_dev *vlan = netdev_priv(dev);
  	struct net_device *lowerdev = vlan->lowerdev;
  
++<<<<<<< HEAD
 +	if (vlan->fwd_priv) {
 +		get_ndo_ext(lowerdev->netdev_ops, ndo_dfwd_del_station)(lowerdev,
 +									vlan->fwd_priv);
 +		vlan->fwd_priv = NULL;
 +		return 0;
++=======
+ 	if (vlan->accel_priv) {
+ 		lowerdev->netdev_ops->ndo_dfwd_del_station(lowerdev,
+ 							   vlan->accel_priv);
+ 		vlan->accel_priv = NULL;
++>>>>>>> 81d4e91cd599 (macvlan: Use software path for offloaded local, broadcast, and multicast traffic)
  	}
  
  	dev_uc_unsync(lowerdev, dev);
diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c b/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
index e1ec83de2867..70a15c5b9e08 100644
--- a/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
@@ -1226,7 +1226,7 @@ void fm10k_restore_rx_state(struct fm10k_intfc *interface)
 			glort = l2_accel->dglort + 1 + i;
 
 			hw->mac.ops.update_xcast_mode(hw, glort,
-						      FM10K_XCAST_MODE_MULTI);
+						      FM10K_XCAST_MODE_NONE);
 			fm10k_queue_mac_request(interface, glort,
 						sdev->dev_addr,
 						hw->mac.default_vid, true);
@@ -1488,7 +1488,7 @@ static void *fm10k_dfwd_add_station(struct net_device *dev,
 
 	if (fm10k_host_mbx_ready(interface)) {
 		hw->mac.ops.update_xcast_mode(hw, glort,
-					      FM10K_XCAST_MODE_MULTI);
+					      FM10K_XCAST_MODE_NONE);
 		fm10k_queue_mac_request(interface, glort, sdev->dev_addr,
 					hw->mac.default_vid, true);
 	}
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index bfe98ae4c752..fb6d13b8dcd9 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -4165,7 +4165,8 @@ static void ixgbe_setup_psrtype(struct ixgbe_adapter *adapter)
 static void ixgbe_configure_virtualization(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
-	u32 reg_offset, vf_shift;
+	u16 pool = adapter->num_rx_pools;
+	u32 reg_offset, vf_shift, vmolr;
 	u32 gcr_ext, vmdctl;
 	int i;
 
@@ -4179,6 +4180,13 @@ static void ixgbe_configure_virtualization(struct ixgbe_adapter *adapter)
 	vmdctl |= IXGBE_VT_CTL_REPLEN;
 	IXGBE_WRITE_REG(hw, IXGBE_VT_CTL, vmdctl);
 
+	/* accept untagged packets until a vlan tag is
+	 * specifically set for the VMDQ queue/pool
+	 */
+	vmolr = IXGBE_VMOLR_AUPE;
+	while (pool--)
+		IXGBE_WRITE_REG(hw, IXGBE_VMOLR(VMDQ_P(pool)), vmolr);
+
 	vf_shift = VMDQ_P(0) % 32;
 	reg_offset = (VMDQ_P(0) >= 32) ? 1 : 0;
 
@@ -5225,28 +5233,6 @@ static void ixgbe_fdir_filter_restore(struct ixgbe_adapter *adapter)
 	spin_unlock(&adapter->fdir_perfect_lock);
 }
 
-static void ixgbe_macvlan_set_rx_mode(struct net_device *dev, unsigned int pool,
-				      struct ixgbe_adapter *adapter)
-{
-	struct ixgbe_hw *hw = &adapter->hw;
-	u32 vmolr;
-
-	/* No unicast promiscuous support for VMDQ devices. */
-	vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(pool));
-	vmolr |= (IXGBE_VMOLR_ROMPE | IXGBE_VMOLR_BAM | IXGBE_VMOLR_AUPE);
-
-	/* clear the affected bit */
-	vmolr &= ~IXGBE_VMOLR_MPE;
-
-	if (dev->flags & IFF_ALLMULTI) {
-		vmolr |= IXGBE_VMOLR_MPE;
-	} else {
-		vmolr |= IXGBE_VMOLR_ROMPE;
-		hw->mac.ops.update_mc_addr_list(hw, dev);
-	}
-	IXGBE_WRITE_REG(hw, IXGBE_VMOLR(pool), vmolr);
-}
-
 /**
  * ixgbe_clean_rx_ring - Free Rx Buffers per Queue
  * @rx_ring: ring to free buffers from
@@ -5334,10 +5320,8 @@ static int ixgbe_fwd_ring_up(struct net_device *vdev,
 	 */
 	err = ixgbe_add_mac_filter(adapter, vdev->dev_addr,
 				   VMDQ_P(accel->pool));
-	if (err >= 0) {
-		ixgbe_macvlan_set_rx_mode(vdev, accel->pool, adapter);
+	if (err >= 0)
 		return 0;
-	}
 
 	for (i = 0; i < adapter->num_rx_queues_per_pool; i++)
 		adapter->rx_ring[baseq + i]->netdev = NULL;
@@ -9790,9 +9774,6 @@ static void ixgbe_fwd_del(struct net_device *pdev, void *priv)
 	ixgbe_del_mac_filter(adapter, accel->netdev->dev_addr,
 			     VMDQ_P(accel->pool));
 
-	/* disable ability to receive packets for this pool */
-	IXGBE_WRITE_REG(&adapter->hw, IXGBE_VMOLR(accel->pool), 0);
-
 	/* Allow remaining Rx packets to get flushed out of the
 	 * Rx FIFO before we drop the netdev for the ring.
 	 */
* Unmerged path drivers/net/macvlan.c
