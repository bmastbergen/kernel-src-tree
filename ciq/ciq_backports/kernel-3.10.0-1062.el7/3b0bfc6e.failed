ovl: decode indexed dir file handles

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 3b0bfc6ed3c434800e5eacfb6cdbe45c07c270e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3b0bfc6e.failed

Decoding an indexed dir file handle is done by looking up the file handle
in index dir by name and then decoding the upper dir from the index origin
file handle. The decoded upper path is used to lookup an overlay dentry of
the same path.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 3b0bfc6ed3c434800e5eacfb6cdbe45c07c270e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/export.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
diff --cc fs/overlayfs/namei.c
index 5e444838b3c6,6199bf7a77c7..000000000000
--- a/fs/overlayfs/namei.c
+++ b/fs/overlayfs/namei.c
@@@ -378,6 -438,41 +378,44 @@@ fail
  	goto out;
  }
  
++<<<<<<< HEAD
++=======
+ /* Get upper dentry from index */
+ struct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index)
+ {
+ 	struct ovl_fh *fh;
+ 	struct dentry *upper;
+ 
+ 	if (!d_is_dir(index))
+ 		return dget(index);
+ 
+ 	fh = ovl_get_fh(index, OVL_XATTR_UPPER);
+ 	if (IS_ERR_OR_NULL(fh))
+ 		return ERR_CAST(fh);
+ 
+ 	upper = ovl_decode_fh(fh, ofs->upper_mnt);
+ 	kfree(fh);
+ 
+ 	if (IS_ERR_OR_NULL(upper))
+ 		return upper ?: ERR_PTR(-ESTALE);
+ 
+ 	if (!d_is_dir(upper)) {
+ 		pr_warn_ratelimited("overlayfs: invalid index upper (%pd2, upper=%pd2).\n",
+ 				    index, upper);
+ 		dput(upper);
+ 		return ERR_PTR(-EIO);
+ 	}
+ 
+ 	return upper;
+ }
+ 
+ /* Is this a leftover from create/whiteout of directory index entry? */
+ static bool ovl_is_temp_index(struct dentry *index)
+ {
+ 	return index->d_name.name[0] == '#';
+ }
+ 
++>>>>>>> 3b0bfc6ed3c4 (ovl: decode indexed dir file handles)
  /*
   * Verify that an index entry name matches the origin file handle stored in
   * OVL_XATTR_ORIGIN and that origin file handle can be decoded to lower path.
diff --cc fs/overlayfs/overlayfs.h
index 403c48960f89,a5d415aec131..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -247,15 -264,33 +247,26 @@@ static inline bool ovl_is_impuredir(str
  
  
  /* namei.c */
++<<<<<<< HEAD
 +int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 +		      struct dentry *origin, bool is_upper, bool set);
 +int ovl_verify_index(struct dentry *index, struct path *lowerstack,
 +		     unsigned int numlower);
++=======
+ int ovl_check_fh_len(struct ovl_fh *fh, int fh_len);
+ struct dentry *ovl_decode_fh(struct ovl_fh *fh, struct vfsmount *mnt);
+ int ovl_check_origin_fh(struct ovl_fs *ofs, struct ovl_fh *fh,
+ 			struct dentry *upperdentry, struct ovl_path **stackp);
+ int ovl_verify_set_fh(struct dentry *dentry, const char *name,
+ 		      struct dentry *real, bool is_upper, bool set);
+ struct dentry *ovl_index_upper(struct ovl_fs *ofs, struct dentry *index);
+ int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
++>>>>>>> 3b0bfc6ed3c4 (ovl: decode indexed dir file handles)
  int ovl_get_index_name(struct dentry *origin, struct qstr *name);
 -struct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh);
  int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 -struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 -			  unsigned int flags);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
  bool ovl_lower_positive(struct dentry *dentry);
  
 -static inline int ovl_verify_origin(struct dentry *upper,
 -				    struct dentry *origin, bool set)
 -{
 -	return ovl_verify_set_fh(upper, OVL_XATTR_ORIGIN, origin, false, set);
 -}
 -
 -static inline int ovl_verify_upper(struct dentry *index,
 -				    struct dentry *upper, bool set)
 -{
 -	return ovl_verify_set_fh(index, OVL_XATTR_UPPER, upper, true, set);
 -}
 -
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
  int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
