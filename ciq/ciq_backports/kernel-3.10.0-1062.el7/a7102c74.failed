ipmi: msghandler: Fix potential Spectre v1 vulnerabilities

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Gustavo A. R. Silva <gustavo@embeddedor.com>
commit a7102c7461794a5bb31af24b08e9e0f50038897a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a7102c74.failed

channel and addr->channel are indirectly controlled by user-space,
hence leading to a potential exploitation of the Spectre variant 1
vulnerability.

These issues were detected with the help of Smatch:

drivers/char/ipmi/ipmi_msghandler.c:1381 ipmi_set_my_address() warn: potential spectre issue 'user->intf->addrinfo' [w] (local cap)
drivers/char/ipmi/ipmi_msghandler.c:1401 ipmi_get_my_address() warn: potential spectre issue 'user->intf->addrinfo' [r] (local cap)
drivers/char/ipmi/ipmi_msghandler.c:1421 ipmi_set_my_LUN() warn: potential spectre issue 'user->intf->addrinfo' [w] (local cap)
drivers/char/ipmi/ipmi_msghandler.c:1441 ipmi_get_my_LUN() warn: potential spectre issue 'user->intf->addrinfo' [r] (local cap)
drivers/char/ipmi/ipmi_msghandler.c:2260 check_addr() warn: potential spectre issue 'intf->addrinfo' [r] (local cap)

Fix this by sanitizing channel and addr->channel before using them to
index user->intf->addrinfo and intf->addrinfo, correspondingly.

Notice that given that speculation windows are large, the policy is
to kill the speculation on the first load and not worry if it can be
completed with a dependent load/store [1].

[1] https://lore.kernel.org/lkml/20180423164740.GY17484@dhcp22.suse.cz/

	Cc: stable@vger.kernel.org
	Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit a7102c7461794a5bb31af24b08e9e0f50038897a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_msghandler.c
diff --cc drivers/char/ipmi/ipmi_msghandler.c
index 5b5cc5cd2796,7a9fbe60a840..000000000000
--- a/drivers/char/ipmi/ipmi_msghandler.c
+++ b/drivers/char/ipmi/ipmi_msghandler.c
@@@ -49,11 -32,8 +49,12 @@@
  #include <linux/moduleparam.h>
  #include <linux/workqueue.h>
  #include <linux/uuid.h>
+ #include <linux/nospec.h>
  
 +#include <linux/rh_kabi.h>
 +
 +#define PFX "IPMI message handler: "
 +
  #define IPMI_DRIVER_VERSION "39.2"
  
  static struct ipmi_recv_msg *ipmi_alloc_recv_msg(void);
@@@ -1347,10 -1293,21 +1348,28 @@@ int ipmi_set_my_address(ipmi_user_t   u
  			unsigned int  channel,
  			unsigned char address)
  {
++<<<<<<< HEAD
 +	if (channel >= IPMI_MAX_CHANNELS)
 +		return -EINVAL;
 +	user->intf->addrinfo[channel].address = address;
 +	return 0;
++=======
+ 	int index, rv = 0;
+ 
+ 	user = acquire_ipmi_user(user, &index);
+ 	if (!user)
+ 		return -ENODEV;
+ 
+ 	if (channel >= IPMI_MAX_CHANNELS) {
+ 		rv = -EINVAL;
+ 	} else {
+ 		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
+ 		user->intf->addrinfo[channel].address = address;
+ 	}
+ 	release_ipmi_user(user, index);
+ 
+ 	return rv;
++>>>>>>> a7102c746179 (ipmi: msghandler: Fix potential Spectre v1 vulnerabilities)
  }
  EXPORT_SYMBOL(ipmi_set_my_address);
  
@@@ -1358,10 -1315,21 +1377,28 @@@ int ipmi_get_my_address(ipmi_user_t   u
  			unsigned int  channel,
  			unsigned char *address)
  {
++<<<<<<< HEAD
 +	if (channel >= IPMI_MAX_CHANNELS)
 +		return -EINVAL;
 +	*address = user->intf->addrinfo[channel].address;
 +	return 0;
++=======
+ 	int index, rv = 0;
+ 
+ 	user = acquire_ipmi_user(user, &index);
+ 	if (!user)
+ 		return -ENODEV;
+ 
+ 	if (channel >= IPMI_MAX_CHANNELS) {
+ 		rv = -EINVAL;
+ 	} else {
+ 		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
+ 		*address = user->intf->addrinfo[channel].address;
+ 	}
+ 	release_ipmi_user(user, index);
+ 
+ 	return rv;
++>>>>>>> a7102c746179 (ipmi: msghandler: Fix potential Spectre v1 vulnerabilities)
  }
  EXPORT_SYMBOL(ipmi_get_my_address);
  
@@@ -1369,10 -1337,21 +1406,28 @@@ int ipmi_set_my_LUN(ipmi_user_t   user
  		    unsigned int  channel,
  		    unsigned char LUN)
  {
++<<<<<<< HEAD
 +	if (channel >= IPMI_MAX_CHANNELS)
 +		return -EINVAL;
 +	user->intf->addrinfo[channel].lun = LUN & 0x3;
 +	return 0;
++=======
+ 	int index, rv = 0;
+ 
+ 	user = acquire_ipmi_user(user, &index);
+ 	if (!user)
+ 		return -ENODEV;
+ 
+ 	if (channel >= IPMI_MAX_CHANNELS) {
+ 		rv = -EINVAL;
+ 	} else {
+ 		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
+ 		user->intf->addrinfo[channel].lun = LUN & 0x3;
+ 	}
+ 	release_ipmi_user(user, index);
+ 
+ 	return rv;
++>>>>>>> a7102c746179 (ipmi: msghandler: Fix potential Spectre v1 vulnerabilities)
  }
  EXPORT_SYMBOL(ipmi_set_my_LUN);
  
@@@ -1380,10 -1359,21 +1435,28 @@@ int ipmi_get_my_LUN(ipmi_user_t   user
  		    unsigned int  channel,
  		    unsigned char *address)
  {
++<<<<<<< HEAD
 +	if (channel >= IPMI_MAX_CHANNELS)
 +		return -EINVAL;
 +	*address = user->intf->addrinfo[channel].lun;
 +	return 0;
++=======
+ 	int index, rv = 0;
+ 
+ 	user = acquire_ipmi_user(user, &index);
+ 	if (!user)
+ 		return -ENODEV;
+ 
+ 	if (channel >= IPMI_MAX_CHANNELS) {
+ 		rv = -EINVAL;
+ 	} else {
+ 		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
+ 		*address = user->intf->addrinfo[channel].lun;
+ 	}
+ 	release_ipmi_user(user, index);
+ 
+ 	return rv;
++>>>>>>> a7102c746179 (ipmi: msghandler: Fix potential Spectre v1 vulnerabilities)
  }
  EXPORT_SYMBOL(ipmi_get_my_LUN);
  
* Unmerged path drivers/char/ipmi/ipmi_msghandler.c
