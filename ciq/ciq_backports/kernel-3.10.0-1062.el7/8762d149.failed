IB/uverbs: Add PTR_IN attributes that are allocated/copied automatically

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Matan Barak <matanb@mellanox.com>
commit 8762d149e88dea5bc09e0d7faa84b635807167ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/8762d149.failed

Adding UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY flag to PTR_IN attributes.
By using this flag, the parse automatically allocates and copies the
user-space data. This data is accessible by using uverbs_attr_get_len
and uverbs_attr_get_alloced_ptr inline accessor functions from the
handler.

	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 8762d149e88dea5bc09e0d7faa84b635807167ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/rdma/uverbs_ioctl.h
diff --cc include/rdma/uverbs_ioctl.h
index 3d6ac684b8f0,11cc40ef1cb6..000000000000
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@@ -408,6 -419,40 +419,43 @@@ static inline int uverbs_attr_get_enum_
  	return attr->ptr_attr.enum_id;
  }
  
++<<<<<<< HEAD
++=======
+ static inline void *uverbs_attr_get_obj(const struct uverbs_attr_bundle *attrs_bundle,
+ 					u16 idx)
+ {
+ 	const struct uverbs_attr *attr;
+ 
+ 	attr = uverbs_attr_get(attrs_bundle, idx);
+ 	if (IS_ERR(attr))
+ 		return ERR_CAST(attr);
+ 
+ 	return attr->obj_attr.uobject->object;
+ }
+ 
+ static inline struct ib_uobject *uverbs_attr_get_uobject(const struct uverbs_attr_bundle *attrs_bundle,
+ 							 u16 idx)
+ {
+ 	const struct uverbs_attr *attr = uverbs_attr_get(attrs_bundle, idx);
+ 
+ 	if (IS_ERR(attr))
+ 		return ERR_CAST(attr);
+ 
+ 	return attr->obj_attr.uobject;
+ }
+ 
+ static inline int
+ uverbs_attr_get_len(const struct uverbs_attr_bundle *attrs_bundle, u16 idx)
+ {
+ 	const struct uverbs_attr *attr = uverbs_attr_get(attrs_bundle, idx);
+ 
+ 	if (IS_ERR(attr))
+ 		return PTR_ERR(attr);
+ 
+ 	return attr->ptr_attr.len;
+ }
+ 
++>>>>>>> 8762d149e88d (IB/uverbs: Add PTR_IN attributes that are allocated/copied automatically)
  static inline int uverbs_copy_to(const struct uverbs_attr_bundle *attrs_bundle,
  				 size_t idx, const void *from, size_t size)
  {
diff --git a/drivers/infiniband/core/uverbs_ioctl.c b/drivers/infiniband/core/uverbs_ioctl.c
index 0135132391cb..1d8c104d3f9a 100644
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@ -114,9 +114,27 @@ static int uverbs_process_attr(struct ib_device *ibdev,
 		    uattr->attr_data.reserved)
 			return -EINVAL;
 
-		e->ptr_attr.data = uattr->data;
 		e->ptr_attr.len = uattr->len;
 		e->ptr_attr.flags = uattr->flags;
+
+		if (val_spec->flags & UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY &&
+		    !uverbs_attr_ptr_is_inline(e)) {
+			void *p;
+
+			p = kvmalloc(uattr->len, GFP_KERNEL);
+			if (!p)
+				return -ENOMEM;
+
+			e->ptr_attr.ptr = p;
+
+			if (copy_from_user(p, u64_to_user_ptr(uattr->data),
+					   uattr->len)) {
+				kvfree(p);
+				return -EFAULT;
+			}
+		} else {
+			e->ptr_attr.data = uattr->data;
+		}
 		break;
 
 	case UVERBS_ATTR_TYPE_IDR:
@@ -200,6 +218,11 @@ static int uverbs_finalize_attrs(struct uverbs_attr_bundle *attrs_bundle,
 					spec->obj.access, commit);
 				if (!ret)
 					ret = current_ret;
+			} else if (spec->type == UVERBS_ATTR_TYPE_PTR_IN &&
+				   spec->flags &
+					   UVERBS_ATTR_SPEC_F_ALLOC_AND_COPY &&
+				   !uverbs_attr_ptr_is_inline(attr)) {
+				kvfree(attr->ptr_attr.ptr);
 			}
 		}
 	}
* Unmerged path include/rdma/uverbs_ioctl.h
