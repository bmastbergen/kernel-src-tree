KVM: x86: nSVM: fix switch to guest mmu

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 3cf85f9f6bd7b172122865432b4c6f0ec844e22a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/3cf85f9f.failed

Recent optimizations in MMU code broke nested SVM with NPT in L1
completely: when we do nested_svm_{,un}init_mmu_context() we want
to switch from TDP MMU to shadow MMU, both init_kvm_tdp_mmu() and
kvm_init_shadow_mmu() check if re-configuration is needed by looking
at cache source data. The data, however, doesn't change - it's only
the type of the MMU which changes. We end up not re-initializing
guest MMU as shadow and everything goes off the rails.

The issue could have been fixed by putting MMU type into extended MMU
role but this is not really needed. We can just split root and guest MMUs
the exact same way we did for nVMX, their types never change in the
lifetime of a vCPU.

There is still room for improvement: currently, we reset all MMU roots
when switching from L1 to L2 and back and this is not needed.

Fixes: 7dcd57552008 ("x86/kvm/mmu: check if tdp/shadow MMU reconfiguration is needed")
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 3cf85f9f6bd7b172122865432b4c6f0ec844e22a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm.c
diff --cc arch/x86/kvm/svm.c
index 2abd6b8af3db,101f53ccf571..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -2584,19 -2937,22 +2584,26 @@@ static void nested_svm_inject_npf_exit(
  static void nested_svm_init_mmu_context(struct kvm_vcpu *vcpu)
  {
  	WARN_ON(mmu_is_nested(vcpu));
+ 
+ 	vcpu->arch.mmu = &vcpu->arch.guest_mmu;
  	kvm_init_shadow_mmu(vcpu);
 -	vcpu->arch.mmu->set_cr3           = nested_svm_set_tdp_cr3;
 -	vcpu->arch.mmu->get_cr3           = nested_svm_get_tdp_cr3;
 -	vcpu->arch.mmu->get_pdptr         = nested_svm_get_tdp_pdptr;
 -	vcpu->arch.mmu->inject_page_fault = nested_svm_inject_npf_exit;
 -	vcpu->arch.mmu->shadow_root_level = get_npt_level(vcpu);
 -	reset_shadow_zero_bits_mask(vcpu, vcpu->arch.mmu);
 +	vcpu->arch.mmu.set_cr3           = nested_svm_set_tdp_cr3;
 +	vcpu->arch.mmu.get_cr3           = nested_svm_get_tdp_cr3;
 +	vcpu->arch.mmu.get_pdptr         = nested_svm_get_tdp_pdptr;
 +	vcpu->arch.mmu.inject_page_fault = nested_svm_inject_npf_exit;
 +	vcpu->arch.mmu.shadow_root_level = get_npt_level();
 +	reset_shadow_zero_bits_mask(vcpu, &vcpu->arch.mmu);
  	vcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;
  }
  
  static void nested_svm_uninit_mmu_context(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	vcpu->arch.walk_mmu = &vcpu->arch.mmu;
++=======
+ 	vcpu->arch.mmu = &vcpu->arch.root_mmu;
+ 	vcpu->arch.walk_mmu = &vcpu->arch.root_mmu;
++>>>>>>> 3cf85f9f6bd7 (KVM: x86: nSVM: fix switch to guest mmu)
  }
  
  static int nested_svm_check_permissions(struct vcpu_svm *svm)
* Unmerged path arch/x86/kvm/svm.c
