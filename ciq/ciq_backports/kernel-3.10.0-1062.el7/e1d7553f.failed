xfs: use xfs_bmap_del_extent_delay for the data fork as well

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit e1d7553faf3979df83a168ea4732f6f5255972a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e1d7553f.failed

And remove the delalloc code from xfs_bmap_del_extent, which gets renamed
to xfs_bmap_del_extent_real to fit the naming scheme used by the other
xfs_bmap_{add,del}_extent_* routines.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit e1d7553faf3979df83a168ea4732f6f5255972a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 7800126fabda,5b84fa933906..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -4660,12 -4841,228 +4660,12 @@@ xfs_bmap_split_indlen
  	return stolen;
  }
  
 -int
 -xfs_bmap_del_extent_delay(
 -	struct xfs_inode	*ip,
 -	int			whichfork,
 -	xfs_extnum_t		*idx,
 -	struct xfs_bmbt_irec	*got,
 -	struct xfs_bmbt_irec	*del)
 -{
 -	struct xfs_mount	*mp = ip->i_mount;
 -	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
 -	struct xfs_bmbt_irec	new;
 -	int64_t			da_old, da_new, da_diff = 0;
 -	xfs_fileoff_t		del_endoff, got_endoff;
 -	xfs_filblks_t		got_indlen, new_indlen, stolen;
 -	int			error = 0, state = 0;
 -	bool			isrt;
 -
 -	XFS_STATS_INC(mp, xs_del_exlist);
 -
 -	isrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);
 -	del_endoff = del->br_startoff + del->br_blockcount;
 -	got_endoff = got->br_startoff + got->br_blockcount;
 -	da_old = startblockval(got->br_startblock);
 -	da_new = 0;
 -
 -	ASSERT(*idx >= 0);
 -	ASSERT(*idx <= xfs_iext_count(ifp));
 -	ASSERT(del->br_blockcount > 0);
 -	ASSERT(got->br_startoff <= del->br_startoff);
 -	ASSERT(got_endoff >= del_endoff);
 -
 -	if (isrt) {
 -		uint64_t rtexts = XFS_FSB_TO_B(mp, del->br_blockcount);
 -
 -		do_div(rtexts, mp->m_sb.sb_rextsize);
 -		xfs_mod_frextents(mp, rtexts);
 -	}
 -
 -	/*
 -	 * Update the inode delalloc counter now and wait to update the
 -	 * sb counters as we might have to borrow some blocks for the
 -	 * indirect block accounting.
 -	 */
 -	error = xfs_trans_reserve_quota_nblks(NULL, ip,
 -			-((long)del->br_blockcount), 0,
 -			isrt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);
 -	if (error)
 -		return error;
 -	ip->i_delayed_blks -= del->br_blockcount;
 -
 -	if (whichfork == XFS_COW_FORK)
 -		state |= BMAP_COWFORK;
 -
 -	if (got->br_startoff == del->br_startoff)
 -		state |= BMAP_LEFT_CONTIG;
 -	if (got_endoff == del_endoff)
 -		state |= BMAP_RIGHT_CONTIG;
 -
 -	switch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {
 -	case BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:
 -		/*
 -		 * Matches the whole extent.  Delete the entry.
 -		 */
 -		xfs_iext_remove(ip, *idx, 1, state);
 -		--*idx;
 -		break;
 -	case BMAP_LEFT_CONTIG:
 -		/*
 -		 * Deleting the first part of the extent.
 -		 */
 -		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
 -		got->br_startoff = del_endoff;
 -		got->br_blockcount -= del->br_blockcount;
 -		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
 -				got->br_blockcount), da_old);
 -		got->br_startblock = nullstartblock((int)da_new);
 -		xfs_iext_update_extent(ifp, *idx, got);
 -		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
 -		break;
 -	case BMAP_RIGHT_CONTIG:
 -		/*
 -		 * Deleting the last part of the extent.
 -		 */
 -		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
 -		got->br_blockcount = got->br_blockcount - del->br_blockcount;
 -		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
 -				got->br_blockcount), da_old);
 -		got->br_startblock = nullstartblock((int)da_new);
 -		xfs_iext_update_extent(ifp, *idx, got);
 -		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
 -		break;
 -	case 0:
 -		/*
 -		 * Deleting the middle of the extent.
 -		 *
 -		 * Distribute the original indlen reservation across the two new
 -		 * extents.  Steal blocks from the deleted extent if necessary.
 -		 * Stealing blocks simply fudges the fdblocks accounting below.
 -		 * Warn if either of the new indlen reservations is zero as this
 -		 * can lead to delalloc problems.
 -		 */
 -		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
 -
 -		got->br_blockcount = del->br_startoff - got->br_startoff;
 -		got_indlen = xfs_bmap_worst_indlen(ip, got->br_blockcount);
 -
 -		new.br_blockcount = got_endoff - del_endoff;
 -		new_indlen = xfs_bmap_worst_indlen(ip, new.br_blockcount);
 -
 -		WARN_ON_ONCE(!got_indlen || !new_indlen);
 -		stolen = xfs_bmap_split_indlen(da_old, &got_indlen, &new_indlen,
 -						       del->br_blockcount);
 -
 -		got->br_startblock = nullstartblock((int)got_indlen);
 -		xfs_iext_update_extent(ifp, *idx, got);
 -		trace_xfs_bmap_post_update(ip, *idx, 0, _THIS_IP_);
 -
 -		new.br_startoff = del_endoff;
 -		new.br_state = got->br_state;
 -		new.br_startblock = nullstartblock((int)new_indlen);
 -
 -		++*idx;
 -		xfs_iext_insert(ip, *idx, 1, &new, state);
 -
 -		da_new = got_indlen + new_indlen - stolen;
 -		del->br_blockcount -= stolen;
 -		break;
 -	}
 -
 -	ASSERT(da_old >= da_new);
 -	da_diff = da_old - da_new;
 -	if (!isrt)
 -		da_diff += del->br_blockcount;
 -	if (da_diff)
 -		xfs_mod_fdblocks(mp, da_diff, false);
 -	return error;
 -}
 -
 -void
 -xfs_bmap_del_extent_cow(
 -	struct xfs_inode	*ip,
 -	xfs_extnum_t		*idx,
 -	struct xfs_bmbt_irec	*got,
 -	struct xfs_bmbt_irec	*del)
 -{
 -	struct xfs_mount	*mp = ip->i_mount;
 -	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, XFS_COW_FORK);
 -	struct xfs_bmbt_irec	new;
 -	xfs_fileoff_t		del_endoff, got_endoff;
 -	int			state = BMAP_COWFORK;
 -
 -	XFS_STATS_INC(mp, xs_del_exlist);
 -
 -	del_endoff = del->br_startoff + del->br_blockcount;
 -	got_endoff = got->br_startoff + got->br_blockcount;
 -
 -	ASSERT(*idx >= 0);
 -	ASSERT(*idx <= xfs_iext_count(ifp));
 -	ASSERT(del->br_blockcount > 0);
 -	ASSERT(got->br_startoff <= del->br_startoff);
 -	ASSERT(got_endoff >= del_endoff);
 -	ASSERT(!isnullstartblock(got->br_startblock));
 -
 -	if (got->br_startoff == del->br_startoff)
 -		state |= BMAP_LEFT_CONTIG;
 -	if (got_endoff == del_endoff)
 -		state |= BMAP_RIGHT_CONTIG;
 -
 -	switch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {
 -	case BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:
 -		/*
 -		 * Matches the whole extent.  Delete the entry.
 -		 */
 -		xfs_iext_remove(ip, *idx, 1, state);
 -		--*idx;
 -		break;
 -	case BMAP_LEFT_CONTIG:
 -		/*
 -		 * Deleting the first part of the extent.
 -		 */
 -		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
 -		got->br_startoff = del_endoff;
 -		got->br_blockcount -= del->br_blockcount;
 -		got->br_startblock = del->br_startblock + del->br_blockcount;
 -		xfs_iext_update_extent(ifp, *idx, got);
 -		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
 -		break;
 -	case BMAP_RIGHT_CONTIG:
 -		/*
 -		 * Deleting the last part of the extent.
 -		 */
 -		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
 -		got->br_blockcount -= del->br_blockcount;
 -		xfs_iext_update_extent(ifp, *idx, got);
 -		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
 -		break;
 -	case 0:
 -		/*
 -		 * Deleting the middle of the extent.
 -		 */
 -		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
 -		got->br_blockcount = del->br_startoff - got->br_startoff;
 -		xfs_iext_update_extent(ifp, *idx, got);
 -		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
 -
 -		new.br_startoff = del_endoff;
 -		new.br_blockcount = got_endoff - del_endoff;
 -		new.br_state = got->br_state;
 -		new.br_startblock = del->br_startblock + del->br_blockcount;
 -
 -		++*idx;
 -		xfs_iext_insert(ip, *idx, 1, &new, state);
 -		break;
 -	}
 -}
 -
  /*
   * Called by xfs_bmapi to update file extent records and the btree
-  * after removing space (or undoing a delayed allocation).
+  * after removing space.
   */
  STATIC int				/* error */
- xfs_bmap_del_extent(
+ xfs_bmap_del_extent_real(
  	xfs_inode_t		*ip,	/* incore inode pointer */
  	xfs_trans_t		*tp,	/* current transaction pointer */
  	xfs_extnum_t		*idx,	/* extent number to update/delete */
@@@ -4673,13 -5070,11 +4673,10 @@@
  	xfs_btree_cur_t		*cur,	/* if null, not a btree */
  	xfs_bmbt_irec_t		*del,	/* data to remove from extents */
  	int			*logflagsp, /* inode logging flags */
 -	int			whichfork, /* data or attr fork */
 -	int			bflags)	/* bmapi flags */
 +	int			whichfork) /* data or attr fork */
  {
- 	xfs_filblks_t		da_new;	/* new delay-alloc indirect blocks */
- 	xfs_filblks_t		da_old;	/* old delay-alloc indirect blocks */
  	xfs_fsblock_t		del_endblock=0;	/* first block past del */
  	xfs_fileoff_t		del_endoff;	/* first offset past del */
- 	int			delay;	/* current block is delayed allocated */
  	int			do_fx;	/* free extent at end of routine */
  	xfs_bmbt_rec_host_t	*ep;	/* current extent entry pointer */
  	int			error;	/* error return value */
@@@ -4712,64 -5109,42 +4709,41 @@@
  	del_endoff = del->br_startoff + del->br_blockcount;
  	got_endoff = got.br_startoff + got.br_blockcount;
  	ASSERT(got_endoff >= del_endoff);
- 	delay = isnullstartblock(got.br_startblock);
- 	ASSERT(isnullstartblock(del->br_startblock) == delay);
- 	flags = 0;
+ 	ASSERT(!isnullstartblock(got.br_startblock));
+ 	flags = XFS_ILOG_CORE;
  	qfield = 0;
  	error = 0;
- 	/*
- 	 * If deleting a real allocation, must free up the disk space.
- 	 */
- 	if (!delay) {
- 		flags = XFS_ILOG_CORE;
- 		/*
- 		 * Realtime allocation.  Free it and record di_nblocks update.
- 		 */
- 		if (whichfork == XFS_DATA_FORK && XFS_IS_REALTIME_INODE(ip)) {
- 			xfs_fsblock_t	bno;
- 			xfs_filblks_t	len;
- 
- 			ASSERT(do_mod(del->br_blockcount,
- 				      mp->m_sb.sb_rextsize) == 0);
- 			ASSERT(do_mod(del->br_startblock,
- 				      mp->m_sb.sb_rextsize) == 0);
- 			bno = del->br_startblock;
- 			len = del->br_blockcount;
- 			do_div(bno, mp->m_sb.sb_rextsize);
- 			do_div(len, mp->m_sb.sb_rextsize);
- 			error = xfs_rtfree_extent(tp, bno, (xfs_extlen_t)len);
- 			if (error)
- 				goto done;
- 			do_fx = 0;
- 			nblks = len * mp->m_sb.sb_rextsize;
- 			qfield = XFS_TRANS_DQ_RTBCOUNT;
- 		}
- 		/*
- 		 * Ordinary allocation.
- 		 */
- 		else {
- 			do_fx = 1;
- 			nblks = del->br_blockcount;
- 			qfield = XFS_TRANS_DQ_BCOUNT;
- 		}
- 		/*
- 		 * Set up del_endblock and cur for later.
- 		 */
- 		del_endblock = del->br_startblock + del->br_blockcount;
- 		if (cur) {
- 			if ((error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
- 					got.br_startblock, got.br_blockcount,
- 					&i)))
- 				goto done;
- 			XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
- 		}
- 		da_old = da_new = 0;
- 	} else {
- 		da_old = startblockval(got.br_startblock);
- 		da_new = 0;
- 		nblks = 0;
+ 
+ 	if (whichfork == XFS_DATA_FORK && XFS_IS_REALTIME_INODE(ip)) {
+ 		xfs_fsblock_t	bno;
+ 		xfs_filblks_t	len;
+ 
+ 		ASSERT(do_mod(del->br_blockcount, mp->m_sb.sb_rextsize) == 0);
+ 		ASSERT(do_mod(del->br_startblock, mp->m_sb.sb_rextsize) == 0);
+ 		bno = del->br_startblock;
+ 		len = del->br_blockcount;
+ 		do_div(bno, mp->m_sb.sb_rextsize);
+ 		do_div(len, mp->m_sb.sb_rextsize);
+ 		error = xfs_rtfree_extent(tp, bno, (xfs_extlen_t)len);
+ 		if (error)
+ 			goto done;
  		do_fx = 0;
+ 		nblks = len * mp->m_sb.sb_rextsize;
+ 		qfield = XFS_TRANS_DQ_RTBCOUNT;
+ 	} else {
+ 		do_fx = 1;
+ 		nblks = del->br_blockcount;
+ 		qfield = XFS_TRANS_DQ_BCOUNT;
+ 	}
+ 
+ 	del_endblock = del->br_startblock + del->br_blockcount;
+ 	if (cur) {
+ 		error = xfs_bmbt_lookup_eq(cur, got.br_startoff,
+ 				got.br_startblock, got.br_blockcount, &i);
+ 		if (error)
+ 			goto done;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
  	}
 -
  	/*
  	 * Set flag value to use in switch statement.
  	 * Left-contig is 2, right-contig is 1.
@@@ -4952,6 -5281,12 +4879,15 @@@
  		++*idx;
  		break;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	/* remove reverse mapping */
+ 	error = xfs_rmap_unmap_extent(mp, dfops, ip, whichfork, del);
+ 	if (error)
+ 		goto done;
+ 
++>>>>>>> e1d7553faf39 (xfs: use xfs_bmap_del_extent_delay for the data fork as well)
  	/*
  	 * If we need to, add to list of extents to delete.
  	 */
@@@ -4966,16 -5308,9 +4902,9 @@@
  	/*
  	 * Adjust quota data.
  	 */
 -	if (qfield && !(bflags & XFS_BMAPI_REMAP))
 +	if (qfield)
  		xfs_trans_mod_dquot_byino(tp, ip, qfield, (long)-nblks);
  
- 	/*
- 	 * Account for change in delayed indirect blocks.
- 	 * Nothing to do for disk quota accounting here.
- 	 */
- 	ASSERT(da_old >= da_new);
- 	if (da_old > da_new)
- 		xfs_mod_fdblocks(mp, (int64_t)(da_old - da_new), false);
  done:
  	*logflagsp = flags;
  	return error;
@@@ -5240,65 -5595,43 +5169,76 @@@ __xfs_bunmapi
  			}
  		}
  
- 		/*
- 		 * If it's the case where the directory code is running
- 		 * with no block reservation, and the deleted block is in
- 		 * the middle of its extent, and the resulting insert
- 		 * of an extent would cause transformation to btree format,
- 		 * then reject it.  The calling code will then swap
- 		 * blocks around instead.
- 		 * We have to do this now, rather than waiting for the
- 		 * conversion to btree format, since the transaction
- 		 * will be dirty.
- 		 */
- 		if (!wasdel && tp->t_blk_res == 0 &&
- 		    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&
- 		    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */
- 			XFS_IFORK_MAXEXT(ip, whichfork) &&
- 		    del.br_startoff > got.br_startoff &&
- 		    del.br_startoff + del.br_blockcount <
- 		    got.br_startoff + got.br_blockcount) {
- 			error = -ENOSPC;
- 			goto error0;
- 		}
- 
- 		/*
- 		 * Unreserve quota and update realtime free space, if
- 		 * appropriate. If delayed allocation, update the inode delalloc
- 		 * counter now and wait to update the sb counters as
- 		 * xfs_bmap_del_extent() might need to borrow some blocks.
- 		 */
  		if (wasdel) {
++<<<<<<< HEAD
 +			ASSERT(startblockval(del.br_startblock) > 0);
 +			if (isrt) {
 +				xfs_filblks_t rtexts;
 +
 +				rtexts = XFS_FSB_TO_B(mp, del.br_blockcount);
 +				do_div(rtexts, mp->m_sb.sb_rextsize);
 +				xfs_mod_frextents(mp, (int64_t)rtexts);
 +				error = xfs_trans_reserve_quota_nblks(NULL,
 +						ip, -((long)del.br_blockcount),
 +						0, XFS_QMOPT_RES_RTBLKS);
 +			} else {
 +				error = xfs_trans_reserve_quota_nblks(NULL,
 +						ip, -((long)del.br_blockcount),
 +						0, XFS_QMOPT_RES_REGBLKS);
 +			}
 +			if (error)
 +				goto error0;
 +			ip->i_delayed_blks -= del.br_blockcount;
 +		}
 +
 +		error = xfs_bmap_del_extent(ip, tp, &lastx, dfops, cur, &del,
 +				&tmp_logflags, whichfork);
 +		logflags |= tmp_logflags;
 +		if (error)
 +			goto error0;
 +
 +		if (!isrt && wasdel)
 +			xfs_mod_fdblocks(mp, (int64_t)del.br_blockcount, false);
 +
 +		bno = del.br_startoff - 1;
++=======
+ 			error = xfs_bmap_del_extent_delay(ip, whichfork, &lastx,
+ 					&got, &del);
+ 		} else {
+ 			/*
+ 			 * If it's the case where the directory code is running
+ 			 * with no block reservation, and the deleted block is
+ 			 * in the middle of its extent, and the resulting insert
+ 			 * of an extent would cause transformation to btree
+ 			 * format, then reject it.  The calling code will then
+ 			 * swap blocks around instead.  We have to do this now,
+ 			 * rather than waiting for the conversion to btree
+ 			 * format, since the transaction will be dirty.
+ 			 */
+ 			if (tp->t_blk_res == 0 &&
+ 			    XFS_IFORK_FORMAT(ip, whichfork) ==
+ 					XFS_DINODE_FMT_EXTENTS &&
+ 			    XFS_IFORK_NEXTENTS(ip, whichfork) >=
+ 					XFS_IFORK_MAXEXT(ip, whichfork) &&
+ 			    del.br_startoff > got.br_startoff &&
+ 			    del.br_startoff + del.br_blockcount <
+ 			    got.br_startoff + got.br_blockcount) {
+ 				error = -ENOSPC;
+ 				goto error0;
+ 			}
+ 
+ 			error = xfs_bmap_del_extent_real(ip, tp, &lastx, dfops,
+ 					cur, &del, &tmp_logflags, whichfork,
+ 					flags);
+ 			logflags |= tmp_logflags;
+ 		}
+ 
+ 		if (error)
+ 			goto error0;
+ 
+ 		max_len -= del.br_blockcount;
+ 		end = del.br_startoff - 1;
++>>>>>>> e1d7553faf39 (xfs: use xfs_bmap_del_extent_delay for the data fork as well)
  nodelete:
  		/*
  		 * If not done go on to the next (previous) record.
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
