x86/hyper-v: Fix the circular dependency in IPI enlightenment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] hyper-v: Fix the circular dependency in IPI enlightenment (Vitaly Kuznetsov) [1661654]
Rebuild_FUZZ: 96.61%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 1268ed0c474a5c8f165ef386f3310521b5e00e27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/1268ed0c.failed

The IPI hypercalls depend on being able to map the Linux notion of CPU ID
to the hypervisor's notion of the CPU ID. The array hv_vp_index[] provides
this mapping. Code for populating this array depends on the IPI functionality.
Break this circular dependency.

[ tglx: Use a proper define instead of '-1' with a u32 variable as pointed
  	out by Vitaly ]

Fixes: 68bb7bfb7985 ("X86/Hyper-V: Enable IPI enlightenments")
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Michael Kelley <mikelley@microsoft.com>
	Cc: gregkh@linuxfoundation.org
	Cc: devel@linuxdriverproject.org
	Cc: olaf@aepfle.de
	Cc: apw@canonical.com
	Cc: jasowang@redhat.com
	Cc: hpa@zytor.com
	Cc: sthemmin@microsoft.com
	Cc: Michael.H.Kelley@microsoft.com
	Cc: vkuznets@redhat.com
Link: https://lkml.kernel.org/r/20180703230155.15160-1-kys@linuxonhyperv.com


(cherry picked from commit 1268ed0c474a5c8f165ef386f3310521b5e00e27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_apic.c
#	arch/x86/hyperv/hv_init.c
#	arch/x86/include/asm/mshyperv.h
diff --cc arch/x86/hyperv/hv_init.c
index d319f711dbe1,1ff420217298..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -127,25 -259,54 +127,46 @@@ static struct notifier_block hv_newcpu_
   *
   * 1. Setup the hypercall page.
   * 2. Register Hyper-V specific clocksource.
 - * 3. Setup Hyper-V specific APIC entry points.
   */
 -void __init hyperv_init(void)
 +void hyperv_init(void)
  {
 -	u64 guest_id, required_msrs;
 +	u64 guest_id;
  	union hv_x64_msr_hypercall_contents hypercall_msr;
++<<<<<<< HEAD
++=======
+ 	int cpuhp, i;
++>>>>>>> 1268ed0c474a (x86/hyper-v: Fix the circular dependency in IPI enlightenment)
  
 -	if (x86_hyper_type != X86_HYPER_MS_HYPERV)
 -		return;
 -
 -	/* Absolutely required MSRs */
 -	required_msrs = HV_X64_MSR_HYPERCALL_AVAILABLE |
 -		HV_X64_MSR_VP_INDEX_AVAILABLE;
 -
 -	if ((ms_hyperv.features & required_msrs) != required_msrs)
 +	if (x86_hyper != &x86_hyper_ms_hyperv)
  		return;
  
 -	/*
 -	 * Allocate the per-CPU state for the hypercall input arg.
 -	 * If this allocation fails, we will not be able to setup
 -	 * (per-CPU) hypercall input page and thus this failure is
 -	 * fatal on Hyper-V.
 -	 */
 -	hyperv_pcpu_input_arg = alloc_percpu(void  *);
 -
 -	BUG_ON(hyperv_pcpu_input_arg == NULL);
 -
  	/* Allocate percpu VP index */
  	hv_vp_index = kmalloc_array(num_possible_cpus(), sizeof(*hv_vp_index),
  				    GFP_KERNEL);
  	if (!hv_vp_index)
  		return;
  
++<<<<<<< HEAD
 +	cpu_notifier_register_begin();
 +	on_each_cpu(hv_cpu_init, NULL, 1);
 +	__register_hotcpu_notifier(&hv_newcpu_notifier);
 +	cpu_notifier_register_done();
++=======
+ 	for (i = 0; i < num_possible_cpus(); i++)
+ 		hv_vp_index[i] = VP_INVAL;
+ 
+ 	hv_vp_assist_page = kcalloc(num_possible_cpus(),
+ 				    sizeof(*hv_vp_assist_page), GFP_KERNEL);
+ 	if (!hv_vp_assist_page) {
+ 		ms_hyperv.hints &= ~HV_X64_ENLIGHTENED_VMCS_RECOMMENDED;
+ 		goto free_vp_index;
+ 	}
+ 
+ 	cpuhp = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, "x86/hyperv_init:online",
+ 				  hv_cpu_init, hv_cpu_die);
+ 	if (cpuhp < 0)
+ 		goto free_vp_assist_page;
++>>>>>>> 1268ed0c474a (x86/hyper-v: Fix the circular dependency in IPI enlightenment)
  
  	/*
  	 * Setup the hypercall page and enable hypercalls.
diff --cc arch/x86/include/asm/mshyperv.h
index 9f5a1d620424,5a7375ed5f7c..000000000000
--- a/arch/x86/include/asm/mshyperv.h
+++ b/arch/x86/include/asm/mshyperv.h
@@@ -5,27 -6,10 +5,31 @@@
  #include <linux/atomic.h>
  #include <linux/nmi.h>
  #include <asm/io.h>
 -#include <asm/hyperv-tlfs.h>
 +#include <asm/hyperv.h>
  #include <asm/nospec-branch.h>
  
++<<<<<<< HEAD
 +/*
 + * The below CPUID leaves are present if VersionAndFeatures.HypervisorPresent
 + * is set by CPUID(HVCPUID_VERSION_FEATURES).
 + */
 +enum hv_cpuid_function {
 +	HVCPUID_VERSION_FEATURES		= 0x00000001,
 +	HVCPUID_VENDOR_MAXFUNCTION		= 0x40000000,
 +	HVCPUID_INTERFACE			= 0x40000001,
 +
 +	/*
 +	 * The remaining functions depend on the value of
 +	 * HVCPUID_INTERFACE
 +	 */
 +	HVCPUID_VERSION				= 0x40000002,
 +	HVCPUID_FEATURES			= 0x40000003,
 +	HVCPUID_ENLIGHTENMENT_INFO		= 0x40000004,
 +	HVCPUID_IMPLEMENTATION_LIMITS		= 0x40000005,
 +};
++=======
+ #define VP_INVAL	U32_MAX
++>>>>>>> 1268ed0c474a (x86/hyper-v: Fix the circular dependency in IPI enlightenment)
  
  struct ms_hyperv_info {
  	u32 features;
@@@ -35,58 -22,8 +39,61 @@@
  
  extern struct ms_hyperv_info ms_hyperv;
  
++<<<<<<< HEAD
 +/*
 + * Declare the MSR used to setup pages used to communicate with the hypervisor.
 + */
 +union hv_x64_msr_hypercall_contents {
 +	u64 as_uint64;
 +	struct {
 +		u64 enable:1;
 +		u64 reserved:11;
 +		u64 guest_physical_address:52;
 +	};
 +};
 +
++=======
++>>>>>>> 1268ed0c474a (x86/hyper-v: Fix the circular dependency in IPI enlightenment)
  /*
 - * Generate the guest ID.
 + * TSC page layout.
 + */
 +
 +struct ms_hyperv_tsc_page {
 +	volatile u32 tsc_sequence;
 +	u32 reserved1;
 +	volatile u64 tsc_scale;
 +	volatile s64 tsc_offset;
 +	u64 reserved2[509];
 +};
 +
 +/*
 + * The guest OS needs to register the guest ID with the hypervisor.
 + * The guest ID is a 64 bit entity and the structure of this ID is
 + * specified in the Hyper-V specification:
 + *
 + * msdn.microsoft.com/en-us/library/windows/hardware/ff542653%28v=vs.85%29.aspx
 + *
 + * While the current guideline does not specify how Linux guest ID(s)
 + * need to be generated, our plan is to publish the guidelines for
 + * Linux and other guest operating systems that currently are hosted
 + * on Hyper-V. The implementation here conforms to this yet
 + * unpublished guidelines.
 + *
 + *
 + * Bit(s)
 + * 63 - Indicates if the OS is Open Source or not; 1 is Open Source
 + * 62:56 - Os Type; Linux is 0x100
 + * 55:48 - Distro specific identification
 + * 47:16 - Linux kernel version number
 + * 15:0  - Distro specific identification
 + *
 + *
 + */
 +
 +#define HV_LINUX_VENDOR_ID              0x8100
 +
 +/*
 + * Generate the guest ID based on the guideline described above.
   */
  
  static inline  __u64 generate_guest_id(__u64 d_info1, __u64 kernel_version,
@@@ -309,9 -260,43 +316,48 @@@ static inline int hv_cpu_number_to_vp_n
  	return hv_vp_index[cpu_number];
  }
  
++<<<<<<< HEAD
 +void hyperv_init(void);
++=======
+ static inline int cpumask_to_vpset(struct hv_vpset *vpset,
+ 				    const struct cpumask *cpus)
+ {
+ 	int cpu, vcpu, vcpu_bank, vcpu_offset, nr_bank = 1;
+ 
+ 	/* valid_bank_mask can represent up to 64 banks */
+ 	if (hv_max_vp_index / 64 >= 64)
+ 		return 0;
+ 
+ 	/*
+ 	 * Clear all banks up to the maximum possible bank as hv_tlb_flush_ex
+ 	 * structs are not cleared between calls, we risk flushing unneeded
+ 	 * vCPUs otherwise.
+ 	 */
+ 	for (vcpu_bank = 0; vcpu_bank <= hv_max_vp_index / 64; vcpu_bank++)
+ 		vpset->bank_contents[vcpu_bank] = 0;
+ 
+ 	/*
+ 	 * Some banks may end up being empty but this is acceptable.
+ 	 */
+ 	for_each_cpu(cpu, cpus) {
+ 		vcpu = hv_cpu_number_to_vp_number(cpu);
+ 		if (vcpu == VP_INVAL)
+ 			return -1;
+ 		vcpu_bank = vcpu / 64;
+ 		vcpu_offset = vcpu % 64;
+ 		__set_bit(vcpu_offset, (unsigned long *)
+ 			  &vpset->bank_contents[vcpu_bank]);
+ 		if (vcpu_bank >= nr_bank)
+ 			nr_bank = vcpu_bank + 1;
+ 	}
+ 	vpset->valid_bank_mask = GENMASK_ULL(nr_bank - 1, 0);
+ 	return nr_bank;
+ }
+ 
+ void __init hyperv_init(void);
++>>>>>>> 1268ed0c474a (x86/hyper-v: Fix the circular dependency in IPI enlightenment)
  void hyperv_setup_mmu_ops(void);
 +void hyper_alloc_mmu(void);
  void hyperv_report_panic(struct pt_regs *regs, long err);
  bool hv_is_hyperv_initialized(void);
  void hyperv_cleanup(void);
* Unmerged path arch/x86/hyperv/hv_apic.c
* Unmerged path arch/x86/hyperv/hv_apic.c
* Unmerged path arch/x86/hyperv/hv_init.c
* Unmerged path arch/x86/include/asm/mshyperv.h
