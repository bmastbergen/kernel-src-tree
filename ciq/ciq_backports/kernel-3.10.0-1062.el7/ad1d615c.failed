ovl: use directory index entries for consistency verification

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit ad1d615cec1c973aa222c065997a77e7cd5a0d17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ad1d615c.failed

A directory index is a directory type entry in index dir with a
"trusted.overlay.upper" xattr containing an encoded ovl_fh of the merge
directory upper dir inode.

On lookup of non-dir files, lower file is followed by origin file handle.
On lookup of dir entries, lower dir is found by name and then compared
to origin file handle. We only trust dir index if we verified that lower
dir matches origin file handle, otherwise index may be inconsistent and
we ignore it.

If we find an indexed non-upper dir or an indexed merged dir, whose
index 'upper' xattr points to a different upper dir, that means that the
lower directory may be also referenced by another upper dir via redirect,
so we fail the lookup on inconsistency error.

To be consistent with directory index entries format, the association of
index dir to upper root dir, that was stored by older kernels in
"trusted.overlay.origin" xattr is now stored in "trusted.overlay.upper"
xattr. This also serves as an indication that overlay was mounted with a
kernel that support index directory entries. For backward compatibility,
if an 'origin' xattr exists on the index dir we also verify it on mount.

Directory index entries are going to be used for NFS export.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit ad1d615cec1c973aa222c065997a77e7cd5a0d17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/namei.c
index 0afb8ae29e9b,b00d909e7326..000000000000
--- a/fs/overlayfs/namei.c
+++ b/fs/overlayfs/namei.c
@@@ -580,8 -660,9 +596,9 @@@ struct dentry *ovl_lookup(struct inode 
  	struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
  	struct ovl_entry *poe = dentry->d_parent->d_fsdata;
  	struct ovl_entry *roe = dentry->d_sb->s_root->d_fsdata;
 -	struct ovl_path *stack = NULL;
 +	struct path *stack = NULL;
  	struct dentry *upperdir, *upperdentry = NULL;
+ 	struct dentry *origin = NULL;
  	struct dentry *index = NULL;
  	unsigned int ctr = 0;
  	struct inode *inode = NULL;
@@@ -662,8 -742,36 +679,39 @@@
  		if (!this)
  			continue;
  
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * If no origin fh is stored in upper of a merge dir, store fh
+ 		 * of lower dir and set upper parent "impure".
+ 		 */
+ 		if (upperdentry && !ctr && !ofs->noxattr) {
+ 			err = ovl_fix_origin(dentry, this, upperdentry);
+ 			if (err) {
+ 				dput(this);
+ 				goto out_put;
+ 			}
+ 		}
+ 
+ 		/*
+ 		 * When "verify_lower" feature is enabled, do not merge with a
+ 		 * lower dir that does not match a stored origin xattr. In any
+ 		 * case, only verified origin is used for index lookup.
+ 		 */
+ 		if (upperdentry && !ctr && ovl_verify_lower(dentry->d_sb)) {
+ 			err = ovl_verify_origin(upperdentry, this, false);
+ 			if (err) {
+ 				dput(this);
+ 				break;
+ 			}
+ 
+ 			/* Bless lower dir as verified origin */
+ 			origin = this;
+ 		}
+ 
++>>>>>>> ad1d615cec1c (ovl: use directory index entries for consistency verification)
  		stack[ctr].dentry = this;
 -		stack[ctr].layer = lower.layer;
 +		stack[ctr].mnt = lowerpath.mnt;
  		ctr++;
  
  		if (d.stop)
diff --cc fs/overlayfs/overlayfs.h
index 79baeaeaf3d6,25794a3a3fe1..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -246,15 -252,27 +247,30 @@@ static inline bool ovl_is_impuredir(str
  
  
  /* namei.c */
 -int ovl_verify_set_fh(struct dentry *dentry, const char *name,
 -		      struct dentry *real, bool is_upper, bool set);
 -int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
 +int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 +		      struct dentry *origin, bool is_upper, bool set);
 +int ovl_verify_index(struct dentry *index, struct path *lowerstack,
 +		     unsigned int numlower);
  int ovl_get_index_name(struct dentry *origin, struct qstr *name);
  int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 -struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 -			  unsigned int flags);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
  bool ovl_lower_positive(struct dentry *dentry);
  
++<<<<<<< HEAD
++=======
+ static inline int ovl_verify_origin(struct dentry *upper,
+ 				    struct dentry *origin, bool set)
+ {
+ 	return ovl_verify_set_fh(upper, OVL_XATTR_ORIGIN, origin, false, set);
+ }
+ 
+ static inline int ovl_verify_upper(struct dentry *index,
+ 				    struct dentry *upper, bool set)
+ {
+ 	return ovl_verify_set_fh(index, OVL_XATTR_UPPER, upper, true, set);
+ }
+ 
++>>>>>>> ad1d615cec1c (ovl: use directory index entries for consistency verification)
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
  int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
diff --cc fs/overlayfs/super.c
index d3038555ac46,170c184a9f43..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -871,121 -902,276 +871,168 @@@ static const struct xattr_handler *ovl_
  	NULL
  };
  
 -static int ovl_get_upper(struct ovl_fs *ofs, struct path *upperpath)
 -{
 -	struct vfsmount *upper_mnt;
 -	int err;
 -
 -	err = ovl_mount_dir(ofs->config.upperdir, upperpath);
 -	if (err)
 -		goto out;
 -
 -	/* Upper fs should not be r/o */
 -	if (sb_rdonly(upperpath->mnt->mnt_sb)) {
 -		pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 -		err = -EINVAL;
 -		goto out;
 -	}
 -
 -	err = ovl_check_namelen(upperpath, ofs, ofs->config.upperdir);
 -	if (err)
 -		goto out;
 -
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(upperpath->dentry)) {
 -		ofs->upperdir_locked = true;
 -	} else if (ofs->config.index) {
 -		pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 -	}
 -
 -	upper_mnt = clone_private_mount(upperpath);
 -	err = PTR_ERR(upper_mnt);
 -	if (IS_ERR(upper_mnt)) {
 -		pr_err("overlayfs: failed to clone upperpath\n");
 -		goto out;
 -	}
 -
 -	/* Don't inherit atime flags */
 -	upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
 -	ofs->upper_mnt = upper_mnt;
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static int ovl_make_workdir(struct ovl_fs *ofs, struct path *workpath)
 +static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
 -	struct vfsmount *mnt = ofs->upper_mnt;
 -	struct dentry *temp;
 +	struct path upperpath = { };
 +	struct path workpath = { };
 +	struct dentry *root_dentry;
 +	struct ovl_entry *oe;
 +	struct ovl_fs *ufs;
 +	const int *upper_stack_depth;
 +	int *overlay_stack_depth;
 +	struct path *stack = NULL;
 +	char *lowertmp;
 +	char *lower;
 +	unsigned int numlower;
 +	unsigned int stacklen = 0;
 +	unsigned int i;
 +	bool remote = false;
 +	struct cred *cred;
  	int err;
  
 -	err = mnt_want_write(mnt);
 -	if (err)
 -		return err;
 -
 -	ofs->workdir = ovl_workdir_create(ofs, OVL_WORKDIR_NAME, false);
 -	if (!ofs->workdir)
 -		goto out;
 -
 -	/*
 -	 * Upper should support d_type, else whiteouts are visible.  Given
 -	 * workdir and upper are on same fs, we can do iterate_dir() on
 -	 * workdir. This check requires successful creation of workdir in
 -	 * previous step.
 -	 */
 -	err = ovl_check_d_type_supported(workpath);
 -	if (err < 0)
 +	err = -ENOMEM;
 +	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
 +	if (!ufs)
  		goto out;
  
 -	/*
 -	 * We allowed this configuration and don't want to break users over
 -	 * kernel upgrade. So warn instead of erroring out.
 -	 */
 -	if (!err)
 -		pr_warn("overlayfs: upper fs needs to support d_type.\n");
 -
 -	/* Check if upper/work fs supports O_TMPFILE */
 -	temp = ovl_do_tmpfile(ofs->workdir, S_IFREG | 0);
 -	ofs->tmpfile = !IS_ERR(temp);
 -	if (ofs->tmpfile)
 -		dput(temp);
 -	else
 -		pr_warn("overlayfs: upper fs does not support tmpfile.\n");
 -
 -	/*
 -	 * Check if upper/work fs supports trusted.overlay.* xattr
 -	 */
 -	err = ovl_do_setxattr(ofs->workdir, OVL_XATTR_OPAQUE, "0", 1, 0);
 -	if (err) {
 -		ofs->noxattr = true;
 -		ofs->config.index = false;
 -		pr_warn("overlayfs: upper fs does not support xattr, falling back to index=off.\n");
 -		err = 0;
 -	} else {
 -		vfs_removexattr(ofs->workdir, OVL_XATTR_OPAQUE);
 -	}
 -
 -	/* Check if upper/work fs supports file handles */
 -	if (ofs->config.index &&
 -	    !ovl_can_decode_fh(ofs->workdir->d_sb)) {
 -		ofs->config.index = false;
 -		pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
 -	}
 -
 -	/* NFS export of r/w mount depends on index */
 -	if (ofs->config.nfs_export && !ofs->config.index) {
 -		pr_warn("overlayfs: NFS export requires \"index=on\", falling back to nfs_export=off.\n");
 -		ofs->config.nfs_export = false;
 -	}
 -
 -out:
 -	mnt_drop_write(mnt);
 -	return err;
 -}
 -
 -static int ovl_get_workdir(struct ovl_fs *ofs, struct path *upperpath)
 -{
 -	int err;
 -	struct path workpath = { };
 -
 -	err = ovl_mount_dir(ofs->config.workdir, &workpath);
 +	ufs->config.index = ovl_index_def;
 +	err = ovl_parse_opt((char *) data, &ufs->config);
  	if (err)
 -		goto out;
 +		goto out_free_config;
  
  	err = -EINVAL;
 -	if (upperpath->mnt != workpath.mnt) {
 -		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 -		goto out;
 -	}
 -	if (!ovl_workdir_ok(workpath.dentry, upperpath->dentry)) {
 -		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 -		goto out;
 +	if (!ufs->config.lowerdir) {
 +		if (!silent)
 +			pr_err("overlayfs: missing 'lowerdir'\n");
 +		goto out_free_config;
  	}
  
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(workpath.dentry)) {
 -		ofs->workdir_locked = true;
 -	} else if (ofs->config.index) {
 -		pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_free_config;
  	}
 +	*overlay_stack_depth = 0;
  
 -	ofs->workbasedir = dget(workpath.dentry);
 -	err = ovl_make_workdir(ofs, &workpath);
 -	if (err)
 -		goto out;
 +	sb->s_maxbytes = MAX_LFS_FILESIZE;
 +	if (ufs->config.upperdir) {
 +		if (!ufs->config.workdir) {
 +			pr_err("overlayfs: missing 'workdir'\n");
 +			goto out_free_config;
 +		}
  
++<<<<<<< HEAD
 +		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 +		if (err)
 +			goto out_free_config;
++=======
+ 	err = 0;
+ out:
+ 	path_put(&workpath);
+ 
+ 	return err;
+ }
+ 
+ static int ovl_get_indexdir(struct ovl_fs *ofs, struct ovl_entry *oe,
+ 			    struct path *upperpath)
+ {
+ 	struct vfsmount *mnt = ofs->upper_mnt;
+ 	int err;
+ 
+ 	err = mnt_want_write(mnt);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Verify lower root is upper root origin */
+ 	err = ovl_verify_origin(upperpath->dentry, oe->lowerstack[0].dentry,
+ 				true);
+ 	if (err) {
+ 		pr_err("overlayfs: failed to verify upper root origin\n");
+ 		goto out;
+ 	}
+ 
+ 	ofs->indexdir = ovl_workdir_create(ofs, OVL_INDEXDIR_NAME, true);
+ 	if (ofs->indexdir) {
+ 		/*
+ 		 * Verify upper root is exclusively associated with index dir.
+ 		 * Older kernels stored upper fh in "trusted.overlay.origin"
+ 		 * xattr. If that xattr exists, verify that it is a match to
+ 		 * upper dir file handle. In any case, verify or set xattr
+ 		 * "trusted.overlay.upper" to indicate that index may have
+ 		 * directory entries.
+ 		 */
+ 		if (ovl_check_origin_xattr(ofs->indexdir)) {
+ 			err = ovl_verify_set_fh(ofs->indexdir, OVL_XATTR_ORIGIN,
+ 						upperpath->dentry, true, false);
+ 			if (err)
+ 				pr_err("overlayfs: failed to verify index dir 'origin' xattr\n");
+ 		}
+ 		err = ovl_verify_upper(ofs->indexdir, upperpath->dentry, true);
+ 		if (err)
+ 			pr_err("overlayfs: failed to verify index dir 'upper' xattr\n");
++>>>>>>> ad1d615cec1c (ovl: use directory index entries for consistency verification)
  
 -		/* Cleanup bad/stale/orphan index entries */
 -		if (!err)
 -			err = ovl_indexdir_cleanup(ofs);
 -	}
 -	if (err || !ofs->indexdir)
 -		pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
 -
 -out:
 -	mnt_drop_write(mnt);
 -	return err;
 -}
 +		/* Upper fs should not be r/o */
 +		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
 +			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 +			err = -EINVAL;
 +			goto out_put_upperpath;
 +		}
  
 -static int ovl_get_lower_layers(struct ovl_fs *ofs, struct path *stack,
 -				unsigned int numlower)
 -{
 -	int err;
 -	unsigned int i;
 +		err = ovl_check_namelen(&upperpath, ufs, ufs->config.upperdir);
 +		if (err)
 +			goto out_put_upperpath;
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(upperpath.dentry)) {
 +			ufs->upperdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 +			goto out_put_upperpath;
 +		} else {
 +			pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
  
 -	err = -ENOMEM;
 -	ofs->lower_layers = kcalloc(numlower, sizeof(struct ovl_layer),
 -				    GFP_KERNEL);
 -	if (ofs->lower_layers == NULL)
 -		goto out;
 -	for (i = 0; i < numlower; i++) {
 -		struct vfsmount *mnt;
 -		dev_t dev;
 +		err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +		if (err)
 +			goto out_unlock_upperdentry;
  
 -		err = get_anon_bdev(&dev);
 -		if (err) {
 -			pr_err("overlayfs: failed to get anonymous bdev for lowerpath\n");
 -			goto out;
 +		err = -EINVAL;
 +		if (upperpath.mnt != workpath.mnt) {
 +			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +			goto out_put_workpath;
 +		}
 +		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +			goto out_put_workpath;
  		}
  
 -		mnt = clone_private_mount(&stack[i]);
 -		err = PTR_ERR(mnt);
 -		if (IS_ERR(mnt)) {
 -			pr_err("overlayfs: failed to clone lowerpath\n");
 -			free_anon_bdev(dev);
 -			goto out;
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(workpath.dentry)) {
 +			ufs->workdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 +			goto out_put_workpath;
 +		} else {
 +			pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
  		}
 -		/*
 -		 * Make lower layers R/O.  That way fchmod/fchown on lower file
 -		 * will fail instead of modifying lower fs.
 -		 */
 -		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
  
 -		ofs->lower_layers[ofs->numlower].mnt = mnt;
 -		ofs->lower_layers[ofs->numlower].pseudo_dev = dev;
 -		ofs->lower_layers[ofs->numlower].idx = i + 1;
 -		ofs->numlower++;
 +		ufs->workbasedir = workpath.dentry;
 +		upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +		err = -EOPNOTSUPP;
 +		if (!upper_stack_depth) {
 +			pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +			goto out_put_workpath;
 +		}
  
 -		/* Check if all lower layers are on same sb */
 -		if (i == 0)
 -			ofs->same_sb = mnt->mnt_sb;
 -		else if (ofs->same_sb != mnt->mnt_sb)
 -			ofs->same_sb = NULL;
 +		*overlay_stack_depth = *upper_stack_depth;
  	}
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static struct ovl_entry *ovl_get_lowerstack(struct super_block *sb,
 -					    struct ovl_fs *ofs)
 -{
 -	int err;
 -	char *lowertmp, *lower;
 -	struct path *stack = NULL;
 -	unsigned int stacklen, numlower = 0, i;
 -	bool remote = false;
 -	struct ovl_entry *oe;
  
  	err = -ENOMEM;
 -	lowertmp = kstrdup(ofs->config.lowerdir, GFP_KERNEL);
 +	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
  	if (!lowertmp)
 -		goto out_err;
 +		goto out_unlock_workdentry;
  
  	err = -EINVAL;
  	stacklen = ovl_split_lowerdirs(lowertmp);
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/super.c
