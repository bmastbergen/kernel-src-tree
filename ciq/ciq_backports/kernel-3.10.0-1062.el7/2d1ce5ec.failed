PCI: Check for PCIe Link downtraining

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [pci] Check for PCIe Link downtraining (Eelco Chaudron) [1654186]
Rebuild_FUZZ: 92.75%
commit-author Alexandru Gagniuc <mr.nuke.me@gmail.com>
commit 2d1ce5ec2117d16047334a1aa4b62e0cfb5a0605
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/2d1ce5ec.failed

When both ends of a PCIe Link are capable of a higher bandwidth than is
currently in use, the Link is said to be "downtrained".  A downtrained Link
may indicate hardware or configuration problems in the system, but it's
hard to identify such Links from userspace.

Refactor pcie_print_link_status() so it continues to always print PCIe
bandwidth information, as several NIC drivers desire.

Add a new internal __pcie_print_link_status() to emit a message only when a
device's bandwidth is constrained by the fabric and call it from the PCI
core for all devices, which identifies all downtrained Links.  It also
emits messages for a few cases that are technically not downtrained, such
as a x4 device in an open-ended x1 slot.

	Signed-off-by: Alexandru Gagniuc <mr.nuke.me@gmail.com>
[bhelgaas: changelog, move __pcie_print_link_status() declaration to
drivers/pci/, rename pcie_check_upstream_link() to
pcie_report_downtraining()]
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 2d1ce5ec2117d16047334a1aa4b62e0cfb5a0605)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci.c
#	drivers/pci/probe.c
diff --cc drivers/pci/pci.c
index 3a64c5971cef,a84d341504a5..000000000000
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@@ -4901,6 -5264,51 +4901,54 @@@ u32 pcie_bandwidth_capable(struct pci_d
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * __pcie_print_link_status - Report the PCI device's link speed and width
+  * @dev: PCI device to query
+  * @verbose: Print info even when enough bandwidth is available
+  *
+  * If the available bandwidth at the device is less than the device is
+  * capable of, report the device's maximum possible bandwidth and the
+  * upstream link that limits its performance.  If @verbose, always print
+  * the available bandwidth, even if the device isn't constrained.
+  */
+ void __pcie_print_link_status(struct pci_dev *dev, bool verbose)
+ {
+ 	enum pcie_link_width width, width_cap;
+ 	enum pci_bus_speed speed, speed_cap;
+ 	struct pci_dev *limiting_dev = NULL;
+ 	u32 bw_avail, bw_cap;
+ 
+ 	bw_cap = pcie_bandwidth_capable(dev, &speed_cap, &width_cap);
+ 	bw_avail = pcie_bandwidth_available(dev, &limiting_dev, &speed, &width);
+ 
+ 	if (bw_avail >= bw_cap && verbose)
+ 		pci_info(dev, "%u.%03u Gb/s available PCIe bandwidth (%s x%d link)\n",
+ 			 bw_cap / 1000, bw_cap % 1000,
+ 			 PCIE_SPEED2STR(speed_cap), width_cap);
+ 	else if (bw_avail < bw_cap)
+ 		pci_info(dev, "%u.%03u Gb/s available PCIe bandwidth, limited by %s x%d link at %s (capable of %u.%03u Gb/s with %s x%d link)\n",
+ 			 bw_avail / 1000, bw_avail % 1000,
+ 			 PCIE_SPEED2STR(speed), width,
+ 			 limiting_dev ? pci_name(limiting_dev) : "<unknown>",
+ 			 bw_cap / 1000, bw_cap % 1000,
+ 			 PCIE_SPEED2STR(speed_cap), width_cap);
+ }
+ 
+ /**
+  * pcie_print_link_status - Report the PCI device's link speed and width
+  * @dev: PCI device to query
+  *
+  * Report the available bandwidth at the device.
+  */
+ void pcie_print_link_status(struct pci_dev *dev)
+ {
+ 	__pcie_print_link_status(dev, true);
+ }
+ EXPORT_SYMBOL(pcie_print_link_status);
+ 
+ /**
++>>>>>>> 2d1ce5ec2117 (PCI: Check for PCIe Link downtraining)
   * pci_select_bars - Make BAR mask from the type of resource
   * @dev: the PCI device for which BAR mask is made
   * @flags: resource type mask to be selected
diff --cc drivers/pci/probe.c
index 59a917b162c7,71412db3cbeb..000000000000
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@@ -1832,7 -2271,60 +1851,64 @@@ static void pci_init_capabilities(struc
  	/* Enable ACS P2P upstream forwarding */
  	pci_enable_acs(dev);
  
++<<<<<<< HEAD
 +	pci_cleanup_aer_error_status_regs(dev);
++=======
+ 	/* Precision Time Measurement */
+ 	pci_ptm_init(dev);
+ 
+ 	/* Advanced Error Reporting */
+ 	pci_aer_init(dev);
+ 
+ 	pcie_report_downtraining(dev);
+ 
+ 	if (pci_probe_reset_function(dev) == 0)
+ 		dev->reset_fn = 1;
+ }
+ 
+ /*
+  * This is the equivalent of pci_host_bridge_msi_domain() that acts on
+  * devices. Firmware interfaces that can select the MSI domain on a
+  * per-device basis should be called from here.
+  */
+ static struct irq_domain *pci_dev_msi_domain(struct pci_dev *dev)
+ {
+ 	struct irq_domain *d;
+ 
+ 	/*
+ 	 * If a domain has been set through the pcibios_add_device()
+ 	 * callback, then this is the one (platform code knows best).
+ 	 */
+ 	d = dev_get_msi_domain(&dev->dev);
+ 	if (d)
+ 		return d;
+ 
+ 	/*
+ 	 * Let's see if we have a firmware interface able to provide
+ 	 * the domain.
+ 	 */
+ 	d = pci_msi_get_device_domain(dev);
+ 	if (d)
+ 		return d;
+ 
+ 	return NULL;
+ }
+ 
+ static void pci_set_msi_domain(struct pci_dev *dev)
+ {
+ 	struct irq_domain *d;
+ 
+ 	/*
+ 	 * If the platform or firmware interfaces cannot supply a
+ 	 * device-specific MSI domain, then inherit the default domain
+ 	 * from the host bridge itself.
+ 	 */
+ 	d = pci_dev_msi_domain(dev);
+ 	if (!d)
+ 		d = dev_get_msi_domain(&dev->bus->dev);
+ 
+ 	dev_set_msi_domain(&dev->dev, d);
++>>>>>>> 2d1ce5ec2117 (PCI: Check for PCIe Link downtraining)
  }
  
  void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
* Unmerged path drivers/pci/pci.c
diff --git a/drivers/pci/pci.h b/drivers/pci/pci.h
index 4ae994e3c513..e185b47af12d 100644
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@ -269,6 +269,7 @@ enum pci_bus_speed pcie_get_speed_cap(struct pci_dev *dev);
 enum pcie_link_width pcie_get_width_cap(struct pci_dev *dev);
 u32 pcie_bandwidth_capable(struct pci_dev *dev, enum pci_bus_speed *speed,
 			   enum pcie_link_width *width);
+void __pcie_print_link_status(struct pci_dev *dev, bool verbose);
 
 /* Single Root I/O Virtualization */
 struct pci_sriov {
* Unmerged path drivers/pci/probe.c
