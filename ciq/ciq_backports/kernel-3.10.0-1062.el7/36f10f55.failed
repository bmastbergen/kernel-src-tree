fsnotify: let connector point to an abstract object

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 36f10f55ff1d2867bfc48ed898a9cc0dc6b49dd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/36f10f55.failed

Make the code to attach/detach a connector to object more generic
by letting the fsnotify connector point to an abstract fsnotify_connp_t.
Code that needs to dereference an inode or mount object now uses the
helpers fsnotify_conn_{inode,mount}.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 36f10f55ff1d2867bfc48ed898a9cc0dc6b49dd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fdinfo.c
#	fs/notify/fsnotify.h
#	fs/notify/mark.c
#	include/linux/fsnotify_backend.h
diff --cc fs/notify/fdinfo.c
index 3b054e0b60bc,86fcf5814279..000000000000
--- a/fs/notify/fdinfo.c
+++ b/fs/notify/fdinfo.c
@@@ -79,13 -76,12 +79,13 @@@ static int inotify_fdinfo(struct seq_fi
  {
  	struct inotify_inode_mark *inode_mark;
  	struct inode *inode;
 +	int ret = 0;
  
 -	if (mark->connector->type != FSNOTIFY_OBJ_TYPE_INODE)
 -		return;
 +	if (!(mark->connector->flags & FSNOTIFY_OBJ_TYPE_INODE))
 +		return 0;
  
  	inode_mark = container_of(mark, struct inotify_inode_mark, fsn_mark);
- 	inode = igrab(mark->connector->inode);
+ 	inode = igrab(fsnotify_conn_inode(mark->connector));
  	if (inode) {
  		/*
  		 * IN_ALL_EVENTS represents all of the mask bits
@@@ -125,29 -116,25 +125,39 @@@ static int fanotify_fdinfo(struct seq_f
  	if (mark->flags & FSNOTIFY_MARK_FLAG_IGNORED_SURV_MODIFY)
  		mflags |= FAN_MARK_IGNORED_SURV_MODIFY;
  
++<<<<<<< HEAD
 +	if (mark->connector->flags & FSNOTIFY_OBJ_TYPE_INODE) {
 +		inode = igrab(mark->connector->inode);
++=======
+ 	if (mark->connector->type == FSNOTIFY_OBJ_TYPE_INODE) {
+ 		inode = igrab(fsnotify_conn_inode(mark->connector));
++>>>>>>> 36f10f55ff1d (fsnotify: let connector point to an abstract object)
  		if (!inode)
 -			return;
 -		seq_printf(m, "fanotify ino:%lx sdev:%x mflags:%x mask:%x ignored_mask:%x ",
 -			   inode->i_ino, inode->i_sb->s_dev,
 -			   mflags, mark->mask, mark->ignored_mask);
 -		show_mark_fhandle(m, inode);
 -		seq_putc(m, '\n');
 +			goto out;
 +		ret = seq_printf(m, "fanotify ino:%lx sdev:%x "
 +				 "mflags:%x mask:%x ignored_mask:%x ",
 +				 inode->i_ino, inode->i_sb->s_dev,
 +				 mflags, mark->mask, mark->ignored_mask);
 +		ret |= show_mark_fhandle(m, inode);
 +		ret |= seq_putc(m, '\n');
  		iput(inode);
++<<<<<<< HEAD
 +	} else if (mark->connector->flags & FSNOTIFY_OBJ_TYPE_VFSMOUNT) {
 +		struct mount *mnt = real_mount(mark->connector->mnt);
++=======
+ 	} else if (mark->connector->type == FSNOTIFY_OBJ_TYPE_VFSMOUNT) {
+ 		struct mount *mnt = fsnotify_conn_mount(mark->connector);
++>>>>>>> 36f10f55ff1d (fsnotify: let connector point to an abstract object)
  
 -		seq_printf(m, "fanotify mnt_id:%x mflags:%x mask:%x ignored_mask:%x\n",
 -			   mnt->mnt_id, mflags, mark->mask, mark->ignored_mask);
 +		ret = seq_printf(m, "fanotify mnt_id:%x mflags:%x mask:%x "
 +				 "ignored_mask:%x\n", mnt->mnt_id, mflags,
 +				 mark->mask, mark->ignored_mask);
  	}
 +out:
 +	return ret;
  }
  
 -void fanotify_show_fdinfo(struct seq_file *m, struct file *f)
 +int fanotify_show_fdinfo(struct seq_file *m, struct file *f)
  {
  	struct fsnotify_group *group = f->private_data;
  	unsigned int flags = 0;
diff --cc fs/notify/fsnotify.h
index 2ce7101951ac,7902653dd577..000000000000
--- a/fs/notify/fsnotify.h
+++ b/fs/notify/fsnotify.h
@@@ -8,11 -9,17 +8,25 @@@
  
  #include "../mount.h"
  
++<<<<<<< HEAD
 +struct fsnotify_iter_info {
 +	struct fsnotify_mark *inode_mark;
 +	struct fsnotify_mark *vfsmount_mark;
 +	int srcu_idx;
 +};
++=======
+ static inline struct inode *fsnotify_conn_inode(
+ 				struct fsnotify_mark_connector *conn)
+ {
+ 	return container_of(conn->obj, struct inode, i_fsnotify_marks);
+ }
+ 
+ static inline struct mount *fsnotify_conn_mount(
+ 				struct fsnotify_mark_connector *conn)
+ {
+ 	return container_of(conn->obj, struct mount, mnt_fsnotify_marks);
+ }
++>>>>>>> 36f10f55ff1d (fsnotify: let connector point to an abstract object)
  
  /* destroy all events sitting in this groups notification queue */
  extern void fsnotify_flush_notify(struct fsnotify_group *group);
diff --cc fs/notify/mark.c
index 76c708e59bfa,959bc73aaae7..000000000000
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@@ -119,10 -119,10 +119,17 @@@ static void __fsnotify_recalc_mask(stru
  		if (mark->flags & FSNOTIFY_MARK_FLAG_ATTACHED)
  			new_mask |= mark->mask;
  	}
++<<<<<<< HEAD
 +	if (conn->flags & FSNOTIFY_OBJ_TYPE_INODE)
 +		conn->inode->i_fsnotify_mask = new_mask;
 +	else if (conn->flags & FSNOTIFY_OBJ_TYPE_VFSMOUNT)
 +		real_mount(conn->mnt)->mnt_fsnotify_mask = new_mask;
++=======
+ 	if (conn->type == FSNOTIFY_OBJ_TYPE_INODE)
+ 		fsnotify_conn_inode(conn)->i_fsnotify_mask = new_mask;
+ 	else if (conn->type == FSNOTIFY_OBJ_TYPE_VFSMOUNT)
+ 		fsnotify_conn_mount(conn)->mnt_fsnotify_mask = new_mask;
++>>>>>>> 36f10f55ff1d (fsnotify: let connector point to an abstract object)
  }
  
  /*
@@@ -139,8 -139,9 +146,14 @@@ void fsnotify_recalc_mask(struct fsnoti
  	spin_lock(&conn->lock);
  	__fsnotify_recalc_mask(conn);
  	spin_unlock(&conn->lock);
++<<<<<<< HEAD
 +	if (conn->flags & FSNOTIFY_OBJ_TYPE_INODE)
 +		__fsnotify_update_child_dentry_flags(conn->inode);
++=======
+ 	if (conn->type == FSNOTIFY_OBJ_TYPE_INODE)
+ 		__fsnotify_update_child_dentry_flags(
+ 					fsnotify_conn_inode(conn));
++>>>>>>> 36f10f55ff1d (fsnotify: let connector point to an abstract object)
  }
  
  /* Free all connectors queued for freeing once SRCU period ends */
@@@ -166,20 -167,20 +179,35 @@@ static struct inode *fsnotify_detach_co
  {
  	struct inode *inode = NULL;
  
++<<<<<<< HEAD
 +	if (conn->flags & FSNOTIFY_OBJ_TYPE_INODE) {
 +		inode = conn->inode;
 +		rcu_assign_pointer(inode->i_fsnotify_marks, NULL);
 +		inode->i_fsnotify_mask = 0;
 +		conn->inode = NULL;
 +		conn->flags &= ~FSNOTIFY_OBJ_TYPE_INODE;
 +	} else if (conn->flags & FSNOTIFY_OBJ_TYPE_VFSMOUNT) {
 +		rcu_assign_pointer(real_mount(conn->mnt)->mnt_fsnotify_marks,
 +				   NULL);
 +		real_mount(conn->mnt)->mnt_fsnotify_mask = 0;
 +		conn->mnt = NULL;
 +		conn->flags &= ~FSNOTIFY_OBJ_TYPE_VFSMOUNT;
++=======
+ 	if (conn->type == FSNOTIFY_OBJ_TYPE_DETACHED)
+ 		return NULL;
+ 
+ 	if (conn->type == FSNOTIFY_OBJ_TYPE_INODE) {
+ 		inode = fsnotify_conn_inode(conn);
+ 		inode->i_fsnotify_mask = 0;
+ 	} else if (conn->type == FSNOTIFY_OBJ_TYPE_VFSMOUNT) {
+ 		fsnotify_conn_mount(conn)->mnt_fsnotify_mask = 0;
++>>>>>>> 36f10f55ff1d (fsnotify: let connector point to an abstract object)
  	}
  
+ 	rcu_assign_pointer(*(conn->obj), NULL);
+ 	conn->obj = NULL;
+ 	conn->type = FSNOTIFY_OBJ_TYPE_DETACHED;
+ 
  	return inode;
  }
  
@@@ -440,13 -448,10 +468,20 @@@ static int fsnotify_attach_connector_to
  		return -ENOMEM;
  	spin_lock_init(&conn->lock);
  	INIT_HLIST_HEAD(&conn->list);
++<<<<<<< HEAD
 +	if (inode) {
 +		conn->flags = FSNOTIFY_OBJ_TYPE_INODE;
 +		conn->inode = igrab(inode);
 +	} else {
 +		conn->flags = FSNOTIFY_OBJ_TYPE_VFSMOUNT;
 +		conn->mnt = mnt;
 +	}
++=======
+ 	conn->type = type;
+ 	conn->obj = connp;
+ 	if (conn->type == FSNOTIFY_OBJ_TYPE_INODE)
+ 		inode = igrab(fsnotify_conn_inode(conn));
++>>>>>>> 36f10f55ff1d (fsnotify: let connector point to an abstract object)
  	/*
  	 * cmpxchg() provides the barrier so that readers of *connp can see
  	 * only initialized structure
diff --cc include/linux/fsnotify_backend.h
index 6305bebac1c3,381cfb0e67fa..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -200,6 -199,69 +200,13 @@@ struct fsnotify_group 
  #define FSNOTIFY_EVENT_PATH	1
  #define FSNOTIFY_EVENT_INODE	2
  
 -enum fsnotify_obj_type {
 -	FSNOTIFY_OBJ_TYPE_INODE,
 -	FSNOTIFY_OBJ_TYPE_VFSMOUNT,
 -	FSNOTIFY_OBJ_TYPE_COUNT,
 -	FSNOTIFY_OBJ_TYPE_DETACHED = FSNOTIFY_OBJ_TYPE_COUNT
 -};
 -
 -#define FSNOTIFY_OBJ_TYPE_INODE_FL	(1U << FSNOTIFY_OBJ_TYPE_INODE)
 -#define FSNOTIFY_OBJ_TYPE_VFSMOUNT_FL	(1U << FSNOTIFY_OBJ_TYPE_VFSMOUNT)
 -#define FSNOTIFY_OBJ_ALL_TYPES_MASK	((1U << FSNOTIFY_OBJ_TYPE_COUNT) - 1)
 -
 -static inline bool fsnotify_valid_obj_type(unsigned int type)
 -{
 -	return (type < FSNOTIFY_OBJ_TYPE_COUNT);
 -}
 -
 -struct fsnotify_iter_info {
 -	struct fsnotify_mark *marks[FSNOTIFY_OBJ_TYPE_COUNT];
 -	unsigned int report_mask;
 -	int srcu_idx;
 -};
 -
 -static inline bool fsnotify_iter_should_report_type(
 -		struct fsnotify_iter_info *iter_info, int type)
 -{
 -	return (iter_info->report_mask & (1U << type));
 -}
 -
 -static inline void fsnotify_iter_set_report_type(
 -		struct fsnotify_iter_info *iter_info, int type)
 -{
 -	iter_info->report_mask |= (1U << type);
 -}
 -
 -static inline void fsnotify_iter_set_report_type_mark(
 -		struct fsnotify_iter_info *iter_info, int type,
 -		struct fsnotify_mark *mark)
 -{
 -	iter_info->marks[type] = mark;
 -	iter_info->report_mask |= (1U << type);
 -}
 -
 -#define FSNOTIFY_ITER_FUNCS(name, NAME) \
 -static inline struct fsnotify_mark *fsnotify_iter_##name##_mark( \
 -		struct fsnotify_iter_info *iter_info) \
 -{ \
 -	return (iter_info->report_mask & FSNOTIFY_OBJ_TYPE_##NAME##_FL) ? \
 -		iter_info->marks[FSNOTIFY_OBJ_TYPE_##NAME] : NULL; \
 -}
 -
 -FSNOTIFY_ITER_FUNCS(inode, INODE)
 -FSNOTIFY_ITER_FUNCS(vfsmount, VFSMOUNT)
 -
 -#define fsnotify_foreach_obj_type(type) \
 -	for (type = 0; type < FSNOTIFY_OBJ_TYPE_COUNT; type++)
 -
+ /*
+  * fsnotify_connp_t is what we embed in objects which connector can be attached
+  * to. fsnotify_connp_t * is how we refer from connector back to object.
+  */
+ struct fsnotify_mark_connector;
+ typedef struct fsnotify_mark_connector __rcu *fsnotify_connp_t;
+ 
  /*
   * Inode / vfsmount point to this structure which tracks all marks attached to
   * the inode / vfsmount. The reference to inode / vfsmount is held by this
@@@ -208,14 -270,10 +215,21 @@@
   */
  struct fsnotify_mark_connector {
  	spinlock_t lock;
++<<<<<<< HEAD
 +#define FSNOTIFY_OBJ_TYPE_INODE		0x01
 +#define FSNOTIFY_OBJ_TYPE_VFSMOUNT	0x02
 +#define FSNOTIFY_OBJ_ALL_TYPES		(FSNOTIFY_OBJ_TYPE_INODE | \
 +					 FSNOTIFY_OBJ_TYPE_VFSMOUNT)
 +	unsigned int flags;	/* Type of object [lock] */
 +	union {	/* Object pointer [lock] */
 +		struct inode *inode;
 +		struct vfsmount *mnt;
++=======
+ 	unsigned int type;	/* Type of object [lock] */
+ 	union {
+ 		/* Object pointer [lock] */
+ 		fsnotify_connp_t *obj;
++>>>>>>> 36f10f55ff1d (fsnotify: let connector point to an abstract object)
  		/* Used listing heads to free after srcu period expires */
  		struct fsnotify_mark_connector *destroy_next;
  	};
* Unmerged path fs/notify/fdinfo.c
* Unmerged path fs/notify/fsnotify.h
* Unmerged path fs/notify/mark.c
* Unmerged path include/linux/fsnotify_backend.h
diff --git a/kernel/audit_tree.c b/kernel/audit_tree.c
index 6d67b66d8484..34b77514ed92 100644
--- a/kernel/audit_tree.c
+++ b/kernel/audit_tree.c
@@ -165,7 +165,8 @@ static __cacheline_aligned_in_smp DEFINE_SPINLOCK(hash_lock);
 /* Function to return search key in our hash from inode. */
 static unsigned long inode_to_key(const struct inode *inode)
 {
-	return (unsigned long)inode;
+	/* Use address pointed to by connector->obj as the key */
+	return (unsigned long)&inode->i_fsnotify_marks;
 }
 
 /*
@@ -180,7 +181,7 @@ static unsigned long chunk_to_key(struct audit_chunk *chunk)
 	 */
 	if (WARN_ON_ONCE(!chunk->mark.connector))
 		return 0;
-	return (unsigned long)chunk->mark.connector->inode;
+	return (unsigned long)chunk->mark.connector->obj;
 }
 
 static inline struct list_head *chunk_hash(unsigned long key)
@@ -255,7 +256,7 @@ static void untag_chunk(struct node *p)
 	spin_lock(&entry->lock);
 	/*
 	 * mark_mutex protects mark from getting detached and thus also from
-	 * mark->connector->inode getting NULL.
+	 * mark->connector->obj getting NULL.
 	 */
 	if (chunk->dead || !(entry->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {
 		spin_unlock(&entry->lock);
@@ -285,8 +286,8 @@ static void untag_chunk(struct node *p)
 	if (!new)
 		goto Fallback;
 
-	if (fsnotify_add_inode_mark_locked(&new->mark, entry->connector->inode,
-					   1)) {
+	if (fsnotify_add_mark_locked(&new->mark, entry->connector->obj,
+				     FSNOTIFY_OBJ_TYPE_INODE, 1)) {
 		fsnotify_put_mark(&new->mark);
 		goto Fallback;
 	}
@@ -420,7 +421,7 @@ static int tag_chunk(struct inode *inode, struct audit_tree *tree)
 	spin_lock(&old_entry->lock);
 	/*
 	 * mark_mutex protects mark from getting detached and thus also from
-	 * mark->connector->inode getting NULL.
+	 * mark->connector->obj getting NULL.
 	 */
 	if (!(old_entry->flags & FSNOTIFY_MARK_FLAG_ATTACHED)) {
 		/* old_entry is being shot, lets just lie */
@@ -431,8 +432,8 @@ static int tag_chunk(struct inode *inode, struct audit_tree *tree)
 		return -ENOENT;
 	}
 
-	if (fsnotify_add_inode_mark_locked(chunk_entry,
-			     old_entry->connector->inode, 1)) {
+	if (fsnotify_add_mark_locked(chunk_entry, old_entry->connector->obj,
+				     FSNOTIFY_OBJ_TYPE_INODE, 1)) {
 		spin_unlock(&old_entry->lock);
 		mutex_unlock(&old_entry->group->mark_mutex);
 		fsnotify_put_mark(chunk_entry);
