tls: RX path for ktls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Dave Watson <davejwatson@fb.com>
commit c46234ebb4d1eee5e09819f49169e51cfc6eb909
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c46234eb.failed

Add rx path for tls software implementation.

recvmsg, splice_read, and poll implemented.

An additional sockopt TLS_RX is added, with the same interface as
TLS_TX.  Either TLX_RX or TLX_TX may be provided separately, or
together (with two different setsockopt calls with appropriate keys).

Control messages are passed via CMSG in a similar way to transmit.
If no cmsg buffer is passed, then only application data records
will be passed to userspace, and EIO is returned for other types of
alerts.

EBADMSG is passed for decryption errors, and EMSGSIZE is passed for
framing too big, and EBADMSG for framing too small (matching openssl
semantics). EINVAL is returned for TLS versions that do not match the
original setsockopt call.  All are unrecoverable.

strparser is used to parse TLS framing.   Decryption is done directly
in to userspace buffers if they are large enough to support it, otherwise
sk_cow_data is called (similar to ipsec), and buffers are decrypted in
place and copied.  splice_read always decrypts in place, since no
buffers are provided to decrypt in to.

sk_poll is overridden, and only returns POLLIN if a full TLS message is
received.  Otherwise we wait for strparser to finish reading a full frame.
Actual decryption is only done during recvmsg or splice_read calls.

	Signed-off-by: Dave Watson <davejwatson@fb.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c46234ebb4d1eee5e09819f49169e51cfc6eb909)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/amso1100/c2_user.h
#	include/net/tls.h
#	net/tls/Kconfig
#	net/tls/tls_main.c
#	net/tls/tls_sw.c
diff --cc drivers/infiniband/hw/amso1100/c2_user.h
index 7e9e7ad65467,c6633e97eca4..000000000000
--- a/drivers/infiniband/hw/amso1100/c2_user.h
+++ b/drivers/infiniband/hw/amso1100/c2_user.h
@@@ -38,45 -36,43 +38,77 @@@
  
  #include <linux/types.h>
  
++<<<<<<< HEAD:drivers/infiniband/hw/amso1100/c2_user.h
 +/*
 + * Make sure that all structs defined in this file remain laid out so
 + * that they pack the same way on 32-bit and 64-bit architectures (to
 + * avoid incompatibility between 32-bit userspace and 64-bit kernels).
 + * In particular do not use pointer types -- pass pointers in __u64
 + * instead.
 + */
 +
 +struct c2_alloc_ucontext_resp {
 +	__u32 qp_tab_size;
 +	__u32 uarc_size;
++=======
+ /* TLS socket options */
+ #define TLS_TX			1	/* Set transmit parameters */
+ #define TLS_RX			2	/* Set receive parameters */
+ 
+ /* Supported versions */
+ #define TLS_VERSION_MINOR(ver)	((ver) & 0xFF)
+ #define TLS_VERSION_MAJOR(ver)	(((ver) >> 8) & 0xFF)
+ 
+ #define TLS_VERSION_NUMBER(id)	((((id##_VERSION_MAJOR) & 0xFF) << 8) |	\
+ 				 ((id##_VERSION_MINOR) & 0xFF))
+ 
+ #define TLS_1_2_VERSION_MAJOR	0x3
+ #define TLS_1_2_VERSION_MINOR	0x3
+ #define TLS_1_2_VERSION		TLS_VERSION_NUMBER(TLS_1_2)
+ 
+ /* Supported ciphers */
+ #define TLS_CIPHER_AES_GCM_128				51
+ #define TLS_CIPHER_AES_GCM_128_IV_SIZE			8
+ #define TLS_CIPHER_AES_GCM_128_KEY_SIZE		16
+ #define TLS_CIPHER_AES_GCM_128_SALT_SIZE		4
+ #define TLS_CIPHER_AES_GCM_128_TAG_SIZE		16
+ #define TLS_CIPHER_AES_GCM_128_REC_SEQ_SIZE		8
+ 
+ #define TLS_SET_RECORD_TYPE	1
+ #define TLS_GET_RECORD_TYPE	2
+ 
+ struct tls_crypto_info {
+ 	__u16 version;
+ 	__u16 cipher_type;
++>>>>>>> c46234ebb4d1 (tls: RX path for ktls):include/uapi/linux/tls.h
 +};
 +
 +struct c2_alloc_pd_resp {
 +	__u32 pdn;
 +	__u32 reserved;
 +};
 +
 +struct c2_create_cq {
 +	__u32 lkey;
 +	__u32 pdn;
 +	__u64 arm_db_page;
 +	__u64 set_db_page;
 +	__u32 arm_db_index;
 +	__u32 set_db_index;
 +};
 +
 +struct c2_create_cq_resp {
 +	__u32 cqn;
 +	__u32 reserved;
  };
  
 -struct tls12_crypto_info_aes_gcm_128 {
 -	struct tls_crypto_info info;
 -	unsigned char iv[TLS_CIPHER_AES_GCM_128_IV_SIZE];
 -	unsigned char key[TLS_CIPHER_AES_GCM_128_KEY_SIZE];
 -	unsigned char salt[TLS_CIPHER_AES_GCM_128_SALT_SIZE];
 -	unsigned char rec_seq[TLS_CIPHER_AES_GCM_128_REC_SEQ_SIZE];
 +struct c2_create_qp {
 +	__u32 lkey;
 +	__u32 reserved;
 +	__u64 sq_db_page;
 +	__u64 rq_db_page;
 +	__u32 sq_db_index;
 +	__u32 rq_db_index;
  };
  
 -#endif /* _UAPI_LINUX_TLS_H */
 +#endif				/* C2_USER_H */
* Unmerged path include/net/tls.h
* Unmerged path net/tls/Kconfig
* Unmerged path net/tls/tls_main.c
* Unmerged path net/tls/tls_sw.c
* Unmerged path drivers/infiniband/hw/amso1100/c2_user.h
* Unmerged path include/net/tls.h
* Unmerged path net/tls/Kconfig
* Unmerged path net/tls/tls_main.c
* Unmerged path net/tls/tls_sw.c
