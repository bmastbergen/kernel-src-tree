asm-generic/io.h: Reconcile I/O accessor overrides

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Thierry Reding <treding@nvidia.com>
commit 9216efafc52ff99e9351ef60de5fcafc2bc8adb6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9216efaf.failed

Overriding I/O accessors and helpers is currently very inconsistent.
This commit introduces a homogeneous way to override functions by
checking for the existence of a macro with the same of the function.
Architectures can provide their own implementations and communicate this
to the generic header by defining the appropriate macro. Doing this will
also help prevent the implementations from being subsequently
overridden.

While at it, also turn a lot of macros into static inline functions for
better type checking and to provide a canonical signature for overriding
architectures to copy. Also reorder functions by logical groups.

	Signed-off-by: Thierry Reding <treding@nvidia.com>
(cherry picked from commit 9216efafc52ff99e9351ef60de5fcafc2bc8adb6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/asm-generic/io.h
diff --cc include/asm-generic/io.h
index 66a3fecbf792,fb62c621acf9..000000000000
--- a/include/asm-generic/io.h
+++ b/include/asm-generic/io.h
@@@ -52,140 -57,122 +57,195 @@@ static inline u32 __raw_readl(const vol
  }
  #endif
  
++<<<<<<< HEAD
 +#define readb __raw_readb
 +#ifndef readb_relaxed
 +#define readb_relaxed readb
 +#endif
++=======
+ #ifdef CONFIG_64BIT
+ #ifndef __raw_readq
+ #define __raw_readq __raw_readq
+ static inline u64 __raw_readq(const volatile void __iomem *addr)
+ {
+ 	return *(const volatile u64 __force *)addr;
+ }
+ #endif
+ #endif /* CONFIG_64BIT */
++>>>>>>> 9216efafc52f (asm-generic/io.h: Reconcile I/O accessor overrides)
  
+ #ifndef __raw_writeb
+ #define __raw_writeb __raw_writeb
+ static inline void __raw_writeb(u8 value, volatile void __iomem *addr)
+ {
+ 	*(volatile u8 __force *)addr = value;
+ }
+ #endif
+ 
+ #ifndef __raw_writew
+ #define __raw_writew __raw_writew
+ static inline void __raw_writew(u16 value, volatile void __iomem *addr)
+ {
+ 	*(volatile u16 __force *)addr = value;
+ }
+ #endif
+ 
+ #ifndef __raw_writel
+ #define __raw_writel __raw_writel
+ static inline void __raw_writel(u32 value, volatile void __iomem *addr)
+ {
+ 	*(volatile u32 __force *)addr = value;
+ }
+ #endif
+ 
+ #ifdef CONFIG_64BIT
+ #ifndef __raw_writeq
+ #define __raw_writeq __raw_writeq
+ static inline void __raw_writeq(u64 value, volatile void __iomem *addr)
+ {
+ 	*(volatile u64 __force *)addr = value;
+ }
+ #endif
+ #endif /* CONFIG_64BIT */
+ 
+ /*
+  * {read,write}{b,w,l,q}() access little endian memory and return result in
+  * native endianness.
+  */
+ 
+ #ifndef readb
+ #define readb readb
+ static inline u8 readb(const volatile void __iomem *addr)
+ {
+ 	return __raw_readb(addr);
+ }
+ #endif
+ 
+ #ifndef readw
  #define readw readw
  static inline u16 readw(const volatile void __iomem *addr)
  {
  	return __le16_to_cpu(__raw_readw(addr));
  }
++<<<<<<< HEAD
 +#ifndef readw_relaxed
 +#define readw_relaxed readw
++=======
++>>>>>>> 9216efafc52f (asm-generic/io.h: Reconcile I/O accessor overrides)
  #endif
  
+ #ifndef readl
  #define readl readl
  static inline u32 readl(const volatile void __iomem *addr)
  {
  	return __le32_to_cpu(__raw_readl(addr));
  }
++<<<<<<< HEAD
 +#ifndef readl_relaxed
 +#define readl_relaxed readl
 +#endif
 +
 +#ifndef __raw_writeb
 +static inline void __raw_writeb(u8 b, volatile void __iomem *addr)
 +{
 +	*(volatile u8 __force *) addr = b;
 +}
 +#endif
 +
 +#ifndef __raw_writew
 +static inline void __raw_writew(u16 b, volatile void __iomem *addr)
 +{
 +	*(volatile u16 __force *) addr = b;
 +}
 +#endif
 +
 +#ifndef __raw_writel
 +static inline void __raw_writel(u32 b, volatile void __iomem *addr)
 +{
 +	*(volatile u32 __force *) addr = b;
 +}
  #endif
  
 +#define writeb __raw_writeb
 +#ifndef writeb_relaxed
 +#define writeb_relaxed writeb
 +#endif
 +
 +#define writew(b,addr) __raw_writew(__cpu_to_le16(b),addr)
 +#ifndef writew_relaxed
 +#define writew_relaxed writew
 +#endif
 +
 +#define writel(b,addr) __raw_writel(__cpu_to_le32(b),addr)
 +#ifndef writel_relaxed
 +#define writel_relaxed writel
 +#endif
 +
- #ifdef CONFIG_64BIT
- #ifndef __raw_readq
- static inline u64 __raw_readq(const volatile void __iomem *addr)
- {
- 	return *(const volatile u64 __force *) addr;
- }
++=======
 +#endif
 +
++>>>>>>> 9216efafc52f (asm-generic/io.h: Reconcile I/O accessor overrides)
+ #ifdef CONFIG_64BIT
+ #ifndef readq
  #define readq readq
  static inline u64 readq(const volatile void __iomem *addr)
  {
  	return __le64_to_cpu(__raw_readq(addr));
  }
++<<<<<<< HEAD
 +#ifndef readq_relaxed
 +#define readq_relaxed readq
 +#endif
 +
 +#ifndef __raw_writeq
 +static inline void __raw_writeq(u64 b, volatile void __iomem *addr)
 +{
 +	*(volatile u64 __force *) addr = b;
 +}
 +#endif
 +
 +#define writeq(b, addr) __raw_writeq(__cpu_to_le64(b), addr)
 +#ifndef writeq_relaxed
 +#define writeq_relaxed writeq
 +#endif
- #endif /* CONFIG_64BIT */
- 
- #ifndef PCI_IOBASE
- #define PCI_IOBASE ((void __iomem *) 0)
++=======
  #endif
++>>>>>>> 9216efafc52f (asm-generic/io.h: Reconcile I/O accessor overrides)
+ #endif /* CONFIG_64BIT */
  
- /*****************************************************************************/
- /*
-  * traditional input/output functions
-  */
- 
- static inline u8 inb(unsigned long addr)
- {
- 	return readb(addr + PCI_IOBASE);
- }
- 
- static inline u16 inw(unsigned long addr)
- {
- 	return readw(addr + PCI_IOBASE);
- }
- 
- static inline u32 inl(unsigned long addr)
+ #ifndef writeb
+ #define writeb writeb
+ static inline void writeb(u8 value, volatile void __iomem *addr)
  {
- 	return readl(addr + PCI_IOBASE);
+ 	__raw_writeb(value, addr);
  }
+ #endif
  
- static inline void outb(u8 b, unsigned long addr)
+ #ifndef writew
+ #define writew writew
+ static inline void writew(u16 value, volatile void __iomem *addr)
  {
- 	writeb(b, addr + PCI_IOBASE);
+ 	__raw_writew(cpu_to_le16(value), addr);
  }
+ #endif
  
- static inline void outw(u16 b, unsigned long addr)
+ #ifndef writel
+ #define writel writel
+ static inline void writel(u32 value, volatile void __iomem *addr)
  {
- 	writew(b, addr + PCI_IOBASE);
+ 	__raw_writel(__cpu_to_le32(value), addr);
  }
+ #endif
  
- static inline void outl(u32 b, unsigned long addr)
+ #ifdef CONFIG_64BIT
+ #ifndef writeq
+ #define writeq writeq
+ static inline void writeq(u64 value, volatile void __iomem *addr)
  {
- 	writel(b, addr + PCI_IOBASE);
+ 	__raw_writeq(__cpu_to_le64(value), addr);
  }
- 
- #define inb_p(addr)	inb(addr)
- #define inw_p(addr)	inw(addr)
- #define inl_p(addr)	inl(addr)
- #define outb_p(x, addr)	outb((x), (addr))
- #define outw_p(x, addr)	outw((x), (addr))
- #define outl_p(x, addr)	outl((x), (addr))
+ #endif
+ #endif /* CONFIG_64BIT */
  
  #ifndef insb
  static inline void insb(unsigned long addr, void *buffer, int count)
@@@ -351,10 -540,13 +613,13 @@@ static inline void __iomem *ioremap_wc(
  static inline void iounmap(void __iomem *addr)
  {
  }
+ #endif
  #endif /* CONFIG_MMU */
  
 -#ifdef CONFIG_HAS_IOPORT_MAP
 +#ifdef CONFIG_HAS_IOPORT
  #ifndef CONFIG_GENERIC_IOMAP
+ #ifndef ioport_map
+ #define ioport_map ioport_map
  static inline void __iomem *ioport_map(unsigned long port, unsigned int nr)
  {
  	return PCI_IOBASE + (port & IO_SPACE_LIMIT);
@@@ -367,13 -563,29 +636,29 @@@ static inline void ioport_unmap(void __
  extern void __iomem *ioport_map(unsigned long port, unsigned int nr);
  extern void ioport_unmap(void __iomem *p);
  #endif /* CONFIG_GENERIC_IOMAP */
 -#endif /* CONFIG_HAS_IOPORT_MAP */
 +#endif /* CONFIG_HAS_IOPORT */
  
  #ifndef xlate_dev_kmem_ptr
- #define xlate_dev_kmem_ptr(p)	p
+ #define xlate_dev_kmem_ptr xlate_dev_kmem_ptr
+ static inline void *xlate_dev_kmem_ptr(void *addr)
+ {
+ 	return addr;
+ }
  #endif
+ 
  #ifndef xlate_dev_mem_ptr
- #define xlate_dev_mem_ptr(p)	__va(p)
+ #define xlate_dev_mem_ptr xlate_dev_mem_ptr
+ static inline void *xlate_dev_mem_ptr(phys_addr_t addr)
+ {
+ 	return __va(addr);
+ }
+ #endif
+ 
+ #ifndef unxlate_dev_mem_ptr
+ #define unxlate_dev_mem_ptr unxlate_dev_mem_ptr
+ static inline void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr)
+ {
+ }
  #endif
  
  #ifdef CONFIG_VIRT_TO_BUS
* Unmerged path include/asm-generic/io.h
