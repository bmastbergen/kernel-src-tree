ovl: decode pure upper file handles

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 8556a4205b111c4dac931ee5eba4fcce74c3cb21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/8556a420.failed

Decoding an upper file handle is done by decoding the upper dentry from
underlying upper fs, finding or allocating an overlay inode that is
hashed by the real upper inode and instantiating an overlay dentry with
that inode.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 8556a4205b111c4dac931ee5eba4fcce74c3cb21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/export.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
diff --cc fs/overlayfs/namei.c
index 5e444838b3c6,a35c5eaa2c01..000000000000
--- a/fs/overlayfs/namei.c
+++ b/fs/overlayfs/namei.c
@@@ -84,15 -85,54 +84,26 @@@ invalid
  
  static int ovl_acceptable(void *ctx, struct dentry *dentry)
  {
 -	/*
 -	 * A non-dir origin may be disconnected, which is fine, because
 -	 * we only need it for its unique inode number.
 -	 */
 -	if (!d_is_dir(dentry))
 -		return 1;
 -
 -	/* Don't decode a deleted empty directory */
 -	if (d_unhashed(dentry))
 -		return 0;
 -
 -	/* Check if directory belongs to the layer we are decoding from */
 -	return is_subdir(dentry, ((struct vfsmount *)ctx)->mnt_root);
 +	return 1;
  }
  
++<<<<<<< HEAD
 +static struct ovl_fh *ovl_get_origin_fh(struct dentry *dentry)
++=======
+ /*
+  * Check validity of an overlay file handle buffer.
+  *
+  * Return 0 for a valid file handle.
+  * Return -ENODATA for "origin unknown".
+  * Return <0 for an invalid file handle.
+  */
+ int ovl_check_fh_len(struct ovl_fh *fh, int fh_len)
++>>>>>>> 8556a4205b11 (ovl: decode pure upper file handles)
  {
 -	if (fh_len < sizeof(struct ovl_fh) || fh_len < fh->len)
 -		return -EINVAL;
 -
 -	if (fh->magic != OVL_FH_MAGIC)
 -		return -EINVAL;
 -
 -	/* Treat larger version and unknown flags as "origin unknown" */
 -	if (fh->version > OVL_FH_VERSION || fh->flags & ~OVL_FH_FLAG_ALL)
 -		return -ENODATA;
 -
 -	/* Treat endianness mismatch as "origin unknown" */
 -	if (!(fh->flags & OVL_FH_FLAG_ANY_ENDIAN) &&
 -	    (fh->flags & OVL_FH_FLAG_BIG_ENDIAN) != OVL_FH_FLAG_CPU_ENDIAN)
 -		return -ENODATA;
 -
 -	return 0;
 -}
 -
 -static struct ovl_fh *ovl_get_fh(struct dentry *dentry, const char *name)
 -{
 -	int res, err;
 +	int res;
  	struct ovl_fh *fh = NULL;
  
 -	res = vfs_getxattr(dentry, name, NULL, 0);
 +	res = vfs_getxattr(dentry, OVL_XATTR_ORIGIN, NULL, 0);
  	if (res < 0) {
  		if (res == -ENODATA || res == -EOPNOTSUPP)
  			return NULL;
@@@ -139,16 -171,11 +150,20 @@@ invalid
  	goto out;
  }
  
++<<<<<<< HEAD
 +static struct dentry *ovl_get_origin(struct dentry *dentry,
 +				     struct vfsmount *mnt)
++=======
+ struct dentry *ovl_decode_fh(struct ovl_fh *fh, struct vfsmount *mnt)
++>>>>>>> 8556a4205b11 (ovl: decode pure upper file handles)
  {
 -	struct dentry *real;
 +	struct dentry *origin = NULL;
 +	struct ovl_fh *fh = ovl_get_origin_fh(dentry);
  	int bytes;
  
 +	if (IS_ERR_OR_NULL(fh))
 +		return (struct dentry *)fh;
 +
  	/*
  	 * Make sure that the stored uuid matches the uuid of the lower
  	 * layer where file handle will be decoded.
diff --cc fs/overlayfs/overlayfs.h
index 403c48960f89,401113a2e9c7..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -247,15 -264,30 +247,23 @@@ static inline bool ovl_is_impuredir(str
  
  
  /* namei.c */
++<<<<<<< HEAD
 +int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 +		      struct dentry *origin, bool is_upper, bool set);
 +int ovl_verify_index(struct dentry *index, struct path *lowerstack,
 +		     unsigned int numlower);
++=======
+ int ovl_check_fh_len(struct ovl_fh *fh, int fh_len);
+ struct dentry *ovl_decode_fh(struct ovl_fh *fh, struct vfsmount *mnt);
+ int ovl_verify_set_fh(struct dentry *dentry, const char *name,
+ 		      struct dentry *real, bool is_upper, bool set);
+ int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
++>>>>>>> 8556a4205b11 (ovl: decode pure upper file handles)
  int ovl_get_index_name(struct dentry *origin, struct qstr *name);
 -struct dentry *ovl_get_index_fh(struct ovl_fs *ofs, struct ovl_fh *fh);
  int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 -struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 -			  unsigned int flags);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
  bool ovl_lower_positive(struct dentry *dentry);
  
 -static inline int ovl_verify_origin(struct dentry *upper,
 -				    struct dentry *origin, bool set)
 -{
 -	return ovl_verify_set_fh(upper, OVL_XATTR_ORIGIN, origin, false, set);
 -}
 -
 -static inline int ovl_verify_upper(struct dentry *index,
 -				    struct dentry *upper, bool set)
 -{
 -	return ovl_verify_set_fh(index, OVL_XATTR_UPPER, upper, true, set);
 -}
 -
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
  int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
