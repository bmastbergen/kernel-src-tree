net/mlx5e: Use pcie_bandwidth_available() to compute bandwidth

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Use pcie_bandwidth_available() to compute bandwidth (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 96.67%
commit-author Tal Gilboa <talgi@mellanox.com>
commit 33523a361307c097a8a23f3549cb485db5fba6c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/33523a36.failed

Use the new pci_bandwidth_available() function to calculate maximum
available bandwidth through the PCI chain instead of computing it ourselves
with mlx5e_get_pci_bw().

This is used to detect when the device is capable of more bandwidth than is
available in the current slot.  The driver may adjust compression settings
accordingly.

Note that pci_bandwidth_available() accounts for PCIe encoding overhead, so
it is more accurate than mlx5e_get_pci_bw() was.

	Signed-off-by: Tal Gilboa <talgi@mellanox.com>
[bhelgaas: remove mlx5e_get_pci_bw() wrapper altogether]
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Tariq Toukan <tariqt@mellanox.com>
(cherry picked from commit 33523a361307c097a8a23f3549cb485db5fba6c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 257706f992fc,93291ec4a3d1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -3921,50 -3864,16 +3921,54 @@@ void mlx5e_build_default_indir_rqt(u32 
  		indirection_rqt[i] = i % num_channels;
  }
  
 -static bool cqe_compress_heuristic(u32 link_speed, u32 pci_bw)
++<<<<<<< HEAD
 +static int mlx5e_get_pci_bw(struct mlx5_core_dev *mdev, u32 *pci_bw)
  {
 -	return (link_speed && pci_bw &&
 -		(pci_bw < 40000) && (pci_bw < link_speed));
 +	enum pcie_link_width width;
 +	enum pci_bus_speed speed;
 +	int err = 0;
 +
 +	err = pcie_get_minimum_link(mdev->pdev, &speed, &width);
 +	if (err)
 +		return err;
 +
 +	if (speed == PCI_SPEED_UNKNOWN || width == PCIE_LNK_WIDTH_UNKNOWN)
 +		return -EINVAL;
 +
 +	switch (speed) {
 +	case PCIE_SPEED_2_5GT:
 +		*pci_bw = 2500 * width;
 +		break;
 +	case PCIE_SPEED_5_0GT:
 +		*pci_bw = 5000 * width;
 +		break;
 +	case PCIE_SPEED_8_0GT:
 +		*pci_bw = 8000 * width;
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
 +	return 0;
  }
  
 -static bool hw_lro_heuristic(u32 link_speed, u32 pci_bw)
 +static bool slow_pci_heuristic(struct mlx5_core_dev *mdev)
++=======
++static bool cqe_compress_heuristic(u32 link_speed, u32 pci_bw)
++>>>>>>> 33523a361307 (net/mlx5e: Use pcie_bandwidth_available() to compute bandwidth)
  {
 -	return !(link_speed && pci_bw &&
 -		 (pci_bw <= 16000) && (pci_bw < link_speed));
 +	u32 link_speed = 0;
 +	u32 pci_bw = 0;
 +
 +	mlx5e_get_max_linkspeed(mdev, &link_speed);
 +	mlx5e_get_pci_bw(mdev, &pci_bw);
 +	mlx5_core_dbg_once(mdev, "Max link speed = %d, PCI BW = %d\n",
 +			   link_speed, pci_bw);
 +
 +#define MLX5E_SLOW_PCI_RATIO (2)
 +
 +	return link_speed && pci_bw &&
 +		link_speed > MLX5E_SLOW_PCI_RATIO * pci_bw;
  }
  
  void mlx5e_set_tx_cq_mode_params(struct mlx5e_params *params, u8 cq_period_mode)
@@@ -4042,6 -3948,11 +4046,14 @@@ void mlx5e_build_nic_params(struct mlx5
  	params->num_channels = max_channels;
  	params->num_tc       = 1;
  
++<<<<<<< HEAD
++=======
+ 	mlx5e_get_max_linkspeed(mdev, &link_speed);
+ 	pci_bw = pcie_bandwidth_available(mdev->pdev, NULL, NULL, NULL);
+ 	mlx5_core_dbg(mdev, "Max link speed = %d, PCI BW = %d\n",
+ 		      link_speed, pci_bw);
+ 
++>>>>>>> 33523a361307 (net/mlx5e: Use pcie_bandwidth_available() to compute bandwidth)
  	/* SQ */
  	params->log_sq_size = is_kdump_kernel() ?
  		MLX5E_PARAMS_MINIMUM_LOG_SQ_SIZE :
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
