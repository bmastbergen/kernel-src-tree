iavf: rename i40e_status to iavf_status

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit 0b6591e6463bf092080647e989bb541d0787eac6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0b6591e6.failed

This is just a rename of an internal variable i40e_status, but
it was a pretty big change and so deserved it's own patch.

	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 0b6591e6463bf092080647e989bb541d0787eac6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40evf/i40e_adminq.c
#	drivers/net/ethernet/intel/i40evf/i40e_common.c
#	drivers/net/ethernet/intel/i40evf/i40evf_client.c
#	drivers/net/ethernet/intel/i40evf/i40evf_main.c
#	drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
#	drivers/net/ethernet/intel/iavf/i40e_prototype.h
#	drivers/net/ethernet/intel/iavf/i40evf.h
diff --cc drivers/net/ethernet/intel/i40evf/i40e_adminq.c
index 21a0dbf6ccf6,c6da41e65439..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_adminq.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_adminq.c
@@@ -515,9 -507,9 +517,13 @@@ shutdown_arq_out
   *     - hw->aq.arq_buf_size
   *     - hw->aq.asq_buf_size
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +i40e_status i40evf_init_adminq(struct i40e_hw *hw)
++=======
+ iavf_status iavf_init_adminq(struct i40e_hw *hw)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
- 	i40e_status ret_code;
+ 	iavf_status ret_code;
  
  	/* verify input for valid configuration */
  	if ((hw->aq.num_arq_entries == 0) ||
@@@ -556,15 -548,15 +562,19 @@@ init_adminq_exit
  }
  
  /**
 - *  iavf_shutdown_adminq - shutdown routine for the Admin Queue
 + *  i40evf_shutdown_adminq - shutdown routine for the Admin Queue
   *  @hw: pointer to the hardware structure
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +i40e_status i40evf_shutdown_adminq(struct i40e_hw *hw)
++=======
+ iavf_status iavf_shutdown_adminq(struct i40e_hw *hw)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
- 	i40e_status ret_code = 0;
+ 	iavf_status ret_code = 0;
  
 -	if (iavf_check_asq_alive(hw))
 -		iavf_aq_queue_shutdown(hw, true);
 +	if (i40evf_check_asq_alive(hw))
 +		i40evf_aq_queue_shutdown(hw, true);
  
  	i40e_shutdown_asq(hw);
  	i40e_shutdown_arq(hw);
@@@ -643,13 -631,13 +652,21 @@@ bool i40evf_asq_done(struct i40e_hw *hw
   *  This is the main send command driver routine for the Admin Queue send
   *  queue.  It runs the queue, cleans the queue, etc
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +i40e_status i40evf_asq_send_command(struct i40e_hw *hw,
 +				struct i40e_aq_desc *desc,
 +				void *buff, /* can be NULL */
 +				u16  buff_size,
 +				struct i40e_asq_cmd_details *cmd_details)
++=======
+ iavf_status iavf_asq_send_command(struct i40e_hw *hw,
+ 				  struct i40e_aq_desc *desc,
+ 				  void *buff, /* can be NULL */
+ 				  u16  buff_size,
+ 				  struct i40e_asq_cmd_details *cmd_details)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
- 	i40e_status status = 0;
+ 	iavf_status status = 0;
  	struct i40e_dma_mem *dma_buff = NULL;
  	struct i40e_asq_cmd_details *details;
  	struct i40e_aq_desc *desc_on_ring;
@@@ -780,9 -768,9 +797,9 @@@
  	}
  
  	/* if ready, copy the desc back to temp */
 -	if (iavf_asq_done(hw)) {
 +	if (i40evf_asq_done(hw)) {
  		*desc = *desc_on_ring;
- 		if (buff != NULL)
+ 		if (buff)
  			memcpy(buff, dma_buff->va, buff_size);
  		retval = le16_to_cpu(desc->retval);
  		if (retval != 0) {
@@@ -806,8 -794,7 +823,12 @@@
  
  	i40e_debug(hw, I40E_DEBUG_AQ_MESSAGE,
  		   "AQTX: desc and buffer writeback:\n");
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +	i40evf_debug_aq(hw, I40E_DEBUG_AQ_COMMAND, (void *)desc, buff,
 +			buff_size);
++=======
+ 	iavf_debug_aq(hw, I40E_DEBUG_AQ_COMMAND, (void *)desc, buff, buff_size);
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  
  	/* save writeback aq if requested */
  	if (details->wb_desc)
@@@ -839,8 -826,7 +860,12 @@@ asq_send_command_error
   *
   *  Fill the desc with default values
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +void i40evf_fill_default_direct_cmd_desc(struct i40e_aq_desc *desc,
 +				       u16 opcode)
++=======
+ void iavf_fill_default_direct_cmd_desc(struct i40e_aq_desc *desc, u16 opcode)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
  	/* zero out the desc */
  	memset((void *)desc, 0, sizeof(struct i40e_aq_desc));
@@@ -858,13 -844,13 +883,19 @@@
   *  the contents through e.  It can also return how many events are
   *  left to process through 'pending'
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_adminq.c
 +i40e_status i40evf_clean_arq_element(struct i40e_hw *hw,
 +					     struct i40e_arq_event_info *e,
 +					     u16 *pending)
++=======
+ iavf_status iavf_clean_arq_element(struct i40e_hw *hw,
+ 				   struct i40e_arq_event_info *e,
+ 				   u16 *pending)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_adminq.c
  {
- 	i40e_status ret_code = 0;
  	u16 ntc = hw->aq.arq.next_to_clean;
  	struct i40e_aq_desc *desc;
+ 	iavf_status ret_code = 0;
  	struct i40e_dma_mem *bi;
  	u16 desc_idx;
  	u16 datalen;
diff --cc drivers/net/ethernet/intel/i40evf/i40e_common.c
index eea280ba411e,96133efddf72..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40evf/i40e_common.c
@@@ -126,7 -125,7 +125,11 @@@ const char *i40evf_aq_str(struct i40e_h
   * @hw: pointer to the HW structure
   * @stat_err: the status error code to convert
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +const char *i40evf_stat_str(struct i40e_hw *hw, i40e_status stat_err)
++=======
+ const char *iavf_stat_str(struct i40e_hw *hw, iavf_status stat_err)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	switch (stat_err) {
  	case 0:
@@@ -349,16 -348,14 +352,24 @@@ bool i40evf_check_asq_alive(struct i40e
   * Tell the Firmware that we're shutting down the AdminQ and whether
   * or not the driver is unloading as well.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40evf_aq_queue_shutdown(struct i40e_hw *hw,
 +					     bool unloading)
++=======
+ iavf_status iavf_aq_queue_shutdown(struct i40e_hw *hw, bool unloading)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	struct i40e_aq_desc desc;
  	struct i40e_aqc_queue_shutdown *cmd =
  		(struct i40e_aqc_queue_shutdown *)&desc.params.raw;
- 	i40e_status status;
+ 	iavf_status status;
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +	i40evf_fill_default_direct_cmd_desc(&desc,
 +					  i40e_aqc_opc_queue_shutdown);
++=======
+ 	iavf_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_queue_shutdown);
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_common.c
  
  	if (unloading)
  		cmd->driver_unloading = cpu_to_le32(I40E_AQ_DRIVER_UNLOADING);
@@@ -431,8 -428,8 +442,13 @@@ static iavf_status i40e_aq_get_set_rss_
   *
   * get the RSS lookup table, PF or VSI type
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40evf_aq_get_rss_lut(struct i40e_hw *hw, u16 vsi_id,
 +				  bool pf_lut, u8 *lut, u16 lut_size)
++=======
+ iavf_status iavf_aq_get_rss_lut(struct i40e_hw *hw, u16 vsi_id,
+ 				bool pf_lut, u8 *lut, u16 lut_size)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	return i40e_aq_get_set_rss_lut(hw, vsi_id, pf_lut, lut, lut_size,
  				       false);
@@@ -448,8 -445,8 +464,13 @@@
   *
   * set the RSS lookup table, PF or VSI type
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40evf_aq_set_rss_lut(struct i40e_hw *hw, u16 vsi_id,
 +				  bool pf_lut, u8 *lut, u16 lut_size)
++=======
+ iavf_status iavf_aq_set_rss_lut(struct i40e_hw *hw, u16 vsi_id,
+ 				bool pf_lut, u8 *lut, u16 lut_size)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	return i40e_aq_get_set_rss_lut(hw, vsi_id, pf_lut, lut, lut_size, true);
  }
@@@ -463,12 -460,12 +484,19 @@@
   *
   * get the RSS key per VSI
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +static i40e_status i40e_aq_get_set_rss_key(struct i40e_hw *hw,
 +				      u16 vsi_id,
 +				      struct i40e_aqc_get_set_rss_key_data *key,
 +				      bool set)
++=======
+ static
+ iavf_status i40e_aq_get_set_rss_key(struct i40e_hw *hw, u16 vsi_id,
+ 				    struct i40e_aqc_get_set_rss_key_data *key,
+ 				    bool set)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
- 	i40e_status status;
+ 	iavf_status status;
  	struct i40e_aq_desc desc;
  	struct i40e_aqc_get_set_rss_key *cmd_resp =
  			(struct i40e_aqc_get_set_rss_key *)&desc.params.raw;
@@@ -503,9 -500,8 +531,14 @@@
   * @key: pointer to key info struct
   *
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40evf_aq_get_rss_key(struct i40e_hw *hw,
 +				  u16 vsi_id,
 +				  struct i40e_aqc_get_set_rss_key_data *key)
++=======
+ iavf_status iavf_aq_get_rss_key(struct i40e_hw *hw, u16 vsi_id,
+ 				struct i40e_aqc_get_set_rss_key_data *key)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	return i40e_aq_get_set_rss_key(hw, vsi_id, key, false);
  }
@@@ -518,9 -514,8 +551,14 @@@
   *
   * set the RSS key per VSI
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40evf_aq_set_rss_key(struct i40e_hw *hw,
 +				  u16 vsi_id,
 +				  struct i40e_aqc_get_set_rss_key_data *key)
++=======
+ iavf_status iavf_aq_set_rss_key(struct i40e_hw *hw, u16 vsi_id,
+ 				struct i40e_aqc_get_set_rss_key_data *key)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
  	return i40e_aq_get_set_rss_key(hw, vsi_id, key, true);
  }
@@@ -1030,20 -895,19 +1068,27 @@@ do_retry
   * @cmd_details: pointer to command details
   *
   * Send message to PF driver using admin queue. By default, this message
 - * is sent asynchronously, i.e. iavf_asq_send_command() does not wait for
 + * is sent asynchronously, i.e. i40evf_asq_send_command() does not wait for
   * completion before returning.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40e_aq_send_msg_to_pf(struct i40e_hw *hw,
 +				enum virtchnl_ops v_opcode,
 +				i40e_status v_retval,
 +				u8 *msg, u16 msglen,
 +				struct i40e_asq_cmd_details *cmd_details)
++=======
+ iavf_status iavf_aq_send_msg_to_pf(struct i40e_hw *hw,
+ 				   enum virtchnl_ops v_opcode,
+ 				   iavf_status v_retval, u8 *msg, u16 msglen,
+ 				   struct i40e_asq_cmd_details *cmd_details)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
- 	struct i40e_aq_desc desc;
  	struct i40e_asq_cmd_details details;
- 	i40e_status status;
+ 	struct i40e_aq_desc desc;
+ 	iavf_status status;
  
 -	iavf_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_send_msg_to_pf);
 +	i40evf_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_send_msg_to_pf);
  	desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_SI);
  	desc.cookie_high = cpu_to_le32(v_opcode);
  	desc.cookie_low = cpu_to_le32(v_retval);
@@@ -1105,216 -969,8 +1150,220 @@@ void i40e_vf_parse_hw_config(struct i40
   * as none will be forthcoming. Immediately after calling this function,
   * the admin queue should be shut down and (optionally) reinitialized.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40e_common.c
 +i40e_status i40e_vf_reset(struct i40e_hw *hw)
++=======
+ iavf_status iavf_vf_reset(struct i40e_hw *hw)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40e_common.c
  {
 -	return iavf_aq_send_msg_to_pf(hw, VIRTCHNL_OP_RESET_VF,
 +	return i40e_aq_send_msg_to_pf(hw, VIRTCHNL_OP_RESET_VF,
  				      0, NULL, 0, NULL);
  }
 +
 +/**
 + * i40evf_aq_write_ddp - Write dynamic device personalization (ddp)
 + * @hw: pointer to the hw struct
 + * @buff: command buffer (size in bytes = buff_size)
 + * @buff_size: buffer size in bytes
 + * @track_id: package tracking id
 + * @error_offset: returns error offset
 + * @error_info: returns error information
 + * @cmd_details: pointer to command details structure or NULL
 + **/
 +enum
 +i40e_status_code i40evf_aq_write_ddp(struct i40e_hw *hw, void *buff,
 +				     u16 buff_size, u32 track_id,
 +				     u32 *error_offset, u32 *error_info,
 +				     struct i40e_asq_cmd_details *cmd_details)
 +{
 +	struct i40e_aq_desc desc;
 +	struct i40e_aqc_write_personalization_profile *cmd =
 +		(struct i40e_aqc_write_personalization_profile *)
 +		&desc.params.raw;
 +	struct i40e_aqc_write_ddp_resp *resp;
 +	i40e_status status;
 +
 +	i40evf_fill_default_direct_cmd_desc(&desc,
 +					    i40e_aqc_opc_write_personalization_profile);
 +
 +	desc.flags |= cpu_to_le16(I40E_AQ_FLAG_BUF | I40E_AQ_FLAG_RD);
 +	if (buff_size > I40E_AQ_LARGE_BUF)
 +		desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);
 +
 +	desc.datalen = cpu_to_le16(buff_size);
 +
 +	cmd->profile_track_id = cpu_to_le32(track_id);
 +
 +	status = i40evf_asq_send_command(hw, &desc, buff, buff_size, cmd_details);
 +	if (!status) {
 +		resp = (struct i40e_aqc_write_ddp_resp *)&desc.params.raw;
 +		if (error_offset)
 +			*error_offset = le32_to_cpu(resp->error_offset);
 +		if (error_info)
 +			*error_info = le32_to_cpu(resp->error_info);
 +	}
 +
 +	return status;
 +}
 +
 +/**
 + * i40evf_aq_get_ddp_list - Read dynamic device personalization (ddp)
 + * @hw: pointer to the hw struct
 + * @buff: command buffer (size in bytes = buff_size)
 + * @buff_size: buffer size in bytes
 + * @flags: AdminQ command flags
 + * @cmd_details: pointer to command details structure or NULL
 + **/
 +enum
 +i40e_status_code i40evf_aq_get_ddp_list(struct i40e_hw *hw, void *buff,
 +					u16 buff_size, u8 flags,
 +				       struct i40e_asq_cmd_details *cmd_details)
 +{
 +	struct i40e_aq_desc desc;
 +	struct i40e_aqc_get_applied_profiles *cmd =
 +		(struct i40e_aqc_get_applied_profiles *)&desc.params.raw;
 +	i40e_status status;
 +
 +	i40evf_fill_default_direct_cmd_desc(&desc,
 +					    i40e_aqc_opc_get_personalization_profile_list);
 +
 +	desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);
 +	if (buff_size > I40E_AQ_LARGE_BUF)
 +		desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_LB);
 +	desc.datalen = cpu_to_le16(buff_size);
 +
 +	cmd->flags = flags;
 +
 +	status = i40evf_asq_send_command(hw, &desc, buff, buff_size, cmd_details);
 +
 +	return status;
 +}
 +
 +/**
 + * i40evf_find_segment_in_package
 + * @segment_type: the segment type to search for (i.e., SEGMENT_TYPE_I40E)
 + * @pkg_hdr: pointer to the package header to be searched
 + *
 + * This function searches a package file for a particular segment type. On
 + * success it returns a pointer to the segment header, otherwise it will
 + * return NULL.
 + **/
 +struct i40e_generic_seg_header *
 +i40evf_find_segment_in_package(u32 segment_type,
 +			       struct i40e_package_header *pkg_hdr)
 +{
 +	struct i40e_generic_seg_header *segment;
 +	u32 i;
 +
 +	/* Search all package segments for the requested segment type */
 +	for (i = 0; i < pkg_hdr->segment_count; i++) {
 +		segment =
 +			(struct i40e_generic_seg_header *)((u8 *)pkg_hdr +
 +			 pkg_hdr->segment_offset[i]);
 +
 +		if (segment->type == segment_type)
 +			return segment;
 +	}
 +
 +	return NULL;
 +}
 +
 +/**
 + * i40evf_write_profile
 + * @hw: pointer to the hardware structure
 + * @profile: pointer to the profile segment of the package to be downloaded
 + * @track_id: package tracking id
 + *
 + * Handles the download of a complete package.
 + */
 +enum i40e_status_code
 +i40evf_write_profile(struct i40e_hw *hw, struct i40e_profile_segment *profile,
 +		     u32 track_id)
 +{
 +	i40e_status status = 0;
 +	struct i40e_section_table *sec_tbl;
 +	struct i40e_profile_section_header *sec = NULL;
 +	u32 dev_cnt;
 +	u32 vendor_dev_id;
 +	u32 *nvm;
 +	u32 section_size = 0;
 +	u32 offset = 0, info = 0;
 +	u32 i;
 +
 +	dev_cnt = profile->device_table_count;
 +
 +	for (i = 0; i < dev_cnt; i++) {
 +		vendor_dev_id = profile->device_table[i].vendor_dev_id;
 +		if ((vendor_dev_id >> 16) == PCI_VENDOR_ID_INTEL)
 +			if (hw->device_id == (vendor_dev_id & 0xFFFF))
 +				break;
 +	}
 +	if (i == dev_cnt) {
 +		i40e_debug(hw, I40E_DEBUG_PACKAGE, "Device doesn't support DDP");
 +		return I40E_ERR_DEVICE_NOT_SUPPORTED;
 +	}
 +
 +	nvm = (u32 *)&profile->device_table[dev_cnt];
 +	sec_tbl = (struct i40e_section_table *)&nvm[nvm[0] + 1];
 +
 +	for (i = 0; i < sec_tbl->section_count; i++) {
 +		sec = (struct i40e_profile_section_header *)((u8 *)profile +
 +					     sec_tbl->section_offset[i]);
 +
 +		/* Skip 'AQ', 'note' and 'name' sections */
 +		if (sec->section.type != SECTION_TYPE_MMIO)
 +			continue;
 +
 +		section_size = sec->section.size +
 +			sizeof(struct i40e_profile_section_header);
 +
 +		/* Write profile */
 +		status = i40evf_aq_write_ddp(hw, (void *)sec, (u16)section_size,
 +					     track_id, &offset, &info, NULL);
 +		if (status) {
 +			i40e_debug(hw, I40E_DEBUG_PACKAGE,
 +				   "Failed to write profile: offset %d, info %d",
 +				   offset, info);
 +			break;
 +		}
 +	}
 +	return status;
 +}
 +
 +/**
 + * i40evf_add_pinfo_to_list
 + * @hw: pointer to the hardware structure
 + * @profile: pointer to the profile segment of the package
 + * @profile_info_sec: buffer for information section
 + * @track_id: package tracking id
 + *
 + * Register a profile to the list of loaded profiles.
 + */
 +enum i40e_status_code
 +i40evf_add_pinfo_to_list(struct i40e_hw *hw,
 +			 struct i40e_profile_segment *profile,
 +			 u8 *profile_info_sec, u32 track_id)
 +{
 +	i40e_status status = 0;
 +	struct i40e_profile_section_header *sec = NULL;
 +	struct i40e_profile_info *pinfo;
 +	u32 offset = 0, info = 0;
 +
 +	sec = (struct i40e_profile_section_header *)profile_info_sec;
 +	sec->tbl_size = 1;
 +	sec->data_end = sizeof(struct i40e_profile_section_header) +
 +			sizeof(struct i40e_profile_info);
 +	sec->section.type = SECTION_TYPE_INFO;
 +	sec->section.offset = sizeof(struct i40e_profile_section_header);
 +	sec->section.size = sizeof(struct i40e_profile_info);
 +	pinfo = (struct i40e_profile_info *)(profile_info_sec +
 +					     sec->section.offset);
 +	pinfo->track_id = track_id;
 +	pinfo->version = profile->version;
 +	pinfo->op = I40E_DDP_ADD_TRACKID;
 +	memcpy(pinfo->name, profile->name, I40E_DDP_NAME_SIZE);
 +
 +	status = i40evf_aq_write_ddp(hw, (void *)sec, sec->data_end,
 +				     track_id, &offset, &info, NULL);
 +	return status;
 +}
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_client.c
index 3cc9d60d0d72,4c3e9b5d547b..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_client.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_client.c
@@@ -132,10 -132,10 +132,15 @@@ void i40evf_notify_client_open(struct i
   *
   * Return 0 on success or < 0 on error
   **/
 -static int iavf_client_release_qvlist(struct i40e_info *ldev)
 +static int i40evf_client_release_qvlist(struct i40e_info *ldev)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +	struct i40evf_adapter *adapter = ldev->vf;
 +	i40e_status err;
++=======
+ 	struct iavf_adapter *adapter = ldev->vf;
+ 	iavf_status err;
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40evf_client.c
  
  	if (adapter->aq_required)
  		return -EAGAIN;
@@@ -415,12 -415,12 +420,17 @@@ static void i40evf_client_prepare(struc
   *
   * Return 0 on success or < 0 on error
   **/
 -static u32 iavf_client_virtchnl_send(struct i40e_info *ldev,
 -				     struct i40e_client *client,
 -				     u8 *msg, u16 len)
 +static u32 i40evf_client_virtchnl_send(struct i40e_info *ldev,
 +				       struct i40e_client *client,
 +				       u8 *msg, u16 len)
  {
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_client.c
 +	struct i40evf_adapter *adapter = ldev->vf;
 +	i40e_status err;
++=======
+ 	struct iavf_adapter *adapter = ldev->vf;
+ 	iavf_status err;
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40evf_client.c
  
  	if (adapter->aq_required)
  		return -EAGAIN;
@@@ -442,14 -442,14 +452,14 @@@
   *
   * Return 0 on success or < 0 on error
   **/
 -static int iavf_client_setup_qvlist(struct i40e_info *ldev,
 -				    struct i40e_client *client,
 -				    struct i40e_qvlist_info *qvlist_info)
 +static int i40evf_client_setup_qvlist(struct i40e_info *ldev,
 +				      struct i40e_client *client,
 +				      struct i40e_qvlist_info *qvlist_info)
  {
  	struct virtchnl_iwarp_qvlist_info *v_qvlist_info;
 -	struct iavf_adapter *adapter = ldev->vf;
 +	struct i40evf_adapter *adapter = ldev->vf;
  	struct i40e_qv_info *qv_info;
- 	i40e_status err;
+ 	iavf_status err;
  	u32 v_idx, i;
  	u32 msg_size;
  
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_main.c
index 950c8aeb0fc9,46bdc59b9bed..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_main.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_main.c
@@@ -65,11 -66,11 +65,17 @@@ static struct workqueue_struct *i40evf_
   * @size: size of memory requested
   * @alignment: what to align the allocation to
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +i40e_status i40evf_allocate_dma_mem_d(struct i40e_hw *hw,
 +				      struct i40e_dma_mem *mem,
 +				      u64 size, u32 alignment)
++=======
+ iavf_status iavf_allocate_dma_mem_d(struct i40e_hw *hw,
+ 				    struct i40e_dma_mem *mem,
+ 				    u64 size, u32 alignment)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40evf_main.c
  {
 -	struct iavf_adapter *adapter = (struct iavf_adapter *)hw->back;
 +	struct i40evf_adapter *adapter = (struct i40evf_adapter *)hw->back;
  
  	if (!mem)
  		return I40E_ERR_PARAM;
@@@ -88,9 -89,9 +94,13 @@@
   * @hw:   pointer to the HW structure
   * @mem:  ptr to mem struct to free
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +i40e_status i40evf_free_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem)
++=======
+ iavf_status iavf_free_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40evf_main.c
  {
 -	struct iavf_adapter *adapter = (struct iavf_adapter *)hw->back;
 +	struct i40evf_adapter *adapter = (struct i40evf_adapter *)hw->back;
  
  	if (!mem || !mem->va)
  		return I40E_ERR_PARAM;
@@@ -105,8 -106,8 +115,13 @@@
   * @mem:  ptr to mem struct to fill out
   * @size: size of memory requested
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +i40e_status i40evf_allocate_virt_mem_d(struct i40e_hw *hw,
 +				       struct i40e_virt_mem *mem, u32 size)
++=======
+ iavf_status iavf_allocate_virt_mem_d(struct i40e_hw *hw,
+ 				     struct i40e_virt_mem *mem, u32 size)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40evf_main.c
  {
  	if (!mem)
  		return I40E_ERR_PARAM;
@@@ -125,8 -126,8 +140,13 @@@
   * @hw:   pointer to the HW structure
   * @mem:  ptr to mem struct to free
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_main.c
 +i40e_status i40evf_free_virt_mem_d(struct i40e_hw *hw,
 +				   struct i40e_virt_mem *mem)
++=======
+ iavf_status iavf_free_virt_mem_d(struct i40e_hw *hw,
+ 				 struct i40e_virt_mem *mem)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40evf_main.c
  {
  	if (!mem)
  		return I40E_ERR_PARAM;
@@@ -2060,9 -2063,9 +2082,9 @@@ static void i40evf_adminq_task(struct w
  		goto out;
  
  	do {
 -		ret = iavf_clean_arq_element(hw, &event, &pending);
 +		ret = i40evf_clean_arq_element(hw, &event, &pending);
  		v_op = (enum virtchnl_ops)le32_to_cpu(event.desc.cookie_high);
- 		v_ret = (i40e_status)le32_to_cpu(event.desc.cookie_low);
+ 		v_ret = (iavf_status)le32_to_cpu(event.desc.cookie_low);
  
  		if (ret || !v_op)
  			break; /* No event to process or error cleaning ARQ */
diff --cc drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
index 6579dabab78c,a1fa7a22c19a..000000000000
--- a/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
@@@ -18,20 -18,20 +18,20 @@@
   *
   * Send message to PF and print status if failure.
   **/
 -static int iavf_send_pf_msg(struct iavf_adapter *adapter,
 -			    enum virtchnl_ops op, u8 *msg, u16 len)
 +static int i40evf_send_pf_msg(struct i40evf_adapter *adapter,
 +			      enum virtchnl_ops op, u8 *msg, u16 len)
  {
  	struct i40e_hw *hw = &adapter->hw;
- 	i40e_status err;
+ 	iavf_status err;
  
 -	if (adapter->flags & IAVF_FLAG_PF_COMMS_FAILED)
 +	if (adapter->flags & I40EVF_FLAG_PF_COMMS_FAILED)
  		return 0; /* nothing to see here, move along */
  
 -	err = iavf_aq_send_msg_to_pf(hw, op, 0, msg, len, NULL);
 +	err = i40e_aq_send_msg_to_pf(hw, op, 0, msg, len, NULL);
  	if (err)
  		dev_dbg(&adapter->pdev->dev, "Unable to send opcode %d to PF, err %s, aq_err %s\n",
 -			op, iavf_stat_str(hw, err),
 -			iavf_aq_str(hw, hw->aq.asq_last_status));
 +			op, i40evf_stat_str(hw, err),
 +			i40evf_aq_str(hw, hw->aq.asq_last_status));
  	return err;
  }
  
@@@ -69,9 -69,9 +69,9 @@@ int i40evf_verify_api_ver(struct i40evf
  	struct i40e_hw *hw = &adapter->hw;
  	struct i40e_arq_event_info event;
  	enum virtchnl_ops op;
- 	i40e_status err;
+ 	iavf_status err;
  
 -	event.buf_len = IAVF_MAX_AQ_BUF_SIZE;
 +	event.buf_len = I40EVF_MAX_AQ_BUF_SIZE;
  	event.msg_buf = kzalloc(event.buf_len, GFP_KERNEL);
  	if (!event.msg_buf) {
  		err = -ENOMEM;
@@@ -142,15 -142,13 +142,23 @@@ int i40evf_send_vf_config_msg(struct i4
  	       VIRTCHNL_VF_OFFLOAD_ADQ;
  
  	adapter->current_op = VIRTCHNL_OP_GET_VF_RESOURCES;
 -	adapter->aq_required &= ~IAVF_FLAG_AQ_GET_CONFIG;
 +	adapter->aq_required &= ~I40EVF_FLAG_AQ_GET_CONFIG;
  	if (PF_IS_V11(adapter))
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
 +		return i40evf_send_pf_msg(adapter,
 +					  VIRTCHNL_OP_GET_VF_RESOURCES,
 +					  (u8 *)&caps, sizeof(caps));
 +	else
 +		return i40evf_send_pf_msg(adapter,
 +					  VIRTCHNL_OP_GET_VF_RESOURCES,
 +					  NULL, 0);
++=======
+ 		return iavf_send_pf_msg(adapter, VIRTCHNL_OP_GET_VF_RESOURCES,
+ 					(u8 *)&caps, sizeof(caps));
+ 	else
+ 		return iavf_send_pf_msg(adapter, VIRTCHNL_OP_GET_VF_RESOURCES,
+ 					NULL, 0);
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40evf_virtchnl.c
  }
  
  /**
@@@ -493,8 -491,7 +501,12 @@@ void i40evf_add_ether_addrs(struct i40e
  
  	spin_unlock_bh(&adapter->mac_vlan_list_lock);
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
 +	i40evf_send_pf_msg(adapter, VIRTCHNL_OP_ADD_ETH_ADDR,
 +			   (u8 *)veal, len);
++=======
+ 	iavf_send_pf_msg(adapter, VIRTCHNL_OP_ADD_ETH_ADDR, (u8 *)veal, len);
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40evf_virtchnl.c
  	kfree(veal);
  }
  
@@@ -565,8 -562,7 +577,12 @@@ void i40evf_del_ether_addrs(struct i40e
  
  	spin_unlock_bh(&adapter->mac_vlan_list_lock);
  
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
 +	i40evf_send_pf_msg(adapter, VIRTCHNL_OP_DEL_ETH_ADDR,
 +			   (u8 *)veal, len);
++=======
+ 	iavf_send_pf_msg(adapter, VIRTCHNL_OP_DEL_ETH_ADDR, (u8 *)veal, len);
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40evf_virtchnl.c
  	kfree(veal);
  }
  
@@@ -776,8 -772,8 +792,13 @@@ void i40evf_request_stats(struct i40evf
  	adapter->current_op = VIRTCHNL_OP_GET_STATS;
  	vqs.vsi_id = adapter->vsi_res->vsi_id;
  	/* queue maps are ignored for this message - only the vsi is used */
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
 +	if (i40evf_send_pf_msg(adapter, VIRTCHNL_OP_GET_STATS,
 +			       (u8 *)&vqs, sizeof(vqs)))
++=======
+ 	if (iavf_send_pf_msg(adapter, VIRTCHNL_OP_GET_STATS, (u8 *)&vqs,
+ 			     sizeof(vqs)))
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40evf_virtchnl.c
  		/* if the request failed, don't lock out others */
  		adapter->current_op = VIRTCHNL_OP_UNKNOWN;
  }
@@@ -1196,10 -1183,9 +1217,16 @@@ void i40evf_request_reset(struct i40evf
   * wait, we fire off our requests and assume that no errors will be returned.
   * This function handles the reply messages.
   **/
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
 +void i40evf_virtchnl_completion(struct i40evf_adapter *adapter,
 +				enum virtchnl_ops v_opcode,
 +				i40e_status v_retval,
 +				u8 *msg, u16 msglen)
++=======
+ void iavf_virtchnl_completion(struct iavf_adapter *adapter,
+ 			      enum virtchnl_ops v_opcode, iavf_status v_retval,
+ 			      u8 *msg, u16 msglen)
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40evf_virtchnl.c
  {
  	struct net_device *netdev = adapter->netdev;
  
@@@ -1332,8 -1319,7 +1360,12 @@@
  			break;
  		default:
  			dev_err(&adapter->pdev->dev, "PF returned error %d (%s) to our request %d\n",
++<<<<<<< HEAD:drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
 +				v_retval,
 +				i40evf_stat_str(&adapter->hw, v_retval),
++=======
+ 				v_retval, iavf_stat_str(&adapter->hw, v_retval),
++>>>>>>> 0b6591e6463b (iavf: rename i40e_status to iavf_status):drivers/net/ethernet/intel/iavf/i40evf_virtchnl.c
  				v_opcode);
  		}
  	}
* Unmerged path drivers/net/ethernet/intel/iavf/i40e_prototype.h
* Unmerged path drivers/net/ethernet/intel/iavf/i40evf.h
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_adminq.c
diff --git a/drivers/net/ethernet/intel/i40evf/i40e_alloc.h b/drivers/net/ethernet/intel/i40evf/i40e_alloc.h
index cb8689222c8b..90c6988d1c8f 100644
--- a/drivers/net/ethernet/intel/i40evf/i40e_alloc.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_alloc.h
@@ -20,16 +20,12 @@ enum i40e_memory_type {
 };
 
 /* prototype for functions used for dynamic memory allocation */
-i40e_status i40e_allocate_dma_mem(struct i40e_hw *hw,
-					    struct i40e_dma_mem *mem,
-					    enum i40e_memory_type type,
-					    u64 size, u32 alignment);
-i40e_status i40e_free_dma_mem(struct i40e_hw *hw,
-					struct i40e_dma_mem *mem);
-i40e_status i40e_allocate_virt_mem(struct i40e_hw *hw,
-					     struct i40e_virt_mem *mem,
-					     u32 size);
-i40e_status i40e_free_virt_mem(struct i40e_hw *hw,
-					 struct i40e_virt_mem *mem);
+iavf_status i40e_allocate_dma_mem(struct i40e_hw *hw, struct i40e_dma_mem *mem,
+				  enum i40e_memory_type type,
+				  u64 size, u32 alignment);
+iavf_status i40e_free_dma_mem(struct i40e_hw *hw, struct i40e_dma_mem *mem);
+iavf_status i40e_allocate_virt_mem(struct i40e_hw *hw,
+				   struct i40e_virt_mem *mem, u32 size);
+iavf_status i40e_free_virt_mem(struct i40e_hw *hw, struct i40e_virt_mem *mem);
 
 #endif /* _I40E_ALLOC_H_ */
* Unmerged path drivers/net/ethernet/intel/i40evf/i40e_common.c
diff --git a/drivers/net/ethernet/intel/i40evf/i40e_osdep.h b/drivers/net/ethernet/intel/i40evf/i40e_osdep.h
index d394f0fe8516..28a210f22785 100644
--- a/drivers/net/ethernet/intel/i40evf/i40e_osdep.h
+++ b/drivers/net/ethernet/intel/i40evf/i40e_osdep.h
@@ -48,5 +48,5 @@ struct i40e_virt_mem {
 extern void i40evf_debug_d(void *hw, u32 mask, char *fmt_str, ...)
 	__attribute__ ((format(gnu_printf, 3, 4)));
 
-typedef enum i40e_status_code i40e_status;
+typedef enum i40e_status_code iavf_status;
 #endif /* _I40E_OSDEP_H_ */
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_client.c
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c b/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
index 50f65ab737c9..24d45e5ac32c 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
@@ -776,10 +776,7 @@ static int __i40evf_set_coalesce(struct net_device *netdev,
 		   (ec->rx_coalesce_usecs > I40E_MAX_ITR)) {
 		netif_info(adapter, drv, netdev, "Invalid value, rx-usecs range is 0-8160\n");
 		return -EINVAL;
-	}
-
-	else
-	if (ec->tx_coalesce_usecs == 0) {
+	} else if (ec->tx_coalesce_usecs == 0) {
 		if (ec->use_adaptive_tx_coalesce)
 			netif_info(adapter, drv, netdev, "tx-usecs=0, need to disable adaptive-tx for a complete disable\n");
 	} else if ((ec->tx_coalesce_usecs < I40E_MIN_ITR) ||
@@ -1004,9 +1001,8 @@ static int i40evf_set_rxfh(struct net_device *netdev, const u32 *indir,
 	if (!indir)
 		return 0;
 
-	if (key) {
+	if (key)
 		memcpy(adapter->rss_key, key, adapter->rss_key_size);
-	}
 
 	/* Each 32 bits pointed by 'indir' is stored with a lut entry */
 	for (i = 0; i < adapter->rss_lut_size; i++)
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_main.c
* Unmerged path drivers/net/ethernet/intel/i40evf/i40evf_virtchnl.c
* Unmerged path drivers/net/ethernet/intel/iavf/i40e_prototype.h
* Unmerged path drivers/net/ethernet/intel/iavf/i40evf.h
