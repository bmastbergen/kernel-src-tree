bpf tools: Improve libbpf error reporting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit 6371ca3b541c82d8aa6a9002bd52d92bcdda5944
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6371ca3b.failed

In this patch, a series of libbpf specific error numbers and
libbpf_strerror() are introduced to help reporting errors.

Functions are updated to pass correct the error number through the
CHECK_ERR() macro.

All users of bpf_object__open{_buffer}() and bpf_program__title() in
perf are modified accordingly. In addition, due to the error codes
changing, bpf__strerror_load() is also modified to use them.

bpf__strerror_head() is also changed accordingly so it can parse libbpf
errors. bpf_loader_strerror() is introduced for that purpose, and will
be improved by the following patch.

load_program() is improved not to dump log buffer if it is empty. log
buffer is also used to deduce whether the error was caused by an invalid
program or other problem.

v1 -> v2:

 - Using macro for error code.

 - Fetch error message based on array index, eliminate for-loop.

 - Use log buffer to detect the reason of failure. 3 new error code
   are introduced to replace LIBBPF_ERRNO__LOAD.

In v1:

  # perf record -e ./test_ill_program.o ls
  event syntax error: './test_ill_program.o'
                       \___ Failed to load program: Validate your program and check 'license'/'version' sections in your object
  SKIP

  # perf record -e ./test_kversion_nomatch_program.o ls
  event syntax error: './test_kversion_nomatch_program.o'
                       \___ Failed to load program: Validate your program and check 'license'/'version' sections in your object
  SKIP

  # perf record -e ./test_big_program.o ls
  event syntax error: './test_big_program.o'
                       \___ Failed to load program: Validate your program and check 'license'/'version' sections in your object
  SKIP

  In v2:

  # perf record -e ./test_ill_program.o ls
  event syntax error: './test_ill_program.o'
                       \___ Kernel verifier blocks program loading
  SKIP

  # perf record -e ./test_kversion_nomatch_program.o
  event syntax error: './test_kversion_nomatch_program.o'
                       \___ Incorrect kernel version
  SKIP
  (Will be further improved by following patches)

  # perf record -e ./test_big_program.o
  event syntax error: './test_big_program.o'
                       \___ Program too big
  SKIP

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/1446817783-86722-2-git-send-email-wangnan0@huawei.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 6371ca3b541c82d8aa6a9002bd52d92bcdda5944)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
#	tools/lib/bpf/libbpf.h
#	tools/perf/tests/llvm.c
#	tools/perf/util/bpf-loader.c
#	tools/perf/util/parse-events.c
diff --cc tools/lib/bpf/libbpf.c
index 5bbbf285af74,07b492d3dfaa..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -101,15 -71,12 +101,22 @@@ static const char *libbpf_strerror_tabl
  	[ERRCODE_OFFSET(LIBELF)]	= "Something wrong in libelf",
  	[ERRCODE_OFFSET(FORMAT)]	= "BPF object format invalid",
  	[ERRCODE_OFFSET(KVERSION)]	= "'version' section incorrect or lost",
++<<<<<<< HEAD
 +	[ERRCODE_OFFSET(ENDIAN)]	= "Endian mismatch",
++=======
+ 	[ERRCODE_OFFSET(ENDIAN)]	= "Endian missmatch",
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  	[ERRCODE_OFFSET(INTERNAL)]	= "Internal error in libbpf",
  	[ERRCODE_OFFSET(RELOC)]		= "Relocation failed",
  	[ERRCODE_OFFSET(VERIFY)]	= "Kernel verifier blocks program loading",
  	[ERRCODE_OFFSET(PROG2BIG)]	= "Program too big",
  	[ERRCODE_OFFSET(KVER)]		= "Incorrect kernel version",
++<<<<<<< HEAD
 +	[ERRCODE_OFFSET(PROGTYPE)]	= "Kernel doesn't support this program type",
 +	[ERRCODE_OFFSET(WRNGPID)]	= "Wrong pid in netlink message",
 +	[ERRCODE_OFFSET(INVSEQ)]	= "Invalid netlink sequence",
++=======
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  };
  
  int libbpf_strerror(int err, char *buf, size_t size)
@@@ -781,24 -508,24 +788,39 @@@ static int bpf_object__elf_collect(stru
  
  		idx++;
  		if (gelf_getshdr(scn, &sh) != &sh) {
++<<<<<<< HEAD
 +			pr_warning("failed to get section(%d) header from %s\n",
 +				   idx, obj->path);
++=======
+ 			pr_warning("failed to get section header from %s\n",
+ 				   obj->path);
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  			err = -LIBBPF_ERRNO__FORMAT;
  			goto out;
  		}
  
  		name = elf_strptr(elf, ep->e_shstrndx, sh.sh_name);
  		if (!name) {
++<<<<<<< HEAD
 +			pr_warning("failed to get section(%d) name from %s\n",
 +				   idx, obj->path);
++=======
+ 			pr_warning("failed to get section name from %s\n",
+ 				   obj->path);
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  			err = -LIBBPF_ERRNO__FORMAT;
  			goto out;
  		}
  
  		data = elf_getdata(scn, 0);
  		if (!data) {
++<<<<<<< HEAD
 +			pr_warning("failed to get section(%d) data from %s(%s)\n",
 +				   idx, name, obj->path);
++=======
+ 			pr_warning("failed to get section data from %s(%s)\n",
+ 				   name, obj->path);
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  			err = -LIBBPF_ERRNO__FORMAT;
  			goto out;
  		}
@@@ -822,10 -550,8 +844,14 @@@
  				pr_warning("bpf: multiple SYMTAB in %s\n",
  					   obj->path);
  				err = -LIBBPF_ERRNO__FORMAT;
++<<<<<<< HEAD
 +			} else {
++=======
+ 			} else
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  				obj->efile.symbols = data;
 +				obj->efile.strtabidx = sh.sh_link;
 +			}
  		} else if ((sh.sh_type == SHT_PROGBITS) &&
  			   (sh.sh_flags & SHF_EXECINSTR) &&
  			   (data->d_size > 0)) {
@@@ -941,46 -643,15 +967,52 @@@ bpf_program__collect_reloc(struct bpf_p
  			pr_warning("relocation: symbol %"PRIx64" not found\n",
  				   GELF_R_SYM(rel.r_info));
  			return -LIBBPF_ERRNO__FORMAT;
++<<<<<<< HEAD
 +		}
 +		pr_debug("relo for %lld value %lld name %d\n",
 +			 (long long) (rel.r_info >> 32),
 +			 (long long) sym.st_value, sym.st_name);
 +
 +		if (sym.st_shndx != maps_shndx && sym.st_shndx != text_shndx) {
 +			pr_warning("Program '%s' contains non-map related relo data pointing to section %u\n",
 +				   prog->section_name, sym.st_shndx);
 +			return -LIBBPF_ERRNO__RELOC;
 +		}
 +
 +		insn_idx = rel.r_offset / sizeof(struct bpf_insn);
 +		pr_debug("relocation: insn_idx=%u\n", insn_idx);
 +
 +		if (insns[insn_idx].code == (BPF_JMP | BPF_CALL)) {
 +			if (insns[insn_idx].src_reg != BPF_PSEUDO_CALL) {
 +				pr_warning("incorrect bpf_call opcode\n");
 +				return -LIBBPF_ERRNO__RELOC;
 +			}
 +			prog->reloc_desc[i].type = RELO_CALL;
 +			prog->reloc_desc[i].insn_idx = insn_idx;
 +			prog->reloc_desc[i].text_off = sym.st_value;
 +			continue;
++=======
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  		}
  
  		if (insns[insn_idx].code != (BPF_LD | BPF_IMM | BPF_DW)) {
  			pr_warning("bpf: relocation: invalid relo for insns[%d].code 0x%x\n",
  				   insn_idx, insns[insn_idx].code);
  			return -LIBBPF_ERRNO__RELOC;
++<<<<<<< HEAD
 +		}
 +
 +		/* TODO: 'maps' is sorted. We can use bsearch to make it faster. */
 +		for (map_idx = 0; map_idx < nr_maps; map_idx++) {
 +			if (maps[map_idx].offset == sym.st_value) {
 +				pr_debug("relocation: find map %zd (%s) for insn %u\n",
 +					 map_idx, maps[map_idx].name, insn_idx);
 +				break;
 +			}
++=======
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  		}
  
 -		map_idx = sym.st_value / sizeof(struct bpf_map_def);
  		if (map_idx >= nr_maps) {
  			pr_warning("bpf relocation: map_idx %d large than %d\n",
  				   (int)map_idx, (int)nr_maps - 1);
@@@ -1078,26 -729,19 +1110,33 @@@ bpf_program__relocate(struct bpf_progra
  		return 0;
  
  	for (i = 0; i < prog->nr_reloc; i++) {
 -		int insn_idx, map_idx;
 -		struct bpf_insn *insns = prog->insns;
 -
 -		insn_idx = prog->reloc_desc[i].insn_idx;
 -		map_idx = prog->reloc_desc[i].map_idx;
 -
 +		if (prog->reloc_desc[i].type == RELO_LD64) {
 +			struct bpf_insn *insns = prog->insns;
 +			int insn_idx, map_idx;
 +
 +			insn_idx = prog->reloc_desc[i].insn_idx;
 +			map_idx = prog->reloc_desc[i].map_idx;
 +
++<<<<<<< HEAD
 +			if (insn_idx >= (int)prog->insns_cnt) {
 +				pr_warning("relocation out of range: '%s'\n",
 +					   prog->section_name);
 +				return -LIBBPF_ERRNO__RELOC;
 +			}
 +			insns[insn_idx].src_reg = BPF_PSEUDO_MAP_FD;
 +			insns[insn_idx].imm = obj->maps[map_idx].fd;
 +		} else {
 +			err = bpf_program__reloc_text(prog, obj,
 +						      &prog->reloc_desc[i]);
 +			if (err)
 +				return err;
++=======
+ 		if (insn_idx >= (int)prog->insns_cnt) {
+ 			pr_warning("relocation out of range: '%s'\n",
+ 				   prog->section_name);
+ 			return -LIBBPF_ERRNO__RELOC;
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  		}
 -		insns[insn_idx].src_reg = BPF_PSEUDO_MAP_FD;
 -		insns[insn_idx].imm = map_fds[map_idx];
  	}
  
  	zfree(&prog->reloc_desc);
@@@ -1148,7 -794,8 +1187,12 @@@ static int bpf_object__collect_reloc(st
  
  		prog = bpf_object__find_prog_by_idx(obj, idx);
  		if (!prog) {
++<<<<<<< HEAD
 +			pr_warning("relocation failed: no section(%d)\n", idx);
++=======
+ 			pr_warning("relocation failed: no %d section\n",
+ 				   idx);
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  			return -LIBBPF_ERRNO__RELOC;
  		}
  
@@@ -1192,27 -840,15 +1236,39 @@@ load_program(enum bpf_prog_type type, c
  		pr_warning("-- BEGIN DUMP LOG ---\n");
  		pr_warning("\n%s\n", log_buf);
  		pr_warning("-- END LOG --\n");
++<<<<<<< HEAD
 +	} else if (insns_cnt >= BPF_MAXINSNS) {
 +		pr_warning("Program too large (%d insns), at most %d insns\n",
 +			   insns_cnt, BPF_MAXINSNS);
 +		ret = -LIBBPF_ERRNO__PROG2BIG;
 +	} else {
 +		/* Wrong program type? */
 +		if (type != BPF_PROG_TYPE_KPROBE) {
 +			int fd;
 +
 +			fd = bpf_load_program_name(BPF_PROG_TYPE_KPROBE, name,
 +						   insns, insns_cnt, license,
 +						   kern_version, NULL, 0);
 +			if (fd >= 0) {
 +				close(fd);
 +				ret = -LIBBPF_ERRNO__PROGTYPE;
 +				goto out;
 +			}
 +		}
 +
 +		if (log_buf)
 +			ret = -LIBBPF_ERRNO__KVER;
++=======
+ 	} else {
+ 		if (insns_cnt >= BPF_MAXINSNS) {
+ 			pr_warning("Program too large (%d insns), at most %d insns\n",
+ 				   insns_cnt, BPF_MAXINSNS);
+ 			ret = -LIBBPF_ERRNO__PROG2BIG;
+ 		} else if (log_buf) {
+ 			pr_warning("log buffer is empty\n");
+ 			ret = -LIBBPF_ERRNO__KVER;
+ 		}
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  	}
  
  out:
@@@ -1429,191 -1004,6 +1485,194 @@@ out
  	bpf_object__unload(obj);
  	pr_warning("failed to load object '%s'\n", obj->path);
  	return err;
++<<<<<<< HEAD
 +}
 +
 +static int check_path(const char *path)
 +{
 +	struct statfs st_fs;
 +	char *dname, *dir;
 +	int err = 0;
 +
 +	if (path == NULL)
 +		return -EINVAL;
 +
 +	dname = strdup(path);
 +	if (dname == NULL)
 +		return -ENOMEM;
 +
 +	dir = dirname(dname);
 +	if (statfs(dir, &st_fs)) {
 +		pr_warning("failed to statfs %s: %s\n", dir, strerror(errno));
 +		err = -errno;
 +	}
 +	free(dname);
 +
 +	if (!err && st_fs.f_type != BPF_FS_MAGIC) {
 +		pr_warning("specified path %s is not on BPF FS\n", path);
 +		err = -EINVAL;
 +	}
 +
 +	return err;
 +}
 +
 +int bpf_program__pin_instance(struct bpf_program *prog, const char *path,
 +			      int instance)
 +{
 +	int err;
 +
 +	err = check_path(path);
 +	if (err)
 +		return err;
 +
 +	if (prog == NULL) {
 +		pr_warning("invalid program pointer\n");
 +		return -EINVAL;
 +	}
 +
 +	if (instance < 0 || instance >= prog->instances.nr) {
 +		pr_warning("invalid prog instance %d of prog %s (max %d)\n",
 +			   instance, prog->section_name, prog->instances.nr);
 +		return -EINVAL;
 +	}
 +
 +	if (bpf_obj_pin(prog->instances.fds[instance], path)) {
 +		pr_warning("failed to pin program: %s\n", strerror(errno));
 +		return -errno;
 +	}
 +	pr_debug("pinned program '%s'\n", path);
 +
 +	return 0;
 +}
 +
 +static int make_dir(const char *path)
 +{
 +	int err = 0;
 +
 +	if (mkdir(path, 0700) && errno != EEXIST)
 +		err = -errno;
 +
 +	if (err)
 +		pr_warning("failed to mkdir %s: %s\n", path, strerror(-err));
 +	return err;
 +}
 +
 +int bpf_program__pin(struct bpf_program *prog, const char *path)
 +{
 +	int i, err;
 +
 +	err = check_path(path);
 +	if (err)
 +		return err;
 +
 +	if (prog == NULL) {
 +		pr_warning("invalid program pointer\n");
 +		return -EINVAL;
 +	}
 +
 +	if (prog->instances.nr <= 0) {
 +		pr_warning("no instances of prog %s to pin\n",
 +			   prog->section_name);
 +		return -EINVAL;
 +	}
 +
 +	err = make_dir(path);
 +	if (err)
 +		return err;
 +
 +	for (i = 0; i < prog->instances.nr; i++) {
 +		char buf[PATH_MAX];
 +		int len;
 +
 +		len = snprintf(buf, PATH_MAX, "%s/%d", path, i);
 +		if (len < 0)
 +			return -EINVAL;
 +		else if (len >= PATH_MAX)
 +			return -ENAMETOOLONG;
 +
 +		err = bpf_program__pin_instance(prog, buf, i);
 +		if (err)
 +			return err;
 +	}
 +
 +	return 0;
 +}
 +
 +int bpf_map__pin(struct bpf_map *map, const char *path)
 +{
 +	int err;
 +
 +	err = check_path(path);
 +	if (err)
 +		return err;
 +
 +	if (map == NULL) {
 +		pr_warning("invalid map pointer\n");
 +		return -EINVAL;
 +	}
 +
 +	if (bpf_obj_pin(map->fd, path)) {
 +		pr_warning("failed to pin map: %s\n", strerror(errno));
 +		return -errno;
 +	}
 +
 +	pr_debug("pinned map '%s'\n", path);
 +	return 0;
 +}
 +
 +int bpf_object__pin(struct bpf_object *obj, const char *path)
 +{
 +	struct bpf_program *prog;
 +	struct bpf_map *map;
 +	int err;
 +
 +	if (!obj)
 +		return -ENOENT;
 +
 +	if (!obj->loaded) {
 +		pr_warning("object not yet loaded; load it first\n");
 +		return -ENOENT;
 +	}
 +
 +	err = make_dir(path);
 +	if (err)
 +		return err;
 +
 +	bpf_map__for_each(map, obj) {
 +		char buf[PATH_MAX];
 +		int len;
 +
 +		len = snprintf(buf, PATH_MAX, "%s/%s", path,
 +			       bpf_map__name(map));
 +		if (len < 0)
 +			return -EINVAL;
 +		else if (len >= PATH_MAX)
 +			return -ENAMETOOLONG;
 +
 +		err = bpf_map__pin(map, buf);
 +		if (err)
 +			return err;
 +	}
 +
 +	bpf_object__for_each_program(prog, obj) {
 +		char buf[PATH_MAX];
 +		int len;
 +
 +		len = snprintf(buf, PATH_MAX, "%s/%s", path,
 +			       prog->section_name);
 +		if (len < 0)
 +			return -EINVAL;
 +		else if (len >= PATH_MAX)
 +			return -ENAMETOOLONG;
 +
 +		err = bpf_program__pin(prog, buf);
 +		if (err)
 +			return err;
 +	}
 +
 +	return 0;
++=======
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  }
  
  void bpf_object__close(struct bpf_object *obj)
@@@ -1669,30 -1047,12 +1728,36 @@@ bpf_object__next(struct bpf_object *pre
  	return next;
  }
  
 -const char *
 -bpf_object__get_name(struct bpf_object *obj)
 +const char *bpf_object__name(struct bpf_object *obj)
 +{
++<<<<<<< HEAD
 +	return obj ? obj->path : ERR_PTR(-EINVAL);
 +}
 +
 +unsigned int bpf_object__kversion(struct bpf_object *obj)
 +{
 +	return obj ? obj->kern_version : 0;
 +}
 +
 +int bpf_object__set_priv(struct bpf_object *obj, void *priv,
 +			 bpf_object_clear_priv_t clear_priv)
  {
 +	if (obj->priv && obj->clear_priv)
 +		obj->clear_priv(obj, obj->priv);
 +
 +	obj->priv = priv;
 +	obj->clear_priv = clear_priv;
 +	return 0;
 +}
 +
 +void *bpf_object__priv(struct bpf_object *obj)
 +{
 +	return obj ? obj->priv : ERR_PTR(-EINVAL);
++=======
+ 	if (!obj)
+ 		return ERR_PTR(-EINVAL);
+ 	return obj->path;
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  }
  
  struct bpf_program *
diff --cc tools/lib/bpf/libbpf.h
index f85906533cdd,30a40e9fa503..000000000000
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@@ -24,10 -9,8 +24,14 @@@
  #define __BPF_LIBBPF_H
  
  #include <stdio.h>
 +#include <stdint.h>
  #include <stdbool.h>
++<<<<<<< HEAD
 +#include <sys/types.h>  // for size_t
 +#include <linux/bpf.h>
++=======
+ #include <linux/err.h>
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  
  enum libbpf_errno {
  	__LIBBPF_ERRNO__START = 4000,
@@@ -36,16 -19,13 +40,23 @@@
  	LIBBPF_ERRNO__LIBELF = __LIBBPF_ERRNO__START,
  	LIBBPF_ERRNO__FORMAT,	/* BPF object format invalid */
  	LIBBPF_ERRNO__KVERSION,	/* Incorrect or no 'version' section */
++<<<<<<< HEAD
 +	LIBBPF_ERRNO__ENDIAN,	/* Endian mismatch */
++=======
+ 	LIBBPF_ERRNO__ENDIAN,	/* Endian missmatch */
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  	LIBBPF_ERRNO__INTERNAL,	/* Internal error in libbpf */
  	LIBBPF_ERRNO__RELOC,	/* Relocation failed */
  	LIBBPF_ERRNO__LOAD,	/* Load program failure for unknown reason */
  	LIBBPF_ERRNO__VERIFY,	/* Kernel verifier blocks program loading */
  	LIBBPF_ERRNO__PROG2BIG,	/* Program too big */
  	LIBBPF_ERRNO__KVER,	/* Incorrect kernel version */
++<<<<<<< HEAD
 +	LIBBPF_ERRNO__PROGTYPE,	/* Kernel doesn't support this program type */
 +	LIBBPF_ERRNO__WRNGPID,	/* Wrong pid in netlink message */
 +	LIBBPF_ERRNO__INVSEQ,	/* Invalid netlink sequence */
++=======
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  	__LIBBPF_ERRNO__END,
  };
  
diff --cc tools/perf/util/bpf-loader.c
index ab56073c5d6e,c46256b1f5fd..000000000000
--- a/tools/perf/util/bpf-loader.c
+++ b/tools/perf/util/bpf-loader.c
@@@ -39,10 -46,22 +39,27 @@@ struct bpf_object *bpf__prepare_load(co
  		libbpf_initialized = true;
  	}
  
++<<<<<<< HEAD
 +	obj = bpf_object__open(filename);
 +	if (!obj) {
++=======
+ 	if (source) {
+ 		int err;
+ 		void *obj_buf;
+ 		size_t obj_buf_sz;
+ 
+ 		err = llvm__compile_bpf(filename, &obj_buf, &obj_buf_sz);
+ 		if (err)
+ 			return ERR_PTR(err);
+ 		obj = bpf_object__open_buffer(obj_buf, obj_buf_sz, filename);
+ 		free(obj_buf);
+ 	} else
+ 		obj = bpf_object__open(filename);
+ 
+ 	if (IS_ERR(obj)) {
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  		pr_debug("bpf: failed to load %s\n", filename);
- 		return ERR_PTR(-EINVAL);
+ 		return obj;
  	}
  
  	return obj;
@@@ -52,6 -71,301 +69,303 @@@ void bpf__clear(void
  {
  	struct bpf_object *obj, *tmp;
  
 -	bpf_object__for_each_safe(obj, tmp) {
 -		bpf__unprobe(obj);
 +	bpf_object__for_each_safe(obj, tmp)
  		bpf_object__close(obj);
++<<<<<<< HEAD
++=======
+ 	}
+ }
+ 
+ static void
+ bpf_prog_priv__clear(struct bpf_program *prog __maybe_unused,
+ 		     void *_priv)
+ {
+ 	struct bpf_prog_priv *priv = _priv;
+ 
+ 	cleanup_perf_probe_events(&priv->pev, 1);
+ 	free(priv);
+ }
+ 
+ static int
+ config_bpf_program(struct bpf_program *prog)
+ {
+ 	struct perf_probe_event *pev = NULL;
+ 	struct bpf_prog_priv *priv = NULL;
+ 	const char *config_str;
+ 	int err;
+ 
+ 	config_str = bpf_program__title(prog, false);
+ 	if (IS_ERR(config_str)) {
+ 		pr_debug("bpf: unable to get title for program\n");
+ 		return PTR_ERR(config_str);
+ 	}
+ 
+ 	priv = calloc(sizeof(*priv), 1);
+ 	if (!priv) {
+ 		pr_debug("bpf: failed to alloc priv\n");
+ 		return -ENOMEM;
+ 	}
+ 	pev = &priv->pev;
+ 
+ 	pr_debug("bpf: config program '%s'\n", config_str);
+ 	err = parse_perf_probe_command(config_str, pev);
+ 	if (err < 0) {
+ 		pr_debug("bpf: '%s' is not a valid config string\n",
+ 			 config_str);
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 
+ 	if (pev->group && strcmp(pev->group, PERF_BPF_PROBE_GROUP)) {
+ 		pr_debug("bpf: '%s': group for event is set and not '%s'.\n",
+ 			 config_str, PERF_BPF_PROBE_GROUP);
+ 		err = -EINVAL;
+ 		goto errout;
+ 	} else if (!pev->group)
+ 		pev->group = strdup(PERF_BPF_PROBE_GROUP);
+ 
+ 	if (!pev->group) {
+ 		pr_debug("bpf: strdup failed\n");
+ 		err = -ENOMEM;
+ 		goto errout;
+ 	}
+ 
+ 	if (!pev->event) {
+ 		pr_debug("bpf: '%s': event name is missing\n",
+ 			 config_str);
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 	pr_debug("bpf: config '%s' is ok\n", config_str);
+ 
+ 	err = bpf_program__set_private(prog, priv, bpf_prog_priv__clear);
+ 	if (err) {
+ 		pr_debug("Failed to set priv for program '%s'\n", config_str);
+ 		goto errout;
+ 	}
+ 
+ 	return 0;
+ 
+ errout:
+ 	if (pev)
+ 		clear_perf_probe_event(pev);
+ 	free(priv);
+ 	return err;
+ }
+ 
+ static int bpf__prepare_probe(void)
+ {
+ 	static int err = 0;
+ 	static bool initialized = false;
+ 
+ 	/*
+ 	 * Make err static, so if init failed the first, bpf__prepare_probe()
+ 	 * fails each time without calling init_probe_symbol_maps multiple
+ 	 * times.
+ 	 */
+ 	if (initialized)
+ 		return err;
+ 
+ 	initialized = true;
+ 	err = init_probe_symbol_maps(false);
+ 	if (err < 0)
+ 		pr_debug("Failed to init_probe_symbol_maps\n");
+ 	probe_conf.max_probes = MAX_PROBES;
+ 	return err;
+ }
+ 
+ int bpf__probe(struct bpf_object *obj)
+ {
+ 	int err = 0;
+ 	struct bpf_program *prog;
+ 	struct bpf_prog_priv *priv;
+ 	struct perf_probe_event *pev;
+ 
+ 	err = bpf__prepare_probe();
+ 	if (err) {
+ 		pr_debug("bpf__prepare_probe failed\n");
+ 		return err;
+ 	}
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		err = config_bpf_program(prog);
+ 		if (err)
+ 			goto out;
+ 
+ 		err = bpf_program__get_private(prog, (void **)&priv);
+ 		if (err || !priv)
+ 			goto out;
+ 		pev = &priv->pev;
+ 
+ 		err = convert_perf_probe_events(pev, 1);
+ 		if (err < 0) {
+ 			pr_debug("bpf_probe: failed to convert perf probe events");
+ 			goto out;
+ 		}
+ 
+ 		err = apply_perf_probe_events(pev, 1);
+ 		if (err < 0) {
+ 			pr_debug("bpf_probe: failed to apply perf probe events");
+ 			goto out;
+ 		}
+ 	}
+ out:
+ 	return err < 0 ? err : 0;
+ }
+ 
+ #define EVENTS_WRITE_BUFSIZE  4096
+ int bpf__unprobe(struct bpf_object *obj)
+ {
+ 	int err, ret = 0;
+ 	struct bpf_program *prog;
+ 	struct bpf_prog_priv *priv;
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		int i;
+ 
+ 		err = bpf_program__get_private(prog, (void **)&priv);
+ 		if (err || !priv)
+ 			continue;
+ 
+ 		for (i = 0; i < priv->pev.ntevs; i++) {
+ 			struct probe_trace_event *tev = &priv->pev.tevs[i];
+ 			char name_buf[EVENTS_WRITE_BUFSIZE];
+ 			struct strfilter *delfilter;
+ 
+ 			snprintf(name_buf, EVENTS_WRITE_BUFSIZE,
+ 				 "%s:%s", tev->group, tev->event);
+ 			name_buf[EVENTS_WRITE_BUFSIZE - 1] = '\0';
+ 
+ 			delfilter = strfilter__new(name_buf, NULL);
+ 			if (!delfilter) {
+ 				pr_debug("Failed to create filter for unprobing\n");
+ 				ret = -ENOMEM;
+ 				continue;
+ 			}
+ 
+ 			err = del_perf_probe_events(delfilter);
+ 			strfilter__delete(delfilter);
+ 			if (err) {
+ 				pr_debug("Failed to delete %s\n", name_buf);
+ 				ret = err;
+ 				continue;
+ 			}
+ 		}
+ 	}
+ 	return ret;
+ }
+ 
+ int bpf__load(struct bpf_object *obj)
+ {
+ 	int err;
+ 
+ 	err = bpf_object__load(obj);
+ 	if (err) {
+ 		pr_debug("bpf: load objects failed\n");
+ 		return err;
+ 	}
+ 	return 0;
+ }
+ 
+ int bpf__foreach_tev(struct bpf_object *obj,
+ 		     bpf_prog_iter_callback_t func,
+ 		     void *arg)
+ {
+ 	struct bpf_program *prog;
+ 	int err;
+ 
+ 	bpf_object__for_each_program(prog, obj) {
+ 		struct probe_trace_event *tev;
+ 		struct perf_probe_event *pev;
+ 		struct bpf_prog_priv *priv;
+ 		int i, fd;
+ 
+ 		err = bpf_program__get_private(prog,
+ 				(void **)&priv);
+ 		if (err || !priv) {
+ 			pr_debug("bpf: failed to get private field\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		pev = &priv->pev;
+ 		for (i = 0; i < pev->ntevs; i++) {
+ 			tev = &pev->tevs[i];
+ 
+ 			fd = bpf_program__fd(prog);
+ 			if (fd < 0) {
+ 				pr_debug("bpf: failed to get file descriptor\n");
+ 				return fd;
+ 			}
+ 
+ 			err = (*func)(tev, fd, arg);
+ 			if (err) {
+ 				pr_debug("bpf: call back failed, stop iterate\n");
+ 				return err;
+ 			}
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ static int
+ bpf_loader_strerror(int err, char *buf, size_t size)
+ {
+ 	char sbuf[STRERR_BUFSIZE];
+ 	const char *msg;
+ 
+ 	if (!buf || !size)
+ 		return -1;
+ 
+ 	err = err > 0 ? err : -err;
+ 
+ 	if (err >= __LIBBPF_ERRNO__START)
+ 		return libbpf_strerror(err, buf, size);
+ 
+ 	msg = strerror_r(err, sbuf, sizeof(sbuf));
+ 	snprintf(buf, size, "%s", msg);
+ 	buf[size - 1] = '\0';
+ 	return 0;
+ }
+ 
+ #define bpf__strerror_head(err, buf, size) \
+ 	char sbuf[STRERR_BUFSIZE], *emsg;\
+ 	if (!size)\
+ 		return 0;\
+ 	if (err < 0)\
+ 		err = -err;\
+ 	bpf_loader_strerror(err, sbuf, sizeof(sbuf));\
+ 	emsg = sbuf;\
+ 	switch (err) {\
+ 	default:\
+ 		scnprintf(buf, size, "%s", emsg);\
+ 		break;
+ 
+ #define bpf__strerror_entry(val, fmt...)\
+ 	case val: {\
+ 		scnprintf(buf, size, fmt);\
+ 		break;\
+ 	}
+ 
+ #define bpf__strerror_end(buf, size)\
+ 	}\
+ 	buf[size - 1] = '\0';
+ 
+ int bpf__strerror_probe(struct bpf_object *obj __maybe_unused,
+ 			int err, char *buf, size_t size)
+ {
+ 	bpf__strerror_head(err, buf, size);
+ 	bpf__strerror_entry(EEXIST, "Probe point exist. Try use 'perf probe -d \"*\"'");
+ 	bpf__strerror_entry(EPERM, "You need to be root, and /proc/sys/kernel/kptr_restrict should be 0\n");
+ 	bpf__strerror_entry(ENOENT, "You need to check probing points in BPF file\n");
+ 	bpf__strerror_end(buf, size);
+ 	return 0;
+ }
+ 
+ int bpf__strerror_load(struct bpf_object *obj __maybe_unused,
+ 		       int err, char *buf, size_t size)
+ {
+ 	bpf__strerror_head(err, buf, size);
+ 	bpf__strerror_end(buf, size);
+ 	return 0;
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  }
diff --cc tools/perf/util/parse-events.c
index 3a234b74d6ff,c75b25d5e28c..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -590,6 -530,130 +590,133 @@@ static int add_tracepoint_multi_sys(str
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ struct __add_bpf_event_param {
+ 	struct parse_events_evlist *data;
+ 	struct list_head *list;
+ };
+ 
+ static int add_bpf_event(struct probe_trace_event *tev, int fd,
+ 			 void *_param)
+ {
+ 	LIST_HEAD(new_evsels);
+ 	struct __add_bpf_event_param *param = _param;
+ 	struct parse_events_evlist *evlist = param->data;
+ 	struct list_head *list = param->list;
+ 	struct perf_evsel *pos;
+ 	int err;
+ 
+ 	pr_debug("add bpf event %s:%s and attach bpf program %d\n",
+ 		 tev->group, tev->event, fd);
+ 
+ 	err = parse_events_add_tracepoint(&new_evsels, &evlist->idx, tev->group,
+ 					  tev->event, evlist->error, NULL);
+ 	if (err) {
+ 		struct perf_evsel *evsel, *tmp;
+ 
+ 		pr_debug("Failed to add BPF event %s:%s\n",
+ 			 tev->group, tev->event);
+ 		list_for_each_entry_safe(evsel, tmp, &new_evsels, node) {
+ 			list_del(&evsel->node);
+ 			perf_evsel__delete(evsel);
+ 		}
+ 		return err;
+ 	}
+ 	pr_debug("adding %s:%s\n", tev->group, tev->event);
+ 
+ 	list_for_each_entry(pos, &new_evsels, node) {
+ 		pr_debug("adding %s:%s to %p\n",
+ 			 tev->group, tev->event, pos);
+ 		pos->bpf_fd = fd;
+ 	}
+ 	list_splice(&new_evsels, list);
+ 	return 0;
+ }
+ 
+ int parse_events_load_bpf_obj(struct parse_events_evlist *data,
+ 			      struct list_head *list,
+ 			      struct bpf_object *obj)
+ {
+ 	int err;
+ 	char errbuf[BUFSIZ];
+ 	struct __add_bpf_event_param param = {data, list};
+ 	static bool registered_unprobe_atexit = false;
+ 
+ 	if (IS_ERR(obj) || !obj) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Internal error: load bpf obj with NULL");
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 
+ 	/*
+ 	 * Register atexit handler before calling bpf__probe() so
+ 	 * bpf__probe() don't need to unprobe probe points its already
+ 	 * created when failure.
+ 	 */
+ 	if (!registered_unprobe_atexit) {
+ 		atexit(bpf__clear);
+ 		registered_unprobe_atexit = true;
+ 	}
+ 
+ 	err = bpf__probe(obj);
+ 	if (err) {
+ 		bpf__strerror_probe(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__load(obj);
+ 	if (err) {
+ 		bpf__strerror_load(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__foreach_tev(obj, add_bpf_event, &param);
+ 	if (err) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Attach events in BPF object failed");
+ 		goto errout;
+ 	}
+ 
+ 	return 0;
+ errout:
+ 	data->error->help = strdup("(add -v to see detail)");
+ 	data->error->str = strdup(errbuf);
+ 	return err;
+ }
+ 
+ int parse_events_load_bpf(struct parse_events_evlist *data,
+ 			  struct list_head *list,
+ 			  char *bpf_file_name,
+ 			  bool source)
+ {
+ 	struct bpf_object *obj;
+ 
+ 	obj = bpf__prepare_load(bpf_file_name, source);
+ 	if (IS_ERR(obj)) {
+ 		char errbuf[BUFSIZ];
+ 		int err;
+ 
+ 		err = PTR_ERR(obj);
+ 
+ 		if (err == -ENOTSUP)
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "BPF support is not compiled");
+ 		else
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "BPF object file '%s' is invalid",
+ 				 bpf_file_name);
+ 
+ 		data->error->help = strdup("(add -v to see detail)");
+ 		data->error->str = strdup(errbuf);
+ 		return err;
+ 	}
+ 
+ 	return parse_events_load_bpf_obj(data, list, obj);
+ }
+ 
++>>>>>>> 6371ca3b541c (bpf tools: Improve libbpf error reporting)
  static int
  parse_breakpoint_type(const char *type, struct perf_event_attr *attr)
  {
* Unmerged path tools/perf/tests/llvm.c
* Unmerged path tools/lib/bpf/libbpf.c
* Unmerged path tools/lib/bpf/libbpf.h
* Unmerged path tools/perf/tests/llvm.c
* Unmerged path tools/perf/util/bpf-loader.c
* Unmerged path tools/perf/util/parse-events.c
