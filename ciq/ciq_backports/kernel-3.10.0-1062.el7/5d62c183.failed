nohz: Prevent a timer interrupt storm in tick_nohz_stop_sched_tick()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 5d62c183f9e9df1deeea0906d099a94e8a43047a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/5d62c183.failed

The conditions in irq_exit() to invoke tick_nohz_irq_exit() which
subsequently invokes tick_nohz_stop_sched_tick() are:

  if ((idle_cpu(cpu) && !need_resched()) || tick_nohz_full_cpu(cpu))

If need_resched() is not set, but a timer softirq is pending then this is
an indication that the softirq code punted and delegated the execution to
softirqd. need_resched() is not true because the current interrupted task
takes precedence over softirqd.

Invoking tick_nohz_irq_exit() in this case can cause an endless loop of
timer interrupts because the timer wheel contains an expired timer, but
softirqs are not yet executed. So it returns an immediate expiry request,
which causes the timer to fire immediately again. Lather, rinse and
repeat....

Prevent that by adding a check for a pending timer soft interrupt to the
conditions in tick_nohz_stop_sched_tick() which avoid calling
get_next_timer_interrupt(). That keeps the tick sched timer on the tick and
prevents a repetitive programming of an already expired timer.

	Reported-by: Sebastian Siewior <bigeasy@linutronix.d>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Anna-Maria Gleixner <anna-maria@linutronix.de>
	Cc: Sebastian Siewior <bigeasy@linutronix.de>
	Cc: stable@vger.kernel.org
Link: https://lkml.kernel.org/r/alpine.DEB.2.20.1712272156050.2431@nanos

(cherry picked from commit 5d62c183f9e9df1deeea0906d099a94e8a43047a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/tick-sched.c
diff --cc kernel/time/tick-sched.c
index 8b8d105721e7,f7cc7abfcf25..000000000000
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@@ -570,9 -647,14 +570,14 @@@ static void tick_nohz_restart(struct ti
  	 * Reset to make sure next tick stop doesn't get fooled by past
  	 * cached clock deadline.
  	 */
 -	ts->next_tick = 0;
 +	ts->next_tick.tv64 = 0;
  }
  
+ static inline bool local_timer_softirq_pending(void)
+ {
+ 	return local_softirq_pending() & TIMER_SOFTIRQ;
+ }
+ 
  static ktime_t tick_nohz_stop_sched_tick(struct tick_sched *ts,
  					 ktime_t now, int cpu)
  {
@@@ -589,8 -671,18 +594,23 @@@
  	} while (read_seqretry(&jiffies_lock, seq));
  	ts->last_jiffies = basejiff;
  
++<<<<<<< HEAD
 +	if (rcu_needs_cpu(cpu, &next_rcu) ||
 +	    arch_needs_cpu(cpu) || irq_work_needs_cpu()) {
++=======
+ 	/*
+ 	 * Keep the periodic tick, when RCU, architecture or irq_work
+ 	 * requests it.
+ 	 * Aside of that check whether the local timer softirq is
+ 	 * pending. If so its a bad idea to call get_next_timer_interrupt()
+ 	 * because there is an already expired timer, so it will request
+ 	 * immeditate expiry, which rearms the hardware timer with a
+ 	 * minimal delta which brings us back to this place
+ 	 * immediately. Lather, rinse and repeat...
+ 	 */
+ 	if (rcu_needs_cpu(basemono, &next_rcu) || arch_needs_cpu() ||
+ 	    irq_work_needs_cpu() || local_timer_softirq_pending()) {
++>>>>>>> 5d62c183f9e9 (nohz: Prevent a timer interrupt storm in tick_nohz_stop_sched_tick())
  		next_tick = basemono + TICK_NSEC;
  	} else {
  		/*
* Unmerged path kernel/time/tick-sched.c
