net: add skb_to_full_sk() helper and use it in selinux_netlbl_skbuff_setsid()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [net] add skb_to_full_sk() helper and use it in selinux_netlbl_skbuff_setsid() (Flavio Leitner) [1554261]
Rebuild_FUZZ: 96.64%
commit-author Eric Dumazet <edumazet@google.com>
commit 54abc686c2d111e98228943a7e1e51cc256e35d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/54abc686.failed

Generalize selinux_skb_sk() added in commit 212cd0895330
("selinux: fix random read in selinux_ip_postroute_compat()")
so that we can use it other contexts.

Use it right away in selinux_netlbl_skbuff_setsid()

Fixes: ca6fb0651883 ("tcp: attach SYNACK messages to request sockets instead of listener")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 54abc686c2d111e98228943a7e1e51cc256e35d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/inet_sock.h
#	security/selinux/hooks.c
diff --cc include/net/inet_sock.h
index adb8a8b50c3e,2134e6d815bc..000000000000
--- a/include/net/inet_sock.h
+++ b/include/net/inet_sock.h
@@@ -188,6 -200,28 +188,31 @@@ struct inet_sock 
  #define IPCORK_OPT	1	/* ip-options has been held in ipcork.opt */
  #define IPCORK_ALLFRAG	2	/* always fragment (for ipv6 for now) */
  
++<<<<<<< HEAD
++=======
+ /* cmsg flags for inet */
+ #define IP_CMSG_PKTINFO		BIT(0)
+ #define IP_CMSG_TTL		BIT(1)
+ #define IP_CMSG_TOS		BIT(2)
+ #define IP_CMSG_RECVOPTS	BIT(3)
+ #define IP_CMSG_RETOPTS		BIT(4)
+ #define IP_CMSG_PASSSEC		BIT(5)
+ #define IP_CMSG_ORIGDSTADDR	BIT(6)
+ #define IP_CMSG_CHECKSUM	BIT(7)
+ 
+ /* SYNACK messages might be attached to request sockets.
+  * Some places want to reach the listener in this case.
+  */
+ static inline struct sock *skb_to_full_sk(const struct sk_buff *skb)
+ {
+ 	struct sock *sk = skb->sk;
+ 
+ 	if (sk && sk->sk_state == TCP_NEW_SYN_RECV)
+ 		sk = inet_reqsk(sk)->rsk_listener;
+ 	return sk;
+ }
+ 
++>>>>>>> 54abc686c2d1 (net: add skb_to_full_sk() helper and use it in selinux_netlbl_skbuff_setsid())
  static inline struct inet_sock *inet_sk(const struct sock *sk)
  {
  	return (struct inet_sock *)sk;
diff --cc security/selinux/hooks.c
index 446d7e4737ae,23307da15f1d..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -5119,7 -4935,7 +5119,11 @@@ static unsigned int selinux_ip_postrout
  						int ifindex,
  						u16 family)
  {
++<<<<<<< HEAD
 +	struct sock *sk = skb->sk;
++=======
+ 	struct sock *sk = skb_to_full_sk(skb);
++>>>>>>> 54abc686c2d1 (net: add skb_to_full_sk() helper and use it in selinux_netlbl_skbuff_setsid())
  	struct sk_security_struct *sksec;
  	struct common_audit_data ad;
  	struct lsm_network_audit net = {0,};
@@@ -5174,7 -4990,7 +5178,11 @@@ static unsigned int selinux_ip_postrout
  	if (!secmark_active && !peerlbl_active)
  		return NF_ACCEPT;
  
++<<<<<<< HEAD
 +	sk = skb->sk;
++=======
+ 	sk = skb_to_full_sk(skb);
++>>>>>>> 54abc686c2d1 (net: add skb_to_full_sk() helper and use it in selinux_netlbl_skbuff_setsid())
  
  #ifdef CONFIG_XFRM
  	/* If skb->dst->xfrm is non-NULL then the packet is undergoing an IPsec
* Unmerged path include/net/inet_sock.h
* Unmerged path security/selinux/hooks.c
diff --git a/security/selinux/netlabel.c b/security/selinux/netlabel.c
index 6235d052338b..955777a0e1f0 100644
--- a/security/selinux/netlabel.c
+++ b/security/selinux/netlabel.c
@@ -219,7 +219,7 @@ int selinux_netlbl_skbuff_setsid(struct sk_buff *skb,
 
 	/* if this is a locally generated packet check to see if it is already
 	 * being labeled by it's parent socket, if it is just exit */
-	sk = skb->sk;
+	sk = skb_to_full_sk(skb);
 	if (sk != NULL) {
 		struct sk_security_struct *sksec = sk->sk_security;
 		if (sksec->nlbl_state != NLBL_REQSKB)
