net: phy: switch remaining users to phy_(read|write)_mmd()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] phy: switch remaining users to phy_(read|write)_mmd() (Ivan Vecera) [1655590]
Rebuild_FUZZ: 95.50%
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit a6d99fcd3fc4f6e71630eba8e7f4d2b3b396c4c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a6d99fcd.failed

Switch everyone over to using phy_read_mmd() and phy_write_mmd() now
that they are able to handle both Clause 22 indirect addressing and
Clause 45 direct addressing methods to the MMD registers.

	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a6d99fcd3fc4f6e71630eba8e7f4d2b3b396c4c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/bcm-phy-lib.c
#	drivers/net/phy/dp83867.c
#	drivers/net/phy/intel-xway.c
#	drivers/net/phy/microchip.c
#	drivers/net/phy/phy.c
#	drivers/net/phy/phy_device.c
diff --cc drivers/net/phy/phy.c
index f64de02dbd2e,ba4676ee9018..000000000000
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@@ -1086,8 -1227,7 +1086,12 @@@ int phy_init_eee(struct phy_device *phy
  			return status;
  
  		/* First check if the EEE ability is supported */
++<<<<<<< HEAD
 +		eee_cap = phy_read_mmd_indirect(phydev->bus, MDIO_PCS_EEE_ABLE,
 +						MDIO_MMD_PCS, phydev->addr);
++=======
+ 		eee_cap = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
++>>>>>>> a6d99fcd3fc4 (net: phy: switch remaining users to phy_(read|write)_mmd())
  		if (eee_cap <= 0)
  			goto eee_exit_err;
  
@@@ -1098,13 -1238,11 +1102,21 @@@
  		/* Check which link settings negotiated and verify it in
  		 * the EEE advertising registers.
  		 */
++<<<<<<< HEAD
 +		eee_lp = phy_read_mmd_indirect(phydev->bus, MDIO_AN_EEE_LPABLE,
 +					       MDIO_MMD_AN, phydev->addr);
 +		if (eee_lp <= 0)
 +			goto eee_exit_err;
 +
 +		eee_adv = phy_read_mmd_indirect(phydev->bus, MDIO_AN_EEE_ADV,
 +						MDIO_MMD_AN, phydev->addr);
++=======
+ 		eee_lp = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE);
+ 		if (eee_lp <= 0)
+ 			goto eee_exit_err;
+ 
+ 		eee_adv = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
++>>>>>>> a6d99fcd3fc4 (net: phy: switch remaining users to phy_(read|write)_mmd())
  		if (eee_adv <= 0)
  			goto eee_exit_err;
  
@@@ -1118,15 -1255,12 +1130,23 @@@
  			/* Configure the PHY to stop receiving xMII
  			 * clock while it is signaling LPI.
  			 */
++<<<<<<< HEAD
 +			int val = phy_read_mmd_indirect(phydev->bus, MDIO_CTRL1,
 +							MDIO_MMD_PCS,
 +							phydev->addr);
++=======
+ 			int val = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1);
++>>>>>>> a6d99fcd3fc4 (net: phy: switch remaining users to phy_(read|write)_mmd())
  			if (val < 0)
  				return val;
  
  			val |= MDIO_PCS_CTRL1_CLKSTOP_EN;
++<<<<<<< HEAD
 +			phy_write_mmd_indirect(phydev->bus, MDIO_CTRL1,
 +					       MDIO_MMD_PCS, phydev->addr, val);
++=======
+ 			phy_write_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1, val);
++>>>>>>> a6d99fcd3fc4 (net: phy: switch remaining users to phy_(read|write)_mmd())
  		}
  
  		return 0; /* EEE supported */
@@@ -1145,8 -1279,10 +1165,15 @@@ EXPORT_SYMBOL(phy_init_eee)
   */
  int phy_get_eee_err(struct phy_device *phydev)
  {
++<<<<<<< HEAD
 +	return phy_read_mmd_indirect(phydev->bus, MDIO_PCS_EEE_WK_ERR,
 +				     MDIO_MMD_PCS, phydev->addr);
++=======
+ 	if (!phydev->drv)
+ 		return -EIO;
+ 
+ 	return phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_EEE_WK_ERR);
++>>>>>>> a6d99fcd3fc4 (net: phy: switch remaining users to phy_(read|write)_mmd())
  }
  EXPORT_SYMBOL(phy_get_eee_err);
  
@@@ -1162,23 -1298,23 +1189,35 @@@ int phy_ethtool_get_eee(struct phy_devi
  {
  	int val;
  
 -	if (!phydev->drv)
 -		return -EIO;
 -
  	/* Get Supported EEE */
++<<<<<<< HEAD
 +	val = phy_read_mmd_indirect(phydev->bus, MDIO_PCS_EEE_ABLE,
 +				    MDIO_MMD_PCS, phydev->addr);
++=======
+ 	val = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_EEE_ABLE);
++>>>>>>> a6d99fcd3fc4 (net: phy: switch remaining users to phy_(read|write)_mmd())
  	if (val < 0)
  		return val;
  	data->supported = mmd_eee_cap_to_ethtool_sup_t(val);
  
  	/* Get advertisement EEE */
++<<<<<<< HEAD
 +	val = phy_read_mmd_indirect(phydev->bus, MDIO_AN_EEE_ADV,
 +				    MDIO_MMD_AN, phydev->addr);
++=======
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
++>>>>>>> a6d99fcd3fc4 (net: phy: switch remaining users to phy_(read|write)_mmd())
  	if (val < 0)
  		return val;
  	data->advertised = mmd_eee_adv_to_ethtool_adv_t(val);
  
  	/* Get LP advertisement EEE */
++<<<<<<< HEAD
 +	val = phy_read_mmd_indirect(phydev->bus, MDIO_AN_EEE_LPABLE,
 +				    MDIO_MMD_AN, phydev->addr);
++=======
+ 	val = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE);
++>>>>>>> a6d99fcd3fc4 (net: phy: switch remaining users to phy_(read|write)_mmd())
  	if (val < 0)
  		return val;
  	data->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(val);
@@@ -1198,8 -1334,13 +1237,18 @@@ int phy_ethtool_set_eee(struct phy_devi
  {
  	int val = ethtool_adv_to_mmd_eee_adv_t(data->advertised);
  
++<<<<<<< HEAD
 +	phy_write_mmd_indirect(phydev->bus, MDIO_AN_EEE_ADV, MDIO_MMD_AN,
 +			       phydev->addr, val);
++=======
+ 	if (!phydev->drv)
+ 		return -EIO;
+ 
+ 	/* Mask prohibited EEE modes */
+ 	val &= ~phydev->eee_broken_modes;
+ 
+ 	phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, val);
++>>>>>>> a6d99fcd3fc4 (net: phy: switch remaining users to phy_(read|write)_mmd())
  
  	return 0;
  }
diff --cc drivers/net/phy/phy_device.c
index 2dbcaed2657a,1219eeab69d1..000000000000
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@@ -822,6 -1197,43 +822,46 @@@ static int genphy_config_advert(struct 
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * genphy_config_eee_advert - disable unwanted eee mode advertisement
+  * @phydev: target phy_device struct
+  *
+  * Description: Writes MDIO_AN_EEE_ADV after disabling unsupported energy
+  *   efficent ethernet modes. Returns 0 if the PHY's advertisement hasn't
+  *   changed, and 1 if it has changed.
+  */
+ static int genphy_config_eee_advert(struct phy_device *phydev)
+ {
+ 	int broken = phydev->eee_broken_modes;
+ 	int old_adv, adv;
+ 
+ 	/* Nothing to disable */
+ 	if (!broken)
+ 		return 0;
+ 
+ 	/* If the following call fails, we assume that EEE is not
+ 	 * supported by the phy. If we read 0, EEE is not advertised
+ 	 * In both case, we don't need to continue
+ 	 */
+ 	adv = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV);
+ 	if (adv <= 0)
+ 		return 0;
+ 
+ 	old_adv = adv;
+ 	adv &= ~broken;
+ 
+ 	/* Advertising remains unchanged with the broken mask */
+ 	if (old_adv == adv)
+ 		return 0;
+ 
+ 	phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, adv);
+ 
+ 	return 1;
+ }
+ 
+ /**
++>>>>>>> a6d99fcd3fc4 (net: phy: switch remaining users to phy_(read|write)_mmd())
   * genphy_setup_forced - configures/forces speed/duplex from @phydev
   * @phydev: target phy_device struct
   *
* Unmerged path drivers/net/phy/bcm-phy-lib.c
* Unmerged path drivers/net/phy/dp83867.c
* Unmerged path drivers/net/phy/intel-xway.c
* Unmerged path drivers/net/phy/microchip.c
* Unmerged path drivers/net/phy/bcm-phy-lib.c
* Unmerged path drivers/net/phy/dp83867.c
* Unmerged path drivers/net/phy/intel-xway.c
* Unmerged path drivers/net/phy/microchip.c
* Unmerged path drivers/net/phy/phy.c
* Unmerged path drivers/net/phy/phy_device.c
