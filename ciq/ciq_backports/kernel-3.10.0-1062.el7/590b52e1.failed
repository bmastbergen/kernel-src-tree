netfilter: conntrack: skip clash resolution if nat is in place

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 590b52e10d410e1439ae86be9fe19d75fdab628b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/590b52e1.failed

The clash resolution is not easy to apply if the NAT table is
registered. Even if no NAT rules are installed, the nul-binding ensures
that a unique tuple is used, thus, the packet that loses race gets a
different source port number, as described by:

http://marc.info/?l=netfilter-devel&m=146818011604484&w=2

Clash resolution with NAT is also problematic if addresses/port range
ports are used since the conntrack that wins race may describe a
different mangling that we may have earlier applied to the packet via
nf_nat_setup_info().

Fixes: 71d8c47fc653 ("netfilter: conntrack: introduce clash resolution on insertion race")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
	Tested-by: Marc Dionne <marc.c.dionne@gmail.com>
(cherry picked from commit 590b52e10d410e1439ae86be9fe19d75fdab628b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_core.c
diff --cc net/netfilter/nf_conntrack_core.c
index 5a73e052c209,9f530adad10d..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -640,6 -604,63 +640,66 @@@ out
  }
  EXPORT_SYMBOL_GPL(nf_conntrack_hash_check_insert);
  
++<<<<<<< HEAD
++=======
+ static inline void nf_ct_acct_update(struct nf_conn *ct,
+ 				     enum ip_conntrack_info ctinfo,
+ 				     unsigned int len)
+ {
+ 	struct nf_conn_acct *acct;
+ 
+ 	acct = nf_conn_acct_find(ct);
+ 	if (acct) {
+ 		struct nf_conn_counter *counter = acct->counter;
+ 
+ 		atomic64_inc(&counter[CTINFO2DIR(ctinfo)].packets);
+ 		atomic64_add(len, &counter[CTINFO2DIR(ctinfo)].bytes);
+ 	}
+ }
+ 
+ static void nf_ct_acct_merge(struct nf_conn *ct, enum ip_conntrack_info ctinfo,
+ 			     const struct nf_conn *loser_ct)
+ {
+ 	struct nf_conn_acct *acct;
+ 
+ 	acct = nf_conn_acct_find(loser_ct);
+ 	if (acct) {
+ 		struct nf_conn_counter *counter = acct->counter;
+ 		unsigned int bytes;
+ 
+ 		/* u32 should be fine since we must have seen one packet. */
+ 		bytes = atomic64_read(&counter[CTINFO2DIR(ctinfo)].bytes);
+ 		nf_ct_acct_update(ct, ctinfo, bytes);
+ 	}
+ }
+ 
+ /* Resolve race on insertion if this protocol allows this. */
+ static int nf_ct_resolve_clash(struct net *net, struct sk_buff *skb,
+ 			       enum ip_conntrack_info ctinfo,
+ 			       struct nf_conntrack_tuple_hash *h)
+ {
+ 	/* This is the conntrack entry already in hashes that won race. */
+ 	struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);
+ 	struct nf_conntrack_l4proto *l4proto;
+ 
+ 	l4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
+ 	if (l4proto->allow_clash &&
+ 	    !nfct_nat(ct) &&
+ 	    !nf_ct_is_dying(ct) &&
+ 	    atomic_inc_not_zero(&ct->ct_general.use)) {
+ 		nf_ct_acct_merge(ct, ctinfo, (struct nf_conn *)skb->nfct);
+ 		nf_conntrack_put(skb->nfct);
+ 		/* Assign conntrack already in hashes to this skbuff. Don't
+ 		 * modify skb->nfctinfo to ensure consistent stateful filtering.
+ 		 */
+ 		skb->nfct = &ct->ct_general;
+ 		return NF_ACCEPT;
+ 	}
+ 	NF_CT_STAT_INC(net, drop);
+ 	return NF_DROP;
+ }
+ 
++>>>>>>> 590b52e10d41 (netfilter: conntrack: skip clash resolution if nat is in place)
  /* Confirm a connection given skb; places it in hash table */
  int
  __nf_conntrack_confirm(struct sk_buff *skb)
* Unmerged path net/netfilter/nf_conntrack_core.c
