tcp: when rearming RTO, if RTO time is in past then fire RTO ASAP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Neal Cardwell <ncardwell@google.com>
commit cdbeb633ca71a02b7b63bfeb94994bf4e1a0b894
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/cdbeb633.failed

In some situations tcp_send_loss_probe() can realize that it's unable
to send a loss probe (TLP), and falls back to calling tcp_rearm_rto()
to schedule an RTO timer. In such cases, sometimes tcp_rearm_rto()
realizes that the RTO was eligible to fire immediately or at some
point in the past (delta_us <= 0). Previously in such cases
tcp_rearm_rto() was scheduling such "overdue" RTOs to happen at now +
icsk_rto, which caused needless delays of hundreds of milliseconds
(and non-linear behavior that made reproducible testing
difficult). This commit changes the logic to schedule "overdue" RTOs
ASAP, rather than at now + icsk_rto.

Fixes: 6ba8a3b19e76 ("tcp: Tail loss probe (TLP)")
	Suggested-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cdbeb633ca71a02b7b63bfeb94994bf4e1a0b894)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index da081b2e918a,bab7f0493098..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -2998,17 -3003,13 +2998,21 @@@ void tcp_rearm_rto(struct sock *sk
  	} else {
  		u32 rto = inet_csk(sk)->icsk_rto;
  		/* Offset the time elapsed after installing regular RTO */
 -		if (icsk->icsk_pending == ICSK_TIME_REO_TIMEOUT ||
 +		if (icsk->icsk_pending == ICSK_TIME_EARLY_RETRANS ||
  		    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {
 -			s64 delta_us = tcp_rto_delta_us(sk);
 -			/* delta_us may not be positive if the socket is locked
 +			struct sk_buff *skb = tcp_write_queue_head(sk);
 +			const u32 rto_time_stamp =
 +				tcp_skb_timestamp(skb) + rto;
 +			s32 delta = (s32)(rto_time_stamp - tcp_time_stamp);
 +			/* delta may not be positive if the socket is locked
  			 * when the retrans timer fires and is rescheduled.
  			 */
++<<<<<<< HEAD
 +			if (delta > 0)
 +				rto = delta;
++=======
+ 			rto = usecs_to_jiffies(max_t(int, delta_us, 1));
++>>>>>>> cdbeb633ca71 (tcp: when rearming RTO, if RTO time is in past then fire RTO ASAP)
  		}
  		inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, rto,
  					  TCP_RTO_MAX);
* Unmerged path net/ipv4/tcp_input.c
