net/mlx5e: Fail attempt to offload e-switch TC flows with egress upper devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Fail attempt to offload e-switch TC flows with egress upper devices (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 97.37%
commit-author Eli Britstein <elibr@mellanox.com>
commit a0646c88ed3ac527b71cf365b03ff4fc729d35b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a0646c88.failed

We use the switchdev parent HW id helper to identify if the mirred device
shares the same ASIC/port with the ingress device. This can get us wrong
in the presence of upper devices such as vlan or bridge set over the HW
devices (VF or uplink representors), b/c the switchdev ID is retrieved
recursively.

To fail offload attempts in such cases, we condition the check on the
egress device to have not only the same switchdev ID but also the relevant
mlx5 netdev ops.

Fixes: 03a9d11e6eeb ('net/mlx5e: Add TC drop and mirred/redirect action parsing for SRIOV offloads')
	Signed-off-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Acked-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a0646c88ed3ac527b71cf365b03ff4fc729d35b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 1af2953c38f5,f414f19c1159..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -1077,27 -1284,55 +1077,72 @@@ static const struct switchdev_ops mlx5e
  	.switchdev_port_attr_get	= mlx5e_attr_get,
  };
  
++<<<<<<< HEAD
 +static int mlx5e_change_rep_mtu(struct net_device *netdev, int new_mtu)
++=======
+ static const struct net_device_ops mlx5e_netdev_ops_vf_rep = {
+ 	.ndo_open                = mlx5e_vf_rep_open,
+ 	.ndo_stop                = mlx5e_vf_rep_close,
+ 	.ndo_start_xmit          = mlx5e_xmit,
+ 	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
+ 	.ndo_setup_tc            = mlx5e_rep_setup_tc,
+ 	.ndo_get_stats64         = mlx5e_vf_rep_get_stats,
+ 	.ndo_has_offload_stats	 = mlx5e_rep_has_offload_stats,
+ 	.ndo_get_offload_stats	 = mlx5e_rep_get_offload_stats,
+ 	.ndo_change_mtu          = mlx5e_vf_rep_change_mtu,
+ };
+ 
+ static const struct net_device_ops mlx5e_netdev_ops_uplink_rep = {
+ 	.ndo_open                = mlx5e_open,
+ 	.ndo_stop                = mlx5e_close,
+ 	.ndo_start_xmit          = mlx5e_xmit,
+ 	.ndo_set_mac_address     = mlx5e_uplink_rep_set_mac,
+ 	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
+ 	.ndo_setup_tc            = mlx5e_rep_setup_tc,
+ 	.ndo_get_stats64         = mlx5e_get_stats,
+ 	.ndo_has_offload_stats	 = mlx5e_rep_has_offload_stats,
+ 	.ndo_get_offload_stats	 = mlx5e_rep_get_offload_stats,
+ 	.ndo_change_mtu          = mlx5e_uplink_rep_change_mtu,
+ 	.ndo_udp_tunnel_add      = mlx5e_add_vxlan_port,
+ 	.ndo_udp_tunnel_del      = mlx5e_del_vxlan_port,
+ 	.ndo_features_check      = mlx5e_features_check,
+ 	.ndo_set_vf_mac          = mlx5e_set_vf_mac,
+ 	.ndo_set_vf_rate         = mlx5e_set_vf_rate,
+ 	.ndo_get_vf_config       = mlx5e_get_vf_config,
+ 	.ndo_get_vf_stats        = mlx5e_get_vf_stats,
+ };
+ 
+ bool mlx5e_eswitch_rep(struct net_device *netdev)
+ {
+ 	if (netdev->netdev_ops == &mlx5e_netdev_ops_vf_rep ||
+ 	    netdev->netdev_ops == &mlx5e_netdev_ops_uplink_rep)
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ static void mlx5e_build_rep_params(struct net_device *netdev)
++>>>>>>> a0646c88ed3a (net/mlx5e: Fail attempt to offload e-switch TC flows with egress upper devices)
  {
 -	struct mlx5e_priv *priv = netdev_priv(netdev);
 -	struct mlx5e_rep_priv *rpriv = priv->ppriv;
 -	struct mlx5_eswitch_rep *rep = rpriv->rep;
 -	struct mlx5_core_dev *mdev = priv->mdev;
 -	struct mlx5e_params *params;
 +	return mlx5e_change_mtu(netdev, new_mtu, NULL);
 +}
 +
 +static const struct net_device_ops mlx5e_netdev_ops_rep = {
 +	.ndo_size                = sizeof(struct net_device_ops),
 +	.ndo_open                = mlx5e_rep_open,
 +	.ndo_stop                = mlx5e_rep_close,
 +	.ndo_start_xmit          = mlx5e_xmit,
 +	.extended.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
 +	.extended.ndo_setup_tc_rh = mlx5e_rep_setup_tc,
 +	.ndo_get_stats64         = mlx5e_rep_get_stats,
 +	.extended.ndo_has_offload_stats	 = mlx5e_has_offload_stats,
 +	.extended.ndo_get_offload_stats	 = mlx5e_get_offload_stats,
 +	.extended.ndo_change_mtu	= mlx5e_change_rep_mtu,
 +};
  
 +static void mlx5e_build_rep_params(struct mlx5_core_dev *mdev,
 +				   struct mlx5e_params *params, u16 mtu)
 +{
  	u8 cq_period_mode = MLX5_CAP_GEN(mdev, cq_period_start_from_cqe) ?
  					 MLX5_CQ_PERIOD_MODE_START_FROM_CQE :
  					 MLX5_CQ_PERIOD_MODE_START_FROM_EQE;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index fbb4f1b36627,9ba8ade3be47..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2622,29 -2539,80 +2622,46 @@@ static int parse_tc_fdb_actions(struct 
  			continue;
  		}
  
 -		if (is_tcf_csum(a)) {
 -			if (csum_offload_supported(priv, action,
 -						   tcf_csum_update_flags(a),
 -						   extack))
 -				continue;
 -
 -			return -EOPNOTSUPP;
 -		}
 -
 -		if (is_tcf_mirred_egress_redirect(a) || is_tcf_mirred_egress_mirror(a)) {
 -			struct mlx5e_priv *out_priv;
 +		if (is_tcf_mirred_egress_redirect(a)) {
  			struct net_device *out_dev;
 +			struct mlx5e_priv *out_priv;
  
  			out_dev = tcf_mirred_dev(a);
 -			if (!out_dev) {
 -				/* out_dev is NULL when filters with
 -				 * non-existing mirred device are replayed to
 -				 * the driver.
 -				 */
 -				return -EINVAL;
 -			}
  
 -			if (attr->out_count >= MLX5_MAX_FLOW_FWD_VPORTS) {
 -				NL_SET_ERR_MSG_MOD(extack,
 -						   "can't support more output ports, can't offload forwarding");
 -				pr_err("can't support more than %d output ports, can't offload forwarding\n",
 -				       attr->out_count);
 -				return -EOPNOTSUPP;
 -			}
 -
 -			action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 -				  MLX5_FLOW_CONTEXT_ACTION_COUNT;
  			if (switchdev_port_same_parent_id(priv->netdev,
++<<<<<<< HEAD
 +							  out_dev)) {
 +				attr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +					MLX5_FLOW_CONTEXT_ACTION_COUNT;
++=======
+ 							  out_dev) ||
+ 			    is_merged_eswitch_dev(priv, out_dev)) {
+ 				struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
+ 				struct net_device *uplink_dev = mlx5_eswitch_uplink_get_proto_dev(esw, REP_ETH);
+ 				struct net_device *uplink_upper = netdev_master_upper_dev_get(uplink_dev);
+ 
+ 				if (uplink_upper &&
+ 				    netif_is_lag_master(uplink_upper) &&
+ 				    uplink_upper == out_dev)
+ 					out_dev = uplink_dev;
+ 
+ 				if (!mlx5e_eswitch_rep(out_dev))
+ 					return -EOPNOTSUPP;
+ 
++>>>>>>> a0646c88ed3a (net/mlx5e: Fail attempt to offload e-switch TC flows with egress upper devices)
  				out_priv = netdev_priv(out_dev);
  				rpriv = out_priv->ppriv;
 -				attr->dests[attr->out_count].rep = rpriv->rep;
 -				attr->dests[attr->out_count].mdev = out_priv->mdev;
 -				attr->out_count++;
 +				attr->out_rep = rpriv->rep;
 +				attr->out_mdev = out_priv->mdev;
  			} else if (encap) {
 -				parse_attr->mirred_ifindex[attr->out_count] =
 -					out_dev->ifindex;
 -				parse_attr->tun_info[attr->out_count] = *info;
 -				encap = false;
 +				parse_attr->mirred_ifindex = out_dev->ifindex;
 +				parse_attr->tun_info = *info;
  				attr->parse_attr = parse_attr;
 -				attr->dests[attr->out_count].flags |=
 -					MLX5_ESW_DEST_ENCAP;
 -				attr->out_count++;
 -				/* attr->dests[].rep is resolved when we
 -				 * handle encap
 -				 */
 -			} else if (parse_attr->filter_dev != priv->netdev) {
 -				/* All mlx5 devices are called to configure
 -				 * high level device filters. Therefore, the
 -				 * *attempt* to  install a filter on invalid
 -				 * eswitch should not trigger an explicit error
 -				 */
 -				return -EINVAL;
 +				attr->action |= MLX5_FLOW_CONTEXT_ACTION_ENCAP |
 +					MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +					MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +				/* attr->out_rep is resolved when we handle encap */
  			} else {
 -				NL_SET_ERR_MSG_MOD(extack,
 -						   "devices are not on same switch HW, can't offload forwarding");
  				pr_err("devices %s %s not on same switch HW, can't offload forwarding\n",
  				       priv->netdev->name, out_dev->name);
  				return -EINVAL;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index c078c6703dc7..2222709a7108 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -178,6 +178,9 @@ void mlx5e_rep_encap_entry_detach(struct mlx5e_priv *priv,
 				  struct mlx5e_encap_entry *e);
 
 void mlx5e_rep_queue_neigh_stats_work(struct mlx5e_priv *priv);
+
+bool mlx5e_eswitch_rep(struct net_device *netdev);
+
 #else /* CONFIG_MLX5_ESWITCH */
 static inline void mlx5e_register_vport_reps(struct mlx5e_priv *priv) {}
 static inline void mlx5e_unregister_vport_reps(struct mlx5e_priv *priv) {}
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
