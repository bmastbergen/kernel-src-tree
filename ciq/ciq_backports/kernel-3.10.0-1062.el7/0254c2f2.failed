xfs: remove the nr_extents argument to xfs_iext_insert

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 0254c2f253d6fe11ea2ce5046ed6acfddbe4ee17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0254c2f2.failed

We only have two places that insert 2 extents at the same time, so unroll
the loop there.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 0254c2f253d6fe11ea2ce5046ed6acfddbe4ee17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_iext_tree.c
#	fs/xfs/libxfs/xfs_inode_fork.c
#	fs/xfs/libxfs/xfs_inode_fork.h
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 59769f7334d7,2656b6cbbb6c..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -901,11 -900,9 +901,16 @@@ xfs_bmap_local_to_extents
  	rec.br_startblock = args.fsbno;
  	rec.br_blockcount = 1;
  	rec.br_state = XFS_EXT_NORM;
++<<<<<<< HEAD
 +	xfs_iext_insert(ip, 0, 1, &rec, 0);
++=======
+ 	xfs_iext_first(ifp, &icur);
+ 	xfs_iext_insert(ip, &icur, &rec, 0);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  
 +	trace_xfs_bmap_post_update(ip, 0,
 +			whichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0,
 +			_THIS_IP_);
  	XFS_IFORK_NEXT_SET(ip, whichfork, 1);
  	ip->i_d.di_nblocks = 1;
  	xfs_trans_mod_dquot_byino(tp, ip,
@@@ -1257,15 -1260,17 +1262,22 @@@ xfs_bmap_read_extents
  		 * Copy records into the extent records.
  		 */
  		frp = XFS_BMBT_REC_ADDR(mp, block, 1);
 -		for (j = 0; j < num_recs; j++, frp++, i++) {
 -			if (!xfs_bmbt_validate_extent(mp, whichfork, frp)) {
 +		for (j = 0; j < num_recs; j++, i++, frp++) {
 +			xfs_bmbt_rec_host_t *trp = xfs_iext_get_ext(ifp, i);
 +			trp->l0 = be64_to_cpu(frp->l0);
 +			trp->l1 = be64_to_cpu(frp->l1);
 +			if (!xfs_bmbt_validate_extent(mp, whichfork, trp)) {
  				XFS_ERROR_REPORT("xfs_bmap_read_extents(2)",
  						 XFS_ERRLEVEL_LOW, mp);
 -				error = -EFSCORRUPTED;
 -				goto out_brelse;
 +				goto error0;
  			}
++<<<<<<< HEAD
++=======
+ 			xfs_bmbt_disk_get_all(frp, &new);
+ 			xfs_iext_insert(ip, &icur, &new, state);
+ 			trace_xfs_read_extent(ip, &icur, state, _THIS_IP_);
+ 			xfs_iext_next(ifp, &icur);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  		}
  		xfs_trans_brelse(tp, bp);
  		bno = nextbno;
@@@ -1857,9 -1817,15 +1869,19 @@@ xfs_bmap_add_extent_delay_real
  		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),
  			startblockval(PREV.br_startblock) -
  			(bma->cur ? bma->cur->bc_private.b.allocated : 0));
++<<<<<<< HEAD
 +		ep = xfs_iext_get_ext(ifp, bma->idx + 1);
 +		xfs_bmbt_set_startblock(ep, nullstartblock(da_new));
 +		trace_xfs_bmap_post_update(bma->ip, bma->idx + 1, state, _THIS_IP_);
++=======
+ 
+ 		PREV.br_startoff = new_endoff;
+ 		PREV.br_blockcount = temp;
+ 		PREV.br_startblock = nullstartblock(da_new);
+ 		xfs_iext_next(ifp, &bma->icur);
+ 		xfs_iext_insert(bma->ip, &bma->icur, &PREV, state);
+ 		xfs_iext_prev(ifp, &bma->icur);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  		break;
  
  	case BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:
@@@ -1941,11 -1895,13 +1963,18 @@@
  		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),
  			startblockval(PREV.br_startblock) -
  			(bma->cur ? bma->cur->bc_private.b.allocated : 0));
 +		ep = xfs_iext_get_ext(ifp, bma->idx);
 +		xfs_bmbt_set_startblock(ep, nullstartblock(da_new));
 +		trace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);
  
++<<<<<<< HEAD
 +		bma->idx++;
++=======
+ 		PREV.br_startblock = nullstartblock(da_new);
+ 		PREV.br_blockcount = temp;
+ 		xfs_iext_insert(bma->ip, &bma->icur, &PREV, state);
+ 		xfs_iext_next(ifp, &bma->icur);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  		break;
  
  	case 0:
@@@ -1969,19 -1925,32 +1998,40 @@@
  		 *  PREV @ idx          LEFT              RIGHT
  		 *                      inserted at idx + 1
  		 */
 -		old = PREV;
 -
 -		/* LEFT is the new middle */
 +		temp = new->br_startoff - PREV.br_startoff;
 +		temp2 = PREV.br_startoff + PREV.br_blockcount - new_endoff;
 +		trace_xfs_bmap_pre_update(bma->ip, bma->idx, 0, _THIS_IP_);
 +		xfs_bmbt_set_blockcount(ep, temp);	/* truncate PREV */
  		LEFT = *new;
 -
 -		/* RIGHT is the new right */
  		RIGHT.br_state = PREV.br_state;
 +		RIGHT.br_startblock = nullstartblock(
 +				(int)xfs_bmap_worst_indlen(bma->ip, temp2));
  		RIGHT.br_startoff = new_endoff;
++<<<<<<< HEAD
 +		RIGHT.br_blockcount = temp2;
 +		/* insert LEFT (r[0]) and RIGHT (r[1]) at the same time */
 +		xfs_iext_insert(bma->ip, bma->idx + 1, 2, &LEFT, state);
 +		bma->ip->i_d.di_nextents++;
++=======
+ 		RIGHT.br_blockcount =
+ 			PREV.br_startoff + PREV.br_blockcount - new_endoff;
+ 		RIGHT.br_startblock =
+ 			nullstartblock(xfs_bmap_worst_indlen(bma->ip,
+ 					RIGHT.br_blockcount));
+ 
+ 		/* truncate PREV */
+ 		PREV.br_blockcount = new->br_startoff - PREV.br_startoff;
+ 		PREV.br_startblock =
+ 			nullstartblock(xfs_bmap_worst_indlen(bma->ip,
+ 					PREV.br_blockcount));
+ 		xfs_iext_update_extent(bma->ip, state, &bma->icur, &PREV);
+ 
+ 		xfs_iext_next(ifp, &bma->icur);
+ 		xfs_iext_insert(bma->ip, &bma->icur, &RIGHT, state);
+ 		xfs_iext_insert(bma->ip, &bma->icur, &LEFT, state);
+ 		(*nextents)++;
+ 
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  		if (bma->cur == NULL)
  			rval = XFS_ILOG_CORE | XFS_ILOG_DEXT;
  		else {
@@@ -2396,10 -2310,9 +2446,15 @@@ xfs_bmap_add_extent_unwritten_real
  		PREV.br_startoff += new->br_blockcount;
  		PREV.br_startblock += new->br_blockcount;
  		PREV.br_blockcount -= new->br_blockcount;
 +		xfs_iext_update_extent(ifp, *idx, &PREV);
 +		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
  
++<<<<<<< HEAD
 +		xfs_iext_insert(ip, *idx, 1, new, state);
++=======
+ 		xfs_iext_update_extent(ip, state, icur, &PREV);
+ 		xfs_iext_insert(ip, icur, new, state);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  		XFS_IFORK_NEXT_SET(ip, whichfork,
  				XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
  		if (cur == NULL)
@@@ -2476,13 -2375,11 +2531,19 @@@
  		 * The right neighbor is not contiguous.
  		 */
  		old = PREV;
 +		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
  		PREV.br_blockcount -= new->br_blockcount;
 +		xfs_iext_update_extent(ifp, *idx, &PREV);
 +		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
  
++<<<<<<< HEAD
 +		++*idx;
 +		xfs_iext_insert(ip, *idx, 1, new, state);
++=======
+ 		xfs_iext_update_extent(ip, state, icur, &PREV);
+ 		xfs_iext_next(ifp, icur);
+ 		xfs_iext_insert(ip, icur, new, state);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  
  		XFS_IFORK_NEXT_SET(ip, whichfork,
  				XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
@@@ -2532,8 -2420,10 +2593,15 @@@
  		r[1].br_startblock = new->br_startblock + new->br_blockcount;
  		r[1].br_state = PREV.br_state;
  
++<<<<<<< HEAD
 +		++*idx;
 +		xfs_iext_insert(ip, *idx, 2, &r[0], state);
++=======
+ 		xfs_iext_update_extent(ip, state, icur, &PREV);
+ 		xfs_iext_next(ifp, icur);
+ 		xfs_iext_insert(ip, icur, &r[1], state);
+ 		xfs_iext_insert(ip, icur, &r[0], state);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  
  		XFS_IFORK_NEXT_SET(ip, whichfork,
  				XFS_IFORK_NEXTENTS(ip, whichfork) + 2);
@@@ -2750,7 -2631,7 +2818,11 @@@ xfs_bmap_add_extent_hole_delay
  		 * Insert a new entry.
  		 */
  		oldlen = newlen = 0;
++<<<<<<< HEAD
 +		xfs_iext_insert(ip, *idx, 1, new, state);
++=======
+ 		xfs_iext_insert(ip, icur, new, state);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  		break;
  	}
  	if (oldlen != newlen) {
@@@ -2958,7 -2815,7 +3030,11 @@@ xfs_bmap_add_extent_hole_real
  		 * real allocation.
  		 * Insert a new entry.
  		 */
++<<<<<<< HEAD
 +		xfs_iext_insert(ip, *idx, 1, new, state);
++=======
+ 		xfs_iext_insert(ip, icur, new, state);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  		XFS_IFORK_NEXT_SET(ip, whichfork,
  			XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
  		if (cur == NULL) {
@@@ -4641,15 -4627,212 +4717,215 @@@ xfs_bmap_split_indlen
  	return stolen;
  }
  
++<<<<<<< HEAD
++=======
+ int
+ xfs_bmap_del_extent_delay(
+ 	struct xfs_inode	*ip,
+ 	int			whichfork,
+ 	struct xfs_iext_cursor	*icur,
+ 	struct xfs_bmbt_irec	*got,
+ 	struct xfs_bmbt_irec	*del)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
+ 	struct xfs_bmbt_irec	new;
+ 	int64_t			da_old, da_new, da_diff = 0;
+ 	xfs_fileoff_t		del_endoff, got_endoff;
+ 	xfs_filblks_t		got_indlen, new_indlen, stolen;
+ 	int			state = xfs_bmap_fork_to_state(whichfork);
+ 	int			error = 0;
+ 	bool			isrt;
+ 
+ 	XFS_STATS_INC(mp, xs_del_exlist);
+ 
+ 	isrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);
+ 	del_endoff = del->br_startoff + del->br_blockcount;
+ 	got_endoff = got->br_startoff + got->br_blockcount;
+ 	da_old = startblockval(got->br_startblock);
+ 	da_new = 0;
+ 
+ 	ASSERT(del->br_blockcount > 0);
+ 	ASSERT(got->br_startoff <= del->br_startoff);
+ 	ASSERT(got_endoff >= del_endoff);
+ 
+ 	if (isrt) {
+ 		uint64_t rtexts = XFS_FSB_TO_B(mp, del->br_blockcount);
+ 
+ 		do_div(rtexts, mp->m_sb.sb_rextsize);
+ 		xfs_mod_frextents(mp, rtexts);
+ 	}
+ 
+ 	/*
+ 	 * Update the inode delalloc counter now and wait to update the
+ 	 * sb counters as we might have to borrow some blocks for the
+ 	 * indirect block accounting.
+ 	 */
+ 	error = xfs_trans_reserve_quota_nblks(NULL, ip,
+ 			-((long)del->br_blockcount), 0,
+ 			isrt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);
+ 	if (error)
+ 		return error;
+ 	ip->i_delayed_blks -= del->br_blockcount;
+ 
+ 	if (got->br_startoff == del->br_startoff)
+ 		state |= BMAP_LEFT_FILLING;
+ 	if (got_endoff == del_endoff)
+ 		state |= BMAP_RIGHT_FILLING;
+ 
+ 	switch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {
+ 	case BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Matches the whole extent.  Delete the entry.
+ 		 */
+ 		xfs_iext_remove(ip, icur, 1, state);
+ 		xfs_iext_prev(ifp, icur);
+ 		break;
+ 	case BMAP_LEFT_FILLING:
+ 		/*
+ 		 * Deleting the first part of the extent.
+ 		 */
+ 		got->br_startoff = del_endoff;
+ 		got->br_blockcount -= del->br_blockcount;
+ 		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
+ 				got->br_blockcount), da_old);
+ 		got->br_startblock = nullstartblock((int)da_new);
+ 		xfs_iext_update_extent(ip, state, icur, got);
+ 		break;
+ 	case BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Deleting the last part of the extent.
+ 		 */
+ 		got->br_blockcount = got->br_blockcount - del->br_blockcount;
+ 		da_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip,
+ 				got->br_blockcount), da_old);
+ 		got->br_startblock = nullstartblock((int)da_new);
+ 		xfs_iext_update_extent(ip, state, icur, got);
+ 		break;
+ 	case 0:
+ 		/*
+ 		 * Deleting the middle of the extent.
+ 		 *
+ 		 * Distribute the original indlen reservation across the two new
+ 		 * extents.  Steal blocks from the deleted extent if necessary.
+ 		 * Stealing blocks simply fudges the fdblocks accounting below.
+ 		 * Warn if either of the new indlen reservations is zero as this
+ 		 * can lead to delalloc problems.
+ 		 */
+ 		got->br_blockcount = del->br_startoff - got->br_startoff;
+ 		got_indlen = xfs_bmap_worst_indlen(ip, got->br_blockcount);
+ 
+ 		new.br_blockcount = got_endoff - del_endoff;
+ 		new_indlen = xfs_bmap_worst_indlen(ip, new.br_blockcount);
+ 
+ 		WARN_ON_ONCE(!got_indlen || !new_indlen);
+ 		stolen = xfs_bmap_split_indlen(da_old, &got_indlen, &new_indlen,
+ 						       del->br_blockcount);
+ 
+ 		got->br_startblock = nullstartblock((int)got_indlen);
+ 
+ 		new.br_startoff = del_endoff;
+ 		new.br_state = got->br_state;
+ 		new.br_startblock = nullstartblock((int)new_indlen);
+ 
+ 		xfs_iext_update_extent(ip, state, icur, got);
+ 		xfs_iext_next(ifp, icur);
+ 		xfs_iext_insert(ip, icur, &new, state);
+ 
+ 		da_new = got_indlen + new_indlen - stolen;
+ 		del->br_blockcount -= stolen;
+ 		break;
+ 	}
+ 
+ 	ASSERT(da_old >= da_new);
+ 	da_diff = da_old - da_new;
+ 	if (!isrt)
+ 		da_diff += del->br_blockcount;
+ 	if (da_diff)
+ 		xfs_mod_fdblocks(mp, da_diff, false);
+ 	return error;
+ }
+ 
+ void
+ xfs_bmap_del_extent_cow(
+ 	struct xfs_inode	*ip,
+ 	struct xfs_iext_cursor	*icur,
+ 	struct xfs_bmbt_irec	*got,
+ 	struct xfs_bmbt_irec	*del)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, XFS_COW_FORK);
+ 	struct xfs_bmbt_irec	new;
+ 	xfs_fileoff_t		del_endoff, got_endoff;
+ 	int			state = BMAP_COWFORK;
+ 
+ 	XFS_STATS_INC(mp, xs_del_exlist);
+ 
+ 	del_endoff = del->br_startoff + del->br_blockcount;
+ 	got_endoff = got->br_startoff + got->br_blockcount;
+ 
+ 	ASSERT(del->br_blockcount > 0);
+ 	ASSERT(got->br_startoff <= del->br_startoff);
+ 	ASSERT(got_endoff >= del_endoff);
+ 	ASSERT(!isnullstartblock(got->br_startblock));
+ 
+ 	if (got->br_startoff == del->br_startoff)
+ 		state |= BMAP_LEFT_FILLING;
+ 	if (got_endoff == del_endoff)
+ 		state |= BMAP_RIGHT_FILLING;
+ 
+ 	switch (state & (BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING)) {
+ 	case BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Matches the whole extent.  Delete the entry.
+ 		 */
+ 		xfs_iext_remove(ip, icur, 1, state);
+ 		xfs_iext_prev(ifp, icur);
+ 		break;
+ 	case BMAP_LEFT_FILLING:
+ 		/*
+ 		 * Deleting the first part of the extent.
+ 		 */
+ 		got->br_startoff = del_endoff;
+ 		got->br_blockcount -= del->br_blockcount;
+ 		got->br_startblock = del->br_startblock + del->br_blockcount;
+ 		xfs_iext_update_extent(ip, state, icur, got);
+ 		break;
+ 	case BMAP_RIGHT_FILLING:
+ 		/*
+ 		 * Deleting the last part of the extent.
+ 		 */
+ 		got->br_blockcount -= del->br_blockcount;
+ 		xfs_iext_update_extent(ip, state, icur, got);
+ 		break;
+ 	case 0:
+ 		/*
+ 		 * Deleting the middle of the extent.
+ 		 */
+ 		got->br_blockcount = del->br_startoff - got->br_startoff;
+ 
+ 		new.br_startoff = del_endoff;
+ 		new.br_blockcount = got_endoff - del_endoff;
+ 		new.br_state = got->br_state;
+ 		new.br_startblock = del->br_startblock + del->br_blockcount;
+ 
+ 		xfs_iext_update_extent(ip, state, icur, got);
+ 		xfs_iext_next(ifp, icur);
+ 		xfs_iext_insert(ip, icur, &new, state);
+ 		break;
+ 	}
+ }
+ 
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  /*
   * Called by xfs_bmapi to update file extent records and the btree
 - * after removing space.
 + * after removing space (or undoing a delayed allocation).
   */
  STATIC int				/* error */
 -xfs_bmap_del_extent_real(
 +xfs_bmap_del_extent(
  	xfs_inode_t		*ip,	/* incore inode pointer */
  	xfs_trans_t		*tp,	/* current transaction pointer */
 -	struct xfs_iext_cursor	*icur,
 +	xfs_extnum_t		*idx,	/* extent number to update/delete */
  	struct xfs_defer_ops	*dfops,	/* list of extents to be freed */
  	xfs_btree_cur_t		*cur,	/* if null, not a btree */
  	xfs_bmbt_irec_t		*del,	/* data to remove from extents */
@@@ -4838,101 -4974,73 +5114,127 @@@
  		/*
  		 * Deleting the middle of the extent.
  		 */
 -		old = got;
 -
 -		got.br_blockcount = del->br_startoff - got.br_startoff;
 -		xfs_iext_update_extent(ip, state, icur, &got);
 -
 +		temp = del->br_startoff - got.br_startoff;
 +		trace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);
 +		xfs_bmbt_set_blockcount(ep, temp);
  		new.br_startoff = del_endoff;
 -		new.br_blockcount = got_endoff - del_endoff;
 +		temp2 = got_endoff - del_endoff;
 +		new.br_blockcount = temp2;
  		new.br_state = got.br_state;
 -		new.br_startblock = del_endblock;
 -
 -		flags |= XFS_ILOG_CORE;
 -		if (cur) {
 -			error = xfs_bmbt_update(cur, &got);
 -			if (error)
 -				goto done;
 -			error = xfs_btree_increment(cur, 0, &i);
 -			if (error)
 -				goto done;
 -			cur->bc_rec.b = new;
 -			error = xfs_btree_insert(cur, &i);
 -			if (error && error != -ENOSPC)
 -				goto done;
 -			/*
 -			 * If get no-space back from btree insert, it tried a
 -			 * split, and we have a zero block reservation.  Fix up
 -			 * our state and return the error.
 -			 */
 -			if (error == -ENOSPC) {
 +		if (!delay) {
 +			new.br_startblock = del_endblock;
 +			flags |= XFS_ILOG_CORE;
 +			if (cur) {
 +				if ((error = xfs_bmbt_update(cur,
 +						got.br_startoff,
 +						got.br_startblock, temp,
 +						got.br_state)))
 +					goto done;
 +				if ((error = xfs_btree_increment(cur, 0, &i)))
 +					goto done;
 +				cur->bc_rec.b = new;
 +				error = xfs_btree_insert(cur, &i);
 +				if (error && error != -ENOSPC)
 +					goto done;
  				/*
 -				 * Reset the cursor, don't trust it after any
 -				 * insert operation.
 +				 * If get no-space back from btree insert,
 +				 * it tried a split, and we have a zero
 +				 * block reservation.
 +				 * Fix up our state and return the error.
  				 */
 -				error = xfs_bmbt_lookup_eq(cur, &got, &i);
 -				if (error)
 +				if (error == -ENOSPC) {
 +					/*
 +					 * Reset the cursor, don't trust
 +					 * it after any insert operation.
 +					 */
 +					if ((error = xfs_bmbt_lookup_eq(cur,
 +							got.br_startoff,
 +							got.br_startblock,
 +							temp, &i)))
 +						goto done;
 +					XFS_WANT_CORRUPTED_GOTO(mp,
 +								i == 1, done);
 +					/*
 +					 * Update the btree record back
 +					 * to the original value.
 +					 */
 +					if ((error = xfs_bmbt_update(cur,
 +							got.br_startoff,
 +							got.br_startblock,
 +							got.br_blockcount,
 +							got.br_state)))
 +						goto done;
 +					/*
 +					 * Reset the extent record back
 +					 * to the original value.
 +					 */
 +					xfs_bmbt_set_blockcount(ep,
 +						got.br_blockcount);
 +					flags = 0;
 +					error = -ENOSPC;
  					goto done;
 +				}
  				XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
++<<<<<<< HEAD
 +			} else
 +				flags |= xfs_ilog_fext(whichfork);
 +			XFS_IFORK_NEXT_SET(ip, whichfork,
 +				XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
 +		} else {
 +			xfs_filblks_t	stolen;
 +			ASSERT(whichfork == XFS_DATA_FORK);
 +
 +			/*
 +			 * Distribute the original indlen reservation across the
 +			 * two new extents. Steal blocks from the deleted extent
 +			 * if necessary. Stealing blocks simply fudges the
 +			 * fdblocks accounting in xfs_bunmapi().
 +			 */
 +			temp = xfs_bmap_worst_indlen(ip, got.br_blockcount);
 +			temp2 = xfs_bmap_worst_indlen(ip, new.br_blockcount);
 +			stolen = xfs_bmap_split_indlen(da_old, &temp, &temp2,
 +						       del->br_blockcount);
 +			da_new = temp + temp2 - stolen;
 +			del->br_blockcount -= stolen;
 +
 +			/*
 +			 * Set the reservation for each extent. Warn if either
 +			 * is zero as this can lead to delalloc problems.
 +			 */
 +			WARN_ON_ONCE(!temp || !temp2);
 +			xfs_bmbt_set_startblock(ep, nullstartblock((int)temp));
 +			new.br_startblock = nullstartblock((int)temp2);
 +		}
 +		trace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);
 +		xfs_iext_insert(ip, *idx + 1, 1, &new, state);
 +		++*idx;
++=======
+ 				/*
+ 				 * Update the btree record back
+ 				 * to the original value.
+ 				 */
+ 				error = xfs_bmbt_update(cur, &old);
+ 				if (error)
+ 					goto done;
+ 				/*
+ 				 * Reset the extent record back
+ 				 * to the original value.
+ 				 */
+ 				xfs_iext_update_extent(ip, state, icur, &old);
+ 				flags = 0;
+ 				error = -ENOSPC;
+ 				goto done;
+ 			}
+ 			XFS_WANT_CORRUPTED_GOTO(mp, i == 1, done);
+ 		} else
+ 			flags |= xfs_ilog_fext(whichfork);
+ 		XFS_IFORK_NEXT_SET(ip, whichfork,
+ 			XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
+ 		xfs_iext_next(ifp, icur);
+ 		xfs_iext_insert(ip, icur, &new, state);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  		break;
  	}
 -
 -	/* remove reverse mapping */
 -	error = xfs_rmap_unmap_extent(mp, dfops, ip, whichfork, del);
 -	if (error)
 -		goto done;
 -
  	/*
  	 * If we need to, add to list of extents to delete.
  	 */
@@@ -5611,11 -5856,57 +5913,47 @@@ xfs_bmap_shift_extents
  			return error;
  	}
  
 -	/*
 -	 * If there are not extents, or split_fsb lies in a hole we are done.
 -	 */
 -	if (!xfs_iext_lookup_extent(ip, ifp, split_fsb, &icur, &got) ||
 -	    got.br_startoff >= split_fsb)
 -		return 0;
 -
 -	gotblkcnt = split_fsb - got.br_startoff;
 -	new.br_startoff = split_fsb;
 -	new.br_startblock = got.br_startblock + gotblkcnt;
 -	new.br_blockcount = got.br_blockcount - gotblkcnt;
 -	new.br_state = got.br_state;
 -
  	if (ifp->if_flags & XFS_IFBROOT) {
  		cur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);
 -		cur->bc_private.b.firstblock = *firstfsb;
 +		cur->bc_private.b.firstblock = *firstblock;
  		cur->bc_private.b.dfops = dfops;
  		cur->bc_private.b.flags = 0;
++<<<<<<< HEAD
++=======
+ 		error = xfs_bmbt_lookup_eq(cur, &got, &i);
+ 		if (error)
+ 			goto del_cursor;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 1, del_cursor);
+ 	}
+ 
+ 	got.br_blockcount = gotblkcnt;
+ 	xfs_iext_update_extent(ip, xfs_bmap_fork_to_state(whichfork), &icur,
+ 			&got);
+ 
+ 	logflags = XFS_ILOG_CORE;
+ 	if (cur) {
+ 		error = xfs_bmbt_update(cur, &got);
+ 		if (error)
+ 			goto del_cursor;
+ 	} else
+ 		logflags |= XFS_ILOG_DEXT;
+ 
+ 	/* Add new extent */
+ 	xfs_iext_next(ifp, &icur);
+ 	xfs_iext_insert(ip, &icur, &new, 0);
+ 	XFS_IFORK_NEXT_SET(ip, whichfork,
+ 			   XFS_IFORK_NEXTENTS(ip, whichfork) + 1);
+ 
+ 	if (cur) {
+ 		error = xfs_bmbt_lookup_eq(cur, &new, &i);
+ 		if (error)
+ 			goto del_cursor;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 0, del_cursor);
+ 		error = xfs_btree_insert(cur, &i);
+ 		if (error)
+ 			goto del_cursor;
+ 		XFS_WANT_CORRUPTED_GOTO(mp, i == 1, del_cursor);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  	}
  
  	/*
diff --cc fs/xfs/libxfs/xfs_inode_fork.c
index f83028029221,af31d5826c32..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@@ -264,8 -360,12 +264,16 @@@ xfs_iformat_extents
  						 XFS_ERRLEVEL_LOW, mp);
  				return -EFSCORRUPTED;
  			}
++<<<<<<< HEAD
++=======
+ 
+ 			xfs_bmbt_disk_get_all(dp, &new);
+ 			xfs_iext_insert(ip, &icur, &new, state);
+ 			trace_xfs_read_extent(ip, &icur, state, _THIS_IP_);
+ 			xfs_iext_next(ifp, &icur);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  		}
 +		XFS_BMAP_TRACE_EXLIST(ip, nex, whichfork);
  	}
  	ifp->if_flags |= XFS_IFEXTENTS;
  	return 0;
diff --cc fs/xfs/libxfs/xfs_inode_fork.h
index a53b7ced7b58,84b5e6f8bf2c..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.h
+++ b/fs/xfs/libxfs/xfs_inode_fork.h
@@@ -135,37 -112,12 +135,45 @@@ int		xfs_iextents_copy(struct xfs_inod
  				  int);
  void		xfs_init_local_fork(struct xfs_inode *, int, const void *, int);
  
++<<<<<<< HEAD
 +struct xfs_bmbt_rec_host *
 +		xfs_iext_get_ext(struct xfs_ifork *, xfs_extnum_t);
 +xfs_extnum_t	xfs_iext_count(struct xfs_ifork *);
 +void		xfs_iext_insert(struct xfs_inode *, xfs_extnum_t, xfs_extnum_t,
 +				struct xfs_bmbt_irec *, int);
 +void		xfs_iext_add(struct xfs_ifork *, xfs_extnum_t, int);
 +void		xfs_iext_add_indirect_multi(struct xfs_ifork *, int,
 +					    xfs_extnum_t, int);
 +void		xfs_iext_remove(struct xfs_inode *, xfs_extnum_t, int, int);
 +void		xfs_iext_remove_inline(struct xfs_ifork *, xfs_extnum_t, int);
 +void		xfs_iext_remove_direct(struct xfs_ifork *, xfs_extnum_t, int);
 +void		xfs_iext_remove_indirect(struct xfs_ifork *, xfs_extnum_t, int);
 +void		xfs_iext_realloc_direct(struct xfs_ifork *, int);
 +void		xfs_iext_direct_to_inline(struct xfs_ifork *, xfs_extnum_t);
 +void		xfs_iext_inline_to_direct(struct xfs_ifork *, int);
++=======
+ xfs_extnum_t	xfs_iext_count(struct xfs_ifork *ifp);
+ void		xfs_iext_insert(struct xfs_inode *, struct xfs_iext_cursor *cur,
+ 			struct xfs_bmbt_irec *, int);
+ void		xfs_iext_remove(struct xfs_inode *, struct xfs_iext_cursor *,
+ 			int, int);
++>>>>>>> 0254c2f253d6 (xfs: remove the nr_extents argument to xfs_iext_insert)
  void		xfs_iext_destroy(struct xfs_ifork *);
 +struct xfs_bmbt_rec_host *
 +		xfs_iext_bno_to_ext(struct xfs_ifork *, xfs_fileoff_t, int *);
 +struct xfs_ext_irec *
 +		xfs_iext_bno_to_irec(struct xfs_ifork *, xfs_fileoff_t, int *);
 +struct xfs_ext_irec *
 +		xfs_iext_idx_to_irec(struct xfs_ifork *, xfs_extnum_t *, int *,
 +				     int);
 +void		xfs_iext_irec_init(struct xfs_ifork *);
 +struct xfs_ext_irec *
 +		xfs_iext_irec_new(struct xfs_ifork *, int);
 +void		xfs_iext_irec_remove(struct xfs_ifork *, int);
 +void		xfs_iext_irec_compact(struct xfs_ifork *);
 +void		xfs_iext_irec_compact_pages(struct xfs_ifork *);
 +void		xfs_iext_irec_compact_full(struct xfs_ifork *);
 +void		xfs_iext_irec_update_extoffs(struct xfs_ifork *, int, int);
  
  bool		xfs_iext_lookup_extent(struct xfs_inode *ip,
  			struct xfs_ifork *ifp, xfs_fileoff_t bno,
* Unmerged path fs/xfs/libxfs/xfs_iext_tree.c
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_iext_tree.c
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.c
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.h
