nfsd: remove redundant assignment to pointer 'this'

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [infiniband] remove redundant assignment to pointer 'rdi' (Kamal Heib) [1641363]
Rebuild_FUZZ: 88.42%
commit-author Colin Ian King <colin.king@canonical.com>
commit e34c0ce9136a0fe96f0f547898d14c44f3c9f147
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e34c0ce9.failed

The pointer 'this' is being initialized with a value that is never read
and it is being updated later with a new value. The initialization is
redundant and can be removed.

Addresses-Coverity: ("Unused value")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit e34c0ce9136a0fe96f0f547898d14c44f3c9f147)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4proc.c
diff --cc fs/nfsd/nfs4proc.c
index 4a0ef5cfe8c6,486c5dba4b65..000000000000
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@@ -2391,16 -3320,92 +2391,58 @@@ static struct nfsd4_operation nfsd4_ops
  	},
  };
  
++<<<<<<< HEAD
++=======
+ /**
+  * nfsd4_spo_must_allow - Determine if the compound op contains an
+  * operation that is allowed to be sent with machine credentials
+  *
+  * @rqstp: a pointer to the struct svc_rqst
+  *
+  * Checks to see if the compound contains a spo_must_allow op
+  * and confirms that it was sent with the proper machine creds.
+  */
+ 
+ bool nfsd4_spo_must_allow(struct svc_rqst *rqstp)
+ {
+ 	struct nfsd4_compoundres *resp = rqstp->rq_resp;
+ 	struct nfsd4_compoundargs *argp = rqstp->rq_argp;
+ 	struct nfsd4_op *this;
+ 	struct nfsd4_compound_state *cstate = &resp->cstate;
+ 	struct nfs4_op_map *allow = &cstate->clp->cl_spo_must_allow;
+ 	u32 opiter;
+ 
+ 	if (!cstate->minorversion)
+ 		return false;
+ 
+ 	if (cstate->spo_must_allowed)
+ 		return true;
+ 
+ 	opiter = resp->opcnt;
+ 	while (opiter < argp->opcnt) {
+ 		this = &argp->ops[opiter++];
+ 		if (test_bit(this->opnum, allow->u.longs) &&
+ 			cstate->clp->cl_mach_cred &&
+ 			nfsd4_mach_creds_match(cstate->clp, rqstp)) {
+ 			cstate->spo_must_allowed = true;
+ 			return true;
+ 		}
+ 	}
+ 	cstate->spo_must_allowed = false;
+ 	return false;
+ }
+ 
++>>>>>>> e34c0ce9136a (nfsd: remove redundant assignment to pointer 'this')
  int nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)
  {
 -	if (op->opnum == OP_ILLEGAL || op->status == nfserr_notsupp)
 -		return op_encode_hdr_size * sizeof(__be32);
 +	struct nfsd4_operation *opdesc;
 +	nfsd4op_rsize estimator;
  
 -	BUG_ON(OPDESC(op)->op_rsize_bop == NULL);
 -	return OPDESC(op)->op_rsize_bop(rqstp, op);
 +	if (op->opnum == OP_ILLEGAL)
 +		return op_encode_hdr_size * sizeof(__be32);
 +	opdesc = OPDESC(op);
 +	estimator = opdesc->op_rsize_bop;
 +	return estimator ? estimator(rqstp, op) : PAGE_SIZE;
  }
  
  void warn_on_nonidempotent_op(struct nfsd4_op *op)
* Unmerged path fs/nfsd/nfs4proc.c
