net: phy: Check phydev->drv

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] phy: Check phydev->drv (Ivan Vecera) [1655590]
Rebuild_FUZZ: 89.80%
commit-author Florian Fainelli <f.fainelli@gmail.com>
commit 25149ef9d25cafc4f4fe9f4461f18f876f397417
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/25149ef9.failed

There are number of function calls, originating from user-space,
typically through the Ethernet driver that can make us crash by
dereferencing phydev->drv which will be NULL once we unbind the driver
from the PHY.

There are still functional issues that prevent an unbind then rebind to
work, but these will be addressed separately.

	Suggested-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 25149ef9d25cafc4f4fe9f4461f18f876f397417)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phy.c
#	drivers/net/phy/phy_device.c
diff --cc drivers/net/phy/phy.c
index ad140f0e18e9,d6f7838455dd..000000000000
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@@ -795,6 -976,11 +798,14 @@@ void phy_state_machine(struct work_stru
  
  	mutex_lock(&phydev->lock);
  
++<<<<<<< HEAD
++=======
+ 	old_state = phydev->state;
+ 
+ 	if (phydev->drv && phydev->drv->link_change_notify)
+ 		phydev->drv->link_change_notify(phydev);
+ 
++>>>>>>> 25149ef9d25c (net: phy: Check phydev->drv)
  	switch (phydev->state) {
  	case PHY_DOWN:
  	case PHY_STARTING:
@@@ -1066,10 -1289,13 +1077,13 @@@ static void phy_write_mmd_indirect(stru
   */
  int phy_init_eee(struct phy_device *phydev, bool clk_stop_enable)
  {
+ 	if (!phydev->drv)
+ 		return -EIO;
+ 
  	/* According to 802.3az,the EEE is supported only in full duplex-mode.
  	 * Also EEE feature is active when core is operating with MII, GMII
 -	 * or RGMII (all kinds). Internal PHYs are also allowed to proceed and
 -	 * should return an error if they do not support EEE.
 +	 * or RGMII. Internal PHYs are also allowed to proceed and should
 +	 * return an error if they do not support EEE.
  	 */
  	if ((phydev->duplex == DUPLEX_FULL) &&
  	    ((phydev->interface == PHY_INTERFACE_MODE_MII) ||
@@@ -1145,8 -1369,10 +1159,15 @@@ EXPORT_SYMBOL(phy_init_eee)
   */
  int phy_get_eee_err(struct phy_device *phydev)
  {
++<<<<<<< HEAD
 +	return phy_read_mmd_indirect(phydev->bus, MDIO_PCS_EEE_WK_ERR,
 +				     MDIO_MMD_PCS, phydev->addr);
++=======
+ 	if (!phydev->drv)
+ 		return -EIO;
+ 
+ 	return phy_read_mmd_indirect(phydev, MDIO_PCS_EEE_WK_ERR, MDIO_MMD_PCS);
++>>>>>>> 25149ef9d25c (net: phy: Check phydev->drv)
  }
  EXPORT_SYMBOL(phy_get_eee_err);
  
@@@ -1162,9 -1388,11 +1183,12 @@@ int phy_ethtool_get_eee(struct phy_devi
  {
  	int val;
  
+ 	if (!phydev->drv)
+ 		return -EIO;
+ 
  	/* Get Supported EEE */
 -	val = phy_read_mmd_indirect(phydev, MDIO_PCS_EEE_ABLE, MDIO_MMD_PCS);
 +	val = phy_read_mmd_indirect(phydev->bus, MDIO_PCS_EEE_ABLE,
 +				    MDIO_MMD_PCS, phydev->addr);
  	if (val < 0)
  		return val;
  	data->supported = mmd_eee_cap_to_ethtool_sup_t(val);
@@@ -1198,8 -1424,13 +1222,18 @@@ int phy_ethtool_set_eee(struct phy_devi
  {
  	int val = ethtool_adv_to_mmd_eee_adv_t(data->advertised);
  
++<<<<<<< HEAD
 +	phy_write_mmd_indirect(phydev->bus, MDIO_AN_EEE_ADV, MDIO_MMD_AN,
 +			       phydev->addr, val);
++=======
+ 	if (!phydev->drv)
+ 		return -EIO;
+ 
+ 	/* Mask prohibited EEE modes */
+ 	val &= ~phydev->eee_broken_modes;
+ 
+ 	phy_write_mmd_indirect(phydev, MDIO_AN_EEE_ADV, MDIO_MMD_AN, val);
++>>>>>>> 25149ef9d25c (net: phy: Check phydev->drv)
  
  	return 0;
  }
diff --cc drivers/net/phy/phy_device.c
index 2dbcaed2657a,daec6555f3b1..000000000000
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@@ -743,19 -1094,32 +743,43 @@@ int phy_suspend(struct phy_device *phyd
  	if (wol.wolopts)
  		return -EBUSY;
  
++<<<<<<< HEAD
 +	if (phydrv->suspend)
 +		return phydrv->suspend(phydev);
 +	return 0;
++=======
+ 	if (phydev->drv && phydrv->suspend)
+ 		ret = phydrv->suspend(phydev);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	phydev->suspended = true;
+ 
+ 	return ret;
++>>>>>>> 25149ef9d25c (net: phy: Check phydev->drv)
  }
  EXPORT_SYMBOL(phy_suspend);
  
  int phy_resume(struct phy_device *phydev)
  {
 -	struct phy_driver *phydrv = to_phy_driver(phydev->mdio.dev.driver);
 -	int ret = 0;
 +	struct phy_driver *phydrv = to_phy_driver(phydev->dev.driver);
  
++<<<<<<< HEAD
 +	if (phydrv->resume)
 +		return phydrv->resume(phydev);
 +	return 0;
++=======
+ 	if (phydev->drv && phydrv->resume)
+ 		ret = phydrv->resume(phydev);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	phydev->suspended = false;
+ 
+ 	return ret;
++>>>>>>> 25149ef9d25c (net: phy: Check phydev->drv)
  }
  EXPORT_SYMBOL(phy_resume);
  
* Unmerged path drivers/net/phy/phy.c
* Unmerged path drivers/net/phy/phy_device.c
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 9542c61131f8..22c672b1a173 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -666,6 +666,9 @@ int phy_stop_interrupts(struct phy_device *phydev);
 
 static inline int phy_read_status(struct phy_device *phydev)
 {
+	if (!phydev->drv)
+		return -EIO;
+
 	return phydev->drv->read_status(phydev);
 }
 
