selftests/powerpc: Move get_auxv_entry() into utils.c

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Michael Ellerman <mpe@ellerman.id.au>
commit fcb45ec074725baeb3aaa1b1854b9f44c3eebacf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fcb45ec0.failed

This doesn't really belong in harness.c, it's a helper function. So move
it into utils.c.

	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit fcb45ec074725baeb3aaa1b1854b9f44c3eebacf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/powerpc/pmu/Makefile
#	tools/testing/selftests/powerpc/pmu/ebb/Makefile
* Unmerged path tools/testing/selftests/powerpc/pmu/Makefile
* Unmerged path tools/testing/selftests/powerpc/pmu/ebb/Makefile
* Unmerged path tools/testing/selftests/powerpc/pmu/Makefile
* Unmerged path tools/testing/selftests/powerpc/pmu/ebb/Makefile
diff --git a/tools/testing/selftests/powerpc/tm/Makefile b/tools/testing/selftests/powerpc/tm/Makefile
index 75e1119e46b1..fd0d728f4c8c 100644
--- a/tools/testing/selftests/powerpc/tm/Makefile
+++ b/tools/testing/selftests/powerpc/tm/Makefile
@@ -4,7 +4,7 @@ all: $(PROGS)
 
 $(PROGS):
 
-tm-syscall: tm-syscall-asm.S
+tm-syscall: tm-syscall-asm.S ../utils.c
 tm-syscall: CFLAGS += -mhtm -I../../../../../usr/include
 
 run_tests: all
diff --git a/tools/testing/selftests/powerpc/utils.c b/tools/testing/selftests/powerpc/utils.c
new file mode 100644
index 000000000000..536113add380
--- /dev/null
+++ b/tools/testing/selftests/powerpc/utils.c
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2013-2015, Michael Ellerman, IBM Corp.
+ * Licensed under GPLv2.
+ */
+
+#include <elf.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <link.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "utils.h"
+
+static char auxv[4096];
+
+void *get_auxv_entry(int type)
+{
+	ElfW(auxv_t) *p;
+	void *result;
+	ssize_t num;
+	int fd;
+
+	fd = open("/proc/self/auxv", O_RDONLY);
+	if (fd == -1) {
+		perror("open");
+		return NULL;
+	}
+
+	result = NULL;
+
+	num = read(fd, auxv, sizeof(auxv));
+	if (num < 0) {
+		perror("read");
+		goto out;
+	}
+
+	if (num > sizeof(auxv)) {
+		printf("Overflowed auxv buffer\n");
+		goto out;
+	}
+
+	p = (ElfW(auxv_t) *)auxv;
+
+	while (p->a_type != AT_NULL) {
+		if (p->a_type == type) {
+			result = (void *)p->a_un.a_val;
+			break;
+		}
+
+		p++;
+	}
+out:
+	close(fd);
+	return result;
+}
