net/mlx5e: Change return type of tc add flow functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Change return type of tc add flow functions (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 96.15%
commit-author Rabie Loulou <rabiel@mellanox.com>
commit c83954abb221718e961802136078ba04d563cf3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/c83954ab.failed

Refactor the flow add utility functions to return err code instead of rule
pointers. This will allow for simpler logic when one tc rule is
duplicated to two HW rules in downstream patches.

	Signed-off-by: Rabie Loulou <rabiel@mellanox.com>
	Signed-off-by: Shahar Klein <shahark@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit c83954abb221718e961802136078ba04d563cf3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 3a01f0d3c372,861986f82844..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -666,10 -673,11 +666,10 @@@ static void mlx5e_hairpin_flow_del(stru
  	}
  }
  
- static struct mlx5_flow_handle *
+ static int
  mlx5e_tc_add_nic_flow(struct mlx5e_priv *priv,
  		      struct mlx5e_tc_flow_parse_attr *parse_attr,
 -		      struct mlx5e_tc_flow *flow,
 -		      struct netlink_ext_ack *extack)
 +		      struct mlx5e_tc_flow *flow)
  {
  	struct mlx5_nic_flow_attr *attr = flow->nic_attr;
  	struct mlx5_core_dev *dev = priv->mdev;
@@@ -678,17 -686,15 +678,15 @@@
  		.action = attr->action,
  		.has_flow_tag = true,
  		.flow_tag = attr->flow_tag,
 -		.reformat_id = 0,
 +		.encap_id = 0,
  	};
  	struct mlx5_fc *counter = NULL;
- 	struct mlx5_flow_handle *rule;
  	bool table_created = false;
  	int err, dest_ix = 0;
  
  	if (flow->flags & MLX5E_TC_FLOW_HAIRPIN) {
 -		err = mlx5e_hairpin_flow_add(priv, flow, parse_attr, extack);
 +		err = mlx5e_hairpin_flow_add(priv, flow, parse_attr);
  		if (err) {
- 			rule = ERR_PTR(err);
  			goto err_add_hairpin_flow;
  		}
  		if (flow->flags & MLX5E_TC_FLOW_HAIRPIN_RSS) {
@@@ -745,9 -750,11 +741,9 @@@
  							    MLX5E_TC_TABLE_NUM_GROUPS,
  							    MLX5E_TC_FT_LEVEL, 0);
  		if (IS_ERR(priv->fs.tc.t)) {
 -			NL_SET_ERR_MSG_MOD(extack,
 -					   "Failed to create tc offload table\n");
  			netdev_err(priv->netdev,
  				   "Failed to create tc offload table\n");
- 			rule = ERR_CAST(priv->fs.tc.t);
+ 			err = PTR_ERR(priv->fs.tc.t);
  			goto err_create_ft;
  		}
  
@@@ -811,30 -820,32 +809,43 @@@ static int mlx5e_attach_encap(struct ml
  			      struct ip_tunnel_info *tun_info,
  			      struct net_device *mirred_dev,
  			      struct net_device **encap_dev,
 -			      struct mlx5e_tc_flow *flow,
 -			      struct netlink_ext_ack *extack);
 +			      struct mlx5e_tc_flow *flow);
  
- static struct mlx5_flow_handle *
+ static int
  mlx5e_tc_add_fdb_flow(struct mlx5e_priv *priv,
  		      struct mlx5e_tc_flow_parse_attr *parse_attr,
 -		      struct mlx5e_tc_flow *flow,
 -		      struct netlink_ext_ack *extack)
 +		      struct mlx5e_tc_flow *flow)
  {
  	struct mlx5_eswitch *esw = priv->mdev->priv.eswitch;
  	struct mlx5_esw_flow_attr *attr = flow->esw_attr;
  	struct net_device *out_dev, *encap_dev = NULL;
++<<<<<<< HEAD
 +	struct mlx5_flow_handle *rule = NULL;
++=======
+ 	struct mlx5_fc *counter = NULL;
++>>>>>>> c83954abb221 (net/mlx5e: Change return type of tc add flow functions)
  	struct mlx5e_rep_priv *rpriv;
  	struct mlx5e_priv *out_priv;
- 	int err;
+ 	int err = 0, encap_err = 0;
  
 -	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT) {
 +	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_ENCAP) {
  		out_dev = __dev_get_by_index(dev_net(priv->netdev),
  					     attr->parse_attr->mirred_ifindex);
++<<<<<<< HEAD
 +		err = mlx5e_attach_encap(priv, &parse_attr->tun_info,
 +					 out_dev, &encap_dev, flow);
 +		if (err) {
 +			rule = ERR_PTR(err);
 +			if (err != -EAGAIN)
 +				goto err_attach_encap;
++=======
+ 		encap_err = mlx5e_attach_encap(priv, &parse_attr->tun_info,
+ 					       out_dev, &encap_dev, flow,
+ 					       extack);
+ 		if (encap_err && encap_err != -EAGAIN) {
+ 			err = encap_err;
+ 			goto err_attach_encap;
++>>>>>>> c83954abb221 (net/mlx5e: Change return type of tc add flow functions)
  		}
  		out_priv = netdev_priv(encap_dev);
  		rpriv = out_priv->ppriv;
@@@ -851,32 -860,55 +860,63 @@@
  	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR) {
  		err = mlx5e_attach_mod_hdr(priv, flow, parse_attr);
  		kfree(parse_attr->mod_hdr_actions);
- 		if (err) {
- 			rule = ERR_PTR(err);
+ 		if (err)
  			goto err_mod_hdr;
- 		}
  	}
  
++<<<<<<< HEAD
 +	/* we get here if (1) there's no error (rule being null) or when
++=======
+ 	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {
+ 		counter = mlx5_fc_create(esw->dev, true);
+ 		if (IS_ERR(counter)) {
+ 			err = PTR_ERR(counter);
+ 			goto err_create_counter;
+ 		}
+ 
+ 		attr->counter = counter;
+ 	}
+ 
+ 	/* we get here if (1) there's no error or when
++>>>>>>> c83954abb221 (net/mlx5e: Change return type of tc add flow functions)
  	 * (2) there's an encap action and we're on -EAGAIN (no valid neigh)
  	 */
- 	if (rule != ERR_PTR(-EAGAIN)) {
- 		rule = mlx5_eswitch_add_offloaded_rule(esw, &parse_attr->spec, attr);
- 		if (IS_ERR(rule))
+ 	if (encap_err != -EAGAIN) {
+ 		flow->rule[0] = mlx5_eswitch_add_offloaded_rule(esw, &parse_attr->spec, attr);
+ 		if (IS_ERR(flow->rule[0])) {
+ 			err = PTR_ERR(flow->rule[0]);
  			goto err_add_rule;
++<<<<<<< HEAD
++=======
+ 		}
+ 
+ 		if (attr->mirror_count) {
+ 			flow->rule[1] = mlx5_eswitch_add_fwd_rule(esw, &parse_attr->spec, attr);
+ 			if (IS_ERR(flow->rule[1])) {
+ 				err = PTR_ERR(flow->rule[1]);
+ 				goto err_fwd_rule;
+ 			}
+ 		}
++>>>>>>> c83954abb221 (net/mlx5e: Change return type of tc add flow functions)
  	}
- 	return rule;
  
+ 	return encap_err;
+ 
++<<<<<<< HEAD
++=======
+ err_fwd_rule:
+ 	mlx5_eswitch_del_offloaded_rule(esw, flow->rule[0], attr);
++>>>>>>> c83954abb221 (net/mlx5e: Change return type of tc add flow functions)
  err_add_rule:
 -	mlx5_fc_destroy(esw->dev, counter);
 -err_create_counter:
  	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
  		mlx5e_detach_mod_hdr(priv, flow);
  err_mod_hdr:
  	mlx5_eswitch_del_vlan_action(esw, attr);
  err_add_vlan:
 -	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT)
 +	if (attr->action & MLX5_FLOW_CONTEXT_ACTION_ENCAP)
  		mlx5e_detach_encap(priv, flow);
  err_attach_encap:
- 	return rule;
+ 	return err;
  }
  
  static void mlx5e_tc_del_fdb_flow(struct mlx5e_priv *priv,
@@@ -2758,22 -2952,21 +2798,34 @@@ int mlx5e_configure_flower(struct mlx5e
  		goto err_free;
  
  	if (flow->flags & MLX5E_TC_FLOW_ESWITCH) {
 -		err = parse_tc_fdb_actions(priv, f->exts, parse_attr, flow,
 -					   extack);
 +		err = parse_tc_fdb_actions(priv, f->exts, parse_attr, flow);
  		if (err < 0)
  			goto err_free;
++<<<<<<< HEAD
 +		flow->rule = mlx5e_tc_add_fdb_flow(priv, parse_attr, flow);
++=======
+ 		err = mlx5e_tc_add_fdb_flow(priv, parse_attr, flow, extack);
++>>>>>>> c83954abb221 (net/mlx5e: Change return type of tc add flow functions)
  	} else {
 -		err = parse_tc_nic_actions(priv, f->exts, parse_attr, flow,
 -					   extack);
 +		err = parse_tc_nic_actions(priv, f->exts, parse_attr, flow);
  		if (err < 0)
  			goto err_free;
++<<<<<<< HEAD
 +		flow->rule = mlx5e_tc_add_nic_flow(priv, parse_attr, flow);
 +	}
 +
 +	if (IS_ERR(flow->rule)) {
 +		err = PTR_ERR(flow->rule);
 +		if (err != -EAGAIN)
 +			goto err_free;
 +	}
++=======
+ 		err = mlx5e_tc_add_nic_flow(priv, parse_attr, flow, extack);
+ 	}
+ 
+ 	if (err && err != -EAGAIN)
+ 		goto err_free;
++>>>>>>> c83954abb221 (net/mlx5e: Change return type of tc add flow functions)
  
  	if (err != -EAGAIN)
  		flow->flags |= MLX5E_TC_FLOW_OFFLOADED;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
