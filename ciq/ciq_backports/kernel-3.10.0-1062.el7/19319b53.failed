iomap: inline data should be an iomap type, not a flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 19319b53210c6b89c375cf395c08f156cccd83ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/19319b53.failed

Inline data is fundamentally different from our normal mapped case in that
it doesn't even have a block address.  So instead of having a flag for it
it should be an entirely separate iomap range type.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 19319b53210c6b89c375cf395c08f156cccd83ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/inline.c
#	fs/iomap.c
diff --cc fs/ext4/inline.c
index 701ee09d5bdb,e1f00891ef95..000000000000
--- a/fs/ext4/inline.c
+++ b/fs/ext4/inline.c
@@@ -1844,6 -1811,38 +1844,41 @@@ int ext4_destroy_inline_data(handle_t *
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ int ext4_inline_data_iomap(struct inode *inode, struct iomap *iomap)
+ {
+ 	__u64 addr;
+ 	int error = -EAGAIN;
+ 	struct ext4_iloc iloc;
+ 
+ 	down_read(&EXT4_I(inode)->xattr_sem);
+ 	if (!ext4_has_inline_data(inode))
+ 		goto out;
+ 
+ 	error = ext4_get_inode_loc(inode, &iloc);
+ 	if (error)
+ 		goto out;
+ 
+ 	addr = (__u64)iloc.bh->b_blocknr << inode->i_sb->s_blocksize_bits;
+ 	addr += (char *)ext4_raw_inode(&iloc) - iloc.bh->b_data;
+ 	addr += offsetof(struct ext4_inode, i_block);
+ 
+ 	brelse(iloc.bh);
+ 
+ 	iomap->addr = addr;
+ 	iomap->offset = 0;
+ 	iomap->length = min_t(loff_t, ext4_get_inline_size(inode),
+ 			      i_size_read(inode));
+ 	iomap->type = IOMAP_INLINE;
+ 	iomap->flags = 0;
+ 
+ out:
+ 	up_read(&EXT4_I(inode)->xattr_sem);
+ 	return error;
+ }
+ 
++>>>>>>> 19319b53210c (iomap: inline data should be an iomap type, not a flag)
  int ext4_inline_data_fiemap(struct inode *inode,
  			    struct fiemap_extent_info *fieinfo,
  			    int *has_inline, __u64 start, __u64 len)
diff --cc fs/iomap.c
index 0466c51d2aef,df2652b0d85d..000000000000
--- a/fs/iomap.c
+++ b/fs/iomap.c
@@@ -746,3 -682,628 +747,631 @@@ iomap_seek_data(struct inode *inode, lo
  	return offset;
  }
  EXPORT_SYMBOL_GPL(iomap_seek_data);
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Private flags for iomap_dio, must not overlap with the public ones in
+  * iomap.h:
+  */
+ #define IOMAP_DIO_WRITE_FUA	(1 << 28)
+ #define IOMAP_DIO_NEED_SYNC	(1 << 29)
+ #define IOMAP_DIO_WRITE		(1 << 30)
+ #define IOMAP_DIO_DIRTY		(1 << 31)
+ 
+ struct iomap_dio {
+ 	struct kiocb		*iocb;
+ 	iomap_dio_end_io_t	*end_io;
+ 	loff_t			i_size;
+ 	loff_t			size;
+ 	atomic_t		ref;
+ 	unsigned		flags;
+ 	int			error;
+ 
+ 	union {
+ 		/* used during submission and for synchronous completion: */
+ 		struct {
+ 			struct iov_iter		*iter;
+ 			struct task_struct	*waiter;
+ 			struct request_queue	*last_queue;
+ 			blk_qc_t		cookie;
+ 		} submit;
+ 
+ 		/* used for aio completion: */
+ 		struct {
+ 			struct work_struct	work;
+ 		} aio;
+ 	};
+ };
+ 
+ static ssize_t iomap_dio_complete(struct iomap_dio *dio)
+ {
+ 	struct kiocb *iocb = dio->iocb;
+ 	struct inode *inode = file_inode(iocb->ki_filp);
+ 	loff_t offset = iocb->ki_pos;
+ 	ssize_t ret;
+ 
+ 	if (dio->end_io) {
+ 		ret = dio->end_io(iocb,
+ 				dio->error ? dio->error : dio->size,
+ 				dio->flags);
+ 	} else {
+ 		ret = dio->error;
+ 	}
+ 
+ 	if (likely(!ret)) {
+ 		ret = dio->size;
+ 		/* check for short read */
+ 		if (offset + ret > dio->i_size &&
+ 		    !(dio->flags & IOMAP_DIO_WRITE))
+ 			ret = dio->i_size - offset;
+ 		iocb->ki_pos += ret;
+ 	}
+ 
+ 	/*
+ 	 * Try again to invalidate clean pages which might have been cached by
+ 	 * non-direct readahead, or faulted in by get_user_pages() if the source
+ 	 * of the write was an mmap'ed region of the file we're writing.  Either
+ 	 * one is a pretty crazy thing to do, so we don't support it 100%.  If
+ 	 * this invalidation fails, tough, the write still worked...
+ 	 *
+ 	 * And this page cache invalidation has to be after dio->end_io(), as
+ 	 * some filesystems convert unwritten extents to real allocations in
+ 	 * end_io() when necessary, otherwise a racing buffer read would cache
+ 	 * zeros from unwritten extents.
+ 	 */
+ 	if (!dio->error &&
+ 	    (dio->flags & IOMAP_DIO_WRITE) && inode->i_mapping->nrpages) {
+ 		int err;
+ 		err = invalidate_inode_pages2_range(inode->i_mapping,
+ 				offset >> PAGE_SHIFT,
+ 				(offset + dio->size - 1) >> PAGE_SHIFT);
+ 		if (err)
+ 			dio_warn_stale_pagecache(iocb->ki_filp);
+ 	}
+ 
+ 	/*
+ 	 * If this is a DSYNC write, make sure we push it to stable storage now
+ 	 * that we've written data.
+ 	 */
+ 	if (ret > 0 && (dio->flags & IOMAP_DIO_NEED_SYNC))
+ 		ret = generic_write_sync(iocb, ret);
+ 
+ 	inode_dio_end(file_inode(iocb->ki_filp));
+ 	kfree(dio);
+ 
+ 	return ret;
+ }
+ 
+ static void iomap_dio_complete_work(struct work_struct *work)
+ {
+ 	struct iomap_dio *dio = container_of(work, struct iomap_dio, aio.work);
+ 	struct kiocb *iocb = dio->iocb;
+ 
+ 	iocb->ki_complete(iocb, iomap_dio_complete(dio), 0);
+ }
+ 
+ /*
+  * Set an error in the dio if none is set yet.  We have to use cmpxchg
+  * as the submission context and the completion context(s) can race to
+  * update the error.
+  */
+ static inline void iomap_dio_set_error(struct iomap_dio *dio, int ret)
+ {
+ 	cmpxchg(&dio->error, 0, ret);
+ }
+ 
+ static void iomap_dio_bio_end_io(struct bio *bio)
+ {
+ 	struct iomap_dio *dio = bio->bi_private;
+ 	bool should_dirty = (dio->flags & IOMAP_DIO_DIRTY);
+ 
+ 	if (bio->bi_status)
+ 		iomap_dio_set_error(dio, blk_status_to_errno(bio->bi_status));
+ 
+ 	if (atomic_dec_and_test(&dio->ref)) {
+ 		if (is_sync_kiocb(dio->iocb)) {
+ 			struct task_struct *waiter = dio->submit.waiter;
+ 
+ 			WRITE_ONCE(dio->submit.waiter, NULL);
+ 			wake_up_process(waiter);
+ 		} else if (dio->flags & IOMAP_DIO_WRITE) {
+ 			struct inode *inode = file_inode(dio->iocb->ki_filp);
+ 
+ 			INIT_WORK(&dio->aio.work, iomap_dio_complete_work);
+ 			queue_work(inode->i_sb->s_dio_done_wq, &dio->aio.work);
+ 		} else {
+ 			iomap_dio_complete_work(&dio->aio.work);
+ 		}
+ 	}
+ 
+ 	if (should_dirty) {
+ 		bio_check_pages_dirty(bio);
+ 	} else {
+ 		struct bio_vec *bvec;
+ 		int i;
+ 
+ 		bio_for_each_segment_all(bvec, bio, i)
+ 			put_page(bvec->bv_page);
+ 		bio_put(bio);
+ 	}
+ }
+ 
+ static blk_qc_t
+ iomap_dio_zero(struct iomap_dio *dio, struct iomap *iomap, loff_t pos,
+ 		unsigned len)
+ {
+ 	struct page *page = ZERO_PAGE(0);
+ 	struct bio *bio;
+ 
+ 	bio = bio_alloc(GFP_KERNEL, 1);
+ 	bio_set_dev(bio, iomap->bdev);
+ 	bio->bi_iter.bi_sector =
+ 		(iomap->addr + pos - iomap->offset) >> 9;
+ 	bio->bi_private = dio;
+ 	bio->bi_end_io = iomap_dio_bio_end_io;
+ 
+ 	get_page(page);
+ 	if (bio_add_page(bio, page, len, 0) != len)
+ 		BUG();
+ 	bio_set_op_attrs(bio, REQ_OP_WRITE, REQ_SYNC | REQ_IDLE);
+ 
+ 	atomic_inc(&dio->ref);
+ 	return submit_bio(bio);
+ }
+ 
+ static loff_t
+ iomap_dio_actor(struct inode *inode, loff_t pos, loff_t length,
+ 		void *data, struct iomap *iomap)
+ {
+ 	struct iomap_dio *dio = data;
+ 	unsigned int blkbits = blksize_bits(bdev_logical_block_size(iomap->bdev));
+ 	unsigned int fs_block_size = i_blocksize(inode), pad;
+ 	unsigned int align = iov_iter_alignment(dio->submit.iter);
+ 	struct iov_iter iter;
+ 	struct bio *bio;
+ 	bool need_zeroout = false;
+ 	bool use_fua = false;
+ 	int nr_pages, ret;
+ 	size_t copied = 0;
+ 
+ 	if ((pos | length | align) & ((1 << blkbits) - 1))
+ 		return -EINVAL;
+ 
+ 	switch (iomap->type) {
+ 	case IOMAP_HOLE:
+ 		if (WARN_ON_ONCE(dio->flags & IOMAP_DIO_WRITE))
+ 			return -EIO;
+ 		/*FALLTHRU*/
+ 	case IOMAP_UNWRITTEN:
+ 		if (!(dio->flags & IOMAP_DIO_WRITE)) {
+ 			length = iov_iter_zero(length, dio->submit.iter);
+ 			dio->size += length;
+ 			return length;
+ 		}
+ 		dio->flags |= IOMAP_DIO_UNWRITTEN;
+ 		need_zeroout = true;
+ 		break;
+ 	case IOMAP_MAPPED:
+ 		if (iomap->flags & IOMAP_F_SHARED)
+ 			dio->flags |= IOMAP_DIO_COW;
+ 		if (iomap->flags & IOMAP_F_NEW) {
+ 			need_zeroout = true;
+ 		} else {
+ 			/*
+ 			 * Use a FUA write if we need datasync semantics, this
+ 			 * is a pure data IO that doesn't require any metadata
+ 			 * updates and the underlying device supports FUA. This
+ 			 * allows us to avoid cache flushes on IO completion.
+ 			 */
+ 			if (!(iomap->flags & (IOMAP_F_SHARED|IOMAP_F_DIRTY)) &&
+ 			    (dio->flags & IOMAP_DIO_WRITE_FUA) &&
+ 			    blk_queue_fua(bdev_get_queue(iomap->bdev)))
+ 				use_fua = true;
+ 		}
+ 		break;
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		return -EIO;
+ 	}
+ 
+ 	/*
+ 	 * Operate on a partial iter trimmed to the extent we were called for.
+ 	 * We'll update the iter in the dio once we're done with this extent.
+ 	 */
+ 	iter = *dio->submit.iter;
+ 	iov_iter_truncate(&iter, length);
+ 
+ 	nr_pages = iov_iter_npages(&iter, BIO_MAX_PAGES);
+ 	if (nr_pages <= 0)
+ 		return nr_pages;
+ 
+ 	if (need_zeroout) {
+ 		/* zero out from the start of the block to the write offset */
+ 		pad = pos & (fs_block_size - 1);
+ 		if (pad)
+ 			iomap_dio_zero(dio, iomap, pos - pad, pad);
+ 	}
+ 
+ 	do {
+ 		size_t n;
+ 		if (dio->error) {
+ 			iov_iter_revert(dio->submit.iter, copied);
+ 			return 0;
+ 		}
+ 
+ 		bio = bio_alloc(GFP_KERNEL, nr_pages);
+ 		bio_set_dev(bio, iomap->bdev);
+ 		bio->bi_iter.bi_sector =
+ 			(iomap->addr + pos - iomap->offset) >> 9;
+ 		bio->bi_write_hint = dio->iocb->ki_hint;
+ 		bio->bi_private = dio;
+ 		bio->bi_end_io = iomap_dio_bio_end_io;
+ 
+ 		ret = bio_iov_iter_get_pages(bio, &iter);
+ 		if (unlikely(ret)) {
+ 			bio_put(bio);
+ 			return copied ? copied : ret;
+ 		}
+ 
+ 		n = bio->bi_iter.bi_size;
+ 		if (dio->flags & IOMAP_DIO_WRITE) {
+ 			bio->bi_opf = REQ_OP_WRITE | REQ_SYNC | REQ_IDLE;
+ 			if (use_fua)
+ 				bio->bi_opf |= REQ_FUA;
+ 			else
+ 				dio->flags &= ~IOMAP_DIO_WRITE_FUA;
+ 			task_io_account_write(n);
+ 		} else {
+ 			bio->bi_opf = REQ_OP_READ;
+ 			if (dio->flags & IOMAP_DIO_DIRTY)
+ 				bio_set_pages_dirty(bio);
+ 		}
+ 
+ 		iov_iter_advance(dio->submit.iter, n);
+ 
+ 		dio->size += n;
+ 		pos += n;
+ 		copied += n;
+ 
+ 		nr_pages = iov_iter_npages(&iter, BIO_MAX_PAGES);
+ 
+ 		atomic_inc(&dio->ref);
+ 
+ 		dio->submit.last_queue = bdev_get_queue(iomap->bdev);
+ 		dio->submit.cookie = submit_bio(bio);
+ 	} while (nr_pages);
+ 
+ 	if (need_zeroout) {
+ 		/* zero out from the end of the write to the end of the block */
+ 		pad = pos & (fs_block_size - 1);
+ 		if (pad)
+ 			iomap_dio_zero(dio, iomap, pos, fs_block_size - pad);
+ 	}
+ 	return copied;
+ }
+ 
+ /*
+  * iomap_dio_rw() always completes O_[D]SYNC writes regardless of whether the IO
+  * is being issued as AIO or not.  This allows us to optimise pure data writes
+  * to use REQ_FUA rather than requiring generic_write_sync() to issue a
+  * REQ_FLUSH post write. This is slightly tricky because a single request here
+  * can be mapped into multiple disjoint IOs and only a subset of the IOs issued
+  * may be pure data writes. In that case, we still need to do a full data sync
+  * completion.
+  */
+ ssize_t
+ iomap_dio_rw(struct kiocb *iocb, struct iov_iter *iter,
+ 		const struct iomap_ops *ops, iomap_dio_end_io_t end_io)
+ {
+ 	struct address_space *mapping = iocb->ki_filp->f_mapping;
+ 	struct inode *inode = file_inode(iocb->ki_filp);
+ 	size_t count = iov_iter_count(iter);
+ 	loff_t pos = iocb->ki_pos, start = pos;
+ 	loff_t end = iocb->ki_pos + count - 1, ret = 0;
+ 	unsigned int flags = IOMAP_DIRECT;
+ 	struct blk_plug plug;
+ 	struct iomap_dio *dio;
+ 
+ 	lockdep_assert_held(&inode->i_rwsem);
+ 
+ 	if (!count)
+ 		return 0;
+ 
+ 	dio = kmalloc(sizeof(*dio), GFP_KERNEL);
+ 	if (!dio)
+ 		return -ENOMEM;
+ 
+ 	dio->iocb = iocb;
+ 	atomic_set(&dio->ref, 1);
+ 	dio->size = 0;
+ 	dio->i_size = i_size_read(inode);
+ 	dio->end_io = end_io;
+ 	dio->error = 0;
+ 	dio->flags = 0;
+ 
+ 	dio->submit.iter = iter;
+ 	if (is_sync_kiocb(iocb)) {
+ 		dio->submit.waiter = current;
+ 		dio->submit.cookie = BLK_QC_T_NONE;
+ 		dio->submit.last_queue = NULL;
+ 	}
+ 
+ 	if (iov_iter_rw(iter) == READ) {
+ 		if (pos >= dio->i_size)
+ 			goto out_free_dio;
+ 
+ 		if (iter->type == ITER_IOVEC)
+ 			dio->flags |= IOMAP_DIO_DIRTY;
+ 	} else {
+ 		flags |= IOMAP_WRITE;
+ 		dio->flags |= IOMAP_DIO_WRITE;
+ 
+ 		/* for data sync or sync, we need sync completion processing */
+ 		if (iocb->ki_flags & IOCB_DSYNC)
+ 			dio->flags |= IOMAP_DIO_NEED_SYNC;
+ 
+ 		/*
+ 		 * For datasync only writes, we optimistically try using FUA for
+ 		 * this IO.  Any non-FUA write that occurs will clear this flag,
+ 		 * hence we know before completion whether a cache flush is
+ 		 * necessary.
+ 		 */
+ 		if ((iocb->ki_flags & (IOCB_DSYNC | IOCB_SYNC)) == IOCB_DSYNC)
+ 			dio->flags |= IOMAP_DIO_WRITE_FUA;
+ 	}
+ 
+ 	if (iocb->ki_flags & IOCB_NOWAIT) {
+ 		if (filemap_range_has_page(mapping, start, end)) {
+ 			ret = -EAGAIN;
+ 			goto out_free_dio;
+ 		}
+ 		flags |= IOMAP_NOWAIT;
+ 	}
+ 
+ 	ret = filemap_write_and_wait_range(mapping, start, end);
+ 	if (ret)
+ 		goto out_free_dio;
+ 
+ 	/*
+ 	 * Try to invalidate cache pages for the range we're direct
+ 	 * writing.  If this invalidation fails, tough, the write will
+ 	 * still work, but racing two incompatible write paths is a
+ 	 * pretty crazy thing to do, so we don't support it 100%.
+ 	 */
+ 	ret = invalidate_inode_pages2_range(mapping,
+ 			start >> PAGE_SHIFT, end >> PAGE_SHIFT);
+ 	if (ret)
+ 		dio_warn_stale_pagecache(iocb->ki_filp);
+ 	ret = 0;
+ 
+ 	if (iov_iter_rw(iter) == WRITE && !is_sync_kiocb(iocb) &&
+ 	    !inode->i_sb->s_dio_done_wq) {
+ 		ret = sb_init_dio_done_wq(inode->i_sb);
+ 		if (ret < 0)
+ 			goto out_free_dio;
+ 	}
+ 
+ 	inode_dio_begin(inode);
+ 
+ 	blk_start_plug(&plug);
+ 	do {
+ 		ret = iomap_apply(inode, pos, count, flags, ops, dio,
+ 				iomap_dio_actor);
+ 		if (ret <= 0) {
+ 			/* magic error code to fall back to buffered I/O */
+ 			if (ret == -ENOTBLK)
+ 				ret = 0;
+ 			break;
+ 		}
+ 		pos += ret;
+ 
+ 		if (iov_iter_rw(iter) == READ && pos >= dio->i_size)
+ 			break;
+ 	} while ((count = iov_iter_count(iter)) > 0);
+ 	blk_finish_plug(&plug);
+ 
+ 	if (ret < 0)
+ 		iomap_dio_set_error(dio, ret);
+ 
+ 	/*
+ 	 * If all the writes we issued were FUA, we don't need to flush the
+ 	 * cache on IO completion. Clear the sync flag for this case.
+ 	 */
+ 	if (dio->flags & IOMAP_DIO_WRITE_FUA)
+ 		dio->flags &= ~IOMAP_DIO_NEED_SYNC;
+ 
+ 	if (!atomic_dec_and_test(&dio->ref)) {
+ 		if (!is_sync_kiocb(iocb))
+ 			return -EIOCBQUEUED;
+ 
+ 		for (;;) {
+ 			set_current_state(TASK_UNINTERRUPTIBLE);
+ 			if (!READ_ONCE(dio->submit.waiter))
+ 				break;
+ 
+ 			if (!(iocb->ki_flags & IOCB_HIPRI) ||
+ 			    !dio->submit.last_queue ||
+ 			    !blk_poll(dio->submit.last_queue,
+ 					 dio->submit.cookie))
+ 				io_schedule();
+ 		}
+ 		__set_current_state(TASK_RUNNING);
+ 	}
+ 
+ 	ret = iomap_dio_complete(dio);
+ 
+ 	return ret;
+ 
+ out_free_dio:
+ 	kfree(dio);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(iomap_dio_rw);
+ 
+ /* Swapfile activation */
+ 
+ #ifdef CONFIG_SWAP
+ struct iomap_swapfile_info {
+ 	struct iomap iomap;		/* accumulated iomap */
+ 	struct swap_info_struct *sis;
+ 	uint64_t lowest_ppage;		/* lowest physical addr seen (pages) */
+ 	uint64_t highest_ppage;		/* highest physical addr seen (pages) */
+ 	unsigned long nr_pages;		/* number of pages collected */
+ 	int nr_extents;			/* extent count */
+ };
+ 
+ /*
+  * Collect physical extents for this swap file.  Physical extents reported to
+  * the swap code must be trimmed to align to a page boundary.  The logical
+  * offset within the file is irrelevant since the swapfile code maps logical
+  * page numbers of the swap device to the physical page-aligned extents.
+  */
+ static int iomap_swapfile_add_extent(struct iomap_swapfile_info *isi)
+ {
+ 	struct iomap *iomap = &isi->iomap;
+ 	unsigned long nr_pages;
+ 	uint64_t first_ppage;
+ 	uint64_t first_ppage_reported;
+ 	uint64_t next_ppage;
+ 	int error;
+ 
+ 	/*
+ 	 * Round the start up and the end down so that the physical
+ 	 * extent aligns to a page boundary.
+ 	 */
+ 	first_ppage = ALIGN(iomap->addr, PAGE_SIZE) >> PAGE_SHIFT;
+ 	next_ppage = ALIGN_DOWN(iomap->addr + iomap->length, PAGE_SIZE) >>
+ 			PAGE_SHIFT;
+ 
+ 	/* Skip too-short physical extents. */
+ 	if (first_ppage >= next_ppage)
+ 		return 0;
+ 	nr_pages = next_ppage - first_ppage;
+ 
+ 	/*
+ 	 * Calculate how much swap space we're adding; the first page contains
+ 	 * the swap header and doesn't count.  The mm still wants that first
+ 	 * page fed to add_swap_extent, however.
+ 	 */
+ 	first_ppage_reported = first_ppage;
+ 	if (iomap->offset == 0)
+ 		first_ppage_reported++;
+ 	if (isi->lowest_ppage > first_ppage_reported)
+ 		isi->lowest_ppage = first_ppage_reported;
+ 	if (isi->highest_ppage < (next_ppage - 1))
+ 		isi->highest_ppage = next_ppage - 1;
+ 
+ 	/* Add extent, set up for the next call. */
+ 	error = add_swap_extent(isi->sis, isi->nr_pages, nr_pages, first_ppage);
+ 	if (error < 0)
+ 		return error;
+ 	isi->nr_extents += error;
+ 	isi->nr_pages += nr_pages;
+ 	return 0;
+ }
+ 
+ /*
+  * Accumulate iomaps for this swap file.  We have to accumulate iomaps because
+  * swap only cares about contiguous page-aligned physical extents and makes no
+  * distinction between written and unwritten extents.
+  */
+ static loff_t iomap_swapfile_activate_actor(struct inode *inode, loff_t pos,
+ 		loff_t count, void *data, struct iomap *iomap)
+ {
+ 	struct iomap_swapfile_info *isi = data;
+ 	int error;
+ 
+ 	switch (iomap->type) {
+ 	case IOMAP_MAPPED:
+ 	case IOMAP_UNWRITTEN:
+ 		/* Only real or unwritten extents. */
+ 		break;
+ 	case IOMAP_INLINE:
+ 		/* No inline data. */
+ 		pr_err("swapon: file is inline\n");
+ 		return -EINVAL;
+ 	default:
+ 		pr_err("swapon: file has unallocated extents\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* No uncommitted metadata or shared blocks. */
+ 	if (iomap->flags & IOMAP_F_DIRTY) {
+ 		pr_err("swapon: file is not committed\n");
+ 		return -EINVAL;
+ 	}
+ 	if (iomap->flags & IOMAP_F_SHARED) {
+ 		pr_err("swapon: file has shared extents\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Only one bdev per swap file. */
+ 	if (iomap->bdev != isi->sis->bdev) {
+ 		pr_err("swapon: file is on multiple devices\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (isi->iomap.length == 0) {
+ 		/* No accumulated extent, so just store it. */
+ 		memcpy(&isi->iomap, iomap, sizeof(isi->iomap));
+ 	} else if (isi->iomap.addr + isi->iomap.length == iomap->addr) {
+ 		/* Append this to the accumulated extent. */
+ 		isi->iomap.length += iomap->length;
+ 	} else {
+ 		/* Otherwise, add the retained iomap and store this one. */
+ 		error = iomap_swapfile_add_extent(isi);
+ 		if (error)
+ 			return error;
+ 		memcpy(&isi->iomap, iomap, sizeof(isi->iomap));
+ 	}
+ 	return count;
+ }
+ 
+ /*
+  * Iterate a swap file's iomaps to construct physical extents that can be
+  * passed to the swapfile subsystem.
+  */
+ int iomap_swapfile_activate(struct swap_info_struct *sis,
+ 		struct file *swap_file, sector_t *pagespan,
+ 		const struct iomap_ops *ops)
+ {
+ 	struct iomap_swapfile_info isi = {
+ 		.sis = sis,
+ 		.lowest_ppage = (sector_t)-1ULL,
+ 	};
+ 	struct address_space *mapping = swap_file->f_mapping;
+ 	struct inode *inode = mapping->host;
+ 	loff_t pos = 0;
+ 	loff_t len = ALIGN_DOWN(i_size_read(inode), PAGE_SIZE);
+ 	loff_t ret;
+ 
+ 	ret = filemap_write_and_wait(inode->i_mapping);
+ 	if (ret)
+ 		return ret;
+ 
+ 	while (len > 0) {
+ 		ret = iomap_apply(inode, pos, len, IOMAP_REPORT,
+ 				ops, &isi, iomap_swapfile_activate_actor);
+ 		if (ret <= 0)
+ 			return ret;
+ 
+ 		pos += ret;
+ 		len -= ret;
+ 	}
+ 
+ 	if (isi.iomap.length) {
+ 		ret = iomap_swapfile_add_extent(&isi);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	*pagespan = 1 + isi.highest_ppage - isi.lowest_ppage;
+ 	sis->max = isi.nr_pages;
+ 	sis->pages = isi.nr_pages - 1;
+ 	sis->highest_bit = isi.nr_pages - 1;
+ 	return isi.nr_extents;
+ }
+ EXPORT_SYMBOL_GPL(iomap_swapfile_activate);
+ #endif /* CONFIG_SWAP */
++>>>>>>> 19319b53210c (iomap: inline data should be an iomap type, not a flag)
* Unmerged path fs/ext4/inline.c
diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index 2b54e62ca6f7..99e55df9444c 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -689,8 +689,7 @@ static void gfs2_stuffed_iomap(struct inode *inode, struct iomap *iomap)
 		      sizeof(struct gfs2_dinode);
 	iomap->offset = 0;
 	iomap->length = i_size_read(inode);
-	iomap->type = IOMAP_MAPPED;
-	iomap->flags = IOMAP_F_DATA_INLINE;
+	iomap->type = IOMAP_INLINE;
 }
 
 /**
* Unmerged path fs/iomap.c
diff --git a/include/linux/iomap.h b/include/linux/iomap.h
index 13e11e5099b6..9a5f971849ff 100644
--- a/include/linux/iomap.h
+++ b/include/linux/iomap.h
@@ -20,6 +20,7 @@ struct vm_fault;
 #define IOMAP_DELALLOC	0x02	/* delayed allocation blocks */
 #define IOMAP_MAPPED	0x03	/* blocks allocated at @addr */
 #define IOMAP_UNWRITTEN	0x04	/* blocks allocated at @addr in unwritten state */
+#define IOMAP_INLINE	0x05	/* data inline in the inode */
 
 /*
  * Flags for all iomap mappings:
@@ -36,7 +37,6 @@ struct vm_fault;
  */
 #define IOMAP_F_MERGED		0x10	/* contains multiple blocks/extents */
 #define IOMAP_F_SHARED		0x20	/* block shared with another file */
-#define IOMAP_F_DATA_INLINE	0x40	/* data inline in the inode */
 
 /*
  * Magic value for addr:
