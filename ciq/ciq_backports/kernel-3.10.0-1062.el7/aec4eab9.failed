net/mlx5e: Vxlan, add sync lock for add/del vxlan port

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Vxlan, add sync lock for add/del vxlan port (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 96.15%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit aec4eab9af9606e8a6a1ceab3ec5a15030751876
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/aec4eab9.failed

Vxlan API can and will be called from different mlx5 modules, we should
not count on mlx5e private state lock only, hence we introduce a vxlan
private mutex to sync between add/del vxlan port operations.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
(cherry picked from commit aec4eab9af9606e8a6a1ceab3ec5a15030751876)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
index a2b48ad77f26,9a8fd762167b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
@@@ -36,6 -36,15 +36,18 @@@
  #include "mlx5_core.h"
  #include "vxlan.h"
  
++<<<<<<< HEAD
++=======
+ struct mlx5_vxlan {
+ 	struct mlx5_core_dev		*mdev;
+ 	spinlock_t			lock; /* protect vxlan table */
+ 	/* max_num_ports is usuallly 4, 16 buckets is more than enough */
+ 	DECLARE_HASHTABLE(htable, 4);
+ 	int				num_ports;
+ 	struct mutex                    sync_lock; /* sync add/del port HW operations */
+ };
+ 
++>>>>>>> aec4eab9af96 (net/mlx5e: Vxlan, add sync lock for add/del vxlan port)
  struct mlx5_vxlan_port {
  	struct hlist_node hlist;
  	atomic_t refcount;
@@@ -109,55 -105,69 +121,92 @@@ struct mlx5_vxlan_port *mlx5e_vxlan_loo
  	return vxlanp;
  }
  
 -int mlx5_vxlan_add_port(struct mlx5_vxlan *vxlan, u16 port)
 +void mlx5e_vxlan_add_port(struct mlx5e_priv *priv, u16 port)
  {
 +	struct mlx5e_vxlan_db *vxlan_db = &priv->vxlan;
  	struct mlx5_vxlan_port *vxlanp;
 -	int ret = -ENOSPC;
  
 -	vxlanp = mlx5_vxlan_lookup_port(vxlan, port);
 +	vxlanp = mlx5e_vxlan_lookup_port(priv, port);
  	if (vxlanp) {
  		atomic_inc(&vxlanp->refcount);
 -		return 0;
 +		return;
 +	}
 +
++<<<<<<< HEAD
 +	if (vxlan_db->num_ports >= mlx5e_vxlan_max_udp_ports(priv->mdev)) {
 +		netdev_info(priv->netdev,
 +			    "UDP port (%d) not offloaded, max number of UDP ports (%d) are already offloaded\n",
 +			    port, mlx5e_vxlan_max_udp_ports(priv->mdev));
 +		return;
  	}
  
 +	if (mlx5e_vxlan_core_add_port_cmd(priv->mdev, port))
 +		return;
++=======
+ 	mutex_lock(&vxlan->sync_lock);
+ 	if (vxlan->num_ports >= mlx5_vxlan_max_udp_ports(vxlan->mdev)) {
+ 		mlx5_core_info(vxlan->mdev,
+ 			       "UDP port (%d) not offloaded, max number of UDP ports (%d) are already offloaded\n",
+ 			       port, mlx5_vxlan_max_udp_ports(vxlan->mdev));
+ 		ret = -ENOSPC;
+ 		goto unlock;
+ 	}
+ 
+ 	ret = mlx5_vxlan_core_add_port_cmd(vxlan->mdev, port);
+ 	if (ret)
+ 		goto unlock;
++>>>>>>> aec4eab9af96 (net/mlx5e: Vxlan, add sync lock for add/del vxlan port)
  
  	vxlanp = kzalloc(sizeof(*vxlanp), GFP_KERNEL);
 -	if (!vxlanp) {
 -		ret = -ENOMEM;
 +	if (!vxlanp)
  		goto err_delete_port;
 -	}
  
  	vxlanp->udp_port = port;
  	atomic_set(&vxlanp->refcount, 1);
  
 -	spin_lock_bh(&vxlan->lock);
 -	hash_add(vxlan->htable, &vxlanp->hlist, port);
 -	spin_unlock_bh(&vxlan->lock);
 +	spin_lock_bh(&vxlan_db->lock);
 +	hash_add(vxlan_db->htable, &vxlanp->hlist, port);
 +	spin_unlock_bh(&vxlan_db->lock);
 +
++<<<<<<< HEAD
 +	vxlan_db->num_ports++;
 +	return;
  
 +err_delete_port:
 +	mlx5e_vxlan_core_del_port_cmd(priv->mdev, port);
++=======
+ 	vxlan->num_ports++;
+ 	mutex_unlock(&vxlan->sync_lock);
+ 	return 0;
+ 
+ err_delete_port:
+ 	mlx5_vxlan_core_del_port_cmd(vxlan->mdev, port);
+ 
+ unlock:
+ 	mutex_unlock(&vxlan->sync_lock);
+ 	return ret;
++>>>>>>> aec4eab9af96 (net/mlx5e: Vxlan, add sync lock for add/del vxlan port)
  }
  
 -int mlx5_vxlan_del_port(struct mlx5_vxlan *vxlan, u16 port)
 +void mlx5e_vxlan_del_port(struct mlx5e_priv *priv, u16 port)
  {
 +	struct mlx5e_vxlan_db *vxlan_db = &priv->vxlan;
  	struct mlx5_vxlan_port *vxlanp;
  	bool remove = false;
 -	int ret = 0;
  
++<<<<<<< HEAD
 +	spin_lock_bh(&vxlan_db->lock);
 +	vxlanp = mlx5e_vxlan_lookup_port_locked(priv, port);
 +	if (!vxlanp)
++=======
+ 	mutex_lock(&vxlan->sync_lock);
+ 
+ 	spin_lock_bh(&vxlan->lock);
+ 	vxlanp = mlx5_vxlan_lookup_port_locked(vxlan, port);
+ 	if (!vxlanp) {
+ 		ret = -ENOENT;
++>>>>>>> aec4eab9af96 (net/mlx5e: Vxlan, add sync lock for add/del vxlan port)
  		goto out_unlock;
 -	}
  
  	if (atomic_dec_and_test(&vxlanp->refcount)) {
  		hash_del(&vxlanp->hlist);
@@@ -165,18 -175,43 +214,50 @@@
  	}
  
  out_unlock:
 -	spin_unlock_bh(&vxlan->lock);
 +	spin_unlock_bh(&vxlan_db->lock);
  
  	if (remove) {
 -		mlx5_vxlan_core_del_port_cmd(vxlan->mdev, port);
 +		mlx5e_vxlan_core_del_port_cmd(priv->mdev, port);
  		kfree(vxlanp);
 -		vxlan->num_ports--;
 +		vxlan_db->num_ports--;
  	}
++<<<<<<< HEAD
 +}
 +
 +void mlx5e_vxlan_cleanup(struct mlx5e_priv *priv)
++=======
+ 
+ 	mutex_unlock(&vxlan->sync_lock);
+ 
+ 	return ret;
+ }
+ 
+ struct mlx5_vxlan *mlx5_vxlan_create(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_vxlan *vxlan;
+ 
+ 	if (!MLX5_CAP_ETH(mdev, tunnel_stateless_vxlan) || !mlx5_core_is_pf(mdev))
+ 		return ERR_PTR(-ENOTSUPP);
+ 
+ 	vxlan = kzalloc(sizeof(*vxlan), GFP_KERNEL);
+ 	if (!vxlan)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	vxlan->mdev = mdev;
+ 	mutex_init(&vxlan->sync_lock);
+ 	spin_lock_init(&vxlan->lock);
+ 	hash_init(vxlan->htable);
+ 
+ 	/* Hardware adds 4789 by default */
+ 	mlx5_vxlan_add_port(vxlan, 4789);
+ 
+ 	return vxlan;
+ }
+ 
+ void mlx5_vxlan_destroy(struct mlx5_vxlan *vxlan)
++>>>>>>> aec4eab9af96 (net/mlx5e: Vxlan, add sync lock for add/del vxlan port)
  {
 +	struct mlx5e_vxlan_db *vxlan_db = &priv->vxlan;
  	struct mlx5_vxlan_port *vxlanp;
  	struct hlist_node *tmp;
  	int bkt;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
