ipmi_si: Fix crash when using hard-coded device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit 41b766d661bf94a364960862cfc248a78313dbd3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/41b766d6.failed

When excuting a command like:
  modprobe ipmi_si ports=0xffc0e3 type=bt
The system would get an oops.

The trouble here is that ipmi_si_hardcode_find_bmc() is called before
ipmi_si_platform_init(), but initialization of the hard-coded device
creates an IPMI platform device, which won't be initialized yet.

The real trouble is that hard-coded devices aren't created with
any device, and the fixup is done later.  So do it right, create the
hard-coded devices as normal platform devices.

This required adding some new resource types to the IPMI platform
code for passing information required by the hard-coded device
and adding some code to remove the hard-coded platform devices
on module removal.

To enforce the "hard-coded devices passed by the user take priority
over firmware devices" rule, some special code was added to check
and see if a hard-coded device already exists.

	Reported-by: Yang Yingliang <yangyingliang@huawei.com>
	Cc: stable@vger.kernel.org # v4.15+
	Signed-off-by: Corey Minyard <cminyard@mvista.com>
	Tested-by: Yang Yingliang <yangyingliang@huawei.com>
(cherry picked from commit 41b766d661bf94a364960862cfc248a78313dbd3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_hardcode.c
#	drivers/char/ipmi/ipmi_si_intf.c
#	drivers/char/ipmi/ipmi_si_platform.c
diff --cc drivers/char/ipmi/ipmi_si_hardcode.c
index 6383058dcd0d,1e5783961b0d..000000000000
--- a/drivers/char/ipmi/ipmi_si_hardcode.c
+++ b/drivers/char/ipmi/ipmi_si_hardcode.c
@@@ -1,8 -1,11 +1,9 @@@
 -// SPDX-License-Identifier: GPL-2.0+
 -
 -#define pr_fmt(fmt) "ipmi_hardcode: " fmt
  
  #include <linux/moduleparam.h>
+ #include <linux/platform_device.h>
  #include "ipmi_si.h"
  
 +#define PFX "ipmi_hardcode: "
  /*
   * There can be 4 IO ports passed in (with or without IRQs), 4 addresses,
   * a default IO port, and 1 ACPI/SPMI address.  That sets SI_MAX_DRIVERS.
@@@ -93,54 -216,45 +214,94 @@@ void __init ipmi_hardcode_init(void
  		}
  	}
  
- 	memset(&io, 0, sizeof(io));
  	for (i = 0; i < SI_MAX_PARMS; i++) {
++<<<<<<< HEAD
 +		if (!ports[i] && !addrs[i])
 +			continue;
 +
 +		io.addr_source = SI_HARDCODED;
 +		pr_info(PFX "probing via hardcoded address\n");
 +
 +		if (!si_type[i] || strcmp(si_type[i], "kcs") == 0) {
 +			io.si_type = SI_KCS;
 +		} else if (strcmp(si_type[i], "smic") == 0) {
 +			io.si_type = SI_SMIC;
 +		} else if (strcmp(si_type[i], "bt") == 0) {
 +			io.si_type = SI_BT;
 +		} else {
 +			pr_warn(PFX "Interface type specified for interface %d, was invalid: %s\n",
 +				i, si_type[i]);
 +			continue;
 +		}
 +
 +		if (ports[i]) {
 +			/* An I/O port */
 +			io.addr_data = ports[i];
 +			io.addr_type = IPMI_IO_ADDR_SPACE;
 +		} else if (addrs[i]) {
 +			/* A memory port */
 +			io.addr_data = addrs[i];
 +			io.addr_type = IPMI_MEM_ADDR_SPACE;
 +		} else {
 +			pr_warn(PFX "Interface type specified for interface %d, but port and address were not set or set to zero.\n",
 +				i);
 +			continue;
 +		}
 +
 +		io.addr = NULL;
 +		io.regspacing = regspacings[i];
 +		if (!io.regspacing)
 +			io.regspacing = DEFAULT_REGSPACING;
 +		io.regsize = regsizes[i];
 +		if (!io.regsize)
 +			io.regsize = DEFAULT_REGSIZE;
 +		io.regshift = regshifts[i];
 +		io.irq = irqs[i];
 +		if (io.irq)
 +			io.irq_setup = ipmi_std_irq_setup;
 +		io.slave_addr = slave_addrs[i];
 +
 +		ret = ipmi_si_add_smi(&io);
++=======
+ 		if (i < num_ports && ports[i])
+ 			ipmi_hardcode_init_one(si_type[i], i, ports[i],
+ 					       IORESOURCE_IO);
+ 		if (i < num_addrs && addrs[i])
+ 			ipmi_hardcode_init_one(si_type[i], i, addrs[i],
+ 					       IORESOURCE_MEM);
++>>>>>>> 41b766d661bf (ipmi_si: Fix crash when using hard-coded device)
+ 	}
+ }
+ 
+ void ipmi_si_hardcode_exit(void)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < SI_MAX_PARMS; i++) {
+ 		if (ipmi_hc_pdevs[i])
+ 			platform_device_unregister(ipmi_hc_pdevs[i]);
  	}
- 	return ret;
+ }
+ 
+ /*
+  * Returns true of the given address exists as a hardcoded address,
+  * false if not.
+  */
+ int ipmi_si_hardcode_match(int addr_type, unsigned long addr)
+ {
+ 	unsigned int i;
+ 
+ 	if (addr_type == IPMI_IO_ADDR_SPACE) {
+ 		for (i = 0; i < num_ports; i++) {
+ 			if (ports[i] == addr)
+ 				return 1;
+ 		}
+ 	} else {
+ 		for (i = 0; i < num_addrs; i++) {
+ 			if (addrs[i] == addr)
+ 				return 1;
+ 		}
+ 	}
+ 
+ 	return 0;
  }
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 995c76ba9a4f,abbd526626d5..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -2267,21 -2117,9 +2279,23 @@@ static int __init init_ipmi_si(void
  	if (initialized)
  		return 0;
  
++<<<<<<< HEAD
 +	/* RHEL7-only - Init ipmi_shadow_smi_handlers
 +	 * The instance of struct ipmi_shadow_smi_handlers is located in
 +	 * ipmi_msghandler.c. Locating it in this file would cause a
 +	 * module dependency loop, because ipmi_msghandler would then
 +	 * depend on ipmi_si, which already depends on ipmi_msghandler.
 +	 */
 +	shadow_handlers = ipmi_get_shadow_smi_handlers();
 +	shadow_handlers->handlers = &handlers;
 +	shadow_handlers->set_need_watch = set_need_watch;
 +
 +	pr_info("IPMI System Interface driver.\n");
++=======
+ 	ipmi_hardcode_init();
++>>>>>>> 41b766d661bf (ipmi_si: Fix crash when using hard-coded device)
  
- 	/* If the user gave us a device, they presumably want us to use it */
- 	if (!ipmi_si_hardcode_find_bmc())
- 		goto do_scan;
+ 	pr_info("IPMI System Interface driver\n");
  
  	ipmi_si_platform_init();
  
diff --cc drivers/char/ipmi/ipmi_si_platform.c
index f807009a6a13,8158d03542f4..000000000000
--- a/drivers/char/ipmi/ipmi_si_platform.c
+++ b/drivers/char/ipmi/ipmi_si_platform.c
@@@ -420,6 -433,12 +434,15 @@@ static int ipmi_remove(struct platform_
  	return ipmi_si_remove_by_dev(&pdev->dev);
  }
  
++<<<<<<< HEAD
++=======
+ static const struct platform_device_id si_plat_ids[] = {
+ 	{ "dmi-ipmi-si", 0 },
+ 	{ "hardcode-ipmi-si", 0 },
+ 	{ }
+ };
+ 
++>>>>>>> 41b766d661bf (ipmi_si: Fix crash when using hard-coded device)
  struct platform_driver ipmi_platform_driver = {
  	.driver = {
  		.name = DEVICE_NAME,
diff --git a/drivers/char/ipmi/ipmi_si.h b/drivers/char/ipmi/ipmi_si.h
index 8aad83a3c127..003878a38e42 100644
--- a/drivers/char/ipmi/ipmi_si.h
+++ b/drivers/char/ipmi/ipmi_si.h
@@ -25,7 +25,9 @@ void ipmi_irq_finish_setup(struct si_sm_io *io);
 int ipmi_si_remove_by_dev(struct device *dev);
 void ipmi_si_remove_by_data(int addr_space, enum si_type si_type,
 			    unsigned long addr);
-int ipmi_si_hardcode_find_bmc(void);
+void ipmi_hardcode_init(void);
+void ipmi_si_hardcode_exit(void);
+int ipmi_si_hardcode_match(int addr_type, unsigned long addr);
 void ipmi_si_platform_init(void);
 void ipmi_si_platform_shutdown(void);
 
* Unmerged path drivers/char/ipmi/ipmi_si_hardcode.c
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
* Unmerged path drivers/char/ipmi/ipmi_si_platform.c
