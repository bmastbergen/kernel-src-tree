xfs: serialize unaligned dio writes against all other dio writes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 2032a8a27b5cc0f578d37fa16fa2494b80a0d00a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/2032a8a2.failed

XFS applies more strict serialization constraints to unaligned
direct writes to accommodate things like direct I/O layer zeroing,
unwritten extent conversion, etc. Unaligned submissions acquire the
exclusive iolock and wait for in-flight dio to complete to ensure
multiple submissions do not race on the same block and cause data
corruption.

This generally works in the case of an aligned dio followed by an
unaligned dio, but the serialization is lost if I/Os occur in the
opposite order. If an unaligned write is submitted first and
immediately followed by an overlapping, aligned write, the latter
submits without the typical unaligned serialization barriers because
there is no indication of an unaligned dio still in-flight. This can
lead to unpredictable results.

To provide proper unaligned dio serialization, require that such
direct writes are always the only dio allowed in-flight at one time
for a particular inode. We already acquire the exclusive iolock and
drain pending dio before submitting the unaligned dio. Wait once
more after the dio submission to hold the iolock across the I/O and
prevent further submissions until the unaligned I/O completes. This
is heavy handed, but consistent with the current pre-submission
serialization for unaligned direct writes.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Allison Henderson <allison.henderson@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 2032a8a27b5cc0f578d37fa16fa2494b80a0d00a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_file.c
diff --cc fs/xfs/xfs_file.c
index 374d446488ef,a7ceae90110e..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -680,64 -516,47 +680,88 @@@ xfs_file_dio_aio_write
  		iolock = XFS_IOLOCK_SHARED;
  	}
  
 -	if (iocb->ki_flags & IOCB_NOWAIT) {
 -		if (!xfs_ilock_nowait(ip, iolock))
 -			return -EAGAIN;
 -	} else {
 -		xfs_ilock(ip, iolock);
 -	}
 +	xfs_rw_ilock(ip, iolock);
  
 -	ret = xfs_file_aio_write_checks(iocb, from, &iolock);
 +	ret = xfs_file_aio_write_checks(file, &pos, &count, &iolock);
  	if (ret)
  		goto out;
 -	count = iov_iter_count(from);
 +	end = pos + count - 1;
 +
 +	if (mapping->nrpages) {
 +		ret = filemap_write_and_wait_range(mapping, pos, end);
 +		if (ret)
 +			goto out;
 +
 +		/*
 +		 * Invalidate whole pages. This can return an error if we fail
 +		 * to invalidate a page, but this should never happen on XFS.
 +		 * Warn if it does fail.
 +		 */
 +		ret = invalidate_inode_pages2_range(mapping,
 +				pos >> PAGE_SHIFT, end >> PAGE_SHIFT);
 +		WARN_ON_ONCE(ret);
 +		ret = 0;
 +	}
  
  	/*
- 	 * If we are doing unaligned IO, wait for all other IO to drain,
- 	 * otherwise demote the lock if we had to take the exclusive lock
- 	 * for other reasons in xfs_file_aio_write_checks.
+ 	 * If we are doing unaligned IO, we can't allow any other overlapping IO
+ 	 * in-flight at the same time or we risk data corruption. Wait for all
+ 	 * other IO to drain before we submit. If the IO is aligned, demote the
+ 	 * iolock if we had to take the exclusive lock in
+ 	 * xfs_file_aio_write_checks() for other reasons.
  	 */
++<<<<<<< HEAD
 +	if (unaligned_io)
 +		inode_dio_wait(inode);
 +	else if (iolock == XFS_IOLOCK_EXCL) {
 +		xfs_rw_ilock_demote(ip, XFS_IOLOCK_EXCL);
++=======
+ 	if (unaligned_io) {
+ 		/* unaligned dio always waits, bail */
+ 		if (iocb->ki_flags & IOCB_NOWAIT)
+ 			return -EAGAIN;
+ 		inode_dio_wait(inode);
+ 	} else if (iolock == XFS_IOLOCK_EXCL) {
+ 		xfs_ilock_demote(ip, XFS_IOLOCK_EXCL);
++>>>>>>> 2032a8a27b5c (xfs: serialize unaligned dio writes against all other dio writes)
  		iolock = XFS_IOLOCK_SHARED;
  	}
  
  	trace_xfs_file_direct_write(ip, count, iocb->ki_pos);
++<<<<<<< HEAD
 +
 +	if (count != ocount)
 +		nr_segs = iov_shorten((struct iovec *)iovp, nr_segs, count);
 +
 +	ret = __blockdev_direct_IO(WRITE, iocb, inode, target->bt_bdev, iovp,
 +			pos, nr_segs, xfs_get_blocks_direct, xfs_end_io_direct_write,
 +			NULL, DIO_ASYNC_EXTEND);
 +
 +	/* see generic_file_direct_write() for why this is necessary */
 +	if (mapping->nrpages) {
 +		invalidate_inode_pages2_range(mapping,
 +					      pos >> PAGE_CACHE_SHIFT,
 +					      end >> PAGE_CACHE_SHIFT);
 +	}
 +
 +	if (ret > 0) {
 +		pos += ret;
 +		iocb->ki_pos = pos;
 +	}
 +
++=======
+ 	ret = iomap_dio_rw(iocb, from, &xfs_iomap_ops, xfs_dio_write_end_io);
+ 
+ 	/*
+ 	 * If unaligned, this is the only IO in-flight. If it has not yet
+ 	 * completed, wait on it before we release the iolock to prevent
+ 	 * subsequent overlapping IO.
+ 	 */
+ 	if (ret == -EIOCBQUEUED && unaligned_io)
+ 		inode_dio_wait(inode);
++>>>>>>> 2032a8a27b5c (xfs: serialize unaligned dio writes against all other dio writes)
  out:
 -	xfs_iunlock(ip, iolock);
 +	xfs_rw_iunlock(ip, iolock);
  
  	/*
  	 * No fallback to buffered IO on errors for XFS, direct IO will either
* Unmerged path fs/xfs/xfs_file.c
