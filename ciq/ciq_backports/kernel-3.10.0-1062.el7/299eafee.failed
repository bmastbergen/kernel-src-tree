IB/mlx5: Fix memory leak in mlx5_ib_create_flow

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Gustavo A. R. Silva <gustavo@embeddedor.com>
commit 299eafee39a22a9d9a7c19ae592b230bd199f259
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/299eafee.failed

In case memory resources for *ucmd* were allocated, release them
before return.

Addresses-Coverity-ID: 1469857 ("Resource leak")
Fixes: 3b3233fbf02e ("IB/mlx5: Add flow counters binding support")
	Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 299eafee39a22a9d9a7c19ae592b230bd199f259)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index 1726b9447b75,f93b30060ca7..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -3223,12 -3517,43 +3223,47 @@@ static struct ib_flow *mlx5_ib_create_f
  	int err;
  	int underlay_qpn;
  
++<<<<<<< HEAD
 +	if (udata &&
 +	    udata->inlen && !ib_is_udata_cleared(udata, 0, udata->inlen))
 +		return ERR_PTR(-EOPNOTSUPP);
++=======
+ 	if (udata && udata->inlen) {
+ 		min_ucmd_sz = offsetof(typeof(ucmd_hdr), reserved) +
+ 				sizeof(ucmd_hdr.reserved);
+ 		if (udata->inlen < min_ucmd_sz)
+ 			return ERR_PTR(-EOPNOTSUPP);
+ 
+ 		err = ib_copy_from_udata(&ucmd_hdr, udata, min_ucmd_sz);
+ 		if (err)
+ 			return ERR_PTR(err);
  
- 	if (flow_attr->priority > MLX5_IB_FLOW_LAST_PRIO)
- 		return ERR_PTR(-ENOMEM);
+ 		/* currently supports only one counters data */
+ 		if (ucmd_hdr.ncounters_data > 1)
+ 			return ERR_PTR(-EINVAL);
+ 
+ 		required_ucmd_sz = min_ucmd_sz +
+ 			sizeof(struct mlx5_ib_flow_counters_data) *
+ 			ucmd_hdr.ncounters_data;
+ 		if (udata->inlen > required_ucmd_sz &&
+ 		    !ib_is_udata_cleared(udata, required_ucmd_sz,
+ 					 udata->inlen - required_ucmd_sz))
+ 			return ERR_PTR(-EOPNOTSUPP);
+ 
+ 		ucmd = kzalloc(required_ucmd_sz, GFP_KERNEL);
+ 		if (!ucmd)
+ 			return ERR_PTR(-ENOMEM);
+ 
+ 		err = ib_copy_from_udata(ucmd, udata, required_ucmd_sz);
+ 		if (err)
+ 			goto free_ucmd;
+ 	}
++>>>>>>> 299eafee39a2 (IB/mlx5: Fix memory leak in mlx5_ib_create_flow)
+ 
+ 	if (flow_attr->priority > MLX5_IB_FLOW_LAST_PRIO) {
+ 		err = -ENOMEM;
+ 		goto free_ucmd;
+ 	}
  
  	if (domain != IB_FLOW_DOMAIN_USER ||
  	    flow_attr->port > dev->num_ports ||
@@@ -3238,14 -3565,18 +3275,18 @@@
  
  	if (is_egress &&
  	    (flow_attr->type == IB_FLOW_ATTR_ALL_DEFAULT ||
- 	     flow_attr->type == IB_FLOW_ATTR_MC_DEFAULT))
- 		return ERR_PTR(-EINVAL);
+ 	     flow_attr->type == IB_FLOW_ATTR_MC_DEFAULT)) {
+ 		err = -EINVAL;
+ 		goto free_ucmd;
+ 	}
  
  	dst = kzalloc(sizeof(*dst), GFP_KERNEL);
- 	if (!dst)
- 		return ERR_PTR(-ENOMEM);
+ 	if (!dst) {
+ 		err = -ENOMEM;
+ 		goto free_ucmd;
+ 	}
  
 -	mutex_lock(&dev->flow_db->lock);
 +	mutex_lock(&dev->flow_db.lock);
  
  	ft_prio = get_flow_table(dev, flow_attr,
  				 is_egress ? MLX5_IB_FT_TX : MLX5_IB_FT_RX);
@@@ -3309,9 -3641,10 +3350,14 @@@ destroy_ft
  	if (ft_prio_tx)
  		put_flow_table(dev, ft_prio_tx, false);
  unlock:
 -	mutex_unlock(&dev->flow_db->lock);
 +	mutex_unlock(&dev->flow_db.lock);
  	kfree(dst);
++<<<<<<< HEAD
 +	kfree(handler);
++=======
+ free_ucmd:
+ 	kfree(ucmd);
++>>>>>>> 299eafee39a2 (IB/mlx5: Fix memory leak in mlx5_ib_create_flow)
  	return ERR_PTR(err);
  }
  
* Unmerged path drivers/infiniband/hw/mlx5/main.c
