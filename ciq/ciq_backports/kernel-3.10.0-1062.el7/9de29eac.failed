x86/spectre: Fix an error message

jira LE-1907
cve CVE-2019-11091
cve CVE-2018-12130
cve CVE-2018-12127
cve CVE-2018-12126
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [x86] spectre: Fix an error message (Waiman Long) [1709296 1690335 1690348 1690358] {CVE-2018-12126 CVE-2018-12127 CVE-2018-12130 CVE-2019-11091}
Rebuild_FUZZ: 93.55%
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit 9de29eac8d2189424d81c0d840cd0469aa3d41c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9de29eac.failed

If i == ARRAY_SIZE(mitigation_options) then we accidentally print
garbage from one space beyond the end of the mitigation_options[] array.

	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: David Woodhouse <dwmw@amazon.co.uk>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: KarimAllah Ahmed <karahmed@amazon.de>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: kernel-janitors@vger.kernel.org
Fixes: 9005c6834c0f ("x86/spectre: Simplify spectre_v2 command line parsing")
Link: http://lkml.kernel.org/r/20180214071416.GA26677@mwanda
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 9de29eac8d2189424d81c0d840cd0469aa3d41c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/bugs.c
diff --cc arch/x86/kernel/cpu/bugs.c
index 6ec1d2da76d1,d71c8b54b696..000000000000
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@@ -141,135 -93,52 +141,154 @@@ enum spectre_v2_mitigation_cmd spectre_
  #undef pr_fmt
  #define pr_fmt(fmt)     "Spectre V2 : " fmt
  
 -static enum spectre_v2_mitigation spectre_v2_enabled = SPECTRE_V2_NONE;
 -
 -#ifdef RETPOLINE
 -static bool spectre_v2_bad_module;
 -
 -bool retpoline_module_ok(bool has_retpoline)
 +static inline bool match_option(const char *arg, int arglen, const char *opt)
  {
 -	if (spectre_v2_enabled == SPECTRE_V2_NONE || has_retpoline)
 -		return true;
 +	int len = strlen(opt);
  
 -	pr_err("System may be vulnerable to spectre v2\n");
 -	spectre_v2_bad_module = true;
 -	return false;
 +	return len == arglen && !strncmp(arg, opt, len);
  }
  
 -static inline const char *spectre_v2_module_string(void)
 +static enum spectre_v2_mitigation_cmd spectre_v2_parse_cmdline(void)
  {
 -	return spectre_v2_bad_module ? " - vulnerable module loaded" : "";
 +	char arg[20];
 +	int ret;
 +
++<<<<<<< HEAD
 +	ret = cmdline_find_option(boot_command_line, "spectre_v2", arg,
 +				  sizeof(arg));
 +	if (ret > 0)  {
 +		if (match_option(arg, ret, "off")) {
 +			goto disable;
 +		} else if (match_option(arg, ret, "on")) {
 +			return SPECTRE_V2_CMD_FORCE;
 +		} else if (match_option(arg, ret, "retpoline")) {
 +			return SPECTRE_V2_CMD_RETPOLINE;
 +		} else if (match_option(arg, ret, "retpoline,ibrs_user")) {
 +			return SPECTRE_V2_CMD_RETPOLINE_IBRS_USER;
 +		} else if (match_option(arg, ret, "ibrs")) {
 +			return SPECTRE_V2_CMD_IBRS;
 +		} else if (match_option(arg, ret, "ibrs_always")) {
 +			return SPECTRE_V2_CMD_IBRS_ALWAYS;
 +		} else if (match_option(arg, ret, "auto")) {
++=======
++	if (cmdline_find_option_bool(boot_command_line, "nospectre_v2"))
++		return SPECTRE_V2_CMD_NONE;
++	else {
++		ret = cmdline_find_option(boot_command_line, "spectre_v2", arg, sizeof(arg));
++		if (ret < 0)
++			return SPECTRE_V2_CMD_AUTO;
++
++		for (i = 0; i < ARRAY_SIZE(mitigation_options); i++) {
++			if (!match_option(arg, ret, mitigation_options[i].option))
++				continue;
++			cmd = mitigation_options[i].cmd;
++			break;
++		}
++
++		if (i >= ARRAY_SIZE(mitigation_options)) {
++			pr_err("unknown option (%s). Switching to AUTO select\n", arg);
++>>>>>>> 9de29eac8d21 (x86/spectre: Fix an error message)
 +			return SPECTRE_V2_CMD_AUTO;
 +		}
 +	}
 +
 +	if (!cmdline_find_option_bool(boot_command_line, "nospectre_v2"))
 +		return SPECTRE_V2_CMD_AUTO;
 +disable:
 +	return SPECTRE_V2_CMD_NONE;
  }
 -#else
 -static inline const char *spectre_v2_module_string(void) { return ""; }
 -#endif
  
 -static void __init spec2_print_if_insecure(const char *reason)
 +void __spectre_v2_select_mitigation(void)
  {
 -	if (boot_cpu_has_bug(X86_BUG_SPECTRE_V2))
 -		pr_info("%s selected on command line.\n", reason);
 +	const bool full_retpoline = IS_ENABLED(CONFIG_RETPOLINE) && retp_compiler();
 +	enum spectre_v2_mitigation_cmd cmd = spectre_v2_cmd;
 +
 +	/*
 +	 * If the CPU is not affected and the command line mode is NONE or AUTO
 +	 * then nothing to do.
 +	 */
 +	if (!boot_cpu_has_bug(X86_BUG_SPECTRE_V2) &&
 +	    (cmd == SPECTRE_V2_CMD_NONE || cmd == SPECTRE_V2_CMD_AUTO))
 +		return;
 +
 +	switch (cmd) {
 +	case SPECTRE_V2_CMD_NONE:
 +		return;
 +
 +	case SPECTRE_V2_CMD_FORCE:
 +	case SPECTRE_V2_CMD_AUTO:
 +		if (boot_cpu_has(X86_FEATURE_IBRS_ENHANCED)) {
 +			spec_ctrl_enable_ibrs_enhanced();
 +			return;
 +		}
 +		break;
 +
 +	case SPECTRE_V2_CMD_RETPOLINE:
 +		spec_ctrl_enable_retpoline();
 +		return;
 +
 +	case SPECTRE_V2_CMD_IBRS:
 +		if (spec_ctrl_force_enable_ibrs())
 +			return;
 +		break;
 +
 +	case SPECTRE_V2_CMD_IBRS_ALWAYS:
 +		if (spec_ctrl_enable_ibrs_always() ||
 +		    spec_ctrl_force_enable_ibp_disabled())
 +			return;
 +		break;
 +
 +	case SPECTRE_V2_CMD_RETPOLINE_IBRS_USER:
 +		if (spec_ctrl_enable_retpoline_ibrs_user())
 +			return;
 +		break;
 +	}
 +
 +	if (spec_ctrl_cond_enable_ibrs(full_retpoline))
 +		return;
 +
 +	if (spec_ctrl_cond_enable_ibp_disabled())
 +		return;
 +
 +	spec_ctrl_enable_retpoline();
  }
  
 -static void __init spec2_print_if_secure(const char *reason)
 +void spectre_v2_print_mitigation(void)
  {
 -	if (!boot_cpu_has_bug(X86_BUG_SPECTRE_V2))
 -		pr_info("%s selected on command line.\n", reason);
 +
 +	pr_info("%s\n", spectre_v2_strings[spec_ctrl_get_mitigation()]);
  }
  
 -static inline bool retp_compiler(void)
 +static void __init spectre_v2_select_mitigation(void)
  {
 -	return __is_defined(RETPOLINE);
 +	spectre_v2_cmd = spectre_v2_parse_cmdline();
 +	__spectre_v2_select_mitigation();
 +	spectre_v2_print_mitigation();
  }
  
 -static inline bool match_option(const char *arg, int arglen, const char *opt)
 -{
 -	int len = strlen(opt);
 +#undef pr_fmt
  
 -	return len == arglen && !strncmp(arg, opt, len);
 -}
 +#define pr_fmt(fmt)    "Speculative Store Bypass: " fmt
 +
 +enum ssb_mitigation ssb_mode = SPEC_STORE_BYPASS_NONE;
 +
 +/* The kernel command line selection */
 +enum ssb_mitigation_cmd {
 +	SPEC_STORE_BYPASS_CMD_NONE,
 +	SPEC_STORE_BYPASS_CMD_AUTO,
 +	SPEC_STORE_BYPASS_CMD_ON,
 +	SPEC_STORE_BYPASS_CMD_PRCTL,
 +	SPEC_STORE_BYPASS_CMD_SECCOMP,
 +};
 +
 +static enum ssb_mitigation_cmd ssb_cmd = SPEC_STORE_BYPASS_CMD_NONE;
 +
 +static const char *ssb_strings[] = {
 +	[SPEC_STORE_BYPASS_NONE]	= "Vulnerable",
 +	[SPEC_STORE_BYPASS_DISABLE]	= "Mitigation: Speculative Store Bypass disabled",
 +	[SPEC_STORE_BYPASS_PRCTL]	= "Mitigation: Speculative Store Bypass disabled via prctl",
 +	[SPEC_STORE_BYPASS_SECCOMP]	= "Mitigation: Speculative Store Bypass disabled via prctl and seccomp",
 +};
  
  static const struct {
  	const char *option;
* Unmerged path arch/x86/kernel/cpu/bugs.c
