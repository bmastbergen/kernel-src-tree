autofs: make autofs_expire_direct() static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ian Kent <raven@themaw.net>
commit 5d30517d67e349164838ad039f0f2d09dde15f59
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/5d30517d.failed

autofs_expire_direct() isn't used outside of fs/autofs/expire.c so make it
static.

Link: http://lkml.kernel.org/r/152937732944.21213.11821977712410930973.stgit@pluto.themaw.net
	Signed-off-by: Ian Kent <raven@themaw.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 5d30517d67e349164838ad039f0f2d09dde15f59)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/autofs4/autofs_i.h
#	fs/autofs4/expire.c
diff --cc fs/autofs4/autofs_i.h
index 7e44fa72be46,fe1b62cfc769..000000000000
--- a/fs/autofs4/autofs_i.h
+++ b/fs/autofs4/autofs_i.h
@@@ -140,25 -143,22 +140,40 @@@ static inline int autofs4_oz_mode(struc
  	return sbi->catatonic || task_pgrp(current) == sbi->oz_pgrp;
  }
  
 -struct inode *autofs_get_inode(struct super_block *, umode_t);
 -void autofs_free_ino(struct autofs_info *);
 +struct inode *autofs4_get_inode(struct super_block *, umode_t);
 +void autofs4_free_ino(struct autofs_info *);
  
  /* Expiration */
++<<<<<<< HEAD:fs/autofs4/autofs_i.h
 +int is_autofs4_dentry(struct dentry *);
 +int autofs4_expire_wait(const struct path *path, int rcu_walk);
 +int autofs4_expire_run(struct super_block *, struct vfsmount *,
 +		       struct autofs_sb_info *,
 +		       struct autofs_packet_expire __user *);
 +int autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,
 +			    struct autofs_sb_info *sbi, int when);
 +int autofs4_expire_multi(struct super_block *, struct vfsmount *,
 +			 struct autofs_sb_info *, int __user *);
 +struct dentry *autofs4_expire_direct(struct super_block *sb,
 +				     struct vfsmount *mnt,
 +				     struct autofs_sb_info *sbi, int how);
 +struct dentry *autofs4_expire_indirect(struct super_block *sb,
 +				       struct vfsmount *mnt,
 +				       struct autofs_sb_info *sbi, int how);
++=======
+ int is_autofs_dentry(struct dentry *);
+ int autofs_expire_wait(const struct path *path, int rcu_walk);
+ int autofs_expire_run(struct super_block *, struct vfsmount *,
+ 		      struct autofs_sb_info *,
+ 		      struct autofs_packet_expire __user *);
+ int autofs_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,
+ 			   struct autofs_sb_info *sbi, int when);
+ int autofs_expire_multi(struct super_block *, struct vfsmount *,
+ 			struct autofs_sb_info *, int __user *);
+ struct dentry *autofs_expire_indirect(struct super_block *sb,
+ 				      struct vfsmount *mnt,
+ 				      struct autofs_sb_info *sbi, int how);
++>>>>>>> 5d30517d67e3 (autofs: make autofs_expire_direct() static):fs/autofs/autofs_i.h
  
  /* Device node initialization */
  
diff --cc fs/autofs4/expire.c
index 0f4f1d4ac0bf,64e6eba2c628..000000000000
--- a/fs/autofs4/expire.c
+++ b/fs/autofs4/expire.c
@@@ -292,10 -292,10 +292,17 @@@ static struct dentry *autofs4_check_lea
  }
  
  /* Check if we can expire a direct mount (possibly a tree) */
++<<<<<<< HEAD:fs/autofs4/expire.c
 +struct dentry *autofs4_expire_direct(struct super_block *sb,
 +				     struct vfsmount *mnt,
 +				     struct autofs_sb_info *sbi,
 +				     int how)
++=======
+ static struct dentry *autofs_expire_direct(struct super_block *sb,
+ 					   struct vfsmount *mnt,
+ 					   struct autofs_sb_info *sbi,
+ 					   int how)
++>>>>>>> 5d30517d67e3 (autofs: make autofs_expire_direct() static):fs/autofs/expire.c
  {
  	unsigned long timeout;
  	struct dentry *root = dget(sb->s_root);
* Unmerged path fs/autofs4/autofs_i.h
* Unmerged path fs/autofs4/expire.c
