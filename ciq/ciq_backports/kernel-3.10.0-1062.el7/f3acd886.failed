perf trace: Use perf_evsel__sc_tp_{uint,ptr} for "id"/"args" handling syscalls:* events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [tools] perf trace: Use perf_evsel__sc_tp_{uint, ptr} for "id"/"args" handling syscalls:* events (Jiri Olsa) [1680072]
Rebuild_FUZZ: 99.43%
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit f3acd8869b9badcfd91cf50a2b6242be7b9368e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/f3acd886.failed

Now it looks just about the same as for the trace__sys_{enter,exit}.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: https://lkml.kernel.org/n/tip-y59may7zx1eccnp4m3qm4u0b@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit f3acd8869b9badcfd91cf50a2b6242be7b9368e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-trace.c
diff --cc tools/perf/builtin-trace.c
index 6364109feae1,7232a7302580..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -1676,6 -1690,37 +1676,40 @@@ out_put
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int trace__fprintf_sys_enter(struct trace *trace, struct perf_evsel *evsel,
+ 				    struct perf_sample *sample)
+ {
+ 	struct thread_trace *ttrace;
+ 	struct thread *thread;
+ 	int id = perf_evsel__sc_tp_uint(evsel, id, sample), err = -1;
+ 	struct syscall *sc = trace__syscall_info(trace, evsel, id);
+ 	char msg[1024];
+ 	void *args;
+ 
+ 	if (sc == NULL)
+ 		return -1;
+ 
+ 	thread = machine__findnew_thread(trace->host, sample->pid, sample->tid);
+ 	ttrace = thread__trace(thread, trace->output);
+ 	/*
+ 	 * We need to get ttrace just to make sure it is there when syscall__scnprintf_args()
+ 	 * and the rest of the beautifiers accessing it via struct syscall_arg touches it.
+ 	 */
+ 	if (ttrace == NULL)
+ 		goto out_put;
+ 
+ 	args = perf_evsel__sc_tp_ptr(evsel, args, sample);
+ 	syscall__scnprintf_args(sc, msg, sizeof(msg), args, trace, thread);
+ 	fprintf(trace->output, "%s", msg);
+ 	err = 0;
+ out_put:
+ 	thread__put(thread);
+ 	return err;
+ }
+ 
++>>>>>>> f3acd8869b9b (perf trace: Use perf_evsel__sc_tp_{uint,ptr} for "id"/"args" handling syscalls:* events)
  static int trace__resolve_callchain(struct trace *trace, struct perf_evsel *evsel,
  				    struct perf_sample *sample,
  				    struct callchain_cursor *cursor)
* Unmerged path tools/perf/builtin-trace.c
