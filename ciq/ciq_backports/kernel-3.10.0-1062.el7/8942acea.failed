IB/uverbs: Pass IB_UVERBS_QPF_GRH_REQUIRED to user space

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Artemy Kovalyov <artemyko@mellanox.com>
commit 8942acea3723ff9424dc89350d2ab6e969fdd093
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/8942acea.failed

Userspace also needs to know if the port requires GRHs to properly form
the AVs it creates.

	Signed-off-by: Artemy Kovalyov <artemyko@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit 8942acea3723ff9424dc89350d2ab6e969fdd093)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/rdma/ib_user_ioctl_verbs.h
diff --cc include/uapi/rdma/ib_user_ioctl_verbs.h
index 173629ecc09b,a81d853bf25d..000000000000
--- a/include/uapi/rdma/ib_user_ioctl_verbs.h
+++ b/include/uapi/rdma/ib_user_ioctl_verbs.h
@@@ -40,4 -40,105 +40,108 @@@
  #define RDMA_UAPI_PTR(_type, _name)	__aligned_u64 _name
  #endif
  
++<<<<<<< HEAD
++=======
+ enum ib_uverbs_query_port_cap_flags {
+ 	IB_UVERBS_PCF_SM = 1 << 1,
+ 	IB_UVERBS_PCF_NOTICE_SUP = 1 << 2,
+ 	IB_UVERBS_PCF_TRAP_SUP = 1 << 3,
+ 	IB_UVERBS_PCF_OPT_IPD_SUP = 1 << 4,
+ 	IB_UVERBS_PCF_AUTO_MIGR_SUP = 1 << 5,
+ 	IB_UVERBS_PCF_SL_MAP_SUP = 1 << 6,
+ 	IB_UVERBS_PCF_MKEY_NVRAM = 1 << 7,
+ 	IB_UVERBS_PCF_PKEY_NVRAM = 1 << 8,
+ 	IB_UVERBS_PCF_LED_INFO_SUP = 1 << 9,
+ 	IB_UVERBS_PCF_SM_DISABLED = 1 << 10,
+ 	IB_UVERBS_PCF_SYS_IMAGE_GUID_SUP = 1 << 11,
+ 	IB_UVERBS_PCF_PKEY_SW_EXT_PORT_TRAP_SUP = 1 << 12,
+ 	IB_UVERBS_PCF_EXTENDED_SPEEDS_SUP = 1 << 14,
+ 	IB_UVERBS_PCF_CM_SUP = 1 << 16,
+ 	IB_UVERBS_PCF_SNMP_TUNNEL_SUP = 1 << 17,
+ 	IB_UVERBS_PCF_REINIT_SUP = 1 << 18,
+ 	IB_UVERBS_PCF_DEVICE_MGMT_SUP = 1 << 19,
+ 	IB_UVERBS_PCF_VENDOR_CLASS_SUP = 1 << 20,
+ 	IB_UVERBS_PCF_DR_NOTICE_SUP = 1 << 21,
+ 	IB_UVERBS_PCF_CAP_MASK_NOTICE_SUP = 1 << 22,
+ 	IB_UVERBS_PCF_BOOT_MGMT_SUP = 1 << 23,
+ 	IB_UVERBS_PCF_LINK_LATENCY_SUP = 1 << 24,
+ 	IB_UVERBS_PCF_CLIENT_REG_SUP = 1 << 25,
+ 	/*
+ 	 * IsOtherLocalChangesNoticeSupported is aliased by IP_BASED_GIDS and
+ 	 * is inaccessible
+ 	 */
+ 	IB_UVERBS_PCF_LINK_SPEED_WIDTH_TABLE_SUP = 1 << 27,
+ 	IB_UVERBS_PCF_VENDOR_SPECIFIC_MADS_TABLE_SUP = 1 << 28,
+ 	IB_UVERBS_PCF_MCAST_PKEY_TRAP_SUPPRESSION_SUP = 1 << 29,
+ 	IB_UVERBS_PCF_MCAST_FDB_TOP_SUP = 1 << 30,
+ 	IB_UVERBS_PCF_HIERARCHY_INFO_SUP = 1ULL << 31,
+ 
+ 	/* NOTE this is an internal flag, not an IBA flag */
+ 	IB_UVERBS_PCF_IP_BASED_GIDS = 1 << 26,
+ };
+ 
+ enum ib_uverbs_query_port_flags {
+ 	IB_UVERBS_QPF_GRH_REQUIRED = 1 << 0,
+ };
+ 
+ enum ib_uverbs_flow_action_esp_keymat {
+ 	IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM,
+ };
+ 
+ enum ib_uverbs_flow_action_esp_keymat_aes_gcm_iv_algo {
+ 	IB_UVERBS_FLOW_ACTION_IV_ALGO_SEQ,
+ };
+ 
+ struct ib_uverbs_flow_action_esp_keymat_aes_gcm {
+ 	__aligned_u64	iv;
+ 	__u32		iv_algo; /* Use enum ib_uverbs_flow_action_esp_keymat_aes_gcm_iv_algo */
+ 
+ 	__u32		salt;
+ 	__u32		icv_len;
+ 
+ 	__u32		key_len;
+ 	__u32		aes_key[256 / 32];
+ };
+ 
+ enum ib_uverbs_flow_action_esp_replay {
+ 	IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE,
+ 	IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP,
+ };
+ 
+ struct ib_uverbs_flow_action_esp_replay_bmp {
+ 	__u32	size;
+ };
+ 
+ enum ib_uverbs_flow_action_esp_flags {
+ 	IB_UVERBS_FLOW_ACTION_ESP_FLAGS_INLINE_CRYPTO	= 0UL << 0,	/* Default */
+ 	IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLOAD	= 1UL << 0,
+ 
+ 	IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TUNNEL		= 0UL << 1,	/* Default */
+ 	IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TRANSPORT	= 1UL << 1,
+ 
+ 	IB_UVERBS_FLOW_ACTION_ESP_FLAGS_DECRYPT		= 0UL << 2,	/* Default */
+ 	IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ENCRYPT		= 1UL << 2,
+ 
+ 	IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW	= 1UL << 3,
+ };
+ 
+ struct ib_uverbs_flow_action_esp_encap {
+ 	/* This struct represents a list of pointers to flow_xxxx_filter that
+ 	 * encapsulates the payload in ESP tunnel mode.
+ 	 */
+ 	RDMA_UAPI_PTR(void *, val_ptr); /* pointer to a flow_xxxx_filter */
+ 	RDMA_UAPI_PTR(struct ib_uverbs_flow_action_esp_encap *, next_ptr);
+ 	__u16	len;		/* Len of the filter struct val_ptr points to */
+ 	__u16	type;		/* Use flow_spec_type enum */
+ };
+ 
+ struct ib_uverbs_flow_action_esp {
+ 	__u32		spi;
+ 	__u32		seq;
+ 	__u32		tfc_pad;
+ 	__u32		flags;
+ 	__aligned_u64	hard_limit_pkts;
+ };
+ 
++>>>>>>> 8942acea3723 (IB/uverbs: Pass IB_UVERBS_QPF_GRH_REQUIRED to user space)
  #endif
diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c
index bb6b556a3d12..b38ad89243a8 100644
--- a/drivers/infiniband/core/uverbs_cmd.c
+++ b/drivers/infiniband/core/uverbs_cmd.c
@@ -266,6 +266,9 @@ ssize_t ib_uverbs_query_port(struct ib_uverbs_file *file,
 	resp.qkey_viol_cntr  = attr.qkey_viol_cntr;
 	resp.pkey_tbl_len    = attr.pkey_tbl_len;
 
+	if (rdma_is_grh_required(ib_dev, cmd.port_num))
+		resp.flags |= IB_UVERBS_QPF_GRH_REQUIRED;
+
 	if (rdma_cap_opa_ah(ib_dev, cmd.port_num)) {
 		resp.lid     = OPA_TO_IB_UCAST_LID(attr.lid);
 		resp.sm_lid  = OPA_TO_IB_UCAST_LID(attr.sm_lid);
* Unmerged path include/uapi/rdma/ib_user_ioctl_verbs.h
diff --git a/include/uapi/rdma/ib_user_verbs.h b/include/uapi/rdma/ib_user_verbs.h
index 3bdfac2e012f..28eac0f413a5 100644
--- a/include/uapi/rdma/ib_user_verbs.h
+++ b/include/uapi/rdma/ib_user_verbs.h
@@ -298,7 +298,8 @@ struct ib_uverbs_query_port_resp {
 	__u8  active_speed;
 	__u8  phys_state;
 	__u8  link_layer;
-	__u8  reserved[2];
+	__u8  flags;			/* see ib_uverbs_query_port_flags */
+	__u8  reserved;
 };
 
 struct ib_uverbs_alloc_pd {
