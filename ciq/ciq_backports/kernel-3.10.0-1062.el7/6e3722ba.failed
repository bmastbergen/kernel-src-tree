IB/mlx5: Use the correct commands for UMEM and UCTX allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Yishai Hadas <yishaih@mellanox.com>
commit 6e3722baac048fdf95b867c5ee7e270718e8630d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6e3722ba.failed

During testing the command format was changed to close a security
hole. Revise the driver to use the command format that will actually be
supported in GA firmware.

Both the UMEM and UCTX are intended only for use by the kernel and cannot
be executed using a general command.

Since the UMEM and CTX are not part of the general object the caps bits
were moved to be some log_xxx location in the general HCA caps.

The firmware code was adapted as well to match the above.

Fixes: a8b92ca1b0e5 ("IB/mlx5: Introduce DEVX")
	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Reviewed-by: Achiad Shochat <achiad@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 6e3722baac048fdf95b867c5ee7e270718e8630d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/devx.c
#	include/linux/mlx5/mlx5_ifc.h
diff --cc include/linux/mlx5/mlx5_ifc.h
index 2259a02a35bf,5ae0b0b9914a..000000000000
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@@ -76,6 -76,10 +76,13 @@@ enum 
  };
  
  enum {
++<<<<<<< HEAD
++=======
+ 	MLX5_SHARED_RESOURCE_UID = 0xffff,
+ };
+ 
+ enum {
++>>>>>>> 6e3722baac04 (IB/mlx5: Use the correct commands for UMEM and UCTX allocation)
  	MLX5_CMD_OP_QUERY_HCA_CAP                 = 0x100,
  	MLX5_CMD_OP_QUERY_ADAPTER                 = 0x101,
  	MLX5_CMD_OP_INIT_HCA                      = 0x102,
@@@ -240,6 -253,14 +247,17 @@@
  	MLX5_CMD_OP_FPGA_QUERY_QP                 = 0x962,
  	MLX5_CMD_OP_FPGA_DESTROY_QP               = 0x963,
  	MLX5_CMD_OP_FPGA_QUERY_QP_COUNTERS        = 0x964,
++<<<<<<< HEAD
++=======
+ 	MLX5_CMD_OP_CREATE_GENERAL_OBJECT         = 0xa00,
+ 	MLX5_CMD_OP_MODIFY_GENERAL_OBJECT         = 0xa01,
+ 	MLX5_CMD_OP_QUERY_GENERAL_OBJECT          = 0xa02,
+ 	MLX5_CMD_OP_DESTROY_GENERAL_OBJECT        = 0xa03,
+ 	MLX5_CMD_OP_CREATE_UCTX                   = 0xa04,
+ 	MLX5_CMD_OP_DESTROY_UCTX                  = 0xa06,
+ 	MLX5_CMD_OP_CREATE_UMEM                   = 0xa08,
+ 	MLX5_CMD_OP_DESTROY_UMEM                  = 0xa0a,
++>>>>>>> 6e3722baac04 (IB/mlx5: Use the correct commands for UMEM and UCTX allocation)
  	MLX5_CMD_OP_MAX
  };
  
@@@ -1115,7 -1181,15 +1133,19 @@@ struct mlx5_ifc_cmd_hca_cap_bits 
  	u8         reserved_at_3f8[0x3];
  	u8         log_max_current_uc_list[0x5];
  
++<<<<<<< HEAD
 +	u8         reserved_at_400[0x80];
++=======
+ 	u8         general_obj_types[0x40];
+ 
+ 	u8         reserved_at_440[0x20];
+ 
+ 	u8         reserved_at_460[0x3];
+ 	u8         log_max_uctx[0x5];
+ 	u8         reserved_at_468[0x3];
+ 	u8         log_max_umem[0x5];
+ 	u8         max_num_eqs[0x10];
++>>>>>>> 6e3722baac04 (IB/mlx5: Use the correct commands for UMEM and UCTX allocation)
  
  	u8         reserved_at_480[0x3];
  	u8         log_max_l2_table[0x5];
@@@ -9069,4 -9320,193 +9099,196 @@@ struct mlx5_ifc_destroy_vport_lag_in_bi
  	u8         reserved_at_40[0x40];
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5_ifc_alloc_memic_in_bits {
+ 	u8         opcode[0x10];
+ 	u8         reserved_at_10[0x10];
+ 
+ 	u8         reserved_at_20[0x10];
+ 	u8         op_mod[0x10];
+ 
+ 	u8         reserved_at_30[0x20];
+ 
+ 	u8	   reserved_at_40[0x18];
+ 	u8	   log_memic_addr_alignment[0x8];
+ 
+ 	u8         range_start_addr[0x40];
+ 
+ 	u8         range_size[0x20];
+ 
+ 	u8         memic_size[0x20];
+ };
+ 
+ struct mlx5_ifc_alloc_memic_out_bits {
+ 	u8         status[0x8];
+ 	u8         reserved_at_8[0x18];
+ 
+ 	u8         syndrome[0x20];
+ 
+ 	u8         memic_start_addr[0x40];
+ };
+ 
+ struct mlx5_ifc_dealloc_memic_in_bits {
+ 	u8         opcode[0x10];
+ 	u8         reserved_at_10[0x10];
+ 
+ 	u8         reserved_at_20[0x10];
+ 	u8         op_mod[0x10];
+ 
+ 	u8         reserved_at_40[0x40];
+ 
+ 	u8         memic_start_addr[0x40];
+ 
+ 	u8         memic_size[0x20];
+ 
+ 	u8         reserved_at_e0[0x20];
+ };
+ 
+ struct mlx5_ifc_dealloc_memic_out_bits {
+ 	u8         status[0x8];
+ 	u8         reserved_at_8[0x18];
+ 
+ 	u8         syndrome[0x20];
+ 
+ 	u8         reserved_at_40[0x40];
+ };
+ 
+ struct mlx5_ifc_general_obj_in_cmd_hdr_bits {
+ 	u8         opcode[0x10];
+ 	u8         uid[0x10];
+ 
+ 	u8         reserved_at_20[0x10];
+ 	u8         obj_type[0x10];
+ 
+ 	u8         obj_id[0x20];
+ 
+ 	u8         reserved_at_60[0x20];
+ };
+ 
+ struct mlx5_ifc_general_obj_out_cmd_hdr_bits {
+ 	u8         status[0x8];
+ 	u8         reserved_at_8[0x18];
+ 
+ 	u8         syndrome[0x20];
+ 
+ 	u8         obj_id[0x20];
+ 
+ 	u8         reserved_at_60[0x20];
+ };
+ 
+ struct mlx5_ifc_umem_bits {
+ 	u8         reserved_at_0[0x80];
+ 
+ 	u8         reserved_at_80[0x1b];
+ 	u8         log_page_size[0x5];
+ 
+ 	u8         page_offset[0x20];
+ 
+ 	u8         num_of_mtt[0x40];
+ 
+ 	struct mlx5_ifc_mtt_bits  mtt[0];
+ };
+ 
+ struct mlx5_ifc_uctx_bits {
+ 	u8         cap[0x20];
+ 
+ 	u8         reserved_at_20[0x160];
+ };
+ 
+ struct mlx5_ifc_create_umem_in_bits {
+ 	u8         opcode[0x10];
+ 	u8         uid[0x10];
+ 
+ 	u8         reserved_at_20[0x10];
+ 	u8         op_mod[0x10];
+ 
+ 	u8         reserved_at_40[0x40];
+ 
+ 	struct mlx5_ifc_umem_bits  umem;
+ };
+ 
+ struct mlx5_ifc_create_uctx_in_bits {
+ 	u8         opcode[0x10];
+ 	u8         reserved_at_10[0x10];
+ 
+ 	u8         reserved_at_20[0x10];
+ 	u8         op_mod[0x10];
+ 
+ 	u8         reserved_at_40[0x40];
+ 
+ 	struct mlx5_ifc_uctx_bits  uctx;
+ };
+ 
+ struct mlx5_ifc_destroy_uctx_in_bits {
+ 	u8         opcode[0x10];
+ 	u8         reserved_at_10[0x10];
+ 
+ 	u8         reserved_at_20[0x10];
+ 	u8         op_mod[0x10];
+ 
+ 	u8         reserved_at_40[0x10];
+ 	u8         uid[0x10];
+ 
+ 	u8         reserved_at_60[0x20];
+ };
+ 
+ struct mlx5_ifc_mtrc_string_db_param_bits {
+ 	u8         string_db_base_address[0x20];
+ 
+ 	u8         reserved_at_20[0x8];
+ 	u8         string_db_size[0x18];
+ };
+ 
+ struct mlx5_ifc_mtrc_cap_bits {
+ 	u8         trace_owner[0x1];
+ 	u8         trace_to_memory[0x1];
+ 	u8         reserved_at_2[0x4];
+ 	u8         trc_ver[0x2];
+ 	u8         reserved_at_8[0x14];
+ 	u8         num_string_db[0x4];
+ 
+ 	u8         first_string_trace[0x8];
+ 	u8         num_string_trace[0x8];
+ 	u8         reserved_at_30[0x28];
+ 
+ 	u8         log_max_trace_buffer_size[0x8];
+ 
+ 	u8         reserved_at_60[0x20];
+ 
+ 	struct mlx5_ifc_mtrc_string_db_param_bits string_db_param[8];
+ 
+ 	u8         reserved_at_280[0x180];
+ };
+ 
+ struct mlx5_ifc_mtrc_conf_bits {
+ 	u8         reserved_at_0[0x1c];
+ 	u8         trace_mode[0x4];
+ 	u8         reserved_at_20[0x18];
+ 	u8         log_trace_buffer_size[0x8];
+ 	u8         trace_mkey[0x20];
+ 	u8         reserved_at_60[0x3a0];
+ };
+ 
+ struct mlx5_ifc_mtrc_stdb_bits {
+ 	u8         string_db_index[0x4];
+ 	u8         reserved_at_4[0x4];
+ 	u8         read_size[0x18];
+ 	u8         start_offset[0x20];
+ 	u8         string_db_data[0];
+ };
+ 
+ struct mlx5_ifc_mtrc_ctrl_bits {
+ 	u8         trace_status[0x2];
+ 	u8         reserved_at_2[0x2];
+ 	u8         arm_event[0x1];
+ 	u8         reserved_at_5[0xb];
+ 	u8         modify_field_select[0x10];
+ 	u8         reserved_at_20[0x2b];
+ 	u8         current_timestamp52_32[0x15];
+ 	u8         current_timestamp31_0[0x20];
+ 	u8         reserved_at_80[0x180];
+ };
+ 
++>>>>>>> 6e3722baac04 (IB/mlx5: Use the correct commands for UMEM and UCTX allocation)
  #endif /* MLX5_IFC_H */
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path include/linux/mlx5/mlx5_ifc.h
