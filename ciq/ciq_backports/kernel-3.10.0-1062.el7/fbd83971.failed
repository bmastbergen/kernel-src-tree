usb: usbtmc: Add ioctl for EOM bit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [usb] usbtmc: Add ioctl for EOM bit (Torez Smith) [1657401]
Rebuild_FUZZ: 92.06%
commit-author Guido Kiener <guido@kiener-muenchen.de>
commit fbd83971f9429849dd3a105b663822d15b7b992b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/fbd83971.failed

add USBTMC_IOCTL_EOM_ENABLE to specify EOM bit for next write()
call. Sets Bit 0 of field 'bmTransferAttributes' of DEV_DEP_MSG_OUT
Bulk-OUT Header.
Allows fine grained control over end of message handling on a
per file descriptor basis.

	Reviewed-by: Steve Bayless <steve_bayless@keysight.com>
	Tested-by: Dave Penkler <dpenkler@gmail.com>
	Signed-off-by: Dave Penkler <dpenkler@gmail.com>
	Signed-off-by: Guido Kiener <guido.kiener@rohde-schwarz.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit fbd83971f9429849dd3a105b663822d15b7b992b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/class/usbtmc.c
#	include/uapi/linux/usb/tmc.h
diff --cc drivers/usb/class/usbtmc.c
index 771a590617dc,c77e0ac6260b..000000000000
--- a/drivers/usb/class/usbtmc.c
+++ b/drivers/usb/class/usbtmc.c
@@@ -107,6 -109,20 +107,22 @@@ struct usbtmc_device_data 
  };
  #define to_usbtmc_data(d) container_of(d, struct usbtmc_device_data, kref)
  
++<<<<<<< HEAD
++=======
+ /*
+  * This structure holds private data for each USBTMC file handle.
+  */
+ struct usbtmc_file_data {
+ 	struct usbtmc_device_data *data;
+ 	struct list_head file_elem;
+ 
+ 	u32            timeout;
+ 	u8             srq_byte;
+ 	atomic_t       srq_asserted;
+ 	u8             eom_val;
+ };
+ 
++>>>>>>> fbd83971f942 (usb: usbtmc: Add ioctl for EOM bit)
  /* Forward declarations */
  static struct usb_driver usbtmc_driver;
  
@@@ -134,10 -154,22 +150,25 @@@ static int usbtmc_open(struct inode *in
  	/* Protect reference to data from file structure until release */
  	kref_get(&data->kref);
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&data->io_mutex);
+ 	file_data->data = data;
+ 
+ 	file_data->timeout = USBTMC_TIMEOUT;
+ 	file_data->eom_val = 1;
+ 
+ 	INIT_LIST_HEAD(&file_data->file_elem);
+ 	spin_lock_irq(&data->dev_lock);
+ 	list_add_tail(&file_data->file_elem, &data->file_list);
+ 	spin_unlock_irq(&data->dev_lock);
+ 	mutex_unlock(&data->io_mutex);
+ 
++>>>>>>> fbd83971f942 (usb: usbtmc: Add ioctl for EOM bit)
  	/* Store pointer in file structure's private data field */
 -	filp->private_data = file_data;
 +	filp->private_data = data;
  
 -	return 0;
 +	return retval;
  }
  
  static int usbtmc_release(struct inode *inode, struct file *file)
@@@ -1183,8 -1244,63 +1214,65 @@@ exit
  	return rv;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Get the usb timeout value
+  */
+ static int usbtmc_ioctl_get_timeout(struct usbtmc_file_data *file_data,
+ 				void __user *arg)
+ {
+ 	u32 timeout;
+ 
+ 	timeout = file_data->timeout;
+ 
+ 	return put_user(timeout, (__u32 __user *)arg);
+ }
+ 
+ /*
+  * Set the usb timeout value
+  */
+ static int usbtmc_ioctl_set_timeout(struct usbtmc_file_data *file_data,
+ 				void __user *arg)
+ {
+ 	u32 timeout;
+ 
+ 	if (get_user(timeout, (__u32 __user *)arg))
+ 		return -EFAULT;
+ 
+ 	/* Note that timeout = 0 means
+ 	 * MAX_SCHEDULE_TIMEOUT in usb_control_msg
+ 	 */
+ 	if (timeout < USBTMC_MIN_TIMEOUT)
+ 		return -EINVAL;
+ 
+ 	file_data->timeout = timeout;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * enables/disables sending EOM on write
+  */
+ static int usbtmc_ioctl_eom_enable(struct usbtmc_file_data *file_data,
+ 				void __user *arg)
+ {
+ 	u8 eom_enable;
+ 
+ 	if (copy_from_user(&eom_enable, arg, sizeof(eom_enable)))
+ 		return -EFAULT;
+ 
+ 	if (eom_enable > 1)
+ 		return -EINVAL;
+ 
+ 	file_data->eom_val = eom_enable;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> fbd83971f942 (usb: usbtmc: Add ioctl for EOM bit)
  static long usbtmc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
  {
 -	struct usbtmc_file_data *file_data;
  	struct usbtmc_device_data *data;
  	int retval = -EBADRQC;
  
@@@ -1220,6 -1338,21 +1308,24 @@@
  		retval = usbtmc_ioctl_abort_bulk_in(data);
  		break;
  
++<<<<<<< HEAD
++=======
+ 	case USBTMC_IOCTL_GET_TIMEOUT:
+ 		retval = usbtmc_ioctl_get_timeout(file_data,
+ 						  (void __user *)arg);
+ 		break;
+ 
+ 	case USBTMC_IOCTL_SET_TIMEOUT:
+ 		retval = usbtmc_ioctl_set_timeout(file_data,
+ 						  (void __user *)arg);
+ 		break;
+ 
+ 	case USBTMC_IOCTL_EOM_ENABLE:
+ 		retval = usbtmc_ioctl_eom_enable(file_data,
+ 						 (void __user *)arg);
+ 		break;
+ 
++>>>>>>> fbd83971f942 (usb: usbtmc: Add ioctl for EOM bit)
  	case USBTMC488_IOCTL_GET_CAPS:
  		retval = copy_to_user((void __user *)arg,
  				&data->usb488_caps,
diff --cc include/uapi/linux/usb/tmc.h
index 6b0a5bf45da8,e7317dfdd2ae..000000000000
--- a/include/uapi/linux/usb/tmc.h
+++ b/include/uapi/linux/usb/tmc.h
@@@ -46,6 -48,10 +46,13 @@@
  #define USBTMC_IOCTL_ABORT_BULK_IN	_IO(USBTMC_IOC_NR, 4)
  #define USBTMC_IOCTL_CLEAR_OUT_HALT	_IO(USBTMC_IOC_NR, 6)
  #define USBTMC_IOCTL_CLEAR_IN_HALT	_IO(USBTMC_IOC_NR, 7)
++<<<<<<< HEAD
++=======
+ #define USBTMC_IOCTL_GET_TIMEOUT	_IOR(USBTMC_IOC_NR, 9, __u32)
+ #define USBTMC_IOCTL_SET_TIMEOUT	_IOW(USBTMC_IOC_NR, 10, __u32)
+ #define USBTMC_IOCTL_EOM_ENABLE	        _IOW(USBTMC_IOC_NR, 11, __u8)
+ 
++>>>>>>> fbd83971f942 (usb: usbtmc: Add ioctl for EOM bit)
  #define USBTMC488_IOCTL_GET_CAPS	_IOR(USBTMC_IOC_NR, 17, unsigned char)
  #define USBTMC488_IOCTL_READ_STB	_IOR(USBTMC_IOC_NR, 18, unsigned char)
  #define USBTMC488_IOCTL_REN_CONTROL	_IOW(USBTMC_IOC_NR, 19, unsigned char)
* Unmerged path drivers/usb/class/usbtmc.c
* Unmerged path include/uapi/linux/usb/tmc.h
