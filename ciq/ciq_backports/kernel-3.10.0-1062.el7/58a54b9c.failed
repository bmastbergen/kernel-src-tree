net: ena: fix crash during ena_remove()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] ena: fix crash during ena_remove() (John Linville) [1633418]
Rebuild_FUZZ: 93.15%
commit-author Arthur Kiyanovski <akiyano@amazon.com>
commit 58a54b9c62e206b8d5f6e59020bcb178fc271d8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/58a54b9c.failed

In ena_remove() we have the following stack call:
ena_remove()
  unregister_netdev()
  ena_destroy_device()
    netif_carrier_off()

Calling netif_carrier_off() causes linkwatch to try to handle the
link change event on the already unregistered netdev, which leads
to a read from an unreadable memory address.

This patch switches the order of the two functions, so that
netif_carrier_off() is called on a regiestered netdev.

To accomplish this fix we also had to:
1. Remove the set bit ENA_FLAG_TRIGGER_RESET
2. Add a sanitiy check in ena_close()
both to prevent double device reset (when calling unregister_netdev()
ena_close is called, but the device was already deleted in
ena_destroy_device()).
3. Set the admin_queue running state to false to avoid using it after
device was reset (for example when calling ena_destroy_all_io_queues()
right after ena_com_dev_reset() in ena_down)

Fixes: 944b28aa2982 ("net: ena: fix missing lock during device destruction")
	Signed-off-by: Arthur Kiyanovski <akiyano@amazon.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 58a54b9c62e206b8d5f6e59020bcb178fc271d8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amazon/ena/ena_netdev.c
diff --cc drivers/net/ethernet/amazon/ena/ena_netdev.c
index c9fb38254854,a70bb1bb90e7..000000000000
--- a/drivers/net/ethernet/amazon/ena/ena_netdev.c
+++ b/drivers/net/ethernet/amazon/ena/ena_netdev.c
@@@ -2618,10 -2617,8 +2623,15 @@@ static void ena_destroy_device(struct e
  	if (test_bit(ENA_FLAG_DEV_UP, &adapter->flags))
  		ena_down(adapter);
  
++<<<<<<< HEAD
 +	/* Before releasing the ENA resources, a device reset is required.
 +	 * (to prevent the device from accessing them).
 +	 * In case the reset flag is set and the device is up, ena_down()
 +	 * already perform the reset, so it can be skipped.
++=======
+ 	/* Stop the device from sending AENQ events (in case reset flag is set
+ 	 *  and device is up, ena_down() already reset the device.
++>>>>>>> 58a54b9c62e2 (net: ena: fix crash during ena_remove())
  	 */
  	if (!(test_bit(ENA_FLAG_TRIGGER_RESET, &adapter->flags) && dev_up))
  		ena_com_dev_reset(adapter->ena_dev, adapter->reset_reason);
* Unmerged path drivers/net/ethernet/amazon/ena/ena_netdev.c
