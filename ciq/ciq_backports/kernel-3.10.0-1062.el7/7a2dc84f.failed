ALSA: hda/ca0132 - Fix input effect controls for desktop cards

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit 7a2dc84fc480aec4f8f96e152327423014edf668
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7a2dc84f.failed

This patch removes the echo cancellation control for desktop cards, and
makes use of the special 0x47 SCP command for noise reduction.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 7a2dc84fc480aec4f8f96e152327423014edf668)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index e10b8cea0b28,1a13ceae261e..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -3530,17 -4855,554 +3530,60 @@@ static int ca0132_effects_set(struct hd
  		/* Voice Focus applies to 2-ch Mic, Digital Mic */
  		if ((nid == VOICE_FOCUS) && (spec->cur_mic_type != DIGITAL_MIC))
  			val = 0;
++<<<<<<< HEAD
++=======
+ 
+ 		/* If Voice Focus on SBZ, set to two channel. */
+ 		if ((nid == VOICE_FOCUS) && (spec->use_pci_mmio)
+ 				&& (spec->cur_mic_type != REAR_LINE_IN)) {
+ 			if (spec->effects_switch[CRYSTAL_VOICE -
+ 						 EFFECT_START_NID]) {
+ 
+ 				if (spec->effects_switch[VOICE_FOCUS -
+ 							 EFFECT_START_NID]) {
+ 					tmp = FLOAT_TWO;
+ 					val = 1;
+ 				} else
+ 					tmp = FLOAT_ONE;
+ 
+ 				dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 			}
+ 		}
+ 		/*
+ 		 * For SBZ noise reduction, there's an extra command
+ 		 * to module ID 0x47. No clue why.
+ 		 */
+ 		if ((nid == NOISE_REDUCTION) && (spec->use_pci_mmio)
+ 				&& (spec->cur_mic_type != REAR_LINE_IN)) {
 -			if (spec->effects_switch[CRYSTAL_VOICE -
 -						 EFFECT_START_NID]) {
 -				if (spec->effects_switch[NOISE_REDUCTION -
 -							 EFFECT_START_NID])
 -					tmp = FLOAT_ONE;
 -				else
 -					tmp = FLOAT_ZERO;
 -			} else
 -				tmp = FLOAT_ZERO;
 -
 -			dspio_set_uint_param(codec, 0x47, 0x00, tmp);
 -		}
 -
 -		/* If rear line in disable effects. */
 -		if (spec->use_alt_functions &&
 -				spec->in_enum_val == REAR_LINE_IN)
 -			val = 0;
 -	}
 -
 -	codec_dbg(codec, "ca0132_effect_set: nid=0x%x, val=%ld\n",
 -		    nid, val);
 -
 -	on = (val == 0) ? FLOAT_ZERO : FLOAT_ONE;
 -	err = dspio_set_uint_param(codec, ca0132_effects[idx].mid,
 -				   ca0132_effects[idx].reqs[0], on);
 -
 -	if (err < 0)
 -		return 0; /* no changed */
 -
 -	return 1;
 -}
 -
 -/*
 - * Turn on/off Playback Enhancements
 - */
 -static int ca0132_pe_switch_set(struct hda_codec *codec)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -	hda_nid_t nid;
 -	int i, ret = 0;
 -
 -	codec_dbg(codec, "ca0132_pe_switch_set: val=%ld\n",
 -		    spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID]);
 -
 -	if (spec->use_alt_functions)
 -		ca0132_alt_select_out(codec);
 -
 -	i = OUT_EFFECT_START_NID - EFFECT_START_NID;
 -	nid = OUT_EFFECT_START_NID;
 -	/* PE affects all out effects */
 -	for (; nid < OUT_EFFECT_END_NID; nid++, i++)
 -		ret |= ca0132_effects_set(codec, nid, spec->effects_switch[i]);
 -
 -	return ret;
 -}
 -
 -/* Check if Mic1 is streaming, if so, stop streaming */
 -static int stop_mic1(struct hda_codec *codec)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -	unsigned int oldval = snd_hda_codec_read(codec, spec->adcs[0], 0,
 -						 AC_VERB_GET_CONV, 0);
 -	if (oldval != 0)
 -		snd_hda_codec_write(codec, spec->adcs[0], 0,
 -				    AC_VERB_SET_CHANNEL_STREAMID,
 -				    0);
 -	return oldval;
 -}
 -
 -/* Resume Mic1 streaming if it was stopped. */
 -static void resume_mic1(struct hda_codec *codec, unsigned int oldval)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -	/* Restore the previous stream and channel */
 -	if (oldval != 0)
 -		snd_hda_codec_write(codec, spec->adcs[0], 0,
 -				    AC_VERB_SET_CHANNEL_STREAMID,
 -				    oldval);
 -}
 -
 -/*
 - * Turn on/off CrystalVoice
 - */
 -static int ca0132_cvoice_switch_set(struct hda_codec *codec)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -	hda_nid_t nid;
 -	int i, ret = 0;
 -	unsigned int oldval;
 -
 -	codec_dbg(codec, "ca0132_cvoice_switch_set: val=%ld\n",
 -		    spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID]);
 -
 -	i = IN_EFFECT_START_NID - EFFECT_START_NID;
 -	nid = IN_EFFECT_START_NID;
 -	/* CrystalVoice affects all in effects */
 -	for (; nid < IN_EFFECT_END_NID; nid++, i++)
 -		ret |= ca0132_effects_set(codec, nid, spec->effects_switch[i]);
 -
 -	/* including VoiceFX */
 -	ret |= ca0132_voicefx_set(codec, (spec->voicefx_val ? 1 : 0));
 -
 -	/* set correct vipsource */
 -	oldval = stop_mic1(codec);
 -	if (spec->use_alt_functions)
 -		ret |= ca0132_alt_set_vipsource(codec, 1);
 -	else
 -		ret |= ca0132_set_vipsource(codec, 1);
 -	resume_mic1(codec, oldval);
 -	return ret;
 -}
 -
 -static int ca0132_mic_boost_set(struct hda_codec *codec, long val)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -	int ret = 0;
 -
 -	if (val) /* on */
 -		ret = snd_hda_codec_amp_update(codec, spec->input_pins[0], 0,
 -					HDA_INPUT, 0, HDA_AMP_VOLMASK, 3);
 -	else /* off */
 -		ret = snd_hda_codec_amp_update(codec, spec->input_pins[0], 0,
 -					HDA_INPUT, 0, HDA_AMP_VOLMASK, 0);
 -
 -	return ret;
 -}
 -
 -static int ca0132_alt_mic_boost_set(struct hda_codec *codec, long val)
 -{
 -	struct ca0132_spec *spec = codec->spec;
 -	int ret = 0;
 -
 -	ret = snd_hda_codec_amp_update(codec, spec->input_pins[0], 0,
 -				HDA_INPUT, 0, HDA_AMP_VOLMASK, val);
 -	return ret;
 -}
 -
 -static int ae5_headphone_gain_set(struct hda_codec *codec, long val)
 -{
 -	unsigned int i;
 -
 -	for (i = 0; i < 4; i++)
 -		ca0113_mmio_command_set(codec, 0x48, 0x11 + i,
 -				ae5_headphone_gain_presets[val].vals[i]);
 -	return 0;
 -}
 -
 -/*
 - * gpio pin 1 is a relay that switches on/off, apparently setting the headphone
 - * amplifier to handle a 600 ohm load.
 - */
 -static int zxr_headphone_gain_set(struct hda_codec *codec, long val)
 -{
 -	ca0113_mmio_gpio_set(codec, 1, val);
 -
 -	return 0;
 -}
 -
 -static int ca0132_vnode_switch_set(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	hda_nid_t nid = get_amp_nid(kcontrol);
 -	hda_nid_t shared_nid = 0;
 -	bool effective;
 -	int ret = 0;
 -	struct ca0132_spec *spec = codec->spec;
 -	int auto_jack;
 -
 -	if (nid == VNID_HP_SEL) {
 -		auto_jack =
 -			spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
 -		if (!auto_jack) {
 -			if (spec->use_alt_functions)
 -				ca0132_alt_select_out(codec);
 -			else
 -				ca0132_select_out(codec);
 -		}
 -		return 1;
 -	}
 -
 -	if (nid == VNID_AMIC1_SEL) {
 -		auto_jack =
 -			spec->vnode_lswitch[VNID_AMIC1_ASEL - VNODE_START_NID];
 -		if (!auto_jack)
 -			ca0132_select_mic(codec);
 -		return 1;
 -	}
 -
 -	if (nid == VNID_HP_ASEL) {
 -		if (spec->use_alt_functions)
 -			ca0132_alt_select_out(codec);
 -		else
 -			ca0132_select_out(codec);
 -		return 1;
 -	}
 -
 -	if (nid == VNID_AMIC1_ASEL) {
 -		ca0132_select_mic(codec);
 -		return 1;
 -	}
 -
 -	/* if effective conditions, then update hw immediately. */
 -	effective = ca0132_is_vnode_effective(codec, nid, &shared_nid);
 -	if (effective) {
 -		int dir = get_amp_direction(kcontrol);
 -		int ch = get_amp_channels(kcontrol);
 -		unsigned long pval;
 -
 -		mutex_lock(&codec->control_mutex);
 -		pval = kcontrol->private_value;
 -		kcontrol->private_value = HDA_COMPOSE_AMP_VAL(shared_nid, ch,
 -								0, dir);
 -		ret = snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);
 -		kcontrol->private_value = pval;
 -		mutex_unlock(&codec->control_mutex);
 -	}
 -
 -	return ret;
 -}
 -/* End of control change helpers. */
 -/*
 - * Below I've added controls to mess with the effect levels, I've only enabled
 - * them on the Sound Blaster Z, but they would probably also work on the
 - * Chromebook. I figured they were probably tuned specifically for it, and left
 - * out for a reason.
 - */
 -
 -/* Sets DSP effect level from the sliders above the controls */
 -static int ca0132_alt_slider_ctl_set(struct hda_codec *codec, hda_nid_t nid,
 -			  const unsigned int *lookup, int idx)
 -{
 -	int i = 0;
 -	unsigned int y;
 -	/*
 -	 * For X_BASS, req 2 is actually crossover freq instead of
 -	 * effect level
 -	 */
 -	if (nid == X_BASS)
 -		y = 2;
 -	else
 -		y = 1;
 -
 -	snd_hda_power_up(codec);
 -	if (nid == XBASS_XOVER) {
 -		for (i = 0; i < OUT_EFFECTS_COUNT; i++)
 -			if (ca0132_effects[i].nid == X_BASS)
 -				break;
 -
 -		dspio_set_param(codec, ca0132_effects[i].mid, 0x20,
 -				ca0132_effects[i].reqs[1],
 -				&(lookup[idx - 1]), sizeof(unsigned int));
 -	} else {
 -		/* Find the actual effect structure */
 -		for (i = 0; i < OUT_EFFECTS_COUNT; i++)
 -			if (nid == ca0132_effects[i].nid)
 -				break;
 -
 -		dspio_set_param(codec, ca0132_effects[i].mid, 0x20,
 -				ca0132_effects[i].reqs[y],
 -				&(lookup[idx]), sizeof(unsigned int));
 -	}
 -
 -	snd_hda_power_down(codec);
 -
 -	return 0;
 -}
 -
 -static int ca0132_alt_xbass_xover_slider_ctl_get(struct snd_kcontrol *kcontrol,
 -			  struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	long *valp = ucontrol->value.integer.value;
 -
 -	*valp = spec->xbass_xover_freq;
 -	return 0;
 -}
 -
 -static int ca0132_alt_slider_ctl_get(struct snd_kcontrol *kcontrol,
 -			  struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	hda_nid_t nid = get_amp_nid(kcontrol);
 -	long *valp = ucontrol->value.integer.value;
 -	int idx = nid - OUT_EFFECT_START_NID;
 -
 -	*valp = spec->fx_ctl_val[idx];
 -	return 0;
 -}
 -
 -/*
 - * The X-bass crossover starts at 10hz, so the min is 1. The
 - * frequency is set in multiples of 10.
 - */
 -static int ca0132_alt_xbass_xover_slider_info(struct snd_kcontrol *kcontrol,
 -		struct snd_ctl_elem_info *uinfo)
 -{
 -	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 -	uinfo->count = 1;
 -	uinfo->value.integer.min = 1;
 -	uinfo->value.integer.max = 100;
 -	uinfo->value.integer.step = 1;
 -
 -	return 0;
 -}
 -
 -static int ca0132_alt_effect_slider_info(struct snd_kcontrol *kcontrol,
 -		struct snd_ctl_elem_info *uinfo)
 -{
 -	int chs = get_amp_channels(kcontrol);
 -
 -	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 -	uinfo->count = chs == 3 ? 2 : 1;
 -	uinfo->value.integer.min = 0;
 -	uinfo->value.integer.max = 100;
 -	uinfo->value.integer.step = 1;
 -
 -	return 0;
 -}
 -
 -static int ca0132_alt_xbass_xover_slider_put(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	hda_nid_t nid = get_amp_nid(kcontrol);
 -	long *valp = ucontrol->value.integer.value;
 -	int idx;
 -
 -	/* any change? */
 -	if (spec->xbass_xover_freq == *valp)
 -		return 0;
 -
 -	spec->xbass_xover_freq = *valp;
 -
 -	idx = *valp;
 -	ca0132_alt_slider_ctl_set(codec, nid, float_xbass_xover_lookup, idx);
 -
 -	return 0;
 -}
 -
 -static int ca0132_alt_effect_slider_put(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	hda_nid_t nid = get_amp_nid(kcontrol);
 -	long *valp = ucontrol->value.integer.value;
 -	int idx;
 -
 -	idx = nid - EFFECT_START_NID;
 -	/* any change? */
 -	if (spec->fx_ctl_val[idx] == *valp)
 -		return 0;
 -
 -	spec->fx_ctl_val[idx] = *valp;
 -
 -	idx = *valp;
 -	ca0132_alt_slider_ctl_set(codec, nid, float_zero_to_one_lookup, idx);
 -
 -	return 0;
 -}
 -
 -
 -/*
 - * Mic Boost Enum for alternative ca0132 codecs. I didn't like that the original
 - * only has off or full 30 dB, and didn't like making a volume slider that has
 - * traditional 0-100 in alsamixer that goes in big steps. I like enum better.
 - */
 -#define MIC_BOOST_NUM_OF_STEPS 4
 -#define MIC_BOOST_ENUM_MAX_STRLEN 10
 -
 -static int ca0132_alt_mic_boost_info(struct snd_kcontrol *kcontrol,
 -				 struct snd_ctl_elem_info *uinfo)
 -{
 -	char *sfx = "dB";
 -	char namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
 -
 -	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 -	uinfo->count = 1;
 -	uinfo->value.enumerated.items = MIC_BOOST_NUM_OF_STEPS;
 -	if (uinfo->value.enumerated.item >= MIC_BOOST_NUM_OF_STEPS)
 -		uinfo->value.enumerated.item = MIC_BOOST_NUM_OF_STEPS - 1;
 -	sprintf(namestr, "%d %s", (uinfo->value.enumerated.item * 10), sfx);
 -	strcpy(uinfo->value.enumerated.name, namestr);
 -	return 0;
 -}
 -
 -static int ca0132_alt_mic_boost_get(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -
 -	ucontrol->value.enumerated.item[0] = spec->mic_boost_enum_val;
 -	return 0;
 -}
 -
 -static int ca0132_alt_mic_boost_put(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	int sel = ucontrol->value.enumerated.item[0];
 -	unsigned int items = MIC_BOOST_NUM_OF_STEPS;
 -
 -	if (sel >= items)
 -		return 0;
 -
 -	codec_dbg(codec, "ca0132_alt_mic_boost: boost=%d\n",
 -		    sel);
 -
 -	spec->mic_boost_enum_val = sel;
 -
 -	if (spec->in_enum_val != REAR_LINE_IN)
 -		ca0132_alt_mic_boost_set(codec, spec->mic_boost_enum_val);
 -
 -	return 1;
 -}
 -
 -/*
 - * Sound BlasterX AE-5 Headphone Gain Controls.
 - */
 -#define AE5_HEADPHONE_GAIN_MAX 3
 -static int ae5_headphone_gain_info(struct snd_kcontrol *kcontrol,
 -				 struct snd_ctl_elem_info *uinfo)
 -{
 -	char *sfx = " Ohms)";
 -	char namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
 -
 -	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 -	uinfo->count = 1;
 -	uinfo->value.enumerated.items = AE5_HEADPHONE_GAIN_MAX;
 -	if (uinfo->value.enumerated.item >= AE5_HEADPHONE_GAIN_MAX)
 -		uinfo->value.enumerated.item = AE5_HEADPHONE_GAIN_MAX - 1;
 -	sprintf(namestr, "%s %s",
 -		ae5_headphone_gain_presets[uinfo->value.enumerated.item].name,
 -		sfx);
 -	strcpy(uinfo->value.enumerated.name, namestr);
 -	return 0;
 -}
 -
 -static int ae5_headphone_gain_get(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -
 -	ucontrol->value.enumerated.item[0] = spec->ae5_headphone_gain_val;
 -	return 0;
 -}
 -
 -static int ae5_headphone_gain_put(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	int sel = ucontrol->value.enumerated.item[0];
 -	unsigned int items = AE5_HEADPHONE_GAIN_MAX;
 -
 -	if (sel >= items)
 -		return 0;
 -
 -	codec_dbg(codec, "ae5_headphone_gain: boost=%d\n",
 -		    sel);
 -
 -	spec->ae5_headphone_gain_val = sel;
 -
 -	if (spec->out_enum_val == HEADPHONE_OUT)
 -		ae5_headphone_gain_set(codec, spec->ae5_headphone_gain_val);
 -
 -	return 1;
 -}
 -
 -/*
 - * Sound BlasterX AE-5 sound filter enumerated control.
 - */
 -#define AE5_SOUND_FILTER_MAX 3
 -
 -static int ae5_sound_filter_info(struct snd_kcontrol *kcontrol,
 -				 struct snd_ctl_elem_info *uinfo)
 -{
 -	char namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
 -
 -	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 -	uinfo->count = 1;
 -	uinfo->value.enumerated.items = AE5_SOUND_FILTER_MAX;
 -	if (uinfo->value.enumerated.item >= AE5_SOUND_FILTER_MAX)
 -		uinfo->value.enumerated.item = AE5_SOUND_FILTER_MAX - 1;
 -	sprintf(namestr, "%s",
 -			ae5_filter_presets[uinfo->value.enumerated.item].name);
 -	strcpy(uinfo->value.enumerated.name, namestr);
 -	return 0;
 -}
 -
 -static int ae5_sound_filter_get(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -
 -	ucontrol->value.enumerated.item[0] = spec->ae5_filter_val;
 -	return 0;
 -}
++			if (spec->effects_switch[CRYSTAL_VOICE -
++						 EFFECT_START_NID]) {
++				if (spec->effects_switch[NOISE_REDUCTION -
++							 EFFECT_START_NID])
++					tmp = FLOAT_ONE;
++				else
++					tmp = FLOAT_ZERO;
++			} else
++				tmp = FLOAT_ZERO;
+ 
 -static int ae5_sound_filter_put(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	int sel = ucontrol->value.enumerated.item[0];
 -	unsigned int items = AE5_SOUND_FILTER_MAX;
++			dspio_set_uint_param(codec, 0x47, 0x00, tmp);
++		}
+ 
 -	if (sel >= items)
 -		return 0;
++		/* If rear line in disable effects. */
++		if (spec->use_alt_functions &&
++				spec->in_enum_val == REAR_LINE_IN)
++			val = 0;
++>>>>>>> 7a2dc84fc480 (ALSA: hda/ca0132 - Fix input effect controls for desktop cards)
 +	}
  
 -	codec_dbg(codec, "ae5_sound_filter: %s\n",
 -			ae5_filter_presets[sel].name);
 +	codec_dbg(codec, "ca0132_effect_set: nid=0x%x, val=%ld\n",
 +		    nid, val);
  
 -	spec->ae5_filter_val = sel;
 +	on = (val == 0) ? FLOAT_ZERO : FLOAT_ONE;
 +	err = dspio_set_uint_param(codec, ca0132_effects[idx].mid,
 +				   ca0132_effects[idx].reqs[0], on);
  
 -	ca0113_mmio_command_set_type2(codec, 0x48, 0x07,
 -			ae5_filter_presets[sel].val);
 +	if (err < 0)
 +		return 0; /* no changed */
  
  	return 1;
  }
@@@ -4061,6 -6374,13 +4104,16 @@@ static int ca0132_build_controls(struc
  	 */
  	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT;
  	for (i = 0; i < num_fx; i++) {
++<<<<<<< HEAD
++=======
+ 		/* Desktop cards break if Echo Cancellation is used. */
+ 		if (spec->use_pci_mmio) {
+ 			if (i == (ECHO_CANCELLATION - IN_EFFECT_START_NID +
+ 						OUT_EFFECTS_COUNT))
+ 				continue;
+ 		}
+ 
++>>>>>>> 7a2dc84fc480 (ALSA: hda/ca0132 - Fix input effect controls for desktop cards)
  		err = add_fx_switch(codec, ca0132_effects[i].nid,
  				    ca0132_effects[i].name,
  				    ca0132_effects[i].direct);
* Unmerged path sound/pci/hda/patch_ca0132.c
