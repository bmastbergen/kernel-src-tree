ALSA: hda/ca0132 - Add ZxR 600 ohm gain control

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit d51434d43a2cbef2a656b780c7ab936105a30aaf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/d51434d4.failed

This patch adds a control for 600 ohm gain on the Sound Blaster ZxR.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit d51434d43a2cbef2a656b780c7ab936105a30aaf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index 5992a3b4cc50,90e6a96b3630..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -127,7 -146,16 +127,20 @@@ enum 
  	VOICEFX = IN_EFFECT_END_NID,
  	PLAY_ENHANCEMENT,
  	CRYSTAL_VOICE,
++<<<<<<< HEAD
 +	EFFECT_END_NID
++=======
+ 	EFFECT_END_NID,
+ 	OUTPUT_SOURCE_ENUM,
+ 	INPUT_SOURCE_ENUM,
+ 	XBASS_XOVER,
+ 	EQ_PRESET_ENUM,
+ 	SMART_VOLUME_ENUM,
+ 	MIC_BOOST_ENUM,
+ 	AE5_HEADPHONE_GAIN_ENUM,
+ 	AE5_SOUND_FILTER_ENUM,
+ 	ZXR_HEADPHONE_GAIN
++>>>>>>> d51434d43a2c (ALSA: hda/ca0132 - Add ZxR 600 ohm gain control)
  #define EFFECTS_COUNT  (EFFECT_END_NID - EFFECT_START_NID)
  };
  
@@@ -753,6 -1019,21 +766,24 @@@ struct ca0132_spec 
  	long effects_switch[EFFECTS_COUNT];
  	long voicefx_val;
  	long cur_mic_boost;
++<<<<<<< HEAD
++=======
+ 	/* ca0132_alt control related values */
+ 	unsigned char in_enum_val;
+ 	unsigned char out_enum_val;
+ 	unsigned char mic_boost_enum_val;
+ 	unsigned char smart_volume_setting;
+ 	long fx_ctl_val[EFFECT_LEVEL_SLIDERS];
+ 	long xbass_xover_freq;
+ 	long eq_preset_val;
+ 	unsigned int tlv[4];
+ 	struct hda_vmaster_mute_hook vmaster_mute;
+ 	/* AE-5 Control values */
+ 	unsigned char ae5_headphone_gain_val;
+ 	unsigned char ae5_filter_val;
+ 	/* ZxR Control Values */
+ 	unsigned char zxr_gain_set;
++>>>>>>> d51434d43a2c (ALSA: hda/ca0132 - Add ZxR 600 ohm gain control)
  
  	struct hda_codec *codec;
  	struct delayed_work unsol_hp_work;
@@@ -3339,6 -4143,301 +3370,304 @@@ exit
  	return err < 0 ? err : 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int ae5_headphone_gain_set(struct hda_codec *codec, long val);
+ static int zxr_headphone_gain_set(struct hda_codec *codec, long val);
+ static int ca0132_effects_set(struct hda_codec *codec, hda_nid_t nid, long val);
+ 
+ static void ae5_mmio_select_out(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < AE5_CA0113_OUT_SET_COMMANDS; i++)
+ 		ca0113_mmio_command_set(codec,
+ 			ae5_ca0113_output_presets[spec->cur_out_type].group[i],
+ 			ae5_ca0113_output_presets[spec->cur_out_type].target[i],
+ 			ae5_ca0113_output_presets[spec->cur_out_type].vals[i]);
+ }
+ 
+ /*
+  * These are the commands needed to setup output on each of the different card
+  * types.
+  */
+ static void ca0132_alt_select_out_quirk_handler(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	switch (spec->cur_out_type) {
+ 	case SPEAKER_OUT:
+ 		switch (spec->quirk) {
+ 		case QUIRK_SBZ:
+ 			ca0113_mmio_gpio_set(codec, 7, false);
+ 			ca0113_mmio_gpio_set(codec, 4, true);
+ 			ca0113_mmio_gpio_set(codec, 1, true);
+ 			chipio_set_control_param(codec, 0x0d, 0x18);
+ 			break;
+ 		case QUIRK_ZXR:
+ 			ca0113_mmio_gpio_set(codec, 2, true);
+ 			ca0113_mmio_gpio_set(codec, 3, true);
+ 			ca0113_mmio_gpio_set(codec, 5, false);
+ 			zxr_headphone_gain_set(codec, 0);
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			break;
+ 		case QUIRK_R3DI:
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			r3di_gpio_out_set(codec, R3DI_LINE_OUT);
+ 			break;
+ 		case QUIRK_R3D:
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			ca0113_mmio_gpio_set(codec, 1, true);
+ 			break;
+ 		case QUIRK_AE5:
+ 			ae5_mmio_select_out(codec);
+ 			ae5_headphone_gain_set(codec, 2);
+ 			tmp = FLOAT_ZERO;
+ 			dspio_set_uint_param(codec, 0x96, 0x29, tmp);
+ 			dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
+ 			chipio_set_control_param(codec, 0x0d, 0xa4);
+ 			chipio_write(codec, 0x18b03c, 0x00000012);
+ 			break;
+ 		}
+ 		break;
+ 	case HEADPHONE_OUT:
+ 		switch (spec->quirk) {
+ 		case QUIRK_SBZ:
+ 			ca0113_mmio_gpio_set(codec, 7, true);
+ 			ca0113_mmio_gpio_set(codec, 4, true);
+ 			ca0113_mmio_gpio_set(codec, 1, false);
+ 			chipio_set_control_param(codec, 0x0d, 0x12);
+ 			break;
+ 		case QUIRK_ZXR:
+ 			ca0113_mmio_gpio_set(codec, 2, false);
+ 			ca0113_mmio_gpio_set(codec, 3, false);
+ 			ca0113_mmio_gpio_set(codec, 5, true);
+ 			zxr_headphone_gain_set(codec, spec->zxr_gain_set);
+ 			chipio_set_control_param(codec, 0x0d, 0x21);
+ 			break;
+ 		case QUIRK_R3DI:
+ 			chipio_set_control_param(codec, 0x0d, 0x21);
+ 			r3di_gpio_out_set(codec, R3DI_HEADPHONE_OUT);
+ 			break;
+ 		case QUIRK_R3D:
+ 			chipio_set_control_param(codec, 0x0d, 0x21);
+ 			ca0113_mmio_gpio_set(codec, 0x1, false);
+ 			break;
+ 		case QUIRK_AE5:
+ 			ae5_mmio_select_out(codec);
+ 			ae5_headphone_gain_set(codec,
+ 					spec->ae5_headphone_gain_val);
+ 			tmp = FLOAT_ONE;
+ 			dspio_set_uint_param(codec, 0x96, 0x29, tmp);
+ 			dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
+ 			chipio_set_control_param(codec, 0x0d, 0xa1);
+ 			chipio_write(codec, 0x18b03c, 0x00000012);
+ 			break;
+ 		}
+ 		break;
+ 	case SURROUND_OUT:
+ 		switch (spec->quirk) {
+ 		case QUIRK_SBZ:
+ 			ca0113_mmio_gpio_set(codec, 7, false);
+ 			ca0113_mmio_gpio_set(codec, 4, true);
+ 			ca0113_mmio_gpio_set(codec, 1, true);
+ 			chipio_set_control_param(codec, 0x0d, 0x18);
+ 			break;
+ 		case QUIRK_ZXR:
+ 			ca0113_mmio_gpio_set(codec, 2, true);
+ 			ca0113_mmio_gpio_set(codec, 3, true);
+ 			ca0113_mmio_gpio_set(codec, 5, false);
+ 			zxr_headphone_gain_set(codec, 0);
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			break;
+ 		case QUIRK_R3DI:
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			r3di_gpio_out_set(codec, R3DI_LINE_OUT);
+ 			break;
+ 		case QUIRK_R3D:
+ 			ca0113_mmio_gpio_set(codec, 1, true);
+ 			chipio_set_control_param(codec, 0x0d, 0x24);
+ 			break;
+ 		case QUIRK_AE5:
+ 			ae5_mmio_select_out(codec);
+ 			ae5_headphone_gain_set(codec, 2);
+ 			tmp = FLOAT_ZERO;
+ 			dspio_set_uint_param(codec, 0x96, 0x29, tmp);
+ 			dspio_set_uint_param(codec, 0x96, 0x2a, tmp);
+ 			chipio_set_control_param(codec, 0x0d, 0xa4);
+ 			chipio_write(codec, 0x18b03c, 0x00000012);
+ 			break;
+ 		}
+ 		break;
+ 	}
+ }
+ 
+ /*
+  * This function behaves similarly to the ca0132_select_out funciton above,
+  * except with a few differences. It adds the ability to select the current
+  * output with an enumerated control "output source" if the auto detect
+  * mute switch is set to off. If the auto detect mute switch is enabled, it
+  * will detect either headphone or lineout(SPEAKER_OUT) from jack detection.
+  * It also adds the ability to auto-detect the front headphone port. The only
+  * way to select surround is to disable auto detect, and set Surround with the
+  * enumerated control.
+  */
+ static int ca0132_alt_select_out(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int pin_ctl;
+ 	int jack_present;
+ 	int auto_jack;
+ 	unsigned int i;
+ 	unsigned int tmp;
+ 	int err;
+ 	/* Default Headphone is rear headphone */
+ 	hda_nid_t headphone_nid = spec->out_pins[1];
+ 
+ 	codec_dbg(codec, "%s\n", __func__);
+ 
+ 	snd_hda_power_up_pm(codec);
+ 
+ 	auto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
+ 
+ 	/*
+ 	 * If headphone rear or front is plugged in, set to headphone.
+ 	 * If neither is plugged in, set to rear line out. Only if
+ 	 * hp/speaker auto detect is enabled.
+ 	 */
+ 	if (auto_jack) {
+ 		jack_present = snd_hda_jack_detect(codec, spec->unsol_tag_hp) ||
+ 			   snd_hda_jack_detect(codec, spec->unsol_tag_front_hp);
+ 
+ 		if (jack_present)
+ 			spec->cur_out_type = HEADPHONE_OUT;
+ 		else
+ 			spec->cur_out_type = SPEAKER_OUT;
+ 	} else
+ 		spec->cur_out_type = spec->out_enum_val;
+ 
+ 	/* Begin DSP output switch */
+ 	tmp = FLOAT_ONE;
+ 	err = dspio_set_uint_param(codec, 0x96, 0x3A, tmp);
+ 	if (err < 0)
+ 		goto exit;
+ 
+ 	ca0132_alt_select_out_quirk_handler(codec);
+ 
+ 	switch (spec->cur_out_type) {
+ 	case SPEAKER_OUT:
+ 		codec_dbg(codec, "%s speaker\n", __func__);
+ 
+ 		/* disable headphone node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[1],
+ 				    pin_ctl & ~PIN_HP);
+ 		/* enable line-out node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
+ 				AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
+ 				    pin_ctl | PIN_OUT);
+ 		/* Enable EAPD */
+ 		snd_hda_codec_write(codec, spec->out_pins[0], 0,
+ 			AC_VERB_SET_EAPD_BTLENABLE, 0x01);
+ 
+ 		/* If PlayEnhancement is enabled, set different source */
+ 		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
+ 		else
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_EIGHT);
+ 		break;
+ 	case HEADPHONE_OUT:
+ 		codec_dbg(codec, "%s hp\n", __func__);
+ 
+ 		snd_hda_codec_write(codec, spec->out_pins[0], 0,
+ 			AC_VERB_SET_EAPD_BTLENABLE, 0x00);
+ 
+ 		/* disable speaker*/
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
+ 				pin_ctl & ~PIN_HP);
+ 
+ 		/* enable headphone, either front or rear */
+ 
+ 		if (snd_hda_jack_detect(codec, spec->unsol_tag_front_hp))
+ 			headphone_nid = spec->out_pins[2];
+ 		else if (snd_hda_jack_detect(codec, spec->unsol_tag_hp))
+ 			headphone_nid = spec->out_pins[1];
+ 
+ 		pin_ctl = snd_hda_codec_read(codec, headphone_nid, 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, headphone_nid,
+ 				    pin_ctl | PIN_HP);
+ 
+ 		if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ONE);
+ 		else
+ 			dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_ZERO);
+ 		break;
+ 	case SURROUND_OUT:
+ 		codec_dbg(codec, "%s surround\n", __func__);
+ 
+ 		/* enable line out node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,
+ 				AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[0],
+ 						pin_ctl | PIN_OUT);
+ 		/* Disable headphone out */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[1],
+ 				    pin_ctl & ~PIN_HP);
+ 		/* Enable EAPD on line out */
+ 		snd_hda_codec_write(codec, spec->out_pins[0], 0,
+ 			AC_VERB_SET_EAPD_BTLENABLE, 0x01);
+ 		/* enable center/lfe out node */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[2], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[2],
+ 				    pin_ctl | PIN_OUT);
+ 		/* Now set rear surround node as out. */
+ 		pin_ctl = snd_hda_codec_read(codec, spec->out_pins[3], 0,
+ 					AC_VERB_GET_PIN_WIDGET_CONTROL, 0);
+ 		snd_hda_set_pin_ctl(codec, spec->out_pins[3],
+ 				    pin_ctl | PIN_OUT);
+ 
+ 		dspio_set_uint_param(codec, 0x80, 0x04, FLOAT_EIGHT);
+ 		break;
+ 	}
+ 	/*
+ 	 * Surround always sets it's scp command to req 0x04 to FLOAT_EIGHT.
+ 	 * With this set though, X_BASS cannot be enabled. So, if we have OutFX
+ 	 * enabled, we need to make sure X_BASS is off, otherwise everything
+ 	 * sounds all muffled. Running ca0132_effects_set with X_BASS as the
+ 	 * effect should sort this out.
+ 	 */
+ 	if (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])
+ 		ca0132_effects_set(codec, X_BASS,
+ 			spec->effects_switch[X_BASS - EFFECT_START_NID]);
+ 
+ 	/* run through the output dsp commands for the selected output. */
+ 	for (i = 0; i < alt_out_presets[spec->cur_out_type].commands; i++) {
+ 		err = dspio_set_uint_param(codec,
+ 		alt_out_presets[spec->cur_out_type].mids[i],
+ 		alt_out_presets[spec->cur_out_type].reqs[i],
+ 		alt_out_presets[spec->cur_out_type].vals[i]);
+ 
+ 		if (err < 0)
+ 			goto exit;
+ 	}
+ 
+ exit:
+ 	snd_hda_power_down_pm(codec);
+ 
+ 	return err < 0 ? err : 0;
+ }
+ 
++>>>>>>> d51434d43a2c (ALSA: hda/ca0132 - Add ZxR 600 ohm gain control)
  static void ca0132_unsol_hp_delayed(struct work_struct *work)
  {
  	struct ca0132_spec *spec = container_of(
@@@ -3634,6 -5005,37 +3963,40 @@@ static int ca0132_mic_boost_set(struct 
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int ca0132_alt_mic_boost_set(struct hda_codec *codec, long val)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	int ret = 0;
+ 
+ 	ret = snd_hda_codec_amp_update(codec, spec->input_pins[0], 0,
+ 				HDA_INPUT, 0, HDA_AMP_VOLMASK, val);
+ 	return ret;
+ }
+ 
+ static int ae5_headphone_gain_set(struct hda_codec *codec, long val)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < 4; i++)
+ 		ca0113_mmio_command_set(codec, 0x48, 0x11 + i,
+ 				ae5_headphone_gain_presets[val].vals[i]);
+ 	return 0;
+ }
+ 
+ /*
+  * gpio pin 1 is a relay that switches on/off, apparently setting the headphone
+  * amplifier to handle a 600 ohm load.
+  */
+ static int zxr_headphone_gain_set(struct hda_codec *codec, long val)
+ {
+ 	ca0113_mmio_gpio_set(codec, 1, val);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> d51434d43a2c (ALSA: hda/ca0132 - Add ZxR 600 ohm gain control)
  static int ca0132_vnode_switch_set(struct snd_kcontrol *kcontrol,
  				struct snd_ctl_elem_value *ucontrol)
  {
@@@ -3794,63 -5227,77 +4157,73 @@@ static int ca0132_switch_put(struct snd
  	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
  	struct ca0132_spec *spec = codec->spec;
  	hda_nid_t nid = get_amp_nid(kcontrol);
 +	int ch = get_amp_channels(kcontrol);
  	long *valp = ucontrol->value.integer.value;
 -	int idx;
 -
 -	idx = nid - EFFECT_START_NID;
 -	/* any change? */
 -	if (spec->fx_ctl_val[idx] == *valp)
 -		return 0;
 -
 -	spec->fx_ctl_val[idx] = *valp;
 -
 -	idx = *valp;
 -	ca0132_alt_slider_ctl_set(codec, nid, float_zero_to_one_lookup, idx);
 -
 -	return 0;
 -}
 -
 +	int changed = 1;
  
 -/*
 - * Mic Boost Enum for alternative ca0132 codecs. I didn't like that the original
 - * only has off or full 30 dB, and didn't like making a volume slider that has
 - * traditional 0-100 in alsamixer that goes in big steps. I like enum better.
 - */
 -#define MIC_BOOST_NUM_OF_STEPS 4
 -#define MIC_BOOST_ENUM_MAX_STRLEN 10
 +	codec_dbg(codec, "ca0132_switch_put: nid=0x%x, val=%ld\n",
 +		    nid, *valp);
  
 -static int ca0132_alt_mic_boost_info(struct snd_kcontrol *kcontrol,
 -				 struct snd_ctl_elem_info *uinfo)
 -{
 -	char *sfx = "dB";
 -	char namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
 -
 -	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 -	uinfo->count = 1;
 -	uinfo->value.enumerated.items = MIC_BOOST_NUM_OF_STEPS;
 -	if (uinfo->value.enumerated.item >= MIC_BOOST_NUM_OF_STEPS)
 -		uinfo->value.enumerated.item = MIC_BOOST_NUM_OF_STEPS - 1;
 -	sprintf(namestr, "%d %s", (uinfo->value.enumerated.item * 10), sfx);
 -	strcpy(uinfo->value.enumerated.name, namestr);
 -	return 0;
 -}
 +	snd_hda_power_up(codec);
 +	/* vnode */
 +	if ((nid >= VNODE_START_NID) && (nid < VNODE_END_NID)) {
 +		if (ch & 1) {
 +			spec->vnode_lswitch[nid - VNODE_START_NID] = *valp;
 +			valp++;
 +		}
 +		if (ch & 2) {
 +			spec->vnode_rswitch[nid - VNODE_START_NID] = *valp;
 +			valp++;
 +		}
 +		changed = ca0132_vnode_switch_set(kcontrol, ucontrol);
 +		goto exit;
 +	}
  
 -static int ca0132_alt_mic_boost_get(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 +	/* PE */
 +	if (nid == PLAY_ENHANCEMENT) {
 +		spec->effects_switch[nid - EFFECT_START_NID] = *valp;
 +		changed = ca0132_pe_switch_set(codec);
 +		goto exit;
 +	}
  
 -	ucontrol->value.enumerated.item[0] = spec->mic_boost_enum_val;
 -	return 0;
 -}
 +	/* CrystalVoice */
 +	if (nid == CRYSTAL_VOICE) {
 +		spec->effects_switch[nid - EFFECT_START_NID] = *valp;
 +		changed = ca0132_cvoice_switch_set(codec);
 +		goto exit;
 +	}
  
 -static int ca0132_alt_mic_boost_put(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	int sel = ucontrol->value.enumerated.item[0];
 -	unsigned int items = MIC_BOOST_NUM_OF_STEPS;
 +	/* out and in effects */
 +	if (((nid >= OUT_EFFECT_START_NID) && (nid < OUT_EFFECT_END_NID)) ||
 +	    ((nid >= IN_EFFECT_START_NID) && (nid < IN_EFFECT_END_NID))) {
 +		spec->effects_switch[nid - EFFECT_START_NID] = *valp;
 +		changed = ca0132_effects_set(codec, nid, *valp);
 +		goto exit;
 +	}
  
 -	if (sel >= items)
 -		return 0;
 +	/* mic boost */
 +	if (nid == spec->input_pins[0]) {
 +		spec->cur_mic_boost = *valp;
  
 -	codec_dbg(codec, "ca0132_alt_mic_boost: boost=%d\n",
 -		    sel);
 +		/* Mic boost does not apply to Digital Mic */
 +		if (spec->cur_mic_type != DIGITAL_MIC)
 +			changed = ca0132_mic_boost_set(codec, *valp);
 +		goto exit;
 +	}
  
 -	spec->mic_boost_enum_val = sel;
++	if (nid == ZXR_HEADPHONE_GAIN) {
++		spec->zxr_gain_set = *valp;
++		if (spec->cur_out_type == HEADPHONE_OUT)
++			changed = zxr_headphone_gain_set(codec, *valp);
++		else
++			changed = 0;
+ 
 -	if (spec->in_enum_val != REAR_LINE_IN)
 -		ca0132_alt_mic_boost_set(codec, spec->mic_boost_enum_val);
++		goto exit;
++	}
+ 
 -	return 1;
 +exit:
 +	snd_hda_power_down(codec);
 +	return changed;
  }
  
  /*
@@@ -3962,146 -5380,352 +4335,349 @@@ static int ca0132_volume_tlv(struct snd
  {
  	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
  	struct ca0132_spec *spec = codec->spec;
 +	hda_nid_t nid = get_amp_nid(kcontrol);
 +	int ch = get_amp_channels(kcontrol);
 +	int dir = get_amp_direction(kcontrol);
 +	unsigned long pval;
 +	int err;
  
 -	ucontrol->value.enumerated.item[0] = spec->ae5_filter_val;
 -	return 0;
 +	switch (nid) {
 +	case VNID_SPK:
 +		/* follow shared_out tlv */
 +		nid = spec->shared_out_nid;
 +		mutex_lock(&codec->control_mutex);
 +		pval = kcontrol->private_value;
 +		kcontrol->private_value = HDA_COMPOSE_AMP_VAL(nid, ch, 0, dir);
 +		err = snd_hda_mixer_amp_tlv(kcontrol, op_flag, size, tlv);
 +		kcontrol->private_value = pval;
 +		mutex_unlock(&codec->control_mutex);
 +		break;
 +	case VNID_MIC:
 +		/* follow shared_mic tlv */
 +		nid = spec->shared_mic_nid;
 +		mutex_lock(&codec->control_mutex);
 +		pval = kcontrol->private_value;
 +		kcontrol->private_value = HDA_COMPOSE_AMP_VAL(nid, ch, 0, dir);
 +		err = snd_hda_mixer_amp_tlv(kcontrol, op_flag, size, tlv);
 +		kcontrol->private_value = pval;
 +		mutex_unlock(&codec->control_mutex);
 +		break;
 +	default:
 +		err = snd_hda_mixer_amp_tlv(kcontrol, op_flag, size, tlv);
 +	}
 +	return err;
  }
  
 -static int ae5_sound_filter_put(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 +static int add_fx_switch(struct hda_codec *codec, hda_nid_t nid,
 +			 const char *pfx, int dir)
  {
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	int sel = ucontrol->value.enumerated.item[0];
 -	unsigned int items = AE5_SOUND_FILTER_MAX;
 -
 -	if (sel >= items)
 -		return 0;
 -
 -	codec_dbg(codec, "ae5_sound_filter: %s\n",
 -			ae5_filter_presets[sel].name);
 -
 -	spec->ae5_filter_val = sel;
 -
 -	ca0113_mmio_command_set_type2(codec, 0x48, 0x07,
 -			ae5_filter_presets[sel].val);
 -
 -	return 1;
 +	char namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
 +	int type = dir ? HDA_INPUT : HDA_OUTPUT;
 +	struct snd_kcontrol_new knew =
 +		CA0132_CODEC_MUTE_MONO(namestr, nid, 1, type);
 +	sprintf(namestr, "%s %s Switch", pfx, dirstr[dir]);
 +	return snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));
  }
  
 -/*
 - * Input Select Control for alternative ca0132 codecs. This exists because
 - * front microphone has no auto-detect, and we need a way to set the rear
 - * as line-in
 - */
 -static int ca0132_alt_input_source_info(struct snd_kcontrol *kcontrol,
 -				 struct snd_ctl_elem_info *uinfo)
 +static int add_voicefx(struct hda_codec *codec)
  {
 -	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 -	uinfo->count = 1;
 -	uinfo->value.enumerated.items = IN_SRC_NUM_OF_INPUTS;
 -	if (uinfo->value.enumerated.item >= IN_SRC_NUM_OF_INPUTS)
 -		uinfo->value.enumerated.item = IN_SRC_NUM_OF_INPUTS - 1;
 -	strcpy(uinfo->value.enumerated.name,
 -			in_src_str[uinfo->value.enumerated.item]);
 -	return 0;
 +	struct snd_kcontrol_new knew =
 +		HDA_CODEC_MUTE_MONO(ca0132_voicefx.name,
 +				    VOICEFX, 1, 0, HDA_INPUT);
 +	knew.info = ca0132_voicefx_info;
 +	knew.get = ca0132_voicefx_get;
 +	knew.put = ca0132_voicefx_put;
 +	return snd_hda_ctl_add(codec, VOICEFX, snd_ctl_new1(&knew, codec));
  }
  
 -static int ca0132_alt_input_source_get(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
++<<<<<<< HEAD
++=======
++/* Create the EQ Preset control */
++static int add_ca0132_alt_eq_presets(struct hda_codec *codec)
+ {
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -
 -	ucontrol->value.enumerated.item[0] = spec->in_enum_val;
 -	return 0;
++	struct snd_kcontrol_new knew =
++		HDA_CODEC_MUTE_MONO(ca0132_alt_eq_enum.name,
++				    EQ_PRESET_ENUM, 1, 0, HDA_OUTPUT);
++	knew.info = ca0132_alt_eq_preset_info;
++	knew.get = ca0132_alt_eq_preset_get;
++	knew.put = ca0132_alt_eq_preset_put;
++	return snd_hda_ctl_add(codec, EQ_PRESET_ENUM,
++				snd_ctl_new1(&knew, codec));
+ }
+ 
 -static int ca0132_alt_input_source_put(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	int sel = ucontrol->value.enumerated.item[0];
 -	unsigned int items = IN_SRC_NUM_OF_INPUTS;
 -
 -	if (sel >= items)
 -		return 0;
 -
 -	codec_dbg(codec, "ca0132_alt_input_select: sel=%d, preset=%s\n",
 -		    sel, in_src_str[sel]);
 -
 -	spec->in_enum_val = sel;
 -
 -	ca0132_alt_select_in(codec);
++/*
++ * Add enumerated control for the three different settings of the smart volume
++ * output effect. Normal just uses the slider value, and loud and night are
++ * their own things that ignore that value.
++ */
++static int ca0132_alt_add_svm_enum(struct hda_codec *codec)
++{
++	struct snd_kcontrol_new knew =
++		HDA_CODEC_MUTE_MONO("FX: Smart Volume Setting",
++				    SMART_VOLUME_ENUM, 1, 0, HDA_OUTPUT);
++	knew.info = ca0132_alt_svm_setting_info;
++	knew.get = ca0132_alt_svm_setting_get;
++	knew.put = ca0132_alt_svm_setting_put;
++	return snd_hda_ctl_add(codec, SMART_VOLUME_ENUM,
++				snd_ctl_new1(&knew, codec));
+ 
 -	return 1;
+ }
+ 
 -/* Sound Blaster Z Output Select Control */
 -static int ca0132_alt_output_select_get_info(struct snd_kcontrol *kcontrol,
 -				 struct snd_ctl_elem_info *uinfo)
++/*
++ * Create an Output Select enumerated control for codecs with surround
++ * out capabilities.
++ */
++static int ca0132_alt_add_output_enum(struct hda_codec *codec)
+ {
 -	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 -	uinfo->count = 1;
 -	uinfo->value.enumerated.items = NUM_OF_OUTPUTS;
 -	if (uinfo->value.enumerated.item >= NUM_OF_OUTPUTS)
 -		uinfo->value.enumerated.item = NUM_OF_OUTPUTS - 1;
 -	strcpy(uinfo->value.enumerated.name,
 -			alt_out_presets[uinfo->value.enumerated.item].name);
 -	return 0;
++	struct snd_kcontrol_new knew =
++		HDA_CODEC_MUTE_MONO("Output Select",
++				    OUTPUT_SOURCE_ENUM, 1, 0, HDA_OUTPUT);
++	knew.info = ca0132_alt_output_select_get_info;
++	knew.get = ca0132_alt_output_select_get;
++	knew.put = ca0132_alt_output_select_put;
++	return snd_hda_ctl_add(codec, OUTPUT_SOURCE_ENUM,
++				snd_ctl_new1(&knew, codec));
+ }
+ 
 -static int ca0132_alt_output_select_get(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
++/*
++ * Create an Input Source enumerated control for the alternate ca0132 codecs
++ * because the front microphone has no auto-detect, and Line-in has to be set
++ * somehow.
++ */
++static int ca0132_alt_add_input_enum(struct hda_codec *codec)
+ {
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -
 -	ucontrol->value.enumerated.item[0] = spec->out_enum_val;
 -	return 0;
++	struct snd_kcontrol_new knew =
++		HDA_CODEC_MUTE_MONO("Input Source",
++				    INPUT_SOURCE_ENUM, 1, 0, HDA_INPUT);
++	knew.info = ca0132_alt_input_source_info;
++	knew.get = ca0132_alt_input_source_get;
++	knew.put = ca0132_alt_input_source_put;
++	return snd_hda_ctl_add(codec, INPUT_SOURCE_ENUM,
++				snd_ctl_new1(&knew, codec));
+ }
+ 
 -static int ca0132_alt_output_select_put(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
++/*
++ * Add mic boost enumerated control. Switches through 0dB to 30dB. This adds
++ * more control than the original mic boost, which is either full 30dB or off.
++ */
++static int ca0132_alt_add_mic_boost_enum(struct hda_codec *codec)
+ {
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	int sel = ucontrol->value.enumerated.item[0];
 -	unsigned int items = NUM_OF_OUTPUTS;
 -	unsigned int auto_jack;
 -
 -	if (sel >= items)
 -		return 0;
 -
 -	codec_dbg(codec, "ca0132_alt_output_select: sel=%d, preset=%s\n",
 -		    sel, alt_out_presets[sel].name);
 -
 -	spec->out_enum_val = sel;
 -
 -	auto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
 -
 -	if (!auto_jack)
 -		ca0132_alt_select_out(codec);
++	struct snd_kcontrol_new knew =
++		HDA_CODEC_MUTE_MONO("Mic Boost Capture Switch",
++				    MIC_BOOST_ENUM, 1, 0, HDA_INPUT);
++	knew.info = ca0132_alt_mic_boost_info;
++	knew.get = ca0132_alt_mic_boost_get;
++	knew.put = ca0132_alt_mic_boost_put;
++	return snd_hda_ctl_add(codec, MIC_BOOST_ENUM,
++				snd_ctl_new1(&knew, codec));
+ 
 -	return 1;
+ }
+ 
+ /*
 - * Smart Volume output setting control. Three different settings, Normal,
 - * which takes the value from the smart volume slider. The two others, loud
 - * and night, disregard the slider value and have uneditable values.
++ * Add headphone gain enumerated control for the AE-5. This switches between
++ * three modes, low, medium, and high. When non-headphone outputs are selected,
++ * it is automatically set to high. This is the same behavior as Windows.
+  */
 -#define NUM_OF_SVM_SETTINGS 3
 -static const char *const out_svm_set_enum_str[3] = {"Normal", "Loud", "Night" };
 -
 -static int ca0132_alt_svm_setting_info(struct snd_kcontrol *kcontrol,
 -				 struct snd_ctl_elem_info *uinfo)
++static int ae5_add_headphone_gain_enum(struct hda_codec *codec)
+ {
 -	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 -	uinfo->count = 1;
 -	uinfo->value.enumerated.items = NUM_OF_SVM_SETTINGS;
 -	if (uinfo->value.enumerated.item >= NUM_OF_SVM_SETTINGS)
 -		uinfo->value.enumerated.item = NUM_OF_SVM_SETTINGS - 1;
 -	strcpy(uinfo->value.enumerated.name,
 -			out_svm_set_enum_str[uinfo->value.enumerated.item]);
 -	return 0;
++	struct snd_kcontrol_new knew =
++		HDA_CODEC_MUTE_MONO("AE-5: Headphone Gain",
++				    AE5_HEADPHONE_GAIN_ENUM, 1, 0, HDA_OUTPUT);
++	knew.info = ae5_headphone_gain_info;
++	knew.get = ae5_headphone_gain_get;
++	knew.put = ae5_headphone_gain_put;
++	return snd_hda_ctl_add(codec, AE5_HEADPHONE_GAIN_ENUM,
++				snd_ctl_new1(&knew, codec));
+ }
+ 
 -static int ca0132_alt_svm_setting_get(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
++/*
++ * Add sound filter enumerated control for the AE-5. This adds three different
++ * settings: Slow Roll Off, Minimum Phase, and Fast Roll Off. From what I've
++ * read into it, it changes the DAC's interpolation filter.
++ */
++static int ae5_add_sound_filter_enum(struct hda_codec *codec)
+ {
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -
 -	ucontrol->value.enumerated.item[0] = spec->smart_volume_setting;
 -	return 0;
++	struct snd_kcontrol_new knew =
++		HDA_CODEC_MUTE_MONO("AE-5: Sound Filter",
++				    AE5_SOUND_FILTER_ENUM, 1, 0, HDA_OUTPUT);
++	knew.info = ae5_sound_filter_info;
++	knew.get = ae5_sound_filter_get;
++	knew.put = ae5_sound_filter_put;
++	return snd_hda_ctl_add(codec, AE5_SOUND_FILTER_ENUM,
++				snd_ctl_new1(&knew, codec));
+ }
+ 
 -static int ca0132_alt_svm_setting_put(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
++static int zxr_add_headphone_gain_switch(struct hda_codec *codec)
+ {
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	int sel = ucontrol->value.enumerated.item[0];
 -	unsigned int items = NUM_OF_SVM_SETTINGS;
 -	unsigned int idx = SMART_VOLUME - EFFECT_START_NID;
 -	unsigned int tmp;
 -
 -	if (sel >= items)
 -		return 0;
 -
 -	codec_dbg(codec, "ca0132_alt_svm_setting: sel=%d, preset=%s\n",
 -		    sel, out_svm_set_enum_str[sel]);
 -
 -	spec->smart_volume_setting = sel;
++	struct snd_kcontrol_new knew =
++		CA0132_CODEC_MUTE_MONO("ZxR: 600 Ohm Gain",
++				    ZXR_HEADPHONE_GAIN, 1, HDA_OUTPUT);
+ 
 -	switch (sel) {
 -	case 0:
 -		tmp = FLOAT_ZERO;
 -		break;
 -	case 1:
 -		tmp = FLOAT_ONE;
 -		break;
 -	case 2:
 -		tmp = FLOAT_TWO;
 -		break;
 -	default:
 -		tmp = FLOAT_ZERO;
 -		break;
 -	}
 -	/* Req 2 is the Smart Volume Setting req. */
 -	dspio_set_uint_param(codec, ca0132_effects[idx].mid,
 -			ca0132_effects[idx].reqs[2], tmp);
 -	return 1;
++	return snd_hda_ctl_add(codec, ZXR_HEADPHONE_GAIN,
++				snd_ctl_new1(&knew, codec));
+ }
+ 
 -/* Sound Blaster Z EQ preset controls */
 -static int ca0132_alt_eq_preset_info(struct snd_kcontrol *kcontrol,
 -				 struct snd_ctl_elem_info *uinfo)
 -{
 -	unsigned int items = ARRAY_SIZE(ca0132_alt_eq_presets);
++/*
++ * Need to create slave controls for the alternate codecs that have surround
++ * capabilities.
++ */
++static const char * const ca0132_alt_slave_pfxs[] = {
++	"Front", "Surround", "Center", "LFE", NULL,
++};
+ 
 -	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 -	uinfo->count = 1;
 -	uinfo->value.enumerated.items = items;
 -	if (uinfo->value.enumerated.item >= items)
 -		uinfo->value.enumerated.item = items - 1;
 -	strcpy(uinfo->value.enumerated.name,
 -		ca0132_alt_eq_presets[uinfo->value.enumerated.item].name);
 -	return 0;
 -}
++/*
++ * Also need special channel map, because the default one is incorrect.
++ * I think this has to do with the pin for rear surround being 0x11,
++ * and the center/lfe being 0x10. Usually the pin order is the opposite.
++ */
++static const struct snd_pcm_chmap_elem ca0132_alt_chmaps[] = {
++	{ .channels = 2,
++	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
++	{ .channels = 4,
++	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
++		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
++	{ .channels = 6,
++	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
++		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,
++		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
++	{ }
++};
+ 
 -static int ca0132_alt_eq_preset_get(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
++/* Add the correct chmap for streams with 6 channels. */
++static void ca0132_alt_add_chmap_ctls(struct hda_codec *codec)
+ {
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
++	int err = 0;
++	struct hda_pcm *pcm;
+ 
 -	ucontrol->value.enumerated.item[0] = spec->eq_preset_val;
 -	return 0;
++	list_for_each_entry(pcm, &codec->pcm_list_head, list) {
++		struct hda_pcm_stream *hinfo =
++			&pcm->stream[SNDRV_PCM_STREAM_PLAYBACK];
++		struct snd_pcm_chmap *chmap;
++		const struct snd_pcm_chmap_elem *elem;
++
++		elem = ca0132_alt_chmaps;
++		if (hinfo->channels_max == 6) {
++			err = snd_pcm_add_chmap_ctls(pcm->pcm,
++					SNDRV_PCM_STREAM_PLAYBACK,
++					elem, hinfo->channels_max, 0, &chmap);
++			if (err < 0)
++				codec_dbg(codec, "snd_pcm_add_chmap_ctls failed!");
++		}
++	}
+ }
+ 
 -static int ca0132_alt_eq_preset_put(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
++>>>>>>> d51434d43a2c (ALSA: hda/ca0132 - Add ZxR 600 ohm gain control)
 +/*
 + * When changing Node IDs for Mixer Controls below, make sure to update
 + * Node IDs in ca0132_config() as well.
 + */
 +static struct snd_kcontrol_new ca0132_mixer[] = {
 +	CA0132_CODEC_VOL("Master Playback Volume", VNID_SPK, HDA_OUTPUT),
 +	CA0132_CODEC_MUTE("Master Playback Switch", VNID_SPK, HDA_OUTPUT),
 +	CA0132_CODEC_VOL("Capture Volume", VNID_MIC, HDA_INPUT),
 +	CA0132_CODEC_MUTE("Capture Switch", VNID_MIC, HDA_INPUT),
 +	HDA_CODEC_VOLUME("Analog-Mic2 Capture Volume", 0x08, 0, HDA_INPUT),
 +	HDA_CODEC_MUTE("Analog-Mic2 Capture Switch", 0x08, 0, HDA_INPUT),
 +	HDA_CODEC_VOLUME("What U Hear Capture Volume", 0x0a, 0, HDA_INPUT),
 +	HDA_CODEC_MUTE("What U Hear Capture Switch", 0x0a, 0, HDA_INPUT),
 +	CA0132_CODEC_MUTE_MONO("Mic1-Boost (30dB) Capture Switch",
 +			       0x12, 1, HDA_INPUT),
 +	CA0132_CODEC_MUTE_MONO("HP/Speaker Playback Switch",
 +			       VNID_HP_SEL, 1, HDA_OUTPUT),
 +	CA0132_CODEC_MUTE_MONO("AMic1/DMic Capture Switch",
 +			       VNID_AMIC1_SEL, 1, HDA_INPUT),
 +	CA0132_CODEC_MUTE_MONO("HP/Speaker Auto Detect Playback Switch",
 +			       VNID_HP_ASEL, 1, HDA_OUTPUT),
 +	CA0132_CODEC_MUTE_MONO("AMic1/DMic Auto Detect Capture Switch",
 +			       VNID_AMIC1_ASEL, 1, HDA_INPUT),
 +	{ } /* end */
 +};
 +
 +static int ca0132_build_controls(struct hda_codec *codec)
  {
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
  	struct ca0132_spec *spec = codec->spec;
 -	int i, err = 0;
 -	int sel = ucontrol->value.enumerated.item[0];
 -	unsigned int items = ARRAY_SIZE(ca0132_alt_eq_presets);
 +	int i, num_fx;
 +	int err = 0;
  
 -	if (sel >= items)
 -		return 0;
 +	/* Add Mixer controls */
 +	for (i = 0; i < spec->num_mixers; i++) {
 +		err = snd_hda_add_new_ctls(codec, spec->mixers[i]);
 +		if (err < 0)
 +			return err;
 +	}
  
 -	codec_dbg(codec, "%s: sel=%d, preset=%s\n", __func__, sel,
 -			ca0132_alt_eq_presets[sel].name);
 -	/*
 -	 * Idx 0 is default.
 -	 * Default needs to qualify with CrystalVoice state.
 +	/* Add in and out effects controls.
 +	 * VoiceFX, PE and CrystalVoice are added separately.
  	 */
 -	for (i = 0; i < EQ_PRESET_MAX_PARAM_COUNT; i++) {
 -		err = dspio_set_uint_param(codec, ca0132_alt_eq_enum.mid,
 -				ca0132_alt_eq_enum.reqs[i],
 -				ca0132_alt_eq_presets[sel].vals[i]);
 +	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT;
 +	for (i = 0; i < num_fx; i++) {
 +		err = add_fx_switch(codec, ca0132_effects[i].nid,
 +				    ca0132_effects[i].name,
 +				    ca0132_effects[i].direct);
  		if (err < 0)
 -			break;
 +			return err;
  	}
  
 -	if (err >= 0)
 -		spec->eq_preset_val = sel;
 +	err = add_fx_switch(codec, PLAY_ENHANCEMENT, "PlayEnhancement", 0);
 +	if (err < 0)
 +		return err;
  
 -	return 1;
 -}
 -
 -static int ca0132_voicefx_info(struct snd_kcontrol *kcontrol,
 -				 struct snd_ctl_elem_info *uinfo)
 -{
 -	unsigned int items = ARRAY_SIZE(ca0132_voicefx_presets);
 -
 -	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 -	uinfo->count = 1;
 -	uinfo->value.enumerated.items = items;
 -	if (uinfo->value.enumerated.item >= items)
 -		uinfo->value.enumerated.item = items - 1;
 -	strcpy(uinfo->value.enumerated.name,
 -	       ca0132_voicefx_presets[uinfo->value.enumerated.item].name);
 -	return 0;
 -}
 -
 -static int ca0132_voicefx_get(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -
 -	ucontrol->value.enumerated.item[0] = spec->voicefx_val;
 -	return 0;
 -}
 -
 -static int ca0132_voicefx_put(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	int i, err = 0;
 -	int sel = ucontrol->value.enumerated.item[0];
 -
 -	if (sel >= ARRAY_SIZE(ca0132_voicefx_presets))
 -		return 0;
 +	err = add_fx_switch(codec, CRYSTAL_VOICE, "CrystalVoice", 1);
 +	if (err < 0)
 +		return err;
  
 -	codec_dbg(codec, "ca0132_voicefx_put: sel=%d, preset=%s\n",
 -		    sel, ca0132_voicefx_presets[sel].name);
 +	add_voicefx(codec);
  
++<<<<<<< HEAD
++=======
+ 	/*
 -	 * Idx 0 is default.
 -	 * Default needs to qualify with CrystalVoice state.
++	 * If the codec uses alt_functions, you need the enumerated controls
++	 * to select the new outputs and inputs, plus add the new mic boost
++	 * setting control.
+ 	 */
 -	for (i = 0; i < VOICEFX_MAX_PARAM_COUNT; i++) {
 -		err = dspio_set_uint_param(codec, ca0132_voicefx.mid,
 -				ca0132_voicefx.reqs[i],
 -				ca0132_voicefx_presets[sel].vals[i]);
 -		if (err < 0)
 -			break;
++	if (spec->use_alt_functions) {
++		ca0132_alt_add_output_enum(codec);
++		ca0132_alt_add_mic_boost_enum(codec);
++		/*
++		 * ZxR only has microphone input, there is no front panel
++		 * header on the card, and aux-in is handled by the DBPro board.
++		 */
++		if (spec->quirk != QUIRK_ZXR)
++			ca0132_alt_add_input_enum(codec);
+ 	}
+ 
 -	if (err >= 0) {
 -		spec->voicefx_val = sel;
 -		/* enable voice fx */
 -		ca0132_voicefx_set(codec, (sel ? 1 : 0));
++	if (spec->quirk == QUIRK_AE5) {
++		ae5_add_headphone_gain_enum(codec);
++		ae5_add_sound_filter_enum(codec);
+ 	}
+ 
 -	return 1;
 -}
 -
 -static int ca0132_switch_get(struct snd_kcontrol *kcontrol,
 -				struct snd_ctl_elem_value *ucontrol)
 -{
 -	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 -	struct ca0132_spec *spec = codec->spec;
 -	hda_nid_t nid = get_amp_nid(kcontrol);
 -	int ch = get_amp_channels(kcontrol);
 -	long *valp = ucontrol->value.integer.value;
++	if (spec->quirk == QUIRK_ZXR)
++		zxr_add_headphone_gain_switch(codec);
++>>>>>>> d51434d43a2c (ALSA: hda/ca0132 - Add ZxR 600 ohm gain control)
 +#ifdef ENABLE_TUNING_CONTROLS
 +	add_tuning_ctls(codec);
 +#endif
  
 -	/* vnode */
 -	if ((nid >= VNODE_START_NID) && (nid < VNODE_END_NID)) {
 -		if (ch & 1) {
 -			*valp = spec->vnode_lswitch[nid - VNODE_START_NID];
 -			valp++;
 -		}
 -		if (ch & 2) {
 -			*valp = spec->vnode_rswitch[nid - VNODE_START_NID];
 -			valp++;
 -		}
 -		return 0;
 -	}
 +	err = snd_hda_jack_add_kctls(codec, &spec->gen.autocfg);
 +	if (err < 0)
 +		return err;
  
 -	/* effects, include PE and CrystalVoice */
 -	if ((nid >= EFFECT_START_NID) && (nid < EFFECT_END_NID)) {
 -		*valp = spec->effects_switch[nid - EFFECT_START_NID];
 -		return 0;
 +	if (spec->dig_out) {
 +		err = snd_hda_create_spdif_out_ctls(codec, spec->dig_out,
 +						    spec->dig_out);
 +		if (err < 0)
 +			return err;
 +		err = snd_hda_create_spdif_share_sw(codec, &spec->multiout);
 +		if (err < 0)
 +			return err;
 +		/* spec->multiout.share_spdif = 1; */
  	}
  
 -	/* mic boost */
 -	if (nid == spec->input_pins[0]) {
 -		*valp = spec->cur_mic_boost;
 -		return 0;
 +	if (spec->dig_in) {
 +		err = snd_hda_create_spdif_in_ctls(codec, spec->dig_in);
 +		if (err < 0)
 +			return err;
  	}
 -
  	return 0;
  }
  
* Unmerged path sound/pci/hda/patch_ca0132.c
