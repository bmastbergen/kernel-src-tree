ovl: consistent i_ino for non-samefs with xino

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 12574a9f4c9cc9d8d6fd9078cbb8ec7d3e9ed46b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/12574a9f.failed

When overlay layers are not all on the same fs, but all inode numbers
of underlying fs do not use the high 'xino' bits, overlay st_ino values
are constant and persistent.

In that case, set i_ino value to the same value as st_ino for nfsd
readdirplus validator.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 12574a9f4c9cc9d8d6fd9078cbb8ec7d3e9ed46b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/export.c
#	fs/overlayfs/inode.c
diff --cc fs/overlayfs/inode.c
index 24ce49ae057f,6e3815fb006b..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -494,21 -489,31 +494,28 @@@ static inline void ovl_lockdep_annotate
  }
  
  static void ovl_fill_inode(struct inode *inode, umode_t mode, dev_t rdev,
- 			   unsigned long ino)
+ 			   unsigned long ino, int fsid)
  {
+ 	int xinobits = ovl_xino_bits(inode->i_sb);
+ 
  	/*
  	 * When NFS export is enabled and d_ino is consistent with st_ino
- 	 * (samefs), set the same value to i_ino, because nfsd readdirplus
- 	 * compares d_ino values to i_ino values of child entries. When called
- 	 * from ovl_new_inode(), ino arg is 0, so i_ino will be updated to real
+ 	 * (samefs or i_ino has enough bits to encode layer), set the same
+ 	 * value used for d_ino to i_ino, because nfsd readdirplus compares
+ 	 * d_ino values to i_ino values of child entries. When called from
+ 	 * ovl_new_inode(), ino arg is 0, so i_ino will be updated to real
  	 * upper inode i_ino on ovl_inode_init() or ovl_inode_update().
  	 */
- 	if (inode->i_sb->s_export_op && ovl_same_sb(inode->i_sb))
+ 	if (inode->i_sb->s_export_op &&
+ 	    (ovl_same_sb(inode->i_sb) || xinobits)) {
  		inode->i_ino = ino;
- 	else
+ 		if (xinobits && fsid && !(ino >> (64 - xinobits)))
+ 			inode->i_ino |= (unsigned long)fsid << (64 - xinobits);
+ 	} else {
  		inode->i_ino = get_next_ino();
+ 	}
  	inode->i_mode = mode;
  	inode->i_flags |= S_NOCMTIME;
 -#ifdef CONFIG_FS_POSIX_ACL
 -	inode->i_acl = inode->i_default_acl = ACL_DONT_CACHE;
 -#endif
  
  	ovl_lockdep_annotate_inode_mutex_key(inode);
  
@@@ -690,16 -698,66 +697,22 @@@ static bool ovl_verify_inode(struct ino
  	return true;
  }
  
 -struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,
 -			       bool is_upper)
 -{
 -	struct inode *inode, *key = d_inode(real);
 -
 -	inode = ilookup5(sb, (unsigned long) key, ovl_inode_test, key);
 -	if (!inode)
 -		return NULL;
 -
 -	if (!ovl_verify_inode(inode, is_upper ? NULL : real,
 -			      is_upper ? real : NULL, false)) {
 -		iput(inode);
 -		return ERR_PTR(-ESTALE);
 -	}
 -
 -	return inode;
 -}
 -
 -/*
 - * Does overlay inode need to be hashed by lower inode?
 - */
 -static bool ovl_hash_bylower(struct super_block *sb, struct dentry *upper,
 -			     struct dentry *lower, struct dentry *index)
 -{
 -	struct ovl_fs *ofs = sb->s_fs_info;
 -
 -	/* No, if pure upper */
 -	if (!lower)
 -		return false;
 -
 -	/* Yes, if already indexed */
 -	if (index)
 -		return true;
 -
 -	/* Yes, if won't be copied up */
 -	if (!ofs->upper_mnt)
 -		return true;
 -
 -	/* No, if lower hardlink is or will be broken on copy up */
 -	if ((upper || !ovl_indexdir(sb)) &&
 -	    !d_is_dir(lower) && d_inode(lower)->i_nlink > 1)
 -		return false;
 -
 -	/* No, if non-indexed upper with NFS export */
 -	if (sb->s_export_op && upper)
 -		return false;
 -
 -	/* Otherwise, hash by lower inode for fsnotify */
 -	return true;
 -}
 -
  struct inode *ovl_get_inode(struct super_block *sb, struct dentry *upperdentry,
- 			    struct dentry *lowerdentry, struct dentry *index,
+ 			    struct ovl_path *lowerpath, struct dentry *index,
  			    unsigned int numlower)
  {
 +	struct ovl_fs *ofs = sb->s_fs_info;
  	struct inode *realinode = upperdentry ? d_inode(upperdentry) : NULL;
  	struct inode *inode;
++<<<<<<< HEAD
 +	/* Already indexed or could be indexed on copy up? */
 +	bool indexed = (index || (ovl_indexdir(sb) && !upperdentry));
 +	struct dentry *origin = indexed ? lowerdentry : NULL;
++=======
+ 	struct dentry *lowerdentry = lowerpath ? lowerpath->dentry : NULL;
+ 	bool bylower = ovl_hash_bylower(sb, upperdentry, lowerdentry, index);
+ 	int fsid = bylower ? lowerpath->layer->fsid : 0;
++>>>>>>> 12574a9f4c9c (ovl: consistent i_ino for non-samefs with xino)
  	bool is_dir;
  	unsigned long ino = 0;
  
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/inode.c
diff --git a/fs/overlayfs/namei.c b/fs/overlayfs/namei.c
index 42e824e6e6cb..0ebd71447d92 100644
--- a/fs/overlayfs/namei.c
+++ b/fs/overlayfs/namei.c
@@ -747,9 +747,7 @@ struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 		upperdentry = dget(index);
 
 	if (upperdentry || ctr) {
-		if (ctr)
-			origin = stack[0].dentry;
-		inode = ovl_get_inode(dentry->d_sb, upperdentry, origin, index,
+		inode = ovl_get_inode(dentry->d_sb, upperdentry, stack, index,
 				      ctr);
 		err = PTR_ERR(inode);
 		if (IS_ERR(inode))
diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index 403c48960f89..567015eb9e31 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -290,7 +290,7 @@ bool ovl_is_private_xattr(const char *name);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
 struct inode *ovl_get_inode(struct super_block *sb, struct dentry *upperdentry,
-			    struct dentry *lowerdentry, struct dentry *index,
+			    struct ovl_path *lowerpath, struct dentry *index,
 			    unsigned int numlower);
 static inline void ovl_copyattr(struct inode *from, struct inode *to)
 {
