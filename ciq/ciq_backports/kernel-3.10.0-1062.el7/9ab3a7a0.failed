asm-generic/io.h: Implement generic {read,write}s*()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [kernel] asm-generic/io.h: Implement generic {read, write}s*() (Petr Oros) [1668778]
Rebuild_FUZZ: 99.05%
commit-author Thierry Reding <treding@nvidia.com>
commit 9ab3a7a0d2b417773e8e8a880fc3a69f7fc1f57a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9ab3a7a0.failed

Currently driver writers need to use io{read,write}{8,16,32}_rep() when
accessing FIFO registers portably. This is bad for two reasons: it is
inconsistent with how other registers are accessed using the standard
{read,write}{b,w,l}() functions, which can lead to confusion. On some
architectures the io{read,write}*() functions also need to perform some
extra checks to determine whether an address is memory-mapped or refers
to I/O space. Drivers which can be expected to never use I/O can safely
use the {read,write}s{b,w,l,q}(), just like they use their non-string
variants and there's no need for these extra checks.

This patch implements generic versions of readsb(), readsw(), readsl(),
readsq(), writesb(), writesw(), writesl() and writesq(). Variants of
these string functions for I/O accesses (ins*() and outs*() as well as
ioread*_rep() and iowrite*_rep()) are now implemented in terms of the
new functions.

Going forward, {read,write}{,s}{b,w,l,q}() should be used consistently
by drivers for devices that will only ever be memory-mapped and hence
don't need to access I/O space, whereas io{read,write}{8,16,32}_rep()
should be used by drivers for devices that can be either memory-mapped
or I/O-mapped.

	Signed-off-by: Thierry Reding <treding@nvidia.com>
(cherry picked from commit 9ab3a7a0d2b417773e8e8a880fc3a69f7fc1f57a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/asm-generic/io.h
diff --cc include/asm-generic/io.h
index 66a3fecbf792,00483d769d86..000000000000
--- a/include/asm-generic/io.h
+++ b/include/asm-generic/io.h
@@@ -135,60 -122,66 +135,66 @@@ static inline void __raw_writeq(u64 b, 
  }
  #endif
  
 -#ifndef readl
 -#define readl readl
 -static inline u32 readl(const volatile void __iomem *addr)
 +#define writeq(b, addr) __raw_writeq(__cpu_to_le64(b), addr)
 +#ifndef writeq_relaxed
 +#define writeq_relaxed writeq
 +#endif
 +#endif /* CONFIG_64BIT */
 +
 +#ifndef PCI_IOBASE
 +#define PCI_IOBASE ((void __iomem *) 0)
 +#endif
 +
 +/*****************************************************************************/
 +/*
 + * traditional input/output functions
 + */
 +
 +static inline u8 inb(unsigned long addr)
  {
 -	return __le32_to_cpu(__raw_readl(addr));
 +	return readb(addr + PCI_IOBASE);
  }
 -#endif
  
 -#ifdef CONFIG_64BIT
 -#ifndef readq
 -#define readq readq
 -static inline u64 readq(const volatile void __iomem *addr)
 +static inline u16 inw(unsigned long addr)
  {
 -	return __le64_to_cpu(__raw_readq(addr));
 +	return readw(addr + PCI_IOBASE);
  }
 -#endif
 -#endif /* CONFIG_64BIT */
  
 -#ifndef writeb
 -#define writeb writeb
 -static inline void writeb(u8 value, volatile void __iomem *addr)
 +static inline u32 inl(unsigned long addr)
  {
 -	__raw_writeb(value, addr);
 +	return readl(addr + PCI_IOBASE);
  }
 -#endif
  
 -#ifndef writew
 -#define writew writew
 -static inline void writew(u16 value, volatile void __iomem *addr)
 +static inline void outb(u8 b, unsigned long addr)
  {
 -	__raw_writew(cpu_to_le16(value), addr);
 +	writeb(b, addr + PCI_IOBASE);
  }
 -#endif
  
 -#ifndef writel
 -#define writel writel
 -static inline void writel(u32 value, volatile void __iomem *addr)
 +static inline void outw(u16 b, unsigned long addr)
  {
 -	__raw_writel(__cpu_to_le32(value), addr);
 +	writew(b, addr + PCI_IOBASE);
  }
 -#endif
  
 -#ifdef CONFIG_64BIT
 -#ifndef writeq
 -#define writeq writeq
 -static inline void writeq(u64 value, volatile void __iomem *addr)
 +static inline void outl(u32 b, unsigned long addr)
  {
 -	__raw_writeq(__cpu_to_le64(value), addr);
 +	writel(b, addr + PCI_IOBASE);
  }
 -#endif
 -#endif /* CONFIG_64BIT */
 +
 +#define inb_p(addr)	inb(addr)
 +#define inw_p(addr)	inw(addr)
 +#define inl_p(addr)	inl(addr)
 +#define outb_p(x, addr)	outb((x), (addr))
 +#define outw_p(x, addr)	outw((x), (addr))
 +#define outl_p(x, addr)	outl((x), (addr))
  
- #ifndef insb
- static inline void insb(unsigned long addr, void *buffer, int count)
+ /*
+  * {read,write}s{b,w,l,q}() repeatedly access the same memory address in
+  * native endianness in 8-, 16-, 32- or 64-bit chunks (@count times).
+  */
+ #ifndef readsb
+ #define readsb readsb
+ static inline void readsb(const volatile void __iomem *addr, void *buffer,
+ 			  unsigned int count)
  {
  	if (count) {
  		u8 *buf = buffer;
@@@ -262,38 -289,379 +302,400 @@@ static inline void writesl(volatile voi
  }
  #endif
  
++<<<<<<< HEAD
 +#ifndef CONFIG_GENERIC_IOMAP
 +#define ioread8(addr)		readb(addr)
 +#define ioread16(addr)		readw(addr)
 +#define ioread16be(addr)	__be16_to_cpu(__raw_readw(addr))
 +#define ioread32(addr)		readl(addr)
 +#define ioread32be(addr)	__be32_to_cpu(__raw_readl(addr))
 +
 +#define iowrite8(v, addr)	writeb((v), (addr))
 +#define iowrite16(v, addr)	writew((v), (addr))
 +#define iowrite16be(v, addr)	__raw_writew(__cpu_to_be16(v), addr)
 +#define iowrite32(v, addr)	writel((v), (addr))
 +#define iowrite32be(v, addr)	__raw_writel(__cpu_to_be32(v), addr)
 +
 +#define ioread8_rep(p, dst, count) \
 +	insb((unsigned long) (p), (dst), (count))
 +#define ioread16_rep(p, dst, count) \
 +	insw((unsigned long) (p), (dst), (count))
 +#define ioread32_rep(p, dst, count) \
 +	insl((unsigned long) (p), (dst), (count))
++=======
+ #ifdef CONFIG_64BIT
+ #ifndef writesq
+ #define writesq writesq
+ static inline void writesq(volatile void __iomem *addr, const void *buffer,
+ 			   unsigned int count)
+ {
+ 	if (count) {
+ 		const u64 *buf = buffer;
++>>>>>>> 9ab3a7a0d2b4 (asm-generic/io.h: Implement generic {read,write}s*())
  
- #define iowrite8_rep(p, src, count) \
- 	outsb((unsigned long) (p), (src), (count))
- #define iowrite16_rep(p, src, count) \
- 	outsw((unsigned long) (p), (src), (count))
- #define iowrite32_rep(p, src, count) \
- 	outsl((unsigned long) (p), (src), (count))
- #endif /* CONFIG_GENERIC_IOMAP */
+ 		do {
+ 			__raw_writeq(*buf++, addr);
+ 		} while (--count);
+ 	}
+ }
+ #endif
+ #endif /* CONFIG_64BIT */
  
 -#ifndef PCI_IOBASE
 -#define PCI_IOBASE ((void __iomem *)0)
 -#endif
 -
  #ifndef IO_SPACE_LIMIT
  #define IO_SPACE_LIMIT 0xffff
  #endif
  
++<<<<<<< HEAD
++=======
+ /*
+  * {in,out}{b,w,l}() access little endian I/O. {in,out}{b,w,l}_p() can be
+  * implemented on hardware that needs an additional delay for I/O accesses to
+  * take effect.
+  */
+ 
+ #ifndef inb
+ #define inb inb
+ static inline u8 inb(unsigned long addr)
+ {
+ 	return readb(PCI_IOBASE + addr);
+ }
+ #endif
+ 
+ #ifndef inw
+ #define inw inw
+ static inline u16 inw(unsigned long addr)
+ {
+ 	return readw(PCI_IOBASE + addr);
+ }
+ #endif
+ 
+ #ifndef inl
+ #define inl inl
+ static inline u32 inl(unsigned long addr)
+ {
+ 	return readl(PCI_IOBASE + addr);
+ }
+ #endif
+ 
+ #ifndef outb
+ #define outb outb
+ static inline void outb(u8 value, unsigned long addr)
+ {
+ 	writeb(value, PCI_IOBASE + addr);
+ }
+ #endif
+ 
+ #ifndef outw
+ #define outw outw
+ static inline void outw(u16 value, unsigned long addr)
+ {
+ 	writew(value, PCI_IOBASE + addr);
+ }
+ #endif
+ 
+ #ifndef outl
+ #define outl outl
+ static inline void outl(u32 value, unsigned long addr)
+ {
+ 	writel(value, PCI_IOBASE + addr);
+ }
+ #endif
+ 
+ #ifndef inb_p
+ #define inb_p inb_p
+ static inline u8 inb_p(unsigned long addr)
+ {
+ 	return inb(addr);
+ }
+ #endif
+ 
+ #ifndef inw_p
+ #define inw_p inw_p
+ static inline u16 inw_p(unsigned long addr)
+ {
+ 	return inw(addr);
+ }
+ #endif
+ 
+ #ifndef inl_p
+ #define inl_p inl_p
+ static inline u32 inl_p(unsigned long addr)
+ {
+ 	return inl(addr);
+ }
+ #endif
+ 
+ #ifndef outb_p
+ #define outb_p outb_p
+ static inline void outb_p(u8 value, unsigned long addr)
+ {
+ 	outb(value, addr);
+ }
+ #endif
+ 
+ #ifndef outw_p
+ #define outw_p outw_p
+ static inline void outw_p(u16 value, unsigned long addr)
+ {
+ 	outw(value, addr);
+ }
+ #endif
+ 
+ #ifndef outl_p
+ #define outl_p outl_p
+ static inline void outl_p(u32 value, unsigned long addr)
+ {
+ 	outl(value, addr);
+ }
+ #endif
+ 
+ /*
+  * {in,out}s{b,w,l}{,_p}() are variants of the above that repeatedly access a
+  * single I/O port multiple times.
+  */
+ 
+ #ifndef insb
+ #define insb insb
+ static inline void insb(unsigned long addr, void *buffer, unsigned int count)
+ {
+ 	readsb(PCI_IOBASE + addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef insw
+ #define insw insw
+ static inline void insw(unsigned long addr, void *buffer, unsigned int count)
+ {
+ 	readsw(PCI_IOBASE + addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef insl
+ #define insl insl
+ static inline void insl(unsigned long addr, void *buffer, unsigned int count)
+ {
+ 	readsl(PCI_IOBASE + addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef outsb
+ #define outsb outsb
+ static inline void outsb(unsigned long addr, const void *buffer,
+ 			 unsigned int count)
+ {
+ 	writesb(PCI_IOBASE + addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef outsw
+ #define outsw outsw
+ static inline void outsw(unsigned long addr, const void *buffer,
+ 			 unsigned int count)
+ {
+ 	writesw(PCI_IOBASE + addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef outsl
+ #define outsl outsl
+ static inline void outsl(unsigned long addr, const void *buffer,
+ 			 unsigned int count)
+ {
+ 	writesl(PCI_IOBASE + addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef insb_p
+ #define insb_p insb_p
+ static inline void insb_p(unsigned long addr, void *buffer, unsigned int count)
+ {
+ 	insb(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef insw_p
+ #define insw_p insw_p
+ static inline void insw_p(unsigned long addr, void *buffer, unsigned int count)
+ {
+ 	insw(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef insl_p
+ #define insl_p insl_p
+ static inline void insl_p(unsigned long addr, void *buffer, unsigned int count)
+ {
+ 	insl(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef outsb_p
+ #define outsb_p outsb_p
+ static inline void outsb_p(unsigned long addr, const void *buffer,
+ 			   unsigned int count)
+ {
+ 	outsb(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef outsw_p
+ #define outsw_p outsw_p
+ static inline void outsw_p(unsigned long addr, const void *buffer,
+ 			   unsigned int count)
+ {
+ 	outsw(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef outsl_p
+ #define outsl_p outsl_p
+ static inline void outsl_p(unsigned long addr, const void *buffer,
+ 			   unsigned int count)
+ {
+ 	outsl(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef CONFIG_GENERIC_IOMAP
+ #ifndef ioread8
+ #define ioread8 ioread8
+ static inline u8 ioread8(const volatile void __iomem *addr)
+ {
+ 	return readb(addr);
+ }
+ #endif
+ 
+ #ifndef ioread16
+ #define ioread16 ioread16
+ static inline u16 ioread16(const volatile void __iomem *addr)
+ {
+ 	return readw(addr);
+ }
+ #endif
+ 
+ #ifndef ioread32
+ #define ioread32 ioread32
+ static inline u32 ioread32(const volatile void __iomem *addr)
+ {
+ 	return readl(addr);
+ }
+ #endif
+ 
+ #ifndef iowrite8
+ #define iowrite8 iowrite8
+ static inline void iowrite8(u8 value, volatile void __iomem *addr)
+ {
+ 	writeb(value, addr);
+ }
+ #endif
+ 
+ #ifndef iowrite16
+ #define iowrite16 iowrite16
+ static inline void iowrite16(u16 value, volatile void __iomem *addr)
+ {
+ 	writew(value, addr);
+ }
+ #endif
+ 
+ #ifndef iowrite32
+ #define iowrite32 iowrite32
+ static inline void iowrite32(u32 value, volatile void __iomem *addr)
+ {
+ 	writel(value, addr);
+ }
+ #endif
+ 
+ #ifndef ioread16be
+ #define ioread16be ioread16be
+ static inline u16 ioread16be(const volatile void __iomem *addr)
+ {
+ 	return __be16_to_cpu(__raw_readw(addr));
+ }
+ #endif
+ 
+ #ifndef ioread32be
+ #define ioread32be ioread32be
+ static inline u32 ioread32be(const volatile void __iomem *addr)
+ {
+ 	return __be32_to_cpu(__raw_readl(addr));
+ }
+ #endif
+ 
+ #ifndef iowrite16be
+ #define iowrite16be iowrite16be
+ static inline void iowrite16be(u16 value, void volatile __iomem *addr)
+ {
+ 	__raw_writew(__cpu_to_be16(value), addr);
+ }
+ #endif
+ 
+ #ifndef iowrite32be
+ #define iowrite32be iowrite32be
+ static inline void iowrite32be(u32 value, volatile void __iomem *addr)
+ {
+ 	__raw_writel(__cpu_to_be32(value), addr);
+ }
+ #endif
+ 
+ #ifndef ioread8_rep
+ #define ioread8_rep ioread8_rep
+ static inline void ioread8_rep(const volatile void __iomem *addr, void *buffer,
+ 			       unsigned int count)
+ {
+ 	readsb(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef ioread16_rep
+ #define ioread16_rep ioread16_rep
+ static inline void ioread16_rep(const volatile void __iomem *addr,
+ 				void *buffer, unsigned int count)
+ {
+ 	readsw(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef ioread32_rep
+ #define ioread32_rep ioread32_rep
+ static inline void ioread32_rep(const volatile void __iomem *addr,
+ 				void *buffer, unsigned int count)
+ {
+ 	readsl(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef iowrite8_rep
+ #define iowrite8_rep iowrite8_rep
+ static inline void iowrite8_rep(volatile void __iomem *addr,
+ 				const void *buffer,
+ 				unsigned int count)
+ {
+ 	writesb(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef iowrite16_rep
+ #define iowrite16_rep iowrite16_rep
+ static inline void iowrite16_rep(volatile void __iomem *addr,
+ 				 const void *buffer,
+ 				 unsigned int count)
+ {
+ 	writesw(addr, buffer, count);
+ }
+ #endif
+ 
+ #ifndef iowrite32_rep
+ #define iowrite32_rep iowrite32_rep
+ static inline void iowrite32_rep(volatile void __iomem *addr,
+ 				 const void *buffer,
+ 				 unsigned int count)
+ {
+ 	writesl(addr, buffer, count);
+ }
+ #endif
+ #endif /* CONFIG_GENERIC_IOMAP */
+ 
++>>>>>>> 9ab3a7a0d2b4 (asm-generic/io.h: Implement generic {read,write}s*())
  #ifdef __KERNEL__
  
  #include <linux/vmalloc.h>
* Unmerged path include/asm-generic/io.h
