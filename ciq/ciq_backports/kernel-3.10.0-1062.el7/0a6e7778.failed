net/sched: allow flower to match tunnel options

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [net] sched: allow flower to match tunnel options (Ivan Vecera) [1672341]
Rebuild_FUZZ: 95.56%
commit-author Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
commit 0a6e77784f490912d81b92cfd48424541c04691e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0a6e7778.failed

Allow matching on options in Geneve tunnel headers.
This makes use of existing tunnel metadata support.

The options can be described in the form
CLASS:TYPE:DATA/CLASS_MASK:TYPE_MASK:DATA_MASK, where CLASS is
represented as a 16bit hexadecimal value, TYPE as an 8bit
hexadecimal value and DATA as a variable length hexadecimal value.

e.g.
 # ip link add name geneve0 type geneve dstport 0 external
 # tc qdisc add dev geneve0 ingress
 # tc filter add dev geneve0 protocol ip parent ffff: \
     flower \
       enc_src_ip 10.0.99.192 \
       enc_dst_ip 10.0.99.193 \
       enc_key_id 11 \
       geneve_opts 0102:80:1122334421314151/ffff:ff:ffffffffffffffff \
       ip_proto udp \
       action mirred egress redirect dev eth1

This patch adds support for matching Geneve options in the order
supplied by the user. This leads to an efficient implementation in
the software datapath (and in our opinion hardware datapaths that
offload this feature). It is also compatible with Geneve options
matching provided by the Open vSwitch kernel datapath which is
relevant here as the Flower classifier may be used as a mechanism
to program flows into hardware as a form of Open vSwitch datapath
offload (sometimes referred to as OVS-TC). The netlink
Kernel/Userspace API may be extended, for example by adding a flag,
if other matching options are desired, for example matching given
options in any order. This would require an implementation in the
TC software datapath. And be done in a way that drivers that
facilitate offload of the Flower classifier can reject or accept
such flows based on hardware datapath capabilities.

This approach was discussed and agreed on at Netconf 2017 in Seoul.

	Signed-off-by: Simon Horman <simon.horman@netronome.com>
	Signed-off-by: Pieter Jansen van Vuuren <pieter.jansenvanvuuren@netronome.com>
	Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0a6e77784f490912d81b92cfd48424541c04691e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_flower.c
diff --cc net/sched/cls_flower.c
index eb4e6a91f3e1,9da244235170..000000000000
--- a/net/sched/cls_flower.c
+++ b/net/sched/cls_flower.c
@@@ -564,8 -620,148 +581,147 @@@ static void fl_set_key_ip(struct nlatt
  	fl_set_key_val(tb, &key->ttl, ttl_key, &mask->ttl, ttl_mask, sizeof(key->ttl));
  }
  
+ static int fl_set_geneve_opt(const struct nlattr *nla, struct fl_flow_key *key,
+ 			     int depth, int option_len,
+ 			     struct netlink_ext_ack *extack)
+ {
+ 	struct nlattr *tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX + 1];
+ 	struct nlattr *class = NULL, *type = NULL, *data = NULL;
+ 	struct geneve_opt *opt;
+ 	int err, data_len = 0;
+ 
+ 	if (option_len > sizeof(struct geneve_opt))
+ 		data_len = option_len - sizeof(struct geneve_opt);
+ 
+ 	opt = (struct geneve_opt *)&key->enc_opts.data[key->enc_opts.len];
+ 	memset(opt, 0xff, option_len);
+ 	opt->length = data_len / 4;
+ 	opt->r1 = 0;
+ 	opt->r2 = 0;
+ 	opt->r3 = 0;
+ 
+ 	/* If no mask has been prodived we assume an exact match. */
+ 	if (!depth)
+ 		return sizeof(struct geneve_opt) + data_len;
+ 
+ 	if (nla_type(nla) != TCA_FLOWER_KEY_ENC_OPTS_GENEVE) {
+ 		NL_SET_ERR_MSG(extack, "Non-geneve option type for mask");
+ 		return -EINVAL;
+ 	}
+ 
+ 	err = nla_parse_nested(tb, TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX,
+ 			       nla, geneve_opt_policy, extack);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/* We are not allowed to omit any of CLASS, TYPE or DATA
+ 	 * fields from the key.
+ 	 */
+ 	if (!option_len &&
+ 	    (!tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS] ||
+ 	     !tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE] ||
+ 	     !tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA])) {
+ 		NL_SET_ERR_MSG(extack, "Missing tunnel key geneve option class, type or data");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Omitting any of CLASS, TYPE or DATA fields is allowed
+ 	 * for the mask.
+ 	 */
+ 	if (tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA]) {
+ 		int new_len = key->enc_opts.len;
+ 
+ 		data = tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA];
+ 		data_len = nla_len(data);
+ 		if (data_len < 4) {
+ 			NL_SET_ERR_MSG(extack, "Tunnel key geneve option data is less than 4 bytes long");
+ 			return -ERANGE;
+ 		}
+ 		if (data_len % 4) {
+ 			NL_SET_ERR_MSG(extack, "Tunnel key geneve option data is not a multiple of 4 bytes long");
+ 			return -ERANGE;
+ 		}
+ 
+ 		new_len += sizeof(struct geneve_opt) + data_len;
+ 		BUILD_BUG_ON(FLOW_DIS_TUN_OPTS_MAX != IP_TUNNEL_OPTS_MAX);
+ 		if (new_len > FLOW_DIS_TUN_OPTS_MAX) {
+ 			NL_SET_ERR_MSG(extack, "Tunnel options exceeds max size");
+ 			return -ERANGE;
+ 		}
+ 		opt->length = data_len / 4;
+ 		memcpy(opt->opt_data, nla_data(data), data_len);
+ 	}
+ 
+ 	if (tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS]) {
+ 		class = tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS];
+ 		opt->opt_class = nla_get_be16(class);
+ 	}
+ 
+ 	if (tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE]) {
+ 		type = tb[TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE];
+ 		opt->type = nla_get_u8(type);
+ 	}
+ 
+ 	return sizeof(struct geneve_opt) + data_len;
+ }
+ 
+ static int fl_set_enc_opt(struct nlattr **tb, struct fl_flow_key *key,
+ 			  struct fl_flow_key *mask,
+ 			  struct netlink_ext_ack *extack)
+ {
+ 	const struct nlattr *nla_enc_key, *nla_opt_key, *nla_opt_msk = NULL;
+ 	int option_len, key_depth, msk_depth = 0;
+ 
+ 	nla_enc_key = nla_data(tb[TCA_FLOWER_KEY_ENC_OPTS]);
+ 
+ 	if (tb[TCA_FLOWER_KEY_ENC_OPTS_MASK]) {
+ 		nla_opt_msk = nla_data(tb[TCA_FLOWER_KEY_ENC_OPTS_MASK]);
+ 		msk_depth = nla_len(tb[TCA_FLOWER_KEY_ENC_OPTS_MASK]);
+ 	}
+ 
+ 	nla_for_each_attr(nla_opt_key, nla_enc_key,
+ 			  nla_len(tb[TCA_FLOWER_KEY_ENC_OPTS]), key_depth) {
+ 		switch (nla_type(nla_opt_key)) {
+ 		case TCA_FLOWER_KEY_ENC_OPTS_GENEVE:
+ 			option_len = 0;
+ 			key->enc_opts.dst_opt_type = TUNNEL_GENEVE_OPT;
+ 			option_len = fl_set_geneve_opt(nla_opt_key, key,
+ 						       key_depth, option_len,
+ 						       extack);
+ 			if (option_len < 0)
+ 				return option_len;
+ 
+ 			key->enc_opts.len += option_len;
+ 			/* At the same time we need to parse through the mask
+ 			 * in order to verify exact and mask attribute lengths.
+ 			 */
+ 			mask->enc_opts.dst_opt_type = TUNNEL_GENEVE_OPT;
+ 			option_len = fl_set_geneve_opt(nla_opt_msk, mask,
+ 						       msk_depth, option_len,
+ 						       extack);
+ 			if (option_len < 0)
+ 				return option_len;
+ 
+ 			mask->enc_opts.len += option_len;
+ 			if (key->enc_opts.len != mask->enc_opts.len) {
+ 				NL_SET_ERR_MSG(extack, "Key and mask miss aligned");
+ 				return -EINVAL;
+ 			}
+ 
+ 			if (msk_depth)
+ 				nla_opt_msk = nla_next(nla_opt_msk, &msk_depth);
+ 			break;
+ 		default:
+ 			NL_SET_ERR_MSG(extack, "Unknown tunnel option type");
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
  static int fl_set_key(struct net *net, struct nlattr **tb,
 -		      struct fl_flow_key *key, struct fl_flow_key *mask,
 -		      struct netlink_ext_ack *extack)
 +		      struct fl_flow_key *key, struct fl_flow_key *mask)
  {
  	__be16 ethertype;
  	int ret = 0;
@@@ -819,44 -1020,83 +981,46 @@@ static void fl_init_dissector(struct cl
  
  	FL_KEY_SET(keys, cnt, FLOW_DISSECTOR_KEY_CONTROL, control);
  	FL_KEY_SET(keys, cnt, FLOW_DISSECTOR_KEY_BASIC, basic);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_ETH_ADDRS, eth);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_IPV4_ADDRS, ipv4);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_IPV6_ADDRS, ipv6);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_PORTS, tp);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_IP, ip);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_TCP, tcp);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_ICMP, icmp);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_ARP, arp);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_MPLS, mpls);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_VLAN, vlan);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_CVLAN, cvlan);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_ENC_KEYID, enc_key_id);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS, enc_ipv4);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS, enc_ipv6);
 -	if (FL_KEY_IS_MASKED(mask, enc_ipv4) ||
 -	    FL_KEY_IS_MASKED(mask, enc_ipv6))
 +	if (FL_KEY_IS_MASKED(&mask->key, enc_ipv4) ||
 +	    FL_KEY_IS_MASKED(&mask->key, enc_ipv6))
  		FL_KEY_SET(keys, cnt, FLOW_DISSECTOR_KEY_ENC_CONTROL,
  			   enc_control);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_ENC_PORTS, enc_tp);
 -	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
 +	FL_KEY_SET_IF_MASKED(&mask->key, keys, cnt,
  			     FLOW_DISSECTOR_KEY_ENC_IP, enc_ip);
+ 	FL_KEY_SET_IF_MASKED(mask, keys, cnt,
+ 			     FLOW_DISSECTOR_KEY_ENC_OPTS, enc_opts);
  
 -	skb_flow_dissector_init(dissector, keys, cnt);
 -}
 -
 -static struct fl_flow_mask *fl_create_new_mask(struct cls_fl_head *head,
 -					       struct fl_flow_mask *mask)
 -{
 -	struct fl_flow_mask *newmask;
 -	int err;
 -
 -	newmask = kzalloc(sizeof(*newmask), GFP_KERNEL);
 -	if (!newmask)
 -		return ERR_PTR(-ENOMEM);
 -
 -	fl_mask_copy(newmask, mask);
 -
 -	err = fl_init_mask_hashtable(newmask);
 -	if (err)
 -		goto errout_free;
 -
 -	fl_init_dissector(&newmask->dissector, &newmask->key);
 -
 -	INIT_LIST_HEAD_RCU(&newmask->filters);
 -
 -	err = rhashtable_insert_fast(&head->ht, &newmask->ht_node,
 -				     mask_ht_params);
 -	if (err)
 -		goto errout_destroy;
 -
 -	list_add_tail_rcu(&newmask->list, &head->masks);
 -
 -	return newmask;
 -
 -errout_destroy:
 -	rhashtable_destroy(&newmask->ht);
 -errout_free:
 -	kfree(newmask);
 -
 -	return ERR_PTR(err);
 +	skb_flow_dissector_init(&head->dissector, keys, cnt);
  }
  
  static int fl_check_assign_mask(struct cls_fl_head *head,
@@@ -1206,30 -1578,86 +1370,112 @@@ static int fl_dump_key_flags(struct sk_
  	return nla_put(skb, TCA_FLOWER_KEY_FLAGS_MASK, 4, &_mask);
  }
  
++<<<<<<< HEAD
 +static int fl_dump(struct net *net, struct tcf_proto *tp, void *fh,
 +		   struct sk_buff *skb, struct tcmsg *t)
++=======
+ static int fl_dump_key_geneve_opt(struct sk_buff *skb,
+ 				  struct flow_dissector_key_enc_opts *enc_opts)
+ {
+ 	struct geneve_opt *opt;
+ 	struct nlattr *nest;
+ 	int opt_off = 0;
+ 
+ 	nest = nla_nest_start(skb, TCA_FLOWER_KEY_ENC_OPTS_GENEVE);
+ 	if (!nest)
+ 		goto nla_put_failure;
+ 
+ 	while (enc_opts->len > opt_off) {
+ 		opt = (struct geneve_opt *)&enc_opts->data[opt_off];
+ 
+ 		if (nla_put_be16(skb, TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS,
+ 				 opt->opt_class))
+ 			goto nla_put_failure;
+ 		if (nla_put_u8(skb, TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE,
+ 			       opt->type))
+ 			goto nla_put_failure;
+ 		if (nla_put(skb, TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA,
+ 			    opt->length * 4, opt->opt_data))
+ 			goto nla_put_failure;
+ 
+ 		opt_off += sizeof(struct geneve_opt) + opt->length * 4;
+ 	}
+ 	nla_nest_end(skb, nest);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	nla_nest_cancel(skb, nest);
+ 	return -EMSGSIZE;
+ }
+ 
+ static int fl_dump_key_options(struct sk_buff *skb, int enc_opt_type,
+ 			       struct flow_dissector_key_enc_opts *enc_opts)
+ {
+ 	struct nlattr *nest;
+ 	int err;
+ 
+ 	if (!enc_opts->len)
+ 		return 0;
+ 
+ 	nest = nla_nest_start(skb, enc_opt_type);
+ 	if (!nest)
+ 		goto nla_put_failure;
+ 
+ 	switch (enc_opts->dst_opt_type) {
+ 	case TUNNEL_GENEVE_OPT:
+ 		err = fl_dump_key_geneve_opt(skb, enc_opts);
+ 		if (err)
+ 			goto nla_put_failure;
+ 		break;
+ 	default:
+ 		goto nla_put_failure;
+ 	}
+ 	nla_nest_end(skb, nest);
+ 	return 0;
+ 
+ nla_put_failure:
+ 	nla_nest_cancel(skb, nest);
+ 	return -EMSGSIZE;
+ }
+ 
+ static int fl_dump_key_enc_opt(struct sk_buff *skb,
+ 			       struct flow_dissector_key_enc_opts *key_opts,
+ 			       struct flow_dissector_key_enc_opts *msk_opts)
+ {
+ 	int err;
+ 
+ 	err = fl_dump_key_options(skb, TCA_FLOWER_KEY_ENC_OPTS, key_opts);
+ 	if (err)
+ 		return err;
+ 
+ 	return fl_dump_key_options(skb, TCA_FLOWER_KEY_ENC_OPTS_MASK, msk_opts);
+ }
+ 
+ static int fl_dump_key(struct sk_buff *skb, struct net *net,
+ 		       struct fl_flow_key *key, struct fl_flow_key *mask)
++>>>>>>> 0a6e77784f49 (net/sched: allow flower to match tunnel options)
  {
 +	struct cls_fl_head *head = rtnl_dereference(tp->root);
 +	struct cls_fl_filter *f = fh;
 +	struct nlattr *nest;
 +	struct fl_flow_key *key, *mask;
 +
 +	if (!f)
 +		return skb->len;
 +
 +	t->tcm_handle = f->handle;
 +
 +	nest = nla_nest_start(skb, TCA_OPTIONS);
 +	if (!nest)
 +		goto nla_put_failure;
 +
 +	if (f->res.classid &&
 +	    nla_put_u32(skb, TCA_FLOWER_CLASSID, f->res.classid))
 +		goto nla_put_failure;
 +
 +	key = &f->key;
 +	mask = &head->mask.key;
 +
  	if (mask->indev_ifindex) {
  		struct net_device *dev;
  
diff --git a/include/uapi/linux/pkt_cls.h b/include/uapi/linux/pkt_cls.h
index 447180804df1..c9f98d4ca360 100644
--- a/include/uapi/linux/pkt_cls.h
+++ b/include/uapi/linux/pkt_cls.h
@@ -510,11 +510,37 @@ enum {
 	TCA_FLOWER_KEY_ENC_IP_TTL,	/* u8 */
 	TCA_FLOWER_KEY_ENC_IP_TTL_MASK,	/* u8 */
 
+	TCA_FLOWER_KEY_ENC_OPTS,
+	TCA_FLOWER_KEY_ENC_OPTS_MASK,
+
 	__TCA_FLOWER_MAX,
 };
 
 #define TCA_FLOWER_MAX (__TCA_FLOWER_MAX - 1)
 
+enum {
+	TCA_FLOWER_KEY_ENC_OPTS_UNSPEC,
+	TCA_FLOWER_KEY_ENC_OPTS_GENEVE, /* Nested
+					 * TCA_FLOWER_KEY_ENC_OPT_GENEVE_
+					 * attributes
+					 */
+	__TCA_FLOWER_KEY_ENC_OPTS_MAX,
+};
+
+#define TCA_FLOWER_KEY_ENC_OPTS_MAX (__TCA_FLOWER_KEY_ENC_OPTS_MAX - 1)
+
+enum {
+	TCA_FLOWER_KEY_ENC_OPT_GENEVE_UNSPEC,
+	TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS,            /* u16 */
+	TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE,             /* u8 */
+	TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA,             /* 4 to 128 bytes */
+
+	__TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX,
+};
+
+#define TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX \
+		(__TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX - 1)
+
 enum {
 	TCA_FLOWER_KEY_FLAGS_IS_FRAGMENT = (1 << 0),
 	TCA_FLOWER_KEY_FLAGS_FRAG_IS_FIRST = (1 << 1),
* Unmerged path net/sched/cls_flower.c
