IB/mlx5: Add counters create and destroy support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Raed Salem <raeds@mellanox.com>
commit b29e2a1309e38cd1afa598a54f3ccb4e4d2ee01c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b29e2a13.failed

This patch implements the device counters create and destroy APIs and
introducing some internal management structures.

Downstream patches in this series will add the functionality to support
flow counters binding and reading.

	Reviewed-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Raed Salem <raeds@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit b29e2a1309e38cd1afa598a54f3ccb4e4d2ee01c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
#	drivers/infiniband/hw/mlx5/mlx5_ib.h
diff --cc drivers/infiniband/hw/mlx5/main.c
index 1726b9447b75,81471013b776..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -4766,7 -4965,69 +4766,73 @@@ static void mlx5_ib_cleanup_multiport_m
  	mlx5_nic_vport_disable_roce(dev->mdev);
  }
  
++<<<<<<< HEAD
 +static void mlx5_ib_stage_init_cleanup(struct mlx5_ib_dev *dev)
++=======
+ ADD_UVERBS_ATTRIBUTES_SIMPLE(mlx5_ib_dm, UVERBS_OBJECT_DM,
+ 			     UVERBS_METHOD_DM_ALLOC,
+ 			     &UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_START_OFFSET,
+ 						  UVERBS_ATTR_TYPE(u64),
+ 						  UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
+ 			     &UVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_ALLOC_DM_RESP_PAGE_INDEX,
+ 						  UVERBS_ATTR_TYPE(u16),
+ 						  UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+ 
+ ADD_UVERBS_ATTRIBUTES_SIMPLE(mlx5_ib_flow_action, UVERBS_OBJECT_FLOW_ACTION,
+ 			     UVERBS_METHOD_FLOW_ACTION_ESP_CREATE,
+ 			     &UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_FLOW_ACTION_FLAGS,
+ 						 UVERBS_ATTR_TYPE(u64),
+ 						 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)));
+ 
+ #define NUM_TREES	2
+ static int populate_specs_root(struct mlx5_ib_dev *dev)
+ {
+ 	const struct uverbs_object_tree_def *default_root[NUM_TREES + 1] = {
+ 		uverbs_default_get_objects()};
+ 	size_t num_trees = 1;
+ 
+ 	if (mlx5_accel_ipsec_device_caps(dev->mdev) & MLX5_ACCEL_IPSEC_CAP_DEVICE &&
+ 	    !WARN_ON(num_trees >= ARRAY_SIZE(default_root)))
+ 		default_root[num_trees++] = &mlx5_ib_flow_action;
+ 
+ 	if (MLX5_CAP_DEV_MEM(dev->mdev, memic) &&
+ 	    !WARN_ON(num_trees >= ARRAY_SIZE(default_root)))
+ 		default_root[num_trees++] = &mlx5_ib_dm;
+ 
+ 	dev->ib_dev.specs_root =
+ 		uverbs_alloc_spec_tree(num_trees, default_root);
+ 
+ 	return PTR_ERR_OR_ZERO(dev->ib_dev.specs_root);
+ }
+ 
+ static void depopulate_specs_root(struct mlx5_ib_dev *dev)
+ {
+ 	uverbs_free_spec_tree(dev->ib_dev.specs_root);
+ }
+ 
+ static int mlx5_ib_destroy_counters(struct ib_counters *counters)
+ {
+ 	struct mlx5_ib_mcounters *mcounters = to_mcounters(counters);
+ 
+ 	kfree(mcounters);
+ 
+ 	return 0;
+ }
+ 
+ static struct ib_counters *mlx5_ib_create_counters(struct ib_device *device,
+ 						   struct uverbs_attr_bundle *attrs)
+ {
+ 	struct mlx5_ib_mcounters *mcounters;
+ 
+ 	mcounters = kzalloc(sizeof(*mcounters), GFP_KERNEL);
+ 	if (!mcounters)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	return &mcounters->ibcntrs;
+ }
+ 
+ void mlx5_ib_stage_init_cleanup(struct mlx5_ib_dev *dev)
++>>>>>>> b29e2a1309e3 (IB/mlx5: Add counters create and destroy support)
  {
  	mlx5_ib_cleanup_multiport_master(dev);
  #ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING
@@@ -4968,6 -5266,12 +5034,15 @@@ static int mlx5_ib_stage_caps_init(stru
  	dev->ib_dev.uverbs_ex_cmd_mask |=
  			(1ull << IB_USER_VERBS_EX_CMD_CREATE_FLOW) |
  			(1ull << IB_USER_VERBS_EX_CMD_DESTROY_FLOW);
++<<<<<<< HEAD
++=======
+ 	dev->ib_dev.create_flow_action_esp = mlx5_ib_create_flow_action_esp;
+ 	dev->ib_dev.destroy_flow_action = mlx5_ib_destroy_flow_action;
+ 	dev->ib_dev.modify_flow_action_esp = mlx5_ib_modify_flow_action_esp;
+ 	dev->ib_dev.driver_id = RDMA_DRIVER_MLX5;
+ 	dev->ib_dev.create_counters = mlx5_ib_create_counters;
+ 	dev->ib_dev.destroy_counters = mlx5_ib_destroy_counters;
++>>>>>>> b29e2a1309e3 (IB/mlx5: Add counters create and destroy support)
  
  	err = init_node_data(dev);
  	if (err)
diff --cc drivers/infiniband/hw/mlx5/mlx5_ib.h
index 7653bfad9f25,fd27ec1aed08..000000000000
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@@ -772,6 -797,32 +772,35 @@@ struct mlx5_ib_multiport_info 
  	bool unaffiliate;
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5_ib_flow_action {
+ 	struct ib_flow_action		ib_action;
+ 	union {
+ 		struct {
+ 			u64			    ib_flags;
+ 			struct mlx5_accel_esp_xfrm *ctx;
+ 		} esp_aes_gcm;
+ 	};
+ };
+ 
+ struct mlx5_memic {
+ 	struct mlx5_core_dev *dev;
+ 	spinlock_t		memic_lock;
+ 	DECLARE_BITMAP(memic_alloc_pages, MLX5_MAX_MEMIC_PAGES);
+ };
+ 
+ struct mlx5_ib_mcounters {
+ 	struct ib_counters ibcntrs;
+ };
+ 
+ static inline struct mlx5_ib_mcounters *
+ to_mcounters(struct ib_counters *ibcntrs)
+ {
+ 	return container_of(ibcntrs, struct mlx5_ib_mcounters, ibcntrs);
+ }
+ 
++>>>>>>> b29e2a1309e3 (IB/mlx5: Add counters create and destroy support)
  struct mlx5_ib_dev {
  	struct ib_device		ib_dev;
  	struct mlx5_core_dev		*mdev;
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path drivers/infiniband/hw/mlx5/mlx5_ib.h
