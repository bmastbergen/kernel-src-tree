perf stat: Pass a 'struct perf_stat_config' argument to global print functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit 6ca9a082b1908ff7f8adedf08166043b83b266f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6ca9a082.failed

Add 'struct perf_stat_config' argument to the global print functions, so
that these functions can be used out of the 'perf stat' command code.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20180830063252.23729-20-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 6ca9a082b1908ff7f8adedf08166043b83b266f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-script.c
#	tools/perf/builtin-stat.c
#	tools/perf/util/stat-shadow.c
diff --cc tools/perf/builtin-script.c
index a7b5efbdcaf1,6176bae177c2..000000000000
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@@ -1403,6 -1537,90 +1403,93 @@@ static int data_src__fprintf(u64 data_s
  	return fprintf(fp, "%-*s", maxlen, out);
  }
  
++<<<<<<< HEAD
++=======
+ struct metric_ctx {
+ 	struct perf_sample	*sample;
+ 	struct thread		*thread;
+ 	struct perf_evsel	*evsel;
+ 	FILE 			*fp;
+ };
+ 
+ static void script_print_metric(struct perf_stat_config *config __maybe_unused,
+ 				void *ctx, const char *color,
+ 			        const char *fmt,
+ 			        const char *unit, double val)
+ {
+ 	struct metric_ctx *mctx = ctx;
+ 
+ 	if (!fmt)
+ 		return;
+ 	perf_sample__fprintf_start(mctx->sample, mctx->thread, mctx->evsel,
+ 				   PERF_RECORD_SAMPLE, mctx->fp);
+ 	fputs("\tmetric: ", mctx->fp);
+ 	if (color)
+ 		color_fprintf(mctx->fp, color, fmt, val);
+ 	else
+ 		printf(fmt, val);
+ 	fprintf(mctx->fp, " %s\n", unit);
+ }
+ 
+ static void script_new_line(struct perf_stat_config *config __maybe_unused,
+ 			    void *ctx)
+ {
+ 	struct metric_ctx *mctx = ctx;
+ 
+ 	perf_sample__fprintf_start(mctx->sample, mctx->thread, mctx->evsel,
+ 				   PERF_RECORD_SAMPLE, mctx->fp);
+ 	fputs("\tmetric: ", mctx->fp);
+ }
+ 
+ static void perf_sample__fprint_metric(struct perf_script *script,
+ 				       struct thread *thread,
+ 				       struct perf_evsel *evsel,
+ 				       struct perf_sample *sample,
+ 				       FILE *fp)
+ {
+ 	struct perf_stat_output_ctx ctx = {
+ 		.print_metric = script_print_metric,
+ 		.new_line = script_new_line,
+ 		.ctx = &(struct metric_ctx) {
+ 				.sample = sample,
+ 				.thread = thread,
+ 				.evsel  = evsel,
+ 				.fp     = fp,
+ 			 },
+ 		.force_header = false,
+ 	};
+ 	struct perf_evsel *ev2;
+ 	static bool init;
+ 	u64 val;
+ 
+ 	if (!init) {
+ 		perf_stat__init_shadow_stats();
+ 		init = true;
+ 	}
+ 	if (!evsel->stats)
+ 		perf_evlist__alloc_stats(script->session->evlist, false);
+ 	if (evsel_script(evsel->leader)->gnum++ == 0)
+ 		perf_stat__reset_shadow_stats();
+ 	val = sample->period * evsel->scale;
+ 	perf_stat__update_shadow_stats(evsel,
+ 				       val,
+ 				       sample->cpu,
+ 				       &rt_stat);
+ 	evsel_script(evsel)->val = val;
+ 	if (evsel_script(evsel->leader)->gnum == evsel->leader->nr_members) {
+ 		for_each_group_member (ev2, evsel->leader) {
+ 			perf_stat__print_shadow_stats(&stat_config, ev2,
+ 						      evsel_script(ev2)->val,
+ 						      sample->cpu,
+ 						      &ctx,
+ 						      NULL,
+ 						      &rt_stat);
+ 		}
+ 		evsel_script(evsel->leader)->gnum = 0;
+ 	}
+ }
+ 
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  static void process_event(struct perf_script *script,
  			  struct perf_sample *sample, struct perf_evsel *evsel,
  			  struct addr_location *al,
diff --cc tools/perf/builtin-stat.c
index a3a835604d08,7a3361308e61..000000000000
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@@ -797,14 -694,15 +797,15 @@@ static void print_noise(struct perf_evs
  		return;
  
  	ps = evsel->stats;
 -	print_noise_pct(config, stddev_stats(&ps->res_stats[0]), avg);
 +	print_noise_pct(stddev_stats(&ps->res_stats[0]), avg);
  }
  
- static void aggr_printout(struct perf_evsel *evsel, int id, int nr)
+ static void aggr_printout(struct perf_stat_config *config,
+ 			  struct perf_evsel *evsel, int id, int nr)
  {
- 	switch (stat_config.aggr_mode) {
+ 	switch (config->aggr_mode) {
  	case AGGR_CORE:
- 		fprintf(stat_config.output, "S%d-C%*d%s%*d%s",
+ 		fprintf(config->output, "S%d-C%*d%s%*d%s",
  			cpu_map__id_to_socket(id),
  			csv_output ? 0 : -8,
  			cpu_map__id_to_cpu(id),
@@@ -1162,12 -1043,12 +1172,12 @@@ static void printout(int id, int nr, st
  	}
  	if (run == 0 || ena == 0 || counter->counts->scaled == -1) {
  		if (metric_only) {
- 			pm(&os, NULL, "", "", 0);
+ 			pm(config, &os, NULL, "", "", 0);
  			return;
  		}
- 		aggr_printout(counter, id, nr);
+ 		aggr_printout(config, counter, id, nr);
  
 -		fprintf(config->output, "%*s%s",
 +		fprintf(stat_config.output, "%*s%s",
  			csv_output ? 0 : 18,
  			counter->supported ? CNTR_NOT_COUNTED : CNTR_NOT_SUPPORTED,
  			csv_sep);
@@@ -1191,20 -1072,16 +1201,31 @@@
  				csv_sep, counter->cgrp->name);
  
  		if (!csv_output)
++<<<<<<< HEAD
 +			pm(&os, NULL, NULL, "", 0);
 +		print_noise(counter, noise);
 +		print_running(run, ena);
++=======
+ 			pm(config, &os, NULL, NULL, "", 0);
+ 		print_noise(config, counter, noise);
+ 		print_running(config, run, ena);
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  		if (csv_output)
- 			pm(&os, NULL, NULL, "", 0);
+ 			pm(config, &os, NULL, NULL, "", 0);
  		return;
  	}
  
++<<<<<<< HEAD
 +	if (metric_only)
 +		/* nothing */;
 +	else if (nsec_counter(counter))
 +		nsec_printout(id, nr, counter, uval);
 +	else
 +		abs_printout(id, nr, counter, uval);
++=======
+ 	if (!metric_only)
+ 		abs_printout(config, id, nr, counter, uval);
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  
  	out.print_metric = pm;
  	out.new_line = nl;
@@@ -1212,16 -1089,16 +1233,16 @@@
  	out.force_header = false;
  
  	if (csv_output && !metric_only) {
 -		print_noise(config, counter, noise);
 -		print_running(config, run, ena);
 +		print_noise(counter, noise);
 +		print_running(run, ena);
  	}
  
- 	perf_stat__print_shadow_stats(counter, uval,
+ 	perf_stat__print_shadow_stats(config, counter, uval,
  				first_shadow_cpu(counter, id),
 -				&out, &metric_events, st);
 +				&out, &metric_events);
  	if (!csv_output && !metric_only) {
 -		print_noise(config, counter, noise);
 -		print_running(config, run, ena);
 +		print_noise(counter, noise);
 +		print_running(run, ena);
  	}
  }
  
@@@ -1583,17 -1531,19 +1604,17 @@@ static void print_metric_headers(const 
  		out.new_line = new_line_metric;
  		out.force_header = true;
  		os.evsel = counter;
- 		perf_stat__print_shadow_stats(counter, 0,
+ 		perf_stat__print_shadow_stats(config, counter, 0,
  					      0,
  					      &out,
 -					      &metric_events,
 -					      &rt_stat);
 +					      &metric_events);
  	}
 -	fputc('\n', config->output);
 +	fputc('\n', stat_config.output);
  }
  
 -static void print_interval(struct perf_stat_config *config,
 -			   char *prefix, struct timespec *ts)
 +static void print_interval(char *prefix, struct timespec *ts)
  {
 -	FILE *output = config->output;
 +	FILE *output = stat_config.output;
  	static int num_print_interval;
  
  	if (interval_clear)
diff --cc tools/perf/util/stat-shadow.c
index b29877d9b2f4,8ad32763cfff..000000000000
--- a/tools/perf/util/stat-shadow.c
+++ b/tools/perf/util/stat-shadow.c
@@@ -394,9 -386,35 +394,38 @@@ void perf_stat__collect_metric_expr(str
  	}
  }
  
++<<<<<<< HEAD
 +static void print_stalled_cycles_frontend(int cpu,
++=======
+ static double runtime_stat_avg(struct runtime_stat *st,
+ 			       enum stat_type type, int ctx, int cpu)
+ {
+ 	struct saved_value *v;
+ 
+ 	v = saved_value_lookup(NULL, cpu, false, type, ctx, st);
+ 	if (!v)
+ 		return 0.0;
+ 
+ 	return avg_stats(&v->stats);
+ }
+ 
+ static double runtime_stat_n(struct runtime_stat *st,
+ 			     enum stat_type type, int ctx, int cpu)
+ {
+ 	struct saved_value *v;
+ 
+ 	v = saved_value_lookup(NULL, cpu, false, type, ctx, st);
+ 	if (!v)
+ 		return 0.0;
+ 
+ 	return v->stats.n;
+ }
+ 
+ static void print_stalled_cycles_frontend(struct perf_stat_config *config,
+ 					  int cpu,
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  					  struct perf_evsel *evsel, double avg,
 -					  struct perf_stat_output_ctx *out,
 -					  struct runtime_stat *st)
 +					  struct perf_stat_output_ctx *out)
  {
  	double total, ratio = 0.0;
  	const char *color;
@@@ -410,15 -428,17 +439,16 @@@
  	color = get_ratio_color(GRC_STALLED_CYCLES_FE, ratio);
  
  	if (ratio)
- 		out->print_metric(out->ctx, color, "%7.2f%%", "frontend cycles idle",
+ 		out->print_metric(config, out->ctx, color, "%7.2f%%", "frontend cycles idle",
  				  ratio);
  	else
- 		out->print_metric(out->ctx, NULL, NULL, "frontend cycles idle", 0);
+ 		out->print_metric(config, out->ctx, NULL, NULL, "frontend cycles idle", 0);
  }
  
- static void print_stalled_cycles_backend(int cpu,
+ static void print_stalled_cycles_backend(struct perf_stat_config *config,
+ 					 int cpu,
  					 struct perf_evsel *evsel, double avg,
 -					 struct perf_stat_output_ctx *out,
 -					 struct runtime_stat *st)
 +					 struct perf_stat_output_ctx *out)
  {
  	double total, ratio = 0.0;
  	const char *color;
@@@ -431,13 -451,15 +461,14 @@@
  
  	color = get_ratio_color(GRC_STALLED_CYCLES_BE, ratio);
  
- 	out->print_metric(out->ctx, color, "%7.2f%%", "backend cycles idle", ratio);
+ 	out->print_metric(config, out->ctx, color, "%7.2f%%", "backend cycles idle", ratio);
  }
  
- static void print_branch_misses(int cpu,
+ static void print_branch_misses(struct perf_stat_config *config,
+ 				int cpu,
  				struct perf_evsel *evsel,
  				double avg,
 -				struct perf_stat_output_ctx *out,
 -				struct runtime_stat *st)
 +				struct perf_stat_output_ctx *out)
  {
  	double total, ratio = 0.0;
  	const char *color;
@@@ -450,13 -472,16 +481,14 @@@
  
  	color = get_ratio_color(GRC_CACHE_MISSES, ratio);
  
- 	out->print_metric(out->ctx, color, "%7.2f%%", "of all branches", ratio);
+ 	out->print_metric(config, out->ctx, color, "%7.2f%%", "of all branches", ratio);
  }
  
- static void print_l1_dcache_misses(int cpu,
+ static void print_l1_dcache_misses(struct perf_stat_config *config,
+ 				   int cpu,
  				   struct perf_evsel *evsel,
  				   double avg,
 -				   struct perf_stat_output_ctx *out,
 -				   struct runtime_stat *st)
 -
 +				   struct perf_stat_output_ctx *out)
  {
  	double total, ratio = 0.0;
  	const char *color;
@@@ -469,13 -494,16 +501,14 @@@
  
  	color = get_ratio_color(GRC_CACHE_MISSES, ratio);
  
- 	out->print_metric(out->ctx, color, "%7.2f%%", "of all L1-dcache hits", ratio);
+ 	out->print_metric(config, out->ctx, color, "%7.2f%%", "of all L1-dcache hits", ratio);
  }
  
- static void print_l1_icache_misses(int cpu,
+ static void print_l1_icache_misses(struct perf_stat_config *config,
+ 				   int cpu,
  				   struct perf_evsel *evsel,
  				   double avg,
 -				   struct perf_stat_output_ctx *out,
 -				   struct runtime_stat *st)
 -
 +				   struct perf_stat_output_ctx *out)
  {
  	double total, ratio = 0.0;
  	const char *color;
@@@ -487,13 -515,15 +520,14 @@@
  		ratio = avg / total * 100.0;
  
  	color = get_ratio_color(GRC_CACHE_MISSES, ratio);
- 	out->print_metric(out->ctx, color, "%7.2f%%", "of all L1-icache hits", ratio);
+ 	out->print_metric(config, out->ctx, color, "%7.2f%%", "of all L1-icache hits", ratio);
  }
  
- static void print_dtlb_cache_misses(int cpu,
+ static void print_dtlb_cache_misses(struct perf_stat_config *config,
+ 				    int cpu,
  				    struct perf_evsel *evsel,
  				    double avg,
 -				    struct perf_stat_output_ctx *out,
 -				    struct runtime_stat *st)
 +				    struct perf_stat_output_ctx *out)
  {
  	double total, ratio = 0.0;
  	const char *color;
@@@ -505,13 -535,15 +539,14 @@@
  		ratio = avg / total * 100.0;
  
  	color = get_ratio_color(GRC_CACHE_MISSES, ratio);
- 	out->print_metric(out->ctx, color, "%7.2f%%", "of all dTLB cache hits", ratio);
+ 	out->print_metric(config, out->ctx, color, "%7.2f%%", "of all dTLB cache hits", ratio);
  }
  
- static void print_itlb_cache_misses(int cpu,
+ static void print_itlb_cache_misses(struct perf_stat_config *config,
+ 				    int cpu,
  				    struct perf_evsel *evsel,
  				    double avg,
 -				    struct perf_stat_output_ctx *out,
 -				    struct runtime_stat *st)
 +				    struct perf_stat_output_ctx *out)
  {
  	double total, ratio = 0.0;
  	const char *color;
@@@ -523,13 -555,15 +558,14 @@@
  		ratio = avg / total * 100.0;
  
  	color = get_ratio_color(GRC_CACHE_MISSES, ratio);
- 	out->print_metric(out->ctx, color, "%7.2f%%", "of all iTLB cache hits", ratio);
+ 	out->print_metric(config, out->ctx, color, "%7.2f%%", "of all iTLB cache hits", ratio);
  }
  
- static void print_ll_cache_misses(int cpu,
+ static void print_ll_cache_misses(struct perf_stat_config *config,
+ 				  int cpu,
  				  struct perf_evsel *evsel,
  				  double avg,
 -				  struct perf_stat_output_ctx *out,
 -				  struct runtime_stat *st)
 +				  struct perf_stat_output_ctx *out)
  {
  	double total, ratio = 0.0;
  	const char *color;
@@@ -645,8 -682,10 +681,15 @@@ static double td_be_bound(int ctx, int 
  	return sanitize_val(1.0 - sum);
  }
  
++<<<<<<< HEAD
 +static void print_smi_cost(int cpu, struct perf_evsel *evsel,
 +			   struct perf_stat_output_ctx *out)
++=======
+ static void print_smi_cost(struct perf_stat_config *config,
+ 			   int cpu, struct perf_evsel *evsel,
+ 			   struct perf_stat_output_ctx *out,
+ 			   struct runtime_stat *st)
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  {
  	double smi_num, aperf, cycles, cost = 0.0;
  	int ctx = evsel_context(evsel);
@@@ -715,13 -757,15 +759,14 @@@ static void generic_metric(struct perf_
  				     out->force_header ?
  				     (metric_name ? metric_name : name) : "", 0);
  	} else
- 		print_metric(ctxp, NULL, NULL, "", 0);
+ 		print_metric(config, ctxp, NULL, NULL, "", 0);
  }
  
- void perf_stat__print_shadow_stats(struct perf_evsel *evsel,
+ void perf_stat__print_shadow_stats(struct perf_stat_config *config,
+ 				   struct perf_evsel *evsel,
  				   double avg, int cpu,
  				   struct perf_stat_output_ctx *out,
 -				   struct rblist *metric_events,
 -				   struct runtime_stat *st)
 +				   struct rblist *metric_events)
  {
  	void *ctxp = out->ctx;
  	print_metric_t print_metric = out->print_metric;
@@@ -732,21 -776,27 +777,21 @@@
  	int num = 1;
  
  	if (perf_evsel__match(evsel, HARDWARE, HW_INSTRUCTIONS)) {
 -		total = runtime_stat_avg(st, STAT_CYCLES, ctx, cpu);
 -
 +		total = avg_stats(&runtime_cycles_stats[ctx][cpu]);
  		if (total) {
  			ratio = avg / total;
- 			print_metric(ctxp, NULL, "%7.2f ",
+ 			print_metric(config, ctxp, NULL, "%7.2f ",
  					"insn per cycle", ratio);
  		} else {
- 			print_metric(ctxp, NULL, NULL, "insn per cycle", 0);
+ 			print_metric(config, ctxp, NULL, NULL, "insn per cycle", 0);
  		}
 -
 -		total = runtime_stat_avg(st, STAT_STALLED_CYCLES_FRONT,
 -					 ctx, cpu);
 -
 -		total = max(total, runtime_stat_avg(st,
 -						    STAT_STALLED_CYCLES_BACK,
 -						    ctx, cpu));
 +		total = avg_stats(&runtime_stalled_cycles_front_stats[ctx][cpu]);
 +		total = max(total, avg_stats(&runtime_stalled_cycles_back_stats[ctx][cpu]));
  
  		if (total && avg) {
- 			out->new_line(ctxp);
+ 			out->new_line(config, ctxp);
  			ratio = total / avg;
- 			print_metric(ctxp, NULL, "%7.2f ",
+ 			print_metric(config, ctxp, NULL, "%7.2f ",
  					"stalled cycles per insn",
  					ratio);
  		} else if (have_frontend_stalled) {
@@@ -754,147 -804,155 +799,210 @@@
  				     "stalled cycles per insn", 0);
  		}
  	} else if (perf_evsel__match(evsel, HARDWARE, HW_BRANCH_MISSES)) {
++<<<<<<< HEAD
 +		if (runtime_branches_stats[ctx][cpu].n != 0)
 +			print_branch_misses(cpu, evsel, avg, out);
++=======
+ 		if (runtime_stat_n(st, STAT_BRANCHES, ctx, cpu) != 0)
+ 			print_branch_misses(config, cpu, evsel, avg, out, st);
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  		else
- 			print_metric(ctxp, NULL, NULL, "of all branches", 0);
+ 			print_metric(config, ctxp, NULL, NULL, "of all branches", 0);
  	} else if (
  		evsel->attr.type == PERF_TYPE_HW_CACHE &&
  		evsel->attr.config ==  ( PERF_COUNT_HW_CACHE_L1D |
  					((PERF_COUNT_HW_CACHE_OP_READ) << 8) |
  					 ((PERF_COUNT_HW_CACHE_RESULT_MISS) << 16))) {
++<<<<<<< HEAD
 +		if (runtime_l1_dcache_stats[ctx][cpu].n != 0)
 +			print_l1_dcache_misses(cpu, evsel, avg, out);
++=======
+ 
+ 		if (runtime_stat_n(st, STAT_L1_DCACHE, ctx, cpu) != 0)
+ 			print_l1_dcache_misses(config, cpu, evsel, avg, out, st);
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  		else
- 			print_metric(ctxp, NULL, NULL, "of all L1-dcache hits", 0);
+ 			print_metric(config, ctxp, NULL, NULL, "of all L1-dcache hits", 0);
  	} else if (
  		evsel->attr.type == PERF_TYPE_HW_CACHE &&
  		evsel->attr.config ==  ( PERF_COUNT_HW_CACHE_L1I |
  					((PERF_COUNT_HW_CACHE_OP_READ) << 8) |
  					 ((PERF_COUNT_HW_CACHE_RESULT_MISS) << 16))) {
++<<<<<<< HEAD
 +		if (runtime_l1_icache_stats[ctx][cpu].n != 0)
 +			print_l1_icache_misses(cpu, evsel, avg, out);
++=======
+ 
+ 		if (runtime_stat_n(st, STAT_L1_ICACHE, ctx, cpu) != 0)
+ 			print_l1_icache_misses(config, cpu, evsel, avg, out, st);
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  		else
- 			print_metric(ctxp, NULL, NULL, "of all L1-icache hits", 0);
+ 			print_metric(config, ctxp, NULL, NULL, "of all L1-icache hits", 0);
  	} else if (
  		evsel->attr.type == PERF_TYPE_HW_CACHE &&
  		evsel->attr.config ==  ( PERF_COUNT_HW_CACHE_DTLB |
  					((PERF_COUNT_HW_CACHE_OP_READ) << 8) |
  					 ((PERF_COUNT_HW_CACHE_RESULT_MISS) << 16))) {
++<<<<<<< HEAD
 +		if (runtime_dtlb_cache_stats[ctx][cpu].n != 0)
 +			print_dtlb_cache_misses(cpu, evsel, avg, out);
++=======
+ 
+ 		if (runtime_stat_n(st, STAT_DTLB_CACHE, ctx, cpu) != 0)
+ 			print_dtlb_cache_misses(config, cpu, evsel, avg, out, st);
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  		else
- 			print_metric(ctxp, NULL, NULL, "of all dTLB cache hits", 0);
+ 			print_metric(config, ctxp, NULL, NULL, "of all dTLB cache hits", 0);
  	} else if (
  		evsel->attr.type == PERF_TYPE_HW_CACHE &&
  		evsel->attr.config ==  ( PERF_COUNT_HW_CACHE_ITLB |
  					((PERF_COUNT_HW_CACHE_OP_READ) << 8) |
  					 ((PERF_COUNT_HW_CACHE_RESULT_MISS) << 16))) {
++<<<<<<< HEAD
 +		if (runtime_itlb_cache_stats[ctx][cpu].n != 0)
 +			print_itlb_cache_misses(cpu, evsel, avg, out);
++=======
+ 
+ 		if (runtime_stat_n(st, STAT_ITLB_CACHE, ctx, cpu) != 0)
+ 			print_itlb_cache_misses(config, cpu, evsel, avg, out, st);
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  		else
- 			print_metric(ctxp, NULL, NULL, "of all iTLB cache hits", 0);
+ 			print_metric(config, ctxp, NULL, NULL, "of all iTLB cache hits", 0);
  	} else if (
  		evsel->attr.type == PERF_TYPE_HW_CACHE &&
  		evsel->attr.config ==  ( PERF_COUNT_HW_CACHE_LL |
  					((PERF_COUNT_HW_CACHE_OP_READ) << 8) |
  					 ((PERF_COUNT_HW_CACHE_RESULT_MISS) << 16))) {
++<<<<<<< HEAD
 +		if (runtime_ll_cache_stats[ctx][cpu].n != 0)
 +			print_ll_cache_misses(cpu, evsel, avg, out);
++=======
+ 
+ 		if (runtime_stat_n(st, STAT_LL_CACHE, ctx, cpu) != 0)
+ 			print_ll_cache_misses(config, cpu, evsel, avg, out, st);
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  		else
- 			print_metric(ctxp, NULL, NULL, "of all LL-cache hits", 0);
+ 			print_metric(config, ctxp, NULL, NULL, "of all LL-cache hits", 0);
  	} else if (perf_evsel__match(evsel, HARDWARE, HW_CACHE_MISSES)) {
 -		total = runtime_stat_avg(st, STAT_CACHEREFS, ctx, cpu);
 +		total = avg_stats(&runtime_cacherefs_stats[ctx][cpu]);
  
  		if (total)
  			ratio = avg * 100 / total;
  
++<<<<<<< HEAD
 +		if (runtime_cacherefs_stats[ctx][cpu].n != 0)
 +			print_metric(ctxp, NULL, "%8.3f %%",
++=======
+ 		if (runtime_stat_n(st, STAT_CACHEREFS, ctx, cpu) != 0)
+ 			print_metric(config, ctxp, NULL, "%8.3f %%",
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  				     "of all cache refs", ratio);
  		else
- 			print_metric(ctxp, NULL, NULL, "of all cache refs", 0);
+ 			print_metric(config, ctxp, NULL, NULL, "of all cache refs", 0);
  	} else if (perf_evsel__match(evsel, HARDWARE, HW_STALLED_CYCLES_FRONTEND)) {
++<<<<<<< HEAD
 +		print_stalled_cycles_frontend(cpu, evsel, avg, out);
 +	} else if (perf_evsel__match(evsel, HARDWARE, HW_STALLED_CYCLES_BACKEND)) {
 +		print_stalled_cycles_backend(cpu, evsel, avg, out);
++=======
+ 		print_stalled_cycles_frontend(config, cpu, evsel, avg, out, st);
+ 	} else if (perf_evsel__match(evsel, HARDWARE, HW_STALLED_CYCLES_BACKEND)) {
+ 		print_stalled_cycles_backend(config, cpu, evsel, avg, out, st);
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  	} else if (perf_evsel__match(evsel, HARDWARE, HW_CPU_CYCLES)) {
 -		total = runtime_stat_avg(st, STAT_NSECS, 0, cpu);
 +		total = avg_stats(&runtime_nsecs_stats[cpu]);
  
  		if (total) {
  			ratio = avg / total;
- 			print_metric(ctxp, NULL, "%8.3f", "GHz", ratio);
+ 			print_metric(config, ctxp, NULL, "%8.3f", "GHz", ratio);
  		} else {
- 			print_metric(ctxp, NULL, NULL, "Ghz", 0);
+ 			print_metric(config, ctxp, NULL, NULL, "Ghz", 0);
  		}
  	} else if (perf_stat_evsel__is(evsel, CYCLES_IN_TX)) {
 -		total = runtime_stat_avg(st, STAT_CYCLES, ctx, cpu);
 -
 +		total = avg_stats(&runtime_cycles_stats[ctx][cpu]);
  		if (total)
- 			print_metric(ctxp, NULL,
+ 			print_metric(config, ctxp, NULL,
  					"%7.2f%%", "transactional cycles",
  					100.0 * (avg / total));
  		else
- 			print_metric(ctxp, NULL, NULL, "transactional cycles",
+ 			print_metric(config, ctxp, NULL, NULL, "transactional cycles",
  				     0);
  	} else if (perf_stat_evsel__is(evsel, CYCLES_IN_TX_CP)) {
 -		total = runtime_stat_avg(st, STAT_CYCLES, ctx, cpu);
 -		total2 = runtime_stat_avg(st, STAT_CYCLES_IN_TX, ctx, cpu);
 -
 +		total = avg_stats(&runtime_cycles_stats[ctx][cpu]);
 +		total2 = avg_stats(&runtime_cycles_in_tx_stats[ctx][cpu]);
  		if (total2 < avg)
  			total2 = avg;
  		if (total)
- 			print_metric(ctxp, NULL, "%7.2f%%", "aborted cycles",
+ 			print_metric(config, ctxp, NULL, "%7.2f%%", "aborted cycles",
  				100.0 * ((total2-avg) / total));
  		else
- 			print_metric(ctxp, NULL, NULL, "aborted cycles", 0);
+ 			print_metric(config, ctxp, NULL, NULL, "aborted cycles", 0);
  	} else if (perf_stat_evsel__is(evsel, TRANSACTION_START)) {
 -		total = runtime_stat_avg(st, STAT_CYCLES_IN_TX,
 -					 ctx, cpu);
 +		total = avg_stats(&runtime_cycles_in_tx_stats[ctx][cpu]);
  
  		if (avg)
  			ratio = total / avg;
  
++<<<<<<< HEAD
 +		if (runtime_cycles_in_tx_stats[ctx][cpu].n != 0)
 +			print_metric(ctxp, NULL, "%8.0f",
 +				     "cycles / transaction", ratio);
 +		else
 +			print_metric(ctxp, NULL, NULL, "cycles / transaction",
 +				     0);
++=======
+ 		if (runtime_stat_n(st, STAT_CYCLES_IN_TX, ctx, cpu) != 0)
+ 			print_metric(config, ctxp, NULL, "%8.0f",
+ 				     "cycles / transaction", ratio);
+ 		else
+ 			print_metric(config, ctxp, NULL, NULL, "cycles / transaction",
+ 				      0);
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  	} else if (perf_stat_evsel__is(evsel, ELISION_START)) {
 -		total = runtime_stat_avg(st, STAT_CYCLES_IN_TX,
 -					 ctx, cpu);
 +		total = avg_stats(&runtime_cycles_in_tx_stats[ctx][cpu]);
  
  		if (avg)
  			ratio = total / avg;
  
++<<<<<<< HEAD
 +		print_metric(ctxp, NULL, "%8.0f", "cycles / elision", ratio);
 +	} else if (perf_evsel__match(evsel, SOFTWARE, SW_TASK_CLOCK) ||
 +		   perf_evsel__match(evsel, SOFTWARE, SW_CPU_CLOCK)) {
 +		if ((ratio = avg_stats(&walltime_nsecs_stats)) != 0)
 +			print_metric(ctxp, NULL, "%8.3f", "CPUs utilized",
 +				     avg / ratio);
++=======
+ 		print_metric(config, ctxp, NULL, "%8.0f", "cycles / elision", ratio);
+ 	} else if (perf_evsel__is_clock(evsel)) {
+ 		if ((ratio = avg_stats(&walltime_nsecs_stats)) != 0)
+ 			print_metric(config, ctxp, NULL, "%8.3f", "CPUs utilized",
+ 				     avg / (ratio * evsel->scale));
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  		else
- 			print_metric(ctxp, NULL, NULL, "CPUs utilized", 0);
+ 			print_metric(config, ctxp, NULL, NULL, "CPUs utilized", 0);
  	} else if (perf_stat_evsel__is(evsel, TOPDOWN_FETCH_BUBBLES)) {
 -		double fe_bound = td_fe_bound(ctx, cpu, st);
 +		double fe_bound = td_fe_bound(ctx, cpu);
  
  		if (fe_bound > 0.2)
  			color = PERF_COLOR_RED;
- 		print_metric(ctxp, color, "%8.1f%%", "frontend bound",
+ 		print_metric(config, ctxp, color, "%8.1f%%", "frontend bound",
  				fe_bound * 100.);
  	} else if (perf_stat_evsel__is(evsel, TOPDOWN_SLOTS_RETIRED)) {
 -		double retiring = td_retiring(ctx, cpu, st);
 +		double retiring = td_retiring(ctx, cpu);
  
  		if (retiring > 0.7)
  			color = PERF_COLOR_GREEN;
- 		print_metric(ctxp, color, "%8.1f%%", "retiring",
+ 		print_metric(config, ctxp, color, "%8.1f%%", "retiring",
  				retiring * 100.);
  	} else if (perf_stat_evsel__is(evsel, TOPDOWN_RECOVERY_BUBBLES)) {
 -		double bad_spec = td_bad_spec(ctx, cpu, st);
 +		double bad_spec = td_bad_spec(ctx, cpu);
  
  		if (bad_spec > 0.1)
  			color = PERF_COLOR_RED;
- 		print_metric(ctxp, color, "%8.1f%%", "bad speculation",
+ 		print_metric(config, ctxp, color, "%8.1f%%", "bad speculation",
  				bad_spec * 100.);
  	} else if (perf_stat_evsel__is(evsel, TOPDOWN_SLOTS_ISSUED)) {
 -		double be_bound = td_be_bound(ctx, cpu, st);
 +		double be_bound = td_be_bound(ctx, cpu);
  		const char *name = "backend bound";
  		static int have_recovery_bubbles = -1;
  
@@@ -907,15 -965,15 +1015,26 @@@
  
  		if (be_bound > 0.2)
  			color = PERF_COLOR_RED;
++<<<<<<< HEAD
 +		if (td_total_slots(ctx, cpu) > 0)
 +			print_metric(ctxp, color, "%8.1f%%", name,
++=======
+ 		if (td_total_slots(ctx, cpu, st) > 0)
+ 			print_metric(config, ctxp, color, "%8.1f%%", name,
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  					be_bound * 100.);
  		else
- 			print_metric(ctxp, NULL, NULL, name, 0);
+ 			print_metric(config, ctxp, NULL, NULL, name, 0);
  	} else if (evsel->metric_expr) {
++<<<<<<< HEAD
 +		generic_metric(evsel->metric_expr, evsel->metric_events, evsel->name,
 +				evsel->metric_name, avg, cpu, out);
 +	} else if (runtime_nsecs_stats[cpu].n != 0) {
++=======
+ 		generic_metric(config, evsel->metric_expr, evsel->metric_events, evsel->name,
+ 				evsel->metric_name, avg, cpu, out, st);
+ 	} else if (runtime_stat_n(st, STAT_NSECS, 0, cpu) != 0) {
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  		char unit = 'M';
  		char unit_buf[10];
  
@@@ -928,9 -986,9 +1047,13 @@@
  			unit = 'K';
  		}
  		snprintf(unit_buf, sizeof(unit_buf), "%c/sec", unit);
- 		print_metric(ctxp, NULL, "%8.3f", unit_buf, ratio);
+ 		print_metric(config, ctxp, NULL, "%8.3f", unit_buf, ratio);
  	} else if (perf_stat_evsel__is(evsel, SMI_NUM)) {
++<<<<<<< HEAD
 +		print_smi_cost(cpu, evsel, out);
++=======
+ 		print_smi_cost(config, cpu, evsel, out, st);
++>>>>>>> 6ca9a082b190 (perf stat: Pass a 'struct perf_stat_config' argument to global print functions)
  	} else {
  		num = 0;
  	}
@@@ -940,10 -998,10 +1063,10 @@@
  
  		list_for_each_entry (mexp, &me->head, nd) {
  			if (num++ > 0)
- 				out->new_line(ctxp);
- 			generic_metric(mexp->metric_expr, mexp->metric_events,
+ 				out->new_line(config, ctxp);
+ 			generic_metric(config, mexp->metric_expr, mexp->metric_events,
  					evsel->name, mexp->metric_name,
 -					avg, cpu, out, st);
 +					avg, cpu, out);
  		}
  	}
  	if (num == 0)
* Unmerged path tools/perf/builtin-script.c
* Unmerged path tools/perf/builtin-stat.c
* Unmerged path tools/perf/util/stat-shadow.c
diff --git a/tools/perf/util/stat.h b/tools/perf/util/stat.h
index 4b88aef959fb..d2a446091b8f 100644
--- a/tools/perf/util/stat.h
+++ b/tools/perf/util/stat.h
@@ -124,9 +124,10 @@ bool __perf_evsel_stat__is(struct perf_evsel *evsel,
 extern struct runtime_stat rt_stat;
 extern struct stats walltime_nsecs_stats;
 
-typedef void (*print_metric_t)(void *ctx, const char *color, const char *unit,
+typedef void (*print_metric_t)(struct perf_stat_config *config,
+			       void *ctx, const char *color, const char *unit,
 			       const char *fmt, double val);
-typedef void (*new_line_t )(void *ctx);
+typedef void (*new_line_t)(struct perf_stat_config *config, void *ctx);
 
 void runtime_stat__init(struct runtime_stat *st);
 void runtime_stat__exit(struct runtime_stat *st);
@@ -141,7 +142,8 @@ struct perf_stat_output_ctx {
 	bool force_header;
 };
 
-void perf_stat__print_shadow_stats(struct perf_evsel *evsel,
+void perf_stat__print_shadow_stats(struct perf_stat_config *config,
+				   struct perf_evsel *evsel,
 				   double avg, int cpu,
 				   struct perf_stat_output_ctx *out,
 				   struct rblist *metric_events);
