s390/zcrypt: AP bus support for alternate driver(s)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [s390] zcrypt: AP bus support for alternate driver(s) (Hendrik Brueckner) [1641030]
Rebuild_FUZZ: 94.85%
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit 7e0bdbe5c21cb8316a694e46ad5aad339f6894a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7e0bdbe5.failed

The current AP bus, AP devices and AP device drivers implementation
uses a clearly defined mapping for binding AP devices to AP device
drivers. So for example a CEX6C queue will always be bound to the
cex4queue device driver.

The Linux Device Driver model has no sensitivity for more than one
device driver eligible for one device type. If there exist more than
one drivers matching to the device type, simple all drivers are tried
consecutively.  There is no way to determine and influence the probing
order of the drivers.

With KVM there is a need to provide additional device drivers matching
to the very same type of AP devices. With a simple implementation the
KVM drivers run in competition to the regular drivers. Whichever
'wins' a device depends on build order and implementation details
within the common Linux Device Driver Model and is not
deterministic. However, a userspace process could figure out which
device should be bound to which driver and sort out the correct
binding by manipulating attributes in the sysfs.

If for security reasons a AP device must not get bound to the 'wrong'
device driver the sorting out has to be done within the Linux kernel
by the AP bus code. This patch modifies the behavior of the AP bus
for probing drivers for devices in a way that two sets of drivers are
usable. Two new bitmasks 'apmask' and 'aqmask' are used to mark a
subset of the APQN range for 'usable by the ap bus and the default
drivers' or 'not usable by the default drivers and thus available for
alternate drivers like vfio-xxx'. So an APQN which is addressed by
this masking only the default drivers will be probed. In contrary an
APQN which is not addressed by the masks will never be probed and
bound to default drivers but onny to alternate drivers.

Eventually the two masks give a way to divide the range of APQNs into
two pools: one pool of APQNs used by the AP bus and the default
drivers and thus via zcrypt drivers available to the userspace of the
system. And another pool where no zcrypt drivers are bound to and
which can be used by alternate drivers (like vfio-xxx) for their
needs. This division is hot-plug save and makes sure a APQN assigned
to an alternate driver is at no time somehow exploitable by the wrong
party.

The two masks are located in sysfs at /sys/bus/ap/apmask and
/sys/bus/ap/aqmask.  The mask syntax is exactly the same as the
already existing mask attributes in the /sys/bus/ap directory (for
example ap_usage_domain_mask and ap_control_domain_mask).

By default all APQNs belong to the ap bus and the default drivers:

  cat /sys/bus/ap/apmask
  0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
  cat /sys/bus/ap/aqmask
  0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff

The masks can be changed at boot time with the kernel command line
like this:

  ... ap.apmask=0xffff ap.aqmask=0x40

This would give these two pools:

  default drivers pool:    adapter 0 - 15, domain 1
  alternate drivers pool:  adapter 0 - 15, all but domain 1
			   adapter 16-255, all domains

The sysfs attributes for this two masks are writeable and an
administrator is able to reconfigure the assignements on the fly by
writing new mask values into.  With changing the mask(s) a revision of
the existing queue to driver bindings is done. So all APQNs which are
bound to the 'wrong' driver are reprobed via kernel function
device_reprobe() and thus the new correct driver will be assigned with
respect of the changed apmask and aqmask bits.

The mask values are bitmaps in big endian order starting with bit 0.
So adapter number 0 is the leftmost bit, mask is 0x8000... The sysfs
attributes accept 2 different formats:
- Absolute hex string starting with 0x like "0x12345678" does set
  the mask starting from left to right. If the given string is shorter
  than the mask it is padded with 0s on the right. If the string is
  longer than the mask an error comes back (EINVAL).
- '+' or '-' followed by a numerical value. Valid examples are "+1",
  "-13", "+0x41", "-0xff" and even "+0" and "-0". Only the addressed
  bit in the mask is switched on ('+') or off ('-').

This patch will also be the base for an upcoming extension to the
zcrypt drivers to be able to provide additional zcrypt device nodes
with filtering based on ap and aq masks.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 7e0bdbe5c21cb8316a694e46ad5aad339f6894a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
#	drivers/s390/crypto/ap_bus.h
diff --cc drivers/s390/crypto/ap_bus.c
index eec227533e4a,30d7898910ea..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -48,9 -34,9 +48,10 @@@
  #include <linux/crypto.h>
  #include <linux/mod_devicetable.h>
  #include <linux/debugfs.h>
+ #include <linux/ctype.h>
  
  #include "ap_bus.h"
 +#include "ap_asm.h"
  #include "ap_debug.h"
  
  /*
@@@ -71,10 -48,18 +72,18 @@@ module_param_named(domain, ap_domain_in
  MODULE_PARM_DESC(domain, "domain index for ap devices");
  EXPORT_SYMBOL(ap_domain_index);
  
 -static int ap_thread_flag;
 -module_param_named(poll_thread, ap_thread_flag, int, 0440);
 +static int ap_thread_flag = 0;
 +module_param_named(poll_thread, ap_thread_flag, int, S_IRUSR|S_IRGRP);
  MODULE_PARM_DESC(poll_thread, "Turn on/off poll thread, default is 0 (off).");
  
+ static char *apm_str;
+ module_param_named(apmask, apm_str, charp, 0440);
+ MODULE_PARM_DESC(apmask, "AP bus adapter mask.");
+ 
+ static char *aqm_str;
+ module_param_named(aqmask, aqm_str, charp, 0440);
+ MODULE_PARM_DESC(aqmask, "AP bus domain mask.");
+ 
  static struct device *ap_root_device;
  
  DEFINE_SPINLOCK(ap_list_lock);
@@@ -703,10 -683,77 +719,78 @@@ static struct bus_type ap_bus_type = 
  	.name = "ap",
  	.match = &ap_bus_match,
  	.uevent = &ap_uevent,
 -	.pm = &ap_bus_pm_ops,
 +	.suspend = ap_dev_suspend,
 +	.resume = ap_dev_resume,
  };
  
+ static int __ap_revise_reserved(struct device *dev, void *dummy)
+ {
+ 	int rc, card, queue, devres, drvres;
+ 
+ 	if (is_queue_dev(dev)) {
+ 		card = AP_QID_CARD(to_ap_queue(dev)->qid);
+ 		queue = AP_QID_QUEUE(to_ap_queue(dev)->qid);
+ 		mutex_lock(&ap_perms_mutex);
+ 		devres = test_bit_inv(card, ap_perms.apm)
+ 			&& test_bit_inv(queue, ap_perms.aqm);
+ 		mutex_unlock(&ap_perms_mutex);
+ 		drvres = to_ap_drv(dev->driver)->flags
+ 			& AP_DRIVER_FLAG_DEFAULT;
+ 		if (!!devres != !!drvres) {
+ 			AP_DBF(DBF_DEBUG, "reprobing queue=%02x.%04x\n",
+ 			       card, queue);
+ 			rc = device_reprobe(dev);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void ap_bus_revise_bindings(void)
+ {
+ 	bus_for_each_dev(&ap_bus_type, NULL, NULL, __ap_revise_reserved);
+ }
+ 
+ int ap_owned_by_def_drv(int card, int queue)
+ {
+ 	int rc = 0;
+ 
+ 	if (card < 0 || card >= AP_DEVICES || queue < 0 || queue >= AP_DOMAINS)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&ap_perms_mutex);
+ 
+ 	if (test_bit_inv(card, ap_perms.apm)
+ 	    && test_bit_inv(queue, ap_perms.aqm))
+ 		rc = 1;
+ 
+ 	mutex_unlock(&ap_perms_mutex);
+ 
+ 	return rc;
+ }
+ EXPORT_SYMBOL(ap_owned_by_def_drv);
+ 
+ int ap_apqn_in_matrix_owned_by_def_drv(unsigned long *apm,
+ 				       unsigned long *aqm)
+ {
+ 	int card, queue, rc = 0;
+ 
+ 	mutex_lock(&ap_perms_mutex);
+ 
+ 	for (card = 0; !rc && card < AP_DEVICES; card++)
+ 		if (test_bit_inv(card, apm) &&
+ 		    test_bit_inv(card, ap_perms.apm))
+ 			for (queue = 0; !rc && queue < AP_DOMAINS; queue++)
+ 				if (test_bit_inv(queue, aqm) &&
+ 				    test_bit_inv(queue, ap_perms.aqm))
+ 					rc = 1;
+ 
+ 	mutex_unlock(&ap_perms_mutex);
+ 
+ 	return rc;
+ }
+ EXPORT_SYMBOL(ap_apqn_in_matrix_owned_by_def_drv);
+ 
  static int ap_device_probe(struct device *dev)
  {
  	struct ap_device *ap_dev = to_ap_dev(dev);
@@@ -940,8 -1034,116 +1073,116 @@@ static ssize_t ap_max_domain_id_show(st
  	return snprintf(buf, PAGE_SIZE, "%d\n", max_domain_id);
  }
  
 -static BUS_ATTR_RO(ap_max_domain_id);
 +static BUS_ATTR(ap_max_domain_id, 0444, ap_max_domain_id_show, NULL);
  
+ static ssize_t apmask_show(struct bus_type *bus, char *buf)
+ {
+ 	int rc;
+ 
+ 	if (mutex_lock_interruptible(&ap_perms_mutex))
+ 		return -ERESTARTSYS;
+ 	rc = snprintf(buf, PAGE_SIZE,
+ 		      "0x%016lx%016lx%016lx%016lx\n",
+ 		      ap_perms.apm[0], ap_perms.apm[1],
+ 		      ap_perms.apm[2], ap_perms.apm[3]);
+ 	mutex_unlock(&ap_perms_mutex);
+ 
+ 	return rc;
+ }
+ 
+ static ssize_t apmask_store(struct bus_type *bus, const char *buf,
+ 			    size_t count)
+ {
+ 	int i;
+ 
+ 	if (*buf == '+' || *buf == '-') {
+ 		if (kstrtoint(buf, 0, &i))
+ 			return -EINVAL;
+ 		if (i <= -AP_DEVICES || i >= AP_DEVICES)
+ 			return -EINVAL;
+ 		if (mutex_lock_interruptible(&ap_perms_mutex))
+ 			return -ERESTARTSYS;
+ 		if (*buf == '-')
+ 			clear_bit_inv(-i, ap_perms.apm);
+ 		else
+ 			set_bit_inv(i, ap_perms.apm);
+ 	} else {
+ 		DECLARE_BITMAP(apm, AP_DEVICES);
+ 
+ 		i = hex2bitmap(buf, apm, AP_DEVICES);
+ 		if (i)
+ 			return i;
+ 		if (mutex_lock_interruptible(&ap_perms_mutex))
+ 			return -ERESTARTSYS;
+ 		for (i = 0; i < AP_DEVICES; i++)
+ 			if (test_bit_inv(i, apm))
+ 				set_bit_inv(i, ap_perms.apm);
+ 			else
+ 				clear_bit_inv(i, ap_perms.apm);
+ 	}
+ 	mutex_unlock(&ap_perms_mutex);
+ 
+ 	ap_bus_revise_bindings();
+ 
+ 	return count;
+ }
+ 
+ static BUS_ATTR_RW(apmask);
+ 
+ static ssize_t aqmask_show(struct bus_type *bus, char *buf)
+ {
+ 	int rc;
+ 
+ 	if (mutex_lock_interruptible(&ap_perms_mutex))
+ 		return -ERESTARTSYS;
+ 	rc = snprintf(buf, PAGE_SIZE,
+ 		      "0x%016lx%016lx%016lx%016lx\n",
+ 		      ap_perms.aqm[0], ap_perms.aqm[1],
+ 		      ap_perms.aqm[2], ap_perms.aqm[3]);
+ 	mutex_unlock(&ap_perms_mutex);
+ 
+ 	return rc;
+ }
+ 
+ static ssize_t aqmask_store(struct bus_type *bus, const char *buf,
+ 			    size_t count)
+ {
+ 	int i;
+ 
+ 	if (*buf == '+' || *buf == '-') {
+ 		if (kstrtoint(buf, 0, &i))
+ 			return -EINVAL;
+ 		if (i <= -AP_DEVICES || i >= AP_DEVICES)
+ 			return -EINVAL;
+ 		if (mutex_lock_interruptible(&ap_perms_mutex))
+ 			return -ERESTARTSYS;
+ 		if (*buf == '-')
+ 			clear_bit_inv(-i, ap_perms.aqm);
+ 		else
+ 			set_bit_inv(i, ap_perms.aqm);
+ 	} else {
+ 		DECLARE_BITMAP(aqm, AP_DEVICES);
+ 
+ 		i = hex2bitmap(buf, aqm, AP_DEVICES);
+ 		if (i)
+ 			return i;
+ 		if (mutex_lock_interruptible(&ap_perms_mutex))
+ 			return -ERESTARTSYS;
+ 		for (i = 0; i < AP_DEVICES; i++)
+ 			if (test_bit_inv(i, aqm))
+ 				set_bit_inv(i, ap_perms.aqm);
+ 			else
+ 				clear_bit_inv(i, ap_perms.aqm);
+ 	}
+ 	mutex_unlock(&ap_perms_mutex);
+ 
+ 	ap_bus_revise_bindings();
+ 
+ 	return count;
+ }
+ 
+ static BUS_ATTR_RW(aqmask);
+ 
  static struct bus_attribute *const ap_bus_attrs[] = {
  	&bus_attr_ap_domain,
  	&bus_attr_ap_control_domain_mask,
@@@ -1257,9 -1434,35 +1501,41 @@@ int __init ap_debug_init(void
  	return 0;
  }
  
++<<<<<<< HEAD
 +void ap_debug_exit(void)
 +{
 +	debug_unregister(ap_dbf_info);
++=======
+ static void __init ap_perms_init(void)
+ {
+ 	int i, rc;
+ 
+ 	/* start with all resources useable */
+ 	memset(&ap_perms.apm, 0xFF, sizeof(ap_perms.apm));
+ 	memset(&ap_perms.aqm, 0xFF, sizeof(ap_perms.aqm));
+ 
+ 	/* process kernel parameters apm and aqm if given */
+ 	if (apm_str) {
+ 		DECLARE_BITMAP(apm, AP_DEVICES);
+ 
+ 		rc = hex2bitmap(apm_str, apm, AP_DEVICES);
+ 		if (rc == 0) {
+ 			for (i = 0; i < AP_DEVICES; i++)
+ 				if (!test_bit_inv(i, apm))
+ 					clear_bit_inv(i, ap_perms.apm);
+ 		}
+ 	}
+ 	if (aqm_str) {
+ 		DECLARE_BITMAP(aqm, AP_DOMAINS);
+ 
+ 		rc = hex2bitmap(aqm_str, aqm, AP_DOMAINS);
+ 		if (rc == 0) {
+ 			for (i = 0; i < AP_DOMAINS; i++)
+ 				if (!test_bit_inv(i, aqm))
+ 					clear_bit_inv(i, ap_perms.aqm);
+ 		}
+ 	}
++>>>>>>> 7e0bdbe5c21c (s390/zcrypt: AP bus support for alternate driver(s))
  }
  
  /**
diff --cc drivers/s390/crypto/ap_bus.h
index 680817a65f16,5246cd8c16a6..000000000000
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@@ -267,7 -257,27 +276,32 @@@ void ap_queue_resume(struct ap_device *
  struct ap_card *ap_card_create(int id, int queue_depth, int raw_device_type,
  			       int comp_device_type, unsigned int functions);
  
++<<<<<<< HEAD
 +int ap_module_init(void);
 +void ap_module_exit(void);
++=======
+ /*
+  * check APQN for owned/reserved by ap bus and default driver(s).
+  * Checks if this APQN is or will be in use by the ap bus
+  * and the default set of drivers.
+  * If yes, returns 1, if not returns 0. On error a negative
+  * errno value is returned.
+  */
+ int ap_owned_by_def_drv(int card, int queue);
+ 
+ /*
+  * check 'matrix' of APQNs for owned/reserved by ap bus and
+  * default driver(s).
+  * Checks if there is at least one APQN in the given 'matrix'
+  * marked as owned/reserved by the ap bus and default driver(s).
+  * If such an APQN is found the return value is 1, otherwise
+  * 0 is returned. On error a negative errno value is returned.
+  * The parameter apm is a bitmask which should be declared
+  * as DECLARE_BITMAP(apm, AP_DEVICES), the aqm parameter is
+  * similar, should be declared as DECLARE_BITMAP(aqm, AP_DOMAINS).
+  */
+ int ap_apqn_in_matrix_owned_by_def_drv(unsigned long *apm,
+ 				       unsigned long *aqm);
++>>>>>>> 7e0bdbe5c21c (s390/zcrypt: AP bus support for alternate driver(s))
  
  #endif /* _AP_BUS_H_ */
* Unmerged path drivers/s390/crypto/ap_bus.c
* Unmerged path drivers/s390/crypto/ap_bus.h
diff --git a/drivers/s390/crypto/zcrypt_cex2a.c b/drivers/s390/crypto/zcrypt_cex2a.c
index c7d48a18199e..017f6897265a 100644
--- a/drivers/s390/crypto/zcrypt_cex2a.c
+++ b/drivers/s390/crypto/zcrypt_cex2a.c
@@ -158,6 +158,7 @@ static struct ap_driver zcrypt_cex2a_card_driver = {
 	.probe = zcrypt_cex2a_card_probe,
 	.remove = zcrypt_cex2a_card_remove,
 	.ids = zcrypt_cex2a_card_ids,
+	.flags = AP_DRIVER_FLAG_DEFAULT,
 };
 
 /**
@@ -221,6 +222,7 @@ static struct ap_driver zcrypt_cex2a_queue_driver = {
 	.suspend = ap_queue_suspend,
 	.resume = ap_queue_resume,
 	.ids = zcrypt_cex2a_queue_ids,
+	.flags = AP_DRIVER_FLAG_DEFAULT,
 };
 
 int __init zcrypt_cex2a_init(void)
diff --git a/drivers/s390/crypto/zcrypt_cex4.c b/drivers/s390/crypto/zcrypt_cex4.c
index e2eebc775a37..5de695dec230 100644
--- a/drivers/s390/crypto/zcrypt_cex4.c
+++ b/drivers/s390/crypto/zcrypt_cex4.c
@@ -213,6 +213,7 @@ static struct ap_driver zcrypt_cex4_card_driver = {
 	.probe = zcrypt_cex4_card_probe,
 	.remove = zcrypt_cex4_card_remove,
 	.ids = zcrypt_cex4_card_ids,
+	.flags = AP_DRIVER_FLAG_DEFAULT,
 };
 
 /**
@@ -282,6 +283,7 @@ static struct ap_driver zcrypt_cex4_queue_driver = {
 	.suspend = ap_queue_suspend,
 	.resume = ap_queue_resume,
 	.ids = zcrypt_cex4_queue_ids,
+	.flags = AP_DRIVER_FLAG_DEFAULT,
 };
 
 int __init zcrypt_cex4_init(void)
diff --git a/drivers/s390/crypto/zcrypt_pcixcc.c b/drivers/s390/crypto/zcrypt_pcixcc.c
index 26ceaa696765..26c3a35da23b 100644
--- a/drivers/s390/crypto/zcrypt_pcixcc.c
+++ b/drivers/s390/crypto/zcrypt_pcixcc.c
@@ -236,6 +236,7 @@ static struct ap_driver zcrypt_pcixcc_card_driver = {
 	.probe = zcrypt_pcixcc_card_probe,
 	.remove = zcrypt_pcixcc_card_remove,
 	.ids = zcrypt_pcixcc_card_ids,
+	.flags = AP_DRIVER_FLAG_DEFAULT,
 };
 
 /**
@@ -299,6 +300,7 @@ static struct ap_driver zcrypt_pcixcc_queue_driver = {
 	.suspend = ap_queue_suspend,
 	.resume = ap_queue_resume,
 	.ids = zcrypt_pcixcc_queue_ids,
+	.flags = AP_DRIVER_FLAG_DEFAULT,
 };
 
 int __init zcrypt_pcixcc_init(void)
