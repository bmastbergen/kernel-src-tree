net: phy: Restore phy_resume() locking assumption

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] phy: Restore phy_resume() locking assumption (Ivan Vecera) [1685646]
Rebuild_FUZZ: 94.62%
commit-author Andrew Lunn <andrew@lunn.ch>
commit 9c2c2e62df3fa30fb13fbeb7512a4eede729383b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9c2c2e62.failed

commit f5e64032a799 ("net: phy: fix resume handling") changes the
locking semantics for phy_resume() such that the caller now needs to
hold the phy mutex. Not all call sites were adopted to this new
semantic, resulting in warnings from the added
WARN_ON(!mutex_is_locked(&phydev->lock)).  Rather than change the
semantics, add a __phy_resume() and restore the old behavior of
phy_resume().

	Reported-by: Heiner Kallweit <hkallweit1@gmail.com>
Fixes: f5e64032a799 ("net: phy: fix resume handling")
	Signed-off-by: Andrew Lunn <andrew@lunn.ch>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9c2c2e62df3fa30fb13fbeb7512a4eede729383b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phy.c
#	drivers/net/phy/phy_device.c
#	include/linux/phy.h
diff --cc drivers/net/phy/phy.c
index c89d087511ee,a6f924fee584..000000000000
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@@ -880,13 -818,17 +880,19 @@@ void phy_start(struct phy_device *phyde
  		phydev->state = PHY_UP;
  		break;
  	case PHY_HALTED:
++<<<<<<< HEAD
++=======
+ 		/* if phy was suspended, bring the physical link up again */
+ 		__phy_resume(phydev);
+ 
++>>>>>>> 9c2c2e62df3f (net: phy: Restore phy_resume() locking assumption)
  		/* make sure interrupts are re-enabled for the PHY */
 -		if (phy_interrupt_is_valid(phydev)) {
 -			err = phy_enable_interrupts(phydev);
 -			if (err < 0)
 -				break;
 -		}
 +		err = phy_enable_interrupts(phydev);
 +		if (err < 0)
 +			break;
  
  		phydev->state = PHY_RESUMING;
 +		do_resume = true;
  		break;
  	default:
  		break;
diff --cc drivers/net/phy/phy_device.c
index f7f4abfd4a6f,478405e544cc..000000000000
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@@ -62,9 -75,118 +62,121 @@@ static struct phy_driver genphy_driver[
  static LIST_HEAD(phy_fixup_list);
  static DEFINE_MUTEX(phy_fixup_lock);
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PM
+ static bool mdio_bus_phy_may_suspend(struct phy_device *phydev)
+ {
+ 	struct device_driver *drv = phydev->mdio.dev.driver;
+ 	struct phy_driver *phydrv = to_phy_driver(drv);
+ 	struct net_device *netdev = phydev->attached_dev;
+ 
+ 	if (!drv || !phydrv->suspend)
+ 		return false;
+ 
+ 	/* PHY not attached? May suspend if the PHY has not already been
+ 	 * suspended as part of a prior call to phy_disconnect() ->
+ 	 * phy_detach() -> phy_suspend() because the parent netdev might be the
+ 	 * MDIO bus driver and clock gated at this point.
+ 	 */
+ 	if (!netdev)
+ 		return !phydev->suspended;
+ 
+ 	/* Don't suspend PHY if the attached netdev parent may wakeup.
+ 	 * The parent may point to a PCI device, as in tg3 driver.
+ 	 */
+ 	if (netdev->dev.parent && device_may_wakeup(netdev->dev.parent))
+ 		return false;
+ 
+ 	/* Also don't suspend PHY if the netdev itself may wakeup. This
+ 	 * is the case for devices w/o underlaying pwr. mgmt. aware bus,
+ 	 * e.g. SoC devices.
+ 	 */
+ 	if (device_may_wakeup(&netdev->dev))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ static int mdio_bus_phy_suspend(struct device *dev)
+ {
+ 	struct phy_device *phydev = to_phy_device(dev);
+ 
+ 	/* We must stop the state machine manually, otherwise it stops out of
+ 	 * control, possibly with the phydev->lock held. Upon resume, netdev
+ 	 * may call phy routines that try to grab the same lock, and that may
+ 	 * lead to a deadlock.
+ 	 */
+ 	if (phydev->attached_dev && phydev->adjust_link)
+ 		phy_stop_machine(phydev);
+ 
+ 	if (!mdio_bus_phy_may_suspend(phydev))
+ 		return 0;
+ 
+ 	return phy_suspend(phydev);
+ }
+ 
+ static int mdio_bus_phy_resume(struct device *dev)
+ {
+ 	struct phy_device *phydev = to_phy_device(dev);
+ 	int ret;
+ 
+ 	if (!mdio_bus_phy_may_suspend(phydev))
+ 		goto no_resume;
+ 
+ 	ret = phy_resume(phydev);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ no_resume:
+ 	if (phydev->attached_dev && phydev->adjust_link)
+ 		phy_start_machine(phydev);
+ 
+ 	return 0;
+ }
+ 
+ static int mdio_bus_phy_restore(struct device *dev)
+ {
+ 	struct phy_device *phydev = to_phy_device(dev);
+ 	struct net_device *netdev = phydev->attached_dev;
+ 	int ret;
+ 
+ 	if (!netdev)
+ 		return 0;
+ 
+ 	ret = phy_init_hw(phydev);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	/* The PHY needs to renegotiate. */
+ 	phydev->link = 0;
+ 	phydev->state = PHY_UP;
+ 
+ 	phy_start_machine(phydev);
+ 
+ 	return 0;
+ }
+ 
+ static const struct dev_pm_ops mdio_bus_phy_pm_ops = {
+ 	.suspend = mdio_bus_phy_suspend,
+ 	.resume = mdio_bus_phy_resume,
+ 	.freeze = mdio_bus_phy_suspend,
+ 	.thaw = mdio_bus_phy_resume,
+ 	.restore = mdio_bus_phy_restore,
+ };
+ 
+ #define MDIO_BUS_PHY_PM_OPS (&mdio_bus_phy_pm_ops)
+ 
+ #else
+ 
+ #define MDIO_BUS_PHY_PM_OPS NULL
+ 
+ #endif /* CONFIG_PM */
+ 
++>>>>>>> 9c2c2e62df3f (net: phy: Restore phy_resume() locking assumption)
  /**
   * phy_register_fixup - creates a new phy_fixup and adds it to the list
 - * @bus_id: A string which matches phydev->mdio.dev.bus_id (or PHY_ANY_ID)
 + * @bus_id: A string which matches phydev->dev.bus_id (or PHY_ANY_ID)
   * @phy_uid: Used to match against phydev->phy_id (the UID of the PHY)
   *	It can also be PHY_ANY_UID
   * @phy_uid_mask: Applied to phydev->phy_id and fixup->phy_uid before
@@@ -651,9 -1037,10 +763,13 @@@ int phy_attach_direct(struct net_devic
  	 */
  	err = phy_init_hw(phydev);
  	if (err)
 -		goto error;
 +		phy_detach(phydev);
  
  	phy_resume(phydev);
++<<<<<<< HEAD
++=======
+ 	phy_led_triggers_register(phydev);
++>>>>>>> 9c2c2e62df3f (net: phy: Restore phy_resume() locking assumption)
  
  	return err;
  
@@@ -758,15 -1168,93 +874,99 @@@ int phy_suspend(struct phy_device *phyd
  }
  EXPORT_SYMBOL(phy_suspend);
  
- int phy_resume(struct phy_device *phydev)
+ int __phy_resume(struct phy_device *phydev)
  {
++<<<<<<< HEAD
 +	struct phy_driver *phydrv = to_phy_driver(phydev->dev.driver);
++=======
+ 	struct phy_driver *phydrv = to_phy_driver(phydev->mdio.dev.driver);
+ 	int ret = 0;
+ 
+ 	WARN_ON(!mutex_is_locked(&phydev->lock));
+ 
+ 	if (phydev->drv && phydrv->resume)
+ 		ret = phydrv->resume(phydev);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	phydev->suspended = false;
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL(__phy_resume);
+ 
+ int phy_resume(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&phydev->lock);
+ 	ret = __phy_resume(phydev);
+ 	mutex_unlock(&phydev->lock);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL(phy_resume);
+ 
+ int phy_loopback(struct phy_device *phydev, bool enable)
+ {
+ 	struct phy_driver *phydrv = to_phy_driver(phydev->mdio.dev.driver);
+ 	int ret = 0;
+ 
+ 	mutex_lock(&phydev->lock);
+ 
+ 	if (enable && phydev->loopback_enabled) {
+ 		ret = -EBUSY;
+ 		goto out;
+ 	}
+ 
+ 	if (!enable && !phydev->loopback_enabled) {
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (phydev->drv && phydrv->set_loopback)
+ 		ret = phydrv->set_loopback(phydev, enable);
+ 	else
+ 		ret = -EOPNOTSUPP;
+ 
+ 	if (ret)
+ 		goto out;
+ 
+ 	phydev->loopback_enabled = enable;
+ 
+ out:
+ 	mutex_unlock(&phydev->lock);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(phy_loopback);
+ 
+ /**
+  * phy_reset_after_clk_enable - perform a PHY reset if needed
+  * @phydev: target phy_device struct
+  *
+  * Description: Some PHYs are known to need a reset after their refclk was
+  *   enabled. This function evaluates the flags and perform the reset if it's
+  *   needed. Returns < 0 on error, 0 if the phy wasn't reset and 1 if the phy
+  *   was reset.
+  */
+ int phy_reset_after_clk_enable(struct phy_device *phydev)
+ {
+ 	if (!phydev || !phydev->drv)
+ 		return -ENODEV;
+ 
+ 	if (phydev->drv->flags & PHY_RST_AFTER_CLK_EN) {
+ 		phy_device_reset(phydev, 1);
+ 		phy_device_reset(phydev, 0);
+ 		return 1;
+ 	}
++>>>>>>> 9c2c2e62df3f (net: phy: Restore phy_resume() locking assumption)
  
 +	if (phydrv->resume)
 +		return phydrv->resume(phydev);
  	return 0;
  }
 -EXPORT_SYMBOL(phy_reset_after_clk_enable);
 +EXPORT_SYMBOL(phy_resume);
  
  /* Generic PHY support and helper functions */
  
diff --cc include/linux/phy.h
index 2a7a15321caa,d7069539f351..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -644,6 -924,8 +644,11 @@@ void phy_device_remove(struct phy_devic
  int phy_init_hw(struct phy_device *phydev);
  int phy_suspend(struct phy_device *phydev);
  int phy_resume(struct phy_device *phydev);
++<<<<<<< HEAD
++=======
+ int __phy_resume(struct phy_device *phydev);
+ int phy_loopback(struct phy_device *phydev, bool enable);
++>>>>>>> 9c2c2e62df3f (net: phy: Restore phy_resume() locking assumption)
  struct phy_device *phy_attach(struct net_device *dev, const char *bus_id,
  			      phy_interface_t interface);
  struct phy_device *phy_find_first(struct mii_bus *bus);
* Unmerged path drivers/net/phy/phy.c
* Unmerged path drivers/net/phy/phy_device.c
* Unmerged path include/linux/phy.h
