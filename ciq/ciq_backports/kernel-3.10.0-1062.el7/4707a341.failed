/dev/mem: Use more consistent data types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Thierry Reding <treding@nvidia.com>
commit 4707a341b4af57c72c1573a89d303559cf7bcf88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4707a341.failed

The xlate_dev_{kmem,mem}_ptr() functions take either a physical address
or a kernel virtual address, so data types should be phys_addr_t and
void *. They both return a kernel virtual address which is only ever
used in calls to copy_{from,to}_user(), so make variables that store it
void * rather than char * for consistency.

Also only define a weak unxlate_dev_mem_ptr() function if architectures
haven't overridden them in the asm/io.h header file.

	Signed-off-by: Thierry Reding <treding@nvidia.com>
(cherry picked from commit 4707a341b4af57c72c1573a89d303559cf7bcf88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/io.h
#	drivers/char/mem.c
diff --cc arch/s390/include/asm/io.h
index fd9be010f9b2,d22c2eeae78f..000000000000
--- a/arch/s390/include/asm/io.h
+++ b/arch/s390/include/asm/io.h
@@@ -13,31 -13,10 +13,36 @@@
  #include <asm/page.h>
  #include <asm/pci_io.h>
  
++<<<<<<< HEAD
 +/*
 + * Change virtual addresses to physical addresses and vv.
 + * These are pretty trivial
 + */
 +static inline unsigned long virt_to_phys(volatile void * address)
 +{
 +	unsigned long real_address;
 +	asm volatile(
 +		 "	lra	%0,0(%1)\n"
 +		 "	jz	0f\n"
 +		 "	la	%0,0\n"
 +		 "0:"
 +		 : "=a" (real_address) : "a" (address) : "cc");
 +	return real_address;
 +}
 +#define virt_to_phys virt_to_phys
 +
 +static inline void * phys_to_virt(unsigned long address)
 +{
 +	return (void *) address;
 +}
 +
 +void *xlate_dev_mem_ptr(unsigned long phys);
++=======
++>>>>>>> 4707a341b4af (/dev/mem: Use more consistent data types)
  #define xlate_dev_mem_ptr xlate_dev_mem_ptr
- void unxlate_dev_mem_ptr(unsigned long phys, void *addr);
+ void *xlate_dev_mem_ptr(phys_addr_t phys);
+ #define unxlate_dev_mem_ptr unxlate_dev_mem_ptr
+ void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr);
  
  /*
   * Convert a virtual cached pointer to an uncached pointer
diff --cc drivers/char/mem.c
index 13e75e167775,4c58333b4257..000000000000
--- a/drivers/char/mem.c
+++ b/drivers/char/mem.c
@@@ -108,9 -100,10 +111,16 @@@ static ssize_t read_mem(struct file *fi
  {
  	phys_addr_t p = *ppos;
  	ssize_t read, sz;
++<<<<<<< HEAD
 +	char *ptr;
 +	char *bounce;
 +	int err;
++=======
+ 	void *ptr;
+ 
+ 	if (p != *ppos)
+ 		return 0;
++>>>>>>> 4707a341b4af (/dev/mem: Use more consistent data types)
  
  	if (!valid_phys_addr_range(p, count))
  		return -EFAULT;
* Unmerged path arch/s390/include/asm/io.h
diff --git a/arch/s390/mm/maccess.c b/arch/s390/mm/maccess.c
index 309340ae035a..a2df9800a8b2 100644
--- a/arch/s390/mm/maccess.c
+++ b/arch/s390/mm/maccess.c
@@ -202,7 +202,7 @@ static int is_swapped(unsigned long addr)
  * For swapped prefix pages a new buffer is returned that contains a copy of
  * the absolute memory. The buffer size is maximum one page large.
  */
-void *xlate_dev_mem_ptr(unsigned long addr)
+void *xlate_dev_mem_ptr(phys_addr_t addr)
 {
 	void *bounce = (void *) addr;
 	unsigned long size;
@@ -224,7 +224,7 @@ EXPORT_SYMBOL_GPL(xlate_dev_mem_ptr);
 /*
  * Free converted buffer for /dev/mem access (if necessary)
  */
-void unxlate_dev_mem_ptr(unsigned long addr, void *buf)
+void unxlate_dev_mem_ptr(phys_addr_t addr, void *buf)
 {
 	if ((void *) addr != buf)
 		free_page((unsigned long) buf);
diff --git a/arch/x86/include/asm/io.h b/arch/x86/include/asm/io.h
index 772a9eaedf5b..807180d56357 100644
--- a/arch/x86/include/asm/io.h
+++ b/arch/x86/include/asm/io.h
@@ -349,8 +349,8 @@ BUILDIO(b, b, char)
 BUILDIO(w, w, short)
 BUILDIO(l, , int)
 
-extern void *xlate_dev_mem_ptr(unsigned long phys);
-extern void unxlate_dev_mem_ptr(unsigned long phys, void *addr);
+extern void *xlate_dev_mem_ptr(phys_addr_t phys);
+extern void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr);
 
 extern int ioremap_change_attr(unsigned long vaddr, unsigned long size,
 				enum page_cache_mode pcm);
diff --git a/arch/x86/mm/ioremap.c b/arch/x86/mm/ioremap.c
index 94e769457935..3347b33e455c 100644
--- a/arch/x86/mm/ioremap.c
+++ b/arch/x86/mm/ioremap.c
@@ -401,7 +401,7 @@ int arch_ioremap_pmd_supported(void)
  * Convert a physical pointer to a virtual kernel pointer for /dev/mem
  * access
  */
-void *xlate_dev_mem_ptr(unsigned long phys)
+void *xlate_dev_mem_ptr(phys_addr_t phys)
 {
 	unsigned long start  = phys &  PAGE_MASK;
 	unsigned long offset = phys & ~PAGE_MASK;
@@ -417,7 +417,7 @@ void *xlate_dev_mem_ptr(unsigned long phys)
 	return vaddr;
 }
 
-void unxlate_dev_mem_ptr(unsigned long phys, void *addr)
+void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr)
 {
 	memunmap((void *)((unsigned long)addr & PAGE_MASK));
 }
* Unmerged path drivers/char/mem.c
