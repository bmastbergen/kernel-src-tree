ovl: don't allow writing ioctl on lower layer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 7c6893e3c9abf6a9676e060a1e35e5caca673d57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7c6893e3.failed

Problem with ioctl() is that it's a file operation, yet often used as an
inode operation (i.e. modify the inode despite the file being opened for
read-only).

mnt_want_write_file() is used by filesystems in such cases to get write
access on an arbitrary open file.

Since overlayfs lets filesystems do all file operations, including ioctl,
this can lead to mnt_want_write_file() returning OK for a lower file and
modification of that lower file.

This patch prevents modification by checking if the file is from an
overlayfs lower layer and returning EPERM in that case.

Need to introduce a mnt_want_write_file_path() variant that still does the
old thing for inode operations that can do the copy up + modification
correctly in such cases (fchown, fsetxattr, fremovexattr).

This does not address the correctness of such ioctls on overlayfs (the
correct way would be to copy up and attempt to perform ioctl on upper
file).

In theory this could be a regression.  We very much hope that nobody is
relying on such a hack in any sane setup.

While this patch meddles in VFS code, it has no effect on non-overlayfs
filesystems.

	Reported-by: "zhangyi (F)" <yi.zhang@huawei.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 7c6893e3c9abf6a9676e060a1e35e5caca673d57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xattr.c
diff --cc fs/xattr.c
index e540aca87417,d7c2cf7817bb..000000000000
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@@ -22,7 -22,61 +22,65 @@@
  #include <linux/vmalloc.h>
  #include <linux/posix_acl_xattr.h>
  
++<<<<<<< HEAD
 +#include <asm/uaccess.h>
++=======
+ #include <linux/uaccess.h>
+ #include "internal.h"
+ 
+ static const char *
+ strcmp_prefix(const char *a, const char *a_prefix)
+ {
+ 	while (*a_prefix && *a == *a_prefix) {
+ 		a++;
+ 		a_prefix++;
+ 	}
+ 	return *a_prefix ? NULL : a;
+ }
+ 
+ /*
+  * In order to implement different sets of xattr operations for each xattr
+  * prefix, a filesystem should create a null-terminated array of struct
+  * xattr_handler (one for each prefix) and hang a pointer to it off of the
+  * s_xattr field of the superblock.
+  */
+ #define for_each_xattr_handler(handlers, handler)		\
+ 	if (handlers)						\
+ 		for ((handler) = *(handlers)++;			\
+ 			(handler) != NULL;			\
+ 			(handler) = *(handlers)++)
+ 
+ /*
+  * Find the xattr_handler with the matching prefix.
+  */
+ static const struct xattr_handler *
+ xattr_resolve_name(struct inode *inode, const char **name)
+ {
+ 	const struct xattr_handler **handlers = inode->i_sb->s_xattr;
+ 	const struct xattr_handler *handler;
+ 
+ 	if (!(inode->i_opflags & IOP_XATTR)) {
+ 		if (unlikely(is_bad_inode(inode)))
+ 			return ERR_PTR(-EIO);
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 	}
+ 	for_each_xattr_handler(handlers, handler) {
+ 		const char *n;
+ 
+ 		n = strcmp_prefix(*name, xattr_prefix(handler));
+ 		if (n) {
+ 			if (!handler->prefix ^ !*n) {
+ 				if (*n)
+ 					continue;
+ 				return ERR_PTR(-EINVAL);
+ 			}
+ 			*name = n;
+ 			return handler;
+ 		}
+ 	}
+ 	return ERR_PTR(-EOPNOTSUPP);
+ }
++>>>>>>> 7c6893e3c9ab (ovl: don't allow writing ioctl on lower layer)
  
  /*
   * Check permissions for extended attribute access.  This is a bit complicated
@@@ -420,12 -496,11 +478,20 @@@ SYSCALL_DEFINE5(fsetxattr, int, fd, con
  
  	if (!f.file)
  		return error;
++<<<<<<< HEAD
 +	dentry = f.file->f_path.dentry;
 +	audit_inode(NULL, dentry, 0);
 +	error = mnt_want_write_file(f.file);
 +	if (!error) {
 +		error = setxattr(dentry, name, value, size, flags);
 +		mnt_drop_write_file(f.file);
++=======
+ 	audit_file(f.file);
+ 	error = mnt_want_write_file_path(f.file);
+ 	if (!error) {
+ 		error = setxattr(f.file->f_path.dentry, name, value, size, flags);
+ 		mnt_drop_write_file_path(f.file);
++>>>>>>> 7c6893e3c9ab (ovl: don't allow writing ioctl on lower layer)
  	}
  	fdput(f);
  	return error;
@@@ -681,12 -728,11 +747,20 @@@ SYSCALL_DEFINE2(fremovexattr, int, fd, 
  
  	if (!f.file)
  		return error;
++<<<<<<< HEAD
 +	dentry = f.file->f_path.dentry;
 +	audit_inode(NULL, dentry, 0);
 +	error = mnt_want_write_file(f.file);
 +	if (!error) {
 +		error = removexattr(dentry, name);
 +		mnt_drop_write_file(f.file);
++=======
+ 	audit_file(f.file);
+ 	error = mnt_want_write_file_path(f.file);
+ 	if (!error) {
+ 		error = removexattr(f.file->f_path.dentry, name);
+ 		mnt_drop_write_file_path(f.file);
++>>>>>>> 7c6893e3c9ab (ovl: don't allow writing ioctl on lower layer)
  	}
  	fdput(f);
  	return error;
diff --git a/fs/internal.h b/fs/internal.h
index 6e6d12ea9aaf..32db562aebdb 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -72,8 +72,10 @@ extern void __init mnt_init(void);
 
 extern int __mnt_want_write(struct vfsmount *);
 extern int __mnt_want_write_file(struct file *);
+extern int mnt_want_write_file_path(struct file *);
 extern void __mnt_drop_write(struct vfsmount *);
 extern void __mnt_drop_write_file(struct file *);
+extern void mnt_drop_write_file_path(struct file *);
 
 /*
  * fs_struct.c
diff --git a/fs/namespace.c b/fs/namespace.c
index 9350eca3d061..6c3d52231231 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -431,13 +431,18 @@ int __mnt_want_write_file(struct file *file)
 }
 
 /**
- * mnt_want_write_file - get write access to a file's mount
+ * mnt_want_write_file_path - get write access to a file's mount
  * @file: the file who's mount on which to take a write
  *
  * This is like mnt_want_write, but it takes a file and can
  * do some optimisations if the file is open for write already
+ *
+ * Called by the vfs for cases when we have an open file at hand, but will do an
+ * inode operation on it (important distinction for files opened on overlayfs,
+ * since the file operations will come from the real underlying file, while
+ * inode operations come from the overlay).
  */
-int mnt_want_write_file(struct file *file)
+int mnt_want_write_file_path(struct file *file)
 {
 	int ret;
 
@@ -447,6 +452,53 @@ int mnt_want_write_file(struct file *file)
 		sb_end_write(file->f_path.mnt->mnt_sb);
 	return ret;
 }
+
+static inline int may_write_real(struct file *file)
+{
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *upperdentry;
+
+	/* Writable file? */
+	if (file->f_mode & FMODE_WRITER)
+		return 0;
+
+	/* Not overlayfs? */
+	if (likely(!(dentry->d_flags & DCACHE_OP_REAL)))
+		return 0;
+
+	/* File refers to upper, writable layer? */
+	upperdentry = d_real(dentry, NULL, 0, D_REAL_UPPER);
+	if (upperdentry && file_inode(file) == d_inode(upperdentry))
+		return 0;
+
+	/* Lower layer: can't write to real file, sorry... */
+	return -EPERM;
+}
+
+/**
+ * mnt_want_write_file - get write access to a file's mount
+ * @file: the file who's mount on which to take a write
+ *
+ * This is like mnt_want_write, but it takes a file and can
+ * do some optimisations if the file is open for write already
+ *
+ * Mostly called by filesystems from their ioctl operation before performing
+ * modification.  On overlayfs this needs to check if the file is on a read-only
+ * lower layer and deny access in that case.
+ */
+int mnt_want_write_file(struct file *file)
+{
+	int ret;
+
+	ret = may_write_real(file);
+	if (!ret) {
+		sb_start_write(file_inode(file)->i_sb);
+		ret = __mnt_want_write_file(file);
+		if (ret)
+			sb_end_write(file_inode(file)->i_sb);
+	}
+	return ret;
+}
 EXPORT_SYMBOL_GPL(mnt_want_write_file);
 
 /**
@@ -484,10 +536,16 @@ void __mnt_drop_write_file(struct file *file)
 	__mnt_drop_write(file->f_path.mnt);
 }
 
-void mnt_drop_write_file(struct file *file)
+void mnt_drop_write_file_path(struct file *file)
 {
 	mnt_drop_write(file->f_path.mnt);
 }
+
+void mnt_drop_write_file(struct file *file)
+{
+	__mnt_drop_write(file->f_path.mnt);
+	sb_end_write(file_inode(file)->i_sb);
+}
 EXPORT_SYMBOL(mnt_drop_write_file);
 
 static int mnt_make_readonly(struct mount *mnt)
diff --git a/fs/open.c b/fs/open.c
index 877b114748a0..416b34d6b3fc 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -656,12 +656,12 @@ SYSCALL_DEFINE3(fchown, unsigned int, fd, uid_t, user, gid_t, group)
 	if (!f.file)
 		goto out;
 
-	error = mnt_want_write_file(f.file);
+	error = mnt_want_write_file_path(f.file);
 	if (error)
 		goto out_fput;
 	audit_inode(NULL, f.file->f_path.dentry, 0);
 	error = chown_common(&f.file->f_path, user, group);
-	mnt_drop_write_file(f.file);
+	mnt_drop_write_file_path(f.file);
 out_fput:
 	fdput(f);
 out:
* Unmerged path fs/xattr.c
