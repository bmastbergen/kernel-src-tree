efi/runtime-wrappers: Remove out of date comment regarding in_nmi()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ard Biesheuvel <ard.biesheuvel@linaro.org>
commit 774846defceb16dcab2f0215cfc467f7c93f1c26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/774846de.failed

This code is long gone, so remove the comment as well.

	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Signed-off-by: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
Link: http://lkml.kernel.org/r/1454364428-494-6-git-send-email-matt@codeblueprint.co.uk
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 774846defceb16dcab2f0215cfc467f7c93f1c26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/runtime-wrappers.c
diff --cc drivers/firmware/efi/runtime-wrappers.c
index dcc976822484,311f415bff51..000000000000
--- a/drivers/firmware/efi/runtime-wrappers.c
+++ b/drivers/firmware/efi/runtime-wrappers.c
@@@ -19,31 -21,48 +19,36 @@@
  #include <asm/efi.h>
  
  /*
 - * According to section 7.1 of the UEFI spec, Runtime Services are not fully
 - * reentrant, and there are particular combinations of calls that need to be
 - * serialized. (source: UEFI Specification v2.4A)
 - *
 - * Table 31. Rules for Reentry Into Runtime Services
 - * +------------------------------------+-------------------------------+
 - * | If previous call is busy in	| Forbidden to call		|
 - * +------------------------------------+-------------------------------+
 - * | Any				| SetVirtualAddressMap()	|
 - * +------------------------------------+-------------------------------+
 - * | ConvertPointer()			| ConvertPointer()		|
 - * +------------------------------------+-------------------------------+
 - * | SetVariable()			| ResetSystem()			|
 - * | UpdateCapsule()			|				|
 - * | SetTime()				|				|
 - * | SetWakeupTime()			|				|
 - * | GetNextHighMonotonicCount()	|				|
 - * +------------------------------------+-------------------------------+
 - * | GetVariable()			| GetVariable()			|
 - * | GetNextVariableName()		| GetNextVariableName()		|
 - * | SetVariable()			| SetVariable()			|
 - * | QueryVariableInfo()		| QueryVariableInfo()		|
 - * | UpdateCapsule()			| UpdateCapsule()		|
 - * | QueryCapsuleCapabilities()		| QueryCapsuleCapabilities()	|
 - * | GetNextHighMonotonicCount()	| GetNextHighMonotonicCount()	|
 - * +------------------------------------+-------------------------------+
 - * | GetTime()				| GetTime()			|
 - * | SetTime()				| SetTime()			|
 - * | GetWakeupTime()			| GetWakeupTime()		|
 - * | SetWakeupTime()			| SetWakeupTime()		|
 - * +------------------------------------+-------------------------------+
 - *
 - * Due to the fact that the EFI pstore may write to the variable store in
 - * interrupt context, we need to use a spinlock for at least the groups that
 - * contain SetVariable() and QueryVariableInfo(). That leaves little else, as
 - * none of the remaining functions are actually ever called at runtime.
 - * So let's just use a single spinlock to serialize all Runtime Services calls.
 + * Wrap around the new efi_call_virt_generic() macros so that the
 + * code doesn't get too cluttered:
   */
 -static DEFINE_SPINLOCK(efi_runtime_lock);
 +#define efi_call_virt(f, args...)   \
 +	efi_call_virt_pointer(efi.systab->runtime, f, args)
 +#define __efi_call_virt(f, args...) \
 +	__efi_call_virt_pointer(efi.systab->runtime, f, args)
 +
++<<<<<<< HEAD
 +void efi_call_virt_check_flags(unsigned long flags, const char *call)
 +{
 +	unsigned long cur_flags, mismatch;
  
 +	local_save_flags(cur_flags);
 +
 +	mismatch = flags ^ cur_flags;
 +	if (!WARN_ON_ONCE(mismatch & ARCH_EFI_IRQ_FLAGS_MASK))
 +		return;
 +
 +	add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_NOW_UNRELIABLE);
 +	pr_err_ratelimited(FW_BUG "IRQ flags corrupted (0x%08lx=>0x%08lx) by EFI %s\n",
 +			   flags, cur_flags, call);
 +	local_irq_restore(flags);
 +}
 +
 +/* As per commit ef68c8f87ed1 ("x86: Serialize EFI time accesses on rtc_lock"),
++=======
+ /*
+  * As per commit ef68c8f87ed1 ("x86: Serialize EFI time accesses on rtc_lock"),
++>>>>>>> 774846defceb (efi/runtime-wrappers: Remove out of date comment regarding in_nmi())
   * the EFI specification requires that callers of the time related runtime
   * functions serialize with other CMOS accesses in the kernel, as the EFI time
   * functions may choose to also use the legacy CMOS RTC.
* Unmerged path drivers/firmware/efi/runtime-wrappers.c
