ALSA: hda/ca0132 - Fix AE-5 control type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit 4b432ad4ca8cd63ab1c0b45d9af2d1fe7796944d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4b432ad4.failed

This patch corrects the control type of the additional AE-5 controls
added in a previous patch from HDA_INPUT to HDA_OUTPUT.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Reviewed-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 4b432ad4ca8cd63ab1c0b45d9af2d1fe7796944d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index fe65633ba745,aebc592d9ead..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -4002,6 -6019,170 +4002,173 @@@ static int add_voicefx(struct hda_code
  	return snd_hda_ctl_add(codec, VOICEFX, snd_ctl_new1(&knew, codec));
  }
  
++<<<<<<< HEAD
++=======
+ /* Create the EQ Preset control */
+ static int add_ca0132_alt_eq_presets(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO(ca0132_alt_eq_enum.name,
+ 				    EQ_PRESET_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ca0132_alt_eq_preset_info;
+ 	knew.get = ca0132_alt_eq_preset_get;
+ 	knew.put = ca0132_alt_eq_preset_put;
+ 	return snd_hda_ctl_add(codec, EQ_PRESET_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Add enumerated control for the three different settings of the smart volume
+  * output effect. Normal just uses the slider value, and loud and night are
+  * their own things that ignore that value.
+  */
+ static int ca0132_alt_add_svm_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("FX: Smart Volume Setting",
+ 				    SMART_VOLUME_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ca0132_alt_svm_setting_info;
+ 	knew.get = ca0132_alt_svm_setting_get;
+ 	knew.put = ca0132_alt_svm_setting_put;
+ 	return snd_hda_ctl_add(codec, SMART_VOLUME_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ 
+ }
+ 
+ /*
+  * Create an Output Select enumerated control for codecs with surround
+  * out capabilities.
+  */
+ static int ca0132_alt_add_output_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("Output Select",
+ 				    OUTPUT_SOURCE_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ca0132_alt_output_select_get_info;
+ 	knew.get = ca0132_alt_output_select_get;
+ 	knew.put = ca0132_alt_output_select_put;
+ 	return snd_hda_ctl_add(codec, OUTPUT_SOURCE_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Create an Input Source enumerated control for the alternate ca0132 codecs
+  * because the front microphone has no auto-detect, and Line-in has to be set
+  * somehow.
+  */
+ static int ca0132_alt_add_input_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("Input Source",
+ 				    INPUT_SOURCE_ENUM, 1, 0, HDA_INPUT);
+ 	knew.info = ca0132_alt_input_source_info;
+ 	knew.get = ca0132_alt_input_source_get;
+ 	knew.put = ca0132_alt_input_source_put;
+ 	return snd_hda_ctl_add(codec, INPUT_SOURCE_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Add mic boost enumerated control. Switches through 0dB to 30dB. This adds
+  * more control than the original mic boost, which is either full 30dB or off.
+  */
+ static int ca0132_alt_add_mic_boost_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("Mic Boost Capture Switch",
+ 				    MIC_BOOST_ENUM, 1, 0, HDA_INPUT);
+ 	knew.info = ca0132_alt_mic_boost_info;
+ 	knew.get = ca0132_alt_mic_boost_get;
+ 	knew.put = ca0132_alt_mic_boost_put;
+ 	return snd_hda_ctl_add(codec, MIC_BOOST_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ 
+ }
+ 
+ /*
+  * Add headphone gain enumerated control for the AE-5. This switches between
+  * three modes, low, medium, and high. When non-headphone outputs are selected,
+  * it is automatically set to high. This is the same behavior as Windows.
+  */
+ static int ae5_add_headphone_gain_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("AE-5: Headphone Gain",
+ 				    AE5_HEADPHONE_GAIN_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ae5_headphone_gain_info;
+ 	knew.get = ae5_headphone_gain_get;
+ 	knew.put = ae5_headphone_gain_put;
+ 	return snd_hda_ctl_add(codec, AE5_HEADPHONE_GAIN_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Add sound filter enumerated control for the AE-5. This adds three different
+  * settings: Slow Roll Off, Minimum Phase, and Fast Roll Off. From what I've
+  * read into it, it changes the DAC's interpolation filter.
+  */
+ static int ae5_add_sound_filter_enum(struct hda_codec *codec)
+ {
+ 	struct snd_kcontrol_new knew =
+ 		HDA_CODEC_MUTE_MONO("AE-5: Sound Filter",
+ 				    AE5_SOUND_FILTER_ENUM, 1, 0, HDA_OUTPUT);
+ 	knew.info = ae5_sound_filter_info;
+ 	knew.get = ae5_sound_filter_get;
+ 	knew.put = ae5_sound_filter_put;
+ 	return snd_hda_ctl_add(codec, AE5_SOUND_FILTER_ENUM,
+ 				snd_ctl_new1(&knew, codec));
+ }
+ 
+ /*
+  * Need to create slave controls for the alternate codecs that have surround
+  * capabilities.
+  */
+ static const char * const ca0132_alt_slave_pfxs[] = {
+ 	"Front", "Surround", "Center", "LFE", NULL,
+ };
+ 
+ /*
+  * Also need special channel map, because the default one is incorrect.
+  * I think this has to do with the pin for rear surround being 0x11,
+  * and the center/lfe being 0x10. Usually the pin order is the opposite.
+  */
+ static const struct snd_pcm_chmap_elem ca0132_alt_chmaps[] = {
+ 	{ .channels = 2,
+ 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },
+ 	{ .channels = 4,
+ 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+ 		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+ 	{ .channels = 6,
+ 	  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR,
+ 		   SNDRV_CHMAP_FC, SNDRV_CHMAP_LFE,
+ 		   SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },
+ 	{ }
+ };
+ 
+ /* Add the correct chmap for streams with 6 channels. */
+ static void ca0132_alt_add_chmap_ctls(struct hda_codec *codec)
+ {
+ 	int err = 0;
+ 	struct hda_pcm *pcm;
+ 
+ 	list_for_each_entry(pcm, &codec->pcm_list_head, list) {
+ 		struct hda_pcm_stream *hinfo =
+ 			&pcm->stream[SNDRV_PCM_STREAM_PLAYBACK];
+ 		struct snd_pcm_chmap *chmap;
+ 		const struct snd_pcm_chmap_elem *elem;
+ 
+ 		elem = ca0132_alt_chmaps;
+ 		if (hinfo->channels_max == 6) {
+ 			err = snd_pcm_add_chmap_ctls(pcm->pcm,
+ 					SNDRV_PCM_STREAM_PLAYBACK,
+ 					elem, hinfo->channels_max, 0, &chmap);
+ 			if (err < 0)
+ 				codec_dbg(codec, "snd_pcm_add_chmap_ctls failed!");
+ 		}
+ 	}
+ }
+ 
++>>>>>>> 4b432ad4ca8c (ALSA: hda/ca0132 - Fix AE-5 control type)
  /*
   * When changing Node IDs for Mixer Controls below, make sure to update
   * Node IDs in ca0132_config() as well.
* Unmerged path sound/pci/hda/patch_ca0132.c
