xfs: buffer lru reference count error injection tag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 7561d27e90fa0df0aac2a1d6b49c2a28eaae7026
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/7561d27e.failed

XFS uses a fixed reference count for certain types of buffers in the
internal LRU cache. These reference counts dictate how aggressively
certain buffers are reclaimed vs. others. While the reference counts
implements priority across different buffer types, all buffers
(other than uncached buffers) are typically cached for at least one
reclaim cycle.

We've had at least one bug recently that has been hidden by a
released buffer sitting around in the LRU. Users hitting the problem
were able to reproduce under enough memory pressure to cause
aggressive reclaim in a particular window of time.

To support future xfstests cases, add an error injection tag to
hardcode the buffer reference count to zero. When enabled, this
bypasses caching of associated buffers and facilitates test cases
that depend on this behavior.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 7561d27e90fa0df0aac2a1d6b49c2a28eaae7026)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_error.c
#	fs/xfs/xfs_error.h
diff --cc fs/xfs/xfs_error.c
index 6f1f3b8a712f,6732b0a0d826..000000000000
--- a/fs/xfs/xfs_error.c
+++ b/fs/xfs/xfs_error.c
@@@ -50,8 -50,15 +50,13 @@@ static unsigned int xfs_errortag_random
  	XFS_RANDOM_DIOWRITE_IOERR,
  	XFS_RANDOM_BMAPIFORMAT,
  	XFS_RANDOM_FREE_EXTENT,
 -	XFS_RANDOM_RMAP_FINISH_ONE,
 -	XFS_RANDOM_REFCOUNT_CONTINUE_UPDATE,
 -	XFS_RANDOM_REFCOUNT_FINISH_ONE,
 -	XFS_RANDOM_BMAP_FINISH_ONE,
 -	XFS_RANDOM_AG_RESV_CRITICAL,
  	XFS_RANDOM_DROP_WRITES,
  	XFS_RANDOM_LOG_BAD_CRC,
++<<<<<<< HEAD
++=======
+ 	XFS_RANDOM_LOG_ITEM_PIN,
+ 	XFS_RANDOM_BUF_LRU_REF,
++>>>>>>> 7561d27e90fa (xfs: buffer lru reference count error injection tag)
  };
  
  struct xfs_errortag_attr {
@@@ -149,8 -156,15 +154,13 @@@ XFS_ERRORTAG_ATTR_RW(stratcmpl,		XFS_ER
  XFS_ERRORTAG_ATTR_RW(diowrite,		XFS_ERRTAG_DIOWRITE_IOERR);
  XFS_ERRORTAG_ATTR_RW(bmapifmt,		XFS_ERRTAG_BMAPIFORMAT);
  XFS_ERRORTAG_ATTR_RW(free_extent,	XFS_ERRTAG_FREE_EXTENT);
 -XFS_ERRORTAG_ATTR_RW(rmap_finish_one,	XFS_ERRTAG_RMAP_FINISH_ONE);
 -XFS_ERRORTAG_ATTR_RW(refcount_continue_update,	XFS_ERRTAG_REFCOUNT_CONTINUE_UPDATE);
 -XFS_ERRORTAG_ATTR_RW(refcount_finish_one,	XFS_ERRTAG_REFCOUNT_FINISH_ONE);
 -XFS_ERRORTAG_ATTR_RW(bmap_finish_one,	XFS_ERRTAG_BMAP_FINISH_ONE);
 -XFS_ERRORTAG_ATTR_RW(ag_resv_critical,	XFS_ERRTAG_AG_RESV_CRITICAL);
  XFS_ERRORTAG_ATTR_RW(drop_writes,	XFS_ERRTAG_DROP_WRITES);
  XFS_ERRORTAG_ATTR_RW(log_bad_crc,	XFS_ERRTAG_LOG_BAD_CRC);
++<<<<<<< HEAD
++=======
+ XFS_ERRORTAG_ATTR_RW(log_item_pin,	XFS_ERRTAG_LOG_ITEM_PIN);
+ XFS_ERRORTAG_ATTR_RW(buf_lru_ref,	XFS_ERRTAG_BUF_LRU_REF);
++>>>>>>> 7561d27e90fa (xfs: buffer lru reference count error injection tag)
  
  static struct attribute *xfs_errortag_attrs[] = {
  	XFS_ERRORTAG_ATTR_LIST(noerror),
@@@ -176,8 -190,15 +186,13 @@@
  	XFS_ERRORTAG_ATTR_LIST(diowrite),
  	XFS_ERRORTAG_ATTR_LIST(bmapifmt),
  	XFS_ERRORTAG_ATTR_LIST(free_extent),
 -	XFS_ERRORTAG_ATTR_LIST(rmap_finish_one),
 -	XFS_ERRORTAG_ATTR_LIST(refcount_continue_update),
 -	XFS_ERRORTAG_ATTR_LIST(refcount_finish_one),
 -	XFS_ERRORTAG_ATTR_LIST(bmap_finish_one),
 -	XFS_ERRORTAG_ATTR_LIST(ag_resv_critical),
  	XFS_ERRORTAG_ATTR_LIST(drop_writes),
  	XFS_ERRORTAG_ATTR_LIST(log_bad_crc),
++<<<<<<< HEAD
++=======
+ 	XFS_ERRORTAG_ATTR_LIST(log_item_pin),
+ 	XFS_ERRORTAG_ATTR_LIST(buf_lru_ref),
++>>>>>>> 7561d27e90fa (xfs: buffer lru reference count error injection tag)
  	NULL,
  };
  
diff --cc fs/xfs/xfs_error.h
index 825e5352fc8d,78a7f43f8d01..000000000000
--- a/fs/xfs/xfs_error.h
+++ b/fs/xfs/xfs_error.h
@@@ -99,9 -104,11 +99,17 @@@ extern void xfs_verifier_error(struct x
   * delalloc blocks!) are tossed as part of the write failure error
   * handling sequence.
   */
++<<<<<<< HEAD
 +#define XFS_ERRTAG_DROP_WRITES				23
 +#define XFS_ERRTAG_LOG_BAD_CRC				24
 +#define XFS_ERRTAG_MAX					25
++=======
+ #define XFS_ERRTAG_DROP_WRITES				28
+ #define XFS_ERRTAG_LOG_BAD_CRC				29
+ #define XFS_ERRTAG_LOG_ITEM_PIN				30
+ #define XFS_ERRTAG_BUF_LRU_REF				31
+ #define XFS_ERRTAG_MAX					32
++>>>>>>> 7561d27e90fa (xfs: buffer lru reference count error injection tag)
  
  /*
   * Random factors for above tags, 1 means always, 2 means 1/2 time, etc.
@@@ -129,8 -136,15 +137,13 @@@
  #define XFS_RANDOM_DIOWRITE_IOERR			(XFS_RANDOM_DEFAULT/10)
  #define	XFS_RANDOM_BMAPIFORMAT				XFS_RANDOM_DEFAULT
  #define XFS_RANDOM_FREE_EXTENT				1
 -#define XFS_RANDOM_RMAP_FINISH_ONE			1
 -#define XFS_RANDOM_REFCOUNT_CONTINUE_UPDATE		1
 -#define XFS_RANDOM_REFCOUNT_FINISH_ONE			1
 -#define XFS_RANDOM_BMAP_FINISH_ONE			1
 -#define XFS_RANDOM_AG_RESV_CRITICAL			4
  #define XFS_RANDOM_DROP_WRITES				1
  #define XFS_RANDOM_LOG_BAD_CRC				1
++<<<<<<< HEAD
++=======
+ #define XFS_RANDOM_LOG_ITEM_PIN				1
+ #define XFS_RANDOM_BUF_LRU_REF				2
++>>>>>>> 7561d27e90fa (xfs: buffer lru reference count error injection tag)
  
  #ifdef DEBUG
  extern int xfs_errortag_init(struct xfs_mount *mp);
diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c
index 8d45b964cd22..d8687eff99b6 100644
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@ -41,6 +41,7 @@
 #include "xfs_mount.h"
 #include "xfs_trace.h"
 #include "xfs_log.h"
+#include "xfs_error.h"
 
 static kmem_zone_t *xfs_buf_zone;
 
@@ -2152,3 +2153,18 @@ xfs_buf_terminate(void)
 {
 	kmem_zone_destroy(xfs_buf_zone);
 }
+
+void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)
+{
+	struct xfs_mount	*mp = bp->b_target->bt_mount;
+
+	/*
+	 * Set the lru reference count to 0 based on the error injection tag.
+	 * This allows userspace to disrupt buffer caching for debug/testing
+	 * purposes.
+	 */
+	if (XFS_TEST_ERROR(false, mp, XFS_ERRTAG_BUF_LRU_REF))
+		lru_ref = 0;
+
+	atomic_set(&bp->b_lru_ref, lru_ref);
+}
diff --git a/fs/xfs/xfs_buf.h b/fs/xfs/xfs_buf.h
index 26c424a562d2..c8e1873a4840 100644
--- a/fs/xfs/xfs_buf.h
+++ b/fs/xfs/xfs_buf.h
@@ -353,10 +353,7 @@ extern void xfs_buf_terminate(void);
 #define XFS_BUF_ADDR(bp)		((bp)->b_maps[0].bm_bn)
 #define XFS_BUF_SET_ADDR(bp, bno)	((bp)->b_maps[0].bm_bn = (xfs_daddr_t)(bno))
 
-static inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)
-{
-	atomic_set(&bp->b_lru_ref, lru_ref);
-}
+void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref);
 
 /*
  * If the buffer is already on the LRU, do nothing. Otherwise set the buffer
* Unmerged path fs/xfs/xfs_error.c
* Unmerged path fs/xfs/xfs_error.h
