pkey: Indicate old mkvp only if old and current mkvp are different

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Ingo Franzki <ifranzki@linux.ibm.com>
commit ebb7c695d3bc7a4986b92edc8d9ef43491be183e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ebb7c695.failed

When the CCA master key is set twice with the same master key,
then the old and the current master key are the same and thus the
verification patterns are the same, too. The check to report if a
secure key is currently wrapped by the old master key erroneously
reports old mkvp in this case.

	Reviewed-by: Harald Freudenberger <freude@linux.ibm.com>
	Signed-off-by: Ingo Franzki <ifranzki@linux.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit ebb7c695d3bc7a4986b92edc8d9ef43491be183e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/pkey_api.c
diff --cc drivers/s390/crypto/pkey_api.c
index 4090e8247d97,3e85d665c572..000000000000
--- a/drivers/s390/crypto/pkey_api.c
+++ b/drivers/s390/crypto/pkey_api.c
@@@ -1049,8 -1079,8 +1049,13 @@@ int pkey_verifykey(const struct pkey_se
  	rc = mkvp_cache_fetch(cardnr, domain, mkvp);
  	if (rc)
  		goto out;
++<<<<<<< HEAD
 +	if (t->mkvp == mkvp[1]) {
 +		DEBUG_DBG("pkey_verifykey secure key has old mkvp\n");
++=======
+ 	if (t->mkvp == mkvp[1] && t->mkvp != mkvp[0]) {
+ 		DEBUG_DBG("%s secure key has old mkvp\n", __func__);
++>>>>>>> ebb7c695d3bc (pkey: Indicate old mkvp only if old and current mkvp are different)
  		if (pattributes)
  			*pattributes |= PKEY_VERIFY_ATTR_OLD_MKVP;
  	}
* Unmerged path drivers/s390/crypto/pkey_api.c
