ALSA: hda/ca0132 - Merge post-dsp functions + cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Connor McAdams <conmanx360@gmail.com>
commit 6ef0e91ec433f337877c9112bf0d27a9e1d0fe95
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6ef0e91e.failed

This patch cleans up some of the formatting of the post-dsp load setup
functions, and also merges some of the sub functions into individual
ones.

	Signed-off-by: Connor McAdams <conmanx360@gmail.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 6ef0e91ec433f337877c9112bf0d27a9e1d0fe95)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/patch_ca0132.c
diff --cc sound/pci/hda/patch_ca0132.c
index 20ce308ff039,b89616c57c18..000000000000
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@@ -4361,6 -6335,196 +4361,199 @@@ static void ca0132_refresh_widget_caps(
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Creates a dummy stream to bind the output to. This seems to have to be done
+  * after changing the main outputs source and destination streams.
+  */
+ static void ca0132_alt_create_dummy_stream(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int stream_format;
+ 
+ 	stream_format = snd_hdac_calc_stream_format(48000, 2,
+ 			SNDRV_PCM_FORMAT_S32_LE, 32, 0);
+ 
+ 	snd_hda_codec_setup_stream(codec, spec->dacs[0], spec->dsp_stream_id,
+ 					0, stream_format);
+ 
+ 	snd_hda_codec_cleanup_stream(codec, spec->dacs[0]);
+ }
+ 
+ /*
+  * Initialize mic for non-chromebook ca0132 implementations.
+  */
+ static void ca0132_alt_init_analog_mics(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	/* Mic 1 Setup */
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 	if (spec->quirk == QUIRK_R3DI) {
+ 		chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 		tmp = FLOAT_ONE;
+ 	} else
+ 		tmp = FLOAT_THREE;
+ 	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 	/* Mic 2 setup (not present on desktop cards) */
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN2, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT2, SR_96_000);
+ 	if (spec->quirk == QUIRK_R3DI)
+ 		chipio_set_conn_rate(codec, 0x0F, SR_96_000);
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x80, 0x01, tmp);
+ }
+ 
+ /*
+  * Sets the source of stream 0x14 to connpointID 0x48, and the destination
+  * connpointID to 0x91. If this isn't done, the destination is 0x71, and
+  * you get no sound. I'm guessing this has to do with the Sound Blaster Z
+  * having an updated DAC, which changes the destination to that DAC.
+  */
+ static void sbz_connect_streams(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 
+ 	codec_dbg(codec, "Connect Streams entered, mutex locked and loaded.\n");
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 
+ 	/* This value is 0x43 for 96khz, and 0x83 for 192khz. */
+ 	chipio_write_no_mutex(codec, 0x18a020, 0x00000043);
+ 
+ 	/* Setup stream 0x14 with it's source and destination points */
+ 	chipio_set_stream_source_dest(codec, 0x14, 0x48, 0x91);
+ 	chipio_set_conn_rate_no_mutex(codec, 0x48, SR_96_000);
+ 	chipio_set_conn_rate_no_mutex(codec, 0x91, SR_96_000);
+ 	chipio_set_stream_channels(codec, 0x14, 2);
+ 	chipio_set_stream_control(codec, 0x14, 1);
+ 
+ 	codec_dbg(codec, "Connect Streams exited, mutex released.\n");
+ 
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ /*
+  * Write data through ChipIO to setup proper stream destinations.
+  * Not sure how it exactly works, but it seems to direct data
+  * to different destinations. Example is f8 to c0, e0 to c0.
+  * All I know is, if you don't set these, you get no sound.
+  */
+ static void sbz_chipio_startup_data(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 
+ 	mutex_lock(&spec->chipio_mutex);
+ 	codec_dbg(codec, "Startup Data entered, mutex locked and loaded.\n");
+ 
+ 	/* These control audio output */
+ 	chipio_write_no_mutex(codec, 0x190060, 0x0001f8c0);
+ 	chipio_write_no_mutex(codec, 0x190064, 0x0001f9c1);
+ 	chipio_write_no_mutex(codec, 0x190068, 0x0001fac6);
+ 	chipio_write_no_mutex(codec, 0x19006c, 0x0001fbc7);
+ 	/* Signal to update I think */
+ 	chipio_write_no_mutex(codec, 0x19042c, 0x00000001);
+ 
+ 	chipio_set_stream_channels(codec, 0x0C, 6);
+ 	chipio_set_stream_control(codec, 0x0C, 1);
+ 	/* No clue what these control */
+ 	chipio_write_no_mutex(codec, 0x190030, 0x0001e0c0);
+ 	chipio_write_no_mutex(codec, 0x190034, 0x0001e1c1);
+ 	chipio_write_no_mutex(codec, 0x190038, 0x0001e4c2);
+ 	chipio_write_no_mutex(codec, 0x19003c, 0x0001e5c3);
+ 	chipio_write_no_mutex(codec, 0x190040, 0x0001e2c4);
+ 	chipio_write_no_mutex(codec, 0x190044, 0x0001e3c5);
+ 	chipio_write_no_mutex(codec, 0x190048, 0x0001e8c6);
+ 	chipio_write_no_mutex(codec, 0x19004c, 0x0001e9c7);
+ 	chipio_write_no_mutex(codec, 0x190050, 0x0001ecc8);
+ 	chipio_write_no_mutex(codec, 0x190054, 0x0001edc9);
+ 	chipio_write_no_mutex(codec, 0x190058, 0x0001eaca);
+ 	chipio_write_no_mutex(codec, 0x19005c, 0x0001ebcb);
+ 
+ 	chipio_write_no_mutex(codec, 0x19042c, 0x00000001);
+ 
+ 	codec_dbg(codec, "Startup Data exited, mutex released.\n");
+ 	mutex_unlock(&spec->chipio_mutex);
+ }
+ 
+ /*
+  * Custom DSP SCP commands where the src value is 0x00 instead of 0x20. This is
+  * done after the DSP is loaded.
+  */
+ static void ca0132_alt_dsp_scp_startup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 	case QUIRK_AE5:
+ 		tmp = 0x00000003;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		tmp = 0x00000000;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0A, tmp);
+ 		tmp = 0x00000001;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0B, tmp);
+ 		tmp = 0x00000004;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		tmp = 0x00000005;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		tmp = 0x00000000;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		break;
+ 	case QUIRK_R3D:
+ 	case QUIRK_R3DI:
+ 		tmp = 0x00000000;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0A, tmp);
+ 		tmp = 0x00000001;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0B, tmp);
+ 		tmp = 0x00000004;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		tmp = 0x00000005;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		tmp = 0x00000000;
+ 		dspio_set_uint_param_no_source(codec, 0x80, 0x0C, tmp);
+ 		break;
+ 	}
+ }
+ 
+ static void ca0132_alt_dsp_initial_mic_setup(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 
+ 	chipio_set_stream_control(codec, 0x03, 0);
+ 	chipio_set_stream_control(codec, 0x04, 0);
+ 
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);
+ 
+ 	tmp = FLOAT_THREE;
+ 	dspio_set_uint_param(codec, 0x80, 0x00, tmp);
+ 
+ 	chipio_set_stream_control(codec, 0x03, 1);
+ 	chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 		chipio_write(codec, 0x18b098, 0x0000000c);
+ 		chipio_write(codec, 0x18b09C, 0x0000000c);
+ 		break;
+ 	case QUIRK_AE5:
+ 		chipio_write(codec, 0x18b098, 0x0000000c);
+ 		chipio_write(codec, 0x18b09c, 0x0000004c);
+ 		break;
+ 	}
+ }
+ 
+ /*
++>>>>>>> 6ef0e91ec433 (ALSA: hda/ca0132 - Merge post-dsp functions + cleanup)
   * Setup default parameters for DSP
   */
  static void ca0132_setup_defaults(struct hda_codec *codec)
@@@ -4405,6 -6569,108 +4598,111 @@@
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Setup default parameters for Recon3D/Recon3Di DSP.
+  */
+ 
+ static void r3d_setup_defaults(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 	int num_fx;
+ 	int idx, i;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return;
+ 
+ 	ca0132_alt_dsp_scp_startup(codec);
+ 	ca0132_alt_init_analog_mics(codec);
+ 
+ 	/*remove DSP headroom*/
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x3C, tmp);
+ 
+ 	/* set WUH source */
+ 	tmp = FLOAT_TWO;
+ 	dspio_set_uint_param(codec, 0x31, 0x00, tmp);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);
+ 
+ 	/* Set speaker source? */
+ 	dspio_set_uint_param(codec, 0x32, 0x00, tmp);
+ 
+ 	if (spec->quirk == QUIRK_R3DI)
+ 		r3di_gpio_dsp_status_set(codec, R3DI_DSP_DOWNLOADED);
+ 
+ 	/* Setup effect defaults */
+ 	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;
+ 	for (idx = 0; idx < num_fx; idx++) {
+ 		for (i = 0; i <= ca0132_effects[idx].params; i++) {
+ 			dspio_set_uint_param(codec,
+ 					ca0132_effects[idx].mid,
+ 					ca0132_effects[idx].reqs[i],
+ 					ca0132_effects[idx].def_vals[i]);
+ 		}
+ 	}
+ }
+ 
+ /*
+  * Setup default parameters for the Sound Blaster Z DSP. A lot more going on
+  * than the Chromebook setup.
+  */
+ static void sbz_setup_defaults(struct hda_codec *codec)
+ {
+ 	struct ca0132_spec *spec = codec->spec;
+ 	unsigned int tmp;
+ 	int num_fx;
+ 	int idx, i;
+ 
+ 	if (spec->dsp_state != DSP_DOWNLOADED)
+ 		return;
+ 
+ 	ca0132_alt_dsp_scp_startup(codec);
+ 	ca0132_alt_init_analog_mics(codec);
+ 	sbz_connect_streams(codec);
+ 	sbz_chipio_startup_data(codec);
+ 
+ 	chipio_set_stream_control(codec, 0x03, 1);
+ 	chipio_set_stream_control(codec, 0x04, 1);
+ 
+ 	/*
+ 	 * Sets internal input loopback to off, used to have a switch to
+ 	 * enable input loopback, but turned out to be way too buggy.
+ 	 */
+ 	tmp = FLOAT_ONE;
+ 	dspio_set_uint_param(codec, 0x37, 0x08, tmp);
+ 	dspio_set_uint_param(codec, 0x37, 0x10, tmp);
+ 
+ 	/*remove DSP headroom*/
+ 	tmp = FLOAT_ZERO;
+ 	dspio_set_uint_param(codec, 0x96, 0x3C, tmp);
+ 
+ 	/* set WUH source */
+ 	tmp = FLOAT_TWO;
+ 	dspio_set_uint_param(codec, 0x31, 0x00, tmp);
+ 	chipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);
+ 
+ 	/* Set speaker source? */
+ 	dspio_set_uint_param(codec, 0x32, 0x00, tmp);
+ 
+ 	ca0132_alt_dsp_initial_mic_setup(codec);
+ 
+ 	/* out, in effects + voicefx */
+ 	num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;
+ 	for (idx = 0; idx < num_fx; idx++) {
+ 		for (i = 0; i <= ca0132_effects[idx].params; i++) {
+ 			dspio_set_uint_param(codec,
+ 					ca0132_effects[idx].mid,
+ 					ca0132_effects[idx].reqs[i],
+ 					ca0132_effects[idx].def_vals[i]);
+ 		}
+ 	}
+ 
+ 	ca0132_alt_create_dummy_stream(codec);
+ }
+ 
+ /*
++>>>>>>> 6ef0e91ec433 (ALSA: hda/ca0132 - Merge post-dsp functions + cleanup)
   * Initialization of flags in chip
   */
  static void ca0132_init_flags(struct hda_codec *codec)
@@@ -4443,11 -6739,51 +4741,56 @@@ static void ca0132_set_dsp_msr(struct h
  static bool ca0132_download_dsp_images(struct hda_codec *codec)
  {
  	bool dsp_loaded = false;
 -	struct ca0132_spec *spec = codec->spec;
  	const struct dsp_image_seg *dsp_os_image;
  	const struct firmware *fw_entry;
++<<<<<<< HEAD
 +
 +	if (request_firmware(&fw_entry, EFX_FILE, codec->card->dev) != 0)
 +		return false;
++=======
+ 	/*
+ 	 * Alternate firmwares for different variants. The Recon3Di apparently
+ 	 * can use the default firmware, but I'll leave the option in case
+ 	 * it needs it again.
+ 	 */
+ 	switch (spec->quirk) {
+ 	case QUIRK_SBZ:
+ 	case QUIRK_R3D:
+ 	case QUIRK_AE5:
+ 		if (request_firmware(&fw_entry, DESKTOP_EFX_FILE,
+ 					codec->card->dev) != 0) {
+ 			codec_dbg(codec, "Desktop firmware not found.");
+ 			spec->alt_firmware_present = false;
+ 		} else {
+ 			codec_dbg(codec, "Desktop firmware selected.");
+ 			spec->alt_firmware_present = true;
+ 		}
+ 		break;
+ 	case QUIRK_R3DI:
+ 		if (request_firmware(&fw_entry, R3DI_EFX_FILE,
+ 					codec->card->dev) != 0) {
+ 			codec_dbg(codec, "Recon3Di alt firmware not detected.");
+ 			spec->alt_firmware_present = false;
+ 		} else {
+ 			codec_dbg(codec, "Recon3Di firmware selected.");
+ 			spec->alt_firmware_present = true;
+ 		}
+ 		break;
+ 	default:
+ 		spec->alt_firmware_present = false;
+ 		break;
+ 	}
+ 	/*
+ 	 * Use default ctefx.bin if no alt firmware is detected, or if none
+ 	 * exists for your particular codec.
+ 	 */
+ 	if (!spec->alt_firmware_present) {
+ 		codec_dbg(codec, "Default firmware selected.");
+ 		if (request_firmware(&fw_entry, EFX_FILE,
+ 					codec->card->dev) != 0)
+ 			return false;
+ 	}
++>>>>>>> 6ef0e91ec433 (ALSA: hda/ca0132 - Merge post-dsp functions + cleanup)
  
  	dsp_os_image = (struct dsp_image_seg *)(fw_entry->data);
  	if (dspload_image(codec, dsp_os_image, 0, 0, true, 0)) {
* Unmerged path sound/pci/hda/patch_ca0132.c
