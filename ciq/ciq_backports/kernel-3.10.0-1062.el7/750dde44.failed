nvme-pci: simplify nvme_cqe_valid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 750dde4472e48eadf28221b7eb02d493db1bcfd0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/750dde44.failed

We always look at the current CQ head and phase, so don't pass these
as separate arguments, and rename the function to nvme_cqe_pending.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 750dde4472e48eadf28221b7eb02d493db1bcfd0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/pci.c
index 555634b3136a,cf36dd39f2a5..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -808,6 -1011,39 +808,42 @@@ static irqreturn_t nvme_irq_check(int i
  	return IRQ_NONE;
  }
  
++<<<<<<< HEAD
++=======
+ static int __nvme_poll(struct nvme_queue *nvmeq, unsigned int tag)
+ {
+ 	struct nvme_completion cqe;
+ 	int found = 0, consumed = 0;
+ 
+ 	if (!nvme_cqe_pending(nvmeq))
+ 		return 0;
+ 
+ 	spin_lock_irq(&nvmeq->q_lock);
+ 	while (nvme_read_cqe(nvmeq, &cqe)) {
+ 		nvme_handle_cqe(nvmeq, &cqe);
+ 		consumed++;
+ 
+ 		if (tag == cqe.command_id) {
+ 			found = 1;
+ 			break;
+ 		}
+        }
+ 
+ 	if (consumed)
+ 		nvme_ring_cq_doorbell(nvmeq);
+ 	spin_unlock_irq(&nvmeq->q_lock);
+ 
+ 	return found;
+ }
+ 
+ static int nvme_poll(struct blk_mq_hw_ctx *hctx, unsigned int tag)
+ {
+ 	struct nvme_queue *nvmeq = hctx->driver_data;
+ 
+ 	return __nvme_poll(nvmeq, tag);
+ }
+ 
++>>>>>>> 750dde4472e4 (nvme-pci: simplify nvme_cqe_valid)
  static void nvme_pci_submit_async_event(struct nvme_ctrl *ctrl)
  {
  	struct nvme_dev *dev = to_nvme_dev(ctrl);
* Unmerged path drivers/nvme/host/pci.c
