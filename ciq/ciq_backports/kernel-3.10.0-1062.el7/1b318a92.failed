net/mlx5e: Vxlan, return values for add/del port

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Vxlan, return values for add/del port (Alaa Hleihel) [1642498]
Rebuild_FUZZ: 95.65%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 1b318a92f3ddaed6c91d5027dfd42549f87602f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/1b318a92.failed

For a better API mlx5_vxlan_{add/del}_port can fail, make them return
error values.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
(cherry picked from commit 1b318a92f3ddaed6c91d5027dfd42549f87602f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
#	drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
index a2b48ad77f26,c9a50753ab23..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
@@@ -109,55 -104,62 +109,97 @@@ struct mlx5_vxlan_port *mlx5e_vxlan_loo
  	return vxlanp;
  }
  
++<<<<<<< HEAD
 +void mlx5e_vxlan_add_port(struct mlx5e_priv *priv, u16 port)
++=======
+ int mlx5_vxlan_add_port(struct mlx5_vxlan *vxlan, u16 port)
++>>>>>>> 1b318a92f3dd (net/mlx5e: Vxlan, return values for add/del port)
  {
 +	struct mlx5e_vxlan_db *vxlan_db = &priv->vxlan;
  	struct mlx5_vxlan_port *vxlanp;
+ 	int ret = -ENOSPC;
  
 -	vxlanp = mlx5_vxlan_lookup_port(vxlan, port);
 +	vxlanp = mlx5e_vxlan_lookup_port(priv, port);
  	if (vxlanp) {
  		atomic_inc(&vxlanp->refcount);
- 		return;
+ 		return 0;
  	}
  
++<<<<<<< HEAD
 +	if (vxlan_db->num_ports >= mlx5e_vxlan_max_udp_ports(priv->mdev)) {
 +		netdev_info(priv->netdev,
 +			    "UDP port (%d) not offloaded, max number of UDP ports (%d) are already offloaded\n",
 +			    port, mlx5e_vxlan_max_udp_ports(priv->mdev));
 +		return;
 +	}
 +
 +	if (mlx5e_vxlan_core_add_port_cmd(priv->mdev, port))
 +		return;
++=======
+ 	if (vxlan->num_ports >= mlx5_vxlan_max_udp_ports(vxlan->mdev)) {
+ 		mlx5_core_info(vxlan->mdev,
+ 			       "UDP port (%d) not offloaded, max number of UDP ports (%d) are already offloaded\n",
+ 			       port, mlx5_vxlan_max_udp_ports(vxlan->mdev));
+ 		ret = -ENOSPC;
+ 		return ret;
+ 	}
+ 
+ 	ret = mlx5_vxlan_core_add_port_cmd(vxlan->mdev, port);
+ 	if (ret)
+ 		return ret;
++>>>>>>> 1b318a92f3dd (net/mlx5e: Vxlan, return values for add/del port)
  
  	vxlanp = kzalloc(sizeof(*vxlanp), GFP_KERNEL);
- 	if (!vxlanp)
+ 	if (!vxlanp) {
+ 		ret = -ENOMEM;
  		goto err_delete_port;
+ 	}
  
  	vxlanp->udp_port = port;
  	atomic_set(&vxlanp->refcount, 1);
  
 -	spin_lock_bh(&vxlan->lock);
 -	hash_add(vxlan->htable, &vxlanp->hlist, port);
 -	spin_unlock_bh(&vxlan->lock);
 +	spin_lock_bh(&vxlan_db->lock);
 +	hash_add(vxlan_db->htable, &vxlanp->hlist, port);
 +	spin_unlock_bh(&vxlan_db->lock);
  
++<<<<<<< HEAD
 +	vxlan_db->num_ports++;
 +	return;
 +
 +err_delete_port:
 +	mlx5e_vxlan_core_del_port_cmd(priv->mdev, port);
 +}
 +
 +void mlx5e_vxlan_del_port(struct mlx5e_priv *priv, u16 port)
++=======
+ 	vxlan->num_ports++;
+ 	return 0;
+ 
+ err_delete_port:
+ 	mlx5_vxlan_core_del_port_cmd(vxlan->mdev, port);
+ 	return ret;
+ }
+ 
+ int mlx5_vxlan_del_port(struct mlx5_vxlan *vxlan, u16 port)
++>>>>>>> 1b318a92f3dd (net/mlx5e: Vxlan, return values for add/del port)
  {
 +	struct mlx5e_vxlan_db *vxlan_db = &priv->vxlan;
  	struct mlx5_vxlan_port *vxlanp;
  	bool remove = false;
+ 	int ret = 0;
  
++<<<<<<< HEAD
 +	spin_lock_bh(&vxlan_db->lock);
 +	vxlanp = mlx5e_vxlan_lookup_port_locked(priv, port);
 +	if (!vxlanp)
++=======
+ 	spin_lock_bh(&vxlan->lock);
+ 	vxlanp = mlx5_vxlan_lookup_port_locked(vxlan, port);
+ 	if (!vxlanp) {
+ 		ret = -ENOENT;
++>>>>>>> 1b318a92f3dd (net/mlx5e: Vxlan, return values for add/del port)
  		goto out_unlock;
+ 	}
  
  	if (atomic_dec_and_test(&vxlanp->refcount)) {
  		hash_del(&vxlanp->hlist);
@@@ -165,18 -167,39 +207,19 @@@
  	}
  
  out_unlock:
 -	spin_unlock_bh(&vxlan->lock);
 +	spin_unlock_bh(&vxlan_db->lock);
  
  	if (remove) {
 -		mlx5_vxlan_core_del_port_cmd(vxlan->mdev, port);
 +		mlx5e_vxlan_core_del_port_cmd(priv->mdev, port);
  		kfree(vxlanp);
 -		vxlan->num_ports--;
 +		vxlan_db->num_ports--;
  	}
+ 	return ret;
  }
  
 -struct mlx5_vxlan *mlx5_vxlan_create(struct mlx5_core_dev *mdev)
 -{
 -	struct mlx5_vxlan *vxlan;
 -
 -	if (!MLX5_CAP_ETH(mdev, tunnel_stateless_vxlan) || !mlx5_core_is_pf(mdev))
 -		return ERR_PTR(-ENOTSUPP);
 -
 -	vxlan = kzalloc(sizeof(*vxlan), GFP_KERNEL);
 -	if (!vxlan)
 -		return ERR_PTR(-ENOMEM);
 -
 -	vxlan->mdev = mdev;
 -	spin_lock_init(&vxlan->lock);
 -	hash_init(vxlan->htable);
 -
 -	/* Hardware adds 4789 by default */
 -	mlx5_vxlan_add_port(vxlan, 4789);
 -
 -	return vxlan;
 -}
 -
 -void mlx5_vxlan_destroy(struct mlx5_vxlan *vxlan)
 +void mlx5e_vxlan_cleanup(struct mlx5e_priv *priv)
  {
 +	struct mlx5e_vxlan_db *vxlan_db = &priv->vxlan;
  	struct mlx5_vxlan_port *vxlanp;
  	struct hlist_node *tmp;
  	int bkt;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
index 6b38b6fbd030,fd874a30c4d0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
@@@ -33,20 -33,32 +33,36 @@@
  #define __MLX5_VXLAN_H__
  
  #include <linux/mlx5/driver.h>
 +#include "en.h"
  
 -struct mlx5_vxlan;
  struct mlx5_vxlan_port;
  
 -#ifdef CONFIG_MLX5_CORE_EN
 -
 -static inline bool mlx5_vxlan_allowed(struct mlx5_vxlan *vxlan)
 +static inline bool mlx5e_vxlan_allowed(struct mlx5_core_dev *mdev)
  {
 -	/* not allowed reason is encoded in vxlan pointer as error,
 -	 * on mlx5_vxlan_create
 -	 */
 -	return !IS_ERR_OR_NULL(vxlan);
 +	return (MLX5_CAP_ETH(mdev, tunnel_stateless_vxlan) &&
 +		mlx5_core_is_pf(mdev));
  }
  
++<<<<<<< HEAD
 +void mlx5e_vxlan_init(struct mlx5e_priv *priv);
 +void mlx5e_vxlan_cleanup(struct mlx5e_priv *priv);
 +void mlx5e_vxlan_add_port(struct mlx5e_priv *priv, u16 port);
 +void mlx5e_vxlan_del_port(struct mlx5e_priv *priv, u16 port);
 +struct mlx5_vxlan_port *mlx5e_vxlan_lookup_port(struct mlx5e_priv *priv, u16 port);
++=======
+ struct mlx5_vxlan *mlx5_vxlan_create(struct mlx5_core_dev *mdev);
+ void mlx5_vxlan_destroy(struct mlx5_vxlan *vxlan);
+ int mlx5_vxlan_add_port(struct mlx5_vxlan *vxlan, u16 port);
+ int mlx5_vxlan_del_port(struct mlx5_vxlan *vxlan, u16 port);
+ struct mlx5_vxlan_port *mlx5_vxlan_lookup_port(struct mlx5_vxlan *vxlan, u16 port);
+ 
+ #else
+ 
+ static inline struct mlx5_vxlan*
+ mlx5_vxlan_create(struct mlx5_core_dev *mdev) { return ERR_PTR(-ENOTSUPP); }
+ static inline void mlx5_vxlan_destroy(struct mlx5_vxlan *vxlan) { return; }
+ 
+ #endif
++>>>>>>> 1b318a92f3dd (net/mlx5e: Vxlan, return values for add/del port)
  
  #endif /* __MLX5_VXLAN_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/vxlan.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/vxlan.h
