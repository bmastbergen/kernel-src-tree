mm: clear __GFP_FS when PF_MEMALLOC_NOIO is set

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Junxiao Bi <junxiao.bi@oracle.com>
commit 934f3072c17cc8886f4c043b47eeeb1b12f8de33
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/934f3072.failed

commit 21caf2fc1931 ("mm: teach mm by current context info to not do I/O
during memory allocation") introduces PF_MEMALLOC_NOIO flag to avoid doing
I/O inside memory allocation, __GFP_IO is cleared when this flag is set,
but __GFP_FS implies __GFP_IO, it should also be cleared.  Or it may still
run into I/O, like in superblock shrinker.  And this will make the kernel
run into the deadlock case described in that commit.

See Dave Chinner's comment about io in superblock shrinker:

Filesystem shrinkers do indeed perform IO from the superblock shrinker and
have for years.  Even clean inodes can require IO before they can be freed
- e.g.  on an orphan list, need truncation of post-eof blocks, need to
wait for ordered operations to complete before it can be freed, etc.

IOWs, Ext4, btrfs and XFS all can issue and/or block on arbitrary amounts
of IO in the superblock shrinker context.  XFS, in particular, has been
doing transactions and IO from the VFS inode cache shrinker since it was
first introduced....

Fix this by clearing __GFP_FS in memalloc_noio_flags(), this function has
masked all the gfp_mask that will be passed into fs for the processes
setting PF_MEMALLOC_NOIO in the direct reclaim path.

v1 thread at: https://lkml.org/lkml/2014/9/3/32

	Signed-off-by: Junxiao Bi <junxiao.bi@oracle.com>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: joyce.xue <xuejiufei@huawei.com>
	Cc: Ming Lei <ming.lei@canonical.com>
	Cc: Trond Myklebust <trond.myklebust@primarydata.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 934f3072c17cc8886f4c043b47eeeb1b12f8de33)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sched.h
diff --cc include/linux/sched.h
index 83cd9508a135,5e63ba59258c..000000000000
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@@ -2130,43 -1935,9 +2130,49 @@@ extern void thread_group_cputime_adjust
  #define tsk_used_math(p) ((p)->flags & PF_USED_MATH)
  #define used_math() tsk_used_math(current)
  
++<<<<<<< HEAD
 +/* Per-process atomic flags. */
 +#define PFA_NO_NEW_PRIVS 0	/* May not gain new privileges. */
 +#define PFA_SPREAD_PAGE  1      /* Spread page cache over cpuset */
 +#define PFA_SPREAD_SLAB  2      /* Spread some slab caches over cpuset */
 +
 +#define PFA_SPEC_SSB_DISABLE	   3	/* Speculative Store Bypass disabled */
 +#define PFA_SPEC_SSB_FORCE_DISABLE 4	/* Speculative Store Bypass force disabled*/
 +
 +#define TASK_PFA_TEST(name, func)                                      \
 +       static inline bool task_##func(struct task_struct *p)           \
 +       { return test_bit(PFA_##name, &p->atomic_flags); }
 +#define TASK_PFA_SET(name, func)                                       \
 +       static inline void task_set_##func(struct task_struct *p)       \
 +       { set_bit(PFA_##name, &p->atomic_flags); }
 +#define TASK_PFA_CLEAR(name, func)                                     \
 +       static inline void task_clear_##func(struct task_struct *p)     \
 +       { clear_bit(PFA_##name, &p->atomic_flags); }
 +
 +TASK_PFA_TEST(NO_NEW_PRIVS, no_new_privs)
 +TASK_PFA_SET(NO_NEW_PRIVS, no_new_privs)
 +
 +TASK_PFA_TEST(SPREAD_PAGE, spread_page)
 +TASK_PFA_SET(SPREAD_PAGE, spread_page)
 +TASK_PFA_CLEAR(SPREAD_PAGE, spread_page)
 +
 +TASK_PFA_TEST(SPREAD_SLAB, spread_slab)
 +TASK_PFA_SET(SPREAD_SLAB, spread_slab)
 +TASK_PFA_CLEAR(SPREAD_SLAB, spread_slab)
 +
 +TASK_PFA_TEST(SPEC_SSB_DISABLE, spec_ssb_disable)
 +TASK_PFA_SET(SPEC_SSB_DISABLE, spec_ssb_disable)
 +TASK_PFA_CLEAR(SPEC_SSB_DISABLE, spec_ssb_disable)
 +
 +TASK_PFA_TEST(SPEC_SSB_FORCE_DISABLE, spec_ssb_force_disable)
 +TASK_PFA_SET(SPEC_SSB_FORCE_DISABLE, spec_ssb_force_disable)
 +
 +/* __GFP_IO isn't allowed if PF_MEMALLOC_NOIO is set in current->flags */
++=======
+ /* __GFP_IO isn't allowed if PF_MEMALLOC_NOIO is set in current->flags
+  * __GFP_FS is also cleared as it implies __GFP_IO.
+  */
++>>>>>>> 934f3072c17c (mm: clear __GFP_FS when PF_MEMALLOC_NOIO is set)
  static inline gfp_t memalloc_noio_flags(gfp_t flags)
  {
  	if (unlikely(current->flags & PF_MEMALLOC_NOIO))
* Unmerged path include/linux/sched.h
