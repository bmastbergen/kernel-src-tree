netfilter: x_tables: move hook state into xt_action_param structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 613dbd95723aee7abd16860745691b6c7bda20dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/613dbd95.failed

Place pointer to hook state in xt_action_param structure instead of
copying the fields that we need. After this change xt_action_param fits
into one cacheline.

This patch also adds a set of new wrapper functions to fetch relevant
hook state structure fields.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 613dbd95723aee7abd16860745691b6c7bda20dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/x_tables.h
#	include/net/netfilter/nf_tables.h
#	net/bridge/netfilter/ebt_log.c
#	net/bridge/netfilter/ebt_nflog.c
#	net/bridge/netfilter/ebt_redirect.c
#	net/bridge/netfilter/ebtables.c
#	net/ipv4/netfilter/arp_tables.c
#	net/ipv4/netfilter/ip_tables.c
#	net/ipv4/netfilter/ipt_REJECT.c
#	net/ipv4/netfilter/ipt_SYNPROXY.c
#	net/ipv4/netfilter/ipt_rpfilter.c
#	net/ipv6/netfilter/ip6_tables.c
#	net/ipv6/netfilter/ip6t_REJECT.c
#	net/ipv6/netfilter/ip6t_SYNPROXY.c
#	net/ipv6/netfilter/ip6t_rpfilter.c
#	net/netfilter/ipset/ip_set_core.c
#	net/netfilter/xt_AUDIT.c
#	net/netfilter/xt_LOG.c
#	net/netfilter/xt_NFLOG.c
#	net/netfilter/xt_TCPMSS.c
#	net/netfilter/xt_TEE.c
#	net/netfilter/xt_TPROXY.c
#	net/netfilter/xt_addrtype.c
#	net/netfilter/xt_connlimit.c
#	net/netfilter/xt_ipvs.c
#	net/netfilter/xt_nfacct.c
#	net/netfilter/xt_osf.c
#	net/netfilter/xt_owner.c
#	net/netfilter/xt_recent.c
#	net/netfilter/xt_set.c
#	net/netfilter/xt_socket.c
#	net/sched/act_ipt.c
#	net/sched/em_ipset.c
diff --cc include/linux/netfilter/x_tables.h
index c07aca6ea5d3,cd4eaf8df445..000000000000
--- a/include/linux/netfilter/x_tables.h
+++ b/include/linux/netfilter/x_tables.h
@@@ -3,9 -3,13 +3,14 @@@
  
  
  #include <linux/netdevice.h>
++<<<<<<< HEAD
++=======
+ #include <linux/static_key.h>
+ #include <linux/netfilter.h>
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  #include <uapi/linux/netfilter/x_tables.h>
  
 -/* Test a struct->invflags and a boolean for inequality */
 -#define NF_INVF(ptr, flag, boolean)					\
 -	((boolean) ^ !!((ptr)->invflags & (flag)))
 +#include <linux/rh_kabi.h>
  
  /**
   * struct xt_action_param - parameters for matches/targets
@@@ -14,13 -18,9 +19,14 @@@
   * @target:	the target extension
   * @matchinfo:	per-match data
   * @targetinfo:	per-target data
++<<<<<<< HEAD
 + * @in:		input netdevice
 + * @out:	output netdevice
++=======
+  * @state:	pointer to hook state this packet came from
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
   * @fragoff:	packet is a fragment, this is the data offset
   * @thoff:	position of transport header relative to skb->data
-  * @hook:	hook number given packet came from
-  * @family:	Actual NFPROTO_* through which the function is invoked
-  * 		(helpful when match->family == NFPROTO_UNSPEC)
   *
   * Fields written to by extensions:
   *
@@@ -35,11 -34,9 +41,13 @@@ struct xt_action_param 
  	union {
  		const void *matchinfo, *targinfo;
  	};
++<<<<<<< HEAD
 +	const struct net_device *in, *out;
++=======
+ 	const struct nf_hook_state *state;
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	int fragoff;
  	unsigned int thoff;
- 	unsigned int hooknum;
- 	u_int8_t family;
  	bool hotdrop;
  };
  
diff --cc include/net/netfilter/nf_tables.h
index aefa47fab07d,44060344f958..000000000000
--- a/include/net/netfilter/nf_tables.h
+++ b/include/net/netfilter/nf_tables.h
@@@ -33,10 -30,29 +33,19 @@@ static inline void nft_set_pktinfo(stru
  				   const struct nf_hook_state *state)
  {
  	pkt->skb = skb;
++<<<<<<< HEAD
 +	pkt->in = pkt->xt.in = state->in;
 +	pkt->out = pkt->xt.out = state->out;
 +	pkt->hook = pkt->xt.hooknum = state->hook;
 +	pkt->pf = pkt->xt.family = state->pf;
++=======
+ 	pkt->net = state->net;
+ 	pkt->in = state->in;
+ 	pkt->out = state->out;
+ 	pkt->hook = state->hook;
+ 	pkt->pf = state->pf;
+ 	pkt->xt.state = state;
 -}
 -
 -static inline void nft_set_pktinfo_proto_unspec(struct nft_pktinfo *pkt,
 -						struct sk_buff *skb)
 -{
 -	pkt->tprot_set = false;
 -	pkt->tprot = 0;
 -	pkt->xt.thoff = 0;
 -	pkt->xt.fragoff = 0;
 -}
 -
 -static inline void nft_set_pktinfo_unspec(struct nft_pktinfo *pkt,
 -					  struct sk_buff *skb,
 -					  const struct nf_hook_state *state)
 -{
 -	nft_set_pktinfo(pkt, skb, state);
 -	nft_set_pktinfo_proto_unspec(pkt, skb);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  }
  
  /**
diff --cc net/bridge/netfilter/ebt_log.c
index 6fa89f2fb5a8,e88bd4827ac1..000000000000
--- a/net/bridge/netfilter/ebt_log.c
+++ b/net/bridge/netfilter/ebt_log.c
@@@ -180,7 -179,7 +180,11 @@@ ebt_log_tg(struct sk_buff *skb, const s
  {
  	const struct ebt_log_info *info = par->targinfo;
  	struct nf_loginfo li;
++<<<<<<< HEAD
 +	struct net *net = dev_net(par->in ? par->in : par->out);
++=======
+ 	struct net *net = xt_net(par);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	li.type = NF_LOG_TYPE_LOG;
  	li.u.log.level = info->loglevel;
diff --cc net/bridge/netfilter/ebt_nflog.c
index 59ac7952010d,c1dc48686200..000000000000
--- a/net/bridge/netfilter/ebt_nflog.c
+++ b/net/bridge/netfilter/ebt_nflog.c
@@@ -23,8 -23,8 +23,12 @@@ static unsigned in
  ebt_nflog_tg(struct sk_buff *skb, const struct xt_action_param *par)
  {
  	const struct ebt_nflog_info *info = par->targinfo;
+ 	struct net *net = xt_net(par);
  	struct nf_loginfo li;
++<<<<<<< HEAD
 +	struct net *net = dev_net(par->in ? par->in : par->out);
++=======
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	li.type = NF_LOG_TYPE_ULOG;
  	li.u.ulog.copy_len = info->len;
diff --cc net/bridge/netfilter/ebt_redirect.c
index 203964997a51,8d2a85e0594e..000000000000
--- a/net/bridge/netfilter/ebt_redirect.c
+++ b/net/bridge/netfilter/ebt_redirect.c
@@@ -23,12 -23,12 +23,17 @@@ ebt_redirect_tg(struct sk_buff *skb, co
  	if (!skb_make_writable(skb, 0))
  		return EBT_DROP;
  
++<<<<<<< HEAD
 +	if (par->hooknum != NF_BR_BROUTING)
 +		/* rcu_read_lock()ed by nf_hook_slow */
++=======
+ 	if (xt_hooknum(par) != NF_BR_BROUTING)
+ 		/* rcu_read_lock()ed by nf_hook_thresh */
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  		ether_addr_copy(eth_hdr(skb)->h_dest,
- 				br_port_get_rcu(par->in)->br->dev->dev_addr);
+ 				br_port_get_rcu(xt_in(par))->br->dev->dev_addr);
  	else
- 		ether_addr_copy(eth_hdr(skb)->h_dest, par->in->dev_addr);
+ 		ether_addr_copy(eth_hdr(skb)->h_dest, xt_in(par)->dev_addr);
  	skb->pkt_type = PACKET_HOST;
  	return info->target;
  }
diff --cc net/bridge/netfilter/ebtables.c
index 71f90ec4f774,1ab6014cf0f8..000000000000
--- a/net/bridge/netfilter/ebtables.c
+++ b/net/bridge/netfilter/ebtables.c
@@@ -198,11 -194,8 +198,14 @@@ unsigned int ebt_do_table (unsigned in
  	const struct ebt_table_info *private;
  	struct xt_action_param acpar;
  
++<<<<<<< HEAD
 +	acpar.family  = NFPROTO_BRIDGE;
 +	acpar.in      = in;
 +	acpar.out     = out;
++=======
+ 	acpar.state   = state;
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	acpar.hotdrop = false;
- 	acpar.hooknum = hook;
  
  	read_lock_bh(&table->lock);
  	private = table->private;
diff --cc net/ipv4/netfilter/arp_tables.c
index db08227b5640,e76ab23a2deb..000000000000
--- a/net/ipv4/netfilter/arp_tables.c
+++ b/net/ipv4/netfilter/arp_tables.c
@@@ -280,12 -212,12 +280,16 @@@ unsigned int arpt_do_table(struct sk_bu
  	table_base = private->entries;
  	jumpstack  = (struct arpt_entry **)private->jumpstack[cpu];
  
 -	/* No TEE support for arptables, so no need to switch to alternate
 -	 * stack.  All targets that reenter must return absolute verdicts.
 -	 */
  	e = get_entry(table_base, private->hook_entry[hook]);
  
++<<<<<<< HEAD
 +	acpar.in      = state->in;
 +	acpar.out     = state->out;
 +	acpar.hooknum = hook;
 +	acpar.family  = NFPROTO_ARP;
++=======
+ 	acpar.state   = state;
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	acpar.hotdrop = false;
  
  	arp = arp_hdr(skb);
diff --cc net/ipv4/netfilter/ip_tables.c
index 8ba1995799c8,de4fa03f46f3..000000000000
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@@ -314,10 -261,7 +314,14 @@@ ipt_do_table(struct sk_buff *skb
  	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
  	acpar.thoff   = ip_hdrlen(skb);
  	acpar.hotdrop = false;
++<<<<<<< HEAD
 +	acpar.in      = state->in;
 +	acpar.out     = state->out;
 +	acpar.family  = NFPROTO_IPV4;
 +	acpar.hooknum = hook;
++=======
+ 	acpar.state   = state;
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	IP_NF_ASSERT(table->valid_hooks & (1 << hook));
  	local_bh_disable();
diff --cc net/ipv4/netfilter/ipt_REJECT.c
index 87907d4bd259,8bd0d7b26632..000000000000
--- a/net/ipv4/netfilter/ipt_REJECT.c
+++ b/net/ipv4/netfilter/ipt_REJECT.c
@@@ -59,7 -59,7 +59,11 @@@ reject_tg(struct sk_buff *skb, const st
  		nf_send_unreach(skb, ICMP_PKT_FILTERED, hook);
  		break;
  	case IPT_TCP_RESET:
++<<<<<<< HEAD
 +		nf_send_reset(skb, hook);
++=======
+ 		nf_send_reset(xt_net(par), skb, hook);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	case IPT_ICMP_ECHOREPLY:
  		/* Doesn't happen. */
  		break;
diff --cc net/ipv4/netfilter/ipt_SYNPROXY.c
index 4a36fb966b85,361411688221..000000000000
--- a/net/ipv4/netfilter/ipt_SYNPROXY.c
+++ b/net/ipv4/netfilter/ipt_SYNPROXY.c
@@@ -261,7 -263,7 +261,11 @@@ static unsigned in
  synproxy_tg4(struct sk_buff *skb, const struct xt_action_param *par)
  {
  	const struct xt_synproxy_info *info = par->targinfo;
++<<<<<<< HEAD
 +	struct net *net = dev_net(par->in);
++=======
+ 	struct net *net = xt_net(par);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	struct synproxy_net *snet = synproxy_pernet(net);
  	struct synproxy_options opts = {};
  	struct tcphdr *th, _th;
diff --cc net/ipv4/netfilter/ipt_rpfilter.c
index 56dd8ac6d28b,59b49945b481..000000000000
--- a/net/ipv4/netfilter/ipt_rpfilter.c
+++ b/net/ipv4/netfilter/ipt_rpfilter.c
@@@ -99,7 -95,7 +99,11 @@@ static bool rpfilter_mt(const struct sk
  	flow.flowi4_tos = RT_TOS(iph->tos);
  	flow.flowi4_scope = RT_SCOPE_UNIVERSE;
  
++<<<<<<< HEAD
 +	return rpfilter_lookup_reverse(&flow, par->in, info->flags) ^ invert;
++=======
+ 	return rpfilter_lookup_reverse(xt_net(par), &flow, xt_in(par), info->flags) ^ invert;
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  }
  
  static int rpfilter_check(const struct xt_mtchk_param *par)
diff --cc net/ipv6/netfilter/ip6_tables.c
index 8d0065d4cef6,7eac01d5d621..000000000000
--- a/net/ipv6/netfilter/ip6_tables.c
+++ b/net/ipv6/netfilter/ip6_tables.c
@@@ -336,10 -291,7 +336,14 @@@ ip6t_do_table(struct sk_buff *skb
  	 * rule is also a fragment-specific rule, non-fragments won't
  	 * match it. */
  	acpar.hotdrop = false;
++<<<<<<< HEAD
 +	acpar.in      = state->in;
 +	acpar.out     = state->out;
 +	acpar.family  = NFPROTO_IPV6;
 +	acpar.hooknum = hook;
++=======
+ 	acpar.state   = state;
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	IP_NF_ASSERT(table->valid_hooks & (1 << hook));
  
diff --cc net/ipv6/netfilter/ip6t_REJECT.c
index 544b0a9da1b5,fa51a205918d..000000000000
--- a/net/ipv6/netfilter/ip6t_REJECT.c
+++ b/net/ipv6/netfilter/ip6t_REJECT.c
@@@ -40,33 -39,40 +40,50 @@@ static unsigned in
  reject_tg6(struct sk_buff *skb, const struct xt_action_param *par)
  {
  	const struct ip6t_reject_info *reject = par->targinfo;
++<<<<<<< HEAD
 +	struct net *net = dev_net((par->in != NULL) ? par->in : par->out);
++=======
+ 	struct net *net = xt_net(par);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
 +	pr_debug("%s: medium point\n", __func__);
  	switch (reject->with) {
  	case IP6T_ICMP6_NO_ROUTE:
- 		nf_send_unreach6(net, skb, ICMPV6_NOROUTE, par->hooknum);
+ 		nf_send_unreach6(net, skb, ICMPV6_NOROUTE, xt_hooknum(par));
  		break;
  	case IP6T_ICMP6_ADM_PROHIBITED:
- 		nf_send_unreach6(net, skb, ICMPV6_ADM_PROHIBITED, par->hooknum);
+ 		nf_send_unreach6(net, skb, ICMPV6_ADM_PROHIBITED,
+ 				 xt_hooknum(par));
  		break;
  	case IP6T_ICMP6_NOT_NEIGHBOUR:
- 		nf_send_unreach6(net, skb, ICMPV6_NOT_NEIGHBOUR, par->hooknum);
+ 		nf_send_unreach6(net, skb, ICMPV6_NOT_NEIGHBOUR,
+ 				 xt_hooknum(par));
  		break;
  	case IP6T_ICMP6_ADDR_UNREACH:
- 		nf_send_unreach6(net, skb, ICMPV6_ADDR_UNREACH, par->hooknum);
+ 		nf_send_unreach6(net, skb, ICMPV6_ADDR_UNREACH,
+ 				 xt_hooknum(par));
  		break;
  	case IP6T_ICMP6_PORT_UNREACH:
- 		nf_send_unreach6(net, skb, ICMPV6_PORT_UNREACH, par->hooknum);
+ 		nf_send_unreach6(net, skb, ICMPV6_PORT_UNREACH,
+ 				 xt_hooknum(par));
  		break;
  	case IP6T_ICMP6_ECHOREPLY:
  		/* Do nothing */
  		break;
  	case IP6T_TCP_RESET:
- 		nf_send_reset6(net, skb, par->hooknum);
+ 		nf_send_reset6(net, skb, xt_hooknum(par));
  		break;
++<<<<<<< HEAD
 +	default:
 +		net_info_ratelimited("case %u not handled yet\n", reject->with);
++=======
+ 	case IP6T_ICMP6_POLICY_FAIL:
+ 		nf_send_unreach6(net, skb, ICMPV6_POLICY_FAIL, xt_hooknum(par));
+ 		break;
+ 	case IP6T_ICMP6_REJECT_ROUTE:
+ 		nf_send_unreach6(net, skb, ICMPV6_REJECT_ROUTE,
+ 				 xt_hooknum(par));
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  		break;
  	}
  
diff --cc net/ipv6/netfilter/ip6t_SYNPROXY.c
index e80c07f688dc,99a1216287c8..000000000000
--- a/net/ipv6/netfilter/ip6t_SYNPROXY.c
+++ b/net/ipv6/netfilter/ip6t_SYNPROXY.c
@@@ -274,7 -277,8 +274,12 @@@ static unsigned in
  synproxy_tg6(struct sk_buff *skb, const struct xt_action_param *par)
  {
  	const struct xt_synproxy_info *info = par->targinfo;
++<<<<<<< HEAD
 +	struct synproxy_net *snet = synproxy_pernet(dev_net(par->in));
++=======
+ 	struct net *net = xt_net(par);
+ 	struct synproxy_net *snet = synproxy_pernet(net);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	struct synproxy_options opts = {};
  	struct tcphdr *th, _th;
  
diff --cc net/ipv6/netfilter/ip6t_rpfilter.c
index e0983f3648a6,d5263dc364a9..000000000000
--- a/net/ipv6/netfilter/ip6t_rpfilter.c
+++ b/net/ipv6/netfilter/ip6t_rpfilter.c
@@@ -92,7 -93,8 +92,12 @@@ static bool rpfilter_mt(const struct sk
  	if (unlikely(saddrtype == IPV6_ADDR_ANY))
  		return true ^ invert; /* not routable: forward path will drop it */
  
++<<<<<<< HEAD
 +	return rpfilter_lookup_reverse6(skb, par->in, info->flags) ^ invert;
++=======
+ 	return rpfilter_lookup_reverse6(xt_net(par), skb, xt_in(par),
+ 					info->flags) ^ invert;
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  }
  
  static int rpfilter_check(const struct xt_mtchk_param *par)
diff --cc net/netfilter/ipset/ip_set_core.c
index 067631260b46,3f1b945a24d5..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -558,8 -541,7 +558,12 @@@ in
  ip_set_test(ip_set_id_t index, const struct sk_buff *skb,
  	    const struct xt_action_param *par, struct ip_set_adt_opt *opt)
  {
++<<<<<<< HEAD
 +	struct ip_set *set = ip_set_rcu_get(
 +			dev_net(par->in ? par->in : par->out), index);
++=======
+ 	struct ip_set *set = ip_set_rcu_get(xt_net(par), index);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	int ret = 0;
  
  	BUG_ON(!set);
@@@ -597,8 -579,7 +601,12 @@@ in
  ip_set_add(ip_set_id_t index, const struct sk_buff *skb,
  	   const struct xt_action_param *par, struct ip_set_adt_opt *opt)
  {
++<<<<<<< HEAD
 +	struct ip_set *set = ip_set_rcu_get(
 +			dev_net(par->in ? par->in : par->out), index);
++=======
+ 	struct ip_set *set = ip_set_rcu_get(xt_net(par), index);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	int ret;
  
  	BUG_ON(!set);
@@@ -620,8 -601,7 +628,12 @@@ in
  ip_set_del(ip_set_id_t index, const struct sk_buff *skb,
  	   const struct xt_action_param *par, struct ip_set_adt_opt *opt)
  {
++<<<<<<< HEAD
 +	struct ip_set *set = ip_set_rcu_get(
 +			dev_net(par->in ? par->in : par->out), index);
++=======
+ 	struct ip_set *set = ip_set_rcu_get(xt_net(par), index);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	int ret = 0;
  
  	BUG_ON(!set);
diff --cc net/netfilter/xt_AUDIT.c
index 582ee54f6664,19247a17e511..000000000000
--- a/net/netfilter/xt_AUDIT.c
+++ b/net/netfilter/xt_AUDIT.c
@@@ -78,24 -131,39 +78,56 @@@ audit_tg(struct sk_buff *skb, const str
  	if (ab == NULL)
  		goto errout;
  
++<<<<<<< HEAD
 +	audit_log_format(ab, "mark=%#x", skb->mark);
 +
 +	switch (par->family) {
 +	case NFPROTO_BRIDGE:
 +		switch (eth_hdr(skb)->h_proto) {
 +		case htons(ETH_P_IP):
 +			fam = audit_ip4(ab, skb) ? NFPROTO_IPV4 : -1;
 +			break;
 +		case htons(ETH_P_IPV6):
 +			fam = audit_ip6(ab, skb) ? NFPROTO_IPV6 : -1;
 +			break;
 +		}
 +		break;
 +	case NFPROTO_IPV4:
 +		fam = audit_ip4(ab, skb) ? NFPROTO_IPV4 : -1;
++=======
+ 	audit_log_format(ab, "action=%hhu hook=%u len=%u inif=%s outif=%s",
+ 			 info->type, xt_hooknum(par), skb->len,
+ 			 xt_in(par) ? xt_inname(par) : "?",
+ 			 xt_out(par) ? xt_outname(par) : "?");
+ 
+ 	if (skb->mark)
+ 		audit_log_format(ab, " mark=%#x", skb->mark);
+ 
+ 	if (skb->dev && skb->dev->type == ARPHRD_ETHER) {
+ 		audit_log_format(ab, " smac=%pM dmac=%pM macproto=0x%04x",
+ 				 eth_hdr(skb)->h_source, eth_hdr(skb)->h_dest,
+ 				 ntohs(eth_hdr(skb)->h_proto));
+ 
+ 		if (xt_family(par) == NFPROTO_BRIDGE) {
+ 			switch (eth_hdr(skb)->h_proto) {
+ 			case htons(ETH_P_IP):
+ 				audit_ip4(ab, skb);
+ 				break;
+ 
+ 			case htons(ETH_P_IPV6):
+ 				audit_ip6(ab, skb);
+ 				break;
+ 			}
+ 		}
+ 	}
+ 
+ 	switch (xt_family(par)) {
+ 	case NFPROTO_IPV4:
+ 		audit_ip4(ab, skb);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  		break;
 -
  	case NFPROTO_IPV6:
 -		audit_ip6(ab, skb);
 +		fam = audit_ip6(ab, skb) ? NFPROTO_IPV6 : -1;
  		break;
  	}
  
diff --cc net/netfilter/xt_LOG.c
index c13b79440ede,c3b2017ebe41..000000000000
--- a/net/netfilter/xt_LOG.c
+++ b/net/netfilter/xt_LOG.c
@@@ -32,8 -32,8 +32,12 @@@ static unsigned in
  log_tg(struct sk_buff *skb, const struct xt_action_param *par)
  {
  	const struct xt_log_info *loginfo = par->targinfo;
+ 	struct net *net = xt_net(par);
  	struct nf_loginfo li;
++<<<<<<< HEAD
 +	struct net *net = dev_net(par->in ? par->in : par->out);
++=======
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	li.type = NF_LOG_TYPE_LOG;
  	li.u.log.level = loginfo->level;
diff --cc net/netfilter/xt_NFLOG.c
index fb7497c928a0,c7f8958cea4a..000000000000
--- a/net/netfilter/xt_NFLOG.c
+++ b/net/netfilter/xt_NFLOG.c
@@@ -25,16 -25,20 +25,20 @@@ static unsigned in
  nflog_tg(struct sk_buff *skb, const struct xt_action_param *par)
  {
  	const struct xt_nflog_info *info = par->targinfo;
+ 	struct net *net = xt_net(par);
  	struct nf_loginfo li;
++<<<<<<< HEAD
 +	struct net *net = dev_net(par->in ? par->in : par->out);
++=======
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	li.type		     = NF_LOG_TYPE_ULOG;
  	li.u.ulog.copy_len   = info->len;
  	li.u.ulog.group	     = info->group;
  	li.u.ulog.qthreshold = info->threshold;
 -	li.u.ulog.flags	     = 0;
 -
 -	if (info->flags & XT_NFLOG_F_COPY_LEN)
 -		li.u.ulog.flags |= NF_LOG_F_COPY_LEN;
  
- 	nfulnl_log_packet(net, par->family, par->hooknum, skb, par->in,
- 			  par->out, &li, info->prefix);
+ 	nfulnl_log_packet(net, xt_family(par), xt_hooknum(par), skb,
+ 			  xt_in(par), xt_out(par), &li, info->prefix);
  	return XT_CONTINUE;
  }
  
diff --cc net/netfilter/xt_TCPMSS.c
index cc9c1b169c91,27241a767f17..000000000000
--- a/net/netfilter/xt_TCPMSS.c
+++ b/net/netfilter/xt_TCPMSS.c
@@@ -108,20 -108,16 +108,24 @@@ tcpmss_mangle_packet(struct sk_buff *sk
  		return -1;
  
  	if (info->mss == XT_TCPMSS_CLAMP_PMTU) {
++<<<<<<< HEAD
 +		struct net *net = dev_net(par->in ? par->in : par->out);
++=======
+ 		struct net *net = xt_net(par);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  		unsigned int in_mtu = tcpmss_reverse_mtu(net, skb, family);
 -		unsigned int min_mtu = min(dst_mtu(skb_dst(skb)), in_mtu);
  
 -		if (min_mtu <= minlen) {
 +		if (dst_mtu(skb_dst(skb)) <= minlen) {
  			net_err_ratelimited("unknown or invalid path-MTU (%u)\n",
 -					    min_mtu);
 +					    dst_mtu(skb_dst(skb)));
  			return -1;
  		}
 -		newmss = min_mtu - minlen;
 +		if (in_mtu <= minlen) {
 +			net_err_ratelimited("unknown or invalid path-MTU (%u)\n",
 +					    in_mtu);
 +			return -1;
 +		}
 +		newmss = min(dst_mtu(skb_dst(skb)), in_mtu) - minlen;
  	} else
  		newmss = info->mss;
  
diff --cc net/netfilter/xt_TEE.c
index 5f20b0bccd0a,1c57ace75ae6..000000000000
--- a/net/netfilter/xt_TEE.c
+++ b/net/netfilter/xt_TEE.c
@@@ -33,7 -33,7 +33,11 @@@ tee_tg4(struct sk_buff *skb, const stru
  	const struct xt_tee_tginfo *info = par->targinfo;
  	int oif = info->priv ? info->priv->oif : 0;
  
++<<<<<<< HEAD
 +	nf_dup_ipv4(skb, par->hooknum, &info->gw.in, oif);
++=======
+ 	nf_dup_ipv4(xt_net(par), skb, xt_hooknum(par), &info->gw.in, oif);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	return XT_CONTINUE;
  }
@@@ -45,7 -45,7 +49,11 @@@ tee_tg6(struct sk_buff *skb, const stru
  	const struct xt_tee_tginfo *info = par->targinfo;
  	int oif = info->priv ? info->priv->oif : 0;
  
++<<<<<<< HEAD
 +	nf_dup_ipv6(skb, par->hooknum, &info->gw.in6, oif);
++=======
+ 	nf_dup_ipv6(xt_net(par), skb, xt_hooknum(par), &info->gw.in6, oif);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	return XT_CONTINUE;
  }
diff --cc net/netfilter/xt_TPROXY.c
index ef8a926752a9,dbd72cc40e42..000000000000
--- a/net/netfilter/xt_TPROXY.c
+++ b/net/netfilter/xt_TPROXY.c
@@@ -346,7 -364,8 +346,12 @@@ tproxy_tg4_v0(struct sk_buff *skb, cons
  {
  	const struct xt_tproxy_target_info *tgi = par->targinfo;
  
++<<<<<<< HEAD
 +	return tproxy_tg4(skb, tgi->laddr, tgi->lport, tgi->mark_mask, tgi->mark_value);
++=======
+ 	return tproxy_tg4(xt_net(par), skb, tgi->laddr, tgi->lport,
+ 			  tgi->mark_mask, tgi->mark_value);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  }
  
  static unsigned int
@@@ -354,7 -373,8 +359,12 @@@ tproxy_tg4_v1(struct sk_buff *skb, cons
  {
  	const struct xt_tproxy_target_info_v1 *tgi = par->targinfo;
  
++<<<<<<< HEAD
 +	return tproxy_tg4(skb, tgi->laddr.ip, tgi->lport, tgi->mark_mask, tgi->mark_value);
++=======
+ 	return tproxy_tg4(xt_net(par), skb, tgi->laddr.ip, tgi->lport,
+ 			  tgi->mark_mask, tgi->mark_value);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  }
  
  #ifdef XT_TPROXY_HAVE_IPV6
@@@ -424,7 -444,7 +434,11 @@@ tproxy_handle_time_wait6(struct sk_buf
  		 * to a listener socket if there's one */
  		struct sock *sk2;
  
++<<<<<<< HEAD
 +		sk2 = nf_tproxy_get_sock_v6(dev_net(skb->dev), tproto,
++=======
+ 		sk2 = nf_tproxy_get_sock_v6(xt_net(par), skb, thoff, hp, tproto,
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  					    &iph->saddr,
  					    tproxy_laddr6(skb, &tgi->laddr.in6, &iph->daddr),
  					    hp->source,
@@@ -468,10 -487,10 +482,14 @@@ tproxy_tg6_v1(struct sk_buff *skb, cons
  	 * addresses, this happens if the redirect already happened
  	 * and the current packet belongs to an already established
  	 * connection */
++<<<<<<< HEAD
 +	sk = nf_tproxy_get_sock_v6(dev_net(skb->dev), tproto,
++=======
+ 	sk = nf_tproxy_get_sock_v6(xt_net(par), skb, thoff, hp, tproto,
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  				   &iph->saddr, &iph->daddr,
  				   hp->source, hp->dest,
- 				   par->in, NFT_LOOKUP_ESTABLISHED);
+ 				   xt_in(par), NFT_LOOKUP_ESTABLISHED);
  
  	laddr = tproxy_laddr6(skb, &tgi->laddr.in6, &iph->daddr);
  	lport = tgi->lport ? tgi->lport : hp->dest;
@@@ -483,10 -502,10 +501,15 @@@
  	else if (!sk)
  		/* no there's no established connection, check if
  		 * there's a listener on the redirected addr/port */
++<<<<<<< HEAD
 +		sk = nf_tproxy_get_sock_v6(dev_net(skb->dev), tproto,
 +					   &iph->saddr, laddr,
++=======
+ 		sk = nf_tproxy_get_sock_v6(xt_net(par), skb, thoff, hp,
+ 					   tproto, &iph->saddr, laddr,
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  					   hp->source, lport,
- 					   par->in, NFT_LOOKUP_LISTENER);
+ 					   xt_in(par), NFT_LOOKUP_LISTENER);
  
  	/* NOTE: assign_sock consumes our sk reference */
  	if (sk && tproxy_sk_is_transparent(sk)) {
diff --cc net/netfilter/xt_addrtype.c
index 6347ef83ff71,e329dabde35f..000000000000
--- a/net/netfilter/xt_addrtype.c
+++ b/net/netfilter/xt_addrtype.c
@@@ -125,7 -125,7 +125,11 @@@ static inline bool match_type(struct ne
  static bool
  addrtype_mt_v0(const struct sk_buff *skb, struct xt_action_param *par)
  {
++<<<<<<< HEAD
 +	struct net *net = dev_net(par->in ? par->in : par->out);
++=======
+ 	struct net *net = xt_net(par);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	const struct xt_addrtype_info *info = par->matchinfo;
  	const struct iphdr *iph = ip_hdr(skb);
  	bool ret = true;
@@@ -143,7 -143,7 +147,11 @@@
  static bool
  addrtype_mt_v1(const struct sk_buff *skb, struct xt_action_param *par)
  {
++<<<<<<< HEAD
 +	struct net *net = dev_net(par->in ? par->in : par->out);
++=======
+ 	struct net *net = xt_net(par);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	const struct xt_addrtype_info_v1 *info = par->matchinfo;
  	const struct iphdr *iph;
  	const struct net_device *dev = NULL;
diff --cc net/netfilter/xt_connlimit.c
index 075d89d94d28,bb3845339efd..000000000000
--- a/net/netfilter/xt_connlimit.c
+++ b/net/netfilter/xt_connlimit.c
@@@ -317,7 -317,7 +317,11 @@@ static int count_them(struct net *net
  static bool
  connlimit_mt(const struct sk_buff *skb, struct xt_action_param *par)
  {
++<<<<<<< HEAD
 +	struct net *net = dev_net(par->in ? par->in : par->out);
++=======
+ 	struct net *net = xt_net(par);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	const struct xt_connlimit_info *info = par->matchinfo;
  	union nf_inet_addr addr;
  	struct nf_conntrack_tuple tuple;
@@@ -332,7 -332,7 +336,11 @@@
  		tuple_ptr = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
  		zone = nf_ct_zone(ct);
  	} else if (!nf_ct_get_tuplepr(skb, skb_network_offset(skb),
++<<<<<<< HEAD
 +				    par->family, &tuple)) {
++=======
+ 				      xt_family(par), net, &tuple)) {
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  		goto hotdrop;
  	}
  
diff --cc net/netfilter/xt_ipvs.c
index 8d47c3780fda,0fdc89064488..000000000000
--- a/net/netfilter/xt_ipvs.c
+++ b/net/netfilter/xt_ipvs.c
@@@ -48,8 -48,9 +48,12 @@@ static boo
  ipvs_mt(const struct sk_buff *skb, struct xt_action_param *par)
  {
  	const struct xt_ipvs_mtinfo *data = par->matchinfo;
++<<<<<<< HEAD
++=======
+ 	struct netns_ipvs *ipvs = net_ipvs(xt_net(par));
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	/* ipvs_mt_check ensures that family is only NFPROTO_IPV[46]. */
- 	const u_int8_t family = par->family;
+ 	const u_int8_t family = xt_family(par);
  	struct ip_vs_iphdr iph;
  	struct ip_vs_protocol *pp;
  	struct ip_vs_conn *cp;
diff --cc net/netfilter/xt_nfacct.c
index b3be0ef21f19,cc0518fe598e..000000000000
--- a/net/netfilter/xt_nfacct.c
+++ b/net/netfilter/xt_nfacct.c
@@@ -25,7 -26,9 +25,13 @@@ static bool nfacct_mt(const struct sk_b
  
  	nfnl_acct_update(skb, info->nfacct);
  
++<<<<<<< HEAD
 +	return true;
++=======
+ 	overquota = nfnl_acct_overquota(xt_net(par), skb, info->nfacct);
+ 
+ 	return overquota == NFACCT_UNDERQUOTA ? false : true;
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  }
  
  static int
diff --cc net/netfilter/xt_osf.c
index de49ff18963a,c05fefcec238..000000000000
--- a/net/netfilter/xt_osf.c
+++ b/net/netfilter/xt_osf.c
@@@ -208,7 -201,7 +208,11 @@@ xt_osf_match_packet(const struct sk_buf
  	unsigned char opts[MAX_IPOPTLEN];
  	const struct xt_osf_finger *kf;
  	const struct xt_osf_user_finger *f;
++<<<<<<< HEAD
 +	struct net *net = dev_net(p->in ? p->in : p->out);
++=======
+ 	struct net *net = xt_net(p);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	if (!info)
  		return false;
@@@ -241,110 -236,107 +245,131 @@@
  		optp = _optp;
  		fmatch = FMATCH_WRONG;
  
 -		if (totlen != f->ss || !xt_osf_ttl(skb, info, f->ttl))
 -			continue;
 +		if (totlen == f->ss && xt_osf_ttl(skb, info, f->ttl)) {
 +			int foptsize, optnum;
  
 -		/*
 -		 * Should not happen if userspace parser was written correctly.
 -		 */
 -		if (f->wss.wc >= OSF_WSS_MAX)
 -			continue;
 +			/*
 +			 * Should not happen if userspace parser was written correctly.
 +			 */
 +			if (f->wss.wc >= OSF_WSS_MAX)
 +				continue;
  
 -		/* Check options */
 +			/* Check options */
  
 -		foptsize = 0;
 -		for (optnum = 0; optnum < f->opt_num; ++optnum)
 -			foptsize += f->opt[optnum].length;
 +			foptsize = 0;
 +			for (optnum = 0; optnum < f->opt_num; ++optnum)
 +				foptsize += f->opt[optnum].length;
  
 -		if (foptsize > MAX_IPOPTLEN ||
 -		    optsize > MAX_IPOPTLEN ||
 -		    optsize != foptsize)
 -			continue;
 +			if (foptsize > MAX_IPOPTLEN ||
 +				optsize > MAX_IPOPTLEN ||
 +				optsize != foptsize)
 +				continue;
  
 -		check_WSS = f->wss.wc;
 +			check_WSS = f->wss.wc;
  
 -		for (optnum = 0; optnum < f->opt_num; ++optnum) {
 -			if (f->opt[optnum].kind == (*optp)) {
 -				__u32 len = f->opt[optnum].length;
 -				const __u8 *optend = optp + len;
 +			for (optnum = 0; optnum < f->opt_num; ++optnum) {
 +				if (f->opt[optnum].kind == (*optp)) {
 +					__u32 len = f->opt[optnum].length;
 +					const __u8 *optend = optp + len;
 +					int loop_cont = 0;
  
 -				fmatch = FMATCH_OK;
 +					fmatch = FMATCH_OK;
  
 -				switch (*optp) {
 -				case OSFOPT_MSS:
 -					mss = optp[3];
 -					mss <<= 8;
 -					mss |= optp[2];
 +					switch (*optp) {
 +					case OSFOPT_MSS:
 +						mss = optp[3];
 +						mss <<= 8;
 +						mss |= optp[2];
  
 -					mss = ntohs((__force __be16)mss);
 +						mss = ntohs((__force __be16)mss);
 +						break;
 +					case OSFOPT_TS:
 +						loop_cont = 1;
 +						break;
 +					}
 +
 +					optp = optend;
 +				} else
 +					fmatch = FMATCH_OPT_WRONG;
 +
 +				if (fmatch != FMATCH_OK)
 +					break;
 +			}
 +
 +			if (fmatch != FMATCH_OPT_WRONG) {
 +				fmatch = FMATCH_WRONG;
 +
 +				switch (check_WSS) {
 +				case OSF_WSS_PLAIN:
 +					if (f->wss.val == 0 || window == f->wss.val)
 +						fmatch = FMATCH_OK;
 +					break;
 +				case OSF_WSS_MSS:
 +					/*
 +					 * Some smart modems decrease mangle MSS to 
 +					 * SMART_MSS_2, so we check standard, decreased
 +					 * and the one provided in the fingerprint MSS
 +					 * values.
 +					 */
 +#define SMART_MSS_1	1460
 +#define SMART_MSS_2	1448
 +					if (window == f->wss.val * mss ||
 +					    window == f->wss.val * SMART_MSS_1 ||
 +					    window == f->wss.val * SMART_MSS_2)
 +						fmatch = FMATCH_OK;
 +					break;
 +				case OSF_WSS_MTU:
 +					if (window == f->wss.val * (mss + 40) ||
 +					    window == f->wss.val * (SMART_MSS_1 + 40) ||
 +					    window == f->wss.val * (SMART_MSS_2 + 40))
 +						fmatch = FMATCH_OK;
  					break;
 -				case OSFOPT_TS:
 +				case OSF_WSS_MODULO:
 +					if ((window % f->wss.val) == 0)
 +						fmatch = FMATCH_OK;
  					break;
  				}
 -
 -				optp = optend;
 -			} else
 -				fmatch = FMATCH_OPT_WRONG;
 +			}
  
  			if (fmatch != FMATCH_OK)
 -				break;
 -		}
 +				continue;
  
 -		if (fmatch != FMATCH_OPT_WRONG) {
 -			fmatch = FMATCH_WRONG;
 +			fcount++;
  
 -			switch (check_WSS) {
 -			case OSF_WSS_PLAIN:
 -				if (f->wss.val == 0 || window == f->wss.val)
 -					fmatch = FMATCH_OK;
 -				break;
 -			case OSF_WSS_MSS:
 -				/*
 -				 * Some smart modems decrease mangle MSS to
 -				 * SMART_MSS_2, so we check standard, decreased
 -				 * and the one provided in the fingerprint MSS
 -				 * values.
 -				 */
 -#define SMART_MSS_1	1460
 -#define SMART_MSS_2	1448
 -				if (window == f->wss.val * mss ||
 -				    window == f->wss.val * SMART_MSS_1 ||
 -				    window == f->wss.val * SMART_MSS_2)
 -					fmatch = FMATCH_OK;
 -				break;
 -			case OSF_WSS_MTU:
 -				if (window == f->wss.val * (mss + 40) ||
 -				    window == f->wss.val * (SMART_MSS_1 + 40) ||
 -				    window == f->wss.val * (SMART_MSS_2 + 40))
 -					fmatch = FMATCH_OK;
 -				break;
 -			case OSF_WSS_MODULO:
 -				if ((window % f->wss.val) == 0)
 -					fmatch = FMATCH_OK;
 +			if (info->flags & XT_OSF_LOG)
 +				nf_log_packet(net, p->family, p->hooknum, skb,
 +					p->in, p->out, NULL,
 +					"%s [%s:%s] : %pI4:%d -> %pI4:%d hops=%d\n",
 +					f->genre, f->version, f->subtype,
 +					&ip->saddr, ntohs(tcp->source),
 +					&ip->daddr, ntohs(tcp->dest),
 +					f->ttl - ip->ttl);
 +
 +			if ((info->flags & XT_OSF_LOG) &&
 +			    info->loglevel == XT_OSF_LOGLEVEL_FIRST)
  				break;
 -			}
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		if (fmatch != FMATCH_OK)
+ 			continue;
+ 
+ 		fcount++;
+ 
+ 		if (info->flags & XT_OSF_LOG)
+ 			nf_log_packet(net, xt_family(p), xt_hooknum(p), skb,
+ 				      xt_in(p), xt_out(p), NULL,
+ 				      "%s [%s:%s] : %pI4:%d -> %pI4:%d hops=%d\n",
+ 				      f->genre, f->version, f->subtype,
+ 				      &ip->saddr, ntohs(tcp->source),
+ 				      &ip->daddr, ntohs(tcp->dest),
+ 				      f->ttl - ip->ttl);
+ 
+ 		if ((info->flags & XT_OSF_LOG) &&
+ 		    info->loglevel == XT_OSF_LOGLEVEL_FIRST)
+ 			break;
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	}
  	rcu_read_unlock();
  
diff --cc net/netfilter/xt_owner.c
index 1302b475abcb,16477df45b3b..000000000000
--- a/net/netfilter/xt_owner.c
+++ b/net/netfilter/xt_owner.c
@@@ -35,6 -63,7 +35,10 @@@ owner_mt(const struct sk_buff *skb, str
  	const struct xt_owner_match_info *info = par->matchinfo;
  	const struct file *filp;
  	struct sock *sk = skb_to_full_sk(skb);
++<<<<<<< HEAD
++=======
+ 	struct net *net = xt_net(par);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	if (sk == NULL || sk->sk_socket == NULL)
  		return (info->match ^ info->invert) == 0;
diff --cc net/netfilter/xt_recent.c
index 31c5e0046dd0,bf250000e084..000000000000
--- a/net/netfilter/xt_recent.c
+++ b/net/netfilter/xt_recent.c
@@@ -228,7 -236,7 +228,11 @@@ static void recent_table_flush(struct r
  static bool
  recent_mt(const struct sk_buff *skb, struct xt_action_param *par)
  {
++<<<<<<< HEAD
 +	struct net *net = dev_net(par->in ? par->in : par->out);
++=======
+ 	struct net *net = xt_net(par);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	struct recent_net *recent_net = recent_pernet(net);
  	const struct xt_recent_mtinfo_v1 *info = par->matchinfo;
  	struct recent_table *t;
diff --cc net/netfilter/xt_set.c
index bb2c08cd66da,1bfede7be418..000000000000
--- a/net/netfilter/xt_set.c
+++ b/net/netfilter/xt_set.c
@@@ -59,9 -55,8 +59,14 @@@ set_match_v0(const struct sk_buff *skb
  {
  	const struct xt_set_info_match_v0 *info = par->matchinfo;
  
++<<<<<<< HEAD
 +	ADT_OPT(opt, par->family, info->match_set.u.compat.dim,
 +		info->match_set.u.compat.flags, 0, UINT_MAX,
 +		0, 0, 0, 0);
++=======
+ 	ADT_OPT(opt, xt_family(par), info->match_set.u.compat.dim,
+ 		info->match_set.u.compat.flags, 0, UINT_MAX);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	return match_set(info->match_set.index, skb, par, &opt,
  			 info->match_set.u.compat.flags & IPSET_INV_MATCH);
@@@ -123,9 -118,8 +128,14 @@@ set_match_v1(const struct sk_buff *skb
  {
  	const struct xt_set_info_match_v1 *info = par->matchinfo;
  
++<<<<<<< HEAD
 +	ADT_OPT(opt, par->family, info->match_set.dim,
 +		info->match_set.flags, 0, UINT_MAX,
 +		0, 0, 0, 0);
++=======
+ 	ADT_OPT(opt, xt_family(par), info->match_set.dim,
+ 		info->match_set.flags, 0, UINT_MAX);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	if (opt.flags & IPSET_RETURN_NOMATCH)
  		opt.cmdflags |= IPSET_FLAG_RETURN_NOMATCH;
@@@ -170,11 -182,10 +180,16 @@@ static boo
  set_match_v3(const struct sk_buff *skb, struct xt_action_param *par)
  {
  	const struct xt_set_info_match_v3 *info = par->matchinfo;
 -	int ret;
  
++<<<<<<< HEAD
 +	ADT_OPT(opt, par->family, info->match_set.dim,
 +		info->match_set.flags, info->flags, UINT_MAX,
 +		info->packets.value, info->bytes.value,
 +		info->packets.op, info->bytes.op);
++=======
+ 	ADT_OPT(opt, xt_family(par), info->match_set.dim,
+ 		info->match_set.flags, info->flags, UINT_MAX);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	if (info->packets.op != IPSET_COUNTER_NONE ||
  	    info->bytes.op != IPSET_COUNTER_NONE)
@@@ -193,11 -229,10 +208,16 @@@ static boo
  set_match_v4(const struct sk_buff *skb, struct xt_action_param *par)
  {
  	const struct xt_set_info_match_v4 *info = par->matchinfo;
 -	int ret;
  
++<<<<<<< HEAD
 +	ADT_OPT(opt, par->family, info->match_set.dim,
 +		info->match_set.flags, info->flags, UINT_MAX,
 +		info->packets.value, info->bytes.value,
 +		info->packets.op, info->bytes.op);
++=======
+ 	ADT_OPT(opt, xt_family(par), info->match_set.dim,
+ 		info->match_set.flags, info->flags, UINT_MAX);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	if (info->packets.op != IPSET_COUNTER_NONE ||
  	    info->bytes.op != IPSET_COUNTER_NONE)
@@@ -217,12 -259,10 +237,19 @@@ set_target_v0(struct sk_buff *skb, cons
  {
  	const struct xt_set_info_target_v0 *info = par->targinfo;
  
++<<<<<<< HEAD
 +	ADT_OPT(add_opt, par->family, info->add_set.u.compat.dim,
 +		info->add_set.u.compat.flags, 0, UINT_MAX,
 +		0, 0, 0, 0);
 +	ADT_OPT(del_opt, par->family, info->del_set.u.compat.dim,
 +		info->del_set.u.compat.flags, 0, UINT_MAX,
 +		0, 0, 0, 0);
++=======
+ 	ADT_OPT(add_opt, xt_family(par), info->add_set.u.compat.dim,
+ 		info->add_set.u.compat.flags, 0, UINT_MAX);
+ 	ADT_OPT(del_opt, xt_family(par), info->del_set.u.compat.dim,
+ 		info->del_set.u.compat.flags, 0, UINT_MAX);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	if (info->add_set.index != IPSET_INVALID_ID)
  		ip_set_add(info->add_set.index, skb, par, &add_opt);
@@@ -292,12 -332,10 +319,19 @@@ set_target_v1(struct sk_buff *skb, cons
  {
  	const struct xt_set_info_target_v1 *info = par->targinfo;
  
++<<<<<<< HEAD
 +	ADT_OPT(add_opt, par->family, info->add_set.dim,
 +		info->add_set.flags, 0, UINT_MAX,
 +		0, 0, 0, 0);
 +	ADT_OPT(del_opt, par->family, info->del_set.dim,
 +		info->del_set.flags, 0, UINT_MAX,
 +		0, 0, 0, 0);
++=======
+ 	ADT_OPT(add_opt, xt_family(par), info->add_set.dim,
+ 		info->add_set.flags, 0, UINT_MAX);
+ 	ADT_OPT(del_opt, xt_family(par), info->del_set.dim,
+ 		info->del_set.flags, 0, UINT_MAX);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	if (info->add_set.index != IPSET_INVALID_ID)
  		ip_set_add(info->add_set.index, skb, par, &add_opt);
@@@ -363,12 -401,10 +397,19 @@@ set_target_v2(struct sk_buff *skb, cons
  {
  	const struct xt_set_info_target_v2 *info = par->targinfo;
  
++<<<<<<< HEAD
 +	ADT_OPT(add_opt, par->family, info->add_set.dim,
 +		info->add_set.flags, info->flags, info->timeout,
 +		0, 0, 0, 0);
 +	ADT_OPT(del_opt, par->family, info->del_set.dim,
 +		info->del_set.flags, 0, UINT_MAX,
 +		0, 0, 0, 0);
++=======
+ 	ADT_OPT(add_opt, xt_family(par), info->add_set.dim,
+ 		info->add_set.flags, info->flags, info->timeout);
+ 	ADT_OPT(del_opt, xt_family(par), info->del_set.dim,
+ 		info->del_set.flags, 0, UINT_MAX);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	/* Normalize to fit into jiffies */
  	if (add_opt.ext.timeout != IPSET_NO_TIMEOUT &&
@@@ -395,15 -429,12 +436,24 @@@ set_target_v3(struct sk_buff *skb, cons
  	const struct xt_set_info_target_v3 *info = par->targinfo;
  	int ret;
  
++<<<<<<< HEAD
 +	ADT_OPT(add_opt, par->family, info->add_set.dim,
 +		info->add_set.flags, info->flags, info->timeout,
 +		0, 0, 0, 0);
 +	ADT_OPT(del_opt, par->family, info->del_set.dim,
 +		info->del_set.flags, 0, UINT_MAX,
 +		0, 0, 0, 0);
 +	ADT_OPT(map_opt, par->family, info->map_set.dim,
 +		info->map_set.flags, 0, UINT_MAX,
 +		0, 0, 0, 0);
++=======
+ 	ADT_OPT(add_opt, xt_family(par), info->add_set.dim,
+ 		info->add_set.flags, info->flags, info->timeout);
+ 	ADT_OPT(del_opt, xt_family(par), info->del_set.dim,
+ 		info->del_set.flags, 0, UINT_MAX);
+ 	ADT_OPT(map_opt, xt_family(par), info->map_set.dim,
+ 		info->map_set.flags, 0, UINT_MAX);
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	/* Normalize to fit into jiffies */
  	if (add_opt.ext.timeout != IPSET_NO_TIMEOUT &&
diff --cc net/netfilter/xt_socket.c
index 1ba67931eb1b,2198914707f5..000000000000
--- a/net/netfilter/xt_socket.c
+++ b/net/netfilter/xt_socket.c
@@@ -133,60 -53,11 +133,64 @@@ static boo
  socket_match(const struct sk_buff *skb, struct xt_action_param *par,
  	     const struct xt_socket_mtinfo1 *info)
  {
 -	struct sk_buff *pskb = (struct sk_buff *)skb;
 +	const struct iphdr *iph = ip_hdr(skb);
 +	struct udphdr _hdr, *hp = NULL;
  	struct sock *sk = skb->sk;
 +	__be32 uninitialized_var(daddr), uninitialized_var(saddr);
 +	__be16 uninitialized_var(dport), uninitialized_var(sport);
 +	u8 uninitialized_var(protocol);
 +#ifdef XT_SOCKET_HAVE_CONNTRACK
 +	struct nf_conn const *ct;
 +	enum ip_conntrack_info ctinfo;
 +#endif
 +
 +	if (iph->protocol == IPPROTO_UDP || iph->protocol == IPPROTO_TCP) {
 +		hp = skb_header_pointer(skb, ip_hdrlen(skb),
 +					sizeof(_hdr), &_hdr);
 +		if (hp == NULL)
 +			return false;
 +
 +		protocol = iph->protocol;
 +		saddr = iph->saddr;
 +		sport = hp->source;
 +		daddr = iph->daddr;
 +		dport = hp->dest;
 +
 +	} else if (iph->protocol == IPPROTO_ICMP) {
 +		if (extract_icmp4_fields(skb, &protocol, &saddr, &daddr,
 +					&sport, &dport))
 +			return false;
 +	} else {
 +		return false;
 +	}
 +
 +#ifdef XT_SOCKET_HAVE_CONNTRACK
 +	/* Do the lookup with the original socket address in case this is a
 +	 * reply packet of an established SNAT-ted connection. */
 +
 +	ct = nf_ct_get(skb, &ctinfo);
 +	if (ct && !nf_ct_is_untracked(ct) &&
 +	    ((iph->protocol != IPPROTO_ICMP &&
 +	      ctinfo == IP_CT_ESTABLISHED_REPLY) ||
 +	     (iph->protocol == IPPROTO_ICMP &&
 +	      ctinfo == IP_CT_RELATED_REPLY)) &&
 +	    (ct->status & IPS_SRC_NAT_DONE)) {
 +
 +		daddr = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
 +		dport = (iph->protocol == IPPROTO_TCP) ?
 +			ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.tcp.port :
 +			ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;
 +	}
 +#endif
  
  	if (!sk)
++<<<<<<< HEAD
 +		sk = xt_socket_get_sock_v4(dev_net(skb->dev), protocol,
 +					   saddr, daddr, sport, dport,
 +					   par->in);
++=======
+ 		sk = nf_sk_lookup_slow_v4(xt_net(par), skb, xt_in(par));
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	if (sk) {
  		bool wildcard;
  		bool transparent = true;
@@@ -237,121 -105,16 +241,125 @@@ socket_mt4_v1_v2(const struct sk_buff *
  	return socket_match(skb, par, par->matchinfo);
  }
  
 -#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)
 +#ifdef XT_SOCKET_HAVE_IPV6
 +
 +static int
 +extract_icmp6_fields(const struct sk_buff *skb,
 +		     unsigned int outside_hdrlen,
 +		     int *protocol,
 +		     struct in6_addr **raddr,
 +		     struct in6_addr **laddr,
 +		     __be16 *rport,
 +		     __be16 *lport)
 +{
 +	struct ipv6hdr *inside_iph, _inside_iph;
 +	struct icmp6hdr *icmph, _icmph;
 +	__be16 *ports, _ports[2];
 +	u8 inside_nexthdr;
 +	__be16 inside_fragoff;
 +	int inside_hdrlen;
 +
 +	icmph = skb_header_pointer(skb, outside_hdrlen,
 +				   sizeof(_icmph), &_icmph);
 +	if (icmph == NULL)
 +		return 1;
 +
 +	if (icmph->icmp6_type & ICMPV6_INFOMSG_MASK)
 +		return 1;
 +
 +	inside_iph = skb_header_pointer(skb, outside_hdrlen + sizeof(_icmph), sizeof(_inside_iph), &_inside_iph);
 +	if (inside_iph == NULL)
 +		return 1;
 +	inside_nexthdr = inside_iph->nexthdr;
 +
 +	inside_hdrlen = ipv6_skip_exthdr(skb, outside_hdrlen + sizeof(_icmph) + sizeof(_inside_iph),
 +					 &inside_nexthdr, &inside_fragoff);
 +	if (inside_hdrlen < 0)
 +		return 1; /* hjm: Packet has no/incomplete transport layer headers. */
 +
 +	if (inside_nexthdr != IPPROTO_TCP &&
 +	    inside_nexthdr != IPPROTO_UDP)
 +		return 1;
 +
 +	ports = skb_header_pointer(skb, inside_hdrlen,
 +				   sizeof(_ports), &_ports);
 +	if (ports == NULL)
 +		return 1;
 +
 +	/* the inside IP packet is the one quoted from our side, thus
 +	 * its saddr is the local address */
 +	*protocol = inside_nexthdr;
 +	*laddr = &inside_iph->saddr;
 +	*lport = ports[0];
 +	*raddr = &inside_iph->daddr;
 +	*rport = ports[1];
 +
 +	return 0;
 +}
 +
 +static struct sock *
 +xt_socket_get_sock_v6(struct net *net, const u8 protocol,
 +		      const struct in6_addr *saddr, const struct in6_addr *daddr,
 +		      const __be16 sport, const __be16 dport,
 +		      const struct net_device *in)
 +{
 +	switch (protocol) {
 +	case IPPROTO_TCP:
 +		return inet6_lookup(net, &tcp_hashinfo,
 +				    saddr, sport, daddr, dport,
 +				    in->ifindex);
 +	case IPPROTO_UDP:
 +		return udp6_lib_lookup(net, saddr, sport, daddr, dport,
 +				       in->ifindex);
 +	}
 +
 +	return NULL;
 +}
 +
  static bool
 -socket_mt6_v1_v2_v3(const struct sk_buff *skb, struct xt_action_param *par)
 +socket_mt6_v1_v2(const struct sk_buff *skb, struct xt_action_param *par)
  {
 -	const struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par->matchinfo;
 -	struct sk_buff *pskb = (struct sk_buff *)skb;
 +	struct ipv6hdr *iph = ipv6_hdr(skb);
 +	struct udphdr _hdr, *hp = NULL;
  	struct sock *sk = skb->sk;
 +	struct in6_addr *daddr = NULL, *saddr = NULL;
 +	__be16 uninitialized_var(dport), uninitialized_var(sport);
 +	int thoff = 0, uninitialized_var(tproto);
 +	const struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par->matchinfo;
 +
 +	tproto = ipv6_find_hdr(skb, &thoff, -1, NULL, NULL);
 +	if (tproto < 0) {
 +		pr_debug("unable to find transport header in IPv6 packet, dropping\n");
 +		return NF_DROP;
 +	}
 +
 +	if (tproto == IPPROTO_UDP || tproto == IPPROTO_TCP) {
 +		hp = skb_header_pointer(skb, thoff,
 +					sizeof(_hdr), &_hdr);
 +		if (hp == NULL)
 +			return false;
 +
 +		saddr = &iph->saddr;
 +		sport = hp->source;
 +		daddr = &iph->daddr;
 +		dport = hp->dest;
 +
 +	} else if (tproto == IPPROTO_ICMPV6) {
 +		if (extract_icmp6_fields(skb, thoff, &tproto, &saddr, &daddr,
 +					 &sport, &dport))
 +			return false;
 +	} else {
 +		return false;
 +	}
  
  	if (!sk)
++<<<<<<< HEAD
 +		sk = xt_socket_get_sock_v6(dev_net(skb->dev), tproto,
 +					   saddr, daddr, sport, dport,
 +					   par->in);
++=======
+ 		sk = nf_sk_lookup_slow_v6(xt_net(par), skb, xt_in(par));
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	if (sk) {
  		bool wildcard;
  		bool transparent = true;
diff --cc net/sched/act_ipt.c
index 4ae4144607be,ce7ea6c1c50d..000000000000
--- a/net/sched/act_ipt.c
+++ b/net/sched/act_ipt.c
@@@ -226,12 -232,9 +232,15 @@@ static int tcf_ipt(struct sk_buff *skb
  	 * worry later - danger - this API seems to have changed
  	 * from earlier kernels
  	 */
++<<<<<<< HEAD
 +	par.in       = skb->dev;
 +	par.out      = NULL;
 +	par.hooknum  = ipt->tcfi_hook;
++=======
+ 	par.state    = &state;
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  	par.target   = ipt->tcfi_t->u.kernel.target;
  	par.targinfo = ipt->tcfi_t->data;
- 	par.family   = NFPROTO_IPV4;
  	ret = par.target->target(skb, &par);
  
  	switch (ret) {
diff --cc net/sched/em_ipset.c
index df0328ba6a48,c1b23e3060b8..000000000000
--- a/net/sched/em_ipset.c
+++ b/net/sched/em_ipset.c
@@@ -95,8 -96,9 +96,14 @@@ static int em_ipset_match(struct sk_buf
  	if (skb->skb_iif)
  		indev = dev_get_by_index_rcu(em->net, skb->skb_iif);
  
++<<<<<<< HEAD
 +	acpar.in      = indev ? indev : dev;
 +	acpar.out     = dev;
++=======
+ 	state.in      = indev ? indev : dev;
+ 	state.out     = dev;
+ 	acpar.state   = &state;
++>>>>>>> 613dbd95723a (netfilter: x_tables: move hook state into xt_action_param structure)
  
  	ret = ip_set_test(set->index, skb, &acpar, &opt);
  
* Unmerged path include/linux/netfilter/x_tables.h
* Unmerged path include/net/netfilter/nf_tables.h
diff --git a/net/bridge/netfilter/ebt_arpreply.c b/net/bridge/netfilter/ebt_arpreply.c
index 070cf134a22f..5929309beaa1 100644
--- a/net/bridge/netfilter/ebt_arpreply.c
+++ b/net/bridge/netfilter/ebt_arpreply.c
@@ -51,7 +51,8 @@ ebt_arpreply_tg(struct sk_buff *skb, const struct xt_action_param *par)
 	if (diptr == NULL)
 		return EBT_DROP;
 
-	arp_send(ARPOP_REPLY, ETH_P_ARP, *siptr, (struct net_device *)par->in,
+	arp_send(ARPOP_REPLY, ETH_P_ARP, *siptr,
+		 (struct net_device *)xt_in(par),
 		 *diptr, shp, info->mac, shp);
 
 	return info->target;
* Unmerged path net/bridge/netfilter/ebt_log.c
* Unmerged path net/bridge/netfilter/ebt_nflog.c
* Unmerged path net/bridge/netfilter/ebt_redirect.c
* Unmerged path net/bridge/netfilter/ebtables.c
* Unmerged path net/ipv4/netfilter/arp_tables.c
* Unmerged path net/ipv4/netfilter/ip_tables.c
diff --git a/net/ipv4/netfilter/ipt_MASQUERADE.c b/net/ipv4/netfilter/ipt_MASQUERADE.c
index da7f02a0b868..34cfb9b0bc0a 100644
--- a/net/ipv4/netfilter/ipt_MASQUERADE.c
+++ b/net/ipv4/netfilter/ipt_MASQUERADE.c
@@ -55,7 +55,8 @@ masquerade_tg(struct sk_buff *skb, const struct xt_action_param *par)
 	range.min_proto = mr->range[0].min;
 	range.max_proto = mr->range[0].max;
 
-	return nf_nat_masquerade_ipv4(skb, par->hooknum, &range, par->out);
+	return nf_nat_masquerade_ipv4(skb, xt_hooknum(par), &range,
+				      xt_out(par));
 }
 
 static struct xt_target masquerade_tg_reg __read_mostly = {
* Unmerged path net/ipv4/netfilter/ipt_REJECT.c
* Unmerged path net/ipv4/netfilter/ipt_SYNPROXY.c
* Unmerged path net/ipv4/netfilter/ipt_rpfilter.c
* Unmerged path net/ipv6/netfilter/ip6_tables.c
diff --git a/net/ipv6/netfilter/ip6t_MASQUERADE.c b/net/ipv6/netfilter/ip6t_MASQUERADE.c
index 7f9f45d829d2..2b1a15846f9a 100644
--- a/net/ipv6/netfilter/ip6t_MASQUERADE.c
+++ b/net/ipv6/netfilter/ip6t_MASQUERADE.c
@@ -24,7 +24,7 @@
 static unsigned int
 masquerade_tg6(struct sk_buff *skb, const struct xt_action_param *par)
 {
-	return nf_nat_masquerade_ipv6(skb, par->targinfo, par->out);
+	return nf_nat_masquerade_ipv6(skb, par->targinfo, xt_out(par));
 }
 
 static int masquerade_tg6_checkentry(const struct xt_tgchk_param *par)
* Unmerged path net/ipv6/netfilter/ip6t_REJECT.c
* Unmerged path net/ipv6/netfilter/ip6t_SYNPROXY.c
* Unmerged path net/ipv6/netfilter/ip6t_rpfilter.c
* Unmerged path net/netfilter/ipset/ip_set_core.c
diff --git a/net/netfilter/ipset/ip_set_hash_netiface.c b/net/netfilter/ipset/ip_set_hash_netiface.c
index e7f18f343213..f5164c1efce2 100644
--- a/net/netfilter/ipset/ip_set_hash_netiface.c
+++ b/net/netfilter/ipset/ip_set_hash_netiface.c
@@ -170,7 +170,7 @@ hash_netiface4_kadt(struct ip_set *set, const struct sk_buff *skb,
 	ip4addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip);
 	e.ip &= ip_set_netmask(e.cidr);
 
-#define IFACE(dir)	(par->dir ? par->dir->name : "")
+#define IFACE(dir)	(par->state->dir ? par->state->dir->name : "")
 #define SRCDIR		(opt->flags & IPSET_DIM_TWO_SRC)
 
 	if (opt->cmdflags & IPSET_FLAG_PHYSDEV) {
* Unmerged path net/netfilter/xt_AUDIT.c
* Unmerged path net/netfilter/xt_LOG.c
diff --git a/net/netfilter/xt_NETMAP.c b/net/netfilter/xt_NETMAP.c
index b253e07cb1c5..94d0b5411192 100644
--- a/net/netfilter/xt_NETMAP.c
+++ b/net/netfilter/xt_NETMAP.c
@@ -33,8 +33,8 @@ netmap_tg6(struct sk_buff *skb, const struct xt_action_param *par)
 		netmask.ip6[i] = ~(range->min_addr.ip6[i] ^
 				   range->max_addr.ip6[i]);
 
-	if (par->hooknum == NF_INET_PRE_ROUTING ||
-	    par->hooknum == NF_INET_LOCAL_OUT)
+	if (xt_hooknum(par) == NF_INET_PRE_ROUTING ||
+	    xt_hooknum(par) == NF_INET_LOCAL_OUT)
 		new_addr.in6 = ipv6_hdr(skb)->daddr;
 	else
 		new_addr.in6 = ipv6_hdr(skb)->saddr;
@@ -51,7 +51,7 @@ netmap_tg6(struct sk_buff *skb, const struct xt_action_param *par)
 	newrange.min_proto	= range->min_proto;
 	newrange.max_proto	= range->max_proto;
 
-	return nf_nat_setup_info(ct, &newrange, HOOK2MANIP(par->hooknum));
+	return nf_nat_setup_info(ct, &newrange, HOOK2MANIP(xt_hooknum(par)));
 }
 
 static int netmap_tg6_checkentry(const struct xt_tgchk_param *par)
@@ -72,16 +72,16 @@ netmap_tg4(struct sk_buff *skb, const struct xt_action_param *par)
 	const struct nf_nat_ipv4_multi_range_compat *mr = par->targinfo;
 	struct nf_nat_range newrange;
 
-	NF_CT_ASSERT(par->hooknum == NF_INET_PRE_ROUTING ||
-		     par->hooknum == NF_INET_POST_ROUTING ||
-		     par->hooknum == NF_INET_LOCAL_OUT ||
-		     par->hooknum == NF_INET_LOCAL_IN);
+	NF_CT_ASSERT(xt_hooknum(par) == NF_INET_PRE_ROUTING ||
+		     xt_hooknum(par) == NF_INET_POST_ROUTING ||
+		     xt_hooknum(par) == NF_INET_LOCAL_OUT ||
+		     xt_hooknum(par) == NF_INET_LOCAL_IN);
 	ct = nf_ct_get(skb, &ctinfo);
 
 	netmask = ~(mr->range[0].min_ip ^ mr->range[0].max_ip);
 
-	if (par->hooknum == NF_INET_PRE_ROUTING ||
-	    par->hooknum == NF_INET_LOCAL_OUT)
+	if (xt_hooknum(par) == NF_INET_PRE_ROUTING ||
+	    xt_hooknum(par) == NF_INET_LOCAL_OUT)
 		new_ip = ip_hdr(skb)->daddr & ~netmask;
 	else
 		new_ip = ip_hdr(skb)->saddr & ~netmask;
@@ -96,7 +96,7 @@ netmap_tg4(struct sk_buff *skb, const struct xt_action_param *par)
 	newrange.max_proto   = mr->range[0].max;
 
 	/* Hand modified range to generic setup. */
-	return nf_nat_setup_info(ct, &newrange, HOOK2MANIP(par->hooknum));
+	return nf_nat_setup_info(ct, &newrange, HOOK2MANIP(xt_hooknum(par)));
 }
 
 static int netmap_tg4_check(const struct xt_tgchk_param *par)
* Unmerged path net/netfilter/xt_NFLOG.c
diff --git a/net/netfilter/xt_NFQUEUE.c b/net/netfilter/xt_NFQUEUE.c
index 8f1779ff7e30..a360b99a958a 100644
--- a/net/netfilter/xt_NFQUEUE.c
+++ b/net/netfilter/xt_NFQUEUE.c
@@ -43,7 +43,7 @@ nfqueue_tg_v1(struct sk_buff *skb, const struct xt_action_param *par)
 
 	if (info->queues_total > 1) {
 		queue = nfqueue_hash(skb, queue, info->queues_total,
-				     par->family, jhash_initval);
+				     xt_family(par), jhash_initval);
 	}
 	return NF_QUEUE_NR(queue);
 }
@@ -98,7 +98,7 @@ nfqueue_tg_v3(struct sk_buff *skb, const struct xt_action_param *par)
 			queue = info->queuenum + cpu % info->queues_total;
 		} else {
 			queue = nfqueue_hash(skb, queue, info->queues_total,
-					     par->family, jhash_initval);
+					     xt_family(par), jhash_initval);
 		}
 	}
 
diff --git a/net/netfilter/xt_REDIRECT.c b/net/netfilter/xt_REDIRECT.c
index 03f0b370e178..651dce65a30b 100644
--- a/net/netfilter/xt_REDIRECT.c
+++ b/net/netfilter/xt_REDIRECT.c
@@ -31,7 +31,7 @@
 static unsigned int
 redirect_tg6(struct sk_buff *skb, const struct xt_action_param *par)
 {
-	return nf_nat_redirect_ipv6(skb, par->targinfo, par->hooknum);
+	return nf_nat_redirect_ipv6(skb, par->targinfo, xt_hooknum(par));
 }
 
 static int redirect_tg6_checkentry(const struct xt_tgchk_param *par)
@@ -62,7 +62,7 @@ static int redirect_tg4_check(const struct xt_tgchk_param *par)
 static unsigned int
 redirect_tg4(struct sk_buff *skb, const struct xt_action_param *par)
 {
-	return nf_nat_redirect_ipv4(skb, par->targinfo, par->hooknum);
+	return nf_nat_redirect_ipv4(skb, par->targinfo, xt_hooknum(par));
 }
 
 static struct xt_target redirect_tg_reg[] __read_mostly = {
* Unmerged path net/netfilter/xt_TCPMSS.c
* Unmerged path net/netfilter/xt_TEE.c
* Unmerged path net/netfilter/xt_TPROXY.c
* Unmerged path net/netfilter/xt_addrtype.c
diff --git a/net/netfilter/xt_cluster.c b/net/netfilter/xt_cluster.c
index 96fa26b20b67..9a9884a39c0e 100644
--- a/net/netfilter/xt_cluster.c
+++ b/net/netfilter/xt_cluster.c
@@ -112,7 +112,7 @@ xt_cluster_mt(const struct sk_buff *skb, struct xt_action_param *par)
 	 * know, matches should not alter packets, but we are doing this here
 	 * because we would need to add a PKTTYPE target for this sole purpose.
 	 */
-	if (!xt_cluster_is_multicast_addr(skb, par->family) &&
+	if (!xt_cluster_is_multicast_addr(skb, xt_family(par)) &&
 	    skb->pkt_type == PACKET_MULTICAST) {
 	    	pskb->pkt_type = PACKET_HOST;
 	}
* Unmerged path net/netfilter/xt_connlimit.c
diff --git a/net/netfilter/xt_conntrack.c b/net/netfilter/xt_conntrack.c
index 4604fa4176ee..172342c0c3fc 100644
--- a/net/netfilter/xt_conntrack.c
+++ b/net/netfilter/xt_conntrack.c
@@ -199,22 +199,22 @@ conntrack_mt(const struct sk_buff *skb, struct xt_action_param *par,
 		return false;
 
 	if (info->match_flags & XT_CONNTRACK_ORIGSRC)
-		if (conntrack_mt_origsrc(ct, info, par->family) ^
+		if (conntrack_mt_origsrc(ct, info, xt_family(par)) ^
 		    !(info->invert_flags & XT_CONNTRACK_ORIGSRC))
 			return false;
 
 	if (info->match_flags & XT_CONNTRACK_ORIGDST)
-		if (conntrack_mt_origdst(ct, info, par->family) ^
+		if (conntrack_mt_origdst(ct, info, xt_family(par)) ^
 		    !(info->invert_flags & XT_CONNTRACK_ORIGDST))
 			return false;
 
 	if (info->match_flags & XT_CONNTRACK_REPLSRC)
-		if (conntrack_mt_replsrc(ct, info, par->family) ^
+		if (conntrack_mt_replsrc(ct, info, xt_family(par)) ^
 		    !(info->invert_flags & XT_CONNTRACK_REPLSRC))
 			return false;
 
 	if (info->match_flags & XT_CONNTRACK_REPLDST)
-		if (conntrack_mt_repldst(ct, info, par->family) ^
+		if (conntrack_mt_repldst(ct, info, xt_family(par)) ^
 		    !(info->invert_flags & XT_CONNTRACK_REPLDST))
 			return false;
 
diff --git a/net/netfilter/xt_devgroup.c b/net/netfilter/xt_devgroup.c
index d9202cdd25c9..96ebe1cdefec 100644
--- a/net/netfilter/xt_devgroup.c
+++ b/net/netfilter/xt_devgroup.c
@@ -24,12 +24,12 @@ static bool devgroup_mt(const struct sk_buff *skb, struct xt_action_param *par)
 	const struct xt_devgroup_info *info = par->matchinfo;
 
 	if (info->flags & XT_DEVGROUP_MATCH_SRC &&
-	    (((info->src_group ^ par->in->group) & info->src_mask ? 1 : 0) ^
+	    (((info->src_group ^ xt_in(par)->group) & info->src_mask ? 1 : 0) ^
 	     ((info->flags & XT_DEVGROUP_INVERT_SRC) ? 1 : 0)))
 		return false;
 
 	if (info->flags & XT_DEVGROUP_MATCH_DST &&
-	    (((info->dst_group ^ par->out->group) & info->dst_mask ? 1 : 0) ^
+	    (((info->dst_group ^ xt_out(par)->group) & info->dst_mask ? 1 : 0) ^
 	     ((info->flags & XT_DEVGROUP_INVERT_DST) ? 1 : 0)))
 		return false;
 
diff --git a/net/netfilter/xt_dscp.c b/net/netfilter/xt_dscp.c
index 64670fc5d0e1..236ac8008909 100644
--- a/net/netfilter/xt_dscp.c
+++ b/net/netfilter/xt_dscp.c
@@ -58,7 +58,7 @@ static bool tos_mt(const struct sk_buff *skb, struct xt_action_param *par)
 {
 	const struct xt_tos_match_info *info = par->matchinfo;
 
-	if (par->family == NFPROTO_IPV4)
+	if (xt_family(par) == NFPROTO_IPV4)
 		return ((ip_hdr(skb)->tos & info->tos_mask) ==
 		       info->tos_value) ^ !!info->invert;
 	else
* Unmerged path net/netfilter/xt_ipvs.c
* Unmerged path net/netfilter/xt_nfacct.c
* Unmerged path net/netfilter/xt_osf.c
* Unmerged path net/netfilter/xt_owner.c
diff --git a/net/netfilter/xt_pkttype.c b/net/netfilter/xt_pkttype.c
index 5b645cb598fc..57efb703ff18 100644
--- a/net/netfilter/xt_pkttype.c
+++ b/net/netfilter/xt_pkttype.c
@@ -30,10 +30,10 @@ pkttype_mt(const struct sk_buff *skb, struct xt_action_param *par)
 
 	if (skb->pkt_type != PACKET_LOOPBACK)
 		type = skb->pkt_type;
-	else if (par->family == NFPROTO_IPV4 &&
+	else if (xt_family(par) == NFPROTO_IPV4 &&
 	    ipv4_is_multicast(ip_hdr(skb)->daddr))
 		type = PACKET_MULTICAST;
-	else if (par->family == NFPROTO_IPV6 &&
+	else if (xt_family(par) == NFPROTO_IPV6 &&
 	    ipv6_hdr(skb)->daddr.s6_addr[0] == 0xFF)
 		type = PACKET_MULTICAST;
 	else
diff --git a/net/netfilter/xt_policy.c b/net/netfilter/xt_policy.c
index f23e97bb42d7..2b4ab189bba7 100644
--- a/net/netfilter/xt_policy.c
+++ b/net/netfilter/xt_policy.c
@@ -116,9 +116,9 @@ policy_mt(const struct sk_buff *skb, struct xt_action_param *par)
 	int ret;
 
 	if (info->flags & XT_POLICY_MATCH_IN)
-		ret = match_policy_in(skb, info, par->family);
+		ret = match_policy_in(skb, info, xt_family(par));
 	else
-		ret = match_policy_out(skb, info, par->family);
+		ret = match_policy_out(skb, info, xt_family(par));
 
 	if (ret < 0)
 		ret = info->flags & XT_POLICY_MATCH_NONE ? true : false;
* Unmerged path net/netfilter/xt_recent.c
* Unmerged path net/netfilter/xt_set.c
* Unmerged path net/netfilter/xt_socket.c
* Unmerged path net/sched/act_ipt.c
* Unmerged path net/sched/em_ipset.c
