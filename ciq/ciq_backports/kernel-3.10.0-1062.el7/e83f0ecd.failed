IB/uverbs: Do not pass struct ib_device to the ioctl methods

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Jason Gunthorpe <jgg@mellanox.com>
commit e83f0ecdc40f2c3d63ff0e7f17462a29d12684a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e83f0ecd.failed

This does the same as the patch before, except for ioctl. The rules are
the same, but for the ioctl methods the core code handles setting up the
uobject.

- Retrieve the ib_dev from the uobject->context->device. This is
  safe under ioctl as the core has already done rdma_alloc_begin_uobject
  and so CREATE calls are entirely protected by the rwsem.
- Retrieve the ib_dev from uobject->object
- Call ib_uverbs_get_ucontext()

	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit e83f0ecdc40f2c3d63ff0e7f17462a29d12684a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/uverbs_ioctl.c
#	drivers/infiniband/core/uverbs_std_types.c
#	drivers/infiniband/core/uverbs_std_types_counters.c
#	drivers/infiniband/core/uverbs_std_types_cq.c
#	drivers/infiniband/core/uverbs_std_types_dm.c
#	drivers/infiniband/core/uverbs_std_types_flow_action.c
#	drivers/infiniband/core/uverbs_std_types_mr.c
#	drivers/infiniband/hw/mlx5/devx.c
#	drivers/infiniband/hw/mlx5/flow.c
#	include/rdma/ib_verbs.h
diff --cc drivers/infiniband/core/uverbs_ioctl.c
index ec7b453e622b,f0655a84f9d9..000000000000
--- a/drivers/infiniband/core/uverbs_ioctl.c
+++ b/drivers/infiniband/core/uverbs_ioctl.c
@@@ -312,7 -344,23 +312,27 @@@ static int uverbs_handle_method(struct 
  	if (ret)
  		goto cleanup;
  
++<<<<<<< HEAD
 +	ret = method_spec->handler(ibdev, ufile, attr_bundle);
++=======
+ 	/*
+ 	 * We destroy the HW object before invoking the handler, handlers do
+ 	 * not get to manipulate the HW objects.
+ 	 */
+ 	if (destroy_attr) {
+ 		ret = uobj_destroy(destroy_attr->uobject);
+ 		if (ret)
+ 			goto cleanup;
+ 	}
+ 
+ 	ret = method_spec->handler(ufile, attr_bundle);
+ 
+ 	if (destroy_attr) {
+ 		uobj_put_destroy(destroy_attr->uobject);
+ 		destroy_attr->uobject = NULL;
+ 	}
+ 
++>>>>>>> e83f0ecdc40f (IB/uverbs: Do not pass struct ib_device to the ioctl methods)
  cleanup:
  	finalize_ret = uverbs_finalize_attrs(attr_bundle,
  					     method_spec->attr_buckets,
diff --cc drivers/infiniband/core/uverbs_std_types.c
index bd9387aa9ae7,3aa7c7deac74..000000000000
--- a/drivers/infiniband/core/uverbs_std_types.c
+++ b/drivers/infiniband/core/uverbs_std_types.c
@@@ -204,17 -210,12 +204,26 @@@ static int uverbs_hot_unplug_completion
  	return 0;
  };
  
++<<<<<<< HEAD
 +/*
 + * This spec is used in order to pass information to the hardware driver in a
 + * legacy way. Every verb that could get driver specific data should get this
 + * spec.
 + */
 +const struct uverbs_attr_def uverbs_uhw_compat_in =
 +	UVERBS_ATTR_PTR_IN_SZ(UVERBS_ATTR_UHW_IN, UVERBS_ATTR_MIN_SIZE(0),
 +			      UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO));
 +const struct uverbs_attr_def uverbs_uhw_compat_out =
 +	UVERBS_ATTR_PTR_OUT_SZ(UVERBS_ATTR_UHW_OUT, UVERBS_ATTR_MIN_SIZE(0),
 +			       UA_FLAGS(UVERBS_ATTR_SPEC_F_MIN_SZ_OR_ZERO));
++=======
+ int uverbs_destroy_def_handler(struct ib_uverbs_file *file,
+ 			       struct uverbs_attr_bundle *attrs)
+ {
+ 	return 0;
+ }
+ EXPORT_SYMBOL(uverbs_destroy_def_handler);
++>>>>>>> e83f0ecdc40f (IB/uverbs: Do not pass struct ib_device to the ioctl methods)
  
  void create_udata(struct uverbs_attr_bundle *ctx, struct ib_udata *udata)
  {
diff --cc drivers/infiniband/core/uverbs_std_types_cq.c
index b0dbae9dd0d7,5b5f2052cd52..000000000000
--- a/drivers/infiniband/core/uverbs_std_types_cq.c
+++ b/drivers/infiniband/core/uverbs_std_types_cq.c
@@@ -53,12 -57,13 +53,18 @@@ static int uverbs_free_cq(struct ib_uob
  	return ret;
  }
  
- static int UVERBS_HANDLER(UVERBS_METHOD_CQ_CREATE)(struct ib_device *ib_dev,
- 						   struct ib_uverbs_file *file,
- 						   struct uverbs_attr_bundle *attrs)
+ static int UVERBS_HANDLER(UVERBS_METHOD_CQ_CREATE)(
+ 	struct ib_uverbs_file *file, struct uverbs_attr_bundle *attrs)
  {
++<<<<<<< HEAD
 +	struct ib_ucontext *ucontext = file->ucontext;
 +	struct ib_ucq_object           *obj;
++=======
+ 	struct ib_ucq_object *obj = container_of(
+ 		uverbs_attr_get_uobject(attrs, UVERBS_ATTR_CREATE_CQ_HANDLE),
+ 		typeof(*obj), uobject);
+ 	struct ib_device *ib_dev = obj->uobject.context->device;
++>>>>>>> e83f0ecdc40f (IB/uverbs: Do not pass struct ib_device to the ioctl methods)
  	struct ib_udata uhw;
  	int ret;
  	u64 user_handle;
@@@ -102,10 -106,6 +108,13 @@@
  		goto err_event_file;
  	}
  
++<<<<<<< HEAD
 +	obj = container_of(uverbs_attr_get(attrs,
 +					   UVERBS_ATTR_CREATE_CQ_HANDLE)->obj_attr.uobject,
 +			   typeof(*obj), uobject);
 +	obj->uverbs_file	   = ucontext->ufile;
++=======
++>>>>>>> e83f0ecdc40f (IB/uverbs: Do not pass struct ib_device to the ioctl methods)
  	obj->comp_events_reported  = 0;
  	obj->async_events_reported = 0;
  	INIT_LIST_HEAD(&obj->comp_list);
@@@ -146,46 -146,43 +155,45 @@@ err_event_file
  	return ret;
  };
  
 -DECLARE_UVERBS_NAMED_METHOD(
 -	UVERBS_METHOD_CQ_CREATE,
 -	UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE,
 -			UVERBS_OBJECT_CQ,
 -			UVERBS_ACCESS_NEW,
 -			UA_MANDATORY),
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
 -			   UVERBS_ATTR_TYPE(u32),
 -			   UA_MANDATORY),
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
 -			   UVERBS_ATTR_TYPE(u64),
 -			   UA_MANDATORY),
 -	UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
 -		       UVERBS_OBJECT_COMP_CHANNEL,
 -		       UVERBS_ACCESS_READ,
 -		       UA_OPTIONAL),
 -	UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR,
 -			   UVERBS_ATTR_TYPE(u32),
 -			   UA_MANDATORY),
 -	UVERBS_ATTR_FLAGS_IN(UVERBS_ATTR_CREATE_CQ_FLAGS,
 -			     enum ib_uverbs_ex_create_cq_flags),
 -	UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE,
 +static DECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_CQ_CREATE,
 +	&UVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_CQ_HANDLE, UVERBS_OBJECT_CQ,
 +			 UVERBS_ACCESS_NEW,
 +			 UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_CQE,
  			    UVERBS_ATTR_TYPE(u32),
 -			    UA_MANDATORY),
 -	UVERBS_ATTR_UHW());
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_USER_HANDLE,
 +			    UVERBS_ATTR_TYPE(u64),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_FD(UVERBS_ATTR_CREATE_CQ_COMP_CHANNEL,
 +			UVERBS_OBJECT_COMP_CHANNEL,
 +			UVERBS_ACCESS_READ),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_COMP_VECTOR, UVERBS_ATTR_TYPE(u32),
 +			    UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CREATE_CQ_FLAGS, UVERBS_ATTR_TYPE(u32)),
 +	&UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CREATE_CQ_RESP_CQE, UVERBS_ATTR_TYPE(u32),
 +			     UA_FLAGS(UVERBS_ATTR_SPEC_F_MANDATORY)),
 +	&uverbs_uhw_compat_in, &uverbs_uhw_compat_out);
  
- static int UVERBS_HANDLER(UVERBS_METHOD_CQ_DESTROY)(struct ib_device *ib_dev,
- 						    struct ib_uverbs_file *file,
- 						    struct uverbs_attr_bundle *attrs)
+ static int UVERBS_HANDLER(UVERBS_METHOD_CQ_DESTROY)(
+ 	struct ib_uverbs_file *file, struct uverbs_attr_bundle *attrs)
  {
 +	struct ib_uverbs_destroy_cq_resp resp;
  	struct ib_uobject *uobj =
 -		uverbs_attr_get_uobject(attrs, UVERBS_ATTR_DESTROY_CQ_HANDLE);
 -	struct ib_ucq_object *obj =
 -		container_of(uobj, struct ib_ucq_object, uobject);
 -	struct ib_uverbs_destroy_cq_resp resp = {
 -		.comp_events_reported = obj->comp_events_reported,
 -		.async_events_reported = obj->async_events_reported
 -	};
 +		uverbs_attr_get(attrs, UVERBS_ATTR_DESTROY_CQ_HANDLE)->obj_attr.uobject;
 +	struct ib_ucq_object *obj = container_of(uobj, struct ib_ucq_object,
 +						 uobject);
 +	int ret;
 +
 +	if (!(ib_dev->uverbs_cmd_mask & 1ULL << IB_USER_VERBS_CMD_DESTROY_CQ))
 +		return -EOPNOTSUPP;
 +
 +	ret = rdma_explicit_destroy(uobj);
 +	if (ret)
 +		return ret;
 +
 +	resp.comp_events_reported  = obj->comp_events_reported;
 +	resp.async_events_reported = obj->async_events_reported;
  
  	return uverbs_copy_to(attrs, UVERBS_ATTR_DESTROY_CQ_RESP, &resp,
  			      sizeof(resp));
diff --cc include/rdma/ib_verbs.h
index f069d7abc349,dea770e5b9ae..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -4058,4 -4170,6 +4058,9 @@@ void rdma_roce_rescan_device(struct ib_
  
  struct ib_ucontext *ib_uverbs_get_ucontext(struct ib_uverbs_file *ufile);
  
++<<<<<<< HEAD
++=======
+ int uverbs_destroy_def_handler(struct ib_uverbs_file *file,
+ 			       struct uverbs_attr_bundle *attrs);
++>>>>>>> e83f0ecdc40f (IB/uverbs: Do not pass struct ib_device to the ioctl methods)
  #endif /* IB_VERBS_H */
* Unmerged path drivers/infiniband/core/uverbs_std_types_counters.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_dm.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_flow_action.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
* Unmerged path drivers/infiniband/core/uverbs_ioctl.c
* Unmerged path drivers/infiniband/core/uverbs_std_types.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_counters.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_cq.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_dm.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_flow_action.c
* Unmerged path drivers/infiniband/core/uverbs_std_types_mr.c
* Unmerged path drivers/infiniband/hw/mlx5/devx.c
* Unmerged path drivers/infiniband/hw/mlx5/flow.c
* Unmerged path include/rdma/ib_verbs.h
diff --git a/include/rdma/uverbs_ioctl.h b/include/rdma/uverbs_ioctl.h
index 2cc45699a237..f86841d7345b 100644
--- a/include/rdma/uverbs_ioctl.h
+++ b/include/rdma/uverbs_ioctl.h
@@ -133,7 +133,7 @@ struct uverbs_method_spec {
 	u32						flags;
 	size_t						num_buckets;
 	size_t						num_child_attrs;
-	int (*handler)(struct ib_device *ib_dev, struct ib_uverbs_file *ufile,
+	int (*handler)(struct ib_uverbs_file *ufile,
 		       struct uverbs_attr_bundle *ctx);
 	struct uverbs_attr_spec_hash		*attr_buckets[0];
 };
@@ -176,7 +176,7 @@ struct uverbs_method_def {
 	u32				     flags;
 	size_t				     num_attrs;
 	const struct uverbs_attr_def * const (*attrs)[];
-	int (*handler)(struct ib_device *ib_dev, struct ib_uverbs_file *ufile,
+	int (*handler)(struct ib_uverbs_file *ufile,
 		       struct uverbs_attr_bundle *ctx);
 };
 
