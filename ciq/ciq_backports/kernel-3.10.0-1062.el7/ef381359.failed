net/mlx5e: Replace egdev with indirect block notifications

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Replace egdev with indirect block notifications (Alaa Hleihel) [1642362 1642498]
Rebuild_FUZZ: 96.43%
commit-author Oz Shlomo <ozsh@mellanox.com>
commit ef381359e3a81422cee85ddee1f7dc3ac90f3c38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ef381359.failed

Use TC indirect block notifications to offload filters that
are configured on higher level device interfaces (e.g. tunnel
devices). This mechanism replaces the current egdev implementation.

	Signed-off-by: Oz Shlomo <ozsh@mellanox.com>
	Reviewed-by: Eli Britstein <elibr@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit ef381359e3a81422cee85ddee1f7dc3ac90f3c38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 1af2953c38f5,5cac4de435c9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@@ -929,22 -1040,6 +949,25 @@@ mlx5e_rep_setup_tc_cls_flower(struct ml
  	}
  }
  
++<<<<<<< HEAD
 +static int mlx5e_rep_setup_tc_cb_egdev(enum tc_setup_type type, void *type_data,
 +				       void *cb_priv)
 +{
 +	struct mlx5e_priv *priv = cb_priv;
 +
 +	if (!tc_cls_can_offload_and_chain0(priv->netdev, type_data))
 +		return -EOPNOTSUPP;
 +
 +	switch (type) {
 +	case TC_SETUP_CLSFLOWER:
 +		return mlx5e_rep_setup_tc_cls_flower(priv, type_data, MLX5E_TC_EGRESS);
 +	default:
 +		return -EOPNOTSUPP;
 +	}
 +}
 +
++=======
++>>>>>>> ef381359e3a8 (net/mlx5e: Replace egdev with indirect block notifications)
  static int mlx5e_rep_setup_tc_cb(enum tc_setup_type type, void *type_data,
  				 void *cb_priv)
  {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index fbb4f1b36627..87d0b652c870 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -2627,6 +2627,13 @@ static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
 			struct mlx5e_priv *out_priv;
 
 			out_dev = tcf_mirred_dev(a);
+			if (!out_dev) {
+				/* out_dev is NULL when filters with
+				 * non-existing mirred device are replayed to
+				 * the driver.
+				 */
+				return -EINVAL;
+			}
 
 			if (switchdev_port_same_parent_id(priv->netdev,
 							  out_dev)) {
@@ -2644,6 +2651,13 @@ static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,
 					MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 					MLX5_FLOW_CONTEXT_ACTION_COUNT;
 				/* attr->out_rep is resolved when we handle encap */
+			} else if (parse_attr->filter_dev != priv->netdev) {
+				/* All mlx5 devices are called to configure
+				 * high level device filters. Therefore, the
+				 * *attempt* to  install a filter on invalid
+				 * eswitch should not trigger an explicit error
+				 */
+				return -EINVAL;
 			} else {
 				pr_err("devices %s %s not on same switch HW, can't offload forwarding\n",
 				       priv->netdev->name, out_dev->name);
