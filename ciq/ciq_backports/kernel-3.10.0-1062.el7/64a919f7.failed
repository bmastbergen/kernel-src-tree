KVM: nVMX: move host EFER consistency checks to VMFail path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 64a919f7b5d0593227d0ea7976949c1248ec36ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/64a919f7.failed

Invalid host state related to loading EFER on VMExit causes a
VMFail(VMXERR_ENTRY_INVALID_HOST_STATE_FIELD), not a VMExit.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 64a919f7b5d0593227d0ea7976949c1248ec36ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 5501a1957de2,a914e7ca044c..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -10670,6 -12474,77 +10671,80 @@@ static int check_vmentry_prereqs(struc
  	    !nested_cr3_valid(vcpu, vmcs12->host_cr3))
  		return VMXERR_ENTRY_INVALID_HOST_STATE_FIELD;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * If the load IA32_EFER VM-exit control is 1, bits reserved in the
+ 	 * IA32_EFER MSR must be 0 in the field for that register. In addition,
+ 	 * the values of the LMA and LME bits in the field must each be that of
+ 	 * the host address-space size VM-exit control.
+ 	 */
+ 	if (vmcs12->vm_exit_controls & VM_EXIT_LOAD_IA32_EFER) {
+ 		ia32e = (vmcs12->vm_exit_controls &
+ 			 VM_EXIT_HOST_ADDR_SPACE_SIZE) != 0;
+ 		if (!kvm_valid_efer(vcpu, vmcs12->host_ia32_efer) ||
+ 		    ia32e != !!(vmcs12->host_ia32_efer & EFER_LMA) ||
+ 		    ia32e != !!(vmcs12->host_ia32_efer & EFER_LME))
+ 			return VMXERR_ENTRY_INVALID_HOST_STATE_FIELD;
+ 	}
+ 
+ 	/*
+ 	 * From the Intel SDM, volume 3:
+ 	 * Fields relevant to VM-entry event injection must be set properly.
+ 	 * These fields are the VM-entry interruption-information field, the
+ 	 * VM-entry exception error code, and the VM-entry instruction length.
+ 	 */
+ 	if (vmcs12->vm_entry_intr_info_field & INTR_INFO_VALID_MASK) {
+ 		u32 intr_info = vmcs12->vm_entry_intr_info_field;
+ 		u8 vector = intr_info & INTR_INFO_VECTOR_MASK;
+ 		u32 intr_type = intr_info & INTR_INFO_INTR_TYPE_MASK;
+ 		bool has_error_code = intr_info & INTR_INFO_DELIVER_CODE_MASK;
+ 		bool should_have_error_code;
+ 		bool urg = nested_cpu_has2(vmcs12,
+ 					   SECONDARY_EXEC_UNRESTRICTED_GUEST);
+ 		bool prot_mode = !urg || vmcs12->guest_cr0 & X86_CR0_PE;
+ 
+ 		/* VM-entry interruption-info field: interruption type */
+ 		if (intr_type == INTR_TYPE_RESERVED ||
+ 		    (intr_type == INTR_TYPE_OTHER_EVENT &&
+ 		     !nested_cpu_supports_monitor_trap_flag(vcpu)))
+ 			return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
+ 
+ 		/* VM-entry interruption-info field: vector */
+ 		if ((intr_type == INTR_TYPE_NMI_INTR && vector != NMI_VECTOR) ||
+ 		    (intr_type == INTR_TYPE_HARD_EXCEPTION && vector > 31) ||
+ 		    (intr_type == INTR_TYPE_OTHER_EVENT && vector != 0))
+ 			return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
+ 
+ 		/* VM-entry interruption-info field: deliver error code */
+ 		should_have_error_code =
+ 			intr_type == INTR_TYPE_HARD_EXCEPTION && prot_mode &&
+ 			x86_exception_has_error_code(vector);
+ 		if (has_error_code != should_have_error_code)
+ 			return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
+ 
+ 		/* VM-entry exception error code */
+ 		if (has_error_code &&
+ 		    vmcs12->vm_entry_exception_error_code & GENMASK(31, 15))
+ 			return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
+ 
+ 		/* VM-entry interruption-info field: reserved bits */
+ 		if (intr_info & INTR_INFO_RESVD_BITS_MASK)
+ 			return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
+ 
+ 		/* VM-entry instruction length */
+ 		switch (intr_type) {
+ 		case INTR_TYPE_SOFT_EXCEPTION:
+ 		case INTR_TYPE_SOFT_INTR:
+ 		case INTR_TYPE_PRIV_SW_EXCEPTION:
+ 			if ((vmcs12->vm_entry_instruction_len > 15) ||
+ 			    (vmcs12->vm_entry_instruction_len == 0 &&
+ 			     !nested_cpu_has_zero_length_injection(vcpu)))
+ 				return VMXERR_ENTRY_INVALID_CONTROL_FIELD;
+ 		}
+ 	}
+ 
++>>>>>>> 64a919f7b5d0 (KVM: nVMX: move host EFER consistency checks to VMFail path)
  	return 0;
  }
  
* Unmerged path arch/x86/kvm/vmx.c
