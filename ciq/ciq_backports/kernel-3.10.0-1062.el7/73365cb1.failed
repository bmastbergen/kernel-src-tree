ALSA: pcm: Unify snd_pcm_group initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 73365cb10b280e539bad14e129e0d8434418bb79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/73365cb1.failed

There are multiple open codes that initialize the same object.
Create a common helper function instead.

Also, use kzalloc() to be safer at creating a group object, and move
the initialization out of the critical section.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 73365cb10b280e539bad14e129e0d8434418bb79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/core/pcm_native.c
diff --cc sound/core/pcm_native.c
index a561b8b6585b,9e4e289e5703..000000000000
--- a/sound/core/pcm_native.c
+++ b/sound/core/pcm_native.c
@@@ -90,14 -92,21 +90,21 @@@ static DECLARE_RWSEM(snd_pcm_link_rwsem
   * and this may lead to a deadlock when the code path takes read sem
   * twice (e.g. one in snd_pcm_action_nonatomic() and another in
   * snd_pcm_stream_lock()).  As a (suboptimal) workaround, let writer to
 - * sleep until all the readers are completed without blocking by writer.
 + * spin until it gets the lock.
   */
 -static inline void down_write_nonfifo(struct rw_semaphore *lock)
 +static inline void down_write_nonblock(struct rw_semaphore *lock)
  {
  	while (!down_write_trylock(lock))
 -		msleep(1);
 +		cond_resched();
  }
  
+ void snd_pcm_group_init(struct snd_pcm_group *group)
+ {
+ 	spin_lock_init(&group->lock);
+ 	mutex_init(&group->mutex);
+ 	INIT_LIST_HEAD(&group->substreams);
+ }
+ 
  #define PCM_LOCK_DEFAULT	0
  #define PCM_LOCK_IRQ	1
  #define PCM_LOCK_IRQSAVE	2
@@@ -1966,7 -1981,8 +1973,12 @@@ static int snd_pcm_link(struct snd_pcm_
  		res = -ENOMEM;
  		goto _nolock;
  	}
++<<<<<<< HEAD
 +	down_write_nonblock(&snd_pcm_link_rwsem);
++=======
+ 	snd_pcm_group_init(group);
+ 	down_write_nonfifo(&snd_pcm_link_rwsem);
++>>>>>>> 73365cb10b28 (ALSA: pcm: Unify snd_pcm_group initialization)
  	write_lock_irq(&snd_pcm_link_rwlock);
  	if (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN ||
  	    substream->runtime->status->state != substream1->runtime->status->state ||
diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index cdf41c403763..266bb16b6f66 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -753,9 +753,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 			}
 		}
 		substream->group = &substream->self_group;
-		spin_lock_init(&substream->self_group.lock);
-		mutex_init(&substream->self_group.mutex);
-		INIT_LIST_HEAD(&substream->self_group.substreams);
+		snd_pcm_group_init(&substream->self_group);
 		list_add_tail(&substream->link_list, &substream->self_group.substreams);
 		atomic_set(&substream->mmap_count, 0);
 		prev = substream;
diff --git a/sound/core/pcm_local.h b/sound/core/pcm_local.h
index c515612969a4..0b4b5dfaec18 100644
--- a/sound/core/pcm_local.h
+++ b/sound/core/pcm_local.h
@@ -66,5 +66,6 @@ static inline void snd_pcm_timer_done(struct snd_pcm_substream *substream) {}
 #endif
 
 void __snd_pcm_xrun(struct snd_pcm_substream *substream);
+void snd_pcm_group_init(struct snd_pcm_group *group);
 
 #endif	/* __SOUND_CORE_PCM_LOCAL_H */
* Unmerged path sound/core/pcm_native.c
