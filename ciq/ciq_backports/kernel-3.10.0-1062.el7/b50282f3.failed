ext4: check to make sure the rename(2)'s destination is not freed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit b50282f3241acee880514212d88b6049fb5039c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b50282f3.failed

If the destination of the rename(2) system call exists, the inode's
link count (i_nlinks) must be non-zero.  If it is, the inode can end
up on the orphan list prematurely, leading to all sorts of hilarity,
including a use-after-free.

https://bugzilla.kernel.org/show_bug.cgi?id=200931

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Reported-by: Wen Xu <wen.xu@gatech.edu>
	Cc: stable@vger.kernel.org
(cherry picked from commit b50282f3241acee880514212d88b6049fb5039c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/namei.c
diff --cc fs/ext4/namei.c
index 640ba031713a,377d516c475f..000000000000
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@@ -3247,8 -3478,23 +3247,28 @@@ static int ext4_rename(struct inode *ol
  	int credits;
  	u8 old_file_type;
  
++<<<<<<< HEAD
 +	dquot_initialize(old.dir);
 +	dquot_initialize(new.dir);
++=======
+ 	if (new.inode && new.inode->i_nlink == 0) {
+ 		EXT4_ERROR_INODE(new.inode,
+ 				 "target of rename is already freed");
+ 		return -EFSCORRUPTED;
+ 	}
+ 
+ 	if ((ext4_test_inode_flag(new_dir, EXT4_INODE_PROJINHERIT)) &&
+ 	    (!projid_eq(EXT4_I(new_dir)->i_projid,
+ 			EXT4_I(old_dentry->d_inode)->i_projid)))
+ 		return -EXDEV;
+ 
+ 	retval = dquot_initialize(old.dir);
+ 	if (retval)
+ 		return retval;
+ 	retval = dquot_initialize(new.dir);
+ 	if (retval)
+ 		return retval;
++>>>>>>> b50282f3241a (ext4: check to make sure the rename(2)'s destination is not freed)
  
  	/* Initialize quotas before so that eventual writes go
  	 * in separate transaction */
* Unmerged path fs/ext4/namei.c
