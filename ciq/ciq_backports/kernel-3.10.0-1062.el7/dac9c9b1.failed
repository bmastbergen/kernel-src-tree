xfs: pass struct xfs_bmbt_irec to xfs_bmbt_validate_extent

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Christoph Hellwig <hch@lst.de>
commit dac9c9b137950421a87c1d9ba29f3a6ee54d0e8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/dac9c9b1.failed

This removed an unaligned load per extent, as well as the manual poking
into the on-disk extent format.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit dac9c9b137950421a87c1d9ba29f3a6ee54d0e8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/libxfs/xfs_bmap.c
#	fs/xfs/libxfs/xfs_bmap_btree.h
#	fs/xfs/libxfs/xfs_inode_fork.c
diff --cc fs/xfs/libxfs/xfs_bmap.c
index 59769f7334d7,08df809e2315..000000000000
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@@ -1257,15 -1260,17 +1257,27 @@@ xfs_bmap_read_extents
  		 * Copy records into the extent records.
  		 */
  		frp = XFS_BMBT_REC_ADDR(mp, block, 1);
++<<<<<<< HEAD
 +		for (j = 0; j < num_recs; j++, i++, frp++) {
 +			xfs_bmbt_rec_host_t *trp = xfs_iext_get_ext(ifp, i);
 +			trp->l0 = be64_to_cpu(frp->l0);
 +			trp->l1 = be64_to_cpu(frp->l1);
 +			if (!xfs_bmbt_validate_extent(mp, whichfork, trp)) {
++=======
+ 		for (j = 0; j < num_recs; j++, frp++, i++) {
+ 			xfs_bmbt_disk_get_all(frp, &new);
+ 			if (!xfs_bmbt_validate_extent(mp, whichfork, &new)) {
++>>>>>>> dac9c9b13795 (xfs: pass struct xfs_bmbt_irec to xfs_bmbt_validate_extent)
  				XFS_ERROR_REPORT("xfs_bmap_read_extents(2)",
  						 XFS_ERRLEVEL_LOW, mp);
 -				error = -EFSCORRUPTED;
 -				goto out_brelse;
 +				goto error0;
  			}
++<<<<<<< HEAD
++=======
+ 			xfs_iext_insert(ip, &icur, &new, state);
+ 			trace_xfs_read_extent(ip, &icur, state, _THIS_IP_);
+ 			xfs_iext_next(ifp, &icur);
++>>>>>>> dac9c9b13795 (xfs: pass struct xfs_bmbt_irec to xfs_bmbt_validate_extent)
  		}
  		xfs_trans_brelse(tp, bp);
  		bno = nextbno;
diff --cc fs/xfs/libxfs/xfs_bmap_btree.h
index 64437f0f7a7e,135b8c56d23e..000000000000
--- a/fs/xfs/libxfs/xfs_bmap_btree.h
+++ b/fs/xfs/libxfs/xfs_bmap_btree.h
@@@ -137,9 -122,9 +137,15 @@@ extern struct xfs_btree_cur *xfs_bmbt_i
   * Check that the extent does not contain an invalid unwritten extent flag.
   */
  static inline bool xfs_bmbt_validate_extent(struct xfs_mount *mp, int whichfork,
++<<<<<<< HEAD
 +		struct xfs_bmbt_rec_host *ep)
 +{
 +	if (ep->l0 >> (64 - BMBT_EXNTFLAG_BITLEN) == 0)
++=======
+ 		struct xfs_bmbt_irec *irec)
+ {
+ 	if (irec->br_state == XFS_EXT_NORM)
++>>>>>>> dac9c9b13795 (xfs: pass struct xfs_bmbt_irec to xfs_bmbt_validate_extent)
  		return true;
  	if (whichfork == XFS_DATA_FORK &&
  	    xfs_sb_version_hasextflgbit(&mp->m_sb))
diff --cc fs/xfs/libxfs/xfs_inode_fork.c
index f83028029221,1c90ec41e9df..000000000000
--- a/fs/xfs/libxfs/xfs_inode_fork.c
+++ b/fs/xfs/libxfs/xfs_inode_fork.c
@@@ -245,27 -347,25 +245,39 @@@ xfs_iformat_extents
  	}
  
  	ifp->if_real_bytes = 0;
 -	ifp->if_bytes = 0;
 -	ifp->if_u1.if_root = NULL;
 -	ifp->if_height = 0;
 +	if (nex == 0)
 +		ifp->if_u1.if_extents = NULL;
 +	else if (nex <= XFS_INLINE_EXTS)
 +		ifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;
 +	else
 +		xfs_iext_add(ifp, 0, nex);
 +
 +	ifp->if_bytes = size;
  	if (size) {
  		dp = (xfs_bmbt_rec_t *) XFS_DFORK_PTR(dip, whichfork);
 -
 -		xfs_iext_first(ifp, &icur);
  		for (i = 0; i < nex; i++, dp++) {
++<<<<<<< HEAD
 +			xfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);
 +			ep->l0 = get_unaligned_be64(&dp->l0);
 +			ep->l1 = get_unaligned_be64(&dp->l1);
 +			if (!xfs_bmbt_validate_extent(mp, whichfork, ep)) {
++=======
+ 			xfs_bmbt_disk_get_all(dp, &new);
+ 			if (!xfs_bmbt_validate_extent(mp, whichfork, &new)) {
++>>>>>>> dac9c9b13795 (xfs: pass struct xfs_bmbt_irec to xfs_bmbt_validate_extent)
  				XFS_ERROR_REPORT("xfs_iformat_extents(2)",
  						 XFS_ERRLEVEL_LOW, mp);
  				return -EFSCORRUPTED;
  			}
++<<<<<<< HEAD
++=======
+ 
+ 			xfs_iext_insert(ip, &icur, &new, state);
+ 			trace_xfs_read_extent(ip, &icur, state, _THIS_IP_);
+ 			xfs_iext_next(ifp, &icur);
++>>>>>>> dac9c9b13795 (xfs: pass struct xfs_bmbt_irec to xfs_bmbt_validate_extent)
  		}
 +		XFS_BMAP_TRACE_EXLIST(ip, nex, whichfork);
  	}
  	ifp->if_flags |= XFS_IFEXTENTS;
  	return 0;
@@@ -654,53 -688,32 +666,65 @@@ xfs_iext_count(struct xfs_ifork *ifp
   */
  int
  xfs_iextents_copy(
 -	struct xfs_inode	*ip,
 -	struct xfs_bmbt_rec	*dp,
 +	xfs_inode_t		*ip,
 +	xfs_bmbt_rec_t		*dp,
  	int			whichfork)
  {
 -	int			state = xfs_bmap_fork_to_state(whichfork);
 -	struct xfs_ifork	*ifp = XFS_IFORK_PTR(ip, whichfork);
 -	struct xfs_iext_cursor	icur;
 -	struct xfs_bmbt_irec	rec;
 -	int			copied = 0;
 +	int			copied;
 +	int			i;
 +	xfs_ifork_t		*ifp;
 +	int			nrecs;
 +	xfs_fsblock_t		start_block;
  
 -	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL | XFS_ILOCK_SHARED));
 +	ifp = XFS_IFORK_PTR(ip, whichfork);
 +	ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));
  	ASSERT(ifp->if_bytes > 0);
  
++<<<<<<< HEAD
 +	nrecs = xfs_iext_count(ifp);
 +	XFS_BMAP_TRACE_EXLIST(ip, nrecs, whichfork);
 +	ASSERT(nrecs > 0);
++=======
+ 	for_each_xfs_iext(ifp, &icur, &rec) {
+ 		if (isnullstartblock(rec.br_startblock))
+ 			continue;
+ 		ASSERT(xfs_bmbt_validate_extent(ip->i_mount, whichfork, &rec));
+ 		xfs_bmbt_disk_set_all(dp, &rec);
+ 		trace_xfs_write_extent(ip, &icur, state, _RET_IP_);
+ 		copied += sizeof(struct xfs_bmbt_rec);
+ 		dp++;
+ 	}
++>>>>>>> dac9c9b13795 (xfs: pass struct xfs_bmbt_irec to xfs_bmbt_validate_extent)
 +
 +	/*
 +	 * There are some delayed allocation extents in the
 +	 * inode, so copy the extents one at a time and skip
 +	 * the delayed ones.  There must be at least one
 +	 * non-delayed extent.
 +	 */
 +	copied = 0;
 +	for (i = 0; i < nrecs; i++) {
 +		xfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, i);
 +
 +		ASSERT(xfs_bmbt_validate_extent(ip->i_mount, whichfork, ep));
 +
 +		start_block = xfs_bmbt_get_startblock(ep);
 +		if (isnullstartblock(start_block)) {
 +			/*
 +			 * It's a delayed allocation extent, so skip it.
 +			 */
 +			continue;
 +		}
 +
 +		/* Translate to on disk format */
 +		put_unaligned_be64(ep->l0, &dp->l0);
 +		put_unaligned_be64(ep->l1, &dp->l1);
 +		dp++;
 +		copied++;
 +	}
 +	ASSERT(copied != 0);
  
 -	ASSERT(copied > 0);
 -	ASSERT(copied <= ifp->if_bytes);
 -	return copied;
 +	return (copied * (uint)sizeof(xfs_bmbt_rec_t));
  }
  
  /*
* Unmerged path fs/xfs/libxfs/xfs_bmap.c
* Unmerged path fs/xfs/libxfs/xfs_bmap_btree.h
* Unmerged path fs/xfs/libxfs/xfs_inode_fork.c
