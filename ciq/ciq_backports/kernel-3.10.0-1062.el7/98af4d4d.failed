zram: register default groups with device_add_disk()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Hannes Reinecke <hare@suse.de>
commit 98af4d4df889dcea3bc0ce6b8a04759658ba8826
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/98af4d4d.failed

Register default sysfs groups during device_add_disk() to avoid a
race condition with udev during startup.

	Signed-off-by: Hannes Reinecke <hare@suse.com>
	Cc: Minchan Kim <minchan@kernel.org>
	Cc: Nitin Gupta <ngupta@vflare.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 98af4d4df889dcea3bc0ce6b8a04759658ba8826)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/zram/zram_drv.c
diff --cc drivers/block/zram/zram_drv.c
index 4987c3f4bb80,4879595200e1..000000000000
--- a/drivers/block/zram/zram_drv.c
+++ b/drivers/block/zram/zram_drv.c
@@@ -1179,24 -1717,15 +1184,23 @@@ static int zram_add(void
  	 * zeroed.
  	 */
  	if (ZRAM_LOGICAL_BLOCK_SIZE == PAGE_SIZE)
 -		blk_queue_max_write_zeroes_sectors(zram->disk->queue, UINT_MAX);
 +		zram->disk->queue->limits.discard_zeroes_data = 1;
 +	else
 +		zram->disk->queue->limits.discard_zeroes_data = 0;
 +	queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, zram->disk->queue);
  
++<<<<<<< HEAD
 +	add_disk(zram->disk);
++=======
+ 	zram->disk->queue->backing_dev_info->capabilities |=
+ 			(BDI_CAP_STABLE_WRITES | BDI_CAP_SYNCHRONOUS_IO);
+ 	device_add_disk(NULL, zram->disk, zram_disk_attr_groups);
++>>>>>>> 98af4d4df889 (zram: register default groups with device_add_disk())
  
- 	ret = sysfs_create_group(&disk_to_dev(zram->disk)->kobj,
- 				&zram_disk_attr_group);
- 	if (ret < 0) {
- 		pr_err("Error creating sysfs group for device %d\n",
- 				device_id);
- 		goto out_free_disk;
- 	}
  	strlcpy(zram->compressor, default_compressor, sizeof(zram->compressor));
 +	zram->meta = NULL;
 +	zram->max_comp_streams = 1;
  
 -	zram_debugfs_register(zram);
  	pr_info("Added device: %s\n", zram->disk->disk_name);
  	return device_id;
  
@@@ -1230,15 -1756,7 +1231,19 @@@ static int zram_remove(struct zram *zra
  	zram->claim = true;
  	mutex_unlock(&bdev->bd_mutex);
  
++<<<<<<< HEAD
 +	/*
 +	 * Remove sysfs first, so no one will perform a disksize
 +	 * store while we destroy the devices. This also helps during
 +	 * hot_remove -- zram_reset_device() is the last holder of
 +	 * ->init_lock, no later/concurrent disksize_store() or any
 +	 * other sysfs handlers are possible.
 +	 */
 +	sysfs_remove_group(&disk_to_dev(zram->disk)->kobj,
 +			&zram_disk_attr_group);
++=======
+ 	zram_debugfs_unregister(zram);
++>>>>>>> 98af4d4df889 (zram: register default groups with device_add_disk())
  
  	/* Make sure all the pending I/O are finished */
  	fsync_bdev(bdev);
* Unmerged path drivers/block/zram/zram_drv.c
