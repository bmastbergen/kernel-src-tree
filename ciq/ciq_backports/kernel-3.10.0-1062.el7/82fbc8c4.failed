ftrace: Add missing check for existing hwlat thread

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Erica Bugden <erica.bugden@linutronix.de>
commit 82fbc8c48adffd73297e7edbd7266a89d00cc52f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/82fbc8c4.failed

The hwlat tracer uses a kernel thread to measure latencies. The function
that creates this kernel thread, start_kthread(), can be called when the
tracer is initialized and when the tracer is explicitly enabled.
start_kthread() does not check if there is an existing hwlat kernel
thread and will create a new one each time it is called.

This causes the reference to the previous thread to be lost. Without the
thread reference, the old kernel thread becomes unstoppable and
continues to use CPU time even after the hwlat tracer has been disabled.
This problem can be observed when a system is booted with tracing
enabled and the hwlat tracer is configured like this:

	echo hwlat > current_tracer; echo 1 > tracing_on

Add the missing check for an existing kernel thread in start_kthread()
to prevent this problem. This function and the rest of the hwlat kernel
thread setup and teardown are already serialized because they are called
through the tracer core code with trace_type_lock held.

[
 Note, this only fixes the symptom. The real fix was not to call
 this function when tracing_on was already one. But this still makes
 the code more robust, so we'll add it.
]

Link: http://lkml.kernel.org/r/1533120354-22923-1-git-send-email-erica.bugden@linutronix.de

	Signed-off-by: Erica Bugden <erica.bugden@linutronix.de>
	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit 82fbc8c48adffd73297e7edbd7266a89d00cc52f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_hwlat.c
diff --cc kernel/trace/trace_hwlat.c
index 4b30d8bcf79c,2d9d36dd5fe7..000000000000
--- a/kernel/trace/trace_hwlat.c
+++ b/kernel/trace/trace_hwlat.c
@@@ -366,7 -350,19 +366,21 @@@ static int kthread_fn(void *data
   */
  static int start_kthread(struct trace_array *tr)
  {
 -	struct cpumask *current_mask = &save_cpumask;
  	struct task_struct *kthread;
++<<<<<<< HEAD
++=======
+ 	int next_cpu;
+ 
+ 	if (hwlat_kthread)
+ 		return 0;
+ 
+ 	/* Just pick the first CPU on first iteration */
+ 	current_mask = &save_cpumask;
+ 	get_online_cpus();
+ 	cpumask_and(current_mask, cpu_online_mask, tracing_buffer_mask);
+ 	put_online_cpus();
+ 	next_cpu = cpumask_first(current_mask);
++>>>>>>> 82fbc8c48adf (ftrace: Add missing check for existing hwlat thread)
  
  	kthread = kthread_create(kthread_fn, NULL, "hwlatd");
  	if (IS_ERR(kthread)) {
* Unmerged path kernel/trace/trace_hwlat.c
