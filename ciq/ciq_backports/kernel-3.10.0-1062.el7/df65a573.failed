net/mlx5e: Refactor eswitch flow attr for destination specific properties

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Refactor eswitch flow attr for destination specific properties (Alaa Hleihel) [1642383 1642498]
Rebuild_FUZZ: 97.18%
commit-author Eli Britstein <elibr@mellanox.com>
commit df65a573eab28059e5dd1d5c32ad270dcf9cbf24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/df65a573.failed

Currently the eswitch flow attr structure stores each destination
specific property in its own specific array.
Group them in an array of destination structures as a pre-step towards
adding additional destination specific field properties.

	Signed-off-by: Eli Britstein <elibr@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit df65a573eab28059e5dd1d5c32ad270dcf9cbf24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index fbb4f1b36627,b24b758f467d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -838,8 -939,8 +838,13 @@@ mlx5e_tc_add_fdb_flow(struct mlx5e_pri
  		}
  		out_priv = netdev_priv(encap_dev);
  		rpriv = out_priv->ppriv;
++<<<<<<< HEAD
 +		attr->out_rep = rpriv->rep;
 +		attr->out_mdev = out_priv->mdev;
++=======
+ 		attr->dests[attr->out_count].rep = rpriv->rep;
+ 		attr->dests[attr->out_count++].mdev = out_priv->mdev;
++>>>>>>> df65a573eab2 (net/mlx5e: Refactor eswitch flow attr for destination specific properties)
  	}
  
  	err = mlx5_eswitch_add_vlan_action(esw, attr);
@@@ -2622,29 -2431,66 +2627,51 @@@ static int parse_tc_fdb_actions(struct 
  			continue;
  		}
  
 -		if (is_tcf_csum(a)) {
 -			if (csum_offload_supported(priv, action,
 -						   tcf_csum_update_flags(a),
 -						   extack))
 -				continue;
 -
 -			return -EOPNOTSUPP;
 -		}
 -
 -		if (is_tcf_mirred_egress_redirect(a) || is_tcf_mirred_egress_mirror(a)) {
 -			struct mlx5e_priv *out_priv;
 +		if (is_tcf_mirred_egress_redirect(a)) {
  			struct net_device *out_dev;
 +			struct mlx5e_priv *out_priv;
  
  			out_dev = tcf_mirred_dev(a);
 -			if (!out_dev) {
 -				/* out_dev is NULL when filters with
 -				 * non-existing mirred device are replayed to
 -				 * the driver.
 -				 */
 -				return -EINVAL;
 -			}
 -
 -			if (attr->out_count >= MLX5_MAX_FLOW_FWD_VPORTS) {
 -				NL_SET_ERR_MSG_MOD(extack,
 -						   "can't support more output ports, can't offload forwarding");
 -				pr_err("can't support more than %d output ports, can't offload forwarding\n",
 -				       attr->out_count);
 -				return -EOPNOTSUPP;
 -			}
  
  			if (switchdev_port_same_parent_id(priv->netdev,
 -							  out_dev) ||
 -			    is_merged_eswitch_dev(priv, out_dev)) {
 -				action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 -					  MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +							  out_dev)) {
 +				attr->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +					MLX5_FLOW_CONTEXT_ACTION_COUNT;
  				out_priv = netdev_priv(out_dev);
  				rpriv = out_priv->ppriv;
++<<<<<<< HEAD
 +				attr->out_rep = rpriv->rep;
 +				attr->out_mdev = out_priv->mdev;
++=======
+ 				attr->dests[attr->out_count].rep = rpriv->rep;
+ 				attr->dests[attr->out_count].mdev = out_priv->mdev;
+ 				attr->out_count++;
++>>>>>>> df65a573eab2 (net/mlx5e: Refactor eswitch flow attr for destination specific properties)
  			} else if (encap) {
  				parse_attr->mirred_ifindex = out_dev->ifindex;
  				parse_attr->tun_info = *info;
  				attr->parse_attr = parse_attr;
++<<<<<<< HEAD
 +				attr->action |= MLX5_FLOW_CONTEXT_ACTION_ENCAP |
 +					MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
 +					MLX5_FLOW_CONTEXT_ACTION_COUNT;
 +				/* attr->out_rep is resolved when we handle encap */
++=======
+ 				action |= MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT |
+ 					  MLX5_FLOW_CONTEXT_ACTION_FWD_DEST |
+ 					  MLX5_FLOW_CONTEXT_ACTION_COUNT;
+ 				/* attr->dests[].rep is resolved when we
+ 				 * handle encap
+ 				 */
+ 			} else if (parse_attr->filter_dev != priv->netdev) {
+ 				/* All mlx5 devices are called to configure
+ 				 * high level device filters. Therefore, the
+ 				 * *attempt* to  install a filter on invalid
+ 				 * eswitch should not trigger an explicit error
+ 				 */
+ 				return -EINVAL;
++>>>>>>> df65a573eab2 (net/mlx5e: Refactor eswitch flow attr for destination specific properties)
  			} else {
 -				NL_SET_ERR_MSG_MOD(extack,
 -						   "devices are not on same switch HW, can't offload forwarding");
  				pr_err("devices %s %s not on same switch HW, can't offload forwarding\n",
  				       priv->netdev->name, out_dev->name);
  				return -EINVAL;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 21bc97b70ed9,5468975a1bdb..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -241,20 -278,33 +241,27 @@@ enum mlx5_flow_match_level 
  	MLX5_MATCH_L4	= MLX5_INLINE_MODE_TCP_UDP,
  };
  
 -/* current maximum for flow based vport multicasting */
 -#define MLX5_MAX_FLOW_FWD_VPORTS 2
 -
  struct mlx5_esw_flow_attr {
  	struct mlx5_eswitch_rep *in_rep;
++<<<<<<< HEAD
 +	struct mlx5_eswitch_rep *out_rep;
 +	struct mlx5_core_dev	*out_mdev;
++=======
++>>>>>>> df65a573eab2 (net/mlx5e: Refactor eswitch flow attr for destination specific properties)
  	struct mlx5_core_dev	*in_mdev;
  
 -	int split_count;
 -	int out_count;
 -
  	int	action;
 -	__be16	vlan_proto[MLX5_FS_VLAN_DEPTH];
 -	u16	vlan_vid[MLX5_FS_VLAN_DEPTH];
 -	u8	vlan_prio[MLX5_FS_VLAN_DEPTH];
 -	u8	total_vlan;
 +	__be16	vlan_proto;
 +	u16	vlan_vid;
 +	u8	vlan_prio;
  	bool	vlan_handled;
  	u32	encap_id;
+ 	struct {
+ 		struct mlx5_eswitch_rep *rep;
+ 		struct mlx5_core_dev *mdev;
+ 	} dests[MLX5_MAX_FLOW_FWD_VPORTS];
  	u32	mod_hdr_id;
  	u8	match_level;
 -	struct mlx5_fc *counter;
 -	u32	chain;
 -	u16	prio;
 -	u32	dest_chain;
  	struct mlx5e_tc_flow_parse_attr *parse_attr;
  };
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 84864631953e,7cbe602129b7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -70,23 -107,34 +70,49 @@@ mlx5_eswitch_add_offloaded_rule(struct 
  	}
  
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) {
++<<<<<<< HEAD
 +		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
 +		dest[i].vport.num = attr->out_rep->vport;
 +		if (MLX5_CAP_ESW(esw->dev, merged_eswitch)) {
 +			dest[i].vport.vhca_id =
 +				MLX5_CAP_GEN(attr->out_mdev, vhca_id);
 +			dest[i].vport.vhca_id_valid = 1;
++=======
+ 		if (attr->dest_chain) {
+ 			struct mlx5_flow_table *ft;
+ 
+ 			ft = esw_get_prio_table(esw, attr->dest_chain, 1, 0);
+ 			if (IS_ERR(ft)) {
+ 				rule = ERR_CAST(ft);
+ 				goto err_create_goto_table;
+ 			}
+ 
+ 			dest[i].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 			dest[i].ft = ft;
+ 			i++;
+ 		} else {
+ 			for (j = attr->split_count; j < attr->out_count; j++) {
+ 				dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
+ 				dest[i].vport.num = attr->dests[j].rep->vport;
+ 				dest[i].vport.vhca_id =
+ 					MLX5_CAP_GEN(attr->dests[j].mdev, vhca_id);
+ 				if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 					dest[i].vport.flags |=
+ 						MLX5_FLOW_DEST_VPORT_VHCA_ID;
+ 				i++;
+ 			}
++>>>>>>> df65a573eab2 (net/mlx5e: Refactor eswitch flow attr for destination specific properties)
  		}
 +		i++;
  	}
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {
 +		counter = mlx5_fc_create(esw->dev, true);
 +		if (IS_ERR(counter)) {
 +			rule = ERR_CAST(counter);
 +			goto err_counter_alloc;
 +		}
  		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;
 -		dest[i].counter_id = mlx5_fc_id(attr->counter);
 +		dest[i].counter = counter;
  		i++;
  	}
  
@@@ -134,6 -190,101 +160,104 @@@ err_counter_alloc
  	return rule;
  }
  
++<<<<<<< HEAD
++=======
+ struct mlx5_flow_handle *
+ mlx5_eswitch_add_fwd_rule(struct mlx5_eswitch *esw,
+ 			  struct mlx5_flow_spec *spec,
+ 			  struct mlx5_esw_flow_attr *attr)
+ {
+ 	struct mlx5_flow_destination dest[MLX5_MAX_FLOW_FWD_VPORTS + 1] = {};
+ 	struct mlx5_flow_act flow_act = { .flags = FLOW_ACT_NO_APPEND, };
+ 	struct mlx5_flow_table *fast_fdb;
+ 	struct mlx5_flow_table *fwd_fdb;
+ 	struct mlx5_flow_handle *rule;
+ 	void *misc;
+ 	int i;
+ 
+ 	fast_fdb = esw_get_prio_table(esw, attr->chain, attr->prio, 0);
+ 	if (IS_ERR(fast_fdb)) {
+ 		rule = ERR_CAST(fast_fdb);
+ 		goto err_get_fast;
+ 	}
+ 
+ 	fwd_fdb = esw_get_prio_table(esw, attr->chain, attr->prio, 1);
+ 	if (IS_ERR(fwd_fdb)) {
+ 		rule = ERR_CAST(fwd_fdb);
+ 		goto err_get_fwd;
+ 	}
+ 
+ 	flow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
+ 	for (i = 0; i < attr->split_count; i++) {
+ 		dest[i].type = MLX5_FLOW_DESTINATION_TYPE_VPORT;
+ 		dest[i].vport.num = attr->dests[i].rep->vport;
+ 		dest[i].vport.vhca_id =
+ 			MLX5_CAP_GEN(attr->dests[i].mdev, vhca_id);
+ 		if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 			dest[i].vport.flags |= MLX5_FLOW_DEST_VPORT_VHCA_ID;
+ 	}
+ 	dest[i].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 	dest[i].ft = fwd_fdb,
+ 	i++;
+ 
+ 	misc = MLX5_ADDR_OF(fte_match_param, spec->match_value, misc_parameters);
+ 	MLX5_SET(fte_match_set_misc, misc, source_port, attr->in_rep->vport);
+ 
+ 	if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 		MLX5_SET(fte_match_set_misc, misc,
+ 			 source_eswitch_owner_vhca_id,
+ 			 MLX5_CAP_GEN(attr->in_mdev, vhca_id));
+ 
+ 	misc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria, misc_parameters);
+ 	MLX5_SET_TO_ONES(fte_match_set_misc, misc, source_port);
+ 	if (MLX5_CAP_ESW(esw->dev, merged_eswitch))
+ 		MLX5_SET_TO_ONES(fte_match_set_misc, misc,
+ 				 source_eswitch_owner_vhca_id);
+ 
+ 	if (attr->match_level == MLX5_MATCH_NONE)
+ 		spec->match_criteria_enable = MLX5_MATCH_MISC_PARAMETERS;
+ 	else
+ 		spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS |
+ 					      MLX5_MATCH_MISC_PARAMETERS;
+ 
+ 	rule = mlx5_add_flow_rules(fast_fdb, spec, &flow_act, dest, i);
+ 
+ 	if (IS_ERR(rule))
+ 		goto add_err;
+ 
+ 	esw->offloads.num_flows++;
+ 
+ 	return rule;
+ add_err:
+ 	esw_put_prio_table(esw, attr->chain, attr->prio, 1);
+ err_get_fwd:
+ 	esw_put_prio_table(esw, attr->chain, attr->prio, 0);
+ err_get_fast:
+ 	return rule;
+ }
+ 
+ static void
+ __mlx5_eswitch_del_rule(struct mlx5_eswitch *esw,
+ 			struct mlx5_flow_handle *rule,
+ 			struct mlx5_esw_flow_attr *attr,
+ 			bool fwd_rule)
+ {
+ 	bool split = (attr->split_count > 0);
+ 
+ 	mlx5_del_flow_rules(rule);
+ 	esw->offloads.num_flows--;
+ 
+ 	if (fwd_rule)  {
+ 		esw_put_prio_table(esw, attr->chain, attr->prio, 1);
+ 		esw_put_prio_table(esw, attr->chain, attr->prio, 0);
+ 	} else {
+ 		esw_put_prio_table(esw, attr->chain, attr->prio, !!split);
+ 		if (attr->dest_chain)
+ 			esw_put_prio_table(esw, attr->dest_chain, 1, 0);
+ 	}
+ }
+ 
++>>>>>>> df65a573eab2 (net/mlx5e: Refactor eswitch flow attr for destination specific properties)
  void
  mlx5_eswitch_del_offloaded_rule(struct mlx5_eswitch *esw,
  				struct mlx5_flow_handle *rule,
@@@ -173,7 -327,7 +297,11 @@@ esw_vlan_action_get_vport(struct mlx5_e
  	struct mlx5_eswitch_rep *in_rep, *out_rep, *vport = NULL;
  
  	in_rep  = attr->in_rep;
++<<<<<<< HEAD
 +	out_rep = attr->out_rep;
++=======
+ 	out_rep = attr->dests[0].rep;
++>>>>>>> df65a573eab2 (net/mlx5e: Refactor eswitch flow attr for destination specific properties)
  
  	if (push)
  		vport = in_rep;
@@@ -194,7 -348,7 +322,11 @@@ static int esw_add_vlan_action_check(st
  		goto out_notsupp;
  
  	in_rep  = attr->in_rep;
++<<<<<<< HEAD
 +	out_rep = attr->out_rep;
++=======
+ 	out_rep = attr->dests[0].rep;
++>>>>>>> df65a573eab2 (net/mlx5e: Refactor eswitch flow attr for destination specific properties)
  
  	if (push && in_rep->vport == FDB_UPLINK_VPORT)
  		goto out_notsupp;
@@@ -245,7 -400,7 +377,11 @@@ int mlx5_eswitch_add_vlan_action(struc
  
  	if (!push && !pop && fwd) {
  		/* tracks VF --> wire rules without vlan push action */
++<<<<<<< HEAD
 +		if (attr->out_rep->vport == FDB_UPLINK_VPORT) {
++=======
+ 		if (attr->dests[0].rep->vport == FDB_UPLINK_VPORT) {
++>>>>>>> df65a573eab2 (net/mlx5e: Refactor eswitch flow attr for destination specific properties)
  			vport->vlan_refcount++;
  			attr->vlan_handled = true;
  		}
@@@ -305,7 -460,7 +441,11 @@@ int mlx5_eswitch_del_vlan_action(struc
  
  	if (!push && !pop && fwd) {
  		/* tracks VF --> wire rules without vlan push action */
++<<<<<<< HEAD
 +		if (attr->out_rep->vport == FDB_UPLINK_VPORT)
++=======
+ 		if (attr->dests[0].rep->vport == FDB_UPLINK_VPORT)
++>>>>>>> df65a573eab2 (net/mlx5e: Refactor eswitch flow attr for destination specific properties)
  			vport->vlan_refcount--;
  
  		return 0;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
