r8169: factor out getting ether_clk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit b779daea4aee27d3838a9052e2c3364e28ebaa87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/b779daea.failed

rtl_init_one() is complex enough, so we better factor out getting the
ether_clk.

	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b779daea4aee27d3838a9052e2c3364e28ebaa87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/realtek/r8169.c
diff --cc drivers/net/ethernet/realtek/r8169.c
index 8e2332fe4a17,e790a4116f1e..000000000000
--- a/drivers/net/ethernet/realtek/r8169.c
+++ b/drivers/net/ethernet/realtek/r8169.c
@@@ -7339,6 -7127,60 +7339,63 @@@ static bool rtl_chip_supports_csum_v2(s
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int rtl_jumbo_max(struct rtl8169_private *tp)
+ {
+ 	/* Non-GBit versions don't support jumbo frames */
+ 	if (!tp->supports_gmii)
+ 		return JUMBO_1K;
+ 
+ 	switch (tp->mac_version) {
+ 	/* RTL8169 */
+ 	case RTL_GIGA_MAC_VER_01 ... RTL_GIGA_MAC_VER_06:
+ 		return JUMBO_7K;
+ 	/* RTL8168b */
+ 	case RTL_GIGA_MAC_VER_11:
+ 	case RTL_GIGA_MAC_VER_12:
+ 	case RTL_GIGA_MAC_VER_17:
+ 		return JUMBO_4K;
+ 	/* RTL8168c */
+ 	case RTL_GIGA_MAC_VER_18 ... RTL_GIGA_MAC_VER_24:
+ 		return JUMBO_6K;
+ 	default:
+ 		return JUMBO_9K;
+ 	}
+ }
+ 
+ static void rtl_disable_clk(void *data)
+ {
+ 	clk_disable_unprepare(data);
+ }
+ 
+ static int rtl_get_ether_clk(struct rtl8169_private *tp)
+ {
+ 	struct device *d = tp_to_dev(tp);
+ 	struct clk *clk;
+ 	int rc;
+ 
+ 	clk = devm_clk_get(d, "ether_clk");
+ 	if (IS_ERR(clk)) {
+ 		rc = PTR_ERR(clk);
+ 		if (rc == -ENOENT)
+ 			/* clk-core allows NULL (for suspend / resume) */
+ 			rc = 0;
+ 		else if (rc != -EPROBE_DEFER)
+ 			dev_err(d, "failed to get clk: %d\n", rc);
+ 	} else {
+ 		tp->clk = clk;
+ 		rc = clk_prepare_enable(clk);
+ 		if (rc)
+ 			dev_err(d, "failed to enable clk: %d\n", rc);
+ 		else
+ 			rc = devm_add_action_or_reset(d, rtl_disable_clk, clk);
+ 	}
+ 
+ 	return rc;
+ }
+ 
++>>>>>>> b779daea4aee (r8169: factor out getting ether_clk)
  static int rtl_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
  {
  	const struct rtl_cfg_info *cfg = rtl_cfg_infos + ent->driver_data;
@@@ -7358,14 -7199,12 +7415,21 @@@
  	tp->dev = dev;
  	tp->pci_dev = pdev;
  	tp->msg_enable = netif_msg_init(debug.msg_enable, R8169_MSG_DEFAULT);
 -	tp->supports_gmii = cfg->has_gmii;
  
++<<<<<<< HEAD
 +	mii = &tp->mii;
 +	mii->dev = dev;
 +	mii->mdio_read = rtl_mdio_read;
 +	mii->mdio_write = rtl_mdio_write;
 +	mii->phy_id_mask = 0x1f;
 +	mii->reg_num_mask = 0x1f;
 +	mii->supports_gmii = cfg->has_gmii;
++=======
+ 	/* Get the *optional* external "ether_clk" used on some boards */
+ 	rc = rtl_get_ether_clk(tp);
+ 	if (rc)
+ 		return rc;
++>>>>>>> b779daea4aee (r8169: factor out getting ether_clk)
  
  	/* enable device (incl. PCI PM wakeup and hotplug setup) */
  	rc = pcim_enable_device(pdev);
* Unmerged path drivers/net/ethernet/realtek/r8169.c
