scsi: mpt3sas: Configure reply post queue depth, DMA and sgl tablesize.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [scsi] mpt3sas: Configure reply post queue depth, DMA and sgl tablesize (Tomas Henzl) [1513855]
Rebuild_FUZZ: 94.81%
commit-author Suganath Prabu Subramani <suganath-prabu.subramani@broadcom.com>
commit 0448f0195124e33f11d15b7d1e1cab959989eee7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0448f019.failed

This configures shost max sector to 128, single reply descriptor post
queue, sgl table size to 16 and 32 bit DMA for MPI Endpoint and it
supports 64K as max IO.

	Signed-off-by: Suganath Prabu S <suganath-prabu.subramani@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 0448f0195124e33f11d15b7d1e1cab959989eee7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/mpt3sas/mpt3sas_base.c
diff --cc drivers/scsi/mpt3sas/mpt3sas_base.c
index fe9d88fa114b,f45da9a4bb50..000000000000
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@@ -3264,17 -3891,21 +3268,33 @@@ _base_allocate_memory_pools(struct MPT3
  		sg_tablesize = min_t(unsigned short, sg_tablesize,
  		   MPT_KDUMP_MIN_PHYS_SEGMENTS);
  
++<<<<<<< HEAD
 +	if (sg_tablesize < MPT_MIN_PHYS_SEGMENTS)
 +		sg_tablesize = MPT_MIN_PHYS_SEGMENTS;
 +	else if (sg_tablesize > MPT_MAX_PHYS_SEGMENTS) {
 +		sg_tablesize = min_t(unsigned short, sg_tablesize,
 +				      SCSI_MAX_SG_CHAIN_SEGMENTS);
 +		pr_warn(MPT3SAS_FMT
 +		 "sg_tablesize(%u) is bigger than kernel"
 +		 " defined SCSI_MAX_SG_SEGMENTS(%u)\n", ioc->name,
 +		 sg_tablesize, MPT_MAX_PHYS_SEGMENTS);
++=======
+ 	if (ioc->is_mcpu_endpoint)
+ 		ioc->shost->sg_tablesize = MPT_MIN_PHYS_SEGMENTS;
+ 	else {
+ 		if (sg_tablesize < MPT_MIN_PHYS_SEGMENTS)
+ 			sg_tablesize = MPT_MIN_PHYS_SEGMENTS;
+ 		else if (sg_tablesize > MPT_MAX_PHYS_SEGMENTS) {
+ 			sg_tablesize = min_t(unsigned short, sg_tablesize,
+ 					SG_MAX_SEGMENTS);
+ 			pr_warn(MPT3SAS_FMT
+ 				"sg_tablesize(%u) is bigger than kernel "
+ 				"defined SG_CHUNK_SIZE(%u)\n", ioc->name,
+ 				sg_tablesize, MPT_MAX_PHYS_SEGMENTS);
+ 		}
+ 		ioc->shost->sg_tablesize = sg_tablesize;
++>>>>>>> 0448f0195124 (scsi: mpt3sas: Configure reply post queue depth, DMA and sgl tablesize.)
  	}
- 	ioc->shost->sg_tablesize = sg_tablesize;
  
  	ioc->internal_depth = min_t(int, (facts->HighPriorityCredit + (5)),
  		(facts->RequestCredit / 4));
* Unmerged path drivers/scsi/mpt3sas/mpt3sas_base.c
diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
index 51967ba0f26c..b1e10df9b071 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@ -10710,26 +10710,34 @@ _scsih_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	shost->transportt = mpt3sas_transport_template;
 	shost->unique_id = ioc->id;
 
-	if (max_sectors != 0xFFFF) {
-		if (max_sectors < 64) {
-			shost->max_sectors = 64;
-			pr_warn(MPT3SAS_FMT "Invalid value %d passed " \
-			    "for max_sectors, range is 64 to 32767. Assigning "
-			    "value of 64.\n", ioc->name, max_sectors);
-		} else if (max_sectors > 32767) {
-			shost->max_sectors = 32767;
-			pr_warn(MPT3SAS_FMT "Invalid value %d passed " \
-			    "for max_sectors, range is 64 to 32767. Assigning "
-			    "default value of 32767.\n", ioc->name,
-			    max_sectors);
-		} else {
-			shost->max_sectors = max_sectors & 0xFFFE;
-			pr_info(MPT3SAS_FMT
+	if (ioc->is_mcpu_endpoint) {
+		/* mCPU MPI support 64K max IO */
+		shost->max_sectors = 128;
+		pr_info(MPT3SAS_FMT
 				"The max_sectors value is set to %d\n",
 				ioc->name, shost->max_sectors);
+	} else {
+		if (max_sectors != 0xFFFF) {
+			if (max_sectors < 64) {
+				shost->max_sectors = 64;
+				pr_warn(MPT3SAS_FMT "Invalid value %d passed " \
+				    "for max_sectors, range is 64 to 32767. " \
+				    "Assigning value of 64.\n", \
+				    ioc->name, max_sectors);
+			} else if (max_sectors > 32767) {
+				shost->max_sectors = 32767;
+				pr_warn(MPT3SAS_FMT "Invalid value %d passed " \
+				    "for max_sectors, range is 64 to 32767." \
+				    "Assigning default value of 32767.\n", \
+				    ioc->name, max_sectors);
+			} else {
+				shost->max_sectors = max_sectors & 0xFFFE;
+				pr_info(MPT3SAS_FMT
+					"The max_sectors value is set to %d\n",
+					ioc->name, shost->max_sectors);
+			}
 		}
 	}
-
 	/* register EEDP capabilities with SCSI layer */
 	if (prot_mask > 0)
 		scsi_host_set_prot(shost, prot_mask);
