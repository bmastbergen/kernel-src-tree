treewide: devm_kzalloc() -> devm_kcalloc()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Kees Cook <keescook@chromium.org>
commit a86854d0c599b3202307abceb68feee4d7061578
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/a86854d0.failed

The devm_kzalloc() function has a 2-factor argument form, devm_kcalloc().
This patch replaces cases of:

        devm_kzalloc(handle, a * b, gfp)

with:
        devm_kcalloc(handle, a * b, gfp)

as well as handling cases of:

        devm_kzalloc(handle, a * b * c, gfp)

with:

        devm_kzalloc(handle, array3_size(a, b, c), gfp)

as it's slightly less ugly than:

        devm_kcalloc(handle, array_size(a, b), c, gfp)

This does, however, attempt to ignore constant size factors like:

        devm_kzalloc(handle, 4 * 1024, gfp)

though any constants defined via macros get caught up in the conversion.

Any factors with a sizeof() of "unsigned char", "char", and "u8" were
dropped, since they're redundant.

Some manual whitespace fixes were needed in this patch, as Coccinelle
really liked to write "=devm_kcalloc..." instead of "= devm_kcalloc...".

The Coccinelle script used for this was:

// Fix redundant parens around sizeof().
@@
expression HANDLE;
type TYPE;
expression THING, E;
@@

(
  devm_kzalloc(HANDLE,
-	(sizeof(TYPE)) * E
+	sizeof(TYPE) * E
  , ...)
|
  devm_kzalloc(HANDLE,
-	(sizeof(THING)) * E
+	sizeof(THING) * E
  , ...)
)

// Drop single-byte sizes and redundant parens.
@@
expression HANDLE;
expression COUNT;
typedef u8;
typedef __u8;
@@

(
  devm_kzalloc(HANDLE,
-	sizeof(u8) * (COUNT)
+	COUNT
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(__u8) * (COUNT)
+	COUNT
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(char) * (COUNT)
+	COUNT
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(unsigned char) * (COUNT)
+	COUNT
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(u8) * COUNT
+	COUNT
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(__u8) * COUNT
+	COUNT
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(char) * COUNT
+	COUNT
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(unsigned char) * COUNT
+	COUNT
  , ...)
)

// 2-factor product with sizeof(type/expression) and identifier or constant.
@@
expression HANDLE;
type TYPE;
expression THING;
identifier COUNT_ID;
constant COUNT_CONST;
@@

(
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	sizeof(TYPE) * (COUNT_ID)
+	COUNT_ID, sizeof(TYPE)
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	sizeof(TYPE) * COUNT_ID
+	COUNT_ID, sizeof(TYPE)
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	sizeof(TYPE) * (COUNT_CONST)
+	COUNT_CONST, sizeof(TYPE)
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	sizeof(TYPE) * COUNT_CONST
+	COUNT_CONST, sizeof(TYPE)
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	sizeof(THING) * (COUNT_ID)
+	COUNT_ID, sizeof(THING)
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	sizeof(THING) * COUNT_ID
+	COUNT_ID, sizeof(THING)
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	sizeof(THING) * (COUNT_CONST)
+	COUNT_CONST, sizeof(THING)
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	sizeof(THING) * COUNT_CONST
+	COUNT_CONST, sizeof(THING)
  , ...)
)

// 2-factor product, only identifiers.
@@
expression HANDLE;
identifier SIZE, COUNT;
@@

- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	SIZE * COUNT
+	COUNT, SIZE
  , ...)

// 3-factor product with 1 sizeof(type) or sizeof(expression), with
// redundant parens removed.
@@
expression HANDLE;
expression THING;
identifier STRIDE, COUNT;
type TYPE;
@@

(
  devm_kzalloc(HANDLE,
-	sizeof(TYPE) * (COUNT) * (STRIDE)
+	array3_size(COUNT, STRIDE, sizeof(TYPE))
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(TYPE) * (COUNT) * STRIDE
+	array3_size(COUNT, STRIDE, sizeof(TYPE))
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(TYPE) * COUNT * (STRIDE)
+	array3_size(COUNT, STRIDE, sizeof(TYPE))
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(TYPE) * COUNT * STRIDE
+	array3_size(COUNT, STRIDE, sizeof(TYPE))
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(THING) * (COUNT) * (STRIDE)
+	array3_size(COUNT, STRIDE, sizeof(THING))
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(THING) * (COUNT) * STRIDE
+	array3_size(COUNT, STRIDE, sizeof(THING))
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(THING) * COUNT * (STRIDE)
+	array3_size(COUNT, STRIDE, sizeof(THING))
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(THING) * COUNT * STRIDE
+	array3_size(COUNT, STRIDE, sizeof(THING))
  , ...)
)

// 3-factor product with 2 sizeof(variable), with redundant parens removed.
@@
expression HANDLE;
expression THING1, THING2;
identifier COUNT;
type TYPE1, TYPE2;
@@

(
  devm_kzalloc(HANDLE,
-	sizeof(TYPE1) * sizeof(TYPE2) * COUNT
+	array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(TYPE1) * sizeof(THING2) * (COUNT)
+	array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(THING1) * sizeof(THING2) * COUNT
+	array3_size(COUNT, sizeof(THING1), sizeof(THING2))
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(THING1) * sizeof(THING2) * (COUNT)
+	array3_size(COUNT, sizeof(THING1), sizeof(THING2))
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(TYPE1) * sizeof(THING2) * COUNT
+	array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
  , ...)
|
  devm_kzalloc(HANDLE,
-	sizeof(TYPE1) * sizeof(THING2) * (COUNT)
+	array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
  , ...)
)

// 3-factor product, only identifiers, with redundant parens removed.
@@
expression HANDLE;
identifier STRIDE, SIZE, COUNT;
@@

(
  devm_kzalloc(HANDLE,
-	(COUNT) * STRIDE * SIZE
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  devm_kzalloc(HANDLE,
-	COUNT * (STRIDE) * SIZE
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  devm_kzalloc(HANDLE,
-	COUNT * STRIDE * (SIZE)
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  devm_kzalloc(HANDLE,
-	(COUNT) * (STRIDE) * SIZE
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  devm_kzalloc(HANDLE,
-	COUNT * (STRIDE) * (SIZE)
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  devm_kzalloc(HANDLE,
-	(COUNT) * STRIDE * (SIZE)
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  devm_kzalloc(HANDLE,
-	(COUNT) * (STRIDE) * (SIZE)
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
|
  devm_kzalloc(HANDLE,
-	COUNT * STRIDE * SIZE
+	array3_size(COUNT, STRIDE, SIZE)
  , ...)
)

// Any remaining multi-factor products, first at least 3-factor products,
// when they're not all constants...
@@
expression HANDLE;
expression E1, E2, E3;
constant C1, C2, C3;
@@

(
  devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
|
  devm_kzalloc(HANDLE,
-	(E1) * E2 * E3
+	array3_size(E1, E2, E3)
  , ...)
|
  devm_kzalloc(HANDLE,
-	(E1) * (E2) * E3
+	array3_size(E1, E2, E3)
  , ...)
|
  devm_kzalloc(HANDLE,
-	(E1) * (E2) * (E3)
+	array3_size(E1, E2, E3)
  , ...)
|
  devm_kzalloc(HANDLE,
-	E1 * E2 * E3
+	array3_size(E1, E2, E3)
  , ...)
)

// And then all remaining 2 factors products when they're not all constants,
// keeping sizeof() as the second factor argument.
@@
expression HANDLE;
expression THING, E1, E2;
type TYPE;
constant C1, C2, C3;
@@

(
  devm_kzalloc(HANDLE, sizeof(THING) * C2, ...)
|
  devm_kzalloc(HANDLE, sizeof(TYPE) * C2, ...)
|
  devm_kzalloc(HANDLE, C1 * C2 * C3, ...)
|
  devm_kzalloc(HANDLE, C1 * C2, ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	sizeof(TYPE) * (E2)
+	E2, sizeof(TYPE)
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	sizeof(TYPE) * E2
+	E2, sizeof(TYPE)
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	sizeof(THING) * (E2)
+	E2, sizeof(THING)
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	sizeof(THING) * E2
+	E2, sizeof(THING)
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	(E1) * E2
+	E1, E2
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	(E1) * (E2)
+	E1, E2
  , ...)
|
- devm_kzalloc
+ devm_kcalloc
  (HANDLE,
-	E1 * E2
+	E1, E2
  , ...)
)

	Signed-off-by: Kees Cook <keescook@chromium.org>
(cherry picked from commit a86854d0c599b3202307abceb68feee4d7061578)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ata/sata_mv.c
#	drivers/bus/fsl-mc/fsl-mc-allocator.c
#	drivers/clk/bcm/clk-bcm2835.c
#	drivers/clk/ti/adpll.c
#	drivers/cpufreq/brcmstb-avs-cpufreq.c
#	drivers/cpufreq/imx6q-cpufreq.c
#	drivers/crypto/marvell/cesa.c
#	drivers/crypto/talitos.c
#	drivers/devfreq/devfreq.c
#	drivers/devfreq/event/exynos-ppmu.c
#	drivers/dma/k3dma.c
#	drivers/dma/mv_xor_v2.c
#	drivers/dma/s3c24xx-dma.c
#	drivers/dma/zx_dma.c
#	drivers/firmware/arm_scpi.c
#	drivers/firmware/ti_sci.c
#	drivers/gpio/gpio-adnp.c
#	drivers/gpio/gpio-aspeed.c
#	drivers/gpio/gpio-bcm-kona.c
#	drivers/gpio/gpio-davinci.c
#	drivers/gpio/gpio-thunderx.c
#	drivers/gpu/drm/exynos/exynos_drm_fimc.c
#	drivers/gpu/drm/exynos/exynos_drm_gsc.c
#	drivers/gpu/drm/msm/hdmi/hdmi.c
#	drivers/gpu/drm/msm/hdmi/hdmi_phy.c
#	drivers/hid/wacom_sys.c
#	drivers/hwmon/aspeed-pwm-tacho.c
#	drivers/hwmon/gpio-fan.c
#	drivers/hwmon/iio_hwmon.c
#	drivers/hwmon/nct6683.c
#	drivers/hwmon/nct6775.c
#	drivers/hwmon/pmbus/pmbus_core.c
#	drivers/hwmon/pmbus/ucd9000.c
#	drivers/hwmon/pwm-fan.c
#	drivers/hwtracing/coresight/coresight-etb10.c
#	drivers/hwtracing/coresight/of_coresight.c
#	drivers/i2c/busses/i2c-qup.c
#	drivers/i2c/muxes/i2c-mux-reg.c
#	drivers/iio/adc/at91_adc.c
#	drivers/iio/adc/twl6030-gpadc.c
#	drivers/iio/dac/ad5592r-base.c
#	drivers/iio/multiplexer/iio-mux.c
#	drivers/input/keyboard/clps711x-keypad.c
#	drivers/input/misc/rotary_encoder.c
#	drivers/input/rmi4/rmi_driver.c
#	drivers/input/rmi4/rmi_f54.c
#	drivers/input/rmi4/rmi_spi.c
#	drivers/iommu/arm-smmu.c
#	drivers/iommu/rockchip-iommu.c
#	drivers/irqchip/irq-imgpdc.c
#	drivers/irqchip/irq-mvebu-gicp.c
#	drivers/leds/leds-apu.c
#	drivers/leds/leds-lp55xx-common.c
#	drivers/leds/leds-lp8501.c
#	drivers/leds/leds-mc13783.c
#	drivers/leds/leds-mlxcpld.c
#	drivers/leds/leds-netxbig.c
#	drivers/leds/leds-ns2.c
#	drivers/leds/leds-pca955x.c
#	drivers/leds/leds-pca963x.c
#	drivers/leds/leds-tca6507.c
#	drivers/mailbox/hi6220-mailbox.c
#	drivers/mailbox/mailbox-sti.c
#	drivers/mailbox/omap-mailbox.c
#	drivers/mailbox/ti-msgmgr.c
#	drivers/media/i2c/s5k5baf.c
#	drivers/media/platform/am437x/am437x-vpfe.c
#	drivers/media/platform/davinci/vpif_capture.c
#	drivers/media/platform/qcom/camss-8x16/camss-csid.c
#	drivers/media/platform/qcom/camss-8x16/camss-csiphy.c
#	drivers/media/platform/qcom/camss-8x16/camss-ispif.c
#	drivers/media/platform/qcom/camss-8x16/camss-vfe.c
#	drivers/media/platform/qcom/camss-8x16/camss.c
#	drivers/media/platform/vsp1/vsp1_entity.c
#	drivers/media/platform/xilinx/xilinx-vipp.c
#	drivers/media/v4l2-core/v4l2-flash-led-class.c
#	drivers/mfd/ab8500-debugfs.c
#	drivers/mfd/htc-egpio.c
#	drivers/mfd/htc-i2cpld.c
#	drivers/mfd/motorola-cpcap.c
#	drivers/mfd/sprd-sc27xx-spi.c
#	drivers/misc/sram.c
#	drivers/mmc/host/sdhci-omap.c
#	drivers/mtd/devices/docg3.c
#	drivers/mtd/nand/raw/qcom_nandc.c
#	drivers/mtd/nand/s3c2410.c
#	drivers/net/dsa/b53/b53_common.c
#	drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
#	drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
#	drivers/net/ethernet/ni/nixge.c
#	drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
#	drivers/net/ethernet/ti/cpsw.c
#	drivers/net/ethernet/ti/netcp_ethss.c
#	drivers/net/phy/phy_led_triggers.c
#	drivers/net/wireless/mediatek/mt76/mac80211.c
#	drivers/pci/cadence/pcie-cadence-ep.c
#	drivers/pci/dwc/pci-dra7xx.c
#	drivers/pci/dwc/pcie-designware-ep.c
#	drivers/pci/host/pcie-rockchip-ep.c
#	drivers/pinctrl/berlin/berlin.c
#	drivers/pinctrl/freescale/pinctrl-imx.c
#	drivers/pinctrl/freescale/pinctrl-imx1-core.c
#	drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
#	drivers/pinctrl/mvebu/pinctrl-mvebu.c
#	drivers/pinctrl/pinctrl-at91-pio4.c
#	drivers/pinctrl/pinctrl-at91.c
#	drivers/pinctrl/pinctrl-axp209.c
#	drivers/pinctrl/pinctrl-digicolor.c
#	drivers/pinctrl/pinctrl-ingenic.c
#	drivers/pinctrl/pinctrl-lpc18xx.c
#	drivers/pinctrl/pinctrl-ocelot.c
#	drivers/pinctrl/pinctrl-rockchip.c
#	drivers/pinctrl/pinctrl-single.c
#	drivers/pinctrl/pinctrl-st.c
#	drivers/pinctrl/pinctrl-tegra.c
#	drivers/pinctrl/samsung/pinctrl-exynos.c
#	drivers/pinctrl/samsung/pinctrl-samsung.c
#	drivers/pinctrl/sh-pfc/core.c
#	drivers/pinctrl/sh-pfc/gpio.c
#	drivers/pinctrl/sh-pfc/pinctrl.c
#	drivers/pinctrl/sprd/pinctrl-sprd.c
#	drivers/pinctrl/sunxi/pinctrl-sunxi.c
#	drivers/pinctrl/ti/pinctrl-ti-iodelay.c
#	drivers/pinctrl/zte/pinctrl-zx.c
#	drivers/platform/mellanox/mlxreg-hotplug.c
#	drivers/power/charger-manager.c
#	drivers/power/power_supply_core.c
#	drivers/pwm/pwm-lp3943.c
#	drivers/regulator/act8865-regulator.c
#	drivers/regulator/as3711-regulator.c
#	drivers/regulator/bcm590xx-regulator.c
#	drivers/regulator/da9063-regulator.c
#	drivers/regulator/gpio-regulator.c
#	drivers/regulator/max1586.c
#	drivers/regulator/max8660.c
#	drivers/regulator/max8998.c
#	drivers/regulator/pbias-regulator.c
#	drivers/regulator/rc5t583-regulator.c
#	drivers/regulator/s5m8767.c
#	drivers/regulator/ti-abb-regulator.c
#	drivers/regulator/tps65090-regulator.c
#	drivers/regulator/tps65217-regulator.c
#	drivers/regulator/tps65218-regulator.c
#	drivers/regulator/tps65910-regulator.c
#	drivers/regulator/tps80031-regulator.c
#	drivers/reset/reset-ti-syscon.c
#	drivers/scsi/ufs/ufshcd-pltfrm.c
#	drivers/scsi/ufs/ufshcd.c
#	drivers/soc/bcm/raspberrypi-power.c
#	drivers/soc/mediatek/mtk-scpsys.c
#	drivers/soc/ti/knav_qmss_acc.c
#	drivers/spi/spi-davinci.c
#	drivers/spi/spi-ep93xx.c
#	drivers/spi/spi-gpio.c
#	drivers/spi/spi-imx.c
#	drivers/spi/spi.c
#	drivers/staging/greybus/audio_topology.c
#	drivers/staging/media/imx/imx-media-dev.c
#	drivers/staging/mt7621-pinctrl/pinctrl-rt2880.c
#	drivers/thermal/tegra/soctherm.c
#	drivers/thermal/thermal-generic-adc.c
#	drivers/usb/gadget/atmel_usba_udc.c
#	drivers/usb/gadget/udc/renesas_usb3.c
#	sound/soc/au1x/dbdma2.c
#	sound/soc/codecs/hdmi-codec.c
#	sound/soc/codecs/wm8994.c
#	sound/soc/davinci/davinci-mcasp.c
#	sound/soc/generic/audio-graph-card.c
#	sound/soc/generic/audio-graph-scu-card.c
#	sound/soc/generic/simple-card.c
#	sound/soc/generic/simple-scu-card.c
#	sound/soc/img/img-i2s-in.c
#	sound/soc/img/img-i2s-out.c
#	sound/soc/intel/skylake/skl-topology.c
#	sound/soc/mediatek/mt2701/mt2701-afe-pcm.c
#	sound/soc/pxa/mmp-sspa.c
#	sound/soc/rockchip/rk3399_gru_sound.c
#	sound/soc/sh/rcar/cmd.c
#	sound/soc/sh/rcar/core.c
#	sound/soc/sh/rcar/ctu.c
#	sound/soc/sh/rcar/dvc.c
#	sound/soc/sh/rcar/mix.c
#	sound/soc/sh/rcar/src.c
#	sound/soc/sh/rcar/ssi.c
#	sound/soc/sh/rcar/ssiu.c
#	sound/soc/uniphier/aio-cpu.c
diff --cc drivers/ata/sata_mv.c
index 56be31819897,73ba8e134ca9..000000000000
--- a/drivers/ata/sata_mv.c
+++ b/drivers/ata/sata_mv.c
@@@ -4076,8 -4119,12 +4076,16 @@@ static int mv_platform_probe(struct pla
  					GFP_KERNEL);
  	if (!hpriv->port_clks)
  		return -ENOMEM;
++<<<<<<< HEAD
++=======
+ 	hpriv->port_phys = devm_kcalloc(&pdev->dev,
+ 					n_ports, sizeof(struct phy *),
+ 					GFP_KERNEL);
+ 	if (!hpriv->port_phys)
+ 		return -ENOMEM;
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	host->private_data = hpriv;
 +	hpriv->n_ports = n_ports;
  	hpriv->board_idx = chip_soc;
  
  	host->iomap = NULL;
diff --cc drivers/cpufreq/imx6q-cpufreq.c
index b78bc35973ba,70912104a199..000000000000
--- a/drivers/cpufreq/imx6q-cpufreq.c
+++ b/drivers/cpufreq/imx6q-cpufreq.c
@@@ -250,13 -367,55 +250,59 @@@ static int imx6q_cpufreq_probe(struct p
  	if (num < 0) {
  		ret = num;
  		dev_err(cpu_dev, "no OPP table is found: %d\n", ret);
 -		goto out_free_opp;
 +		goto put_node;
  	}
  
 -	ret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table);
 +	ret = opp_init_cpufreq_table(cpu_dev, &freq_table);
  	if (ret) {
  		dev_err(cpu_dev, "failed to init cpufreq table: %d\n", ret);
++<<<<<<< HEAD
 +		goto put_node;
++=======
+ 		goto out_free_opp;
+ 	}
+ 
+ 	/* Make imx6_soc_volt array's size same as arm opp number */
+ 	imx6_soc_volt = devm_kcalloc(cpu_dev, num, sizeof(*imx6_soc_volt),
+ 				     GFP_KERNEL);
+ 	if (imx6_soc_volt == NULL) {
+ 		ret = -ENOMEM;
+ 		goto free_freq_table;
+ 	}
+ 
+ 	prop = of_find_property(np, "fsl,soc-operating-points", NULL);
+ 	if (!prop || !prop->value)
+ 		goto soc_opp_out;
+ 
+ 	/*
+ 	 * Each OPP is a set of tuples consisting of frequency and
+ 	 * voltage like <freq-kHz vol-uV>.
+ 	 */
+ 	nr = prop->length / sizeof(u32);
+ 	if (nr % 2 || (nr / 2) < num)
+ 		goto soc_opp_out;
+ 
+ 	for (j = 0; j < num; j++) {
+ 		val = prop->value;
+ 		for (i = 0; i < nr / 2; i++) {
+ 			unsigned long freq = be32_to_cpup(val++);
+ 			unsigned long volt = be32_to_cpup(val++);
+ 			if (freq_table[j].frequency == freq) {
+ 				imx6_soc_volt[soc_opp_count++] = volt;
+ 				break;
+ 			}
+ 		}
+ 	}
+ 
+ soc_opp_out:
+ 	/* use fixed soc opp volt if no valid soc opp info found in dtb */
+ 	if (soc_opp_count != num) {
+ 		dev_warn(cpu_dev, "can NOT find valid fsl,soc-operating-points property in dtb, use default value!\n");
+ 		for (j = 0; j < num; j++)
+ 			imx6_soc_volt[j] = PU_SOC_VOLTAGE_NORMAL;
+ 		if (freq_table[num - 1].frequency * 1000 == FREQ_1P2_GHZ)
+ 			imx6_soc_volt[num - 1] = PU_SOC_VOLTAGE_HIGH;
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	}
  
  	if (of_property_read_u32(np, "clock-latency", &transition_latency))
diff --cc drivers/crypto/talitos.c
index 5b2b5e61e4f9,cf14f099ce4a..000000000000
--- a/drivers/crypto/talitos.c
+++ b/drivers/crypto/talitos.c
@@@ -2756,8 -3339,64 +2756,69 @@@ static int talitos_probe(struct platfor
  				  TALITOS_FTR_SHA224_HWINIT |
  				  TALITOS_FTR_HMAC_OK;
  
++<<<<<<< HEAD
 +	priv->chan = kzalloc(sizeof(struct talitos_channel) *
 +			     priv->num_channels, GFP_KERNEL);
++=======
+ 	if (of_device_is_compatible(np, "fsl,sec1.0"))
+ 		priv->features |= TALITOS_FTR_SEC1;
+ 
+ 	if (of_device_is_compatible(np, "fsl,sec1.2")) {
+ 		priv->reg_deu = priv->reg + TALITOS12_DEU;
+ 		priv->reg_aesu = priv->reg + TALITOS12_AESU;
+ 		priv->reg_mdeu = priv->reg + TALITOS12_MDEU;
+ 		stride = TALITOS1_CH_STRIDE;
+ 	} else if (of_device_is_compatible(np, "fsl,sec1.0")) {
+ 		priv->reg_deu = priv->reg + TALITOS10_DEU;
+ 		priv->reg_aesu = priv->reg + TALITOS10_AESU;
+ 		priv->reg_mdeu = priv->reg + TALITOS10_MDEU;
+ 		priv->reg_afeu = priv->reg + TALITOS10_AFEU;
+ 		priv->reg_rngu = priv->reg + TALITOS10_RNGU;
+ 		priv->reg_pkeu = priv->reg + TALITOS10_PKEU;
+ 		stride = TALITOS1_CH_STRIDE;
+ 	} else {
+ 		priv->reg_deu = priv->reg + TALITOS2_DEU;
+ 		priv->reg_aesu = priv->reg + TALITOS2_AESU;
+ 		priv->reg_mdeu = priv->reg + TALITOS2_MDEU;
+ 		priv->reg_afeu = priv->reg + TALITOS2_AFEU;
+ 		priv->reg_rngu = priv->reg + TALITOS2_RNGU;
+ 		priv->reg_pkeu = priv->reg + TALITOS2_PKEU;
+ 		priv->reg_keu = priv->reg + TALITOS2_KEU;
+ 		priv->reg_crcu = priv->reg + TALITOS2_CRCU;
+ 		stride = TALITOS2_CH_STRIDE;
+ 	}
+ 
+ 	err = talitos_probe_irq(ofdev);
+ 	if (err)
+ 		goto err_out;
+ 
+ 	if (of_device_is_compatible(np, "fsl,sec1.0")) {
+ 		if (priv->num_channels == 1)
+ 			tasklet_init(&priv->done_task[0], talitos1_done_ch0,
+ 				     (unsigned long)dev);
+ 		else
+ 			tasklet_init(&priv->done_task[0], talitos1_done_4ch,
+ 				     (unsigned long)dev);
+ 	} else {
+ 		if (priv->irq[1]) {
+ 			tasklet_init(&priv->done_task[0], talitos2_done_ch0_2,
+ 				     (unsigned long)dev);
+ 			tasklet_init(&priv->done_task[1], talitos2_done_ch1_3,
+ 				     (unsigned long)dev);
+ 		} else if (priv->num_channels == 1) {
+ 			tasklet_init(&priv->done_task[0], talitos2_done_ch0,
+ 				     (unsigned long)dev);
+ 		} else {
+ 			tasklet_init(&priv->done_task[0], talitos2_done_4ch,
+ 				     (unsigned long)dev);
+ 		}
+ 	}
+ 
+ 	priv->chan = devm_kcalloc(dev,
+ 				  priv->num_channels,
+ 				  sizeof(struct talitos_channel),
+ 				  GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	if (!priv->chan) {
  		dev_err(dev, "failed to allocate channel management space\n");
  		err = -ENOMEM;
@@@ -2778,8 -3406,17 +2839,22 @@@
  	priv->fifo_len = roundup_pow_of_two(priv->chfifo_len);
  
  	for (i = 0; i < priv->num_channels; i++) {
++<<<<<<< HEAD
 +		priv->chan[i].fifo = kzalloc(sizeof(struct talitos_request) *
 +					     priv->fifo_len, GFP_KERNEL);
++=======
+ 		priv->chan[i].reg = priv->reg + stride * (i + 1);
+ 		if (!priv->irq[1] || !(i & 1))
+ 			priv->chan[i].reg += TALITOS_CH_BASE_OFFSET;
+ 
+ 		spin_lock_init(&priv->chan[i].head_lock);
+ 		spin_lock_init(&priv->chan[i].tail_lock);
+ 
+ 		priv->chan[i].fifo = devm_kcalloc(dev,
+ 						priv->fifo_len,
+ 						sizeof(struct talitos_request),
+ 						GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		if (!priv->chan[i].fifo) {
  			dev_err(dev, "failed to allocate request fifo %d\n", i);
  			err = -ENOMEM;
diff --cc drivers/devfreq/devfreq.c
index e94e619fe050,0b5b3abe054e..000000000000
--- a/drivers/devfreq/devfreq.c
+++ b/drivers/devfreq/devfreq.c
@@@ -477,12 -595,48 +477,55 @@@ struct devfreq *devfreq_add_device(stru
  	devfreq->data = data;
  	devfreq->nb.notifier_call = devfreq_notifier_call;
  
++<<<<<<< HEAD
 +	devfreq->trans_table =	devm_kzalloc(dev, sizeof(unsigned int) *
 +						devfreq->profile->max_state *
 +						devfreq->profile->max_state,
 +						GFP_KERNEL);
 +	devfreq->time_in_state = devm_kzalloc(dev, sizeof(unsigned int) *
++=======
+ 	if (!devfreq->profile->max_state && !devfreq->profile->freq_table) {
+ 		mutex_unlock(&devfreq->lock);
+ 		err = set_freq_table(devfreq);
+ 		if (err < 0)
+ 			goto err_out;
+ 		mutex_lock(&devfreq->lock);
+ 	}
+ 
+ 	devfreq->min_freq = find_available_min_freq(devfreq);
+ 	if (!devfreq->min_freq) {
+ 		mutex_unlock(&devfreq->lock);
+ 		err = -EINVAL;
+ 		goto err_dev;
+ 	}
+ 	devfreq->scaling_min_freq = devfreq->min_freq;
+ 
+ 	devfreq->max_freq = find_available_max_freq(devfreq);
+ 	if (!devfreq->max_freq) {
+ 		mutex_unlock(&devfreq->lock);
+ 		err = -EINVAL;
+ 		goto err_dev;
+ 	}
+ 	devfreq->scaling_max_freq = devfreq->max_freq;
+ 
+ 	dev_set_name(&devfreq->dev, "devfreq%d",
+ 				atomic_inc_return(&devfreq_no));
+ 	err = device_register(&devfreq->dev);
+ 	if (err) {
+ 		mutex_unlock(&devfreq->lock);
+ 		goto err_dev;
+ 	}
+ 
+ 	devfreq->trans_table =
+ 		devm_kzalloc(&devfreq->dev,
+ 			     array3_size(sizeof(unsigned int),
+ 					 devfreq->profile->max_state,
+ 					 devfreq->profile->max_state),
+ 			     GFP_KERNEL);
+ 	devfreq->time_in_state = devm_kcalloc(&devfreq->dev,
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  						devfreq->profile->max_state,
+ 						sizeof(unsigned long),
  						GFP_KERNEL);
  	devfreq->last_stat_updated = jiffies;
  
diff --cc drivers/gpio/gpio-adnp.c
index e60567fc5073,91b90c0cea73..000000000000
--- a/drivers/gpio/gpio-adnp.c
+++ b/drivers/gpio/gpio-adnp.c
@@@ -454,7 -427,8 +454,12 @@@ static int adnp_irq_setup(struct adnp *
  	 * is chosen to match the register layout of the hardware in that
  	 * each segment contains the corresponding bits for all interrupts.
  	 */
++<<<<<<< HEAD
 +	adnp->irq_enable = devm_kzalloc(chip->dev, num_regs * 6, GFP_KERNEL);
++=======
+ 	adnp->irq_enable = devm_kcalloc(chip->parent, num_regs, 6,
+ 					GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	if (!adnp->irq_enable)
  		return -ENOMEM;
  
diff --cc drivers/gpio/gpio-davinci.c
index 17df6db5dca7,035a454eca43..000000000000
--- a/drivers/gpio/gpio-davinci.c
+++ b/drivers/gpio/gpio-davinci.c
@@@ -152,44 -194,68 +152,52 @@@ static int __init davinci_gpio_setup(vo
  		return -EINVAL;
  	}
  
 -	if (WARN_ON(ARCH_NR_GPIOS < ngpio))
 -		ngpio = ARCH_NR_GPIOS;
 +	if (WARN_ON(DAVINCI_N_GPIO < ngpio))
 +		ngpio = DAVINCI_N_GPIO;
  
++<<<<<<< HEAD
 +	gpio_base = ioremap(soc_info->gpio_base, SZ_4K);
 +	if (WARN_ON(!gpio_base))
++=======
+ 	nbank = DIV_ROUND_UP(ngpio, 32);
+ 	chips = devm_kcalloc(dev,
+ 			     nbank, sizeof(struct davinci_gpio_controller),
+ 			     GFP_KERNEL);
+ 	if (!chips)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
  
 -	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	gpio_base = devm_ioremap_resource(dev, res);
 -	if (IS_ERR(gpio_base))
 -		return PTR_ERR(gpio_base);
 +	for (i = 0, base = 0; base < ngpio; i++, base += 32) {
 +		chips[i].chip.label = "DaVinci";
  
 -	snprintf(label, MAX_LABEL_SIZE, "davinci_gpio.%d", ctrl_num++);
 -	chips->chip.label = devm_kstrdup(dev, label, GFP_KERNEL);
 -		if (!chips->chip.label)
 -			return -ENOMEM;
 +		chips[i].chip.direction_input = davinci_direction_in;
 +		chips[i].chip.get = davinci_gpio_get;
 +		chips[i].chip.direction_output = davinci_direction_out;
 +		chips[i].chip.set = davinci_gpio_set;
  
 -	chips->chip.direction_input = davinci_direction_in;
 -	chips->chip.get = davinci_gpio_get;
 -	chips->chip.direction_output = davinci_direction_out;
 -	chips->chip.set = davinci_gpio_set;
 +		chips[i].chip.base = base;
 +		chips[i].chip.ngpio = ngpio - base;
 +		if (chips[i].chip.ngpio > 32)
 +			chips[i].chip.ngpio = 32;
  
 -	chips->chip.ngpio = ngpio;
 -	chips->chip.base = bank_base;
 +		spin_lock_init(&chips[i].lock);
  
 -#ifdef CONFIG_OF_GPIO
 -	chips->chip.of_gpio_n_cells = 2;
 -	chips->chip.parent = dev;
 -	chips->chip.of_node = dev->of_node;
 +		regs = gpio2regs(base);
 +		chips[i].regs = regs;
 +		chips[i].set_data = &regs->set_data;
 +		chips[i].clr_data = &regs->clr_data;
 +		chips[i].in_data = &regs->in_data;
  
 -	if (of_property_read_bool(dev->of_node, "gpio-ranges")) {
 -		chips->chip.request = gpiochip_generic_request;
 -		chips->chip.free = gpiochip_generic_free;
 +		gpiochip_add(&chips[i].chip);
  	}
 -#endif
 -	spin_lock_init(&chips->lock);
 -	bank_base += ngpio;
 -
 -	for (gpio = 0, bank = 0; gpio < ngpio; gpio += 32, bank++)
 -		chips->regs[bank] = gpio_base + offset_array[bank];
  
 -	ret = devm_gpiochip_add_data(dev, &chips->chip, chips);
 -	if (ret)
 -		goto err;
 -
 -	platform_set_drvdata(pdev, chips);
 -	ret = davinci_gpio_irq_setup(pdev);
 -	if (ret)
 -		goto err;
 +	soc_info->gpio_ctlrs = chips;
 +	soc_info->gpio_ctlrs_num = DIV_ROUND_UP(ngpio, 32);
  
 +	davinci_gpio_irq_setup();
  	return 0;
 -
 -err:
 -	/* Revert the static variable increments */
 -	ctrl_num--;
 -	bank_base -= ngpio;
 -
 -	return ret;
  }
 +pure_initcall(davinci_gpio_setup);
  
  /*--------------------------------------------------------------------------*/
  /*
diff --cc drivers/gpu/drm/exynos/exynos_drm_fimc.c
index 5b18b5c5fdf2,6127ef25acd6..000000000000
--- a/drivers/gpu/drm/exynos/exynos_drm_fimc.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_fimc.c
@@@ -1644,18 -1266,51 +1644,27 @@@ static int fimc_probe(struct platform_d
  	if (!ctx)
  		return -ENOMEM;
  
 -	ctx->dev = dev;
 -	ctx->id = of_alias_get_id(dev->of_node, "fimc");
 +	ctx->ippdrv.dev = dev;
  
++<<<<<<< HEAD
 +	ret = fimc_parse_dt(ctx);
 +	if (ret < 0)
 +		return ret;
++=======
+ 	/* construct formats/limits array */
+ 	num_formats = ARRAY_SIZE(fimc_formats) + ARRAY_SIZE(fimc_tiled_formats);
+ 	formats = devm_kcalloc(dev, num_formats, sizeof(*formats),
+ 			       GFP_KERNEL);
+ 	if (!formats)
+ 		return -ENOMEM;
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  
 -	/* linear formats */
 -	if (ctx->id < 3) {
 -		limits = fimc_4210_limits_v1;
 -		num_limits = ARRAY_SIZE(fimc_4210_limits_v1);
 -	} else {
 -		limits = fimc_4210_limits_v2;
 -		num_limits = ARRAY_SIZE(fimc_4210_limits_v2);
 -	}
 -	for (i = 0; i < ARRAY_SIZE(fimc_formats); i++) {
 -		formats[i].fourcc = fimc_formats[i];
 -		formats[i].type = DRM_EXYNOS_IPP_FORMAT_SOURCE |
 -				  DRM_EXYNOS_IPP_FORMAT_DESTINATION;
 -		formats[i].limits = limits;
 -		formats[i].num_limits = num_limits;
 -	}
 -
 -	/* tiled formats */
 -	if (ctx->id < 3) {
 -		limits = fimc_4210_limits_tiled_v1;
 -		num_limits = ARRAY_SIZE(fimc_4210_limits_tiled_v1);
 -	} else {
 -		limits = fimc_4210_limits_tiled_v2;
 -		num_limits = ARRAY_SIZE(fimc_4210_limits_tiled_v2);
 +	ctx->sysreg = syscon_regmap_lookup_by_phandle(dev->of_node,
 +						"samsung,sysreg");
 +	if (IS_ERR(ctx->sysreg)) {
 +		dev_err(dev, "syscon regmap lookup failed.\n");
 +		return PTR_ERR(ctx->sysreg);
  	}
 -	for (j = i, i = 0; i < ARRAY_SIZE(fimc_tiled_formats); j++, i++) {
 -		formats[j].fourcc = fimc_tiled_formats[i];
 -		formats[j].modifier = DRM_FORMAT_MOD_SAMSUNG_64_32_TILE;
 -		formats[j].type = DRM_EXYNOS_IPP_FORMAT_SOURCE |
 -				  DRM_EXYNOS_IPP_FORMAT_DESTINATION;
 -		formats[j].limits = limits;
 -		formats[j].num_limits = num_limits;
 -	}
 -
 -	ctx->formats = formats;
 -	ctx->num_formats = num_formats;
  
  	/* resource memory */
  	ctx->regs_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
diff --cc drivers/gpu/drm/exynos/exynos_drm_gsc.c
index 0506b2b17ac1,35ac66730563..000000000000
--- a/drivers/gpu/drm/exynos/exynos_drm_gsc.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_gsc.c
@@@ -1669,20 -1202,35 +1669,40 @@@ static int gsc_probe(struct platform_de
  	if (!ctx)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	if (dev->of_node) {
 +		ctx->sysreg = syscon_regmap_lookup_by_phandle(dev->of_node,
 +							"samsung,sysreg");
 +		if (IS_ERR(ctx->sysreg)) {
 +			dev_warn(dev, "failed to get system register.\n");
 +			ctx->sysreg = NULL;
 +		}
++=======
+ 	formats = devm_kcalloc(dev,
+ 			       ARRAY_SIZE(gsc_formats), sizeof(*formats),
+ 			       GFP_KERNEL);
+ 	if (!formats)
+ 		return -ENOMEM;
+ 
+ 	driver_data = (struct gsc_driverdata *)of_device_get_match_data(dev);
+ 	ctx->dev = dev;
+ 	ctx->num_clocks = driver_data->num_clocks;
+ 	ctx->clk_names = driver_data->clk_names;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(gsc_formats); i++) {
+ 		formats[i].fourcc = gsc_formats[i];
+ 		formats[i].type = DRM_EXYNOS_IPP_FORMAT_SOURCE |
+ 				  DRM_EXYNOS_IPP_FORMAT_DESTINATION;
+ 		formats[i].limits = driver_data->limits;
+ 		formats[i].num_limits = driver_data->num_limits;
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	}
 -	ctx->formats = formats;
 -	ctx->num_formats = ARRAY_SIZE(gsc_formats);
  
  	/* clock control */
 -	for (i = 0; i < ctx->num_clocks; i++) {
 -		ctx->clocks[i] = devm_clk_get(dev, ctx->clk_names[i]);
 -		if (IS_ERR(ctx->clocks[i])) {
 -			dev_err(dev, "failed to get clock: %s\n",
 -				ctx->clk_names[i]);
 -			return PTR_ERR(ctx->clocks[i]);
 -		}
 +	ctx->gsc_clk = devm_clk_get(dev, "gscl");
 +	if (IS_ERR(ctx->gsc_clk)) {
 +		dev_err(dev, "failed to get gsc clock.\n");
 +		return PTR_ERR(ctx->gsc_clk);
  	}
  
  	/* resource memory */
diff --cc drivers/hid/wacom_sys.c
index 22459d6debf8,c101369b51de..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1116,6 -1230,225 +1116,228 @@@ static int wacom_devm_sysfs_create_grou
  					       group);
  }
  
++<<<<<<< HEAD
++=======
+ enum led_brightness wacom_leds_brightness_get(struct wacom_led *led)
+ {
+ 	struct wacom *wacom = led->wacom;
+ 
+ 	if (wacom->led.max_hlv)
+ 		return led->hlv * LED_FULL / wacom->led.max_hlv;
+ 
+ 	if (wacom->led.max_llv)
+ 		return led->llv * LED_FULL / wacom->led.max_llv;
+ 
+ 	/* device doesn't support brightness tuning */
+ 	return LED_FULL;
+ }
+ 
+ static enum led_brightness __wacom_led_brightness_get(struct led_classdev *cdev)
+ {
+ 	struct wacom_led *led = container_of(cdev, struct wacom_led, cdev);
+ 	struct wacom *wacom = led->wacom;
+ 
+ 	if (wacom->led.groups[led->group].select != led->id)
+ 		return LED_OFF;
+ 
+ 	return wacom_leds_brightness_get(led);
+ }
+ 
+ static int wacom_led_brightness_set(struct led_classdev *cdev,
+ 				    enum led_brightness brightness)
+ {
+ 	struct wacom_led *led = container_of(cdev, struct wacom_led, cdev);
+ 	struct wacom *wacom = led->wacom;
+ 	int error;
+ 
+ 	mutex_lock(&wacom->lock);
+ 
+ 	if (!wacom->led.groups || (brightness == LED_OFF &&
+ 	    wacom->led.groups[led->group].select != led->id)) {
+ 		error = 0;
+ 		goto out;
+ 	}
+ 
+ 	led->llv = wacom->led.llv = wacom->led.max_llv * brightness / LED_FULL;
+ 	led->hlv = wacom->led.hlv = wacom->led.max_hlv * brightness / LED_FULL;
+ 
+ 	wacom->led.groups[led->group].select = led->id;
+ 
+ 	error = wacom_led_control(wacom);
+ 
+ out:
+ 	mutex_unlock(&wacom->lock);
+ 
+ 	return error;
+ }
+ 
+ static void wacom_led_readonly_brightness_set(struct led_classdev *cdev,
+ 					       enum led_brightness brightness)
+ {
+ }
+ 
+ static int wacom_led_register_one(struct device *dev, struct wacom *wacom,
+ 				  struct wacom_led *led, unsigned int group,
+ 				  unsigned int id, bool read_only)
+ {
+ 	int error;
+ 	char *name;
+ 
+ 	name = devm_kasprintf(dev, GFP_KERNEL,
+ 			      "%s::wacom-%d.%d",
+ 			      dev_name(dev),
+ 			      group,
+ 			      id);
+ 	if (!name)
+ 		return -ENOMEM;
+ 
+ 	if (!read_only) {
+ 		led->trigger.name = name;
+ 		error = devm_led_trigger_register(dev, &led->trigger);
+ 		if (error) {
+ 			hid_err(wacom->hdev,
+ 				"failed to register LED trigger %s: %d\n",
+ 				led->cdev.name, error);
+ 			return error;
+ 		}
+ 	}
+ 
+ 	led->group = group;
+ 	led->id = id;
+ 	led->wacom = wacom;
+ 	led->llv = wacom->led.llv;
+ 	led->hlv = wacom->led.hlv;
+ 	led->cdev.name = name;
+ 	led->cdev.max_brightness = LED_FULL;
+ 	led->cdev.flags = LED_HW_PLUGGABLE;
+ 	led->cdev.brightness_get = __wacom_led_brightness_get;
+ 	if (!read_only) {
+ 		led->cdev.brightness_set_blocking = wacom_led_brightness_set;
+ 		led->cdev.default_trigger = led->cdev.name;
+ 	} else {
+ 		led->cdev.brightness_set = wacom_led_readonly_brightness_set;
+ 	}
+ 
+ 	error = devm_led_classdev_register(dev, &led->cdev);
+ 	if (error) {
+ 		hid_err(wacom->hdev,
+ 			"failed to register LED %s: %d\n",
+ 			led->cdev.name, error);
+ 		led->cdev.name = NULL;
+ 		return error;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_led_groups_release_one(void *data)
+ {
+ 	struct wacom_group_leds *group = data;
+ 
+ 	devres_release_group(group->dev, group);
+ }
+ 
+ static int wacom_led_groups_alloc_and_register_one(struct device *dev,
+ 						   struct wacom *wacom,
+ 						   int group_id, int count,
+ 						   bool read_only)
+ {
+ 	struct wacom_led *leds;
+ 	int i, error;
+ 
+ 	if (group_id >= wacom->led.count || count <= 0)
+ 		return -EINVAL;
+ 
+ 	if (!devres_open_group(dev, &wacom->led.groups[group_id], GFP_KERNEL))
+ 		return -ENOMEM;
+ 
+ 	leds = devm_kcalloc(dev, count, sizeof(struct wacom_led), GFP_KERNEL);
+ 	if (!leds) {
+ 		error = -ENOMEM;
+ 		goto err;
+ 	}
+ 
+ 	wacom->led.groups[group_id].leds = leds;
+ 	wacom->led.groups[group_id].count = count;
+ 
+ 	for (i = 0; i < count; i++) {
+ 		error = wacom_led_register_one(dev, wacom, &leds[i],
+ 					       group_id, i, read_only);
+ 		if (error)
+ 			goto err;
+ 	}
+ 
+ 	wacom->led.groups[group_id].dev = dev;
+ 
+ 	devres_close_group(dev, &wacom->led.groups[group_id]);
+ 
+ 	/*
+ 	 * There is a bug (?) in devm_led_classdev_register() in which its
+ 	 * increments the refcount of the parent. If the parent is an input
+ 	 * device, that means the ref count never reaches 0 when
+ 	 * devm_input_device_release() gets called.
+ 	 * This means that the LEDs are still there after disconnect.
+ 	 * Manually force the release of the group so that the leds are released
+ 	 * once we are done using them.
+ 	 */
+ 	error = devm_add_action_or_reset(&wacom->hdev->dev,
+ 					 wacom_led_groups_release_one,
+ 					 &wacom->led.groups[group_id]);
+ 	if (error)
+ 		return error;
+ 
+ 	return 0;
+ 
+ err:
+ 	devres_release_group(dev, &wacom->led.groups[group_id]);
+ 	return error;
+ }
+ 
+ struct wacom_led *wacom_led_find(struct wacom *wacom, unsigned int group_id,
+ 				 unsigned int id)
+ {
+ 	struct wacom_group_leds *group;
+ 
+ 	if (group_id >= wacom->led.count)
+ 		return NULL;
+ 
+ 	group = &wacom->led.groups[group_id];
+ 
+ 	if (!group->leds)
+ 		return NULL;
+ 
+ 	id %= group->count;
+ 
+ 	return &group->leds[id];
+ }
+ 
+ /**
+  * wacom_led_next: gives the next available led with a wacom trigger.
+  *
+  * returns the next available struct wacom_led which has its default trigger
+  * or the current one if none is available.
+  */
+ struct wacom_led *wacom_led_next(struct wacom *wacom, struct wacom_led *cur)
+ {
+ 	struct wacom_led *next_led;
+ 	int group, next;
+ 
+ 	if (!wacom || !cur)
+ 		return NULL;
+ 
+ 	group = cur->group;
+ 	next = cur->id;
+ 
+ 	do {
+ 		next_led = wacom_led_find(wacom, group, ++next);
+ 		if (!next_led || next_led == cur)
+ 			return next_led;
+ 	} while (next_led->cdev.trigger != &next_led->trigger);
+ 
+ 	return next_led;
+ }
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  static void wacom_led_groups_release(void *data)
  {
  	struct wacom *wacom = data;
@@@ -1128,8 -1462,8 +1350,12 @@@ static int wacom_led_groups_allocate(st
  	struct wacom_group_leds *groups;
  	int error;
  
++<<<<<<< HEAD
 +	groups = devm_kzalloc(&wacom->hdev->dev,
 +			      sizeof(struct wacom_group_leds) * count,
++=======
+ 	groups = devm_kcalloc(dev, count, sizeof(struct wacom_group_leds),
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  			      GFP_KERNEL);
  	if (!groups)
  		return -ENOMEM;
diff --cc drivers/hwmon/gpio-fan.c
index 3104149795c5,a3974cddef07..000000000000
--- a/drivers/hwmon/gpio-fan.c
+++ b/drivers/hwmon/gpio-fan.c
@@@ -404,30 -428,33 +404,37 @@@ static int gpio_fan_get_of_pdata(struc
  	struct property *prop;
  	const __be32 *p;
  
 -	/* Alarm GPIO if one exists */
 -	fan_data->alarm_gpio = devm_gpiod_get_optional(dev, "alarm", GPIOD_IN);
 -	if (IS_ERR(fan_data->alarm_gpio))
 -		return PTR_ERR(fan_data->alarm_gpio);
 +	node = dev->of_node;
  
  	/* Fill GPIO pin array */
 -	fan_data->num_gpios = gpiod_count(dev, NULL);
 -	if (fan_data->num_gpios <= 0) {
 -		if (fan_data->alarm_gpio)
 -			return 0;
 -		dev_err(dev, "DT properties empty / missing");
 +	pdata->num_ctrl = of_gpio_count(node);
 +	if (pdata->num_ctrl <= 0) {
 +		dev_err(dev, "gpios DT property empty / missing");
  		return -ENODEV;
  	}
++<<<<<<< HEAD
 +	ctrl = devm_kzalloc(dev, pdata->num_ctrl * sizeof(unsigned),
 +				GFP_KERNEL);
 +	if (!ctrl)
++=======
+ 	gpios = devm_kcalloc(dev,
+ 			     fan_data->num_gpios, sizeof(struct gpio_desc *),
+ 			     GFP_KERNEL);
+ 	if (!gpios)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 -	for (i = 0; i < fan_data->num_gpios; i++) {
 -		gpios[i] = devm_gpiod_get_index(dev, NULL, i, GPIOD_ASIS);
 -		if (IS_ERR(gpios[i]))
 -			return PTR_ERR(gpios[i]);
 +	for (i = 0; i < pdata->num_ctrl; i++) {
 +		int val;
 +
 +		val = of_get_gpio(node, i);
 +		if (val < 0)
 +			return val;
 +		ctrl[i] = val;
  	}
 -	fan_data->gpios = gpios;
 +	pdata->ctrl = ctrl;
  
  	/* Get number of RPM/ctrl_val pairs in speed map */
 -	prop = of_find_property(np, "gpio-fan,speed-map", &i);
 +	prop = of_find_property(node, "gpio-fan,speed-map", &i);
  	if (!prop) {
  		dev_err(dev, "gpio-fan,speed-map DT property missing");
  		return -ENODEV;
@@@ -444,8 -471,8 +451,13 @@@
  	 * Speed map is in the form <RPM ctrl_val RPM ctrl_val ...>
  	 * this needs splitting into pairs to create gpio_fan_speed structs
  	 */
++<<<<<<< HEAD
 +	speed = devm_kzalloc(dev,
 +			pdata->num_speed * sizeof(struct gpio_fan_speed),
++=======
+ 	speed = devm_kcalloc(dev,
+ 			fan_data->num_speed, sizeof(struct gpio_fan_speed),
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  			GFP_KERNEL);
  	if (!speed)
  		return -ENOMEM;
diff --cc drivers/hwmon/iio_hwmon.c
index 52b77afebde1,69031a0f7ed2..000000000000
--- a/drivers/hwmon/iio_hwmon.c
+++ b/drivers/hwmon/iio_hwmon.c
@@@ -95,8 -92,8 +95,13 @@@ static int iio_hwmon_probe(struct platf
  	while (st->channels[st->num_channels].indio_dev)
  		st->num_channels++;
  
++<<<<<<< HEAD
 +	st->attrs = devm_kzalloc(dev,
 +				 sizeof(*st->attrs) * (st->num_channels + 2),
++=======
+ 	st->attrs = devm_kcalloc(dev,
+ 				 st->num_channels + 1, sizeof(*st->attrs),
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  				 GFP_KERNEL);
  	if (st->attrs == NULL) {
  		ret = -ENOMEM;
diff --cc drivers/hwmon/nct6775.c
index 99cec1825420,155d4d1d1585..000000000000
--- a/drivers/hwmon/nct6775.c
+++ b/drivers/hwmon/nct6775.c
@@@ -688,6 -1108,137 +688,140 @@@ struct nct6775_sio_data 
  	enum kinds kind;
  };
  
++<<<<<<< HEAD
++=======
+ struct sensor_device_template {
+ 	struct device_attribute dev_attr;
+ 	union {
+ 		struct {
+ 			u8 nr;
+ 			u8 index;
+ 		} s;
+ 		int index;
+ 	} u;
+ 	bool s2;	/* true if both index and nr are used */
+ };
+ 
+ struct sensor_device_attr_u {
+ 	union {
+ 		struct sensor_device_attribute a1;
+ 		struct sensor_device_attribute_2 a2;
+ 	} u;
+ 	char name[32];
+ };
+ 
+ #define __TEMPLATE_ATTR(_template, _mode, _show, _store) {	\
+ 	.attr = {.name = _template, .mode = _mode },		\
+ 	.show	= _show,					\
+ 	.store	= _store,					\
+ }
+ 
+ #define SENSOR_DEVICE_TEMPLATE(_template, _mode, _show, _store, _index)	\
+ 	{ .dev_attr = __TEMPLATE_ATTR(_template, _mode, _show, _store),	\
+ 	  .u.index = _index,						\
+ 	  .s2 = false }
+ 
+ #define SENSOR_DEVICE_TEMPLATE_2(_template, _mode, _show, _store,	\
+ 				 _nr, _index)				\
+ 	{ .dev_attr = __TEMPLATE_ATTR(_template, _mode, _show, _store),	\
+ 	  .u.s.index = _index,						\
+ 	  .u.s.nr = _nr,						\
+ 	  .s2 = true }
+ 
+ #define SENSOR_TEMPLATE(_name, _template, _mode, _show, _store, _index)	\
+ static struct sensor_device_template sensor_dev_template_##_name	\
+ 	= SENSOR_DEVICE_TEMPLATE(_template, _mode, _show, _store,	\
+ 				 _index)
+ 
+ #define SENSOR_TEMPLATE_2(_name, _template, _mode, _show, _store,	\
+ 			  _nr, _index)					\
+ static struct sensor_device_template sensor_dev_template_##_name	\
+ 	= SENSOR_DEVICE_TEMPLATE_2(_template, _mode, _show, _store,	\
+ 				 _nr, _index)
+ 
+ struct sensor_template_group {
+ 	struct sensor_device_template **templates;
+ 	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
+ 	int base;
+ };
+ 
+ static struct attribute_group *
+ nct6775_create_attr_group(struct device *dev,
+ 			  const struct sensor_template_group *tg,
+ 			  int repeat)
+ {
+ 	struct attribute_group *group;
+ 	struct sensor_device_attr_u *su;
+ 	struct sensor_device_attribute *a;
+ 	struct sensor_device_attribute_2 *a2;
+ 	struct attribute **attrs;
+ 	struct sensor_device_template **t;
+ 	int i, count;
+ 
+ 	if (repeat <= 0)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	t = tg->templates;
+ 	for (count = 0; *t; t++, count++)
+ 		;
+ 
+ 	if (count == 0)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	group = devm_kzalloc(dev, sizeof(*group), GFP_KERNEL);
+ 	if (group == NULL)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	attrs = devm_kcalloc(dev, repeat * count + 1, sizeof(*attrs),
+ 			     GFP_KERNEL);
+ 	if (attrs == NULL)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	su = devm_kzalloc(dev, array3_size(repeat, count, sizeof(*su)),
+ 			       GFP_KERNEL);
+ 	if (su == NULL)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	group->attrs = attrs;
+ 	group->is_visible = tg->is_visible;
+ 
+ 	for (i = 0; i < repeat; i++) {
+ 		t = tg->templates;
+ 		while (*t != NULL) {
+ 			snprintf(su->name, sizeof(su->name),
+ 				 (*t)->dev_attr.attr.name, tg->base + i);
+ 			if ((*t)->s2) {
+ 				a2 = &su->u.a2;
+ 				sysfs_attr_init(&a2->dev_attr.attr);
+ 				a2->dev_attr.attr.name = su->name;
+ 				a2->nr = (*t)->u.s.nr + i;
+ 				a2->index = (*t)->u.s.index;
+ 				a2->dev_attr.attr.mode =
+ 				  (*t)->dev_attr.attr.mode;
+ 				a2->dev_attr.show = (*t)->dev_attr.show;
+ 				a2->dev_attr.store = (*t)->dev_attr.store;
+ 				*attrs = &a2->dev_attr.attr;
+ 			} else {
+ 				a = &su->u.a1;
+ 				sysfs_attr_init(&a->dev_attr.attr);
+ 				a->dev_attr.attr.name = su->name;
+ 				a->index = (*t)->u.index + i;
+ 				a->dev_attr.attr.mode =
+ 				  (*t)->dev_attr.attr.mode;
+ 				a->dev_attr.show = (*t)->dev_attr.show;
+ 				a->dev_attr.store = (*t)->dev_attr.store;
+ 				*attrs = &a->dev_attr.attr;
+ 			}
+ 			attrs++;
+ 			su++;
+ 			t++;
+ 		}
+ 	}
+ 
+ 	return group;
+ }
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  static bool is_word_sized(struct nct6775_data *data, u16 reg)
  {
  	switch (data->kind) {
diff --cc drivers/hwmon/pmbus/pmbus_core.c
index 9add60920ac0,82c3754e21e3..000000000000
--- a/drivers/hwmon/pmbus/pmbus_core.c
+++ b/drivers/hwmon/pmbus/pmbus_core.c
@@@ -1714,13 -2030,271 +1714,200 @@@ static int pmbus_init_common(struct i2c
  		return -ENODEV;
  	}
  
 -	for (page = 0; page < info->pages; page++) {
 -		ret = pmbus_identify_common(client, data, page);
 -		if (ret < 0) {
 -			dev_err(dev, "Failed to identify chip capabilities\n");
 -			return ret;
 -		}
 -	}
 -	return 0;
 -}
 -
 -#if IS_ENABLED(CONFIG_REGULATOR)
 -static int pmbus_regulator_is_enabled(struct regulator_dev *rdev)
 -{
 -	struct device *dev = rdev_get_dev(rdev);
 -	struct i2c_client *client = to_i2c_client(dev->parent);
 -	u8 page = rdev_get_id(rdev);
 -	int ret;
 -
 -	ret = pmbus_read_byte_data(client, page, PMBUS_OPERATION);
 -	if (ret < 0)
 +	ret = pmbus_identify_common(client, data);
 +	if (ret < 0) {
 +		dev_err(dev, "Failed to identify chip capabilities\n");
  		return ret;
 -
 -	return !!(ret & PB_OPERATION_CONTROL_ON);
 -}
 -
 -static int _pmbus_regulator_on_off(struct regulator_dev *rdev, bool enable)
 -{
 -	struct device *dev = rdev_get_dev(rdev);
 -	struct i2c_client *client = to_i2c_client(dev->parent);
 -	u8 page = rdev_get_id(rdev);
 -
 -	return pmbus_update_byte_data(client, page, PMBUS_OPERATION,
 -				      PB_OPERATION_CONTROL_ON,
 -				      enable ? PB_OPERATION_CONTROL_ON : 0);
 -}
 -
 -static int pmbus_regulator_enable(struct regulator_dev *rdev)
 -{
 -	return _pmbus_regulator_on_off(rdev, 1);
 -}
 -
 -static int pmbus_regulator_disable(struct regulator_dev *rdev)
 -{
 -	return _pmbus_regulator_on_off(rdev, 0);
 -}
 -
 -const struct regulator_ops pmbus_regulator_ops = {
 -	.enable = pmbus_regulator_enable,
 -	.disable = pmbus_regulator_disable,
 -	.is_enabled = pmbus_regulator_is_enabled,
 -};
 -EXPORT_SYMBOL_GPL(pmbus_regulator_ops);
 -
 -static int pmbus_regulator_register(struct pmbus_data *data)
 -{
 -	struct device *dev = data->dev;
 -	const struct pmbus_driver_info *info = data->info;
 -	const struct pmbus_platform_data *pdata = dev_get_platdata(dev);
 -	struct regulator_dev *rdev;
 -	int i;
 -
 -	for (i = 0; i < info->num_regulators; i++) {
 -		struct regulator_config config = { };
 -
 -		config.dev = dev;
 -		config.driver_data = data;
 -
 -		if (pdata && pdata->reg_init_data)
 -			config.init_data = &pdata->reg_init_data[i];
 -
 -		rdev = devm_regulator_register(dev, &info->reg_desc[i],
 -					       &config);
 -		if (IS_ERR(rdev)) {
 -			dev_err(dev, "Failed to register %s regulator\n",
 -				info->reg_desc[i].name);
 -			return PTR_ERR(rdev);
 -		}
  	}
 -
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ #else
+ static int pmbus_regulator_register(struct pmbus_data *data)
+ {
+ 	return 0;
+ }
+ #endif
+ 
+ static struct dentry *pmbus_debugfs_dir;	/* pmbus debugfs directory */
+ 
+ #if IS_ENABLED(CONFIG_DEBUG_FS)
+ static int pmbus_debugfs_get(void *data, u64 *val)
+ {
+ 	int rc;
+ 	struct pmbus_debugfs_entry *entry = data;
+ 
+ 	rc = _pmbus_read_byte_data(entry->client, entry->page, entry->reg);
+ 	if (rc < 0)
+ 		return rc;
+ 
+ 	*val = rc;
+ 
+ 	return 0;
+ }
+ DEFINE_DEBUGFS_ATTRIBUTE(pmbus_debugfs_ops, pmbus_debugfs_get, NULL,
+ 			 "0x%02llx\n");
+ 
+ static int pmbus_debugfs_get_status(void *data, u64 *val)
+ {
+ 	int rc;
+ 	struct pmbus_debugfs_entry *entry = data;
+ 	struct pmbus_data *pdata = i2c_get_clientdata(entry->client);
+ 
+ 	rc = pdata->read_status(entry->client, entry->page);
+ 	if (rc < 0)
+ 		return rc;
+ 
+ 	*val = rc;
+ 
+ 	return 0;
+ }
+ DEFINE_DEBUGFS_ATTRIBUTE(pmbus_debugfs_ops_status, pmbus_debugfs_get_status,
+ 			 NULL, "0x%04llx\n");
+ 
+ static int pmbus_init_debugfs(struct i2c_client *client,
+ 			      struct pmbus_data *data)
+ {
+ 	int i, idx = 0;
+ 	char name[PMBUS_NAME_SIZE];
+ 	struct pmbus_debugfs_entry *entries;
+ 
+ 	if (!pmbus_debugfs_dir)
+ 		return -ENODEV;
+ 
+ 	/*
+ 	 * Create the debugfs directory for this device. Use the hwmon device
+ 	 * name to avoid conflicts (hwmon numbers are globally unique).
+ 	 */
+ 	data->debugfs = debugfs_create_dir(dev_name(data->hwmon_dev),
+ 					   pmbus_debugfs_dir);
+ 	if (IS_ERR_OR_NULL(data->debugfs)) {
+ 		data->debugfs = NULL;
+ 		return -ENODEV;
+ 	}
+ 
+ 	/* Allocate the max possible entries we need. */
+ 	entries = devm_kcalloc(data->dev,
+ 			       data->info->pages * 10, sizeof(*entries),
+ 			       GFP_KERNEL);
+ 	if (!entries)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < data->info->pages; ++i) {
+ 		/* Check accessibility of status register if it's not page 0 */
+ 		if (!i || pmbus_check_status_register(client, i)) {
+ 			/* No need to set reg as we have special read op. */
+ 			entries[idx].client = client;
+ 			entries[idx].page = i;
+ 			scnprintf(name, PMBUS_NAME_SIZE, "status%d", i);
+ 			debugfs_create_file(name, 0444, data->debugfs,
+ 					    &entries[idx++],
+ 					    &pmbus_debugfs_ops_status);
+ 		}
+ 
+ 		if (data->info->func[i] & PMBUS_HAVE_STATUS_VOUT) {
+ 			entries[idx].client = client;
+ 			entries[idx].page = i;
+ 			entries[idx].reg = PMBUS_STATUS_VOUT;
+ 			scnprintf(name, PMBUS_NAME_SIZE, "status%d_vout", i);
+ 			debugfs_create_file(name, 0444, data->debugfs,
+ 					    &entries[idx++],
+ 					    &pmbus_debugfs_ops);
+ 		}
+ 
+ 		if (data->info->func[i] & PMBUS_HAVE_STATUS_IOUT) {
+ 			entries[idx].client = client;
+ 			entries[idx].page = i;
+ 			entries[idx].reg = PMBUS_STATUS_IOUT;
+ 			scnprintf(name, PMBUS_NAME_SIZE, "status%d_iout", i);
+ 			debugfs_create_file(name, 0444, data->debugfs,
+ 					    &entries[idx++],
+ 					    &pmbus_debugfs_ops);
+ 		}
+ 
+ 		if (data->info->func[i] & PMBUS_HAVE_STATUS_INPUT) {
+ 			entries[idx].client = client;
+ 			entries[idx].page = i;
+ 			entries[idx].reg = PMBUS_STATUS_INPUT;
+ 			scnprintf(name, PMBUS_NAME_SIZE, "status%d_input", i);
+ 			debugfs_create_file(name, 0444, data->debugfs,
+ 					    &entries[idx++],
+ 					    &pmbus_debugfs_ops);
+ 		}
+ 
+ 		if (data->info->func[i] & PMBUS_HAVE_STATUS_TEMP) {
+ 			entries[idx].client = client;
+ 			entries[idx].page = i;
+ 			entries[idx].reg = PMBUS_STATUS_TEMPERATURE;
+ 			scnprintf(name, PMBUS_NAME_SIZE, "status%d_temp", i);
+ 			debugfs_create_file(name, 0444, data->debugfs,
+ 					    &entries[idx++],
+ 					    &pmbus_debugfs_ops);
+ 		}
+ 
+ 		if (pmbus_check_byte_register(client, i, PMBUS_STATUS_CML)) {
+ 			entries[idx].client = client;
+ 			entries[idx].page = i;
+ 			entries[idx].reg = PMBUS_STATUS_CML;
+ 			scnprintf(name, PMBUS_NAME_SIZE, "status%d_cml", i);
+ 			debugfs_create_file(name, 0444, data->debugfs,
+ 					    &entries[idx++],
+ 					    &pmbus_debugfs_ops);
+ 		}
+ 
+ 		if (pmbus_check_byte_register(client, i, PMBUS_STATUS_OTHER)) {
+ 			entries[idx].client = client;
+ 			entries[idx].page = i;
+ 			entries[idx].reg = PMBUS_STATUS_OTHER;
+ 			scnprintf(name, PMBUS_NAME_SIZE, "status%d_other", i);
+ 			debugfs_create_file(name, 0444, data->debugfs,
+ 					    &entries[idx++],
+ 					    &pmbus_debugfs_ops);
+ 		}
+ 
+ 		if (pmbus_check_byte_register(client, i,
+ 					      PMBUS_STATUS_MFR_SPECIFIC)) {
+ 			entries[idx].client = client;
+ 			entries[idx].page = i;
+ 			entries[idx].reg = PMBUS_STATUS_MFR_SPECIFIC;
+ 			scnprintf(name, PMBUS_NAME_SIZE, "status%d_mfr", i);
+ 			debugfs_create_file(name, 0444, data->debugfs,
+ 					    &entries[idx++],
+ 					    &pmbus_debugfs_ops);
+ 		}
+ 
+ 		if (data->info->func[i] & PMBUS_HAVE_STATUS_FAN12) {
+ 			entries[idx].client = client;
+ 			entries[idx].page = i;
+ 			entries[idx].reg = PMBUS_STATUS_FAN_12;
+ 			scnprintf(name, PMBUS_NAME_SIZE, "status%d_fan12", i);
+ 			debugfs_create_file(name, 0444, data->debugfs,
+ 					    &entries[idx++],
+ 					    &pmbus_debugfs_ops);
+ 		}
+ 
+ 		if (data->info->func[i] & PMBUS_HAVE_STATUS_FAN34) {
+ 			entries[idx].client = client;
+ 			entries[idx].page = i;
+ 			entries[idx].reg = PMBUS_STATUS_FAN_34;
+ 			scnprintf(name, PMBUS_NAME_SIZE, "status%d_fan34", i);
+ 			debugfs_create_file(name, 0444, data->debugfs,
+ 					    &entries[idx++],
+ 					    &pmbus_debugfs_ops);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ #else
+ static int pmbus_init_debugfs(struct i2c_client *client,
+ 			      struct pmbus_data *data)
+ {
+ 	return 0;
+ }
+ #endif	/* IS_ENABLED(CONFIG_DEBUG_FS) */
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  
  int pmbus_do_probe(struct i2c_client *client, const struct i2c_device_id *id,
  		   struct pmbus_driver_info *info)
diff --cc drivers/hwmon/pmbus/ucd9000.c
index fbb1479d3ad4,ae93885fccd8..000000000000
--- a/drivers/hwmon/pmbus/ucd9000.c
+++ b/drivers/hwmon/pmbus/ucd9000.c
@@@ -118,6 -151,341 +118,344 @@@ static const struct i2c_device_id ucd90
  };
  MODULE_DEVICE_TABLE(i2c, ucd9000_id);
  
++<<<<<<< HEAD
++=======
+ static const struct of_device_id ucd9000_of_match[] = {
+ 	{
+ 		.compatible = "ti,ucd9000",
+ 		.data = (void *)ucd9000
+ 	},
+ 	{
+ 		.compatible = "ti,ucd90120",
+ 		.data = (void *)ucd90120
+ 	},
+ 	{
+ 		.compatible = "ti,ucd90124",
+ 		.data = (void *)ucd90124
+ 	},
+ 	{
+ 		.compatible = "ti,ucd90160",
+ 		.data = (void *)ucd90160
+ 	},
+ 	{
+ 		.compatible = "ti,ucd9090",
+ 		.data = (void *)ucd9090
+ 	},
+ 	{
+ 		.compatible = "ti,ucd90910",
+ 		.data = (void *)ucd90910
+ 	},
+ 	{ },
+ };
+ MODULE_DEVICE_TABLE(of, ucd9000_of_match);
+ 
+ #ifdef CONFIG_GPIOLIB
+ static int ucd9000_gpio_read_config(struct i2c_client *client,
+ 				    unsigned int offset)
+ {
+ 	int ret;
+ 
+ 	/* No page set required */
+ 	ret = i2c_smbus_write_byte_data(client, UCD9000_GPIO_SELECT, offset);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return i2c_smbus_read_byte_data(client, UCD9000_GPIO_CONFIG);
+ }
+ 
+ static int ucd9000_gpio_get(struct gpio_chip *gc, unsigned int offset)
+ {
+ 	struct i2c_client *client  = gpiochip_get_data(gc);
+ 	int ret;
+ 
+ 	ret = ucd9000_gpio_read_config(client, offset);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return !!(ret & UCD9000_GPIO_CONFIG_STATUS);
+ }
+ 
+ static void ucd9000_gpio_set(struct gpio_chip *gc, unsigned int offset,
+ 			     int value)
+ {
+ 	struct i2c_client *client = gpiochip_get_data(gc);
+ 	int ret;
+ 
+ 	ret = ucd9000_gpio_read_config(client, offset);
+ 	if (ret < 0) {
+ 		dev_dbg(&client->dev, "failed to read GPIO %d config: %d\n",
+ 			offset, ret);
+ 		return;
+ 	}
+ 
+ 	if (value) {
+ 		if (ret & UCD9000_GPIO_CONFIG_STATUS)
+ 			return;
+ 
+ 		ret |= UCD9000_GPIO_CONFIG_STATUS;
+ 	} else {
+ 		if (!(ret & UCD9000_GPIO_CONFIG_STATUS))
+ 			return;
+ 
+ 		ret &= ~UCD9000_GPIO_CONFIG_STATUS;
+ 	}
+ 
+ 	ret |= UCD9000_GPIO_CONFIG_ENABLE;
+ 
+ 	/* Page set not required */
+ 	ret = i2c_smbus_write_byte_data(client, UCD9000_GPIO_CONFIG, ret);
+ 	if (ret < 0) {
+ 		dev_dbg(&client->dev, "Failed to write GPIO %d config: %d\n",
+ 			offset, ret);
+ 		return;
+ 	}
+ 
+ 	ret &= ~UCD9000_GPIO_CONFIG_ENABLE;
+ 
+ 	ret = i2c_smbus_write_byte_data(client, UCD9000_GPIO_CONFIG, ret);
+ 	if (ret < 0)
+ 		dev_dbg(&client->dev, "Failed to write GPIO %d config: %d\n",
+ 			offset, ret);
+ }
+ 
+ static int ucd9000_gpio_get_direction(struct gpio_chip *gc,
+ 				      unsigned int offset)
+ {
+ 	struct i2c_client *client = gpiochip_get_data(gc);
+ 	int ret;
+ 
+ 	ret = ucd9000_gpio_read_config(client, offset);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return !(ret & UCD9000_GPIO_CONFIG_OUT_ENABLE);
+ }
+ 
+ static int ucd9000_gpio_set_direction(struct gpio_chip *gc,
+ 				      unsigned int offset, bool direction_out,
+ 				      int requested_out)
+ {
+ 	struct i2c_client *client = gpiochip_get_data(gc);
+ 	int ret, config, out_val;
+ 
+ 	ret = ucd9000_gpio_read_config(client, offset);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (direction_out) {
+ 		out_val = requested_out ? UCD9000_GPIO_CONFIG_OUT_VALUE : 0;
+ 
+ 		if (ret & UCD9000_GPIO_CONFIG_OUT_ENABLE) {
+ 			if ((ret & UCD9000_GPIO_CONFIG_OUT_VALUE) == out_val)
+ 				return 0;
+ 		} else {
+ 			ret |= UCD9000_GPIO_CONFIG_OUT_ENABLE;
+ 		}
+ 
+ 		if (out_val)
+ 			ret |= UCD9000_GPIO_CONFIG_OUT_VALUE;
+ 		else
+ 			ret &= ~UCD9000_GPIO_CONFIG_OUT_VALUE;
+ 
+ 	} else {
+ 		if (!(ret & UCD9000_GPIO_CONFIG_OUT_ENABLE))
+ 			return 0;
+ 
+ 		ret &= ~UCD9000_GPIO_CONFIG_OUT_ENABLE;
+ 	}
+ 
+ 	ret |= UCD9000_GPIO_CONFIG_ENABLE;
+ 	config = ret;
+ 
+ 	/* Page set not required */
+ 	ret = i2c_smbus_write_byte_data(client, UCD9000_GPIO_CONFIG, config);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	config &= ~UCD9000_GPIO_CONFIG_ENABLE;
+ 
+ 	return i2c_smbus_write_byte_data(client, UCD9000_GPIO_CONFIG, config);
+ }
+ 
+ static int ucd9000_gpio_direction_input(struct gpio_chip *gc,
+ 					unsigned int offset)
+ {
+ 	return ucd9000_gpio_set_direction(gc, offset, UCD9000_GPIO_INPUT, 0);
+ }
+ 
+ static int ucd9000_gpio_direction_output(struct gpio_chip *gc,
+ 					 unsigned int offset, int val)
+ {
+ 	return ucd9000_gpio_set_direction(gc, offset, UCD9000_GPIO_OUTPUT,
+ 					  val);
+ }
+ 
+ static void ucd9000_probe_gpio(struct i2c_client *client,
+ 			       const struct i2c_device_id *mid,
+ 			       struct ucd9000_data *data)
+ {
+ 	int rc;
+ 
+ 	switch (mid->driver_data) {
+ 	case ucd9090:
+ 		data->gpio.ngpio = UCD9090_NUM_GPIOS;
+ 		break;
+ 	case ucd90120:
+ 	case ucd90124:
+ 	case ucd90160:
+ 		data->gpio.ngpio = UCD901XX_NUM_GPIOS;
+ 		break;
+ 	case ucd90910:
+ 		data->gpio.ngpio = UCD90910_NUM_GPIOS;
+ 		break;
+ 	default:
+ 		return; /* GPIO support is optional. */
+ 	}
+ 
+ 	/*
+ 	 * Pinmux support has not been added to the new gpio_chip.
+ 	 * This support should be added when possible given the mux
+ 	 * behavior of these IO devices.
+ 	 */
+ 	data->gpio.label = client->name;
+ 	data->gpio.get_direction = ucd9000_gpio_get_direction;
+ 	data->gpio.direction_input = ucd9000_gpio_direction_input;
+ 	data->gpio.direction_output = ucd9000_gpio_direction_output;
+ 	data->gpio.get = ucd9000_gpio_get;
+ 	data->gpio.set = ucd9000_gpio_set;
+ 	data->gpio.can_sleep = true;
+ 	data->gpio.base = -1;
+ 	data->gpio.parent = &client->dev;
+ 
+ 	rc = devm_gpiochip_add_data(&client->dev, &data->gpio, client);
+ 	if (rc)
+ 		dev_warn(&client->dev, "Could not add gpiochip: %d\n", rc);
+ }
+ #else
+ static void ucd9000_probe_gpio(struct i2c_client *client,
+ 			       const struct i2c_device_id *mid,
+ 			       struct ucd9000_data *data)
+ {
+ }
+ #endif /* CONFIG_GPIOLIB */
+ 
+ #ifdef CONFIG_DEBUG_FS
+ static int ucd9000_get_mfr_status(struct i2c_client *client, u8 *buffer)
+ {
+ 	int ret = pmbus_set_page(client, 0);
+ 
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return i2c_smbus_read_block_data(client, UCD9000_MFR_STATUS, buffer);
+ }
+ 
+ static int ucd9000_debugfs_show_mfr_status_bit(void *data, u64 *val)
+ {
+ 	struct ucd9000_debugfs_entry *entry = data;
+ 	struct i2c_client *client = entry->client;
+ 	u8 buffer[I2C_SMBUS_BLOCK_MAX];
+ 	int ret;
+ 
+ 	ret = ucd9000_get_mfr_status(client, buffer);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	/*
+ 	 * Attribute only created for devices with gpi fault bits at bits
+ 	 * 16-23, which is the second byte of the response.
+ 	 */
+ 	*val = !!(buffer[1] & BIT(entry->index));
+ 
+ 	return 0;
+ }
+ DEFINE_DEBUGFS_ATTRIBUTE(ucd9000_debugfs_mfr_status_bit,
+ 			 ucd9000_debugfs_show_mfr_status_bit, NULL, "%1lld\n");
+ 
+ static ssize_t ucd9000_debugfs_read_mfr_status(struct file *file,
+ 					       char __user *buf, size_t count,
+ 					       loff_t *ppos)
+ {
+ 	struct i2c_client *client = file->private_data;
+ 	u8 buffer[I2C_SMBUS_BLOCK_MAX];
+ 	char str[(I2C_SMBUS_BLOCK_MAX * 2) + 2];
+ 	char *res;
+ 	int rc;
+ 
+ 	rc = ucd9000_get_mfr_status(client, buffer);
+ 	if (rc < 0)
+ 		return rc;
+ 
+ 	res = bin2hex(str, buffer, min(rc, I2C_SMBUS_BLOCK_MAX));
+ 	*res++ = '\n';
+ 	*res = 0;
+ 
+ 	return simple_read_from_buffer(buf, count, ppos, str, res - str);
+ }
+ 
+ static const struct file_operations ucd9000_debugfs_show_mfr_status_fops = {
+ 	.llseek = noop_llseek,
+ 	.read = ucd9000_debugfs_read_mfr_status,
+ 	.open = simple_open,
+ };
+ 
+ static int ucd9000_init_debugfs(struct i2c_client *client,
+ 				const struct i2c_device_id *mid,
+ 				struct ucd9000_data *data)
+ {
+ 	struct dentry *debugfs;
+ 	struct ucd9000_debugfs_entry *entries;
+ 	int i;
+ 	char name[UCD9000_DEBUGFS_NAME_LEN];
+ 
+ 	debugfs = pmbus_get_debugfs_dir(client);
+ 	if (!debugfs)
+ 		return -ENOENT;
+ 
+ 	data->debugfs = debugfs_create_dir(client->name, debugfs);
+ 	if (!data->debugfs)
+ 		return -ENOENT;
+ 
+ 	/*
+ 	 * Of the chips this driver supports, only the UCD9090, UCD90160,
+ 	 * and UCD90910 report GPI faults in their MFR_STATUS register, so only
+ 	 * create the GPI fault debugfs attributes for those chips.
+ 	 */
+ 	if (mid->driver_data == ucd9090 || mid->driver_data == ucd90160 ||
+ 	    mid->driver_data == ucd90910) {
+ 		entries = devm_kcalloc(&client->dev,
+ 				       UCD9000_GPI_COUNT, sizeof(*entries),
+ 				       GFP_KERNEL);
+ 		if (!entries)
+ 			return -ENOMEM;
+ 
+ 		for (i = 0; i < UCD9000_GPI_COUNT; i++) {
+ 			entries[i].client = client;
+ 			entries[i].index = i;
+ 			scnprintf(name, UCD9000_DEBUGFS_NAME_LEN,
+ 				  "gpi%d_alarm", i + 1);
+ 			debugfs_create_file(name, 0444, data->debugfs,
+ 					    &entries[i],
+ 					    &ucd9000_debugfs_mfr_status_bit);
+ 		}
+ 	}
+ 
+ 	scnprintf(name, UCD9000_DEBUGFS_NAME_LEN, "mfr_status");
+ 	debugfs_create_file(name, 0444, data->debugfs, client,
+ 			    &ucd9000_debugfs_show_mfr_status_fops);
+ 
+ 	return 0;
+ }
+ #else
+ static int ucd9000_init_debugfs(struct i2c_client *client,
+ 				const struct i2c_device_id *mid,
+ 				struct ucd9000_data *data)
+ {
+ 	return 0;
+ }
+ #endif /* CONFIG_DEBUG_FS */
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  static int ucd9000_probe(struct i2c_client *client,
  			 const struct i2c_device_id *id)
  {
diff --cc drivers/iio/adc/at91_adc.c
index ab552510543f,44b516863c9d..000000000000
--- a/drivers/iio/adc/at91_adc.c
+++ b/drivers/iio/adc/at91_adc.c
@@@ -273,8 -624,8 +273,13 @@@ static int at91_adc_trigger_init(struc
  	struct at91_adc_state *st = iio_priv(idev);
  	int i, ret;
  
++<<<<<<< HEAD
 +	st->trig = devm_kzalloc(&idev->dev,
 +				st->trigger_number * sizeof(st->trig),
++=======
+ 	st->trig = devm_kcalloc(&idev->dev,
+ 				st->trigger_number, sizeof(*st->trig),
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  				GFP_KERNEL);
  
  	if (st->trig == NULL) {
@@@ -481,45 -905,11 +486,46 @@@ static int at91_adc_probe_dt(struct at9
  	if (ret)
  		goto error_ret;
  
 -	st->registers = &st->caps->registers;
 -	st->num_channels = st->caps->num_channels;
 +	st->registers = devm_kzalloc(&idev->dev,
 +				     sizeof(struct at91_adc_reg_desc),
 +				     GFP_KERNEL);
 +	if (!st->registers) {
 +		dev_err(&idev->dev, "Could not allocate register memory.\n");
 +		ret = -ENOMEM;
 +		goto error_ret;
 +	}
 +
 +	if (of_property_read_u32(node, "atmel,adc-channel-base", &prop)) {
 +		dev_err(&idev->dev, "Missing adc-channel-base property in the DT.\n");
 +		ret = -EINVAL;
 +		goto error_ret;
 +	}
 +	st->registers->channel_base = prop;
 +
 +	if (of_property_read_u32(node, "atmel,adc-drdy-mask", &prop)) {
 +		dev_err(&idev->dev, "Missing adc-drdy-mask property in the DT.\n");
 +		ret = -EINVAL;
 +		goto error_ret;
 +	}
 +	st->registers->drdy_mask = prop;
 +
 +	if (of_property_read_u32(node, "atmel,adc-status-register", &prop)) {
 +		dev_err(&idev->dev, "Missing adc-status-register property in the DT.\n");
 +		ret = -EINVAL;
 +		goto error_ret;
 +	}
 +	st->registers->status_register = prop;
 +
 +	if (of_property_read_u32(node, "atmel,adc-trigger-register", &prop)) {
 +		dev_err(&idev->dev, "Missing adc-trigger-register property in the DT.\n");
 +		ret = -EINVAL;
 +		goto error_ret;
 +	}
 +	st->registers->trigger_register = prop;
 +
  	st->trigger_number = of_get_child_count(node);
- 	st->trigger_list = devm_kzalloc(&idev->dev, st->trigger_number *
+ 	st->trigger_list = devm_kcalloc(&idev->dev,
+ 					st->trigger_number,
  					sizeof(struct at91_adc_trigger),
  					GFP_KERNEL);
  	if (!st->trigger_list) {
diff --cc drivers/input/misc/rotary_encoder.c
index aff47b2c38ff,6d304381fc30..000000000000
--- a/drivers/input/misc/rotary_encoder.c
+++ b/drivers/input/misc/rotary_encoder.c
@@@ -225,53 -258,50 +225,62 @@@ static int rotary_encoder_probe(struct 
  	input->id.bustype = BUS_HOST;
  	input->dev.parent = dev;
  
 -	if (encoder->relative_axis)
 -		input_set_capability(input, EV_REL, encoder->axis);
 -	else
 -		input_set_abs_params(input,
 -				     encoder->axis, 0, encoder->steps, 0, 1);
 -
 -	switch (steps_per_period >> (encoder->gpios->ndescs - 2)) {
 -	case 4:
 -		handler = &rotary_encoder_quarter_period_irq;
 -		encoder->last_stable = rotary_encoder_get_state(encoder);
 -		break;
 -	case 2:
 -		handler = &rotary_encoder_half_period_irq;
 -		encoder->last_stable = rotary_encoder_get_state(encoder);
 -		break;
 -	case 1:
 -		handler = &rotary_encoder_irq;
 -		break;
 -	default:
 -		dev_err(dev, "'%d' is not a valid steps-per-period value\n",
 -			steps_per_period);
 -		return -EINVAL;
 +	if (pdata->relative_axis) {
 +		input->evbit[0] = BIT_MASK(EV_REL);
 +		input->relbit[0] = BIT_MASK(pdata->axis);
 +	} else {
 +		input->evbit[0] = BIT_MASK(EV_ABS);
 +		input_set_abs_params(encoder->input,
 +				     pdata->axis, 0, pdata->steps, 0, 1);
  	}
  
++<<<<<<< HEAD
 +	/* request the GPIOs */
 +	err = gpio_request_one(pdata->gpio_a, GPIOF_IN, dev_name(dev));
 +	if (err) {
 +		dev_err(dev, "unable to request GPIO %d\n", pdata->gpio_a);
 +		goto exit_free_mem;
 +	}
++=======
+ 	encoder->irq =
+ 		devm_kcalloc(dev,
+ 			     encoder->gpios->ndescs, sizeof(*encoder->irq),
+ 			     GFP_KERNEL);
+ 	if (!encoder->irq)
+ 		return -ENOMEM;
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  
 -	for (i = 0; i < encoder->gpios->ndescs; ++i) {
 -		encoder->irq[i] = gpiod_to_irq(encoder->gpios->desc[i]);
 -
 -		err = devm_request_threaded_irq(dev, encoder->irq[i],
 -				NULL, handler,
 -				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
 -				IRQF_ONESHOT,
 -				DRV_NAME, encoder);
 -		if (err) {
 -			dev_err(dev, "unable to request IRQ %d (gpio#%d)\n",
 -				encoder->irq[i], i);
 -			return err;
 -		}
 +	err = gpio_request_one(pdata->gpio_b, GPIOF_IN, dev_name(dev));
 +	if (err) {
 +		dev_err(dev, "unable to request GPIO %d\n", pdata->gpio_b);
 +		goto exit_free_gpio_a;
 +	}
 +
 +	encoder->irq_a = gpio_to_irq(pdata->gpio_a);
 +	encoder->irq_b = gpio_to_irq(pdata->gpio_b);
 +
 +	/* request the IRQs */
 +	if (pdata->half_period) {
 +		handler = &rotary_encoder_half_period_irq;
 +		encoder->last_stable = rotary_encoder_get_state(pdata);
 +	} else {
 +		handler = &rotary_encoder_irq;
 +	}
 +
 +	err = request_irq(encoder->irq_a, handler,
 +			  IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
 +			  DRV_NAME, encoder);
 +	if (err) {
 +		dev_err(dev, "unable to request IRQ %d\n", encoder->irq_a);
 +		goto exit_free_gpio_b;
 +	}
 +
 +	err = request_irq(encoder->irq_b, handler,
 +			  IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
 +			  DRV_NAME, encoder);
 +	if (err) {
 +		dev_err(dev, "unable to request IRQ %d\n", encoder->irq_b);
 +		goto exit_free_irq_a;
  	}
  
  	err = input_register_device(input);
diff --cc drivers/input/rmi4/rmi_driver.c
index 90a1e22b36d3,7d29053dfb0f..000000000000
--- a/drivers/input/rmi4/rmi_driver.c
+++ b/drivers/input/rmi4/rmi_driver.c
@@@ -975,8 -1062,8 +976,13 @@@ static int rmi_probe_interrupts(struct 
  	data->num_of_irq_regs = (data->irq_count + 7) / 8;
  
  	size = BITS_TO_LONGS(data->irq_count) * sizeof(unsigned long);
++<<<<<<< HEAD
 +	irq_memory = devm_kzalloc(dev, size * 4, GFP_KERNEL);
 +	if (!irq_memory) {
++=======
+ 	data->irq_memory = devm_kcalloc(dev, size, 4, GFP_KERNEL);
+ 	if (!data->irq_memory) {
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		dev_err(dev, "Failed to allocate memory for irq masks.\n");
  		return -ENOMEM;
  	}
diff --cc drivers/leds/leds-lp55xx-common.c
index ba34199dc3d9,3d79a6380761..000000000000
--- a/drivers/leds/leds-lp55xx-common.c
+++ b/drivers/leds/leds-lp55xx-common.c
@@@ -554,6 -541,56 +554,59 @@@ void lp55xx_unregister_sysfs(struct lp5
  }
  EXPORT_SYMBOL_GPL(lp55xx_unregister_sysfs);
  
++<<<<<<< HEAD
++=======
+ struct lp55xx_platform_data *lp55xx_of_populate_pdata(struct device *dev,
+ 						      struct device_node *np)
+ {
+ 	struct device_node *child;
+ 	struct lp55xx_platform_data *pdata;
+ 	struct lp55xx_led_config *cfg;
+ 	int num_channels;
+ 	int i = 0;
+ 
+ 	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+ 	if (!pdata)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	num_channels = of_get_child_count(np);
+ 	if (num_channels == 0) {
+ 		dev_err(dev, "no LED channels\n");
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	cfg = devm_kcalloc(dev, num_channels, sizeof(*cfg), GFP_KERNEL);
+ 	if (!cfg)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	pdata->led_config = &cfg[0];
+ 	pdata->num_channels = num_channels;
+ 
+ 	for_each_child_of_node(np, child) {
+ 		cfg[i].chan_nr = i;
+ 
+ 		of_property_read_string(child, "chan-name", &cfg[i].name);
+ 		of_property_read_u8(child, "led-cur", &cfg[i].led_current);
+ 		of_property_read_u8(child, "max-cur", &cfg[i].max_current);
+ 		cfg[i].default_trigger =
+ 			of_get_property(child, "linux,default-trigger", NULL);
+ 
+ 		i++;
+ 	}
+ 
+ 	of_property_read_string(np, "label", &pdata->label);
+ 	of_property_read_u8(np, "clock-mode", &pdata->clock_mode);
+ 
+ 	pdata->enable_gpio = of_get_named_gpio(np, "enable-gpio", 0);
+ 
+ 	/* LP8501 specific */
+ 	of_property_read_u8(np, "pwr-sel", (u8 *)&pdata->pwr_sel);
+ 
+ 	return pdata;
+ }
+ EXPORT_SYMBOL_GPL(lp55xx_of_populate_pdata);
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  MODULE_AUTHOR("Milo Kim <milo.kim@ti.com>");
  MODULE_DESCRIPTION("LP55xx Common Driver");
  MODULE_LICENSE("GPL");
diff --cc drivers/leds/leds-mc13783.c
index e942adaa7504,47ad7de9553c..000000000000
--- a/drivers/leds/leds-mc13783.c
+++ b/drivers/leds/leds-mc13783.c
@@@ -164,175 -76,184 +164,189 @@@ static int mc13783_led_setup(struct mc1
  	case MC13783_LED_R3:
  	case MC13783_LED_G3:
  	case MC13783_LED_B3:
 -		off = led->id - MC13783_LED_R1;
 -		bank = off / 3;
 -		reg = 3 + bank;
 -		shift = (off - bank * 3) * 5 + 6;
 -		break;
 -	case MC13892_LED_MD:
 -	case MC13892_LED_AD:
 -	case MC13892_LED_KP:
 -		off = led->id - MC13892_LED_MD;
 -		reg = off / 2;
 -		shift = 3 + (off - reg * 2) * 12;
 -		break;
 -	case MC13892_LED_R:
 -	case MC13892_LED_G:
 -	case MC13892_LED_B:
 -		off = led->id - MC13892_LED_R;
 -		bank = off / 2;
 -		reg = 2 + bank;
 -		shift = (off - bank * 2) * 12 + 3;
 -		break;
 -	case MC34708_LED_R:
 -	case MC34708_LED_G:
 -		reg = 0;
 -		shift = 3 + (led->id - MC34708_LED_R) * 12;
 +		bank = (led->id - MC13783_LED_R1)/3;
 +		reg = MC13783_REG_LED_CONTROL_3 + bank;
 +		shift = ((led->id - MC13783_LED_R1) - bank * 3) * 2;
 +		mask = MC13783_LED_Cx_TC_C_MASK;
 +		value = max_current & MC13783_LED_Cx_TC_C_MASK;
  		break;
 -	default:
 -		BUG();
  	}
  
 -	return mc13xxx_reg_rmw(leds->master, leds->devtype->ledctrl_base + reg,
 -			mc13xxx_max_brightness(led->id) << shift,
 -			value << shift);
 +	mc13xxx_lock(led->master);
 +
 +	ret = mc13xxx_reg_rmw(led->master, reg, mask << shift,
 +						value << shift);
 +
 +	mc13xxx_unlock(led->master);
 +	return ret;
  }
  
 -#ifdef CONFIG_OF
 -static struct mc13xxx_leds_platform_data __init *mc13xxx_led_probe_dt(
 -	struct platform_device *pdev)
 +static int mc13783_leds_prepare(struct platform_device *pdev)
  {
 -	struct mc13xxx_leds *leds = platform_get_drvdata(pdev);
 -	struct mc13xxx_leds_platform_data *pdata;
 -	struct device_node *parent, *child;
 -	struct device *dev = &pdev->dev;
 -	int i = 0, ret = -ENODATA;
 -
 -	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
 -	if (!pdata)
 -		return ERR_PTR(-ENOMEM);
 -
 -	parent = of_get_child_by_name(dev->parent->of_node, "leds");
 -	if (!parent)
 -		goto out_node_put;
 +	struct mc13xxx_leds_platform_data *pdata = dev_get_platdata(&pdev->dev);
 +	struct mc13xxx *dev = dev_get_drvdata(pdev->dev.parent);
 +	int ret = 0;
 +	int reg = 0;
 +
 +	mc13xxx_lock(dev);
 +
 +	if (pdata->flags & MC13783_LED_TC1HALF)
 +		reg |= MC13783_LED_C1_TC1HALF_BIT;
  
 -	ret = of_property_read_u32_array(parent, "led-control",
 -					 pdata->led_control,
 -					 leds->devtype->num_regs);
 +	if (pdata->flags & MC13783_LED_SLEWLIMTC)
 +		reg |= MC13783_LED_Cx_SLEWLIM_BIT;
 +
 +	ret = mc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_1, reg);
  	if (ret)
 -		goto out_node_put;
 +		goto out;
  
 -	pdata->num_leds = of_get_child_count(parent);
 +	reg = (pdata->bl_period & MC13783_LED_Cx_PERIOD_MASK) <<
 +							MC13783_LED_Cx_PERIOD;
  
 -	pdata->led = devm_kcalloc(dev, pdata->num_leds, sizeof(*pdata->led),
 -				  GFP_KERNEL);
 -	if (!pdata->led) {
 -		ret = -ENOMEM;
 -		goto out_node_put;
 -	}
++<<<<<<< HEAD
 +	if (pdata->flags & MC13783_LED_SLEWLIMBL)
 +		reg |= MC13783_LED_Cx_SLEWLIM_BIT;
  
 -	for_each_child_of_node(parent, child) {
 -		const char *str;
 -		u32 tmp;
 +	ret = mc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_2, reg);
 +	if (ret)
 +		goto out;
  
 -		if (of_property_read_u32(child, "reg", &tmp))
 -			continue;
 -		pdata->led[i].id = leds->devtype->led_min + tmp;
 +	reg = (pdata->tc1_period & MC13783_LED_Cx_PERIOD_MASK) <<
 +							MC13783_LED_Cx_PERIOD;
  
 -		if (!of_property_read_string(child, "label", &str))
 -			pdata->led[i].name = str;
 -		if (!of_property_read_string(child, "linux,default-trigger",
 -					     &str))
 -			pdata->led[i].default_trigger = str;
 +	if (pdata->flags & MC13783_LED_TRIODE_TC1)
 +		reg |= MC13783_LED_Cx_TRIODE_TC_BIT;
  
 -		i++;
 -	}
 +	ret = mc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_3, reg);
 +	if (ret)
 +		goto out;
  
 -	pdata->num_leds = i;
 -	ret = i > 0 ? 0 : -ENODATA;
 +	reg = (pdata->tc2_period & MC13783_LED_Cx_PERIOD_MASK) <<
 +							MC13783_LED_Cx_PERIOD;
  
 -out_node_put:
 -	of_node_put(parent);
 +	if (pdata->flags & MC13783_LED_TRIODE_TC2)
 +		reg |= MC13783_LED_Cx_TRIODE_TC_BIT;
  
 -	return ret ? ERR_PTR(ret) : pdata;
 -}
 -#else
 -static inline struct mc13xxx_leds_platform_data __init *mc13xxx_led_probe_dt(
 -	struct platform_device *pdev)
 -{
 -	return ERR_PTR(-ENOSYS);
 -}
 -#endif
 +	ret = mc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_4, reg);
 +	if (ret)
 +		goto out;
  
 -static int __init mc13xxx_led_probe(struct platform_device *pdev)
 -{
 -	struct device *dev = &pdev->dev;
 -	struct mc13xxx_leds_platform_data *pdata = dev_get_platdata(dev);
 -	struct mc13xxx *mcdev = dev_get_drvdata(dev->parent);
 -	struct mc13xxx_led_devtype *devtype =
 -		(struct mc13xxx_led_devtype *)pdev->id_entry->driver_data;
 -	struct mc13xxx_leds *leds;
 -	int i, id, ret = -ENODATA;
 -	u32 init_led = 0;
 -
 -	leds = devm_kzalloc(dev, sizeof(*leds), GFP_KERNEL);
 -	if (!leds)
 -		return -ENOMEM;
 +	reg = (pdata->tc3_period & MC13783_LED_Cx_PERIOD_MASK) <<
 +							MC13783_LED_Cx_PERIOD;
  
 -	leds->devtype = devtype;
 -	leds->master = mcdev;
 -	platform_set_drvdata(pdev, leds);
 +	if (pdata->flags & MC13783_LED_TRIODE_TC3)
 +		reg |= MC13783_LED_Cx_TRIODE_TC_BIT;
  
 -	if (dev->parent->of_node) {
 -		pdata = mc13xxx_led_probe_dt(pdev);
 -		if (IS_ERR(pdata))
 -			return PTR_ERR(pdata);
 -	} else if (!pdata)
 -		return -ENODATA;
 +	ret = mc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_5, reg);
 +	if (ret)
 +		goto out;
 +
 +	reg = MC13783_LED_C0_ENABLE_BIT;
 +	if (pdata->flags & MC13783_LED_TRIODE_MD)
 +		reg |= MC13783_LED_C0_TRIODE_MD_BIT;
 +	if (pdata->flags & MC13783_LED_TRIODE_AD)
 +		reg |= MC13783_LED_C0_TRIODE_AD_BIT;
 +	if (pdata->flags & MC13783_LED_TRIODE_KP)
 +		reg |= MC13783_LED_C0_TRIODE_KP_BIT;
 +	if (pdata->flags & MC13783_LED_BOOST_EN)
 +		reg |= MC13783_LED_C0_BOOST_BIT;
 +
 +	reg |= (pdata->abmode & MC13783_LED_C0_ABMODE_MASK) <<
 +							MC13783_LED_C0_ABMODE;
 +	reg |= (pdata->abref & MC13783_LED_C0_ABREF_MASK) <<
 +							MC13783_LED_C0_ABREF;
 +
 +	ret = mc13xxx_reg_write(dev, MC13783_REG_LED_CONTROL_0, reg);
 +
 +out:
 +	mc13xxx_unlock(dev);
 +	return ret;
 +}
  
 -	leds->num_leds = pdata->num_leds;
 +static int mc13783_led_probe(struct platform_device *pdev)
 +{
 +	struct mc13xxx_leds_platform_data *pdata = dev_get_platdata(&pdev->dev);
 +	struct mc13xxx_led_platform_data *led_cur;
 +	struct mc13783_led *led, *led_dat;
 +	int ret, i;
 +	int init_led = 0;
 +
 +	if (pdata == NULL) {
 +		dev_err(&pdev->dev, "missing platform data\n");
 +		return -ENODEV;
++=======
++	pdata->led = devm_kcalloc(dev, pdata->num_leds, sizeof(*pdata->led),
++				  GFP_KERNEL);
++	if (!pdata->led) {
++		ret = -ENOMEM;
++		goto out_node_put;
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
 +	}
  
 -	if ((leds->num_leds < 1) ||
 -	    (leds->num_leds > (devtype->led_max - devtype->led_min + 1))) {
 -		dev_err(dev, "Invalid LED count %d\n", leds->num_leds);
 +	if (pdata->num_leds < 1 || pdata->num_leds > (MC13783_LED_MAX + 1)) {
 +		dev_err(&pdev->dev, "Invalid led count %d\n", pdata->num_leds);
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	led = devm_kzalloc(&pdev->dev, pdata->num_leds * sizeof(*led),
 +				GFP_KERNEL);
 +	if (led == NULL) {
 +		dev_err(&pdev->dev, "failed to alloc memory\n");
++=======
+ 	leds->led = devm_kcalloc(dev, leds->num_leds, sizeof(*leds->led),
+ 				 GFP_KERNEL);
+ 	if (!leds->led)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 -
 -	for (i = 0; i < devtype->num_regs; i++) {
 -		ret = mc13xxx_reg_write(mcdev, leds->devtype->ledctrl_base + i,
 -					pdata->led_control[i]);
 -		if (ret)
 -			return ret;
  	}
  
 -	for (i = 0; i < leds->num_leds; i++) {
 -		const char *name, *trig;
 -
 -		ret = -EINVAL;
 +	ret = mc13783_leds_prepare(pdev);
 +	if (ret) {
 +		dev_err(&pdev->dev, "unable to init led driver\n");
 +		return ret;
 +	}
  
 -		id = pdata->led[i].id;
 -		name = pdata->led[i].name;
 -		trig = pdata->led[i].default_trigger;
 +	for (i = 0; i < pdata->num_leds; i++) {
 +		led_dat = &led[i];
 +		led_cur = &pdata->led[i];
  
 -		if ((id > devtype->led_max) || (id < devtype->led_min)) {
 -			dev_err(dev, "Invalid ID %i\n", id);
 -			break;
 +		if (led_cur->id > MC13783_LED_MAX || led_cur->id < 0) {
 +			dev_err(&pdev->dev, "invalid id %d\n", led_cur->id);
 +			ret = -EINVAL;
 +			goto err_register;
  		}
  
 -		if (init_led & (1 << id)) {
 -			dev_warn(dev, "LED %i already initialized\n", id);
 -			break;
 +		if (init_led & (1 << led_cur->id)) {
 +			dev_err(&pdev->dev, "led %d already initialized\n",
 +					led_cur->id);
 +			ret = -EINVAL;
 +			goto err_register;
  		}
  
 -		init_led |= 1 << id;
 -		leds->led[i].id = id;
 -		leds->led[i].leds = leds;
 -		leds->led[i].cdev.name = name;
 -		leds->led[i].cdev.default_trigger = trig;
 -		leds->led[i].cdev.flags = LED_CORE_SUSPENDRESUME;
 -		leds->led[i].cdev.brightness_set_blocking = mc13xxx_led_set;
 -		leds->led[i].cdev.max_brightness = mc13xxx_max_brightness(id);
 +		init_led |= 1 << led_cur->id;
 +		led_dat->cdev.name = led_cur->name;
 +		led_dat->cdev.default_trigger = led_cur->default_trigger;
 +		led_dat->cdev.brightness_set = mc13783_led_set;
 +		led_dat->cdev.brightness = LED_OFF;
 +		led_dat->id = led_cur->id;
 +		led_dat->master = dev_get_drvdata(pdev->dev.parent);
  
 -		ret = led_classdev_register(dev->parent, &leds->led[i].cdev);
 +		INIT_WORK(&led_dat->work, mc13783_led_work);
 +
 +		ret = led_classdev_register(pdev->dev.parent, &led_dat->cdev);
  		if (ret) {
 -			dev_err(dev, "Failed to register LED %i\n", id);
 -			break;
 +			dev_err(&pdev->dev, "failed to register led %d\n",
 +					led_dat->id);
 +			goto err_register;
 +		}
 +
 +		ret = mc13783_led_setup(led_dat, led_cur->max_current);
 +		if (ret) {
 +			dev_err(&pdev->dev, "unable to init led %d\n",
 +					led_dat->id);
 +			i++;
 +			goto err_register;
  		}
  	}
  
diff --cc drivers/leds/leds-netxbig.c
index c61c5ebcc08e,62fa0de526ee..000000000000
--- a/drivers/leds/leds-netxbig.c
+++ b/drivers/leds/leds-netxbig.c
@@@ -343,12 -313,220 +343,220 @@@ create_netxbig_led(struct platform_devi
  	 * If available, expose the SATA activity blink capability through
  	 * a "sata" sysfs attribute.
  	 */
++<<<<<<< HEAD
 +	if (led_dat->mode_val[NETXBIG_LED_SATA] != NETXBIG_LED_INVALID_MODE) {
 +		ret = device_create_file(led_dat->cdev.dev, &dev_attr_sata);
 +		if (ret)
 +			led_classdev_unregister(&led_dat->cdev);
++=======
+ 	if (led_dat->mode_val[NETXBIG_LED_SATA] != NETXBIG_LED_INVALID_MODE)
+ 		led_dat->cdev.groups = netxbig_led_groups;
+ 
+ 	return devm_led_classdev_register(&pdev->dev, &led_dat->cdev);
+ }
+ 
+ #ifdef CONFIG_OF_GPIO
+ static int gpio_ext_get_of_pdata(struct device *dev, struct device_node *np,
+ 				 struct netxbig_gpio_ext *gpio_ext)
+ {
+ 	int *addr, *data;
+ 	int num_addr, num_data;
+ 	int ret;
+ 	int i;
+ 
+ 	ret = of_gpio_named_count(np, "addr-gpios");
+ 	if (ret < 0) {
+ 		dev_err(dev,
+ 			"Failed to count GPIOs in DT property addr-gpios\n");
+ 		return ret;
+ 	}
+ 	num_addr = ret;
+ 	addr = devm_kcalloc(dev, num_addr, sizeof(*addr), GFP_KERNEL);
+ 	if (!addr)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < num_addr; i++) {
+ 		ret = of_get_named_gpio(np, "addr-gpios", i);
+ 		if (ret < 0)
+ 			return ret;
+ 		addr[i] = ret;
+ 	}
+ 	gpio_ext->addr = addr;
+ 	gpio_ext->num_addr = num_addr;
+ 
+ 	ret = of_gpio_named_count(np, "data-gpios");
+ 	if (ret < 0) {
+ 		dev_err(dev,
+ 			"Failed to count GPIOs in DT property data-gpios\n");
+ 		return ret;
+ 	}
+ 	num_data = ret;
+ 	data = devm_kcalloc(dev, num_data, sizeof(*data), GFP_KERNEL);
+ 	if (!data)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < num_data; i++) {
+ 		ret = of_get_named_gpio(np, "data-gpios", i);
+ 		if (ret < 0)
+ 			return ret;
+ 		data[i] = ret;
+ 	}
+ 	gpio_ext->data = data;
+ 	gpio_ext->num_data = num_data;
+ 
+ 	ret = of_get_named_gpio(np, "enable-gpio", 0);
+ 	if (ret < 0) {
+ 		dev_err(dev,
+ 			"Failed to get GPIO from DT property enable-gpio\n");
+ 		return ret;
+ 	}
+ 	gpio_ext->enable = ret;
+ 
+ 	return 0;
+ }
+ 
+ static int netxbig_leds_get_of_pdata(struct device *dev,
+ 				     struct netxbig_led_platform_data *pdata)
+ {
+ 	struct device_node *np = dev->of_node;
+ 	struct device_node *gpio_ext_np;
+ 	struct device_node *child;
+ 	struct netxbig_gpio_ext *gpio_ext;
+ 	struct netxbig_led_timer *timers;
+ 	struct netxbig_led *leds, *led;
+ 	int num_timers;
+ 	int num_leds = 0;
+ 	int ret;
+ 	int i;
+ 
+ 	/* GPIO extension */
+ 	gpio_ext_np = of_parse_phandle(np, "gpio-ext", 0);
+ 	if (!gpio_ext_np) {
+ 		dev_err(dev, "Failed to get DT handle gpio-ext\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	gpio_ext = devm_kzalloc(dev, sizeof(*gpio_ext), GFP_KERNEL);
+ 	if (!gpio_ext)
+ 		return -ENOMEM;
+ 	ret = gpio_ext_get_of_pdata(dev, gpio_ext_np, gpio_ext);
+ 	if (ret)
+ 		return ret;
+ 	of_node_put(gpio_ext_np);
+ 	pdata->gpio_ext = gpio_ext;
+ 
+ 	/* Timers (optional) */
+ 	ret = of_property_count_u32_elems(np, "timers");
+ 	if (ret > 0) {
+ 		if (ret % 3)
+ 			return -EINVAL;
+ 		num_timers = ret / 3;
+ 		timers = devm_kcalloc(dev, num_timers, sizeof(*timers),
+ 				      GFP_KERNEL);
+ 		if (!timers)
+ 			return -ENOMEM;
+ 		for (i = 0; i < num_timers; i++) {
+ 			u32 tmp;
+ 
+ 			of_property_read_u32_index(np, "timers", 3 * i,
+ 						   &timers[i].mode);
+ 			if (timers[i].mode >= NETXBIG_LED_MODE_NUM)
+ 				return -EINVAL;
+ 			of_property_read_u32_index(np, "timers",
+ 						   3 * i + 1, &tmp);
+ 			timers[i].delay_on = tmp;
+ 			of_property_read_u32_index(np, "timers",
+ 						   3 * i + 2, &tmp);
+ 			timers[i].delay_off = tmp;
+ 		}
+ 		pdata->timer = timers;
+ 		pdata->num_timer = num_timers;
+ 	}
+ 
+ 	/* LEDs */
+ 	num_leds = of_get_child_count(np);
+ 	if (!num_leds) {
+ 		dev_err(dev, "No LED subnodes found in DT\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	leds = devm_kcalloc(dev, num_leds, sizeof(*leds), GFP_KERNEL);
+ 	if (!leds)
+ 		return -ENOMEM;
+ 
+ 	led = leds;
+ 	for_each_child_of_node(np, child) {
+ 		const char *string;
+ 		int *mode_val;
+ 		int num_modes;
+ 
+ 		ret = of_property_read_u32(child, "mode-addr",
+ 					   &led->mode_addr);
+ 		if (ret)
+ 			goto err_node_put;
+ 
+ 		ret = of_property_read_u32(child, "bright-addr",
+ 					   &led->bright_addr);
+ 		if (ret)
+ 			goto err_node_put;
+ 
+ 		ret = of_property_read_u32(child, "max-brightness",
+ 					   &led->bright_max);
+ 		if (ret)
+ 			goto err_node_put;
+ 
+ 		mode_val =
+ 			devm_kcalloc(dev,
+ 				     NETXBIG_LED_MODE_NUM, sizeof(*mode_val),
+ 				     GFP_KERNEL);
+ 		if (!mode_val) {
+ 			ret = -ENOMEM;
+ 			goto err_node_put;
+ 		}
+ 
+ 		for (i = 0; i < NETXBIG_LED_MODE_NUM; i++)
+ 			mode_val[i] = NETXBIG_LED_INVALID_MODE;
+ 
+ 		ret = of_property_count_u32_elems(child, "mode-val");
+ 		if (ret < 0 || ret % 2) {
+ 			ret = -EINVAL;
+ 			goto err_node_put;
+ 		}
+ 		num_modes = ret / 2;
+ 		if (num_modes > NETXBIG_LED_MODE_NUM) {
+ 			ret = -EINVAL;
+ 			goto err_node_put;
+ 		}
+ 
+ 		for (i = 0; i < num_modes; i++) {
+ 			int mode;
+ 			int val;
+ 
+ 			of_property_read_u32_index(child,
+ 						   "mode-val", 2 * i, &mode);
+ 			of_property_read_u32_index(child,
+ 						   "mode-val", 2 * i + 1, &val);
+ 			if (mode >= NETXBIG_LED_MODE_NUM) {
+ 				ret = -EINVAL;
+ 				goto err_node_put;
+ 			}
+ 			mode_val[mode] = val;
+ 		}
+ 		led->mode_val = mode_val;
+ 
+ 		if (!of_property_read_string(child, "label", &string))
+ 			led->name = string;
+ 		else
+ 			led->name = child->name;
+ 
+ 		if (!of_property_read_string(child,
+ 					     "linux,default-trigger", &string))
+ 			led->default_trigger = string;
+ 
+ 		led++;
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	}
  
 -	pdata->leds = leds;
 -	pdata->num_leds = num_leds;
 -
 -	return 0;
 -
 -err_node_put:
 -	of_node_put(child);
  	return ret;
  }
  
@@@ -359,11 -551,18 +567,17 @@@ static int netxbig_led_probe(struct pla
  	int i;
  	int ret;
  
 -	if (!pdata) {
 -		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 -		if (!pdata)
 -			return -ENOMEM;
 -		ret = netxbig_leds_get_of_pdata(&pdev->dev, pdata);
 -		if (ret)
 -			return ret;
 -	}
 +	if (!pdata)
 +		return -EINVAL;
  
++<<<<<<< HEAD
 +	leds_data = devm_kzalloc(&pdev->dev,
 +		sizeof(struct netxbig_led_data) * pdata->num_leds, GFP_KERNEL);
++=======
+ 	leds_data = devm_kcalloc(&pdev->dev,
+ 				 pdata->num_leds, sizeof(*leds_data),
+ 				 GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	if (!leds_data)
  		return -ENOMEM;
  
diff --cc drivers/leds/leds-ns2.c
index 70137b1eecf5,14fe5cd43232..000000000000
--- a/drivers/leds/leds-ns2.c
+++ b/drivers/leds/leds-ns2.c
@@@ -291,9 -288,39 +291,43 @@@ ns2_leds_get_of_pdata(struct device *de
  		ret = of_property_read_string(child, "linux,default-trigger",
  					      &string);
  		if (ret == 0)
 -			led->default_trigger = string;
 +			leds[i].default_trigger = string;
  
++<<<<<<< HEAD
 +		i++;
++=======
+ 		ret = of_property_count_u32_elems(child, "modes-map");
+ 		if (ret < 0 || ret % 3) {
+ 			dev_err(dev,
+ 				"Missing or malformed modes-map property\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		num_modes = ret / 3;
+ 		modval = devm_kcalloc(dev,
+ 				      num_modes,
+ 				      sizeof(struct ns2_led_modval),
+ 				      GFP_KERNEL);
+ 		if (!modval)
+ 			return -ENOMEM;
+ 
+ 		for (i = 0; i < num_modes; i++) {
+ 			of_property_read_u32_index(child,
+ 						"modes-map", 3 * i,
+ 						(u32 *) &modval[i].mode);
+ 			of_property_read_u32_index(child,
+ 						"modes-map", 3 * i + 1,
+ 						(u32 *) &modval[i].cmd_level);
+ 			of_property_read_u32_index(child,
+ 						"modes-map", 3 * i + 2,
+ 						(u32 *) &modval[i].slow_level);
+ 		}
+ 
+ 		led->num_modes = num_modes;
+ 		led->modval = modval;
+ 
+ 		led++;
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	}
  
  	pdata->leds = leds;
diff --cc drivers/leds/leds-pca955x.c
index edf485b773c8,f51b356d4426..000000000000
--- a/drivers/leds/leds-pca955x.c
+++ b/drivers/leds/leds-pca955x.c
@@@ -235,26 -289,156 +235,153 @@@ static void pca955x_led_work(struct wor
  		break;
  	}
  
 -	ret = pca955x_write_ls(pca955x->client, chip_ls, ls);
 +	pca955x_write_ls(pca955x->client, chip_ls, ls);
  
 -out:
  	mutex_unlock(&pca955x->lock);
 -
 -	return ret;
  }
  
 -#ifdef CONFIG_LEDS_PCA955X_GPIO
 -/*
 - * Read the INPUT register, which contains the state of LEDs.
 - */
 -static int pca955x_read_input(struct i2c_client *client, int n, u8 *val)
 +static void pca955x_led_set(struct led_classdev *led_cdev, enum led_brightness value)
  {
 -	int ret = i2c_smbus_read_byte_data(client, n);
 +	struct pca955x_led *pca955x;
  
 -	if (ret < 0) {
 -		dev_err(&client->dev, "%s: reg 0x%x, err %d\n",
 -			__func__, n, ret);
 -		return ret;
 -	}
 -	*val = (u8)ret;
 -	return 0;
 +	pca955x = container_of(led_cdev, struct pca955x_led, led_cdev);
 +
 +	pca955x->brightness = value;
  
 +	/*
 +	 * Must use workqueue for the actual I/O since I2C operations
 +	 * can sleep.
 +	 */
 +	schedule_work(&pca955x->work);
  }
  
++<<<<<<< HEAD
++=======
+ static int pca955x_gpio_request_pin(struct gpio_chip *gc, unsigned int offset)
+ {
+ 	struct pca955x *pca955x = gpiochip_get_data(gc);
+ 	struct pca955x_led *led = &pca955x->leds[offset];
+ 
+ 	if (led->type == PCA955X_TYPE_GPIO)
+ 		return 0;
+ 
+ 	return -EBUSY;
+ }
+ 
+ static int pca955x_set_value(struct gpio_chip *gc, unsigned int offset,
+ 			     int val)
+ {
+ 	struct pca955x *pca955x = gpiochip_get_data(gc);
+ 	struct pca955x_led *led = &pca955x->leds[offset];
+ 
+ 	if (val)
+ 		return pca955x_led_set(&led->led_cdev, PCA955X_GPIO_HIGH);
+ 
+ 	return pca955x_led_set(&led->led_cdev, PCA955X_GPIO_LOW);
+ }
+ 
+ static void pca955x_gpio_set_value(struct gpio_chip *gc, unsigned int offset,
+ 				   int val)
+ {
+ 	pca955x_set_value(gc, offset, val);
+ }
+ 
+ static int pca955x_gpio_get_value(struct gpio_chip *gc, unsigned int offset)
+ {
+ 	struct pca955x *pca955x = gpiochip_get_data(gc);
+ 	struct pca955x_led *led = &pca955x->leds[offset];
+ 	u8 reg = 0;
+ 
+ 	/* There is nothing we can do about errors */
+ 	pca955x_read_input(pca955x->client, led->led_num / 8, &reg);
+ 
+ 	return !!(reg & (1 << (led->led_num % 8)));
+ }
+ 
+ static int pca955x_gpio_direction_input(struct gpio_chip *gc,
+ 					unsigned int offset)
+ {
+ 	struct pca955x *pca955x = gpiochip_get_data(gc);
+ 	struct pca955x_led *led = &pca955x->leds[offset];
+ 
+ 	/* To use as input ensure pin is not driven. */
+ 	return pca955x_led_set(&led->led_cdev, PCA955X_GPIO_INPUT);
+ }
+ 
+ static int pca955x_gpio_direction_output(struct gpio_chip *gc,
+ 					 unsigned int offset, int val)
+ {
+ 	return pca955x_set_value(gc, offset, val);
+ }
+ #endif /* CONFIG_LEDS_PCA955X_GPIO */
+ 
+ #if IS_ENABLED(CONFIG_OF)
+ static struct pca955x_platform_data *
+ pca955x_pdata_of_init(struct i2c_client *client, struct pca955x_chipdef *chip)
+ {
+ 	struct device_node *np = client->dev.of_node;
+ 	struct device_node *child;
+ 	struct pca955x_platform_data *pdata;
+ 	int count;
+ 
+ 	count = of_get_child_count(np);
+ 	if (!count || count > chip->bits)
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+ 	if (!pdata)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	pdata->leds = devm_kcalloc(&client->dev,
+ 				   chip->bits, sizeof(struct pca955x_led),
+ 				   GFP_KERNEL);
+ 	if (!pdata->leds)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	for_each_child_of_node(np, child) {
+ 		const char *name;
+ 		u32 reg;
+ 		int res;
+ 
+ 		res = of_property_read_u32(child, "reg", &reg);
+ 		if ((res != 0) || (reg >= chip->bits))
+ 			continue;
+ 
+ 		if (of_property_read_string(child, "label", &name))
+ 			name = child->name;
+ 
+ 		snprintf(pdata->leds[reg].name, sizeof(pdata->leds[reg].name),
+ 			 "%s", name);
+ 
+ 		pdata->leds[reg].type = PCA955X_TYPE_LED;
+ 		of_property_read_u32(child, "type", &pdata->leds[reg].type);
+ 		of_property_read_string(child, "linux,default-trigger",
+ 					&pdata->leds[reg].default_trigger);
+ 	}
+ 
+ 	pdata->num_leds = chip->bits;
+ 
+ 	return pdata;
+ }
+ 
+ static const struct of_device_id of_pca955x_match[] = {
+ 	{ .compatible = "nxp,pca9550", .data = (void *)pca9550 },
+ 	{ .compatible = "nxp,pca9551", .data = (void *)pca9551 },
+ 	{ .compatible = "nxp,pca9552", .data = (void *)pca9552 },
+ 	{ .compatible = "nxp,pca9553", .data = (void *)pca9553 },
+ 	{},
+ };
+ 
+ MODULE_DEVICE_TABLE(of, of_pca955x_match);
+ #else
+ static struct pca955x_platform_data *
+ pca955x_pdata_of_init(struct i2c_client *client, struct pca955x_chipdef *chip)
+ {
+ 	return ERR_PTR(-ENODEV);
+ }
+ #endif
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  static int pca955x_probe(struct i2c_client *client,
  					const struct i2c_device_id *id)
  {
diff --cc drivers/leds/leds-tca6507.c
index 98fe021ba276,8f343afa4787..000000000000
--- a/drivers/leds/leds-tca6507.c
+++ b/drivers/leds/leds-tca6507.c
@@@ -681,8 -697,8 +681,13 @@@ tca6507_led_dt_init(struct i2c_client *
  	if (!count || count > NUM_LEDS)
  		return ERR_PTR(-ENODEV);
  
++<<<<<<< HEAD
 +	tca_leds = devm_kzalloc(&client->dev,
 +			sizeof(struct led_info) * count, GFP_KERNEL);
++=======
+ 	tca_leds = devm_kcalloc(&client->dev,
+ 			NUM_LEDS, sizeof(struct led_info), GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	if (!tca_leds)
  		return ERR_PTR(-ENOMEM);
  
diff --cc drivers/media/platform/davinci/vpif_capture.c
index 5f98df1fc8a0,a96f53ce8088..000000000000
--- a/drivers/media/platform/davinci/vpif_capture.c
+++ b/drivers/media/platform/davinci/vpif_capture.c
@@@ -2056,6 -1382,235 +2056,238 @@@ vpif_init_free_channel_objects
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int vpif_async_bound(struct v4l2_async_notifier *notifier,
+ 			    struct v4l2_subdev *subdev,
+ 			    struct v4l2_async_subdev *asd)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < vpif_obj.config->asd_sizes[0]; i++) {
+ 		struct v4l2_async_subdev *_asd = vpif_obj.config->asd[i];
+ 		const struct fwnode_handle *fwnode = _asd->match.fwnode;
+ 
+ 		if (fwnode == subdev->fwnode) {
+ 			vpif_obj.sd[i] = subdev;
+ 			vpif_obj.config->chan_config->inputs[i].subdev_name =
+ 				(char *)to_of_node(subdev->fwnode)->full_name;
+ 			vpif_dbg(2, debug,
+ 				 "%s: setting input %d subdev_name = %s\n",
+ 				 __func__, i,
+ 				vpif_obj.config->chan_config->inputs[i].subdev_name);
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < vpif_obj.config->subdev_count; i++)
+ 		if (!strcmp(vpif_obj.config->subdev_info[i].name,
+ 			    subdev->name)) {
+ 			vpif_obj.sd[i] = subdev;
+ 			return 0;
+ 		}
+ 
+ 	return -EINVAL;
+ }
+ 
+ static int vpif_probe_complete(void)
+ {
+ 	struct common_obj *common;
+ 	struct video_device *vdev;
+ 	struct channel_obj *ch;
+ 	struct vb2_queue *q;
+ 	int j, err, k;
+ 
+ 	for (j = 0; j < VPIF_CAPTURE_MAX_DEVICES; j++) {
+ 		ch = vpif_obj.dev[j];
+ 		ch->channel_id = j;
+ 		common = &(ch->common[VPIF_VIDEO_INDEX]);
+ 		spin_lock_init(&common->irqlock);
+ 		mutex_init(&common->lock);
+ 
+ 		/* select input 0 */
+ 		err = vpif_set_input(vpif_obj.config, ch, 0);
+ 		if (err)
+ 			goto probe_out;
+ 
+ 		/* set initial format */
+ 		ch->video.stdid = V4L2_STD_525_60;
+ 		memset(&ch->video.dv_timings, 0, sizeof(ch->video.dv_timings));
+ 		common->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+ 		vpif_update_std_info(ch);
+ 
+ 		/* Initialize vb2 queue */
+ 		q = &common->buffer_queue;
+ 		q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+ 		q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+ 		q->drv_priv = ch;
+ 		q->ops = &video_qops;
+ 		q->mem_ops = &vb2_dma_contig_memops;
+ 		q->buf_struct_size = sizeof(struct vpif_cap_buffer);
+ 		q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+ 		q->min_buffers_needed = 1;
+ 		q->lock = &common->lock;
+ 		q->dev = vpif_dev;
+ 
+ 		err = vb2_queue_init(q);
+ 		if (err) {
+ 			vpif_err("vpif_capture: vb2_queue_init() failed\n");
+ 			goto probe_out;
+ 		}
+ 
+ 		INIT_LIST_HEAD(&common->dma_queue);
+ 
+ 		/* Initialize the video_device structure */
+ 		vdev = &ch->video_dev;
+ 		strlcpy(vdev->name, VPIF_DRIVER_NAME, sizeof(vdev->name));
+ 		vdev->release = video_device_release_empty;
+ 		vdev->fops = &vpif_fops;
+ 		vdev->ioctl_ops = &vpif_ioctl_ops;
+ 		vdev->v4l2_dev = &vpif_obj.v4l2_dev;
+ 		vdev->vfl_dir = VFL_DIR_RX;
+ 		vdev->queue = q;
+ 		vdev->lock = &common->lock;
+ 		video_set_drvdata(&ch->video_dev, ch);
+ 		err = video_register_device(vdev,
+ 					    VFL_TYPE_GRABBER, (j ? 1 : 0));
+ 		if (err)
+ 			goto probe_out;
+ 	}
+ 
+ 	v4l2_info(&vpif_obj.v4l2_dev, "VPIF capture driver initialized\n");
+ 	return 0;
+ 
+ probe_out:
+ 	for (k = 0; k < j; k++) {
+ 		/* Get the pointer to the channel object */
+ 		ch = vpif_obj.dev[k];
+ 		common = &ch->common[k];
+ 		/* Unregister video device */
+ 		video_unregister_device(&ch->video_dev);
+ 	}
+ 	kfree(vpif_obj.sd);
+ 	v4l2_device_unregister(&vpif_obj.v4l2_dev);
+ 
+ 	return err;
+ }
+ 
+ static int vpif_async_complete(struct v4l2_async_notifier *notifier)
+ {
+ 	return vpif_probe_complete();
+ }
+ 
+ static const struct v4l2_async_notifier_operations vpif_async_ops = {
+ 	.bound = vpif_async_bound,
+ 	.complete = vpif_async_complete,
+ };
+ 
+ static struct vpif_capture_config *
+ vpif_capture_get_pdata(struct platform_device *pdev)
+ {
+ 	struct device_node *endpoint = NULL;
+ 	struct v4l2_fwnode_endpoint bus_cfg;
+ 	struct vpif_capture_config *pdata;
+ 	struct vpif_subdev_info *sdinfo;
+ 	struct vpif_capture_chan_config *chan;
+ 	unsigned int i;
+ 
+ 	/*
+ 	 * DT boot: OF node from parent device contains
+ 	 * video ports & endpoints data.
+ 	 */
+ 	if (pdev->dev.parent && pdev->dev.parent->of_node)
+ 		pdev->dev.of_node = pdev->dev.parent->of_node;
+ 	if (!IS_ENABLED(CONFIG_OF) || !pdev->dev.of_node)
+ 		return pdev->dev.platform_data;
+ 
+ 	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+ 	if (!pdata)
+ 		return NULL;
+ 	pdata->subdev_info =
+ 		devm_kcalloc(&pdev->dev,
+ 			     VPIF_CAPTURE_NUM_CHANNELS,
+ 			     sizeof(*pdata->subdev_info),
+ 			     GFP_KERNEL);
+ 
+ 	if (!pdata->subdev_info)
+ 		return NULL;
+ 
+ 	for (i = 0; i < VPIF_CAPTURE_NUM_CHANNELS; i++) {
+ 		struct device_node *rem;
+ 		unsigned int flags;
+ 		int err;
+ 
+ 		endpoint = of_graph_get_next_endpoint(pdev->dev.of_node,
+ 						      endpoint);
+ 		if (!endpoint)
+ 			break;
+ 
+ 		sdinfo = &pdata->subdev_info[i];
+ 		chan = &pdata->chan_config[i];
+ 		chan->inputs = devm_kcalloc(&pdev->dev,
+ 					    VPIF_CAPTURE_NUM_CHANNELS,
+ 					    sizeof(*chan->inputs),
+ 					    GFP_KERNEL);
+ 		if (!chan->inputs)
+ 			return NULL;
+ 
+ 		chan->input_count++;
+ 		chan->inputs[i].input.type = V4L2_INPUT_TYPE_CAMERA;
+ 		chan->inputs[i].input.std = V4L2_STD_ALL;
+ 		chan->inputs[i].input.capabilities = V4L2_IN_CAP_STD;
+ 
+ 		err = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint),
+ 						 &bus_cfg);
+ 		if (err) {
+ 			dev_err(&pdev->dev, "Could not parse the endpoint\n");
+ 			goto done;
+ 		}
+ 		dev_dbg(&pdev->dev, "Endpoint %pOF, bus_width = %d\n",
+ 			endpoint, bus_cfg.bus.parallel.bus_width);
+ 		flags = bus_cfg.bus.parallel.flags;
+ 
+ 		if (flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)
+ 			chan->vpif_if.hd_pol = 1;
+ 
+ 		if (flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)
+ 			chan->vpif_if.vd_pol = 1;
+ 
+ 		rem = of_graph_get_remote_port_parent(endpoint);
+ 		if (!rem) {
+ 			dev_dbg(&pdev->dev, "Remote device at %pOF not found\n",
+ 				endpoint);
+ 			goto done;
+ 		}
+ 
+ 		dev_dbg(&pdev->dev, "Remote device %s, %pOF found\n",
+ 			rem->name, rem);
+ 		sdinfo->name = rem->full_name;
+ 
+ 		pdata->asd[i] = devm_kzalloc(&pdev->dev,
+ 					     sizeof(struct v4l2_async_subdev),
+ 					     GFP_KERNEL);
+ 		if (!pdata->asd[i]) {
+ 			of_node_put(rem);
+ 			pdata = NULL;
+ 			goto done;
+ 		}
+ 
+ 		pdata->asd[i]->match_type = V4L2_ASYNC_MATCH_FWNODE;
+ 		pdata->asd[i]->match.fwnode = of_fwnode_handle(rem);
+ 		of_node_put(rem);
+ 	}
+ 
+ done:
+ 	if (pdata) {
+ 		pdata->asd_sizes[0] = i;
+ 		pdata->subdev_count = i;
+ 		pdata->card_name = "DA850/OMAP-L138 Video Capture";
+ 	}
+ 
+ 	return pdata;
+ }
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  /**
   * vpif_probe : This function probes the vpif capture driver
   * @pdev: platform device pointer
diff --cc drivers/mfd/ab8500-debugfs.c
index 37b7ce4c7c3b,8d652b2f9d14..000000000000
--- a/drivers/mfd/ab8500-debugfs.c
+++ b/drivers/mfd/ab8500-debugfs.c
@@@ -2946,17 -2659,20 +2946,32 @@@ static int ab8500_debug_probe(struct pl
  	ab8500 = dev_get_drvdata(plf->dev.parent);
  	num_irqs = ab8500->mask_size;
  
++<<<<<<< HEAD
 +	irq_count = kzalloc(sizeof(*irq_count)*num_irqs, GFP_KERNEL);
 +	if (!irq_count)
 +		return -ENOMEM;
 +
 +	dev_attr = kzalloc(sizeof(*dev_attr)*num_irqs,GFP_KERNEL);
++=======
+ 	irq_count = devm_kcalloc(&plf->dev,
+ 				 num_irqs, sizeof(*irq_count), GFP_KERNEL);
+ 	if (!irq_count)
+ 		return -ENOMEM;
+ 
+ 	dev_attr = devm_kcalloc(&plf->dev,
+ 				num_irqs, sizeof(*dev_attr), GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	if (!dev_attr)
 -		return -ENOMEM;
 +		goto out_freeirq_count;
  
++<<<<<<< HEAD
 +	event_name = kzalloc(sizeof(*event_name)*num_irqs, GFP_KERNEL);
++=======
+ 	event_name = devm_kcalloc(&plf->dev,
+ 				  num_irqs, sizeof(*event_name), GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	if (!event_name)
 -		return -ENOMEM;
 +		goto out_freedev_attr;
  
  	res = platform_get_resource_byname(plf, 0, "IRQ_AB8500");
  	if (!res) {
diff --cc drivers/mfd/htc-egpio.c
index bbaec0ccba8f,ad6e5b518669..000000000000
--- a/drivers/mfd/htc-egpio.c
+++ b/drivers/mfd/htc-egpio.c
@@@ -306,7 -321,9 +306,13 @@@ static int __init egpio_probe(struct pl
  	platform_set_drvdata(pdev, ei);
  
  	ei->nchips = pdata->num_chips;
++<<<<<<< HEAD:drivers/mfd/htc-egpio.c
 +	ei->chip = kzalloc(sizeof(struct egpio_chip) * ei->nchips, GFP_KERNEL);
++=======
+ 	ei->chip = devm_kcalloc(&pdev->dev,
+ 				ei->nchips, sizeof(struct egpio_chip),
+ 				GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc()):drivers/gpio/gpio-htc-egpio.c
  	if (!ei->chip) {
  		ret = -ENOMEM;
  		goto fail;
diff --cc drivers/mfd/htc-i2cpld.c
index 324187c0c124,01572b5e79e8..000000000000
--- a/drivers/mfd/htc-i2cpld.c
+++ b/drivers/mfd/htc-i2cpld.c
@@@ -514,12 -477,12 +514,20 @@@ static int htcpld_setup_chips(struct pl
  
  	/* Setup each chip's output GPIOs */
  	htcpld->nchips = pdata->num_chip;
++<<<<<<< HEAD
 +	htcpld->chip = kzalloc(sizeof(struct htcpld_chip) * htcpld->nchips,
 +			       GFP_KERNEL);
 +	if (!htcpld->chip) {
 +		dev_warn(dev, "Unable to allocate memory for chips\n");
++=======
+ 	htcpld->chip = devm_kcalloc(dev,
+ 				    htcpld->nchips,
+ 				    sizeof(struct htcpld_chip),
+ 				    GFP_KERNEL);
+ 	if (!htcpld->chip)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 +	}
  
  	/* Add the chips as best we can */
  	for (i = 0; i < htcpld->nchips; i++) {
diff --cc drivers/misc/sram.c
index 437192e43006,c5dc6095686a..000000000000
--- a/drivers/misc/sram.c
+++ b/drivers/misc/sram.c
@@@ -31,9 -35,321 +31,327 @@@
  
  #define SRAM_GRANULARITY	32
  
++<<<<<<< HEAD
 +struct sram_dev {
 +	struct gen_pool *pool;
 +	struct clk *clk;
++=======
+ static ssize_t sram_read(struct file *filp, struct kobject *kobj,
+ 			 struct bin_attribute *attr,
+ 			 char *buf, loff_t pos, size_t count)
+ {
+ 	struct sram_partition *part;
+ 
+ 	part = container_of(attr, struct sram_partition, battr);
+ 
+ 	mutex_lock(&part->lock);
+ 	memcpy_fromio(buf, part->base + pos, count);
+ 	mutex_unlock(&part->lock);
+ 
+ 	return count;
+ }
+ 
+ static ssize_t sram_write(struct file *filp, struct kobject *kobj,
+ 			  struct bin_attribute *attr,
+ 			  char *buf, loff_t pos, size_t count)
+ {
+ 	struct sram_partition *part;
+ 
+ 	part = container_of(attr, struct sram_partition, battr);
+ 
+ 	mutex_lock(&part->lock);
+ 	memcpy_toio(part->base + pos, buf, count);
+ 	mutex_unlock(&part->lock);
+ 
+ 	return count;
+ }
+ 
+ static int sram_add_pool(struct sram_dev *sram, struct sram_reserve *block,
+ 			 phys_addr_t start, struct sram_partition *part)
+ {
+ 	int ret;
+ 
+ 	part->pool = devm_gen_pool_create(sram->dev, ilog2(SRAM_GRANULARITY),
+ 					  NUMA_NO_NODE, block->label);
+ 	if (IS_ERR(part->pool))
+ 		return PTR_ERR(part->pool);
+ 
+ 	ret = gen_pool_add_virt(part->pool, (unsigned long)part->base, start,
+ 				block->size, NUMA_NO_NODE);
+ 	if (ret < 0) {
+ 		dev_err(sram->dev, "failed to register subpool: %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int sram_add_export(struct sram_dev *sram, struct sram_reserve *block,
+ 			   phys_addr_t start, struct sram_partition *part)
+ {
+ 	sysfs_bin_attr_init(&part->battr);
+ 	part->battr.attr.name = devm_kasprintf(sram->dev, GFP_KERNEL,
+ 					       "%llx.sram",
+ 					       (unsigned long long)start);
+ 	if (!part->battr.attr.name)
+ 		return -ENOMEM;
+ 
+ 	part->battr.attr.mode = S_IRUSR | S_IWUSR;
+ 	part->battr.read = sram_read;
+ 	part->battr.write = sram_write;
+ 	part->battr.size = block->size;
+ 
+ 	return device_create_bin_file(sram->dev, &part->battr);
+ }
+ 
+ static int sram_add_partition(struct sram_dev *sram, struct sram_reserve *block,
+ 			      phys_addr_t start)
+ {
+ 	int ret;
+ 	struct sram_partition *part = &sram->partition[sram->partitions];
+ 
+ 	mutex_init(&part->lock);
+ 	part->base = sram->virt_base + block->start;
+ 
+ 	if (block->pool) {
+ 		ret = sram_add_pool(sram, block, start, part);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 	if (block->export) {
+ 		ret = sram_add_export(sram, block, start, part);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 	if (block->protect_exec) {
+ 		ret = sram_check_protect_exec(sram, block, part);
+ 		if (ret)
+ 			return ret;
+ 
+ 		ret = sram_add_pool(sram, block, start, part);
+ 		if (ret)
+ 			return ret;
+ 
+ 		sram_add_protect_exec(part);
+ 	}
+ 
+ 	sram->partitions++;
+ 
+ 	return 0;
+ }
+ 
+ static void sram_free_partitions(struct sram_dev *sram)
+ {
+ 	struct sram_partition *part;
+ 
+ 	if (!sram->partitions)
+ 		return;
+ 
+ 	part = &sram->partition[sram->partitions - 1];
+ 	for (; sram->partitions; sram->partitions--, part--) {
+ 		if (part->battr.size)
+ 			device_remove_bin_file(sram->dev, &part->battr);
+ 
+ 		if (part->pool &&
+ 		    gen_pool_avail(part->pool) < gen_pool_size(part->pool))
+ 			dev_err(sram->dev, "removed pool while SRAM allocated\n");
+ 	}
+ }
+ 
+ static int sram_reserve_cmp(void *priv, struct list_head *a,
+ 					struct list_head *b)
+ {
+ 	struct sram_reserve *ra = list_entry(a, struct sram_reserve, list);
+ 	struct sram_reserve *rb = list_entry(b, struct sram_reserve, list);
+ 
+ 	return ra->start - rb->start;
+ }
+ 
+ static int sram_reserve_regions(struct sram_dev *sram, struct resource *res)
+ {
+ 	struct device_node *np = sram->dev->of_node, *child;
+ 	unsigned long size, cur_start, cur_size;
+ 	struct sram_reserve *rblocks, *block;
+ 	struct list_head reserve_list;
+ 	unsigned int nblocks, exports = 0;
+ 	const char *label;
+ 	int ret = 0;
+ 
+ 	INIT_LIST_HEAD(&reserve_list);
+ 
+ 	size = resource_size(res);
+ 
+ 	/*
+ 	 * We need an additional block to mark the end of the memory region
+ 	 * after the reserved blocks from the dt are processed.
+ 	 */
+ 	nblocks = (np) ? of_get_available_child_count(np) + 1 : 1;
+ 	rblocks = kcalloc(nblocks, sizeof(*rblocks), GFP_KERNEL);
+ 	if (!rblocks)
+ 		return -ENOMEM;
+ 
+ 	block = &rblocks[0];
+ 	for_each_available_child_of_node(np, child) {
+ 		struct resource child_res;
+ 
+ 		ret = of_address_to_resource(child, 0, &child_res);
+ 		if (ret < 0) {
+ 			dev_err(sram->dev,
+ 				"could not get address for node %pOF\n",
+ 				child);
+ 			goto err_chunks;
+ 		}
+ 
+ 		if (child_res.start < res->start || child_res.end > res->end) {
+ 			dev_err(sram->dev,
+ 				"reserved block %pOF outside the sram area\n",
+ 				child);
+ 			ret = -EINVAL;
+ 			goto err_chunks;
+ 		}
+ 
+ 		block->start = child_res.start - res->start;
+ 		block->size = resource_size(&child_res);
+ 		list_add_tail(&block->list, &reserve_list);
+ 
+ 		if (of_find_property(child, "export", NULL))
+ 			block->export = true;
+ 
+ 		if (of_find_property(child, "pool", NULL))
+ 			block->pool = true;
+ 
+ 		if (of_find_property(child, "protect-exec", NULL))
+ 			block->protect_exec = true;
+ 
+ 		if ((block->export || block->pool || block->protect_exec) &&
+ 		    block->size) {
+ 			exports++;
+ 
+ 			label = NULL;
+ 			ret = of_property_read_string(child, "label", &label);
+ 			if (ret && ret != -EINVAL) {
+ 				dev_err(sram->dev,
+ 					"%pOF has invalid label name\n",
+ 					child);
+ 				goto err_chunks;
+ 			}
+ 			if (!label)
+ 				label = child->name;
+ 
+ 			block->label = devm_kstrdup(sram->dev,
+ 						    label, GFP_KERNEL);
+ 			if (!block->label) {
+ 				ret = -ENOMEM;
+ 				goto err_chunks;
+ 			}
+ 
+ 			dev_dbg(sram->dev, "found %sblock '%s' 0x%x-0x%x\n",
+ 				block->export ? "exported " : "", block->label,
+ 				block->start, block->start + block->size);
+ 		} else {
+ 			dev_dbg(sram->dev, "found reserved block 0x%x-0x%x\n",
+ 				block->start, block->start + block->size);
+ 		}
+ 
+ 		block++;
+ 	}
+ 	child = NULL;
+ 
+ 	/* the last chunk marks the end of the region */
+ 	rblocks[nblocks - 1].start = size;
+ 	rblocks[nblocks - 1].size = 0;
+ 	list_add_tail(&rblocks[nblocks - 1].list, &reserve_list);
+ 
+ 	list_sort(NULL, &reserve_list, sram_reserve_cmp);
+ 
+ 	if (exports) {
+ 		sram->partition = devm_kcalloc(sram->dev,
+ 				       exports, sizeof(*sram->partition),
+ 				       GFP_KERNEL);
+ 		if (!sram->partition) {
+ 			ret = -ENOMEM;
+ 			goto err_chunks;
+ 		}
+ 	}
+ 
+ 	cur_start = 0;
+ 	list_for_each_entry(block, &reserve_list, list) {
+ 		/* can only happen if sections overlap */
+ 		if (block->start < cur_start) {
+ 			dev_err(sram->dev,
+ 				"block at 0x%x starts after current offset 0x%lx\n",
+ 				block->start, cur_start);
+ 			ret = -EINVAL;
+ 			sram_free_partitions(sram);
+ 			goto err_chunks;
+ 		}
+ 
+ 		if ((block->export || block->pool || block->protect_exec) &&
+ 		    block->size) {
+ 			ret = sram_add_partition(sram, block,
+ 						 res->start + block->start);
+ 			if (ret) {
+ 				sram_free_partitions(sram);
+ 				goto err_chunks;
+ 			}
+ 		}
+ 
+ 		/* current start is in a reserved block, so continue after it */
+ 		if (block->start == cur_start) {
+ 			cur_start = block->start + block->size;
+ 			continue;
+ 		}
+ 
+ 		/*
+ 		 * allocate the space between the current starting
+ 		 * address and the following reserved block, or the
+ 		 * end of the region.
+ 		 */
+ 		cur_size = block->start - cur_start;
+ 
+ 		dev_dbg(sram->dev, "adding chunk 0x%lx-0x%lx\n",
+ 			cur_start, cur_start + cur_size);
+ 
+ 		ret = gen_pool_add_virt(sram->pool,
+ 				(unsigned long)sram->virt_base + cur_start,
+ 				res->start + cur_start, cur_size, -1);
+ 		if (ret < 0) {
+ 			sram_free_partitions(sram);
+ 			goto err_chunks;
+ 		}
+ 
+ 		/* next allocation after this reserved block */
+ 		cur_start = block->start + block->size;
+ 	}
+ 
+  err_chunks:
+ 	if (child)
+ 		of_node_put(child);
+ 
+ 	kfree(rblocks);
+ 
+ 	return ret;
+ }
+ 
+ static int atmel_securam_wait(void)
+ {
+ 	struct regmap *regmap;
+ 	u32 val;
+ 
+ 	regmap = syscon_regmap_lookup_by_compatible("atmel,sama5d2-secumod");
+ 	if (IS_ERR(regmap))
+ 		return -ENODEV;
+ 
+ 	return regmap_read_poll_timeout(regmap, AT91_SECUMOD_RAMRDY, val,
+ 					val & AT91_SECUMOD_RAMRDY_READY,
+ 					10000, 500000);
+ }
+ 
+ static const struct of_device_id sram_dt_ids[] = {
+ 	{ .compatible = "mmio-sram" },
+ 	{ .compatible = "atmel,sama5d2-securam", .data = atmel_securam_wait },
+ 	{}
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  };
  
  static int sram_probe(struct platform_device *pdev)
diff --cc drivers/mtd/devices/docg3.c
index 3e1b0a0ef4db,512bd4c2eec0..000000000000
--- a/drivers/mtd/devices/docg3.c
+++ b/drivers/mtd/devices/docg3.c
@@@ -2047,15 -1988,15 +2047,20 @@@ static int __init docg3_probe(struct pl
  	ress = platform_get_resource(pdev, IORESOURCE_MEM, 0);
  	if (!ress) {
  		dev_err(dev, "No I/O memory resource defined\n");
 -		return ret;
 +		goto noress;
  	}
 -	base = devm_ioremap(dev, ress->start, DOC_IOSPACE_SIZE);
 +	base = ioremap(ress->start, DOC_IOSPACE_SIZE);
  
  	ret = -ENOMEM;
++<<<<<<< HEAD
 +	cascade = kzalloc(sizeof(*cascade) * DOC_MAX_NBFLOORS,
 +			  GFP_KERNEL);
++=======
+ 	cascade = devm_kcalloc(dev, DOC_MAX_NBFLOORS, sizeof(*cascade),
+ 			       GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	if (!cascade)
 -		return ret;
 +		goto nomem1;
  	cascade->base = base;
  	mutex_init(&cascade->lock);
  	cascade->bch = init_bch(DOC_ECC_BCH_M, DOC_ECC_BCH_T,
diff --cc drivers/mtd/nand/s3c2410.c
index d65afd23e171,19661c5d3220..000000000000
--- a/drivers/mtd/nand/s3c2410.c
+++ b/drivers/mtd/nand/s3c2410.c
@@@ -884,15 -974,97 +884,92 @@@ static void s3c2410_nand_update_chip(st
  
  		/* change the behaviour depending on whether we are using
  		 * the large or small page nand device */
 -		if (chip->page_shift > 10) {
 -			chip->ecc.size	    = 256;
 -			chip->ecc.bytes	    = 3;
 -		} else {
 -			chip->ecc.size	    = 512;
 -			chip->ecc.bytes	    = 3;
 -			mtd_set_ooblayout(nand_to_mtd(chip),
 -					  &s3c2410_ooblayout_ops);
 -		}
 -
 -		dev_info(info->device, "hardware ECC\n");
 -		break;
  
 -	default:
 -		dev_err(info->device, "invalid ECC mode!\n");
 -		return -EINVAL;
 +	if (chip->page_shift > 10) {
 +		chip->ecc.size	    = 256;
 +		chip->ecc.bytes	    = 3;
 +	} else {
 +		chip->ecc.size	    = 512;
 +		chip->ecc.bytes	    = 3;
 +		chip->ecc.layout    = &nand_hw_eccoob;
  	}
++<<<<<<< HEAD:drivers/mtd/nand/s3c2410.c
++=======
+ 
+ 	if (chip->bbt_options & NAND_BBT_USE_FLASH)
+ 		chip->options |= NAND_SKIP_BBTSCAN;
+ 
+ 	return 0;
+ }
+ 
+ static const struct of_device_id s3c24xx_nand_dt_ids[] = {
+ 	{
+ 		.compatible = "samsung,s3c2410-nand",
+ 		.data = &s3c2410_nand_devtype_data,
+ 	}, {
+ 		/* also compatible with s3c6400 */
+ 		.compatible = "samsung,s3c2412-nand",
+ 		.data = &s3c2412_nand_devtype_data,
+ 	}, {
+ 		.compatible = "samsung,s3c2440-nand",
+ 		.data = &s3c2440_nand_devtype_data,
+ 	},
+ 	{ /* sentinel */ }
+ };
+ MODULE_DEVICE_TABLE(of, s3c24xx_nand_dt_ids);
+ 
+ static int s3c24xx_nand_probe_dt(struct platform_device *pdev)
+ {
+ 	const struct s3c24XX_nand_devtype_data *devtype_data;
+ 	struct s3c2410_platform_nand *pdata;
+ 	struct s3c2410_nand_info *info = platform_get_drvdata(pdev);
+ 	struct device_node *np = pdev->dev.of_node, *child;
+ 	struct s3c2410_nand_set *sets;
+ 
+ 	devtype_data = of_device_get_match_data(&pdev->dev);
+ 	if (!devtype_data)
+ 		return -ENODEV;
+ 
+ 	info->cpu_type = devtype_data->type;
+ 
+ 	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+ 	if (!pdata)
+ 		return -ENOMEM;
+ 
+ 	pdev->dev.platform_data = pdata;
+ 
+ 	pdata->nr_sets = of_get_child_count(np);
+ 	if (!pdata->nr_sets)
+ 		return 0;
+ 
+ 	sets = devm_kcalloc(&pdev->dev, pdata->nr_sets, sizeof(*sets),
+ 			    GFP_KERNEL);
+ 	if (!sets)
+ 		return -ENOMEM;
+ 
+ 	pdata->sets = sets;
+ 
+ 	for_each_available_child_of_node(np, child) {
+ 		sets->name = (char *)child->name;
+ 		sets->of_node = child;
+ 		sets->nr_chips = 1;
+ 
+ 		of_node_get(child);
+ 
+ 		sets++;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int s3c24xx_nand_probe_pdata(struct platform_device *pdev)
+ {
+ 	struct s3c2410_nand_info *info = platform_get_drvdata(pdev);
+ 
+ 	info->cpu_type = platform_get_device_id(pdev)->driver_data;
+ 
+ 	return 0;
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc()):drivers/mtd/nand/raw/s3c2410.c
  }
  
  /* s3c24xx_nand_probe
diff --cc drivers/net/ethernet/ti/cpsw.c
index 11a2c779af33,358edab9e72e..000000000000
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@@ -1464,29 -2740,16 +1464,36 @@@ static int cpsw_probe_dt(struct cpsw_pl
  	}
  	data->active_slave = prop;
  
++<<<<<<< HEAD
 +	if (of_property_read_u32(node, "cpts_clock_mult", &prop)) {
 +		pr_err("Missing cpts_clock_mult property in the DT.\n");
 +		ret = -EINVAL;
 +		goto error_ret;
 +	}
 +	data->cpts_clock_mult = prop;
 +
 +	if (of_property_read_u32(node, "cpts_clock_shift", &prop)) {
 +		pr_err("Missing cpts_clock_shift property in the DT.\n");
 +		ret = -EINVAL;
 +		goto error_ret;
 +	}
 +	data->cpts_clock_shift = prop;
 +
 +	data->slave_data = kcalloc(data->slaves, sizeof(struct cpsw_slave_data),
 +				   GFP_KERNEL);
++=======
+ 	data->slave_data = devm_kcalloc(&pdev->dev,
+ 					data->slaves,
+ 					sizeof(struct cpsw_slave_data),
+ 					GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	if (!data->slave_data)
 -		return -ENOMEM;
 +		return -EINVAL;
  
  	if (of_property_read_u32(node, "cpdma_channels", &prop)) {
 -		dev_err(&pdev->dev, "Missing cpdma_channels property in the DT.\n");
 -		return -EINVAL;
 +		pr_err("Missing cpdma_channels property in the DT.\n");
 +		ret = -EINVAL;
 +		goto error_ret;
  	}
  	data->channels = prop;
  
@@@ -1706,67 -3046,43 +1713,76 @@@ static int cpsw_probe(struct platform_d
  
  	memcpy(ndev->dev_addr, priv->mac_addr, ETH_ALEN);
  
++<<<<<<< HEAD
 +	priv->slaves = kzalloc(sizeof(struct cpsw_slave) * data->slaves,
 +			       GFP_KERNEL);
 +	if (!priv->slaves) {
 +		ret = -EBUSY;
 +		goto clean_ndev_ret;
++=======
+ 	cpsw->slaves = devm_kcalloc(&pdev->dev,
+ 				    data->slaves, sizeof(struct cpsw_slave),
+ 				    GFP_KERNEL);
+ 	if (!cpsw->slaves) {
+ 		ret = -ENOMEM;
+ 		goto clean_dt_ret;
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	}
  	for (i = 0; i < data->slaves; i++)
 -		cpsw->slaves[i].slave_num = i;
 +		priv->slaves[i].slave_num = i;
  
 -	cpsw->slaves[0].ndev = ndev;
 +	priv->slaves[0].ndev = ndev;
  	priv->emac_port = 0;
  
 -	clk = devm_clk_get(&pdev->dev, "fck");
 -	if (IS_ERR(clk)) {
 -		dev_err(priv->dev, "fck is not found\n");
 +	priv->clk = clk_get(&pdev->dev, "fck");
 +	if (IS_ERR(priv->clk)) {
 +		dev_err(&pdev->dev, "fck is not found\n");
  		ret = -ENODEV;
 -		goto clean_dt_ret;
 -	}
 -	cpsw->bus_freq_mhz = clk_get_rate(clk) / 1000000;
 -
 -	ss_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	ss_regs = devm_ioremap_resource(&pdev->dev, ss_res);
 -	if (IS_ERR(ss_regs)) {
 -		ret = PTR_ERR(ss_regs);
 -		goto clean_dt_ret;
 -	}
 -	cpsw->regs = ss_regs;
 -
 -	cpsw->version = readl(&cpsw->regs->id_ver);
 -
 -	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
 -	cpsw->wr_regs = devm_ioremap_resource(&pdev->dev, res);
 -	if (IS_ERR(cpsw->wr_regs)) {
 -		ret = PTR_ERR(cpsw->wr_regs);
 -		goto clean_dt_ret;
 -	}
 +		goto clean_slave_ret;
 +	}
 +	priv->coal_intvl = 0;
 +	priv->bus_freq_mhz = clk_get_rate(priv->clk) / 1000000;
 +
 +	priv->cpsw_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 +	if (!priv->cpsw_res) {
 +		dev_err(priv->dev, "error getting i/o resource\n");
 +		ret = -ENOENT;
 +		goto clean_clk_ret;
 +	}
 +	if (!request_mem_region(priv->cpsw_res->start,
 +				resource_size(priv->cpsw_res), ndev->name)) {
 +		dev_err(priv->dev, "failed request i/o region\n");
 +		ret = -ENXIO;
 +		goto clean_clk_ret;
 +	}
 +	ss_regs = ioremap(priv->cpsw_res->start, resource_size(priv->cpsw_res));
 +	if (!ss_regs) {
 +		dev_err(priv->dev, "unable to map i/o region\n");
 +		goto clean_cpsw_iores_ret;
 +	}
 +	priv->regs = ss_regs;
 +	priv->version = __raw_readl(&priv->regs->id_ver);
 +	priv->host_port = HOST_PORT_NUM;
 +
 +	priv->cpsw_wr_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
 +	if (!priv->cpsw_wr_res) {
 +		dev_err(priv->dev, "error getting i/o resource\n");
 +		ret = -ENOENT;
 +		goto clean_iomap_ret;
 +	}
 +	if (!request_mem_region(priv->cpsw_wr_res->start,
 +			resource_size(priv->cpsw_wr_res), ndev->name)) {
 +		dev_err(priv->dev, "failed request i/o region\n");
 +		ret = -ENXIO;
 +		goto clean_iomap_ret;
 +	}
 +	wr_regs = ioremap(priv->cpsw_wr_res->start,
 +				resource_size(priv->cpsw_wr_res));
 +	if (!wr_regs) {
 +		dev_err(priv->dev, "unable to map i/o region\n");
 +		goto clean_cpsw_wr_iores_ret;
 +	}
 +	priv->wr_regs = wr_regs;
  
  	memset(&dma_params, 0, sizeof(dma_params));
  	memset(&ale_params, 0, sizeof(ale_params));
diff --cc drivers/pinctrl/mvebu/pinctrl-mvebu.c
index cfed9312050c,d7ec7119701b..000000000000
--- a/drivers/pinctrl/mvebu/pinctrl-mvebu.c
+++ b/drivers/pinctrl/mvebu/pinctrl-mvebu.c
@@@ -627,34 -611,25 +629,42 @@@ int mvebu_pinctrl_probe(struct platform
  		for (k = 0; k < ctrl->npins; k++)
  			ctrl->pins[k] = ctrl->pid + k;
  
 -		/*
 -		 * We allow to pass controls with NULL name that we treat
 -		 * as a range of one-pin groups with generic mvebu register
 -		 * controls.
 -		 */
 -		if (!ctrl->name) {
 -			pctl->num_groups += ctrl->npins;
 -			noname += ctrl->npins;
 -		} else {
 +		/* special soc specific control */
 +		if (ctrl->mpp_get || ctrl->mpp_set) {
 +			if (!ctrl->name || !ctrl->mpp_get || !ctrl->mpp_set) {
 +				dev_err(&pdev->dev, "wrong soc control info\n");
 +				return -EINVAL;
 +			}
  			pctl->num_groups += 1;
 +			continue;
 +		}
 +
 +		/* generic mvebu register control */
 +		names = devm_kzalloc(&pdev->dev, ctrl->npins * 8, GFP_KERNEL);
 +		if (!names) {
 +			dev_err(&pdev->dev, "failed to alloc mpp names\n");
 +			return -ENOMEM;
  		}
 +		for (k = 0; k < ctrl->npins; k++)
 +			sprintf(names + 8*k, "mpp%d", ctrl->pid+k);
 +		ctrl->name = names;
 +		pctl->num_groups += ctrl->npins;
  	}
  
++<<<<<<< HEAD
 +	pdesc = devm_kzalloc(&pdev->dev, pctl->desc.npins *
 +			     sizeof(struct pinctrl_pin_desc), GFP_KERNEL);
 +	if (!pdesc) {
 +		dev_err(&pdev->dev, "failed to alloc pinctrl pins\n");
++=======
+ 	pdesc = devm_kcalloc(&pdev->dev,
+ 			     pctl->desc.npins,
+ 			     sizeof(struct pinctrl_pin_desc),
+ 			     GFP_KERNEL);
+ 	if (!pdesc)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 +	}
  
  	for (n = 0; n < pctl->desc.npins; n++)
  		pdesc[n].number = n;
diff --cc drivers/pinctrl/pinctrl-at91.c
index d0a984263840,50f0ec42c637..000000000000
--- a/drivers/pinctrl/pinctrl-at91.c
+++ b/drivers/pinctrl/pinctrl-at91.c
@@@ -820,17 -1044,16 +821,23 @@@ static int at91_pinctrl_mux_mask(struc
  	}
  
  	size /= sizeof(*list);
 -	if (!size || size % gpio_banks) {
 -		dev_err(info->dev, "wrong mux mask array should be by %d\n", gpio_banks);
 +	if (!size || size % info->nbanks) {
 +		dev_err(info->dev, "wrong mux mask array should be by %d\n", info->nbanks);
  		return -EINVAL;
  	}
 -	info->nmux = size / gpio_banks;
 +	info->nmux = size / info->nbanks;
  
++<<<<<<< HEAD
 +	info->mux_mask = devm_kzalloc(info->dev, sizeof(u32) * size, GFP_KERNEL);
 +	if (!info->mux_mask) {
 +		dev_err(info->dev, "could not alloc mux_mask\n");
++=======
+ 	info->mux_mask = devm_kcalloc(info->dev, size, sizeof(u32),
+ 				      GFP_KERNEL);
+ 	if (!info->mux_mask)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 +	}
  
  	ret = of_property_read_u32_array(np, "atmel,mux-mask",
  					  info->mux_mask, size);
@@@ -1025,9 -1262,11 +1038,11 @@@ static int at91_pinctrl_probe(struct pl
  	}
  
  	at91_pinctrl_desc.name = dev_name(&pdev->dev);
 -	at91_pinctrl_desc.npins = gpio_banks * MAX_NB_GPIO_PER_BANK;
 +	at91_pinctrl_desc.npins = info->nbanks * MAX_NB_GPIO_PER_BANK;
  	at91_pinctrl_desc.pins = pdesc =
- 		devm_kzalloc(&pdev->dev, sizeof(*pdesc) * at91_pinctrl_desc.npins, GFP_KERNEL);
+ 		devm_kcalloc(&pdev->dev,
+ 			     at91_pinctrl_desc.npins, sizeof(*pdesc),
+ 			     GFP_KERNEL);
  
  	if (!at91_pinctrl_desc.pins)
  		return -ENOMEM;
diff --cc drivers/pinctrl/pinctrl-single.c
index da554b246255,b3153c095199..000000000000
--- a/drivers/pinctrl/pinctrl-single.c
+++ b/drivers/pinctrl/pinctrl-single.c
@@@ -777,13 -699,21 +777,13 @@@ static int pcs_add_pin(struct pcs_devic
  static int pcs_allocate_pin_table(struct pcs_device *pcs)
  {
  	int mux_bytes, nr_pins, i;
 -	int num_pins_in_register = 0;
  
  	mux_bytes = pcs->width / BITS_PER_BYTE;
 -
 -	if (pcs->bits_per_mux) {
 -		pcs->bits_per_pin = fls(pcs->fmask);
 -		nr_pins = (pcs->size * BITS_PER_BYTE) / pcs->bits_per_pin;
 -		num_pins_in_register = pcs->width / pcs->bits_per_pin;
 -	} else {
 -		nr_pins = pcs->size / mux_bytes;
 -	}
 +	nr_pins = pcs->size / mux_bytes;
  
  	dev_dbg(pcs->dev, "allocating %i pins\n", nr_pins);
- 	pcs->pins.pa = devm_kzalloc(pcs->dev,
- 				sizeof(*pcs->pins.pa) * nr_pins,
+ 	pcs->pins.pa = devm_kcalloc(pcs->dev,
+ 				nr_pins, sizeof(*pcs->pins.pa),
  				GFP_KERNEL);
  	if (!pcs->pins.pa)
  		return -ENOMEM;
@@@ -1095,33 -977,18 +1095,37 @@@ static int pcs_parse_one_pinctrl_entry(
  						unsigned *num_maps,
  						const char **pgnames)
  {
 -	const char *name = "pinctrl-single,pins";
  	struct pcs_func_vals *vals;
 -	int rows, *pins, found = 0, res = -ENOMEM, i;
 +	const __be32 *mux;
 +	int size, params, rows, *pins, index = 0, found = 0, res = -ENOMEM;
  	struct pcs_function *function;
  
 -	rows = pinctrl_count_index_with_args(np, name);
 -	if (rows <= 0) {
 -		dev_err(pcs->dev, "Invalid number of rows: %d\n", rows);
 +	if (pcs->bits_per_mux) {
 +		params = 3;
 +		mux = of_get_property(np, PCS_MUX_BITS_NAME, &size);
 +	} else {
 +		params = 2;
 +		mux = of_get_property(np, PCS_MUX_PINS_NAME, &size);
 +	}
 +
 +	if (!mux) {
 +		dev_err(pcs->dev, "no valid property for %s\n", np->name);
 +		return -EINVAL;
 +	}
 +
++<<<<<<< HEAD
 +	if (size < (sizeof(*mux) * params)) {
 +		dev_err(pcs->dev, "bad data for %s\n", np->name);
  		return -EINVAL;
  	}
  
 +	size /= sizeof(*mux);	/* Number of elements in array */
 +	rows = size / params;
 +
 +	vals = devm_kzalloc(pcs->dev, sizeof(*vals) * rows, GFP_KERNEL);
++=======
+ 	vals = devm_kcalloc(pcs->dev, rows, sizeof(*vals), GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	if (!vals)
  		return -ENOMEM;
  
@@@ -1189,6 -1068,139 +1193,142 @@@ free_vals
  
  	return res;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int pcs_parse_bits_in_pinctrl_entry(struct pcs_device *pcs,
+ 						struct device_node *np,
+ 						struct pinctrl_map **map,
+ 						unsigned *num_maps,
+ 						const char **pgnames)
+ {
+ 	const char *name = "pinctrl-single,bits";
+ 	struct pcs_func_vals *vals;
+ 	int rows, *pins, found = 0, res = -ENOMEM, i;
+ 	int npins_in_row;
+ 	struct pcs_function *function;
+ 
+ 	rows = pinctrl_count_index_with_args(np, name);
+ 	if (rows <= 0) {
+ 		dev_err(pcs->dev, "Invalid number of rows: %d\n", rows);
+ 		return -EINVAL;
+ 	}
+ 
+ 	npins_in_row = pcs->width / pcs->bits_per_pin;
+ 
+ 	vals = devm_kzalloc(pcs->dev,
+ 			    array3_size(rows, npins_in_row, sizeof(*vals)),
+ 			    GFP_KERNEL);
+ 	if (!vals)
+ 		return -ENOMEM;
+ 
+ 	pins = devm_kzalloc(pcs->dev,
+ 			    array3_size(rows, npins_in_row, sizeof(*pins)),
+ 			    GFP_KERNEL);
+ 	if (!pins)
+ 		goto free_vals;
+ 
+ 	for (i = 0; i < rows; i++) {
+ 		struct of_phandle_args pinctrl_spec;
+ 		unsigned offset, val;
+ 		unsigned mask, bit_pos, val_pos, mask_pos, submask;
+ 		unsigned pin_num_from_lsb;
+ 		int pin;
+ 
+ 		res = pinctrl_parse_index_with_args(np, name, i, &pinctrl_spec);
+ 		if (res)
+ 			return res;
+ 
+ 		if (pinctrl_spec.args_count < 3) {
+ 			dev_err(pcs->dev, "invalid args_count for spec: %i\n",
+ 				pinctrl_spec.args_count);
+ 			break;
+ 		}
+ 
+ 		/* Index plus two value cells */
+ 		offset = pinctrl_spec.args[0];
+ 		val = pinctrl_spec.args[1];
+ 		mask = pinctrl_spec.args[2];
+ 
+ 		dev_dbg(pcs->dev, "%s index: 0x%x value: 0x%x mask: 0x%x\n",
+ 			pinctrl_spec.np->name, offset, val, mask);
+ 
+ 		/* Parse pins in each row from LSB */
+ 		while (mask) {
+ 			bit_pos = __ffs(mask);
+ 			pin_num_from_lsb = bit_pos / pcs->bits_per_pin;
+ 			mask_pos = ((pcs->fmask) << bit_pos);
+ 			val_pos = val & mask_pos;
+ 			submask = mask & mask_pos;
+ 
+ 			if ((mask & mask_pos) == 0) {
+ 				dev_err(pcs->dev,
+ 					"Invalid mask for %s at 0x%x\n",
+ 					np->name, offset);
+ 				break;
+ 			}
+ 
+ 			mask &= ~mask_pos;
+ 
+ 			if (submask != mask_pos) {
+ 				dev_warn(pcs->dev,
+ 						"Invalid submask 0x%x for %s at 0x%x\n",
+ 						submask, np->name, offset);
+ 				continue;
+ 			}
+ 
+ 			vals[found].mask = submask;
+ 			vals[found].reg = pcs->base + offset;
+ 			vals[found].val = val_pos;
+ 
+ 			pin = pcs_get_pin_by_offset(pcs, offset);
+ 			if (pin < 0) {
+ 				dev_err(pcs->dev,
+ 					"could not add functions for %s %ux\n",
+ 					np->name, offset);
+ 				break;
+ 			}
+ 			pins[found++] = pin + pin_num_from_lsb;
+ 		}
+ 	}
+ 
+ 	pgnames[0] = np->name;
+ 	function = pcs_add_function(pcs, np, np->name, vals, found, pgnames, 1);
+ 	if (!function) {
+ 		res = -ENOMEM;
+ 		goto free_pins;
+ 	}
+ 
+ 	res = pinctrl_generic_add_group(pcs->pctl, np->name, pins, found, pcs);
+ 	if (res < 0)
+ 		goto free_function;
+ 
+ 	(*map)->type = PIN_MAP_TYPE_MUX_GROUP;
+ 	(*map)->data.mux.group = np->name;
+ 	(*map)->data.mux.function = np->name;
+ 
+ 	if (PCS_HAS_PINCONF) {
+ 		dev_err(pcs->dev, "pinconf not supported\n");
+ 		goto free_pingroups;
+ 	}
+ 
+ 	*num_maps = 1;
+ 	return 0;
+ 
+ free_pingroups:
+ 	pinctrl_generic_remove_last_group(pcs->pctl);
+ 	*num_maps = 1;
+ free_function:
+ 	pinmux_generic_remove_last_function(pcs->pctl);
+ free_pins:
+ 	devm_kfree(pcs->dev, pins);
+ 
+ free_vals:
+ 	devm_kfree(pcs->dev, vals);
+ 
+ 	return res;
+ }
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  /**
   * pcs_dt_node_to_map() - allocates and parses pinctrl maps
   * @pctldev: pinctrl instance
diff --cc drivers/pinctrl/pinctrl-tegra.c
index e1f705a0cfb6,f974eee29a19..000000000000
--- a/drivers/pinctrl/pinctrl-tegra.c
+++ b/drivers/pinctrl/pinctrl-tegra.c
@@@ -716,6 -661,41 +716,44 @@@ int tegra_pinctrl_probe(struct platform
  	pmx->dev = &pdev->dev;
  	pmx->soc = soc_data;
  
++<<<<<<< HEAD:drivers/pinctrl/pinctrl-tegra.c
++=======
+ 	/*
+ 	 * Each mux group will appear in 4 functions' list of groups.
+ 	 * This over-allocates slightly, since not all groups are mux groups.
+ 	 */
+ 	pmx->group_pins = devm_kcalloc(&pdev->dev,
+ 		soc_data->ngroups * 4, sizeof(*pmx->group_pins),
+ 		GFP_KERNEL);
+ 	if (!pmx->group_pins)
+ 		return -ENOMEM;
+ 
+ 	group_pins = pmx->group_pins;
+ 	for (fn = 0; fn < soc_data->nfunctions; fn++) {
+ 		struct tegra_function *func = &soc_data->functions[fn];
+ 
+ 		func->groups = group_pins;
+ 
+ 		for (gn = 0; gn < soc_data->ngroups; gn++) {
+ 			const struct tegra_pingroup *g = &soc_data->groups[gn];
+ 
+ 			if (g->mux_reg == -1)
+ 				continue;
+ 
+ 			for (gfn = 0; gfn < 4; gfn++)
+ 				if (g->funcs[gfn] == fn)
+ 					break;
+ 			if (gfn == 4)
+ 				continue;
+ 
+ 			BUG_ON(group_pins - pmx->group_pins >=
+ 				soc_data->ngroups * 4);
+ 			*group_pins++ = g->name;
+ 			func->ngroups++;
+ 		}
+ 	}
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc()):drivers/pinctrl/tegra/pinctrl-tegra.c
  	tegra_pinctrl_gpio_range.npins = pmx->soc->ngpios;
  	tegra_pinctrl_desc.name = dev_name(&pdev->dev);
  	tegra_pinctrl_desc.pins = pmx->soc->pins;
@@@ -728,12 -708,10 +766,12 @@@
  	}
  	pmx->nbanks = i;
  
- 	pmx->regs = devm_kzalloc(&pdev->dev, pmx->nbanks * sizeof(*pmx->regs),
+ 	pmx->regs = devm_kcalloc(&pdev->dev, pmx->nbanks, sizeof(*pmx->regs),
  				 GFP_KERNEL);
 -	if (!pmx->regs)
 -		return -ENOMEM;
 +	if (!pmx->regs) {
 +		dev_err(&pdev->dev, "Can't alloc regs pointer\n");
 +		return -ENODEV;
 +	}
  
  	for (i = 0; i < pmx->nbanks; i++) {
  		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
diff --cc drivers/pinctrl/sh-pfc/core.c
index b551336924a5,c671c3c4aca6..000000000000
--- a/drivers/pinctrl/sh-pfc/core.c
+++ b/drivers/pinctrl/sh-pfc/core.c
@@@ -24,31 -29,65 +24,45 @@@
  
  #include "core.h"
  
 -static int sh_pfc_map_resources(struct sh_pfc *pfc,
 -				struct platform_device *pdev)
 +static int sh_pfc_ioremap(struct sh_pfc *pfc, struct platform_device *pdev)
  {
 -	unsigned int num_windows, num_irqs;
 -	struct sh_pfc_window *windows;
 -	unsigned int *irqs = NULL;
  	struct resource *res;
 -	unsigned int i;
 -	int irq;
 +	int k;
  
 -	/* Count the MEM and IRQ resources. */
 -	for (num_windows = 0;; num_windows++) {
 -		res = platform_get_resource(pdev, IORESOURCE_MEM, num_windows);
 -		if (!res)
 -			break;
 -	}
 -	for (num_irqs = 0;; num_irqs++) {
 -		irq = platform_get_irq(pdev, num_irqs);
 -		if (irq == -EPROBE_DEFER)
 -			return irq;
 -		if (irq < 0)
 -			break;
 -	}
 -
 -	if (num_windows == 0)
 +	if (pdev->num_resources == 0)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	pfc->window = devm_kzalloc(pfc->dev, pdev->num_resources *
 +				   sizeof(*pfc->window), GFP_NOWAIT);
 +	if (!pfc->window)
++=======
+ 	/* Allocate memory windows and IRQs arrays. */
+ 	windows = devm_kcalloc(pfc->dev, num_windows, sizeof(*windows),
+ 			       GFP_KERNEL);
+ 	if (windows == NULL)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
  
 -	pfc->num_windows = num_windows;
 -	pfc->windows = windows;
 -
 +	pfc->num_windows = pdev->num_resources;
 +
++<<<<<<< HEAD
 +	for (k = 0, res = pdev->resource; k < pdev->num_resources; k++, res++) {
 +		WARN_ON(resource_type(res) != IORESOURCE_MEM);
 +		pfc->window[k].phys = res->start;
 +		pfc->window[k].size = resource_size(res);
 +		pfc->window[k].virt = devm_ioremap_nocache(pfc->dev, res->start,
 +							   resource_size(res));
 +		if (!pfc->window[k].virt)
++=======
+ 	if (num_irqs) {
+ 		irqs = devm_kcalloc(pfc->dev, num_irqs, sizeof(*irqs),
+ 				    GFP_KERNEL);
+ 		if (irqs == NULL)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  			return -ENOMEM;
 -
 -		pfc->num_irqs = num_irqs;
 -		pfc->irqs = irqs;
  	}
  
 -	/* Fill them. */
 -	for (i = 0; i < num_windows; i++) {
 -		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
 -		windows->phys = res->start;
 -		windows->size = resource_size(res);
 -		windows->virt = devm_ioremap_resource(pfc->dev, res);
 -		if (IS_ERR(windows->virt))
 -			return -ENOMEM;
 -		windows++;
 -	}
 -	for (i = 0; i < num_irqs; i++)
 -		*irqs++ = platform_get_irq(pdev, i);
 -
  	return 0;
  }
  
@@@ -348,8 -390,315 +362,315 @@@ int sh_pfc_config_mux(struct sh_pfc *pf
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ const struct pinmux_bias_reg *
+ sh_pfc_pin_to_bias_reg(const struct sh_pfc *pfc, unsigned int pin,
+ 		       unsigned int *bit)
+ {
+ 	unsigned int i, j;
+ 
+ 	for (i = 0; pfc->info->bias_regs[i].puen; i++) {
+ 		for (j = 0; j < ARRAY_SIZE(pfc->info->bias_regs[i].pins); j++) {
+ 			if (pfc->info->bias_regs[i].pins[j] == pin) {
+ 				*bit = j;
+ 				return &pfc->info->bias_regs[i];
+ 			}
+ 		}
+ 	}
+ 
+ 	WARN_ONCE(1, "Pin %u is not in bias info list\n", pin);
+ 
+ 	return NULL;
+ }
+ 
+ static int sh_pfc_init_ranges(struct sh_pfc *pfc)
+ {
+ 	struct sh_pfc_pin_range *range;
+ 	unsigned int nr_ranges;
+ 	unsigned int i;
+ 
+ 	if (pfc->info->pins[0].pin == (u16)-1) {
+ 		/* Pin number -1 denotes that the SoC doesn't report pin numbers
+ 		 * in its pin arrays yet. Consider the pin numbers range as
+ 		 * continuous and allocate a single range.
+ 		 */
+ 		pfc->nr_ranges = 1;
+ 		pfc->ranges = devm_kzalloc(pfc->dev, sizeof(*pfc->ranges),
+ 					   GFP_KERNEL);
+ 		if (pfc->ranges == NULL)
+ 			return -ENOMEM;
+ 
+ 		pfc->ranges->start = 0;
+ 		pfc->ranges->end = pfc->info->nr_pins - 1;
+ 		pfc->nr_gpio_pins = pfc->info->nr_pins;
+ 
+ 		return 0;
+ 	}
+ 
+ 	/* Count, allocate and fill the ranges. The PFC SoC data pins array must
+ 	 * be sorted by pin numbers, and pins without a GPIO port must come
+ 	 * last.
+ 	 */
+ 	for (i = 1, nr_ranges = 1; i < pfc->info->nr_pins; ++i) {
+ 		if (pfc->info->pins[i-1].pin != pfc->info->pins[i].pin - 1)
+ 			nr_ranges++;
+ 	}
+ 
+ 	pfc->nr_ranges = nr_ranges;
+ 	pfc->ranges = devm_kcalloc(pfc->dev, nr_ranges, sizeof(*pfc->ranges),
+ 				   GFP_KERNEL);
+ 	if (pfc->ranges == NULL)
+ 		return -ENOMEM;
+ 
+ 	range = pfc->ranges;
+ 	range->start = pfc->info->pins[0].pin;
+ 
+ 	for (i = 1; i < pfc->info->nr_pins; ++i) {
+ 		if (pfc->info->pins[i-1].pin == pfc->info->pins[i].pin - 1)
+ 			continue;
+ 
+ 		range->end = pfc->info->pins[i-1].pin;
+ 		if (!(pfc->info->pins[i-1].configs & SH_PFC_PIN_CFG_NO_GPIO))
+ 			pfc->nr_gpio_pins = range->end + 1;
+ 
+ 		range++;
+ 		range->start = pfc->info->pins[i].pin;
+ 	}
+ 
+ 	range->end = pfc->info->pins[i-1].pin;
+ 	if (!(pfc->info->pins[i-1].configs & SH_PFC_PIN_CFG_NO_GPIO))
+ 		pfc->nr_gpio_pins = range->end + 1;
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_OF
+ static const struct of_device_id sh_pfc_of_table[] = {
+ #ifdef CONFIG_PINCTRL_PFC_EMEV2
+ 	{
+ 		.compatible = "renesas,pfc-emev2",
+ 		.data = &emev2_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A73A4
+ 	{
+ 		.compatible = "renesas,pfc-r8a73a4",
+ 		.data = &r8a73a4_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A7740
+ 	{
+ 		.compatible = "renesas,pfc-r8a7740",
+ 		.data = &r8a7740_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A7743
+ 	{
+ 		.compatible = "renesas,pfc-r8a7743",
+ 		.data = &r8a7743_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A7745
+ 	{
+ 		.compatible = "renesas,pfc-r8a7745",
+ 		.data = &r8a7745_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A77470
+ 	{
+ 		.compatible = "renesas,pfc-r8a77470",
+ 		.data = &r8a77470_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A7778
+ 	{
+ 		.compatible = "renesas,pfc-r8a7778",
+ 		.data = &r8a7778_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A7779
+ 	{
+ 		.compatible = "renesas,pfc-r8a7779",
+ 		.data = &r8a7779_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A7790
+ 	{
+ 		.compatible = "renesas,pfc-r8a7790",
+ 		.data = &r8a7790_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A7791
+ 	{
+ 		.compatible = "renesas,pfc-r8a7791",
+ 		.data = &r8a7791_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A7792
+ 	{
+ 		.compatible = "renesas,pfc-r8a7792",
+ 		.data = &r8a7792_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A7793
+ 	{
+ 		.compatible = "renesas,pfc-r8a7793",
+ 		.data = &r8a7793_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A7794
+ 	{
+ 		.compatible = "renesas,pfc-r8a7794",
+ 		.data = &r8a7794_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A7795
+ 	{
+ 		.compatible = "renesas,pfc-r8a7795",
+ 		.data = &r8a7795_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A7796
+ 	{
+ 		.compatible = "renesas,pfc-r8a7796",
+ 		.data = &r8a7796_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A77965
+ 	{
+ 		.compatible = "renesas,pfc-r8a77965",
+ 		.data = &r8a77965_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A77970
+ 	{
+ 		.compatible = "renesas,pfc-r8a77970",
+ 		.data = &r8a77970_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A77980
+ 	{
+ 		.compatible = "renesas,pfc-r8a77980",
+ 		.data = &r8a77980_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A77990
+ 	{
+ 		.compatible = "renesas,pfc-r8a77990",
+ 		.data = &r8a77990_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_R8A77995
+ 	{
+ 		.compatible = "renesas,pfc-r8a77995",
+ 		.data = &r8a77995_pinmux_info,
+ 	},
+ #endif
+ #ifdef CONFIG_PINCTRL_PFC_SH73A0
+ 	{
+ 		.compatible = "renesas,pfc-sh73a0",
+ 		.data = &sh73a0_pinmux_info,
+ 	},
+ #endif
+ 	{ },
+ };
+ #endif
+ 
+ #if defined(CONFIG_PM_SLEEP) && defined(CONFIG_ARM_PSCI_FW)
+ static void sh_pfc_nop_reg(struct sh_pfc *pfc, u32 reg, unsigned int idx)
+ {
+ }
+ 
+ static void sh_pfc_save_reg(struct sh_pfc *pfc, u32 reg, unsigned int idx)
+ {
+ 	pfc->saved_regs[idx] = sh_pfc_read(pfc, reg);
+ }
+ 
+ static void sh_pfc_restore_reg(struct sh_pfc *pfc, u32 reg, unsigned int idx)
+ {
+ 	sh_pfc_write(pfc, reg, pfc->saved_regs[idx]);
+ }
+ 
+ static unsigned int sh_pfc_walk_regs(struct sh_pfc *pfc,
+ 	void (*do_reg)(struct sh_pfc *pfc, u32 reg, unsigned int idx))
+ {
+ 	unsigned int i, n = 0;
+ 
+ 	if (pfc->info->cfg_regs)
+ 		for (i = 0; pfc->info->cfg_regs[i].reg; i++)
+ 			do_reg(pfc, pfc->info->cfg_regs[i].reg, n++);
+ 
+ 	if (pfc->info->drive_regs)
+ 		for (i = 0; pfc->info->drive_regs[i].reg; i++)
+ 			do_reg(pfc, pfc->info->drive_regs[i].reg, n++);
+ 
+ 	if (pfc->info->bias_regs)
+ 		for (i = 0; pfc->info->bias_regs[i].puen; i++) {
+ 			do_reg(pfc, pfc->info->bias_regs[i].puen, n++);
+ 			if (pfc->info->bias_regs[i].pud)
+ 				do_reg(pfc, pfc->info->bias_regs[i].pud, n++);
+ 		}
+ 
+ 	if (pfc->info->ioctrl_regs)
+ 		for (i = 0; pfc->info->ioctrl_regs[i].reg; i++)
+ 			do_reg(pfc, pfc->info->ioctrl_regs[i].reg, n++);
+ 
+ 	return n;
+ }
+ 
+ static int sh_pfc_suspend_init(struct sh_pfc *pfc)
+ {
+ 	unsigned int n;
+ 
+ 	/* This is the best we can do to check for the presence of PSCI */
+ 	if (!psci_ops.cpu_suspend)
+ 		return 0;
+ 
+ 	n = sh_pfc_walk_regs(pfc, sh_pfc_nop_reg);
+ 	if (!n)
+ 		return 0;
+ 
+ 	pfc->saved_regs = devm_kmalloc_array(pfc->dev, n,
+ 					     sizeof(*pfc->saved_regs),
+ 					     GFP_KERNEL);
+ 	if (!pfc->saved_regs)
+ 		return -ENOMEM;
+ 
+ 	dev_dbg(pfc->dev, "Allocated space to save %u regs\n", n);
+ 	return 0;
+ }
+ 
+ static int sh_pfc_suspend_noirq(struct device *dev)
+ {
+ 	struct sh_pfc *pfc = dev_get_drvdata(dev);
+ 
+ 	if (pfc->saved_regs)
+ 		sh_pfc_walk_regs(pfc, sh_pfc_save_reg);
+ 	return 0;
+ }
+ 
+ static int sh_pfc_resume_noirq(struct device *dev)
+ {
+ 	struct sh_pfc *pfc = dev_get_drvdata(dev);
+ 
+ 	if (pfc->saved_regs)
+ 		sh_pfc_walk_regs(pfc, sh_pfc_restore_reg);
+ 	return 0;
+ }
+ 
+ static const struct dev_pm_ops sh_pfc_pm  = {
+ 	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(sh_pfc_suspend_noirq, sh_pfc_resume_noirq)
+ };
+ #define DEV_PM_OPS	&sh_pfc_pm
+ #else
+ static int sh_pfc_suspend_init(struct sh_pfc *pfc) { return 0; }
+ #define DEV_PM_OPS	NULL
+ #endif /* CONFIG_PM_SLEEP && CONFIG_ARM_PSCI_FW */
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  static int sh_pfc_probe(struct platform_device *pdev)
  {
 -#ifdef CONFIG_OF
 -	struct device_node *np = pdev->dev.of_node;
 -#endif
  	const struct sh_pfc_soc_info *info;
  	struct sh_pfc *pfc;
  	int ret;
diff --cc drivers/pinctrl/sh-pfc/gpio.c
index d37efa7dcf90,6ffdc6beb203..000000000000
--- a/drivers/pinctrl/sh-pfc/gpio.c
+++ b/drivers/pinctrl/sh-pfc/gpio.c
@@@ -224,7 -224,8 +224,12 @@@ static int gpio_pin_setup(struct sh_pfc
  	struct gpio_chip *gc = &chip->gpio_chip;
  	int ret;
  
++<<<<<<< HEAD
 +	chip->pins = devm_kzalloc(pfc->dev, pfc->nr_pins * sizeof(*chip->pins),
++=======
+ 	chip->pins = devm_kcalloc(pfc->dev,
+ 				  pfc->info->nr_pins, sizeof(*chip->pins),
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  				  GFP_KERNEL);
  	if (chip->pins == NULL)
  		return -ENOMEM;
diff --cc drivers/pinctrl/sh-pfc/pinctrl.c
index 1d9fe2b665e8,654dc20e171b..000000000000
--- a/drivers/pinctrl/sh-pfc/pinctrl.c
+++ b/drivers/pinctrl/sh-pfc/pinctrl.c
@@@ -382,24 -767,11 +382,30 @@@ static const struct pinconf_ops sh_pfc_
  /* PFC ranges -> pinctrl pin descs */
  static int sh_pfc_map_pins(struct sh_pfc *pfc, struct sh_pfc_pinctrl *pmx)
  {
 +	const struct pinmux_range *ranges;
 +	struct pinmux_range def_range;
 +	unsigned int nr_ranges;
 +	unsigned int nr_pins;
  	unsigned int i;
  
++<<<<<<< HEAD
 +	if (pfc->info->ranges == NULL) {
 +		def_range.begin = 0;
 +		def_range.end = pfc->info->nr_pins - 1;
 +		ranges = &def_range;
 +		nr_ranges = 1;
 +	} else {
 +		ranges = pfc->info->ranges;
 +		nr_ranges = pfc->info->nr_ranges;
 +	}
 +
 +	pmx->pins = devm_kzalloc(pfc->dev,
 +				 sizeof(*pmx->pins) * pfc->info->nr_pins,
++=======
+ 	/* Allocate and initialize the pins and configs arrays. */
+ 	pmx->pins = devm_kcalloc(pfc->dev,
+ 				 pfc->info->nr_pins, sizeof(*pmx->pins),
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  				 GFP_KERNEL);
  	if (unlikely(!pmx->pins))
  		return -ENOMEM;
diff --cc drivers/power/charger-manager.c
index 98de1ddce458,faa1a67cf3d2..000000000000
--- a/drivers/power/charger-manager.c
+++ b/drivers/power/charger-manager.c
@@@ -1384,13 -1379,11 +1384,21 @@@ static int charger_manager_register_sys
  		charger = &desc->charger_regulators[i];
  
  		snprintf(buf, 10, "charger.%d", i);
++<<<<<<< HEAD:drivers/power/charger-manager.c
 +		str = kzalloc(sizeof(char) * (strlen(buf) + 1), GFP_KERNEL);
 +		if (!str) {
 +			dev_err(cm->dev, "Cannot allocate memory: %s\n",
 +					charger->regulator_name);
 +			ret = -ENOMEM;
 +			goto err;
 +		}
++=======
+ 		str = devm_kzalloc(cm->dev,
+ 				strlen(buf) + 1, GFP_KERNEL);
+ 		if (!str)
+ 			return -ENOMEM;
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc()):drivers/power/supply/charger-manager.c
  		strcpy(str, buf);
  
  		charger->attrs[0] = &charger->attr_name.attr;
@@@ -1451,37 -1479,166 +1459,182 @@@ err
  	return ret;
  }
  
++<<<<<<< HEAD:drivers/power/charger-manager.c
++=======
+ static const struct of_device_id charger_manager_match[] = {
+ 	{
+ 		.compatible = "charger-manager",
+ 	},
+ 	{},
+ };
+ 
+ static struct charger_desc *of_cm_parse_desc(struct device *dev)
+ {
+ 	struct charger_desc *desc;
+ 	struct device_node *np = dev->of_node;
+ 	u32 poll_mode = CM_POLL_DISABLE;
+ 	u32 battery_stat = CM_NO_BATTERY;
+ 	int num_chgs = 0;
+ 
+ 	desc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);
+ 	if (!desc)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	of_property_read_string(np, "cm-name", &desc->psy_name);
+ 
+ 	of_property_read_u32(np, "cm-poll-mode", &poll_mode);
+ 	desc->polling_mode = poll_mode;
+ 
+ 	of_property_read_u32(np, "cm-poll-interval",
+ 				&desc->polling_interval_ms);
+ 
+ 	of_property_read_u32(np, "cm-fullbatt-vchkdrop-ms",
+ 					&desc->fullbatt_vchkdrop_ms);
+ 	of_property_read_u32(np, "cm-fullbatt-vchkdrop-volt",
+ 					&desc->fullbatt_vchkdrop_uV);
+ 	of_property_read_u32(np, "cm-fullbatt-voltage", &desc->fullbatt_uV);
+ 	of_property_read_u32(np, "cm-fullbatt-soc", &desc->fullbatt_soc);
+ 	of_property_read_u32(np, "cm-fullbatt-capacity",
+ 					&desc->fullbatt_full_capacity);
+ 
+ 	of_property_read_u32(np, "cm-battery-stat", &battery_stat);
+ 	desc->battery_present = battery_stat;
+ 
+ 	/* chargers */
+ 	of_property_read_u32(np, "cm-num-chargers", &num_chgs);
+ 	if (num_chgs) {
+ 		/* Allocate empty bin at the tail of array */
+ 		desc->psy_charger_stat = devm_kcalloc(dev,
+ 						      num_chgs + 1,
+ 						      sizeof(char *),
+ 						      GFP_KERNEL);
+ 		if (desc->psy_charger_stat) {
+ 			int i;
+ 			for (i = 0; i < num_chgs; i++)
+ 				of_property_read_string_index(np, "cm-chargers",
+ 						i, &desc->psy_charger_stat[i]);
+ 		} else {
+ 			return ERR_PTR(-ENOMEM);
+ 		}
+ 	}
+ 
+ 	of_property_read_string(np, "cm-fuel-gauge", &desc->psy_fuel_gauge);
+ 
+ 	of_property_read_string(np, "cm-thermal-zone", &desc->thermal_zone);
+ 
+ 	of_property_read_u32(np, "cm-battery-cold", &desc->temp_min);
+ 	if (of_get_property(np, "cm-battery-cold-in-minus", NULL))
+ 		desc->temp_min *= -1;
+ 	of_property_read_u32(np, "cm-battery-hot", &desc->temp_max);
+ 	of_property_read_u32(np, "cm-battery-temp-diff", &desc->temp_diff);
+ 
+ 	of_property_read_u32(np, "cm-charging-max",
+ 				&desc->charging_max_duration_ms);
+ 	of_property_read_u32(np, "cm-discharging-max",
+ 				&desc->discharging_max_duration_ms);
+ 
+ 	/* battery charger regualtors */
+ 	desc->num_charger_regulators = of_get_child_count(np);
+ 	if (desc->num_charger_regulators) {
+ 		struct charger_regulator *chg_regs;
+ 		struct device_node *child;
+ 
+ 		chg_regs = devm_kcalloc(dev,
+ 					desc->num_charger_regulators,
+ 					sizeof(*chg_regs),
+ 					GFP_KERNEL);
+ 		if (!chg_regs)
+ 			return ERR_PTR(-ENOMEM);
+ 
+ 		desc->charger_regulators = chg_regs;
+ 
+ 		for_each_child_of_node(np, child) {
+ 			struct charger_cable *cables;
+ 			struct device_node *_child;
+ 
+ 			of_property_read_string(child, "cm-regulator-name",
+ 					&chg_regs->regulator_name);
+ 
+ 			/* charger cables */
+ 			chg_regs->num_cables = of_get_child_count(child);
+ 			if (chg_regs->num_cables) {
+ 				cables = devm_kcalloc(dev,
+ 						      chg_regs->num_cables,
+ 						      sizeof(*cables),
+ 						      GFP_KERNEL);
+ 				if (!cables) {
+ 					of_node_put(child);
+ 					return ERR_PTR(-ENOMEM);
+ 				}
+ 
+ 				chg_regs->cables = cables;
+ 
+ 				for_each_child_of_node(child, _child) {
+ 					of_property_read_string(_child,
+ 					"cm-cable-name", &cables->name);
+ 					of_property_read_string(_child,
+ 					"cm-cable-extcon",
+ 					&cables->extcon_name);
+ 					of_property_read_u32(_child,
+ 					"cm-cable-min",
+ 					&cables->min_uA);
+ 					of_property_read_u32(_child,
+ 					"cm-cable-max",
+ 					&cables->max_uA);
+ 					cables++;
+ 				}
+ 			}
+ 			chg_regs++;
+ 		}
+ 	}
+ 	return desc;
+ }
+ 
+ static inline struct charger_desc *cm_get_drv_data(struct platform_device *pdev)
+ {
+ 	if (pdev->dev.of_node)
+ 		return of_cm_parse_desc(&pdev->dev);
+ 	return dev_get_platdata(&pdev->dev);
+ }
+ 
+ static enum alarmtimer_restart cm_timer_func(struct alarm *alarm, ktime_t now)
+ {
+ 	cm_timer_set = false;
+ 	return ALARMTIMER_NORESTART;
+ }
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc()):drivers/power/supply/charger-manager.c
  static int charger_manager_probe(struct platform_device *pdev)
  {
 -	struct charger_desc *desc = cm_get_drv_data(pdev);
 +	struct charger_desc *desc = dev_get_platdata(&pdev->dev);
  	struct charger_manager *cm;
 -	int ret, i = 0;
 +	int ret = 0, i = 0;
  	int j = 0;
  	union power_supply_propval val;
 -	struct power_supply *fuel_gauge;
 -	struct power_supply_config psy_cfg = {};
  
 -	if (IS_ERR(desc)) {
 -		dev_err(&pdev->dev, "No platform data (desc) found\n");
 -		return -ENODEV;
 +	if (g_desc && !rtc_dev && g_desc->rtc_name) {
 +		rtc_dev = rtc_class_open(g_desc->rtc_name);
 +		if (IS_ERR_OR_NULL(rtc_dev)) {
 +			rtc_dev = NULL;
 +			dev_err(&pdev->dev, "Cannot get RTC %s.\n",
 +				g_desc->rtc_name);
 +			ret = -ENODEV;
 +			goto err_alloc;
 +		}
  	}
  
 -	cm = devm_kzalloc(&pdev->dev, sizeof(*cm), GFP_KERNEL);
 -	if (!cm)
 -		return -ENOMEM;
 +	if (!desc) {
 +		dev_err(&pdev->dev, "No platform data (desc) found.\n");
 +		ret = -ENODEV;
 +		goto err_alloc;
 +	}
 +
 +	cm = kzalloc(sizeof(struct charger_manager), GFP_KERNEL);
 +	if (!cm) {
 +		dev_err(&pdev->dev, "Cannot allocate memory.\n");
 +		ret = -ENOMEM;
 +		goto err_alloc;
 +	}
  
  	/* Basic Values. Unspecified are Null or 0 */
  	cm->dev = &pdev->dev;
@@@ -1590,47 -1726,49 +1743,59 @@@
  		strncpy(cm->psy_name_buf, psy_default.name, PSY_NAME_MAX);
  	else
  		strncpy(cm->psy_name_buf, desc->psy_name, PSY_NAME_MAX);
 -	cm->charger_psy_desc.name = cm->psy_name_buf;
 +	cm->charger_psy.name = cm->psy_name_buf;
  
  	/* Allocate for psy properties because they may vary */
++<<<<<<< HEAD:drivers/power/charger-manager.c
 +	cm->charger_psy.properties = kzalloc(sizeof(enum power_supply_property)
 +				* (ARRAY_SIZE(default_charger_props) +
 +				NUM_CHARGER_PSY_OPTIONAL),
 +				GFP_KERNEL);
 +	if (!cm->charger_psy.properties) {
 +		dev_err(&pdev->dev, "Cannot allocate for psy properties.\n");
 +		ret = -ENOMEM;
 +		goto err_chg_stat;
 +	}
 +	memcpy(cm->charger_psy.properties, default_charger_props,
++=======
+ 	cm->charger_psy_desc.properties =
+ 		devm_kcalloc(&pdev->dev,
+ 			     ARRAY_SIZE(default_charger_props) +
+ 				NUM_CHARGER_PSY_OPTIONAL,
+ 			     sizeof(enum power_supply_property), GFP_KERNEL);
+ 	if (!cm->charger_psy_desc.properties)
+ 		return -ENOMEM;
+ 
+ 	memcpy(cm->charger_psy_desc.properties, default_charger_props,
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc()):drivers/power/supply/charger-manager.c
  		sizeof(enum power_supply_property) *
  		ARRAY_SIZE(default_charger_props));
 -	cm->charger_psy_desc.num_properties = psy_default.num_properties;
 +	cm->charger_psy.num_properties = psy_default.num_properties;
  
  	/* Find which optional psy-properties are available */
 -	fuel_gauge = power_supply_get_by_name(desc->psy_fuel_gauge);
 -	if (!fuel_gauge) {
 -		dev_err(&pdev->dev, "Cannot find power supply \"%s\"\n",
 -			desc->psy_fuel_gauge);
 -		return -ENODEV;
 -	}
 -	if (!power_supply_get_property(fuel_gauge,
 +	if (!cm->fuel_gauge->get_property(cm->fuel_gauge,
  					  POWER_SUPPLY_PROP_CHARGE_NOW, &val)) {
 -		cm->charger_psy_desc.properties[cm->charger_psy_desc.num_properties] =
 +		cm->charger_psy.properties[cm->charger_psy.num_properties] =
  				POWER_SUPPLY_PROP_CHARGE_NOW;
 -		cm->charger_psy_desc.num_properties++;
 +		cm->charger_psy.num_properties++;
  	}
 -	if (!power_supply_get_property(fuel_gauge,
 +	if (!cm->fuel_gauge->get_property(cm->fuel_gauge,
  					  POWER_SUPPLY_PROP_CURRENT_NOW,
  					  &val)) {
 -		cm->charger_psy_desc.properties[cm->charger_psy_desc.num_properties] =
 +		cm->charger_psy.properties[cm->charger_psy.num_properties] =
  				POWER_SUPPLY_PROP_CURRENT_NOW;
 -		cm->charger_psy_desc.num_properties++;
 +		cm->charger_psy.num_properties++;
  	}
  
 -	ret = cm_init_thermal_data(cm, fuel_gauge);
 -	if (ret) {
 -		dev_err(&pdev->dev, "Failed to initialize thermal data\n");
 -		cm->desc->measure_battery_temp = false;
 +	if (desc->measure_battery_temp) {
 +		cm->charger_psy.properties[cm->charger_psy.num_properties] =
 +				POWER_SUPPLY_PROP_TEMP;
 +		cm->charger_psy.num_properties++;
 +	} else {
 +		cm->charger_psy.properties[cm->charger_psy.num_properties] =
 +				POWER_SUPPLY_PROP_TEMP_AMBIENT;
 +		cm->charger_psy.num_properties++;
  	}
 -	power_supply_put(fuel_gauge);
  
  	INIT_DELAYED_WORK(&cm->fullbatt_vchk_work, fullbatt_vchk);
  
diff --cc drivers/power/power_supply_core.c
index 79db3278f492,d21f478741c1..000000000000
--- a/drivers/power/power_supply_core.c
+++ b/drivers/power/power_supply_core.c
@@@ -245,17 -256,18 +245,22 @@@ static int power_supply_check_supplies(
  	/* All supplies found, allocate char ** array for filling */
  	psy->supplied_from = devm_kzalloc(&psy->dev, sizeof(psy->supplied_from),
  					  GFP_KERNEL);
 -	if (!psy->supplied_from)
 +	if (!psy->supplied_from) {
 +		dev_err(&psy->dev, "Couldn't allocate memory for supply list\n");
  		return -ENOMEM;
 +	}
  
++<<<<<<< HEAD:drivers/power/power_supply_core.c
 +	*psy->supplied_from = devm_kzalloc(&psy->dev, sizeof(char *) * cnt,
++=======
+ 	*psy->supplied_from = devm_kcalloc(&psy->dev,
+ 					   cnt - 1, sizeof(char *),
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc()):drivers/power/supply/power_supply_core.c
  					   GFP_KERNEL);
 -	if (!*psy->supplied_from)
 +	if (!*psy->supplied_from) {
 +		dev_err(&psy->dev, "Couldn't allocate memory for supply list\n");
  		return -ENOMEM;
 +	}
  
  	return power_supply_populate_supplied_from(psy);
  }
diff --cc drivers/regulator/as3711-regulator.c
index 3da6bd6950cf,565a71343a8e..000000000000
--- a/drivers/regulator/as3711-regulator.c
+++ b/drivers/regulator/as3711-regulator.c
@@@ -352,20 -239,14 +352,28 @@@ static int as3711_regulator_probe(struc
  		}
  	}
  
++<<<<<<< HEAD
 +	regs = devm_kzalloc(&pdev->dev, AS3711_REGULATOR_NUM *
 +			sizeof(struct as3711_regulator), GFP_KERNEL);
 +	if (!regs) {
 +		dev_err(&pdev->dev, "Memory allocation failed exiting..\n");
++=======
+ 	regs = devm_kcalloc(&pdev->dev,
+ 			    AS3711_REGULATOR_NUM,
+ 			    sizeof(struct as3711_regulator),
+ 			    GFP_KERNEL);
+ 	if (!regs)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 +	}
  
  	for (id = 0, ri = as3711_reg_info; id < AS3711_REGULATOR_NUM; ++id, ri++) {
 +		reg_data = pdata->init_data[id];
 +
 +		/* No need to register if there is no regulator data */
 +		if (!reg_data)
 +			continue;
 +
  		reg = &regs[id];
  		reg->reg_info = ri;
  
diff --cc drivers/regulator/gpio-regulator.c
index 9d39eb4aafa3,b2f5ec4f658a..000000000000
--- a/drivers/regulator/gpio-regulator.c
+++ b/drivers/regulator/gpio-regulator.c
@@@ -161,21 -162,49 +161,31 @@@ of_get_gpio_regulator_config(struct dev
  	of_property_read_u32(np, "startup-delay-us", &config->startup_delay);
  
  	config->enable_gpio = of_get_named_gpio(np, "enable-gpio", 0);
 -	if (config->enable_gpio < 0 && config->enable_gpio != -ENOENT)
 -		return ERR_PTR(config->enable_gpio);
  
 -	/* Fetch GPIOs. - optional property*/
 -	ret = of_gpio_count(np);
 -	if ((ret < 0) && (ret != -ENOENT))
 -		return ERR_PTR(ret);
 +	/* Fetch GPIOs. */
 +	config->nr_gpios = of_gpio_count(np);
  
++<<<<<<< HEAD
 +	config->gpios = devm_kzalloc(dev,
 +				sizeof(struct gpio) * config->nr_gpios,
 +				GFP_KERNEL);
 +	if (!config->gpios)
 +		return ERR_PTR(-ENOMEM);
++=======
+ 	if (ret > 0) {
+ 		config->nr_gpios = ret;
+ 		config->gpios = devm_kcalloc(dev,
+ 					config->nr_gpios, sizeof(struct gpio),
+ 					GFP_KERNEL);
+ 		if (!config->gpios)
+ 			return ERR_PTR(-ENOMEM);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  
 -		proplen = of_property_count_u32_elems(np, "gpios-states");
 -		/* optional property */
 -		if (proplen < 0)
 -			proplen = 0;
 -
 -		if (proplen > 0 && proplen != config->nr_gpios) {
 -			dev_warn(dev, "gpios <-> gpios-states mismatch\n");
 -			proplen = 0;
 -		}
 -
 -		for (i = 0; i < config->nr_gpios; i++) {
 -			gpio = of_get_named_gpio(np, "gpios", i);
 -			if (gpio < 0) {
 -				if (gpio != -ENOENT)
 -					return ERR_PTR(gpio);
 -				break;
 -			}
 -			config->gpios[i].gpio = gpio;
 -			config->gpios[i].label = config->supply_name;
 -			if (proplen > 0) {
 -				of_property_read_u32_index(np, "gpios-states",
 -							   i, &ret);
 -				if (ret)
 -					config->gpios[i].flags =
 -							   GPIOF_OUT_INIT_HIGH;
 -			}
 -		}
 +	for (i = 0; i < config->nr_gpios; i++) {
 +		gpio = of_get_named_gpio(np, "gpios", i);
 +		if (gpio < 0)
 +			break;
 +		config->gpios[i].gpio = gpio;
  	}
  
  	/* Fetch states. */
@@@ -185,11 -214,9 +195,17 @@@
  		return ERR_PTR(-EINVAL);
  	}
  
++<<<<<<< HEAD
 +	proplen = prop->length / sizeof(int);
 +
 +	config->states = devm_kzalloc(dev,
 +				sizeof(struct gpio_regulator_state)
 +				* (proplen / 2),
++=======
+ 	config->states = devm_kcalloc(dev,
+ 				proplen / 2,
+ 				sizeof(struct gpio_regulator_state),
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  				GFP_KERNEL);
  	if (!config->states)
  		return ERR_PTR(-ENOMEM);
diff --cc drivers/regulator/max1586.c
index 54af61015814,cc52779b53f7..000000000000
--- a/drivers/regulator/max1586.c
+++ b/drivers/regulator/max1586.c
@@@ -159,6 -159,67 +159,70 @@@ static struct regulator_desc max1586_re
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static int of_get_max1586_platform_data(struct device *dev,
+ 				 struct max1586_platform_data *pdata)
+ {
+ 	struct max1586_subdev_data *sub;
+ 	struct of_regulator_match rmatch[ARRAY_SIZE(max1586_reg)] = { };
+ 	struct device_node *np = dev->of_node;
+ 	int i, matched;
+ 
+ 	if (of_property_read_u32(np, "v3-gain",
+ 				 &pdata->v3_gain) < 0) {
+ 		dev_err(dev, "%pOF has no 'v3-gain' property\n", np);
+ 		return -EINVAL;
+ 	}
+ 
+ 	np = of_get_child_by_name(np, "regulators");
+ 	if (!np) {
+ 		dev_err(dev, "missing 'regulators' subnode in DT\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	for (i = 0; i < ARRAY_SIZE(rmatch); i++)
+ 		rmatch[i].name = max1586_reg[i].name;
+ 
+ 	matched = of_regulator_match(dev, np, rmatch, ARRAY_SIZE(rmatch));
+ 	of_node_put(np);
+ 	/*
+ 	 * If matched is 0, ie. neither Output_V3 nor Output_V6 have been found,
+ 	 * return 0, which signals the normal situation where no subregulator is
+ 	 * available. This is normal because the max1586 doesn't provide any
+ 	 * readback support, so the subregulators can't report any status
+ 	 * anyway.  If matched < 0, return the error.
+ 	 */
+ 	if (matched <= 0)
+ 		return matched;
+ 
+ 	pdata->subdevs = devm_kcalloc(dev,
+ 				      matched,
+ 				      sizeof(struct max1586_subdev_data),
+ 				      GFP_KERNEL);
+ 	if (!pdata->subdevs)
+ 		return -ENOMEM;
+ 
+ 	pdata->num_subdevs = matched;
+ 	sub = pdata->subdevs;
+ 
+ 	for (i = 0; i < matched; i++) {
+ 		sub->id = i;
+ 		sub->name = rmatch[i].of_node->name;
+ 		sub->platform_data = rmatch[i].init_data;
+ 		sub++;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static const struct of_device_id max1586_of_match[] = {
+ 	{ .compatible = "maxim,max1586", },
+ 	{},
+ };
+ MODULE_DEVICE_TABLE(of, max1586_of_match);
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  static int max1586_pmic_probe(struct i2c_client *client,
  					const struct i2c_device_id *i2c_id)
  {
diff --cc drivers/regulator/max8660.c
index d428ef9a626f,4cf6897a401f..000000000000
--- a/drivers/regulator/max8660.c
+++ b/drivers/regulator/max8660.c
@@@ -305,6 -315,71 +305,74 @@@ static const struct regulator_desc max8
  	},
  };
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	MAX8660 = 0,
+ 	MAX8661 = 1,
+ };
+ 
+ #ifdef CONFIG_OF
+ static const struct of_device_id max8660_dt_ids[] = {
+ 	{ .compatible = "maxim,max8660", .data = (void *) MAX8660 },
+ 	{ .compatible = "maxim,max8661", .data = (void *) MAX8661 },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(of, max8660_dt_ids);
+ 
+ static int max8660_pdata_from_dt(struct device *dev,
+ 				 struct device_node **of_node,
+ 				 struct max8660_platform_data *pdata)
+ {
+ 	int matched, i;
+ 	struct device_node *np;
+ 	struct max8660_subdev_data *sub;
+ 	struct of_regulator_match rmatch[ARRAY_SIZE(max8660_reg)] = { };
+ 
+ 	np = of_get_child_by_name(dev->of_node, "regulators");
+ 	if (!np) {
+ 		dev_err(dev, "missing 'regulators' subnode in DT\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	for (i = 0; i < ARRAY_SIZE(rmatch); i++)
+ 		rmatch[i].name = max8660_reg[i].name;
+ 
+ 	matched = of_regulator_match(dev, np, rmatch, ARRAY_SIZE(rmatch));
+ 	of_node_put(np);
+ 	if (matched <= 0)
+ 		return matched;
+ 
+ 	pdata->subdevs = devm_kcalloc(dev,
+ 				      matched,
+ 				      sizeof(struct max8660_subdev_data),
+ 				      GFP_KERNEL);
+ 	if (!pdata->subdevs)
+ 		return -ENOMEM;
+ 
+ 	pdata->num_subdevs = matched;
+ 	sub = pdata->subdevs;
+ 
+ 	for (i = 0; i < matched; i++) {
+ 		sub->id = i;
+ 		sub->name = rmatch[i].name;
+ 		sub->platform_data = rmatch[i].init_data;
+ 		of_node[i] = rmatch[i].of_node;
+ 		sub++;
+ 	}
+ 
+ 	return 0;
+ }
+ #else
+ static inline int max8660_pdata_from_dt(struct device *dev,
+ 					struct device_node **of_node,
+ 					struct max8660_platform_data *pdata)
+ {
+ 	return 0;
+ }
+ #endif
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  static int max8660_probe(struct i2c_client *client,
  				   const struct i2c_device_id *i2c_id)
  {
diff --cc drivers/regulator/max8998.c
index a57a1b15cdba,6b9f262ebbb0..000000000000
--- a/drivers/regulator/max8998.c
+++ b/drivers/regulator/max8998.c
@@@ -621,6 -622,125 +621,128 @@@ static struct regulator_desc regulators
  	}
  };
  
++<<<<<<< HEAD
++=======
+ static int max8998_pmic_dt_parse_dvs_gpio(struct max8998_dev *iodev,
+ 			struct max8998_platform_data *pdata,
+ 			struct device_node *pmic_np)
+ {
+ 	int gpio;
+ 
+ 	gpio = of_get_named_gpio(pmic_np, "max8998,pmic-buck1-dvs-gpios", 0);
+ 	if (!gpio_is_valid(gpio)) {
+ 		dev_err(iodev->dev, "invalid buck1 gpio[0]: %d\n", gpio);
+ 		return -EINVAL;
+ 	}
+ 	pdata->buck1_set1 = gpio;
+ 
+ 	gpio = of_get_named_gpio(pmic_np, "max8998,pmic-buck1-dvs-gpios", 1);
+ 	if (!gpio_is_valid(gpio)) {
+ 		dev_err(iodev->dev, "invalid buck1 gpio[1]: %d\n", gpio);
+ 		return -EINVAL;
+ 	}
+ 	pdata->buck1_set2 = gpio;
+ 
+ 	gpio = of_get_named_gpio(pmic_np, "max8998,pmic-buck2-dvs-gpio", 0);
+ 	if (!gpio_is_valid(gpio)) {
+ 		dev_err(iodev->dev, "invalid buck 2 gpio: %d\n", gpio);
+ 		return -EINVAL;
+ 	}
+ 	pdata->buck2_set3 = gpio;
+ 
+ 	return 0;
+ }
+ 
+ static int max8998_pmic_dt_parse_pdata(struct max8998_dev *iodev,
+ 					struct max8998_platform_data *pdata)
+ {
+ 	struct device_node *pmic_np = iodev->dev->of_node;
+ 	struct device_node *regulators_np, *reg_np;
+ 	struct max8998_regulator_data *rdata;
+ 	unsigned int i;
+ 	int ret;
+ 
+ 	regulators_np = of_get_child_by_name(pmic_np, "regulators");
+ 	if (!regulators_np) {
+ 		dev_err(iodev->dev, "could not find regulators sub-node\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* count the number of regulators to be supported in pmic */
+ 	pdata->num_regulators = of_get_child_count(regulators_np);
+ 
+ 	rdata = devm_kcalloc(iodev->dev,
+ 			     pdata->num_regulators, sizeof(*rdata),
+ 			     GFP_KERNEL);
+ 	if (!rdata) {
+ 		of_node_put(regulators_np);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	pdata->regulators = rdata;
+ 	for (i = 0; i < ARRAY_SIZE(regulators); ++i) {
+ 		reg_np = of_get_child_by_name(regulators_np,
+ 							regulators[i].name);
+ 		if (!reg_np)
+ 			continue;
+ 
+ 		rdata->id = regulators[i].id;
+ 		rdata->initdata = of_get_regulator_init_data(iodev->dev,
+ 							     reg_np,
+ 							     &regulators[i]);
+ 		rdata->reg_node = reg_np;
+ 		++rdata;
+ 	}
+ 	pdata->num_regulators = rdata - pdata->regulators;
+ 
+ 	of_node_put(reg_np);
+ 	of_node_put(regulators_np);
+ 
+ 	ret = max8998_pmic_dt_parse_dvs_gpio(iodev, pdata, pmic_np);
+ 	if (ret)
+ 		return -EINVAL;
+ 
+ 	if (of_find_property(pmic_np, "max8998,pmic-buck-voltage-lock", NULL))
+ 		pdata->buck_voltage_lock = true;
+ 
+ 	ret = of_property_read_u32(pmic_np,
+ 					"max8998,pmic-buck1-default-dvs-idx",
+ 					&pdata->buck1_default_idx);
+ 	if (!ret && pdata->buck1_default_idx >= 4) {
+ 		pdata->buck1_default_idx = 0;
+ 		dev_warn(iodev->dev, "invalid value for default dvs index, using 0 instead\n");
+ 	}
+ 
+ 	ret = of_property_read_u32(pmic_np,
+ 					"max8998,pmic-buck2-default-dvs-idx",
+ 					&pdata->buck2_default_idx);
+ 	if (!ret && pdata->buck2_default_idx >= 2) {
+ 		pdata->buck2_default_idx = 0;
+ 		dev_warn(iodev->dev, "invalid value for default dvs index, using 0 instead\n");
+ 	}
+ 
+ 	ret = of_property_read_u32_array(pmic_np,
+ 					"max8998,pmic-buck1-dvs-voltage",
+ 					pdata->buck1_voltage,
+ 					ARRAY_SIZE(pdata->buck1_voltage));
+ 	if (ret) {
+ 		dev_err(iodev->dev, "buck1 voltages not specified\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	ret = of_property_read_u32_array(pmic_np,
+ 					"max8998,pmic-buck2-dvs-voltage",
+ 					pdata->buck2_voltage,
+ 					ARRAY_SIZE(pdata->buck2_voltage));
+ 	if (ret) {
+ 		dev_err(iodev->dev, "buck2 voltages not specified\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  static int max8998_pmic_probe(struct platform_device *pdev)
  {
  	struct max8998_dev *iodev = dev_get_drvdata(pdev->dev.parent);
diff --cc drivers/regulator/rc5t583-regulator.c
index 5885b4504596,2ec51af43673..000000000000
--- a/drivers/regulator/rc5t583-regulator.c
+++ b/drivers/regulator/rc5t583-regulator.c
@@@ -133,12 -132,12 +133,20 @@@ static int rc5t583_regulator_probe(stru
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	regs = devm_kzalloc(&pdev->dev, RC5T583_REGULATOR_MAX *
 +			sizeof(struct rc5t583_regulator), GFP_KERNEL);
 +	if (!regs) {
 +		dev_err(&pdev->dev, "Memory allocation failed exiting..\n");
++=======
+ 	regs = devm_kcalloc(&pdev->dev,
+ 			    RC5T583_REGULATOR_MAX,
+ 			    sizeof(struct rc5t583_regulator),
+ 			    GFP_KERNEL);
+ 	if (!regs)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 +	}
  
  
  	for (id = 0; id < RC5T583_REGULATOR_MAX; ++id) {
diff --cc drivers/regulator/s5m8767.c
index c24448bc43cf,0cbc980753c2..000000000000
--- a/drivers/regulator/s5m8767.c
+++ b/drivers/regulator/s5m8767.c
@@@ -539,21 -553,17 +539,35 @@@ static int s5m8767_pmic_dt_parse_pdata(
  	/* count the number of regulators to be supported in pmic */
  	pdata->num_regulators = of_get_child_count(regulators_np);
  
++<<<<<<< HEAD
 +	rdata = devm_kzalloc(&pdev->dev, sizeof(*rdata) *
 +				pdata->num_regulators, GFP_KERNEL);
 +	if (!rdata) {
 +		dev_err(iodev->dev,
 +			"could not allocate memory for regulator data\n");
++=======
+ 	rdata = devm_kcalloc(&pdev->dev,
+ 			     pdata->num_regulators, sizeof(*rdata),
+ 			     GFP_KERNEL);
+ 	if (!rdata)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 +	}
  
++<<<<<<< HEAD
 +	rmode = devm_kzalloc(&pdev->dev, sizeof(*rmode) *
 +				pdata->num_regulators, GFP_KERNEL);
 +	if (!rmode) {
 +		dev_err(iodev->dev,
 +			"could not allocate memory for regulator mode\n");
++=======
+ 	rmode = devm_kcalloc(&pdev->dev,
+ 			     pdata->num_regulators, sizeof(*rmode),
+ 			     GFP_KERNEL);
+ 	if (!rmode)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 +	}
  
  	pdata->regulators = rdata;
  	pdata->opmode = rmode;
diff --cc drivers/regulator/tps65090-regulator.c
index c8e70451df38,edaef9e4dc74..000000000000
--- a/drivers/regulator/tps65090-regulator.c
+++ b/drivers/regulator/tps65090-regulator.c
@@@ -168,19 -328,16 +168,26 @@@ static struct tps65090_platform_data *t
  
  	tps65090_pdata = devm_kzalloc(&pdev->dev, sizeof(*tps65090_pdata),
  				GFP_KERNEL);
 -	if (!tps65090_pdata)
 +	if (!tps65090_pdata) {
 +		dev_err(&pdev->dev, "Memory alloc for tps65090_pdata failed\n");
  		return ERR_PTR(-ENOMEM);
 +	}
  
++<<<<<<< HEAD
 +	reg_pdata = devm_kzalloc(&pdev->dev, TPS65090_REGULATOR_MAX *
 +				sizeof(*reg_pdata), GFP_KERNEL);
 +	if (!reg_pdata) {
 +		dev_err(&pdev->dev, "Memory alloc for reg_pdata failed\n");
++=======
+ 	reg_pdata = devm_kcalloc(&pdev->dev,
+ 				 TPS65090_REGULATOR_MAX, sizeof(*reg_pdata),
+ 				 GFP_KERNEL);
+ 	if (!reg_pdata)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return ERR_PTR(-ENOMEM);
 +	}
  
 -	regulators = of_get_child_by_name(np, "regulators");
 +	regulators = of_find_node_by_name(np, "regulators");
  	if (!regulators) {
  		dev_err(&pdev->dev, "regulator node not found\n");
  		return ERR_PTR(-ENODEV);
@@@ -250,12 -430,11 +257,19 @@@ static int tps65090_regulator_probe(str
  		return tps65090_pdata ? PTR_ERR(tps65090_pdata) : -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	pmic = devm_kzalloc(&pdev->dev, TPS65090_REGULATOR_MAX * sizeof(*pmic),
 +			GFP_KERNEL);
 +	if (!pmic) {
 +		dev_err(&pdev->dev, "mem alloc for pmic failed\n");
++=======
+ 	pmic = devm_kcalloc(&pdev->dev,
+ 			    TPS65090_REGULATOR_MAX, sizeof(*pmic),
+ 			    GFP_KERNEL);
+ 	if (!pmic)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 +	}
  
  	for (num = 0; num < TPS65090_REGULATOR_MAX; num++) {
  		tps_pdata = tps65090_pdata->reg_pdata[num];
diff --cc drivers/regulator/tps65217-regulator.c
index df395187c063,fc12badf3805..000000000000
--- a/drivers/regulator/tps65217-regulator.c
+++ b/drivers/regulator/tps65217-regulator.c
@@@ -340,19 -226,12 +340,26 @@@ static int tps65217_regulator_probe(str
  	struct regulator_dev *rdev;
  	struct regulator_config config = { };
  	int i, ret;
 -	unsigned int val;
  
++<<<<<<< HEAD
 +	if (tps->dev->of_node)
 +		pdata = tps65217_parse_dt(pdev);
 +
 +	if (!pdata) {
 +		dev_err(&pdev->dev, "Platform data not found\n");
 +		return -EINVAL;
 +	}
 +
 +	if (tps65217_chip_id(tps) != TPS65217) {
 +		dev_err(&pdev->dev, "Invalid tps chip version\n");
 +		return -ENODEV;
 +	}
++=======
+ 	/* Allocate memory for strobes */
+ 	tps->strobes = devm_kcalloc(&pdev->dev,
+ 				    TPS65217_NUM_REGULATOR, sizeof(u8),
+ 				    GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  
  	platform_set_drvdata(pdev, tps);
  
diff --cc drivers/regulator/tps65910-regulator.c
index 45c16447744b,02ccdaa226a7..000000000000
--- a/drivers/regulator/tps65910-regulator.c
+++ b/drivers/regulator/tps65910-regulator.c
@@@ -1092,37 -1131,28 +1092,61 @@@ static int tps65910_probe(struct platfo
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	pmic->desc = devm_kzalloc(&pdev->dev, pmic->num_regulators *
 +			sizeof(struct regulator_desc), GFP_KERNEL);
 +	if (!pmic->desc) {
 +		dev_err(&pdev->dev, "Memory alloc fails for desc\n");
++=======
+ 	pmic->desc = devm_kcalloc(&pdev->dev,
+ 				  pmic->num_regulators,
+ 				  sizeof(struct regulator_desc),
+ 				  GFP_KERNEL);
+ 	if (!pmic->desc)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 +	}
  
++<<<<<<< HEAD
 +	pmic->info = devm_kzalloc(&pdev->dev, pmic->num_regulators *
 +			sizeof(struct tps_info *), GFP_KERNEL);
 +	if (!pmic->info) {
 +		dev_err(&pdev->dev, "Memory alloc fails for info\n");
++=======
+ 	pmic->info = devm_kcalloc(&pdev->dev,
+ 				  pmic->num_regulators,
+ 				  sizeof(struct tps_info *),
+ 				  GFP_KERNEL);
+ 	if (!pmic->info)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 +	}
  
++<<<<<<< HEAD
 +	pmic->rdev = devm_kzalloc(&pdev->dev, pmic->num_regulators *
 +			sizeof(struct regulator_dev *), GFP_KERNEL);
 +	if (!pmic->rdev) {
 +		dev_err(&pdev->dev, "Memory alloc fails for rdev\n");
++=======
+ 	pmic->rdev = devm_kcalloc(&pdev->dev,
+ 				  pmic->num_regulators,
+ 				  sizeof(struct regulator_dev *),
+ 				  GFP_KERNEL);
+ 	if (!pmic->rdev)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 +	}
 +
 +	for (i = 0; i < pmic->num_regulators && i < TPS65910_NUM_REGS;
 +			i++, info++) {
 +
 +		reg_data = pmic_plat_data->tps65910_pmic_init_data[i];
 +
 +		/* Regulator API handles empty constraints but not NULL
 +		 * constraints */
 +		if (!reg_data)
 +			continue;
  
 -	for (i = 0; i < pmic->num_regulators; i++, info++) {
  		/* Register the regulators */
  		pmic->info[i] = info;
  
diff --cc drivers/regulator/tps80031-regulator.c
index 6511d0bfd896,1001147404c3..000000000000
--- a/drivers/regulator/tps80031-regulator.c
+++ b/drivers/regulator/tps80031-regulator.c
@@@ -691,12 -691,10 +691,18 @@@ static int tps80031_regulator_probe(str
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	pmic = devm_kzalloc(&pdev->dev,
 +			TPS80031_REGULATOR_MAX * sizeof(*pmic), GFP_KERNEL);
 +	if (!pmic) {
 +		dev_err(&pdev->dev, "mem alloc for pmic failed\n");
++=======
+ 	pmic = devm_kcalloc(&pdev->dev,
+ 			TPS80031_REGULATOR_MAX, sizeof(*pmic), GFP_KERNEL);
+ 	if (!pmic)
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  		return -ENOMEM;
 +	}
  
  	for (num = 0; num < TPS80031_REGULATOR_MAX; ++num) {
  		tps_pdata = pdata->regulator_pdata[num];
diff --cc drivers/scsi/ufs/ufshcd-pltfrm.c
index 03319acd9c72,895a9b5ac989..000000000000
--- a/drivers/scsi/ufs/ufshcd-pltfrm.c
+++ b/drivers/scsi/ufs/ufshcd-pltfrm.c
@@@ -33,8 -33,193 +33,193 @@@
   * this program.
   */
  
 -#include <linux/platform_device.h>
 -#include <linux/pm_runtime.h>
 -#include <linux/of.h>
 -
  #include "ufshcd.h"
++<<<<<<< HEAD
 +#include <linux/platform_device.h>
++=======
+ #include "ufshcd-pltfrm.h"
+ 
+ #define UFSHCD_DEFAULT_LANES_PER_DIRECTION		2
+ 
+ static int ufshcd_parse_clock_info(struct ufs_hba *hba)
+ {
+ 	int ret = 0;
+ 	int cnt;
+ 	int i;
+ 	struct device *dev = hba->dev;
+ 	struct device_node *np = dev->of_node;
+ 	char *name;
+ 	u32 *clkfreq = NULL;
+ 	struct ufs_clk_info *clki;
+ 	int len = 0;
+ 	size_t sz = 0;
+ 
+ 	if (!np)
+ 		goto out;
+ 
+ 	cnt = of_property_count_strings(np, "clock-names");
+ 	if (!cnt || (cnt == -EINVAL)) {
+ 		dev_info(dev, "%s: Unable to find clocks, assuming enabled\n",
+ 				__func__);
+ 	} else if (cnt < 0) {
+ 		dev_err(dev, "%s: count clock strings failed, err %d\n",
+ 				__func__, cnt);
+ 		ret = cnt;
+ 	}
+ 
+ 	if (cnt <= 0)
+ 		goto out;
+ 
+ 	if (!of_get_property(np, "freq-table-hz", &len)) {
+ 		dev_info(dev, "freq-table-hz property not specified\n");
+ 		goto out;
+ 	}
+ 
+ 	if (len <= 0)
+ 		goto out;
+ 
+ 	sz = len / sizeof(*clkfreq);
+ 	if (sz != 2 * cnt) {
+ 		dev_err(dev, "%s len mismatch\n", "freq-table-hz");
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	clkfreq = devm_kcalloc(dev, sz, sizeof(*clkfreq),
+ 			       GFP_KERNEL);
+ 	if (!clkfreq) {
+ 		ret = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	ret = of_property_read_u32_array(np, "freq-table-hz",
+ 			clkfreq, sz);
+ 	if (ret && (ret != -EINVAL)) {
+ 		dev_err(dev, "%s: error reading array %d\n",
+ 				"freq-table-hz", ret);
+ 		return ret;
+ 	}
+ 
+ 	for (i = 0; i < sz; i += 2) {
+ 		ret = of_property_read_string_index(np,
+ 				"clock-names", i/2, (const char **)&name);
+ 		if (ret)
+ 			goto out;
+ 
+ 		clki = devm_kzalloc(dev, sizeof(*clki), GFP_KERNEL);
+ 		if (!clki) {
+ 			ret = -ENOMEM;
+ 			goto out;
+ 		}
+ 
+ 		clki->min_freq = clkfreq[i];
+ 		clki->max_freq = clkfreq[i+1];
+ 		clki->name = kstrdup(name, GFP_KERNEL);
+ 		dev_dbg(dev, "%s: min %u max %u name %s\n", "freq-table-hz",
+ 				clki->min_freq, clki->max_freq, clki->name);
+ 		list_add_tail(&clki->list, &hba->clk_list_head);
+ 	}
+ out:
+ 	return ret;
+ }
+ 
+ #define MAX_PROP_SIZE 32
+ static int ufshcd_populate_vreg(struct device *dev, const char *name,
+ 		struct ufs_vreg **out_vreg)
+ {
+ 	int ret = 0;
+ 	char prop_name[MAX_PROP_SIZE];
+ 	struct ufs_vreg *vreg = NULL;
+ 	struct device_node *np = dev->of_node;
+ 
+ 	if (!np) {
+ 		dev_err(dev, "%s: non DT initialization\n", __func__);
+ 		goto out;
+ 	}
+ 
+ 	snprintf(prop_name, MAX_PROP_SIZE, "%s-supply", name);
+ 	if (!of_parse_phandle(np, prop_name, 0)) {
+ 		dev_info(dev, "%s: Unable to find %s regulator, assuming enabled\n",
+ 				__func__, prop_name);
+ 		goto out;
+ 	}
+ 
+ 	vreg = devm_kzalloc(dev, sizeof(*vreg), GFP_KERNEL);
+ 	if (!vreg)
+ 		return -ENOMEM;
+ 
+ 	vreg->name = kstrdup(name, GFP_KERNEL);
+ 
+ 	/* if fixed regulator no need further initialization */
+ 	snprintf(prop_name, MAX_PROP_SIZE, "%s-fixed-regulator", name);
+ 	if (of_property_read_bool(np, prop_name))
+ 		goto out;
+ 
+ 	snprintf(prop_name, MAX_PROP_SIZE, "%s-max-microamp", name);
+ 	ret = of_property_read_u32(np, prop_name, &vreg->max_uA);
+ 	if (ret) {
+ 		dev_err(dev, "%s: unable to find %s err %d\n",
+ 				__func__, prop_name, ret);
+ 		goto out;
+ 	}
+ 
+ 	vreg->min_uA = 0;
+ 	if (!strcmp(name, "vcc")) {
+ 		if (of_property_read_bool(np, "vcc-supply-1p8")) {
+ 			vreg->min_uV = UFS_VREG_VCC_1P8_MIN_UV;
+ 			vreg->max_uV = UFS_VREG_VCC_1P8_MAX_UV;
+ 		} else {
+ 			vreg->min_uV = UFS_VREG_VCC_MIN_UV;
+ 			vreg->max_uV = UFS_VREG_VCC_MAX_UV;
+ 		}
+ 	} else if (!strcmp(name, "vccq")) {
+ 		vreg->min_uV = UFS_VREG_VCCQ_MIN_UV;
+ 		vreg->max_uV = UFS_VREG_VCCQ_MAX_UV;
+ 	} else if (!strcmp(name, "vccq2")) {
+ 		vreg->min_uV = UFS_VREG_VCCQ2_MIN_UV;
+ 		vreg->max_uV = UFS_VREG_VCCQ2_MAX_UV;
+ 	}
+ 
+ 	goto out;
+ 
+ out:
+ 	if (!ret)
+ 		*out_vreg = vreg;
+ 	return ret;
+ }
+ 
+ /**
+  * ufshcd_parse_regulator_info - get regulator info from device tree
+  * @hba: per adapter instance
+  *
+  * Get regulator info from device tree for vcc, vccq, vccq2 power supplies.
+  * If any of the supplies are not defined it is assumed that they are always-on
+  * and hence return zero. If the property is defined but parsing is failed
+  * then return corresponding error.
+  */
+ static int ufshcd_parse_regulator_info(struct ufs_hba *hba)
+ {
+ 	int err;
+ 	struct device *dev = hba->dev;
+ 	struct ufs_vreg_info *info = &hba->vreg_info;
+ 
+ 	err = ufshcd_populate_vreg(dev, "vdd-hba", &info->vdd_hba);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = ufshcd_populate_vreg(dev, "vcc", &info->vcc);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = ufshcd_populate_vreg(dev, "vccq", &info->vccq);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = ufshcd_populate_vreg(dev, "vccq2", &info->vccq2);
+ out:
+ 	return err;
+ }
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  
  #ifdef CONFIG_PM
  /**
diff --cc drivers/scsi/ufs/ufshcd.c
index c32a478df81b,397081d320b1..000000000000
--- a/drivers/scsi/ufs/ufshcd.c
+++ b/drivers/scsi/ufs/ufshcd.c
@@@ -596,137 -1169,184 +596,143 @@@ static int ufshcd_memory_alloc(struct u
  		goto out;
  	}
  
 -	/* scale up the gear after scaling up clocks */
 -	if (scale_up) {
 -		ret = ufshcd_scale_gear(hba, true);
 -		if (ret) {
 -			ufshcd_scale_clks(hba, false);
 -			goto out;
 -		}
 +	/*
 +	 * Allocate memory for UTP Task Management descriptors
 +	 * UFSHCI requires 1024 byte alignment of UTMRD
 +	 */
 +	utmrdl_size = sizeof(struct utp_task_req_desc) * hba->nutmrs;
 +	hba->utmrdl_base_addr = dma_alloc_coherent(hba->dev,
 +						   utmrdl_size,
 +						   &hba->utmrdl_dma_addr,
 +						   GFP_KERNEL);
 +	if (!hba->utmrdl_base_addr ||
 +	    WARN_ON(hba->utmrdl_dma_addr & (PAGE_SIZE - 1))) {
 +		dev_err(hba->dev,
 +		"Task Management Descriptor Memory allocation failed\n");
 +		goto out;
  	}
  
 -	ret = ufshcd_vops_clk_scale_notify(hba, scale_up, POST_CHANGE);
 -
 -out:
 -	ufshcd_clock_scaling_unprepare(hba);
 -	ufshcd_release(hba);
 -	return ret;
 -}
 -
 -static void ufshcd_clk_scaling_suspend_work(struct work_struct *work)
 -{
 -	struct ufs_hba *hba = container_of(work, struct ufs_hba,
 -					   clk_scaling.suspend_work);
 -	unsigned long irq_flags;
 -
 -	spin_lock_irqsave(hba->host->host_lock, irq_flags);
 -	if (hba->clk_scaling.active_reqs || hba->clk_scaling.is_suspended) {
 -		spin_unlock_irqrestore(hba->host->host_lock, irq_flags);
 -		return;
 +	/* Allocate memory for local reference block */
++<<<<<<< HEAD
 +	hba->lrb = kcalloc(hba->nutrs, sizeof(struct ufshcd_lrb), GFP_KERNEL);
++=======
++	hba->lrb = devm_kcalloc(hba->dev,
++				hba->nutrs, sizeof(struct ufshcd_lrb),
++				GFP_KERNEL);
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
 +	if (!hba->lrb) {
 +		dev_err(hba->dev, "LRB Memory allocation failed\n");
 +		goto out;
  	}
 -	hba->clk_scaling.is_suspended = true;
 -	spin_unlock_irqrestore(hba->host->host_lock, irq_flags);
 -
 -	__ufshcd_suspend_clkscaling(hba);
 +	return 0;
 +out:
 +	ufshcd_free_hba_memory(hba);
 +	return -ENOMEM;
  }
  
 -static void ufshcd_clk_scaling_resume_work(struct work_struct *work)
 +/**
 + * ufshcd_host_memory_configure - configure local reference block with
 + *				memory offsets
 + * @hba: per adapter instance
 + *
 + * Configure Host memory space
 + * 1. Update Corresponding UTRD.UCDBA and UTRD.UCDBAU with UCD DMA
 + * address.
 + * 2. Update each UTRD with Response UPIU offset, Response UPIU length
 + * and PRDT offset.
 + * 3. Save the corresponding addresses of UTRD, UCD.CMD, UCD.RSP and UCD.PRDT
 + * into local reference block.
 + */
 +static void ufshcd_host_memory_configure(struct ufs_hba *hba)
  {
 -	struct ufs_hba *hba = container_of(work, struct ufs_hba,
 -					   clk_scaling.resume_work);
 -	unsigned long irq_flags;
 +	struct utp_transfer_cmd_desc *cmd_descp;
 +	struct utp_transfer_req_desc *utrdlp;
 +	dma_addr_t cmd_desc_dma_addr;
 +	dma_addr_t cmd_desc_element_addr;
 +	u16 response_offset;
 +	u16 prdt_offset;
 +	int cmd_desc_size;
 +	int i;
  
 -	spin_lock_irqsave(hba->host->host_lock, irq_flags);
 -	if (!hba->clk_scaling.is_suspended) {
 -		spin_unlock_irqrestore(hba->host->host_lock, irq_flags);
 -		return;
 -	}
 -	hba->clk_scaling.is_suspended = false;
 -	spin_unlock_irqrestore(hba->host->host_lock, irq_flags);
 +	utrdlp = hba->utrdl_base_addr;
 +	cmd_descp = hba->ucdl_base_addr;
  
 -	devfreq_resume_device(hba->devfreq);
 -}
 +	response_offset =
 +		offsetof(struct utp_transfer_cmd_desc, response_upiu);
 +	prdt_offset =
 +		offsetof(struct utp_transfer_cmd_desc, prd_table);
  
 -static int ufshcd_devfreq_target(struct device *dev,
 -				unsigned long *freq, u32 flags)
 -{
 -	int ret = 0;
 -	struct ufs_hba *hba = dev_get_drvdata(dev);
 -	ktime_t start;
 -	bool scale_up, sched_clk_scaling_suspend_work = false;
 -	struct list_head *clk_list = &hba->clk_list_head;
 -	struct ufs_clk_info *clki;
 -	unsigned long irq_flags;
 -
 -	if (!ufshcd_is_clkscaling_supported(hba))
 -		return -EINVAL;
 -
 -	spin_lock_irqsave(hba->host->host_lock, irq_flags);
 -	if (ufshcd_eh_in_progress(hba)) {
 -		spin_unlock_irqrestore(hba->host->host_lock, irq_flags);
 -		return 0;
 -	}
 +	cmd_desc_size = sizeof(struct utp_transfer_cmd_desc);
 +	cmd_desc_dma_addr = hba->ucdl_dma_addr;
  
 -	if (!hba->clk_scaling.active_reqs)
 -		sched_clk_scaling_suspend_work = true;
 +	for (i = 0; i < hba->nutrs; i++) {
 +		/* Configure UTRD with command descriptor base address */
 +		cmd_desc_element_addr =
 +				(cmd_desc_dma_addr + (cmd_desc_size * i));
 +		utrdlp[i].command_desc_base_addr_lo =
 +				cpu_to_le32(lower_32_bits(cmd_desc_element_addr));
 +		utrdlp[i].command_desc_base_addr_hi =
 +				cpu_to_le32(upper_32_bits(cmd_desc_element_addr));
  
 -	if (list_empty(clk_list)) {
 -		spin_unlock_irqrestore(hba->host->host_lock, irq_flags);
 -		goto out;
 -	}
 +		/* Response upiu and prdt offset should be in double words */
 +		utrdlp[i].response_upiu_offset =
 +				cpu_to_le16((response_offset >> 2));
 +		utrdlp[i].prd_table_offset =
 +				cpu_to_le16((prdt_offset >> 2));
 +		utrdlp[i].response_upiu_length =
 +				cpu_to_le16(ALIGNED_UPIU_SIZE);
  
 -	clki = list_first_entry(&hba->clk_list_head, struct ufs_clk_info, list);
 -	scale_up = (*freq == clki->max_freq) ? true : false;
 -	if (!ufshcd_is_devfreq_scaling_required(hba, scale_up)) {
 -		spin_unlock_irqrestore(hba->host->host_lock, irq_flags);
 -		ret = 0;
 -		goto out; /* no state change required */
 +		hba->lrb[i].utr_descriptor_ptr = (utrdlp + i);
 +		hba->lrb[i].ucd_cmd_ptr =
 +			(struct utp_upiu_cmd *)(cmd_descp + i);
 +		hba->lrb[i].ucd_rsp_ptr =
 +			(struct utp_upiu_rsp *)cmd_descp[i].response_upiu;
 +		hba->lrb[i].ucd_prdt_ptr =
 +			(struct ufshcd_sg_entry *)cmd_descp[i].prd_table;
  	}
 -	spin_unlock_irqrestore(hba->host->host_lock, irq_flags);
 -
 -	start = ktime_get();
 -	ret = ufshcd_devfreq_scale(hba, scale_up);
 -
 -	trace_ufshcd_profile_clk_scaling(dev_name(hba->dev),
 -		(scale_up ? "up" : "down"),
 -		ktime_to_us(ktime_sub(ktime_get(), start)), ret);
 -
 -out:
 -	if (sched_clk_scaling_suspend_work)
 -		queue_work(hba->clk_scaling.workq,
 -			   &hba->clk_scaling.suspend_work);
 -
 -	return ret;
  }
  
 -
 -static int ufshcd_devfreq_get_dev_status(struct device *dev,
 -		struct devfreq_dev_status *stat)
 +/**
 + * ufshcd_dme_link_startup - Notify Unipro to perform link startup
 + * @hba: per adapter instance
 + *
 + * UIC_CMD_DME_LINK_STARTUP command must be issued to Unipro layer,
 + * in order to initialize the Unipro link startup procedure.
 + * Once the Unipro links are up, the device connected to the controller
 + * is detected.
 + *
 + * Returns 0 on success, non-zero value on failure
 + */
 +static int ufshcd_dme_link_startup(struct ufs_hba *hba)
  {
 -	struct ufs_hba *hba = dev_get_drvdata(dev);
 -	struct ufs_clk_scaling *scaling = &hba->clk_scaling;
 +	struct uic_command *uic_cmd;
  	unsigned long flags;
  
 -	if (!ufshcd_is_clkscaling_supported(hba))
 -		return -EINVAL;
 -
 -	memset(stat, 0, sizeof(*stat));
 -
 -	spin_lock_irqsave(hba->host->host_lock, flags);
 -	if (!scaling->window_start_t)
 -		goto start_window;
 -
 -	if (scaling->is_busy_started)
 -		scaling->tot_busy_t += ktime_to_us(ktime_sub(ktime_get(),
 -					scaling->busy_start_t));
 -
 -	stat->total_time = jiffies_to_usecs((long)jiffies -
 -				(long)scaling->window_start_t);
 -	stat->busy_time = scaling->tot_busy_t;
 -start_window:
 -	scaling->window_start_t = jiffies;
 -	scaling->tot_busy_t = 0;
 -
 -	if (hba->outstanding_reqs) {
 -		scaling->busy_start_t = ktime_get();
 -		scaling->is_busy_started = true;
 -	} else {
 -		scaling->busy_start_t = 0;
 -		scaling->is_busy_started = false;
 +	/* check if controller is ready to accept UIC commands */
 +	if (((readl(hba->mmio_base + REG_CONTROLLER_STATUS)) &
 +	    UIC_COMMAND_READY) == 0x0) {
 +		dev_err(hba->dev,
 +			"Controller not ready"
 +			" to accept UIC commands\n");
 +		return -EIO;
  	}
 -	spin_unlock_irqrestore(hba->host->host_lock, flags);
 -	return 0;
 -}
  
 -static struct devfreq_dev_profile ufs_devfreq_profile = {
 -	.polling_ms	= 100,
 -	.target		= ufshcd_devfreq_target,
 -	.get_dev_status	= ufshcd_devfreq_get_dev_status,
 -};
 +	spin_lock_irqsave(hba->host->host_lock, flags);
  
 -static int ufshcd_devfreq_init(struct ufs_hba *hba)
 -{
 -	struct list_head *clk_list = &hba->clk_list_head;
 -	struct ufs_clk_info *clki;
 -	struct devfreq *devfreq;
 -	int ret;
 -
 -	/* Skip devfreq if we don't have any clocks in the list */
 -	if (list_empty(clk_list))
 -		return 0;
 -
 -	clki = list_first_entry(clk_list, struct ufs_clk_info, list);
 -	dev_pm_opp_add(hba->dev, clki->min_freq, 0);
 -	dev_pm_opp_add(hba->dev, clki->max_freq, 0);
 -
 -	devfreq = devfreq_add_device(hba->dev,
 -			&ufs_devfreq_profile,
 -			DEVFREQ_GOV_SIMPLE_ONDEMAND,
 -			NULL);
 -	if (IS_ERR(devfreq)) {
 -		ret = PTR_ERR(devfreq);
 -		dev_err(hba->dev, "Unable to register with devfreq %d\n", ret);
 -
 -		dev_pm_opp_remove(hba->dev, clki->min_freq);
 -		dev_pm_opp_remove(hba->dev, clki->max_freq);
 -		return ret;
 -	}
 +	/* form UIC command */
 +	uic_cmd = &hba->active_uic_cmd;
 +	uic_cmd->command = UIC_CMD_DME_LINK_STARTUP;
 +	uic_cmd->argument1 = 0;
 +	uic_cmd->argument2 = 0;
 +	uic_cmd->argument3 = 0;
  
 -	hba->devfreq = devfreq;
 +	/* enable UIC related interrupts */
 +	hba->int_enable_mask |= UIC_COMMAND_COMPL;
 +	ufshcd_int_config(hba, UFSHCD_INT_ENABLE);
  
 +	/* sending UIC commands to controller */
 +	ufshcd_send_uic_command(hba, uic_cmd);
 +	spin_unlock_irqrestore(hba->host->host_lock, flags);
  	return 0;
  }
  
diff --cc drivers/spi/spi-davinci.c
index df0aacc6fc3b,577084bb911b..000000000000
--- a/drivers/spi/spi-davinci.c
+++ b/drivers/spi/spi-davinci.c
@@@ -886,6 -923,15 +886,18 @@@ static int davinci_spi_probe(struct pla
  	/* pdata in dspi is now updated and point pdata to that */
  	pdata = &dspi->pdata;
  
++<<<<<<< HEAD
++=======
+ 	dspi->bytes_per_word = devm_kcalloc(&pdev->dev,
+ 					    pdata->num_chipselect,
+ 					    sizeof(*dspi->bytes_per_word),
+ 					    GFP_KERNEL);
+ 	if (dspi->bytes_per_word == NULL) {
+ 		ret = -ENOMEM;
+ 		goto free_master;
+ 	}
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
  	if (r == NULL) {
  		ret = -ENOENT;
diff --cc drivers/spi/spi-ep93xx.c
index d7bac60253c9,f1526757aaf6..000000000000
--- a/drivers/spi/spi-ep93xx.c
+++ b/drivers/spi/spi-ep93xx.c
@@@ -1031,21 -638,62 +1031,47 @@@ static int ep93xx_spi_probe(struct plat
  	struct resource *res;
  	int irq;
  	int error;
 -	int i;
 -
 -	info = dev_get_platdata(&pdev->dev);
 -	if (!info) {
 -		dev_err(&pdev->dev, "missing platform data\n");
 -		return -EINVAL;
 -	}
 -
 -	irq = platform_get_irq(pdev, 0);
 -	if (irq < 0) {
 -		dev_err(&pdev->dev, "failed to get irq resources\n");
 -		return -EBUSY;
 -	}
  
 -	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 -	if (!res) {
 -		dev_err(&pdev->dev, "unable to get iomem resource\n");
 -		return -ENODEV;
 -	}
 +	info = pdev->dev.platform_data;
  
  	master = spi_alloc_master(&pdev->dev, sizeof(*espi));
 -	if (!master)
 +	if (!master) {
 +		dev_err(&pdev->dev, "failed to allocate spi master\n");
  		return -ENOMEM;
 +	}
  
 -	master->prepare_transfer_hardware = ep93xx_spi_prepare_hardware;
 -	master->unprepare_transfer_hardware = ep93xx_spi_unprepare_hardware;
 -	master->prepare_message = ep93xx_spi_prepare_message;
 -	master->transfer_one = ep93xx_spi_transfer_one;
 +	master->setup = ep93xx_spi_setup;
 +	master->transfer = ep93xx_spi_transfer;
 +	master->cleanup = ep93xx_spi_cleanup;
  	master->bus_num = pdev->id;
 -	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
 -	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);
 -
  	master->num_chipselect = info->num_chipselect;
++<<<<<<< HEAD
 +	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
++=======
+ 	master->cs_gpios = devm_kcalloc(&master->dev,
+ 					master->num_chipselect, sizeof(int),
+ 					GFP_KERNEL);
+ 	if (!master->cs_gpios) {
+ 		error = -ENOMEM;
+ 		goto fail_release_master;
+ 	}
+ 
+ 	for (i = 0; i < master->num_chipselect; i++) {
+ 		master->cs_gpios[i] = info->chipselect[i];
+ 
+ 		if (!gpio_is_valid(master->cs_gpios[i]))
+ 			continue;
+ 
+ 		error = devm_gpio_request_one(&pdev->dev, master->cs_gpios[i],
+ 					      GPIOF_OUT_INIT_HIGH,
+ 					      "ep93xx-spi");
+ 		if (error) {
+ 			dev_err(&pdev->dev, "could not request cs gpio %d\n",
+ 				master->cs_gpios[i]);
+ 			goto fail_release_master;
+ 		}
+ 	}
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  
  	platform_set_drvdata(pdev, master);
  
diff --cc drivers/spi/spi-gpio.c
index 0f0e9656a791,6ae92d4dca19..000000000000
--- a/drivers/spi/spi-gpio.c
+++ b/drivers/spi/spi-gpio.c
@@@ -430,24 -367,24 +430,35 @@@ static int spi_gpio_probe(struct platfo
  		return -ENODEV;
  #endif
  
 -	master = spi_alloc_master(&pdev->dev, sizeof(*spi_gpio));
 -	if (!master)
 -		return -ENOMEM;
 +	if (use_of && !SPI_N_CHIPSEL)
 +		num_devices = 1;
 +	else
 +		num_devices = SPI_N_CHIPSEL;
  
 +	status = spi_gpio_request(pdata, dev_name(&pdev->dev), &master_flags);
 +	if (status < 0)
 +		return status;
 +
 +	master = spi_alloc_master(&pdev->dev, sizeof(*spi_gpio) +
 +					(sizeof(unsigned long) * num_devices));
 +	if (!master) {
 +		status = -ENOMEM;
 +		goto gpio_free;
 +	}
  	spi_gpio = spi_master_get_devdata(master);
++<<<<<<< HEAD
++=======
+ 
+ 	spi_gpio->cs_gpios = devm_kcalloc(&pdev->dev,
+ 				pdata->num_chipselect,
+ 				sizeof(*spi_gpio->cs_gpios),
+ 				GFP_KERNEL);
+ 	if (!spi_gpio->cs_gpios)
+ 		return -ENOMEM;
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  	platform_set_drvdata(pdev, spi_gpio);
  
 -	/* Determine if we have chip selects connected */
 -	spi_gpio->has_cs = !!pdata->num_chipselect;
 -
  	spi_gpio->pdev = pdev;
  	if (pdata)
  		spi_gpio->pdata = *pdata;
diff --cc drivers/spi/spi-imx.c
index 0befeeb522f4,d3b21faf6b1f..000000000000
--- a/drivers/spi/spi-imx.c
+++ b/drivers/spi/spi-imx.c
@@@ -781,28 -1489,43 +781,40 @@@ static int spi_imx_probe(struct platfor
  	if (!master)
  		return -ENOMEM;
  
 -	ret = of_property_read_u32(np, "fsl,spi-rdy-drctl", &spi_drctl);
 -	if ((ret < 0) || (spi_drctl >= 0x3)) {
 -		/* '11' is reserved */
 -		spi_drctl = 0;
 -	}
 -
  	platform_set_drvdata(pdev, master);
  
 -	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 32);
 -	master->bus_num = np ? -1 : pdev->id;
 +	master->bus_num = pdev->id;
 +	master->num_chipselect = num_cs;
  
  	spi_imx = spi_master_get_devdata(master);
 -	spi_imx->bitbang.master = master;
 -	spi_imx->dev = &pdev->dev;
 -	spi_imx->slave_mode = slave_mode;
 -
 -	spi_imx->devtype_data = devtype_data;
 -
 +	spi_imx->bitbang.master = spi_master_get(master);
 +
 +	for (i = 0; i < master->num_chipselect; i++) {
 +		int cs_gpio = of_get_named_gpio(np, "cs-gpios", i);
 +		if (!gpio_is_valid(cs_gpio) && mxc_platform_info)
 +			cs_gpio = mxc_platform_info->chipselect[i];
 +
++<<<<<<< HEAD
 +		spi_imx->chipselect[i] = cs_gpio;
 +		if (!gpio_is_valid(cs_gpio))
 +			continue;
++=======
+ 	/* Get number of chip selects, either platform data or OF */
+ 	if (mxc_platform_info) {
+ 		master->num_chipselect = mxc_platform_info->num_chipselect;
+ 		if (mxc_platform_info->chipselect) {
+ 			master->cs_gpios = devm_kcalloc(&master->dev,
+ 				master->num_chipselect, sizeof(int),
+ 				GFP_KERNEL);
+ 			if (!master->cs_gpios)
+ 				return -ENOMEM;
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  
 -			for (i = 0; i < master->num_chipselect; i++)
 -				master->cs_gpios[i] = mxc_platform_info->chipselect[i];
 +		ret = gpio_request(spi_imx->chipselect[i], DRIVER_NAME);
 +		if (ret) {
 +			dev_err(&pdev->dev, "can't get cs gpios\n");
 +			goto out_gpio_free;
  		}
 -	} else {
 -		u32 num_cs;
 -
 -		if (!of_property_read_u32(np, "num-cs", &num_cs))
 -			master->num_chipselect = num_cs;
 -		/* If not preset, default value of 1 is used */
  	}
  
  	spi_imx->bitbang.chipselect = spi_imx_chipselect;
diff --cc drivers/spi/spi.c
index bff6fccdf1f3,ec395a6baf9c..000000000000
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@@ -1073,15 -2049,14 +1073,19 @@@ static int of_spi_register_master(struc
  	else if (nb < 0)
  		return nb;
  
++<<<<<<< HEAD
 +	cs = devm_kzalloc(&master->dev,
 +			  sizeof(int) * master->num_chipselect,
++=======
+ 	cs = devm_kcalloc(&ctlr->dev, ctlr->num_chipselect, sizeof(int),
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  			  GFP_KERNEL);
 -	ctlr->cs_gpios = cs;
 +	master->cs_gpios = cs;
  
 -	if (!ctlr->cs_gpios)
 +	if (!master->cs_gpios)
  		return -ENOMEM;
  
 -	for (i = 0; i < ctlr->num_chipselect; i++)
 +	for (i = 0; i < master->num_chipselect; i++)
  		cs[i] = -ENOENT;
  
  	for (i = 0; i < nb; i++)
diff --cc drivers/usb/gadget/atmel_usba_udc.c
index 5a5128a226f7,17147b8c771e..000000000000
--- a/drivers/usb/gadget/atmel_usba_udc.c
+++ b/drivers/usb/gadget/atmel_usba_udc.c
@@@ -1835,18 -1970,215 +1835,205 @@@ static int atmel_usba_stop(struct usb_g
  	return 0;
  }
  
 -static void at91sam9rl_toggle_bias(struct usba_udc *udc, int is_on)
 +static int __init usba_udc_probe(struct platform_device *pdev)
  {
++<<<<<<< HEAD:drivers/usb/gadget/atmel_usba_udc.c
 +	struct usba_platform_data *pdata = pdev->dev.platform_data;
 +	struct resource *regs, *fifo;
++=======
+ 	regmap_update_bits(udc->pmc, AT91_CKGR_UCKR, AT91_PMC_BIASEN,
+ 			   is_on ? AT91_PMC_BIASEN : 0);
+ }
+ 
+ static void at91sam9g45_pulse_bias(struct usba_udc *udc)
+ {
+ 	regmap_update_bits(udc->pmc, AT91_CKGR_UCKR, AT91_PMC_BIASEN, 0);
+ 	regmap_update_bits(udc->pmc, AT91_CKGR_UCKR, AT91_PMC_BIASEN,
+ 			   AT91_PMC_BIASEN);
+ }
+ 
+ static const struct usba_udc_errata at91sam9rl_errata = {
+ 	.toggle_bias = at91sam9rl_toggle_bias,
+ };
+ 
+ static const struct usba_udc_errata at91sam9g45_errata = {
+ 	.pulse_bias = at91sam9g45_pulse_bias,
+ };
+ 
+ static const struct of_device_id atmel_udc_dt_ids[] = {
+ 	{ .compatible = "atmel,at91sam9rl-udc", .data = &at91sam9rl_errata },
+ 	{ .compatible = "atmel,at91sam9g45-udc", .data = &at91sam9g45_errata },
+ 	{ .compatible = "atmel,sama5d3-udc" },
+ 	{ /* sentinel */ }
+ };
+ 
+ MODULE_DEVICE_TABLE(of, atmel_udc_dt_ids);
+ 
+ static struct usba_ep * atmel_udc_of_init(struct platform_device *pdev,
+ 						    struct usba_udc *udc)
+ {
+ 	u32 val;
+ 	const char *name;
+ 	struct device_node *np = pdev->dev.of_node;
+ 	const struct of_device_id *match;
+ 	struct device_node *pp;
+ 	int i, ret;
+ 	struct usba_ep *eps, *ep;
+ 
+ 	match = of_match_node(atmel_udc_dt_ids, np);
+ 	if (!match)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	udc->errata = match->data;
+ 	udc->pmc = syscon_regmap_lookup_by_compatible("atmel,at91sam9g45-pmc");
+ 	if (IS_ERR(udc->pmc))
+ 		udc->pmc = syscon_regmap_lookup_by_compatible("atmel,at91sam9x5-pmc");
+ 	if (udc->errata && IS_ERR(udc->pmc))
+ 		return ERR_CAST(udc->pmc);
+ 
+ 	udc->num_ep = 0;
+ 
+ 	udc->vbus_pin = devm_gpiod_get_optional(&pdev->dev, "atmel,vbus",
+ 						GPIOD_IN);
+ 
+ 	if (fifo_mode == 0) {
+ 		pp = NULL;
+ 		while ((pp = of_get_next_child(np, pp)))
+ 			udc->num_ep++;
+ 		udc->configured_ep = 1;
+ 	} else {
+ 		udc->num_ep = usba_config_fifo_table(udc);
+ 	}
+ 
+ 	eps = devm_kcalloc(&pdev->dev, udc->num_ep, sizeof(struct usba_ep),
+ 			   GFP_KERNEL);
+ 	if (!eps)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	udc->gadget.ep0 = &eps[0].ep;
+ 
+ 	INIT_LIST_HEAD(&eps[0].ep.ep_list);
+ 
+ 	pp = NULL;
+ 	i = 0;
+ 	while ((pp = of_get_next_child(np, pp)) && i < udc->num_ep) {
+ 		ep = &eps[i];
+ 
+ 		ret = of_property_read_u32(pp, "reg", &val);
+ 		if (ret) {
+ 			dev_err(&pdev->dev, "of_probe: reg error(%d)\n", ret);
+ 			goto err;
+ 		}
+ 		ep->index = fifo_mode ? udc->fifo_cfg[i].hw_ep_num : val;
+ 
+ 		ret = of_property_read_u32(pp, "atmel,fifo-size", &val);
+ 		if (ret) {
+ 			dev_err(&pdev->dev, "of_probe: fifo-size error(%d)\n", ret);
+ 			goto err;
+ 		}
+ 		if (fifo_mode) {
+ 			if (val < udc->fifo_cfg[i].fifo_size) {
+ 				dev_warn(&pdev->dev,
+ 					 "Using max fifo-size value from DT\n");
+ 				ep->fifo_size = val;
+ 			} else {
+ 				ep->fifo_size = udc->fifo_cfg[i].fifo_size;
+ 			}
+ 		} else {
+ 			ep->fifo_size = val;
+ 		}
+ 
+ 		ret = of_property_read_u32(pp, "atmel,nb-banks", &val);
+ 		if (ret) {
+ 			dev_err(&pdev->dev, "of_probe: nb-banks error(%d)\n", ret);
+ 			goto err;
+ 		}
+ 		if (fifo_mode) {
+ 			if (val < udc->fifo_cfg[i].nr_banks) {
+ 				dev_warn(&pdev->dev,
+ 					 "Using max nb-banks value from DT\n");
+ 				ep->nr_banks = val;
+ 			} else {
+ 				ep->nr_banks = udc->fifo_cfg[i].nr_banks;
+ 			}
+ 		} else {
+ 			ep->nr_banks = val;
+ 		}
+ 
+ 		ep->can_dma = of_property_read_bool(pp, "atmel,can-dma");
+ 		ep->can_isoc = of_property_read_bool(pp, "atmel,can-isoc");
+ 
+ 		ret = of_property_read_string(pp, "name", &name);
+ 		if (ret) {
+ 			dev_err(&pdev->dev, "of_probe: name error(%d)\n", ret);
+ 			goto err;
+ 		}
+ 		sprintf(ep->name, "ep%d", ep->index);
+ 		ep->ep.name = ep->name;
+ 
+ 		ep->ep_regs = udc->regs + USBA_EPT_BASE(i);
+ 		ep->dma_regs = udc->regs + USBA_DMA_BASE(i);
+ 		ep->fifo = udc->fifo + USBA_FIFO_BASE(i);
+ 		ep->ep.ops = &usba_ep_ops;
+ 		usb_ep_set_maxpacket_limit(&ep->ep, ep->fifo_size);
+ 		ep->udc = udc;
+ 		INIT_LIST_HEAD(&ep->queue);
+ 
+ 		if (ep->index == 0) {
+ 			ep->ep.caps.type_control = true;
+ 		} else {
+ 			ep->ep.caps.type_iso = ep->can_isoc;
+ 			ep->ep.caps.type_bulk = true;
+ 			ep->ep.caps.type_int = true;
+ 		}
+ 
+ 		ep->ep.caps.dir_in = true;
+ 		ep->ep.caps.dir_out = true;
+ 
+ 		if (fifo_mode != 0) {
+ 			/*
+ 			 * Generate ept_cfg based on FIFO size and
+ 			 * banks number
+ 			 */
+ 			if (ep->fifo_size  <= 8)
+ 				ep->ept_cfg = USBA_BF(EPT_SIZE, USBA_EPT_SIZE_8);
+ 			else
+ 				/* LSB is bit 1, not 0 */
+ 				ep->ept_cfg =
+ 				  USBA_BF(EPT_SIZE, fls(ep->fifo_size - 1) - 3);
+ 
+ 			ep->ept_cfg |= USBA_BF(BK_NUMBER, ep->nr_banks);
+ 		}
+ 
+ 		if (i)
+ 			list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+ 
+ 		i++;
+ 	}
+ 
+ 	if (i == 0) {
+ 		dev_err(&pdev->dev, "of_probe: no endpoint specified\n");
+ 		ret = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	return eps;
+ err:
+ 	return ERR_PTR(ret);
+ }
+ 
+ static int usba_udc_probe(struct platform_device *pdev)
+ {
+ 	struct resource *res;
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc()):drivers/usb/gadget/udc/atmel_usba_udc.c
  	struct clk *pclk, *hclk;
 -	struct usba_udc *udc;
 +	struct usba_udc *udc = &the_udc;
  	int irq, ret, i;
  
 -	udc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);
 -	if (!udc)
 -		return -ENOMEM;
 -
 -	udc->gadget = usba_gadget_template;
 -	INIT_LIST_HEAD(&udc->gadget.ep_list);
 -
 -	res = platform_get_resource(pdev, IORESOURCE_MEM, CTRL_IOMEM_ID);
 -	udc->regs = devm_ioremap_resource(&pdev->dev, res);
 -	if (IS_ERR(udc->regs))
 -		return PTR_ERR(udc->regs);
 -	dev_info(&pdev->dev, "MMIO registers at %pR mapped at %p\n",
 -		 res, udc->regs);
 -
 -	res = platform_get_resource(pdev, IORESOURCE_MEM, FIFO_IOMEM_ID);
 -	udc->fifo = devm_ioremap_resource(&pdev->dev, res);
 -	if (IS_ERR(udc->fifo))
 -		return PTR_ERR(udc->fifo);
 -	dev_info(&pdev->dev, "FIFO at %pR mapped at %p\n", res, udc->fifo);
 +	regs = platform_get_resource(pdev, IORESOURCE_MEM, CTRL_IOMEM_ID);
 +	fifo = platform_get_resource(pdev, IORESOURCE_MEM, FIFO_IOMEM_ID);
 +	if (!regs || !fifo || !pdata)
 +		return -ENXIO;
  
  	irq = platform_get_irq(pdev, 0);
  	if (irq < 0)
diff --cc sound/soc/intel/skylake/skl-topology.c
index 3b1dca419883,fcdc716754b6..000000000000
--- a/sound/soc/intel/skylake/skl-topology.c
+++ b/sound/soc/intel/skylake/skl-topology.c
@@@ -2724,6 -2729,167 +2728,170 @@@ static int skl_tplg_get_desc_blocks(str
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ /* Functions to parse private data from configuration file format v4 */
+ 
+ /*
+  * Add pipeline from topology binary into driver pipeline list
+  *
+  * If already added we return that instance
+  * Otherwise we create a new instance and add into driver list
+  */
+ static int skl_tplg_add_pipe_v4(struct device *dev,
+ 				struct skl_module_cfg *mconfig, struct skl *skl,
+ 				struct skl_dfw_v4_pipe *dfw_pipe)
+ {
+ 	struct skl_pipeline *ppl;
+ 	struct skl_pipe *pipe;
+ 	struct skl_pipe_params *params;
+ 
+ 	list_for_each_entry(ppl, &skl->ppl_list, node) {
+ 		if (ppl->pipe->ppl_id == dfw_pipe->pipe_id) {
+ 			mconfig->pipe = ppl->pipe;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	ppl = devm_kzalloc(dev, sizeof(*ppl), GFP_KERNEL);
+ 	if (!ppl)
+ 		return -ENOMEM;
+ 
+ 	pipe = devm_kzalloc(dev, sizeof(*pipe), GFP_KERNEL);
+ 	if (!pipe)
+ 		return -ENOMEM;
+ 
+ 	params = devm_kzalloc(dev, sizeof(*params), GFP_KERNEL);
+ 	if (!params)
+ 		return -ENOMEM;
+ 
+ 	pipe->ppl_id = dfw_pipe->pipe_id;
+ 	pipe->memory_pages = dfw_pipe->memory_pages;
+ 	pipe->pipe_priority = dfw_pipe->pipe_priority;
+ 	pipe->conn_type = dfw_pipe->conn_type;
+ 	pipe->state = SKL_PIPE_INVALID;
+ 	pipe->p_params = params;
+ 	INIT_LIST_HEAD(&pipe->w_list);
+ 
+ 	ppl->pipe = pipe;
+ 	list_add(&ppl->node, &skl->ppl_list);
+ 
+ 	mconfig->pipe = pipe;
+ 
+ 	return 0;
+ }
+ 
+ static void skl_fill_module_pin_info_v4(struct skl_dfw_v4_module_pin *dfw_pin,
+ 					struct skl_module_pin *m_pin,
+ 					bool is_dynamic, int max_pin)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < max_pin; i++) {
+ 		m_pin[i].id.module_id = dfw_pin[i].module_id;
+ 		m_pin[i].id.instance_id = dfw_pin[i].instance_id;
+ 		m_pin[i].in_use = false;
+ 		m_pin[i].is_dynamic = is_dynamic;
+ 		m_pin[i].pin_state = SKL_PIN_UNBIND;
+ 	}
+ }
+ 
+ static void skl_tplg_fill_fmt_v4(struct skl_module_pin_fmt *dst_fmt,
+ 				 struct skl_dfw_v4_module_fmt *src_fmt,
+ 				 int pins)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < pins; i++) {
+ 		dst_fmt[i].fmt.channels  = src_fmt[i].channels;
+ 		dst_fmt[i].fmt.s_freq = src_fmt[i].freq;
+ 		dst_fmt[i].fmt.bit_depth = src_fmt[i].bit_depth;
+ 		dst_fmt[i].fmt.valid_bit_depth = src_fmt[i].valid_bit_depth;
+ 		dst_fmt[i].fmt.ch_cfg = src_fmt[i].ch_cfg;
+ 		dst_fmt[i].fmt.ch_map = src_fmt[i].ch_map;
+ 		dst_fmt[i].fmt.interleaving_style =
+ 						src_fmt[i].interleaving_style;
+ 		dst_fmt[i].fmt.sample_type = src_fmt[i].sample_type;
+ 	}
+ }
+ 
+ static int skl_tplg_get_pvt_data_v4(struct snd_soc_tplg_dapm_widget *tplg_w,
+ 				    struct skl *skl, struct device *dev,
+ 				    struct skl_module_cfg *mconfig)
+ {
+ 	struct skl_dfw_v4_module *dfw =
+ 				(struct skl_dfw_v4_module *)tplg_w->priv.data;
+ 	int ret;
+ 
+ 	dev_dbg(dev, "Parsing Skylake v4 widget topology data\n");
+ 
+ 	ret = guid_parse(dfw->uuid, (guid_t *)mconfig->guid);
+ 	if (ret)
+ 		return ret;
+ 	mconfig->id.module_id = -1;
+ 	mconfig->id.instance_id = dfw->instance_id;
+ 	mconfig->module->resources[0].cps = dfw->max_mcps;
+ 	mconfig->module->resources[0].ibs = dfw->ibs;
+ 	mconfig->module->resources[0].obs = dfw->obs;
+ 	mconfig->core_id = dfw->core_id;
+ 	mconfig->module->max_input_pins = dfw->max_in_queue;
+ 	mconfig->module->max_output_pins = dfw->max_out_queue;
+ 	mconfig->module->loadable = dfw->is_loadable;
+ 	skl_tplg_fill_fmt_v4(mconfig->module->formats[0].inputs, dfw->in_fmt,
+ 			     MAX_IN_QUEUE);
+ 	skl_tplg_fill_fmt_v4(mconfig->module->formats[0].outputs, dfw->out_fmt,
+ 			     MAX_OUT_QUEUE);
+ 
+ 	mconfig->params_fixup = dfw->params_fixup;
+ 	mconfig->converter = dfw->converter;
+ 	mconfig->m_type = dfw->module_type;
+ 	mconfig->vbus_id = dfw->vbus_id;
+ 	mconfig->module->resources[0].is_pages = dfw->mem_pages;
+ 
+ 	ret = skl_tplg_add_pipe_v4(dev, mconfig, skl, &dfw->pipe);
+ 	if (ret)
+ 		return ret;
+ 
+ 	mconfig->dev_type = dfw->dev_type;
+ 	mconfig->hw_conn_type = dfw->hw_conn_type;
+ 	mconfig->time_slot = dfw->time_slot;
+ 	mconfig->formats_config.caps_size = dfw->caps.caps_size;
+ 
+ 	mconfig->m_in_pin = devm_kcalloc(dev,
+ 				MAX_IN_QUEUE, sizeof(*mconfig->m_in_pin),
+ 				GFP_KERNEL);
+ 	if (!mconfig->m_in_pin)
+ 		return -ENOMEM;
+ 
+ 	mconfig->m_out_pin = devm_kcalloc(dev,
+ 				MAX_OUT_QUEUE, sizeof(*mconfig->m_out_pin),
+ 				GFP_KERNEL);
+ 	if (!mconfig->m_out_pin)
+ 		return -ENOMEM;
+ 
+ 	skl_fill_module_pin_info_v4(dfw->in_pin, mconfig->m_in_pin,
+ 				    dfw->is_dynamic_in_pin,
+ 				    mconfig->module->max_input_pins);
+ 	skl_fill_module_pin_info_v4(dfw->out_pin, mconfig->m_out_pin,
+ 				    dfw->is_dynamic_out_pin,
+ 				    mconfig->module->max_output_pins);
+ 
+ 	if (mconfig->formats_config.caps_size) {
+ 		mconfig->formats_config.set_params = dfw->caps.set_params;
+ 		mconfig->formats_config.param_id = dfw->caps.param_id;
+ 		mconfig->formats_config.caps =
+ 		devm_kzalloc(dev, mconfig->formats_config.caps_size,
+ 			     GFP_KERNEL);
+ 		if (!mconfig->formats_config.caps)
+ 			return -ENOMEM;
+ 		memcpy(mconfig->formats_config.caps, dfw->caps.caps,
+ 		       dfw->caps.caps_size);
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> a86854d0c599 (treewide: devm_kzalloc() -> devm_kcalloc())
  /*
   * Parse the private data for the token and corresponding value.
   * The private data can have multiple data blocks. So, a data block
* Unmerged path drivers/bus/fsl-mc/fsl-mc-allocator.c
* Unmerged path drivers/clk/bcm/clk-bcm2835.c
* Unmerged path drivers/clk/ti/adpll.c
* Unmerged path drivers/cpufreq/brcmstb-avs-cpufreq.c
* Unmerged path drivers/crypto/marvell/cesa.c
* Unmerged path drivers/devfreq/event/exynos-ppmu.c
* Unmerged path drivers/dma/k3dma.c
* Unmerged path drivers/dma/mv_xor_v2.c
* Unmerged path drivers/dma/s3c24xx-dma.c
* Unmerged path drivers/dma/zx_dma.c
* Unmerged path drivers/firmware/arm_scpi.c
* Unmerged path drivers/firmware/ti_sci.c
* Unmerged path drivers/gpio/gpio-aspeed.c
* Unmerged path drivers/gpio/gpio-bcm-kona.c
* Unmerged path drivers/gpio/gpio-thunderx.c
* Unmerged path drivers/gpu/drm/msm/hdmi/hdmi.c
* Unmerged path drivers/gpu/drm/msm/hdmi/hdmi_phy.c
* Unmerged path drivers/hwmon/aspeed-pwm-tacho.c
* Unmerged path drivers/hwmon/nct6683.c
* Unmerged path drivers/hwmon/pwm-fan.c
* Unmerged path drivers/hwtracing/coresight/coresight-etb10.c
* Unmerged path drivers/hwtracing/coresight/of_coresight.c
* Unmerged path drivers/i2c/busses/i2c-qup.c
* Unmerged path drivers/i2c/muxes/i2c-mux-reg.c
* Unmerged path drivers/iio/adc/twl6030-gpadc.c
* Unmerged path drivers/iio/dac/ad5592r-base.c
* Unmerged path drivers/iio/multiplexer/iio-mux.c
* Unmerged path drivers/input/keyboard/clps711x-keypad.c
* Unmerged path drivers/input/rmi4/rmi_f54.c
* Unmerged path drivers/input/rmi4/rmi_spi.c
* Unmerged path drivers/iommu/arm-smmu.c
* Unmerged path drivers/iommu/rockchip-iommu.c
* Unmerged path drivers/irqchip/irq-imgpdc.c
* Unmerged path drivers/irqchip/irq-mvebu-gicp.c
* Unmerged path drivers/leds/leds-apu.c
* Unmerged path drivers/leds/leds-lp8501.c
* Unmerged path drivers/leds/leds-mlxcpld.c
* Unmerged path drivers/leds/leds-pca963x.c
* Unmerged path drivers/mailbox/hi6220-mailbox.c
* Unmerged path drivers/mailbox/mailbox-sti.c
* Unmerged path drivers/mailbox/omap-mailbox.c
* Unmerged path drivers/mailbox/ti-msgmgr.c
* Unmerged path drivers/media/i2c/s5k5baf.c
* Unmerged path drivers/media/platform/am437x/am437x-vpfe.c
* Unmerged path drivers/media/platform/qcom/camss-8x16/camss-csid.c
* Unmerged path drivers/media/platform/qcom/camss-8x16/camss-csiphy.c
* Unmerged path drivers/media/platform/qcom/camss-8x16/camss-ispif.c
* Unmerged path drivers/media/platform/qcom/camss-8x16/camss-vfe.c
* Unmerged path drivers/media/platform/qcom/camss-8x16/camss.c
* Unmerged path drivers/media/platform/vsp1/vsp1_entity.c
* Unmerged path drivers/media/platform/xilinx/xilinx-vipp.c
* Unmerged path drivers/media/v4l2-core/v4l2-flash-led-class.c
* Unmerged path drivers/mfd/motorola-cpcap.c
* Unmerged path drivers/mfd/sprd-sc27xx-spi.c
* Unmerged path drivers/mmc/host/sdhci-omap.c
* Unmerged path drivers/mtd/nand/raw/qcom_nandc.c
* Unmerged path drivers/net/dsa/b53/b53_common.c
* Unmerged path drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
* Unmerged path drivers/net/ethernet/ni/nixge.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
* Unmerged path drivers/net/ethernet/ti/netcp_ethss.c
* Unmerged path drivers/net/phy/phy_led_triggers.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mac80211.c
* Unmerged path drivers/pci/cadence/pcie-cadence-ep.c
* Unmerged path drivers/pci/dwc/pci-dra7xx.c
* Unmerged path drivers/pci/dwc/pcie-designware-ep.c
* Unmerged path drivers/pci/host/pcie-rockchip-ep.c
* Unmerged path drivers/pinctrl/berlin/berlin.c
* Unmerged path drivers/pinctrl/freescale/pinctrl-imx.c
* Unmerged path drivers/pinctrl/freescale/pinctrl-imx1-core.c
* Unmerged path drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
* Unmerged path drivers/pinctrl/pinctrl-at91-pio4.c
* Unmerged path drivers/pinctrl/pinctrl-axp209.c
* Unmerged path drivers/pinctrl/pinctrl-digicolor.c
* Unmerged path drivers/pinctrl/pinctrl-ingenic.c
* Unmerged path drivers/pinctrl/pinctrl-lpc18xx.c
* Unmerged path drivers/pinctrl/pinctrl-ocelot.c
* Unmerged path drivers/pinctrl/pinctrl-rockchip.c
* Unmerged path drivers/pinctrl/pinctrl-st.c
* Unmerged path drivers/pinctrl/samsung/pinctrl-exynos.c
* Unmerged path drivers/pinctrl/samsung/pinctrl-samsung.c
* Unmerged path drivers/pinctrl/sprd/pinctrl-sprd.c
* Unmerged path drivers/pinctrl/sunxi/pinctrl-sunxi.c
* Unmerged path drivers/pinctrl/ti/pinctrl-ti-iodelay.c
* Unmerged path drivers/pinctrl/zte/pinctrl-zx.c
* Unmerged path drivers/platform/mellanox/mlxreg-hotplug.c
* Unmerged path drivers/pwm/pwm-lp3943.c
* Unmerged path drivers/regulator/act8865-regulator.c
* Unmerged path drivers/regulator/bcm590xx-regulator.c
* Unmerged path drivers/regulator/da9063-regulator.c
* Unmerged path drivers/regulator/pbias-regulator.c
* Unmerged path drivers/regulator/ti-abb-regulator.c
* Unmerged path drivers/regulator/tps65218-regulator.c
* Unmerged path drivers/reset/reset-ti-syscon.c
* Unmerged path drivers/soc/bcm/raspberrypi-power.c
* Unmerged path drivers/soc/mediatek/mtk-scpsys.c
* Unmerged path drivers/soc/ti/knav_qmss_acc.c
* Unmerged path drivers/staging/greybus/audio_topology.c
* Unmerged path drivers/staging/media/imx/imx-media-dev.c
* Unmerged path drivers/staging/mt7621-pinctrl/pinctrl-rt2880.c
* Unmerged path drivers/thermal/tegra/soctherm.c
* Unmerged path drivers/thermal/thermal-generic-adc.c
* Unmerged path drivers/usb/gadget/udc/renesas_usb3.c
* Unmerged path sound/soc/au1x/dbdma2.c
* Unmerged path sound/soc/codecs/hdmi-codec.c
* Unmerged path sound/soc/codecs/wm8994.c
* Unmerged path sound/soc/davinci/davinci-mcasp.c
* Unmerged path sound/soc/generic/audio-graph-card.c
* Unmerged path sound/soc/generic/audio-graph-scu-card.c
* Unmerged path sound/soc/generic/simple-card.c
* Unmerged path sound/soc/generic/simple-scu-card.c
* Unmerged path sound/soc/img/img-i2s-in.c
* Unmerged path sound/soc/img/img-i2s-out.c
* Unmerged path sound/soc/mediatek/mt2701/mt2701-afe-pcm.c
* Unmerged path sound/soc/pxa/mmp-sspa.c
* Unmerged path sound/soc/rockchip/rk3399_gru_sound.c
* Unmerged path sound/soc/sh/rcar/cmd.c
* Unmerged path sound/soc/sh/rcar/core.c
* Unmerged path sound/soc/sh/rcar/ctu.c
* Unmerged path sound/soc/sh/rcar/dvc.c
* Unmerged path sound/soc/sh/rcar/mix.c
* Unmerged path sound/soc/sh/rcar/src.c
* Unmerged path sound/soc/sh/rcar/ssi.c
* Unmerged path sound/soc/sh/rcar/ssiu.c
* Unmerged path sound/soc/uniphier/aio-cpu.c
diff --git a/drivers/acpi/fan.c b/drivers/acpi/fan.c
index ebc33dc0b7e7..e535a8e45ee0 100644
--- a/drivers/acpi/fan.c
+++ b/drivers/acpi/fan.c
@@ -292,8 +292,8 @@ static int acpi_fan_get_fps(struct acpi_device *device)
 	}
 
 	fan->fps_count = obj->package.count - 1; /* minus revision field */
-	fan->fps = devm_kzalloc(&device->dev,
-				fan->fps_count * sizeof(struct acpi_fan_fps),
+	fan->fps = devm_kcalloc(&device->dev,
+				fan->fps_count, sizeof(struct acpi_fan_fps),
 				GFP_KERNEL);
 	if (!fan->fps) {
 		dev_err(&device->dev, "Not enough memory\n");
diff --git a/drivers/acpi/nfit/core.c b/drivers/acpi/nfit/core.c
index 61006aea42ad..22afbeaad544 100644
--- a/drivers/acpi/nfit/core.c
+++ b/drivers/acpi/nfit/core.c
@@ -1082,9 +1082,10 @@ static int __nfit_mem_init(struct acpi_nfit_desc *acpi_desc,
 				continue;
 			nfit_mem->nfit_flush = nfit_flush;
 			flush = nfit_flush->flush;
-			nfit_mem->flush_wpq = devm_kzalloc(acpi_desc->dev,
-					flush->hint_count
-					* sizeof(struct resource), GFP_KERNEL);
+			nfit_mem->flush_wpq = devm_kcalloc(acpi_desc->dev,
+					flush->hint_count,
+					sizeof(struct resource),
+					GFP_KERNEL);
 			if (!nfit_mem->flush_wpq)
 				return -ENOMEM;
 			for (i = 0; i < flush->hint_count; i++) {
* Unmerged path drivers/ata/sata_mv.c
* Unmerged path drivers/bus/fsl-mc/fsl-mc-allocator.c
diff --git a/drivers/char/tpm/tpm2-cmd.c b/drivers/char/tpm/tpm2-cmd.c
index c254ce9be935..3acf4fd4e5a5 100644
--- a/drivers/char/tpm/tpm2-cmd.c
+++ b/drivers/char/tpm/tpm2-cmd.c
@@ -936,7 +936,7 @@ static int tpm2_get_cc_attrs_tbl(struct tpm_chip *chip)
 		goto out;
 	}
 
-	chip->cc_attrs_tbl = devm_kzalloc(&chip->dev, 4 * nr_commands,
+	chip->cc_attrs_tbl = devm_kcalloc(&chip->dev, 4, nr_commands,
 					  GFP_KERNEL);
 
 	rc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_GET_CAPABILITY);
* Unmerged path drivers/clk/bcm/clk-bcm2835.c
* Unmerged path drivers/clk/ti/adpll.c
* Unmerged path drivers/cpufreq/brcmstb-avs-cpufreq.c
* Unmerged path drivers/cpufreq/imx6q-cpufreq.c
* Unmerged path drivers/crypto/marvell/cesa.c
* Unmerged path drivers/crypto/talitos.c
* Unmerged path drivers/devfreq/devfreq.c
* Unmerged path drivers/devfreq/event/exynos-ppmu.c
* Unmerged path drivers/dma/k3dma.c
* Unmerged path drivers/dma/mv_xor_v2.c
* Unmerged path drivers/dma/s3c24xx-dma.c
* Unmerged path drivers/dma/zx_dma.c
* Unmerged path drivers/firmware/arm_scpi.c
* Unmerged path drivers/firmware/ti_sci.c
* Unmerged path drivers/gpio/gpio-adnp.c
* Unmerged path drivers/gpio/gpio-aspeed.c
* Unmerged path drivers/gpio/gpio-bcm-kona.c
* Unmerged path drivers/gpio/gpio-davinci.c
* Unmerged path drivers/gpio/gpio-thunderx.c
diff --git a/drivers/gpu/drm/exynos/exynos_drm_dsi.c b/drivers/gpu/drm/exynos/exynos_drm_dsi.c
index 7904ffa9abfb..26df34a13488 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_dsi.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_dsi.c
@@ -1743,8 +1743,8 @@ static int exynos_dsi_probe(struct platform_device *pdev)
 		return -EPROBE_DEFER;
 	}
 
-	dsi->clks = devm_kzalloc(dev,
-			sizeof(*dsi->clks) * dsi->driver_data->num_clks,
+	dsi->clks = devm_kcalloc(dev,
+			dsi->driver_data->num_clks, sizeof(*dsi->clks),
 			GFP_KERNEL);
 	if (!dsi->clks)
 		return -ENOMEM;
* Unmerged path drivers/gpu/drm/exynos/exynos_drm_fimc.c
* Unmerged path drivers/gpu/drm/exynos/exynos_drm_gsc.c
diff --git a/drivers/gpu/drm/exynos/exynos_hdmi.c b/drivers/gpu/drm/exynos/exynos_hdmi.c
index abd84cbcf1c2..db81444684cf 100644
--- a/drivers/gpu/drm/exynos/exynos_hdmi.c
+++ b/drivers/gpu/drm/exynos/exynos_hdmi.c
@@ -1694,7 +1694,7 @@ static int hdmi_clk_init(struct hdmi_context *hdata)
 	if (!count)
 		return 0;
 
-	clks = devm_kzalloc(dev, sizeof(*clks) * count, GFP_KERNEL);
+	clks = devm_kcalloc(dev, count, sizeof(*clks), GFP_KERNEL);
 	if (!clks)
 		return -ENOMEM;
 
* Unmerged path drivers/gpu/drm/msm/hdmi/hdmi.c
* Unmerged path drivers/gpu/drm/msm/hdmi/hdmi_phy.c
diff --git a/drivers/hid/hid-sensor-hub.c b/drivers/hid/hid-sensor-hub.c
index 83434e47b0dc..c87aa1d1e229 100644
--- a/drivers/hid/hid-sensor-hub.c
+++ b/drivers/hid/hid-sensor-hub.c
@@ -643,7 +643,8 @@ static int sensor_hub_probe(struct hid_device *hdev,
 		ret = -EINVAL;
 		goto err_stop_hw;
 	}
-	sd->hid_sensor_hub_client_devs = devm_kzalloc(&hdev->dev, dev_cnt *
+	sd->hid_sensor_hub_client_devs = devm_kcalloc(&hdev->dev,
+						      dev_cnt,
 						      sizeof(struct mfd_cell),
 						      GFP_KERNEL);
 	if (sd->hid_sensor_hub_client_devs == NULL) {
diff --git a/drivers/hid/intel-ish-hid/ishtp-hid-client.c b/drivers/hid/intel-ish-hid/ishtp-hid-client.c
index 376f6d908e36..5d83cc7a4ba4 100644
--- a/drivers/hid/intel-ish-hid/ishtp-hid-client.c
+++ b/drivers/hid/intel-ish-hid/ishtp-hid-client.c
@@ -122,9 +122,9 @@ static void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,
 			}
 			client_data->hid_dev_count = (unsigned int)*payload;
 			if (!client_data->hid_devices)
-				client_data->hid_devices = devm_kzalloc(
+				client_data->hid_devices = devm_kcalloc(
 						&client_data->cl_device->dev,
-						client_data->hid_dev_count *
+						client_data->hid_dev_count,
 						sizeof(struct device_info),
 						GFP_KERNEL);
 			if (!client_data->hid_devices) {
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hwmon/aspeed-pwm-tacho.c
* Unmerged path drivers/hwmon/gpio-fan.c
diff --git a/drivers/hwmon/ibmpowernv.c b/drivers/hwmon/ibmpowernv.c
index 3a77240bcaa3..a47b8e349d5f 100644
--- a/drivers/hwmon/ibmpowernv.c
+++ b/drivers/hwmon/ibmpowernv.c
@@ -309,9 +309,9 @@ static int populate_attr_groups(struct platform_device *pdev)
 	of_node_put(opal);
 
 	for (type = 0; type < MAX_SENSOR_TYPE; type++) {
-		sensor_groups[type].group.attrs = devm_kzalloc(&pdev->dev,
-					sizeof(struct attribute *) *
-					(sensor_groups[type].attr_count + 1),
+		sensor_groups[type].group.attrs = devm_kcalloc(&pdev->dev,
+					sensor_groups[type].attr_count + 1,
+					sizeof(struct attribute *),
 					GFP_KERNEL);
 		if (!sensor_groups[type].group.attrs)
 			return -ENOMEM;
@@ -357,7 +357,8 @@ static int create_device_attrs(struct platform_device *pdev)
 	int err = 0;
 
 	opal = of_find_node_by_path("/ibm,opal/sensors");
-	sdata = devm_kzalloc(&pdev->dev, pdata->sensors_count * sizeof(*sdata),
+	sdata = devm_kcalloc(&pdev->dev,
+			     pdata->sensors_count, sizeof(*sdata),
 			     GFP_KERNEL);
 	if (!sdata) {
 		err = -ENOMEM;
* Unmerged path drivers/hwmon/iio_hwmon.c
* Unmerged path drivers/hwmon/nct6683.c
* Unmerged path drivers/hwmon/nct6775.c
* Unmerged path drivers/hwmon/pmbus/pmbus_core.c
* Unmerged path drivers/hwmon/pmbus/ucd9000.c
* Unmerged path drivers/hwmon/pwm-fan.c
* Unmerged path drivers/hwtracing/coresight/coresight-etb10.c
* Unmerged path drivers/hwtracing/coresight/of_coresight.c
* Unmerged path drivers/i2c/busses/i2c-qup.c
diff --git a/drivers/i2c/muxes/i2c-mux-gpio.c b/drivers/i2c/muxes/i2c-mux-gpio.c
index d50b8483ebca..275e274b5c3a 100644
--- a/drivers/i2c/muxes/i2c-mux-gpio.c
+++ b/drivers/i2c/muxes/i2c-mux-gpio.c
@@ -86,8 +86,8 @@ static int i2c_mux_gpio_probe_dt(struct gpiomux *mux,
 
 	mux->data.n_values = of_get_child_count(np);
 
-	values = devm_kzalloc(&pdev->dev,
-			      sizeof(*mux->data.values) * mux->data.n_values,
+	values = devm_kcalloc(&pdev->dev,
+			      mux->data.n_values, sizeof(*mux->data.values),
 			      GFP_KERNEL);
 	if (!values) {
 		dev_err(&pdev->dev, "Cannot allocate values array");
@@ -109,8 +109,9 @@ static int i2c_mux_gpio_probe_dt(struct gpiomux *mux,
 		return -EINVAL;
 	}
 
-	gpios = devm_kzalloc(&pdev->dev,
-			     sizeof(*mux->data.gpios) * mux->data.n_gpios, GFP_KERNEL);
+	gpios = devm_kcalloc(&pdev->dev,
+			     mux->data.n_gpios, sizeof(*mux->data.gpios),
+			     GFP_KERNEL);
 	if (!gpios) {
 		dev_err(&pdev->dev, "Cannot allocate gpios array");
 		return -ENOMEM;
* Unmerged path drivers/i2c/muxes/i2c-mux-reg.c
* Unmerged path drivers/iio/adc/at91_adc.c
diff --git a/drivers/iio/adc/max1363.c b/drivers/iio/adc/max1363.c
index 9e6da72ad823..93323a8c02b4 100644
--- a/drivers/iio/adc/max1363.c
+++ b/drivers/iio/adc/max1363.c
@@ -1416,8 +1416,10 @@ static int max1363_alloc_scan_masks(struct iio_dev *indio_dev)
 	int i;
 
 	masks = devm_kzalloc(&indio_dev->dev,
-			BITS_TO_LONGS(MAX1363_MAX_CHANNELS) * sizeof(long) *
-			(st->chip_info->num_modes + 1), GFP_KERNEL);
+			array3_size(BITS_TO_LONGS(MAX1363_MAX_CHANNELS),
+				    sizeof(long),
+				    st->chip_info->num_modes + 1),
+			GFP_KERNEL);
 	if (!masks)
 		return -ENOMEM;
 
* Unmerged path drivers/iio/adc/twl6030-gpadc.c
* Unmerged path drivers/iio/dac/ad5592r-base.c
* Unmerged path drivers/iio/multiplexer/iio-mux.c
* Unmerged path drivers/input/keyboard/clps711x-keypad.c
diff --git a/drivers/input/keyboard/matrix_keypad.c b/drivers/input/keyboard/matrix_keypad.c
index 71d77192ac1e..b7daa87258d4 100644
--- a/drivers/input/keyboard/matrix_keypad.c
+++ b/drivers/input/keyboard/matrix_keypad.c
@@ -434,9 +434,9 @@ matrix_keypad_parse_dt(struct device *dev)
 	of_property_read_u32(np, "col-scan-delay-us",
 						&pdata->col_scan_delay_us);
 
-	gpios = devm_kzalloc(dev,
-			     sizeof(unsigned int) *
-				(pdata->num_row_gpios + pdata->num_col_gpios),
+	gpios = devm_kcalloc(dev,
+			     pdata->num_row_gpios + pdata->num_col_gpios,
+			     sizeof(unsigned int),
 			     GFP_KERNEL);
 	if (!gpios) {
 		dev_err(dev, "could not allocate memory for gpios\n");
diff --git a/drivers/input/keyboard/samsung-keypad.c b/drivers/input/keyboard/samsung-keypad.c
index 22e357b51024..d0b3992c8599 100644
--- a/drivers/input/keyboard/samsung-keypad.c
+++ b/drivers/input/keyboard/samsung-keypad.c
@@ -282,7 +282,7 @@ static struct samsung_keypad_platdata *samsung_keypad_parse_dt(
 
 	key_count = of_get_child_count(np);
 	keymap_data->keymap_size = key_count;
-	keymap = devm_kzalloc(dev, sizeof(uint32_t) * key_count, GFP_KERNEL);
+	keymap = devm_kcalloc(dev, key_count, sizeof(uint32_t), GFP_KERNEL);
 	if (!keymap) {
 		dev_err(dev, "could not allocate memory for keymap\n");
 		return NULL;
diff --git a/drivers/input/matrix-keymap.c b/drivers/input/matrix-keymap.c
index 08b61f506db6..09eaa3ac598d 100644
--- a/drivers/input/matrix-keymap.c
+++ b/drivers/input/matrix-keymap.c
@@ -167,8 +167,8 @@ int matrix_keypad_build_keymap(const struct matrix_keymap_data *keymap_data,
 		return -EINVAL;
 
 	if (!keymap) {
-		keymap = devm_kzalloc(input_dev->dev.parent,
-				      max_keys * sizeof(*keymap),
+		keymap = devm_kcalloc(input_dev->dev.parent,
+				      max_keys, sizeof(*keymap),
 				      GFP_KERNEL);
 		if (!keymap) {
 			dev_err(input_dev->dev.parent,
* Unmerged path drivers/input/misc/rotary_encoder.c
* Unmerged path drivers/input/rmi4/rmi_driver.c
diff --git a/drivers/input/rmi4/rmi_f11.c b/drivers/input/rmi4/rmi_f11.c
index 89d5029a2445..bb8c64c7472e 100644
--- a/drivers/input/rmi4/rmi_f11.c
+++ b/drivers/input/rmi4/rmi_f11.c
@@ -1185,14 +1185,15 @@ static int rmi_f11_initialize(struct rmi_function *fn)
 		f11->sensor.attn_size += f11->sensor.nbr_fingers * 2;
 
 	/* allocate the in-kernel tracking buffers */
-	sensor->tracking_pos = devm_kzalloc(&fn->dev,
-			sizeof(struct input_mt_pos) * sensor->nbr_fingers,
+	sensor->tracking_pos = devm_kcalloc(&fn->dev,
+			sensor->nbr_fingers, sizeof(struct input_mt_pos),
+			GFP_KERNEL);
+	sensor->tracking_slots = devm_kcalloc(&fn->dev,
+			sensor->nbr_fingers, sizeof(int), GFP_KERNEL);
+	sensor->objs = devm_kcalloc(&fn->dev,
+			sensor->nbr_fingers,
+			sizeof(struct rmi_2d_sensor_abs_object),
 			GFP_KERNEL);
-	sensor->tracking_slots = devm_kzalloc(&fn->dev,
-			sizeof(int) * sensor->nbr_fingers, GFP_KERNEL);
-	sensor->objs = devm_kzalloc(&fn->dev,
-			sizeof(struct rmi_2d_sensor_abs_object)
-			* sensor->nbr_fingers, GFP_KERNEL);
 	if (!sensor->tracking_pos || !sensor->tracking_slots || !sensor->objs)
 		return -ENOMEM;
 
diff --git a/drivers/input/rmi4/rmi_f12.c b/drivers/input/rmi4/rmi_f12.c
index ec6d7469b6ed..1cb2ea90b9c6 100644
--- a/drivers/input/rmi4/rmi_f12.c
+++ b/drivers/input/rmi4/rmi_f12.c
@@ -496,14 +496,15 @@ static int rmi_f12_probe(struct rmi_function *fn)
 	}
 
 	/* allocate the in-kernel tracking buffers */
-	sensor->tracking_pos = devm_kzalloc(&fn->dev,
-			sizeof(struct input_mt_pos) * sensor->nbr_fingers,
+	sensor->tracking_pos = devm_kcalloc(&fn->dev,
+			sensor->nbr_fingers, sizeof(struct input_mt_pos),
+			GFP_KERNEL);
+	sensor->tracking_slots = devm_kcalloc(&fn->dev,
+			sensor->nbr_fingers, sizeof(int), GFP_KERNEL);
+	sensor->objs = devm_kcalloc(&fn->dev,
+			sensor->nbr_fingers,
+			sizeof(struct rmi_2d_sensor_abs_object),
 			GFP_KERNEL);
-	sensor->tracking_slots = devm_kzalloc(&fn->dev,
-			sizeof(int) * sensor->nbr_fingers, GFP_KERNEL);
-	sensor->objs = devm_kzalloc(&fn->dev,
-			sizeof(struct rmi_2d_sensor_abs_object)
-			* sensor->nbr_fingers, GFP_KERNEL);
 	if (!sensor->tracking_pos || !sensor->tracking_slots || !sensor->objs)
 		return -ENOMEM;
 
* Unmerged path drivers/input/rmi4/rmi_f54.c
* Unmerged path drivers/input/rmi4/rmi_spi.c
* Unmerged path drivers/iommu/arm-smmu.c
* Unmerged path drivers/iommu/rockchip-iommu.c
* Unmerged path drivers/irqchip/irq-imgpdc.c
* Unmerged path drivers/irqchip/irq-mvebu-gicp.c
diff --git a/drivers/leds/leds-adp5520.c b/drivers/leds/leds-adp5520.c
index e8072abe76e5..2ed0cc8b26bf 100644
--- a/drivers/leds/leds-adp5520.c
+++ b/drivers/leds/leds-adp5520.c
@@ -119,7 +119,7 @@ static int adp5520_led_probe(struct platform_device *pdev)
 		return -EFAULT;
 	}
 
-	led = devm_kzalloc(&pdev->dev, sizeof(*led) * pdata->num_leds,
+	led = devm_kcalloc(&pdev->dev, pdata->num_leds, sizeof(*led),
 				GFP_KERNEL);
 	if (led == NULL) {
 		dev_err(&pdev->dev, "failed to alloc memory\n");
* Unmerged path drivers/leds/leds-apu.c
diff --git a/drivers/leds/leds-da9052.c b/drivers/leds/leds-da9052.c
index efec43344e9f..baa005f85706 100644
--- a/drivers/leds/leds-da9052.c
+++ b/drivers/leds/leds-da9052.c
@@ -124,8 +124,8 @@ static int da9052_led_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	led = devm_kzalloc(&pdev->dev,
-			   sizeof(struct da9052_led) * pled->num_leds,
+	led = devm_kcalloc(&pdev->dev,
+			   pled->num_leds, sizeof(struct da9052_led),
 			   GFP_KERNEL);
 	if (led == NULL) {
 		dev_err(&pdev->dev, "Failed to alloc memory\n");
diff --git a/drivers/leds/leds-lp5521.c b/drivers/leds/leds-lp5521.c
index 19752c928aa2..cfd87e48df49 100644
--- a/drivers/leds/leds-lp5521.c
+++ b/drivers/leds/leds-lp5521.c
@@ -427,8 +427,8 @@ static int lp5521_probe(struct i2c_client *client,
 	if (!chip)
 		return -ENOMEM;
 
-	led = devm_kzalloc(&client->dev,
-			sizeof(*led) * pdata->num_channels, GFP_KERNEL);
+	led = devm_kcalloc(&client->dev,
+			pdata->num_channels, sizeof(*led), GFP_KERNEL);
 	if (!led)
 		return -ENOMEM;
 
diff --git a/drivers/leds/leds-lp5523.c b/drivers/leds/leds-lp5523.c
index 229f734040af..c25841049ddc 100644
--- a/drivers/leds/leds-lp5523.c
+++ b/drivers/leds/leds-lp5523.c
@@ -440,8 +440,8 @@ static int lp5523_probe(struct i2c_client *client,
 	if (!chip)
 		return -ENOMEM;
 
-	led = devm_kzalloc(&client->dev,
-			sizeof(*led) * pdata->num_channels, GFP_KERNEL);
+	led = devm_kcalloc(&client->dev,
+			pdata->num_channels, sizeof(*led), GFP_KERNEL);
 	if (!led)
 		return -ENOMEM;
 
diff --git a/drivers/leds/leds-lp5562.c b/drivers/leds/leds-lp5562.c
index 513f2390ca2d..a7feb1737566 100644
--- a/drivers/leds/leds-lp5562.c
+++ b/drivers/leds/leds-lp5562.c
@@ -526,8 +526,8 @@ static int lp5562_probe(struct i2c_client *client,
 	if (!chip)
 		return -ENOMEM;
 
-	led = devm_kzalloc(&client->dev,
-			sizeof(*led) * pdata->num_channels, GFP_KERNEL);
+	led = devm_kcalloc(&client->dev,
+			pdata->num_channels, sizeof(*led), GFP_KERNEL);
 	if (!led)
 		return -ENOMEM;
 
* Unmerged path drivers/leds/leds-lp55xx-common.c
* Unmerged path drivers/leds/leds-lp8501.c
diff --git a/drivers/leds/leds-lt3593.c b/drivers/leds/leds-lt3593.c
index ca48a7d5502d..139ce7906b97 100644
--- a/drivers/leds/leds-lt3593.c
+++ b/drivers/leds/leds-lt3593.c
@@ -142,8 +142,8 @@ static int lt3593_led_probe(struct platform_device *pdev)
 	if (!pdata)
 		return -EBUSY;
 
-	leds_data = devm_kzalloc(&pdev->dev,
-			sizeof(struct lt3593_led_data) * pdata->num_leds,
+	leds_data = devm_kcalloc(&pdev->dev,
+			pdata->num_leds, sizeof(struct lt3593_led_data),
 			GFP_KERNEL);
 	if (!leds_data)
 		return -ENOMEM;
* Unmerged path drivers/leds/leds-mc13783.c
* Unmerged path drivers/leds/leds-mlxcpld.c
* Unmerged path drivers/leds/leds-netxbig.c
* Unmerged path drivers/leds/leds-ns2.c
* Unmerged path drivers/leds/leds-pca955x.c
* Unmerged path drivers/leds/leds-pca963x.c
* Unmerged path drivers/leds/leds-tca6507.c
* Unmerged path drivers/mailbox/hi6220-mailbox.c
* Unmerged path drivers/mailbox/mailbox-sti.c
* Unmerged path drivers/mailbox/omap-mailbox.c
* Unmerged path drivers/mailbox/ti-msgmgr.c
* Unmerged path drivers/media/i2c/s5k5baf.c
* Unmerged path drivers/media/platform/am437x/am437x-vpfe.c
* Unmerged path drivers/media/platform/davinci/vpif_capture.c
* Unmerged path drivers/media/platform/qcom/camss-8x16/camss-csid.c
* Unmerged path drivers/media/platform/qcom/camss-8x16/camss-csiphy.c
* Unmerged path drivers/media/platform/qcom/camss-8x16/camss-ispif.c
* Unmerged path drivers/media/platform/qcom/camss-8x16/camss-vfe.c
* Unmerged path drivers/media/platform/qcom/camss-8x16/camss.c
* Unmerged path drivers/media/platform/vsp1/vsp1_entity.c
* Unmerged path drivers/media/platform/xilinx/xilinx-vipp.c
* Unmerged path drivers/media/v4l2-core/v4l2-flash-led-class.c
diff --git a/drivers/memory/of_memory.c b/drivers/memory/of_memory.c
index 60074351f17e..b7b7c11a94e9 100644
--- a/drivers/memory/of_memory.c
+++ b/drivers/memory/of_memory.c
@@ -125,8 +125,8 @@ const struct lpddr2_timings *of_get_ddr_timings(struct device_node *np_ddr,
 			arr_sz++;
 
 	if (arr_sz)
-		timings = devm_kzalloc(dev, sizeof(*timings) * arr_sz,
-			GFP_KERNEL);
+		timings = devm_kcalloc(dev, arr_sz, sizeof(*timings),
+				       GFP_KERNEL);
 
 	if (!timings)
 		goto default_timings;
* Unmerged path drivers/mfd/ab8500-debugfs.c
* Unmerged path drivers/mfd/htc-egpio.c
* Unmerged path drivers/mfd/htc-i2cpld.c
* Unmerged path drivers/mfd/motorola-cpcap.c
* Unmerged path drivers/mfd/sprd-sc27xx-spi.c
diff --git a/drivers/mfd/twl-core.c b/drivers/mfd/twl-core.c
index 89ab4d970643..a247ea954c0b 100644
--- a/drivers/mfd/twl-core.c
+++ b/drivers/mfd/twl-core.c
@@ -1188,8 +1188,9 @@ twl_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	}
 
 	num_slaves = twl_get_num_slaves();
-	twl_priv->twl_modules = devm_kzalloc(&client->dev,
-					 sizeof(struct twl_client) * num_slaves,
+	twl_priv->twl_modules = devm_kcalloc(&client->dev,
+					 num_slaves,
+					 sizeof(struct twl_client),
 					 GFP_KERNEL);
 	if (!twl_priv->twl_modules) {
 		status = -ENOMEM;
diff --git a/drivers/mfd/wm8994-core.c b/drivers/mfd/wm8994-core.c
index 00e4fe2f3c75..29b3ab6060f2 100644
--- a/drivers/mfd/wm8994-core.c
+++ b/drivers/mfd/wm8994-core.c
@@ -502,9 +502,10 @@ static int wm8994_device_init(struct wm8994 *wm8994, int irq)
 		goto err;
 	}
 
-	wm8994->supplies = devm_kzalloc(wm8994->dev,
-					sizeof(struct regulator_bulk_data) *
-					wm8994->num_supplies, GFP_KERNEL);
+	wm8994->supplies = devm_kcalloc(wm8994->dev,
+					wm8994->num_supplies,
+					sizeof(struct regulator_bulk_data),
+					GFP_KERNEL);
 	if (!wm8994->supplies) {
 		ret = -ENOMEM;
 		goto err;
* Unmerged path drivers/misc/sram.c
* Unmerged path drivers/mmc/host/sdhci-omap.c
* Unmerged path drivers/mtd/devices/docg3.c
* Unmerged path drivers/mtd/nand/raw/qcom_nandc.c
* Unmerged path drivers/mtd/nand/s3c2410.c
* Unmerged path drivers/net/dsa/b53/b53_common.c
diff --git a/drivers/net/ethernet/amazon/ena/ena_ethtool.c b/drivers/net/ethernet/amazon/ena/ena_ethtool.c
index 7643faaebb42..fd28bd0d1c1e 100644
--- a/drivers/net/ethernet/amazon/ena/ena_ethtool.c
+++ b/drivers/net/ethernet/amazon/ena/ena_ethtool.c
@@ -839,8 +839,8 @@ static void ena_dump_stats_ex(struct ena_adapter *adapter, u8 *buf)
 		return;
 	}
 
-	strings_buf = devm_kzalloc(&adapter->pdev->dev,
-				   strings_num * ETH_GSTRING_LEN,
+	strings_buf = devm_kcalloc(&adapter->pdev->dev,
+				   ETH_GSTRING_LEN, strings_num,
 				   GFP_ATOMIC);
 	if (!strings_buf) {
 		netif_err(adapter, drv, netdev,
@@ -848,8 +848,8 @@ static void ena_dump_stats_ex(struct ena_adapter *adapter, u8 *buf)
 		return;
 	}
 
-	data_buf = devm_kzalloc(&adapter->pdev->dev,
-				strings_num * sizeof(u64),
+	data_buf = devm_kcalloc(&adapter->pdev->dev,
+				strings_num, sizeof(u64),
 				GFP_ATOMIC);
 	if (!data_buf) {
 		netif_err(adapter, drv, netdev,
diff --git a/drivers/net/ethernet/ethoc.c b/drivers/net/ethernet/ethoc.c
index bd30806b0307..5b2b83090da0 100644
--- a/drivers/net/ethernet/ethoc.c
+++ b/drivers/net/ethernet/ethoc.c
@@ -1023,7 +1023,8 @@ static int ethoc_probe(struct platform_device *pdev)
 	dev_dbg(&pdev->dev, "ethoc: num_tx: %d num_rx: %d\n",
 		priv->num_tx, priv->num_rx);
 
-	priv->vma = devm_kzalloc(&pdev->dev, num_bd*sizeof(void *), GFP_KERNEL);
+	priv->vma = devm_kcalloc(&pdev->dev, num_bd, sizeof(void *),
+				 GFP_KERNEL);
 	if (!priv->vma) {
 		ret = -ENOMEM;
 		goto error;
* Unmerged path drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
* Unmerged path drivers/net/ethernet/ni/nixge.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c
* Unmerged path drivers/net/ethernet/ti/cpsw.c
* Unmerged path drivers/net/ethernet/ti/netcp_ethss.c
* Unmerged path drivers/net/phy/phy_led_triggers.c
* Unmerged path drivers/net/wireless/mediatek/mt76/mac80211.c
* Unmerged path drivers/pci/cadence/pcie-cadence-ep.c
* Unmerged path drivers/pci/dwc/pci-dra7xx.c
* Unmerged path drivers/pci/dwc/pcie-designware-ep.c
* Unmerged path drivers/pci/host/pcie-rockchip-ep.c
* Unmerged path drivers/pinctrl/berlin/berlin.c
* Unmerged path drivers/pinctrl/freescale/pinctrl-imx.c
* Unmerged path drivers/pinctrl/freescale/pinctrl-imx1-core.c
* Unmerged path drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
* Unmerged path drivers/pinctrl/mvebu/pinctrl-mvebu.c
* Unmerged path drivers/pinctrl/pinctrl-at91-pio4.c
* Unmerged path drivers/pinctrl/pinctrl-at91.c
* Unmerged path drivers/pinctrl/pinctrl-axp209.c
* Unmerged path drivers/pinctrl/pinctrl-digicolor.c
* Unmerged path drivers/pinctrl/pinctrl-ingenic.c
* Unmerged path drivers/pinctrl/pinctrl-lpc18xx.c
diff --git a/drivers/pinctrl/pinctrl-mxs.c b/drivers/pinctrl/pinctrl-mxs.c
index b45c4eb35798..83cbb1cedb03 100644
--- a/drivers/pinctrl/pinctrl-mxs.c
+++ b/drivers/pinctrl/pinctrl-mxs.c
@@ -361,12 +361,12 @@ static int mxs_pinctrl_parse_group(struct platform_device *pdev,
 		return -EINVAL;
 	g->npins = length / sizeof(u32);
 
-	g->pins = devm_kzalloc(&pdev->dev, g->npins * sizeof(*g->pins),
+	g->pins = devm_kcalloc(&pdev->dev, g->npins, sizeof(*g->pins),
 			       GFP_KERNEL);
 	if (!g->pins)
 		return -ENOMEM;
 
-	g->muxsel = devm_kzalloc(&pdev->dev, g->npins * sizeof(*g->muxsel),
+	g->muxsel = devm_kcalloc(&pdev->dev, g->npins, sizeof(*g->muxsel),
 				 GFP_KERNEL);
 	if (!g->muxsel)
 		return -ENOMEM;
@@ -417,13 +417,16 @@ static int mxs_pinctrl_probe_dt(struct platform_device *pdev,
 		}
 	}
 
-	soc->functions = devm_kzalloc(&pdev->dev, soc->nfunctions *
-				      sizeof(*soc->functions), GFP_KERNEL);
+	soc->functions = devm_kcalloc(&pdev->dev,
+				      soc->nfunctions,
+				      sizeof(*soc->functions),
+				      GFP_KERNEL);
 	if (!soc->functions)
 		return -ENOMEM;
 
-	soc->groups = devm_kzalloc(&pdev->dev, soc->ngroups *
-				   sizeof(*soc->groups), GFP_KERNEL);
+	soc->groups = devm_kcalloc(&pdev->dev,
+				   soc->ngroups, sizeof(*soc->groups),
+				   GFP_KERNEL);
 	if (!soc->groups)
 		return -ENOMEM;
 
@@ -458,7 +461,8 @@ static int mxs_pinctrl_probe_dt(struct platform_device *pdev,
 
 		if (strcmp(fn, child->name)) {
 			f = &soc->functions[idxf++];
-			f->groups = devm_kzalloc(&pdev->dev, f->ngroups *
+			f->groups = devm_kcalloc(&pdev->dev,
+						 f->ngroups,
 						 sizeof(*f->groups),
 						 GFP_KERNEL);
 			if (!f->groups)
* Unmerged path drivers/pinctrl/pinctrl-ocelot.c
* Unmerged path drivers/pinctrl/pinctrl-rockchip.c
* Unmerged path drivers/pinctrl/pinctrl-single.c
* Unmerged path drivers/pinctrl/pinctrl-st.c
* Unmerged path drivers/pinctrl/pinctrl-tegra.c
diff --git a/drivers/pinctrl/pinctrl-xway.c b/drivers/pinctrl/pinctrl-xway.c
index e92132c76a6b..d331973b2c1f 100644
--- a/drivers/pinctrl/pinctrl-xway.c
+++ b/drivers/pinctrl/pinctrl-xway.c
@@ -730,8 +730,8 @@ static int pinmux_xway_probe(struct platform_device *pdev)
 	xway_chip.ngpio = xway_soc->pin_count;
 
 	/* load our pad descriptors */
-	xway_info.pads = devm_kzalloc(&pdev->dev,
-			sizeof(struct pinctrl_pin_desc) * xway_chip.ngpio,
+	xway_info.pads = devm_kcalloc(&pdev->dev,
+			xway_chip.ngpio, sizeof(struct pinctrl_pin_desc),
 			GFP_KERNEL);
 	if (!xway_info.pads) {
 		dev_err(&pdev->dev, "Failed to allocate pads\n");
* Unmerged path drivers/pinctrl/samsung/pinctrl-exynos.c
* Unmerged path drivers/pinctrl/samsung/pinctrl-samsung.c
* Unmerged path drivers/pinctrl/sh-pfc/core.c
* Unmerged path drivers/pinctrl/sh-pfc/gpio.c
* Unmerged path drivers/pinctrl/sh-pfc/pinctrl.c
diff --git a/drivers/pinctrl/spear/pinctrl-plgpio.c b/drivers/pinctrl/spear/pinctrl-plgpio.c
index 3e5a887216b8..17c85a16a5e3 100644
--- a/drivers/pinctrl/spear/pinctrl-plgpio.c
+++ b/drivers/pinctrl/spear/pinctrl-plgpio.c
@@ -555,9 +555,9 @@ static int plgpio_probe(struct platform_device *pdev)
 		dev_warn(&pdev->dev, "clk_get() failed, work without it\n");
 
 #ifdef CONFIG_PM_SLEEP
-	plgpio->csave_regs = devm_kzalloc(&pdev->dev,
-			sizeof(*plgpio->csave_regs) *
+	plgpio->csave_regs = devm_kcalloc(&pdev->dev,
 			DIV_ROUND_UP(plgpio->chip.ngpio, MAX_GPIO_PER_REG),
+			sizeof(*plgpio->csave_regs),
 			GFP_KERNEL);
 	if (!plgpio->csave_regs) {
 		dev_err(&pdev->dev, "csave registers memory allocation fail\n");
* Unmerged path drivers/pinctrl/sprd/pinctrl-sprd.c
* Unmerged path drivers/pinctrl/sunxi/pinctrl-sunxi.c
* Unmerged path drivers/pinctrl/ti/pinctrl-ti-iodelay.c
* Unmerged path drivers/pinctrl/zte/pinctrl-zx.c
* Unmerged path drivers/platform/mellanox/mlxreg-hotplug.c
* Unmerged path drivers/power/charger-manager.c
* Unmerged path drivers/power/power_supply_core.c
* Unmerged path drivers/pwm/pwm-lp3943.c
* Unmerged path drivers/regulator/act8865-regulator.c
* Unmerged path drivers/regulator/as3711-regulator.c
* Unmerged path drivers/regulator/bcm590xx-regulator.c
* Unmerged path drivers/regulator/da9063-regulator.c
* Unmerged path drivers/regulator/gpio-regulator.c
* Unmerged path drivers/regulator/max1586.c
* Unmerged path drivers/regulator/max8660.c
diff --git a/drivers/regulator/max8997.c b/drivers/regulator/max8997.c
index df20069f0537..2efac55f59b3 100644
--- a/drivers/regulator/max8997.c
+++ b/drivers/regulator/max8997.c
@@ -932,8 +932,9 @@ static int max8997_pmic_dt_parse_pdata(struct platform_device *pdev,
 	/* count the number of regulators to be supported in pmic */
 	pdata->num_regulators = of_get_child_count(regulators_np);
 
-	rdata = devm_kzalloc(&pdev->dev, sizeof(*rdata) *
-				pdata->num_regulators, GFP_KERNEL);
+	rdata = devm_kcalloc(&pdev->dev,
+			     pdata->num_regulators, sizeof(*rdata),
+			     GFP_KERNEL);
 	if (!rdata) {
 		of_node_put(regulators_np);
 		dev_err(&pdev->dev, "could not allocate memory for regulator data\n");
* Unmerged path drivers/regulator/max8998.c
diff --git a/drivers/regulator/mc13xxx-regulator-core.c b/drivers/regulator/mc13xxx-regulator-core.c
index da4859282302..63b63a9c38b9 100644
--- a/drivers/regulator/mc13xxx-regulator-core.c
+++ b/drivers/regulator/mc13xxx-regulator-core.c
@@ -192,7 +192,7 @@ struct mc13xxx_regulator_init_data *mc13xxx_parse_regulators_dt(
 	if (!parent)
 		return NULL;
 
-	data = devm_kzalloc(&pdev->dev, sizeof(*data) * priv->num_regulators,
+	data = devm_kcalloc(&pdev->dev, priv->num_regulators, sizeof(*data),
 			    GFP_KERNEL);
 	if (!data) {
 		of_node_put(parent);
* Unmerged path drivers/regulator/pbias-regulator.c
* Unmerged path drivers/regulator/rc5t583-regulator.c
* Unmerged path drivers/regulator/s5m8767.c
* Unmerged path drivers/regulator/ti-abb-regulator.c
* Unmerged path drivers/regulator/tps65090-regulator.c
* Unmerged path drivers/regulator/tps65217-regulator.c
* Unmerged path drivers/regulator/tps65218-regulator.c
* Unmerged path drivers/regulator/tps65910-regulator.c
* Unmerged path drivers/regulator/tps80031-regulator.c
* Unmerged path drivers/reset/reset-ti-syscon.c
diff --git a/drivers/scsi/isci/init.c b/drivers/scsi/isci/init.c
index cd13df8a7eca..651931e021de 100644
--- a/drivers/scsi/isci/init.c
+++ b/drivers/scsi/isci/init.c
@@ -233,14 +233,14 @@ static int isci_register_sas_ha(struct isci_host *isci_host)
 	struct asd_sas_phy **sas_phys;
 	struct asd_sas_port **sas_ports;
 
-	sas_phys = devm_kzalloc(&isci_host->pdev->dev,
-				SCI_MAX_PHYS * sizeof(void *),
+	sas_phys = devm_kcalloc(&isci_host->pdev->dev,
+				SCI_MAX_PHYS, sizeof(void *),
 				GFP_KERNEL);
 	if (!sas_phys)
 		return -ENOMEM;
 
-	sas_ports = devm_kzalloc(&isci_host->pdev->dev,
-				 SCI_MAX_PORTS * sizeof(void *),
+	sas_ports = devm_kcalloc(&isci_host->pdev->dev,
+				 SCI_MAX_PORTS, sizeof(void *),
 				 GFP_KERNEL);
 	if (!sas_ports)
 		return -ENOMEM;
* Unmerged path drivers/scsi/ufs/ufshcd-pltfrm.c
* Unmerged path drivers/scsi/ufs/ufshcd.c
* Unmerged path drivers/soc/bcm/raspberrypi-power.c
* Unmerged path drivers/soc/mediatek/mtk-scpsys.c
* Unmerged path drivers/soc/ti/knav_qmss_acc.c
* Unmerged path drivers/spi/spi-davinci.c
* Unmerged path drivers/spi/spi-ep93xx.c
* Unmerged path drivers/spi/spi-gpio.c
* Unmerged path drivers/spi/spi-imx.c
diff --git a/drivers/spi/spi-oc-tiny.c b/drivers/spi/spi-oc-tiny.c
index e60a776ed2d4..e887898ee1aa 100644
--- a/drivers/spi/spi-oc-tiny.c
+++ b/drivers/spi/spi-oc-tiny.c
@@ -255,8 +255,8 @@ static int tiny_spi_of_probe(struct platform_device *pdev)
 		return 0;
 	hw->gpio_cs_count = of_gpio_count(np);
 	if (hw->gpio_cs_count > 0) {
-		hw->gpio_cs = devm_kzalloc(&pdev->dev,
-				hw->gpio_cs_count * sizeof(unsigned int),
+		hw->gpio_cs = devm_kcalloc(&pdev->dev,
+				hw->gpio_cs_count, sizeof(unsigned int),
 				GFP_KERNEL);
 		if (!hw->gpio_cs)
 			return -ENOMEM;
diff --git a/drivers/spi/spi-pl022.c b/drivers/spi/spi-pl022.c
index 371cc66f1a0e..8c0308b9dcfc 100644
--- a/drivers/spi/spi-pl022.c
+++ b/drivers/spi/spi-pl022.c
@@ -2130,7 +2130,7 @@ static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
 	pl022->master_info = platform_info;
 	pl022->adev = adev;
 	pl022->vendor = id->data;
-	pl022->chipselects = devm_kzalloc(dev, num_cs * sizeof(int),
+	pl022->chipselects = devm_kcalloc(dev, num_cs, sizeof(int),
 					  GFP_KERNEL);
 
 	pl022->pinctrl = devm_pinctrl_get(dev);
* Unmerged path drivers/spi/spi.c
* Unmerged path drivers/staging/greybus/audio_topology.c
* Unmerged path drivers/staging/media/imx/imx-media-dev.c
* Unmerged path drivers/staging/mt7621-pinctrl/pinctrl-rt2880.c
* Unmerged path drivers/thermal/tegra/soctherm.c
* Unmerged path drivers/thermal/thermal-generic-adc.c
diff --git a/drivers/tty/serial/rp2.c b/drivers/tty/serial/rp2.c
index de679dec3482..af481dea23b0 100644
--- a/drivers/tty/serial/rp2.c
+++ b/drivers/tty/serial/rp2.c
@@ -775,7 +775,7 @@ static int rp2_probe(struct pci_dev *pdev,
 
 	rp2_init_card(card);
 
-	ports = devm_kzalloc(&pdev->dev, sizeof(*ports) * card->n_ports,
+	ports = devm_kcalloc(&pdev->dev, card->n_ports, sizeof(*ports),
 			     GFP_KERNEL);
 	if (!ports)
 		return -ENOMEM;
* Unmerged path drivers/usb/gadget/atmel_usba_udc.c
* Unmerged path drivers/usb/gadget/udc/renesas_usb3.c
diff --git a/drivers/video/au1100fb.c b/drivers/video/au1100fb.c
index bdc515f5e979..4627771dda8e 100644
--- a/drivers/video/au1100fb.c
+++ b/drivers/video/au1100fb.c
@@ -522,7 +522,7 @@ static int au1100fb_drv_probe(struct platform_device *dev)
 	fbdev->info.fix = au1100fb_fix;
 
 	fbdev->info.pseudo_palette =
-		devm_kzalloc(&dev->dev, sizeof(u32) * 16, GFP_KERNEL);
+		devm_kcalloc(&dev->dev, 16, sizeof(u32), GFP_KERNEL);
 	if (!fbdev->info.pseudo_palette)
 		return -ENOMEM;
 
diff --git a/drivers/video/backlight/adp8860_bl.c b/drivers/video/backlight/adp8860_bl.c
index 75b10f876127..9be6860b1f9c 100644
--- a/drivers/video/backlight/adp8860_bl.c
+++ b/drivers/video/backlight/adp8860_bl.c
@@ -222,7 +222,7 @@ static int adp8860_led_probe(struct i2c_client *client)
 	struct led_info *cur_led;
 	int ret, i;
 
-	led = devm_kzalloc(&client->dev, sizeof(*led) * pdata->num_leds,
+	led = devm_kcalloc(&client->dev, pdata->num_leds, sizeof(*led),
 				GFP_KERNEL);
 	if (led == NULL) {
 		dev_err(&client->dev, "failed to alloc memory\n");
diff --git a/drivers/video/backlight/adp8870_bl.c b/drivers/video/backlight/adp8870_bl.c
index 90049d7b5c60..0bdf3962dc56 100644
--- a/drivers/video/backlight/adp8870_bl.c
+++ b/drivers/video/backlight/adp8870_bl.c
@@ -244,7 +244,7 @@ static int adp8870_led_probe(struct i2c_client *client)
 	struct led_info *cur_led;
 	int ret, i;
 
-	led = devm_kzalloc(&client->dev, pdata->num_leds * sizeof(*led),
+	led = devm_kcalloc(&client->dev, pdata->num_leds, sizeof(*led),
 				GFP_KERNEL);
 	if (led == NULL) {
 		dev_err(&client->dev, "failed to alloc memory\n");
diff --git a/drivers/video/backlight/lp855x_bl.c b/drivers/video/backlight/lp855x_bl.c
index a0e1e02bdc2e..04aebeccd7e2 100644
--- a/drivers/video/backlight/lp855x_bl.c
+++ b/drivers/video/backlight/lp855x_bl.c
@@ -366,7 +366,7 @@ static int lp855x_parse_dt(struct device *dev, struct device_node *node)
 		struct device_node *child;
 		int i = 0;
 
-		rom = devm_kzalloc(dev, sizeof(*rom) * rom_length, GFP_KERNEL);
+		rom = devm_kcalloc(dev, rom_length, sizeof(*rom), GFP_KERNEL);
 		if (!rom)
 			return -ENOMEM;
 
diff --git a/drivers/video/mxsfb.c b/drivers/video/mxsfb.c
index 21223d475b39..30b668941684 100644
--- a/drivers/video/mxsfb.c
+++ b/drivers/video/mxsfb.c
@@ -925,7 +925,7 @@ static int mxsfb_probe(struct platform_device *pdev)
 	if (IS_ERR(host->reg_lcd))
 		host->reg_lcd = NULL;
 
-	fb_info->pseudo_palette = devm_kzalloc(&pdev->dev, sizeof(u32) * 16,
+	fb_info->pseudo_palette = devm_kcalloc(&pdev->dev, 16, sizeof(u32),
 					       GFP_KERNEL);
 	if (!fb_info->pseudo_palette) {
 		ret = -ENOMEM;
diff --git a/drivers/video/omap2/vrfb.c b/drivers/video/omap2/vrfb.c
index f346b02eee1d..f355ecfac3b1 100644
--- a/drivers/video/omap2/vrfb.c
+++ b/drivers/video/omap2/vrfb.c
@@ -359,8 +359,8 @@ static int __init vrfb_probe(struct platform_device *pdev)
 
 	num_ctxs = pdev->num_resources - 1;
 
-	ctxs = devm_kzalloc(&pdev->dev,
-			sizeof(struct vrfb_ctx) * num_ctxs,
+	ctxs = devm_kcalloc(&pdev->dev,
+			num_ctxs, sizeof(struct vrfb_ctx),
 			GFP_KERNEL);
 
 	if (!ctxs)
* Unmerged path sound/soc/au1x/dbdma2.c
* Unmerged path sound/soc/codecs/hdmi-codec.c
diff --git a/sound/soc/codecs/rt5645.c b/sound/soc/codecs/rt5645.c
index 4764fa576b1f..09ddf982d7e1 100644
--- a/sound/soc/codecs/rt5645.c
+++ b/sound/soc/codecs/rt5645.c
@@ -3449,8 +3449,9 @@ static int rt5645_probe(struct snd_soc_component *component)
 	if (rt5645->pdata.long_name)
 		component->card->long_name = rt5645->pdata.long_name;
 
-	rt5645->eq_param = devm_kzalloc(component->dev,
-		RT5645_HWEQ_NUM * sizeof(struct rt5645_eq_param_s), GFP_KERNEL);
+	rt5645->eq_param = devm_kcalloc(component->dev,
+		RT5645_HWEQ_NUM, sizeof(struct rt5645_eq_param_s),
+		GFP_KERNEL);
 
 	return 0;
 }
* Unmerged path sound/soc/codecs/wm8994.c
* Unmerged path sound/soc/davinci/davinci-mcasp.c
* Unmerged path sound/soc/generic/audio-graph-card.c
* Unmerged path sound/soc/generic/audio-graph-scu-card.c
* Unmerged path sound/soc/generic/simple-card.c
* Unmerged path sound/soc/generic/simple-scu-card.c
* Unmerged path sound/soc/img/img-i2s-in.c
* Unmerged path sound/soc/img/img-i2s-out.c
* Unmerged path sound/soc/intel/skylake/skl-topology.c
* Unmerged path sound/soc/mediatek/mt2701/mt2701-afe-pcm.c
* Unmerged path sound/soc/pxa/mmp-sspa.c
* Unmerged path sound/soc/rockchip/rk3399_gru_sound.c
* Unmerged path sound/soc/sh/rcar/cmd.c
* Unmerged path sound/soc/sh/rcar/core.c
* Unmerged path sound/soc/sh/rcar/ctu.c
* Unmerged path sound/soc/sh/rcar/dvc.c
* Unmerged path sound/soc/sh/rcar/mix.c
* Unmerged path sound/soc/sh/rcar/src.c
* Unmerged path sound/soc/sh/rcar/ssi.c
* Unmerged path sound/soc/sh/rcar/ssiu.c
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 9f9e9110c31c..694054ad733f 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4086,7 +4086,7 @@ int snd_soc_of_parse_audio_routing(struct snd_soc_card *card,
 		return -EINVAL;
 	}
 
-	routes = devm_kzalloc(card->dev, num_routes * sizeof(*routes),
+	routes = devm_kcalloc(card->dev, num_routes, sizeof(*routes),
 			      GFP_KERNEL);
 	if (!routes) {
 		dev_err(card->dev,
@@ -4410,8 +4410,8 @@ int snd_soc_of_get_dai_link_codecs(struct device *dev,
 			dev_err(dev, "Bad phandle in 'sound-dai'\n");
 		return num_codecs;
 	}
-	component = devm_kzalloc(dev,
-				 sizeof *component * num_codecs,
+	component = devm_kcalloc(dev,
+				 num_codecs, sizeof(*component),
 				 GFP_KERNEL);
 	if (!component)
 		return -ENOMEM;
* Unmerged path sound/soc/uniphier/aio-cpu.c
