perf tools: Enable indices setting syntax for BPF map

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit e571e029bdbf59f485fe67740b7a4ef421e1d55d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/e571e029.failed

This patch introduces a new syntax to perf event parser:

 # perf record -e './test_bpf_map_3.c/map:channel.value[0,1,2,3...5]=101/' usleep 2

By utilizing the basic facilities in bpf-loader.c which allow setting
different slots in a BPF map separately, the newly introduced syntax
allows perf to control specific elements in a BPF map.

Test result:

  # cat ./test_bpf_map_3.c
  /************************ BEGIN **************************/
  #include <uapi/linux/bpf.h>
  #define SEC(NAME) __attribute__((section(NAME), used))
  struct bpf_map_def {
	unsigned int type;
	unsigned int key_size;
	unsigned int value_size;
	unsigned int max_entries;
  };
  static void *(*map_lookup_elem)(struct bpf_map_def *, void *) =
 	(void *)BPF_FUNC_map_lookup_elem;
  static int (*trace_printk)(const char *fmt, int fmt_size, ...) =
 	(void *)BPF_FUNC_trace_printk;
  struct bpf_map_def SEC("maps") channel = {
 	.type = BPF_MAP_TYPE_ARRAY,
 	.key_size = sizeof(int),
 	.value_size = sizeof(unsigned char),
 	.max_entries = 100,
  };
  SEC("func=hrtimer_nanosleep rqtp->tv_nsec")
  int func(void *ctx, int err, long nsec)
  {
 	char fmt[] = "%ld\n";
 	long usec = nsec * 0x10624dd3 >> 38; // nsec / 1000
 	int key = (int)usec;
 	unsigned char *pval = map_lookup_elem(&channel, &key);

 	if (!pval)
 		return 0;
 	trace_printk(fmt, sizeof(fmt), (unsigned char)*pval);
 	return 0;
  }
  char _license[] SEC("license") = "GPL";
  int _version SEC("version") = LINUX_VERSION_CODE;
  /************************* END ***************************/

Normal case:

  # echo "" > /sys/kernel/debug/tracing/trace
  # ./perf record -e './test_bpf_map_3.c/map:channel.value[0,1,2,3...5]=101/' usleep 2
  [ perf record: Woken up 1 times to write data ]
  [ perf record: Captured and wrote 0.012 MB perf.data ]
  # cat /sys/kernel/debug/tracing/trace | grep usleep
            usleep-405   [004] d... 2745423.547822: : 101
  # ./perf record -e './test_bpf_map_3.c/map:channel.value[0...9,20...29]=102,map:channel.value[10...19]=103/' usleep 3
  [ perf record: Woken up 1 times to write data ]
  [ perf record: Captured and wrote 0.012 MB perf.data ]
  # ./perf record -e './test_bpf_map_3.c/map:channel.value[0...9,20...29]=102,map:channel.value[10...19]=103/' usleep 15
  [ perf record: Woken up 1 times to write data ]
  [ perf record: Captured and wrote 0.012 MB perf.data ]
  # cat /sys/kernel/debug/tracing/trace | grep usleep
            usleep-405   [004] d... 2745423.547822: : 101
            usleep-655   [006] d... 2745434.122814: : 102
            usleep-904   [006] d... 2745439.916264: : 103
  # ./perf record -e './test_bpf_map_3.c/map:channel.value[all]=104/' usleep 99
  # cat /sys/kernel/debug/tracing/trace | grep usleep
            usleep-405   [004] d... 2745423.547822: : 101
            usleep-655   [006] d... 2745434.122814: : 102
            usleep-904   [006] d... 2745439.916264: : 103
            usleep-1537  [003] d... 2745538.053737: : 104

Error case:

  # ./perf record -e './test_bpf_map_3.c/map:channel.value[10...1000]=104/' usleep 99
  event syntax error: '..annel.value[10...1000]=104/'
                                   \___ Index too large
  Hint:	Valid config terms:
      	map:[<arraymap>].value<indices>=[value]
      	map:[<eventmap>].event<indices>=[event]

      	where <indices> is something like [0,3...5] or [all]
      	(add -v to see detail)
  Run 'perf list' for a list of valid events

   Usage: perf record [<options>] [<command>]
      or: perf record [<options>] -- <command> [<options>]

      -e, --event <event>   event selector. use 'perf list' to list available events

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
	Cc: Cody P Schafer <dev@codyps.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Jeremie Galarneau <jeremie.galarneau@efficios.com>
	Cc: Kirill Smelkov <kirr@nexedi.com>
	Cc: Li Zefan <lizefan@huawei.com>
	Cc: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/1456132275-98875-9-git-send-email-wangnan0@huawei.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit e571e029bdbf59f485fe67740b7a4ef421e1d55d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/parse-events.c
#	tools/perf/util/parse-events.l
#	tools/perf/util/parse-events.y
diff --cc tools/perf/util/parse-events.c
index 3a234b74d6ff,6e2f20334379..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -590,6 -578,183 +590,186 @@@ static int add_tracepoint_multi_sys(str
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ struct __add_bpf_event_param {
+ 	struct parse_events_evlist *data;
+ 	struct list_head *list;
+ };
+ 
+ static int add_bpf_event(struct probe_trace_event *tev, int fd,
+ 			 void *_param)
+ {
+ 	LIST_HEAD(new_evsels);
+ 	struct __add_bpf_event_param *param = _param;
+ 	struct parse_events_evlist *evlist = param->data;
+ 	struct list_head *list = param->list;
+ 	struct perf_evsel *pos;
+ 	int err;
+ 
+ 	pr_debug("add bpf event %s:%s and attach bpf program %d\n",
+ 		 tev->group, tev->event, fd);
+ 
+ 	err = parse_events_add_tracepoint(&new_evsels, &evlist->idx, tev->group,
+ 					  tev->event, evlist->error, NULL);
+ 	if (err) {
+ 		struct perf_evsel *evsel, *tmp;
+ 
+ 		pr_debug("Failed to add BPF event %s:%s\n",
+ 			 tev->group, tev->event);
+ 		list_for_each_entry_safe(evsel, tmp, &new_evsels, node) {
+ 			list_del(&evsel->node);
+ 			perf_evsel__delete(evsel);
+ 		}
+ 		return err;
+ 	}
+ 	pr_debug("adding %s:%s\n", tev->group, tev->event);
+ 
+ 	list_for_each_entry(pos, &new_evsels, node) {
+ 		pr_debug("adding %s:%s to %p\n",
+ 			 tev->group, tev->event, pos);
+ 		pos->bpf_fd = fd;
+ 	}
+ 	list_splice(&new_evsels, list);
+ 	return 0;
+ }
+ 
+ int parse_events_load_bpf_obj(struct parse_events_evlist *data,
+ 			      struct list_head *list,
+ 			      struct bpf_object *obj)
+ {
+ 	int err;
+ 	char errbuf[BUFSIZ];
+ 	struct __add_bpf_event_param param = {data, list};
+ 	static bool registered_unprobe_atexit = false;
+ 
+ 	if (IS_ERR(obj) || !obj) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Internal error: load bpf obj with NULL");
+ 		err = -EINVAL;
+ 		goto errout;
+ 	}
+ 
+ 	/*
+ 	 * Register atexit handler before calling bpf__probe() so
+ 	 * bpf__probe() don't need to unprobe probe points its already
+ 	 * created when failure.
+ 	 */
+ 	if (!registered_unprobe_atexit) {
+ 		atexit(bpf__clear);
+ 		registered_unprobe_atexit = true;
+ 	}
+ 
+ 	err = bpf__probe(obj);
+ 	if (err) {
+ 		bpf__strerror_probe(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__load(obj);
+ 	if (err) {
+ 		bpf__strerror_load(obj, err, errbuf, sizeof(errbuf));
+ 		goto errout;
+ 	}
+ 
+ 	err = bpf__foreach_tev(obj, add_bpf_event, &param);
+ 	if (err) {
+ 		snprintf(errbuf, sizeof(errbuf),
+ 			 "Attach events in BPF object failed");
+ 		goto errout;
+ 	}
+ 
+ 	return 0;
+ errout:
+ 	data->error->help = strdup("(add -v to see detail)");
+ 	data->error->str = strdup(errbuf);
+ 	return err;
+ }
+ 
+ static int
+ parse_events_config_bpf(struct parse_events_evlist *data,
+ 			struct bpf_object *obj,
+ 			struct list_head *head_config)
+ {
+ 	struct parse_events_term *term;
+ 	int error_pos;
+ 
+ 	if (!head_config || list_empty(head_config))
+ 		return 0;
+ 
+ 	list_for_each_entry(term, head_config, list) {
+ 		char errbuf[BUFSIZ];
+ 		int err;
+ 
+ 		if (term->type_term != PARSE_EVENTS__TERM_TYPE_USER) {
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "Invalid config term for BPF object");
+ 			errbuf[BUFSIZ - 1] = '\0';
+ 
+ 			data->error->idx = term->err_term;
+ 			data->error->str = strdup(errbuf);
+ 			return -EINVAL;
+ 		}
+ 
+ 		err = bpf__config_obj(obj, term, data->evlist, &error_pos);
+ 		if (err) {
+ 			bpf__strerror_config_obj(obj, term, data->evlist,
+ 						 &error_pos, err, errbuf,
+ 						 sizeof(errbuf));
+ 			data->error->help = strdup(
+ "Hint:\tValid config terms:\n"
+ "     \tmap:[<arraymap>].value<indices>=[value]\n"
+ "     \tmap:[<eventmap>].event<indices>=[event]\n"
+ "\n"
+ "     \twhere <indices> is something like [0,3...5] or [all]\n"
+ "     \t(add -v to see detail)");
+ 			data->error->str = strdup(errbuf);
+ 			if (err == -BPF_LOADER_ERRNO__OBJCONF_MAP_VALUE)
+ 				data->error->idx = term->err_val;
+ 			else
+ 				data->error->idx = term->err_term + error_pos;
+ 			return err;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ int parse_events_load_bpf(struct parse_events_evlist *data,
+ 			  struct list_head *list,
+ 			  char *bpf_file_name,
+ 			  bool source,
+ 			  struct list_head *head_config)
+ {
+ 	struct bpf_object *obj;
+ 	int err;
+ 
+ 	obj = bpf__prepare_load(bpf_file_name, source);
+ 	if (IS_ERR(obj)) {
+ 		char errbuf[BUFSIZ];
+ 
+ 		err = PTR_ERR(obj);
+ 
+ 		if (err == -ENOTSUP)
+ 			snprintf(errbuf, sizeof(errbuf),
+ 				 "BPF support is not compiled");
+ 		else
+ 			bpf__strerror_prepare_load(bpf_file_name,
+ 						   source,
+ 						   -err, errbuf,
+ 						   sizeof(errbuf));
+ 
+ 		data->error->help = strdup("(add -v to see detail)");
+ 		data->error->str = strdup(errbuf);
+ 		return err;
+ 	}
+ 
+ 	err = parse_events_load_bpf_obj(data, list, obj);
+ 	if (err)
+ 		return err;
+ 	return parse_events_config_bpf(data, obj, head_config);
+ }
+ 
++>>>>>>> e571e029bdbf (perf tools: Enable indices setting syntax for BPF map)
  static int
  parse_breakpoint_type(const char *type, struct perf_event_attr *attr)
  {
diff --cc tools/perf/util/parse-events.l
index 32c8c241ab5c,fb85d0311d28..000000000000
--- a/tools/perf/util/parse-events.l
+++ b/tools/perf/util/parse-events.l
@@@ -214,7 -204,8 +223,12 @@@ no-overwrite		{ return term(yyscanner, 
  ,			{ return ','; }
  "/"			{ BEGIN(INITIAL); return '/'; }
  {name_minus}		{ return str(yyscanner, PE_NAME); }
++<<<<<<< HEAD
 +@{drv_cfg_term}		{ return drv_str(yyscanner, PE_DRV_CFG_TERM); }
++=======
+ \[all\]			{ return PE_ARRAY_ALL; }
+ "["			{ BEGIN(array); return '['; }
++>>>>>>> e571e029bdbf (perf tools: Enable indices setting syntax for BPF map)
  }
  
  <mem>{
diff --cc tools/perf/util/parse-events.y
index b7975dc972b1,d1fbcabbe70d..000000000000
--- a/tools/perf/util/parse-events.y
+++ b/tools/perf/util/parse-events.y
@@@ -51,7 -48,7 +51,11 @@@ static void inc_group_count(struct list
  %token PE_PREFIX_MEM PE_PREFIX_RAW PE_PREFIX_GROUP
  %token PE_ERROR
  %token PE_PMU_EVENT_PRE PE_PMU_EVENT_SUF PE_KERNEL_PMU_EVENT
++<<<<<<< HEAD
 +%token PE_DRV_CFG_TERM
++=======
+ %token PE_ARRAY_ALL PE_ARRAY_RANGE
++>>>>>>> e571e029bdbf (perf tools: Enable indices setting syntax for BPF map)
  %type <num> PE_VALUE
  %type <num> PE_VALUE_SYM_HW
  %type <num> PE_VALUE_SYM_SW
@@@ -547,18 -574,89 +555,98 @@@ PE_TER
  {
  	struct parse_events_term *term;
  
 -	ABORT_ON(parse_events_term__num(&term, (int)$1, NULL, 1, &@1, NULL));
 +	ABORT_ON(parse_events_term__num(&term, (int)$1, NULL, 1, true, &@1, NULL));
 +	$$ = term;
 +}
 +|
 +PE_DRV_CFG_TERM
 +{
 +	struct parse_events_term *term;
 +
 +	ABORT_ON(parse_events_term__str(&term, PARSE_EVENTS__TERM_TYPE_DRV_CFG,
 +					$1, $1, &@1, NULL));
  	$$ = term;
  }
+ |
+ PE_NAME array '=' PE_NAME
+ {
+ 	struct parse_events_term *term;
+ 	int i;
+ 
+ 	ABORT_ON(parse_events_term__str(&term, PARSE_EVENTS__TERM_TYPE_USER,
+ 					$1, $4, &@1, &@4));
+ 
+ 	term->array = $2;
+ 	$$ = term;
+ }
+ |
+ PE_NAME array '=' PE_VALUE
+ {
+ 	struct parse_events_term *term;
+ 
+ 	ABORT_ON(parse_events_term__num(&term, PARSE_EVENTS__TERM_TYPE_USER,
+ 					$1, $4, &@1, &@4));
+ 	term->array = $2;
+ 	$$ = term;
+ }
+ 
+ array:
+ '[' array_terms ']'
+ {
+ 	$$ = $2;
+ }
+ |
+ PE_ARRAY_ALL
+ {
+ 	$$.nr_ranges = 0;
+ 	$$.ranges = NULL;
+ }
+ 
+ array_terms:
+ array_terms ',' array_term
+ {
+ 	struct parse_events_array new_array;
+ 
+ 	new_array.nr_ranges = $1.nr_ranges + $3.nr_ranges;
+ 	new_array.ranges = malloc(sizeof(new_array.ranges[0]) *
+ 				  new_array.nr_ranges);
+ 	ABORT_ON(!new_array.ranges);
+ 	memcpy(&new_array.ranges[0], $1.ranges,
+ 	       $1.nr_ranges * sizeof(new_array.ranges[0]));
+ 	memcpy(&new_array.ranges[$1.nr_ranges], $3.ranges,
+ 	       $3.nr_ranges * sizeof(new_array.ranges[0]));
+ 	free($1.ranges);
+ 	free($3.ranges);
+ 	$$ = new_array;
+ }
+ |
+ array_term
+ 
+ array_term:
+ PE_VALUE
+ {
+ 	struct parse_events_array array;
+ 
+ 	array.nr_ranges = 1;
+ 	array.ranges = malloc(sizeof(array.ranges[0]));
+ 	ABORT_ON(!array.ranges);
+ 	array.ranges[0].start = $1;
+ 	array.ranges[0].length = 1;
+ 	$$ = array;
+ }
+ |
+ PE_VALUE PE_ARRAY_RANGE PE_VALUE
+ {
+ 	struct parse_events_array array;
+ 
+ 	ABORT_ON($3 < $1);
+ 	array.nr_ranges = 1;
+ 	array.ranges = malloc(sizeof(array.ranges[0]));
+ 	ABORT_ON(!array.ranges);
+ 	array.ranges[0].start = $1;
+ 	array.ranges[0].length = $3 - $1 + 1;
+ 	$$ = array;
+ }
  
  sep_dc: ':' |
  
* Unmerged path tools/perf/util/parse-events.c
* Unmerged path tools/perf/util/parse-events.l
* Unmerged path tools/perf/util/parse-events.y
