ovl: generalize ovl_verify_origin() and helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 051224438af21047b34160b1e0ad1c5af45fdace
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/05122443.failed

Remove the "origin" language from the functions that handle set, get
and verify of "origin" xattr and pass the xattr name as an argument.

The same helpers are going to be used for NFS export to get, get and
verify the "upper" xattr for directory index entries.

ovl_verify_origin() is now a helper used only to verify non upper
file handle stored in "origin" xattr of upper inode.

The upper root dir file handle is still stored in "origin" xattr on
the index dir for backward compatibility. This is going to be changed
by the patch that adds directory index entries support.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 051224438af21047b34160b1e0ad1c5af45fdace)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/copy_up.c
#	fs/overlayfs/namei.c
#	fs/overlayfs/overlayfs.h
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/copy_up.c
index fa73bcccdc24,503c92404095..000000000000
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@@ -271,9 -238,9 +271,13 @@@ struct ovl_fh *ovl_encode_fh(struct den
  	int fh_type, fh_len, dwords;
  	void *buf;
  	int buflen = MAX_HANDLE_SZ;
++<<<<<<< HEAD
 +	uuid_be *uuid = (uuid_be *) &lower->d_sb->s_uuid;
++=======
+ 	uuid_t *uuid = &real->d_sb->s_uuid;
++>>>>>>> 051224438af2 (ovl: generalize ovl_verify_origin() and helpers)
  
 -	buf = kmalloc(buflen, GFP_KERNEL);
 +	buf = kmalloc(buflen, GFP_TEMPORARY);
  	if (!buf)
  		return ERR_PTR(-ENOMEM);
  
diff --cc fs/overlayfs/namei.c
index 0afb8ae29e9b,11e164cb2593..000000000000
--- a/fs/overlayfs/namei.c
+++ b/fs/overlayfs/namei.c
@@@ -87,12 -87,39 +87,43 @@@ static int ovl_acceptable(void *ctx, st
  	return 1;
  }
  
++<<<<<<< HEAD
 +static struct ovl_fh *ovl_get_origin_fh(struct dentry *dentry)
++=======
+ /*
+  * Check validity of an overlay file handle buffer.
+  *
+  * Return 0 for a valid file handle.
+  * Return -ENODATA for "origin unknown".
+  * Return <0 for an invalid file handle.
+  */
+ static int ovl_check_fh_len(struct ovl_fh *fh, int fh_len)
+ {
+ 	if (fh_len < sizeof(struct ovl_fh) || fh_len < fh->len)
+ 		return -EINVAL;
+ 
+ 	if (fh->magic != OVL_FH_MAGIC)
+ 		return -EINVAL;
+ 
+ 	/* Treat larger version and unknown flags as "origin unknown" */
+ 	if (fh->version > OVL_FH_VERSION || fh->flags & ~OVL_FH_FLAG_ALL)
+ 		return -ENODATA;
+ 
+ 	/* Treat endianness mismatch as "origin unknown" */
+ 	if (!(fh->flags & OVL_FH_FLAG_ANY_ENDIAN) &&
+ 	    (fh->flags & OVL_FH_FLAG_BIG_ENDIAN) != OVL_FH_FLAG_CPU_ENDIAN)
+ 		return -ENODATA;
+ 
+ 	return 0;
+ }
+ 
+ static struct ovl_fh *ovl_get_fh(struct dentry *dentry, const char *name)
++>>>>>>> 051224438af2 (ovl: generalize ovl_verify_origin() and helpers)
  {
 -	int res, err;
 +	int res;
  	struct ovl_fh *fh = NULL;
  
- 	res = vfs_getxattr(dentry, OVL_XATTR_ORIGIN, NULL, 0);
+ 	res = vfs_getxattr(dentry, name, NULL, 0);
  	if (res < 0) {
  		if (res == -ENODATA || res == -EOPNOTSUPP)
  			return NULL;
@@@ -313,9 -319,43 +344,48 @@@ static int ovl_check_origin(struct dent
  		dput(origin);
  		return -ENOMEM;
  	}
++<<<<<<< HEAD
 +	**stackp = (struct path) { .dentry = origin, .mnt = mnt };
++=======
+ 	**stackp = (struct ovl_path){
+ 		.dentry = origin,
+ 		.layer = &ofs->lower_layers[i]
+ 	};
+ 
+ 	return 0;
+ 
+ invalid:
+ 	pr_warn_ratelimited("overlayfs: invalid origin (%pd2, ftype=%x, origin ftype=%x).\n",
+ 			    upperdentry, d_inode(upperdentry)->i_mode & S_IFMT,
+ 			    d_inode(origin)->i_mode & S_IFMT);
+ 	dput(origin);
+ 	return -EIO;
+ }
+ 
+ static int ovl_check_origin(struct ovl_fs *ofs, struct dentry *upperdentry,
+ 			    struct ovl_path **stackp, unsigned int *ctrp)
+ {
+ 	struct ovl_fh *fh = ovl_get_fh(upperdentry, OVL_XATTR_ORIGIN);
+ 	int err;
+ 
+ 	if (IS_ERR_OR_NULL(fh))
+ 		return PTR_ERR(fh);
+ 
+ 	err = ovl_check_origin_fh(ofs, fh, upperdentry, stackp);
+ 	kfree(fh);
+ 
+ 	if (err) {
+ 		if (err == -ESTALE)
+ 			return 0;
+ 		return err;
+ 	}
+ 
+ 	if (WARN_ON(*ctrp))
+ 		return -EIO;
+ 
++>>>>>>> 051224438af2 (ovl: generalize ovl_verify_origin() and helpers)
  	*ctrp = 1;
 +
  	return 0;
  }
  
@@@ -342,15 -383,15 +413,20 @@@ static int ovl_verify_fh(struct dentry 
  }
  
  /*
-  * Verify that an inode matches the origin file handle stored in upper inode.
+  * Verify that @real dentry matches the file handle stored in xattr @name.
   *
-  * If @set is true and there is no stored file handle, encode and store origin
-  * file handle in OVL_XATTR_ORIGIN.
+  * If @set is true and there is no stored file handle, encode @real and store
+  * file handle in xattr @name.
   *
-  * Return 0 on match, -ESTALE on mismatch, < 0 on error.
+  * Return 0 on match, -ESTALE on mismatch, -ENODATA on no xattr, < 0 on error.
   */
++<<<<<<< HEAD
 +int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 +		      struct dentry *origin, bool is_upper, bool set)
++=======
+ int ovl_verify_set_fh(struct dentry *dentry, const char *name,
+ 		      struct dentry *real, bool is_upper, bool set)
++>>>>>>> 051224438af2 (ovl: generalize ovl_verify_origin() and helpers)
  {
  	struct inode *inode;
  	struct ovl_fh *fh;
@@@ -421,10 -461,14 +498,10 @@@ int ovl_verify_index(struct dentry *ind
  		goto fail;
  
  	err = -EINVAL;
 -	if (hex2bin((u8 *)fh, index->d_name.name, len))
 -		goto fail;
 -
 -	err = ovl_check_fh_len(fh, len);
 -	if (err)
 +	if (hex2bin((u8 *)fh, index->d_name.name, len) || len != fh->len)
  		goto fail;
  
- 	err = ovl_verify_origin_fh(index, fh);
+ 	err = ovl_verify_fh(index, OVL_XATTR_ORIGIN, fh);
  	if (err)
  		goto fail;
  
diff --cc fs/overlayfs/overlayfs.h
index 79baeaeaf3d6,1d62b1e6111a..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -246,15 -249,21 +246,27 @@@ static inline bool ovl_is_impuredir(str
  
  
  /* namei.c */
++<<<<<<< HEAD
 +int ovl_verify_origin(struct dentry *dentry, struct vfsmount *mnt,
 +		      struct dentry *origin, bool is_upper, bool set);
 +int ovl_verify_index(struct dentry *index, struct path *lowerstack,
 +		     unsigned int numlower);
++=======
+ int ovl_verify_set_fh(struct dentry *dentry, const char *name,
+ 		      struct dentry *real, bool is_upper, bool set);
+ int ovl_verify_index(struct ovl_fs *ofs, struct dentry *index);
++>>>>>>> 051224438af2 (ovl: generalize ovl_verify_origin() and helpers)
  int ovl_get_index_name(struct dentry *origin, struct qstr *name);
  int ovl_path_next(int idx, struct dentry *dentry, struct path *path);
 -struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,
 -			  unsigned int flags);
 +struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags);
  bool ovl_lower_positive(struct dentry *dentry);
  
+ static inline int ovl_verify_origin(struct dentry *upper,
+ 				    struct dentry *origin, bool set)
+ {
+ 	return ovl_verify_set_fh(upper, OVL_XATTR_ORIGIN, origin, false, set);
+ }
+ 
  /* readdir.c */
  extern const struct file_operations ovl_dir_operations;
  int ovl_check_empty_dir(struct dentry *dentry, struct list_head *list);
@@@ -318,4 -326,6 +330,10 @@@ int ovl_copy_up(struct dentry *dentry)
  int ovl_copy_up_flags(struct dentry *dentry, int flags);
  int ovl_copy_xattr(struct dentry *old, struct dentry *new);
  int ovl_set_attr(struct dentry *upper, struct kstat *stat);
++<<<<<<< HEAD
 +struct ovl_fh *ovl_encode_fh(struct dentry *lower, bool is_upper);
++=======
+ struct ovl_fh *ovl_encode_fh(struct dentry *real, bool is_upper);
+ int ovl_set_origin(struct dentry *dentry, struct dentry *lower,
+ 		   struct dentry *upper);
++>>>>>>> 051224438af2 (ovl: generalize ovl_verify_origin() and helpers)
diff --cc fs/overlayfs/super.c
index d3038555ac46,4ebbb368fce8..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -871,121 -879,258 +871,154 @@@ static const struct xattr_handler *ovl_
  	NULL
  };
  
 -static int ovl_get_upper(struct ovl_fs *ofs, struct path *upperpath)
 -{
 -	struct vfsmount *upper_mnt;
 -	int err;
 -
 -	err = ovl_mount_dir(ofs->config.upperdir, upperpath);
 -	if (err)
 -		goto out;
 -
 -	/* Upper fs should not be r/o */
 -	if (sb_rdonly(upperpath->mnt->mnt_sb)) {
 -		pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 -		err = -EINVAL;
 -		goto out;
 -	}
 -
 -	err = ovl_check_namelen(upperpath, ofs, ofs->config.upperdir);
 -	if (err)
 -		goto out;
 -
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(upperpath->dentry)) {
 -		ofs->upperdir_locked = true;
 -	} else if (ofs->config.index) {
 -		pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 -	}
 -
 -	upper_mnt = clone_private_mount(upperpath);
 -	err = PTR_ERR(upper_mnt);
 -	if (IS_ERR(upper_mnt)) {
 -		pr_err("overlayfs: failed to clone upperpath\n");
 -		goto out;
 -	}
 -
 -	/* Don't inherit atime flags */
 -	upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
 -	ofs->upper_mnt = upper_mnt;
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static int ovl_make_workdir(struct ovl_fs *ofs, struct path *workpath)
 +static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
 -	struct vfsmount *mnt = ofs->upper_mnt;
 -	struct dentry *temp;
 +	struct path upperpath = { };
 +	struct path workpath = { };
 +	struct dentry *root_dentry;
 +	struct ovl_entry *oe;
 +	struct ovl_fs *ufs;
 +	const int *upper_stack_depth;
 +	int *overlay_stack_depth;
 +	struct path *stack = NULL;
 +	char *lowertmp;
 +	char *lower;
 +	unsigned int numlower;
 +	unsigned int stacklen = 0;
 +	unsigned int i;
 +	bool remote = false;
 +	struct cred *cred;
  	int err;
  
 -	err = mnt_want_write(mnt);
 -	if (err)
 -		return err;
 -
 -	ofs->workdir = ovl_workdir_create(ofs, OVL_WORKDIR_NAME, false);
 -	if (!ofs->workdir)
 -		goto out;
 -
 -	/*
 -	 * Upper should support d_type, else whiteouts are visible.  Given
 -	 * workdir and upper are on same fs, we can do iterate_dir() on
 -	 * workdir. This check requires successful creation of workdir in
 -	 * previous step.
 -	 */
 -	err = ovl_check_d_type_supported(workpath);
 -	if (err < 0)
 +	err = -ENOMEM;
 +	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
 +	if (!ufs)
  		goto out;
  
 -	/*
 -	 * We allowed this configuration and don't want to break users over
 -	 * kernel upgrade. So warn instead of erroring out.
 -	 */
 -	if (!err)
 -		pr_warn("overlayfs: upper fs needs to support d_type.\n");
 -
 -	/* Check if upper/work fs supports O_TMPFILE */
 -	temp = ovl_do_tmpfile(ofs->workdir, S_IFREG | 0);
 -	ofs->tmpfile = !IS_ERR(temp);
 -	if (ofs->tmpfile)
 -		dput(temp);
 -	else
 -		pr_warn("overlayfs: upper fs does not support tmpfile.\n");
 -
 -	/*
 -	 * Check if upper/work fs supports trusted.overlay.* xattr
 -	 */
 -	err = ovl_do_setxattr(ofs->workdir, OVL_XATTR_OPAQUE, "0", 1, 0);
 -	if (err) {
 -		ofs->noxattr = true;
 -		ofs->config.index = false;
 -		pr_warn("overlayfs: upper fs does not support xattr, falling back to index=off.\n");
 -		err = 0;
 -	} else {
 -		vfs_removexattr(ofs->workdir, OVL_XATTR_OPAQUE);
 -	}
 -
 -	/* Check if upper/work fs supports file handles */
 -	if (ofs->config.index &&
 -	    !ovl_can_decode_fh(ofs->workdir->d_sb)) {
 -		ofs->config.index = false;
 -		pr_warn("overlayfs: upper fs does not support file handles, falling back to index=off.\n");
 -	}
 -
 -out:
 -	mnt_drop_write(mnt);
 -	return err;
 -}
 -
 -static int ovl_get_workdir(struct ovl_fs *ofs, struct path *upperpath)
 -{
 -	int err;
 -	struct path workpath = { };
 -
 -	err = ovl_mount_dir(ofs->config.workdir, &workpath);
 +	ufs->config.index = ovl_index_def;
 +	err = ovl_parse_opt((char *) data, &ufs->config);
  	if (err)
 -		goto out;
 +		goto out_free_config;
  
  	err = -EINVAL;
 -	if (upperpath->mnt != workpath.mnt) {
 -		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 -		goto out;
 -	}
 -	if (!ovl_workdir_ok(workpath.dentry, upperpath->dentry)) {
 -		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 -		goto out;
 +	if (!ufs->config.lowerdir) {
 +		if (!silent)
 +			pr_err("overlayfs: missing 'lowerdir'\n");
 +		goto out_free_config;
  	}
  
 -	err = -EBUSY;
 -	if (ovl_inuse_trylock(workpath.dentry)) {
 -		ofs->workdir_locked = true;
 -	} else if (ofs->config.index) {
 -		pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 -		goto out;
 -	} else {
 -		pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_free_config;
  	}
 +	*overlay_stack_depth = 0;
  
 -	ofs->workbasedir = dget(workpath.dentry);
 -	err = ovl_make_workdir(ofs, &workpath);
 -	if (err)
 -		goto out;
 +	sb->s_maxbytes = MAX_LFS_FILESIZE;
 +	if (ufs->config.upperdir) {
 +		if (!ufs->config.workdir) {
 +			pr_err("overlayfs: missing 'workdir'\n");
 +			goto out_free_config;
 +		}
  
++<<<<<<< HEAD
 +		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
++=======
+ 	err = 0;
+ out:
+ 	path_put(&workpath);
+ 
+ 	return err;
+ }
+ 
+ static int ovl_get_indexdir(struct ovl_fs *ofs, struct ovl_entry *oe,
+ 			    struct path *upperpath)
+ {
+ 	struct vfsmount *mnt = ofs->upper_mnt;
+ 	int err;
+ 
+ 	err = mnt_want_write(mnt);
+ 	if (err)
+ 		return err;
+ 
+ 	/* Verify lower root is upper root origin */
+ 	err = ovl_verify_origin(upperpath->dentry, oe->lowerstack[0].dentry,
+ 				true);
+ 	if (err) {
+ 		pr_err("overlayfs: failed to verify upper root origin\n");
+ 		goto out;
+ 	}
+ 
+ 	ofs->indexdir = ovl_workdir_create(ofs, OVL_INDEXDIR_NAME, true);
+ 	if (ofs->indexdir) {
+ 		/* Verify upper root is exclusively associated with index dir */
+ 		err = ovl_verify_set_fh(ofs->indexdir, OVL_XATTR_ORIGIN,
+ 					upperpath->dentry, true, true);
++>>>>>>> 051224438af2 (ovl: generalize ovl_verify_origin() and helpers)
  		if (err)
 -			pr_err("overlayfs: failed to verify index dir origin\n");
 -
 -		/* Cleanup bad/stale/orphan index entries */
 -		if (!err)
 -			err = ovl_indexdir_cleanup(ofs);
 -	}
 -	if (err || !ofs->indexdir)
 -		pr_warn("overlayfs: try deleting index dir or mounting with '-o index=off' to disable inodes index.\n");
 +			goto out_free_config;
  
 -out:
 -	mnt_drop_write(mnt);
 -	return err;
 -}
 +		/* Upper fs should not be r/o */
 +		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
 +			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
 +			err = -EINVAL;
 +			goto out_put_upperpath;
 +		}
  
 -static int ovl_get_lower_layers(struct ovl_fs *ofs, struct path *stack,
 -				unsigned int numlower)
 -{
 -	int err;
 -	unsigned int i;
 +		err = ovl_check_namelen(&upperpath, ufs, ufs->config.upperdir);
 +		if (err)
 +			goto out_put_upperpath;
 +
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(upperpath.dentry)) {
 +			ufs->upperdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: upperdir is in-use by another mount, mount with '-o index=off' to override exclusive upperdir protection.\n");
 +			goto out_put_upperpath;
 +		} else {
 +			pr_warn("overlayfs: upperdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
 +		}
  
 -	err = -ENOMEM;
 -	ofs->lower_layers = kcalloc(numlower, sizeof(struct ovl_layer),
 -				    GFP_KERNEL);
 -	if (ofs->lower_layers == NULL)
 -		goto out;
 -	for (i = 0; i < numlower; i++) {
 -		struct vfsmount *mnt;
 -		dev_t dev;
 +		err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +		if (err)
 +			goto out_unlock_upperdentry;
  
 -		err = get_anon_bdev(&dev);
 -		if (err) {
 -			pr_err("overlayfs: failed to get anonymous bdev for lowerpath\n");
 -			goto out;
 +		err = -EINVAL;
 +		if (upperpath.mnt != workpath.mnt) {
 +			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +			goto out_put_workpath;
 +		}
 +		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +			goto out_put_workpath;
  		}
  
 -		mnt = clone_private_mount(&stack[i]);
 -		err = PTR_ERR(mnt);
 -		if (IS_ERR(mnt)) {
 -			pr_err("overlayfs: failed to clone lowerpath\n");
 -			free_anon_bdev(dev);
 -			goto out;
 +		err = -EBUSY;
 +		if (ovl_inuse_trylock(workpath.dentry)) {
 +			ufs->workdir_locked = true;
 +		} else if (ufs->config.index) {
 +			pr_err("overlayfs: workdir is in-use by another mount, mount with '-o index=off' to override exclusive workdir protection.\n");
 +			goto out_put_workpath;
 +		} else {
 +			pr_warn("overlayfs: workdir is in-use by another mount, accessing files from both mounts will result in undefined behavior.\n");
  		}
 -		/*
 -		 * Make lower layers R/O.  That way fchmod/fchown on lower file
 -		 * will fail instead of modifying lower fs.
 -		 */
 -		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
  
 -		ofs->lower_layers[ofs->numlower].mnt = mnt;
 -		ofs->lower_layers[ofs->numlower].pseudo_dev = dev;
 -		ofs->lower_layers[ofs->numlower].idx = i + 1;
 -		ofs->numlower++;
 +		ufs->workbasedir = workpath.dentry;
 +		upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +		err = -EOPNOTSUPP;
 +		if (!upper_stack_depth) {
 +			pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +			goto out_put_workpath;
 +		}
  
 -		/* Check if all lower layers are on same sb */
 -		if (i == 0)
 -			ofs->same_sb = mnt->mnt_sb;
 -		else if (ofs->same_sb != mnt->mnt_sb)
 -			ofs->same_sb = NULL;
 +		*overlay_stack_depth = *upper_stack_depth;
  	}
 -	err = 0;
 -out:
 -	return err;
 -}
 -
 -static struct ovl_entry *ovl_get_lowerstack(struct super_block *sb,
 -					    struct ovl_fs *ofs)
 -{
 -	int err;
 -	char *lowertmp, *lower;
 -	struct path *stack = NULL;
 -	unsigned int stacklen, numlower = 0, i;
 -	bool remote = false;
 -	struct ovl_entry *oe;
  
  	err = -ENOMEM;
 -	lowertmp = kstrdup(ofs->config.lowerdir, GFP_KERNEL);
 +	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
  	if (!lowertmp)
 -		goto out_err;
 +		goto out_unlock_workdentry;
  
  	err = -EINVAL;
  	stacklen = ovl_split_lowerdirs(lowertmp);
* Unmerged path fs/overlayfs/copy_up.c
* Unmerged path fs/overlayfs/namei.c
* Unmerged path fs/overlayfs/overlayfs.h
* Unmerged path fs/overlayfs/super.c
