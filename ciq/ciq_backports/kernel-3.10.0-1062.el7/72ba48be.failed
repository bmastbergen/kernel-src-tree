phy: Add phydev_err() and phydev_dbg() macros

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Andrew Lunn <andrew@lunn.ch>
commit 72ba48be3ec8e70937ad97d4420ef7144617c64b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/72ba48be.failed

In preparation for moving some of the phy_device structure members,
add macros for printing errors and debug information.

	Signed-off-by: Andrew Lunn <andrew@lunn.ch>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 72ba48be3ec8e70937ad97d4420ef7144617c64b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/at803x.c
#	drivers/net/phy/micrel.c
#	drivers/net/phy/phy.c
#	include/linux/phy.h
diff --cc drivers/net/phy/at803x.c
index 45cbc10de01c,62361f8af375..000000000000
--- a/drivers/net/phy/at803x.c
+++ b/drivers/net/phy/at803x.c
@@@ -108,68 -231,138 +108,151 @@@ static int at803x_config_init(struct ph
  	return 0;
  }
  
++<<<<<<< HEAD
 +/* ATHEROS 8035 */
 +static struct phy_driver at8035_driver = {
 +	.phy_id		= 0x004dd072,
 +	.name		= "Atheros 8035 ethernet",
 +	.phy_id_mask	= 0xffffffef,
 +	.config_init	= at803x_config_init,
 +	.features	= PHY_GBIT_FEATURES,
 +	.flags		= PHY_HAS_INTERRUPT,
 +	.config_aneg	= &genphy_config_aneg,
 +	.read_status	= &genphy_read_status,
 +	.driver		= {
++=======
+ static int at803x_ack_interrupt(struct phy_device *phydev)
+ {
+ 	int err;
+ 
+ 	err = phy_read(phydev, AT803X_INSR);
+ 
+ 	return (err < 0) ? err : 0;
+ }
+ 
+ static int at803x_config_intr(struct phy_device *phydev)
+ {
+ 	int err;
+ 	int value;
+ 
+ 	value = phy_read(phydev, AT803X_INER);
+ 
+ 	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+ 		err = phy_write(phydev, AT803X_INER,
+ 				value | AT803X_INER_INIT);
+ 	else
+ 		err = phy_write(phydev, AT803X_INER, 0);
+ 
+ 	return err;
+ }
+ 
+ static void at803x_link_change_notify(struct phy_device *phydev)
+ {
+ 	struct at803x_priv *priv = phydev->priv;
+ 
+ 	/*
+ 	 * Conduct a hardware reset for AT8030 every time a link loss is
+ 	 * signalled. This is necessary to circumvent a hardware bug that
+ 	 * occurs when the cable is unplugged while TX packets are pending
+ 	 * in the FIFO. In such cases, the FIFO enters an error mode it
+ 	 * cannot recover from by software.
+ 	 */
+ 	if (phydev->drv->phy_id == ATH8030_PHY_ID) {
+ 		if (phydev->state == PHY_NOLINK) {
+ 			if (priv->gpiod_reset && !priv->phy_reset) {
+ 				struct at803x_context context;
+ 
+ 				at803x_context_save(phydev, &context);
+ 
+ 				gpiod_set_value(priv->gpiod_reset, 0);
+ 				msleep(1);
+ 				gpiod_set_value(priv->gpiod_reset, 1);
+ 				msleep(1);
+ 
+ 				at803x_context_restore(phydev, &context);
+ 
+ 				phydev_dbg(phydev, "%s(): phy was reset\n",
+ 					   __func__);
+ 				priv->phy_reset = true;
+ 			}
+ 		} else {
+ 			priv->phy_reset = false;
+ 		}
+ 	}
+ }
+ 
+ static struct phy_driver at803x_driver[] = {
+ {
+ 	/* ATHEROS 8035 */
+ 	.phy_id			= ATH8035_PHY_ID,
+ 	.name			= "Atheros 8035 ethernet",
+ 	.phy_id_mask		= 0xffffffef,
+ 	.probe			= at803x_probe,
+ 	.config_init		= at803x_config_init,
+ 	.link_change_notify	= at803x_link_change_notify,
+ 	.set_wol		= at803x_set_wol,
+ 	.get_wol		= at803x_get_wol,
+ 	.suspend		= at803x_suspend,
+ 	.resume			= at803x_resume,
+ 	.features		= PHY_GBIT_FEATURES,
+ 	.flags			= PHY_HAS_INTERRUPT,
+ 	.config_aneg		= genphy_config_aneg,
+ 	.read_status		= genphy_read_status,
+ 	.ack_interrupt		= at803x_ack_interrupt,
+ 	.config_intr		= at803x_config_intr,
+ 	.driver			= {
++>>>>>>> 72ba48be3ec8 (phy: Add phydev_err() and phydev_dbg() macros)
  		.owner = THIS_MODULE,
  	},
 -}, {
 -	/* ATHEROS 8030 */
 -	.phy_id			= ATH8030_PHY_ID,
 -	.name			= "Atheros 8030 ethernet",
 -	.phy_id_mask		= 0xffffffef,
 -	.probe			= at803x_probe,
 -	.config_init		= at803x_config_init,
 -	.link_change_notify	= at803x_link_change_notify,
 -	.set_wol		= at803x_set_wol,
 -	.get_wol		= at803x_get_wol,
 -	.suspend		= at803x_suspend,
 -	.resume			= at803x_resume,
 -	.features		= PHY_GBIT_FEATURES,
 -	.flags			= PHY_HAS_INTERRUPT,
 -	.config_aneg		= genphy_config_aneg,
 -	.read_status		= genphy_read_status,
 -	.ack_interrupt		= at803x_ack_interrupt,
 -	.config_intr		= at803x_config_intr,
 -	.driver			= {
 -		.owner = THIS_MODULE,
 -	},
 -}, {
 -	/* ATHEROS 8031 */
 -	.phy_id			= ATH8031_PHY_ID,
 -	.name			= "Atheros 8031 ethernet",
 -	.phy_id_mask		= 0xffffffef,
 -	.probe			= at803x_probe,
 -	.config_init		= at803x_config_init,
 -	.link_change_notify	= at803x_link_change_notify,
 -	.set_wol		= at803x_set_wol,
 -	.get_wol		= at803x_get_wol,
 -	.suspend		= at803x_suspend,
 -	.resume			= at803x_resume,
 -	.features		= PHY_GBIT_FEATURES,
 -	.flags			= PHY_HAS_INTERRUPT,
 -	.config_aneg		= genphy_config_aneg,
 -	.read_status		= genphy_read_status,
 -	.ack_interrupt		= &at803x_ack_interrupt,
 -	.config_intr		= &at803x_config_intr,
 -	.driver			= {
 +};
 +
 +/* ATHEROS 8030 */
 +static struct phy_driver at8030_driver = {
 +	.phy_id		= 0x004dd076,
 +	.name		= "Atheros 8030 ethernet",
 +	.phy_id_mask	= 0xffffffef,
 +	.config_init	= at803x_config_init,
 +	.features	= PHY_GBIT_FEATURES,
 +	.flags		= PHY_HAS_INTERRUPT,
 +	.config_aneg	= &genphy_config_aneg,
 +	.read_status	= &genphy_read_status,
 +	.driver		= {
  		.owner = THIS_MODULE,
  	},
 -} };
 +};
 +
 +static int __init atheros_init(void)
 +{
 +	int ret;
 +
 +	ret = phy_driver_register(&at8035_driver);
 +	if (ret)
 +		goto err1;
 +
 +	ret = phy_driver_register(&at8030_driver);
 +	if (ret)
 +		goto err2;
 +
 +	return 0;
 +
 +err2:
 +	phy_driver_unregister(&at8035_driver);
 +err1:
 +	return ret;
 +}
 +
 +static void __exit atheros_exit(void)
 +{
 +	phy_driver_unregister(&at8035_driver);
 +	phy_driver_unregister(&at8030_driver);
 +}
  
 -module_phy_driver(at803x_driver);
 +module_init(atheros_init);
 +module_exit(atheros_exit);
  
  static struct mdio_device_id __maybe_unused atheros_tbl[] = {
 -	{ ATH8030_PHY_ID, 0xffffffef },
 -	{ ATH8031_PHY_ID, 0xffffffef },
 -	{ ATH8035_PHY_ID, 0xffffffef },
 +	{ 0x004dd076, 0xffffffef },
 +	{ 0x004dd072, 0xffffffef },
  	{ }
  };
  
diff --cc drivers/net/phy/micrel.c
index 2510435f34ed,bf72365e90bc..000000000000
--- a/drivers/net/phy/micrel.c
+++ b/drivers/net/phy/micrel.c
@@@ -83,44 -182,121 +83,135 @@@ static int kszphy_set_interrupt(struct 
  	return phy_write(phydev, MII_KSZPHY_INTCS, temp);
  }
  
 -static int kszphy_rmii_clk_sel(struct phy_device *phydev, bool val)
 +static int kszphy_config_intr(struct phy_device *phydev)
  {
 -	int ctrl;
 +	int temp, rc;
  
 -	ctrl = phy_read(phydev, MII_KSZPHY_CTRL);
 -	if (ctrl < 0)
 -		return ctrl;
 -
 -	if (val)
 -		ctrl |= KSZPHY_RMII_REF_CLK_SEL;
 -	else
 -		ctrl &= ~KSZPHY_RMII_REF_CLK_SEL;
 -
 -	return phy_write(phydev, MII_KSZPHY_CTRL, ctrl);
 +	/* set the interrupt pin active low */
 +	temp = phy_read(phydev, MII_KSZPHY_CTRL);
 +	temp &= ~KSZPHY_CTRL_INT_ACTIVE_HIGH;
 +	phy_write(phydev, MII_KSZPHY_CTRL, temp);
 +	rc = kszphy_set_interrupt(phydev);
 +	return rc < 0 ? rc : 0;
  }
  
 -static int kszphy_setup_led(struct phy_device *phydev, u32 reg, int val)
 +static int ksz9021_config_intr(struct phy_device *phydev)
  {
 -	int rc, temp, shift;
 +	int temp, rc;
  
++<<<<<<< HEAD
 +	/* set the interrupt pin active low */
 +	temp = phy_read(phydev, MII_KSZPHY_CTRL);
 +	temp &= ~KSZ9021_CTRL_INT_ACTIVE_HIGH;
 +	phy_write(phydev, MII_KSZPHY_CTRL, temp);
 +	rc = kszphy_set_interrupt(phydev);
 +	return rc < 0 ? rc : 0;
++=======
+ 	switch (reg) {
+ 	case MII_KSZPHY_CTRL_1:
+ 		shift = 14;
+ 		break;
+ 	case MII_KSZPHY_CTRL_2:
+ 		shift = 4;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	temp = phy_read(phydev, reg);
+ 	if (temp < 0) {
+ 		rc = temp;
+ 		goto out;
+ 	}
+ 
+ 	temp &= ~(3 << shift);
+ 	temp |= val << shift;
+ 	rc = phy_write(phydev, reg, temp);
+ out:
+ 	if (rc < 0)
+ 		phydev_err(phydev, "failed to set led mode\n");
+ 
+ 	return rc;
++>>>>>>> 72ba48be3ec8 (phy: Add phydev_err() and phydev_dbg() macros)
  }
  
 -/* Disable PHY address 0 as the broadcast address, so that it can be used as a
 - * unique (non-broadcast) address on a shared bus.
 - */
 -static int kszphy_broadcast_disable(struct phy_device *phydev)
 +static int ks8737_config_intr(struct phy_device *phydev)
  {
 -	int ret;
 +	int temp, rc;
  
++<<<<<<< HEAD
 +	/* set the interrupt pin active low */
 +	temp = phy_read(phydev, MII_KSZPHY_CTRL);
 +	temp &= ~KS8737_CTRL_INT_ACTIVE_HIGH;
 +	phy_write(phydev, MII_KSZPHY_CTRL, temp);
 +	rc = kszphy_set_interrupt(phydev);
 +	return rc < 0 ? rc : 0;
++=======
+ 	ret = phy_read(phydev, MII_KSZPHY_OMSO);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	ret = phy_write(phydev, MII_KSZPHY_OMSO, ret | KSZPHY_OMSO_B_CAST_OFF);
+ out:
+ 	if (ret)
+ 		phydev_err(phydev, "failed to disable broadcast address\n");
+ 
+ 	return ret;
+ }
+ 
+ static int kszphy_nand_tree_disable(struct phy_device *phydev)
+ {
+ 	int ret;
+ 
+ 	ret = phy_read(phydev, MII_KSZPHY_OMSO);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	if (!(ret & KSZPHY_OMSO_NAND_TREE_ON))
+ 		return 0;
+ 
+ 	ret = phy_write(phydev, MII_KSZPHY_OMSO,
+ 			ret & ~KSZPHY_OMSO_NAND_TREE_ON);
+ out:
+ 	if (ret)
+ 		phydev_err(phydev, "failed to disable NAND tree mode\n");
+ 
+ 	return ret;
++>>>>>>> 72ba48be3ec8 (phy: Add phydev_err() and phydev_dbg() macros)
  }
  
  static int kszphy_config_init(struct phy_device *phydev)
  {
++<<<<<<< HEAD
++=======
+ 	struct kszphy_priv *priv = phydev->priv;
+ 	const struct kszphy_type *type;
+ 	int ret;
+ 
+ 	if (!priv)
+ 		return 0;
+ 
+ 	type = priv->type;
+ 
+ 	if (type->has_broadcast_disable)
+ 		kszphy_broadcast_disable(phydev);
+ 
+ 	if (type->has_nand_tree_disable)
+ 		kszphy_nand_tree_disable(phydev);
+ 
+ 	if (priv->rmii_ref_clk_sel) {
+ 		ret = kszphy_rmii_clk_sel(phydev, priv->rmii_ref_clk_sel_val);
+ 		if (ret) {
+ 			phydev_err(phydev,
+ 				   "failed to set rmii reference clock\n");
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	if (priv->led_mode >= 0)
+ 		kszphy_setup_led(phydev, type->led_mode_reg, priv->led_mode);
+ 
++>>>>>>> 72ba48be3ec8 (phy: Add phydev_err() and phydev_dbg() macros)
  	return 0;
  }
  
@@@ -174,6 -562,132 +265,135 @@@ static int ksz8873mll_config_aneg(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* This routine returns -1 as an indication to the caller that the
+  * Micrel ksz9021 10/100/1000 PHY does not support standard IEEE
+  * MMD extended PHY registers.
+  */
+ static int
+ ksz9021_rd_mmd_phyreg(struct phy_device *phydev, int ptrad, int devnum,
+ 		      int regnum)
+ {
+ 	return -1;
+ }
+ 
+ /* This routine does nothing since the Micrel ksz9021 does not support
+  * standard IEEE MMD extended PHY registers.
+  */
+ static void
+ ksz9021_wr_mmd_phyreg(struct phy_device *phydev, int ptrad, int devnum,
+ 		      int regnum, u32 val)
+ {
+ }
+ 
+ static int kszphy_get_sset_count(struct phy_device *phydev)
+ {
+ 	return ARRAY_SIZE(kszphy_hw_stats);
+ }
+ 
+ static void kszphy_get_strings(struct phy_device *phydev, u8 *data)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(kszphy_hw_stats); i++) {
+ 		memcpy(data + i * ETH_GSTRING_LEN,
+ 		       kszphy_hw_stats[i].string, ETH_GSTRING_LEN);
+ 	}
+ }
+ 
+ #ifndef UINT64_MAX
+ #define UINT64_MAX              (u64)(~((u64)0))
+ #endif
+ static u64 kszphy_get_stat(struct phy_device *phydev, int i)
+ {
+ 	struct kszphy_hw_stat stat = kszphy_hw_stats[i];
+ 	struct kszphy_priv *priv = phydev->priv;
+ 	u64 val;
+ 
+ 	val = phy_read(phydev, stat.reg);
+ 	if (val < 0) {
+ 		val = UINT64_MAX;
+ 	} else {
+ 		val = val & ((1 << stat.bits) - 1);
+ 		priv->stats[i] += val;
+ 		val = priv->stats[i];
+ 	}
+ 
+ 	return val;
+ }
+ 
+ static void kszphy_get_stats(struct phy_device *phydev,
+ 			     struct ethtool_stats *stats, u64 *data)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(kszphy_hw_stats); i++)
+ 		data[i] = kszphy_get_stat(phydev, i);
+ }
+ 
+ static int kszphy_probe(struct phy_device *phydev)
+ {
+ 	const struct kszphy_type *type = phydev->drv->driver_data;
+ 	const struct device_node *np = phydev->dev.of_node;
+ 	struct kszphy_priv *priv;
+ 	struct clk *clk;
+ 	int ret;
+ 
+ 	priv = devm_kzalloc(&phydev->dev, sizeof(*priv), GFP_KERNEL);
+ 	if (!priv)
+ 		return -ENOMEM;
+ 
+ 	phydev->priv = priv;
+ 
+ 	priv->type = type;
+ 
+ 	if (type->led_mode_reg) {
+ 		ret = of_property_read_u32(np, "micrel,led-mode",
+ 				&priv->led_mode);
+ 		if (ret)
+ 			priv->led_mode = -1;
+ 
+ 		if (priv->led_mode > 3) {
+ 			phydev_err(phydev, "invalid led mode: 0x%02x\n",
+ 				   priv->led_mode);
+ 			priv->led_mode = -1;
+ 		}
+ 	} else {
+ 		priv->led_mode = -1;
+ 	}
+ 
+ 	clk = devm_clk_get(&phydev->dev, "rmii-ref");
+ 	/* NOTE: clk may be NULL if building without CONFIG_HAVE_CLK */
+ 	if (!IS_ERR_OR_NULL(clk)) {
+ 		unsigned long rate = clk_get_rate(clk);
+ 		bool rmii_ref_clk_sel_25_mhz;
+ 
+ 		priv->rmii_ref_clk_sel = type->has_rmii_ref_clk_sel;
+ 		rmii_ref_clk_sel_25_mhz = of_property_read_bool(np,
+ 				"micrel,rmii-reference-clock-select-25-mhz");
+ 
+ 		if (rate > 24500000 && rate < 25500000) {
+ 			priv->rmii_ref_clk_sel_val = rmii_ref_clk_sel_25_mhz;
+ 		} else if (rate > 49500000 && rate < 50500000) {
+ 			priv->rmii_ref_clk_sel_val = !rmii_ref_clk_sel_25_mhz;
+ 		} else {
+ 			phydev_err(phydev, "Clock rate out of range: %ld\n",
+ 				   rate);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	/* Support legacy board-file configuration */
+ 	if (phydev->dev_flags & MICREL_PHY_50MHZ_CLK) {
+ 		priv->rmii_ref_clk_sel = true;
+ 		priv->rmii_ref_clk_sel_val = true;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 72ba48be3ec8 (phy: Add phydev_err() and phydev_dbg() macros)
  static struct phy_driver ksphy_driver[] = {
  {
  	.phy_id		= PHY_ID_KS8737,
diff --cc drivers/net/phy/phy.c
index 72b4ef80a369,9771941cf0ee..000000000000
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@@ -893,13 -995,12 +893,22 @@@ void phy_state_machine(struct work_stru
  	if (err < 0)
  		phy_error(phydev);
  
++<<<<<<< HEAD
 +	/* Only re-schedule a PHY state machine change if we are polling the
 +	 * PHY, if PHY_IGNORE_INTERRUPT is set, then we will be moving
 +	 * between states from phy_mac_interrupt()
 +	 */
 +	if (phydev->irq == PHY_POLL)
 +		queue_delayed_work(system_power_efficient_wq, &phydev->state_queue,
 +				   PHY_STATE_TIME * HZ);
++=======
+ 	phydev_dbg(phydev, "PHY state change %s -> %s\n",
+ 		   phy_state_to_str(old_state),
+ 		   phy_state_to_str(phydev->state));
+ 
+ 	queue_delayed_work(system_power_efficient_wq, &phydev->state_queue,
+ 			   PHY_STATE_TIME * HZ);
++>>>>>>> 72ba48be3ec8 (phy: Add phydev_err() and phydev_dbg() macros)
  }
  
  void phy_mac_interrupt(struct phy_device *phydev, int new_link)
diff --cc include/linux/phy.h
index 4477c1bcd079,dbcf9fdd960c..000000000000
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@@ -669,6 -777,14 +669,17 @@@ static inline int phy_read_status(struc
  	return phydev->drv->read_status(phydev);
  }
  
++<<<<<<< HEAD
++=======
+ #define phydev_err(_phydev, format, args...)	\
+ 	dev_err(&_phydev->dev, format, ##args)
+ 
+ #define phydev_dbg(_phydev, format, args...)	\
+ 	dev_dbg(&_phydev->dev, format, ##args)
+ 
+ int genphy_config_init(struct phy_device *phydev);
+ int genphy_setup_forced(struct phy_device *phydev);
++>>>>>>> 72ba48be3ec8 (phy: Add phydev_err() and phydev_dbg() macros)
  int genphy_restart_aneg(struct phy_device *phydev);
  int genphy_config_aneg(struct phy_device *phydev);
  int genphy_aneg_done(struct phy_device *phydev);
* Unmerged path drivers/net/phy/at803x.c
diff --git a/drivers/net/phy/bcm87xx.c b/drivers/net/phy/bcm87xx.c
index 799789518e87..5f122f270af7 100644
--- a/drivers/net/phy/bcm87xx.c
+++ b/drivers/net/phy/bcm87xx.c
@@ -163,8 +163,9 @@ static int bcm87xx_did_interrupt(struct phy_device *phydev)
 	reg = phy_read(phydev, BCM87XX_LASI_STATUS);
 
 	if (reg < 0) {
-		dev_err(&phydev->dev,
-			"Error: Read of BCM87XX_LASI_STATUS failed: %d\n", reg);
+		phydev_err(phydev,
+			   "Error: Read of BCM87XX_LASI_STATUS failed: %d\n",
+			   reg);
 		return 0;
 	}
 	return (reg & 1) != 0;
* Unmerged path drivers/net/phy/micrel.c
* Unmerged path drivers/net/phy/phy.c
* Unmerged path include/linux/phy.h
