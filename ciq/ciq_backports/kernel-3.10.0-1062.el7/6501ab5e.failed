crypto: chelsio - Reset counters on cxgb4 Detach

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [crypto] chelsio - Reset counters on cxgb4 Detach (Arjun Vynipadath) [1642432]
Rebuild_FUZZ: 90.91%
commit-author Harsh Jain <harsh@chelsio.com>
commit 6501ab5ed4d925cce4c2a1c49b63583c42e65bd8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/6501ab5e.failed

Reset the counters on receiving detach from Cxgb4.

	Signed-off-by: Atul Gupta <atul.gupta@chelsio.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 6501ab5ed4d925cce4c2a1c49b63583c42e65bd8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_core.c
diff --cc drivers/crypto/chelsio/chcr_core.c
index 2c472e3c6aeb,e04b3e8fa623..000000000000
--- a/drivers/crypto/chelsio/chcr_core.c
+++ b/drivers/crypto/chelsio/chcr_core.c
@@@ -81,38 -101,56 +81,59 @@@ static int chcr_dev_add(struct uld_ctx 
  {
  	struct chcr_dev *dev;
  
 -	dev = &u_ctx->dev;
 -	dev->state = CHCR_ATTACH;
 -	atomic_set(&dev->inflight, 0);
 -	mutex_lock(&drv_data.drv_mutex);
 -	list_move(&u_ctx->entry, &drv_data.act_dev);
 -	if (!drv_data.last_dev)
 -		drv_data.last_dev = u_ctx;
 -	mutex_unlock(&drv_data.drv_mutex);
 -}
 -
 -static void chcr_dev_init(struct uld_ctx *u_ctx)
 -{
 -	struct chcr_dev *dev;
 +	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 +	if (!dev)
 +		return -ENXIO;
  
 -	dev = &u_ctx->dev;
  	spin_lock_init(&dev->lock_chcr_dev);
 -	INIT_DELAYED_WORK(&dev->detach_work, detach_work_fn);
 -	init_completion(&dev->detach_comp);
 -	dev->state = CHCR_INIT;
 -	dev->wqretry = WQ_RETRY;
 -	atomic_inc(&drv_data.dev_count);
 -	atomic_set(&dev->inflight, 0);
 -	mutex_lock(&drv_data.drv_mutex);
 -	list_add_tail(&u_ctx->entry, &drv_data.inact_dev);
 -	if (!drv_data.last_dev)
 -		drv_data.last_dev = u_ctx;
 -	mutex_unlock(&drv_data.drv_mutex);
 +	u_ctx->dev = dev;
 +	dev->u_ctx = u_ctx;
 +	atomic_inc(&dev_count);
 +	mutex_lock(&dev_mutex);
 +	list_add_tail(&u_ctx->entry, &uld_ctx_list);
 +	if (!ctx_rr)
 +		ctx_rr = u_ctx;
 +	mutex_unlock(&dev_mutex);
 +	return 0;
  }
  
 -static int chcr_dev_move(struct uld_ctx *u_ctx)
 +static int chcr_dev_remove(struct uld_ctx *u_ctx)
  {
++<<<<<<< HEAD
 +	if (ctx_rr == u_ctx) {
 +		if (list_is_last(&ctx_rr->entry, &uld_ctx_list))
 +			ctx_rr = list_first_entry(&uld_ctx_list,
 +						  struct uld_ctx,
 +						  entry);
++=======
+ 	struct adapter *adap;
+ 
+ 	 mutex_lock(&drv_data.drv_mutex);
+ 	if (drv_data.last_dev == u_ctx) {
+ 		if (list_is_last(&drv_data.last_dev->entry, &drv_data.act_dev))
+ 			drv_data.last_dev = list_first_entry(&drv_data.act_dev,
+ 						  struct uld_ctx, entry);
++>>>>>>> 6501ab5ed4d9 (crypto: chelsio - Reset counters on cxgb4 Detach)
  		else
 -			drv_data.last_dev =
 -				list_next_entry(drv_data.last_dev, entry);
 +			ctx_rr = list_next_entry(ctx_rr, entry);
  	}
++<<<<<<< HEAD
 +	list_del(&u_ctx->entry);
 +	if (list_empty(&uld_ctx_list))
 +		ctx_rr = NULL;
 +	kfree(u_ctx->dev);
 +	u_ctx->dev = NULL;
 +	atomic_dec(&dev_count);
++=======
+ 	list_move(&u_ctx->entry, &drv_data.inact_dev);
+ 	if (list_empty(&drv_data.act_dev))
+ 		drv_data.last_dev = NULL;
+ 	adap = padap(&u_ctx->dev);
+ 	memset(&adap->chcr_stats, 0, sizeof(adap->chcr_stats));
+ 	atomic_dec(&drv_data.dev_count);
+ 	mutex_unlock(&drv_data.drv_mutex);
+ 
++>>>>>>> 6501ab5ed4d9 (crypto: chelsio - Reset counters on cxgb4 Detach)
  	return 0;
  }
  
* Unmerged path drivers/crypto/chelsio/chcr_core.c
