sunrpc: Save remote presentation address in svc_xprt for trace events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit ece200ddd54b9ce840cfee554fb812560c545c7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/ece200dd.failed

TP_printk defines a format string that is passed to user space for
converting raw trace event records to something human-readable.

My user space's printf (Oracle Linux 7), however, does not have a
%pI format specifier. The result is that what is supposed to be an
IP address in the output of "trace-cmd report" is just a string that
says the field couldn't be displayed.

To fix this, adopt the same approach as the client: maintain a pre-
formated presentation address for occasions when %pI is not
available.

The location of the trace_svc_send trace point is adjusted so that
rqst->rq_xprt is not NULL when the trace event is recorded.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit ece200ddd54b9ce840cfee554fb812560c545c7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/trace/events/sunrpc.h
diff --cc include/trace/events/sunrpc.h
index c184df1b7502,1ec8c4c45766..000000000000
--- a/include/trace/events/sunrpc.h
+++ b/include/trace/events/sunrpc.h
@@@ -424,28 -485,26 +424,32 @@@ TRACE_EVENT(xs_tcp_data_recv
  		{ (1UL << RQ_BUSY),		"RQ_BUSY"})
  
  TRACE_EVENT(svc_recv,
 -	TP_PROTO(struct svc_rqst *rqst, int len),
 +	TP_PROTO(struct svc_rqst *rqst, int status),
  
 -	TP_ARGS(rqst, len),
 +	TP_ARGS(rqst, status),
  
  	TP_STRUCT__entry(
 -		__field(u32, xid)
 -		__field(int, len)
 +		__field(__be32, xid)
 +		__field(int, status)
  		__field(unsigned long, flags)
- 		__dynamic_array(unsigned char, addr, rqst->rq_addrlen)
+ 		__string(addr, rqst->rq_xprt->xpt_remotebuf)
  	),
  
  	TP_fast_assign(
 -		__entry->xid = be32_to_cpu(rqst->rq_xid);
 -		__entry->len = len;
 +		__entry->xid = status > 0 ? rqst->rq_xid : 0;
 +		__entry->status = status;
  		__entry->flags = rqst->rq_flags;
- 		memcpy(__get_dynamic_array(addr),
- 			&rqst->rq_addr, rqst->rq_addrlen);
+ 		__assign_str(addr, rqst->rq_xprt->xpt_remotebuf);
  	),
  
++<<<<<<< HEAD
 +	TP_printk("addr=%pIScp xid=0x%x status=%d flags=%s",
 +			(struct sockaddr *)__get_dynamic_array(addr),
 +			be32_to_cpu(__entry->xid), __entry->status,
++=======
+ 	TP_printk("addr=%s xid=0x%08x len=%d flags=%s",
+ 			__get_str(addr), __entry->xid, __entry->len,
++>>>>>>> ece200ddd54b (sunrpc: Save remote presentation address in svc_xprt for trace events)
  			show_rqstp_flags(__entry->flags))
  );
  
@@@ -456,22 -515,20 +460,27 @@@ DECLARE_EVENT_CLASS(svc_rqst_event
  	TP_ARGS(rqst),
  
  	TP_STRUCT__entry(
 -		__field(u32, xid)
 +		__field(__be32, xid)
  		__field(unsigned long, flags)
- 		__dynamic_array(unsigned char, addr, rqst->rq_addrlen)
+ 		__string(addr, rqst->rq_xprt->xpt_remotebuf)
  	),
  
  	TP_fast_assign(
 -		__entry->xid = be32_to_cpu(rqst->rq_xid);
 +		__entry->xid = rqst->rq_xid;
  		__entry->flags = rqst->rq_flags;
- 		memcpy(__get_dynamic_array(addr),
- 			&rqst->rq_addr, rqst->rq_addrlen);
+ 		__assign_str(addr, rqst->rq_xprt->xpt_remotebuf);
  	),
  
++<<<<<<< HEAD
 +	TP_printk("addr=%pIScp rq_xid=0x%x flags=%s",
 +		(struct sockaddr *)__get_dynamic_array(addr),
 +		be32_to_cpu(__entry->xid),
 +		show_rqstp_flags(__entry->flags))
++=======
+ 	TP_printk("addr=%s xid=0x%08x flags=%s",
+ 			__get_str(addr), __entry->xid,
+ 			show_rqstp_flags(__entry->flags))
++>>>>>>> ece200ddd54b (sunrpc: Save remote presentation address in svc_xprt for trace events)
  );
  
  DEFINE_EVENT(svc_rqst_event, svc_defer,
@@@ -489,24 -546,22 +498,29 @@@ DECLARE_EVENT_CLASS(svc_rqst_status
  	TP_ARGS(rqst, status),
  
  	TP_STRUCT__entry(
 -		__field(u32, xid)
 +		__field(__be32, xid)
  		__field(int, status)
  		__field(unsigned long, flags)
- 		__dynamic_array(unsigned char, addr, rqst->rq_addrlen)
+ 		__string(addr, rqst->rq_xprt->xpt_remotebuf)
  	),
  
  	TP_fast_assign(
 -		__entry->xid = be32_to_cpu(rqst->rq_xid);
 +		__entry->xid = rqst->rq_xid;
  		__entry->status = status;
  		__entry->flags = rqst->rq_flags;
- 		memcpy(__get_dynamic_array(addr),
- 			&rqst->rq_addr, rqst->rq_addrlen);
+ 		__assign_str(addr, rqst->rq_xprt->xpt_remotebuf);
  	),
  
++<<<<<<< HEAD
 +	TP_printk("addr=%pIScp rq_xid=0x%x status=%d flags=%s",
 +		(struct sockaddr *)__get_dynamic_array(addr),
 +		be32_to_cpu(__entry->xid),
 +		__entry->status, show_rqstp_flags(__entry->flags))
++=======
+ 	TP_printk("addr=%s xid=0x%08x status=%d flags=%s",
+ 		  __get_str(addr), __entry->xid,
+ 		  __entry->status, show_rqstp_flags(__entry->flags))
++>>>>>>> ece200ddd54b (sunrpc: Save remote presentation address in svc_xprt for trace events)
  );
  
  DEFINE_EVENT(svc_rqst_status, svc_process,
@@@ -648,18 -690,17 +647,32 @@@ DECLARE_EVENT_CLASS(svc_deferred_event
  	TP_ARGS(dr),
  
  	TP_STRUCT__entry(
++<<<<<<< HEAD
 +		__field(__be32, xid)
 +		__dynamic_array(unsigned char, addr, dr->addrlen)
 +	),
 +
 +	TP_fast_assign(
 +		__entry->xid = *(__be32 *)(dr->args + (dr->xprt_hlen>>2));
 +		memcpy(__get_dynamic_array(addr), &dr->addr, dr->addrlen);
 +	),
 +
 +	TP_printk("addr=%pIScp xid=0x%x",
 +		(struct sockaddr *)__get_dynamic_array(addr),
 +		be32_to_cpu(__entry->xid))
++=======
+ 		__field(u32, xid)
+ 		__string(addr, dr->xprt->xpt_remotebuf)
+ 	),
+ 
+ 	TP_fast_assign(
+ 		__entry->xid = be32_to_cpu(*(__be32 *)(dr->args +
+ 						       (dr->xprt_hlen>>2)));
+ 		__assign_str(addr, dr->xprt->xpt_remotebuf);
+ 	),
+ 
+ 	TP_printk("addr=%s xid=0x%08x", __get_str(addr), __entry->xid)
++>>>>>>> ece200ddd54b (sunrpc: Save remote presentation address in svc_xprt for trace events)
  );
  
  DEFINE_EVENT(svc_deferred_event, svc_drop_deferred,
diff --git a/include/linux/sunrpc/svc_xprt.h b/include/linux/sunrpc/svc_xprt.h
index eead1088785e..75618af29d1b 100644
--- a/include/linux/sunrpc/svc_xprt.h
+++ b/include/linux/sunrpc/svc_xprt.h
@@ -82,6 +82,7 @@ struct svc_xprt {
 	size_t			xpt_locallen;	/* length of address */
 	struct sockaddr_storage	xpt_remote;	/* remote peer's address */
 	size_t			xpt_remotelen;	/* length of address */
+	char			xpt_remotebuf[INET6_ADDRSTRLEN + 10];
 	struct rpc_wait_queue	xpt_bc_pending;	/* backchannel wait queue */
 	struct list_head	xpt_users;	/* callbacks on free */
 
@@ -151,7 +152,10 @@ static inline void svc_xprt_set_remote(struct svc_xprt *xprt,
 {
 	memcpy(&xprt->xpt_remote, sa, salen);
 	xprt->xpt_remotelen = salen;
+	snprintf(xprt->xpt_remotebuf, sizeof(xprt->xpt_remotebuf) - 1,
+		 "%pISpc", sa);
 }
+
 static inline unsigned short svc_addr_port(const struct sockaddr *sa)
 {
 	const struct sockaddr_in *sin = (const struct sockaddr_in *)sa;
* Unmerged path include/trace/events/sunrpc.h
diff --git a/net/sunrpc/svc_xprt.c b/net/sunrpc/svc_xprt.c
index b60c1501c425..f58093ef4b7f 100644
--- a/net/sunrpc/svc_xprt.c
+++ b/net/sunrpc/svc_xprt.c
@@ -173,6 +173,7 @@ void svc_xprt_init(struct net *net, struct svc_xprt_class *xcl,
 	set_bit(XPT_BUSY, &xprt->xpt_flags);
 	rpc_init_wait_queue(&xprt->xpt_bc_pending, "xpt_bc_pending");
 	xprt->xpt_net = get_net(net);
+	strcpy(xprt->xpt_remotebuf, "uninitialized");
 }
 EXPORT_SYMBOL_GPL(svc_xprt_init);
 
@@ -899,12 +900,12 @@ int svc_send(struct svc_rqst *rqstp)
 		len = xprt->xpt_ops->xpo_sendto(rqstp);
 	mutex_unlock(&xprt->xpt_mutex);
 	rpc_wake_up(&xprt->xpt_bc_pending);
+	trace_svc_send(rqstp, len);
 	svc_xprt_release(rqstp);
 
 	if (len == -ECONNREFUSED || len == -ENOTCONN || len == -EAGAIN)
 		len = 0;
 out:
-	trace_svc_send(rqstp, len);
 	return len;
 }
 
diff --git a/net/sunrpc/svcsock.c b/net/sunrpc/svcsock.c
index 8150ebcac91f..52e324245269 100644
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@ -1325,6 +1325,7 @@ static void svc_tcp_init(struct svc_sock *svsk, struct svc_serv *serv)
 	set_bit(XPT_CONG_CTRL, &svsk->sk_xprt.xpt_flags);
 	if (sk->sk_state == TCP_LISTEN) {
 		dprintk("setting up TCP socket for listening\n");
+		strcpy(svsk->sk_xprt.xpt_remotebuf, "listener");
 		set_bit(XPT_LISTENER, &svsk->sk_xprt.xpt_flags);
 		sk->sk_data_ready = svc_tcp_listen_data_ready;
 		set_bit(XPT_CONN, &svsk->sk_xprt.xpt_flags);
diff --git a/net/sunrpc/xprtrdma/svc_rdma_transport.c b/net/sunrpc/xprtrdma/svc_rdma_transport.c
index 370bd2515e2f..f215ad548c97 100644
--- a/net/sunrpc/xprtrdma/svc_rdma_transport.c
+++ b/net/sunrpc/xprtrdma/svc_rdma_transport.c
@@ -401,8 +401,10 @@ static struct svcxprt_rdma *rdma_create_xprt(struct svc_serv *serv,
 	 */
 	set_bit(XPT_CONG_CTRL, &cma_xprt->sc_xprt.xpt_flags);
 
-	if (listener)
+	if (listener) {
+		strcpy(cma_xprt->sc_xprt.xpt_remotebuf, "listener");
 		set_bit(XPT_LISTENER, &cma_xprt->sc_xprt.xpt_flags);
+	}
 
 	return cma_xprt;
 }
