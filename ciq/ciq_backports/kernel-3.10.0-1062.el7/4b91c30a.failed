ovl: lookup connected ancestor of dir in inode cache

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 4b91c30a5a19332e8dd10b601d05b72caf657730
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/4b91c30a.failed

Decoding a dir file handle requires walking backward up to layer root and
for lower dir also checking the index to see if any of the parents have
been copied up.

Lookup overlay ancestor dentry in inode/dentry cache by decoded real
parents to shortcut looking up all the way back to layer root.

	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 4b91c30a5a19332e8dd10b601d05b72caf657730)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/export.c
#	fs/overlayfs/inode.c
#	fs/overlayfs/overlayfs.h
diff --cc fs/overlayfs/inode.c
index c5e691214402,fcd97b783fa1..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -688,6 -651,24 +694,27 @@@ static bool ovl_verify_inode(struct ino
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,
+ 			       bool is_upper)
+ {
+ 	struct inode *inode, *key = d_inode(real);
+ 
+ 	inode = ilookup5(sb, (unsigned long) key, ovl_inode_test, key);
+ 	if (!inode)
+ 		return NULL;
+ 
+ 	if (!ovl_verify_inode(inode, is_upper ? NULL : real,
+ 			      is_upper ? real : NULL, false)) {
+ 		iput(inode);
+ 		return ERR_PTR(-ESTALE);
+ 	}
+ 
+ 	return inode;
+ }
+ 
++>>>>>>> 4b91c30a5a19 (ovl: lookup connected ancestor of dir in inode cache)
  struct inode *ovl_get_inode(struct super_block *sb, struct dentry *upperdentry,
  			    struct dentry *lowerdentry, struct dentry *index,
  			    unsigned int numlower)
diff --cc fs/overlayfs/overlayfs.h
index 403c48960f89,bf17bf97c50f..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -289,6 -323,8 +289,11 @@@ int ovl_update_time(struct inode *inode
  bool ovl_is_private_xattr(const char *name);
  
  struct inode *ovl_new_inode(struct super_block *sb, umode_t mode, dev_t rdev);
++<<<<<<< HEAD
++=======
+ struct inode *ovl_lookup_inode(struct super_block *sb, struct dentry *real,
+ 			       bool is_upper);
++>>>>>>> 4b91c30a5a19 (ovl: lookup connected ancestor of dir in inode cache)
  struct inode *ovl_get_inode(struct super_block *sb, struct dentry *upperdentry,
  			    struct dentry *lowerdentry, struct dentry *index,
  			    unsigned int numlower);
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/export.c
* Unmerged path fs/overlayfs/inode.c
* Unmerged path fs/overlayfs/overlayfs.h
