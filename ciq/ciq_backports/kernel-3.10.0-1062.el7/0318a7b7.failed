net/mlx5e: Rx, Check ip headers sanity

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Rx, Check ip headers sanity (Alaa Hleihel) [1695493]
Rebuild_FUZZ: 94.44%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 0318a7b7fcad9765931146efa7ca3a034194737c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0318a7b7.failed

In the two places is_last_ethertype_ip is being called, the caller will
be looking inside the ip header, to be safe, add ip{4,6} header sanity
check. And return true only on valid ip headers, i.e: the whole header
is contained in the linear part of the skb.

Note: Such situation is very rare and hard to reproduce, since mlx5e
allocates a large enough headroom to contain the largest header one can
imagine.

Fixes: fe1dc069990c ("net/mlx5e: don't set CHECKSUM_COMPLETE on SCTP packets")
	Reported-by: Cong Wang <xiyou.wangcong@gmail.com>
	Reviewed-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 0318a7b7fcad9765931146efa7ca3a034194737c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
index 1f8a170c334f,36fd628188bc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
@@@ -635,12 -687,108 +635,26 @@@ static inline void mlx5e_skb_set_hash(s
  	skb_set_hash(skb, be32_to_cpu(cqe->rss_hash_result), ht);
  }
  
 -static inline bool is_last_ethertype_ip(struct sk_buff *skb, int *network_depth,
 -					__be16 *proto)
 +static inline bool is_last_ethertype_ip(struct sk_buff *skb, int *network_depth)
  {
++<<<<<<< HEAD
 +	__be16 ethertype = ((struct ethhdr *)skb->data)->h_proto;
++=======
+ 	*proto = ((struct ethhdr *)skb->data)->h_proto;
+ 	*proto = __vlan_get_protocol(skb, *proto, network_depth);
+ 
+ 	if (*proto == htons(ETH_P_IP))
+ 		return pskb_may_pull(skb, *network_depth + sizeof(struct iphdr));
+ 
+ 	if (*proto == htons(ETH_P_IPV6))
+ 		return pskb_may_pull(skb, *network_depth + sizeof(struct ipv6hdr));
+ 
+ 	return false;
+ }
++>>>>>>> 0318a7b7fcad (net/mlx5e: Rx, Check ip headers sanity)
  
 -static inline void mlx5e_enable_ecn(struct mlx5e_rq *rq, struct sk_buff *skb)
 -{
 -	int network_depth = 0;
 -	__be16 proto;
 -	void *ip;
 -	int rc;
 -
 -	if (unlikely(!is_last_ethertype_ip(skb, &network_depth, &proto)))
 -		return;
 -
 -	ip = skb->data + network_depth;
 -	rc = ((proto == htons(ETH_P_IP)) ? IP_ECN_set_ce((struct iphdr *)ip) :
 -					 IP6_ECN_set_ce(skb, (struct ipv6hdr *)ip));
 -
 -	rq->stats->ecn_mark += !!rc;
 -}
 -
 -static u8 get_ip_proto(struct sk_buff *skb, int network_depth, __be16 proto)
 -{
 -	void *ip_p = skb->data + network_depth;
 -
 -	return (proto == htons(ETH_P_IP)) ? ((struct iphdr *)ip_p)->protocol :
 -					    ((struct ipv6hdr *)ip_p)->nexthdr;
 -}
 -
 -#define short_frame(size) ((size) <= ETH_ZLEN + ETH_FCS_LEN)
 -
 -#define MAX_PADDING 8
 -
 -static void
 -tail_padding_csum_slow(struct sk_buff *skb, int offset, int len,
 -		       struct mlx5e_rq_stats *stats)
 -{
 -	stats->csum_complete_tail_slow++;
 -	skb->csum = csum_block_add(skb->csum,
 -				   skb_checksum(skb, offset, len, 0),
 -				   offset);
 -}
 -
 -static void
 -tail_padding_csum(struct sk_buff *skb, int offset,
 -		  struct mlx5e_rq_stats *stats)
 -{
 -	u8 tail_padding[MAX_PADDING];
 -	int len = skb->len - offset;
 -	void *tail;
 -
 -	if (unlikely(len > MAX_PADDING)) {
 -		tail_padding_csum_slow(skb, offset, len, stats);
 -		return;
 -	}
 -
 -	tail = skb_header_pointer(skb, offset, len, tail_padding);
 -	if (unlikely(!tail)) {
 -		tail_padding_csum_slow(skb, offset, len, stats);
 -		return;
 -	}
 -
 -	stats->csum_complete_tail++;
 -	skb->csum = csum_block_add(skb->csum, csum_partial(tail, len, 0), offset);
 -}
 -
 -static void
 -mlx5e_skb_padding_csum(struct sk_buff *skb, int network_depth, __be16 proto,
 -		       struct mlx5e_rq_stats *stats)
 -{
 -	struct ipv6hdr *ip6;
 -	struct iphdr   *ip4;
 -	int pkt_len;
 -
 -	switch (proto) {
 -	case htons(ETH_P_IP):
 -		ip4 = (struct iphdr *)(skb->data + network_depth);
 -		pkt_len = network_depth + ntohs(ip4->tot_len);
 -		break;
 -	case htons(ETH_P_IPV6):
 -		ip6 = (struct ipv6hdr *)(skb->data + network_depth);
 -		pkt_len = network_depth + sizeof(*ip6) + ntohs(ip6->payload_len);
 -		break;
 -	default:
 -		return;
 -	}
 -
 -	if (likely(pkt_len >= skb->len))
 -		return;
 -
 -	tail_padding_csum(skb, pkt_len, stats);
 +	ethertype = __vlan_get_protocol(skb, ethertype, network_depth);
 +	return (ethertype == htons(ETH_P_IP) || ethertype == htons(ETH_P_IPV6));
  }
  
  static inline void mlx5e_handle_csum(struct net_device *netdev,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
