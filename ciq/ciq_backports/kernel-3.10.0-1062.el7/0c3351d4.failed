seqlock: Use raw_ prefix instead of _no_lockdep

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
commit-author John Stultz <john.stultz@linaro.org>
commit 0c3351d451ae2fa438d5d1ed719fc43354fbffbb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/0c3351d4.failed

Linus disliked the _no_lockdep() naming, so instead
use the more-consistent raw_* prefix to the non-lockdep
enabled seqcount methods.

This also adds raw_ methods for the write operations
as well, which will be utilized in a following patch.

	Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
	Reviewed-by: Stephen Boyd <sboyd@codeaurora.org>
	Signed-off-by: John Stultz <john.stultz@linaro.org>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
	Cc: Krzysztof Hałasa <khalasa@piap.pl>
	Cc: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
	Cc: Willy Tarreau <w@1wt.eu>
Link: http://lkml.kernel.org/r/1388704274-5278-1-git-send-email-john.stultz@linaro.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 0c3351d451ae2fa438d5d1ed719fc43354fbffbb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/vdso/vclock_gettime.c
#	include/linux/seqlock.h
diff --cc arch/x86/vdso/vclock_gettime.c
index 7bd0b1186cc9,eb5d7a56f8d4..000000000000
--- a/arch/x86/vdso/vclock_gettime.c
+++ b/arch/x86/vdso/vclock_gettime.c
@@@ -184,7 -178,7 +184,11 @@@ notrace static int __always_inline do_r
  
  	ts->tv_nsec = 0;
  	do {
++<<<<<<< HEAD
 +		seq = read_seqcount_begin(&gtod->seq);
++=======
+ 		seq = raw_read_seqcount_begin(&gtod->seq);
++>>>>>>> 0c3351d451ae (seqlock: Use raw_ prefix instead of _no_lockdep)
  		mode = gtod->clock.vclock_mode;
  		ts->tv_sec = gtod->wall_time_sec;
  		ns = gtod->wall_time_snsec;
@@@ -204,7 -198,7 +208,11 @@@ notrace static int do_monotonic(struct 
  
  	ts->tv_nsec = 0;
  	do {
++<<<<<<< HEAD
 +		seq = read_seqcount_begin(&gtod->seq);
++=======
+ 		seq = raw_read_seqcount_begin(&gtod->seq);
++>>>>>>> 0c3351d451ae (seqlock: Use raw_ prefix instead of _no_lockdep)
  		mode = gtod->clock.vclock_mode;
  		ts->tv_sec = gtod->monotonic_time_sec;
  		ns = gtod->monotonic_time_snsec;
@@@ -220,7 -214,7 +228,11 @@@ notrace static int do_realtime_coarse(s
  {
  	unsigned long seq;
  	do {
++<<<<<<< HEAD
 +		seq = read_seqcount_begin(&gtod->seq);
++=======
+ 		seq = raw_read_seqcount_begin(&gtod->seq);
++>>>>>>> 0c3351d451ae (seqlock: Use raw_ prefix instead of _no_lockdep)
  		ts->tv_sec = gtod->wall_time_coarse.tv_sec;
  		ts->tv_nsec = gtod->wall_time_coarse.tv_nsec;
  	} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));
@@@ -231,7 -225,7 +243,11 @@@ notrace static int do_monotonic_coarse(
  {
  	unsigned long seq;
  	do {
++<<<<<<< HEAD
 +		seq = read_seqcount_begin(&gtod->seq);
++=======
+ 		seq = raw_read_seqcount_begin(&gtod->seq);
++>>>>>>> 0c3351d451ae (seqlock: Use raw_ prefix instead of _no_lockdep)
  		ts->tv_sec = gtod->monotonic_time_coarse.tv_sec;
  		ts->tv_nsec = gtod->monotonic_time_coarse.tv_nsec;
  	} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));
diff --cc include/linux/seqlock.h
index 48f2f69e3867,535f158977b9..000000000000
--- a/include/linux/seqlock.h
+++ b/include/linux/seqlock.h
@@@ -83,17 -117,17 +83,29 @@@ repeat
  }
  
  /**
++<<<<<<< HEAD
 + * raw_read_seqcount - Read the raw seqcount
 + * @s: pointer to seqcount_t
 + * Returns: count to be passed to read_seqcount_retry
 + *
 + * raw_read_seqcount opens a read critical section of the given
 + * seqcount without any lockdep checking and without checking or
 + * masking the LSB. Calling code is responsible for handling that.
 + */
 +static inline unsigned raw_read_seqcount(const seqcount_t *s)
++=======
+  * raw_read_seqcount_begin - start seq-read critical section w/o lockdep
+  * @s: pointer to seqcount_t
+  * Returns: count to be passed to read_seqcount_retry
+  *
+  * raw_read_seqcount_begin opens a read critical section of the given
+  * seqcount, but without any lockdep checking. Validity of the critical
+  * section is tested by checking read_seqcount_retry function.
+  */
+ static inline unsigned raw_read_seqcount_begin(const seqcount_t *s)
++>>>>>>> 0c3351d451ae (seqlock: Use raw_ prefix instead of _no_lockdep)
  {
 -	unsigned ret = __read_seqcount_begin(s);
 +	unsigned ret = READ_ONCE(s->sequence);
  	smp_rmb();
  	return ret;
  }
@@@ -109,9 -143,8 +121,14 @@@
   */
  static inline unsigned read_seqcount_begin(const seqcount_t *s)
  {
++<<<<<<< HEAD
 +	unsigned ret = __read_seqcount_begin(s);
 +	smp_rmb();
 +	return ret;
++=======
+ 	seqcount_lockdep_reader_access(s);
+ 	return raw_read_seqcount_begin(s);
++>>>>>>> 0c3351d451ae (seqlock: Use raw_ prefix instead of _no_lockdep)
  }
  
  /**
@@@ -171,31 -206,38 +188,59 @@@ static inline int read_seqcount_retry(c
  }
  
  
+ 
+ static inline void raw_write_seqcount_begin(seqcount_t *s)
+ {
+ 	s->sequence++;
+ 	smp_wmb();
+ }
+ 
+ static inline void raw_write_seqcount_end(seqcount_t *s)
+ {
+ 	smp_wmb();
+ 	s->sequence++;
+ }
+ 
 +/*
 + * raw_write_seqcount_latch - redirect readers to even/odd copy
 + * @s: pointer to seqcount_t
 + */
 +static inline void raw_write_seqcount_latch(seqcount_t *s)
 +{
 +       smp_wmb();      /* prior stores before incrementing "sequence" */
 +       s->sequence++;
 +       smp_wmb();      /* increment "sequence" before following stores */
 +}
 +
  /*
   * Sequence counter only version assumes that callers are using their
   * own mutexing.
   */
 -static inline void write_seqcount_begin_nested(seqcount_t *s, int subclass)
 +static inline void write_seqcount_begin(seqcount_t *s)
  {
++<<<<<<< HEAD
 +	s->sequence++;
 +	smp_wmb();
++=======
+ 	raw_write_seqcount_begin(s);
+ 	seqcount_acquire(&s->dep_map, subclass, 0, _RET_IP_);
+ }
+ 
+ static inline void write_seqcount_begin(seqcount_t *s)
+ {
+ 	write_seqcount_begin_nested(s, 0);
++>>>>>>> 0c3351d451ae (seqlock: Use raw_ prefix instead of _no_lockdep)
  }
  
  static inline void write_seqcount_end(seqcount_t *s)
  {
++<<<<<<< HEAD
 +	smp_wmb();
 +	s->sequence++;
++=======
+ 	seqcount_release(&s->dep_map, 1, _RET_IP_);
+ 	raw_write_seqcount_end(s);
++>>>>>>> 0c3351d451ae (seqlock: Use raw_ prefix instead of _no_lockdep)
  }
  
  /**
* Unmerged path arch/x86/vdso/vclock_gettime.c
* Unmerged path include/linux/seqlock.h
