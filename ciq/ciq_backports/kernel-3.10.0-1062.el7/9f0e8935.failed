PCI: Match Root Port's MPS to endpoint's MPSS as necessary

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1062.el7
Rebuild_CHGLOG: - [pci] Match Root Port's MPS to endpoint's MPSS as necessary (Myron Stowe) [1524000]
Rebuild_FUZZ: 95.50%
commit-author Myron Stowe <myron.stowe@redhat.com>
commit 9f0e89359775ee21fe1ea732e34edb52aef5addf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1062.el7/9f0e8935.failed

In commit 27d868b5e6cf ("PCI: Set MPS to match upstream bridge"), we made
sure every device's MPS setting matches its upstream bridge, making it more
likely that a hot-added device will work in a system with an optimized MPS
configuration.

Recently I've started encountering systems where the endpoint device's MPSS
capability is less than its Root Port's current MPS value, thus the
endpoint is not capable of matching its upstream bridge's MPS setting (see:
bugzilla via "Link:" below).  This leaves the system vulnerable - the
upstream Root Port could respond with larger TLPs than the device can
handle, and the device will consider them to be 'Malformed'.

One could use the "pci=pcie_bus_safe" kernel parameter to work around the
issue, but that forces a user to supply a kernel parameter to get the
system to function reliably and may end up limiting MPS settings of other
unrelated, sub-topologies which could benefit from maintaining their larger
values.

Augment Keith's approach to include tuning down a Root Port's MPS setting
when its hot-added endpoint device is not capable of matching it.

Link: https://bugzilla.kernel.org/show_bug.cgi?id=200527
	Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Acked-by: Jon Mason <jdmason@kudzu.us>
	Cc: Keith Busch <keith.busch@intel.com>
	Cc: Sinan Kaya <okaya@kernel.org>
	Cc: Dongdong Liu <liudongdong3@huawei.com>
(cherry picked from commit 9f0e89359775ee21fe1ea732e34edb52aef5addf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/probe.c
diff --cc drivers/pci/probe.c
index 59a917b162c7,bca6d2741969..000000000000
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@@ -1464,15 -1753,23 +1464,28 @@@ static void pci_configure_mps(struct pc
  	if (pcie_bus_config != PCIE_BUS_DEFAULT)
  		return;
  
+ 	mpss = 128 << dev->pcie_mpss;
+ 	if (mpss < p_mps && pci_pcie_type(bridge) == PCI_EXP_TYPE_ROOT_PORT) {
+ 		pcie_set_mps(bridge, mpss);
+ 		pci_info(dev, "Upstream bridge's Max Payload Size set to %d (was %d, max %d)\n",
+ 			 mpss, p_mps, 128 << bridge->pcie_mpss);
+ 		p_mps = pcie_get_mps(bridge);
+ 	}
+ 
  	rc = pcie_set_mps(dev, p_mps);
  	if (rc) {
 -		pci_warn(dev, "can't set Max Payload Size to %d; if necessary, use \"pci=pcie_bus_safe\" and report a bug\n",
 +		dev_warn(&dev->dev, "can't set Max Payload Size to %d; if necessary, use \"pci=pcie_bus_safe\" and report a bug\n",
  			 p_mps);
  		return;
  	}
  
++<<<<<<< HEAD
 +	dev_info(&dev->dev, "Max Payload Size set to %d (was %d, max %d)\n",
 +		 p_mps, mps, 128 << dev->pcie_mpss);
++=======
+ 	pci_info(dev, "Max Payload Size set to %d (was %d, max %d)\n",
+ 		 p_mps, mps, mpss);
++>>>>>>> 9f0e89359775 (PCI: Match Root Port's MPS to endpoint's MPSS as necessary)
  }
  
  static struct hpp_type0 pci_default_type0 = {
* Unmerged path drivers/pci/probe.c
