nvme-multipath: fix io accounting on failover

jira LE-2015
Rebuild_History Non-Buildable kernel-5.14.0-427.42.1.el9_4
commit-author Keith Busch <kbusch@kernel.org>
commit a2e4c5f5f68dbd206f132bc709b98dea64afc3b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-5.14.0-427.42.1.el9_4/a2e4c5f5.failed

There are io stats accounting that needs to be handled, so don't call
blk_mq_end_request() directly. Use the existing nvme_end_req() helper
that already handles everything.

Fixes: d4d957b53d91ee ("nvme-multipath: support io stats on the mpath device")
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Keith Busch <kbusch@kernel.org>
(cherry picked from commit a2e4c5f5f68dbd206f132bc709b98dea64afc3b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/nvme.h
diff --cc drivers/nvme/host/nvme.h
index a7b00be1e451,fc31bd340a63..000000000000
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@@ -722,6 -746,28 +722,31 @@@ static inline bool nvme_is_aen_req(u16 
  		nvme_tag_from_cid(command_id) >= NVME_AQ_BLK_MQ_DEPTH;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Returns true for sink states that can't ever transition back to live.
+  */
+ static inline bool nvme_state_terminal(struct nvme_ctrl *ctrl)
+ {
+ 	switch (nvme_ctrl_state(ctrl)) {
+ 	case NVME_CTRL_NEW:
+ 	case NVME_CTRL_LIVE:
+ 	case NVME_CTRL_RESETTING:
+ 	case NVME_CTRL_CONNECTING:
+ 		return false;
+ 	case NVME_CTRL_DELETING:
+ 	case NVME_CTRL_DELETING_NOIO:
+ 	case NVME_CTRL_DEAD:
+ 		return true;
+ 	default:
+ 		WARN_ONCE(1, "Unhandled ctrl state:%d", ctrl->state);
+ 		return true;
+ 	}
+ }
+ 
+ void nvme_end_req(struct request *req);
++>>>>>>> a2e4c5f5f68d (nvme-multipath: fix io accounting on failover)
  void nvme_complete_rq(struct request *req);
  void nvme_complete_batch_req(struct request *req);
  
diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index 93dd6cfe54ab..9b4c0a3de0b2 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -382,7 +382,7 @@ static inline void nvme_end_req_zoned(struct request *req)
 			le64_to_cpu(nvme_req(req)->result.u64));
 }
 
-static inline void nvme_end_req(struct request *req)
+void nvme_end_req(struct request *req)
 {
 	blk_status_t status = nvme_error_status(nvme_req(req)->status);
 
diff --git a/drivers/nvme/host/multipath.c b/drivers/nvme/host/multipath.c
index 2adfdb3a135f..a5e6d7f4088c 100644
--- a/drivers/nvme/host/multipath.c
+++ b/drivers/nvme/host/multipath.c
@@ -124,7 +124,8 @@ void nvme_failover_req(struct request *req)
 	blk_steal_bios(&ns->head->requeue_list, req);
 	spin_unlock_irqrestore(&ns->head->requeue_lock, flags);
 
-	blk_mq_end_request(req, 0);
+	nvme_req(req)->status = 0;
+	nvme_end_req(req);
 	kblockd_schedule_work(&ns->head->requeue_work);
 }
 
* Unmerged path drivers/nvme/host/nvme.h
