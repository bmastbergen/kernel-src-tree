gfs2: Fix gfs2_testbit to use clone bitmaps

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.53.1.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit dffe12a82826082d2129ef91b17b257254cb60fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.53.1.el7/dffe12a8.failed

Function gfs2_testbit is called in three places. Two of those places,
gfs2_alloc_extent and gfs2_unaligned_extlen, should be using the clone
bitmaps, not the "real" bitmaps. Function gfs2_unaligned_extlen is used
by the block reservations scheme to determine the length of an extent of
free blocks. Before this patch, it wasn't using the clone bitmap, which
means recently-freed blocks were treated as free blocks for the purposes
of an allocation.

This patch adds a new parameter to gfs2_testbit to indicate whether or
not the clone bitmaps should be used (if available).

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Reviewed-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit dffe12a82826082d2129ef91b17b257254cb60fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/rgrp.c
diff --cc fs/gfs2/rgrp.c
index eebb1e1cfe40,ef50fe9b880a..000000000000
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@@ -125,9 -131,10 +129,14 @@@ static inline void gfs2_setbit(const st
   * Returns: The two bit block state of the requested bit
   */
  
- static inline u8 gfs2_testbit(const struct gfs2_rbm *rbm)
+ static inline u8 gfs2_testbit(const struct gfs2_rbm *rbm, bool use_clone)
  {
++<<<<<<< HEAD
 +	const u8 *buffer = rbm->bi->bi_bh->b_data + rbm->bi->bi_offset;
++=======
+ 	struct gfs2_bitmap *bi = rbm_bi(rbm);
+ 	const u8 *buffer;
++>>>>>>> dffe12a82826 (gfs2: Fix gfs2_testbit to use clone bitmaps)
  	const u8 *byte;
  	unsigned int bit;
  
@@@ -2125,9 -2179,9 +2119,9 @@@ static void gfs2_alloc_extent(const str
  	block++;
  	while (*n < elen) {
  		ret = gfs2_rbm_from_block(&pos, block);
- 		if (ret || gfs2_testbit(&pos) != GFS2_BLKST_FREE)
+ 		if (ret || gfs2_testbit(&pos, true) != GFS2_BLKST_FREE)
  			break;
 -		gfs2_trans_add_meta(pos.rgd->rd_gl, rbm_bi(&pos)->bi_bh);
 +		gfs2_trans_add_meta(pos.rgd->rd_gl, pos.bi->bi_bh);
  		gfs2_setbit(&pos, true, GFS2_BLKST_USED);
  		(*n)++;
  		block++;
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1f6f222b6802..dbe52cee8bb2 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -65,6 +65,27 @@ struct gfs2_log_operations {
 
 #define GBF_FULL 1
 
+/**
+ * Clone bitmaps (bi_clone):
+ *
+ * - When a block is freed, we remember the previous state of the block in the
+ *   clone bitmap, and only mark the block as free in the real bitmap.
+ *
+ * - When looking for a block to allocate, we check for a free block in the
+ *   clone bitmap, and if no clone bitmap exists, in the real bitmap.
+ *
+ * - For allocating a block, we mark it as allocated in the real bitmap, and if
+ *   a clone bitmap exists, also in the clone bitmap.
+ *
+ * - At the end of a log_flush, we copy the real bitmap into the clone bitmap
+ *   to make the clone bitmap reflect the current allocation state.
+ *   (Alternatively, we could remove the clone bitmap.)
+ *
+ * The clone bitmaps are in-core only, and is never written to disk.
+ *
+ * These steps ensure that blocks which have been freed in a transaction cannot
+ * be reallocated in that same transaction.
+ */
 struct gfs2_bitmap {
 	struct buffer_head *bi_bh;
 	char *bi_clone;
* Unmerged path fs/gfs2/rgrp.c
