gfs2: clean up iopen glock mess in gfs2_create_inode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.53.1.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit 2c47c1be51fbded1f7baa2ceaed90f97932f79be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.53.1.el7/2c47c1be.failed

Before this patch, gfs2_create_inode had a use-after-free for the
iopen glock in some error paths because it did this:

	gfs2_glock_put(io_gl);
fail_gunlock2:
	if (io_gl)
		clear_bit(GLF_INODE_CREATING, &io_gl->gl_flags);

In some cases, the io_gl was used for create and only had one
reference, so the glock might be freed before the clear_bit().
This patch tries to straighten it out by only jumping to the
error paths where iopen is properly set, and moving the
gfs2_glock_put after the clear_bit.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 2c47c1be51fbded1f7baa2ceaed90f97932f79be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/inode.c
diff --cc fs/gfs2/inode.c
index a28a52c4fd86,4a1039c41c69..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -660,10 -710,14 +660,10 @@@ static int gfs2_create_inode(struct ino
  	if (error)
  		goto fail_free_inode;
  
 -	error = gfs2_trans_begin(sdp, blocks, 0);
 +	error = gfs2_trans_begin(sdp, RES_DINODE, 0);
  	if (error)
- 		goto fail_gunlock2;
+ 		goto fail_free_inode;
  
 -	if (blocks > 1) {
 -		ip->i_eattr = ip->i_no_addr + 1;
 -		gfs2_init_xattr(ip);
 -	}
  	init_dinode(dip, ip, symname);
  	gfs2_trans_end(sdp);
  
@@@ -677,8 -731,7 +677,12 @@@
  	if (error)
  		goto fail_gunlock2;
  
++<<<<<<< HEAD
 +	glock_set_object(io_gl, ip);
 +	gfs2_glock_put(io_gl);
++=======
+ 	glock_set_object(ip->i_iopen_gh.gh_gl, ip);
++>>>>>>> 2c47c1be51fb (gfs2: clean up iopen glock mess in gfs2_create_inode)
  	gfs2_set_iop(inode);
  	insert_inode_hash(inode);
  
@@@ -700,15 -764,16 +704,21 @@@
  
  	mark_inode_dirty(inode);
  	d_instantiate(dentry, inode);
+ 	/* After instantiate, errors should result in evict which will destroy
+ 	 * both inode and iopen glocks properly. */
  	if (file) {
 -		file->f_mode |= FMODE_CREATED;
 -		error = finish_open(file, dentry, gfs2_open_common);
 +		*opened |= FILE_CREATED;
 +		error = finish_open(file, dentry, gfs2_open_common, opened);
  	}
  	gfs2_glock_dq_uninit(ghs);
 +	gfs2_qa_put(ip);
  	gfs2_glock_dq_uninit(ghs + 1);
  	clear_bit(GLF_INODE_CREATING, &io_gl->gl_flags);
++<<<<<<< HEAD
 +	gfs2_qa_put(dip);
++=======
+ 	gfs2_glock_put(io_gl);
++>>>>>>> 2c47c1be51fb (gfs2: clean up iopen glock mess in gfs2_create_inode)
  	return error;
  
  fail_gunlock3:
* Unmerged path fs/gfs2/inode.c
