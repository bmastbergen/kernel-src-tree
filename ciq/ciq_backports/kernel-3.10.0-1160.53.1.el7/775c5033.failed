fuse: fix live lock in fuse_iget()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.53.1.el7
commit-author Amir Goldstein <amir73il@gmail.com>
commit 775c5033a0d164622d9d10dd0f0a5531639ed3ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.53.1.el7/775c5033.failed

Commit 5d069dbe8aaf ("fuse: fix bad inode") replaced make_bad_inode()
in fuse_iget() with a private implementation fuse_make_bad().

The private implementation fails to remove the bad inode from inode
cache, so the retry loop with iget5_locked() finds the same bad inode
and marks it bad forever.

kmsg snip:

[ ] rcu: INFO: rcu_sched self-detected stall on CPU
...
[ ]  ? bit_wait_io+0x50/0x50
[ ]  ? fuse_init_file_inode+0x70/0x70
[ ]  ? find_inode.isra.32+0x60/0xb0
[ ]  ? fuse_init_file_inode+0x70/0x70
[ ]  ilookup5_nowait+0x65/0x90
[ ]  ? fuse_init_file_inode+0x70/0x70
[ ]  ilookup5.part.36+0x2e/0x80
[ ]  ? fuse_init_file_inode+0x70/0x70
[ ]  ? fuse_inode_eq+0x20/0x20
[ ]  iget5_locked+0x21/0x80
[ ]  ? fuse_inode_eq+0x20/0x20
[ ]  fuse_iget+0x96/0x1b0

Fixes: 5d069dbe8aaf ("fuse: fix bad inode")
	Cc: stable@vger.kernel.org # 5.10+
	Signed-off-by: Amir Goldstein <amir73il@gmail.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 775c5033a0d164622d9d10dd0f0a5531639ed3ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/fuse_i.h
diff --cc fs/fuse/fuse_i.h
index 5ecda7763980,63d97a15ffde..000000000000
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@@ -634,6 -851,27 +634,30 @@@ static inline u64 get_node_id(struct in
  	return get_fuse_inode(inode)->nodeid;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int invalid_nodeid(u64 nodeid)
+ {
+ 	return !nodeid || nodeid == FUSE_ROOT_ID;
+ }
+ 
+ static inline u64 fuse_get_attr_version(struct fuse_conn *fc)
+ {
+ 	return atomic64_read(&fc->attr_version);
+ }
+ 
+ static inline void fuse_make_bad(struct inode *inode)
+ {
+ 	remove_inode_hash(inode);
+ 	set_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state);
+ }
+ 
+ static inline bool fuse_is_bad(struct inode *inode)
+ {
+ 	return unlikely(test_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state));
+ }
+ 
++>>>>>>> 775c5033a0d1 (fuse: fix live lock in fuse_iget())
  /** Device operations */
  extern const struct file_operations fuse_dev_operations;
  
* Unmerged path fs/fuse/fuse_i.h
