fuse: fix bad inode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.53.1.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 5d069dbe8aaf2a197142558b6fb2978189ba3454
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.53.1.el7/5d069dbe.failed

Jan Kara's analysis of the syzbot report (edited):

  The reproducer opens a directory on FUSE filesystem, it then attaches
  dnotify mark to the open directory.  After that a fuse_do_getattr() call
  finds that attributes returned by the server are inconsistent, and calls
  make_bad_inode() which, among other things does:

          inode->i_mode = S_IFREG;

  This then confuses dnotify which doesn't tear down its structures
  properly and eventually crashes.

Avoid calling make_bad_inode() on a live inode: switch to a private flag on
the fuse inode.  Also add the test to ops which the bad_inode_ops would
have caught.

This bug goes back to the initial merge of fuse in 2.6.14...

	Reported-by: syzbot+f427adf9324b92652ccc@syzkaller.appspotmail.com
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
	Tested-by: Jan Kara <jack@suse.cz>
	Cc: <stable@vger.kernel.org>
(cherry picked from commit 5d069dbe8aaf2a197142558b6fb2978189ba3454)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fuse/acl.c
#	fs/fuse/dir.c
#	fs/fuse/file.c
#	fs/fuse/fuse_i.h
#	fs/fuse/inode.c
#	fs/fuse/readdir.c
#	fs/fuse/xattr.c
diff --cc fs/fuse/dir.c
index 7edcb6424cc9,78f9f209078c..000000000000
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@@ -195,14 -201,13 +195,19 @@@ static int fuse_dentry_revalidate(struc
  	struct fuse_inode *fi;
  	int ret;
  
++<<<<<<< HEAD
 +	inode = ACCESS_ONCE(entry->d_inode);
 +	if (inode && is_bad_inode(inode))
++=======
+ 	inode = d_inode_rcu(entry);
+ 	if (inode && fuse_is_bad(inode))
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  		goto invalid;
  	else if (time_before64(fuse_dentry_time(entry), get_jiffies_64()) ||
 -		 (flags & (LOOKUP_EXCL | LOOKUP_REVAL))) {
 +		 (flags & LOOKUP_REVAL)) {
 +		int err;
  		struct fuse_entry_out outarg;
 -		FUSE_ARGS(args);
 +		struct fuse_req *req;
  		struct fuse_forget_link *forget;
  		u64 attr_version;
  
@@@ -358,9 -460,15 +363,16 @@@ static struct dentry *fuse_lookup(struc
  	struct inode *inode;
  	struct dentry *newent;
  	bool outarg_valid = true;
 -	bool locked;
  
++<<<<<<< HEAD
++=======
+ 	if (fuse_is_bad(dir))
+ 		return ERR_PTR(-EIO);
+ 
+ 	locked = fuse_lock_inode(dir);
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  	err = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,
  			       &outarg, &inode);
 -	fuse_unlock_inode(dir, locked);
  	if (err == -ENOENT) {
  		outarg_valid = false;
  		err = 0;
@@@ -509,7 -614,10 +521,14 @@@ static int fuse_atomic_open(struct inod
  	struct fuse_conn *fc = get_fuse_conn(dir);
  	struct dentry *res = NULL;
  
++<<<<<<< HEAD
 +	if (d_unhashed(entry)) {
++=======
+ 	if (fuse_is_bad(dir))
+ 		return -EIO;
+ 
+ 	if (d_in_lookup(entry)) {
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  		res = fuse_lookup(dir, entry, 0);
  		if (IS_ERR(res))
  			return PTR_ERR(res);
@@@ -556,23 -664,20 +575,26 @@@ static int create_new_entry(struct fuse
  	int err;
  	struct fuse_forget_link *forget;
  
+ 	if (fuse_is_bad(dir))
+ 		return -EIO;
+ 
  	forget = fuse_alloc_forget();
 -	if (!forget)
 +	if (!forget) {
 +		fuse_put_request(fc, req);
  		return -ENOMEM;
 +	}
  
  	memset(&outarg, 0, sizeof(outarg));
 -	args->nodeid = get_node_id(dir);
 -	args->out_numargs = 1;
 -	args->out_args[0].size = sizeof(outarg);
 -	args->out_args[0].value = &outarg;
 -	err = fuse_simple_request(fm, args);
 +	req->in.h.nodeid = get_node_id(dir);
 +	req->out.numargs = 1;
 +	if (fc->minor < 9)
 +		req->out.args[0].size = FUSE_COMPAT_ENTRY_OUT_SIZE;
 +	else
 +		req->out.args[0].size = sizeof(outarg);
 +	req->out.args[0].value = &outarg;
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
 +	fuse_put_request(fc, req);
  	if (err)
  		goto out_put_forget_req;
  
@@@ -688,25 -792,24 +710,37 @@@ static inline void fuse_update_ctime(st
  static int fuse_unlink(struct inode *dir, struct dentry *entry)
  {
  	int err;
 -	struct fuse_mount *fm = get_fuse_mount(dir);
 -	FUSE_ARGS(args);
 -
 +	struct fuse_conn *fc = get_fuse_conn(dir);
 +	struct fuse_req *req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +
++<<<<<<< HEAD
 +	req->in.h.opcode = FUSE_UNLINK;
 +	req->in.h.nodeid = get_node_id(dir);
 +	req->in.numargs = 1;
 +	req->in.args[0].size = entry->d_name.len + 1;
 +	req->in.args[0].value = entry->d_name.name;
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
 +	fuse_put_request(fc, req);
++=======
+ 	if (fuse_is_bad(dir))
+ 		return -EIO;
+ 
+ 	args.opcode = FUSE_UNLINK;
+ 	args.nodeid = get_node_id(dir);
+ 	args.in_numargs = 1;
+ 	args.in_args[0].size = entry->d_name.len + 1;
+ 	args.in_args[0].value = entry->d_name.name;
+ 	err = fuse_simple_request(fm, &args);
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  	if (!err) {
 -		struct inode *inode = d_inode(entry);
 +		struct inode *inode = entry->d_inode;
  		struct fuse_inode *fi = get_fuse_inode(inode);
  
 -		spin_lock(&fi->lock);
 -		fi->attr_version = atomic64_inc_return(&fm->fc->attr_version);
 +		spin_lock(&fc->lock);
 +		fi->attr_version = ++fc->attr_version;
  		/*
  		 * If i_nlink == 0 then unlink doesn't make sense, yet this can
  		 * happen if userspace filesystem is careless.  It would be
@@@ -728,22 -831,21 +762,34 @@@
  static int fuse_rmdir(struct inode *dir, struct dentry *entry)
  {
  	int err;
 -	struct fuse_mount *fm = get_fuse_mount(dir);
 -	FUSE_ARGS(args);
 -
 +	struct fuse_conn *fc = get_fuse_conn(dir);
 +	struct fuse_req *req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +
++<<<<<<< HEAD
 +	req->in.h.opcode = FUSE_RMDIR;
 +	req->in.h.nodeid = get_node_id(dir);
 +	req->in.numargs = 1;
 +	req->in.args[0].size = entry->d_name.len + 1;
 +	req->in.args[0].value = entry->d_name.name;
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
 +	fuse_put_request(fc, req);
++=======
+ 	if (fuse_is_bad(dir))
+ 		return -EIO;
+ 
+ 	args.opcode = FUSE_RMDIR;
+ 	args.nodeid = get_node_id(dir);
+ 	args.in_numargs = 1;
+ 	args.in_args[0].size = entry->d_name.len + 1;
+ 	args.in_args[0].value = entry->d_name.name;
+ 	err = fuse_simple_request(fm, &args);
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  	if (!err) {
 -		clear_nlink(d_inode(entry));
 -		fuse_dir_changed(dir);
 +		clear_nlink(entry->d_inode);
 +		fuse_invalidate_attr(dir);
  		fuse_invalidate_entry_cache(entry);
  	} else if (err == -EINTR)
  		fuse_invalidate_entry(entry);
@@@ -818,7 -915,10 +864,14 @@@ static int fuse_rename2(struct inode *o
  	struct fuse_conn *fc = get_fuse_conn(olddir);
  	int err;
  
++<<<<<<< HEAD
 +	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))
++=======
+ 	if (fuse_is_bad(olddir))
+ 		return -EIO;
+ 
+ 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  		return -EINVAL;
  
  	if (flags) {
@@@ -954,23 -1041,19 +1007,29 @@@ static int fuse_do_getattr(struct inod
  		inarg.getattr_flags |= FUSE_GETATTR_FH;
  		inarg.fh = ff->fh;
  	}
 -	args.opcode = FUSE_GETATTR;
 -	args.nodeid = get_node_id(inode);
 -	args.in_numargs = 1;
 -	args.in_args[0].size = sizeof(inarg);
 -	args.in_args[0].value = &inarg;
 -	args.out_numargs = 1;
 -	args.out_args[0].size = sizeof(outarg);
 -	args.out_args[0].value = &outarg;
 -	err = fuse_simple_request(fm, &args);
 +	req->in.h.opcode = FUSE_GETATTR;
 +	req->in.h.nodeid = get_node_id(inode);
 +	req->in.numargs = 1;
 +	req->in.args[0].size = sizeof(inarg);
 +	req->in.args[0].value = &inarg;
 +	req->out.numargs = 1;
 +	if (fc->minor < 9)
 +		req->out.args[0].size = FUSE_COMPAT_ATTR_OUT_SIZE;
 +	else
 +		req->out.args[0].size = sizeof(outarg);
 +	req->out.args[0].value = &outarg;
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
 +	fuse_put_request(fc, req);
  	if (!err) {
++<<<<<<< HEAD
 +		if ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
 +			make_bad_inode(inode);
++=======
+ 		if (fuse_invalid_attr(&outarg.attr) ||
+ 		    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
+ 			fuse_make_bad(inode);
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  			err = -EIO;
  		} else {
  			fuse_change_attributes(inode, &outarg.attr,
@@@ -1244,265 -1345,41 +1306,288 @@@ static int parse_dirfile(char *buf, siz
  	return 0;
  }
  
 -static const char *fuse_get_link(struct dentry *dentry, struct inode *inode,
 -				 struct delayed_call *callback)
 +static int fuse_direntplus_link(struct file *file,
 +				struct fuse_direntplus *direntplus,
 +				u64 attr_version)
  {
 -	struct fuse_conn *fc = get_fuse_conn(inode);
 -	struct page *page;
  	int err;
 +	struct fuse_entry_out *o = &direntplus->entry_out;
 +	struct fuse_dirent *dirent = &direntplus->dirent;
 +	struct dentry *parent = file->f_path.dentry;
 +	struct qstr name = QSTR_INIT(dirent->name, dirent->namelen);
 +	struct dentry *dentry;
 +	struct dentry *alias;
 +	struct inode *dir = parent->d_inode;
 +	struct fuse_conn *fc;
 +	struct inode *inode;
  
++<<<<<<< HEAD
 +	if (!o->nodeid) {
 +		/*
 +		 * Unlike in the case of fuse_lookup, zero nodeid does not mean
 +		 * ENOENT. Instead, it only means the userspace filesystem did
 +		 * not want to return attributes/handle for this entry.
 +		 *
 +		 * So do nothing.
 +		 */
 +		return 0;
++=======
+ 	err = -EIO;
+ 	if (fuse_is_bad(inode))
+ 		goto out_err;
+ 
+ 	if (fc->cache_symlinks)
+ 		return page_get_link(dentry, inode, callback);
+ 
+ 	err = -ECHILD;
+ 	if (!dentry)
+ 		goto out_err;
+ 
+ 	page = alloc_page(GFP_KERNEL);
+ 	err = -ENOMEM;
+ 	if (!page)
+ 		goto out_err;
+ 
+ 	err = fuse_readlink_page(inode, page);
+ 	if (err) {
+ 		__free_page(page);
+ 		goto out_err;
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  	}
  
 -	set_delayed_call(callback, page_put_link, page);
 +	if (name.name[0] == '.') {
 +		/*
 +		 * We could potentially refresh the attributes of the directory
 +		 * and its parent?
 +		 */
 +		if (name.len == 1)
 +			return 0;
 +		if (name.name[1] == '.' && name.len == 2)
 +			return 0;
 +	}
  
 -	return page_address(page);
 +	if (invalid_nodeid(o->nodeid))
 +		return -EIO;
 +	if (!fuse_valid_type(o->attr.mode))
 +		return -EIO;
  
 -out_err:
 -	return ERR_PTR(err);
 +	fc = get_fuse_conn(dir);
 +
 +	name.hash = full_name_hash(name.name, name.len);
 +	dentry = d_lookup(parent, &name);
 +	if (dentry) {
 +		inode = dentry->d_inode;
 +		if (!inode) {
 +			d_drop(dentry);
 +		} else if (get_node_id(inode) != o->nodeid ||
 +			   ((o->attr.mode ^ inode->i_mode) & S_IFMT)) {
 +			err = d_invalidate(dentry);
 +			if (err)
 +				goto out;
 +		} else if (is_bad_inode(inode)) {
 +			err = -EIO;
 +			goto out;
 +		} else {
 +			struct fuse_inode *fi;
 +			fi = get_fuse_inode(inode);
 +			spin_lock(&fc->lock);
 +			fi->nlookup++;
 +			spin_unlock(&fc->lock);
 +
 +			fuse_change_attributes(inode, &o->attr,
 +					       entry_attr_timeout(o),
 +					       attr_version);
 +
 +			/*
 +			 * The other branch to 'found' comes via fuse_iget()
 +			 * which bumps nlookup inside
 +			 */
 +			goto found;
 +		}
 +		dput(dentry);
 +	}
 +
 +	dentry = d_alloc(parent, &name);
 +	err = -ENOMEM;
 +	if (!dentry)
 +		goto out;
 +
 +	inode = fuse_iget(dir->i_sb, o->nodeid, o->generation,
 +			  &o->attr, entry_attr_timeout(o), attr_version);
 +	if (!inode)
 +		goto out;
 +
 +	alias = d_materialise_unique(dentry, inode);
 +	err = PTR_ERR(alias);
 +	if (IS_ERR(alias))
 +		goto out;
 +
 +	if (alias) {
 +		dput(dentry);
 +		dentry = alias;
 +	}
 +
 +found:
 +	if (fc->readdirplus_auto)
 +		set_bit(FUSE_I_INIT_RDPLUS, &get_fuse_inode(inode)->state);
 +	fuse_change_entry_timeout(dentry, o);
 +
 +	err = 0;
 +out:
 +	dput(dentry);
 +	return err;
 +}
 +
 +static int parse_dirplusfile(char *buf, size_t nbytes, struct file *file,
 +			     void *dstbuf, filldir_t filldir, u64 attr_version)
 +{
 +	struct fuse_direntplus *direntplus;
 +	struct fuse_dirent *dirent;
 +	size_t reclen;
 +	int over = 0;
 +	int ret;
 +
 +	while (nbytes >= FUSE_NAME_OFFSET_DIRENTPLUS) {
 +		direntplus = (struct fuse_direntplus *) buf;
 +		dirent = &direntplus->dirent;
 +		reclen = FUSE_DIRENTPLUS_SIZE(direntplus);
 +
 +		if (!dirent->namelen || dirent->namelen > FUSE_NAME_MAX)
 +			return -EIO;
 +		if (reclen > nbytes)
 +			break;
 +		if (memchr(dirent->name, '/', dirent->namelen) != NULL)
 +			return -EIO;
 +
 +		if (!over) {
 +			/* We fill entries into dstbuf only as much as
 +			   it can hold. But we still continue iterating
 +			   over remaining entries to link them. If not,
 +			   we need to send a FORGET for each of those
 +			   which we did not link.
 +			*/
 +			over = filldir(dstbuf, dirent->name, dirent->namelen,
 +				       file->f_pos, dirent->ino,
 +				       dirent->type);
 +			if (!over)
 +				file->f_pos = dirent->off;
 +		}
 +
 +		buf += reclen;
 +		nbytes -= reclen;
 +
 +		ret = fuse_direntplus_link(file, direntplus, attr_version);
 +		if (ret)
 +			fuse_force_forget(file, direntplus->entry_out.nodeid);
 +	}
 +
 +	return 0;
 +}
 +
 +static int fuse_readdir(struct file *file, void *dstbuf, filldir_t filldir)
 +{
 +	int plus, err;
 +	size_t nbytes;
 +	struct page *page;
 +	struct inode *inode = file_inode(file);
 +	struct fuse_conn *fc = get_fuse_conn(inode);
 +	struct fuse_req *req;
 +	u64 attr_version = 0;
 +
 +	if (is_bad_inode(inode))
 +		return -EIO;
 +
 +	req = fuse_get_req(fc, 1);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +
 +	page = alloc_page(GFP_KERNEL);
 +	if (!page) {
 +		fuse_put_request(fc, req);
 +		return -ENOMEM;
 +	}
 +
 +	plus = fuse_use_readdirplus(inode, file);
 +	req->out.argpages = 1;
 +	req->num_pages = 1;
 +	req->pages[0] = page;
 +	req->page_descs[0].length = PAGE_SIZE;
 +	if (plus) {
 +		attr_version = fuse_get_attr_version(fc);
 +		fuse_read_fill(req, file, file->f_pos, PAGE_SIZE,
 +			       FUSE_READDIRPLUS);
 +	} else {
 +		fuse_read_fill(req, file, file->f_pos, PAGE_SIZE,
 +			       FUSE_READDIR);
 +	}
 +	fuse_request_send(fc, req);
 +	nbytes = req->out.args[0].size;
 +	err = req->out.h.error;
 +	fuse_put_request(fc, req);
 +	if (!err) {
 +		if (plus) {
 +			err = parse_dirplusfile(page_address(page), nbytes,
 +						file, dstbuf, filldir,
 +						attr_version);
 +		} else {
 +			err = parse_dirfile(page_address(page), nbytes, file,
 +					    dstbuf, filldir);
 +		}
 +	}
 +
 +	__free_page(page);
 +	fuse_invalidate_atime(inode);
 +	return err;
 +}
 +
 +static char *read_link(struct dentry *dentry)
 +{
 +	struct inode *inode = dentry->d_inode;
 +	struct fuse_conn *fc = get_fuse_conn(inode);
 +	struct fuse_req *req = fuse_get_req_nopages(fc);
 +	char *link;
 +
 +	if (IS_ERR(req))
 +		return ERR_CAST(req);
 +
 +	link = (char *) __get_free_page(GFP_KERNEL);
 +	if (!link) {
 +		link = ERR_PTR(-ENOMEM);
 +		goto out;
 +	}
 +	req->in.h.opcode = FUSE_READLINK;
 +	req->in.h.nodeid = get_node_id(inode);
 +	req->out.argvar = 1;
 +	req->out.numargs = 1;
 +	req->out.args[0].size = PAGE_SIZE - 1;
 +	req->out.args[0].value = link;
 +	fuse_request_send(fc, req);
 +	if (req->out.h.error) {
 +		free_page((unsigned long) link);
 +		link = ERR_PTR(req->out.h.error);
 +	} else
 +		link[req->out.args[0].size] = '\0';
 + out:
 +	fuse_put_request(fc, req);
 +	fuse_invalidate_atime(inode);
 +	return link;
 +}
 +
 +static void free_link(char *link)
 +{
 +	if (!IS_ERR(link))
 +		free_page((unsigned long) link);
 +}
 +
 +static void *fuse_follow_link(struct dentry *dentry, struct nameidata *nd)
 +{
 +	nd_set_link(nd, read_link(dentry));
 +	return NULL;
 +}
 +
 +static void fuse_put_link(struct dentry *dentry, struct nameidata *nd, void *c)
 +{
 +	free_link(nd_get_link(nd));
  }
  
  static int fuse_dir_open(struct inode *inode, struct file *file)
@@@ -1520,7 -1397,25 +1605,29 @@@ static int fuse_dir_release(struct inod
  static int fuse_dir_fsync(struct file *file, loff_t start, loff_t end,
  			  int datasync)
  {
++<<<<<<< HEAD
 +	return fuse_fsync_common(file, start, end, datasync, 1);
++=======
+ 	struct inode *inode = file->f_mapping->host;
+ 	struct fuse_conn *fc = get_fuse_conn(inode);
+ 	int err;
+ 
+ 	if (fuse_is_bad(inode))
+ 		return -EIO;
+ 
+ 	if (fc->no_fsyncdir)
+ 		return 0;
+ 
+ 	inode_lock(inode);
+ 	err = fuse_fsync_common(file, start, end, datasync, FUSE_FSYNCDIR);
+ 	if (err == -ENOSYS) {
+ 		fc->no_fsyncdir = 1;
+ 		err = 0;
+ 	}
+ 	inode_unlock(inode);
+ 
+ 	return err;
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  }
  
  static long fuse_dir_ioctl(struct file *file, unsigned int cmd,
@@@ -1782,8 -1698,9 +1889,14 @@@ int fuse_do_setattr(struct inode *inode
  		goto error;
  	}
  
++<<<<<<< HEAD
 +	if ((inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
 +		make_bad_inode(inode);
++=======
+ 	if (fuse_invalid_attr(&outarg.attr) ||
+ 	    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {
+ 		fuse_make_bad(inode);
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  		err = -EIO;
  		goto error;
  	}
@@@ -1834,9 -1758,14 +1947,12 @@@ error
  
  static int fuse_setattr(struct dentry *entry, struct iattr *attr)
  {
 -	struct inode *inode = d_inode(entry);
 -	struct fuse_conn *fc = get_fuse_conn(inode);
 -	struct file *file = (attr->ia_valid & ATTR_FILE) ? attr->ia_file : NULL;
 +	struct inode *inode = entry->d_inode;
  	int ret;
  
+ 	if (fuse_is_bad(inode))
+ 		return -EIO;
+ 
  	if (!fuse_allow_current_process(get_fuse_conn(inode)))
  		return -EACCES;
  
@@@ -1853,217 -1818,32 +1969,233 @@@
  	return ret;
  }
  
 -static int fuse_getattr(const struct path *path, struct kstat *stat,
 -			u32 request_mask, unsigned int flags)
 +static int fuse_getattr(struct vfsmount *mnt, struct dentry *entry,
 +			struct kstat *stat)
  {
 -	struct inode *inode = d_inode(path->dentry);
 +	struct inode *inode = entry->d_inode;
  	struct fuse_conn *fc = get_fuse_conn(inode);
  
++<<<<<<< HEAD
 +	if (!fuse_allow_current_process(fc))
++=======
+ 	if (fuse_is_bad(inode))
+ 		return -EIO;
+ 
+ 	if (!fuse_allow_current_process(fc)) {
+ 		if (!request_mask) {
+ 			/*
+ 			 * If user explicitly requested *nothing* then don't
+ 			 * error out, but return st_dev only.
+ 			 */
+ 			stat->result_mask = 0;
+ 			stat->dev = inode->i_sb->s_dev;
+ 			return 0;
+ 		}
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  		return -EACCES;
 +
 +	if (READ_ONCE(get_fuse_inode(inode)->inval_atime))
 +		fuse_invalidate_attr(inode);
 +
 +	return fuse_update_attributes(inode, stat, NULL, NULL);
 +}
 +
 +static int fuse_setxattr(struct dentry *entry, const char *name,
 +			 const void *value, size_t size, int flags)
 +{
 +	struct inode *inode = entry->d_inode;
 +	struct fuse_conn *fc = get_fuse_conn(inode);
 +	struct fuse_req *req;
 +	struct fuse_setxattr_in inarg;
 +	int err;
 +
 +	if (fc->no_setxattr)
 +		return -EOPNOTSUPP;
 +
 +	req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +
 +	memset(&inarg, 0, sizeof(inarg));
 +	inarg.size = size;
 +	inarg.flags = flags;
 +	req->in.h.opcode = FUSE_SETXATTR;
 +	req->in.h.nodeid = get_node_id(inode);
 +	req->in.numargs = 3;
 +	req->in.args[0].size = sizeof(inarg);
 +	req->in.args[0].value = &inarg;
 +	req->in.args[1].size = strlen(name) + 1;
 +	req->in.args[1].value = name;
 +	req->in.args[2].size = size;
 +	req->in.args[2].value = value;
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
 +	fuse_put_request(fc, req);
 +	if (err == -ENOSYS) {
 +		fc->no_setxattr = 1;
 +		err = -EOPNOTSUPP;
 +	}
 +	if (!err) {
 +		fuse_invalidate_attr(inode);
 +		fuse_update_ctime(inode);
  	}
 +	return err;
 +}
 +
 +static ssize_t fuse_getxattr(struct dentry *entry, const char *name,
 +			     void *value, size_t size)
 +{
 +	struct inode *inode = entry->d_inode;
 +	struct fuse_conn *fc = get_fuse_conn(inode);
 +	struct fuse_req *req;
 +	struct fuse_getxattr_in inarg;
 +	struct fuse_getxattr_out outarg;
 +	ssize_t ret;
 +
 +	if (fc->no_getxattr)
 +		return -EOPNOTSUPP;
  
 -	return fuse_update_get_attr(inode, NULL, stat, request_mask, flags);
 +	req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +
 +	memset(&inarg, 0, sizeof(inarg));
 +	inarg.size = size;
 +	req->in.h.opcode = FUSE_GETXATTR;
 +	req->in.h.nodeid = get_node_id(inode);
 +	req->in.numargs = 2;
 +	req->in.args[0].size = sizeof(inarg);
 +	req->in.args[0].value = &inarg;
 +	req->in.args[1].size = strlen(name) + 1;
 +	req->in.args[1].value = name;
 +	/* This is really two different operations rolled into one */
 +	req->out.numargs = 1;
 +	if (size) {
 +		req->out.argvar = 1;
 +		req->out.args[0].size = size;
 +		req->out.args[0].value = value;
 +	} else {
 +		req->out.args[0].size = sizeof(outarg);
 +		req->out.args[0].value = &outarg;
 +	}
 +	fuse_request_send(fc, req);
 +	ret = req->out.h.error;
 +	if (!ret)
 +		ret = size ? req->out.args[0].size : outarg.size;
 +	else {
 +		if (ret == -ENOSYS) {
 +			fc->no_getxattr = 1;
 +			ret = -EOPNOTSUPP;
 +		}
 +	}
 +	fuse_put_request(fc, req);
 +	return ret;
  }
  
 -static const struct inode_operations fuse_dir_inode_operations = {
 +static int fuse_verify_xattr_list(char *list, size_t size)
 +{
 +	size_t origsize = size;
 +
 +	while (size) {
 +		size_t thislen = strnlen(list, size);
 +
 +		if (!thislen || thislen == size)
 +			return -EIO;
 +
 +		size -= thislen + 1;
 +		list += thislen + 1;
 +	}
 +
 +	return origsize;
 +}
 +
 +static ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)
 +{
 +	struct inode *inode = entry->d_inode;
 +	struct fuse_conn *fc = get_fuse_conn(inode);
 +	struct fuse_req *req;
 +	struct fuse_getxattr_in inarg;
 +	struct fuse_getxattr_out outarg;
 +	ssize_t ret;
 +
 +	if (!fuse_allow_current_process(fc))
 +		return -EACCES;
 +
 +	if (fc->no_listxattr)
 +		return -EOPNOTSUPP;
 +
 +	req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +
 +	memset(&inarg, 0, sizeof(inarg));
 +	inarg.size = size;
 +	req->in.h.opcode = FUSE_LISTXATTR;
 +	req->in.h.nodeid = get_node_id(inode);
 +	req->in.numargs = 1;
 +	req->in.args[0].size = sizeof(inarg);
 +	req->in.args[0].value = &inarg;
 +	/* This is really two different operations rolled into one */
 +	req->out.numargs = 1;
 +	if (size) {
 +		req->out.argvar = 1;
 +		req->out.args[0].size = size;
 +		req->out.args[0].value = list;
 +	} else {
 +		req->out.args[0].size = sizeof(outarg);
 +		req->out.args[0].value = &outarg;
 +	}
 +	fuse_request_send(fc, req);
 +	ret = req->out.h.error;
 +	if (!ret) {
 +		ret = size ? req->out.args[0].size : outarg.size;
 +		if (ret > 0 && size)
 +			ret = fuse_verify_xattr_list(list, ret);
 +	} else {
 +		if (ret == -ENOSYS) {
 +			fc->no_listxattr = 1;
 +			ret = -EOPNOTSUPP;
 +		}
 +	}
 +	fuse_put_request(fc, req);
 +	return ret;
 +}
 +
 +static int fuse_removexattr(struct dentry *entry, const char *name)
 +{
 +	struct inode *inode = entry->d_inode;
 +	struct fuse_conn *fc = get_fuse_conn(inode);
 +	struct fuse_req *req;
 +	int err;
 +
 +	if (fc->no_removexattr)
 +		return -EOPNOTSUPP;
 +
 +	req = fuse_get_req_nopages(fc);
 +	if (IS_ERR(req))
 +		return PTR_ERR(req);
 +
 +	req->in.h.opcode = FUSE_REMOVEXATTR;
 +	req->in.h.nodeid = get_node_id(inode);
 +	req->in.numargs = 1;
 +	req->in.args[0].size = strlen(name) + 1;
 +	req->in.args[0].value = name;
 +	fuse_request_send(fc, req);
 +	err = req->out.h.error;
 +	fuse_put_request(fc, req);
 +	if (err == -ENOSYS) {
 +		fc->no_removexattr = 1;
 +		err = -EOPNOTSUPP;
 +	}
 +	if (!err) {
 +		fuse_invalidate_attr(inode);
 +		fuse_update_ctime(inode);
 +	}
 +	return err;
 +}
 +
 +static const struct inode_operations_wrapper fuse_dir_inode_operations = {
 +	.ops = {
  	.lookup		= fuse_lookup,
  	.mkdir		= fuse_mkdir,
  	.symlink	= fuse_symlink,
diff --cc fs/fuse/file.c
index a6d3d873e7dc,8cccecb55fb8..000000000000
--- a/fs/fuse/file.c
+++ b/fs/fuse/file.c
@@@ -232,12 -223,18 +232,15 @@@ void fuse_finish_open(struct inode *ino
  
  int fuse_open_common(struct inode *inode, struct file *file, bool isdir)
  {
 -	struct fuse_mount *fm = get_fuse_mount(inode);
 -	struct fuse_conn *fc = fm->fc;
 +	struct fuse_conn *fc = get_fuse_conn(inode);
  	int err;
 -	bool is_wb_truncate = (file->f_flags & O_TRUNC) &&
 +	bool lock_inode = (file->f_flags & O_TRUNC) &&
  			  fc->atomic_o_trunc &&
  			  fc->writeback_cache;
 -	bool dax_truncate = (file->f_flags & O_TRUNC) &&
 -			  fc->atomic_o_trunc && FUSE_IS_DAX(inode);
  
+ 	if (fuse_is_bad(inode))
+ 		return -EIO;
+ 
  	err = generic_file_open(inode, file);
  	if (err)
  		return err;
@@@ -442,18 -466,15 +445,18 @@@ static void fuse_sync_writes(struct ino
  static int fuse_flush(struct file *file, fl_owner_t id)
  {
  	struct inode *inode = file_inode(file);
 -	struct fuse_mount *fm = get_fuse_mount(inode);
 +	struct fuse_conn *fc = get_fuse_conn(inode);
  	struct fuse_file *ff = file->private_data;
 +	struct fuse_req *req;
  	struct fuse_flush_in inarg;
 -	FUSE_ARGS(args);
  	int err;
  
- 	if (is_bad_inode(inode))
+ 	if (fuse_is_bad(inode))
  		return -EIO;
  
 +	if (fc->no_flush)
 +		return 0;
 +
  	err = write_inode_now(inode, 1);
  	if (err)
  		return err;
@@@ -492,19 -518,36 +495,19 @@@
  }
  
  int fuse_fsync_common(struct file *file, loff_t start, loff_t end,
 -		      int datasync, int opcode)
 +		      int datasync, int isdir)
  {
  	struct inode *inode = file->f_mapping->host;
 -	struct fuse_mount *fm = get_fuse_mount(inode);
 +	struct fuse_conn *fc = get_fuse_conn(inode);
  	struct fuse_file *ff = file->private_data;
 -	FUSE_ARGS(args);
 +	struct fuse_req *req;
  	struct fuse_fsync_in inarg;
 -
 -	memset(&inarg, 0, sizeof(inarg));
 -	inarg.fh = ff->fh;
 -	inarg.fsync_flags = datasync ? FUSE_FSYNC_FDATASYNC : 0;
 -	args.opcode = opcode;
 -	args.nodeid = get_node_id(inode);
 -	args.in_numargs = 1;
 -	args.in_args[0].size = sizeof(inarg);
 -	args.in_args[0].value = &inarg;
 -	return fuse_simple_request(fm, &args);
 -}
 -
 -static int fuse_fsync(struct file *file, loff_t start, loff_t end,
 -		      int datasync)
 -{
 -	struct inode *inode = file->f_mapping->host;
 -	struct fuse_conn *fc = get_fuse_conn(inode);
  	int err;
  
- 	if (is_bad_inode(inode))
+ 	if (fuse_is_bad(inode))
  		return -EIO;
  
 -	inode_lock(inode);
 +	mutex_lock(&inode->i_mutex);
  
  	/*
  	 * Start writeback against all dirty pages of the inode, then
@@@ -853,121 -911,87 +856,126 @@@ static void fuse_readpages_end(struct f
  		else
  			SetPageError(page);
  		unlock_page(page);
 -		put_page(page);
 +		page_cache_release(page);
  	}
 -	if (ia->ff)
 -		fuse_file_put(ia->ff, false, false);
 -
 -	fuse_io_free(ia);
 +	if (req->ff)
 +		fuse_file_put(req->ff, false, false);
  }
  
 -static void fuse_send_readpages(struct fuse_io_args *ia, struct file *file)
 +static void fuse_send_readpages(struct fuse_req *req, struct file *file)
  {
  	struct fuse_file *ff = file->private_data;
 -	struct fuse_mount *fm = ff->fm;
 -	struct fuse_args_pages *ap = &ia->ap;
 -	loff_t pos = page_offset(ap->pages[0]);
 -	size_t count = ap->num_pages << PAGE_SHIFT;
 -	ssize_t res;
 -	int err;
 -
 -	ap->args.out_pages = true;
 -	ap->args.page_zeroing = true;
 -	ap->args.page_replace = true;
 -
 -	/* Don't overflow end offset */
 -	if (pos + (count - 1) == LLONG_MAX) {
 -		count--;
 -		ap->descs[ap->num_pages - 1].length--;
 -	}
 -	WARN_ON((loff_t) (pos + count) < 0);
 -
 -	fuse_read_args_fill(ia, file, pos, count, FUSE_READ);
 -	ia->read.attr_ver = fuse_get_attr_version(fm->fc);
 -	if (fm->fc->async_read) {
 -		ia->ff = fuse_file_get(ff);
 -		ap->args.end = fuse_readpages_end;
 -		err = fuse_simple_background(fm, &ap->args, GFP_KERNEL);
 -		if (!err)
 -			return;
 +	struct fuse_conn *fc = ff->fc;
 +	loff_t pos = page_offset(req->pages[0]);
 +	size_t count = req->num_pages << PAGE_CACHE_SHIFT;
 +
 +	req->out.argpages = 1;
 +	req->out.page_zeroing = 1;
 +	req->out.page_replace = 1;
 +	fuse_read_fill(req, file, pos, count, FUSE_READ);
 +	req->misc.read.attr_ver = fuse_get_attr_version(fc);
 +	if (fc->async_read) {
 +		req->ff = fuse_file_get(ff);
 +		req->end = fuse_readpages_end;
 +		fuse_request_send_background(fc, req);
  	} else {
 -		res = fuse_simple_request(fm, &ap->args);
 -		err = res < 0 ? res : 0;
 +		fuse_request_send(fc, req);
 +		fuse_readpages_end(fc, req);
 +		fuse_put_request(fc, req);
  	}
 -	fuse_readpages_end(fm, &ap->args, err);
  }
  
 -static void fuse_readahead(struct readahead_control *rac)
 +struct fuse_fill_data {
 +	struct fuse_req *req;
 +	struct file *file;
 +	struct inode *inode;
 +	unsigned nr_pages;
 +};
 +
 +static int fuse_readpages_fill(void *_data, struct page *page)
  {
 -	struct inode *inode = rac->mapping->host;
 +	struct fuse_fill_data *data = _data;
 +	struct fuse_req *req = data->req;
 +	struct inode *inode = data->inode;
  	struct fuse_conn *fc = get_fuse_conn(inode);
 -	unsigned int i, max_pages, nr_pages = 0;
  
++<<<<<<< HEAD
 +	fuse_wait_on_page_writeback(inode, page->index);
++=======
+ 	if (fuse_is_bad(inode))
+ 		return;
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
 +
 +	if (req->num_pages &&
 +	    (req->num_pages == FUSE_MAX_PAGES_PER_REQ ||
 +	     (req->num_pages + 1) * PAGE_CACHE_SIZE > fc->max_read ||
 +	     req->pages[req->num_pages - 1]->index + 1 != page->index)) {
 +		int nr_alloc = min_t(unsigned, data->nr_pages,
 +				     FUSE_MAX_PAGES_PER_REQ);
 +		fuse_send_readpages(req, data->file);
 +		if (fc->async_read)
 +			req = fuse_get_req_for_background(fc, nr_alloc);
 +		else
 +			req = fuse_get_req(fc, nr_alloc);
  
 -	max_pages = min_t(unsigned int, fc->max_pages,
 -			fc->max_read / PAGE_SIZE);
 +		data->req = req;
 +		if (IS_ERR(req)) {
 +			unlock_page(page);
 +			return PTR_ERR(req);
 +		}
 +	}
  
 -	for (;;) {
 -		struct fuse_io_args *ia;
 -		struct fuse_args_pages *ap;
 +	if (WARN_ON(req->num_pages >= req->max_pages)) {
 +		unlock_page(page);
 +		fuse_put_request(fc, req);
 +		return -EIO;
 +	}
  
 -		nr_pages = readahead_count(rac) - nr_pages;
 -		if (nr_pages > max_pages)
 -			nr_pages = max_pages;
 -		if (nr_pages == 0)
 -			break;
 -		ia = fuse_io_alloc(NULL, nr_pages);
 -		if (!ia)
 -			return;
 -		ap = &ia->ap;
 -		nr_pages = __readahead_batch(rac, ap->pages, nr_pages);
 -		for (i = 0; i < nr_pages; i++) {
 -			fuse_wait_on_page_writeback(inode,
 -						    readahead_index(rac) + i);
 -			ap->descs[i].length = PAGE_SIZE;
 -		}
 -		ap->num_pages = nr_pages;
 -		fuse_send_readpages(ia, rac->file);
 +	page_cache_get(page);
 +	req->pages[req->num_pages] = page;
 +	req->page_descs[req->num_pages].length = PAGE_SIZE;
 +	req->num_pages++;
 +	data->nr_pages--;
 +	return 0;
 +}
 +
 +static int fuse_readpages(struct file *file, struct address_space *mapping,
 +			  struct list_head *pages, unsigned nr_pages)
 +{
 +	struct inode *inode = mapping->host;
 +	struct fuse_conn *fc = get_fuse_conn(inode);
 +	struct fuse_fill_data data;
 +	int err;
 +	int nr_alloc = min_t(unsigned, nr_pages, FUSE_MAX_PAGES_PER_REQ);
 +
 +	err = -EIO;
 +	if (is_bad_inode(inode))
 +		goto out;
 +
 +	data.file = file;
 +	data.inode = inode;
 +	if (fc->async_read)
 +		data.req = fuse_get_req_for_background(fc, nr_alloc);
 +	else
 +		data.req = fuse_get_req(fc, nr_alloc);
 +	data.nr_pages = nr_pages;
 +	err = PTR_ERR(data.req);
 +	if (IS_ERR(data.req))
 +		goto out;
 +
 +	err = read_cache_pages(mapping, pages, fuse_readpages_fill, &data);
 +	if (!err) {
 +		if (data.req->num_pages)
 +			fuse_send_readpages(data.req, file);
 +		else
 +			fuse_put_request(fc, data.req);
  	}
 +out:
 +	return err;
  }
  
 -static ssize_t fuse_cache_read_iter(struct kiocb *iocb, struct iov_iter *to)
 +static ssize_t fuse_file_aio_read(struct kiocb *iocb, const struct iovec *iov,
 +				  unsigned long nr_segs, loff_t pos)
  {
  	struct inode *inode = iocb->ki_filp->f_mapping->host;
  	struct fuse_conn *fc = get_fuse_conn(inode);
@@@ -1562,29 -1567,70 +1570,69 @@@ static ssize_t fuse_direct_write(struc
  	return res;
  }
  
 -static ssize_t fuse_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
 +static void fuse_writepage_free(struct fuse_conn *fc, struct fuse_req *req)
  {
++<<<<<<< HEAD
++=======
+ 	struct file *file = iocb->ki_filp;
+ 	struct fuse_file *ff = file->private_data;
+ 	struct inode *inode = file_inode(file);
+ 
+ 	if (fuse_is_bad(inode))
+ 		return -EIO;
+ 
+ 	if (FUSE_IS_DAX(inode))
+ 		return fuse_dax_read_iter(iocb, to);
+ 
+ 	if (!(ff->open_flags & FOPEN_DIRECT_IO))
+ 		return fuse_cache_read_iter(iocb, to);
+ 	else
+ 		return fuse_direct_read_iter(iocb, to);
+ }
+ 
+ static ssize_t fuse_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
+ {
+ 	struct file *file = iocb->ki_filp;
+ 	struct fuse_file *ff = file->private_data;
+ 	struct inode *inode = file_inode(file);
+ 
+ 	if (fuse_is_bad(inode))
+ 		return -EIO;
+ 
+ 	if (FUSE_IS_DAX(inode))
+ 		return fuse_dax_write_iter(iocb, from);
+ 
+ 	if (!(ff->open_flags & FOPEN_DIRECT_IO))
+ 		return fuse_cache_write_iter(iocb, from);
+ 	else
+ 		return fuse_direct_write_iter(iocb, from);
+ }
+ 
+ static void fuse_writepage_free(struct fuse_writepage_args *wpa)
+ {
+ 	struct fuse_args_pages *ap = &wpa->ia.ap;
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  	int i;
  
 -	for (i = 0; i < ap->num_pages; i++)
 -		__free_page(ap->pages[i]);
 +	for (i = 0; i < req->num_pages; i++)
 +		__free_page(req->pages[i]);
  
 -	if (wpa->ia.ff)
 -		fuse_file_put(wpa->ia.ff, false, false);
 -
 -	kfree(ap->pages);
 -	kfree(wpa);
 +	if (req->ff)
 +		fuse_file_put(req->ff, false, false);
  }
  
 -static void fuse_writepage_finish(struct fuse_mount *fm,
 -				  struct fuse_writepage_args *wpa)
 +static void fuse_writepage_finish(struct fuse_conn *fc, struct fuse_req *req)
  {
 -	struct fuse_args_pages *ap = &wpa->ia.ap;
 -	struct inode *inode = wpa->inode;
 +	struct inode *inode = req->inode;
  	struct fuse_inode *fi = get_fuse_inode(inode);
 -	struct backing_dev_info *bdi = inode_to_bdi(inode);
 +	struct backing_dev_info *bdi = inode->i_mapping->backing_dev_info;
  	int i;
  
 -	for (i = 0; i < ap->num_pages; i++) {
 -		dec_wb_stat(&bdi->wb, WB_WRITEBACK);
 -		dec_node_page_state(ap->pages[i], NR_WRITEBACK_TEMP);
 -		wb_writeout_inc(&bdi->wb);
 +	list_del(&req->writepages_entry);
 +	for (i = 0; i < req->num_pages; i++) {
 +		dec_bdi_stat(bdi, BDI_WRITEBACK);
 +		dec_zone_page_state(req->pages[i], NR_WRITEBACK_TEMP);
 +		bdi_writeout_inc(bdi);
  	}
  	wake_up(&fi->page_waitq);
  }
diff --cc fs/fuse/fuse_i.h
index 5ecda7763980,7c4b8cb93f9f..000000000000
--- a/fs/fuse/fuse_i.h
+++ b/fs/fuse/fuse_i.h
@@@ -634,6 -851,26 +636,29 @@@ static inline u64 get_node_id(struct in
  	return get_fuse_inode(inode)->nodeid;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int invalid_nodeid(u64 nodeid)
+ {
+ 	return !nodeid || nodeid == FUSE_ROOT_ID;
+ }
+ 
+ static inline u64 fuse_get_attr_version(struct fuse_conn *fc)
+ {
+ 	return atomic64_read(&fc->attr_version);
+ }
+ 
+ static inline void fuse_make_bad(struct inode *inode)
+ {
+ 	set_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state);
+ }
+ 
+ static inline bool fuse_is_bad(struct inode *inode)
+ {
+ 	return unlikely(test_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state));
+ }
+ 
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  /** Device operations */
  extern const struct file_operations fuse_dev_operations;
  
diff --cc fs/fuse/inode.c
index 2a5c2cd1bca4,b0e18b470e91..000000000000
--- a/fs/fuse/inode.c
+++ b/fs/fuse/inode.c
@@@ -125,13 -117,24 +125,28 @@@ static void fuse_destroy_inode(struct i
  
  static void fuse_evict_inode(struct inode *inode)
  {
 -	struct fuse_inode *fi = get_fuse_inode(inode);
 -
  	truncate_inode_pages_final(&inode->i_data);
  	clear_inode(inode);
 -	if (inode->i_sb->s_flags & SB_ACTIVE) {
 +	if (inode->i_sb->s_flags & MS_ACTIVE) {
  		struct fuse_conn *fc = get_fuse_conn(inode);
++<<<<<<< HEAD
 +		struct fuse_inode *fi = get_fuse_inode(inode);
 +		fuse_queue_forget(fc, fi->forget, fi->nodeid, fi->nlookup);
 +		fi->forget = NULL;
++=======
+ 
+ 		if (FUSE_IS_DAX(inode))
+ 			fuse_dax_inode_cleanup(inode);
+ 		if (fi->nlookup) {
+ 			fuse_queue_forget(fc, fi->forget, fi->nodeid,
+ 					  fi->nlookup);
+ 			fi->forget = NULL;
+ 		}
+ 	}
+ 	if (S_ISREG(inode->i_mode) && !fuse_is_bad(inode)) {
+ 		WARN_ON(!list_empty(&fi->write_files));
+ 		WARN_ON(!list_empty(&fi->queued_writes));
++>>>>>>> 5d069dbe8aaf (fuse: fix bad inode)
  	}
  }
  
* Unmerged path fs/fuse/acl.c
* Unmerged path fs/fuse/readdir.c
* Unmerged path fs/fuse/xattr.c
* Unmerged path fs/fuse/acl.c
* Unmerged path fs/fuse/dir.c
* Unmerged path fs/fuse/file.c
* Unmerged path fs/fuse/fuse_i.h
* Unmerged path fs/fuse/inode.c
* Unmerged path fs/fuse/readdir.c
* Unmerged path fs/fuse/xattr.c
