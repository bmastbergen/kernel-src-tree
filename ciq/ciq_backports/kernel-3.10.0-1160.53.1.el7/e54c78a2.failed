gfs2: Use fs_* functions instead of pr_* function where we can

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.53.1.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit e54c78a27fcdef406af799f360a93e6754adeefe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.53.1.el7/e54c78a2.failed

Before this patch, various errors and messages were reported using
the pr_* functions: pr_err, pr_warn, pr_info, etc., but that does
not tell you which gfs2 mount had the problem, which is often vital
to debugging. This patch changes the calls from pr_* to fs_* in
most of the messages so that the file system id is printed along
with the message.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit e54c78a27fcdef406af799f360a93e6754adeefe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/dir.c
#	fs/gfs2/glock.c
#	fs/gfs2/lock_dlm.c
#	fs/gfs2/rgrp.c
#	fs/gfs2/trans.c
#	fs/gfs2/util.h
diff --cc fs/gfs2/dir.c
index 25056e88a1cc,2e28fc947f7f..000000000000
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@@ -533,8 -529,8 +534,13 @@@ static int gfs2_check_dirent(struct gfs
  		goto error;
  	return 0;
  error:
++<<<<<<< HEAD
 +	printk(KERN_WARNING "gfs2_check_dirent: %s (%s)\n", msg,
 +	       first ? "first in block" : "not first in block");
++=======
+ 	fs_warn(sdp, "%s: %s (%s)\n",
+ 		__func__, msg, first ? "first in block" : "not first in block");
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  	return -EIO;
  }
  
@@@ -557,8 -553,8 +563,13 @@@ static int gfs2_dirent_offset(struct gf
  	}
  	return offset;
  wrong_type:
++<<<<<<< HEAD
 +	printk(KERN_WARNING "gfs2_scan_dirent: wrong block type %u\n",
 +	       be32_to_cpu(h->mh_type));
++=======
+ 	fs_warn(sdp, "%s: wrong block type %u\n", __func__,
+ 		be32_to_cpu(h->mh_type));
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  	return -1;
  }
  
@@@ -1047,10 -1043,11 +1059,15 @@@ static int dir_split_leaf(struct inode 
  	bn = nbh->b_blocknr;
  
  	/*  Compute the start and len of leaf pointers in the hash table.  */
 -	len = BIT(dip->i_depth - be16_to_cpu(oleaf->lf_depth));
 +	len = 1 << (dip->i_depth - be16_to_cpu(oleaf->lf_depth));
  	half_len = len >> 1;
  	if (!half_len) {
++<<<<<<< HEAD
 +		printk(KERN_WARNING "i_depth %u lf_depth %u index %u\n", dip->i_depth, be16_to_cpu(oleaf->lf_depth), index);
++=======
+ 		fs_warn(GFS2_SB(inode), "i_depth %u lf_depth %u index %u\n",
+ 			dip->i_depth, be16_to_cpu(oleaf->lf_depth), index);
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  		gfs2_consist_inode(dip);
  		error = -EIO;
  		goto fail_brelse;
diff --cc fs/gfs2/glock.c
index d5f0bcb8970e,05431324b262..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -504,7 -494,8 +504,12 @@@ retry
  			do_xmote(gl, gh, LM_ST_UNLOCKED);
  			break;
  		default: /* Everything else */
++<<<<<<< HEAD
 +			printk(KERN_ERR "GFS2: wanted %u got %u\n", gl->gl_target, state);
++=======
+ 			fs_err(gl->gl_name.ln_sbd, "wanted %u got %u\n",
+ 			       gl->gl_target, state);
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  			GLOCK_BUG_ON(gl, 1);
  		}
  		spin_unlock(&gl->gl_lockref.lock);
@@@ -587,7 -578,7 +592,11 @@@ __acquires(&gl->gl_lockref.lock
  			gfs2_glock_queue_work(gl, 0);
  		}
  		else if (ret) {
++<<<<<<< HEAD
 +			printk(KERN_ERR "GFS2: lm_lock ret %d\n", ret);
++=======
+ 			fs_err(sdp, "lm_lock ret %d\n", ret);
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  			GLOCK_BUG_ON(gl, !test_bit(SDF_SHUTDOWN,
  						   &sdp->sd_flags));
  		}
@@@ -1177,13 -1065,13 +1186,23 @@@ do_cancel
  	return;
  
  trap_recursive:
++<<<<<<< HEAD
 +	printk(KERN_ERR "original: %pSR\n", (void *)gh2->gh_ip);
 +	printk(KERN_ERR "pid: %d\n", pid_nr(gh2->gh_owner_pid));
 +	printk(KERN_ERR "lock type: %d req lock state : %d\n",
 +	       gh2->gh_gl->gl_name.ln_type, gh2->gh_state);
 +	printk(KERN_ERR "new: %pSR\n", (void *)gh->gh_ip);
 +	printk(KERN_ERR "pid: %d\n", pid_nr(gh->gh_owner_pid));
 +	printk(KERN_ERR "lock type: %d req lock state : %d\n",
++=======
+ 	fs_err(sdp, "original: %pSR\n", (void *)gh2->gh_ip);
+ 	fs_err(sdp, "pid: %d\n", pid_nr(gh2->gh_owner_pid));
+ 	fs_err(sdp, "lock type: %d req lock state : %d\n",
+ 	       gh2->gh_gl->gl_name.ln_type, gh2->gh_state);
+ 	fs_err(sdp, "new: %pSR\n", (void *)gh->gh_ip);
+ 	fs_err(sdp, "pid: %d\n", pid_nr(gh->gh_owner_pid));
+ 	fs_err(sdp, "lock type: %d req lock state : %d\n",
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  	       gh->gh_gl->gl_name.ln_type, gh->gh_state);
  	gfs2_dump_glock(NULL, gl);
  	BUG();
diff --cc fs/gfs2/lock_dlm.c
index 6baae5087837,31df26ed7854..000000000000
--- a/fs/gfs2/lock_dlm.c
+++ b/fs/gfs2/lock_dlm.c
@@@ -176,7 -177,7 +176,11 @@@ static void gdlm_bast(void *arg, int mo
  		gfs2_glock_cb(gl, LM_ST_SHARED);
  		break;
  	default:
++<<<<<<< HEAD
 +		printk(KERN_ERR "unknown bast mode %d", mode);
++=======
+ 		fs_err(gl->gl_name.ln_sbd, "unknown bast mode %d\n", mode);
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  		BUG();
  	}
  }
@@@ -195,7 -196,7 +199,11 @@@ static int make_mode(struct gfs2_sbd *s
  	case LM_ST_SHARED:
  		return DLM_LOCK_PR;
  	}
++<<<<<<< HEAD
 +	printk(KERN_ERR "unknown LM state %d", lmstate);
++=======
+ 	fs_err(sdp, "unknown LM state %d\n", lmstate);
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  	BUG();
  	return -1;
  }
@@@ -308,7 -309,7 +316,11 @@@ static void gdlm_put_lock(struct gfs2_g
  	error = dlm_unlock(ls->ls_dlm, gl->gl_lksb.sb_lkid, DLM_LKF_VALBLK,
  			   NULL, gl);
  	if (error) {
++<<<<<<< HEAD
 +		printk(KERN_ERR "gdlm_unlock %x,%llx err=%d\n",
++=======
+ 		fs_err(sdp, "gdlm_unlock %x,%llx err=%d\n",
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  		       gl->gl_name.ln_type,
  		       (unsigned long long)gl->gl_name.ln_number, error);
  		return;
diff --cc fs/gfs2/rgrp.c
index eebb1e1cfe40,b445ae15f87e..000000000000
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@@ -98,13 -101,16 +98,26 @@@ static inline void gfs2_setbit(const st
  	cur_state = (*byte1 >> bit) & GFS2_BIT_MASK;
  
  	if (unlikely(!valid_change[new_state * 4 + cur_state])) {
++<<<<<<< HEAD
 +		printk(KERN_WARNING "GFS2: buf_blk = 0x%x old_state=%d, "
 +		       "new_state=%d\n", rbm->offset, cur_state, new_state);
 +		printk(KERN_WARNING "GFS2: rgrp=0x%llx bi_start=0x%x\n",
 +		       (unsigned long long)rbm->rgd->rd_addr,
 +		       rbm->bi->bi_start);
 +		printk(KERN_WARNING "GFS2: bi_offset=0x%x bi_len=0x%x\n",
 +		       rbm->bi->bi_offset, rbm->bi->bi_len);
++=======
+ 		struct gfs2_sbd *sdp = rbm->rgd->rd_sbd;
+ 
+ 		fs_warn(sdp, "buf_blk = 0x%x old_state=%d, new_state=%d\n",
+ 			rbm->offset, cur_state, new_state);
+ 		fs_warn(sdp, "rgrp=0x%llx bi_start=0x%x biblk: 0x%llx\n",
+ 			(unsigned long long)rbm->rgd->rd_addr, bi->bi_start,
+ 			(unsigned long long)bi->bi_bh->b_blocknr);
+ 		fs_warn(sdp, "bi_offset=0x%x bi_len=0x%x block=0x%llx\n",
+ 			bi->bi_offset, bi->bi_len,
+ 			(unsigned long long)gfs2_rbm_to_block(rbm));
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  		dump_stack();
  		gfs2_consist_rgrpd(rbm->rgd);
  		return;
@@@ -690,11 -742,13 +703,21 @@@ void gfs2_clear_rgrpd(struct gfs2_sbd *
  
  static void gfs2_rindex_print(const struct gfs2_rgrpd *rgd)
  {
++<<<<<<< HEAD
 +	printk(KERN_INFO "  ri_addr = %llu\n", (unsigned long long)rgd->rd_addr);
 +	printk(KERN_INFO "  ri_length = %u\n", rgd->rd_length);
 +	printk(KERN_INFO "  ri_data0 = %llu\n", (unsigned long long)rgd->rd_data0);
 +	printk(KERN_INFO "  ri_data = %u\n", rgd->rd_data);
 +	printk(KERN_INFO "  ri_bitbytes = %u\n", rgd->rd_bitbytes);
++=======
+ 	struct gfs2_sbd *sdp = rgd->rd_sbd;
+ 
+ 	fs_info(sdp, "ri_addr = %llu\n", (unsigned long long)rgd->rd_addr);
+ 	fs_info(sdp, "ri_length = %u\n", rgd->rd_length);
+ 	fs_info(sdp, "ri_data0 = %llu\n", (unsigned long long)rgd->rd_data0);
+ 	fs_info(sdp, "ri_data = %u\n", rgd->rd_data);
+ 	fs_info(sdp, "ri_bitbytes = %u\n", rgd->rd_bitbytes);
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  }
  
  /**
@@@ -2329,7 -2429,7 +2352,11 @@@ int gfs2_alloc_blocks(struct gfs2_inod
  		}
  	}
  	if (rbm.rgd->rd_free < *nblocks) {
++<<<<<<< HEAD
 +		printk(KERN_WARNING "nblocks=%u\n", *nblocks);
++=======
+ 		fs_warn(sdp, "nblocks=%u\n", *nblocks);
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  		goto rgrp_error;
  	}
  
diff --cc fs/gfs2/trans.c
index bd93fa2d7186,423bc2d03dd8..000000000000
--- a/fs/gfs2/trans.c
+++ b/fs/gfs2/trans.c
@@@ -80,34 -74,16 +80,47 @@@ fail_holder_uninit
  	return error;
  }
  
++<<<<<<< HEAD
 +/**
 + * gfs2_log_release - Release a given number of log blocks
 + * @sdp: The GFS2 superblock
 + * @blks: The number of blocks
 + *
 + */
 +
 +static void gfs2_log_release(struct gfs2_sbd *sdp, unsigned int blks)
 +{
 +
 +	atomic_add(blks, &sdp->sd_log_blks_free);
 +	trace_gfs2_log_blocks(sdp, blks);
 +	gfs2_assert_withdraw(sdp, atomic_read(&sdp->sd_log_blks_free) <=
 +				  sdp->sd_jdesc->jd_blocks);
 +	up_read(&sdp->sd_log_flush_lock);
 +}
 +
 +static void gfs2_print_trans(const struct gfs2_trans *tr)
 +{
 +	printk(KERN_WARNING "GFS2: Transaction created at: %pSR\n",
 +	       (void *)tr->tr_ip);
 +	printk(KERN_WARNING "GFS2: blocks=%u revokes=%u reserved=%u touched=%d\n",
 +	       tr->tr_blocks, tr->tr_revokes, tr->tr_reserved,
 +	       test_bit(TR_TOUCHED, &tr->tr_flags));
 +	printk(KERN_WARNING "GFS2: Buf %u/%u Databuf %u/%u Revoke %u/%u\n",
 +	       tr->tr_num_buf_new, tr->tr_num_buf_rm,
 +	       tr->tr_num_databuf_new, tr->tr_num_databuf_rm,
 +	       tr->tr_num_revoke, tr->tr_num_revoke_rm);
++=======
+ static void gfs2_print_trans(struct gfs2_sbd *sdp, const struct gfs2_trans *tr)
+ {
+ 	fs_warn(sdp, "Transaction created at: %pSR\n", (void *)tr->tr_ip);
+ 	fs_warn(sdp, "blocks=%u revokes=%u reserved=%u touched=%u\n",
+ 		tr->tr_blocks, tr->tr_revokes, tr->tr_reserved,
+ 		test_bit(TR_TOUCHED, &tr->tr_flags));
+ 	fs_warn(sdp, "Buf %u/%u Databuf %u/%u Revoke %u/%u\n",
+ 		tr->tr_num_buf_new, tr->tr_num_buf_rm,
+ 		tr->tr_num_databuf_new, tr->tr_num_databuf_rm,
+ 		tr->tr_num_revoke, tr->tr_num_revoke_rm);
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  }
  
  void gfs2_trans_end(struct gfs2_sbd *sdp)
@@@ -133,20 -109,18 +146,20 @@@
  
  	if (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&
  				       (tr->tr_num_revoke <= tr->tr_revokes)))
- 		gfs2_print_trans(tr);
+ 		gfs2_print_trans(sdp, tr);
  
  	gfs2_log_commit(sdp, tr);
 -	if (alloced && !test_bit(TR_ATTACHED, &tr->tr_flags))
 -		kfree(tr);
 +	if (tr->tr_t_gh.gh_gl) {
 +		gfs2_glock_dq(&tr->tr_t_gh);
 +		gfs2_holder_uninit(&tr->tr_t_gh);
 +		if (!test_bit(TR_ATTACHED, &tr->tr_flags))
 +			kfree(tr);
 +	}
  	up_read(&sdp->sd_log_flush_lock);
  
 -	if (sdp->sd_vfs->s_flags & SB_SYNCHRONOUS)
 -		gfs2_log_flush(sdp, NULL, GFS2_LOG_HEAD_FLUSH_NORMAL |
 -			       GFS2_LFC_TRANS_END);
 -	if (alloced)
 -		sb_end_intwrite(sdp->sd_vfs);
 +	if (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)
 +		gfs2_log_flush(sdp, NULL);
 +	sb_end_intwrite(sdp->sd_vfs);
  }
  
  static struct gfs2_bufdata *gfs2_alloc_bufdata(struct gfs2_glock *gl,
@@@ -250,11 -225,15 +263,23 @@@ void gfs2_trans_add_meta(struct gfs2_gl
  	set_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);
  	mh = (struct gfs2_meta_header *)bd->bd_bh->b_data;
  	if (unlikely(mh->mh_magic != cpu_to_be32(GFS2_MAGIC))) {
++<<<<<<< HEAD
 +		printk(KERN_ERR
 +		       "Attempting to add uninitialised block to journal (inplace block=%lld)\n",
 +		       (unsigned long long)bd->bd_bh->b_blocknr);
 +		BUG();
 +	}
++=======
+ 		fs_err(sdp, "Attempting to add uninitialised block to "
+ 		       "journal (inplace block=%lld)\n",
+ 		       (unsigned long long)bd->bd_bh->b_blocknr);
+ 		BUG();
+ 	}
+ 	if (unlikely(state == SFS_FROZEN)) {
+ 		fs_info(sdp, "GFS2:adding buf while frozen\n");
+ 		gfs2_assert_withdraw(sdp, 0);
+ 	}
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  	gfs2_pin(sdp, bd->bd_bh);
  	mh->__pad0 = cpu_to_be64(0);
  	mh->mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);
diff --cc fs/gfs2/util.h
index 136b196396ef,9278fecba632..000000000000
--- a/fs/gfs2/util.h
+++ b/fs/gfs2/util.h
@@@ -85,7 -86,7 +85,11 @@@ static inline int gfs2_meta_check(struc
  	struct gfs2_meta_header *mh = (struct gfs2_meta_header *)bh->b_data;
  	u32 magic = be32_to_cpu(mh->mh_magic);
  	if (unlikely(magic != GFS2_MAGIC)) {
++<<<<<<< HEAD
 +		printk(KERN_ERR "GFS2: Magic number missing at %llu\n",
++=======
+ 		fs_err(sdp, "Magic number missing at %llu\n",
++>>>>>>> e54c78a27fcd (gfs2: Use fs_* functions instead of pr_* function where we can)
  		       (unsigned long long)bh->b_blocknr);
  		return -EIO;
  	}
* Unmerged path fs/gfs2/dir.c
* Unmerged path fs/gfs2/glock.c
* Unmerged path fs/gfs2/lock_dlm.c
* Unmerged path fs/gfs2/rgrp.c
* Unmerged path fs/gfs2/trans.c
* Unmerged path fs/gfs2/util.h
