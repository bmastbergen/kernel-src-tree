gfs2: dump fsid when dumping glock problems

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.53.1.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit 3792ce973f07a2644fd81424b9acacb12530a3cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.53.1.el7/3792ce97.failed

Before this patch, if a glock error was encountered, the glock with
the problem was dumped. But sometimes you may have lots of file systems
mounted, and that doesn't tell you which file system it was for.

This patch adds a new boolean parameter fsid to the dump_glock family
of functions. For non-error cases, such as dumping the glocks debugfs
file, the fsid is not dumped in order to keep lock dumps and glocktop
as clean as possible. For all error cases, such as GLOCK_BUG_ON, the
file system id is now printed. This will make it easier to debug.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 3792ce973f07a2644fd81424b9acacb12530a3cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
#	fs/gfs2/glock.h
#	fs/gfs2/glops.c
#	fs/gfs2/incore.h
#	fs/gfs2/rgrp.c
#	fs/gfs2/rgrp.h
diff --cc fs/gfs2/glock.c
index d5f0bcb8970e,e23fb8b7b020..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -1177,15 -1067,15 +1177,15 @@@ do_cancel
  	return;
  
  trap_recursive:
 -	fs_err(sdp, "original: %pSR\n", (void *)gh2->gh_ip);
 -	fs_err(sdp, "pid: %d\n", pid_nr(gh2->gh_owner_pid));
 -	fs_err(sdp, "lock type: %d req lock state : %d\n",
 +	printk(KERN_ERR "original: %pSR\n", (void *)gh2->gh_ip);
 +	printk(KERN_ERR "pid: %d\n", pid_nr(gh2->gh_owner_pid));
 +	printk(KERN_ERR "lock type: %d req lock state : %d\n",
  	       gh2->gh_gl->gl_name.ln_type, gh2->gh_state);
 -	fs_err(sdp, "new: %pSR\n", (void *)gh->gh_ip);
 -	fs_err(sdp, "pid: %d\n", pid_nr(gh->gh_owner_pid));
 -	fs_err(sdp, "lock type: %d req lock state : %d\n",
 +	printk(KERN_ERR "new: %pSR\n", (void *)gh->gh_ip);
 +	printk(KERN_ERR "pid: %d\n", pid_nr(gh->gh_owner_pid));
 +	printk(KERN_ERR "lock type: %d req lock state : %d\n",
  	       gh->gh_gl->gl_name.ln_type, gh->gh_state);
- 	gfs2_dump_glock(NULL, gl);
+ 	gfs2_dump_glock(NULL, gl, true);
  	BUG();
  }
  
@@@ -1714,13 -1610,11 +1714,21 @@@ void gfs2_glock_thaw(struct gfs2_sbd *s
  	glock_hash_walk(thaw_glock, sdp);
  }
  
++<<<<<<< HEAD
 +static int dump_glock(struct seq_file *seq, struct gfs2_glock *gl)
++=======
+ static void dump_glock(struct seq_file *seq, struct gfs2_glock *gl, bool fsid)
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  {
 +	int ret;
  	spin_lock(&gl->gl_lockref.lock);
++<<<<<<< HEAD
 +	ret = gfs2_dump_glock(seq, gl);
++=======
+ 	gfs2_dump_glock(seq, gl, fsid);
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  	spin_unlock(&gl->gl_lockref.lock);
 +	return ret;
  }
  
  static void dump_glock_func(struct gfs2_glock *gl)
@@@ -1810,19 -1704,21 +1818,25 @@@ static const char *hflags2str(char *buf
   * dump_holder - print information about a glock holder
   * @seq: the seq_file struct
   * @gh: the glock holder
+  * @fs_id_buf: pointer to file system id (if requested)
   *
 + * Returns: 0 on success, -ENOBUFS when we run out of space
   */
  
++<<<<<<< HEAD
 +static int dump_holder(struct seq_file *seq, const struct gfs2_holder *gh)
++=======
+ static void dump_holder(struct seq_file *seq, const struct gfs2_holder *gh,
+ 			const char *fs_id_buf)
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  {
  	struct task_struct *gh_owner = NULL;
  	char flags_buf[32];
  
 -	rcu_read_lock();
  	if (gh->gh_owner_pid)
  		gh_owner = pid_task(gh->gh_owner_pid, PIDTYPE_PID);
- 	gfs2_print_dbg(seq, " H: s:%s f:%s e:%d p:%ld [%s] %pS\n",
- 		       state2str(gh->gh_state),
+ 	gfs2_print_dbg(seq, "%s H: s:%s f:%s e:%d p:%ld [%s] %pS\n",
+ 		       fs_id_buf, state2str(gh->gh_state),
  		       hflags2str(flags_buf, gh->gh_flags, gh->gh_iflags),
  		       gh->gh_error,
  		       gh->gh_owner_pid ? (long)pid_nr(gh->gh_owner_pid) : -1,
@@@ -1883,17 -1780,20 +1898,29 @@@ static const char *gflags2str(char *buf
   * example. The field's are n = number (id of the object), f = flags,
   * t = type, s = state, r = refcount, e = error, p = pid.
   *
 + * Returns: 0 on success, -ENOBUFS when we run out of space
   */
  
++<<<<<<< HEAD
 +int gfs2_dump_glock(struct seq_file *seq, const struct gfs2_glock *gl)
++=======
+ void gfs2_dump_glock(struct seq_file *seq, struct gfs2_glock *gl, bool fsid)
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  {
  	const struct gfs2_glock_operations *glops = gl->gl_ops;
  	unsigned long long dtime;
  	const struct gfs2_holder *gh;
  	char gflags_buf[32];
++<<<<<<< HEAD
 +	int error = 0;
++=======
+ 	char fs_id_buf[GFS2_FSNAME_LEN + 3 * sizeof(int) + 2];
+ 	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  
+ 	memset(fs_id_buf, 0, sizeof(fs_id_buf));
+ 	if (fsid && sdp) /* safety precaution */
+ 		sprintf(fs_id_buf, "fsid=%s: ", sdp->sd_fsname);
  	dtime = jiffies - gl->gl_demote_time;
  	dtime *= 1000000/HZ; /* demote time in uSec */
  	if (!test_bit(GLF_DEMOTE, &gl->gl_flags))
@@@ -1909,15 -1809,11 +1936,23 @@@
  		  atomic_read(&gl->gl_revokes),
  		  (int)gl->gl_lockref.count, gl->gl_hold_time);
  
++<<<<<<< HEAD
 +	list_for_each_entry(gh, &gl->gl_holders, gh_list) {
 +		error = dump_holder(seq, gh);
 +		if (error)
 +			goto out;
 +	}
 +	if (gl->gl_state != LM_ST_UNLOCKED && glops->go_dump)
 +		error = glops->go_dump(seq, gl);
 +out:
 +	return error;
++=======
+ 	list_for_each_entry(gh, &gl->gl_holders, gh_list)
+ 		dump_holder(seq, gh, fs_id_buf);
+ 
+ 	if (gl->gl_state != LM_ST_UNLOCKED && glops->go_dump)
+ 		glops->go_dump(seq, gl, fs_id_buf);
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  }
  
  static int gfs2_glstats_seq_show(struct seq_file *seq, void *iter_ptr)
@@@ -2102,7 -2014,8 +2137,12 @@@ static void gfs2_glock_seq_stop(struct 
  
  static int gfs2_glock_seq_show(struct seq_file *seq, void *iter_ptr)
  {
++<<<<<<< HEAD
 +	return dump_glock(seq, iter_ptr);
++=======
+ 	dump_glock(seq, iter_ptr, false);
+ 	return 0;
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  }
  
  static void *gfs2_sbstats_seq_start(struct seq_file *seq, loff_t *pos)
diff --cc fs/gfs2/glock.h
index 44625c0336c9,e4e0bed5257c..000000000000
--- a/fs/gfs2/glock.h
+++ b/fs/gfs2/glock.h
@@@ -203,8 -199,11 +203,16 @@@ extern int gfs2_glock_nq_num(struct gfs
  			     struct gfs2_holder *gh);
  extern int gfs2_glock_nq_m(unsigned int num_gh, struct gfs2_holder *ghs);
  extern void gfs2_glock_dq_m(unsigned int num_gh, struct gfs2_holder *ghs);
++<<<<<<< HEAD
 +extern int gfs2_dump_glock(struct seq_file *seq, const struct gfs2_glock *gl);
 +#define GLOCK_BUG_ON(gl,x) do { if (unlikely(x)) { gfs2_dump_glock(NULL, gl); BUG(); } } while(0)
++=======
+ extern void gfs2_dump_glock(struct seq_file *seq, struct gfs2_glock *gl,
+ 			    bool fsid);
+ #define GLOCK_BUG_ON(gl,x) do { if (unlikely(x)) {		\
+ 			gfs2_dump_glock(NULL, gl, true);	\
+ 			BUG(); } } while(0)
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  extern __printf(2, 3)
  void gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...);
  
diff --cc fs/gfs2/glops.c
index 90b93ba7dd9f,68e2a2d4e6a6..000000000000
--- a/fs/gfs2/glops.c
+++ b/fs/gfs2/glops.c
@@@ -459,16 -461,26 +459,33 @@@ static int inode_go_lock(struct gfs2_ho
   * inode_go_dump - print information about an inode
   * @seq: The iterator
   * @ip: the inode
+  * @fs_id_buf: file system id (may be empty)
   *
 + * Returns: 0 on success, -ENOBUFS when we run out of space
   */
  
++<<<<<<< HEAD
 +static int inode_go_dump(struct seq_file *seq, const struct gfs2_glock *gl)
++=======
+ static void inode_go_dump(struct seq_file *seq, struct gfs2_glock *gl,
+ 			  const char *fs_id_buf)
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  {
 -	struct gfs2_inode *ip = gl->gl_object;
 -	struct inode *inode = &ip->i_inode;
 -	unsigned long nrpages;
 -
 +	const struct gfs2_inode *ip = gl->gl_object;
  	if (ip == NULL)
++<<<<<<< HEAD
 +		return 0;
 +	gfs2_print_dbg(seq, " I: n:%llu/%llu t:%u f:0x%02lx d:0x%08x s:%llu\n",
++=======
+ 		return;
+ 
+ 	xa_lock_irq(&inode->i_data.i_pages);
+ 	nrpages = inode->i_data.nrpages;
+ 	xa_unlock_irq(&inode->i_data.i_pages);
+ 
+ 	gfs2_print_dbg(seq, "%s I: n:%llu/%llu t:%u f:0x%02lx d:0x%08x s:%llu "
+ 		       "p:%lu\n", fs_id_buf,
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  		  (unsigned long long)ip->i_no_formal_ino,
  		  (unsigned long long)ip->i_no_addr,
  		  IF2DT(ip->i_inode.i_mode), ip->i_flags,
diff --cc fs/gfs2/incore.h
index 1f6f222b6802,7a993d7c022e..000000000000
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@@ -211,7 -240,8 +211,12 @@@ struct gfs2_glock_operations 
  	int (*go_demote_ok) (const struct gfs2_glock *gl);
  	int (*go_lock) (struct gfs2_holder *gh);
  	void (*go_unlock) (struct gfs2_holder *gh);
++<<<<<<< HEAD
 +	int (*go_dump)(struct seq_file *seq, const struct gfs2_glock *gl);
++=======
+ 	void (*go_dump)(struct seq_file *seq, struct gfs2_glock *gl,
+ 			const char *fs_id_buf);
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  	void (*go_callback)(struct gfs2_glock *gl, bool remote);
  	const int go_type;
  	const unsigned long go_flags;
diff --cc fs/gfs2/rgrp.c
index eebb1e1cfe40,a60b36fdbdd6..000000000000
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@@ -568,10 -600,23 +568,30 @@@ void gfs2_free_clones(struct gfs2_rgrp
  	}
  }
  
++<<<<<<< HEAD
 +static void dump_rs(struct seq_file *seq, const struct gfs2_blkreserv *rs)
 +{
 +	gfs2_print_dbg(seq, "  B: n:%llu s:%llu b:%u f:%u\n",
 +		       (unsigned long long)rs->rs_inum,
++=======
+ /**
+  * gfs2_rsqa_alloc - make sure we have a reservation assigned to the inode
+  *                 plus a quota allocations data structure, if necessary
+  * @ip: the inode for this reservation
+  */
+ int gfs2_rsqa_alloc(struct gfs2_inode *ip)
+ {
+ 	return gfs2_qa_alloc(ip);
+ }
+ 
+ static void dump_rs(struct seq_file *seq, const struct gfs2_blkreserv *rs,
+ 		    const char *fs_id_buf)
+ {
+ 	struct gfs2_inode *ip = container_of(rs, struct gfs2_inode, i_res);
+ 
+ 	gfs2_print_dbg(seq, "%s  B: n:%llu s:%llu b:%u f:%u\n", fs_id_buf,
+ 		       (unsigned long long)ip->i_no_addr,
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  		       (unsigned long long)gfs2_rbm_to_block(&rs->rs_rbm),
  		       rs->rs_rbm.offset, rs->rs_free);
  }
@@@ -2180,15 -2251,17 +2201,26 @@@ static struct gfs2_rgrpd *rgblk_free(st
   *
   */
  
++<<<<<<< HEAD
 +int gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl)
++=======
+ void gfs2_rgrp_dump(struct seq_file *seq, struct gfs2_glock *gl,
+ 		    const char *fs_id_buf)
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  {
  	struct gfs2_rgrpd *rgd = gl->gl_object;
  	struct gfs2_blkreserv *trs;
  	const struct rb_node *n;
  
  	if (rgd == NULL)
++<<<<<<< HEAD
 +		return 0;
 +	gfs2_print_dbg(seq, " R: n:%llu f:%02x b:%u/%u i:%u r:%u e:%u\n",
++=======
+ 		return;
+ 	gfs2_print_dbg(seq, "%s R: n:%llu f:%02x b:%u/%u i:%u r:%u e:%u\n",
+ 		       fs_id_buf,
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  		       (unsigned long long)rgd->rd_addr, rgd->rd_flags,
  		       rgd->rd_free, rgd->rd_free_clone, rgd->rd_dinodes,
  		       rgd->rd_reserved, rgd->rd_extfail_pt);
@@@ -2203,10 -2276,9 +2235,10 @@@
  	spin_lock(&rgd->rd_rsspin);
  	for (n = rb_first(&rgd->rd_rstree); n; n = rb_next(&trs->rs_node)) {
  		trs = rb_entry(n, struct gfs2_blkreserv, rs_node);
- 		dump_rs(seq, trs);
+ 		dump_rs(seq, trs, fs_id_buf);
  	}
  	spin_unlock(&rgd->rd_rsspin);
 +	return 0;
  }
  
  static void gfs2_rgrp_error(struct gfs2_rgrpd *rgd)
diff --cc fs/gfs2/rgrp.h
index b796c5b66972,c14a673ae36f..000000000000
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@@ -67,10 -66,11 +67,15 @@@ struct gfs2_rgrp_list 
  
  extern void gfs2_rlist_add(struct gfs2_inode *ip, struct gfs2_rgrp_list *rlist,
  			   u64 block);
 -extern void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist);
 +extern void gfs2_rlist_alloc(struct gfs2_rgrp_list *rlist, unsigned int state);
  extern void gfs2_rlist_free(struct gfs2_rgrp_list *rlist);
  extern u64 gfs2_ri_total(struct gfs2_sbd *sdp);
++<<<<<<< HEAD
 +extern int gfs2_rgrp_dump(struct seq_file *seq, const struct gfs2_glock *gl);
++=======
+ extern void gfs2_rgrp_dump(struct seq_file *seq, struct gfs2_glock *gl,
+ 			   const char *fs_id_buf);
++>>>>>>> 3792ce973f07 (gfs2: dump fsid when dumping glock problems)
  extern int gfs2_rgrp_send_discards(struct gfs2_sbd *sdp, u64 offset,
  				   struct buffer_head *bh,
  				   const struct gfs2_bitmap *bi, unsigned minlen, u64 *ptrimmed);
* Unmerged path fs/gfs2/glock.c
* Unmerged path fs/gfs2/glock.h
* Unmerged path fs/gfs2/glops.c
* Unmerged path fs/gfs2/incore.h
diff --git a/fs/gfs2/lops.c b/fs/gfs2/lops.c
index b6ef974ca30d..66689b2edf6a 100644
--- a/fs/gfs2/lops.c
+++ b/fs/gfs2/lops.c
@@ -778,7 +778,7 @@ static int buf_lo_scan_elements(struct gfs2_jdesc *jd, unsigned int start,
 					fs_info(sdp, "busy:%d, pinned:%d\n",
 						buffer_busy(rgd->rd_bits->bi_bh) ? 1 : 0,
 						buffer_pinned(rgd->rd_bits->bi_bh));
-					gfs2_dump_glock(NULL, rgd->rd_gl);
+					gfs2_dump_glock(NULL, rgd->rd_gl, true);
 				}
 			}
 			mark_buffer_dirty(bh_ip);
* Unmerged path fs/gfs2/rgrp.c
* Unmerged path fs/gfs2/rgrp.h
diff --git a/fs/gfs2/util.c b/fs/gfs2/util.c
index d62797b79ef2..9a381a432531 100644
--- a/fs/gfs2/util.c
+++ b/fs/gfs2/util.c
@@ -179,9 +179,11 @@ int gfs2_consist_rgrpd_i(struct gfs2_rgrpd *rgd, int cluster_wide,
 			 const char *function, char *file, unsigned int line)
 {
 	struct gfs2_sbd *sdp = rgd->rd_sbd;
+	char fs_id_buf[GFS2_FSNAME_LEN + 3 * sizeof(int) + 2];
 	int rv;
 
-	gfs2_rgrp_dump(NULL, rgd->rd_gl);
+	sprintf(fs_id_buf, "fsid=%s: ", sdp->sd_fsname);
+	gfs2_rgrp_dump(NULL, rgd->rd_gl, fs_id_buf);
 	rv = gfs2_lm_withdraw(sdp,
 		"GFS2: fsid=%s: fatal: filesystem consistency error\n"
 		"GFS2: fsid=%s:   RG = %llu\n"
