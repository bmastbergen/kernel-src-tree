gfs2: Introduce function gfs2_withdrawn

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.53.1.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit eb43e660c094029fc1165e2641ce06c153129bdd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.53.1.el7/eb43e660.failed

Add function gfs2_withdrawn and replace all checks for the SDF_WITHDRAWN
bit to call it. This does not change the logic or function of gfs2, and
it facilitates later improvements to the withdraw sequence.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit eb43e660c094029fc1165e2641ce06c153129bdd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/aops.c
#	fs/gfs2/file.c
#	fs/gfs2/glock.c
#	fs/gfs2/glops.c
#	fs/gfs2/meta_io.c
#	fs/gfs2/ops_fstype.c
#	fs/gfs2/quota.c
#	fs/gfs2/super.c
#	fs/gfs2/sys.c
#	fs/gfs2/util.c
diff --cc fs/gfs2/aops.c
index 0b7cbf658c05,9c6df721321a..000000000000
--- a/fs/gfs2/aops.c
+++ b/fs/gfs2/aops.c
@@@ -539,7 -497,7 +539,11 @@@ static int __gfs2_readpage(void *file, 
  		error = mpage_readpage(page, gfs2_block_map);
  	}
  
++<<<<<<< HEAD
 +	if (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))
++=======
+ 	if (unlikely(gfs2_withdrawn(sdp)))
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  		return -EIO;
  
  	return error;
@@@ -653,7 -614,7 +657,11 @@@ static int gfs2_readpages(struct file *
  	gfs2_glock_dq(&gh);
  out_uninit:
  	gfs2_holder_uninit(&gh);
++<<<<<<< HEAD
 +	if (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))
++=======
+ 	if (unlikely(gfs2_withdrawn(sdp)))
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  		ret = -EIO;
  	return ret;
  }
diff --cc fs/gfs2/file.c
index 90830069086c,62cc5bd12d09..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -1116,7 -1194,7 +1116,11 @@@ static int gfs2_lock(struct file *file
  		cmd = F_SETLK;
  		fl->fl_type = F_UNLCK;
  	}
++<<<<<<< HEAD
 +	if (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {
++=======
+ 	if (unlikely(gfs2_withdrawn(sdp))) {
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  		if (fl->fl_type == F_UNLCK)
  			locks_lock_file_wait(file, fl);
  		return -EIO;
diff --cc fs/gfs2/glock.c
index d5f0bcb8970e,faa88bd594e2..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -551,7 -549,7 +551,11 @@@ __acquires(&gl->gl_lockref.lock
  	unsigned int lck_flags = (unsigned int)(gh ? gh->gh_flags : 0);
  	int ret;
  
++<<<<<<< HEAD
 +	if (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)) &&
++=======
+ 	if (unlikely(gfs2_withdrawn(sdp)) &&
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  	    target != LM_ST_UNLOCKED)
  		return;
  	lck_flags &= (LM_FLAG_TRY | LM_FLAG_TRY_1CB | LM_FLAG_NOEXP |
@@@ -587,9 -585,8 +591,14 @@@
  			gfs2_glock_queue_work(gl, 0);
  		}
  		else if (ret) {
++<<<<<<< HEAD
 +			printk(KERN_ERR "GFS2: lm_lock ret %d\n", ret);
 +			GLOCK_BUG_ON(gl, !test_bit(SDF_SHUTDOWN,
 +						   &sdp->sd_flags));
++=======
+ 			fs_err(sdp, "lm_lock ret %d\n", ret);
+ 			GLOCK_BUG_ON(gl, !gfs2_withdrawn(sdp));
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  		}
  	} else { /* lock_nolock */
  		finish_xmote(gl, target);
@@@ -1204,7 -1190,7 +1213,11 @@@ int gfs2_glock_nq(struct gfs2_holder *g
  	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
  	int error = 0;
  
++<<<<<<< HEAD
 +	if (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))
++=======
+ 	if (unlikely(gfs2_withdrawn(sdp)))
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  		return -EIO;
  
  	if (test_bit(GLF_LRU, &gl->gl_flags))
diff --cc fs/gfs2/glops.c
index 90b93ba7dd9f,4ede1f18de85..000000000000
--- a/fs/gfs2/glops.c
+++ b/fs/gfs2/glops.c
@@@ -520,7 -540,7 +520,11 @@@ static int trans_go_xmote_bh(struct gfs
  			gfs2_consist(sdp);
  
  		/*  Initialize some head of the log stuff  */
++<<<<<<< HEAD
 +		if (!test_bit(SDF_SHUTDOWN, &sdp->sd_flags)) {
++=======
+ 		if (!gfs2_withdrawn(sdp)) {
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  			sdp->sd_log_sequence = head.lh_sequence + 1;
  			gfs2_log_pointers_init(sdp, head.lh_blkno);
  		}
diff --cc fs/gfs2/meta_io.c
index 8efc17222f4f,0c3772974030..000000000000
--- a/fs/gfs2/meta_io.c
+++ b/fs/gfs2/meta_io.c
@@@ -264,7 -251,7 +264,11 @@@ int gfs2_meta_read(struct gfs2_glock *g
  	struct buffer_head *bh, *bhs[2];
  	int num = 0;
  
++<<<<<<< HEAD
 +	if (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {
++=======
+ 	if (unlikely(gfs2_withdrawn(sdp))) {
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  		*bhp = NULL;
  		return -EIO;
  	}
@@@ -322,7 -309,7 +326,11 @@@
  
  int gfs2_meta_wait(struct gfs2_sbd *sdp, struct buffer_head *bh)
  {
++<<<<<<< HEAD
 +	if (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))
++=======
+ 	if (unlikely(gfs2_withdrawn(sdp)))
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  		return -EIO;
  
  	wait_on_buffer(bh);
@@@ -330,10 -317,10 +338,14 @@@
  	if (!buffer_uptodate(bh)) {
  		struct gfs2_trans *tr = current->journal_info;
  		if (tr && test_bit(TR_TOUCHED, &tr->tr_flags))
 -			gfs2_io_error_bh_wd(sdp, bh);
 +			gfs2_io_error_bh(sdp, bh);
  		return -EIO;
  	}
++<<<<<<< HEAD
 +	if (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))
++=======
+ 	if (unlikely(gfs2_withdrawn(sdp)))
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  		return -EIO;
  
  	return 0;
diff --cc fs/gfs2/ops_fstype.c
index cc0fc48b4376,e8b7b0ce8404..000000000000
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@@ -989,8 -1006,7 +989,12 @@@ hostdata_error
  void gfs2_lm_unmount(struct gfs2_sbd *sdp)
  {
  	const struct lm_lockops *lm = sdp->sd_lockstruct.ls_ops;
++<<<<<<< HEAD
 +	if (likely(!test_bit(SDF_SHUTDOWN, &sdp->sd_flags)) &&
 +	    lm->lm_unmount)
++=======
+ 	if (likely(!gfs2_withdrawn(sdp)) && lm->lm_unmount)
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  		lm->lm_unmount(sdp);
  }
  
diff --cc fs/gfs2/quota.c
index e2f42a2af815,e9f93045eb01..000000000000
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@@ -1488,7 -1475,7 +1488,11 @@@ static void quotad_error(struct gfs2_sb
  {
  	if (error == 0 || error == -EROFS)
  		return;
++<<<<<<< HEAD
 +	if (!test_bit(SDF_SHUTDOWN, &sdp->sd_flags)) {
++=======
+ 	if (!gfs2_withdrawn(sdp)) {
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  		fs_err(sdp, "gfs2_quotad: %s error %d\n", msg, error);
  		sdp->sd_log_error = error;
  		wake_up(&sdp->sd_logd_waitq);
diff --cc fs/gfs2/super.c
index fac088989e79,478015bc6890..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -797,9 -551,9 +797,13 @@@ static void gfs2_dirty_inode(struct ino
  	int need_endtrans = 0;
  	int ret;
  
 -	if (!(flags & I_DIRTY_INODE))
 +	if (!(flags & (I_DIRTY_DATASYNC|I_DIRTY_SYNC)))
  		return;
++<<<<<<< HEAD
 +	if (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))
++=======
+ 	if (unlikely(gfs2_withdrawn(sdp)))
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  		return;
  	if (!gfs2_glock_is_locked_by_me(ip->i_gl)) {
  		ret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);
@@@ -841,21 -595,24 +845,28 @@@ out
   * Returns: errno
   */
  
 -int gfs2_make_fs_ro(struct gfs2_sbd *sdp)
 +static int gfs2_make_fs_ro(struct gfs2_sbd *sdp)
  {
 -	struct gfs2_holder freeze_gh;
 +	struct gfs2_holder t_gh;
  	int error;
  
++<<<<<<< HEAD
 +	if (sdp->sd_quotad_process) {
 +		kthread_stop(sdp->sd_quotad_process);
 +		sdp->sd_quotad_process = NULL;
 +	}
 +	if (sdp->sd_logd_process) {
 +		kthread_stop(sdp->sd_logd_process);
 +		sdp->sd_logd_process = NULL;
 +	}
++=======
+ 	error = gfs2_glock_nq_init(sdp->sd_freeze_gl, LM_ST_SHARED, GL_NOCACHE,
+ 				   &freeze_gh);
+ 	if (error && !gfs2_withdrawn(sdp))
+ 		return error;
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  
  	flush_workqueue(gfs2_delete_workqueue);
 -	if (sdp->sd_quotad_process)
 -		kthread_stop(sdp->sd_quotad_process);
 -	sdp->sd_quotad_process = NULL;
 -	if (sdp->sd_logd_process)
 -		kthread_stop(sdp->sd_logd_process);
 -	sdp->sd_logd_process = NULL;
 -
  	gfs2_quota_sync(sdp->sd_vfs, 0);
  	gfs2_statfs_sync(sdp->sd_vfs, 0);
  
@@@ -970,10 -755,16 +981,21 @@@ static int gfs2_sync_fs(struct super_bl
  static int gfs2_freeze(struct super_block *sb)
  {
  	struct gfs2_sbd *sdp = sb->s_fs_info;
 -	int error = 0;
 +	int error;
  
++<<<<<<< HEAD
 +	if (test_bit(SDF_SHUTDOWN, &sdp->sd_flags))
 +		return -EINVAL;
++=======
+ 	mutex_lock(&sdp->sd_freeze_mutex);
+ 	if (atomic_read(&sdp->sd_freeze_state) != SFS_UNFROZEN)
+ 		goto out;
+ 
+ 	if (gfs2_withdrawn(sdp)) {
+ 		error = -EINVAL;
+ 		goto out;
+ 	}
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  
  	for (;;) {
  		error = gfs2_lock_fs_check_clean(sdp, &sdp->sd_freeze_gh);
diff --cc fs/gfs2/sys.c
index 66e85f87e8c9,8ccb68f4ed16..000000000000
--- a/fs/gfs2/sys.c
+++ b/fs/gfs2/sys.c
@@@ -126,7 -118,7 +126,11 @@@ static ssize_t freeze_store(struct gfs2
  
  static ssize_t withdraw_show(struct gfs2_sbd *sdp, char *buf)
  {
++<<<<<<< HEAD
 +	unsigned int b = test_bit(SDF_SHUTDOWN, &sdp->sd_flags);
++=======
+ 	unsigned int b = gfs2_withdrawn(sdp);
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  	return snprintf(buf, PAGE_SIZE, "%u\n", b);
  }
  
diff --cc fs/gfs2/util.c
index d62797b79ef2,ec600b487498..000000000000
--- a/fs/gfs2/util.c
+++ b/fs/gfs2/util.c
@@@ -253,21 -250,22 +253,33 @@@ int gfs2_io_error_i(struct gfs2_sbd *sd
  }
  
  /**
 - * gfs2_io_error_bh_i - Flag a buffer I/O error
 - * @withdraw: withdraw the filesystem
 + * gfs2_io_error_bh_i - Flag a buffer I/O error and withdraw
 + * Returns: -1 if this call withdrew the machine,
 + *          0 if it was already withdrawn
   */
  
 -void gfs2_io_error_bh_i(struct gfs2_sbd *sdp, struct buffer_head *bh,
 -			const char *function, char *file, unsigned int line,
 -			bool withdraw)
 +int gfs2_io_error_bh_i(struct gfs2_sbd *sdp, struct buffer_head *bh,
 +		       const char *function, char *file, unsigned int line)
  {
++<<<<<<< HEAD
 +	int rv;
 +	rv = gfs2_lm_withdraw(sdp,
 +		"GFS2: fsid=%s: fatal: I/O error\n"
 +		"GFS2: fsid=%s:   block = %llu\n"
 +		"GFS2: fsid=%s:   function = %s, file = %s, line = %u\n",
 +		sdp->sd_fsname,
 +		sdp->sd_fsname, (unsigned long long)bh->b_blocknr,
 +		sdp->sd_fsname, function, file, line);
 +	return rv;
++=======
+ 	if (!gfs2_withdrawn(sdp))
+ 		fs_err(sdp,
+ 		       "fatal: I/O error\n"
+ 		       "  block = %llu\n"
+ 		       "  function = %s, file = %s, line = %u\n",
+ 		       (unsigned long long)bh->b_blocknr,
+ 		       function, file, line);
+ 	if (withdraw)
+ 		gfs2_lm_withdraw(sdp, NULL);
++>>>>>>> eb43e660c094 (gfs2: Introduce function gfs2_withdrawn)
  }
 -
* Unmerged path fs/gfs2/aops.c
* Unmerged path fs/gfs2/file.c
* Unmerged path fs/gfs2/glock.c
* Unmerged path fs/gfs2/glops.c
* Unmerged path fs/gfs2/meta_io.c
* Unmerged path fs/gfs2/ops_fstype.c
* Unmerged path fs/gfs2/quota.c
* Unmerged path fs/gfs2/super.c
* Unmerged path fs/gfs2/sys.c
* Unmerged path fs/gfs2/util.c
diff --git a/fs/gfs2/util.h b/fs/gfs2/util.h
index 136b196396ef..fe80cc8a56ea 100644
--- a/fs/gfs2/util.h
+++ b/fs/gfs2/util.h
@@ -161,6 +161,15 @@ static inline unsigned int gfs2_tune_get_i(struct gfs2_tune *gt,
 	return x;
 }
 
+/**
+ * gfs2_withdrawn - test whether the file system is withdrawing or withdrawn
+ * @sdp: the superblock
+ */
+static inline bool gfs2_withdrawn(struct gfs2_sbd *sdp)
+{
+	return test_bit(SDF_WITHDRAWN, &sdp->sd_flags);
+}
+
 #define gfs2_tune_get(sdp, field) \
 gfs2_tune_get_i(&(sdp)->sd_tune, &(sdp)->sd_tune.field)
 
