GFS2: Use pr_<level> more consistently

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.53.1.el7
commit-author Joe Perches <joe@perches.com>
commit d77d1b58aaf4456946b8502c67f16b52fda60303
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.53.1.el7/d77d1b58.failed

Add pr_fmt, remove embedded "GFS2: " prefixes.
This now consistently emits lower case "gfs2: " for each message.

Other miscellanea around these changes:

o Add missing newlines
o Coalesce formats
o Realign arguments

	Signed-off-by: Joe Perches <joe@perches.com>
	Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

(cherry picked from commit d77d1b58aaf4456946b8502c67f16b52fda60303)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/dir.c
#	fs/gfs2/glock.c
#	fs/gfs2/lock_dlm.c
#	fs/gfs2/ops_fstype.c
#	fs/gfs2/quota.c
#	fs/gfs2/rgrp.c
#	fs/gfs2/super.c
#	fs/gfs2/trans.c
#	fs/gfs2/util.c
diff --cc fs/gfs2/dir.c
index 25056e88a1cc,1a349f9a9685..000000000000
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@@ -533,8 -509,8 +535,13 @@@ static int gfs2_check_dirent(struct gfs
  		goto error;
  	return 0;
  error:
++<<<<<<< HEAD
 +	printk(KERN_WARNING "gfs2_check_dirent: %s (%s)\n", msg,
 +	       first ? "first in block" : "not first in block");
++=======
+ 	pr_warn("%s: %s (%s)\n",
+ 		__func__, msg, first ? "first in block" : "not first in block");
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  	return -EIO;
  }
  
@@@ -557,8 -533,7 +564,12 @@@ static int gfs2_dirent_offset(const voi
  	}
  	return offset;
  wrong_type:
++<<<<<<< HEAD
 +	printk(KERN_WARNING "gfs2_scan_dirent: wrong block type %u\n",
 +	       be32_to_cpu(h->mh_type));
++=======
+ 	pr_warn("%s: wrong block type %u\n", __func__, be32_to_cpu(h->mh_type));
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  	return -1;
  }
  
@@@ -767,9 -727,9 +778,9 @@@ static int get_leaf(struct gfs2_inode *
  {
  	int error;
  
 -	error = gfs2_meta_read(dip->i_gl, leaf_no, DIO_WAIT, bhp);
 +	error = gfs2_meta_read(dip->i_gl, leaf_no, DIO_WAIT, 0, bhp);
  	if (!error && gfs2_metatype_check(GFS2_SB(&dip->i_inode), *bhp, GFS2_METATYPE_LF)) {
- 		/* printk(KERN_INFO "block num=%llu\n", leaf_no); */
+ 		/* pr_info("block num=%llu\n", leaf_no); */
  		error = -EIO;
  	}
  
@@@ -1050,7 -1007,8 +1061,12 @@@ static int dir_split_leaf(struct inode 
  	len = 1 << (dip->i_depth - be16_to_cpu(oleaf->lf_depth));
  	half_len = len >> 1;
  	if (!half_len) {
++<<<<<<< HEAD
 +		printk(KERN_WARNING "i_depth %u lf_depth %u index %u\n", dip->i_depth, be16_to_cpu(oleaf->lf_depth), index);
++=======
+ 		pr_warn("i_depth %u lf_depth %u index %u\n",
+ 			dip->i_depth, be16_to_cpu(oleaf->lf_depth), index);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  		gfs2_consist_inode(dip);
  		error = -EIO;
  		goto fail_brelse;
diff --cc fs/gfs2/glock.c
index d5f0bcb8970e,52f747858f55..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -504,10 -470,10 +506,14 @@@ retry
  			do_xmote(gl, gh, LM_ST_UNLOCKED);
  			break;
  		default: /* Everything else */
++<<<<<<< HEAD
 +			printk(KERN_ERR "GFS2: wanted %u got %u\n", gl->gl_target, state);
++=======
+ 			pr_err("wanted %u got %u\n", gl->gl_target, state);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  			GLOCK_BUG_ON(gl, 1);
  		}
 -		spin_unlock(&gl->gl_spin);
 +		spin_unlock(&gl->gl_lockref.lock);
  		return;
  	}
  
@@@ -580,16 -543,9 +586,22 @@@ __acquires(&gl->gl_lockref.lock
  	if (sdp->sd_lockstruct.ls_ops->lm_lock)	{
  		/* lock_dlm */
  		ret = sdp->sd_lockstruct.ls_ops->lm_lock(gl, target, lck_flags);
++<<<<<<< HEAD
 +		if (ret == -EINVAL && gl->gl_target == LM_ST_UNLOCKED &&
 +		    target == LM_ST_UNLOCKED &&
 +		    test_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags)) {
 +			finish_xmote(gl, target);
 +			gfs2_glock_queue_work(gl, 0);
 +		}
 +		else if (ret) {
 +			printk(KERN_ERR "GFS2: lm_lock ret %d\n", ret);
 +			GLOCK_BUG_ON(gl, !test_bit(SDF_SHUTDOWN,
 +						   &sdp->sd_flags));
++=======
+ 		if (ret) {
+ 			pr_err("lm_lock ret %d\n", ret);
+ 			GLOCK_BUG_ON(gl, 1);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  		}
  	} else { /* lock_nolock */
  		finish_xmote(gl, target);
@@@ -1102,7 -937,7 +1114,11 @@@ void gfs2_print_dbg(struct seq_file *se
  		vaf.fmt = fmt;
  		vaf.va = &args;
  
++<<<<<<< HEAD
 +		printk(KERN_ERR " %pV", &vaf);
++=======
+ 		pr_err("%pV", &vaf);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  	}
  
  	va_end(args);
diff --cc fs/gfs2/lock_dlm.c
index 6baae5087837,c1eb555dc588..000000000000
--- a/fs/gfs2/lock_dlm.c
+++ b/fs/gfs2/lock_dlm.c
@@@ -176,7 -178,7 +178,11 @@@ static void gdlm_bast(void *arg, int mo
  		gfs2_glock_cb(gl, LM_ST_SHARED);
  		break;
  	default:
++<<<<<<< HEAD
 +		printk(KERN_ERR "unknown bast mode %d", mode);
++=======
+ 		pr_err("unknown bast mode %d\n", mode);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  		BUG();
  	}
  }
@@@ -195,7 -197,7 +201,11 @@@ static int make_mode(const unsigned in
  	case LM_ST_SHARED:
  		return DLM_LOCK_PR;
  	}
++<<<<<<< HEAD
 +	printk(KERN_ERR "unknown LM state %d", lmstate);
++=======
+ 	pr_err("unknown LM state %d\n", lmstate);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  	BUG();
  	return -1;
  }
@@@ -308,7 -310,7 +318,11 @@@ static void gdlm_put_lock(struct gfs2_g
  	error = dlm_unlock(ls->ls_dlm, gl->gl_lksb.sb_lkid, DLM_LKF_VALBLK,
  			   NULL, gl);
  	if (error) {
++<<<<<<< HEAD
 +		printk(KERN_ERR "gdlm_unlock %x,%llx err=%d\n",
++=======
+ 		pr_err("gdlm_unlock %x,%llx err=%d\n",
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  		       gl->gl_name.ln_type,
  		       (unsigned long long)gl->gl_name.ln_number, error);
  		return;
diff --cc fs/gfs2/ops_fstype.c
index cc0fc48b4376,fba74a26a6a3..000000000000
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@@ -148,7 -152,7 +150,11 @@@ static int gfs2_check_sb(struct gfs2_sb
  	if (sb->sb_magic != GFS2_MAGIC ||
  	    sb->sb_type != GFS2_METATYPE_SB) {
  		if (!silent)
++<<<<<<< HEAD
 +			printk(KERN_WARNING "GFS2: not a GFS2 filesystem\n");
++=======
+ 			pr_warn("not a GFS2 filesystem\n");
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  		return -EINVAL;
  	}
  
@@@ -170,7 -174,7 +176,11 @@@ static void end_bio_io_page(struct bio 
  	if (!error)
  		SetPageUptodate(page);
  	else
++<<<<<<< HEAD
 +		printk(KERN_WARNING "gfs2: error %d reading superblock\n", error);
++=======
+ 		pr_warn("error %d reading superblock\n", error);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  	unlock_page(page);
  }
  
@@@ -931,7 -947,7 +941,11 @@@ static int gfs2_lm_mount(struct gfs2_sb
  		lm = &gfs2_dlm_ops;
  #endif
  	} else {
++<<<<<<< HEAD
 +		printk(KERN_INFO "GFS2: can't find protocol %s\n", proto);
++=======
+ 		pr_info("can't find protocol %s\n", proto);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  		return -ENOENT;
  	}
  
@@@ -1031,7 -1054,7 +1045,11 @@@ static int fill_super(struct super_bloc
  
  	sdp = init_sbd(sb);
  	if (!sdp) {
++<<<<<<< HEAD
 +		printk(KERN_WARNING "GFS2: can't alloc struct gfs2_sbd\n");
++=======
+ 		pr_warn("can't alloc struct gfs2_sbd\n");
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  		return -ENOMEM;
  	}
  	sdp->sd_args = *args;
@@@ -1271,7 -1302,7 +1289,11 @@@ static struct dentry *gfs2_mount(struc
  
  	error = gfs2_mount_args(&args, data);
  	if (error) {
++<<<<<<< HEAD
 +		printk(KERN_WARNING "GFS2: can't parse mount arguments\n");
++=======
+ 		pr_warn("can't parse mount arguments\n");
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  		goto error_super;
  	}
  
@@@ -1318,20 -1350,17 +1340,29 @@@ static struct dentry *gfs2_mount_meta(s
  	struct path path;
  	int error;
  
 +	if (!dev_name)
 +		return ERR_PTR(-EINVAL);
 +
  	error = kern_path(dev_name, LOOKUP_FOLLOW, &path);
  	if (error) {
++<<<<<<< HEAD
 +		printk(KERN_WARNING "GFS2: path_lookup on %s returned error %d\n",
 +		       dev_name, error);
++=======
+ 		pr_warn("path_lookup on %s returned error %d\n",
+ 			dev_name, error);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  		return ERR_PTR(error);
  	}
  	s = sget(&gfs2_fs_type, test_gfs2_super, set_meta_super, flags,
  		 path.dentry->d_inode->i_sb->s_bdev);
  	path_put(&path);
  	if (IS_ERR(s)) {
++<<<<<<< HEAD
 +		printk(KERN_WARNING "GFS2: gfs2 mount does not exist\n");
++=======
+ 		pr_warn("gfs2 mount does not exist\n");
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  		return ERR_CAST(s);
  	}
  	if ((flags ^ s->s_flags) & MS_RDONLY) {
diff --cc fs/gfs2/quota.c
index e2f42a2af815,73ed92535c8a..000000000000
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@@ -1161,12 -1081,12 +1163,19 @@@ void gfs2_quota_unlock(struct gfs2_inod
  
  static int print_message(struct gfs2_quota_data *qd, char *type)
  {
 -	struct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;
 -
 +	struct gfs2_sbd *sdp = qd->qd_gl->gl_name.ln_sbd;
 +
++<<<<<<< HEAD
 +	printk(KERN_INFO "GFS2: fsid=%s: quota %s for %s %u\n",
 +	       sdp->sd_fsname, type,
 +	       (qd->qd_id.type == USRQUOTA) ? "user" : "group",
 +	       from_kqid(&init_user_ns, qd->qd_id));
++=======
+ 	pr_info("fsid=%s: quota %s for %s %u\n",
+ 		sdp->sd_fsname, type,
+ 		(qd->qd_id.type == USRQUOTA) ? "user" : "group",
+ 		from_kqid(&init_user_ns, qd->qd_id));
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  
  	return 0;
  }
diff --cc fs/gfs2/rgrp.c
index eebb1e1cfe40,281a7716e3f3..000000000000
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@@ -98,13 -101,12 +100,22 @@@ static inline void gfs2_setbit(const st
  	cur_state = (*byte1 >> bit) & GFS2_BIT_MASK;
  
  	if (unlikely(!valid_change[new_state * 4 + cur_state])) {
++<<<<<<< HEAD
 +		printk(KERN_WARNING "GFS2: buf_blk = 0x%x old_state=%d, "
 +		       "new_state=%d\n", rbm->offset, cur_state, new_state);
 +		printk(KERN_WARNING "GFS2: rgrp=0x%llx bi_start=0x%x\n",
 +		       (unsigned long long)rbm->rgd->rd_addr,
 +		       rbm->bi->bi_start);
 +		printk(KERN_WARNING "GFS2: bi_offset=0x%x bi_len=0x%x\n",
 +		       rbm->bi->bi_offset, rbm->bi->bi_len);
++=======
+ 		pr_warn("buf_blk = 0x%x old_state=%d, new_state=%d\n",
+ 			rbm->offset, cur_state, new_state);
+ 		pr_warn("rgrp=0x%llx bi_start=0x%x\n",
+ 			(unsigned long long)rbm->rgd->rd_addr, bi->bi_start);
+ 		pr_warn("bi_offset=0x%x bi_len=0x%x\n",
+ 			bi->bi_offset, bi->bi_len);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  		dump_stack();
  		gfs2_consist_rgrpd(rbm->rgd);
  		return;
@@@ -690,11 -738,11 +701,19 @@@ void gfs2_clear_rgrpd(struct gfs2_sbd *
  
  static void gfs2_rindex_print(const struct gfs2_rgrpd *rgd)
  {
++<<<<<<< HEAD
 +	printk(KERN_INFO "  ri_addr = %llu\n", (unsigned long long)rgd->rd_addr);
 +	printk(KERN_INFO "  ri_length = %u\n", rgd->rd_length);
 +	printk(KERN_INFO "  ri_data0 = %llu\n", (unsigned long long)rgd->rd_data0);
 +	printk(KERN_INFO "  ri_data = %u\n", rgd->rd_data);
 +	printk(KERN_INFO "  ri_bitbytes = %u\n", rgd->rd_bitbytes);
++=======
+ 	pr_info("ri_addr = %llu\n", (unsigned long long)rgd->rd_addr);
+ 	pr_info("ri_length = %u\n", rgd->rd_length);
+ 	pr_info("ri_data0 = %llu\n", (unsigned long long)rgd->rd_data0);
+ 	pr_info("ri_data = %u\n", rgd->rd_data);
+ 	pr_info("ri_bitbytes = %u\n", rgd->rd_bitbytes);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  }
  
  /**
diff --cc fs/gfs2/super.c
index fac088989e79,a08c66e270bf..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -180,8 -177,7 +182,12 @@@ int gfs2_mount_args(struct gfs2_args *a
  			break;
  		case Opt_debug:
  			if (args->ar_errors == GFS2_ERRORS_PANIC) {
++<<<<<<< HEAD
 +				printk(KERN_WARNING "GFS2: -o debug and -o errors=panic "
 +				       "are mutually exclusive.\n");
++=======
+ 				pr_warn("-o debug and -o errors=panic are mutually exclusive\n");
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  				return -EINVAL;
  			}
  			args->ar_debug = 1;
@@@ -233,21 -229,21 +239,33 @@@
  		case Opt_commit:
  			rv = match_int(&tmp[0], &args->ar_commit);
  			if (rv || args->ar_commit <= 0) {
++<<<<<<< HEAD
 +				printk(KERN_WARNING "GFS2: commit mount option requires a positive numeric argument\n");
++=======
+ 				pr_warn("commit mount option requires a positive numeric argument\n");
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  				return rv ? rv : -EINVAL;
  			}
  			break;
  		case Opt_statfs_quantum:
  			rv = match_int(&tmp[0], &args->ar_statfs_quantum);
  			if (rv || args->ar_statfs_quantum < 0) {
++<<<<<<< HEAD
 +				printk(KERN_WARNING "GFS2: statfs_quantum mount option requires a non-negative numeric argument\n");
++=======
+ 				pr_warn("statfs_quantum mount option requires a non-negative numeric argument\n");
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  				return rv ? rv : -EINVAL;
  			}
  			break;
  		case Opt_quota_quantum:
  			rv = match_int(&tmp[0], &args->ar_quota_quantum);
  			if (rv || args->ar_quota_quantum <= 0) {
++<<<<<<< HEAD
 +				printk(KERN_WARNING "GFS2: quota_quantum mount option requires a positive numeric argument\n");
++=======
+ 				pr_warn("quota_quantum mount option requires a positive numeric argument\n");
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  				return rv ? rv : -EINVAL;
  			}
  			break;
@@@ -264,8 -260,7 +282,12 @@@
  			break;
  		case Opt_err_panic:
  			if (args->ar_debug) {
++<<<<<<< HEAD
 +				printk(KERN_WARNING "GFS2: -o debug and -o errors=panic "
 +					"are mutually exclusive.\n");
++=======
+ 				pr_warn("-o debug and -o errors=panic are mutually exclusive\n");
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  				return -EINVAL;
  			}
  			args->ar_errors = GFS2_ERRORS_PANIC;
@@@ -282,15 -277,9 +304,19 @@@
  		case Opt_norgrplvb:
  			args->ar_rgrplvb = 0;
  			break;
 +		case Opt_loccookie:
 +			args->ar_loccookie = 1;
 +			break;
 +		case Opt_noloccookie:
 +			args->ar_loccookie = 0;
 +			break;
  		case Opt_error:
  		default:
++<<<<<<< HEAD
 +			printk(KERN_WARNING "GFS2: invalid mount option: %s\n", o);
++=======
+ 			pr_warn("invalid mount option: %s\n", o);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  			return -EINVAL;
  		}
  	}
diff --cc fs/gfs2/trans.c
index bd93fa2d7186,bead90d27bad..000000000000
--- a/fs/gfs2/trans.c
+++ b/fs/gfs2/trans.c
@@@ -99,15 -101,13 +101,25 @@@ static void gfs2_log_release(struct gfs
  
  static void gfs2_print_trans(const struct gfs2_trans *tr)
  {
++<<<<<<< HEAD
 +	printk(KERN_WARNING "GFS2: Transaction created at: %pSR\n",
 +	       (void *)tr->tr_ip);
 +	printk(KERN_WARNING "GFS2: blocks=%u revokes=%u reserved=%u touched=%d\n",
 +	       tr->tr_blocks, tr->tr_revokes, tr->tr_reserved,
 +	       test_bit(TR_TOUCHED, &tr->tr_flags));
 +	printk(KERN_WARNING "GFS2: Buf %u/%u Databuf %u/%u Revoke %u/%u\n",
 +	       tr->tr_num_buf_new, tr->tr_num_buf_rm,
 +	       tr->tr_num_databuf_new, tr->tr_num_databuf_rm,
 +	       tr->tr_num_revoke, tr->tr_num_revoke_rm);
++=======
+ 	pr_warn("Transaction created at: %pSR\n", (void *)tr->tr_ip);
+ 	pr_warn("blocks=%u revokes=%u reserved=%u touched=%u\n",
+ 		tr->tr_blocks, tr->tr_revokes, tr->tr_reserved, tr->tr_touched);
+ 	pr_warn("Buf %u/%u Databuf %u/%u Revoke %u/%u\n",
+ 		tr->tr_num_buf_new, tr->tr_num_buf_rm,
+ 		tr->tr_num_databuf_new, tr->tr_num_databuf_rm,
+ 		tr->tr_num_revoke, tr->tr_num_revoke_rm);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  }
  
  void gfs2_trans_end(struct gfs2_sbd *sdp)
@@@ -215,6 -220,30 +227,33 @@@ out
  	unlock_buffer(bh);
  }
  
++<<<<<<< HEAD
++=======
+ static void meta_lo_add(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)
+ {
+ 	struct gfs2_meta_header *mh;
+ 	struct gfs2_trans *tr;
+ 
+ 	tr = current->journal_info;
+ 	tr->tr_touched = 1;
+ 	if (!list_empty(&bd->bd_list))
+ 		return;
+ 	set_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);
+ 	set_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);
+ 	mh = (struct gfs2_meta_header *)bd->bd_bh->b_data;
+ 	if (unlikely(mh->mh_magic != cpu_to_be32(GFS2_MAGIC))) {
+ 		pr_err("Attempting to add uninitialised block to journal (inplace block=%lld)\n",
+ 		       (unsigned long long)bd->bd_bh->b_blocknr);
+ 		BUG();
+ 	}
+ 	gfs2_pin(sdp, bd->bd_bh);
+ 	mh->__pad0 = cpu_to_be64(0);
+ 	mh->mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);
+ 	list_add(&bd->bd_list, &tr->tr_buf);
+ 	tr->tr_num_buf_new++;
+ }
+ 
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  void gfs2_trans_add_meta(struct gfs2_glock *gl, struct buffer_head *bh)
  {
  
diff --cc fs/gfs2/util.c
index d62797b79ef2,02fb38db9d19..000000000000
--- a/fs/gfs2/util.c
+++ b/fs/gfs2/util.c
@@@ -31,8 -32,7 +33,12 @@@ mempool_t *gfs2_page_pool __read_mostly
  
  void gfs2_assert_i(struct gfs2_sbd *sdp)
  {
++<<<<<<< HEAD
 +	printk(KERN_EMERG "GFS2: fsid=%s: fatal assertion failed\n",
 +	       sdp->sd_fsname);
++=======
+ 	pr_emerg("fsid=%s: fatal assertion failed\n", sdp->sd_fsname);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  }
  
  int gfs2_lm_withdraw(struct gfs2_sbd *sdp, char *fmt, ...)
@@@ -107,11 -106,8 +113,16 @@@ int gfs2_assert_warn_i(struct gfs2_sbd 
  		return -2;
  
  	if (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW)
++<<<<<<< HEAD
 +		printk(KERN_WARNING
 +		       "GFS2: fsid=%s: warning: assertion \"%s\" failed\n"
 +		       "GFS2: fsid=%s:   function = %s, file = %s, line = %u\n",
 +		       sdp->sd_fsname, assertion,
 +		       sdp->sd_fsname, function, file, line);
++=======
+ 		pr_warn("fsid=%s: warning: assertion \"%s\" failed at function = %s, file = %s, line = %u\n",
+ 			sdp->sd_fsname, assertion, function, file, line);
++>>>>>>> d77d1b58aaf4 (GFS2: Use pr_<level> more consistently)
  
  	if (sdp->sd_args.ar_debug)
  		BUG();
* Unmerged path fs/gfs2/dir.c
* Unmerged path fs/gfs2/glock.c
* Unmerged path fs/gfs2/lock_dlm.c
diff --git a/fs/gfs2/main.c b/fs/gfs2/main.c
index 84f608eaff09..a5007369f64a 100644
--- a/fs/gfs2/main.c
+++ b/fs/gfs2/main.c
@@ -7,6 +7,8 @@
  * of the GNU General Public License version 2.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/completion.h>
* Unmerged path fs/gfs2/ops_fstype.c
* Unmerged path fs/gfs2/quota.c
* Unmerged path fs/gfs2/rgrp.c
* Unmerged path fs/gfs2/super.c
diff --git a/fs/gfs2/sys.c b/fs/gfs2/sys.c
index 66e85f87e8c9..3704f8d5e374 100644
--- a/fs/gfs2/sys.c
+++ b/fs/gfs2/sys.c
@@ -7,6 +7,8 @@
  * of the GNU General Public License version 2.
  */
 
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/sched.h>
 #include <linux/spinlock.h>
 #include <linux/completion.h>
* Unmerged path fs/gfs2/trans.c
* Unmerged path fs/gfs2/util.c
diff --git a/fs/gfs2/util.h b/fs/gfs2/util.h
index 136b196396ef..30a55eee9361 100644
--- a/fs/gfs2/util.h
+++ b/fs/gfs2/util.h
@@ -10,22 +10,21 @@
 #ifndef __UTIL_DOT_H__
 #define __UTIL_DOT_H__
 
+#ifdef pr_fmt
+#undef pr_fmt
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#endif
+
 #include <linux/mempool.h>
 
 #include "incore.h"
 
-#define fs_printk(level, fs, fmt, arg...) \
-	printk(level "GFS2: fsid=%s: " fmt , (fs)->sd_fsname , ## arg)
-
-#define fs_info(fs, fmt, arg...) \
-	fs_printk(KERN_INFO , fs , fmt , ## arg)
-
-#define fs_warn(fs, fmt, arg...) \
-	fs_printk(KERN_WARNING , fs , fmt , ## arg)
-
-#define fs_err(fs, fmt, arg...) \
-	fs_printk(KERN_ERR, fs , fmt , ## arg)
-
+#define fs_warn(fs, fmt, ...)						\
+	pr_warn("fsid=%s: " fmt, (fs)->sd_fsname, ##__VA_ARGS__)
+#define fs_err(fs, fmt, ...)						\
+	pr_err("fsid=%s: " fmt, (fs)->sd_fsname, ##__VA_ARGS__)
+#define fs_info(fs, fmt, ...)						\
+	pr_info("fsid=%s: " fmt, (fs)->sd_fsname, ##__VA_ARGS__)
 
 void gfs2_assert_i(struct gfs2_sbd *sdp);
 
@@ -85,7 +84,7 @@ static inline int gfs2_meta_check(struct gfs2_sbd *sdp,
 	struct gfs2_meta_header *mh = (struct gfs2_meta_header *)bh->b_data;
 	u32 magic = be32_to_cpu(mh->mh_magic);
 	if (unlikely(magic != GFS2_MAGIC)) {
-		printk(KERN_ERR "GFS2: Magic number missing at %llu\n",
+		pr_err("Magic number missing at %llu\n",
 		       (unsigned long long)bh->b_blocknr);
 		return -EIO;
 	}
