gfs2: slow the deluge of io error messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.53.1.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit b524abcc01483b2ac093cc6a8a2a7375558d2b64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.53.1.el7/b524abcc.failed

When an io error is hit, it calls gfs2_io_error_bh_i for every
journal buffer it can't write. Since we changed gfs2_io_error_bh_i
recently to withdraw later in the cycle, it sends a flood of
errors to the console. This patch checks for the file system already
being withdrawn, and if so, doesn't send more messages. It doesn't
stop the flood of messages, but it slows it down and keeps it more
reasonable.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit b524abcc01483b2ac093cc6a8a2a7375558d2b64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/log.c
#	fs/gfs2/util.c
diff --cc fs/gfs2/log.c
index 78f81ccc8357,96706a2bd2b6..000000000000
--- a/fs/gfs2/log.c
+++ b/fs/gfs2/log.c
@@@ -105,8 -108,12 +105,14 @@@ __acquires(&sdp->sd_ail_lock
  		gfs2_assert(sdp, bd->bd_tr == tr);
  
  		if (!buffer_busy(bh)) {
++<<<<<<< HEAD
 +			if (!buffer_uptodate(bh))
++=======
+ 			if (!buffer_uptodate(bh) &&
+ 			    !test_and_set_bit(SDF_AIL1_IO_ERROR,
+ 					      &sdp->sd_flags)) {
++>>>>>>> b524abcc0148 (gfs2: slow the deluge of io error messages)
  				gfs2_io_error_bh(sdp, bh);
 -				*withdraw = true;
 -			}
  			list_move(&bd->bd_ail_st_list, &tr->tr_ail2_list);
  			continue;
  		}
@@@ -194,11 -208,13 +200,16 @@@ static void gfs2_ail1_empty_one(struct 
  		gfs2_assert(sdp, bd->bd_tr == tr);
  		if (buffer_busy(bh))
  			continue;
++<<<<<<< HEAD
 +		if (!buffer_uptodate(bh))
++=======
+ 		if (!buffer_uptodate(bh) &&
+ 		    !test_and_set_bit(SDF_AIL1_IO_ERROR, &sdp->sd_flags)) {
++>>>>>>> b524abcc0148 (gfs2: slow the deluge of io error messages)
  			gfs2_io_error_bh(sdp, bh);
 -			*withdraw = true;
 -		}
  		list_move(&bd->bd_ail_st_list, &tr->tr_ail2_list);
  	}
 +
  }
  
  /**
diff --cc fs/gfs2/util.c
index d62797b79ef2,0a814ccac41d..000000000000
--- a/fs/gfs2/util.c
+++ b/fs/gfs2/util.c
@@@ -253,21 -251,22 +253,33 @@@ int gfs2_io_error_i(struct gfs2_sbd *sd
  }
  
  /**
 - * gfs2_io_error_bh_i - Flag a buffer I/O error
 - * @withdraw: withdraw the filesystem
 + * gfs2_io_error_bh_i - Flag a buffer I/O error and withdraw
 + * Returns: -1 if this call withdrew the machine,
 + *          0 if it was already withdrawn
   */
  
 -void gfs2_io_error_bh_i(struct gfs2_sbd *sdp, struct buffer_head *bh,
 -			const char *function, char *file, unsigned int line,
 -			bool withdraw)
 +int gfs2_io_error_bh_i(struct gfs2_sbd *sdp, struct buffer_head *bh,
 +		       const char *function, char *file, unsigned int line)
  {
++<<<<<<< HEAD
 +	int rv;
 +	rv = gfs2_lm_withdraw(sdp,
 +		"GFS2: fsid=%s: fatal: I/O error\n"
 +		"GFS2: fsid=%s:   block = %llu\n"
 +		"GFS2: fsid=%s:   function = %s, file = %s, line = %u\n",
 +		sdp->sd_fsname,
 +		sdp->sd_fsname, (unsigned long long)bh->b_blocknr,
 +		sdp->sd_fsname, function, file, line);
 +	return rv;
++=======
+ 	if (!test_bit(SDF_SHUTDOWN, &sdp->sd_flags))
+ 		fs_err(sdp,
+ 		       "fatal: I/O error\n"
+ 		       "  block = %llu\n"
+ 		       "  function = %s, file = %s, line = %u\n",
+ 		       (unsigned long long)bh->b_blocknr,
+ 		       function, file, line);
+ 	if (withdraw)
+ 		gfs2_lm_withdraw(sdp, NULL);
++>>>>>>> b524abcc0148 (gfs2: slow the deluge of io error messages)
  }
 -
diff --git a/fs/gfs2/incore.h b/fs/gfs2/incore.h
index 1f6f222b6802..41d3b4cfc6ec 100644
--- a/fs/gfs2/incore.h
+++ b/fs/gfs2/incore.h
@@ -588,6 +588,7 @@ enum {
 	SDF_RORECOVERY		= 7, /* read only recovery */
 	SDF_SKIP_DLM_UNLOCK	= 8,
 	SDF_FORCE_AIL_FLUSH     = 9,
+	SDF_AIL1_IO_ERROR	= 10,
 };
 
 #define GFS2_FSNAME_LEN		256
* Unmerged path fs/gfs2/log.c
* Unmerged path fs/gfs2/util.c
