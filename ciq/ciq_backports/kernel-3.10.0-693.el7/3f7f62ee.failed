scsi: be2iscsi: Add checks to validate completions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] be2iscsi: Add checks to validate completions (Maurizio Lombardi) [1324918]
Rebuild_FUZZ: 93.62%
commit-author Jitendra Bhivare <jitendra.bhivare@broadcom.com>
commit 3f7f62ee5b10de42b3ff1a33599fde4a2094960a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3f7f62ee.failed

Added check in beiscsi_process_cq for pio_handle.
pio_handle is cleared in beiscsi_put_wrb_handle.
This catches any case where task gets cleaned up just before completion.

Use back_lock before accessing pio_handle.

	Signed-off-by: Jitendra Bhivare <jitendra.bhivare@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 3f7f62ee5b10de42b3ff1a33599fde4a2094960a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/be2iscsi/be_main.c
diff --cc drivers/scsi/be2iscsi/be_main.c
index e4c287c0818a,832d4f0fb33f..000000000000
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@@ -1192,8 -957,13 +1192,16 @@@ beiscsi_get_wrb_handle(struct hwi_wrb_c
  		       unsigned int wrbs_per_cxn)
  {
  	struct wrb_handle *pwrb_handle;
 -	unsigned long flags;
  
++<<<<<<< HEAD
 +	spin_lock_bh(&pwrb_context->wrb_lock);
++=======
+ 	spin_lock_irqsave(&pwrb_context->wrb_lock, flags);
+ 	if (!pwrb_context->wrb_handles_available) {
+ 		spin_unlock_irqrestore(&pwrb_context->wrb_lock, flags);
+ 		return NULL;
+ 	}
++>>>>>>> 3f7f62ee5b10 (scsi: be2iscsi: Add checks to validate completions)
  	pwrb_handle = pwrb_context->pwrb_handle_base[pwrb_context->alloc_index];
  	pwrb_context->wrb_handles_available--;
  	if (pwrb_context->alloc_index == (wrbs_per_cxn - 1))
@@@ -1239,7 -1014,8 +1247,12 @@@ beiscsi_put_wrb_handle(struct hwi_wrb_c
  		pwrb_context->free_index = 0;
  	else
  		pwrb_context->free_index++;
++<<<<<<< HEAD
 +	spin_unlock_bh(&pwrb_context->wrb_lock);
++=======
+ 	pwrb_handle->pio_handle = NULL;
+ 	spin_unlock_irqrestore(&pwrb_context->wrb_lock, flags);
++>>>>>>> 3f7f62ee5b10 (scsi: be2iscsi: Add checks to validate completions)
  }
  
  /**
@@@ -1439,11 -1222,11 +1452,16 @@@ hwi_complete_drvr_msgs(struct beiscsi_c
  		       struct beiscsi_hba *phba, struct sol_cqe *psol)
  {
  	struct hwi_wrb_context *pwrb_context;
 -	uint16_t wrb_index, cid, cri_index;
 +	struct wrb_handle *pwrb_handle = NULL;
  	struct hwi_controller *phwi_ctrlr;
++<<<<<<< HEAD
++=======
+ 	struct wrb_handle *pwrb_handle;
+ 	struct iscsi_session *session;
++>>>>>>> 3f7f62ee5b10 (scsi: be2iscsi: Add checks to validate completions)
  	struct iscsi_task *task;
 +	struct beiscsi_io_task *io_task;
 +	uint16_t wrb_index, cid, cri_index;
  
  	phwi_ctrlr = phba->phwi_ctrlr;
  	if (is_chip_be2_be3r(phba)) {
@@@ -1461,11 -1244,12 +1479,19 @@@
  	cri_index = BE_GET_CRI_FROM_CID(cid);
  	pwrb_context = &phwi_ctrlr->wrb_context[cri_index];
  	pwrb_handle = pwrb_context->pwrb_handle_basestd[wrb_index];
+ 	session = beiscsi_conn->conn->session;
+ 	spin_lock_bh(&session->back_lock);
  	task = pwrb_handle->pio_handle;
++<<<<<<< HEAD
 +
 +	io_task = task->dd_data;
 +	memset(io_task->pwrb_handle->pwrb, 0, sizeof(struct iscsi_wrb));
 +	iscsi_put_task(task);
++=======
+ 	if (task)
+ 		__iscsi_put_task(task);
+ 	spin_unlock_bh(&session->back_lock);
++>>>>>>> 3f7f62ee5b10 (scsi: be2iscsi: Add checks to validate completions)
  }
  
  static void
@@@ -1571,7 -1360,6 +1602,10 @@@ static void hwi_complete_cmd(struct bei
  	pwrb = pwrb_handle->pwrb;
  	type = ((struct beiscsi_io_task *)task->dd_data)->wrb_type;
  
++<<<<<<< HEAD
 +	spin_lock_bh(&session->lock);
++=======
++>>>>>>> 3f7f62ee5b10 (scsi: be2iscsi: Add checks to validate completions)
  	switch (type) {
  	case HWH_TYPE_IO:
  	case HWH_TYPE_IO_RD:
* Unmerged path drivers/scsi/be2iscsi/be_main.c
