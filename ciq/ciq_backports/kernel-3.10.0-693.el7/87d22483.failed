net/mlx5: Add sniffer namespaces

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [kernel] mlx5: Add sniffer namespaces (Don Dutile) [1385256 1385330 1417285]
Rebuild_FUZZ: 93.33%
commit-author Maor Gottlieb <maorg@mellanox.com>
commit 87d22483ce68e609818d61e3a65361f5634c6cd6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/87d22483.failed

Add sniffer TX and RX namespaces to receive ingoing and outgoing
traffic.

Each outgoing/incoming packet is duplicated and steered to the sniffer
TX/RX namespace in addition to the regular flow.

	Signed-off-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
(cherry picked from commit 87d22483ce68e609818d61e3a65361f5634c6cd6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
#	include/linux/mlx5/fs.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index 3b6147aebe10,f5571a5a57c5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -1304,10 -1413,30 +1304,20 @@@ struct mlx5_flow_namespace *mlx5_get_fl
  		prio = type;
  		break;
  	case MLX5_FLOW_NAMESPACE_FDB:
 -		if (steering->fdb_root_ns)
 -			return &steering->fdb_root_ns->ns;
 -		else
 -			return NULL;
 -	case MLX5_FLOW_NAMESPACE_ESW_EGRESS:
 -		if (steering->esw_egress_root_ns)
 -			return &steering->esw_egress_root_ns->ns;
 -		else
 -			return NULL;
 -	case MLX5_FLOW_NAMESPACE_ESW_INGRESS:
 -		if (steering->esw_ingress_root_ns)
 -			return &steering->esw_ingress_root_ns->ns;
 +		if (dev->priv.fdb_root_ns)
 +			return &dev->priv.fdb_root_ns->ns;
  		else
  			return NULL;
+ 	case MLX5_FLOW_NAMESPACE_SNIFFER_RX:
+ 		if (steering->sniffer_rx_root_ns)
+ 			return &steering->sniffer_rx_root_ns->ns;
+ 		else
+ 			return NULL;
+ 	case MLX5_FLOW_NAMESPACE_SNIFFER_TX:
+ 		if (steering->sniffer_tx_root_ns)
+ 			return &steering->sniffer_tx_root_ns->ns;
+ 		else
+ 			return NULL;
  	default:
  		return NULL;
  	}
@@@ -1685,11 -1727,56 +1695,64 @@@ static void cleanup_root_ns(struct mlx5
  
  void mlx5_cleanup_fs(struct mlx5_core_dev *dev)
  {
++<<<<<<< HEAD
 +	cleanup_root_ns(dev);
 +	cleanup_single_prio_root_ns(dev, dev->priv.fdb_root_ns);
 +}
 +
 +static int init_fdb_root_ns(struct mlx5_core_dev *dev)
++=======
+ 	struct mlx5_flow_steering *steering = dev->priv.steering;
+ 
+ 	if (MLX5_CAP_GEN(dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)
+ 		return;
+ 
+ 	cleanup_root_ns(steering->root_ns);
+ 	cleanup_root_ns(steering->esw_egress_root_ns);
+ 	cleanup_root_ns(steering->esw_ingress_root_ns);
+ 	cleanup_root_ns(steering->fdb_root_ns);
+ 	cleanup_root_ns(steering->sniffer_rx_root_ns);
+ 	cleanup_root_ns(steering->sniffer_tx_root_ns);
+ 	mlx5_cleanup_fc_stats(dev);
+ 	kfree(steering);
+ }
+ 
+ static int init_sniffer_tx_root_ns(struct mlx5_flow_steering *steering)
+ {
+ 	struct fs_prio *prio;
+ 
+ 	steering->sniffer_tx_root_ns = create_root_ns(steering, FS_FT_SNIFFER_TX);
+ 	if (!steering->sniffer_tx_root_ns)
+ 		return -ENOMEM;
+ 
+ 	/* Create single prio */
+ 	prio = fs_create_prio(&steering->sniffer_tx_root_ns->ns, 0, 1);
+ 	if (IS_ERR(prio)) {
+ 		cleanup_root_ns(steering->sniffer_tx_root_ns);
+ 		return PTR_ERR(prio);
+ 	}
+ 	return 0;
+ }
+ 
+ static int init_sniffer_rx_root_ns(struct mlx5_flow_steering *steering)
+ {
+ 	struct fs_prio *prio;
+ 
+ 	steering->sniffer_rx_root_ns = create_root_ns(steering, FS_FT_SNIFFER_RX);
+ 	if (!steering->sniffer_rx_root_ns)
+ 		return -ENOMEM;
+ 
+ 	/* Create single prio */
+ 	prio = fs_create_prio(&steering->sniffer_rx_root_ns->ns, 0, 1);
+ 	if (IS_ERR(prio)) {
+ 		cleanup_root_ns(steering->sniffer_rx_root_ns);
+ 		return PTR_ERR(prio);
+ 	}
+ 	return 0;
+ }
+ 
+ static int init_fdb_root_ns(struct mlx5_flow_steering *steering)
++>>>>>>> 87d22483ce68 (net/mlx5: Add sniffer namespaces)
  {
  	struct fs_prio *prio;
  
@@@ -1709,18 -1831,61 +1772,36 @@@
  
  int mlx5_init_fs(struct mlx5_core_dev *dev)
  {
 -	struct mlx5_flow_steering *steering;
  	int err = 0;
  
 -	if (MLX5_CAP_GEN(dev, port_type) != MLX5_CAP_PORT_TYPE_ETH)
 -		return 0;
 -
 -	err = mlx5_init_fc_stats(dev);
 -	if (err)
 -		return err;
 -
 -	steering = kzalloc(sizeof(*steering), GFP_KERNEL);
 -	if (!steering)
 -		return -ENOMEM;
 -	steering->dev = dev;
 -	dev->priv.steering = steering;
 -
 -	if (MLX5_CAP_GEN(dev, nic_flow_table) &&
 -	    MLX5_CAP_FLOWTABLE_NIC_RX(dev, ft_support)) {
 -		err = init_root_ns(steering);
 +	if (MLX5_CAP_GEN(dev, nic_flow_table)) {
 +		err = init_root_ns(dev);
  		if (err)
 -			goto err;
 +			return err;
  	}
 -
  	if (MLX5_CAP_GEN(dev, eswitch_flow_table)) {
 -		if (MLX5_CAP_ESW_FLOWTABLE_FDB(dev, ft_support)) {
 -			err = init_fdb_root_ns(steering);
 -			if (err)
 -				goto err;
 -		}
 -		if (MLX5_CAP_ESW_EGRESS_ACL(dev, ft_support)) {
 -			err = init_egress_acl_root_ns(steering);
 -			if (err)
 -				goto err;
 -		}
 -		if (MLX5_CAP_ESW_INGRESS_ACL(dev, ft_support)) {
 -			err = init_ingress_acl_root_ns(steering);
 -			if (err)
 -				goto err;
 -		}
 +		err = init_fdb_root_ns(dev);
 +		if (err)
 +			cleanup_root_ns(dev);
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (MLX5_CAP_FLOWTABLE_SNIFFER_RX(dev, ft_support)) {
+ 		err = init_sniffer_rx_root_ns(steering);
+ 		if (err)
+ 			goto err;
+ 	}
+ 
+ 	if (MLX5_CAP_FLOWTABLE_SNIFFER_TX(dev, ft_support)) {
+ 		err = init_sniffer_tx_root_ns(steering);
+ 		if (err)
+ 			goto err;
+ 	}
+ 
+ 	return 0;
+ err:
+ 	mlx5_cleanup_fs(dev);
++>>>>>>> 87d22483ce68 (net/mlx5: Add sniffer namespaces)
  	return err;
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
index d607e564f454,71ff03bceabb..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
@@@ -45,14 -45,33 +45,41 @@@ enum fs_node_type 
  };
  
  enum fs_flow_table_type {
++<<<<<<< HEAD
 +	FS_FT_NIC_RX	 = 0x0,
 +	FS_FT_FDB	 = 0X4,
++=======
+ 	FS_FT_NIC_RX          = 0x0,
+ 	FS_FT_ESW_EGRESS_ACL  = 0x2,
+ 	FS_FT_ESW_INGRESS_ACL = 0x3,
+ 	FS_FT_FDB             = 0X4,
+ 	FS_FT_SNIFFER_RX	= 0X5,
+ 	FS_FT_SNIFFER_TX	= 0X6,
+ };
+ 
+ enum fs_flow_table_op_mod {
+ 	FS_FT_OP_MOD_NORMAL,
+ 	FS_FT_OP_MOD_LAG_DEMUX,
++>>>>>>> 87d22483ce68 (net/mlx5: Add sniffer namespaces)
  };
  
  enum fs_fte_status {
  	FS_FTE_STATUS_EXISTING = 1UL << 0,
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx5_flow_steering {
+ 	struct mlx5_core_dev *dev;
+ 	struct mlx5_flow_root_namespace *root_ns;
+ 	struct mlx5_flow_root_namespace *fdb_root_ns;
+ 	struct mlx5_flow_root_namespace *esw_egress_root_ns;
+ 	struct mlx5_flow_root_namespace *esw_ingress_root_ns;
+ 	struct mlx5_flow_root_namespace	*sniffer_tx_root_ns;
+ 	struct mlx5_flow_root_namespace	*sniffer_rx_root_ns;
+ };
+ 
++>>>>>>> 87d22483ce68 (net/mlx5: Add sniffer namespaces)
  struct fs_node {
  	struct list_head	list;
  	struct list_head	children;
diff --cc include/linux/mlx5/fs.h
index 3f3444d24756,93ebc5e21334..000000000000
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@@ -59,6 -61,10 +59,13 @@@ enum mlx5_flow_namespace_type 
  	MLX5_FLOW_NAMESPACE_LEFTOVERS,
  	MLX5_FLOW_NAMESPACE_ANCHOR,
  	MLX5_FLOW_NAMESPACE_FDB,
++<<<<<<< HEAD
++=======
+ 	MLX5_FLOW_NAMESPACE_ESW_EGRESS,
+ 	MLX5_FLOW_NAMESPACE_ESW_INGRESS,
+ 	MLX5_FLOW_NAMESPACE_SNIFFER_RX,
+ 	MLX5_FLOW_NAMESPACE_SNIFFER_TX,
++>>>>>>> 87d22483ce68 (net/mlx5: Add sniffer namespaces)
  };
  
  struct mlx5_flow_table;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
* Unmerged path include/linux/mlx5/fs.h
