net-timestamp: only report sw timestamp if reporting bit is set

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] timestamp: only report sw timestamp if reporting bit is set (Hangbin Liu) [1389283]
Rebuild_FUZZ: 96.72%
commit-author Willem de Bruijn <willemb@google.com>
commit c199105d154e029cd8c94cccd35bd073e64acc45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c199105d.failed

The timestamping API has separate bits for generating and reporting
timestamps. A software timestamp should only be reported for a packet
when the packet has the relevant generation flag (SKBTX_..) set
and the socket has reporting bit SOF_TIMESTAMPING_SOFTWARE set.

The second check was accidentally removed. Reinstitute the original
behavior.

Tested:
  Without this patch, Documentation/networking/txtimestamp reports
  timestamps regardless of whether SOF_TIMESTAMPING_SOFTWARE is set.
  After the patch, it only reports them when the flag is set.

Fixes: f24b9be5957b ("net-timestamp: extend SCM_TIMESTAMPING ancillary data struct")
	Signed-off-by: Willem de Bruijn <willemb@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c199105d154e029cd8c94cccd35bd073e64acc45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sock.h
#	net/socket.c
diff --cc include/net/sock.h
index 66e87003d1ca,b9a5bd0ed9f3..000000000000
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@@ -2240,21 -2159,15 +2240,26 @@@ sock_recv_timestamp(struct msghdr *msg
  
  	/*
  	 * generate control messages if
 -	 * - receive time stamping in software requested
 +	 * - receive time stamping in software requested (SOCK_RCVTSTAMP
 +	 *   or SOCK_TIMESTAMPING_RX_SOFTWARE)
  	 * - software time stamp available and wanted
 +	 *   (SOCK_TIMESTAMPING_SOFTWARE)
  	 * - hardware time stamps available and wanted
 +	 *   (SOCK_TIMESTAMPING_SYS_HARDWARE or
 +	 *   SOCK_TIMESTAMPING_RAW_HARDWARE)
  	 */
  	if (sock_flag(sk, SOCK_RCVTSTAMP) ||
++<<<<<<< HEAD
 +	    sock_flag(sk, SOCK_TIMESTAMPING_RX_SOFTWARE) ||
 +	    (kt.tv64 && sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) ||
++=======
+ 	    (sk->sk_tsflags & SOF_TIMESTAMPING_RX_SOFTWARE) ||
+ 	    (kt.tv64 && sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) ||
++>>>>>>> c199105d154e (net-timestamp: only report sw timestamp if reporting bit is set)
  	    (hwtstamps->hwtstamp.tv64 &&
 -	     (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE)))
 +	     sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE)) ||
 +	    (hwtstamps->syststamp.tv64 &&
 +	     sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE)))
  		__sock_recv_timestamp(msg, sk, skb);
  	else
  		sk->sk_stamp = kt;
diff --cc net/socket.c
index 29a2111ee79f,4eb09b34b2d3..000000000000
--- a/net/socket.c
+++ b/net/socket.c
@@@ -698,22 -733,17 +698,32 @@@ void __sock_recv_timestamp(struct msghd
  		}
  	}
  
++<<<<<<< HEAD
 +
 +	memset(ts, 0, sizeof(ts));
 +	if (sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE) &&
 +	    ktime_to_timespec_cond(skb->tstamp, ts + 0))
++=======
+ 	memset(&tss, 0, sizeof(tss));
+ 	if ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&
+ 	    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))
+ 		empty = 0;
+ 	if (shhwtstamps &&
+ 	    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&
+ 	    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))
++>>>>>>> c199105d154e (net-timestamp: only report sw timestamp if reporting bit is set)
  		empty = 0;
 +	if (shhwtstamps) {
 +		if (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE) &&
 +		    ktime_to_timespec_cond(shhwtstamps->syststamp, ts + 1))
 +			empty = 0;
 +		if (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE) &&
 +		    ktime_to_timespec_cond(shhwtstamps->hwtstamp, ts + 2))
 +			empty = 0;
 +	}
  	if (!empty)
  		put_cmsg(msg, SOL_SOCKET,
 -			 SCM_TIMESTAMPING, sizeof(tss), &tss);
 +			 SCM_TIMESTAMPING, sizeof(ts), &ts);
  }
  EXPORT_SYMBOL_GPL(__sock_recv_timestamp);
  
* Unmerged path include/net/sock.h
* Unmerged path net/socket.c
