powerpc/pseries: Implement indexed-count hotplug memory add

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [powerpc] pseries: Implement indexed-count hotplug memory add (Thomas Huth) [1323417]
Rebuild_FUZZ: 92.73%
commit-author Sahil Mehta <sahilmehta17@gmail.com>
commit 333f7b76865bec24c66710cf352f892d69e3ba0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/333f7b76.failed

Indexed-count add for memory hotplug guarantees that a contiguous block
of <count> lmbs beginning at a specified <drc index> will be assigned,
any LMBs in this range that are not already assigned will be DLPAR added.
Because of Qemu's per-DIMM memory management, the addition of a contiguous
block of memory currently requires a series of individual calls to add
each LMB in the block. Indexed-count add reduces this series of calls to
a single call for the entire block.

	Signed-off-by: Sahil Mehta <sahilmehta17@gmail.com>
	Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 333f7b76865bec24c66710cf352f892d69e3ba0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/pseries/dlpar.c
diff --cc arch/powerpc/platforms/pseries/dlpar.c
index b59742323995,193e052fa0dd..000000000000
--- a/arch/powerpc/platforms/pseries/dlpar.c
+++ b/arch/powerpc/platforms/pseries/dlpar.c
@@@ -600,6 -383,158 +606,161 @@@ static int handle_dlpar_errorlog(struc
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static void pseries_hp_work_fn(struct work_struct *work)
+ {
+ 	struct pseries_hp_work *hp_work =
+ 			container_of(work, struct pseries_hp_work, work);
+ 
+ 	if (hp_work->rc)
+ 		*(hp_work->rc) = handle_dlpar_errorlog(hp_work->errlog);
+ 	else
+ 		handle_dlpar_errorlog(hp_work->errlog);
+ 
+ 	if (hp_work->hp_completion)
+ 		complete(hp_work->hp_completion);
+ 
+ 	kfree(hp_work->errlog);
+ 	kfree((void *)work);
+ }
+ 
+ void queue_hotplug_event(struct pseries_hp_errorlog *hp_errlog,
+ 			 struct completion *hotplug_done, int *rc)
+ {
+ 	struct pseries_hp_work *work;
+ 	struct pseries_hp_errorlog *hp_errlog_copy;
+ 
+ 	hp_errlog_copy = kmalloc(sizeof(struct pseries_hp_errorlog),
+ 				 GFP_KERNEL);
+ 	memcpy(hp_errlog_copy, hp_errlog, sizeof(struct pseries_hp_errorlog));
+ 
+ 	work = kmalloc(sizeof(struct pseries_hp_work), GFP_KERNEL);
+ 	if (work) {
+ 		INIT_WORK((struct work_struct *)work, pseries_hp_work_fn);
+ 		work->errlog = hp_errlog_copy;
+ 		work->hp_completion = hotplug_done;
+ 		work->rc = rc;
+ 		queue_work(pseries_hp_wq, (struct work_struct *)work);
+ 	} else {
+ 		*rc = -ENOMEM;
+ 		kfree(hp_errlog_copy);
+ 		complete(hotplug_done);
+ 	}
+ }
+ 
+ static int dlpar_parse_resource(char **cmd, struct pseries_hp_errorlog *hp_elog)
+ {
+ 	char *arg;
+ 
+ 	arg = strsep(cmd, " ");
+ 	if (!arg)
+ 		return -EINVAL;
+ 
+ 	if (sysfs_streq(arg, "memory")) {
+ 		hp_elog->resource = PSERIES_HP_ELOG_RESOURCE_MEM;
+ 	} else if (sysfs_streq(arg, "cpu")) {
+ 		hp_elog->resource = PSERIES_HP_ELOG_RESOURCE_CPU;
+ 	} else {
+ 		pr_err("Invalid resource specified.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int dlpar_parse_action(char **cmd, struct pseries_hp_errorlog *hp_elog)
+ {
+ 	char *arg;
+ 
+ 	arg = strsep(cmd, " ");
+ 	if (!arg)
+ 		return -EINVAL;
+ 
+ 	if (sysfs_streq(arg, "add")) {
+ 		hp_elog->action = PSERIES_HP_ELOG_ACTION_ADD;
+ 	} else if (sysfs_streq(arg, "remove")) {
+ 		hp_elog->action = PSERIES_HP_ELOG_ACTION_REMOVE;
+ 	} else {
+ 		pr_err("Invalid action specified.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int dlpar_parse_id_type(char **cmd, struct pseries_hp_errorlog *hp_elog)
+ {
+ 	char *arg;
+ 	u32 count, index;
+ 
+ 	arg = strsep(cmd, " ");
+ 	if (!arg)
+ 		return -EINVAL;
+ 
+ 	if (sysfs_streq(arg, "indexed-count")) {
+ 		hp_elog->id_type = PSERIES_HP_ELOG_ID_DRC_IC;
+ 		arg = strsep(cmd, " ");
+ 		if (!arg) {
+ 			pr_err("No DRC count specified.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (kstrtou32(arg, 0, &count)) {
+ 			pr_err("Invalid DRC count specified.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		arg = strsep(cmd, " ");
+ 		if (!arg) {
+ 			pr_err("No DRC Index specified.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (kstrtou32(arg, 0, &index)) {
+ 			pr_err("Invalid DRC Index specified.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		hp_elog->_drc_u.ic.count = cpu_to_be32(count);
+ 		hp_elog->_drc_u.ic.index = cpu_to_be32(index);
+ 	} else if (sysfs_streq(arg, "index")) {
+ 		hp_elog->id_type = PSERIES_HP_ELOG_ID_DRC_INDEX;
+ 		arg = strsep(cmd, " ");
+ 		if (!arg) {
+ 			pr_err("No DRC Index specified.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (kstrtou32(arg, 0, &index)) {
+ 			pr_err("Invalid DRC Index specified.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		hp_elog->_drc_u.drc_index = cpu_to_be32(index);
+ 	} else if (sysfs_streq(arg, "count")) {
+ 		hp_elog->id_type = PSERIES_HP_ELOG_ID_DRC_COUNT;
+ 		arg = strsep(cmd, " ");
+ 		if (!arg) {
+ 			pr_err("No DRC count specified.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (kstrtou32(arg, 0, &count)) {
+ 			pr_err("Invalid DRC count specified.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		hp_elog->_drc_u.drc_count = cpu_to_be32(count);
+ 	} else {
+ 		pr_err("Invalid id_type specified.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 333f7b76865b (powerpc/pseries: Implement indexed-count hotplug memory add)
  static ssize_t dlpar_store(struct class *class, struct class_attribute *attr,
  			   const char *buf, size_t count)
  {
diff --git a/arch/powerpc/include/asm/rtas.h b/arch/powerpc/include/asm/rtas.h
index 034f9d13205d..49ec8c6c03ca 100644
--- a/arch/powerpc/include/asm/rtas.h
+++ b/arch/powerpc/include/asm/rtas.h
@@ -306,6 +306,7 @@ struct pseries_hp_errorlog {
 	union {
 		__be32	drc_index;
 		__be32	drc_count;
+		struct { __be32 count, index; } ic;
 		char	drc_name[1];
 	} _drc_u;
 };
@@ -322,6 +323,7 @@ struct pseries_hp_errorlog {
 #define PSERIES_HP_ELOG_ID_DRC_NAME	1
 #define PSERIES_HP_ELOG_ID_DRC_INDEX	2
 #define PSERIES_HP_ELOG_ID_DRC_COUNT	3
+#define PSERIES_HP_ELOG_ID_DRC_IC	4
 
 struct pseries_errorlog *get_pseries_errorlog(struct rtas_error_log *log,
 					      uint16_t section_id);
* Unmerged path arch/powerpc/platforms/pseries/dlpar.c
diff --git a/arch/powerpc/platforms/pseries/hotplug-memory.c b/arch/powerpc/platforms/pseries/hotplug-memory.c
index 1e5732c56541..874ab90a6ccb 100644
--- a/arch/powerpc/platforms/pseries/hotplug-memory.c
+++ b/arch/powerpc/platforms/pseries/hotplug-memory.c
@@ -816,6 +816,97 @@ static int dlpar_memory_add_by_index(u32 drc_index, struct property *prop)
 	return rc;
 }
 
+static int dlpar_memory_add_by_ic(u32 lmbs_to_add, u32 drc_index,
+				  struct property *prop)
+{
+	struct of_drconf_cell *lmbs;
+	u32 num_lmbs, *p;
+	int i, rc, start_lmb_found;
+	int lmbs_available = 0, start_index = 0, end_index;
+
+	pr_info("Attempting to hot-add %u LMB(s) at index %x\n",
+		lmbs_to_add, drc_index);
+
+	if (lmbs_to_add == 0)
+		return -EINVAL;
+
+	p = prop->value;
+	num_lmbs = *p++;
+	lmbs = (struct of_drconf_cell *)p;
+	start_lmb_found = 0;
+
+	/* Navigate to drc_index */
+	while (start_index < num_lmbs) {
+		if (lmbs[start_index].drc_index == drc_index) {
+			start_lmb_found = 1;
+			break;
+		}
+
+		start_index++;
+	}
+
+	if (!start_lmb_found)
+		return -EINVAL;
+
+	end_index = start_index + lmbs_to_add;
+
+	/* Validate that the LMBs in this range are not reserved */
+	for (i = start_index; i < end_index; i++) {
+		if (lmbs[i].flags & DRCONF_MEM_RESERVED)
+			break;
+
+		lmbs_available++;
+	}
+
+	if (lmbs_available < lmbs_to_add)
+		return -EINVAL;
+
+	for (i = start_index; i < end_index; i++) {
+		if (lmbs[i].flags & DRCONF_MEM_ASSIGNED)
+			continue;
+
+		rc = dlpar_acquire_drc(lmbs[i].drc_index);
+		if (rc)
+			break;
+
+		rc = dlpar_add_lmb(&lmbs[i]);
+		if (rc) {
+			dlpar_release_drc(lmbs[i].drc_index);
+			break;
+		}
+
+		lmbs[i].reserved = 1;
+	}
+
+	if (rc) {
+		pr_err("Memory indexed-count-add failed, removing any added LMBs\n");
+
+		for (i = start_index; i < end_index; i++) {
+			if (!lmbs[i].reserved)
+				continue;
+
+			rc = dlpar_remove_lmb(&lmbs[i]);
+			if (rc)
+				pr_err("Failed to remove LMB, drc index %x\n",
+				       be32_to_cpu(lmbs[i].drc_index));
+			else
+				dlpar_release_drc(lmbs[i].drc_index);
+		}
+		rc = -EINVAL;
+	} else {
+		for (i = start_index; i < end_index; i++) {
+			if (!lmbs[i].reserved)
+				continue;
+
+			pr_info("Memory at %llx (drc index %x) was hot-added\n",
+				lmbs[i].base_addr, lmbs[i].drc_index);
+			lmbs[i].reserved = 0;
+		}
+	}
+
+	return rc;
+}
+
 int dlpar_memory(struct pseries_hp_errorlog *hp_elog)
 {
 	struct device_node *dn;
@@ -823,9 +914,6 @@ int dlpar_memory(struct pseries_hp_errorlog *hp_elog)
 	u32 count, drc_index;
 	int rc;
 
-	count = hp_elog->_drc_u.drc_count;
-	drc_index = hp_elog->_drc_u.drc_index;
-
 	lock_device_hotplug();
 
 	dn = of_find_node_by_path("/ibm,dynamic-reconfiguration-memory");
@@ -842,22 +930,35 @@ int dlpar_memory(struct pseries_hp_errorlog *hp_elog)
 
 	switch (hp_elog->action) {
 	case PSERIES_HP_ELOG_ACTION_ADD:
-		if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_COUNT)
+		if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_COUNT) {
+			count = hp_elog->_drc_u.drc_count;
 			rc = dlpar_memory_add_by_count(count, prop);
-		else if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_INDEX)
+		} else if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_INDEX) {
+			drc_index = hp_elog->_drc_u.drc_index;
 			rc = dlpar_memory_add_by_index(drc_index, prop);
-		else
+		} else if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_IC) {
+			count = hp_elog->_drc_u.ic.count;
+			drc_index = hp_elog->_drc_u.ic.index;
+			rc = dlpar_memory_add_by_ic(count, drc_index, prop);
+		} else {
 			rc = -EINVAL;
+		}
+
 		break;
 	case PSERIES_HP_ELOG_ACTION_REMOVE:
-		if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_COUNT)
+		if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_COUNT) {
+			count = hp_elog->_drc_u.drc_count;
 			rc = dlpar_memory_remove_by_count(count, prop);
-		else if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_INDEX)
+		} else if (hp_elog->id_type == PSERIES_HP_ELOG_ID_DRC_INDEX) {
+			drc_index = hp_elog->_drc_u.drc_index;
 			rc = dlpar_memory_remove_by_index(drc_index, prop);
-		else
+		} else {
 			rc = -EINVAL;
+		}
+
 		break;
 	case PSERIES_HP_ELOG_ACTION_READD:
+		drc_index = hp_elog->_drc_u.drc_index;
 		rc = dlpar_memory_readd_by_index(drc_index, prop);
 		break;
 	default:
