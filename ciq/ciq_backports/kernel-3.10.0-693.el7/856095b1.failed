EDAC/mce_amd: Use SMCA prefix for error descriptions arrays

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [edac] mce_amd: Use SMCA prefix for error descriptions arrays (David Arcari) [1389383]
Rebuild_FUZZ: 95.58%
commit-author Yazen Ghannam <Yazen.Ghannam@amd.com>
commit 856095b1794be487527771dbd2fe28e34e94b266
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/856095b1.failed

The error descriptions defined for Fam17h can be reused for other SMCA
systems, so their names should reflect this.

Change f17h prefix to smca for error descriptions.

	Signed-off-by: Yazen Ghannam <Yazen.Ghannam@amd.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: http://lkml.kernel.org/r/1472673994-12235-4-git-send-email-Yazen.Ghannam@amd.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 856095b1794be487527771dbd2fe28e34e94b266)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/mce_amd.c
diff --cc drivers/edac/mce_amd.c
index 896ecd88aae5,ea549a94361b..000000000000
--- a/drivers/edac/mce_amd.c
+++ b/drivers/edac/mce_amd.c
@@@ -138,6 -138,151 +138,154 @@@ static const char * const mc5_mce_desc[
  	"Retire status queue"
  };
  
++<<<<<<< HEAD
++=======
+ static const char * const mc6_mce_desc[] = {
+ 	"Hardware Assertion",
+ 	"Free List",
+ 	"Physical Register File",
+ 	"Retire Queue",
+ 	"Scheduler table",
+ 	"Status Register File",
+ };
+ 
+ /* Scalable MCA error strings */
+ static const char * const smca_ls_mce_desc[] = {
+ 	"Load queue parity",
+ 	"Store queue parity",
+ 	"Miss address buffer payload parity",
+ 	"L1 TLB parity",
+ 	"Reserved",
+ 	"DC tag error type 6",
+ 	"DC tag error type 1",
+ 	"Internal error type 1",
+ 	"Internal error type 2",
+ 	"Sys Read data error thread 0",
+ 	"Sys read data error thread 1",
+ 	"DC tag error type 2",
+ 	"DC data error type 1 (poison comsumption)",
+ 	"DC data error type 2",
+ 	"DC data error type 3",
+ 	"DC tag error type 4",
+ 	"L2 TLB parity",
+ 	"PDC parity error",
+ 	"DC tag error type 3",
+ 	"DC tag error type 5",
+ 	"L2 fill data error",
+ };
+ 
+ static const char * const smca_if_mce_desc[] = {
+ 	"microtag probe port parity error",
+ 	"IC microtag or full tag multi-hit error",
+ 	"IC full tag parity",
+ 	"IC data array parity",
+ 	"Decoupling queue phys addr parity error",
+ 	"L0 ITLB parity error",
+ 	"L1 ITLB parity error",
+ 	"L2 ITLB parity error",
+ 	"BPQ snoop parity on Thread 0",
+ 	"BPQ snoop parity on Thread 1",
+ 	"L1 BTB multi-match error",
+ 	"L2 BTB multi-match error",
+ 	"L2 Cache Response Poison error",
+ 	"System Read Data error",
+ };
+ 
+ static const char * const smca_l2_mce_desc[] = {
+ 	"L2M tag multi-way-hit error",
+ 	"L2M tag ECC error",
+ 	"L2M data ECC error",
+ 	"HW assert",
+ };
+ 
+ static const char * const smca_de_mce_desc[] = {
+ 	"uop cache tag parity error",
+ 	"uop cache data parity error",
+ 	"Insn buffer parity error",
+ 	"uop queue parity error",
+ 	"Insn dispatch queue parity error",
+ 	"Fetch address FIFO parity",
+ 	"Patch RAM data parity",
+ 	"Patch RAM sequencer parity",
+ 	"uop buffer parity"
+ };
+ 
+ static const char * const smca_ex_mce_desc[] = {
+ 	"Watchdog timeout error",
+ 	"Phy register file parity",
+ 	"Flag register file parity",
+ 	"Immediate displacement register file parity",
+ 	"Address generator payload parity",
+ 	"EX payload parity",
+ 	"Checkpoint queue parity",
+ 	"Retire dispatch queue parity",
+ 	"Retire status queue parity error",
+ 	"Scheduling queue parity error",
+ 	"Branch buffer queue parity error",
+ };
+ 
+ static const char * const smca_fp_mce_desc[] = {
+ 	"Physical register file parity",
+ 	"Freelist parity error",
+ 	"Schedule queue parity",
+ 	"NSQ parity error",
+ 	"Retire queue parity",
+ 	"Status register file parity",
+ 	"Hardware assertion",
+ };
+ 
+ static const char * const smca_l3_mce_desc[] = {
+ 	"Shadow tag macro ECC error",
+ 	"Shadow tag macro multi-way-hit error",
+ 	"L3M tag ECC error",
+ 	"L3M tag multi-way-hit error",
+ 	"L3M data ECC error",
+ 	"XI parity, L3 fill done channel error",
+ 	"L3 victim queue parity",
+ 	"L3 HW assert",
+ };
+ 
+ static const char * const smca_cs_mce_desc[] = {
+ 	"Illegal request from transport layer",
+ 	"Address violation",
+ 	"Security violation",
+ 	"Illegal response from transport layer",
+ 	"Unexpected response",
+ 	"Parity error on incoming request or probe response data",
+ 	"Parity error on incoming read response data",
+ 	"Atomic request parity",
+ 	"ECC error on probe filter access",
+ };
+ 
+ static const char * const smca_pie_mce_desc[] = {
+ 	"HW assert",
+ 	"Internal PIE register security violation",
+ 	"Error on GMI link",
+ 	"Poison data written to internal PIE register",
+ };
+ 
+ static const char * const smca_umc_mce_desc[] = {
+ 	"DRAM ECC error",
+ 	"Data poison error on DRAM",
+ 	"SDP parity error",
+ 	"Advanced peripheral bus error",
+ 	"Command/address parity error",
+ 	"Write data CRC error",
+ };
+ 
+ static const char * const smca_pb_mce_desc[] = {
+ 	"Parameter Block RAM ECC error",
+ };
+ 
+ static const char * const smca_psp_mce_desc[] = {
+ 	"PSP RAM ECC or parity error",
+ };
+ 
+ static const char * const smca_smu_mce_desc[] = {
+ 	"SMU RAM ECC or parity error",
+ };
+ 
++>>>>>>> 856095b1794b (EDAC/mce_amd: Use SMCA prefix for error descriptions arrays)
  static bool f12h_mc0_mce(u16 ec, u8 xec)
  {
  	bool ret = false;
@@@ -710,6 -827,177 +858,180 @@@ static void decode_mc6_mce(struct mce *
  	pr_emerg(HW_ERR "Corrupted MC6 MCE info?\n");
  }
  
++<<<<<<< HEAD
++=======
+ static void decode_f17h_core_errors(const char *ip_name, u8 xec,
+ 				   unsigned int mca_type)
+ {
+ 	const char * const *error_desc_array;
+ 	size_t len;
+ 
+ 	pr_emerg(HW_ERR "%s Error: ", ip_name);
+ 
+ 	switch (mca_type) {
+ 	case SMCA_LS:
+ 		error_desc_array = smca_ls_mce_desc;
+ 		len = ARRAY_SIZE(smca_ls_mce_desc) - 1;
+ 
+ 		if (xec == 0x4) {
+ 			pr_cont("Unrecognized LS MCA error code.\n");
+ 			return;
+ 		}
+ 		break;
+ 
+ 	case SMCA_IF:
+ 		error_desc_array = smca_if_mce_desc;
+ 		len = ARRAY_SIZE(smca_if_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_L2_CACHE:
+ 		error_desc_array = smca_l2_mce_desc;
+ 		len = ARRAY_SIZE(smca_l2_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_DE:
+ 		error_desc_array = smca_de_mce_desc;
+ 		len = ARRAY_SIZE(smca_de_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_EX:
+ 		error_desc_array = smca_ex_mce_desc;
+ 		len = ARRAY_SIZE(smca_ex_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_FP:
+ 		error_desc_array = smca_fp_mce_desc;
+ 		len = ARRAY_SIZE(smca_fp_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_L3_CACHE:
+ 		error_desc_array = smca_l3_mce_desc;
+ 		len = ARRAY_SIZE(smca_l3_mce_desc) - 1;
+ 		break;
+ 
+ 	default:
+ 		pr_cont("Corrupted MCA core error info.\n");
+ 		return;
+ 	}
+ 
+ 	if (xec > len) {
+ 		pr_cont("Unrecognized %s MCA bank error code.\n",
+ 			 amd_core_mcablock_names[mca_type]);
+ 		return;
+ 	}
+ 
+ 	pr_cont("%s.\n", error_desc_array[xec]);
+ }
+ 
+ static void decode_df_errors(u8 xec, unsigned int mca_type)
+ {
+ 	const char * const *error_desc_array;
+ 	size_t len;
+ 
+ 	pr_emerg(HW_ERR "Data Fabric Error: ");
+ 
+ 	switch (mca_type) {
+ 	case  SMCA_CS:
+ 		error_desc_array = smca_cs_mce_desc;
+ 		len = ARRAY_SIZE(smca_cs_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_PIE:
+ 		error_desc_array = smca_pie_mce_desc;
+ 		len = ARRAY_SIZE(smca_pie_mce_desc) - 1;
+ 		break;
+ 
+ 	default:
+ 		pr_cont("Corrupted MCA Data Fabric info.\n");
+ 		return;
+ 	}
+ 
+ 	if (xec > len) {
+ 		pr_cont("Unrecognized %s MCA bank error code.\n",
+ 			 amd_df_mcablock_names[mca_type]);
+ 		return;
+ 	}
+ 
+ 	pr_cont("%s.\n", error_desc_array[xec]);
+ }
+ 
+ /* Decode errors according to Scalable MCA specification */
+ static void decode_smca_errors(struct mce *m)
+ {
+ 	u32 addr = MSR_AMD64_SMCA_MCx_IPID(m->bank);
+ 	unsigned int hwid, mca_type, i;
+ 	u8 xec = XEC(m->status, xec_mask);
+ 	const char * const *error_desc_array;
+ 	const char *ip_name;
+ 	u32 low, high;
+ 	size_t len;
+ 
+ 	if (rdmsr_safe(addr, &low, &high)) {
+ 		pr_emerg(HW_ERR "Invalid IP block specified.\n");
+ 		return;
+ 	}
+ 
+ 	hwid = high & MCI_IPID_HWID;
+ 	mca_type = (high & MCI_IPID_MCATYPE) >> 16;
+ 
+ 	pr_emerg(HW_ERR "MC%d IPID value: 0x%08x%08x\n", m->bank, high, low);
+ 
+ 	/*
+ 	 * Based on hwid and mca_type values, decode errors from respective IPs.
+ 	 * Note: mca_type values make sense only in the context of an hwid.
+ 	 */
+ 	for (i = 0; i < ARRAY_SIZE(amd_hwids); i++)
+ 		if (amd_hwids[i].hwid == hwid)
+ 			break;
+ 
+ 	switch (i) {
+ 	case SMCA_F17H_CORE:
+ 		ip_name = (mca_type == SMCA_L3_CACHE) ?
+ 			  "L3 Cache" : "F17h Core";
+ 		return decode_f17h_core_errors(ip_name, xec, mca_type);
+ 		break;
+ 
+ 	case SMCA_DF:
+ 		return decode_df_errors(xec, mca_type);
+ 		break;
+ 
+ 	case SMCA_UMC:
+ 		error_desc_array = smca_umc_mce_desc;
+ 		len = ARRAY_SIZE(smca_umc_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_PB:
+ 		error_desc_array = smca_pb_mce_desc;
+ 		len = ARRAY_SIZE(smca_pb_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_PSP:
+ 		error_desc_array = smca_psp_mce_desc;
+ 		len = ARRAY_SIZE(smca_psp_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_SMU:
+ 		error_desc_array = smca_smu_mce_desc;
+ 		len = ARRAY_SIZE(smca_smu_mce_desc) - 1;
+ 		break;
+ 
+ 	default:
+ 		pr_emerg(HW_ERR "HWID:%d does not match any existing IPs.\n", hwid);
+ 		return;
+ 	}
+ 
+ 	ip_name = amd_hwids[i].name;
+ 	pr_emerg(HW_ERR "%s Error: ", ip_name);
+ 
+ 	if (xec > len) {
+ 		pr_cont("Unrecognized %s MCA bank error code.\n", ip_name);
+ 		return;
+ 	}
+ 
+ 	pr_cont("%s.\n", error_desc_array[xec]);
+ }
+ 
++>>>>>>> 856095b1794b (EDAC/mce_amd: Use SMCA prefix for error descriptions arrays)
  static inline void amd_decode_err_code(u16 ec)
  {
  	if (INT_ERROR(ec)) {
* Unmerged path drivers/edac/mce_amd.c
