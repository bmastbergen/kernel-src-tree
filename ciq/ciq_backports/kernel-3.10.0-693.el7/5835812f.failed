target: ensure se_cmd->t_prot_sg is allocated when required

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [target] ensure se_cmd->t_prot_sg is allocated when required (Don Dutile) [1417284]
Rebuild_FUZZ: 92.73%
commit-author Akinobu Mita <akinobu.mita@gmail.com>
commit 5835812f13e56483f2c4907664bb43b0a78546b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5835812f.failed

Even if the device backend is initialized with protection info is
enabled, some requests don't have the protection info attached for
WRITE SAME command issued by block device helpers, WRITE command with
WRPROTECT=0 by SG_IO ioctl, etc.

So when TCM loopback fabric module is used, se_cmd->t_prot_sg is NULL
for these requests and performing WRITE_INSERT of PI using software
emulation by sbc_dif_generate() causes kernel crash.

To fix this, introduce SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC for
se_cmd_flags, which is used to determine that se_cmd->t_prot_sg needs
to be allocated or use pre-allocated protection information by scsi
mid-layer.

	Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
	Cc: Nicholas Bellinger <nab@linux-iscsi.org>
	Cc: Sagi Grimberg <sagig@mellanox.com>
	Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
	Cc: Christoph Hellwig <hch@lst.de>
	Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
	Cc: target-devel@vger.kernel.org
	Cc: linux-scsi@vger.kernel.org
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 5835812f13e56483f2c4907664bb43b0a78546b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/target/target_core_base.h
diff --cc include/target/target_core_base.h
index 985ca4c907fe,9f8f5a1b527d..000000000000
--- a/include/target/target_core_base.h
+++ b/include/target/target_core_base.h
@@@ -165,10 -159,9 +165,14 @@@ enum se_cmd_flags_table 
  	SCF_SEND_DELAYED_TAS		= 0x00004000,
  	SCF_ALUA_NON_OPTIMIZED		= 0x00008000,
  	SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC = 0x00020000,
 +	SCF_ACK_KREF			= 0x00040000,
  	SCF_COMPARE_AND_WRITE		= 0x00080000,
  	SCF_COMPARE_AND_WRITE_POST	= 0x00100000,
++<<<<<<< HEAD
 +	SCF_CMD_XCOPY_PASSTHROUGH	= 0x00200000,
++=======
+ 	SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC = 0x00200000,
++>>>>>>> 5835812f13e5 (target: ensure se_cmd->t_prot_sg is allocated when required)
  };
  
  /* struct se_dev_entry->lun_flags and struct se_lun->lun_access */
diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c
index 86700d5e9a81..39a5bfcf0df3 100644
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@ -1410,6 +1410,7 @@ int target_submit_cmd_map_sgls(struct se_cmd *se_cmd, struct se_session *se_sess
 	if (sgl_prot_count) {
 		se_cmd->t_prot_sg = sgl_prot;
 		se_cmd->t_prot_nents = sgl_prot_count;
+		se_cmd->se_cmd_flags |= SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC;
 	}
 
 	/*
@@ -2098,6 +2099,12 @@ static inline void transport_reset_sgl_orig(struct se_cmd *cmd)
 
 static inline void transport_free_pages(struct se_cmd *cmd)
 {
+	if (!(cmd->se_cmd_flags & SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC)) {
+		transport_free_sgl(cmd->t_prot_sg, cmd->t_prot_nents);
+		cmd->t_prot_sg = NULL;
+		cmd->t_prot_nents = 0;
+	}
+
 	if (cmd->se_cmd_flags & SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) {
 		/*
 		 * Release special case READ buffer payload required for
@@ -2121,10 +2128,6 @@ static inline void transport_free_pages(struct se_cmd *cmd)
 	transport_free_sgl(cmd->t_bidi_data_sg, cmd->t_bidi_data_nents);
 	cmd->t_bidi_data_sg = NULL;
 	cmd->t_bidi_data_nents = 0;
-
-	transport_free_sgl(cmd->t_prot_sg, cmd->t_prot_nents);
-	cmd->t_prot_sg = NULL;
-	cmd->t_prot_nents = 0;
 }
 
 /**
@@ -2263,6 +2266,14 @@ transport_generic_new_cmd(struct se_cmd *cmd)
 	int ret = 0;
 	bool zero_flag = !(cmd->se_cmd_flags & SCF_SCSI_DATA_CDB);
 
+	if (cmd->prot_op != TARGET_PROT_NORMAL &&
+	    !(cmd->se_cmd_flags & SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC)) {
+		ret = target_alloc_sgl(&cmd->t_prot_sg, &cmd->t_prot_nents,
+				       cmd->prot_length, true);
+		if (ret < 0)
+			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+	}
+
 	/*
 	 * Determine is the TCM fabric module has already allocated physical
 	 * memory, and is directly calling transport_generic_map_mem_to_cmd()
@@ -2288,14 +2299,6 @@ transport_generic_new_cmd(struct se_cmd *cmd)
 				return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 		}
 
-		if (cmd->prot_op != TARGET_PROT_NORMAL) {
-			ret = target_alloc_sgl(&cmd->t_prot_sg,
-					       &cmd->t_prot_nents,
-					       cmd->prot_length, true);
-			if (ret < 0)
-				return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
-		}
-
 		ret = target_alloc_sgl(&cmd->t_data_sg, &cmd->t_data_nents,
 				       cmd->data_length, zero_flag);
 		if (ret < 0)
* Unmerged path include/target/target_core_base.h
