i40e: Fix configure TCs after initial DCB disable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Ertman <david.m.ertman@intel.com>
commit ea6acb7ef78960e4b6f1cd8c4162a5e490e83dcd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ea6acb7e.failed

in commit a036244c068612a43fa8c0f33a0eb4daa4d8dba0 a fix
was put into place to avoid a kernel panic when a non-
supported traffic class configuration was put into place
and then lldp was enabled/disabled on the link partner
switch.  This fix caused it to be necessary to
unload/reload the driver to reenable DCB once a supported
TC config was in place.

The root cause of the original panic was that the function
i40e_pf_get_default_tc was allowing for a default TC other
than TC 0, and only TC 0 is supported as a default.

This patch removes the get_default_tc function and replaces
it with a #define since there is only one TC supported as
a default.

Change-Id: I448371974e946386d0a7718d73668b450b7c72ef
	Signed-off-by: Dave Ertman <david.m.ertman@intel.com>
	Tested-by: Ronald Bynoe <ronald.j.bynoe@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit ea6acb7ef78960e4b6f1cd8c4162a5e490e83dcd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e.h
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index 68870b273109,6d61e443bdf8..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -78,27 -78,28 +78,38 @@@
  /* max 16 qps */
  #define i40e_default_queues_per_vmdq(pf) \
  		(((pf)->flags & I40E_FLAG_RSS_AQ_CAPABLE) ? 4 : 1)
 -#define I40E_DEFAULT_QUEUES_PER_VF	4
 -#define I40E_DEFAULT_QUEUES_PER_TC	1 /* should be a power of 2 */
 +#define I40E_DEFAULT_QUEUES_PER_VF    4
 +#define I40E_DEFAULT_QUEUES_PER_TC    1 /* should be a power of 2 */
  #define i40e_pf_get_max_q_per_tc(pf) \
  		(((pf)->flags & I40E_FLAG_128_QP_RSS_CAPABLE) ? 128 : 64)
 -#define I40E_FDIR_RING			0
 -#define I40E_FDIR_RING_COUNT		32
 +#define I40E_FDIR_RING                0
 +#define I40E_FDIR_RING_COUNT          32
  #ifdef I40E_FCOE
 -#define I40E_DEFAULT_FCOE		8 /* default number of QPs for FCoE */
 -#define I40E_MINIMUM_FCOE		1 /* minimum number of QPs for FCoE */
 +#define I40E_DEFAULT_FCOE             8 /* default number of QPs for FCoE */
 +#define I40E_MINIMUM_FCOE             1 /* minimum number of QPs for FCoE */
  #endif /* I40E_FCOE */
++<<<<<<< HEAD
 +#define I40E_MAX_AQ_BUF_SIZE          4096
 +#define I40E_AQ_LEN                   256
 +#define I40E_AQ_WORK_LIMIT            66 /* max number of VFs + a little */
 +#define I40E_MAX_USER_PRIORITY        8
 +#define I40E_DEFAULT_MSG_ENABLE       4
 +#define I40E_QUEUE_WAIT_RETRY_LIMIT   10
 +#define I40E_INT_NAME_STR_LEN        (IFNAMSIZ + 16)
++=======
+ #define I40E_MAX_AQ_BUF_SIZE		4096
+ #define I40E_AQ_LEN			256
+ #define I40E_AQ_WORK_LIMIT		66 /* max number of VFs + a little */
+ #define I40E_MAX_USER_PRIORITY		8
+ #define I40E_DEFAULT_TRAFFIC_CLASS	BIT(0)
+ #define I40E_DEFAULT_MSG_ENABLE		4
+ #define I40E_QUEUE_WAIT_RETRY_LIMIT	10
+ #define I40E_INT_NAME_STR_LEN		(IFNAMSIZ + 16)
++>>>>>>> ea6acb7ef789 (i40e: Fix configure TCs after initial DCB disable)
  
  /* Ethtool Private Flags */
 -#define I40E_PRIV_FLAGS_MFP_FLAG		BIT(0)
 -#define I40E_PRIV_FLAGS_LINKPOLL_FLAG		BIT(1)
 +#define	I40E_PRIV_FLAGS_MFP_FLAG		BIT(0)
 +#define	I40E_PRIV_FLAGS_LINKPOLL_FLAG		BIT(1)
  #define I40E_PRIV_FLAGS_FD_ATR			BIT(2)
  #define I40E_PRIV_FLAGS_VEB_STATS		BIT(3)
  #define I40E_PRIV_FLAGS_HW_ATR_EVICT		BIT(4)
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index b8f28e7c6d01..0b55c80b0555 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -4619,29 +4619,6 @@ static u8 i40e_pf_get_num_tc(struct i40e_pf *pf)
 	return num_tc;
 }
 
-/**
- * i40e_pf_get_default_tc - Get bitmap for first enabled TC
- * @pf: PF being queried
- *
- * Return a bitmap for first enabled traffic class for this PF.
- **/
-static u8 i40e_pf_get_default_tc(struct i40e_pf *pf)
-{
-	u8 enabled_tc = pf->hw.func_caps.enabled_tcmap;
-	u8 i = 0;
-
-	if (!enabled_tc)
-		return 0x1; /* TC0 */
-
-	/* Find the first enabled TC */
-	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
-		if (enabled_tc & BIT(i))
-			break;
-	}
-
-	return BIT(i);
-}
-
 /**
  * i40e_pf_get_pf_tc_map - Get bitmap for enabled traffic classes
  * @pf: PF being queried
@@ -4652,7 +4629,7 @@ static u8 i40e_pf_get_tc_map(struct i40e_pf *pf)
 {
 	/* If DCB is not enabled for this PF then just return default TC */
 	if (!(pf->flags & I40E_FLAG_DCB_ENABLED))
-		return i40e_pf_get_default_tc(pf);
+		return I40E_DEFAULT_TRAFFIC_CLASS;
 
 	/* SFP mode we want PF to be enabled for all TCs */
 	if (!(pf->flags & I40E_FLAG_MFP_ENABLED))
@@ -4662,7 +4639,7 @@ static u8 i40e_pf_get_tc_map(struct i40e_pf *pf)
 	if (pf->hw.func_caps.iscsi)
 		return i40e_get_iscsi_tc_map(pf);
 	else
-		return i40e_pf_get_default_tc(pf);
+		return I40E_DEFAULT_TRAFFIC_CLASS;
 }
 
 /**
@@ -5008,7 +4985,7 @@ static void i40e_dcb_reconfigure(struct i40e_pf *pf)
 		if (v == pf->lan_vsi)
 			tc_map = i40e_pf_get_tc_map(pf);
 		else
-			tc_map = i40e_pf_get_default_tc(pf);
+			tc_map = I40E_DEFAULT_TRAFFIC_CLASS;
 #ifdef I40E_FCOE
 		if (pf->vsi[v]->type == I40E_VSI_FCOE)
 			tc_map = i40e_get_fcoe_tc_map(pf);
@@ -5702,7 +5679,7 @@ static int i40e_handle_lldp_event(struct i40e_pf *pf,
 	u8 type;
 
 	/* Not DCB capable or capability disabled */
-	if (!(pf->flags & I40E_FLAG_DCB_ENABLED))
+	if (!(pf->flags & I40E_FLAG_DCB_CAPABLE))
 		return ret;
 
 	/* Ignore if event is not for Nearest Bridge */
