tcp: replace dst_confirm with sk_dst_confirm

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Julian Anastasov <ja@ssi.bg>
commit c3a2e8370534f810cac6050169db0ed3e0f94f0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c3a2e837.failed

When same struct dst_entry can be used for many different
neighbours we can not use it for pending confirmations.
Use the new sk_dst_confirm() helper to propagate the
indication from received packets to sock_confirm_neigh().

	Reported-by: YueHaibing <yuehaibing@huawei.com>
Fixes: 5110effee8fd ("net: Do delayed neigh confirmation.")
Fixes: f2bb4bedf35d ("ipv4: Cache output routes in fib_info nexthops.")
	Tested-by: YueHaibing <yuehaibing@huawei.com>
	Signed-off-by: Julian Anastasov <ja@ssi.bg>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c3a2e8370534f810cac6050169db0ed3e0f94f0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_metrics.c
diff --cc net/ipv4/tcp_metrics.c
index 02307e286e43,0f46e5fe31ad..000000000000
--- a/net/ipv4/tcp_metrics.c
+++ b/net/ipv4/tcp_metrics.c
@@@ -489,11 -491,10 +487,14 @@@ void tcp_init_metrics(struct sock *sk
  	struct tcp_metrics_block *tm;
  	u32 val, crtt = 0; /* cached RTT scaled by 8 */
  
++<<<<<<< HEAD
 +	if (dst == NULL)
++=======
+ 	sk_dst_confirm(sk);
+ 	if (!dst)
++>>>>>>> c3a2e8370534 (tcp: replace dst_confirm with sk_dst_confirm)
  		goto reset;
  
- 	dst_confirm(dst);
- 
  	rcu_read_lock();
  	tm = tcp_get_metrics(sk, dst, true);
  	if (!tm) {
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 82210b952832..c6b87da917b4 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -3560,11 +3560,8 @@ static int tcp_ack(struct sock *sk, const struct sk_buff *skb, int flag)
 	if (tp->tlp_high_seq)
 		tcp_process_tlp_ack(sk, ack, flag);
 
-	if ((flag & FLAG_FORWARD_PROGRESS) || !(flag & FLAG_NOT_DUP)) {
-		struct dst_entry *dst = __sk_dst_get(sk);
-		if (dst)
-			dst_confirm(dst);
-	}
+	if ((flag & FLAG_FORWARD_PROGRESS) || !(flag & FLAG_NOT_DUP))
+		sk_dst_confirm(sk);
 
 	if (icsk->icsk_pending == ICSK_TIME_RETRANS)
 		tcp_schedule_loss_probe(sk);
@@ -5804,7 +5801,6 @@ int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 		break;
 
 	case TCP_FIN_WAIT1: {
-		struct dst_entry *dst;
 		int tmo;
 
 		/* If we enter the TCP_FIN_WAIT1 state and we are a
@@ -5831,9 +5827,7 @@ int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 		tcp_set_state(sk, TCP_FIN_WAIT2);
 		sk->sk_shutdown |= SEND_SHUTDOWN;
 
-		dst = __sk_dst_get(sk);
-		if (dst)
-			dst_confirm(dst);
+		sk_dst_confirm(sk);
 
 		if (!sock_flag(sk, SOCK_DEAD)) {
 			/* Wake up lingering close() */
* Unmerged path net/ipv4/tcp_metrics.c
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 883facac02ce..aec4eb2f1622 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -950,6 +950,8 @@ static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,
 	skb_set_hash_from_sk(skb, sk);
 	atomic_add(skb->truesize, &sk->sk_wmem_alloc);
 
+	skb_set_dst_pending_confirm(skb, sk->sk_dst_pending_confirm);
+
 	/* Build TCP header and checksum it. */
 	th = tcp_hdr(skb);
 	th->source		= inet->inet_sport;
