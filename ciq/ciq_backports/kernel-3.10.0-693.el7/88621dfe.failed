IB/mlx5: Port status track LAG master, when LAG is active

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Aviv Heller <avivh@mellanox.com>
commit 88621dfe90677a6a07ae1aff9feb1773226bc8b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/88621dfe.failed

When LAG is active, port up/down events should be triggered
by tracking the LAG master, and not one of the two slave
netdevs.

In the same manner, ib_query_port() should return the details
of the LAG master.

	Signed-off-by: Aviv Heller <avivh@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 88621dfe90677a6a07ae1aff9feb1773226bc8b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index 0662b3b06b3e,00a3616f395c..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -106,13 -107,42 +106,42 @@@ static int mlx5_netdev_event(struct not
  	struct mlx5_ib_dev *ibdev = container_of(this, struct mlx5_ib_dev,
  						 roce.nb);
  
 -	switch (event) {
 -	case NETDEV_REGISTER:
 -	case NETDEV_UNREGISTER:
 -		write_lock(&ibdev->roce.netdev_lock);
 -		if (ndev->dev.parent == &ibdev->mdev->pdev->dev)
 -			ibdev->roce.netdev = (event == NETDEV_UNREGISTER) ?
 -					     NULL : ndev;
 -		write_unlock(&ibdev->roce.netdev_lock);
 -		break;
 +	if ((event != NETDEV_UNREGISTER) && (event != NETDEV_REGISTER))
 +		return NOTIFY_DONE;
  
++<<<<<<< HEAD
 +	write_lock(&ibdev->roce.netdev_lock);
 +	if (ndev->dev.parent == &ibdev->mdev->pdev->dev)
 +		ibdev->roce.netdev = (event == NETDEV_UNREGISTER) ? NULL : ndev;
 +	write_unlock(&ibdev->roce.netdev_lock);
++=======
+ 	case NETDEV_UP:
+ 	case NETDEV_DOWN: {
+ 		struct net_device *lag_ndev = mlx5_lag_get_roce_netdev(ibdev->mdev);
+ 		struct net_device *upper = NULL;
+ 
+ 		if (lag_ndev) {
+ 			upper = netdev_master_upper_dev_get(lag_ndev);
+ 			dev_put(lag_ndev);
+ 		}
+ 
+ 		if ((upper == ndev || (!upper && ndev == ibdev->roce.netdev))
+ 		    && ibdev->ib_active) {
+ 			struct ib_event ibev = {0};
+ 
+ 			ibev.device = &ibdev->ib_dev;
+ 			ibev.event = (event == NETDEV_UP) ?
+ 				     IB_EVENT_PORT_ACTIVE : IB_EVENT_PORT_ERR;
+ 			ibev.element.port_num = 1;
+ 			ib_dispatch_event(&ibev);
+ 		}
+ 		break;
+ 	}
+ 
+ 	default:
+ 		break;
+ 	}
++>>>>>>> 88621dfe9067 (IB/mlx5: Port status track LAG master, when LAG is active)
  
  	return NOTIFY_DONE;
  }
* Unmerged path drivers/infiniband/hw/mlx5/main.c
