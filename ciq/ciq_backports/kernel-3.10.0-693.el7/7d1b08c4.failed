random: entropy_bytes is actually bits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Greg Price <price@MIT.EDU>
commit 7d1b08c40c4f02c119476b29eca9bbc8d98d2a83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7d1b08c4.failed

The variable 'entropy_bytes' is set from an expression that actually
counts bits.  Fortunately it's also only compared to values that also
count bits.  Rename it accordingly.

	Signed-off-by: Greg Price <price@mit.edu>
	Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
(cherry picked from commit 7d1b08c40c4f02c119476b29eca9bbc8d98d2a83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/random.c
diff --cc drivers/char/random.c
index 71f7f741fbfa,581d806823e9..000000000000
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@@ -671,11 -665,36 +671,44 @@@ retry
  				  entropy_count >> ENTROPY_SHIFT,
  				  r->entropy_total, _RET_IP_);
  
++<<<<<<< HEAD
 +	/* should we wake readers? */
 +	if (r == &input_pool &&
 +	    (entropy_count >> ENTROPY_SHIFT) >= random_read_wakeup_thresh) {
 +		wake_up_interruptible(&random_read_wait);
 +		kill_fasync(&fasync, SIGIO, POLL_IN);
++=======
+ 	if (r == &input_pool) {
+ 		int entropy_bits = entropy_count >> ENTROPY_SHIFT;
+ 
+ 		/* should we wake readers? */
+ 		if (entropy_bits >= random_read_wakeup_thresh) {
+ 			wake_up_interruptible(&random_read_wait);
+ 			kill_fasync(&fasync, SIGIO, POLL_IN);
+ 		}
+ 		/* If the input pool is getting full, send some
+ 		 * entropy to the two output pools, flipping back and
+ 		 * forth between them, until the output pools are 75%
+ 		 * full.
+ 		 */
+ 		if (entropy_bits > random_write_wakeup_thresh &&
+ 		    r->initialized &&
+ 		    r->entropy_total >= 2*random_read_wakeup_thresh) {
+ 			static struct entropy_store *last = &blocking_pool;
+ 			struct entropy_store *other = &blocking_pool;
+ 
+ 			if (last == &blocking_pool)
+ 				other = &nonblocking_pool;
+ 			if (other->entropy_count <=
+ 			    3 * other->poolinfo->poolfracbits / 4)
+ 				last = other;
+ 			if (last->entropy_count <=
+ 			    3 * last->poolinfo->poolfracbits / 4) {
+ 				schedule_work(&last->push_work);
+ 				r->entropy_total = 0;
+ 			}
+ 		}
++>>>>>>> 7d1b08c40c4f (random: entropy_bytes is actually bits)
  	}
  }
  
* Unmerged path drivers/char/random.c
