audit: Fix sleep in atomic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jan Kara <jack@suse.cz>
commit be29d20f3f5db1f0b4e49a4f6eeedf840e2bf9b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/be29d20f.failed

Audit tree code was happily adding new notification marks while holding
spinlocks. Since fsnotify_add_mark() acquires group->mark_mutex this can
lead to sleeping while holding a spinlock, deadlocks due to lock
inversion, and probably other fun. Fix the problem by acquiring
group->mark_mutex earlier.

CC: Paul Moore <paul@paul-moore.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit be29d20f3f5db1f0b4e49a4f6eeedf840e2bf9b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/audit_tree.c
diff --cc kernel/audit_tree.c
index 7219796b590d,862969014cf6..000000000000
--- a/kernel/audit_tree.c
+++ b/kernel/audit_tree.c
@@@ -230,9 -231,11 +230,11 @@@ static void untag_chunk(struct node *p
  	if (size)
  		new = alloc_chunk(size);
  
+ 	mutex_lock(&entry->group->mark_mutex);
  	spin_lock(&entry->lock);
 -	if (chunk->dead || !entry->inode) {
 +	if (chunk->dead || !entry->i.inode) {
  		spin_unlock(&entry->lock);
+ 		mutex_unlock(&entry->group->mark_mutex);
  		if (new)
  			free_chunk(new);
  		goto out;
@@@ -257,8 -261,8 +260,13 @@@
  	if (!new)
  		goto Fallback;
  
++<<<<<<< HEAD
 +	fsnotify_duplicate_mark(&new->mark, entry);
 +	if (fsnotify_add_mark(&new->mark, new->mark.group, new->mark.i.inode, NULL, 1)) {
++=======
+ 	if (fsnotify_add_mark_locked(&new->mark, entry->group, entry->inode,
+ 				     NULL, 1)) {
++>>>>>>> be29d20f3f5d (audit: Fix sleep in atomic)
  		fsnotify_put_mark(&new->mark);
  		goto Fallback;
  	}
@@@ -385,18 -391,21 +395,26 @@@ static int tag_chunk(struct inode *inod
  
  	chunk_entry = &chunk->mark;
  
+ 	mutex_lock(&old_entry->group->mark_mutex);
  	spin_lock(&old_entry->lock);
 -	if (!old_entry->inode) {
 +	if (!old_entry->i.inode) {
  		/* old_entry is being shot, lets just lie */
  		spin_unlock(&old_entry->lock);
+ 		mutex_unlock(&old_entry->group->mark_mutex);
  		fsnotify_put_mark(old_entry);
  		free_chunk(chunk);
  		return -ENOENT;
  	}
  
++<<<<<<< HEAD
 +	fsnotify_duplicate_mark(chunk_entry, old_entry);
 +	if (fsnotify_add_mark(chunk_entry, chunk_entry->group, chunk_entry->i.inode, NULL, 1)) {
++=======
+ 	if (fsnotify_add_mark_locked(chunk_entry, old_entry->group,
+ 				     old_entry->inode, NULL, 1)) {
++>>>>>>> be29d20f3f5d (audit: Fix sleep in atomic)
  		spin_unlock(&old_entry->lock);
+ 		mutex_unlock(&old_entry->group->mark_mutex);
  		fsnotify_put_mark(chunk_entry);
  		fsnotify_put_mark(old_entry);
  		return -ENOSPC;
* Unmerged path kernel/audit_tree.c
