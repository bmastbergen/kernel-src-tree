HID: wacom: Use tablet-provided touch height/width values for INTUOSHT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Use tablet-provided touch height/width values for INTUOSHT (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 96.30%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 76703be827a7867c28b904562bc78ed1314698bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/76703be8.failed

The current generation of "Intuos" tablets (i.e. INTUOSHT) report touch
width and height data just like the "Intuos Pro" do. This commit changes
the code to allow these tablets to use the appropriate codepath instead
of the one intended for Intuos5/Bamboo.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 76703be827a7867c28b904562bc78ed1314698bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index bdf17efa93aa,3024a3c2b4ff..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1138,46 -1423,37 +1138,52 @@@ static int wacom_bpt_touch(struct wacom
  	return 0;
  }
  
 -static void wacom_wac_pen_pre_report(struct hid_device *hdev,
 -		struct hid_report *report)
 +static void wacom_bpt3_touch_msg(struct wacom_wac *wacom, unsigned char *data)
  {
 -	return;
 -}
 +	struct wacom_features *features = &wacom->features;
 +	struct input_dev *input = wacom->input;
 +	bool touch = data[1] & 0x80;
 +	int slot = input_mt_get_slot_by_key(input, data[0]);
  
 -static void wacom_wac_pen_report(struct hid_device *hdev,
 -		struct hid_report *report)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct input_dev *input = wacom_wac->pen_input;
 -	bool prox = wacom_wac->hid_data.inrange_state;
 +	if (slot < 0)
 +		return;
  
 -	if (!wacom_wac->shared->stylus_in_proximity) /* first in prox */
 -		/* Going into proximity select tool */
 -		wacom_wac->tool[0] = wacom_wac->hid_data.invert_state ?
 -						BTN_TOOL_RUBBER : BTN_TOOL_PEN;
 +	touch = touch && !wacom->shared->stylus_in_proximity;
  
 -	/* keep pen state for touch events */
 -	wacom_wac->shared->stylus_in_proximity = prox;
 +	input_mt_slot(input, slot);
 +	input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
  
 -	/* send pen events only when touch is up or forced out */
 -	if (!wacom_wac->shared->touch_down) {
 -		input_report_key(input, BTN_TOUCH,
 -				wacom_wac->hid_data.tipswitch);
 -		input_report_key(input, wacom_wac->tool[0], prox);
 +	if (touch) {
 +		int x = (data[2] << 4) | (data[4] >> 4);
 +		int y = (data[3] << 4) | (data[4] & 0x0f);
 +		int width, height;
  
 -		wacom_wac->hid_data.tipswitch = false;
++<<<<<<< HEAD
 +		if (features->type >= INTUOSPS && features->type <= INTUOSPL) {
 +			width  = data[5];
 +			height = data[6];
++=======
++		if (features->type >= INTUOSPS && features->type <= INTUOSHT) {
++			width  = data[5] * 100;
++			height = data[6] * 100;
++>>>>>>> 76703be827a7 (HID: wacom: Use tablet-provided touch height/width values for INTUOSHT)
 +		} else {
 +			/*
 +			 * "a" is a scaled-down area which we assume is
 +			 * roughly circular and which can be described as:
 +			 * a=(pi*r^2)/C.
 +			 */
 +			int a = data[5];
 +			int x_res  = input_abs_get_res(input, ABS_X);
 +			int y_res  = input_abs_get_res(input, ABS_Y);
 +			width  = 2 * int_sqrt(a * WACOM_CONTACT_AREA_SCALE);
 +			height = width * y_res / x_res;
 +		}
  
 -		input_sync(input);
 +		input_report_abs(input, ABS_MT_POSITION_X, x);
 +		input_report_abs(input, ABS_MT_POSITION_Y, y);
 +		input_report_abs(input, ABS_MT_TOUCH_MAJOR, width);
 +		input_report_abs(input, ABS_MT_TOUCH_MINOR, height);
  	}
  }
  
* Unmerged path drivers/hid/wacom_wac.c
