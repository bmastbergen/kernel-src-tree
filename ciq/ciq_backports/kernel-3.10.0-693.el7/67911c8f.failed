NFS: Add nfs_commit_file()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Anna Schumaker <Anna.Schumaker@Netapp.com>
commit 67911c8f18b595040f5c2df0550c69a7c9397891
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/67911c8f.failed

Copy will use this to set up a commit request for a generic range.  I
don't want to allocate a new pagecache entry for the file, so I needed
to change parts of the commit path to handle requests with a null
wb_page.

	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 67911c8f18b595040f5c2df0550c69a7c9397891)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pagelist.c
#	fs/nfs/write.c
diff --cc fs/nfs/pagelist.c
index 2e3bb7900cc5,174dd4cf5747..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -376,8 -341,10 +376,15 @@@ nfs_create_request(struct nfs_open_cont
  	 * long write-back delay. This will be adjusted in
  	 * update_nfs_request below if the region is not locked. */
  	req->wb_page    = page;
++<<<<<<< HEAD
 +	req->wb_index	= page_file_index(page);
 +	page_cache_get(page);
++=======
+ 	if (page) {
+ 		req->wb_index = page_file_index(page);
+ 		get_page(page);
+ 	}
++>>>>>>> 67911c8f18b5 (NFS: Add nfs_commit_file())
  	req->wb_offset  = offset;
  	req->wb_pgbase	= offset;
  	req->wb_bytes   = count;
diff --cc fs/nfs/write.c
index f45a88499a0a,e18a97aab275..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -830,13 -831,13 +831,21 @@@ EXPORT_SYMBOL_GPL(nfs_request_add_commi
   * holding the nfs_page lock.
   */
  void
 -nfs_request_add_commit_list(struct nfs_page *req, struct nfs_commit_info *cinfo)
 +nfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,
 +			    struct nfs_commit_info *cinfo)
  {
++<<<<<<< HEAD
 +	spin_lock(cinfo->lock);
 +	nfs_request_add_commit_list_locked(req, dst, cinfo);
 +	spin_unlock(cinfo->lock);
 +	nfs_mark_page_unstable(req->wb_page, cinfo);
++=======
+ 	spin_lock(&cinfo->inode->i_lock);
+ 	nfs_request_add_commit_list_locked(req, &cinfo->mds->list, cinfo);
+ 	spin_unlock(&cinfo->inode->i_lock);
+ 	if (req->wb_page)
+ 		nfs_mark_page_unstable(req->wb_page, cinfo);
++>>>>>>> 67911c8f18b5 (NFS: Add nfs_commit_file())
  }
  EXPORT_SYMBOL_GPL(nfs_request_add_commit_list);
  
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index c7e591f07962..2339000efb43 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -479,6 +479,7 @@ void nfs_mark_request_commit(struct nfs_page *req,
 			     u32 ds_commit_idx);
 int nfs_write_need_commit(struct nfs_pgio_header *);
 void nfs_writeback_update_inode(struct nfs_pgio_header *hdr);
+int nfs_commit_file(struct file *file, struct nfs_write_verifier *verf);
 int nfs_generic_commit_list(struct inode *inode, struct list_head *head,
 			    int how, struct nfs_commit_info *cinfo);
 void nfs_retry_commit(struct list_head *page_list,
* Unmerged path fs/nfs/pagelist.c
* Unmerged path fs/nfs/write.c
