x86/mce/AMD, EDAC/mce_amd: Define and use tables for known SMCA IP types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Yazen Ghannam <Yazen.Ghannam@amd.com>
commit 5896820e0aa32572ad03b30563c539655b6c6375
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5896820e.failed

Scalable MCA defines a number of IP types. An MCA bank on an SMCA
system is defined as one of these IP types. A bank's type is uniquely
identified by the combination of the HWID and MCATYPE values read from
its MCA_IPID register.

Add the required tables in order to be able to lookup error descriptions
based on a bank's type and the error's extended error code.

[ bp: Align comments, simplify a bit. ]

	Signed-off-by: Yazen Ghannam <Yazen.Ghannam@amd.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: http://lkml.kernel.org/r/1472741832-1690-1-git-send-email-Yazen.Ghannam@amd.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 5896820e0aa32572ad03b30563c539655b6c6375)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mce.h
#	arch/x86/kernel/cpu/mcheck/mce_amd.c
#	drivers/edac/mce_amd.c
diff --cc arch/x86/include/asm/mce.h
index cb08d9d92582,9bd7ff5ffbcc..000000000000
--- a/arch/x86/include/asm/mce.h
+++ b/arch/x86/include/asm/mce.h
@@@ -295,4 -332,52 +295,55 @@@ struct cper_sec_mem_err
  extern void apei_mce_report_mem_error(int corrected,
  				      struct cper_sec_mem_err *mem_err);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Enumerate new IP types and HWID values in AMD processors which support
+  * Scalable MCA.
+  */
+ #ifdef CONFIG_X86_MCE_AMD
+ 
+ /* These may be used by multiple smca_hwid_mcatypes */
+ enum smca_bank_types {
+ 	SMCA_LS = 0,	/* Load Store */
+ 	SMCA_IF,	/* Instruction Fetch */
+ 	SMCA_L2_CACHE,	/* L2 Cache */
+ 	SMCA_DE,	/* Decoder Unit */
+ 	SMCA_EX,	/* Execution Unit */
+ 	SMCA_FP,	/* Floating Point */
+ 	SMCA_L3_CACHE,	/* L3 Cache */
+ 	SMCA_CS,	/* Coherent Slave */
+ 	SMCA_PIE,	/* Power, Interrupts, etc. */
+ 	SMCA_UMC,	/* Unified Memory Controller */
+ 	SMCA_PB,	/* Parameter Block */
+ 	SMCA_PSP,	/* Platform Security Processor */
+ 	SMCA_SMU,	/* System Management Unit */
+ 	N_SMCA_BANK_TYPES
+ };
+ 
+ struct smca_bank_name {
+ 	const char *name;	/* Short name for sysfs */
+ 	const char *long_name;	/* Long name for pretty-printing */
+ };
+ 
+ extern struct smca_bank_name smca_bank_names[N_SMCA_BANK_TYPES];
+ 
+ #define HWID_MCATYPE(hwid, mcatype) ((hwid << 16) | mcatype)
+ 
+ struct smca_hwid_mcatype {
+ 	unsigned int bank_type;	/* Use with smca_bank_types for easy indexing. */
+ 	u32 hwid_mcatype;	/* (hwid,mcatype) tuple */
+ 	u32 xec_bitmap;		/* Bitmap of valid ExtErrorCodes; current max is 21. */
+ };
+ 
+ struct smca_bank_info {
+ 	struct smca_hwid_mcatype *type;
+ 	u32 type_instance;
+ };
+ 
+ extern struct smca_bank_info smca_banks[MAX_NR_BANKS];
+ 
+ #endif
+ 
++>>>>>>> 5896820e0aa3 (x86/mce/AMD, EDAC/mce_amd: Define and use tables for known SMCA IP types)
  #endif /* _ASM_X86_MCE_H */
diff --cc arch/x86/kernel/cpu/mcheck/mce_amd.c
index 40045b269893,3b74b62d0808..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce_amd.c
+++ b/arch/x86/kernel/cpu/mcheck/mce_amd.c
@@@ -63,6 -63,56 +63,59 @@@ static const char * const th_names[] = 
  	"execution_unit",
  };
  
++<<<<<<< HEAD
++=======
+ struct smca_bank_name smca_bank_names[] = {
+ 	[SMCA_LS]	= { "load_store",	"Load Store Unit" },
+ 	[SMCA_IF]	= { "insn_fetch",	"Instruction Fetch Unit" },
+ 	[SMCA_L2_CACHE]	= { "l2_cache",		"L2 Cache" },
+ 	[SMCA_DE]	= { "decode_unit",	"Decode Unit" },
+ 	[SMCA_EX]	= { "execution_unit",	"Execution Unit" },
+ 	[SMCA_FP]	= { "floating_point",	"Floating Point Unit" },
+ 	[SMCA_L3_CACHE]	= { "l3_cache",		"L3 Cache" },
+ 	[SMCA_CS]	= { "coherent_slave",	"Coherent Slave" },
+ 	[SMCA_PIE]	= { "pie",		"Power, Interrupts, etc." },
+ 	[SMCA_UMC]	= { "umc",		"Unified Memory Controller" },
+ 	[SMCA_PB]	= { "param_block",	"Parameter Block" },
+ 	[SMCA_PSP]	= { "psp",		"Platform Security Processor" },
+ 	[SMCA_SMU]	= { "smu",		"System Management Unit" },
+ };
+ EXPORT_SYMBOL_GPL(smca_bank_names);
+ 
+ static struct smca_hwid_mcatype smca_hwid_mcatypes[] = {
+ 	/* { bank_type, hwid_mcatype, xec_bitmap } */
+ 
+ 	/* ZN Core (HWID=0xB0) MCA types */
+ 	{ SMCA_LS,	 HWID_MCATYPE(0xB0, 0x0), 0x1FFFEF },
+ 	{ SMCA_IF,	 HWID_MCATYPE(0xB0, 0x1), 0x3FFF },
+ 	{ SMCA_L2_CACHE, HWID_MCATYPE(0xB0, 0x2), 0xF },
+ 	{ SMCA_DE,	 HWID_MCATYPE(0xB0, 0x3), 0x1FF },
+ 	/* HWID 0xB0 MCATYPE 0x4 is Reserved */
+ 	{ SMCA_EX,	 HWID_MCATYPE(0xB0, 0x5), 0x7FF },
+ 	{ SMCA_FP,	 HWID_MCATYPE(0xB0, 0x6), 0x7F },
+ 	{ SMCA_L3_CACHE, HWID_MCATYPE(0xB0, 0x7), 0xFF },
+ 
+ 	/* Data Fabric MCA types */
+ 	{ SMCA_CS,	 HWID_MCATYPE(0x2E, 0x0), 0x1FF },
+ 	{ SMCA_PIE,	 HWID_MCATYPE(0x2E, 0x1), 0xF },
+ 
+ 	/* Unified Memory Controller MCA type */
+ 	{ SMCA_UMC,	 HWID_MCATYPE(0x96, 0x0), 0x3F },
+ 
+ 	/* Parameter Block MCA type */
+ 	{ SMCA_PB,	 HWID_MCATYPE(0x05, 0x0), 0x1 },
+ 
+ 	/* Platform Security Processor MCA type */
+ 	{ SMCA_PSP,	 HWID_MCATYPE(0xFF, 0x0), 0x1 },
+ 
+ 	/* System Management Unit MCA type */
+ 	{ SMCA_SMU,	 HWID_MCATYPE(0x01, 0x0), 0x1 },
+ };
+ 
+ struct smca_bank_info smca_banks[MAX_NR_BANKS];
+ EXPORT_SYMBOL_GPL(smca_banks);
+ 
++>>>>>>> 5896820e0aa3 (x86/mce/AMD, EDAC/mce_amd: Define and use tables for known SMCA IP types)
  static DEFINE_PER_CPU(struct threshold_bank **, threshold_banks);
  static DEFINE_PER_CPU(unsigned int, bank_map);	/* see which banks are on */
  
@@@ -351,17 -476,13 +434,20 @@@ void mce_amd_feature_init(struct cpuinf
  	int offset = -1;
  
  	for (bank = 0; bank < mca_cfg.banks; ++bank) {
+ 		if (mce_flags.smca)
+ 			get_smca_bank_info(bank);
+ 
  		for (block = 0; block < NR_BLOCKS; ++block) {
 -			address = get_block_address(cpu, address, low, high, bank, block);
 -			if (!address)
 -				break;
 +			if (block == 0)
 +				address = MSR_IA32_MCx_MISC(bank);
 +			else if (block == 1) {
 +				address = (low & MASK_BLKPTR_LO) >> 21;
 +				if (!address)
 +					break;
 +
 +				address += MCG_XBLK_ADDR;
 +			} else
 +				++address;
  
  			if (rdmsr_safe(address, &low, &high))
  				break;
diff --cc drivers/edac/mce_amd.c
index 896ecd88aae5,99b3bf3f4182..000000000000
--- a/drivers/edac/mce_amd.c
+++ b/drivers/edac/mce_amd.c
@@@ -138,6 -138,172 +138,175 @@@ static const char * const mc5_mce_desc[
  	"Retire status queue"
  };
  
++<<<<<<< HEAD
++=======
+ static const char * const mc6_mce_desc[] = {
+ 	"Hardware Assertion",
+ 	"Free List",
+ 	"Physical Register File",
+ 	"Retire Queue",
+ 	"Scheduler table",
+ 	"Status Register File",
+ };
+ 
+ /* Scalable MCA error strings */
+ static const char * const smca_ls_mce_desc[] = {
+ 	"Load queue parity",
+ 	"Store queue parity",
+ 	"Miss address buffer payload parity",
+ 	"L1 TLB parity",
+ 	"Reserved",
+ 	"DC tag error type 6",
+ 	"DC tag error type 1",
+ 	"Internal error type 1",
+ 	"Internal error type 2",
+ 	"Sys Read data error thread 0",
+ 	"Sys read data error thread 1",
+ 	"DC tag error type 2",
+ 	"DC data error type 1 (poison comsumption)",
+ 	"DC data error type 2",
+ 	"DC data error type 3",
+ 	"DC tag error type 4",
+ 	"L2 TLB parity",
+ 	"PDC parity error",
+ 	"DC tag error type 3",
+ 	"DC tag error type 5",
+ 	"L2 fill data error",
+ };
+ 
+ static const char * const smca_if_mce_desc[] = {
+ 	"microtag probe port parity error",
+ 	"IC microtag or full tag multi-hit error",
+ 	"IC full tag parity",
+ 	"IC data array parity",
+ 	"Decoupling queue phys addr parity error",
+ 	"L0 ITLB parity error",
+ 	"L1 ITLB parity error",
+ 	"L2 ITLB parity error",
+ 	"BPQ snoop parity on Thread 0",
+ 	"BPQ snoop parity on Thread 1",
+ 	"L1 BTB multi-match error",
+ 	"L2 BTB multi-match error",
+ 	"L2 Cache Response Poison error",
+ 	"System Read Data error",
+ };
+ 
+ static const char * const smca_l2_mce_desc[] = {
+ 	"L2M tag multi-way-hit error",
+ 	"L2M tag ECC error",
+ 	"L2M data ECC error",
+ 	"HW assert",
+ };
+ 
+ static const char * const smca_de_mce_desc[] = {
+ 	"uop cache tag parity error",
+ 	"uop cache data parity error",
+ 	"Insn buffer parity error",
+ 	"uop queue parity error",
+ 	"Insn dispatch queue parity error",
+ 	"Fetch address FIFO parity",
+ 	"Patch RAM data parity",
+ 	"Patch RAM sequencer parity",
+ 	"uop buffer parity"
+ };
+ 
+ static const char * const smca_ex_mce_desc[] = {
+ 	"Watchdog timeout error",
+ 	"Phy register file parity",
+ 	"Flag register file parity",
+ 	"Immediate displacement register file parity",
+ 	"Address generator payload parity",
+ 	"EX payload parity",
+ 	"Checkpoint queue parity",
+ 	"Retire dispatch queue parity",
+ 	"Retire status queue parity error",
+ 	"Scheduling queue parity error",
+ 	"Branch buffer queue parity error",
+ };
+ 
+ static const char * const smca_fp_mce_desc[] = {
+ 	"Physical register file parity",
+ 	"Freelist parity error",
+ 	"Schedule queue parity",
+ 	"NSQ parity error",
+ 	"Retire queue parity",
+ 	"Status register file parity",
+ 	"Hardware assertion",
+ };
+ 
+ static const char * const smca_l3_mce_desc[] = {
+ 	"Shadow tag macro ECC error",
+ 	"Shadow tag macro multi-way-hit error",
+ 	"L3M tag ECC error",
+ 	"L3M tag multi-way-hit error",
+ 	"L3M data ECC error",
+ 	"XI parity, L3 fill done channel error",
+ 	"L3 victim queue parity",
+ 	"L3 HW assert",
+ };
+ 
+ static const char * const smca_cs_mce_desc[] = {
+ 	"Illegal request from transport layer",
+ 	"Address violation",
+ 	"Security violation",
+ 	"Illegal response from transport layer",
+ 	"Unexpected response",
+ 	"Parity error on incoming request or probe response data",
+ 	"Parity error on incoming read response data",
+ 	"Atomic request parity",
+ 	"ECC error on probe filter access",
+ };
+ 
+ static const char * const smca_pie_mce_desc[] = {
+ 	"HW assert",
+ 	"Internal PIE register security violation",
+ 	"Error on GMI link",
+ 	"Poison data written to internal PIE register",
+ };
+ 
+ static const char * const smca_umc_mce_desc[] = {
+ 	"DRAM ECC error",
+ 	"Data poison error on DRAM",
+ 	"SDP parity error",
+ 	"Advanced peripheral bus error",
+ 	"Command/address parity error",
+ 	"Write data CRC error",
+ };
+ 
+ static const char * const smca_pb_mce_desc[] = {
+ 	"Parameter Block RAM ECC error",
+ };
+ 
+ static const char * const smca_psp_mce_desc[] = {
+ 	"PSP RAM ECC or parity error",
+ };
+ 
+ static const char * const smca_smu_mce_desc[] = {
+ 	"SMU RAM ECC or parity error",
+ };
+ 
+ struct smca_mce_desc {
+ 	const char * const *descs;
+ 	unsigned int num_descs;
+ };
+ 
+ static struct smca_mce_desc smca_mce_descs[] = {
+ 	[SMCA_LS]	= { smca_ls_mce_desc,	ARRAY_SIZE(smca_ls_mce_desc)	},
+ 	[SMCA_IF]	= { smca_if_mce_desc,	ARRAY_SIZE(smca_if_mce_desc)	},
+ 	[SMCA_L2_CACHE]	= { smca_l2_mce_desc,	ARRAY_SIZE(smca_l2_mce_desc)	},
+ 	[SMCA_DE]	= { smca_de_mce_desc,	ARRAY_SIZE(smca_de_mce_desc)	},
+ 	[SMCA_EX]	= { smca_ex_mce_desc,	ARRAY_SIZE(smca_ex_mce_desc)	},
+ 	[SMCA_FP]	= { smca_fp_mce_desc,	ARRAY_SIZE(smca_fp_mce_desc)	},
+ 	[SMCA_L3_CACHE]	= { smca_l3_mce_desc,	ARRAY_SIZE(smca_l3_mce_desc)	},
+ 	[SMCA_CS]	= { smca_cs_mce_desc,	ARRAY_SIZE(smca_cs_mce_desc)	},
+ 	[SMCA_PIE]	= { smca_pie_mce_desc,	ARRAY_SIZE(smca_pie_mce_desc)	},
+ 	[SMCA_UMC]	= { smca_umc_mce_desc,	ARRAY_SIZE(smca_umc_mce_desc)	},
+ 	[SMCA_PB]	= { smca_pb_mce_desc,	ARRAY_SIZE(smca_pb_mce_desc)	},
+ 	[SMCA_PSP]	= { smca_psp_mce_desc,	ARRAY_SIZE(smca_psp_mce_desc)	},
+ 	[SMCA_SMU]	= { smca_smu_mce_desc,	ARRAY_SIZE(smca_smu_mce_desc)	},
+ };
+ 
++>>>>>>> 5896820e0aa3 (x86/mce/AMD, EDAC/mce_amd: Define and use tables for known SMCA IP types)
  static bool f12h_mc0_mce(u16 ec, u8 xec)
  {
  	bool ret = false;
@@@ -710,6 -848,34 +879,37 @@@ static void decode_mc6_mce(struct mce *
  	pr_emerg(HW_ERR "Corrupted MC6 MCE info?\n");
  }
  
++<<<<<<< HEAD
++=======
+ /* Decode errors according to Scalable MCA specification */
+ static void decode_smca_errors(struct mce *m)
+ {
+ 	struct smca_hwid_mcatype *type;
+ 	unsigned int bank_type;
+ 	const char *ip_name;
+ 	u8 xec = XEC(m->status, xec_mask);
+ 
+ 	if (m->bank >= ARRAY_SIZE(smca_banks))
+ 		return;
+ 
+ 	type = smca_banks[m->bank].type;
+ 	if (!type)
+ 		return;
+ 
+ 	bank_type = type->bank_type;
+ 	ip_name = smca_bank_names[bank_type].long_name;
+ 
+ 	pr_emerg(HW_ERR "%s Extended Error Code: %d\n", ip_name, xec);
+ 
+ 	/* Only print the decode of valid error codes */
+ 	if (xec < smca_mce_descs[bank_type].num_descs &&
+ 			(type->xec_bitmap & BIT_ULL(xec))) {
+ 		pr_emerg(HW_ERR "%s Error: ", ip_name);
+ 		pr_cont("%s.\n", smca_mce_descs[bank_type].descs[xec]);
+ 	}
+ }
+ 
++>>>>>>> 5896820e0aa3 (x86/mce/AMD, EDAC/mce_amd: Define and use tables for known SMCA IP types)
  static inline void amd_decode_err_code(u16 ec)
  {
  	if (INT_ERROR(ec)) {
* Unmerged path arch/x86/include/asm/mce.h
* Unmerged path arch/x86/kernel/cpu/mcheck/mce_amd.c
* Unmerged path drivers/edac/mce_amd.c
