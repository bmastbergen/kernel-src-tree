KVM: nVMX: check host CR3 on vmentry and vmexit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ladi Prosek <lprosek@redhat.com>
commit 1dc35dacc16b4f13547125c5df2d026d9e46ea01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1dc35dac.failed

This commit adds missing host CR3 checks. Before entering guest mode, the value
of CR3 is checked for reserved bits. After returning, nested_vmx_load_cr3 is
called to set the new CR3 value and check and load PDPTRs.

	Signed-off-by: Ladi Prosek <lprosek@redhat.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 1dc35dacc16b4f13547125c5df2d026d9e46ea01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index c4ff252596cb,7280a355737e..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -9386,7 -9968,50 +9386,53 @@@ static int nested_vmx_store_msr(struct 
  	return 0;
  }
  
+ static bool nested_cr3_valid(struct kvm_vcpu *vcpu, unsigned long val)
+ {
+ 	unsigned long invalid_mask;
+ 
+ 	invalid_mask = (~0ULL) << cpuid_maxphyaddr(vcpu);
+ 	return (val & invalid_mask) == 0;
+ }
+ 
  /*
++<<<<<<< HEAD
++=======
+  * Load guest's/host's cr3 at nested entry/exit. nested_ept is true if we are
+  * emulating VM entry into a guest with EPT enabled.
+  * Returns 0 on success, 1 on failure. Invalid state exit qualification code
+  * is assigned to entry_failure_code on failure.
+  */
+ static int nested_vmx_load_cr3(struct kvm_vcpu *vcpu, unsigned long cr3, bool nested_ept,
+ 			       unsigned long *entry_failure_code)
+ {
+ 	if (cr3 != kvm_read_cr3(vcpu) || (!nested_ept && pdptrs_changed(vcpu))) {
+ 		if (!nested_cr3_valid(vcpu, cr3)) {
+ 			*entry_failure_code = ENTRY_FAIL_DEFAULT;
+ 			return 1;
+ 		}
+ 
+ 		/*
+ 		 * If PAE paging and EPT are both on, CR3 is not used by the CPU and
+ 		 * must not be dereferenced.
+ 		 */
+ 		if (!is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu) &&
+ 		    !nested_ept) {
+ 			if (!load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3)) {
+ 				*entry_failure_code = ENTRY_FAIL_PDPTE;
+ 				return 1;
+ 			}
+ 		}
+ 
+ 		vcpu->arch.cr3 = cr3;
+ 		__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);
+ 	}
+ 
+ 	kvm_mmu_reset_context(vcpu);
+ 	return 0;
+ }
+ 
+ /*
++>>>>>>> 1dc35dacc16b (KVM: nVMX: check host CR3 on vmentry and vmexit)
   * prepare_vmcs02 is called when the L1 guest hypervisor runs its nested
   * L2 guest. L1 has a vmcs for L2 (vmcs12), and this function "merges" it
   * with L0's requirements for its guest (a.k.a. vmcs01), so we can run the L2
@@@ -9799,21 -10453,22 +9845,27 @@@ static int nested_vmx_run(struct kvm_vc
  				vmx->nested.nested_vmx_entry_ctls_high))
  	{
  		nested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);
 -		goto out;
 +		return 1;
  	}
  
++<<<<<<< HEAD
 +	if (((vmcs12->host_cr0 & VMXON_CR0_ALWAYSON) != VMXON_CR0_ALWAYSON) ||
 +	    ((vmcs12->host_cr4 & VMXON_CR4_ALWAYSON) != VMXON_CR4_ALWAYSON)) {
++=======
+ 	if (!nested_host_cr0_valid(vcpu, vmcs12->host_cr0) ||
+ 	    !nested_host_cr4_valid(vcpu, vmcs12->host_cr4) ||
+ 	    !nested_cr3_valid(vcpu, vmcs12->host_cr3)) {
++>>>>>>> 1dc35dacc16b (KVM: nVMX: check host CR3 on vmentry and vmexit)
  		nested_vmx_failValid(vcpu,
  			VMXERR_ENTRY_INVALID_HOST_STATE_FIELD);
 -		goto out;
 +		return 1;
  	}
  
 -	if (!nested_guest_cr0_valid(vcpu, vmcs12->guest_cr0) ||
 -	    !nested_guest_cr4_valid(vcpu, vmcs12->guest_cr4)) {
 +	if (!nested_cr0_valid(vcpu, vmcs12->guest_cr0) ||
 +	    ((vmcs12->guest_cr4 & VMXON_CR4_ALWAYSON) != VMXON_CR4_ALWAYSON)) {
  		nested_vmx_entry_failure(vcpu, vmcs12,
  			EXIT_REASON_INVALID_STATE, ENTRY_FAIL_DEFAULT);
 -		goto out;
 +		return 1;
  	}
  	if (vmcs12->vmcs_link_pointer != -1ull) {
  		nested_vmx_entry_failure(vcpu, vmcs12,
diff --git a/arch/x86/include/uapi/asm/vmx.h b/arch/x86/include/uapi/asm/vmx.h
index f9dea4fd4107..14458658e988 100644
--- a/arch/x86/include/uapi/asm/vmx.h
+++ b/arch/x86/include/uapi/asm/vmx.h
@@ -133,6 +133,7 @@
 	{ EXIT_REASON_XRSTORS,               "XRSTORS" }
 
 #define VMX_ABORT_SAVE_GUEST_MSR_FAIL        1
+#define VMX_ABORT_LOAD_HOST_PDPTE_FAIL       2
 #define VMX_ABORT_LOAD_HOST_MSR_FAIL         4
 
 #endif /* _UAPIVMX_H */
* Unmerged path arch/x86/kvm/vmx.c
