xen-netfront: Fix Rx stall during network stress and OOM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Vineeth Remanan Pillai <vineethp@amazon.com>
commit 90c311b0eeead647b708a723dbdde1eda3dcad05
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/90c311b0.failed

During an OOM scenario, request slots could not be created as skb
allocation fails. So the netback cannot pass in packets and netfront
wrongly assumes that there is no more work to be done and it disables
polling. This causes Rx to stall.

The issue is with the retry logic which schedules the timer if the
created slots are less than NET_RX_SLOTS_MIN. The count of new request
slots to be pushed are calculated as a difference between new req_prod
and rsp_cons which could be more than the actual slots, if there are
unconsumed responses.

The fix is to calculate the count of newly created slots as the
difference between new req_prod and old req_prod.

	Signed-off-by: Vineeth Remanan Pillai <vineethp@amazon.com>
	Reviewed-by: Juergen Gross <jgross@suse.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 90c311b0eeead647b708a723dbdde1eda3dcad05)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/xen-netfront.c
diff --cc drivers/net/xen-netfront.c
index 8896052a2ee0,8315fe73ecd0..000000000000
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@@ -334,14 -318,19 +334,25 @@@ no_skb
  		req->gref = ref;
  	}
  
++<<<<<<< HEAD
++=======
+ 	queue->rx.req_prod_pvt = req_prod;
+ 
+ 	/* Not enough requests? Try again later. */
+ 	if (req_prod - queue->rx.sring->req_prod < NET_RX_SLOTS_MIN) {
+ 		mod_timer(&queue->rx_refill_timer, jiffies + (HZ/10));
+ 		return;
+ 	}
+ 
++>>>>>>> 90c311b0eeea (xen-netfront: Fix Rx stall during network stress and OOM)
  	wmb();		/* barrier so backend seens requests */
  
 -	RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&queue->rx, notify);
 +	/* Above is a suitable barrier to ensure backend will see requests. */
 +	np->rx.req_prod_pvt = req_prod + i;
 + push:
 +	RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&np->rx, notify);
  	if (notify)
 -		notify_remote_via_irq(queue->rx_irq);
 +		notify_remote_via_irq(np->rx_irq);
  }
  
  static int xennet_open(struct net_device *dev)
* Unmerged path drivers/net/xen-netfront.c
