IB/mlx5: Add flow tag support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Moses Reuben <mosesr@mellanox.com>
commit 2ac693f9953a2787f942abcbea5d1dc22a310932
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2ac693f9.failed

Set flow tag in flow table entry, when IB_FLOW_SPEC_ACTION_TAG
is part of the flow specifications.

Flow tag doesn't support multicast flows, so it's passing to
hardware only when used.

	Signed-off-by: Moses Reuben <mosesr@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 2ac693f9953a2787f942abcbea5d1dc22a310932)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index 7e1c9a7b92f0,2e85f73c3235..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -1496,9 -1666,10 +1496,10 @@@ static void set_tos(void *outer_c, voi
  #define LAST_ETH_FIELD vlan_tag
  #define LAST_IB_FIELD sl
  #define LAST_IPV4_FIELD tos
 -#define LAST_IPV6_FIELD traffic_class
 +#define LAST_IPV6_FIELD dst_ip
  #define LAST_TCP_UDP_FIELD src_port
  #define LAST_TUNNEL_FIELD tunnel_id
+ #define LAST_FLOW_TAG_FIELD tag_id
  
  /* Field is the last supported field */
  #define FIELDS_NOT_SUPPORTED(filter, field)\
@@@ -1509,13 -1680,28 +1510,17 @@@
  		   sizeof(filter.field))
  
  static int parse_flow_attr(u32 *match_c, u32 *match_v,
++<<<<<<< HEAD
 +			   union ib_flow_spec *ib_spec)
++=======
+ 			   const union ib_flow_spec *ib_spec, u32 *tag_id)
++>>>>>>> 2ac693f9953a (IB/mlx5: Add flow tag support)
  {
 -	void *misc_params_c = MLX5_ADDR_OF(fte_match_param, match_c,
 -					   misc_parameters);
 -	void *misc_params_v = MLX5_ADDR_OF(fte_match_param, match_v,
 -					   misc_parameters);
 -	void *headers_c;
 -	void *headers_v;
 -
 -	if (ib_spec->type & IB_FLOW_SPEC_INNER) {
 -		headers_c = MLX5_ADDR_OF(fte_match_param, match_c,
 -					 inner_headers);
 -		headers_v = MLX5_ADDR_OF(fte_match_param, match_v,
 -					 inner_headers);
 -	} else {
 -		headers_c = MLX5_ADDR_OF(fte_match_param, match_c,
 -					 outer_headers);
 -		headers_v = MLX5_ADDR_OF(fte_match_param, match_v,
 -					 outer_headers);
 -	}
 -
 -	switch (ib_spec->type & ~IB_FLOW_SPEC_INNER) {
 +	void *outer_headers_c = MLX5_ADDR_OF(fte_match_param, match_c,
 +					     outer_headers);
 +	void *outer_headers_v = MLX5_ADDR_OF(fte_match_param, match_v,
 +					     outer_headers);
 +	switch (ib_spec->type) {
  	case IB_FLOW_SPEC_ETH:
  		if (FIELDS_NOT_SUPPORTED(ib_spec->eth.mask, LAST_ETH_FIELD))
  			return -ENOTSUPP;
@@@ -1850,12 -2060,11 +1864,16 @@@ static struct mlx5_ib_flow_handler *cre
  {
  	struct mlx5_flow_table	*ft = ft_prio->flow_table;
  	struct mlx5_ib_flow_handler *handler;
 -	struct mlx5_flow_act flow_act = {0};
 -	struct mlx5_flow_spec *spec;
 -	const void *ib_flow = (const void *)flow_attr + sizeof(*flow_attr);
 +	void *ib_flow = flow_attr + 1;
 +	u8 match_criteria_enable = 0;
  	unsigned int spec_index;
++<<<<<<< HEAD
 +	u32 *match_c;
 +	u32 *match_v;
 +	u32 action;
++=======
+ 	u32 flow_tag = MLX5_FS_DEFAULT_FLOW_TAG;
++>>>>>>> 2ac693f9953a (IB/mlx5: Add flow tag support)
  	int err = 0;
  
  	if (!is_valid_attr(flow_attr))
@@@ -1872,22 -2080,30 +1890,43 @@@
  	INIT_LIST_HEAD(&handler->list);
  
  	for (spec_index = 0; spec_index < flow_attr->num_of_specs; spec_index++) {
++<<<<<<< HEAD
 +		err = parse_flow_attr(match_c, match_v, ib_flow);
++=======
+ 		err = parse_flow_attr(spec->match_criteria,
+ 				      spec->match_value, ib_flow, &flow_tag);
++>>>>>>> 2ac693f9953a (IB/mlx5: Add flow tag support)
  		if (err < 0)
  			goto free;
  
  		ib_flow += ((union ib_flow_spec *)ib_flow)->size;
  	}
  
 -	spec->match_criteria_enable = get_match_criteria_enable(spec->match_criteria);
 -	flow_act.action = dst ? MLX5_FLOW_CONTEXT_ACTION_FWD_DEST :
 +	/* Outer header support only */
 +	match_criteria_enable = (!outer_header_zero(match_c)) << 0;
 +	action = dst ? MLX5_FLOW_CONTEXT_ACTION_FWD_DEST :
  		MLX5_FLOW_CONTEXT_ACTION_FWD_NEXT_PRIO;
++<<<<<<< HEAD
 +	handler->rule = mlx5_add_flow_rule(ft, match_criteria_enable,
 +					   match_c, match_v,
 +					   action,
 +					   MLX5_FS_DEFAULT_FLOW_TAG,
 +					   dst);
++=======
+ 
+ 	if (flow_tag != MLX5_FS_DEFAULT_FLOW_TAG &&
+ 	    (flow_attr->type == IB_FLOW_ATTR_ALL_DEFAULT ||
+ 	     flow_attr->type == IB_FLOW_ATTR_MC_DEFAULT)) {
+ 		mlx5_ib_warn(dev, "Flow tag %u and attribute type %x isn't allowed in leftovers\n",
+ 			     flow_tag, flow_attr->type);
+ 		err = -EINVAL;
+ 		goto free;
+ 	}
+ 	flow_act.flow_tag = flow_tag;
+ 	handler->rule = mlx5_add_flow_rules(ft, spec,
+ 					    &flow_act,
+ 					    dst, 1);
++>>>>>>> 2ac693f9953a (IB/mlx5: Add flow tag support)
  
  	if (IS_ERR(handler->rule)) {
  		err = PTR_ERR(handler->rule);
* Unmerged path drivers/infiniband/hw/mlx5/main.c
