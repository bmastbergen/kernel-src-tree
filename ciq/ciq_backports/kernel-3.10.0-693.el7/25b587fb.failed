powerpc/pseries: Correct possible read beyond dlpar sysfs buffer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [powerpc] pseries: Correct possible read beyond dlpar sysfs buffer (Thomas Huth) [1323417]
Rebuild_FUZZ: 93.33%
commit-author Nathan Fontenot <nfont@linux.vnet.ibm.com>
commit 25b587fba9a4198e7ea2e2319d62e219d1a4ca2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/25b587fb.failed

The pasrsing of data written to the dlpar file in sysfs does not correctly
account for the possibility of reading past the end of the buffer. The code
assumes that all pieces of the command witten to the sysfs file are present
in the form "<resource> <action> <id_type> <id>".

Correct this by updating the buffer parsing code to make a local copy and
use the strsep() and sysfs_streq() routines to parse the buffer. This patch
also separates the parsing code into subroutines for each piece of the
command.

	Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 25b587fba9a4198e7ea2e2319d62e219d1a4ca2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/pseries/dlpar.c
diff --cc arch/powerpc/platforms/pseries/dlpar.c
index b59742323995,76caa4a45ccd..000000000000
--- a/arch/powerpc/platforms/pseries/dlpar.c
+++ b/arch/powerpc/platforms/pseries/dlpar.c
@@@ -600,53 -377,107 +600,109 @@@ static int handle_dlpar_errorlog(struc
  	return rc;
  }
  
- static ssize_t dlpar_store(struct class *class, struct class_attribute *attr,
- 			   const char *buf, size_t count)
++<<<<<<< HEAD
++=======
+ static void pseries_hp_work_fn(struct work_struct *work)
  {
- 	struct pseries_hp_errorlog *hp_elog;
- 	const char *arg;
- 	int rc;
+ 	struct pseries_hp_work *hp_work =
+ 			container_of(work, struct pseries_hp_work, work);
  
- 	hp_elog = kzalloc(sizeof(*hp_elog), GFP_KERNEL);
- 	if (!hp_elog) {
- 		rc = -ENOMEM;
- 		goto dlpar_store_out;
+ 	if (hp_work->rc)
+ 		*(hp_work->rc) = handle_dlpar_errorlog(hp_work->errlog);
+ 	else
+ 		handle_dlpar_errorlog(hp_work->errlog);
+ 
+ 	if (hp_work->hp_completion)
+ 		complete(hp_work->hp_completion);
+ 
+ 	kfree(hp_work->errlog);
+ 	kfree((void *)work);
+ }
+ 
+ void queue_hotplug_event(struct pseries_hp_errorlog *hp_errlog,
+ 			 struct completion *hotplug_done, int *rc)
+ {
+ 	struct pseries_hp_work *work;
+ 	struct pseries_hp_errorlog *hp_errlog_copy;
+ 
+ 	hp_errlog_copy = kmalloc(sizeof(struct pseries_hp_errorlog),
+ 				 GFP_KERNEL);
+ 	memcpy(hp_errlog_copy, hp_errlog, sizeof(struct pseries_hp_errorlog));
+ 
+ 	work = kmalloc(sizeof(struct pseries_hp_work), GFP_KERNEL);
+ 	if (work) {
+ 		INIT_WORK((struct work_struct *)work, pseries_hp_work_fn);
+ 		work->errlog = hp_errlog_copy;
+ 		work->hp_completion = hotplug_done;
+ 		work->rc = rc;
+ 		queue_work(pseries_hp_wq, (struct work_struct *)work);
+ 	} else {
+ 		*rc = -ENOMEM;
+ 		kfree(hp_errlog_copy);
+ 		complete(hotplug_done);
  	}
+ }
  
- 	/* Parse out the request from the user, this will be in the form
- 	 * <resource> <action> <id_type> <id>
- 	 */
- 	arg = buf;
- 	if (!strncmp(arg, "memory", 6)) {
+ static int dlpar_parse_resource(char **cmd, struct pseries_hp_errorlog *hp_elog)
+ {
+ 	char *arg;
+ 
+ 	arg = strsep(cmd, " ");
+ 	if (!arg)
+ 		return -EINVAL;
+ 
+ 	if (sysfs_streq(arg, "memory")) {
  		hp_elog->resource = PSERIES_HP_ELOG_RESOURCE_MEM;
- 		arg += strlen("memory ");
+ 	} else if (sysfs_streq(arg, "cpu")) {
+ 		hp_elog->resource = PSERIES_HP_ELOG_RESOURCE_CPU;
  	} else {
- 		pr_err("Invalid resource specified: \"%s\"\n", buf);
- 		rc = -EINVAL;
- 		goto dlpar_store_out;
+ 		pr_err("Invalid resource specified.\n");
+ 		return -EINVAL;
  	}
  
- 	if (!strncmp(arg, "add", 3)) {
+ 	return 0;
+ }
+ 
+ static int dlpar_parse_action(char **cmd, struct pseries_hp_errorlog *hp_elog)
+ {
+ 	char *arg;
+ 
+ 	arg = strsep(cmd, " ");
+ 	if (!arg)
+ 		return -EINVAL;
+ 
+ 	if (sysfs_streq(arg, "add")) {
  		hp_elog->action = PSERIES_HP_ELOG_ACTION_ADD;
- 		arg += strlen("add ");
- 	} else if (!strncmp(arg, "remove", 6)) {
+ 	} else if (sysfs_streq(arg, "remove")) {
  		hp_elog->action = PSERIES_HP_ELOG_ACTION_REMOVE;
- 		arg += strlen("remove ");
  	} else {
- 		pr_err("Invalid action specified: \"%s\"\n", buf);
- 		rc = -EINVAL;
- 		goto dlpar_store_out;
+ 		pr_err("Invalid action specified.\n");
+ 		return -EINVAL;
  	}
  
- 	if (!strncmp(arg, "index", 5)) {
- 		u32 index;
+ 	return 0;
+ }
+ 
+ static int dlpar_parse_id_type(char **cmd, struct pseries_hp_errorlog *hp_elog)
+ {
+ 	char *arg;
+ 	u32 count, index;
+ 
+ 	arg = strsep(cmd, " ");
+ 	if (!arg)
+ 		return -EINVAL;
  
+ 	if (sysfs_streq(arg, "index")) {
  		hp_elog->id_type = PSERIES_HP_ELOG_ID_DRC_INDEX;
- 		arg += strlen("index ");
+ 		arg = strsep(cmd, " ");
+ 		if (!arg) {
+ 			pr_err("No DRC Index specified.\n");
+ 			return -EINVAL;
+ 		}
+ 
  		if (kstrtou32(arg, 0, &index)) {
- 			rc = -EINVAL;
- 			pr_err("Invalid drc_index specified: \"%s\"\n", buf);
- 			goto dlpar_store_out;
+ 			pr_err("Invalid DRC Index specified.\n");
+ 			return -EINVAL;
  		}
  
  		hp_elog->_drc_u.drc_index = cpu_to_be32(index);
@@@ -663,10 -496,46 +721,61 @@@
  
  		hp_elog->_drc_u.drc_count = cpu_to_be32(count);
  	} else {
- 		pr_err("Invalid id_type specified: \"%s\"\n", buf);
+ 		pr_err("Invalid id_type specified.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 25b587fba9a4 (powerpc/pseries: Correct possible read beyond dlpar sysfs buffer)
+ static ssize_t dlpar_store(struct class *class, struct class_attribute *attr,
+ 			   const char *buf, size_t count)
+ {
+ 	struct pseries_hp_errorlog *hp_elog;
++<<<<<<< HEAD
++	const char *arg;
++=======
+ 	struct completion hotplug_done;
+ 	char *argbuf;
+ 	char *args;
++>>>>>>> 25b587fba9a4 (powerpc/pseries: Correct possible read beyond dlpar sysfs buffer)
+ 	int rc;
+ 
+ 	args = argbuf = kstrdup(buf, GFP_KERNEL);
+ 	hp_elog = kzalloc(sizeof(*hp_elog), GFP_KERNEL);
+ 	if (!hp_elog || !argbuf) {
+ 		pr_info("Could not allocate resources for DLPAR operation\n");
+ 		kfree(argbuf);
+ 		kfree(hp_elog);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	/*
+ 	 * Parse out the request from the user, this will be in the form:
+ 	 * <resource> <action> <id_type> <id>
+ 	 */
++<<<<<<< HEAD
++	arg = buf;
++	if (!strncmp(arg, "memory", 6)) {
++		hp_elog->resource = PSERIES_HP_ELOG_RESOURCE_MEM;
++		arg += strlen("memory ");
++	} else {
++		pr_err("Invalid resource specified: \"%s\"\n", buf);
 +		rc = -EINVAL;
++=======
+ 	rc = dlpar_parse_resource(&args, hp_elog);
+ 	if (rc)
++>>>>>>> 25b587fba9a4 (powerpc/pseries: Correct possible read beyond dlpar sysfs buffer)
+ 		goto dlpar_store_out;
+ 
+ 	rc = dlpar_parse_action(&args, hp_elog);
+ 	if (rc)
+ 		goto dlpar_store_out;
+ 
+ 	rc = dlpar_parse_id_type(&args, hp_elog);
+ 	if (rc)
  		goto dlpar_store_out;
- 	}
  
  	init_completion(&hotplug_done);
  	queue_hotplug_event(hp_elog, &hotplug_done, &rc);
* Unmerged path arch/powerpc/platforms/pseries/dlpar.c
