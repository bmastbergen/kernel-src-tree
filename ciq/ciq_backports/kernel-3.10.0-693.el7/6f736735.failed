perf evsel: Require that callchains be resolved before calling fprintf_{sym,callchain}

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [tools] perf evsel: Require that callchains be resolved before calling fprintf_{sym, callchain} (Jiri Olsa) [1373817]
Rebuild_FUZZ: 99.42%
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 6f736735e30f51805f6be31d20a4bf5b0ae91bae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6f736735.failed

This way the print routine merely does printing, not requiring access to
the resolving machinery, which helps disentangling the object files and
easing creating subsets with a limited functionality set.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-2ti2jbra8fypdfawwwm3aee3@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 6f736735e30f51805f6be31d20a4bf5b0ae91bae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-script.c
#	tools/perf/builtin-trace.c
#	tools/perf/util/evsel.c
#	tools/perf/util/evsel.h
diff --cc tools/perf/builtin-script.c
index bea425037a92,875d84e7ba5b..000000000000
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@@ -567,18 -569,23 +567,37 @@@ static void print_sample_bts(struct per
  	/* print branch_from information */
  	if (PRINT_FIELD(IP)) {
  		unsigned int print_opts = output[attr->type].print_ip_opts;
+ 		struct callchain_cursor *cursor = NULL, cursor_callchain;
  
++<<<<<<< HEAD
 +		if (symbol_conf.use_callchain && sample->callchain) {
 +			printf("\n");
 +		} else {
 +			printf(" ");
 +			if (print_opts & PRINT_IP_OPT_SRCLINE) {
++=======
+ 		if (symbol_conf.use_callchain && sample->callchain &&
+ 		    thread__resolve_callchain(al->thread, &cursor_callchain, evsel,
+ 					      sample, NULL, NULL, scripting_max_stack) == 0)
+ 			cursor = &cursor_callchain;
+ 
+ 		if (cursor == NULL) {
+ 			putchar(' ');
+ 			if (print_opts & EVSEL__PRINT_SRCLINE) {
++>>>>>>> 6f736735e30f (perf evsel: Require that callchains be resolved before calling fprintf_{sym,callchain})
  				print_srcline_last = true;
 -				print_opts &= ~EVSEL__PRINT_SRCLINE;
 +				print_opts &= ~PRINT_IP_OPT_SRCLINE;
  			}
++<<<<<<< HEAD
 +		}
 +		perf_evsel__print_ip(evsel, sample, al, 0, print_opts,
 +				     scripting_max_stack, stdout);
++=======
+ 		} else
+ 			putchar('\n');
+ 
+ 		sample__fprintf_sym(sample, al, 0, print_opts, cursor, stdout);
++>>>>>>> 6f736735e30f (perf evsel: Require that callchains be resolved before calling fprintf_{sym,callchain})
  	}
  
  	/* print branch_to information */
@@@ -703,14 -788,15 +722,21 @@@ static void process_event(struct perf_s
  		printf("%16" PRIu64, sample->weight);
  
  	if (PRINT_FIELD(IP)) {
- 		if (!symbol_conf.use_callchain)
- 			printf(" ");
- 		else
- 			printf("\n");
+ 		struct callchain_cursor *cursor = NULL, cursor_callchain;
  
++<<<<<<< HEAD
 +		perf_evsel__print_ip(evsel, sample, al, 0,
 +				     output[attr->type].print_ip_opts,
 +				     scripting_max_stack, stdout);
++=======
+ 		if (symbol_conf.use_callchain &&
+ 		    thread__resolve_callchain(al->thread, &cursor_callchain, evsel,
+ 					      sample, NULL, NULL, scripting_max_stack) == 0)
+ 			cursor = &cursor_callchain;
+ 
+ 		putchar(cursor ? '\n' : ' ');
+ 		sample__fprintf_sym(sample, al, 0, output[attr->type].print_ip_opts, cursor, stdout);
++>>>>>>> 6f736735e30f (perf evsel: Require that callchains be resolved before calling fprintf_{sym,callchain})
  	}
  
  	if (PRINT_FIELD(IREGS))
diff --cc tools/perf/builtin-trace.c
index 5c663a0da608,0e2a82bda22f..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -1869,6 -1878,30 +1869,33 @@@ out_put
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int trace__fprintf_callchain(struct trace *trace, struct perf_evsel *evsel,
+ 				    struct perf_sample *sample)
+ {
+ 	struct addr_location al;
+ 	/* TODO: user-configurable print_opts */
+ 	const unsigned int print_opts = EVSEL__PRINT_SYM |
+ 				        EVSEL__PRINT_DSO |
+ 				        EVSEL__PRINT_UNKNOWN_AS_ADDR;
+ 
+ 	if (sample->callchain == NULL)
+ 		return 0;
+ 
+ 	if (machine__resolve(trace->host, &al, sample) < 0 ||
+ 	    thread__resolve_callchain(al.thread, &callchain_cursor, evsel,
+ 				      sample, NULL, NULL, scripting_max_stack)) {
+ 		pr_err("Problem processing %s callchain, skipping...\n",
+ 			perf_evsel__name(evsel));
+ 		return 0;
+ 	}
+ 
+ 	return sample__fprintf_callchain(sample, &al, 38, print_opts,
+ 					 &callchain_cursor, trace->output);
+ }
+ 
++>>>>>>> 6f736735e30f (perf evsel: Require that callchains be resolved before calling fprintf_{sym,callchain})
  static int trace__sys_exit(struct trace *trace, struct perf_evsel *evsel,
  			   union perf_event *event __maybe_unused,
  			   struct perf_sample *sample)
diff --cc tools/perf/util/evsel.c
index e0478f1149c9,35c5a5282239..000000000000
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@@ -2281,6 -2343,127 +2281,130 @@@ out
  	return ++printed;
  }
  
++<<<<<<< HEAD
++=======
+ int sample__fprintf_callchain(struct perf_sample *sample,
+ 			      struct addr_location *al, int left_alignment,
+ 			      unsigned int print_opts, struct callchain_cursor *cursor,
+ 			      FILE *fp)
+ {
+ 	int printed = 0;
+ 	struct callchain_cursor_node *node;
+ 	int print_ip = print_opts & EVSEL__PRINT_IP;
+ 	int print_sym = print_opts & EVSEL__PRINT_SYM;
+ 	int print_dso = print_opts & EVSEL__PRINT_DSO;
+ 	int print_symoffset = print_opts & EVSEL__PRINT_SYMOFFSET;
+ 	int print_oneline = print_opts & EVSEL__PRINT_ONELINE;
+ 	int print_srcline = print_opts & EVSEL__PRINT_SRCLINE;
+ 	int print_unknown_as_addr = print_opts & EVSEL__PRINT_UNKNOWN_AS_ADDR;
+ 	char s = print_oneline ? ' ' : '\t';
+ 
+ 	if (sample->callchain) {
+ 		struct addr_location node_al;
+ 
+ 		callchain_cursor_commit(cursor);
+ 
+ 		if (print_symoffset)
+ 			node_al = *al;
+ 
+ 		while (1) {
+ 			u64 addr = 0;
+ 
+ 			node = callchain_cursor_current(cursor);
+ 			if (!node)
+ 				break;
+ 
+ 			if (node->sym && node->sym->ignore)
+ 				goto next;
+ 
+ 			printed += fprintf(fp, "%-*.*s", left_alignment, left_alignment, " ");
+ 
+ 			if (print_ip)
+ 				printed += fprintf(fp, "%c%16" PRIx64, s, node->ip);
+ 
+ 			if (node->map)
+ 				addr = node->map->map_ip(node->map, node->ip);
+ 
+ 			if (print_sym) {
+ 				printed += fprintf(fp, " ");
+ 				node_al.addr = addr;
+ 				node_al.map  = node->map;
+ 
+ 				if (print_symoffset) {
+ 					printed += __symbol__fprintf_symname_offs(node->sym, &node_al,
+ 										  print_unknown_as_addr, fp);
+ 				} else {
+ 					printed += __symbol__fprintf_symname(node->sym, &node_al,
+ 									     print_unknown_as_addr, fp);
+ 				}
+ 			}
+ 
+ 			if (print_dso) {
+ 				printed += fprintf(fp, " (");
+ 				printed += map__fprintf_dsoname(node->map, fp);
+ 				printed += fprintf(fp, ")");
+ 			}
+ 
+ 			if (print_srcline)
+ 				printed += map__fprintf_srcline(node->map, addr, "\n  ", fp);
+ 
+ 			if (!print_oneline)
+ 				printed += fprintf(fp, "\n");
+ next:
+ 			callchain_cursor_advance(cursor);
+ 		}
+ 	}
+ 
+ 	return printed;
+ }
+ 
+ int sample__fprintf_sym(struct perf_sample *sample, struct addr_location *al,
+ 			int left_alignment, unsigned int print_opts,
+ 			struct callchain_cursor *cursor, FILE *fp)
+ {
+ 	int printed = 0;
+ 	int print_ip = print_opts & EVSEL__PRINT_IP;
+ 	int print_sym = print_opts & EVSEL__PRINT_SYM;
+ 	int print_dso = print_opts & EVSEL__PRINT_DSO;
+ 	int print_symoffset = print_opts & EVSEL__PRINT_SYMOFFSET;
+ 	int print_srcline = print_opts & EVSEL__PRINT_SRCLINE;
+ 	int print_unknown_as_addr = print_opts & EVSEL__PRINT_UNKNOWN_AS_ADDR;
+ 
+ 	if (cursor != NULL) {
+ 		printed += sample__fprintf_callchain(sample, al, left_alignment,
+ 						     print_opts, cursor, fp);
+ 	} else if (!(al->sym && al->sym->ignore)) {
+ 		printed += fprintf(fp, "%-*.*s", left_alignment, left_alignment, " ");
+ 
+ 		if (print_ip)
+ 			printed += fprintf(fp, "%16" PRIx64, sample->ip);
+ 
+ 		if (print_sym) {
+ 			printed += fprintf(fp, " ");
+ 			if (print_symoffset) {
+ 				printed += __symbol__fprintf_symname_offs(al->sym, al,
+ 									  print_unknown_as_addr, fp);
+ 			} else {
+ 				printed += __symbol__fprintf_symname(al->sym, al,
+ 								     print_unknown_as_addr, fp);
+ 			}
+ 		}
+ 
+ 		if (print_dso) {
+ 			printed += fprintf(fp, " (");
+ 			printed += map__fprintf_dsoname(al->map, fp);
+ 			printed += fprintf(fp, ")");
+ 		}
+ 
+ 		if (print_srcline)
+ 			printed += map__fprintf_srcline(al->map, al->addr, "\n  ", fp);
+ 	}
+ 
+ 	return printed;
+ }
+ 
+ 
++>>>>>>> 6f736735e30f (perf evsel: Require that callchains be resolved before calling fprintf_{sym,callchain})
  bool perf_evsel__fallback(struct perf_evsel *evsel, int err,
  			  char *msg, size_t msgsize)
  {
diff --cc tools/perf/util/evsel.h
index 8b108cb05d6f,abadfea1dbaa..000000000000
--- a/tools/perf/util/evsel.h
+++ b/tools/perf/util/evsel.h
@@@ -372,6 -387,24 +372,27 @@@ struct perf_attr_details 
  int perf_evsel__fprintf(struct perf_evsel *evsel,
  			struct perf_attr_details *details, FILE *fp);
  
++<<<<<<< HEAD
++=======
+ #define EVSEL__PRINT_IP			(1<<0)
+ #define EVSEL__PRINT_SYM		(1<<1)
+ #define EVSEL__PRINT_DSO		(1<<2)
+ #define EVSEL__PRINT_SYMOFFSET		(1<<3)
+ #define EVSEL__PRINT_ONELINE		(1<<4)
+ #define EVSEL__PRINT_SRCLINE		(1<<5)
+ #define EVSEL__PRINT_UNKNOWN_AS_ADDR	(1<<6)
+ 
+ struct callchain_cursor;
+ 
+ int sample__fprintf_callchain(struct perf_sample *sample, struct addr_location *al,
+ 			      int left_alignment, unsigned int print_opts,
+ 			      struct callchain_cursor *cursor, FILE *fp);
+ 
+ int sample__fprintf_sym(struct perf_sample *sample, struct addr_location *al,
+ 			int left_alignment, unsigned int print_opts,
+ 			struct callchain_cursor *cursor, FILE *fp);
+ 
++>>>>>>> 6f736735e30f (perf evsel: Require that callchains be resolved before calling fprintf_{sym,callchain})
  bool perf_evsel__fallback(struct perf_evsel *evsel, int err,
  			  char *msg, size_t msgsize);
  int perf_evsel__open_strerror(struct perf_evsel *evsel, struct target *target,
* Unmerged path tools/perf/builtin-script.c
* Unmerged path tools/perf/builtin-trace.c
* Unmerged path tools/perf/util/evsel.c
* Unmerged path tools/perf/util/evsel.h
