ACPICA: Core: Major update for code formatting, no functional changes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Bob Moore <robert.moore@intel.com>
commit 1fad87385e7e82f656fb661aef0f841e42991974
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1fad8738.failed

ACPICA commit dfa394471f6c01b2ee9433dbc143ec70cb9bca72

Mostly indentation inconsistencies across the code. Split
some long lines, etc.

Link: https://github.com/acpica/acpica/commit/dfa39447
	Signed-off-by: Bob Moore <robert.moore@intel.com>
	Signed-off-by: Lv Zheng <lv.zheng@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 1fad87385e7e82f656fb661aef0f841e42991974)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpica/dbstats.c
#	drivers/acpi/acpica/dbutils.c
#	drivers/acpi/acpica/dsdebug.c
#	drivers/acpi/acpica/dsfield.c
#	drivers/acpi/acpica/dsinit.c
#	drivers/acpi/acpica/dsmethod.c
#	drivers/acpi/acpica/dsutils.c
#	drivers/acpi/acpica/evxface.c
#	drivers/acpi/acpica/exconvrt.c
#	drivers/acpi/acpica/excreate.c
#	drivers/acpi/acpica/exdebug.c
#	drivers/acpi/acpica/exfield.c
#	drivers/acpi/acpica/exoparg3.c
#	drivers/acpi/acpica/exregion.c
#	drivers/acpi/acpica/exstore.c
#	drivers/acpi/acpica/exsystem.c
#	drivers/acpi/acpica/hwgpe.c
#	drivers/acpi/acpica/nsnames.c
#	drivers/acpi/acpica/nsrepair2.c
#	drivers/acpi/acpica/psloop.c
#	drivers/acpi/acpica/rscreate.c
#	drivers/acpi/acpica/rsmisc.c
#	drivers/acpi/acpica/rsutils.c
#	drivers/acpi/acpica/tbdata.c
#	drivers/acpi/acpica/tbinstal.c
#	drivers/acpi/acpica/tbutils.c
#	drivers/acpi/acpica/tbxfload.c
#	drivers/acpi/acpica/utdelete.c
#	drivers/acpi/acpica/utfileio.c
#	drivers/acpi/acpica/utnonansi.c
#	drivers/acpi/acpica/utobject.c
#	drivers/acpi/acpica/utosi.c
#	drivers/acpi/acpica/utprint.c
#	drivers/acpi/acpica/utxface.c
#	drivers/acpi/acpica/utxferror.c
#	tools/power/acpi/common/getopt.c
#	tools/power/acpi/tools/acpidump/apfiles.c
diff --cc drivers/acpi/acpica/dsfield.c
index d4bfe7b7f90a,6bca0ec42dbd..000000000000
--- a/drivers/acpi/acpica/dsfield.c
+++ b/drivers/acpi/acpica/dsfield.c
@@@ -105,7 -105,8 +105,12 @@@ acpi_ds_create_external_region(acpi_sta
  	 * operation_region not found. Generate an External for it, and
  	 * insert the name into the namespace.
  	 */
++<<<<<<< HEAD
 +	acpi_dm_add_to_external_list(op, path, ACPI_TYPE_REGION, 0);
++=======
+ 	acpi_dm_add_op_to_external_list(op, path, ACPI_TYPE_REGION, 0, 0);
+ 
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  	status = acpi_ns_lookup(walk_state->scope_info, path, ACPI_TYPE_REGION,
  				ACPI_IMODE_LOAD_PASS1, ACPI_NS_SEARCH_PARENT,
  				walk_state, node);
@@@ -310,8 -310,8 +314,13 @@@ acpi_ds_get_field_names(struct acpi_cre
  		switch (arg->common.aml_opcode) {
  		case AML_INT_RESERVEDFIELD_OP:
  
++<<<<<<< HEAD
 +			position = (u64) info->field_bit_position
 +			    + (u64) arg->common.value.size;
++=======
+ 			position = (u64)info->field_bit_position +
+ 			    (u64)arg->common.value.size;
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  
  			if (position > ACPI_UINT32_MAX) {
  				ACPI_ERROR((AE_INFO,
@@@ -424,8 -425,8 +433,13 @@@
  
  			/* Keep track of bit position for the next field */
  
++<<<<<<< HEAD
 +			position = (u64) info->field_bit_position
 +			    + (u64) arg->common.value.size;
++=======
+ 			position = (u64)info->field_bit_position +
+ 			    (u64)arg->common.value.size;
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  
  			if (position > ACPI_UINT32_MAX) {
  				ACPI_ERROR((AE_INFO,
diff --cc drivers/acpi/acpica/dsinit.c
index 14424200d246,c1d8af8a8aaf..000000000000
--- a/drivers/acpi/acpica/dsinit.c
+++ b/drivers/acpi/acpica/dsinit.c
@@@ -204,15 -237,27 +204,26 @@@ acpi_ds_initialize_objects(u32 table_in
  		return_ACPI_STATUS(status);
  	}
  
 -	/* DSDT is always the first AML table */
 -
 -	if (ACPI_COMPARE_NAME(table->signature, ACPI_SIG_DSDT)) {
 -		ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,
 -				      "\nInitializing Namespace objects:\n"));
 -	}
 -
 -	/* Summary of objects initialized */
 -
  	ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,
++<<<<<<< HEAD
 +			      "\nTable [%4.4s](id %4.4X) - %u Objects with %u Devices %u Methods %u Regions\n",
 +			      table->signature, owner_id, info.object_count,
 +			      info.device_count, info.method_count,
 +			      info.op_region_count));
++=======
+ 			      "Table [%4.4s: %-8.8s] (id %.2X) - %4u Objects with %3u Devices, "
+ 			      "%3u Regions, %4u Methods (%u/%u/%u Serial/Non/Cvt)\n",
+ 			      table->signature, table->oem_table_id, owner_id,
+ 			      info.object_count, info.device_count,
+ 			      info.op_region_count, info.method_count,
+ 			      info.serial_method_count,
+ 			      info.non_serial_method_count,
+ 			      info.serialized_method_count));
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  
 -	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH, "%u Methods, %u Regions\n",
 -			  info.method_count, info.op_region_count));
 +	ACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,
 +			  "%u Methods, %u Regions\n", info.method_count,
 +			  info.op_region_count));
  
  	return_ACPI_STATUS(AE_OK);
  }
diff --cc drivers/acpi/acpica/dsmethod.c
index 2184259c386b,6585e8e37c8e..000000000000
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@@ -59,6 -63,137 +59,140 @@@ acpi_ds_create_method_mutex(union acpi_
  
  /*******************************************************************************
   *
++<<<<<<< HEAD
++=======
+  * FUNCTION:    acpi_ds_auto_serialize_method
+  *
+  * PARAMETERS:  node                        - Namespace Node of the method
+  *              obj_desc                    - Method object attached to node
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: Parse a control method AML to scan for control methods that
+  *              need serialization due to the creation of named objects.
+  *
+  * NOTE: It is a bit of overkill to mark all such methods serialized, since
+  * there is only a problem if the method actually blocks during execution.
+  * A blocking operation is, for example, a Sleep() operation, or any access
+  * to an operation region. However, it is probably not possible to easily
+  * detect whether a method will block or not, so we simply mark all suspicious
+  * methods as serialized.
+  *
+  * NOTE2: This code is essentially a generic routine for parsing a single
+  * control method.
+  *
+  ******************************************************************************/
+ 
+ acpi_status
+ acpi_ds_auto_serialize_method(struct acpi_namespace_node *node,
+ 			      union acpi_operand_object *obj_desc)
+ {
+ 	acpi_status status;
+ 	union acpi_parse_object *op = NULL;
+ 	struct acpi_walk_state *walk_state;
+ 
+ 	ACPI_FUNCTION_TRACE_PTR(ds_auto_serialize_method, node);
+ 
+ 	ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+ 			  "Method auto-serialization parse [%4.4s] %p\n",
+ 			  acpi_ut_get_node_name(node), node));
+ 
+ 	/* Create/Init a root op for the method parse tree */
+ 
+ 	op = acpi_ps_alloc_op(AML_METHOD_OP, obj_desc->method.aml_start);
+ 	if (!op) {
+ 		return_ACPI_STATUS(AE_NO_MEMORY);
+ 	}
+ 
+ 	acpi_ps_set_name(op, node->name.integer);
+ 	op->common.node = node;
+ 
+ 	/* Create and initialize a new walk state */
+ 
+ 	walk_state =
+ 	    acpi_ds_create_walk_state(node->owner_id, NULL, NULL, NULL);
+ 	if (!walk_state) {
+ 		acpi_ps_free_op(op);
+ 		return_ACPI_STATUS(AE_NO_MEMORY);
+ 	}
+ 
+ 	status = acpi_ds_init_aml_walk(walk_state, op, node,
+ 				       obj_desc->method.aml_start,
+ 				       obj_desc->method.aml_length, NULL, 0);
+ 	if (ACPI_FAILURE(status)) {
+ 		acpi_ds_delete_walk_state(walk_state);
+ 		acpi_ps_free_op(op);
+ 		return_ACPI_STATUS(status);
+ 	}
+ 
+ 	walk_state->descending_callback = acpi_ds_detect_named_opcodes;
+ 
+ 	/* Parse the method, scan for creation of named objects */
+ 
+ 	status = acpi_ps_parse_aml(walk_state);
+ 
+ 	acpi_ps_delete_parse_tree(op);
+ 	return_ACPI_STATUS(status);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_ds_detect_named_opcodes
+  *
+  * PARAMETERS:  walk_state      - Current state of the parse tree walk
+  *              out_op          - Unused, required for parser interface
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: Descending callback used during the loading of ACPI tables.
+  *              Currently used to detect methods that must be marked serialized
+  *              in order to avoid problems with the creation of named objects.
+  *
+  ******************************************************************************/
+ 
+ static acpi_status
+ acpi_ds_detect_named_opcodes(struct acpi_walk_state *walk_state,
+ 			     union acpi_parse_object **out_op)
+ {
+ 
+ 	ACPI_FUNCTION_NAME(acpi_ds_detect_named_opcodes);
+ 
+ 	/* We are only interested in opcodes that create a new name */
+ 
+ 	if (!
+ 	    (walk_state->op_info->
+ 	     flags & (AML_NAMED | AML_CREATE | AML_FIELD))) {
+ 		return (AE_OK);
+ 	}
+ 
+ 	/*
+ 	 * At this point, we know we have a Named object opcode.
+ 	 * Mark the method as serialized. Later code will create a mutex for
+ 	 * this method to enforce serialization.
+ 	 *
+ 	 * Note, ACPI_METHOD_IGNORE_SYNC_LEVEL flag means that we will ignore the
+ 	 * Sync Level mechanism for this method, even though it is now serialized.
+ 	 * Otherwise, there can be conflicts with existing ASL code that actually
+ 	 * uses sync levels.
+ 	 */
+ 	walk_state->method_desc->method.sync_level = 0;
+ 	walk_state->method_desc->method.info_flags |=
+ 	    (ACPI_METHOD_SERIALIZED | ACPI_METHOD_IGNORE_SYNC_LEVEL);
+ 
+ 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+ 			  "Method serialized [%4.4s] %p - [%s] (%4.4X)\n",
+ 			  walk_state->method_node->name.ascii,
+ 			  walk_state->method_node, walk_state->op_info->name,
+ 			  walk_state->opcode));
+ 
+ 	/* Abort the parse, no need to examine this method any further */
+ 
+ 	return (AE_CTRL_TERMINATE);
+ }
+ 
+ /*******************************************************************************
+  *
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
   * FUNCTION:    acpi_ds_method_error
   *
   * PARAMETERS:  status          - Execution status
@@@ -222,10 -369,13 +356,11 @@@ acpi_ds_begin_method_execution(struct a
  		 * Top-level method invocation has no walk state at this point
  		 */
  		if (walk_state &&
 -		    (!(obj_desc->method.
 -		       info_flags & ACPI_METHOD_IGNORE_SYNC_LEVEL))
 -		    && (walk_state->thread->current_sync_level >
 -			obj_desc->method.mutex->mutex.sync_level)) {
 +		    (walk_state->thread->current_sync_level >
 +		     obj_desc->method.mutex->mutex.sync_level)) {
  			ACPI_ERROR((AE_INFO,
- 				    "Cannot acquire Mutex for method [%4.4s], current SyncLevel is too large (%u)",
+ 				    "Cannot acquire Mutex for method [%4.4s]"
+ 				    ", current SyncLevel is too large (%u)",
  				    acpi_ut_get_node_name(method_node),
  				    walk_state->thread->current_sync_level));
  
@@@ -669,8 -829,10 +807,9 @@@ acpi_ds_terminate_control_method(union 
  			 */
  			method_desc->method.info_flags &=
  			    ~ACPI_METHOD_SERIALIZED_PENDING;
+ 
  			method_desc->method.info_flags |=
 -			    (ACPI_METHOD_SERIALIZED |
 -			     ACPI_METHOD_IGNORE_SYNC_LEVEL);
 +			    ACPI_METHOD_SERIALIZED;
  			method_desc->method.sync_level = 0;
  		}
  
diff --cc drivers/acpi/acpica/dsutils.c
index c666fc014987,fa8e2920a3ef..000000000000
--- a/drivers/acpi/acpica/dsutils.c
+++ b/drivers/acpi/acpica/dsutils.c
@@@ -503,9 -502,8 +502,14 @@@ acpi_ds_create_operand(struct acpi_walk
  		 */
  		if ((walk_state->deferred_node) &&
  		    (walk_state->deferred_node->type == ACPI_TYPE_BUFFER_FIELD)
++<<<<<<< HEAD
 +		    && (arg_index ==
 +			(u32) ((walk_state->opcode ==
 +				AML_CREATE_FIELD_OP) ? 3 : 2))) {
++=======
+ 		    && (arg_index == (u32)
+ 			((walk_state->opcode == AML_CREATE_FIELD_OP) ? 3 : 2))) {
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  			obj_desc =
  			    ACPI_CAST_PTR(union acpi_operand_object,
  					  walk_state->deferred_node);
diff --cc drivers/acpi/acpica/evxface.c
index 00d67a948816,012b9dedfa79..000000000000
--- a/drivers/acpi/acpica/evxface.c
+++ b/drivers/acpi/acpica/evxface.c
@@@ -681,10 -852,77 +681,83 @@@ free_and_exit
  	goto unlock_and_exit;
  }
  
++<<<<<<< HEAD
++=======
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_install_gpe_handler
+  *
+  * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT
+  *                                defined GPEs)
+  *              gpe_number      - The GPE number within the GPE block
+  *              type            - Whether this GPE should be treated as an
+  *                                edge- or level-triggered interrupt.
+  *              address         - Address of the handler
+  *              context         - Value passed to the handler on each GPE
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: Install a handler for a General Purpose Event.
+  *
+  ******************************************************************************/
+ 
+ acpi_status
+ acpi_install_gpe_handler(acpi_handle gpe_device,
+ 			 u32 gpe_number,
+ 			 u32 type, acpi_gpe_handler address, void *context)
+ {
+ 	acpi_status status;
+ 
+ 	ACPI_FUNCTION_TRACE(acpi_install_gpe_handler);
+ 
+ 	status = acpi_ev_install_gpe_handler(gpe_device, gpe_number, type,
+ 					     FALSE, address, context);
+ 
+ 	return_ACPI_STATUS(status);
+ }
+ 
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  ACPI_EXPORT_SYMBOL(acpi_install_gpe_handler)
  
  /*******************************************************************************
   *
++<<<<<<< HEAD
++=======
+  * FUNCTION:    acpi_install_gpe_raw_handler
+  *
+  * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT
+  *                                defined GPEs)
+  *              gpe_number      - The GPE number within the GPE block
+  *              type            - Whether this GPE should be treated as an
+  *                                edge- or level-triggered interrupt.
+  *              address         - Address of the handler
+  *              context         - Value passed to the handler on each GPE
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: Install a handler for a General Purpose Event.
+  *
+  ******************************************************************************/
+ acpi_status
+ acpi_install_gpe_raw_handler(acpi_handle gpe_device,
+ 			     u32 gpe_number,
+ 			     u32 type, acpi_gpe_handler address, void *context)
+ {
+ 	acpi_status status;
+ 
+ 	ACPI_FUNCTION_TRACE(acpi_install_gpe_raw_handler);
+ 
+ 	status = acpi_ev_install_gpe_handler(gpe_device, gpe_number, type,
+ 					     TRUE, address, context);
+ 
+ 	return_ACPI_STATUS(status);
+ }
+ 
+ ACPI_EXPORT_SYMBOL(acpi_install_gpe_raw_handler)
+ 
+ /*******************************************************************************
+  *
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
   * FUNCTION:    acpi_remove_gpe_handler
   *
   * PARAMETERS:  gpe_device      - Namespace node for the GPE (NULL for FADT
diff --cc drivers/acpi/acpica/exconvrt.c
index 69e4a8cc9b71,73c2e823488d..000000000000
--- a/drivers/acpi/acpica/exconvrt.c
+++ b/drivers/acpi/acpica/exconvrt.c
@@@ -227,9 -227,8 +227,14 @@@ acpi_ex_convert_to_buffer(union acpi_op
  		/* Copy the integer to the buffer, LSB first */
  
  		new_buf = return_desc->buffer.pointer;
++<<<<<<< HEAD
 +		ACPI_MEMCPY(new_buf,
 +			    &obj_desc->integer.value,
 +			    acpi_gbl_integer_byte_width);
++=======
+ 		memcpy(new_buf, &obj_desc->integer.value,
+ 		       acpi_gbl_integer_byte_width);
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  		break;
  
  	case ACPI_TYPE_STRING:
@@@ -355,9 -354,8 +360,14 @@@ acpi_ex_convert_to_ascii(u64 integer, u
  
  			/* Get one hex digit, most significant digits first */
  
++<<<<<<< HEAD
 +			string[k] =
 +			    (u8) acpi_ut_hex_to_ascii_char(integer,
 +							   ACPI_MUL_4(j));
++=======
+ 			string[k] = (u8)
+ 			    acpi_ut_hex_to_ascii_char(integer, ACPI_MUL_4(j));
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  			k++;
  		}
  		break;
diff --cc drivers/acpi/acpica/excreate.c
index 269e81d86ef4,0f3444647f52..000000000000
--- a/drivers/acpi/acpica/excreate.c
+++ b/drivers/acpi/acpica/excreate.c
@@@ -189,11 -189,11 +189,11 @@@ acpi_status acpi_ex_create_event(struc
  
  	/* Attach object to the Node */
  
- 	status =
- 	    acpi_ns_attach_object((struct acpi_namespace_node *)walk_state->
- 				  operands[0], obj_desc, ACPI_TYPE_EVENT);
+ 	status = acpi_ns_attach_object((struct acpi_namespace_node *)
+ 				       walk_state->operands[0], obj_desc,
+ 				       ACPI_TYPE_EVENT);
  
 -cleanup:
 +      cleanup:
  	/*
  	 * Remove local reference to the object (on error, will cause deletion
  	 * of both object and semaphore if present.)
@@@ -491,10 -492,9 +491,16 @@@ acpi_ex_create_method(u8 * aml_start
  	 * Disassemble the method flags. Split off the arg_count, Serialized
  	 * flag, and sync_level for efficiency.
  	 */
++<<<<<<< HEAD
 +	method_flags = (u8) operand[1]->integer.value;
 +
 +	obj_desc->method.param_count =
 +	    (u8) (method_flags & AML_METHOD_ARG_COUNT);
++=======
+ 	method_flags = (u8)operand[1]->integer.value;
+ 	obj_desc->method.param_count = (u8)
+ 	    (method_flags & AML_METHOD_ARG_COUNT);
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  
  	/*
  	 * Get the sync_level. If method is serialized, a mutex will be
diff --cc drivers/acpi/acpica/exdebug.c
index 81c72a4ecd82,665a4b9556e2..000000000000
--- a/drivers/acpi/acpica/exdebug.c
+++ b/drivers/acpi/acpica/exdebug.c
@@@ -261,3 -319,317 +261,320 @@@ acpi_ex_do_debug_object(union acpi_oper
  	return_VOID;
  }
  #endif
++<<<<<<< HEAD
++=======
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_ex_interpreter_trace_enabled
+  *
+  * PARAMETERS:  name                - Whether method name should be matched,
+  *                                    this should be checked before starting
+  *                                    the tracer
+  *
+  * RETURN:      TRUE if interpreter trace is enabled.
+  *
+  * DESCRIPTION: Check whether interpreter trace is enabled
+  *
+  ******************************************************************************/
+ 
+ static u8 acpi_ex_interpreter_trace_enabled(char *name)
+ {
+ 
+ 	/* Check if tracing is enabled */
+ 
+ 	if (!(acpi_gbl_trace_flags & ACPI_TRACE_ENABLED)) {
+ 		return (FALSE);
+ 	}
+ 
+ 	/*
+ 	 * Check if tracing is filtered:
+ 	 *
+ 	 * 1. If the tracer is started, acpi_gbl_trace_method_object should have
+ 	 *    been filled by the trace starter
+ 	 * 2. If the tracer is not started, acpi_gbl_trace_method_name should be
+ 	 *    matched if it is specified
+ 	 * 3. If the tracer is oneshot style, acpi_gbl_trace_method_name should
+ 	 *    not be cleared by the trace stopper during the first match
+ 	 */
+ 	if (acpi_gbl_trace_method_object) {
+ 		return (TRUE);
+ 	}
+ 	if (name &&
+ 	    (acpi_gbl_trace_method_name &&
+ 	     strcmp(acpi_gbl_trace_method_name, name))) {
+ 		return (FALSE);
+ 	}
+ 	if ((acpi_gbl_trace_flags & ACPI_TRACE_ONESHOT) &&
+ 	    !acpi_gbl_trace_method_name) {
+ 		return (FALSE);
+ 	}
+ 
+ 	return (TRUE);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_ex_get_trace_event_name
+  *
+  * PARAMETERS:  type            - Trace event type
+  *
+  * RETURN:      Trace event name.
+  *
+  * DESCRIPTION: Used to obtain the full trace event name.
+  *
+  ******************************************************************************/
+ 
+ #ifdef ACPI_DEBUG_OUTPUT
+ 
+ static const char *acpi_ex_get_trace_event_name(acpi_trace_event_type type)
+ {
+ 	switch (type) {
+ 	case ACPI_TRACE_AML_METHOD:
+ 
+ 		return "Method";
+ 
+ 	case ACPI_TRACE_AML_OPCODE:
+ 
+ 		return "Opcode";
+ 
+ 	case ACPI_TRACE_AML_REGION:
+ 
+ 		return "Region";
+ 
+ 	default:
+ 
+ 		return "";
+ 	}
+ }
+ 
+ #endif
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_ex_trace_point
+  *
+  * PARAMETERS:  type                - Trace event type
+  *              begin               - TRUE if before execution
+  *              aml                 - Executed AML address
+  *              pathname            - Object path
+  *
+  * RETURN:      None
+  *
+  * DESCRIPTION: Internal interpreter execution trace.
+  *
+  ******************************************************************************/
+ 
+ void
+ acpi_ex_trace_point(acpi_trace_event_type type,
+ 		    u8 begin, u8 *aml, char *pathname)
+ {
+ 
+ 	ACPI_FUNCTION_NAME(ex_trace_point);
+ 
+ 	if (pathname) {
+ 		ACPI_DEBUG_PRINT((ACPI_DB_TRACE_POINT,
+ 				  "%s %s [0x%p:%s] execution.\n",
+ 				  acpi_ex_get_trace_event_name(type),
+ 				  begin ? "Begin" : "End", aml, pathname));
+ 	} else {
+ 		ACPI_DEBUG_PRINT((ACPI_DB_TRACE_POINT,
+ 				  "%s %s [0x%p] execution.\n",
+ 				  acpi_ex_get_trace_event_name(type),
+ 				  begin ? "Begin" : "End", aml));
+ 	}
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_ex_start_trace_method
+  *
+  * PARAMETERS:  method_node         - Node of the method
+  *              obj_desc            - The method object
+  *              walk_state          - current state, NULL if not yet executing
+  *                                    a method.
+  *
+  * RETURN:      None
+  *
+  * DESCRIPTION: Start control method execution trace
+  *
+  ******************************************************************************/
+ 
+ void
+ acpi_ex_start_trace_method(struct acpi_namespace_node *method_node,
+ 			   union acpi_operand_object *obj_desc,
+ 			   struct acpi_walk_state *walk_state)
+ {
+ 	acpi_status status;
+ 	char *pathname = NULL;
+ 	u8 enabled = FALSE;
+ 
+ 	ACPI_FUNCTION_NAME(ex_start_trace_method);
+ 
+ 	if (method_node) {
+ 		pathname = acpi_ns_get_normalized_pathname(method_node, TRUE);
+ 	}
+ 
+ 	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+ 	if (ACPI_FAILURE(status)) {
+ 		goto exit;
+ 	}
+ 
+ 	enabled = acpi_ex_interpreter_trace_enabled(pathname);
+ 	if (enabled && !acpi_gbl_trace_method_object) {
+ 		acpi_gbl_trace_method_object = obj_desc;
+ 		acpi_gbl_original_dbg_level = acpi_dbg_level;
+ 		acpi_gbl_original_dbg_layer = acpi_dbg_layer;
+ 		acpi_dbg_level = ACPI_TRACE_LEVEL_ALL;
+ 		acpi_dbg_layer = ACPI_TRACE_LAYER_ALL;
+ 
+ 		if (acpi_gbl_trace_dbg_level) {
+ 			acpi_dbg_level = acpi_gbl_trace_dbg_level;
+ 		}
+ 		if (acpi_gbl_trace_dbg_layer) {
+ 			acpi_dbg_layer = acpi_gbl_trace_dbg_layer;
+ 		}
+ 	}
+ 
+ 	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+ 
+ exit:
+ 	if (enabled) {
+ 		ACPI_TRACE_POINT(ACPI_TRACE_AML_METHOD, TRUE,
+ 				 obj_desc ? obj_desc->method.aml_start : NULL,
+ 				 pathname);
+ 	}
+ 	if (pathname) {
+ 		ACPI_FREE(pathname);
+ 	}
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_ex_stop_trace_method
+  *
+  * PARAMETERS:  method_node         - Node of the method
+  *              obj_desc            - The method object
+  *              walk_state          - current state, NULL if not yet executing
+  *                                    a method.
+  *
+  * RETURN:      None
+  *
+  * DESCRIPTION: Stop control method execution trace
+  *
+  ******************************************************************************/
+ 
+ void
+ acpi_ex_stop_trace_method(struct acpi_namespace_node *method_node,
+ 			  union acpi_operand_object *obj_desc,
+ 			  struct acpi_walk_state *walk_state)
+ {
+ 	acpi_status status;
+ 	char *pathname = NULL;
+ 	u8 enabled;
+ 
+ 	ACPI_FUNCTION_NAME(ex_stop_trace_method);
+ 
+ 	if (method_node) {
+ 		pathname = acpi_ns_get_normalized_pathname(method_node, TRUE);
+ 	}
+ 
+ 	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+ 	if (ACPI_FAILURE(status)) {
+ 		goto exit_path;
+ 	}
+ 
+ 	enabled = acpi_ex_interpreter_trace_enabled(NULL);
+ 
+ 	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+ 
+ 	if (enabled) {
+ 		ACPI_TRACE_POINT(ACPI_TRACE_AML_METHOD, FALSE,
+ 				 obj_desc ? obj_desc->method.aml_start : NULL,
+ 				 pathname);
+ 	}
+ 
+ 	status = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);
+ 	if (ACPI_FAILURE(status)) {
+ 		goto exit_path;
+ 	}
+ 
+ 	/* Check whether the tracer should be stopped */
+ 
+ 	if (acpi_gbl_trace_method_object == obj_desc) {
+ 
+ 		/* Disable further tracing if type is one-shot */
+ 
+ 		if (acpi_gbl_trace_flags & ACPI_TRACE_ONESHOT) {
+ 			acpi_gbl_trace_method_name = NULL;
+ 		}
+ 
+ 		acpi_dbg_level = acpi_gbl_original_dbg_level;
+ 		acpi_dbg_layer = acpi_gbl_original_dbg_layer;
+ 		acpi_gbl_trace_method_object = NULL;
+ 	}
+ 
+ 	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
+ 
+ exit_path:
+ 	if (pathname) {
+ 		ACPI_FREE(pathname);
+ 	}
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_ex_start_trace_opcode
+  *
+  * PARAMETERS:  op                  - The parser opcode object
+  *              walk_state          - current state, NULL if not yet executing
+  *                                    a method.
+  *
+  * RETURN:      None
+  *
+  * DESCRIPTION: Start opcode execution trace
+  *
+  ******************************************************************************/
+ 
+ void
+ acpi_ex_start_trace_opcode(union acpi_parse_object *op,
+ 			   struct acpi_walk_state *walk_state)
+ {
+ 
+ 	ACPI_FUNCTION_NAME(ex_start_trace_opcode);
+ 
+ 	if (acpi_ex_interpreter_trace_enabled(NULL) &&
+ 	    (acpi_gbl_trace_flags & ACPI_TRACE_OPCODE)) {
+ 		ACPI_TRACE_POINT(ACPI_TRACE_AML_OPCODE, TRUE,
+ 				 op->common.aml, op->common.aml_op_name);
+ 	}
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_ex_stop_trace_opcode
+  *
+  * PARAMETERS:  op                  - The parser opcode object
+  *              walk_state          - current state, NULL if not yet executing
+  *                                    a method.
+  *
+  * RETURN:      None
+  *
+  * DESCRIPTION: Stop opcode execution trace
+  *
+  ******************************************************************************/
+ 
+ void
+ acpi_ex_stop_trace_opcode(union acpi_parse_object *op,
+ 			  struct acpi_walk_state *walk_state)
+ {
+ 
+ 	ACPI_FUNCTION_NAME(ex_stop_trace_opcode);
+ 
+ 	if (acpi_ex_interpreter_trace_enabled(NULL) &&
+ 	    (acpi_gbl_trace_flags & ACPI_TRACE_OPCODE)) {
+ 		ACPI_TRACE_POINT(ACPI_TRACE_AML_OPCODE, FALSE,
+ 				 op->common.aml, op->common.aml_op_name);
+ 	}
+ }
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
diff --cc drivers/acpi/acpica/exfield.c
index c251b0cce123,ad7080ba65e2..000000000000
--- a/drivers/acpi/acpica/exfield.c
+++ b/drivers/acpi/acpica/exfield.c
@@@ -180,18 -181,17 +181,26 @@@ acpi_ex_read_data_from_field(struct acp
  		} else if (obj_desc->field.region_obj->region.space_id ==
  			   ACPI_ADR_SPACE_GSBUS) {
  			accessor_type = obj_desc->field.attribute;
- 			length = acpi_ex_get_serial_access_length(accessor_type,
- 								  obj_desc->
- 								  field.
- 								  access_length);
+ 			length =
+ 			    acpi_ex_get_serial_access_length(accessor_type,
+ 							     obj_desc->field.
+ 							     access_length);
  
  			/*
++<<<<<<< HEAD
 +			 * Add additional 2 bytes for modeled generic_serial_bus data buffer:
 +			 * typedef struct {
 +			 *     BYTEStatus; // Byte 0 of the data buffer
 +			 *     BYTELength; // Byte 1 of the data buffer
 +			 *     BYTE[x-1]Data; // Bytes 2-x of the arbitrary length data buffer,
 +			 * }
++=======
+ 			 * Add additional 2 bytes for the generic_serial_bus data buffer:
+ 			 *
+ 			 *     Status;    (Byte 0 of the data buffer)
+ 			 *     Length;    (Byte 1 of the data buffer)
+ 			 *     Data[x-1]: (Bytes 2-x of the arbitrary length data buffer)
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  			 */
  			length += 2;
  			function = ACPI_READ | (accessor_type << 16);
@@@ -254,6 -256,39 +265,42 @@@
  		buffer = &buffer_desc->integer.value;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if ((obj_desc->common.type == ACPI_TYPE_LOCAL_REGION_FIELD) &&
+ 	    (obj_desc->field.region_obj->region.space_id ==
+ 	     ACPI_ADR_SPACE_GPIO)) {
+ 		/*
+ 		 * For GPIO (general_purpose_io), the Address will be the bit offset
+ 		 * from the previous Connection() operator, making it effectively a
+ 		 * pin number index. The bit_length is the length of the field, which
+ 		 * is thus the number of pins.
+ 		 */
+ 		ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+ 				  "GPIO FieldRead [FROM]:  Pin %u Bits %u\n",
+ 				  obj_desc->field.pin_number_index,
+ 				  obj_desc->field.bit_length));
+ 
+ 		/* Lock entire transaction if requested */
+ 
+ 		acpi_ex_acquire_global_lock(obj_desc->common_field.field_flags);
+ 
+ 		/* Perform the write */
+ 
+ 		status =
+ 		    acpi_ex_access_region(obj_desc, 0, (u64 *)buffer,
+ 					  ACPI_READ);
+ 
+ 		acpi_ex_release_global_lock(obj_desc->common_field.field_flags);
+ 		if (ACPI_FAILURE(status)) {
+ 			acpi_ut_remove_reference(buffer_desc);
+ 		} else {
+ 			*ret_buffer_desc = buffer_desc;
+ 		}
+ 		return_ACPI_STATUS(status);
+ 	}
+ 
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
  			  "FieldRead [TO]:   Obj %p, Type %X, Buf %p, ByteLen %X\n",
  			  obj_desc, obj_desc->common.type, buffer,
@@@ -362,18 -400,17 +412,26 @@@ acpi_ex_write_data_to_field(union acpi_
  		} else if (obj_desc->field.region_obj->region.space_id ==
  			   ACPI_ADR_SPACE_GSBUS) {
  			accessor_type = obj_desc->field.attribute;
- 			length = acpi_ex_get_serial_access_length(accessor_type,
- 								  obj_desc->
- 								  field.
- 								  access_length);
+ 			length =
+ 			    acpi_ex_get_serial_access_length(accessor_type,
+ 							     obj_desc->field.
+ 							     access_length);
  
  			/*
++<<<<<<< HEAD
 +			 * Add additional 2 bytes for modeled generic_serial_bus data buffer:
 +			 * typedef struct {
 +			 *     BYTEStatus; // Byte 0 of the data buffer
 +			 *     BYTELength; // Byte 1 of the data buffer
 +			 *     BYTE[x-1]Data; // Bytes 2-x of the arbitrary length data buffer,
 +			 * }
++=======
+ 			 * Add additional 2 bytes for the generic_serial_bus data buffer:
+ 			 *
+ 			 *     Status;    (Byte 0 of the data buffer)
+ 			 *     Length;    (Byte 1 of the data buffer)
+ 			 *     Data[x-1]: (Bytes 2-x of the arbitrary length data buffer)
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  			 */
  			length += 2;
  			function = ACPI_WRITE | (accessor_type << 16);
@@@ -409,12 -447,49 +468,57 @@@
  		 * Perform the write (returns status and perhaps data in the
  		 * same buffer)
  		 */
++<<<<<<< HEAD
 +		status = acpi_ex_access_region(obj_desc, 0,
 +					       (u64 *) buffer, function);
++=======
+ 		status =
+ 		    acpi_ex_access_region(obj_desc, 0, (u64 *)buffer, function);
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  		acpi_ex_release_global_lock(obj_desc->common_field.field_flags);
  
  		*result_desc = buffer_desc;
  		return_ACPI_STATUS(status);
++<<<<<<< HEAD
++=======
+ 	} else if ((obj_desc->common.type == ACPI_TYPE_LOCAL_REGION_FIELD) &&
+ 		   (obj_desc->field.region_obj->region.space_id ==
+ 		    ACPI_ADR_SPACE_GPIO)) {
+ 		/*
+ 		 * For GPIO (general_purpose_io), we will bypass the entire field
+ 		 * mechanism and handoff the bit address and bit width directly to
+ 		 * the handler. The Address will be the bit offset
+ 		 * from the previous Connection() operator, making it effectively a
+ 		 * pin number index. The bit_length is the length of the field, which
+ 		 * is thus the number of pins.
+ 		 */
+ 		if (source_desc->common.type != ACPI_TYPE_INTEGER) {
+ 			return_ACPI_STATUS(AE_AML_OPERAND_TYPE);
+ 		}
+ 
+ 		ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
+ 				  "GPIO FieldWrite [FROM]: (%s:%X), Val %.8X  [TO]: Pin %u Bits %u\n",
+ 				  acpi_ut_get_type_name(source_desc->common.
+ 							type),
+ 				  source_desc->common.type,
+ 				  (u32)source_desc->integer.value,
+ 				  obj_desc->field.pin_number_index,
+ 				  obj_desc->field.bit_length));
+ 
+ 		buffer = &source_desc->integer.value;
+ 
+ 		/* Lock entire transaction if requested */
+ 
+ 		acpi_ex_acquire_global_lock(obj_desc->common_field.field_flags);
+ 
+ 		/* Perform the write */
+ 
+ 		status =
+ 		    acpi_ex_access_region(obj_desc, 0, (u64 *)buffer,
+ 					  ACPI_WRITE);
+ 		acpi_ex_release_global_lock(obj_desc->common_field.field_flags);
+ 		return_ACPI_STATUS(status);
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  	}
  
  	/* Get a pointer to the data to be written */
diff --cc drivers/acpi/acpica/exoparg3.c
index 37656f12f204,27fb0172fca2..000000000000
--- a/drivers/acpi/acpica/exoparg3.c
+++ b/drivers/acpi/acpica/exoparg3.c
@@@ -95,10 -95,11 +95,18 @@@ acpi_status acpi_ex_opcode_3A_0T_0R(str
  	case AML_FATAL_OP:	/* Fatal (fatal_type fatal_code fatal_arg) */
  
  		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
++<<<<<<< HEAD
 +				  "FatalOp: Type %X Code %X Arg %X <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n",
 +				  (u32) operand[0]->integer.value,
 +				  (u32) operand[1]->integer.value,
 +				  (u32) operand[2]->integer.value));
++=======
+ 				  "FatalOp: Type %X Code %X Arg %X "
+ 				  "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n",
+ 				  (u32)operand[0]->integer.value,
+ 				  (u32)operand[1]->integer.value,
+ 				  (u32)operand[2]->integer.value));
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  
  		fatal = ACPI_ALLOCATE(sizeof(struct acpi_signal_fatal_info));
  		if (fatal) {
@@@ -226,8 -240,8 +236,13 @@@ acpi_status acpi_ex_opcode_3A_1T_1R(str
  
  			/* We have a buffer, copy the portion requested */
  
++<<<<<<< HEAD
 +			ACPI_MEMCPY(buffer, operand[0]->string.pointer + index,
 +				    length);
++=======
+ 			memcpy(buffer,
+ 			       operand[0]->string.pointer + index, length);
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  		}
  
  		/* Set the length of the new String/Buffer */
diff --cc drivers/acpi/acpica/exregion.c
index 303429bb4d5d,1851a307544a..000000000000
--- a/drivers/acpi/acpica/exregion.c
+++ b/drivers/acpi/acpica/exregion.c
@@@ -400,8 -400,10 +401,15 @@@ acpi_ex_pci_config_space_handler(u32 fu
  	switch (function) {
  	case ACPI_READ:
  
++<<<<<<< HEAD
 +		status = acpi_os_read_pci_configuration(pci_id, pci_register,
 +							value, bit_width);
++=======
+ 		*value = 0;
+ 		status =
+ 		    acpi_os_read_pci_configuration(pci_id, pci_register, value,
+ 						   bit_width);
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  		break;
  
  	case ACPI_WRITE:
diff --cc drivers/acpi/acpica/exstore.c
index f0b09bf9887d,d3afbcbe7886..000000000000
--- a/drivers/acpi/acpica/exstore.c
+++ b/drivers/acpi/acpica/exstore.c
@@@ -413,6 -414,71 +413,74 @@@ acpi_ex_store_object_to_node(union acpi
  			  acpi_ut_get_object_type_name(source_desc), node,
  			  acpi_ut_get_type_name(target_type)));
  
++<<<<<<< HEAD
++=======
+ 	/* Only limited target types possible for everything except copy_object */
+ 
+ 	if (walk_state->opcode != AML_COPY_OP) {
+ 		/*
+ 		 * Only copy_object allows all object types to be overwritten. For
+ 		 * target_ref(s), there are restrictions on the object types that
+ 		 * are allowed.
+ 		 *
+ 		 * Allowable operations/typing for Store:
+ 		 *
+ 		 * 1) Simple Store
+ 		 *      Integer     --> Integer (Named/Local/Arg)
+ 		 *      String      --> String  (Named/Local/Arg)
+ 		 *      Buffer      --> Buffer  (Named/Local/Arg)
+ 		 *      Package     --> Package (Named/Local/Arg)
+ 		 *
+ 		 * 2) Store with implicit conversion
+ 		 *      Integer     --> String or Buffer  (Named)
+ 		 *      String      --> Integer or Buffer (Named)
+ 		 *      Buffer      --> Integer or String (Named)
+ 		 */
+ 		switch (target_type) {
+ 		case ACPI_TYPE_PACKAGE:
+ 			/*
+ 			 * Here, can only store a package to an existing package.
+ 			 * Storing a package to a Local/Arg is OK, and handled
+ 			 * elsewhere.
+ 			 */
+ 			if (walk_state->opcode == AML_STORE_OP) {
+ 				if (source_desc->common.type !=
+ 				    ACPI_TYPE_PACKAGE) {
+ 					ACPI_ERROR((AE_INFO,
+ 						    "Cannot assign type [%s] to [Package] "
+ 						    "(source must be type Pkg)",
+ 						    acpi_ut_get_object_type_name
+ 						    (source_desc)));
+ 
+ 					return_ACPI_STATUS(AE_AML_TARGET_TYPE);
+ 				}
+ 				break;
+ 			}
+ 
+ 			/* Fallthrough */
+ 
+ 		case ACPI_TYPE_DEVICE:
+ 		case ACPI_TYPE_EVENT:
+ 		case ACPI_TYPE_MUTEX:
+ 		case ACPI_TYPE_REGION:
+ 		case ACPI_TYPE_POWER:
+ 		case ACPI_TYPE_PROCESSOR:
+ 		case ACPI_TYPE_THERMAL:
+ 
+ 			ACPI_ERROR((AE_INFO,
+ 				    "Target must be [Buffer/Integer/String/Reference]"
+ 				    ", found [%s] (%4.4s)",
+ 				    acpi_ut_get_type_name(node->type),
+ 				    node->name.ascii));
+ 
+ 			return_ACPI_STATUS(AE_AML_TARGET_TYPE);
+ 
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  	/*
  	 * Resolve the source object to an actual value
  	 * (If it is a reference object)
@@@ -463,11 -530,12 +532,12 @@@
  			 * store has been performed such that the node/object type
  			 * has been changed.
  			 */
- 			status = acpi_ns_attach_object(node, new_desc,
- 						       new_desc->common.type);
+ 			status =
+ 			    acpi_ns_attach_object(node, new_desc,
+ 						  new_desc->common.type);
  
  			ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
 -					  "Store type [%s] into [%s] via Convert/Attach\n",
 +					  "Store %s into %s via Convert/Attach\n",
  					  acpi_ut_get_object_type_name
  					  (source_desc),
  					  acpi_ut_get_object_type_name
@@@ -491,18 -559,15 +561,18 @@@
  
  	default:
  		/*
 -		 * copy_object operator: No conversions for all other types.
 -		 * Instead, directly store a copy of the source object.
 +		 * No conversions for all other types. Directly store a copy of
 +		 * the source object. This is the ACPI spec-defined behavior for
 +		 * the copy_object operator.
  		 *
 -		 * This is the ACPI spec-defined behavior for the copy_object
 -		 * operator. (Note, for this default case, all normal
 -		 * Store/Target operations exited above with an error).
 +		 * NOTE: For the Store operator, this is a departure from the
 +		 * ACPI spec, which states "If conversion is impossible, abort
 +		 * the running control method". Instead, this code implements
 +		 * "If conversion is impossible, treat the Store operation as
 +		 * a CopyObject".
  		 */
- 		status = acpi_ex_store_direct_to_node(source_desc, node,
- 						      walk_state);
+ 		status =
+ 		    acpi_ex_store_direct_to_node(source_desc, node, walk_state);
  		break;
  	}
  
diff --cc drivers/acpi/acpica/exsystem.c
index 6578dee2e51b,7c91c1f799a5..000000000000
--- a/drivers/acpi/acpica/exsystem.c
+++ b/drivers/acpi/acpica/exsystem.c
@@@ -77,8 -77,7 +77,12 @@@ acpi_status acpi_ex_system_wait_semapho
  
  		/* We must wait, so unlock the interpreter */
  
++<<<<<<< HEAD
 +		acpi_ex_relinquish_interpreter();
 +
++=======
+ 		acpi_ex_exit_interpreter();
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  		status = acpi_os_wait_semaphore(semaphore, 1, timeout);
  
  		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
@@@ -123,8 -122,7 +127,12 @@@ acpi_status acpi_ex_system_wait_mutex(a
  
  		/* We must wait, so unlock the interpreter */
  
++<<<<<<< HEAD
 +		acpi_ex_relinquish_interpreter();
 +
++=======
+ 		acpi_ex_exit_interpreter();
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  		status = acpi_os_acquire_mutex(mutex, timeout);
  
  		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
diff --cc drivers/acpi/acpica/hwgpe.c
index 96540506058f,8272f966382a..000000000000
--- a/drivers/acpi/acpica/hwgpe.c
+++ b/drivers/acpi/acpica/hwgpe.c
@@@ -255,6 -278,31 +254,34 @@@ acpi_hw_get_gpe_status(struct acpi_gpe_
  
  /******************************************************************************
   *
++<<<<<<< HEAD
++=======
+  * FUNCTION:    acpi_hw_gpe_enable_write
+  *
+  * PARAMETERS:  enable_mask         - Bit mask to write to the GPE register
+  *              gpe_register_info   - Gpe Register info
+  *
+  * RETURN:      Status
+  *
+  * DESCRIPTION: Write the enable mask byte to the given GPE register.
+  *
+  ******************************************************************************/
+ 
+ static acpi_status
+ acpi_hw_gpe_enable_write(u8 enable_mask,
+ 			 struct acpi_gpe_register_info *gpe_register_info)
+ {
+ 	acpi_status status;
+ 
+ 	gpe_register_info->enable_mask = enable_mask;
+ 
+ 	status = acpi_hw_write(enable_mask, &gpe_register_info->enable_address);
+ 	return (status);
+ }
+ 
+ /******************************************************************************
+  *
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
   * FUNCTION:    acpi_hw_disable_gpe_block
   *
   * PARAMETERS:  gpe_xrupt_info      - GPE Interrupt info
diff --cc drivers/acpi/acpica/nsnames.c
index 90a0380fb8a0,521031f9b6c6..000000000000
--- a/drivers/acpi/acpica/nsnames.c
+++ b/drivers/acpi/acpica/nsnames.c
@@@ -139,29 -69,7 +139,33 @@@ char *acpi_ns_get_external_pathname(str
  
  	ACPI_FUNCTION_TRACE_PTR(ns_get_external_pathname, node);
  
++<<<<<<< HEAD
 +	/* Calculate required buffer size based on depth below root */
 +
 +	size = acpi_ns_get_pathname_length(node);
 +	if (!size) {
 +		return_PTR(NULL);
 +	}
 +
 +	/* Allocate a buffer to be returned to caller */
 +
 +	name_buffer = ACPI_ALLOCATE_ZEROED(size);
 +	if (!name_buffer) {
 +		ACPI_ERROR((AE_INFO, "Could not allocate %u bytes", (u32)size));
 +		return_PTR(NULL);
 +	}
 +
 +	/* Build the path in the allocated buffer */
 +
 +	status = acpi_ns_build_external_path(node, size, name_buffer);
 +	if (ACPI_FAILURE(status)) {
 +		ACPI_FREE(name_buffer);
 +		return_PTR(NULL);
 +	}
 +
++=======
+ 	name_buffer = acpi_ns_get_normalized_pathname(node, FALSE);
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  	return_PTR(name_buffer);
  }
  
@@@ -184,29 -91,8 +188,34 @@@ acpi_size acpi_ns_get_pathname_length(s
  
  	ACPI_FUNCTION_ENTRY();
  
++<<<<<<< HEAD
 +	/*
 +	 * Compute length of pathname as 5 * number of name segments.
 +	 * Go back up the parent tree to the root
 +	 */
 +	size = 0;
 +	next_node = node;
 +
 +	while (next_node && (next_node != acpi_gbl_root_node)) {
 +		if (ACPI_GET_DESCRIPTOR_TYPE(next_node) != ACPI_DESC_TYPE_NAMED) {
 +			ACPI_ERROR((AE_INFO,
 +				    "Invalid Namespace Node (%p) while traversing namespace",
 +				    next_node));
 +			return (0);
 +		}
 +		size += ACPI_PATH_SEGMENT_LENGTH;
 +		next_node = next_node->parent;
 +	}
 +
 +	if (!size) {
 +		size = 1;	/* Root node case */
 +	}
 +
 +	return (size + 1);	/* +1 for null string terminator */
++=======
+ 	size = acpi_ns_build_normalized_path(node, NULL, 0, FALSE);
+ 	return (size);
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  }
  
  /*******************************************************************************
@@@ -264,3 -153,153 +273,156 @@@ acpi_ns_handle_to_pathname(acpi_handle 
  			  (char *)buffer->pointer, (u32) required_size));
  	return_ACPI_STATUS(AE_OK);
  }
++<<<<<<< HEAD
++=======
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_ns_build_normalized_path
+  *
+  * PARAMETERS:  node        - Namespace node
+  *              full_path   - Where the path name is returned
+  *              path_size   - Size of returned path name buffer
+  *              no_trailing - Remove trailing '_' from each name segment
+  *
+  * RETURN:      Return 1 if the AML path is empty, otherwise returning (length
+  *              of pathname + 1) which means the 'FullPath' contains a trailing
+  *              null.
+  *
+  * DESCRIPTION: Build and return a full namespace pathname.
+  *              Note that if the size of 'FullPath' isn't large enough to
+  *              contain the namespace node's path name, the actual required
+  *              buffer length is returned, and it should be greater than
+  *              'PathSize'. So callers are able to check the returning value
+  *              to determine the buffer size of 'FullPath'.
+  *
+  ******************************************************************************/
+ 
+ u32
+ acpi_ns_build_normalized_path(struct acpi_namespace_node *node,
+ 			      char *full_path, u32 path_size, u8 no_trailing)
+ {
+ 	u32 length = 0, i;
+ 	char name[ACPI_NAME_SIZE];
+ 	u8 do_no_trailing;
+ 	char c, *left, *right;
+ 	struct acpi_namespace_node *next_node;
+ 
+ 	ACPI_FUNCTION_TRACE_PTR(ns_build_normalized_path, node);
+ 
+ #define ACPI_PATH_PUT8(path, size, byte, length)    \
+ 	do {                                            \
+ 		if ((length) < (size))                      \
+ 		{                                           \
+ 			(path)[(length)] = (byte);              \
+ 		}                                           \
+ 		(length)++;                                 \
+ 	} while (0)
+ 
+ 	/*
+ 	 * Make sure the path_size is correct, so that we don't need to
+ 	 * validate both full_path and path_size.
+ 	 */
+ 	if (!full_path) {
+ 		path_size = 0;
+ 	}
+ 
+ 	if (!node) {
+ 		goto build_trailing_null;
+ 	}
+ 
+ 	next_node = node;
+ 	while (next_node && next_node != acpi_gbl_root_node) {
+ 		if (next_node != node) {
+ 			ACPI_PATH_PUT8(full_path, path_size,
+ 				       AML_DUAL_NAME_PREFIX, length);
+ 		}
+ 
+ 		ACPI_MOVE_32_TO_32(name, &next_node->name);
+ 		do_no_trailing = no_trailing;
+ 		for (i = 0; i < 4; i++) {
+ 			c = name[4 - i - 1];
+ 			if (do_no_trailing && c != '_') {
+ 				do_no_trailing = FALSE;
+ 			}
+ 			if (!do_no_trailing) {
+ 				ACPI_PATH_PUT8(full_path, path_size, c, length);
+ 			}
+ 		}
+ 
+ 		next_node = next_node->parent;
+ 	}
+ 
+ 	ACPI_PATH_PUT8(full_path, path_size, AML_ROOT_PREFIX, length);
+ 
+ 	/* Reverse the path string */
+ 
+ 	if (length <= path_size) {
+ 		left = full_path;
+ 		right = full_path + length - 1;
+ 
+ 		while (left < right) {
+ 			c = *left;
+ 			*left++ = *right;
+ 			*right-- = c;
+ 		}
+ 	}
+ 
+ 	/* Append the trailing null */
+ 
+ build_trailing_null:
+ 	ACPI_PATH_PUT8(full_path, path_size, '\0', length);
+ 
+ #undef ACPI_PATH_PUT8
+ 
+ 	return_UINT32(length);
+ }
+ 
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_ns_get_normalized_pathname
+  *
+  * PARAMETERS:  node            - Namespace node whose pathname is needed
+  *              no_trailing     - Remove trailing '_' from each name segment
+  *
+  * RETURN:      Pointer to storage containing the fully qualified name of
+  *              the node, In external format (name segments separated by path
+  *              separators.)
+  *
+  * DESCRIPTION: Used to obtain the full pathname to a namespace node, usually
+  *              for error and debug statements. All trailing '_' will be
+  *              removed from the full pathname if 'NoTrailing' is specified..
+  *
+  ******************************************************************************/
+ 
+ char *acpi_ns_get_normalized_pathname(struct acpi_namespace_node *node,
+ 				      u8 no_trailing)
+ {
+ 	char *name_buffer;
+ 	acpi_size size;
+ 
+ 	ACPI_FUNCTION_TRACE_PTR(ns_get_normalized_pathname, node);
+ 
+ 	/* Calculate required buffer size based on depth below root */
+ 
+ 	size = acpi_ns_build_normalized_path(node, NULL, 0, no_trailing);
+ 	if (!size) {
+ 		return_PTR(NULL);
+ 	}
+ 
+ 	/* Allocate a buffer to be returned to caller */
+ 
+ 	name_buffer = ACPI_ALLOCATE_ZEROED(size);
+ 	if (!name_buffer) {
+ 		ACPI_ERROR((AE_INFO, "Could not allocate %u bytes", (u32)size));
+ 		return_PTR(NULL);
+ 	}
+ 
+ 	/* Build the path in the allocated buffer */
+ 
+ 	(void)acpi_ns_build_normalized_path(node, name_buffer, size,
+ 					    no_trailing);
+ 
+ 	return_PTR(name_buffer);
+ }
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
diff --cc drivers/acpi/acpica/nsrepair2.c
index c84603ee83ae,f6dd2a83ea63..000000000000
--- a/drivers/acpi/acpica/nsrepair2.c
+++ b/drivers/acpi/acpica/nsrepair2.c
@@@ -703,8 -714,9 +707,14 @@@ acpi_ns_repair_PSS(struct acpi_evaluate
  		elements = (*outer_elements)->package.elements;
  		obj_desc = elements[1];	/* Index1 = power_dissipation */
  
++<<<<<<< HEAD
 +		if ((u32) obj_desc->integer.value > previous_value) {
 +			ACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname,
++=======
+ 		if ((u32)obj_desc->integer.value > previous_value) {
+ 			ACPI_WARN_PREDEFINED((AE_INFO,
+ 					      info->full_pathname,
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  					      info->node_flags,
  					      "SubPackage[%u,%u] - suspicious power dissipation values",
  					      i - 1, i));
diff --cc drivers/acpi/acpica/psloop.c
index 065b44ae538f,c660006f13ee..000000000000
--- a/drivers/acpi/acpica/psloop.c
+++ b/drivers/acpi/acpica/psloop.c
@@@ -123,12 -124,9 +123,18 @@@ acpi_ps_get_arguments(struct acpi_walk_
  		/*
  		 * Op is not a constant or string, append each argument to the Op
  		 */
++<<<<<<< HEAD
 +		while (GET_CURRENT_ARG_TYPE(walk_state->arg_types)
 +		       && !walk_state->arg_count) {
 +			walk_state->aml_offset =
 +			    (u32) ACPI_PTR_DIFF(walk_state->parser_state.aml,
 +						walk_state->parser_state.
 +						aml_start);
++=======
+ 		while (GET_CURRENT_ARG_TYPE(walk_state->arg_types) &&
+ 		       !walk_state->arg_count) {
+ 			walk_state->aml = walk_state->parser_state.aml;
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  
  			status =
  			    acpi_ps_get_next_arg(walk_state,
diff --cc drivers/acpi/acpica/rscreate.c
index 65f3e1c5b598,603e544e3f64..000000000000
--- a/drivers/acpi/acpica/rscreate.c
+++ b/drivers/acpi/acpica/rscreate.c
@@@ -342,10 -347,7 +344,14 @@@ acpi_rs_create_pci_routing_table(union 
  					   (u8 *) output_buffer->pointer);
  				path_buffer.pointer = user_prt->source;
  
++<<<<<<< HEAD
 +				status =
 +				    acpi_ns_handle_to_pathname((acpi_handle)
 +							       node,
 +							       &path_buffer);
++=======
+ 				status = acpi_ns_handle_to_pathname((acpi_handle) node, &path_buffer, FALSE);
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  
  				/* +1 to include null terminator */
  
@@@ -441,16 -442,16 +447,27 @@@ acpi_rs_create_aml_resources(struct acp
  
  	ACPI_FUNCTION_TRACE(rs_create_aml_resources);
  
 -	/* Params already validated, no need to re-validate here */
 +	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "LinkedListBuffer = %p\n",
 +			  linked_list_buffer));
  
++<<<<<<< HEAD
 +	/*
 +	 * Params already validated, so we don't re-validate here
 +	 *
 +	 * Pass the linked_list_buffer into a module that calculates
 +	 * the buffer size needed for the byte stream.
 +	 */
 +	status = acpi_rs_get_aml_length(linked_list_buffer, &aml_size_needed);
++=======
+ 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "ResourceList Buffer = %p\n",
+ 			  resource_list->pointer));
+ 
+ 	/* Get the buffer size needed for the AML byte stream */
+ 
+ 	status =
+ 	    acpi_rs_get_aml_length(resource_list->pointer,
+ 				   resource_list->length, &aml_size_needed);
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  
  	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "AmlSizeNeeded=%X, %s\n",
  			  (u32)aml_size_needed, acpi_format_exception(status)));
diff --cc drivers/acpi/acpica/rsmisc.c
index 80d12994e0d0,b112c7b1abbf..000000000000
--- a/drivers/acpi/acpica/rsmisc.c
+++ b/drivers/acpi/acpica/rsmisc.c
@@@ -445,8 -445,8 +445,13 @@@ acpi_rs_convert_aml_to_resource(struct 
  
  		/* Round the resource struct length up to the next boundary (32 or 64) */
  
++<<<<<<< HEAD
 +		resource->length =
 +		    (u32) ACPI_ROUND_UP_TO_NATIVE_WORD(resource->length);
++=======
+ 		resource->length = (u32)
+ 		    ACPI_ROUND_UP_TO_NATIVE_WORD(resource->length);
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  	}
  	return_ACPI_STATUS(AE_OK);
  }
@@@ -550,9 -550,8 +555,14 @@@ acpi_rs_convert_resource_to_aml(struct 
  			item_count = ACPI_GET8(source);
  			ACPI_SET8(destination, item_count);
  
++<<<<<<< HEAD
 +			aml_length =
 +			    (u16) (aml_length +
 +				   (info->value * (item_count - 1)));
++=======
+ 			aml_length = (u16)
+ 			    (aml_length + (info->value * (item_count - 1)));
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  			break;
  
  		case ACPI_RSC_COUNT16:
diff --cc drivers/acpi/acpica/rsutils.c
index 480b6b40c5ea,33e558c9434f..000000000000
--- a/drivers/acpi/acpica/rsutils.c
+++ b/drivers/acpi/acpica/rsutils.c
@@@ -364,12 -363,12 +363,17 @@@ acpi_rs_get_resource_source(acpi_rs_len
  		 * Zero the entire area of the buffer.
  		 */
  		total_length =
 -		    (u32)strlen(ACPI_CAST_PTR(char, &aml_resource_source[1])) +
 +		    (u32)
 +		    ACPI_STRLEN(ACPI_CAST_PTR(char, &aml_resource_source[1])) +
  		    1;
++<<<<<<< HEAD
 +		total_length = (u32) ACPI_ROUND_UP_TO_NATIVE_WORD(total_length);
++=======
+ 
+ 		total_length = (u32)ACPI_ROUND_UP_TO_NATIVE_WORD(total_length);
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  
 -		memset(resource_source->string_ptr, 0, total_length);
 +		ACPI_MEMSET(resource_source->string_ptr, 0, total_length);
  
  		/* Copy the resource_source string to the destination */
  
diff --cc drivers/acpi/acpica/tbinstal.c
index 4024bfc5fa21,bd87801acedf..000000000000
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@@ -142,119 -126,33 +142,138 @@@ acpi_tb_add_table(struct acpi_table_des
  	}
  
  	/*
 -	 * ACPI Table Override:
 +	 * Validate the incoming table signature.
  	 *
 -	 * Before we install the table, let the host OS override it with a new
 -	 * one if desired. Any table within the RSDT/XSDT can be replaced,
 -	 * including the DSDT which is pointed to by the FADT.
 +	 * 1) Originally, we checked the table signature for "SSDT" or "PSDT".
 +	 * 2) We added support for OEMx tables, signature "OEM".
 +	 * 3) Valid tables were encountered with a null signature, so we just
 +	 *    gave up on validating the signature, (05/2008).
 +	 * 4) We encountered non-AML tables such as the MADT, which caused
 +	 *    interpreter errors and kernel faults. So now, we once again allow
 +	 *    only "SSDT", "OEMx", and now, also a null signature. (05/2011).
  	 */
 -	if (override) {
 -		acpi_tb_override_table(new_table_desc);
 +	if ((table_desc->pointer->signature[0] != 0x00) &&
 +	    (!ACPI_COMPARE_NAME(table_desc->pointer->signature, ACPI_SIG_SSDT))
 +	    && (ACPI_STRNCMP(table_desc->pointer->signature, "OEM", 3))) {
 +		ACPI_BIOS_ERROR((AE_INFO,
 +				 "Table has invalid signature [%4.4s] (0x%8.8X), "
 +				 "must be SSDT or OEMx",
 +				 acpi_ut_valid_acpi_name(table_desc->pointer->
 +							 signature) ?
 +				 table_desc->pointer->signature : "????",
 +				 *(u32 *)table_desc->pointer->signature));
 +
 +		return_ACPI_STATUS(AE_BAD_SIGNATURE);
  	}
  
 -	acpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.tables[i],
 -				      new_table_desc->address,
 -				      new_table_desc->flags,
 -				      new_table_desc->pointer);
 +	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
 +
 +	/* Check if table is already registered */
 +
 +	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {
 +		if (!acpi_gbl_root_table_list.tables[i].pointer) {
 +			status =
 +			    acpi_tb_verify_table(&acpi_gbl_root_table_list.
 +						 tables[i]);
 +			if (ACPI_FAILURE(status)
 +			    || !acpi_gbl_root_table_list.tables[i].pointer) {
 +				continue;
 +			}
 +		}
 +
++<<<<<<< HEAD
 +		/*
 +		 * Check for a table match on the entire table length,
 +		 * not just the header.
 +		 */
 +		if (table_desc->length !=
 +		    acpi_gbl_root_table_list.tables[i].length) {
 +			continue;
 +		}
++=======
++			/*
++			 * Note: the current mechanism does not unregister a table if it is
++			 * dynamically unloaded. The related namespace entries are deleted,
++			 * but the table remains in the root table list.
++			 *
++			 * The assumption here is that the number of different tables that
++			 * will be loaded is actually small, and there is minimal overhead
++			 * in just keeping the table in case it is needed again.
++			 *
++			 * If this assumption changes in the future (perhaps on large
++			 * machines with many table load/unload operations), tables will
++			 * need to be unregistered when they are unloaded, and slots in the
++			 * root table list should be reused when empty.
++			 */
++			if (acpi_gbl_root_table_list.tables[i].flags &
++			    ACPI_TABLE_IS_LOADED) {
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
 +
 +		if (ACPI_MEMCMP(table_desc->pointer,
 +				acpi_gbl_root_table_list.tables[i].pointer,
 +				acpi_gbl_root_table_list.tables[i].length)) {
 +			continue;
 +		}
  
 -	acpi_tb_print_table_header(new_table_desc->address,
 -				   new_table_desc->pointer);
 +		/*
 +		 * Note: the current mechanism does not unregister a table if it is
 +		 * dynamically unloaded. The related namespace entries are deleted,
 +		 * but the table remains in the root table list.
 +		 *
 +		 * The assumption here is that the number of different tables that
 +		 * will be loaded is actually small, and there is minimal overhead
 +		 * in just keeping the table in case it is needed again.
 +		 *
 +		 * If this assumption changes in the future (perhaps on large
 +		 * machines with many table load/unload operations), tables will
 +		 * need to be unregistered when they are unloaded, and slots in the
 +		 * root table list should be reused when empty.
 +		 */
 +		*table_index = i;
  
 -	/* This synchronizes acpi_gbl_dsdt_index */
 +		if (acpi_gbl_root_table_list.tables[i].
 +		    flags & ACPI_TABLE_IS_LOADED) {
 +
 +			/* Table is still loaded, this is an error */
 +
 +			status = AE_ALREADY_EXISTS;
 +			goto release;
 +		} else {
 +			/* Table was unloaded, allow it to be reloaded */
 +
 +			acpi_tb_delete_table(table_desc);
 +			table_desc->pointer =
 +			    acpi_gbl_root_table_list.tables[i].pointer;
 +			table_desc->address =
 +			    acpi_gbl_root_table_list.tables[i].address;
 +			status = AE_OK;
 +			goto print_header;
 +		}
 +	}
  
 -	*table_index = i;
 +	/*
 +	 * ACPI Table Override:
 +	 * Allow the host to override dynamically loaded tables.
 +	 * NOTE: the table is fully mapped at this point, and the mapping will
 +	 * be deleted by tb_table_override if the table is actually overridden.
 +	 */
 +	(void)acpi_tb_table_override(table_desc->pointer, table_desc);
  
 -	/* Set the global integer width (based upon revision of the DSDT) */
 +	/* Add the table to the global root table list */
  
 -	if (i == acpi_gbl_dsdt_index) {
 -		acpi_ut_set_integer_width(new_table_desc->pointer->revision);
 +	status = acpi_tb_store_table(table_desc->address, table_desc->pointer,
 +				     table_desc->length, table_desc->flags,
 +				     table_index);
 +	if (ACPI_FAILURE(status)) {
 +		goto release;
  	}
 +
 +      print_header:
 +	acpi_tb_print_table_header(table_desc->address, table_desc->pointer);
 +
 +      release:
 +	(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
 +	return_ACPI_STATUS(status);
  }
  
  /*******************************************************************************
diff --cc drivers/acpi/acpica/tbutils.c
index 61ffb069ecd5,72bcccf1b7c4..000000000000
--- a/drivers/acpi/acpica/tbutils.c
+++ b/drivers/acpi/acpica/tbutils.c
@@@ -564,36 -352,66 +565,39 @@@ acpi_tb_parse_root_table(acpi_physical_
  
  		/* Get the table physical address (32-bit for RSDT, 64-bit for XSDT) */
  
 -		address =
 +		acpi_gbl_root_table_list.tables[acpi_gbl_root_table_list.
 +						current_table_count].address =
  		    acpi_tb_get_root_table_entry(table_entry, table_entry_size);
  
 -		/* Skip NULL entries in RSDT/XSDT */
 -
 -		if (!address) {
 -			goto next_table;
 -		}
 -
 -		status = acpi_tb_install_standard_table(address,
 -							ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL,
 -							FALSE, TRUE,
 -							&table_index);
 -
 -		if (ACPI_SUCCESS(status) &&
 -		    ACPI_COMPARE_NAME(&acpi_gbl_root_table_list.
 -				      tables[table_index].signature,
 -				      ACPI_SIG_FADT)) {
 -			acpi_gbl_fadt_index = table_index;
 -			acpi_tb_parse_fadt();
 -		}
 -
 -next_table:
 -
  		table_entry += table_entry_size;
 +		acpi_gbl_root_table_list.current_table_count++;
  	}
  
 +	/*
 +	 * It is not possible to map more than one entry in some environments,
 +	 * so unmap the root table here before mapping other tables
 +	 */
  	acpi_os_unmap_memory(table, length);
 -	return_ACPI_STATUS(AE_OK);
 -}
++<<<<<<< HEAD
  
 -/*******************************************************************************
 - *
 - * FUNCTION:    acpi_is_valid_signature
 - *
 - * PARAMETERS:  signature           - Sig string to be validated
 - *
 - * RETURN:      TRUE if signature is correct length and has valid characters
 - *
 - * DESCRIPTION: Validate an ACPI table signature.
 - *
 - ******************************************************************************/
 -
 -u8 acpi_is_valid_signature(char *signature)
 -{
 -	u32 i;
 -
 -	/* Validate the signature length */
 -
 -	if (strlen(signature) != ACPI_NAME_SIZE) {
 -		return (FALSE);
 -	}
 +	/*
 +	 * Complete the initialization of the root table array by examining
 +	 * the header of each table
 +	 */
 +	for (i = 2; i < acpi_gbl_root_table_list.current_table_count; i++) {
 +		acpi_tb_install_table(acpi_gbl_root_table_list.tables[i].
 +				      address, NULL, i);
  
 -	/* Validate each character in the signature */
 +		/* Special case for FADT - get the DSDT and FACS */
  
 -	for (i = 0; i < ACPI_NAME_SIZE; i++) {
 -		if (!acpi_ut_valid_acpi_char(signature[i], i)) {
 -			return (FALSE);
 +		if (ACPI_COMPARE_NAME
 +		    (&acpi_gbl_root_table_list.tables[i].signature,
 +		     ACPI_SIG_FADT)) {
 +			acpi_tb_parse_fadt(i);
  		}
  	}
  
 -	return (TRUE);
++=======
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
 +	return_ACPI_STATUS(AE_OK);
  }
diff --cc drivers/acpi/acpica/tbxfload.c
index 2620dbe96cfa,9a7d72b75355..000000000000
--- a/drivers/acpi/acpica/tbxfload.c
+++ b/drivers/acpi/acpica/tbxfload.c
@@@ -195,7 -185,23 +195,27 @@@ static acpi_status acpi_tb_load_namespa
  		/* Ignore errors while loading tables, get as many as possible */
  
  		(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
++<<<<<<< HEAD
 +		(void)acpi_ns_load_table(i, acpi_gbl_root_node);
++=======
+ 		status = acpi_ns_load_table(i, acpi_gbl_root_node);
+ 		if (ACPI_FAILURE(status)) {
+ 			ACPI_EXCEPTION((AE_INFO, status,
+ 					"(%4.4s:%8.8s) while loading table",
+ 					table->signature.ascii,
+ 					table->pointer->oem_table_id));
+ 
+ 			tables_failed++;
+ 
+ 			ACPI_DEBUG_PRINT_RAW((ACPI_DB_INIT,
+ 					      "Table [%4.4s:%8.8s] (id FF) - Table namespace load failed\n\n",
+ 					      table->signature.ascii,
+ 					      table->pointer->oem_table_id));
+ 		} else {
+ 			tables_loaded++;
+ 		}
+ 
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  		(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
  	}
  
diff --cc drivers/acpi/acpica/utdelete.c
index d6b33f29d327,1afd7427a90c..000000000000
--- a/drivers/acpi/acpica/utdelete.c
+++ b/drivers/acpi/acpica/utdelete.c
@@@ -208,6 -209,10 +208,13 @@@ static void acpi_ut_delete_internal_obj
  			acpi_ut_delete_object_desc(object->method.mutex);
  			object->method.mutex = NULL;
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		if (object->method.node) {
+ 			object->method.node = NULL;
+ 		}
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  		break;
  
  	case ACPI_TYPE_REGION:
diff --cc drivers/acpi/acpica/utobject.c
index aa61f66ee861,787eccf6a1d5..000000000000
--- a/drivers/acpi/acpica/utobject.c
+++ b/drivers/acpi/acpica/utobject.c
@@@ -253,7 -253,8 +253,12 @@@ union acpi_operand_object *acpi_ut_crea
  		buffer = ACPI_ALLOCATE_ZEROED(buffer_size);
  		if (!buffer) {
  			ACPI_ERROR((AE_INFO, "Could not allocate size %u",
++<<<<<<< HEAD
 +				    (u32) buffer_size));
++=======
+ 				    (u32)buffer_size));
+ 
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  			acpi_ut_remove_reference(buffer_desc);
  			return_PTR(NULL);
  		}
@@@ -305,7 -306,8 +310,12 @@@ union acpi_operand_object *acpi_ut_crea
  	string = ACPI_ALLOCATE_ZEROED(string_size + 1);
  	if (!string) {
  		ACPI_ERROR((AE_INFO, "Could not allocate size %u",
++<<<<<<< HEAD
 +			    (u32) string_size));
++=======
+ 			    (u32)string_size));
+ 
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  		acpi_ut_remove_reference(string_desc);
  		return_PTR(NULL);
  	}
diff --cc drivers/acpi/acpica/utosi.c
index bc8f5a2af0d4,0809d73193e1..000000000000
--- a/drivers/acpi/acpica/utosi.c
+++ b/drivers/acpi/acpica/utosi.c
@@@ -236,10 -268,11 +236,18 @@@ acpi_status acpi_ut_remove_interface(ac
  
  	previous_interface = next_interface = acpi_gbl_supported_interfaces;
  	while (next_interface) {
++<<<<<<< HEAD
 +		if (!ACPI_STRCMP(interface_name, next_interface->name)) {
 +
 +			/* Found: name is in either the static list or was added at runtime */
 +
++=======
+ 		if (!strcmp(interface_name, next_interface->name)) {
+ 			/*
+ 			 * Found: name is in either the static list
+ 			 * or was added at runtime
+ 			 */
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  			if (next_interface->flags & ACPI_OSI_DYNAMIC) {
  
  				/* Interface was added dynamically, remove and free it */
diff --cc drivers/acpi/acpica/utxface.c
index 71911d7853df,9f3f0a1591f6..000000000000
--- a/drivers/acpi/acpica/utxface.c
+++ b/drivers/acpi/acpica/utxface.c
@@@ -208,6 -183,43 +207,46 @@@ acpi_status acpi_get_system_info(struc
  
  ACPI_EXPORT_SYMBOL(acpi_get_system_info)
  
++<<<<<<< HEAD
++=======
+ /*******************************************************************************
+  *
+  * FUNCTION:    acpi_get_statistics
+  *
+  * PARAMETERS:  stats           - Where the statistics are returned
+  *
+  * RETURN:      status          - the status of the call
+  *
+  * DESCRIPTION: Get the contents of the various system counters
+  *
+  ******************************************************************************/
+ acpi_status acpi_get_statistics(struct acpi_statistics *stats)
+ {
+ 	ACPI_FUNCTION_TRACE(acpi_get_statistics);
+ 
+ 	/* Parameter validation */
+ 
+ 	if (!stats) {
+ 		return_ACPI_STATUS(AE_BAD_PARAMETER);
+ 	}
+ 
+ 	/* Various interrupt-based event counters */
+ 
+ 	stats->sci_count = acpi_sci_count;
+ 	stats->gpe_count = acpi_gpe_count;
+ 
+ 	memcpy(stats->fixed_event_count, acpi_fixed_event_count,
+ 	       sizeof(acpi_fixed_event_count));
+ 
+ 	/* Other counters */
+ 
+ 	stats->method_count = acpi_method_count;
+ 	return_ACPI_STATUS(AE_OK);
+ }
+ 
+ ACPI_EXPORT_SYMBOL(acpi_get_statistics)
+ 
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  /*****************************************************************************
   *
   * FUNCTION:    acpi_install_initialization_handler
diff --cc drivers/acpi/acpica/utxferror.c
index f7edb88f6054,f6cbaf451dbf..000000000000
--- a/drivers/acpi/acpica/utxferror.c
+++ b/drivers/acpi/acpica/utxferror.c
@@@ -106,9 -107,17 +106,22 @@@ acpi_exception(const char *module_name
  	va_list arg_list;
  
  	ACPI_MSG_REDIRECT_BEGIN;
 +	acpi_os_printf(ACPI_MSG_EXCEPTION "%s, ",
 +		       acpi_format_exception(status));
  
++<<<<<<< HEAD
++=======
+ 	/* For AE_OK, just print the message */
+ 
+ 	if (ACPI_SUCCESS(status)) {
+ 		acpi_os_printf(ACPI_MSG_EXCEPTION);
+ 
+ 	} else {
+ 		acpi_os_printf(ACPI_MSG_EXCEPTION "%s, ",
+ 			       acpi_format_exception(status));
+ 	}
+ 
++>>>>>>> 1fad87385e7e (ACPICA: Core: Major update for code formatting, no functional changes)
  	va_start(arg_list, format);
  	acpi_os_vprintf(format, arg_list);
  	ACPI_MSG_SUFFIX;
* Unmerged path drivers/acpi/acpica/dbstats.c
* Unmerged path drivers/acpi/acpica/dbutils.c
* Unmerged path drivers/acpi/acpica/dsdebug.c
* Unmerged path drivers/acpi/acpica/tbdata.c
* Unmerged path drivers/acpi/acpica/utfileio.c
* Unmerged path drivers/acpi/acpica/utnonansi.c
* Unmerged path drivers/acpi/acpica/utprint.c
* Unmerged path tools/power/acpi/common/getopt.c
* Unmerged path tools/power/acpi/tools/acpidump/apfiles.c
* Unmerged path drivers/acpi/acpica/dbstats.c
* Unmerged path drivers/acpi/acpica/dbutils.c
diff --git a/drivers/acpi/acpica/dsargs.c b/drivers/acpi/acpica/dsargs.c
index fb09b08d7080..a8391e68ad40 100644
--- a/drivers/acpi/acpica/dsargs.c
+++ b/drivers/acpi/acpica/dsargs.c
@@ -194,8 +194,8 @@ acpi_ds_get_buffer_field_arguments(union acpi_operand_object *obj_desc)
 	extra_desc = acpi_ns_get_secondary_object(obj_desc);
 	node = obj_desc->buffer_field.node;
 
-	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname(ACPI_TYPE_BUFFER_FIELD,
-						      node, NULL));
+	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname
+			(ACPI_TYPE_BUFFER_FIELD, node, NULL));
 
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "[%4.4s] BufferField Arg Init\n",
 			  acpi_ut_get_node_name(node)));
@@ -385,7 +385,8 @@ acpi_status acpi_ds_get_region_arguments(union acpi_operand_object *obj_desc)
 	ACPI_DEBUG_EXEC(acpi_ut_display_init_pathname
 			(ACPI_TYPE_REGION, node, NULL));
 
-	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "[%4.4s] OpRegion Arg Init at AML %p\n",
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "[%4.4s] OpRegion Arg Init at AML %p\n",
 			  acpi_ut_get_node_name(node),
 			  extra_desc->extra.aml_start));
 
* Unmerged path drivers/acpi/acpica/dsdebug.c
* Unmerged path drivers/acpi/acpica/dsfield.c
* Unmerged path drivers/acpi/acpica/dsinit.c
* Unmerged path drivers/acpi/acpica/dsmethod.c
diff --git a/drivers/acpi/acpica/dsmthdat.c b/drivers/acpi/acpica/dsmthdat.c
index c4b0b3657237..4d33e113e207 100644
--- a/drivers/acpi/acpica/dsmthdat.c
+++ b/drivers/acpi/acpica/dsmthdat.c
@@ -99,6 +99,7 @@ void acpi_ds_method_data_init(struct acpi_walk_state *walk_state)
 	for (i = 0; i < ACPI_METHOD_NUM_ARGS; i++) {
 		ACPI_MOVE_32_TO_32(&walk_state->arguments[i].name,
 				   NAMEOF_ARG_NTE);
+
 		walk_state->arguments[i].name.integer |= (i << 24);
 		walk_state->arguments[i].descriptor_type = ACPI_DESC_TYPE_NAMED;
 		walk_state->arguments[i].type = ACPI_TYPE_ANY;
@@ -201,7 +202,7 @@ acpi_ds_method_data_init_args(union acpi_operand_object **params,
 
 	if (!params) {
 		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
-				  "No param list passed to method\n"));
+				  "No parameter list passed to method\n"));
 		return_ACPI_STATUS(AE_OK);
 	}
 
@@ -214,9 +215,9 @@ acpi_ds_method_data_init_args(union acpi_operand_object **params,
 		 * Store the argument in the method/walk descriptor.
 		 * Do not copy the arg in order to implement call by reference
 		 */
-		status = acpi_ds_method_data_set_value(ACPI_REFCLASS_ARG, index,
-						       params[index],
-						       walk_state);
+		status =
+		    acpi_ds_method_data_set_value(ACPI_REFCLASS_ARG, index,
+						  params[index], walk_state);
 		if (ACPI_FAILURE(status)) {
 			return_ACPI_STATUS(status);
 		}
@@ -610,11 +611,11 @@ acpi_ds_store_object_to_local(u8 type,
 			 * do the indirect store
 			 */
 			if ((ACPI_GET_DESCRIPTOR_TYPE(current_obj_desc) ==
-			     ACPI_DESC_TYPE_OPERAND)
-			    && (current_obj_desc->common.type ==
-				ACPI_TYPE_LOCAL_REFERENCE)
-			    && (current_obj_desc->reference.class ==
-				ACPI_REFCLASS_REFOF)) {
+			     ACPI_DESC_TYPE_OPERAND) &&
+			    (current_obj_desc->common.type ==
+			     ACPI_TYPE_LOCAL_REFERENCE) &&
+			    (current_obj_desc->reference.class ==
+			     ACPI_REFCLASS_REFOF)) {
 				ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
 						  "Arg (%p) is an ObjRef(Node), storing in node %p\n",
 						  new_obj_desc,
@@ -638,6 +639,7 @@ acpi_ds_store_object_to_local(u8 type,
 				if (new_obj_desc != obj_desc) {
 					acpi_ut_remove_reference(new_obj_desc);
 				}
+
 				return_ACPI_STATUS(status);
 			}
 		}
diff --git a/drivers/acpi/acpica/dsobject.c b/drivers/acpi/acpica/dsobject.c
index 63f0d220ca3d..81839ddd2dd5 100644
--- a/drivers/acpi/acpica/dsobject.c
+++ b/drivers/acpi/acpica/dsobject.c
@@ -463,10 +463,10 @@ acpi_ds_build_internal_package_obj(struct acpi_walk_state *walk_state,
 						  arg->common.node);
 			}
 		} else {
-			status = acpi_ds_build_internal_object(walk_state, arg,
-							       &obj_desc->
-							       package.
-							       elements[i]);
+			status =
+			    acpi_ds_build_internal_object(walk_state, arg,
+							  &obj_desc->package.
+							  elements[i]);
 		}
 
 		if (*obj_desc_ptr) {
@@ -525,7 +525,8 @@ acpi_ds_build_internal_package_obj(struct acpi_walk_state *walk_state,
 		}
 
 		ACPI_INFO((AE_INFO,
-			   "Actual Package length (%u) is larger than NumElements field (%u), truncated",
+			   "Actual Package length (%u) is larger than "
+			   "NumElements field (%u), truncated",
 			   i, element_count));
 	} else if (i < element_count) {
 		/*
@@ -533,7 +534,8 @@ acpi_ds_build_internal_package_obj(struct acpi_walk_state *walk_state,
 		 * Note: this is not an error, the package is padded out with NULLs.
 		 */
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
-				  "Package List length (%u) smaller than NumElements count (%u), padded with null elements\n",
+				  "Package List length (%u) smaller than NumElements "
+				  "count (%u), padded with null elements\n",
 				  i, element_count));
 	}
 
@@ -584,8 +586,9 @@ acpi_ds_create_node(struct acpi_walk_state *walk_state,
 
 	/* Build an internal object for the argument(s) */
 
-	status = acpi_ds_build_internal_object(walk_state, op->common.value.arg,
-					       &obj_desc);
+	status =
+	    acpi_ds_build_internal_object(walk_state, op->common.value.arg,
+					  &obj_desc);
 	if (ACPI_FAILURE(status)) {
 		return_ACPI_STATUS(status);
 	}
diff --git a/drivers/acpi/acpica/dsopcode.c b/drivers/acpi/acpica/dsopcode.c
index 1fc1ff114f26..97d12b23cc33 100644
--- a/drivers/acpi/acpica/dsopcode.c
+++ b/drivers/acpi/acpica/dsopcode.c
@@ -243,8 +243,9 @@ acpi_ds_init_buffer_field(u16 aml_opcode,
 	 * For field_flags, use LOCK_RULE = 0 (NO_LOCK),
 	 * UPDATE_RULE = 0 (UPDATE_PRESERVE)
 	 */
-	status = acpi_ex_prep_common_field_object(obj_desc, field_flags, 0,
-						  bit_offset, bit_count);
+	status =
+	    acpi_ex_prep_common_field_object(obj_desc, field_flags, 0,
+					     bit_offset, bit_count);
 	if (ACPI_FAILURE(status)) {
 		goto cleanup;
 	}
@@ -330,8 +331,9 @@ acpi_ds_eval_buffer_field_operands(struct acpi_walk_state *walk_state,
 
 	/* Resolve the operands */
 
-	status = acpi_ex_resolve_operands(op->common.aml_opcode,
-					  ACPI_WALK_OPERANDS, walk_state);
+	status =
+	    acpi_ex_resolve_operands(op->common.aml_opcode, ACPI_WALK_OPERANDS,
+				     walk_state);
 	if (ACPI_FAILURE(status)) {
 		ACPI_ERROR((AE_INFO, "(%s) bad operand(s), status 0x%X",
 			    acpi_ps_get_opcode_name(op->common.aml_opcode),
@@ -414,8 +416,9 @@ acpi_ds_eval_region_operands(struct acpi_walk_state *walk_state,
 
 	/* Resolve the length and address operands to numbers */
 
-	status = acpi_ex_resolve_operands(op->common.aml_opcode,
-					  ACPI_WALK_OPERANDS, walk_state);
+	status =
+	    acpi_ex_resolve_operands(op->common.aml_opcode, ACPI_WALK_OPERANDS,
+				     walk_state);
 	if (ACPI_FAILURE(status)) {
 		return_ACPI_STATUS(status);
 	}
@@ -452,7 +455,6 @@ acpi_ds_eval_region_operands(struct acpi_walk_state *walk_state,
 	/* Now the address and length are valid for this opregion */
 
 	obj_desc->region.flags |= AOPOBJ_DATA_VALID;
-
 	return_ACPI_STATUS(status);
 }
 
@@ -508,8 +510,9 @@ acpi_ds_eval_table_region_operands(struct acpi_walk_state *walk_state,
 	 * Resolve the Signature string, oem_id string,
 	 * and oem_table_id string operands
 	 */
-	status = acpi_ex_resolve_operands(op->common.aml_opcode,
-					  ACPI_WALK_OPERANDS, walk_state);
+	status =
+	    acpi_ex_resolve_operands(op->common.aml_opcode, ACPI_WALK_OPERANDS,
+				     walk_state);
 	if (ACPI_FAILURE(status)) {
 		return_ACPI_STATUS(status);
 	}
* Unmerged path drivers/acpi/acpica/dsutils.c
diff --git a/drivers/acpi/acpica/dswexec.c b/drivers/acpi/acpica/dswexec.c
index 151d924817e1..44d03f2639c5 100644
--- a/drivers/acpi/acpica/dswexec.c
+++ b/drivers/acpi/acpica/dswexec.c
@@ -172,7 +172,8 @@ acpi_ds_get_predicate_value(struct acpi_walk_state *walk_state,
 
       cleanup:
 
-	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Completed a predicate eval=%X Op=%p\n",
+	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+			  "Completed a predicate eval=%X Op=%p\n",
 			  walk_state->control_state->common.value,
 			  walk_state->op));
 
@@ -264,8 +265,8 @@ acpi_ds_exec_begin_op(struct acpi_walk_state *walk_state,
 	    (walk_state->control_state->common.state ==
 	     ACPI_CONTROL_CONDITIONAL_EXECUTING)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
-				  "Exec predicate Op=%p State=%p\n", op,
-				  walk_state));
+				  "Exec predicate Op=%p State=%p\n",
+				  op, walk_state));
 
 		walk_state->control_state->common.state =
 		    ACPI_CONTROL_PREDICATE_EXECUTING;
@@ -502,9 +503,8 @@ acpi_status acpi_ds_exec_end_op(struct acpi_walk_state *walk_state)
 						  "Method Reference in a Package, Op=%p\n",
 						  op));
 
-				op->common.node =
-				    (struct acpi_namespace_node *)op->asl.value.
-				    arg->asl.node;
+				op->common.node = (struct acpi_namespace_node *)
+				    op->asl.value.arg->asl.node;
 				acpi_ut_add_reference(op->asl.value.arg->asl.
 						      node->object);
 				return_ACPI_STATUS(AE_OK);
@@ -586,8 +586,8 @@ acpi_status acpi_ds_exec_end_op(struct acpi_walk_state *walk_state)
 				 * Put the Node on the object stack (Contains the ACPI Name
 				 * of this object)
 				 */
-				walk_state->operands[0] =
-				    (void *)op->common.parent->common.node;
+				walk_state->operands[0] = (void *)
+				    op->common.parent->common.node;
 				walk_state->num_operands = 1;
 
 				status = acpi_ds_create_node(walk_state,
@@ -692,7 +692,8 @@ acpi_status acpi_ds_exec_end_op(struct acpi_walk_state *walk_state)
 		default:
 
 			ACPI_ERROR((AE_INFO,
-				    "Unimplemented opcode, class=0x%X type=0x%X Opcode=0x%X Op=%p",
+				    "Unimplemented opcode, class=0x%X "
+				    "type=0x%X Opcode=0x%X Op=%p",
 				    op_class, op_type, op->common.aml_opcode,
 				    op));
 
diff --git a/drivers/acpi/acpica/dswload.c b/drivers/acpi/acpica/dswload.c
index 95e681a36f9c..24214085f9d1 100644
--- a/drivers/acpi/acpica/dswload.c
+++ b/drivers/acpi/acpica/dswload.c
@@ -451,13 +451,9 @@ acpi_status acpi_ds_load1_end_op(struct acpi_walk_state *walk_state)
 			status =
 			    acpi_ex_create_region(op->named.data,
 						  op->named.length,
-						  (acpi_adr_space_type) ((op->
-									  common.
-									  value.
-									  arg)->
-									 common.
-									 value.
-									 integer),
+						  (acpi_adr_space_type)
+						  ((op->common.value.arg)->
+						   common.value.integer),
 						  walk_state);
 			if (ACPI_FAILURE(status)) {
 				return_ACPI_STATUS(status);
diff --git a/drivers/acpi/acpica/dswload2.c b/drivers/acpi/acpica/dswload2.c
index b1f8f4725c23..0853807d5445 100644
--- a/drivers/acpi/acpica/dswload2.c
+++ b/drivers/acpi/acpica/dswload2.c
@@ -598,11 +598,10 @@ acpi_status acpi_ds_load2_end_op(struct acpi_walk_state *walk_state)
 				 * Executing a method: initialize the region and unlock
 				 * the interpreter
 				 */
-				status =
-				    acpi_ex_create_region(op->named.data,
-							  op->named.length,
-							  region_space,
-							  walk_state);
+				status = acpi_ex_create_region(op->named.data,
+							       op->named.length,
+							       region_space,
+							       walk_state);
 				if (ACPI_FAILURE(status)) {
 					return_ACPI_STATUS(status);
 				}
@@ -664,6 +663,7 @@ acpi_status acpi_ds_load2_end_op(struct acpi_walk_state *walk_state)
 								  length,
 								  walk_state);
 				}
+
 				walk_state->operands[0] = NULL;
 				walk_state->num_operands = 0;
 
diff --git a/drivers/acpi/acpica/dswscope.c b/drivers/acpi/acpica/dswscope.c
index d67891de1b54..f7a4e0e9d2be 100644
--- a/drivers/acpi/acpica/dswscope.c
+++ b/drivers/acpi/acpica/dswscope.c
@@ -77,6 +77,7 @@ void acpi_ds_scope_stack_clear(struct acpi_walk_state *walk_state)
 				  "Popped object type (%s)\n",
 				  acpi_ut_get_type_name(scope_info->common.
 							value)));
+
 		acpi_ut_delete_generic_state(scope_info);
 	}
 }
diff --git a/drivers/acpi/acpica/evgpe.c b/drivers/acpi/acpica/evgpe.c
index c8a1f7d5931f..3bc6d05b377b 100644
--- a/drivers/acpi/acpica/evgpe.c
+++ b/drivers/acpi/acpica/evgpe.c
@@ -93,6 +93,7 @@ acpi_ev_update_gpe_enable_mask(struct acpi_gpe_event_info *gpe_event_info)
 			     (u8)register_bit);
 	}
 
+	gpe_register_info->enable_mask = gpe_register_info->enable_for_run;
 	return_ACPI_STATUS(AE_OK);
 }
 
diff --git a/drivers/acpi/acpica/evgpeblk.c b/drivers/acpi/acpica/evgpeblk.c
index c1aa1eda26c3..2dffa7304319 100644
--- a/drivers/acpi/acpica/evgpeblk.c
+++ b/drivers/acpi/acpica/evgpeblk.c
@@ -167,6 +167,7 @@ acpi_status acpi_ev_delete_gpe_block(struct acpi_gpe_block_info *gpe_block)
 		if (gpe_block->next) {
 			gpe_block->next->previous = gpe_block->previous;
 		}
+
 		acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
 	}
 
diff --git a/drivers/acpi/acpica/evgpeutil.c b/drivers/acpi/acpica/evgpeutil.c
index b24dbb80fab8..d916253de57f 100644
--- a/drivers/acpi/acpica/evgpeutil.c
+++ b/drivers/acpi/acpica/evgpeutil.c
@@ -387,6 +387,7 @@ acpi_ev_delete_gpe_handlers(struct acpi_gpe_xrupt_info *gpe_xrupt_info,
 					ACPI_FREE(notify);
 					notify = next;
 				}
+
 				gpe_event_info->dispatch.notify_list = NULL;
 				gpe_event_info->flags &=
 				    ~ACPI_GPE_DISPATCH_MASK;
diff --git a/drivers/acpi/acpica/evmisc.c b/drivers/acpi/acpica/evmisc.c
index a9e7b62fc800..c55485b01576 100644
--- a/drivers/acpi/acpica/evmisc.c
+++ b/drivers/acpi/acpica/evmisc.c
@@ -68,6 +68,7 @@ static void ACPI_SYSTEM_XFACE acpi_ev_notify_dispatch(void *context);
 
 u8 acpi_ev_is_notify_object(struct acpi_namespace_node *node)
 {
+
 	switch (node->type) {
 	case ACPI_TYPE_DEVICE:
 	case ACPI_TYPE_PROCESSOR:
@@ -170,8 +171,8 @@ acpi_ev_queue_notify_request(struct acpi_namespace_node * node,
 			  acpi_ut_get_notify_name(notify_value, ACPI_TYPE_ANY),
 			  node));
 
-	status = acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_ev_notify_dispatch,
-				 info);
+	status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+				 acpi_ev_notify_dispatch, info);
 	if (ACPI_FAILURE(status)) {
 		acpi_ut_delete_generic_state(info);
 	}
* Unmerged path drivers/acpi/acpica/evxface.c
diff --git a/drivers/acpi/acpica/evxfregn.c b/drivers/acpi/acpica/evxfregn.c
index 1bd3225be468..f3b3ee5dc605 100644
--- a/drivers/acpi/acpica/evxfregn.c
+++ b/drivers/acpi/acpica/evxfregn.c
@@ -135,6 +135,7 @@ acpi_install_address_space_handler(acpi_handle device,
 		if (!acpi_gbl_reg_methods_executed) {
 
 			/* We will defer execution of the _REG methods for this space */
+
 			goto unlock_and_exit;
 		}
 		break;
diff --git a/drivers/acpi/acpica/exconfig.c b/drivers/acpi/acpica/exconfig.c
index 5bff332aa0f0..c365b5e8478c 100644
--- a/drivers/acpi/acpica/exconfig.c
+++ b/drivers/acpi/acpica/exconfig.c
@@ -368,8 +368,8 @@ acpi_ex_load_op(union acpi_operand_object *obj_desc,
 		}
 
 		/*
-		 * If the Region Address and Length have not been previously evaluated,
-		 * evaluate them now and save the results.
+		 * If the Region Address and Length have not been previously
+		 * evaluated, evaluate them now and save the results.
 		 */
 		if (!(obj_desc->common.flags & AOPOBJ_DATA_VALID)) {
 			status = acpi_ds_get_region_arguments(obj_desc);
@@ -467,8 +467,8 @@ acpi_ex_load_op(union acpi_operand_object *obj_desc,
 		}
 
 		/*
-		 * Copy the table from the buffer because the buffer could be modified
-		 * or even deleted in the future
+		 * Copy the table from the buffer because the buffer could be
+		 * modified or even deleted in the future
 		 */
 		table_desc.pointer = ACPI_ALLOCATE(length);
 		if (!table_desc.pointer) {
* Unmerged path drivers/acpi/acpica/exconvrt.c
* Unmerged path drivers/acpi/acpica/excreate.c
* Unmerged path drivers/acpi/acpica/exdebug.c
* Unmerged path drivers/acpi/acpica/exfield.c
diff --git a/drivers/acpi/acpica/exfldio.c b/drivers/acpi/acpica/exfldio.c
index 7e0afe72487e..296cc11286d4 100644
--- a/drivers/acpi/acpica/exfldio.c
+++ b/drivers/acpi/acpica/exfldio.c
@@ -186,7 +186,8 @@ acpi_ex_setup_region(union acpi_operand_object *obj_desc,
 			 * byte, and a field with Dword access specified.
 			 */
 			ACPI_ERROR((AE_INFO,
-				    "Field [%4.4s] access width (%u bytes) too large for region [%4.4s] (length %u)",
+				    "Field [%4.4s] access width (%u bytes) "
+				    "too large for region [%4.4s] (length %u)",
 				    acpi_ut_get_node_name(obj_desc->
 							  common_field.node),
 				    obj_desc->common_field.access_byte_width,
@@ -200,7 +201,8 @@ acpi_ex_setup_region(union acpi_operand_object *obj_desc,
 		 * exceeds region length, indicate an error
 		 */
 		ACPI_ERROR((AE_INFO,
-			    "Field [%4.4s] Base+Offset+Width %u+%u+%u is beyond end of region [%4.4s] (length %u)",
+			    "Field [%4.4s] Base+Offset+Width %u+%u+%u "
+			    "is beyond end of region [%4.4s] (length %u)",
 			    acpi_ut_get_node_name(obj_desc->common_field.node),
 			    obj_desc->common_field.base_byte_offset,
 			    field_datum_byte_offset,
@@ -646,15 +648,15 @@ acpi_ex_write_with_update_rule(union acpi_operand_object *obj_desc,
 
 			ACPI_ERROR((AE_INFO,
 				    "Unknown UpdateRule value: 0x%X",
-				    (obj_desc->common_field.
-				     field_flags &
+				    (obj_desc->common_field.field_flags &
 				     AML_FIELD_UPDATE_RULE_MASK)));
 			return_ACPI_STATUS(AE_AML_OPERAND_VALUE);
 		}
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
-			  "Mask %8.8X%8.8X, DatumOffset %X, Width %X, Value %8.8X%8.8X, MergedValue %8.8X%8.8X\n",
+			  "Mask %8.8X%8.8X, DatumOffset %X, Width %X, "
+			  "Value %8.8X%8.8X, MergedValue %8.8X%8.8X\n",
 			  ACPI_FORMAT_UINT64(mask),
 			  field_datum_byte_offset,
 			  obj_desc->common_field.access_byte_width,
@@ -663,8 +665,9 @@ acpi_ex_write_with_update_rule(union acpi_operand_object *obj_desc,
 
 	/* Write the merged value */
 
-	status = acpi_ex_field_datum_io(obj_desc, field_datum_byte_offset,
-					&merged_value, ACPI_WRITE);
+	status =
+	    acpi_ex_field_datum_io(obj_desc, field_datum_byte_offset,
+				   &merged_value, ACPI_WRITE);
 
 	return_ACPI_STATUS(status);
 }
@@ -772,8 +775,9 @@ acpi_ex_extract_from_field(union acpi_operand_object *obj_desc,
 		/* Get next input datum from the field */
 
 		field_offset += obj_desc->common_field.access_byte_width;
-		status = acpi_ex_field_datum_io(obj_desc, field_offset,
-						&raw_datum, ACPI_READ);
+		status =
+		    acpi_ex_field_datum_io(obj_desc, field_offset, &raw_datum,
+					   ACPI_READ);
 		if (ACPI_FAILURE(status)) {
 			return_ACPI_STATUS(status);
 		}
@@ -866,6 +870,7 @@ acpi_ex_insert_into_field(union acpi_operand_object *obj_desc,
 	new_buffer = NULL;
 	required_length =
 	    ACPI_ROUND_BITS_UP_TO_BYTES(obj_desc->common_field.bit_length);
+
 	/*
 	 * We must have a buffer that is at least as long as the field
 	 * we are writing to. This is because individual fields are
@@ -940,9 +945,9 @@ acpi_ex_insert_into_field(union acpi_operand_object *obj_desc,
 		/* Write merged datum to the target field */
 
 		merged_datum &= mask;
-		status = acpi_ex_write_with_update_rule(obj_desc, mask,
-							merged_datum,
-							field_offset);
+		status =
+		    acpi_ex_write_with_update_rule(obj_desc, mask, merged_datum,
+						   field_offset);
 		if (ACPI_FAILURE(status)) {
 			goto exit;
 		}
@@ -998,9 +1003,9 @@ acpi_ex_insert_into_field(union acpi_operand_object *obj_desc,
 	/* Write the last datum to the field */
 
 	merged_datum &= mask;
-	status = acpi_ex_write_with_update_rule(obj_desc,
-						mask, merged_datum,
-						field_offset);
+	status =
+	    acpi_ex_write_with_update_rule(obj_desc, mask, merged_datum,
+					   field_offset);
 
       exit:
 	/* Free temporary buffer if we used one */
diff --git a/drivers/acpi/acpica/exmisc.c b/drivers/acpi/acpica/exmisc.c
index 00bf29877574..c002ffe4c598 100644
--- a/drivers/acpi/acpica/exmisc.c
+++ b/drivers/acpi/acpica/exmisc.c
@@ -267,8 +267,9 @@ acpi_ex_do_concatenate(union acpi_operand_object *operand0,
 
 	case ACPI_TYPE_STRING:
 
-		status = acpi_ex_convert_to_string(operand1, &local_operand1,
-						   ACPI_IMPLICIT_CONVERT_HEX);
+		status =
+		    acpi_ex_convert_to_string(operand1, &local_operand1,
+					      ACPI_IMPLICIT_CONVERT_HEX);
 		break;
 
 	case ACPI_TYPE_BUFFER:
@@ -591,8 +592,9 @@ acpi_ex_do_logical_op(u16 opcode,
 
 	case ACPI_TYPE_STRING:
 
-		status = acpi_ex_convert_to_string(operand1, &local_operand1,
-						   ACPI_IMPLICIT_CONVERT_HEX);
+		status =
+		    acpi_ex_convert_to_string(operand1, &local_operand1,
+					      ACPI_IMPLICIT_CONVERT_HEX);
 		break;
 
 	case ACPI_TYPE_BUFFER:
diff --git a/drivers/acpi/acpica/exnames.c b/drivers/acpi/acpica/exnames.c
index 14689dec4960..cc162a6435a9 100644
--- a/drivers/acpi/acpica/exnames.c
+++ b/drivers/acpi/acpica/exnames.c
@@ -164,8 +164,8 @@ static acpi_status acpi_ex_name_segment(u8 ** in_aml_address, char *name_string)
 	ACPI_FUNCTION_TRACE(ex_name_segment);
 
 	/*
-	 * If first character is a digit, then we know that we aren't looking at a
-	 * valid name segment
+	 * If first character is a digit, then we know that we aren't looking
+	 * at a valid name segment
 	 */
 	char_buf[0] = *aml_address;
 
diff --git a/drivers/acpi/acpica/exoparg1.c b/drivers/acpi/acpica/exoparg1.c
index 814b4a3d656a..48c534199fe3 100644
--- a/drivers/acpi/acpica/exoparg1.c
+++ b/drivers/acpi/acpica/exoparg1.c
@@ -484,22 +484,26 @@ acpi_status acpi_ex_opcode_1A_1T_1R(struct acpi_walk_state *walk_state)
 
 	case AML_TO_DECSTRING_OP:	/* to_decimal_string (Data, Result) */
 
-		status = acpi_ex_convert_to_string(operand[0], &return_desc,
-						   ACPI_EXPLICIT_CONVERT_DECIMAL);
+		status =
+		    acpi_ex_convert_to_string(operand[0], &return_desc,
+					      ACPI_EXPLICIT_CONVERT_DECIMAL);
 		if (return_desc == operand[0]) {
 
 			/* No conversion performed, add ref to handle return value */
+
 			acpi_ut_add_reference(return_desc);
 		}
 		break;
 
 	case AML_TO_HEXSTRING_OP:	/* to_hex_string (Data, Result) */
 
-		status = acpi_ex_convert_to_string(operand[0], &return_desc,
-						   ACPI_EXPLICIT_CONVERT_HEX);
+		status =
+		    acpi_ex_convert_to_string(operand[0], &return_desc,
+					      ACPI_EXPLICIT_CONVERT_HEX);
 		if (return_desc == operand[0]) {
 
 			/* No conversion performed, add ref to handle return value */
+
 			acpi_ut_add_reference(return_desc);
 		}
 		break;
@@ -510,17 +514,20 @@ acpi_status acpi_ex_opcode_1A_1T_1R(struct acpi_walk_state *walk_state)
 		if (return_desc == operand[0]) {
 
 			/* No conversion performed, add ref to handle return value */
+
 			acpi_ut_add_reference(return_desc);
 		}
 		break;
 
 	case AML_TO_INTEGER_OP:	/* to_integer (Data, Result) */
 
-		status = acpi_ex_convert_to_integer(operand[0], &return_desc,
-						    ACPI_ANY_BASE);
+		status =
+		    acpi_ex_convert_to_integer(operand[0], &return_desc,
+					       ACPI_ANY_BASE);
 		if (return_desc == operand[0]) {
 
 			/* No conversion performed, add ref to handle return value */
+
 			acpi_ut_add_reference(return_desc);
 		}
 		break;
@@ -713,9 +720,9 @@ acpi_status acpi_ex_opcode_1A_0T_1R(struct acpi_walk_state *walk_state)
 
 		/* Get the base object */
 
-		status = acpi_ex_resolve_multiple(walk_state,
-						  operand[0], &type,
-						  &temp_desc);
+		status =
+		    acpi_ex_resolve_multiple(walk_state, operand[0], &type,
+					     &temp_desc);
 		if (ACPI_FAILURE(status)) {
 			goto cleanup;
 		}
@@ -759,8 +766,10 @@ acpi_status acpi_ex_opcode_1A_0T_1R(struct acpi_walk_state *walk_state)
 		default:
 
 			ACPI_ERROR((AE_INFO,
-				    "Operand must be Buffer/Integer/String/Package - found type %s",
+				    "Operand must be Buffer/Integer/String/Package"
+				    " - found type %s",
 				    acpi_ut_get_type_name(type)));
+
 			status = AE_AML_OPERAND_TYPE;
 			goto cleanup;
 		}
@@ -974,6 +983,7 @@ acpi_status acpi_ex_opcode_1A_0T_1R(struct acpi_walk_state *walk_state)
 						    "Unknown Index TargetType 0x%X in reference object %p",
 						    operand[0]->reference.
 						    target_type, operand[0]));
+
 					status = AE_AML_OPERAND_TYPE;
 					goto cleanup;
 				}
@@ -1014,6 +1024,7 @@ acpi_status acpi_ex_opcode_1A_0T_1R(struct acpi_walk_state *walk_state)
 
 		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
 			    walk_state->opcode));
+
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
 	}
diff --git a/drivers/acpi/acpica/exoparg2.c b/drivers/acpi/acpica/exoparg2.c
index d5088f7030c7..05210c8a08ab 100644
--- a/drivers/acpi/acpica/exoparg2.c
+++ b/drivers/acpi/acpica/exoparg2.c
@@ -199,6 +199,7 @@ acpi_status acpi_ex_opcode_2A_2T_1R(struct acpi_walk_state *walk_state)
 
 		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
 			    walk_state->opcode));
+
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
 	}
@@ -299,8 +300,9 @@ acpi_status acpi_ex_opcode_2A_1T_1R(struct acpi_walk_state *walk_state)
 
 	case AML_CONCAT_OP:	/* Concatenate (Data1, Data2, Result) */
 
-		status = acpi_ex_do_concatenate(operand[0], operand[1],
-						&return_desc, walk_state);
+		status =
+		    acpi_ex_do_concatenate(operand[0], operand[1], &return_desc,
+					   walk_state);
 		break;
 
 	case AML_TO_STRING_OP:	/* to_string (Buffer, Length, Result) (ACPI 2.0) */
@@ -345,8 +347,9 @@ acpi_status acpi_ex_opcode_2A_1T_1R(struct acpi_walk_state *walk_state)
 
 		/* concatenate_res_template (Buffer, Buffer, Result) (ACPI 2.0) */
 
-		status = acpi_ex_concat_template(operand[0], operand[1],
-						 &return_desc, walk_state);
+		status =
+		    acpi_ex_concat_template(operand[0], operand[1],
+					    &return_desc, walk_state);
 		break;
 
 	case AML_INDEX_OP:	/* Index (Source Index Result) */
@@ -549,6 +552,7 @@ acpi_status acpi_ex_opcode_2A_0T_1R(struct acpi_walk_state *walk_state)
 
 		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
 			    walk_state->opcode));
+
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
 	}
* Unmerged path drivers/acpi/acpica/exoparg3.c
diff --git a/drivers/acpi/acpica/exoparg6.c b/drivers/acpi/acpica/exoparg6.c
index 879b6cd8319c..25c975a4c15e 100644
--- a/drivers/acpi/acpica/exoparg6.c
+++ b/drivers/acpi/acpica/exoparg6.c
@@ -310,6 +310,7 @@ acpi_status acpi_ex_opcode_6A_0T_1R(struct acpi_walk_state * walk_state)
 
 		ACPI_ERROR((AE_INFO, "Unknown AML opcode 0x%X",
 			    walk_state->opcode));
+
 		status = AE_AML_BAD_OPCODE;
 		goto cleanup;
 	}
diff --git a/drivers/acpi/acpica/exprep.c b/drivers/acpi/acpica/exprep.c
index 5a588611ab48..ed1771442024 100644
--- a/drivers/acpi/acpica/exprep.c
+++ b/drivers/acpi/acpica/exprep.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Module Name: exprep - ACPI AML (p-code) execution - field prep utilities
+ * Module Name: exprep - ACPI AML field prep utilities
  *
  *****************************************************************************/
 
@@ -103,8 +103,10 @@ acpi_ex_generate_access(u32 field_bit_offset,
 	/* Round Field start offset and length to "minimal" byte boundaries */
 
 	field_byte_offset = ACPI_DIV_8(ACPI_ROUND_DOWN(field_bit_offset, 8));
-	field_byte_end_offset = ACPI_DIV_8(ACPI_ROUND_UP(field_bit_length +
-							 field_bit_offset, 8));
+
+	field_byte_end_offset =
+	    ACPI_DIV_8(ACPI_ROUND_UP(field_bit_length + field_bit_offset, 8));
+
 	field_byte_length = field_byte_end_offset - field_byte_offset;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
@@ -159,7 +161,8 @@ acpi_ex_generate_access(u32 field_bit_offset,
 
 			if (accesses <= 1) {
 				ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
-						  "Entire field can be accessed with one operation of size %u\n",
+						  "Entire field can be accessed "
+						  "with one operation of size %u\n",
 						  access_byte_width));
 				return_VALUE(access_byte_width);
 			}
@@ -202,6 +205,7 @@ acpi_ex_generate_access(u32 field_bit_offset,
 	 */
 	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
 			  "Cannot access field in one operation, using width 8\n"));
+
 	return_VALUE(8);
 }
 #endif				/* ACPI_UNDER_DEVELOPMENT */
@@ -281,6 +285,7 @@ acpi_ex_decode_field_access(union acpi_operand_object *obj_desc,
 		/* Invalid field access type */
 
 		ACPI_ERROR((AE_INFO, "Unknown field access type 0x%X", access));
+
 		return_UINT32(0);
 	}
 
@@ -354,8 +359,8 @@ acpi_ex_prep_common_field_object(union acpi_operand_object *obj_desc,
 	 * For all other access types (Byte, Word, Dword, Qword), the Bitwidth is
 	 * the same (equivalent) as the byte_alignment.
 	 */
-	access_bit_width = acpi_ex_decode_field_access(obj_desc, field_flags,
-						       &byte_alignment);
+	access_bit_width =
+	    acpi_ex_decode_field_access(obj_desc, field_flags, &byte_alignment);
 	if (!access_bit_width) {
 		return_ACPI_STATUS(AE_AML_OPERAND_VALUE);
 	}
@@ -593,7 +598,8 @@ acpi_status acpi_ex_prep_field_value(struct acpi_create_field_info *info)
 					  access_byte_width);
 
 		ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
-				  "IndexField: BitOff %X, Off %X, Value %X, Gran %X, Index %p, Data %p\n",
+				  "IndexField: BitOff %X, Off %X, Value %X, "
+				  "Gran %X, Index %p, Data %p\n",
 				  obj_desc->index_field.start_field_bit_offset,
 				  obj_desc->index_field.base_byte_offset,
 				  obj_desc->index_field.value,
@@ -613,8 +619,9 @@ acpi_status acpi_ex_prep_field_value(struct acpi_create_field_info *info)
 	 * Store the constructed descriptor (obj_desc) into the parent Node,
 	 * preserving the current type of that named_obj.
 	 */
-	status = acpi_ns_attach_object(info->field_node, obj_desc,
-				       acpi_ns_get_type(info->field_node));
+	status =
+	    acpi_ns_attach_object(info->field_node, obj_desc,
+				  acpi_ns_get_type(info->field_node));
 
 	ACPI_DEBUG_PRINT((ACPI_DB_BFIELD,
 			  "Set NamedObj %p [%4.4s], ObjDesc %p\n",
* Unmerged path drivers/acpi/acpica/exregion.c
diff --git a/drivers/acpi/acpica/exresnte.c b/drivers/acpi/acpica/exresnte.c
index acd34f599313..b38e0e6291fa 100644
--- a/drivers/acpi/acpica/exresnte.c
+++ b/drivers/acpi/acpica/exresnte.c
@@ -112,7 +112,7 @@ acpi_ex_resolve_node_to_value(struct acpi_namespace_node **object_ptr,
 
 	/*
 	 * Several object types require no further processing:
-	 * 1) Device/Thermal objects don't have a "real" subobject, return the Node
+	 * 1) Device/Thermal objects don't have a "real" subobject, return Node
 	 * 2) Method locals and arguments have a pseudo-Node
 	 * 3) 10/2007: Added method type to assist with Package construction.
 	 */
diff --git a/drivers/acpi/acpica/exresolv.c b/drivers/acpi/acpica/exresolv.c
index ac04278ad28f..50f3fcbba698 100644
--- a/drivers/acpi/acpica/exresolv.c
+++ b/drivers/acpi/acpica/exresolv.c
@@ -218,7 +218,8 @@ acpi_ex_resolve_object_to_value(union acpi_operand_object **stack_ptr,
 					 * the package, can't dereference it
 					 */
 					ACPI_ERROR((AE_INFO,
-						    "Attempt to dereference an Index to NULL package element Idx=%p",
+						    "Attempt to dereference an Index to "
+						    "NULL package element Idx=%p",
 						    stack_desc));
 					status = AE_AML_UNINITIALIZED_ELEMENT;
 				}
@@ -363,10 +364,9 @@ acpi_ex_resolve_multiple(struct acpi_walk_state *walk_state,
 
 		if (type == ACPI_TYPE_LOCAL_ALIAS) {
 			type = ((struct acpi_namespace_node *)obj_desc)->type;
-			obj_desc =
-			    acpi_ns_get_attached_object((struct
-							 acpi_namespace_node *)
-							obj_desc);
+			obj_desc = acpi_ns_get_attached_object((struct
+								acpi_namespace_node
+								*)obj_desc);
 		}
 		break;
 
diff --git a/drivers/acpi/acpica/exresop.c b/drivers/acpi/acpica/exresop.c
index 00e5af7129c1..5353a23eb732 100644
--- a/drivers/acpi/acpica/exresop.c
+++ b/drivers/acpi/acpica/exresop.c
@@ -90,8 +90,8 @@ acpi_ex_check_object_type(acpi_object_type type_needed,
 		 * specification, a store to a constant is a noop.)
 		 */
 		if ((this_type == ACPI_TYPE_INTEGER) &&
-		    (((union acpi_operand_object *)object)->common.
-		     flags & AOPOBJ_AML_CONSTANT)) {
+		    (((union acpi_operand_object *)object)->common.flags &
+		     AOPOBJ_AML_CONSTANT)) {
 			return (AE_OK);
 		}
 	}
@@ -196,10 +196,10 @@ acpi_ex_resolve_operands(u16 opcode,
 			 * thus, the attached object is always the aliased namespace node
 			 */
 			if (object_type == ACPI_TYPE_LOCAL_ALIAS) {
-				obj_desc =
-				    acpi_ns_get_attached_object((struct
-								 acpi_namespace_node
-								 *)obj_desc);
+				obj_desc = acpi_ns_get_attached_object((struct
+									acpi_namespace_node
+									*)
+								       obj_desc);
 				*stack_ptr = obj_desc;
 				object_type =
 				    ((struct acpi_namespace_node *)obj_desc)->
@@ -285,8 +285,8 @@ acpi_ex_resolve_operands(u16 opcode,
 		case ARGI_REF_OR_STRING:	/* Can be a String or Reference */
 
 			if ((ACPI_GET_DESCRIPTOR_TYPE(obj_desc) ==
-			     ACPI_DESC_TYPE_OPERAND)
-			    && (obj_desc->common.type == ACPI_TYPE_STRING)) {
+			     ACPI_DESC_TYPE_OPERAND) &&
+			    (obj_desc->common.type == ACPI_TYPE_STRING)) {
 				/*
 				 * String found - the string references a named object and
 				 * must be resolved to a node
@@ -463,8 +463,9 @@ acpi_ex_resolve_operands(u16 opcode,
 			 * But we can implicitly convert from a BUFFER or INTEGER
 			 * aka - "Implicit Source Operand Conversion"
 			 */
-			status = acpi_ex_convert_to_string(obj_desc, stack_ptr,
-							   ACPI_IMPLICIT_CONVERT_HEX);
+			status =
+			    acpi_ex_convert_to_string(obj_desc, stack_ptr,
+						      ACPI_IMPLICIT_CONVERT_HEX);
 			if (ACPI_FAILURE(status)) {
 				if (status == AE_TYPE) {
 					ACPI_ERROR((AE_INFO,
@@ -595,8 +596,10 @@ acpi_ex_resolve_operands(u16 opcode,
 
 		case ARGI_REGION_OR_BUFFER:	/* Used by Load() only */
 
-			/* Need an operand of type REGION or a BUFFER (which could be a resolved region field) */
-
+			/*
+			 * Need an operand of type REGION or a BUFFER
+			 * (which could be a resolved region field)
+			 */
 			switch (obj_desc->common.type) {
 			case ACPI_TYPE_BUFFER:
 			case ACPI_TYPE_REGION:
@@ -638,9 +641,9 @@ acpi_ex_resolve_operands(u16 opcode,
 
 				if (acpi_gbl_enable_interpreter_slack) {
 					/*
-					 * Enable original behavior of Store(), allowing any and all
-					 * objects as the source operand. The ACPI spec does not
-					 * allow this, however.
+					 * Enable original behavior of Store(), allowing any
+					 * and all objects as the source operand. The ACPI
+					 * spec does not allow this, however.
 					 */
 					break;
 				}
@@ -653,7 +656,8 @@ acpi_ex_resolve_operands(u16 opcode,
 				}
 
 				ACPI_ERROR((AE_INFO,
-					    "Needed Integer/Buffer/String/Package/Ref/Ddb], found [%s] %p",
+					    "Needed Integer/Buffer/String/Package/Ref/Ddb]"
+					    ", found [%s] %p",
 					    acpi_ut_get_object_type_name
 					    (obj_desc), obj_desc));
 
@@ -676,9 +680,10 @@ acpi_ex_resolve_operands(u16 opcode,
 		 * Make sure that the original object was resolved to the
 		 * required object type (Simple cases only).
 		 */
-		status = acpi_ex_check_object_type(type_needed,
-						   (*stack_ptr)->common.type,
-						   *stack_ptr);
+		status =
+		    acpi_ex_check_object_type(type_needed,
+					      (*stack_ptr)->common.type,
+					      *stack_ptr);
 		if (ACPI_FAILURE(status)) {
 			return_ACPI_STATUS(status);
 		}
* Unmerged path drivers/acpi/acpica/exstore.c
diff --git a/drivers/acpi/acpica/exstorob.c b/drivers/acpi/acpica/exstorob.c
index 26e371073b1a..7a1a234f8921 100644
--- a/drivers/acpi/acpica/exstorob.c
+++ b/drivers/acpi/acpica/exstorob.c
@@ -1,6 +1,6 @@
 /******************************************************************************
  *
- * Module Name: exstorob - AML Interpreter object store support, store to object
+ * Module Name: exstorob - AML object store support, store to object
  *
  *****************************************************************************/
 
@@ -203,8 +203,9 @@ acpi_ex_store_string_to_string(union acpi_operand_object *source_desc,
 			ACPI_FREE(target_desc->string.pointer);
 		}
 
-		target_desc->string.pointer = ACPI_ALLOCATE_ZEROED((acpi_size)
-								   length + 1);
+		target_desc->string.pointer =
+		    ACPI_ALLOCATE_ZEROED((acpi_size) length + 1);
+
 		if (!target_desc->string.pointer) {
 			return_ACPI_STATUS(AE_NO_MEMORY);
 		}
* Unmerged path drivers/acpi/acpica/exsystem.c
diff --git a/drivers/acpi/acpica/exutils.c b/drivers/acpi/acpica/exutils.c
index 99dc7b287d55..70482fb189cf 100644
--- a/drivers/acpi/acpica/exutils.c
+++ b/drivers/acpi/acpica/exutils.c
@@ -227,8 +227,8 @@ u8 acpi_ex_truncate_for32bit_table(union acpi_operand_object *obj_desc)
 	if ((acpi_gbl_integer_byte_width == 4) &&
 	    (obj_desc->integer.value > (u64)ACPI_UINT32_MAX)) {
 		/*
-		 * We are executing in a 32-bit ACPI table.
-		 * Truncate the value to 32 bits by zeroing out the upper 32-bit field
+		 * We are executing in a 32-bit ACPI table. Truncate
+		 * the value to 32 bits by zeroing out the upper 32-bit field
 		 */
 		obj_desc->integer.value &= (u64)ACPI_UINT32_MAX;
 		return (TRUE);
@@ -383,7 +383,8 @@ void acpi_ex_eisa_id_to_string(char *out_string, u64 compressed_id)
 
 	if (compressed_id > ACPI_UINT32_MAX) {
 		ACPI_WARNING((AE_INFO,
-			      "Expected EISAID is larger than 32 bits: 0x%8.8X%8.8X, truncating",
+			      "Expected EISAID is larger than 32 bits: "
+			      "0x%8.8X%8.8X, truncating",
 			      ACPI_FORMAT_UINT64(compressed_id)));
 	}
 
diff --git a/drivers/acpi/acpica/hwesleep.c b/drivers/acpi/acpica/hwesleep.c
index 414076818d40..1fc9f6b20df2 100644
--- a/drivers/acpi/acpica/hwesleep.c
+++ b/drivers/acpi/acpica/hwesleep.c
@@ -117,8 +117,8 @@ acpi_status acpi_hw_extended_sleep(u8 sleep_state)
 
 	/* Clear wake status (WAK_STS) */
 
-	status =
-	    acpi_write((u64)ACPI_X_WAKE_STATUS, &acpi_gbl_FADT.sleep_status);
+	status = acpi_write((u64)ACPI_X_WAKE_STATUS,
+			    &acpi_gbl_FADT.sleep_status);
 	if (ACPI_FAILURE(status)) {
 		return_ACPI_STATUS(status);
 	}
* Unmerged path drivers/acpi/acpica/hwgpe.c
diff --git a/drivers/acpi/acpica/hwsleep.c b/drivers/acpi/acpica/hwsleep.c
index e3828cc4361b..aaeeaf0eb3e0 100644
--- a/drivers/acpi/acpica/hwsleep.c
+++ b/drivers/acpi/acpica/hwsleep.c
@@ -80,8 +80,8 @@ acpi_status acpi_hw_legacy_sleep(u8 sleep_state)
 
 	/* Clear wake status */
 
-	status =
-	    acpi_write_bit_register(ACPI_BITREG_WAKE_STATUS, ACPI_CLEAR_STATUS);
+	status = acpi_write_bit_register(ACPI_BITREG_WAKE_STATUS,
+					 ACPI_CLEAR_STATUS);
 	if (ACPI_FAILURE(status)) {
 		return_ACPI_STATUS(status);
 	}
diff --git a/drivers/acpi/acpica/hwxfsleep.c b/drivers/acpi/acpica/hwxfsleep.c
index 15dddc10fc9b..f060f2f9d708 100644
--- a/drivers/acpi/acpica/hwxfsleep.c
+++ b/drivers/acpi/acpica/hwxfsleep.c
@@ -214,6 +214,7 @@ acpi_status acpi_enter_sleep_state_s4bios(void)
 		if (ACPI_FAILURE(status)) {
 			return_ACPI_STATUS(status);
 		}
+
 	} while (!in_value);
 
 	return_ACPI_STATUS(AE_OK);
diff --git a/drivers/acpi/acpica/nsconvert.c b/drivers/acpi/acpica/nsconvert.c
index acd2964c2690..fa2958689b6a 100644
--- a/drivers/acpi/acpica/nsconvert.c
+++ b/drivers/acpi/acpica/nsconvert.c
@@ -96,9 +96,9 @@ acpi_ns_convert_to_integer(union acpi_operand_object *original_object,
 		/* Extract each buffer byte to create the integer */
 
 		for (i = 0; i < original_object->buffer.length; i++) {
-			value |=
-			    ((u64)original_object->buffer.
-			     pointer[i] << (i * 8));
+			value |= ((u64)
+				  original_object->buffer.pointer[i] << (i *
+									 8));
 		}
 		break;
 
@@ -153,10 +153,9 @@ acpi_ns_convert_to_string(union acpi_operand_object *original_object,
 				return (AE_NO_MEMORY);
 			}
 		} else {
-			status =
-			    acpi_ex_convert_to_string(original_object,
-						      &new_object,
-						      ACPI_IMPLICIT_CONVERT_HEX);
+			status = acpi_ex_convert_to_string(original_object,
+							   &new_object,
+							   ACPI_IMPLICIT_CONVERT_HEX);
 			if (ACPI_FAILURE(status)) {
 				return (status);
 			}
@@ -244,9 +243,8 @@ acpi_ns_convert_to_buffer(union acpi_operand_object *original_object,
 
 		/* String-to-Buffer conversion. Simple data copy */
 
-		new_object =
-		    acpi_ut_create_buffer_object(original_object->string.
-						 length);
+		new_object = acpi_ut_create_buffer_object
+		    (original_object->string.length);
 		if (!new_object) {
 			return (AE_NO_MEMORY);
 		}
diff --git a/drivers/acpi/acpica/nsdump.c b/drivers/acpi/acpica/nsdump.c
index 7418c77fde8c..bbb5d74cc340 100644
--- a/drivers/acpi/acpica/nsdump.c
+++ b/drivers/acpi/acpica/nsdump.c
@@ -530,11 +530,13 @@ acpi_ns_dump_one_object(acpi_handle obj_handle,
 				acpi_os_printf
 				    ("(Pointer to ACPI Object type %.2X [UNKNOWN])\n",
 				     obj_type);
+
 				bytes_to_dump = 32;
 			} else {
 				acpi_os_printf
 				    ("(Pointer to ACPI Object type %.2X [%s])\n",
 				     obj_type, acpi_ut_get_type_name(obj_type));
+
 				bytes_to_dump =
 				    sizeof(union acpi_operand_object);
 			}
@@ -564,6 +566,7 @@ acpi_ns_dump_one_object(acpi_handle obj_handle,
 			 */
 			bytes_to_dump = obj_desc->string.length;
 			obj_desc = (void *)obj_desc->string.pointer;
+
 			acpi_os_printf("(Buffer/String pointer %p length %X)\n",
 				       obj_desc, bytes_to_dump);
 			ACPI_DUMP_BUFFER(obj_desc, bytes_to_dump);
diff --git a/drivers/acpi/acpica/nsload.c b/drivers/acpi/acpica/nsload.c
index 0a7badc3179f..82b56e55e51c 100644
--- a/drivers/acpi/acpica/nsload.c
+++ b/drivers/acpi/acpica/nsload.c
@@ -307,7 +307,6 @@ acpi_status acpi_ns_unload_namespace(acpi_handle handle)
 	/* This function does the real work */
 
 	status = acpi_ns_delete_subtree(handle);
-
 	return_ACPI_STATUS(status);
 }
 #endif
* Unmerged path drivers/acpi/acpica/nsnames.c
diff --git a/drivers/acpi/acpica/nsparse.c b/drivers/acpi/acpica/nsparse.c
index 35dde8151c0d..07822c4cc8f5 100644
--- a/drivers/acpi/acpica/nsparse.c
+++ b/drivers/acpi/acpica/nsparse.c
@@ -136,8 +136,8 @@ acpi_ns_one_complete_parse(u32 pass_number,
 
 	/* Parse the AML */
 
-	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "*PARSE* pass %u parse\n",
-			  pass_number));
+	ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
+			  "*PARSE* pass %u parse\n", pass_number));
 	status = acpi_ps_parse_aml(walk_state);
 
       cleanup:
@@ -176,6 +176,7 @@ acpi_ns_parse_table(u32 table_index, struct acpi_namespace_node *start_node)
 	 * performs another complete parse of the AML.
 	 */
 	ACPI_DEBUG_PRINT((ACPI_DB_PARSE, "**** Start pass 1\n"));
+
 	status = acpi_ns_one_complete_parse(ACPI_IMODE_LOAD_PASS1,
 					    table_index, start_node);
 	if (ACPI_FAILURE(status)) {
diff --git a/drivers/acpi/acpica/nsprepkg.c b/drivers/acpi/acpica/nsprepkg.c
index 6d55cef7916c..781c43486c49 100644
--- a/drivers/acpi/acpica/nsprepkg.c
+++ b/drivers/acpi/acpica/nsprepkg.c
@@ -233,8 +233,9 @@ acpi_ns_check_package(struct acpi_evaluate_info *info,
 
 		/* First element is the (Integer) revision */
 
-		status = acpi_ns_check_object_type(info, elements,
-						   ACPI_RTYPE_INTEGER, 0);
+		status =
+		    acpi_ns_check_object_type(info, elements,
+					      ACPI_RTYPE_INTEGER, 0);
 		if (ACPI_FAILURE(status)) {
 			return (status);
 		}
@@ -252,8 +253,9 @@ acpi_ns_check_package(struct acpi_evaluate_info *info,
 
 		/* First element is the (Integer) count of sub-packages to follow */
 
-		status = acpi_ns_check_object_type(info, elements,
-						   ACPI_RTYPE_INTEGER, 0);
+		status =
+		    acpi_ns_check_object_type(info, elements,
+					      ACPI_RTYPE_INTEGER, 0);
 		if (ACPI_FAILURE(status)) {
 			return (status);
 		}
diff --git a/drivers/acpi/acpica/nsrepair.c b/drivers/acpi/acpica/nsrepair.c
index f8e71ea60319..2e0b402ce44a 100644
--- a/drivers/acpi/acpica/nsrepair.c
+++ b/drivers/acpi/acpica/nsrepair.c
@@ -349,6 +349,7 @@ static const struct acpi_simple_repair_info *acpi_ns_match_simple_repair(struct
 
 			return (NULL);
 		}
+
 		this_name++;
 	}
 
@@ -504,6 +505,7 @@ acpi_ns_remove_null_elements(struct acpi_evaluate_info *info,
 			*dest = *source;
 			dest++;
 		}
+
 		source++;
 	}
 
@@ -555,8 +557,8 @@ acpi_ns_wrap_with_package(struct acpi_evaluate_info *info,
 	ACPI_FUNCTION_NAME(ns_wrap_with_package);
 
 	/*
-	 * Create the new outer package and populate it. The new package will
-	 * have a single element, the lone sub-object.
+	 * Create the new outer package and populate it. The new
+	 * package will have a single element, the lone sub-object.
 	 */
 	pkg_obj_desc = acpi_ut_create_package_object(1);
 	if (!pkg_obj_desc) {
* Unmerged path drivers/acpi/acpica/nsrepair2.c
diff --git a/drivers/acpi/acpica/nsutils.c b/drivers/acpi/acpica/nsutils.c
index 08c0b5beec88..e9d0b328b3c6 100644
--- a/drivers/acpi/acpica/nsutils.c
+++ b/drivers/acpi/acpica/nsutils.c
@@ -173,9 +173,10 @@ void acpi_ns_get_internal_name_length(struct acpi_namestring_info *info)
 	info->fully_qualified = FALSE;
 
 	/*
-	 * For the internal name, the required length is 4 bytes per segment, plus
-	 * 1 each for root_prefix, multi_name_prefix_op, segment count, trailing null
-	 * (which is not really needed, but no there's harm in putting it there)
+	 * For the internal name, the required length is 4 bytes per segment,
+	 * plus 1 each for root_prefix, multi_name_prefix_op, segment count,
+	 * trailing null (which is not really needed, but no there's harm in
+	 * putting it there)
 	 *
 	 * strlen() + 1 covers the first name_seg, which has no path separator
 	 */
@@ -681,6 +682,7 @@ acpi_ns_get_node(struct acpi_namespace_node *prefix_node,
 		if (!prefix_node) {
 			*return_node = acpi_gbl_root_node;
 		}
+
 		return_ACPI_STATUS(AE_OK);
 	}
 
diff --git a/drivers/acpi/acpica/nsxfeval.c b/drivers/acpi/acpica/nsxfeval.c
index 3a5bd348ba8d..e6122bc087e2 100644
--- a/drivers/acpi/acpica/nsxfeval.c
+++ b/drivers/acpi/acpica/nsxfeval.c
@@ -740,8 +740,8 @@ acpi_ns_get_device_callback(acpi_handle obj_handle,
 
 	/* We have a valid device, invoke the user function */
 
-	status = info->user_function(obj_handle, nesting_level, info->context,
-				     return_value);
+	status = info->user_function(obj_handle, nesting_level,
+				     info->context, return_value);
 	return (status);
 }
 
diff --git a/drivers/acpi/acpica/nsxfname.c b/drivers/acpi/acpica/nsxfname.c
index c86094fcab7b..8d8cdb283f0e 100644
--- a/drivers/acpi/acpica/nsxfname.c
+++ b/drivers/acpi/acpica/nsxfname.c
@@ -563,6 +563,7 @@ acpi_status acpi_install_method(u8 *buffer)
 	parser_state.aml += acpi_ps_get_opcode_size(opcode);
 	parser_state.pkg_end = acpi_ps_get_next_package_end(&parser_state);
 	path = acpi_ps_get_next_namestring(&parser_state);
+
 	method_flags = *parser_state.aml++;
 	aml_start = parser_state.aml;
 	aml_length = ACPI_PTR_DIFF(parser_state.pkg_end, aml_start);
diff --git a/drivers/acpi/acpica/nsxfobj.c b/drivers/acpi/acpica/nsxfobj.c
index 94e961cf6294..63a45831d72f 100644
--- a/drivers/acpi/acpica/nsxfobj.c
+++ b/drivers/acpi/acpica/nsxfobj.c
@@ -118,10 +118,8 @@ acpi_status acpi_get_type(acpi_handle handle, acpi_object_type * ret_type)
 		return (AE_BAD_PARAMETER);
 	}
 
-	/*
-	 * Special case for the predefined Root Node
-	 * (return type ANY)
-	 */
+	/* Special case for the predefined Root Node (return type ANY) */
+
 	if (handle == ACPI_ROOT_OBJECT) {
 		*ret_type = ACPI_TYPE_ANY;
 		return (AE_OK);
diff --git a/drivers/acpi/acpica/psargs.c b/drivers/acpi/acpica/psargs.c
index 91a5a69db80c..d2961e6f3ba7 100644
--- a/drivers/acpi/acpica/psargs.c
+++ b/drivers/acpi/acpica/psargs.c
@@ -734,6 +734,7 @@ acpi_ps_get_next_arg(struct acpi_walk_state *walk_state,
 		if (!arg) {
 			return_ACPI_STATUS(AE_NO_MEMORY);
 		}
+
 		acpi_ps_get_next_simple_arg(parser_state, arg_type, arg);
 		break;
 
* Unmerged path drivers/acpi/acpica/psloop.c
diff --git a/drivers/acpi/acpica/psparse.c b/drivers/acpi/acpica/psparse.c
index 86198a9139b5..e2e4daa6ec01 100644
--- a/drivers/acpi/acpica/psparse.c
+++ b/drivers/acpi/acpica/psparse.c
@@ -520,8 +520,8 @@ acpi_status acpi_ps_parse_aml(struct acpi_walk_state *walk_state)
 			}
 
 			/*
-			 * If the transfer to the new method method call worked, a new walk
-			 * state was created -- get it
+			 * If the transfer to the new method method call worked
+			 *, a new walk state was created -- get it
 			 */
 			walk_state = acpi_ds_get_current_walk_state(thread);
 			continue;
@@ -538,8 +538,8 @@ acpi_status acpi_ps_parse_aml(struct acpi_walk_state *walk_state)
 			/* Check for possible multi-thread reentrancy problem */
 
 			if ((status == AE_ALREADY_EXISTS) &&
-			    (!(walk_state->method_desc->method.
-			       info_flags & ACPI_METHOD_SERIALIZED))) {
+			    (!(walk_state->method_desc->method.info_flags &
+			       ACPI_METHOD_SERIALIZED))) {
 				/*
 				 * Method is not serialized and tried to create an object
 				 * twice. The probable cause is that the method cannot
diff --git a/drivers/acpi/acpica/psutils.c b/drivers/acpi/acpica/psutils.c
index 91fa73a6e55e..38cbeb20519e 100644
--- a/drivers/acpi/acpica/psutils.c
+++ b/drivers/acpi/acpica/psutils.c
@@ -174,8 +174,8 @@ void acpi_ps_free_op(union acpi_parse_object *op)
 	ACPI_FUNCTION_NAME(ps_free_op);
 
 	if (op->common.aml_opcode == AML_INT_RETURN_VALUE_OP) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, "Free retval op: %p\n",
-				  op));
+		ACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS,
+				  "Free retval op: %p\n", op));
 	}
 
 	if (op->common.flags & ACPI_PARSEOP_GENERIC) {
diff --git a/drivers/acpi/acpica/pswalk.c b/drivers/acpi/acpica/pswalk.c
index abd65624754f..42f5317463c3 100644
--- a/drivers/acpi/acpica/pswalk.c
+++ b/drivers/acpi/acpica/pswalk.c
@@ -99,6 +99,7 @@ void acpi_ps_delete_parse_tree(union acpi_parse_object *subtree_root)
 		if (op == subtree_root) {
 			return_VOID;
 		}
+
 		if (next) {
 			op = next;
 		} else {
diff --git a/drivers/acpi/acpica/rsaddr.c b/drivers/acpi/acpica/rsaddr.c
index 94116d19b81d..c432d481d77a 100644
--- a/drivers/acpi/acpica/rsaddr.c
+++ b/drivers/acpi/acpica/rsaddr.c
@@ -312,8 +312,8 @@ acpi_rs_get_address_common(struct acpi_resource *resource,
 
 	/* Validate the Resource Type */
 
-	if ((aml->address.resource_type > 2)
-	    && (aml->address.resource_type < 0xC0)) {
+	if ((aml->address.resource_type > 2) &&
+	    (aml->address.resource_type < 0xC0)) {
 		return (FALSE);
 	}
 
diff --git a/drivers/acpi/acpica/rscalc.c b/drivers/acpi/acpica/rscalc.c
index b62a0f4f4f9b..40a2aaa98212 100644
--- a/drivers/acpi/acpica/rscalc.c
+++ b/drivers/acpi/acpica/rscalc.c
@@ -143,16 +143,17 @@ acpi_rs_stream_option_length(u32 resource_length,
 	ACPI_FUNCTION_ENTRY();
 
 	/*
-	 * The resource_source_index and resource_source are optional elements of some
-	 * Large-type resource descriptors.
+	 * The resource_source_index and resource_source are optional elements of
+	 * some Large-type resource descriptors.
 	 */
 
 	/*
-	 * If the length of the actual resource descriptor is greater than the ACPI
-	 * spec-defined minimum length, it means that a resource_source_index exists
-	 * and is followed by a (required) null terminated string. The string length
-	 * (including the null terminator) is the resource length minus the minimum
-	 * length, minus one byte for the resource_source_index itself.
+	 * If the length of the actual resource descriptor is greater than the
+	 * ACPI spec-defined minimum length, it means that a resource_source_index
+	 * exists and is followed by a (required) null terminated string. The
+	 * string length (including the null terminator) is the resource length
+	 * minus the minimum length, minus one byte for the resource_source_index
+	 * itself.
 	 */
 	if (resource_length > minimum_aml_resource_length) {
 
@@ -272,11 +273,11 @@ acpi_rs_get_aml_length(struct acpi_resource * resource, acpi_size * size_needed)
 			 * 16-Bit Address Resource:
 			 * Add the size of the optional resource_source info
 			 */
-			total_size = (acpi_rs_length)
-			    (total_size +
-			     acpi_rs_struct_option_length(&resource->data.
-							  address16.
-							  resource_source));
+			total_size = (acpi_rs_length) (total_size +
+						       acpi_rs_struct_option_length
+						       (&resource->data.
+							address16.
+							resource_source));
 			break;
 
 		case ACPI_RESOURCE_TYPE_ADDRESS32:
@@ -284,11 +285,11 @@ acpi_rs_get_aml_length(struct acpi_resource * resource, acpi_size * size_needed)
 			 * 32-Bit Address Resource:
 			 * Add the size of the optional resource_source info
 			 */
-			total_size = (acpi_rs_length)
-			    (total_size +
-			     acpi_rs_struct_option_length(&resource->data.
-							  address32.
-							  resource_source));
+			total_size = (acpi_rs_length) (total_size +
+						       acpi_rs_struct_option_length
+						       (&resource->data.
+							address32.
+							resource_source));
 			break;
 
 		case ACPI_RESOURCE_TYPE_ADDRESS64:
@@ -296,11 +297,11 @@ acpi_rs_get_aml_length(struct acpi_resource * resource, acpi_size * size_needed)
 			 * 64-Bit Address Resource:
 			 * Add the size of the optional resource_source info
 			 */
-			total_size = (acpi_rs_length)
-			    (total_size +
-			     acpi_rs_struct_option_length(&resource->data.
-							  address64.
-							  resource_source));
+			total_size = (acpi_rs_length) (total_size +
+						       acpi_rs_struct_option_length
+						       (&resource->data.
+							address64.
+							resource_source));
 			break;
 
 		case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:
@@ -309,26 +310,28 @@ acpi_rs_get_aml_length(struct acpi_resource * resource, acpi_size * size_needed)
 			 * Add the size of each additional optional interrupt beyond the
 			 * required 1 (4 bytes for each u32 interrupt number)
 			 */
-			total_size = (acpi_rs_length)
-			    (total_size +
-			     ((resource->data.extended_irq.interrupt_count -
-			       1) * 4) +
-			     /* Add the size of the optional resource_source info */
-			     acpi_rs_struct_option_length(&resource->data.
-							  extended_irq.
-							  resource_source));
+			total_size = (acpi_rs_length) (total_size +
+						       ((resource->data.
+							 extended_irq.
+							 interrupt_count -
+							 1) * 4) +
+						       /* Add the size of the optional resource_source info */
+						       acpi_rs_struct_option_length
+						       (&resource->data.
+							extended_irq.
+							resource_source));
 			break;
 
 		case ACPI_RESOURCE_TYPE_GPIO:
 
-			total_size =
-			    (acpi_rs_length) (total_size +
-					      (resource->data.gpio.
-					       pin_table_length * 2) +
-					      resource->data.gpio.
-					      resource_source.string_length +
-					      resource->data.gpio.
-					      vendor_length);
+			total_size = (acpi_rs_length) (total_size +
+						       (resource->data.gpio.
+							pin_table_length * 2) +
+						       resource->data.gpio.
+						       resource_source.
+						       string_length +
+						       resource->data.gpio.
+						       vendor_length);
 
 			break;
 
@@ -561,8 +564,8 @@ acpi_rs_get_list_length(u8 * aml_buffer,
 			    acpi_gbl_resource_struct_sizes[resource_index] +
 			    extra_struct_bytes;
 		}
-		buffer_size = (u32)ACPI_ROUND_UP_TO_NATIVE_WORD(buffer_size);
 
+		buffer_size = (u32)ACPI_ROUND_UP_TO_NATIVE_WORD(buffer_size);
 		*size_needed += buffer_size;
 
 		ACPI_DEBUG_PRINT((ACPI_DB_RESOURCES,
* Unmerged path drivers/acpi/acpica/rscreate.c
diff --git a/drivers/acpi/acpica/rsdump.c b/drivers/acpi/acpica/rsdump.c
index 8a2d4986b0aa..f3154e4c7777 100644
--- a/drivers/acpi/acpica/rsdump.c
+++ b/drivers/acpi/acpica/rsdump.c
@@ -480,6 +480,7 @@ void acpi_rs_dump_irq_list(u8 * route_table)
 
 static void acpi_rs_out_string(char *title, char *value)
 {
+
 	acpi_os_printf("%27s : %s", title, value);
 	if (!*value) {
 		acpi_os_printf("[NULL NAMESTRING]");
@@ -494,21 +495,25 @@ static void acpi_rs_out_integer8(char *title, u8 value)
 
 static void acpi_rs_out_integer16(char *title, u16 value)
 {
+
 	acpi_os_printf("%27s : %4.4X\n", title, value);
 }
 
 static void acpi_rs_out_integer32(char *title, u32 value)
 {
+
 	acpi_os_printf("%27s : %8.8X\n", title, value);
 }
 
 static void acpi_rs_out_integer64(char *title, u64 value)
 {
+
 	acpi_os_printf("%27s : %8.8X%8.8X\n", title, ACPI_FORMAT_UINT64(value));
 }
 
 static void acpi_rs_out_title(char *title)
 {
+
 	acpi_os_printf("%27s : ", title);
 }
 
@@ -541,6 +546,7 @@ static void acpi_rs_dump_short_byte_list(u8 length, u8 * data)
 	for (i = 0; i < length; i++) {
 		acpi_os_printf("%X ", data[i]);
 	}
+
 	acpi_os_printf("\n");
 }
 
diff --git a/drivers/acpi/acpica/rslist.c b/drivers/acpi/acpica/rslist.c
index 6053aa182093..976a485a50dd 100644
--- a/drivers/acpi/acpica/rslist.c
+++ b/drivers/acpi/acpica/rslist.c
@@ -89,6 +89,7 @@ acpi_rs_convert_aml_to_resources(u8 * aml,
 	/* Get the appropriate conversion info table */
 
 	aml_resource = ACPI_CAST_PTR(union aml_resource, aml);
+
 	if (acpi_ut_get_resource_type(aml) == ACPI_RESOURCE_NAME_SERIAL_BUS) {
 		if (aml_resource->common_serial_bus.type >
 		    AML_RESOURCE_MAX_SERIALBUSTYPE) {
@@ -225,10 +226,10 @@ acpi_rs_convert_resources_to_aml(struct acpi_resource *resource,
 
 		/* Perform final sanity check on the new AML resource descriptor */
 
-		status = acpi_ut_validate_resource(NULL,
-						   ACPI_CAST_PTR(union
-								 aml_resource,
-								 aml), NULL);
+		status =
+		    acpi_ut_validate_resource(NULL,
+					      ACPI_CAST_PTR(union aml_resource,
+							    aml), NULL);
 		if (ACPI_FAILURE(status)) {
 			return_ACPI_STATUS(status);
 		}
* Unmerged path drivers/acpi/acpica/rsmisc.c
* Unmerged path drivers/acpi/acpica/rsutils.c
diff --git a/drivers/acpi/acpica/rsxface.c b/drivers/acpi/acpica/rsxface.c
index f4dfbbe9af94..728772eaac8b 100644
--- a/drivers/acpi/acpica/rsxface.c
+++ b/drivers/acpi/acpica/rsxface.c
@@ -53,7 +53,7 @@ ACPI_MODULE_NAME("rsxface")
 
 /* Local macros for 16,32-bit to 64-bit conversion */
 #define ACPI_COPY_FIELD(out, in, field)  ((out)->field = (in)->field)
-#define ACPI_COPY_ADDRESS(out, in)                      \
+#define ACPI_COPY_ADDRESS(out, in)                       \
 	ACPI_COPY_FIELD(out, in, resource_type);             \
 	ACPI_COPY_FIELD(out, in, producer_consumer);         \
 	ACPI_COPY_FIELD(out, in, decode);                    \
* Unmerged path drivers/acpi/acpica/tbdata.c
* Unmerged path drivers/acpi/acpica/tbinstal.c
diff --git a/drivers/acpi/acpica/tbprint.c b/drivers/acpi/acpica/tbprint.c
index dc963f823d2c..62b56ed68d48 100644
--- a/drivers/acpi/acpica/tbprint.c
+++ b/drivers/acpi/acpica/tbprint.c
@@ -76,6 +76,7 @@ static void acpi_tb_fix_string(char *string, acpi_size length)
 		if (!ACPI_IS_PRINT(*string)) {
 			*string = '?';
 		}
+
 		string++;
 		length--;
 	}
* Unmerged path drivers/acpi/acpica/tbutils.c
* Unmerged path drivers/acpi/acpica/tbxfload.c
diff --git a/drivers/acpi/acpica/utcopy.c b/drivers/acpi/acpica/utcopy.c
index 1731c27c36a6..d5064a4f4f5f 100644
--- a/drivers/acpi/acpica/utcopy.c
+++ b/drivers/acpi/acpica/utcopy.c
@@ -257,9 +257,9 @@ acpi_ut_copy_ielement_to_eelement(u8 object_type,
 	ACPI_FUNCTION_ENTRY();
 
 	this_index = state->pkg.index;
-	target_object = (union acpi_object *)
-	    &((union acpi_object *)(state->pkg.dest_object))->package.
-	    elements[this_index];
+	target_object = (union acpi_object *)&((union acpi_object *)
+					       (state->pkg.dest_object))->
+	    package.elements[this_index];
 
 	switch (object_type) {
 	case ACPI_COPY_TYPE_SIMPLE:
@@ -348,15 +348,15 @@ acpi_ut_copy_ipackage_to_epackage(union acpi_operand_object *internal_object,
 	 * Free space begins right after the first package
 	 */
 	info.length = ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object));
-	info.free_space =
-	    buffer + ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object));
+	info.free_space = buffer +
+	    ACPI_ROUND_UP_TO_NATIVE_WORD(sizeof(union acpi_object));
 	info.object_space = 0;
 	info.num_packages = 1;
 
 	external_object->type = internal_object->common.type;
 	external_object->package.count = internal_object->package.count;
-	external_object->package.elements = ACPI_CAST_PTR(union acpi_object,
-							  info.free_space);
+	external_object->package.elements =
+	    ACPI_CAST_PTR(union acpi_object, info.free_space);
 
 	/*
 	 * Leave room for an array of ACPI_OBJECTS in the buffer
@@ -593,8 +593,8 @@ acpi_ut_copy_epackage_to_ipackage(union acpi_object *external_object,
 	package_elements = package_object->package.elements;
 
 	/*
-	 * Recursive implementation. Probably ok, since nested external packages
-	 * as parameters should be very rare.
+	 * Recursive implementation. Probably ok, since nested external
+	 * packages as parameters should be very rare.
 	 */
 	for (i = 0; i < external_object->package.count; i++) {
 		status =
@@ -649,9 +649,8 @@ acpi_ut_copy_eobject_to_iobject(union acpi_object *external_object,
 		/*
 		 * Build a simple object (no nested objects)
 		 */
-		status =
-		    acpi_ut_copy_esimple_to_isimple(external_object,
-						    internal_object);
+		status = acpi_ut_copy_esimple_to_isimple(external_object,
+							 internal_object);
 	}
 
 	return_ACPI_STATUS(status);
diff --git a/drivers/acpi/acpica/utdecode.c b/drivers/acpi/acpica/utdecode.c
index 0953cab627a0..487d913e8aa2 100644
--- a/drivers/acpi/acpica/utdecode.c
+++ b/drivers/acpi/acpica/utdecode.c
@@ -207,7 +207,8 @@ char *acpi_ut_get_event_name(u32 event_id)
  *
  * The type ACPI_TYPE_ANY (Untyped) is used as a "don't care" when searching;
  * when stored in a table it really means that we have thus far seen no
- * evidence to indicate what type is actually going to be stored for this entry.
+ * evidence to indicate what type is actually going to be stored for this
+ & entry.
  */
 static const char acpi_gbl_bad_type[] = "UNDEFINED";
 
* Unmerged path drivers/acpi/acpica/utdelete.c
diff --git a/drivers/acpi/acpica/uterror.c b/drivers/acpi/acpica/uterror.c
index 154fdcaa5830..5ee0aa4d8ed8 100644
--- a/drivers/acpi/acpica/uterror.c
+++ b/drivers/acpi/acpica/uterror.c
@@ -217,8 +217,9 @@ acpi_ut_namespace_error(const char *module_name,
 	} else {
 		/* Convert path to external format */
 
-		status = acpi_ns_externalize_name(ACPI_UINT32_MAX,
-						  internal_name, NULL, &name);
+		status =
+		    acpi_ns_externalize_name(ACPI_UINT32_MAX, internal_name,
+					     NULL, &name);
 
 		/* Print target name */
 
@@ -271,9 +272,8 @@ acpi_ut_method_error(const char *module_name,
 	acpi_os_printf(ACPI_MSG_ERROR);
 
 	if (path) {
-		status =
-		    acpi_ns_get_node(prefix_node, path, ACPI_NS_NO_UPSEARCH,
-				     &node);
+		status = acpi_ns_get_node(prefix_node, path,
+					  ACPI_NS_NO_UPSEARCH, &node);
 		if (ACPI_FAILURE(status)) {
 			acpi_os_printf("[Could not get node by pathname]");
 		}
* Unmerged path drivers/acpi/acpica/utfileio.c
diff --git a/drivers/acpi/acpica/utmath.c b/drivers/acpi/acpica/utmath.c
index 909fe66e1934..e658504bf095 100644
--- a/drivers/acpi/acpica/utmath.c
+++ b/drivers/acpi/acpica/utmath.c
@@ -111,6 +111,7 @@ acpi_ut_short_divide(u64 dividend,
 	 */
 	ACPI_DIV_64_BY_32(0, dividend_ovl.part.hi, divisor,
 			  quotient.part.hi, remainder32);
+
 	ACPI_DIV_64_BY_32(remainder32, dividend_ovl.part.lo, divisor,
 			  quotient.part.lo, remainder32);
 
@@ -179,6 +180,7 @@ acpi_ut_divide(u64 in_dividend,
 		 */
 		ACPI_DIV_64_BY_32(0, dividend.part.hi, divisor.part.lo,
 				  quotient.part.hi, partial1);
+
 		ACPI_DIV_64_BY_32(partial1, dividend.part.lo, divisor.part.lo,
 				  quotient.part.lo, remainder.part.lo);
 	}
@@ -206,12 +208,12 @@ acpi_ut_divide(u64 in_dividend,
 
 		ACPI_DIV_64_BY_32(normalized_dividend.part.hi,
 				  normalized_dividend.part.lo,
-				  normalized_divisor.part.lo,
-				  quotient.part.lo, partial1);
+				  normalized_divisor.part.lo, quotient.part.lo,
+				  partial1);
 
 		/*
-		 * The quotient is always 32 bits, and simply requires adjustment.
-		 * The 64-bit remainder must be generated.
+		 * The quotient is always 32 bits, and simply requires
+		 * adjustment. The 64-bit remainder must be generated.
 		 */
 		partial1 = quotient.part.lo * divisor.part.hi;
 		partial2.full = (u64) quotient.part.lo * divisor.part.lo;
diff --git a/drivers/acpi/acpica/utmisc.c b/drivers/acpi/acpica/utmisc.c
index 02f9101b65e4..8c810f3dfe69 100644
--- a/drivers/acpi/acpica/utmisc.c
+++ b/drivers/acpi/acpica/utmisc.c
@@ -261,8 +261,8 @@ acpi_ut_walk_package_tree(union acpi_operand_object *source_object,
 		 */
 		if ((!this_source_obj) ||
 		    (ACPI_GET_DESCRIPTOR_TYPE(this_source_obj) !=
-		     ACPI_DESC_TYPE_OPERAND)
-		    || (this_source_obj->common.type != ACPI_TYPE_PACKAGE)) {
+		     ACPI_DESC_TYPE_OPERAND) ||
+		    (this_source_obj->common.type != ACPI_TYPE_PACKAGE)) {
 			status =
 			    walk_callback(ACPI_COPY_TYPE_SIMPLE,
 					  this_source_obj, state, context);
@@ -315,9 +315,10 @@ acpi_ut_walk_package_tree(union acpi_operand_object *source_object,
 			 * The callback above returned a new target package object.
 			 */
 			acpi_ut_push_generic_state(&state_list, state);
-			state = acpi_ut_create_pkg_state(this_source_obj,
-							 state->pkg.
-							 this_target_obj, 0);
+			state =
+			    acpi_ut_create_pkg_state(this_source_obj,
+						     state->pkg.this_target_obj,
+						     0);
 			if (!state) {
 
 				/* Free any stacked Update State objects */
diff --git a/drivers/acpi/acpica/utmutex.c b/drivers/acpi/acpica/utmutex.c
index 08c323245584..e412d9af4248 100644
--- a/drivers/acpi/acpica/utmutex.c
+++ b/drivers/acpi/acpica/utmutex.c
@@ -269,8 +269,9 @@ acpi_status acpi_ut_acquire_mutex(acpi_mutex_handle mutex_id)
 			  (u32)this_thread_id,
 			  acpi_ut_get_mutex_name(mutex_id)));
 
-	status = acpi_os_acquire_mutex(acpi_gbl_mutex_info[mutex_id].mutex,
-				       ACPI_WAIT_FOREVER);
+	status =
+	    acpi_os_acquire_mutex(acpi_gbl_mutex_info[mutex_id].mutex,
+				  ACPI_WAIT_FOREVER);
 	if (ACPI_SUCCESS(status)) {
 		ACPI_DEBUG_PRINT((ACPI_DB_MUTEX,
 				  "Thread %u acquired Mutex [%s]\n",
* Unmerged path drivers/acpi/acpica/utnonansi.c
* Unmerged path drivers/acpi/acpica/utobject.c
* Unmerged path drivers/acpi/acpica/utosi.c
diff --git a/drivers/acpi/acpica/utownerid.c b/drivers/acpi/acpica/utownerid.c
index 835340b26d37..4a9411e67d51 100644
--- a/drivers/acpi/acpica/utownerid.c
+++ b/drivers/acpi/acpica/utownerid.c
@@ -73,8 +73,8 @@ acpi_status acpi_ut_allocate_owner_id(acpi_owner_id * owner_id)
 	/* Guard against multiple allocations of ID to the same location */
 
 	if (*owner_id) {
-		ACPI_ERROR((AE_INFO, "Owner ID [0x%2.2X] already exists",
-			    *owner_id));
+		ACPI_ERROR((AE_INFO,
+			    "Owner ID [0x%2.2X] already exists", *owner_id));
 		return_ACPI_STATUS(AE_ALREADY_EXISTS);
 	}
 
@@ -87,8 +87,8 @@ acpi_status acpi_ut_allocate_owner_id(acpi_owner_id * owner_id)
 
 	/*
 	 * Find a free owner ID, cycle through all possible IDs on repeated
-	 * allocations. (ACPI_NUM_OWNERID_MASKS + 1) because first index may have
-	 * to be scanned twice.
+	 * allocations. (ACPI_NUM_OWNERID_MASKS + 1) because first index
+	 * may have to be scanned twice.
 	 */
 	for (i = 0, j = acpi_gbl_last_owner_id_index;
 	     i < (ACPI_NUM_OWNERID_MASKS + 1); i++, j++) {
@@ -141,8 +141,8 @@ acpi_status acpi_ut_allocate_owner_id(acpi_owner_id * owner_id)
 	 * they are released when a table is unloaded or a method completes
 	 * execution.
 	 *
-	 * If this error happens, there may be very deep nesting of invoked control
-	 * methods, or there may be a bug where the IDs are not released.
+	 * If this error happens, there may be very deep nesting of invoked
+	 * control methods, or there may be a bug where the IDs are not released.
 	 */
 	status = AE_OWNER_ID_LIMIT;
 	ACPI_ERROR((AE_INFO,
diff --git a/drivers/acpi/acpica/utpredef.c b/drivers/acpi/acpica/utpredef.c
index 2b1ce4cd3207..e9d7267ff26d 100644
--- a/drivers/acpi/acpica/utpredef.c
+++ b/drivers/acpi/acpica/utpredef.c
@@ -225,8 +225,10 @@ const union acpi_predefined_info *acpi_ut_match_resource_name(char *name)
 {
 	const union acpi_predefined_info *this_name;
 
-	/* Quick check for a predefined name, first character must be underscore */
-
+	/*
+	 * Quick check for a predefined name, first character must
+	 * be underscore
+	 */
 	if (name[0] != '_') {
 		return (NULL);
 	}
* Unmerged path drivers/acpi/acpica/utprint.c
diff --git a/drivers/acpi/acpica/utresrc.c b/drivers/acpi/acpica/utresrc.c
index cb7fa491decf..7738a2327182 100644
--- a/drivers/acpi/acpica/utresrc.c
+++ b/drivers/acpi/acpica/utresrc.c
@@ -438,8 +438,8 @@ acpi_ut_walk_aml_resources(struct acpi_walk_state *walk_state,
 		    acpi_ut_validate_resource(walk_state, aml, &resource_index);
 		if (ACPI_FAILURE(status)) {
 			/*
-			 * Exit on failure. Cannot continue because the descriptor length
-			 * may be bogus also.
+			 * Exit on failure. Cannot continue because the descriptor
+			 * length may be bogus also.
 			 */
 			return_ACPI_STATUS(status);
 		}
@@ -565,8 +565,8 @@ acpi_ut_validate_resource(struct acpi_walk_state *walk_state,
 	}
 
 	/*
-	 * Check validity of the resource type, via acpi_gbl_resource_types. Zero
-	 * indicates an invalid resource.
+	 * Check validity of the resource type, via acpi_gbl_resource_types.
+	 * Zero indicates an invalid resource.
 	 */
 	if (!acpi_gbl_resource_types[resource_index]) {
 		goto invalid_resource;
diff --git a/drivers/acpi/acpica/utstate.c b/drivers/acpi/acpica/utstate.c
index a6b729d4c1dc..8d8a3e2a69c6 100644
--- a/drivers/acpi/acpica/utstate.c
+++ b/drivers/acpi/acpica/utstate.c
@@ -281,6 +281,7 @@ union acpi_generic_state *acpi_ut_create_pkg_state(void *internal_object,
 	state->pkg.dest_object = external_object;
 	state->pkg.index = index;
 	state->pkg.num_packages = 1;
+
 	return (state);
 }
 
@@ -314,6 +315,7 @@ union acpi_generic_state *acpi_ut_create_control_state(void)
 
 	state->common.descriptor_type = ACPI_DESC_TYPE_STATE_CONTROL;
 	state->common.state = ACPI_CONTROL_CONDITIONAL_EXECUTING;
+
 	return (state);
 }
 
@@ -339,5 +341,6 @@ void acpi_ut_delete_generic_state(union acpi_generic_state *state)
 	if (state) {
 		(void)acpi_os_release_object(acpi_gbl_state_cache, state);
 	}
+
 	return;
 }
diff --git a/drivers/acpi/acpica/utstring.c b/drivers/acpi/acpica/utstring.c
index 9edb65f516a6..950cac3baed7 100644
--- a/drivers/acpi/acpica/utstring.c
+++ b/drivers/acpi/acpica/utstring.c
@@ -415,6 +415,7 @@ void acpi_ut_print_string(char *string, u8 max_length)
 			break;
 		}
 	}
+
 	acpi_os_printf("\"");
 
 	if (i == max_length && string[i]) {
diff --git a/drivers/acpi/acpica/uttrack.c b/drivers/acpi/acpica/uttrack.c
index 77e3eb7d7c04..a230a55dc6ef 100644
--- a/drivers/acpi/acpica/uttrack.c
+++ b/drivers/acpi/acpica/uttrack.c
@@ -150,9 +150,9 @@ void *acpi_ut_allocate_and_track(acpi_size size,
 		return (NULL);
 	}
 
-	status = acpi_ut_track_allocation(allocation, size,
-					  ACPI_MEM_MALLOC, component, module,
-					  line);
+	status =
+	    acpi_ut_track_allocation(allocation, size, ACPI_MEM_MALLOC,
+				     component, module, line);
 	if (ACPI_FAILURE(status)) {
 		acpi_os_free(allocation);
 		return (NULL);
@@ -161,6 +161,7 @@ void *acpi_ut_allocate_and_track(acpi_size size,
 	acpi_gbl_global_list->total_allocated++;
 	acpi_gbl_global_list->total_size += (u32)size;
 	acpi_gbl_global_list->current_total_size += (u32)size;
+
 	if (acpi_gbl_global_list->current_total_size >
 	    acpi_gbl_global_list->max_occupied) {
 		acpi_gbl_global_list->max_occupied =
@@ -223,6 +224,7 @@ void *acpi_ut_allocate_zeroed_and_track(acpi_size size,
 	acpi_gbl_global_list->total_allocated++;
 	acpi_gbl_global_list->total_size += (u32)size;
 	acpi_gbl_global_list->current_total_size += (u32)size;
+
 	if (acpi_gbl_global_list->current_total_size >
 	    acpi_gbl_global_list->max_occupied) {
 		acpi_gbl_global_list->max_occupied =
@@ -269,8 +271,8 @@ acpi_ut_free_and_track(void *allocation,
 	acpi_gbl_global_list->total_freed++;
 	acpi_gbl_global_list->current_total_size -= debug_block->size;
 
-	status = acpi_ut_remove_allocation(debug_block,
-					   component, module, line);
+	status =
+	    acpi_ut_remove_allocation(debug_block, component, module, line);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "Could not free memory"));
 	}
@@ -524,35 +526,35 @@ void acpi_ut_dump_allocation_info(void)
 
 /*
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-			  ("%30s: %4d (%3d Kb)\n", "Current allocations",
-			  mem_list->current_count,
-			  ROUND_UP_TO_1K (mem_list->current_size)));
+		("%30s: %4d (%3d Kb)\n", "Current allocations",
+		mem_list->current_count,
+		ROUND_UP_TO_1K (mem_list->current_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-			  ("%30s: %4d (%3d Kb)\n", "Max concurrent allocations",
-			  mem_list->max_concurrent_count,
-			  ROUND_UP_TO_1K (mem_list->max_concurrent_size)));
+		("%30s: %4d (%3d Kb)\n", "Max concurrent allocations",
+		mem_list->max_concurrent_count,
+		ROUND_UP_TO_1K (mem_list->max_concurrent_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-			  ("%30s: %4d (%3d Kb)\n", "Total (all) internal objects",
-			  running_object_count,
-			  ROUND_UP_TO_1K (running_object_size)));
+		("%30s: %4d (%3d Kb)\n", "Total (all) internal objects",
+		running_object_count,
+		ROUND_UP_TO_1K (running_object_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-			  ("%30s: %4d (%3d Kb)\n", "Total (all) allocations",
-			  running_alloc_count,
-			  ROUND_UP_TO_1K (running_alloc_size)));
+		("%30s: %4d (%3d Kb)\n", "Total (all) allocations",
+		running_alloc_count,
+		ROUND_UP_TO_1K (running_alloc_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-			  ("%30s: %4d (%3d Kb)\n", "Current Nodes",
-			  acpi_gbl_current_node_count,
-			  ROUND_UP_TO_1K (acpi_gbl_current_node_size)));
+		("%30s: %4d (%3d Kb)\n", "Current Nodes",
+		acpi_gbl_current_node_count,
+		ROUND_UP_TO_1K (acpi_gbl_current_node_size)));
 
 	ACPI_DEBUG_PRINT (TRACE_ALLOCATIONS | TRACE_TABLES,
-			  ("%30s: %4d (%3d Kb)\n", "Max Nodes",
-			  acpi_gbl_max_concurrent_node_count,
-			  ROUND_UP_TO_1K ((acpi_gbl_max_concurrent_node_count *
-					 sizeof (struct acpi_namespace_node)))));
+		("%30s: %4d (%3d Kb)\n", "Max Nodes",
+		acpi_gbl_max_concurrent_node_count,
+		ROUND_UP_TO_1K ((acpi_gbl_max_concurrent_node_count *
+			sizeof (struct acpi_namespace_node)))));
 */
 	return_VOID;
 }
* Unmerged path drivers/acpi/acpica/utxface.c
* Unmerged path drivers/acpi/acpica/utxferror.c
diff --git a/drivers/acpi/acpica/utxfmutex.c b/drivers/acpi/acpica/utxfmutex.c
index 312299721ba1..dad497158f9f 100644
--- a/drivers/acpi/acpica/utxfmutex.c
+++ b/drivers/acpi/acpica/utxfmutex.c
@@ -89,9 +89,9 @@ acpi_ut_get_mutex_object(acpi_handle handle,
 
 	mutex_node = handle;
 	if (pathname != NULL) {
-		status = acpi_get_handle(handle, pathname,
-					 ACPI_CAST_PTR(acpi_handle,
-						       &mutex_node));
+		status =
+		    acpi_get_handle(handle, pathname,
+				    ACPI_CAST_PTR(acpi_handle, &mutex_node));
 		if (ACPI_FAILURE(status)) {
 			return (status);
 		}
* Unmerged path tools/power/acpi/common/getopt.c
diff --git a/tools/power/acpi/os_specific/service_layers/oslibcfs.c b/tools/power/acpi/os_specific/service_layers/oslibcfs.c
index 2da0ce885c8c..f0ffd090ff9a 100644
--- a/tools/power/acpi/os_specific/service_layers/oslibcfs.c
+++ b/tools/power/acpi/os_specific/service_layers/oslibcfs.c
@@ -73,6 +73,7 @@ ACPI_FILE acpi_os_open_file(const char *path, u8 modes)
 	if (modes & ACPI_FILE_WRITING) {
 		modes_str[i++] = 'w';
 	}
+
 	if (modes & ACPI_FILE_BINARY) {
 		modes_str[i++] = 'b';
 	}
@@ -100,6 +101,7 @@ ACPI_FILE acpi_os_open_file(const char *path, u8 modes)
 
 void acpi_os_close_file(ACPI_FILE file)
 {
+
 	fclose(file);
 }
 
@@ -202,6 +204,7 @@ acpi_status acpi_os_set_file_offset(ACPI_FILE file, long offset, u8 from)
 	if (from == ACPI_FILE_BEGIN) {
 		ret = fseek(file, offset, SEEK_SET);
 	}
+
 	if (from == ACPI_FILE_END) {
 		ret = fseek(file, offset, SEEK_END);
 	}
* Unmerged path tools/power/acpi/tools/acpidump/apfiles.c
