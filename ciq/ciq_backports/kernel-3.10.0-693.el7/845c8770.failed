i2c / ACPI: Assign IRQ for devices that have GpioInt automatically

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 845c877009cf014b971aab7f54613f9185a824b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/845c8770.failed

Following what DT already does. If the device does not have ACPI Interrupt
resource but instead it has one or more GpioInt resources listed below it,
we take the first GpioInt resource, convert it to suitable Linux IRQ number
and pass it to the driver instead.

This makes drivers simpler because the don't need to care about GPIOs at
all if only thing they need is interrupt.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Acked-by: Wolfram Sang <wsa@the-dreams.de>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 845c877009cf014b971aab7f54613f9185a824b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/i2c-core.c
diff --cc drivers/i2c/i2c-core.c
index 63b934e7da74,fc2ee8213fb6..000000000000
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@@ -240,6 -631,22 +240,25 @@@ static int i2c_device_probe(struct devi
  	if (!client)
  		return 0;
  
++<<<<<<< HEAD
++=======
+ 	if (!client->irq) {
+ 		int irq = -ENOENT;
+ 
+ 		if (dev->of_node)
+ 			irq = of_irq_get(dev->of_node, 0);
+ 		else if (ACPI_COMPANION(dev))
+ 			irq = acpi_dev_gpio_irq_get(ACPI_COMPANION(dev), 0);
+ 
+ 		if (irq == -EPROBE_DEFER)
+ 			return irq;
+ 		if (irq < 0)
+ 			irq = 0;
+ 
+ 		client->irq = irq;
+ 	}
+ 
++>>>>>>> 845c877009cf (i2c / ACPI: Assign IRQ for devices that have GpioInt automatically)
  	driver = to_i2c_driver(dev->driver);
  	if (!driver->probe || !driver->id_table)
  		return -ENODEV;
* Unmerged path drivers/i2c/i2c-core.c
