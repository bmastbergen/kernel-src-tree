sctp: change to check peer prsctp_capable when using prsctp polices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit be4947bf46cb0e7a7d089e03c61bab35f1e695ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/be4947bf.failed

Now before using prsctp polices, sctp uses asoc->prsctp_enable to
check if prsctp is enabled. However asoc->prsctp_enable is set only
means local host support prsctp, sctp should not abandon packet if
peer host doesn't enable prsctp.

So this patch is to use asoc->peer.prsctp_capable to check if prsctp
is enabled on both side, instead of asoc->prsctp_enable, as asoc's
peer.prsctp_capable is set only when local and peer both enable prsctp.

Fixes: a6c2f792873a ("sctp: implement prsctp TTL policy")
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit be4947bf46cb0e7a7d089e03c61bab35f1e695ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/outqueue.c
diff --cc net/sctp/outqueue.c
index 1f13c4abebe1,107233da5cc9..000000000000
--- a/net/sctp/outqueue.c
+++ b/net/sctp/outqueue.c
@@@ -305,20 -299,42 +305,40 @@@ void sctp_outq_tail(struct sctp_outq *q
  	 * immediately.
  	 */
  	if (sctp_chunk_is_data(chunk)) {
 -		/* Is it OK to queue data chunks?  */
 -		/* From 9. Termination of Association
 -		 *
 -		 * When either endpoint performs a shutdown, the
 -		 * association on each peer will stop accepting new
 -		 * data from its user and only deliver data in queue
 -		 * at the time of sending or receiving the SHUTDOWN
 -		 * chunk.
 -		 */
 -		switch (q->asoc->state) {
 -		case SCTP_STATE_CLOSED:
 -		case SCTP_STATE_SHUTDOWN_PENDING:
 -		case SCTP_STATE_SHUTDOWN_SENT:
 -		case SCTP_STATE_SHUTDOWN_RECEIVED:
 -		case SCTP_STATE_SHUTDOWN_ACK_SENT:
 -			/* Cannot send after transport endpoint shutdown */
 -			error = -ESHUTDOWN;
 -			break;
 -
 +		pr_debug("%s: outqueueing: outq:%p, chunk:%p[%s])\n",
 +			 __func__, q, chunk, chunk && chunk->chunk_hdr ?
 +			 sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)) :
 +			 "illegal chunk");
 +
++<<<<<<< HEAD
 +		sctp_chunk_hold(chunk);
 +		sctp_outq_tail_data(q, chunk);
 +		if (chunk->asoc->prsctp_enable &&
 +		    SCTP_PR_PRIO_ENABLED(chunk->sinfo.sinfo_flags))
 +			chunk->asoc->sent_cnt_removable++;
 +		if (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED)
 +			SCTP_INC_STATS(net, SCTP_MIB_OUTUNORDERCHUNKS);
 +		else
 +			SCTP_INC_STATS(net, SCTP_MIB_OUTORDERCHUNKS);
++=======
+ 		default:
+ 			pr_debug("%s: outqueueing: outq:%p, chunk:%p[%s])\n",
+ 				 __func__, q, chunk, chunk && chunk->chunk_hdr ?
+ 				 sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)) :
+ 				 "illegal chunk");
+ 
+ 			sctp_chunk_hold(chunk);
+ 			sctp_outq_tail_data(q, chunk);
+ 			if (chunk->asoc->peer.prsctp_capable &&
+ 			    SCTP_PR_PRIO_ENABLED(chunk->sinfo.sinfo_flags))
+ 				chunk->asoc->sent_cnt_removable++;
+ 			if (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED)
+ 				SCTP_INC_STATS(net, SCTP_MIB_OUTUNORDERCHUNKS);
+ 			else
+ 				SCTP_INC_STATS(net, SCTP_MIB_OUTORDERCHUNKS);
+ 			break;
+ 		}
++>>>>>>> be4947bf46cb (sctp: change to check peer prsctp_capable when using prsctp polices)
  	} else {
  		list_add_tail(&chunk->list, &q->control_chunk_list);
  		SCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);
diff --git a/net/sctp/chunk.c b/net/sctp/chunk.c
index f6f8876e4253..3dc89ca6022a 100644
--- a/net/sctp/chunk.c
+++ b/net/sctp/chunk.c
@@ -185,7 +185,7 @@ struct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *asoc,
 			 msg, msg->expires_at, jiffies);
 	}
 
-	if (asoc->prsctp_enable &&
+	if (asoc->peer.prsctp_capable &&
 	    SCTP_PR_TTL_ENABLED(sinfo->sinfo_flags))
 		msg->expires_at =
 			jiffies + msecs_to_jiffies(sinfo->sinfo_timetolive);
@@ -348,7 +348,7 @@ errout:
 /* Check whether this message has expired. */
 int sctp_chunk_abandoned(struct sctp_chunk *chunk)
 {
-	if (!chunk->asoc->prsctp_enable ||
+	if (!chunk->asoc->peer.prsctp_capable ||
 	    !SCTP_PR_POLICY(chunk->sinfo.sinfo_flags)) {
 		struct sctp_datamsg *msg = chunk->msg;
 
* Unmerged path net/sctp/outqueue.c
