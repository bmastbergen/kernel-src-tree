scsi: qla2xxx: Add Block Multi Queue functionality.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add Block Multi Queue functionality (Chad Dupuis) [1414957]
Rebuild_FUZZ: 92.63%
commit-author Michael Hernandez <michael.hernandez@cavium.com>
commit 5601236b6f7948cd1783298f6d4cacce02e22fde
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5601236b.failed

Tell the SCSI layer how many hardware queues we have based on the number
of max queue pairs created. The number of max queue pairs created will
depend on number of MSI-X vector count.

This feature can be turned on via CONFIG_SCSI_MQ_DEFAULT or passing
scsi_mod.use_blk_mq=Y as a parameter to the kernel

	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Sawan Chandak <sawan.chandak@cavium.com>
	Signed-off-by: Michael Hernandez <michael.hernandez@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 5601236b6f7948cd1783298f6d4cacce02e22fde)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_os.c
index f1f989d1fce1,d10a8763caaf..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -269,8 -274,8 +271,13 @@@ struct scsi_host_template qla2xxx_drive
  	.slave_destroy		= qla2xxx_slave_destroy,
  	.scan_finished		= qla2xxx_scan_finished,
  	.scan_start		= qla2xxx_scan_start,
++<<<<<<< HEAD
 +	.change_queue_depth	= qla2x00_change_queue_depth,
 +	.change_queue_type	= qla2x00_change_queue_type,
++=======
+ 	.change_queue_depth	= scsi_change_queue_depth,
+ 	.map_queues             = qla2xxx_map_queues,
++>>>>>>> 5601236b6f79 (scsi: qla2xxx: Add Block Multi Queue functionality.)
  	.this_id		= -1,
  	.cmd_per_lun		= 3,
  	.use_clustering		= ENABLE_CLUSTERING,
@@@ -690,12 -741,28 +697,34 @@@ qla2xxx_queuecommand(struct Scsi_Host *
  	struct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);
  	srb_t *sp;
  	int rval;
++<<<<<<< HEAD
++=======
+ 	struct qla_qpair *qpair = NULL;
+ 	uint32_t tag;
+ 	uint16_t hwq;
++>>>>>>> 5601236b6f79 (scsi: qla2xxx: Add Block Multi Queue functionality.)
  
  	if (unlikely(test_bit(UNLOADING, &base_vha->dpc_flags))) {
  		cmd->result = DID_NO_CONNECT << 16;
  		goto qc24_fail_command;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (ha->mqenable) {
+ 		if (shost_use_blk_mq(vha->host)) {
+ 			tag = blk_mq_unique_tag(cmd->request);
+ 			hwq = blk_mq_unique_tag_to_hwq(tag);
+ 			qpair = ha->queue_pair_map[hwq];
+ 		} else if (vha->vp_idx && vha->qpair) {
+ 			qpair = vha->qpair;
+ 		}
+ 
+ 		if (qpair)
+ 			return qla2xxx_mqueuecommand(host, cmd, qpair);
+ 	}
+ 
++>>>>>>> 5601236b6f79 (scsi: qla2xxx: Add Block Multi Queue functionality.)
  	if (ha->flags.eeh_busy) {
  		if (ha->flags.pci_channel_io_perm_failure) {
  			ql_dbg(ql_dbg_aer, vha, 0x9010,
@@@ -2380,6 -2522,8 +2409,11 @@@ qla2x00_probe_one(struct pci_dev *pdev
  	uint16_t req_length = 0, rsp_length = 0;
  	struct req_que *req = NULL;
  	struct rsp_que *rsp = NULL;
++<<<<<<< HEAD
++=======
+ 	int i;
+ 
++>>>>>>> 5601236b6f79 (scsi: qla2xxx: Add Block Multi Queue functionality.)
  	bars = pci_select_bars(pdev, IORESOURCE_MEM | IORESOURCE_IO);
  	sht = &qla2xxx_driver_template;
  	if (pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2422 ||
@@@ -2733,13 -2888,18 +2767,23 @@@ que_init
  		goto probe_init_failed;
  	}
  
+ 	if (ha->mqenable && shost_use_blk_mq(host)) {
+ 		/* number of hardware queues supported by blk/scsi-mq*/
+ 		host->nr_hw_queues = ha->max_qpairs;
+ 
+ 		ql_dbg(ql_dbg_init, base_vha, 0x0192,
+ 			"blk/scsi-mq enabled, HW queues = %d.\n", host->nr_hw_queues);
+ 	} else
+ 		ql_dbg(ql_dbg_init, base_vha, 0x0193,
+ 			"blk/scsi-mq disabled.\n");
+ 
  	qlt_probe_one_stage1(base_vha, ha);
  
 +	/* Set up the irqs */
 +	ret = qla2x00_request_irqs(ha, rsp);
 +	if (ret)
 +		goto probe_init_failed;
 +
  	pci_save_state(pdev);
  
  	/* Assign back pointers */
@@@ -2831,10 -2990,11 +2875,18 @@@
  	    base_vha->mgmt_svr_loop_id, host->sg_tablesize);
  
  	if (ha->mqenable) {
++<<<<<<< HEAD
 +		if (qla25xx_setup_mode(base_vha)) {
 +			ql_log(ql_log_warn, base_vha, 0x00ec,
 +			    "Failed to create queues, falling back to single queue mode.\n");
 +			goto que_init;
++=======
+ 		ha->wq = alloc_workqueue("qla2xxx_wq", WQ_MEM_RECLAIM, 1);
+ 		/* Create start of day qpairs for Block MQ */
+ 		if (shost_use_blk_mq(host)) {
+ 			for (i = 0; i < ha->max_qpairs; i++)
+ 				qla2xxx_create_qpair(base_vha, 5, 0);
++>>>>>>> 5601236b6f79 (scsi: qla2xxx: Add Block Multi Queue functionality.)
  		}
  	}
  
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
