net/af_iucv: don't use paged skbs for TX on HiperSockets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Julian Wiedmann <jwi@linux.vnet.ibm.com>
commit dc5367bcc556e97555fc94a32cd1aadbebdff47e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/dc5367bc.failed

With commit e53743994e21
("af_iucv: use paged SKBs for big outbound messages"),
we transmit paged skbs for both of AF_IUCV's transport modes
(IUCV or HiperSockets).
The qeth driver for Layer 3 HiperSockets currently doesn't
support NETIF_F_SG, so these skbs would just be linearized again
by the stack.
Avoid that overhead by using paged skbs only for IUCV transport.

cc stable, since this also circumvents a significant skb leak when
sending large messages (where the skb then needs to be linearized).

	Signed-off-by: Julian Wiedmann <jwi@linux.vnet.ibm.com>
	Signed-off-by: Ursula Braun <ubraun@linux.vnet.ibm.com>
	Cc: <stable@vger.kernel.org> # v4.8+
Fixes: e53743994e21 ("af_iucv: use paged SKBs for big outbound messages")
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dc5367bcc556e97555fc94a32cd1aadbebdff47e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/iucv/af_iucv.c
diff --cc net/iucv/af_iucv.c
index f1a141a2db54,13190b38f22e..000000000000
--- a/net/iucv/af_iucv.c
+++ b/net/iucv/af_iucv.c
@@@ -1030,8 -1044,10 +1030,13 @@@ static int iucv_sock_sendmsg(struct kio
  {
  	struct sock *sk = sock->sk;
  	struct iucv_sock *iucv = iucv_sk(sk);
++<<<<<<< HEAD
++=======
+ 	size_t headroom = 0;
+ 	size_t linear;
++>>>>>>> dc5367bcc556 (net/af_iucv: don't use paged skbs for TX on HiperSockets)
  	struct sk_buff *skb;
 -	struct iucv_message txmsg = {0};
 +	struct iucv_message txmsg;
  	struct cmsghdr *cmsg;
  	int cmsg_done;
  	long timeo;
@@@ -1110,20 -1123,33 +1115,40 @@@
  	 * this is fine for SOCK_SEQPACKET (unless we want to support
  	 * segmented records using the MSG_EOR flag), but
  	 * for SOCK_STREAM we might want to improve it in future */
++<<<<<<< HEAD
 +	if (iucv->transport == AF_IUCV_TRANS_HIPER)
 +		skb = sock_alloc_send_skb(sk,
 +			len + sizeof(struct af_iucv_trans_hdr) + ETH_HLEN,
 +			noblock, &err);
 +	else
 +		skb = sock_alloc_send_skb(sk, len, noblock, &err);
++=======
+ 	if (iucv->transport == AF_IUCV_TRANS_HIPER) {
+ 		headroom = sizeof(struct af_iucv_trans_hdr) + ETH_HLEN;
+ 		linear = len;
+ 	} else {
+ 		if (len < PAGE_SIZE) {
+ 			linear = len;
+ 		} else {
+ 			/* In nonlinear "classic" iucv skb,
+ 			 * reserve space for iucv_array
+ 			 */
+ 			headroom = sizeof(struct iucv_array) *
+ 				   (MAX_SKB_FRAGS + 1);
+ 			linear = PAGE_SIZE - headroom;
+ 		}
+ 	}
+ 	skb = sock_alloc_send_pskb(sk, headroom + linear, len - linear,
+ 				   noblock, &err, 0);
++>>>>>>> dc5367bcc556 (net/af_iucv: don't use paged skbs for TX on HiperSockets)
  	if (!skb)
  		goto out;
 -	if (headroom)
 -		skb_reserve(skb, headroom);
 -	skb_put(skb, linear);
 -	skb->len = len;
 -	skb->data_len = len - linear;
 -	err = skb_copy_datagram_from_iter(skb, 0, &msg->msg_iter, len);
 -	if (err)
 +	if (iucv->transport == AF_IUCV_TRANS_HIPER)
 +		skb_reserve(skb, sizeof(struct af_iucv_trans_hdr) + ETH_HLEN);
 +	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
 +		err = -EFAULT;
  		goto fail;
 +	}
  
  	/* wait if outstanding messages for iucv path has reached */
  	timeo = sock_sndtimeo(sk, noblock);
* Unmerged path net/iucv/af_iucv.c
