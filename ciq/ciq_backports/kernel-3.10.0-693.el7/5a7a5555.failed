net sched: stylistic cleanups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: stylistic cleanups (Jonathan Toppins) [1393375]
Rebuild_FUZZ: 92.59%
commit-author Jamal Hadi Salim <jhs@mojatatu.com>
commit 5a7a5555a362f60350668cd124df9a396f546c61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5a7a5555.failed

	Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5a7a5555a362f60350668cd124df9a396f546c61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_api.c
#	net/sched/cls_bpf.c
#	net/sched/cls_flower.c
#	net/sched/cls_route.c
#	net/sched/cls_tcindex.c
#	net/sched/cls_u32.c
#	net/sched/sch_api.c
diff --cc net/sched/cls_api.c
index a79e83e16a99,11da7da0b7c4..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -310,11 -341,18 +310,23 @@@ replay
  			break;
  		case RTM_DELTFILTER:
  			err = tp->ops->delete(tp, fh);
++<<<<<<< HEAD
 +			if (err == 0)
 +				tfilter_notify(net, skb, n, tp, fh, RTM_DELTFILTER);
++=======
+ 			if (err == 0) {
+ 				struct tcf_proto *next = rtnl_dereference(tp->next);
+ 
+ 				tfilter_notify(net, skb, n, tp, fh,
+ 					       RTM_DELTFILTER);
+ 				if (tcf_destroy(tp, false))
+ 					RCU_INIT_POINTER(*back, next);
+ 			}
++>>>>>>> 5a7a5555a362 (net sched: stylistic cleanups)
  			goto errout;
  		case RTM_GETTFILTER:
- 			err = tfilter_notify(net, skb, n, tp, fh, RTM_NEWTFILTER);
+ 			err = tfilter_notify(net, skb, n, tp, fh,
+ 					     RTM_NEWTFILTER);
  			goto errout;
  		default:
  			err = -EINVAL;
@@@ -516,23 -561,27 +529,27 @@@ int tcf_exts_validate(struct net *net, 
  	{
  		struct tc_action *act;
  
 +		INIT_LIST_HEAD(&exts->actions);
  		if (exts->police && tb[exts->police]) {
  			act = tcf_action_init_1(net, tb[exts->police], rate_tlv,
- 						"police", ovr,
- 						TCA_ACT_BIND);
+ 						"police", ovr, TCA_ACT_BIND);
  			if (IS_ERR(act))
  				return PTR_ERR(act);
  
  			act->type = exts->type = TCA_OLD_COMPAT;
 -			exts->actions[0] = act;
 -			exts->nr_actions = 1;
 +			list_add(&act->list, &exts->actions);
  		} else if (exts->action && tb[exts->action]) {
 -			LIST_HEAD(actions);
 -			int err, i = 0;
 -
 +			int err;
  			err = tcf_action_init(net, tb[exts->action], rate_tlv,
++<<<<<<< HEAD
 +					      NULL, ovr,
 +					      TCA_ACT_BIND, &exts->actions);
++=======
+ 					      NULL, ovr, TCA_ACT_BIND,
+ 					      &actions);
++>>>>>>> 5a7a5555a362 (net sched: stylistic cleanups)
  			if (err)
  				return err;
 -			list_for_each_entry(act, &actions, list)
 -				exts->actions[i++] = act;
 -			exts->nr_actions = i;
  		}
  	}
  #else
diff --cc net/sched/cls_bpf.c
index 95b1641cf7a7,c6f7a47541eb..000000000000
--- a/net/sched/cls_bpf.c
+++ b/net/sched/cls_bpf.c
@@@ -41,6 -53,10 +41,13 @@@ struct cls_bpf_prog 
  
  static const struct nla_policy bpf_policy[TCA_BPF_MAX + 1] = {
  	[TCA_BPF_CLASSID]	= { .type = NLA_U32 },
++<<<<<<< HEAD
++=======
+ 	[TCA_BPF_FLAGS]		= { .type = NLA_U32 },
+ 	[TCA_BPF_FD]		= { .type = NLA_U32 },
+ 	[TCA_BPF_NAME]		= { .type = NLA_NUL_STRING,
+ 				    .len = CLS_BPF_NAME_LEN },
++>>>>>>> 5a7a5555a362 (net sched: stylistic cleanups)
  	[TCA_BPF_OPS_LEN]	= { .type = NLA_U16 },
  	[TCA_BPF_OPS]		= { .type = NLA_BINARY,
  				    .len = sizeof(struct sock_filter) * BPF_MAXINSNS },
diff --cc net/sched/cls_route.c
index fa6aa85d5903,a4ce39b19be0..000000000000
--- a/net/sched/cls_route.c
+++ b/net/sched/cls_route.c
@@@ -243,10 -261,17 +243,14 @@@ static int route4_init(struct tcf_prot
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void
 +route4_delete_filter(struct tcf_proto *tp, struct route4_filter *f)
++=======
+ static void route4_delete_filter(struct rcu_head *head)
++>>>>>>> 5a7a5555a362 (net sched: stylistic cleanups)
  {
 -	struct route4_filter *f = container_of(head, struct route4_filter, rcu);
 -
 +	tcf_unbind_filter(tp, &f->res);
  	tcf_exts_destroy(&f->exts);
  	kfree(f);
  }
@@@ -422,13 -473,12 +426,11 @@@ errout
  }
  
  static int route4_change(struct net *net, struct sk_buff *in_skb,
- 		       struct tcf_proto *tp, unsigned long base,
- 		       u32 handle,
- 		       struct nlattr **tca,
- 		       unsigned long *arg, bool ovr)
+ 			 struct tcf_proto *tp, unsigned long base, u32 handle,
+ 			 struct nlattr **tca, unsigned long *arg, bool ovr)
  {
 -	struct route4_head *head = rtnl_dereference(tp->root);
 -	struct route4_filter __rcu **fp;
 -	struct route4_filter *fold, *f1, *pfp, *f = NULL;
 +	struct route4_head *head = tp->root;
 +	struct route4_filter *f, *f1, **fp;
  	struct route4_bucket *b;
  	struct nlattr *opt = tca[TCA_OPTIONS];
  	struct nlattr *tb[TCA_ROUTE4_MAX + 1];
diff --cc net/sched/cls_tcindex.c
index fcae64bf7721,96144bdf30db..000000000000
--- a/net/sched/cls_tcindex.c
+++ b/net/sched/cls_tcindex.c
@@@ -133,8 -133,24 +132,29 @@@ static int tcindex_init(struct tcf_prot
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int
 +tcindex_delete(struct tcf_proto *tp, unsigned long arg)
++=======
+ static void tcindex_destroy_rexts(struct rcu_head *head)
+ {
+ 	struct tcindex_filter_result *r;
+ 
+ 	r = container_of(head, struct tcindex_filter_result, rcu);
+ 	tcf_exts_destroy(&r->exts);
+ }
+ 
+ static void tcindex_destroy_fexts(struct rcu_head *head)
+ {
+ 	struct tcindex_filter *f = container_of(head, struct tcindex_filter,
+ 						rcu);
+ 
+ 	tcf_exts_destroy(&f->result.exts);
+ 	kfree(f);
+ }
+ 
+ static int tcindex_delete(struct tcf_proto *tp, unsigned long arg)
++>>>>>>> 5a7a5555a362 (net sched: stylistic cleanups)
  {
  	struct tcindex_data *p = rtnl_dereference(tp->root);
  	struct tcindex_filter_result *r = (struct tcindex_filter_result *) arg;
diff --cc net/sched/cls_u32.c
index 9fba35eb571c,ae83c3aec308..000000000000
--- a/net/sched/cls_u32.c
+++ b/net/sched/cls_u32.c
@@@ -439,7 -446,8 +437,12 @@@ static void u32_remove_hw_knode(struct 
  	}
  }
  
++<<<<<<< HEAD
 +static void u32_replace_hw_hnode(struct tcf_proto *tp, struct tc_u_hnode *h)
++=======
+ static int u32_replace_hw_hnode(struct tcf_proto *tp, struct tc_u_hnode *h,
+ 				u32 flags)
++>>>>>>> 5a7a5555a362 (net sched: stylistic cleanups)
  {
  	struct net_device *dev = tp->q->dev_queue->dev;
  	struct tc_cls_u32_offload u32_offload = {0};
@@@ -479,7 -493,8 +482,12 @@@ static void u32_clear_hw_hnode(struct t
  	}
  }
  
++<<<<<<< HEAD
 +static void u32_replace_hw_knode(struct tcf_proto *tp, struct tc_u_knode *n)
++=======
+ static int u32_replace_hw_knode(struct tcf_proto *tp, struct tc_u_knode *n,
+ 				u32 flags)
++>>>>>>> 5a7a5555a362 (net sched: stylistic cleanups)
  {
  	struct net_device *dev = tp->q->dev_queue->dev;
  	struct tc_cls_u32_offload u32_offload = {0};
diff --cc net/sched/sch_api.c
index ba6b51bc1c21,206dc24add3a..000000000000
--- a/net/sched/sch_api.c
+++ b/net/sched/sch_api.c
@@@ -1452,7 -1510,8 +1457,12 @@@ static int tc_dump_qdisc(struct sk_buf
  			s_q_idx = 0;
  		q_idx = 0;
  
++<<<<<<< HEAD
 +		if (tc_dump_qdisc_root(dev->qdisc, skb, cb, &q_idx, s_q_idx) < 0)
++=======
+ 		if (tc_dump_qdisc_root(dev->qdisc, skb, cb, &q_idx, s_q_idx,
+ 				       true) < 0)
++>>>>>>> 5a7a5555a362 (net sched: stylistic cleanups)
  			goto done;
  
  		dev_queue = dev_ingress_queue(dev);
* Unmerged path net/sched/cls_flower.c
diff --git a/net/sched/act_api.c b/net/sched/act_api.c
index 45d305cc522a..38db2b23f5ba 100644
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@ -525,9 +525,8 @@ err_out:
 	return ERR_PTR(err);
 }
 
-int tcf_action_init(struct net *net, struct nlattr *nla,
-				  struct nlattr *est, char *name, int ovr,
-				  int bind, struct list_head *actions)
+int tcf_action_init(struct net *net, struct nlattr *nla, struct nlattr *est,
+		    char *name, int ovr, int bind, struct list_head *actions)
 {
 	struct nlattr *tb[TCA_ACT_MAX_PRIO + 1];
 	struct tc_action *act;
@@ -878,9 +877,8 @@ tcf_add_notify(struct net *net, struct nlmsghdr *n, struct list_head *actions,
 	return err;
 }
 
-static int
-tcf_action_add(struct net *net, struct nlattr *nla, struct nlmsghdr *n,
-	       u32 portid, int ovr)
+static int tcf_action_add(struct net *net, struct nlattr *nla,
+			  struct nlmsghdr *n, u32 portid, int ovr)
 {
 	int ret = 0;
 	LIST_HEAD(actions);
@@ -948,8 +946,7 @@ replay:
 	return ret;
 }
 
-static struct nlattr *
-find_dump_kind(const struct nlmsghdr *n)
+static struct nlattr *find_dump_kind(const struct nlmsghdr *n)
 {
 	struct nlattr *tb1, *tb2[TCA_ACT_MAX + 1];
 	struct nlattr *tb[TCA_ACT_MAX_PRIO + 1];
@@ -976,8 +973,7 @@ find_dump_kind(const struct nlmsghdr *n)
 	return kind;
 }
 
-static int
-tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)
+static int tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)
 {
 	struct nlmsghdr *nlh;
 	unsigned char *b = skb_tail_pointer(skb);
diff --git a/net/sched/act_csum.c b/net/sched/act_csum.c
index 11fe1a416433..31587167092d 100644
--- a/net/sched/act_csum.c
+++ b/net/sched/act_csum.c
@@ -130,8 +130,8 @@ static void *tcf_csum_skb_nextlayer(struct sk_buff *skb,
 		return (void *)(skb_network_header(skb) + ihl);
 }
 
-static int tcf_csum_ipv4_icmp(struct sk_buff *skb,
-			      unsigned int ihl, unsigned int ipl)
+static int tcf_csum_ipv4_icmp(struct sk_buff *skb, unsigned int ihl,
+			      unsigned int ipl)
 {
 	struct icmphdr *icmph;
 
@@ -166,8 +166,8 @@ static int tcf_csum_ipv4_igmp(struct sk_buff *skb,
 	return 1;
 }
 
-static int tcf_csum_ipv6_icmp(struct sk_buff *skb,
-			      unsigned int ihl, unsigned int ipl)
+static int tcf_csum_ipv6_icmp(struct sk_buff *skb, unsigned int ihl,
+			      unsigned int ipl)
 {
 	struct icmp6hdr *icmp6h;
 	const struct ipv6hdr *ip6h;
@@ -188,8 +188,8 @@ static int tcf_csum_ipv6_icmp(struct sk_buff *skb,
 	return 1;
 }
 
-static int tcf_csum_ipv4_tcp(struct sk_buff *skb,
-			     unsigned int ihl, unsigned int ipl)
+static int tcf_csum_ipv4_tcp(struct sk_buff *skb, unsigned int ihl,
+			     unsigned int ipl)
 {
 	struct tcphdr *tcph;
 	const struct iphdr *iph;
@@ -209,8 +209,8 @@ static int tcf_csum_ipv4_tcp(struct sk_buff *skb,
 	return 1;
 }
 
-static int tcf_csum_ipv6_tcp(struct sk_buff *skb,
-			     unsigned int ihl, unsigned int ipl)
+static int tcf_csum_ipv6_tcp(struct sk_buff *skb, unsigned int ihl,
+			     unsigned int ipl)
 {
 	struct tcphdr *tcph;
 	const struct ipv6hdr *ip6h;
@@ -231,8 +231,8 @@ static int tcf_csum_ipv6_tcp(struct sk_buff *skb,
 	return 1;
 }
 
-static int tcf_csum_ipv4_udp(struct sk_buff *skb,
-			     unsigned int ihl, unsigned int ipl, int udplite)
+static int tcf_csum_ipv4_udp(struct sk_buff *skb, unsigned int ihl,
+			     unsigned int ipl, int udplite)
 {
 	struct udphdr *udph;
 	const struct iphdr *iph;
@@ -284,8 +284,8 @@ ignore_obscure_skb:
 	return 1;
 }
 
-static int tcf_csum_ipv6_udp(struct sk_buff *skb,
-			     unsigned int ihl, unsigned int ipl, int udplite)
+static int tcf_csum_ipv6_udp(struct sk_buff *skb, unsigned int ihl,
+			     unsigned int ipl, int udplite)
 {
 	struct udphdr *udph;
 	const struct ipv6hdr *ip6h;
@@ -396,8 +396,8 @@ fail:
 	return 0;
 }
 
-static int tcf_csum_ipv6_hopopts(struct ipv6_opt_hdr *ip6xh,
-				 unsigned int ixhl, unsigned int *pl)
+static int tcf_csum_ipv6_hopopts(struct ipv6_opt_hdr *ip6xh, unsigned int ixhl,
+				 unsigned int *pl)
 {
 	int off, len, optlen;
 	unsigned char *xh = (void *)ip6xh;
@@ -510,8 +510,8 @@ fail:
 	return 0;
 }
 
-static int tcf_csum(struct sk_buff *skb,
-		    const struct tc_action *a, struct tcf_result *res)
+static int tcf_csum(struct sk_buff *skb, const struct tc_action *a,
+		    struct tcf_result *res)
 {
 	struct tcf_csum *p = a->priv;
 	int action;
@@ -547,8 +547,8 @@ drop:
 	return TC_ACT_SHOT;
 }
 
-static int tcf_csum_dump(struct sk_buff *skb,
-			 struct tc_action *a, int bind, int ref)
+static int tcf_csum_dump(struct sk_buff *skb, struct tc_action *a, int bind,
+			 int ref)
 {
 	unsigned char *b = skb_tail_pointer(skb);
 	struct tcf_csum *p = a->priv;
diff --git a/net/sched/act_gact.c b/net/sched/act_gact.c
index 085ab295a109..98ca3ca85133 100644
--- a/net/sched/act_gact.c
+++ b/net/sched/act_gact.c
@@ -167,7 +167,8 @@ static void tcf_gact_stats_update(struct tc_action *a, u64 bytes, u32 packets,
 	int action = READ_ONCE(gact->tcf_action);
 	struct tcf_t *tm = &gact->tcf_tm;
 
-	_bstats_cpu_update(this_cpu_ptr(gact->common.cpu_bstats), bytes, packets);
+	_bstats_cpu_update(this_cpu_ptr(gact->common.cpu_bstats), bytes,
+			   packets);
 	if (action == TC_ACT_SHOT)
 		this_cpu_ptr(gact->common.cpu_qstats)->drops += packets;
 
diff --git a/net/sched/act_mirred.c b/net/sched/act_mirred.c
index 4b6188539f6c..822afb768fdd 100644
--- a/net/sched/act_mirred.c
+++ b/net/sched/act_mirred.c
@@ -212,7 +212,8 @@ out:
 	return retval;
 }
 
-static int tcf_mirred_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)
+static int tcf_mirred_dump(struct sk_buff *skb, struct tc_action *a, int bind,
+			   int ref)
 {
 	unsigned char *b = skb_tail_pointer(skb);
 	struct tcf_mirred *m = a->priv;
diff --git a/net/sched/act_police.c b/net/sched/act_police.c
index 376c02554325..79cddc92987f 100644
--- a/net/sched/act_police.c
+++ b/net/sched/act_police.c
@@ -363,8 +363,8 @@ static int tcf_act_police(struct sk_buff *skb, const struct tc_action *a,
 	return police->tcf_action;
 }
 
-static int
-tcf_act_police_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)
+static int tcf_act_police_dump(struct sk_buff *skb, struct tc_action *a,
+			       int bind, int ref)
 {
 	unsigned char *b = skb_tail_pointer(skb);
 	struct tcf_police *police = a->priv;
@@ -413,14 +413,12 @@ static struct tc_action_ops act_police_ops = {
 	.walk		=	tcf_act_police_walker
 };
 
-static int __init
-police_init_module(void)
+static int __init police_init_module(void)
 {
 	return tcf_register_action(&act_police_ops);
 }
 
-static void __exit
-police_cleanup_module(void)
+static void __exit police_cleanup_module(void)
 {
 	tcf_unregister_action(&act_police_ops);
 }
* Unmerged path net/sched/cls_api.c
* Unmerged path net/sched/cls_bpf.c
diff --git a/net/sched/cls_flow.c b/net/sched/cls_flow.c
index c999e8f9936b..43420168d51b 100644
--- a/net/sched/cls_flow.c
+++ b/net/sched/cls_flow.c
@@ -80,12 +80,14 @@ static u32 flow_get_dst(const struct sk_buff *skb, const struct flow_keys *flow)
 	return addr_fold(skb_dst(skb)) ^ (__force u16)skb->protocol;
 }
 
-static u32 flow_get_proto(const struct sk_buff *skb, const struct flow_keys *flow)
+static u32 flow_get_proto(const struct sk_buff *skb,
+			  const struct flow_keys *flow)
 {
 	return flow->ip_proto;
 }
 
-static u32 flow_get_proto_src(const struct sk_buff *skb, const struct flow_keys *flow)
+static u32 flow_get_proto_src(const struct sk_buff *skb,
+			      const struct flow_keys *flow)
 {
 	if (flow->ports)
 		return ntohs(flow->port16[0]);
@@ -93,7 +95,8 @@ static u32 flow_get_proto_src(const struct sk_buff *skb, const struct flow_keys
 	return addr_fold(skb->sk);
 }
 
-static u32 flow_get_proto_dst(const struct sk_buff *skb, const struct flow_keys *flow)
+static u32 flow_get_proto_dst(const struct sk_buff *skb,
+			      const struct flow_keys *flow)
 {
 	if (flow->ports)
 		return ntohs(flow->port16[1]);
@@ -142,7 +145,8 @@ static u32 flow_get_nfct(const struct sk_buff *skb)
 })
 #endif
 
-static u32 flow_get_nfct_src(const struct sk_buff *skb, const struct flow_keys *flow)
+static u32 flow_get_nfct_src(const struct sk_buff *skb,
+			     const struct flow_keys *flow)
 {
 	switch (skb->protocol) {
 	case htons(ETH_P_IP):
@@ -154,7 +158,8 @@ fallback:
 	return flow_get_src(skb, flow);
 }
 
-static u32 flow_get_nfct_dst(const struct sk_buff *skb, const struct flow_keys *flow)
+static u32 flow_get_nfct_dst(const struct sk_buff *skb,
+			     const struct flow_keys *flow)
 {
 	switch (skb->protocol) {
 	case htons(ETH_P_IP):
@@ -166,14 +171,16 @@ fallback:
 	return flow_get_dst(skb, flow);
 }
 
-static u32 flow_get_nfct_proto_src(const struct sk_buff *skb, const struct flow_keys *flow)
+static u32 flow_get_nfct_proto_src(const struct sk_buff *skb,
+				   const struct flow_keys *flow)
 {
 	return ntohs(CTTUPLE(skb, src.u.all));
 fallback:
 	return flow_get_proto_src(skb, flow);
 }
 
-static u32 flow_get_nfct_proto_dst(const struct sk_buff *skb, const struct flow_keys *flow)
+static u32 flow_get_nfct_proto_dst(const struct sk_buff *skb,
+				   const struct flow_keys *flow)
 {
 	return ntohs(CTTUPLE(skb, dst.u.all));
 fallback:
* Unmerged path net/sched/cls_flower.c
diff --git a/net/sched/cls_fw.c b/net/sched/cls_fw.c
index 87e4b3371637..a2dfe56ce441 100644
--- a/net/sched/cls_fw.c
+++ b/net/sched/cls_fw.c
@@ -54,7 +54,7 @@ static u32 fw_hash(u32 handle)
 }
 
 static int fw_classify(struct sk_buff *skb, const struct tcf_proto *tp,
-			  struct tcf_result *res)
+		       struct tcf_result *res)
 {
 	struct fw_head *head = tp->root;
 	struct fw_filter *f;
@@ -165,7 +165,8 @@ static const struct nla_policy fw_policy[TCA_FW_MAX + 1] = {
 
 static int
 fw_change_attrs(struct net *net, struct tcf_proto *tp, struct fw_filter *f,
-	struct nlattr **tb, struct nlattr **tca, unsigned long base, bool ovr)
+		struct nlattr **tb, struct nlattr **tca, unsigned long base,
+		bool ovr)
 {
 	struct fw_head *head = tp->root;
 	struct tcf_exts e;
@@ -212,9 +213,8 @@ errout:
 
 static int fw_change(struct net *net, struct sk_buff *in_skb,
 		     struct tcf_proto *tp, unsigned long base,
-		     u32 handle,
-		     struct nlattr **tca,
-		     unsigned long *arg, bool ovr)
+		     u32 handle, struct nlattr **tca, unsigned long *arg,
+		     bool ovr)
 {
 	struct fw_head *head = tp->root;
 	struct fw_filter *f = (struct fw_filter *) *arg;
* Unmerged path net/sched/cls_route.c
* Unmerged path net/sched/cls_tcindex.c
* Unmerged path net/sched/cls_u32.c
* Unmerged path net/sched/sch_api.c
