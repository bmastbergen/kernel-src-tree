KVM: x86: allow hotplug of VCPU with APIC ID over 0xff

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit 5bd5db385b3e13c702365574c0b7350c6ea45e84
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5bd5db38.failed

LAPIC after reset is in xAPIC mode, which poses a problem for hotplug of
VCPUs with high APIC ID, because reset VCPU is waiting for INIT/SIPI,
but there is no way to uniquely address it using xAPIC.

From many possible options, we chose the one that also works on real
hardware: accepting interrupts addressed to LAPIC's x2APIC ID even in
xAPIC mode.

KVM intentionally differs from real hardware, because real hardware
(Knights Landing) does just "x2apic_id & 0xff" to decide whether to
accept the interrupt in xAPIC mode and it can deliver one interrupt to
more than one physical destination, e.g. 0x123 to 0x123 and 0x23.

Fixes: 682f732ecf73 ("KVM: x86: bump MAX_VCPUS to 288")
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 5bd5db385b3e13c702365574c0b7350c6ea45e84)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
diff --cc arch/x86/kvm/lapic.c
index 323d098efc5e,7e9ac4606279..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -201,11 -196,21 +203,27 @@@ static void recalculate_apic_map(struc
  		if (!kvm_apic_present(vcpu))
  			continue;
  
++<<<<<<< HEAD
 +		aid = kvm_apic_id(apic);
 +		ldr = kvm_apic_get_reg(apic, APIC_LDR);
 +
 +		if (aid <= new->max_apic_id)
 +			new->phys_map[aid] = apic;
++=======
+ 		xapic_id = kvm_xapic_id(apic);
+ 		x2apic_id = kvm_x2apic_id(apic);
+ 
+ 		/* Hotplug hack: see kvm_apic_match_physical_addr(), ... */
+ 		if ((apic_x2apic_mode(apic) || x2apic_id > 0xff) &&
+ 				x2apic_id <= new->max_apic_id)
+ 			new->phys_map[x2apic_id] = apic;
+ 		/*
+ 		 * ... xAPIC ID of VCPUs with APIC ID > 0xff will wrap-around,
+ 		 * prevent them from masking VCPUs with APIC ID <= 0xff.
+ 		 */
+ 		if (!apic_x2apic_mode(apic) && !new->phys_map[xapic_id])
+ 			new->phys_map[xapic_id] = apic;
 -
 -		ldr = kvm_lapic_get_reg(apic, APIC_LDR);
++>>>>>>> 5bd5db385b3e (KVM: x86: allow hotplug of VCPU with APIC ID over 0xff)
  
  		if (apic_x2apic_mode(apic)) {
  			new->mode |= KVM_APIC_MODE_X2APIC;
@@@ -615,9 -613,18 +633,22 @@@ static bool kvm_apic_match_physical_add
  		return true;
  
  	if (apic_x2apic_mode(apic))
 -		return mda == kvm_x2apic_id(apic);
 +		return mda == kvm_apic_id(apic);
  
++<<<<<<< HEAD
 +	return mda == SET_APIC_DEST_FIELD(kvm_apic_id(apic));
++=======
+ 	/*
+ 	 * Hotplug hack: Make LAPIC in xAPIC mode also accept interrupts as if
+ 	 * it were in x2APIC mode.  Hotplugged VCPUs start in xAPIC mode and
+ 	 * this allows unique addressing of VCPUs with APIC ID over 0xff.
+ 	 * The 0xff condition is needed because writeable xAPIC ID.
+ 	 */
+ 	if (kvm_x2apic_id(apic) > 0xff && mda == kvm_x2apic_id(apic))
+ 		return true;
+ 
+ 	return mda == kvm_xapic_id(apic);
++>>>>>>> 5bd5db385b3e (KVM: x86: allow hotplug of VCPU with APIC ID over 0xff)
  }
  
  static bool kvm_apic_match_logical_addr(struct kvm_lapic *apic, u32 mda)
* Unmerged path arch/x86/kvm/lapic.c
