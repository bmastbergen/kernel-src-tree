dax: Make huge page handling depend of CONFIG_BROKEN

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jan Kara <jack@suse.cz>
commit 348e967ab07c96a9e7a6a194812254a8df2045c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/348e967a.failed

Currently the handling of huge pages for DAX is racy. For example the
following can happen:

CPU0 (THP write fault)			CPU1 (normal read fault)

__dax_pmd_fault()			__dax_fault()
  get_block(inode, block, &bh, 0) -> not mapped
					get_block(inode, block, &bh, 0)
					  -> not mapped
  if (!buffer_mapped(&bh) && write)
    get_block(inode, block, &bh, 1) -> allocates blocks
  truncate_pagecache_range(inode, lstart, lend);
					dax_load_hole();

This results in data corruption since process on CPU1 won't see changes
into the file done by CPU0.

The race can happen even if two normal faults race however with THP the
situation is even worse because the two faults don't operate on the same
entries in the radix tree and we want to use these entries for
serialization. So make THP support in DAX code depend on CONFIG_BROKEN
for now.

	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
(cherry picked from commit 348e967ab07c96a9e7a6a194812254a8df2045c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/Kconfig
diff --cc fs/Kconfig
index ed6bd9486027,b8fcb416be72..000000000000
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@@ -52,6 -50,8 +52,11 @@@ config FS_DAX_PM
  	bool
  	default FS_DAX
  	depends on FS_DAX
++<<<<<<< HEAD
++=======
+ 	depends on ZONE_DEVICE
+ 	depends on TRANSPARENT_HUGEPAGE
++>>>>>>> 348e967ab07c (dax: Make huge page handling depend of CONFIG_BROKEN)
  	depends on BROKEN
  
  endif # BLOCK
* Unmerged path fs/Kconfig
diff --git a/fs/dax.c b/fs/dax.c
index 3ad95e9ec809..a45a97e891a4 100644
--- a/fs/dax.c
+++ b/fs/dax.c
@@ -799,7 +799,7 @@ int dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,
 }
 EXPORT_SYMBOL_GPL(dax_fault);
 
-#ifdef CONFIG_TRANSPARENT_HUGEPAGE
+#if defined(CONFIG_TRANSPARENT_HUGEPAGE)
 /*
  * The 'colour' (ie low bits) within a PMD of a page offset.  This comes up
  * more often than one might expect in the below function.
diff --git a/include/linux/dax.h b/include/linux/dax.h
index bbe07d8b9dee..1d3f25e1cb59 100644
--- a/include/linux/dax.h
+++ b/include/linux/dax.h
@@ -26,7 +26,7 @@ static inline struct page *read_dax_sector(struct block_device *bdev,
 }
 #endif
 
-#ifdef CONFIG_TRANSPARENT_HUGEPAGE
+#if defined(CONFIG_TRANSPARENT_HUGEPAGE)
 int dax_pmd_fault(struct vm_area_struct *, unsigned long addr, pmd_t *,
 				unsigned int flags, get_block_t, dax_iodone_t);
 int __dax_pmd_fault(struct vm_area_struct *, unsigned long addr, pmd_t *,
