net: add possibility to pass information about upper device via notifier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] add possibility to pass information about upper device via notifier (Ivan Vecera) [1275772 1297841 1331748]
Rebuild_FUZZ: 96.40%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 29bf24afb29042f568fa67b1b0eee46796725ed2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/29bf24af.failed

Sometimes the drivers and other code would find it handy to know some
internal information about upper device being changed. So allow upper-code
to pass information down to notifier listeners during linking.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 29bf24afb29042f568fa67b1b0eee46796725ed2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
#	drivers/net/team/team.c
#	drivers/net/vrf.c
#	include/linux/netdevice.h
#	net/batman-adv/hard-interface.c
#	net/bridge/br_if.c
#	net/core/dev.c
#	net/openvswitch/vport-netdev.c
diff --cc drivers/net/bonding/bond_main.c
index ce8e9750aae0,fa3ed1d8a12d..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1202,9 -1204,10 +1202,13 @@@ static int bond_master_upper_dev_link(s
  {
  	int err;
  
++<<<<<<< HEAD
 +	err = netdev_master_upper_dev_link_private(slave_dev, bond_dev, slave);
++=======
+ 	err = netdev_master_upper_dev_link(slave_dev, bond_dev, slave, NULL);
++>>>>>>> 29bf24afb290 (net: add possibility to pass information about upper device via notifier)
  	if (err)
  		return err;
 -	slave_dev->flags |= IFF_SLAVE;
  	rtmsg_ifinfo(RTM_NEWLINK, slave_dev, IFF_SLAVE, GFP_KERNEL);
  	return 0;
  }
diff --cc drivers/net/team/team.c
index 75ab1983f4c3,f7b6ff7948b8..000000000000
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@@ -1101,7 -1083,7 +1101,11 @@@ static int team_upper_dev_link(struct n
  {
  	int err;
  
++<<<<<<< HEAD
 +	err = netdev_master_upper_dev_link(port_dev, dev);
++=======
+ 	err = netdev_master_upper_dev_link(port_dev, dev, NULL, NULL);
++>>>>>>> 29bf24afb290 (net: add possibility to pass information about upper device via notifier)
  	if (err)
  		return err;
  	port_dev->priv_flags |= IFF_TEAM_PORT;
diff --cc include/linux/netdevice.h
index 24b9dc29c57a,aea556c64f2c..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -3698,10 -3620,8 +3699,15 @@@ struct net_device *netdev_master_upper_
  struct net_device *netdev_master_upper_dev_get_rcu(struct net_device *dev);
  int netdev_upper_dev_link(struct net_device *dev, struct net_device *upper_dev);
  int netdev_master_upper_dev_link(struct net_device *dev,
++<<<<<<< HEAD
 +				 struct net_device *upper_dev);
 +int netdev_master_upper_dev_link_private(struct net_device *dev,
 +					 struct net_device *upper_dev,
 +					 void *private);
++=======
+ 				 struct net_device *upper_dev,
+ 				 void *upper_priv, void *upper_info);
++>>>>>>> 29bf24afb290 (net: add possibility to pass information about upper device via notifier)
  void netdev_upper_dev_unlink(struct net_device *dev,
  			     struct net_device *upper_dev);
  void netdev_adjacent_rename_links(struct net_device *dev, char *oldname);
diff --cc net/batman-adv/hard-interface.c
index b6504eac0ed8,aa8867e1d983..000000000000
--- a/net/batman-adv/hard-interface.c
+++ b/net/batman-adv/hard-interface.c
@@@ -377,7 -464,8 +377,12 @@@ int batadv_hardif_enable_interface(stru
  	hard_iface->soft_iface = soft_iface;
  	bat_priv = netdev_priv(hard_iface->soft_iface);
  
++<<<<<<< HEAD
 +	ret = netdev_master_upper_dev_link(hard_iface->net_dev, soft_iface);
++=======
+ 	ret = netdev_master_upper_dev_link(hard_iface->net_dev,
+ 					   soft_iface, NULL, NULL);
++>>>>>>> 29bf24afb290 (net: add possibility to pass information about upper device via notifier)
  	if (ret)
  		goto err_dev;
  
diff --cc net/bridge/br_if.c
index c4107a488d8b,8d1d4a22c50d..000000000000
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@@ -511,7 -493,7 +511,11 @@@ int br_add_if(struct net_bridge *br, st
  
  	dev->priv_flags |= IFF_BRIDGE_PORT;
  
++<<<<<<< HEAD
 +	err = netdev_master_upper_dev_link(dev, br->dev);
++=======
+ 	err = netdev_master_upper_dev_link(dev, br->dev, NULL, NULL);
++>>>>>>> 29bf24afb290 (net: add possibility to pass information about upper device via notifier)
  	if (err)
  		goto err5;
  
diff --cc net/core/dev.c
index e2ceb23207bd,8ed886663c6d..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -5350,7 -5421,7 +5350,11 @@@ void __netdev_adjacent_dev_unlink_neigh
  
  static int __netdev_upper_dev_link(struct net_device *dev,
  				   struct net_device *upper_dev, bool master,
++<<<<<<< HEAD
 +				   void *private)
++=======
+ 				   void *upper_priv, void *upper_info)
++>>>>>>> 29bf24afb290 (net: add possibility to pass information about upper device via notifier)
  {
  	struct netdev_notifier_changeupper_info changeupper_info;
  	struct netdev_adjacent *i, *j, *to_i, *to_j;
@@@ -5374,8 -5445,15 +5378,9 @@@
  	changeupper_info.upper_dev = upper_dev;
  	changeupper_info.master = master;
  	changeupper_info.linking = true;
+ 	changeupper_info.upper_info = upper_info;
  
 -	ret = call_netdevice_notifiers_info(NETDEV_PRECHANGEUPPER, dev,
 -					    &changeupper_info.info);
 -	ret = notifier_to_errno(ret);
 -	if (ret)
 -		return ret;
 -
 -	ret = __netdev_adjacent_dev_link_neighbour(dev, upper_dev, upper_priv,
 +	ret = __netdev_adjacent_dev_link_neighbour(dev, upper_dev, private,
  						   master);
  	if (ret)
  		return ret;
@@@ -5480,6 -5558,8 +5485,11 @@@ EXPORT_SYMBOL(netdev_upper_dev_link)
   * netdev_master_upper_dev_link - Add a master link to the upper device
   * @dev: device
   * @upper_dev: new upper device
++<<<<<<< HEAD
++=======
+  * @upper_priv: upper device private
+  * @upper_info: upper info to be passed down via notifier
++>>>>>>> 29bf24afb290 (net: add possibility to pass information about upper device via notifier)
   *
   * Adds a link to device which is upper to this one. In this case, only
   * one master upper device can be linked, although other non-master devices
@@@ -5488,9 -5568,11 +5498,17 @@@
   * counts are adjusted and the function returns zero.
   */
  int netdev_master_upper_dev_link(struct net_device *dev,
++<<<<<<< HEAD
 +				 struct net_device *upper_dev)
 +{
 +	return __netdev_upper_dev_link(dev, upper_dev, true, NULL);
++=======
+ 				 struct net_device *upper_dev,
+ 				 void *upper_priv, void *upper_info)
+ {
+ 	return __netdev_upper_dev_link(dev, upper_dev, true,
+ 				       upper_priv, upper_info);
++>>>>>>> 29bf24afb290 (net: add possibility to pass information about upper device via notifier)
  }
  EXPORT_SYMBOL(netdev_master_upper_dev_link);
  
diff --cc net/openvswitch/vport-netdev.c
index 76fcaf1fd2a9,8f4dd4c39bfe..000000000000
--- a/net/openvswitch/vport-netdev.c
+++ b/net/openvswitch/vport-netdev.c
@@@ -105,7 -105,7 +105,11 @@@ struct vport *ovs_netdev_link(struct vp
  
  	rtnl_lock();
  	err = netdev_master_upper_dev_link(vport->dev,
++<<<<<<< HEAD
 +					   get_dpdev(vport->dp));
++=======
+ 					   get_dpdev(vport->dp), NULL, NULL);
++>>>>>>> 29bf24afb290 (net: add possibility to pass information about upper device via notifier)
  	if (err)
  		goto error_unlock;
  
* Unmerged path drivers/net/vrf.c
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/team/team.c
* Unmerged path drivers/net/vrf.c
* Unmerged path include/linux/netdevice.h
* Unmerged path net/batman-adv/hard-interface.c
* Unmerged path net/bridge/br_if.c
* Unmerged path net/core/dev.c
* Unmerged path net/openvswitch/vport-netdev.c
