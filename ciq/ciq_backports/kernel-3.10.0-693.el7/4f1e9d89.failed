net_sched: act: move tcf_hashinfo_init() into tcf_register_action()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: act: move tcf_hashinfo_init() into tcf_register_action() (Ivan Vecera) [1428588]
Rebuild_FUZZ: 96.92%
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit 4f1e9d8949b438c7791993515fc164312e9080e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4f1e9d89.failed

	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Cc: David S. Miller <davem@davemloft.net>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4f1e9d8949b438c7791993515fc164312e9080e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_csum.c
#	net/sched/act_gact.c
#	net/sched/act_ipt.c
#	net/sched/act_mirred.c
#	net/sched/act_nat.c
#	net/sched/act_pedit.c
#	net/sched/act_police.c
#	net/sched/act_simple.c
#	net/sched/act_skbedit.c
diff --cc net/sched/act_csum.c
index 11fe1a416433,edbf40dac709..000000000000
--- a/net/sched/act_csum.c
+++ b/net/sched/act_csum.c
@@@ -37,15 -37,6 +37,18 @@@
  #include <net/tc_act/tc_csum.h>
  
  #define CSUM_TAB_MASK 15
++<<<<<<< HEAD
 +static struct tcf_common *tcf_csum_ht[CSUM_TAB_MASK + 1];
 +static u32 csum_idx_gen;
 +static DEFINE_RWLOCK(csum_lock);
 +
 +static struct tcf_hashinfo csum_hash_info = {
 +	.htab	= tcf_csum_ht,
 +	.hmask	= CSUM_TAB_MASK,
 +	.lock	= &csum_lock,
 +};
++=======
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  
  static const struct nla_policy csum_policy[TCA_CSUM_MAX + 1] = {
  	[TCA_CSUM_PARMS] = { .len = sizeof(struct tc_csum), },
@@@ -578,9 -560,7 +581,8 @@@ nla_put_failure
  
  static struct tc_action_ops act_csum_ops = {
  	.kind		= "csum",
- 	.hinfo		= &csum_hash_info,
  	.type		= TCA_ACT_CSUM,
 +	.capab		= TCA_CAP_NONE,
  	.owner		= THIS_MODULE,
  	.act		= tcf_csum,
  	.dump		= tcf_csum_dump,
@@@ -593,7 -572,7 +595,11 @@@ MODULE_LICENSE("GPL")
  
  static int __init csum_init_module(void)
  {
++<<<<<<< HEAD
 +	return tcf_register_action(&act_csum_ops);
++=======
+ 	return tcf_register_action(&act_csum_ops, CSUM_TAB_MASK);
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  }
  
  static void __exit csum_cleanup_module(void)
diff --cc net/sched/act_gact.c
index eb9ba60ebab4,d6bcbd9f7791..000000000000
--- a/net/sched/act_gact.c
+++ b/net/sched/act_gact.c
@@@ -24,15 -24,6 +24,18 @@@
  #include <net/tc_act/tc_gact.h>
  
  #define GACT_TAB_MASK	15
++<<<<<<< HEAD
 +static struct tcf_common *tcf_gact_ht[GACT_TAB_MASK + 1];
 +static u32 gact_idx_gen;
 +static DEFINE_RWLOCK(gact_lock);
 +
 +static struct tcf_hashinfo gact_hash_info = {
 +	.htab	=	tcf_gact_ht,
 +	.hmask	=	GACT_TAB_MASK,
 +	.lock	=	&gact_lock,
 +};
++=======
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  
  #ifdef CONFIG_GACT_PROB
  static int gact_net_rand(struct tcf_gact *gact)
@@@ -200,9 -179,7 +203,8 @@@ nla_put_failure
  
  static struct tc_action_ops act_gact_ops = {
  	.kind		=	"gact",
- 	.hinfo		=	&gact_hash_info,
  	.type		=	TCA_ACT_GACT,
 +	.capab		=	TCA_CAP_NONE,
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_gact,
  	.dump		=	tcf_gact_dump,
diff --cc net/sched/act_ipt.c
index 90a973aacc76,8a64a0734aee..000000000000
--- a/net/sched/act_ipt.c
+++ b/net/sched/act_ipt.c
@@@ -29,15 -29,6 +29,18 @@@
  
  
  #define IPT_TAB_MASK     15
++<<<<<<< HEAD
 +static struct tcf_common *tcf_ipt_ht[IPT_TAB_MASK + 1];
 +static u32 ipt_idx_gen;
 +static DEFINE_RWLOCK(ipt_lock);
 +
 +static struct tcf_hashinfo ipt_hash_info = {
 +	.htab	=	tcf_ipt_ht,
 +	.hmask	=	IPT_TAB_MASK,
 +	.lock	=	&ipt_lock,
 +};
++=======
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  
  static int ipt_init_target(struct xt_entry_target *t, char *table, unsigned int hook)
  {
@@@ -295,9 -261,7 +298,8 @@@ nla_put_failure
  
  static struct tc_action_ops act_ipt_ops = {
  	.kind		=	"ipt",
- 	.hinfo		=	&ipt_hash_info,
  	.type		=	TCA_ACT_IPT,
 +	.capab		=	TCA_CAP_NONE,
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_ipt,
  	.dump		=	tcf_ipt_dump,
@@@ -307,9 -271,7 +309,13 @@@
  
  static struct tc_action_ops act_xt_ops = {
  	.kind		=	"xt",
++<<<<<<< HEAD
 +	.hinfo		=	&ipt_hash_info,
 +	.type		=	TCA_ACT_IPT,
 +	.capab		=	TCA_CAP_NONE,
++=======
+ 	.type		=	TCA_ACT_XT,
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_ipt,
  	.dump		=	tcf_ipt_dump,
@@@ -325,16 -287,17 +331,25 @@@ MODULE_ALIAS("act_xt")
  static int __init ipt_init_module(void)
  {
  	int ret1, ret2;
++<<<<<<< HEAD
 +	ret1 = tcf_register_action(&act_xt_ops);
++=======
+ 
+ 	ret1 = tcf_register_action(&act_xt_ops, IPT_TAB_MASK);
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  	if (ret1 < 0)
  		printk("Failed to load xt action\n");
- 	ret2 = tcf_register_action(&act_ipt_ops);
+ 	ret2 = tcf_register_action(&act_ipt_ops, IPT_TAB_MASK);
  	if (ret2 < 0)
  		printk("Failed to load ipt action\n");
  
++<<<<<<< HEAD
 +	if (ret1 < 0 && ret2 < 0)
++=======
+ 	if (ret1 < 0 && ret2 < 0) {
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  		return ret1;
 -	} else
 +	else
  		return 0;
  }
  
diff --cc net/sched/act_mirred.c
index 3ff85aed0e67,4f912c0e225b..000000000000
--- a/net/sched/act_mirred.c
+++ b/net/sched/act_mirred.c
@@@ -261,12 -231,9 +261,11 @@@ static struct notifier_block mirred_dev
  	.notifier_call = mirred_device_event,
  };
  
 +
  static struct tc_action_ops act_mirred_ops = {
  	.kind		=	"mirred",
- 	.hinfo		=	&mirred_hash_info,
  	.type		=	TCA_ACT_MIRRED,
 +	.capab		=	TCA_CAP_NONE,
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_mirred,
  	.dump		=	tcf_mirred_dump,
@@@ -290,8 -257,8 +289,12 @@@ static int __init mirred_init_module(vo
  
  static void __exit mirred_cleanup_module(void)
  {
 +	unregister_netdevice_notifier_rh(&mirred_device_notifier);
  	tcf_unregister_action(&act_mirred_ops);
++<<<<<<< HEAD
++=======
+ 	unregister_netdevice_notifier(&mirred_device_notifier);
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  }
  
  module_init(mirred_init_module);
diff --cc net/sched/act_nat.c
index 76869538d028,270a030d5fd0..000000000000
--- a/net/sched/act_nat.c
+++ b/net/sched/act_nat.c
@@@ -30,16 -30,7 +30,19 @@@
  
  
  #define NAT_TAB_MASK	15
 +static struct tcf_common *tcf_nat_ht[NAT_TAB_MASK + 1];
 +static u32 nat_idx_gen;
 +static DEFINE_RWLOCK(nat_lock);
 +
++<<<<<<< HEAD
 +static struct tcf_hashinfo nat_hash_info = {
 +	.htab	=	tcf_nat_ht,
 +	.hmask	=	NAT_TAB_MASK,
 +	.lock	=	&nat_lock,
 +};
  
++=======
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  static const struct nla_policy nat_policy[TCA_NAT_MAX + 1] = {
  	[TCA_NAT_PARMS]	= { .len = sizeof(struct tc_nat) },
  };
@@@ -301,9 -282,7 +304,8 @@@ nla_put_failure
  
  static struct tc_action_ops act_nat_ops = {
  	.kind		=	"nat",
- 	.hinfo		=	&nat_hash_info,
  	.type		=	TCA_ACT_NAT,
 +	.capab		=	TCA_CAP_NONE,
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_nat,
  	.dump		=	tcf_nat_dump,
@@@ -316,7 -294,7 +318,11 @@@ MODULE_LICENSE("GPL")
  
  static int __init nat_init_module(void)
  {
++<<<<<<< HEAD
 +	return tcf_register_action(&act_nat_ops);
++=======
+ 	return tcf_register_action(&act_nat_ops, NAT_TAB_MASK);
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  }
  
  static void __exit nat_cleanup_module(void)
diff --cc net/sched/act_pedit.c
index 7aa2dcd989f8,5f9bcb2e080b..000000000000
--- a/net/sched/act_pedit.c
+++ b/net/sched/act_pedit.c
@@@ -24,16 -24,7 +24,19 @@@
  #include <net/tc_act/tc_pedit.h>
  
  #define PEDIT_TAB_MASK	15
 +static struct tcf_common *tcf_pedit_ht[PEDIT_TAB_MASK + 1];
 +static u32 pedit_idx_gen;
 +static DEFINE_RWLOCK(pedit_lock);
 +
++<<<<<<< HEAD
 +static struct tcf_hashinfo pedit_hash_info = {
 +	.htab	=	tcf_pedit_ht,
 +	.hmask	=	PEDIT_TAB_MASK,
 +	.lock	=	&pedit_lock,
 +};
  
++=======
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  static const struct nla_policy pedit_policy[TCA_PEDIT_MAX + 1] = {
  	[TCA_PEDIT_PARMS]	= { .len = sizeof(struct tc_pedit) },
  };
@@@ -238,9 -216,7 +241,8 @@@ nla_put_failure
  
  static struct tc_action_ops act_pedit_ops = {
  	.kind		=	"pedit",
- 	.hinfo		=	&pedit_hash_info,
  	.type		=	TCA_ACT_PEDIT,
 +	.capab		=	TCA_CAP_NONE,
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_pedit,
  	.dump		=	tcf_pedit_dump,
@@@ -254,7 -230,7 +256,11 @@@ MODULE_LICENSE("GPL")
  
  static int __init pedit_init_module(void)
  {
++<<<<<<< HEAD
 +	return tcf_register_action(&act_pedit_ops);
++=======
+ 	return tcf_register_action(&act_pedit_ops, PEDIT_TAB_MASK);
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  }
  
  static void __exit pedit_cleanup_module(void)
diff --cc net/sched/act_police.c
index 376c02554325,0566e4606a4a..000000000000
--- a/net/sched/act_police.c
+++ b/net/sched/act_police.c
@@@ -41,15 -41,6 +41,18 @@@ struct tcf_police 
  	container_of(pc, struct tcf_police, common)
  
  #define POL_TAB_MASK     15
++<<<<<<< HEAD
 +static struct tcf_common *tcf_police_ht[POL_TAB_MASK + 1];
 +static u32 police_idx_gen;
 +static DEFINE_RWLOCK(police_lock);
 +
 +static struct tcf_hashinfo police_hash_info = {
 +	.htab	=	tcf_police_ht,
 +	.hmask	=	POL_TAB_MASK,
 +	.lock	=	&police_lock,
 +};
++=======
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  
  /* old policer structure from before tc actions */
  struct tc_police_compat {
@@@ -264,14 -231,13 +267,18 @@@ override
  	if (ret != ACT_P_CREATED)
  		return ret;
  
 -	police->tcfp_t_c = ktime_to_ns(ktime_get());
 +	police->tcfp_t_c = ktime_get_ns();
  	police->tcf_index = parm->index ? parm->index :
++<<<<<<< HEAD
 +		tcf_hash_new_index(&police_idx_gen, &police_hash_info);
++=======
+ 		tcf_hash_new_index(hinfo);
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  	h = tcf_hash(police->tcf_index, POL_TAB_MASK);
 -	spin_lock_bh(&hinfo->lock);
 -	hlist_add_head(&police->tcf_head, &hinfo->htab[h]);
 -	spin_unlock_bh(&hinfo->lock);
 +	write_lock_bh(&police_lock);
 +	police->tcf_next = tcf_police_ht[h];
 +	tcf_police_ht[h] = &police->common;
 +	write_unlock_bh(&police_lock);
  
  	a->priv = police;
  	return ret;
@@@ -402,9 -348,7 +409,8 @@@ MODULE_LICENSE("GPL")
  
  static struct tc_action_ops act_police_ops = {
  	.kind		=	"police",
- 	.hinfo		=	&police_hash_info,
  	.type		=	TCA_ID_POLICE,
 +	.capab		=	TCA_CAP_NONE,
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_act_police,
  	.dump		=	tcf_act_police_dump,
@@@ -416,7 -359,7 +422,11 @@@
  static int __init
  police_init_module(void)
  {
++<<<<<<< HEAD
 +	return tcf_register_action(&act_police_ops);
++=======
+ 	return tcf_register_action(&act_police_ops, POL_TAB_MASK);
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  }
  
  static void __exit
diff --cc net/sched/act_simple.c
index f7b45ab85388,992c2317ce88..000000000000
--- a/net/sched/act_simple.c
+++ b/net/sched/act_simple.c
@@@ -25,15 -25,6 +25,18 @@@
  #include <net/tc_act/tc_defact.h>
  
  #define SIMP_TAB_MASK     7
++<<<<<<< HEAD
 +static struct tcf_common *tcf_simp_ht[SIMP_TAB_MASK + 1];
 +static u32 simp_idx_gen;
 +static DEFINE_RWLOCK(simp_lock);
 +
 +static struct tcf_hashinfo simp_hash_info = {
 +	.htab	=	tcf_simp_ht,
 +	.hmask	=	SIMP_TAB_MASK,
 +	.lock	=	&simp_lock,
 +};
++=======
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  
  #define SIMP_MAX_DATA	32
  static int tcf_simp(struct sk_buff *skb, const struct tc_action *a,
@@@ -196,9 -162,7 +199,8 @@@ nla_put_failure
  
  static struct tc_action_ops act_simp_ops = {
  	.kind		=	"simple",
- 	.hinfo		=	&simp_hash_info,
  	.type		=	TCA_ACT_SIMP,
 +	.capab		=	TCA_CAP_NONE,
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_simp,
  	.dump		=	tcf_simp_dump,
@@@ -212,7 -176,8 +214,12 @@@ MODULE_LICENSE("GPL")
  
  static int __init simp_init_module(void)
  {
++<<<<<<< HEAD
 +	int ret = tcf_register_action(&act_simp_ops);
++=======
+ 	int ret;
+ 	ret = tcf_register_action(&act_simp_ops, SIMP_TAB_MASK);
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  	if (!ret)
  		pr_info("Simple TC action Loaded\n");
  	return ret;
diff --cc net/sched/act_skbedit.c
index 8fe9d25c3008,fcfeeaf838be..000000000000
--- a/net/sched/act_skbedit.c
+++ b/net/sched/act_skbedit.c
@@@ -29,15 -28,6 +29,18 @@@
  #include <net/tc_act/tc_skbedit.h>
  
  #define SKBEDIT_TAB_MASK     15
++<<<<<<< HEAD
 +static struct tcf_common *tcf_skbedit_ht[SKBEDIT_TAB_MASK + 1];
 +static u32 skbedit_idx_gen;
 +static DEFINE_RWLOCK(skbedit_lock);
 +
 +static struct tcf_hashinfo skbedit_hash_info = {
 +	.htab	=	tcf_skbedit_ht,
 +	.hmask	=	SKBEDIT_TAB_MASK,
 +	.lock	=	&skbedit_lock,
 +};
++=======
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  
  static int tcf_skbedit(struct sk_buff *skb, const struct tc_action *a,
  		       struct tcf_result *res)
@@@ -196,9 -174,7 +199,8 @@@ nla_put_failure
  
  static struct tc_action_ops act_skbedit_ops = {
  	.kind		=	"skbedit",
- 	.hinfo		=	&skbedit_hash_info,
  	.type		=	TCA_ACT_SKBEDIT,
 +	.capab		=	TCA_CAP_NONE,
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_skbedit,
  	.dump		=	tcf_skbedit_dump,
@@@ -212,7 -187,7 +214,11 @@@ MODULE_LICENSE("GPL")
  
  static int __init skbedit_init_module(void)
  {
++<<<<<<< HEAD
 +	return tcf_register_action(&act_skbedit_ops);
++=======
+ 	return tcf_register_action(&act_skbedit_ops, SKBEDIT_TAB_MASK);
++>>>>>>> 4f1e9d8949b4 (net_sched: act: move tcf_hashinfo_init() into tcf_register_action())
  }
  
  static void __exit skbedit_cleanup_module(void)
diff --git a/include/net/act_api.h b/include/net/act_api.h
index 11aac9abd0ca..eaa2e61cb505 100644
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@ -90,7 +90,7 @@ struct tcf_common *tcf_hash_create(u32 index, struct nlattr *est,
 				   struct tcf_hashinfo *hinfo);
 void tcf_hash_insert(struct tcf_common *p, struct tcf_hashinfo *hinfo);
 
-int tcf_register_action(struct tc_action_ops *a);
+int tcf_register_action(struct tc_action_ops *a, unsigned int mask);
 int tcf_unregister_action(struct tc_action_ops *a);
 void tcf_action_destroy(struct list_head *actions, int bind);
 int tcf_action_exec(struct sk_buff *skb, const struct list_head *actions,
diff --git a/net/sched/act_api.c b/net/sched/act_api.c
index 34e255487d7a..9959b0968065 100644
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@ -265,9 +265,10 @@ EXPORT_SYMBOL(tcf_hash_insert);
 static LIST_HEAD(act_base);
 static DEFINE_RWLOCK(act_mod_lock);
 
-int tcf_register_action(struct tc_action_ops *act)
+int tcf_register_action(struct tc_action_ops *act, unsigned int mask)
 {
 	struct tc_action_ops *a;
+	int err;
 
 	/* Must supply act, dump, cleanup and init */
 	if (!act->act || !act->dump || !act->cleanup || !act->init)
@@ -279,10 +280,21 @@ int tcf_register_action(struct tc_action_ops *act)
 	if (!act->walk)
 		act->walk = tcf_generic_walker;
 
+	act->hinfo = kmalloc(sizeof(struct tcf_hashinfo), GFP_KERNEL);
+	if (!act->hinfo)
+		return -ENOMEM;
+	err = tcf_hashinfo_init(act->hinfo, mask);
+	if (err) {
+		kfree(act->hinfo);
+		return err;
+	}
+
 	write_lock(&act_mod_lock);
 	list_for_each_entry(a, &act_base, head) {
 		if (act->type == a->type || (strcmp(act->kind, a->kind) == 0)) {
 			write_unlock(&act_mod_lock);
+			tcf_hashinfo_destroy(act->hinfo);
+			kfree(act->hinfo);
 			return -EEXIST;
 		}
 	}
@@ -301,6 +313,8 @@ int tcf_unregister_action(struct tc_action_ops *act)
 	list_for_each_entry(a, &act_base, head) {
 		if (a == act) {
 			list_del(&act->head);
+			tcf_hashinfo_destroy(act->hinfo);
+			kfree(act->hinfo);
 			err = 0;
 			break;
 		}
* Unmerged path net/sched/act_csum.c
* Unmerged path net/sched/act_gact.c
* Unmerged path net/sched/act_ipt.c
* Unmerged path net/sched/act_mirred.c
* Unmerged path net/sched/act_nat.c
* Unmerged path net/sched/act_pedit.c
* Unmerged path net/sched/act_police.c
* Unmerged path net/sched/act_simple.c
* Unmerged path net/sched/act_skbedit.c
