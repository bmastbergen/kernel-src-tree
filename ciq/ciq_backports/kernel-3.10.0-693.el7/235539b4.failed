kvm: add stubs for arch specific debugfs support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Luiz Capitulino <lcapitulino@redhat.com>
commit 235539b48a2357da28f52d66d04bec04f3dcb9dd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/235539b4.failed

Two stubs are added:

 o kvm_arch_has_vcpu_debugfs(): must return true if the arch
   supports creating debugfs entries in the vcpu debugfs dir
   (which will be implemented by the next commit)

 o kvm_arch_create_vcpu_debugfs(): code that creates debugfs
   entries in the vcpu debugfs dir

For x86, this commit introduces a new file to avoid growing
arch/x86/kvm/x86.c even more.

	Signed-off-by: Luiz Capitulino <lcapitulino@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 235539b48a2357da28f52d66d04bec04f3dcb9dd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/mips/kvm/mips.c
#	arch/x86/kvm/Makefile
diff --cc arch/x86/kvm/Makefile
index 167ae65a0c98,3bff20710471..000000000000
--- a/arch/x86/kvm/Makefile
+++ b/arch/x86/kvm/Makefile
@@@ -12,10 -12,11 +12,15 @@@ kvm-y			+= $(KVM)/kvm_main.o $(KVM)/coa
  kvm-$(CONFIG_KVM_ASYNC_PF)	+= $(KVM)/async_pf.o
  
  kvm-y			+= x86.o mmu.o emulate.o i8259.o irq.o lapic.o \
++<<<<<<< HEAD
 +			   i8254.o ioapic.o irq_comm.o cpuid.o pmu.o \
 +			   hyperv.o
++=======
+ 			   i8254.o ioapic.o irq_comm.o cpuid.o pmu.o mtrr.o \
+ 			   hyperv.o page_track.o debugfs.o
++>>>>>>> 235539b48a23 (kvm: add stubs for arch specific debugfs support)
  
  kvm-$(CONFIG_KVM_DEVICE_ASSIGNMENT)	+= assigned-dev.o iommu.o
 -
  kvm-intel-y		+= vmx.o pmu_intel.o
  kvm-amd-y		+= svm.o pmu_amd.o
  
* Unmerged path arch/mips/kvm/mips.c
diff --git a/arch/arm/kvm/arm.c b/arch/arm/kvm/arm.c
index 66df4c62bc78..0f97e8848f54 100644
--- a/arch/arm/kvm/arm.c
+++ b/arch/arm/kvm/arm.c
@@ -147,6 +147,16 @@ out_fail_alloc:
 	return ret;
 }
 
+bool kvm_arch_has_vcpu_debugfs(void)
+{
+	return false;
+}
+
+int kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
 int kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)
 {
 	return VM_FAULT_SIGBUS;
* Unmerged path arch/mips/kvm/mips.c
diff --git a/arch/powerpc/kvm/powerpc.c b/arch/powerpc/kvm/powerpc.c
index 64a0fde48c79..39fe43617efe 100644
--- a/arch/powerpc/kvm/powerpc.c
+++ b/arch/powerpc/kvm/powerpc.c
@@ -441,6 +441,16 @@ err_out:
 	return -EINVAL;
 }
 
+bool kvm_arch_has_vcpu_debugfs(void)
+{
+	return false;
+}
+
+int kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
 void kvm_arch_destroy_vm(struct kvm *kvm)
 {
 	unsigned int i;
diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c
index e79f2bd2e6d5..9b2d6973d202 100644
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@ -293,6 +293,16 @@ out_err:
 	return rc;
 }
 
+bool kvm_arch_has_vcpu_debugfs(void)
+{
+	return false;
+}
+
+int kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
 void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
 {
 	VCPU_EVENT(vcpu, 3, "%s", "free cpu");
* Unmerged path arch/x86/kvm/Makefile
diff --git a/arch/x86/kvm/debugfs.c b/arch/x86/kvm/debugfs.c
new file mode 100644
index 000000000000..bb5e9f635dde
--- /dev/null
+++ b/arch/x86/kvm/debugfs.c
@@ -0,0 +1,20 @@
+/*
+ * Kernel-based Virtual Machine driver for Linux
+ *
+ * Copyright 2016 Red Hat, Inc. and/or its affiliates.
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.  See
+ * the COPYING file in the top-level directory.
+ *
+ */
+#include <linux/kvm_host.h>
+
+bool kvm_arch_has_vcpu_debugfs(void)
+{
+	return false;
+}
+
+int kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index d93fbbc9561f..2f313d1eba45 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -716,6 +716,9 @@ int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu);
 void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu);
 void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu);
 
+bool kvm_arch_has_vcpu_debugfs(void);
+int kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu);
+
 int kvm_arch_hardware_enable(void);
 void kvm_arch_hardware_disable(void);
 int kvm_arch_hardware_setup(void);
