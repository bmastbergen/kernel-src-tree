net/mlx5: E-Switch, Allow fine tuning of eswitch vport push/pop vlan

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Allow fine tuning of eswitch vport push/pop vlan (Don Dutile) [1385330 1417285]
Rebuild_FUZZ: 96.97%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit e33dfe316cf3b408e63bf0c21be0842412eb7981
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e33dfe31.failed

The HW can be programmed to push vlan, pop vlan or both.

A factorization step towards using the push/pop capabilties in the
eswitch offloads mode. This patch doesn't add new functionality.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e33dfe316cf3b408e63bf0c21be0842412eb7981)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 084178cfa483,abbf2c369923..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -205,22 -127,22 +205,31 @@@ static int modify_esw_vport_context_cmd
  }
  
  static int modify_esw_vport_cvlan(struct mlx5_core_dev *dev, u32 vport,
- 				  u16 vlan, u8 qos, bool set)
+ 				  u16 vlan, u8 qos, u8 set_flags)
  {
 -	u32 in[MLX5_ST_SZ_DW(modify_esw_vport_context_in)] = {0};
 +	u32 in[MLX5_ST_SZ_DW(modify_esw_vport_context_in)];
 +
 +	memset(in, 0, sizeof(in));
  
  	if (!MLX5_CAP_ESW(dev, vport_cvlan_strip) ||
  	    !MLX5_CAP_ESW(dev, vport_cvlan_insert_if_not_exist))
  		return -ENOTSUPP;
  
++<<<<<<< HEAD
 +	esw_debug(dev, "Set Vport[%d] VLAN %d qos %d set=%d\n",
 +		  vport, vlan, qos, set);
 +
 +	if (set) {
++=======
+ 	esw_debug(dev, "Set Vport[%d] VLAN %d qos %d set=%x\n",
+ 		  vport, vlan, qos, set_flags);
+ 
+ 	if (set_flags & SET_VLAN_STRIP)
++>>>>>>> e33dfe316cf3 (net/mlx5: E-Switch, Allow fine tuning of eswitch vport push/pop vlan)
  		MLX5_SET(modify_esw_vport_context_in, in,
  			 esw_vport_context.vport_cvlan_strip, 1);
+ 
+ 	if (set_flags & SET_VLAN_INSERT) {
  		/* insert only if no vlan in packet */
  		MLX5_SET(modify_esw_vport_context_in, in,
  			 esw_vport_context.vport_cvlan_insert, 1);
@@@ -1522,22 -1793,19 +1531,26 @@@ int __mlx5_eswitch_set_vport_vlan(struc
  	if (!LEGAL_VPORT(esw, vport) || (vlan > 4095) || (qos > 7))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (vlan || qos)
 +		set = 1;
 +
++=======
+ 	mutex_lock(&esw->state_lock);
++>>>>>>> e33dfe316cf3 (net/mlx5: E-Switch, Allow fine tuning of eswitch vport push/pop vlan)
  	evport = &esw->vports[vport];
  
- 	err = modify_esw_vport_cvlan(esw->dev, vport, vlan, qos, set);
+ 	err = modify_esw_vport_cvlan(esw->dev, vport, vlan, qos, set_flags);
  	if (err)
 -		goto unlock;
 +		return err;
  
 -	evport->info.vlan = vlan;
 -	evport->info.qos = qos;
 -	if (evport->enabled && esw->mode == SRIOV_LEGACY) {
 +	mutex_lock(&esw->state_lock);
 +	evport->vlan = vlan;
 +	evport->qos = qos;
 +	if (evport->enabled) {
  		err = esw_vport_ingress_config(esw, evport);
  		if (err)
 -			goto unlock;
 +			goto out;
  		err = esw_vport_egress_config(esw, evport);
  	}
  
@@@ -1546,6 -1814,62 +1559,65 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ int mlx5_eswitch_set_vport_vlan(struct mlx5_eswitch *esw,
+ 				int vport, u16 vlan, u8 qos)
+ {
+ 	u8 set_flags = 0;
+ 
+ 	if (vlan || qos)
+ 		set_flags = SET_VLAN_STRIP | SET_VLAN_INSERT;
+ 
+ 	return __mlx5_eswitch_set_vport_vlan(esw, vport, vlan, qos, set_flags);
+ }
+ 
+ int mlx5_eswitch_set_vport_spoofchk(struct mlx5_eswitch *esw,
+ 				    int vport, bool spoofchk)
+ {
+ 	struct mlx5_vport *evport;
+ 	bool pschk;
+ 	int err = 0;
+ 
+ 	if (!ESW_ALLOWED(esw))
+ 		return -EPERM;
+ 	if (!LEGAL_VPORT(esw, vport))
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&esw->state_lock);
+ 	evport = &esw->vports[vport];
+ 	pschk = evport->info.spoofchk;
+ 	evport->info.spoofchk = spoofchk;
+ 	if (evport->enabled && esw->mode == SRIOV_LEGACY)
+ 		err = esw_vport_ingress_config(esw, evport);
+ 	if (err)
+ 		evport->info.spoofchk = pschk;
+ 	mutex_unlock(&esw->state_lock);
+ 
+ 	return err;
+ }
+ 
+ int mlx5_eswitch_set_vport_trust(struct mlx5_eswitch *esw,
+ 				 int vport, bool setting)
+ {
+ 	struct mlx5_vport *evport;
+ 
+ 	if (!ESW_ALLOWED(esw))
+ 		return -EPERM;
+ 	if (!LEGAL_VPORT(esw, vport))
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&esw->state_lock);
+ 	evport = &esw->vports[vport];
+ 	evport->info.trusted = setting;
+ 	if (evport->enabled)
+ 		esw_vport_change_handle_locked(evport);
+ 	mutex_unlock(&esw->state_lock);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> e33dfe316cf3 (net/mlx5: E-Switch, Allow fine tuning of eswitch vport push/pop vlan)
  int mlx5_eswitch_get_vport_stats(struct mlx5_eswitch *esw,
  				 int vport,
  				 struct ifla_vf_stats *vf_stats)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 7b5e70f8cc22,4f5391a7965a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -170,4 -237,42 +170,45 @@@ int mlx5_eswitch_get_vport_stats(struc
  				 int vport,
  				 struct ifla_vf_stats *vf_stats);
  
++<<<<<<< HEAD
++=======
+ struct mlx5_flow_spec;
+ 
+ struct mlx5_flow_rule *
+ mlx5_eswitch_add_offloaded_rule(struct mlx5_eswitch *esw,
+ 				struct mlx5_flow_spec *spec,
+ 				u32 action, u32 src_vport, u32 dst_vport);
+ struct mlx5_flow_rule *
+ mlx5_eswitch_create_vport_rx_rule(struct mlx5_eswitch *esw, int vport, u32 tirn);
+ 
+ enum {
+ 	SET_VLAN_STRIP	= BIT(0),
+ 	SET_VLAN_INSERT	= BIT(1)
+ };
+ 
+ int mlx5_eswitch_sqs2vport_start(struct mlx5_eswitch *esw,
+ 				 struct mlx5_eswitch_rep *rep,
+ 				 u16 *sqns_array, int sqns_num);
+ void mlx5_eswitch_sqs2vport_stop(struct mlx5_eswitch *esw,
+ 				 struct mlx5_eswitch_rep *rep);
+ 
+ int mlx5_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode);
+ int mlx5_devlink_eswitch_mode_get(struct devlink *devlink, u16 *mode);
+ void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
+ 				     int vport_index,
+ 				     struct mlx5_eswitch_rep *rep);
+ void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
+ 				       int vport_index);
+ 
+ #define MLX5_DEBUG_ESWITCH_MASK BIT(3)
+ 
+ #define esw_info(dev, format, ...)				\
+ 	pr_info("(%s): E-Switch: " format, (dev)->priv.name, ##__VA_ARGS__)
+ 
+ #define esw_warn(dev, format, ...)				\
+ 	pr_warn("(%s): E-Switch: " format, (dev)->priv.name, ##__VA_ARGS__)
+ 
+ #define esw_debug(dev, format, ...)				\
+ 	mlx5_core_dbg_mask(dev, MLX5_DEBUG_ESWITCH_MASK, format, ##__VA_ARGS__)
++>>>>>>> e33dfe316cf3 (net/mlx5: E-Switch, Allow fine tuning of eswitch vport push/pop vlan)
  #endif /* __MLX5_ESWITCH_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
