PCI: Enable access to non-standard VPD for Chelsio devices (cxgb3)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [pci] Enable access to non-standard VPD for Chelsio devices (Sai Vemuri) [1241921]
Rebuild_FUZZ: 89.08%
commit-author Alexey Kardashevskiy <aik@ozlabs.ru>
commit 1c7de2b4ff886a45fbd2f4c3d4627e0f37a9dd77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1c7de2b4.failed

There is at least one Chelsio 10Gb card which uses VPD area to store some
non-standard blocks (example below).  However pci_vpd_size() returns the
length of the first block only assuming that there can be only one VPD "End
Tag".

Since 4e1a635552d3 ("vfio/pci: Use kernel VPD access functions"), VFIO
blocks access beyond that offset, which prevents the guest "cxgb3" driver
from probing the device.  The host system does not have this problem as its
driver accesses the config space directly without pci_read_vpd().

Add a quirk to override the VPD size to a bigger value.  The maximum size
is taken from EEPROMSIZE in drivers/net/ethernet/chelsio/cxgb3/common.h.
We do not read the tag as the cxgb3 driver does as the driver supports
writing to EEPROM/VPD and when it writes, it only checks for 8192 bytes
boundary.  The quirk is registered for all devices supported by the cxgb3
driver.

This adds a quirk to the PCI layer (not to the cxgb3 driver) as the cxgb3
driver itself accesses VPD directly and the problem only exists with the
vfio-pci driver (when cxgb3 is not running on the host and may not be even
loaded) which blocks accesses beyond the first block of VPD data.  However
vfio-pci itself does not have quirks mechanism so we add it to PCI.

This is the controller:
Ethernet controller [0200]: Chelsio Communications Inc T310 10GbE Single Port Adapter [1425:0030]

This is what I parsed from its VPD:
===
b'\x82*\x0010 Gigabit Ethernet-SR PCI Express Adapter\x90J\x00EC\x07D76809 FN\x0746K'
 0000 Large item 42 bytes; name 0x2 Identifier String
	b'10 Gigabit Ethernet-SR PCI Express Adapter'
 002d Large item 74 bytes; name 0x10
	#00 [EC] len=7: b'D76809 '
	#0a [FN] len=7: b'46K7897'
	#14 [PN] len=7: b'46K7897'
	#1e [MN] len=4: b'1037'
	#25 [FC] len=4: b'5769'
	#2c [SN] len=12: b'YL102035603V'
	#3b [NA] len=12: b'00145E992ED1'
 007a Small item 1 bytes; name 0xf End Tag

 0c00 Large item 16 bytes; name 0x2 Identifier String
	b'S310E-SR-X      '
 0c13 Large item 234 bytes; name 0x10
	#00 [PN] len=16: b'TBD             '
	#13 [EC] len=16: b'110107730D2     '
	#26 [SN] len=16: b'97YL102035603V  '
	#39 [NA] len=12: b'00145E992ED1'
	#48 [V0] len=6: b'175000'
	#51 [V1] len=6: b'266666'
	#5a [V2] len=6: b'266666'
	#63 [V3] len=6: b'2000  '
	#6c [V4] len=2: b'1 '
	#71 [V5] len=6: b'c2    '
	#7a [V6] len=6: b'0     '
	#83 [V7] len=2: b'1 '
	#88 [V8] len=2: b'0 '
	#8d [V9] len=2: b'0 '
	#92 [VA] len=2: b'0 '
	#97 [RV] len=80: b's\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'...
 0d00 Large item 252 bytes; name 0x11
	#00 [VC] len=16: b'122310_1222 dp  '
	#13 [VD] len=16: b'610-0001-00 H1\x00\x00'
	#26 [VE] len=16: b'122310_1353 fp  '
	#39 [VF] len=16: b'610-0001-00 H1\x00\x00'
	#4c [RW] len=173: b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'...
 0dff Small item 0 bytes; name 0xf End Tag

10f3 Large item 13315 bytes; name 0x62
!!! unknown item name 98: b'\xd0\x03\x00@`\x0c\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00'
===

	Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 1c7de2b4ff886a45fbd2f4c3d4627e0f37a9dd77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/quirks.c
diff --cc drivers/pci/quirks.c
index b0a778f02014,bdc23ce2cd42..000000000000
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@@ -3207,6 -3232,156 +3207,159 @@@ static void quirk_no_pm_reset(struct pc
  DECLARE_PCI_FIXUP_CLASS_HEADER(PCI_VENDOR_ID_ATI, PCI_ANY_ID,
  			       PCI_CLASS_DISPLAY_VGA, 8, quirk_no_pm_reset);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Thunderbolt controllers with broken MSI hotplug signaling:
+  * Entire 1st generation (Light Ridge, Eagle Ridge, Light Peak) and part
+  * of the 2nd generation (Cactus Ridge 4C up to revision 1, Port Ridge).
+  */
+ static void quirk_thunderbolt_hotplug_msi(struct pci_dev *pdev)
+ {
+ 	if (pdev->is_hotplug_bridge &&
+ 	    (pdev->device != PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C ||
+ 	     pdev->revision <= 1))
+ 		pdev->no_msi = 1;
+ }
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_LIGHT_RIDGE,
+ 			quirk_thunderbolt_hotplug_msi);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_EAGLE_RIDGE,
+ 			quirk_thunderbolt_hotplug_msi);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_LIGHT_PEAK,
+ 			quirk_thunderbolt_hotplug_msi);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C,
+ 			quirk_thunderbolt_hotplug_msi);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PORT_RIDGE,
+ 			quirk_thunderbolt_hotplug_msi);
+ 
+ static void quirk_chelsio_extend_vpd(struct pci_dev *dev)
+ {
+ 	pci_set_vpd_size(dev, 8192);
+ }
+ 
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x20, quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x21, quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x22, quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x23, quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x24, quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x25, quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x26, quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x30, quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x31, quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x32, quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x35, quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x36, quirk_chelsio_extend_vpd);
+ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CHELSIO, 0x37, quirk_chelsio_extend_vpd);
+ 
+ #ifdef CONFIG_ACPI
+ /*
+  * Apple: Shutdown Cactus Ridge Thunderbolt controller.
+  *
+  * On Apple hardware the Cactus Ridge Thunderbolt controller needs to be
+  * shutdown before suspend. Otherwise the native host interface (NHI) will not
+  * be present after resume if a device was plugged in before suspend.
+  *
+  * The thunderbolt controller consists of a pcie switch with downstream
+  * bridges leading to the NHI and to the tunnel pci bridges.
+  *
+  * This quirk cuts power to the whole chip. Therefore we have to apply it
+  * during suspend_noirq of the upstream bridge.
+  *
+  * Power is automagically restored before resume. No action is needed.
+  */
+ static void quirk_apple_poweroff_thunderbolt(struct pci_dev *dev)
+ {
+ 	acpi_handle bridge, SXIO, SXFP, SXLV;
+ 
+ 	if (!dmi_match(DMI_BOARD_VENDOR, "Apple Inc."))
+ 		return;
+ 	if (pci_pcie_type(dev) != PCI_EXP_TYPE_UPSTREAM)
+ 		return;
+ 	bridge = ACPI_HANDLE(&dev->dev);
+ 	if (!bridge)
+ 		return;
+ 	/*
+ 	 * SXIO and SXLV are present only on machines requiring this quirk.
+ 	 * TB bridges in external devices might have the same device id as those
+ 	 * on the host, but they will not have the associated ACPI methods. This
+ 	 * implicitly checks that we are at the right bridge.
+ 	 */
+ 	if (ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXIO", &SXIO))
+ 	    || ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXFP", &SXFP))
+ 	    || ACPI_FAILURE(acpi_get_handle(bridge, "DSB0.NHI0.SXLV", &SXLV)))
+ 		return;
+ 	dev_info(&dev->dev, "quirk: cutting power to thunderbolt controller...\n");
+ 
+ 	/* magic sequence */
+ 	acpi_execute_simple_method(SXIO, NULL, 1);
+ 	acpi_execute_simple_method(SXFP, NULL, 0);
+ 	msleep(300);
+ 	acpi_execute_simple_method(SXLV, NULL, 0);
+ 	acpi_execute_simple_method(SXIO, NULL, 0);
+ 	acpi_execute_simple_method(SXLV, NULL, 0);
+ }
+ DECLARE_PCI_FIXUP_SUSPEND_LATE(PCI_VENDOR_ID_INTEL,
+ 			       PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C,
+ 			       quirk_apple_poweroff_thunderbolt);
+ 
+ /*
+  * Apple: Wait for the thunderbolt controller to reestablish pci tunnels.
+  *
+  * During suspend the thunderbolt controller is reset and all pci
+  * tunnels are lost. The NHI driver will try to reestablish all tunnels
+  * during resume. We have to manually wait for the NHI since there is
+  * no parent child relationship between the NHI and the tunneled
+  * bridges.
+  */
+ static void quirk_apple_wait_for_thunderbolt(struct pci_dev *dev)
+ {
+ 	struct pci_dev *sibling = NULL;
+ 	struct pci_dev *nhi = NULL;
+ 
+ 	if (!dmi_match(DMI_BOARD_VENDOR, "Apple Inc."))
+ 		return;
+ 	if (pci_pcie_type(dev) != PCI_EXP_TYPE_DOWNSTREAM)
+ 		return;
+ 	/*
+ 	 * Find the NHI and confirm that we are a bridge on the tb host
+ 	 * controller and not on a tb endpoint.
+ 	 */
+ 	sibling = pci_get_slot(dev->bus, 0x0);
+ 	if (sibling == dev)
+ 		goto out; /* we are the downstream bridge to the NHI */
+ 	if (!sibling || !sibling->subordinate)
+ 		goto out;
+ 	nhi = pci_get_slot(sibling->subordinate, 0x0);
+ 	if (!nhi)
+ 		goto out;
+ 	if (nhi->vendor != PCI_VENDOR_ID_INTEL
+ 		    || (nhi->device != PCI_DEVICE_ID_INTEL_LIGHT_RIDGE &&
+ 			nhi->device != PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C &&
+ 			nhi->device != PCI_DEVICE_ID_INTEL_FALCON_RIDGE_2C_NHI &&
+ 			nhi->device != PCI_DEVICE_ID_INTEL_FALCON_RIDGE_4C_NHI)
+ 		    || nhi->class != PCI_CLASS_SYSTEM_OTHER << 8)
+ 		goto out;
+ 	dev_info(&dev->dev, "quirk: waiting for thunderbolt to reestablish PCI tunnels...\n");
+ 	device_pm_wait_for_dev(&dev->dev, &nhi->dev);
+ out:
+ 	pci_dev_put(nhi);
+ 	pci_dev_put(sibling);
+ }
+ DECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,
+ 			       PCI_DEVICE_ID_INTEL_LIGHT_RIDGE,
+ 			       quirk_apple_wait_for_thunderbolt);
+ DECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,
+ 			       PCI_DEVICE_ID_INTEL_CACTUS_RIDGE_4C,
+ 			       quirk_apple_wait_for_thunderbolt);
+ DECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,
+ 			       PCI_DEVICE_ID_INTEL_FALCON_RIDGE_2C_BRIDGE,
+ 			       quirk_apple_wait_for_thunderbolt);
+ DECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_INTEL,
+ 			       PCI_DEVICE_ID_INTEL_FALCON_RIDGE_4C_BRIDGE,
+ 			       quirk_apple_wait_for_thunderbolt);
+ #endif
+ 
++>>>>>>> 1c7de2b4ff88 (PCI: Enable access to non-standard VPD for Chelsio devices (cxgb3))
  static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,
  			  struct pci_fixup *end)
  {
* Unmerged path drivers/pci/quirks.c
