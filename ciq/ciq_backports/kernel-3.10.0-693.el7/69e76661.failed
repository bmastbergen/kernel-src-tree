vxlan: fix hlist corruption

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 69e766612c4bcb79e19cebed9eed61d4222c1d47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/69e76661.failed

It's not a good idea to add the same hlist_node to two different hash lists.
This leads to various hard to debug memory corruptions.

Fixes: b1be00a6c39f ("vxlan: support both IPv4 and IPv6 sockets in a single vxlan device")
	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 69e766612c4bcb79e19cebed9eed61d4222c1d47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 05e4fb1a5b9e,b04e103350fb..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -241,17 -226,28 +241,33 @@@ static struct vxlan_sock *vxlan_find_so
  	return NULL;
  }
  
 -static struct vxlan_dev *vxlan_vs_find_vni(struct vxlan_sock *vs, int ifindex,
 -					   __be32 vni)
 +static struct vxlan_dev *vxlan_vs_find_vni(struct vxlan_sock *vs, __be32 vni)
  {
- 	struct vxlan_dev *vxlan;
+ 	struct vxlan_dev_node *node;
  
  	/* For flow based devices, map all packets to VNI 0 */
  	if (vs->flags & VXLAN_F_COLLECT_METADATA)
  		vni = 0;
  
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(vxlan, vni_head(vs, vni), hlist) {
 +		if (vxlan->default_dst.remote_vni == vni)
 +			return vxlan;
++=======
+ 	hlist_for_each_entry_rcu(node, vni_head(vs, vni), hlist) {
+ 		if (node->vxlan->default_dst.remote_vni != vni)
+ 			continue;
+ 
+ 		if (IS_ENABLED(CONFIG_IPV6)) {
+ 			const struct vxlan_config *cfg = &node->vxlan->cfg;
+ 
+ 			if ((cfg->flags & VXLAN_F_IPV6_LINKLOCAL) &&
+ 			    cfg->remote_ifindex != ifindex)
+ 				continue;
+ 		}
+ 
+ 		return node->vxlan;
++>>>>>>> 69e766612c4b (vxlan: fix hlist corruption)
  	}
  
  	return NULL;
@@@ -2286,7 -2382,20 +2302,24 @@@ static void vxlan_cleanup(unsigned lon
  	mod_timer(&vxlan->age_timer, next_timer);
  }
  
++<<<<<<< HEAD
 +static void vxlan_vs_add_dev(struct vxlan_sock *vs, struct vxlan_dev *vxlan)
++=======
+ static void vxlan_vs_del_dev(struct vxlan_dev *vxlan)
+ {
+ 	struct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);
+ 
+ 	spin_lock(&vn->sock_lock);
+ 	hlist_del_init_rcu(&vxlan->hlist4.hlist);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	hlist_del_init_rcu(&vxlan->hlist6.hlist);
+ #endif
+ 	spin_unlock(&vn->sock_lock);
+ }
+ 
+ static void vxlan_vs_add_dev(struct vxlan_sock *vs, struct vxlan_dev *vxlan,
+ 			     struct vxlan_dev_node *node)
++>>>>>>> 69e766612c4b (vxlan: fix hlist corruption)
  {
  	struct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);
  	__be32 vni = vxlan->default_dst.remote_vni;
@@@ -2766,12 -2872,16 +2801,25 @@@ static int __vxlan_sock_add(struct vxla
  	if (IS_ERR(vs))
  		return PTR_ERR(vs);
  #if IS_ENABLED(CONFIG_IPV6)
++<<<<<<< HEAD
 +	if (ipv6)
 +		vxlan->vn6_sock = vs;
 +	else
 +#endif
 +		vxlan->vn4_sock = vs;
 +	vxlan_vs_add_dev(vs, vxlan);
++=======
+ 	if (ipv6) {
+ 		rcu_assign_pointer(vxlan->vn6_sock, vs);
+ 		node = &vxlan->hlist6;
+ 	} else
+ #endif
+ 	{
+ 		rcu_assign_pointer(vxlan->vn4_sock, vs);
+ 		node = &vxlan->hlist4;
+ 	}
+ 	vxlan_vs_add_dev(vs, vxlan, node);
++>>>>>>> 69e766612c4b (vxlan: fix hlist corruption)
  	return 0;
  }
  
* Unmerged path drivers/net/vxlan.c
diff --git a/include/net/vxlan.h b/include/net/vxlan.h
index d243713534f5..731e4a5ca095 100644
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@ -224,9 +224,17 @@ struct vxlan_config {
 	bool			no_share;
 };
 
+struct vxlan_dev_node {
+	struct hlist_node hlist;
+	struct vxlan_dev *vxlan;
+};
+
 /* Pseudo network device */
 struct vxlan_dev {
-	struct hlist_node hlist;	/* vni hash table */
+	struct vxlan_dev_node hlist4;	/* vni hash table for IPv4 socket */
+#if IS_ENABLED(CONFIG_IPV6)
+	struct vxlan_dev_node hlist6;	/* vni hash table for IPv6 socket */
+#endif
 	struct list_head  next;		/* vxlan's per namespace list */
 	struct vxlan_sock *vn4_sock;	/* listening socket for IPv4 */
 #if IS_ENABLED(CONFIG_IPV6)
