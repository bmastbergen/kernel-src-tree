virtio_balloon: Use a workqueue instead of "vballoon" kthread

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Petr Mladek <pmladek@suse.com>
commit fad7b7b27b6a168ca8ebc84482043886f837b89d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fad7b7b2.failed

This patch moves the deferred work from the "vballoon" kthread into a
system freezable workqueue.

We do not need to maintain and run a dedicated kthread. Also the event
driven workqueues API makes the logic much easier. Especially, we do
not longer need an own wait queue, wait function, and freeze point.

The conversion is pretty straightforward. One cycle of the main loop
is put into a work. The work is queued instead of waking the kthread.

fill_balloon() and leak_balloon() have a limit for the amount of modified
pages. The work re-queues itself when necessary. For this, we make
fill_balloon() to return the number of really modified pages.
Note that leak_balloon() already did this.

virtballoon_restore() queues the work only when really needed.

The only complication is that we need to prevent queuing the work
when the balloon is being removed. It was easier before because the
kthread simply removed itself from the wait queue. We need an
extra boolean and spin lock now.

My initial idea was to use a dedicated workqueue. Michael S. Tsirkin
suggested using a system one. Tejun Heo confirmed that the system
workqueue has a pretty high concurrency level (256) by default.
Therefore we need not be afraid of too long blocking.

	Signed-off-by: Petr Mladek <pmladek@suse.cz>
	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
(cherry picked from commit fad7b7b27b6a168ca8ebc84482043886f837b89d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/virtio/virtio_balloon.c
diff --cc drivers/virtio/virtio_balloon.c
index a9ca908865d3,2c9a92f1e525..000000000000
--- a/drivers/virtio/virtio_balloon.c
+++ b/drivers/virtio/virtio_balloon.c
@@@ -133,13 -132,13 +133,14 @@@ static void set_page_pfns(struct virtio
  	/* Set balloon pfns pointing at this page.
  	 * Note that the first pfn points at start of the page. */
  	for (i = 0; i < VIRTIO_BALLOON_PAGES_PER_PAGE; i++)
 -		pfns[i] = page_to_balloon_pfn(page) + i;
 +		pfns[i] = cpu_to_virtio32(vb->vdev,
 +					  page_to_balloon_pfn(page) + i);
  }
  
- static void fill_balloon(struct virtio_balloon *vb, size_t num)
+ static unsigned fill_balloon(struct virtio_balloon *vb, size_t num)
  {
  	struct balloon_dev_info *vb_dev_info = &vb->vb_dev_info;
+ 	unsigned num_allocated_pages;
  
  	/* We can only do one array worth at a time. */
  	num = min(num, ARRAY_SIZE(vb->pfns));
@@@ -356,35 -358,25 +369,53 @@@ static int virtballoon_oom_notify(struc
  	return NOTIFY_OK;
  }
  
- static int balloon(void *_vballoon)
+ static void balloon(struct work_struct *work)
  {
++<<<<<<< HEAD
 +	struct virtio_balloon *vb = _vballoon;
++=======
+ 	struct virtio_balloon *vb;
+ 	s64 diff;
++>>>>>>> fad7b7b27b6a (virtio_balloon: Use a workqueue instead of "vballoon" kthread)
  
- 	set_freezable();
- 	while (!kthread_should_stop()) {
- 		s64 diff;
+ 	vb = container_of(work, struct virtio_balloon, work);
+ 	diff = towards_target(vb);
  
++<<<<<<< HEAD
 +		try_to_freeze();
 +		wait_event_interruptible(vb->config_change,
 +					 (diff = towards_target(vb)) != 0
 +					 || vb->need_stats_update
 +					 || kthread_should_stop()
 +					 || freezing(current));
 +		if (vb->need_stats_update)
 +			stats_handle_request(vb);
 +		if (diff > 0)
 +			fill_balloon(vb, diff);
 +		else if (diff < 0)
 +			leak_balloon(vb, -diff);
 +		update_balloon_size(vb);
 +
 +		/*
 +		 * For large balloon changes, we could spend a lot of time
 +		 * and always have work to do.  Be nice if preempt disabled.
 +		 */
 +		cond_resched();
 +	}
 +	return 0;
++=======
+ 	if (vb->need_stats_update)
+ 		stats_handle_request(vb);
+ 
+ 	if (diff > 0)
+ 		diff -= fill_balloon(vb, diff);
+ 	else if (diff < 0)
+ 		diff += leak_balloon(vb, -diff);
+ 	update_balloon_size(vb);
+ 
+ 	if (diff)
+ 		queue_work(system_freezable_wq, work);
++>>>>>>> fad7b7b27b6a (virtio_balloon: Use a workqueue instead of "vballoon" kthread)
  }
  
  static int init_vqs(struct virtio_balloon *vb)
* Unmerged path drivers/virtio/virtio_balloon.c
