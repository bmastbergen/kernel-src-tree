perf evlist: Only open events on CPUs an evsel permits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mark Rutland <mark.rutland@arm.com>
commit 9f21b815be863218192f42f9f5bf78b75f8738e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9f21b815.failed

In systems with heterogeneous CPU PMUs, it's possible for each evsel to
cover a distinct set of CPUs, and hence the cpu_map associated with each
evsel may have a distinct idx<->id mapping. Any of these may be distinct
from the evlist's cpu map.

Events can be tied to the same fd so long as they use the same per-cpu
ringbuffer (i.e. so long as they are on the same CPU). To acquire the
correct FDs, we must compare the Linux logical IDs rather than the evsel
or evlist indices.

This path adds logic to perf_evlist__mmap_per_evsel to handle this,
translating IDs as required. As PMUs may cover a subset of CPUs from the
evlist, we skip the CPUs a PMU cannot handle.

Without this patch, perf record may try to mmap erroneous FDs on
heterogeneous systems, and will bail out early rather than running the
workload.

	Signed-off-by: Mark Rutland <mark.rutland@arm.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Mark Rutland <mark.rutland@arm.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Will Deacon <will.deacon@arm.com>
Link: http://lkml.kernel.org/r/1473330112-28528-7-git-send-email-mark.rutland@arm.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 9f21b815be863218192f42f9f5bf78b75f8738e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/evlist.c
diff --cc tools/perf/util/evlist.c
index 7f41d60e3ecf,ea34c5a32c11..000000000000
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@@ -1044,17 -1032,32 +1044,24 @@@ perf_evlist__should_poll(struct perf_ev
  }
  
  static int perf_evlist__mmap_per_evsel(struct perf_evlist *evlist, int idx,
++<<<<<<< HEAD
 +				       struct mmap_params *mp, int cpu,
 +				       int thread, int *output)
++=======
+ 				       struct mmap_params *mp, int cpu_idx,
+ 				       int thread, int *_output, int *_output_backward)
++>>>>>>> 9f21b815be86 (perf evlist: Only open events on CPUs an evsel permits)
  {
  	struct perf_evsel *evsel;
  	int revent;
+ 	int evlist_cpu = cpu_map__cpu(evlist->cpus, cpu_idx);
  
 -	evlist__for_each_entry(evlist, evsel) {
 -		struct perf_mmap *maps = evlist->mmap;
 -		int *output = _output;
 +	evlist__for_each(evlist, evsel) {
  		int fd;
+ 		int cpu;
  
 -		if (evsel->attr.write_backward) {
 -			output = _output_backward;
 -			maps = evlist->backward_mmap;
 -
 -			if (!maps) {
 -				maps = perf_evlist__alloc_mmap(evlist);
 -				if (!maps)
 -					return -1;
 -				evlist->backward_mmap = maps;
 -				if (evlist->bkw_mmap_state == BKW_MMAP_NOTREADY)
 -					perf_evlist__toggle_bkw_mmap(evlist, BKW_MMAP_RUNNING);
 -			}
 -		}
 +		if (evsel->overwrite != (evlist->overwrite && evlist->backward))
 +			continue;
  
  		if (evsel->system_wide && thread)
  			continue;
* Unmerged path tools/perf/util/evlist.c
