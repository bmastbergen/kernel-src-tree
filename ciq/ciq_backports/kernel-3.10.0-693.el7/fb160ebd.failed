net: amd-xgbe: use correct format specifier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] amd-xgbe: use correct format specifier (David Arcari) [1339783]
Rebuild_FUZZ: 93.83%
commit-author xypron.glpk@gmx.de <xypron.glpk@gmx.de>
commit fb160ebd512c505e8d3a18b4f877c7edd24acb49
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fb160ebd.failed

i has been defined as unsigned int.
So use %u for output.

	Signed-off-by: Heinrich Schuchardt <xypron.glpk@gmx.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fb160ebd512c505e8d3a18b4f877c7edd24acb49)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-drv.c
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index d58e85811bc9,a9b2709567ec..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@@ -124,9 -127,98 +124,101 @@@
  #include "xgbe.h"
  #include "xgbe-common.h"
  
 -static int xgbe_one_poll(struct napi_struct *, int);
 -static int xgbe_all_poll(struct napi_struct *, int);
  
++<<<<<<< HEAD
 +static int xgbe_poll(struct napi_struct *, int);
 +static void xgbe_set_rx_mode(struct net_device *);
++=======
+ static int xgbe_alloc_channels(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel_mem, *channel;
+ 	struct xgbe_ring *tx_ring, *rx_ring;
+ 	unsigned int count, i;
+ 	int ret = -ENOMEM;
+ 
+ 	count = max_t(unsigned int, pdata->tx_ring_count, pdata->rx_ring_count);
+ 
+ 	channel_mem = kcalloc(count, sizeof(struct xgbe_channel), GFP_KERNEL);
+ 	if (!channel_mem)
+ 		goto err_channel;
+ 
+ 	tx_ring = kcalloc(pdata->tx_ring_count, sizeof(struct xgbe_ring),
+ 			  GFP_KERNEL);
+ 	if (!tx_ring)
+ 		goto err_tx_ring;
+ 
+ 	rx_ring = kcalloc(pdata->rx_ring_count, sizeof(struct xgbe_ring),
+ 			  GFP_KERNEL);
+ 	if (!rx_ring)
+ 		goto err_rx_ring;
+ 
+ 	for (i = 0, channel = channel_mem; i < count; i++, channel++) {
+ 		snprintf(channel->name, sizeof(channel->name), "channel-%u", i);
+ 		channel->pdata = pdata;
+ 		channel->queue_index = i;
+ 		channel->dma_regs = pdata->xgmac_regs + DMA_CH_BASE +
+ 				    (DMA_CH_INC * i);
+ 
+ 		if (pdata->per_channel_irq) {
+ 			/* Get the DMA interrupt (offset 1) */
+ 			ret = platform_get_irq(pdata->pdev, i + 1);
+ 			if (ret < 0) {
+ 				netdev_err(pdata->netdev,
+ 					   "platform_get_irq %u failed\n",
+ 					   i + 1);
+ 				goto err_irq;
+ 			}
+ 
+ 			channel->dma_irq = ret;
+ 		}
+ 
+ 		if (i < pdata->tx_ring_count) {
+ 			spin_lock_init(&tx_ring->lock);
+ 			channel->tx_ring = tx_ring++;
+ 		}
+ 
+ 		if (i < pdata->rx_ring_count) {
+ 			spin_lock_init(&rx_ring->lock);
+ 			channel->rx_ring = rx_ring++;
+ 		}
+ 
+ 		netif_dbg(pdata, drv, pdata->netdev,
+ 			  "%s: dma_regs=%p, dma_irq=%d, tx=%p, rx=%p\n",
+ 			  channel->name, channel->dma_regs, channel->dma_irq,
+ 			  channel->tx_ring, channel->rx_ring);
+ 	}
+ 
+ 	pdata->channel = channel_mem;
+ 	pdata->channel_count = count;
+ 
+ 	return 0;
+ 
+ err_irq:
+ 	kfree(rx_ring);
+ 
+ err_rx_ring:
+ 	kfree(tx_ring);
+ 
+ err_tx_ring:
+ 	kfree(channel_mem);
+ 
+ err_channel:
+ 	return ret;
+ }
+ 
+ static void xgbe_free_channels(struct xgbe_prv_data *pdata)
+ {
+ 	if (!pdata->channel)
+ 		return;
+ 
+ 	kfree(pdata->channel->rx_ring);
+ 	kfree(pdata->channel->tx_ring);
+ 	kfree(pdata->channel);
+ 
+ 	pdata->channel = NULL;
+ 	pdata->channel_count = 0;
+ }
++>>>>>>> fb160ebd512c (net: amd-xgbe: use correct format specifier)
  
  static inline unsigned int xgbe_tx_avail_desc(struct xgbe_ring *ring)
  {
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
