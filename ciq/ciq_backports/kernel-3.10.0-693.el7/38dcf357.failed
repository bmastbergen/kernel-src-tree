bridge: call netdev_sw_port_stp_update when bridge port STP status changes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Scott Feldman <sfeldma@gmail.com>
commit 38dcf357aed299186ecb090cc2f5290cc17d637d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/38dcf357.failed

To notify switch driver of change in STP state of bridge port, add new
.ndo op and provide switchdev wrapper func to call ndo op. Use it in bridge
code then.

	Signed-off-by: Scott Feldman <sfeldma@gmail.com>
	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: Andy Gospodarek <gospo@cumulusnetworks.com>
	Acked-by: Thomas Graf <tgraf@suug.ch>
	Acked-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 38dcf357aed299186ecb090cc2f5290cc17d637d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	include/net/switchdev.h
#	net/switchdev/switchdev.c
diff --cc include/linux/netdevice.h
index b6150f910ad9,29c92ee9ed56..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1106,23 -994,39 +1106,34 @@@ struct net_device_ops_extended 
   *	address family that vxlan is not listening to anymore. The operation
   *	is protected by the vxlan_net->sock_lock.
   *
 - * void* (*ndo_dfwd_add_station)(struct net_device *pdev,
 - *				 struct net_device *dev)
 - *	Called by upper layer devices to accelerate switching or other
 - *	station functionality into hardware. 'pdev is the lowerdev
 - *	to use for the offload and 'dev' is the net device that will
 - *	back the offload. Returns a pointer to the private structure
 - *	the upper layer will maintain.
 - * void (*ndo_dfwd_del_station)(struct net_device *pdev, void *priv)
 - *	Called by upper layer device to delete the station created
 - *	by 'ndo_dfwd_add_station'. 'pdev' is the net device backing
 - *	the station and priv is the structure returned by the add
 - *	operation.
 - * netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *skb,
 - *				      struct net_device *dev,
 - *				      void *priv);
 - *	Callback to use for xmit over the accelerated station. This
 - *	is used in place of ndo_start_xmit on accelerated net
 - *	devices.
 - * bool	(*ndo_gso_check) (struct sk_buff *skb,
 - *			  struct net_device *dev);
 - *	Called by core transmit path to determine if device is capable of
 - *	performing GSO on a packet. The device returns true if it is
 - *	able to GSO the packet, false otherwise. If the return value is
 - *	false the stack will do software GSO.
 + * int (*ndo_get_iflink)(const struct net_device *dev);
 + *	Called to get the iflink value of this device.
   *
 + * netdev_features_t (*ndo_features_check) (struct sk_buff *skb,
 + *					    struct net_device *dev
 + *					    netdev_features_t features);
 + *	Called by core transmit path to determine if device is capable of
 + *	performing offload operations on a given packet. This is to give
 + *	the device an opportunity to implement any restrictions that cannot
 + *	be otherwise expressed by feature flags. The check is called with
 + *	the set of features that the stack has calculated and it returns
 + *	those the driver believes to be appropriate.
 + * int (*ndo_fill_metadata_dst)(struct net_device *dev, struct sk_buff *skb);
 + *	This function is used to get egress tunnel information for given skb.
 + *	This is useful for retrieving outer tunnel header parameters while
 + *	sampling packet.
 + *
++<<<<<<< HEAD
++=======
+  * int (*ndo_switch_parent_id_get)(struct net_device *dev,
+  *				   struct netdev_phys_item_id *psid);
+  *	Called to get an ID of the switch chip this port is part of.
+  *	If driver implements this, it indicates that it represents a port
+  *	of a switch chip.
+  * int (*ndo_switch_port_stp_update)(struct net_device *dev, u8 state);
+  *	Called to notify switch device port of bridge port STP
+  *	state change.
++>>>>>>> 38dcf357aed2 (bridge: call netdev_sw_port_stp_update when bridge port STP status changes)
   */
  struct net_device_ops {
  	int			(*ndo_init)(struct net_device *dev);
@@@ -1284,70 -1169,25 +1295,85 @@@
  						      sa_family_t sa_family,
  						      __be16 port);
  
 -	void*			(*ndo_dfwd_add_station)(struct net_device *pdev,
 -							struct net_device *dev);
 -	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
 -							void *priv);
 -
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, int	(*ndo_get_iflink)(const struct net_device *dev))
 +	RH_KABI_USE_P(2, netdev_features_t
 +				(*ndo_features_check)(struct sk_buff *skb,
 +						      struct net_device *dev,
 +						      netdev_features_t features))
 +	RH_KABI_USE_P(3, int	(*ndo_set_vf_rate)(struct net_device *dev,
 +						   int vf, int min_tx_rate,
 +						   int max_tx_rate))
 +	RH_KABI_USE_P(4, int	(*ndo_get_vf_stats)(struct net_device *dev,
 +						    int vf,
 +						    struct ifla_vf_stats
 +						    *vf_stats))
 +	RH_KABI_USE_P(5, int    (*ndo_set_vf_rss_query_en)(struct net_device *dev,
 +							   int vf, bool setting))
 +
++<<<<<<< HEAD
 +	RH_KABI_USE_P(6, int	(*ndo_fdb_add)(struct ndmsg *ndm,
 +					       struct nlattr *tb[],
 +					       struct net_device *dev,
 +					       const unsigned char *addr,
 +					       u16 vid,
 +					       u16 flags))
 +	RH_KABI_USE_P(7,int	(*ndo_setup_tc)(struct net_device *dev,
 +						u32 handle,
 +						__be16 protocol,
 +						struct tc_to_netdev *tc))
 +	RH_KABI_USE_P(8, int	(*ndo_fill_metadata_dst)(struct net_device *dev,
 +						       struct sk_buff *skb))
 +	RH_KABI_USE_P(9, void	(*ndo_add_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_USE_P(10, void	(*ndo_del_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_USE_P(16, size_t ndo_size)
 +	/* RHEL: put all new non-performance critical ndo's into
 +	 * net_device_ops_extended. The reserved slots above can be used
 +	 * only for performance critical operations.
 +	 * Drivers may access the extended fields directly from
 +	 * net_device_ops, if they allocated the net_device_ops structure
 +	 * themselves (usually statically). The kernel core and drivers
 +	 * using others' net_device_ops must access the extended fields
 +	 * using the get_ndo_ext macro.
 +	 */
 +	RH_KABI_EXTEND(struct net_device_ops_extended extended)
++=======
+ 	netdev_tx_t		(*ndo_dfwd_start_xmit) (struct sk_buff *skb,
+ 							struct net_device *dev,
+ 							void *priv);
+ 	int			(*ndo_get_lock_subclass)(struct net_device *dev);
+ 	bool			(*ndo_gso_check) (struct sk_buff *skb,
+ 						  struct net_device *dev);
+ #ifdef CONFIG_NET_SWITCHDEV
+ 	int			(*ndo_switch_parent_id_get)(struct net_device *dev,
+ 							    struct netdev_phys_item_id *psid);
+ 	int			(*ndo_switch_port_stp_update)(struct net_device *dev,
+ 							      u8 state);
+ #endif
++>>>>>>> 38dcf357aed2 (bridge: call netdev_sw_port_stp_update when bridge port STP status changes)
  };
  
 +#define get_ndo_ext(ops, field)		({				\
 +	const struct net_device_ops *__ops = (ops);			\
 +	size_t __off = offsetof(struct net_device_ops, extended.field);	\
 +	__ops->ndo_size > __off ? __ops->extended.field : NULL;		\
 +	})
 +
  /**
   * enum net_device_priv_flags - &struct net_device priv_flags
   *
* Unmerged path include/net/switchdev.h
* Unmerged path net/switchdev/switchdev.c
* Unmerged path include/linux/netdevice.h
* Unmerged path include/net/switchdev.h
diff --git a/net/bridge/br_stp.c b/net/bridge/br_stp.c
index 2b047bcf42a4..fb3ebe615513 100644
--- a/net/bridge/br_stp.c
+++ b/net/bridge/br_stp.c
@@ -12,6 +12,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/rculist.h>
+#include <net/switchdev.h>
 
 #include "br_private.h"
 #include "br_private_stp.h"
@@ -38,7 +39,13 @@ void br_log_state(const struct net_bridge_port *p)
 
 void br_set_state(struct net_bridge_port *p, unsigned int state)
 {
+	int err;
+
 	p->state = state;
+	err = netdev_switch_port_stp_update(p->dev, state);
+	if (err && err != -EOPNOTSUPP)
+		br_warn(p->br, "error setting offload STP state on port %u(%s)\n",
+				(unsigned int) p->port_no, p->dev->name);
 }
 
 /* called under bridge lock */
* Unmerged path net/switchdev/switchdev.c
