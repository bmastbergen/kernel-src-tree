qedr: Add support for PD,PKEY and CQ verbs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ram Amrani <Ram.Amrani@cavium.com>
commit a7efd7773e31b60f695816c27393fc717a9df127
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a7efd777.failed

Add support for protection domain and completion queue verbs.

	Signed-off-by: Rajesh Borundia <rajesh.borundia@cavium.com>
	Signed-off-by: Ram Amrani <Ram.Amrani@cavium.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit a7efd7773e31b60f695816c27393fc717a9df127)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/amso1100/c2_user.h
#	drivers/infiniband/hw/cxgb3/iwch_user.h
#	drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
#	drivers/infiniband/hw/qedr/main.c
#	drivers/infiniband/hw/qedr/qedr.h
#	drivers/infiniband/hw/qedr/verbs.c
diff --cc drivers/infiniband/hw/amso1100/c2_user.h
index 7e9e7ad65467,84f6520107cc..000000000000
--- a/drivers/infiniband/hw/amso1100/c2_user.h
+++ b/drivers/infiniband/hw/amso1100/c2_user.h
@@@ -30,53 -28,148 +30,184 @@@
   * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
 + *
 + */
 +
 +#ifndef C2_USER_H
 +#define C2_USER_H
 +
 +#include <linux/types.h>
 +
 +/*
 + * Make sure that all structs defined in this file remain laid out so
 + * that they pack the same way on 32-bit and 64-bit architectures (to
 + * avoid incompatibility between 32-bit userspace and 64-bit kernels).
 + * In particular do not use pointer types -- pass pointers in __u64
 + * instead.
   */
 -#ifndef __QED_HSI_RDMA__
 -#define __QED_HSI_RDMA__
  
 -#include <linux/qed/rdma_common.h>
 +struct c2_alloc_ucontext_resp {
 +	__u32 qp_tab_size;
 +	__u32 uarc_size;
 +};
 +
++<<<<<<< HEAD:drivers/infiniband/hw/amso1100/c2_user.h
 +struct c2_alloc_pd_resp {
 +	__u32 pdn;
 +	__u32 reserved;
 +};
  
 -/* rdma completion notification queue element */
 -struct rdma_cnqe {
 -	struct regpair	cq_handle;
 +struct c2_create_cq {
 +	__u32 lkey;
 +	__u32 pdn;
 +	__u64 arm_db_page;
 +	__u64 set_db_page;
 +	__u32 arm_db_index;
 +	__u32 set_db_index;
  };
  
 +struct c2_create_cq_resp {
 +	__u32 cqn;
 +	__u32 reserved;
++=======
+ struct rdma_cqe_responder {
+ 	struct regpair srq_wr_id;
+ 	struct regpair qp_handle;
+ 	__le32 imm_data_or_inv_r_Key;
+ 	__le32 length;
+ 	__le32 imm_data_hi;
+ 	__le16 rq_cons;
+ 	u8 flags;
+ #define RDMA_CQE_RESPONDER_TOGGLE_BIT_MASK  0x1
+ #define RDMA_CQE_RESPONDER_TOGGLE_BIT_SHIFT 0
+ #define RDMA_CQE_RESPONDER_TYPE_MASK        0x3
+ #define RDMA_CQE_RESPONDER_TYPE_SHIFT       1
+ #define RDMA_CQE_RESPONDER_INV_FLG_MASK     0x1
+ #define RDMA_CQE_RESPONDER_INV_FLG_SHIFT    3
+ #define RDMA_CQE_RESPONDER_IMM_FLG_MASK     0x1
+ #define RDMA_CQE_RESPONDER_IMM_FLG_SHIFT    4
+ #define RDMA_CQE_RESPONDER_RDMA_FLG_MASK    0x1
+ #define RDMA_CQE_RESPONDER_RDMA_FLG_SHIFT   5
+ #define RDMA_CQE_RESPONDER_RESERVED2_MASK   0x3
+ #define RDMA_CQE_RESPONDER_RESERVED2_SHIFT  6
+ 	u8 status;
+ };
+ 
+ struct rdma_cqe_requester {
+ 	__le16 sq_cons;
+ 	__le16 reserved0;
+ 	__le32 reserved1;
+ 	struct regpair qp_handle;
+ 	struct regpair reserved2;
+ 	__le32 reserved3;
+ 	__le16 reserved4;
+ 	u8 flags;
+ #define RDMA_CQE_REQUESTER_TOGGLE_BIT_MASK  0x1
+ #define RDMA_CQE_REQUESTER_TOGGLE_BIT_SHIFT 0
+ #define RDMA_CQE_REQUESTER_TYPE_MASK        0x3
+ #define RDMA_CQE_REQUESTER_TYPE_SHIFT       1
+ #define RDMA_CQE_REQUESTER_RESERVED5_MASK   0x1F
+ #define RDMA_CQE_REQUESTER_RESERVED5_SHIFT  3
+ 	u8 status;
+ };
+ 
+ struct rdma_cqe_common {
+ 	struct regpair reserved0;
+ 	struct regpair qp_handle;
+ 	__le16 reserved1[7];
+ 	u8 flags;
+ #define RDMA_CQE_COMMON_TOGGLE_BIT_MASK  0x1
+ #define RDMA_CQE_COMMON_TOGGLE_BIT_SHIFT 0
+ #define RDMA_CQE_COMMON_TYPE_MASK        0x3
+ #define RDMA_CQE_COMMON_TYPE_SHIFT       1
+ #define RDMA_CQE_COMMON_RESERVED2_MASK   0x1F
+ #define RDMA_CQE_COMMON_RESERVED2_SHIFT  3
+ 	u8 status;
++>>>>>>> a7efd7773e31 (qedr: Add support for PD,PKEY and CQ verbs):drivers/infiniband/hw/qedr/qedr_hsi_rdma.h
  };
  
 -/* rdma completion queue element */
 -union rdma_cqe {
 -	struct rdma_cqe_responder resp;
 -	struct rdma_cqe_requester req;
 -	struct rdma_cqe_common cmn;
 +struct c2_create_qp {
 +	__u32 lkey;
 +	__u32 reserved;
 +	__u64 sq_db_page;
 +	__u64 rq_db_page;
 +	__u32 sq_db_index;
 +	__u32 rq_db_index;
  };
  
++<<<<<<< HEAD:drivers/infiniband/hw/amso1100/c2_user.h
 +#endif				/* C2_USER_H */
++=======
+ /* * CQE requester status enumeration */
+ enum rdma_cqe_requester_status_enum {
+ 	RDMA_CQE_REQ_STS_OK,
+ 	RDMA_CQE_REQ_STS_BAD_RESPONSE_ERR,
+ 	RDMA_CQE_REQ_STS_LOCAL_LENGTH_ERR,
+ 	RDMA_CQE_REQ_STS_LOCAL_QP_OPERATION_ERR,
+ 	RDMA_CQE_REQ_STS_LOCAL_PROTECTION_ERR,
+ 	RDMA_CQE_REQ_STS_MEMORY_MGT_OPERATION_ERR,
+ 	RDMA_CQE_REQ_STS_REMOTE_INVALID_REQUEST_ERR,
+ 	RDMA_CQE_REQ_STS_REMOTE_ACCESS_ERR,
+ 	RDMA_CQE_REQ_STS_REMOTE_OPERATION_ERR,
+ 	RDMA_CQE_REQ_STS_RNR_NAK_RETRY_CNT_ERR,
+ 	RDMA_CQE_REQ_STS_TRANSPORT_RETRY_CNT_ERR,
+ 	RDMA_CQE_REQ_STS_WORK_REQUEST_FLUSHED_ERR,
+ 	MAX_RDMA_CQE_REQUESTER_STATUS_ENUM
+ };
+ 
+ /* CQE responder status enumeration */
+ enum rdma_cqe_responder_status_enum {
+ 	RDMA_CQE_RESP_STS_OK,
+ 	RDMA_CQE_RESP_STS_LOCAL_ACCESS_ERR,
+ 	RDMA_CQE_RESP_STS_LOCAL_LENGTH_ERR,
+ 	RDMA_CQE_RESP_STS_LOCAL_QP_OPERATION_ERR,
+ 	RDMA_CQE_RESP_STS_LOCAL_PROTECTION_ERR,
+ 	RDMA_CQE_RESP_STS_MEMORY_MGT_OPERATION_ERR,
+ 	RDMA_CQE_RESP_STS_REMOTE_INVALID_REQUEST_ERR,
+ 	RDMA_CQE_RESP_STS_WORK_REQUEST_FLUSHED_ERR,
+ 	MAX_RDMA_CQE_RESPONDER_STATUS_ENUM
+ };
+ 
+ /* CQE type enumeration */
+ enum rdma_cqe_type {
+ 	RDMA_CQE_TYPE_REQUESTER,
+ 	RDMA_CQE_TYPE_RESPONDER_RQ,
+ 	RDMA_CQE_TYPE_RESPONDER_SRQ,
+ 	RDMA_CQE_TYPE_INVALID,
+ 	MAX_RDMA_CQE_TYPE
+ };
+ 
+ struct rdma_sq_sge {
+ 	__le32 length;
+ 	struct regpair	addr;
+ 	__le32 l_key;
+ };
+ 
+ struct rdma_rq_sge {
+ 	struct regpair addr;
+ 	__le32 length;
+ 	__le32 flags;
+ };
+ 
+ struct rdma_srq_sge {
+ 	struct regpair addr;
+ 	__le32 length;
+ 	__le32 l_key;
+ };
+ 
+ /* Rdma doorbell data for CQ */
+ struct rdma_pwm_val32_data {
+ 	__le16 icid;
+ 	u8 agg_flags;
+ 	u8 params;
+ #define RDMA_PWM_VAL32_DATA_AGG_CMD_MASK    0x3
+ #define RDMA_PWM_VAL32_DATA_AGG_CMD_SHIFT   0
+ #define RDMA_PWM_VAL32_DATA_BYPASS_EN_MASK  0x1
+ #define RDMA_PWM_VAL32_DATA_BYPASS_EN_SHIFT 2
+ #define RDMA_PWM_VAL32_DATA_RESERVED_MASK   0x1F
+ #define RDMA_PWM_VAL32_DATA_RESERVED_SHIFT  3
+ 	__le32 value;
+ };
+ 
+ #endif /* __QED_HSI_RDMA__ */
++>>>>>>> a7efd7773e31 (qedr: Add support for PD,PKEY and CQ verbs):drivers/infiniband/hw/qedr/qedr_hsi_rdma.h
diff --cc drivers/infiniband/hw/cxgb3/iwch_user.h
index a277c31fcaf7,36c8a692f740..000000000000
--- a/drivers/infiniband/hw/cxgb3/iwch_user.h
+++ b/drivers/infiniband/hw/cxgb3/iwch_user.h
@@@ -29,46 -29,38 +29,72 @@@
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
 -#ifndef __QEDR_VERBS_H__
 -#define __QEDR_VERBS_H__
 +#ifndef __IWCH_USER_H__
 +#define __IWCH_USER_H__
  
 -int qedr_query_device(struct ib_device *ibdev,
 -		      struct ib_device_attr *attr, struct ib_udata *udata);
 -int qedr_query_port(struct ib_device *, u8 port, struct ib_port_attr *props);
 -int qedr_modify_port(struct ib_device *, u8 port, int mask,
 -		     struct ib_port_modify *props);
 +#define IWCH_UVERBS_ABI_VERSION	1
  
 -int qedr_query_gid(struct ib_device *, u8 port, int index, union ib_gid *gid);
 +/*
 + * Make sure that all structs defined in this file remain laid out so
 + * that they pack the same way on 32-bit and 64-bit architectures (to
 + * avoid incompatibility between 32-bit userspace and 64-bit kernels).
 + * In particular do not use pointer types -- pass pointers in __u64
 + * instead.
 + */
 +struct iwch_create_cq_req {
 +	__u64 user_rptr_addr;
 +};
 +
++<<<<<<< HEAD:drivers/infiniband/hw/cxgb3/iwch_user.h
 +struct iwch_create_cq_resp_v0 {
 +	__u64 key;
 +	__u32 cqid;
 +	__u32 size_log2;
 +};
 +
 +struct iwch_create_cq_resp {
 +	__u64 key;
 +	__u32 cqid;
 +	__u32 size_log2;
 +	__u32 memsize;
 +	__u32 reserved;
 +};
 +
 +struct iwch_create_qp_resp {
 +	__u64 key;
 +	__u64 db_key;
 +	__u32 qpid;
 +	__u32 size_log2;
 +	__u32 sq_size_log2;
 +	__u32 rq_size_log2;
 +};
  
 +struct iwch_reg_user_mr_resp {
 +	__u32 pbl_addr;
 +};
++=======
+ int qedr_query_pkey(struct ib_device *, u8 port, u16 index, u16 *pkey);
+ 
+ struct ib_ucontext *qedr_alloc_ucontext(struct ib_device *, struct ib_udata *);
+ int qedr_dealloc_ucontext(struct ib_ucontext *);
+ 
+ int qedr_mmap(struct ib_ucontext *, struct vm_area_struct *vma);
+ int qedr_del_gid(struct ib_device *device, u8 port_num,
+ 		 unsigned int index, void **context);
+ int qedr_add_gid(struct ib_device *device, u8 port_num,
+ 		 unsigned int index, const union ib_gid *gid,
+ 		 const struct ib_gid_attr *attr, void **context);
+ struct ib_pd *qedr_alloc_pd(struct ib_device *,
+ 			    struct ib_ucontext *, struct ib_udata *);
+ int qedr_dealloc_pd(struct ib_pd *pd);
+ 
+ struct ib_cq *qedr_create_cq(struct ib_device *ibdev,
+ 			     const struct ib_cq_init_attr *attr,
+ 			     struct ib_ucontext *ib_ctx,
+ 			     struct ib_udata *udata);
+ int qedr_resize_cq(struct ib_cq *, int cqe, struct ib_udata *);
+ int qedr_destroy_cq(struct ib_cq *);
+ int qedr_arm_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags flags);
+ 
++>>>>>>> a7efd7773e31 (qedr: Add support for PD,PKEY and CQ verbs):drivers/infiniband/hw/qedr/verbs.h
  #endif
diff --cc drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
index 1d7bd82a1fb1,b0fc5f2125e0..000000000000
--- a/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
+++ b/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
@@@ -29,34 -29,44 +29,69 @@@
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
 -#ifndef __QEDR_USER_H__
 -#define __QEDR_USER_H__
  
 -#include <linux/types.h>
 +/*
 + * This file is conditionally built on PowerPC only.  Otherwise weak symbol
 + * versions of the functions exported from here are used.
 + */
  
 -#define QEDR_ABI_VERSION		(8)
 +#include "ipath_kernel.h"
  
 -/* user kernel communication data structures. */
 +/**
 + * ipath_enable_wc - enable write combining for MMIO writes to the device
 + * @dd: infinipath device
 + *
 + * Nothing to do on PowerPC, so just return without error.
 + */
 +int ipath_enable_wc(struct ipath_devdata *dd)
 +{
 +	return 0;
 +}
  
++<<<<<<< HEAD:drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
 +/**
 + * ipath_unordered_wc - indicate whether write combining is unordered
 + *
 + * Because our performance depends on our ability to do write
 + * combining mmio writes in the most efficient way, we need to
 + * know if we are on a processor that may reorder stores when
 + * write combining.
 + */
 +int ipath_unordered_wc(void)
 +{
 +	return 1;
 +}
++=======
+ struct qedr_alloc_ucontext_resp {
+ 	__u64 db_pa;
+ 	__u32 db_size;
+ 
+ 	__u32 max_send_wr;
+ 	__u32 max_recv_wr;
+ 	__u32 max_srq_wr;
+ 	__u32 sges_per_send_wr;
+ 	__u32 sges_per_recv_wr;
+ 	__u32 sges_per_srq_wr;
+ 	__u32 max_cqes;
+ };
+ 
+ struct qedr_alloc_pd_ureq {
+ 	__u64 rsvd1;
+ };
+ 
+ struct qedr_alloc_pd_uresp {
+ 	__u32 pd_id;
+ };
+ 
+ struct qedr_create_cq_ureq {
+ 	__u64 addr;
+ 	__u64 len;
+ };
+ 
+ struct qedr_create_cq_uresp {
+ 	__u32 db_offset;
+ 	__u16 icid;
+ };
+ 
+ #endif /* __QEDR_USER_H__ */
++>>>>>>> a7efd7773e31 (qedr: Add support for PD,PKEY and CQ verbs):include/uapi/rdma/qedr-abi.h
* Unmerged path drivers/infiniband/hw/qedr/main.c
* Unmerged path drivers/infiniband/hw/qedr/qedr.h
* Unmerged path drivers/infiniband/hw/qedr/verbs.c
* Unmerged path drivers/infiniband/hw/amso1100/c2_user.h
* Unmerged path drivers/infiniband/hw/cxgb3/iwch_user.h
* Unmerged path drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
* Unmerged path drivers/infiniband/hw/qedr/main.c
* Unmerged path drivers/infiniband/hw/qedr/qedr.h
* Unmerged path drivers/infiniband/hw/qedr/verbs.c
