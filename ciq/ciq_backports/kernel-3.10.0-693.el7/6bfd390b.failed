net/mlx5e: Add support for multiple profiles

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Add support for multiple profiles (Don Dutile) [1383788 1417284]
Rebuild_FUZZ: 95.24%
commit-author Hadar Hen Zion <hadarh@mellanox.com>
commit 6bfd390ba5466675f6f02f77a3e957bd4e6075ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6bfd390b.failed

To allow support in representor netdevices where we create more than one
netdevice per NIC, add profiles to the mlx5e driver. The profiling
allows for creation of mlx5e instances with different characteristics.

Each profile implements its own behavior using set of function pointers
defined in struct mlx5e_profile. This is done to allow for avoiding complex
per profix branching in the code.

Currently only the profile for the conventional NIC is implemented,
which is of use when a netdev is created upon pci probe.

This patch doesn't add any new functionality.

	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6bfd390ba5466675f6f02f77a3e957bd4e6075ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 0c9d38242297,3e22c5e8dcf6..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -1444,28 -1518,28 +1444,45 @@@ static int mlx5e_create_rqt(struct mlx5
  	return err;
  }
  
 -static void mlx5e_destroy_rqt(struct mlx5e_priv *priv, struct mlx5e_rqt *rqt)
 +static void mlx5e_destroy_rqt(struct mlx5e_priv *priv, u32 rqtn)
  {
 -	rqt->enabled = false;
 -	mlx5_core_destroy_rqt(priv->mdev, rqt->rqtn);
 +	mlx5_core_destroy_rqt(priv->mdev, rqtn);
  }
  
- static int mlx5e_create_rqts(struct mlx5e_priv *priv)
+ static int mlx5e_create_indirect_rqts(struct mlx5e_priv *priv)
  {
+ 	struct mlx5e_rqt *rqt = &priv->indir_rqt;
+ 
+ 	return mlx5e_create_rqt(priv, MLX5E_INDIR_RQT_SIZE, 0, rqt);
+ }
+ 
+ static int mlx5e_create_direct_rqts(struct mlx5e_priv *priv)
+ {
++<<<<<<< HEAD
 +	int nch = mlx5e_get_max_num_channels(priv->mdev);
 +	u32 *rqtn;
 +	int err;
 +	int ix;
 +
 +	/* Indirect RQT */
 +	rqtn = &priv->indir_rqtn;
 +	err = mlx5e_create_rqt(priv, MLX5E_INDIR_RQT_SIZE, 0, rqtn);
 +	if (err)
 +		return err;
 +
 +	/* Direct RQTs */
 +	for (ix = 0; ix < nch; ix++) {
 +		rqtn = &priv->direct_tir[ix].rqtn;
 +		err = mlx5e_create_rqt(priv, 1 /*size */, ix, rqtn);
++=======
+ 	struct mlx5e_rqt *rqt;
+ 	int err;
+ 	int ix;
+ 
+ 	for (ix = 0; ix < priv->profile->max_nch(priv->mdev); ix++) {
+ 		rqt = &priv->direct_tir[ix].rqt;
+ 		err = mlx5e_create_rqt(priv, 1 /*size */, ix, rqt);
++>>>>>>> 6bfd390ba546 (net/mlx5e: Add support for multiple profiles)
  		if (err)
  			goto err_destroy_rqts;
  	}
@@@ -1474,24 -1548,11 +1491,30 @@@
  
  err_destroy_rqts:
  	for (ix--; ix >= 0; ix--)
 -		mlx5e_destroy_rqt(priv, &priv->direct_tir[ix].rqt);
 +		mlx5e_destroy_rqt(priv, priv->direct_tir[ix].rqtn);
 +
++<<<<<<< HEAD
 +	mlx5e_destroy_rqt(priv, priv->indir_rqtn);
 +
 +	return err;
 +}
 +
 +static void mlx5e_destroy_rqts(struct mlx5e_priv *priv)
 +{
 +	int nch = mlx5e_get_max_num_channels(priv->mdev);
 +	int i;
 +
 +	for (i = 0; i < nch; i++)
 +		mlx5e_destroy_rqt(priv, priv->direct_tir[i].rqtn);
  
 +	mlx5e_destroy_rqt(priv, priv->indir_rqtn);
 +}
 +
++=======
+ 	return err;
+ }
+ 
++>>>>>>> 6bfd390ba546 (net/mlx5e: Add support for multiple profiles)
  int mlx5e_redirect_rqt(struct mlx5e_priv *priv, u32 rqtn, int sz, int ix)
  {
  	struct mlx5_core_dev *mdev = priv->mdev;
@@@ -2077,15 -2106,13 +2100,18 @@@ static void mlx5e_build_direct_tir_ctx(
  	MLX5_SET(tirc, tirc, rx_hash_fn, MLX5_RX_HASH_FN_INVERTED_XOR8);
  }
  
- static int mlx5e_create_tirs(struct mlx5e_priv *priv)
+ static int mlx5e_create_indirect_tirs(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	int nch = mlx5e_get_max_num_channels(priv->mdev);
++=======
+ 	struct mlx5e_tir *tir;
++>>>>>>> 6bfd390ba546 (net/mlx5e: Add support for multiple profiles)
  	void *tirc;
  	int inlen;
 +	u32 *tirn;
  	int err;
  	u32 *in;
- 	int ix;
  	int tt;
  
  	inlen = MLX5_ST_SZ_BYTES(create_tir_in);
@@@ -2093,25 -2120,51 +2119,51 @@@
  	if (!in)
  		return -ENOMEM;
  
- 	/* indirect tirs */
  	for (tt = 0; tt < MLX5E_NUM_INDIR_TIRS; tt++) {
  		memset(in, 0, inlen);
 -		tir = &priv->indir_tir[tt];
 +		tirn = &priv->indir_tirn[tt];
  		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
  		mlx5e_build_indir_tir_ctx(priv, tirc, tt);
 -		err = mlx5e_create_tir(priv->mdev, tir, in, inlen);
 +		err = mlx5_core_create_tir(priv->mdev, in, inlen, tirn);
  		if (err)
  			goto err_destroy_tirs;
  	}
  
- 	/* direct tirs */
+ 	kvfree(in);
+ 
+ 	return 0;
+ 
+ err_destroy_tirs:
+ 	for (tt--; tt >= 0; tt--)
+ 		mlx5e_destroy_tir(priv->mdev, &priv->indir_tir[tt]);
+ 
+ 	kvfree(in);
+ 
+ 	return err;
+ }
+ 
+ static int mlx5e_create_direct_tirs(struct mlx5e_priv *priv)
+ {
+ 	int nch = priv->profile->max_nch(priv->mdev);
+ 	struct mlx5e_tir *tir;
+ 	void *tirc;
+ 	int inlen;
+ 	int err;
+ 	u32 *in;
+ 	int ix;
+ 
+ 	inlen = MLX5_ST_SZ_BYTES(create_tir_in);
+ 	in = mlx5_vzalloc(inlen);
+ 	if (!in)
+ 		return -ENOMEM;
+ 
  	for (ix = 0; ix < nch; ix++) {
  		memset(in, 0, inlen);
 -		tir = &priv->direct_tir[ix];
 +		tirn = &priv->direct_tir[ix].tirn;
  		tirc = MLX5_ADDR_OF(create_tir_in, in, ctx);
  		mlx5e_build_direct_tir_ctx(priv, tirc,
 -					   priv->direct_tir[ix].rqt.rqtn);
 -		err = mlx5e_create_tir(priv->mdev, tir, in, inlen);
 +					   priv->direct_tir[ix].rqtn);
 +		err = mlx5_core_create_tir(priv->mdev, in, inlen, tirn);
  		if (err)
  			goto err_destroy_ch_tirs;
  	}
@@@ -2122,12 -2175,8 +2174,15 @@@
  
  err_destroy_ch_tirs:
  	for (ix--; ix >= 0; ix--)
 -		mlx5e_destroy_tir(priv->mdev, &priv->direct_tir[ix]);
 +		mlx5_core_destroy_tir(priv->mdev, priv->direct_tir[ix].tirn);
 +
++<<<<<<< HEAD
 +err_destroy_tirs:
 +	for (tt--; tt >= 0; tt--)
 +		mlx5_core_destroy_tir(priv->mdev, priv->indir_tirn[tt]);
  
++=======
++>>>>>>> 6bfd390ba546 (net/mlx5e: Add support for multiple profiles)
  	kvfree(in);
  
  	return err;
@@@ -2139,10 -2196,7 +2202,14 @@@ static void mlx5e_destroy_direct_tirs(s
  	int i;
  
  	for (i = 0; i < nch; i++)
++<<<<<<< HEAD
 +		mlx5_core_destroy_tir(priv->mdev, priv->direct_tir[i].tirn);
 +
 +	for (i = 0; i < MLX5E_NUM_INDIR_TIRS; i++)
 +		mlx5_core_destroy_tir(priv->mdev, priv->indir_tirn[i]);
++=======
+ 		mlx5e_destroy_tir(priv->mdev, &priv->direct_tir[i]);
++>>>>>>> 6bfd390ba546 (net/mlx5e: Add support for multiple profiles)
  }
  
  int mlx5e_modify_rqs_vsd(struct mlx5e_priv *priv, bool vsd)
@@@ -3003,14 -3265,11 +3208,14 @@@ static void *mlx5e_create_netdev(struc
  {
  	struct net_device *netdev;
  	struct mlx5e_priv *priv;
- 	int nch = mlx5e_get_max_num_channels(mdev);
+ 	int nch = profile->max_nch(mdev);
  	int err;
  
 +	if (mlx5e_check_required_hca_cap(mdev))
 +		return NULL;
 +
  	netdev = alloc_etherdev_mqs(sizeof(struct mlx5e_priv),
- 				    nch * MLX5E_MAX_NUM_TC,
+ 				    nch * profile->max_tc,
  				    nch);
  	if (!netdev) {
  		mlx5_core_err(mdev, "alloc_etherdev_mqs() failed\n");
@@@ -3055,76 -3289,41 +3259,90 @@@
  	err = mlx5e_create_umr_mkey(priv);
  	if (err) {
  		mlx5_core_err(mdev, "create umr mkey failed, %d\n", err);
 -		goto err_destroy_wq;
 +		goto err_destroy_mkey;
  	}
  
- 	err = mlx5e_create_tises(priv);
- 	if (err) {
- 		mlx5_core_warn(mdev, "create tises failed, %d\n", err);
+ 	err = profile->init_tx(priv);
+ 	if (err)
  		goto err_destroy_umr_mkey;
- 	}
  
  	err = mlx5e_open_drop_rq(priv);
  	if (err) {
  		mlx5_core_err(mdev, "open drop rq failed, %d\n", err);
- 		goto err_destroy_tises;
+ 		goto err_cleanup_tx;
  	}
  
- 	err = mlx5e_create_rqts(priv);
- 	if (err) {
- 		mlx5_core_warn(mdev, "create rqts failed, %d\n", err);
+ 	err = profile->init_rx(priv);
+ 	if (err)
  		goto err_close_drop_rq;
++<<<<<<< HEAD
 +	}
 +
 +	err = mlx5e_create_tirs(priv);
 +	if (err) {
 +		mlx5_core_warn(mdev, "create tirs failed, %d\n", err);
 +		goto err_destroy_rqts;
 +	}
 +
 +	err = mlx5e_create_flow_tables(priv);
 +	if (err) {
 +		mlx5_core_warn(mdev, "create flow tables failed, %d\n", err);
 +		goto err_destroy_tirs;
 +	}
++=======
++>>>>>>> 6bfd390ba546 (net/mlx5e: Add support for multiple profiles)
  
  	mlx5e_create_q_counter(priv);
  
 -	mlx5e_init_l2_addr(priv);
 +	mlx5e_init_eth_addr(priv);
 +
++<<<<<<< HEAD
 +	mlx5e_vxlan_init(priv);
 +
 +#ifdef CONFIG_MLX5_CORE_EN_DCB
 +	mlx5e_dcbnl_ieee_setets_core(priv, &priv->params.ets);
 +#endif
  
++=======
++>>>>>>> 6bfd390ba546 (net/mlx5e: Add support for multiple profiles)
  	err = register_netdev(netdev);
  	if (err) {
  		mlx5_core_err(mdev, "register_netdev failed, %d\n", err);
  		goto err_dealloc_q_counters;
  	}
  
++<<<<<<< HEAD
 +	if (mlx5e_vxlan_allowed(mdev)) {
 +		rtnl_lock();
 +		vxlan_get_rx_port(netdev);
 +		rtnl_unlock();
 +	}
 +
 +	mlx5e_enable_async_events(priv);
 +	queue_work(priv->wq, &priv->set_rx_mode_work);
 +
 +	return priv;
 +
 +
 +err_dealloc_q_counters:
 +	mlx5e_destroy_q_counter(priv);
 +	mlx5e_destroy_flow_tables(priv);
 +
 +err_destroy_tirs:
 +	mlx5e_destroy_tirs(priv);
 +
 +err_destroy_rqts:
 +	mlx5e_destroy_rqts(priv);
++=======
+ 	if (profile->enable)
+ 		profile->enable(priv);
+ 
+ 	return priv;
+ 
+ err_dealloc_q_counters:
+ 	mlx5e_destroy_q_counter(priv);
+ 	profile->cleanup_rx(priv);
++>>>>>>> 6bfd390ba546 (net/mlx5e: Add support for multiple profiles)
  
  err_close_drop_rq:
  	mlx5e_close_drop_rq(priv);
@@@ -3156,9 -3343,27 +3374,33 @@@ err_free_netdev
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, void *vpriv)
 +{
 +	struct mlx5e_priv *priv = vpriv;
++=======
+ static void *mlx5e_add(struct mlx5_core_dev *mdev)
+ {
+ 	void *ret;
+ 
+ 	if (mlx5e_check_required_hca_cap(mdev))
+ 		return NULL;
+ 
+ 	if (mlx5e_create_mdev_resources(mdev))
+ 		return NULL;
+ 
+ 	ret = mlx5e_create_netdev(mdev, &mlx5e_nic_profile);
+ 	if (!ret) {
+ 		mlx5e_destroy_mdev_resources(mdev);
+ 		return NULL;
+ 	}
+ 	return ret;
+ }
+ 
+ static void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, struct mlx5e_priv *priv)
+ {
+ 	const struct mlx5e_profile *profile = priv->profile;
++>>>>>>> 6bfd390ba546 (net/mlx5e: Add support for multiple profiles)
  	struct net_device *netdev = priv->netdev;
  
  	set_bit(MLX5E_STATE_DESTROYING, &priv->state);
@@@ -3173,20 -3378,15 +3415,27 @@@
  		unregister_netdev(netdev);
  	}
  
++<<<<<<< HEAD
 +	mlx5e_vxlan_cleanup(priv);
 +	mlx5e_destroy_q_counter(priv);
 +	mlx5e_destroy_flow_tables(priv);
 +	mlx5e_destroy_tirs(priv);
 +	mlx5e_destroy_rqts(priv);
++=======
+ 	mlx5e_destroy_q_counter(priv);
+ 	profile->cleanup_rx(priv);
++>>>>>>> 6bfd390ba546 (net/mlx5e: Add support for multiple profiles)
  	mlx5e_close_drop_rq(priv);
- 	mlx5e_destroy_tises(priv);
+ 	profile->cleanup_tx(priv);
  	mlx5_core_destroy_mkey(priv->mdev, &priv->umr_mkey);
 +	mlx5_core_destroy_mkey(priv->mdev, &priv->mkey);
 +	mlx5_core_dealloc_transport_domain(priv->mdev, priv->tdn);
 +	mlx5_core_dealloc_pd(priv->mdev, priv->pdn);
 +	mlx5_unmap_free_uar(priv->mdev, &priv->cq_uar);
  	cancel_delayed_work_sync(&priv->update_stats_work);
  	destroy_workqueue(priv->wq);
+ 	if (profile->cleanup)
+ 		profile->cleanup(priv);
  
  	if (!test_bit(MLX5_INTERFACE_STATE_SHUTDOWN, &mdev->intf_state))
  		free_netdev(netdev);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index 5eea7e35421a..7c9a4d3cd878 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -477,6 +477,22 @@ struct mlx5e_direct_tir {
 	u32              rqtn;
 };
 
+struct mlx5e_profile {
+	void	(*init)(struct mlx5_core_dev *mdev,
+			struct net_device *netdev,
+			const struct mlx5e_profile *profile);
+	void	(*cleanup)(struct mlx5e_priv *priv);
+	int	(*init_rx)(struct mlx5e_priv *priv);
+	void	(*cleanup_rx)(struct mlx5e_priv *priv);
+	int	(*init_tx)(struct mlx5e_priv *priv);
+	void	(*cleanup_tx)(struct mlx5e_priv *priv);
+	void	(*enable)(struct mlx5e_priv *priv);
+	void	(*disable)(struct mlx5e_priv *priv);
+	void	(*update_stats)(struct mlx5e_priv *priv);
+	int	(*max_nch)(struct mlx5_core_dev *mdev);
+	int	max_tc;
+};
+
 struct mlx5e_priv {
 	/* priv data path fields - start */
 	struct mlx5e_sq            **txq_to_sq_map;
@@ -517,6 +533,7 @@ struct mlx5e_priv {
 	struct mlx5e_stats         stats;
 	struct mlx5e_tstamp        tstamp;
 	u16 q_counter;
+	const struct mlx5e_profile *profile;
 };
 
 enum mlx5e_link_mode {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
