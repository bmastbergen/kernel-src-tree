mmc: dw_mmc: remove the quirks flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mmc] dw_mmc: remove the quirks flags (Don Zickus) [1430497]
Rebuild_FUZZ: 92.54%
commit-author Jaehoon Chung <jh80.chung@samsung.com>
commit 16a34574c6ca12bb8fd73ae034acd5b536d3cdaa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/16a34574.failed

Remove the quirks flag. (DW_MCI_QUIRK_BROKEN_DTO)
For removing this, enabled the dto_timer by defaults.
It doesn't see any I/O performance degression.
In future, dwmmc controller should not use the quirks flag.

	Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
	Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 16a34574c6ca12bb8fd73ae034acd5b536d3cdaa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/dw_mmc-rockchip.c
#	drivers/mmc/host/dw_mmc.c
#	include/linux/mmc/dw_mmc.h
diff --cc drivers/mmc/host/dw_mmc.c
index bc3a1bc4940f,e7fb0527d0e3..000000000000
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@@ -1070,17 -1819,57 +1070,38 @@@ static void dw_mci_tasklet_func(unsigne
  			}
  
  			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,
++<<<<<<< HEAD
 +						&host->pending_events))
++=======
+ 						&host->pending_events)) {
+ 				/*
+ 				 * If all data-related interrupts don't come
+ 				 * within the given time in reading data state.
+ 				 */
+ 				if (host->dir_status == DW_MCI_RECV_STATUS)
+ 					dw_mci_set_drto(host);
++>>>>>>> 16a34574c6ca (mmc: dw_mmc: remove the quirks flags)
  				break;
 -			}
  
  			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);
 -
 -			/*
 -			 * Handle an EVENT_DATA_ERROR that might have shown up
 -			 * before the transfer completed.  This might not have
 -			 * been caught by the check above because the interrupt
 -			 * could have gone off between the previous check and
 -			 * the check for transfer complete.
 -			 *
 -			 * Technically this ought not be needed assuming we
 -			 * get a DATA_COMPLETE eventually (we'll notice the
 -			 * error and end the request), but it shouldn't hurt.
 -			 *
 -			 * This has the advantage of sending the stop command.
 -			 */
 -			if (test_and_clear_bit(EVENT_DATA_ERROR,
 -					       &host->pending_events)) {
 -				dw_mci_stop_dma(host);
 -				if (data->stop ||
 -				    !(host->data_status & (SDMMC_INT_DRTO |
 -							   SDMMC_INT_EBE)))
 -					send_stop_abort(host, data);
 -				state = STATE_DATA_ERROR;
 -				break;
 -			}
  			prev_state = state = STATE_DATA_BUSY;
 -
  			/* fall through */
  
  		case STATE_DATA_BUSY:
  			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,
++<<<<<<< HEAD
 +						&host->pending_events))
++=======
+ 						&host->pending_events)) {
+ 				/*
+ 				 * If data error interrupt comes but data over
+ 				 * interrupt doesn't come within the given time.
+ 				 * in reading data state.
+ 				 */
+ 				if (host->dir_status == DW_MCI_RECV_STATUS)
+ 					dw_mci_set_drto(host);
++>>>>>>> 16a34574c6ca (mmc: dw_mmc: remove the quirks flags)
  				break;
 -			}
  
  			host->data = NULL;
  			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);
@@@ -1624,6 -2432,8 +1645,11 @@@ static irqreturn_t dw_mci_interrupt(in
  		}
  
  		if (pending & SDMMC_INT_DATA_OVER) {
++<<<<<<< HEAD
++=======
+ 			del_timer(&host->dto_timer);
+ 
++>>>>>>> 16a34574c6ca (mmc: dw_mmc: remove the quirks flags)
  			mci_writel(host, RINTSTS, SDMMC_INT_DATA_OVER);
  			if (!host->data_status)
  				host->data_status = pending;
@@@ -2236,9 -3011,23 +2262,26 @@@ int dw_mci_probe(struct dw_mci *host
  		goto err_clk_ciu;
  	}
  
++<<<<<<< HEAD
 +	host->quirks = host->pdata->quirks;
++=======
+ 	if (drv_data && drv_data->init) {
+ 		ret = drv_data->init(host);
+ 		if (ret) {
+ 			dev_err(host->dev,
+ 				"implementation specific init failed\n");
+ 			goto err_clk_ciu;
+ 		}
+ 	}
+ 
+ 	setup_timer(&host->cmd11_timer,
+ 		    dw_mci_cmd11_timer, (unsigned long)host);
+ 
+ 	setup_timer(&host->dto_timer,
+ 		    dw_mci_dto_timer, (unsigned long)host);
++>>>>>>> 16a34574c6ca (mmc: dw_mmc: remove the quirks flags)
  
  	spin_lock_init(&host->lock);
 -	spin_lock_init(&host->irq_lock);
  	INIT_LIST_HEAD(&host->queue);
  
  	/*
diff --cc include/linux/mmc/dw_mmc.h
index 1f2636132520,83b0edfce471..000000000000
--- a/include/linux/mmc/dw_mmc.h
+++ b/include/linux/mmc/dw_mmc.h
@@@ -236,12 -238,6 +232,15 @@@ struct dw_mci_dma_ops 
  	void (*exit)(struct dw_mci *host);
  };
  
++<<<<<<< HEAD
 +/* IP Quirks/flags. */
 +/* Unreliable card detection */
 +#define DW_MCI_QUIRK_BROKEN_CARD_DETECTION	BIT(0)
 +/* Timer for broken data transfer over scheme */
 +#define DW_MCI_QUIRK_BROKEN_DTO			BIT(1)
 +
++=======
++>>>>>>> 16a34574c6ca (mmc: dw_mmc: remove the quirks flags)
  struct dma_pdata;
  
  /* Board platform data */
* Unmerged path drivers/mmc/host/dw_mmc-rockchip.c
* Unmerged path drivers/mmc/host/dw_mmc-rockchip.c
* Unmerged path drivers/mmc/host/dw_mmc.c
* Unmerged path include/linux/mmc/dw_mmc.h
