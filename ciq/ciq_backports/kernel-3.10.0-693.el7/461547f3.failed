flow_dissector: Fix unaligned access in __skb_flow_dissector when used by eth_get_headlen

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit 461547f3158978c180d74484d58e82be9b8e7357
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/461547f3.failed

This patch fixes an issue with unaligned accesses when using
eth_get_headlen on a page that was DMA aligned instead of being IP aligned.
The fact is when trying to check the length we don't need to be looking at
the flow label so we can reorder the checks to first check if we are
supposed to gather the flow label and then make the call to actually get
it.

v2:  Updated path so that either STOP_AT_FLOW_LABEL or KEY_FLOW_LABEL can
     cause us to check for the flow label.

	Reported-by: Sowmini Varadhan <sowmini.varadhan@oracle.com>
	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 461547f3158978c180d74484d58e82be9b8e7357)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,eab81bc80e5c..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -145,31 -177,77 +145,69 @@@ ip
  		nhoff += iph->ihl * 4;
  
  		ip_proto = iph->protocol;
 +		if (ip_is_fragment(iph))
 +			ip_proto = 0;
  
 -		if (!dissector_uses_key(flow_dissector,
 -					FLOW_DISSECTOR_KEY_IPV4_ADDRS))
 -			break;
 -
 -		key_addrs = skb_flow_dissector_target(flow_dissector,
 -			      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);
 -		memcpy(&key_addrs->v4addrs, &iph->saddr,
 -		       sizeof(key_addrs->v4addrs));
 -		key_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
 -
 -		if (ip_is_fragment(iph)) {
 -			key_control->flags |= FLOW_DIS_IS_FRAGMENT;
 -
 -			if (iph->frag_off & htons(IP_OFFSET)) {
 -				goto out_good;
 -			} else {
 -				key_control->flags |= FLOW_DIS_FIRST_FRAG;
 -				if (!(flags & FLOW_DISSECTOR_F_PARSE_1ST_FRAG))
 -					goto out_good;
 -			}
 -		}
 -
 -		if (flags & FLOW_DISSECTOR_F_STOP_AT_L3)
 -			goto out_good;
 -
 +		iph_to_flow_copy_addrs(flow, iph);
  		break;
  	}
 -	case htons(ETH_P_IPV6): {
 +	case __constant_htons(ETH_P_IPV6): {
  		const struct ipv6hdr *iph;
  		struct ipv6hdr _iph;
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 461547f31589 (flow_dissector: Fix unaligned access in __skb_flow_dissector when used by eth_get_headlen)
  ipv6:
  		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
  		if (!iph)
 -			goto out_bad;
 +			return false;
  
  		ip_proto = iph->nexthdr;
 +		flow->src = (__force __be32)ipv6_addr_hash(&iph->saddr);
 +		flow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);
  		nhoff += sizeof(struct ipv6hdr);
  
++<<<<<<< HEAD
 +		/* skip the flow label processing if skb is NULL.  The
 +		 * assumption here is that if there is no skb we are not
 +		 * looking for flow info as much as we are length.
 +		 */
 +		if (!skb)
 +			break;
++=======
+ 		if (dissector_uses_key(flow_dissector,
+ 				       FLOW_DISSECTOR_KEY_IPV6_ADDRS)) {
+ 			struct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;
+ 
+ 			key_ipv6_addrs = skb_flow_dissector_target(flow_dissector,
+ 								   FLOW_DISSECTOR_KEY_IPV6_ADDRS,
+ 								   target_container);
+ 
+ 			memcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));
+ 			key_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
+ 		}
+ 
+ 		if ((dissector_uses_key(flow_dissector,
+ 					FLOW_DISSECTOR_KEY_FLOW_LABEL) ||
+ 		     (flags & FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL)) &&
+ 		    ip6_flowlabel(iph)) {
+ 			__be32 flow_label = ip6_flowlabel(iph);
+ 
+ 			if (dissector_uses_key(flow_dissector,
+ 					       FLOW_DISSECTOR_KEY_FLOW_LABEL)) {
+ 				key_tags = skb_flow_dissector_target(flow_dissector,
+ 								     FLOW_DISSECTOR_KEY_FLOW_LABEL,
+ 								     target_container);
+ 				key_tags->flow_label = ntohl(flow_label);
+ 			}
+ 			if (flags & FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL)
+ 				goto out_good;
+ 		}
+ 
+ 		if (flags & FLOW_DISSECTOR_F_STOP_AT_L3)
+ 			goto out_good;
++>>>>>>> 461547f31589 (flow_dissector: Fix unaligned access in __skb_flow_dissector when used by eth_get_headlen)
  
  		break;
  	}
* Unmerged path net/core/flow_dissector.c
