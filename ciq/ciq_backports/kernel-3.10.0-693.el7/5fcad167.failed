HID: wacom: ask for a in-prox report when it was missed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: ask for a in-prox report when it was missed (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.24%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 5fcad167315f224eaf6750b0fb85ee6c92f087cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5fcad167.failed

If noone listens to the input device when a tool comes in proximity,
the tablet does not send the in-prox event when a client becomes available.
That means that no events will be sent until the tool is taken out of
proximity.

In this situation, ask for the report WACOM_REPORT_INTUOSREAD which will
read the corresponding feature and generate an in-prox event.
To make some generation of hardware working, we need to unset the
quirk NO_GET set by hid-core because the interfaces are seen as "boot
mouse".

We don't schedule this read in a worker while we are in an IO interrupt.
We know that usbhid will do it asynchronously. If this is triggered by
uhid, then this is obviously a client side bug :)

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Jason Gerecke <killertofu@gmail.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 5fcad167315f224eaf6750b0fb85ee6c92f087cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,353fe476be26..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1301,10 -1401,16 +1301,18 @@@ static int wacom_probe(struct usb_inter
  	struct wacom_wac *wacom_wac;
  	struct wacom_features *features;
  	int error;
 -	unsigned int connect_mask = HID_CONNECT_HIDRAW;
  
 -	if (!id->driver_data)
 +	if (!id->driver_info)
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	hdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;
+ 
+ 	/* hid-core sets this quirk for the boot interface */
+ 	hdev->quirks &= ~HID_QUIRK_NOGET;
+ 
++>>>>>>> 5fcad167315f (HID: wacom: ask for a in-prox report when it was missed)
  	wacom = kzalloc(sizeof(struct wacom), GFP_KERNEL);
  	if (!wacom)
  		return -ENOMEM;
* Unmerged path drivers/hid/wacom_sys.c
diff --git a/drivers/hid/wacom_wac.c b/drivers/hid/wacom_wac.c
index 27dda3639500..957d2aa21933 100644
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@ -322,6 +322,19 @@ exit:
 	return retval;
 }
 
+static void wacom_intuos_schedule_prox_event(struct wacom_wac *wacom_wac)
+{
+	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+	struct hid_report *r;
+	struct hid_report_enum *re;
+
+	re = &(wacom->hdev->report_enum[HID_FEATURE_REPORT]);
+	r = re->report_id_hash[WACOM_REPORT_INTUOSREAD];
+	if (r) {
+		hid_hw_request(wacom->hdev, r, HID_REQ_GET_REPORT);
+	}
+}
+
 static int wacom_intuos_inout(struct wacom_wac *wacom)
 {
 	struct wacom_features *features = &wacom->features;
@@ -496,8 +509,11 @@ static int wacom_intuos_inout(struct wacom_wac *wacom)
 	}
 
 	/* don't report other events if we don't know the ID */
-	if (!wacom->id[idx])
+	if (!wacom->id[idx]) {
+		/* but reschedule a read of the current tool */
+		wacom_intuos_schedule_prox_event(wacom);
 		return 1;
+	}
 
 	return 0;
 }
