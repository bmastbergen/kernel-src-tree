dax: Remove pointless writeback from dax_do_io()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jan Kara <jack@suse.cz>
commit c3d98e39d5b37320b15f227686575d58f676e6ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c3d98e39.failed

dax_do_io() is calling filemap_write_and_wait() if DIO_LOCKING flags is
set. Presumably this was copied over from direct IO code. However DAX
inodes have no pagecache pages to write so the call is pointless. Remove
it.

	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
(cherry picked from commit c3d98e39d5b37320b15f227686575d58f676e6ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
diff --cc fs/dax.c
index ac0232cd059c,237581441bc1..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -293,15 -268,8 +293,20 @@@ ssize_t dax_do_io(int rw, struct kiocb 
  	memset(&bh, 0, sizeof(bh));
  	bh.b_bdev = inode->i_sb->s_bdev;
  
++<<<<<<< HEAD
 +	if ((flags & DIO_LOCKING) && (rw == READ)) {
 +		struct address_space *mapping = inode->i_mapping;
 +		mutex_lock(&inode->i_mutex);
 +		retval = filemap_write_and_wait_range(mapping, pos, end - 1);
 +		if (retval) {
 +			mutex_unlock(&inode->i_mutex);
 +			goto out;
 +		}
 +	}
++=======
+ 	if ((flags & DIO_LOCKING) && iov_iter_rw(iter) == READ)
+ 		inode_lock(inode);
++>>>>>>> c3d98e39d5b3 (dax: Remove pointless writeback from dax_do_io())
  
  	/* Protects against truncate */
  	if (!(flags & DIO_SKIP_DIO_COUNT))
* Unmerged path fs/dax.c
