ALSA: hda - Allow to enable/disable vmaster build explicitly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Takashi Iwai <tiwai@suse.de>
commit 7480316c265c9fcdbf73b1b8dec061b893b7e987
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7480316c.failed

Another preliminary patch for the dual-codec support: since the
support of vmaster over multiple codecs is difficult, simply disable
it by a new flag to hda_codec struct.  A new user hint is added as
well for consistency.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 7480316c265c9fcdbf73b1b8dec061b893b7e987)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/sound/alsa/HD-Audio.txt
diff --cc Documentation/sound/alsa/HD-Audio.txt
index e7193aac669c,f59c3cdbfaf4..000000000000
--- a/Documentation/sound/alsa/HD-Audio.txt
+++ b/Documentation/sound/alsa/HD-Audio.txt
@@@ -428,54 -433,71 +428,122 @@@ auto-switch.  As a boolean value, eithe
  
  The generic parser supports the following hints:
  
++<<<<<<< HEAD:Documentation/sound/alsa/HD-Audio.txt
 +- jack_detect (bool): specify whether the jack detection is available
 +  at all on this machine; default true
 +- inv_jack_detect (bool): indicates that the jack detection logic is
 +  inverted
 +- trigger_sense (bool): indicates that the jack detection needs the
 +  explicit call of AC_VERB_SET_PIN_SENSE verb
 +- inv_eapd (bool): indicates that the EAPD is implemented in the
 +  inverted logic
 +- pcm_format_first (bool): sets the PCM format before the stream tag
 +  and channel ID
 +- sticky_stream (bool): keep the PCM format, stream tag and ID as long
 +  as possible; default true
 +- spdif_status_reset (bool): reset the SPDIF status bits at each time
 +  the SPDIF stream is set up
 +-  pin_amp_workaround (bool): the output pin may have multiple amp
 +  values
 +- single_adc_amp (bool): ADCs can have only single input amps
 +- auto_mute (bool): enable/disable the headphone auto-mute feature;
 +  default true
 +- auto_mic (bool): enable/disable the mic auto-switch feature; default
 +  true
 +- line_in_auto_switch (bool): enable/disable the line-in auto-switch
 +  feature; default false
 +- need_dac_fix (bool): limits the DACs depending on the channel count
 +- primary_hp (bool): probe headphone jacks as the primary outputs;
 +  default true
 +- multi_io (bool): try probing multi-I/O config (e.g. shared
 +  line-in/surround, mic/clfe jacks)
 +- multi_cap_vol (bool): provide multiple capture volumes
 +- inv_dmic_split (bool): provide split internal mic volume/switch for
 +  phase-inverted digital mics
 +- indep_hp (bool): provide the independent headphone PCM stream and
 +  the corresponding mixer control, if available
 +- add_stereo_mix_input (bool): add the stereo mix (analog-loopback
 +  mix) to the input mux if available
 +- add_jack_modes (bool): add "xxx Jack Mode" enum controls to each
 +  I/O jack for allowing to change the headphone amp and mic bias VREF
 +  capabilities
 +- power_save_node (bool): advanced power management for each widget,
 +  controlling the power sate (D0/D3) of each widget node depending on
 +  the actual pin and stream states
 +- power_down_unused (bool): power down the unused widgets, a subset of
 +  power_save_node, and will be dropped in future
 +- add_hp_mic (bool): add the headphone to capture source if possible
 +- hp_mic_detect (bool): enable/disable the hp/mic shared input for a
 +  single built-in mic case; default true
 +- mixer_nid (int): specifies the widget NID of the analog-loopback
 +  mixer
++=======
+ jack_detect (bool)
+     specify whether the jack detection is available at all on this
+     machine; default true
+ inv_jack_detect (bool)
+     indicates that the jack detection logic is inverted
+ trigger_sense (bool)
+     indicates that the jack detection needs the explicit call of
+     AC_VERB_SET_PIN_SENSE verb
+ inv_eapd (bool)
+     indicates that the EAPD is implemented in the inverted logic
+ pcm_format_first (bool)
+     sets the PCM format before the stream tag and channel ID
+ sticky_stream (bool)
+     keep the PCM format, stream tag and ID as long as possible;
+     default true
+ spdif_status_reset (bool)
+     reset the SPDIF status bits at each time the SPDIF stream is set
+     up
+ pin_amp_workaround (bool)
+     the output pin may have multiple amp values
+ single_adc_amp (bool)
+     ADCs can have only single input amps
+ auto_mute (bool)
+     enable/disable the headphone auto-mute feature; default true
+ auto_mic (bool)
+     enable/disable the mic auto-switch feature; default true
+ line_in_auto_switch (bool)
+     enable/disable the line-in auto-switch feature; default false
+ need_dac_fix (bool)
+     limits the DACs depending on the channel count
+ primary_hp (bool)
+     probe headphone jacks as the primary outputs; default true
+ multi_io (bool)
+     try probing multi-I/O config (e.g. shared line-in/surround,
+     mic/clfe jacks)
+ multi_cap_vol (bool)
+     provide multiple capture volumes
+ inv_dmic_split (bool)
+     provide split internal mic volume/switch for phase-inverted
+     digital mics
+ indep_hp (bool)
+     provide the independent headphone PCM stream and the corresponding
+     mixer control, if available
+ add_stereo_mix_input (bool)
+     add the stereo mix (analog-loopback mix) to the input mux if
+     available 
+ add_jack_modes (bool)
+     add "xxx Jack Mode" enum controls to each I/O jack for allowing to
+     change the headphone amp and mic bias VREF capabilities
+ power_save_node (bool)
+     advanced power management for each widget, controlling the power
+     sate (D0/D3) of each widget node depending on the actual pin and
+     stream states
+ power_down_unused (bool)
+     power down the unused widgets, a subset of power_save_node, and
+     will be dropped in future 
+ add_hp_mic (bool)
+     add the headphone to capture source if possible
+ hp_mic_detect (bool)
+     enable/disable the hp/mic shared input for a single built-in mic
+     case; default true
+ vmaster (bool)
+     enable/disable the virtual Master control; default true
+ mixer_nid (int)
+     specifies the widget NID of the analog-loopback mixer
++>>>>>>> 7480316c265c (ALSA: hda - Allow to enable/disable vmaster build explicitly):Documentation/sound/hd-audio/notes.rst
  
  
  Early Patching
* Unmerged path Documentation/sound/alsa/HD-Audio.txt
diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c
index 443832870a44..2842c82363c0 100644
--- a/sound/pci/hda/hda_generic.c
+++ b/sound/pci/hda/hda_generic.c
@@ -196,6 +196,9 @@ static void parse_user_hints(struct hda_codec *codec)
 	val = snd_hda_get_bool_hint(codec, "hp_mic_detect");
 	if (val >= 0)
 		spec->suppress_hp_mic_detect = !val;
+	val = snd_hda_get_bool_hint(codec, "vmaster");
+	if (val >= 0)
+		spec->suppress_vmaster = !val;
 
 	if (!snd_hda_get_int_hint(codec, "mixer_nid", &val))
 		spec->mixer_nid = val;
@@ -5033,7 +5036,7 @@ int snd_hda_gen_build_controls(struct hda_codec *codec)
 	}
 
 	/* if we have no master control, let's create it */
-	if (!spec->no_analog &&
+	if (!spec->no_analog && !spec->suppress_vmaster &&
 	    !snd_hda_find_mixer_ctl(codec, "Master Playback Volume")) {
 		err = snd_hda_add_vmaster(codec, "Master Playback Volume",
 					  spec->vmaster_tlv, slave_pfxs,
@@ -5041,7 +5044,7 @@ int snd_hda_gen_build_controls(struct hda_codec *codec)
 		if (err < 0)
 			return err;
 	}
-	if (!spec->no_analog &&
+	if (!spec->no_analog && !spec->suppress_vmaster &&
 	    !snd_hda_find_mixer_ctl(codec, "Master Playback Switch")) {
 		err = __snd_hda_add_vmaster(codec, "Master Playback Switch",
 					    NULL, slave_pfxs,
diff --git a/sound/pci/hda/hda_generic.h b/sound/pci/hda/hda_generic.h
index f66fc7e25e07..61772317de46 100644
--- a/sound/pci/hda/hda_generic.h
+++ b/sound/pci/hda/hda_generic.h
@@ -229,6 +229,7 @@ struct hda_gen_spec {
 	unsigned int add_jack_modes:1; /* add i/o jack mode enum ctls */
 	unsigned int power_down_unused:1; /* power down unused widgets */
 	unsigned int dac_min_mute:1; /* minimal = mute for DACs */
+	unsigned int suppress_vmaster:1; /* don't create vmaster kctls */
 
 	/* other internal flags */
 	unsigned int no_analog:1; /* digital I/O only */
