scsi: megaraid_sas: raid6 also require cpuSel check same as raid5

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] megaraid_sas: raid6 also require cpuSel check same as raid5 (Tomas Henzl) [1433861]
Rebuild_FUZZ: 95.16%
commit-author Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
commit 874d025da667d19b728141437ccbefe9dbaf9e7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/874d025d.failed

Without this fix, raid6 performance will not be optimal.

	Signed-off-by: Kashyap Desai <kashyap.desai@broadcom.com>
	Signed-off-by: Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 874d025da667d19b728141437ccbefe9dbaf9e7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_fusion.c
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.c
index 50ad36bc60c5,f990ab4d45e1..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@@ -1827,10 -2097,88 +1827,91 @@@ static void megasas_stream_detect(struc
  	current_sd = &current_ld_sd->stream_track[stream_num];
  	current_sd->is_read = io_info->isRead;
  	current_sd->next_seq_lba = io_info->ldStartBlock + io_info->numBlocks;
 -	*track_stream = (((*track_stream & ZERO_LAST_STREAM) << 4) | stream_num);
 +	*track_stream =
 +	(((*track_stream & ZERO_LAST_STREAM) << 4) | stream_num);
  	return;
 -}
  
++<<<<<<< HEAD
++=======
+ /**
+  * megasas_set_raidflag_cpu_affinity - This function sets the cpu
+  * affinity (cpu of the controller) and raid_flags in the raid context
+  * based on IO type.
+  *
+  * @praid_context:	IO RAID context
+  * @raid:		LD raid map
+  * @fp_possible:	Is fast path possible?
+  * @is_read:		Is read IO?
+  *
+  */
+ static void
+ megasas_set_raidflag_cpu_affinity(union RAID_CONTEXT_UNION *praid_context,
+ 				  struct MR_LD_RAID *raid, bool fp_possible,
+ 				  u8 is_read, u32 scsi_buff_len)
+ {
+ 	u8 cpu_sel = MR_RAID_CTX_CPUSEL_0;
+ 	struct RAID_CONTEXT_G35 *rctx_g35;
+ 
+ 	rctx_g35 = &praid_context->raid_context_g35;
+ 	if (fp_possible) {
+ 		if (is_read) {
+ 			if ((raid->cpuAffinity.pdRead.cpu0) &&
+ 			    (raid->cpuAffinity.pdRead.cpu1))
+ 				cpu_sel = MR_RAID_CTX_CPUSEL_FCFS;
+ 			else if (raid->cpuAffinity.pdRead.cpu1)
+ 				cpu_sel = MR_RAID_CTX_CPUSEL_1;
+ 		} else {
+ 			if ((raid->cpuAffinity.pdWrite.cpu0) &&
+ 			    (raid->cpuAffinity.pdWrite.cpu1))
+ 				cpu_sel = MR_RAID_CTX_CPUSEL_FCFS;
+ 			else if (raid->cpuAffinity.pdWrite.cpu1)
+ 				cpu_sel = MR_RAID_CTX_CPUSEL_1;
+ 			/* Fast path cache by pass capable R0/R1 VD */
+ 			if ((raid->level <= 1) &&
+ 			    (raid->capability.fp_cache_bypass_capable)) {
+ 				rctx_g35->routing_flags |=
+ 					(1 << MR_RAID_CTX_ROUTINGFLAGS_SLD_SHIFT);
+ 				rctx_g35->raid_flags =
+ 					(MR_RAID_FLAGS_IO_SUB_TYPE_CACHE_BYPASS
+ 					<< MR_RAID_CTX_RAID_FLAGS_IO_SUB_TYPE_SHIFT);
+ 			}
+ 		}
+ 	} else {
+ 		if (is_read) {
+ 			if ((raid->cpuAffinity.ldRead.cpu0) &&
+ 			    (raid->cpuAffinity.ldRead.cpu1))
+ 				cpu_sel = MR_RAID_CTX_CPUSEL_FCFS;
+ 			else if (raid->cpuAffinity.ldRead.cpu1)
+ 				cpu_sel = MR_RAID_CTX_CPUSEL_1;
+ 		} else {
+ 			if ((raid->cpuAffinity.ldWrite.cpu0) &&
+ 			    (raid->cpuAffinity.ldWrite.cpu1))
+ 				cpu_sel = MR_RAID_CTX_CPUSEL_FCFS;
+ 			else if (raid->cpuAffinity.ldWrite.cpu1)
+ 				cpu_sel = MR_RAID_CTX_CPUSEL_1;
+ 
+ 			if (is_stream_detected(rctx_g35) &&
+ 			    ((raid->level == 5) || (raid->level == 6)) &&
+ 			    (raid->writeMode == MR_RL_WRITE_THROUGH_MODE) &&
+ 			    (cpu_sel == MR_RAID_CTX_CPUSEL_FCFS))
+ 				cpu_sel = MR_RAID_CTX_CPUSEL_0;
+ 		}
+ 	}
+ 
+ 	rctx_g35->routing_flags |=
+ 		(cpu_sel << MR_RAID_CTX_ROUTINGFLAGS_CPUSEL_SHIFT);
+ 
+ 	/* Always give priority to MR_RAID_FLAGS_IO_SUB_TYPE_LDIO_BW_LIMIT
+ 	 * vs MR_RAID_FLAGS_IO_SUB_TYPE_CACHE_BYPASS.
+ 	 * IO Subtype is not bitmap.
+ 	 */
+ 	if ((raid->level == 1) && (!is_read)) {
+ 		if (scsi_buff_len > MR_LARGE_IO_MIN_SIZE)
+ 			praid_context->raid_context_g35.raid_flags =
+ 				(MR_RAID_FLAGS_IO_SUB_TYPE_LDIO_BW_LIMIT
+ 				<< MR_RAID_CTX_RAID_FLAGS_IO_SUB_TYPE_SHIFT);
+ 	}
++>>>>>>> 874d025da667 (scsi: megaraid_sas: raid6 also require cpuSel check same as raid5)
  }
  
  /**
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.c
