crypto: af_alg - Add nokey compatibility path

jira LE-1907
cve CVE-2015-8970
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] af_alg - Add nokey compatibility path ("Bruno E. O. Meneguele") [1386234] {CVE-2015-8970}
Rebuild_FUZZ: 90.24%
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 37766586c965d63758ad542325a96d5384f4a8c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/37766586.failed

This patch adds a compatibility path to support old applications
that do acept(2) before setkey.

	Cc: stable@vger.kernel.org
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 37766586c965d63758ad542325a96d5384f4a8c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/crypto/if_alg.h
diff --cc include/crypto/if_alg.h
index 2f38daaab3d7,df8284415c56..000000000000
--- a/include/crypto/if_alg.h
+++ b/include/crypto/if_alg.h
@@@ -51,8 -52,11 +51,14 @@@ struct af_alg_type 
  	void (*release)(void *private);
  	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
  	int (*accept)(void *private, struct sock *sk);
++<<<<<<< HEAD
++=======
+ 	int (*accept_nokey)(void *private, struct sock *sk);
+ 	int (*setauthsize)(void *private, unsigned int authsize);
++>>>>>>> 37766586c965 (crypto: af_alg - Add nokey compatibility path)
  
  	struct proto_ops *ops;
+ 	struct proto_ops *ops_nokey;
  	struct module *owner;
  	char name[14];
  };
diff --git a/crypto/af_alg.c b/crypto/af_alg.c
index 5a2902e7e684..06e19b5a7d31 100644
--- a/crypto/af_alg.c
+++ b/crypto/af_alg.c
@@ -76,6 +76,8 @@ int af_alg_register_type(const struct af_alg_type *type)
 		goto unlock;
 
 	type->ops->owner = THIS_MODULE;
+	if (type->ops_nokey)
+		type->ops_nokey->owner = THIS_MODULE;
 	node->type = type;
 	list_add(&node->list, &alg_types);
 	err = 0;
@@ -257,6 +259,7 @@ int af_alg_accept(struct sock *sk, struct socket *newsock)
 	const struct af_alg_type *type;
 	struct sock *sk2;
 	int err;
+	bool nokey;
 
 	lock_sock(sk);
 	type = ask->type;
@@ -275,12 +278,17 @@ int af_alg_accept(struct sock *sk, struct socket *newsock)
 	security_sk_clone(sk, sk2);
 
 	err = type->accept(ask->private, sk2);
+
+	nokey = err == -ENOKEY;
+	if (nokey && type->accept_nokey)
+		err = type->accept_nokey(ask->private, sk2);
+
 	if (err)
 		goto unlock;
 
 	sk2->sk_family = PF_ALG;
 
-	if (!ask->refcnt++)
+	if (nokey || !ask->refcnt++)
 		sock_hold(sk);
 	alg_sk(sk2)->parent = sk;
 	alg_sk(sk2)->type = type;
@@ -288,6 +296,9 @@ int af_alg_accept(struct sock *sk, struct socket *newsock)
 	newsock->ops = type->ops;
 	newsock->state = SS_CONNECTED;
 
+	if (nokey)
+		newsock->ops = type->ops_nokey;
+
 	err = 0;
 
 unlock:
* Unmerged path include/crypto/if_alg.h
