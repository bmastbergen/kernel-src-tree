make freeing super_block rcu-delayed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit e2fec7c35582e7bb41cccc1761faa2af4dc17627
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e2fec7c3.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit e2fec7c35582e7bb41cccc1761faa2af4dc17627)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fs.h
diff --cc include/linux/fs.h
index 8dc175024e03,2ab8a67ee054..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -1447,43 -1322,17 +1447,55 @@@ struct super_block 
  	int s_readonly_remount;
  
  	/* AIO completions deferred from interrupt context */
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(struct workqueue_struct *s_dio_done_wq)
++=======
+ 	struct workqueue_struct *s_dio_done_wq;
+ 
+ 	/*
+ 	 * Keep the lru lists last in the structure so they always sit on their
+ 	 * own individual cachelines.
+ 	 */
+ 	struct list_lru		s_dentry_lru ____cacheline_aligned_in_smp;
+ 	struct list_lru		s_inode_lru ____cacheline_aligned_in_smp;
+ 	struct rcu_head		rcu;
++>>>>>>> e2fec7c35582 (make freeing super_block rcu-delayed)
 +};
 +
 +extern const unsigned super_block_wrapper_version;
 +struct super_block_wrapper {
 +	struct super_block sb;
 +
 +	/* -- Wrapper version 0 -- */
 +	/*
 +	 * Indicates how deep in a filesystem stack this SB is
 +	 */
 +	int s_stack_depth;
 +
 +	/* -- Wrapper version 1 -- */
  };
  
 +static inline struct super_block_wrapper *get_sb_wrapper(struct super_block *sb,
 +							 unsigned version)
 +{
 +	/* Make sure we get a link failure if this function is used against an
 +	 * older kernel that doesn't have the superblock wrapper.
 +	 */
 +	if (super_block_wrapper_version < version)
 +		return NULL;
 +	return container_of(sb, struct super_block_wrapper, sb);
 +}
 +
 +static inline int *get_s_stack_depth(struct super_block *sb)
 +{
 +	struct super_block_wrapper *wrapper = get_sb_wrapper(sb, 0);
 +	return wrapper ? &wrapper->s_stack_depth : NULL;
 +}
 +
 +/* superblock cache pruning functions */
 +extern void prune_icache_sb(struct super_block *sb, int nr_to_scan);
 +extern void prune_dcache_sb(struct super_block *sb, int nr_to_scan);
 +
  extern struct timespec current_fs_time(struct super_block *sb);
  
  /*
diff --git a/fs/super.c b/fs/super.c
index 2255fd76fd29..3623389db39d 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -121,7 +121,7 @@ static void destroy_super(struct super_block *s)
 	WARN_ON(!list_empty(&s->s_mounts));
 	kfree(s->s_subtype);
 	kfree(s->s_options);
-	kfree(s);
+	kfree_rcu(s, rcu);
 }
 
 /**
* Unmerged path include/linux/fs.h
