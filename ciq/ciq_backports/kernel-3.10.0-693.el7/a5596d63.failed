crypto: hash - Add crypto_ahash_has_setkey

jira LE-1907
cve CVE-2015-8970
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] hash - Add crypto_ahash_has_setkey ("Bruno E. O. Meneguele") [1386234] {CVE-2015-8970}
Rebuild_FUZZ: 89.47%
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit a5596d6332787fd383b3b5427b41f94254430827
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a5596d63.failed

This patch adds a way for ahash users to determine whether a key
is required by a crypto_ahash transform.

	Cc: stable@vger.kernel.org
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit a5596d6332787fd383b3b5427b41f94254430827)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/crypto/hash.h
diff --cc include/crypto/hash.h
index 74b13ec1ebd4,6361892ea737..000000000000
--- a/include/crypto/hash.h
+++ b/include/crypto/hash.h
@@@ -184,12 -362,78 +185,33 @@@ static inline void *ahash_request_ctx(s
  	return req->__ctx;
  }
  
 -/**
 - * crypto_ahash_setkey - set key for cipher handle
 - * @tfm: cipher handle
 - * @key: buffer holding the key
 - * @keylen: length of the key in bytes
 - *
 - * The caller provided key is set for the ahash cipher. The cipher
 - * handle must point to a keyed hash in order for this function to succeed.
 - *
 - * Return: 0 if the setting of the key was successful; < 0 if an error occurred
 - */
  int crypto_ahash_setkey(struct crypto_ahash *tfm, const u8 *key,
  			unsigned int keylen);
++<<<<<<< HEAD
++=======
+ 
+ static inline bool crypto_ahash_has_setkey(struct crypto_ahash *tfm)
+ {
+ 	return tfm->has_setkey;
+ }
+ 
+ /**
+  * crypto_ahash_finup() - update and finalize message digest
+  * @req: reference to the ahash_request handle that holds all information
+  *	 needed to perform the cipher operation
+  *
+  * This function is a "short-hand" for the function calls of
+  * crypto_ahash_update and crypto_shash_final. The parameters have the same
+  * meaning as discussed for those separate functions.
+  *
+  * Return: 0 if the message digest creation was successful; < 0 if an error
+  *	   occurred
+  */
++>>>>>>> a5596d633278 (crypto: hash - Add crypto_ahash_has_setkey)
  int crypto_ahash_finup(struct ahash_request *req);
 -
 -/**
 - * crypto_ahash_final() - calculate message digest
 - * @req: reference to the ahash_request handle that holds all information
 - *	 needed to perform the cipher operation
 - *
 - * Finalize the message digest operation and create the message digest
 - * based on all data added to the cipher handle. The message digest is placed
 - * into the output buffer registered with the ahash_request handle.
 - *
 - * Return: 0 if the message digest creation was successful; < 0 if an error
 - *	   occurred
 - */
  int crypto_ahash_final(struct ahash_request *req);
 -
 -/**
 - * crypto_ahash_digest() - calculate message digest for a buffer
 - * @req: reference to the ahash_request handle that holds all information
 - *	 needed to perform the cipher operation
 - *
 - * This function is a "short-hand" for the function calls of crypto_ahash_init,
 - * crypto_ahash_update and crypto_ahash_final. The parameters have the same
 - * meaning as discussed for those separate three functions.
 - *
 - * Return: 0 if the message digest creation was successful; < 0 if an error
 - *	   occurred
 - */
  int crypto_ahash_digest(struct ahash_request *req);
  
 -/**
 - * crypto_ahash_export() - extract current message digest state
 - * @req: reference to the ahash_request handle whose state is exported
 - * @out: output buffer of sufficient size that can hold the hash state
 - *
 - * This function exports the hash state of the ahash_request handle into the
 - * caller-allocated output buffer out which must have sufficient size (e.g. by
 - * calling crypto_ahash_reqsize).
 - *
 - * Return: 0 if the export was successful; < 0 if an error occurred
 - */
  static inline int crypto_ahash_export(struct ahash_request *req, void *out)
  {
  	return crypto_ahash_reqtfm(req)->export(req, out);
diff --git a/crypto/ahash.c b/crypto/ahash.c
index b6a7df746f43..8444019853b6 100644
--- a/crypto/ahash.c
+++ b/crypto/ahash.c
@@ -406,6 +406,7 @@ static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)
 	struct ahash_alg *alg = crypto_ahash_alg(hash);
 
 	hash->setkey = ahash_nosetkey;
+	hash->has_setkey = false;
 	hash->export = ahash_no_export;
 	hash->import = ahash_no_import;
 
@@ -418,8 +419,10 @@ static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)
 	hash->finup = alg->finup ?: ahash_def_finup;
 	hash->digest = alg->digest;
 
-	if (alg->setkey)
+	if (alg->setkey) {
 		hash->setkey = alg->setkey;
+		hash->has_setkey = true;
+	}
 	if (alg->export)
 		hash->export = alg->export;
 	if (alg->import)
diff --git a/crypto/shash.c b/crypto/shash.c
index 929058a68561..8e4256aae963 100644
--- a/crypto/shash.c
+++ b/crypto/shash.c
@@ -354,8 +354,10 @@ int crypto_init_shash_ops_async(struct crypto_tfm *tfm)
 	crt->finup = shash_async_finup;
 	crt->digest = shash_async_digest;
 
-	if (alg->setkey)
+	if (alg->setkey) {
 		crt->setkey = shash_async_setkey;
+		crt->has_setkey = true;
+	}
 	if (alg->export)
 		crt->export = shash_async_export;
 	if (alg->import)
* Unmerged path include/crypto/hash.h
