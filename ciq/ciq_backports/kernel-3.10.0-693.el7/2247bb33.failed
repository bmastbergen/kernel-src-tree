mm/hugetlb: fix memory offline with hugepage size > memory block size

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mm] hugetlb: fix memory offline with hugepage size > memory block size (Andrea Arcangeli) [1430172]
Rebuild_FUZZ: 97.78%
commit-author Gerald Schaefer <gerald.schaefer@de.ibm.com>
commit 2247bb335ab9c40058484cac36ea74ee652f3b7b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2247bb33.failed

Patch series "mm/hugetlb: memory offline issues with hugepages", v4.

This addresses several issues with hugepages and memory offline.  While
the first patch fixes a panic, and is therefore rather important, the
last patch is just a performance optimization.

The second patch fixes a theoretical issue with reserved hugepages,
while still leaving some ugly usability issue, see description.

This patch (of 3):

dissolve_free_huge_pages() will either run into the VM_BUG_ON() or a
list corruption and addressing exception when trying to set a memory
block offline that is part (but not the first part) of a "gigantic"
hugetlb page with a size > memory block size.

When no other smaller hugetlb page sizes are present, the VM_BUG_ON()
will trigger directly.  In the other case we will run into an addressing
exception later, because dissolve_free_huge_page() will not work on the
head page of the compound hugetlb page which will result in a NULL
hstate from page_hstate().

To fix this, first remove the VM_BUG_ON() because it is wrong, and then
use the compound head page in dissolve_free_huge_page().  This means
that an unused pre-allocated gigantic page that has any part of itself
inside the memory block that is going offline will be dissolved
completely.  Losing an unused gigantic hugepage is preferable to failing
the memory offline, for example in the situation where a (possibly
faulty) memory DIMM needs to go offline.

Fixes: c8721bbb ("mm: memory-hotplug: enable memory hotplug to handle hugepage")
Link: http://lkml.kernel.org/r/20160926172811.94033-2-gerald.schaefer@de.ibm.com
	Signed-off-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Acked-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: "Kirill A . Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: "Aneesh Kumar K . V" <aneesh.kumar@linux.vnet.ibm.com>
	Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: Rui Teng <rui.teng@linux.vnet.ibm.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 2247bb335ab9c40058484cac36ea74ee652f3b7b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/hugetlb.c
diff --cc mm/hugetlb.c
index 2c12fc3891a9,603bdd01ec2c..000000000000
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@@ -1189,16 -1463,12 +1191,23 @@@ static void dissolve_free_huge_page(str
   */
  void dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)
  {
 +	unsigned int order = 8 * sizeof(void *);
  	unsigned long pfn;
 +	struct hstate *h;
  
++<<<<<<< HEAD
 +	/* Set scan step to minimum hugepage size */
 +	for_each_hstate(h)
 +		if (order > huge_page_order(h))
 +			order = huge_page_order(h);
 +	VM_BUG_ON(!IS_ALIGNED(start_pfn, 1 << order));
 +	for (pfn = start_pfn; pfn < end_pfn; pfn += 1 << order)
++=======
+ 	if (!hugepages_supported())
+ 		return;
+ 
+ 	for (pfn = start_pfn; pfn < end_pfn; pfn += 1 << minimum_order)
++>>>>>>> 2247bb335ab9 (mm/hugetlb: fix memory offline with hugepage size > memory block size)
  		dissolve_free_huge_page(pfn_to_page(pfn));
  }
  
* Unmerged path mm/hugetlb.c
