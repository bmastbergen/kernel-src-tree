gre: fix error handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric Dumazet <edumazet@google.com>
commit e582615ad33dbd39623084a02e95567b116e1eea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e582615a.failed

1) gre_parse_header() can be called from gre_err()

   At this point transport header points to ICMP header, not the inner
header.

2) We can not really change transport header as ipgre_err() will later
assume transport header still points to ICMP header (using icmp_hdr())

3) pskb_may_pull() logic in gre_parse_header() really works
  if we are interested at zone pointed by skb->data

4) As Jiri explained in commit b7f8fe251e46 ("gre: do not pull header in
ICMP error processing") we should not pull headers in error handler.

So this fix :

A) changes gre_parse_header() to use skb->data instead of
skb_transport_header()

B) Adds a nhs parameter to gre_parse_header() so that we can skip the
not pulled IP header from error path.
  This offset is 0 for normal receive path.

C) remove obsolete IPV6 includes

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Tom Herbert <tom@herbertland.com>
	Cc: Maciej Å»enczykowski <maze@google.com>
	Cc: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e582615ad33dbd39623084a02e95567b116e1eea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/gre.h
#	net/ipv4/gre_demux.c
#	net/ipv4/ip_gre.c
#	net/ipv6/ip6_gre.c
diff --cc include/net/gre.h
index 898513e436c5,7a54a31d1d4c..000000000000
--- a/include/net/gre.h
+++ b/include/net/gre.h
@@@ -23,5 -23,110 +23,114 @@@ struct gre_protocol 
  int gre_add_protocol(const struct gre_protocol *proto, u8 version);
  int gre_del_protocol(const struct gre_protocol *proto, u8 version);
  
++<<<<<<< HEAD
 +struct net_device *gretap_fb_dev_create(struct net *net, const char *name);
++=======
+ struct net_device *gretap_fb_dev_create(struct net *net, const char *name,
+ 				       u8 name_assign_type);
+ int gre_parse_header(struct sk_buff *skb, struct tnl_ptk_info *tpi,
+ 		     bool *csum_err, __be16 proto, int nhs);
+ 
+ static inline int gre_calc_hlen(__be16 o_flags)
+ {
+ 	int addend = 4;
+ 
+ 	if (o_flags & TUNNEL_CSUM)
+ 		addend += 4;
+ 	if (o_flags & TUNNEL_KEY)
+ 		addend += 4;
+ 	if (o_flags & TUNNEL_SEQ)
+ 		addend += 4;
+ 	return addend;
+ }
+ 
+ static inline __be16 gre_flags_to_tnl_flags(__be16 flags)
+ {
+ 	__be16 tflags = 0;
+ 
+ 	if (flags & GRE_CSUM)
+ 		tflags |= TUNNEL_CSUM;
+ 	if (flags & GRE_ROUTING)
+ 		tflags |= TUNNEL_ROUTING;
+ 	if (flags & GRE_KEY)
+ 		tflags |= TUNNEL_KEY;
+ 	if (flags & GRE_SEQ)
+ 		tflags |= TUNNEL_SEQ;
+ 	if (flags & GRE_STRICT)
+ 		tflags |= TUNNEL_STRICT;
+ 	if (flags & GRE_REC)
+ 		tflags |= TUNNEL_REC;
+ 	if (flags & GRE_VERSION)
+ 		tflags |= TUNNEL_VERSION;
+ 
+ 	return tflags;
+ }
+ 
+ static inline __be16 gre_tnl_flags_to_gre_flags(__be16 tflags)
+ {
+ 	__be16 flags = 0;
+ 
+ 	if (tflags & TUNNEL_CSUM)
+ 		flags |= GRE_CSUM;
+ 	if (tflags & TUNNEL_ROUTING)
+ 		flags |= GRE_ROUTING;
+ 	if (tflags & TUNNEL_KEY)
+ 		flags |= GRE_KEY;
+ 	if (tflags & TUNNEL_SEQ)
+ 		flags |= GRE_SEQ;
+ 	if (tflags & TUNNEL_STRICT)
+ 		flags |= GRE_STRICT;
+ 	if (tflags & TUNNEL_REC)
+ 		flags |= GRE_REC;
+ 	if (tflags & TUNNEL_VERSION)
+ 		flags |= GRE_VERSION;
+ 
+ 	return flags;
+ }
+ 
+ static inline __sum16 gre_checksum(struct sk_buff *skb)
+ {
+ 	__wsum csum;
+ 
+ 	if (skb->ip_summed == CHECKSUM_PARTIAL)
+ 		csum = lco_csum(skb);
+ 	else
+ 		csum = skb_checksum(skb, 0, skb->len, 0);
+ 	return csum_fold(csum);
+ }
+ 
+ static inline void gre_build_header(struct sk_buff *skb, int hdr_len,
+ 				    __be16 flags, __be16 proto,
+ 				    __be32 key, __be32 seq)
+ {
+ 	struct gre_base_hdr *greh;
+ 
+ 	skb_push(skb, hdr_len);
+ 
+ 	skb_reset_transport_header(skb);
+ 	greh = (struct gre_base_hdr *)skb->data;
+ 	greh->flags = gre_tnl_flags_to_gre_flags(flags);
+ 	greh->protocol = proto;
+ 
+ 	if (flags & (TUNNEL_KEY | TUNNEL_CSUM | TUNNEL_SEQ)) {
+ 		__be32 *ptr = (__be32 *)(((u8 *)greh) + hdr_len - 4);
+ 
+ 		if (flags & TUNNEL_SEQ) {
+ 			*ptr = seq;
+ 			ptr--;
+ 		}
+ 		if (flags & TUNNEL_KEY) {
+ 			*ptr = key;
+ 			ptr--;
+ 		}
+ 		if (flags & TUNNEL_CSUM &&
+ 		    !(skb_shinfo(skb)->gso_type &
+ 		      (SKB_GSO_GRE | SKB_GSO_GRE_CSUM))) {
+ 			*ptr = 0;
+ 			*(__sum16 *)ptr = gre_checksum(skb);
+ 		}
+ 	}
+ }
+ 
++>>>>>>> e582615ad33d (gre: fix error handler)
  #endif
diff --cc net/ipv4/gre_demux.c
index d9c552a721fc,de1d119a4497..000000000000
--- a/net/ipv4/gre_demux.c
+++ b/net/ipv4/gre_demux.c
@@@ -60,6 -60,67 +60,70 @@@ int gre_del_protocol(const struct gre_p
  }
  EXPORT_SYMBOL_GPL(gre_del_protocol);
  
++<<<<<<< HEAD
++=======
+ /* Fills in tpi and returns header length to be pulled. */
+ int gre_parse_header(struct sk_buff *skb, struct tnl_ptk_info *tpi,
+ 		     bool *csum_err, __be16 proto, int nhs)
+ {
+ 	const struct gre_base_hdr *greh;
+ 	__be32 *options;
+ 	int hdr_len;
+ 
+ 	if (unlikely(!pskb_may_pull(skb, nhs + sizeof(struct gre_base_hdr))))
+ 		return -EINVAL;
+ 
+ 	greh = (struct gre_base_hdr *)(skb->data + nhs);
+ 	if (unlikely(greh->flags & (GRE_VERSION | GRE_ROUTING)))
+ 		return -EINVAL;
+ 
+ 	tpi->flags = gre_flags_to_tnl_flags(greh->flags);
+ 	hdr_len = gre_calc_hlen(tpi->flags);
+ 
+ 	if (!pskb_may_pull(skb, nhs + hdr_len))
+ 		return -EINVAL;
+ 
+ 	greh = (struct gre_base_hdr *)(skb->data + nhs);
+ 	tpi->proto = greh->protocol;
+ 
+ 	options = (__be32 *)(greh + 1);
+ 	if (greh->flags & GRE_CSUM) {
+ 		if (skb_checksum_simple_validate(skb)) {
+ 			*csum_err = true;
+ 			return -EINVAL;
+ 		}
+ 
+ 		skb_checksum_try_convert(skb, IPPROTO_GRE, 0,
+ 					 null_compute_pseudo);
+ 		options++;
+ 	}
+ 
+ 	if (greh->flags & GRE_KEY) {
+ 		tpi->key = *options;
+ 		options++;
+ 	} else {
+ 		tpi->key = 0;
+ 	}
+ 	if (unlikely(greh->flags & GRE_SEQ)) {
+ 		tpi->seq = *options;
+ 		options++;
+ 	} else {
+ 		tpi->seq = 0;
+ 	}
+ 	/* WCCP version 1 and 2 protocol decoding.
+ 	 * - Change protocol to IPv4/IPv6
+ 	 * - When dealing with WCCPv2, Skip extra 4 bytes in GRE header
+ 	 */
+ 	if (greh->flags == 0 && tpi->proto == htons(ETH_P_WCCP)) {
+ 		tpi->proto = proto;
+ 		if ((*(u8 *)options & 0xF0) != 0x40)
+ 			hdr_len += 4;
+ 	}
+ 	return hdr_len;
+ }
+ EXPORT_SYMBOL(gre_parse_header);
+ 
++>>>>>>> e582615ad33d (gre: fix error handler)
  static int gre_rcv(struct sk_buff *skb)
  {
  	const struct gre_protocol *proto;
diff --cc net/ipv4/ip_gre.c
index 9c178e45801f,1d000af7f561..000000000000
--- a/net/ipv4/ip_gre.c
+++ b/net/ipv4/ip_gre.c
@@@ -342,7 -217,8 +337,12 @@@ static void gre_err(struct sk_buff *skb
  	struct tnl_ptk_info tpi;
  	bool csum_err = false;
  
++<<<<<<< HEAD
 +	if (parse_gre_header(skb, &tpi, &csum_err)) {
++=======
+ 	if (gre_parse_header(skb, &tpi, &csum_err, htons(ETH_P_IP),
+ 			     iph->ihl * 4) < 0) {
++>>>>>>> e582615ad33d (gre: fix error handler)
  		if (!csum_err)		/* ignore csum errors. */
  			return;
  	}
@@@ -432,10 -334,11 +432,15 @@@ static int gre_rcv(struct sk_buff *skb
  	}
  #endif
  
++<<<<<<< HEAD
 +	if (parse_gre_header(skb, &tpi, &csum_err) < 0)
++=======
+ 	hdr_len = gre_parse_header(skb, &tpi, &csum_err, htons(ETH_P_IP), 0);
+ 	if (hdr_len < 0)
++>>>>>>> e582615ad33d (gre: fix error handler)
  		goto drop;
  
 -	if (ipgre_rcv(skb, &tpi, hdr_len) == PACKET_RCVD)
 +	if (ipgre_rcv(skb, &tpi) == PACKET_RCVD)
  		return 0;
  
  	icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);
diff --cc net/ipv6/ip6_gre.c
index 7af2a5d5ad35,776d145113e1..000000000000
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@@ -468,7 -468,8 +468,12 @@@ static int gre_rcv(struct sk_buff *skb
  	bool csum_err = false;
  	int hdr_len;
  
++<<<<<<< HEAD
 +	if (gre_parse_header(skb, &tpi, &csum_err, &hdr_len) < 0)
++=======
+ 	hdr_len = gre_parse_header(skb, &tpi, &csum_err, htons(ETH_P_IPV6), 0);
+ 	if (hdr_len < 0)
++>>>>>>> e582615ad33d (gre: fix error handler)
  		goto drop;
  
  	if (iptunnel_pull_header(skb, hdr_len, tpi.proto, false))
* Unmerged path include/net/gre.h
* Unmerged path net/ipv4/gre_demux.c
* Unmerged path net/ipv4/ip_gre.c
* Unmerged path net/ipv6/ip6_gre.c
