HID: wacom: EKR: have one power_supply per remote

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: ekr: have one power_supply per remote (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 94.62%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 59d69bc8215478af6b89d4ae9ab0baf6d91eb870
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/59d69bc8.failed

Previously, all the remotes attached to the same receiver would share the
same power_supply. That's not good as the remotes will constantly change
the battery information according to their own state.

To have something generic enough, we introduce struct wacom_battery
which regroups all the information we need for a battery.

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 59d69bc8215478af6b89d4ae9ab0baf6d91eb870)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom.h
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom.h
index 87d2c48e3adc,768d69602e7a..000000000000
--- a/drivers/hid/wacom.h
+++ b/drivers/hid/wacom.h
@@@ -109,36 -106,94 +109,80 @@@ MODULE_LICENSE(DRIVER_LICENSE)
  #define USB_VENDOR_ID_WACOM	0x056a
  #define USB_VENDOR_ID_LENOVO	0x17ef
  
++<<<<<<< HEAD
++=======
+ enum wacom_worker {
+ 	WACOM_WORKER_WIRELESS,
+ 	WACOM_WORKER_BATTERY,
+ 	WACOM_WORKER_REMOTE,
+ };
+ 
+ struct wacom_group_leds {
+ 	u8 select; /* status led selector (0..3) */
+ };
+ 
+ struct wacom_battery {
+ 	struct power_supply_desc bat_desc;
+ 	struct power_supply_desc ac_desc;
+ 	struct power_supply *battery;
+ 	struct power_supply *ac;
+ 	char bat_name[WACOM_NAME_MAX];
+ 	char ac_name[WACOM_NAME_MAX];
+ 	int battery_capacity;
+ 	int bat_charging;
+ 	int bat_connected;
+ 	int ps_connected;
+ };
+ 
+ struct wacom_remote {
+ 	spinlock_t remote_lock;
+ 	struct kfifo remote_fifo;
+ 	struct kobject *remote_dir;
+ 	struct {
+ 		struct attribute_group group;
+ 		u32 serial;
+ 		struct input_dev *input;
+ 		bool registered;
+ 		struct wacom_battery battery;
+ 	} remotes[WACOM_MAX_REMOTES];
+ };
+ 
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
  struct wacom {
 +	dma_addr_t data_dma;
  	struct usb_device *usbdev;
  	struct usb_interface *intf;
 +	struct urb *irq;
  	struct wacom_wac wacom_wac;
 -	struct hid_device *hdev;
  	struct mutex lock;
 -	struct work_struct wireless_work;
 -	struct work_struct battery_work;
 -	struct work_struct remote_work;
 -	struct wacom_remote *remote;
 -	struct wacom_leds {
 -		struct wacom_group_leds *groups;
 +	struct work_struct work;
 +	bool open;
 +	char phys[32];
 +	struct wacom_led {
 +		u8 select[2]; /* status led selector (0..3) */
  		u8 llv;       /* status led brightness no button (1..127) */
  		u8 hlv;       /* status led brightness button pressed (1..127) */
  		u8 img_lum;   /* OLED matrix display brightness */
  	} led;
++<<<<<<< HEAD
 +	bool led_initialized;
 +	struct power_supply battery;
++=======
+ 	struct wacom_battery battery;
+ 	bool resources;
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
  };
  
 -static inline void wacom_schedule_work(struct wacom_wac *wacom_wac,
 -				       enum wacom_worker which)
 +static inline void wacom_schedule_work(struct wacom_wac *wacom_wac)
  {
  	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
 -
 -	switch (which) {
 -	case WACOM_WORKER_WIRELESS:
 -		schedule_work(&wacom->wireless_work);
 -		break;
 -	case WACOM_WORKER_BATTERY:
 -		schedule_work(&wacom->battery_work);
 -		break;
 -	case WACOM_WORKER_REMOTE:
 -		schedule_work(&wacom->remote_work);
 -		break;
 -	}
 +	schedule_work(&wacom->work);
  }
  
 -extern const struct hid_device_id wacom_ids[];
 +extern const struct usb_device_id wacom_ids[];
  
  void wacom_wac_irq(struct wacom_wac *wacom_wac, size_t len);
 -void wacom_setup_device_quirks(struct wacom *wacom);
 -int wacom_setup_pen_input_capabilities(struct input_dev *input_dev,
 -				   struct wacom_wac *wacom_wac);
 -int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
 +void wacom_setup_device_quirks(struct wacom_features *features);
 +int wacom_setup_input_capabilities(struct input_dev *input_dev,
  				   struct wacom_wac *wacom_wac);
 -int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
 -				       struct wacom_wac *wacom_wac);
 -void wacom_wac_usage_mapping(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage);
 -int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
 -		struct hid_usage *usage, __s32 value);
 -void wacom_wac_report(struct hid_device *hdev, struct hid_report *report);
 -void wacom_battery_work(struct work_struct *work);
  #endif
diff --cc drivers/hid/wacom_sys.c
index e75b5002a526,04f5c753c868..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1079,13 -1101,29 +1079,39 @@@ static int wacom_battery_get_property(s
  				      enum power_supply_property psp,
  				      union power_supply_propval *val)
  {
++<<<<<<< HEAD
 +	struct wacom *wacom = container_of(psy, struct wacom, battery);
 +	int ret = 0;
 +
 +	switch (psp) {
 +		case POWER_SUPPLY_PROP_CAPACITY:
 +			val->intval =
 +				wacom->wacom_wac.battery_capacity * 100 / 31;
++=======
+ 	struct wacom_battery *battery = power_supply_get_drvdata(psy);
+ 	int ret = 0;
+ 
+ 	switch (psp) {
+ 		case POWER_SUPPLY_PROP_PRESENT:
+ 			val->intval = battery->bat_connected;
+ 			break;
+ 		case POWER_SUPPLY_PROP_SCOPE:
+ 			val->intval = POWER_SUPPLY_SCOPE_DEVICE;
+ 			break;
+ 		case POWER_SUPPLY_PROP_CAPACITY:
+ 			val->intval = battery->battery_capacity;
+ 			break;
+ 		case POWER_SUPPLY_PROP_STATUS:
+ 			if (battery->bat_charging)
+ 				val->intval = POWER_SUPPLY_STATUS_CHARGING;
+ 			else if (battery->battery_capacity == 100 &&
+ 				    battery->ps_connected)
+ 				val->intval = POWER_SUPPLY_STATUS_FULL;
+ 			else if (battery->ps_connected)
+ 				val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+ 			else
+ 				val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
  			break;
  		default:
  			ret = -EINVAL;
@@@ -1095,35 -1133,103 +1121,132 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int wacom_initialize_battery(struct wacom *wacom)
 +{
 +	int error = 0;
++=======
+ static int wacom_ac_get_property(struct power_supply *psy,
+ 				enum power_supply_property psp,
+ 				union power_supply_propval *val)
+ {
+ 	struct wacom_battery *battery = power_supply_get_drvdata(psy);
+ 	int ret = 0;
+ 
+ 	switch (psp) {
+ 	case POWER_SUPPLY_PROP_PRESENT:
+ 		/* fall through */
+ 	case POWER_SUPPLY_PROP_ONLINE:
+ 		val->intval = battery->ps_connected;
+ 		break;
+ 	case POWER_SUPPLY_PROP_SCOPE:
+ 		val->intval = POWER_SUPPLY_SCOPE_DEVICE;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 	return ret;
+ }
+ 
+ static int __wacom_initialize_battery(struct wacom *wacom,
+ 				      struct wacom_battery *battery)
+ {
+ 	static atomic_t battery_no = ATOMIC_INIT(0);
+ 	struct device *dev = &wacom->hdev->dev;
+ 	struct power_supply_config psy_cfg = { .drv_data = battery, };
+ 	struct power_supply *ps_bat, *ps_ac;
+ 	struct power_supply_desc *bat_desc = &battery->bat_desc;
+ 	struct power_supply_desc *ac_desc = &battery->ac_desc;
+ 	unsigned long n;
+ 	int error;
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
 +
 +	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_MONITOR) {
 +		wacom->battery.properties = wacom_battery_props;
 +		wacom->battery.num_properties = ARRAY_SIZE(wacom_battery_props);
 +		wacom->battery.get_property = wacom_battery_get_property;
 +		wacom->battery.name = "wacom_battery";
 +		wacom->battery.type = POWER_SUPPLY_TYPE_BATTERY;
 +		wacom->battery.use_for_apm = 0;
 +
++<<<<<<< HEAD
 +		error = power_supply_register(&wacom->usbdev->dev,
 +					      &wacom->battery);
 +
 +		if (!error)
 +			power_supply_powers(&wacom->battery,
 +					    &wacom->usbdev->dev);
 +	}
  
 -	if (!devres_open_group(dev, bat_desc, GFP_KERNEL))
 -		return -ENOMEM;
 -
++=======
+ 	n = atomic_inc_return(&battery_no) - 1;
+ 
+ 	bat_desc->properties = wacom_battery_props;
+ 	bat_desc->num_properties = ARRAY_SIZE(wacom_battery_props);
+ 	bat_desc->get_property = wacom_battery_get_property;
+ 	sprintf(battery->bat_name, "wacom_battery_%ld", n);
+ 	bat_desc->name = battery->bat_name;
+ 	bat_desc->type = POWER_SUPPLY_TYPE_BATTERY;
+ 	bat_desc->use_for_apm = 0;
+ 
+ 	ac_desc->properties = wacom_ac_props;
+ 	ac_desc->num_properties = ARRAY_SIZE(wacom_ac_props);
+ 	ac_desc->get_property = wacom_ac_get_property;
+ 	sprintf(battery->ac_name, "wacom_ac_%ld", n);
+ 	ac_desc->name = battery->ac_name;
+ 	ac_desc->type = POWER_SUPPLY_TYPE_MAINS;
+ 	ac_desc->use_for_apm = 0;
+ 
+ 	ps_bat = devm_power_supply_register(dev, bat_desc, &psy_cfg);
+ 	if (IS_ERR(ps_bat)) {
+ 		error = PTR_ERR(ps_bat);
+ 		goto err;
+ 	}
+ 
+ 	ps_ac = devm_power_supply_register(dev, ac_desc, &psy_cfg);
+ 	if (IS_ERR(ps_ac)) {
+ 		error = PTR_ERR(ps_ac);
+ 		goto err;
+ 	}
+ 
+ 	power_supply_powers(ps_bat, &wacom->hdev->dev);
+ 	power_supply_powers(ps_ac, &wacom->hdev->dev);
+ 
+ 	battery->battery = ps_bat;
+ 	battery->ac = ps_ac;
+ 
+ 	devres_close_group(dev, bat_desc);
+ 	return 0;
+ 
+ err:
+ 	devres_release_group(dev, bat_desc);
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
  	return error;
  }
  
+ static int wacom_initialize_battery(struct wacom *wacom)
+ {
+ 	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY)
+ 		return __wacom_initialize_battery(wacom, &wacom->battery);
+ 
+ 	return 0;
+ }
+ 
  static void wacom_destroy_battery(struct wacom *wacom)
  {
++<<<<<<< HEAD
 +	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_MONITOR &&
 +	    wacom->battery.dev) {
 +		power_supply_unregister(&wacom->battery);
 +		wacom->battery.dev = NULL;
++=======
+ 	if (wacom->battery.battery) {
+ 		devres_release_group(&wacom->hdev->dev,
+ 				     &wacom->battery.bat_desc);
+ 		wacom->battery.battery = NULL;
+ 		wacom->battery.ac = NULL;
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
  	}
  }
  
@@@ -1293,10 -1594,459 +1416,463 @@@ static void wacom_calculate_res(struct 
  						    features->unitExpo);
  }
  
 -void wacom_battery_work(struct work_struct *work)
 +static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *id)
  {
++<<<<<<< HEAD
++=======
+ 	struct wacom *wacom = container_of(work, struct wacom, battery_work);
+ 
+ 	if ((wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 	     !wacom->battery.battery) {
+ 		wacom_initialize_battery(wacom);
+ 	}
+ 	else if (!(wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 		 wacom->battery.battery) {
+ 		wacom_destroy_battery(wacom);
+ 	}
+ }
+ 
+ static size_t wacom_compute_pktlen(struct hid_device *hdev)
+ {
+ 	struct hid_report_enum *report_enum;
+ 	struct hid_report *report;
+ 	size_t size = 0;
+ 
+ 	report_enum = hdev->report_enum + HID_INPUT_REPORT;
+ 
+ 	list_for_each_entry(report, &report_enum->report_list, list) {
+ 		size_t report_size = hid_report_len(report);
+ 		if (report_size > size)
+ 			size = report_size;
+ 	}
+ 
+ 	return size;
+ }
+ 
+ static void wacom_update_name(struct wacom *wacom, const char *suffix)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	char name[WACOM_NAME_MAX];
+ 
+ 	/* Generic devices name unspecified */
+ 	if ((features->type == HID_GENERIC) && !strcmp("Wacom HID", features->name)) {
+ 		if (strstr(wacom->hdev->name, "Wacom") ||
+ 		    strstr(wacom->hdev->name, "wacom") ||
+ 		    strstr(wacom->hdev->name, "WACOM")) {
+ 			/* name is in HID descriptor, use it */
+ 			strlcpy(name, wacom->hdev->name, sizeof(name));
+ 
+ 			/* strip out excess whitespaces */
+ 			while (1) {
+ 				char *gap = strstr(name, "  ");
+ 				if (gap == NULL)
+ 					break;
+ 				/* shift everything including the terminator */
+ 				memmove(gap, gap+1, strlen(gap));
+ 			}
+ 			/* get rid of trailing whitespace */
+ 			if (name[strlen(name)-1] == ' ')
+ 				name[strlen(name)-1] = '\0';
+ 		} else {
+ 			/* no meaningful name retrieved. use product ID */
+ 			snprintf(name, sizeof(name),
+ 				 "%s %X", features->name, wacom->hdev->product);
+ 		}
+ 	} else {
+ 		strlcpy(name, features->name, sizeof(name));
+ 	}
+ 
+ 	/* Append the device type to the name */
+ 	snprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),
+ 		"%s%s Pen", name, suffix);
+ 	snprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),
+ 		"%s%s Finger", name, suffix);
+ 	snprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),
+ 		"%s%s Pad", name, suffix);
+ }
+ 
+ static void wacom_release_resources(struct wacom *wacom)
+ {
+ 	struct hid_device *hdev = wacom->hdev;
+ 
+ 	if (!wacom->resources)
+ 		return;
+ 
+ 	devres_release_group(&hdev->dev, wacom);
+ 
+ 	wacom->resources = false;
+ 
+ 	wacom->wacom_wac.pen_input = NULL;
+ 	wacom->wacom_wac.touch_input = NULL;
+ 	wacom->wacom_wac.pad_input = NULL;
+ }
+ 
+ static int wacom_parse_and_register(struct wacom *wacom, bool wireless)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	struct hid_device *hdev = wacom->hdev;
+ 	int error;
+ 	unsigned int connect_mask = HID_CONNECT_HIDRAW;
+ 
+ 	features->pktlen = wacom_compute_pktlen(hdev);
+ 	if (features->pktlen > WACOM_PKGLEN_MAX)
+ 		return -EINVAL;
+ 
+ 	if (!devres_open_group(&hdev->dev, wacom, GFP_KERNEL))
+ 		return -ENOMEM;
+ 
+ 	wacom->resources = true;
+ 
+ 	error = wacom_allocate_inputs(wacom);
+ 	if (error)
+ 		goto fail;
+ 
+ 	/*
+ 	 * Bamboo Pad has a generic hid handling for the Pen, and we switch it
+ 	 * into debug mode for the touch part.
+ 	 * We ignore the other interfaces.
+ 	 */
+ 	if (features->type == BAMBOO_PAD) {
+ 		if (features->pktlen == WACOM_PKGLEN_PENABLED) {
+ 			features->type = HID_GENERIC;
+ 		} else if ((features->pktlen != WACOM_PKGLEN_BPAD_TOUCH) &&
+ 			   (features->pktlen != WACOM_PKGLEN_BPAD_TOUCH_USB)) {
+ 			error = -ENODEV;
+ 			goto fail;
+ 		}
+ 	}
+ 
+ 	/* set the default size in case we do not get them from hid */
+ 	wacom_set_default_phy(features);
+ 
+ 	/* Retrieve the physical and logical size for touch devices */
+ 	wacom_retrieve_hid_descriptor(hdev, features);
+ 	wacom_setup_device_quirks(wacom);
+ 
+ 	if (features->device_type == WACOM_DEVICETYPE_NONE &&
+ 	    features->type != WIRELESS) {
+ 		error = features->type == HID_GENERIC ? -ENODEV : 0;
+ 
+ 		dev_warn(&hdev->dev, "Unknown device_type for '%s'. %s.",
+ 			 hdev->name,
+ 			 error ? "Ignoring" : "Assuming pen");
+ 
+ 		if (error)
+ 			goto fail;
+ 
+ 		features->device_type |= WACOM_DEVICETYPE_PEN;
+ 	}
+ 
+ 	wacom_calculate_res(features);
+ 
+ 	wacom_update_name(wacom, wireless ? " (WL)" : "");
+ 
+ 	error = wacom_add_shared_data(hdev);
+ 	if (error)
+ 		goto fail;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_WL_MONITOR) &&
+ 	     (features->quirks & WACOM_QUIRK_BATTERY)) {
+ 		error = wacom_initialize_battery(wacom);
+ 		if (error)
+ 			goto fail;
+ 	}
+ 
+ 	error = wacom_register_inputs(wacom);
+ 	if (error)
+ 		goto fail;
+ 
+ 	if (wacom->wacom_wac.features.device_type & WACOM_DEVICETYPE_PAD) {
+ 		error = wacom_initialize_leds(wacom);
+ 		if (error)
+ 			goto fail;
+ 
+ 		error = wacom_initialize_remotes(wacom);
+ 		if (error)
+ 			goto fail;
+ 	}
+ 
+ 	if (features->type == HID_GENERIC)
+ 		connect_mask |= HID_CONNECT_DRIVER;
+ 
+ 	/* Regular HID work starts now */
+ 	error = hid_hw_start(hdev, connect_mask);
+ 	if (error) {
+ 		hid_err(hdev, "hw start failed\n");
+ 		goto fail;
+ 	}
+ 
+ 	if (!wireless) {
+ 		/* Note that if query fails it is not a hard failure */
+ 		wacom_query_tablet_data(hdev, features);
+ 	}
+ 
+ 	/* touch only Bamboo doesn't support pen */
+ 	if ((features->type == BAMBOO_TOUCH) &&
+ 	    (features->device_type & WACOM_DEVICETYPE_PEN)) {
+ 		error = -ENODEV;
+ 		goto fail_quirks;
+ 	}
+ 
+ 	/* pen only Bamboo neither support touch nor pad */
+ 	if ((features->type == BAMBOO_PEN) &&
+ 	    ((features->device_type & WACOM_DEVICETYPE_TOUCH) ||
+ 	    (features->device_type & WACOM_DEVICETYPE_PAD))) {
+ 		error = -ENODEV;
+ 		goto fail_quirks;
+ 	}
+ 
+ 	if (features->device_type & WACOM_DEVICETYPE_WL_MONITOR)
+ 		error = hid_hw_open(hdev);
+ 
+ 	if ((wacom_wac->features.type == INTUOSHT ||
+ 	     wacom_wac->features.type == INTUOSHT2) &&
+ 	    (wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH)) {
+ 		wacom_wac->shared->type = wacom_wac->features.type;
+ 		wacom_wac->shared->touch_input = wacom_wac->touch_input;
+ 	}
+ 
+ 	devres_close_group(&hdev->dev, wacom);
+ 
+ 	return 0;
+ 
+ fail_quirks:
+ 	hid_hw_stop(hdev);
+ fail:
+ 	wacom_release_resources(wacom);
+ 	return error;
+ }
+ 
+ static void wacom_wireless_work(struct work_struct *work)
+ {
+ 	struct wacom *wacom = container_of(work, struct wacom, wireless_work);
+ 	struct usb_device *usbdev = wacom->usbdev;
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_device *hdev1, *hdev2;
+ 	struct wacom *wacom1, *wacom2;
+ 	struct wacom_wac *wacom_wac1, *wacom_wac2;
+ 	int error;
+ 
+ 	/*
+ 	 * Regardless if this is a disconnect or a new tablet,
+ 	 * remove any existing input and battery devices.
+ 	 */
+ 
+ 	wacom_destroy_battery(wacom);
+ 
+ 	/* Stylus interface */
+ 	hdev1 = usb_get_intfdata(usbdev->config->interface[1]);
+ 	wacom1 = hid_get_drvdata(hdev1);
+ 	wacom_wac1 = &(wacom1->wacom_wac);
+ 	wacom_release_resources(wacom1);
+ 
+ 	/* Touch interface */
+ 	hdev2 = usb_get_intfdata(usbdev->config->interface[2]);
+ 	wacom2 = hid_get_drvdata(hdev2);
+ 	wacom_wac2 = &(wacom2->wacom_wac);
+ 	wacom_release_resources(wacom2);
+ 
+ 	if (wacom_wac->pid == 0) {
+ 		hid_info(wacom->hdev, "wireless tablet disconnected\n");
+ 	} else {
+ 		const struct hid_device_id *id = wacom_ids;
+ 
+ 		hid_info(wacom->hdev, "wireless tablet connected with PID %x\n",
+ 			 wacom_wac->pid);
+ 
+ 		while (id->bus) {
+ 			if (id->vendor == USB_VENDOR_ID_WACOM &&
+ 			    id->product == wacom_wac->pid)
+ 				break;
+ 			id++;
+ 		}
+ 
+ 		if (!id->bus) {
+ 			hid_info(wacom->hdev, "ignoring unknown PID.\n");
+ 			return;
+ 		}
+ 
+ 		/* Stylus interface */
+ 		wacom_wac1->features =
+ 			*((struct wacom_features *)id->driver_data);
+ 
+ 		wacom_wac1->pid = wacom_wac->pid;
+ 		hid_hw_stop(hdev1);
+ 		error = wacom_parse_and_register(wacom1, true);
+ 		if (error)
+ 			goto fail;
+ 
+ 		/* Touch interface */
+ 		if (wacom_wac1->features.touch_max ||
+ 		    (wacom_wac1->features.type >= INTUOSHT &&
+ 		    wacom_wac1->features.type <= BAMBOO_PT)) {
+ 			wacom_wac2->features =
+ 				*((struct wacom_features *)id->driver_data);
+ 			wacom_wac2->pid = wacom_wac->pid;
+ 			hid_hw_stop(hdev2);
+ 			error = wacom_parse_and_register(wacom2, true);
+ 			if (error)
+ 				goto fail;
+ 		}
+ 
+ 		error = wacom_initialize_battery(wacom);
+ 		if (error)
+ 			goto fail;
+ 	}
+ 
+ 	return;
+ 
+ fail:
+ 	wacom_release_resources(wacom1);
+ 	wacom_release_resources(wacom2);
+ 	return;
+ }
+ 
+ static void wacom_remote_destroy_one(struct wacom *wacom, unsigned int index)
+ {
+ 	struct wacom_remote *remote = wacom->remote;
+ 	u32 serial = remote->remotes[index].serial;
+ 	int i;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&remote->remote_lock, flags);
+ 	remote->remotes[index].registered = false;
+ 	spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 
+ 	if (remote->remotes[index].group.name)
+ 		devres_release_group(&wacom->hdev->dev,
+ 				     &remote->remotes[index]);
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		if (remote->remotes[i].serial == serial) {
+ 			remote->remotes[i].serial = 0;
+ 			remote->remotes[i].group.name = NULL;
+ 			remote->remotes[i].registered = false;
+ 			wacom->led.groups[i].select = WACOM_STATUS_UNKNOWN;
+ 		}
+ 	}
+ }
+ 
+ static int wacom_remote_create_one(struct wacom *wacom, u32 serial,
+ 				   unsigned int index)
+ {
+ 	struct wacom_remote *remote = wacom->remote;
+ 	struct device *dev = &wacom->hdev->dev;
+ 	int error, k;
+ 
+ 	/* A remote can pair more than once with an EKR,
+ 	 * check to make sure this serial isn't already paired.
+ 	 */
+ 	for (k = 0; k < WACOM_MAX_REMOTES; k++) {
+ 		if (remote->remotes[k].serial == serial)
+ 			break;
+ 	}
+ 
+ 	if (k < WACOM_MAX_REMOTES) {
+ 		remote->remotes[index].serial = serial;
+ 		return 0;
+ 	}
+ 
+ 	if (!devres_open_group(dev, &remote->remotes[index], GFP_KERNEL))
+ 		return -ENOMEM;
+ 
+ 	error = wacom_remote_create_attr_group(wacom, serial, index);
+ 	if (error)
+ 		goto fail;
+ 
+ 	remote->remotes[index].input = wacom_allocate_input(wacom);
+ 	if (!remote->remotes[index].input) {
+ 		error = -ENOMEM;
+ 		goto fail;
+ 	}
+ 	remote->remotes[index].input->uniq = remote->remotes[index].group.name;
+ 	remote->remotes[index].input->name = wacom->wacom_wac.pad_name;
+ 
+ 	if (!remote->remotes[index].input->name) {
+ 		error = -EINVAL;
+ 		goto fail;
+ 	}
+ 
+ 	error = wacom_setup_pad_input_capabilities(remote->remotes[index].input,
+ 						   &wacom->wacom_wac);
+ 	if (error)
+ 		goto fail;
+ 
+ 	remote->remotes[index].serial = serial;
+ 
+ 	error = input_register_device(remote->remotes[index].input);
+ 	if (error)
+ 		goto fail;
+ 
+ 	error = __wacom_initialize_battery(wacom,
+ 					   &remote->remotes[index].battery);
+ 	if (error)
+ 		goto fail;
+ 
+ 	remote->remotes[index].registered = true;
+ 
+ 	devres_close_group(dev, &remote->remotes[index]);
+ 	return 0;
+ 
+ fail:
+ 	devres_release_group(dev, &remote->remotes[index]);
+ 	remote->remotes[index].serial = 0;
+ 	return error;
+ }
+ 
+ static void wacom_remote_work(struct work_struct *work)
+ {
+ 	struct wacom *wacom = container_of(work, struct wacom, remote_work);
+ 	struct wacom_remote *remote = wacom->remote;
+ 	struct wacom_remote_data data;
+ 	unsigned long flags;
+ 	unsigned int count;
+ 	u32 serial;
+ 	int i;
+ 
+ 	spin_lock_irqsave(&remote->remote_lock, flags);
+ 
+ 	count = kfifo_out(&remote->remote_fifo, &data, sizeof(data));
+ 
+ 	if (count != sizeof(data)) {
+ 		hid_err(wacom->hdev,
+ 			"workitem triggered without status available\n");
+ 		spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 		return;
+ 	}
+ 
+ 	if (!kfifo_is_empty(&remote->remote_fifo))
+ 		wacom_schedule_work(&wacom->wacom_wac, WACOM_WORKER_REMOTE);
+ 
+ 	spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		serial = data.remote[i].serial;
+ 		if (data.remote[i].connected) {
+ 
+ 			if (remote->remotes[i].serial == serial)
+ 				continue;
+ 
+ 			if (remote->remotes[i].serial)
+ 				wacom_remote_destroy_one(wacom, i);
+ 
+ 			wacom_remote_create_one(wacom, serial, i);
+ 
+ 		} else if (remote->remotes[i].serial) {
+ 			wacom_remote_destroy_one(wacom, i);
+ 		}
+ 	}
+ }
+ 
+ static int wacom_probe(struct hid_device *hdev,
+ 		const struct hid_device_id *id)
+ {
+ 	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
  	struct usb_device *dev = interface_to_usbdev(intf);
 +	struct usb_endpoint_descriptor *endpoint;
  	struct wacom *wacom;
  	struct wacom_wac *wacom_wac;
  	struct wacom_features *features;
diff --cc drivers/hid/wacom_wac.c
index 98c7d65145c2,1c882bb70f14..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -34,6 -34,50 +34,53 @@@
   */
  #define WACOM_CONTACT_AREA_SCALE 2607
  
++<<<<<<< HEAD
++=======
+ static void wacom_report_numbered_buttons(struct input_dev *input_dev,
+ 				int button_count, int mask);
+ 
+ /*
+  * Percent of battery capacity for Graphire.
+  * 8th value means AC online and show 100% capacity.
+  */
+ static unsigned short batcap_gr[8] = { 1, 15, 25, 35, 50, 70, 100, 100 };
+ 
+ /*
+  * Percent of battery capacity for Intuos4 WL, AC has a separate bit.
+  */
+ static unsigned short batcap_i4[8] = { 1, 15, 30, 45, 60, 70, 85, 100 };
+ 
+ static void __wacom_notify_battery(struct wacom_battery *battery,
+ 				   int bat_capacity, bool bat_charging,
+ 				   bool bat_connected, bool ps_connected)
+ {
+ 	bool changed = battery->battery_capacity != bat_capacity  ||
+ 		       battery->bat_charging     != bat_charging  ||
+ 		       battery->bat_connected    != bat_connected ||
+ 		       battery->ps_connected     != ps_connected;
+ 
+ 	if (changed) {
+ 		battery->battery_capacity = bat_capacity;
+ 		battery->bat_charging = bat_charging;
+ 		battery->bat_connected = bat_connected;
+ 		battery->ps_connected = ps_connected;
+ 
+ 		if (battery->battery)
+ 			power_supply_changed(battery->battery);
+ 	}
+ }
+ 
+ static void wacom_notify_battery(struct wacom_wac *wacom_wac,
+ 	int bat_capacity, bool bat_charging, bool bat_connected,
+ 	bool ps_connected)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 
+ 	__wacom_notify_battery(&wacom->battery, bat_capacity, bat_charging,
+ 			       bat_connected, ps_connected);
+ }
+ 
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
  static int wacom_penpartner_irq(struct wacom_wac *wacom)
  {
  	unsigned char *data = wacom->data;
@@@ -488,7 -757,132 +535,136 @@@ static int wacom_intuos_inout(struct wa
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void wacom_intuos_general(struct wacom_wac *wacom)
++=======
+ static int wacom_remote_irq(struct wacom_wac *wacom_wac, size_t len)
+ {
+ 	unsigned char *data = wacom_wac->data;
+ 	struct input_dev *input;
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	struct wacom_remote *remote = wacom->remote;
+ 	int bat_charging, bat_percent, touch_ring_mode;
+ 	__u32 serial;
+ 	int i, index = -1;
+ 	unsigned long flags;
+ 
+ 	if (data[0] != WACOM_REPORT_REMOTE) {
+ 		hid_dbg(wacom->hdev, "%s: received unknown report #%d",
+ 			__func__, data[0]);
+ 		return 0;
+ 	}
+ 
+ 	serial = data[3] + (data[4] << 8) + (data[5] << 16);
+ 	wacom_wac->id[0] = PAD_DEVICE_ID;
+ 
+ 	spin_lock_irqsave(&remote->remote_lock, flags);
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		if (remote->remotes[i].serial == serial) {
+ 			index = i;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (index < 0 || !remote->remotes[index].registered)
+ 		goto out;
+ 
+ 	input = remote->remotes[index].input;
+ 
+ 	input_report_key(input, BTN_0, (data[9] & 0x01));
+ 	input_report_key(input, BTN_1, (data[9] & 0x02));
+ 	input_report_key(input, BTN_2, (data[9] & 0x04));
+ 	input_report_key(input, BTN_3, (data[9] & 0x08));
+ 	input_report_key(input, BTN_4, (data[9] & 0x10));
+ 	input_report_key(input, BTN_5, (data[9] & 0x20));
+ 	input_report_key(input, BTN_6, (data[9] & 0x40));
+ 	input_report_key(input, BTN_7, (data[9] & 0x80));
+ 
+ 	input_report_key(input, BTN_8, (data[10] & 0x01));
+ 	input_report_key(input, BTN_9, (data[10] & 0x02));
+ 	input_report_key(input, BTN_A, (data[10] & 0x04));
+ 	input_report_key(input, BTN_B, (data[10] & 0x08));
+ 	input_report_key(input, BTN_C, (data[10] & 0x10));
+ 	input_report_key(input, BTN_X, (data[10] & 0x20));
+ 	input_report_key(input, BTN_Y, (data[10] & 0x40));
+ 	input_report_key(input, BTN_Z, (data[10] & 0x80));
+ 
+ 	input_report_key(input, BTN_BASE, (data[11] & 0x01));
+ 	input_report_key(input, BTN_BASE2, (data[11] & 0x02));
+ 
+ 	if (data[12] & 0x80)
+ 		input_report_abs(input, ABS_WHEEL, (data[12] & 0x7f));
+ 	else
+ 		input_report_abs(input, ABS_WHEEL, 0);
+ 
+ 	bat_percent = data[7] & 0x7f;
+ 	bat_charging = !!(data[7] & 0x80);
+ 
+ 	if (data[9] | data[10] | (data[11] & 0x03) | data[12])
+ 		input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 	else
+ 		input_report_abs(input, ABS_MISC, 0);
+ 
+ 	input_event(input, EV_MSC, MSC_SERIAL, serial);
+ 
+ 	input_sync(input);
+ 
+ 	/*Which mode select (LED light) is currently on?*/
+ 	touch_ring_mode = (data[11] & 0xC0) >> 6;
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		if (remote->remotes[i].serial == serial)
+ 			wacom->led.groups[i].select = touch_ring_mode;
+ 	}
+ 
+ 	__wacom_notify_battery(&remote->remotes[index].battery, bat_percent,
+ 				bat_charging, 1, bat_charging);
+ 
+ out:
+ 	spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 	return 0;
+ }
+ 
+ static void wacom_remote_status_irq(struct wacom_wac *wacom_wac, size_t len)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	unsigned char *data = wacom_wac->data;
+ 	struct wacom_remote *remote = wacom->remote;
+ 	struct wacom_remote_data remote_data;
+ 	unsigned long flags;
+ 	int i, ret;
+ 
+ 	if (data[0] != WACOM_REPORT_DEVICE_LIST)
+ 		return;
+ 
+ 	memset(&remote_data, 0, sizeof(struct wacom_remote_data));
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		int j = i * 6;
+ 		int serial = (data[j+6] << 16) + (data[j+5] << 8) + data[j+4];
+ 		bool connected = data[j+2];
+ 
+ 		remote_data.remote[i].serial = serial;
+ 		remote_data.remote[i].connected = connected;
+ 	}
+ 
+ 	spin_lock_irqsave(&remote->remote_lock, flags);
+ 
+ 	ret = kfifo_in(&remote->remote_fifo, &remote_data, sizeof(remote_data));
+ 	if (ret != sizeof(remote_data)) {
+ 		spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 		hid_err(wacom->hdev, "Can't queue Remote status event.\n");
+ 		return;
+ 	}
+ 
+ 	spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 
+ 	wacom_schedule_work(wacom_wac, WACOM_WORKER_REMOTE);
+ }
+ 
+ static int wacom_intuos_general(struct wacom_wac *wacom)
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
  {
  	struct wacom_features *features = &wacom->features;
  	unsigned char *data = wacom->data;
@@@ -1311,15 -2143,27 +1487,21 @@@ static int wacom_wireless_irq(struct wa
  
  	connected = data[1] & 0x01;
  	if (connected) {
 -		int pid, battery, charging;
 -
 -		if ((wacom->shared->type == INTUOSHT ||
 -		    wacom->shared->type == INTUOSHT2) &&
 -		    wacom->shared->touch_input &&
 -		    wacom->shared->touch_max) {
 -			input_report_switch(wacom->shared->touch_input,
 -					SW_MUTE_DEVICE, data[5] & 0x40);
 -			input_sync(wacom->shared->touch_input);
 -		}
 +		int pid, battery;
  
  		pid = get_unaligned_be16(&data[6]);
 -		battery = (data[5] & 0x3f) * 100 / 31;
 -		charging = !!(data[5] & 0x80);
 +		battery = data[5] & 0x3f;
  		if (wacom->pid != pid) {
  			wacom->pid = pid;
 -			wacom_schedule_work(wacom, WACOM_WORKER_WIRELESS);
 +			wacom_schedule_work(wacom);
  		}
++<<<<<<< HEAD
 +		wacom->battery_capacity = battery;
++=======
+ 
+ 		wacom_notify_battery(wacom, battery, charging, 1, 0);
+ 
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
  	} else if (wacom->pid != 0) {
  		/* disconnected while previously connected */
  		wacom->pid = 0;
@@@ -1330,6 -2174,46 +1512,49 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int wacom_status_irq(struct wacom_wac *wacom_wac, size_t len)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	unsigned char *data = wacom_wac->data;
+ 
+ 	if (data[0] != WACOM_REPORT_USB)
+ 		return 0;
+ 
+ 	if ((features->type == INTUOSHT ||
+ 	    features->type == INTUOSHT2) &&
+ 	    wacom_wac->shared->touch_input &&
+ 	    features->touch_max) {
+ 		input_report_switch(wacom_wac->shared->touch_input,
+ 				    SW_MUTE_DEVICE, data[8] & 0x40);
+ 		input_sync(wacom_wac->shared->touch_input);
+ 	}
+ 
+ 	if (data[9] & 0x02) { /* wireless module is attached */
+ 		int battery = (data[8] & 0x3f) * 100 / 31;
+ 		bool charging = !!(data[8] & 0x80);
+ 
+ 		wacom_notify_battery(wacom_wac, battery, charging,
+ 				     battery || charging, 1);
+ 
+ 		if (!wacom->battery.battery &&
+ 		    !(features->quirks & WACOM_QUIRK_BATTERY)) {
+ 			features->quirks |= WACOM_QUIRK_BATTERY;
+ 			wacom_schedule_work(wacom_wac, WACOM_WORKER_BATTERY);
+ 		}
+ 	}
+ 	else if ((features->quirks & WACOM_QUIRK_BATTERY) &&
+ 		 wacom->battery.battery) {
+ 		features->quirks &= ~WACOM_QUIRK_BATTERY;
+ 		wacom_schedule_work(wacom_wac, WACOM_WORKER_BATTERY);
+ 		wacom_notify_battery(wacom_wac, 0, 0, 0, 0);
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
  void wacom_wac_irq(struct wacom_wac *wacom_wac, size_t len)
  {
  	bool sync;
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,8a8974c901cb..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -138,17 -194,58 +138,31 @@@ struct wacom_shared 
  };
  
  struct wacom_wac {
++<<<<<<< HEAD
 +	char name[WACOM_NAME_MAX];
 +	unsigned char *data;
++=======
+ 	char pen_name[WACOM_NAME_MAX];
+ 	char touch_name[WACOM_NAME_MAX];
+ 	char pad_name[WACOM_NAME_MAX];
+ 	unsigned char data[WACOM_PKGLEN_MAX];
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
  	int tool[2];
  	int id[2];
  	__u32 serial[2];
 -	bool reporting_data;
  	struct wacom_features features;
  	struct wacom_shared *shared;
 -	struct input_dev *pen_input;
 -	struct input_dev *touch_input;
 -	struct input_dev *pad_input;
 +	struct input_dev *input;
  	int pid;
- 	int battery_capacity;
  	int num_contacts_left;
++<<<<<<< HEAD
++=======
+ 	u8 bt_features;
+ 	u8 bt_high_speed;
+ 	int mode_report;
+ 	int mode_value;
+ 	struct hid_data hid_data;
++>>>>>>> 59d69bc82154 (HID: wacom: EKR: have one power_supply per remote)
  };
  
  #endif
* Unmerged path drivers/hid/wacom.h
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
* Unmerged path drivers/hid/wacom_wac.h
