flow_dissector: Fix fragment handling for header length computation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit 43d2ccb3c122a47524019d1831a54f07f7fcb978
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/43d2ccb3.failed

It turns out that for IPv4 we were reporting the ip_proto of the fragment,
and for IPv6 we were not.  This patch updates that behavior so that we
always report the IP protocol of the fragment.  In addition it takes the
steps of updating the payload offset code so that we will determine the
start of the payload not including the L4 header for any fragment after the
first.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Acked-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 43d2ccb3c122a47524019d1831a54f07f7fcb978)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,8bd745f72734..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -296,16 -445,15 +296,21 @@@ ip_proto_again
  		if (!fh)
  			goto out_bad;
  
 -		key_control->flags |= FLOW_DIS_IS_FRAGMENT;
 +		key_control->is_fragment = 1;
  
  		nhoff += sizeof(_fh);
+ 		ip_proto = fh->nexthdr;
  
  		if (!(fh->frag_off & htons(IP6_OFFSET))) {
++<<<<<<< HEAD
 +			key_control->first_frag = 1;
 +			if (flags & FLOW_DISSECTOR_F_PARSE_1ST_FRAG) {
 +				ip_proto = fh->nexthdr;
++=======
+ 			key_control->flags |= FLOW_DIS_FIRST_FRAG;
+ 			if (flags & FLOW_DISSECTOR_F_PARSE_1ST_FRAG)
++>>>>>>> 43d2ccb3c122 (flow_dissector: Fix fragment handling for header length computation)
  				goto ip_proto_again;
- 			}
  		}
  		goto out_good;
  	}
@@@ -418,19 -738,25 +423,28 @@@ EXPORT_SYMBOL(__skb_tx_hash)
  u32 __skb_get_poff(const struct sk_buff *skb, void *data,
  		   const struct flow_keys *keys, int hlen)
  {
 -	u32 poff = keys->control.thoff;
 +	u32 poff = keys->thoff;
  
++<<<<<<< HEAD
 +	switch (keys->ip_proto) {
++=======
+ 	/* skip L4 headers for fragments after the first */
+ 	if ((keys->control.flags & FLOW_DIS_IS_FRAGMENT) &&
+ 	    !(keys->control.flags & FLOW_DIS_FIRST_FRAG))
+ 		return poff;
+ 
+ 	switch (keys->basic.ip_proto) {
++>>>>>>> 43d2ccb3c122 (flow_dissector: Fix fragment handling for header length computation)
  	case IPPROTO_TCP: {
 -		/* access doff as u8 to avoid unaligned access */
 -		const u8 *doff;
 -		u8 _doff;
 +		const struct tcphdr *tcph;
 +		struct tcphdr _tcph;
  
 -		doff = __skb_header_pointer(skb, poff + 12, sizeof(_doff),
 -					    data, hlen, &_doff);
 -		if (!doff)
 +		tcph = __skb_header_pointer(skb, poff, sizeof(_tcph),
 +					    data, hlen, &_tcph);
 +		if (!tcph)
  			return poff;
  
 -		poff += max_t(u32, sizeof(struct tcphdr), (*doff & 0xF0) >> 2);
 +		poff += max_t(u32, sizeof(struct tcphdr), tcph->doff * 4);
  		break;
  	}
  	case IPPROTO_UDP:
* Unmerged path net/core/flow_dissector.c
