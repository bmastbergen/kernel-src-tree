HID: wacom: Add four new Intuos devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Add four new Intuos devices (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 93.15%
commit-author Ping Cheng <pinglinux@gmail.com>
commit eda01dab53b1126a20da98b5d691f3e55d79f21d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/eda01dab.failed

This series of devices supports both pen and touch. It reports
touch data in Bamboo3 format and pen data in Intuos pro format.

	Signed-off-by: Ping Cheng <pingc@wacom.com>
Tested-By: Aaron Skomra <aaron.skomra@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit eda01dab53b1126a20da98b5d691f3e55d79f21d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,530476dc7bb9..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1293,10 -1495,202 +1293,206 @@@ static void wacom_calculate_res(struct 
  						    features->unitExpo);
  }
  
 -static void wacom_wireless_work(struct work_struct *work)
 +static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *id)
  {
++<<<<<<< HEAD
++=======
+ 	struct wacom *wacom = container_of(work, struct wacom, work);
+ 	struct usb_device *usbdev = wacom->usbdev;
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_device *hdev1, *hdev2;
+ 	struct wacom *wacom1, *wacom2;
+ 	struct wacom_wac *wacom_wac1, *wacom_wac2;
+ 	int error;
+ 
+ 	/*
+ 	 * Regardless if this is a disconnect or a new tablet,
+ 	 * remove any existing input and battery devices.
+ 	 */
+ 
+ 	wacom_destroy_battery(wacom);
+ 
+ 	/* Stylus interface */
+ 	hdev1 = usb_get_intfdata(usbdev->config->interface[1]);
+ 	wacom1 = hid_get_drvdata(hdev1);
+ 	wacom_wac1 = &(wacom1->wacom_wac);
+ 	wacom_clean_inputs(wacom1);
+ 
+ 	/* Touch interface */
+ 	hdev2 = usb_get_intfdata(usbdev->config->interface[2]);
+ 	wacom2 = hid_get_drvdata(hdev2);
+ 	wacom_wac2 = &(wacom2->wacom_wac);
+ 	wacom_clean_inputs(wacom2);
+ 
+ 	if (wacom_wac->pid == 0) {
+ 		hid_info(wacom->hdev, "wireless tablet disconnected\n");
+ 		wacom_wac1->shared->type = 0;
+ 	} else {
+ 		const struct hid_device_id *id = wacom_ids;
+ 
+ 		hid_info(wacom->hdev, "wireless tablet connected with PID %x\n",
+ 			 wacom_wac->pid);
+ 
+ 		while (id->bus) {
+ 			if (id->vendor == USB_VENDOR_ID_WACOM &&
+ 			    id->product == wacom_wac->pid)
+ 				break;
+ 			id++;
+ 		}
+ 
+ 		if (!id->bus) {
+ 			hid_info(wacom->hdev, "ignoring unknown PID.\n");
+ 			return;
+ 		}
+ 
+ 		/* Stylus interface */
+ 		wacom_wac1->features =
+ 			*((struct wacom_features *)id->driver_data);
+ 		wacom_wac1->features.device_type |= WACOM_DEVICETYPE_PEN;
+ 		wacom_set_default_phy(&wacom_wac1->features);
+ 		wacom_calculate_res(&wacom_wac1->features);
+ 		snprintf(wacom_wac1->pen_name, WACOM_NAME_MAX, "%s (WL) Pen",
+ 			 wacom_wac1->features.name);
+ 		if (wacom_wac1->features.type < BAMBOO_PEN ||
+ 		    wacom_wac1->features.type > BAMBOO_PT) {
+ 			snprintf(wacom_wac1->pad_name, WACOM_NAME_MAX, "%s (WL) Pad",
+ 				 wacom_wac1->features.name);
+ 			wacom_wac1->features.device_type |= WACOM_DEVICETYPE_PAD;
+ 		}
+ 		wacom_wac1->shared->touch_max = wacom_wac1->features.touch_max;
+ 		wacom_wac1->shared->type = wacom_wac1->features.type;
+ 		wacom_wac1->pid = wacom_wac->pid;
+ 		error = wacom_allocate_inputs(wacom1) ||
+ 			wacom_register_inputs(wacom1);
+ 		if (error)
+ 			goto fail;
+ 
+ 		/* Touch interface */
+ 		if (wacom_wac1->features.touch_max ||
+ 		    (wacom_wac1->features.type >= INTUOSHT &&
+ 		    wacom_wac1->features.type <= BAMBOO_PT)) {
+ 			wacom_wac2->features =
+ 				*((struct wacom_features *)id->driver_data);
+ 			wacom_wac2->features.pktlen = WACOM_PKGLEN_BBTOUCH3;
+ 			wacom_set_default_phy(&wacom_wac2->features);
+ 			wacom_wac2->features.x_max = wacom_wac2->features.y_max = 4096;
+ 			wacom_calculate_res(&wacom_wac2->features);
+ 			snprintf(wacom_wac2->touch_name, WACOM_NAME_MAX,
+ 				 "%s (WL) Finger",wacom_wac2->features.name);
+ 			if (wacom_wac1->features.touch_max)
+ 				wacom_wac2->features.device_type |= WACOM_DEVICETYPE_TOUCH;
+ 			if (wacom_wac1->features.type >= INTUOSHT &&
+ 			    wacom_wac1->features.type <= BAMBOO_PT) {
+ 				snprintf(wacom_wac2->pad_name, WACOM_NAME_MAX,
+ 					 "%s (WL) Pad",wacom_wac2->features.name);
+ 				wacom_wac2->features.device_type |= WACOM_DEVICETYPE_PAD;
+ 			}
+ 			wacom_wac2->pid = wacom_wac->pid;
+ 			error = wacom_allocate_inputs(wacom2) ||
+ 				wacom_register_inputs(wacom2);
+ 			if (error)
+ 				goto fail;
+ 
+ 			if ((wacom_wac1->features.type == INTUOSHT ||
+ 			    wacom_wac1->features.type == INTUOSHT2) &&
+ 			    wacom_wac1->features.touch_max)
+ 				wacom_wac->shared->touch_input = wacom_wac2->touch_input;
+ 		}
+ 
+ 		error = wacom_initialize_battery(wacom);
+ 		if (error)
+ 			goto fail;
+ 	}
+ 
+ 	return;
+ 
+ fail:
+ 	wacom_clean_inputs(wacom1);
+ 	wacom_clean_inputs(wacom2);
+ 	return;
+ }
+ 
+ void wacom_battery_work(struct work_struct *work)
+ {
+ 	struct wacom *wacom = container_of(work, struct wacom, work);
+ 
+ 	if ((wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 	     !wacom->battery) {
+ 		wacom_initialize_battery(wacom);
+ 	}
+ 	else if (!(wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 		 wacom->battery) {
+ 		wacom_destroy_battery(wacom);
+ 	}
+ }
+ 
+ static size_t wacom_compute_pktlen(struct hid_device *hdev)
+ {
+ 	struct hid_report_enum *report_enum;
+ 	struct hid_report *report;
+ 	size_t size = 0;
+ 
+ 	report_enum = hdev->report_enum + HID_INPUT_REPORT;
+ 
+ 	list_for_each_entry(report, &report_enum->report_list, list) {
+ 		size_t report_size = hid_report_len(report);
+ 		if (report_size > size)
+ 			size = report_size;
+ 	}
+ 
+ 	return size;
+ }
+ 
+ static void wacom_update_name(struct wacom *wacom)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	char name[WACOM_NAME_MAX];
+ 
+ 	/* Generic devices name unspecified */
+ 	if ((features->type == HID_GENERIC) && !strcmp("Wacom HID", features->name)) {
+ 		if (strstr(wacom->hdev->name, "Wacom") ||
+ 		    strstr(wacom->hdev->name, "wacom") ||
+ 		    strstr(wacom->hdev->name, "WACOM")) {
+ 			/* name is in HID descriptor, use it */
+ 			strlcpy(name, wacom->hdev->name, sizeof(name));
+ 
+ 			/* strip out excess whitespaces */
+ 			while (1) {
+ 				char *gap = strstr(name, "  ");
+ 				if (gap == NULL)
+ 					break;
+ 				/* shift everything including the terminator */
+ 				memmove(gap, gap+1, strlen(gap));
+ 			}
+ 			/* get rid of trailing whitespace */
+ 			if (name[strlen(name)-1] == ' ')
+ 				name[strlen(name)-1] = '\0';
+ 		} else {
+ 			/* no meaningful name retrieved. use product ID */
+ 			snprintf(name, sizeof(name),
+ 				 "%s %X", features->name, wacom->hdev->product);
+ 		}
+ 	} else {
+ 		strlcpy(name, features->name, sizeof(name));
+ 	}
+ 
+ 	/* Append the device type to the name */
+ 	snprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),
+ 		"%s Pen", name);
+ 	snprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),
+ 		"%s Finger", name);
+ 	snprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),
+ 		"%s Pad", name);
+ }
+ 
+ static int wacom_probe(struct hid_device *hdev,
+ 		const struct hid_device_id *id)
+ {
+ 	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  	struct usb_device *dev = interface_to_usbdev(intf);
 +	struct usb_endpoint_descriptor *endpoint;
  	struct wacom *wacom;
  	struct wacom_wac *wacom_wac;
  	struct wacom_features *features;
@@@ -1412,15 -1779,67 +1608,70 @@@
  	}
  
  	/* Note that if query fails it is not a hard failure */
 -	wacom_query_tablet_data(hdev, features);
 +	wacom_query_tablet_data(intf, features);
  
 -	/* touch only Bamboo doesn't support pen */
 -	if ((features->type == BAMBOO_TOUCH) &&
 -	    (features->device_type & WACOM_DEVICETYPE_PEN)) {
 -		error = -ENODEV;
 -		goto fail_shared_data;
 -	}
 +	usb_set_intfdata(intf, wacom);
  
++<<<<<<< HEAD
 +	if (features->quirks & WACOM_QUIRK_MONITOR) {
 +		if (usb_submit_urb(wacom->irq, GFP_KERNEL)) {
 +			error = -EIO;
 +			goto fail5;
 +		}
++=======
+ 	/* pen only Bamboo neither support touch nor pad */
+ 	if ((features->type == BAMBOO_PEN) &&
+ 	    ((features->device_type & WACOM_DEVICETYPE_TOUCH) ||
+ 	    (features->device_type & WACOM_DEVICETYPE_PAD))) {
+ 		error = -ENODEV;
+ 		goto fail_shared_data;
+ 	}
+ 
+ 	wacom_calculate_res(features);
+ 
+ 	wacom_update_name(wacom);
+ 
+ 	error = wacom_add_shared_data(hdev);
+ 	if (error)
+ 		goto fail_shared_data;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_WL_MONITOR) &&
+ 	     (features->quirks & WACOM_QUIRK_BATTERY)) {
+ 		error = wacom_initialize_battery(wacom);
+ 		if (error)
+ 			goto fail_battery;
+ 	}
+ 
+ 	error = wacom_register_inputs(wacom);
+ 	if (error)
+ 		goto fail_register_inputs;
+ 
+ 	if (hdev->bus == BUS_BLUETOOTH) {
+ 		error = device_create_file(&hdev->dev, &dev_attr_speed);
+ 		if (error)
+ 			hid_warn(hdev,
+ 				 "can't create sysfs speed attribute err: %d\n",
+ 				 error);
+ 	}
+ 
+ 	if (features->type == HID_GENERIC)
+ 		connect_mask |= HID_CONNECT_DRIVER;
+ 
+ 	/* Regular HID work starts now */
+ 	error = hid_hw_start(hdev, connect_mask);
+ 	if (error) {
+ 		hid_err(hdev, "hw start failed\n");
+ 		goto fail_hw_start;
+ 	}
+ 
+ 	if (features->device_type & WACOM_DEVICETYPE_WL_MONITOR)
+ 		error = hid_hw_open(hdev);
+ 
+ 	if ((wacom_wac->features.type == INTUOSHT ||
+ 	    wacom_wac->features.type == INTUOSHT2) &&
+ 	    (wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH)) {
+ 			wacom_wac->shared->touch_input = wacom_wac->touch_input;
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  	}
  
  	return 0;
diff --cc drivers/hid/wacom_wac.c
index bdf17efa93aa,a0d875c5ed38..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1138,29 -1550,358 +1141,35 @@@ static int wacom_bpt_touch(struct wacom
  	return 0;
  }
  
 -static void wacom_wac_pen_pre_report(struct hid_device *hdev,
 -		struct hid_report *report)
 -{
 -	return;
 -}
 -
 -static void wacom_wac_pen_report(struct hid_device *hdev,
 -		struct hid_report *report)
 +static void wacom_bpt3_touch_msg(struct wacom_wac *wacom, unsigned char *data)
  {
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct input_dev *input = wacom_wac->pen_input;
 -	bool prox = wacom_wac->hid_data.inrange_state;
 +	struct wacom_features *features = &wacom->features;
 +	struct input_dev *input = wacom->input;
 +	bool touch = data[1] & 0x80;
 +	int slot = input_mt_get_slot_by_key(input, data[0]);
  
 -	if (!wacom_wac->shared->stylus_in_proximity) /* first in prox */
 -		/* Going into proximity select tool */
 -		wacom_wac->tool[0] = wacom_wac->hid_data.invert_state ?
 -						BTN_TOOL_RUBBER : BTN_TOOL_PEN;
 +	if (slot < 0)
 +		return;
  
 -	/* keep pen state for touch events */
 -	wacom_wac->shared->stylus_in_proximity = prox;
 +	touch = touch && !wacom->shared->stylus_in_proximity;
  
 -	/* send pen events only when touch is up or forced out */
 -	if (!wacom_wac->shared->touch_down) {
 -		input_report_key(input, BTN_TOUCH,
 -				wacom_wac->hid_data.tipswitch);
 -		input_report_key(input, wacom_wac->tool[0], prox);
 +	input_mt_slot(input, slot);
 +	input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
  
 -		wacom_wac->hid_data.tipswitch = false;
 -
 -		input_sync(input);
 -	}
 -}
 -
 -static void wacom_wac_finger_usage_mapping(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct wacom_features *features = &wacom_wac->features;
 -	struct input_dev *input = wacom_wac->touch_input;
 -	unsigned touch_max = wacom_wac->features.touch_max;
 -
 -	switch (usage->hid) {
 -	case HID_GD_X:
 -		features->last_slot_field = usage->hid;
 -		if (touch_max == 1)
 -			wacom_map_usage(input, usage, field, EV_ABS, ABS_X, 4);
 -		else
 -			wacom_map_usage(input, usage, field, EV_ABS,
 -					ABS_MT_POSITION_X, 4);
 -		break;
 -	case HID_GD_Y:
 -		features->last_slot_field = usage->hid;
 -		if (touch_max == 1)
 -			wacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 4);
 -		else
 -			wacom_map_usage(input, usage, field, EV_ABS,
 -					ABS_MT_POSITION_Y, 4);
 -		break;
 -	case HID_DG_WIDTH:
 -	case HID_DG_HEIGHT:
 -		features->last_slot_field = usage->hid;
 -		wacom_map_usage(input, usage, field, EV_ABS, ABS_MT_TOUCH_MAJOR, 0);
 -		wacom_map_usage(input, usage, field, EV_ABS, ABS_MT_TOUCH_MINOR, 0);
 -		input_set_abs_params(input, ABS_MT_ORIENTATION, 0, 1, 0, 0);
 -		break;
 -	case HID_DG_CONTACTID:
 -		features->last_slot_field = usage->hid;
 -		break;
 -	case HID_DG_INRANGE:
 -		features->last_slot_field = usage->hid;
 -		break;
 -	case HID_DG_INVERT:
 -		features->last_slot_field = usage->hid;
 -		break;
 -	case HID_DG_TIPSWITCH:
 -		features->last_slot_field = usage->hid;
 -		wacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);
 -		break;
 -	case HID_DG_CONTACTCOUNT:
 -		wacom_wac->hid_data.cc_index = field->index;
 -		wacom_wac->hid_data.cc_value_index = usage->usage_index;
 -		break;
 -	}
 -}
 -
 -static void wacom_wac_finger_slot(struct wacom_wac *wacom_wac,
 -		struct input_dev *input)
 -{
 -	struct hid_data *hid_data = &wacom_wac->hid_data;
 -	bool mt = wacom_wac->features.touch_max > 1;
 -	bool prox = hid_data->tipswitch &&
 -		    !wacom_wac->shared->stylus_in_proximity;
 -
 -	wacom_wac->hid_data.num_received++;
 -	if (wacom_wac->hid_data.num_received > wacom_wac->hid_data.num_expected)
 -		return;
 -
 -	if (mt) {
 -		int slot;
 -
 -		slot = input_mt_get_slot_by_key(input, hid_data->id);
 -		input_mt_slot(input, slot);
 -		input_mt_report_slot_state(input, MT_TOOL_FINGER, prox);
 -	}
 -	else {
 -		input_report_key(input, BTN_TOUCH, prox);
 -	}
 -
 -	if (prox) {
 -		input_report_abs(input, mt ? ABS_MT_POSITION_X : ABS_X,
 -				 hid_data->x);
 -		input_report_abs(input, mt ? ABS_MT_POSITION_Y : ABS_Y,
 -				 hid_data->y);
 -
 -		if (test_bit(ABS_MT_TOUCH_MAJOR, input->absbit)) {
 -			input_report_abs(input, ABS_MT_TOUCH_MAJOR, max(hid_data->width, hid_data->height));
 -			input_report_abs(input, ABS_MT_TOUCH_MINOR, min(hid_data->width, hid_data->height));
 -			if (hid_data->width != hid_data->height)
 -				input_report_abs(input, ABS_MT_ORIENTATION, hid_data->width <= hid_data->height ? 0 : 1);
 -		}
 -	}
 -}
 -
 -static int wacom_wac_finger_event(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage, __s32 value)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -
 -	switch (usage->hid) {
 -	case HID_GD_X:
 -		wacom_wac->hid_data.x = value;
 -		break;
 -	case HID_GD_Y:
 -		wacom_wac->hid_data.y = value;
 -		break;
 -	case HID_DG_WIDTH:
 -		wacom_wac->hid_data.width = value;
 -		break;
 -	case HID_DG_HEIGHT:
 -		wacom_wac->hid_data.height = value;
 -		break;
 -	case HID_DG_CONTACTID:
 -		wacom_wac->hid_data.id = value;
 -		break;
 -	case HID_DG_TIPSWITCH:
 -		wacom_wac->hid_data.tipswitch = value;
 -		break;
 -	}
 -
 -
 -	if (usage->usage_index + 1 == field->report_count) {
 -		if (usage->hid == wacom_wac->features.last_slot_field)
 -			wacom_wac_finger_slot(wacom_wac, wacom_wac->touch_input);
 -	}
 -
 -	return 0;
 -}
 -
 -static void wacom_wac_finger_pre_report(struct hid_device *hdev,
 -		struct hid_report *report)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct hid_data* hid_data = &wacom_wac->hid_data;
 -
 -	if (hid_data->cc_index >= 0) {
 -		struct hid_field *field = report->field[hid_data->cc_index];
 -		int value = field->value[hid_data->cc_value_index];
 -		if (value)
 -			hid_data->num_expected = value;
 -	}
 -	else {
 -		hid_data->num_expected = wacom_wac->features.touch_max;
 -	}
 -}
 -
 -static void wacom_wac_finger_report(struct hid_device *hdev,
 -		struct hid_report *report)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct input_dev *input = wacom_wac->touch_input;
 -	unsigned touch_max = wacom_wac->features.touch_max;
 -
 -	/* If more packets of data are expected, give us a chance to
 -	 * process them rather than immediately syncing a partial
 -	 * update.
 -	 */
 -	if (wacom_wac->hid_data.num_received < wacom_wac->hid_data.num_expected)
 -		return;
 -
 -	if (touch_max > 1)
 -		input_mt_sync_frame(input);
 -
 -	input_sync(input);
 -	wacom_wac->hid_data.num_received = 0;
 -
 -	/* keep touch state for pen event */
 -	wacom_wac->shared->touch_down = wacom_wac_finger_count_touches(wacom_wac);
 -}
 -
 -void wacom_wac_usage_mapping(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -
 -	/* currently, only direct devices have proper hid report descriptors */
 -	__set_bit(INPUT_PROP_DIRECT, wacom_wac->pen_input->propbit);
 -	__set_bit(INPUT_PROP_DIRECT, wacom_wac->touch_input->propbit);
 -
 -	if (WACOM_PEN_FIELD(field))
 -		return wacom_wac_pen_usage_mapping(hdev, field, usage);
 -
 -	if (WACOM_FINGER_FIELD(field))
 -		return wacom_wac_finger_usage_mapping(hdev, field, usage);
 -}
 -
 -int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
 -		struct hid_usage *usage, __s32 value)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -
 -	if (wacom->wacom_wac.features.type != HID_GENERIC)
 -		return 0;
 -
 -	if (WACOM_PEN_FIELD(field))
 -		return wacom_wac_pen_event(hdev, field, usage, value);
 -
 -	if (WACOM_FINGER_FIELD(field))
 -		return wacom_wac_finger_event(hdev, field, usage, value);
 -
 -	return 0;
 -}
 -
 -static void wacom_report_events(struct hid_device *hdev, struct hid_report *report)
 -{
 -	int r;
 -
 -	for (r = 0; r < report->maxfield; r++) {
 -		struct hid_field *field;
 -		unsigned count, n;
 -
 -		field = report->field[r];
 -		count = field->report_count;
 -
 -		if (!(HID_MAIN_ITEM_VARIABLE & field->flags))
 -			continue;
 -
 -		for (n = 0; n < count; n++)
 -			wacom_wac_event(hdev, field, &field->usage[n], field->value[n]);
 -	}
 -}
 -
 -void wacom_wac_report(struct hid_device *hdev, struct hid_report *report)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct hid_field *field = report->field[0];
 -
 -	if (wacom_wac->features.type != HID_GENERIC)
 -		return;
 -
 -	if (WACOM_PEN_FIELD(field))
 -		wacom_wac_pen_pre_report(hdev, report);
 -
 -	if (WACOM_FINGER_FIELD(field))
 -		wacom_wac_finger_pre_report(hdev, report);
 -
 -	wacom_report_events(hdev, report);
 -
 -	if (WACOM_PEN_FIELD(field))
 -		return wacom_wac_pen_report(hdev, report);
 -
 -	if (WACOM_FINGER_FIELD(field))
 -		return wacom_wac_finger_report(hdev, report);
 -}
 -
 -static int wacom_bpt_touch(struct wacom_wac *wacom)
 -{
 -	struct wacom_features *features = &wacom->features;
 -	struct input_dev *input = wacom->touch_input;
 -	struct input_dev *pad_input = wacom->pad_input;
 -	unsigned char *data = wacom->data;
 -	int i;
 -
 -	if (data[0] != 0x02)
 -	    return 0;
 -
 -	for (i = 0; i < 2; i++) {
 -		int offset = (data[1] & 0x80) ? (8 * i) : (9 * i);
 -		bool touch = data[offset + 3] & 0x80;
 -
 -		/*
 -		 * Touch events need to be disabled while stylus is
 -		 * in proximity because user's hand is resting on touchpad
 -		 * and sending unwanted events.  User expects tablet buttons
 -		 * to continue working though.
 -		 */
 -		touch = touch && !wacom->shared->stylus_in_proximity;
 -
 -		input_mt_slot(input, i);
 -		input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
 -		if (touch) {
 -			int x = get_unaligned_be16(&data[offset + 3]) & 0x7ff;
 -			int y = get_unaligned_be16(&data[offset + 5]) & 0x7ff;
 -			if (features->quirks & WACOM_QUIRK_BBTOUCH_LOWRES) {
 -				x <<= 5;
 -				y <<= 5;
 -			}
 -			input_report_abs(input, ABS_MT_POSITION_X, x);
 -			input_report_abs(input, ABS_MT_POSITION_Y, y);
 -		}
 -	}
 -
 -	input_mt_sync_frame(input);
 -
 -	input_report_key(pad_input, BTN_LEFT, (data[1] & 0x08) != 0);
 -	input_report_key(pad_input, BTN_FORWARD, (data[1] & 0x04) != 0);
 -	input_report_key(pad_input, BTN_BACK, (data[1] & 0x02) != 0);
 -	input_report_key(pad_input, BTN_RIGHT, (data[1] & 0x01) != 0);
 -	wacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);
 -
 -	return 1;
 -}
 -
 -static void wacom_bpt3_touch_msg(struct wacom_wac *wacom, unsigned char *data)
 -{
 -	struct wacom_features *features = &wacom->features;
 -	struct input_dev *input = wacom->touch_input;
 -	bool touch = data[1] & 0x80;
 -	int slot = input_mt_get_slot_by_key(input, data[0]);
 -
 -	if (slot < 0)
 -		return;
 -
 -	touch = touch && !wacom->shared->stylus_in_proximity;
 -
 -	input_mt_slot(input, slot);
 -	input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
 -
 -	if (touch) {
 -		int x = (data[2] << 4) | (data[4] >> 4);
 -		int y = (data[3] << 4) | (data[4] & 0x0f);
 -		int width, height;
 +	if (touch) {
 +		int x = (data[2] << 4) | (data[4] >> 4);
 +		int y = (data[3] << 4) | (data[4] & 0x0f);
 +		int width, height;
  
++<<<<<<< HEAD
 +		if (features->type >= INTUOSPS && features->type <= INTUOSPL) {
 +			width  = data[5];
 +			height = data[6];
++=======
+ 		if (features->type >= INTUOSPS && features->type <= INTUOSHT2) {
+ 			width  = data[5] * 100;
+ 			height = data[6] * 100;
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  		} else {
  			/*
  			 * "a" is a scaled-down area which we assume is
@@@ -1183,20 -1924,25 +1192,30 @@@
  
  static void wacom_bpt3_button_msg(struct wacom_wac *wacom, unsigned char *data)
  {
 -	struct input_dev *input = wacom->pad_input;
 -	struct wacom_features *features = &wacom->features;
 +	struct input_dev *input = wacom->input;
  
++<<<<<<< HEAD
 +	input_report_key(input, BTN_LEFT, (data[1] & 0x08) != 0);
++=======
+ 	if (features->type == INTUOSHT || features->type == INTUOSHT2) {
+ 		input_report_key(input, BTN_LEFT, (data[1] & 0x02) != 0);
+ 		input_report_key(input, BTN_BACK, (data[1] & 0x08) != 0);
+ 	} else {
+ 		input_report_key(input, BTN_BACK, (data[1] & 0x02) != 0);
+ 		input_report_key(input, BTN_LEFT, (data[1] & 0x08) != 0);
+ 	}
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  	input_report_key(input, BTN_FORWARD, (data[1] & 0x04) != 0);
 +	input_report_key(input, BTN_BACK, (data[1] & 0x02) != 0);
  	input_report_key(input, BTN_RIGHT, (data[1] & 0x01) != 0);
  }
  
  static int wacom_bpt3_touch(struct wacom_wac *wacom)
  {
 +	struct input_dev *input = wacom->input;
  	unsigned char *data = wacom->data;
  	int count = data[1] & 0x07;
- 	int i;
+ 	int  touch_changed = 0, i;
  
  	if (data[0] != 0x02)
  	    return 0;
@@@ -1212,11 -1959,14 +1232,19 @@@
  			wacom_bpt3_button_msg(wacom, data + offset);
  
  	}
 +	input_mt_sync_frame(input);
  
++<<<<<<< HEAD
 +	input_sync(input);
++=======
+ 	/* only update touch if we actually have a touchpad and touch data changed */
+ 	if (wacom->touch_registered && touch_changed) {
+ 		input_mt_sync_frame(wacom->touch_input);
+ 		wacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);
+ 	}
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  
 -	return 1;
 +	return 0;
  }
  
  static int wacom_bpt_pen(struct wacom_wac *wacom)
@@@ -1311,10 -2153,20 +1345,23 @@@ static int wacom_wireless_irq(struct wa
  
  	connected = data[1] & 0x01;
  	if (connected) {
++<<<<<<< HEAD
 +		int pid, battery;
++=======
+ 		int pid, battery, charging;
+ 
+ 		if ((wacom->shared->type == INTUOSHT ||
+ 		    wacom->shared->type == INTUOSHT2) &&
+ 		    wacom->shared->touch_input &&
+ 		    wacom->shared->touch_max) {
+ 			input_report_switch(wacom->shared->touch_input,
+ 					SW_MUTE_DEVICE, data[5] & 0x40);
+ 			input_sync(wacom->shared->touch_input);
+ 		}
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  
  		pid = get_unaligned_be16(&data[6]);
 -		battery = (data[5] & 0x3f) * 100 / 31;
 -		charging = !!(data[5] & 0x80);
 +		battery = data[5] & 0x3f;
  		if (wacom->pid != pid) {
  			wacom->pid = pid;
  			wacom_schedule_work(wacom);
@@@ -1330,6 -2185,48 +1377,51 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int wacom_status_irq(struct wacom_wac *wacom_wac, size_t len)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	unsigned char *data = wacom_wac->data;
+ 
+ 	if (data[0] != WACOM_REPORT_USB)
+ 		return 0;
+ 
+ 	if ((features->type == INTUOSHT ||
+ 	    features->type == INTUOSHT2) &&
+ 	    wacom_wac->shared->touch_input &&
+ 	    features->touch_max) {
+ 		input_report_switch(wacom_wac->shared->touch_input,
+ 				    SW_MUTE_DEVICE, data[8] & 0x40);
+ 		input_sync(wacom_wac->shared->touch_input);
+ 	}
+ 
+ 	if (data[9] & 0x02) { /* wireless module is attached */
+ 		int battery = (data[8] & 0x3f) * 100 / 31;
+ 		bool charging = !!(data[8] & 0x80);
+ 
+ 		wacom_notify_battery(wacom_wac, battery, charging,
+ 				     battery || charging, 1);
+ 
+ 		if (!wacom->battery &&
+ 		    !(features->quirks & WACOM_QUIRK_BATTERY)) {
+ 			features->quirks |= WACOM_QUIRK_BATTERY;
+ 			INIT_WORK(&wacom->work, wacom_battery_work);
+ 			wacom_schedule_work(wacom_wac);
+ 		}
+ 	}
+ 	else if ((features->quirks & WACOM_QUIRK_BATTERY) &&
+ 		 wacom->battery) {
+ 		features->quirks &= ~WACOM_QUIRK_BATTERY;
+ 		INIT_WORK(&wacom->work, wacom_battery_work);
+ 		wacom_schedule_work(wacom_wac);
+ 		wacom_notify_battery(wacom_wac, 0, 0, 0, 0);
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  void wacom_wac_irq(struct wacom_wac *wacom_wac, size_t len)
  {
  	bool sync;
@@@ -1403,7 -2312,18 +1495,22 @@@
  		break;
  
  	case BAMBOO_PT:
++<<<<<<< HEAD
 +		sync = wacom_bpt_irq(wacom_wac, len);
++=======
+ 	case BAMBOO_PEN:
+ 	case BAMBOO_TOUCH:
+ 	case INTUOSHT:
+ 	case INTUOSHT2:
+ 		if (wacom_wac->data[0] == WACOM_REPORT_USB)
+ 			sync = wacom_status_irq(wacom_wac, len);
+ 		else
+ 			sync = wacom_bpt_irq(wacom_wac, len);
+ 		break;
+ 
+ 	case BAMBOO_PAD:
+ 		sync = wacom_bamboo_pad_irq(wacom_wac, len);
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  		break;
  
  	case WIRELESS:
@@@ -1415,13 -2342,19 +1522,13 @@@
  		break;
  	}
  
 -	if (sync) {
 -		if (wacom_wac->pen_input)
 -			input_sync(wacom_wac->pen_input);
 -		if (wacom_wac->touch_input)
 -			input_sync(wacom_wac->touch_input);
 -		if (wacom_wac->pad_input)
 -			input_sync(wacom_wac->pad_input);
 -	}
 +	if (sync)
 +		input_sync(wacom_wac->input);
  }
  
- static void wacom_setup_cintiq(struct wacom_wac *wacom_wac)
+ static void wacom_setup_basic_pro_pen(struct wacom_wac *wacom_wac)
  {
 -	struct input_dev *input_dev = wacom_wac->pen_input;
 +	struct input_dev *input_dev = wacom_wac->input;
  
  	input_set_capability(input_dev, EV_MSC, MSC_SERIAL);
  
@@@ -1435,9 -2364,24 +1538,22 @@@
  
  	input_set_abs_params(input_dev, ABS_DISTANCE,
  			     0, wacom_wac->features.distance_max, 0, 0);
+ }
+ 
+ static void wacom_setup_cintiq(struct wacom_wac *wacom_wac)
+ {
+ 	struct input_dev *input_dev = wacom_wac->pen_input;
+ 
+ 	wacom_setup_basic_pro_pen(wacom_wac);
+ 
+ 	__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 	__set_bit(BTN_TOOL_BRUSH, input_dev->keybit);
+ 	__set_bit(BTN_TOOL_PENCIL, input_dev->keybit);
+ 	__set_bit(BTN_TOOL_AIRBRUSH, input_dev->keybit);
+ 
  	input_set_abs_params(input_dev, ABS_WHEEL, 0, 1023, 0, 0);
  	input_set_abs_params(input_dev, ABS_TILT_X, -64, 63, 0, 0);
 -	input_abs_set_res(input_dev, ABS_TILT_X, 57);
  	input_set_abs_params(input_dev, ABS_TILT_Y, -64, 63, 0, 0);
 -	input_abs_set_res(input_dev, ABS_TILT_Y, 57);
  }
  
  static void wacom_setup_intuos(struct wacom_wac *wacom_wac)
@@@ -1794,42 -2619,282 +1910,314 @@@ int wacom_setup_input_capabilities(stru
  		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
 -	case INTUOSHT:
  	case BAMBOO_PT:
++<<<<<<< HEAD
 +		__clear_bit(ABS_MISC, input_dev->absbit);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
++=======
+ 	case BAMBOO_PEN:
+ 	case INTUOSHT2:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		if (features->type == INTUOSHT2) {
+ 			wacom_setup_basic_pro_pen(wacom_wac);
+ 		} else {
+ 			__clear_bit(ABS_MISC, input_dev->absbit);
+ 			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 			__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 			__set_bit(BTN_STYLUS, input_dev->keybit);
+ 			__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 				      features->distance_max,
+ 				      0, 0);
+ 		}
+ 		break;
+ 	case BAMBOO_PAD:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 		break;
+ 	}
+ 	return 0;
+ }
 -
 -int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
 -					 struct wacom_wac *wacom_wac)
 -{
 -	struct wacom_features *features = &wacom_wac->features;
 -
 -	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
 -
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
 +
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			unsigned int flags = INPUT_MT_POINTER;
 +
 +			__set_bit(BTN_LEFT, input_dev->keybit);
 +			__set_bit(BTN_FORWARD, input_dev->keybit);
 +			__set_bit(BTN_BACK, input_dev->keybit);
 +			__set_bit(BTN_RIGHT, input_dev->keybit);
 +
++<<<<<<< HEAD
 +			if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MAJOR,
 +						     0, features->x_max, 0, 0);
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MINOR,
 +						     0, features->y_max, 0, 0);
 +			} else {
 +				__set_bit(BTN_TOOL_FINGER, input_dev->keybit);
 +				__set_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);
 +				flags = 0;
 +			}
 +			input_mt_init_slots(input_dev, features->touch_max, flags);
 +		} else if (features->device_type == BTN_TOOL_PEN) {
 +			__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +			__set_bit(BTN_STYLUS, input_dev->keybit);
 +			__set_bit(BTN_STYLUS2, input_dev->keybit);
 +			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 +					      features->distance_max,
 +					      0, 0);
++=======
+ 	if (!(features->device_type & WACOM_DEVICETYPE_TOUCH))
+ 		return -ENODEV;
+ 
+ 	if (features->type == HID_GENERIC)
+ 		/* setup has already been done */
+ 		return 0;
+ 
+ 	__set_bit(BTN_TOUCH, input_dev->keybit);
+ 
+ 	if (features->touch_max == 1) {
+ 		input_set_abs_params(input_dev, ABS_X, 0,
+ 			features->x_max, features->x_fuzz, 0);
+ 		input_set_abs_params(input_dev, ABS_Y, 0,
+ 			features->y_max, features->y_fuzz, 0);
+ 		input_abs_set_res(input_dev, ABS_X,
+ 				  features->x_resolution);
+ 		input_abs_set_res(input_dev, ABS_Y,
+ 				  features->y_resolution);
+ 	}
+ 	else if (features->touch_max > 1) {
+ 		input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+ 			features->x_max, features->x_fuzz, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+ 			features->y_max, features->y_fuzz, 0);
+ 		input_abs_set_res(input_dev, ABS_MT_POSITION_X,
+ 				  features->x_resolution);
+ 		input_abs_set_res(input_dev, ABS_MT_POSITION_Y,
+ 				  features->y_resolution);
+ 	}
+ 
+ 	switch (features->type) {
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, features->y_max, 0, 0);
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		break;
+ 
+ 	case WACOM_24HDT:
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
+ 		/* fall through */
+ 
+ 	case WACOM_27QHDT:
+ 	case MTSCREEN:
+ 	case MTTPC:
+ 	case MTTPC_B:
+ 	case TABLETPC2FG:
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);
+ 		/*fall through */
+ 
+ 	case TABLETPC:
+ 	case TABLETPCE:
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 	case INTUOSHT2:
+ 		input_dev->evbit[0] |= BIT_MASK(EV_SW);
+ 		__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
+ 		/* fall through */
+ 
+ 	case BAMBOO_PT:
+ 	case BAMBOO_TOUCH:
+ 		if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 			input_set_abs_params(input_dev,
+ 				     ABS_MT_TOUCH_MAJOR,
+ 				     0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev,
+ 				     ABS_MT_TOUCH_MINOR,
+ 				     0, features->y_max, 0, 0);
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  		}
 -		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
  		break;
++<<<<<<< HEAD
++=======
+ 
+ 	case BAMBOO_PAD:
+ 		input_mt_init_slots(input_dev, features->touch_max,
+ 				    INPUT_MT_POINTER);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static void wacom_setup_numbered_buttons(struct input_dev *input_dev,
+ 				int button_count)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < button_count && i < 10; i++)
+ 		__set_bit(BTN_0 + i, input_dev->keybit);
+ 	for (i = 10; i < button_count && i < 16; i++)
+ 		__set_bit(BTN_A + (i-10), input_dev->keybit);
+ 	for (i = 16; i < button_count && i < 18; i++)
+ 		__set_bit(BTN_BASE + (i-16), input_dev->keybit);
+ }
+ 
+ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_PAD))
+ 		return -ENODEV;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	/* kept for making legacy xf86-input-wacom working with the wheels */
+ 	__set_bit(ABS_MISC, input_dev->absbit);
+ 
+ 	/* kept for making legacy xf86-input-wacom accepting the pad */
+ 	input_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);
+ 
+ 	/* kept for making udev and libwacom accepting the pad */
+ 	__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 	wacom_setup_numbered_buttons(input_dev, features->numbered_buttons);
+ 
+ 	switch (features->type) {
+ 
+ 	case CINTIQ_HYBRID:
+ 	case DTK:
+ 	case DTUS:
+ 	case GRAPHIRE_BT:
+ 		break;
+ 
+ 	case WACOM_MO:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_G4:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
+ 		break;
+ 
+ 	case WACOM_24HD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_THROTTLE, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_27QHD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_X, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_X, 1024); /* points/g */
+ 		input_set_abs_params(input_dev, ABS_Y, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Y, 1024);
+ 		input_set_abs_params(input_dev, ABS_Z, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 1024);
+ 		__set_bit(INPUT_PROP_ACCELEROMETER, input_dev->propbit);
+ 		break;
+ 
+ 	case WACOM_22HD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case WACOM_21UX2:
+ 	case WACOM_BEE:
+ 	case CINTIQ:
+ 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
+ 		break;
+ 
+ 	case WACOM_13HD:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOS3:
+ 	case INTUOS3L:
+ 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
+ 		/* fall through */
+ 
+ 	case INTUOS3S:
+ 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
+ 		break;
+ 
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOS4WL:
+ 		/*
+ 		 * For Bluetooth devices, the udev rule does not work correctly
+ 		 * for pads unless we add a stylus capability, which forces
+ 		 * ID_INPUT_TABLET to be set.
+ 		 */
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case INTUOS4:
+ 	case INTUOS4L:
+ 	case INTUOS4S:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 	case BAMBOO_PT:
+ 	case BAMBOO_TOUCH:
+ 	case INTUOSHT2:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 
+ 		break;
+ 
+ 	case REMOTE:
+ 		input_set_capability(input_dev, EV_MSC, MSC_SERIAL);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	default:
+ 		/* no pad supported */
+ 		return -ENODEV;
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  	}
  	return 0;
  }
@@@ -2103,136 -3193,216 +2491,189 @@@ static const struct wacom_features waco
  	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x5e };
  static const struct wacom_features wacom_features_0x5E =
  	{ "Wacom Cintiq 22HDT", .type = WACOM_24HDT,
 -	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x5b, .touch_max = 10,
 -	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
 +	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x5b, .touch_max = 10 };
  static const struct wacom_features wacom_features_0x90 =
 -	{ "Wacom ISDv4 90", 26202, 16325, 255, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 90",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  255,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x93 =
 -	{ "Wacom ISDv4 93", 26202, 16325, 255, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 93",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  255,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x97 =
 -	{ "Wacom ISDv4 97", 26202, 16325, 511, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 97",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  511,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x9A =
 -	{ "Wacom ISDv4 9A", 26202, 16325, 255, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 9A",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  255,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x9F =
 -	{ "Wacom ISDv4 9F", 26202, 16325, 255, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 9F",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  255,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xE2 =
 -	{ "Wacom ISDv4 E2", 26202, 16325, 255, 0,
 -	  TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom ISDv4 E2",       WACOM_PKGLEN_TPC2FG,    26202, 16325,  255,
 +	  0, TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xE3 =
 -	{ "Wacom ISDv4 E3", 26202, 16325, 255, 0,
 -	  TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom ISDv4 E3",       WACOM_PKGLEN_TPC2FG,    26202, 16325,  255,
 +	  0, TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xE5 =
 -	{ "Wacom ISDv4 E5", 26202, 16325, 255, 0,
 -	  MTSCREEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 E5",       WACOM_PKGLEN_MTOUCH,    26202, 16325,  255,
 +	  0, MTSCREEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xE6 =
 -	{ "Wacom ISDv4 E6", 27760, 15694, 255, 0,
 -	  TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom ISDv4 E6",       WACOM_PKGLEN_TPC2FG,    27760, 15694,  255,
 +	  0, TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xEC =
 -	{ "Wacom ISDv4 EC", 25710, 14500, 255, 0,
 -	  TABLETPC,    WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 EC",       WACOM_PKGLEN_GRAPHIRE,  25710, 14500,  255,
 +	  0, TABLETPC,    WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xED =
 -	{ "Wacom ISDv4 ED", 26202, 16325, 255, 0,
 -	  TABLETPCE, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 ED",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  255,
 +	  0, TABLETPCE, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xEF =
 -	{ "Wacom ISDv4 EF", 26202, 16325, 255, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 EF",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  255,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x100 =
 -	{ "Wacom ISDv4 100", 26202, 16325, 255, 0,
 -	  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 100",      WACOM_PKGLEN_MTTPC,     26202, 16325,  255,
 +	  0, MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x101 =
 -	{ "Wacom ISDv4 101", 26202, 16325, 255, 0,
 -	  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 101",      WACOM_PKGLEN_MTTPC,     26202, 16325,  255,
 +	  0, MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x10D =
 -	{ "Wacom ISDv4 10D", 26202, 16325, 255, 0,
 -	  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x10E =
 -	{ "Wacom ISDv4 10E", 27760, 15694, 255, 0,
 -	  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x10F =
 -	{ "Wacom ISDv4 10F", 27760, 15694, 255, 0,
 -	  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x116 =
 -	{ "Wacom ISDv4 116", 26202, 16325, 255, 0,
 -	  TABLETPCE, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x12C =
 -	{ "Wacom ISDv4 12C", 27848, 15752, 2047, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 10D",      WACOM_PKGLEN_MTTPC,     26202, 16325,  255,
 +	  0, MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x4001 =
 -	{ "Wacom ISDv4 4001", 26202, 16325, 255, 0,
 -	  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x4004 =
 -	{ "Wacom ISDv4 4004", 11060, 6220, 255, 0,
 -	  MTTPC_B, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x5000 =
 -	{ "Wacom ISDv4 5000", 27848, 15752, 1023, 0,
 -	  MTTPC_B, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x5002 =
 -	{ "Wacom ISDv4 5002", 29576, 16724, 1023, 0,
 -	  MTTPC_B, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 4001",      WACOM_PKGLEN_MTTPC,     26202, 16325,  255,
 +	  0, MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x47 =
 -	{ "Wacom Intuos2 6x8", 20320, 16240, 1023, 31,
 -	  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom Intuos2 6x8",    WACOM_PKGLEN_INTUOS,    20320, 16240, 1023,
 +	  31, INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x84 =
 -	{ "Wacom Wireless Receiver", .type = WIRELESS, .touch_max = 16 };
 +	{ "Wacom Wireless Receiver", WACOM_PKGLEN_WIRELESS, 0, 0, 0,
 +	  0, WIRELESS, 0, 0, .touch_max = 16 };
  static const struct wacom_features wacom_features_0xD0 =
 -	{ "Wacom Bamboo 2FG", 14720, 9200, 1023, 31,
 -	  BAMBOO_TOUCH, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom Bamboo 2FG",     WACOM_PKGLEN_BBFUN,     14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xD1 =
 -	{ "Wacom Bamboo 2FG 4x5", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom Bamboo 2FG 4x5", WACOM_PKGLEN_BBFUN,     14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xD2 =
 -	{ "Wacom Bamboo Craft", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom Bamboo Craft",   WACOM_PKGLEN_BBFUN,     14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xD3 =
 -	{ "Wacom Bamboo 2FG 6x8", 21648, 13700, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom Bamboo 2FG 6x8", WACOM_PKGLEN_BBFUN,     21648, 13700, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xD4 =
 -	{ "Wacom Bamboo Pen", 14720, 9200, 1023, 31,
 -	  BAMBOO_PEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom Bamboo Pen",     WACOM_PKGLEN_BBFUN,     14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xD5 =
 -	{ "Wacom Bamboo Pen 6x8", 21648, 13700, 1023, 31,
 -	  BAMBOO_PEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom Bamboo Pen 6x8",     WACOM_PKGLEN_BBFUN, 21648, 13700, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xD6 =
 -	{ "Wacom BambooPT 2FG 4x5", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom BambooPT 2FG 4x5", WACOM_PKGLEN_BBFUN,   14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xD7 =
 -	{ "Wacom BambooPT 2FG Small", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom BambooPT 2FG Small", WACOM_PKGLEN_BBFUN, 14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xD8 =
 -	{ "Wacom Bamboo Comic 2FG", 21648, 13700, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom Bamboo Comic 2FG", WACOM_PKGLEN_BBFUN,   21648, 13700, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xDA =
 -	{ "Wacom Bamboo 2FG 4x5 SE", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 -static const struct wacom_features wacom_features_0xDB =
 -	{ "Wacom Bamboo 2FG 6x8 SE", 21648, 13700, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom Bamboo 2FG 4x5 SE", WACOM_PKGLEN_BBFUN,  14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
 +static struct wacom_features wacom_features_0xDB =
 +	{ "Wacom Bamboo 2FG 6x8 SE", WACOM_PKGLEN_BBFUN,  21648, 13700, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xDD =
 -        { "Wacom Bamboo Connect", 14720, 9200, 1023, 31,
 -          BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +        { "Wacom Bamboo Connect", WACOM_PKGLEN_BBPEN,     14720,  9200, 1023,
 +          31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xDE =
 -        { "Wacom Bamboo 16FG 4x5", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16 };
 +        { "Wacom Bamboo 16FG 4x5", WACOM_PKGLEN_BBPEN,    14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 16 };
  static const struct wacom_features wacom_features_0xDF =
 -        { "Wacom Bamboo 16FG 6x8", 21648, 13700, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16 };
 -static const struct wacom_features wacom_features_0x300 =
 -	{ "Wacom Bamboo One S", 14720, 9225, 1023, 31,
 -	  BAMBOO_PEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x301 =
 -	{ "Wacom Bamboo One M", 21648, 13530, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x302 =
 -	{ "Wacom Intuos PT S", 15200, 9500, 1023, 31,
 -	  INTUOSHT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16,
 -	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
 -static const struct wacom_features wacom_features_0x303 =
 -	{ "Wacom Intuos PT M", 21600, 13500, 1023, 31,
 -	  INTUOSHT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16,
 -	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
 -static const struct wacom_features wacom_features_0x30E =
 -	{ "Wacom Intuos S", 15200, 9500, 1023, 31,
 -	  INTUOSHT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 -	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
 +        { "Wacom Bamboo 16FG 6x8", WACOM_PKGLEN_BBPEN,    21648, 13700, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 16 };
  static const struct wacom_features wacom_features_0x6004 =
++<<<<<<< HEAD
 +	{ "ISD-V4",               WACOM_PKGLEN_GRAPHIRE,  12800,  8000,  255,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
++=======
+ 	{ "ISD-V4", 12800, 8000, 255, 0,
+ 	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
+ static const struct wacom_features wacom_features_0x307 =
+ 	{ "Wacom ISDv5 307", 59152, 33448, 2047, 63,
+ 	  CINTIQ_HYBRID, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9,
+ 	  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,
+ 	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x309 };
+ static const struct wacom_features wacom_features_0x309 =
+ 	{ "Wacom ISDv5 309", .type = WACOM_24HDT, /* Touch */
+ 	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x0307, .touch_max = 10,
+ 	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
+ static const struct wacom_features wacom_features_0x30A =
+ 	{ "Wacom ISDv5 30A", 59152, 33448, 2047, 63,
+ 	  CINTIQ_HYBRID, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9,
+ 	  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,
+ 	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x30C };
+ static const struct wacom_features wacom_features_0x30C =
+ 	{ "Wacom ISDv5 30C", .type = WACOM_24HDT, /* Touch */
+ 	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x30A, .touch_max = 10,
+ 	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
+ static const struct wacom_features wacom_features_0x318 =
+ 	{ "Wacom USB Bamboo PAD", 4095, 4095, /* Touch */
+ 	  .type = BAMBOO_PAD, 35, 48, .touch_max = 4 };
+ static const struct wacom_features wacom_features_0x319 =
+ 	{ "Wacom Wireless Bamboo PAD", 4095, 4095, /* Touch */
+ 	  .type = BAMBOO_PAD, 35, 48, .touch_max = 4 };
+ static const struct wacom_features wacom_features_0x323 =
+ 	{ "Wacom Intuos P M", 21600, 13500, 1023, 31,
+ 	  INTUOSHT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
+ 	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
+ static const struct wacom_features wacom_features_0x331 =
+ 	{ "Wacom Express Key Remote", .type = REMOTE,
+ 	  .numbered_buttons = 18, .check_for_hid_type = true,
+ 	  .hid_type = HID_TYPE_USBNONE };
+ static const struct wacom_features wacom_features_0x33B =
+ 	{ "Wacom Intuos S 2", 15200, 9500, 2047, 63,
+ 	  INTUOSHT2, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
+ 	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
+ static const struct wacom_features wacom_features_0x33C =
+ 	{ "Wacom Intuos PT S 2", 15200, 9500, 2047, 63,
+ 	  INTUOSHT2, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16,
+ 	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
+ static const struct wacom_features wacom_features_0x33D =
+ 	{ "Wacom Intuos P M 2", 21600, 13500, 2047, 63,
+ 	  INTUOSHT2, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
+ 	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
+ static const struct wacom_features wacom_features_0x33E =
+ 	{ "Wacom Intuos PT M 2", 21600, 13500, 2047, 63,
+ 	  INTUOSHT2, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16,
+ 	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  
 -static const struct wacom_features wacom_features_HID_ANY_ID =
 -	{ "Wacom HID", .type = HID_GENERIC };
 -
 -#define USB_DEVICE_WACOM(prod)						\
 -	HID_DEVICE(BUS_USB, HID_GROUP_WACOM, USB_VENDOR_ID_WACOM, prod),\
 -	.driver_data = (kernel_ulong_t)&wacom_features_##prod
 +#define USB_DEVICE_WACOM(prod)					\
 +	USB_DEVICE(USB_VENDOR_ID_WACOM, prod),			\
 +	.driver_info = (kernel_ulong_t)&wacom_features_##prod
  
 -#define BT_DEVICE_WACOM(prod)						\
 -	HID_DEVICE(BUS_BLUETOOTH, HID_GROUP_WACOM, USB_VENDOR_ID_WACOM, prod),\
 -	.driver_data = (kernel_ulong_t)&wacom_features_##prod
 -
 -#define I2C_DEVICE_WACOM(prod)						\
 -	HID_DEVICE(BUS_I2C, HID_GROUP_WACOM, USB_VENDOR_ID_WACOM, prod),\
 -	.driver_data = (kernel_ulong_t)&wacom_features_##prod
 +#define USB_DEVICE_DETAILED(prod, class, sub, proto)			\
 +	USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_WACOM, prod, class,	\
 +				      sub, proto),			\
 +	.driver_info = (kernel_ulong_t)&wacom_features_##prod
  
  #define USB_DEVICE_LENOVO(prod)					\
 -	HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, prod),			\
 -	.driver_data = (kernel_ulong_t)&wacom_features_##prod
 +	USB_DEVICE(USB_VENDOR_ID_LENOVO, prod),			\
 +	.driver_info = (kernel_ulong_t)&wacom_features_##prod
  
 -const struct hid_device_id wacom_ids[] = {
 +const struct usb_device_id wacom_ids[] = {
  	{ USB_DEVICE_WACOM(0x00) },
 -	{ USB_DEVICE_WACOM(0x03) },
  	{ USB_DEVICE_WACOM(0x10) },
  	{ USB_DEVICE_WACOM(0x11) },
  	{ USB_DEVICE_WACOM(0x12) },
@@@ -2347,13 -3534,23 +2788,25 @@@
  	{ USB_DEVICE_WACOM(0x32A) },
  	{ USB_DEVICE_WACOM(0x32B) },
  	{ USB_DEVICE_WACOM(0x32C) },
++<<<<<<< HEAD
++=======
+ 	{ USB_DEVICE_WACOM(0x32F) },
+ 	{ USB_DEVICE_WACOM(0x331) },
+ 	{ USB_DEVICE_WACOM(0x333) },
+ 	{ USB_DEVICE_WACOM(0x335) },
+ 	{ USB_DEVICE_WACOM(0x336) },
+ 	{ USB_DEVICE_WACOM(0x33B) },
+ 	{ USB_DEVICE_WACOM(0x33C) },
+ 	{ USB_DEVICE_WACOM(0x33D) },
+ 	{ USB_DEVICE_WACOM(0x33E) },
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  	{ USB_DEVICE_WACOM(0x4001) },
 -	{ USB_DEVICE_WACOM(0x4004) },
 -	{ USB_DEVICE_WACOM(0x5000) },
 -	{ USB_DEVICE_WACOM(0x5002) },
 +	{ USB_DEVICE_WACOM(0x47) },
 +	{ USB_DEVICE_WACOM(0xF4) },
 +	{ USB_DEVICE_WACOM(0xF8) },
 +	{ USB_DEVICE_DETAILED(0xF6, USB_CLASS_HID, 0, 0) },
 +	{ USB_DEVICE_WACOM(0xFA) },
  	{ USB_DEVICE_LENOVO(0x6004) },
 -
 -	{ USB_DEVICE_WACOM(HID_ANY_ID) },
 -	{ I2C_DEVICE_WACOM(HID_ANY_ID) },
  	{ }
  };
 -MODULE_DEVICE_TABLE(hid, wacom_ids);
 +MODULE_DEVICE_TABLE(usb, wacom_ids);
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,1a30e4407a46..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -53,16 -54,45 +53,26 @@@
  #define WACOM_REPORT_TPC1FG		6
  #define WACOM_REPORT_TPC2FG		13
  #define WACOM_REPORT_TPCMT		13
 -#define WACOM_REPORT_TPCMT2		3
  #define WACOM_REPORT_TPCHID		15
 -#define WACOM_REPORT_CINTIQ		16
 -#define WACOM_REPORT_CINTIQPAD		17
  #define WACOM_REPORT_TPCST		16
 -#define WACOM_REPORT_DTUS		17
  #define WACOM_REPORT_TPC1FGE		18
  #define WACOM_REPORT_24HDT		1
++<<<<<<< HEAD
++=======
+ #define WACOM_REPORT_WL			128
+ #define WACOM_REPORT_USB		192
+ #define WACOM_REPORT_BPAD_PEN		3
+ #define WACOM_REPORT_BPAD_TOUCH		16
+ #define WACOM_REPORT_DEVICE_LIST	16
+ #define WACOM_REPORT_INTUOS_PEN		16
+ #define WACOM_REPORT_REMOTE		17
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  
  /* device quirks */
 -#define WACOM_QUIRK_BBTOUCH_LOWRES	0x0001
 -#define WACOM_QUIRK_BATTERY		0x0008
 -
 -/* device types */
 -#define WACOM_DEVICETYPE_NONE           0x0000
 -#define WACOM_DEVICETYPE_PEN            0x0001
 -#define WACOM_DEVICETYPE_TOUCH          0x0002
 -#define WACOM_DEVICETYPE_PAD            0x0004
 -#define WACOM_DEVICETYPE_WL_MONITOR     0x0008
 -
 -#define WACOM_VENDORDEFINED_PEN		0xff0d0001
 -
 -#define WACOM_PEN_FIELD(f)	(((f)->logical == HID_DG_STYLUS) || \
 -				 ((f)->physical == HID_DG_STYLUS) || \
 -				 ((f)->physical == HID_DG_PEN) || \
 -				 ((f)->application == HID_DG_PEN) || \
 -				 ((f)->application == HID_DG_DIGITIZER) || \
 -				 ((f)->application == WACOM_VENDORDEFINED_PEN))
 -#define WACOM_FINGER_FIELD(f)	(((f)->logical == HID_DG_FINGER) || \
 -				 ((f)->physical == HID_DG_FINGER) || \
 -				 ((f)->application == HID_DG_TOUCHSCREEN))
 +#define WACOM_QUIRK_MULTI_INPUT		0x0001
 +#define WACOM_QUIRK_BBTOUCH_LOWRES	0x0002
 +#define WACOM_QUIRK_NO_INPUT		0x0004
 +#define WACOM_QUIRK_MONITOR		0x0008
  
  enum {
  	PENPARTNER = 0,
@@@ -94,6 -129,10 +104,13 @@@
  	WACOM_13HD,
  	WACOM_MO,
  	WIRELESS,
++<<<<<<< HEAD
++=======
+ 	BAMBOO_PEN,
+ 	INTUOSHT,
+ 	INTUOSHT2,
+ 	BAMBOO_TOUCH,
++>>>>>>> eda01dab53b1 (HID: wacom: Add four new Intuos devices)
  	BAMBOO_PT,
  	WACOM_24HDT,
  	WACOM_27QHDT,
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
* Unmerged path drivers/hid/wacom_wac.h
