6lowpan: add 802.15.4 short addr slaac

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alexander Aring <aar@pengutronix.de>
commit 2ad3ed59198c5404c34515cfcfd9a2b3c54d964f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2ad3ed59.failed

This patch adds the autoconfiguration if a valid 802.15.4 short address
is available for 802.15.4 6LoWPAN interfaces.

	Cc: David S. Miller <davem@davemloft.net>
	Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
	Cc: James Morris <jmorris@namei.org>
	Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
	Cc: Patrick McHardy <kaber@trash.net>
	Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
	Signed-off-by: Alexander Aring <aar@pengutronix.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2ad3ed59198c5404c34515cfcfd9a2b3c54d964f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/addrconf.c
diff --cc net/ipv6/addrconf.c
index ee6298c84794,1ce4048d1b5e..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -2776,10 -2947,11 +2776,15 @@@ static void init_loopback(struct net_de
  	}
  }
  
++<<<<<<< HEAD
 +static void addrconf_add_linklocal(struct inet6_dev *idev, const struct in6_addr *addr)
++=======
+ void addrconf_add_linklocal(struct inet6_dev *idev,
+ 			    const struct in6_addr *addr, u32 flags)
++>>>>>>> 2ad3ed59198c (6lowpan: add 802.15.4 short addr slaac)
  {
  	struct inet6_ifaddr *ifp;
 -	u32 addr_flags = flags | IFA_F_PERMANENT;
 +	u32 addr_flags = IFA_F_PERMANENT;
  
  #ifdef CONFIG_IPV6_OPTIMISTIC_DAD
  	if (idev->cnf.optimistic_dad &&
@@@ -2796,13 -2967,119 +2801,14 @@@
  		in6_ifa_put(ifp);
  	}
  }
+ EXPORT_SYMBOL_GPL(addrconf_add_linklocal);
  
 -static bool ipv6_reserved_interfaceid(struct in6_addr address)
 -{
 -	if ((address.s6_addr32[2] | address.s6_addr32[3]) == 0)
 -		return true;
 -
 -	if (address.s6_addr32[2] == htonl(0x02005eff) &&
 -	    ((address.s6_addr32[3] & htonl(0xfe000000)) == htonl(0xfe000000)))
 -		return true;
 -
 -	if (address.s6_addr32[2] == htonl(0xfdffffff) &&
 -	    ((address.s6_addr32[3] & htonl(0xffffff80)) == htonl(0xffffff80)))
 -		return true;
 -
 -	return false;
 -}
 -
 -static int ipv6_generate_stable_address(struct in6_addr *address,
 -					u8 dad_count,
 -					const struct inet6_dev *idev)
 -{
 -	static DEFINE_SPINLOCK(lock);
 -	static __u32 digest[SHA_DIGEST_WORDS];
 -	static __u32 workspace[SHA_WORKSPACE_WORDS];
 -
 -	static union {
 -		char __data[SHA_MESSAGE_BYTES];
 -		struct {
 -			struct in6_addr secret;
 -			__be32 prefix[2];
 -			unsigned char hwaddr[MAX_ADDR_LEN];
 -			u8 dad_count;
 -		} __packed;
 -	} data;
 -
 -	struct in6_addr secret;
 -	struct in6_addr temp;
 -	struct net *net = dev_net(idev->dev);
 -
 -	BUILD_BUG_ON(sizeof(data.__data) != sizeof(data));
 -
 -	if (idev->cnf.stable_secret.initialized)
 -		secret = idev->cnf.stable_secret.secret;
 -	else if (net->ipv6.devconf_dflt->stable_secret.initialized)
 -		secret = net->ipv6.devconf_dflt->stable_secret.secret;
 -	else
 -		return -1;
 -
 -retry:
 -	spin_lock_bh(&lock);
 -
 -	sha_init(digest);
 -	memset(&data, 0, sizeof(data));
 -	memset(workspace, 0, sizeof(workspace));
 -	memcpy(data.hwaddr, idev->dev->perm_addr, idev->dev->addr_len);
 -	data.prefix[0] = address->s6_addr32[0];
 -	data.prefix[1] = address->s6_addr32[1];
 -	data.secret = secret;
 -	data.dad_count = dad_count;
 -
 -	sha_transform(digest, data.__data, workspace);
 -
 -	temp = *address;
 -	temp.s6_addr32[2] = (__force __be32)digest[0];
 -	temp.s6_addr32[3] = (__force __be32)digest[1];
 -
 -	spin_unlock_bh(&lock);
 -
 -	if (ipv6_reserved_interfaceid(temp)) {
 -		dad_count++;
 -		if (dad_count > dev_net(idev->dev)->ipv6.sysctl.idgen_retries)
 -			return -1;
 -		goto retry;
 -	}
 -
 -	*address = temp;
 -	return 0;
 -}
 -
 -static void ipv6_gen_mode_random_init(struct inet6_dev *idev)
 -{
 -	struct ipv6_stable_secret *s = &idev->cnf.stable_secret;
 -
 -	if (s->initialized)
 -		return;
 -	s = &idev->cnf.stable_secret;
 -	get_random_bytes(&s->secret, sizeof(s->secret));
 -	s->initialized = true;
 -}
 -
  static void addrconf_addr_gen(struct inet6_dev *idev, bool prefix_route)
  {
 -	struct in6_addr addr;
 -
 -	/* no link local addresses on L3 master devices */
 -	if (netif_is_l3_master(idev->dev))
 -		return;
 -
 -	ipv6_addr_set(&addr, htonl(0xFE800000), 0, 0, 0);
 +	if (idev->addr_gen_mode == IN6_ADDR_GEN_MODE_EUI64) {
 +		struct in6_addr addr;
  
 -	switch (idev->addr_gen_mode) {
 -	case IN6_ADDR_GEN_MODE_RANDOM:
 -		ipv6_gen_mode_random_init(idev);
 -		/* fallthrough */
 -	case IN6_ADDR_GEN_MODE_STABLE_PRIVACY:
 -		if (!ipv6_generate_stable_address(&addr, 0, idev))
 -			addrconf_add_linklocal(idev, &addr,
 -					       IFA_F_STABLE_PRIVACY);
 -		else if (prefix_route)
 -			addrconf_prefix_route(&addr, 64, idev->dev, 0, 0);
 -		break;
 -	case IN6_ADDR_GEN_MODE_EUI64:
 +		ipv6_addr_set(&addr,  htonl(0xFE800000), 0, 0, 0);
  		/* addrconf_add_linklocal also adds a prefix_route and we
  		 * only need to care about prefix routes if ipv6_generate_eui64
  		 * couldn't generate one.
diff --git a/include/net/6lowpan.h b/include/net/6lowpan.h
index af2deb98d4a2..edc7a22993ed 100644
--- a/include/net/6lowpan.h
+++ b/include/net/6lowpan.h
@@ -216,6 +216,12 @@ static inline bool lowpan_fetch_skb(struct sk_buff *skb, void *data,
 	return false;
 }
 
+static inline bool lowpan_802154_is_valid_src_short_addr(__le16 addr)
+{
+	/* First bit of addr is multicast, reserved or 802.15.4 specific */
+	return !(addr & cpu_to_le16(0x8000));
+}
+
 static inline void lowpan_push_hc_data(u8 **hc_ptr, const void *data,
 				       const size_t len)
 {
diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index b9f981413f76..2307ca364d9a 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -87,6 +87,9 @@ int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2);
 void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);
 void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);
 
+void addrconf_add_linklocal(struct inet6_dev *idev,
+			    const struct in6_addr *addr, u32 flags);
+
 static inline int addrconf_ifid_eui48(u8 *eui, struct net_device *dev)
 {
 	if (dev->addr_len != ETH_ALEN)
diff --git a/net/6lowpan/core.c b/net/6lowpan/core.c
index f7fbf06f4fc8..59d65f8bcdd4 100644
--- a/net/6lowpan/core.c
+++ b/net/6lowpan/core.c
@@ -14,6 +14,7 @@
 #include <linux/module.h>
 
 #include <net/6lowpan.h>
+#include <net/addrconf.h>
 
 #include "6lowpan_i.h"
 
@@ -72,16 +73,61 @@ void lowpan_unregister_netdev(struct net_device *dev)
 }
 EXPORT_SYMBOL(lowpan_unregister_netdev);
 
+static int addrconf_ifid_802154_6lowpan(u8 *eui, struct net_device *dev)
+{
+	struct wpan_dev *wpan_dev = lowpan_802154_dev(dev)->wdev->ieee802154_ptr;
+
+	/* Set short_addr autoconfiguration if short_addr is present only */
+	if (!lowpan_802154_is_valid_src_short_addr(wpan_dev->short_addr))
+		return -1;
+
+	/* For either address format, all zero addresses MUST NOT be used */
+	if (wpan_dev->pan_id == cpu_to_le16(0x0000) &&
+	    wpan_dev->short_addr == cpu_to_le16(0x0000))
+		return -1;
+
+	/* Alternatively, if no PAN ID is known, 16 zero bits may be used */
+	if (wpan_dev->pan_id == cpu_to_le16(IEEE802154_PAN_ID_BROADCAST))
+		memset(eui, 0, 2);
+	else
+		ieee802154_le16_to_be16(eui, &wpan_dev->pan_id);
+
+	/* The "Universal/Local" (U/L) bit shall be set to zero */
+	eui[0] &= ~2;
+	eui[2] = 0;
+	eui[3] = 0xFF;
+	eui[4] = 0xFE;
+	eui[5] = 0;
+	ieee802154_le16_to_be16(&eui[6], &wpan_dev->short_addr);
+	return 0;
+}
+
 static int lowpan_event(struct notifier_block *unused,
 			unsigned long event, void *ptr)
 {
 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+	struct inet6_dev *idev;
+	struct in6_addr addr;
 	int i;
 
 	if (dev->type != ARPHRD_6LOWPAN)
 		return NOTIFY_DONE;
 
+	idev = __in6_dev_get(dev);
+	if (!idev)
+		return NOTIFY_DONE;
+
 	switch (event) {
+	case NETDEV_UP:
+	case NETDEV_CHANGE:
+		/* (802.15.4 6LoWPAN short address slaac handling */
+		if (lowpan_is_ll(dev, LOWPAN_LLTYPE_IEEE802154) &&
+		    addrconf_ifid_802154_6lowpan(addr.s6_addr + 8, dev) == 0) {
+			__ipv6_addr_set_half(&addr.s6_addr32[0],
+					     htonl(0xFE800000), 0);
+			addrconf_add_linklocal(idev, &addr, 0);
+		}
+		break;
 	case NETDEV_DOWN:
 		for (i = 0; i < LOWPAN_IPHC_CTX_TABLE_SIZE; i++)
 			clear_bit(LOWPAN_IPHC_CTX_FLAG_ACTIVE,
* Unmerged path net/ipv6/addrconf.c
