userfaultfd: non-cooperative: rename *EVENT_MADVDONTNEED to *EVENT_REMOVE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mike Rapoport <rppt@linux.vnet.ibm.com>
commit d811914d87576c562e849c00d9f9beff45038801
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d811914d.failed

Patch series "userfaultfd: non-cooperative: add madvise() event for
MADV_REMOVE request".

These patches add notification of madvise(MADV_REMOVE) event to
non-cooperative userfaultfd monitor.

The first pacth renames EVENT_MADVDONTNEED to EVENT_REMOVE along with
relevant functions and structures.  Using _REMOVE instead of
_MADVDONTNEED describes the event semantics more clearly and I hope it's
not too late for such change in the ABI.

This patch (of 3):

The UFFD_EVENT_MADVDONTNEED purpose is to notify uffd monitor about
removal of certain range from address space tracked by userfaultfd.
Hence, UFFD_EVENT_REMOVE seems to better reflect the operation
semantics.  Respectively, 'madv_dn' field of uffd_msg is renamed to
'remove' and the madvise_userfault_dontneed callback is renamed to
userfaultfd_remove.

Link: http://lkml.kernel.org/r/1484814154-1557-2-git-send-email-rppt@linux.vnet.ibm.com
	Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Reviewed-by: Andrea Arcangeli <aarcange@redhat.com>
	Acked-by: Hillf Danton <hillf.zj@alibaba-inc.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d811914d87576c562e849c00d9f9beff45038801)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/userfaultfd.c
#	include/linux/userfaultfd_k.h
#	include/uapi/linux/userfaultfd.h
#	mm/madvise.c
#	tools/testing/selftests/vm/userfaultfd.c
diff --cc fs/userfaultfd.c
index 0eadec862028,8fe601b4875e..000000000000
--- a/fs/userfaultfd.c
+++ b/fs/userfaultfd.c
@@@ -517,6 -571,144 +517,147 @@@ static void userfaultfd_event_complete(
  	__remove_wait_queue(&ctx->event_wqh, &ewq->wq);
  }
  
++<<<<<<< HEAD
++=======
+ int dup_userfaultfd(struct vm_area_struct *vma, struct list_head *fcs)
+ {
+ 	struct userfaultfd_ctx *ctx = NULL, *octx;
+ 	struct userfaultfd_fork_ctx *fctx;
+ 
+ 	octx = vma->vm_userfaultfd_ctx.ctx;
+ 	if (!octx || !(octx->features & UFFD_FEATURE_EVENT_FORK)) {
+ 		vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;
+ 		vma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);
+ 		return 0;
+ 	}
+ 
+ 	list_for_each_entry(fctx, fcs, list)
+ 		if (fctx->orig == octx) {
+ 			ctx = fctx->new;
+ 			break;
+ 		}
+ 
+ 	if (!ctx) {
+ 		fctx = kmalloc(sizeof(*fctx), GFP_KERNEL);
+ 		if (!fctx)
+ 			return -ENOMEM;
+ 
+ 		ctx = kmem_cache_alloc(userfaultfd_ctx_cachep, GFP_KERNEL);
+ 		if (!ctx) {
+ 			kfree(fctx);
+ 			return -ENOMEM;
+ 		}
+ 
+ 		atomic_set(&ctx->refcount, 1);
+ 		ctx->flags = octx->flags;
+ 		ctx->state = UFFD_STATE_RUNNING;
+ 		ctx->features = octx->features;
+ 		ctx->released = false;
+ 		ctx->mm = vma->vm_mm;
+ 		atomic_inc(&ctx->mm->mm_count);
+ 
+ 		userfaultfd_ctx_get(octx);
+ 		fctx->orig = octx;
+ 		fctx->new = ctx;
+ 		list_add_tail(&fctx->list, fcs);
+ 	}
+ 
+ 	vma->vm_userfaultfd_ctx.ctx = ctx;
+ 	return 0;
+ }
+ 
+ static int dup_fctx(struct userfaultfd_fork_ctx *fctx)
+ {
+ 	struct userfaultfd_ctx *ctx = fctx->orig;
+ 	struct userfaultfd_wait_queue ewq;
+ 
+ 	msg_init(&ewq.msg);
+ 
+ 	ewq.msg.event = UFFD_EVENT_FORK;
+ 	ewq.msg.arg.reserved.reserved1 = (unsigned long)fctx->new;
+ 
+ 	return userfaultfd_event_wait_completion(ctx, &ewq);
+ }
+ 
+ void dup_userfaultfd_complete(struct list_head *fcs)
+ {
+ 	int ret = 0;
+ 	struct userfaultfd_fork_ctx *fctx, *n;
+ 
+ 	list_for_each_entry_safe(fctx, n, fcs, list) {
+ 		if (!ret)
+ 			ret = dup_fctx(fctx);
+ 		list_del(&fctx->list);
+ 		kfree(fctx);
+ 	}
+ }
+ 
+ void mremap_userfaultfd_prep(struct vm_area_struct *vma,
+ 			     struct vm_userfaultfd_ctx *vm_ctx)
+ {
+ 	struct userfaultfd_ctx *ctx;
+ 
+ 	ctx = vma->vm_userfaultfd_ctx.ctx;
+ 	if (ctx && (ctx->features & UFFD_FEATURE_EVENT_REMAP)) {
+ 		vm_ctx->ctx = ctx;
+ 		userfaultfd_ctx_get(ctx);
+ 	}
+ }
+ 
+ void mremap_userfaultfd_complete(struct vm_userfaultfd_ctx *vm_ctx,
+ 				 unsigned long from, unsigned long to,
+ 				 unsigned long len)
+ {
+ 	struct userfaultfd_ctx *ctx = vm_ctx->ctx;
+ 	struct userfaultfd_wait_queue ewq;
+ 
+ 	if (!ctx)
+ 		return;
+ 
+ 	if (to & ~PAGE_MASK) {
+ 		userfaultfd_ctx_put(ctx);
+ 		return;
+ 	}
+ 
+ 	msg_init(&ewq.msg);
+ 
+ 	ewq.msg.event = UFFD_EVENT_REMAP;
+ 	ewq.msg.arg.remap.from = from;
+ 	ewq.msg.arg.remap.to = to;
+ 	ewq.msg.arg.remap.len = len;
+ 
+ 	userfaultfd_event_wait_completion(ctx, &ewq);
+ }
+ 
+ void userfaultfd_remove(struct vm_area_struct *vma,
+ 			struct vm_area_struct **prev,
+ 			unsigned long start, unsigned long end)
+ {
+ 	struct mm_struct *mm = vma->vm_mm;
+ 	struct userfaultfd_ctx *ctx;
+ 	struct userfaultfd_wait_queue ewq;
+ 
+ 	ctx = vma->vm_userfaultfd_ctx.ctx;
+ 	if (!ctx || !(ctx->features & UFFD_FEATURE_EVENT_REMOVE))
+ 		return;
+ 
+ 	userfaultfd_ctx_get(ctx);
+ 	up_read(&mm->mmap_sem);
+ 
+ 	*prev = NULL; /* We wait for ACK w/o the mmap semaphore */
+ 
+ 	msg_init(&ewq.msg);
+ 
+ 	ewq.msg.event = UFFD_EVENT_REMOVE;
+ 	ewq.msg.arg.remove.start = start;
+ 	ewq.msg.arg.remove.end = end;
+ 
+ 	userfaultfd_event_wait_completion(ctx, &ewq);
+ 
+ 	down_read(&mm->mmap_sem);
+ }
+ 
++>>>>>>> d811914d8757 (userfaultfd: non-cooperative: rename *EVENT_MADVDONTNEED to *EVENT_REMOVE)
  static int userfaultfd_release(struct inode *inode, struct file *file)
  {
  	struct userfaultfd_ctx *ctx = file->private_data;
diff --cc include/linux/userfaultfd_k.h
index 587480ad41b7,2521542f6c07..000000000000
--- a/include/linux/userfaultfd_k.h
+++ b/include/linux/userfaultfd_k.h
@@@ -53,6 -52,20 +53,23 @@@ static inline bool userfaultfd_armed(st
  	return vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP);
  }
  
++<<<<<<< HEAD
++=======
+ extern int dup_userfaultfd(struct vm_area_struct *, struct list_head *);
+ extern void dup_userfaultfd_complete(struct list_head *);
+ 
+ extern void mremap_userfaultfd_prep(struct vm_area_struct *,
+ 				    struct vm_userfaultfd_ctx *);
+ extern void mremap_userfaultfd_complete(struct vm_userfaultfd_ctx *,
+ 					unsigned long from, unsigned long to,
+ 					unsigned long len);
+ 
+ extern void userfaultfd_remove(struct vm_area_struct *vma,
+ 			       struct vm_area_struct **prev,
+ 			       unsigned long start,
+ 			       unsigned long end);
+ 
++>>>>>>> d811914d8757 (userfaultfd: non-cooperative: rename *EVENT_MADVDONTNEED to *EVENT_REMOVE)
  #else /* CONFIG_USERFAULTFD */
  
  /* mm helpers */
@@@ -80,6 -90,34 +97,37 @@@ static inline bool userfaultfd_armed(st
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int dup_userfaultfd(struct vm_area_struct *vma,
+ 				  struct list_head *l)
+ {
+ 	return 0;
+ }
+ 
+ static inline void dup_userfaultfd_complete(struct list_head *l)
+ {
+ }
+ 
+ static inline void mremap_userfaultfd_prep(struct vm_area_struct *vma,
+ 					   struct vm_userfaultfd_ctx *ctx)
+ {
+ }
+ 
+ static inline void mremap_userfaultfd_complete(struct vm_userfaultfd_ctx *ctx,
+ 					       unsigned long from,
+ 					       unsigned long to,
+ 					       unsigned long len)
+ {
+ }
+ 
+ static inline void userfaultfd_remove(struct vm_area_struct *vma,
+ 				      struct vm_area_struct **prev,
+ 				      unsigned long start,
+ 				      unsigned long end)
+ {
+ }
++>>>>>>> d811914d8757 (userfaultfd: non-cooperative: rename *EVENT_MADVDONTNEED to *EVENT_REMOVE)
  #endif /* CONFIG_USERFAULTFD */
  
  #endif /* _LINUX_USERFAULTFD_K_H */
diff --cc include/uapi/linux/userfaultfd.h
index abfce32281cc,b742c40c2880..000000000000
--- a/include/uapi/linux/userfaultfd.h
+++ b/include/uapi/linux/userfaultfd.h
@@@ -18,12 -18,11 +18,20 @@@
   * means the userland is reading).
   */
  #define UFFD_API ((__u64)0xAA)
++<<<<<<< HEAD
 +/*
 + * After implementing the respective features it will become:
 + * #define UFFD_API_FEATURES (UFFD_FEATURE_PAGEFAULT_FLAG_WP | \
 + *			      UFFD_FEATURE_EVENT_FORK)
 + */
 +#define UFFD_API_FEATURES (0)
++=======
+ #define UFFD_API_FEATURES (UFFD_FEATURE_EVENT_FORK |		\
+ 			   UFFD_FEATURE_EVENT_REMAP |		\
+ 			   UFFD_FEATURE_EVENT_REMOVE |	\
+ 			   UFFD_FEATURE_MISSING_HUGETLBFS |	\
+ 			   UFFD_FEATURE_MISSING_SHMEM)
++>>>>>>> d811914d8757 (userfaultfd: non-cooperative: rename *EVENT_MADVDONTNEED to *EVENT_REMOVE)
  #define UFFD_API_IOCTLS				\
  	((__u64)1 << _UFFDIO_REGISTER |		\
  	 (__u64)1 << _UFFDIO_UNREGISTER |	\
@@@ -81,6 -80,21 +89,24 @@@ struct uffd_msg 
  		} pagefault;
  
  		struct {
++<<<<<<< HEAD
++=======
+ 			__u32	ufd;
+ 		} fork;
+ 
+ 		struct {
+ 			__u64	from;
+ 			__u64	to;
+ 			__u64	len;
+ 		} remap;
+ 
+ 		struct {
+ 			__u64	start;
+ 			__u64	end;
+ 		} remove;
+ 
+ 		struct {
++>>>>>>> d811914d8757 (userfaultfd: non-cooperative: rename *EVENT_MADVDONTNEED to *EVENT_REMOVE)
  			/* unused reserved fields */
  			__u64	reserved1;
  			__u64	reserved2;
@@@ -93,9 -107,9 +119,14 @@@
   * Start at 0x12 and not at 0 to be more strict against bugs.
   */
  #define UFFD_EVENT_PAGEFAULT	0x12
 +#if 0 /* not available yet */
  #define UFFD_EVENT_FORK		0x13
++<<<<<<< HEAD
 +#endif
++=======
+ #define UFFD_EVENT_REMAP	0x14
+ #define UFFD_EVENT_REMOVE	0x15
++>>>>>>> d811914d8757 (userfaultfd: non-cooperative: rename *EVENT_MADVDONTNEED to *EVENT_REMOVE)
  
  /* flags for UFFD_EVENT_PAGEFAULT */
  #define UFFD_PAGEFAULT_FLAG_WRITE	(1<<0)	/* If this was a write fault */
@@@ -113,11 -127,37 +144,18 @@@ struct uffdio_api 
  	 * Note: UFFD_EVENT_PAGEFAULT and UFFD_PAGEFAULT_FLAG_WRITE
  	 * are to be considered implicitly always enabled in all kernels as
  	 * long as the uffdio_api.api requested matches UFFD_API.
 -	 *
 -	 * UFFD_FEATURE_MISSING_HUGETLBFS means an UFFDIO_REGISTER
 -	 * with UFFDIO_REGISTER_MODE_MISSING mode will succeed on
 -	 * hugetlbfs virtual memory ranges. Adding or not adding
 -	 * UFFD_FEATURE_MISSING_HUGETLBFS to uffdio_api.features has
 -	 * no real functional effect after UFFDIO_API returns, but
 -	 * it's only useful for an initial feature set probe at
 -	 * UFFDIO_API time. There are two ways to use it:
 -	 *
 -	 * 1) by adding UFFD_FEATURE_MISSING_HUGETLBFS to the
 -	 *    uffdio_api.features before calling UFFDIO_API, an error
 -	 *    will be returned by UFFDIO_API on a kernel without
 -	 *    hugetlbfs missing support
 -	 *
 -	 * 2) the UFFD_FEATURE_MISSING_HUGETLBFS can not be added in
 -	 *    uffdio_api.features and instead it will be set by the
 -	 *    kernel in the uffdio_api.features if the kernel supports
 -	 *    it, so userland can later check if the feature flag is
 -	 *    present in uffdio_api.features after UFFDIO_API
 -	 *    succeeded.
 -	 *
 -	 * UFFD_FEATURE_MISSING_SHMEM works the same as
 -	 * UFFD_FEATURE_MISSING_HUGETLBFS, but it applies to shmem
 -	 * (i.e. tmpfs and other shmem based APIs).
  	 */
 +#if 0 /* not available yet */
  #define UFFD_FEATURE_PAGEFAULT_FLAG_WP		(1<<0)
  #define UFFD_FEATURE_EVENT_FORK			(1<<1)
++<<<<<<< HEAD
 +#endif
++=======
+ #define UFFD_FEATURE_EVENT_REMAP		(1<<2)
+ #define UFFD_FEATURE_EVENT_REMOVE		(1<<3)
+ #define UFFD_FEATURE_MISSING_HUGETLBFS		(1<<4)
+ #define UFFD_FEATURE_MISSING_SHMEM		(1<<5)
++>>>>>>> d811914d8757 (userfaultfd: non-cooperative: rename *EVENT_MADVDONTNEED to *EVENT_REMOVE)
  	__u64 features;
  
  	__u64 ioctls;
diff --cc mm/madvise.c
index ba35af4c0b09,ab5ef141cc9b..000000000000
--- a/mm/madvise.c
+++ b/mm/madvise.c
@@@ -276,17 -476,11 +276,22 @@@ static long madvise_dontneed(struct vm_
  			     unsigned long start, unsigned long end)
  {
  	*prev = vma;
 -	if (!can_madv_dontneed_vma(vma))
 +	if (vma->vm_flags & (VM_LOCKED|VM_HUGETLB|VM_PFNMAP))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (unlikely(vma->vm_flags & VM_NONLINEAR)) {
 +		struct zap_details details = {
 +			.nonlinear_vma = vma,
 +			.last_index = ULONG_MAX,
 +		};
 +		zap_page_range(vma, start, end - start, &details);
 +	} else
 +		zap_page_range(vma, start, end - start, NULL);
++=======
+ 	userfaultfd_remove(vma, prev, start, end);
+ 	zap_page_range(vma, start, end - start);
++>>>>>>> d811914d8757 (userfaultfd: non-cooperative: rename *EVENT_MADVDONTNEED to *EVENT_REMOVE)
  	return 0;
  }
  
* Unmerged path tools/testing/selftests/vm/userfaultfd.c
* Unmerged path fs/userfaultfd.c
* Unmerged path include/linux/userfaultfd_k.h
* Unmerged path include/uapi/linux/userfaultfd.h
* Unmerged path mm/madvise.c
* Unmerged path tools/testing/selftests/vm/userfaultfd.c
