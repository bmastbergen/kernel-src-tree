selinux: Add accessor functions for inode->i_security

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 83da53c5a34564a0a63b26f84293c6e2a639e1e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/83da53c5.failed

Add functions dentry_security and inode_security for accessing
inode->i_security.  These functions initially don't do much, but they
will later be used to revalidate the security labels when necessary.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Acked-by:  Stephen Smalley <sds@tycho.nsa.gov>
	Signed-off-by: Paul Moore <pmoore@redhat.com>
(cherry picked from commit 83da53c5a34564a0a63b26f84293c6e2a639e1e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
diff --cc security/selinux/hooks.c
index 47406b6a55bb,1dc0d79a6a25..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -530,8 -583,8 +548,13 @@@ static int selinux_get_mnt_opts(const s
  		opts->mnt_opts_flags[i++] = DEFCONTEXT_MNT;
  	}
  	if (sbsec->flags & ROOTCONTEXT_MNT) {
++<<<<<<< HEAD
 +		struct inode *root = sbsec->sb->s_root->d_inode;
 +		struct inode_security_struct *isec = root->i_security;
++=======
+ 		struct dentry *root = sbsec->sb->s_root;
+ 		struct inode_security_struct *isec = backing_inode_security(root);
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  
  		rc = security_sid_to_context(isec->sid, &context, &len);
  		if (rc)
@@@ -586,8 -639,8 +609,13 @@@ static int selinux_set_mnt_opts(struct 
  	int rc = 0, i;
  	struct superblock_security_struct *sbsec = sb->s_security;
  	const char *name = sb->s_type->name;
++<<<<<<< HEAD
 +	struct inode *inode = sbsec->sb->s_root->d_inode;
 +	struct inode_security_struct *root_isec = inode->i_security;
++=======
+ 	struct dentry *root = sbsec->sb->s_root;
+ 	struct inode_security_struct *root_isec = backing_inode_security(root);
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  	u32 fscontext_sid = 0, context_sid = 0, rootcontext_sid = 0;
  	u32 defcontext_sid = 0;
  	char **mount_options = opts->mnt_opts;
@@@ -815,8 -870,8 +843,13 @@@ static int selinux_cmp_sb_context(cons
  	if ((oldflags & DEFCONTEXT_MNT) && old->def_sid != new->def_sid)
  		goto mismatch;
  	if (oldflags & ROOTCONTEXT_MNT) {
++<<<<<<< HEAD
 +		struct inode_security_struct *oldroot = oldsb->s_root->d_inode->i_security;
 +		struct inode_security_struct *newroot = newsb->s_root->d_inode->i_security;
++=======
+ 		struct inode_security_struct *oldroot = backing_inode_security(oldsb->s_root);
+ 		struct inode_security_struct *newroot = backing_inode_security(newsb->s_root);
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  		if (oldroot->sid != newroot->sid)
  			goto mismatch;
  	}
@@@ -866,17 -921,14 +899,26 @@@ static int selinux_sb_clone_mnt_opts(co
  		if (!set_fscontext)
  			newsbsec->sid = sid;
  		if (!set_rootcontext) {
++<<<<<<< HEAD
 +			struct inode *newinode = newsb->s_root->d_inode;
 +			struct inode_security_struct *newisec = newinode->i_security;
++=======
+ 			struct inode_security_struct *newisec = backing_inode_security(newsb->s_root);
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  			newisec->sid = sid;
  		}
  		newsbsec->mntpoint_sid = sid;
  	}
  	if (set_rootcontext) {
++<<<<<<< HEAD
 +		const struct inode *oldinode = oldsb->s_root->d_inode;
 +		const struct inode_security_struct *oldisec = oldinode->i_security;
 +		struct inode *newinode = newsb->s_root->d_inode;
 +		struct inode_security_struct *newisec = newinode->i_security;
++=======
+ 		const struct inode_security_struct *oldisec = backing_inode_security(oldsb->s_root);
+ 		struct inode_security_struct *newisec = backing_inode_security(newsb->s_root);
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  
  		newisec->sid = oldisec->sid;
  	}
@@@ -1665,6 -1724,32 +1707,35 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Determine the label for an inode that might be unioned.
+  */
+ static int selinux_determine_inode_label(struct inode *dir,
+ 					 const struct qstr *name,
+ 					 u16 tclass,
+ 					 u32 *_new_isid)
+ {
+ 	const struct superblock_security_struct *sbsec = dir->i_sb->s_security;
+ 	const struct inode_security_struct *dsec = inode_security(dir);
+ 	const struct task_security_struct *tsec = current_security();
+ 
+ 	if ((sbsec->flags & SE_SBINITIALIZED) &&
+ 	    (sbsec->behavior == SECURITY_FS_USE_MNTPOINT)) {
+ 		*_new_isid = sbsec->mntpoint_sid;
+ 	} else if ((sbsec->flags & SBLABEL_MNT) &&
+ 		   tsec->create_sid) {
+ 		*_new_isid = tsec->create_sid;
+ 	} else {
+ 		return security_transition_sid(tsec->sid, dsec->sid, tclass,
+ 					       name, _new_isid);
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  /* Check whether a task can create a file. */
  static int may_create(struct inode *dir,
  		      struct dentry *dentry,
@@@ -1733,8 -1815,8 +1804,13 @@@ static int may_link(struct inode *dir
  	u32 av;
  	int rc;
  
++<<<<<<< HEAD
 +	dsec = dir->i_security;
 +	isec = dentry->d_inode->i_security;
++=======
+ 	dsec = inode_security(dir);
+ 	isec = backing_inode_security(dentry);
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  
  	ad.type = LSM_AUDIT_DATA_DENTRY;
  	ad.u.dentry = dentry;
@@@ -1777,10 -1859,10 +1853,17 @@@ static inline int may_rename(struct ino
  	int old_is_dir, new_is_dir;
  	int rc;
  
++<<<<<<< HEAD
 +	old_dsec = old_dir->i_security;
 +	old_isec = old_dentry->d_inode->i_security;
 +	old_is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
 +	new_dsec = new_dir->i_security;
++=======
+ 	old_dsec = inode_security(old_dir);
+ 	old_isec = backing_inode_security(old_dentry);
+ 	old_is_dir = d_is_dir(old_dentry);
+ 	new_dsec = inode_security(new_dir);
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  
  	ad.type = LSM_AUDIT_DATA_DENTRY;
  
@@@ -1807,9 -1889,9 +1890,15 @@@
  	rc = avc_has_perm(sid, new_dsec->sid, SECCLASS_DIR, av, &ad);
  	if (rc)
  		return rc;
++<<<<<<< HEAD
 +	if (new_dentry->d_inode) {
 +		new_isec = new_dentry->d_inode->i_security;
 +		new_is_dir = S_ISDIR(new_dentry->d_inode->i_mode);
++=======
+ 	if (d_is_positive(new_dentry)) {
+ 		new_isec = backing_inode_security(new_dentry);
+ 		new_is_dir = d_is_dir(new_dentry);
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  		rc = avc_has_perm(sid, new_isec->sid,
  				  new_isec->sclass,
  				  (new_is_dir ? DIR__RMDIR : FILE__UNLINK), &ad);
@@@ -1900,6 -1982,74 +1989,77 @@@ static inline u32 open_file_to_av(struc
  
  /* Hook functions begin here. */
  
++<<<<<<< HEAD
++=======
+ static int selinux_binder_set_context_mgr(struct task_struct *mgr)
+ {
+ 	u32 mysid = current_sid();
+ 	u32 mgrsid = task_sid(mgr);
+ 
+ 	return avc_has_perm(mysid, mgrsid, SECCLASS_BINDER,
+ 			    BINDER__SET_CONTEXT_MGR, NULL);
+ }
+ 
+ static int selinux_binder_transaction(struct task_struct *from,
+ 				      struct task_struct *to)
+ {
+ 	u32 mysid = current_sid();
+ 	u32 fromsid = task_sid(from);
+ 	u32 tosid = task_sid(to);
+ 	int rc;
+ 
+ 	if (mysid != fromsid) {
+ 		rc = avc_has_perm(mysid, fromsid, SECCLASS_BINDER,
+ 				  BINDER__IMPERSONATE, NULL);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	return avc_has_perm(fromsid, tosid, SECCLASS_BINDER, BINDER__CALL,
+ 			    NULL);
+ }
+ 
+ static int selinux_binder_transfer_binder(struct task_struct *from,
+ 					  struct task_struct *to)
+ {
+ 	u32 fromsid = task_sid(from);
+ 	u32 tosid = task_sid(to);
+ 
+ 	return avc_has_perm(fromsid, tosid, SECCLASS_BINDER, BINDER__TRANSFER,
+ 			    NULL);
+ }
+ 
+ static int selinux_binder_transfer_file(struct task_struct *from,
+ 					struct task_struct *to,
+ 					struct file *file)
+ {
+ 	u32 sid = task_sid(to);
+ 	struct file_security_struct *fsec = file->f_security;
+ 	struct dentry *dentry = file->f_path.dentry;
+ 	struct inode_security_struct *isec = backing_inode_security(dentry);
+ 	struct common_audit_data ad;
+ 	int rc;
+ 
+ 	ad.type = LSM_AUDIT_DATA_PATH;
+ 	ad.u.path = file->f_path;
+ 
+ 	if (sid != fsec->sid) {
+ 		rc = avc_has_perm(sid, fsec->sid,
+ 				  SECCLASS_FD,
+ 				  FD__USE,
+ 				  &ad);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
+ 		return 0;
+ 
+ 	return avc_has_perm(sid, isec->sid, isec->sclass, file_to_av(file),
+ 			    &ad);
+ }
+ 
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  static int selinux_ptrace_access_check(struct task_struct *child,
  				     unsigned int mode)
  {
@@@ -2539,7 -2654,7 +2699,11 @@@ static int selinux_sb_remount(struct su
  			break;
  		case ROOTCONTEXT_MNT: {
  			struct inode_security_struct *root_isec;
++<<<<<<< HEAD
 +			root_isec = sb->s_root->d_inode->i_security;
++=======
+ 			root_isec = backing_inode_security(sb->s_root);
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  
  			if (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid, sid))
  				goto out_bad_option;
@@@ -2776,11 -2858,23 +2940,23 @@@ static int selinux_inode_readlink(struc
  	return dentry_has_perm(cred, dentry, FILE__READ);
  }
  
 -static int selinux_inode_follow_link(struct dentry *dentry, struct inode *inode,
 -				     bool rcu)
 +static int selinux_inode_follow_link(struct dentry *dentry, struct nameidata *nameidata)
  {
  	const struct cred *cred = current_cred();
 -	struct common_audit_data ad;
 -	struct inode_security_struct *isec;
 -	u32 sid;
  
++<<<<<<< HEAD
 +	return dentry_has_perm(cred, dentry, FILE__READ);
++=======
+ 	validate_creds(cred);
+ 
+ 	ad.type = LSM_AUDIT_DATA_DENTRY;
+ 	ad.u.dentry = dentry;
+ 	sid = cred_sid(cred);
+ 	isec = inode_security(inode);
+ 
+ 	return avc_has_perm_flags(sid, isec->sid, isec->sclass, FILE__READ, &ad,
+ 				  rcu ? MAY_NOT_BLOCK : 0);
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  }
  
  static noinline int audit_inode_permission(struct inode *inode,
@@@ -2902,8 -2992,8 +3078,13 @@@ static int selinux_inode_setotherxattr(
  static int selinux_inode_setxattr(struct dentry *dentry, const char *name,
  				  const void *value, size_t size, int flags)
  {
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_inode;
 +	struct inode_security_struct *isec = inode->i_security;
++=======
+ 	struct inode *inode = d_backing_inode(dentry);
+ 	struct inode_security_struct *isec = backing_inode_security(dentry);
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  	struct superblock_security_struct *sbsec;
  	struct common_audit_data ad;
  	u32 newsid, sid = current_sid();
@@@ -2979,8 -3069,8 +3160,13 @@@ static void selinux_inode_post_setxattr
  					const void *value, size_t size,
  					int flags)
  {
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_inode;
 +	struct inode_security_struct *isec = inode->i_security;
++=======
+ 	struct inode *inode = d_backing_inode(dentry);
+ 	struct inode_security_struct *isec = backing_inode_security(dentry);
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  	u32 newsid;
  	int rc;
  
@@@ -3102,9 -3195,9 +3288,9 @@@ static int selinux_inode_listsecurity(s
  	return len;
  }
  
 -static void selinux_inode_getsecid(struct inode *inode, u32 *secid)
 +static void selinux_inode_getsecid(const struct inode *inode, u32 *secid)
  {
- 	struct inode_security_struct *isec = inode->i_security;
+ 	struct inode_security_struct *isec = inode_security(inode);
  	*secid = isec->sid;
  }
  
@@@ -3152,6 -3245,46 +3338,49 @@@ static void selinux_file_free_security(
  	file_free_security(file);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Check whether a task has the ioctl permission and cmd
+  * operation to an inode.
+  */
+ static int ioctl_has_perm(const struct cred *cred, struct file *file,
+ 		u32 requested, u16 cmd)
+ {
+ 	struct common_audit_data ad;
+ 	struct file_security_struct *fsec = file->f_security;
+ 	struct inode *inode = file_inode(file);
+ 	struct inode_security_struct *isec = inode_security(inode);
+ 	struct lsm_ioctlop_audit ioctl;
+ 	u32 ssid = cred_sid(cred);
+ 	int rc;
+ 	u8 driver = cmd >> 8;
+ 	u8 xperm = cmd & 0xff;
+ 
+ 	ad.type = LSM_AUDIT_DATA_IOCTL_OP;
+ 	ad.u.op = &ioctl;
+ 	ad.u.op->cmd = cmd;
+ 	ad.u.op->path = file->f_path;
+ 
+ 	if (ssid != fsec->sid) {
+ 		rc = avc_has_perm(ssid, fsec->sid,
+ 				SECCLASS_FD,
+ 				FD__USE,
+ 				&ad);
+ 		if (rc)
+ 			goto out;
+ 	}
+ 
+ 	if (unlikely(IS_PRIVATE(inode)))
+ 		return 0;
+ 
+ 	rc = avc_has_extended_perms(ssid, isec->sid, isec->sclass,
+ 			requested, driver, xperm, &ad);
+ out:
+ 	return rc;
+ }
+ 
++>>>>>>> 83da53c5a345 (selinux: Add accessor functions for inode->i_security)
  static int selinux_file_ioctl(struct file *file, unsigned int cmd,
  			      unsigned long arg)
  {
* Unmerged path security/selinux/hooks.c
