HID: wacom: Fail probe if HID_GENERIC device has unknown device_type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Fail probe if HID_GENERIC device has unknown device_type (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 96.18%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 8e116d3169cc2b93b7eb2f44dc021a93cd3d5308
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8e116d31.failed

The last patch was careful to maintain backwards-compatible behavior
by forcing device_type to BTN_TOOL_PEN (and printing a warning) if it
were still uninitialized after scanning the HID descriptor and applying
quirks. We should be more strict with HID_GENERIC devices, however,
since there is no a priori guarantee that it is a tablet or touchpad.
If the device_type is still uninitialized for a HID_GENERIC device then
we assume that it isn't something the driver can work with and so fail
the probe.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Reviewed-by: Ping Cheng <pingc@wacom.com>
	Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 8e116d3169cc2b93b7eb2f44dc021a93cd3d5308)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,7abf52caa8d8..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1343,72 -1524,59 +1343,84 @@@ static int wacom_probe(struct usb_inter
  	wacom_set_default_phy(features);
  
  	/* Retrieve the physical and logical size for touch devices */
 -	wacom_retrieve_hid_descriptor(hdev, features);
 -	wacom_setup_device_quirks(wacom);
 +	error = wacom_retrieve_hid_descriptor(intf, features);
 +	if (error)
 +		goto fail3;
  
++<<<<<<< HEAD
 +	/*
 +	 * Intuos5 has no useful data about its touch interface in its
 +	 * HID descriptor. If this is the touch interface (wMaxPacketSize
 +	 * of WACOM_PKGLEN_BBTOUCH3), override the table values.
 +	 */
 +	if (features->type >= INTUOS5S && features->type <= INTUOSPL) {
 +		if (endpoint->wMaxPacketSize == WACOM_PKGLEN_BBTOUCH3) {
 +			features->device_type = BTN_TOOL_FINGER;
 +			features->pktlen = WACOM_PKGLEN_BBTOUCH3;
++=======
+ 	if (!features->device_type && features->type != WIRELESS) {
+ 		error = features->type == HID_GENERIC ? -ENODEV : 0;
+ 
+ 		dev_warn(&hdev->dev, "Unknown device_type for '%s'. %s.",
+ 			 hdev->name,
+ 			 error ? "Ignoring" : "Assuming pen");
+ 
+ 		if (error)
+ 			goto fail_shared_data;
++>>>>>>> 8e116d3169cc (HID: wacom: Fail probe if HID_GENERIC device has unknown device_type)
  
 -		features->device_type = BTN_TOOL_PEN;
 +			features->x_max = 4096;
 +			features->y_max = 4096;
 +		} else {
 +			features->device_type = BTN_TOOL_PEN;
 +		}
  	}
  
 +	wacom_setup_device_quirks(features);
 +
 +	/* set unit to "100th of a mm" for devices not reported by HID */
 +	if (!features->unit) {
 +		features->unit = 0x11;
 +		features->unitExpo = 16 - 3;
 +	}
  	wacom_calculate_res(features);
  
 -	wacom_update_name(wacom);
 +	strlcpy(wacom_wac->name, features->name, sizeof(wacom_wac->name));
  
 -	error = wacom_add_shared_data(hdev);
 -	if (error)
 -		goto fail_shared_data;
 +	if (features->quirks & WACOM_QUIRK_MULTI_INPUT) {
 +		struct usb_device *other_dev;
  
 -	if (!(features->quirks & WACOM_QUIRK_MONITOR) &&
 -	     (features->quirks & WACOM_QUIRK_BATTERY)) {
 -		error = wacom_initialize_battery(wacom);
 -		if (error)
 -			goto fail_battery;
 -	}
 +		/* Append the device type to the name */
 +		if (features->device_type != BTN_TOOL_FINGER)
 +			strlcat(wacom_wac->name, " Pen", WACOM_NAME_MAX);
 +		else if (features->touch_max)
 +			strlcat(wacom_wac->name, " Finger", WACOM_NAME_MAX);
 +		else
 +			strlcat(wacom_wac->name, " Pad", WACOM_NAME_MAX);
  
 -	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
 -		error = wacom_register_inputs(wacom);
 +		other_dev = wacom_get_sibling(dev, features->oVid, features->oPid);
 +		if (other_dev == NULL || wacom_get_usbdev_data(other_dev) == NULL)
 +			other_dev = dev;
 +		error = wacom_add_shared_data(wacom_wac, other_dev);
  		if (error)
 -			goto fail_register_inputs;
 +			goto fail3;
  	}
  
 -	if (hdev->bus == BUS_BLUETOOTH) {
 -		error = device_create_file(&hdev->dev, &dev_attr_speed);
 -		if (error)
 -			hid_warn(hdev,
 -				 "can't create sysfs speed attribute err: %d\n",
 -				 error);
 -	}
 +	usb_fill_int_urb(wacom->irq, dev,
 +			 usb_rcvintpipe(dev, endpoint->bEndpointAddress),
 +			 wacom_wac->data, features->pktlen,
 +			 wacom_sys_irq, wacom, endpoint->bInterval);
 +	wacom->irq->transfer_dma = wacom->data_dma;
 +	wacom->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
  
 -	if (features->type == HID_GENERIC)
 -		connect_mask |= HID_CONNECT_DRIVER;
 +	error = wacom_initialize_leds(wacom);
 +	if (error)
 +		goto fail4;
  
 -	/* Regular HID work starts now */
 -	error = hid_hw_start(hdev, connect_mask);
 -	if (error) {
 -		hid_err(hdev, "hw start failed\n");
 -		goto fail_hw_start;
 +	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
 +		error = wacom_register_input(wacom);
 +		if (error)
 +			goto fail5;
  	}
  
  	/* Note that if query fails it is not a hard failure */
* Unmerged path drivers/hid/wacom_sys.c
