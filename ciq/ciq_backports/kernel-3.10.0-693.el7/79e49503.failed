ipv6: avoid write to a possibly cloned skb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Florian Westphal <fw@strlen.de>
commit 79e49503efe53a8c51d8b695bedc8a346c5e4a87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/79e49503.failed

ip6_fragment, in case skb has a fraglist, checks if the
skb is cloned.  If it is, it will move to the 'slow path' and allocates
new skbs for each fragment.

However, right before entering the slowpath loop, it updates the
nexthdr value of the last ipv6 extension header to NEXTHDR_FRAGMENT,
to account for the fragment header that will be inserted in the new
ipv6-fragment skbs.

In case original skb is cloned this munges nexthdr value of another
skb.  Avoid this by doing the nexthdr update for each of the new fragment
skbs separately.

This was observed with tcpdump on a bridge device where netfilter ipv6
reassembly is active:  tcpdump shows malformed fragment headers as
the l4 header (icmpv6, tcp, etc). is decoded as a fragment header.

	Cc: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Reported-by: Andreas Karis <akaris@redhat.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 79e49503efe53a8c51d8b695bedc8a346c5e4a87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_output.c
diff --cc net/ipv6/ip6_output.c
index ba8faeafb515,58f6288e9ba5..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -707,14 -768,14 +707,23 @@@ slow_path
  	 *	Fragment the datagram.
  	 */
  
++<<<<<<< HEAD
 +	*prevhdr = NEXTHDR_FRAGMENT;
 +	hroom = LL_RESERVED_SPACE(rt->dst.dev);
++=======
++>>>>>>> 79e49503efe5 (ipv6: avoid write to a possibly cloned skb)
  	troom = rt->dst.dev->needed_tailroom;
  
  	/*
  	 *	Keep copying data until we run out.
  	 */
++<<<<<<< HEAD
 +	while(left > 0)	{
++=======
+ 	while (left > 0)	{
+ 		u8 *fragnexthdr_offset;
+ 
++>>>>>>> 79e49503efe5 (ipv6: avoid write to a possibly cloned skb)
  		len = left;
  		/* IF: it doesn't fit, use 'mtu' - the data space left */
  		if (len > mtu)
* Unmerged path net/ipv6/ip6_output.c
