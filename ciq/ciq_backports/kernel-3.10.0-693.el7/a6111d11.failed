btrfs: raid56: Use raid_write_end_io for scrub

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Zhao Lei <zhaolei@cn.fujitsu.com>
commit a6111d11b8b5364d02ea2e881c81ce39d004eb32
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a6111d11.failed

No need to create additional end_io function for scrub, it increased
code size and introduced some un-unified lines, as:
raid_write_parity_end_io():
        int err = bio->bi_error;
        if (bio->bi_error)
raid_write_end_io():
        int err = bio->bi_error;
        if (err)

This patch combines them.

	Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit a6111d11b8b5364d02ea2e881c81ce39d004eb32)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/raid56.c
diff --cc fs/btrfs/raid56.c
index c488bf410cf1,55161369fab1..000000000000
--- a/fs/btrfs/raid56.c
+++ b/fs/btrfs/raid56.c
@@@ -899,9 -897,11 +899,14 @@@ static void rbio_orig_end_io(struct btr
   * end io function used by finish_rmw.  When we finally
   * get here, we've written a full stripe
   */
 -static void raid_write_end_io(struct bio *bio)
 +static void raid_write_end_io(struct bio *bio, int err)
  {
  	struct btrfs_raid_bio *rbio = bio->bi_private;
++<<<<<<< HEAD
++=======
+ 	int err = bio->bi_error;
+ 	int max_errors;
++>>>>>>> a6111d11b8b5 (btrfs: raid56: Use raid_write_end_io for scrub)
  
  	if (err)
  		fail_bio_stripe(rbio, bio);
@@@ -914,11 -914,12 +919,13 @@@
  	err = 0;
  
  	/* OK, we have read all the stripes we need to. */
- 	if (atomic_read(&rbio->error) > rbio->bbio->max_errors)
+ 	max_errors = (rbio->operation == BTRFS_RBIO_PARITY_SCRUB) ?
+ 		     0 : rbio->bbio->max_errors;
+ 	if (atomic_read(&rbio->error) > max_errors)
  		err = -EIO;
  
 -	rbio_orig_end_io(rbio, err);
 +	rbio_orig_end_io(rbio, err, 0);
 +	return;
  }
  
  /*
@@@ -2284,30 -2280,6 +2291,33 @@@ static int alloc_rbio_essential_pages(s
  	return 0;
  }
  
++<<<<<<< HEAD
 +/*
 + * end io function used by finish_rmw.  When we finally
 + * get here, we've written a full stripe
 + */
 +static void raid_write_parity_end_io(struct bio *bio, int err)
 +{
 +	struct btrfs_raid_bio *rbio = bio->bi_private;
 +
 +	if (err)
 +		fail_bio_stripe(rbio, bio);
 +
 +	bio_put(bio);
 +
 +	if (!atomic_dec_and_test(&rbio->stripes_pending))
 +		return;
 +
 +	err = 0;
 +
 +	if (atomic_read(&rbio->error))
 +		err = -EIO;
 +
 +	rbio_orig_end_io(rbio, err, 0);
 +}
 +
++=======
++>>>>>>> a6111d11b8b5 (btrfs: raid56: Use raid_write_end_io for scrub)
  static noinline void finish_parity_scrub(struct btrfs_raid_bio *rbio,
  					 int need_check)
  {
@@@ -2460,8 -2432,7 +2470,12 @@@ submit_write
  			break;
  
  		bio->bi_private = rbio;
++<<<<<<< HEAD
 +		bio->bi_end_io = raid_write_parity_end_io;
 +		BUG_ON(!test_bit(BIO_UPTODATE, &bio->bi_flags));
++=======
+ 		bio->bi_end_io = raid_write_end_io;
++>>>>>>> a6111d11b8b5 (btrfs: raid56: Use raid_write_end_io for scrub)
  		submit_bio(WRITE, bio);
  	}
  	return;
* Unmerged path fs/btrfs/raid56.c
