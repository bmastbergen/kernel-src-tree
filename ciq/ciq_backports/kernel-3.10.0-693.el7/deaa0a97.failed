netfilter: nf_ct_dccp/sctp: fix memory leak after netns cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Liping Zhang <zlpnobody@gmail.com>
commit deaa0a976b829af8a7886d8e2528a675cbe4dac8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/deaa0a97.failed

After running the following commands for a while, kmemleak reported that
"1879 new suspected memory leaks" happened:
  # while : ; do
  ip netns add test
  ip netns delete test
  done

  unreferenced object 0xffff88006342fa38 (size 1024):
  comm "ip", pid 15477, jiffies 4295982857 (age 957.836s)
  hex dump (first 32 bytes):
    b8 b0 4d a0 ff ff ff ff c0 34 c3 59 00 88 ff ff  ..M......4.Y....
    04 00 00 00 a4 01 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<ffffffff8190510a>] kmemleak_alloc+0x4a/0xa0
    [<ffffffff81284130>] __kmalloc_track_caller+0x150/0x300
    [<ffffffff812302d0>] kmemdup+0x20/0x50
    [<ffffffffa04d598a>] dccp_init_net+0x8a/0x160 [nf_conntrack]
    [<ffffffffa04cf9f5>] nf_ct_l4proto_pernet_register_one+0x25/0x90
  ...
  unreferenced object 0xffff88006342da58 (size 1024):
  comm "ip", pid 15477, jiffies 4295982857 (age 957.836s)
  hex dump (first 32 bytes):
    10 b3 4d a0 ff ff ff ff 04 35 c3 59 00 88 ff ff  ..M......5.Y....
    04 00 00 00 a4 01 00 00 00 00 00 00 00 00 00 00  ................
  backtrace:
    [<ffffffff8190510a>] kmemleak_alloc+0x4a/0xa0
    [<ffffffff81284130>] __kmalloc_track_caller+0x150/0x300
    [<ffffffff812302d0>] kmemdup+0x20/0x50
    [<ffffffffa04d6a9d>] sctp_init_net+0x5d/0x130 [nf_conntrack]
    [<ffffffffa04cf9f5>] nf_ct_l4proto_pernet_register_one+0x25/0x90
  ...

This is because we forgot to implement the get_net_proto for sctp and
dccp, so we won't invoke the nf_ct_unregister_sysctl to free the
ctl_table when do netns cleanup. Also note, we will fail to register
the sysctl for dccp/sctp either due to the lack of get_net_proto.

Fixes: c51d39010a1b ("netfilter: conntrack: built-in support for DCCP")
Fixes: a85406afeb3e ("netfilter: conntrack: built-in support for SCTP")
	Cc: Davide Caratti <dcaratti@redhat.com>
	Signed-off-by: Liping Zhang <zlpnobody@gmail.com>
	Acked-by: Davide Caratti <dcaratti@redhat.com>
	Acked-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit deaa0a976b829af8a7886d8e2528a675cbe4dac8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_proto_dccp.c
#	net/netfilter/nf_conntrack_proto_sctp.c
diff --cc net/netfilter/nf_conntrack_proto_dccp.c
index 59359bec328a,4707d997558a..000000000000
--- a/net/netfilter/nf_conntrack_proto_dccp.c
+++ b/net/netfilter/nf_conntrack_proto_dccp.c
@@@ -865,7 -872,12 +865,16 @@@ static int dccp_init_net(struct net *ne
  	return dccp_kmemdup_sysctl_table(net, pn, dn);
  }
  
++<<<<<<< HEAD
 +static struct nf_conntrack_l4proto dccp_proto4 __read_mostly = {
++=======
+ static struct nf_proto_net *dccp_get_net_proto(struct net *net)
+ {
+ 	return &net->ct.nf_ct_proto.dccp.pn;
+ }
+ 
+ struct nf_conntrack_l4proto nf_conntrack_l4proto_dccp4 __read_mostly = {
++>>>>>>> deaa0a976b82 (netfilter: nf_ct_dccp/sctp: fix memory leak after netns cleanup)
  	.l3proto		= AF_INET,
  	.l4proto		= IPPROTO_DCCP,
  	.name			= "dccp",
@@@ -895,11 -908,12 +904,12 @@@
  		.nla_policy	= dccp_timeout_nla_policy,
  	},
  #endif /* CONFIG_NF_CT_NETLINK_TIMEOUT */
 +	.net_id			= &dccp_net_id,
  	.init_net		= dccp_init_net,
+ 	.get_net_proto		= dccp_get_net_proto,
  };
 -EXPORT_SYMBOL_GPL(nf_conntrack_l4proto_dccp4);
  
 -struct nf_conntrack_l4proto nf_conntrack_l4proto_dccp6 __read_mostly = {
 +static struct nf_conntrack_l4proto dccp_proto6 __read_mostly = {
  	.l3proto		= AF_INET6,
  	.l4proto		= IPPROTO_DCCP,
  	.name			= "dccp",
@@@ -929,78 -944,7 +939,79 @@@
  		.nla_policy	= dccp_timeout_nla_policy,
  	},
  #endif /* CONFIG_NF_CT_NETLINK_TIMEOUT */
 +	.net_id			= &dccp_net_id,
  	.init_net		= dccp_init_net,
+ 	.get_net_proto		= dccp_get_net_proto,
  };
 -EXPORT_SYMBOL_GPL(nf_conntrack_l4proto_dccp6);
 +
 +static __net_init int dccp_net_init(struct net *net)
 +{
 +	int ret = 0;
 +	ret = nf_ct_l4proto_pernet_register(net, &dccp_proto4);
 +	if (ret < 0) {
 +		pr_err("nf_conntrack_dccp4: pernet registration failed.\n");
 +		goto out;
 +	}
 +	ret = nf_ct_l4proto_pernet_register(net, &dccp_proto6);
 +	if (ret < 0) {
 +		pr_err("nf_conntrack_dccp6: pernet registration failed.\n");
 +		goto cleanup_dccp4;
 +	}
 +	return 0;
 +cleanup_dccp4:
 +	nf_ct_l4proto_pernet_unregister(net, &dccp_proto4);
 +out:
 +	return ret;
 +}
 +
 +static __net_exit void dccp_net_exit(struct net *net)
 +{
 +	nf_ct_l4proto_pernet_unregister(net, &dccp_proto6);
 +	nf_ct_l4proto_pernet_unregister(net, &dccp_proto4);
 +}
 +
 +static struct pernet_operations dccp_net_ops = {
 +	.init = dccp_net_init,
 +	.exit = dccp_net_exit,
 +	.id   = &dccp_net_id,
 +	.size = sizeof(struct dccp_net),
 +};
 +
 +static int __init nf_conntrack_proto_dccp_init(void)
 +{
 +	int ret;
 +
 +	ret = register_pernet_subsys(&dccp_net_ops);
 +	if (ret < 0)
 +		goto out_pernet;
 +
 +	ret = nf_ct_l4proto_register(&dccp_proto4);
 +	if (ret < 0)
 +		goto out_dccp4;
 +
 +	ret = nf_ct_l4proto_register(&dccp_proto6);
 +	if (ret < 0)
 +		goto out_dccp6;
 +
 +	return 0;
 +out_dccp6:
 +	nf_ct_l4proto_unregister(&dccp_proto4);
 +out_dccp4:
 +	unregister_pernet_subsys(&dccp_net_ops);
 +out_pernet:
 +	return ret;
 +}
 +
 +static void __exit nf_conntrack_proto_dccp_fini(void)
 +{
 +	nf_ct_l4proto_unregister(&dccp_proto6);
 +	nf_ct_l4proto_unregister(&dccp_proto4);
 +	unregister_pernet_subsys(&dccp_net_ops);
 +}
 +
 +module_init(nf_conntrack_proto_dccp_init);
 +module_exit(nf_conntrack_proto_dccp_fini);
 +
 +MODULE_AUTHOR("Patrick McHardy <kaber@trash.net>");
 +MODULE_DESCRIPTION("DCCP connection tracking protocol helper");
 +MODULE_LICENSE("GPL");
diff --cc net/netfilter/nf_conntrack_proto_sctp.c
index fd3950c77413,4ed976f137d3..000000000000
--- a/net/netfilter/nf_conntrack_proto_sctp.c
+++ b/net/netfilter/nf_conntrack_proto_sctp.c
@@@ -856,21 -783,15 +856,30 @@@ static int sctp_init_net(struct net *ne
  			sn->timeouts[i] = sctp_timeouts[i];
  	}
  
 -	return sctp_kmemdup_sysctl_table(pn, sn);
 +	if (proto == AF_INET) {
 +		ret = sctp_kmemdup_compat_sysctl_table(pn, sn);
 +		if (ret < 0)
 +			return ret;
 +
 +		ret = sctp_kmemdup_sysctl_table(pn, sn);
 +		if (ret < 0)
 +			nf_ct_kfree_compat_sysctl_table(pn);
 +	} else
 +		ret = sctp_kmemdup_sysctl_table(pn, sn);
 +
 +	return ret;
  }
  
++<<<<<<< HEAD
 +static struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp4 __read_mostly = {
++=======
+ static struct nf_proto_net *sctp_get_net_proto(struct net *net)
+ {
+ 	return &net->ct.nf_ct_proto.sctp.pn;
+ }
+ 
+ struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp4 __read_mostly = {
++>>>>>>> deaa0a976b82 (netfilter: nf_ct_dccp/sctp: fix memory leak after netns cleanup)
  	.l3proto		= PF_INET,
  	.l4proto 		= IPPROTO_SCTP,
  	.name 			= "sctp",
@@@ -901,11 -823,12 +910,12 @@@
  		.nla_policy	= sctp_timeout_nla_policy,
  	},
  #endif /* CONFIG_NF_CT_NETLINK_TIMEOUT */
 +	.net_id			= &sctp_net_id,
  	.init_net		= sctp_init_net,
+ 	.get_net_proto		= sctp_get_net_proto,
  };
 -EXPORT_SYMBOL_GPL(nf_conntrack_l4proto_sctp4);
  
 -struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp6 __read_mostly = {
 +static struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp6 __read_mostly = {
  	.l3proto		= PF_INET6,
  	.l4proto 		= IPPROTO_SCTP,
  	.name 			= "sctp",
@@@ -936,81 -860,7 +946,82 @@@
  	},
  #endif /* CONFIG_NF_CT_NETLINK_TIMEOUT */
  #endif
 +	.net_id			= &sctp_net_id,
  	.init_net		= sctp_init_net,
+ 	.get_net_proto		= sctp_get_net_proto,
  };
 -EXPORT_SYMBOL_GPL(nf_conntrack_l4proto_sctp6);
 +
 +static int sctp_net_init(struct net *net)
 +{
 +	int ret = 0;
 +
 +	ret = nf_ct_l4proto_pernet_register(net, &nf_conntrack_l4proto_sctp4);
 +	if (ret < 0) {
 +		pr_err("nf_conntrack_sctp4: pernet registration failed.\n");
 +		goto out;
 +	}
 +	ret = nf_ct_l4proto_pernet_register(net, &nf_conntrack_l4proto_sctp6);
 +	if (ret < 0) {
 +		pr_err("nf_conntrack_sctp6: pernet registration failed.\n");
 +		goto cleanup_sctp4;
 +	}
 +	return 0;
 +
 +cleanup_sctp4:
 +	nf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_sctp4);
 +out:
 +	return ret;
 +}
 +
 +static void sctp_net_exit(struct net *net)
 +{
 +	nf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_sctp6);
 +	nf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_sctp4);
 +}
 +
 +static struct pernet_operations sctp_net_ops = {
 +	.init = sctp_net_init,
 +	.exit = sctp_net_exit,
 +	.id   = &sctp_net_id,
 +	.size = sizeof(struct sctp_net),
 +};
 +
 +static int __init nf_conntrack_proto_sctp_init(void)
 +{
 +	int ret;
 +
 +	ret = register_pernet_subsys(&sctp_net_ops);
 +	if (ret < 0)
 +		goto out_pernet;
 +
 +	ret = nf_ct_l4proto_register(&nf_conntrack_l4proto_sctp4);
 +	if (ret < 0)
 +		goto out_sctp4;
 +
 +	ret = nf_ct_l4proto_register(&nf_conntrack_l4proto_sctp6);
 +	if (ret < 0)
 +		goto out_sctp6;
 +
 +	return 0;
 +out_sctp6:
 +	nf_ct_l4proto_unregister(&nf_conntrack_l4proto_sctp4);
 +out_sctp4:
 +	unregister_pernet_subsys(&sctp_net_ops);
 +out_pernet:
 +	return ret;
 +}
 +
 +static void __exit nf_conntrack_proto_sctp_fini(void)
 +{
 +	nf_ct_l4proto_unregister(&nf_conntrack_l4proto_sctp6);
 +	nf_ct_l4proto_unregister(&nf_conntrack_l4proto_sctp4);
 +	unregister_pernet_subsys(&sctp_net_ops);
 +}
 +
 +module_init(nf_conntrack_proto_sctp_init);
 +module_exit(nf_conntrack_proto_sctp_fini);
 +
 +MODULE_LICENSE("GPL");
 +MODULE_AUTHOR("Kiran Kumar Immidi");
 +MODULE_DESCRIPTION("Netfilter connection tracking protocol helper for SCTP");
 +MODULE_ALIAS("ip_conntrack_proto_sctp");
* Unmerged path net/netfilter/nf_conntrack_proto_dccp.c
* Unmerged path net/netfilter/nf_conntrack_proto_sctp.c
