scsi: aacraid: Added support to abort cmd and reset lun

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] aacraid: Added support to abort cmd and reset lun (Scott Benesh) [1384213]
Rebuild_FUZZ: 94.23%
commit-author Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
commit 954b2b5ac76d6bde80974c0779d36f054e036aa5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/954b2b5a.failed

Added task management command support to abort any timed out commands
in case of a eh_abort call and to reset lun's in case of eh_reset call.

	Signed-off-by: Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
	Signed-off-by: Dave Carroll <David.Carroll@microsemi.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 954b2b5ac76d6bde80974c0779d36f054e036aa5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/aacraid/aacraid.h
#	drivers/scsi/aacraid/linit.c
#	drivers/scsi/aacraid/src.c
diff --cc drivers/scsi/aacraid/aacraid.h
index cec822900b4b,055ab19ab9fc..000000000000
--- a/drivers/scsi/aacraid/aacraid.h
+++ b/drivers/scsi/aacraid/aacraid.h
@@@ -95,6 -96,189 +95,192 @@@ enum 
  #define SA_AIF_BPSTAT_CHANGE		(1<<30)
  #define SA_AIF_BPCFG_CHANGE		(1<<31)
  
++<<<<<<< HEAD
++=======
+ #define HBA_MAX_SG_EMBEDDED		28
+ #define HBA_MAX_SG_SEPARATE		90
+ #define HBA_SENSE_DATA_LEN_MAX		32
+ #define HBA_REQUEST_TAG_ERROR_FLAG	0x00000002
+ #define HBA_SGL_FLAGS_EXT		0x80000000UL
+ 
+ struct aac_hba_sgl {
+ 	u32		addr_lo; /* Lower 32-bits of SGL element address */
+ 	u32		addr_hi; /* Upper 32-bits of SGL element address */
+ 	u32		len;	/* Length of SGL element in bytes */
+ 	u32		flags;	/* SGL element flags */
+ };
+ 
+ enum {
+ 	HBA_IU_TYPE_SCSI_CMD_REQ		= 0x40,
+ 	HBA_IU_TYPE_SCSI_TM_REQ			= 0x41,
+ 	HBA_IU_TYPE_SATA_REQ			= 0x42,
+ 	HBA_IU_TYPE_RESP			= 0x60,
+ 	HBA_IU_TYPE_COALESCED_RESP		= 0x61,
+ 	HBA_IU_TYPE_INT_COALESCING_CFG_REQ	= 0x70
+ };
+ 
+ enum {
+ 	HBA_CMD_BYTE1_DATA_DIR_IN		= 0x1,
+ 	HBA_CMD_BYTE1_DATA_DIR_OUT		= 0x2,
+ 	HBA_CMD_BYTE1_DATA_TYPE_DDR		= 0x4,
+ 	HBA_CMD_BYTE1_CRYPTO_ENABLE		= 0x8
+ };
+ 
+ enum {
+ 	HBA_CMD_BYTE1_BITOFF_DATA_DIR_IN	= 0x0,
+ 	HBA_CMD_BYTE1_BITOFF_DATA_DIR_OUT,
+ 	HBA_CMD_BYTE1_BITOFF_DATA_TYPE_DDR,
+ 	HBA_CMD_BYTE1_BITOFF_CRYPTO_ENABLE
+ };
+ 
+ enum {
+ 	HBA_RESP_DATAPRES_NO_DATA		= 0x0,
+ 	HBA_RESP_DATAPRES_RESPONSE_DATA,
+ 	HBA_RESP_DATAPRES_SENSE_DATA
+ };
+ 
+ enum {
+ 	HBA_RESP_SVCRES_TASK_COMPLETE		= 0x0,
+ 	HBA_RESP_SVCRES_FAILURE,
+ 	HBA_RESP_SVCRES_TMF_COMPLETE,
+ 	HBA_RESP_SVCRES_TMF_SUCCEEDED,
+ 	HBA_RESP_SVCRES_TMF_REJECTED,
+ 	HBA_RESP_SVCRES_TMF_LUN_INVALID
+ };
+ 
+ enum {
+ 	HBA_RESP_STAT_IO_ERROR			= 0x1,
+ 	HBA_RESP_STAT_IO_ABORTED,
+ 	HBA_RESP_STAT_NO_PATH_TO_DEVICE,
+ 	HBA_RESP_STAT_INVALID_DEVICE,
+ 	HBA_RESP_STAT_HBAMODE_DISABLED		= 0xE,
+ 	HBA_RESP_STAT_UNDERRUN			= 0x51,
+ 	HBA_RESP_STAT_OVERRUN			= 0x75
+ };
+ 
+ struct aac_hba_cmd_req {
+ 	u8	iu_type;	/* HBA information unit type */
+ 	/*
+ 	 * byte1:
+ 	 * [1:0] DIR - 0=No data, 0x1 = IN, 0x2 = OUT
+ 	 * [2]   TYPE - 0=PCI, 1=DDR
+ 	 * [3]   CRYPTO_ENABLE - 0=Crypto disabled, 1=Crypto enabled
+ 	 */
+ 	u8	byte1;
+ 	u8	reply_qid;	/* Host reply queue to post response to */
+ 	u8	reserved1;
+ 	__le32	it_nexus;	/* Device handle for the request */
+ 	__le32	request_id;	/* Sender context */
+ 	/* Lower 32-bits of tweak value for crypto enabled IOs */
+ 	__le32	tweak_value_lo;
+ 	u8	cdb[16];	/* SCSI CDB of the command */
+ 	u8	lun[8];		/* SCSI LUN of the command */
+ 
+ 	/* Total data length in bytes to be read/written (if any) */
+ 	__le32	data_length;
+ 
+ 	/* [2:0] Task Attribute, [6:3] Command Priority */
+ 	u8	attr_prio;
+ 
+ 	/* Number of SGL elements embedded in the HBA req */
+ 	u8	emb_data_desc_count;
+ 
+ 	__le16	dek_index;	/* DEK index for crypto enabled IOs */
+ 
+ 	/* Lower 32-bits of reserved error data target location on the host */
+ 	__le32	error_ptr_lo;
+ 
+ 	/* Upper 32-bits of reserved error data target location on the host */
+ 	__le32	error_ptr_hi;
+ 
+ 	/* Length of reserved error data area on the host in bytes */
+ 	__le32	error_length;
+ 
+ 	/* Upper 32-bits of tweak value for crypto enabled IOs */
+ 	__le32	tweak_value_hi;
+ 
+ 	struct aac_hba_sgl sge[HBA_MAX_SG_SEPARATE+2]; /* SG list space */
+ 
+ 	/*
+ 	 * structure must not exceed
+ 	 * AAC_MAX_NATIVE_SIZE-FW_ERROR_BUFFER_SIZE
+ 	 */
+ };
+ 
+ /* Task Management Functions (TMF) */
+ #define HBA_TMF_ABORT_TASK	0x01
+ #define HBA_TMF_LUN_RESET	0x08
+ 
+ struct aac_hba_tm_req {
+ 	u8	iu_type;	/* HBA information unit type */
+ 	u8	reply_qid;	/* Host reply queue to post response to */
+ 	u8	tmf;		/* Task management function */
+ 	u8	reserved1;
+ 
+ 	__le32	it_nexus;	/* Device handle for the command */
+ 
+ 	u8	lun[8];		/* SCSI LUN */
+ 
+ 	/* Used to hold sender context. */
+ 	__le32	request_id;	/* Sender context */
+ 	__le32	reserved2;
+ 
+ 	/* Request identifier of managed task */
+ 	__le32	managed_request_id;	/* Sender context being managed */
+ 	__le32	reserved3;
+ 
+ 	/* Lower 32-bits of reserved error data target location on the host */
+ 	__le32	error_ptr_lo;
+ 	/* Upper 32-bits of reserved error data target location on the host */
+ 	__le32	error_ptr_hi;
+ 	/* Length of reserved error data area on the host in bytes */
+ 	__le32	error_length;
+ };
+ 
+ struct aac_hba_reset_req {
+ 	u8	iu_type;	/* HBA information unit type */
+ 	/* 0 - reset specified device, 1 - reset all devices */
+ 	u8	reset_type;
+ 	u8	reply_qid;	/* Host reply queue to post response to */
+ 	u8	reserved1;
+ 
+ 	__le32	it_nexus;	/* Device handle for the command */
+ 	__le32	request_id;	/* Sender context */
+ 	/* Lower 32-bits of reserved error data target location on the host */
+ 	__le32	error_ptr_lo;
+ 	/* Upper 32-bits of reserved error data target location on the host */
+ 	__le32	error_ptr_hi;
+ 	/* Length of reserved error data area on the host in bytes */
+ 	__le32	error_length;
+ };
+ 
+ struct aac_hba_resp {
+ 	u8	iu_type;		/* HBA information unit type */
+ 	u8	reserved1[3];
+ 	__le32	request_identifier;	/* sender context */
+ 	__le32	reserved2;
+ 	u8	service_response;	/* SCSI service response */
+ 	u8	status;			/* SCSI status */
+ 	u8	datapres;	/* [1:0] - data present, [7:2] - reserved */
+ 	u8	sense_response_data_len;	/* Sense/response data length */
+ 	__le32	residual_count;		/* Residual data length in bytes */
+ 	/* Sense/response data */
+ 	u8	sense_response_buf[HBA_SENSE_DATA_LEN_MAX];
+ };
+ 
+ struct aac_native_hba {
+ 	union {
+ 		struct aac_hba_cmd_req cmd;
+ 		struct aac_hba_tm_req tmr;
+ 		u8 cmd_bytes[AAC_MAX_NATIVE_SIZE-FW_ERROR_BUFFER_SIZE];
+ 	} cmd;
+ 	union {
+ 		struct aac_hba_resp err;
+ 		u8 resp_bytes[FW_ERROR_BUFFER_SIZE];
+ 	} resp;
+ };
+ 
++>>>>>>> 954b2b5ac76d (scsi: aacraid: Added support to abort cmd and reset lun)
  #define CISS_REPORT_PHYSICAL_LUNS	0xc3
  #define WRITE_HOST_WELLNESS		0xa5
  #define CISS_IDENTIFY_PHYSICAL_DEVICE	0x15
diff --cc drivers/scsi/aacraid/linit.c
index 71d8efdb66d8,c09b71c7dd8e..000000000000
--- a/drivers/scsi/aacraid/linit.c
+++ b/drivers/scsi/aacraid/linit.c
@@@ -620,46 -574,136 +620,151 @@@ static int aac_eh_abort(struct scsi_cmn
  	struct scsi_device * dev = cmd->device;
  	struct Scsi_Host * host = dev->host;
  	struct aac_dev * aac = (struct aac_dev *)host->hostdata;
- 	int count;
+ 	int count, found;
+ 	u32 bus, cid;
  	int ret = FAILED;
  
++<<<<<<< HEAD
 +	printk(KERN_ERR "%s: Host adapter abort request (%d,%d,%d,%d)\n",
 +		AAC_DRIVERNAME,
 +		host->host_no, sdev_channel(dev), sdev_id(dev), dev->lun);
 +	switch (cmd->cmnd[0]) {
 +	case SERVICE_ACTION_IN_16:
 +		if (!(aac->raw_io_interface) ||
 +		    !(aac->raw_io_64) ||
 +		    ((cmd->cmnd[1] & 0x1f) != SAI_READ_CAPACITY_16))
 +			break;
 +	case INQUIRY:
 +	case READ_CAPACITY:
 +		/* Mark associated FIB to not complete, eh handler does this */
++=======
+ 	bus = aac_logical_to_phys(scmd_channel(cmd));
+ 	cid = scmd_id(cmd);
+ 	if (aac->hba_map[bus][cid].devtype == AAC_DEVTYPE_NATIVE_RAW) {
+ 		struct fib *fib;
+ 		struct aac_hba_tm_req *tmf;
+ 		int status;
+ 		u64 address;
+ 		__le32 managed_request_id;
+ 
+ 		pr_err("%s: Host adapter abort request (%d,%d,%d,%d)\n",
+ 		 AAC_DRIVERNAME,
+ 		 host->host_no, sdev_channel(dev), sdev_id(dev), (int)dev->lun);
+ 
+ 		found = 0;
++>>>>>>> 954b2b5ac76d (scsi: aacraid: Added support to abort cmd and reset lun)
  		for (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {
- 			struct fib * fib = &aac->fibs[count];
- 			if (fib->hw_fib_va->header.XferState &&
- 			  (fib->flags & FIB_CONTEXT_FLAG) &&
- 			  (fib->callback_data == cmd)) {
- 				fib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;
- 				cmd->SCp.phase = AAC_OWNER_ERROR_HANDLER;
+ 			fib = &aac->fibs[count];
+ 			if (*(u8 *)fib->hw_fib_va != 0 &&
+ 				(fib->flags & FIB_CONTEXT_FLAG_NATIVE_HBA) &&
+ 				(fib->callback_data == cmd)) {
+ 				found = 1;
+ 				managed_request_id = ((struct aac_hba_cmd_req *)
+ 					fib->hw_fib_va)->request_id;
+ 				break;
+ 			}
+ 		}
+ 		if (!found)
+ 			return ret;
+ 
+ 		/* start a HBA_TMF_ABORT_TASK TMF request */
+ 		fib = aac_fib_alloc(aac);
+ 		if (!fib)
+ 			return ret;
+ 
+ 		tmf = (struct aac_hba_tm_req *)fib->hw_fib_va;
+ 		memset(tmf, 0, sizeof(*tmf));
+ 		tmf->tmf = HBA_TMF_ABORT_TASK;
+ 		tmf->it_nexus = aac->hba_map[bus][cid].rmw_nexus;
+ 		tmf->lun[1] = cmd->device->lun;
+ 
+ 		address = (u64)fib->hw_error_pa;
+ 		tmf->error_ptr_hi = cpu_to_le32((u32)(address >> 32));
+ 		tmf->error_ptr_lo = cpu_to_le32((u32)(address & 0xffffffff));
+ 		tmf->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE);
+ 
+ 		fib->hbacmd_size = sizeof(*tmf);
+ 		cmd->SCp.sent_command = 0;
+ 
+ 		status = aac_hba_send(HBA_IU_TYPE_SCSI_TM_REQ, fib,
+ 				  (fib_callback) aac_hba_callback,
+ 				  (void *) cmd);
+ 
+ 		/* Wait up to 2 minutes for completion */
+ 		for (count = 0; count < 120; ++count) {
+ 			if (cmd->SCp.sent_command) {
  				ret = SUCCESS;
+ 				break;
  			}
+ 			msleep(1000);
  		}
- 		break;
- 	case TEST_UNIT_READY:
- 		/* Mark associated FIB to not complete, eh handler does this */
- 		for (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {
- 			struct scsi_cmnd * command;
- 			struct fib * fib = &aac->fibs[count];
- 			if ((fib->hw_fib_va->header.XferState & cpu_to_le32(Async | NoResponseExpected)) &&
- 			  (fib->flags & FIB_CONTEXT_FLAG) &&
- 			  ((command = fib->callback_data)) &&
- 			  (command->device == cmd->device)) {
- 				fib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;
- 				command->SCp.phase = AAC_OWNER_ERROR_HANDLER;
- 				if (command == cmd)
+ 
+ 		if (ret != SUCCESS)
+ 			pr_err("%s: Host adapter abort request timed out\n",
+ 			AAC_DRIVERNAME);
+ 	} else {
+ 		pr_err(
+ 			"%s: Host adapter abort request.\n"
+ 			"%s: Outstanding commands on (%d,%d,%d,%d):\n",
+ 			AAC_DRIVERNAME, AAC_DRIVERNAME,
+ 			host->host_no, sdev_channel(dev), sdev_id(dev),
+ 			(int)dev->lun);
+ 		switch (cmd->cmnd[0]) {
+ 		case SERVICE_ACTION_IN_16:
+ 			if (!(aac->raw_io_interface) ||
+ 			    !(aac->raw_io_64) ||
+ 			    ((cmd->cmnd[1] & 0x1f) != SAI_READ_CAPACITY_16))
+ 				break;
+ 		case INQUIRY:
+ 		case READ_CAPACITY:
+ 			/*
+ 			 * Mark associated FIB to not complete,
+ 			 * eh handler does this
+ 			 */
+ 			for (count = 0;
+ 				count < (host->can_queue + AAC_NUM_MGT_FIB);
+ 				++count) {
+ 				struct fib *fib = &aac->fibs[count];
+ 
+ 				if (fib->hw_fib_va->header.XferState &&
+ 				(fib->flags & FIB_CONTEXT_FLAG) &&
+ 				(fib->callback_data == cmd)) {
+ 					fib->flags |=
+ 						FIB_CONTEXT_FLAG_TIMED_OUT;
+ 					cmd->SCp.phase =
+ 						AAC_OWNER_ERROR_HANDLER;
  					ret = SUCCESS;
+ 				}
+ 			}
+ 			break;
+ 		case TEST_UNIT_READY:
+ 			/*
+ 			 * Mark associated FIB to not complete,
+ 			 * eh handler does this
+ 			 */
+ 			for (count = 0;
+ 				count < (host->can_queue + AAC_NUM_MGT_FIB);
+ 				++count) {
+ 				struct scsi_cmnd *command;
+ 				struct fib *fib = &aac->fibs[count];
+ 
+ 				command = fib->callback_data;
+ 
+ 				if ((fib->hw_fib_va->header.XferState &
+ 					cpu_to_le32
+ 					(Async | NoResponseExpected)) &&
+ 					(fib->flags & FIB_CONTEXT_FLAG) &&
+ 					((command)) &&
+ 					(command->device == cmd->device)) {
+ 					fib->flags |=
+ 						FIB_CONTEXT_FLAG_TIMED_OUT;
+ 					command->SCp.phase =
+ 						AAC_OWNER_ERROR_HANDLER;
+ 					if (command == cmd)
+ 						ret = SUCCESS;
+ 				}
  			}
+ 			break;
  		}
  	}
  	return ret;
diff --cc drivers/scsi/aacraid/src.c
index a5f7a6f2f3d7,1dd62a4aad2c..000000000000
--- a/drivers/scsi/aacraid/src.c
+++ b/drivers/scsi/aacraid/src.c
@@@ -468,10 -484,51 +468,58 @@@ static int aac_src_deliver_message(stru
  
  	atomic_inc(&q->numpending);
  
++<<<<<<< HEAD
 +	if (dev->msi_enabled && fib->hw_fib_va->header.Command != AifRequest &&
 +	    dev->max_msix > 1) {
 +		vector_no = fib->vector_no;
 +		fib->hw_fib_va->header.Handle += (vector_no << 16);
++=======
+ 	native_hba = (fib->flags & FIB_CONTEXT_FLAG_NATIVE_HBA) ? 1 : 0;
+ 
+ 
+ 	if (dev->msi_enabled && dev->max_msix > 1 &&
+ 		(native_hba || fib->hw_fib_va->header.Command != AifRequest)) {
+ 
+ 		if ((dev->comm_interface == AAC_COMM_MESSAGE_TYPE3)
+ 			&& dev->sa_firmware)
+ 			vector_no = aac_get_vector(dev);
+ 		else
+ 			vector_no = fib->vector_no;
+ 
+ 		if (native_hba) {
+ 			if (fib->flags & FIB_CONTEXT_FLAG_NATIVE_HBA_TMF) {
+ 				struct aac_hba_tm_req *tm_req;
+ 
+ 				tm_req = (struct aac_hba_tm_req *)
+ 						fib->hw_fib_va;
+ 				if (tm_req->iu_type ==
+ 					HBA_IU_TYPE_SCSI_TM_REQ) {
+ 					((struct aac_hba_tm_req *)
+ 						fib->hw_fib_va)->reply_qid
+ 							= vector_no;
+ 					((struct aac_hba_tm_req *)
+ 						fib->hw_fib_va)->request_id
+ 							+= (vector_no << 16);
+ 				} else {
+ 					((struct aac_hba_reset_req *)
+ 						fib->hw_fib_va)->reply_qid
+ 							= vector_no;
+ 					((struct aac_hba_reset_req *)
+ 						fib->hw_fib_va)->request_id
+ 							+= (vector_no << 16);
+ 				}
+ 			} else {
+ 				((struct aac_hba_cmd_req *)
+ 					fib->hw_fib_va)->reply_qid
+ 						= vector_no;
+ 				((struct aac_hba_cmd_req *)
+ 					fib->hw_fib_va)->request_id
+ 						+= (vector_no << 16);
+ 			}
+ 		} else {
+ 			fib->hw_fib_va->header.Handle += (vector_no << 16);
+ 		}
++>>>>>>> 954b2b5ac76d (scsi: aacraid: Added support to abort cmd and reset lun)
  	} else {
  		vector_no = 0;
  	}
* Unmerged path drivers/scsi/aacraid/aacraid.h
* Unmerged path drivers/scsi/aacraid/linit.c
* Unmerged path drivers/scsi/aacraid/src.c
