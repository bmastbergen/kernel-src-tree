IB/mlx5: Port events in RoCE now rely on netdev events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Aviv Heller <avivh@mellanox.com>
commit 5ec8c83e3ad3ea4ea78798edcd4ad61e0041a174
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5ec8c83e.failed

Since ib_query_port() in RoCE returns the state of its netdev as the port
state, it makes sense to propagate the port up/down events to ib_core
when the netdev port state changes, instead of relying on traditional
core events.

This also keeps both the event and ib_query_port() synchronized.

	Signed-off-by: Aviv Heller <avivh@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 5ec8c83e3ad3ea4ea78798edcd4ad61e0041a174)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index 0662b3b06b3e,ed038b7a96fc..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -2608,9 -2716,11 +2640,16 @@@ static int mlx5_enable_roce(struct mlx5
  	int err;
  
  	dev->roce.nb.notifier_call = mlx5_netdev_event;
++<<<<<<< HEAD
 +	err = register_netdevice_notifier_rh(&dev->roce.nb);
 +	if (err)
++=======
+ 	err = register_netdevice_notifier(&dev->roce.nb);
+ 	if (err) {
+ 		dev->roce.nb.notifier_call = NULL;
++>>>>>>> 5ec8c83e3ad3 (IB/mlx5: Port events in RoCE now rely on netdev events)
  		return err;
+ 	}
  
  	err = mlx5_nic_vport_enable_roce(dev->mdev);
  	if (err)
@@@ -2619,14 -2729,48 +2658,56 @@@
  	return 0;
  
  err_unregister_netdevice_notifier:
++<<<<<<< HEAD
 +	unregister_netdevice_notifier_rh(&dev->roce.nb);
++=======
+ 	mlx5_remove_roce_notifier(dev);
++>>>>>>> 5ec8c83e3ad3 (IB/mlx5: Port events in RoCE now rely on netdev events)
  	return err;
  }
  
  static void mlx5_disable_roce(struct mlx5_ib_dev *dev)
  {
  	mlx5_nic_vport_disable_roce(dev->mdev);
++<<<<<<< HEAD
 +	unregister_netdevice_notifier_rh(&dev->roce.nb);
++=======
+ }
+ 
+ static void mlx5_ib_dealloc_q_counters(struct mlx5_ib_dev *dev)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < dev->num_ports; i++)
+ 		mlx5_core_dealloc_q_counter(dev->mdev,
+ 					    dev->port[i].q_cnt_id);
+ }
+ 
+ static int mlx5_ib_alloc_q_counters(struct mlx5_ib_dev *dev)
+ {
+ 	int i;
+ 	int ret;
+ 
+ 	for (i = 0; i < dev->num_ports; i++) {
+ 		ret = mlx5_core_alloc_q_counter(dev->mdev,
+ 						&dev->port[i].q_cnt_id);
+ 		if (ret) {
+ 			mlx5_ib_warn(dev,
+ 				     "couldn't allocate queue counter for port %d, err %d\n",
+ 				     i + 1, ret);
+ 			goto dealloc_counters;
+ 		}
+ 	}
+ 
+ 	return 0;
+ 
+ dealloc_counters:
+ 	while (--i >= 0)
+ 		mlx5_core_dealloc_q_counter(dev->mdev,
+ 					    dev->port[i].q_cnt_id);
+ 
+ 	return ret;
++>>>>>>> 5ec8c83e3ad3 (IB/mlx5: Port events in RoCE now rely on netdev events)
  }
  
  static const char * const names[] = {
* Unmerged path drivers/infiniband/hw/mlx5/main.c
