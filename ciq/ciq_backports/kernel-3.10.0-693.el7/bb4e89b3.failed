crypto: ccp - Refactor code to enable checks for queue space.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] ccp - Refactor code to enable checks for queue space (Suravee Suthikulpanit) [1390820]
Rebuild_FUZZ: 92.04%
commit-author Gary R Hook <gary.hook@amd.com>
commit bb4e89b34d1bf46156b7e880a0f34205fb7ce2a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/bb4e89b3.failed

Available queue space is used to decide (by counting free slots)
if we have to put a command on hold or if it can be sent
to the engine immediately.

	Signed-off-by: Gary R Hook <gary.hook@amd.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit bb4e89b34d1bf46156b7e880a0f34205fb7ce2a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/ccp/ccp-dev-v3.c
#	drivers/crypto/ccp/ccp-dev.h
diff --cc drivers/crypto/ccp/ccp-dev.h
index 72bf1536b653,de907029c6ee..000000000000
--- a/drivers/crypto/ccp/ccp-dev.h
+++ b/drivers/crypto/ccp/ccp-dev.h
@@@ -268,4 -444,35 +268,38 @@@ irqreturn_t ccp_irq_handler(int irq, vo
  
  int ccp_run_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd);
  
++<<<<<<< HEAD
++=======
+ int ccp_dmaengine_register(struct ccp_device *ccp);
+ void ccp_dmaengine_unregister(struct ccp_device *ccp);
+ 
+ /* Structure for computation functions that are device-specific */
+ struct ccp_actions {
+ 	int (*aes)(struct ccp_op *);
+ 	int (*xts_aes)(struct ccp_op *);
+ 	int (*sha)(struct ccp_op *);
+ 	int (*rsa)(struct ccp_op *);
+ 	int (*passthru)(struct ccp_op *);
+ 	int (*ecc)(struct ccp_op *);
+ 	u32 (*sballoc)(struct ccp_cmd_queue *, unsigned int);
+ 	void (*sbfree)(struct ccp_cmd_queue *, unsigned int,
+ 			       unsigned int);
+ 	unsigned int (*get_free_slots)(struct ccp_cmd_queue *);
+ 	int (*init)(struct ccp_device *);
+ 	void (*destroy)(struct ccp_device *);
+ 	irqreturn_t (*irqhandler)(int, void *);
+ };
+ 
+ /* Structure to hold CCP version-specific values */
+ struct ccp_vdata {
+ 	unsigned int version;
+ 	int (*init)(struct ccp_device *);
+ 	const struct ccp_actions *perform;
+ 	const unsigned int bar;
+ 	const unsigned int offset;
+ };
+ 
+ extern	struct ccp_vdata ccpv3;
+ 
++>>>>>>> bb4e89b34d1b (crypto: ccp - Refactor code to enable checks for queue space.)
  #endif
* Unmerged path drivers/crypto/ccp/ccp-dev-v3.c
* Unmerged path drivers/crypto/ccp/ccp-dev-v3.c
* Unmerged path drivers/crypto/ccp/ccp-dev.h
diff --git a/drivers/crypto/ccp/ccp-ops.c b/drivers/crypto/ccp/ccp-ops.c
index 23dbb41465d1..d1fd420a83c5 100644
--- a/drivers/crypto/ccp/ccp-ops.c
+++ b/drivers/crypto/ccp/ccp-ops.c
@@ -1992,7 +1992,7 @@ int ccp_run_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)
 	cmd->engine_error = 0;
 	cmd_q->cmd_error = 0;
 	cmd_q->int_rcvd = 0;
-	cmd_q->free_slots = CMD_Q_DEPTH(ioread32(cmd_q->reg_status));
+	cmd_q->free_slots = cmd_q->ccp->vdata->perform->get_free_slots(cmd_q);
 
 	switch (cmd->engine) {
 	case CCP_ENGINE_AES:
