xen-netfront: fix oops when disconnected from backend

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Vrabel <david.vrabel@citrix.com>
commit 765418694bc99d91e71ede6d2889a6328da137fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/76541869.failed

xennet_disconnect_backend() was not correctly iterating over all the
queues.

	Signed-off-by: David Vrabel <david.vrabel@citrix.com>
	Reviewed-by: Wei Liu <wei.liu2@citrix.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 765418694bc99d91e71ede6d2889a6328da137fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/xen-netfront.c
diff --cc drivers/net/xen-netfront.c
index 6c33c68dceb8,daaf1e56e41e..000000000000
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@@ -1228,12 -1282,12 +1228,17 @@@ static irqreturn_t xennet_tx_interrupt(
  
  static irqreturn_t xennet_rx_interrupt(int irq, void *dev_id)
  {
 -	struct netfront_queue *queue = dev_id;
 -	struct net_device *dev = queue->info->netdev;
 +	struct netfront_info *np = dev_id;
 +	struct net_device *dev = np->netdev;
  
  	if (likely(netif_carrier_ok(dev) &&
++<<<<<<< HEAD
 +		   RING_HAS_UNCONSUMED_RESPONSES(&np->rx)))
 +			napi_schedule(&np->napi);
++=======
+ 		   RING_HAS_UNCONSUMED_RESPONSES(&queue->rx)))
+ 		napi_schedule(&queue->napi);
++>>>>>>> 765418694bc9 (xen-netfront: fix oops when disconnected from backend)
  
  	return IRQ_HANDLED;
  }
@@@ -1414,30 -1436,37 +1419,63 @@@ static void xennet_end_access(int ref, 
  
  static void xennet_disconnect_backend(struct netfront_info *info)
  {
++<<<<<<< HEAD
 +	/* Stop old i/f to prevent errors whilst we rebuild the state. */
 +	spin_lock_bh(&info->rx_lock);
 +	spin_lock_irq(&info->tx_lock);
 +	netif_carrier_off(info->netdev);
 +	spin_unlock_irq(&info->tx_lock);
 +	spin_unlock_bh(&info->rx_lock);
 +
 +	if (info->tx_irq && (info->tx_irq == info->rx_irq))
 +		unbind_from_irqhandler(info->tx_irq, info);
 +	if (info->tx_irq && (info->tx_irq != info->rx_irq)) {
 +		unbind_from_irqhandler(info->tx_irq, info);
 +		unbind_from_irqhandler(info->rx_irq, info);
++=======
+ 	unsigned int i = 0;
+ 	unsigned int num_queues = info->netdev->real_num_tx_queues;
+ 
+ 	for (i = 0; i < num_queues; ++i) {
+ 		struct netfront_queue *queue = &info->queues[i];
+ 
+ 		/* Stop old i/f to prevent errors whilst we rebuild the state. */
+ 		spin_lock_bh(&queue->rx_lock);
+ 		spin_lock_irq(&queue->tx_lock);
+ 		netif_carrier_off(queue->info->netdev);
+ 		spin_unlock_irq(&queue->tx_lock);
+ 		spin_unlock_bh(&queue->rx_lock);
+ 
+ 		if (queue->tx_irq && (queue->tx_irq == queue->rx_irq))
+ 			unbind_from_irqhandler(queue->tx_irq, queue);
+ 		if (queue->tx_irq && (queue->tx_irq != queue->rx_irq)) {
+ 			unbind_from_irqhandler(queue->tx_irq, queue);
+ 			unbind_from_irqhandler(queue->rx_irq, queue);
+ 		}
+ 		queue->tx_evtchn = queue->rx_evtchn = 0;
+ 		queue->tx_irq = queue->rx_irq = 0;
+ 
+ 		/* End access and free the pages */
+ 		xennet_end_access(queue->tx_ring_ref, queue->tx.sring);
+ 		xennet_end_access(queue->rx_ring_ref, queue->rx.sring);
+ 
+ 		queue->tx_ring_ref = GRANT_INVALID_REF;
+ 		queue->rx_ring_ref = GRANT_INVALID_REF;
+ 		queue->tx.sring = NULL;
+ 		queue->rx.sring = NULL;
++>>>>>>> 765418694bc9 (xen-netfront: fix oops when disconnected from backend)
  	}
 +	info->tx_evtchn = info->rx_evtchn = 0;
 +	info->tx_irq = info->rx_irq = 0;
 +
 +	/* End access and free the pages */
 +	xennet_end_access(info->tx_ring_ref, info->tx.sring);
 +	xennet_end_access(info->rx_ring_ref, info->rx.sring);
 +
 +	info->tx_ring_ref = GRANT_INVALID_REF;
 +	info->rx_ring_ref = GRANT_INVALID_REF;
 +	info->tx.sring = NULL;
 +	info->rx.sring = NULL;
  }
  
  /**
* Unmerged path drivers/net/xen-netfront.c
