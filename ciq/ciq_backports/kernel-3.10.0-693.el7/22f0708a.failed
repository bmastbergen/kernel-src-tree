vxlan: fix oops in dev_fill_metadata_dst

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Paolo Abeni <pabeni@redhat.com>
commit 22f0708a718daea5e79de2d29b4829de016a4ff4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/22f0708a.failed

Since the commit 0c1d70af924b ("net: use dst_cache for vxlan device")
vxlan_fill_metadata_dst() calls vxlan_get_route() passing a NULL
dst_cache pointer, so the latter should explicitly check for
valid dst_cache ptr. Unfortunately the commit d71785ffc7e7 ("net: add
dst_cache to ovs vxlan lwtunnel") removed said check.

As a result is possible to trigger a null pointer access calling
vxlan_fill_metadata_dst(), e.g. with:

ovs-vsctl add-br ovs-br0
ovs-vsctl add-port ovs-br0 vxlan0 -- set interface vxlan0 \
	type=vxlan options:remote_ip=192.168.1.1 \
	options:key=1234 options:dst_port=4789 ofport_request=10
ip address add dev ovs-br0 172.16.1.2/24
ovs-vsctl set Bridge ovs-br0 ipfix=@i -- --id=@i create IPFIX \
	targets=\"172.16.1.1:1234\" sampling=1
iperf -c 172.16.1.1 -u -l 1000 -b 10M -t 1 -p 1234

This commit addresses the issue passing to vxlan_get_route() the
dst_cache already available into the lwt info processed by
vxlan_fill_metadata_dst().

Fixes: d71785ffc7e7 ("net: add dst_cache to ovs vxlan lwtunnel")
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Acked-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 22f0708a718daea5e79de2d29b4829de016a4ff4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 3b2c9ff3617e,30b04cf2bb1e..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -2429,25 -2434,25 +2429,35 @@@ static int vxlan_fill_metadata_dst(stru
  	dport = info->key.tp_dst ? : vxlan->cfg.dst_port;
  
  	if (ip_tunnel_info_af(info) == AF_INET) {
 -		struct vxlan_sock *sock4 = rcu_dereference(vxlan->vn4_sock);
  		struct rtable *rt;
  
 -		rt = vxlan_get_route(vxlan, dev, sock4, skb, 0, info->key.tos,
 +		if (!vxlan->vn4_sock)
 +			return -EINVAL;
 +		rt = vxlan_get_route(vxlan, skb, 0, info->key.tos,
  				     info->key.u.ipv4.dst,
++<<<<<<< HEAD
 +				     &info->key.u.ipv4.src, NULL, info);
++=======
+ 				     &info->key.u.ipv4.src, dport, sport,
+ 				     &info->dst_cache, info);
++>>>>>>> 22f0708a718d (vxlan: fix oops in dev_fill_metadata_dst)
  		if (IS_ERR(rt))
  			return PTR_ERR(rt);
  		ip_rt_put(rt);
  	} else {
  #if IS_ENABLED(CONFIG_IPV6)
 -		struct vxlan_sock *sock6 = rcu_dereference(vxlan->vn6_sock);
  		struct dst_entry *ndst;
  
 -		ndst = vxlan6_get_route(vxlan, dev, sock6, skb, 0, info->key.tos,
 +		if (!vxlan->vn6_sock)
 +			return -EINVAL;
 +		ndst = vxlan6_get_route(vxlan, skb, 0, info->key.tos,
  					info->key.label, &info->key.u.ipv6.dst,
++<<<<<<< HEAD
 +					&info->key.u.ipv6.src, NULL, info);
++=======
+ 					&info->key.u.ipv6.src, dport, sport,
+ 					&info->dst_cache, info);
++>>>>>>> 22f0708a718d (vxlan: fix oops in dev_fill_metadata_dst)
  		if (IS_ERR(ndst))
  			return PTR_ERR(ndst);
  		dst_release(ndst);
* Unmerged path drivers/net/vxlan.c
