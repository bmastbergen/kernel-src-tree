btrfs: switch to common message helpers in open_ctree, adjust messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Sterba <dsterba@suse.com>
commit 05135f597adcb94dc34fa87b82e68eb55e00f0eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/05135f59.failed

Currently we lack the identification of the filesystem in most if not
all mount messages, done via printk/pr_* functions. We can use the
btrfs_* helpers in open_ctree, as the fs_info <-> sb link is established
at the beginning of the function.

The messages have been updated at the same time to be more consistent:

* dropped sb->s_id, as it's not available via btrfs_*
* added %d for return code where appropriate
* wording changed
* %Lx replaced by %llx

	Signed-off-by: David Sterba <dsterba@suse.com>
(cherry picked from commit 05135f597adcb94dc34fa87b82e68eb55e00f0eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/disk-io.c
diff --cc fs/btrfs/disk-io.c
index b256be64a9b6,123fab55b5a4..000000000000
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@@ -2769,9 -2787,10 +2769,10 @@@ int open_ctree(struct super_block *sb
  	 * flag our filesystem as having big metadata blocks if
  	 * they are bigger than the page size
  	 */
 -	if (btrfs_super_nodesize(disk_super) > PAGE_SIZE) {
 +	if (btrfs_super_nodesize(disk_super) > PAGE_CACHE_SIZE) {
  		if (!(features & BTRFS_FEATURE_INCOMPAT_BIG_METADATA))
- 			printk(KERN_INFO "BTRFS: flagging fs with big metadata feature\n");
+ 			btrfs_info(fs_info,
+ 				"flagging fs with big metadata feature");
  		features |= BTRFS_FEATURE_INCOMPAT_BIG_METADATA;
  	}
  
@@@ -3044,11 -3054,13 +3042,11 @@@ retry_root_backup
  		ret = btrfs_cleanup_fs_roots(fs_info);
  		if (ret)
  			goto fail_qgroup;
 -
 -		mutex_lock(&fs_info->cleaner_mutex);
 +		/* We locked cleaner_mutex before creating cleaner_kthread. */
  		ret = btrfs_recover_relocation(tree_root);
 -		mutex_unlock(&fs_info->cleaner_mutex);
  		if (ret < 0) {
- 			printk(KERN_WARNING
- 			       "BTRFS: failed to recover relocation\n");
+ 			btrfs_warn(fs_info, "failed to recover relocation: %d",
+ 					ret);
  			err = -EINVAL;
  			goto fail_qgroup;
  		}
@@@ -3069,6 -3079,18 +3067,21 @@@
  	if (sb->s_flags & MS_RDONLY)
  		return 0;
  
++<<<<<<< HEAD
++=======
+ 	if (btrfs_test_opt(tree_root, FREE_SPACE_TREE) &&
+ 	    !btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE)) {
+ 		btrfs_info(fs_info, "creating free space tree");
+ 		ret = btrfs_create_free_space_tree(fs_info);
+ 		if (ret) {
+ 			btrfs_warn(fs_info,
+ 				"failed to create free space tree: %d", ret);
+ 			close_ctree(tree_root);
+ 			return ret;
+ 		}
+ 	}
+ 
++>>>>>>> 05135f597adc (btrfs: switch to common message helpers in open_ctree, adjust messages)
  	down_read(&fs_info->cleanup_work_sem);
  	if ((ret = btrfs_orphan_cleanup(fs_info->fs_root)) ||
  	    (ret = btrfs_orphan_cleanup(fs_info->tree_root))) {
@@@ -3094,12 -3116,24 +3107,27 @@@
  
  	btrfs_qgroup_rescan_resume(fs_info);
  
++<<<<<<< HEAD
++=======
+ 	if (btrfs_test_opt(tree_root, CLEAR_CACHE) &&
+ 	    btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE)) {
+ 		btrfs_info(fs_info, "clearing free space tree");
+ 		ret = btrfs_clear_free_space_tree(fs_info);
+ 		if (ret) {
+ 			btrfs_warn(fs_info,
+ 				"failed to clear free space tree: %d", ret);
+ 			close_ctree(tree_root);
+ 			return ret;
+ 		}
+ 	}
+ 
++>>>>>>> 05135f597adc (btrfs: switch to common message helpers in open_ctree, adjust messages)
  	if (!fs_info->uuid_root) {
- 		pr_info("BTRFS: creating UUID tree\n");
+ 		btrfs_info(fs_info, "creating UUID tree");
  		ret = btrfs_create_uuid_tree(fs_info);
  		if (ret) {
- 			pr_warn("BTRFS: failed to create the UUID tree %d\n",
- 				ret);
+ 			btrfs_warn(fs_info,
+ 				"failed to create the UUID tree: %d", ret);
  			close_ctree(tree_root);
  			return ret;
  		}
* Unmerged path fs/btrfs/disk-io.c
