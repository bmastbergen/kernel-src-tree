random: clarify bits/bytes in wakeup thresholds

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Greg Price <price@MIT.EDU>
commit 2132a96f66b6b4d865113e7d4cb56d5f7c6e3cdf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2132a96f.failed

These are a recurring cause of confusion, so rename them to
hopefully be clearer.

	Signed-off-by: Greg Price <price@mit.edu>
	Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
(cherry picked from commit 2132a96f66b6b4d865113e7d4cb56d5f7c6e3cdf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/random.c
diff --cc drivers/char/random.c
index 71f7f741fbfa,8cc7d6515676..000000000000
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@@ -305,7 -302,7 +305,11 @@@ static int random_read_wakeup_bits = 64
   * should wake up processes which are selecting or polling on write
   * access to /dev/random.
   */
++<<<<<<< HEAD
 +static int random_write_wakeup_thresh = 128;
++=======
+ static int random_write_wakeup_bits = 28 * OUTPUT_POOL_WORDS;
++>>>>>>> 2132a96f66b6 (random: clarify bits/bytes in wakeup thresholds)
  
  /*
   * The minimum number of seconds between urandom pool reseeding.  We
@@@ -671,11 -665,36 +675,44 @@@ retry
  				  entropy_count >> ENTROPY_SHIFT,
  				  r->entropy_total, _RET_IP_);
  
++<<<<<<< HEAD
 +	/* should we wake readers? */
 +	if (r == &input_pool &&
 +	    (entropy_count >> ENTROPY_SHIFT) >= random_read_wakeup_thresh) {
 +		wake_up_interruptible(&random_read_wait);
 +		kill_fasync(&fasync, SIGIO, POLL_IN);
++=======
+ 	if (r == &input_pool) {
+ 		int entropy_bits = entropy_count >> ENTROPY_SHIFT;
+ 
+ 		/* should we wake readers? */
+ 		if (entropy_bits >= random_read_wakeup_bits) {
+ 			wake_up_interruptible(&random_read_wait);
+ 			kill_fasync(&fasync, SIGIO, POLL_IN);
+ 		}
+ 		/* If the input pool is getting full, send some
+ 		 * entropy to the two output pools, flipping back and
+ 		 * forth between them, until the output pools are 75%
+ 		 * full.
+ 		 */
+ 		if (entropy_bits > random_write_wakeup_bits &&
+ 		    r->initialized &&
+ 		    r->entropy_total >= 2*random_read_wakeup_bits) {
+ 			static struct entropy_store *last = &blocking_pool;
+ 			struct entropy_store *other = &blocking_pool;
+ 
+ 			if (last == &blocking_pool)
+ 				other = &nonblocking_pool;
+ 			if (other->entropy_count <=
+ 			    3 * other->poolinfo->poolfracbits / 4)
+ 				last = other;
+ 			if (last->entropy_count <=
+ 			    3 * last->poolinfo->poolfracbits / 4) {
+ 				schedule_work(&last->push_work);
+ 				r->entropy_total = 0;
+ 			}
+ 		}
++>>>>>>> 2132a96f66b6 (random: clarify bits/bytes in wakeup thresholds)
  	}
  }
  
@@@ -902,26 -916,45 +939,60 @@@ static void xfer_secondary_pool(struct 
  	}
  	if (r->pull &&
  	    r->entropy_count < (nbytes << (ENTROPY_SHIFT + 3)) &&
 -	    r->entropy_count < r->poolinfo->poolfracbits)
 -		_xfer_secondary_pool(r, nbytes);
 -}
 -
 -static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
 -{
 -	__u32	tmp[OUTPUT_POOL_WORDS];
 -
 +	    r->entropy_count < r->poolinfo->poolfracbits) {
 +		/* If we're limited, always leave two wakeup worth's BITS */
 +		int rsvd = r->limit ? 0 : random_read_wakeup_thresh/4;
 +		int bytes = nbytes;
 +
 +		/* pull at least as many as BYTES as wakeup BITS */
 +		bytes = max_t(int, bytes, random_read_wakeup_thresh / 8);
 +		/* but never more than the buffer size */
 +		bytes = min_t(int, bytes, sizeof(tmp));
 +
++<<<<<<< HEAD
 +		DEBUG_ENT("going to reseed %s with %d bits "
 +			  "(%zu of %d requested)\n",
 +			  r->name, bytes * 8, nbytes * 8,
 +			  r->entropy_count >> ENTROPY_SHIFT);
 +
 +		bytes = extract_entropy(r->pull, tmp, bytes,
 +					random_read_wakeup_thresh / 8, rsvd);
 +		mix_pool_bytes(r, tmp, bytes, NULL);
 +		credit_entropy_bits(r, bytes*8);
 +	}
++=======
+ 	/* For /dev/random's pool, always leave two wakeups' worth */
+ 	int rsvd_bytes = r->limit ? 0 : random_read_wakeup_bits / 4;
+ 	int bytes = nbytes;
+ 
+ 	/* pull at least as much as a wakeup */
+ 	bytes = max_t(int, bytes, random_read_wakeup_bits / 8);
+ 	/* but never more than the buffer size */
+ 	bytes = min_t(int, bytes, sizeof(tmp));
+ 
+ 	trace_xfer_secondary_pool(r->name, bytes * 8, nbytes * 8,
+ 				  ENTROPY_BITS(r), ENTROPY_BITS(r->pull));
+ 	bytes = extract_entropy(r->pull, tmp, bytes,
+ 				random_read_wakeup_bits / 8, rsvd_bytes);
+ 	mix_pool_bytes(r, tmp, bytes, NULL);
+ 	credit_entropy_bits(r, bytes*8);
+ }
+ 
+ /*
+  * Used as a workqueue function so that when the input pool is getting
+  * full, we can "spill over" some entropy to the output pools.  That
+  * way the output pools can store some of the excess entropy instead
+  * of letting it go to waste.
+  */
+ static void push_to_pool(struct work_struct *work)
+ {
+ 	struct entropy_store *r = container_of(work, struct entropy_store,
+ 					      push_work);
+ 	BUG_ON(!r);
+ 	_xfer_secondary_pool(r, random_read_wakeup_bits/8);
+ 	trace_push_to_pool(r->name, r->entropy_count >> ENTROPY_SHIFT,
+ 			   r->pull->entropy_count >> ENTROPY_SHIFT);
++>>>>>>> 2132a96f66b6 (random: clarify bits/bytes in wakeup thresholds)
  }
  
  /*
@@@ -949,28 -975,19 +1020,34 @@@ retry
  	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
  	have_bytes = entropy_count >> (ENTROPY_SHIFT + 3);
  	ibytes = nbytes;
 -	/* If limited, never pull more than available */
 -	if (r->limit)
 -		ibytes = min_t(size_t, ibytes, have_bytes - reserved);
 -	if (ibytes < min)
 +	if (have_bytes < min + reserved) {
  		ibytes = 0;
 -	entropy_count = max_t(int, 0,
 -			      entropy_count - (ibytes << (ENTROPY_SHIFT + 3)));
 -	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
 -		goto retry;
 +	} else {
 +		/* If limited, never pull more than available */
 +		if (r->limit)
 +			ibytes = min_t(size_t, ibytes, have_bytes - reserved);
 +		entropy_count = max_t(int, 0,
 +			    entropy_count - (ibytes << (ENTROPY_SHIFT + 3)));
 +		if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
 +			goto retry;
 +
++<<<<<<< HEAD
 +		if ((r->entropy_count >> ENTROPY_SHIFT)
 +		    < random_write_wakeup_thresh)
 +			wakeup_write = 1;
 +	}
  
 +	DEBUG_ENT("debiting %zu entropy credits from %s%s\n",
 +		  ibytes * 8, r->name, r->limit ? "" : " (unlimited)");
 +
 +	spin_unlock_irqrestore(&r->lock, flags);
 +
 +	if (wakeup_write) {
++=======
+ 	trace_debit_entropy(r->name, 8 * ibytes);
+ 	if (ibytes &&
+ 	    (r->entropy_count >> ENTROPY_SHIFT) < random_write_wakeup_bits) {
++>>>>>>> 2132a96f66b6 (random: clarify bits/bytes in wakeup thresholds)
  		wake_up_interruptible(&random_write_wait);
  		kill_fasync(&fasync, SIGIO, POLL_OUT);
  	}
@@@ -1269,53 -1286,27 +1346,61 @@@ random_read(struct file *file, char __u
  	if (nbytes == 0)
  		return 0;
  
 -	nbytes = min_t(size_t, nbytes, SEC_XFER_SIZE);
 -	while (1) {
 -		n = extract_entropy_user(&blocking_pool, buf, nbytes);
 -		if (n < 0)
 -			return n;
 -		trace_random_read(n*8, (nbytes-n)*8,
 -				  ENTROPY_BITS(&blocking_pool),
 -				  ENTROPY_BITS(&input_pool));
 -		if (n > 0)
 -			return n;
 -		/* Pool is (near) empty.  Maybe wait and retry. */
 -
 -		if (file->f_flags & O_NONBLOCK)
 -			return -EAGAIN;
 +	while (nbytes > 0) {
 +		n = nbytes;
 +		if (n > SEC_XFER_SIZE)
 +			n = SEC_XFER_SIZE;
 +
 +		DEBUG_ENT("reading %zu bits\n", n*8);
 +
++<<<<<<< HEAD
 +		n = extract_entropy_user(&blocking_pool, buf, n);
 +
 +		if (n < 0) {
 +			retval = n;
 +			break;
 +		}
 +
 +		DEBUG_ENT("read got %zd bits (%zd still needed)\n",
 +			  n*8, (nbytes-n)*8);
 +
 +		if (n == 0) {
 +			if (file->f_flags & O_NONBLOCK) {
 +				retval = -EAGAIN;
 +				break;
 +			}
 +
 +			DEBUG_ENT("sleeping?\n");
 +
 +			wait_event_interruptible(random_read_wait,
 +				ENTROPY_BITS(&input_pool) >=
 +				random_read_wakeup_thresh);
 +
 +			DEBUG_ENT("awake\n");
 +
 +			if (signal_pending(current)) {
 +				retval = -ERESTARTSYS;
 +				break;
 +			}
 +
 +			continue;
 +		}
  
 +		count += n;
 +		buf += n;
 +		nbytes -= n;
 +		break;		/* This break makes the device work */
 +				/* like a named pipe */
++=======
+ 		wait_event_interruptible(random_read_wait,
+ 			ENTROPY_BITS(&input_pool) >=
+ 			random_read_wakeup_bits);
+ 		if (signal_pending(current))
+ 			return -ERESTARTSYS;
++>>>>>>> 2132a96f66b6 (random: clarify bits/bytes in wakeup thresholds)
  	}
 +
 +	return (count ? count : retval);
  }
  
  static ssize_t
* Unmerged path drivers/char/random.c
