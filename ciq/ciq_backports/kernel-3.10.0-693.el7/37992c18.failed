xfs: don't release bios on completion immediately

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 37992c18bba3f578860c6448b7bae18a14e535d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/37992c18.failed

Completion of an ioend requires us to walk the bufferhead list to
end writback on all the bufferheads. This, in turn, is needed so
that we can end writeback on all the pages we just did IO on.

To remove our dependency on bufferheads in writeback, we need to
turn this around the other way - we need to walk the pages we've
just completed IO on, and then walk the buffers attached to the
pages and complete their IO. In doing this, we remove the
requirement for the ioend to track bufferheads directly.

To enable IO completion to walk all the pages we've submitted IO on,
we need to keep the bios that we used for IO around until the ioend
has been completed. We can do this simply by chaining the bios to
the ioend at completion time, and then walking their pages directly
just before destroying the ioend.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
[hch: changed the xfs_finish_page_writeback calling convention]
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 37992c18bba3f578860c6448b7bae18a14e535d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_aops.c
#	fs/xfs/xfs_aops.h
diff --cc fs/xfs/xfs_aops.c
index acf6c4a54883,9d9a01b50078..000000000000
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@@ -269,17 -326,11 +313,18 @@@ xfs_alloc_ioend
  	 * all the I/O from calling the completion routine too early.
  	 */
  	atomic_set(&ioend->io_remaining, 1);
 -	INIT_LIST_HEAD(&ioend->io_list);
 +	ioend->io_error = 0;
 +	ioend->io_list = NULL;
  	ioend->io_type = type;
  	ioend->io_inode = inode;
 +	ioend->io_buffer_head = NULL;
 +	ioend->io_buffer_tail = NULL;
 +	ioend->io_offset = 0;
 +	ioend->io_size = 0;
 +	ioend->io_append_trans = NULL;
 +
  	INIT_WORK(&ioend->io_work, xfs_end_io);
+ 	spin_lock_init(&ioend->io_lock);
  	return ioend;
  }
  
@@@ -357,19 -408,23 +402,32 @@@ xfs_imap_valid
   */
  STATIC void
  xfs_end_bio(
 -	struct bio		*bio)
 +	struct bio		*bio,
 +	int			error)
  {
- 	xfs_ioend_t		*ioend = bio->bi_private;
+ 	struct xfs_ioend	*ioend = bio->bi_private;
+ 	unsigned long		flags;
  
++<<<<<<< HEAD
 +	ASSERT(atomic_read(&bio->bi_cnt) >= 1);
 +	if (!ioend->io_error && !test_bit(BIO_UPTODATE, &bio->bi_flags))
 +		ioend->io_error = error;
 +
 +	/* Toss bio and pass work off to an xfsdatad thread */
++=======
++>>>>>>> 37992c18bba3 (xfs: don't release bios on completion immediately)
  	bio->bi_private = NULL;
  	bio->bi_end_io = NULL;
- 	bio_put(bio);
+ 
+ 	spin_lock_irqsave(&ioend->io_lock, flags);
+ 	if (!ioend->io_error)
+ 	       ioend->io_error = bio->bi_error;
+ 	if (!ioend->io_bio_done)
+ 		ioend->io_bio_done = bio;
+ 	else
+ 		ioend->io_bio_done_tail->bi_private = bio;
+ 	ioend->io_bio_done_tail = bio;
+ 	spin_unlock_irqrestore(&ioend->io_lock, flags);
  
  	xfs_finish_ioend(ioend);
  }
@@@ -540,29 -555,32 +598,54 @@@ xfs_add_to_ioend
  	struct inode		*inode,
  	struct buffer_head	*bh,
  	xfs_off_t		offset,
 -	struct xfs_writepage_ctx *wpc,
 -	struct writeback_control *wbc,
 -	struct list_head	*iolist)
 +	unsigned int		type,
 +	xfs_ioend_t		**result,
 +	int			need_ioend)
  {
++<<<<<<< HEAD
 +	xfs_ioend_t		*ioend = *result;
 +
 +	if (!ioend || need_ioend || type != ioend->io_type) {
 +		xfs_ioend_t	*previous = *result;
 +
 +		ioend = xfs_alloc_ioend(inode, type);
 +		ioend->io_offset = offset;
 +		ioend->io_buffer_head = bh;
 +		ioend->io_buffer_tail = bh;
 +		if (previous)
 +			previous->io_list = ioend;
 +		*result = ioend;
 +	} else {
 +		ioend->io_buffer_tail->b_private = bh;
 +		ioend->io_buffer_tail = bh;
 +	}
 +
 +	bh->b_private = NULL;
 +	ioend->io_size += bh->b_size;
++=======
+ 	if (!wpc->ioend || wpc->io_type != wpc->ioend->io_type ||
+ 	    bh->b_blocknr != wpc->last_block + 1 ||
+ 	    offset != wpc->ioend->io_offset + wpc->ioend->io_size) {
+ 		if (wpc->ioend)
+ 			list_add(&wpc->ioend->io_list, iolist);
+ 		wpc->ioend = xfs_alloc_ioend(inode, wpc->io_type);
+ 		wpc->ioend->io_offset = offset;
+ 	}
+ 
+ retry:
+ 	if (!wpc->ioend->io_bio)
+ 		wpc->ioend->io_bio = xfs_alloc_ioend_bio(bh);
+ 
+ 	if (xfs_bio_add_buffer(wpc->ioend->io_bio, bh) != bh->b_size) {
+ 		xfs_submit_ioend_bio(wbc, wpc->ioend, wpc->ioend->io_bio);
+ 		wpc->ioend->io_bio = NULL;
+ 		goto retry;
+ 	}
+ 
+ 	wpc->ioend->io_size += bh->b_size;
+ 	wpc->last_block = bh->b_blocknr;
+ 	xfs_start_buffer_writeback(bh);
++>>>>>>> 37992c18bba3 (xfs: don't release bios on completion immediately)
  }
  
  STATIC void
diff --cc fs/xfs/xfs_aops.h
index a4343c63fb38,61a3dc3dbdf8..000000000000
--- a/fs/xfs/xfs_aops.h
+++ b/fs/xfs/xfs_aops.h
@@@ -50,6 -50,10 +48,13 @@@ typedef struct xfs_ioend 
  	xfs_off_t		io_offset;	/* offset in the file */
  	struct work_struct	io_work;	/* xfsdatad work queue */
  	struct xfs_trans	*io_append_trans;/* xact. for size update */
++<<<<<<< HEAD
++=======
+ 	struct bio		*io_bio;	/* bio being built */
+ 	struct bio		*io_bio_done;	/* bios completed */
+ 	struct bio		*io_bio_done_tail; /* bios completed */
+ 	spinlock_t		io_lock;	/* for bio completion list */
++>>>>>>> 37992c18bba3 (xfs: don't release bios on completion immediately)
  } xfs_ioend_t;
  
  extern const struct address_space_operations xfs_address_space_operations;
* Unmerged path fs/xfs/xfs_aops.c
* Unmerged path fs/xfs/xfs_aops.h
