net/mlx5: Change the acl enable prototype to return status

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Change the acl enable prototype to return status (Don Dutile) [1385330 1417285]
Rebuild_FUZZ: 96.43%
commit-author Mohamad Haj Yahia <mohamad@mellanox.com>
commit 247f139cdae73b4f47bd348d05dff1afd40b84b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/247f139c.failed

The Ingress/Egress ACL enable function may fail and it should return
status to its caller to avoid NULL pointer dereference.

Fixes: f942380c1239 ('net/mlx5: E-Switch, Vport ingress/egress ACLs rules for spoofchk')
	Signed-off-by: Mohamad Haj Yahia <mohamad@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 247f139cdae73b4f47bd348d05dff1afd40b84b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 084178cfa483,be1f7333ab7f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -776,8 -920,19 +776,24 @@@ static void esw_vport_change_handler(st
  					     vport->enabled_events);
  }
  
++<<<<<<< HEAD
 +static void esw_vport_enable_egress_acl(struct mlx5_eswitch *esw,
 +					struct mlx5_vport *vport)
++=======
+ static void esw_vport_change_handler(struct work_struct *work)
+ {
+ 	struct mlx5_vport *vport =
+ 		container_of(work, struct mlx5_vport, vport_change_handler);
+ 	struct mlx5_eswitch *esw = vport->dev->priv.eswitch;
+ 
+ 	mutex_lock(&esw->state_lock);
+ 	esw_vport_change_handle_locked(vport);
+ 	mutex_unlock(&esw->state_lock);
+ }
+ 
+ static int esw_vport_enable_egress_acl(struct mlx5_eswitch *esw,
+ 				       struct mlx5_vport *vport)
++>>>>>>> 247f139cdae7 (net/mlx5: Change the acl enable prototype to return status)
  {
  	int inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);
  	struct mlx5_flow_group *vlan_grp = NULL;
@@@ -795,7 -950,10 +811,14 @@@
  	int err = 0;
  
  	if (!MLX5_CAP_ESW_EGRESS_ACL(dev, ft_support))
++<<<<<<< HEAD
 +		return;
++=======
+ 		return -EOPNOTSUPP;
+ 
+ 	if (!IS_ERR_OR_NULL(vport->egress.acl))
+ 		return 0;
++>>>>>>> 247f139cdae7 (net/mlx5: Change the acl enable prototype to return status)
  
  	esw_debug(dev, "Create vport[%d] egress ACL log_max_size(%d)\n",
  		  vport->vport, MLX5_CAP_ESW_EGRESS_ACL(dev, log_max_ft_size));
@@@ -808,10 -966,10 +831,10 @@@
  
  	flow_group_in = mlx5_vzalloc(inlen);
  	if (!flow_group_in)
- 		return;
+ 		return -ENOMEM;
  
  	acl = mlx5_create_vport_flow_table(root_ns, 0, table_size, 0, vport->vport);
 -	if (IS_ERR(acl)) {
 +	if (IS_ERR_OR_NULL(acl)) {
  		err = PTR_ERR(acl);
  		esw_warn(dev, "Failed to create E-Switch vport[%d] egress flow Table, err(%d)\n",
  			 vport->vport, err);
@@@ -908,7 -1067,10 +932,14 @@@ static int esw_vport_enable_ingress_acl
  	int err = 0;
  
  	if (!MLX5_CAP_ESW_INGRESS_ACL(dev, ft_support))
++<<<<<<< HEAD
 +		return;
++=======
+ 		return -EOPNOTSUPP;
+ 
+ 	if (!IS_ERR_OR_NULL(vport->ingress.acl))
+ 		return 0;
++>>>>>>> 247f139cdae7 (net/mlx5: Change the acl enable prototype to return status)
  
  	esw_debug(dev, "Create vport[%d] ingress ACL log_max_size(%d)\n",
  		  vport->vport, MLX5_CAP_ESW_INGRESS_ACL(dev, log_max_ft_size));
@@@ -921,10 -1083,10 +952,10 @@@
  
  	flow_group_in = mlx5_vzalloc(inlen);
  	if (!flow_group_in)
- 		return;
+ 		return -ENOMEM;
  
  	acl = mlx5_create_vport_flow_table(root_ns, 0, table_size, 0, vport->vport);
 -	if (IS_ERR(acl)) {
 +	if (IS_ERR_OR_NULL(acl)) {
  		err = PTR_ERR(acl);
  		esw_warn(dev, "Failed to create E-Switch vport[%d] ingress flow Table, err(%d)\n",
  			 vport->vport, err);
@@@ -1057,8 -1226,18 +1089,20 @@@ static int esw_vport_ingress_config(str
  
  	esw_vport_cleanup_ingress_rules(esw, vport);
  
 -	if (!vport->info.vlan && !vport->info.qos && !vport->info.spoofchk) {
 -		esw_vport_disable_ingress_acl(esw, vport);
 +	if (!vport->vlan && !vport->qos)
  		return 0;
++<<<<<<< HEAD
++=======
+ 	}
+ 
+ 	err = esw_vport_enable_ingress_acl(esw, vport);
+ 	if (err) {
+ 		mlx5_core_warn(esw->dev,
+ 			       "failed to enable ingress acl (%d) on vport[%d]\n",
+ 			       err, vport->vport);
+ 		return err;
+ 	}
++>>>>>>> 247f139cdae7 (net/mlx5: Change the acl enable prototype to return status)
  
  	esw_debug(esw->dev,
  		  "vport[%d] configure ingress rules, vlan(%d) qos(%d)\n",
@@@ -1097,20 -1301,23 +1141,32 @@@ out
  static int esw_vport_egress_config(struct mlx5_eswitch *esw,
  				   struct mlx5_vport *vport)
  {
 -	struct mlx5_flow_spec *spec;
 +	u32 *match_v;
 +	u32 *match_c;
  	int err = 0;
  
 +	if (IS_ERR_OR_NULL(vport->egress.acl)) {
 +		esw_warn(esw->dev, "vport[%d] configure rgress rules failed, egress acl is not initialized!\n",
 +			 vport->vport);
 +		return -EPERM;
 +	}
 +
  	esw_vport_cleanup_egress_rules(esw, vport);
  
 -	if (!vport->info.vlan && !vport->info.qos) {
 -		esw_vport_disable_egress_acl(esw, vport);
 +	if (!vport->vlan && !vport->qos)
  		return 0;
++<<<<<<< HEAD
++=======
+ 	}
+ 
+ 	err = esw_vport_enable_egress_acl(esw, vport);
+ 	if (err) {
+ 		mlx5_core_warn(esw->dev,
+ 			       "failed to enable egress acl (%d) on vport[%d]\n",
+ 			       err, vport->vport);
+ 		return err;
+ 	}
++>>>>>>> 247f139cdae7 (net/mlx5: Change the acl enable prototype to return status)
  
  	esw_debug(esw->dev,
  		  "vport[%d] configure egress rules, vlan(%d) qos(%d)\n",
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
