net: sctp: implement rfc6458, 5.3.6. SCTP_NXTINFO cmsg support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sctp: implement rfc6458, 5.3.6. SCTP_NXTINFO cmsg support (Xin Long) [1339791]
Rebuild_FUZZ: 95.80%
commit-author Geir Ola Vaagland <geirola@gmail.com>
commit 2347c80ff127b94ddaa675e2b78ab4cef46dc905
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2347c80f.failed

This patch implements section 5.3.6. of RFC6458, that is, support
for 'SCTP Next Receive Information Structure' (SCTP_NXTINFO) which
is placed into ancillary data cmsghdr structure for each recvmsg()
call, if this information is already available when delivering the
current message.

This option can be enabled/disabled via setsockopt(2) on SOL_SCTP
level by setting an int value with 1/0 for SCTP_RECVNXTINFO in
user space applications as per RFC6458, section 8.1.30.

The sctp_nxtinfo structure is defined as per RFC as below ...

  struct sctp_nxtinfo {
    uint16_t nxt_sid;
    uint16_t nxt_flags;
    uint32_t nxt_ppid;
    uint32_t nxt_length;
    sctp_assoc_t nxt_assoc_id;
  };

... and provided under cmsg_level IPPROTO_SCTP, cmsg_type
SCTP_NXTINFO, while cmsg_data[] contains struct sctp_nxtinfo.

Joint work with Daniel Borkmann.

	Signed-off-by: Geir Ola Vaagland <geirola@gmail.com>
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2347c80ff127b94ddaa675e2b78ab4cef46dc905)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sctp/structs.h
#	include/net/sctp/ulpevent.h
#	include/uapi/linux/sctp.h
#	net/sctp/socket.c
#	net/sctp/ulpevent.c
diff --cc include/net/sctp/structs.h
index 4f9d7015fcef,7741d1b66967..000000000000
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@@ -214,17 -207,18 +214,22 @@@ struct sctp_sock 
  	struct sctp_paddrparams paddrparam;
  	struct sctp_event_subscribe subscribe;
  	struct sctp_assocparams assocparams;
 -
  	int user_frag;
 -
  	__u32 autoclose;
 -	__u8 nodelay;
 -	__u8 disable_fragments;
 -	__u8 v4mapped;
 -	__u8 frag_interleave;
  	__u32 adaptation_ind;
  	__u32 pd_point;
++<<<<<<< HEAD
 +	__u16	nodelay:1,
 +		disable_fragments:1,
 +		v4mapped:1,
 +		frag_interleave:1,
 +		_reserved1:1,
 +		_reserved2:1,
 +		data_ready_signalled:1;
++=======
+ 	__u8 recvrcvinfo;
+ 	__u8 recvnxtinfo;
++>>>>>>> 2347c80ff127 (net: sctp: implement rfc6458, 5.3.6. SCTP_NXTINFO cmsg support)
  
  	atomic_t pd_mode;
  	/* Receive to here while partial delivery is in effect. */
diff --cc include/net/sctp/ulpevent.h
index 42fbbfb99375,cccdcfd14973..000000000000
--- a/include/net/sctp/ulpevent.h
+++ b/include/net/sctp/ulpevent.h
@@@ -136,7 -129,12 +136,16 @@@ struct sctp_ulpevent *sctp_ulpevent_mak
  	const struct sctp_association *asoc, gfp_t gfp);
  
  void sctp_ulpevent_read_sndrcvinfo(const struct sctp_ulpevent *event,
++<<<<<<< HEAD
 +	struct msghdr *);
++=======
+ 				   struct msghdr *);
+ void sctp_ulpevent_read_rcvinfo(const struct sctp_ulpevent *event,
+ 				struct msghdr *);
+ void sctp_ulpevent_read_nxtinfo(const struct sctp_ulpevent *event,
+ 				struct msghdr *, struct sock *sk);
+ 
++>>>>>>> 2347c80ff127 (net: sctp: implement rfc6458, 5.3.6. SCTP_NXTINFO cmsg support)
  __u16 sctp_ulpevent_get_notification_type(const struct sctp_ulpevent *event);
  
  /* Is this event type enabled? */
diff --cc include/uapi/linux/sctp.h
index f99df6a81072,222f82ffeca4..000000000000
--- a/include/uapi/linux/sctp.h
+++ b/include/uapi/linux/sctp.h
@@@ -96,6 -95,8 +96,11 @@@ typedef __s32 sctp_assoc_t
  #define SCTP_GET_ASSOC_ID_LIST	29	/* Read only */
  #define SCTP_AUTO_ASCONF       30
  #define SCTP_PEER_ADDR_THLDS	31
++<<<<<<< HEAD
++=======
+ #define SCTP_RECVRCVINFO	32
+ #define SCTP_RECVNXTINFO	33
++>>>>>>> 2347c80ff127 (net: sctp: implement rfc6458, 5.3.6. SCTP_NXTINFO cmsg support)
  
  /* Internal Socket Options. Some of the sctp library functions are
   * implemented using these socket options.
@@@ -110,34 -111,15 +115,45 @@@
  #define SCTP_SOCKOPT_CONNECTX	110		/* CONNECTX requests. */
  #define SCTP_SOCKOPT_CONNECTX3	111	/* CONNECTX requests (updated) */
  #define SCTP_GET_ASSOC_STATS	112	/* Read only */
 +#define SCTP_PR_SUPPORTED	113
 +#define SCTP_DEFAULT_PRINFO	114
 +#define SCTP_PR_ASSOC_STATUS	115
 +
++<<<<<<< HEAD
 +/* PR-SCTP policies */
 +#define SCTP_PR_SCTP_NONE	0x0000
 +#define SCTP_PR_SCTP_TTL	0x0010
 +#define SCTP_PR_SCTP_RTX	0x0020
 +#define SCTP_PR_SCTP_PRIO	0x0030
 +#define SCTP_PR_SCTP_MAX	SCTP_PR_SCTP_PRIO
 +#define SCTP_PR_SCTP_MASK	0x0030
 +
 +#define __SCTP_PR_INDEX(x)	((x >> 4) - 1)
 +#define SCTP_PR_INDEX(x)	__SCTP_PR_INDEX(SCTP_PR_SCTP_ ## x)
 +
 +#define SCTP_PR_POLICY(x)	((x) & SCTP_PR_SCTP_MASK)
 +#define SCTP_PR_SET_POLICY(flags, x)	\
 +	do {				\
 +		flags &= ~SCTP_PR_SCTP_MASK;	\
 +		flags |= x;		\
 +	} while (0)
 +
 +#define SCTP_PR_TTL_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_TTL)
 +#define SCTP_PR_RTX_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_RTX)
 +#define SCTP_PR_PRIO_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_PRIO)
  
 +/*
 + * 5.2.1 SCTP Initiation Structure (SCTP_INIT)
++=======
+ /* These are bit fields for msghdr->msg_flags.  See section 5.1.  */
+ /* On user space Linux, these live in <bits/socket.h> as an enum.  */
+ enum sctp_msg_flags {
+ 	MSG_NOTIFICATION = 0x8000,
+ #define MSG_NOTIFICATION MSG_NOTIFICATION
+ };
+ 
+ /* 5.3.1 SCTP Initiation Structure (SCTP_INIT)
++>>>>>>> 2347c80ff127 (net: sctp: implement rfc6458, 5.3.6. SCTP_NXTINFO cmsg support)
   *
   *   This cmsghdr structure provides information for initializing new
   *   SCTP associations with sendmsg().  The SCTP_INITMSG socket option
@@@ -180,19 -159,74 +196,78 @@@ struct sctp_sndrcvinfo 
  	sctp_assoc_t sinfo_assoc_id;
  };
  
++<<<<<<< HEAD
++=======
+ /* 5.3.4 SCTP Send Information Structure (SCTP_SNDINFO)
+  *
+  *   This cmsghdr structure specifies SCTP options for sendmsg().
+  *
+  *   cmsg_level    cmsg_type      cmsg_data[]
+  *   ------------  ------------   -------------------
+  *   IPPROTO_SCTP  SCTP_SNDINFO   struct sctp_sndinfo
+  */
+ struct sctp_sndinfo {
+ 	__u16 snd_sid;
+ 	__u16 snd_flags;
+ 	__u32 snd_ppid;
+ 	__u32 snd_context;
+ 	sctp_assoc_t snd_assoc_id;
+ };
+ 
+ /* 5.3.5 SCTP Receive Information Structure (SCTP_RCVINFO)
+  *
+  *   This cmsghdr structure describes SCTP receive information
+  *   about a received message through recvmsg().
+  *
+  *   cmsg_level    cmsg_type      cmsg_data[]
+  *   ------------  ------------   -------------------
+  *   IPPROTO_SCTP  SCTP_RCVINFO   struct sctp_rcvinfo
+  */
+ struct sctp_rcvinfo {
+ 	__u16 rcv_sid;
+ 	__u16 rcv_ssn;
+ 	__u16 rcv_flags;
+ 	__u32 rcv_ppid;
+ 	__u32 rcv_tsn;
+ 	__u32 rcv_cumtsn;
+ 	__u32 rcv_context;
+ 	sctp_assoc_t rcv_assoc_id;
+ };
+ 
+ /* 5.3.6 SCTP Next Receive Information Structure (SCTP_NXTINFO)
+  *
+  *   This cmsghdr structure describes SCTP receive information
+  *   of the next message that will be delivered through recvmsg()
+  *   if this information is already available when delivering
+  *   the current message.
+  *
+  *   cmsg_level    cmsg_type      cmsg_data[]
+  *   ------------  ------------   -------------------
+  *   IPPROTO_SCTP  SCTP_NXTINFO   struct sctp_nxtinfo
+  */
+ struct sctp_nxtinfo {
+ 	__u16 nxt_sid;
+ 	__u16 nxt_flags;
+ 	__u32 nxt_ppid;
+ 	__u32 nxt_length;
+ 	sctp_assoc_t nxt_assoc_id;
+ };
+ 
++>>>>>>> 2347c80ff127 (net: sctp: implement rfc6458, 5.3.6. SCTP_NXTINFO cmsg support)
  /*
   *  sinfo_flags: 16 bits (unsigned integer)
   *
   *   This field may contain any of the following flags and is composed of
   *   a bitwise OR of these values.
   */
 +
  enum sctp_sinfo_flags {
- 	SCTP_UNORDERED = 1,  /* Send/receive message unordered. */
- 	SCTP_ADDR_OVER = 2,  /* Override the primary destination. */
- 	SCTP_ABORT=4,        /* Send an ABORT message to the peer. */
- 	SCTP_SACK_IMMEDIATELY = 8,	/* SACK should be sent without delay */
- 	SCTP_EOF=MSG_FIN,    /* Initiate graceful shutdown process. */
+ 	SCTP_UNORDERED		= (1 << 0), /* Send/receive message unordered. */
+ 	SCTP_ADDR_OVER		= (1 << 1), /* Override the primary destination. */
+ 	SCTP_ABORT		= (1 << 2), /* Send an ABORT message to the peer. */
+ 	SCTP_SACK_IMMEDIATELY	= (1 << 3), /* SACK should be sent without delay. */
+ 	SCTP_NOTIFICATION	= MSG_NOTIFICATION, /* Next message is not user msg but notification. */
+ 	SCTP_EOF		= MSG_FIN,  /* Initiate graceful shutdown process. */
  };
  
  typedef union {
@@@ -203,10 -237,16 +278,19 @@@
  
  /* These are cmsg_types.  */
  typedef enum sctp_cmsg_type {
 -	SCTP_INIT,		/* 5.2.1 SCTP Initiation Structure */
 +	SCTP_INIT,              /* 5.2.1 SCTP Initiation Structure */
  #define SCTP_INIT	SCTP_INIT
 -	SCTP_SNDRCV,		/* 5.2.2 SCTP Header Information Structure */
 +	SCTP_SNDRCV,            /* 5.2.2 SCTP Header Information Structure */
  #define SCTP_SNDRCV	SCTP_SNDRCV
++<<<<<<< HEAD
++=======
+ 	SCTP_SNDINFO,		/* 5.3.4 SCTP Send Information Structure */
+ #define SCTP_SNDINFO	SCTP_SNDINFO
+ 	SCTP_RCVINFO,		/* 5.3.5 SCTP Receive Information Structure */
+ #define SCTP_RCVINFO	SCTP_RCVINFO
+ 	SCTP_NXTINFO,		/* 5.3.6 SCTP Next Receive Information Structure */
+ #define SCTP_NXTINFO	SCTP_NXTINFO
++>>>>>>> 2347c80ff127 (net: sctp: implement rfc6458, 5.3.6. SCTP_NXTINFO cmsg support)
  } sctp_cmsg_t;
  
  /*
diff --cc net/sctp/socket.c
index 3865a48c7d38,9bca87ee5152..000000000000
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@@ -2110,9 -2107,15 +2108,18 @@@ static int sctp_recvmsg(struct kiocb *i
  		msg->msg_flags |= MSG_NOTIFICATION;
  		sp->pf->event_msgname(event, msg->msg_name, addr_len);
  	} else {
 -		sp->pf->skb_msgname(skb, msg->msg_name, addr_len);
 +		sp->pf->skb_msgname(head_skb, msg->msg_name, addr_len);
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Check if we allow SCTP_NXTINFO. */
+ 	if (sp->recvnxtinfo)
+ 		sctp_ulpevent_read_nxtinfo(event, msg, sk);
+ 	/* Check if we allow SCTP_RCVINFO. */
+ 	if (sp->recvrcvinfo)
+ 		sctp_ulpevent_read_rcvinfo(event, msg);
++>>>>>>> 2347c80ff127 (net: sctp: implement rfc6458, 5.3.6. SCTP_NXTINFO cmsg support)
  	/* Check if we allow SCTP_SNDRCVINFO. */
  	if (sp->subscribe.sctp_data_io_event)
  		sctp_ulpevent_read_sndrcvinfo(event, msg);
@@@ -3585,80 -3596,38 +3592,96 @@@ static int sctp_setsockopt_paddr_thresh
  	return 0;
  }
  
 -static int sctp_setsockopt_recvrcvinfo(struct sock *sk,
 -				       char __user *optval,
 -				       unsigned int optlen)
 +static int sctp_setsockopt_pr_supported(struct sock *sk,
 +					char __user *optval,
 +					unsigned int optlen)
  {
 -	int val;
 +	struct sctp_assoc_value params;
 +	struct sctp_association *asoc;
 +	int retval = -EINVAL;
  
 -	if (optlen < sizeof(int))
 -		return -EINVAL;
 -	if (get_user(val, (int __user *) optval))
 -		return -EFAULT;
 +	if (optlen != sizeof(params))
 +		goto out;
  
 -	sctp_sk(sk)->recvrcvinfo = (val == 0) ? 0 : 1;
 +	if (copy_from_user(&params, optval, optlen)) {
 +		retval = -EFAULT;
 +		goto out;
 +	}
  
 -	return 0;
 +	asoc = sctp_id2assoc(sk, params.assoc_id);
 +	if (asoc) {
 +		asoc->prsctp_enable = !!params.assoc_value;
 +	} else if (!params.assoc_id) {
 +		struct sctp_sock *sp = sctp_sk(sk);
 +
 +		sp->ep->prsctp_enable = !!params.assoc_value;
 +	} else {
 +		goto out;
 +	}
 +
 +	retval = 0;
 +
 +out:
 +	return retval;
 +}
 +
 +static int sctp_setsockopt_default_prinfo(struct sock *sk,
 +					  char __user *optval,
 +					  unsigned int optlen)
 +{
 +	struct sctp_default_prinfo info;
 +	struct sctp_association *asoc;
 +	int retval = -EINVAL;
 +
 +	if (optlen != sizeof(info))
 +		goto out;
 +
 +	if (copy_from_user(&info, optval, sizeof(info))) {
 +		retval = -EFAULT;
 +		goto out;
 +	}
 +
 +	if (info.pr_policy & ~SCTP_PR_SCTP_MASK)
 +		goto out;
 +
 +	if (info.pr_policy == SCTP_PR_SCTP_NONE)
 +		info.pr_value = 0;
 +
 +	asoc = sctp_id2assoc(sk, info.pr_assoc_id);
 +	if (asoc) {
 +		SCTP_PR_SET_POLICY(asoc->default_flags, info.pr_policy);
 +		asoc->default_timetolive = info.pr_value;
 +	} else if (!info.pr_assoc_id) {
 +		struct sctp_sock *sp = sctp_sk(sk);
 +
 +		SCTP_PR_SET_POLICY(sp->default_flags, info.pr_policy);
 +		sp->default_timetolive = info.pr_value;
 +	} else {
 +		goto out;
 +	}
 +
 +	retval = 0;
 +
 +out:
 +	return retval;
  }
  
+ static int sctp_setsockopt_recvnxtinfo(struct sock *sk,
+ 				       char __user *optval,
+ 				       unsigned int optlen)
+ {
+ 	int val;
+ 
+ 	if (optlen < sizeof(int))
+ 		return -EINVAL;
+ 	if (get_user(val, (int __user *) optval))
+ 		return -EFAULT;
+ 
+ 	sctp_sk(sk)->recvnxtinfo = (val == 0) ? 0 : 1;
+ 
+ 	return 0;
+ }
+ 
  /* API 6.2 setsockopt(), getsockopt()
   *
   * Applications use setsockopt() and getsockopt() to set or retrieve
@@@ -3810,12 -3779,12 +3833,15 @@@ static int sctp_setsockopt(struct sock 
  	case SCTP_PEER_ADDR_THLDS:
  		retval = sctp_setsockopt_paddr_thresholds(sk, optval, optlen);
  		break;
 -	case SCTP_RECVRCVINFO:
 -		retval = sctp_setsockopt_recvrcvinfo(sk, optval, optlen);
 +	case SCTP_PR_SUPPORTED:
 +		retval = sctp_setsockopt_pr_supported(sk, optval, optlen);
 +		break;
 +	case SCTP_DEFAULT_PRINFO:
 +		retval = sctp_setsockopt_default_prinfo(sk, optval, optlen);
  		break;
+ 	case SCTP_RECVNXTINFO:
+ 		retval = sctp_setsockopt_recvnxtinfo(sk, optval, optlen);
+ 		break;
  	default:
  		retval = -ENOPROTOOPT;
  		break;
@@@ -4065,6 -4031,9 +4091,12 @@@ static int sctp_init_sock(struct sock *
  	/* Enable Nagle algorithm by default.  */
  	sp->nodelay           = 0;
  
++<<<<<<< HEAD
++=======
+ 	sp->recvrcvinfo = 0;
+ 	sp->recvnxtinfo = 0;
+ 
++>>>>>>> 2347c80ff127 (net: sctp: implement rfc6458, 5.3.6. SCTP_NXTINFO cmsg support)
  	/* Enable by default. */
  	sp->v4mapped          = 1;
  
@@@ -6070,148 -5815,46 +6102,168 @@@ static int sctp_getsockopt_assoc_stats(
  	return 0;
  }
  
 -static int sctp_getsockopt_recvrcvinfo(struct sock *sk,	int len,
 -				       char __user *optval,
 -				       int __user *optlen)
 +static int sctp_getsockopt_pr_supported(struct sock *sk, int len,
 +					char __user *optval,
 +					int __user *optlen)
  {
 -	int val = 0;
 +	struct sctp_assoc_value params;
 +	struct sctp_association *asoc;
 +	int retval = -EFAULT;
  
 -	if (len < sizeof(int))
 -		return -EINVAL;
 +	if (len < sizeof(params)) {
 +		retval = -EINVAL;
 +		goto out;
 +	}
 +
 +	len = sizeof(params);
 +	if (copy_from_user(&params, optval, len))
 +		goto out;
 +
 +	asoc = sctp_id2assoc(sk, params.assoc_id);
 +	if (asoc) {
 +		params.assoc_value = asoc->prsctp_enable;
 +	} else if (!params.assoc_id) {
 +		struct sctp_sock *sp = sctp_sk(sk);
 +
 +		params.assoc_value = sp->ep->prsctp_enable;
 +	} else {
 +		retval = -EINVAL;
 +		goto out;
 +	}
  
 -	len = sizeof(int);
 -	if (sctp_sk(sk)->recvrcvinfo)
 -		val = 1;
  	if (put_user(len, optlen))
 -		return -EFAULT;
 -	if (copy_to_user(optval, &val, len))
 -		return -EFAULT;
 +		goto out;
  
 -	return 0;
 +	if (copy_to_user(optval, &params, len))
 +		goto out;
 +
 +	retval = 0;
 +
 +out:
 +	return retval;
 +}
 +
 +static int sctp_getsockopt_default_prinfo(struct sock *sk, int len,
 +					  char __user *optval,
 +					  int __user *optlen)
 +{
 +	struct sctp_default_prinfo info;
 +	struct sctp_association *asoc;
 +	int retval = -EFAULT;
 +
 +	if (len < sizeof(info)) {
 +		retval = -EINVAL;
 +		goto out;
 +	}
 +
 +	len = sizeof(info);
 +	if (copy_from_user(&info, optval, len))
 +		goto out;
 +
 +	asoc = sctp_id2assoc(sk, info.pr_assoc_id);
 +	if (asoc) {
 +		info.pr_policy = SCTP_PR_POLICY(asoc->default_flags);
 +		info.pr_value = asoc->default_timetolive;
 +	} else if (!info.pr_assoc_id) {
 +		struct sctp_sock *sp = sctp_sk(sk);
 +
 +		info.pr_policy = SCTP_PR_POLICY(sp->default_flags);
 +		info.pr_value = sp->default_timetolive;
 +	} else {
 +		retval = -EINVAL;
 +		goto out;
 +	}
 +
 +	if (put_user(len, optlen))
 +		goto out;
 +
 +	if (copy_to_user(optval, &info, len))
 +		goto out;
 +
 +	retval = 0;
 +
 +out:
 +	return retval;
 +}
 +
 +static int sctp_getsockopt_pr_assocstatus(struct sock *sk, int len,
 +					  char __user *optval,
 +					  int __user *optlen)
 +{
 +	struct sctp_prstatus params;
 +	struct sctp_association *asoc;
 +	int policy;
 +	int retval = -EINVAL;
 +
 +	if (len < sizeof(params))
 +		goto out;
 +
 +	len = sizeof(params);
 +	if (copy_from_user(&params, optval, len)) {
 +		retval = -EFAULT;
 +		goto out;
 +	}
 +
 +	policy = params.sprstat_policy;
 +	if (policy & ~SCTP_PR_SCTP_MASK)
 +		goto out;
 +
 +	asoc = sctp_id2assoc(sk, params.sprstat_assoc_id);
 +	if (!asoc)
 +		goto out;
 +
 +	if (policy == SCTP_PR_SCTP_NONE) {
 +		params.sprstat_abandoned_unsent = 0;
 +		params.sprstat_abandoned_sent = 0;
 +		for (policy = 0; policy <= SCTP_PR_INDEX(MAX); policy++) {
 +			params.sprstat_abandoned_unsent +=
 +				asoc->abandoned_unsent[policy];
 +			params.sprstat_abandoned_sent +=
 +				asoc->abandoned_sent[policy];
 +		}
 +	} else {
 +		params.sprstat_abandoned_unsent =
 +			asoc->abandoned_unsent[__SCTP_PR_INDEX(policy)];
 +		params.sprstat_abandoned_sent =
 +			asoc->abandoned_sent[__SCTP_PR_INDEX(policy)];
 +	}
 +
 +	if (put_user(len, optlen)) {
 +		retval = -EFAULT;
 +		goto out;
 +	}
 +
 +	if (copy_to_user(optval, &params, len)) {
 +		retval = -EFAULT;
 +		goto out;
 +	}
 +
 +	retval = 0;
 +
 +out:
 +	return retval;
  }
  
+ static int sctp_getsockopt_recvnxtinfo(struct sock *sk,	int len,
+ 				       char __user *optval,
+ 				       int __user *optlen)
+ {
+ 	int val = 0;
+ 
+ 	if (len < sizeof(int))
+ 		return -EINVAL;
+ 
+ 	len = sizeof(int);
+ 	if (sctp_sk(sk)->recvnxtinfo)
+ 		val = 1;
+ 	if (put_user(len, optlen))
+ 		return -EFAULT;
+ 	if (copy_to_user(optval, &val, len))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
  static int sctp_getsockopt(struct sock *sk, int level, int optname,
  			   char __user *optval, int __user *optlen)
  {
@@@ -6355,17 -5998,12 +6407,20 @@@
  	case SCTP_GET_ASSOC_STATS:
  		retval = sctp_getsockopt_assoc_stats(sk, len, optval, optlen);
  		break;
 -	case SCTP_RECVRCVINFO:
 -		retval = sctp_getsockopt_recvrcvinfo(sk, len, optval, optlen);
 +	case SCTP_PR_SUPPORTED:
 +		retval = sctp_getsockopt_pr_supported(sk, len, optval, optlen);
 +		break;
 +	case SCTP_DEFAULT_PRINFO:
 +		retval = sctp_getsockopt_default_prinfo(sk, len, optval,
 +							optlen);
 +		break;
 +	case SCTP_PR_ASSOC_STATUS:
 +		retval = sctp_getsockopt_pr_assocstatus(sk, len, optval,
 +							optlen);
  		break;
+ 	case SCTP_RECVNXTINFO:
+ 		retval = sctp_getsockopt_recvnxtinfo(sk, len, optval, optlen);
+ 		break;
  	default:
  		retval = -ENOPROTOOPT;
  		break;
diff --cc net/sctp/ulpevent.c
index 36628efae234,e049298ecfa0..000000000000
--- a/net/sctp/ulpevent.c
+++ b/net/sctp/ulpevent.c
@@@ -902,6 -886,69 +902,72 @@@ void sctp_ulpevent_read_sndrcvinfo(cons
  		 sizeof(sinfo), &sinfo);
  }
  
++<<<<<<< HEAD
++=======
+ /* RFC6458, Section 5.3.5 SCTP Receive Information Structure
+  * (SCTP_SNDRCV)
+  */
+ void sctp_ulpevent_read_rcvinfo(const struct sctp_ulpevent *event,
+ 				struct msghdr *msghdr)
+ {
+ 	struct sctp_rcvinfo rinfo;
+ 
+ 	if (sctp_ulpevent_is_notification(event))
+ 		return;
+ 
+ 	memset(&rinfo, 0, sizeof(struct sctp_rcvinfo));
+ 	rinfo.rcv_sid = event->stream;
+ 	rinfo.rcv_ssn = event->ssn;
+ 	rinfo.rcv_ppid = event->ppid;
+ 	rinfo.rcv_flags = event->flags;
+ 	rinfo.rcv_tsn = event->tsn;
+ 	rinfo.rcv_cumtsn = event->cumtsn;
+ 	rinfo.rcv_assoc_id = sctp_assoc2id(event->asoc);
+ 	rinfo.rcv_context = event->asoc->default_rcv_context;
+ 
+ 	put_cmsg(msghdr, IPPROTO_SCTP, SCTP_RCVINFO,
+ 		 sizeof(rinfo), &rinfo);
+ }
+ 
+ /* RFC6458, Section 5.3.6. SCTP Next Receive Information Structure
+  * (SCTP_NXTINFO)
+  */
+ static void __sctp_ulpevent_read_nxtinfo(const struct sctp_ulpevent *event,
+ 					 struct msghdr *msghdr,
+ 					 const struct sk_buff *skb)
+ {
+ 	struct sctp_nxtinfo nxtinfo;
+ 
+ 	memset(&nxtinfo, 0, sizeof(nxtinfo));
+ 	nxtinfo.nxt_sid = event->stream;
+ 	nxtinfo.nxt_ppid = event->ppid;
+ 	nxtinfo.nxt_flags = event->flags;
+ 	if (sctp_ulpevent_is_notification(event))
+ 		nxtinfo.nxt_flags |= SCTP_NOTIFICATION;
+ 	nxtinfo.nxt_length = skb->len;
+ 	nxtinfo.nxt_assoc_id = sctp_assoc2id(event->asoc);
+ 
+ 	put_cmsg(msghdr, IPPROTO_SCTP, SCTP_NXTINFO,
+ 		 sizeof(nxtinfo), &nxtinfo);
+ }
+ 
+ void sctp_ulpevent_read_nxtinfo(const struct sctp_ulpevent *event,
+ 				struct msghdr *msghdr,
+ 				struct sock *sk)
+ {
+ 	struct sk_buff *skb;
+ 	int err;
+ 
+ 	skb = sctp_skb_recv_datagram(sk, MSG_PEEK, 1, &err);
+ 	if (skb != NULL) {
+ 		__sctp_ulpevent_read_nxtinfo(sctp_skb2event(skb),
+ 					     msghdr, skb);
+ 		/* Just release refcount here. */
+ 		kfree_skb(skb);
+ 	}
+ }
+ 
++>>>>>>> 2347c80ff127 (net: sctp: implement rfc6458, 5.3.6. SCTP_NXTINFO cmsg support)
  /* Do accounting for bytes received and hold a reference to the association
   * for each skb.
   */
diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h
index 5e1b0dc26470..1f5c18ccdf86 100644
--- a/include/net/sctp/sctp.h
+++ b/include/net/sctp/sctp.h
@@ -121,6 +121,7 @@ void sctp_copy_sock(struct sock *newsk, struct sock *sk,
 		    struct sctp_association *asoc);
 extern struct percpu_counter sctp_sockets_allocated;
 int sctp_asconf_mgmt(struct sctp_sock *, struct sctp_sockaddr_entry *);
+struct sk_buff *sctp_skb_recv_datagram(struct sock *, int, int, int *);
 
 int sctp_transport_walk_start(struct rhashtable_iter *iter);
 void sctp_transport_walk_stop(struct rhashtable_iter *iter);
* Unmerged path include/net/sctp/structs.h
* Unmerged path include/net/sctp/ulpevent.h
* Unmerged path include/uapi/linux/sctp.h
* Unmerged path net/sctp/socket.c
* Unmerged path net/sctp/ulpevent.c
