btrfs: fix one bug that process may endlessly wait for ticket in wait_reserve_ticket()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Wang Xiaoguang <wangxg.fnst@cn.fujitsu.com>
commit e0af24849efb0eea572cf22d22bb65d164cb8a6f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e0af2484.failed

If can_overcommit() in btrfs_calc_reclaim_metadata_size() returns true,
btrfs_async_reclaim_metadata_space() will not reclaim metadata space, just
return directly and also forget to wake up process which are waiting for
their tickets, so these processes will wait endlessly.

Fstests case generic/172 with mount option "-o compress=lzo" have revealed
this bug in my test machine. Here if we have tickets to handle, we must
handle them first.

	Signed-off-by: Wang Xiaoguang <wangxg.fnst@cn.fujitsu.com>
	Reviewed-by: Josef Bacik <jbacik@fb.com>
	Signed-off-by: David Sterba <dsterba@suse.com>
(cherry picked from commit e0af24849efb0eea572cf22d22bb65d164cb8a6f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/extent-tree.c
diff --cc fs/btrfs/extent-tree.c
index b627133218e7,64676a16d32a..000000000000
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@@ -4811,18 -4896,22 +4811,32 @@@ static inline u6
  btrfs_calc_reclaim_metadata_size(struct btrfs_root *root,
  				 struct btrfs_space_info *space_info)
  {
 -	struct reserve_ticket *ticket;
  	u64 used;
  	u64 expected;
 -	u64 to_reclaim = 0;
 +	u64 to_reclaim;
  
++<<<<<<< HEAD
 +	to_reclaim = min_t(u64, num_online_cpus() * 1024 * 1024,
 +				16 * 1024 * 1024);
 +	spin_lock(&space_info->lock);
 +	if (can_overcommit(root, space_info, to_reclaim,
 +			   BTRFS_RESERVE_FLUSH_ALL)) {
 +		to_reclaim = 0;
 +		goto out;
 +	}
++=======
+ 	list_for_each_entry(ticket, &space_info->tickets, list)
+ 		to_reclaim += ticket->bytes;
+ 	list_for_each_entry(ticket, &space_info->priority_tickets, list)
+ 		to_reclaim += ticket->bytes;
+ 	if (to_reclaim)
+ 		return to_reclaim;
++>>>>>>> e0af24849efb (btrfs: fix one bug that process may endlessly wait for ticket in wait_reserve_ticket())
+ 
+ 	to_reclaim = min_t(u64, num_online_cpus() * SZ_1M, SZ_16M);
+ 	if (can_overcommit(root, space_info, to_reclaim,
+ 			   BTRFS_RESERVE_FLUSH_ALL))
+ 		return 0;
  
  	used = space_info->bytes_used + space_info->bytes_reserved +
  	       space_info->bytes_pinned + space_info->bytes_readonly +
* Unmerged path fs/btrfs/extent-tree.c
