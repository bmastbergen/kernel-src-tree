scsi: aacraid: Use correct channel number for raw srb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] aacraid: Use correct channel number for raw srb (Scott Benesh) [1384213]
Rebuild_FUZZ: 94.00%
commit-author Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
commit f3ef4a74dc3712ef0ce60d652aa87b1ba70cb2a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f3ef4a74.failed

The channel being used for raw srb commands is retrieved from the utility
sent fibs and is converted into physical channel id. The driver does not
need to to do this since the management utility sends the correct channel
id in the first place and in addition the driver sets inaccurate
information in the cmd sent to the firmware and gets an invalid response.

Fixed by using channel id from srb command.

	Cc: stable@vger.kernel.org
Fixes: 423400e64d377c0 ("scsi: aacraid: Include HBA direct interface")
	Signed-off-by: Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
	Reviewed-by: David Carroll <David.Carroll@microsemi.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit f3ef4a74dc3712ef0ce60d652aa87b1ba70cb2a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/aacraid/commctrl.c
diff --cc drivers/scsi/aacraid/commctrl.c
index d8a9c33600f5,f6afd50579c0..000000000000
--- a/drivers/scsi/aacraid/commctrl.c
+++ b/drivers/scsi/aacraid/commctrl.c
@@@ -589,13 -579,136 +589,80 @@@ static int aac_send_raw_srb(struct aac_
  		rcode = -EINVAL;
  		goto cleanup;
  	}
++<<<<<<< HEAD
 +	if ((data_dir == DMA_NONE) && user_srbcmd->sg.count) {
 +		dprintk((KERN_DEBUG"aacraid: SG with no direction specified in Raw SRB command\n"));
 +		rcode = -EINVAL;
 +		goto cleanup;
++=======
+ 
+ 	chn = user_srbcmd->channel;
+ 	if (chn < AAC_MAX_BUSES && user_srbcmd->id < AAC_MAX_TARGETS &&
+ 		dev->hba_map[chn][user_srbcmd->id].devtype ==
+ 		AAC_DEVTYPE_NATIVE_RAW) {
+ 		is_native_device = 1;
+ 		hbacmd = (struct aac_hba_cmd_req *)srbfib->hw_fib_va;
+ 		memset(hbacmd, 0, 96);	/* sizeof(*hbacmd) is not necessary */
+ 
+ 		/* iu_type is a parameter of aac_hba_send */
+ 		switch (data_dir) {
+ 		case DMA_TO_DEVICE:
+ 			hbacmd->byte1 = 2;
+ 			break;
+ 		case DMA_FROM_DEVICE:
+ 		case DMA_BIDIRECTIONAL:
+ 			hbacmd->byte1 = 1;
+ 			break;
+ 		case DMA_NONE:
+ 		default:
+ 			break;
+ 		}
+ 		hbacmd->lun[1] = cpu_to_le32(user_srbcmd->lun);
+ 		hbacmd->it_nexus = dev->hba_map[chn][user_srbcmd->id].rmw_nexus;
+ 
+ 		/*
+ 		 * we fill in reply_qid later in aac_src_deliver_message
+ 		 * we fill in iu_type, request_id later in aac_hba_send
+ 		 * we fill in emb_data_desc_count, data_length later
+ 		 * in sg list build
+ 		 */
+ 
+ 		memcpy(hbacmd->cdb, user_srbcmd->cdb, sizeof(hbacmd->cdb));
+ 
+ 		address = (u64)srbfib->hw_error_pa;
+ 		hbacmd->error_ptr_hi = cpu_to_le32((u32)(address >> 32));
+ 		hbacmd->error_ptr_lo = cpu_to_le32((u32)(address & 0xffffffff));
+ 		hbacmd->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE);
+ 		hbacmd->emb_data_desc_count =
+ 					cpu_to_le32(user_srbcmd->sg.count);
+ 		srbfib->hbacmd_size = 64 +
+ 			user_srbcmd->sg.count * sizeof(struct aac_hba_sgl);
+ 
+ 	} else {
+ 		is_native_device = 0;
+ 		aac_fib_init(srbfib);
+ 
+ 		/* raw_srb FIB is not FastResponseCapable */
+ 		srbfib->hw_fib_va->header.XferState &=
+ 			~cpu_to_le32(FastResponseCapable);
+ 
+ 		srbcmd = (struct aac_srb *) fib_data(srbfib);
+ 
+ 		// Fix up srb for endian and force some values
+ 
+ 		srbcmd->function = cpu_to_le32(SRBF_ExecuteScsi); // Force this
+ 		srbcmd->channel	 = cpu_to_le32(user_srbcmd->channel);
+ 		srbcmd->id	 = cpu_to_le32(user_srbcmd->id);
+ 		srbcmd->lun	 = cpu_to_le32(user_srbcmd->lun);
+ 		srbcmd->timeout	 = cpu_to_le32(user_srbcmd->timeout);
+ 		srbcmd->flags	 = cpu_to_le32(flags);
+ 		srbcmd->retry_limit = 0; // Obsolete parameter
+ 		srbcmd->cdb_size = cpu_to_le32(user_srbcmd->cdb_size);
+ 		memcpy(srbcmd->cdb, user_srbcmd->cdb, sizeof(srbcmd->cdb));
++>>>>>>> f3ef4a74dc37 (scsi: aacraid: Use correct channel number for raw srb)
  	}
 -
  	byte_count = 0;
 -	if (is_native_device) {
 -		struct user_sgmap *usg32 = &user_srbcmd->sg;
 -		struct user_sgmap64 *usg64 =
 -			(struct user_sgmap64 *)&user_srbcmd->sg;
 -
 -		for (i = 0; i < usg32->count; i++) {
 -			void *p;
 -			u64 addr;
 -
 -			sg_count[i] = (actual_fibsize64 == fibsize) ?
 -				usg64->sg[i].count : usg32->sg[i].count;
 -			if (sg_count[i] >
 -				(dev->scsi_host_ptr->max_sectors << 9)) {
 -				pr_err("aacraid: upsg->sg[%d].count=%u>%u\n",
 -					i, sg_count[i],
 -					dev->scsi_host_ptr->max_sectors << 9);
 -				rcode = -EINVAL;
 -				goto cleanup;
 -			}
 -
 -			p = kmalloc(sg_count[i], GFP_KERNEL|__GFP_DMA);
 -			if (!p) {
 -				rcode = -ENOMEM;
 -				goto cleanup;
 -			}
 -
 -			if (actual_fibsize64 == fibsize) {
 -				addr = (u64)usg64->sg[i].addr[0];
 -				addr += ((u64)usg64->sg[i].addr[1]) << 32;
 -			} else {
 -				addr = (u64)usg32->sg[i].addr;
 -			}
 -
 -			sg_user[i] = (void __user *)(uintptr_t)addr;
 -			sg_list[i] = p; // save so we can clean up later
 -			sg_indx = i;
 -
 -			if (flags & SRB_DataOut) {
 -				if (copy_from_user(p, sg_user[i],
 -					sg_count[i])) {
 -					rcode = -EFAULT;
 -					goto cleanup;
 -				}
 -			}
 -			addr = pci_map_single(dev->pdev, p, sg_count[i],
 -						data_dir);
 -			hbacmd->sge[i].addr_hi = cpu_to_le32((u32)(addr>>32));
 -			hbacmd->sge[i].addr_lo = cpu_to_le32(
 -						(u32)(addr & 0xffffffff));
 -			hbacmd->sge[i].len = cpu_to_le32(sg_count[i]);
 -			hbacmd->sge[i].flags = 0;
 -			byte_count += sg_count[i];
 -		}
 -
 -		if (usg32->count > 0)	/* embedded sglist */
 -			hbacmd->sge[usg32->count-1].flags =
 -				cpu_to_le32(0x40000000);
 -		hbacmd->data_length = cpu_to_le32(byte_count);
 -
 -		status = aac_hba_send(HBA_IU_TYPE_SCSI_CMD_REQ, srbfib,
 -					NULL, NULL);
 -
 -	} else if (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64) {
 +	if (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64) {
  		struct user_sgmap64* upsg = (struct user_sgmap64*)&user_srbcmd->sg;
  		struct sgmap64* psg = (struct sgmap64*)&srbcmd->sg;
  
* Unmerged path drivers/scsi/aacraid/commctrl.c
