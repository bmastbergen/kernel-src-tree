drm/i915: Move updating color management to before vblank evasion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [drm] i915: Move updating color management to before vblank evasion (Rob Clark) [1422186]
Rebuild_FUZZ: 96.83%
commit-author Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
commit 567f0792a6ad11c0c2620944b8eeb777359fb85a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/567f0792.failed

This cannot be done reliably during vblank evasasion
since the color management registers are not double buffered.

The original commit that moved it always during vblank evasion was
wrong, so revert it to before vblank evasion again.

	Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Fixes: 20a34e78f0d7 ("drm/i915: Update color management during vblank evasion.")
	Cc: stable@vger.kernel.org # v4.7+
Link: http://patchwork.freedesktop.org/patch/msgid/1488292128-14540-1-git-send-email-maarten.lankhorst@linux.intel.com
	Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
(cherry picked from commit 567f0792a6ad11c0c2620944b8eeb777359fb85a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_display.c
diff --cc drivers/gpu/drm/i915/intel_display.c
index 460d1c5248a2,b2b0661ccbed..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -14099,25 -13335,36 +14099,38 @@@ static void intel_begin_crtc_commit(str
  	struct drm_device *dev = crtc->dev;
  	struct drm_i915_private *dev_priv = to_i915(dev);
  	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 -	struct intel_crtc_state *intel_cstate =
 -		to_intel_crtc_state(crtc->state);
 -	struct intel_crtc_state *old_intel_cstate =
 +	struct intel_crtc_state *old_intel_state =
  		to_intel_crtc_state(old_crtc_state);
 -	struct intel_atomic_state *old_intel_state =
 -		to_intel_atomic_state(old_crtc_state->state);
  	bool modeset = needs_modeset(crtc->state);
 +	enum pipe pipe = intel_crtc->pipe;
  
+ 	if (!modeset &&
+ 	    (intel_cstate->base.color_mgmt_changed ||
+ 	     intel_cstate->update_pipe)) {
+ 		intel_color_set_csc(crtc->state);
+ 		intel_color_load_luts(crtc->state);
+ 	}
+ 
  	/* Perform vblank evasion around commit operation */
  	intel_pipe_update_start(intel_crtc);
  
  	if (modeset)
 -		goto out;
 +		return;
  
++<<<<<<< HEAD
 +	if (to_intel_crtc_state(crtc->state)->update_pipe)
 +		intel_update_pipe_config(intel_crtc, old_intel_state);
 +	else if (dev_priv->info.gen >= 9) {
++=======
+ 	if (intel_cstate->update_pipe)
+ 		intel_update_pipe_config(intel_crtc, old_intel_cstate);
+ 	else if (INTEL_GEN(dev_priv) >= 9)
++>>>>>>> 567f0792a6ad (drm/i915: Move updating color management to before vblank evasion)
  		skl_detach_scalers(intel_crtc);
  
 -out:
 -	if (dev_priv->display.atomic_update_watermarks)
 -		dev_priv->display.atomic_update_watermarks(old_intel_state,
 -							   intel_cstate);
 +		I915_WRITE(PIPE_WM_LINETIME(pipe),
 +			   dev_priv->wm.skl_hw.wm_linetime[pipe]);
 +	}
  }
  
  static void intel_finish_crtc_commit(struct drm_crtc *crtc,
* Unmerged path drivers/gpu/drm/i915/intel_display.c
