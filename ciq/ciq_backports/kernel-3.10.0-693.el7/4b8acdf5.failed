amd-xgbe: Update how to determine DMA channel status

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit 4b8acdf5fe97d01962f3a62eaff3f010f8de5869
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4b8acdf5.failed

Tx and Rx DMA channel status determiniation is different depending on the
version of the hardware. Update the channel status processing code to
account for the change.  Also, reduce the timeout value used when stopping
the channels.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4b8acdf5fe97d01962f3a62eaff3f010f8de5869)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-dev.c
#	drivers/net/ethernet/amd/xgbe/xgbe.h
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-dev.c
index a748fd8a1c58,0a7ab63deaf9..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
@@@ -1945,6 -2944,75 +1945,78 @@@ static void xgbe_config_mmc(struct xgbe
  	XGMAC_IOWRITE_BITS(pdata, MMC_CR, CR, 1);
  }
  
++<<<<<<< HEAD
++=======
+ static void xgbe_txq_prepare_tx_stop(struct xgbe_prv_data *pdata,
+ 				     unsigned int queue)
+ {
+ 	unsigned int tx_status;
+ 	unsigned long tx_timeout;
+ 
+ 	/* The Tx engine cannot be stopped if it is actively processing
+ 	 * packets. Wait for the Tx queue to empty the Tx fifo.  Don't
+ 	 * wait forever though...
+ 	 */
+ 	tx_timeout = jiffies + (XGBE_DMA_STOP_TIMEOUT * HZ);
+ 	while (time_before(jiffies, tx_timeout)) {
+ 		tx_status = XGMAC_MTL_IOREAD(pdata, queue, MTL_Q_TQDR);
+ 		if ((XGMAC_GET_BITS(tx_status, MTL_Q_TQDR, TRCSTS) != 1) &&
+ 		    (XGMAC_GET_BITS(tx_status, MTL_Q_TQDR, TXQSTS) == 0))
+ 			break;
+ 
+ 		usleep_range(500, 1000);
+ 	}
+ 
+ 	if (!time_before(jiffies, tx_timeout))
+ 		netdev_info(pdata->netdev,
+ 			    "timed out waiting for Tx queue %u to empty\n",
+ 			    queue);
+ }
+ 
+ static void xgbe_prepare_tx_stop(struct xgbe_prv_data *pdata,
+ 				 unsigned int queue)
+ {
+ 	unsigned int tx_dsr, tx_pos, tx_qidx;
+ 	unsigned int tx_status;
+ 	unsigned long tx_timeout;
+ 
+ 	if (XGMAC_GET_BITS(pdata->hw_feat.version, MAC_VR, SNPSVER) > 0x20)
+ 		return xgbe_txq_prepare_tx_stop(pdata, queue);
+ 
+ 	/* Calculate the status register to read and the position within */
+ 	if (queue < DMA_DSRX_FIRST_QUEUE) {
+ 		tx_dsr = DMA_DSR0;
+ 		tx_pos = (queue * DMA_DSR_Q_WIDTH) + DMA_DSR0_TPS_START;
+ 	} else {
+ 		tx_qidx = queue - DMA_DSRX_FIRST_QUEUE;
+ 
+ 		tx_dsr = DMA_DSR1 + ((tx_qidx / DMA_DSRX_QPR) * DMA_DSRX_INC);
+ 		tx_pos = ((tx_qidx % DMA_DSRX_QPR) * DMA_DSR_Q_WIDTH) +
+ 			 DMA_DSRX_TPS_START;
+ 	}
+ 
+ 	/* The Tx engine cannot be stopped if it is actively processing
+ 	 * descriptors. Wait for the Tx engine to enter the stopped or
+ 	 * suspended state.  Don't wait forever though...
+ 	 */
+ 	tx_timeout = jiffies + (XGBE_DMA_STOP_TIMEOUT * HZ);
+ 	while (time_before(jiffies, tx_timeout)) {
+ 		tx_status = XGMAC_IOREAD(pdata, tx_dsr);
+ 		tx_status = GET_BITS(tx_status, tx_pos, DMA_DSR_TPS_WIDTH);
+ 		if ((tx_status == DMA_TPS_STOPPED) ||
+ 		    (tx_status == DMA_TPS_SUSPENDED))
+ 			break;
+ 
+ 		usleep_range(500, 1000);
+ 	}
+ 
+ 	if (!time_before(jiffies, tx_timeout))
+ 		netdev_info(pdata->netdev,
+ 			    "timed out waiting for Tx DMA channel %u to stop\n",
+ 			    queue);
+ }
+ 
++>>>>>>> 4b8acdf5fe97 (amd-xgbe: Update how to determine DMA channel status)
  static void xgbe_enable_tx(struct xgbe_prv_data *pdata)
  {
  	struct xgbe_channel *channel;
@@@ -1973,6 -3041,10 +2045,13 @@@ static void xgbe_disable_tx(struct xgbe
  	struct xgbe_channel *channel;
  	unsigned int i;
  
++<<<<<<< HEAD
++=======
+ 	/* Prepare for Tx DMA channel stop */
+ 	for (i = 0; i < pdata->tx_q_count; i++)
+ 		xgbe_prepare_tx_stop(pdata, i);
+ 
++>>>>>>> 4b8acdf5fe97 (amd-xgbe: Update how to determine DMA channel status)
  	/* Disable MAC Tx */
  	XGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 0);
  
@@@ -2064,6 -3166,10 +2143,13 @@@ static void xgbe_powerdown_tx(struct xg
  	struct xgbe_channel *channel;
  	unsigned int i;
  
++<<<<<<< HEAD
++=======
+ 	/* Prepare for Tx DMA channel stop */
+ 	for (i = 0; i < pdata->tx_q_count; i++)
+ 		xgbe_prepare_tx_stop(pdata, i);
+ 
++>>>>>>> 4b8acdf5fe97 (amd-xgbe: Update how to determine DMA channel status)
  	/* Disable MAC Tx */
  	XGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 0);
  
diff --cc drivers/net/ethernet/amd/xgbe/xgbe.h
index 1903f878545a,d5cae1557908..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@@ -135,10 -140,26 +135,16 @@@
  
  #define XGBE_TX_MAX_BUF_SIZE	(0x3fff & ~(64 - 1))
  
 -/* Descriptors required for maximum contiguous TSO/GSO packet */
 -#define XGBE_TX_MAX_SPLIT	((GSO_MAX_SIZE / XGBE_TX_MAX_BUF_SIZE) + 1)
 -
 -/* Maximum possible descriptors needed for an SKB:
 - * - Maximum number of SKB frags
 - * - Maximum descriptors for contiguous TSO/GSO packet
 - * - Possible context descriptor
 - * - Possible TSO header descriptor
 - */
 -#define XGBE_TX_MAX_DESCS	(MAX_SKB_FRAGS + XGBE_TX_MAX_SPLIT + 2)
 -
  #define XGBE_RX_MIN_BUF_SIZE	(ETH_FRAME_LEN + ETH_FCS_LEN + VLAN_HLEN)
  #define XGBE_RX_BUF_ALIGN	64
 -#define XGBE_SKB_ALLOC_SIZE	256
 -#define XGBE_SPH_HDSMS_SIZE	2	/* Keep in sync with SKB_ALLOC_SIZE */
  
  #define XGBE_MAX_DMA_CHANNELS	16
++<<<<<<< HEAD
++=======
+ #define XGBE_MAX_QUEUES		16
+ #define XGBE_PRIORITY_QUEUES	8
+ #define XGBE_DMA_STOP_TIMEOUT	1
++>>>>>>> 4b8acdf5fe97 (amd-xgbe: Update how to determine DMA channel status)
  
  /* DMA cache settings - Outer sharable, write-back, write-allocate */
  #define XGBE_DMA_OS_AXDOMAIN	0x2
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-common.h b/drivers/net/ethernet/amd/xgbe/xgbe-common.h
index 3373e9ef2003..11cef6aa2ac3 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-common.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-common.h
@@ -686,6 +686,10 @@
 #define MTL_Q_RQOMR_RSF_WIDTH		1
 #define MTL_Q_RQOMR_RTC_INDEX		0
 #define MTL_Q_RQOMR_RTC_WIDTH		2
+#define MTL_Q_TQDR_TRCSTS_INDEX		1
+#define MTL_Q_TQDR_TRCSTS_WIDTH		2
+#define MTL_Q_TQDR_TXQSTS_INDEX		4
+#define MTL_Q_TQDR_TXQSTS_WIDTH		1
 #define MTL_Q_TQOMR_FTQ_INDEX		0
 #define MTL_Q_TQOMR_FTQ_WIDTH		1
 #define MTL_Q_TQOMR_TQS_INDEX		16
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-dev.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe.h
