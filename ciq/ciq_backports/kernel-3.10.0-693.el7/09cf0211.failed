bridge: mdb: fill state in br_mdb_notify

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit 09cf0211f970311383fdb453bbd5b3beeb294324
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/09cf0211.failed

Fill also the port group state when sending notifications.

	Signed-off-by: Satish Ashok <sashok@cumulusnetworks.com>
	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 09cf0211f970311383fdb453bbd5b3beeb294324)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_mdb.c
diff --cc net/bridge/br_mdb.c
index 6809915e67a5,1fb7d076f15c..000000000000
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@@ -347,9 -348,8 +348,13 @@@ static int br_mdb_add_group(struct net_
  	if (unlikely(!p))
  		return -ENOMEM;
  	rcu_assign_pointer(*pp, p);
 +	if (state == MDB_TEMPORARY)
 +		mod_timer(&p->timer, now + br->multicast_membership_interval);
  
++<<<<<<< HEAD
++=======
+ 	br_mdb_notify(br->dev, port, group, RTM_NEWMDB, state);
++>>>>>>> 09cf0211f970 (bridge: mdb: fill state in br_mdb_notify)
  	return 0;
  }
  
* Unmerged path net/bridge/br_mdb.c
diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c
index e18cf217ef81..b72523249eae 100644
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@ -692,7 +692,7 @@ static int br_multicast_add_group(struct net_bridge *br,
 	if (unlikely(!p))
 		goto err;
 	rcu_assign_pointer(*pp, p);
-	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
+	br_mdb_notify(br->dev, port, group, RTM_NEWMDB, MDB_TEMPORARY);
 
 found:
 	mod_timer(&p->timer, now + br->multicast_membership_interval);
@@ -1378,8 +1378,9 @@ br_multicast_leave_group(struct net_bridge *br,
 			rcu_assign_pointer(*pp, p->next);
 			hlist_del_init(&p->mglist);
 			del_timer(&p->timer);
+			br_mdb_notify(br->dev, port, group, RTM_DELMDB,
+				      p->state);
 			call_rcu_bh(&p->rcu, br_multicast_free_pg);
-			br_mdb_notify(br->dev, port, group, RTM_DELMDB);
 
 			if (!mp->ports && !mp->mglist &&
 			    netif_running(br->dev))
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 5a1b7346601e..a48dd6fc9ed3 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -483,7 +483,7 @@ br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
 void br_mdb_init(void);
 void br_mdb_uninit(void);
 void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
-		   struct br_ip *group, int type);
+		   struct br_ip *group, int type, u8 state);
 
 #define mlock_dereference(X, br) \
 	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
