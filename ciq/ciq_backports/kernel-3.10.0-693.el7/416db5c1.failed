nfp: remove support for nfp3200

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 416db5c1e448805866a6f23ebf7c78443f3d3bd5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/416db5c1.failed

Drop all code related to nfp3200.  It was never widely deployed
as a NIC.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 416db5c1e448805866a6f23ebf7c78443f3d3bd5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
#	drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net.h
index b7c0ef360c21,808c38ae4991..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@@ -411,8 -421,8 +411,7 @@@ static inline bool nfp_net_fw_ver_eq(st
   * @netdev:             Backpointer to net_device structure
   * @nfp_fallback:       Is the driver used in fallback mode?
   * @is_vf:              Is the driver attached to a VF?
-  * @is_nfp3200:         Is the driver for a NFP-3200 card?
   * @fw_loaded:          Is the firmware loaded?
 - * @bpf_offload_skip_sw:  Offloaded BPF program will not be rerun by cls_bpf
   * @ctrl:               Local copy of the control register/word.
   * @fl_bufsz:           Currently configured size of the freelist buffers
   * @rx_offset:		Offset in the RX buffers where packet data starts
@@@ -471,8 -486,8 +470,7 @@@ struct nfp_net 
  
  	unsigned nfp_fallback:1;
  	unsigned is_vf:1;
- 	unsigned is_nfp3200:1;
  	unsigned fw_loaded:1;
 -	unsigned bpf_offload_skip_sw:1;
  
  	u32 ctrl;
  	u32 fl_bufsz;
@@@ -566,7 -591,15 +564,19 @@@ static inline void nn_writeb(struct nfp
  	writeb(val, nn->ctrl_bar + off);
  }
  
++<<<<<<< HEAD
 +/* NFP-3200 can't handle 16-bit accesses too well - hence no readw/writew */
++=======
+ static inline u16 nn_readw(struct nfp_net *nn, int off)
+ {
+ 	return readw(nn->ctrl_bar + off);
+ }
+ 
+ static inline void nn_writew(struct nfp_net *nn, int off, u16 val)
+ {
+ 	writew(val, nn->ctrl_bar + off);
+ }
++>>>>>>> 416db5c1e448 (nfp: remove support for nfp3200)
  
  static inline u32 nn_readl(struct nfp_net *nn, int off)
  {
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
index ad6c4e31cedd,385ba355c965..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
@@@ -196,10 -200,37 +191,23 @@@
  #define NFP_NET_CFG_VXLAN_SZ		  0x0008
  
  /**
++<<<<<<< HEAD
 + * 64B reserved for future use (0x0080 - 0x00c0)
++=======
+  * BPF section
+  * @NFP_NET_CFG_BPF_ABI:	BPF ABI version
+  * @NFP_NET_CFG_BPF_CAP:	BPF capabilities
+  * @NFP_NET_CFG_BPF_MAX_LEN:	Maximum size of JITed BPF code in bytes
+  * @NFP_NET_CFG_BPF_START:	Offset at which BPF will be loaded
+  * @NFP_NET_CFG_BPF_DONE:	Offset to jump to on exit
+  * @NFP_NET_CFG_BPF_STACK_SZ:	Total size of stack area in 64B chunks
+  * @NFP_NET_CFG_BPF_INL_MTU:	Packet data split offset in 64B chunks
+  * @NFP_NET_CFG_BPF_SIZE:	Size of the JITed BPF code in instructions
+  * @NFP_NET_CFG_BPF_ADDR:	DMA address of the buffer with JITed BPF code
++>>>>>>> 416db5c1e448 (nfp: remove support for nfp3200)
   */
 -#define NFP_NET_CFG_BPF_ABI		0x0080
 -#define   NFP_NET_BPF_ABI		1
 -#define NFP_NET_CFG_BPF_CAP		0x0081
 -#define   NFP_NET_BPF_CAP_RELO		(1 << 0) /* seamless reload */
 -#define NFP_NET_CFG_BPF_MAX_LEN		0x0082
 -#define NFP_NET_CFG_BPF_START		0x0084
 -#define NFP_NET_CFG_BPF_DONE		0x0086
 -#define NFP_NET_CFG_BPF_STACK_SZ	0x0088
 -#define NFP_NET_CFG_BPF_INL_MTU		0x0089
 -#define NFP_NET_CFG_BPF_SIZE		0x008e
 -#define NFP_NET_CFG_BPF_ADDR		0x0090
 -#define   NFP_NET_CFG_BPF_CFG_8CTX	(1 << 0) /* 8ctx mode */
 -#define   NFP_NET_CFG_BPF_CFG_MASK	7ULL
 -#define   NFP_NET_CFG_BPF_ADDR_MASK	(~NFP_NET_CFG_BPF_CFG_MASK)
 -
 -/**
 - * 40B reserved for future use (0x0098 - 0x00c0)
 - */
 -#define NFP_NET_CFG_RESERVED            0x0098
 -#define NFP_NET_CFG_RESERVED_SZ         0x0028
 +#define NFP_NET_CFG_RESERVED            0x0080
 +#define NFP_NET_CFG_RESERVED_SZ         0x0040
  
  /**
   * RSS configuration (0x0100 - 0x01ac):
diff --cc drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
index f7062cb648e1,d065235034d4..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
@@@ -148,16 -136,10 +136,23 @@@ static int nfp_netvf_pci_probe(struct p
  		dev_warn(&pdev->dev, "OBSOLETE Firmware detected - VF isolation not available\n");
  	} else {
  		switch (fw_ver.major) {
++<<<<<<< HEAD
 +		case 1 ... 3:
 +			if (is_nfp3200) {
 +				stride = 2;
 +				tx_bar_no = NFP_NET_Q0_BAR;
 +				rx_bar_no = NFP_NET_Q1_BAR;
 +			} else {
 +				stride = 4;
 +				tx_bar_no = NFP_NET_Q0_BAR;
 +				rx_bar_no = tx_bar_no;
 +			}
++=======
+ 		case 1 ... 4:
+ 			stride = 4;
+ 			tx_bar_no = NFP_NET_Q0_BAR;
+ 			rx_bar_no = tx_bar_no;
++>>>>>>> 416db5c1e448 (nfp: remove support for nfp3200)
  			break;
  		default:
  			dev_err(&pdev->dev, "Unsupported Firmware ABI %d.%d.%d.%d\n",
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net.h
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index b5384cc528b8..18d03d293729 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@ -247,44 +247,15 @@ int nfp_net_reconfig(struct nfp_net *nn, u32 update)
 /* Interrupt configuration and handling
  */
 
-/**
- * nfp_net_irq_unmask_msix() - Unmask MSI-X after automasking
- * @nn:       NFP Network structure
- * @entry_nr: MSI-X table entry
- *
- * Clear the MSI-X table mask bit for the given entry bypassing Linux irq
- * handling subsystem.  Use *only* to reenable automasked vectors.
- */
-static void nfp_net_irq_unmask_msix(struct nfp_net *nn, unsigned int entry_nr)
-{
-	struct list_head *msi_head = &nn->pdev->dev.msi_list;
-	struct msi_desc *entry;
-	u32 off;
-
-	/* All MSI-Xs have the same mask_base */
-	entry = list_first_entry(msi_head, struct msi_desc, list);
-
-	off = (PCI_MSIX_ENTRY_SIZE * entry_nr) +
-		PCI_MSIX_ENTRY_VECTOR_CTRL;
-	writel(0, entry->mask_base + off);
-	readl(entry->mask_base);
-}
-
 /**
  * nfp_net_irq_unmask() - Unmask automasked interrupt
  * @nn:       NFP Network structure
  * @entry_nr: MSI-X table entry
  *
- * If MSI-X auto-masking is enabled clear the mask bit, otherwise
- * clear the ICR for the entry.
+ * Clear the ICR for the IRQ entry.
  */
 static void nfp_net_irq_unmask(struct nfp_net *nn, unsigned int entry_nr)
 {
-	if (nn->ctrl & NFP_NET_CFG_CTRL_MSIXAUTO) {
-		nfp_net_irq_unmask_msix(nn, entry_nr);
-		return;
-	}
-
 	nn_writeb(nn, NFP_NET_CFG_ICR(entry_nr), NFP_NET_CFG_ICR_UNMASKED);
 	nn_pci_flush(nn);
 }
@@ -1333,20 +1304,6 @@ static void nfp_net_set_hash(struct net_device *netdev, struct sk_buff *skb,
  * more cleanly separate packet receive code from other bookkeeping
  * functions performed in the napi poll function.
  *
- * There are differences between the NFP-3200 firmware and the
- * NFP-6000 firmware.  The NFP-3200 firmware uses a dedicated RX queue
- * to indicate that new packets have arrived.  The NFP-6000 does not
- * have this queue and uses the DD bit in the RX descriptor. This
- * method cannot be used on the NFP-3200 as it causes a race
- * condition: The RX ring write pointer on the NFP-3200 is updated
- * after packets (and descriptors) have been DMAed.  If the DD bit is
- * used and subsequently the read pointer is updated this may lead to
- * the RX queue to underflow (if the firmware has not yet update the
- * write pointer).  Therefore we use slightly ugly conditional code
- * below to handle the differences.  We may, in the future update the
- * NFP-3200 firmware to behave the same as the firmware on the
- * NFP-6000.
- *
  * Return: Number of packets received.
  */
 static int nfp_net_rx(struct nfp_net_rx_ring *rx_ring, int budget)
@@ -1354,41 +1311,19 @@ static int nfp_net_rx(struct nfp_net_rx_ring *rx_ring, int budget)
 	struct nfp_net_r_vector *r_vec = rx_ring->r_vec;
 	struct nfp_net *nn = r_vec->nfp_net;
 	unsigned int data_len, meta_len;
-	int avail = 0, pkts_polled = 0;
 	struct sk_buff *skb, *new_skb;
 	struct nfp_net_rx_desc *rxd;
 	dma_addr_t new_dma_addr;
-	u32 qcp_wr_p;
+	int pkts_polled = 0;
 	int idx;
 
-	if (nn->is_nfp3200) {
-		/* Work out how many packets arrived */
-		qcp_wr_p = nfp_qcp_wr_ptr_read(rx_ring->qcp_rx);
-		idx = rx_ring->rd_p % rx_ring->cnt;
-
-		if (qcp_wr_p == idx)
-			/* No new packets */
-			return 0;
-
-		if (qcp_wr_p > idx)
-			avail = qcp_wr_p - idx;
-		else
-			avail = qcp_wr_p + rx_ring->cnt - idx;
-	} else {
-		avail = budget + 1;
-	}
-
-	while (avail > 0 && pkts_polled < budget) {
+	while (pkts_polled < budget) {
 		idx = rx_ring->rd_p % rx_ring->cnt;
 
 		rxd = &rx_ring->rxds[idx];
-		if (!(rxd->rxd.meta_len_dd & PCIE_DESC_RX_DD)) {
-			if (nn->is_nfp3200)
-				nn_dbg(nn, "RX descriptor not valid (DD)%d:%u rxd[0]=%#x rxd[1]=%#x\n",
-				       rx_ring->idx, idx,
-				       rxd->vals[0], rxd->vals[1]);
+		if (!(rxd->rxd.meta_len_dd & PCIE_DESC_RX_DD))
 			break;
-		}
+
 		/* Memory barrier to ensure that we won't do other reads
 		 * before the DD bit.
 		 */
@@ -1396,7 +1331,6 @@ static int nfp_net_rx(struct nfp_net_rx_ring *rx_ring, int budget)
 
 		rx_ring->rd_p++;
 		pkts_polled++;
-		avail--;
 
 		skb = rx_ring->rxbufs[idx].skb;
 
@@ -1458,9 +1392,6 @@ static int nfp_net_rx(struct nfp_net_rx_ring *rx_ring, int budget)
 		napi_gro_receive(&rx_ring->r_vec->napi, skb);
 	}
 
-	if (nn->is_nfp3200)
-		nfp_qcp_rd_ptr_add(rx_ring->qcp_rx, pkts_polled);
-
 	return pkts_polled;
 }
 
@@ -1845,9 +1776,8 @@ static void nfp_net_write_mac_addr(struct nfp_net *nn)
 {
 	nn_writel(nn, NFP_NET_CFG_MACADDR + 0,
 		  get_unaligned_be32(nn->netdev->dev_addr));
-	/* We can't do writew for NFP-3200 compatibility */
-	nn_writel(nn, NFP_NET_CFG_MACADDR + 4,
-		  get_unaligned_be16(nn->netdev->dev_addr + 4) << 16);
+	nn_writew(nn, NFP_NET_CFG_MACADDR + 6,
+		  get_unaligned_be16(nn->netdev->dev_addr + 4));
 }
 
 static void nfp_net_vec_clear_ring_data(struct nfp_net *nn, unsigned int idx)
@@ -2599,8 +2529,7 @@ static const struct net_device_ops nfp_net_netdev_ops = {
  */
 void nfp_net_info(struct nfp_net *nn)
 {
-	nn_info(nn, "Netronome %s %sNetdev: TxQs=%d/%d RxQs=%d/%d\n",
-		nn->is_nfp3200 ? "NFP-32xx" : "NFP-6xxx",
+	nn_info(nn, "Netronome NFP-6xxx %sNetdev: TxQs=%d/%d RxQs=%d/%d\n",
 		nn->is_vf ? "VF " : "",
 		nn->num_tx_rings, nn->max_tx_rings,
 		nn->num_rx_rings, nn->max_rx_rings);
@@ -2808,13 +2737,7 @@ int nfp_net_netdev_init(struct net_device *netdev)
 		nn->ctrl |= NFP_NET_CFG_CTRL_IRQMOD;
 	}
 
-	/* On NFP-3200 enable MSI-X auto-masking, if supported and the
-	 * interrupts are not shared.
-	 */
-	if (nn->is_nfp3200 && nn->cap & NFP_NET_CFG_CTRL_MSIXAUTO)
-		nn->ctrl |= NFP_NET_CFG_CTRL_MSIXAUTO;
-
-	/* On NFP4000/NFP6000, determine RX packet/metadata boundary offset */
+	/* Determine RX packet/metadata boundary offset */
 	if (nn->fw_ver.major >= 2)
 		nn->rx_offset = nn_readl(nn, NFP_NET_CFG_RX_OFFSET);
 	else
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_ctrl.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
