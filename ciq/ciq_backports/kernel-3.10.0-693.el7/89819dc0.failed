net_sched: convert tcf_hashinfo to hlist and use spinlock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: convert tcf_hashinfo to hlist and use spinlock (Ivan Vecera) [1420506]
Rebuild_FUZZ: 96.36%
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit 89819dc01f4c5920783f561597a48d9d75220e9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/89819dc0.failed

So that we don't need to play with singly linked list,
and since the code is not on hot path, we can use spinlock
instead of rwlock.

	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Cc: David S. Miller <davem@davemloft.net>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 89819dc01f4c5920783f561597a48d9d75220e9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/act_api.h
#	net/sched/act_api.c
#	net/sched/act_police.c
diff --cc include/net/act_api.h
index a72642610790,22418d1a8396..000000000000
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@@ -36,9 -36,9 +36,13 @@@ struct tcf_common 
  #define tcf_rcu		common.tcfc_rcu
  
  struct tcf_hashinfo {
- 	struct tcf_common	**htab;
+ 	struct hlist_head	*htab;
  	unsigned int		hmask;
++<<<<<<< HEAD
 +	rwlock_t		*lock;
++=======
+ 	spinlock_t		lock;
++>>>>>>> 89819dc01f4c (net_sched: convert tcf_hashinfo to hlist and use spinlock)
  };
  
  static inline unsigned int tcf_hash(u32 index, unsigned int hmask)
@@@ -46,6 -46,26 +50,29 @@@
  	return index & hmask;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int tcf_hashinfo_init(struct tcf_hashinfo *hf, unsigned int mask)
+ {
+ 	int i;
+ 
+ 	spin_lock_init(&hf->lock);
+ 	hf->hmask = mask;
+ 	hf->htab = kzalloc((mask + 1) * sizeof(struct hlist_head),
+ 			   GFP_KERNEL);
+ 	if (!hf->htab)
+ 		return -ENOMEM;
+ 	for (i = 0; i < mask + 1; i++)
+ 		INIT_HLIST_HEAD(&hf->htab[i]);
+ 	return 0;
+ }
+ 
+ static inline void tcf_hashinfo_destroy(struct tcf_hashinfo *hf)
+ {
+ 	kfree(hf->htab);
+ }
+ 
++>>>>>>> 89819dc01f4c (net_sched: convert tcf_hashinfo to hlist and use spinlock)
  #ifdef CONFIG_NET_CLS_ACT
  
  #define ACT_P_CREATED 1
diff --cc net/sched/act_api.c
index 814fabfe0de5,dc457c957656..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -29,25 -29,16 +29,38 @@@
  
  void tcf_hash_destroy(struct tcf_common *p, struct tcf_hashinfo *hinfo)
  {
++<<<<<<< HEAD
 +	unsigned int h = tcf_hash(p->tcfc_index, hinfo->hmask);
 +	struct tcf_common **p1p;
 +
 +	for (p1p = &hinfo->htab[h]; *p1p; p1p = &(*p1p)->tcfc_next) {
 +		if (*p1p == p) {
 +			write_lock_bh(hinfo->lock);
 +			*p1p = p->tcfc_next;
 +			write_unlock_bh(hinfo->lock);
 +			gen_kill_estimator(&p->tcfc_bstats,
 +					   &p->tcfc_rate_est);
 +			/*
 +			 * gen_estimator est_timer() might access p->tcfc_lock
 +			 * or bstats, wait a RCU grace period before freeing p
 +			 */
 +			kfree_rcu(p, tcfc_rcu);
 +			return;
 +		}
 +	}
 +	WARN_ON(1);
++=======
+ 	spin_lock_bh(&hinfo->lock);
+ 	hlist_del(&p->tcfc_head);
+ 	spin_unlock_bh(&hinfo->lock);
+ 	gen_kill_estimator(&p->tcfc_bstats,
+ 			   &p->tcfc_rate_est);
+ 	/*
+ 	 * gen_estimator est_timer() might access p->tcfc_lock
+ 	 * or bstats, wait a RCU grace period before freeing p
+ 	 */
+ 	kfree_rcu(p, tcfc_rcu);
++>>>>>>> 89819dc01f4c (net_sched: convert tcf_hashinfo to hlist and use spinlock)
  }
  EXPORT_SYMBOL(tcf_hash_destroy);
  
@@@ -77,7 -69,7 +91,11 @@@ static int tcf_dump_walker(struct sk_bu
  	int err = 0, index = -1, i = 0, s_i = 0, n_i = 0;
  	struct nlattr *nest;
  
++<<<<<<< HEAD
 +	read_lock_bh(hinfo->lock);
++=======
+ 	spin_lock_bh(&hinfo->lock);
++>>>>>>> 89819dc01f4c (net_sched: convert tcf_hashinfo to hlist and use spinlock)
  
  	s_i = cb->args[0];
  
@@@ -107,7 -99,7 +125,11 @@@
  		}
  	}
  done:
++<<<<<<< HEAD
 +	read_unlock_bh(hinfo->lock);
++=======
+ 	spin_unlock_bh(&hinfo->lock);
++>>>>>>> 89819dc01f4c (net_sched: convert tcf_hashinfo to hlist and use spinlock)
  	if (n_i)
  		cb->args[0] += n_i;
  	return n_i;
@@@ -168,15 -159,15 +189,25 @@@ EXPORT_SYMBOL(tcf_generic_walker)
  
  struct tcf_common *tcf_hash_lookup(u32 index, struct tcf_hashinfo *hinfo)
  {
- 	struct tcf_common *p;
+ 	struct tcf_common *p = NULL;
+ 	struct hlist_head *head;
  
++<<<<<<< HEAD
 +	read_lock_bh(hinfo->lock);
 +	for (p = hinfo->htab[tcf_hash(index, hinfo->hmask)]; p;
 +	     p = p->tcfc_next) {
 +		if (p->tcfc_index == index)
 +			break;
 +	}
 +	read_unlock_bh(hinfo->lock);
++=======
+ 	spin_lock_bh(&hinfo->lock);
+ 	head = &hinfo->htab[tcf_hash(index, hinfo->hmask)];
+ 	hlist_for_each_entry_rcu(p, head, tcfc_head)
+ 		if (p->tcfc_index == index)
+ 			break;
+ 	spin_unlock_bh(&hinfo->lock);
++>>>>>>> 89819dc01f4c (net_sched: convert tcf_hashinfo to hlist and use spinlock)
  
  	return p;
  }
@@@ -256,10 -249,9 +288,16 @@@ void tcf_hash_insert(struct tcf_common 
  {
  	unsigned int h = tcf_hash(p->tcfc_index, hinfo->hmask);
  
++<<<<<<< HEAD
 +	write_lock_bh(hinfo->lock);
 +	p->tcfc_next = hinfo->htab[h];
 +	hinfo->htab[h] = p;
 +	write_unlock_bh(hinfo->lock);
++=======
+ 	spin_lock_bh(&hinfo->lock);
+ 	hlist_add_head(&p->tcfc_head, &hinfo->htab[h]);
+ 	spin_unlock_bh(&hinfo->lock);
++>>>>>>> 89819dc01f4c (net_sched: convert tcf_hashinfo to hlist and use spinlock)
  }
  EXPORT_SYMBOL(tcf_hash_insert);
  
diff --cc net/sched/act_police.c
index 16a62c36928a,0cc305e7e469..000000000000
--- a/net/sched/act_police.c
+++ b/net/sched/act_police.c
@@@ -71,14 -65,14 +72,22 @@@ static int tcf_act_police_walker(struc
  	int err = 0, index = -1, i = 0, s_i = 0, n_i = 0;
  	struct nlattr *nest;
  
++<<<<<<< HEAD
 +	read_lock_bh(&police_lock);
++=======
+ 	spin_lock_bh(&police_hash_info.lock);
++>>>>>>> 89819dc01f4c (net_sched: convert tcf_hashinfo to hlist and use spinlock)
  
  	s_i = cb->args[0];
  
  	for (i = 0; i < (POL_TAB_MASK + 1); i++) {
++<<<<<<< HEAD
 +		p = tcf_police_ht[tcf_hash(i, POL_TAB_MASK)];
++=======
+ 		head = &police_hash_info.htab[tcf_hash(i, POL_TAB_MASK)];
++>>>>>>> 89819dc01f4c (net_sched: convert tcf_hashinfo to hlist and use spinlock)
  
- 		for (; p; p = p->tcfc_next) {
+ 		hlist_for_each_entry_rcu(p, head, tcfc_head) {
  			index++;
  			if (index < s_i)
  				continue;
@@@ -101,7 -95,7 +110,11 @@@
  		}
  	}
  done:
++<<<<<<< HEAD
 +	read_unlock_bh(&police_lock);
++=======
+ 	spin_unlock_bh(&police_hash_info.lock);
++>>>>>>> 89819dc01f4c (net_sched: convert tcf_hashinfo to hlist and use spinlock)
  	if (n_i)
  		cb->args[0] += n_i;
  	return n_i;
@@@ -113,25 -107,16 +126,38 @@@ nla_put_failure
  
  static void tcf_police_destroy(struct tcf_police *p)
  {
++<<<<<<< HEAD
 +	unsigned int h = tcf_hash(p->tcf_index, POL_TAB_MASK);
 +	struct tcf_common **p1p;
 +
 +	for (p1p = &tcf_police_ht[h]; *p1p; p1p = &(*p1p)->tcfc_next) {
 +		if (*p1p == &p->common) {
 +			write_lock_bh(&police_lock);
 +			*p1p = p->tcf_next;
 +			write_unlock_bh(&police_lock);
 +			gen_kill_estimator(&p->tcf_bstats,
 +					   &p->tcf_rate_est);
 +			/*
 +			 * gen_estimator est_timer() might access p->tcf_lock
 +			 * or bstats, wait a RCU grace period before freeing p
 +			 */
 +			kfree_rcu(p, tcf_rcu);
 +			return;
 +		}
 +	}
 +	WARN_ON(1);
++=======
+ 	spin_lock_bh(&police_hash_info.lock);
+ 	hlist_del(&p->tcf_head);
+ 	spin_unlock_bh(&police_hash_info.lock);
+ 	gen_kill_estimator(&p->tcf_bstats,
+ 			   &p->tcf_rate_est);
+ 	/*
+ 	 * gen_estimator est_timer() might access p->tcf_lock
+ 	 * or bstats, wait a RCU grace period before freeing p
+ 	 */
+ 	kfree_rcu(p, tcf_rcu);
++>>>>>>> 89819dc01f4c (net_sched: convert tcf_hashinfo to hlist and use spinlock)
  }
  
  static const struct nla_policy police_policy[TCA_POLICE_MAX + 1] = {
@@@ -266,10 -251,9 +292,16 @@@ override
  	police->tcf_index = parm->index ? parm->index :
  		tcf_hash_new_index(&police_idx_gen, &police_hash_info);
  	h = tcf_hash(police->tcf_index, POL_TAB_MASK);
++<<<<<<< HEAD
 +	write_lock_bh(&police_lock);
 +	police->tcf_next = tcf_police_ht[h];
 +	tcf_police_ht[h] = &police->common;
 +	write_unlock_bh(&police_lock);
++=======
+ 	spin_lock_bh(&police_hash_info.lock);
+ 	hlist_add_head(&police->tcf_head, &police_hash_info.htab[h]);
+ 	spin_unlock_bh(&police_hash_info.lock);
++>>>>>>> 89819dc01f4c (net_sched: convert tcf_hashinfo to hlist and use spinlock)
  
  	a->priv = police;
  	return ret;
* Unmerged path include/net/act_api.h
* Unmerged path net/sched/act_api.c
* Unmerged path net/sched/act_police.c
