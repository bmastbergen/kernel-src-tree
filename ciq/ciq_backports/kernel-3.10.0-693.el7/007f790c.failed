net: introduce generic switch devices support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] switchdev: introduce generic switch devices support (Ivan Vecera) [1275772 1297841 1331748]
Rebuild_FUZZ: 89.58%
commit-author Jiri Pirko <jiri@resnulli.us>
commit 007f790c8276271de26416f90d55561bcc96588a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/007f790c.failed

The goal of this is to provide a possibility to support various switch
chips. Drivers should implement relevant ndos to do so. Now there is
only one ndo defined:
- for getting physical switch id is in place.

Note that user can use random port netdevice to access the switch.

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Reviewed-by: Thomas Graf <tgraf@suug.ch>
	Acked-by: Andy Gospodarek <gospo@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 007f790c8276271de26416f90d55561bcc96588a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	net/Kconfig
#	net/Makefile
diff --cc include/linux/netdevice.h
index b6150f910ad9,3603f31e78f3..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1106,23 -994,36 +1106,35 @@@ struct net_device_ops_extended 
   *	address family that vxlan is not listening to anymore. The operation
   *	is protected by the vxlan_net->sock_lock.
   *
 - * void* (*ndo_dfwd_add_station)(struct net_device *pdev,
 - *				 struct net_device *dev)
 - *	Called by upper layer devices to accelerate switching or other
 - *	station functionality into hardware. 'pdev is the lowerdev
 - *	to use for the offload and 'dev' is the net device that will
 - *	back the offload. Returns a pointer to the private structure
 - *	the upper layer will maintain.
 - * void (*ndo_dfwd_del_station)(struct net_device *pdev, void *priv)
 - *	Called by upper layer device to delete the station created
 - *	by 'ndo_dfwd_add_station'. 'pdev' is the net device backing
 - *	the station and priv is the structure returned by the add
 - *	operation.
 - * netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *skb,
 - *				      struct net_device *dev,
 - *				      void *priv);
 - *	Callback to use for xmit over the accelerated station. This
 - *	is used in place of ndo_start_xmit on accelerated net
 - *	devices.
 - * bool	(*ndo_gso_check) (struct sk_buff *skb,
 - *			  struct net_device *dev);
 + * int (*ndo_get_iflink)(const struct net_device *dev);
 + *	Called to get the iflink value of this device.
 + *
 + * netdev_features_t (*ndo_features_check) (struct sk_buff *skb,
 + *					    struct net_device *dev
 + *					    netdev_features_t features);
   *	Called by core transmit path to determine if device is capable of
++<<<<<<< HEAD
 + *	performing offload operations on a given packet. This is to give
 + *	the device an opportunity to implement any restrictions that cannot
 + *	be otherwise expressed by feature flags. The check is called with
 + *	the set of features that the stack has calculated and it returns
 + *	those the driver believes to be appropriate.
 + * int (*ndo_fill_metadata_dst)(struct net_device *dev, struct sk_buff *skb);
 + *	This function is used to get egress tunnel information for given skb.
 + *	This is useful for retrieving outer tunnel header parameters while
 + *	sampling packet.
 + *
++=======
+  *	performing GSO on a packet. The device returns true if it is
+  *	able to GSO the packet, false otherwise. If the return value is
+  *	false the stack will do software GSO.
+  *
+  * int (*ndo_switch_parent_id_get)(struct net_device *dev,
+  *				   struct netdev_phys_item_id *psid);
+  *	Called to get an ID of the switch chip this port is part of.
+  *	If driver implements this, it indicates that it represents a port
+  *	of a switch chip.
++>>>>>>> 007f790c8276 (net: introduce generic switch devices support)
   */
  struct net_device_ops {
  	int			(*ndo_init)(struct net_device *dev);
@@@ -1284,70 -1166,23 +1296,83 @@@
  						      sa_family_t sa_family,
  						      __be16 port);
  
 -	void*			(*ndo_dfwd_add_station)(struct net_device *pdev,
 -							struct net_device *dev);
 -	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
 -							void *priv);
 -
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, int	(*ndo_get_iflink)(const struct net_device *dev))
 +	RH_KABI_USE_P(2, netdev_features_t
 +				(*ndo_features_check)(struct sk_buff *skb,
 +						      struct net_device *dev,
 +						      netdev_features_t features))
 +	RH_KABI_USE_P(3, int	(*ndo_set_vf_rate)(struct net_device *dev,
 +						   int vf, int min_tx_rate,
 +						   int max_tx_rate))
 +	RH_KABI_USE_P(4, int	(*ndo_get_vf_stats)(struct net_device *dev,
 +						    int vf,
 +						    struct ifla_vf_stats
 +						    *vf_stats))
 +	RH_KABI_USE_P(5, int    (*ndo_set_vf_rss_query_en)(struct net_device *dev,
 +							   int vf, bool setting))
 +
++<<<<<<< HEAD
 +	RH_KABI_USE_P(6, int	(*ndo_fdb_add)(struct ndmsg *ndm,
 +					       struct nlattr *tb[],
 +					       struct net_device *dev,
 +					       const unsigned char *addr,
 +					       u16 vid,
 +					       u16 flags))
 +	RH_KABI_USE_P(7,int	(*ndo_setup_tc)(struct net_device *dev,
 +						u32 handle,
 +						__be16 protocol,
 +						struct tc_to_netdev *tc))
 +	RH_KABI_USE_P(8, int	(*ndo_fill_metadata_dst)(struct net_device *dev,
 +						       struct sk_buff *skb))
 +	RH_KABI_USE_P(9, void	(*ndo_add_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_USE_P(10, void	(*ndo_del_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_USE_P(16, size_t ndo_size)
 +	/* RHEL: put all new non-performance critical ndo's into
 +	 * net_device_ops_extended. The reserved slots above can be used
 +	 * only for performance critical operations.
 +	 * Drivers may access the extended fields directly from
 +	 * net_device_ops, if they allocated the net_device_ops structure
 +	 * themselves (usually statically). The kernel core and drivers
 +	 * using others' net_device_ops must access the extended fields
 +	 * using the get_ndo_ext macro.
 +	 */
 +	RH_KABI_EXTEND(struct net_device_ops_extended extended)
++=======
+ 	netdev_tx_t		(*ndo_dfwd_start_xmit) (struct sk_buff *skb,
+ 							struct net_device *dev,
+ 							void *priv);
+ 	int			(*ndo_get_lock_subclass)(struct net_device *dev);
+ 	bool			(*ndo_gso_check) (struct sk_buff *skb,
+ 						  struct net_device *dev);
+ #ifdef CONFIG_NET_SWITCHDEV
+ 	int			(*ndo_switch_parent_id_get)(struct net_device *dev,
+ 							    struct netdev_phys_item_id *psid);
+ #endif
++>>>>>>> 007f790c8276 (net: introduce generic switch devices support)
  };
  
 +#define get_ndo_ext(ops, field)		({				\
 +	const struct net_device_ops *__ops = (ops);			\
 +	size_t __off = offsetof(struct net_device_ops, extended.field);	\
 +	__ops->ndo_size > __off ? __ops->extended.field : NULL;		\
 +	})
 +
  /**
   * enum net_device_priv_flags - &struct net_device priv_flags
   *
diff --cc net/Kconfig
index 41d41ae01a1c,ff9ffc17fa0e..000000000000
--- a/net/Kconfig
+++ b/net/Kconfig
@@@ -221,6 -227,8 +221,11 @@@ source "net/openvswitch/Kconfig
  source "net/vmw_vsock/Kconfig"
  source "net/netlink/Kconfig"
  source "net/mpls/Kconfig"
++<<<<<<< HEAD
++=======
+ source "net/hsr/Kconfig"
+ source "net/switchdev/Kconfig"
++>>>>>>> 007f790c8276 (net: introduce generic switch devices support)
  
  config RPS
  	boolean
diff --cc net/Makefile
index 642f22554c92,95fc694e4ddc..000000000000
--- a/net/Makefile
+++ b/net/Makefile
@@@ -70,3 -72,7 +70,10 @@@ obj-$(CONFIG_NFC)		+= nfc
  obj-$(CONFIG_OPENVSWITCH)	+= openvswitch/
  obj-$(CONFIG_VSOCKETS)	+= vmw_vsock/
  obj-$(CONFIG_NET_MPLS_GSO)	+= mpls/
++<<<<<<< HEAD
++=======
+ obj-$(CONFIG_HSR)		+= hsr/
+ ifneq ($(CONFIG_NET_SWITCHDEV),)
+ obj-y				+= switchdev/
+ endif
++>>>>>>> 007f790c8276 (net: introduce generic switch devices support)
diff --git a/Documentation/networking/switchdev.txt b/Documentation/networking/switchdev.txt
new file mode 100644
index 000000000000..f981a9295a39
--- /dev/null
+++ b/Documentation/networking/switchdev.txt
@@ -0,0 +1,59 @@
+Switch (and switch-ish) device drivers HOWTO
+===========================
+
+Please note that the word "switch" is here used in very generic meaning.
+This include devices supporting L2/L3 but also various flow offloading chips,
+including switches embedded into SR-IOV NICs.
+
+Lets describe a topology a bit. Imagine the following example:
+
+       +----------------------------+    +---------------+
+       |     SOME switch chip       |    |      CPU      |
+       +----------------------------+    +---------------+
+       port1 port2 port3 port4 MNGMNT    |     PCI-E     |
+         |     |     |     |     |       +---------------+
+        PHY   PHY    |     |     |         |  NIC0 NIC1
+                     |     |     |         |   |    |
+                     |     |     +- PCI-E -+   |    |
+                     |     +------- MII -------+    |
+                     +------------- MII ------------+
+
+In this example, there are two independent lines between the switch silicon
+and CPU. NIC0 and NIC1 drivers are not aware of a switch presence. They are
+separate from the switch driver. SOME switch chip is by managed by a driver
+via PCI-E device MNGMNT. Note that MNGMNT device, NIC0 and NIC1 may be
+connected to some other type of bus.
+
+Now, for the previous example show the representation in kernel:
+
+       +----------------------------+    +---------------+
+       |     SOME switch chip       |    |      CPU      |
+       +----------------------------+    +---------------+
+       sw0p0 sw0p1 sw0p2 sw0p3 MNGMNT    |     PCI-E     |
+         |     |     |     |     |       +---------------+
+        PHY   PHY    |     |     |         |  eth0 eth1
+                     |     |     |         |   |    |
+                     |     |     +- PCI-E -+   |    |
+                     |     +------- MII -------+    |
+                     +------------- MII ------------+
+
+Lets call the example switch driver for SOME switch chip "SOMEswitch". This
+driver takes care of PCI-E device MNGMNT. There is a netdevice instance sw0pX
+created for each port of a switch. These netdevices are instances
+of "SOMEswitch" driver. sw0pX netdevices serve as a "representation"
+of the switch chip. eth0 and eth1 are instances of some other existing driver.
+
+The only difference of the switch-port netdevice from the ordinary netdevice
+is that is implements couple more NDOs:
+
+  ndo_switch_parent_id_get - This returns the same ID for two port netdevices
+			     of the same physical switch chip. This is
+			     mandatory to be implemented by all switch drivers
+			     and serves the caller for recognition of a port
+			     netdevice.
+  ndo_switch_parent_* - Functions that serve for a manipulation of the switch
+			chip itself (it can be though of as a "parent" of the
+			port, therefore the name). They are not port-specific.
+			Caller might use arbitrary port netdevice of the same
+			switch and it will make no difference.
+  ndo_switch_port_* - Functions that serve for a port-specific manipulation.
diff --git a/MAINTAINERS b/MAINTAINERS
index d259f76582fa..89b7b3933d85 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -8152,6 +8152,13 @@ F:	lib/swiotlb.c
 F:	arch/*/kernel/pci-swiotlb.c
 F:	include/linux/swiotlb.h
 
+SWITCHDEV
+M:	Jiri Pirko <jiri@resnulli.us>
+L:	netdev@vger.kernel.org
+S:	Supported
+F:	net/switchdev/
+F:	include/net/switchdev.h
+
 SYNOPSYS ARC ARCHITECTURE
 M:	Vineet Gupta <vgupta@synopsys.com>
 S:	Supported
* Unmerged path include/linux/netdevice.h
diff --git a/include/net/switchdev.h b/include/net/switchdev.h
new file mode 100644
index 000000000000..7a52360a1446
--- /dev/null
+++ b/include/net/switchdev.h
@@ -0,0 +1,30 @@
+/*
+ * include/net/switchdev.h - Switch device API
+ * Copyright (c) 2014 Jiri Pirko <jiri@resnulli.us>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#ifndef _LINUX_SWITCHDEV_H_
+#define _LINUX_SWITCHDEV_H_
+
+#include <linux/netdevice.h>
+
+#ifdef CONFIG_NET_SWITCHDEV
+
+int netdev_switch_parent_id_get(struct net_device *dev,
+				struct netdev_phys_item_id *psid);
+
+#else
+
+static inline int netdev_switch_parent_id_get(struct net_device *dev,
+					      struct netdev_phys_item_id *psid)
+{
+	return -EOPNOTSUPP;
+}
+
+#endif
+
+#endif /* _LINUX_SWITCHDEV_H_ */
* Unmerged path net/Kconfig
* Unmerged path net/Makefile
diff --git a/net/switchdev/Kconfig b/net/switchdev/Kconfig
new file mode 100644
index 000000000000..155754588fd6
--- /dev/null
+++ b/net/switchdev/Kconfig
@@ -0,0 +1,13 @@
+#
+# Configuration for Switch device support
+#
+
+config NET_SWITCHDEV
+	boolean "Switch (and switch-ish) device support (EXPERIMENTAL)"
+	depends on INET
+	---help---
+	  This module provides glue between core networking code and device
+	  drivers in order to support hardware switch chips in very generic
+	  meaning of the word "switch". This include devices supporting L2/L3 but
+	  also various flow offloading chips, including switches embedded into
+	  SR-IOV NICs.
diff --git a/net/switchdev/Makefile b/net/switchdev/Makefile
new file mode 100644
index 000000000000..5ed63ed324d0
--- /dev/null
+++ b/net/switchdev/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the Switch device API
+#
+
+obj-$(CONFIG_NET_SWITCHDEV) += switchdev.o
diff --git a/net/switchdev/switchdev.c b/net/switchdev/switchdev.c
new file mode 100644
index 000000000000..66973deaae56
--- /dev/null
+++ b/net/switchdev/switchdev.c
@@ -0,0 +1,33 @@
+/*
+ * net/switchdev/switchdev.c - Switch device API
+ * Copyright (c) 2014 Jiri Pirko <jiri@resnulli.us>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <net/switchdev.h>
+
+/**
+ *	netdev_switch_parent_id_get - Get ID of a switch
+ *	@dev: port device
+ *	@psid: switch ID
+ *
+ *	Get ID of a switch this port is part of.
+ */
+int netdev_switch_parent_id_get(struct net_device *dev,
+				struct netdev_phys_item_id *psid)
+{
+	const struct net_device_ops *ops = dev->netdev_ops;
+
+	if (!ops->ndo_switch_parent_id_get)
+		return -EOPNOTSUPP;
+	return ops->ndo_switch_parent_id_get(dev, psid);
+}
+EXPORT_SYMBOL(netdev_switch_parent_id_get);
