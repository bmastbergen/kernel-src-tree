netfilter: conntrack: built-in support for SCTP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Davide Caratti <dcaratti@redhat.com>
commit a85406afeb3e045b001b2aac5b4f89f4266fede3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a85406af.failed

CONFIG_NF_CT_PROTO_SCTP is no more a tristate. When set to y, connection
tracking support for SCTP protocol is built-in into nf_conntrack.ko.

footprint test:
$ ls -l net/netfilter/nf_conntrack{_proto_sctp,}.ko \
        net/ipv4/netfilter/nf_conntrack_ipv4.ko \
        net/ipv6/netfilter/nf_conntrack_ipv6.ko

(builtin)||  sctp  |  ipv4  |  ipv6  | nf_conntrack
---------++--------+--------+--------+--------------
none     || 498243 | 828755 | 828676 | 6141434
SCTP     ||   -    | 829254 | 829175 | 6547872

	Signed-off-by: Davide Caratti <dcaratti@redhat.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit a85406afeb3e045b001b2aac5b4f89f4266fede3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/ipv4/nf_conntrack_ipv4.h
#	include/net/netfilter/ipv6/nf_conntrack_ipv6.h
#	include/net/netns/conntrack.h
#	net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
#	net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
#	net/netfilter/Makefile
#	net/netfilter/nf_conntrack_proto_sctp.c
diff --cc include/net/netfilter/ipv4/nf_conntrack_ipv4.h
index 6c3d12e2949f,5f1fc15a51fb..000000000000
--- a/include/net/netfilter/ipv4/nf_conntrack_ipv4.h
+++ b/include/net/netfilter/ipv4/nf_conntrack_ipv4.h
@@@ -15,6 -15,12 +15,15 @@@ extern struct nf_conntrack_l3proto nf_c
  extern struct nf_conntrack_l4proto nf_conntrack_l4proto_tcp4;
  extern struct nf_conntrack_l4proto nf_conntrack_l4proto_udp4;
  extern struct nf_conntrack_l4proto nf_conntrack_l4proto_icmp;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ extern struct nf_conntrack_l4proto nf_conntrack_l4proto_dccp4;
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ extern struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp4;
+ #endif
++>>>>>>> a85406afeb3e (netfilter: conntrack: built-in support for SCTP)
  
  int nf_conntrack_ipv4_compat_init(void);
  void nf_conntrack_ipv4_compat_fini(void);
diff --cc include/net/netfilter/ipv6/nf_conntrack_ipv6.h
index a4c993685795,f70d191a8820..000000000000
--- a/include/net/netfilter/ipv6/nf_conntrack_ipv6.h
+++ b/include/net/netfilter/ipv6/nf_conntrack_ipv6.h
@@@ -6,6 -6,12 +6,15 @@@ extern struct nf_conntrack_l3proto nf_c
  extern struct nf_conntrack_l4proto nf_conntrack_l4proto_tcp6;
  extern struct nf_conntrack_l4proto nf_conntrack_l4proto_udp6;
  extern struct nf_conntrack_l4proto nf_conntrack_l4proto_icmpv6;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ extern struct nf_conntrack_l4proto nf_conntrack_l4proto_dccp6;
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ extern struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp6;
+ #endif
++>>>>>>> a85406afeb3e (netfilter: conntrack: built-in support for SCTP)
  
  #include <linux/sysctl.h>
  extern struct ctl_table nf_ct_ipv6_sysctl_table[];
diff --cc include/net/netns/conntrack.h
index 4303c98010df,17724c62de97..000000000000
--- a/include/net/netns/conntrack.h
+++ b/include/net/netns/conntrack.h
@@@ -4,7 -4,14 +4,16 @@@
  #include <linux/list.h>
  #include <linux/list_nulls.h>
  #include <linux/atomic.h>
 -#include <linux/workqueue.h>
  #include <linux/netfilter/nf_conntrack_tcp.h>
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ #include <linux/netfilter/nf_conntrack_dccp.h>
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ #include <linux/netfilter/nf_conntrack_sctp.h>
+ #endif
++>>>>>>> a85406afeb3e (netfilter: conntrack: built-in support for SCTP)
  #include <linux/seqlock.h>
  
  struct ctl_table_header;
@@@ -51,19 -54,35 +60,40 @@@ struct nf_icmp_net 
  	unsigned int timeout;
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ struct nf_dccp_net {
+ 	struct nf_proto_net pn;
+ 	int dccp_loose;
+ 	unsigned int dccp_timeout[CT_DCCP_MAX + 1];
+ };
+ #endif
+ 
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ struct nf_sctp_net {
+ 	struct nf_proto_net pn;
+ 	unsigned int timeouts[SCTP_CONNTRACK_MAX];
+ };
+ #endif
+ 
++>>>>>>> a85406afeb3e (netfilter: conntrack: built-in support for SCTP)
  struct nf_ip_net {
  	struct nf_generic_net   generic;
  	struct nf_tcp_net	tcp;
  	struct nf_udp_net	udp;
  	struct nf_icmp_net	icmp;
  	struct nf_icmp_net	icmpv6;
 -#ifdef CONFIG_NF_CT_PROTO_DCCP
 -	struct nf_dccp_net	dccp;
 +#if defined(CONFIG_SYSCTL) && defined(CONFIG_NF_CONNTRACK_PROC_COMPAT)
 +	struct ctl_table_header *ctl_table_header;
 +	struct ctl_table	*ctl_table;
  #endif
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 	struct nf_sctp_net	sctp;
+ #endif
  };
  
 +#ifndef __GENKSYMS__
  struct ct_pcpu {
  	spinlock_t		lock;
  	struct hlist_nulls_head unconfirmed;
diff --cc net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
index 311c90294dd4,0a9d354ef314..000000000000
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
@@@ -408,6 -336,18 +408,21 @@@ MODULE_ALIAS("nf_conntrack-" __stringif
  MODULE_ALIAS("ip_conntrack");
  MODULE_LICENSE("GPL");
  
++<<<<<<< HEAD
++=======
+ static struct nf_conntrack_l4proto *builtin_l4proto4[] = {
+ 	&nf_conntrack_l4proto_tcp4,
+ 	&nf_conntrack_l4proto_udp4,
+ 	&nf_conntrack_l4proto_icmp,
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	&nf_conntrack_l4proto_dccp4,
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 	&nf_conntrack_l4proto_sctp4,
+ #endif
+ };
+ 
++>>>>>>> a85406afeb3e (netfilter: conntrack: built-in support for SCTP)
  static int ipv4_net_init(struct net *net)
  {
  	int ret = 0;
diff --cc net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
index 8f8c8ed94a2f,1d8daafb1685..000000000000
--- a/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
@@@ -350,6 -336,18 +350,21 @@@ static struct nf_sockopt_ops so_getorig
  	.owner		= THIS_MODULE,
  };
  
++<<<<<<< HEAD
++=======
+ static struct nf_conntrack_l4proto *builtin_l4proto6[] = {
+ 	&nf_conntrack_l4proto_tcp6,
+ 	&nf_conntrack_l4proto_udp6,
+ 	&nf_conntrack_l4proto_icmpv6,
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	&nf_conntrack_l4proto_dccp6,
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 	&nf_conntrack_l4proto_sctp6,
+ #endif
+ };
+ 
++>>>>>>> a85406afeb3e (netfilter: conntrack: built-in support for SCTP)
  static int ipv6_net_init(struct net *net)
  {
  	int ret = 0;
diff --cc net/netfilter/Makefile
index 2a3dcb487568,6545c28ab746..000000000000
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@@ -5,6 -5,8 +5,11 @@@ nf_conntrack-$(CONFIG_NF_CONNTRACK_TIME
  nf_conntrack-$(CONFIG_NF_CONNTRACK_TIMESTAMP) += nf_conntrack_timestamp.o
  nf_conntrack-$(CONFIG_NF_CONNTRACK_EVENTS) += nf_conntrack_ecache.o
  nf_conntrack-$(CONFIG_NF_CONNTRACK_LABELS) += nf_conntrack_labels.o
++<<<<<<< HEAD
++=======
+ nf_conntrack-$(CONFIG_NF_CT_PROTO_DCCP) += nf_conntrack_proto_dccp.o
+ nf_conntrack-$(CONFIG_NF_CT_PROTO_SCTP) += nf_conntrack_proto_sctp.o
++>>>>>>> a85406afeb3e (netfilter: conntrack: built-in support for SCTP)
  
  obj-$(CONFIG_NETFILTER) = netfilter.o
  
@@@ -18,10 -18,7 +23,9 @@@ obj-$(CONFIG_NETFILTER_NETLINK_LOG) += 
  # connection tracking
  obj-$(CONFIG_NF_CONNTRACK) += nf_conntrack.o
  
 +# SCTP protocol connection tracking
 +obj-$(CONFIG_NF_CT_PROTO_DCCP) += nf_conntrack_proto_dccp.o
  obj-$(CONFIG_NF_CT_PROTO_GRE) += nf_conntrack_proto_gre.o
- obj-$(CONFIG_NF_CT_PROTO_SCTP) += nf_conntrack_proto_sctp.o
  obj-$(CONFIG_NF_CT_PROTO_UDPLITE) += nf_conntrack_proto_udplite.o
  
  # netlink interface for nf_conntrack
diff --cc net/netfilter/nf_conntrack_proto_sctp.c
index b3f59c204e9e,a0efde38da44..000000000000
--- a/net/netfilter/nf_conntrack_proto_sctp.c
+++ b/net/netfilter/nf_conntrack_proto_sctp.c
@@@ -144,15 -143,9 +143,19 @@@ static const u8 sctp_conntracks[2][11][
  	}
  };
  
++<<<<<<< HEAD
 +static int sctp_net_id	__read_mostly;
 +struct sctp_net {
 +	struct nf_proto_net pn;
 +	unsigned int timeouts[SCTP_CONNTRACK_MAX];
 +};
 +
 +static inline struct sctp_net *sctp_pernet(struct net *net)
++=======
+ static inline struct nf_sctp_net *sctp_pernet(struct net *net)
++>>>>>>> a85406afeb3e (netfilter: conntrack: built-in support for SCTP)
  {
- 	return net_generic(net, sctp_net_id);
+ 	return &net->ct.nf_ct_proto.sctp;
  }
  
  static bool sctp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,
@@@ -787,33 -726,9 +790,37 @@@ static int sctp_kmemdup_sysctl_table(st
  	return 0;
  }
  
 +static int sctp_kmemdup_compat_sysctl_table(struct nf_proto_net *pn,
 +					    struct sctp_net *sn)
 +{
 +#ifdef CONFIG_SYSCTL
 +#ifdef CONFIG_NF_CONNTRACK_PROC_COMPAT
 +	pn->ctl_compat_table = kmemdup(sctp_compat_sysctl_table,
 +				       sizeof(sctp_compat_sysctl_table),
 +				       GFP_KERNEL);
 +	if (!pn->ctl_compat_table)
 +		return -ENOMEM;
 +
 +	pn->ctl_compat_table[0].data = &sn->timeouts[SCTP_CONNTRACK_CLOSED];
 +	pn->ctl_compat_table[1].data = &sn->timeouts[SCTP_CONNTRACK_COOKIE_WAIT];
 +	pn->ctl_compat_table[2].data = &sn->timeouts[SCTP_CONNTRACK_COOKIE_ECHOED];
 +	pn->ctl_compat_table[3].data = &sn->timeouts[SCTP_CONNTRACK_ESTABLISHED];
 +	pn->ctl_compat_table[4].data = &sn->timeouts[SCTP_CONNTRACK_SHUTDOWN_SENT];
 +	pn->ctl_compat_table[5].data = &sn->timeouts[SCTP_CONNTRACK_SHUTDOWN_RECD];
 +	pn->ctl_compat_table[6].data = &sn->timeouts[SCTP_CONNTRACK_SHUTDOWN_ACK_SENT];
 +#endif
 +#endif
 +	return 0;
 +}
 +
  static int sctp_init_net(struct net *net, u_int16_t proto)
  {
++<<<<<<< HEAD
 +	int ret;
 +	struct sctp_net *sn = sctp_pernet(net);
++=======
+ 	struct nf_sctp_net *sn = sctp_pernet(net);
++>>>>>>> a85406afeb3e (netfilter: conntrack: built-in support for SCTP)
  	struct nf_proto_net *pn = &sn->pn;
  
  	if (!pn->users) {
@@@ -823,21 -738,10 +830,21 @@@
  			sn->timeouts[i] = sctp_timeouts[i];
  	}
  
 -	return sctp_kmemdup_sysctl_table(pn, sn);
 +	if (proto == AF_INET) {
 +		ret = sctp_kmemdup_compat_sysctl_table(pn, sn);
 +		if (ret < 0)
 +			return ret;
 +
 +		ret = sctp_kmemdup_sysctl_table(pn, sn);
 +		if (ret < 0)
 +			nf_ct_kfree_compat_sysctl_table(pn);
 +	} else
 +		ret = sctp_kmemdup_sysctl_table(pn, sn);
 +
 +	return ret;
  }
  
- static struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp4 __read_mostly = {
+ struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp4 __read_mostly = {
  	.l3proto		= PF_INET,
  	.l4proto 		= IPPROTO_SCTP,
  	.name 			= "sctp",
@@@ -901,81 -805,6 +908,84 @@@ struct nf_conntrack_l4proto nf_conntrac
  	},
  #endif /* CONFIG_NF_CT_NETLINK_TIMEOUT */
  #endif
- 	.net_id			= &sctp_net_id,
  	.init_net		= sctp_init_net,
  };
++<<<<<<< HEAD
 +
 +static int sctp_net_init(struct net *net)
 +{
 +	int ret = 0;
 +
 +	ret = nf_ct_l4proto_pernet_register(net, &nf_conntrack_l4proto_sctp4);
 +	if (ret < 0) {
 +		pr_err("nf_conntrack_sctp4: pernet registration failed.\n");
 +		goto out;
 +	}
 +	ret = nf_ct_l4proto_pernet_register(net, &nf_conntrack_l4proto_sctp6);
 +	if (ret < 0) {
 +		pr_err("nf_conntrack_sctp6: pernet registration failed.\n");
 +		goto cleanup_sctp4;
 +	}
 +	return 0;
 +
 +cleanup_sctp4:
 +	nf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_sctp4);
 +out:
 +	return ret;
 +}
 +
 +static void sctp_net_exit(struct net *net)
 +{
 +	nf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_sctp6);
 +	nf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_sctp4);
 +}
 +
 +static struct pernet_operations sctp_net_ops = {
 +	.init = sctp_net_init,
 +	.exit = sctp_net_exit,
 +	.id   = &sctp_net_id,
 +	.size = sizeof(struct sctp_net),
 +};
 +
 +static int __init nf_conntrack_proto_sctp_init(void)
 +{
 +	int ret;
 +
 +	ret = register_pernet_subsys(&sctp_net_ops);
 +	if (ret < 0)
 +		goto out_pernet;
 +
 +	ret = nf_ct_l4proto_register(&nf_conntrack_l4proto_sctp4);
 +	if (ret < 0)
 +		goto out_sctp4;
 +
 +	ret = nf_ct_l4proto_register(&nf_conntrack_l4proto_sctp6);
 +	if (ret < 0)
 +		goto out_sctp6;
 +
 +	return 0;
 +out_sctp6:
 +	nf_ct_l4proto_unregister(&nf_conntrack_l4proto_sctp4);
 +out_sctp4:
 +	unregister_pernet_subsys(&sctp_net_ops);
 +out_pernet:
 +	return ret;
 +}
 +
 +static void __exit nf_conntrack_proto_sctp_fini(void)
 +{
 +	nf_ct_l4proto_unregister(&nf_conntrack_l4proto_sctp6);
 +	nf_ct_l4proto_unregister(&nf_conntrack_l4proto_sctp4);
 +	unregister_pernet_subsys(&sctp_net_ops);
 +}
 +
 +module_init(nf_conntrack_proto_sctp_init);
 +module_exit(nf_conntrack_proto_sctp_fini);
 +
 +MODULE_LICENSE("GPL");
 +MODULE_AUTHOR("Kiran Kumar Immidi");
 +MODULE_DESCRIPTION("Netfilter connection tracking protocol helper for SCTP");
 +MODULE_ALIAS("ip_conntrack_proto_sctp");
++=======
+ EXPORT_SYMBOL_GPL(nf_conntrack_l4proto_sctp6);
++>>>>>>> a85406afeb3e (netfilter: conntrack: built-in support for SCTP)
* Unmerged path include/net/netfilter/ipv4/nf_conntrack_ipv4.h
* Unmerged path include/net/netfilter/ipv6/nf_conntrack_ipv6.h
* Unmerged path include/net/netns/conntrack.h
* Unmerged path net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
index a7265625168d..35dd7f768790 100644
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -147,15 +147,14 @@ config NF_CT_PROTO_GRE
 	tristate
 
 config NF_CT_PROTO_SCTP
-	tristate 'SCTP protocol connection tracking support'
+	bool 'SCTP protocol connection tracking support'
 	depends on NETFILTER_ADVANCED
-	default IP_SCTP
+	default y
 	help
 	  With this option enabled, the layer 3 independent connection
 	  tracking code will be able to do state tracking on SCTP connections.
 
-	  If you want to compile it as a module, say M here and read
-	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.
+	  If unsure, say Y.
 
 config NF_CT_PROTO_UDPLITE
 	tristate 'UDP-Lite protocol connection tracking support'
* Unmerged path net/netfilter/Makefile
* Unmerged path net/netfilter/nf_conntrack_proto_sctp.c
