dell-wmi: Generate one sparse keymap for all machines

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Pali Rohár <pali.rohar@gmail.com>
commit e075b3c898e4055ec62a1f0ed7f3b8e62814bfb6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e075b3c8.failed

This patch reworks code for generating sparse keymap and processing WMI
events. It unifies procedure for generating sparse keymap and also unifies
big switch code for processing WMI events of different types. After this
patch dell-wmi driver does not differ between "old" and "new" hotkey type.

It constructs sparse keymap table with all WMI codes. It is because on some
laptops (e.g. Dell Latitude E6440) ACPI/firmware send both event types (old
and new).

Each WMI code in sparse keymap table is prefixed by 16bit event type, so it
does not change functionality on laptops with "old" hotkey support (those
without scancodes in DMI).

This allow us to distinguish between same WMI codes with different types in
sparse keymap. Thanks to this WMI events of type 0x0011 were moved from big
switch into sparse keymap table too.

This patch also fixes possible bug in parsing WMI event buffer introduced
in commit 5ea2559726b7 ("dell-wmi: Add support for new Dell systems"). That
commit changed buffer type from int* to u16* without fixing code. More at:
http://lkml.iu.edu/hypermail/linux/kernel/1507.0/01950.html

	Signed-off-by: Pali Rohár <pali.rohar@gmail.com>
	Tested-by: Michał Kępień <kernel@kempniu.pl>
	Reviewed-by: Michał Kępień <kernel@kempniu.pl>
	Tested-by: Gabriele Mazzotta <gabriele.mzt@gmail.com>
	Signed-off-by: Darren Hart <dvhart@linux.intel.com>
(cherry picked from commit e075b3c898e4055ec62a1f0ed7f3b8e62814bfb6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/platform/x86/dell-wmi.c
diff --cc drivers/platform/x86/dell-wmi.c
index 8a4ceeea7f7f,b8ad055078cf..000000000000
--- a/drivers/platform/x86/dell-wmi.c
+++ b/drivers/platform/x86/dell-wmi.c
@@@ -52,31 -53,58 +52,32 @@@ static u32 dell_wmi_interface_version
  MODULE_ALIAS("wmi:"DELL_EVENT_GUID);
  MODULE_ALIAS("wmi:"DELL_DESCRIPTOR_GUID);
  
 -static int __init dmi_matched(const struct dmi_system_id *dmi)
 -{
 -	wmi_requires_smbios_request = 1;
 -	return 1;
 -}
 -
 -static const struct dmi_system_id dell_wmi_smbios_list[] __initconst = {
 -	{
 -		.callback = dmi_matched,
 -		.ident = "Dell Inspiron M5110",
 -		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron M5110"),
 -		},
 -	},
 -	{
 -		.callback = dmi_matched,
 -		.ident = "Dell Vostro V131",
 -		.matches = {
 -			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
 -			DMI_MATCH(DMI_PRODUCT_NAME, "Vostro V131"),
 -		},
 -	},
 -	{ }
 -};
 -
  /*
+  * Keymap for WMI events of type 0x0000
+  *
   * Certain keys are flagged as KE_IGNORE. All of these are either
   * notifications (rather than requests for change) or are also sent
   * via the keyboard controller so should not be sent again.
   */
- 
- static const struct key_entry dell_wmi_legacy_keymap[] __initconst = {
+ static const struct key_entry dell_wmi_keymap_type_0000[] __initconst = {
  	{ KE_IGNORE, 0x003a, { KEY_CAPSLOCK } },
  
 -	/* Key code is followed by brightness level */
 -	{ KE_KEY,    0xe005, { KEY_BRIGHTNESSDOWN } },
 -	{ KE_KEY,    0xe006, { KEY_BRIGHTNESSUP } },
 +	{ KE_KEY, 0xe009, { KEY_EJECTCD } },
 +
 +	/* These also contain the brightness level at offset 6 */
 +	{ KE_KEY, 0xe006, { KEY_BRIGHTNESSUP } },
 +	{ KE_KEY, 0xe005, { KEY_BRIGHTNESSDOWN } },
  
  	/* Battery health status button */
 -	{ KE_KEY,    0xe007, { KEY_BATTERY } },
 +	{ KE_KEY, 0xe007, { KEY_BATTERY } },
  
 -	/* Radio devices state change, key code is followed by other values */
 +	/* Radio devices state change */
  	{ KE_IGNORE, 0xe008, { KEY_RFKILL } },
  
 -	{ KE_KEY,    0xe009, { KEY_EJECTCD } },
 +	/* The next device is at offset 6, the active devices are at
 +	   offset 8 and the attached devices at offset 10 */
 +	{ KE_KEY, 0xe00b, { KEY_SWITCHVIDEOMODE } },
  
 -	/* Key code is followed by: next, active and attached devices */
 -	{ KE_KEY,    0xe00b, { KEY_SWITCHVIDEOMODE } },
 -
 -	/* Key code is followed by keyboard illumination level */
  	{ KE_IGNORE, 0xe00c, { KEY_KBDILLUMTOGGLE } },
  
  	/* BIOS error detected */
@@@ -116,11 -177,15 +117,12 @@@
  	{ KE_IGNORE, 0xe0f7, { KEY_MUTE } },
  	{ KE_IGNORE, 0xe0f8, { KEY_VOLUMEDOWN } },
  	{ KE_IGNORE, 0xe0f9, { KEY_VOLUMEUP } },
++<<<<<<< HEAD
 +	{ KE_END, 0 }
++=======
++>>>>>>> e075b3c898e4 (dell-wmi: Generate one sparse keymap for all machines)
  };
  
- static bool dell_new_hk_type;
- 
  struct dell_bios_keymap_entry {
  	u16 scancode;
  	u16 keycode;
@@@ -132,7 -197,11 +134,15 @@@ struct dell_bios_hotkey_table 
  
  };
  
++<<<<<<< HEAD
 +static const struct dell_bios_hotkey_table *dell_bios_hotkey_table;
++=======
+ struct dell_dmi_results {
+ 	int err;
+ 	int keymap_size;
+ 	struct key_entry *keymap;
+ };
++>>>>>>> e075b3c898e4 (dell-wmi: Generate one sparse keymap for all machines)
  
  /* Uninitialized entries here are KEY_RESERVED == 0. */
  static const u16 bios_to_linux_keycode[256] __initconst = {
@@@ -178,9 -247,53 +188,56 @@@
  	[255]	= KEY_PROG3,
  };
  
++<<<<<<< HEAD
++=======
+ /*
+  * Keymap for WMI events of type 0x0010
+  *
+  * These are applied if the 0xB2 DMI hotkey table is present and doesn't
+  * override them.
+  */
+ static const struct key_entry dell_wmi_keymap_type_0010[] __initconst = {
+ 	/* Fn-lock */
+ 	{ KE_IGNORE, 0x151, { KEY_RESERVED } },
+ 
+ 	/* Change keyboard illumination */
+ 	{ KE_IGNORE, 0x152, { KEY_KBDILLUMTOGGLE } },
+ 
+ 	/*
+ 	 * Radio disable (notify only -- there is no model for which the
+ 	 * WMI event is supposed to trigger an action).
+ 	 */
+ 	{ KE_IGNORE, 0x153, { KEY_RFKILL } },
+ 
+ 	/* RGB keyboard backlight control */
+ 	{ KE_IGNORE, 0x154, { KEY_RESERVED } },
+ 
+ 	/* Stealth mode toggle */
+ 	{ KE_IGNORE, 0x155, { KEY_RESERVED } },
+ };
+ 
+ /*
+  * Keymap for WMI events of type 0x0011
+  */
+ static const struct key_entry dell_wmi_keymap_type_0011[] __initconst = {
+ 	/* Battery unplugged */
+ 	{ KE_IGNORE, 0xfff0, { KEY_RESERVED } },
+ 
+ 	/* Battery inserted */
+ 	{ KE_IGNORE, 0xfff1, { KEY_RESERVED } },
+ 
+ 	/* Keyboard backlight level changed */
+ 	{ KE_IGNORE, 0x01e1, { KEY_RESERVED } },
+ 	{ KE_IGNORE, 0x02ea, { KEY_RESERVED } },
+ 	{ KE_IGNORE, 0x02eb, { KEY_RESERVED } },
+ 	{ KE_IGNORE, 0x02ec, { KEY_RESERVED } },
+ 	{ KE_IGNORE, 0x02f6, { KEY_RESERVED } },
+ };
+ 
++>>>>>>> e075b3c898e4 (dell-wmi: Generate one sparse keymap for all machines)
  static struct input_dev *dell_wmi_input_dev;
  
- static void dell_wmi_process_key(int reported_key)
+ static void dell_wmi_process_key(int type, int code)
  {
  	const struct key_entry *key;
  
@@@ -196,10 -309,11 +253,10 @@@
  
  	/* Don't report brightness notifications that will also come via ACPI */
  	if ((key->keycode == KEY_BRIGHTNESSUP ||
 -	     key->keycode == KEY_BRIGHTNESSDOWN) &&
 -	    acpi_video_handles_brightness_key_presses())
 +	     key->keycode == KEY_BRIGHTNESSDOWN) && acpi_video)
  		return;
  
- 	if (reported_key == 0xe025 && !wmi_requires_smbios_request)
+ 	if (type == 0x0000 && code == 0xe025 && !wmi_requires_smbios_request)
  		return;
  
  	sparse_keymap_report_entry(dell_wmi_input_dev, key, 1, true);
@@@ -351,16 -409,53 +352,62 @@@ static void dell_wmi_notify(u32 value, 
  	kfree(obj);
  }
  
 -static bool have_scancode(u32 scancode, const struct key_entry *keymap, int len)
 +static const struct key_entry * __init dell_wmi_prepare_new_keymap(void)
  {
 +	int hotkey_num = (dell_bios_hotkey_table->header.length - 4) /
 +				sizeof(struct dell_bios_keymap_entry);
 +	struct key_entry *keymap;
  	int i;
  
++<<<<<<< HEAD
 +	keymap = kcalloc(hotkey_num + 1, sizeof(struct key_entry), GFP_KERNEL);
 +	if (!keymap)
 +		return NULL;
++=======
+ 	for (i = 0; i < len; i++)
+ 		if (keymap[i].code == scancode)
+ 			return true;
+ 
+ 	return false;
+ }
+ 
+ static void __init handle_dmi_entry(const struct dmi_header *dm,
+ 				    void *opaque)
+ 
+ {
+ 	struct dell_dmi_results *results = opaque;
+ 	struct dell_bios_hotkey_table *table;
+ 	int hotkey_num, i, pos = 0;
+ 	struct key_entry *keymap;
+ 
+ 	if (results->err || results->keymap)
+ 		return;		/* We already found the hotkey table. */
+ 
+ 	if (dm->type != 0xb2)
+ 		return;
+ 
+ 	table = container_of(dm, struct dell_bios_hotkey_table, header);
+ 
+ 	hotkey_num = (table->header.length -
+ 		      sizeof(struct dell_bios_hotkey_table)) /
+ 				sizeof(struct dell_bios_keymap_entry);
+ 	if (hotkey_num < 1) {
+ 		/*
+ 		 * Historically, dell-wmi would ignore a DMI entry of
+ 		 * fewer than 7 bytes.  Sizes between 4 and 8 bytes are
+ 		 * nonsensical (both the header and all entries are 4
+ 		 * bytes), so we approximate the old behavior by
+ 		 * ignoring tables with fewer than one entry.
+ 		 */
+ 		return;
+ 	}
+ 
+ 	keymap = kcalloc(hotkey_num, sizeof(struct key_entry), GFP_KERNEL);
+ 	if (!keymap) {
+ 		results->err = -ENOMEM;
+ 		return;
+ 	}
++>>>>>>> e075b3c898e4 (dell-wmi: Generate one sparse keymap for all machines)
  
  	for (i = 0; i < hotkey_num; i++) {
  		const struct dell_bios_keymap_entry *bios_entry =
@@@ -384,21 -479,24 +431,32 @@@
  		}
  
  		if (keycode == KEY_KBDILLUMTOGGLE)
 -			keymap[pos].type = KE_IGNORE;
 +			keymap[i].type = KE_IGNORE;
  		else
 -			keymap[pos].type = KE_KEY;
 -		keymap[pos].code = bios_entry->scancode;
 -		keymap[pos].keycode = keycode;
 -
 -		pos++;
 +			keymap[i].type = KE_KEY;
 +		keymap[i].code = bios_entry->scancode;
 +		keymap[i].keycode = keycode;
  	}
  
++<<<<<<< HEAD
 +	keymap[hotkey_num].type = KE_END;
 +
 +	return keymap;
++=======
+ 	results->keymap = keymap;
+ 	results->keymap_size = pos;
++>>>>>>> e075b3c898e4 (dell-wmi: Generate one sparse keymap for all machines)
  }
  
  static int __init dell_wmi_input_setup(void)
  {
++<<<<<<< HEAD
 +	int err;
++=======
+ 	struct dell_dmi_results dmi_results = {};
+ 	struct key_entry *keymap;
+ 	int err, i, pos = 0;
++>>>>>>> e075b3c898e4 (dell-wmi: Generate one sparse keymap for all machines)
  
  	dell_wmi_input_dev = input_allocate_device();
  	if (!dell_wmi_input_dev)
@@@ -408,24 -506,85 +466,94 @@@
  	dell_wmi_input_dev->phys = "wmi/input0";
  	dell_wmi_input_dev->id.bustype = BUS_HOST;
  
 -	if (dmi_walk(handle_dmi_entry, &dmi_results)) {
 -		/*
 -		 * Historically, dell-wmi ignored dmi_walk errors.  A failure
 -		 * is certainly surprising, but it probably just indicates
 -		 * a very old laptop.
 -		 */
 -		pr_warn("no DMI; using the old-style hotkey interface\n");
 -	}
 +	if (dell_new_hk_type) {
 +		const struct key_entry *keymap = dell_wmi_prepare_new_keymap();
 +		if (!keymap) {
 +			err = -ENOMEM;
 +			goto err_free_dev;
 +		}
  
++<<<<<<< HEAD
 +		err = sparse_keymap_setup(dell_wmi_input_dev, keymap, NULL);
++=======
+ 	if (dmi_results.err) {
+ 		err = dmi_results.err;
+ 		goto err_free_dev;
+ 	}
+ 
+ 	keymap = kcalloc(dmi_results.keymap_size +
+ 			 ARRAY_SIZE(dell_wmi_keymap_type_0000) +
+ 			 ARRAY_SIZE(dell_wmi_keymap_type_0010) +
+ 			 ARRAY_SIZE(dell_wmi_keymap_type_0011) +
+ 			 1,
+ 			 sizeof(struct key_entry), GFP_KERNEL);
+ 	if (!keymap) {
+ 		kfree(dmi_results.keymap);
+ 		err = -ENOMEM;
+ 		goto err_free_dev;
+ 	}
+ 
+ 	/* Append table with events of type 0x0010 which comes from DMI */
+ 	for (i = 0; i < dmi_results.keymap_size; i++) {
+ 		keymap[pos] = dmi_results.keymap[i];
+ 		keymap[pos].code |= (0x0010 << 16);
+ 		pos++;
+ 	}
+ 
+ 	kfree(dmi_results.keymap);
+ 
+ 	/* Append table with extra events of type 0x0010 which are not in DMI */
+ 	for (i = 0; i < ARRAY_SIZE(dell_wmi_keymap_type_0010); i++) {
+ 		const struct key_entry *entry = &dell_wmi_keymap_type_0010[i];
++>>>>>>> e075b3c898e4 (dell-wmi: Generate one sparse keymap for all machines)
  
  		/*
- 		 * Sparse keymap library makes a copy of keymap so we
- 		 * don't need the original one that was allocated.
+ 		 * Check if we've already found this scancode.  This takes
+ 		 * quadratic time, but it doesn't matter unless the list
+ 		 * of extra keys gets very long.
  		 */
++<<<<<<< HEAD
 +		kfree(keymap);
 +	} else {
 +		err = sparse_keymap_setup(dell_wmi_input_dev,
 +					  dell_wmi_legacy_keymap, NULL);
++=======
+ 		if (dmi_results.keymap_size &&
+ 		    have_scancode(entry->code | (0x0010 << 16),
+ 				  keymap, dmi_results.keymap_size)
+ 		   )
+ 			continue;
+ 
+ 		keymap[pos] = *entry;
+ 		keymap[pos].code |= (0x0010 << 16);
+ 		pos++;
++>>>>>>> e075b3c898e4 (dell-wmi: Generate one sparse keymap for all machines)
+ 	}
+ 
+ 	/* Append table with events of type 0x0011 */
+ 	for (i = 0; i < ARRAY_SIZE(dell_wmi_keymap_type_0011); i++) {
+ 		keymap[pos] = dell_wmi_keymap_type_0011[i];
+ 		keymap[pos].code |= (0x0011 << 16);
+ 		pos++;
  	}
+ 
+ 	/*
+ 	 * Now append also table with "legacy" events of type 0x0000. Some of
+ 	 * them are reported also on laptops which have scancodes in DMI.
+ 	 */
+ 	for (i = 0; i < ARRAY_SIZE(dell_wmi_keymap_type_0000); i++) {
+ 		keymap[pos] = dell_wmi_keymap_type_0000[i];
+ 		pos++;
+ 	}
+ 
+ 	keymap[pos].type = KE_END;
+ 
+ 	err = sparse_keymap_setup(dell_wmi_input_dev, keymap, NULL);
+ 	/*
+ 	 * Sparse keymap library makes a copy of keymap so we don't need the
+ 	 * original one that was allocated.
+ 	 */
+ 	kfree(keymap);
  	if (err)
  		goto err_free_dev;
  
* Unmerged path drivers/platform/x86/dell-wmi.c
