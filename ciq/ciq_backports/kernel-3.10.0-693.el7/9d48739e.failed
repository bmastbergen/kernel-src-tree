md: change all printk() to pr_err() or pr_warn() etc.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [md] change all printk() to pr_err() or pr_warn() etc (Jes Sorensen) [1380016]
Rebuild_FUZZ: 95.05%
commit-author NeilBrown <neilb@suse.com>
commit 9d48739ef19aa8ad6026fd312b3ed81b560c8579
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9d48739e.failed

1/ using pr_debug() for a number of messages reduces the noise of
   md, but still allows them to be enabled when needed.
2/ try to be consistent in the usage of pr_err() and pr_warn(), and
   document the intention
3/ When strings have been split onto multiple lines, rejoin into
   a single string.
   The cost of having lines > 80 chars is less than the cost of not
   being able to easily search for a particular message.

	Signed-off-by: NeilBrown <neilb@suse.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 9d48739ef19aa8ad6026fd312b3ed81b560c8579)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index ba8c742c55f6,22c9efd86b0d..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -722,10 -723,8 +734,15 @@@ static void super_written(struct bio *b
  	struct md_rdev *rdev = bio->bi_private;
  	struct mddev *mddev = rdev->mddev;
  
++<<<<<<< HEAD
 +	if (error || !test_bit(BIO_UPTODATE, &bio->bi_flags)) {
 +		printk("md: super_written gets error=%d, uptodate=%d\n",
 +		       error, test_bit(BIO_UPTODATE, &bio->bi_flags));
 +		WARN_ON(test_bit(BIO_UPTODATE, &bio->bi_flags));
++=======
+ 	if (bio->bi_error) {
+ 		pr_err("md: super_written gets error=%d\n", bio->bi_error);
++>>>>>>> 9d48739ef19a (md: change all printk() to pr_err() or pr_warn() etc.)
  		md_error(mddev, rdev);
  	}
  
@@@ -2005,15 -2004,12 +2016,22 @@@ int md_integrity_register(struct mddev 
  	 * All component devices are integrity capable and have matching
  	 * profiles, register the common profile for the md device.
  	 */
++<<<<<<< HEAD
 +	if (blk_integrity_register(mddev->gendisk,
 +			bdev_get_integrity(reference->bdev)) != 0) {
 +		printk(KERN_ERR "md: failed to register integrity for %s\n",
 +			mdname(mddev));
 +		return -EINVAL;
 +	}
 +	printk(KERN_NOTICE "md: data integrity enabled on %s\n", mdname(mddev));
++=======
+ 	blk_integrity_register(mddev->gendisk,
+ 			       bdev_get_integrity(reference->bdev));
+ 
+ 	pr_debug("md: data integrity enabled on %s\n", mdname(mddev));
++>>>>>>> 9d48739ef19a (md: change all printk() to pr_err() or pr_warn() etc.)
  	if (bioset_integrity_create(mddev->bio_set, BIO_POOL_SIZE)) {
- 		printk(KERN_ERR "md: failed to create integrity pool for %s\n",
+ 		pr_err("md: failed to create integrity pool for %s\n",
  		       mdname(mddev));
  		return -EINVAL;
  	}
@@@ -2102,11 -2097,10 +2120,11 @@@ static int bind_rdev_to_array(struct md
  		return -EBUSY;
  	}
  	bdevname(rdev->bdev,b);
 -	strreplace(b, '/', '!');
 +	while ( (s=strchr(b, '/')) != NULL)
 +		*s = '!';
  
  	rdev->mddev = mddev;
- 	printk(KERN_INFO "md: bind<%s>\n", b);
+ 	pr_debug("md: bind<%s>\n", b);
  
  	if ((err = kobject_add(&rdev->kobj, &mddev->kobj, "dev-%s", b)))
  		goto fail;
@@@ -3322,6 -3370,11 +3328,14 @@@ safe_delay_store(struct mddev *mddev, c
  {
  	unsigned long msec;
  
++<<<<<<< HEAD
++=======
+ 	if (mddev_is_clustered(mddev)) {
+ 		pr_warn("md: Safemode is disabled for clustered mode\n");
+ 		return -EINVAL;
+ 	}
+ 
++>>>>>>> 9d48739ef19a (md: change all printk() to pr_err() or pr_warn() etc.)
  	if (strict_strtoul_scaled(cbuf, &msec, 3) < 0)
  		return -EINVAL;
  	if (msec == 0)
@@@ -3504,10 -3557,9 +3518,16 @@@ level_store(struct mddev *mddev, const 
  	    pers->sync_request != NULL) {
  		/* need to add the md_redundancy_group */
  		if (sysfs_create_group(&mddev->kobj, &md_redundancy_group))
++<<<<<<< HEAD
 +			printk(KERN_WARNING
 +			       "md: cannot register extra attributes for %s\n",
 +			       mdname(mddev));
 +		mddev->sysfs_action = sysfs_get_dirent(mddev->kobj.sd, NULL, "sync_action");
++=======
+ 			pr_warn("md: cannot register extra attributes for %s\n",
+ 				mdname(mddev));
+ 		mddev->sysfs_action = sysfs_get_dirent(mddev->kobj.sd, "sync_action");
++>>>>>>> 9d48739ef19a (md: change all printk() to pr_err() or pr_warn() etc.)
  	}
  	if (oldpers->sync_request != NULL &&
  	    pers->sync_request == NULL) {
@@@ -5205,10 -5257,16 +5219,23 @@@ int md_run(struct mddev *mddev
  	}
  	if (err == 0 && pers->sync_request &&
  	    (mddev->bitmap_info.file || mddev->bitmap_info.offset)) {
++<<<<<<< HEAD
 +		err = bitmap_create(mddev);
 +		if (err)
 +			printk(KERN_ERR "%s: failed to create bitmap (%d)\n",
 +			       mdname(mddev), err);
++=======
+ 		struct bitmap *bitmap;
+ 
+ 		bitmap = bitmap_create(mddev, -1);
+ 		if (IS_ERR(bitmap)) {
+ 			err = PTR_ERR(bitmap);
+ 			pr_warn("%s: failed to create bitmap (%d)\n",
+ 				mdname(mddev), err);
+ 		} else
+ 			mddev->bitmap = bitmap;
+ 
++>>>>>>> 9d48739ef19a (md: change all printk() to pr_err() or pr_warn() etc.)
  	}
  	if (err) {
  		mddev_detach(mddev);
@@@ -5898,6 -5957,13 +5918,16 @@@ static int add_new_disk(struct mddev *m
  	struct md_rdev *rdev;
  	dev_t dev = MKDEV(info->major,info->minor);
  
++<<<<<<< HEAD
++=======
+ 	if (mddev_is_clustered(mddev) &&
+ 		!(info->state & ((1 << MD_DISK_CLUSTER_ADD) | (1 << MD_DISK_CANDIDATE)))) {
+ 		pr_warn("%s: Cannot add to clustered mddev.\n",
+ 			mdname(mddev));
+ 		return -EINVAL;
+ 	}
+ 
++>>>>>>> 9d48739ef19a (md: change all printk() to pr_err() or pr_warn() etc.)
  	if (info->major != MAJOR(dev) || info->minor != MINOR(dev))
  		return -EOVERFLOW;
  
@@@ -6502,10 -6612,26 +6521,33 @@@ static int update_array_info(struct mdd
  			mddev->pers->quiesce(mddev, 0);
  		} else {
  			/* remove the bitmap */
++<<<<<<< HEAD
 +			if (!mddev->bitmap)
 +				return -ENOENT;
 +			if (mddev->bitmap->storage.file)
 +				return -EINVAL;
++=======
+ 			if (!mddev->bitmap) {
+ 				rv = -ENOENT;
+ 				goto err;
+ 			}
+ 			if (mddev->bitmap->storage.file) {
+ 				rv = -EINVAL;
+ 				goto err;
+ 			}
+ 			if (mddev->bitmap_info.nodes) {
+ 				/* hold PW on all the bitmap lock */
+ 				if (md_cluster_ops->lock_all_bitmaps(mddev) <= 0) {
+ 					pr_warn("md: can't change bitmap to none since the array is in use by more than one node\n");
+ 					rv = -EPERM;
+ 					md_cluster_ops->unlock_all_bitmaps(mddev);
+ 					goto err;
+ 				}
+ 
+ 				mddev->bitmap_info.nodes = 0;
+ 				md_cluster_ops->leave(mddev);
+ 			}
++>>>>>>> 9d48739ef19a (md: change all printk() to pr_err() or pr_warn() etc.)
  			mddev->pers->quiesce(mddev, 1);
  			bitmap_destroy(mddev);
  			mddev->pers->quiesce(mddev, 0);
@@@ -7433,6 -7562,55 +7468,58 @@@ int unregister_md_personality(struct md
  }
  EXPORT_SYMBOL(unregister_md_personality);
  
++<<<<<<< HEAD
++=======
+ int register_md_cluster_operations(struct md_cluster_operations *ops,
+ 				   struct module *module)
+ {
+ 	int ret = 0;
+ 	spin_lock(&pers_lock);
+ 	if (md_cluster_ops != NULL)
+ 		ret = -EALREADY;
+ 	else {
+ 		md_cluster_ops = ops;
+ 		md_cluster_mod = module;
+ 	}
+ 	spin_unlock(&pers_lock);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(register_md_cluster_operations);
+ 
+ int unregister_md_cluster_operations(void)
+ {
+ 	spin_lock(&pers_lock);
+ 	md_cluster_ops = NULL;
+ 	spin_unlock(&pers_lock);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(unregister_md_cluster_operations);
+ 
+ int md_setup_cluster(struct mddev *mddev, int nodes)
+ {
+ 	if (!md_cluster_ops)
+ 		request_module("md-cluster");
+ 	spin_lock(&pers_lock);
+ 	/* ensure module won't be unloaded */
+ 	if (!md_cluster_ops || !try_module_get(md_cluster_mod)) {
+ 		pr_warn("can't find md-cluster module or get it's reference.\n");
+ 		spin_unlock(&pers_lock);
+ 		return -ENOENT;
+ 	}
+ 	spin_unlock(&pers_lock);
+ 
+ 	return md_cluster_ops->join(mddev, nodes);
+ }
+ 
+ void md_cluster_stop(struct mddev *mddev)
+ {
+ 	if (!md_cluster_ops)
+ 		return;
+ 	md_cluster_ops->leave(mddev);
+ 	module_put(md_cluster_mod);
+ }
+ 
++>>>>>>> 9d48739ef19a (md: change all printk() to pr_err() or pr_warn() etc.)
  static int is_mddev_idle(struct mddev *mddev, int init)
  {
  	struct md_rdev *rdev;
@@@ -8039,9 -8254,8 +8120,14 @@@ static void md_start_sync(struct work_s
  						mddev,
  						"resync");
  	if (!mddev->sync_thread) {
++<<<<<<< HEAD
 +		printk(KERN_ERR "%s: could not start resync"
 +		       " thread...\n",
 +		       mdname(mddev));
++=======
+ 		pr_warn("%s: could not start resync thread...\n",
+ 			mdname(mddev));
++>>>>>>> 9d48739ef19a (md: change all printk() to pr_err() or pr_warn() etc.)
  		/* leave the spares where they are, it shouldn't hurt */
  		clear_bit(MD_RECOVERY_SYNC, &mddev->recovery);
  		clear_bit(MD_RECOVERY_RESHAPE, &mddev->recovery);
@@@ -8431,6 -8673,138 +8517,141 @@@ err_wq
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void check_sb_changes(struct mddev *mddev, struct md_rdev *rdev)
+ {
+ 	struct mdp_superblock_1 *sb = page_address(rdev->sb_page);
+ 	struct md_rdev *rdev2;
+ 	int role, ret;
+ 	char b[BDEVNAME_SIZE];
+ 
+ 	/* Check for change of roles in the active devices */
+ 	rdev_for_each(rdev2, mddev) {
+ 		if (test_bit(Faulty, &rdev2->flags))
+ 			continue;
+ 
+ 		/* Check if the roles changed */
+ 		role = le16_to_cpu(sb->dev_roles[rdev2->desc_nr]);
+ 
+ 		if (test_bit(Candidate, &rdev2->flags)) {
+ 			if (role == 0xfffe) {
+ 				pr_info("md: Removing Candidate device %s because add failed\n", bdevname(rdev2->bdev,b));
+ 				md_kick_rdev_from_array(rdev2);
+ 				continue;
+ 			}
+ 			else
+ 				clear_bit(Candidate, &rdev2->flags);
+ 		}
+ 
+ 		if (role != rdev2->raid_disk) {
+ 			/* got activated */
+ 			if (rdev2->raid_disk == -1 && role != 0xffff) {
+ 				rdev2->saved_raid_disk = role;
+ 				ret = remove_and_add_spares(mddev, rdev2);
+ 				pr_info("Activated spare: %s\n",
+ 					bdevname(rdev2->bdev,b));
+ 				/* wakeup mddev->thread here, so array could
+ 				 * perform resync with the new activated disk */
+ 				set_bit(MD_RECOVERY_NEEDED, &mddev->recovery);
+ 				md_wakeup_thread(mddev->thread);
+ 
+ 			}
+ 			/* device faulty
+ 			 * We just want to do the minimum to mark the disk
+ 			 * as faulty. The recovery is performed by the
+ 			 * one who initiated the error.
+ 			 */
+ 			if ((role == 0xfffe) || (role == 0xfffd)) {
+ 				md_error(mddev, rdev2);
+ 				clear_bit(Blocked, &rdev2->flags);
+ 			}
+ 		}
+ 	}
+ 
+ 	if (mddev->raid_disks != le32_to_cpu(sb->raid_disks))
+ 		update_raid_disks(mddev, le32_to_cpu(sb->raid_disks));
+ 
+ 	/* Finally set the event to be up to date */
+ 	mddev->events = le64_to_cpu(sb->events);
+ }
+ 
+ static int read_rdev(struct mddev *mddev, struct md_rdev *rdev)
+ {
+ 	int err;
+ 	struct page *swapout = rdev->sb_page;
+ 	struct mdp_superblock_1 *sb;
+ 
+ 	/* Store the sb page of the rdev in the swapout temporary
+ 	 * variable in case we err in the future
+ 	 */
+ 	rdev->sb_page = NULL;
+ 	err = alloc_disk_sb(rdev);
+ 	if (err == 0) {
+ 		ClearPageUptodate(rdev->sb_page);
+ 		rdev->sb_loaded = 0;
+ 		err = super_types[mddev->major_version].
+ 			load_super(rdev, NULL, mddev->minor_version);
+ 	}
+ 	if (err < 0) {
+ 		pr_warn("%s: %d Could not reload rdev(%d) err: %d. Restoring old values\n",
+ 				__func__, __LINE__, rdev->desc_nr, err);
+ 		if (rdev->sb_page)
+ 			put_page(rdev->sb_page);
+ 		rdev->sb_page = swapout;
+ 		rdev->sb_loaded = 1;
+ 		return err;
+ 	}
+ 
+ 	sb = page_address(rdev->sb_page);
+ 	/* Read the offset unconditionally, even if MD_FEATURE_RECOVERY_OFFSET
+ 	 * is not set
+ 	 */
+ 
+ 	if ((le32_to_cpu(sb->feature_map) & MD_FEATURE_RECOVERY_OFFSET))
+ 		rdev->recovery_offset = le64_to_cpu(sb->recovery_offset);
+ 
+ 	/* The other node finished recovery, call spare_active to set
+ 	 * device In_sync and mddev->degraded
+ 	 */
+ 	if (rdev->recovery_offset == MaxSector &&
+ 	    !test_bit(In_sync, &rdev->flags) &&
+ 	    mddev->pers->spare_active(mddev))
+ 		sysfs_notify(&mddev->kobj, NULL, "degraded");
+ 
+ 	put_page(swapout);
+ 	return 0;
+ }
+ 
+ void md_reload_sb(struct mddev *mddev, int nr)
+ {
+ 	struct md_rdev *rdev;
+ 	int err;
+ 
+ 	/* Find the rdev */
+ 	rdev_for_each_rcu(rdev, mddev) {
+ 		if (rdev->desc_nr == nr)
+ 			break;
+ 	}
+ 
+ 	if (!rdev || rdev->desc_nr != nr) {
+ 		pr_warn("%s: %d Could not find rdev with nr %d\n", __func__, __LINE__, nr);
+ 		return;
+ 	}
+ 
+ 	err = read_rdev(mddev, rdev);
+ 	if (err < 0)
+ 		return;
+ 
+ 	check_sb_changes(mddev, rdev);
+ 
+ 	/* Read all rdev's to update recovery_offset */
+ 	rdev_for_each_rcu(rdev, mddev)
+ 		read_rdev(mddev, rdev);
+ }
+ EXPORT_SYMBOL(md_reload_sb);
+ 
++>>>>>>> 9d48739ef19a (md: change all printk() to pr_err() or pr_warn() etc.)
  #ifndef MODULE
  
  /*
* Unmerged path drivers/md/md.c
