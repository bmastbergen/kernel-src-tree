mnt: On an unmount propagate clearing of MNT_LOCKED

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 5d88457eb5b86b475422dc882f089203faaeedb5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5d88457e.failed

A prerequisite of calling umount_tree is that the point where the tree
is mounted at is valid to unmount.

If we are propagating the effect of the unmount clear MNT_LOCKED in
every instance where the same filesystem is mounted on the same
mountpoint in the mount tree, as we know (by virtue of the fact
that umount_tree was called) that it is safe to reveal what
is at that mountpoint.

	Cc: stable@vger.kernel.org
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 5d88457eb5b86b475422dc882f089203faaeedb5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index 07e51358b239,2b12b7a9455d..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -1217,13 -1333,26 +1217,24 @@@ void umount_tree(struct mount *mnt, in
  	LIST_HEAD(tmp_list);
  	struct mount *p;
  
++<<<<<<< HEAD
 +	for (p = mnt; p; p = next_mnt(p, mnt))
 +		list_move(&p->mnt_hash, &tmp_list);
++=======
+ 	if (how & UMOUNT_PROPAGATE)
+ 		propagate_mount_unlock(mnt);
+ 
+ 	/* Gather the mounts to umount */
+ 	for (p = mnt; p; p = next_mnt(p, mnt)) {
+ 		p->mnt.mnt_flags |= MNT_UMOUNT;
+ 		list_move(&p->mnt_list, &tmp_list);
+ 	}
++>>>>>>> 5d88457eb5b8 (mnt: On an unmount propagate clearing of MNT_LOCKED)
  
 -	/* Hide the mounts from mnt_mounts */
 -	list_for_each_entry(p, &tmp_list, mnt_list) {
 -		list_del_init(&p->mnt_child);
 -	}
 -
 -	/* Add propogated mounts to the tmp_list */
 -	if (how & UMOUNT_PROPAGATE)
 +	if (propagate)
  		propagate_umount(&tmp_list);
  
 -	while (!list_empty(&tmp_list)) {
 -		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 +	list_for_each_entry(p, &tmp_list, mnt_hash) {
  		list_del_init(&p->mnt_expire);
  		list_del_init(&p->mnt_list);
  		__touch_mnt_namespace(p->mnt_ns);
* Unmerged path fs/namespace.c
diff --git a/fs/pnode.c b/fs/pnode.c
index 4cba0cce1f85..d316cd718ca8 100644
--- a/fs/pnode.c
+++ b/fs/pnode.c
@@ -369,6 +369,26 @@ int propagate_mount_busy(struct mount *mnt, int refcnt)
 	return ret;
 }
 
+/*
+ * Clear MNT_LOCKED when it can be shown to be safe.
+ *
+ * mount_lock lock must be held for write
+ */
+void propagate_mount_unlock(struct mount *mnt)
+{
+	struct mount *parent = mnt->mnt_parent;
+	struct mount *m, *child;
+
+	BUG_ON(parent == mnt);
+
+	for (m = propagation_next(parent, parent); m;
+			m = propagation_next(m, parent)) {
+		child = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);
+		if (child)
+			child->mnt.mnt_flags &= ~MNT_LOCKED;
+	}
+}
+
 /*
  * NOTE: unmounting 'mnt' naturally propagates to all other mounts its
  * parent propagates to.
diff --git a/fs/pnode.h b/fs/pnode.h
index 65e04f65fa1a..247c482b3e00 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -42,6 +42,7 @@ int propagate_mnt(struct mount *, struct mountpoint *, struct mount *,
 		struct list_head *);
 int propagate_umount(struct list_head *);
 int propagate_mount_busy(struct mount *, int);
+void propagate_mount_unlock(struct mount *);
 void mnt_release_group_id(struct mount *);
 int get_dominating_id(struct mount *mnt, const struct path *root);
 unsigned int mnt_get_count(struct mount *mnt);
