bridge: mdb: Marking port-group as offloaded

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Elad Raz <eladr@mellanox.com>
commit 45ebcce56823d14d196dbdecd26783b3d5f464a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/45ebcce5.failed

There is a race-condition when updating the mdb offload flag without using
the mulicast_lock. This reverts commit 9e8430f8d60d98 ("bridge: mdb:
Passing the port-group pointer to br_mdb module").

This patch marks offloaded MDB entry as "offload" by changing the port-
group flags and marks it as MDB_PG_FLAGS_OFFLOAD.

When switchdev PORT_MDB succeeded and adds a multicast group, a completion
callback is been invoked "br_mdb_complete". The completion function
locks the multicast_lock and finds the right net_bridge_port_group and
marks it as offloaded.

Fixes: 9e8430f8d60d98 ("bridge: mdb: Passing the port-group pointer to br_mdb module")
	Reported-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: Elad Raz <eladr@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 45ebcce56823d14d196dbdecd26783b3d5f464a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_mdb.c
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_mdb.c
index 96ac1d431f38,7dbc80d01eb0..000000000000
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@@ -206,9 -256,45 +206,50 @@@ static inline size_t rtnl_mdb_nlmsg_siz
  		+ nla_total_size(sizeof(struct br_mdb_entry));
  }
  
++<<<<<<< HEAD
 +static void __br_mdb_notify(struct net_device *dev, struct br_mdb_entry *entry,
 +			    int type)
++=======
+ struct br_mdb_complete_info {
+ 	struct net_bridge_port *port;
+ 	struct br_ip ip;
+ };
+ 
+ static void br_mdb_complete(struct net_device *dev, int err, void *priv)
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
+ {
+ 	struct br_mdb_complete_info *data = priv;
+ 	struct net_bridge_port_group __rcu **pp;
+ 	struct net_bridge_port_group *p;
+ 	struct net_bridge_mdb_htable *mdb;
+ 	struct net_bridge_mdb_entry *mp;
+ 	struct net_bridge_port *port = data->port;
+ 	struct net_bridge *br = port->br;
+ 
+ 	if (err)
+ 		goto err;
+ 
+ 	spin_lock_bh(&br->multicast_lock);
+ 	mdb = mlock_dereference(br->mdb, br);
+ 	mp = br_mdb_ip_get(mdb, &data->ip);
+ 	if (!mp)
+ 		goto out;
+ 	for (pp = &mp->ports; (p = mlock_dereference(*pp, br)) != NULL;
+ 	     pp = &p->next) {
+ 		if (p->port != port)
+ 			continue;
+ 		p->flags |= MDB_PG_FLAGS_OFFLOAD;
+ 	}
+ out:
+ 	spin_unlock_bh(&br->multicast_lock);
+ err:
+ 	kfree(priv);
+ }
+ 
+ static void __br_mdb_notify(struct net_device *dev, struct net_bridge_port *p,
+ 			    struct br_mdb_entry *entry, int type)
  {
+ 	struct br_mdb_complete_info *complete_info;
  	struct switchdev_obj_port_mdb mdb = {
  		.obj = {
  			.id = SWITCHDEV_OBJ_ID_PORT_MDB,
@@@ -230,10 -316,18 +271,23 @@@
  #endif
  
  	mdb.obj.orig_dev = port_dev;
++<<<<<<< HEAD
 +	if (port_dev && type == RTM_NEWMDB)
 +		switchdev_port_obj_add(port_dev, &mdb.obj);
 +	else if (port_dev && type == RTM_DELMDB)
++=======
+ 	if (port_dev && type == RTM_NEWMDB) {
+ 		complete_info = kmalloc(sizeof(*complete_info), GFP_ATOMIC);
+ 		if (complete_info) {
+ 			complete_info->port = p;
+ 			__mdb_entry_to_br_ip(entry, &complete_info->ip);
+ 			mdb.obj.complete_priv = complete_info;
+ 			mdb.obj.complete = br_mdb_complete;
+ 			switchdev_port_obj_add(port_dev, &mdb.obj);
+ 		}
+ 	} else if (port_dev && type == RTM_DELMDB) {
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
  		switchdev_port_obj_del(port_dev, &mdb.obj);
 -	}
  
  	skb = nlmsg_new(rtnl_mdb_nlmsg_size(), GFP_ATOMIC);
  	if (!skb)
@@@ -252,7 -346,7 +306,11 @@@ errout
  }
  
  void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
++<<<<<<< HEAD
 +		   struct br_ip *group, int type)
++=======
+ 		   struct br_ip *group, int type, u8 flags)
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
  {
  	struct br_mdb_entry entry;
  
@@@ -263,7 -357,76 +321,80 @@@
  #if IS_ENABLED(CONFIG_IPV6)
  	entry.addr.u.ip6 = group->u.ip6;
  #endif
++<<<<<<< HEAD
 +	__br_mdb_notify(dev, &entry, type);
++=======
+ 	entry.vid = group->vid;
+ 	__mdb_entry_fill_flags(&entry, flags);
+ 	__br_mdb_notify(dev, port, &entry, type);
+ }
+ 
+ static int nlmsg_populate_rtr_fill(struct sk_buff *skb,
+ 				   struct net_device *dev,
+ 				   int ifindex, u32 pid,
+ 				   u32 seq, int type, unsigned int flags)
+ {
+ 	struct br_port_msg *bpm;
+ 	struct nlmsghdr *nlh;
+ 	struct nlattr *nest;
+ 
+ 	nlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);
+ 	if (!nlh)
+ 		return -EMSGSIZE;
+ 
+ 	bpm = nlmsg_data(nlh);
+ 	memset(bpm, 0, sizeof(*bpm));
+ 	bpm->family = AF_BRIDGE;
+ 	bpm->ifindex = dev->ifindex;
+ 	nest = nla_nest_start(skb, MDBA_ROUTER);
+ 	if (!nest)
+ 		goto cancel;
+ 
+ 	if (nla_put_u32(skb, MDBA_ROUTER_PORT, ifindex))
+ 		goto end;
+ 
+ 	nla_nest_end(skb, nest);
+ 	nlmsg_end(skb, nlh);
+ 	return 0;
+ 
+ end:
+ 	nla_nest_end(skb, nest);
+ cancel:
+ 	nlmsg_cancel(skb, nlh);
+ 	return -EMSGSIZE;
+ }
+ 
+ static inline size_t rtnl_rtr_nlmsg_size(void)
+ {
+ 	return NLMSG_ALIGN(sizeof(struct br_port_msg))
+ 		+ nla_total_size(sizeof(__u32));
+ }
+ 
+ void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
+ 		   int type)
+ {
+ 	struct net *net = dev_net(dev);
+ 	struct sk_buff *skb;
+ 	int err = -ENOBUFS;
+ 	int ifindex;
+ 
+ 	ifindex = port ? port->dev->ifindex : 0;
+ 	skb = nlmsg_new(rtnl_rtr_nlmsg_size(), GFP_ATOMIC);
+ 	if (!skb)
+ 		goto errout;
+ 
+ 	err = nlmsg_populate_rtr_fill(skb, dev, ifindex, 0, 0, type, NTF_SELF);
+ 	if (err < 0) {
+ 		kfree_skb(skb);
+ 		goto errout;
+ 	}
+ 
+ 	rtnl_notify(skb, net, 0, RTNLGRP_MDB, NULL, GFP_ATOMIC);
+ 	return;
+ 
+ errout:
+ 	rtnl_set_sk_err(net, RTNLGRP_MDB, err);
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
  }
  
  static bool is_valid_mdb_entry(struct br_mdb_entry *entry)
@@@ -413,7 -571,7 +544,11 @@@ static int __br_mdb_add(struct net *net
  static int br_mdb_add(struct sk_buff *skb, struct nlmsghdr *nlh)
  {
  	struct net *net = sock_net(skb->sk);
++<<<<<<< HEAD
 +	unsigned short vid = VLAN_N_VID;
++=======
+ 	struct net_bridge_vlan_group *vg;
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
  	struct net_device *dev, *pdev;
  	struct br_mdb_entry *entry;
  	struct net_bridge_port *p;
@@@ -438,19 -596,19 +573,34 @@@
  	if (!p || p->br != br || p->state == BR_STATE_DISABLED)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	pv = nbp_get_vlan_info(p);
 +	if (br_vlan_enabled(br) && pv && entry->vid == 0) {
 +		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
 +			entry->vid = vid;
 +			err = __br_mdb_add(net, br, entry);
 +			if (err)
 +				break;
 +			__br_mdb_notify(dev, entry, RTM_NEWMDB);
++=======
+ 	vg = nbp_vlan_group(p);
+ 	if (br_vlan_enabled(br) && vg && entry->vid == 0) {
+ 		list_for_each_entry(v, &vg->vlan_list, vlist) {
+ 			entry->vid = v->vid;
+ 			err = __br_mdb_add(net, br, entry);
+ 			if (err)
+ 				break;
+ 			__br_mdb_notify(dev, p, entry, RTM_NEWMDB);
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
  		}
  	} else {
  		err = __br_mdb_add(net, br, entry);
  		if (!err)
++<<<<<<< HEAD
 +			__br_mdb_notify(dev, entry, RTM_NEWMDB);
++=======
+ 			__br_mdb_notify(dev, p, entry, RTM_NEWMDB);
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
  	}
  
  	return err;
@@@ -539,18 -690,18 +689,26 @@@ static int br_mdb_del(struct sk_buff *s
  	if (!p || p->br != br || p->state == BR_STATE_DISABLED)
  		return -EINVAL;
  
 -	vg = nbp_vlan_group(p);
 -	if (br_vlan_enabled(br) && vg && entry->vid == 0) {
 -		list_for_each_entry(v, &vg->vlan_list, vlist) {
 -			entry->vid = v->vid;
 +	pv = nbp_get_vlan_info(p);
 +	if (br_vlan_enabled(br) && pv && entry->vid == 0) {
 +		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
 +			entry->vid = vid;
  			err = __br_mdb_del(br, entry);
  			if (!err)
++<<<<<<< HEAD
 +				__br_mdb_notify(dev, entry, RTM_DELMDB);
++=======
+ 				__br_mdb_notify(dev, p, entry, RTM_DELMDB);
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
  		}
  	} else {
  		err = __br_mdb_del(br, entry);
  		if (!err)
++<<<<<<< HEAD
 +			__br_mdb_notify(dev, entry, RTM_DELMDB);
++=======
+ 			__br_mdb_notify(dev, p, entry, RTM_DELMDB);
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
  	}
  
  	return err;
diff --cc net/bridge/br_multicast.c
index e267dc359e3a,191ea66e4d92..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -272,7 -284,7 +272,11 @@@ static void br_multicast_del_pg(struct 
  		hlist_del_init(&p->mglist);
  		del_timer(&p->timer);
  		br_mdb_notify(br->dev, p->port, &pg->addr, RTM_DELMDB,
++<<<<<<< HEAD
 +			      p->state);
++=======
+ 			      p->flags);
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
  		call_rcu_bh(&p->rcu, br_multicast_free_pg);
  
  		if (!mp->ports && !mp->mglist &&
@@@ -694,7 -706,7 +698,11 @@@ static int br_multicast_add_group(struc
  	if (unlikely(!p))
  		goto err;
  	rcu_assign_pointer(*pp, p);
++<<<<<<< HEAD
 +	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
++=======
+ 	br_mdb_notify(br->dev, port, group, RTM_NEWMDB, 0);
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
  
  found:
  	mod_timer(&p->timer, now + br->multicast_membership_interval);
@@@ -1365,7 -1462,8 +1373,12 @@@ br_multicast_leave_group(struct net_bri
  			hlist_del_init(&p->mglist);
  			del_timer(&p->timer);
  			call_rcu_bh(&p->rcu, br_multicast_free_pg);
++<<<<<<< HEAD
 +			br_mdb_notify(br->dev, port, group, RTM_DELMDB);
++=======
+ 			br_mdb_notify(br->dev, port, group, RTM_DELMDB,
+ 				      p->flags);
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
  
  			if (!mp->ports && !mp->mglist &&
  			    netif_running(br->dev))
diff --cc net/bridge/br_private.h
index b75519ca3c51,d9da857182ef..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -484,7 -561,9 +484,13 @@@ br_multicast_new_port_group(struct net_
  void br_mdb_init(void);
  void br_mdb_uninit(void);
  void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
++<<<<<<< HEAD
 +		   struct br_ip *group, int type);
++=======
+ 		   struct br_ip *group, int type, u8 flags);
+ void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
+ 		   int type);
++>>>>>>> 45ebcce56823 (bridge: mdb: Marking port-group as offloaded)
  
  #define mlock_dereference(X, br) \
  	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
* Unmerged path net/bridge/br_mdb.c
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_private.h
