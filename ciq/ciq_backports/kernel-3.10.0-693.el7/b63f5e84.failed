GFS2: Wake up io waiters whenever a flush is done

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit b63f5e84826b3e1ae81e051a6a7c5a94b657aecb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b63f5e84.failed

Before this patch, if a process called function gfs2_log_reserve to
reserve some journal blocks, but the journal not enough blocks were
free, it would call io_schedule. However, in the log flush daemon,
it woke up the waiters only if an gfs2_ail_flush was no longer
required. This resulted in situations where processes would wait
forever because the number of blocks required was so high that it
pushed the journal into a perpetual state of flush being required.

This patch changes the logd daemon so that it wakes up io waiters
every time the log is actually flushed.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit b63f5e84826b3e1ae81e051a6a7c5a94b657aecb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/log.c
diff --cc fs/gfs2/log.c
index 67ed790519f8,5028a9d00c17..000000000000
--- a/fs/gfs2/log.c
+++ b/fs/gfs2/log.c
@@@ -805,19 -922,22 +806,30 @@@ int gfs2_logd(void *data
  
  	while (!kthread_should_stop()) {
  
+ 		did_flush = false;
  		if (gfs2_jrnl_flush_reqd(sdp) || t == 0) {
  			gfs2_ail1_empty(sdp);
++<<<<<<< HEAD
 +			gfs2_log_flush(sdp, NULL);
++=======
+ 			gfs2_log_flush(sdp, NULL, NORMAL_FLUSH);
+ 			did_flush = true;
++>>>>>>> b63f5e84826b (GFS2: Wake up io waiters whenever a flush is done)
  		}
  
  		if (gfs2_ail_flush_reqd(sdp)) {
  			gfs2_ail1_start(sdp);
  			gfs2_ail1_wait(sdp);
  			gfs2_ail1_empty(sdp);
++<<<<<<< HEAD
 +			gfs2_log_flush(sdp, NULL);
++=======
+ 			gfs2_log_flush(sdp, NULL, NORMAL_FLUSH);
+ 			did_flush = true;
++>>>>>>> b63f5e84826b (GFS2: Wake up io waiters whenever a flush is done)
  		}
  
- 		if (!gfs2_ail_flush_reqd(sdp))
+ 		if (!gfs2_ail_flush_reqd(sdp) || did_flush)
  			wake_up(&sdp->sd_log_waitq);
  
  		t = gfs2_tune_get(sdp, gt_logd_secs) * HZ;
* Unmerged path fs/gfs2/log.c
