net_sched: act: refactor cleanup ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: act: refactor cleanup ops (Ivan Vecera) [1428588]
Rebuild_FUZZ: 94.12%
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit a5b5c958ffd1610545d6b4b8290aa9c5266d10fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a5b5c958.failed

For bindcnt and refcnt etc., they are common for all actions,
not need to repeat such operations for their own, they can be unified
now. Actions just need to do its specific cleanup if needed.

	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Cc: David S. Miller <davem@davemloft.net>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a5b5c958ffd1610545d6b4b8290aa9c5266d10fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_api.c
#	net/sched/act_csum.c
#	net/sched/act_gact.c
#	net/sched/act_ipt.c
#	net/sched/act_mirred.c
#	net/sched/act_nat.c
#	net/sched/act_pedit.c
#	net/sched/act_police.c
#	net/sched/act_simple.c
#	net/sched/act_skbedit.c
diff --cc net/sched/act_api.c
index 34e255487d7a,a5bf9351ce5c..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -62,7 -56,9 +62,13 @@@ int tcf_hash_release(struct tcf_common 
  
  		p->tcfc_refcnt--;
  		if (p->tcfc_bindcnt <= 0 && p->tcfc_refcnt <= 0) {
++<<<<<<< HEAD
 +			tcf_hash_destroy(p, hinfo);
++=======
+ 			if (a->ops->cleanup)
+ 				a->ops->cleanup(a, bind);
+ 			tcf_hash_destroy(a);
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  			ret = 1;
  		}
  	}
diff --cc net/sched/act_csum.c
index 11fe1a416433,8df3060e7ac1..000000000000
--- a/net/sched/act_csum.c
+++ b/net/sched/act_csum.c
@@@ -584,7 -566,6 +584,10 @@@ static struct tc_action_ops act_csum_op
  	.owner		= THIS_MODULE,
  	.act		= tcf_csum,
  	.dump		= tcf_csum_dump,
++<<<<<<< HEAD
 +	.cleanup	= tcf_csum_cleanup,
++=======
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  	.init		= tcf_csum_init,
  };
  
diff --cc net/sched/act_gact.c
index eb9ba60ebab4,094a1b509d75..000000000000
--- a/net/sched/act_gact.c
+++ b/net/sched/act_gact.c
@@@ -206,7 -185,6 +206,10 @@@ static struct tc_action_ops act_gact_op
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_gact,
  	.dump		=	tcf_gact_dump,
++<<<<<<< HEAD
 +	.cleanup	=	tcf_gact_cleanup,
++=======
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  	.init		=	tcf_gact_init,
  };
  
diff --cc net/sched/act_ipt.c
index 90a973aacc76,71f29f1b5a20..000000000000
--- a/net/sched/act_ipt.c
+++ b/net/sched/act_ipt.c
@@@ -78,22 -69,12 +78,31 @@@ static void ipt_destroy_target(struct x
  	module_put(par.target->me);
  }
  
++<<<<<<< HEAD
 +static int tcf_ipt_release(struct tcf_ipt *ipt, int bind)
 +{
 +	int ret = 0;
 +	if (ipt) {
 +		if (bind)
 +			ipt->tcf_bindcnt--;
 +		ipt->tcf_refcnt--;
 +		if (ipt->tcf_bindcnt <= 0 && ipt->tcf_refcnt <= 0) {
 +			ipt_destroy_target(ipt->tcfi_t);
 +			kfree(ipt->tcfi_tname);
 +			kfree(ipt->tcfi_t);
 +			tcf_hash_destroy(&ipt->common, &ipt_hash_info);
 +			ret = ACT_P_DELETED;
 +		}
 +	}
 +	return ret;
++=======
+ static void tcf_ipt_release(struct tc_action *a, int bind)
+ {
+ 	struct tcf_ipt *ipt = to_ipt(a);
+ 	ipt_destroy_target(ipt->tcfi_t);
+ 	kfree(ipt->tcfi_tname);
+ 	kfree(ipt->tcfi_t);
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  }
  
  static const struct nla_policy ipt_policy[TCA_IPT_MAX + 1] = {
@@@ -144,7 -122,7 +153,11 @@@ static int tcf_ipt_init(struct net *net
  	} else {
  		if (bind)/* dont override defaults */
  			return 0;
++<<<<<<< HEAD
 +		tcf_ipt_release(to_ipt(pc), bind);
++=======
+ 		tcf_hash_release(a, bind);
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  
  		if (!ovr)
  			return -EEXIST;
diff --cc net/sched/act_mirred.c
index 3ff85aed0e67,0f00eb96af84..000000000000
--- a/net/sched/act_mirred.c
+++ b/net/sched/act_mirred.c
@@@ -30,32 -30,15 +30,41 @@@
  #include <linux/if_arp.h>
  
  #define MIRRED_TAB_MASK     7
 +static struct tcf_common *tcf_mirred_ht[MIRRED_TAB_MASK + 1];
 +static u32 mirred_idx_gen;
 +static DEFINE_RWLOCK(mirred_lock);
  static LIST_HEAD(mirred_list);
 -static struct tcf_hashinfo mirred_hash_info;
  
++<<<<<<< HEAD
 +static struct tcf_hashinfo mirred_hash_info = {
 +	.htab	=	tcf_mirred_ht,
 +	.hmask	=	MIRRED_TAB_MASK,
 +	.lock	=	&mirred_lock,
 +};
 +
 +static int tcf_mirred_release(struct tcf_mirred *m, int bind)
 +{
 +	if (m) {
 +		if (bind)
 +			m->tcf_bindcnt--;
 +		m->tcf_refcnt--;
 +		if (!m->tcf_bindcnt && m->tcf_refcnt <= 0) {
 +			list_del(&m->tcfm_list);
 +			if (m->tcfm_dev)
 +				dev_put(m->tcfm_dev);
 +			tcf_hash_destroy(&m->common, &mirred_hash_info);
 +			return 1;
 +		}
 +	}
 +	return 0;
++=======
+ static void tcf_mirred_release(struct tc_action *a, int bind)
+ {
+ 	struct tcf_mirred *m = to_mirred(a);
+ 	list_del(&m->tcfm_list);
+ 	if (m->tcfm_dev)
+ 		dev_put(m->tcfm_dev);
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  }
  
  static const struct nla_policy mirred_policy[TCA_MIRRED_MAX + 1] = {
@@@ -120,7 -100,7 +129,11 @@@ static int tcf_mirred_init(struct net *
  		ret = ACT_P_CREATED;
  	} else {
  		if (!ovr) {
++<<<<<<< HEAD
 +			tcf_mirred_release(to_mirred(pc), bind);
++=======
+ 			tcf_hash_release(a, bind);
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  			return -EEXIST;
  		}
  	}
diff --cc net/sched/act_nat.c
index 76869538d028,9a3cb1d16d19..000000000000
--- a/net/sched/act_nat.c
+++ b/net/sched/act_nat.c
@@@ -307,7 -289,6 +307,10 @@@ static struct tc_action_ops act_nat_op
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_nat,
  	.dump		=	tcf_nat_dump,
++<<<<<<< HEAD
 +	.cleanup	=	tcf_nat_cleanup,
++=======
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  	.init		=	tcf_nat_init,
  };
  
diff --cc net/sched/act_pedit.c
index 7aa2dcd989f8,8aa795b275f2..000000000000
--- a/net/sched/act_pedit.c
+++ b/net/sched/act_pedit.c
@@@ -112,18 -99,11 +112,23 @@@ static int tcf_pedit_init(struct net *n
  	return ret;
  }
  
- static int tcf_pedit_cleanup(struct tc_action *a, int bind)
+ static void tcf_pedit_cleanup(struct tc_action *a, int bind)
  {
  	struct tcf_pedit *p = a->priv;
++<<<<<<< HEAD
 +
 +	if (p) {
 +		struct tc_pedit_key *keys = p->tcfp_keys;
 +		if (tcf_hash_release(&p->common, bind, &pedit_hash_info)) {
 +			kfree(keys);
 +			return 1;
 +		}
 +	}
 +	return 0;
++=======
+ 	struct tc_pedit_key *keys = p->tcfp_keys;
+ 	kfree(keys);
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  }
  
  static int tcf_pedit(struct sk_buff *skb, const struct tc_action *a,
diff --cc net/sched/act_police.c
index 376c02554325,7ff7bef065bf..000000000000
--- a/net/sched/act_police.c
+++ b/net/sched/act_police.c
@@@ -408,7 -354,6 +408,10 @@@ static struct tc_action_ops act_police_
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_act_police,
  	.dump		=	tcf_act_police_dump,
++<<<<<<< HEAD
 +	.cleanup	=	tcf_act_police_cleanup,
++=======
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  	.init		=	tcf_act_police_locate,
  	.walk		=	tcf_act_police_walker
  };
diff --cc net/sched/act_simple.c
index f7b45ab85388,14b5e362a1d6..000000000000
--- a/net/sched/act_simple.c
+++ b/net/sched/act_simple.c
@@@ -55,20 -47,10 +55,27 @@@ static int tcf_simp(struct sk_buff *skb
  	return d->tcf_action;
  }
  
++<<<<<<< HEAD
 +static int tcf_simp_release(struct tcf_defact *d, int bind)
 +{
 +	int ret = 0;
 +	if (d) {
 +		if (bind)
 +			d->tcf_bindcnt--;
 +		d->tcf_refcnt--;
 +		if (d->tcf_bindcnt <= 0 && d->tcf_refcnt <= 0) {
 +			kfree(d->tcfd_defdata);
 +			tcf_hash_destroy(&d->common, &simp_hash_info);
 +			ret = 1;
 +		}
 +	}
 +	return ret;
++=======
+ static void tcf_simp_release(struct tc_action *a, int bind)
+ {
+ 	struct tcf_defact *d = to_defact(a);
+ 	kfree(d->tcfd_defdata);
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  }
  
  static int alloc_defdata(struct tcf_defact *d, char *defdata)
@@@ -145,7 -121,7 +152,11 @@@ static int tcf_simp_init(struct net *ne
  
  		if (bind)
  			return 0;
++<<<<<<< HEAD
 +		tcf_simp_release(d, bind);
++=======
+ 		tcf_hash_release(a, bind);
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  		if (!ovr)
  			return -EEXIST;
  
diff --cc net/sched/act_skbedit.c
index 8fe9d25c3008,9f91928fcaeb..000000000000
--- a/net/sched/act_skbedit.c
+++ b/net/sched/act_skbedit.c
@@@ -202,7 -180,6 +202,10 @@@ static struct tc_action_ops act_skbedit
  	.owner		=	THIS_MODULE,
  	.act		=	tcf_skbedit,
  	.dump		=	tcf_skbedit_dump,
++<<<<<<< HEAD
 +	.cleanup	=	tcf_skbedit_cleanup,
++=======
++>>>>>>> a5b5c958ffd1 (net_sched: act: refactor cleanup ops)
  	.init		=	tcf_skbedit_init,
  };
  
diff --git a/include/net/act_api.h b/include/net/act_api.h
index 11aac9abd0ca..7059b39d01cd 100644
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@ -69,7 +69,7 @@ struct tc_action_ops {
 	struct module		*owner;
 	int     (*act)(struct sk_buff *, const struct tc_action *, struct tcf_result *);
 	int     (*dump)(struct sk_buff *, struct tc_action *, int, int);
-	int     (*cleanup)(struct tc_action *, int bind);
+	void	(*cleanup)(struct tc_action *, int bind);
 	int     (*lookup)(struct tc_action *, u32);
 	int     (*init)(struct net *net, struct nlattr *nla,
 			struct nlattr *est, struct tc_action *act, int ovr,
* Unmerged path net/sched/act_api.c
* Unmerged path net/sched/act_csum.c
* Unmerged path net/sched/act_gact.c
* Unmerged path net/sched/act_ipt.c
* Unmerged path net/sched/act_mirred.c
* Unmerged path net/sched/act_nat.c
* Unmerged path net/sched/act_pedit.c
* Unmerged path net/sched/act_police.c
* Unmerged path net/sched/act_simple.c
* Unmerged path net/sched/act_skbedit.c
