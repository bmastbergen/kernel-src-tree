perf tools: Set the maximum allowed stack from /proc/sys/kernel/perf_event_max_stack

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 4cb93446c587d56e2a54f4f83113daba2c0b6dee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4cb93446.failed

There is an upper limit to what tooling considers a valid callchain,
and it was tied to the hardcoded value in the kernel,
PERF_MAX_STACK_DEPTH (127), now that this can be tuned via a sysctl,
make it read it and use that as the upper limit, falling back to
PERF_MAX_STACK_DEPTH for kernels where this sysctl isn't present.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Brendan Gregg <brendan.d.gregg@gmail.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Milian Wolff <milian.wolff@kdab.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-yjqsd30nnkogvj5oyx9ghir9@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 4cb93446c587d56e2a54f4f83113daba2c0b6dee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-trace.txt
#	tools/perf/builtin-trace.c
diff --cc tools/perf/Documentation/perf-trace.txt
index 13293de8869f,6afe20121bc0..000000000000
--- a/tools/perf/Documentation/perf-trace.txt
+++ b/tools/perf/Documentation/perf-trace.txt
@@@ -120,6 -120,38 +120,28 @@@ the thread executes on the designated C
  --event::
  	Trace other events, see 'perf list' for a complete list.
  
++<<<<<<< HEAD
++=======
+ --max-stack::
+         Set the stack depth limit when parsing the callchain, anything
+         beyond the specified depth will be ignored. Note that at this point
+         this is just about the presentation part, i.e. the kernel is still
+         not limiting, the overhead of callchains needs to be set via the
+         knobs in --call-graph dwarf.
+ 
+         Implies '--call-graph dwarf' when --call-graph not present on the
+         command line, on systems where DWARF unwinding was built in.
+ 
+         Default: /proc/sys/kernel/perf_event_max_stack when present, 127 otherwise.
+ 
+ --min-stack::
+         Set the stack depth limit when parsing the callchain, anything
+         below the specified depth will be ignored. Disabled by default.
+ 
+         Implies '--call-graph dwarf' when --call-graph not present on the
+         command line, on systems where DWARF unwinding was built in.
+ 
++>>>>>>> 4cb93446c587 (perf tools: Set the maximum allowed stack from /proc/sys/kernel/perf_event_max_stack)
  --proc-map-timeout::
  	When processing pre-existing threads /proc/XXX/mmap, it may take a long time,
  	because the file may be huge. A time out is needed in such cases.
diff --cc tools/perf/builtin-trace.c
index 75f64f4b8495,f4f3389c92c7..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -2925,6 -3095,18 +2925,21 @@@ int cmd_trace(int argc, const char **ar
  		     "Trace pagefaults", parse_pagefaults, "maj"),
  	OPT_BOOLEAN(0, "syscalls", &trace.trace_syscalls, "Trace syscalls"),
  	OPT_BOOLEAN('f', "force", &trace.force, "don't complain, do it"),
++<<<<<<< HEAD
++=======
+ 	OPT_CALLBACK(0, "call-graph", &trace.opts,
+ 		     "record_mode[,record_size]", record_callchain_help,
+ 		     &record_parse_callchain_opt),
+ 	OPT_BOOLEAN(0, "kernel-syscall-graph", &trace.kernel_syscallchains,
+ 		    "Show the kernel callchains on the syscall exit path"),
+ 	OPT_UINTEGER(0, "min-stack", &trace.min_stack,
+ 		     "Set the minimum stack depth when parsing the callchain, "
+ 		     "anything below the specified depth will be ignored."),
+ 	OPT_UINTEGER(0, "max-stack", &trace.max_stack,
+ 		     "Set the maximum stack depth when parsing the callchain, "
+ 		     "anything beyond the specified depth will be ignored. "
+ 		     "Default: kernel.perf_event_max_stack or " __stringify(PERF_MAX_STACK_DEPTH)),
++>>>>>>> 4cb93446c587 (perf tools: Set the maximum allowed stack from /proc/sys/kernel/perf_event_max_stack)
  	OPT_UINTEGER(0, "proc-map-timeout", &trace.opts.proc_map_timeout,
  			"per thread proc mmap processing timeout in ms"),
  	OPT_END()
@@@ -2952,6 -3146,26 +2967,29 @@@
  		trace.opts.sample_time = true;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (trace.opts.mmap_pages == UINT_MAX)
+ 		mmap_pages_user_set = false;
+ 
+ 	if (trace.max_stack == UINT_MAX) {
+ 		trace.max_stack = sysctl_perf_event_max_stack;
+ 		max_stack_user_set = false;
+ 	}
+ 
+ #ifdef HAVE_DWARF_UNWIND_SUPPORT
+ 	if ((trace.min_stack || max_stack_user_set) && !callchain_param.enabled)
+ 		record_opts__parse_callchain(&trace.opts, &callchain_param, "dwarf", false);
+ #endif
+ 
+ 	if (callchain_param.enabled) {
+ 		if (!mmap_pages_user_set && geteuid() == 0)
+ 			trace.opts.mmap_pages = perf_event_mlock_kb_in_pages() * 4;
+ 
+ 		symbol_conf.use_callchain = true;
+ 	}
+ 
++>>>>>>> 4cb93446c587 (perf tools: Set the maximum allowed stack from /proc/sys/kernel/perf_event_max_stack)
  	if (trace.evlist->nr_entries > 0)
  		evlist__set_evsel_handler(trace.evlist, trace__event_handler);
  
diff --git a/tools/perf/Documentation/perf-report.txt b/tools/perf/Documentation/perf-report.txt
index 496d42cdf02b..ebaf849e30ef 100644
--- a/tools/perf/Documentation/perf-report.txt
+++ b/tools/perf/Documentation/perf-report.txt
@@ -248,7 +248,7 @@ OPTIONS
 	Note that when using the --itrace option the synthesized callchain size
 	will override this value if the synthesized callchain size is bigger.
 
-	Default: 127
+	Default: /proc/sys/kernel/perf_event_max_stack when present, 127 otherwise.
 
 -G::
 --inverted::
diff --git a/tools/perf/Documentation/perf-script.txt b/tools/perf/Documentation/perf-script.txt
index 4fc44c75263f..a856a1095893 100644
--- a/tools/perf/Documentation/perf-script.txt
+++ b/tools/perf/Documentation/perf-script.txt
@@ -267,7 +267,7 @@ include::itrace.txt[]
         Note that when using the --itrace option the synthesized callchain size
         will override this value if the synthesized callchain size is bigger.
 
-        Default: 127
+        Default: /proc/sys/kernel/perf_event_max_stack when present, 127 otherwise.
 
 --ns::
 	Use 9 decimal places when displaying time (i.e. show the nanoseconds)
diff --git a/tools/perf/Documentation/perf-top.txt b/tools/perf/Documentation/perf-top.txt
index 19f046f027cd..91d638df3a6b 100644
--- a/tools/perf/Documentation/perf-top.txt
+++ b/tools/perf/Documentation/perf-top.txt
@@ -177,7 +177,7 @@ Default is to monitor all CPUS.
 	between information loss and faster processing especially for
 	workloads that can have a very long callchain stack.
 
-	Default: 127
+	Default: /proc/sys/kernel/perf_event_max_stack when present, 127 otherwise.
 
 --ignore-callees=<regex>::
         Ignore callees of the function(s) matching the given regex.
* Unmerged path tools/perf/Documentation/perf-trace.txt
diff --git a/tools/perf/builtin-report.c b/tools/perf/builtin-report.c
index 1d5be0bd426f..8d9b88af901d 100644
--- a/tools/perf/builtin-report.c
+++ b/tools/perf/builtin-report.c
@@ -691,7 +691,7 @@ int cmd_report(int argc, const char **argv, const char *prefix __maybe_unused)
 			.ordered_events	 = true,
 			.ordering_requires_timestamps = true,
 		},
-		.max_stack		 = PERF_MAX_STACK_DEPTH,
+		.max_stack		 = sysctl_perf_event_max_stack,
 		.pretty_printing_style	 = "normal",
 		.socket_filter		 = -1,
 	};
@@ -744,7 +744,7 @@ int cmd_report(int argc, const char **argv, const char *prefix __maybe_unused)
 	OPT_INTEGER(0, "max-stack", &report.max_stack,
 		    "Set the maximum stack depth when parsing the callchain, "
 		    "anything beyond the specified depth will be ignored. "
-		    "Default: " __stringify(PERF_MAX_STACK_DEPTH)),
+		    "Default: kernel.perf_event_max_stack or " __stringify(PERF_MAX_STACK_DEPTH)),
 	OPT_BOOLEAN('G', "inverted", &report.inverted_callchain,
 		    "alias for inverted call graph"),
 	OPT_CALLBACK(0, "ignore-callees", NULL, "regex",
diff --git a/tools/perf/builtin-script.c b/tools/perf/builtin-script.c
index 4ad8f074e784..7a38f84e6e12 100644
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@ -1942,7 +1942,7 @@ int cmd_script(int argc, const char **argv, const char *prefix __maybe_unused)
 	OPT_UINTEGER(0, "max-stack", &scripting_max_stack,
 		     "Set the maximum stack depth when parsing the callchain, "
 		     "anything beyond the specified depth will be ignored. "
-		     "Default: " __stringify(PERF_MAX_STACK_DEPTH)),
+		     "Default: kernel.perf_event_max_stack or " __stringify(PERF_MAX_STACK_DEPTH)),
 	OPT_BOOLEAN('I', "show-info", &show_full_info,
 		    "display extended information from perf.data file"),
 	OPT_BOOLEAN('\0', "show-kernel-path", &symbol_conf.show_kernel_path,
@@ -1978,6 +1978,8 @@ int cmd_script(int argc, const char **argv, const char *prefix __maybe_unused)
 		NULL
 	};
 
+	scripting_max_stack = sysctl_perf_event_max_stack;
+
 	setup_scripting();
 
 	argc = parse_options_subcommand(argc, argv, options, script_subcommands, script_usage,
diff --git a/tools/perf/builtin-top.c b/tools/perf/builtin-top.c
index 9ea9a0353626..34973bc3567e 100644
--- a/tools/perf/builtin-top.c
+++ b/tools/perf/builtin-top.c
@@ -1104,7 +1104,7 @@ int cmd_top(int argc, const char **argv, const char *prefix __maybe_unused)
 			},
 			.proc_map_timeout    = 500,
 		},
-		.max_stack	     = PERF_MAX_STACK_DEPTH,
+		.max_stack	     = sysctl_perf_event_max_stack,
 		.sym_pcnt_filter     = 5,
 	};
 	struct record_opts *opts = &top.record_opts;
@@ -1172,7 +1172,7 @@ int cmd_top(int argc, const char **argv, const char *prefix __maybe_unused)
 		    "Accumulate callchains of children and show total overhead as well"),
 	OPT_INTEGER(0, "max-stack", &top.max_stack,
 		    "Set the maximum stack depth when parsing the callchain. "
-		    "Default: " __stringify(PERF_MAX_STACK_DEPTH)),
+		    "Default: kernel.perf_event_max_stack or " __stringify(PERF_MAX_STACK_DEPTH)),
 	OPT_CALLBACK(0, "ignore-callees", NULL, "regex",
 		   "ignore callees of these functions in call graphs",
 		   report_parse_ignore_callees_opt),
* Unmerged path tools/perf/builtin-trace.c
diff --git a/tools/perf/perf.c b/tools/perf/perf.c
index c8a3a15d825c..0326dfd53bd5 100644
--- a/tools/perf/perf.c
+++ b/tools/perf/perf.c
@@ -16,6 +16,7 @@
 #include "util/parse-events.h"
 #include <subcmd/parse-options.h>
 #include "util/debug.h"
+#include <api/fs/fs.h>
 #include <api/fs/tracing_path.h>
 #include <pthread.h>
 #include <stdlib.h>
@@ -531,6 +532,7 @@ int main(int argc, const char **argv)
 {
 	const char *cmd;
 	char sbuf[STRERR_BUFSIZE];
+	int value;
 
 	/* libsubcmd init */
 	exec_cmd_init("perf", PREFIX, PERF_EXEC_PATH, EXEC_PATH_ENVIRONMENT);
@@ -540,6 +542,9 @@ int main(int argc, const char **argv)
 	page_size = sysconf(_SC_PAGE_SIZE);
 	cacheline_size = sysconf(_SC_LEVEL1_DCACHE_LINESIZE);
 
+	if (sysctl__read_int("kernel/perf_event_max_stack", &value) == 0)
+		sysctl_perf_event_max_stack = value;
+
 	cmd = extract_argv0_path(argv[0]);
 	if (!cmd)
 		cmd = "perf-help";
diff --git a/tools/perf/tests/hists_cumulate.c b/tools/perf/tests/hists_cumulate.c
index ed5aa9eaeb6c..4a2bbff9b1ee 100644
--- a/tools/perf/tests/hists_cumulate.c
+++ b/tools/perf/tests/hists_cumulate.c
@@ -101,7 +101,7 @@ static int add_hist_entries(struct hists *hists, struct machine *machine)
 		if (machine__resolve(machine, &al, &sample) < 0)
 			goto out;
 
-		if (hist_entry_iter__add(&iter, &al, PERF_MAX_STACK_DEPTH,
+		if (hist_entry_iter__add(&iter, &al, sysctl_perf_event_max_stack,
 					 NULL) < 0) {
 			addr_location__put(&al);
 			goto out;
diff --git a/tools/perf/tests/hists_filter.c b/tools/perf/tests/hists_filter.c
index b825d24f8186..e846f8c42013 100644
--- a/tools/perf/tests/hists_filter.c
+++ b/tools/perf/tests/hists_filter.c
@@ -81,7 +81,7 @@ static int add_hist_entries(struct perf_evlist *evlist,
 
 			al.socket = fake_samples[i].socket;
 			if (hist_entry_iter__add(&iter, &al,
-						 PERF_MAX_STACK_DEPTH, NULL) < 0) {
+						 sysctl_perf_event_max_stack, NULL) < 0) {
 				addr_location__put(&al);
 				goto out;
 			}
diff --git a/tools/perf/tests/hists_output.c b/tools/perf/tests/hists_output.c
index d3556fbe8c5c..7cd8738e842f 100644
--- a/tools/perf/tests/hists_output.c
+++ b/tools/perf/tests/hists_output.c
@@ -67,7 +67,7 @@ static int add_hist_entries(struct hists *hists, struct machine *machine)
 		if (machine__resolve(machine, &al, &sample) < 0)
 			goto out;
 
-		if (hist_entry_iter__add(&iter, &al, PERF_MAX_STACK_DEPTH,
+		if (hist_entry_iter__add(&iter, &al, sysctl_perf_event_max_stack,
 					 NULL) < 0) {
 			addr_location__put(&al);
 			goto out;
diff --git a/tools/perf/util/machine.c b/tools/perf/util/machine.c
index 79d3c2f665e1..5be3b29a4e71 100644
--- a/tools/perf/util/machine.c
+++ b/tools/perf/util/machine.c
@@ -1762,7 +1762,7 @@ static int resolve_lbr_callchain_sample(struct thread *thread,
 		 */
 		int mix_chain_nr = i + 1 + lbr_nr + 1;
 
-		if (mix_chain_nr > PERF_MAX_STACK_DEPTH + PERF_MAX_BRANCH_DEPTH) {
+		if (mix_chain_nr > (int)sysctl_perf_event_max_stack + PERF_MAX_BRANCH_DEPTH) {
 			pr_warning("corrupted callchain. skipping...\n");
 			return 0;
 		}
@@ -1822,7 +1822,7 @@ static int thread__resolve_callchain_sample(struct thread *thread,
 	 * Based on DWARF debug information, some architectures skip
 	 * a callchain entry saved by the kernel.
 	 */
-	if (chain->nr < PERF_MAX_STACK_DEPTH)
+	if (chain->nr < sysctl_perf_event_max_stack)
 		skip_idx = arch_skip_callchain_idx(thread, chain);
 
 	/*
@@ -1883,7 +1883,7 @@ static int thread__resolve_callchain_sample(struct thread *thread,
 	}
 
 check_calls:
-	if (chain->nr > PERF_MAX_STACK_DEPTH && (int)chain->nr > max_stack) {
+	if (chain->nr > sysctl_perf_event_max_stack && (int)chain->nr > max_stack) {
 		pr_warning("corrupted callchain. skipping...\n");
 		return 0;
 	}
diff --git a/tools/perf/util/scripting-engines/trace-event-perl.c b/tools/perf/util/scripting-engines/trace-event-perl.c
index 2ce059a95b6d..6f72167c0ca5 100644
--- a/tools/perf/util/scripting-engines/trace-event-perl.c
+++ b/tools/perf/util/scripting-engines/trace-event-perl.c
@@ -265,7 +265,7 @@ static SV *perl_process_callchain(struct perf_sample *sample,
 
 	if (thread__resolve_callchain(al->thread, evsel,
 				      sample, NULL, NULL,
-				      PERF_MAX_STACK_DEPTH) != 0) {
+				      sysctl_perf_event_max_stack) != 0) {
 		pr_err("Failed to resolve callchain. Skipping\n");
 		goto exit;
 	}
diff --git a/tools/perf/util/util.c b/tools/perf/util/util.c
index 85623368c136..6c0081ae93f2 100644
--- a/tools/perf/util/util.c
+++ b/tools/perf/util/util.c
@@ -32,6 +32,8 @@ struct callchain_param	callchain_param = {
 unsigned int page_size;
 int cacheline_size;
 
+unsigned int sysctl_perf_event_max_stack = PERF_MAX_STACK_DEPTH;
+
 bool test_attr__enabled;
 
 bool perf_host  = true;
diff --git a/tools/perf/util/util.h b/tools/perf/util/util.h
index fc2c6c713c4b..54638ec2c57a 100644
--- a/tools/perf/util/util.h
+++ b/tools/perf/util/util.h
@@ -267,6 +267,7 @@ void sighandler_dump_stack(int sig);
 
 extern unsigned int page_size;
 extern int cacheline_size;
+extern unsigned int sysctl_perf_event_max_stack;
 
 struct parse_tag {
 	char tag;
