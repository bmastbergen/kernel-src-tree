geneve: fix hlist corruption

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 4b4c21fad6ae6bd58ff1566f23b0f4f70fdc9a30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4b4c21fa.failed

It's not a good idea to add the same hlist_node to two different hash lists.
This leads to various hard to debug memory corruptions.

Fixes: 8ed66f0e8235 ("geneve: implement support for IPv6-based tunnels")
	Cc: John W. Linville <linville@tuxdriver.com>
	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4b4c21fad6ae6bd58ff1566f23b0f4f70fdc9a30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
diff --cc drivers/net/geneve.c
index d6abacdaaf40,de8156c6b292..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -44,43 -43,32 +44,51 @@@ struct geneve_net 
  	struct list_head	sock_list;
  };
  
 -static unsigned int geneve_net_id;
 +static int geneve_net_id;
 +
 +union geneve_addr {
 +	struct sockaddr_in sin;
 +	struct sockaddr_in6 sin6;
 +	struct sockaddr sa;
 +};
 +
 +static union geneve_addr geneve_remote_unspec = { .sa.sa_family = AF_UNSPEC, };
  
+ struct geneve_dev_node {
+ 	struct hlist_node hlist;
+ 	struct geneve_dev *geneve;
+ };
+ 
  /* Pseudo network device */
  struct geneve_dev {
- 	struct hlist_node  hlist;	/* vni hash table */
+ 	struct geneve_dev_node hlist4;	/* vni hash table for IPv4 socket */
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	struct geneve_dev_node hlist6;	/* vni hash table for IPv6 socket */
+ #endif
  	struct net	   *net;	/* netns for packet i/o */
  	struct net_device  *dev;	/* netdev for geneve tunnel */
 -	struct ip_tunnel_info info;
 -	struct geneve_sock __rcu *sock4;	/* IPv4 socket used for geneve tunnel */
 +	struct geneve_sock *sock4;	/* IPv4 socket used for geneve tunnel */
  #if IS_ENABLED(CONFIG_IPV6)
 -	struct geneve_sock __rcu *sock6;	/* IPv6 socket used for geneve tunnel */
 +	struct geneve_sock *sock6;	/* IPv6 socket used for geneve tunnel */
  #endif
 +	u8                 vni[3];	/* virtual network ID for tunnel */
 +	u8                 ttl;		/* TTL override */
 +	u8                 tos;		/* TOS override */
 +	union geneve_addr  remote;	/* IP address for link partner */
  	struct list_head   next;	/* geneve's per namespace list */
 -	struct gro_cells   gro_cells;
 +	__be32		   label;	/* IPv6 flowlabel override */
 +	__be16		   dst_port;
  	bool		   collect_md;
 -	bool		   use_udp6_rx_checksums;
 +	struct gro_cells   gro_cells;
 +	u32		   flags;
 +	struct dst_cache   dst_cache;
  };
  
 +/* Geneve device flags */
 +#define GENEVE_F_UDP_ZERO_CSUM_TX	BIT(0)
 +#define GENEVE_F_UDP_ZERO_CSUM6_TX	BIT(1)
 +#define GENEVE_F_UDP_ZERO_CSUM6_RX	BIT(2)
 +
  struct geneve_sock {
  	bool			collect_md;
  	struct list_head	list;
@@@ -125,10 -137,10 +133,17 @@@ static struct geneve_dev *geneve_lookup
  	/* Find the device for this VNI */
  	hash = geneve_net_vni_hash(vni);
  	vni_list_head = &gs->vni_list[hash];
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(geneve, vni_list_head, hlist) {
 +		if (!memcmp(vni, geneve->vni, sizeof(geneve->vni)) &&
 +		    addr == geneve->remote.sin.sin_addr.s_addr)
 +			return geneve;
++=======
+ 	hlist_for_each_entry_rcu(node, vni_list_head, hlist) {
+ 		if (eq_tun_id_and_vni((u8 *)&node->geneve->info.key.tun_id, vni) &&
+ 		    addr == node->geneve->info.key.u.ipv4.dst)
+ 			return node->geneve;
++>>>>>>> 4b4c21fad6ae (geneve: fix hlist corruption)
  	}
  	return NULL;
  }
@@@ -144,10 -156,10 +159,17 @@@ static struct geneve_dev *geneve6_looku
  	/* Find the device for this VNI */
  	hash = geneve_net_vni_hash(vni);
  	vni_list_head = &gs->vni_list[hash];
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(geneve, vni_list_head, hlist) {
 +		if (!memcmp(vni, geneve->vni, sizeof(geneve->vni)) &&
 +		    ipv6_addr_equal(&addr6, &geneve->remote.sin6.sin6_addr))
 +			return geneve;
++=======
+ 	hlist_for_each_entry_rcu(node, vni_list_head, hlist) {
+ 		if (eq_tun_id_and_vni((u8 *)&node->geneve->info.key.tun_id, vni) &&
+ 		    ipv6_addr_equal(&addr6, &node->geneve->info.key.u.ipv6.dst))
+ 			return node->geneve;
++>>>>>>> 4b4c21fad6ae (geneve: fix hlist corruption)
  	}
  	return NULL;
  }
@@@ -569,10 -599,12 +591,11 @@@ static int geneve_sock_add(struct genev
  {
  	struct net *net = geneve->net;
  	struct geneve_net *gn = net_generic(net, geneve_net_id);
+ 	struct geneve_dev_node *node;
  	struct geneve_sock *gs;
 -	__u8 vni[3];
  	__u32 hash;
  
 -	gs = geneve_find_sock(gn, ipv6 ? AF_INET6 : AF_INET, geneve->info.key.tp_dst);
 +	gs = geneve_find_sock(gn, ipv6 ? AF_INET6 : AF_INET, geneve->dst_port);
  	if (gs) {
  		gs->refcnt++;
  		goto out;
@@@ -584,16 -617,21 +607,33 @@@
  
  out:
  	gs->collect_md = geneve->collect_md;
 +	gs->flags = geneve->flags;
  #if IS_ENABLED(CONFIG_IPV6)
++<<<<<<< HEAD
 +	if (ipv6)
 +		geneve->sock6 = gs;
 +	else
 +#endif
 +		geneve->sock4 = gs;
 +
 +	hash = geneve_net_vni_hash(geneve->vni);
 +	hlist_add_head_rcu(&geneve->hlist, &gs->vni_list[hash]);
++=======
+ 	if (ipv6) {
+ 		rcu_assign_pointer(geneve->sock6, gs);
+ 		node = &geneve->hlist6;
+ 	} else
+ #endif
+ 	{
+ 		rcu_assign_pointer(geneve->sock4, gs);
+ 		node = &geneve->hlist4;
+ 	}
+ 	node->geneve = geneve;
+ 
+ 	tunnel_id_to_vni(geneve->info.key.tun_id, vni);
+ 	hash = geneve_net_vni_hash(vni);
+ 	hlist_add_head_rcu(&node->hlist, &gs->vni_list[hash]);
++>>>>>>> 4b4c21fad6ae (geneve: fix hlist corruption)
  	return 0;
  }
  
* Unmerged path drivers/net/geneve.c
