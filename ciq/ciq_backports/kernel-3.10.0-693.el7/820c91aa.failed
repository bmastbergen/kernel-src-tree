fm10k: use common reset flow when handling io errors from PCI stack

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 820c91aa9c39e1923fbe4a6593b3d2dfd7ad593f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/820c91aa.failed

Now that we have extracted the necessary steps for a split
suspend/resume flow, re-use these functions instead of using the current
open coded flow. This ensures that we don't miss any steps. It also
ensures that we have the correct driver states set.

Since we'll be handling all of the reset flow ourselves, we no longer
need to request a reset in the io_slot_reset() function.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Krishneil Singh <Krishneil.k.singh@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 820c91aa9c39e1923fbe4a6593b3d2dfd7ad593f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/fm10k/fm10k_pci.c
diff --cc drivers/net/ethernet/intel/fm10k/fm10k_pci.c
index 012e762ca41a,716a5c852143..000000000000
--- a/drivers/net/ethernet/intel/fm10k/fm10k_pci.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_pci.c
@@@ -2496,47 -2362,15 +2479,45 @@@ static void fm10k_io_resume(struct pci_
  {
  	struct fm10k_intfc *interface = pci_get_drvdata(pdev);
  	struct net_device *netdev = interface->netdev;
- 	struct fm10k_hw *hw = &interface->hw;
- 	int err = 0;
+ 	int err;
  
- 	/* reset hardware to known state */
- 	err = hw->mac.ops.init_hw(&interface->hw);
- 	if (err) {
- 		dev_err(&pdev->dev, "init_hw failed: %d\n", err);
- 		return;
- 	}
+ 	err = fm10k_handle_resume(interface);
  
++<<<<<<< HEAD
 +	/* reset statistics starting values */
 +	hw->mac.ops.rebind_hw_stats(hw, &interface->stats);
 +
 +	rtnl_lock();
 +
 +	err = fm10k_init_queueing_scheme(interface);
 +	if (err) {
 +		dev_err(&interface->pdev->dev,
 +			"init_queueing_scheme failed: %d\n", err);
 +		goto unlock;
 +	}
 +
 +	/* reassociate interrupts */
 +	fm10k_mbx_request_irq(interface);
 +
 +	/* reset clock */
 +	fm10k_ts_reset(interface);
 +
 +	rtnl_lock();
 +	if (netif_running(netdev))
 +		err = fm10k_open(netdev);
 +	rtnl_unlock();
 +
 +	/* final check of hardware state before registering the interface */
 +	err = err ? : fm10k_hw_ready(interface);
 +
 +	if (!err)
++=======
+ 	if (err)
+ 		dev_warn(&pdev->dev,
+ 			 "fm10k_io_resume failed: %d\n", err);
+ 	else
++>>>>>>> 820c91aa9c39 (fm10k: use common reset flow when handling io errors from PCI stack)
  		netif_device_attach(netdev);
- 
- unlock:
- 	rtnl_unlock();
  }
  
  static const struct pci_error_handlers fm10k_err_handler = {
* Unmerged path drivers/net/ethernet/intel/fm10k/fm10k_pci.c
