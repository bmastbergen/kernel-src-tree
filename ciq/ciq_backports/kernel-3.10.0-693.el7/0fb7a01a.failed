random: simplify accounting code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Greg Price <price@MIT.EDU>
commit 0fb7a01af5b0cbe5bf365891fc4d186f2caa23f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0fb7a01a.failed

With this we handle "reserved" in just one place.  As a bonus the
code becomes less nested, and the "wakeup_write" flag variable
becomes unnecessary.  The variable "flags" was already unused.

This code behaves identically to the previous version except in
two pathological cases that don't occur.  If the argument "nbytes"
is already less than "min", then we didn't previously enforce
"min".  If r->limit is false while "reserved" is nonzero, then we
previously applied "reserved" in checking whether we had enough
bits, even though we don't apply it to actually limit how many we
take.  The callers of account() never exercise either of these cases.

Before the previous commit, it was possible for "nbytes" to be less
than "min" if userspace chose a pathological configuration, but no
longer.

	Cc: Jiri Kosina <jkosina@suse.cz>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Signed-off-by: Greg Price <price@mit.edu>
	Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
(cherry picked from commit 0fb7a01af5b0cbe5bf365891fc4d186f2caa23f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/random.c
diff --cc drivers/char/random.c
index 71f7f741fbfa,ded4339be8f9..000000000000
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@@ -949,28 -975,19 +947,28 @@@ retry
  	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
  	have_bytes = entropy_count >> (ENTROPY_SHIFT + 3);
  	ibytes = nbytes;
- 	if (have_bytes < min + reserved) {
+ 	/* If limited, never pull more than available */
+ 	if (r->limit)
+ 		ibytes = min_t(size_t, ibytes, have_bytes - reserved);
+ 	if (ibytes < min)
  		ibytes = 0;
- 	} else {
- 		/* If limited, never pull more than available */
- 		if (r->limit)
- 			ibytes = min_t(size_t, ibytes, have_bytes - reserved);
- 		entropy_count = max_t(int, 0,
- 			    entropy_count - (ibytes << (ENTROPY_SHIFT + 3)));
- 		if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
- 			goto retry;
- 
- 		if ((r->entropy_count >> ENTROPY_SHIFT)
- 		    < random_write_wakeup_thresh)
- 			wakeup_write = 1;
- 	}
+ 	entropy_count = max_t(int, 0,
+ 			      entropy_count - (ibytes << (ENTROPY_SHIFT + 3)));
+ 	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
+ 		goto retry;
  
++<<<<<<< HEAD
 +	DEBUG_ENT("debiting %zu entropy credits from %s%s\n",
 +		  ibytes * 8, r->name, r->limit ? "" : " (unlimited)");
 +
 +	spin_unlock_irqrestore(&r->lock, flags);
 +
 +	if (wakeup_write) {
++=======
+ 	trace_debit_entropy(r->name, 8 * ibytes);
+ 	if (ibytes &&
+ 	    (r->entropy_count >> ENTROPY_SHIFT) < random_write_wakeup_thresh) {
++>>>>>>> 0fb7a01af5b0 (random: simplify accounting code)
  		wake_up_interruptible(&random_write_wait);
  		kill_fasync(&fasync, SIGIO, POLL_OUT);
  	}
* Unmerged path drivers/char/random.c
