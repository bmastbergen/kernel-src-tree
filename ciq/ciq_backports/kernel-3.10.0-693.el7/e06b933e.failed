namespace: update event counter when umounting a deleted dentry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Andrey Ulanov <andreyu@google.com>
commit e06b933e6ded42384164d28a2060b7f89243b895
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e06b933e.failed

- m_start() in fs/namespace.c expects that ns->event is incremented each
  time a mount added or removed from ns->list.
- umount_tree() removes items from the list but does not increment event
  counter, expecting that it's done before the function is called.
- There are some codepaths that call umount_tree() without updating
  "event" counter. e.g. from __detach_mounts().
- When this happens m_start may reuse a cached mount structure that no
  longer belongs to ns->list (i.e. use after free which usually leads
  to infinite loop).

This change fixes the above problem by incrementing global event counter
before invoking umount_tree().

Change-Id: I622c8e84dcb9fb63542372c5dbf0178ee86bb589
	Cc: stable@vger.kernel.org
	Signed-off-by: Andrey Ulanov <andreyu@google.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit e06b933e6ded42384164d28a2060b7f89243b895)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index 91fbddebae10,298618b88bba..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -1335,6 -1541,42 +1335,45 @@@ static int do_umount(struct mount *mnt
  	return retval;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * __detach_mounts - lazily unmount all mounts on the specified dentry
+  *
+  * During unlink, rmdir, and d_drop it is possible to loose the path
+  * to an existing mountpoint, and wind up leaking the mount.
+  * detach_mounts allows lazily unmounting those mounts instead of
+  * leaking them.
+  *
+  * The caller may hold dentry->d_inode->i_mutex.
+  */
+ void __detach_mounts(struct dentry *dentry)
+ {
+ 	struct mountpoint *mp;
+ 	struct mount *mnt;
+ 
+ 	namespace_lock();
+ 	mp = lookup_mountpoint(dentry);
+ 	if (IS_ERR_OR_NULL(mp))
+ 		goto out_unlock;
+ 
+ 	lock_mount_hash();
+ 	event++;
+ 	while (!hlist_empty(&mp->m_list)) {
+ 		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
+ 		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
+ 			hlist_add_head(&mnt->mnt_umount.s_list, &unmounted);
+ 			umount_mnt(mnt);
+ 		}
+ 		else umount_tree(mnt, UMOUNT_CONNECTED);
+ 	}
+ 	unlock_mount_hash();
+ 	put_mountpoint(mp);
+ out_unlock:
+ 	namespace_unlock();
+ }
+ 
++>>>>>>> e06b933e6ded (namespace: update event counter when umounting a deleted dentry)
  /* 
   * Is the caller allowed to modify his namespace?
   */
* Unmerged path fs/namespace.c
