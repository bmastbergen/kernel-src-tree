xprtrdma: fix semicolon.cocci warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author kbuild test robot <fengguang.wu@intel.com>
commit 53d7852307295b4576777618cbc2684bb191fb46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/53d78523.failed

net/sunrpc/xprtrdma/verbs.c:798:2-3: Unneeded semicolon

 Remove unneeded semicolon.

Generated by: scripts/coccinelle/misc/semicolon.cocci

CC: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>
	Reviewed-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 53d7852307295b4576777618cbc2684bb191fb46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/verbs.c
diff --cc net/sunrpc/xprtrdma/verbs.c
index 852c524a0dd0,536d0be3f61b..000000000000
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@@ -777,6 -747,90 +777,93 @@@ rpcrdma_ep_disconnect(struct rpcrdma_e
  	ib_drain_qp(ia->ri_id->qp);
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ rpcrdma_mr_recovery_worker(struct work_struct *work)
+ {
+ 	struct rpcrdma_buffer *buf = container_of(work, struct rpcrdma_buffer,
+ 						  rb_recovery_worker.work);
+ 	struct rpcrdma_mw *mw;
+ 
+ 	spin_lock(&buf->rb_recovery_lock);
+ 	while (!list_empty(&buf->rb_stale_mrs)) {
+ 		mw = list_first_entry(&buf->rb_stale_mrs,
+ 				      struct rpcrdma_mw, mw_list);
+ 		list_del_init(&mw->mw_list);
+ 		spin_unlock(&buf->rb_recovery_lock);
+ 
+ 		dprintk("RPC:       %s: recovering MR %p\n", __func__, mw);
+ 		mw->mw_xprt->rx_ia.ri_ops->ro_recover_mr(mw);
+ 
+ 		spin_lock(&buf->rb_recovery_lock);
+ 	}
+ 	spin_unlock(&buf->rb_recovery_lock);
+ }
+ 
+ void
+ rpcrdma_defer_mr_recovery(struct rpcrdma_mw *mw)
+ {
+ 	struct rpcrdma_xprt *r_xprt = mw->mw_xprt;
+ 	struct rpcrdma_buffer *buf = &r_xprt->rx_buf;
+ 
+ 	spin_lock(&buf->rb_recovery_lock);
+ 	list_add(&mw->mw_list, &buf->rb_stale_mrs);
+ 	spin_unlock(&buf->rb_recovery_lock);
+ 
+ 	schedule_delayed_work(&buf->rb_recovery_worker, 0);
+ }
+ 
+ static void
+ rpcrdma_create_mrs(struct rpcrdma_xprt *r_xprt)
+ {
+ 	struct rpcrdma_buffer *buf = &r_xprt->rx_buf;
+ 	struct rpcrdma_ia *ia = &r_xprt->rx_ia;
+ 	unsigned int count;
+ 	LIST_HEAD(free);
+ 	LIST_HEAD(all);
+ 
+ 	for (count = 0; count < 32; count++) {
+ 		struct rpcrdma_mw *mw;
+ 		int rc;
+ 
+ 		mw = kzalloc(sizeof(*mw), GFP_KERNEL);
+ 		if (!mw)
+ 			break;
+ 
+ 		rc = ia->ri_ops->ro_init_mr(ia, mw);
+ 		if (rc) {
+ 			kfree(mw);
+ 			break;
+ 		}
+ 
+ 		mw->mw_xprt = r_xprt;
+ 
+ 		list_add(&mw->mw_list, &free);
+ 		list_add(&mw->mw_all, &all);
+ 	}
+ 
+ 	spin_lock(&buf->rb_mwlock);
+ 	list_splice(&free, &buf->rb_mws);
+ 	list_splice(&all, &buf->rb_all);
+ 	r_xprt->rx_stats.mrs_allocated += count;
+ 	spin_unlock(&buf->rb_mwlock);
+ 
+ 	dprintk("RPC:       %s: created %u MRs\n", __func__, count);
+ }
+ 
+ static void
+ rpcrdma_mr_refresh_worker(struct work_struct *work)
+ {
+ 	struct rpcrdma_buffer *buf = container_of(work, struct rpcrdma_buffer,
+ 						  rb_refresh_worker.work);
+ 	struct rpcrdma_xprt *r_xprt = container_of(buf, struct rpcrdma_xprt,
+ 						   rx_buf);
+ 
+ 	rpcrdma_create_mrs(r_xprt);
+ }
+ 
++>>>>>>> 53d785230729 (xprtrdma: fix semicolon.cocci warnings)
  struct rpcrdma_req *
  rpcrdma_create_req(struct rpcrdma_xprt *r_xprt)
  {
* Unmerged path net/sunrpc/xprtrdma/verbs.c
