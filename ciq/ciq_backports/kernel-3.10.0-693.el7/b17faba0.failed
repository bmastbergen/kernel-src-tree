ntb_transport: Limit memory windows based on available, scratchpads

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Shyam Sundar S K <ssundark@amd.com>
commit b17faba03fc72091f4d040b879def004316952ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b17faba0.failed

When the underlying NTB H/W driver advertises more memory windows
than the number of scratchpads available to setup MW's, it is likely
that we may end up filling the remaining memory windows with garbage.
So to avoid that, lets limit the memory windows that transport driver
can setup based on the available scratchpads.

	Signed-off-by: Shyam Sundar S K <Shyam-sundar.S-k@amd.com>
	Acked-by: Allen Hubbe <Allen.Hubbe@dell.com>
	Signed-off-by: Jon Mason <jdmason@kudzu.us>
(cherry picked from commit b17faba03fc72091f4d040b879def004316952ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ntb/ntb_transport.c
diff --cc drivers/ntb/ntb_transport.c
index cc39efa77597,9b791cb33c19..000000000000
--- a/drivers/ntb/ntb_transport.c
+++ b/drivers/ntb/ntb_transport.c
@@@ -56,9 -58,24 +56,26 @@@
  #include <linux/pci.h>
  #include <linux/slab.h>
  #include <linux/types.h>
 -#include <linux/uaccess.h>
 -#include "linux/ntb.h"
 -#include "linux/ntb_transport.h"
 +#include "ntb_hw.h"
  
++<<<<<<< HEAD
 +#define NTB_TRANSPORT_VERSION	3
++=======
+ #define NTB_TRANSPORT_VERSION	4
+ #define NTB_TRANSPORT_VER	"4"
+ #define NTB_TRANSPORT_NAME	"ntb_transport"
+ #define NTB_TRANSPORT_DESC	"Software Queue-Pair Transport over NTB"
+ #define NTB_TRANSPORT_MIN_SPADS (MW0_SZ_HIGH + 2)
+ 
+ MODULE_DESCRIPTION(NTB_TRANSPORT_DESC);
+ MODULE_VERSION(NTB_TRANSPORT_VER);
+ MODULE_LICENSE("Dual BSD/GPL");
+ MODULE_AUTHOR("Intel Corporation");
+ 
+ static unsigned long max_mw_size;
+ module_param(max_mw_size, ulong, 0644);
+ MODULE_PARM_DESC(max_mw_size, "Limit size of large memory windows");
++>>>>>>> b17faba03fc7 (ntb_transport: Limit memory windows based on available, scratchpads)
  
  static unsigned int transport_mtu = 0x10000;
  module_param(transport_mtu, uint, 0644);
@@@ -195,16 -243,32 +212,13 @@@ enum 
  	NUM_MWS,
  	MW0_SZ_HIGH,
  	MW0_SZ_LOW,
- 	MW1_SZ_HIGH,
- 	MW1_SZ_LOW,
- 	MAX_SPAD,
  };
  
 -#define dev_client_dev(__dev) \
 -	container_of((__dev), struct ntb_transport_client_dev, dev)
 -
 -#define drv_client(__drv) \
 -	container_of((__drv), struct ntb_transport_client, driver)
 -
 -#define QP_TO_MW(nt, qp)	((qp) % nt->mw_count)
 +#define QP_TO_MW(ndev, qp)	((qp) % ntb_max_mw(ndev))
  #define NTB_QP_DEF_NUM_ENTRIES	100
  #define NTB_LINK_DOWN_TIMEOUT	10
 -#define DMA_RETRIES		20
 -#define DMA_OUT_RESOURCE_TO	msecs_to_jiffies(50)
 -
 -static void ntb_transport_rxc_db(unsigned long data);
 -static const struct ntb_ctx_ops ntb_transport_ops;
 -static struct ntb_client ntb_transport_client;
 -static int ntb_async_tx_submit(struct ntb_transport_qp *qp,
 -			       struct ntb_queue_entry *entry);
 -static void ntb_memcpy_tx(struct ntb_queue_entry *entry, void __iomem *offset);
 -static int ntb_async_rx_submit(struct ntb_queue_entry *entry, void *offset);
 -static void ntb_memcpy_rx(struct ntb_queue_entry *entry, void *offset);
  
 -
 -static int ntb_transport_bus_match(struct device *dev,
 -				   struct device_driver *drv)
 +static int ntb_match_bus(struct device *dev, struct device_driver *drv)
  {
  	return !strncmp(dev_name(dev), drv->name, strlen(drv->name));
  }
@@@ -635,26 -805,33 +649,38 @@@ static void ntb_qp_link_down(struct ntb
  	schedule_work(&qp->link_cleanup);
  }
  
 -static void ntb_transport_link_cleanup(struct ntb_transport_ctx *nt)
 +static void ntb_transport_link_cleanup(struct ntb_transport *nt)
  {
++<<<<<<< HEAD
 +	int i;
++=======
+ 	struct ntb_transport_qp *qp;
+ 	u64 qp_bitmap_alloc;
+ 	unsigned int i, count;
 -
 -	qp_bitmap_alloc = nt->qp_bitmap & ~nt->qp_bitmap_free;
++>>>>>>> b17faba03fc7 (ntb_transport: Limit memory windows based on available, scratchpads)
  
  	/* Pass along the info to any clients */
 -	for (i = 0; i < nt->qp_count; i++)
 -		if (qp_bitmap_alloc & BIT_ULL(i)) {
 -			qp = &nt->qp_vec[i];
 -			ntb_qp_link_cleanup(qp);
 -			cancel_work_sync(&qp->link_cleanup);
 -			cancel_delayed_work_sync(&qp->link_work);
 -		}
 +	for (i = 0; i < nt->max_qps; i++)
 +		if (!test_bit(i, &nt->qp_bitmap))
 +			ntb_qp_link_cleanup(&nt->qps[i]);
  
 -	if (!nt->link_is_up)
 +	if (nt->transport_link == NTB_LINK_DOWN)
  		cancel_delayed_work_sync(&nt->link_work);
 +	else
 +		nt->transport_link = NTB_LINK_DOWN;
  
  	/* The scratchpad registers keep the values if the remote side
  	 * goes down, blast them now to give them a sane value the next
  	 * time they are accessed
  	 */
++<<<<<<< HEAD
 +	for (i = 0; i < MAX_SPAD; i++)
 +		ntb_write_local_spad(nt->ndev, i, 0);
++=======
+ 	count = ntb_spad_count(nt->ndev);
+ 	for (i = 0; i < count; i++)
+ 		ntb_spad_write(nt->ndev, i, 0);
++>>>>>>> b17faba03fc7 (ntb_transport: Limit memory windows based on available, scratchpads)
  }
  
  static void ntb_transport_link_cleanup_work(struct work_struct *work)
@@@ -921,18 -1056,51 +947,61 @@@ static int ntb_transport_init_queue(str
  	return 0;
  }
  
 -static int ntb_transport_probe(struct ntb_client *self, struct ntb_dev *ndev)
 +int ntb_transport_init(struct pci_dev *pdev)
  {
++<<<<<<< HEAD
 +	struct ntb_transport *nt;
 +	int rc, i;
 +
 +	nt = kzalloc(sizeof(struct ntb_transport), GFP_KERNEL);
 +	if (!nt)
 +		return -ENOMEM;
 +
 +	nt->ndev = ntb_register_transport(pdev, nt);
 +	if (!nt->ndev) {
 +		rc = -EIO;
++=======
+ 	struct ntb_transport_ctx *nt;
+ 	struct ntb_transport_mw *mw;
+ 	unsigned int mw_count, qp_count, spad_count, max_mw_count_for_spads;
+ 	u64 qp_bitmap;
+ 	int node;
+ 	int rc, i;
+ 
+ 	mw_count = ntb_mw_count(ndev);
+ 
+ 	if (ntb_db_is_unsafe(ndev))
+ 		dev_dbg(&ndev->dev,
+ 			"doorbell is unsafe, proceed anyway...\n");
+ 	if (ntb_spad_is_unsafe(ndev))
+ 		dev_dbg(&ndev->dev,
+ 			"scratchpad is unsafe, proceed anyway...\n");
+ 
+ 	node = dev_to_node(&ndev->dev);
+ 
+ 	nt = kzalloc_node(sizeof(*nt), GFP_KERNEL, node);
+ 	if (!nt)
+ 		return -ENOMEM;
+ 
+ 	nt->ndev = ndev;
+ 	spad_count = ntb_spad_count(ndev);
+ 
+ 	/* Limit the MW's based on the availability of scratchpads */
+ 
+ 	if (spad_count < NTB_TRANSPORT_MIN_SPADS) {
+ 		nt->mw_count = 0;
+ 		rc = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	max_mw_count_for_spads = (spad_count - MW0_SZ_HIGH) / 2;
+ 	nt->mw_count = min(mw_count, max_mw_count_for_spads);
+ 
+ 	nt->mw_vec = kzalloc_node(mw_count * sizeof(*nt->mw_vec),
+ 				  GFP_KERNEL, node);
+ 	if (!nt->mw_vec) {
+ 		rc = -ENOMEM;
++>>>>>>> b17faba03fc7 (ntb_transport: Limit memory windows based on available, scratchpads)
  		goto err;
  	}
  
* Unmerged path drivers/ntb/ntb_transport.c
