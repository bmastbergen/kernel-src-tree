dmaengine: dw: pass platform data via struct dw_dma_chip

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [sound] alsa: dmaengine: dw: pass platform data via struct dw_dma_chip (Jaroslav Kysela) [1399503]
Rebuild_FUZZ: 94.92%
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 3a14c66d43d018baed96ceb74f9ab548878c09b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3a14c66d.failed

We pass struct dw_dma_chip to dw_dma_probe() anyway, thus we may use it to
pass a platform data as well.

While here, constify the source of the platform data.

	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Vinod Koul <vinod.koul@intel.com>
(cherry picked from commit 3a14c66d43d018baed96ceb74f9ab548878c09b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ata/sata_dwc_460ex.c
#	drivers/dma/dw/pci.c
#	drivers/dma/dw/platform.c
#	drivers/dma/dw_dmac.c
#	include/linux/dma/dw.h
diff --cc drivers/ata/sata_dwc_460ex.c
index 73510d0d1406,2cb6f7e04b5c..000000000000
--- a/drivers/ata/sata_dwc_460ex.c
+++ b/drivers/ata/sata_dwc_460ex.c
@@@ -1739,10 -1243,14 +1739,16 @@@ static int sata_dwc_probe(struct platfo
  	}
  
  	/* Save dev for later use in dev_xxx() routines */
 -	hsdev->dev = &ofdev->dev;
 -
 -	hsdev->dma->dev = &ofdev->dev;
 +	host_pvt.dwc_dev = &ofdev->dev;
  
  	/* Initialize AHB DMAC */
++<<<<<<< HEAD
 +	dma_dwc_init(hsdev, irq);
++=======
+ 	err = dw_dma_probe(hsdev->dma);
+ 	if (err)
+ 		goto error_dma_iomap;
++>>>>>>> 3a14c66d43d0 (dmaengine: dw: pass platform data via struct dw_dma_chip)
  
  	/* Enable SATA Interrupts */
  	sata_dwc_enable_interrupts(hsdev);
diff --cc drivers/dma/dw_dmac.c
index 2e5deaa82b60,edf053f73a49..000000000000
--- a/drivers/dma/dw_dmac.c
+++ b/drivers/dma/dw_dmac.c
@@@ -1580,161 -1439,70 +1580,191 @@@ EXPORT_SYMBOL(dw_dma_cyclic_free)
  
  /*----------------------------------------------------------------------*/
  
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +static void dw_dma_off(struct dw_dma *dw)
 +{
 +	int i;
 +
 +	dma_writel(dw, CFG, 0);
 +
 +	channel_clear_bit(dw, MASK.XFER, dw->all_chan_mask);
 +	channel_clear_bit(dw, MASK.SRC_TRAN, dw->all_chan_mask);
 +	channel_clear_bit(dw, MASK.DST_TRAN, dw->all_chan_mask);
 +	channel_clear_bit(dw, MASK.ERROR, dw->all_chan_mask);
 +
 +	while (dma_readl(dw, CFG) & DW_CFG_DMA_EN)
 +		cpu_relax();
 +
 +	for (i = 0; i < dw->dma.chancnt; i++)
 +		dw->chan[i].initialized = false;
 +}
 +
 +#ifdef CONFIG_OF
 +static struct dw_dma_platform_data *
 +dw_dma_parse_dt(struct platform_device *pdev)
 +{
 +	struct device_node *np = pdev->dev.of_node;
 +	struct dw_dma_platform_data *pdata;
 +	u32 tmp, arr[4];
 +
 +	if (!np) {
 +		dev_err(&pdev->dev, "Missing DT data\n");
 +		return NULL;
 +	}
 +
 +	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 +	if (!pdata)
 +		return NULL;
 +
 +	if (of_property_read_u32(np, "dma-channels", &pdata->nr_channels))
 +		return NULL;
 +
 +	if (of_property_read_bool(np, "is_private"))
 +		pdata->is_private = true;
 +
 +	if (!of_property_read_u32(np, "chan_allocation_order", &tmp))
 +		pdata->chan_allocation_order = (unsigned char)tmp;
 +
 +	if (!of_property_read_u32(np, "chan_priority", &tmp))
 +		pdata->chan_priority = tmp;
 +
 +	if (!of_property_read_u32(np, "block_size", &tmp))
 +		pdata->block_size = tmp;
 +
 +	if (!of_property_read_u32(np, "dma-masters", &tmp)) {
 +		if (tmp > 4)
 +			return NULL;
 +
 +		pdata->nr_masters = tmp;
 +	}
 +
 +	if (!of_property_read_u32_array(np, "data_width", arr,
 +				pdata->nr_masters))
 +		for (tmp = 0; tmp < pdata->nr_masters; tmp++)
 +			pdata->data_width[tmp] = arr[tmp];
 +
 +	return pdata;
 +}
 +#else
 +static inline struct dw_dma_platform_data *
 +dw_dma_parse_dt(struct platform_device *pdev)
 +{
 +	return NULL;
 +}
 +#endif
 +
 +static int dw_probe(struct platform_device *pdev)
 +{
 +	struct dw_dma_platform_data *pdata;
 +	struct resource		*io;
++=======
+ int dw_dma_probe(struct dw_dma_chip *chip)
+ {
+ 	struct dw_dma_platform_data *pdata;
++>>>>>>> 3a14c66d43d0 (dmaengine: dw: pass platform data via struct dw_dma_chip):drivers/dma/dw/core.c
  	struct dw_dma		*dw;
 -	bool			autocfg = false;
 +	size_t			size;
 +	void __iomem		*regs;
 +	bool			autocfg;
  	unsigned int		dw_params;
 -	unsigned int		i;
 +	unsigned int		nr_channels;
 +	unsigned int		max_blk_size = 0;
 +	int			irq;
  	int			err;
 +	int			i;
  
 -	dw = devm_kzalloc(chip->dev, sizeof(*dw), GFP_KERNEL);
 -	if (!dw)
 -		return -ENOMEM;
 +	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 +	if (!io)
 +		return -EINVAL;
  
 -	dw->pdata = devm_kzalloc(chip->dev, sizeof(*dw->pdata), GFP_KERNEL);
 -	if (!dw->pdata)
 -		return -ENOMEM;
 +	irq = platform_get_irq(pdev, 0);
 +	if (irq < 0)
 +		return irq;
  
 -	dw->regs = chip->regs;
 -	chip->dw = dw;
 +	regs = devm_ioremap_resource(&pdev->dev, io);
 +	if (IS_ERR(regs))
 +		return PTR_ERR(regs);
  
 -	pm_runtime_get_sync(chip->dev);
 +	/* Apply default dma_mask if needed */
 +	if (!pdev->dev.dma_mask) {
 +		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
 +		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 +	}
  
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +	dw_params = dma_read_byaddr(regs, DW_PARAMS);
 +	autocfg = dw_params >> DW_PARAMS_EN & 0x1;
++=======
+ 	if (!chip->pdata) {
+ 		dw_params = dma_readl(dw, DW_PARAMS);
+ 		dev_dbg(chip->dev, "DW_PARAMS: 0x%08x\n", dw_params);
++>>>>>>> 3a14c66d43d0 (dmaengine: dw: pass platform data via struct dw_dma_chip):drivers/dma/dw/core.c
  
 -		autocfg = dw_params >> DW_PARAMS_EN & 1;
 -		if (!autocfg) {
 -			err = -EINVAL;
 -			goto err_pdata;
 -		}
 +	dev_dbg(&pdev->dev, "DW_PARAMS: 0x%08x\n", dw_params);
  
 -		/* Reassign the platform data pointer */
 -		pdata = dw->pdata;
 +	pdata = dev_get_platdata(&pdev->dev);
 +	if (!pdata)
 +		pdata = dw_dma_parse_dt(pdev);
  
 -		/* Get hardware configuration parameters */
 -		pdata->nr_channels = (dw_params >> DW_PARAMS_NR_CHAN & 7) + 1;
 -		pdata->nr_masters = (dw_params >> DW_PARAMS_NR_MASTER & 3) + 1;
 -		for (i = 0; i < pdata->nr_masters; i++) {
 -			pdata->data_width[i] =
 -				4 << (dw_params >> DW_PARAMS_DATA_WIDTH(i) & 3);
 -		}
 -		pdata->block_size = dma_readl(dw, MAX_BLK_SIZE);
 +	if (!pdata && autocfg) {
 +		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 +		if (!pdata)
 +			return -ENOMEM;
  
  		/* Fill platform data with the default values */
  		pdata->is_private = true;
 -		pdata->is_memcpy = true;
  		pdata->chan_allocation_order = CHAN_ALLOCATION_ASCENDING;
  		pdata->chan_priority = CHAN_PRIORITY_ASCENDING;
++<<<<<<< HEAD:drivers/dma/dw_dmac.c
 +	} else if (!pdata || pdata->nr_channels > DW_DMA_MAX_NR_CHANNELS)
 +		return -EINVAL;
 +
 +	if (autocfg)
 +		nr_channels = (dw_params >> DW_PARAMS_NR_CHAN & 0x7) + 1;
 +	else
 +		nr_channels = pdata->nr_channels;
 +
 +	size = sizeof(struct dw_dma) + nr_channels * sizeof(struct dw_dma_chan);
 +	dw = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
 +	if (!dw)
 +		return -ENOMEM;
 +
 +	dw->clk = devm_clk_get(&pdev->dev, "hclk");
 +	if (IS_ERR(dw->clk))
 +		return PTR_ERR(dw->clk);
 +	clk_prepare_enable(dw->clk);
 +
 +	dw->regs = regs;
 +
 +	/* Get hardware configuration parameters */
 +	if (autocfg) {
 +		max_blk_size = dma_readl(dw, MAX_BLK_SIZE);
 +
 +		dw->nr_masters = (dw_params >> DW_PARAMS_NR_MASTER & 3) + 1;
 +		for (i = 0; i < dw->nr_masters; i++) {
 +			dw->data_width[i] =
 +				(dw_params >> DW_PARAMS_DATA_WIDTH(i) & 3) + 2;
 +		}
 +	} else {
 +		dw->nr_masters = pdata->nr_masters;
 +		memcpy(dw->data_width, pdata->data_width, 4);
++=======
+ 	} else if (chip->pdata->nr_channels > DW_DMA_MAX_NR_CHANNELS) {
+ 		err = -EINVAL;
+ 		goto err_pdata;
+ 	} else {
+ 		memcpy(dw->pdata, chip->pdata, sizeof(*dw->pdata));
+ 
+ 		/* Reassign the platform data pointer */
+ 		pdata = dw->pdata;
+ 	}
+ 
+ 	dw->chan = devm_kcalloc(chip->dev, pdata->nr_channels, sizeof(*dw->chan),
+ 				GFP_KERNEL);
+ 	if (!dw->chan) {
+ 		err = -ENOMEM;
+ 		goto err_pdata;
++>>>>>>> 3a14c66d43d0 (dmaengine: dw: pass platform data via struct dw_dma_chip):drivers/dma/dw/core.c
  	}
  
  	/* Calculate all channel mask before DMA setup */
* Unmerged path drivers/dma/dw/pci.c
* Unmerged path drivers/dma/dw/platform.c
* Unmerged path include/linux/dma/dw.h
* Unmerged path drivers/ata/sata_dwc_460ex.c
* Unmerged path drivers/dma/dw/pci.c
* Unmerged path drivers/dma/dw/platform.c
* Unmerged path drivers/dma/dw_dmac.c
* Unmerged path include/linux/dma/dw.h
diff --git a/sound/soc/intel/common/sst-firmware.c b/sound/soc/intel/common/sst-firmware.c
index ef4881e7753a..25993527370b 100644
--- a/sound/soc/intel/common/sst-firmware.c
+++ b/sound/soc/intel/common/sst-firmware.c
@@ -203,7 +203,7 @@ static struct dw_dma_chip *dw_probe(struct device *dev, struct resource *mem,
 
 	chip->dev = dev;
 
-	err = dw_dma_probe(chip, NULL);
+	err = dw_dma_probe(chip);
 	if (err)
 		return ERR_PTR(err);
 
