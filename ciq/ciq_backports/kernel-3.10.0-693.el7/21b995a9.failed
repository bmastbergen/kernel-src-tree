ip6_tunnel: must reload ipv6h in ip6ip6_tnl_xmit()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 21b995a9cb093fff33ec91d7cb3822b882a90a1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/21b995a9.failed

Since ip6_tnl_parse_tlv_enc_lim() can call pskb_may_pull(),
we must reload any pointer that was related to skb->head
(or skb->data), or risk use after free.

Fixes: c12b395a4664 ("gre: Support GRE over IPv6")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Dmitry Kozlov <xeb@mail.ru>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 21b995a9cb093fff33ec91d7cb3822b882a90a1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_tunnel.c
diff --cc net/ipv6/ip6_tunnel.c
index 2a4b43ddc51c,02923f956ac8..000000000000
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@@ -1138,31 -1286,59 +1138,55 @@@ ip6ip6_tnl_xmit(struct sk_buff *skb, st
  	    ip6_tnl_addr_conflict(t, ipv6h))
  		return -1;
  
 -	dsfield = ipv6_get_dsfield(ipv6h);
 -
 -	if (t->parms.collect_md) {
 -		struct ip_tunnel_info *tun_info;
 -		const struct ip_tunnel_key *key;
 -
 -		tun_info = skb_tunnel_info(skb);
 -		if (unlikely(!tun_info || !(tun_info->mode & IP_TUNNEL_INFO_TX) ||
 -			     ip_tunnel_info_af(tun_info) != AF_INET6))
 +	offset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));
 +	if (offset > 0) {
 +		struct ipv6_tlv_tnl_enc_lim *tel;
 +		tel = (struct ipv6_tlv_tnl_enc_lim *)&skb_network_header(skb)[offset];
 +		if (tel->encap_limit == 0) {
 +			icmpv6_send(skb, ICMPV6_PARAMPROB,
 +				    ICMPV6_HDR_FIELD, offset + 2);
  			return -1;
++<<<<<<< HEAD
++=======
+ 		key = &tun_info->key;
+ 		memset(&fl6, 0, sizeof(fl6));
+ 		fl6.flowi6_proto = IPPROTO_IPV6;
+ 		fl6.daddr = key->u.ipv6.dst;
+ 		fl6.flowlabel = key->label;
+ 	} else {
+ 		offset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));
+ 		/* ip6_tnl_parse_tlv_enc_lim() might have reallocated skb->head */
+ 		ipv6h = ipv6_hdr(skb);
+ 		if (offset > 0) {
+ 			struct ipv6_tlv_tnl_enc_lim *tel;
+ 
+ 			tel = (void *)&skb_network_header(skb)[offset];
+ 			if (tel->encap_limit == 0) {
+ 				icmpv6_send(skb, ICMPV6_PARAMPROB,
+ 					    ICMPV6_HDR_FIELD, offset + 2);
+ 				return -1;
+ 			}
+ 			encap_limit = tel->encap_limit - 1;
+ 		} else if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT)) {
+ 			encap_limit = t->parms.encap_limit;
++>>>>>>> 21b995a9cb09 (ip6_tunnel: must reload ipv6h in ip6ip6_tnl_xmit())
  		}
 +		encap_limit = tel->encap_limit - 1;
 +	} else if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))
 +		encap_limit = t->parms.encap_limit;
  
 -		memcpy(&fl6, &t->fl.u.ip6, sizeof(fl6));
 -		fl6.flowi6_proto = IPPROTO_IPV6;
 -
 -		if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
 -			fl6.flowlabel |= (*(__be32 *)ipv6h & IPV6_TCLASS_MASK);
 -		if (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)
 -			fl6.flowlabel |= ip6_flowlabel(ipv6h);
 -		if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
 -			fl6.flowi6_mark = skb->mark;
 -	}
 -
 -	fl6.flowi6_uid = sock_net_uid(dev_net(dev), NULL);
 -
 -	if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))
 -		return -1;
 -
 -	skb_set_inner_ipproto(skb, IPPROTO_IPV6);
 +	memcpy(&fl6, &t->fl.u.ip6, sizeof (fl6));
 +	fl6.flowi6_proto = IPPROTO_IPV6;
  
 -	err = ip6_tnl_xmit(skb, dev, dsfield, &fl6, encap_limit, &mtu,
 -			   IPPROTO_IPV6);
 +	dsfield = ipv6_get_dsfield(ipv6h);
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)
 +		fl6.flowlabel |= (*(__be32 *) ipv6h & IPV6_TCLASS_MASK);
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)
 +		fl6.flowlabel |= ip6_flowlabel(ipv6h);
 +	if (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)
 +		fl6.flowi6_mark = skb->mark;
 +
 +	err = ip6_tnl_xmit2(skb, dev, dsfield, &fl6, encap_limit, &mtu);
  	if (err != 0) {
  		if (err == -EMSGSIZE)
  			icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);
diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c
index 4cd4c6bd0d06..2a847c199d51 100644
--- a/net/ipv6/ip6_gre.c
+++ b/net/ipv6/ip6_gre.c
@@ -735,6 +735,9 @@ static inline int ip6gre_xmit_ipv6(struct sk_buff *skb, struct net_device *dev)
 		return -1;
 
 	offset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));
+	/* ip6_tnl_parse_tlv_enc_lim() might have reallocated skb->head */
+	ipv6h = ipv6_hdr(skb);
+
 	if (offset > 0) {
 		struct ipv6_tlv_tnl_enc_lim *tel;
 		tel = (struct ipv6_tlv_tnl_enc_lim *)&skb_network_header(skb)[offset];
* Unmerged path net/ipv6/ip6_tunnel.c
