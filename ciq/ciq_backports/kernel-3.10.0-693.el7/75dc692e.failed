r8152: fix rx issue for runtime suspend

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author hayeswang <hayeswang@realtek.com>
commit 75dc692eda114cb234a46cb11893a9c3ea520934
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/75dc692e.failed

Pause the rx and make sure the rx fifo is empty when the autosuspend
occurs.

If the rx data comes when the driver is canceling the rx urb, the host
controller would stop getting the data from the device and continue
it after next rx urb is submitted. That is, one continuing data is
split into two different urb buffers. That let the driver take the
data as a rx descriptor, and unexpected behavior happens.

	Signed-off-by: Hayes Wang <hayeswang@realtek.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 75dc692eda114cb234a46cb11893a9c3ea520934)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/usb/r8152.c
diff --cc drivers/net/usb/r8152.c
index e290630a4f38,be418563cb18..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -3553,19 -3581,58 +3553,58 @@@ static int rtl8152_suspend(struct usb_i
  	struct net_device *netdev = tp->netdev;
  	int ret = 0;
  
++<<<<<<< HEAD
 +	mutex_lock(&tp->control);
 +
 +	if (PMSG_IS_AUTO(message)) {
 +		if (netif_running(netdev) && delay_autosuspend(tp)) {
++=======
+ 	if (netif_running(netdev) && test_bit(WORK_ENABLE, &tp->flags)) {
+ 		u32 rcr = 0;
+ 
+ 		if (delay_autosuspend(tp)) {
++>>>>>>> 75dc692eda11 (r8152: fix rx issue for runtime suspend)
  			ret = -EBUSY;
  			goto out1;
  		}
  
++<<<<<<< HEAD
 +		set_bit(SELECTIVE_SUSPEND, &tp->flags);
 +	} else {
 +		netif_device_detach(netdev);
++=======
+ 		if (netif_carrier_ok(netdev)) {
+ 			u32 ocp_data;
+ 
+ 			rcr = ocp_read_dword(tp, MCU_TYPE_PLA, PLA_RCR);
+ 			ocp_data = rcr & ~RCR_ACPT_ALL;
+ 			ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, ocp_data);
+ 			rxdy_gated_en(tp, true);
+ 			ocp_data = ocp_read_byte(tp, MCU_TYPE_PLA,
+ 						 PLA_OOB_CTRL);
+ 			if (!(ocp_data & RXFIFO_EMPTY)) {
+ 				rxdy_gated_en(tp, false);
+ 				ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, rcr);
+ 				ret = -EBUSY;
+ 				goto out1;
+ 			}
+ 		}
+ 
+ 		clear_bit(WORK_ENABLE, &tp->flags);
+ 		usb_kill_urb(tp->intr_urb);
+ 
+ 		tp->rtl_ops.autosuspend_en(tp, true);
+ 
+ 		if (netif_carrier_ok(netdev)) {
+ 			napi_disable(&tp->napi);
+ 			rtl_stop_rx(tp);
+ 			rxdy_gated_en(tp, false);
+ 			ocp_write_dword(tp, MCU_TYPE_PLA, PLA_RCR, rcr);
+ 			napi_enable(&tp->napi);
+ 		}
++>>>>>>> 75dc692eda11 (r8152: fix rx issue for runtime suspend)
  	}
  
 -	set_bit(SELECTIVE_SUSPEND, &tp->flags);
 -
 -out1:
 -	return ret;
 -}
 -
 -static int rtl8152_system_suspend(struct r8152 *tp)
 -{
 -	struct net_device *netdev = tp->netdev;
 -	int ret = 0;
 -
 -	netif_device_detach(netdev);
 -
  	if (netif_running(netdev) && test_bit(WORK_ENABLE, &tp->flags)) {
  		clear_bit(WORK_ENABLE, &tp->flags);
  		usb_kill_urb(tp->intr_urb);
* Unmerged path drivers/net/usb/r8152.c
