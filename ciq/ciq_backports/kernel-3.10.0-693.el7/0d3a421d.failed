net: sctp: implement rfc6458, 5.3.5. SCTP_RCVINFO cmsg support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sctp: implement rfc6458, 5.3.5. SCTP_RCVINFO cmsg support (Xin Long) [1339791]
Rebuild_FUZZ: 95.80%
commit-author Geir Ola Vaagland <geirola@gmail.com>
commit 0d3a421d284812d07970b4ccee74d4fa38737e4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0d3a421d.failed

This patch implements section 5.3.5. of RFC6458, that is, support
for 'SCTP Receive Information Structure' (SCTP_RCVINFO) which is
placed into ancillary data cmsghdr structure for each recvmsg()
call.

This option can be enabled/disabled via setsockopt(2) on SOL_SCTP
level by setting an int value with 1/0 for SCTP_RECVRCVINFO in user
space applications as per RFC6458, section 8.1.29.

The sctp_rcvinfo structure is defined as per RFC as below ...

  struct sctp_rcvinfo {
    uint16_t rcv_sid;
    uint16_t rcv_ssn;
    uint16_t rcv_flags;
    <-- 2 bytes hole  -->
    uint32_t rcv_ppid;
    uint32_t rcv_tsn;
    uint32_t rcv_cumtsn;
    uint32_t rcv_context;
    sctp_assoc_t rcv_assoc_id;
  };

... and provided under cmsg_level IPPROTO_SCTP, cmsg_type
SCTP_RCVINFO, while cmsg_data[] contains struct sctp_rcvinfo.
An sctp_rcvinfo item always corresponds to the data in msg_iov.

Joint work with Daniel Borkmann.

	Signed-off-by: Geir Ola Vaagland <geirola@gmail.com>
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0d3a421d284812d07970b4ccee74d4fa38737e4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sctp/structs.h
#	include/uapi/linux/sctp.h
#	net/sctp/socket.c
diff --cc include/net/sctp/structs.h
index 4f9d7015fcef,11d5df015370..000000000000
--- a/include/net/sctp/structs.h
+++ b/include/net/sctp/structs.h
@@@ -214,17 -207,17 +214,23 @@@ struct sctp_sock 
  	struct sctp_paddrparams paddrparam;
  	struct sctp_event_subscribe subscribe;
  	struct sctp_assocparams assocparams;
+ 
  	int user_frag;
+ 
  	__u32 autoclose;
 -	__u8 nodelay;
 -	__u8 disable_fragments;
 -	__u8 v4mapped;
 -	__u8 frag_interleave;
  	__u32 adaptation_ind;
  	__u32 pd_point;
++<<<<<<< HEAD
 +	__u16	nodelay:1,
 +		disable_fragments:1,
 +		v4mapped:1,
 +		frag_interleave:1,
 +		_reserved1:1,
 +		_reserved2:1,
 +		data_ready_signalled:1;
++=======
+ 	__u8 recvrcvinfo;
++>>>>>>> 0d3a421d2848 (net: sctp: implement rfc6458, 5.3.5. SCTP_RCVINFO cmsg support)
  
  	atomic_t pd_mode;
  	/* Receive to here while partial delivery is in effect. */
diff --cc include/uapi/linux/sctp.h
index f99df6a81072,29b81bbfc53d..000000000000
--- a/include/uapi/linux/sctp.h
+++ b/include/uapi/linux/sctp.h
@@@ -110,34 -110,8 +111,33 @@@ typedef __s32 sctp_assoc_t
  #define SCTP_SOCKOPT_CONNECTX	110		/* CONNECTX requests. */
  #define SCTP_SOCKOPT_CONNECTX3	111	/* CONNECTX requests (updated) */
  #define SCTP_GET_ASSOC_STATS	112	/* Read only */
 +#define SCTP_PR_SUPPORTED	113
 +#define SCTP_DEFAULT_PRINFO	114
 +#define SCTP_PR_ASSOC_STATUS	115
 +
 +/* PR-SCTP policies */
 +#define SCTP_PR_SCTP_NONE	0x0000
 +#define SCTP_PR_SCTP_TTL	0x0010
 +#define SCTP_PR_SCTP_RTX	0x0020
 +#define SCTP_PR_SCTP_PRIO	0x0030
 +#define SCTP_PR_SCTP_MAX	SCTP_PR_SCTP_PRIO
 +#define SCTP_PR_SCTP_MASK	0x0030
 +
 +#define __SCTP_PR_INDEX(x)	((x >> 4) - 1)
 +#define SCTP_PR_INDEX(x)	__SCTP_PR_INDEX(SCTP_PR_SCTP_ ## x)
 +
 +#define SCTP_PR_POLICY(x)	((x) & SCTP_PR_SCTP_MASK)
 +#define SCTP_PR_SET_POLICY(flags, x)	\
 +	do {				\
 +		flags &= ~SCTP_PR_SCTP_MASK;	\
 +		flags |= x;		\
 +	} while (0)
 +
 +#define SCTP_PR_TTL_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_TTL)
 +#define SCTP_PR_RTX_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_RTX)
 +#define SCTP_PR_PRIO_ENABLED(x)	(SCTP_PR_POLICY(x) == SCTP_PR_SCTP_PRIO)
  
- /*
-  * 5.2.1 SCTP Initiation Structure (SCTP_INIT)
+ /* 5.3.1 SCTP Initiation Structure (SCTP_INIT)
   *
   *   This cmsghdr structure provides information for initializing new
   *   SCTP associations with sendmsg().  The SCTP_INITMSG socket option
@@@ -180,6 -151,42 +177,45 @@@ struct sctp_sndrcvinfo 
  	sctp_assoc_t sinfo_assoc_id;
  };
  
++<<<<<<< HEAD
++=======
+ /* 5.3.4 SCTP Send Information Structure (SCTP_SNDINFO)
+  *
+  *   This cmsghdr structure specifies SCTP options for sendmsg().
+  *
+  *   cmsg_level    cmsg_type      cmsg_data[]
+  *   ------------  ------------   -------------------
+  *   IPPROTO_SCTP  SCTP_SNDINFO   struct sctp_sndinfo
+  */
+ struct sctp_sndinfo {
+ 	__u16 snd_sid;
+ 	__u16 snd_flags;
+ 	__u32 snd_ppid;
+ 	__u32 snd_context;
+ 	sctp_assoc_t snd_assoc_id;
+ };
+ 
+ /* 5.3.5 SCTP Receive Information Structure (SCTP_RCVINFO)
+  *
+  *   This cmsghdr structure describes SCTP receive information
+  *   about a received message through recvmsg().
+  *
+  *   cmsg_level    cmsg_type      cmsg_data[]
+  *   ------------  ------------   -------------------
+  *   IPPROTO_SCTP  SCTP_RCVINFO   struct sctp_rcvinfo
+  */
+ struct sctp_rcvinfo {
+ 	__u16 rcv_sid;
+ 	__u16 rcv_ssn;
+ 	__u16 rcv_flags;
+ 	__u32 rcv_ppid;
+ 	__u32 rcv_tsn;
+ 	__u32 rcv_cumtsn;
+ 	__u32 rcv_context;
+ 	sctp_assoc_t rcv_assoc_id;
+ };
+ 
++>>>>>>> 0d3a421d2848 (net: sctp: implement rfc6458, 5.3.5. SCTP_RCVINFO cmsg support)
  /*
   *  sinfo_flags: 16 bits (unsigned integer)
   *
@@@ -203,10 -209,14 +238,17 @@@ typedef union 
  
  /* These are cmsg_types.  */
  typedef enum sctp_cmsg_type {
 -	SCTP_INIT,		/* 5.2.1 SCTP Initiation Structure */
 +	SCTP_INIT,              /* 5.2.1 SCTP Initiation Structure */
  #define SCTP_INIT	SCTP_INIT
 -	SCTP_SNDRCV,		/* 5.2.2 SCTP Header Information Structure */
 +	SCTP_SNDRCV,            /* 5.2.2 SCTP Header Information Structure */
  #define SCTP_SNDRCV	SCTP_SNDRCV
++<<<<<<< HEAD
++=======
+ 	SCTP_SNDINFO,		/* 5.3.4 SCTP Send Information Structure */
+ #define SCTP_SNDINFO	SCTP_SNDINFO
+ 	SCTP_RCVINFO,		/* 5.3.5 SCTP Receive Information Structure */
+ #define SCTP_RCVINFO	SCTP_RCVINFO
++>>>>>>> 0d3a421d2848 (net: sctp: implement rfc6458, 5.3.5. SCTP_RCVINFO cmsg support)
  } sctp_cmsg_t;
  
  /*
diff --cc net/sctp/socket.c
index 3865a48c7d38,9c193887c5cd..000000000000
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@@ -2110,9 -2109,12 +2110,12 @@@ static int sctp_recvmsg(struct kiocb *i
  		msg->msg_flags |= MSG_NOTIFICATION;
  		sp->pf->event_msgname(event, msg->msg_name, addr_len);
  	} else {
 -		sp->pf->skb_msgname(skb, msg->msg_name, addr_len);
 +		sp->pf->skb_msgname(head_skb, msg->msg_name, addr_len);
  	}
  
+ 	/* Check if we allow SCTP_RCVINFO. */
+ 	if (sp->recvrcvinfo)
+ 		sctp_ulpevent_read_rcvinfo(event, msg);
  	/* Check if we allow SCTP_SNDRCVINFO. */
  	if (sp->subscribe.sctp_data_io_event)
  		sctp_ulpevent_read_sndrcvinfo(event, msg);
@@@ -3585,78 -3595,20 +3588,95 @@@ static int sctp_setsockopt_paddr_thresh
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int sctp_setsockopt_pr_supported(struct sock *sk,
 +					char __user *optval,
 +					unsigned int optlen)
 +{
 +	struct sctp_assoc_value params;
 +	struct sctp_association *asoc;
 +	int retval = -EINVAL;
 +
 +	if (optlen != sizeof(params))
 +		goto out;
 +
 +	if (copy_from_user(&params, optval, optlen)) {
 +		retval = -EFAULT;
 +		goto out;
 +	}
 +
 +	asoc = sctp_id2assoc(sk, params.assoc_id);
 +	if (asoc) {
 +		asoc->prsctp_enable = !!params.assoc_value;
 +	} else if (!params.assoc_id) {
 +		struct sctp_sock *sp = sctp_sk(sk);
 +
 +		sp->ep->prsctp_enable = !!params.assoc_value;
 +	} else {
 +		goto out;
 +	}
 +
 +	retval = 0;
 +
 +out:
 +	return retval;
 +}
 +
 +static int sctp_setsockopt_default_prinfo(struct sock *sk,
 +					  char __user *optval,
 +					  unsigned int optlen)
 +{
 +	struct sctp_default_prinfo info;
 +	struct sctp_association *asoc;
 +	int retval = -EINVAL;
 +
 +	if (optlen != sizeof(info))
 +		goto out;
 +
 +	if (copy_from_user(&info, optval, sizeof(info))) {
 +		retval = -EFAULT;
 +		goto out;
 +	}
 +
 +	if (info.pr_policy & ~SCTP_PR_SCTP_MASK)
 +		goto out;
 +
 +	if (info.pr_policy == SCTP_PR_SCTP_NONE)
 +		info.pr_value = 0;
 +
 +	asoc = sctp_id2assoc(sk, info.pr_assoc_id);
 +	if (asoc) {
 +		SCTP_PR_SET_POLICY(asoc->default_flags, info.pr_policy);
 +		asoc->default_timetolive = info.pr_value;
 +	} else if (!info.pr_assoc_id) {
 +		struct sctp_sock *sp = sctp_sk(sk);
 +
 +		SCTP_PR_SET_POLICY(sp->default_flags, info.pr_policy);
 +		sp->default_timetolive = info.pr_value;
 +	} else {
 +		goto out;
 +	}
 +
 +	retval = 0;
 +
 +out:
 +	return retval;
++=======
+ static int sctp_setsockopt_recvrcvinfo(struct sock *sk,
+ 				       char __user *optval,
+ 				       unsigned int optlen)
+ {
+ 	int val;
+ 
+ 	if (optlen < sizeof(int))
+ 		return -EINVAL;
+ 	if (get_user(val, (int __user *) optval))
+ 		return -EFAULT;
+ 
+ 	sctp_sk(sk)->recvrcvinfo = (val == 0) ? 0 : 1;
+ 
+ 	return 0;
++>>>>>>> 0d3a421d2848 (net: sctp: implement rfc6458, 5.3.5. SCTP_RCVINFO cmsg support)
  }
  
  /* API 6.2 setsockopt(), getsockopt()
@@@ -3810,11 -3762,8 +3830,16 @@@ static int sctp_setsockopt(struct sock 
  	case SCTP_PEER_ADDR_THLDS:
  		retval = sctp_setsockopt_paddr_thresholds(sk, optval, optlen);
  		break;
++<<<<<<< HEAD
 +	case SCTP_PR_SUPPORTED:
 +		retval = sctp_setsockopt_pr_supported(sk, optval, optlen);
 +		break;
 +	case SCTP_DEFAULT_PRINFO:
 +		retval = sctp_setsockopt_default_prinfo(sk, optval, optlen);
++=======
+ 	case SCTP_RECVRCVINFO:
+ 		retval = sctp_setsockopt_recvrcvinfo(sk, optval, optlen);
++>>>>>>> 0d3a421d2848 (net: sctp: implement rfc6458, 5.3.5. SCTP_RCVINFO cmsg support)
  		break;
  	default:
  		retval = -ENOPROTOOPT;
@@@ -6070,146 -5794,24 +6097,167 @@@ static int sctp_getsockopt_assoc_stats(
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int sctp_getsockopt_pr_supported(struct sock *sk, int len,
 +					char __user *optval,
 +					int __user *optlen)
 +{
 +	struct sctp_assoc_value params;
 +	struct sctp_association *asoc;
 +	int retval = -EFAULT;
 +
 +	if (len < sizeof(params)) {
 +		retval = -EINVAL;
 +		goto out;
 +	}
 +
 +	len = sizeof(params);
 +	if (copy_from_user(&params, optval, len))
 +		goto out;
 +
 +	asoc = sctp_id2assoc(sk, params.assoc_id);
 +	if (asoc) {
 +		params.assoc_value = asoc->prsctp_enable;
 +	} else if (!params.assoc_id) {
 +		struct sctp_sock *sp = sctp_sk(sk);
 +
 +		params.assoc_value = sp->ep->prsctp_enable;
 +	} else {
 +		retval = -EINVAL;
 +		goto out;
 +	}
 +
 +	if (put_user(len, optlen))
 +		goto out;
 +
 +	if (copy_to_user(optval, &params, len))
 +		goto out;
 +
 +	retval = 0;
 +
 +out:
 +	return retval;
 +}
 +
 +static int sctp_getsockopt_default_prinfo(struct sock *sk, int len,
 +					  char __user *optval,
 +					  int __user *optlen)
 +{
 +	struct sctp_default_prinfo info;
 +	struct sctp_association *asoc;
 +	int retval = -EFAULT;
 +
 +	if (len < sizeof(info)) {
 +		retval = -EINVAL;
 +		goto out;
 +	}
 +
 +	len = sizeof(info);
 +	if (copy_from_user(&info, optval, len))
 +		goto out;
 +
 +	asoc = sctp_id2assoc(sk, info.pr_assoc_id);
 +	if (asoc) {
 +		info.pr_policy = SCTP_PR_POLICY(asoc->default_flags);
 +		info.pr_value = asoc->default_timetolive;
 +	} else if (!info.pr_assoc_id) {
 +		struct sctp_sock *sp = sctp_sk(sk);
 +
 +		info.pr_policy = SCTP_PR_POLICY(sp->default_flags);
 +		info.pr_value = sp->default_timetolive;
 +	} else {
 +		retval = -EINVAL;
 +		goto out;
 +	}
 +
 +	if (put_user(len, optlen))
 +		goto out;
 +
 +	if (copy_to_user(optval, &info, len))
 +		goto out;
 +
 +	retval = 0;
 +
 +out:
 +	return retval;
 +}
 +
 +static int sctp_getsockopt_pr_assocstatus(struct sock *sk, int len,
 +					  char __user *optval,
 +					  int __user *optlen)
 +{
 +	struct sctp_prstatus params;
 +	struct sctp_association *asoc;
 +	int policy;
 +	int retval = -EINVAL;
 +
 +	if (len < sizeof(params))
 +		goto out;
 +
 +	len = sizeof(params);
 +	if (copy_from_user(&params, optval, len)) {
 +		retval = -EFAULT;
 +		goto out;
 +	}
 +
 +	policy = params.sprstat_policy;
 +	if (policy & ~SCTP_PR_SCTP_MASK)
 +		goto out;
 +
 +	asoc = sctp_id2assoc(sk, params.sprstat_assoc_id);
 +	if (!asoc)
 +		goto out;
 +
 +	if (policy == SCTP_PR_SCTP_NONE) {
 +		params.sprstat_abandoned_unsent = 0;
 +		params.sprstat_abandoned_sent = 0;
 +		for (policy = 0; policy <= SCTP_PR_INDEX(MAX); policy++) {
 +			params.sprstat_abandoned_unsent +=
 +				asoc->abandoned_unsent[policy];
 +			params.sprstat_abandoned_sent +=
 +				asoc->abandoned_sent[policy];
 +		}
 +	} else {
 +		params.sprstat_abandoned_unsent =
 +			asoc->abandoned_unsent[__SCTP_PR_INDEX(policy)];
 +		params.sprstat_abandoned_sent =
 +			asoc->abandoned_sent[__SCTP_PR_INDEX(policy)];
 +	}
 +
 +	if (put_user(len, optlen)) {
 +		retval = -EFAULT;
 +		goto out;
 +	}
 +
 +	if (copy_to_user(optval, &params, len)) {
 +		retval = -EFAULT;
 +		goto out;
 +	}
 +
 +	retval = 0;
 +
 +out:
 +	return retval;
++=======
+ static int sctp_getsockopt_recvrcvinfo(struct sock *sk,	int len,
+ 				       char __user *optval,
+ 				       int __user *optlen)
+ {
+ 	int val = 0;
+ 
+ 	if (len < sizeof(int))
+ 		return -EINVAL;
+ 
+ 	len = sizeof(int);
+ 	if (sctp_sk(sk)->recvrcvinfo)
+ 		val = 1;
+ 	if (put_user(len, optlen))
+ 		return -EFAULT;
+ 	if (copy_to_user(optval, &val, len))
+ 		return -EFAULT;
+ 
+ 	return 0;
++>>>>>>> 0d3a421d2848 (net: sctp: implement rfc6458, 5.3.5. SCTP_RCVINFO cmsg support)
  }
  
  static int sctp_getsockopt(struct sock *sk, int level, int optname,
@@@ -6355,16 -5957,8 +6403,21 @@@
  	case SCTP_GET_ASSOC_STATS:
  		retval = sctp_getsockopt_assoc_stats(sk, len, optval, optlen);
  		break;
++<<<<<<< HEAD
 +	case SCTP_PR_SUPPORTED:
 +		retval = sctp_getsockopt_pr_supported(sk, len, optval, optlen);
 +		break;
 +	case SCTP_DEFAULT_PRINFO:
 +		retval = sctp_getsockopt_default_prinfo(sk, len, optval,
 +							optlen);
 +		break;
 +	case SCTP_PR_ASSOC_STATUS:
 +		retval = sctp_getsockopt_pr_assocstatus(sk, len, optval,
 +							optlen);
++=======
+ 	case SCTP_RECVRCVINFO:
+ 		retval = sctp_getsockopt_recvrcvinfo(sk, len, optval, optlen);
++>>>>>>> 0d3a421d2848 (net: sctp: implement rfc6458, 5.3.5. SCTP_RCVINFO cmsg support)
  		break;
  	default:
  		retval = -ENOPROTOOPT;
* Unmerged path include/net/sctp/structs.h
diff --git a/include/net/sctp/ulpevent.h b/include/net/sctp/ulpevent.h
index 42fbbfb99375..180518af9ebd 100644
--- a/include/net/sctp/ulpevent.h
+++ b/include/net/sctp/ulpevent.h
@@ -136,7 +136,10 @@ struct sctp_ulpevent *sctp_ulpevent_make_sender_dry_event(
 	const struct sctp_association *asoc, gfp_t gfp);
 
 void sctp_ulpevent_read_sndrcvinfo(const struct sctp_ulpevent *event,
-	struct msghdr *);
+				   struct msghdr *);
+void sctp_ulpevent_read_rcvinfo(const struct sctp_ulpevent *event,
+				struct msghdr *);
+
 __u16 sctp_ulpevent_get_notification_type(const struct sctp_ulpevent *event);
 
 /* Is this event type enabled? */
* Unmerged path include/uapi/linux/sctp.h
* Unmerged path net/sctp/socket.c
diff --git a/net/sctp/ulpevent.c b/net/sctp/ulpevent.c
index 36628efae234..3a4fe57f6680 100644
--- a/net/sctp/ulpevent.c
+++ b/net/sctp/ulpevent.c
@@ -902,6 +902,31 @@ void sctp_ulpevent_read_sndrcvinfo(const struct sctp_ulpevent *event,
 		 sizeof(sinfo), &sinfo);
 }
 
+/* RFC6458, Section 5.3.5 SCTP Receive Information Structure
+ * (SCTP_SNDRCV)
+ */
+void sctp_ulpevent_read_rcvinfo(const struct sctp_ulpevent *event,
+				struct msghdr *msghdr)
+{
+	struct sctp_rcvinfo rinfo;
+
+	if (sctp_ulpevent_is_notification(event))
+		return;
+
+	memset(&rinfo, 0, sizeof(struct sctp_rcvinfo));
+	rinfo.rcv_sid = event->stream;
+	rinfo.rcv_ssn = event->ssn;
+	rinfo.rcv_ppid = event->ppid;
+	rinfo.rcv_flags = event->flags;
+	rinfo.rcv_tsn = event->tsn;
+	rinfo.rcv_cumtsn = event->cumtsn;
+	rinfo.rcv_assoc_id = sctp_assoc2id(event->asoc);
+	rinfo.rcv_context = event->asoc->default_rcv_context;
+
+	put_cmsg(msghdr, IPPROTO_SCTP, SCTP_RCVINFO,
+		 sizeof(rinfo), &rinfo);
+}
+
 /* Do accounting for bytes received and hold a reference to the association
  * for each skb.
  */
