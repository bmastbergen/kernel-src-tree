ipv6: introduce secret_stable to ipv6_devconf

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit 3d1bec99320d4e96897805440f8cf4f68eff226b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3d1bec99.failed

This patch implements the procfs logic for the stable_address knob:
The secret is formatted as an ipv6 address and will be stored per
interface and per namespace. We track initialized flag and return EIO
errors until the secret is set.

We don't inherit the secret to newly created namespaces.

	Cc: Erik Kline <ek@google.com>
	Cc: Fernando Gont <fgont@si6networks.com>
	Cc: Lorenzo Colitti <lorenzo@google.com>
	Cc: YOSHIFUJI Hideaki/吉藤英明 <hideaki.yoshifuji@miraclelinux.com>
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3d1bec99320d4e96897805440f8cf4f68eff226b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ipv6.h
#	include/uapi/linux/ipv6.h
#	net/ipv6/addrconf.c
diff --cc include/linux/ipv6.h
index bf6b55bb15ef,82806c60aa42..000000000000
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@@ -48,6 -51,12 +48,15 @@@ struct ipv6_devconf 
  	__s32		accept_dad;
  	__s32		force_tllao;
  	__s32           ndisc_notify;
++<<<<<<< HEAD
++=======
+ 	__s32		suppress_frag_ndisc;
+ 	__s32		accept_ra_mtu;
+ 	struct ipv6_stable_secret {
+ 		bool initialized;
+ 		struct in6_addr secret;
+ 	} stable_secret;
++>>>>>>> 3d1bec99320d (ipv6: introduce secret_stable to ipv6_devconf)
  	void		*sysctl;
  };
  
diff --cc include/uapi/linux/ipv6.h
index d07ac6903e59,5efa54ae567c..000000000000
--- a/include/uapi/linux/ipv6.h
+++ b/include/uapi/linux/ipv6.h
@@@ -162,6 -166,11 +162,14 @@@ enum 
  	DEVCONF_NDISC_NOTIFY,
  	DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL,
  	DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL,
++<<<<<<< HEAD
++=======
+ 	DEVCONF_SUPPRESS_FRAG_NDISC,
+ 	DEVCONF_ACCEPT_RA_FROM_LOCAL,
+ 	DEVCONF_USE_OPTIMISTIC,
+ 	DEVCONF_ACCEPT_RA_MTU,
+ 	DEVCONF_STABLE_SECRET,
++>>>>>>> 3d1bec99320d (ipv6: introduce secret_stable to ipv6_devconf)
  	DEVCONF_MAX
  };
  
diff --cc net/ipv6/addrconf.c
index cc12901dc798,5b967c8a617a..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -199,6 -204,11 +203,14 @@@ static struct ipv6_devconf ipv6_devcon
  	.accept_source_route	= 0,	/* we do not accept RH0 by default. */
  	.disable_ipv6		= 0,
  	.accept_dad		= 1,
++<<<<<<< HEAD
++=======
+ 	.suppress_frag_ndisc	= 1,
+ 	.accept_ra_mtu		= 1,
+ 	.stable_secret		= {
+ 		.initialized = false,
+ 	}
++>>>>>>> 3d1bec99320d (ipv6: introduce secret_stable to ipv6_devconf)
  };
  
  static struct ipv6_devconf ipv6_devconf_dflt __read_mostly = {
@@@ -234,6 -245,11 +246,14 @@@
  	.accept_source_route	= 0,	/* we do not accept RH0 by default. */
  	.disable_ipv6		= 0,
  	.accept_dad		= 1,
++<<<<<<< HEAD
++=======
+ 	.suppress_frag_ndisc	= 1,
+ 	.accept_ra_mtu		= 1,
+ 	.stable_secret		= {
+ 		.initialized = false,
+ 	},
++>>>>>>> 3d1bec99320d (ipv6: introduce secret_stable to ipv6_devconf)
  };
  
  /* Check if a valid qdisc is available */
@@@ -4353,6 -4437,10 +4373,13 @@@ static inline void ipv6_store_devconf(s
  	array[DEVCONF_ACCEPT_DAD] = cnf->accept_dad;
  	array[DEVCONF_FORCE_TLLAO] = cnf->force_tllao;
  	array[DEVCONF_NDISC_NOTIFY] = cnf->ndisc_notify;
++<<<<<<< HEAD
++=======
+ 	array[DEVCONF_SUPPRESS_FRAG_NDISC] = cnf->suppress_frag_ndisc;
+ 	array[DEVCONF_ACCEPT_RA_FROM_LOCAL] = cnf->accept_ra_from_local;
+ 	array[DEVCONF_ACCEPT_RA_MTU] = cnf->accept_ra_mtu;
+ 	/* we omit DEVCONF_STABLE_SECRET for now */
++>>>>>>> 3d1bec99320d (ipv6: introduce secret_stable to ipv6_devconf)
  }
  
  static inline size_t inet6_ifla6_size(void)
@@@ -4954,6 -5046,93 +4981,96 @@@ int addrconf_sysctl_disable(struct ctl_
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static
+ int addrconf_sysctl_proxy_ndp(struct ctl_table *ctl, int write,
+ 			      void __user *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int *valp = ctl->data;
+ 	int ret;
+ 	int old, new;
+ 
+ 	old = *valp;
+ 	ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
+ 	new = *valp;
+ 
+ 	if (write && old != new) {
+ 		struct net *net = ctl->extra2;
+ 
+ 		if (!rtnl_trylock())
+ 			return restart_syscall();
+ 
+ 		if (valp == &net->ipv6.devconf_dflt->proxy_ndp)
+ 			inet6_netconf_notify_devconf(net, NETCONFA_PROXY_NEIGH,
+ 						     NETCONFA_IFINDEX_DEFAULT,
+ 						     net->ipv6.devconf_dflt);
+ 		else if (valp == &net->ipv6.devconf_all->proxy_ndp)
+ 			inet6_netconf_notify_devconf(net, NETCONFA_PROXY_NEIGH,
+ 						     NETCONFA_IFINDEX_ALL,
+ 						     net->ipv6.devconf_all);
+ 		else {
+ 			struct inet6_dev *idev = ctl->extra1;
+ 
+ 			inet6_netconf_notify_devconf(net, NETCONFA_PROXY_NEIGH,
+ 						     idev->dev->ifindex,
+ 						     &idev->cnf);
+ 		}
+ 		rtnl_unlock();
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int addrconf_sysctl_stable_secret(struct ctl_table *ctl, int write,
+ 					 void __user *buffer, size_t *lenp,
+ 					 loff_t *ppos)
+ {
+ 	int err;
+ 	struct in6_addr addr;
+ 	char str[IPV6_MAX_STRLEN];
+ 	struct ctl_table lctl = *ctl;
+ 	struct ipv6_stable_secret *secret = ctl->data;
+ 
+ 	lctl.maxlen = IPV6_MAX_STRLEN;
+ 	lctl.data = str;
+ 
+ 	if (!rtnl_trylock())
+ 		return restart_syscall();
+ 
+ 	if (!write && !secret->initialized) {
+ 		err = -EIO;
+ 		goto out;
+ 	}
+ 
+ 	if (!write) {
+ 		err = snprintf(str, sizeof(str), "%pI6",
+ 			       &secret->secret);
+ 		if (err >= sizeof(str)) {
+ 			err = -EIO;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	err = proc_dostring(&lctl, write, buffer, lenp, ppos);
+ 	if (err || !write)
+ 		goto out;
+ 
+ 	if (in6_pton(str, -1, addr.in6_u.u6_addr8, -1, NULL) != 1) {
+ 		err = -EIO;
+ 		goto out;
+ 	}
+ 
+ 	secret->initialized = true;
+ 	secret->secret = addr;
+ 
+ out:
+ 	rtnl_unlock();
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 3d1bec99320d (ipv6: introduce secret_stable to ipv6_devconf)
  static struct addrconf_sysctl_table
  {
  	struct ctl_table_header *sysctl_header;
@@@ -5197,6 -5384,34 +5314,37 @@@
  			.proc_handler   = proc_dointvec
  		},
  		{
++<<<<<<< HEAD
++=======
+ 			.procname	= "suppress_frag_ndisc",
+ 			.data		= &ipv6_devconf.suppress_frag_ndisc,
+ 			.maxlen		= sizeof(int),
+ 			.mode		= 0644,
+ 			.proc_handler	= proc_dointvec
+ 		},
+ 		{
+ 			.procname	= "accept_ra_from_local",
+ 			.data		= &ipv6_devconf.accept_ra_from_local,
+ 			.maxlen		= sizeof(int),
+ 			.mode		= 0644,
+ 			.proc_handler	= proc_dointvec,
+ 		},
+ 		{
+ 			.procname	= "accept_ra_mtu",
+ 			.data		= &ipv6_devconf.accept_ra_mtu,
+ 			.maxlen		= sizeof(int),
+ 			.mode		= 0644,
+ 			.proc_handler	= proc_dointvec,
+ 		},
+ 		{
+ 			.procname	= "stable_secret",
+ 			.data		= &ipv6_devconf.stable_secret,
+ 			.maxlen		= IPV6_MAX_STRLEN,
+ 			.mode		= 0600,
+ 			.proc_handler	= addrconf_sysctl_stable_secret,
+ 		},
+ 		{
++>>>>>>> 3d1bec99320d (ipv6: introduce secret_stable to ipv6_devconf)
  			/* sentinel */
  		}
  	},
* Unmerged path include/linux/ipv6.h
* Unmerged path include/uapi/linux/ipv6.h
* Unmerged path net/ipv6/addrconf.c
