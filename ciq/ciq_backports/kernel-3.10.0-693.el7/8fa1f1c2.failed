make fs/{namespace,super}.c forget about acct.h

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] make fs/{namespace, super}.c forget about acct.h ("Eric W. Biederman") [1247935]
Rebuild_FUZZ: 98.95%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 8fa1f1c2bd86007beb4a4845e6087ac4a704dc80
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8fa1f1c2.failed

These externs belong in fs/internal.h.  Rename (they are not acct-specific
anymore) and move them over there.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 8fa1f1c2bd86007beb4a4845e6087ac4a704dc80)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fs_pin.c
#	fs/namespace.c
#	fs/super.c
diff --cc fs/namespace.c
index a82db7875df0,0e4ce51c5277..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -902,13 -953,21 +901,19 @@@ put_again
  	if (unlikely(mnt->mnt_pinned)) {
  		mnt_add_count(mnt, mnt->mnt_pinned + 1);
  		mnt->mnt_pinned = 0;
++<<<<<<< HEAD
 +		br_write_unlock(&vfsmount_lock);
 +		acct_auto_close_mnt(&mnt->mnt);
++=======
+ 		rcu_read_unlock();
+ 		unlock_mount_hash();
+ 		mnt_pin_kill(mnt);
++>>>>>>> 8fa1f1c2bd86 (make fs/{namespace,super}.c forget about acct.h)
  		goto put_again;
  	}
 -	if (unlikely(mnt->mnt.mnt_flags & MNT_DOOMED)) {
 -		rcu_read_unlock();
 -		unlock_mount_hash();
 -		return;
 -	}
 -	mnt->mnt.mnt_flags |= MNT_DOOMED;
 -	rcu_read_unlock();
  
  	list_del(&mnt->mnt_instance);
 -	unlock_mount_hash();
 +	br_write_unlock(&vfsmount_lock);
  
  	/*
  	 * This probably indicates that somebody messed
diff --cc fs/super.c
index 2255fd76fd29,a371ce6aa919..000000000000
--- a/fs/super.c
+++ b/fs/super.c
@@@ -666,12 -701,21 +665,29 @@@ int do_remount_sb(struct super_block *s
  		return -EACCES;
  #endif
  
++<<<<<<< HEAD
 +	if (flags & MS_RDONLY)
 +		acct_auto_close(sb);
++=======
+ 	remount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);
+ 
+ 	if (remount_ro) {
+ 		if (sb->s_pins.first) {
+ 			up_write(&sb->s_umount);
+ 			sb_pin_kill(sb);
+ 			down_write(&sb->s_umount);
+ 			if (!sb->s_root)
+ 				return 0;
+ 			if (sb->s_writers.frozen != SB_UNFROZEN)
+ 				return -EBUSY;
+ 			remount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);
+ 		}
+ 	}
++>>>>>>> 8fa1f1c2bd86 (make fs/{namespace,super}.c forget about acct.h)
  	shrink_dcache_sb(sb);
 +	sync_filesystem(sb);
 +
 +	remount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);
  
  	/* If we are remounting RDONLY and current sb is read/write,
  	   make sure there are no rw files opened */
* Unmerged path fs/fs_pin.c
* Unmerged path fs/fs_pin.c
diff --git a/fs/internal.h b/fs/internal.h
index 3b41f3e8a80a..a7d8b6527caa 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -135,3 +135,9 @@ extern ssize_t __kernel_write(struct file *, const char *, size_t, loff_t *);
  * pipe.c
  */
 extern const struct file_operations pipefifo_fops;
+
+/*
+ * fs_pin.c
+ */
+extern void sb_pin_kill(struct super_block *sb);
+extern void mnt_pin_kill(struct mount *m);
* Unmerged path fs/namespace.c
* Unmerged path fs/super.c
