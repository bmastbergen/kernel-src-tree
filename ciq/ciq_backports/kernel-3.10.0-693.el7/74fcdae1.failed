x86/intel_rdt: Call intel_rdt_sched_in() with preemption disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] intel_rdt: Call intel_rdt_sched_in() with preemption disabled (Jiri Olsa) [1288964]
Rebuild_FUZZ: 96.83%
commit-author Fenghua Yu <fenghua.yu@intel.com>
commit 74fcdae1a7fdf30de5413ccc1eca271415d01124
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/74fcdae1.failed

intel_rdt_sched_in() must be called with preemption disabled because the
function accesses percpu variables (pqr_state and closid).

If a task moves itself via move_myself() preemption is enabled, which
violates the calling convention and can result in incorrect closid
selection when the task gets preempted or migrated.

Add the required protection and a comment about the calling convention.

	Signed-off-by: Fenghua Yu <fenghua.yu@intel.com>
	Cc: "Ravi V Shankar" <ravi.v.shankar@intel.com>
	Cc: "Tony Luck" <tony.luck@intel.com>
	Cc: "Marcelo Tosatti" <mtosatti@redhat.com>
	Cc: "Sai Prakhya" <sai.praneeth.prakhya@intel.com>
	Cc: "Vikas Shivappa" <vikas.shivappa@linux.intel.com>
	Cc: "H. Peter Anvin" <h.peter.anvin@intel.com>
Link: http://lkml.kernel.org/r/1480625714-54246-1-git-send-email-fenghua.yu@intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 74fcdae1a7fdf30de5413ccc1eca271415d01124)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/intel_rdt.h
#	arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
diff --cc arch/x86/include/asm/intel_rdt.h
index 2e5eab09083e,95ce5c85b009..000000000000
--- a/arch/x86/include/asm/intel_rdt.h
+++ b/arch/x86/include/asm/intel_rdt.h
@@@ -176,4 -181,44 +176,47 @@@ ssize_t rdtgroup_schemata_write(struct 
  				char *buf, size_t nbytes, loff_t off);
  int rdtgroup_schemata_show(struct kernfs_open_file *of,
  			   struct seq_file *s, void *v);
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * intel_rdt_sched_in() - Writes the task's CLOSid to IA32_PQR_MSR
+  *
+  * Following considerations are made so that this has minimal impact
+  * on scheduler hot path:
+  * - This will stay as no-op unless we are running on an Intel SKU
+  *   which supports resource control and we enable by mounting the
+  *   resctrl file system.
+  * - Caches the per cpu CLOSid values and does the MSR write only
+  *   when a task with a different CLOSid is scheduled in.
+  *
+  * Must be called with preemption disabled.
+  */
+ static inline void intel_rdt_sched_in(void)
+ {
+ 	if (static_branch_likely(&rdt_enable_key)) {
+ 		struct intel_pqr_state *state = this_cpu_ptr(&pqr_state);
+ 		int closid;
+ 
+ 		/*
+ 		 * If this task has a closid assigned, use it.
+ 		 * Else use the closid assigned to this cpu.
+ 		 */
+ 		closid = current->closid;
+ 		if (closid == 0)
+ 			closid = this_cpu_read(cpu_closid);
+ 
+ 		if (closid != state->closid) {
+ 			state->closid = closid;
+ 			wrmsr(MSR_IA32_PQR_ASSOC, state->rmid, closid);
+ 		}
+ 	}
+ }
+ 
+ #else
+ 
+ static inline void intel_rdt_sched_in(void) {}
+ 
+ #endif /* CONFIG_INTEL_RDT_A */
++>>>>>>> 74fcdae1a7fd (x86/intel_rdt: Call intel_rdt_sched_in() with preemption disabled)
  #endif /* _ASM_X86_INTEL_RDT_H */
diff --cc arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
index 38f46efc4acf,1afd3f393501..000000000000
--- a/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
+++ b/arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
@@@ -326,6 -326,11 +326,14 @@@ static void move_myself(struct callback
  		kfree(rdtgrp);
  	}
  
++<<<<<<< HEAD
++=======
+ 	preempt_disable();
+ 	/* update PQR_ASSOC MSR to make resource group go into effect */
+ 	intel_rdt_sched_in();
+ 	preempt_enable();
+ 
++>>>>>>> 74fcdae1a7fd (x86/intel_rdt: Call intel_rdt_sched_in() with preemption disabled)
  	kfree(callback);
  }
  
* Unmerged path arch/x86/include/asm/intel_rdt.h
* Unmerged path arch/x86/kernel/cpu/intel_rdt_rdtgroup.c
