blk-mq: blk_mq_try_issue_directly() should lookup hardware queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jens Axboe <axboe@fb.com>
commit 066a4a73cee9a44a906b98825e70c47de5bd8b5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/066a4a73.failed

A previous commit changed this to pass in the hardware queue, but
it was using the wrong hardware queue. Hence a request that was
allocated on one hardware queue ended up being issued on another
one, and that caused IO timeouts and oopses on some drivers. Since
the request holds hardware queue private resources, like a tag,
we can't just issue it on a different hardware queue.

Fixes: 2253efc850c4 ("blk-mq: Move more code into blk_mq_direct_issue_request()")
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 066a4a73cee9a44a906b98825e70c47de5bd8b5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index 1fb8b36f35c6,77110aed24ea..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1228,12 -1291,11 +1228,20 @@@ static struct request *blk_mq_map_reque
  	return rq;
  }
  
++<<<<<<< HEAD
 +static int blk_mq_direct_issue_request(struct request *rq)
 +{
 +	int ret;
 +	struct request_queue *q = rq->q;
 +	struct blk_mq_hw_ctx *hctx = q->mq_ops->map_queue(q,
 +			rq->mq_ctx->cpu);
++=======
+ static void blk_mq_try_issue_directly(struct request *rq, blk_qc_t *cookie)
+ {
+ 	int ret;
+ 	struct request_queue *q = rq->q;
+ 	struct blk_mq_hw_ctx *hctx = blk_mq_map_queue(q, rq->mq_ctx->cpu);
++>>>>>>> 066a4a73cee9 (blk-mq: blk_mq_try_issue_directly() should lookup hardware queue)
  	struct blk_mq_queue_data bd = {
  		.rq = rq,
  		.list = NULL,
@@@ -1328,11 -1410,18 +1336,26 @@@ static void blk_mq_make_request(struct 
  			old_rq = rq;
  		blk_mq_put_ctx(data.ctx);
  		if (!old_rq)
++<<<<<<< HEAD
 +			return;
 +		if (!blk_mq_direct_issue_request(old_rq))
 +			return;
 +		blk_mq_insert_request(old_rq, false, true, true);
 +		return;
++=======
+ 			goto done;
+ 
+ 		if (!(data.hctx->flags & BLK_MQ_F_BLOCKING)) {
+ 			rcu_read_lock();
+ 			blk_mq_try_issue_directly(old_rq, &cookie);
+ 			rcu_read_unlock();
+ 		} else {
+ 			srcu_idx = srcu_read_lock(&data.hctx->queue_rq_srcu);
+ 			blk_mq_try_issue_directly(old_rq, &cookie);
+ 			srcu_read_unlock(&data.hctx->queue_rq_srcu, srcu_idx);
+ 		}
+ 		goto done;
++>>>>>>> 066a4a73cee9 (blk-mq: blk_mq_try_issue_directly() should lookup hardware queue)
  	}
  
  	if (!blk_mq_merge_queue_io(data.hctx, data.ctx, rq, bio)) {
* Unmerged path block/blk-mq.c
