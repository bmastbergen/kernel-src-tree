xfs: fix up xfs_swap_extent_forks inline extent handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric Sandeen <sandeen@sandeen.net>
commit 4dfce57db6354603641132fac3c887614e3ebe81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4dfce57d.failed

There have been several reports over the years of NULL pointer
dereferences in xfs_trans_log_inode during xfs_fsr processes,
when the process is doing an fput and tearing down extents
on the temporary inode, something like:

BUG: unable to handle kernel NULL pointer dereference at 0000000000000018
PID: 29439  TASK: ffff880550584fa0  CPU: 6   COMMAND: "xfs_fsr"
    [exception RIP: xfs_trans_log_inode+0x10]
 #9 [ffff8800a57bbbe0] xfs_bunmapi at ffffffffa037398e [xfs]
#10 [ffff8800a57bbce8] xfs_itruncate_extents at ffffffffa0391b29 [xfs]
#11 [ffff8800a57bbd88] xfs_inactive_truncate at ffffffffa0391d0c [xfs]
#12 [ffff8800a57bbdb8] xfs_inactive at ffffffffa0392508 [xfs]
#13 [ffff8800a57bbdd8] xfs_fs_evict_inode at ffffffffa035907e [xfs]
#14 [ffff8800a57bbe00] evict at ffffffff811e1b67
#15 [ffff8800a57bbe28] iput at ffffffff811e23a5
#16 [ffff8800a57bbe58] dentry_kill at ffffffff811dcfc8
#17 [ffff8800a57bbe88] dput at ffffffff811dd06c
#18 [ffff8800a57bbea8] __fput at ffffffff811c823b
#19 [ffff8800a57bbef0] ____fput at ffffffff811c846e
#20 [ffff8800a57bbf00] task_work_run at ffffffff81093b27
#21 [ffff8800a57bbf30] do_notify_resume at ffffffff81013b0c
#22 [ffff8800a57bbf50] int_signal at ffffffff8161405d

As it turns out, this is because the i_itemp pointer, along
with the d_ops pointer, has been overwritten with zeros
when we tear down the extents during truncate.  When the in-core
inode fork on the temporary inode used by xfs_fsr was originally
set up during the extent swap, we mistakenly looked at di_nextents
to determine whether all extents fit inline, but this misses extents
generated by speculative preallocation; we should be using if_bytes
instead.

This mistake corrupts the in-memory inode, and code in
xfs_iext_remove_inline eventually gets bad inputs, causing
it to memmove and memset incorrect ranges; this became apparent
because the two values in ifp->if_u2.if_inline_ext[1] contained
what should have been in d_ops and i_itemp; they were memmoved due
to incorrect array indexing and then the original locations
were zeroed with memset, again due to an array overrun.

Fix this by properly using i_df.if_bytes to determine the number
of extents, not di_nextents.

Thanks to dchinner for looking at this with me and spotting the
root cause.

	Cc: stable@vger.kernel.org
	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 4dfce57db6354603641132fac3c887614e3ebe81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/xfs_bmap_util.c
index 935fc7ad67c0,47074e0c33f3..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -1634,109 -1656,146 +1634,127 @@@ xfs_swap_extent_flush
  	return 0;
  }
  
 -/*
 - * Move extents from one file to another, when rmap is enabled.
 - */
 -STATIC int
 -xfs_swap_extent_rmap(
 -	struct xfs_trans		**tpp,
 -	struct xfs_inode		*ip,
 -	struct xfs_inode		*tip)
 +int
 +xfs_swap_extents(
 +	xfs_inode_t	*ip,	/* target inode */
 +	xfs_inode_t	*tip,	/* tmp inode */
 +	xfs_swapext_t	*sxp)
  {
 -	struct xfs_bmbt_irec		irec;
 -	struct xfs_bmbt_irec		uirec;
 -	struct xfs_bmbt_irec		tirec;
 -	xfs_fileoff_t			offset_fsb;
 -	xfs_fileoff_t			end_fsb;
 -	xfs_filblks_t			count_fsb;
 -	xfs_fsblock_t			firstfsb;
 -	struct xfs_defer_ops		dfops;
 -	int				error;
 -	xfs_filblks_t			ilen;
 -	xfs_filblks_t			rlen;
 -	int				nimaps;
 -	__uint64_t			tip_flags2;
 +	xfs_mount_t	*mp = ip->i_mount;
 +	xfs_trans_t	*tp;
 +	xfs_bstat_t	*sbp = &sxp->sx_stat;
 +	xfs_ifork_t	*tempifp, *ifp, *tifp;
 +	int		src_log_flags, target_log_flags;
 +	int		error = 0;
 +	int		aforkblks = 0;
 +	int		taforkblks = 0;
 +	__uint64_t	tmp;
 +	int		lock_flags;
 +
 +	tempifp = kmem_alloc(sizeof(xfs_ifork_t), KM_MAYFAIL);
 +	if (!tempifp) {
 +		error = -ENOMEM;
 +		goto out;
 +	}
  
  	/*
 -	 * If the source file has shared blocks, we must flag the donor
 -	 * file as having shared blocks so that we get the shared-block
 -	 * rmap functions when we go to fix up the rmaps.  The flags
 -	 * will be switch for reals later.
 +	 * Lock the inodes against other IO, page faults and truncate to
 +	 * begin with.  Then we can ensure the inodes are flushed and have no
 +	 * page cache safely. Once we have done this we can take the ilocks and
 +	 * do the rest of the checks.
  	 */
 -	tip_flags2 = tip->i_d.di_flags2;
 -	if (ip->i_d.di_flags2 & XFS_DIFLAG2_REFLINK)
 -		tip->i_d.di_flags2 |= XFS_DIFLAG2_REFLINK;
 -
 -	offset_fsb = 0;
 -	end_fsb = XFS_B_TO_FSB(ip->i_mount, i_size_read(VFS_I(ip)));
 -	count_fsb = (xfs_filblks_t)(end_fsb - offset_fsb);
 -
 -	while (count_fsb) {
 -		/* Read extent from the donor file */
 -		nimaps = 1;
 -		error = xfs_bmapi_read(tip, offset_fsb, count_fsb, &tirec,
 -				&nimaps, 0);
 -		if (error)
 -			goto out;
 -		ASSERT(nimaps == 1);
 -		ASSERT(tirec.br_startblock != DELAYSTARTBLOCK);
 -
 -		trace_xfs_swap_extent_rmap_remap(tip, &tirec);
 -		ilen = tirec.br_blockcount;
 -
 -		/* Unmap the old blocks in the source file. */
 -		while (tirec.br_blockcount) {
 -			xfs_defer_init(&dfops, &firstfsb);
 -			trace_xfs_swap_extent_rmap_remap_piece(tip, &tirec);
 -
 -			/* Read extent from the source file */
 -			nimaps = 1;
 -			error = xfs_bmapi_read(ip, tirec.br_startoff,
 -					tirec.br_blockcount, &irec,
 -					&nimaps, 0);
 -			if (error)
 -				goto out_defer;
 -			ASSERT(nimaps == 1);
 -			ASSERT(tirec.br_startoff == irec.br_startoff);
 -			trace_xfs_swap_extent_rmap_remap_piece(ip, &irec);
 -
 -			/* Trim the extent. */
 -			uirec = tirec;
 -			uirec.br_blockcount = rlen = min_t(xfs_filblks_t,
 -					tirec.br_blockcount,
 -					irec.br_blockcount);
 -			trace_xfs_swap_extent_rmap_remap_piece(tip, &uirec);
 -
 -			/* Remove the mapping from the donor file. */
 -			error = xfs_bmap_unmap_extent((*tpp)->t_mountp, &dfops,
 -					tip, &uirec);
 -			if (error)
 -				goto out_defer;
 -
 -			/* Remove the mapping from the source file. */
 -			error = xfs_bmap_unmap_extent((*tpp)->t_mountp, &dfops,
 -					ip, &irec);
 -			if (error)
 -				goto out_defer;
 -
 -			/* Map the donor file's blocks into the source file. */
 -			error = xfs_bmap_map_extent((*tpp)->t_mountp, &dfops,
 -					ip, &uirec);
 -			if (error)
 -				goto out_defer;
 -
 -			/* Map the source file's blocks into the donor file. */
 -			error = xfs_bmap_map_extent((*tpp)->t_mountp, &dfops,
 -					tip, &irec);
 -			if (error)
 -				goto out_defer;
 -
 -			error = xfs_defer_finish(tpp, &dfops, ip);
 -			if (error)
 -				goto out_defer;
 -
 -			tirec.br_startoff += rlen;
 -			if (tirec.br_startblock != HOLESTARTBLOCK &&
 -			    tirec.br_startblock != DELAYSTARTBLOCK)
 -				tirec.br_startblock += rlen;
 -			tirec.br_blockcount -= rlen;
 -		}
 +	lock_flags = XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL;
 +	xfs_lock_two_inodes(ip, tip, XFS_IOLOCK_EXCL);
 +	xfs_lock_two_inodes(ip, tip, XFS_MMAPLOCK_EXCL);
  
 -		/* Roll on... */
 -		count_fsb -= ilen;
 -		offset_fsb += ilen;
 +	/* Verify that both files have the same format */
 +	if ((ip->i_d.di_mode & S_IFMT) != (tip->i_d.di_mode & S_IFMT)) {
 +		error = -EINVAL;
 +		goto out_unlock;
  	}
  
 -	tip->i_d.di_flags2 = tip_flags2;
 -	return 0;
 -
 -out_defer:
 -	xfs_defer_cancel(&dfops);
 -out:
 -	trace_xfs_swap_extent_rmap_error(ip, error, _RET_IP_);
 -	tip->i_d.di_flags2 = tip_flags2;
 -	return error;
 -}
 -
++<<<<<<< HEAD
 +	/* Verify both files are either real-time or non-realtime */
 +	if (XFS_IS_REALTIME_INODE(ip) != XFS_IS_REALTIME_INODE(tip)) {
 +		error = -EINVAL;
 +		goto out_unlock;
 +	}
++=======
+ /* Swap the extents of two files by swapping data forks. */
+ STATIC int
+ xfs_swap_extent_forks(
+ 	struct xfs_trans	*tp,
+ 	struct xfs_inode	*ip,
+ 	struct xfs_inode	*tip,
+ 	int			*src_log_flags,
+ 	int			*target_log_flags)
+ {
+ 	struct xfs_ifork	tempifp, *ifp, *tifp;
+ 	int			aforkblks = 0;
+ 	int			taforkblks = 0;
+ 	xfs_extnum_t		nextents;
+ 	__uint64_t		tmp;
+ 	int			error;
++>>>>>>> 4dfce57db635 (xfs: fix up xfs_swap_extent_forks inline extent handling)
 +
 +	error = xfs_swap_extent_flush(ip);
 +	if (error)
 +		goto out_unlock;
 +	error = xfs_swap_extent_flush(tip);
 +	if (error)
 +		goto out_unlock;
 +
 +	tp = xfs_trans_alloc(mp, XFS_TRANS_SWAPEXT);
 +	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);
 +	if (error) {
 +		xfs_trans_cancel(tp);
 +		goto out_unlock;
 +	}
  
 +	/*
 +	 * Lock and join the inodes to the tansaction so that transaction commit
 +	 * or cancel will unlock the inodes from this point onwards.
 +	 */
 +	xfs_lock_two_inodes(ip, tip, XFS_ILOCK_EXCL);
 +	lock_flags |= XFS_ILOCK_EXCL;
 +	xfs_trans_ijoin(tp, ip, lock_flags);
 +	xfs_trans_ijoin(tp, tip, lock_flags);
 +
 +
 +	/* Verify all data are being swapped */
 +	if (sxp->sx_offset != 0 ||
 +	    sxp->sx_length != ip->i_d.di_size ||
 +	    sxp->sx_length != tip->i_d.di_size) {
 +		error = -EFAULT;
 +		goto out_trans_cancel;
 +	}
 +
 +	trace_xfs_swap_extent_before(ip, 0);
 +	trace_xfs_swap_extent_before(tip, 1);
 +
 +	/* check inode formats now that data is flushed */
 +	error = xfs_swap_extents_check_format(ip, tip);
 +	if (error) {
 +		xfs_notice(mp,
 +		    "%s: inode 0x%llx format is incompatible for exchanging.",
 +				__func__, ip->i_ino);
 +		goto out_trans_cancel;
 +	}
 +
 +	/*
 +	 * Compare the current change & modify times with that
 +	 * passed in.  If they differ, we abort this swap.
 +	 * This is the mechanism used to ensure the calling
 +	 * process that the file was not changed out from
 +	 * under it.
 +	 */
 +	if ((sbp->bs_ctime.tv_sec != VFS_I(ip)->i_ctime.tv_sec) ||
 +	    (sbp->bs_ctime.tv_nsec != VFS_I(ip)->i_ctime.tv_nsec) ||
 +	    (sbp->bs_mtime.tv_sec != VFS_I(ip)->i_mtime.tv_sec) ||
 +	    (sbp->bs_mtime.tv_nsec != VFS_I(ip)->i_mtime.tv_nsec)) {
 +		error = -EBUSY;
 +		goto out_trans_cancel;
 +	}
  	/*
  	 * Count the number of extended attribute blocks
  	 */
* Unmerged path fs/xfs/xfs_bmap_util.c
