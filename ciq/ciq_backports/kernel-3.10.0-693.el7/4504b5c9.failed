kvm: x86: Add AVX512_4VNNIW and AVX512_4FMAPS support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Luwei Kang <luwei.kang@intel.com>
commit 4504b5c9414c55da37f26b1faf49c09a2acbf255
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4504b5c9.failed

Add two new AVX512 subfeatures support for KVM guest.

AVX512_4VNNIW:
Vector instructions for deep learning enhanced word variable precision.

AVX512_4FMAPS:
Vector instructions for deep learning floating-point single precision.

	Reviewed-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: He Chen <he.chen@linux.intel.com>
	Signed-off-by: Luwei Kang <luwei.kang@intel.com>
[Changed subject tags.]
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit 4504b5c9414c55da37f26b1faf49c09a2acbf255)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
diff --cc arch/x86/kvm/cpuid.c
index 7f642dfc1c1d,a982fd80bceb..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -13,13 -13,13 +13,18 @@@
   */
  
  #include <linux/kvm_host.h>
 -#include <linux/export.h>
 +#include <linux/module.h>
  #include <linux/vmalloc.h>
  #include <linux/uaccess.h>
++<<<<<<< HEAD
 +#include <asm/i387.h> /* For use_eager_fpu.  Ugh! */
 +#include <asm/fpu-internal.h> /* For use_eager_fpu.  Ugh! */
++=======
+ #include <asm/processor.h>
+ #include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */
++>>>>>>> 4504b5c9414c (kvm: x86: Add AVX512_4VNNIW and AVX512_4FMAPS support)
  #include <asm/user.h>
 -#include <asm/fpu/xstate.h>
 +#include <asm/xsave.h>
  #include "cpuid.h"
  #include "lapic.h"
  #include "mmu.h"
@@@ -360,9 -376,16 +370,13 @@@ static inline int __do_cpuid_ent(struc
  		F(AVX512BW) | F(AVX512VL);
  
  	/* cpuid 0xD.1.eax */
 -	const u32 kvm_cpuid_D_1_eax_x86_features =
 -		F(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | f_xsaves;
 -
 -	/* cpuid 7.0.ecx*/
 -	const u32 kvm_cpuid_7_0_ecx_x86_features = F(PKU) | 0 /*OSPKE*/;
 +	const u32 kvm_supported_word10_x86_features =
 +		F(XSAVEOPT) | F(XSAVEC) | F(XGETBV1);
  
+ 	/* cpuid 7.0.edx*/
+ 	const u32 kvm_cpuid_7_0_edx_x86_features =
+ 		KF(AVX512_4VNNIW) | KF(AVX512_4FMAPS);
+ 
  	/* all calls to cpuid_count() should be made on the same cpu */
  	get_cpu();
  
@@@ -436,15 -459,23 +450,31 @@@
  		entry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;
  		/* Mask ebx against host capability word 9 */
  		if (index == 0) {
 -			entry->ebx &= kvm_cpuid_7_0_ebx_x86_features;
 -			cpuid_mask(&entry->ebx, CPUID_7_0_EBX);
 +			entry->ebx &= kvm_supported_word9_x86_features;
 +			cpuid_mask(&entry->ebx, 9);
  			// TSC_ADJUST is emulated
  			entry->ebx |= F(TSC_ADJUST);
++<<<<<<< HEAD
 +		} else
 +			entry->ebx = 0;
 +		entry->eax = 0;
 +		entry->ecx = 0;
 +		entry->edx = 0;
++=======
+ 			entry->ecx &= kvm_cpuid_7_0_ecx_x86_features;
+ 			cpuid_mask(&entry->ecx, CPUID_7_ECX);
+ 			/* PKU is not yet implemented for shadow paging. */
+ 			if (!tdp_enabled)
+ 				entry->ecx &= ~F(PKU);
+ 			entry->edx &= kvm_cpuid_7_0_edx_x86_features;
+ 			entry->edx &= get_scattered_cpuid_leaf(7, 0, CPUID_EDX);
+ 		} else {
+ 			entry->ebx = 0;
+ 			entry->ecx = 0;
+ 			entry->edx = 0;
+ 		}
+ 		entry->eax = 0;
++>>>>>>> 4504b5c9414c (kvm: x86: Add AVX512_4VNNIW and AVX512_4FMAPS support)
  		break;
  	}
  	case 9:
* Unmerged path arch/x86/kvm/cpuid.c
