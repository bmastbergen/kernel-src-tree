vfio: vfio_register_notifier: classify iommu notifier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jike Song <jike.song@intel.com>
commit 22195cbd3451a75abaf30651a61cf85c89061327
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/22195cbd.failed

Currently vfio_register_notifier assumes that there is only one
notifier chain, which is in vfio_iommu. However, the user might
also be interested in events other than vfio_iommu, for example,
vfio_group. Refactor vfio_{un}register_notifier implementation
to make it feasible.

	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Xiao Guangrong <guangrong.xiao@linux.intel.com>
	Reviewed-by: Kirti Wankhede <kwankhede@nvidia.com>
	Signed-off-by: Jike Song <jike.song@intel.com>
[aw: merge with commit 816ca69ea9c7 ("vfio: Fix handling of error returned by 'vfio_group_get_from_dev()'"), remove typedef]
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
(cherry picked from commit 22195cbd3451a75abaf30651a61cf85c89061327)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vfio/vfio.c
#	drivers/vfio/vfio_iommu_type1.c
#	include/linux/vfio.h
diff --cc drivers/vfio/vfio.c
index 4ed340b370b6,6cc2a9ffac10..000000000000
--- a/drivers/vfio/vfio.c
+++ b/drivers/vfio/vfio.c
@@@ -2015,6 -2008,113 +2015,116 @@@ err_unpin_pages
  }
  EXPORT_SYMBOL(vfio_unpin_pages);
  
++<<<<<<< HEAD
++=======
+ static int vfio_register_iommu_notifier(struct vfio_group *group,
+ 					unsigned long *events,
+ 					struct notifier_block *nb)
+ {
+ 	struct vfio_container *container;
+ 	struct vfio_iommu_driver *driver;
+ 	int ret;
+ 
+ 	ret = vfio_group_add_container_user(group);
+ 	if (ret)
+ 		return -EINVAL;
+ 
+ 	container = group->container;
+ 	down_read(&container->group_lock);
+ 
+ 	driver = container->iommu_driver;
+ 	if (likely(driver && driver->ops->register_notifier))
+ 		ret = driver->ops->register_notifier(container->iommu_data,
+ 						     events, nb);
+ 	else
+ 		ret = -ENOTTY;
+ 
+ 	up_read(&container->group_lock);
+ 	vfio_group_try_dissolve_container(group);
+ 
+ 	return ret;
+ }
+ 
+ static int vfio_unregister_iommu_notifier(struct vfio_group *group,
+ 					  struct notifier_block *nb)
+ {
+ 	struct vfio_container *container;
+ 	struct vfio_iommu_driver *driver;
+ 	int ret;
+ 
+ 	ret = vfio_group_add_container_user(group);
+ 	if (ret)
+ 		return -EINVAL;
+ 
+ 	container = group->container;
+ 	down_read(&container->group_lock);
+ 
+ 	driver = container->iommu_driver;
+ 	if (likely(driver && driver->ops->unregister_notifier))
+ 		ret = driver->ops->unregister_notifier(container->iommu_data,
+ 						       nb);
+ 	else
+ 		ret = -ENOTTY;
+ 
+ 	up_read(&container->group_lock);
+ 	vfio_group_try_dissolve_container(group);
+ 
+ 	return ret;
+ }
+ 
+ int vfio_register_notifier(struct device *dev, enum vfio_notify_type type,
+ 			   unsigned long *events, struct notifier_block *nb)
+ {
+ 	struct vfio_group *group;
+ 	int ret;
+ 
+ 	if (!dev || !nb || !events || (*events == 0))
+ 		return -EINVAL;
+ 
+ 	group = vfio_group_get_from_dev(dev);
+ 	if (!group)
+ 		return -ENODEV;
+ 
+ 	switch (type) {
+ 	case VFIO_IOMMU_NOTIFY:
+ 		ret = vfio_register_iommu_notifier(group, events, nb);
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 	}
+ 
+ 	vfio_group_put(group);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(vfio_register_notifier);
+ 
+ int vfio_unregister_notifier(struct device *dev, enum vfio_notify_type type,
+ 			     struct notifier_block *nb)
+ {
+ 	struct vfio_group *group;
+ 	int ret;
+ 
+ 	if (!dev || !nb)
+ 		return -EINVAL;
+ 
+ 	group = vfio_group_get_from_dev(dev);
+ 	if (!group)
+ 		return -ENODEV;
+ 
+ 	switch (type) {
+ 	case VFIO_IOMMU_NOTIFY:
+ 		ret = vfio_unregister_iommu_notifier(group, nb);
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 	}
+ 
+ 	vfio_group_put(group);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(vfio_unregister_notifier);
+ 
++>>>>>>> 22195cbd3451 (vfio: vfio_register_notifier: classify iommu notifier)
  /**
   * Module/class support
   */
diff --cc drivers/vfio/vfio_iommu_type1.c
index 644eb159cec7,b88ad1e5e7ff..000000000000
--- a/drivers/vfio/vfio_iommu_type1.c
+++ b/drivers/vfio/vfio_iommu_type1.c
@@@ -1520,16 -1583,42 +1520,43 @@@ static long vfio_iommu_type1_ioctl(voi
  	return -ENOTTY;
  }
  
++<<<<<<< HEAD
++=======
+ static int vfio_iommu_type1_register_notifier(void *iommu_data,
+ 					      unsigned long *events,
+ 					      struct notifier_block *nb)
+ {
+ 	struct vfio_iommu *iommu = iommu_data;
+ 
+ 	/* clear known events */
+ 	*events &= ~VFIO_IOMMU_NOTIFY_DMA_UNMAP;
+ 
+ 	/* refuse to register if still events remaining */
+ 	if (*events)
+ 		return -EINVAL;
+ 
+ 	return blocking_notifier_chain_register(&iommu->notifier, nb);
+ }
+ 
+ static int vfio_iommu_type1_unregister_notifier(void *iommu_data,
+ 						struct notifier_block *nb)
+ {
+ 	struct vfio_iommu *iommu = iommu_data;
+ 
+ 	return blocking_notifier_chain_unregister(&iommu->notifier, nb);
+ }
+ 
++>>>>>>> 22195cbd3451 (vfio: vfio_register_notifier: classify iommu notifier)
  static const struct vfio_iommu_driver_ops vfio_iommu_driver_ops_type1 = {
 -	.name			= "vfio-iommu-type1",
 -	.owner			= THIS_MODULE,
 -	.open			= vfio_iommu_type1_open,
 -	.release		= vfio_iommu_type1_release,
 -	.ioctl			= vfio_iommu_type1_ioctl,
 -	.attach_group		= vfio_iommu_type1_attach_group,
 -	.detach_group		= vfio_iommu_type1_detach_group,
 -	.pin_pages		= vfio_iommu_type1_pin_pages,
 -	.unpin_pages		= vfio_iommu_type1_unpin_pages,
 -	.register_notifier	= vfio_iommu_type1_register_notifier,
 -	.unregister_notifier	= vfio_iommu_type1_unregister_notifier,
 +	.name		= "vfio-iommu-type1",
 +	.owner		= THIS_MODULE,
 +	.open		= vfio_iommu_type1_open,
 +	.release	= vfio_iommu_type1_release,
 +	.ioctl		= vfio_iommu_type1_ioctl,
 +	.attach_group	= vfio_iommu_type1_attach_group,
 +	.detach_group	= vfio_iommu_type1_detach_group,
 +	.pin_pages	= vfio_iommu_type1_pin_pages,
 +	.unpin_pages	= vfio_iommu_type1_unpin_pages,
  };
  
  static int __init vfio_iommu_type1_init(void)
diff --cc include/linux/vfio.h
index 6428de7ec03f,0e5201f207d3..000000000000
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@@ -78,6 -80,11 +78,14 @@@ struct vfio_iommu_driver_ops 
  				     unsigned long *phys_pfn);
  	int		(*unpin_pages)(void *iommu_data,
  				       unsigned long *user_pfn, int npage);
++<<<<<<< HEAD
++=======
+ 	int		(*register_notifier)(void *iommu_data,
+ 					     unsigned long *events,
+ 					     struct notifier_block *nb);
+ 	int		(*unregister_notifier)(void *iommu_data,
+ 					       struct notifier_block *nb);
++>>>>>>> 22195cbd3451 (vfio: vfio_register_notifier: classify iommu notifier)
  };
  
  extern int vfio_register_iommu_driver(const struct vfio_iommu_driver_ops *ops);
@@@ -101,6 -108,22 +109,25 @@@ extern int vfio_pin_pages(struct devic
  extern int vfio_unpin_pages(struct device *dev, unsigned long *user_pfn,
  			    int npage);
  
++<<<<<<< HEAD
++=======
+ /* each type has independent events */
+ enum vfio_notify_type {
+ 	VFIO_IOMMU_NOTIFY = 0,
+ };
+ 
+ /* events for VFIO_IOMMU_NOTIFY */
+ #define VFIO_IOMMU_NOTIFY_DMA_UNMAP	BIT(0)
+ 
+ extern int vfio_register_notifier(struct device *dev,
+ 				  enum vfio_notify_type type,
+ 				  unsigned long *required_events,
+ 				  struct notifier_block *nb);
+ extern int vfio_unregister_notifier(struct device *dev,
+ 				    enum vfio_notify_type type,
+ 				    struct notifier_block *nb);
+ 
++>>>>>>> 22195cbd3451 (vfio: vfio_register_notifier: classify iommu notifier)
  /*
   * Sub-module helpers
   */
* Unmerged path drivers/vfio/vfio.c
* Unmerged path drivers/vfio/vfio_iommu_type1.c
* Unmerged path include/linux/vfio.h
