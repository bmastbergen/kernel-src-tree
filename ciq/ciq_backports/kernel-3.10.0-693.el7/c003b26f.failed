mnt: In umount_tree reuse mnt_list instead of mnt_hash

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit c003b26ff98ca04a180ff34c38c007a3998d62f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c003b26f.failed

umount_tree builds a list of mounts that need to be unmounted.
Utilize mnt_list for this purpose instead of mnt_hash.  This begins to
allow keeping a mount on the mnt_hash after it is unmounted, which is
necessary for a properly functioning MNT_LOCKED implementation.

The fact that mnt_list is an ordinary list makding available list_move
is nice bonus.

	Cc: stable@vger.kernel.org
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit c003b26ff98ca04a180ff34c38c007a3998d62f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
#	fs/pnode.c
#	fs/pnode.h
diff --cc fs/namespace.c
index 07e51358b239,54cbef129f4a..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -1217,13 -1330,22 +1217,32 @@@ void umount_tree(struct mount *mnt, in
  	LIST_HEAD(tmp_list);
  	struct mount *p;
  
++<<<<<<< HEAD
 +	for (p = mnt; p; p = next_mnt(p, mnt))
 +		list_move(&p->mnt_hash, &tmp_list);
 +
 +	if (propagate)
 +		propagate_umount(&tmp_list);
 +
 +	list_for_each_entry(p, &tmp_list, mnt_hash) {
++=======
+ 	/* Gather the mounts to umount */
+ 	for (p = mnt; p; p = next_mnt(p, mnt))
+ 		list_move(&p->mnt_list, &tmp_list);
+ 
+ 	/* Hide the mounts from lookup_mnt and mnt_mounts */
+ 	list_for_each_entry(p, &tmp_list, mnt_list) {
+ 		hlist_del_init_rcu(&p->mnt_hash);
+ 		list_del_init(&p->mnt_child);
+ 	}
+ 
+ 	/* Add propogated mounts to the tmp_list */
+ 	if (how & UMOUNT_PROPAGATE)
+ 		propagate_umount(&tmp_list);
+ 
+ 	while (!list_empty(&tmp_list)) {
+ 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
++>>>>>>> c003b26ff98c (mnt: In umount_tree reuse mnt_list instead of mnt_hash)
  		list_del_init(&p->mnt_expire);
  		list_del_init(&p->mnt_list);
  		__touch_mnt_namespace(p->mnt_ns);
diff --cc fs/pnode.c
index 4cba0cce1f85,bf012af709dd..000000000000
--- a/fs/pnode.c
+++ b/fs/pnode.c
@@@ -389,8 -381,11 +389,16 @@@ static void __propagate_umount(struct m
  		 * umount the child only if the child has no
  		 * other children
  		 */
++<<<<<<< HEAD
 +		if (child && list_empty(&child->mnt_mounts))
 +			list_move_tail(&child->mnt_hash, &mnt->mnt_hash);
++=======
+ 		if (child && list_empty(&child->mnt_mounts)) {
+ 			list_del_init(&child->mnt_child);
+ 			hlist_del_init_rcu(&child->mnt_hash);
+ 			list_move_tail(&child->mnt_list, &mnt->mnt_list);
+ 		}
++>>>>>>> c003b26ff98c (mnt: In umount_tree reuse mnt_list instead of mnt_hash)
  	}
  }
  
@@@ -405,7 -400,7 +413,11 @@@ int propagate_umount(struct list_head *
  {
  	struct mount *mnt;
  
++<<<<<<< HEAD
 +	list_for_each_entry(mnt, list, mnt_hash)
++=======
+ 	list_for_each_entry(mnt, list, mnt_list)
++>>>>>>> c003b26ff98c (mnt: In umount_tree reuse mnt_list instead of mnt_hash)
  		__propagate_umount(mnt);
  	return 0;
  }
diff --cc fs/pnode.h
index 65e04f65fa1a,aa6d65df7204..000000000000
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@@ -39,7 -39,7 +39,11 @@@ static inline void set_mnt_shared(struc
  
  void change_mnt_propagation(struct mount *, int);
  int propagate_mnt(struct mount *, struct mountpoint *, struct mount *,
++<<<<<<< HEAD
 +		struct list_head *);
++=======
+ 		struct hlist_head *);
++>>>>>>> c003b26ff98c (mnt: In umount_tree reuse mnt_list instead of mnt_hash)
  int propagate_umount(struct list_head *);
  int propagate_mount_busy(struct mount *, int);
  void mnt_release_group_id(struct mount *);
* Unmerged path fs/namespace.c
* Unmerged path fs/pnode.c
* Unmerged path fs/pnode.h
