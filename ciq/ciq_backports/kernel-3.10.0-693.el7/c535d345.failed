vfio_pci: Update vfio_pci to use vfio_info_add_capability()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Kirti Wankhede <kwankhede@nvidia.com>
commit c535d34569bbc61ebf25a5505ab9eafba057345f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c535d345.failed

Update msix_sparse_mmap_cap() to use vfio_info_add_capability()
Update region type capability to use vfio_info_add_capability()

	Signed-off-by: Kirti Wankhede <kwankhede@nvidia.com>
	Signed-off-by: Neo Jia <cjia@nvidia.com>
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
(cherry picked from commit c535d34569bbc61ebf25a5505ab9eafba057345f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vfio/pci/vfio_pci.c
diff --cc drivers/vfio/pci/vfio_pci.c
index 2a0043c78806,03b5434f4d5b..000000000000
--- a/drivers/vfio/pci/vfio_pci.c
+++ b/drivers/vfio/pci/vfio_pci.c
@@@ -446,6 -555,74 +446,77 @@@ static int vfio_pci_for_each_slot_or_bu
  	return walk.ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int msix_sparse_mmap_cap(struct vfio_pci_device *vdev,
+ 				struct vfio_info_cap *caps)
+ {
+ 	struct vfio_region_info_cap_sparse_mmap *sparse;
+ 	size_t end, size;
+ 	int nr_areas = 2, i = 0, ret;
+ 
+ 	end = pci_resource_len(vdev->pdev, vdev->msix_bar);
+ 
+ 	/* If MSI-X table is aligned to the start or end, only one area */
+ 	if (((vdev->msix_offset & PAGE_MASK) == 0) ||
+ 	    (PAGE_ALIGN(vdev->msix_offset + vdev->msix_size) >= end))
+ 		nr_areas = 1;
+ 
+ 	size = sizeof(*sparse) + (nr_areas * sizeof(*sparse->areas));
+ 
+ 	sparse = kzalloc(size, GFP_KERNEL);
+ 	if (!sparse)
+ 		return -ENOMEM;
+ 
+ 	sparse->nr_areas = nr_areas;
+ 
+ 	if (vdev->msix_offset & PAGE_MASK) {
+ 		sparse->areas[i].offset = 0;
+ 		sparse->areas[i].size = vdev->msix_offset & PAGE_MASK;
+ 		i++;
+ 	}
+ 
+ 	if (PAGE_ALIGN(vdev->msix_offset + vdev->msix_size) < end) {
+ 		sparse->areas[i].offset = PAGE_ALIGN(vdev->msix_offset +
+ 						     vdev->msix_size);
+ 		sparse->areas[i].size = end - sparse->areas[i].offset;
+ 		i++;
+ 	}
+ 
+ 	ret = vfio_info_add_capability(caps, VFIO_REGION_INFO_CAP_SPARSE_MMAP,
+ 				       sparse);
+ 	kfree(sparse);
+ 
+ 	return ret;
+ }
+ 
+ int vfio_pci_register_dev_region(struct vfio_pci_device *vdev,
+ 				 unsigned int type, unsigned int subtype,
+ 				 const struct vfio_pci_regops *ops,
+ 				 size_t size, u32 flags, void *data)
+ {
+ 	struct vfio_pci_region *region;
+ 
+ 	region = krealloc(vdev->region,
+ 			  (vdev->num_regions + 1) * sizeof(*region),
+ 			  GFP_KERNEL);
+ 	if (!region)
+ 		return -ENOMEM;
+ 
+ 	vdev->region = region;
+ 	vdev->region[vdev->num_regions].type = type;
+ 	vdev->region[vdev->num_regions].subtype = subtype;
+ 	vdev->region[vdev->num_regions].ops = ops;
+ 	vdev->region[vdev->num_regions].size = size;
+ 	vdev->region[vdev->num_regions].flags = flags;
+ 	vdev->region[vdev->num_regions].data = data;
+ 
+ 	vdev->num_regions++;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> c535d34569bb (vfio_pci: Update vfio_pci to use vfio_info_add_capability())
  static long vfio_pci_ioctl(void *device_data,
  			   unsigned int cmd, unsigned long arg)
  {
@@@ -543,7 -733,48 +614,52 @@@
  
  			break;
  		default:
++<<<<<<< HEAD
 +			return -EINVAL;
++=======
+ 		{
+ 			struct vfio_region_info_cap_type cap_type;
+ 
+ 			if (info.index >=
+ 			    VFIO_PCI_NUM_REGIONS + vdev->num_regions)
+ 				return -EINVAL;
+ 
+ 			i = info.index - VFIO_PCI_NUM_REGIONS;
+ 
+ 			info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
+ 			info.size = vdev->region[i].size;
+ 			info.flags = vdev->region[i].flags;
+ 
+ 			cap_type.type = vdev->region[i].type;
+ 			cap_type.subtype = vdev->region[i].subtype;
+ 
+ 			ret = vfio_info_add_capability(&caps,
+ 						      VFIO_REGION_INFO_CAP_TYPE,
+ 						      &cap_type);
+ 			if (ret)
+ 				return ret;
+ 
+ 		}
+ 		}
+ 
+ 		if (caps.size) {
+ 			info.flags |= VFIO_REGION_INFO_FLAG_CAPS;
+ 			if (info.argsz < sizeof(info) + caps.size) {
+ 				info.argsz = sizeof(info) + caps.size;
+ 				info.cap_offset = 0;
+ 			} else {
+ 				vfio_info_cap_shift(&caps, sizeof(info));
+ 				if (copy_to_user((void __user *)arg +
+ 						  sizeof(info), caps.buf,
+ 						  caps.size)) {
+ 					kfree(caps.buf);
+ 					return -EFAULT;
+ 				}
+ 				info.cap_offset = sizeof(info);
+ 			}
+ 
+ 			kfree(caps.buf);
++>>>>>>> c535d34569bb (vfio_pci: Update vfio_pci to use vfio_info_add_capability())
  		}
  
  		return copy_to_user((void __user *)arg, &info, minsz) ?
* Unmerged path drivers/vfio/pci/vfio_pci.c
