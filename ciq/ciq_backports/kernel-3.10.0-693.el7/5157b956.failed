SUNRPC: Consolidate xs_tcp_data_ready and xs_data_ready

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 5157b956961d78effd78399e1574b08b9b618422
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5157b956.failed

The only difference between the two at this point is the reset of
the connection timeout, and since everyone expect tcp ignore that value,
we can just throw it into the generic function.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 5157b956961d78effd78399e1574b08b9b618422)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtsock.c
diff --cc net/sunrpc/xprtsock.c
index 90ddaee8ee0a,62b4f5a2a331..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -1086,7 -1088,14 +1086,18 @@@ static void xs_data_ready(struct sock *
  	if (xprt != NULL) {
  		struct sock_xprt *transport = container_of(xprt,
  				struct sock_xprt, xprt);
++<<<<<<< HEAD
 +		queue_work(rpciod_workqueue, &transport->recv_worker);
++=======
+ 		transport->old_data_ready(sk);
+ 		/* Any data means we had a useful conversation, so
+ 		 * then we don't need to delay the next reconnect
+ 		 */
+ 		if (xprt->reestablish_timeout)
+ 			xprt->reestablish_timeout = 0;
+ 		if (!test_and_set_bit(XPRT_SOCK_DATA_READY, &transport->sock_state))
+ 			queue_work(rpciod_workqueue, &transport->recv_worker);
++>>>>>>> 5157b956961d (SUNRPC: Consolidate xs_tcp_data_ready and xs_data_ready)
  	}
  	read_unlock_bh(&sk->sk_callback_lock);
  }
@@@ -1505,34 -1519,6 +1516,37 @@@ static void xs_tcp_data_receive_workfn(
  }
  
  /**
++<<<<<<< HEAD
 + * xs_tcp_data_ready - "data ready" callback for TCP sockets
 + * @sk: socket with data to read
 + *
 + */
 +static void xs_tcp_data_ready(struct sock *sk, int bytes)
 +{
 +	struct sock_xprt *transport;
 +	struct rpc_xprt *xprt;
 +
 +	dprintk("RPC:       xs_tcp_data_ready...\n");
 +
 +	read_lock_bh(&sk->sk_callback_lock);
 +	if (!(xprt = xprt_from_sock(sk)))
 +		goto out;
 +	transport = container_of(xprt, struct sock_xprt, xprt);
 +
 +	/* Any data means we had a useful conversation, so
 +	 * the we don't need to delay the next reconnect
 +	 */
 +	if (xprt->reestablish_timeout)
 +		xprt->reestablish_timeout = 0;
 +	queue_work(rpciod_workqueue, &transport->recv_worker);
 +
 +out:
 +	read_unlock_bh(&sk->sk_callback_lock);
 +}
 +
 +/**
++=======
++>>>>>>> 5157b956961d (SUNRPC: Consolidate xs_tcp_data_ready and xs_data_ready)
   * xs_tcp_state_change - callback to handle TCP socket state changes
   * @sk: socket whose state has changed
   *
* Unmerged path net/sunrpc/xprtsock.c
