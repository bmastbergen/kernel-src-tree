amd-xgbe: Check Rx queue fifos before stopping Rx DMA

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit c3727d61ea73a1df60bacd0b416e01282a94240b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c3727d61.failed

Check to be sure that the Rx queue fifos are empty before stopping the
Rx DMA channels.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c3727d61ea73a1df60bacd0b416e01282a94240b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-common.h
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-common.h
index 3373e9ef2003,bbef95973c27..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-common.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-common.h
@@@ -662,24 -766,24 +662,40 @@@
  #define MTL_Q_TQOMR			0x00
  #define MTL_Q_TQUR			0x04
  #define MTL_Q_TQDR			0x08
 +#define MTL_Q_TCECR			0x10
 +#define MTL_Q_TCESR			0x14
 +#define MTL_Q_TCQWR			0x18
  #define MTL_Q_RQOMR			0x40
  #define MTL_Q_RQMPOCR			0x44
++<<<<<<< HEAD
 +#define MTL_Q_RQDR			0x4c
++=======
+ #define MTL_Q_RQDR			0x48
+ #define MTL_Q_RQFCR			0x50
++>>>>>>> c3727d61ea73 (amd-xgbe: Check Rx queue fifos before stopping Rx DMA)
  #define MTL_Q_IER			0x70
  #define MTL_Q_ISR			0x74
  
  /* MTL queue register entry bit positions and sizes */
++<<<<<<< HEAD
 +#define MTL_Q_TCQWR_QW_INDEX		0
 +#define MTL_Q_TCQWR_QW_WIDTH		21
++=======
+ #define MTL_Q_RQDR_PRXQ_INDEX		16
+ #define MTL_Q_RQDR_PRXQ_WIDTH		14
+ #define MTL_Q_RQDR_RXQSTS_INDEX		4
+ #define MTL_Q_RQDR_RXQSTS_WIDTH		2
+ #define MTL_Q_RQFCR_RFA_INDEX		1
+ #define MTL_Q_RQFCR_RFA_WIDTH		6
+ #define MTL_Q_RQFCR_RFD_INDEX		17
+ #define MTL_Q_RQFCR_RFD_WIDTH		6
++>>>>>>> c3727d61ea73 (amd-xgbe: Check Rx queue fifos before stopping Rx DMA)
  #define MTL_Q_RQOMR_EHFC_INDEX		7
  #define MTL_Q_RQOMR_EHFC_WIDTH		1
 +#define MTL_Q_RQOMR_RFA_INDEX		8
 +#define MTL_Q_RQOMR_RFA_WIDTH		3
 +#define MTL_Q_RQOMR_RFD_INDEX		13
 +#define MTL_Q_RQOMR_RFD_WIDTH		3
  #define MTL_Q_RQOMR_RQS_INDEX		16
  #define MTL_Q_RQOMR_RQS_WIDTH		9
  #define MTL_Q_RQOMR_RSF_INDEX		5
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-common.h
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
index a748fd8a1c58..8f304363e04b 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
@@ -1990,6 +1990,32 @@ static void xgbe_disable_tx(struct xgbe_prv_data *pdata)
 	}
 }
 
+static void xgbe_prepare_rx_stop(struct xgbe_prv_data *pdata,
+				 unsigned int queue)
+{
+	unsigned int rx_status;
+	unsigned long rx_timeout;
+
+	/* The Rx engine cannot be stopped if it is actively processing
+	 * packets. Wait for the Rx queue to empty the Rx fifo.  Don't
+	 * wait forever though...
+	 */
+	rx_timeout = jiffies + (XGBE_DMA_STOP_TIMEOUT * HZ);
+	while (time_before(jiffies, rx_timeout)) {
+		rx_status = XGMAC_MTL_IOREAD(pdata, queue, MTL_Q_RQDR);
+		if ((XGMAC_GET_BITS(rx_status, MTL_Q_RQDR, PRXQ) == 0) &&
+		    (XGMAC_GET_BITS(rx_status, MTL_Q_RQDR, RXQSTS) == 0))
+			break;
+
+		usleep_range(500, 1000);
+	}
+
+	if (!time_before(jiffies, rx_timeout))
+		netdev_info(pdata->netdev,
+			    "timed out waiting for Rx queue %u to empty\n",
+			    queue);
+}
+
 static void xgbe_enable_rx(struct xgbe_prv_data *pdata)
 {
 	struct xgbe_channel *channel;
@@ -2028,6 +2054,10 @@ static void xgbe_disable_rx(struct xgbe_prv_data *pdata)
 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, ACS, 0);
 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, RE, 0);
 
+	/* Prepare for Rx DMA channel stop */
+	for (i = 0; i < pdata->rx_q_count; i++)
+		xgbe_prepare_rx_stop(pdata, i);
+
 	/* Disable each Rx queue */
 	XGMAC_IOWRITE(pdata, MAC_RQC0R, 0);
 
