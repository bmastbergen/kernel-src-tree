bnxt_en: Fix compiler warnings when CONFIG_RFS_ACCEL is not defined.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Fix compiler warnings when CONFIG_RFS_ACCEL is not defined (Jonathan Toppins) [1382378]
Rebuild_FUZZ: 99.26%
commit-author Michael Chan <michael.chan@broadcom.com>
commit b742995445fbac874f5fe19ce2afc76c7a6ac2cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b7429954.failed

CC [M]  drivers/net/ethernet/broadcom/bnxt/bnxt.o
drivers/net/ethernet/broadcom/bnxt/bnxt.c:4947:21: warning: ‘bnxt_get_max_func_rss_ctxs’ defined but not used [-Wunused-function]
 static unsigned int bnxt_get_max_func_rss_ctxs(struct bnxt *bp)
                     ^
  CC [M]  drivers/net/ethernet/broadcom/bnxt/bnxt.o
drivers/net/ethernet/broadcom/bnxt/bnxt.c:4956:21: warning: ‘bnxt_get_max_func_vnics’ defined but not used [-Wunused-function]
 static unsigned int bnxt_get_max_func_vnics(struct bnxt *bp)
                     ^

	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b742995445fbac874f5fe19ce2afc76c7a6ac2cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index f29714ec118c,c0918507fdb4..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -4793,16 -4879,154 +4793,162 @@@ static int bnxt_trim_rings(struct bnxt 
  	return 0;
  }
  
 -static void bnxt_setup_msix(struct bnxt *bp)
 +static int bnxt_setup_msix(struct bnxt *bp)
  {
++<<<<<<< HEAD
++=======
+ 	const int len = sizeof(bp->irq_tbl[0].name);
+ 	struct net_device *dev = bp->dev;
+ 	int tcs, i;
+ 
+ 	tcs = netdev_get_num_tc(dev);
+ 	if (tcs > 1) {
+ 		bp->tx_nr_rings_per_tc = bp->tx_nr_rings / tcs;
+ 		if (bp->tx_nr_rings_per_tc == 0) {
+ 			netdev_reset_tc(dev);
+ 			bp->tx_nr_rings_per_tc = bp->tx_nr_rings;
+ 		} else {
+ 			int i, off, count;
+ 
+ 			bp->tx_nr_rings = bp->tx_nr_rings_per_tc * tcs;
+ 			for (i = 0; i < tcs; i++) {
+ 				count = bp->tx_nr_rings_per_tc;
+ 				off = i * count;
+ 				netdev_set_tc_queue(dev, i, count, off);
+ 			}
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < bp->cp_nr_rings; i++) {
+ 		char *attr;
+ 
+ 		if (bp->flags & BNXT_FLAG_SHARED_RINGS)
+ 			attr = "TxRx";
+ 		else if (i < bp->rx_nr_rings)
+ 			attr = "rx";
+ 		else
+ 			attr = "tx";
+ 
+ 		snprintf(bp->irq_tbl[i].name, len, "%s-%s-%d", dev->name, attr,
+ 			 i);
+ 		bp->irq_tbl[i].handler = bnxt_msix;
+ 	}
+ }
+ 
+ static void bnxt_setup_inta(struct bnxt *bp)
+ {
+ 	const int len = sizeof(bp->irq_tbl[0].name);
+ 
+ 	if (netdev_get_num_tc(bp->dev))
+ 		netdev_reset_tc(bp->dev);
+ 
+ 	snprintf(bp->irq_tbl[0].name, len, "%s-%s-%d", bp->dev->name, "TxRx",
+ 		 0);
+ 	bp->irq_tbl[0].handler = bnxt_inta;
+ }
+ 
+ static int bnxt_setup_int_mode(struct bnxt *bp)
+ {
+ 	int rc;
+ 
+ 	if (bp->flags & BNXT_FLAG_USING_MSIX)
+ 		bnxt_setup_msix(bp);
+ 	else
+ 		bnxt_setup_inta(bp);
+ 
+ 	rc = bnxt_set_real_num_queues(bp);
+ 	return rc;
+ }
+ 
+ #ifdef CONFIG_RFS_ACCEL
+ static unsigned int bnxt_get_max_func_rss_ctxs(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_rsscos_ctxs;
+ #endif
+ 	return bp->pf.max_rsscos_ctxs;
+ }
+ 
+ static unsigned int bnxt_get_max_func_vnics(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_vnics;
+ #endif
+ 	return bp->pf.max_vnics;
+ }
+ #endif
+ 
+ unsigned int bnxt_get_max_func_stat_ctxs(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_stat_ctxs;
+ #endif
+ 	return bp->pf.max_stat_ctxs;
+ }
+ 
+ void bnxt_set_max_func_stat_ctxs(struct bnxt *bp, unsigned int max)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		bp->vf.max_stat_ctxs = max;
+ 	else
+ #endif
+ 		bp->pf.max_stat_ctxs = max;
+ }
+ 
+ unsigned int bnxt_get_max_func_cp_rings(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_cp_rings;
+ #endif
+ 	return bp->pf.max_cp_rings;
+ }
+ 
+ void bnxt_set_max_func_cp_rings(struct bnxt *bp, unsigned int max)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		bp->vf.max_cp_rings = max;
+ 	else
+ #endif
+ 		bp->pf.max_cp_rings = max;
+ }
+ 
+ static unsigned int bnxt_get_max_func_irqs(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_irqs;
+ #endif
+ 	return bp->pf.max_irqs;
+ }
+ 
+ void bnxt_set_max_func_irqs(struct bnxt *bp, unsigned int max_irqs)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		bp->vf.max_irqs = max_irqs;
+ 	else
+ #endif
+ 		bp->pf.max_irqs = max_irqs;
+ }
+ 
+ static int bnxt_init_msix(struct bnxt *bp)
+ {
+ 	int i, total_vecs, rc = 0, min = 1;
++>>>>>>> b742995445fb (bnxt_en: Fix compiler warnings when CONFIG_RFS_ACCEL is not defined.)
  	struct msix_entry *msix_ent;
 +	struct net_device *dev = bp->dev;
 +	int i, total_vecs, rc = 0, min = 1;
 +	const int len = sizeof(bp->irq_tbl[0].name);
 +
 +	bp->flags &= ~BNXT_FLAG_USING_MSIX;
 +	total_vecs = bp->cp_nr_rings;
  
 -	total_vecs = bnxt_get_max_func_irqs(bp);
  	msix_ent = kcalloc(total_vecs, sizeof(struct msix_entry), GFP_KERNEL);
  	if (!msix_ent)
  		return -ENOMEM;
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
