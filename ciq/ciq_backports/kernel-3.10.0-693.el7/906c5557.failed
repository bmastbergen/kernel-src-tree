timekeeping: Copy the shadow-timekeeper over the real timekeeper last

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author John Stultz <john.stultz@linaro.org>
commit 906c55579a6360dd9ef5a3101bb2e3ae396dfb97
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/906c5557.failed

The fix in d151832650ed9 (time: Move clock_was_set_seq update
before updating shadow-timekeeper) was unfortunately incomplete.

The main gist of that change was to do the shadow-copy update
last, so that any state changes were properly duplicated, and
we wouldn't accidentally have stale data in the shadow.

Unfortunately in the main update_wall_time() logic, we update
use the shadow-timekeeper to calculate the next update values,
then while holding the lock, copy the shadow-timekeeper over,
then call timekeeping_update() to do some additional
bookkeeping, (skipping the shadow mirror). The bug with this is
the additional bookkeeping isn't all read-only, and some
changes timkeeper state. Thus we might then overwrite this state
change on the next update.

To avoid this problem, do the timekeeping_update() on the
shadow-timekeeper prior to copying the full state over to
the real-timekeeper.

This avoids problems with both the clock_was_set_seq and
next_leap_ktime being overwritten and possibly the
fast-timekeepers as well.

Many thanks to Prarit for his rigorous testing, which discovered
this problem, along with Prarit and Daniel's work validating this
fix.

	Reported-by: Prarit Bhargava <prarit@redhat.com>
	Tested-by: Prarit Bhargava <prarit@redhat.com>
	Tested-by: Daniel Bristot de Oliveira <bristot@redhat.com>
	Signed-off-by: John Stultz <john.stultz@linaro.org>
	Cc: Richard Cochran <richardcochran@gmail.com>
	Cc: Jan Kara <jack@suse.cz>
	Cc: Jiri Bohac <jbohac@suse.cz>
	Cc: Ingo Molnar <mingo@kernel.org>
Link: http://lkml.kernel.org/r/1434560753-7441-1-git-send-email-john.stultz@linaro.org
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 906c55579a6360dd9ef5a3101bb2e3ae396dfb97)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/timekeeping.c
diff --cc kernel/time/timekeeping.c
index 1f122214a691,30b7a409bf1e..000000000000
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@@ -1736,12 -1850,13 +1736,18 @@@ void update_wall_time(void
  	 * requires changes to all other timekeeper usage sites as
  	 * well, i.e. move the timekeeper pointer getter into the
  	 * spinlocked/seqcount protected sections. And we trade this
 -	 * memcpy under the tk_core.seq against one before we start
 +	 * memcpy under the timekeeper_seq against one before we start
  	 * updating.
  	 */
+ 	timekeeping_update(tk, clock_set);
  	memcpy(real_tk, tk, sizeof(*tk));
++<<<<<<< HEAD
 +	timekeeping_update(real_tk, clock_set);
 +	write_seqcount_end(&timekeeper_seq);
++=======
+ 	/* The memcpy must come last. Do not put anything here! */
+ 	write_seqcount_end(&tk_core.seq);
++>>>>>>> 906c55579a63 (timekeeping: Copy the shadow-timekeeper over the real timekeeper last)
  out:
  	raw_spin_unlock_irqrestore(&timekeeper_lock, flags);
  	if (clock_set)
* Unmerged path kernel/time/timekeeping.c
