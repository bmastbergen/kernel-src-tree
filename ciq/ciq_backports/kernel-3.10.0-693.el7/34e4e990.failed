net/mlx5: Enable to query min inline for a specific vport

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [kernel] mlx5: Enable to query min inline for a specific vport (Don Dutile) [1385330 1417286]
Rebuild_FUZZ: 96.36%
commit-author Roi Dayan <roid@mellanox.com>
commit 34e4e99078667d30f71a50c1e5181e4270e9d8bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/34e4e990.failed

Also move the inline capablities enum to a shared header vport.h

	Signed-off-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 34e4e99078667d30f71a50c1e5181e4270e9d8bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/vport.c
#	include/linux/mlx5/vport.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 01fb0755be57,19403d6bf369..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -619,6 -956,9 +619,12 @@@ static int mlx5e_create_sq(struct mlx5e
  	}
  	sq->bf_buf_size = (1 << MLX5_CAP_GEN(mdev, log_bf_reg_size)) / 2;
  	sq->max_inline  = param->max_inline;
++<<<<<<< HEAD
++=======
+ 	sq->min_inline_mode =
+ 		MLX5_CAP_ETH(mdev, wqe_inline_mode) == MLX5_CAP_INLINE_MODE_VPORT_CONTEXT ?
+ 		param->min_inline_mode : 0;
++>>>>>>> 34e4e9907866 (net/mlx5: Enable to query min inline for a specific vport)
  
  	err = mlx5e_alloc_sq_db(sq, cpu_to_node(c->cpu));
  	if (err)
@@@ -2743,9 -3413,38 +2749,44 @@@ void mlx5e_set_rx_cq_mode_params(struc
  			MLX5E_PARAMS_DEFAULT_RX_CQ_MODERATION_USEC_FROM_CQE;
  }
  
++<<<<<<< HEAD
 +static void mlx5e_build_netdev_priv(struct mlx5_core_dev *mdev,
 +				    struct net_device *netdev,
 +				    int num_channels)
++=======
+ static void mlx5e_query_min_inline(struct mlx5_core_dev *mdev,
+ 				   u8 *min_inline_mode)
+ {
+ 	switch (MLX5_CAP_ETH(mdev, wqe_inline_mode)) {
+ 	case MLX5_CAP_INLINE_MODE_L2:
+ 		*min_inline_mode = MLX5_INLINE_MODE_L2;
+ 		break;
+ 	case MLX5_CAP_INLINE_MODE_VPORT_CONTEXT:
+ 		mlx5_query_nic_vport_min_inline(mdev, 0, min_inline_mode);
+ 		break;
+ 	case MLX5_CAP_INLINE_MODE_NOT_REQUIRED:
+ 		*min_inline_mode = MLX5_INLINE_MODE_NONE;
+ 		break;
+ 	}
+ }
+ 
+ u32 mlx5e_choose_lro_timeout(struct mlx5_core_dev *mdev, u32 wanted_timeout)
+ {
+ 	int i;
+ 
+ 	/* The supported periods are organized in ascending order */
+ 	for (i = 0; i < MLX5E_LRO_TIMEOUT_ARR_SIZE - 1; i++)
+ 		if (MLX5_CAP_ETH(mdev, lro_timer_supported_periods[i]) >= wanted_timeout)
+ 			break;
+ 
+ 	return MLX5_CAP_ETH(mdev, lro_timer_supported_periods[i]);
+ }
+ 
+ static void mlx5e_build_nic_netdev_priv(struct mlx5_core_dev *mdev,
+ 					struct net_device *netdev,
+ 					const struct mlx5e_profile *profile,
+ 					void *ppriv)
++>>>>>>> 34e4e9907866 (net/mlx5: Enable to query min inline for a specific vport)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
  	u32 link_speed = 0;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/vport.c
index 4908639947c4,269e4401c342..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/vport.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vport.c
@@@ -130,9 -110,41 +130,44 @@@ static int mlx5_modify_nic_vport_contex
  
  	MLX5_SET(modify_nic_vport_context_in, in, opcode,
  		 MLX5_CMD_OP_MODIFY_NIC_VPORT_CONTEXT);
 -	return mlx5_cmd_exec(mdev, in, inlen, out, sizeof(out));
 -}
  
++<<<<<<< HEAD
 +	memset(out, 0, sizeof(out));
 +	return mlx5_cmd_exec_check_status(mdev, in, inlen, out, sizeof(out));
++=======
+ int mlx5_query_nic_vport_min_inline(struct mlx5_core_dev *mdev,
+ 				    u16 vport, u8 *min_inline)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(query_nic_vport_context_out)] = {0};
+ 	int err;
+ 
+ 	err = mlx5_query_nic_vport_context(mdev, vport, out, sizeof(out));
+ 	if (!err)
+ 		*min_inline = MLX5_GET(query_nic_vport_context_out, out,
+ 				       nic_vport_context.min_wqe_inline_mode);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mlx5_query_nic_vport_min_inline);
+ 
+ int mlx5_modify_nic_vport_min_inline(struct mlx5_core_dev *mdev,
+ 				     u16 vport, u8 min_inline)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(modify_nic_vport_context_in)] = {0};
+ 	int inlen = MLX5_ST_SZ_BYTES(modify_nic_vport_context_in);
+ 	void *nic_vport_ctx;
+ 
+ 	MLX5_SET(modify_nic_vport_context_in, in,
+ 		 field_select.min_inline, 1);
+ 	MLX5_SET(modify_nic_vport_context_in, in, vport_number, vport);
+ 	MLX5_SET(modify_nic_vport_context_in, in, other_vport, 1);
+ 
+ 	nic_vport_ctx = MLX5_ADDR_OF(modify_nic_vport_context_in,
+ 				     in, nic_vport_context);
+ 	MLX5_SET(nic_vport_context, nic_vport_ctx,
+ 		 min_wqe_inline_mode, min_inline);
+ 
+ 	return mlx5_modify_nic_vport_context(mdev, in, inlen);
++>>>>>>> 34e4e9907866 (net/mlx5: Enable to query min inline for a specific vport)
  }
  
  int mlx5_query_nic_vport_mac_address(struct mlx5_core_dev *mdev,
diff --cc include/linux/mlx5/vport.h
index 6c16c198f680,ec35157ea725..000000000000
--- a/include/linux/mlx5/vport.h
+++ b/include/linux/mlx5/vport.h
@@@ -43,6 -49,10 +49,13 @@@ int mlx5_modify_vport_admin_state(struc
  				  u16 vport, u8 state);
  int mlx5_query_nic_vport_mac_address(struct mlx5_core_dev *mdev,
  				     u16 vport, u8 *addr);
++<<<<<<< HEAD
++=======
+ int mlx5_query_nic_vport_min_inline(struct mlx5_core_dev *mdev,
+ 				    u16 vport, u8 *min_inline);
+ int mlx5_modify_nic_vport_min_inline(struct mlx5_core_dev *mdev,
+ 				     u16 vport, u8 min_inline);
++>>>>>>> 34e4e9907866 (net/mlx5: Enable to query min inline for a specific vport)
  int mlx5_modify_nic_vport_mac_address(struct mlx5_core_dev *dev,
  				      u16 vport, u8 *addr);
  int mlx5_query_nic_vport_mtu(struct mlx5_core_dev *mdev, u16 *mtu);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/vport.c
* Unmerged path include/linux/mlx5/vport.h
