HID: wacom: Slim down wacom_intuos_pad processing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Slim down wacom_intuos_pad processing (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 94.62%
commit-author Jason Gerecke <killertofu@gmail.com>
commit c7f0522a1ad1c2a1a23872c96955d60890f453e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c7f0522a.failed

Seperate the function into two halves: first gather data from the packet,
next report all gathered data. The input subsystem should automatically
mute any events that aren't actually declared for the tablet at hand.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit c7f0522a1ad1c2a1a23872c96955d60890f453e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index bdf17efa93aa,ec1e13e55ae9..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -34,6 -34,41 +34,44 @@@
   */
  #define WACOM_CONTACT_AREA_SCALE 2607
  
++<<<<<<< HEAD
++=======
+ static void wacom_report_numbered_buttons(struct input_dev *input_dev,
+ 				int button_count, int mask);
+ 
+ /*
+  * Percent of battery capacity for Graphire.
+  * 8th value means AC online and show 100% capacity.
+  */
+ static unsigned short batcap_gr[8] = { 1, 15, 25, 35, 50, 70, 100, 100 };
+ 
+ /*
+  * Percent of battery capacity for Intuos4 WL, AC has a separate bit.
+  */
+ static unsigned short batcap_i4[8] = { 1, 15, 30, 45, 60, 70, 85, 100 };
+ 
+ static void wacom_notify_battery(struct wacom_wac *wacom_wac,
+ 	int bat_capacity, bool bat_charging, bool bat_connected,
+ 	bool ps_connected)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	bool changed = wacom_wac->battery_capacity != bat_capacity  ||
+ 		       wacom_wac->bat_charging     != bat_charging  ||
+ 		       wacom_wac->bat_connected    != bat_connected ||
+ 		       wacom_wac->ps_connected     != ps_connected;
+ 
+ 	if (changed) {
+ 		wacom_wac->battery_capacity = bat_capacity;
+ 		wacom_wac->bat_charging = bat_charging;
+ 		wacom_wac->bat_connected = bat_connected;
+ 		wacom_wac->ps_connected = ps_connected;
+ 
+ 		if (wacom->battery)
+ 			power_supply_changed(wacom->battery);
+ 	}
+ }
+ 
++>>>>>>> c7f0522a1ad1 (HID: wacom: Slim down wacom_intuos_pad processing)
  static int wacom_penpartner_irq(struct wacom_wac *wacom)
  {
  	unsigned char *data = wacom->data;
@@@ -308,6 -436,141 +346,144 @@@ exit
  	return retval;
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_intuos_schedule_prox_event(struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	struct hid_report *r;
+ 	struct hid_report_enum *re;
+ 
+ 	re = &(wacom->hdev->report_enum[HID_FEATURE_REPORT]);
+ 	r = re->report_id_hash[WACOM_REPORT_INTUOSREAD];
+ 	if (r) {
+ 		hid_hw_request(wacom->hdev, r, HID_REQ_GET_REPORT);
+ 	}
+ }
+ 
+ static int wacom_intuos_pad(struct wacom_wac *wacom)
+ {
+ 	struct wacom_features *features = &wacom->features;
+ 	unsigned char *data = wacom->data;
+ 	struct input_dev *input = wacom->pad_input;
+ 	int i;
+ 	int buttons = 0, nbuttons = features->numbered_buttons;
+ 	int keys = 0, nkeys = 0;
+ 	int ring1 = 0, ring2 = 0;
+ 	int strip1 = 0, strip2 = 0;
+ 	bool prox = false;
+ 
+ 	/* pad packets. Works as a second tool and is always in prox */
+ 	if (!(data[0] == WACOM_REPORT_INTUOSPAD || data[0] == WACOM_REPORT_INTUOS5PAD ||
+ 	      data[0] == WACOM_REPORT_CINTIQPAD))
+ 		return 0;
+ 
+ 	if (features->type >= INTUOS4S && features->type <= INTUOS4L) {
+ 		buttons = (data[3] << 1) | (data[2] & 0x01);
+ 		ring1 = data[1];
+ 	} else if (features->type == DTK) {
+ 		buttons = data[6];
+ 	} else if (features->type == WACOM_13HD) {
+ 		buttons = (data[4] << 1) | (data[3] & 0x01);
+ 	} else if (features->type == WACOM_24HD) {
+ 		buttons = (data[8] << 8) | data[6];
+ 		ring1 = data[1];
+ 		ring2 = data[2];
+ 
+ 		/*
+ 		 * Three "buttons" are available on the 24HD which are
+ 		 * physically implemented as a touchstrip. Each button
+ 		 * is approximately 3 bits wide with a 2 bit spacing.
+ 		 * The raw touchstrip bits are stored at:
+ 		 *    ((data[3] & 0x1f) << 8) | data[4])
+ 		 */
+ 		nkeys = 3;
+ 		keys = ((data[3] & 0x1C) ? 1<<2 : 0) |
+ 		       ((data[4] & 0xE0) ? 1<<1 : 0) |
+ 		       ((data[4] & 0x07) ? 1<<0 : 0);
+ 	} else if (features->type == WACOM_27QHD) {
+ 		nkeys = 3;
+ 		keys = data[2] & 0x07;
+ 
+ 		input_report_abs(input, ABS_X, be16_to_cpup((__be16 *)&data[4]));
+ 		input_report_abs(input, ABS_Y, be16_to_cpup((__be16 *)&data[6]));
+ 		input_report_abs(input, ABS_Z, be16_to_cpup((__be16 *)&data[8]));
+ 	} else if (features->type == CINTIQ_HYBRID) {
+ 		/*
+ 		 * Do not send hardware buttons under Android. They
+ 		 * are already sent to the system through GPIO (and
+ 		 * have different meaning).
+ 		 *
+ 		 * d-pad right  -> data[4] & 0x10
+ 		 * d-pad up     -> data[4] & 0x20
+ 		 * d-pad left   -> data[4] & 0x40
+ 		 * d-pad down   -> data[4] & 0x80
+ 		 * d-pad center -> data[3] & 0x01
+ 		 */
+ 		buttons = (data[4] << 1) | (data[3] & 0x01);
+ 	} else if (features->type == CINTIQ_COMPANION_2) {
+ 		/* d-pad right  -> data[4] & 0x10
+ 		 * d-pad up     -> data[4] & 0x20
+ 		 * d-pad left   -> data[4] & 0x40
+ 		 * d-pad down   -> data[4] & 0x80
+ 		 * d-pad center -> data[3] & 0x01
+ 		 */
+ 		buttons = ((data[2] & 0xF0) << 7) |
+ 		          ((data[1] & 0x04) << 6) |
+ 		          ((data[2] & 0x0F) << 2) |
+ 		          (data[1] & 0x03);
+ 	} else if (features->type >= INTUOS5S && features->type <= INTUOSPL) {
+ 		/*
+ 		 * ExpressKeys on Intuos5/Intuos Pro have a capacitive sensor in
+ 		 * addition to the mechanical switch. Switch data is
+ 		 * stored in data[4], capacitive data in data[5].
+ 		 *
+ 		 * Touch ring mode switch (data[3]) has no capacitive sensor
+ 		 */
+ 		buttons = (data[4] << 1) | (data[3] & 0x01);
+ 		ring1 = data[2];
+ 	} else {
+ 		if (features->type == WACOM_21UX2 || features->type == WACOM_22HD) {
+ 			buttons = (data[8] << 10) | ((data[7] & 0x01) << 9) |
+ 			          (data[6] << 1) | (data[5] & 0x01);
+ 
+ 			if (features->type == WACOM_22HD) {
+ 				nkeys = 3;
+ 				keys = data[9] & 0x07;
+ 			}
+ 		} else {
+ 			buttons = ((data[6] & 0x10) << 10) |
+ 			          ((data[5] & 0x10) << 9)  |
+ 			          ((data[6] & 0x0F) << 4)  |
+ 			          (data[5] & 0x0F);
+ 		}
+ 		strip1 = (data[1] << 8) || data[2];
+ 		strip2 = (data[3] << 8) || data[4];
+ 	}
+ 
+ 	prox = (buttons & ~(~0 << nbuttons)) || (keys & ~(~0 << nkeys)) ||
+ 	       (ring1 & 0x80) || (ring2 & 0x80) || strip1 || strip2;
+ 
+ 	wacom_report_numbered_buttons(input, nbuttons, buttons);
+ 
+ 	for (i = 0; i < nkeys; i++)
+ 		input_report_key(input, KEY_PROG1 + i, keys & (1 << i));
+ 
+ 	input_report_abs(input, ABS_RX, strip1);
+ 	input_report_abs(input, ABS_RX, strip2);
+ 
+ 	input_report_abs(input, ABS_WHEEL,    ring1 & 0x7f ? ring1 : 0);
+ 	input_report_abs(input, ABS_THROTTLE, ring2 & 0x07 ? ring2 : 0);
+ 
+ 	input_report_key(input, wacom->tool[1], prox ? 1 : 0);
+ 	input_report_abs(input, ABS_MISC, prox ? PAD_DEVICE_ID : 0);
+ 
+ 	input_event(input, EV_MSC, MSC_SERIAL, 0xffffffff);
+ 
+ 	return 1;
+ }
+ 
++>>>>>>> c7f0522a1ad1 (HID: wacom: Slim down wacom_intuos_pad processing)
  static int wacom_intuos_inout(struct wacom_wac *wacom)
  {
  	struct wacom_features *features = &wacom->features;
@@@ -1826,10 -2576,281 +2002,284 @@@ int wacom_setup_input_capabilities(stru
  			__set_bit(BTN_STYLUS, input_dev->keybit);
  			__set_bit(BTN_STYLUS2, input_dev->keybit);
  			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 -				      features->distance_max,
 -				      0, 0);
 +					      features->distance_max,
 +					      0, 0);
  		}
  		break;
++<<<<<<< HEAD
++=======
+ 	case BAMBOO_PAD:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
+ 					 struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_TOUCH))
+ 		return -ENODEV;
+ 
+ 	if (features->type == HID_GENERIC)
+ 		/* setup has already been done */
+ 		return 0;
+ 
+ 	__set_bit(BTN_TOUCH, input_dev->keybit);
+ 
+ 	if (features->touch_max == 1) {
+ 		input_set_abs_params(input_dev, ABS_X, 0,
+ 			features->x_max, features->x_fuzz, 0);
+ 		input_set_abs_params(input_dev, ABS_Y, 0,
+ 			features->y_max, features->y_fuzz, 0);
+ 		input_abs_set_res(input_dev, ABS_X,
+ 				  features->x_resolution);
+ 		input_abs_set_res(input_dev, ABS_Y,
+ 				  features->y_resolution);
+ 	}
+ 	else if (features->touch_max > 1) {
+ 		input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+ 			features->x_max, features->x_fuzz, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+ 			features->y_max, features->y_fuzz, 0);
+ 		input_abs_set_res(input_dev, ABS_MT_POSITION_X,
+ 				  features->x_resolution);
+ 		input_abs_set_res(input_dev, ABS_MT_POSITION_Y,
+ 				  features->y_resolution);
+ 	}
+ 
+ 	switch (features->type) {
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, features->y_max, 0, 0);
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		break;
+ 
+ 	case WACOM_24HDT:
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
+ 		/* fall through */
+ 
+ 	case WACOM_27QHDT:
+ 	case MTSCREEN:
+ 	case MTTPC:
+ 	case MTTPC_B:
+ 	case TABLETPC2FG:
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);
+ 		/*fall through */
+ 
+ 	case TABLETPC:
+ 	case TABLETPCE:
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 	case INTUOSHT2:
+ 		input_dev->evbit[0] |= BIT_MASK(EV_SW);
+ 		__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
+ 		/* fall through */
+ 
+ 	case BAMBOO_PT:
+ 	case BAMBOO_TOUCH:
+ 		if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 			input_set_abs_params(input_dev,
+ 				     ABS_MT_TOUCH_MAJOR,
+ 				     0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev,
+ 				     ABS_MT_TOUCH_MINOR,
+ 				     0, features->y_max, 0, 0);
+ 		}
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		break;
+ 
+ 	case BAMBOO_PAD:
+ 		input_mt_init_slots(input_dev, features->touch_max,
+ 				    INPUT_MT_POINTER);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static void wacom_setup_numbered_buttons(struct input_dev *input_dev,
+ 				int button_count)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < button_count && i < 10; i++)
+ 		__set_bit(BTN_0 + i, input_dev->keybit);
+ 	for (i = 10; i < button_count && i < 16; i++)
+ 		__set_bit(BTN_A + (i-10), input_dev->keybit);
+ 	for (i = 16; i < button_count && i < 18; i++)
+ 		__set_bit(BTN_BASE + (i-16), input_dev->keybit);
+ }
+ 
+ static void wacom_report_numbered_buttons(struct input_dev *input_dev,
+ 				int button_count, int mask)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < button_count && i < 10; i++)
+ 		input_report_key(input_dev, BTN_0 + i, mask & (1 << i));
+ 	for (i = 10; i < button_count && i < 16; i++)
+ 		input_report_key(input_dev, BTN_A + (i-10), mask & (1 << i));
+ 	for (i = 16; i < button_count && i < 18; i++)
+ 		input_report_key(input_dev, BTN_BASE + (i-16), mask & (1 << i));
+ }
+ 
+ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_PAD))
+ 		return -ENODEV;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	/* kept for making legacy xf86-input-wacom working with the wheels */
+ 	__set_bit(ABS_MISC, input_dev->absbit);
+ 
+ 	/* kept for making legacy xf86-input-wacom accepting the pad */
+ 	input_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);
+ 
+ 	/* kept for making udev and libwacom accepting the pad */
+ 	__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 	wacom_setup_numbered_buttons(input_dev, features->numbered_buttons);
+ 
+ 	switch (features->type) {
+ 
+ 	case CINTIQ_HYBRID:
+ 	case CINTIQ_COMPANION_2:
+ 	case DTK:
+ 	case DTUS:
+ 	case GRAPHIRE_BT:
+ 		break;
+ 
+ 	case WACOM_MO:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_G4:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
+ 		break;
+ 
+ 	case WACOM_24HD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_THROTTLE, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_27QHD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_X, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_X, 1024); /* points/g */
+ 		input_set_abs_params(input_dev, ABS_Y, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Y, 1024);
+ 		input_set_abs_params(input_dev, ABS_Z, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 1024);
+ 		__set_bit(INPUT_PROP_ACCELEROMETER, input_dev->propbit);
+ 		break;
+ 
+ 	case WACOM_22HD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case WACOM_21UX2:
+ 	case WACOM_BEE:
+ 	case CINTIQ:
+ 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
+ 		break;
+ 
+ 	case WACOM_13HD:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOS3:
+ 	case INTUOS3L:
+ 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
+ 		/* fall through */
+ 
+ 	case INTUOS3S:
+ 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
+ 		break;
+ 
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOS4WL:
+ 		/*
+ 		 * For Bluetooth devices, the udev rule does not work correctly
+ 		 * for pads unless we add a stylus capability, which forces
+ 		 * ID_INPUT_TABLET to be set.
+ 		 */
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case INTUOS4:
+ 	case INTUOS4L:
+ 	case INTUOS4S:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 	case BAMBOO_PT:
+ 	case BAMBOO_TOUCH:
+ 	case INTUOSHT2:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 
+ 		break;
+ 
+ 	case REMOTE:
+ 		input_set_capability(input_dev, EV_MSC, MSC_SERIAL);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	default:
+ 		/* no pad supported */
+ 		return -ENODEV;
++>>>>>>> c7f0522a1ad1 (HID: wacom: Slim down wacom_intuos_pad processing)
  	}
  	return 0;
  }
* Unmerged path drivers/hid/wacom_wac.c
