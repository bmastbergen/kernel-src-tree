x86/cpuid: Provide get_scattered_cpuid_leaf()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] cpuid: Provide get_scattered_cpuid_leaf() (Paul Lai) [1382116]
Rebuild_FUZZ: 95.35%
commit-author He Chen <he.chen@linux.intel.com>
commit 47bdf3378d62a627cfb8a54e1180c08d67078b61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/47bdf337.failed

Sparse populated CPUID leafs are collected in a software provided leaf to
avoid bloat of the x86_capability array, but there is no way to rebuild the
real leafs (e.g. for KVM CPUID enumeration) other than rereading the CPUID
leaf from the CPU. While this is possible it is problematic as it does not
take software disabled features into account. If a feature is disabled on
the host it should not be exposed to a guest either.

Add get_scattered_cpuid_leaf() which rebuilds the leaf from the scattered
cpuid table information and the active CPU features.

[ tglx: Rewrote changelog ]

	Signed-off-by: He Chen <he.chen@linux.intel.com>
	Reviewed-by: Borislav Petkov <bp@suse.de>
	Cc: Luwei Kang <luwei.kang@intel.com>
	Cc: kvm@vger.kernel.org
	Cc: Radim Krčmář <rkrcmar@redhat.com>
	Cc: Piotr Luc <Piotr.Luc@intel.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
Link: http://lkml.kernel.org/r/1478856336-9388-3-git-send-email-he.chen@linux.intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 47bdf3378d62a627cfb8a54e1180c08d67078b61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/scattered.c
diff --cc arch/x86/kernel/cpu/scattered.c
index 21e9c42c84be,d1316f9c8329..000000000000
--- a/arch/x86/kernel/cpu/scattered.c
+++ b/arch/x86/kernel/cpu/scattered.c
@@@ -17,11 -17,17 +17,25 @@@ struct cpuid_bit 
  	u32 sub_leaf;
  };
  
++<<<<<<< HEAD
 +enum cpuid_regs {
 +	CR_EAX = 0,
 +	CR_ECX,
 +	CR_EDX,
 +	CR_EBX
++=======
+ /* Please keep the leaf sorted by cpuid_bit.level for faster search. */
+ static const struct cpuid_bit cpuid_bits[] = {
+ 	{ X86_FEATURE_APERFMPERF,       CPUID_ECX,  0, 0x00000006, 0 },
+ 	{ X86_FEATURE_EPB,              CPUID_ECX,  3, 0x00000006, 0 },
+ 	{ X86_FEATURE_INTEL_PT,         CPUID_EBX, 25, 0x00000007, 0 },
+ 	{ X86_FEATURE_AVX512_4VNNIW,    CPUID_EDX,  2, 0x00000007, 0 },
+ 	{ X86_FEATURE_AVX512_4FMAPS,    CPUID_EDX,  3, 0x00000007, 0 },
+ 	{ X86_FEATURE_HW_PSTATE,        CPUID_EDX,  7, 0x80000007, 0 },
+ 	{ X86_FEATURE_CPB,              CPUID_EDX,  9, 0x80000007, 0 },
+ 	{ X86_FEATURE_PROC_FEEDBACK,    CPUID_EDX, 11, 0x80000007, 0 },
+ 	{ 0, 0, 0, 0, 0 }
++>>>>>>> 47bdf3378d62 (x86/cpuid: Provide get_scattered_cpuid_leaf())
  };
  
  void init_scattered_cpuid_features(struct cpuinfo_x86 *c)
@@@ -30,36 -36,6 +44,39 @@@
  	u32 regs[4];
  	const struct cpuid_bit *cb;
  
++<<<<<<< HEAD
 +	static const struct cpuid_bit cpuid_bits[] = {
 +		{ X86_FEATURE_DTHERM,		CR_EAX, 0, 0x00000006, 0 },
 +		{ X86_FEATURE_IDA,		CR_EAX, 1, 0x00000006, 0 },
 +		{ X86_FEATURE_ARAT,		CR_EAX, 2, 0x00000006, 0 },
 +		{ X86_FEATURE_PLN,		CR_EAX, 4, 0x00000006, 0 },
 +		{ X86_FEATURE_PTS,		CR_EAX, 6, 0x00000006, 0 },
 +		{ X86_FEATURE_HWP,		CR_EAX, 7, 0x00000006, 0 },
 +		{ X86_FEATURE_HWP_NOITFY,	CR_EAX, 8, 0x00000006, 0 },
 +		{ X86_FEATURE_HWP_ACT_WINDOW,	CR_EAX, 9, 0x00000006, 0 },
 +		{ X86_FEATURE_HWP_EPP,		CR_EAX,10, 0x00000006, 0 },
 +		{ X86_FEATURE_HWP_PKG_REQ,	CR_EAX,11, 0x00000006, 0 },
 +		{ X86_FEATURE_INTEL_PT,		CR_EBX,25, 0x00000007, 0 },
 +		{ X86_FEATURE_APERFMPERF,	CR_ECX, 0, 0x00000006, 0 },
 +		{ X86_FEATURE_EPB,		CR_ECX, 3, 0x00000006, 0 },
 +		{ X86_FEATURE_HW_PSTATE,	CR_EDX, 7, 0x80000007, 0 },
 +		{ X86_FEATURE_CPB,		CR_EDX, 9, 0x80000007, 0 },
 +		{ X86_FEATURE_PROC_FEEDBACK,	CR_EDX,11, 0x80000007, 0 },
 +		{ X86_FEATURE_NPT,		CR_EDX, 0, 0x8000000a, 0 },
 +		{ X86_FEATURE_LBRV,		CR_EDX, 1, 0x8000000a, 0 },
 +		{ X86_FEATURE_SVML,		CR_EDX, 2, 0x8000000a, 0 },
 +		{ X86_FEATURE_NRIPS,		CR_EDX, 3, 0x8000000a, 0 },
 +		{ X86_FEATURE_TSCRATEMSR,	CR_EDX, 4, 0x8000000a, 0 },
 +		{ X86_FEATURE_VMCBCLEAN,	CR_EDX, 5, 0x8000000a, 0 },
 +		{ X86_FEATURE_FLUSHBYASID,	CR_EDX, 6, 0x8000000a, 0 },
 +		{ X86_FEATURE_DECODEASSISTS,	CR_EDX, 7, 0x8000000a, 0 },
 +		{ X86_FEATURE_PAUSEFILTER,	CR_EDX,10, 0x8000000a, 0 },
 +		{ X86_FEATURE_PFTHRESHOLD,	CR_EDX,12, 0x8000000a, 0 },
 +		{ 0, 0, 0, 0, 0 }
 +	};
 +
++=======
++>>>>>>> 47bdf3378d62 (x86/cpuid: Provide get_scattered_cpuid_leaf())
  	for (cb = cpuid_bits; cb->feature; cb++) {
  
  		/* Verify that the level is valid */
diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h
index b43e343ac07a..d60f07e343ff 100644
--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -184,6 +184,9 @@ extern void identify_secondary_cpu(struct cpuinfo_x86 *);
 extern void print_cpu_info(struct cpuinfo_x86 *);
 void print_cpu_msr(struct cpuinfo_x86 *);
 extern void init_scattered_cpuid_features(struct cpuinfo_x86 *c);
+extern u32 get_scattered_cpuid_leaf(unsigned int level,
+				    unsigned int sub_leaf,
+				    enum cpuid_regs_idx reg);
 extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c);
 extern void init_amd_cacheinfo(struct cpuinfo_x86 *c);
 
* Unmerged path arch/x86/kernel/cpu/scattered.c
