crypto: sha1-mb - async implementation for sha1-mb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] sha1-mb - async implementation for sha1-mb (Herbert Xu) [1379518]
Rebuild_FUZZ: 91.30%
commit-author Megha Dey <megha.dey@linux.intel.com>
commit 331bf739c4f9992a73547d20bd8f2378b97d386a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/331bf739.failed

Herbert wants the sha1-mb algorithm to have an async implementation:
https://lkml.org/lkml/2016/4/5/286.
Currently, sha1-mb uses an async interface for the outer algorithm
and a sync interface for the inner algorithm. This patch introduces
a async interface for even the inner algorithm.

	Signed-off-by: Megha Dey <megha.dey@linux.intel.com>
	Signed-off-by: Tim Chen <tim.c.chen@linux.intel.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 331bf739c4f9992a73547d20bd8f2378b97d386a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/crypto/sha-mb/sha1_mb.c
#	crypto/mcryptd.c
diff --cc arch/x86/crypto/sha-mb/sha1_mb.c
index 65c30b6b7400,669cc37268e1..000000000000
--- a/arch/x86/crypto/sha-mb/sha1_mb.c
+++ b/arch/x86/crypto/sha-mb/sha1_mb.c
@@@ -80,15 -77,17 +80,15 @@@ struct sha1_mb_ctx 
  	struct mcryptd_ahash *mcryptd_tfm;
  };
  
 -static inline struct mcryptd_hash_request_ctx
 -		*cast_hash_to_mcryptd_ctx(struct sha1_hash_ctx *hash_ctx)
 +static inline struct mcryptd_hash_request_ctx *cast_hash_to_mcryptd_ctx(struct sha1_hash_ctx *hash_ctx)
  {
- 	struct shash_desc *desc;
+ 	struct ahash_request *areq;
  
- 	desc = container_of((void *) hash_ctx, struct shash_desc, __ctx);
- 	return container_of(desc, struct mcryptd_hash_request_ctx, desc);
+ 	areq = container_of((void *) hash_ctx, struct ahash_request, __ctx);
+ 	return container_of(areq, struct mcryptd_hash_request_ctx, areq);
  }
  
 -static inline struct ahash_request
 -		*cast_mcryptd_ctx_to_req(struct mcryptd_hash_request_ctx *ctx)
 +static inline struct ahash_request *cast_mcryptd_ctx_to_req(struct mcryptd_hash_request_ctx *ctx)
  {
  	return container_of((void *) ctx, struct ahash_request, __ctx);
  }
@@@ -398,9 -426,11 +398,14 @@@ static int sha_finish_walk(struct mcryp
  				flag |= HASH_LAST;
  
  		}
++<<<<<<< HEAD
 +		sha_ctx = (struct sha1_hash_ctx *) shash_desc_ctx(&rctx->desc);
++=======
+ 		sha_ctx = (struct sha1_hash_ctx *)
+ 						ahash_request_ctx(&rctx->areq);
++>>>>>>> 331bf739c4f9 (crypto: sha1-mb - async implementation for sha1-mb)
  		kernel_fpu_begin();
 -		sha_ctx = sha1_ctx_mgr_submit(cstate->mgr, sha_ctx,
 -						rctx->walk.data, nbytes, flag);
 +		sha_ctx = sha1_ctx_mgr_submit(cstate->mgr, sha_ctx, rctx->walk.data, nbytes, flag);
  		if (!sha_ctx) {
  			if (flush)
  				sha_ctx = sha1_ctx_mgr_flush(cstate->mgr);
@@@ -489,11 -519,10 +494,14 @@@ static void sha1_mb_add_list(struct mcr
  	mcryptd_arm_flusher(cstate, delay);
  }
  
- static int sha1_mb_update(struct shash_desc *desc, const u8 *data,
- 			  unsigned int len)
+ static int sha1_mb_update(struct ahash_request *areq)
  {
  	struct mcryptd_hash_request_ctx *rctx =
++<<<<<<< HEAD
 +			container_of(desc, struct mcryptd_hash_request_ctx, desc);
++=======
+ 		container_of(areq, struct mcryptd_hash_request_ctx, areq);
++>>>>>>> 331bf739c4f9 (crypto: sha1-mb - async implementation for sha1-mb)
  	struct mcryptd_alg_cstate *cstate =
  				this_cpu_ptr(sha1_mb_alg_state.alg_cstate);
  
@@@ -522,10 -551,11 +530,10 @@@
  		rctx->flag |= HASH_DONE;
  
  	/* submit */
- 	sha_ctx = (struct sha1_hash_ctx *) shash_desc_ctx(desc);
+ 	sha_ctx = (struct sha1_hash_ctx *) ahash_request_ctx(areq);
  	sha1_mb_add_list(rctx, cstate);
  	kernel_fpu_begin();
 -	sha_ctx = sha1_ctx_mgr_submit(cstate->mgr, sha_ctx, rctx->walk.data,
 -							nbytes, HASH_UPDATE);
 +	sha_ctx = sha1_ctx_mgr_submit(cstate->mgr, sha_ctx, rctx->walk.data, nbytes, HASH_UPDATE);
  	kernel_fpu_end();
  
  	/* check if anything is returned */
@@@ -548,11 -578,10 +556,14 @@@ done
  	return ret;
  }
  
- static int sha1_mb_finup(struct shash_desc *desc, const u8 *data,
- 			     unsigned int len, u8 *out)
+ static int sha1_mb_finup(struct ahash_request *areq)
  {
  	struct mcryptd_hash_request_ctx *rctx =
++<<<<<<< HEAD
 +			container_of(desc, struct mcryptd_hash_request_ctx, desc);
++=======
+ 		container_of(areq, struct mcryptd_hash_request_ctx, areq);
++>>>>>>> 331bf739c4f9 (crypto: sha1-mb - async implementation for sha1-mb)
  	struct mcryptd_alg_cstate *cstate =
  				this_cpu_ptr(sha1_mb_alg_state.alg_cstate);
  
@@@ -609,10 -638,10 +619,14 @@@ done
  	return ret;
  }
  
- static int sha1_mb_final(struct shash_desc *desc, u8 *out)
+ static int sha1_mb_final(struct ahash_request *areq)
  {
  	struct mcryptd_hash_request_ctx *rctx =
++<<<<<<< HEAD
 +			container_of(desc, struct mcryptd_hash_request_ctx, desc);
++=======
+ 		container_of(areq, struct mcryptd_hash_request_ctx, areq);
++>>>>>>> 331bf739c4f9 (crypto: sha1-mb - async implementation for sha1-mb)
  	struct mcryptd_alg_cstate *cstate =
  				this_cpu_ptr(sha1_mb_alg_state.alg_cstate);
  
@@@ -766,32 -845,38 +829,67 @@@ static int sha1_mb_async_digest(struct 
  	return crypto_ahash_digest(mcryptd_req);
  }
  
++<<<<<<< HEAD
 +static int sha1_mb_async_init_tfm(struct crypto_tfm *tfm)
 +{
 +	struct mcryptd_ahash *mcryptd_tfm;
 +	struct sha1_mb_ctx *ctx = crypto_tfm_ctx(tfm);
 +	struct mcryptd_hash_ctx *mctx;
 +
 +	mcryptd_tfm = mcryptd_alloc_ahash("__intel_sha1-mb",
 +					  CRYPTO_ALG_INTERNAL,
 +					  CRYPTO_ALG_INTERNAL);
 +	if (IS_ERR(mcryptd_tfm))
 +		return PTR_ERR(mcryptd_tfm);
 +	mctx = crypto_ahash_ctx(&mcryptd_tfm->base);
 +	mctx->alg_state = &sha1_mb_alg_state;
 +	ctx->mcryptd_tfm = mcryptd_tfm;
 +	crypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),
 +				 sizeof(struct ahash_request) +
 +				 crypto_ahash_reqsize(&mcryptd_tfm->base));
 +
 +	return 0;
 +}
 +
 +static void sha1_mb_async_exit_tfm(struct crypto_tfm *tfm)
 +{
 +	struct sha1_mb_ctx *ctx = crypto_tfm_ctx(tfm);
 +
 +	mcryptd_free_ahash(ctx->mcryptd_tfm);
++=======
+ static int sha1_mb_async_export(struct ahash_request *req, void *out)
+ {
+ 	struct ahash_request *mcryptd_req = ahash_request_ctx(req);
+ 	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
+ 	struct sha1_mb_ctx *ctx = crypto_ahash_ctx(tfm);
+ 	struct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;
+ 
+ 	memcpy(mcryptd_req, req, sizeof(*req));
+ 	ahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);
+ 	return crypto_ahash_export(mcryptd_req, out);
+ }
+ 
+ static int sha1_mb_async_import(struct ahash_request *req, const void *in)
+ {
+ 	struct ahash_request *mcryptd_req = ahash_request_ctx(req);
+ 	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
+ 	struct sha1_mb_ctx *ctx = crypto_ahash_ctx(tfm);
+ 	struct mcryptd_ahash *mcryptd_tfm = ctx->mcryptd_tfm;
+ 	struct crypto_ahash *child = mcryptd_ahash_child(mcryptd_tfm);
+ 	struct mcryptd_hash_request_ctx *rctx;
+ 	struct ahash_request *areq;
+ 
+ 	memcpy(mcryptd_req, req, sizeof(*req));
+ 	ahash_request_set_tfm(mcryptd_req, &mcryptd_tfm->base);
+ 	rctx = ahash_request_ctx(mcryptd_req);
+ 	areq = &rctx->areq;
+ 
+ 	ahash_request_set_tfm(areq, child);
+ 	ahash_request_set_callback(areq, CRYPTO_TFM_REQ_MAY_SLEEP,
+ 					rctx->complete, req);
+ 
+ 	return crypto_ahash_import(mcryptd_req, in);
++>>>>>>> 331bf739c4f9 (crypto: sha1-mb - async implementation for sha1-mb)
  }
  
  static struct ahash_alg sha1_mb_async_alg = {
diff --cc crypto/mcryptd.c
index 6c5040caa542,86fb59b109a9..000000000000
--- a/crypto/mcryptd.c
+++ b/crypto/mcryptd.c
@@@ -502,14 -492,13 +500,14 @@@ static int mcryptd_create_hash(struct c
  	u32 mask = 0;
  	int err;
  
 -	mcryptd_check_internal(tb, &type, &mask);
 +	if (!mcryptd_check_internal(tb, &type, &mask))
 +		return -EINVAL;
  
- 	salg = shash_attr_alg(tb[1], type, mask);
- 	if (IS_ERR(salg))
- 		return PTR_ERR(salg);
+ 	halg = ahash_attr_alg(tb[1], type, mask);
+ 	if (IS_ERR(halg))
+ 		return PTR_ERR(halg);
  
- 	alg = &salg->base;
+ 	alg = &halg->base;
  	pr_debug("crypto: mcryptd hash alg: %s\n", alg->cra_name);
  	inst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),
  					sizeof(*ctx));
@@@ -530,7 -519,8 +528,12 @@@
  		type |= CRYPTO_ALG_INTERNAL;
  	inst->alg.halg.base.cra_flags = type;
  
++<<<<<<< HEAD
 +	inst->alg.halg.digestsize = salg->digestsize;
++=======
+ 	inst->alg.halg.digestsize = halg->digestsize;
+ 	inst->alg.halg.statesize = halg->statesize;
++>>>>>>> 331bf739c4f9 (crypto: sha1-mb - async implementation for sha1-mb)
  	inst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);
  
  	inst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;
* Unmerged path arch/x86/crypto/sha-mb/sha1_mb.c
* Unmerged path crypto/mcryptd.c
diff --git a/include/crypto/internal/hash.h b/include/crypto/internal/hash.h
index 3b4af1d7c7e9..a7f052ec7bd6 100644
--- a/include/crypto/internal/hash.h
+++ b/include/crypto/internal/hash.h
@@ -117,14 +117,10 @@ int shash_ahash_update(struct ahash_request *req, struct shash_desc *desc);
 int shash_ahash_finup(struct ahash_request *req, struct shash_desc *desc);
 int shash_ahash_digest(struct ahash_request *req, struct shash_desc *desc);
 
-int shash_ahash_mcryptd_update(struct ahash_request *req,
-			       struct shash_desc *desc);
-int shash_ahash_mcryptd_final(struct ahash_request *req,
-			      struct shash_desc *desc);
-int shash_ahash_mcryptd_finup(struct ahash_request *req,
-			      struct shash_desc *desc);
-int shash_ahash_mcryptd_digest(struct ahash_request *req,
-			       struct shash_desc *desc);
+int ahash_mcryptd_update(struct ahash_request *desc);
+int ahash_mcryptd_final(struct ahash_request *desc);
+int ahash_mcryptd_finup(struct ahash_request *desc);
+int ahash_mcryptd_digest(struct ahash_request *desc);
 
 int crypto_init_shash_ops_async(struct crypto_tfm *tfm);
 
diff --git a/include/crypto/mcryptd.h b/include/crypto/mcryptd.h
index c23ee1f7ee80..4a53c0d38cd2 100644
--- a/include/crypto/mcryptd.h
+++ b/include/crypto/mcryptd.h
@@ -39,7 +39,7 @@ struct mcryptd_instance_ctx {
 };
 
 struct mcryptd_hash_ctx {
-	struct crypto_shash *child;
+	struct crypto_ahash *child;
 	struct mcryptd_alg_state *alg_state;
 };
 
@@ -59,13 +59,13 @@ struct mcryptd_hash_request_ctx {
 	struct crypto_hash_walk walk;
 	u8 *out;
 	int flag;
-	struct shash_desc desc;
+	struct ahash_request areq;
 };
 
 struct mcryptd_ahash *mcryptd_alloc_ahash(const char *alg_name,
 					u32 type, u32 mask);
-struct crypto_shash *mcryptd_ahash_child(struct mcryptd_ahash *tfm);
-struct shash_desc *mcryptd_shash_desc(struct ahash_request *req);
+struct crypto_ahash *mcryptd_ahash_child(struct mcryptd_ahash *tfm);
+struct ahash_request *mcryptd_ahash_desc(struct ahash_request *req);
 void mcryptd_free_ahash(struct mcryptd_ahash *tfm);
 void mcryptd_flusher(struct work_struct *work);
 
