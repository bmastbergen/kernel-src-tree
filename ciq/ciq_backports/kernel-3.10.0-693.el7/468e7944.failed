bridge: vlan: fix possible null vlgrp deref while registering new port

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit 468e7944589c7f096bb4ea14db17980aa6c2766c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/468e7944.failed

While a new port is being initialized the rx_handler gets set, but the
vlans get initialized later in br_add_if() and in that window if we
receive a frame with a link-local address we can try to dereference
p->vlgrp in:
br_handle_frame() -> br_handle_local_finish() -> br_should_learn()

Fix this by checking vlgrp before using it.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 468e7944589c7f096bb4ea14db17980aa6c2766c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_vlan.c
diff --cc net/bridge/br_vlan.c
index 1122c9d717ea,678d5c41b551..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -275,14 -476,15 +275,20 @@@ bool br_allowed_egress(struct net_bridg
  /* Called under RCU */
  bool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid)
  {
+ 	struct net_bridge_vlan_group *vg;
  	struct net_bridge *br = p->br;
 +	struct net_port_vlans *v;
  
 -	/* If filtering was disabled at input, let it pass. */
  	if (!br->vlan_enabled)
  		return true;
  
++<<<<<<< HEAD
 +	v = rcu_dereference(p->vlan_info);
 +	if (!v)
++=======
+ 	vg = p->vlgrp;
+ 	if (!vg || !vg->num_vlans)
++>>>>>>> 468e7944589c (bridge: vlan: fix possible null vlgrp deref while registering new port)
  		return false;
  
  	if (!br_vlan_get_tag(skb, vid) && skb->vlan_proto != br->vlan_proto)
* Unmerged path net/bridge/br_vlan.c
