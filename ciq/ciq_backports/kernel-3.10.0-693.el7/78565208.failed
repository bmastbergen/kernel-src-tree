net: Copy inner L3 and L4 headers as unaligned on GRE TEB

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] flow_dissector: Copy inner L3 and L4 headers as unaligned on GRE TEB (Jonathan Toppins) [1428557]
Rebuild_FUZZ: 89.60%
commit-author Alexander Duyck <aduyck@mirantis.com>
commit 78565208d73ca9b654fb9a6b142214d52eeedfd1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/78565208.failed

This patch corrects the unaligned accesses seen on GRE TEB tunnels when
generating hash keys.  Specifically what this patch does is make it so that
we force the use of skb_copy_bits when the GRE inner headers will be
unaligned due to NET_IP_ALIGNED being a non-zero value.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Acked-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 78565208d73ca9b654fb9a6b142214d52eeedfd1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,12e700332010..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -241,30 -360,59 +241,60 @@@ ip_proto_again
  		 * Only look inside GRE if version zero and no
  		 * routing
  		 */
 -		if (hdr->flags & (GRE_VERSION | GRE_ROUTING))
 -			break;
 -
 -		proto = hdr->proto;
 -		nhoff += 4;
 -		if (hdr->flags & GRE_CSUM)
 +		if (!(hdr->flags & (GRE_VERSION|GRE_ROUTING))) {
 +			proto = hdr->proto;
  			nhoff += 4;
 -		if (hdr->flags & GRE_KEY) {
 -			const __be32 *keyid;
 -			__be32 _keyid;
 -
 -			keyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),
 -						     data, hlen, &_keyid);
 -
 -			if (!keyid)
 -				goto out_bad;
 -
 -			if (dissector_uses_key(flow_dissector,
 -					       FLOW_DISSECTOR_KEY_GRE_KEYID)) {
 -				key_keyid = skb_flow_dissector_target(flow_dissector,
 -								      FLOW_DISSECTOR_KEY_GRE_KEYID,
 -								      target_container);
 -				key_keyid->keyid = *keyid;
 +			if (hdr->flags & GRE_CSUM)
 +				nhoff += 4;
 +			if (hdr->flags & GRE_KEY)
 +				nhoff += 4;
 +			if (hdr->flags & GRE_SEQ)
 +				nhoff += 4;
 +			if (proto == htons(ETH_P_TEB)) {
 +				const struct ethhdr *eth;
 +				struct ethhdr _eth;
 +
 +				eth = __skb_header_pointer(skb, nhoff,
 +							   sizeof(_eth),
 +							   data, hlen, &_eth);
 +				if (!eth)
 +					return false;
 +				proto = eth->h_proto;
 +				nhoff += sizeof(*eth);
  			}
 -			nhoff += 4;
 +			goto again;
  		}
++<<<<<<< HEAD
 +		break;
++=======
+ 		if (hdr->flags & GRE_SEQ)
+ 			nhoff += 4;
+ 		if (proto == htons(ETH_P_TEB)) {
+ 			const struct ethhdr *eth;
+ 			struct ethhdr _eth;
+ 
+ 			eth = __skb_header_pointer(skb, nhoff,
+ 						   sizeof(_eth),
+ 						   data, hlen, &_eth);
+ 			if (!eth)
+ 				goto out_bad;
+ 			proto = eth->h_proto;
+ 			nhoff += sizeof(*eth);
+ 
+ 			/* Cap headers that we access via pointers at the
+ 			 * end of the Ethernet header as our maximum alignment
+ 			 * at that point is only 2 bytes.
+ 			 */
+ 			if (NET_IP_ALIGN)
+ 				hlen = nhoff;
+ 		}
+ 
+ 		key_control->flags |= FLOW_DIS_ENCAPSULATION;
+ 		if (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP)
+ 			goto out_good;
+ 
+ 		goto again;
++>>>>>>> 78565208d73c (net: Copy inner L3 and L4 headers as unaligned on GRE TEB)
  	}
  	case NEXTHDR_HOP:
  	case NEXTHDR_ROUTING:
* Unmerged path net/core/flow_dissector.c
