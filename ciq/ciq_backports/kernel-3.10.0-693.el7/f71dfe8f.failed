pNFS: Remove redundant pnfs_mark_layout_returned_if_empty()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit f71dfe8fc947e04a9e3d10723d4ec4c5c44ce0f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f71dfe8f.failed

That's already being taken care of in pnfs_layout_remove_lseg().

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit f71dfe8fc947e04a9e3d10723d4ec4c5c44ce0f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/nfs4proc.c
index 464f667c987d,d38cc5f0282f..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -8268,8 -8126,8 +8268,13 @@@ static void nfs4_layoutreturn_release(v
  
  	dprintk("--> %s\n", __func__);
  	spin_lock(&lo->plh_inode->i_lock);
++<<<<<<< HEAD
 +	pnfs_mark_matching_lsegs_invalid(lo, &freeme, &lrp->args.range);
 +	pnfs_mark_layout_returned_if_empty(lo);
++=======
+ 	pnfs_mark_matching_lsegs_invalid(lo, &freeme, &lrp->args.range,
+ 			be32_to_cpu(lrp->args.stateid.seqid));
++>>>>>>> f71dfe8fc947 (pNFS: Remove redundant pnfs_mark_layout_returned_if_empty())
  	if (lrp->res.lrs_present && pnfs_layout_is_valid(lo))
  		pnfs_set_layout_stateid(lo, &lrp->res.stateid, true);
  	pnfs_clear_layoutreturn_waitbit(lo);
diff --git a/fs/nfs/callback_proc.c b/fs/nfs/callback_proc.c
index 82033764530b..65e70206bd45 100644
--- a/fs/nfs/callback_proc.c
+++ b/fs/nfs/callback_proc.c
@@ -251,7 +251,6 @@ static u32 initiate_file_draining(struct nfs_client *clp,
 		NFS_SERVER(ino)->pnfs_curr_ld->return_range(lo,
 			&args->cbl_range);
 	}
-	pnfs_mark_layout_returned_if_empty(lo);
 unlock:
 	spin_unlock(&ino->i_lock);
 	pnfs_free_lseg_list(&free_me_list);
* Unmerged path fs/nfs/nfs4proc.c
diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c
index 3653071b6302..2222941f6b3c 100644
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@ -1156,7 +1156,6 @@ void pnfs_roc_set_barrier(struct inode *ino, u32 barrier)
 
 	spin_lock(&ino->i_lock);
 	lo = NFS_I(ino)->layout;
-	pnfs_mark_layout_returned_if_empty(lo);
 	if (pnfs_seqid_is_newer(barrier, lo->plh_barrier))
 		lo->plh_barrier = barrier;
 	spin_unlock(&ino->i_lock);
diff --git a/fs/nfs/pnfs.h b/fs/nfs/pnfs.h
index 6a045d2d2293..4587781cf951 100644
--- a/fs/nfs/pnfs.h
+++ b/fs/nfs/pnfs.h
@@ -544,19 +544,6 @@ pnfs_calc_offset_length(u64 offset, u64 end)
 	return 1 + end - offset;
 }
 
-/**
- * pnfs_mark_layout_returned_if_empty - marks the layout as returned
- * @lo: layout header
- *
- * Note: Caller must hold inode->i_lock
- */
-static inline void
-pnfs_mark_layout_returned_if_empty(struct pnfs_layout_hdr *lo)
-{
-	if (list_empty(&lo->plh_segs))
-		set_bit(NFS_LAYOUT_INVALID_STID, &lo->plh_flags);
-}
-
 static inline void
 pnfs_copy_range(struct pnfs_layout_range *dst,
 		const struct pnfs_layout_range *src)
