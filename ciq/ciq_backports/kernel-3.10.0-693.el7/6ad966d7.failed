powerpc/64: Fix checksum folding in csum_add()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Shile Zhang <shile.zhang@nokia.com>
commit 6ad966d7303b70165228dba1ee8da1a05c10eefe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6ad966d7.failed

Paul's patch to fix checksum folding, commit b492f7e4e07a ("powerpc/64:
Fix checksum folding in csum_tcpudp_nofold and ip_fast_csum_nofold")
missed a case in csum_add(). Fix it.

	Signed-off-by: Shile Zhang <shile.zhang@nokia.com>
	Acked-by: Paul Mackerras <paulus@ozlabs.org>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 6ad966d7303b70165228dba1ee8da1a05c10eefe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/checksum.h
diff --cc arch/powerpc/include/asm/checksum.h
index 0ffd793cff0f,842124b199b5..000000000000
--- a/arch/powerpc/include/asm/checksum.h
+++ b/arch/powerpc/include/asm/checksum.h
@@@ -118,6 -89,131 +118,134 @@@ static inline __wsum csum_tcpudp_nofold
  #endif
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * computes the checksum of the TCP/UDP pseudo-header
+  * returns a 16-bit checksum, already complemented
+  */
+ static inline __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr, __u32 len,
+ 					__u8 proto, __wsum sum)
+ {
+ 	return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));
+ }
+ 
+ #define HAVE_ARCH_CSUM_ADD
+ static inline __wsum csum_add(__wsum csum, __wsum addend)
+ {
+ #ifdef __powerpc64__
+ 	u64 res = (__force u64)csum;
+ #endif
+ 	if (__builtin_constant_p(csum) && csum == 0)
+ 		return addend;
+ 	if (__builtin_constant_p(addend) && addend == 0)
+ 		return csum;
+ 
+ #ifdef __powerpc64__
+ 	res += (__force u64)addend;
+ 	return (__force __wsum) from64to32(res);
+ #else
+ 	asm("addc %0,%0,%1;"
+ 	    "addze %0,%0;"
+ 	    : "+r" (csum) : "r" (addend) : "xer");
+ 	return csum;
+ #endif
+ }
+ 
+ /*
+  * This is a version of ip_compute_csum() optimized for IP headers,
+  * which always checksum on 4 octet boundaries.  ihl is the number
+  * of 32-bit words and is always >= 5.
+  */
+ static inline __wsum ip_fast_csum_nofold(const void *iph, unsigned int ihl)
+ {
+ 	const u32 *ptr = (const u32 *)iph + 1;
+ #ifdef __powerpc64__
+ 	unsigned int i;
+ 	u64 s = *(const u32 *)iph;
+ 
+ 	for (i = 0; i < ihl - 1; i++, ptr++)
+ 		s += *ptr;
+ 	return (__force __wsum)from64to32(s);
+ #else
+ 	__wsum sum, tmp;
+ 
+ 	asm("mtctr %3;"
+ 	    "addc %0,%4,%5;"
+ 	    "1: lwzu %1, 4(%2);"
+ 	    "adde %0,%0,%1;"
+ 	    "bdnz 1b;"
+ 	    "addze %0,%0;"
+ 	    : "=r" (sum), "=r" (tmp), "+b" (ptr)
+ 	    : "r" (ihl - 2), "r" (*(const u32 *)iph), "r" (*ptr)
+ 	    : "ctr", "xer", "memory");
+ 
+ 	return sum;
+ #endif
+ }
+ 
+ static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
+ {
+ 	return csum_fold(ip_fast_csum_nofold(iph, ihl));
+ }
+ 
+ /*
+  * computes the checksum of a memory block at buff, length len,
+  * and adds in "sum" (32-bit)
+  *
+  * returns a 32-bit number suitable for feeding into itself
+  * or csum_tcpudp_magic
+  *
+  * this function must be called with even lengths, except
+  * for the last fragment, which may be odd
+  *
+  * it's best to have buff aligned on a 32-bit boundary
+  */
+ __wsum __csum_partial(const void *buff, int len, __wsum sum);
+ 
+ static inline __wsum csum_partial(const void *buff, int len, __wsum sum)
+ {
+ 	if (__builtin_constant_p(len) && len <= 16 && (len & 1) == 0) {
+ 		if (len == 2)
+ 			sum = csum_add(sum, (__force __wsum)*(const u16 *)buff);
+ 		if (len >= 4)
+ 			sum = csum_add(sum, (__force __wsum)*(const u32 *)buff);
+ 		if (len == 6)
+ 			sum = csum_add(sum, (__force __wsum)
+ 					    *(const u16 *)(buff + 4));
+ 		if (len >= 8)
+ 			sum = csum_add(sum, (__force __wsum)
+ 					    *(const u32 *)(buff + 4));
+ 		if (len == 10)
+ 			sum = csum_add(sum, (__force __wsum)
+ 					    *(const u16 *)(buff + 8));
+ 		if (len >= 12)
+ 			sum = csum_add(sum, (__force __wsum)
+ 					    *(const u32 *)(buff + 8));
+ 		if (len == 14)
+ 			sum = csum_add(sum, (__force __wsum)
+ 					    *(const u16 *)(buff + 12));
+ 		if (len >= 16)
+ 			sum = csum_add(sum, (__force __wsum)
+ 					    *(const u32 *)(buff + 12));
+ 	} else if (__builtin_constant_p(len) && (len & 3) == 0) {
+ 		sum = csum_add(sum, ip_fast_csum_nofold(buff, len >> 2));
+ 	} else {
+ 		sum = __csum_partial(buff, len, sum);
+ 	}
+ 	return sum;
+ }
+ 
+ /*
+  * this routine is used for miscellaneous IP-like checksums, mainly
+  * in icmp.c
+  */
+ static inline __sum16 ip_compute_csum(const void *buff, int len)
+ {
+ 	return csum_fold(csum_partial(buff, len, 0));
+ }
+ 
++>>>>>>> 6ad966d7303b (powerpc/64: Fix checksum folding in csum_add())
  #endif
  #endif /* __KERNEL__ */
  #endif
* Unmerged path arch/powerpc/include/asm/checksum.h
