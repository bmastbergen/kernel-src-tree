bridge: vlan: Prevent possible use-after-free

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 07bc588fc1087929e8e6dfe95ffcee1cb69a240f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/07bc588f.failed

When adding a port to a bridge we initialize VLAN filtering on it. We do
not bail out in case an error occurred in nbp_vlan_init, as it can be
used as a non VLAN filtering bridge.

However, if VLAN filtering is required and an error occurred in
nbp_vlan_init, we should set vlgrp to NULL, so that VLAN filtering
functions (e.g. br_vlan_find, br_get_pvid) will know the struct is
invalid and will not try to access it.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 07bc588fc1087929e8e6dfe95ffcee1cb69a240f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_vlan.c
diff --cc net/bridge/br_vlan.c
index 1122c9d717ea,1054696323d7..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -598,10 -859,68 +598,63 @@@ unlock
  
  int br_vlan_init(struct net_bridge *br)
  {
 -	struct net_bridge_vlan_group *vg;
 -	int ret = -ENOMEM;
 -
 -	vg = kzalloc(sizeof(*vg), GFP_KERNEL);
 -	if (!vg)
 -		goto out;
 -	ret = rhashtable_init(&vg->vlan_hash, &br_vlan_rht_params);
 -	if (ret)
 -		goto err_rhtbl;
 -	INIT_LIST_HEAD(&vg->vlan_list);
  	br->vlan_proto = htons(ETH_P_8021Q);
  	br->default_pvid = 1;
++<<<<<<< HEAD
 +	return br_vlan_add(br, 1,
 +			   BRIDGE_VLAN_INFO_PVID | BRIDGE_VLAN_INFO_UNTAGGED);
++=======
+ 	rcu_assign_pointer(br->vlgrp, vg);
+ 	ret = br_vlan_add(br, 1,
+ 			  BRIDGE_VLAN_INFO_PVID | BRIDGE_VLAN_INFO_UNTAGGED |
+ 			  BRIDGE_VLAN_INFO_BRENTRY);
+ 	if (ret)
+ 		goto err_vlan_add;
+ 
+ out:
+ 	return ret;
+ 
+ err_vlan_add:
+ 	rhashtable_destroy(&vg->vlan_hash);
+ err_rhtbl:
+ 	kfree(vg);
+ 
+ 	goto out;
+ }
+ 
+ int nbp_vlan_init(struct net_bridge_port *p)
+ {
+ 	struct net_bridge_vlan_group *vg;
+ 	int ret = -ENOMEM;
+ 
+ 	vg = kzalloc(sizeof(struct net_bridge_vlan_group), GFP_KERNEL);
+ 	if (!vg)
+ 		goto out;
+ 
+ 	ret = rhashtable_init(&vg->vlan_hash, &br_vlan_rht_params);
+ 	if (ret)
+ 		goto err_rhtbl;
+ 	INIT_LIST_HEAD(&vg->vlan_list);
+ 	rcu_assign_pointer(p->vlgrp, vg);
+ 	if (p->br->default_pvid) {
+ 		ret = nbp_vlan_add(p, p->br->default_pvid,
+ 				   BRIDGE_VLAN_INFO_PVID |
+ 				   BRIDGE_VLAN_INFO_UNTAGGED);
+ 		if (ret)
+ 			goto err_vlan_add;
+ 	}
+ out:
+ 	return ret;
+ 
+ err_vlan_add:
+ 	RCU_INIT_POINTER(p->vlgrp, NULL);
+ 	synchronize_rcu();
+ 	rhashtable_destroy(&vg->vlan_hash);
+ err_rhtbl:
+ 	kfree(vg);
+ 
+ 	goto out;
++>>>>>>> 07bc588fc108 (bridge: vlan: Prevent possible use-after-free)
  }
  
  /* Must be protected by RTNL.
* Unmerged path net/bridge/br_vlan.c
