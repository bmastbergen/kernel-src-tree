sfc: update EF10 register definitions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Bert Kenward <bkenward@solarflare.com>
commit d8d8ccf277419b6feb281a2d08d9f881b2b724be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d8d8ccf2.failed

The RX_L4_CLASS field has shrunk from 3 bits to 2 bits. The upper
bit was never used in previous hardware, so we can use the new
definition throughout.

The TSO OUTER_IPID field was previously spelt differently from the
external definitions.

	Signed-off-by: Edward Cree <ecree@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d8d8ccf277419b6feb281a2d08d9f881b2b724be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/ef10.c
#	drivers/net/ethernet/sfc/ef10_regs.h
diff --cc drivers/net/ethernet/sfc/ef10.c
index 00279da6a1e8,56a6bc60dac1..000000000000
--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@@ -2832,6 -3254,97 +2832,100 @@@ static void efx_ef10_handle_rx_abort(st
  	++efx_rx_queue_channel(rx_queue)->n_rx_nodesc_trunc;
  }
  
++<<<<<<< HEAD
++=======
+ static u16 efx_ef10_handle_rx_event_errors(struct efx_channel *channel,
+ 					   unsigned int n_packets,
+ 					   unsigned int rx_encap_hdr,
+ 					   unsigned int rx_l3_class,
+ 					   unsigned int rx_l4_class,
+ 					   const efx_qword_t *event)
+ {
+ 	struct efx_nic *efx = channel->efx;
+ 	bool handled = false;
+ 
+ 	if (EFX_QWORD_FIELD(*event, ESF_DZ_RX_ECRC_ERR)) {
+ 		if (!(efx->net_dev->features & NETIF_F_RXALL)) {
+ 			if (!efx->loopback_selftest)
+ 				channel->n_rx_eth_crc_err += n_packets;
+ 			return EFX_RX_PKT_DISCARD;
+ 		}
+ 		handled = true;
+ 	}
+ 	if (EFX_QWORD_FIELD(*event, ESF_DZ_RX_IPCKSUM_ERR)) {
+ 		if (unlikely(rx_encap_hdr != ESE_EZ_ENCAP_HDR_VXLAN &&
+ 			     rx_l3_class != ESE_DZ_L3_CLASS_IP4 &&
+ 			     rx_l3_class != ESE_DZ_L3_CLASS_IP4_FRAG &&
+ 			     rx_l3_class != ESE_DZ_L3_CLASS_IP6 &&
+ 			     rx_l3_class != ESE_DZ_L3_CLASS_IP6_FRAG))
+ 			netdev_WARN(efx->net_dev,
+ 				    "invalid class for RX_IPCKSUM_ERR: event="
+ 				    EFX_QWORD_FMT "\n",
+ 				    EFX_QWORD_VAL(*event));
+ 		if (!efx->loopback_selftest)
+ 			*(rx_encap_hdr ?
+ 			  &channel->n_rx_outer_ip_hdr_chksum_err :
+ 			  &channel->n_rx_ip_hdr_chksum_err) += n_packets;
+ 		return 0;
+ 	}
+ 	if (EFX_QWORD_FIELD(*event, ESF_DZ_RX_TCPUDP_CKSUM_ERR)) {
+ 		if (unlikely(rx_encap_hdr != ESE_EZ_ENCAP_HDR_VXLAN &&
+ 			     ((rx_l3_class != ESE_DZ_L3_CLASS_IP4 &&
+ 			       rx_l3_class != ESE_DZ_L3_CLASS_IP6) ||
+ 			      (rx_l4_class != ESE_FZ_L4_CLASS_TCP &&
+ 			       rx_l4_class != ESE_FZ_L4_CLASS_UDP))))
+ 			netdev_WARN(efx->net_dev,
+ 				    "invalid class for RX_TCPUDP_CKSUM_ERR: event="
+ 				    EFX_QWORD_FMT "\n",
+ 				    EFX_QWORD_VAL(*event));
+ 		if (!efx->loopback_selftest)
+ 			*(rx_encap_hdr ?
+ 			  &channel->n_rx_outer_tcp_udp_chksum_err :
+ 			  &channel->n_rx_tcp_udp_chksum_err) += n_packets;
+ 		return 0;
+ 	}
+ 	if (EFX_QWORD_FIELD(*event, ESF_EZ_RX_IP_INNER_CHKSUM_ERR)) {
+ 		if (unlikely(!rx_encap_hdr))
+ 			netdev_WARN(efx->net_dev,
+ 				    "invalid encapsulation type for RX_IP_INNER_CHKSUM_ERR: event="
+ 				    EFX_QWORD_FMT "\n",
+ 				    EFX_QWORD_VAL(*event));
+ 		else if (unlikely(rx_l3_class != ESE_DZ_L3_CLASS_IP4 &&
+ 				  rx_l3_class != ESE_DZ_L3_CLASS_IP4_FRAG &&
+ 				  rx_l3_class != ESE_DZ_L3_CLASS_IP6 &&
+ 				  rx_l3_class != ESE_DZ_L3_CLASS_IP6_FRAG))
+ 			netdev_WARN(efx->net_dev,
+ 				    "invalid class for RX_IP_INNER_CHKSUM_ERR: event="
+ 				    EFX_QWORD_FMT "\n",
+ 				    EFX_QWORD_VAL(*event));
+ 		if (!efx->loopback_selftest)
+ 			channel->n_rx_inner_ip_hdr_chksum_err += n_packets;
+ 		return 0;
+ 	}
+ 	if (EFX_QWORD_FIELD(*event, ESF_EZ_RX_TCP_UDP_INNER_CHKSUM_ERR)) {
+ 		if (unlikely(!rx_encap_hdr))
+ 			netdev_WARN(efx->net_dev,
+ 				    "invalid encapsulation type for RX_TCP_UDP_INNER_CHKSUM_ERR: event="
+ 				    EFX_QWORD_FMT "\n",
+ 				    EFX_QWORD_VAL(*event));
+ 		else if (unlikely((rx_l3_class != ESE_DZ_L3_CLASS_IP4 &&
+ 				   rx_l3_class != ESE_DZ_L3_CLASS_IP6) ||
+ 				  (rx_l4_class != ESE_FZ_L4_CLASS_TCP &&
+ 				   rx_l4_class != ESE_FZ_L4_CLASS_UDP)))
+ 			netdev_WARN(efx->net_dev,
+ 				    "invalid class for RX_TCP_UDP_INNER_CHKSUM_ERR: event="
+ 				    EFX_QWORD_FMT "\n",
+ 				    EFX_QWORD_VAL(*event));
+ 		if (!efx->loopback_selftest)
+ 			channel->n_rx_inner_tcp_udp_chksum_err += n_packets;
+ 		return 0;
+ 	}
+ 
+ 	WARN_ON(!handled); /* No error bits were recognised */
+ 	return 0;
+ }
+ 
++>>>>>>> d8d8ccf27741 (sfc: update EF10 register definitions)
  static int efx_ef10_handle_rx_event(struct efx_channel *channel,
  				    const efx_qword_t *event)
  {
@@@ -2849,8 -3365,14 +2943,13 @@@
  	rx_bytes = EFX_QWORD_FIELD(*event, ESF_DZ_RX_BYTES);
  	next_ptr_lbits = EFX_QWORD_FIELD(*event, ESF_DZ_RX_DSC_PTR_LBITS);
  	rx_queue_label = EFX_QWORD_FIELD(*event, ESF_DZ_RX_QLABEL);
++<<<<<<< HEAD
 +	rx_l4_class = EFX_QWORD_FIELD(*event, ESF_DZ_RX_L4_CLASS);
++=======
+ 	rx_l3_class = EFX_QWORD_FIELD(*event, ESF_DZ_RX_L3_CLASS);
+ 	rx_l4_class = EFX_QWORD_FIELD(*event, ESF_FZ_RX_L4_CLASS);
++>>>>>>> d8d8ccf27741 (sfc: update EF10 register definitions)
  	rx_cont = EFX_QWORD_FIELD(*event, ESF_DZ_RX_CONT);
 -	rx_encap_hdr =
 -		nic_data->datapath_caps &
 -			(1 << MC_CMD_GET_CAPABILITIES_OUT_VXLAN_NVGRE_LBN) ?
 -		EFX_QWORD_FIELD(*event, ESF_EZ_RX_ENCAP_HDR) :
 -		ESE_EZ_ENCAP_HDR_NONE;
  
  	if (EFX_QWORD_FIELD(*event, ESF_DZ_RX_DROP_EVENT))
  		netdev_WARN(efx->net_dev, "saw RX_DROP_EVENT: event="
@@@ -2910,20 -3432,41 +3009,37 @@@
  		n_packets = 1;
  	}
  
++<<<<<<< HEAD
 +	if (unlikely(EFX_QWORD_FIELD(*event, ESF_DZ_RX_ECRC_ERR)))
 +		flags |= EFX_RX_PKT_DISCARD;
++=======
+ 	EFX_POPULATE_QWORD_5(errors, ESF_DZ_RX_ECRC_ERR, 1,
+ 				     ESF_DZ_RX_IPCKSUM_ERR, 1,
+ 				     ESF_DZ_RX_TCPUDP_CKSUM_ERR, 1,
+ 				     ESF_EZ_RX_IP_INNER_CHKSUM_ERR, 1,
+ 				     ESF_EZ_RX_TCP_UDP_INNER_CHKSUM_ERR, 1);
+ 	EFX_AND_QWORD(errors, *event, errors);
+ 	if (unlikely(!EFX_QWORD_IS_ZERO(errors))) {
+ 		flags |= efx_ef10_handle_rx_event_errors(channel, n_packets,
+ 							 rx_encap_hdr,
+ 							 rx_l3_class, rx_l4_class,
+ 							 event);
+ 	} else {
+ 		bool tcpudp = rx_l4_class == ESE_FZ_L4_CLASS_TCP ||
+ 			      rx_l4_class == ESE_FZ_L4_CLASS_UDP;
++>>>>>>> d8d8ccf27741 (sfc: update EF10 register definitions)
  
 -		switch (rx_encap_hdr) {
 -		case ESE_EZ_ENCAP_HDR_VXLAN: /* VxLAN or GENEVE */
 -			flags |= EFX_RX_PKT_CSUMMED; /* outer UDP csum */
 -			if (tcpudp)
 -				flags |= EFX_RX_PKT_CSUM_LEVEL; /* inner L4 */
 -			break;
 -		case ESE_EZ_ENCAP_HDR_GRE:
 -		case ESE_EZ_ENCAP_HDR_NONE:
 -			if (tcpudp)
 -				flags |= EFX_RX_PKT_CSUMMED;
 -			break;
 -		default:
 -			netdev_WARN(efx->net_dev,
 -				    "unknown encapsulation type: event="
 -				    EFX_QWORD_FMT "\n",
 -				    EFX_QWORD_VAL(*event));
 -		}
 +	if (unlikely(EFX_QWORD_FIELD(*event, ESF_DZ_RX_IPCKSUM_ERR))) {
 +		channel->n_rx_ip_hdr_chksum_err += n_packets;
 +	} else if (unlikely(EFX_QWORD_FIELD(*event,
 +					    ESF_DZ_RX_TCPUDP_CKSUM_ERR))) {
 +		channel->n_rx_tcp_udp_chksum_err += n_packets;
 +	} else if (rx_l4_class == ESE_DZ_L4_CLASS_TCP ||
 +		   rx_l4_class == ESE_DZ_L4_CLASS_UDP) {
 +		flags |= EFX_RX_PKT_CSUMMED;
  	}
  
- 	if (rx_l4_class == ESE_DZ_L4_CLASS_TCP)
+ 	if (rx_l4_class == ESE_FZ_L4_CLASS_TCP)
  		flags |= EFX_RX_PKT_TCP;
  
  	channel->irq_mod_score += 2 * n_packets;
diff --cc drivers/net/ethernet/sfc/ef10_regs.h
index 62a55dde61d5,6a56778cf06c..000000000000
--- a/drivers/net/ethernet/sfc/ef10_regs.h
+++ b/drivers/net/ethernet/sfc/ef10_regs.h
@@@ -1,6 -1,6 +1,10 @@@
  /****************************************************************************
   * Driver for Solarflare network controllers and boards
++<<<<<<< HEAD
 + * Copyright 2012-2013 Solarflare Communications Inc.
++=======
+  * Copyright 2012-2017 Solarflare Communications Inc.
++>>>>>>> d8d8ccf27741 (sfc: update EF10 register definitions)
   *
   * This program is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 as published
@@@ -192,14 -208,25 +206,16 @@@
  #define	ESF_DZ_RX_MAC_CLASS_WIDTH 1
  #define	ESE_DZ_MAC_CLASS_MCAST 1
  #define	ESE_DZ_MAC_CLASS_UCAST 0
 -#define	ESF_DD_RX_EV_SOFT1_LBN 32
 -#define	ESF_DD_RX_EV_SOFT1_WIDTH 3
 -#define	ESF_EZ_RX_EV_SOFT1_LBN 34
 -#define	ESF_EZ_RX_EV_SOFT1_WIDTH 1
 -#define	ESF_EZ_RX_ENCAP_HDR_LBN 32
 -#define	ESF_EZ_RX_ENCAP_HDR_WIDTH 2
 -#define	ESE_EZ_ENCAP_HDR_GRE 2
 -#define	ESE_EZ_ENCAP_HDR_VXLAN 1
 -#define	ESE_EZ_ENCAP_HDR_NONE 0
 -#define	ESF_DD_RX_EV_RSVD1_LBN 30
 -#define	ESF_DD_RX_EV_RSVD1_WIDTH 2
 -#define	ESF_EZ_RX_EV_RSVD1_LBN 31
 -#define	ESF_EZ_RX_EV_RSVD1_WIDTH 1
 -#define	ESF_EZ_RX_ABORT_LBN 30
 -#define	ESF_EZ_RX_ABORT_WIDTH 1
 +#define	ESF_DZ_RX_EV_SOFT1_LBN 32
 +#define	ESF_DZ_RX_EV_SOFT1_WIDTH 3
 +#define	ESF_DZ_RX_EV_RSVD1_LBN 31
 +#define	ESF_DZ_RX_EV_RSVD1_WIDTH 1
 +#define	ESF_DZ_RX_ABORT_LBN 30
 +#define	ESF_DZ_RX_ABORT_WIDTH 1
  #define	ESF_DZ_RX_ECC_ERR_LBN 29
  #define	ESF_DZ_RX_ECC_ERR_WIDTH 1
+ #define	ESF_DZ_RX_TRUNC_ERR_LBN 29
+ #define	ESF_DZ_RX_TRUNC_ERR_WIDTH 1
  #define	ESF_DZ_RX_CRC1_ERR_LBN 28
  #define	ESF_DZ_RX_CRC1_ERR_WIDTH 1
  #define	ESF_DZ_RX_CRC0_ERR_LBN 27
@@@ -301,6 -342,12 +317,15 @@@
  #define	ESE_DZ_TX_OPTION_DESC_TSO 7
  #define	ESE_DZ_TX_OPTION_DESC_VLAN 6
  #define	ESE_DZ_TX_OPTION_DESC_CRC_CSUM 0
++<<<<<<< HEAD
++=======
+ #define	ESF_DZ_TX_TSO_OPTION_TYPE_LBN 56
+ #define	ESF_DZ_TX_TSO_OPTION_TYPE_WIDTH 4
+ #define	ESE_DZ_TX_TSO_OPTION_DESC_FATSO2B 3
+ #define	ESE_DZ_TX_TSO_OPTION_DESC_FATSO2A 2
+ #define	ESE_DZ_TX_TSO_OPTION_DESC_ENCAP 1
+ #define	ESE_DZ_TX_TSO_OPTION_DESC_NORMAL 0
++>>>>>>> d8d8ccf27741 (sfc: update EF10 register definitions)
  #define	ESF_DZ_TX_TSO_TCP_FLAGS_LBN 48
  #define	ESF_DZ_TX_TSO_TCP_FLAGS_WIDTH 8
  #define	ESF_DZ_TX_TSO_IP_ID_LBN 32
@@@ -308,6 -355,44 +333,47 @@@
  #define	ESF_DZ_TX_TSO_TCP_SEQNO_LBN 0
  #define	ESF_DZ_TX_TSO_TCP_SEQNO_WIDTH 32
  
++<<<<<<< HEAD
++=======
+ /* TX_TSO_V2_DESC_A */
+ #define	ESF_DZ_TX_DESC_IS_OPT_LBN 63
+ #define	ESF_DZ_TX_DESC_IS_OPT_WIDTH 1
+ #define	ESF_DZ_TX_OPTION_TYPE_LBN 60
+ #define	ESF_DZ_TX_OPTION_TYPE_WIDTH 3
+ #define	ESE_DZ_TX_OPTION_DESC_TSO 7
+ #define	ESE_DZ_TX_OPTION_DESC_VLAN 6
+ #define	ESE_DZ_TX_OPTION_DESC_CRC_CSUM 0
+ #define	ESF_DZ_TX_TSO_OPTION_TYPE_LBN 56
+ #define	ESF_DZ_TX_TSO_OPTION_TYPE_WIDTH 4
+ #define	ESE_DZ_TX_TSO_OPTION_DESC_FATSO2B 3
+ #define	ESE_DZ_TX_TSO_OPTION_DESC_FATSO2A 2
+ #define	ESE_DZ_TX_TSO_OPTION_DESC_ENCAP 1
+ #define	ESE_DZ_TX_TSO_OPTION_DESC_NORMAL 0
+ #define	ESF_DZ_TX_TSO_IP_ID_LBN 32
+ #define	ESF_DZ_TX_TSO_IP_ID_WIDTH 16
+ #define	ESF_DZ_TX_TSO_TCP_SEQNO_LBN 0
+ #define	ESF_DZ_TX_TSO_TCP_SEQNO_WIDTH 32
+ 
+ /* TX_TSO_V2_DESC_B */
+ #define	ESF_DZ_TX_DESC_IS_OPT_LBN 63
+ #define	ESF_DZ_TX_DESC_IS_OPT_WIDTH 1
+ #define	ESF_DZ_TX_OPTION_TYPE_LBN 60
+ #define	ESF_DZ_TX_OPTION_TYPE_WIDTH 3
+ #define	ESE_DZ_TX_OPTION_DESC_TSO 7
+ #define	ESE_DZ_TX_OPTION_DESC_VLAN 6
+ #define	ESE_DZ_TX_OPTION_DESC_CRC_CSUM 0
+ #define	ESF_DZ_TX_TSO_OPTION_TYPE_LBN 56
+ #define	ESF_DZ_TX_TSO_OPTION_TYPE_WIDTH 4
+ #define	ESE_DZ_TX_TSO_OPTION_DESC_FATSO2B 3
+ #define	ESE_DZ_TX_TSO_OPTION_DESC_FATSO2A 2
+ #define	ESE_DZ_TX_TSO_OPTION_DESC_ENCAP 1
+ #define	ESE_DZ_TX_TSO_OPTION_DESC_NORMAL 0
+ #define	ESF_DZ_TX_TSO_TCP_MSS_LBN 32
+ #define	ESF_DZ_TX_TSO_TCP_MSS_WIDTH 16
+ #define	ESF_DZ_TX_TSO_OUTER_IPID_LBN 0
+ #define	ESF_DZ_TX_TSO_OUTER_IPID_WIDTH 16
+ 
++>>>>>>> d8d8ccf27741 (sfc: update EF10 register definitions)
  /*************************************************************************/
  
  /* TX_DESC_UPD_REG: Transmit descriptor update register.
* Unmerged path drivers/net/ethernet/sfc/ef10.c
* Unmerged path drivers/net/ethernet/sfc/ef10_regs.h
