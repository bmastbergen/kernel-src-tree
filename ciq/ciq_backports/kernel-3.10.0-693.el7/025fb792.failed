mei: split amthif client init from end of clients enumeration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit 025fb792bac33632c19fe12265ba1f6108921300
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/025fb792.failed

The amthif FW client can appear after the end of client enumeration.
Amthif host client initialization is done now at FW client discovery
time.

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 025fb792bac33632c19fe12265ba1f6108921300)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/client.c
diff --cc drivers/misc/mei/client.c
index d470ad099cb1,af6816bc268f..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -670,31 -666,12 +670,32 @@@ int mei_cl_unlink(struct mei_cl *cl
  	return 0;
  }
  
- 
- void mei_host_client_init(struct work_struct *work)
+ void mei_host_client_init(struct mei_device *dev)
  {
++<<<<<<< HEAD
 +	struct mei_device *dev =
 +		container_of(work, struct mei_device, init_work);
 +	struct mei_me_client *me_cl;
 +
 +	mutex_lock(&dev->device_lock);
 +
 +
 +	me_cl = mei_me_cl_by_uuid(dev, &mei_amthif_guid);
 +	if (me_cl)
 +		mei_amthif_host_init(dev, me_cl);
 +	mei_me_cl_put(me_cl);
 +
 +	me_cl = mei_me_cl_by_uuid(dev, &mei_wd_guid);
 +	if (me_cl)
 +		mei_wd_host_init(dev, me_cl);
 +	mei_me_cl_put(me_cl);
 +
++=======
++>>>>>>> 025fb792bac3 (mei: split amthif client init from end of clients enumeration)
  	dev->dev_state = MEI_DEV_ENABLED;
  	dev->reset_count = 0;
- 	mutex_unlock(&dev->device_lock);
  
- 	mei_cl_bus_rescan(dev);
+ 	schedule_work(&dev->bus_rescan_work);
  
  	pm_runtime_mark_last_busy(dev->dev);
  	dev_dbg(dev->dev, "rpm: autosuspend\n");
diff --git a/drivers/misc/mei/amthif.c b/drivers/misc/mei/amthif.c
index 3ee24dcd2932..f5dd304f4c24 100644
--- a/drivers/misc/mei/amthif.c
+++ b/drivers/misc/mei/amthif.c
@@ -69,6 +69,9 @@ int mei_amthif_host_init(struct mei_device *dev, struct mei_me_client *me_cl)
 	struct mei_cl *cl = &dev->iamthif_cl;
 	int ret;
 
+	if (mei_cl_is_connected(cl))
+		return 0;
+
 	dev->iamthif_state = MEI_IAMTHIF_IDLE;
 
 	mei_cl_init(cl, dev);
@@ -81,8 +84,6 @@ int mei_amthif_host_init(struct mei_device *dev, struct mei_me_client *me_cl)
 
 	ret = mei_cl_connect(cl, me_cl, NULL);
 
-	dev->iamthif_state = MEI_IAMTHIF_IDLE;
-
 	return ret;
 }
 
diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c
index 8aba7220c6fd..f4cd8eb2bdb4 100644
--- a/drivers/misc/mei/bus.c
+++ b/drivers/misc/mei/bus.c
@@ -981,6 +981,14 @@ void mei_cl_bus_rescan_work(struct work_struct *work)
 {
 	struct mei_device *bus =
 		container_of(work, struct mei_device, bus_rescan_work);
+	struct mei_me_client *me_cl;
+
+	mutex_lock(&bus->device_lock);
+	me_cl = mei_me_cl_by_uuid(bus, &mei_amthif_guid);
+	if (me_cl)
+		mei_amthif_host_init(bus, me_cl);
+	mei_me_cl_put(me_cl);
+	mutex_unlock(&bus->device_lock);
 
 	mei_cl_bus_rescan(bus);
 }
* Unmerged path drivers/misc/mei/client.c
diff --git a/drivers/misc/mei/client.h b/drivers/misc/mei/client.h
index 3f0ed224a4f2..3b9e02eebbc9 100644
--- a/drivers/misc/mei/client.h
+++ b/drivers/misc/mei/client.h
@@ -230,7 +230,7 @@ int mei_cl_irq_write(struct mei_cl *cl, struct mei_cl_cb *cb,
 
 void mei_cl_complete(struct mei_cl *cl, struct mei_cl_cb *cb);
 
-void mei_host_client_init(struct work_struct *work);
+void mei_host_client_init(struct mei_device *dev);
 
 u8 mei_cl_notify_fop2req(enum mei_cb_file_ops fop);
 enum mei_cb_file_ops mei_cl_notify_req2fop(u8 request);
diff --git a/drivers/misc/mei/hbm.c b/drivers/misc/mei/hbm.c
index 95feae24c969..7bc27b7cf02f 100644
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@ -546,7 +546,7 @@ static int mei_hbm_prop_req(struct mei_device *dev)
 	/* We got all client properties */
 	if (next_client_index == MEI_CLIENTS_MAX) {
 		dev->hbm_state = MEI_HBM_STARTED;
-		schedule_work(&dev->init_work);
+		mei_host_client_init(dev);
 
 		return 0;
 	}
diff --git a/drivers/misc/mei/init.c b/drivers/misc/mei/init.c
index 60b2335c1606..a27b781ec5be 100644
--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@ -91,7 +91,6 @@ EXPORT_SYMBOL_GPL(mei_fw_status2str);
  */
 void mei_cancel_work(struct mei_device *dev)
 {
-	cancel_work_sync(&dev->init_work);
 	cancel_work_sync(&dev->reset_work);
 	cancel_work_sync(&dev->bus_rescan_work);
 
@@ -398,7 +397,6 @@ void mei_device_init(struct mei_device *dev,
 	mei_io_list_init(&dev->ctrl_rd_list);
 
 	INIT_DELAYED_WORK(&dev->timer_work, mei_timer);
-	INIT_WORK(&dev->init_work, mei_host_client_init);
 	INIT_WORK(&dev->reset_work, mei_reset_work);
 	INIT_WORK(&dev->bus_rescan_work, mei_cl_bus_rescan_work);
 
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index 15f821bcacb0..54569793dd55 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -449,7 +449,6 @@ const char *mei_pg_state_str(enum mei_pg_state state);
  * @iamthif_state : amthif processor state
  * @iamthif_canceled : current amthif command is canceled
  *
- * @init_work   : work item for the device init
  * @reset_work  : work item for the device reset
  * @bus_rescan_work : work item for the bus rescan
  *
@@ -547,7 +546,6 @@ struct mei_device {
 	enum iamthif_states iamthif_state;
 	bool iamthif_canceled;
 
-	struct work_struct init_work;
 	struct work_struct reset_work;
 	struct work_struct bus_rescan_work;
 
