pNFS: Do not set plh_return_seq for non-callback related layoutreturns

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 2d6cf5ab0b5d13d06c4b7920d6a12dbedf003190
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2d6cf5ab.failed

In cases where we need to send a layoutreturn in order to propagate
an error, we should not tie that to a specific layout stateid.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 2d6cf5ab0b5d13d06c4b7920d6a12dbedf003190)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pnfs.c
diff --cc fs/nfs/pnfs.c
index 3653071b6302,c57cbddca760..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -1749,12 -1804,38 +1749,40 @@@ out_forget
  	return ERR_PTR(-EAGAIN);
  }
  
++<<<<<<< HEAD
 +void
++=======
+ static void
+ pnfs_set_plh_return_info(struct pnfs_layout_hdr *lo, enum pnfs_iomode iomode,
+ 			 u32 seq)
+ {
+ 	if (lo->plh_return_iomode != 0 && lo->plh_return_iomode != iomode)
+ 		iomode = IOMODE_ANY;
+ 	lo->plh_return_iomode = iomode;
+ 	set_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags);
+ 	if (seq != 0) {
+ 		WARN_ON_ONCE(lo->plh_return_seq != 0 && lo->plh_return_seq != seq);
+ 		lo->plh_return_seq = seq;
+ 	}
+ }
+ 
+ /**
+  * pnfs_mark_matching_lsegs_return - Free or return matching layout segments
+  * @lo: pointer to layout header
+  * @tmp_list: list header to be used with pnfs_free_lseg_list()
+  * @return_range: describe layout segment ranges to be returned
+  *
+  * This function is mainly intended for use by layoutrecall. It attempts
+  * to free the layout segment immediately, or else to mark it for return
+  * as soon as its reference count drops to zero.
+  */
+ int
++>>>>>>> 2d6cf5ab0b5d (pNFS: Do not set plh_return_seq for non-callback related layoutreturns)
  pnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,
  				struct list_head *tmp_list,
 -				const struct pnfs_layout_range *return_range,
 -				u32 seq)
 +				struct pnfs_layout_range *return_range)
  {
  	struct pnfs_layout_segment *lseg, *next;
 -	int remaining = 0;
  
  	dprintk("%s:Begin lo %p\n", __func__, lo);
  
@@@ -1787,19 -1873,27 +1815,38 @@@ void pnfs_error_mark_layout_for_return(
  		.length = NFS4_MAX_UINT64,
  	};
  	LIST_HEAD(free_me);
 -	bool return_now = false;
  
  	spin_lock(&inode->i_lock);
++<<<<<<< HEAD
 +	if (lo->plh_return_iomode == 0)
 +		lo->plh_return_iomode = range.iomode;
 +	else if (lo->plh_return_iomode != range.iomode)
 +		lo->plh_return_iomode = IOMODE_ANY;
++=======
+ 	pnfs_set_plh_return_info(lo, range.iomode, 0);
++>>>>>>> 2d6cf5ab0b5d (pNFS: Do not set plh_return_seq for non-callback related layoutreturns)
  	/*
  	 * mark all matching lsegs so that we are sure to have no live
  	 * segments at hand when sending layoutreturn. See pnfs_put_lseg()
  	 * for how it works.
  	 */
++<<<<<<< HEAD
 +	pnfs_mark_matching_lsegs_return(lo, &free_me, &range);
 +	spin_unlock(&inode->i_lock);
++=======
+ 	if (!pnfs_mark_matching_lsegs_return(lo, &free_me, &range, 0)) {
+ 		nfs4_stateid stateid;
+ 		enum pnfs_iomode iomode;
+ 
+ 		return_now = pnfs_prepare_layoutreturn(lo, &stateid, &iomode);
+ 		spin_unlock(&inode->i_lock);
+ 		if (return_now)
+ 			pnfs_send_layoutreturn(lo, &stateid, iomode, false);
+ 	} else {
+ 		spin_unlock(&inode->i_lock);
+ 		nfs_commit_inode(inode, 0);
+ 	}
++>>>>>>> 2d6cf5ab0b5d (pNFS: Do not set plh_return_seq for non-callback related layoutreturns)
  	pnfs_free_lseg_list(&free_me);
  }
  EXPORT_SYMBOL_GPL(pnfs_error_mark_layout_for_return);
* Unmerged path fs/nfs/pnfs.c
