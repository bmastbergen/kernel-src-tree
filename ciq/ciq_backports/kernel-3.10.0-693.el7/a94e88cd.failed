ACPICA: Tables: Avoid SSDT installation with acpi_gbl_disable_ssdt_table_load.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [acpi] acpica: tables: Avoid SSDT installation with acpi_gbl_disable_ssdt_table_load (Prarit Bhargava) [1425180]
Rebuild_FUZZ: 99.35%
commit-author Lv Zheng <lv.zheng@intel.com>
commit a94e88cdd8057fe8ea84bbb6d9a89a823c7bc49b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a94e88cd.failed

It is reported that when acpi_gbl_disable_ssdt_table_load is specified, user
still can see it installed into /sys/firmware/acpi/tables on Linux boxes.
This is because the option only stops table "loading", but doesn't stop
table "installing", thus it is still in the acpi_gbl_root_table_list. With
previous cleanups, it is possible to prevent SSDT installations to make
it not such confusing.  The global variable is also renamed.  Lv Zheng.

	Signed-off-by: Lv Zheng <lv.zheng@intel.com>
[rjw: Subject]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit a94e88cdd8057fe8ea84bbb6d9a89a823c7bc49b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/kernel-parameters.txt
#	drivers/acpi/acpica/acglobal.h
#	drivers/acpi/acpica/tbinstal.c
#	include/acpi/acpixf.h
diff --cc Documentation/kernel-parameters.txt
index 31622a80d6ed,fbb58d790ec7..000000000000
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@@ -230,7 -229,31 +230,27 @@@ bytes respectively. Such letter suffixe
  			use by PCI
  			Format: <irq>,<irq>...
  
++<<<<<<< HEAD
 +	acpi_no_auto_ssdt	[HW,ACPI] Disable automatic loading of SSDT
++=======
+ 	acpi_no_auto_serialize	[HW,ACPI]
+ 			Disable auto-serialization of AML methods
+ 			AML control methods that contain the opcodes to create
+ 			named objects will be marked as "Serialized" by the
+ 			auto-serialization feature.
+ 			This feature is enabled by default.
+ 			This option allows to turn off the feature.
+ 
+ 	acpi_no_static_ssdt	[HW,ACPI]
+ 			Disable installation of static SSDTs at early boot time
+ 			By default, SSDTs contained in the RSDT/XSDT will be
+ 			installed automatically and they will appear under
+ 			/sys/firmware/acpi/tables.
+ 			This option turns off this feature.
+ 			Note that specifying this option does not affect
+ 			dynamic table installation which will install SSDT
+ 			tables to /sys/firmware/acpi/tables/dynamic.
 -
 -	acpica_no_return_repair [HW, ACPI]
 -			Disable AML predefined validation mechanism
 -			This mechanism can repair the evaluation result to make
 -			the return objects more ACPI specification compliant.
 -			This option is useful for developers to identify the
 -			root cause of an AML interpreter issue when the issue
 -			has something to do with the repair mechanism.
++>>>>>>> a94e88cdd805 (ACPICA: Tables: Avoid SSDT installation with acpi_gbl_disable_ssdt_table_load.)
  
  	acpi_os_name=	[HW,ACPI] Tell ACPI BIOS the name of the OS
  			Format: To spoof as Windows 98: ="Microsoft Windows"
diff --cc drivers/acpi/acpica/acglobal.h
index 38796f430f23,0cac564ffe93..000000000000
--- a/drivers/acpi/acpica/acglobal.h
+++ b/drivers/acpi/acpica/acglobal.h
@@@ -130,28 -157,19 +130,32 @@@ u8 ACPI_INIT_GLOBAL(acpi_gbl_truncate_i
   * Disable runtime checking and repair of values returned by control methods.
   * Use only if the repair is causing a problem on a particular machine.
   */
 -ACPI_INIT_GLOBAL(u8, acpi_gbl_disable_auto_repair, FALSE);
 +u8 ACPI_INIT_GLOBAL(acpi_gbl_disable_auto_repair, FALSE);
  
  /*
-  * Optionally do not load any SSDTs from the RSDT/XSDT during initialization.
+  * Optionally do not install any SSDTs from the RSDT/XSDT during initialization.
   * This can be useful for debugging ACPI problems on some machines.
   */
++<<<<<<< HEAD
 +u8 ACPI_INIT_GLOBAL(acpi_gbl_disable_ssdt_table_load, FALSE);
 +
 +/* acpi_gbl_FADT is a local copy of the FADT, converted to a common format. */
 +
 +struct acpi_table_fadt acpi_gbl_FADT;
 +u32 acpi_current_gpe_count;
 +u32 acpi_gbl_trace_flags;
 +acpi_name acpi_gbl_trace_method_name;
 +u8 acpi_gbl_system_awake_and_running;
++=======
+ ACPI_INIT_GLOBAL(u8, acpi_gbl_disable_ssdt_table_install, FALSE);
++>>>>>>> a94e88cdd805 (ACPICA: Tables: Avoid SSDT installation with acpi_gbl_disable_ssdt_table_load.)
  
  /*
 - * We keep track of the latest version of Windows that has been requested by
 - * the BIOS.
 + * ACPI 5.0 introduces the concept of a "reduced hardware platform", meaning
 + * that the ACPI hardware is no longer required. A flag in the FADT indicates
 + * a reduced HW machine, and that flag is duplicated here for convenience.
   */
 -ACPI_INIT_GLOBAL(u8, acpi_gbl_osi_data, 0);
 +u8 acpi_gbl_reduced_hardware;
  
  #endif				/* DEFINE_ACPI_GLOBALS */
  
diff --cc drivers/acpi/acpica/tbinstal.c
index 4024bfc5fa21,de10d3245d9c..000000000000
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@@ -130,105 -566,117 +130,166 @@@ acpi_tb_add_table(struct acpi_table_des
  {
  	u32 i;
  	acpi_status status = AE_OK;
 -	struct acpi_table_desc new_table_desc;
  
 -	ACPI_FUNCTION_TRACE(tb_install_non_fixed_table);
 +	ACPI_FUNCTION_TRACE(tb_add_table);
  
++<<<<<<< HEAD
 +	if (!table_desc->pointer) {
 +		status = acpi_tb_verify_table(table_desc);
 +		if (ACPI_FAILURE(status) || !table_desc->pointer) {
 +			acpi_tb_invalidate_table(table_desc);
 +			return_ACPI_STATUS(status);
++=======
+ 	/* Acquire a temporal table descriptor for validation */
+ 
+ 	status =
+ 	    acpi_tb_acquire_temporal_table(&new_table_desc, address, flags);
+ 	if (ACPI_FAILURE(status)) {
+ 		ACPI_ERROR((AE_INFO, "Could not acquire table length at %p",
+ 			    ACPI_CAST_PTR(void, address)));
+ 		return_ACPI_STATUS(status);
+ 	}
+ 
+ 	/*
+ 	 * Optionally do not load any SSDTs from the RSDT/XSDT. This can
+ 	 * be useful for debugging ACPI problems on some machines.
+ 	 */
+ 	if (!reload && acpi_gbl_disable_ssdt_table_install &&
+ 	    ACPI_COMPARE_NAME(&new_table_desc.signature, ACPI_SIG_SSDT)) {
+ 		ACPI_INFO((AE_INFO, "Ignoring installation of %4.4s at %p",
+ 			   new_table_desc.signature.ascii, ACPI_CAST_PTR(void,
+ 									 address)));
+ 		goto release_and_exit;
+ 	}
+ 
+ 	/* Validate and verify a table before installation */
+ 
+ 	status = acpi_tb_verify_table(&new_table_desc, NULL);
+ 	if (ACPI_FAILURE(status)) {
+ 		goto release_and_exit;
+ 	}
+ 
+ 	if (reload) {
+ 		/*
+ 		 * Validate the incoming table signature.
+ 		 *
+ 		 * 1) Originally, we checked the table signature for "SSDT" or "PSDT".
+ 		 * 2) We added support for OEMx tables, signature "OEM".
+ 		 * 3) Valid tables were encountered with a null signature, so we just
+ 		 *    gave up on validating the signature, (05/2008).
+ 		 * 4) We encountered non-AML tables such as the MADT, which caused
+ 		 *    interpreter errors and kernel faults. So now, we once again allow
+ 		 *    only "SSDT", "OEMx", and now, also a null signature. (05/2011).
+ 		 */
+ 		if ((new_table_desc.signature.ascii[0] != 0x00) &&
+ 		    (!ACPI_COMPARE_NAME
+ 		     (&new_table_desc.signature, ACPI_SIG_SSDT))
+ 		    && (ACPI_STRNCMP(new_table_desc.signature.ascii, "OEM", 3)))
+ 		{
+ 			ACPI_BIOS_ERROR((AE_INFO,
+ 					 "Table has invalid signature [%4.4s] (0x%8.8X), "
+ 					 "must be SSDT or OEMx",
+ 					 acpi_ut_valid_acpi_name(new_table_desc.
+ 								 signature.
+ 								 ascii) ?
+ 					 new_table_desc.signature.
+ 					 ascii : "????",
+ 					 new_table_desc.signature.integer));
+ 
+ 			status = AE_BAD_SIGNATURE;
+ 			goto release_and_exit;
++>>>>>>> a94e88cdd805 (ACPICA: Tables: Avoid SSDT installation with acpi_gbl_disable_ssdt_table_load.)
  		}
 +	}
  
 -		/* Check if table is already registered */
 +	/*
 +	 * Validate the incoming table signature.
 +	 *
 +	 * 1) Originally, we checked the table signature for "SSDT" or "PSDT".
 +	 * 2) We added support for OEMx tables, signature "OEM".
 +	 * 3) Valid tables were encountered with a null signature, so we just
 +	 *    gave up on validating the signature, (05/2008).
 +	 * 4) We encountered non-AML tables such as the MADT, which caused
 +	 *    interpreter errors and kernel faults. So now, we once again allow
 +	 *    only "SSDT", "OEMx", and now, also a null signature. (05/2011).
 +	 */
 +	if ((table_desc->pointer->signature[0] != 0x00) &&
 +	    (!ACPI_COMPARE_NAME(table_desc->pointer->signature, ACPI_SIG_SSDT))
 +	    && (ACPI_STRNCMP(table_desc->pointer->signature, "OEM", 3))) {
 +		ACPI_BIOS_ERROR((AE_INFO,
 +				 "Table has invalid signature [%4.4s] (0x%8.8X), "
 +				 "must be SSDT or OEMx",
 +				 acpi_ut_valid_acpi_name(table_desc->pointer->
 +							 signature) ?
 +				 table_desc->pointer->signature : "????",
 +				 *(u32 *)table_desc->pointer->signature));
 +
 +		return_ACPI_STATUS(AE_BAD_SIGNATURE);
 +	}
 +
 +	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
  
 -		for (i = 0; i < acpi_gbl_root_table_list.current_table_count;
 -		     ++i) {
 -			/*
 -			 * Check for a table match on the entire table length,
 -			 * not just the header.
 -			 */
 -			if (!acpi_tb_is_equivalent_table(&new_table_desc, i)) {
 +	/* Check if table is already registered */
 +
 +	for (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {
 +		if (!acpi_gbl_root_table_list.tables[i].pointer) {
 +			status =
 +			    acpi_tb_verify_table(&acpi_gbl_root_table_list.
 +						 tables[i]);
 +			if (ACPI_FAILURE(status)
 +			    || !acpi_gbl_root_table_list.tables[i].pointer) {
  				continue;
  			}
 +		}
  
 -			/*
 -			 * Note: the current mechanism does not unregister a table if it is
 -			 * dynamically unloaded. The related namespace entries are deleted,
 -			 * but the table remains in the root table list.
 -			 *
 -			 * The assumption here is that the number of different tables that
 -			 * will be loaded is actually small, and there is minimal overhead
 -			 * in just keeping the table in case it is needed again.
 -			 *
 -			 * If this assumption changes in the future (perhaps on large
 -			 * machines with many table load/unload operations), tables will
 -			 * need to be unregistered when they are unloaded, and slots in the
 -			 * root table list should be reused when empty.
 -			 */
 -			if (acpi_gbl_root_table_list.tables[i].
 -			    flags & ACPI_TABLE_IS_LOADED) {
 -
 -				/* Table is still loaded, this is an error */
 -
 -				status = AE_ALREADY_EXISTS;
 -				goto release_and_exit;
 -			} else {
 -				/*
 -				 * Table was unloaded, allow it to be reloaded.
 -				 * As we are going to return AE_OK to the caller, we should
 -				 * take the responsibility of freeing the input descriptor.
 -				 * Refill the input descriptor to ensure
 -				 * acpi_tb_install_and_override_table() can be called again to
 -				 * indicate the re-installation.
 -				 */
 -				acpi_tb_uninstall_table(&new_table_desc);
 -				*table_index = i;
 -				(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
 -				return_ACPI_STATUS(AE_OK);
 -			}
 +		/*
 +		 * Check for a table match on the entire table length,
 +		 * not just the header.
 +		 */
 +		if (table_desc->length !=
 +		    acpi_gbl_root_table_list.tables[i].length) {
 +			continue;
 +		}
 +
 +		if (ACPI_MEMCMP(table_desc->pointer,
 +				acpi_gbl_root_table_list.tables[i].pointer,
 +				acpi_gbl_root_table_list.tables[i].length)) {
 +			continue;
 +		}
 +
 +		/*
 +		 * Note: the current mechanism does not unregister a table if it is
 +		 * dynamically unloaded. The related namespace entries are deleted,
 +		 * but the table remains in the root table list.
 +		 *
 +		 * The assumption here is that the number of different tables that
 +		 * will be loaded is actually small, and there is minimal overhead
 +		 * in just keeping the table in case it is needed again.
 +		 *
 +		 * If this assumption changes in the future (perhaps on large
 +		 * machines with many table load/unload operations), tables will
 +		 * need to be unregistered when they are unloaded, and slots in the
 +		 * root table list should be reused when empty.
 +		 */
 +		*table_index = i;
 +
 +		if (acpi_gbl_root_table_list.tables[i].
 +		    flags & ACPI_TABLE_IS_LOADED) {
 +
 +			/* Table is still loaded, this is an error */
 +
 +			status = AE_ALREADY_EXISTS;
 +			goto release;
 +		} else {
 +			/* Table was unloaded, allow it to be reloaded */
 +
 +			acpi_tb_delete_table(table_desc);
 +			table_desc->pointer =
 +			    acpi_gbl_root_table_list.tables[i].pointer;
 +			table_desc->address =
 +			    acpi_gbl_root_table_list.tables[i].address;
 +			status = AE_OK;
 +			goto print_header;
  		}
  	}
  
diff --cc include/acpi/acpixf.h
index 4f88d18b72e7,2280c190536d..000000000000
--- a/include/acpi/acpixf.h
+++ b/include/acpi/acpixf.h
@@@ -71,17 -71,19 +71,29 @@@ extern u32 acpi_dbg_layer
  
  /* ACPICA runtime options */
  
 -extern u8 acpi_gbl_auto_serialize_methods;
 -extern u8 acpi_gbl_copy_dsdt_locally;
 +extern u8 acpi_gbl_enable_interpreter_slack;
 +extern u8 acpi_gbl_all_methods_serialized;
  extern u8 acpi_gbl_create_osi_method;
 +extern u8 acpi_gbl_use_default_register_widths;
 +extern acpi_name acpi_gbl_trace_method_name;
 +extern u32 acpi_gbl_trace_flags;
 +extern bool acpi_gbl_enable_aml_debug_object;
 +extern u8 acpi_gbl_copy_dsdt_locally;
 +extern u8 acpi_gbl_truncate_io_addresses;
  extern u8 acpi_gbl_disable_auto_repair;
++<<<<<<< HEAD
 +extern u8 acpi_gbl_disable_ssdt_table_load;
++=======
+ extern u8 acpi_gbl_disable_ssdt_table_install;
+ extern u8 acpi_gbl_do_not_use_xsdt;
+ extern u8 acpi_gbl_enable_aml_debug_object;
+ extern u8 acpi_gbl_enable_interpreter_slack;
+ extern u32 acpi_gbl_trace_flags;
+ extern acpi_name acpi_gbl_trace_method_name;
+ extern u8 acpi_gbl_truncate_io_addresses;
+ extern u8 acpi_gbl_use32_bit_fadt_addresses;
+ extern u8 acpi_gbl_use_default_register_widths;
++>>>>>>> a94e88cdd805 (ACPICA: Tables: Avoid SSDT installation with acpi_gbl_disable_ssdt_table_load.)
  
  /*
   * Hardware-reduced prototypes. All interfaces that use these macros will
* Unmerged path Documentation/kernel-parameters.txt
* Unmerged path drivers/acpi/acpica/acglobal.h
* Unmerged path drivers/acpi/acpica/tbinstal.c
diff --git a/drivers/acpi/acpica/tbxfload.c b/drivers/acpi/acpica/tbxfload.c
index 2620dbe96cfa..4e6d3455abdc 100644
--- a/drivers/acpi/acpica/tbxfload.c
+++ b/drivers/acpi/acpica/tbxfload.c
@@ -179,19 +179,6 @@ static acpi_status acpi_tb_load_namespace(void)
 			continue;
 		}
 
-		/*
-		 * Optionally do not load any SSDTs from the RSDT/XSDT. This can
-		 * be useful for debugging ACPI problems on some machines.
-		 */
-		if (acpi_gbl_disable_ssdt_table_load) {
-			ACPI_INFO((AE_INFO, "Ignoring %4.4s at %p",
-				   acpi_gbl_root_table_list.tables[i].signature.
-				   ascii, ACPI_CAST_PTR(void,
-							acpi_gbl_root_table_list.
-							tables[i].address)));
-			continue;
-		}
-
 		/* Ignore errors while loading tables, get as many as possible */
 
 		(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);
diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index f3f3d673d99f..167afd5f464f 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -1735,16 +1735,15 @@ acpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)
 }
 #endif
 
-static int __init acpi_no_auto_ssdt_setup(char *s)
+static int __init acpi_no_static_ssdt_setup(char *s)
 {
-        printk(KERN_NOTICE PREFIX "SSDT auto-load disabled\n");
+	acpi_gbl_disable_ssdt_table_install = TRUE;
+	pr_info("ACPI: static SSDT installation disabled\n");
 
-        acpi_gbl_disable_ssdt_table_load = TRUE;
-
-        return 1;
+	return 0;
 }
 
-__setup("acpi_no_auto_ssdt", acpi_no_auto_ssdt_setup);
+early_param("acpi_no_static_ssdt", acpi_no_static_ssdt_setup);
 
 acpi_status __init acpi_os_initialize(void)
 {
* Unmerged path include/acpi/acpixf.h
