crypto: ccp - Use precalculated hash from headers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] ccp - Use precalculated hash from headers (Suravee Suthikulpanit) [1390820]
Rebuild_FUZZ: 91.11%
commit-author LABBE Corentin <clabbe.montjoie@gmail.com>
commit bdd75064d2b2068007f4fc5e26ac726e8617a090
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/bdd75064.failed

Precalculated hash for empty message are now present in hash headers.
This patch just use them.

	Signed-off-by: LABBE Corentin <clabbe.montjoie@gmail.com>
	Tested-by: Tom Lendacky <thomas.lendacky@amd.com>
	Acked-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit bdd75064d2b2068007f4fc5e26ac726e8617a090)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/ccp/Kconfig
#	drivers/crypto/ccp/ccp-ops.c
diff --cc drivers/crypto/ccp/ccp-ops.c
index 23dbb41465d1,6613aee79b87..000000000000
--- a/drivers/crypto/ccp/ccp-ops.c
+++ b/drivers/crypto/ccp/ccp-ops.c
@@@ -131,30 -131,25 +131,52 @@@ struct ccp_op 
  	} u;
  };
  
++<<<<<<< HEAD
 +/* The CCP cannot perform zero-length sha operations so the caller
 + * is required to buffer data for the final operation.  However, a
 + * sha operation for a message with a total length of zero is valid
 + * so known values are required to supply the result.
 + */
 +static const u8 ccp_sha1_zero[CCP_SHA_CTXSIZE] = {
 +	0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d,
 +	0x32, 0x55, 0xbf, 0xef, 0x95, 0x60, 0x18, 0x90,
 +	0xaf, 0xd8, 0x07, 0x09, 0x00, 0x00, 0x00, 0x00,
 +	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 +};
 +
 +static const u8 ccp_sha224_zero[CCP_SHA_CTXSIZE] = {
 +	0xd1, 0x4a, 0x02, 0x8c, 0x2a, 0x3a, 0x2b, 0xc9,
 +	0x47, 0x61, 0x02, 0xbb, 0x28, 0x82, 0x34, 0xc4,
 +	0x15, 0xa2, 0xb0, 0x1f, 0x82, 0x8e, 0xa6, 0x2a,
 +	0xc5, 0xb3, 0xe4, 0x2f, 0x00, 0x00, 0x00, 0x00,
 +};
 +
 +static const u8 ccp_sha256_zero[CCP_SHA_CTXSIZE] = {
 +	0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14,
 +	0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,
 +	0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,
 +	0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55,
++=======
+ /* SHA initial context values */
+ static const __be32 ccp_sha1_init[CCP_SHA_CTXSIZE / sizeof(__be32)] = {
+ 	cpu_to_be32(SHA1_H0), cpu_to_be32(SHA1_H1),
+ 	cpu_to_be32(SHA1_H2), cpu_to_be32(SHA1_H3),
+ 	cpu_to_be32(SHA1_H4), 0, 0, 0,
+ };
+ 
+ static const __be32 ccp_sha224_init[CCP_SHA_CTXSIZE / sizeof(__be32)] = {
+ 	cpu_to_be32(SHA224_H0), cpu_to_be32(SHA224_H1),
+ 	cpu_to_be32(SHA224_H2), cpu_to_be32(SHA224_H3),
+ 	cpu_to_be32(SHA224_H4), cpu_to_be32(SHA224_H5),
+ 	cpu_to_be32(SHA224_H6), cpu_to_be32(SHA224_H7),
+ };
+ 
+ static const __be32 ccp_sha256_init[CCP_SHA_CTXSIZE / sizeof(__be32)] = {
+ 	cpu_to_be32(SHA256_H0), cpu_to_be32(SHA256_H1),
+ 	cpu_to_be32(SHA256_H2), cpu_to_be32(SHA256_H3),
+ 	cpu_to_be32(SHA256_H4), cpu_to_be32(SHA256_H5),
+ 	cpu_to_be32(SHA256_H6), cpu_to_be32(SHA256_H7),
++>>>>>>> bdd75064d2b2 (crypto: ccp - Use precalculated hash from headers)
  };
  
  static u32 ccp_addr_lo(struct ccp_dma_info *info)
* Unmerged path drivers/crypto/ccp/Kconfig
* Unmerged path drivers/crypto/ccp/Kconfig
* Unmerged path drivers/crypto/ccp/ccp-ops.c
