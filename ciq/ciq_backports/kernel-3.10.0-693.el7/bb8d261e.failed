nvme: introduce a controller state machine

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [nvme] introduce a controller state machine (David Milburn) [1384066]
Rebuild_FUZZ: 92.31%
commit-author Christoph Hellwig <hch@lst.de>
commit bb8d261e088811ef2b564d745afcd1633428010a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/bb8d261e.failed

Replace the adhoc flags in the PCI driver with a state machine in the
core code.  Based on code from Sagi Grimberg for the Fabrics driver.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Acked-by Jon Derrick: <jonathan.derrick@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit bb8d261e088811ef2b564d745afcd1633428010a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/nvme.h
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/nvme.h
index b4cca1f4b0ba,4135626a3d6f..000000000000
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@@ -60,22 -65,18 +60,33 @@@ enum nvme_quirks 
  	 * logical blocks.
  	 */
  	NVME_QUIRK_DISCARD_ZEROES		= (1 << 2),
 +
 +	/*
 +	 * The controller needs a delay before starts checking the device
 +	 * readiness, which is done by reading the NVME_CSTS_RDY bit.
 +	 */
 +	NVME_QUIRK_DELAY_BEFORE_CHK_RDY		= (1 << 3),
  };
  
++<<<<<<< HEAD
 +/* The below value is the specific amount of delay needed before checking
 + * readiness in case of the PCI_DEVICE(0x1c58, 0x0003), which needs the
 + * NVME_QUIRK_DELAY_BEFORE_CHK_RDY quirk enabled. The value (in ms) was
 + * found empirically.
 + */
 +#define NVME_QUIRK_DELAY_AMOUNT		2000
++=======
+ enum nvme_ctrl_state {
+ 	NVME_CTRL_NEW,
+ 	NVME_CTRL_LIVE,
+ 	NVME_CTRL_RESETTING,
+ 	NVME_CTRL_DELETING,
+ };
++>>>>>>> bb8d261e0888 (nvme: introduce a controller state machine)
  
  struct nvme_ctrl {
+ 	enum nvme_ctrl_state state;
+ 	spinlock_t lock;
  	const struct nvme_ctrl_ops *ops;
  	struct request_queue *admin_q;
  	struct device *dev;
diff --cc drivers/nvme/host/pci.c
index b6cb5e36606f,0cee23651aa7..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -855,8 -895,8 +849,13 @@@ static enum blk_eh_timer_return nvme_ti
  	 * cancellation error. All outstanding requests are completed on
  	 * shutdown, so we return BLK_EH_HANDLED.
  	 */
++<<<<<<< HEAD
 +	if (test_bit(NVME_CTRL_RESETTING, &dev->flags)) {
 +		dev_warn(dev->dev,
++=======
+ 	if (dev->ctrl.state == NVME_CTRL_RESETTING) {
+ 		dev_warn(dev->ctrl.device,
++>>>>>>> bb8d261e0888 (nvme: introduce a controller state machine)
  			 "I/O %d QID %d timeout, disable controller\n",
  			 req->tag, nvmeq->qid);
  		nvme_dev_disable(dev, false);
@@@ -1796,10 -1839,8 +1795,15 @@@ static void nvme_reset_work(struct work
  	if (dev->ctrl.ctrl_config & NVME_CC_ENABLE)
  		nvme_dev_disable(dev, false);
  
++<<<<<<< HEAD
 +	if (test_bit(NVME_CTRL_REMOVING, &dev->flags))
 +		goto out;
 +
 +	set_bit(NVME_CTRL_RESETTING, &dev->flags);
++=======
+ 	if (!nvme_change_ctrl_state(&dev->ctrl, NVME_CTRL_RESETTING))
+ 		goto out;
++>>>>>>> bb8d261e0888 (nvme: introduce a controller state machine)
  
  	result = nvme_pci_enable(dev);
  	if (result)
@@@ -2016,10 -2063,12 +2023,17 @@@ static void nvme_remove(struct pci_dev 
  {
  	struct nvme_dev *dev = pci_get_drvdata(pdev);
  
++<<<<<<< HEAD
 +	set_bit(NVME_CTRL_REMOVING, &dev->flags);
++=======
+ 	del_timer_sync(&dev->watchdog_timer);
+ 
+ 	nvme_change_ctrl_state(&dev->ctrl, NVME_CTRL_DELETING);
+ 
++>>>>>>> bb8d261e0888 (nvme: introduce a controller state machine)
  	pci_set_drvdata(pdev, NULL);
  	flush_work(&dev->async_work);
 +	flush_work(&dev->reset_work);
  	flush_work(&dev->scan_work);
  	nvme_remove_namespaces(&dev->ctrl);
  	nvme_uninit_ctrl(&dev->ctrl);
diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index b3ed604adce1..097ed4ef56bd 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -56,6 +56,55 @@ DEFINE_SPINLOCK(dev_list_lock);
 
 static struct class *nvme_class;
 
+bool nvme_change_ctrl_state(struct nvme_ctrl *ctrl,
+		enum nvme_ctrl_state new_state)
+{
+	enum nvme_ctrl_state old_state = ctrl->state;
+	bool changed = false;
+
+	spin_lock_irq(&ctrl->lock);
+	switch (new_state) {
+	case NVME_CTRL_LIVE:
+		switch (old_state) {
+		case NVME_CTRL_RESETTING:
+			changed = true;
+			/* FALLTHRU */
+		default:
+			break;
+		}
+		break;
+	case NVME_CTRL_RESETTING:
+		switch (old_state) {
+		case NVME_CTRL_NEW:
+		case NVME_CTRL_LIVE:
+			changed = true;
+			/* FALLTHRU */
+		default:
+			break;
+		}
+		break;
+	case NVME_CTRL_DELETING:
+		switch (old_state) {
+		case NVME_CTRL_LIVE:
+		case NVME_CTRL_RESETTING:
+			changed = true;
+			/* FALLTHRU */
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+	spin_unlock_irq(&ctrl->lock);
+
+	if (changed)
+		ctrl->state = new_state;
+
+	return changed;
+}
+EXPORT_SYMBOL_GPL(nvme_change_ctrl_state);
+
 static void nvme_free_ns(struct kref *kref)
 {
 	struct nvme_ns *ns = container_of(kref, struct nvme_ns, kref);
@@ -1436,6 +1485,8 @@ int nvme_init_ctrl(struct nvme_ctrl *ctrl, struct device *dev,
 {
 	int ret;
 
+	ctrl->state = NVME_CTRL_NEW;
+	spin_lock_init(&ctrl->lock);
 	INIT_LIST_HEAD(&ctrl->namespaces);
 	mutex_init(&ctrl->namespaces_mutex);
 	kref_init(&ctrl->kref);
* Unmerged path drivers/nvme/host/nvme.h
* Unmerged path drivers/nvme/host/pci.c
