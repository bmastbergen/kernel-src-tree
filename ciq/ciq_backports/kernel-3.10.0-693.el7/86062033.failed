net_sched: act: hide struct tcf_common from API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: act: hide struct tcf_common from API (Ivan Vecera) [1428588]
Rebuild_FUZZ: 95.56%
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit 86062033feb8a1692f7a3d570c652f1b4a4b4b52
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/86062033.failed

Now we can totally hide it from modules. tcf_hash_*() API's
will operate on struct tc_action, modules don't need to care about
the details.

	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Cc: David S. Miller <davem@davemloft.net>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 86062033feb8a1692f7a3d570c652f1b4a4b4b52)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/act_api.h
#	net/sched/act_api.c
#	net/sched/act_csum.c
#	net/sched/act_gact.c
#	net/sched/act_ipt.c
#	net/sched/act_mirred.c
#	net/sched/act_nat.c
#	net/sched/act_pedit.c
#	net/sched/act_police.c
#	net/sched/act_simple.c
#	net/sched/act_skbedit.c
diff --cc include/net/act_api.h
index 11aac9abd0ca,24ae910609ce..000000000000
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@@ -77,18 -97,15 +77,30 @@@ struct tc_action_ops 
  	int     (*walk)(struct sk_buff *, struct netlink_callback *, int, struct tc_action *);
  };
  
++<<<<<<< HEAD
 +struct tcf_common *tcf_hash_lookup(u32 index, struct tcf_hashinfo *hinfo);
 +void tcf_hash_destroy(struct tcf_common *p, struct tcf_hashinfo *hinfo);
 +int tcf_hash_release(struct tcf_common *p, int bind,
 +		     struct tcf_hashinfo *hinfo);
 +u32 tcf_hash_new_index(u32 *idx_gen, struct tcf_hashinfo *hinfo);
 +struct tcf_common *tcf_hash_check(u32 index, struct tc_action *a,
 +				  int bind, struct tcf_hashinfo *hinfo);
 +struct tcf_common *tcf_hash_create(u32 index, struct nlattr *est,
 +				   struct tc_action *a, int size,
 +				   int bind, u32 *idx_gen,
 +				   struct tcf_hashinfo *hinfo);
 +void tcf_hash_insert(struct tcf_common *p, struct tcf_hashinfo *hinfo);
++=======
+ int tcf_hash_search(struct tc_action *a, u32 index);
+ void tcf_hash_destroy(struct tc_action *a);
+ int tcf_hash_release(struct tc_action *a, int bind);
+ u32 tcf_hash_new_index(struct tcf_hashinfo *hinfo);
+ int tcf_hash_check(u32 index, struct tc_action *a, int bind);
+ int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
+ 		    int size, int bind);
+ void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est);
+ void tcf_hash_insert(struct tc_action *a);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  
  int tcf_register_action(struct tc_action_ops *a);
  int tcf_unregister_action(struct tc_action_ops *a);
diff --cc net/sched/act_api.c
index 34e255487d7a,4f2b807b3621..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -27,27 -27,21 +27,43 @@@
  #include <net/act_api.h>
  #include <net/netlink.h>
  
- void tcf_hash_destroy(struct tcf_common *p, struct tcf_hashinfo *hinfo)
+ void tcf_hash_destroy(struct tc_action *a)
  {
++<<<<<<< HEAD
 +	unsigned int h = tcf_hash(p->tcfc_index, hinfo->hmask);
 +	struct tcf_common **p1p;
 +
 +	for (p1p = &hinfo->htab[h]; *p1p; p1p = &(*p1p)->tcfc_next) {
 +		if (*p1p == p) {
 +			write_lock_bh(hinfo->lock);
 +			*p1p = p->tcfc_next;
 +			write_unlock_bh(hinfo->lock);
 +			gen_kill_estimator(&p->tcfc_bstats,
 +					   &p->tcfc_rate_est);
 +			/*
 +			 * gen_estimator est_timer() might access p->tcfc_lock
 +			 * or bstats, wait a RCU grace period before freeing p
 +			 */
 +			kfree_rcu(p, tcfc_rcu);
 +			return;
 +		}
 +	}
 +	WARN_ON(1);
++=======
+ 	struct tcf_common *p = a->priv;
+ 	struct tcf_hashinfo *hinfo = a->ops->hinfo;
+ 
+ 	spin_lock_bh(&hinfo->lock);
+ 	hlist_del(&p->tcfc_head);
+ 	spin_unlock_bh(&hinfo->lock);
+ 	gen_kill_estimator(&p->tcfc_bstats,
+ 			   &p->tcfc_rate_est);
+ 	/*
+ 	 * gen_estimator est_timer() might access p->tcfc_lock
+ 	 * or bstats, wait a RCU grace period before freeing p
+ 	 */
+ 	kfree_rcu(p, tcfc_rcu);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  }
  EXPORT_SYMBOL(tcf_hash_destroy);
  
@@@ -130,14 -128,13 +146,21 @@@ static int tcf_del_walker(struct sk_buf
  	if (nla_put_string(skb, TCA_KIND, a->ops->kind))
  		goto nla_put_failure;
  	for (i = 0; i < (hinfo->hmask + 1); i++) {
++<<<<<<< HEAD
 +		p = hinfo->htab[tcf_hash(i, hinfo->hmask)];
 +
 +		while (p != NULL) {
 +			s_p = p->tcfc_next;
 +			if (ACT_P_DELETED == tcf_hash_release(p, 0, hinfo))
++=======
+ 		head = &hinfo->htab[tcf_hash(i, hinfo->hmask)];
+ 		hlist_for_each_entry_safe(p, n, head, tcfc_head) {
+ 			a->priv = p;
+ 			if (ACT_P_DELETED == tcf_hash_release(a, 0)) {
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  				module_put(a->ops->owner);
 -				n_i++;
 -			}
 +			n_i++;
 +			p = s_p;
  		}
  	}
  	if (nla_put_u32(skb, TCA_FCNT, n_i))
@@@ -206,10 -200,11 +229,14 @@@ static int tcf_hash_search(struct tc_ac
  	}
  	return 0;
  }
 -EXPORT_SYMBOL(tcf_hash_search);
  
++<<<<<<< HEAD
 +struct tcf_common *tcf_hash_check(u32 index, struct tc_action *a, int bind,
 +				  struct tcf_hashinfo *hinfo)
++=======
+ int tcf_hash_check(u32 index, struct tc_action *a, int bind)
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  {
 -	struct tcf_hashinfo *hinfo = a->ops->hinfo;
  	struct tcf_common *p = NULL;
  	if (index && (p = tcf_hash_lookup(index, hinfo)) != NULL) {
  		if (bind)
@@@ -221,10 -217,20 +249,25 @@@
  }
  EXPORT_SYMBOL(tcf_hash_check);
  
++<<<<<<< HEAD
 +struct tcf_common *tcf_hash_create(u32 index, struct nlattr *est,
 +				   struct tc_action *a, int size, int bind,
 +				   u32 *idx_gen, struct tcf_hashinfo *hinfo)
++=======
+ void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est)
+ {
+ 	struct tcf_common *pc = a->priv;
+ 	if (est)
+ 		gen_kill_estimator(&pc->tcfc_bstats,
+ 				   &pc->tcfc_rate_est);
+ 	kfree_rcu(pc, tcfc_rcu);
+ }
+ EXPORT_SYMBOL(tcf_hash_cleanup);
+ 
+ int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
+ 		    int size, int bind)
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  {
 -	struct tcf_hashinfo *hinfo = a->ops->hinfo;
  	struct tcf_common *p = kzalloc(size, GFP_KERNEL);
  
  	if (unlikely(!p))
@@@ -251,14 -258,15 +294,16 @@@
  }
  EXPORT_SYMBOL(tcf_hash_create);
  
- void tcf_hash_insert(struct tcf_common *p, struct tcf_hashinfo *hinfo)
+ void tcf_hash_insert(struct tc_action *a)
  {
+ 	struct tcf_common *p = a->priv;
+ 	struct tcf_hashinfo *hinfo = a->ops->hinfo;
  	unsigned int h = tcf_hash(p->tcfc_index, hinfo->hmask);
  
 -	spin_lock_bh(&hinfo->lock);
 -	hlist_add_head(&p->tcfc_head, &hinfo->htab[h]);
 -	spin_unlock_bh(&hinfo->lock);
 +	write_lock_bh(hinfo->lock);
 +	p->tcfc_next = hinfo->htab[h];
 +	hinfo->htab[h] = p;
 +	write_unlock_bh(hinfo->lock);
  }
  EXPORT_SYMBOL(tcf_hash_insert);
  
diff --cc net/sched/act_csum.c
index 11fe1a416433,f0f6e7a625d1..000000000000
--- a/net/sched/act_csum.c
+++ b/net/sched/act_csum.c
@@@ -71,17 -62,15 +70,28 @@@ static int tcf_csum_init(struct net *n
  		return -EINVAL;
  	parm = nla_data(tb[TCA_CSUM_PARMS]);
  
++<<<<<<< HEAD
 +	pc = tcf_hash_check(parm->index, a, bind, &csum_hash_info);
 +	if (!pc) {
 +		pc = tcf_hash_create(parm->index, est, a, sizeof(*p), bind,
 +				     &csum_idx_gen, &csum_hash_info);
 +		if (IS_ERR(pc))
 +			return PTR_ERR(pc);
++=======
+ 	if (!tcf_hash_check(parm->index, a, bind)) {
+ 		ret = tcf_hash_create(parm->index, est, a, sizeof(*p), bind);
+ 		if (ret)
+ 			return ret;
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  		ret = ACT_P_CREATED;
  	} else {
  		if (bind)/* dont override defaults */
  			return 0;
++<<<<<<< HEAD
 +		tcf_hash_release(pc, bind, &csum_hash_info);
++=======
+ 		tcf_hash_release(a, bind);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -93,7 -82,7 +103,11 @@@
  	spin_unlock_bh(&p->tcf_lock);
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(pc, &csum_hash_info);
++=======
+ 		tcf_hash_insert(a);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  
  	return ret;
  }
diff --cc net/sched/act_gact.c
index eb9ba60ebab4,af6c0acd9bf1..000000000000
--- a/net/sched/act_gact.c
+++ b/net/sched/act_gact.c
@@@ -94,17 -85,15 +93,28 @@@ static int tcf_gact_init(struct net *ne
  	}
  #endif
  
++<<<<<<< HEAD
 +	pc = tcf_hash_check(parm->index, a, bind, &gact_hash_info);
 +	if (!pc) {
 +		pc = tcf_hash_create(parm->index, est, a, sizeof(*gact),
 +				     bind, &gact_idx_gen, &gact_hash_info);
 +		if (IS_ERR(pc))
 +			return PTR_ERR(pc);
++=======
+ 	if (!tcf_hash_check(parm->index, a, bind)) {
+ 		ret = tcf_hash_create(parm->index, est, a, sizeof(*gact), bind);
+ 		if (ret)
+ 			return ret;
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  		ret = ACT_P_CREATED;
  	} else {
  		if (bind)/* dont override defaults */
  			return 0;
++<<<<<<< HEAD
 +		tcf_hash_release(pc, bind, &gact_hash_info);
++=======
+ 		tcf_hash_release(a, bind);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -122,19 -111,10 +132,26 @@@
  #endif
  	spin_unlock_bh(&gact->tcf_lock);
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(pc, &gact_hash_info);
 +	return ret;
 +}
 +
 +static int tcf_gact_cleanup(struct tc_action *a, int bind)
 +{
 +	struct tcf_gact *gact = a->priv;
 +
 +	if (gact)
 +		return tcf_hash_release(&gact->common, bind, &gact_hash_info);
 +	return 0;
 +}
 +
++=======
+ 		tcf_hash_insert(a);
+ 	return ret;
+ }
+ 
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  static int tcf_gact(struct sk_buff *skb, const struct tc_action *a,
  		    struct tcf_result *res)
  {
diff --cc net/sched/act_ipt.c
index 90a973aacc76,f5e69782d400..000000000000
--- a/net/sched/act_ipt.c
+++ b/net/sched/act_ipt.c
@@@ -134,12 -125,10 +134,19 @@@ static int tcf_ipt_init(struct net *net
  	if (tb[TCA_IPT_INDEX] != NULL)
  		index = nla_get_u32(tb[TCA_IPT_INDEX]);
  
++<<<<<<< HEAD
 +	pc = tcf_hash_check(index, a, bind, &ipt_hash_info);
 +	if (!pc) {
 +		pc = tcf_hash_create(index, est, a, sizeof(*ipt), bind,
 +				     &ipt_idx_gen, &ipt_hash_info);
 +		if (IS_ERR(pc))
 +			return PTR_ERR(pc);
++=======
+ 	if (!tcf_hash_check(index, a, bind) ) {
+ 		ret = tcf_hash_create(index, est, a, sizeof(*ipt), bind);
+ 		if (ret)
+ 			return ret;
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  		ret = ACT_P_CREATED;
  	} else {
  		if (bind)/* dont override defaults */
@@@ -180,7 -169,7 +187,11 @@@
  	ipt->tcfi_hook  = hook;
  	spin_unlock_bh(&ipt->tcf_lock);
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(pc, &ipt_hash_info);
++=======
+ 		tcf_hash_insert(a);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  	return ret;
  
  err3:
diff --cc net/sched/act_mirred.c
index 3ff85aed0e67,3edeecafba2f..000000000000
--- a/net/sched/act_mirred.c
+++ b/net/sched/act_mirred.c
@@@ -30,19 -30,12 +30,20 @@@
  #include <linux/if_arp.h>
  
  #define MIRRED_TAB_MASK     7
 +static struct tcf_common *tcf_mirred_ht[MIRRED_TAB_MASK + 1];
 +static u32 mirred_idx_gen;
 +static DEFINE_RWLOCK(mirred_lock);
  static LIST_HEAD(mirred_list);
 -static struct tcf_hashinfo mirred_hash_info;
 +
 +static struct tcf_hashinfo mirred_hash_info = {
 +	.htab	=	tcf_mirred_ht,
 +	.hmask	=	MIRRED_TAB_MASK,
 +	.lock	=	&mirred_lock,
 +};
  
- static int tcf_mirred_release(struct tcf_mirred *m, int bind)
+ static int tcf_mirred_release(struct tc_action *a, int bind)
  {
+ 	struct tcf_mirred *m = to_mirred(a);
  	if (m) {
  		if (bind)
  			m->tcf_bindcnt--;
@@@ -109,14 -101,12 +109,23 @@@ static int tcf_mirred_init(struct net *
  		dev = NULL;
  	}
  
++<<<<<<< HEAD
 +	pc = tcf_hash_check(parm->index, a, bind, &mirred_hash_info);
 +	if (!pc) {
 +		if (dev == NULL)
 +			return -EINVAL;
 +		pc = tcf_hash_create(parm->index, est, a, sizeof(*m), bind,
 +				     &mirred_idx_gen, &mirred_hash_info);
 +		if (IS_ERR(pc))
 +			return PTR_ERR(pc);
++=======
+ 	if (!tcf_hash_check(parm->index, a, bind)) {
+ 		if (dev == NULL)
+ 			return -EINVAL;
+ 		ret = tcf_hash_create(parm->index, est, a, sizeof(*m), bind);
+ 		if (ret)
+ 			return ret;
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  		ret = ACT_P_CREATED;
  	} else {
  		if (!ovr) {
@@@ -140,7 -130,7 +149,11 @@@
  	spin_unlock_bh(&m->tcf_lock);
  	if (ret == ACT_P_CREATED) {
  		list_add(&m->tcfm_list, &mirred_list);
++<<<<<<< HEAD
 +		tcf_hash_insert(pc, &mirred_hash_info);
++=======
+ 		tcf_hash_insert(a);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  	}
  
  	return ret;
diff --cc net/sched/act_nat.c
index 76869538d028,ce9a3914ed4a..000000000000
--- a/net/sched/act_nat.c
+++ b/net/sched/act_nat.c
@@@ -64,17 -56,15 +63,28 @@@ static int tcf_nat_init(struct net *net
  		return -EINVAL;
  	parm = nla_data(tb[TCA_NAT_PARMS]);
  
++<<<<<<< HEAD
 +	pc = tcf_hash_check(parm->index, a, bind, &nat_hash_info);
 +	if (!pc) {
 +		pc = tcf_hash_create(parm->index, est, a, sizeof(*p), bind,
 +				     &nat_idx_gen, &nat_hash_info);
 +		if (IS_ERR(pc))
 +			return PTR_ERR(pc);
++=======
+ 	if (!tcf_hash_check(parm->index, a, bind)) {
+ 		ret = tcf_hash_create(parm->index, est, a, sizeof(*p), bind);
+ 		if (ret)
+ 			return ret;
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  		ret = ACT_P_CREATED;
  	} else {
  		if (bind)
  			return 0;
++<<<<<<< HEAD
 +		tcf_hash_release(pc, bind, &nat_hash_info);
++=======
+ 		tcf_hash_release(a, bind);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -90,7 -80,7 +100,11 @@@
  	spin_unlock_bh(&p->tcf_lock);
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(pc, &nat_hash_info);
++=======
+ 		tcf_hash_insert(a);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  
  	return ret;
  }
diff --cc net/sched/act_pedit.c
index 7aa2dcd989f8,091ced38a376..000000000000
--- a/net/sched/act_pedit.c
+++ b/net/sched/act_pedit.c
@@@ -64,27 -56,22 +63,39 @@@ static int tcf_pedit_init(struct net *n
  	if (nla_len(tb[TCA_PEDIT_PARMS]) < sizeof(*parm) + ksize)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	pc = tcf_hash_check(parm->index, a, bind, &pedit_hash_info);
 +	if (!pc) {
 +		if (!parm->nkeys)
 +			return -EINVAL;
 +		pc = tcf_hash_create(parm->index, est, a, sizeof(*p), bind,
 +				     &pedit_idx_gen, &pedit_hash_info);
 +		if (IS_ERR(pc))
 +			return PTR_ERR(pc);
 +		p = to_pedit(pc);
++=======
+ 	if (!tcf_hash_check(parm->index, a, bind)) {
+ 		if (!parm->nkeys)
+ 			return -EINVAL;
+ 		ret = tcf_hash_create(parm->index, est, a, sizeof(*p), bind);
+ 		if (ret)
+ 			return ret;
+ 		p = to_pedit(a);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  		keys = kmalloc(ksize, GFP_KERNEL);
  		if (keys == NULL) {
- 			if (est)
- 				gen_kill_estimator(&pc->tcfc_bstats,
- 						   &pc->tcfc_rate_est);
- 			kfree_rcu(pc, tcfc_rcu);
+ 			tcf_hash_cleanup(a, est);
  			return -ENOMEM;
  		}
  		ret = ACT_P_CREATED;
  	} else {
++<<<<<<< HEAD
 +		p = to_pedit(pc);
 +		tcf_hash_release(pc, bind, &pedit_hash_info);
++=======
+ 		p = to_pedit(a);
+ 		tcf_hash_release(a, bind);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  		if (bind)
  			return 0;
  		if (!ovr)
@@@ -108,7 -95,7 +119,11 @@@
  	memcpy(p->tcfp_keys, parm->keys, ksize);
  	spin_unlock_bh(&p->tcf_lock);
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(pc, &pedit_hash_info);
++=======
+ 		tcf_hash_insert(a);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  	return ret;
  }
  
diff --cc net/sched/act_police.c
index 376c02554325,4695d02bd249..000000000000
--- a/net/sched/act_police.c
+++ b/net/sched/act_police.c
@@@ -288,24 -253,6 +288,27 @@@ failure
  	return err;
  }
  
++<<<<<<< HEAD
 +static int tcf_act_police_cleanup(struct tc_action *a, int bind)
 +{
 +	struct tcf_police *p = a->priv;
 +	int ret = 0;
 +
 +	if (p != NULL) {
 +		if (bind)
 +			p->tcf_bindcnt--;
 +
 +		p->tcf_refcnt--;
 +		if (p->tcf_refcnt <= 0 && !p->tcf_bindcnt) {
 +			tcf_police_destroy(p);
 +			ret = 1;
 +		}
 +	}
 +	return ret;
 +}
 +
++=======
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  static int tcf_act_police(struct sk_buff *skb, const struct tc_action *a,
  			  struct tcf_result *res)
  {
diff --cc net/sched/act_simple.c
index f7b45ab85388,11c2922bb900..000000000000
--- a/net/sched/act_simple.c
+++ b/net/sched/act_simple.c
@@@ -122,20 -114,15 +122,24 @@@ static int tcf_simp_init(struct net *ne
  	parm = nla_data(tb[TCA_DEF_PARMS]);
  	defdata = nla_data(tb[TCA_DEF_DATA]);
  
++<<<<<<< HEAD
 +	pc = tcf_hash_check(parm->index, a, bind, &simp_hash_info);
 +	if (!pc) {
 +		pc = tcf_hash_create(parm->index, est, a, sizeof(*d), bind,
 +				     &simp_idx_gen, &simp_hash_info);
 +		if (IS_ERR(pc))
 +			return PTR_ERR(pc);
++=======
+ 	if (!tcf_hash_check(parm->index, a, bind)) {
+ 		ret = tcf_hash_create(parm->index, est, a, sizeof(*d), bind);
+ 		if (ret)
+ 			return ret;
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  
- 		d = to_defact(pc);
+ 		d = to_defact(a);
  		ret = alloc_defdata(d, defdata);
  		if (ret < 0) {
- 			if (est)
- 				gen_kill_estimator(&pc->tcfc_bstats,
- 						   &pc->tcfc_rate_est);
- 			kfree_rcu(pc, tcfc_rcu);
+ 			tcf_hash_cleanup(a, est);
  			return ret;
  		}
  		d->tcf_action = parm->action;
@@@ -153,7 -140,7 +157,11 @@@
  	}
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(pc, &simp_hash_info);
++=======
+ 		tcf_hash_insert(a);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  	return ret;
  }
  
diff --cc net/sched/act_skbedit.c
index 8fe9d25c3008,71fd2d499109..000000000000
--- a/net/sched/act_skbedit.c
+++ b/net/sched/act_skbedit.c
@@@ -109,20 -99,18 +108,31 @@@ static int tcf_skbedit_init(struct net 
  
  	parm = nla_data(tb[TCA_SKBEDIT_PARMS]);
  
++<<<<<<< HEAD
 +	pc = tcf_hash_check(parm->index, a, bind, &skbedit_hash_info);
 +	if (!pc) {
 +		pc = tcf_hash_create(parm->index, est, a, sizeof(*d), bind,
 +				     &skbedit_idx_gen, &skbedit_hash_info);
 +		if (IS_ERR(pc))
 +			return PTR_ERR(pc);
- 
- 		d = to_skbedit(pc);
++=======
+ 	if (!tcf_hash_check(parm->index, a, bind)) {
+ 		ret = tcf_hash_create(parm->index, est, a, sizeof(*d), bind);
+ 		if (ret)
+ 			return ret;
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
+ 
+ 		d = to_skbedit(a);
  		ret = ACT_P_CREATED;
  	} else {
- 		d = to_skbedit(pc);
+ 		d = to_skbedit(a);
  		if (bind)
  			return 0;
++<<<<<<< HEAD
 +		tcf_hash_release(pc, bind, &skbedit_hash_info);
++=======
+ 		tcf_hash_release(a, bind);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  		if (!ovr)
  			return -EEXIST;
  	}
@@@ -142,7 -130,7 +152,11 @@@
  	spin_unlock_bh(&d->tcf_lock);
  
  	if (ret == ACT_P_CREATED)
++<<<<<<< HEAD
 +		tcf_hash_insert(pc, &skbedit_hash_info);
++=======
+ 		tcf_hash_insert(a);
++>>>>>>> 86062033feb8 (net_sched: act: hide struct tcf_common from API)
  	return ret;
  }
  
* Unmerged path include/net/act_api.h
diff --git a/include/net/tc_act/tc_csum.h b/include/net/tc_act/tc_csum.h
index 9e8710be7a04..fa8f5fac65e9 100644
--- a/include/net/tc_act/tc_csum.h
+++ b/include/net/tc_act/tc_csum.h
@@ -9,7 +9,7 @@ struct tcf_csum {
 
 	u32 update_flags;
 };
-#define to_tcf_csum(pc) \
-	container_of(pc,struct tcf_csum,common)
+#define to_tcf_csum(a) \
+	container_of(a->priv,struct tcf_csum,common)
 
 #endif /* __NET_TC_CSUM_H */
diff --git a/include/net/tc_act/tc_defact.h b/include/net/tc_act/tc_defact.h
index 65f024b80958..9763dcbb9bc3 100644
--- a/include/net/tc_act/tc_defact.h
+++ b/include/net/tc_act/tc_defact.h
@@ -8,7 +8,7 @@ struct tcf_defact {
 	u32     		tcfd_datalen;
 	void    		*tcfd_defdata;
 };
-#define to_defact(pc) \
-	container_of(pc, struct tcf_defact, common)
+#define to_defact(a) \
+	container_of(a->priv, struct tcf_defact, common)
 
 #endif /* __NET_TC_DEF_H */
diff --git a/include/net/tc_act/tc_gact.h b/include/net/tc_act/tc_gact.h
index 9e3f6767b80e..9fc9b578908a 100644
--- a/include/net/tc_act/tc_gact.h
+++ b/include/net/tc_act/tc_gact.h
@@ -11,7 +11,7 @@ struct tcf_gact {
         int			tcfg_paction;
 #endif
 };
-#define to_gact(pc) \
-	container_of(pc, struct tcf_gact, common)
+#define to_gact(a) \
+	container_of(a->priv, struct tcf_gact, common)
 
 #endif /* __NET_TC_GACT_H */
diff --git a/include/net/tc_act/tc_ipt.h b/include/net/tc_act/tc_ipt.h
index f7d25dfcc4b7..c0f4193f432c 100644
--- a/include/net/tc_act/tc_ipt.h
+++ b/include/net/tc_act/tc_ipt.h
@@ -11,7 +11,7 @@ struct tcf_ipt {
 	char			*tcfi_tname;
 	struct xt_entry_target	*tcfi_t;
 };
-#define to_ipt(pc) \
-	container_of(pc, struct tcf_ipt, common)
+#define to_ipt(a) \
+	container_of(a->priv, struct tcf_ipt, common)
 
 #endif /* __NET_TC_IPT_H */
diff --git a/include/net/tc_act/tc_mirred.h b/include/net/tc_act/tc_mirred.h
index cfe2943690ff..4dd77a1c106b 100644
--- a/include/net/tc_act/tc_mirred.h
+++ b/include/net/tc_act/tc_mirred.h
@@ -11,7 +11,7 @@ struct tcf_mirred {
 	struct net_device	*tcfm_dev;
 	struct list_head	tcfm_list;
 };
-#define to_mirred(pc) \
-	container_of(pc, struct tcf_mirred, common)
+#define to_mirred(a) \
+	container_of(a->priv, struct tcf_mirred, common)
 
 #endif /* __NET_TC_MIR_H */
diff --git a/include/net/tc_act/tc_nat.h b/include/net/tc_act/tc_nat.h
index 4a691f34d703..63d8e9ca9d99 100644
--- a/include/net/tc_act/tc_nat.h
+++ b/include/net/tc_act/tc_nat.h
@@ -13,9 +13,9 @@ struct tcf_nat {
 	u32 flags;
 };
 
-static inline struct tcf_nat *to_tcf_nat(struct tcf_common *pc)
+static inline struct tcf_nat *to_tcf_nat(struct tc_action *a)
 {
-	return container_of(pc, struct tcf_nat, common);
+	return container_of(a->priv, struct tcf_nat, common);
 }
 
 #endif /* __NET_TC_NAT_H */
diff --git a/include/net/tc_act/tc_pedit.h b/include/net/tc_act/tc_pedit.h
index e6f6e15956f5..5b80998879c7 100644
--- a/include/net/tc_act/tc_pedit.h
+++ b/include/net/tc_act/tc_pedit.h
@@ -9,7 +9,7 @@ struct tcf_pedit {
 	unsigned char		tcfp_flags;
 	struct tc_pedit_key	*tcfp_keys;
 };
-#define to_pedit(pc) \
-	container_of(pc, struct tcf_pedit, common)
+#define to_pedit(a) \
+	container_of(a->priv, struct tcf_pedit, common)
 
 #endif /* __NET_TC_PED_H */
diff --git a/include/net/tc_act/tc_skbedit.h b/include/net/tc_act/tc_skbedit.h
index e103fe02f375..e761ecd2ff8e 100644
--- a/include/net/tc_act/tc_skbedit.h
+++ b/include/net/tc_act/tc_skbedit.h
@@ -30,7 +30,7 @@ struct tcf_skbedit {
 	u16			queue_mapping;
 	/* XXX: 16-bit pad here? */
 };
-#define to_skbedit(pc) \
-	container_of(pc, struct tcf_skbedit, common)
+#define to_skbedit(a) \
+	container_of(a->priv, struct tcf_skbedit, common)
 
 #endif /* __NET_TC_SKBEDIT_H */
* Unmerged path net/sched/act_api.c
* Unmerged path net/sched/act_csum.c
* Unmerged path net/sched/act_gact.c
* Unmerged path net/sched/act_ipt.c
* Unmerged path net/sched/act_mirred.c
* Unmerged path net/sched/act_nat.c
* Unmerged path net/sched/act_pedit.c
* Unmerged path net/sched/act_police.c
* Unmerged path net/sched/act_simple.c
* Unmerged path net/sched/act_skbedit.c
