switchdev: add netlink flags to IPv4 FIB add op

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Scott Feldman <sfeldma@gmail.com>
commit f8f2147150de303e814c0452075d467734d3544b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f8f21471.failed

Pass in the netlink flags (NLM_F_*) into switchdev driver for IPv4 FIB add op
to allow driver to 1) optimize hardware updates, 2) handle ip route prepend
and append commands correctly.

	Suggested-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Suggested-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: Scott Feldman <sfeldma@gmail.com>
	Reviewed-by: Simon Horman <simon.horman@netronome.com>
	Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f8f2147150de303e814c0452075d467734d3544b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/rocker/rocker.c
#	include/linux/netdevice.h
#	include/net/switchdev.h
#	net/ipv4/fib_trie.c
#	net/switchdev/switchdev.c
diff --cc include/linux/netdevice.h
index b6150f910ad9,1354ae83efc8..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1118,11 -1024,23 +1118,30 @@@ struct net_device_ops_extended 
   *	be otherwise expressed by feature flags. The check is called with
   *	the set of features that the stack has calculated and it returns
   *	those the driver believes to be appropriate.
 + * int (*ndo_fill_metadata_dst)(struct net_device *dev, struct sk_buff *skb);
 + *	This function is used to get egress tunnel information for given skb.
 + *	This is useful for retrieving outer tunnel header parameters while
 + *	sampling packet.
   *
++<<<<<<< HEAD
++=======
+  * int (*ndo_switch_parent_id_get)(struct net_device *dev,
+  *				   struct netdev_phys_item_id *psid);
+  *	Called to get an ID of the switch chip this port is part of.
+  *	If driver implements this, it indicates that it represents a port
+  *	of a switch chip.
+  * int (*ndo_switch_port_stp_update)(struct net_device *dev, u8 state);
+  *	Called to notify switch device port of bridge port STP
+  *	state change.
+  * int (*ndo_sw_parent_fib_ipv4_add)(struct net_device *dev, __be32 dst,
+  *				     int dst_len, struct fib_info *fi,
+  *				     u8 tos, u8 type, u32 nlflags, u32 tb_id);
+  *	Called to add/modify IPv4 route to switch device.
+  * int (*ndo_sw_parent_fib_ipv4_del)(struct net_device *dev, __be32 dst,
+  *				     int dst_len, struct fib_info *fi,
+  *				     u8 tos, u8 type, u32 tb_id);
+  *	Called to delete IPv4 route from switch device.
++>>>>>>> f8f2147150de (switchdev: add netlink flags to IPv4 FIB add op)
   */
  struct net_device_ops {
  	int			(*ndo_init)(struct net_device *dev);
@@@ -1284,70 -1185,39 +1303,99 @@@
  						      sa_family_t sa_family,
  						      __be16 port);
  
 -	void*			(*ndo_dfwd_add_station)(struct net_device *pdev,
 -							struct net_device *dev);
 -	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
 -							void *priv);
 -
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, int	(*ndo_get_iflink)(const struct net_device *dev))
 +	RH_KABI_USE_P(2, netdev_features_t
 +				(*ndo_features_check)(struct sk_buff *skb,
 +						      struct net_device *dev,
 +						      netdev_features_t features))
 +	RH_KABI_USE_P(3, int	(*ndo_set_vf_rate)(struct net_device *dev,
 +						   int vf, int min_tx_rate,
 +						   int max_tx_rate))
 +	RH_KABI_USE_P(4, int	(*ndo_get_vf_stats)(struct net_device *dev,
 +						    int vf,
 +						    struct ifla_vf_stats
 +						    *vf_stats))
 +	RH_KABI_USE_P(5, int    (*ndo_set_vf_rss_query_en)(struct net_device *dev,
 +							   int vf, bool setting))
 +
++<<<<<<< HEAD
 +	RH_KABI_USE_P(6, int	(*ndo_fdb_add)(struct ndmsg *ndm,
 +					       struct nlattr *tb[],
 +					       struct net_device *dev,
 +					       const unsigned char *addr,
 +					       u16 vid,
 +					       u16 flags))
 +	RH_KABI_USE_P(7,int	(*ndo_setup_tc)(struct net_device *dev,
 +						u32 handle,
 +						__be16 protocol,
 +						struct tc_to_netdev *tc))
 +	RH_KABI_USE_P(8, int	(*ndo_fill_metadata_dst)(struct net_device *dev,
 +						       struct sk_buff *skb))
 +	RH_KABI_USE_P(9, void	(*ndo_add_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_USE_P(10, void	(*ndo_del_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_USE_P(16, size_t ndo_size)
 +	/* RHEL: put all new non-performance critical ndo's into
 +	 * net_device_ops_extended. The reserved slots above can be used
 +	 * only for performance critical operations.
 +	 * Drivers may access the extended fields directly from
 +	 * net_device_ops, if they allocated the net_device_ops structure
 +	 * themselves (usually statically). The kernel core and drivers
 +	 * using others' net_device_ops must access the extended fields
 +	 * using the get_ndo_ext macro.
 +	 */
 +	RH_KABI_EXTEND(struct net_device_ops_extended extended)
++=======
+ 	netdev_tx_t		(*ndo_dfwd_start_xmit) (struct sk_buff *skb,
+ 							struct net_device *dev,
+ 							void *priv);
+ 	int			(*ndo_get_lock_subclass)(struct net_device *dev);
+ 	netdev_features_t	(*ndo_features_check) (struct sk_buff *skb,
+ 						       struct net_device *dev,
+ 						       netdev_features_t features);
+ #ifdef CONFIG_NET_SWITCHDEV
+ 	int			(*ndo_switch_parent_id_get)(struct net_device *dev,
+ 							    struct netdev_phys_item_id *psid);
+ 	int			(*ndo_switch_port_stp_update)(struct net_device *dev,
+ 							      u8 state);
+ 	int			(*ndo_switch_fib_ipv4_add)(struct net_device *dev,
+ 							   __be32 dst,
+ 							   int dst_len,
+ 							   struct fib_info *fi,
+ 							   u8 tos, u8 type,
+ 							   u32 nlflags,
+ 							   u32 tb_id);
+ 	int			(*ndo_switch_fib_ipv4_del)(struct net_device *dev,
+ 							   __be32 dst,
+ 							   int dst_len,
+ 							   struct fib_info *fi,
+ 							   u8 tos, u8 type,
+ 							   u32 tb_id);
+ #endif
++>>>>>>> f8f2147150de (switchdev: add netlink flags to IPv4 FIB add op)
  };
  
 +#define get_ndo_ext(ops, field)		({				\
 +	const struct net_device_ops *__ops = (ops);			\
 +	size_t __off = offsetof(struct net_device_ops, extended.field);	\
 +	__ops->ndo_size > __off ? __ops->extended.field : NULL;		\
 +	})
 +
  /**
   * enum net_device_priv_flags - &struct net_device priv_flags
   *
diff --cc net/ipv4/fib_trie.c
index 9511456e5325,fcfa9825a816..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -1155,7 -1152,19 +1155,21 @@@ int fib_table_insert(struct fib_table *
  			new_fa->fa_state = state & ~FA_S_ACCESSED;
  			new_fa->fa_slen = fa->fa_slen;
  
++<<<<<<< HEAD
++=======
+ 			err = netdev_switch_fib_ipv4_add(key, plen, fi,
+ 							 new_fa->fa_tos,
+ 							 cfg->fc_type,
+ 							 cfg->fc_nlflags,
+ 							 tb->tb_id);
+ 			if (err) {
+ 				netdev_switch_fib_ipv4_abort(fi);
+ 				kmem_cache_free(fn_alias_kmem, new_fa);
+ 				goto out;
+ 			}
+ 
++>>>>>>> f8f2147150de (switchdev: add netlink flags to IPv4 FIB add op)
  			hlist_replace_rcu(&fa->fa_list, &new_fa->fa_list);
 -
  			alias_free_mem_rcu(fa);
  
  			fib_release_info(fi_drop);
@@@ -1191,6 -1200,16 +1205,19 @@@
  	new_fa->fa_state = 0;
  	new_fa->fa_slen = slen;
  
++<<<<<<< HEAD
++=======
+ 	/* (Optionally) offload fib entry to switch hardware. */
+ 	err = netdev_switch_fib_ipv4_add(key, plen, fi, tos,
+ 					 cfg->fc_type,
+ 					 cfg->fc_nlflags,
+ 					 tb->tb_id);
+ 	if (err) {
+ 		netdev_switch_fib_ipv4_abort(fi);
+ 		goto out_free_new_fa;
+ 	}
+ 
++>>>>>>> f8f2147150de (switchdev: add netlink flags to IPv4 FIB add op)
  	/* Insert new entry to the list. */
  	err = fib_insert_alias(t, tp, l, new_fa, fa, key);
  	if (err)
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path include/net/switchdev.h
* Unmerged path net/switchdev/switchdev.c
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path include/linux/netdevice.h
* Unmerged path include/net/switchdev.h
* Unmerged path net/ipv4/fib_trie.c
* Unmerged path net/switchdev/switchdev.c
