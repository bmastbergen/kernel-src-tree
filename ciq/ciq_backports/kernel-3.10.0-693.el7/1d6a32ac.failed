keep shadowed vfsmounts together

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 1d6a32acd70ab18499829c0a9a5dbe2bace72a13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1d6a32ac.failed

preparation to switching mnt_hash to hlist

	Cc: stable@vger.kernel.org
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 1d6a32acd70ab18499829c0a9a5dbe2bace72a13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index a82db7875df0,9db3ce397a83..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -568,13 -620,21 +568,26 @@@ struct mount *__lookup_mnt(struct vfsmo
   */
  struct mount *__lookup_mnt_last(struct vfsmount *mnt, struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	struct list_head *head = mount_hashtable + hash(mnt, dentry);
 +	struct mount *p;
++=======
+ 	struct list_head *head = m_hash(mnt, dentry);
+ 	struct mount *p, *res = NULL;
++>>>>>>> 1d6a32acd70a (keep shadowed vfsmounts together)
  
- 	list_for_each_entry_reverse(p, head, mnt_hash)
+ 	list_for_each_entry(p, head, mnt_hash)
  		if (&p->mnt_parent->mnt == mnt && p->mnt_mountpoint == dentry)
- 			return p;
- 	return NULL;
+ 			goto found;
+ 	return res;
+ found:
+ 	res = p;
+ 	list_for_each_entry_continue(p, head, mnt_hash) {
+ 		if (&p->mnt_parent->mnt != mnt || p->mnt_mountpoint != dentry)
+ 			break;
+ 		res = p;
+ 	}
+ 	return res;
  }
  
  /*
@@@ -717,8 -777,7 +730,12 @@@ static void attach_mnt(struct mount *mn
  			struct mountpoint *mp)
  {
  	mnt_set_mountpoint(parent, mp, mnt);
++<<<<<<< HEAD
 +	list_add_tail(&mnt->mnt_hash, mount_hashtable +
 +			hash(&parent->mnt, mp->m_dentry));
++=======
+ 	list_add(&mnt->mnt_hash, m_hash(&parent->mnt, mp->m_dentry));
++>>>>>>> 1d6a32acd70a (keep shadowed vfsmounts together)
  	list_add_tail(&mnt->mnt_child, &parent->mnt_mounts);
  }
  
@@@ -740,8 -799,11 +757,16 @@@ static void commit_tree(struct mount *m
  
  	list_splice(&head, n->list.prev);
  
++<<<<<<< HEAD
 +	list_add_tail(&mnt->mnt_hash, mount_hashtable +
 +				hash(&parent->mnt, mnt->mnt_mountpoint));
++=======
+ 	if (shadows)
+ 		list_add(&mnt->mnt_hash, &shadows->mnt_hash);
+ 	else
+ 		list_add(&mnt->mnt_hash,
+ 				m_hash(&parent->mnt, mnt->mnt_mountpoint));
++>>>>>>> 1d6a32acd70a (keep shadowed vfsmounts together)
  	list_add_tail(&mnt->mnt_child, &parent->mnt_mounts);
  	touch_mnt_namespace(n);
  }
@@@ -1631,10 -1674,13 +1656,13 @@@ static int attach_recursive_mnt(struct 
  	}
  
  	list_for_each_entry_safe(child, p, &tree_list, mnt_hash) {
+ 		struct mount *q;
  		list_del_init(&child->mnt_hash);
- 		commit_tree(child);
+ 		q = __lookup_mnt_last(&child->mnt_parent->mnt,
+ 				      child->mnt_mountpoint);
+ 		commit_tree(child, q);
  	}
 -	unlock_mount_hash();
 +	br_write_unlock(&vfsmount_lock);
  
  	return 0;
  
* Unmerged path fs/namespace.c
