s390/scm_block: fix off by one during cluster reservation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [s390] scm_block: fix off by one during cluster reservation (Hendrik Brueckner) [1274409]
Rebuild_FUZZ: 95.41%
commit-author Sebastian Ott <sebott@linux.vnet.ibm.com>
commit a13ccb04af4aa6632c11d59ddf6555aa80ffb139
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a13ccb04.failed

We increase the msb_count after we're finished building the request.
That way we can always access the current request via
scmrq->request[msb_count] . But once the request is started we need
to make sure that the array index stays below msb_count.

	Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit a13ccb04af4aa6632c11d59ddf6555aa80ffb139)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/block/scm_blk_cluster.c
diff --cc drivers/s390/block/scm_blk_cluster.c
index 27f930cd657f,7497ddde2dd6..000000000000
--- a/drivers/s390/block/scm_blk_cluster.c
+++ b/drivers/s390/block/scm_blk_cluster.c
@@@ -82,14 -84,25 +82,32 @@@ bool scm_reserve_cluster(struct scm_req
  
  	spin_lock(&bdev->lock);
  	list_for_each_entry(iter, &bdev->cluster_list, cluster.list) {
++<<<<<<< HEAD
 +		if (clusters_intersect(scmrq, iter) &&
 +		    (rq_data_dir(scmrq->request) == WRITE ||
 +		     rq_data_dir(iter->request) == WRITE)) {
 +			spin_unlock(&bdev->lock);
 +			return false;
++=======
+ 		if (iter == scmrq) {
+ 			/*
+ 			 * We don't have to use clusters_intersect here, since
+ 			 * cluster requests are always started separately.
+ 			 */
+ 			add = 0;
+ 			continue;
+ 		}
+ 		for (pos = 0; pos < iter->aob->request.msb_count; pos++) {
+ 			if (clusters_intersect(req, iter->request[pos]) &&
+ 			    (rq_data_dir(req) == WRITE ||
+ 			     rq_data_dir(iter->request[pos]) == WRITE)) {
+ 				spin_unlock(&bdev->lock);
+ 				return false;
+ 			}
++>>>>>>> a13ccb04af4a (s390/scm_block: fix off by one during cluster reservation)
  		}
  	}
 -	if (add)
 -		list_add(&scmrq->cluster.list, &bdev->cluster_list);
 +	list_add(&scmrq->cluster.list, &bdev->cluster_list);
  	spin_unlock(&bdev->lock);
  
  	return true;
* Unmerged path drivers/s390/block/scm_blk_cluster.c
