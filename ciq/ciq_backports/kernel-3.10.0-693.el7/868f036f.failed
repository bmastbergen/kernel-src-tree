libnvdimm: fix mishandled nvdimm_clear_poison() return value

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 868f036fee4b1f934117197fb93461d2c968ffec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/868f036f.failed

Colin, via static analysis, reports that the length could be negative
from nvdimm_clear_poison() in the error case. There was a similar
problem with commit 0a3f27b9a6a8 "libnvdimm, namespace: avoid multiple
sector calculations" that I noticed when merging the for-4.10/libnvdimm
topic branch into libnvdimm-for-next, but I missed this one. Fix both of
them to the following procedure:

* if we clear a block's worth of media, clear that many blocks in
  badblocks

* if we clear less than the requested size of the transfer return an
  error

* always invalidate cache after any non-error / non-zero
  nvdimm_clear_poison result

Fixes: 82bf1037f2ca ("libnvdimm: check and clear poison before writing to pmem")
Fixes: 0a3f27b9a6a8 ("libnvdimm, namespace: avoid multiple sector calculations")
	Cc: Fabian Frederick <fabf@skynet.be>
	Cc: Dave Jiang <dave.jiang@intel.com>
	Reported-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 868f036fee4b1f934117197fb93461d2c968ffec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvdimm/claim.c
diff --cc drivers/nvdimm/claim.c
index 52ec78a93e38,b3323c0697f6..000000000000
--- a/drivers/nvdimm/claim.c
+++ b/drivers/nvdimm/claim.c
@@@ -239,30 -239,28 +239,43 @@@ static int nsio_rw_bytes(struct nd_name
  	if (rw == READ) {
  		if (unlikely(is_bad_pmem(&nsio->bb, sector, sz_align)))
  			return -EIO;
 -		return memcpy_from_pmem(buf, nsio->addr + offset, size);
 -	}
 -
 -	if (unlikely(is_bad_pmem(&nsio->bb, sector, sz_align))) {
 -		if (IS_ALIGNED(offset, 512) && IS_ALIGNED(size, 512)) {
 -			long cleared;
 +		memcpy_from_pmem(buf, nsio->addr + offset, size);
 +	} else {
 +
 +		if (unlikely(is_bad_pmem(&nsio->bb, sector, sz_align))) {
 +			if (IS_ALIGNED(offset, 512) && IS_ALIGNED(size, 512)) {
 +				long cleared;
 +
++<<<<<<< HEAD
 +				cleared = nvdimm_clear_poison(&ndns->dev,
 +							      offset, size);
 +				if (cleared != size) {
 +					size = cleared;
 +					rc = -EIO;
 +				}
 +
 +				badblocks_clear(&nsio->bb, sector,
 +						cleared >> 9);
 +			} else
 +				rc = -EIO;
 +		}
  
 +		memcpy_to_pmem(nsio->addr + offset, buf, size);
 +		nvdimm_flush(to_nd_region(ndns->dev.parent));
++=======
+ 			cleared = nvdimm_clear_poison(&ndns->dev, offset, size);
+ 			if (cleared < size)
+ 				rc = -EIO;
+ 			if (cleared > 0 && cleared / 512) {
+ 				cleared /= 512;
+ 				badblocks_clear(&nsio->bb, sector, cleared);
+ 			}
+ 			invalidate_pmem(nsio->addr + offset, size);
+ 		} else
+ 			rc = -EIO;
++>>>>>>> 868f036fee4b (libnvdimm: fix mishandled nvdimm_clear_poison() return value)
  	}
  
 -	memcpy_to_pmem(nsio->addr + offset, buf, size);
 -	nvdimm_flush(to_nd_region(ndns->dev.parent));
 -
  	return rc;
  }
  
* Unmerged path drivers/nvdimm/claim.c
diff --git a/drivers/nvdimm/pmem.c b/drivers/nvdimm/pmem.c
index 26fd9ba8de78..9c744e7ad572 100644
--- a/drivers/nvdimm/pmem.c
+++ b/drivers/nvdimm/pmem.c
@@ -47,22 +47,29 @@ static struct nd_region *to_region(struct pmem_device *pmem)
 	return to_nd_region(to_dev(pmem)->parent);
 }
 
-static void pmem_clear_poison(struct pmem_device *pmem, phys_addr_t offset,
+static int pmem_clear_poison(struct pmem_device *pmem, phys_addr_t offset,
 		unsigned int len)
 {
 	struct device *dev = to_dev(pmem);
-	sector_t sector, cleared;
+	sector_t sector;
+	long cleared;
+	int rc = 0;
 
 	sector = (offset - pmem->data_offset) / 512;
-	cleared = nvdimm_clear_poison(dev, pmem->phys_addr + offset, len) / 512;
 
-	if (cleared) {
-		dev_dbg(dev, "%s: %#llx clear %ld sector%s\n",
-				__func__, (unsigned long long) sector,
-				cleared, cleared > 1 ? "s" : "");
+	cleared = nvdimm_clear_poison(dev, pmem->phys_addr + offset, len);
+	if (cleared < len)
+		rc = -EIO;
+	if (cleared > 0 && cleared / 512) {
+		cleared /= 512;
+		dev_dbg(dev, "%s: %#llx clear %ld sector%s\n", __func__,
+				(unsigned long long) sector, cleared,
+				cleared > 1 ? "s" : "");
 		badblocks_clear(&pmem->bb, sector, cleared);
 	}
 	invalidate_pmem(pmem->virt_addr + offset, len);
+
+	return rc;
 }
 
 static int pmem_do_bvec(struct pmem_device *pmem, struct page *page,
