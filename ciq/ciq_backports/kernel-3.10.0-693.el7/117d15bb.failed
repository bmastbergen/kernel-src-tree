RDS: TCP: start multipath acceptor loop at 0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Sowmini Varadhan <sowmini.varadhan@oracle.com>
commit 117d15bbfde643b5bd0a173fddaa0e6c65f14d47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/117d15bb.failed

The for() loop in rds_tcp_accept_one() assumes that the 0'th
rds_tcp_conn_path is UP and starts multipath accepts at index 1.
But this assumption may not always be true: if the 0'th path
has failed (ERROR or DOWN state) an incoming connection request
should be used to resurrect this path.

	Signed-off-by: Sowmini Varadhan <sowmini.varadhan@oracle.com>
	Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 117d15bbfde643b5bd0a173fddaa0e6c65f14d47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rds/tcp_listen.c
diff --cc net/rds/tcp_listen.c
index ecfec7ecfd15,c9c496844cd7..000000000000
--- a/net/rds/tcp_listen.c
+++ b/net/rds/tcp_listen.c
@@@ -70,6 -70,52 +70,55 @@@ bail
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /* rds_tcp_accept_one_path(): if accepting on cp_index > 0, make sure the
+  * client's ipaddr < server's ipaddr. Otherwise, close the accepted
+  * socket and force a reconneect from smaller -> larger ip addr. The reason
+  * we special case cp_index 0 is to allow the rds probe ping itself to itself
+  * get through efficiently.
+  * Since reconnects are only initiated from the node with the numerically
+  * smaller ip address, we recycle conns in RDS_CONN_ERROR on the passive side
+  * by moving them to CONNECTING in this function.
+  */
+ struct rds_tcp_connection *rds_tcp_accept_one_path(struct rds_connection *conn)
+ {
+ 	int i;
+ 	bool peer_is_smaller = (conn->c_faddr < conn->c_laddr);
+ 	int npaths = conn->c_npaths;
+ 
+ 	if (npaths <= 1) {
+ 		struct rds_conn_path *cp = &conn->c_path[0];
+ 		int ret;
+ 
+ 		ret = rds_conn_path_transition(cp, RDS_CONN_DOWN,
+ 					       RDS_CONN_CONNECTING);
+ 		if (!ret)
+ 			rds_conn_path_transition(cp, RDS_CONN_ERROR,
+ 						 RDS_CONN_CONNECTING);
+ 		return cp->cp_transport_data;
+ 	}
+ 
+ 	/* for mprds, paths with cp_index > 0 MUST be initiated by the peer
+ 	 * with the smaller address.
+ 	 */
+ 	if (!peer_is_smaller)
+ 		return NULL;
+ 
+ 	for (i = 0; i < npaths; i++) {
+ 		struct rds_conn_path *cp = &conn->c_path[i];
+ 
+ 		if (rds_conn_path_transition(cp, RDS_CONN_DOWN,
+ 					     RDS_CONN_CONNECTING) ||
+ 		    rds_conn_path_transition(cp, RDS_CONN_ERROR,
+ 					     RDS_CONN_CONNECTING)) {
+ 			return cp->cp_transport_data;
+ 		}
+ 	}
+ 	return NULL;
+ }
+ 
++>>>>>>> 117d15bbfde6 (RDS: TCP: start multipath acceptor loop at 0)
  int rds_tcp_accept_one(struct socket *sock)
  {
  	struct socket *new_sock = NULL;
* Unmerged path net/rds/tcp_listen.c
