fsnotify: clean up spinlock assertions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jan Kara <jack@suse.cz>
commit ed2726406c6a71f5da63719c0ba7d9e21dd9581c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ed272640.failed

Use assert_spin_locked() macro instead of hand-made BUG_ON statements.

Link: http://lkml.kernel.org/r/1474537439-18919-1-git-send-email-jack@suse.cz
	Signed-off-by: Jan Kara <jack@suse.cz>
	Suggested-by: Heiner Kallweit <hkallweit1@gmail.com>
	Reviewed-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ed2726406c6a71f5da63719c0ba7d9e21dd9581c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/notify/fanotify/fanotify_user.c
#	fs/notify/notification.c
diff --cc fs/notify/fanotify/fanotify_user.c
index 542be39911d4,7ebfca6a1427..000000000000
--- a/fs/notify/fanotify/fanotify_user.c
+++ b/fs/notify/fanotify/fanotify_user.c
@@@ -54,7 -54,7 +54,11 @@@ struct kmem_cache *fanotify_perm_event_
  static struct fsnotify_event *get_one_event(struct fsnotify_group *group,
  					    size_t count)
  {
++<<<<<<< HEAD
 +	BUG_ON(!mutex_is_locked(&group->notification_mutex));
++=======
+ 	assert_spin_locked(&group->notification_lock);
++>>>>>>> ed2726406c6a (fsnotify: clean up spinlock assertions)
  
  	pr_debug("%s: group=%p count=%zd\n", __func__, group, count);
  
diff --cc fs/notify/notification.c
index 777e7d805e6e,66f85c651c52..000000000000
--- a/fs/notify/notification.c
+++ b/fs/notify/notification.c
@@@ -63,7 -63,7 +63,11 @@@ EXPORT_SYMBOL_GPL(fsnotify_get_cookie)
  /* return true if the notify queue is empty, false otherwise */
  bool fsnotify_notify_queue_is_empty(struct fsnotify_group *group)
  {
++<<<<<<< HEAD
 +	BUG_ON(!mutex_is_locked(&group->notification_mutex));
++=======
+ 	assert_spin_locked(&group->notification_lock);
++>>>>>>> ed2726406c6a (fsnotify: clean up spinlock assertions)
  	return list_empty(&group->notification_list) ? true : false;
  }
  
@@@ -142,7 -148,7 +146,11 @@@ struct fsnotify_event *fsnotify_remove_
  {
  	struct fsnotify_event *event;
  
++<<<<<<< HEAD
 +	BUG_ON(!mutex_is_locked(&group->notification_mutex));
++=======
+ 	assert_spin_locked(&group->notification_lock);
++>>>>>>> ed2726406c6a (fsnotify: clean up spinlock assertions)
  
  	pr_debug("%s: group=%p\n", __func__, group);
  
@@@ -164,7 -170,7 +172,11 @@@
   */
  struct fsnotify_event *fsnotify_peek_first_event(struct fsnotify_group *group)
  {
++<<<<<<< HEAD
 +	BUG_ON(!mutex_is_locked(&group->notification_mutex));
++=======
+ 	assert_spin_locked(&group->notification_lock);
++>>>>>>> ed2726406c6a (fsnotify: clean up spinlock assertions)
  
  	return list_first_entry(&group->notification_list,
  				struct fsnotify_event, list);
* Unmerged path fs/notify/fanotify/fanotify_user.c
* Unmerged path fs/notify/notification.c
