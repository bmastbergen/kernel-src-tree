net/mlx5: Only cancel recovery work when cleaning up device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Only cancel recovery work when cleaning up device (Don Dutile) [1385330 1417286]
Rebuild_FUZZ: 96.49%
commit-author Daniel Jurgens <danielj@mellanox.com>
commit 5e44fca5047054f1762813751626b5245e0da022
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5e44fca5.failed

Do not attempt to drain the health workqueue when unloading the device in
the recovery flow, this can cause a deadlock when the recovery work
tries to cancel itself with sync.

Because the work is no longer unconditionally canceled when unloading, it
must be explicitly canceled in the AER flow.

fixes: 689a248df83b ("net/mlx5: Cancel recovery work in remove flow")
	Signed-off-by: Daniel Jurgens <danielj@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5e44fca5047054f1762813751626b5245e0da022)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/main.c
index 6ca5c910701a,d01e9f21d469..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@@ -1277,12 -1195,8 +1277,17 @@@ static int mlx5_unload_one(struct mlx5_
  {
  	int err = 0;
  
++<<<<<<< HEAD
 +	err = mlx5_sriov_cleanup(dev);
 +	if (err) {
 +		dev_warn(&dev->pdev->dev, "%s: sriov cleanup failed - abort\n",
 +			 __func__);
 +		return err;
 +	}
++=======
+ 	if (cleanup)
+ 		mlx5_drain_health_wq(dev);
++>>>>>>> 5e44fca50470 (net/mlx5: Only cancel recovery work when cleaning up device)
  
  	mutex_lock(&dev->intf_state_mutex);
  	if (test_bit(MLX5_INTERFACE_STATE_DOWN, &dev->intf_state)) {
@@@ -1433,10 -1357,16 +1438,21 @@@ static pci_ers_result_t mlx5_pci_err_de
  	struct mlx5_priv *priv = &dev->priv;
  
  	dev_info(&pdev->dev, "%s was called\n", __func__);
 -
  	mlx5_enter_error_state(dev);
++<<<<<<< HEAD
 +	mlx5_unload_one(dev, priv);
 +	pci_save_state(pdev);
 +	mlx5_pci_disable_device(dev);
++=======
+ 	mlx5_unload_one(dev, priv, false);
+ 	/* In case of kernel call save the pci state and drain the health wq */
+ 	if (state) {
+ 		pci_save_state(pdev);
+ 		mlx5_drain_health_wq(dev);
+ 		mlx5_pci_disable_device(dev);
+ 	}
+ 
++>>>>>>> 5e44fca50470 (net/mlx5: Only cancel recovery work when cleaning up device)
  	return state == pci_channel_io_perm_failure ?
  		PCI_ERS_RESULT_DISCONNECT : PCI_ERS_RESULT_NEED_RESET;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/main.c
