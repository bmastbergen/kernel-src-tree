net: sched: RCU cls_route

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: RCU cls_route (Ivan Vecera) [1420506]
Rebuild_FUZZ: 88.89%
commit-author John Fastabend <john.fastabend@gmail.com>
commit cc91210cd2f6832db1a174269627d97b7d4f2c80
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/cc91210c.failed

RCUify the route classifier. For now however spinlock's are used to
protect fastmap cache.

The issue here is the fastmap may be read by one CPU while the
cache is being updated by another. An array of pointers could be
one possible solution.

	Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cc91210cd2f6832db1a174269627d97b7d4f2c80)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/cls_route.c
diff --cc net/sched/cls_route.c
index 603ee10bbfda,ba96deacf27c..000000000000
--- a/net/sched/cls_route.c
+++ b/net/sched/cls_route.c
@@@ -490,18 -524,18 +524,25 @@@ static int route4_change(struct net *ne
  		if (f->handle < f1->handle)
  			break;
  
++<<<<<<< HEAD
 +	netif_keep_dst(qdisc_dev(tp->q));
 +	f->next = f1;
 +	tcf_tree_lock(tp);
 +	*fp = f;
- 
- 	if (old_handle && f->handle != old_handle) {
- 		th = to_hash(old_handle);
- 		h = from_hash(old_handle >> 16);
- 		b = head->table[th];
++=======
+ 	rcu_assign_pointer(f->next, f1);
+ 	rcu_assign_pointer(*fp, f);
++>>>>>>> cc91210cd2f6 (net: sched: RCU cls_route)
+ 
+ 	if (fold && fold->handle && f->handle != fold->handle) {
+ 		th = to_hash(fold->handle);
+ 		h = from_hash(fold->handle >> 16);
+ 		b = rtnl_dereference(head->table[th]);
  		if (b) {
- 			for (fp = &b->ht[h]; *fp; fp = &(*fp)->next) {
- 				if (*fp == f) {
+ 			fp = &b->ht[h];
+ 			for (pfp = rtnl_dereference(*fp); pfp;
+ 			     fp = &pfp->next, pfp = rtnl_dereference(*fp)) {
+ 				if (pfp == f) {
  					*fp = f->next;
  					break;
  				}
* Unmerged path net/sched/cls_route.c
