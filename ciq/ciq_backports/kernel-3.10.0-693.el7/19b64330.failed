HID: wacom: use devres to allocate driver data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: use devres to allocate driver data (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 94.25%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 19b643300181ccf2bd83cd751283508b9ae179f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/19b64330.failed

We started switching the driver to devres, so we should use it as much
as possible.

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 19b643300181ccf2bd83cd751283508b9ae179f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index e75b5002a526,56d62e8a400b..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1302,10 -1836,15 +1302,19 @@@ static int wacom_probe(struct usb_inter
  	struct wacom_features *features;
  	int error;
  
 -	if (!id->driver_data)
 +	if (!id->driver_info)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	wacom = kzalloc(sizeof(struct wacom), GFP_KERNEL);
++=======
+ 	hdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;
+ 
+ 	/* hid-core sets this quirk for the boot interface */
+ 	hdev->quirks &= ~HID_QUIRK_NOGET;
+ 
+ 	wacom = devm_kzalloc(&hdev->dev, sizeof(struct wacom), GFP_KERNEL);
++>>>>>>> 19b643300181 (HID: wacom: use devres to allocate driver data)
  	if (!wacom)
  		return -ENOMEM;
  
@@@ -1427,49 -1890,38 +1436,68 @@@
  
  	return 0;
  
++<<<<<<< HEAD
 + fail5: wacom_destroy_leds(wacom);
 + fail4:	wacom_remove_shared_data(wacom_wac);
 + fail3:	usb_free_urb(wacom->irq);
 + fail2:	usb_free_coherent(dev, WACOM_PKGLEN_MAX, wacom_wac->data, wacom->data_dma);
 + fail1:	kfree(wacom);
++=======
+ fail_type:
+ fail_parse:
+ 	hid_set_drvdata(hdev, NULL);
++>>>>>>> 19b643300181 (HID: wacom: use devres to allocate driver data)
  	return error;
  }
  
 -static void wacom_remove(struct hid_device *hdev)
 +static void wacom_disconnect(struct usb_interface *intf)
  {
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	struct wacom_features *features = &wacom_wac->features;
 +	struct wacom *wacom = usb_get_intfdata(intf);
  
 -	if (features->device_type & WACOM_DEVICETYPE_WL_MONITOR)
 -		hid_hw_close(hdev);
 +	usb_set_intfdata(intf, NULL);
  
++<<<<<<< HEAD
 +	usb_kill_urb(wacom->irq);
 +	cancel_work_sync(&wacom->work);
 +	if (wacom->wacom_wac.input)
 +		input_unregister_device(wacom->wacom_wac.input);
 +	wacom_destroy_battery(wacom);
 +	wacom_destroy_leds(wacom);
 +	usb_free_urb(wacom->irq);
 +	usb_free_coherent(interface_to_usbdev(intf), WACOM_PKGLEN_MAX,
 +			wacom->wacom_wac.data, wacom->data_dma);
 +	wacom_remove_shared_data(&wacom->wacom_wac);
 +	kfree(wacom);
++=======
+ 	hid_hw_stop(hdev);
+ 
+ 	cancel_work_sync(&wacom->wireless_work);
+ 	cancel_work_sync(&wacom->battery_work);
+ 	kobject_put(wacom->remote_dir);
+ 	if (hdev->bus == BUS_BLUETOOTH)
+ 		device_remove_file(&hdev->dev, &dev_attr_speed);
+ 	wacom_remove_shared_data(wacom);
+ 
+ 	hid_set_drvdata(hdev, NULL);
++>>>>>>> 19b643300181 (HID: wacom: use devres to allocate driver data)
  }
  
 -#ifdef CONFIG_PM
 -static int wacom_resume(struct hid_device *hdev)
 +static int wacom_suspend(struct usb_interface *intf, pm_message_t message)
  {
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 +	struct wacom *wacom = usb_get_intfdata(intf);
 +
 +	mutex_lock(&wacom->lock);
 +	usb_kill_urb(wacom->irq);
 +	mutex_unlock(&wacom->lock);
 +
 +	return 0;
 +}
 +
 +static int wacom_resume(struct usb_interface *intf)
 +{
 +	struct wacom *wacom = usb_get_intfdata(intf);
  	struct wacom_features *features = &wacom->wacom_wac.features;
 +	int rv = 0;
  
  	mutex_lock(&wacom->lock);
  
* Unmerged path drivers/hid/wacom_sys.c
