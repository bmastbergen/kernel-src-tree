cxgb4: add common api support for configuring filters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Rahul Lakkireddy <rahul.lakkireddy@chelsio.com>
commit 578b46b9383c3619cc0a6002ff867e732b08b67a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/578b46b9.failed

Enable filters for non-offload configuration and add common api support
for setting and deleting filters in LE-TCAM region of the hardware.

IPv4 filters occupy one slot.  IPv6 filters occupy 4 slots and must
be on a 4-slot boundary.  IPv4 filters can not occupy a slot belonging
to IPv6 and the vice-versa is also true.

Filters are set and deleted asynchronously.  Use completion to wait
for reply from firmware in order to allow for synchronization if needed.

	Signed-off-by: Rahul Lakkireddy <rahul.lakkireddy@chelsio.com>
	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 578b46b9383c3619cc0a6002ff867e732b08b67a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --cc drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
index 1d7bd82a1fb1,23742cb1c69f..000000000000
--- a/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
+++ b/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
@@@ -30,33 -32,17 +30,42 @@@
   * SOFTWARE.
   */
  
 -#ifndef __CXGB4_FILTER_H
 -#define __CXGB4_FILTER_H
 +/*
 + * This file is conditionally built on PowerPC only.  Otherwise weak symbol
 + * versions of the functions exported from here are used.
 + */
  
 -#include "t4_msg.h"
 +#include "ipath_kernel.h"
  
 -void filter_rpl(struct adapter *adap, const struct cpl_set_tcb_rpl *rpl);
 -void clear_filter(struct adapter *adap, struct filter_entry *f);
 +/**
 + * ipath_enable_wc - enable write combining for MMIO writes to the device
 + * @dd: infinipath device
 + *
 + * Nothing to do on PowerPC, so just return without error.
 + */
 +int ipath_enable_wc(struct ipath_devdata *dd)
 +{
 +	return 0;
 +}
  
++<<<<<<< HEAD:drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
 +/**
 + * ipath_unordered_wc - indicate whether write combining is unordered
 + *
 + * Because our performance depends on our ability to do write
 + * combining mmio writes in the most efficient way, we need to
 + * know if we are on a processor that may reorder stores when
 + * write combining.
 + */
 +int ipath_unordered_wc(void)
 +{
 +	return 1;
 +}
++=======
+ int set_filter_wr(struct adapter *adapter, int fidx);
+ int delete_filter(struct adapter *adapter, unsigned int fidx);
+ 
+ int writable_filter(struct filter_entry *f);
+ void clear_all_filters(struct adapter *adapter);
+ #endif /* __CXGB4_FILTER_H */
++>>>>>>> 578b46b9383c (cxgb4: add common api support for configuring filters):drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.h
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index 70d5542c0f8b,51edb126da65..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@@ -941,6 -1025,32 +941,35 @@@ enum 
  	VLAN_REWRITE
  };
  
++<<<<<<< HEAD
++=======
+ /* Host shadow copy of ingress filter entry.  This is in host native format
+  * and doesn't match the ordering or bit order, etc. of the hardware of the
+  * firmware command.  The use of bit-field structure elements is purely to
+  * remind ourselves of the field size limitations and save memory in the case
+  * where the filter table is large.
+  */
+ struct filter_entry {
+ 	/* Administrative fields for filter. */
+ 	u32 valid:1;            /* filter allocated and valid */
+ 	u32 locked:1;           /* filter is administratively locked */
+ 
+ 	u32 pending:1;          /* filter action is pending firmware reply */
+ 	u32 smtidx:8;           /* Source MAC Table index for smac */
+ 	struct filter_ctx *ctx; /* Caller's completion hook */
+ 	struct l2t_entry *l2t;  /* Layer Two Table entry for dmac */
+ 	struct net_device *dev; /* Associated net device */
+ 	u32 tid;                /* This will store the actual tid */
+ 
+ 	/* The filter itself.  Most of this is a straight copy of information
+ 	 * provided by the extended ioctl().  Some fields are translated to
+ 	 * internal forms -- for instance the Ingress Queue ID passed in from
+ 	 * the ioctl() is translated into the Absolute Ingress Queue ID.
+ 	 */
+ 	struct ch_filter_specification fs;
+ };
+ 
++>>>>>>> 578b46b9383c (cxgb4: add common api support for configuring filters)
  static inline int is_offload(const struct adapter *adap)
  {
  	return adap->params.offload;
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index b2bcf538138f,e97daa0510e5..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -5240,7 -4824,17 +5249,21 @@@ static int init_one(struct pci_dev *pde
  		}
  	}
  #endif
++<<<<<<< HEAD
 +	if (is_offload(adapter) && tid_init(&adapter->tids) < 0) {
++=======
+ 
+ 	for_each_port(adapter, i) {
+ 		pi = adap2pinfo(adapter, i);
+ 		pi->sched_tbl = t4_init_sched(adapter->params.nsched_cls);
+ 		if (!pi->sched_tbl)
+ 			dev_warn(&pdev->dev,
+ 				 "could not activate scheduling on port %d\n",
+ 				 i);
+ 	}
+ 
+ 	if (tid_init(&adapter->tids) < 0) {
++>>>>>>> 578b46b9383c (cxgb4: add common api support for configuring filters)
  		dev_warn(&pdev->dev, "could not allocate TID table, "
  			 "continuing\n");
  		adapter->params.offload = 0;
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c
* Unmerged path drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_filter.c
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h
index f3c58aaa932d..41bd12a182ae 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h
@@ -1,7 +1,7 @@
 /*
  * This file is part of the Chelsio T4 Ethernet driver for Linux.
  *
- * Copyright (c) 2003-2014 Chelsio Communications, Inc. All rights reserved.
+ * Copyright (c) 2003-2016 Chelsio Communications, Inc. All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -104,6 +104,7 @@ struct tid_info {
 	unsigned int atid_base;
 
 	struct filter_entry *ftid_tab;
+	unsigned long *ftid_bmap;
 	unsigned int nftids;
 	unsigned int ftid_base;
 	unsigned int aftid_base;
@@ -124,6 +125,8 @@ struct tid_info {
 	atomic_t tids_in_use;
 	/* TIDs in the HASH */
 	atomic_t hash_tids_in_use;
+	/* lock for setting/clearing filter bitmap */
+	spinlock_t ftid_lock;
 };
 
 static inline void *lookup_tid(const struct tid_info *t, unsigned int tid)
@@ -183,6 +186,27 @@ int cxgb4_create_server_filter(const struct net_device *dev, unsigned int stid,
 int cxgb4_remove_server_filter(const struct net_device *dev, unsigned int stid,
 			       unsigned int queue, bool ipv6);
 
+/* Filter operation context to allow callers of cxgb4_set_filter() and
+ * cxgb4_del_filter() to wait for an asynchronous completion.
+ */
+struct filter_ctx {
+	struct completion completion;	/* completion rendezvous */
+	void *closure;			/* caller's opaque information */
+	int result;			/* result of operation */
+	u32 tid;			/* to store tid */
+};
+
+struct ch_filter_specification;
+
+int __cxgb4_set_filter(struct net_device *dev, int filter_id,
+		       struct ch_filter_specification *fs,
+		       struct filter_ctx *ctx);
+int __cxgb4_del_filter(struct net_device *dev, int filter_id,
+		       struct filter_ctx *ctx);
+int cxgb4_set_filter(struct net_device *dev, int filter_id,
+		     struct ch_filter_specification *fs);
+int cxgb4_del_filter(struct net_device *dev, int filter_id);
+
 static inline void set_wr_txq(struct sk_buff *skb, int prio, int queue)
 {
 	skb_set_queue_mapping(skb, (queue << 1) | prio);
