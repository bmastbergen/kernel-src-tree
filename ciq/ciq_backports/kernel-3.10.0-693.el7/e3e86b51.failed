ipv6: Fix leak in ipv6_gso_segment().

jira LE-1907
cve CVE-2017-9074
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] ipv6: Fix leak in ipv6_gso_segment() (Eric Garver) [1459950] {CVE-2017-9074}
Rebuild_FUZZ: 98.63%
commit-author David S. Miller <davem@davemloft.net>
commit e3e86b5119f81e5e2499bea7ea1ebe8ac6aab789
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e3e86b51.failed

If ip6_find_1stfragopt() fails and we return an error we have to free
up 'segs' because nobody else is going to.

Fixes: 2423496af35d ("ipv6: Prevent overrun when parsing v6 header options")
	Reported-by: Ben Hutchings <ben@decadent.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e3e86b5119f81e5e2499bea7ea1ebe8ac6aab789)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_offload.c
diff --cc net/ipv6/ip6_offload.c
index b3b3d9e4ed02,cdb3728faca7..000000000000
--- a/net/ipv6/ip6_offload.c
+++ b/net/ipv6/ip6_offload.c
@@@ -104,12 -115,14 +104,21 @@@ static struct sk_buff *ipv6_gso_segment
  		skb->network_header = (u8 *)ipv6h - skb->head;
  
  		if (udpfrag) {
++<<<<<<< HEAD
 +			unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);
 +			if (unfrag_ip6hlen < 0)
 +				return ERR_PTR(unfrag_ip6hlen);
 +			fptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);
++=======
+ 			int err = ip6_find_1stfragopt(skb, &prevhdr);
+ 			if (err < 0) {
+ 				kfree_skb_list(segs);
+ 				return ERR_PTR(err);
+ 			}
+ 			fptr = (struct frag_hdr *)((u8 *)ipv6h + err);
++>>>>>>> e3e86b5119f8 (ipv6: Fix leak in ipv6_gso_segment().)
  			fptr->frag_off = htons(offset);
 -			if (skb->next)
 +			if (skb->next != NULL)
  				fptr->frag_off |= htons(IP6_MF);
  			offset += (ntohs(ipv6h->payload_len) -
  				   sizeof(struct frag_hdr));
* Unmerged path net/ipv6/ip6_offload.c
