KVM: PPC: Book3S HV: Add check for module parameter halt_poll_ns

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Suraj Jitindar Singh <sjitindarsingh@gmail.com>
commit e03f3921e597cbcc6880033e5c52fa1db524f88b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e03f3921.failed

The kvm module parameter halt_poll_ns defines the global maximum halt
polling interval and can be dynamically changed by writing to the
/sys/module/kvm/parameters/halt_poll_ns sysfs file. However in kvm-hv
this module parameter value is only ever checked when we grow the current
polling interval for the given vcore. This means that if we decrease the
halt_poll_ns value below the current polling interval we won't see any
effect unless we try to grow the polling interval above the new max at some
point or it happens to be shrunk below the halt_poll_ns value.

Update the halt polling code so that we always check for a new module param
value of halt_poll_ns and set the current halt polling interval to it if
it's currently greater than the new max. This means that it's redundant to
also perform this check in the grow_halt_poll_ns() function now.

	Signed-off-by: Suraj Jitindar Singh <sjitindarsingh@gmail.com>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit e03f3921e597cbcc6880033e5c52fa1db524f88b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv.c
diff --cc arch/powerpc/kvm/book3s_hv.c
index 32dd0caea96b,0b0ca272a13c..000000000000
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@@ -2579,6 -2592,39 +2579,42 @@@ static void kvmppc_wait_for_exec(struc
  	finish_wait(&vcpu->arch.cpu_run, &wait);
  }
  
++<<<<<<< HEAD
++=======
+ static void grow_halt_poll_ns(struct kvmppc_vcore *vc)
+ {
+ 	/* 10us base */
+ 	if (vc->halt_poll_ns == 0 && halt_poll_ns_grow)
+ 		vc->halt_poll_ns = 10000;
+ 	else
+ 		vc->halt_poll_ns *= halt_poll_ns_grow;
+ }
+ 
+ static void shrink_halt_poll_ns(struct kvmppc_vcore *vc)
+ {
+ 	if (halt_poll_ns_shrink == 0)
+ 		vc->halt_poll_ns = 0;
+ 	else
+ 		vc->halt_poll_ns /= halt_poll_ns_shrink;
+ }
+ 
+ /* Check to see if any of the runnable vcpus on the vcore have pending
+  * exceptions or are no longer ceded
+  */
+ static int kvmppc_vcore_check_block(struct kvmppc_vcore *vc)
+ {
+ 	struct kvm_vcpu *vcpu;
+ 	int i;
+ 
+ 	for_each_runnable_thread(i, vcpu, vc) {
+ 		if (vcpu->arch.pending_exceptions || !vcpu->arch.ceded)
+ 			return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> e03f3921e597 (KVM: PPC: Book3S HV: Add check for module parameter halt_poll_ns)
  /*
   * All the vcpus in this vcore are idle, so wait for a decrementer
   * or external interrupt to one of the vcpus.  vc->lock is held.
@@@ -2616,6 -2683,47 +2652,50 @@@ static void kvmppc_vcore_blocked(struc
  	spin_lock(&vc->lock);
  	vc->vcore_state = VCORE_INACTIVE;
  	trace_kvmppc_vcore_blocked(vc, 1);
++<<<<<<< HEAD
++=======
+ 	++vc->runner->stat.halt_successful_wait;
+ 
+ 	cur = ktime_get();
+ 
+ out:
+ 	block_ns = ktime_to_ns(cur) - ktime_to_ns(start_poll);
+ 
+ 	/* Attribute wait time */
+ 	if (do_sleep) {
+ 		vc->runner->stat.halt_wait_ns +=
+ 			ktime_to_ns(cur) - ktime_to_ns(start_wait);
+ 		/* Attribute failed poll time */
+ 		if (vc->halt_poll_ns)
+ 			vc->runner->stat.halt_poll_fail_ns +=
+ 				ktime_to_ns(start_wait) -
+ 				ktime_to_ns(start_poll);
+ 	} else {
+ 		/* Attribute successful poll time */
+ 		if (vc->halt_poll_ns)
+ 			vc->runner->stat.halt_poll_success_ns +=
+ 				ktime_to_ns(cur) -
+ 				ktime_to_ns(start_poll);
+ 	}
+ 
+ 	/* Adjust poll time */
+ 	if (halt_poll_ns) {
+ 		if (block_ns <= vc->halt_poll_ns)
+ 			;
+ 		/* We slept and blocked for longer than the max halt time */
+ 		else if (vc->halt_poll_ns && block_ns > halt_poll_ns)
+ 			shrink_halt_poll_ns(vc);
+ 		/* We slept and our poll time is too small */
+ 		else if (vc->halt_poll_ns < halt_poll_ns &&
+ 				block_ns < halt_poll_ns)
+ 			grow_halt_poll_ns(vc);
+ 		if (vc->halt_poll_ns > halt_poll_ns)
+ 			vc->halt_poll_ns = halt_poll_ns;
+ 	} else
+ 		vc->halt_poll_ns = 0;
+ 
+ 	trace_kvmppc_vcore_wakeup(do_sleep, block_ns);
++>>>>>>> e03f3921e597 (KVM: PPC: Book3S HV: Add check for module parameter halt_poll_ns)
  }
  
  static int kvmppc_run_vcpu(struct kvm_run *kvm_run, struct kvm_vcpu *vcpu)
* Unmerged path arch/powerpc/kvm/book3s_hv.c
