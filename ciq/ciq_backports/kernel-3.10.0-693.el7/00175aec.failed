net/sched: Macro instead of CONFIG_NET_CLS_ACT ifdef

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: Macro instead of CONFIG_NET_CLS_ACT ifdef (Ivan Vecera) [1390693]
Rebuild_FUZZ: 96.00%
commit-author Amir Vadai <amir@vadai.me>
commit 00175aec941e9c306d8a5ce930b2d91f7c04468c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/00175aec.failed

Introduce the macros tc_no_actions and tc_for_each_action to make code
clearer.
Extracted struct tc_action out of the ifdef to make calls to
is_tcf_gact_shot() and similar functions valid, even when it is a nop.

	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: John Fastabend <john.r.fastabend@intel.com>
	Suggested-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Amir Vadai <amir@vadai.me>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 00175aec941e9c306d8a5ce930b2d91f7c04468c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/act_api.h
diff --cc include/net/act_api.h
index 11aac9abd0ca,2a19fe111c78..000000000000
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@@ -46,10 -51,32 +46,39 @@@ static inline unsigned int tcf_hash(u3
  	return index & hmask;
  }
  
++<<<<<<< HEAD
 +#ifdef CONFIG_NET_CLS_ACT
 +
 +#define ACT_P_CREATED 1
 +#define ACT_P_DELETED 1
++=======
+ static inline int tcf_hashinfo_init(struct tcf_hashinfo *hf, unsigned int mask)
+ {
+ 	int i;
+ 
+ 	spin_lock_init(&hf->lock);
+ 	hf->index = 0;
+ 	hf->hmask = mask;
+ 	hf->htab = kzalloc((mask + 1) * sizeof(struct hlist_head),
+ 			   GFP_KERNEL);
+ 	if (!hf->htab)
+ 		return -ENOMEM;
+ 	for (i = 0; i < mask + 1; i++)
+ 		INIT_HLIST_HEAD(&hf->htab[i]);
+ 	return 0;
+ }
+ 
+ /* Update lastuse only if needed, to avoid dirtying a cache line.
+  * We use a temp variable to avoid fetching jiffies twice.
+  */
+ static inline void tcf_lastuse_update(struct tcf_t *tm)
+ {
+ 	unsigned long now = jiffies;
+ 
+ 	if (tm->lastuse != now)
+ 		tm->lastuse = now;
+ }
++>>>>>>> 00175aec941e (net/sched: Macro instead of CONFIG_NET_CLS_ACT ifdef)
  
  struct tc_action {
  	void			*priv;
@@@ -57,15 -84,18 +86,23 @@@
  	__u32			type; /* for backward compat(TCA_OLD_COMPAT) */
  	__u32			order;
  	struct list_head	list;
 -	struct tcf_hashinfo	*hinfo;
  };
  
++<<<<<<< HEAD
 +#define TCA_CAP_NONE 0
++=======
+ #ifdef CONFIG_NET_CLS_ACT
+ 
+ #define ACT_P_CREATED 1
+ #define ACT_P_DELETED 1
+ 
++>>>>>>> 00175aec941e (net/sched: Macro instead of CONFIG_NET_CLS_ACT ifdef)
  struct tc_action_ops {
  	struct list_head head;
 +	struct tcf_hashinfo *hinfo;
  	char    kind[IFNAMSIZ];
  	__u32   type; /* TBD to match kind */
 +	__u32 	capab;  /* capabilities includes 4 bit version */
  	struct module		*owner;
  	int     (*act)(struct sk_buff *, const struct tc_action *, struct tcf_result *);
  	int     (*dump)(struct sk_buff *, struct tc_action *, int, int);
* Unmerged path include/net/act_api.h
diff --git a/include/net/tc_act/tc_gact.h b/include/net/tc_act/tc_gact.h
index 4d7bab551551..0a61d39b818f 100644
--- a/include/net/tc_act/tc_gact.h
+++ b/include/net/tc_act/tc_gact.h
@@ -15,9 +15,9 @@ struct tcf_gact {
 #define to_gact(pc) \
 	container_of(pc, struct tcf_gact, common)
 
-#ifdef CONFIG_NET_CLS_ACT
 static inline bool is_tcf_gact_shot(const struct tc_action *a)
 {
+#ifdef CONFIG_NET_CLS_ACT
 	struct tcf_gact *gact;
 
 	if (a->ops && a->ops->type != TCA_ACT_GACT)
@@ -27,7 +27,7 @@ static inline bool is_tcf_gact_shot(const struct tc_action *a)
 	if (gact->tcf_action == TC_ACT_SHOT)
 		return true;
 
+#endif
 	return false;
 }
-#endif
 #endif /* __NET_TC_GACT_H */
