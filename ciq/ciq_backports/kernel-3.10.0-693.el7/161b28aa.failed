iommu/vt-d: Make sure IOMMUs are off when intel_iommu=off

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [iommu] vt-d: Make sure IOMMUs are off when intel_iommu=off (Baoquan He) [1441413]
Rebuild_FUZZ: 94.44%
commit-author Joerg Roedel <jroedel@suse.de>
commit 161b28aae1651aa7ad63ec14753aa8a751154340
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/161b28aa.failed

When booting into a kexec kernel with intel_iommu=off, and
the previous kernel had intel_iommu=on, the IOMMU hardware
is still enabled and gets not disabled by the new kernel.

This causes the boot to fail because DMA is blocked by the
hardware. Disable the IOMMUs when we find it enabled in the
kexec kernel and boot with intel_iommu=off.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 161b28aae1651aa7ad63ec14753aa8a751154340)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index e612f7f3a1be,5f08ba13972b..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -4408,6 -4701,48 +4408,51 @@@ static struct notifier_block intel_iomm
  	.priority = 0
  };
  
++<<<<<<< HEAD
++=======
+ static void free_all_cpu_cached_iovas(unsigned int cpu)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < g_num_of_iommus; i++) {
+ 		struct intel_iommu *iommu = g_iommus[i];
+ 		struct dmar_domain *domain;
+ 		int did;
+ 
+ 		if (!iommu)
+ 			continue;
+ 
+ 		for (did = 0; did < cap_ndoms(iommu->cap); did++) {
+ 			domain = get_iommu_domain(iommu, (u16)did);
+ 
+ 			if (!domain)
+ 				continue;
+ 			free_cpu_cached_iovas(cpu, &domain->iovad);
+ 		}
+ 	}
+ }
+ 
+ static int intel_iommu_cpu_dead(unsigned int cpu)
+ {
+ 	free_all_cpu_cached_iovas(cpu);
+ 	flush_unmaps_timeout(cpu);
+ 	return 0;
+ }
+ 
+ static void intel_disable_iommus(void)
+ {
+ 	struct intel_iommu *iommu = NULL;
+ 	struct dmar_drhd_unit *drhd;
+ 
+ 	for_each_iommu(iommu, drhd)
+ 		iommu_disable_translation(iommu);
+ }
+ 
+ static inline struct intel_iommu *dev_to_intel_iommu(struct device *dev)
+ {
+ 	return container_of(dev, struct intel_iommu, iommu.dev);
+ }
++>>>>>>> 161b28aae165 (iommu/vt-d: Make sure IOMMUs are off when intel_iommu=off)
  
  static ssize_t intel_iommu_show_version(struct device *dev,
  					struct device_attribute *attr,
* Unmerged path drivers/iommu/intel-iommu.c
