net: __skb_flow_dissect() must cap its return value

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] flow_dissector: __skb_flow_dissect() must cap its return value (Jonathan Toppins) [1428557]
Rebuild_FUZZ: 88.50%
commit-author Eric Dumazet <edumazet@google.com>
commit 34fad54c2537f7c99d07375e50cb30aa3c23bd83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/34fad54c.failed

After Tom patch, thoff field could point past the end of the buffer,
this could fool some callers.

If an skb was provided, skb->len should be the upper limit.
If not, hlen is supposed to be the upper limit.

Fixes: a6e544b0a88b ("flow_dissector: Jump to exit code in __skb_flow_dissect")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: Yibin Yang <yibyang@cisco.com
	Acked-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Acked-by: Willem de Bruijn <willemb@google.com>
	Acked-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 34fad54c2537f7c99d07375e50cb30aa3c23bd83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,69e4463a4b1b..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -116,13 -101,28 +116,26 @@@ EXPORT_SYMBOL(__skb_flow_get_ports)
   * @nhoff: network header offset, if @data is NULL use skb_network_offset(skb)
   * @hlen: packet header length, if @data is NULL use skb_headlen(skb)
   *
 - * The function will try to retrieve individual keys into target specified
 - * by flow_dissector from either the skbuff or a raw buffer specified by the
 - * rest parameters.
 - *
 - * Caller must take care of zeroing target container memory.
 + * The function will try to retrieve the struct flow_keys from either the skbuff
 + * or a raw buffer specified by the rest parameters
   */
 -bool __skb_flow_dissect(const struct sk_buff *skb,
 -			struct flow_dissector *flow_dissector,
 -			void *target_container,
 -			void *data, __be16 proto, int nhoff, int hlen,
 -			unsigned int flags)
 +bool __skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow,
 +			void *data, __be16 proto, int nhoff, int hlen)
  {
++<<<<<<< HEAD
 +	u8 ip_proto;
++=======
+ 	struct flow_dissector_key_control *key_control;
+ 	struct flow_dissector_key_basic *key_basic;
+ 	struct flow_dissector_key_addrs *key_addrs;
+ 	struct flow_dissector_key_ports *key_ports;
+ 	struct flow_dissector_key_tags *key_tags;
+ 	struct flow_dissector_key_vlan *key_vlan;
+ 	struct flow_dissector_key_keyid *key_keyid;
+ 	bool skip_vlan = false;
+ 	u8 ip_proto = 0;
+ 	bool ret;
++>>>>>>> 34fad54c2537 (net: __skb_flow_dissect() must cap its return value)
  
  	if (!data) {
  		data = skb->data;
@@@ -319,12 -537,29 +332,29 @@@ ip_proto_again
  		break;
  	}
  
 -	if (dissector_uses_key(flow_dissector,
 -			       FLOW_DISSECTOR_KEY_PORTS)) {
 -		key_ports = skb_flow_dissector_target(flow_dissector,
 -						      FLOW_DISSECTOR_KEY_PORTS,
 -						      target_container);
 -		key_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,
 -							data, hlen);
 -	}
 +	flow->n_proto = proto;
 +	flow->ip_proto = ip_proto;
 +	flow->ports = __skb_flow_get_ports(skb, nhoff, ip_proto, data, hlen);
 +	flow->thoff = (u16) nhoff;
  
++<<<<<<< HEAD
 +	return true;
++=======
+ out_good:
+ 	ret = true;
+ 
+ 	key_control->thoff = (u16)nhoff;
+ out:
+ 	key_basic->n_proto = proto;
+ 	key_basic->ip_proto = ip_proto;
+ 
+ 	return ret;
+ 
+ out_bad:
+ 	ret = false;
+ 	key_control->thoff = min_t(u16, nhoff, skb ? skb->len : hlen);
+ 	goto out;
++>>>>>>> 34fad54c2537 (net: __skb_flow_dissect() must cap its return value)
  }
  EXPORT_SYMBOL(__skb_flow_dissect);
  
* Unmerged path net/core/flow_dissector.c
