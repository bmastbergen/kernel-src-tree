HID: wacom: rely on actual touch down count to decide touch_down

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: rely on actual touch down count to decide touch_down (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.93%
commit-author Ping Cheng <pinglinux@gmail.com>
commit e0d41fd435ad71b86380f27195aa117400439f37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e0d41fd4.failed

touch_down is a flag to indicate if there are touches on tablet
or not. Since one set of touch events may be posted over more
than one data packet/touch frame, and pen may come in proximity
while touch events are partially sent, counting all touch events
for the set reflects the actual status of touch_down.

	Signed-off-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit e0d41fd435ad71b86380f27195aa117400439f37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index d83376be6444,cf767419cdc4..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -856,9 -992,61 +856,9 @@@ static int int_dist(int x1, int y1, in
  static int wacom_24hdt_irq(struct wacom_wac *wacom)
  {
  	struct input_dev *input = wacom->input;
 -	unsigned char *data = wacom->data;
 +	char *data = wacom->data;
  	int i;
- 	int current_num_contacts = 0;
+ 	int current_num_contacts = data[61];
  	int contacts_to_send = 0;
  	int num_contacts_left = 4; /* maximum contacts per packet */
  	int byte_per_packet = WACOM_BYTES_PER_24HDT_PACKET;
@@@ -911,14 -1100,16 +912,20 @@@
  				input_report_abs(input, ABS_MT_WIDTH_MINOR, min(w, h));
  				input_report_abs(input, ABS_MT_ORIENTATION, w > h);
  			}
+ 			contact_with_no_pen_down_count++;
  		}
  	}
 -	input_mt_report_pointer_emulation(input, true);
 +	input_mt_sync_frame(input);
  
  	wacom->num_contacts_left -= contacts_to_send;
- 	if (wacom->num_contacts_left <= 0)
+ 	if (wacom->num_contacts_left <= 0) {
  		wacom->num_contacts_left = 0;
++<<<<<<< HEAD
 +
++=======
+ 		wacom->shared->touch_down = (contact_with_no_pen_down_count > 0);
+ 	}
++>>>>>>> e0d41fd435ad (HID: wacom: rely on actual touch down count to decide touch_down)
  	return 1;
  }
  
@@@ -930,9 -1121,10 +937,10 @@@ static int wacom_mt_touch(struct wacom_
  	int current_num_contacts = data[2];
  	int contacts_to_send = 0;
  	int x_offset = 0;
+ 	static int contact_with_no_pen_down_count = 0;
  
  	/* MTTPC does not support Height and Width */
 -	if (wacom->features.type == MTTPC || wacom->features.type == MTTPC_B)
 +	if (wacom->features.type == MTTPC)
  		x_offset = -4;
  
  	/*
@@@ -957,18 -1151,20 +967,24 @@@
  		input_mt_slot(input, slot);
  		input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
  		if (touch) {
 -			int x = get_unaligned_le16(&data[offset + x_offset + 7]);
 -			int y = get_unaligned_le16(&data[offset + x_offset + 9]);
 +			int x = le16_to_cpup((__le16 *)&data[offset + x_offset + 7]);
 +			int y = le16_to_cpup((__le16 *)&data[offset + x_offset + 9]);
  			input_report_abs(input, ABS_MT_POSITION_X, x);
  			input_report_abs(input, ABS_MT_POSITION_Y, y);
+ 			contact_with_no_pen_down_count++;
  		}
  	}
 -	input_mt_report_pointer_emulation(input, true);
 +	input_mt_sync_frame(input);
  
  	wacom->num_contacts_left -= contacts_to_send;
- 	if (wacom->num_contacts_left < 0)
+ 	if (wacom->num_contacts_left <= 0) {
  		wacom->num_contacts_left = 0;
++<<<<<<< HEAD
 +
++=======
+ 		wacom->shared->touch_down = (contact_with_no_pen_down_count > 0);
+ 	}
++>>>>>>> e0d41fd435ad (HID: wacom: rely on actual touch down count to decide touch_down)
  	return 1;
  }
  
@@@ -1004,27 -1200,27 +1020,43 @@@ static int wacom_tpc_mt_touch(struct wa
  
  static int wacom_tpc_single_touch(struct wacom_wac *wacom, size_t len)
  {
 -	unsigned char *data = wacom->data;
 +	char *data = wacom->data;
  	struct input_dev *input = wacom->input;
- 	bool prox;
+ 	bool prox = !wacom->shared->stylus_in_proximity;
  	int x = 0, y = 0;
  
  	if (wacom->features.touch_max > 1 || len > WACOM_PKGLEN_TPC2FG)
  		return 0;
  
++<<<<<<< HEAD
 +	if (!wacom->shared->stylus_in_proximity) {
 +		if (len == WACOM_PKGLEN_TPC1FG) {
 +			prox = data[0] & 0x01;
 +			x = get_unaligned_le16(&data[1]);
 +			y = get_unaligned_le16(&data[3]);
 +		} else {
 +			prox = data[1] & 0x01;
 +			x = le16_to_cpup((__le16 *)&data[2]);
 +			y = le16_to_cpup((__le16 *)&data[4]);
 +		}
 +	} else
 +		/* force touch out when pen is in prox */
 +		prox = 0;
++=======
+ 	if (len == WACOM_PKGLEN_TPC1FG) {
+ 		prox = prox && (data[0] & 0x01);
+ 		x = get_unaligned_le16(&data[1]);
+ 		y = get_unaligned_le16(&data[3]);
+ 	} else if (len == WACOM_PKGLEN_TPC1FG_B) {
+ 		prox = prox && (data[2] & 0x01);
+ 		x = get_unaligned_le16(&data[3]);
+ 		y = get_unaligned_le16(&data[5]);
+ 	} else {
+ 		prox = prox && (data[1] & 0x01);
+ 		x = le16_to_cpup((__le16 *)&data[2]);
+ 		y = le16_to_cpup((__le16 *)&data[4]);
+ 	}
++>>>>>>> e0d41fd435ad (HID: wacom: rely on actual touch down count to decide touch_down)
  
  	if (prox) {
  		input_report_abs(input, ABS_X, x);
@@@ -1108,8 -1615,10 +1140,9 @@@ static int wacom_bpt_touch(struct wacom
  {
  	struct wacom_features *features = &wacom->features;
  	struct input_dev *input = wacom->input;
 -	struct input_dev *pad_input = wacom->pad_input;
  	unsigned char *data = wacom->data;
  	int i;
+ 	int contact_with_no_pen_down_count = 0;
  
  	if (data[0] != 0x02)
  	    return 0;
@@@ -1140,19 -1650,18 +1174,27 @@@
  		}
  	}
  
 -	input_mt_report_pointer_emulation(input, true);
 +	input_mt_sync_frame(input);
  
++<<<<<<< HEAD
 +	input_report_key(input, BTN_LEFT, (data[1] & 0x08) != 0);
 +	input_report_key(input, BTN_FORWARD, (data[1] & 0x04) != 0);
 +	input_report_key(input, BTN_BACK, (data[1] & 0x02) != 0);
 +	input_report_key(input, BTN_RIGHT, (data[1] & 0x01) != 0);
++=======
+ 	input_report_key(pad_input, BTN_LEFT, (data[1] & 0x08) != 0);
+ 	input_report_key(pad_input, BTN_FORWARD, (data[1] & 0x04) != 0);
+ 	input_report_key(pad_input, BTN_BACK, (data[1] & 0x02) != 0);
+ 	input_report_key(pad_input, BTN_RIGHT, (data[1] & 0x01) != 0);
+ 	wacom->shared->touch_down = (contact_with_no_pen_down_count > 0);
++>>>>>>> e0d41fd435ad (HID: wacom: rely on actual touch down count to decide touch_down)
  
 -	return 1;
 +	input_sync(input);
 +
 +	return 0;
  }
  
- static void wacom_bpt3_touch_msg(struct wacom_wac *wacom, unsigned char *data)
+ static int wacom_bpt3_touch_msg(struct wacom_wac *wacom, unsigned char *data, int last_touch_count)
  {
  	struct wacom_features *features = &wacom->features;
  	struct input_dev *input = wacom->input;
@@@ -1226,11 -1746,10 +1273,16 @@@ static int wacom_bpt3_touch(struct waco
  			wacom_bpt3_button_msg(wacom, data + offset);
  
  	}
++<<<<<<< HEAD
 +	input_mt_sync_frame(input);
++=======
+ 	input_mt_report_pointer_emulation(input, true);
+ 	wacom->shared->touch_down = (contact_with_no_pen_down_count > 0);
++>>>>>>> e0d41fd435ad (HID: wacom: rely on actual touch down count to decide touch_down)
  
 -	return 1;
 +	input_sync(input);
 +
 +	return 0;
  }
  
  static int wacom_bpt_pen(struct wacom_wac *wacom)
* Unmerged path drivers/hid/wacom_wac.c
