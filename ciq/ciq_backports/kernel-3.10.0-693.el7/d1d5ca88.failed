scsi: be2iscsi: Add TPE recovery feature

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] be2iscsi: Add TPE recovery feature (Maurizio Lombardi) [1382263]
Rebuild_FUZZ: 91.89%
commit-author Jitendra Bhivare <jitendra.bhivare@broadcom.com>
commit d1d5ca887c0ee60ec6c6e42db0c1073155a09d32
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d1d5ca88.failed

After UE is detected, check for recoverable error by reading
SLIPORT SEMAPHORE register. If transient parity error i.e. 0xExxx
then schedule recovery work on driver wq.

FLag this error to prevent any transactions for the duration of ue2rp to
restart polling. After that, if FW becomes ready then recover port.

Wake up processes in wq before going offline.
Wait for process to execute before cleaning up.

	Signed-off-by: Jitendra Bhivare <jitendra.bhivare@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit d1d5ca887c0ee60ec6c6e42db0c1073155a09d32)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/be2iscsi/be_cmds.c
#	drivers/scsi/be2iscsi/be_cmds.h
#	drivers/scsi/be2iscsi/be_iscsi.c
#	drivers/scsi/be2iscsi/be_main.c
#	drivers/scsi/be2iscsi/be_main.h
#	drivers/scsi/be2iscsi/be_mgmt.c
diff --cc drivers/scsi/be2iscsi/be_cmds.c
index 403296239ae9,ad7405d6821f..000000000000
--- a/drivers/scsi/be2iscsi/be_cmds.c
+++ b/drivers/scsi/be2iscsi/be_cmds.c
@@@ -21,34 -21,77 +21,108 @@@
  #include "be.h"
  #include "be_mgmt.h"
  
++<<<<<<< HEAD
 +int be_chk_reset_complete(struct beiscsi_hba *phba)
 +{
 +	unsigned int num_loop;
 +	u8 *mpu_sem = 0;
 +	u32 status;
 +
 +	num_loop = 1000;
 +	mpu_sem = (u8 *)phba->csr_va + MPU_EP_SEMAPHORE;
 +	msleep(5000);
 +
 +	while (num_loop) {
 +		status = readl((void *)mpu_sem);
 +
 +		if ((status & 0x80000000) || (status & 0x0000FFFF) == 0xC000)
 +			break;
 +		msleep(60);
 +		num_loop--;
 +	}
 +
 +	if ((status & 0x80000000) || (!num_loop)) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 +			    "BC_%d : Failed in be_chk_reset_complete"
 +			    "status = 0x%x\n", status);
 +		return -EIO;
 +	}
 +
 +	return 0;
 +}
++=======
+ /* UE Status Low CSR */
+ static const char * const desc_ue_status_low[] = {
+ 	"CEV",
+ 	"CTX",
+ 	"DBUF",
+ 	"ERX",
+ 	"Host",
+ 	"MPU",
+ 	"NDMA",
+ 	"PTC ",
+ 	"RDMA ",
+ 	"RXF ",
+ 	"RXIPS ",
+ 	"RXULP0 ",
+ 	"RXULP1 ",
+ 	"RXULP2 ",
+ 	"TIM ",
+ 	"TPOST ",
+ 	"TPRE ",
+ 	"TXIPS ",
+ 	"TXULP0 ",
+ 	"TXULP1 ",
+ 	"UC ",
+ 	"WDMA ",
+ 	"TXULP2 ",
+ 	"HOST1 ",
+ 	"P0_OB_LINK ",
+ 	"P1_OB_LINK ",
+ 	"HOST_GPIO ",
+ 	"MBOX ",
+ 	"AXGMAC0",
+ 	"AXGMAC1",
+ 	"JTAG",
+ 	"MPU_INTPEND"
+ };
+ 
+ /* UE Status High CSR */
+ static const char * const desc_ue_status_hi[] = {
+ 	"LPCMEMHOST",
+ 	"MGMT_MAC",
+ 	"PCS0ONLINE",
+ 	"MPU_IRAM",
+ 	"PCS1ONLINE",
+ 	"PCTL0",
+ 	"PCTL1",
+ 	"PMEM",
+ 	"RR",
+ 	"TXPB",
+ 	"RXPP",
+ 	"XAUI",
+ 	"TXP",
+ 	"ARM",
+ 	"IPC",
+ 	"HOST2",
+ 	"HOST3",
+ 	"HOST4",
+ 	"HOST5",
+ 	"HOST6",
+ 	"HOST7",
+ 	"HOST8",
+ 	"HOST9",
+ 	"NETC",
+ 	"Unknown",
+ 	"Unknown",
+ 	"Unknown",
+ 	"Unknown",
+ 	"Unknown",
+ 	"Unknown",
+ 	"Unknown",
+ 	"Unknown"
+ };
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  
  struct be_mcc_wrb *alloc_mcc_wrb(struct beiscsi_hba *phba,
  				 unsigned int *ref_tag)
@@@ -145,22 -245,29 +219,40 @@@ int beiscsi_mccq_compl_wait(struct beis
  			    struct be_dma_mem *mbx_cmd_mem)
  {
  	int rc = 0;
 +	uint32_t mcc_tag_status;
 +	uint16_t status = 0, addl_status = 0, wrb_num = 0;
 +	struct be_mcc_wrb *temp_wrb;
 +	struct be_cmd_req_hdr *mbx_hdr;
 +	struct be_cmd_resp_hdr *mbx_resp_hdr;
 +	struct be_queue_info *mccq = &phba->ctrl.mcc_obj.q;
  
 -	if (beiscsi_hba_in_error(phba)) {
 -		clear_bit(MCC_TAG_STATE_RUNNING,
 -			  &phba->ctrl.ptag_state[tag].tag_state);
 -		return -EIO;
 -	}
 +	if (beiscsi_error(phba))
 +		return -EPERM;
  
  	/* wait for the mccq completion */
++<<<<<<< HEAD
 +	rc = wait_event_interruptible_timeout(
 +				phba->ctrl.mcc_wait[tag],
 +				phba->ctrl.mcc_tag_status[tag],
 +				msecs_to_jiffies(
 +				BEISCSI_HOST_MBX_TIMEOUT));
++=======
+ 	rc = wait_event_interruptible_timeout(phba->ctrl.mcc_wait[tag],
+ 					      phba->ctrl.mcc_tag_status[tag],
+ 					      msecs_to_jiffies(
+ 						BEISCSI_HOST_MBX_TIMEOUT));
+ 	/**
+ 	 * Return EIO if port is being disabled. Associated DMA memory, if any,
+ 	 * is freed by the caller. When port goes offline, MCCQ is cleaned up
+ 	 * so does WRB.
+ 	 */
+ 	if (!test_bit(BEISCSI_HBA_ONLINE, &phba->state)) {
+ 		clear_bit(MCC_TAG_STATE_RUNNING,
+ 			  &phba->ctrl.ptag_state[tag].tag_state);
+ 		return -EIO;
+ 	}
+ 
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  	/**
  	 * If MBOX cmd timeout expired, tag and resource allocated
  	 * for cmd is not freed until FW returns completion.
@@@ -586,10 -619,7 +678,14 @@@ static int be_mbox_db_ready_poll(struc
  	beiscsi_log(phba, KERN_ERR,
  			BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
  			"BC_%d : FW Timed Out\n");
++<<<<<<< HEAD
 +
 +	phba->fw_timeout = true;
 +	beiscsi_ue_detect(phba);
 +
++=======
+ 	set_bit(BEISCSI_HBA_FW_TIMEOUT, &phba->state);
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  	return -EBUSY;
  }
  
@@@ -1327,3 -1257,564 +1423,567 @@@ int be_cmd_set_vlan(struct beiscsi_hba 
  
  	return tag;
  }
++<<<<<<< HEAD
++=======
+ 
+ int beiscsi_check_supported_fw(struct be_ctrl_info *ctrl,
+ 			       struct beiscsi_hba *phba)
+ {
+ 	struct be_dma_mem nonemb_cmd;
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct be_mgmt_controller_attributes *req;
+ 	struct be_sge *sge = nonembedded_sgl(wrb);
+ 	int status = 0;
+ 
+ 	nonemb_cmd.va = pci_alloc_consistent(ctrl->pdev,
+ 				sizeof(struct be_mgmt_controller_attributes),
+ 				&nonemb_cmd.dma);
+ 	if (nonemb_cmd.va == NULL) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : pci_alloc_consistent failed in %s\n",
+ 			    __func__);
+ 		return -ENOMEM;
+ 	}
+ 	nonemb_cmd.size = sizeof(struct be_mgmt_controller_attributes);
+ 	req = nonemb_cmd.va;
+ 	memset(req, 0, sizeof(*req));
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	be_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);
+ 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_GET_CNTL_ATTRIBUTES, sizeof(*req));
+ 	sge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd.dma));
+ 	sge->pa_lo = cpu_to_le32(nonemb_cmd.dma & 0xFFFFFFFF);
+ 	sge->len = cpu_to_le32(nonemb_cmd.size);
+ 	status = be_mbox_notify(ctrl);
+ 	if (!status) {
+ 		struct be_mgmt_controller_attributes_resp *resp = nonemb_cmd.va;
+ 
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : Firmware Version of CMD : %s\n"
+ 			    "Firmware Version is : %s\n"
+ 			    "Developer Build, not performing version check...\n",
+ 			    resp->params.hba_attribs
+ 			    .flashrom_version_string,
+ 			    resp->params.hba_attribs.
+ 			    firmware_version_string);
+ 
+ 		phba->fw_config.iscsi_features =
+ 				resp->params.hba_attribs.iscsi_features;
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BM_%d : phba->fw_config.iscsi_features = %d\n",
+ 			    phba->fw_config.iscsi_features);
+ 		memcpy(phba->fw_ver_str, resp->params.hba_attribs.
+ 		       firmware_version_string, BEISCSI_VER_STRLEN);
+ 	} else
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d :  Failed in beiscsi_check_supported_fw\n");
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	if (nonemb_cmd.va)
+ 		pci_free_consistent(ctrl->pdev, nonemb_cmd.size,
+ 				    nonemb_cmd.va, nonemb_cmd.dma);
+ 
+ 	return status;
+ }
+ 
+ /**
+  * beiscsi_get_fw_config()- Get the FW config for the function
+  * @ctrl: ptr to Ctrl Info
+  * @phba: ptr to the dev priv structure
+  *
+  * Get the FW config and resources available for the function.
+  * The resources are created based on the count received here.
+  *
+  * return
+  *	Success: 0
+  *	Failure: Non-Zero Value
+  **/
+ int beiscsi_get_fw_config(struct be_ctrl_info *ctrl,
+ 			  struct beiscsi_hba *phba)
+ {
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct be_fw_cfg *pfw_cfg = embedded_payload(wrb);
+ 	uint32_t cid_count, icd_count;
+ 	int status = -EINVAL;
+ 	uint8_t ulp_num = 0;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	be_wrb_hdr_prepare(wrb, sizeof(*pfw_cfg), true, 0);
+ 
+ 	be_cmd_hdr_prepare(&pfw_cfg->hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_QUERY_FIRMWARE_CONFIG,
+ 			   EMBED_MBX_MAX_PAYLOAD_SIZE);
+ 
+ 	if (be_mbox_notify(ctrl)) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : Failed in beiscsi_get_fw_config\n");
+ 		goto fail_init;
+ 	}
+ 
+ 	/* FW response formats depend on port id */
+ 	phba->fw_config.phys_port = pfw_cfg->phys_port;
+ 	if (phba->fw_config.phys_port >= BEISCSI_PHYS_PORT_MAX) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : invalid physical port id %d\n",
+ 			    phba->fw_config.phys_port);
+ 		goto fail_init;
+ 	}
+ 
+ 	/* populate and check FW config against min and max values */
+ 	if (!is_chip_be2_be3r(phba)) {
+ 		phba->fw_config.eqid_count = pfw_cfg->eqid_count;
+ 		phba->fw_config.cqid_count = pfw_cfg->cqid_count;
+ 		if (phba->fw_config.eqid_count == 0 ||
+ 		    phba->fw_config.eqid_count > 2048) {
+ 			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 				    "BG_%d : invalid EQ count %d\n",
+ 				    phba->fw_config.eqid_count);
+ 			goto fail_init;
+ 		}
+ 		if (phba->fw_config.cqid_count == 0 ||
+ 		    phba->fw_config.cqid_count > 4096) {
+ 			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 				    "BG_%d : invalid CQ count %d\n",
+ 				    phba->fw_config.cqid_count);
+ 			goto fail_init;
+ 		}
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : EQ_Count : %d CQ_Count : %d\n",
+ 			    phba->fw_config.eqid_count,
+ 			    phba->fw_config.cqid_count);
+ 	}
+ 
+ 	/**
+ 	 * Check on which all ULP iSCSI Protocol is loaded.
+ 	 * Set the Bit for those ULP. This set flag is used
+ 	 * at all places in the code to check on which ULP
+ 	 * iSCSi Protocol is loaded
+ 	 **/
+ 	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {
+ 		if (pfw_cfg->ulp[ulp_num].ulp_mode &
+ 		    BEISCSI_ULP_ISCSI_INI_MODE) {
+ 			set_bit(ulp_num, &phba->fw_config.ulp_supported);
+ 
+ 			/* Get the CID, ICD and Chain count for each ULP */
+ 			phba->fw_config.iscsi_cid_start[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].sq_base;
+ 			phba->fw_config.iscsi_cid_count[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].sq_count;
+ 
+ 			phba->fw_config.iscsi_icd_start[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].icd_base;
+ 			phba->fw_config.iscsi_icd_count[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].icd_count;
+ 
+ 			phba->fw_config.iscsi_chain_start[ulp_num] =
+ 				pfw_cfg->chain_icd[ulp_num].chain_base;
+ 			phba->fw_config.iscsi_chain_count[ulp_num] =
+ 				pfw_cfg->chain_icd[ulp_num].chain_count;
+ 
+ 			beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 				    "BG_%d : Function loaded on ULP : %d\n"
+ 				    "\tiscsi_cid_count : %d\n"
+ 				    "\tiscsi_cid_start : %d\n"
+ 				    "\t iscsi_icd_count : %d\n"
+ 				    "\t iscsi_icd_start : %d\n",
+ 				    ulp_num,
+ 				    phba->fw_config.
+ 				    iscsi_cid_count[ulp_num],
+ 				    phba->fw_config.
+ 				    iscsi_cid_start[ulp_num],
+ 				    phba->fw_config.
+ 				    iscsi_icd_count[ulp_num],
+ 				    phba->fw_config.
+ 				    iscsi_icd_start[ulp_num]);
+ 		}
+ 	}
+ 
+ 	if (phba->fw_config.ulp_supported == 0) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : iSCSI initiator mode not set: ULP0 %x ULP1 %x\n",
+ 			    pfw_cfg->ulp[BEISCSI_ULP0].ulp_mode,
+ 			    pfw_cfg->ulp[BEISCSI_ULP1].ulp_mode);
+ 		goto fail_init;
+ 	}
+ 
+ 	/**
+ 	 * ICD is shared among ULPs. Use icd_count of any one loaded ULP
+ 	 **/
+ 	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)
+ 		if (test_bit(ulp_num, &phba->fw_config.ulp_supported))
+ 			break;
+ 	icd_count = phba->fw_config.iscsi_icd_count[ulp_num];
+ 	if (icd_count == 0 || icd_count > 65536) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d: invalid ICD count %d\n", icd_count);
+ 		goto fail_init;
+ 	}
+ 
+ 	cid_count = BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP0) +
+ 		    BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP1);
+ 	if (cid_count == 0 || cid_count > 4096) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d: invalid CID count %d\n", cid_count);
+ 		goto fail_init;
+ 	}
+ 
+ 	/**
+ 	 * Check FW is dual ULP aware i.e. can handle either
+ 	 * of the protocols.
+ 	 */
+ 	phba->fw_config.dual_ulp_aware = (pfw_cfg->function_mode &
+ 					  BEISCSI_FUNC_DUA_MODE);
+ 
+ 	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 		    "BG_%d : DUA Mode : 0x%x\n",
+ 		    phba->fw_config.dual_ulp_aware);
+ 
+ 	/* all set, continue using this FW config */
+ 	status = 0;
+ fail_init:
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return status;
+ }
+ 
+ /**
+  * beiscsi_get_port_name()- Get port name for the function
+  * @ctrl: ptr to Ctrl Info
+  * @phba: ptr to the dev priv structure
+  *
+  * Get the alphanumeric character for port
+  *
+  **/
+ int beiscsi_get_port_name(struct be_ctrl_info *ctrl, struct beiscsi_hba *phba)
+ {
+ 	int ret = 0;
+ 	struct be_mcc_wrb *wrb;
+ 	struct be_cmd_get_port_name *ioctl;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	ioctl = embedded_payload(wrb);
+ 
+ 	be_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);
+ 	be_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_GET_PORT_NAME,
+ 			   EMBED_MBX_MAX_PAYLOAD_SIZE);
+ 	ret = be_mbox_notify(ctrl);
+ 	phba->port_name = 0;
+ 	if (!ret) {
+ 		phba->port_name = ioctl->p.resp.port_names >>
+ 				  (phba->fw_config.phys_port * 8) & 0xff;
+ 	} else {
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : GET_PORT_NAME ret 0x%x status 0x%x\n",
+ 			    ret, ioctl->h.resp_hdr.status);
+ 	}
+ 
+ 	if (phba->port_name == 0)
+ 		phba->port_name = '?';
+ 
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return ret;
+ }
+ 
+ int beiscsi_set_uer_feature(struct beiscsi_hba *phba)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct be_cmd_set_features *ioctl;
+ 	struct be_mcc_wrb *wrb;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	ioctl = embedded_payload(wrb);
+ 
+ 	be_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);
+ 	be_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_SET_FEATURES,
+ 			   EMBED_MBX_MAX_PAYLOAD_SIZE);
+ 	ioctl->feature = BE_CMD_SET_FEATURE_UER;
+ 	ioctl->param_len = sizeof(ioctl->param.req);
+ 	ioctl->param.req.uer = BE_CMD_UER_SUPP_BIT;
+ 	ret = be_mbox_notify(ctrl);
+ 	if (!ret) {
+ 		phba->ue2rp = ioctl->param.resp.ue2rp;
+ 		set_bit(BEISCSI_HBA_UER_SUPP, &phba->state);
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : HBA error recovery supported\n");
+ 	} else {
+ 		/**
+ 		 * Check "MCC_STATUS_INVALID_LENGTH" for SKH.
+ 		 * Older FW versions return this error.
+ 		 */
+ 		if (ret == MCC_STATUS_ILLEGAL_REQUEST ||
+ 		    ret == MCC_STATUS_INVALID_LENGTH)
+ 			__beiscsi_log(phba, KERN_INFO,
+ 				      "BG_%d : HBA error recovery not supported\n");
+ 	}
+ 
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return ret;
+ }
+ 
+ static u32 beiscsi_get_post_stage(struct beiscsi_hba *phba)
+ {
+ 	u32 sem;
+ 
+ 	if (is_chip_be2_be3r(phba))
+ 		sem = ioread32(phba->csr_va + SLIPORT_SEMAPHORE_OFFSET_BEx);
+ 	else
+ 		pci_read_config_dword(phba->pcidev,
+ 				      SLIPORT_SEMAPHORE_OFFSET_SH, &sem);
+ 	return sem;
+ }
+ 
+ int beiscsi_check_fw_rdy(struct beiscsi_hba *phba)
+ {
+ 	u32 loop, post, rdy = 0;
+ 
+ 	loop = 1000;
+ 	while (loop--) {
+ 		post = beiscsi_get_post_stage(phba);
+ 		if (post & POST_ERROR_BIT)
+ 			break;
+ 		if ((post & POST_STAGE_MASK) == POST_STAGE_ARMFW_RDY) {
+ 			rdy = 1;
+ 			break;
+ 		}
+ 		msleep(60);
+ 	}
+ 
+ 	if (!rdy) {
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BC_%d : FW not ready 0x%x\n", post);
+ 	}
+ 
+ 	return rdy;
+ }
+ 
+ static int beiscsi_cmd_function_reset(struct beiscsi_hba  *phba)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct be_post_sgl_pages_req *req = embedded_payload(wrb);
+ 	int status;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 
+ 	req = embedded_payload(wrb);
+ 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
+ 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_FUNCTION_RESET, sizeof(*req));
+ 	status = be_mbox_notify(ctrl);
+ 
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return status;
+ }
+ 
+ int beiscsi_cmd_special_wrb(struct be_ctrl_info *ctrl, u32 load)
+ {
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);
+ 	u8 *endian_check;
+ 	int status;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 
+ 	endian_check = (u8 *) wrb;
+ 	if (load) {
+ 		/* to start communicating */
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0x12;
+ 		*endian_check++ = 0x34;
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0x56;
+ 		*endian_check++ = 0x78;
+ 		*endian_check++ = 0xFF;
+ 	} else {
+ 		/* to stop communicating */
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0xAA;
+ 		*endian_check++ = 0xBB;
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0xCC;
+ 		*endian_check++ = 0xDD;
+ 		*endian_check = 0xFF;
+ 	}
+ 	be_dws_cpu_to_le(wrb, sizeof(*wrb));
+ 
+ 	status = be_mbox_notify(ctrl);
+ 	if (status)
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BC_%d : special WRB message failed\n");
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return status;
+ }
+ 
+ int beiscsi_init_sliport(struct beiscsi_hba *phba)
+ {
+ 	int status;
+ 
+ 	/* check POST stage before talking to FW */
+ 	status = beiscsi_check_fw_rdy(phba);
+ 	if (!status)
+ 		return -EIO;
+ 
+ 	/* clear all error states after checking FW rdy */
+ 	phba->state &= ~BEISCSI_HBA_IN_ERR;
+ 
+ 	/* check again UER support */
+ 	phba->state &= ~BEISCSI_HBA_UER_SUPP;
+ 
+ 	/*
+ 	 * SLI COMMON_FUNCTION_RESET completion is indicated by BMBX RDY bit.
+ 	 * It should clean up any stale info in FW for this fn.
+ 	 */
+ 	status = beiscsi_cmd_function_reset(phba);
+ 	if (status) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BC_%d : SLI Function Reset failed\n");
+ 		return status;
+ 	}
+ 
+ 	/* indicate driver is loading */
+ 	return beiscsi_cmd_special_wrb(&phba->ctrl, 1);
+ }
+ 
+ /**
+  * beiscsi_cmd_iscsi_cleanup()- Inform FW to cleanup EP data structures.
+  * @phba: pointer to dev priv structure
+  * @ulp: ULP number.
+  *
+  * return
+  *	Success: 0
+  *	Failure: Non-Zero Value
+  **/
+ int beiscsi_cmd_iscsi_cleanup(struct beiscsi_hba *phba, unsigned short ulp)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct iscsi_cleanup_req_v1 *req_v1;
+ 	struct iscsi_cleanup_req *req;
+ 	struct be_mcc_wrb *wrb;
+ 	int status;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	req = embedded_payload(wrb);
+ 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
+ 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,
+ 			   OPCODE_COMMON_ISCSI_CLEANUP, sizeof(*req));
+ 
+        /**
+ 	* TODO: Check with FW folks the chute value to be set.
+ 	* For now, use the ULP_MASK as the chute value.
+ 	*/
+ 	if (is_chip_be2_be3r(phba)) {
+ 		req->chute = (1 << ulp);
+ 		req->hdr_ring_id = HWI_GET_DEF_HDRQ_ID(phba, ulp);
+ 		req->data_ring_id = HWI_GET_DEF_BUFQ_ID(phba, ulp);
+ 	} else {
+ 		req_v1 = (struct iscsi_cleanup_req_v1 *)req;
+ 		req_v1->hdr.version = 1;
+ 		req_v1->hdr_ring_id = cpu_to_le16(HWI_GET_DEF_HDRQ_ID(phba,
+ 								      ulp));
+ 		req_v1->data_ring_id = cpu_to_le16(HWI_GET_DEF_BUFQ_ID(phba,
+ 								       ulp));
+ 	}
+ 
+ 	status = be_mbox_notify(ctrl);
+ 	if (status)
+ 		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,
+ 			    "BG_%d : %s failed %d\n", __func__, ulp);
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return status;
+ }
+ 
+ /*
+  * beiscsi_detect_ue()- Detect Unrecoverable Error on adapter
+  * @phba: Driver priv structure
+  *
+  * Read registers linked to UE and check for the UE status
+  **/
+ int beiscsi_detect_ue(struct beiscsi_hba *phba)
+ {
+ 	uint32_t ue_mask_hi = 0, ue_mask_lo = 0;
+ 	uint32_t ue_hi = 0, ue_lo = 0;
+ 	uint8_t i = 0;
+ 	int ret = 0;
+ 
+ 	pci_read_config_dword(phba->pcidev,
+ 			      PCICFG_UE_STATUS_LOW, &ue_lo);
+ 	pci_read_config_dword(phba->pcidev,
+ 			      PCICFG_UE_STATUS_MASK_LOW,
+ 			      &ue_mask_lo);
+ 	pci_read_config_dword(phba->pcidev,
+ 			      PCICFG_UE_STATUS_HIGH,
+ 			      &ue_hi);
+ 	pci_read_config_dword(phba->pcidev,
+ 			      PCICFG_UE_STATUS_MASK_HI,
+ 			      &ue_mask_hi);
+ 
+ 	ue_lo = (ue_lo & ~ue_mask_lo);
+ 	ue_hi = (ue_hi & ~ue_mask_hi);
+ 
+ 
+ 	if (ue_lo || ue_hi) {
+ 		set_bit(BEISCSI_HBA_IN_UE, &phba->state);
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BC_%d : HBA error detected\n");
+ 		ret = 1;
+ 	}
+ 
+ 	if (ue_lo) {
+ 		for (i = 0; ue_lo; ue_lo >>= 1, i++) {
+ 			if (ue_lo & 1)
+ 				__beiscsi_log(phba, KERN_ERR,
+ 					      "BC_%d : UE_LOW %s bit set\n",
+ 					      desc_ue_status_low[i]);
+ 		}
+ 	}
+ 
+ 	if (ue_hi) {
+ 		for (i = 0; ue_hi; ue_hi >>= 1, i++) {
+ 			if (ue_hi & 1)
+ 				__beiscsi_log(phba, KERN_ERR,
+ 					      "BC_%d : UE_HIGH %s bit set\n",
+ 					      desc_ue_status_hi[i]);
+ 		}
+ 	}
+ 	return ret;
+ }
+ 
+ /*
+  * beiscsi_detect_tpe()- Detect Transient Parity Error on adapter
+  * @phba: Driver priv structure
+  *
+  * Read SLIPORT SEMAPHORE register to check for UER
+  *
+  **/
+ int beiscsi_detect_tpe(struct beiscsi_hba *phba)
+ {
+ 	u32 post, status;
+ 	int ret = 0;
+ 
+ 	post = beiscsi_get_post_stage(phba);
+ 	status = post & POST_STAGE_MASK;
+ 	if ((status & POST_ERR_RECOVERY_CODE_MASK) ==
+ 	    POST_STAGE_RECOVERABLE_ERR) {
+ 		set_bit(BEISCSI_HBA_IN_TPE, &phba->state);
+ 		__beiscsi_log(phba, KERN_INFO,
+ 			      "BC_%d : HBA error recoverable: 0x%x\n", post);
+ 		ret = 1;
+ 	} else {
+ 		__beiscsi_log(phba, KERN_INFO,
+ 			      "BC_%d : HBA in UE: 0x%x\n", post);
+ 	}
+ 
+ 	return ret;
+ }
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
diff --cc drivers/scsi/be2iscsi/be_cmds.h
index c50b74afd00a,26d7921f48a4..000000000000
--- a/drivers/scsi/be2iscsi/be_cmds.h
+++ b/drivers/scsi/be2iscsi/be_cmds.h
@@@ -714,9 -730,50 +714,52 @@@ struct be_cmd_hba_name 
  	u16 flags;
  	u16 rsvd0;
  	u8 initiator_name[ISCSI_NAME_LEN];
 -#define BE_INI_ALIAS_LEN 32
 -	u8 initiator_alias[BE_INI_ALIAS_LEN];
 +	u8 initiator_alias[BEISCSI_ALIAS_LEN];
  } __packed;
  
++<<<<<<< HEAD
++=======
+ /******************** COMMON SET Features *******************/
+ #define BE_CMD_SET_FEATURE_UER	0x10
+ #define BE_CMD_UER_SUPP_BIT	0x1
+ struct be_uer_req {
+ 	u32 uer;
+ 	u32 rsvd;
+ };
+ 
+ struct be_uer_resp {
+ 	u32 uer;
+ 	u16 ue2rp;
+ 	u16 ue2sr;
+ };
+ 
+ struct be_cmd_set_features {
+ 	union {
+ 		struct be_cmd_req_hdr req_hdr;
+ 		struct be_cmd_resp_hdr resp_hdr;
+ 	} h;
+ 	u32 feature;
+ 	u32 param_len;
+ 	union {
+ 		struct be_uer_req req;
+ 		struct be_uer_resp resp;
+ 		u32 rsvd[2];
+ 	} param;
+ } __packed;
+ 
+ int beiscsi_cmd_special_wrb(struct be_ctrl_info *ctrl, u32 load);
+ 
+ int beiscsi_check_fw_rdy(struct beiscsi_hba *phba);
+ 
+ int beiscsi_init_sliport(struct beiscsi_hba *phba);
+ 
+ int beiscsi_cmd_iscsi_cleanup(struct beiscsi_hba *phba, unsigned short ulp_num);
+ 
+ int beiscsi_detect_ue(struct beiscsi_hba *phba);
+ 
+ int beiscsi_detect_tpe(struct beiscsi_hba *phba);
+ 
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  int beiscsi_cmd_eq_create(struct be_ctrl_info *ctrl,
  			  struct be_queue_info *eq, int eq_delay);
  
diff --cc drivers/scsi/be2iscsi/be_iscsi.c
index faa37f67a8e6,35f7d3aab366..000000000000
--- a/drivers/scsi/be2iscsi/be_iscsi.c
+++ b/drivers/scsi/be2iscsi/be_iscsi.c
@@@ -59,15 -58,14 +59,21 @@@ struct iscsi_cls_session *beiscsi_sessi
  	beiscsi_ep = ep->dd_data;
  	phba = beiscsi_ep->phba;
  
++<<<<<<< HEAD
 +	if (phba->state & BE_ADAPTER_PCI_ERR) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
 +			    "BS_%d : PCI_ERROR Recovery\n");
++=======
+ 	if (!beiscsi_hba_is_online(phba)) {
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+ 			    "BS_%d : HBA in error 0x%lx\n", phba->state);
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  		return NULL;
 +	} else {
 +		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
 +			    "BS_%d : In beiscsi_session_create\n");
  	}
  
 -	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
 -		    "BS_%d : In beiscsi_session_create\n");
  	if (cmds_max > beiscsi_ep->phba->params.wrbs_per_cxn) {
  		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
  			    "BS_%d : Cannot handle %d cmds."
@@@ -436,9 -444,9 +442,15 @@@ int beiscsi_iface_set_param(struct Scsi
  	uint32_t rm_len = dt_len;
  	int ret;
  
++<<<<<<< HEAD
 +	if (phba->state & BE_ADAPTER_PCI_ERR) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
 +			    "BS_%d : In PCI_ERROR Recovery\n");
++=======
+ 	if (!beiscsi_hba_is_online(phba)) {
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+ 			    "BS_%d : HBA in error 0x%lx\n", phba->state);
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  		return -EBUSY;
  	}
  
@@@ -579,9 -587,9 +591,15 @@@ int beiscsi_iface_get_param(struct iscs
  
  	if (param_type != ISCSI_NET_PARAM)
  		return 0;
++<<<<<<< HEAD
 +	if (phba->state & BE_ADAPTER_PCI_ERR) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
 +			    "BS_%d : In PCI_ERROR Recovery\n");
++=======
+ 	if (!beiscsi_hba_is_online(phba)) {
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+ 			    "BS_%d : HBA in error 0x%lx\n", phba->state);
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  		return -EBUSY;
  	}
  
@@@ -789,16 -797,13 +807,22 @@@ int beiscsi_get_host_param(struct Scsi_
  	struct beiscsi_hba *phba = iscsi_host_priv(shost);
  	int status = 0;
  
++<<<<<<< HEAD
 +
 +	if (phba->state & BE_ADAPTER_PCI_ERR) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
 +			    "BS_%d : In PCI_ERROR Recovery\n");
++=======
+ 	if (!beiscsi_hba_is_online(phba)) {
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+ 			    "BS_%d : HBA in error 0x%lx\n", phba->state);
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  		return -EBUSY;
 +	} else {
 +		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
 +			    "BS_%d : In beiscsi_get_host_param,"
 +			    " param = %d\n", param);
  	}
 -	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
 -		    "BS_%d : In beiscsi_get_host_param, param = %d\n", param);
  
  	switch (param) {
  	case ISCSI_HOST_PARAM_HWADDRESS:
@@@ -940,15 -945,13 +964,21 @@@ int beiscsi_conn_start(struct iscsi_cls
  
  	phba = ((struct beiscsi_conn *)conn->dd_data)->phba;
  
++<<<<<<< HEAD
 +	if (phba->state & BE_ADAPTER_PCI_ERR) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
 +			    "BS_%d : In PCI_ERROR Recovery\n");
++=======
+ 	if (!beiscsi_hba_is_online(phba)) {
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+ 			    "BS_%d : HBA in error 0x%lx\n", phba->state);
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  		return -EBUSY;
 +	} else {
 +		beiscsi_log(beiscsi_conn->phba, KERN_INFO,
 +			    BEISCSI_LOG_CONFIG,
 +			    "BS_%d : In beiscsi_conn_start\n");
  	}
 -	beiscsi_log(beiscsi_conn->phba, KERN_INFO, BEISCSI_LOG_CONFIG,
 -		    "BS_%d : In beiscsi_conn_start\n");
  
  	memset(&params, 0, sizeof(struct beiscsi_offload_params));
  	beiscsi_ep = beiscsi_conn->ep;
@@@ -1174,19 -1174,14 +1204,24 @@@ beiscsi_ep_connect(struct Scsi_Host *sh
  		return ERR_PTR(ret);
  	}
  
++<<<<<<< HEAD
 +	if (beiscsi_error(phba)) {
++=======
+ 	phba = iscsi_host_priv(shost);
+ 	if (!beiscsi_hba_is_online(phba)) {
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  		ret = -EIO;
 -		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
 -			    "BS_%d : HBA in error 0x%lx\n", phba->state);
 +		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,
 +			    "BS_%d : The FW state Not Stable!!!\n");
  		return ERR_PTR(ret);
  	}
 -	if (!test_bit(BEISCSI_HBA_LINK_UP, &phba->state)) {
 +
 +	if (phba->state & BE_ADAPTER_PCI_ERR) {
 +		ret = -EBUSY;
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
 +			    "BS_%d : In PCI_ERROR Recovery\n");
 +		return ERR_PTR(ret);
 +	} else if (phba->state & BE_ADAPTER_LINK_DOWN) {
  		ret = -EBUSY;
  		beiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,
  			    "BS_%d : The Adapter Port state is Down!!!\n");
@@@ -1340,9 -1335,9 +1375,15 @@@ void beiscsi_ep_disconnect(struct iscsi
  		tcp_upload_flag = CONNECTION_UPLOAD_ABORT;
  	}
  
++<<<<<<< HEAD
 +	if (phba->state & BE_ADAPTER_PCI_ERR) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
 +			    "BS_%d : PCI_ERROR Recovery\n");
++=======
+ 	if (!beiscsi_hba_is_online(phba)) {
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+ 			    "BS_%d : HBA in error 0x%lx\n", phba->state);
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  		goto free_ep;
  	}
  
diff --cc drivers/scsi/be2iscsi/be_main.c
index 8e3a0f9d2ac4,0625bd0c449f..000000000000
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@@ -3679,68 -3584,6 +3722,71 @@@ static void be_mcc_queues_destroy(struc
  	}
  }
  
++<<<<<<< HEAD
 +static void hwi_cleanup(struct beiscsi_hba *phba)
 +{
 +	struct be_queue_info *q;
 +	struct be_ctrl_info *ctrl = &phba->ctrl;
 +	struct hwi_controller *phwi_ctrlr;
 +	struct hwi_context_memory *phwi_context;
 +	struct hwi_async_pdu_context *pasync_ctx;
 +	int i, eq_for_mcc, ulp_num;
 +
 +	phwi_ctrlr = phba->phwi_ctrlr;
 +	phwi_context = phwi_ctrlr->phwi_ctxt;
 +
 +	be_cmd_iscsi_remove_template_hdr(ctrl);
 +
 +	for (i = 0; i < phba->params.cxns_per_ctrl; i++) {
 +		q = &phwi_context->be_wrbq[i];
 +		if (q->created)
 +			beiscsi_cmd_q_destroy(ctrl, q, QTYPE_WRBQ);
 +	}
 +	kfree(phwi_context->be_wrbq);
 +	free_wrb_handles(phba);
 +
 +	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {
 +		if (test_bit(ulp_num, &phba->fw_config.ulp_supported)) {
 +
 +			q = &phwi_context->be_def_hdrq[ulp_num];
 +			if (q->created)
 +				beiscsi_cmd_q_destroy(ctrl, q, QTYPE_DPDUQ);
 +
 +			q = &phwi_context->be_def_dataq[ulp_num];
 +			if (q->created)
 +				beiscsi_cmd_q_destroy(ctrl, q, QTYPE_DPDUQ);
 +
 +			pasync_ctx = phwi_ctrlr->phwi_ctxt->pasync_ctx[ulp_num];
 +		}
 +	}
 +
 +	beiscsi_cmd_q_destroy(ctrl, NULL, QTYPE_SGL);
 +
 +	for (i = 0; i < (phba->num_cpus); i++) {
 +		q = &phwi_context->be_cq[i];
 +		if (q->created) {
 +			be_queue_free(phba, q);
 +			beiscsi_cmd_q_destroy(ctrl, q, QTYPE_CQ);
 +		}
 +	}
 +
 +	be_mcc_queues_destroy(phba);
 +	if (phba->msix_enabled)
 +		eq_for_mcc = 1;
 +	else
 +		eq_for_mcc = 0;
 +	for (i = 0; i < (phba->num_cpus + eq_for_mcc); i++) {
 +		q = &phwi_context->be_eq[i].q;
 +		if (q->created) {
 +			be_queue_free(phba, q);
 +			beiscsi_cmd_q_destroy(ctrl, q, QTYPE_EQ);
 +		}
 +	}
 +	be_cmd_fw_uninit(ctrl);
 +}
 +
++=======
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  static int be_mcc_queues_create(struct beiscsi_hba *phba,
  				struct hwi_context_memory *phwi_context)
  {
@@@ -4479,57 -4295,11 +4634,64 @@@ do_cleanup_ctrlr
  	return ret;
  }
  
++<<<<<<< HEAD
 +static void hwi_purge_eq(struct beiscsi_hba *phba)
 +{
 +	struct hwi_controller *phwi_ctrlr;
 +	struct hwi_context_memory *phwi_context;
 +	struct be_queue_info *eq;
 +	struct be_eq_entry *eqe = NULL;
 +	int i, eq_msix;
 +	unsigned int num_processed;
 +
 +	phwi_ctrlr = phba->phwi_ctrlr;
 +	phwi_context = phwi_ctrlr->phwi_ctxt;
 +	if (phba->msix_enabled)
 +		eq_msix = 1;
 +	else
 +		eq_msix = 0;
 +
 +	for (i = 0; i < (phba->num_cpus + eq_msix); i++) {
 +		eq = &phwi_context->be_eq[i].q;
 +		eqe = queue_tail_node(eq);
 +		num_processed = 0;
 +		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 +					& EQE_VALID_MASK) {
 +			AMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);
 +			queue_tail_inc(eq);
 +			eqe = queue_tail_node(eq);
 +			num_processed++;
 +		}
 +
 +		if (num_processed)
 +			hwi_ring_eq_db(phba, eq->id, 1,	num_processed, 1, 1);
 +	}
 +}
 +
 +static void beiscsi_clean_port(struct beiscsi_hba *phba)
++=======
+ static void beiscsi_cleanup_port(struct beiscsi_hba *phba)
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  {
 +	int mgmt_status, ulp_num;
  	struct ulp_cid_info *ptr_cid_info = NULL;
 -	int ulp_num;
  
++<<<<<<< HEAD
 +	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {
 +		if (test_bit(ulp_num, (void *)&phba->fw_config.ulp_supported)) {
 +			mgmt_status = mgmt_epfw_cleanup(phba, ulp_num);
 +			if (mgmt_status)
 +				beiscsi_log(phba, KERN_WARNING,
 +					    BEISCSI_LOG_INIT,
 +					    "BM_%d : mgmt_epfw_cleanup FAILED"
 +					    " for ULP_%d\n", ulp_num);
 +		}
 +	}
 +
 +	hwi_purge_eq(phba);
 +	hwi_cleanup(phba);
++=======
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  	kfree(phba->io_sgl_hndl_base);
  	kfree(phba->eh_sgl_hndl_base);
  	kfree(phba->ep_array);
@@@ -5127,6 -4883,15 +5288,18 @@@ static int beiscsi_task_xmit(struct isc
  	int num_sg;
  	unsigned int  writedir = 0, xferlen = 0;
  
++<<<<<<< HEAD
++=======
+ 	phba = io_task->conn->phba;
+ 	/**
+ 	 * HBA in error includes BEISCSI_HBA_FW_TIMEOUT. IO path might be
+ 	 * operational if FW still gets heartbeat from EP FW. Is management
+ 	 * path really needed to continue further?
+ 	 */
+ 	if (!beiscsi_hba_is_online(phba))
+ 		return -EIO;
+ 
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  	if (!io_task->conn->login_in_progress)
  		task->hdr->exp_statsn = 0;
  
@@@ -5175,6 -4945,12 +5348,15 @@@ static int beiscsi_bsg_request(struct b
  	shost = iscsi_job_to_shost(job);
  	phba = iscsi_host_priv(shost);
  
++<<<<<<< HEAD
++=======
+ 	if (!beiscsi_hba_is_online(phba)) {
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
+ 			    "BM_%d : HBA in error 0x%lx\n", phba->state);
+ 		return -ENXIO;
+ 	}
+ 
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  	switch (bsg_req->msgcode) {
  	case ISCSI_BSG_HST_VENDOR:
  		nonemb_cmd.va = pci_alloc_consistent(phba->ctrl.pdev,
@@@ -5245,186 -5029,548 +5435,686 @@@ void beiscsi_hba_attrs_init(struct beis
  	beiscsi_log_enable_init(phba, beiscsi_log_enable);
  }
  
++<<<<<<< HEAD
 +/*
 + * beiscsi_quiesce()- Cleanup Driver resources
 + * @phba: Instance Priv structure
 + * @unload_state:i Clean or EEH unload state
 + *
 + * Free the OS and HW resources held by the driver
 + **/
 +static void beiscsi_quiesce(struct beiscsi_hba *phba,
 +		uint32_t unload_state)
 +{
 +	struct hwi_controller *phwi_ctrlr;
 +	struct hwi_context_memory *phwi_context;
 +	struct be_eq_obj *pbe_eq;
 +	unsigned int i, msix_vec;
 +
 +	phwi_ctrlr = phba->phwi_ctrlr;
 +	phwi_context = phwi_ctrlr->phwi_ctxt;
 +	hwi_disable_intr(phba);
 +	if (phba->msix_enabled) {
 +		for (i = 0; i <= phba->num_cpus; i++) {
 +			msix_vec = phba->msix_entries[i].vector;
 +			free_irq(msix_vec, &phwi_context->be_eq[i]);
 +			kfree(phba->msi_name[i]);
 +		}
 +	} else
 +		if (phba->pcidev->irq)
 +			free_irq(phba->pcidev->irq, phba);
 +	pci_disable_msix(phba->pcidev);
 +	cancel_delayed_work_sync(&phba->beiscsi_hw_check_task);
 +
 +	for (i = 0; i < phba->num_cpus; i++) {
 +		pbe_eq = &phwi_context->be_eq[i];
 +		irq_poll_disable(&pbe_eq->iopoll);
 +	}
 +
 +	if (unload_state == BEISCSI_CLEAN_UNLOAD) {
 +		destroy_workqueue(phba->wq);
 +		beiscsi_clean_port(phba);
 +		beiscsi_free_mem(phba);
 +
 +		beiscsi_unmap_pci_function(phba);
 +		pci_free_consistent(phba->pcidev,
 +				    phba->ctrl.mbox_mem_alloced.size,
 +				    phba->ctrl.mbox_mem_alloced.va,
 +				    phba->ctrl.mbox_mem_alloced.dma);
 +	} else {
 +		hwi_purge_eq(phba);
 +		hwi_cleanup(phba);
 +	}
 +
 +}
 +
 +static void beiscsi_remove(struct pci_dev *pcidev)
 +{
 +	struct beiscsi_hba *phba = NULL;
 +
 +	phba = pci_get_drvdata(pcidev);
 +	if (!phba) {
 +		dev_err(&pcidev->dev, "beiscsi_remove called with no phba\n");
 +		return;
 +	}
 +
 +	beiscsi_iface_destroy_default(phba);
 +	iscsi_boot_destroy_kset(phba->boot_kset);
 +	iscsi_host_remove(phba->shost);
 +	beiscsi_quiesce(phba, BEISCSI_CLEAN_UNLOAD);
 +	pci_dev_put(phba->pcidev);
 +	iscsi_host_free(phba->shost);
 +	pci_disable_pcie_error_reporting(pcidev);
 +	pci_set_drvdata(pcidev, NULL);
 +	pci_release_regions(pcidev);
 +	pci_disable_device(pcidev);
 +}
 +
 +static void beiscsi_msix_enable(struct beiscsi_hba *phba)
 +{
 +	int i, status;
 +
 +	for (i = 0; i <= phba->num_cpus; i++)
 +		phba->msix_entries[i].entry = i;
 +
 +	status = pci_enable_msix(phba->pcidev, phba->msix_entries,
 +				 (phba->num_cpus + 1));
 +	if (!status)
 +		phba->msix_enabled = true;
 +
 +	return;
 +}
 +
 +static void be_eqd_update(struct beiscsi_hba *phba)
 +{
- 	struct be_set_eqd set_eqd[MAX_CPUS];
- 	struct be_aic_obj *aic;
- 	struct be_eq_obj *pbe_eq;
- 	struct hwi_controller *phwi_ctrlr;
- 	struct hwi_context_memory *phwi_context;
- 	int eqd, i, num = 0;
- 	ulong now;
- 	u32 pps, delta;
- 	unsigned int tag;
++=======
+ void beiscsi_start_boot_work(struct beiscsi_hba *phba, unsigned int s_handle)
+ {
+ 	if (phba->boot_struct.boot_kset)
+ 		return;
  
- 	phwi_ctrlr = phba->phwi_ctrlr;
- 	phwi_context = phwi_ctrlr->phwi_ctxt;
+ 	/* skip if boot work is already in progress */
+ 	if (test_and_set_bit(BEISCSI_HBA_BOOT_WORK, &phba->state))
+ 		return;
  
- 	for (i = 0; i <= phba->num_cpus; i++) {
- 		aic = &phba->aic_obj[i];
- 		pbe_eq = &phwi_context->be_eq[i];
- 		now = jiffies;
- 		if (!aic->jiffies || time_before(now, aic->jiffies) ||
- 		    pbe_eq->cq_count < aic->eq_prev) {
- 			aic->jiffies = now;
- 			aic->eq_prev = pbe_eq->cq_count;
- 			continue;
- 		}
- 		delta = jiffies_to_msecs(now - aic->jiffies);
- 		pps = (((u32)(pbe_eq->cq_count - aic->eq_prev) * 1000) / delta);
- 		eqd = (pps / 1500) << 2;
+ 	phba->boot_struct.retry = 3;
+ 	phba->boot_struct.tag = 0;
+ 	phba->boot_struct.s_handle = s_handle;
+ 	phba->boot_struct.action = BEISCSI_BOOT_GET_SHANDLE;
+ 	schedule_work(&phba->boot_work);
+ }
  
- 		if (eqd < 8)
- 			eqd = 0;
- 		eqd = min_t(u32, eqd, phwi_context->max_eqd);
- 		eqd = max_t(u32, eqd, phwi_context->min_eqd);
+ static ssize_t beiscsi_show_boot_tgt_info(void *data, int type, char *buf)
+ {
+ 	struct beiscsi_hba *phba = data;
+ 	struct mgmt_session_info *boot_sess = &phba->boot_struct.boot_sess;
+ 	struct mgmt_conn_info *boot_conn = &boot_sess->conn_list[0];
+ 	char *str = buf;
+ 	int rc = -EPERM;
  
- 		aic->jiffies = now;
- 		aic->eq_prev = pbe_eq->cq_count;
+ 	switch (type) {
+ 	case ISCSI_BOOT_TGT_NAME:
+ 		rc = sprintf(buf, "%.*s\n",
+ 			    (int)strlen(boot_sess->target_name),
+ 			    (char *)&boot_sess->target_name);
+ 		break;
+ 	case ISCSI_BOOT_TGT_IP_ADDR:
+ 		if (boot_conn->dest_ipaddr.ip_type == BEISCSI_IP_TYPE_V4)
+ 			rc = sprintf(buf, "%pI4\n",
+ 				(char *)&boot_conn->dest_ipaddr.addr);
+ 		else
+ 			rc = sprintf(str, "%pI6\n",
+ 				(char *)&boot_conn->dest_ipaddr.addr);
+ 		break;
+ 	case ISCSI_BOOT_TGT_PORT:
+ 		rc = sprintf(str, "%d\n", boot_conn->dest_port);
+ 		break;
  
- 		if (eqd != aic->prev_eqd) {
- 			set_eqd[num].delay_multiplier = (eqd * 65)/100;
- 			set_eqd[num].eq_id = pbe_eq->q.id;
- 			aic->prev_eqd = eqd;
- 			num++;
- 		}
- 	}
- 	if (num) {
- 		tag = be_cmd_modify_eq_delay(phba, set_eqd, num);
- 		if (tag)
- 			beiscsi_mccq_compl_wait(phba, tag, NULL, NULL);
+ 	case ISCSI_BOOT_TGT_CHAP_NAME:
+ 		rc = sprintf(str,  "%.*s\n",
+ 			     boot_conn->negotiated_login_options.auth_data.chap.
+ 			     target_chap_name_length,
+ 			     (char *)&boot_conn->negotiated_login_options.
+ 			     auth_data.chap.target_chap_name);
+ 		break;
+ 	case ISCSI_BOOT_TGT_CHAP_SECRET:
+ 		rc = sprintf(str,  "%.*s\n",
+ 			     boot_conn->negotiated_login_options.auth_data.chap.
+ 			     target_secret_length,
+ 			     (char *)&boot_conn->negotiated_login_options.
+ 			     auth_data.chap.target_secret);
+ 		break;
+ 	case ISCSI_BOOT_TGT_REV_CHAP_NAME:
+ 		rc = sprintf(str,  "%.*s\n",
+ 			     boot_conn->negotiated_login_options.auth_data.chap.
+ 			     intr_chap_name_length,
+ 			     (char *)&boot_conn->negotiated_login_options.
+ 			     auth_data.chap.intr_chap_name);
+ 		break;
+ 	case ISCSI_BOOT_TGT_REV_CHAP_SECRET:
+ 		rc = sprintf(str,  "%.*s\n",
+ 			     boot_conn->negotiated_login_options.auth_data.chap.
+ 			     intr_secret_length,
+ 			     (char *)&boot_conn->negotiated_login_options.
+ 			     auth_data.chap.intr_secret);
+ 		break;
+ 	case ISCSI_BOOT_TGT_FLAGS:
+ 		rc = sprintf(str, "2\n");
+ 		break;
+ 	case ISCSI_BOOT_TGT_NIC_ASSOC:
+ 		rc = sprintf(str, "0\n");
+ 		break;
  	}
+ 	return rc;
  }
  
- static void be_check_boot_session(struct beiscsi_hba *phba)
+ static ssize_t beiscsi_show_boot_ini_info(void *data, int type, char *buf)
  {
- 	if (beiscsi_setup_boot_info(phba))
- 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
- 			    "BM_%d : Could not set up "
- 			    "iSCSI boot info on async event.\n");
+ 	struct beiscsi_hba *phba = data;
+ 	char *str = buf;
+ 	int rc = -EPERM;
+ 
+ 	switch (type) {
+ 	case ISCSI_BOOT_INI_INITIATOR_NAME:
+ 		rc = sprintf(str, "%s\n",
+ 			     phba->boot_struct.boot_sess.initiator_iscsiname);
+ 		break;
+ 	}
+ 	return rc;
  }
  
- /*
-  * beiscsi_hw_health_check()- Check adapter health
-  * @work: work item to check HW health
-  *
-  * Check if adapter in an unrecoverable state or not.
-  **/
- static void
- beiscsi_hw_health_check(struct work_struct *work)
+ static ssize_t beiscsi_show_boot_eth_info(void *data, int type, char *buf)
  {
- 	struct beiscsi_hba *phba =
- 		container_of(work, struct beiscsi_hba,
- 			     beiscsi_hw_check_task.work);
- 
+ 	struct beiscsi_hba *phba = data;
+ 	char *str = buf;
+ 	int rc = -EPERM;
+ 
+ 	switch (type) {
+ 	case ISCSI_BOOT_ETH_FLAGS:
+ 		rc = sprintf(str, "2\n");
+ 		break;
+ 	case ISCSI_BOOT_ETH_INDEX:
+ 		rc = sprintf(str, "0\n");
+ 		break;
+ 	case ISCSI_BOOT_ETH_MAC:
+ 		rc  = beiscsi_get_macaddr(str, phba);
+ 		break;
+ 	}
+ 	return rc;
+ }
+ 
+ static umode_t beiscsi_tgt_get_attr_visibility(void *data, int type)
+ {
+ 	umode_t rc = 0;
+ 
+ 	switch (type) {
+ 	case ISCSI_BOOT_TGT_NAME:
+ 	case ISCSI_BOOT_TGT_IP_ADDR:
+ 	case ISCSI_BOOT_TGT_PORT:
+ 	case ISCSI_BOOT_TGT_CHAP_NAME:
+ 	case ISCSI_BOOT_TGT_CHAP_SECRET:
+ 	case ISCSI_BOOT_TGT_REV_CHAP_NAME:
+ 	case ISCSI_BOOT_TGT_REV_CHAP_SECRET:
+ 	case ISCSI_BOOT_TGT_NIC_ASSOC:
+ 	case ISCSI_BOOT_TGT_FLAGS:
+ 		rc = S_IRUGO;
+ 		break;
+ 	}
+ 	return rc;
+ }
+ 
+ static umode_t beiscsi_ini_get_attr_visibility(void *data, int type)
+ {
+ 	umode_t rc = 0;
+ 
+ 	switch (type) {
+ 	case ISCSI_BOOT_INI_INITIATOR_NAME:
+ 		rc = S_IRUGO;
+ 		break;
+ 	}
+ 	return rc;
+ }
+ 
+ static umode_t beiscsi_eth_get_attr_visibility(void *data, int type)
+ {
+ 	umode_t rc = 0;
+ 
+ 	switch (type) {
+ 	case ISCSI_BOOT_ETH_FLAGS:
+ 	case ISCSI_BOOT_ETH_MAC:
+ 	case ISCSI_BOOT_ETH_INDEX:
+ 		rc = S_IRUGO;
+ 		break;
+ 	}
+ 	return rc;
+ }
+ 
+ static void beiscsi_boot_kobj_release(void *data)
+ {
+ 	struct beiscsi_hba *phba = data;
+ 
+ 	scsi_host_put(phba->shost);
+ }
+ 
+ static int beiscsi_boot_create_kset(struct beiscsi_hba *phba)
+ {
+ 	struct boot_struct *bs = &phba->boot_struct;
+ 	struct iscsi_boot_kobj *boot_kobj;
+ 
+ 	if (bs->boot_kset) {
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BM_%d: boot_kset already created\n");
+ 		return 0;
+ 	}
+ 
+ 	bs->boot_kset = iscsi_boot_create_host_kset(phba->shost->host_no);
+ 	if (!bs->boot_kset) {
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BM_%d: boot_kset alloc failed\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	/* get shost ref because the show function will refer phba */
+ 	if (!scsi_host_get(phba->shost))
+ 		goto free_kset;
+ 
+ 	boot_kobj = iscsi_boot_create_target(bs->boot_kset, 0, phba,
+ 					     beiscsi_show_boot_tgt_info,
+ 					     beiscsi_tgt_get_attr_visibility,
+ 					     beiscsi_boot_kobj_release);
+ 	if (!boot_kobj)
+ 		goto put_shost;
+ 
+ 	if (!scsi_host_get(phba->shost))
+ 		goto free_kset;
+ 
+ 	boot_kobj = iscsi_boot_create_initiator(bs->boot_kset, 0, phba,
+ 						beiscsi_show_boot_ini_info,
+ 						beiscsi_ini_get_attr_visibility,
+ 						beiscsi_boot_kobj_release);
+ 	if (!boot_kobj)
+ 		goto put_shost;
+ 
+ 	if (!scsi_host_get(phba->shost))
+ 		goto free_kset;
+ 
+ 	boot_kobj = iscsi_boot_create_ethernet(bs->boot_kset, 0, phba,
+ 					       beiscsi_show_boot_eth_info,
+ 					       beiscsi_eth_get_attr_visibility,
+ 					       beiscsi_boot_kobj_release);
+ 	if (!boot_kobj)
+ 		goto put_shost;
+ 
+ 	return 0;
+ 
+ put_shost:
+ 	scsi_host_put(phba->shost);
+ free_kset:
+ 	iscsi_boot_destroy_kset(bs->boot_kset);
+ 	bs->boot_kset = NULL;
+ 	return -ENOMEM;
+ }
+ 
+ static void beiscsi_boot_work(struct work_struct *work)
+ {
+ 	struct beiscsi_hba *phba =
+ 		container_of(work, struct beiscsi_hba, boot_work);
+ 	struct boot_struct *bs = &phba->boot_struct;
+ 	unsigned int tag = 0;
+ 
+ 	if (!beiscsi_hba_is_online(phba))
+ 		return;
+ 
+ 	beiscsi_log(phba, KERN_INFO,
+ 		    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
+ 		    "BM_%d : %s action %d\n",
+ 		    __func__, phba->boot_struct.action);
+ 
+ 	switch (phba->boot_struct.action) {
+ 	case BEISCSI_BOOT_REOPEN_SESS:
+ 		tag = beiscsi_boot_reopen_sess(phba);
+ 		break;
+ 	case BEISCSI_BOOT_GET_SHANDLE:
+ 		tag = __beiscsi_boot_get_shandle(phba, 1);
+ 		break;
+ 	case BEISCSI_BOOT_GET_SINFO:
+ 		tag = beiscsi_boot_get_sinfo(phba);
+ 		break;
+ 	case BEISCSI_BOOT_LOGOUT_SESS:
+ 		tag = beiscsi_boot_logout_sess(phba);
+ 		break;
+ 	case BEISCSI_BOOT_CREATE_KSET:
+ 		beiscsi_boot_create_kset(phba);
+ 		/**
+ 		 * updated boot_kset is made visible to all before
+ 		 * ending the boot work.
+ 		 */
+ 		mb();
+ 		clear_bit(BEISCSI_HBA_BOOT_WORK, &phba->state);
+ 		return;
+ 	}
+ 	if (!tag) {
+ 		if (bs->retry--)
+ 			schedule_work(&phba->boot_work);
+ 		else
+ 			clear_bit(BEISCSI_HBA_BOOT_WORK, &phba->state);
+ 	}
+ }
+ 
+ static void beiscsi_eqd_update_work(struct work_struct *work)
+ {
+ 	struct hwi_context_memory *phwi_context;
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
+ 	struct be_set_eqd set_eqd[MAX_CPUS];
 -	struct hwi_controller *phwi_ctrlr;
 -	struct be_eq_obj *pbe_eq;
 -	struct beiscsi_hba *phba;
 -	unsigned int pps, delta;
+ 	struct be_aic_obj *aic;
++	struct be_eq_obj *pbe_eq;
++	struct hwi_controller *phwi_ctrlr;
++	struct hwi_context_memory *phwi_context;
+ 	int eqd, i, num = 0;
++<<<<<<< HEAD
++	ulong now;
++	u32 pps, delta;
++	unsigned int tag;
++=======
+ 	unsigned long now;
+ 
+ 	phba = container_of(work, struct beiscsi_hba, eqd_update.work);
+ 	if (!beiscsi_hba_is_online(phba))
+ 		return;
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
+ 
+ 	phwi_ctrlr = phba->phwi_ctrlr;
+ 	phwi_context = phwi_ctrlr->phwi_ctxt;
+ 
+ 	for (i = 0; i <= phba->num_cpus; i++) {
+ 		aic = &phba->aic_obj[i];
+ 		pbe_eq = &phwi_context->be_eq[i];
+ 		now = jiffies;
+ 		if (!aic->jiffies || time_before(now, aic->jiffies) ||
+ 		    pbe_eq->cq_count < aic->eq_prev) {
+ 			aic->jiffies = now;
+ 			aic->eq_prev = pbe_eq->cq_count;
+ 			continue;
+ 		}
+ 		delta = jiffies_to_msecs(now - aic->jiffies);
+ 		pps = (((u32)(pbe_eq->cq_count - aic->eq_prev) * 1000) / delta);
+ 		eqd = (pps / 1500) << 2;
+ 
+ 		if (eqd < 8)
+ 			eqd = 0;
+ 		eqd = min_t(u32, eqd, phwi_context->max_eqd);
+ 		eqd = max_t(u32, eqd, phwi_context->min_eqd);
+ 
+ 		aic->jiffies = now;
+ 		aic->eq_prev = pbe_eq->cq_count;
+ 
+ 		if (eqd != aic->prev_eqd) {
+ 			set_eqd[num].delay_multiplier = (eqd * 65)/100;
+ 			set_eqd[num].eq_id = pbe_eq->q.id;
+ 			aic->prev_eqd = eqd;
+ 			num++;
+ 		}
+ 	}
 -	if (num)
 -		/* completion of this is ignored */
 -		beiscsi_modify_eq_delay(phba, set_eqd, num);
++	if (num) {
++		tag = be_cmd_modify_eq_delay(phba, set_eqd, num);
++		if (tag)
++			beiscsi_mccq_compl_wait(phba, tag, NULL, NULL);
++	}
++}
+ 
 -	schedule_delayed_work(&phba->eqd_update,
 -			      msecs_to_jiffies(BEISCSI_EQD_UPDATE_INTERVAL));
++static void be_check_boot_session(struct beiscsi_hba *phba)
++{
++	if (beiscsi_setup_boot_info(phba))
++		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
++			    "BM_%d : Could not set up "
++			    "iSCSI boot info on async event.\n");
++}
++
++/*
++ * beiscsi_hw_health_check()- Check adapter health
++ * @work: work item to check HW health
++ *
++ * Check if adapter in an unrecoverable state or not.
++ **/
++static void
++beiscsi_hw_health_check(struct work_struct *work)
++{
++	struct beiscsi_hba *phba =
++		container_of(work, struct beiscsi_hba,
++			     beiscsi_hw_check_task.work);
++
 +	be_eqd_update(phba);
 +
 +	if (phba->state & BE_ADAPTER_CHECK_BOOT) {
 +		if ((phba->get_boot > 0) && (!phba->boot_kset)) {
 +			phba->get_boot--;
 +			if (!(phba->get_boot % BE_GET_BOOT_TO))
 +				be_check_boot_session(phba);
 +		} else {
 +			phba->state &= ~BE_ADAPTER_CHECK_BOOT;
 +			phba->get_boot = 0;
 +		}
 +	}
 +
 +	beiscsi_ue_detect(phba);
 +
 +	schedule_delayed_work(&phba->beiscsi_hw_check_task,
 +			      msecs_to_jiffies(1000));
  }
  
+ static void beiscsi_msix_enable(struct beiscsi_hba *phba)
+ {
+ 	int i, status;
+ 
+ 	for (i = 0; i <= phba->num_cpus; i++)
+ 		phba->msix_entries[i].entry = i;
+ 
+ 	status = pci_enable_msix_range(phba->pcidev, phba->msix_entries,
+ 				       phba->num_cpus + 1, phba->num_cpus + 1);
+ 	if (status > 0)
+ 		phba->msix_enabled = true;
+ }
+ 
+ static void beiscsi_hw_tpe_check(unsigned long ptr)
+ {
+ 	struct beiscsi_hba *phba;
+ 	u32 wait;
+ 
+ 	phba = (struct beiscsi_hba *)ptr;
+ 	/* if not TPE, do nothing */
+ 	if (!beiscsi_detect_tpe(phba))
+ 		return;
+ 
+ 	/* wait default 4000ms before recovering */
+ 	wait = 4000;
+ 	if (phba->ue2rp > BEISCSI_UE_DETECT_INTERVAL)
+ 		wait = phba->ue2rp - BEISCSI_UE_DETECT_INTERVAL;
+ 	queue_delayed_work(phba->wq, &phba->recover_port,
+ 			   msecs_to_jiffies(wait));
+ }
+ 
+ static void beiscsi_hw_health_check(unsigned long ptr)
+ {
+ 	struct beiscsi_hba *phba;
+ 
+ 	phba = (struct beiscsi_hba *)ptr;
+ 	beiscsi_detect_ue(phba);
+ 	if (beiscsi_detect_ue(phba)) {
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BM_%d : port in error: %lx\n", phba->state);
+ 		/* detect TPE if UER supported */
+ 		if (!test_bit(BEISCSI_HBA_UER_SUPP, &phba->state))
+ 			return;
+ 		/* modify this timer to check TPE */
+ 		phba->hw_check.function = beiscsi_hw_tpe_check;
+ 	}
+ 
+ 	mod_timer(&phba->hw_check,
+ 		  jiffies + msecs_to_jiffies(BEISCSI_UE_DETECT_INTERVAL));
+ }
+ 
+ /*
+  * beiscsi_enable_port()- Enables the disabled port.
+  * Only port resources freed in disable function are reallocated.
+  * This is called in HBA error handling path.
+  *
+  * @phba: Instance of driver private structure
+  *
+  **/
+ static int beiscsi_enable_port(struct beiscsi_hba *phba)
+ {
+ 	struct hwi_context_memory *phwi_context;
+ 	struct hwi_controller *phwi_ctrlr;
+ 	struct be_eq_obj *pbe_eq;
+ 	int ret, i;
+ 
+ 	if (test_bit(BEISCSI_HBA_ONLINE, &phba->state)) {
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BM_%d : %s : port is online %lx\n",
+ 			      __func__, phba->state);
+ 		return 0;
+ 	}
+ 
+ 	ret = beiscsi_init_sliport(phba);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (enable_msix)
+ 		find_num_cpus(phba);
+ 	else
+ 		phba->num_cpus = 1;
+ 	if (enable_msix) {
+ 		beiscsi_msix_enable(phba);
+ 		if (!phba->msix_enabled)
+ 			phba->num_cpus = 1;
+ 	}
+ 
+ 	beiscsi_get_params(phba);
+ 	/* Re-enable UER. If different TPE occurs then it is recoverable. */
+ 	beiscsi_set_uer_feature(phba);
+ 
+ 	phba->shost->max_id = phba->params.cxns_per_ctrl;
+ 	phba->shost->can_queue = phba->params.ios_per_ctrl;
+ 	ret = hwi_init_controller(phba);
+ 	if (ret) {
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BM_%d : init controller failed %d\n", ret);
+ 		goto disable_msix;
+ 	}
+ 
+ 	for (i = 0; i < MAX_MCC_CMD; i++) {
+ 		init_waitqueue_head(&phba->ctrl.mcc_wait[i + 1]);
+ 		phba->ctrl.mcc_tag[i] = i + 1;
+ 		phba->ctrl.mcc_tag_status[i + 1] = 0;
+ 		phba->ctrl.mcc_tag_available++;
+ 	}
+ 
+ 	phwi_ctrlr = phba->phwi_ctrlr;
+ 	phwi_context = phwi_ctrlr->phwi_ctxt;
+ 	for (i = 0; i < phba->num_cpus; i++) {
+ 		pbe_eq = &phwi_context->be_eq[i];
+ 		irq_poll_init(&pbe_eq->iopoll, be_iopoll_budget, be_iopoll);
+ 	}
+ 
+ 	i = (phba->msix_enabled) ? i : 0;
+ 	/* Work item for MCC handling */
+ 	pbe_eq = &phwi_context->be_eq[i];
+ 	INIT_WORK(&pbe_eq->mcc_work, beiscsi_mcc_work);
+ 
+ 	ret = beiscsi_init_irqs(phba);
+ 	if (ret < 0) {
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BM_%d : setup IRQs failed %d\n", ret);
+ 		goto cleanup_port;
+ 	}
+ 	hwi_enable_intr(phba);
+ 	/* port operational: clear all error bits */
+ 	set_bit(BEISCSI_HBA_ONLINE, &phba->state);
+ 	__beiscsi_log(phba, KERN_INFO,
+ 		      "BM_%d : port online: 0x%lx\n", phba->state);
+ 
+ 	/* start hw_check timer and eqd_update work */
+ 	schedule_delayed_work(&phba->eqd_update,
+ 			      msecs_to_jiffies(BEISCSI_EQD_UPDATE_INTERVAL));
+ 
+ 	/**
+ 	 * Timer function gets modified for TPE detection.
+ 	 * Always reinit to do health check first.
+ 	 */
+ 	phba->hw_check.function = beiscsi_hw_health_check;
+ 	mod_timer(&phba->hw_check,
+ 		  jiffies + msecs_to_jiffies(BEISCSI_UE_DETECT_INTERVAL));
+ 	return 0;
+ 
+ cleanup_port:
+ 	for (i = 0; i < phba->num_cpus; i++) {
+ 		pbe_eq = &phwi_context->be_eq[i];
+ 		irq_poll_disable(&pbe_eq->iopoll);
+ 	}
+ 	hwi_cleanup_port(phba);
+ 
+ disable_msix:
+ 	if (phba->msix_enabled)
+ 		pci_disable_msix(phba->pcidev);
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * beiscsi_disable_port()- Disable port and cleanup driver resources.
+  * This is called in HBA error handling and driver removal.
+  * @phba: Instance Priv structure
+  * @unload: indicate driver is unloading
+  *
+  * Free the OS and HW resources held by the driver
+  **/
+ static void beiscsi_disable_port(struct beiscsi_hba *phba, int unload)
+ {
+ 	struct hwi_context_memory *phwi_context;
+ 	struct hwi_controller *phwi_ctrlr;
+ 	struct be_eq_obj *pbe_eq;
+ 	unsigned int i, msix_vec;
+ 
+ 	if (!test_and_clear_bit(BEISCSI_HBA_ONLINE, &phba->state))
+ 		return;
+ 
+ 	phwi_ctrlr = phba->phwi_ctrlr;
+ 	phwi_context = phwi_ctrlr->phwi_ctxt;
+ 	hwi_disable_intr(phba);
+ 	if (phba->msix_enabled) {
+ 		for (i = 0; i <= phba->num_cpus; i++) {
+ 			msix_vec = phba->msix_entries[i].vector;
+ 			free_irq(msix_vec, &phwi_context->be_eq[i]);
+ 			kfree(phba->msi_name[i]);
+ 		}
+ 	} else
+ 		if (phba->pcidev->irq)
+ 			free_irq(phba->pcidev->irq, phba);
+ 	pci_disable_msix(phba->pcidev);
+ 
+ 	for (i = 0; i < phba->num_cpus; i++) {
+ 		pbe_eq = &phwi_context->be_eq[i];
+ 		irq_poll_disable(&pbe_eq->iopoll);
+ 	}
+ 	cancel_delayed_work_sync(&phba->eqd_update);
+ 	cancel_work_sync(&phba->boot_work);
+ 	/* WQ might be running cancel queued mcc_work if we are not exiting */
+ 	if (!unload && beiscsi_hba_in_error(phba)) {
+ 		pbe_eq = &phwi_context->be_eq[i];
+ 		cancel_work_sync(&pbe_eq->mcc_work);
+ 	}
+ 	hwi_cleanup_port(phba);
+ }
+ 
+ static void beiscsi_recover_port(struct work_struct *work)
+ {
+ 	struct beiscsi_hba *phba;
+ 
+ 	phba = container_of(work, struct beiscsi_hba, recover_port.work);
+ 	iscsi_host_for_each_session(phba->shost, beiscsi_session_fail);
+ 	beiscsi_disable_port(phba, 0);
+ 	beiscsi_enable_port(phba);
+ }
  
  static pci_ers_result_t beiscsi_eeh_err_detected(struct pci_dev *pdev,
  		pci_channel_state_t state)
@@@ -5437,7 -5583,11 +6127,15 @@@
  	beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
  		    "BM_%d : EEH error detected\n");
  
++<<<<<<< HEAD
 +	beiscsi_quiesce(phba, BEISCSI_EEH_UNLOAD);
++=======
+ 	/* first stop UE detection when PCI error detected */
+ 	del_timer_sync(&phba->hw_check);
+ 	cancel_delayed_work_sync(&phba->recover_port);
+ 
+ 	beiscsi_disable_port(phba, 0);
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  
  	if (state == pci_channel_io_perm_failure) {
  		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
@@@ -5494,87 -5643,16 +6192,99 @@@ static pci_ers_result_t beiscsi_eeh_res
  
  static void beiscsi_eeh_resume(struct pci_dev *pdev)
  {
++<<<<<<< HEAD
 +	int ret = 0, i;
 +	struct be_eq_obj *pbe_eq;
 +	struct beiscsi_hba *phba = NULL;
 +	struct hwi_controller *phwi_ctrlr;
 +	struct hwi_context_memory *phwi_context;
++=======
+ 	struct beiscsi_hba *phba;
+ 	int ret;
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  
  	phba = (struct beiscsi_hba *)pci_get_drvdata(pdev);
  	pci_save_state(pdev);
  
++<<<<<<< HEAD
 +	if (enable_msix)
 +		find_num_cpus(phba);
 +	else
 +		phba->num_cpus = 1;
 +
 +	if (enable_msix) {
 +		beiscsi_msix_enable(phba);
 +		if (!phba->msix_enabled)
 +			phba->num_cpus = 1;
 +	}
 +
 +	ret = beiscsi_cmd_reset_function(phba);
 +	if (ret) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 +			    "BM_%d : Reset Failed\n");
 +		goto ret_err;
 +	}
 +
 +	ret = be_chk_reset_complete(phba);
 +	if (ret) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 +			    "BM_%d : Failed to get out of reset.\n");
 +		goto ret_err;
 +	}
 +
 +	beiscsi_get_params(phba);
 +	phba->shost->max_id = phba->params.cxns_per_ctrl;
 +	phba->shost->can_queue = phba->params.ios_per_ctrl;
 +	ret = hwi_init_controller(phba);
 +	if (ret) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 +			    "BM_%d : beiscsi_eeh_resume -"
 +			     "Failed to initialize beiscsi_hba.\n");
 +		goto ret_err;
 +	}
 +
 +	for (i = 0; i < MAX_MCC_CMD; i++) {
 +		init_waitqueue_head(&phba->ctrl.mcc_wait[i + 1]);
 +		phba->ctrl.mcc_tag[i] = i + 1;
 +		phba->ctrl.mcc_tag_status[i + 1] = 0;
 +		phba->ctrl.mcc_tag_available++;
 +	}
 +
 +	phwi_ctrlr = phba->phwi_ctrlr;
 +	phwi_context = phwi_ctrlr->phwi_ctxt;
 +
 +	for (i = 0; i < phba->num_cpus; i++) {
 +		pbe_eq = &phwi_context->be_eq[i];
 +		irq_poll_init(&pbe_eq->iopoll, be_iopoll_budget,
 +				be_iopoll);
 +	}
 +
 +	i = (phba->msix_enabled) ? i : 0;
 +	/* Work item for MCC handling */
 +	pbe_eq = &phwi_context->be_eq[i];
 +	INIT_WORK(&pbe_eq->mcc_work, beiscsi_mcc_work);
 +
 +	ret = beiscsi_init_irqs(phba);
 +	if (ret < 0) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 +			    "BM_%d : beiscsi_eeh_resume - "
 +			    "Failed to beiscsi_init_irqs\n");
 +		goto ret_err;
 +	}
 +
 +	hwi_enable_intr(phba);
 +	phba->state &= ~BE_ADAPTER_PCI_ERR;
 +
 +	return;
 +ret_err:
 +	beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 +		    "BM_%d : AER EEH Resume Failed\n");
++=======
+ 	ret = beiscsi_enable_port(phba);
+ 	if (ret)
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BM_%d : AER EEH resume failed\n");
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  }
  
  static int beiscsi_dev_probe(struct pci_dev *pcidev,
@@@ -5745,21 -5807,41 +6454,54 @@@
  	}
  	hwi_enable_intr(phba);
  
- 	if (iscsi_host_add(phba->shost, &phba->pcidev->dev))
+ 	ret = iscsi_host_add(phba->shost, &phba->pcidev->dev);
+ 	if (ret)
  		goto free_blkenbld;
  
++<<<<<<< HEAD
 +	if (beiscsi_setup_boot_info(phba))
 +		/*
 +		 * log error but continue, because we may not be using
 +		 * iscsi boot.
++=======
+ 	/* set online bit after port is operational */
+ 	set_bit(BEISCSI_HBA_ONLINE, &phba->state);
+ 	__beiscsi_log(phba, KERN_INFO,
+ 		      "BM_%d : port online: 0x%lx\n", phba->state);
+ 
+ 	INIT_WORK(&phba->boot_work, beiscsi_boot_work);
+ 	ret = beiscsi_boot_get_shandle(phba, &s_handle);
+ 	if (ret > 0) {
+ 		beiscsi_start_boot_work(phba, s_handle);
+ 		/**
+ 		 * Set this bit after starting the work to let
+ 		 * probe handle it first.
+ 		 * ASYNC event can too schedule this work.
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  		 */
 -		set_bit(BEISCSI_HBA_BOOT_FOUND, &phba->state);
 -	}
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 +			    "BM_%d : Could not set up "
 +			    "iSCSI boot info.\n");
  
  	beiscsi_iface_create_default(phba);
++<<<<<<< HEAD
 +	schedule_delayed_work(&phba->beiscsi_hw_check_task,
 +			      msecs_to_jiffies(1000));
++=======
+ 	schedule_delayed_work(&phba->eqd_update,
+ 			      msecs_to_jiffies(BEISCSI_EQD_UPDATE_INTERVAL));
+ 
+ 	INIT_DELAYED_WORK(&phba->recover_port, beiscsi_recover_port);
+ 	/**
+ 	 * Start UE detection here. UE before this will cause stall in probe
+ 	 * and eventually fail the probe.
+ 	 */
+ 	init_timer(&phba->hw_check);
+ 	phba->hw_check.function = beiscsi_hw_health_check;
+ 	phba->hw_check.data = (unsigned long)phba;
+ 	mod_timer(&phba->hw_check,
+ 		  jiffies + msecs_to_jiffies(BEISCSI_UE_DETECT_INTERVAL));
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  
  	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
  		    "\n\n\n BM_%d : SUCCESS - DRIVER LOADED\n\n\n");
@@@ -5772,7 -5854,8 +6514,12 @@@ free_blkenbld
  		irq_poll_disable(&pbe_eq->iopoll);
  	}
  free_twq:
++<<<<<<< HEAD
 +	beiscsi_clean_port(phba);
++=======
+ 	hwi_cleanup_port(phba);
+ 	beiscsi_cleanup_port(phba);
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  	beiscsi_free_mem(phba);
  free_port:
  	pci_free_consistent(phba->pcidev,
diff --cc drivers/scsi/be2iscsi/be_main.h
index 90cdc10c01fb,1fd6c1868366..000000000000
--- a/drivers/scsi/be2iscsi/be_main.h
+++ b/drivers/scsi/be2iscsi/be_main.h
@@@ -417,12 -392,32 +417,41 @@@ struct beiscsi_hba 
  		unsigned long ulp_supported;
  	} fw_config;
  
++<<<<<<< HEAD
 +	unsigned int state;
 +	u8 optic_state;
 +	int get_boot;
 +	bool fw_timeout;
 +	bool ue_detected;
 +	struct delayed_work beiscsi_hw_check_task;
++=======
+ 	unsigned long state;
+ #define BEISCSI_HBA_ONLINE	0
+ #define BEISCSI_HBA_LINK_UP	1
+ #define BEISCSI_HBA_BOOT_FOUND	2
+ #define BEISCSI_HBA_BOOT_WORK	3
+ #define BEISCSI_HBA_UER_SUPP	4
+ #define BEISCSI_HBA_PCI_ERR	5
+ #define BEISCSI_HBA_FW_TIMEOUT	6
+ #define BEISCSI_HBA_IN_UE	7
+ #define BEISCSI_HBA_IN_TPE	8
+ 
+ /* error bits */
+ #define BEISCSI_HBA_IN_ERR	((1 << BEISCSI_HBA_PCI_ERR) | \
+ 				 (1 << BEISCSI_HBA_FW_TIMEOUT) | \
+ 				 (1 << BEISCSI_HBA_IN_UE) | \
+ 				 (1 << BEISCSI_HBA_IN_TPE))
+ 
+ 	u8 optic_state;
+ 	struct delayed_work eqd_update;
+ 	/* update EQ delay timer every 1000ms */
+ #define BEISCSI_EQD_UPDATE_INTERVAL	1000
+ 	struct timer_list hw_check;
+ 	/* check for UE every 1000ms */
+ #define BEISCSI_UE_DETECT_INTERVAL	1000
+ 	u32 ue2rp;
+ 	struct delayed_work recover_port;
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  
  	bool mac_addr_set;
  	u8 mac_address[ETH_ALEN];
@@@ -443,8 -437,29 +472,16 @@@
  			struct scatterlist *sg,
  			uint32_t num_sg, uint32_t xferlen,
  			uint32_t writedir);
 -	struct boot_struct {
 -		int retry;
 -		unsigned int tag;
 -		unsigned int s_handle;
 -		struct be_dma_mem nonemb_cmd;
 -		enum {
 -			BEISCSI_BOOT_REOPEN_SESS = 1,
 -			BEISCSI_BOOT_GET_SHANDLE,
 -			BEISCSI_BOOT_GET_SINFO,
 -			BEISCSI_BOOT_LOGOUT_SESS,
 -			BEISCSI_BOOT_CREATE_KSET,
 -		} action;
 -		struct mgmt_session_info boot_sess;
 -		struct iscsi_boot_kset *boot_kset;
 -	} boot_struct;
 -	struct work_struct boot_work;
  };
  
++<<<<<<< HEAD
++=======
+ #define beiscsi_hba_in_error(phba) ((phba)->state & BEISCSI_HBA_IN_ERR)
+ #define beiscsi_hba_is_online(phba) \
+ 	(!beiscsi_hba_in_error((phba)) && \
+ 	 test_bit(BEISCSI_HBA_ONLINE, &phba->state))
+ 
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  struct beiscsi_session {
  	struct pci_pool *bhs_pool;
  };
diff --cc drivers/scsi/be2iscsi/be_mgmt.c
index fa17b8e5a47c,736eca38ea0b..000000000000
--- a/drivers/scsi/be2iscsi/be_mgmt.c
+++ b/drivers/scsi/be2iscsi/be_mgmt.c
@@@ -24,139 -24,9 +24,145 @@@
  #include "be_iscsi.h"
  #include "be_main.h"
  
++<<<<<<< HEAD
 +/* UE Status Low CSR */
 +static const char * const desc_ue_status_low[] = {
 +	"CEV",
 +	"CTX",
 +	"DBUF",
 +	"ERX",
 +	"Host",
 +	"MPU",
 +	"NDMA",
 +	"PTC ",
 +	"RDMA ",
 +	"RXF ",
 +	"RXIPS ",
 +	"RXULP0 ",
 +	"RXULP1 ",
 +	"RXULP2 ",
 +	"TIM ",
 +	"TPOST ",
 +	"TPRE ",
 +	"TXIPS ",
 +	"TXULP0 ",
 +	"TXULP1 ",
 +	"UC ",
 +	"WDMA ",
 +	"TXULP2 ",
 +	"HOST1 ",
 +	"P0_OB_LINK ",
 +	"P1_OB_LINK ",
 +	"HOST_GPIO ",
 +	"MBOX ",
 +	"AXGMAC0",
 +	"AXGMAC1",
 +	"JTAG",
 +	"MPU_INTPEND"
 +};
 +
 +/* UE Status High CSR */
 +static const char * const desc_ue_status_hi[] = {
 +	"LPCMEMHOST",
 +	"MGMT_MAC",
 +	"PCS0ONLINE",
 +	"MPU_IRAM",
 +	"PCS1ONLINE",
 +	"PCTL0",
 +	"PCTL1",
 +	"PMEM",
 +	"RR",
 +	"TXPB",
 +	"RXPP",
 +	"XAUI",
 +	"TXP",
 +	"ARM",
 +	"IPC",
 +	"HOST2",
 +	"HOST3",
 +	"HOST4",
 +	"HOST5",
 +	"HOST6",
 +	"HOST7",
 +	"HOST8",
 +	"HOST9",
 +	"NETC",
 +	"Unknown",
 +	"Unknown",
 +	"Unknown",
 +	"Unknown",
 +	"Unknown",
 +	"Unknown",
 +	"Unknown",
 +	"Unknown"
 +};
 +
 +/*
 + * beiscsi_ue_detec()- Detect Unrecoverable Error on adapter
 + * @phba: Driver priv structure
 + *
 + * Read registers linked to UE and check for the UE status
 + **/
 +void beiscsi_ue_detect(struct beiscsi_hba *phba)
 +{
 +	uint32_t ue_hi = 0, ue_lo = 0;
 +	uint32_t ue_mask_hi = 0, ue_mask_lo = 0;
 +	uint8_t i = 0;
 +
 +	if (phba->ue_detected)
 +		return;
 +
 +	pci_read_config_dword(phba->pcidev,
 +			      PCICFG_UE_STATUS_LOW, &ue_lo);
 +	pci_read_config_dword(phba->pcidev,
 +			      PCICFG_UE_STATUS_MASK_LOW,
 +			      &ue_mask_lo);
 +	pci_read_config_dword(phba->pcidev,
 +			      PCICFG_UE_STATUS_HIGH,
 +			      &ue_hi);
 +	pci_read_config_dword(phba->pcidev,
 +			      PCICFG_UE_STATUS_MASK_HI,
 +			      &ue_mask_hi);
 +
 +	ue_lo = (ue_lo & ~ue_mask_lo);
 +	ue_hi = (ue_hi & ~ue_mask_hi);
 +
 +
 +	if (ue_lo || ue_hi) {
 +		phba->ue_detected = true;
 +		beiscsi_log(phba, KERN_ERR,
 +			    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,
 +			    "BG_%d : Error detected on the adapter\n");
 +	}
 +
 +	if (ue_lo) {
 +		for (i = 0; ue_lo; ue_lo >>= 1, i++) {
 +			if (ue_lo & 1)
 +				beiscsi_log(phba, KERN_ERR,
 +					    BEISCSI_LOG_CONFIG,
 +					    "BG_%d : UE_LOW %s bit set\n",
 +					    desc_ue_status_low[i]);
 +		}
 +	}
 +
 +	if (ue_hi) {
 +		for (i = 0; ue_hi; ue_hi >>= 1, i++) {
 +			if (ue_hi & 1)
 +				beiscsi_log(phba, KERN_ERR,
 +					    BEISCSI_LOG_CONFIG,
 +					    "BG_%d : UE_HIGH %s bit set\n",
 +					    desc_ue_status_hi[i]);
 +		}
 +	}
 +}
 +
 +int be_cmd_modify_eq_delay(struct beiscsi_hba *phba,
 +		 struct be_set_eqd *set_eqd, int num)
++=======
+ int beiscsi_modify_eq_delay(struct beiscsi_hba *phba,
+ 			    struct be_set_eqd *set_eqd,
+ 			    int num)
++>>>>>>> d1d5ca887c0e (scsi: be2iscsi: Add TPE recovery feature)
  {
  	struct be_ctrl_info *ctrl = &phba->ctrl;
  	struct be_mcc_wrb *wrb;
* Unmerged path drivers/scsi/be2iscsi/be_cmds.c
* Unmerged path drivers/scsi/be2iscsi/be_cmds.h
* Unmerged path drivers/scsi/be2iscsi/be_iscsi.c
* Unmerged path drivers/scsi/be2iscsi/be_main.c
* Unmerged path drivers/scsi/be2iscsi/be_main.h
* Unmerged path drivers/scsi/be2iscsi/be_mgmt.c
diff --git a/drivers/scsi/be2iscsi/be_mgmt.h b/drivers/scsi/be2iscsi/be_mgmt.h
index 294b740805a6..50d935a3cfbc 100644
--- a/drivers/scsi/be2iscsi/be_mgmt.h
+++ b/drivers/scsi/be2iscsi/be_mgmt.h
@@ -338,7 +338,6 @@ void beiscsi_offload_cxn_v2(struct beiscsi_offload_params *params,
 			     struct wrb_handle *pwrb_handle,
 			     struct hwi_wrb_context *pwrb_context);
 
-void beiscsi_ue_detect(struct beiscsi_hba *phba);
 int be_cmd_modify_eq_delay(struct beiscsi_hba *phba,
 			 struct be_set_eqd *, int num);
 
