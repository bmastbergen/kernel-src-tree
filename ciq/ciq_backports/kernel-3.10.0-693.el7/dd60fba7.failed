perf tools: Add infrastructure for PMU specific configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mathieu Poirier <mathieu.poirier@linaro.org>
commit dd60fba7324572498d91163e96b1cfe5cd5f7f3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/dd60fba7.failed

This patch adds PMU driver specific configuration to the parser
infrastructure by preceding any term with the '@' letter.  As such doing
something like:

perf record -e some_event/@cfg1,@cfg2=config/ ...

will see 'cfg1' and 'cfg2=config' being added to the list of evsel
config terms.  Token 'cfg1' and 'cfg2=config' are not processed in user
space and are meant to be interpreted by the PMU driver.

First the lexer/parser are supplemented with the required definitions to
recognise the driver specific configuration.  From there they are simply
added to the list of event terms.  The bulk of the work is done in
function "parse_events_add_pmu()" where driver config event terms are
added to a new list of driver config terms, which in turn spliced with
the event's new driver configuration list.

	Signed-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1473179837-3293-4-git-send-email-mathieu.poirier@linaro.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit dd60fba7324572498d91163e96b1cfe5cd5f7f3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/evsel.h
#	tools/perf/util/parse-events.c
#	tools/perf/util/parse-events.h
#	tools/perf/util/parse-events.l
#	tools/perf/util/parse-events.y
diff --cc tools/perf/util/evsel.h
index b09da8272243,323806082c58..000000000000
--- a/tools/perf/util/evsel.h
+++ b/tools/perf/util/evsel.h
@@@ -44,6 -44,9 +44,12 @@@ enum 
  	PERF_EVSEL__CONFIG_TERM_CALLGRAPH,
  	PERF_EVSEL__CONFIG_TERM_STACK_USER,
  	PERF_EVSEL__CONFIG_TERM_INHERIT,
++<<<<<<< HEAD
++=======
+ 	PERF_EVSEL__CONFIG_TERM_MAX_STACK,
+ 	PERF_EVSEL__CONFIG_TERM_OVERWRITE,
+ 	PERF_EVSEL__CONFIG_TERM_DRV_CFG,
++>>>>>>> dd60fba73245 (perf tools: Add infrastructure for PMU specific configuration)
  	PERF_EVSEL__CONFIG_TERM_MAX,
  };
  
@@@ -55,8 -58,11 +61,9 @@@ struct perf_evsel_config_term 
  		u64	freq;
  		bool	time;
  		char	*callgraph;
+ 		char	*drv_cfg;
  		u64	stack_user;
 -		int	max_stack;
  		bool	inherit;
 -		bool	overwrite;
  	} val;
  };
  
diff --cc tools/perf/util/parse-events.c
index a5b0d8e6c607,2eb8b1ed4cc8..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -675,6 -901,10 +675,13 @@@ static const char *config_term_names[__
  	[PARSE_EVENTS__TERM_TYPE_STACKSIZE]		= "stack-size",
  	[PARSE_EVENTS__TERM_TYPE_NOINHERIT]		= "no-inherit",
  	[PARSE_EVENTS__TERM_TYPE_INHERIT]		= "inherit",
++<<<<<<< HEAD
++=======
+ 	[PARSE_EVENTS__TERM_TYPE_MAX_STACK]		= "max-stack",
+ 	[PARSE_EVENTS__TERM_TYPE_OVERWRITE]		= "overwrite",
+ 	[PARSE_EVENTS__TERM_TYPE_NOOVERWRITE]		= "no-overwrite",
+ 	[PARSE_EVENTS__TERM_TYPE_DRV_CFG]		= "driver-config",
++>>>>>>> dd60fba73245 (perf tools: Add infrastructure for PMU specific configuration)
  };
  
  static bool config_term_shrinked;
@@@ -884,6 -1127,18 +892,21 @@@ do {								
  		case PARSE_EVENTS__TERM_TYPE_NOINHERIT:
  			ADD_CONFIG_TERM(INHERIT, inherit, term->val.num ? 0 : 1);
  			break;
++<<<<<<< HEAD
++=======
+ 		case PARSE_EVENTS__TERM_TYPE_MAX_STACK:
+ 			ADD_CONFIG_TERM(MAX_STACK, max_stack, term->val.num);
+ 			break;
+ 		case PARSE_EVENTS__TERM_TYPE_OVERWRITE:
+ 			ADD_CONFIG_TERM(OVERWRITE, overwrite, term->val.num ? 1 : 0);
+ 			break;
+ 		case PARSE_EVENTS__TERM_TYPE_NOOVERWRITE:
+ 			ADD_CONFIG_TERM(OVERWRITE, overwrite, term->val.num ? 0 : 1);
+ 			break;
+ 		case PARSE_EVENTS__TERM_TYPE_DRV_CFG:
+ 			ADD_CONFIG_TERM(DRV_CFG, drv_cfg, term->val.str);
+ 			break;
++>>>>>>> dd60fba73245 (perf tools: Add infrastructure for PMU specific configuration)
  		default:
  			break;
  		}
diff --cc tools/perf/util/parse-events.h
index c93f61beef22,8d09a976fca8..000000000000
--- a/tools/perf/util/parse-events.h
+++ b/tools/perf/util/parse-events.h
@@@ -68,6 -68,10 +68,13 @@@ enum 
  	PARSE_EVENTS__TERM_TYPE_STACKSIZE,
  	PARSE_EVENTS__TERM_TYPE_NOINHERIT,
  	PARSE_EVENTS__TERM_TYPE_INHERIT,
++<<<<<<< HEAD
++=======
+ 	PARSE_EVENTS__TERM_TYPE_MAX_STACK,
+ 	PARSE_EVENTS__TERM_TYPE_NOOVERWRITE,
+ 	PARSE_EVENTS__TERM_TYPE_OVERWRITE,
+ 	PARSE_EVENTS__TERM_TYPE_DRV_CFG,
++>>>>>>> dd60fba73245 (perf tools: Add infrastructure for PMU specific configuration)
  	__PARSE_EVENTS__TERM_TYPE_NR,
  };
  
diff --cc tools/perf/util/parse-events.l
index 1d4e9d370449,9f43fda2570f..000000000000
--- a/tools/perf/util/parse-events.l
+++ b/tools/perf/util/parse-events.l
@@@ -120,7 -143,8 +140,12 @@@ num_dec		[0-9]
  num_hex		0x[a-fA-F0-9]+
  num_raw_hex	[a-fA-F0-9]+
  name		[a-zA-Z_*?][a-zA-Z0-9_*?.]*
++<<<<<<< HEAD
 +name_minus	[a-zA-Z_*?][a-zA-Z0-9\-_*?.]*
++=======
+ name_minus	[a-zA-Z_*?][a-zA-Z0-9\-_*?.:]*
+ drv_cfg_term	[a-zA-Z0-9_\.]+(=[a-zA-Z0-9_*?\.:]+)?
++>>>>>>> dd60fba73245 (perf tools: Add infrastructure for PMU specific configuration)
  /* If you add a modifier you need to update check_modifier() */
  modifier_event	[ukhpPGHSDI]+
  modifier_bp	[rwx]{1,3}
@@@ -191,6 -226,11 +216,12 @@@ no-inherit		{ return term(yyscanner, PA
  ,			{ return ','; }
  "/"			{ BEGIN(INITIAL); return '/'; }
  {name_minus}		{ return str(yyscanner, PE_NAME); }
++<<<<<<< HEAD
++=======
+ \[all\]			{ return PE_ARRAY_ALL; }
+ "["			{ BEGIN(array); return '['; }
+ @{drv_cfg_term}		{ return drv_str(yyscanner, PE_DRV_CFG_TERM); }
++>>>>>>> dd60fba73245 (perf tools: Add infrastructure for PMU specific configuration)
  }
  
  <mem>{
diff --cc tools/perf/util/parse-events.y
index abdb79cfc5ee,879115f93edc..000000000000
--- a/tools/perf/util/parse-events.y
+++ b/tools/perf/util/parse-events.y
@@@ -47,6 -48,8 +47,11 @@@ static void inc_group_count(struct list
  %token PE_PREFIX_MEM PE_PREFIX_RAW PE_PREFIX_GROUP
  %token PE_ERROR
  %token PE_PMU_EVENT_PRE PE_PMU_EVENT_SUF PE_KERNEL_PMU_EVENT
++<<<<<<< HEAD
++=======
+ %token PE_ARRAY_ALL PE_ARRAY_RANGE
+ %token PE_DRV_CFG_TERM
++>>>>>>> dd60fba73245 (perf tools: Add infrastructure for PMU specific configuration)
  %type <num> PE_VALUE
  %type <num> PE_VALUE_SYM_HW
  %type <num> PE_VALUE_SYM_SW
@@@ -543,6 -579,95 +549,98 @@@ PE_TER
  	ABORT_ON(parse_events_term__num(&term, (int)$1, NULL, 1, &@1, NULL));
  	$$ = term;
  }
++<<<<<<< HEAD
++=======
+ |
+ PE_NAME array '=' PE_NAME
+ {
+ 	struct parse_events_term *term;
+ 	int i;
+ 
+ 	ABORT_ON(parse_events_term__str(&term, PARSE_EVENTS__TERM_TYPE_USER,
+ 					$1, $4, &@1, &@4));
+ 
+ 	term->array = $2;
+ 	$$ = term;
+ }
+ |
+ PE_NAME array '=' PE_VALUE
+ {
+ 	struct parse_events_term *term;
+ 
+ 	ABORT_ON(parse_events_term__num(&term, PARSE_EVENTS__TERM_TYPE_USER,
+ 					$1, $4, &@1, &@4));
+ 	term->array = $2;
+ 	$$ = term;
+ }
+ |
+ PE_DRV_CFG_TERM
+ {
+ 	struct parse_events_term *term;
+ 
+ 	ABORT_ON(parse_events_term__str(&term, PARSE_EVENTS__TERM_TYPE_DRV_CFG,
+ 					$1, $1, &@1, NULL));
+ 	$$ = term;
+ }
+ 
+ array:
+ '[' array_terms ']'
+ {
+ 	$$ = $2;
+ }
+ |
+ PE_ARRAY_ALL
+ {
+ 	$$.nr_ranges = 0;
+ 	$$.ranges = NULL;
+ }
+ 
+ array_terms:
+ array_terms ',' array_term
+ {
+ 	struct parse_events_array new_array;
+ 
+ 	new_array.nr_ranges = $1.nr_ranges + $3.nr_ranges;
+ 	new_array.ranges = malloc(sizeof(new_array.ranges[0]) *
+ 				  new_array.nr_ranges);
+ 	ABORT_ON(!new_array.ranges);
+ 	memcpy(&new_array.ranges[0], $1.ranges,
+ 	       $1.nr_ranges * sizeof(new_array.ranges[0]));
+ 	memcpy(&new_array.ranges[$1.nr_ranges], $3.ranges,
+ 	       $3.nr_ranges * sizeof(new_array.ranges[0]));
+ 	free($1.ranges);
+ 	free($3.ranges);
+ 	$$ = new_array;
+ }
+ |
+ array_term
+ 
+ array_term:
+ PE_VALUE
+ {
+ 	struct parse_events_array array;
+ 
+ 	array.nr_ranges = 1;
+ 	array.ranges = malloc(sizeof(array.ranges[0]));
+ 	ABORT_ON(!array.ranges);
+ 	array.ranges[0].start = $1;
+ 	array.ranges[0].length = 1;
+ 	$$ = array;
+ }
+ |
+ PE_VALUE PE_ARRAY_RANGE PE_VALUE
+ {
+ 	struct parse_events_array array;
+ 
+ 	ABORT_ON($3 < $1);
+ 	array.nr_ranges = 1;
+ 	array.ranges = malloc(sizeof(array.ranges[0]));
+ 	ABORT_ON(!array.ranges);
+ 	array.ranges[0].start = $1;
+ 	array.ranges[0].length = $3 - $1 + 1;
+ 	$$ = array;
+ }
++>>>>>>> dd60fba73245 (perf tools: Add infrastructure for PMU specific configuration)
  
  sep_dc: ':' |
  
diff --git a/tools/perf/Documentation/perf-record.txt b/tools/perf/Documentation/perf-record.txt
index 20052ecd742e..982e1a2b7e05 100644
--- a/tools/perf/Documentation/perf-record.txt
+++ b/tools/perf/Documentation/perf-record.txt
@@ -60,6 +60,18 @@ OPTIONS
 	  Note: If user explicitly sets options which conflict with the params,
 	  the value set by the params will be overridden.
 
+	  Also not defined in .../<pmu>/format/* are PMU driver specific
+	  configuration parameters.  Any configuration parameter preceded by
+	  the letter '@' is not interpreted in user space and sent down directly
+	  to the PMU driver.  For example:
+
+	  perf record -e some_event/@cfg1,@cfg2=config/ ...
+
+	  will see 'cfg1' and 'cfg2=config' pushed to the PMU driver associated
+	  with the event for further processing.  There is no restriction on
+	  what the configuration parameters are, as long as their semantic is
+	  understood and supported by the PMU driver.
+
         - a hardware breakpoint event in the form of '\mem:addr[/len][:access]'
           where addr is the address in memory you want to break in.
           Access is the memory access type (read, write, execute) it can
* Unmerged path tools/perf/util/evsel.h
* Unmerged path tools/perf/util/parse-events.c
* Unmerged path tools/perf/util/parse-events.h
* Unmerged path tools/perf/util/parse-events.l
* Unmerged path tools/perf/util/parse-events.y
