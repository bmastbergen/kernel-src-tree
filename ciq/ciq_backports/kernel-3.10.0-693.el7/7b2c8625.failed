tracing: Add NMI tracing in hwlat detector

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Steven Rostedt (Red Hat) <rostedt@goodmis.org>
commit 7b2c86250122de316cbab8754050622ead04af39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7b2c8625.failed

As NMIs can also cause latency when interrupts are disabled, the hwlat
detectory has no way to know if the latency it detects is from an NMI or an
SMI or some other hardware glitch.

As ftrace_nmi_enter/exit() funtions are no longer used (except for sh, which
isn't supported anymore), I converted those to "arch_ftrace_nmi_enter/exit"
and use ftrace_nmi_enter/exit() to check if hwlat detector is tracing or
not, and if so, it calls into the hwlat utility.

Since the hwlat detector only has a single kthread that is spinning with
interrupts disabled, it marks what CPU it is on, and if the NMI callback
happens on that CPU, it records the time spent in that NMI. This is added to
the output that is generated by the hwlat detector as:

 #3     inner/outer(us):    9/9     ts:1470836488.206734548
 #4     inner/outer(us):    0/8     ts:1470836497.140808588
 #5     inner/outer(us):    0/6     ts:1470836499.140825168 nmi-total:5 nmi-count:1
 #6     inner/outer(us):    9/9     ts:1470836501.140841748

All time is still tracked in microseconds.

The NMI information is only shown when an NMI occurred during the sample.

	Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
(cherry picked from commit 7b2c86250122de316cbab8754050622ead04af39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/trace_entries.h
#	kernel/trace/trace_hwlat.c
#	kernel/trace/trace_output.c
diff --cc kernel/trace/trace_entries.h
index e2d027ac66a2,d1cc37e78f99..000000000000
--- a/kernel/trace/trace_entries.h
+++ b/kernel/trace/trace_entries.h
@@@ -322,3 -322,30 +322,33 @@@ FTRACE_ENTRY(branch, trace_branch
  	FILTER_OTHER
  );
  
++<<<<<<< HEAD
++=======
+ 
+ FTRACE_ENTRY(hwlat, hwlat_entry,
+ 
+ 	TRACE_HWLAT,
+ 
+ 	F_STRUCT(
+ 		__field(	u64,			duration	)
+ 		__field(	u64,			outer_duration	)
+ 		__field(	u64,			nmi_total_ts	)
+ 		__field_struct( struct timespec,	timestamp	)
+ 		__field_desc(	long,	timestamp,	tv_sec		)
+ 		__field_desc(	long,	timestamp,	tv_nsec		)
+ 		__field(	unsigned int,		nmi_count	)
+ 		__field(	unsigned int,		seqnum		)
+ 	),
+ 
+ 	F_printk("cnt:%u\tts:%010lu.%010lu\tinner:%llu\touter:%llunmi-ts:%llu\tnmi-count:%u\n",
+ 		 __entry->seqnum,
+ 		 __entry->tv_sec,
+ 		 __entry->tv_nsec,
+ 		 __entry->duration,
+ 		 __entry->outer_duration,
+ 		 __entry->nmi_total_ts,
+ 		 __entry->nmi_count),
+ 
+ 	FILTER_OTHER
+ );
++>>>>>>> 7b2c86250122 (tracing: Add NMI tracing in hwlat detector)
diff --cc kernel/trace/trace_output.c
index 9cf812c3bd25,3fc20422c166..000000000000
--- a/kernel/trace/trace_output.c
+++ b/kernel/trace/trace_output.c
@@@ -1291,6 -1098,71 +1291,74 @@@ static struct trace_event trace_user_st
  	.funcs		= &trace_user_stack_funcs,
  };
  
++<<<<<<< HEAD
++=======
+ /* TRACE_HWLAT */
+ static enum print_line_t
+ trace_hwlat_print(struct trace_iterator *iter, int flags,
+ 		  struct trace_event *event)
+ {
+ 	struct trace_entry *entry = iter->ent;
+ 	struct trace_seq *s = &iter->seq;
+ 	struct hwlat_entry *field;
+ 
+ 	trace_assign_type(field, entry);
+ 
+ 	trace_seq_printf(s, "#%-5u inner/outer(us): %4llu/%-5llu ts:%ld.%09ld",
+ 			 field->seqnum,
+ 			 field->duration,
+ 			 field->outer_duration,
+ 			 field->timestamp.tv_sec,
+ 			 field->timestamp.tv_nsec);
+ 
+ 	if (field->nmi_count) {
+ 		/*
+ 		 * The generic sched_clock() is not NMI safe, thus
+ 		 * we only record the count and not the time.
+ 		 */
+ 		if (!IS_ENABLED(CONFIG_GENERIC_SCHED_CLOCK))
+ 			trace_seq_printf(s, " nmi-total:%llu",
+ 					 field->nmi_total_ts);
+ 		trace_seq_printf(s, " nmi-count:%u",
+ 				 field->nmi_count);
+ 	}
+ 
+ 	trace_seq_putc(s, '\n');
+ 
+ 	return trace_handle_return(s);
+ }
+ 
+ 
+ static enum print_line_t
+ trace_hwlat_raw(struct trace_iterator *iter, int flags,
+ 		struct trace_event *event)
+ {
+ 	struct hwlat_entry *field;
+ 	struct trace_seq *s = &iter->seq;
+ 
+ 	trace_assign_type(field, iter->ent);
+ 
+ 	trace_seq_printf(s, "%llu %lld %ld %09ld %u\n",
+ 			 field->duration,
+ 			 field->outer_duration,
+ 			 field->timestamp.tv_sec,
+ 			 field->timestamp.tv_nsec,
+ 			 field->seqnum);
+ 
+ 	return trace_handle_return(s);
+ }
+ 
+ static struct trace_event_functions trace_hwlat_funcs = {
+ 	.trace		= trace_hwlat_print,
+ 	.raw		= trace_hwlat_raw,
+ };
+ 
+ static struct trace_event trace_hwlat_event = {
+ 	.type		= TRACE_HWLAT,
+ 	.funcs		= &trace_hwlat_funcs,
+ };
+ 
++>>>>>>> 7b2c86250122 (tracing: Add NMI tracing in hwlat detector)
  /* TRACE_BPUTS */
  static enum print_line_t
  trace_bputs_print(struct trace_iterator *iter, int flags,
* Unmerged path kernel/trace/trace_hwlat.c
diff --git a/arch/sh/kernel/ftrace.c b/arch/sh/kernel/ftrace.c
index 30e13196d35b..5b65422ab035 100644
--- a/arch/sh/kernel/ftrace.c
+++ b/arch/sh/kernel/ftrace.c
@@ -139,7 +139,7 @@ static void ftrace_mod_code(void)
 		clear_mod_flag();
 }
 
-void ftrace_nmi_enter(void)
+void arch_ftrace_nmi_enter(void)
 {
 	if (atomic_inc_return(&nmi_running) & MOD_CODE_WRITE_FLAG) {
 		smp_rmb();
@@ -150,7 +150,7 @@ void ftrace_nmi_enter(void)
 	smp_mb();
 }
 
-void ftrace_nmi_exit(void)
+void arch_ftrace_nmi_exit(void)
 {
 	/* Finish all executions before clearing nmi_running */
 	smp_mb();
diff --git a/include/linux/ftrace_irq.h b/include/linux/ftrace_irq.h
index dca7bf8cffe2..4ec2c9b205f2 100644
--- a/include/linux/ftrace_irq.h
+++ b/include/linux/ftrace_irq.h
@@ -3,11 +3,34 @@
 
 
 #ifdef CONFIG_FTRACE_NMI_ENTER
-extern void ftrace_nmi_enter(void);
-extern void ftrace_nmi_exit(void);
+extern void arch_ftrace_nmi_enter(void);
+extern void arch_ftrace_nmi_exit(void);
 #else
-static inline void ftrace_nmi_enter(void) { }
-static inline void ftrace_nmi_exit(void) { }
+static inline void arch_ftrace_nmi_enter(void) { }
+static inline void arch_ftrace_nmi_exit(void) { }
 #endif
 
+#ifdef CONFIG_HWLAT_TRACER
+extern bool trace_hwlat_callback_enabled;
+extern void trace_hwlat_callback(bool enter);
+#endif
+
+static inline void ftrace_nmi_enter(void)
+{
+#ifdef CONFIG_HWLAT_TRACER
+	if (trace_hwlat_callback_enabled)
+		trace_hwlat_callback(true);
+#endif
+	arch_ftrace_nmi_enter();
+}
+
+static inline void ftrace_nmi_exit(void)
+{
+	arch_ftrace_nmi_exit();
+#ifdef CONFIG_HWLAT_TRACER
+	if (trace_hwlat_callback_enabled)
+		trace_hwlat_callback(false);
+#endif
+}
+
 #endif /* _LINUX_FTRACE_IRQ_H */
* Unmerged path kernel/trace/trace_entries.h
* Unmerged path kernel/trace/trace_hwlat.c
* Unmerged path kernel/trace/trace_output.c
