sysfs, kernfs: introduce kernfs_rename[_ns]()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tejun Heo <tj@kernel.org>
commit 890ece160c6465b49c42975d529c3481d89da8f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/890ece16.failed

Introduce kernfs rename interface, krenfs_rename[_ns]().

This is just rename of sysfs_rename().  No functional changes.
Function comment is added to kernfs_rename_ns() and @new_parent_sd is
renamed to @new_parent for consistency with other kernfs interfaces.

v2: Dummy implementation for !CONFIG_SYSFS updated to return -ENOSYS.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 890ece160c6465b49c42975d529c3481d89da8f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/dir.c
#	fs/sysfs/symlink.c
#	fs/sysfs/sysfs.h
#	include/linux/kernfs.h
diff --cc fs/sysfs/dir.c
index 3f68344137e5,5ba896630d04..000000000000
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@@ -862,16 -910,37 +862,28 @@@ void sysfs_remove_dir(struct kobject * 
  {
  	struct sysfs_dirent *sd = kobj->sd;
  
 -	/*
 -	 * In general, kboject owner is responsible for ensuring removal
 -	 * doesn't race with other operations and sysfs doesn't provide any
 -	 * protection; however, when @kobj is used as a symlink target, the
 -	 * symlinking entity usually doesn't own @kobj and thus has no
 -	 * control over removal.  @kobj->sd may be removed anytime and
 -	 * symlink code may end up dereferencing an already freed sd.
 -	 *
 -	 * sysfs_symlink_target_lock synchronizes @kobj->sd disassociation
 -	 * against symlink operations so that symlink code can safely
 -	 * dereference @kobj->sd.
 -	 */
 -	spin_lock(&sysfs_symlink_target_lock);
 +	spin_lock(&sysfs_assoc_lock);
  	kobj->sd = NULL;
 -	spin_unlock(&sysfs_symlink_target_lock);
 +	spin_unlock(&sysfs_assoc_lock);
  
 -	if (sd) {
 -		WARN_ON_ONCE(sysfs_type(sd) != SYSFS_DIR);
 -		kernfs_remove(sd);
 -	}
 +	__sysfs_remove_dir(sd);
  }
  
++<<<<<<< HEAD
 +int sysfs_rename(struct sysfs_dirent *sd,
 +	struct sysfs_dirent *new_parent_sd, const void *new_ns,
 +	const char *new_name)
++=======
+ /**
+  * kernfs_rename_ns - move and rename a kernfs_node
+  * @sd: target node
+  * @new_parent: new parent to put @sd under
+  * @new_name: new name
+  * @new_ns: new namespace tag
+  */
+ int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
+ 		     const char *new_name, const void *new_ns)
++>>>>>>> 890ece160c64 (sysfs, kernfs: introduce kernfs_rename[_ns]())
  {
  	int error;
  
@@@ -883,7 -952,7 +895,11 @@@
  		goto out;	/* nothing to rename */
  
  	error = -EEXIST;
++<<<<<<< HEAD
 +	if (sysfs_find_dirent(new_parent_sd, new_ns, new_name))
++=======
+ 	if (sysfs_find_dirent(new_parent, new_name, new_ns))
++>>>>>>> 890ece160c64 (sysfs, kernfs: introduce kernfs_rename[_ns]())
  		goto out;
  
  	/* rename sysfs_dirent */
@@@ -897,13 -966,15 +913,18 @@@
  		sd->s_name = new_name;
  	}
  
 -	/*
 -	 * Move to the appropriate place in the appropriate directories rbtree.
 -	 */
 +	/* Move to the appropriate place in the appropriate directories rbtree. */
  	sysfs_unlink_sibling(sd);
- 	sysfs_get(new_parent_sd);
+ 	sysfs_get(new_parent);
  	sysfs_put(sd->s_parent);
  	sd->s_ns = new_ns;
++<<<<<<< HEAD
 +	sd->s_hash = sysfs_name_hash(sd->s_ns, sd->s_name);
 +	sd->s_parent = new_parent_sd;
++=======
+ 	sd->s_hash = sysfs_name_hash(sd->s_name, sd->s_ns);
+ 	sd->s_parent = new_parent;
++>>>>>>> 890ece160c64 (sysfs, kernfs: introduce kernfs_rename[_ns]())
  	sysfs_link_sibling(sd);
  
  	error = 0;
@@@ -912,18 -983,16 +933,22 @@@
  	return error;
  }
  
 -int sysfs_rename_dir_ns(struct kobject *kobj, const char *new_name,
 -			const void *new_ns)
 +int sysfs_rename_dir(struct kobject *kobj, const char *new_name)
  {
  	struct sysfs_dirent *parent_sd = kobj->sd->s_parent;
 +	const void *new_ns = NULL;
 +
++<<<<<<< HEAD
 +	if (sysfs_ns_type(parent_sd))
 +		new_ns = kobj->ktype->namespace(kobj);
  
 +	return sysfs_rename(kobj->sd, parent_sd, new_ns, new_name);
++=======
+ 	return kernfs_rename_ns(kobj->sd, parent_sd, new_name, new_ns);
++>>>>>>> 890ece160c64 (sysfs, kernfs: introduce kernfs_rename[_ns]())
  }
  
 -int sysfs_move_dir_ns(struct kobject *kobj, struct kobject *new_parent_kobj,
 -		      const void *new_ns)
 +int sysfs_move_dir(struct kobject *kobj, struct kobject *new_parent_kobj)
  {
  	struct sysfs_dirent *sd = kobj->sd;
  	struct sysfs_dirent *new_parent_sd;
@@@ -935,7 -1001,22 +960,26 @@@
  	new_parent_sd = new_parent_kobj && new_parent_kobj->sd ?
  		new_parent_kobj->sd : &sysfs_root;
  
++<<<<<<< HEAD
 +	return sysfs_rename(sd, new_parent_sd, new_ns, sd->s_name);
++=======
+ 	return kernfs_rename_ns(sd, new_parent_sd, sd->s_name, new_ns);
+ }
+ 
+ /**
+  * sysfs_enable_ns - enable namespace under a directory
+  * @sd: directory of interest, should be empty
+  *
+  * This is to be called right after @sd is created to enable namespace
+  * under it.  All children of @sd must have non-NULL namespace tags and
+  * only the ones which match the super_block's tag will be visible.
+  */
+ void sysfs_enable_ns(struct sysfs_dirent *sd)
+ {
+ 	WARN_ON_ONCE(sysfs_type(sd) != SYSFS_DIR);
+ 	WARN_ON_ONCE(!RB_EMPTY_ROOT(&sd->s_dir.children));
+ 	sd->s_flags |= SYSFS_FLAG_NS;
++>>>>>>> 890ece160c64 (sysfs, kernfs: introduce kernfs_rename[_ns]())
  }
  
  /* Relationship between s_mode and the DT_xxx types */
diff --cc fs/sysfs/symlink.c
index 8c940df97a52,0922c53bd757..000000000000
--- a/fs/sysfs/symlink.c
+++ b/fs/sysfs/symlink.c
@@@ -214,10 -226,7 +214,14 @@@ int sysfs_rename_link(struct kobject *k
  	if (sd->s_symlink.target_sd->s_dir.kobj != targ)
  		goto out;
  
++<<<<<<< HEAD
 +	if (sysfs_ns_type(parent_sd))
 +		new_ns = targ->ktype->namespace(targ);
 +
 +	result = sysfs_rename(sd, parent_sd, new_ns, new);
++=======
+ 	result = kernfs_rename_ns(sd, parent_sd, new, new_ns);
++>>>>>>> 890ece160c64 (sysfs, kernfs: introduce kernfs_rename[_ns]())
  
  out:
  	sysfs_put(sd);
diff --cc fs/sysfs/sysfs.h
index d1e4043eb0c3,8b3fc210b90d..000000000000
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@@ -184,11 -184,7 +184,14 @@@ void release_sysfs_dirent(struct sysfs_
  
  int sysfs_create_subdir(struct kobject *kobj, const char *name,
  			struct sysfs_dirent **p_sd);
 +void sysfs_remove_subdir(struct sysfs_dirent *sd);
  
++<<<<<<< HEAD
 +int sysfs_rename(struct sysfs_dirent *sd,
 +	struct sysfs_dirent *new_parent_sd, const void *ns, const char *new_name);
 +
++=======
++>>>>>>> 890ece160c64 (sysfs, kernfs: introduce kernfs_rename[_ns]())
  static inline struct sysfs_dirent *__sysfs_get(struct sysfs_dirent *sd)
  {
  	if (sd) {
diff --cc include/linux/kernfs.h
index 254b9e872b09,803d9600cf72..000000000000
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@@ -7,6 -7,46 +7,46 @@@
  #ifndef __LINUX_KERNFS_H
  #define __LINUX_KERNFS_H
  
 -#include <linux/kernel.h>
 -#include <linux/err.h>
 -
  struct sysfs_dirent;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_SYSFS
+ 
+ struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
+ 					const char *name,
+ 					struct sysfs_dirent *target);
+ void kernfs_remove(struct sysfs_dirent *sd);
+ int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
+ 			     const void *ns);
+ int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
+ 		     const char *new_name, const void *new_ns);
+ 
+ #else	/* CONFIG_SYSFS */
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_link(struct sysfs_dirent *parent, const char *name,
+ 		   struct sysfs_dirent *target)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline void kernfs_remove(struct sysfs_dirent *sd) { }
+ 
+ static inline int kernfs_remove_by_name_ns(struct sysfs_dirent *parent,
+ 					   const char *name, const void *ns)
+ { return -ENOSYS; }
+ 
+ static inline int kernfs_rename_ns(struct sysfs_dirent *sd,
+ 				   struct sysfs_dirent *new_parent,
+ 				   const char *new_name, const void *new_ns)
+ { return -ENOSYS; }
+ 
+ #endif	/* CONFIG_SYSFS */
+ 
+ static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,
+ 					const char *name)
+ {
+ 	return kernfs_remove_by_name_ns(parent, name, NULL);
+ }
+ 
++>>>>>>> 890ece160c64 (sysfs, kernfs: introduce kernfs_rename[_ns]())
  #endif	/* __LINUX_KERNFS_H */
* Unmerged path fs/sysfs/dir.c
* Unmerged path fs/sysfs/symlink.c
* Unmerged path fs/sysfs/sysfs.h
* Unmerged path include/linux/kernfs.h
