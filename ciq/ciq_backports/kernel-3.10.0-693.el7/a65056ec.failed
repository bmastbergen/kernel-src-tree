net: bridge: extend MLD/IGMP query stats

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] bridge: extend MLD/IGMP query stats (Ivan Vecera) [1352289]
Rebuild_FUZZ: 93.33%
commit-author Nikolay Aleksandrov <razor@blackwall.org>
commit a65056ecf4b48be0d0284a7b6a57b6dace10b843
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a65056ec.failed

As was suggested this patch adds support for the different versions of MLD
and IGMP query types. Since the user visible structure is still in net-next
we can augment it instead of adding netlink attributes.
The distinction between the different IGMP/MLD query types is done as
suggested in Section 7.1, RFC 3376 [1] and Section 8.1, RFC 3810 [2] based
on query payload size and code for IGMP. Since all IGMP packets go through
multicast_rcv() and it uses ip_mc_check_igmp/ipv6_mc_check_mld we can be
sure that at least the ip/ipv6 header can be directly used.

[1] https://tools.ietf.org/html/rfc3376#section-7
[2] https://tools.ietf.org/html/rfc3810#section-8.1

	Suggested-by: Linus LÃ¼ssing <linus.luessing@c0d3.blue>
	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Acked-by: Stephen Hemminger <stephen@networkplumber.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a65056ecf4b48be0d0284a7b6a57b6dace10b843)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_bridge.h
#	net/bridge/br_forward.c
#	net/bridge/br_input.c
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
diff --cc include/uapi/linux/if_bridge.h
index 15a865acafe9,c186f64fffca..000000000000
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@@ -209,4 -243,41 +209,44 @@@ enum 
  };
  #define MDBA_SET_ENTRY_MAX (__MDBA_SET_ENTRY_MAX - 1)
  
++<<<<<<< HEAD
++=======
+ /* Embedded inside LINK_XSTATS_TYPE_BRIDGE */
+ enum {
+ 	BRIDGE_XSTATS_UNSPEC,
+ 	BRIDGE_XSTATS_VLAN,
+ 	BRIDGE_XSTATS_MCAST,
+ 	BRIDGE_XSTATS_PAD,
+ 	__BRIDGE_XSTATS_MAX
+ };
+ #define BRIDGE_XSTATS_MAX (__BRIDGE_XSTATS_MAX - 1)
+ 
+ enum {
+ 	BR_MCAST_DIR_RX,
+ 	BR_MCAST_DIR_TX,
+ 	BR_MCAST_DIR_SIZE
+ };
+ 
+ /* IGMP/MLD statistics */
+ struct br_mcast_stats {
+ 	__u64 igmp_v1queries[BR_MCAST_DIR_SIZE];
+ 	__u64 igmp_v2queries[BR_MCAST_DIR_SIZE];
+ 	__u64 igmp_v3queries[BR_MCAST_DIR_SIZE];
+ 	__u64 igmp_leaves[BR_MCAST_DIR_SIZE];
+ 	__u64 igmp_v1reports[BR_MCAST_DIR_SIZE];
+ 	__u64 igmp_v2reports[BR_MCAST_DIR_SIZE];
+ 	__u64 igmp_v3reports[BR_MCAST_DIR_SIZE];
+ 	__u64 igmp_parse_errors;
+ 
+ 	__u64 mld_v1queries[BR_MCAST_DIR_SIZE];
+ 	__u64 mld_v2queries[BR_MCAST_DIR_SIZE];
+ 	__u64 mld_leaves[BR_MCAST_DIR_SIZE];
+ 	__u64 mld_v1reports[BR_MCAST_DIR_SIZE];
+ 	__u64 mld_v2reports[BR_MCAST_DIR_SIZE];
+ 	__u64 mld_parse_errors;
+ 
+ 	__u64 mcast_bytes[BR_MCAST_DIR_SIZE];
+ 	__u64 mcast_packets[BR_MCAST_DIR_SIZE];
+ };
++>>>>>>> a65056ecf4b4 (net: bridge: extend MLD/IGMP query stats)
  #endif /* _UAPI_LINUX_IF_BRIDGE_H */
diff --cc net/bridge/br_forward.c
index 20c11b41fe6a,d610644368b9..000000000000
--- a/net/bridge/br_forward.c
+++ b/net/bridge/br_forward.c
@@@ -196,8 -198,9 +196,13 @@@ static void br_flood(struct net_bridge 
  					   struct sk_buff *skb),
  		     bool unicast)
  {
++<<<<<<< HEAD
++=======
+ 	u8 igmp_type = br_multicast_igmp_type(skb);
+ 	struct net_bridge_port *prev;
++>>>>>>> a65056ecf4b4 (net: bridge: extend MLD/IGMP query stats)
  	struct net_bridge_port *p;
 +	struct net_bridge_port *prev;
  
  	prev = NULL;
  
@@@ -208,6 -211,17 +213,12 @@@
  		prev = maybe_deliver(prev, p, skb, __packet_hook);
  		if (IS_ERR(prev))
  			goto out;
++<<<<<<< HEAD
++=======
+ 		if (prev == p)
+ 			br_multicast_count(p->br, p, skb, igmp_type,
+ 					   BR_MCAST_DIR_TX);
++>>>>>>> a65056ecf4b4 (net: bridge: extend MLD/IGMP query stats)
  	}
  
  	if (!prev)
@@@ -267,6 -282,9 +278,12 @@@ static void br_multicast_flood(struct n
  		prev = maybe_deliver(prev, port, skb, __packet_hook);
  		if (IS_ERR(prev))
  			goto out;
++<<<<<<< HEAD
++=======
+ 		if (prev == port)
+ 			br_multicast_count(port->br, port, skb, igmp_type,
+ 					   BR_MCAST_DIR_TX);
++>>>>>>> a65056ecf4b4 (net: bridge: extend MLD/IGMP query stats)
  
  		if ((unsigned long)lport >= (unsigned long)port)
  			p = rcu_dereference(p->next);
diff --cc net/bridge/br_input.c
index ddc6cbe6269c,a7817e6f306f..000000000000
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@@ -49,13 -57,75 +49,19 @@@ static int br_pass_frame_up(struct sk_b
  
  	indev = skb->dev;
  	skb->dev = brdev;
 -	skb = br_handle_vlan(br, vg, skb);
 +	skb = br_handle_vlan(br, pv, skb);
  	if (!skb)
  		return NET_RX_DROP;
++<<<<<<< HEAD
++=======
+ 	/* update the multicast stats if the packet is IGMP/MLD */
+ 	br_multicast_count(br, NULL, skb, br_multicast_igmp_type(skb),
+ 			   BR_MCAST_DIR_TX);
++>>>>>>> a65056ecf4b4 (net: bridge: extend MLD/IGMP query stats)
  
 -	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,
 -		       dev_net(indev), NULL, skb, indev, NULL,
 -		       br_netif_receive_skb);
 -}
 -
 -static void br_do_proxy_arp(struct sk_buff *skb, struct net_bridge *br,
 -			    u16 vid, struct net_bridge_port *p)
 -{
 -	struct net_device *dev = br->dev;
 -	struct neighbour *n;
 -	struct arphdr *parp;
 -	u8 *arpptr, *sha;
 -	__be32 sip, tip;
 -
 -	BR_INPUT_SKB_CB(skb)->proxyarp_replied = false;
 -
 -	if (dev->flags & IFF_NOARP)
 -		return;
 -
 -	if (!pskb_may_pull(skb, arp_hdr_len(dev))) {
 -		dev->stats.tx_dropped++;
 -		return;
 -	}
 -	parp = arp_hdr(skb);
 -
 -	if (parp->ar_pro != htons(ETH_P_IP) ||
 -	    parp->ar_op != htons(ARPOP_REQUEST) ||
 -	    parp->ar_hln != dev->addr_len ||
 -	    parp->ar_pln != 4)
 -		return;
 -
 -	arpptr = (u8 *)parp + sizeof(struct arphdr);
 -	sha = arpptr;
 -	arpptr += dev->addr_len;	/* sha */
 -	memcpy(&sip, arpptr, sizeof(sip));
 -	arpptr += sizeof(sip);
 -	arpptr += dev->addr_len;	/* tha */
 -	memcpy(&tip, arpptr, sizeof(tip));
 -
 -	if (ipv4_is_loopback(tip) ||
 -	    ipv4_is_multicast(tip))
 -		return;
 -
 -	n = neigh_lookup(&arp_tbl, &tip, dev);
 -	if (n) {
 -		struct net_bridge_fdb_entry *f;
 -
 -		if (!(n->nud_state & NUD_VALID)) {
 -			neigh_release(n);
 -			return;
 -		}
 -
 -		f = __br_fdb_get(br, n->ha, vid);
 -		if (f && ((p->flags & BR_PROXYARP) ||
 -			  (f->dst && (f->dst->flags & BR_PROXYARP_WIFI)))) {
 -			arp_send(ARPOP_REPLY, ETH_P_ARP, sip, skb->dev, tip,
 -				 sha, n->ha, sha);
 -			BR_INPUT_SKB_CB(skb)->proxyarp_replied = true;
 -		}
 -
 -		neigh_release(n);
 -	}
 +	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, NULL, skb,
 +		       indev, NULL,
 +		       netif_receive_skb_sk);
  }
  
  /* note: already called with rcu_read_lock */
diff --cc net/bridge/br_multicast.c
index 5d8caeb30a05,a5423a1eec05..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -819,11 -843,17 +819,23 @@@ static void __br_multicast_send_query(s
  
  	if (port) {
  		skb->dev = port->dev;
++<<<<<<< HEAD
 +		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, NULL, skb,
 +			NULL, skb->dev,
 +			br_dev_queue_push_xmit);
 +	} else
++=======
+ 		br_multicast_count(br, port, skb, igmp_type,
+ 				   BR_MCAST_DIR_TX);
+ 		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT,
+ 			dev_net(port->dev), NULL, skb, NULL, skb->dev,
+ 			br_dev_queue_push_xmit);
+ 	} else {
+ 		br_multicast_select_own_querier(br, ip, skb);
+ 		br_multicast_count(br, port, skb, igmp_type,
+ 				   BR_MCAST_DIR_RX);
++>>>>>>> a65056ecf4b4 (net: bridge: extend MLD/IGMP query stats)
  		netif_rx(skb);
 -	}
  }
  
  static void br_multicast_send_query(struct net_bridge *br,
@@@ -1592,11 -1673,12 +1604,20 @@@ static int br_multicast_ipv4_rcv(struc
  		break;
  	}
  
++<<<<<<< HEAD
 +out:
 +	__skb_push(skb2, offset);
 +err_out:
 +	if (skb2 != skb)
 +		kfree_skb(skb2);
++=======
+ 	if (skb_trimmed && skb_trimmed != skb)
+ 		kfree_skb(skb_trimmed);
+ 
+ 	br_multicast_count(br, port, skb, BR_INPUT_SKB_CB(skb)->igmp,
+ 			   BR_MCAST_DIR_RX);
+ 
++>>>>>>> a65056ecf4b4 (net: bridge: extend MLD/IGMP query stats)
  	return err;
  }
  
@@@ -1705,27 -1711,23 +1726,36 @@@ static int br_multicast_ipv6_rcv(struc
  		BR_INPUT_SKB_CB(skb)->mrouters_only = 1;
  		err = br_ip6_multicast_add_group(br, port, &mld->mld_mca, vid);
  		break;
 +	    }
  	case ICMPV6_MLD2_REPORT:
 -		err = br_ip6_multicast_mld2_report(br, port, skb_trimmed, vid);
 +		err = br_ip6_multicast_mld2_report(br, port, skb2, vid);
  		break;
  	case ICMPV6_MGM_QUERY:
 -		err = br_ip6_multicast_query(br, port, skb_trimmed, vid);
 +		err = br_ip6_multicast_query(br, port, skb2, vid);
  		break;
  	case ICMPV6_MGM_REDUCTION:
 +	    {
 +		struct mld_msg *mld;
 +		if (!pskb_may_pull(skb2, sizeof(*mld))) {
 +			err = -EINVAL;
 +			goto out;
 +		}
 +		mld = (struct mld_msg *)skb_transport_header(skb2);
  		br_ip6_multicast_leave_group(br, port, &mld->mld_mca, vid);
 -		break;
 +	    }
  	}
  
++<<<<<<< HEAD
 +out:
 +	kfree_skb(skb2);
++=======
+ 	if (skb_trimmed && skb_trimmed != skb)
+ 		kfree_skb(skb_trimmed);
+ 
+ 	br_multicast_count(br, port, skb, BR_INPUT_SKB_CB(skb)->igmp,
+ 			   BR_MCAST_DIR_RX);
+ 
++>>>>>>> a65056ecf4b4 (net: bridge: extend MLD/IGMP query stats)
  	return err;
  }
  #endif
@@@ -2140,4 -2163,240 +2170,168 @@@ unlock
  	return count;
  }
  EXPORT_SYMBOL_GPL(br_multicast_list_adjacent);
 -
 -/**
 - * br_multicast_has_querier_anywhere - Checks for a querier on a bridge
 - * @dev: The bridge port providing the bridge on which to check for a querier
 - * @proto: The protocol family to check for: IGMP -> ETH_P_IP, MLD -> ETH_P_IPV6
 - *
 - * Checks whether the given interface has a bridge on top and if so returns
 - * true if a valid querier exists anywhere on the bridged link layer.
 - * Otherwise returns false.
 - */
 -bool br_multicast_has_querier_anywhere(struct net_device *dev, int proto)
 -{
 -	struct net_bridge *br;
 -	struct net_bridge_port *port;
 -	struct ethhdr eth;
 -	bool ret = false;
 -
 -	rcu_read_lock();
 -	if (!br_port_exists(dev))
 -		goto unlock;
 -
 -	port = br_port_get_rcu(dev);
 -	if (!port || !port->br)
 -		goto unlock;
 -
 -	br = port->br;
 -
 -	memset(&eth, 0, sizeof(eth));
 -	eth.h_proto = htons(proto);
 -
 -	ret = br_multicast_querier_exists(br, &eth);
 -
 -unlock:
 -	rcu_read_unlock();
 -	return ret;
 -}
 -EXPORT_SYMBOL_GPL(br_multicast_has_querier_anywhere);
 -
 -/**
 - * br_multicast_has_querier_adjacent - Checks for a querier behind a bridge port
 - * @dev: The bridge port adjacent to which to check for a querier
 - * @proto: The protocol family to check for: IGMP -> ETH_P_IP, MLD -> ETH_P_IPV6
 - *
 - * Checks whether the given interface has a bridge on top and if so returns
 - * true if a selected querier is behind one of the other ports of this
 - * bridge. Otherwise returns false.
 - */
 -bool br_multicast_has_querier_adjacent(struct net_device *dev, int proto)
 -{
 -	struct net_bridge *br;
 -	struct net_bridge_port *port;
 -	bool ret = false;
 -
 -	rcu_read_lock();
 -	if (!br_port_exists(dev))
 -		goto unlock;
 -
 -	port = br_port_get_rcu(dev);
 -	if (!port || !port->br)
 -		goto unlock;
 -
 -	br = port->br;
 -
 -	switch (proto) {
 -	case ETH_P_IP:
 -		if (!timer_pending(&br->ip4_other_query.timer) ||
 -		    rcu_dereference(br->ip4_querier.port) == port)
 -			goto unlock;
 -		break;
 -#if IS_ENABLED(CONFIG_IPV6)
 -	case ETH_P_IPV6:
 -		if (!timer_pending(&br->ip6_other_query.timer) ||
 -		    rcu_dereference(br->ip6_querier.port) == port)
 -			goto unlock;
 -		break;
  #endif
++<<<<<<< HEAD
++=======
+ 	default:
+ 		goto unlock;
+ 	}
+ 
+ 	ret = true;
+ unlock:
+ 	rcu_read_unlock();
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(br_multicast_has_querier_adjacent);
+ 
+ static void br_mcast_stats_add(struct bridge_mcast_stats __percpu *stats,
+ 			       const struct sk_buff *skb, u8 type, u8 dir)
+ {
+ 	struct bridge_mcast_stats *pstats = this_cpu_ptr(stats);
+ 	__be16 proto = skb->protocol;
+ 	unsigned int t_len;
+ 
+ 	u64_stats_update_begin(&pstats->syncp);
+ 	switch (proto) {
+ 	case htons(ETH_P_IP):
+ 		t_len = ntohs(ip_hdr(skb)->tot_len) - ip_hdrlen(skb);
+ 		switch (type) {
+ 		case IGMP_HOST_MEMBERSHIP_REPORT:
+ 			pstats->mstats.igmp_v1reports[dir]++;
+ 			break;
+ 		case IGMPV2_HOST_MEMBERSHIP_REPORT:
+ 			pstats->mstats.igmp_v2reports[dir]++;
+ 			break;
+ 		case IGMPV3_HOST_MEMBERSHIP_REPORT:
+ 			pstats->mstats.igmp_v3reports[dir]++;
+ 			break;
+ 		case IGMP_HOST_MEMBERSHIP_QUERY:
+ 			if (t_len != sizeof(struct igmphdr)) {
+ 				pstats->mstats.igmp_v3queries[dir]++;
+ 			} else {
+ 				unsigned int offset = skb_transport_offset(skb);
+ 				struct igmphdr *ih, _ihdr;
+ 
+ 				ih = skb_header_pointer(skb, offset,
+ 							sizeof(_ihdr), &_ihdr);
+ 				if (!ih)
+ 					break;
+ 				if (!ih->code)
+ 					pstats->mstats.igmp_v1queries[dir]++;
+ 				else
+ 					pstats->mstats.igmp_v2queries[dir]++;
+ 			}
+ 			break;
+ 		case IGMP_HOST_LEAVE_MESSAGE:
+ 			pstats->mstats.igmp_leaves[dir]++;
+ 			break;
+ 		}
+ 		break;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case htons(ETH_P_IPV6):
+ 		t_len = ntohs(ipv6_hdr(skb)->payload_len) +
+ 			sizeof(struct ipv6hdr);
+ 		t_len -= skb_network_header_len(skb);
+ 		switch (type) {
+ 		case ICMPV6_MGM_REPORT:
+ 			pstats->mstats.mld_v1reports[dir]++;
+ 			break;
+ 		case ICMPV6_MLD2_REPORT:
+ 			pstats->mstats.mld_v2reports[dir]++;
+ 			break;
+ 		case ICMPV6_MGM_QUERY:
+ 			if (t_len != sizeof(struct mld_msg))
+ 				pstats->mstats.mld_v2queries[dir]++;
+ 			else
+ 				pstats->mstats.mld_v1queries[dir]++;
+ 			break;
+ 		case ICMPV6_MGM_REDUCTION:
+ 			pstats->mstats.mld_leaves[dir]++;
+ 			break;
+ 		}
+ 		break;
+ #endif /* CONFIG_IPV6 */
+ 	}
+ 	u64_stats_update_end(&pstats->syncp);
+ }
+ 
+ void br_multicast_count(struct net_bridge *br, const struct net_bridge_port *p,
+ 			const struct sk_buff *skb, u8 type, u8 dir)
+ {
+ 	struct bridge_mcast_stats __percpu *stats;
+ 
+ 	/* if multicast_disabled is true then igmp type can't be set */
+ 	if (!type || !br->multicast_stats_enabled)
+ 		return;
+ 
+ 	if (p)
+ 		stats = p->mcast_stats;
+ 	else
+ 		stats = br->mcast_stats;
+ 	if (WARN_ON(!stats))
+ 		return;
+ 
+ 	br_mcast_stats_add(stats, skb, type, dir);
+ }
+ 
+ int br_multicast_init_stats(struct net_bridge *br)
+ {
+ 	br->mcast_stats = netdev_alloc_pcpu_stats(struct bridge_mcast_stats);
+ 	if (!br->mcast_stats)
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ static void mcast_stats_add_dir(u64 *dst, u64 *src)
+ {
+ 	dst[BR_MCAST_DIR_RX] += src[BR_MCAST_DIR_RX];
+ 	dst[BR_MCAST_DIR_TX] += src[BR_MCAST_DIR_TX];
+ }
+ 
+ void br_multicast_get_stats(const struct net_bridge *br,
+ 			    const struct net_bridge_port *p,
+ 			    struct br_mcast_stats *dest)
+ {
+ 	struct bridge_mcast_stats __percpu *stats;
+ 	struct br_mcast_stats tdst;
+ 	int i;
+ 
+ 	memset(dest, 0, sizeof(*dest));
+ 	if (p)
+ 		stats = p->mcast_stats;
+ 	else
+ 		stats = br->mcast_stats;
+ 	if (WARN_ON(!stats))
+ 		return;
+ 
+ 	memset(&tdst, 0, sizeof(tdst));
+ 	for_each_possible_cpu(i) {
+ 		struct bridge_mcast_stats *cpu_stats = per_cpu_ptr(stats, i);
+ 		struct br_mcast_stats temp;
+ 		unsigned int start;
+ 
+ 		do {
+ 			start = u64_stats_fetch_begin_irq(&cpu_stats->syncp);
+ 			memcpy(&temp, &cpu_stats->mstats, sizeof(temp));
+ 		} while (u64_stats_fetch_retry_irq(&cpu_stats->syncp, start));
+ 
+ 		mcast_stats_add_dir(tdst.igmp_v1queries, temp.igmp_v1queries);
+ 		mcast_stats_add_dir(tdst.igmp_v2queries, temp.igmp_v2queries);
+ 		mcast_stats_add_dir(tdst.igmp_v3queries, temp.igmp_v3queries);
+ 		mcast_stats_add_dir(tdst.igmp_leaves, temp.igmp_leaves);
+ 		mcast_stats_add_dir(tdst.igmp_v1reports, temp.igmp_v1reports);
+ 		mcast_stats_add_dir(tdst.igmp_v2reports, temp.igmp_v2reports);
+ 		mcast_stats_add_dir(tdst.igmp_v3reports, temp.igmp_v3reports);
+ 		tdst.igmp_parse_errors += temp.igmp_parse_errors;
+ 
+ 		mcast_stats_add_dir(tdst.mld_v1queries, temp.mld_v1queries);
+ 		mcast_stats_add_dir(tdst.mld_v2queries, temp.mld_v2queries);
+ 		mcast_stats_add_dir(tdst.mld_leaves, temp.mld_leaves);
+ 		mcast_stats_add_dir(tdst.mld_v1reports, temp.mld_v1reports);
+ 		mcast_stats_add_dir(tdst.mld_v2reports, temp.mld_v2reports);
+ 		tdst.mld_parse_errors += temp.mld_parse_errors;
+ 	}
+ 	memcpy(dest, &tdst, sizeof(*dest));
+ }
++>>>>>>> a65056ecf4b4 (net: bridge: extend MLD/IGMP query stats)
diff --cc net/bridge/br_private.h
index 1e1daa30e106,40f200947ddc..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -475,7 -582,15 +475,19 @@@ br_multicast_new_port_group(struct net_
  void br_mdb_init(void);
  void br_mdb_uninit(void);
  void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
++<<<<<<< HEAD
 +		   struct br_ip *group, int type);
++=======
+ 		   struct br_ip *group, int type, u8 flags);
+ void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
+ 		   int type);
+ void br_multicast_count(struct net_bridge *br, const struct net_bridge_port *p,
+ 			const struct sk_buff *skb, u8 type, u8 dir);
+ int br_multicast_init_stats(struct net_bridge *br);
+ void br_multicast_get_stats(const struct net_bridge *br,
+ 			    const struct net_bridge_port *p,
+ 			    struct br_mcast_stats *dest);
++>>>>>>> a65056ecf4b4 (net: bridge: extend MLD/IGMP query stats)
  
  #define mlock_dereference(X, br) \
  	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
@@@ -595,6 -716,23 +607,26 @@@ static inline void br_mdb_init(void
  static inline void br_mdb_uninit(void)
  {
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline void br_multicast_count(struct net_bridge *br,
+ 				      const struct net_bridge_port *p,
+ 				      const struct sk_buff *skb,
+ 				      u8 type, u8 dir)
+ {
+ }
+ 
+ static inline int br_multicast_init_stats(struct net_bridge *br)
+ {
+ 	return 0;
+ }
+ 
+ static inline int br_multicast_igmp_type(const struct sk_buff *skb)
+ {
+ 	return 0;
+ }
++>>>>>>> a65056ecf4b4 (net: bridge: extend MLD/IGMP query stats)
  #endif
  
  /* br_vlan.c */
* Unmerged path include/uapi/linux/if_bridge.h
* Unmerged path net/bridge/br_forward.c
* Unmerged path net/bridge/br_input.c
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_private.h
