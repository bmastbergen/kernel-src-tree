i40e: rename i40e_put_mac_in_vlan and i40e_del_mac_all_vlan

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit feffdbe47d6f4c02b5e2764e14490c5f9d250bdb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/feffdbe4.failed

These functions purpose is to add a new MAC filter correctly, whether
we're using VLANs or not. Their goal is to ensure that all active VLANs
get the new MAC filter. Rename them so that their intent is clear. They
function correctly regardless of whether we have any active VLANs or
only have I40E_VLAN_ANY filters. The new names convey how they function
in a more clear manner.

Change-ID: Iec1961f968c0223a7132724a74e26a665750b107
	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit feffdbe47d6f4c02b5e2764e14490c5f9d250bdb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e.h
#	drivers/net/ethernet/intel/i40e/i40e_main.c
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index 2ef7a3690712,4a648840e5d4..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -838,15 -851,15 +838,25 @@@ int i40e_open(struct net_device *netdev
  int i40e_close(struct net_device *netdev);
  int i40e_vsi_open(struct i40e_vsi *vsi);
  void i40e_vlan_stripping_disable(struct i40e_vsi *vsi);
++<<<<<<< HEAD
 +int i40e_vsi_add_vlan(struct i40e_vsi *vsi, s16 vid);
 +int i40e_vsi_kill_vlan(struct i40e_vsi *vsi, s16 vid);
 +struct i40e_mac_filter *i40e_put_mac_in_vlan(struct i40e_vsi *vsi, u8 *macaddr,
 +					     bool is_vf, bool is_netdev);
 +int i40e_del_mac_all_vlan(struct i40e_vsi *vsi, u8 *macaddr,
 +			  bool is_vf, bool is_netdev);
++=======
+ int i40e_add_vlan_all_mac(struct i40e_vsi *vsi, s16 vid);
+ int i40e_vsi_add_vlan(struct i40e_vsi *vsi, u16 vid);
+ void i40e_rm_vlan_all_mac(struct i40e_vsi *vsi, s16 vid);
+ void i40e_vsi_kill_vlan(struct i40e_vsi *vsi, u16 vid);
+ struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
+ 					    const u8 *macaddr);
+ int i40e_del_mac_filter(struct i40e_vsi *vsi, const u8 *macaddr);
++>>>>>>> feffdbe47d6f (i40e: rename i40e_put_mac_in_vlan and i40e_del_mac_all_vlan)
  bool i40e_is_vsi_in_vlan(struct i40e_vsi *vsi);
 -struct i40e_mac_filter *i40e_find_mac(struct i40e_vsi *vsi, const u8 *macaddr);
 +struct i40e_mac_filter *i40e_find_mac(struct i40e_vsi *vsi, u8 *macaddr,
 +				      bool is_vf, bool is_netdev);
  #ifdef I40E_FCOE
  int __i40e_setup_tc(struct net_device *netdev, u32 handle, __be16 proto,
  		    struct tc_to_netdev *tc);
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 2f00e31ef630,da9f8d38d6b9..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -1382,48 -1472,77 +1382,98 @@@ void i40e_del_filter(struct i40e_vsi *v
  	if (!vsi || !macaddr)
  		return;
  
 -	f = i40e_find_filter(vsi, macaddr, vlan);
 -	__i40e_del_filter(vsi, f);
 -}
 +	f = i40e_find_filter(vsi, macaddr, vlan, is_vf, is_netdev);
 +	if (!f || f->counter == 0)
 +		return;
  
++<<<<<<< HEAD
 +	if (is_vf) {
 +		if (f->is_vf) {
 +			f->is_vf = false;
 +			f->counter--;
 +		}
 +	} else if (is_netdev) {
 +		if (f->is_netdev) {
 +			f->is_netdev = false;
 +			f->counter--;
 +		}
 +	} else {
 +		/* make sure we don't remove a filter in use by VF or netdev */
 +		int min_f = 0;
++=======
+ /**
+  * i40e_add_mac_filter - Add a MAC filter for all active VLANs
+  * @vsi: the VSI to be searched
+  * @macaddr: the mac address to be filtered
+  *
+  * If we're not in VLAN mode, just add the filter to I40E_VLAN_ANY. Otherwise,
+  * go through all the macvlan filters and add a macvlan filter for each
+  * unique vlan that already exists. If a PVID has been assigned, instead only
+  * add the macaddr to that VLAN.
+  *
+  * Returns last filter added on success, else NULL
+  **/
+ struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
+ 					    const u8 *macaddr)
+ {
+ 	struct i40e_mac_filter *f, *add = NULL;
+ 	struct hlist_node *h;
+ 	int bkt;
++>>>>>>> feffdbe47d6f (i40e: rename i40e_put_mac_in_vlan and i40e_del_mac_all_vlan)
  
 -	if (vsi->info.pvid)
 -		return i40e_add_filter(vsi, macaddr,
 -				       le16_to_cpu(vsi->info.pvid));
 +		min_f += (f->is_vf ? 1 : 0);
 +		min_f += (f->is_netdev ? 1 : 0);
  
 -	if (!i40e_is_vsi_in_vlan(vsi))
 -		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);
 -
 -	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
 -		if (f->state == I40E_FILTER_REMOVE)
 -			continue;
 -		add = i40e_add_filter(vsi, macaddr, f->vlan);
 -		if (!add)
 -			return NULL;
 +		if (f->counter > min_f)
 +			f->counter--;
  	}
  
++<<<<<<< HEAD
 +	/* counter == 0 tells sync_filters_subtask to
 +	 * remove the filter from the firmware's list
 +	 */
 +	if (f->counter == 0) {
 +		if ((f->state == I40E_FILTER_FAILED) ||
 +		    (f->state == I40E_FILTER_NEW)) {
 +			/* this one never got added by the FW. Just remove it,
 +			 * no need to sync anything.
 +			 */
 +			list_del(&f->list);
 +			kfree(f);
 +		} else {
 +			f->state = I40E_FILTER_REMOVE;
 +			vsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;
 +			vsi->back->flags |= I40E_FLAG_FILTER_SYNC;
++=======
+ 	return add;
+ }
+ 
+ /**
+  * i40e_del_mac_filter - Remove a MAC filter from all VLANs
+  * @vsi: the VSI to be searched
+  * @macaddr: the mac address to be removed
+  *
+  * Removes a given MAC address from a VSI regardless of what VLAN it has been
+  * associated with.
+  *
+  * Returns 0 for success, or error
+  **/
+ int i40e_del_mac_filter(struct i40e_vsi *vsi, const u8 *macaddr)
+ {
+ 	struct i40e_mac_filter *f;
+ 	struct hlist_node *h;
+ 	bool found = false;
+ 	int bkt;
+ 
+ 	WARN(!spin_is_locked(&vsi->mac_filter_hash_lock),
+ 	     "Missing mac_filter_hash_lock\n");
+ 	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
+ 		if (ether_addr_equal(macaddr, f->macaddr)) {
+ 			__i40e_del_filter(vsi, f);
+ 			found = true;
++>>>>>>> feffdbe47d6f (i40e: rename i40e_put_mac_in_vlan and i40e_del_mac_all_vlan)
  		}
  	}
 -
 -	if (found)
 -		return 0;
 -	else
 -		return -ENOENT;
  }
  
  /**
@@@ -1464,10 -1583,10 +1514,17 @@@ static int i40e_set_mac(struct net_devi
  	else
  		netdev_info(netdev, "set new mac address %pM\n", addr->sa_data);
  
++<<<<<<< HEAD
 +	spin_lock_bh(&vsi->mac_filter_list_lock);
 +	i40e_del_mac_all_vlan(vsi, netdev->dev_addr, false, true);
 +	i40e_put_mac_in_vlan(vsi, addr->sa_data, false, true);
 +	spin_unlock_bh(&vsi->mac_filter_list_lock);
++=======
+ 	spin_lock_bh(&vsi->mac_filter_hash_lock);
+ 	i40e_del_mac_filter(vsi, netdev->dev_addr);
+ 	i40e_add_mac_filter(vsi, addr->sa_data);
+ 	spin_unlock_bh(&vsi->mac_filter_hash_lock);
++>>>>>>> feffdbe47d6f (i40e: rename i40e_put_mac_in_vlan and i40e_del_mac_all_vlan)
  	ether_addr_copy(netdev->dev_addr, addr->sa_data);
  	if (vsi->type == I40E_VSI_MAIN) {
  		i40e_status ret;
@@@ -1631,6 -1750,43 +1688,46 @@@ static void i40e_vsi_setup_queue_map(st
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_addr_sync - Callback for dev_(mc|uc)_sync to add address
+  * @netdev: the netdevice
+  * @addr: address to add
+  *
+  * Called by __dev_(mc|uc)_sync when an address needs to be added. We call
+  * __dev_(uc|mc)_sync from .set_rx_mode and guarantee to hold the hash lock.
+  */
+ static int i40e_addr_sync(struct net_device *netdev, const u8 *addr)
+ {
+ 	struct i40e_netdev_priv *np = netdev_priv(netdev);
+ 	struct i40e_vsi *vsi = np->vsi;
+ 
+ 	if (i40e_add_mac_filter(vsi, addr))
+ 		return 0;
+ 	else
+ 		return -ENOMEM;
+ }
+ 
+ /**
+  * i40e_addr_unsync - Callback for dev_(mc|uc)_sync to remove address
+  * @netdev: the netdevice
+  * @addr: address to add
+  *
+  * Called by __dev_(mc|uc)_sync when an address needs to be removed. We call
+  * __dev_(uc|mc)_sync from .set_rx_mode and guarantee to hold the hash lock.
+  */
+ static int i40e_addr_unsync(struct net_device *netdev, const u8 *addr)
+ {
+ 	struct i40e_netdev_priv *np = netdev_priv(netdev);
+ 	struct i40e_vsi *vsi = np->vsi;
+ 
+ 	i40e_del_mac_filter(vsi, addr);
+ 
+ 	return 0;
+ }
+ 
+ /**
++>>>>>>> feffdbe47d6f (i40e: rename i40e_put_mac_in_vlan and i40e_del_mac_all_vlan)
   * i40e_set_rx_mode - NDO callback to set the netdev filters
   * @netdev: network interface device structure
   **/
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index 4fb0bfac177f,1859911acf37..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -1938,15 -1941,9 +1938,21 @@@ static int i40e_vc_add_mac_addr_msg(str
  	for (i = 0; i < al->num_elements; i++) {
  		struct i40e_mac_filter *f;
  
++<<<<<<< HEAD
 +		f = i40e_find_mac(vsi, al->list[i].addr, true, false);
 +		if (!f) {
 +			if (i40e_is_vsi_in_vlan(vsi))
 +				f = i40e_put_mac_in_vlan(vsi, al->list[i].addr,
 +							 true, false);
 +			else
 +				f = i40e_add_filter(vsi, al->list[i].addr, -1,
 +						    true, false);
 +		}
++=======
+ 		f = i40e_find_mac(vsi, al->list[i].addr);
+ 		if (!f)
+ 			f = i40e_add_mac_filter(vsi, al->list[i].addr);
++>>>>>>> feffdbe47d6f (i40e: rename i40e_put_mac_in_vlan and i40e_del_mac_all_vlan)
  
  		if (!f) {
  			dev_err(&pf->pdev->dev,
@@@ -2008,12 -2005,12 +2014,16 @@@ static int i40e_vc_del_mac_addr_msg(str
  	}
  	vsi = pf->vsi[vf->lan_vsi_idx];
  
 -	spin_lock_bh(&vsi->mac_filter_hash_lock);
 +	spin_lock_bh(&vsi->mac_filter_list_lock);
  	/* delete addresses from the list */
  	for (i = 0; i < al->num_elements; i++)
++<<<<<<< HEAD
 +		if (i40e_del_mac_all_vlan(vsi, al->list[i].addr, true, false)) {
++=======
+ 		if (i40e_del_mac_filter(vsi, al->list[i].addr)) {
++>>>>>>> feffdbe47d6f (i40e: rename i40e_put_mac_in_vlan and i40e_del_mac_all_vlan)
  			ret = I40E_ERR_INVALID_MAC_ADDR;
 -			spin_unlock_bh(&vsi->mac_filter_hash_lock);
 +			spin_unlock_bh(&vsi->mac_filter_list_lock);
  			goto error_param;
  		} else {
  			vf->num_mac--;
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
