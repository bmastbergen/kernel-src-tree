qed*: Add support for WoL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 14d39648cbfc6289e3f873d30f282b9517ebe860
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/14d39648.failed

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 14d39648cbfc6289e3f873d30f282b9517ebe860)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed.h
#	drivers/net/ethernet/qlogic/qed/qed_main.c
#	drivers/net/ethernet/qlogic/qed/qed_mcp.c
#	drivers/net/ethernet/qlogic/qede/qede.h
#	include/linux/qed/qed_if.h
diff --cc drivers/net/ethernet/qlogic/qed/qed.h
index 653bb5735f0c,8828ffac4b23..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed.h
+++ b/drivers/net/ethernet/qlogic/qed/qed.h
@@@ -226,6 -231,9 +231,12 @@@ struct qed_hw_info 
  	u32				port_mode;
  	u32				hw_mode;
  	unsigned long		device_capabilities;
++<<<<<<< HEAD
++=======
+ 	u16				mtu;
+ 
+ 	enum qed_wol_support b_wol_support;
++>>>>>>> 14d39648cbfc (qed*: Add support for WoL)
  };
  
  struct qed_hw_cid_data {
diff --cc drivers/net/ethernet/qlogic/qed/qed_main.c
index 82cda70ecd7a,b71d73a41b10..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_main.c
@@@ -1425,6 -1437,100 +1429,103 @@@ static int qed_set_led(struct qed_dev *
  	return status;
  }
  
++<<<<<<< HEAD
++=======
+ static int qed_update_wol(struct qed_dev *cdev, bool enabled)
+ {
+ 	struct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);
+ 	struct qed_ptt *ptt;
+ 	int rc = 0;
+ 
+ 	if (IS_VF(cdev))
+ 		return 0;
+ 
+ 	ptt = qed_ptt_acquire(hwfn);
+ 	if (!ptt)
+ 		return -EAGAIN;
+ 
+ 	rc = qed_mcp_ov_update_wol(hwfn, ptt, enabled ? QED_OV_WOL_ENABLED
+ 				   : QED_OV_WOL_DISABLED);
+ 	if (rc)
+ 		goto out;
+ 	rc = qed_mcp_ov_update_current_config(hwfn, ptt, QED_OV_CLIENT_DRV);
+ 
+ out:
+ 	qed_ptt_release(hwfn, ptt);
+ 	return rc;
+ }
+ 
+ static int qed_update_drv_state(struct qed_dev *cdev, bool active)
+ {
+ 	struct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);
+ 	struct qed_ptt *ptt;
+ 	int status = 0;
+ 
+ 	if (IS_VF(cdev))
+ 		return 0;
+ 
+ 	ptt = qed_ptt_acquire(hwfn);
+ 	if (!ptt)
+ 		return -EAGAIN;
+ 
+ 	status = qed_mcp_ov_update_driver_state(hwfn, ptt, active ?
+ 						QED_OV_DRIVER_STATE_ACTIVE :
+ 						QED_OV_DRIVER_STATE_DISABLED);
+ 
+ 	qed_ptt_release(hwfn, ptt);
+ 
+ 	return status;
+ }
+ 
+ static int qed_update_mac(struct qed_dev *cdev, u8 *mac)
+ {
+ 	struct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);
+ 	struct qed_ptt *ptt;
+ 	int status = 0;
+ 
+ 	if (IS_VF(cdev))
+ 		return 0;
+ 
+ 	ptt = qed_ptt_acquire(hwfn);
+ 	if (!ptt)
+ 		return -EAGAIN;
+ 
+ 	status = qed_mcp_ov_update_mac(hwfn, ptt, mac);
+ 	if (status)
+ 		goto out;
+ 
+ 	status = qed_mcp_ov_update_current_config(hwfn, ptt, QED_OV_CLIENT_DRV);
+ 
+ out:
+ 	qed_ptt_release(hwfn, ptt);
+ 	return status;
+ }
+ 
+ static int qed_update_mtu(struct qed_dev *cdev, u16 mtu)
+ {
+ 	struct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);
+ 	struct qed_ptt *ptt;
+ 	int status = 0;
+ 
+ 	if (IS_VF(cdev))
+ 		return 0;
+ 
+ 	ptt = qed_ptt_acquire(hwfn);
+ 	if (!ptt)
+ 		return -EAGAIN;
+ 
+ 	status = qed_mcp_ov_update_mtu(hwfn, ptt, mtu);
+ 	if (status)
+ 		goto out;
+ 
+ 	status = qed_mcp_ov_update_current_config(hwfn, ptt, QED_OV_CLIENT_DRV);
+ 
+ out:
+ 	qed_ptt_release(hwfn, ptt);
+ 	return status;
+ }
+ 
++>>>>>>> 14d39648cbfc (qed*: Add support for WoL)
  static struct qed_selftest_ops qed_selftest_ops_pass = {
  	.selftest_memory = &qed_selftest_memory,
  	.selftest_interrupt = &qed_selftest_interrupt,
@@@ -1460,6 -1566,10 +1561,13 @@@ const struct qed_common_ops qed_common_
  	.get_coalesce = &qed_get_coalesce,
  	.set_coalesce = &qed_set_coalesce,
  	.set_led = &qed_set_led,
++<<<<<<< HEAD
++=======
+ 	.update_drv_state = &qed_update_drv_state,
+ 	.update_mac = &qed_update_mac,
+ 	.update_mtu = &qed_update_mtu,
+ 	.update_wol = &qed_update_wol,
++>>>>>>> 14d39648cbfc (qed*: Add support for WoL)
  };
  
  void qed_get_protocol_stats(struct qed_dev *cdev,
diff --cc drivers/net/ethernet/qlogic/qed/qed_mcp.c
index dae4c0af6504,768b35b1dca0..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@@ -1068,8 -1094,24 +1093,27 @@@ int qed_mcp_fill_shmem_func_info(struc
  
  	info->ovlan = (u16)(shmem_info.ovlan_stag & FUNC_MF_CFG_OV_STAG_MASK);
  
++<<<<<<< HEAD
++=======
+ 	info->mtu = (u16)shmem_info.mtu_size;
+ 
+ 	p_hwfn->hw_info.b_wol_support = QED_WOL_SUPPORT_NONE;
+ 	p_hwfn->cdev->wol_config = (u8)QED_OV_WOL_DEFAULT;
+ 	if (qed_mcp_is_init(p_hwfn)) {
+ 		u32 resp = 0, param = 0;
+ 		int rc;
+ 
+ 		rc = qed_mcp_cmd(p_hwfn, p_ptt,
+ 				 DRV_MSG_CODE_OS_WOL, 0, &resp, &param);
+ 		if (rc)
+ 			return rc;
+ 		if (resp == FW_MSG_CODE_OS_WOL_SUPPORTED)
+ 			p_hwfn->hw_info.b_wol_support = QED_WOL_SUPPORT_PME;
+ 	}
+ 
++>>>>>>> 14d39648cbfc (qed*: Add support for WoL)
  	DP_VERBOSE(p_hwfn, (QED_MSG_SP | NETIF_MSG_IFUP),
- 		   "Read configuration from shmem: pause_on_host %02x protocol %02x BW [%02x - %02x] MAC %02x:%02x:%02x:%02x:%02x:%02x wwn port %llx node %llx ovlan %04x\n",
+ 		   "Read configuration from shmem: pause_on_host %02x protocol %02x BW [%02x - %02x] MAC %02x:%02x:%02x:%02x:%02x:%02x wwn port %llx node %llx ovlan %04x wol %02x\n",
  		info->pause_on_host, info->protocol,
  		info->bandwidth_min, info->bandwidth_max,
  		info->mac[0], info->mac[1], info->mac[2],
@@@ -1223,6 -1266,178 +1268,181 @@@ int qed_mcp_resume(struct qed_hwfn *p_h
  	return (cpu_mode & MCP_REG_CPU_MODE_SOFT_HALT) ? -EAGAIN : 0;
  }
  
++<<<<<<< HEAD
++=======
+ int qed_mcp_ov_update_current_config(struct qed_hwfn *p_hwfn,
+ 				     struct qed_ptt *p_ptt,
+ 				     enum qed_ov_client client)
+ {
+ 	u32 resp = 0, param = 0;
+ 	u32 drv_mb_param;
+ 	int rc;
+ 
+ 	switch (client) {
+ 	case QED_OV_CLIENT_DRV:
+ 		drv_mb_param = DRV_MB_PARAM_OV_CURR_CFG_OS;
+ 		break;
+ 	case QED_OV_CLIENT_USER:
+ 		drv_mb_param = DRV_MB_PARAM_OV_CURR_CFG_OTHER;
+ 		break;
+ 	case QED_OV_CLIENT_VENDOR_SPEC:
+ 		drv_mb_param = DRV_MB_PARAM_OV_CURR_CFG_VENDOR_SPEC;
+ 		break;
+ 	default:
+ 		DP_NOTICE(p_hwfn, "Invalid client type %d\n", client);
+ 		return -EINVAL;
+ 	}
+ 
+ 	rc = qed_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_OV_UPDATE_CURR_CFG,
+ 			 drv_mb_param, &resp, &param);
+ 	if (rc)
+ 		DP_ERR(p_hwfn, "MCP response failure, aborting\n");
+ 
+ 	return rc;
+ }
+ 
+ int qed_mcp_ov_update_driver_state(struct qed_hwfn *p_hwfn,
+ 				   struct qed_ptt *p_ptt,
+ 				   enum qed_ov_driver_state drv_state)
+ {
+ 	u32 resp = 0, param = 0;
+ 	u32 drv_mb_param;
+ 	int rc;
+ 
+ 	switch (drv_state) {
+ 	case QED_OV_DRIVER_STATE_NOT_LOADED:
+ 		drv_mb_param = DRV_MSG_CODE_OV_UPDATE_DRIVER_STATE_NOT_LOADED;
+ 		break;
+ 	case QED_OV_DRIVER_STATE_DISABLED:
+ 		drv_mb_param = DRV_MSG_CODE_OV_UPDATE_DRIVER_STATE_DISABLED;
+ 		break;
+ 	case QED_OV_DRIVER_STATE_ACTIVE:
+ 		drv_mb_param = DRV_MSG_CODE_OV_UPDATE_DRIVER_STATE_ACTIVE;
+ 		break;
+ 	default:
+ 		DP_NOTICE(p_hwfn, "Invalid driver state %d\n", drv_state);
+ 		return -EINVAL;
+ 	}
+ 
+ 	rc = qed_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_OV_UPDATE_DRIVER_STATE,
+ 			 drv_mb_param, &resp, &param);
+ 	if (rc)
+ 		DP_ERR(p_hwfn, "Failed to send driver state\n");
+ 
+ 	return rc;
+ }
+ 
+ int qed_mcp_ov_update_mtu(struct qed_hwfn *p_hwfn,
+ 			  struct qed_ptt *p_ptt, u16 mtu)
+ {
+ 	u32 resp = 0, param = 0;
+ 	u32 drv_mb_param;
+ 	int rc;
+ 
+ 	drv_mb_param = (u32)mtu << DRV_MB_PARAM_OV_MTU_SIZE_SHIFT;
+ 	rc = qed_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_OV_UPDATE_MTU,
+ 			 drv_mb_param, &resp, &param);
+ 	if (rc)
+ 		DP_ERR(p_hwfn, "Failed to send mtu value, rc = %d\n", rc);
+ 
+ 	return rc;
+ }
+ 
+ int qed_mcp_ov_update_mac(struct qed_hwfn *p_hwfn,
+ 			  struct qed_ptt *p_ptt, u8 *mac)
+ {
+ 	struct qed_mcp_mb_params mb_params;
+ 	union drv_union_data union_data;
+ 	int rc;
+ 
+ 	memset(&mb_params, 0, sizeof(mb_params));
+ 	mb_params.cmd = DRV_MSG_CODE_SET_VMAC;
+ 	mb_params.param = DRV_MSG_CODE_VMAC_TYPE_MAC <<
+ 			  DRV_MSG_CODE_VMAC_TYPE_SHIFT;
+ 	mb_params.param |= MCP_PF_ID(p_hwfn);
+ 	ether_addr_copy(&union_data.raw_data[0], mac);
+ 	mb_params.p_data_src = &union_data;
+ 	rc = qed_mcp_cmd_and_union(p_hwfn, p_ptt, &mb_params);
+ 	if (rc)
+ 		DP_ERR(p_hwfn, "Failed to send mac address, rc = %d\n", rc);
+ 
+ 	/* Store primary MAC for later possible WoL */
+ 	memcpy(p_hwfn->cdev->wol_mac, mac, ETH_ALEN);
+ 
+ 	return rc;
+ }
+ 
+ int qed_mcp_ov_update_wol(struct qed_hwfn *p_hwfn,
+ 			  struct qed_ptt *p_ptt, enum qed_ov_wol wol)
+ {
+ 	u32 resp = 0, param = 0;
+ 	u32 drv_mb_param;
+ 	int rc;
+ 
+ 	if (p_hwfn->hw_info.b_wol_support == QED_WOL_SUPPORT_NONE) {
+ 		DP_VERBOSE(p_hwfn, QED_MSG_SP,
+ 			   "Can't change WoL configuration when WoL isn't supported\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	switch (wol) {
+ 	case QED_OV_WOL_DEFAULT:
+ 		drv_mb_param = DRV_MB_PARAM_WOL_DEFAULT;
+ 		break;
+ 	case QED_OV_WOL_DISABLED:
+ 		drv_mb_param = DRV_MB_PARAM_WOL_DISABLED;
+ 		break;
+ 	case QED_OV_WOL_ENABLED:
+ 		drv_mb_param = DRV_MB_PARAM_WOL_ENABLED;
+ 		break;
+ 	default:
+ 		DP_ERR(p_hwfn, "Invalid wol state %d\n", wol);
+ 		return -EINVAL;
+ 	}
+ 
+ 	rc = qed_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_OV_UPDATE_WOL,
+ 			 drv_mb_param, &resp, &param);
+ 	if (rc)
+ 		DP_ERR(p_hwfn, "Failed to send wol mode, rc = %d\n", rc);
+ 
+ 	/* Store the WoL update for a future unload */
+ 	p_hwfn->cdev->wol_config = (u8)wol;
+ 
+ 	return rc;
+ }
+ 
+ int qed_mcp_ov_update_eswitch(struct qed_hwfn *p_hwfn,
+ 			      struct qed_ptt *p_ptt,
+ 			      enum qed_ov_eswitch eswitch)
+ {
+ 	u32 resp = 0, param = 0;
+ 	u32 drv_mb_param;
+ 	int rc;
+ 
+ 	switch (eswitch) {
+ 	case QED_OV_ESWITCH_NONE:
+ 		drv_mb_param = DRV_MB_PARAM_ESWITCH_MODE_NONE;
+ 		break;
+ 	case QED_OV_ESWITCH_VEB:
+ 		drv_mb_param = DRV_MB_PARAM_ESWITCH_MODE_VEB;
+ 		break;
+ 	case QED_OV_ESWITCH_VEPA:
+ 		drv_mb_param = DRV_MB_PARAM_ESWITCH_MODE_VEPA;
+ 		break;
+ 	default:
+ 		DP_ERR(p_hwfn, "Invalid eswitch mode %d\n", eswitch);
+ 		return -EINVAL;
+ 	}
+ 
+ 	rc = qed_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_OV_UPDATE_ESWITCH_MODE,
+ 			 drv_mb_param, &resp, &param);
+ 	if (rc)
+ 		DP_ERR(p_hwfn, "Failed to send eswitch mode, rc = %d\n", rc);
+ 
+ 	return rc;
+ }
+ 
++>>>>>>> 14d39648cbfc (qed*: Add support for WoL)
  int qed_mcp_set_led(struct qed_hwfn *p_hwfn,
  		    struct qed_ptt *p_ptt, enum qed_led_mode mode)
  {
diff --cc drivers/net/ethernet/qlogic/qede/qede.h
index ea44d58691b6,0cba21bf9d5f..000000000000
--- a/drivers/net/ethernet/qlogic/qede/qede.h
+++ b/drivers/net/ethernet/qlogic/qede/qede.h
@@@ -185,6 -192,10 +185,13 @@@ struct qede_dev 
  	unsigned long			sp_flags;
  	u16				vxlan_dst_port;
  	u16				geneve_dst_port;
++<<<<<<< HEAD
++=======
+ 
+ 	bool wol_enabled;
+ 
+ 	struct qede_rdma_dev		rdma_info;
++>>>>>>> 14d39648cbfc (qed*: Add support for WoL)
  };
  
  enum QEDE_STATE {
diff --cc include/linux/qed/qed_if.h
index 2b9c21bc615a,ea095b4893aa..000000000000
--- a/include/linux/qed/qed_if.h
+++ b/include/linux/qed/qed_if.h
@@@ -268,6 -266,10 +268,13 @@@ struct qed_dev_info 
  	u32		flash_size;
  	u8		mf_mode;
  	bool		tx_switching;
++<<<<<<< HEAD
++=======
+ 	bool		rdma_supported;
+ 	u16		mtu;
+ 
+ 	bool wol_support;
++>>>>>>> 14d39648cbfc (qed*: Add support for WoL)
  };
  
  enum qed_sb_type {
@@@ -564,6 -566,41 +571,44 @@@ struct qed_common_ops 
   */
  	int (*set_led)(struct qed_dev *cdev,
  		       enum qed_led_mode mode);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * @brief update_drv_state - API to inform the change in the driver state.
+  *
+  * @param cdev
+  * @param active
+  *
+  */
+ 	int (*update_drv_state)(struct qed_dev *cdev, bool active);
+ 
+ /**
+  * @brief update_mac - API to inform the change in the mac address
+  *
+  * @param cdev
+  * @param mac
+  *
+  */
+ 	int (*update_mac)(struct qed_dev *cdev, u8 *mac);
+ 
+ /**
+  * @brief update_mtu - API to inform the change in the mtu
+  *
+  * @param cdev
+  * @param mtu
+  *
+  */
+ 	int (*update_mtu)(struct qed_dev *cdev, u16 mtu);
+ 
+ /**
+  * @brief update_wol - update of changes in the WoL configuration
+  *
+  * @param cdev
+  * @param enabled - true iff WoL should be enabled.
+  */
+ 	int (*update_wol) (struct qed_dev *cdev, bool enabled);
++>>>>>>> 14d39648cbfc (qed*: Add support for WoL)
  };
  
  #define MASK_FIELD(_name, _value) \
* Unmerged path drivers/net/ethernet/qlogic/qed/qed.h
diff --git a/drivers/net/ethernet/qlogic/qed/qed_dev.c b/drivers/net/ethernet/qlogic/qed/qed_dev.c
index 433f552af2d1..80fa503d13ac 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@ -1339,8 +1339,24 @@ int qed_hw_reset(struct qed_dev *cdev)
 {
 	int rc = 0;
 	u32 unload_resp, unload_param;
+	u32 wol_param;
 	int i;
 
+	switch (cdev->wol_config) {
+	case QED_OV_WOL_DISABLED:
+		wol_param = DRV_MB_PARAM_UNLOAD_WOL_DISABLED;
+		break;
+	case QED_OV_WOL_ENABLED:
+		wol_param = DRV_MB_PARAM_UNLOAD_WOL_ENABLED;
+		break;
+	default:
+		DP_NOTICE(cdev,
+			  "Unknown WoL configuration %02x\n", cdev->wol_config);
+		/* Fallthrough */
+	case QED_OV_WOL_DEFAULT:
+		wol_param = DRV_MB_PARAM_UNLOAD_WOL_MCP;
+	}
+
 	for_each_hwfn(cdev, i) {
 		struct qed_hwfn *p_hwfn = &cdev->hwfns[i];
 
@@ -1369,8 +1385,7 @@ int qed_hw_reset(struct qed_dev *cdev)
 
 		/* Send unload command to MCP */
 		rc = qed_mcp_cmd(p_hwfn, p_hwfn->p_main_ptt,
-				 DRV_MSG_CODE_UNLOAD_REQ,
-				 DRV_MB_PARAM_UNLOAD_WOL_MCP,
+				 DRV_MSG_CODE_UNLOAD_REQ, wol_param,
 				 &unload_resp, &unload_param);
 		if (rc) {
 			DP_NOTICE(p_hwfn, "qed_hw_reset: UNLOAD_REQ failed\n");
diff --git a/drivers/net/ethernet/qlogic/qed/qed_hsi.h b/drivers/net/ethernet/qlogic/qed/qed_hsi.h
index 3601aad5e229..bea685080fc8 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_hsi.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_hsi.h
@@ -8585,6 +8585,7 @@ struct public_drv_mb {
 
 #define DRV_MSG_CODE_BIST_TEST			0x001e0000
 #define DRV_MSG_CODE_SET_LED_MODE		0x00200000
+#define DRV_MSG_CODE_OS_WOL			0x002e0000
 
 #define DRV_MSG_SEQ_NUMBER_MASK			0x0000ffff
 
@@ -8640,6 +8641,9 @@ struct public_drv_mb {
 #define FW_MSG_CODE_NVM_OK			0x00010000
 #define FW_MSG_CODE_OK				0x00160000
 
+#define FW_MSG_CODE_OS_WOL_SUPPORTED            0x00800000
+#define FW_MSG_CODE_OS_WOL_NOT_SUPPORTED        0x00810000
+
 #define FW_MSG_SEQ_NUMBER_MASK			0x0000ffff
 
 	u32 fw_mb_param;
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_main.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_mcp.c
* Unmerged path drivers/net/ethernet/qlogic/qede/qede.h
diff --git a/drivers/net/ethernet/qlogic/qede/qede_ethtool.c b/drivers/net/ethernet/qlogic/qede/qede_ethtool.c
index 5c79562ef32c..1e90ccd8e637 100644
--- a/drivers/net/ethernet/qlogic/qede/qede_ethtool.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_ethtool.c
@@ -490,6 +490,45 @@ static void qede_get_drvinfo(struct net_device *ndev,
 	strlcpy(info->bus_info, pci_name(edev->pdev), sizeof(info->bus_info));
 }
 
+static void qede_get_wol(struct net_device *ndev, struct ethtool_wolinfo *wol)
+{
+	struct qede_dev *edev = netdev_priv(ndev);
+
+	if (edev->dev_info.common.wol_support) {
+		wol->supported = WAKE_MAGIC;
+		wol->wolopts = edev->wol_enabled ? WAKE_MAGIC : 0;
+	}
+}
+
+static int qede_set_wol(struct net_device *ndev, struct ethtool_wolinfo *wol)
+{
+	struct qede_dev *edev = netdev_priv(ndev);
+	bool wol_requested;
+	int rc;
+
+	if (wol->wolopts & ~WAKE_MAGIC) {
+		DP_INFO(edev,
+			"Can't support WoL options other than magic-packet\n");
+		return -EINVAL;
+	}
+
+	wol_requested = !!(wol->wolopts & WAKE_MAGIC);
+	if (wol_requested == edev->wol_enabled)
+		return 0;
+
+	/* Need to actually change configuration */
+	if (!edev->dev_info.common.wol_support) {
+		DP_INFO(edev, "Device doesn't support WoL\n");
+		return -EINVAL;
+	}
+
+	rc = edev->ops->common->update_wol(edev->cdev, wol_requested);
+	if (!rc)
+		edev->wol_enabled = wol_requested;
+
+	return rc;
+}
+
 static u32 qede_get_msglevel(struct net_device *ndev)
 {
 	struct qede_dev *edev = netdev_priv(ndev);
@@ -1462,6 +1501,8 @@ static const struct ethtool_ops qede_ethtool_ops = {
 	.get_drvinfo = qede_get_drvinfo,
 	.get_regs_len = qede_get_regs_len,
 	.get_regs = qede_get_regs,
+	.get_wol = qede_get_wol,
+	.set_wol = qede_set_wol,
 	.get_msglevel = qede_get_msglevel,
 	.set_msglevel = qede_set_msglevel,
 	.nway_reset = qede_nway_reset,
diff --git a/drivers/net/ethernet/qlogic/qede/qede_main.c b/drivers/net/ethernet/qlogic/qede/qede_main.c
index fedf74d77512..464896b5ff11 100644
--- a/drivers/net/ethernet/qlogic/qede/qede_main.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_main.c
@@ -100,6 +100,7 @@ static int qede_probe(struct pci_dev *pdev, const struct pci_device_id *id);
 #define TX_TIMEOUT		(5 * HZ)
 
 static void qede_remove(struct pci_dev *pdev);
+static void qede_shutdown(struct pci_dev *pdev);
 static int qede_alloc_rx_buffer(struct qede_dev *edev,
 				struct qede_rx_queue *rxq);
 static void qede_link_update(void *dev, struct qed_link_output *link);
@@ -167,6 +168,7 @@ static struct pci_driver qede_pci_driver = {
 	.id_table = qede_pci_tbl,
 	.probe = qede_probe,
 	.remove = qede_remove,
+	.shutdown = qede_shutdown,
 #ifdef CONFIG_QED_SRIOV
 	.sriov_configure = qede_sriov_configure,
 #endif
@@ -2652,6 +2654,8 @@ static void __qede_remove(struct pci_dev *pdev, enum qede_remove_mode mode)
 
 	/* Use global ops since we've freed edev */
 	qed_ops->common->slowpath_stop(cdev);
+	if (system_state == SYSTEM_POWER_OFF)
+		return;
 	qed_ops->common->remove(cdev);
 
 	pr_notice("Ending successfully qede_remove\n");
@@ -2662,6 +2666,11 @@ static void qede_remove(struct pci_dev *pdev)
 	__qede_remove(pdev, QEDE_REMOVE_NORMAL);
 }
 
+static void qede_shutdown(struct pci_dev *pdev)
+{
+	__qede_remove(pdev, QEDE_REMOVE_NORMAL);
+}
+
 /* -------------------------------------------------------------------------
  * START OF LOAD / UNLOAD
  * -------------------------------------------------------------------------
* Unmerged path include/linux/qed/qed_if.h
