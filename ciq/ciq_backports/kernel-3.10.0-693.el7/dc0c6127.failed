perf record: Add switch-output size option argument

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jiri Olsa <jolsa@kernel.org>
commit dc0c6127c231d4d264570497a916fa19740c915b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/dc0c6127.failed

It's now possible to specify the threshold size for perf.data like:

  $ perf record --switch-output=2G ...

Once it's reached, the current data are dumped in to the
perf.data.<timestamp> file and session does on.

  $ perf record --switch-output=2G ...
  [ perf record: dump data: Woken up 7244 times ]
  [ perf record: Dump perf.data.2017010214093746 ]
  ...

The size is expected to be a number with appended unit character -
B/K/M/G.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Acked-by: Wang Nan <wangnan0@huawei.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1483955520-29063-5-git-send-email-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit dc0c6127c231d4d264570497a916fa19740c915b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-record.txt
#	tools/perf/builtin-record.c
diff --cc tools/perf/Documentation/perf-record.txt
index 37473e1c67b6,3d55d2fd48b3..000000000000
--- a/tools/perf/Documentation/perf-record.txt
+++ b/tools/perf/Documentation/perf-record.txt
@@@ -331,6 -418,60 +331,63 @@@ Configure all used events to run in ker
  --all-user::
  Configure all used events to run in user space.
  
++<<<<<<< HEAD
++=======
+ --timestamp-filename
+ Append timestamp to output file name.
+ 
+ --switch-output[=mode]::
+ Generate multiple perf.data files, timestamp prefixed, switching to a new one
+ based on 'mode' value:
+   "signal" - when receiving a SIGUSR2 (default value) or
+   <size>   - when reaching the size threshold, size is expected to
+              be a number with appended unit character - B/K/M/G
+ 
+              Note: the precision of  the size  threshold  hugely depends
+              on your configuration  - the number and size of  your  ring
+              buffers (-m). It is generally more precise for higher sizes
+              (like >5M), for lower values expect different sizes.
+ 
+ A possible use case is to, given an external event, slice the perf.data file
+ that gets then processed, possibly via a perf script, to decide if that
+ particular perf.data snapshot should be kept or not.
+ 
+ Implies --timestamp-filename, --no-buildid and --no-buildid-cache.
+ The reason for the latter two is to reduce the data file switching
+ overhead. You can still switch them on with:
+ 
+   --switch-output --no-no-buildid  --no-no-buildid-cache
+ 
+ --dry-run::
+ Parse options then exit. --dry-run can be used to detect errors in cmdline
+ options.
+ 
+ 'perf record --dry-run -e' can act as a BPF script compiler if llvm.dump-obj
+ in config file is set to true.
+ 
+ --tail-synthesize::
+ Instead of collecting non-sample events (for example, fork, comm, mmap) at
+ the beginning of record, collect them during finalizing an output file.
+ The collected non-sample events reflects the status of the system when
+ record is finished.
+ 
+ --overwrite::
+ Makes all events use an overwritable ring buffer. An overwritable ring
+ buffer works like a flight recorder: when it gets full, the kernel will
+ overwrite the oldest records, that thus will never make it to the
+ perf.data file.
+ 
+ When '--overwrite' and '--switch-output' are used perf records and drops
+ events until it receives a signal, meaning that something unusual was
+ detected that warrants taking a snapshot of the most current events,
+ those fitting in the ring buffer at that moment.
+ 
+ 'overwrite' attribute can also be set or canceled for an event using
+ config terms. For example: 'cycles/overwrite/' and 'instructions/no-overwrite/'.
+ 
+ Implies --tail-synthesize.
+ 
++>>>>>>> dc0c6127c231 (perf record: Add switch-output size option argument)
  SEE ALSO
  --------
  linkperf:perf-stat[1], linkperf:perf-list[1]
diff --cc tools/perf/builtin-record.c
index 6cb1cbb83a86,3fa64492ee62..000000000000
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@@ -41,6 -46,14 +41,17 @@@
  #include <asm/bug.h>
  #include <linux/time64.h>
  
++<<<<<<< HEAD
++=======
+ struct switch_output {
+ 	bool		 enabled;
+ 	bool		 signal;
+ 	unsigned long	 size;
+ 	const char	*str;
+ 	bool		 set;
+ };
+ 
++>>>>>>> dc0c6127c231 (perf record: Add switch-output size option argument)
  struct record {
  	struct perf_tool	tool;
  	struct record_opts	opts;
@@@ -187,45 -222,6 +219,48 @@@ static volatile int done
  static volatile int signr = -1;
  static volatile int child_finished;
  
++<<<<<<< HEAD
 +static volatile enum {
 +	AUXTRACE_SNAPSHOT_OFF = -1,
 +	AUXTRACE_SNAPSHOT_DISABLED = 0,
 +	AUXTRACE_SNAPSHOT_ENABLED = 1,
 +} auxtrace_snapshot_state = AUXTRACE_SNAPSHOT_OFF;
 +
 +static inline void
 +auxtrace_snapshot_on(void)
 +{
 +	auxtrace_snapshot_state = AUXTRACE_SNAPSHOT_DISABLED;
 +}
 +
 +static inline void
 +auxtrace_snapshot_enable(void)
 +{
 +	if (auxtrace_snapshot_state == AUXTRACE_SNAPSHOT_OFF)
 +		return;
 +	auxtrace_snapshot_state = AUXTRACE_SNAPSHOT_ENABLED;
 +}
 +
 +static inline void
 +auxtrace_snapshot_disable(void)
 +{
 +	if (auxtrace_snapshot_state == AUXTRACE_SNAPSHOT_OFF)
 +		return;
 +	auxtrace_snapshot_state = AUXTRACE_SNAPSHOT_DISABLED;
 +}
 +
 +static inline bool
 +auxtrace_snapshot_is_enabled(void)
 +{
 +	if (auxtrace_snapshot_state == AUXTRACE_SNAPSHOT_OFF)
 +		return false;
 +	return auxtrace_snapshot_state == AUXTRACE_SNAPSHOT_ENABLED;
 +}
 +
 +static volatile int auxtrace_snapshot_err;
 +static volatile int auxtrace_record__snapshot_started;
 +
++=======
++>>>>>>> dc0c6127c231 (perf record: Add switch-output size option argument)
  static void sig_handler(int sig)
  {
  	if (sig == SIGCHLD)
@@@ -811,10 -865,14 +846,19 @@@ static int __cmd_record(struct record *
  	signal(SIGCHLD, sig_handler);
  	signal(SIGINT, sig_handler);
  	signal(SIGTERM, sig_handler);
 -	signal(SIGSEGV, sigsegv_handler);
  
++<<<<<<< HEAD
 +	if (rec->opts.auxtrace_snapshot_mode) {
 +		signal(SIGUSR2, snapshot_sig_handler);
 +		auxtrace_snapshot_on();
++=======
+ 	if (rec->opts.auxtrace_snapshot_mode || rec->switch_output.enabled) {
+ 		signal(SIGUSR2, snapshot_sig_handler);
+ 		if (rec->opts.auxtrace_snapshot_mode)
+ 			trigger_on(&auxtrace_snapshot_trigger);
+ 		if (rec->switch_output.enabled)
+ 			trigger_on(&switch_output_trigger);
++>>>>>>> dc0c6127c231 (perf record: Add switch-output size option argument)
  	} else {
  		signal(SIGUSR2, SIG_IGN);
  	}
@@@ -1167,6 -1377,42 +1211,45 @@@ out_free
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int switch_output_setup(struct record *rec)
+ {
+ 	struct switch_output *s = &rec->switch_output;
+ 	static struct parse_tag tags_size[] = {
+ 		{ .tag  = 'B', .mult = 1       },
+ 		{ .tag  = 'K', .mult = 1 << 10 },
+ 		{ .tag  = 'M', .mult = 1 << 20 },
+ 		{ .tag  = 'G', .mult = 1 << 30 },
+ 		{ .tag  = 0 },
+ 	};
+ 	unsigned long val;
+ 
+ 	if (!s->set)
+ 		return 0;
+ 
+ 	if (!strcmp(s->str, "signal")) {
+ 		s->signal = true;
+ 		pr_debug("switch-output with SIGUSR2 signal\n");
+ 		goto enabled;
+ 	}
+ 
+ 	val = parse_tag_value(s->str, tags_size);
+ 	if (val != (unsigned long) -1) {
+ 		s->size = val;
+ 		pr_debug("switch-output with %s size threshold\n", s->str);
+ 		goto enabled;
+ 	}
+ 
+ 	return -1;
+ 
+ enabled:
+ 	rec->timestamp_filename = true;
+ 	s->enabled              = true;
+ 	return 0;
+ }
+ 
++>>>>>>> dc0c6127c231 (perf record: Add switch-output size option argument)
  static const char * const __record_usage[] = {
  	"perf record [<options>] [<command>]",
  	"perf record [<options>] -- <command> [<options>]",
@@@ -1319,6 -1580,12 +1402,15 @@@ static struct option __record_options[
  		    "Record build-id of all DSOs regardless of hits"),
  	OPT_BOOLEAN(0, "timestamp-filename", &record.timestamp_filename,
  		    "append timestamp to output filename"),
++<<<<<<< HEAD
++=======
+ 	OPT_STRING_OPTARG_SET(0, "switch-output", &record.switch_output.str,
+ 			  &record.switch_output.set, "signal,size",
+ 			  "Switch output when receive SIGUSR2 or cross size threshold",
+ 			  "signal"),
+ 	OPT_BOOLEAN(0, "dry-run", &dry_run,
+ 		    "Parse options then exit"),
++>>>>>>> dc0c6127c231 (perf record: Add switch-output size option argument)
  	OPT_END()
  };
  
@@@ -1360,6 -1641,11 +1452,14 @@@ int cmd_record(int argc, const char **a
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (switch_output_setup(rec)) {
+ 		parse_options_usage(record_usage, record_options, "switch-output", 0);
+ 		return -EINVAL;
+ 	}
+ 
++>>>>>>> dc0c6127c231 (perf record: Add switch-output size option argument)
  	if (!rec->itr) {
  		rec->itr = auxtrace_record__init(rec->evlist, &err);
  		if (err)
@@@ -1385,8 -1692,39 +1485,42 @@@
  "If some relocation was applied (e.g. kexec) symbols may be misresolved\n"
  "even with a suitable vmlinux or kallsyms file.\n\n");
  
 -	if (rec->no_buildid_cache || rec->no_buildid) {
 +	if (rec->no_buildid_cache || rec->no_buildid)
  		disable_buildid_cache();
++<<<<<<< HEAD
++=======
+ 	} else if (rec->switch_output.enabled) {
+ 		/*
+ 		 * In 'perf record --switch-output', disable buildid
+ 		 * generation by default to reduce data file switching
+ 		 * overhead. Still generate buildid if they are required
+ 		 * explicitly using
+ 		 *
+ 		 *  perf record --switch-output --no-no-buildid \
+ 		 *              --no-no-buildid-cache
+ 		 *
+ 		 * Following code equals to:
+ 		 *
+ 		 * if ((rec->no_buildid || !rec->no_buildid_set) &&
+ 		 *     (rec->no_buildid_cache || !rec->no_buildid_cache_set))
+ 		 *         disable_buildid_cache();
+ 		 */
+ 		bool disable = true;
+ 
+ 		if (rec->no_buildid_set && !rec->no_buildid)
+ 			disable = false;
+ 		if (rec->no_buildid_cache_set && !rec->no_buildid_cache)
+ 			disable = false;
+ 		if (disable) {
+ 			rec->no_buildid = true;
+ 			rec->no_buildid_cache = true;
+ 			disable_buildid_cache();
+ 		}
+ 	}
+ 
+ 	if (record.opts.overwrite)
+ 		record.opts.tail_synthesize = true;
++>>>>>>> dc0c6127c231 (perf record: Add switch-output size option argument)
  
  	if (rec->evlist->nr_entries == 0 &&
  	    perf_evlist__add_default(rec->evlist) < 0) {
@@@ -1448,9 -1786,15 +1582,23 @@@ out
  
  static void snapshot_sig_handler(int sig __maybe_unused)
  {
++<<<<<<< HEAD
 +	if (!auxtrace_snapshot_is_enabled())
 +		return;
 +	auxtrace_snapshot_disable();
 +	auxtrace_snapshot_err = auxtrace_record__snapshot_start(record.itr);
 +	auxtrace_record__snapshot_started = 1;
++=======
+ 	struct record *rec = &record;
+ 
+ 	if (trigger_is_ready(&auxtrace_snapshot_trigger)) {
+ 		trigger_hit(&auxtrace_snapshot_trigger);
+ 		auxtrace_record__snapshot_started = 1;
+ 		if (auxtrace_record__snapshot_start(record.itr))
+ 			trigger_error(&auxtrace_snapshot_trigger);
+ 	}
+ 
+ 	if (switch_output_signal(rec))
+ 		trigger_hit(&switch_output_trigger);
++>>>>>>> dc0c6127c231 (perf record: Add switch-output size option argument)
  }
* Unmerged path tools/perf/Documentation/perf-record.txt
* Unmerged path tools/perf/builtin-record.c
