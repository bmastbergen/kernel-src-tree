debugobjects: Scale thresholds with # of CPUs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Waiman Long <longman@redhat.com>
commit 97dd552eb23c83dbf626a6e84666c7e281375d47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/97dd552e.failed

On a large SMP systems with hundreds of CPUs, the current thresholds
for allocating and freeing debug objects (256 and 1024 respectively)
may not work well. This can cause a lot of needless calls to
kmem_aloc() and kmem_free() on those systems.

To alleviate this thrashing problem, the object freeing threshold
is now increased to "1024 + # of CPUs * 32". Whereas the object
allocation threshold is increased to "256 + # of CPUs * 4". That
should make the debug objects subsystem scale better with the number
of CPUs available in the system.

	Signed-off-by: Waiman Long <longman@redhat.com>
	Cc: Christian Borntraeger <borntraeger@de.ibm.com>
	Cc: "Du Changbin" <changbin.du@intel.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Jan Stancek <jstancek@redhat.com>
Link: http://lkml.kernel.org/r/1483647425-4135-3-git-send-email-longman@redhat.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 97dd552eb23c83dbf626a6e84666c7e281375d47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/debugobjects.c
diff --cc lib/debugobjects.c
index 0d4f195d791d,dc78217b2199..000000000000
--- a/lib/debugobjects.c
+++ b/lib/debugobjects.c
@@@ -203,8 -209,8 +206,13 @@@ static void free_object(struct debug_ob
  	 * schedule work when the pool is filled and the cache is
  	 * initialized:
  	 */
++<<<<<<< HEAD
 +	if (obj_pool_free > ODEBUG_POOL_SIZE && obj_cache)
 +		sched = keventd_up() && !work_pending(&debug_obj_work);
++=======
+ 	if (obj_pool_free > debug_objects_pool_size && obj_cache)
+ 		sched = 1;
++>>>>>>> 97dd552eb23c (debugobjects: Scale thresholds with # of CPUs)
  	hlist_add_head(&obj->node, &obj_pool);
  	obj_pool_free++;
  	obj_pool_used--;
@@@ -1092,7 -1126,14 +1100,14 @@@ void __init debug_objects_mem_init(void
  		debug_objects_enabled = 0;
  		if (obj_cache)
  			kmem_cache_destroy(obj_cache);
 -		pr_warn("out of memory.\n");
 +		printk(KERN_WARNING "ODEBUG: out of memory.\n");
  	} else
  		debug_objects_selftest();
+ 
+ 	/*
+ 	 * Increase the thresholds for allocating and freeing objects
+ 	 * according to the number of possible CPUs available in the system.
+ 	 */
+ 	debug_objects_pool_size += num_possible_cpus() * 32;
+ 	debug_objects_pool_min_level += num_possible_cpus() * 4;
  }
* Unmerged path lib/debugobjects.c
