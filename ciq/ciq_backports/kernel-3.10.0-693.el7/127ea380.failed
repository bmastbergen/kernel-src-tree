net/mlx5: Add Representors registration API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Add Representors registration API (Don Dutile) [1383788 1417284]
Rebuild_FUZZ: 95.12%
commit-author Hadar Hen Zion <hadarh@mellanox.com>
commit 127ea380acc9de16c2cbd57ed99475944c9917ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/127ea380.failed

Introduce E-Switch registration/unregister representors functions.

Those functions are called by the mlx5e driver when the PF NIC is
created upon pci probe action regardless of the E-Switch mode (NONE,
LEGACY or OFFLOADS).

Adding basic E-Switch database that will hold the vport represntors
upon creation.

This patch doesn't add any new functionality.

	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 127ea380acc9de16c2cbd57ed99475944c9917ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 5eea7e35421a,081259a4edc0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -455,26 -492,96 +455,57 @@@ struct mlx5e_vlan_db 
  	bool          filter_disabled;
  };
  
 -struct mlx5e_l2_table {
 -	struct mlx5e_flow_table    ft;
 -	struct hlist_head          netdev_uc[MLX5E_L2_ADDR_HASH_SIZE];
 -	struct hlist_head          netdev_mc[MLX5E_L2_ADDR_HASH_SIZE];
 -	struct mlx5e_l2_rule	   broadcast;
 -	struct mlx5e_l2_rule	   allmulti;
 -	struct mlx5e_l2_rule	   promisc;
 -	bool                       broadcast_enabled;
 -	bool                       allmulti_enabled;
 -	bool                       promisc_enabled;
 -};
 -
 -/* L3/L4 traffic type classifier */
 -struct mlx5e_ttc_table {
 -	struct mlx5e_flow_table  ft;
 -	struct mlx5_flow_rule	 *rules[MLX5E_NUM_TT];
 -};
 -
 -#define ARFS_HASH_SHIFT BITS_PER_BYTE
 -#define ARFS_HASH_SIZE BIT(BITS_PER_BYTE)
 -struct arfs_table {
 -	struct mlx5e_flow_table  ft;
 -	struct mlx5_flow_rule    *default_rule;
 -	struct hlist_head	 rules_hash[ARFS_HASH_SIZE];
 -};
 -
 -enum  arfs_type {
 -	ARFS_IPV4_TCP,
 -	ARFS_IPV6_TCP,
 -	ARFS_IPV4_UDP,
 -	ARFS_IPV6_UDP,
 -	ARFS_NUM_TYPES,
 -};
 -
 -struct mlx5e_arfs_tables {
 -	struct arfs_table arfs_tables[ARFS_NUM_TYPES];
 -	/* Protect aRFS rules list */
 -	spinlock_t                     arfs_lock;
 -	struct list_head               rules;
 -	int                            last_filter_id;
 -	struct workqueue_struct        *wq;
 +struct mlx5e_vxlan_db {
 +	spinlock_t			lock; /* protect vxlan table */
 +	struct radix_tree_root		tree;
  };
  
 -/* NIC prio FTS */
 -enum {
 -	MLX5E_VLAN_FT_LEVEL = 0,
 -	MLX5E_L2_FT_LEVEL,
 -	MLX5E_TTC_FT_LEVEL,
 -	MLX5E_ARFS_FT_LEVEL
 +struct mlx5e_flow_table {
 +	int num_groups;
 +	struct mlx5_flow_table		*t;
 +	struct mlx5_flow_group		**g;
  };
  
 -struct mlx5e_flow_steering {
 -	struct mlx5_flow_namespace      *ns;
 -	struct mlx5e_tc_table           tc;
 -	struct mlx5e_vlan_table         vlan;
 -	struct mlx5e_l2_table           l2;
 -	struct mlx5e_ttc_table          ttc;
 -	struct mlx5e_arfs_tables        arfs;
 +struct mlx5e_flow_tables {
 +	struct mlx5_flow_namespace	*ns;
 +	struct mlx5e_flow_table		vlan;
 +	struct mlx5e_flow_table		main;
  };
  
 -struct mlx5e_rqt {
 +struct mlx5e_direct_tir {
 +	u32              tirn;
  	u32              rqtn;
++<<<<<<< HEAD
++=======
+ 	bool		 enabled;
+ };
+ 
+ struct mlx5e_tir {
+ 	u32		  tirn;
+ 	struct mlx5e_rqt  rqt;
+ 	struct list_head  list;
+ };
+ 
+ enum {
+ 	MLX5E_TC_PRIO = 0,
+ 	MLX5E_NIC_PRIO
+ };
+ 
+ struct mlx5e_profile {
+ 	void	(*init)(struct mlx5_core_dev *mdev,
+ 			struct net_device *netdev,
+ 			const struct mlx5e_profile *profile, void *ppriv);
+ 	void	(*cleanup)(struct mlx5e_priv *priv);
+ 	int	(*init_rx)(struct mlx5e_priv *priv);
+ 	void	(*cleanup_rx)(struct mlx5e_priv *priv);
+ 	int	(*init_tx)(struct mlx5e_priv *priv);
+ 	void	(*cleanup_tx)(struct mlx5e_priv *priv);
+ 	void	(*enable)(struct mlx5e_priv *priv);
+ 	void	(*disable)(struct mlx5e_priv *priv);
+ 	void	(*update_stats)(struct mlx5e_priv *priv);
+ 	int	(*max_nch)(struct mlx5_core_dev *mdev);
+ 	int	max_tc;
++>>>>>>> 127ea380acc9 (net/mlx5: Add Representors registration API)
  };
  
  struct mlx5e_priv {
@@@ -517,6 -617,8 +548,11 @@@
  	struct mlx5e_stats         stats;
  	struct mlx5e_tstamp        tstamp;
  	u16 q_counter;
++<<<<<<< HEAD
++=======
+ 	const struct mlx5e_profile *profile;
+ 	void                      *ppriv;
++>>>>>>> 127ea380acc9 (net/mlx5: Add Representors registration API)
  };
  
  enum mlx5e_link_mode {
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 0c9d38242297,2c9e45893316..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2743,9 -2878,10 +2743,16 @@@ void mlx5e_set_rx_cq_mode_params(struc
  			MLX5E_PARAMS_DEFAULT_RX_CQ_MODERATION_USEC_FROM_CQE;
  }
  
++<<<<<<< HEAD
 +static void mlx5e_build_netdev_priv(struct mlx5_core_dev *mdev,
 +				    struct net_device *netdev,
 +				    int num_channels)
++=======
+ static void mlx5e_build_nic_netdev_priv(struct mlx5_core_dev *mdev,
+ 					struct net_device *netdev,
+ 					const struct mlx5e_profile *profile,
+ 					void *ppriv)
++>>>>>>> 127ea380acc9 (net/mlx5: Add Representors registration API)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
  	u32 link_speed = 0;
@@@ -2822,7 -2961,9 +2829,13 @@@
  
  	priv->mdev                         = mdev;
  	priv->netdev                       = netdev;
++<<<<<<< HEAD
 +	priv->params.num_channels          = num_channels;
++=======
+ 	priv->params.num_channels          = profile->max_nch(mdev);
+ 	priv->profile                      = profile;
+ 	priv->ppriv                        = ppriv;
++>>>>>>> 127ea380acc9 (net/mlx5: Add Representors registration API)
  
  #ifdef CONFIG_MLX5_CORE_EN_DCB
  	mlx5e_ets_init(priv);
@@@ -2999,7 -3126,159 +3012,163 @@@ static int mlx5e_create_umr_mkey(struc
  	return err;
  }
  
++<<<<<<< HEAD
 +static void *mlx5e_create_netdev(struct mlx5_core_dev *mdev)
++=======
+ static void mlx5e_nic_init(struct mlx5_core_dev *mdev,
+ 			   struct net_device *netdev,
+ 			   const struct mlx5e_profile *profile,
+ 			   void *ppriv)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	mlx5e_build_nic_netdev_priv(mdev, netdev, profile, ppriv);
+ 	mlx5e_build_nic_netdev(netdev);
+ 	mlx5e_vxlan_init(priv);
+ }
+ 
+ static void mlx5e_nic_cleanup(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	mlx5e_vxlan_cleanup(priv);
+ 
+ 	if (MLX5_CAP_GEN(mdev, vport_group_manager))
+ 		mlx5_eswitch_unregister_vport_rep(esw, 0);
+ }
+ 
+ static int mlx5e_init_nic_rx(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	int err;
+ 	int i;
+ 
+ 	err = mlx5e_create_indirect_rqts(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create indirect rqts failed, %d\n", err);
+ 		return err;
+ 	}
+ 
+ 	err = mlx5e_create_direct_rqts(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create direct rqts failed, %d\n", err);
+ 		goto err_destroy_indirect_rqts;
+ 	}
+ 
+ 	err = mlx5e_create_indirect_tirs(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create indirect tirs failed, %d\n", err);
+ 		goto err_destroy_direct_rqts;
+ 	}
+ 
+ 	err = mlx5e_create_direct_tirs(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create direct tirs failed, %d\n", err);
+ 		goto err_destroy_indirect_tirs;
+ 	}
+ 
+ 	err = mlx5e_create_flow_steering(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create flow steering failed, %d\n", err);
+ 		goto err_destroy_direct_tirs;
+ 	}
+ 
+ 	err = mlx5e_tc_init(priv);
+ 	if (err)
+ 		goto err_destroy_flow_steering;
+ 
+ 	return 0;
+ 
+ err_destroy_flow_steering:
+ 	mlx5e_destroy_flow_steering(priv);
+ err_destroy_direct_tirs:
+ 	mlx5e_destroy_direct_tirs(priv);
+ err_destroy_indirect_tirs:
+ 	mlx5e_destroy_indirect_tirs(priv);
+ err_destroy_direct_rqts:
+ 	for (i = 0; i < priv->profile->max_nch(mdev); i++)
+ 		mlx5e_destroy_rqt(priv, &priv->direct_tir[i].rqt);
+ err_destroy_indirect_rqts:
+ 	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
+ 	return err;
+ }
+ 
+ static void mlx5e_cleanup_nic_rx(struct mlx5e_priv *priv)
+ {
+ 	int i;
+ 
+ 	mlx5e_tc_cleanup(priv);
+ 	mlx5e_destroy_flow_steering(priv);
+ 	mlx5e_destroy_direct_tirs(priv);
+ 	mlx5e_destroy_indirect_tirs(priv);
+ 	for (i = 0; i < priv->profile->max_nch(priv->mdev); i++)
+ 		mlx5e_destroy_rqt(priv, &priv->direct_tir[i].rqt);
+ 	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
+ }
+ 
+ static int mlx5e_init_nic_tx(struct mlx5e_priv *priv)
+ {
+ 	int err;
+ 
+ 	err = mlx5e_create_tises(priv);
+ 	if (err) {
+ 		mlx5_core_warn(priv->mdev, "create tises failed, %d\n", err);
+ 		return err;
+ 	}
+ 
+ #ifdef CONFIG_MLX5_CORE_EN_DCB
+ 	mlx5e_dcbnl_ieee_setets_core(priv, &priv->params.ets);
+ #endif
+ 	return 0;
+ }
+ 
+ static void mlx5e_nic_enable(struct mlx5e_priv *priv)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	struct mlx5_eswitch_rep rep;
+ 
+ 	if (mlx5e_vxlan_allowed(mdev)) {
+ 		rtnl_lock();
+ 		udp_tunnel_get_rx_info(netdev);
+ 		rtnl_unlock();
+ 	}
+ 
+ 	mlx5e_enable_async_events(priv);
+ 	queue_work(priv->wq, &priv->set_rx_mode_work);
+ 
+ 	if (MLX5_CAP_GEN(mdev, vport_group_manager)) {
+ 		rep.vport = 0;
+ 		rep.priv_data = priv;
+ 		mlx5_eswitch_register_vport_rep(esw, &rep);
+ 	}
+ }
+ 
+ static void mlx5e_nic_disable(struct mlx5e_priv *priv)
+ {
+ 	queue_work(priv->wq, &priv->set_rx_mode_work);
+ 	mlx5e_disable_async_events(priv);
+ }
+ 
+ static const struct mlx5e_profile mlx5e_nic_profile = {
+ 	.init		   = mlx5e_nic_init,
+ 	.cleanup	   = mlx5e_nic_cleanup,
+ 	.init_rx	   = mlx5e_init_nic_rx,
+ 	.cleanup_rx	   = mlx5e_cleanup_nic_rx,
+ 	.init_tx	   = mlx5e_init_nic_tx,
+ 	.cleanup_tx	   = mlx5e_cleanup_nic_tx,
+ 	.enable		   = mlx5e_nic_enable,
+ 	.disable	   = mlx5e_nic_disable,
+ 	.update_stats	   = mlx5e_update_stats,
+ 	.max_nch	   = mlx5e_get_max_num_channels,
+ 	.max_tc		   = MLX5E_MAX_NUM_TC,
+ };
+ 
+ static void *mlx5e_create_netdev(struct mlx5_core_dev *mdev,
+ 				 const struct mlx5e_profile *profile, void *ppriv)
++>>>>>>> 127ea380acc9 (net/mlx5: Add Representors registration API)
  {
  	struct net_device *netdev;
  	struct mlx5e_priv *priv;
@@@ -3017,8 -3293,7 +3186,12 @@@
  		return NULL;
  	}
  
++<<<<<<< HEAD
 +	mlx5e_build_netdev_priv(mdev, netdev, nch);
 +	mlx5e_build_netdev(netdev);
++=======
+ 	profile->init(mdev, netdev, profile, ppriv);
++>>>>>>> 127ea380acc9 (net/mlx5: Add Representors registration API)
  
  	netif_carrier_off(netdev);
  
@@@ -3156,9 -3360,51 +3329,57 @@@ err_free_netdev
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, void *vpriv)
 +{
 +	struct mlx5e_priv *priv = vpriv;
++=======
+ static void mlx5e_register_vport_rep(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	int vport;
+ 
+ 	if (!MLX5_CAP_GEN(mdev, vport_group_manager))
+ 		return;
+ 
+ 	for (vport = 1; vport < total_vfs; vport++) {
+ 		struct mlx5_eswitch_rep rep;
+ 
+ 		rep.vport = vport;
+ 		mlx5_eswitch_register_vport_rep(esw, &rep);
+ 	}
+ }
+ 
+ static void *mlx5e_add(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	void *ppriv = NULL;
+ 	void *ret;
+ 
+ 	if (mlx5e_check_required_hca_cap(mdev))
+ 		return NULL;
+ 
+ 	if (mlx5e_create_mdev_resources(mdev))
+ 		return NULL;
+ 
+ 	mlx5e_register_vport_rep(mdev);
+ 
+ 	if (MLX5_CAP_GEN(mdev, vport_group_manager))
+ 		ppriv = &esw->offloads.vport_reps[0];
+ 
+ 	ret = mlx5e_create_netdev(mdev, &mlx5e_nic_profile, ppriv);
+ 	if (!ret) {
+ 		mlx5e_destroy_mdev_resources(mdev);
+ 		return NULL;
+ 	}
+ 	return ret;
+ }
+ 
+ static void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, struct mlx5e_priv *priv)
+ {
+ 	const struct mlx5e_profile *profile = priv->profile;
++>>>>>>> 127ea380acc9 (net/mlx5: Add Representors registration API)
  	struct net_device *netdev = priv->netdev;
  
  	set_bit(MLX5E_STATE_DESTROYING, &priv->state);
@@@ -3192,6 -3433,21 +3413,24 @@@
  		free_netdev(netdev);
  }
  
++<<<<<<< HEAD
++=======
+ static void mlx5e_remove(struct mlx5_core_dev *mdev, void *vpriv)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	struct mlx5e_priv *priv = vpriv;
+ 	int vport;
+ 
+ 	mlx5e_destroy_netdev(mdev, priv);
+ 
+ 	for (vport = 1; vport < total_vfs; vport++)
+ 		mlx5_eswitch_unregister_vport_rep(esw, vport);
+ 
+ 	mlx5e_destroy_mdev_resources(mdev);
+ }
+ 
++>>>>>>> 127ea380acc9 (net/mlx5: Add Representors registration API)
  static void *mlx5e_get_netdev(void *vpriv)
  {
  	struct mlx5e_priv *priv = vpriv;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index b153747c6dc3,f0a973557f7b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1385,6 -1712,8 +1394,11 @@@ void mlx5_eswitch_cleanup(struct mlx5_e
  	esw->dev->priv.eswitch = NULL;
  	destroy_workqueue(esw->work_queue);
  	kfree(esw->l2_table.bitmap);
++<<<<<<< HEAD
++=======
+ 	kfree(esw->mc_promisc);
+ 	kfree(esw->offloads.vport_reps);
++>>>>>>> 127ea380acc9 (net/mlx5: Add Representors registration API)
  	kfree(esw->vports);
  	kfree(esw);
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 6f9da7b7d506,ffe5eaba626d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -130,9 -135,38 +130,44 @@@ struct mlx5_l2_table 
  
  struct mlx5_eswitch_fdb {
  	void *fdb;
++<<<<<<< HEAD
 +	struct mlx5_flow_group *addr_grp;
 +	struct mlx5_flow_group *allmulti_grp;
 +	struct mlx5_flow_group *promisc_grp;
++=======
+ 	union {
+ 		struct legacy_fdb {
+ 			struct mlx5_flow_group *addr_grp;
+ 			struct mlx5_flow_group *allmulti_grp;
+ 			struct mlx5_flow_group *promisc_grp;
+ 		} legacy;
+ 
+ 		struct offloads_fdb {
+ 			struct mlx5_flow_group *send_to_vport_grp;
+ 			struct mlx5_flow_group *miss_grp;
+ 			struct mlx5_flow_rule  *miss_rule;
+ 		} offloads;
+ 	};
+ };
+ 
+ enum {
+ 	SRIOV_NONE,
+ 	SRIOV_LEGACY,
+ 	SRIOV_OFFLOADS
+ };
+ 
+ 
+ struct mlx5_eswitch_rep {
+ 	u16		       vport;
+ 	void		      *priv_data;
+ 	bool		       valid;
+ };
+ 
+ struct mlx5_esw_offload {
+ 	struct mlx5_flow_table *ft_offloads;
+ 	struct mlx5_flow_group *vport_rx_group;
+ 	struct mlx5_eswitch_rep *vport_reps;
++>>>>>>> 127ea380acc9 (net/mlx5: Add Representors registration API)
  };
  
  struct mlx5_eswitch {
@@@ -167,5 -208,27 +202,28 @@@ int mlx5_eswitch_get_vport_config(struc
  int mlx5_eswitch_get_vport_stats(struct mlx5_eswitch *esw,
  				 int vport,
  				 struct ifla_vf_stats *vf_stats);
 -struct mlx5_flow_rule *
 -mlx5_eswitch_add_send_to_vport_rule(struct mlx5_eswitch *esw, int vport, u32 sqn);
  
++<<<<<<< HEAD
++=======
+ struct mlx5_flow_rule *
+ mlx5_eswitch_create_vport_rx_rule(struct mlx5_eswitch *esw, int vport, u32 tirn);
+ 
+ int mlx5_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode);
+ int mlx5_devlink_eswitch_mode_get(struct devlink *devlink, u16 *mode);
+ void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
+ 				     struct mlx5_eswitch_rep *rep);
+ void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
+ 				       int vport);
+ 
+ #define MLX5_DEBUG_ESWITCH_MASK BIT(3)
+ 
+ #define esw_info(dev, format, ...)				\
+ 	pr_info("(%s): E-Switch: " format, (dev)->priv.name, ##__VA_ARGS__)
+ 
+ #define esw_warn(dev, format, ...)				\
+ 	pr_warn("(%s): E-Switch: " format, (dev)->priv.name, ##__VA_ARGS__)
+ 
+ #define esw_debug(dev, format, ...)				\
+ 	mlx5_core_dbg_mask(dev, MLX5_DEBUG_ESWITCH_MASK, format, ##__VA_ARGS__)
++>>>>>>> 127ea380acc9 (net/mlx5: Add Representors registration API)
  #endif /* __MLX5_ESWITCH_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
