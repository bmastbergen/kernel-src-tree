HID: wacom: power_supply: mark the type as USB

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: power_supply: mark the type as USB (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 94.25%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 96983296281507f049425b84f0d244c40d506eba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/96983296.failed

When upowerd detects a new device, it tries to map this new device to
an input to guess its kind. It works OK for wired tablets when the
wireless module and its battery are attached, but not so well when
connected over wireless.
In that case, the battery is attached to the wireless HID node, not
the Pen or Pad HID node. So there is no input node as a parent of the
reported battery, which means it will be showed as a computer battery
in gnome-control-center.

If we set the power supply type to USB, upowerd has a heuristic that
detects "wacom_" in the name of the power_supply, and set the type to
tablet. So it's now clear that the reported battery of from a tablet.
(see https://cgit.freedesktop.org/upower/tree/src/linux/up-device-supply.c)

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 96983296281507f049425b84f0d244c40d506eba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index e75b5002a526,792708b932bc..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1095,27 -1384,94 +1095,112 @@@ static int wacom_battery_get_property(s
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int wacom_ac_get_property(struct power_supply *psy,
+ 				enum power_supply_property psp,
+ 				union power_supply_propval *val)
+ {
+ 	struct wacom_battery *battery = power_supply_get_drvdata(psy);
+ 	int ret = 0;
+ 
+ 	switch (psp) {
+ 	case POWER_SUPPLY_PROP_PRESENT:
+ 		/* fall through */
+ 	case POWER_SUPPLY_PROP_ONLINE:
+ 		val->intval = battery->ps_connected;
+ 		break;
+ 	case POWER_SUPPLY_PROP_SCOPE:
+ 		val->intval = POWER_SUPPLY_SCOPE_DEVICE;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 	return ret;
+ }
+ 
+ static int __wacom_initialize_battery(struct wacom *wacom,
+ 				      struct wacom_battery *battery)
+ {
+ 	static atomic_t battery_no = ATOMIC_INIT(0);
+ 	struct device *dev = &wacom->hdev->dev;
+ 	struct power_supply_config psy_cfg = { .drv_data = battery, };
+ 	struct power_supply *ps_bat, *ps_ac;
+ 	struct power_supply_desc *bat_desc = &battery->bat_desc;
+ 	struct power_supply_desc *ac_desc = &battery->ac_desc;
+ 	unsigned long n;
+ 	int error;
+ 
+ 	if (!devres_open_group(dev, bat_desc, GFP_KERNEL))
+ 		return -ENOMEM;
+ 
+ 	n = atomic_inc_return(&battery_no) - 1;
+ 
+ 	bat_desc->properties = wacom_battery_props;
+ 	bat_desc->num_properties = ARRAY_SIZE(wacom_battery_props);
+ 	bat_desc->get_property = wacom_battery_get_property;
+ 	sprintf(battery->bat_name, "wacom_battery_%ld", n);
+ 	bat_desc->name = battery->bat_name;
+ 	bat_desc->type = POWER_SUPPLY_TYPE_USB;
+ 	bat_desc->use_for_apm = 0;
+ 
+ 	ac_desc->properties = wacom_ac_props;
+ 	ac_desc->num_properties = ARRAY_SIZE(wacom_ac_props);
+ 	ac_desc->get_property = wacom_ac_get_property;
+ 	sprintf(battery->ac_name, "wacom_ac_%ld", n);
+ 	ac_desc->name = battery->ac_name;
+ 	ac_desc->type = POWER_SUPPLY_TYPE_MAINS;
+ 	ac_desc->use_for_apm = 0;
+ 
+ 	ps_bat = devm_power_supply_register(dev, bat_desc, &psy_cfg);
+ 	if (IS_ERR(ps_bat)) {
+ 		error = PTR_ERR(ps_bat);
+ 		goto err;
+ 	}
+ 
+ 	ps_ac = devm_power_supply_register(dev, ac_desc, &psy_cfg);
+ 	if (IS_ERR(ps_ac)) {
+ 		error = PTR_ERR(ps_ac);
+ 		goto err;
+ 	}
+ 
+ 	power_supply_powers(ps_bat, &wacom->hdev->dev);
+ 	power_supply_powers(ps_ac, &wacom->hdev->dev);
+ 
+ 	battery->battery = ps_bat;
+ 	battery->ac = ps_ac;
+ 
+ 	devres_close_group(dev, bat_desc);
+ 	return 0;
+ 
+ err:
+ 	devres_release_group(dev, bat_desc);
+ 	return error;
+ }
+ 
++>>>>>>> 969832962815 (HID: wacom: power_supply: mark the type as USB)
  static int wacom_initialize_battery(struct wacom *wacom)
  {
 -	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY)
 -		return __wacom_initialize_battery(wacom, &wacom->battery);
 +	int error = 0;
  
 -	return 0;
 +	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_MONITOR) {
 +		wacom->battery.properties = wacom_battery_props;
 +		wacom->battery.num_properties = ARRAY_SIZE(wacom_battery_props);
 +		wacom->battery.get_property = wacom_battery_get_property;
 +		wacom->battery.name = "wacom_battery";
 +		wacom->battery.type = POWER_SUPPLY_TYPE_BATTERY;
 +		wacom->battery.use_for_apm = 0;
 +
 +		error = power_supply_register(&wacom->usbdev->dev,
 +					      &wacom->battery);
 +
 +		if (!error)
 +			power_supply_powers(&wacom->battery,
 +					    &wacom->usbdev->dev);
 +	}
 +
 +	return error;
  }
  
  static void wacom_destroy_battery(struct wacom *wacom)
* Unmerged path drivers/hid/wacom_sys.c
