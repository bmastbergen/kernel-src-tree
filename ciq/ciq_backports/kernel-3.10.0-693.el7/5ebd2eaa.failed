ACPICA: Cleanup for all string-to-integer conversions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Bob Moore <robert.moore@intel.com>
commit 5ebd2eaaefc0d4fe37ab72e716e1b8065ed4206c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5ebd2eaa.failed

ACPICA commit e2e72a351201fd58e4694418859ae2c247dafca0

Consolidate multiple versions of strtoul64 to one common version.
limit possible bases to either 10 or 16.
Handles both implicit and explicit conversions.
Added a 2-character ascii-to-hex function for GPEs and buffers.
Adds a new file, utstrtoul64.c

Link: https://github.com/acpica/acpica/commit/e2e72a35
	Signed-off-by: Bob Moore <robert.moore@intel.com>
	Signed-off-by: Lv Zheng <lv.zheng@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 5ebd2eaaefc0d4fe37ab72e716e1b8065ed4206c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpica/acutils.h
#	drivers/acpi/acpica/dbconvert.c
#	drivers/acpi/acpica/evgpeinit.c
#	drivers/acpi/acpica/exconcat.c
#	drivers/acpi/acpica/exconvrt.c
#	drivers/acpi/acpica/exoparg1.c
#	drivers/acpi/acpica/nsconvert.c
#	drivers/acpi/acpica/uthex.c
#	drivers/acpi/acpica/utnonansi.c
#	tools/power/acpi/tools/acpidump/Makefile
#	tools/power/acpi/tools/acpidump/apdump.c
#	tools/power/acpi/tools/acpidump/apmain.c
diff --cc drivers/acpi/acpica/acutils.h
index 7125ee1826be,0a1b53c9ee0e..000000000000
--- a/drivers/acpi/acpica/acutils.h
+++ b/drivers/acpi/acpica/acutils.h
@@@ -168,6 -179,34 +168,37 @@@ struct acpi_pkg_info 
  #define DB_QWORD_DISPLAY    8
  
  /*
++<<<<<<< HEAD
++=======
+  * utascii - ASCII utilities
+  */
+ u8 acpi_ut_valid_nameseg(char *signature);
+ 
+ u8 acpi_ut_valid_name_char(char character, u32 position);
+ 
+ void acpi_ut_check_and_repair_ascii(u8 *name, char *repaired_name, u32 count);
+ 
+ /*
+  * utnonansi - Non-ANSI C library functions
+  */
+ void acpi_ut_strupr(char *src_string);
+ 
+ void acpi_ut_strlwr(char *src_string);
+ 
+ int acpi_ut_stricmp(char *string1, char *string2);
+ 
+ acpi_status acpi_ut_strtoul64(char *string, u32 flags, u64 *ret_integer);
+ 
+ /*
+  * Values for Flags above
+  * Note: LIMIT values correspond to acpi_gbl_integer_byte_width values (4/8)
+  */
+ #define ACPI_STRTOUL_32BIT          0x04	/* 4 bytes */
+ #define ACPI_STRTOUL_64BIT          0x08	/* 8 bytes */
+ #define ACPI_STRTOUL_BASE16         0x10	/* Default: Base10/16 */
+ 
+ /*
++>>>>>>> 5ebd2eaaefc0 (ACPICA: Cleanup for all string-to-integer conversions)
   * utglobal - Global data structures and procedures
   */
  acpi_status acpi_ut_init_globals(void);
@@@ -195,6 -234,10 +226,13 @@@ char *acpi_ut_get_event_name(u32 event_
  
  char acpi_ut_hex_to_ascii_char(u64 integer, u32 position);
  
++<<<<<<< HEAD
++=======
+ acpi_status acpi_ut_ascii_to_hex_byte(char *two_ascii_chars, u8 *return_byte);
+ 
+ u8 acpi_ut_ascii_char_to_hex(int hex_char);
+ 
++>>>>>>> 5ebd2eaaefc0 (ACPICA: Cleanup for all string-to-integer conversions)
  u8 acpi_ut_valid_object_type(acpi_object_type type);
  
  /*
diff --cc drivers/acpi/acpica/evgpeinit.c
index 9037f17c9608,16ce4835e7d0..000000000000
--- a/drivers/acpi/acpica/evgpeinit.c
+++ b/drivers/acpi/acpica/evgpeinit.c
@@@ -384,8 -379,8 +386,13 @@@ acpi_ev_match_gpe_method(acpi_handle ob
  
  	/* 4) The last two characters of the name are the hex GPE Number */
  
++<<<<<<< HEAD
 +	gpe_number = ACPI_STRTOUL(&name[2], NULL, 16);
 +	if (gpe_number == ACPI_UINT32_MAX) {
++=======
+ 	status = acpi_ut_ascii_to_hex_byte(&name[2], &temp_gpe_number);
+ 	if (ACPI_FAILURE(status)) {
++>>>>>>> 5ebd2eaaefc0 (ACPICA: Cleanup for all string-to-integer conversions)
  
  		/* Conversion failed; invalid method, just ignore it */
  
diff --cc drivers/acpi/acpica/exconvrt.c
index 69e4a8cc9b71,588ad1409dbe..000000000000
--- a/drivers/acpi/acpica/exconvrt.c
+++ b/drivers/acpi/acpica/exconvrt.c
@@@ -124,7 -124,9 +124,13 @@@ acpi_ex_convert_to_integer(union acpi_o
  		 * of ACPI 3.0) is that the to_integer() operator allows both decimal
  		 * and hexadecimal strings (hex prefixed with "0x").
  		 */
++<<<<<<< HEAD
 +		status = acpi_ut_strtoul64((char *)pointer, flags, &result);
++=======
+ 		status = acpi_ut_strtoul64(ACPI_CAST_PTR(char, pointer),
+ 					   (acpi_gbl_integer_byte_width |
+ 					    flags), &result);
++>>>>>>> 5ebd2eaaefc0 (ACPICA: Cleanup for all string-to-integer conversions)
  		if (ACPI_FAILURE(status)) {
  			return_ACPI_STATUS(status);
  		}
diff --cc drivers/acpi/acpica/exoparg1.c
index 814b4a3d656a,6ae19cb26eb2..000000000000
--- a/drivers/acpi/acpica/exoparg1.c
+++ b/drivers/acpi/acpica/exoparg1.c
@@@ -516,8 -521,10 +516,15 @@@ acpi_status acpi_ex_opcode_1A_1T_1R(str
  
  	case AML_TO_INTEGER_OP:	/* to_integer (Data, Result) */
  
++<<<<<<< HEAD
 +		status = acpi_ex_convert_to_integer(operand[0], &return_desc,
 +						    ACPI_ANY_BASE);
++=======
+ 		/* Perform "explicit" conversion */
+ 
+ 		status =
+ 		    acpi_ex_convert_to_integer(operand[0], &return_desc, 0);
++>>>>>>> 5ebd2eaaefc0 (ACPICA: Cleanup for all string-to-integer conversions)
  		if (return_desc == operand[0]) {
  
  			/* No conversion performed, add ref to handle return value */
diff --cc drivers/acpi/acpica/nsconvert.c
index acd2964c2690,2b85dee6d4c0..000000000000
--- a/drivers/acpi/acpica/nsconvert.c
+++ b/drivers/acpi/acpica/nsconvert.c
@@@ -79,7 -79,7 +79,11 @@@ acpi_ns_convert_to_integer(union acpi_o
  		/* String-to-Integer conversion */
  
  		status = acpi_ut_strtoul64(original_object->string.pointer,
++<<<<<<< HEAD
 +					   ACPI_ANY_BASE, &value);
++=======
+ 					   acpi_gbl_integer_byte_width, &value);
++>>>>>>> 5ebd2eaaefc0 (ACPICA: Cleanup for all string-to-integer conversions)
  		if (ACPI_FAILURE(status)) {
  			return (status);
  		}
* Unmerged path drivers/acpi/acpica/dbconvert.c
* Unmerged path drivers/acpi/acpica/exconcat.c
* Unmerged path drivers/acpi/acpica/uthex.c
* Unmerged path drivers/acpi/acpica/utnonansi.c
* Unmerged path tools/power/acpi/tools/acpidump/Makefile
* Unmerged path tools/power/acpi/tools/acpidump/apdump.c
* Unmerged path tools/power/acpi/tools/acpidump/apmain.c
diff --git a/drivers/acpi/acpica/Makefile b/drivers/acpi/acpica/Makefile
index 438304086ff1..5dbcec2596dc 100644
--- a/drivers/acpi/acpica/Makefile
+++ b/drivers/acpi/acpica/Makefile
@@ -169,6 +169,7 @@ acpi-y +=		\
 	utresrc.o	\
 	utstate.o	\
 	utstring.o	\
+	utstrtoul64.o	\
 	utxface.o	\
 	utxfinit.o	\
 	utxferror.o	\
* Unmerged path drivers/acpi/acpica/acutils.h
* Unmerged path drivers/acpi/acpica/dbconvert.c
diff --git a/drivers/acpi/acpica/dswexec.c b/drivers/acpi/acpica/dswexec.c
index 151d924817e1..08bd51f3f1e9 100644
--- a/drivers/acpi/acpica/dswexec.c
+++ b/drivers/acpi/acpica/dswexec.c
@@ -133,7 +133,8 @@ acpi_ds_get_predicate_value(struct acpi_walk_state *walk_state,
 	 * Result of predicate evaluation must be an Integer
 	 * object. Implicitly convert the argument if necessary.
 	 */
-	status = acpi_ex_convert_to_integer(obj_desc, &local_obj_desc, 16);
+	status = acpi_ex_convert_to_integer(obj_desc, &local_obj_desc,
+					    ACPI_STRTOUL_BASE16);
 	if (ACPI_FAILURE(status)) {
 		goto cleanup;
 	}
* Unmerged path drivers/acpi/acpica/evgpeinit.c
* Unmerged path drivers/acpi/acpica/exconcat.c
* Unmerged path drivers/acpi/acpica/exconvrt.c
diff --git a/drivers/acpi/acpica/exmisc.c b/drivers/acpi/acpica/exmisc.c
index 00bf29877574..944b34614a38 100644
--- a/drivers/acpi/acpica/exmisc.c
+++ b/drivers/acpi/acpica/exmisc.c
@@ -585,8 +585,8 @@ acpi_ex_do_logical_op(u16 opcode,
 	switch (operand0->common.type) {
 	case ACPI_TYPE_INTEGER:
 
-		status =
-		    acpi_ex_convert_to_integer(operand1, &local_operand1, 16);
+		status = acpi_ex_convert_to_integer(operand1, &local_operand1,
+						    ACPI_STRTOUL_BASE16);
 		break;
 
 	case ACPI_TYPE_STRING:
* Unmerged path drivers/acpi/acpica/exoparg1.c
diff --git a/drivers/acpi/acpica/exresop.c b/drivers/acpi/acpica/exresop.c
index 00e5af7129c1..07a83131394e 100644
--- a/drivers/acpi/acpica/exresop.c
+++ b/drivers/acpi/acpica/exresop.c
@@ -408,12 +408,13 @@ acpi_ex_resolve_operands(u16 opcode,
 		case ARGI_INTEGER:
 
 			/*
-			 * Need an operand of type ACPI_TYPE_INTEGER,
-			 * But we can implicitly convert from a STRING or BUFFER
-			 * aka - "Implicit Source Operand Conversion"
+			 * Need an operand of type ACPI_TYPE_INTEGER, but we can
+			 * implicitly convert from a STRING or BUFFER.
+			 *
+			 * Known as "Implicit Source Operand Conversion"
 			 */
-			status =
-			    acpi_ex_convert_to_integer(obj_desc, stack_ptr, 16);
+			status = acpi_ex_convert_to_integer(obj_desc, stack_ptr,
+							    ACPI_STRTOUL_BASE16);
 			if (ACPI_FAILURE(status)) {
 				if (status == AE_TYPE) {
 					ACPI_ERROR((AE_INFO,
* Unmerged path drivers/acpi/acpica/nsconvert.c
* Unmerged path drivers/acpi/acpica/uthex.c
* Unmerged path drivers/acpi/acpica/utnonansi.c
diff --git a/drivers/acpi/acpica/utstrtoul64.c b/drivers/acpi/acpica/utstrtoul64.c
new file mode 100644
index 000000000000..b4f341c98a95
--- /dev/null
+++ b/drivers/acpi/acpica/utstrtoul64.c
@@ -0,0 +1,348 @@
+/*******************************************************************************
+ *
+ * Module Name: utstrtoul64 - string to 64-bit integer support
+ *
+ ******************************************************************************/
+
+/*
+ * Copyright (C) 2000 - 2016, Intel Corp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include <acpi/acpi.h>
+#include "accommon.h"
+
+/*******************************************************************************
+ *
+ * The functions in this module satisfy the need for 64-bit string-to-integer
+ * conversions on both 32-bit and 64-bit platforms.
+ *
+ ******************************************************************************/
+
+#define _COMPONENT          ACPI_UTILITIES
+ACPI_MODULE_NAME("utstrtoul64")
+
+/* Local prototypes */
+static u64 acpi_ut_strtoul_base10(char *string, u32 flags);
+
+static u64 acpi_ut_strtoul_base16(char *string, u32 flags);
+
+/*******************************************************************************
+ *
+ * String conversion rules as written in the ACPI specification. The error
+ * conditions and behavior are different depending on the type of conversion.
+ *
+ *
+ * Implicit data type conversion: string-to-integer
+ * --------------------------------------------------
+ *
+ * Base is always 16. This is the ACPI_STRTOUL_BASE16 case.
+ *
+ * Example:
+ *      Add ("BA98", Arg0, Local0)
+ *
+ * The integer is initialized to the value zero.
+ * The ASCII string is interpreted as a hexadecimal constant.
+ *
+ *  1)  A "0x" prefix is not allowed. However, ACPICA allows this for
+ *      compatibility with previous ACPICA. (NO ERROR)
+ *
+ *  2)  Terminates when the size of an integer is reached (32 or 64 bits).
+ *      (NO ERROR)
+ *
+ *  3)  The first non-hex character terminates the conversion without error.
+ *      (NO ERROR)
+ *
+ *  4)  Conversion of a null (zero-length) string to an integer is not
+ *      allowed. However, ACPICA allows this for compatibility with previous
+ *      ACPICA. This conversion returns the value 0. (NO ERROR)
+ *
+ *
+ * Explicit data type conversion:  to_integer() with string operand
+ * ---------------------------------------------------------------
+ *
+ * Base is either 10 (default) or 16 (with 0x prefix)
+ *
+ * Examples:
+ *      to_integer ("1000")
+ *      to_integer ("0xABCD")
+ *
+ *  1)  Can be (must be) either a decimal or hexadecimal numeric string.
+ *      A hex value must be prefixed by "0x" or it is interpreted as a decimal.
+ *
+ *  2)  The value must not exceed the maximum of an integer value. ACPI spec
+ *      states the behavior is "unpredictable", so ACPICA matches the behavior
+ *      of the implicit conversion case.(NO ERROR)
+ *
+ *  3)  Behavior on the first non-hex character is not specified by the ACPI
+ *      spec, so ACPICA matches the behavior of the implicit conversion case
+ *      and terminates. (NO ERROR)
+ *
+ *  4)  A null (zero-length) string is illegal.
+ *      However, ACPICA allows this for compatibility with previous ACPICA.
+ *      This conversion returns the value 0. (NO ERROR)
+ *
+ ******************************************************************************/
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strtoul64
+ *
+ * PARAMETERS:  string                  - Null terminated input string
+ *              flags                   - Conversion info, see below
+ *              return_value            - Where the converted integer is
+ *                                        returned
+ *
+ * RETURN:      Status and Converted value
+ *
+ * DESCRIPTION: Convert a string into an unsigned value. Performs either a
+ *              32-bit or 64-bit conversion, depending on the input integer
+ *              size in Flags (often the current mode of the interpreter).
+ *
+ * Values for Flags:
+ *      ACPI_STRTOUL_32BIT      - Max integer value is 32 bits
+ *      ACPI_STRTOUL_64BIT      - Max integer value is 64 bits
+ *      ACPI_STRTOUL_BASE16     - Input string is hexadecimal. Default
+ *                                is 10/16 based on string prefix (0x).
+ *
+ * NOTES:
+ *   Negative numbers are not supported, as they are not supported by ACPI.
+ *
+ *   Supports only base 16 or base 10 strings/values. Does not
+ *   support Octal strings, as these are not supported by ACPI.
+ *
+ * Current users of this support:
+ *
+ *  interpreter - Implicit and explicit conversions, GPE method names
+ *  debugger    - Command line input string conversion
+ *  iASL        - Main parser, conversion of constants to integers
+ *  iASL        - Data Table Compiler parser (constant math expressions)
+ *  iASL        - Preprocessor (constant math expressions)
+ *  acpi_dump   - Input table addresses
+ *  acpi_exec   - Testing of the acpi_ut_strtoul64 function
+ *
+ * Note concerning callers:
+ *   acpi_gbl_integer_byte_width can be used to set the 32/64 limit. If used,
+ *   this global should be set to the proper width. For the core ACPICA code,
+ *   this width depends on the DSDT version. For iASL, the default byte
+ *   width is always 8 for the parser, but error checking is performed later
+ *   to flag cases where a 64-bit constant is defined in a 32-bit DSDT/SSDT.
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ut_strtoul64(char *string, u32 flags, u64 *return_value)
+{
+	acpi_status status = AE_OK;
+	u32 base;
+
+	ACPI_FUNCTION_TRACE_STR(ut_strtoul64, string);
+
+	/* Parameter validation */
+
+	if (!string || !return_value) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	*return_value = 0;
+
+	/* Check for zero-length string, returns 0 */
+
+	if (*string == 0) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Skip over any white space at start of string */
+
+	while (isspace((int)*string)) {
+		string++;
+	}
+
+	/* End of string? return 0 */
+
+	if (*string == 0) {
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/*
+	 * 1) The "0x" prefix indicates base 16. Per the ACPI specification,
+	 * the "0x" prefix is only allowed for implicit (non-strict) conversions.
+	 * However, we always allow it for compatibility with older ACPICA.
+	 */
+	if ((*string == ACPI_ASCII_ZERO) &&
+	    (tolower((int)*(string + 1)) == 'x')) {
+		string += 2;	/* Go past the 0x */
+		if (*string == 0) {
+			return_ACPI_STATUS(AE_OK);	/* Return value 0 */
+		}
+
+		base = 16;
+	}
+
+	/* 2) Force to base 16 (implicit conversion case) */
+
+	else if (flags & ACPI_STRTOUL_BASE16) {
+		base = 16;
+	}
+
+	/* 3) Default fallback is to Base 10 */
+
+	else {
+		base = 10;
+	}
+
+	/* Skip all leading zeros */
+
+	while (*string == ACPI_ASCII_ZERO) {
+		string++;
+		if (*string == 0) {
+			return_ACPI_STATUS(AE_OK);	/* Return value 0 */
+		}
+	}
+
+	/* Perform the base 16 or 10 conversion */
+
+	if (base == 16) {
+		*return_value = acpi_ut_strtoul_base16(string, flags);
+	} else {
+		*return_value = acpi_ut_strtoul_base10(string, flags);
+	}
+
+	return_ACPI_STATUS(status);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strtoul_base10
+ *
+ * PARAMETERS:  string                  - Null terminated input string
+ *              flags                   - Conversion info
+ *
+ * RETURN:      64-bit converted integer
+ *
+ * DESCRIPTION: Performs a base 10 conversion of the input string to an
+ *              integer value, either 32 or 64 bits.
+ *              Note: String must be valid and non-null.
+ *
+ ******************************************************************************/
+
+static u64 acpi_ut_strtoul_base10(char *string, u32 flags)
+{
+	int ascii_digit;
+	u64 next_value;
+	u64 return_value = 0;
+
+	/* Main loop: convert each ASCII byte in the input string */
+
+	while (*string) {
+		ascii_digit = *string;
+		if (!isdigit(ascii_digit)) {
+
+			/* Not ASCII 0-9, terminate */
+
+			goto exit;
+		}
+
+		/* Convert and insert (add) the decimal digit */
+
+		next_value =
+		    (return_value * 10) + (ascii_digit - ACPI_ASCII_ZERO);
+
+		/* Check for overflow (32 or 64 bit) - return current converted value */
+
+		if (((flags & ACPI_STRTOUL_32BIT) && (next_value > ACPI_UINT32_MAX)) || (next_value < return_value)) {	/* 64-bit overflow case */
+			goto exit;
+		}
+
+		return_value = next_value;
+		string++;
+	}
+
+exit:
+	return (return_value);
+}
+
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ut_strtoul_base16
+ *
+ * PARAMETERS:  string                  - Null terminated input string
+ *              flags                   - conversion info
+ *
+ * RETURN:      64-bit converted integer
+ *
+ * DESCRIPTION: Performs a base 16 conversion of the input string to an
+ *              integer value, either 32 or 64 bits.
+ *              Note: String must be valid and non-null.
+ *
+ ******************************************************************************/
+
+static u64 acpi_ut_strtoul_base16(char *string, u32 flags)
+{
+	int ascii_digit;
+	u32 valid_digits = 1;
+	u64 return_value = 0;
+
+	/* Main loop: convert each ASCII byte in the input string */
+
+	while (*string) {
+
+		/* Check for overflow (32 or 64 bit) - return current converted value */
+
+		if ((valid_digits > 16) ||
+		    ((valid_digits > 8) && (flags & ACPI_STRTOUL_32BIT))) {
+			goto exit;
+		}
+
+		ascii_digit = *string;
+		if (!isxdigit(ascii_digit)) {
+
+			/* Not Hex ASCII A-F, a-f, or 0-9, terminate */
+
+			goto exit;
+		}
+
+		/* Convert and insert the hex digit */
+
+		return_value =
+		    (return_value << 4) |
+		    acpi_ut_ascii_char_to_hex(ascii_digit);
+
+		string++;
+		valid_digits++;
+	}
+
+exit:
+	return (return_value);
+}
* Unmerged path tools/power/acpi/tools/acpidump/Makefile
* Unmerged path tools/power/acpi/tools/acpidump/apdump.c
* Unmerged path tools/power/acpi/tools/acpidump/apmain.c
