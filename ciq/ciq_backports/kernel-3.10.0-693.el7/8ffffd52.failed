HID: wacom: fix timeout on probe for some wacoms

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: fix timeout on probe for some wacoms (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 94.51%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 8ffffd5212846b72f116f7a9572e83d580e25802
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8ffffd52.failed

Some Wacom tablets (at least the ISDv4 found in the Lenovo X230) timeout
during probe while retrieving the input reports.
The only time this information is valuable is during the feature_mapping
stage, so we can ask for it there and discard the generic input reports
retrieval.

This gives a code path closer to the wacom.ko driver when it was in the
input subtree (not HID).

	Cc: stable@vger.kernel.org # requires cherry-pick of c64d883476
	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 8ffffd5212846b72f116f7a9572e83d580e25802)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,25086287957e..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -172,92 -90,45 +172,116 @@@ static void wacom_close(struct input_de
  }
  
  /*
 - * Calculate the resolution of the X or Y axis using hidinput_calc_abs_res.
 + * Calculate the resolution of the X or Y axis, given appropriate HID data.
 + * This function is little more than hidinput_calc_abs_res stripped down.
   */
  static int wacom_calc_hid_res(int logical_extents, int physical_extents,
 -			       unsigned unit, int exponent)
 +                              unsigned char unit, unsigned char exponent)
  {
 -	struct hid_field field = {
 -		.logical_maximum = logical_extents,
 -		.physical_maximum = physical_extents,
 -		.unit = unit,
 -		.unit_exponent = exponent,
 -	};
 -
 -	return hidinput_calc_abs_res(&field, ABS_X);
 +	int prev, unit_exponent;
 +
 +	/* Check if the extents are sane */
 +	if (logical_extents <= 0 || physical_extents <= 0)
 +		return 0;
 +
 +	/* Get signed value of nybble-sized twos-compliment exponent */
 +	unit_exponent = exponent;
 +	if (unit_exponent > 7)
 +		unit_exponent -= 16;
 +
 +	/* Convert physical_extents to millimeters */
 +	if (unit == 0x11) {		/* If centimeters */
 +		unit_exponent += 1;
 +	} else if (unit == 0x13) {	/* If inches */
 +		prev = physical_extents;
 +		physical_extents *= 254;
 +		if (physical_extents < prev)
 +			return 0;
 +		unit_exponent -= 1;
 +	} else {
 +		return 0;
 +	}
 +
 +	/* Apply negative unit exponent */
 +	for (; unit_exponent < 0; unit_exponent++) {
 +		prev = logical_extents;
 +		logical_extents *= 10;
 +		if (logical_extents < prev)
 +			return 0;
 +	}
 +	/* Apply positive unit exponent */
 +	for (; unit_exponent > 0; unit_exponent--) {
 +		prev = physical_extents;
 +		physical_extents *= 10;
 +		if (physical_extents < prev)
 +			return 0;
 +	}
 +
 +	/* Calculate resolution */
 +	return logical_extents / physical_extents;
 +}
 +
 +static int wacom_parse_logical_collection(unsigned char *report,
 +					  struct wacom_features *features)
 +{
++<<<<<<< HEAD
 +	int length = 0;
 +
 +	if (features->type == BAMBOO_PT) {
 +
 +		/* Logical collection is only used by 3rd gen Bamboo Touch */
 +		features->pktlen = WACOM_PKGLEN_BBTOUCH3;
 +		features->device_type = BTN_TOOL_FINGER;
 +
 +		features->x_max = features->y_max =
 +			get_unaligned_le16(&report[10]);
 +
 +		length = 11;
 +	}
 +	return length;
  }
  
 -static void wacom_feature_mapping(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage)
 +static void wacom_retrieve_report_data(struct usb_interface *intf,
 +				       struct wacom_features *features)
  {
 +	int result = 0;
 +	unsigned char *rep_data;
 +
 +	rep_data = kmalloc(2, GFP_KERNEL);
 +	if (rep_data) {
 +
 +		rep_data[0] = 12;
 +		result = wacom_get_report(intf, WAC_HID_FEATURE_REPORT,
 +					  rep_data[0], rep_data, 2,
 +					  WAC_MSG_RETRIES);
 +
 +		if (result >= 0 && rep_data[1] > 2)
 +			features->touch_max = rep_data[1];
 +
 +		kfree(rep_data);
++=======
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_features *features = &wacom->wacom_wac.features;
+ 	u8 *data;
+ 	int ret;
+ 
+ 	switch (usage->hid) {
+ 	case HID_DG_CONTACTMAX:
+ 		/* leave touch_max as is if predefined */
+ 		if (!features->touch_max) {
+ 			/* read manually */
+ 			data = kzalloc(2, GFP_KERNEL);
+ 			if (!data)
+ 				break;
+ 			data[0] = field->report->id;
+ 			ret = wacom_get_report(hdev, HID_FEATURE_REPORT,
+ 						data, 2, 0);
+ 			if (ret == 2)
+ 				features->touch_max = data[1];
+ 			kfree(data);
+ 		}
+ 		break;
++>>>>>>> 8ffffd521284 (HID: wacom: fix timeout on probe for some wacoms)
  	}
  }
  
@@@ -1302,9 -1289,11 +1326,11 @@@ static int wacom_probe(struct usb_inter
  	struct wacom_features *features;
  	int error;
  
 -	if (!id->driver_data)
 +	if (!id->driver_info)
  		return -EINVAL;
  
+ 	hdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;
+ 
  	wacom = kzalloc(sizeof(struct wacom), GFP_KERNEL);
  	if (!wacom)
  		return -ENOMEM;
* Unmerged path drivers/hid/wacom_sys.c
