net/mlx5e: Single flow order-0 pages for Striding RQ

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Single flow order-0 pages for Striding RQ (Don Dutile) [1385310 1385330 1417285]
Rebuild_FUZZ: 96.00%
commit-author Tariq Toukan <tariqt@mellanox.com>
commit 7e426671704d2266757dff9c4254b788561aa11e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7e426671.failed

To improve the memory consumption scheme, we omit the flow that
demands and splits high-order pages in Striding RQ, and stay
with a single Striding RQ flow that uses order-0 pages.

Moving to fragmented memory allows the use of larger MPWQEs,
which reduces the number of UMR posts and filler CQEs.

Moving to a single flow allows several optimizations that improve
performance, especially in production servers where we would
anyway fallback to order-0 allocations:
- inline functions that were called via function pointers.
- improve the UMR post process.

This patch alone is expected to give a slight performance reduction.
However, the new memory scheme gives the possibility to use a page-cache
of a fair size, that doesn't inflate the memory footprint, which will
dramatically fix the reduction and even give a performance gain.

Performance tests:
The following results were measured on a freshly booted system,
giving optimal baseline performance, as high-order pages are yet to
be fragmented and depleted.

We ran pktgen single-stream benchmarks, with iptables-raw-drop:

Single stride, 64 bytes:
* 4,739,057 - baseline
* 4,749,550 - this patch
no reduction

Larger packets, no page cross, 1024 bytes:
* 3,982,361 - baseline
* 3,845,682 - this patch
3.5% reduction

Larger packets, every 3rd packet crosses a page, 1500 bytes:
* 3,731,189 - baseline
* 3,579,414 - this patch
4% reduction

Fixes: 461017cb006a ("net/mlx5e: Support RX multi-packet WQE (Striding RQ)")
Fixes: bc77b240b3c5 ("net/mlx5e: Add fragmented memory support for RX multi packet WQE")
	Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7e426671704d2266757dff9c4254b788561aa11e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 8d737e76ff7e,136554b77c3b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -344,17 -469,11 +451,23 @@@ static int mlx5e_create_rq(struct mlx5e
  		struct mlx5e_rx_wqe *wqe = mlx5_wq_ll_get_wqe(&rq->wq, i);
  
  		wqe->data.byte_count = cpu_to_be32(byte_count);
+ 		wqe->data.lkey = rq->mkey_be;
  	}
  
++<<<<<<< HEAD
 +	rq->wq_type = priv->params.rq_wq_type;
 +	rq->pdev    = c->pdev;
 +	rq->netdev  = c->netdev;
 +	rq->tstamp  = &priv->tstamp;
 +	rq->channel = c;
 +	rq->ix      = c->ix;
 +	rq->priv    = c->priv;
 +	rq->mkey_be = c->mkey_be;
 +	rq->umr_mkey_be = cpu_to_be32(c->priv->umr_mkey.key);
++=======
+ 	INIT_WORK(&rq->am.work, mlx5e_rx_am_work);
+ 	rq->am.mode = priv->params.rx_cq_period_mode;
++>>>>>>> 7e426671704d (net/mlx5e: Single flow order-0 pages for Striding RQ)
  
  	return 0;
  
@@@ -499,6 -617,27 +612,30 @@@ static int mlx5e_wait_for_min_rx_wqes(s
  	return -ETIMEDOUT;
  }
  
++<<<<<<< HEAD
++=======
+ static void mlx5e_free_rx_descs(struct mlx5e_rq *rq)
+ {
+ 	struct mlx5_wq_ll *wq = &rq->wq;
+ 	struct mlx5e_rx_wqe *wqe;
+ 	__be16 wqe_ix_be;
+ 	u16 wqe_ix;
+ 
+ 	/* UMR WQE (if in progress) is always at wq->head */
+ 	if (test_bit(MLX5E_RQ_STATE_UMR_WQE_IN_PROGRESS, &rq->state))
+ 		mlx5e_free_rx_mpwqe(rq, &rq->wqe_info[wq->head]);
+ 
+ 	while (!mlx5_wq_ll_is_empty(wq)) {
+ 		wqe_ix_be = *wq->tail_next;
+ 		wqe_ix    = be16_to_cpu(wqe_ix_be);
+ 		wqe       = mlx5_wq_ll_get_wqe(&rq->wq, wqe_ix);
+ 		rq->dealloc_wqe(rq, wqe_ix);
+ 		mlx5_wq_ll_pop(&rq->wq, wqe_ix_be,
+ 			       &wqe->next.next_wqe_index);
+ 	}
+ }
+ 
++>>>>>>> 7e426671704d (net/mlx5e: Single flow order-0 pages for Striding RQ)
  static int mlx5e_open_rq(struct mlx5e_channel *c,
  			 struct mlx5e_rq_param *param,
  			 struct mlx5e_rq *rq)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
index d795e95774bc,5d1b7b5e4f36..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
@@@ -324,46 -277,9 +277,52 @@@ mlx5e_copy_skb_header_mpwqe(struct devi
  	}
  }
  
++<<<<<<< HEAD
 +static u16 mlx5e_get_wqe_mtt_offset(u16 rq_ix, u16 wqe_ix)
 +{
 +	return rq_ix * MLX5_CHANNEL_MAX_NUM_MTTS +
 +		wqe_ix * ALIGN(MLX5_MPWRQ_PAGES_PER_WQE, 8);
 +}
 +
 +static void mlx5e_build_umr_wqe(struct mlx5e_rq *rq,
 +				struct mlx5e_sq *sq,
 +				struct mlx5e_umr_wqe *wqe,
 +				u16 ix)
 +{
 +	struct mlx5_wqe_ctrl_seg      *cseg = &wqe->ctrl;
 +	struct mlx5_wqe_umr_ctrl_seg *ucseg = &wqe->uctrl;
 +	struct mlx5_wqe_data_seg      *dseg = &wqe->data;
 +	struct mlx5e_mpw_info *wi = &rq->wqe_info[ix];
 +	u8 ds_cnt = DIV_ROUND_UP(sizeof(*wqe), MLX5_SEND_WQE_DS);
 +	u16 umr_wqe_mtt_offset = mlx5e_get_wqe_mtt_offset(rq->ix, ix);
 +
 +	memset(wqe, 0, sizeof(*wqe));
 +	cseg->opmod_idx_opcode =
 +		cpu_to_be32((sq->pc << MLX5_WQE_CTRL_WQE_INDEX_SHIFT) |
 +			    MLX5_OPCODE_UMR);
 +	cseg->qpn_ds    = cpu_to_be32((sq->sqn << MLX5_WQE_CTRL_QPN_SHIFT) |
 +				      ds_cnt);
 +	cseg->fm_ce_se  = MLX5_WQE_CTRL_CQ_UPDATE;
 +	cseg->imm       = rq->umr_mkey_be;
 +
 +	ucseg->flags = MLX5_UMR_TRANSLATION_OFFSET_EN;
 +	ucseg->klm_octowords =
 +		cpu_to_be16(mlx5e_get_mtt_octw(MLX5_MPWRQ_PAGES_PER_WQE));
 +	ucseg->bsf_octowords =
 +		cpu_to_be16(mlx5e_get_mtt_octw(umr_wqe_mtt_offset));
 +	ucseg->mkey_mask     = cpu_to_be64(MLX5_MKEY_MASK_FREE);
 +
 +	dseg->lkey = sq->mkey_be;
 +	dseg->addr = cpu_to_be64(wi->umr.mtt_addr);
 +}
 +
 +static void mlx5e_post_umr_wqe(struct mlx5e_rq *rq, u16 ix)
 +{
++=======
+ static inline void mlx5e_post_umr_wqe(struct mlx5e_rq *rq, u16 ix)
+ {
+ 	struct mlx5e_mpw_info *wi = &rq->wqe_info[ix];
++>>>>>>> 7e426671704d (net/mlx5e: Single flow order-0 pages for Striding RQ)
  	struct mlx5e_sq *sq = &rq->channel->icosq;
  	struct mlx5_wq_cyc *wq = &sq->wq;
  	struct mlx5e_umr_wqe *wqe;
@@@ -417,38 -325,21 +368,31 @@@ static inline int mlx5e_alloc_and_map_p
  	return 0;
  }
  
- static int mlx5e_alloc_rx_fragmented_mpwqe(struct mlx5e_rq *rq,
- 					   struct mlx5e_rx_wqe *wqe,
- 					   u16 ix)
+ static int mlx5e_alloc_rx_umr_mpwqe(struct mlx5e_rq *rq,
+ 				    struct mlx5e_rx_wqe *wqe,
+ 				    u16 ix)
  {
  	struct mlx5e_mpw_info *wi = &rq->wqe_info[ix];
++<<<<<<< HEAD
 +	int mtt_sz = mlx5e_get_wqe_mtt_sz();
 +	u32 dma_offset = mlx5e_get_wqe_mtt_offset(rq->ix, ix) << PAGE_SHIFT;
++=======
+ 	u64 dma_offset = (u64)mlx5e_get_wqe_mtt_offset(rq, ix) << PAGE_SHIFT;
+ 	int pg_strides = mlx5e_mpwqe_strides_per_page(rq);
+ 	int err;
++>>>>>>> 7e426671704d (net/mlx5e: Single flow order-0 pages for Striding RQ)
  	int i;
  
- 	wi->umr.dma_info = kmalloc(sizeof(*wi->umr.dma_info) *
- 				   MLX5_MPWRQ_PAGES_PER_WQE,
- 				   GFP_ATOMIC);
- 	if (unlikely(!wi->umr.dma_info))
- 		goto err_out;
- 
- 	/* We allocate more than mtt_sz as we will align the pointer */
- 	wi->umr.mtt_no_align = kzalloc(mtt_sz + MLX5_UMR_ALIGN - 1,
- 				       GFP_ATOMIC);
- 	if (unlikely(!wi->umr.mtt_no_align))
- 		goto err_free_umr;
- 
- 	wi->umr.mtt = PTR_ALIGN(wi->umr.mtt_no_align, MLX5_UMR_ALIGN);
- 	wi->umr.mtt_addr = dma_map_single(rq->pdev, wi->umr.mtt, mtt_sz,
- 					  PCI_DMA_TODEVICE);
- 	if (unlikely(dma_mapping_error(rq->pdev, wi->umr.mtt_addr)))
- 		goto err_free_mtt;
- 
  	for (i = 0; i < MLX5_MPWRQ_PAGES_PER_WQE; i++) {
- 		if (unlikely(mlx5e_alloc_and_map_page(rq, wi, i)))
+ 		err = mlx5e_alloc_and_map_page(rq, wi, i);
+ 		if (unlikely(err))
  			goto err_unmap;
++<<<<<<< HEAD
 +		atomic_add(mlx5e_mpwqe_strides_per_page(rq),
 +			   &wi->umr.dma_info[i].page->_count);
++=======
+ 		page_ref_add(wi->umr.dma_info[i].page, pg_strides);
++>>>>>>> 7e426671704d (net/mlx5e: Single flow order-0 pages for Striding RQ)
  		wi->skbs_frags[i] = 0;
  	}
  
@@@ -466,48 -352,40 +405,53 @@@ err_unmap
  	while (--i >= 0) {
  		dma_unmap_page(rq->pdev, wi->umr.dma_info[i].addr, PAGE_SIZE,
  			       PCI_DMA_FROMDEVICE);
++<<<<<<< HEAD
 +		atomic_sub(mlx5e_mpwqe_strides_per_page(rq),
 +			   &wi->umr.dma_info[i].page->_count);
++=======
+ 		page_ref_sub(wi->umr.dma_info[i].page, pg_strides);
++>>>>>>> 7e426671704d (net/mlx5e: Single flow order-0 pages for Striding RQ)
  		put_page(wi->umr.dma_info[i].page);
  	}
- 	dma_unmap_single(rq->pdev, wi->umr.mtt_addr, mtt_sz, PCI_DMA_TODEVICE);
- 
- err_free_mtt:
- 	kfree(wi->umr.mtt_no_align);
  
- err_free_umr:
- 	kfree(wi->umr.dma_info);
- 
- err_out:
- 	return -ENOMEM;
+ 	return err;
  }
  
- void mlx5e_free_rx_fragmented_mpwqe(struct mlx5e_rq *rq,
- 				    struct mlx5e_mpw_info *wi)
+ void mlx5e_free_rx_mpwqe(struct mlx5e_rq *rq, struct mlx5e_mpw_info *wi)
  {
- 	int mtt_sz = mlx5e_get_wqe_mtt_sz();
+ 	int pg_strides = mlx5e_mpwqe_strides_per_page(rq);
  	int i;
  
  	for (i = 0; i < MLX5_MPWRQ_PAGES_PER_WQE; i++) {
  		dma_unmap_page(rq->pdev, wi->umr.dma_info[i].addr, PAGE_SIZE,
  			       PCI_DMA_FROMDEVICE);
++<<<<<<< HEAD
 +		atomic_sub(mlx5e_mpwqe_strides_per_page(rq) - wi->skbs_frags[i],
 +			   &wi->umr.dma_info[i].page->_count);
++=======
+ 		page_ref_sub(wi->umr.dma_info[i].page,
+ 			     pg_strides - wi->skbs_frags[i]);
++>>>>>>> 7e426671704d (net/mlx5e: Single flow order-0 pages for Striding RQ)
  		put_page(wi->umr.dma_info[i].page);
  	}
- 	dma_unmap_single(rq->pdev, wi->umr.mtt_addr, mtt_sz, PCI_DMA_TODEVICE);
- 	kfree(wi->umr.mtt_no_align);
- 	kfree(wi->umr.dma_info);
  }
  
- void mlx5e_post_rx_fragmented_mpwqe(struct mlx5e_rq *rq)
+ void mlx5e_post_rx_mpwqe(struct mlx5e_rq *rq)
  {
  	struct mlx5_wq_ll *wq = &rq->wq;
  	struct mlx5e_rx_wqe *wqe = mlx5_wq_ll_get_wqe(wq, wq->head);
  
  	clear_bit(MLX5E_RQ_STATE_UMR_WQE_IN_PROGRESS, &rq->state);
++<<<<<<< HEAD
++=======
+ 
+ 	if (unlikely(test_bit(MLX5E_RQ_STATE_FLUSH, &rq->state))) {
+ 		mlx5e_free_rx_mpwqe(rq, &rq->wqe_info[wq->head]);
+ 		return;
+ 	}
+ 
++>>>>>>> 7e426671704d (net/mlx5e: Single flow order-0 pages for Striding RQ)
  	mlx5_wq_ll_push(wq, be16_to_cpu(wqe->next.next_wqe_index));
- 	rq->stats.mpwqe_frag++;
  
  	/* ensure wqes are visible to device before updating doorbell record */
  	dma_wmb();
@@@ -515,63 -393,7 +459,67 @@@
  	mlx5_wq_ll_update_db_record(wq);
  }
  
++<<<<<<< HEAD
 +static int mlx5e_alloc_rx_linear_mpwqe(struct mlx5e_rq *rq,
 +				       struct mlx5e_rx_wqe *wqe,
 +				       u16 ix)
 +{
 +	struct mlx5e_mpw_info *wi = &rq->wqe_info[ix];
 +	gfp_t gfp_mask;
 +	int i;
 +
 +	gfp_mask = GFP_ATOMIC | __GFP_COLD | __GFP_MEMALLOC;
 +	wi->dma_info.page = alloc_pages_node(NUMA_NO_NODE, gfp_mask,
 +					     MLX5_MPWRQ_WQE_PAGE_ORDER);
 +	if (unlikely(!wi->dma_info.page))
 +		return -ENOMEM;
 +
 +	wi->dma_info.addr = dma_map_page(rq->pdev, wi->dma_info.page, 0,
 +					 rq->wqe_sz, PCI_DMA_FROMDEVICE);
 +	if (unlikely(dma_mapping_error(rq->pdev, wi->dma_info.addr))) {
 +		put_page(wi->dma_info.page);
 +		return -ENOMEM;
 +	}
 +
 +	/* We split the high-order page into order-0 ones and manage their
 +	 * reference counter to minimize the memory held by small skb fragments
 +	 */
 +	split_page(wi->dma_info.page, MLX5_MPWRQ_WQE_PAGE_ORDER);
 +	for (i = 0; i < MLX5_MPWRQ_PAGES_PER_WQE; i++) {
 +		atomic_add(mlx5e_mpwqe_strides_per_page(rq),
 +			   &wi->dma_info.page[i]._count);
 +		wi->skbs_frags[i] = 0;
 +	}
 +
 +	wi->consumed_strides = 0;
 +	wi->dma_pre_sync = mlx5e_dma_pre_sync_linear_mpwqe;
 +	wi->add_skb_frag = mlx5e_add_skb_frag_linear_mpwqe;
 +	wi->copy_skb_header = mlx5e_copy_skb_header_linear_mpwqe;
 +	wi->free_wqe     = mlx5e_free_rx_linear_mpwqe;
 +	wqe->data.lkey = rq->mkey_be;
 +	wqe->data.addr = cpu_to_be64(wi->dma_info.addr);
 +
 +	return 0;
 +}
 +
 +void mlx5e_free_rx_linear_mpwqe(struct mlx5e_rq *rq,
 +				struct mlx5e_mpw_info *wi)
 +{
 +	int i;
 +
 +	dma_unmap_page(rq->pdev, wi->dma_info.addr, rq->wqe_sz,
 +		       PCI_DMA_FROMDEVICE);
 +	for (i = 0; i < MLX5_MPWRQ_PAGES_PER_WQE; i++) {
 +		atomic_sub(mlx5e_mpwqe_strides_per_page(rq) - wi->skbs_frags[i],
 +			   &wi->dma_info.page[i]._count);
 +		put_page(&wi->dma_info.page[i]);
 +	}
 +}
 +
 +int mlx5e_alloc_rx_mpwqe(struct mlx5e_rq *rq, struct mlx5e_rx_wqe *wqe, u16 ix)
++=======
+ int mlx5e_alloc_rx_mpwqe(struct mlx5e_rq *rq, struct mlx5e_rx_wqe *wqe,	u16 ix)
++>>>>>>> 7e426671704d (net/mlx5e: Single flow order-0 pages for Striding RQ)
  {
  	int err;
  
@@@ -592,29 -409,12 +535,29 @@@ void mlx5e_dealloc_rx_mpwqe(struct mlx5
  {
  	struct mlx5e_mpw_info *wi = &rq->wqe_info[ix];
  
- 	wi->free_wqe(rq, wi);
+ 	mlx5e_free_rx_mpwqe(rq, wi);
  }
  
 +void mlx5e_free_rx_descs(struct mlx5e_rq *rq)
 +{
 +	struct mlx5_wq_ll *wq = &rq->wq;
 +	struct mlx5e_rx_wqe *wqe;
 +	__be16 wqe_ix_be;
 +	u16 wqe_ix;
 +
 +	while (!mlx5_wq_ll_is_empty(wq)) {
 +		wqe_ix_be = *wq->tail_next;
 +		wqe_ix    = be16_to_cpu(wqe_ix_be);
 +		wqe       = mlx5_wq_ll_get_wqe(&rq->wq, wqe_ix);
 +		rq->dealloc_wqe(rq, wqe_ix);
 +		mlx5_wq_ll_pop(&rq->wq, wqe_ix_be,
 +			       &wqe->next.next_wqe_index);
 +	}
 +}
 +
  #define RQ_CANNOT_POST(rq) \
 -	(test_bit(MLX5E_RQ_STATE_FLUSH, &rq->state) || \
 -	 test_bit(MLX5E_RQ_STATE_UMR_WQE_IN_PROGRESS, &rq->state))
 +		(!test_bit(MLX5E_RQ_STATE_POST_WQES_ENABLE, &rq->state) || \
 +		 test_bit(MLX5E_RQ_STATE_UMR_WQE_IN_PROGRESS, &rq->state))
  
  bool mlx5e_post_rx_wqes(struct mlx5e_rq *rq)
  {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index b01f5bb32ed7..34edf70c3b6e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -58,12 +58,12 @@
 #define MLX5E_PARAMS_MAXIMUM_LOG_RQ_SIZE                0xd
 
 #define MLX5E_PARAMS_MINIMUM_LOG_RQ_SIZE_MPW            0x1
-#define MLX5E_PARAMS_DEFAULT_LOG_RQ_SIZE_MPW            0x4
+#define MLX5E_PARAMS_DEFAULT_LOG_RQ_SIZE_MPW            0x3
 #define MLX5E_PARAMS_MAXIMUM_LOG_RQ_SIZE_MPW            0x6
 
 #define MLX5_MPWRQ_LOG_STRIDE_SIZE		6  /* >= 6, HW restriction */
 #define MLX5_MPWRQ_LOG_STRIDE_SIZE_CQE_COMPRESS	8  /* >= 6, HW restriction */
-#define MLX5_MPWRQ_LOG_WQE_SZ			17
+#define MLX5_MPWRQ_LOG_WQE_SZ			18
 #define MLX5_MPWRQ_WQE_PAGE_ORDER  (MLX5_MPWRQ_LOG_WQE_SZ - PAGE_SHIFT > 0 ? \
 				    MLX5_MPWRQ_LOG_WQE_SZ - PAGE_SHIFT : 0)
 #define MLX5_MPWRQ_PAGES_PER_WQE		BIT(MLX5_MPWRQ_WQE_PAGE_ORDER)
@@ -251,8 +251,8 @@ struct mlx5e_rq {
 	u32                    wqe_sz;
 	struct sk_buff       **skb;
 	struct mlx5e_mpw_info *wqe_info;
+	void                  *mtt_no_align;
 	__be32                 mkey_be;
-	__be32                 umr_mkey_be;
 
 	struct device         *pdev;
 	struct net_device     *netdev;
@@ -278,32 +278,15 @@ struct mlx5e_rq {
 
 struct mlx5e_umr_dma_info {
 	__be64                *mtt;
-	__be64                *mtt_no_align;
 	dma_addr_t             mtt_addr;
-	struct mlx5e_dma_info *dma_info;
+	struct mlx5e_dma_info  dma_info[MLX5_MPWRQ_PAGES_PER_WQE];
+	struct mlx5e_umr_wqe   wqe;
 };
 
 struct mlx5e_mpw_info {
-	union {
-		struct mlx5e_dma_info     dma_info;
-		struct mlx5e_umr_dma_info umr;
-	};
+	struct mlx5e_umr_dma_info umr;
 	u16 consumed_strides;
 	u16 skbs_frags[MLX5_MPWRQ_PAGES_PER_WQE];
-
-	void (*dma_pre_sync)(struct device *pdev,
-			     struct mlx5e_mpw_info *wi,
-			     u32 wqe_offset, u32 len);
-	void (*add_skb_frag)(struct mlx5e_rq *rq,
-			     struct sk_buff *skb,
-			     struct mlx5e_mpw_info *wi,
-			     u32 page_idx, u32 frag_offset, u32 len);
-	void (*copy_skb_header)(struct device *pdev,
-				struct sk_buff *skb,
-				struct mlx5e_mpw_info *wi,
-				u32 page_idx, u32 offset,
-				u32 headlen);
-	void (*free_wqe)(struct mlx5e_rq *rq, struct mlx5e_mpw_info *wi);
 };
 
 struct mlx5e_tx_wqe_info {
@@ -539,24 +522,11 @@ void mlx5e_handle_rx_cqe(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
 void mlx5e_handle_rx_cqe_mpwrq(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
 bool mlx5e_post_rx_wqes(struct mlx5e_rq *rq);
 int mlx5e_alloc_rx_wqe(struct mlx5e_rq *rq, struct mlx5e_rx_wqe *wqe, u16 ix);
-int mlx5e_alloc_rx_mpwqe(struct mlx5e_rq *rq, struct mlx5e_rx_wqe *wqe, u16 ix);
+int mlx5e_alloc_rx_mpwqe(struct mlx5e_rq *rq, struct mlx5e_rx_wqe *wqe,	u16 ix);
 void mlx5e_dealloc_rx_wqe(struct mlx5e_rq *rq, u16 ix);
 void mlx5e_dealloc_rx_mpwqe(struct mlx5e_rq *rq, u16 ix);
-void mlx5e_post_rx_fragmented_mpwqe(struct mlx5e_rq *rq);
-void mlx5e_complete_rx_linear_mpwqe(struct mlx5e_rq *rq,
-				    struct mlx5_cqe64 *cqe,
-				    u16 byte_cnt,
-				    struct mlx5e_mpw_info *wi,
-				    struct sk_buff *skb);
-void mlx5e_complete_rx_fragmented_mpwqe(struct mlx5e_rq *rq,
-					struct mlx5_cqe64 *cqe,
-					u16 byte_cnt,
-					struct mlx5e_mpw_info *wi,
-					struct sk_buff *skb);
-void mlx5e_free_rx_linear_mpwqe(struct mlx5e_rq *rq,
-				struct mlx5e_mpw_info *wi);
-void mlx5e_free_rx_fragmented_mpwqe(struct mlx5e_rq *rq,
-				    struct mlx5e_mpw_info *wi);
+void mlx5e_post_rx_mpwqe(struct mlx5e_rq *rq);
+void mlx5e_free_rx_mpwqe(struct mlx5e_rq *rq, struct mlx5e_mpw_info *wi);
 struct mlx5_cqe64 *mlx5e_get_cqe(struct mlx5e_cq *cq);
 
 void mlx5e_update_stats(struct mlx5e_priv *priv);
@@ -628,6 +598,12 @@ static inline void mlx5e_cq_arm(struct mlx5e_cq *cq)
 	mlx5_cq_arm(mcq, MLX5_CQ_DB_REQ_NOT, mcq->uar->map, NULL, cq->wq.cc);
 }
 
+static inline u32 mlx5e_get_wqe_mtt_offset(struct mlx5e_rq *rq, u16 wqe_ix)
+{
+	return rq->mpwqe_mtt_offset +
+		wqe_ix * ALIGN(MLX5_MPWRQ_PAGES_PER_WQE, 8);
+}
+
 static inline int mlx5e_get_max_num_channels(struct mlx5_core_dev *mdev)
 {
 	return min_t(int, mdev->priv.eq_table.num_comp_vectors,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rx.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_stats.h b/drivers/net/ethernet/mellanox/mlx5/core/en_stats.h
index 499487ce3b53..1f56543feb63 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_stats.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_stats.h
@@ -73,7 +73,6 @@ struct mlx5e_sw_stats {
 	u64 tx_xmit_more;
 	u64 rx_wqe_err;
 	u64 rx_mpwqe_filler;
-	u64 rx_mpwqe_frag;
 	u64 rx_buff_alloc_err;
 	u64 rx_cqe_compress_blks;
 	u64 rx_cqe_compress_pkts;
@@ -105,7 +104,6 @@ static const struct counter_desc sw_stats_desc[] = {
 	{ MLX5E_DECLARE_STAT(struct mlx5e_sw_stats, tx_xmit_more) },
 	{ MLX5E_DECLARE_STAT(struct mlx5e_sw_stats, rx_wqe_err) },
 	{ MLX5E_DECLARE_STAT(struct mlx5e_sw_stats, rx_mpwqe_filler) },
-	{ MLX5E_DECLARE_STAT(struct mlx5e_sw_stats, rx_mpwqe_frag) },
 	{ MLX5E_DECLARE_STAT(struct mlx5e_sw_stats, rx_buff_alloc_err) },
 	{ MLX5E_DECLARE_STAT(struct mlx5e_sw_stats, rx_cqe_compress_blks) },
 	{ MLX5E_DECLARE_STAT(struct mlx5e_sw_stats, rx_cqe_compress_pkts) },
@@ -274,7 +272,6 @@ struct mlx5e_rq_stats {
 	u64 lro_bytes;
 	u64 wqe_err;
 	u64 mpwqe_filler;
-	u64 mpwqe_frag;
 	u64 buff_alloc_err;
 	u64 cqe_compress_blks;
 	u64 cqe_compress_pkts;
@@ -290,7 +287,6 @@ static const struct counter_desc rq_stats_desc[] = {
 	{ MLX5E_DECLARE_RX_STAT(struct mlx5e_rq_stats, lro_bytes) },
 	{ MLX5E_DECLARE_RX_STAT(struct mlx5e_rq_stats, wqe_err) },
 	{ MLX5E_DECLARE_RX_STAT(struct mlx5e_rq_stats, mpwqe_filler) },
-	{ MLX5E_DECLARE_RX_STAT(struct mlx5e_rq_stats, mpwqe_frag) },
 	{ MLX5E_DECLARE_RX_STAT(struct mlx5e_rq_stats, buff_alloc_err) },
 	{ MLX5E_DECLARE_RX_STAT(struct mlx5e_rq_stats, cqe_compress_blks) },
 	{ MLX5E_DECLARE_RX_STAT(struct mlx5e_rq_stats, cqe_compress_pkts) },
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c
index c38781fa567d..8159ee9905d1 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_txrx.c
@@ -85,7 +85,7 @@ static void mlx5e_poll_ico_cq(struct mlx5e_cq *cq)
 		case MLX5_OPCODE_NOP:
 			break;
 		case MLX5_OPCODE_UMR:
-			mlx5e_post_rx_fragmented_mpwqe(&sq->channel->rq);
+			mlx5e_post_rx_mpwqe(&sq->channel->rq);
 			break;
 		default:
 			WARN_ONCE(true,
