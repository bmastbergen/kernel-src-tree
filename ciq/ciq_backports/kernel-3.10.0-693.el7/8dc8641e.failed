HID: wacom: Use calculated pkglen for wireless touch interface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Use calculated pkglen for wireless touch interface (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.80%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 8dc8641e619228153ab0bc609f9f534126e87c08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8dc8641e.failed

Commit 01c846f introduced the 'wacom_compute_pktlen' function which
automatically determines the correct value for an interface's pkglen
by scanning the HID descriptor. This function returns the correct
value for the wireless receiver's touch interface, removing the need
for us to set it manually here.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.com>
(cherry picked from commit 8dc8641e619228153ab0bc609f9f534126e87c08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,a334332fbb8f..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -607,38 -454,19 +607,42 @@@ static int wacom_retrieve_hid_descripto
  	 */
  	if (features->type == WIRELESS) {
  		if (intf->cur_altsetting->desc.bInterfaceNumber == 0) {
 -			features->device_type = WACOM_DEVICETYPE_NONE;
 +			features->device_type = 0;
  		} else if (intf->cur_altsetting->desc.bInterfaceNumber == 2) {
++<<<<<<< HEAD
 +			features->device_type = BTN_TOOL_FINGER;
 +			features->pktlen = WACOM_PKGLEN_BBTOUCH3;
++=======
+ 			features->device_type |= WACOM_DEVICETYPE_TOUCH;
++>>>>>>> 8dc8641e6192 (HID: wacom: Use calculated pkglen for wireless touch interface)
 +		}
 +	}
 +
 +	/* only devices that support touch need to retrieve the info */
 +	if (features->type < BAMBOO_PT) {
 +		goto out;
 +	}
 +
 +	error = usb_get_extra_descriptor(interface, HID_DEVICET_HID, &hid_desc);
 +	if (error) {
 +		error = usb_get_extra_descriptor(&interface->endpoint[0],
 +						 HID_DEVICET_REPORT, &hid_desc);
 +		if (error) {
 +			dev_err(&intf->dev,
 +				"can not retrieve extra class descriptor\n");
 +			goto out;
  		}
  	}
 +	error = wacom_parse_hid(intf, hid_desc, features);
  
 -	wacom_parse_hid(hdev, features);
 + out:
 +	return error;
  }
  
 -struct wacom_hdev_data {
 +struct wacom_usbdev_data {
  	struct list_head list;
  	struct kref kref;
 -	struct hid_device *dev;
 +	struct usb_device *dev;
  	struct wacom_shared shared;
  };
  
* Unmerged path drivers/hid/wacom_sys.c
