mlxsw: spectrum: Add FDB lock to prevent session interleaving

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 366ce60315292a579b8ceae2777102e1954a2024
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/366ce603.failed

Dumping the FDB (invoked with a process context) or handling FDB
notifications (polled periodicly in delayed work) might each entail
multiple EMAD transcations due to the number of entries.

While we only allow one EMAD transaction at a time, there is nothing
stopping the dump and notification processing sessions from
interleaving. However, this is forbidden by the hardware, so we need to
make sure only one of these sessions can run at a time.

Solve this by adding a mutex ('fdb_lock'), as both kernel threads can
sleep while waiting for the response EMAD.

Fixes: 56ade8fe3f ("mlxsw: spectrum: Add initial support for Spectrum ASIC")
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 366ce60315292a579b8ceae2777102e1954a2024)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum.h
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum.h
index 199f91a62962,69281ca534b1..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
@@@ -120,16 -63,13 +120,24 @@@ struct mlxsw_sp 
  	} fdb_notify;
  #define MLXSW_SP_DEFAULT_AGEING_TIME 300
  	u32 ageing_time;
++<<<<<<< HEAD
 +	struct mlxsw_sp_upper master_bridge;
 +	struct mlxsw_sp_upper lags[MLXSW_SP_LAG_MAX];
++=======
+ 	struct mutex fdb_lock;	/* Make sure FDB sessions are atomic. */
+ 	struct {
+ 		struct net_device *dev;
+ 		unsigned int ref_count;
+ 	} master_bridge;
++>>>>>>> 366ce6031529 (mlxsw: spectrum: Add FDB lock to prevent session interleaving)
  };
  
 +static inline struct mlxsw_sp_upper *
 +mlxsw_sp_lag_get(struct mlxsw_sp *mlxsw_sp, u16 lag_id)
 +{
 +	return &mlxsw_sp->lags[lag_id];
 +}
 +
  struct mlxsw_sp_port_pcpu_stats {
  	u64			rx_packets;
  	u64			rx_bytes;
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
index 4cdc18e72222,80e266063aee..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
@@@ -1057,14 -650,7 +1057,18 @@@ static int mlxsw_sp_port_fdb_dump(struc
  	if (!sfd_pl)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	if (mlxsw_sp_port_is_vport(mlxsw_sp_port)) {
 +		u16 tmp;
 +
 +		tmp = mlxsw_sp_vport_vfid_get(mlxsw_sp_port);
 +		vport_fid = mlxsw_sp_vfid_to_fid(tmp);
 +		vport_vid = mlxsw_sp_vport_vid_get(mlxsw_sp_port);
 +	}
 +
++=======
+ 	mutex_lock(&mlxsw_sp_port->mlxsw_sp->fdb_lock);
++>>>>>>> 366ce6031529 (mlxsw: spectrum: Add FDB lock to prevent session interleaving)
  	mlxsw_reg_sfd_pack(sfd_pl, MLXSW_REG_SFD_OP_QUERY_DUMP, 0);
  	do {
  		mlxsw_reg_sfd_num_rec_set(sfd_pl, MLXSW_REG_SFD_REC_MAX_COUNT);
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum.h
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
