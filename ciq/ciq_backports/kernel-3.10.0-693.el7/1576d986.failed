tun: switch to use skb array for tx

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jason Wang <jasowang@redhat.com>
commit 1576d98605998fb59d121a39581129e134217182
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1576d986.failed

We used to queue tx packets in sk_receive_queue, this is less
efficient since it requires spinlocks to synchronize between producer
and consumer.

This patch tries to address this by:

- switch from sk_receive_queue to a skb_array, and resize it when
  tx_queue_len was changed.
- introduce a new proto_ops peek_len which was used for peeking the
  skb length.
- implement a tun version of peek_len for vhost_net to use and convert
  vhost_net to use peek_len if possible.

Pktgen test shows about 15.3% improvement on guest receiving pps for small
buffers:

Before: ~1300000pps
After : ~1500000pps

	Signed-off-by: Jason Wang <jasowang@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1576d98605998fb59d121a39581129e134217182)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/tun.c
#	include/linux/net.h
diff --cc drivers/net/tun.c
index 735ef7505ea1,74752159ec34..000000000000
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@@ -69,6 -69,9 +69,12 @@@
  #include <net/netns/generic.h>
  #include <net/rtnetlink.h>
  #include <net/sock.h>
++<<<<<<< HEAD
++=======
+ #include <linux/seq_file.h>
+ #include <linux/uio.h>
+ #include <linux/skb_array.h>
++>>>>>>> 1576d9860599 (tun: switch to use skb array for tx)
  
  #include <asm/uaccess.h>
  
@@@ -498,6 -515,16 +505,19 @@@ static struct tun_struct *tun_enable_qu
  	return tun;
  }
  
++<<<<<<< HEAD
++=======
+ static void tun_queue_purge(struct tun_file *tfile)
+ {
+ 	struct sk_buff *skb;
+ 
+ 	while ((skb = skb_array_consume(&tfile->tx_array)) != NULL)
+ 		kfree_skb(skb);
+ 
+ 	skb_queue_purge(&tfile->sk.sk_error_queue);
+ }
+ 
++>>>>>>> 1576d9860599 (tun: switch to use skb array for tx)
  static void __tun_detach(struct tun_file *tfile, bool clean)
  {
  	struct tun_file *ntfile;
@@@ -539,10 -566,9 +559,16 @@@
  			    tun->dev->reg_state == NETREG_REGISTERED)
  				unregister_netdevice(tun->dev);
  		}
++<<<<<<< HEAD
 +
 +		BUG_ON(!test_bit(SOCK_EXTERNALLY_ALLOCATED,
 +				 &tfile->socket.flags));
 +		sk_release_kernel(&tfile->sk);
++=======
+ 		if (tun)
+ 			skb_array_cleanup(&tfile->tx_array);
+ 		sock_put(&tfile->sk);
++>>>>>>> 1576d9860599 (tun: switch to use skb array for tx)
  	}
  }
  
@@@ -620,7 -650,16 +647,14 @@@ static int tun_attach(struct tun_struc
  		if (!err)
  			goto out;
  	}
+ 
+ 	if (!tfile->detached &&
+ 	    skb_array_init(&tfile->tx_array, dev->tx_queue_len, GFP_KERNEL)) {
+ 		err = -ENOMEM;
+ 		goto out;
+ 	}
+ 
  	tfile->queue_index = tun->numqueues;
 -	tfile->socket.sk->sk_shutdown &= ~RCV_SHUTDOWN;
  	rcu_assign_pointer(tfile->tun, tun);
  	rcu_assign_pointer(tun->tfiles[tun->numqueues], tfile);
  	tun->numqueues++;
@@@ -1061,9 -1121,9 +1095,9 @@@ static unsigned int tun_chr_poll(struc
  
  	tun_debug(KERN_INFO, tun, "tun_chr_poll\n");
  
 -	poll_wait(file, sk_sleep(sk), wait);
 +	poll_wait(file, &tfile->wq.wait, wait);
  
- 	if (!skb_queue_empty(&sk->sk_receive_queue))
+ 	if (!skb_array_empty(&tfile->tx_array))
  		mask |= POLLIN | POLLRDNORM;
  
  	if (sock_writeable(sk) ||
@@@ -1543,52 -1442,69 +1577,104 @@@ done
  	return total;
  }
  
+ static struct sk_buff *tun_ring_recv(struct tun_file *tfile, int noblock,
+ 				     int *err)
+ {
+ 	DECLARE_WAITQUEUE(wait, current);
+ 	struct sk_buff *skb = NULL;
+ 
+ 	skb = skb_array_consume(&tfile->tx_array);
+ 	if (skb)
+ 		goto out;
+ 	if (noblock) {
+ 		*err = -EAGAIN;
+ 		goto out;
+ 	}
+ 
+ 	add_wait_queue(&tfile->wq.wait, &wait);
+ 	current->state = TASK_INTERRUPTIBLE;
+ 
+ 	while (1) {
+ 		skb = skb_array_consume(&tfile->tx_array);
+ 		if (skb)
+ 			break;
+ 		if (signal_pending(current)) {
+ 			*err = -ERESTARTSYS;
+ 			break;
+ 		}
+ 		if (tfile->socket.sk->sk_shutdown & RCV_SHUTDOWN) {
+ 			*err = -EFAULT;
+ 			break;
+ 		}
+ 
+ 		schedule();
+ 	}
+ 
+ 	current->state = TASK_RUNNING;
+ 	remove_wait_queue(&tfile->wq.wait, &wait);
+ 
+ out:
+ 	return skb;
+ }
+ 
  static ssize_t tun_do_read(struct tun_struct *tun, struct tun_file *tfile,
 -			   struct iov_iter *to,
 -			   int noblock)
 +			   struct kiocb *iocb, const struct iovec *iv,
 +			   ssize_t len, int noblock)
  {
 +	DECLARE_WAITQUEUE(wait, current);
  	struct sk_buff *skb;
++<<<<<<< HEAD
 +	ssize_t ret = 0;
++=======
+ 	ssize_t ret;
+ 	int err;
++>>>>>>> 1576d9860599 (tun: switch to use skb array for tx)
  
  	tun_debug(KERN_INFO, tun, "tun_do_read\n");
  
 -	if (!iov_iter_count(to))
 -		return 0;
 +	if (unlikely(!noblock))
 +		add_wait_queue(&tfile->wq.wait, &wait);
 +	while (len) {
 +		current->state = TASK_INTERRUPTIBLE;
  
++<<<<<<< HEAD
 +		/* Read frames from the queue */
 +		if (!(skb = skb_dequeue(&tfile->socket.sk->sk_receive_queue))) {
 +			if (noblock) {
 +				ret = -EAGAIN;
 +				break;
 +			}
 +			if (signal_pending(current)) {
 +				ret = -ERESTARTSYS;
 +				break;
 +			}
 +			if (tun->dev->reg_state != NETREG_REGISTERED) {
 +				ret = -EIO;
 +				break;
 +			}
++=======
+ 	/* Read frames from ring */
+ 	skb = tun_ring_recv(tfile, noblock, &err);
+ 	if (!skb)
+ 		return err;
++>>>>>>> 1576d9860599 (tun: switch to use skb array for tx)
  
 -	ret = tun_put_user(tun, tfile, skb, to);
 -	if (unlikely(ret < 0))
 -		kfree_skb(skb);
 -	else
 -		consume_skb(skb);
 +			/* Nothing to read, let's sleep */
 +			schedule();
 +			continue;
 +		}
 +
 +		ret = tun_put_user(tun, tfile, skb, iv, len);
 +		if (unlikely(ret < 0))
 +			kfree_skb(skb);
 +		else
 +			consume_skb(skb);
 +		break;
 +	}
 +
 +	current->state = TASK_RUNNING;
 +	if (unlikely(!noblock))
 +		remove_wait_queue(&tfile->wq.wait, &wait);
  
  	return ret;
  }
@@@ -1718,18 -1629,27 +1804,36 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int tun_release(struct socket *sock)
 +{
 +	if (sock->sk)
 +		sock_put(sock->sk);
 +	return 0;
++=======
+ static int tun_peek_len(struct socket *sock)
+ {
+ 	struct tun_file *tfile = container_of(sock, struct tun_file, socket);
+ 	struct tun_struct *tun;
+ 	int ret = 0;
+ 
+ 	tun = __tun_get(tfile);
+ 	if (!tun)
+ 		return 0;
+ 
+ 	ret = skb_array_peek_len(&tfile->tx_array);
+ 	tun_put(tun);
+ 
+ 	return ret;
++>>>>>>> 1576d9860599 (tun: switch to use skb array for tx)
  }
  
  /* Ops structure to mimic raw sockets with tun */
  static const struct proto_ops tun_socket_ops = {
+ 	.peek_len = tun_peek_len,
  	.sendmsg = tun_sendmsg,
  	.recvmsg = tun_recvmsg,
 +	.release = tun_release,
  };
  
  static struct proto tun_proto = {
@@@ -2521,8 -2466,56 +2625,55 @@@ static const struct ethtool_ops tun_eth
  	.get_msglevel	= tun_get_msglevel,
  	.set_msglevel	= tun_set_msglevel,
  	.get_link	= ethtool_op_get_link,
 -	.get_ts_info	= ethtool_op_get_ts_info,
  };
  
+ static int tun_queue_resize(struct tun_struct *tun)
+ {
+ 	struct net_device *dev = tun->dev;
+ 	struct tun_file *tfile;
+ 	struct skb_array **arrays;
+ 	int n = tun->numqueues + tun->numdisabled;
+ 	int ret, i;
+ 
+ 	arrays = kmalloc(sizeof *arrays * n, GFP_KERNEL);
+ 	if (!arrays)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < tun->numqueues; i++) {
+ 		tfile = rtnl_dereference(tun->tfiles[i]);
+ 		arrays[i] = &tfile->tx_array;
+ 	}
+ 	list_for_each_entry(tfile, &tun->disabled, next)
+ 		arrays[i++] = &tfile->tx_array;
+ 
+ 	ret = skb_array_resize_multiple(arrays, n,
+ 					dev->tx_queue_len, GFP_KERNEL);
+ 
+ 	kfree(arrays);
+ 	return ret;
+ }
+ 
+ static int tun_device_event(struct notifier_block *unused,
+ 			    unsigned long event, void *ptr)
+ {
+ 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+ 	struct tun_struct *tun = netdev_priv(dev);
+ 
+ 	switch (event) {
+ 	case NETDEV_CHANGE_TX_QUEUE_LEN:
+ 		if (tun_queue_resize(tun))
+ 			return NOTIFY_BAD;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return NOTIFY_DONE;
+ }
+ 
+ static struct notifier_block tun_notifier_block __read_mostly = {
+ 	.notifier_call	= tun_device_event,
+ };
  
  static int __init tun_init(void)
  {
diff --cc include/linux/net.h
index b2a81ac8dc15,b9f0ff4d489c..000000000000
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@@ -183,8 -184,8 +183,13 @@@ struct proto_ops 
  				      int offset, size_t size, int flags);
  	ssize_t 	(*splice_read)(struct socket *sock,  loff_t *ppos,
  				       struct pipe_inode_info *pipe, size_t len, unsigned int flags);
++<<<<<<< HEAD
 +	RH_KABI_REPLACE(void		(*set_peek_off)(struct sock *sk, int val),
 +			int		(*set_peek_off)(struct sock *sk, int val))
++=======
+ 	int		(*set_peek_off)(struct sock *sk, int val);
+ 	int		(*peek_len)(struct socket *sock);
++>>>>>>> 1576d9860599 (tun: switch to use skb array for tx)
  };
  
  #define DECLARE_SOCKADDR(type, dst, src)	\
* Unmerged path drivers/net/tun.c
diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index 13cfb2d2863d..af4edc98f0eb 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -503,10 +503,14 @@ out:
 
 static int peek_head_len(struct sock *sk)
 {
+	struct socket *sock = sk->sk_socket;
 	struct sk_buff *head;
 	int len = 0;
 	unsigned long flags;
 
+	if (sock->ops->peek_len)
+		return sock->ops->peek_len(sock);
+
 	spin_lock_irqsave(&sk->sk_receive_queue.lock, flags);
 	head = skb_peek(&sk->sk_receive_queue);
 	if (likely(head)) {
@@ -519,6 +523,16 @@ static int peek_head_len(struct sock *sk)
 	return len;
 }
 
+static int sk_has_rx_data(struct sock *sk)
+{
+	struct socket *sock = sk->sk_socket;
+
+	if (sock->ops->peek_len)
+		return sock->ops->peek_len(sock);
+
+	return skb_queue_empty(&sk->sk_receive_queue);
+}
+
 static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk)
 {
 	struct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_TX];
@@ -535,7 +549,7 @@ static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk)
 		endtime = busy_clock() + vq->busyloop_timeout;
 
 		while (vhost_can_busy_poll(&net->dev, endtime) &&
-		       skb_queue_empty(&sk->sk_receive_queue) &&
+		       !sk_has_rx_data(sk) &&
 		       vhost_vq_avail_empty(&net->dev, vq))
 			cpu_relax();
 
* Unmerged path include/linux/net.h
