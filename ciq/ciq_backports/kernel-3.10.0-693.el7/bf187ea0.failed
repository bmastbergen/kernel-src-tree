nfp: centralize the buffer size calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit bf187ea01b07739167420088adb385f9385a7c7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/bf187ea0.failed

Add a helper function to calculate the buffer size at run time.
Buffer lengths will now depend on the FW prepend configuration
instead of assuming the most space consuming configuration and
defaulting to 2k buffers at initialization time.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bf187ea01b07739167420088adb385f9385a7c7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 8344e8e82257,77c645abb827..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -2209,14 -2202,9 +2222,14 @@@ static int nfp_net_change_mtu(struct ne
  	struct nfp_net_rx_ring *tmp_rings;
  	int err;
  
 +	if (new_mtu < 68 || new_mtu > nn->max_mtu) {
 +		nn_err(nn, "New MTU (%d) is not valid\n", new_mtu);
 +		return -EINVAL;
 +	}
 +
  	old_mtu = netdev->mtu;
  	old_fl_bufsz = nn->fl_bufsz;
- 	new_fl_bufsz = NFP_NET_MAX_PREPEND + ETH_HLEN + VLAN_HLEN * 2 + new_mtu;
+ 	new_fl_bufsz = nfp_net_calc_fl_bufsz(nn, new_mtu);
  
  	if (!netif_running(netdev)) {
  		netdev->mtu = new_mtu;
@@@ -2795,18 -2826,6 +2814,21 @@@ int nfp_net_netdev_init(struct net_devi
  		nn->ctrl |= NFP_NET_CFG_CTRL_IRQMOD;
  	}
  
++<<<<<<< HEAD
 +	/* On NFP-3200 enable MSI-X auto-masking, if supported and the
 +	 * interrupts are not shared.
 +	 */
 +	if (nn->is_nfp3200 && nn->cap & NFP_NET_CFG_CTRL_MSIXAUTO)
 +		nn->ctrl |= NFP_NET_CFG_CTRL_MSIXAUTO;
 +
 +	/* On NFP4000/NFP6000, determine RX packet/metadata boundary offset */
 +	if (nn->fw_ver.major >= 2)
 +		nn->rx_offset = nn_readl(nn, NFP_NET_CFG_RX_OFFSET);
 +	else
 +		nn->rx_offset = NFP_NET_RX_OFFSET;
 +
++=======
++>>>>>>> bf187ea01b07 (nfp: centralize the buffer size calculation)
  	/* Stash the re-configuration queue away.  First odd queue in TX Bar */
  	nn->qcp_cfg = nn->tx_bar + NFP_QCP_QUEUE_ADDR_SZ;
  
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net.h b/drivers/net/ethernet/netronome/nfp/nfp_net.h
index b7c0ef360c21..6ee082e8b34e 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@ -72,7 +72,6 @@
 
 /* Default size for MTU and freelist buffer sizes */
 #define NFP_NET_DEFAULT_MTU		1500
-#define NFP_NET_DEFAULT_RX_BUFSZ	2048
 
 /* Maximum number of bytes prepended to a packet */
 #define NFP_NET_MAX_PREPEND		64
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
