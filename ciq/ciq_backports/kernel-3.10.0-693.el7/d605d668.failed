net/mlx5e: Add support for ethtool self diagnostics test

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Add support for ethtool self diagnostics test (Don Dutile) [1386660 1385330 1417286]
Rebuild_FUZZ: 96.30%
commit-author Kamal Heib <kamalh@mellanox.com>
commit d605d6686dc7e7c767cd2dbf89a4ebd195891212
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d605d668.failed

The self diagnostics test implementaion include the following features:
1. Link Test: Check that link is in up state.
2. Speed Test: Check that link was negotiated correctly.
3. Health Test: Check the device health.

	Signed-off-by: Kamal Heib <kamalh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d605d6686dc7e7c767cd2dbf89a4ebd195891212)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 3784a00cd751,9f43beb86250..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -1,12 -1,13 +1,19 @@@
  obj-$(CONFIG_MLX5_CORE)		+= mlx5_core.o
  
  mlx5_core-y :=	main.o cmd.o debugfs.o fw.o eq.o uar.o pagealloc.o \
 -		health.o mcg.o cq.o srq.o alloc.o qp.o port.o mr.o pd.o \
 -		mad.o transobj.o vport.o sriov.o fs_cmd.o fs_core.o \
 -		fs_counters.o rl.o lag.o dev.o
 +		health.o mcg.o cq.o srq.o alloc.o qp.o port.o mr.o pd.o   \
 +		mad.o transobj.o vport.o sriov.o fs_cmd.o fs_core.o
  
++<<<<<<< HEAD
 +mlx5_core-$(CONFIG_MLX5_CORE_EN) += wq.o eswitch.o \
 +		en_main.o en_fs.o en_ethtool.o en_tx.o en_rx.o \
 +		en_txrx.o en_clock.o
++=======
+ mlx5_core-$(CONFIG_MLX5_CORE_EN) += wq.o eswitch.o eswitch_offloads.o \
+ 		en_main.o en_common.o en_fs.o en_ethtool.o en_tx.o \
+ 		en_rx.o en_rx_am.o en_txrx.o en_clock.o vxlan.o \
+ 		en_tc.o en_arfs.o en_rep.o en_fs_ethtool.o en_selftest.o
++>>>>>>> d605d6686dc7 (net/mlx5e: Add support for ethtool self diagnostics test)
  
 +mlx5_core-$(CONFIG_MLX5_CORE_EN_VXLAN) += vxlan.o
  mlx5_core-$(CONFIG_MLX5_CORE_EN_DCB) +=  en_dcbnl.o
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index b01f5bb32ed7,f7bb4a7fb981..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -539,31 -739,36 +541,51 @@@ void mlx5e_handle_rx_cqe(struct mlx5e_r
  void mlx5e_handle_rx_cqe_mpwrq(struct mlx5e_rq *rq, struct mlx5_cqe64 *cqe);
  bool mlx5e_post_rx_wqes(struct mlx5e_rq *rq);
  int mlx5e_alloc_rx_wqe(struct mlx5e_rq *rq, struct mlx5e_rx_wqe *wqe, u16 ix);
 -int mlx5e_alloc_rx_mpwqe(struct mlx5e_rq *rq, struct mlx5e_rx_wqe *wqe,	u16 ix);
 +int mlx5e_alloc_rx_mpwqe(struct mlx5e_rq *rq, struct mlx5e_rx_wqe *wqe, u16 ix);
  void mlx5e_dealloc_rx_wqe(struct mlx5e_rq *rq, u16 ix);
  void mlx5e_dealloc_rx_mpwqe(struct mlx5e_rq *rq, u16 ix);
 -void mlx5e_post_rx_mpwqe(struct mlx5e_rq *rq);
 -void mlx5e_free_rx_mpwqe(struct mlx5e_rq *rq, struct mlx5e_mpw_info *wi);
 +void mlx5e_post_rx_fragmented_mpwqe(struct mlx5e_rq *rq);
 +void mlx5e_complete_rx_linear_mpwqe(struct mlx5e_rq *rq,
 +				    struct mlx5_cqe64 *cqe,
 +				    u16 byte_cnt,
 +				    struct mlx5e_mpw_info *wi,
 +				    struct sk_buff *skb);
 +void mlx5e_complete_rx_fragmented_mpwqe(struct mlx5e_rq *rq,
 +					struct mlx5_cqe64 *cqe,
 +					u16 byte_cnt,
 +					struct mlx5e_mpw_info *wi,
 +					struct sk_buff *skb);
 +void mlx5e_free_rx_linear_mpwqe(struct mlx5e_rq *rq,
 +				struct mlx5e_mpw_info *wi);
 +void mlx5e_free_rx_fragmented_mpwqe(struct mlx5e_rq *rq,
 +				    struct mlx5e_mpw_info *wi);
  struct mlx5_cqe64 *mlx5e_get_cqe(struct mlx5e_cq *cq);
  
 -void mlx5e_rx_am(struct mlx5e_rq *rq);
 -void mlx5e_rx_am_work(struct work_struct *work);
 -struct mlx5e_cq_moder mlx5e_am_get_def_profile(u8 rx_cq_period_mode);
 -
  void mlx5e_update_stats(struct mlx5e_priv *priv);
  
++<<<<<<< HEAD
 +int mlx5e_create_flow_tables(struct mlx5e_priv *priv);
 +void mlx5e_destroy_flow_tables(struct mlx5e_priv *priv);
 +void mlx5e_init_eth_addr(struct mlx5e_priv *priv);
++=======
+ int mlx5e_create_flow_steering(struct mlx5e_priv *priv);
+ void mlx5e_destroy_flow_steering(struct mlx5e_priv *priv);
+ void mlx5e_init_l2_addr(struct mlx5e_priv *priv);
+ void mlx5e_destroy_flow_table(struct mlx5e_flow_table *ft);
+ int mlx5e_self_test_num(struct mlx5e_priv *priv);
+ void mlx5e_self_test(struct net_device *ndev, struct ethtool_test *etest,
+ 		     u64 *buf);
+ int mlx5e_ethtool_get_flow(struct mlx5e_priv *priv, struct ethtool_rxnfc *info,
+ 			   int location);
+ int mlx5e_ethtool_get_all_flows(struct mlx5e_priv *priv,
+ 				struct ethtool_rxnfc *info, u32 *rule_locs);
+ int mlx5e_ethtool_flow_replace(struct mlx5e_priv *priv,
+ 			       struct ethtool_rx_flow_spec *fs);
+ int mlx5e_ethtool_flow_remove(struct mlx5e_priv *priv,
+ 			      int location);
+ void mlx5e_ethtool_init_steering(struct mlx5e_priv *priv);
+ void mlx5e_ethtool_cleanup_steering(struct mlx5e_priv *priv);
++>>>>>>> d605d6686dc7 (net/mlx5e: Add support for ethtool self diagnostics test)
  void mlx5e_set_rx_mode_work(struct work_struct *work);
  
  void mlx5e_fill_hwstamp(struct mlx5e_tstamp *clock, u64 timestamp,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index fa6e9bbc23fb..24cd6c449991 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@ -179,6 +179,8 @@ static int mlx5e_get_sset_count(struct net_device *dev, int sset)
 
 	case ETH_SS_PRIV_FLAGS:
 		return ARRAY_SIZE(mlx5e_priv_flags);
+	case ETH_SS_TEST:
+		return mlx5e_self_test_num(priv);
 	/* fallthrough */
 	default:
 		return -EOPNOTSUPP;
@@ -277,6 +279,9 @@ static void mlx5e_get_strings(struct net_device *dev,
 		break;
 
 	case ETH_SS_TEST:
+		for (i = 0; i < mlx5e_self_test_num(priv); i++)
+			strcpy(data + i * ETH_GSTRING_LEN,
+			       mlx5e_self_tests[i]);
 		break;
 
 	case ETH_SS_STATS:
@@ -1421,5 +1426,6 @@ const struct ethtool_ops mlx5e_ethtool_ops = {
 	.get_module_info   = mlx5e_get_module_info,
 	.get_module_eeprom = mlx5e_get_module_eeprom,
 	.get_priv_flags    = mlx5e_get_priv_flags,
-	.set_priv_flags    = mlx5e_set_priv_flags
+	.set_priv_flags    = mlx5e_set_priv_flags,
+	.self_test         = mlx5e_self_test,
 };
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c b/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c
new file mode 100644
index 000000000000..49504a7eff20
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2016, Mellanox Technologies, Ltd.  All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include "en.h"
+
+enum {
+	MLX5E_ST_LINK_STATE,
+	MLX5E_ST_LINK_SPEED,
+	MLX5E_ST_HEALTH_INFO,
+	MLX5E_ST_NUM,
+};
+
+const char mlx5e_self_tests[MLX5E_ST_NUM][ETH_GSTRING_LEN] = {
+	"Link Test",
+	"Speed Test",
+	"Health Test",
+};
+
+int mlx5e_self_test_num(struct mlx5e_priv *priv)
+{
+	return ARRAY_SIZE(mlx5e_self_tests);
+}
+
+static int mlx5e_test_health_info(struct mlx5e_priv *priv)
+{
+	struct mlx5_core_health *health = &priv->mdev->priv.health;
+
+	return health->sick ? 1 : 0;
+}
+
+static int mlx5e_test_link_state(struct mlx5e_priv *priv)
+{
+	u8 port_state;
+
+	if (!netif_carrier_ok(priv->netdev))
+		return 1;
+
+	port_state = mlx5_query_vport_state(priv->mdev, MLX5_QUERY_VPORT_STATE_IN_OP_MOD_VNIC_VPORT, 0);
+	return port_state == VPORT_STATE_UP ? 0 : 1;
+}
+
+static int mlx5e_test_link_speed(struct mlx5e_priv *priv)
+{
+	u32 out[MLX5_ST_SZ_DW(ptys_reg)];
+	u32 eth_proto_oper;
+	int i;
+
+	if (!netif_carrier_ok(priv->netdev))
+		return 1;
+
+	if (mlx5_query_port_ptys(priv->mdev, out, sizeof(out), MLX5_PTYS_EN, 1))
+		return 1;
+
+	eth_proto_oper = MLX5_GET(ptys_reg, out, eth_proto_oper);
+	for (i = 0; i < MLX5E_LINK_MODES_NUMBER; i++) {
+		if (eth_proto_oper & MLX5E_PROT_MASK(i))
+			return 0;
+	}
+	return 1;
+}
+
+static int (*mlx5e_st_func[MLX5E_ST_NUM])(struct mlx5e_priv *) = {
+	mlx5e_test_link_state,
+	mlx5e_test_link_speed,
+	mlx5e_test_health_info,
+};
+
+void mlx5e_self_test(struct net_device *ndev, struct ethtool_test *etest,
+		     u64 *buf)
+{
+	struct mlx5e_priv *priv = netdev_priv(ndev);
+	int i;
+
+	memset(buf, 0, sizeof(u64) * MLX5E_ST_NUM);
+
+	mutex_lock(&priv->state_lock);
+	netdev_info(ndev, "Self test begin..\n");
+
+	for (i = 0; i < MLX5E_ST_NUM; i++) {
+		netdev_info(ndev, "\t[%d] %s start..\n",
+			    i, mlx5e_self_tests[i]);
+		buf[i] = mlx5e_st_func[i](priv);
+		netdev_info(ndev, "\t[%d] %s end: result(%lld)\n",
+			    i, mlx5e_self_tests[i], buf[i]);
+	}
+
+	mutex_unlock(&priv->state_lock);
+
+	for (i = 0; i < MLX5E_ST_NUM; i++) {
+		if (buf[i]) {
+			etest->flags |= ETH_TEST_FL_FAILED;
+			break;
+		}
+	}
+	netdev_info(ndev, "Self test out: status flags(0x%x)\n",
+		    etest->flags);
+}
