drm/amdgpu: Program ring for vce instance 1 at its register space

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [drm] amdgpu: Program ring for vce instance 1 at its register space (Rob Clark) [1458391]
Rebuild_FUZZ: 96.83%
commit-author Leo Liu <leo.liu@amd.com>
commit 45cc6586b7a73e84a8806881122b6ec306cdc9e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/45cc6586.failed

We need program ring buffer on instance 1 register space domain,
when only if instance 1 available, with two instances or instance 0,
and we need only program instance 0 regsiter space domain for ring.

	Signed-off-by: Leo Liu <leo.liu@amd.com>
	Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 45cc6586b7a73e84a8806881122b6ec306cdc9e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdgpu/vce_v3_0.c
diff --cc drivers/gpu/drm/amd/amdgpu/vce_v3_0.c
index ce468ee5da2a,90332f55cfba..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c
@@@ -59,14 -74,29 +59,35 @@@ static void vce_v3_0_set_irq_funcs(stru
   *
   * Returns the current hardware read pointer
   */
 -static uint64_t vce_v3_0_ring_get_rptr(struct amdgpu_ring *ring)
 +static uint32_t vce_v3_0_ring_get_rptr(struct amdgpu_ring *ring)
  {
  	struct amdgpu_device *adev = ring->adev;
+ 	u32 v;
+ 
+ 	mutex_lock(&adev->grbm_idx_mutex);
+ 	if (adev->vce.harvest_config == 0 ||
+ 		adev->vce.harvest_config == AMDGPU_VCE_HARVEST_VCE1)
+ 		WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(0));
+ 	else if (adev->vce.harvest_config == AMDGPU_VCE_HARVEST_VCE0)
+ 		WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(1));
  
  	if (ring == &adev->vce.ring[0])
++<<<<<<< HEAD
 +		return RREG32(mmVCE_RB_RPTR);
 +	else
 +		return RREG32(mmVCE_RB_RPTR2);
++=======
+ 		v = RREG32(mmVCE_RB_RPTR);
+ 	else if (ring == &adev->vce.ring[1])
+ 		v = RREG32(mmVCE_RB_RPTR2);
+ 	else
+ 		v = RREG32(mmVCE_RB_RPTR3);
+ 
+ 	WREG32(mmGRBM_GFX_INDEX, mmGRBM_GFX_INDEX_DEFAULT);
+ 	mutex_unlock(&adev->grbm_idx_mutex);
+ 
+ 	return v;
++>>>>>>> 45cc6586b7a7 (drm/amdgpu: Program ring for vce instance 1 at its register space)
  }
  
  /**
@@@ -76,14 -106,29 +97,35 @@@
   *
   * Returns the current hardware write pointer
   */
 -static uint64_t vce_v3_0_ring_get_wptr(struct amdgpu_ring *ring)
 +static uint32_t vce_v3_0_ring_get_wptr(struct amdgpu_ring *ring)
  {
  	struct amdgpu_device *adev = ring->adev;
+ 	u32 v;
+ 
+ 	mutex_lock(&adev->grbm_idx_mutex);
+ 	if (adev->vce.harvest_config == 0 ||
+ 		adev->vce.harvest_config == AMDGPU_VCE_HARVEST_VCE1)
+ 		WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(0));
+ 	else if (adev->vce.harvest_config == AMDGPU_VCE_HARVEST_VCE0)
+ 		WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(1));
  
  	if (ring == &adev->vce.ring[0])
++<<<<<<< HEAD
 +		return RREG32(mmVCE_RB_WPTR);
 +	else
 +		return RREG32(mmVCE_RB_WPTR2);
++=======
+ 		v = RREG32(mmVCE_RB_WPTR);
+ 	else if (ring == &adev->vce.ring[1])
+ 		v = RREG32(mmVCE_RB_WPTR2);
+ 	else
+ 		v = RREG32(mmVCE_RB_WPTR3);
+ 
+ 	WREG32(mmGRBM_GFX_INDEX, mmGRBM_GFX_INDEX_DEFAULT);
+ 	mutex_unlock(&adev->grbm_idx_mutex);
+ 
+ 	return v;
++>>>>>>> 45cc6586b7a7 (drm/amdgpu: Program ring for vce instance 1 at its register space)
  }
  
  /**
@@@ -97,10 -142,22 +139,24 @@@ static void vce_v3_0_ring_set_wptr(stru
  {
  	struct amdgpu_device *adev = ring->adev;
  
+ 	mutex_lock(&adev->grbm_idx_mutex);
+ 	if (adev->vce.harvest_config == 0 ||
+ 		adev->vce.harvest_config == AMDGPU_VCE_HARVEST_VCE1)
+ 		WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(0));
+ 	else if (adev->vce.harvest_config == AMDGPU_VCE_HARVEST_VCE0)
+ 		WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(1));
+ 
  	if (ring == &adev->vce.ring[0])
 -		WREG32(mmVCE_RB_WPTR, lower_32_bits(ring->wptr));
 -	else if (ring == &adev->vce.ring[1])
 -		WREG32(mmVCE_RB_WPTR2, lower_32_bits(ring->wptr));
 +		WREG32(mmVCE_RB_WPTR, ring->wptr);
  	else
++<<<<<<< HEAD
 +		WREG32(mmVCE_RB_WPTR2, ring->wptr);
++=======
+ 		WREG32(mmVCE_RB_WPTR3, lower_32_bits(ring->wptr));
+ 
+ 	WREG32(mmGRBM_GFX_INDEX, mmGRBM_GFX_INDEX_DEFAULT);
+ 	mutex_unlock(&adev->grbm_idx_mutex);
++>>>>>>> 45cc6586b7a7 (drm/amdgpu: Program ring for vce instance 1 at its register space)
  }
  
  static void vce_v3_0_override_vce_clock_gating(struct amdgpu_device *adev, bool override)
@@@ -215,7 -265,7 +271,11 @@@ static void vce_v3_0_set_vce_sw_clock_g
  static int vce_v3_0_start(struct amdgpu_device *adev)
  {
  	struct amdgpu_ring *ring;
++<<<<<<< HEAD
 +	int idx, i, j, r;
++=======
+ 	int idx, r;
++>>>>>>> 45cc6586b7a7 (drm/amdgpu: Program ring for vce instance 1 at its register space)
  
  	mutex_lock(&adev->grbm_idx_mutex);
  	for (idx = 0; idx < 2; ++idx) {
@@@ -223,18 -272,36 +283,50 @@@
  		if (adev->vce.harvest_config & (1 << idx))
  			continue;
  
++<<<<<<< HEAD
 +		if (idx == 0)
 +			WREG32_P(mmGRBM_GFX_INDEX, 0,
 +				~GRBM_GFX_INDEX__VCE_INSTANCE_MASK);
 +		else
 +			WREG32_P(mmGRBM_GFX_INDEX,
 +				GRBM_GFX_INDEX__VCE_INSTANCE_MASK,
 +				~GRBM_GFX_INDEX__VCE_INSTANCE_MASK);
++=======
+ 		WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(idx));
+ 
+ 		/* Program instance 0 reg space for two instances or instance 0 case
+ 		program instance 1 reg space for only instance 1 available case */
+ 		if (idx != 1 || adev->vce.harvest_config == AMDGPU_VCE_HARVEST_VCE0) {
+ 			ring = &adev->vce.ring[0];
+ 			WREG32(mmVCE_RB_RPTR, lower_32_bits(ring->wptr));
+ 			WREG32(mmVCE_RB_WPTR, lower_32_bits(ring->wptr));
+ 			WREG32(mmVCE_RB_BASE_LO, ring->gpu_addr);
+ 			WREG32(mmVCE_RB_BASE_HI, upper_32_bits(ring->gpu_addr));
+ 			WREG32(mmVCE_RB_SIZE, ring->ring_size / 4);
+ 
+ 			ring = &adev->vce.ring[1];
+ 			WREG32(mmVCE_RB_RPTR2, lower_32_bits(ring->wptr));
+ 			WREG32(mmVCE_RB_WPTR2, lower_32_bits(ring->wptr));
+ 			WREG32(mmVCE_RB_BASE_LO2, ring->gpu_addr);
+ 			WREG32(mmVCE_RB_BASE_HI2, upper_32_bits(ring->gpu_addr));
+ 			WREG32(mmVCE_RB_SIZE2, ring->ring_size / 4);
+ 
+ 			ring = &adev->vce.ring[2];
+ 			WREG32(mmVCE_RB_RPTR3, lower_32_bits(ring->wptr));
+ 			WREG32(mmVCE_RB_WPTR3, lower_32_bits(ring->wptr));
+ 			WREG32(mmVCE_RB_BASE_LO3, ring->gpu_addr);
+ 			WREG32(mmVCE_RB_BASE_HI3, upper_32_bits(ring->gpu_addr));
+ 			WREG32(mmVCE_RB_SIZE3, ring->ring_size / 4);
+ 		}
+ 
+ 		vce_v3_0_mc_resume(adev, idx);
+ 		WREG32_FIELD(VCE_STATUS, JOB_BUSY, 1);
++>>>>>>> 45cc6586b7a7 (drm/amdgpu: Program ring for vce instance 1 at its register space)
  
 +		vce_v3_0_mc_resume(adev, idx);
 +
 +		/* set BUSY flag */
 +		WREG32_P(mmVCE_STATUS, 1, ~1);
  		if (adev->asic_type >= CHIP_STONEY)
  			WREG32_P(mmVCE_VCPU_CNTL, 1, ~0x200001);
  		else
* Unmerged path drivers/gpu/drm/amd/amdgpu/vce_v3_0.c
