KVM: x86: fix wbinvd_dirty_mask use-after-free

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ido Yariv <ido@wizery.com>
commit bd768e146624cbec7122ed15dead8daa137d909d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/bd768e14.failed

vcpu->arch.wbinvd_dirty_mask may still be used after freeing it,
corrupting memory. For example, the following call trace may set a bit
in an already freed cpu mask:
    kvm_arch_vcpu_load
    vcpu_load
    vmx_free_vcpu_nested
    vmx_free_vcpu
    kvm_arch_vcpu_free

Fix this by deferring freeing of wbinvd_dirty_mask.

	Cc: stable@vger.kernel.org
	Signed-off-by: Ido Yariv <ido@wizery.com>
	Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit bd768e146624cbec7122ed15dead8daa137d909d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index 608d740cfae1,e954be8a3185..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -7496,11 -7410,12 +7496,17 @@@ void kvm_put_guest_fpu(struct kvm_vcpu 
  
  void kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)
  {
+ 	void *wbinvd_dirty_mask = vcpu->arch.wbinvd_dirty_mask;
+ 
  	kvmclock_reset(vcpu);
  
++<<<<<<< HEAD
 +	free_cpumask_var(vcpu->arch.wbinvd_dirty_mask);
 +	fx_free(vcpu);
++=======
++>>>>>>> bd768e146624 (KVM: x86: fix wbinvd_dirty_mask use-after-free)
  	kvm_x86_ops->vcpu_free(vcpu);
+ 	free_cpumask_var(wbinvd_dirty_mask);
  }
  
  struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,
* Unmerged path arch/x86/kvm/x86.c
