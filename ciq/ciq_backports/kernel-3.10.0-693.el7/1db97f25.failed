ntb: conslidate reading of PPD to move platform detection earlier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [ntb] conslidate reading of PPD to move platform detection earlier (Suravee Suthikulpanit) [1303727]
Rebuild_FUZZ: 96.00%
commit-author Dave Jiang <dave.jiang@intel.com>
commit 1db97f258966878317ece10868eaca99201d5884
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1db97f25.failed

To simplify some of the platform detection code. Move the platform detection
to a function to be called earlier.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Jon Mason <jdmason@kudzu.us>
(cherry picked from commit 1db97f258966878317ece10868eaca99201d5884)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ntb/ntb_hw.c
diff --cc drivers/ntb/ntb_hw.c
index b250e730a323,6f1c92182f35..000000000000
--- a/drivers/ntb/ntb_hw.c
+++ b/drivers/ntb/ntb_hw.c
@@@ -557,129 -702,184 +557,306 @@@ static void bwd_link_poll(struct work_s
  
  static int ntb_xeon_setup(struct ntb_device *ndev)
  {
++<<<<<<< HEAD
 +	int rc;
 +	u8 val;
 +
 +	ndev->hw_type = SNB_HW;
 +
 +	rc = pci_read_config_byte(ndev->pdev, NTB_PPD_OFFSET, &val);
 +	if (rc)
 +		return rc;
 +
 +	switch (val & SNB_PPD_CONN_TYPE) {
 +	case NTB_CONN_B2B:
 +		ndev->conn_type = NTB_CONN_B2B;
 +		break;
 +	case NTB_CONN_CLASSIC:
 +	case NTB_CONN_RP:
 +	default:
 +		dev_err(&ndev->pdev->dev, "Only B2B supported at this time\n");
 +		return -EINVAL;
 +	}
 +
 +	if (val & SNB_PPD_DEV_TYPE)
 +		ndev->dev_type = NTB_DEV_USD;
 +	else
 +		ndev->dev_type = NTB_DEV_DSD;
 +
 +	ndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
 +	ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;
 +	ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;
 +	ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;
++=======
+ 	switch (ndev->conn_type) {
+ 	case NTB_CONN_B2B:
+ 		ndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;
+ 		ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;
+ 		ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;
+ 		ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;
+ 		ndev->limits.max_spads = SNB_MAX_B2B_SPADS;
+ 
+ 		/* There is a Xeon hardware errata related to writes to
+ 		 * SDOORBELL or B2BDOORBELL in conjunction with inbound access
+ 		 * to NTB MMIO Space, which may hang the system.  To workaround
+ 		 * this use the second memory window to access the interrupt and
+ 		 * scratch pad registers on the remote system.
+ 		 */
+ 		if (xeon_errata_workaround) {
+ 			if (!ndev->mw[1].bar_sz)
+ 				return -EINVAL;
+ 
+ 			ndev->limits.max_mw = SNB_ERRATA_MAX_MW;
+ 			ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
+ 			ndev->reg_ofs.spad_write = ndev->mw[1].vbase +
+ 						   SNB_SPAD_OFFSET;
+ 			ndev->reg_ofs.rdb = ndev->mw[1].vbase +
+ 					    SNB_PDOORBELL_OFFSET;
+ 
+ 			/* Set the Limit register to 4k, the minimum size, to
+ 			 * prevent an illegal access
+ 			 */
+ 			writeq(ndev->mw[1].bar_sz + 0x1000, ndev->reg_base +
+ 			       SNB_PBAR4LMT_OFFSET);
+ 			/* HW errata on the Limit registers.  They can only be
+ 			 * written when the base register is 4GB aligned and
+ 			 * < 32bit.  This should already be the case based on
+ 			 * the driver defaults, but write the Limit registers
+ 			 * first just in case.
+ 			 */
+ 		} else {
+ 			ndev->limits.max_mw = SNB_MAX_MW;
+ 
+ 			/* HW Errata on bit 14 of b2bdoorbell register.  Writes
+ 			 * will not be mirrored to the remote system.  Shrink
+ 			 * the number of bits by one, since bit 14 is the last
+ 			 * bit.
+ 			 */
+ 			ndev->limits.max_db_bits = SNB_MAX_DB_BITS - 1;
+ 			ndev->reg_ofs.spad_write = ndev->reg_base +
+ 						   SNB_B2B_SPAD_OFFSET;
+ 			ndev->reg_ofs.rdb = ndev->reg_base +
+ 					    SNB_B2B_DOORBELL_OFFSET;
+ 
+ 			/* Disable the Limit register, just incase it is set to
+ 			 * something silly
+ 			 */
+ 			writeq(0, ndev->reg_base + SNB_PBAR4LMT_OFFSET);
+ 			/* HW errata on the Limit registers.  They can only be
+ 			 * written when the base register is 4GB aligned and
+ 			 * < 32bit.  This should already be the case based on
+ 			 * the driver defaults, but write the Limit registers
+ 			 * first just in case.
+ 			 */
+ 		}
+ 
+ 		/* The Xeon errata workaround requires setting SBAR Base
+ 		 * addresses to known values, so that the PBAR XLAT can be
+ 		 * pointed at SBAR0 of the remote system.
+ 		 */
+ 		if (ndev->dev_type == NTB_DEV_USD) {
+ 			writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
+ 			       SNB_PBAR2XLAT_OFFSET);
+ 			if (xeon_errata_workaround)
+ 				writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 			else {
+ 				writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 				/* B2B_XLAT_OFFSET is a 64bit register, but can
+ 				 * only take 32bit writes
+ 				 */
+ 				writel(SNB_MBAR01_DSD_ADDR & 0xffffffff,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
+ 				writel(SNB_MBAR01_DSD_ADDR >> 32,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
+ 			}
+ 
+ 			writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR0BASE_OFFSET);
+ 			writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR2BASE_OFFSET);
+ 			writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR4BASE_OFFSET);
+ 		} else {
+ 			writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
+ 			       SNB_PBAR2XLAT_OFFSET);
+ 			if (xeon_errata_workaround)
+ 				writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 			else {
+ 				writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 				/* B2B_XLAT_OFFSET is a 64bit register, but can
+ 				 * only take 32bit writes
+ 				 */
+ 				writel(SNB_MBAR01_USD_ADDR & 0xffffffff,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
+ 				writel(SNB_MBAR01_USD_ADDR >> 32,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
+ 			}
+ 			writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR0BASE_OFFSET);
+ 			writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR2BASE_OFFSET);
+ 			writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR4BASE_OFFSET);
+ 		}
+ 		break;
+ 	case NTB_CONN_RP:
+ 		if (xeon_errata_workaround) {
+ 			dev_err(&ndev->pdev->dev,
+ 				"NTB-RP disabled due to hardware errata.  To disregard this warning and potentially lock-up the system, add the parameter 'xeon_errata_workaround=0'.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		/* Scratch pads need to have exclusive access from the primary
+ 		 * or secondary side.  Halve the num spads so that each side can
+ 		 * have an equal amount.
+ 		 */
+ 		ndev->limits.max_spads = SNB_MAX_COMPAT_SPADS / 2;
+ 		ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
+ 		/* Note: The SDOORBELL is the cause of the errata.  You REALLY
+ 		 * don't want to touch it.
+ 		 */
+ 		ndev->reg_ofs.rdb = ndev->reg_base + SNB_SDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;
+ 		/* Offset the start of the spads to correspond to whether it is
+ 		 * primary or secondary
+ 		 */
+ 		ndev->reg_ofs.spad_write = ndev->reg_base + SNB_SPAD_OFFSET +
+ 					   ndev->limits.max_spads * 4;
+ 		ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;
+ 		ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;
+ 		ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;
+ 		ndev->limits.max_mw = SNB_MAX_MW;
+ 		break;
+ 	case NTB_CONN_TRANSPARENT:
+ 		/* Scratch pads need to have exclusive access from the primary
+ 		 * or secondary side.  Halve the num spads so that each side can
+ 		 * have an equal amount.
+ 		 */
+ 		ndev->limits.max_spads = SNB_MAX_COMPAT_SPADS / 2;
+ 		ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
+ 		ndev->reg_ofs.rdb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb = ndev->reg_base + SNB_SDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_SDBMSK_OFFSET;
+ 		ndev->reg_ofs.spad_write = ndev->reg_base + SNB_SPAD_OFFSET;
+ 		/* Offset the start of the spads to correspond to whether it is
+ 		 * primary or secondary
+ 		 */
+ 		ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET +
+ 					  ndev->limits.max_spads * 4;
+ 		ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_PBAR2XLAT_OFFSET;
+ 		ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_PBAR4XLAT_OFFSET;
+ 
+ 		ndev->limits.max_mw = SNB_MAX_MW;
+ 		break;
+ 	default:
+ 		/*
+ 		 * we should never hit this. the detect function should've
+ 		 * take cared of everything.
+ 		 */
+ 		return -EINVAL;
+ 	}
+ 
++>>>>>>> 1db97f258966 (ntb: conslidate reading of PPD to move platform detection earlier)
  	ndev->reg_ofs.lnk_cntl = ndev->reg_base + SNB_NTBCNTL_OFFSET;
 -	ndev->reg_ofs.lnk_stat = ndev->reg_base + SNB_SLINK_STATUS_OFFSET;
 +	ndev->reg_ofs.lnk_stat = ndev->reg_base + SNB_LINK_STATUS_OFFSET;
 +	ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;
  	ndev->reg_ofs.spci_cmd = ndev->reg_base + SNB_PCICMD_OFFSET;
  
 +	/* There is a Xeon hardware errata related to writes to
 +	 * SDOORBELL or B2BDOORBELL in conjunction with inbound access
 +	 * to NTB MMIO Space, which may hang the system.  To workaround
 +	 * this use the second memory window to access the interrupt and
 +	 * scratch pad registers on the remote system.
 +	 */
 +	if (xeon_errata_workaround) {
 +		if (!ndev->mw[1].bar_sz)
 +			return -EINVAL;
 +
 +		ndev->limits.max_mw = SNB_ERRATA_MAX_MW;
 +		ndev->reg_ofs.spad_write = ndev->mw[1].vbase +
 +					   SNB_SPAD_OFFSET;
 +		ndev->reg_ofs.rdb = ndev->mw[1].vbase +
 +				    SNB_PDOORBELL_OFFSET;
 +
 +		/* Set the Limit register to 4k, the minimum size, to
 +		 * prevent an illegal access
 +		 */
 +		writeq(ndev->mw[1].bar_sz + 0x1000, ndev->reg_base +
 +		       SNB_PBAR4LMT_OFFSET);
 +	} else {
 +		ndev->limits.max_mw = SNB_MAX_MW;
 +		ndev->reg_ofs.spad_write = ndev->reg_base +
 +					   SNB_B2B_SPAD_OFFSET;
 +		ndev->reg_ofs.rdb = ndev->reg_base +
 +				    SNB_B2B_DOORBELL_OFFSET;
 +
 +		/* Disable the Limit register, just incase it is set to
 +		 * something silly
 +		 */
 +		writeq(0, ndev->reg_base + SNB_PBAR4LMT_OFFSET);
 +	}
 +
 +	/* The Xeon errata workaround requires setting SBAR Base
 +	 * addresses to known values, so that the PBAR XLAT can be
 +	 * pointed at SBAR0 of the remote system.
 +	 */
 +	if (ndev->dev_type == NTB_DEV_USD) {
 +		writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
 +		       SNB_PBAR2XLAT_OFFSET);
 +		if (xeon_errata_workaround)
 +			writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
 +			       SNB_PBAR4XLAT_OFFSET);
 +		else {
 +			writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
 +			       SNB_PBAR4XLAT_OFFSET);
 +			/* B2B_XLAT_OFFSET is a 64bit register, but can
 +			 * only take 32bit writes
 +			 */
 +			writel(SNB_MBAR01_USD_ADDR & 0xffffffff,
 +			       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
 +			writel(SNB_MBAR01_DSD_ADDR >> 32,
 +			       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
 +		}
 +
 +		writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
 +		       SNB_SBAR0BASE_OFFSET);
 +		writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
 +		       SNB_SBAR2BASE_OFFSET);
 +		writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
 +		       SNB_SBAR4BASE_OFFSET);
 +	} else {
 +		writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
 +		       SNB_PBAR2XLAT_OFFSET);
 +		if (xeon_errata_workaround)
 +			writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
 +			       SNB_PBAR4XLAT_OFFSET);
 +		else {
 +			writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
 +			       SNB_PBAR4XLAT_OFFSET);
 +			/* B2B_XLAT_OFFSET is a 64bit register, but can
 +			 * only take 32bit writes
 +			 */
 +			writel(SNB_MBAR01_USD_ADDR & 0xffffffff,
 +			       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
 +			writel(SNB_MBAR01_USD_ADDR >> 32,
 +			       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
 +		}
 +		writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
 +		       SNB_SBAR0BASE_OFFSET);
 +		writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
 +		       SNB_SBAR2BASE_OFFSET);
 +		writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
 +		       SNB_SBAR4BASE_OFFSET);
 +	}
 +
 +	ndev->limits.max_spads = SNB_MAX_B2B_SPADS;
 +	ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
  	ndev->limits.msix_cnt = SNB_MSIX_CNT;
  	ndev->bits_per_vector = SNB_DB_BITS_PER_VEC;
  
@@@ -765,11 -956,10 +942,18 @@@ static int ntb_device_setup(struct ntb_
  	if (rc)
  		return rc;
  
++<<<<<<< HEAD
 +	dev_info(&ndev->pdev->dev, "Device Type = %s\n",
 +		 ndev->dev_type == NTB_DEV_USD ? "USD/DSP" : "DSD/USP");
 +
 +	/* Enable Bus Master and Memory Space on the secondary side */
 +	writew(PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER, ndev->reg_ofs.spci_cmd);
++=======
+ 	if (ndev->conn_type == NTB_CONN_B2B)
+ 		/* Enable Bus Master and Memory Space on the secondary side */
+ 		writew(PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER,
+ 		       ndev->reg_ofs.spci_cmd);
++>>>>>>> 1db97f258966 (ntb: conslidate reading of PPD to move platform detection earlier)
  
  	return 0;
  }
@@@ -1167,6 -1462,129 +1351,132 @@@ static void ntb_free_debugfs(struct ntb
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void ntb_hw_link_up(struct ntb_device *ndev)
+ {
+ 	if (ndev->conn_type == NTB_CONN_TRANSPARENT)
+ 		ntb_link_event(ndev, NTB_LINK_UP);
+ 	else {
+ 		u32 ntb_cntl;
+ 
+ 		/* Let's bring the NTB link up */
+ 		ntb_cntl = readl(ndev->reg_ofs.lnk_cntl);
+ 		ntb_cntl &= ~(NTB_CNTL_LINK_DISABLE | NTB_CNTL_CFG_LOCK);
+ 		ntb_cntl |= NTB_CNTL_P2S_BAR23_SNOOP | NTB_CNTL_S2P_BAR23_SNOOP;
+ 		ntb_cntl |= NTB_CNTL_P2S_BAR45_SNOOP | NTB_CNTL_S2P_BAR45_SNOOP;
+ 		writel(ntb_cntl, ndev->reg_ofs.lnk_cntl);
+ 	}
+ }
+ 
+ static void ntb_hw_link_down(struct ntb_device *ndev)
+ {
+ 	u32 ntb_cntl;
+ 
+ 	if (ndev->conn_type == NTB_CONN_TRANSPARENT) {
+ 		ntb_link_event(ndev, NTB_LINK_DOWN);
+ 		return;
+ 	}
+ 
+ 	/* Bring NTB link down */
+ 	ntb_cntl = readl(ndev->reg_ofs.lnk_cntl);
+ 	ntb_cntl &= ~(NTB_CNTL_P2S_BAR23_SNOOP | NTB_CNTL_S2P_BAR23_SNOOP);
+ 	ntb_cntl &= ~(NTB_CNTL_P2S_BAR45_SNOOP | NTB_CNTL_S2P_BAR45_SNOOP);
+ 	ntb_cntl |= NTB_CNTL_LINK_DISABLE | NTB_CNTL_CFG_LOCK;
+ 	writel(ntb_cntl, ndev->reg_ofs.lnk_cntl);
+ }
+ 
+ static int ntb_xeon_detect(struct ntb_device *ndev)
+ {
+ 	int rc;
+ 	u8 ppd;
+ 
+ 	ndev->hw_type = SNB_HW;
+ 
+ 	rc = pci_read_config_byte(ndev->pdev, NTB_PPD_OFFSET, &ppd);
+ 	if (rc)
+ 		return -EIO;
+ 
+ 	if (ppd & SNB_PPD_DEV_TYPE)
+ 		ndev->dev_type = NTB_DEV_USD;
+ 	else
+ 		ndev->dev_type = NTB_DEV_DSD;
+ 
+ 	switch (ppd & SNB_PPD_CONN_TYPE) {
+ 	case NTB_CONN_B2B:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = B2B\n");
+ 		ndev->conn_type = NTB_CONN_B2B;
+ 		break;
+ 	case NTB_CONN_RP:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = RP\n");
+ 		ndev->conn_type = NTB_CONN_RP;
+ 		break;
+ 	case NTB_CONN_TRANSPARENT:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = TRANSPARENT\n");
+ 		ndev->conn_type = NTB_CONN_TRANSPARENT;
+ 		/*
+ 		 * This mode is default to USD/DSP. HW does not report
+ 		 * properly in transparent mode as it has no knowledge of
+ 		 * NTB. We will just force correct here.
+ 		 */
+ 		ndev->dev_type = NTB_DEV_USD;
+ 		break;
+ 	default:
+ 		dev_err(&ndev->pdev->dev, "Unknown PPD %x\n", ppd);
+ 		return -ENODEV;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int ntb_atom_detect(struct ntb_device *ndev)
+ {
+ 	int rc;
+ 	u32 ppd;
+ 
+ 	ndev->hw_type = BWD_HW;
+ 
+ 	rc = pci_read_config_dword(ndev->pdev, NTB_PPD_OFFSET, &ppd);
+ 	if (rc)
+ 		return rc;
+ 
+ 	switch ((ppd & BWD_PPD_CONN_TYPE) >> 8) {
+ 	case NTB_CONN_B2B:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = B2B\n");
+ 		ndev->conn_type = NTB_CONN_B2B;
+ 		break;
+ 	case NTB_CONN_RP:
+ 	default:
+ 		dev_err(&ndev->pdev->dev, "Unsupported NTB configuration\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (ppd & BWD_PPD_DEV_TYPE)
+ 		ndev->dev_type = NTB_DEV_DSD;
+ 	else
+ 		ndev->dev_type = NTB_DEV_USD;
+ 
+ 	return 0;
+ }
+ 
+ static int ntb_device_detect(struct ntb_device *ndev)
+ {
+ 	int rc;
+ 
+ 	if (is_ntb_xeon(ndev))
+ 		rc = ntb_xeon_detect(ndev);
+ 	else if (is_ntb_atom(ndev))
+ 		rc = ntb_atom_detect(ndev);
+ 	else
+ 		rc = -ENODEV;
+ 
+ 	dev_info(&ndev->pdev->dev, "Device Type = %s\n",
+ 		 ndev->dev_type == NTB_DEV_USD ? "USD/DSP" : "DSD/USP");
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 1db97f258966 (ntb: conslidate reading of PPD to move platform detection earlier)
  static int ntb_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
  {
  	struct ntb_device *ndev;
* Unmerged path drivers/ntb/ntb_hw.c
