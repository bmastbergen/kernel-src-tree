bridge: export knowledge about the presence of IGMP/MLD queriers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Linus Lüssing <linus.luessing@web.de>
commit c34963e21685659eb513e1c4d847f81d8a8f13f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c34963e2.failed

With this patch other modules are able to ask the bridge whether an
IGMP or MLD querier exists on the according, bridged link layer.

Multicast snooping can only be performed if a valid, selected querier
exists on a link.

Just like the bridge only enables its multicast snooping if a querier
exists, e.g. batman-adv too can only activate its multicast
snooping in bridged scenarios if a querier is present.

For instance this export avoids having to reimplement IGMP/MLD
querier message snooping and parsing in e.g. batman-adv, when
multicast optimizations for bridged scenarios are added in the
future.

	Signed-off-by: Linus Lüssing <linus.luessing@web.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c34963e21685659eb513e1c4d847f81d8a8f13f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/if_bridge.h
#	net/bridge/br_multicast.c
diff --cc include/linux/if_bridge.h
index d66e75e57470,808dcb8cc04f..000000000000
--- a/include/linux/if_bridge.h
+++ b/include/linux/if_bridge.h
@@@ -55,9 -36,28 +55,30 @@@ extern void brioctl_set(int (*ioctl_hoo
  
  typedef int br_should_route_hook_t(struct sk_buff *skb);
  extern br_should_route_hook_t __rcu *br_should_route_hook;
 -
 -#if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)
 +#if 0
 +/* RHEL: not yet fully supported */
  int br_multicast_list_adjacent(struct net_device *dev,
  			       struct list_head *br_ip_list);
++<<<<<<< HEAD
++=======
+ bool br_multicast_has_querier_anywhere(struct net_device *dev, int proto);
+ bool br_multicast_has_querier_adjacent(struct net_device *dev, int proto);
+ #else
+ static inline int br_multicast_list_adjacent(struct net_device *dev,
+ 					     struct list_head *br_ip_list)
+ {
+ 	return 0;
+ }
+ static inline bool br_multicast_has_querier_anywhere(struct net_device *dev,
+ 						     int proto)
+ {
+ 	return false;
+ }
+ static inline bool br_multicast_has_querier_adjacent(struct net_device *dev,
+ 						     int proto)
+ {
+ 	return false;
+ }
++>>>>>>> c34963e21685 (bridge: export knowledge about the presence of IGMP/MLD queriers)
  #endif
 -
  #endif
diff --cc net/bridge/br_multicast.c
index 251bf0711bce,b4845f4b2bb4..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -2145,4 -2214,89 +2145,82 @@@ unlock
  	return count;
  }
  EXPORT_SYMBOL_GPL(br_multicast_list_adjacent);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * br_multicast_has_querier_anywhere - Checks for a querier on a bridge
+  * @dev: The bridge port providing the bridge on which to check for a querier
+  * @proto: The protocol family to check for: IGMP -> ETH_P_IP, MLD -> ETH_P_IPV6
+  *
+  * Checks whether the given interface has a bridge on top and if so returns
+  * true if a valid querier exists anywhere on the bridged link layer.
+  * Otherwise returns false.
+  */
+ bool br_multicast_has_querier_anywhere(struct net_device *dev, int proto)
+ {
+ 	struct net_bridge *br;
+ 	struct net_bridge_port *port;
+ 	struct ethhdr eth;
+ 	bool ret = false;
+ 
+ 	rcu_read_lock();
+ 	if (!br_port_exists(dev))
+ 		goto unlock;
+ 
+ 	port = br_port_get_rcu(dev);
+ 	if (!port || !port->br)
+ 		goto unlock;
+ 
+ 	br = port->br;
+ 
+ 	memset(&eth, 0, sizeof(eth));
+ 	eth.h_proto = htons(proto);
+ 
+ 	ret = br_multicast_querier_exists(br, &eth);
+ 
+ unlock:
+ 	rcu_read_unlock();
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(br_multicast_has_querier_anywhere);
+ 
+ /**
+  * br_multicast_has_querier_adjacent - Checks for a querier behind a bridge port
+  * @dev: The bridge port adjacent to which to check for a querier
+  * @proto: The protocol family to check for: IGMP -> ETH_P_IP, MLD -> ETH_P_IPV6
+  *
+  * Checks whether the given interface has a bridge on top and if so returns
+  * true if a selected querier is behind one of the other ports of this
+  * bridge. Otherwise returns false.
+  */
+ bool br_multicast_has_querier_adjacent(struct net_device *dev, int proto)
+ {
+ 	struct net_bridge *br;
+ 	struct net_bridge_port *port;
+ 	bool ret = false;
+ 
+ 	rcu_read_lock();
+ 	if (!br_port_exists(dev))
+ 		goto unlock;
+ 
+ 	port = br_port_get_rcu(dev);
+ 	if (!port || !port->br)
+ 		goto unlock;
+ 
+ 	br = port->br;
+ 
+ 	switch (proto) {
+ 	case ETH_P_IP:
+ 		if (!timer_pending(&br->ip4_other_query.timer) ||
+ 		    rcu_dereference(br->ip4_querier.port) == port)
+ 			goto unlock;
+ 		break;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case ETH_P_IPV6:
+ 		if (!timer_pending(&br->ip6_other_query.timer) ||
+ 		    rcu_dereference(br->ip6_querier.port) == port)
+ 			goto unlock;
+ 		break;
++>>>>>>> c34963e21685 (bridge: export knowledge about the presence of IGMP/MLD queriers)
  #endif
 -	default:
 -		goto unlock;
 -	}
 -
 -	ret = true;
 -unlock:
 -	rcu_read_unlock();
 -	return ret;
 -}
 -EXPORT_SYMBOL_GPL(br_multicast_has_querier_adjacent);
* Unmerged path include/linux/if_bridge.h
* Unmerged path net/bridge/br_multicast.c
