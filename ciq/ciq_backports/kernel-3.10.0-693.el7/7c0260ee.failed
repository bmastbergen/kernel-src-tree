btrfs: tests, require fs_info for root

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jeff Mahoney <jeffm@suse.com>
commit 7c0260ee098db7a05fd68812b2e21ce2e19dfcf0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7c0260ee.failed

This allows the upcoming patchset to push nodesize and sectorsize into
fs_info.

	Signed-off-by: Jeff Mahoney <jeffm@suse.com>
	Signed-off-by: David Sterba <dsterba@suse.com>
(cherry picked from commit 7c0260ee098db7a05fd68812b2e21ce2e19dfcf0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/disk-io.c
#	fs/btrfs/disk-io.h
#	fs/btrfs/tests/btrfs-tests.c
#	fs/btrfs/tests/extent-buffer-tests.c
#	fs/btrfs/tests/free-space-tests.c
#	fs/btrfs/tests/free-space-tree-tests.c
#	fs/btrfs/tests/inode-tests.c
#	fs/btrfs/tests/qgroup-tests.c
diff --cc fs/btrfs/disk-io.c
index f1b6251aa1de,8e838b1cc806..000000000000
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@@ -1306,14 -1316,20 +1307,28 @@@ static struct btrfs_root *btrfs_alloc_r
  
  #ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS
  /* Should only be used by the testing infrastructure */
++<<<<<<< HEAD
 +struct btrfs_root *btrfs_alloc_dummy_root(void)
++=======
+ struct btrfs_root *btrfs_alloc_dummy_root(struct btrfs_fs_info *fs_info,
+ 					  u32 sectorsize, u32 nodesize)
++>>>>>>> 7c0260ee098d (btrfs: tests, require fs_info for root)
  {
  	struct btrfs_root *root;
  
- 	root = btrfs_alloc_root(NULL, GFP_KERNEL);
+ 	if (!fs_info)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	root = btrfs_alloc_root(fs_info, GFP_KERNEL);
  	if (!root)
  		return ERR_PTR(-ENOMEM);
++<<<<<<< HEAD
 +	__setup_root(4096, 4096, 4096, root, NULL, 1);
++=======
+ 	/* We don't use the stripesize in selftest, set it as sectorsize */
+ 	__setup_root(nodesize, sectorsize, sectorsize, root, fs_info,
+ 			BTRFS_ROOT_TREE_OBJECTID);
++>>>>>>> 7c0260ee098d (btrfs: tests, require fs_info for root)
  	set_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);
  	root->alloc_bytenr = 0;
  
diff --cc fs/btrfs/disk-io.h
index 7c52e29fdb0d,c9d42c92da2b..000000000000
--- a/fs/btrfs/disk-io.h
+++ b/fs/btrfs/disk-io.h
@@@ -90,7 -90,8 +90,12 @@@ void btrfs_drop_and_free_fs_root(struc
  void btrfs_free_fs_root(struct btrfs_root *root);
  
  #ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS
++<<<<<<< HEAD
 +struct btrfs_root *btrfs_alloc_dummy_root(void);
++=======
+ struct btrfs_root *btrfs_alloc_dummy_root(struct btrfs_fs_info *fs_info,
+ 					  u32 sectorsize, u32 nodesize);
++>>>>>>> 7c0260ee098d (btrfs: tests, require fs_info for root)
  #endif
  
  /*
diff --cc fs/btrfs/tests/btrfs-tests.c
index de90bbb1cd8c,bf62ad919a95..000000000000
--- a/fs/btrfs/tests/btrfs-tests.c
+++ b/fs/btrfs/tests/btrfs-tests.c
@@@ -122,6 -125,13 +122,16 @@@ struct btrfs_fs_info *btrfs_alloc_dummy
  	INIT_LIST_HEAD(&fs_info->tree_mod_seq_list);
  	INIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);
  	INIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);
++<<<<<<< HEAD
++=======
+ 	extent_io_tree_init(&fs_info->freed_extents[0], NULL);
+ 	extent_io_tree_init(&fs_info->freed_extents[1], NULL);
+ 	fs_info->pinned_extents = &fs_info->freed_extents[0];
+ 	set_bit(BTRFS_FS_STATE_DUMMY_FS_INFO, &fs_info->fs_state);
+ 
+ 	test_mnt->mnt_sb->s_fs_info = fs_info;
+ 
++>>>>>>> 7c0260ee098d (btrfs: tests, require fs_info for root)
  	return fs_info;
  }
  
diff --cc fs/btrfs/tests/extent-buffer-tests.c
index f51963a8f929,199569174637..000000000000
--- a/fs/btrfs/tests/extent-buffer-tests.c
+++ b/fs/btrfs/tests/extent-buffer-tests.c
@@@ -22,10 -22,11 +22,11 @@@
  #include "../extent_io.h"
  #include "../disk-io.h"
  
 -static int test_btrfs_split_item(u32 sectorsize, u32 nodesize)
 +static int test_btrfs_split_item(void)
  {
- 	struct btrfs_path *path;
- 	struct btrfs_root *root;
+ 	struct btrfs_fs_info *fs_info;
+ 	struct btrfs_path *path = NULL;
+ 	struct btrfs_root *root = NULL;
  	struct extent_buffer *eb;
  	struct btrfs_item *item;
  	char *value = "mary had a little lamb";
@@@ -40,20 -41,28 +41,31 @@@
  
  	test_msg("Running btrfs_split_item tests\n");
  
++<<<<<<< HEAD
 +	root = btrfs_alloc_dummy_root();
++=======
+ 	fs_info = btrfs_alloc_dummy_fs_info();
+ 	if (!fs_info) {
+ 		test_msg("Could not allocate fs_info\n");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	root = btrfs_alloc_dummy_root(fs_info, sectorsize, nodesize);
++>>>>>>> 7c0260ee098d (btrfs: tests, require fs_info for root)
  	if (IS_ERR(root)) {
  		test_msg("Could not allocate root\n");
- 		return PTR_ERR(root);
+ 		ret = PTR_ERR(root);
+ 		goto out;
  	}
  
  	path = btrfs_alloc_path();
  	if (!path) {
  		test_msg("Could not allocate path\n");
- 		kfree(root);
- 		return -ENOMEM;
+ 		ret = -ENOMEM;
+ 		goto out;
  	}
  
 -	path->nodes[0] = eb = alloc_dummy_extent_buffer(NULL, nodesize,
 -							nodesize);
 +	path->nodes[0] = eb = alloc_dummy_extent_buffer(NULL, 4096);
  	if (!eb) {
  		test_msg("Could not allocate dummy buffer\n");
  		ret = -ENOMEM;
diff --cc fs/btrfs/tests/free-space-tests.c
index 69a11e63d668,3221c8dee272..000000000000
--- a/fs/btrfs/tests/free-space-tests.c
+++ b/fs/btrfs/tests/free-space-tests.c
@@@ -885,8 -835,9 +885,9 @@@ test_steal_space_from_bitmap_to_extent(
  	return 0;
  }
  
 -int btrfs_test_free_space_cache(u32 sectorsize, u32 nodesize)
 +int btrfs_test_free_space_cache(void)
  {
+ 	struct btrfs_fs_info *fs_info;
  	struct btrfs_block_group_cache *cache;
  	struct btrfs_root *root = NULL;
  	int ret = -ENOMEM;
@@@ -899,15 -856,17 +900,21 @@@
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	root = btrfs_alloc_dummy_root();
- 	if (IS_ERR(root)) {
- 		ret = PTR_ERR(root);
++=======
+ 	fs_info = btrfs_alloc_dummy_fs_info();
+ 	if (!fs_info) {
+ 		ret = -ENOMEM;
  		goto out;
  	}
  
- 	root->fs_info = btrfs_alloc_dummy_fs_info();
- 	if (!root->fs_info)
+ 	root = btrfs_alloc_dummy_root(fs_info, sectorsize, nodesize);
++>>>>>>> 7c0260ee098d (btrfs: tests, require fs_info for root)
+ 	if (IS_ERR(root)) {
+ 		ret = PTR_ERR(root);
  		goto out;
+ 	}
  
  	root->fs_info->extent_root = root;
  	cache->fs_info = root->fs_info;
@@@ -922,12 -881,11 +929,13 @@@
  	if (ret)
  		goto out;
  
 -	ret = test_steal_space_from_bitmap_to_extent(cache, sectorsize);
 +	ret = test_steal_space_from_bitmap_to_extent(cache);
  out:
 -	btrfs_free_dummy_block_group(cache);
 +	__btrfs_remove_free_space_cache(cache->free_space_ctl);
 +	kfree(cache->free_space_ctl);
 +	kfree(cache);
  	btrfs_free_dummy_root(root);
+ 	btrfs_free_dummy_fs_info(fs_info);
  	test_msg("Free space cache tests finished\n");
  	return ret;
  }
diff --cc fs/btrfs/tests/inode-tests.c
index 846143210001,9f72aeda9220..000000000000
--- a/fs/btrfs/tests/inode-tests.c
+++ b/fs/btrfs/tests/inode-tests.c
@@@ -220,8 -228,9 +220,9 @@@ static unsigned long prealloc_only = 0
  static unsigned long compressed_only = 0;
  static unsigned long vacancy_only = 0;
  
 -static noinline int test_btrfs_get_extent(u32 sectorsize, u32 nodesize)
 +static noinline int test_btrfs_get_extent(void)
  {
+ 	struct btrfs_fs_info *fs_info = NULL;
  	struct inode *inode = NULL;
  	struct btrfs_root *root = NULL;
  	struct extent_map *em = NULL;
@@@ -240,9 -249,9 +241,15 @@@
  	BTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;
  	BTRFS_I(inode)->location.offset = 0;
  
++<<<<<<< HEAD
 +	root = btrfs_alloc_dummy_root();
 +	if (IS_ERR(root)) {
 +		test_msg("Couldn't allocate root\n");
++=======
+ 	fs_info = btrfs_alloc_dummy_fs_info();
+ 	if (!fs_info) {
+ 		test_msg("Couldn't allocate dummy fs info\n");
++>>>>>>> 7c0260ee098d (btrfs: tests, require fs_info for root)
  		goto out;
  	}
  
@@@ -815,8 -836,9 +819,9 @@@ out
  	return ret;
  }
  
 -static int test_hole_first(u32 sectorsize, u32 nodesize)
 +static int test_hole_first(void)
  {
+ 	struct btrfs_fs_info *fs_info = NULL;
  	struct inode *inode = NULL;
  	struct btrfs_root *root = NULL;
  	struct extent_map *em = NULL;
@@@ -832,9 -854,9 +837,15 @@@
  	BTRFS_I(inode)->location.objectid = BTRFS_FIRST_FREE_OBJECTID;
  	BTRFS_I(inode)->location.offset = 0;
  
++<<<<<<< HEAD
 +	root = btrfs_alloc_dummy_root();
 +	if (IS_ERR(root)) {
 +		test_msg("Couldn't allocate root\n");
++=======
+ 	fs_info = btrfs_alloc_dummy_fs_info();
+ 	if (!fs_info) {
+ 		test_msg("Couldn't allocate dummy fs info\n");
++>>>>>>> 7c0260ee098d (btrfs: tests, require fs_info for root)
  		goto out;
  	}
  
@@@ -912,8 -937,9 +924,9 @@@ out
  	return ret;
  }
  
 -static int test_extent_accounting(u32 sectorsize, u32 nodesize)
 +static int test_extent_accounting(void)
  {
+ 	struct btrfs_fs_info *fs_info = NULL;
  	struct inode *inode = NULL;
  	struct btrfs_root *root = NULL;
  	int ret = -ENOMEM;
@@@ -924,9 -950,9 +937,15 @@@
  		return ret;
  	}
  
++<<<<<<< HEAD
 +	root = btrfs_alloc_dummy_root();
 +	if (IS_ERR(root)) {
 +		test_msg("Couldn't allocate root\n");
++=======
+ 	fs_info = btrfs_alloc_dummy_fs_info();
+ 	if (!fs_info) {
+ 		test_msg("Couldn't allocate dummy fs info\n");
++>>>>>>> 7c0260ee098d (btrfs: tests, require fs_info for root)
  		goto out;
  	}
  
@@@ -1097,9 -1130,10 +1116,10 @@@ out
  		clear_extent_bit(&BTRFS_I(inode)->io_tree, 0, (u64)-1,
  				 EXTENT_DIRTY | EXTENT_DELALLOC |
  				 EXTENT_DO_ACCOUNTING | EXTENT_UPTODATE, 0, 0,
 -				 NULL, GFP_KERNEL);
 +				 NULL, GFP_NOFS);
  	iput(inode);
  	btrfs_free_dummy_root(root);
+ 	btrfs_free_dummy_fs_info(fs_info);
  	return ret;
  }
  
diff --cc fs/btrfs/tests/qgroup-tests.c
index 846d277b1901,4407fef7c16c..000000000000
--- a/fs/btrfs/tests/qgroup-tests.c
+++ b/fs/btrfs/tests/qgroup-tests.c
@@@ -443,24 -451,26 +443,33 @@@ static int test_multiple_refs(struct bt
  	return 0;
  }
  
 -int btrfs_test_qgroups(u32 sectorsize, u32 nodesize)
 +int btrfs_test_qgroups(void)
  {
+ 	struct btrfs_fs_info *fs_info = NULL;
  	struct btrfs_root *root;
  	struct btrfs_root *tmp_root;
  	int ret = 0;
  
++<<<<<<< HEAD
 +	root = btrfs_alloc_dummy_root();
 +	if (IS_ERR(root)) {
 +		test_msg("Couldn't allocate root\n");
 +		return PTR_ERR(root);
++=======
+ 	fs_info = btrfs_alloc_dummy_fs_info();
+ 	if (!fs_info) {
+ 		test_msg("Couldn't allocate dummy fs info\n");
+ 		return -ENOMEM;
++>>>>>>> 7c0260ee098d (btrfs: tests, require fs_info for root)
  	}
  
- 	root->fs_info = btrfs_alloc_dummy_fs_info();
- 	if (!root->fs_info) {
- 		test_msg("Couldn't allocate dummy fs info\n");
- 		ret = -ENOMEM;
+ 	root = btrfs_alloc_dummy_root(fs_info, sectorsize, nodesize);
+ 	if (IS_ERR(root)) {
+ 		test_msg("Couldn't allocate root\n");
+ 		ret = PTR_ERR(root);
  		goto out;
  	}
+ 
  	/* We are using this root as our extent root */
  	root->fs_info->extent_root = root;
  
@@@ -484,9 -495,9 +493,13 @@@
  	}
  	btrfs_set_header_level(root->node, 0);
  	btrfs_set_header_nritems(root->node, 0);
 -	root->alloc_bytenr += 2 * nodesize;
 +	root->alloc_bytenr += 8192;
  
++<<<<<<< HEAD
 +	tmp_root = btrfs_alloc_dummy_root();
++=======
+ 	tmp_root = btrfs_alloc_dummy_root(fs_info, sectorsize, nodesize);
++>>>>>>> 7c0260ee098d (btrfs: tests, require fs_info for root)
  	if (IS_ERR(tmp_root)) {
  		test_msg("Couldn't allocate a fs root\n");
  		ret = PTR_ERR(tmp_root);
@@@ -501,7 -512,7 +514,11 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	tmp_root = btrfs_alloc_dummy_root();
++=======
+ 	tmp_root = btrfs_alloc_dummy_root(fs_info, sectorsize, nodesize);
++>>>>>>> 7c0260ee098d (btrfs: tests, require fs_info for root)
  	if (IS_ERR(tmp_root)) {
  		test_msg("Couldn't allocate a fs root\n");
  		ret = PTR_ERR(tmp_root);
@@@ -516,11 -527,12 +533,12 @@@
  	}
  
  	test_msg("Running qgroup tests\n");
 -	ret = test_no_shared_qgroup(root, sectorsize, nodesize);
 +	ret = test_no_shared_qgroup(root);
  	if (ret)
  		goto out;
 -	ret = test_multiple_refs(root, sectorsize, nodesize);
 +	ret = test_multiple_refs(root);
  out:
  	btrfs_free_dummy_root(root);
+ 	btrfs_free_dummy_fs_info(fs_info);
  	return ret;
  }
* Unmerged path fs/btrfs/tests/free-space-tree-tests.c
diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index eaff9105e433..3ea6a7b1dbf6 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -116,6 +116,7 @@ static inline unsigned long btrfs_chunk_item_size(int num_stripes)
 #define BTRFS_FS_STATE_REMOUNTING	1
 #define BTRFS_FS_STATE_TRANS_ABORTED	2
 #define BTRFS_FS_STATE_DEV_REPLACING	3
+#define BTRFS_FS_STATE_DUMMY_FS_INFO	4
 
 #define BTRFS_BACKREF_REV_MAX		256
 #define BTRFS_BACKREF_REV_SHIFT		56
* Unmerged path fs/btrfs/disk-io.c
* Unmerged path fs/btrfs/disk-io.h
* Unmerged path fs/btrfs/tests/btrfs-tests.c
diff --git a/fs/btrfs/tests/btrfs-tests.h b/fs/btrfs/tests/btrfs-tests.h
index fd3954224480..35061648c57f 100644
--- a/fs/btrfs/tests/btrfs-tests.h
+++ b/fs/btrfs/tests/btrfs-tests.h
@@ -34,6 +34,7 @@ int btrfs_init_test_fs(void);
 void btrfs_destroy_test_fs(void);
 struct inode *btrfs_new_test_inode(void);
 struct btrfs_fs_info *btrfs_alloc_dummy_fs_info(void);
+void btrfs_free_dummy_fs_info(struct btrfs_fs_info *fs_info);
 void btrfs_free_dummy_root(struct btrfs_root *root);
 #else
 static inline int btrfs_test_free_space_cache(void)
* Unmerged path fs/btrfs/tests/extent-buffer-tests.c
* Unmerged path fs/btrfs/tests/free-space-tests.c
* Unmerged path fs/btrfs/tests/free-space-tree-tests.c
* Unmerged path fs/btrfs/tests/inode-tests.c
* Unmerged path fs/btrfs/tests/qgroup-tests.c
