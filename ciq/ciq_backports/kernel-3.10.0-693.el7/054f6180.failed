KEYS: Simplify KEYRING_SEARCH_{NO,DO}_STATE_CHECK flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [security] keys: Simplify KEYRING_SEARCH_{NO, DO}_STATE_CHECK flags (David Howells) [1408330]
Rebuild_FUZZ: 99.10%
commit-author David Howells <dhowells@redhat.com>
commit 054f6180d8b5602b431b5924976c956e760488b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/054f6180.failed

Simplify KEYRING_SEARCH_{NO,DO}_STATE_CHECK flags to be two variations of the
same flag.  They are effectively mutually exclusive and one or the other
should be provided, but not both.

Keyring cycle detection and key possession determination are the only things
that set NO_STATE_CHECK, except that neither flag really does anything there
because neither purpose makes use of the keyring_search_iterator() function,
but rather provides their own.

For cycle detection we definitely want to check inside of expired keyrings,
just so that we don't create a cycle we can't get rid of.  Revoked keyrings
are cleared at revocation time and can't then be reused, so shouldn't be a
problem either way.

For possession determination, we *might* want to validate each keyring before
searching it: do you possess a key that's hidden behind an expired or just
plain inaccessible keyring?  Currently, the answer is yes.  Note that you
cannot, however, possess a key behind a revoked keyring because they are
cleared on revocation.

keyring_search() sets DO_STATE_CHECK, which is correct.

request_key_and_link() currently doesn't specify whether to check the key
state or not - but it should set DO_STATE_CHECK.

key_get_instantiation_authkey() also currently doesn't specify whether to
check the key state or not - but it probably should also set DO_STATE_CHECK.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Tested-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 054f6180d8b5602b431b5924976c956e760488b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/keys/request_key.c
#	security/keys/request_key_auth.c
diff --cc security/keys/request_key.c
index 67e413c80983,0bb23f98e4ca..000000000000
--- a/security/keys/request_key.c
+++ b/security/keys/request_key.c
@@@ -517,9 -513,10 +517,16 @@@ struct key *request_key_and_link(struc
  		.index_key.type		= type,
  		.index_key.description	= description,
  		.cred			= current_cred(),
++<<<<<<< HEAD
 +		.match			= type->match,
 +		.match_data		= description,
 +		.flags			= KEYRING_SEARCH_LOOKUP_DIRECT,
++=======
+ 		.match_data.cmp		= key_default_cmp,
+ 		.match_data.raw_data	= description,
+ 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
+ 		.flags			= KEYRING_SEARCH_DO_STATE_CHECK,
++>>>>>>> 054f6180d8b5 (KEYS: Simplify KEYRING_SEARCH_{NO,DO}_STATE_CHECK flags)
  	};
  	struct key *key;
  	key_ref_t key_ref;
diff --cc security/keys/request_key_auth.c
index 7495a93b4b90,5d672f7580dd..000000000000
--- a/security/keys/request_key_auth.c
+++ b/security/keys/request_key_auth.c
@@@ -233,9 -246,10 +233,16 @@@ struct key *key_get_instantiation_authk
  		.index_key.type		= &key_type_request_key_auth,
  		.index_key.description	= description,
  		.cred			= current_cred(),
++<<<<<<< HEAD
 +		.match			= user_match,
 +		.match_data		= description,
 +		.flags			= KEYRING_SEARCH_LOOKUP_DIRECT,
++=======
+ 		.match_data.cmp		= key_default_cmp,
+ 		.match_data.raw_data	= description,
+ 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
+ 		.flags			= KEYRING_SEARCH_DO_STATE_CHECK,
++>>>>>>> 054f6180d8b5 (KEYS: Simplify KEYRING_SEARCH_{NO,DO}_STATE_CHECK flags)
  	};
  	struct key *authkey;
  	key_ref_t authkey_ref;
diff --git a/security/keys/keyring.c b/security/keys/keyring.c
index 04d0d7c2ab0e..6233961689ef 100644
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@ -609,6 +609,10 @@ static bool search_nested_keyrings(struct key *keyring,
 	       ctx->index_key.type->name,
 	       ctx->index_key.description);
 
+#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)
+	BUG_ON((ctx->flags & STATE_CHECKS) == 0 ||
+	       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);
+
 	if (ctx->index_key.description)
 		ctx->index_key.desc_len = strlen(ctx->index_key.description);
 
@@ -618,7 +622,6 @@ static bool search_nested_keyrings(struct key *keyring,
 	if (ctx->flags & KEYRING_SEARCH_LOOKUP_ITERATE ||
 	    keyring_compare_object(keyring, &ctx->index_key)) {
 		ctx->skipped_ret = 2;
-		ctx->flags |= KEYRING_SEARCH_DO_STATE_CHECK;
 		switch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {
 		case 1:
 			goto found;
@@ -630,8 +633,6 @@ static bool search_nested_keyrings(struct key *keyring,
 	}
 
 	ctx->skipped_ret = 0;
-	if (ctx->flags & KEYRING_SEARCH_NO_STATE_CHECK)
-		ctx->flags &= ~KEYRING_SEARCH_DO_STATE_CHECK;
 
 	/* Start processing a new keyring */
 descend_to_keyring:
* Unmerged path security/keys/request_key.c
* Unmerged path security/keys/request_key_auth.c
