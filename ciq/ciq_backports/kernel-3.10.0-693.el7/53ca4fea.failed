NTB: Code Style Clean-up

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [ntb] Code Style Clean-up (Suravee Suthikulpanit) [1303727]
Rebuild_FUZZ: 88.37%
commit-author Jon Mason <jon.mason@intel.com>
commit 53ca4fea0bbe966b3123509125898b286a136f47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/53ca4fea.failed

Some white space and 80 char overruns corrected.

	Signed-off-by: Jon Mason <jon.mason@intel.com>
(cherry picked from commit 53ca4fea0bbe966b3123509125898b286a136f47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ntb_netdev.c
#	drivers/ntb/ntb_hw.c
diff --cc drivers/net/ntb_netdev.c
index db34e2d54fd9,63aa9d9e34c5..000000000000
--- a/drivers/net/ntb_netdev.c
+++ b/drivers/net/ntb_netdev.c
@@@ -375,12 -377,15 +375,16 @@@ static void ntb_netdev_remove(struct pc
  {
  	struct net_device *ndev;
  	struct ntb_netdev *dev;
++<<<<<<< HEAD
++=======
+ 	bool found = false;
++>>>>>>> 53ca4fea0bbe (NTB: Code Style Clean-up)
  
  	list_for_each_entry(dev, &dev_list, list) {
 -		if (dev->pdev == pdev) {
 -			found = true;
 +		if (dev->pdev == pdev)
  			break;
 -		}
  	}
 -	if (!found)
 +	if (dev == NULL)
  		return;
  
  	list_del(&dev->list);
diff --cc drivers/ntb/ntb_hw.c
index 0d1ee9d661d9,eba1ed58471d..000000000000
--- a/drivers/ntb/ntb_hw.c
+++ b/drivers/ntb/ntb_hw.c
@@@ -582,104 -681,191 +583,288 @@@ static int ntb_xeon_setup(struct ntb_de
  	else
  		ndev->dev_type = NTB_DEV_DSD;
  
++<<<<<<< HEAD
 +	ndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
 +	ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;
 +	ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;
 +	ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;
++=======
+ 	switch (val & SNB_PPD_CONN_TYPE) {
+ 	case NTB_CONN_B2B:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = B2B\n");
+ 		ndev->conn_type = NTB_CONN_B2B;
+ 		ndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;
+ 		ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;
+ 		ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;
+ 		ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;
+ 		ndev->limits.max_spads = SNB_MAX_B2B_SPADS;
+ 
+ 		/* There is a Xeon hardware errata related to writes to
+ 		 * SDOORBELL or B2BDOORBELL in conjunction with inbound access
+ 		 * to NTB MMIO Space, which may hang the system.  To workaround
+ 		 * this use the second memory window to access the interrupt and
+ 		 * scratch pad registers on the remote system.
+ 		 */
+ 		if (xeon_errata_workaround) {
+ 			if (!ndev->mw[1].bar_sz)
+ 				return -EINVAL;
+ 
+ 			ndev->limits.max_mw = SNB_ERRATA_MAX_MW;
+ 			ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
+ 			ndev->reg_ofs.spad_write = ndev->mw[1].vbase +
+ 						   SNB_SPAD_OFFSET;
+ 			ndev->reg_ofs.rdb = ndev->mw[1].vbase +
+ 					    SNB_PDOORBELL_OFFSET;
+ 
+ 			/* Set the Limit register to 4k, the minimum size, to
+ 			 * prevent an illegal access
+ 			 */
+ 			writeq(ndev->mw[1].bar_sz + 0x1000, ndev->reg_base +
+ 			       SNB_PBAR4LMT_OFFSET);
+ 			/* HW errata on the Limit registers.  They can only be
+ 			 * written when the base register is 4GB aligned and
+ 			 * < 32bit.  This should already be the case based on
+ 			 * the driver defaults, but write the Limit registers
+ 			 * first just in case.
+ 			 */
+ 		} else {
+ 			ndev->limits.max_mw = SNB_MAX_MW;
+ 
+ 			/* HW Errata on bit 14 of b2bdoorbell register.  Writes
+ 			 * will not be mirrored to the remote system.  Shrink
+ 			 * the number of bits by one, since bit 14 is the last
+ 			 * bit.
+ 			 */
+ 			ndev->limits.max_db_bits = SNB_MAX_DB_BITS - 1;
+ 			ndev->reg_ofs.spad_write = ndev->reg_base +
+ 						   SNB_B2B_SPAD_OFFSET;
+ 			ndev->reg_ofs.rdb = ndev->reg_base +
+ 					    SNB_B2B_DOORBELL_OFFSET;
+ 
+ 			/* Disable the Limit register, just incase it is set to
+ 			 * something silly
+ 			 */
+ 			writeq(0, ndev->reg_base + SNB_PBAR4LMT_OFFSET);
+ 			/* HW errata on the Limit registers.  They can only be
+ 			 * written when the base register is 4GB aligned and
+ 			 * < 32bit.  This should already be the case based on
+ 			 * the driver defaults, but write the Limit registers
+ 			 * first just in case.
+ 			 */
+ 		}
+ 
+ 		/* The Xeon errata workaround requires setting SBAR Base
+ 		 * addresses to known values, so that the PBAR XLAT can be
+ 		 * pointed at SBAR0 of the remote system.
+ 		 */
+ 		if (ndev->dev_type == NTB_DEV_USD) {
+ 			writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
+ 			       SNB_PBAR2XLAT_OFFSET);
+ 			if (xeon_errata_workaround)
+ 				writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 			else {
+ 				writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 				/* B2B_XLAT_OFFSET is a 64bit register, but can
+ 				 * only take 32bit writes
+ 				 */
+ 				writel(SNB_MBAR01_DSD_ADDR & 0xffffffff,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
+ 				writel(SNB_MBAR01_DSD_ADDR >> 32,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
+ 			}
+ 
+ 			writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR0BASE_OFFSET);
+ 			writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR2BASE_OFFSET);
+ 			writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR4BASE_OFFSET);
+ 		} else {
+ 			writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
+ 			       SNB_PBAR2XLAT_OFFSET);
+ 			if (xeon_errata_workaround)
+ 				writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 			else {
+ 				writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 				/* B2B_XLAT_OFFSET is a 64bit register, but can
+ 				 * only take 32bit writes
+ 				 */
+ 				writel(SNB_MBAR01_USD_ADDR & 0xffffffff,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
+ 				writel(SNB_MBAR01_USD_ADDR >> 32,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
+ 			}
+ 			writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR0BASE_OFFSET);
+ 			writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR2BASE_OFFSET);
+ 			writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR4BASE_OFFSET);
+ 		}
+ 		break;
+ 	case NTB_CONN_RP:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = RP\n");
+ 		ndev->conn_type = NTB_CONN_RP;
+ 
+ 		if (xeon_errata_workaround) {
+ 			dev_err(&ndev->pdev->dev,
+ 				"NTB-RP disabled due to hardware errata.  To disregard this warning and potentially lock-up the system, add the parameter 'xeon_errata_workaround=0'.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		/* Scratch pads need to have exclusive access from the primary
+ 		 * or secondary side.  Halve the num spads so that each side can
+ 		 * have an equal amount.
+ 		 */
+ 		ndev->limits.max_spads = SNB_MAX_COMPAT_SPADS / 2;
+ 		ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
+ 		/* Note: The SDOORBELL is the cause of the errata.  You REALLY
+ 		 * don't want to touch it.
+ 		 */
+ 		ndev->reg_ofs.rdb = ndev->reg_base + SNB_SDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;
+ 		/* Offset the start of the spads to correspond to whether it is
+ 		 * primary or secondary
+ 		 */
+ 		ndev->reg_ofs.spad_write = ndev->reg_base + SNB_SPAD_OFFSET +
+ 					   ndev->limits.max_spads * 4;
+ 		ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;
+ 		ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;
+ 		ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;
+ 		ndev->limits.max_mw = SNB_MAX_MW;
+ 		break;
+ 	case NTB_CONN_TRANSPARENT:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = TRANSPARENT\n");
+ 		ndev->conn_type = NTB_CONN_TRANSPARENT;
+ 		/* Scratch pads need to have exclusive access from the primary
+ 		 * or secondary side.  Halve the num spads so that each side can
+ 		 * have an equal amount.
+ 		 */
+ 		ndev->limits.max_spads = SNB_MAX_COMPAT_SPADS / 2;
+ 		ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
+ 		ndev->reg_ofs.rdb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb = ndev->reg_base + SNB_SDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_SDBMSK_OFFSET;
+ 		ndev->reg_ofs.spad_write = ndev->reg_base + SNB_SPAD_OFFSET;
+ 		/* Offset the start of the spads to correspond to whether it is
+ 		 * primary or secondary
+ 		 */
+ 		ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET +
+ 					  ndev->limits.max_spads * 4;
+ 		ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_PBAR2XLAT_OFFSET;
+ 		ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_PBAR4XLAT_OFFSET;
+ 
+ 		ndev->limits.max_mw = SNB_MAX_MW;
+ 		break;
+ 	default:
+ 		/* Most likely caused by the remote NTB-RP device not being
+ 		 * configured
+ 		 */
+ 		dev_err(&ndev->pdev->dev, "Unknown PPD %x\n", val);
+ 		return -EINVAL;
+ 	}
+ 
++>>>>>>> 53ca4fea0bbe (NTB: Code Style Clean-up)
  	ndev->reg_ofs.lnk_cntl = ndev->reg_base + SNB_NTBCNTL_OFFSET;
 -	ndev->reg_ofs.lnk_stat = ndev->reg_base + SNB_SLINK_STATUS_OFFSET;
 +	ndev->reg_ofs.lnk_stat = ndev->reg_base + SNB_LINK_STATUS_OFFSET;
 +	ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;
  	ndev->reg_ofs.spci_cmd = ndev->reg_base + SNB_PCICMD_OFFSET;
  
 +	/* There is a Xeon hardware errata related to writes to
 +	 * SDOORBELL or B2BDOORBELL in conjunction with inbound access
 +	 * to NTB MMIO Space, which may hang the system.  To workaround
 +	 * this use the second memory window to access the interrupt and
 +	 * scratch pad registers on the remote system.
 +	 */
 +	if (xeon_errata_workaround) {
 +		if (!ndev->mw[1].bar_sz)
 +			return -EINVAL;
 +
 +		ndev->limits.max_mw = SNB_ERRATA_MAX_MW;
 +		ndev->reg_ofs.spad_write = ndev->mw[1].vbase +
 +					   SNB_SPAD_OFFSET;
 +		ndev->reg_ofs.rdb = ndev->mw[1].vbase +
 +				    SNB_PDOORBELL_OFFSET;
 +
 +		/* Set the Limit register to 4k, the minimum size, to
 +		 * prevent an illegal access
 +		 */
 +		writeq(ndev->mw[1].bar_sz + 0x1000, ndev->reg_base +
 +		       SNB_PBAR4LMT_OFFSET);
 +	} else {
 +		ndev->limits.max_mw = SNB_MAX_MW;
 +		ndev->reg_ofs.spad_write = ndev->reg_base +
 +					   SNB_B2B_SPAD_OFFSET;
 +		ndev->reg_ofs.rdb = ndev->reg_base +
 +				    SNB_B2B_DOORBELL_OFFSET;
 +
 +		/* Disable the Limit register, just incase it is set to
 +		 * something silly
 +		 */
 +		writeq(0, ndev->reg_base + SNB_PBAR4LMT_OFFSET);
 +	}
 +
 +	/* The Xeon errata workaround requires setting SBAR Base
 +	 * addresses to known values, so that the PBAR XLAT can be
 +	 * pointed at SBAR0 of the remote system.
 +	 */
 +	if (ndev->dev_type == NTB_DEV_USD) {
 +		writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
 +		       SNB_PBAR2XLAT_OFFSET);
 +		if (xeon_errata_workaround)
 +			writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
 +			       SNB_PBAR4XLAT_OFFSET);
 +		else {
 +			writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
 +			       SNB_PBAR4XLAT_OFFSET);
 +			/* B2B_XLAT_OFFSET is a 64bit register, but can
 +			 * only take 32bit writes
 +			 */
 +			writel(SNB_MBAR01_USD_ADDR & 0xffffffff,
 +			       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
 +			writel(SNB_MBAR01_DSD_ADDR >> 32,
 +			       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
 +		}
 +
 +		writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
 +		       SNB_SBAR0BASE_OFFSET);
 +		writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
 +		       SNB_SBAR2BASE_OFFSET);
 +		writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
 +		       SNB_SBAR4BASE_OFFSET);
 +	} else {
 +		writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
 +		       SNB_PBAR2XLAT_OFFSET);
 +		if (xeon_errata_workaround)
 +			writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
 +			       SNB_PBAR4XLAT_OFFSET);
 +		else {
 +			writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
 +			       SNB_PBAR4XLAT_OFFSET);
 +			/* B2B_XLAT_OFFSET is a 64bit register, but can
 +			 * only take 32bit writes
 +			 */
 +			writel(SNB_MBAR01_USD_ADDR & 0xffffffff,
 +			       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
 +			writel(SNB_MBAR01_USD_ADDR >> 32,
 +			       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
 +		}
 +		writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
 +		       SNB_SBAR0BASE_OFFSET);
 +		writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
 +		       SNB_SBAR2BASE_OFFSET);
 +		writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
 +		       SNB_SBAR4BASE_OFFSET);
 +	}
 +
 +	ndev->limits.max_spads = SNB_MAX_B2B_SPADS;
 +	ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
  	ndev->limits.msix_cnt = SNB_MSIX_CNT;
  	ndev->bits_per_vector = SNB_DB_BITS_PER_VEC;
  
* Unmerged path drivers/net/ntb_netdev.c
* Unmerged path drivers/ntb/ntb_hw.c
diff --git a/drivers/ntb/ntb_hw.h b/drivers/ntb/ntb_hw.h
index 8f6ab08cfa52..b698a6fcfb04 100644
--- a/drivers/ntb/ntb_hw.h
+++ b/drivers/ntb/ntb_hw.h
@@ -221,7 +221,7 @@ int ntb_register_db_callback(struct ntb_device *ndev, unsigned int idx,
 							   int db_num));
 void ntb_unregister_db_callback(struct ntb_device *ndev, unsigned int idx);
 int ntb_register_event_callback(struct ntb_device *ndev,
-				void (*event_cb_func) (void *handle,
+				void (*event_cb_func)(void *handle,
 						      enum ntb_hw_event event));
 void ntb_unregister_event_callback(struct ntb_device *ndev);
 int ntb_get_max_spads(struct ntb_device *ndev);
diff --git a/drivers/ntb/ntb_transport.c b/drivers/ntb/ntb_transport.c
index 075a8486498c..0a2f55c8340f 100644
--- a/drivers/ntb/ntb_transport.c
+++ b/drivers/ntb/ntb_transport.c
@@ -106,8 +106,8 @@ struct ntb_transport_qp {
 	struct ntb_rx_info __iomem *rx_info;
 	struct ntb_rx_info *remote_rx_info;
 
-	void (*tx_handler) (struct ntb_transport_qp *qp, void *qp_data,
-			    void *data, int len);
+	void (*tx_handler)(struct ntb_transport_qp *qp, void *qp_data,
+			   void *data, int len);
 	struct list_head tx_free_q;
 	spinlock_t ntb_tx_free_q_lock;
 	void __iomem *tx_mw;
@@ -116,8 +116,8 @@ struct ntb_transport_qp {
 	unsigned int tx_max_entry;
 	unsigned int tx_max_frame;
 
-	void (*rx_handler) (struct ntb_transport_qp *qp, void *qp_data,
-			    void *data, int len);
+	void (*rx_handler)(struct ntb_transport_qp *qp, void *qp_data,
+			   void *data, int len);
 	struct list_head rx_pend_q;
 	struct list_head rx_free_q;
 	spinlock_t ntb_rx_pend_q_lock;
@@ -128,7 +128,7 @@ struct ntb_transport_qp {
 	unsigned int rx_max_frame;
 	dma_cookie_t last_cookie;
 
-	void (*event_handler) (void *data, int status);
+	void (*event_handler)(void *data, int status);
 	struct delayed_work link_work;
 	struct work_struct link_cleanup;
 
@@ -479,7 +479,7 @@ static void ntb_list_add(spinlock_t *lock, struct list_head *entry,
 }
 
 static struct ntb_queue_entry *ntb_list_rm(spinlock_t *lock,
-						struct list_head *list)
+					   struct list_head *list)
 {
 	struct ntb_queue_entry *entry;
 	unsigned long flags;
@@ -838,7 +838,7 @@ static void ntb_qp_link_work(struct work_struct *work)
 }
 
 static int ntb_transport_init_queue(struct ntb_transport *nt,
-				     unsigned int qp_num)
+				    unsigned int qp_num)
 {
 	struct ntb_transport_qp *qp;
 	unsigned int num_qps_mw, tx_size;
@@ -1058,7 +1058,7 @@ static void ntb_async_rx(struct ntb_queue_entry *entry, void *offset,
 	if (!chan)
 		goto err;
 
-	if (len < copy_bytes) 
+	if (len < copy_bytes)
 		goto err_wait;
 
 	device = chan->device;
@@ -1194,8 +1194,7 @@ out:
 	return 0;
 
 err:
-	ntb_list_add(&qp->ntb_rx_pend_q_lock, &entry->entry,
-		     &qp->rx_pend_q);
+	ntb_list_add(&qp->ntb_rx_pend_q_lock, &entry->entry, &qp->rx_pend_q);
 	/* Ensure that the data is fully copied out before clearing the flag */
 	wmb();
 	hdr->flags = 0;
diff --git a/include/linux/ntb.h b/include/linux/ntb.h
index cbc792cd745e..9ac1a62fc6f5 100644
--- a/include/linux/ntb.h
+++ b/include/linux/ntb.h
@@ -50,8 +50,8 @@ struct ntb_transport_qp;
 
 struct ntb_client {
 	struct device_driver driver;
-	int (*probe) (struct pci_dev *pdev);
-	void (*remove) (struct pci_dev *pdev);
+	int (*probe)(struct pci_dev *pdev);
+	void (*remove)(struct pci_dev *pdev);
 };
 
 enum {
@@ -65,11 +65,11 @@ int ntb_register_client_dev(char *device_name);
 void ntb_unregister_client_dev(char *device_name);
 
 struct ntb_queue_handlers {
-	void (*rx_handler) (struct ntb_transport_qp *qp, void *qp_data,
-			    void *data, int len);
-	void (*tx_handler) (struct ntb_transport_qp *qp, void *qp_data,
-			    void *data, int len);
-	void (*event_handler) (void *data, int status);
+	void (*rx_handler)(struct ntb_transport_qp *qp, void *qp_data,
+			   void *data, int len);
+	void (*tx_handler)(struct ntb_transport_qp *qp, void *qp_data,
+			   void *data, int len);
+	void (*event_handler)(void *data, int status);
 };
 
 unsigned char ntb_transport_qp_num(struct ntb_transport_qp *qp);
