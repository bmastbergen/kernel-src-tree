NFS: Move the flock open mode check into nfs_flock()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Benjamin Coddington <bcodding@redhat.com>
commit e12937279c8b07798651de7f5c8c52974c699931
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e1293727.failed

We only need to check lock exclusive/shared types against open mode when
flock() is used on NFS, so move it into the flock-specific path instead of
checking it for all locks.

	Signed-off-by: Benjamin Coddington <bcodding@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit e12937279c8b07798651de7f5c8c52974c699931)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/file.c
#	fs/nfs/nfs4proc.c
diff --cc fs/nfs/file.c
index c497ac465f2a,b7f4af3483b6..000000000000
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@@ -930,13 -820,23 +930,32 @@@ int nfs_flock(struct file *filp, int cm
  	if (NFS_SERVER(inode)->flags & NFS_MOUNT_LOCAL_FLOCK)
  		is_local = 1;
  
++<<<<<<< HEAD
 +	/* We're simulating flock() locks using posix locks on the server */
 +	fl->fl_owner = (fl_owner_t)filp;
 +	fl->fl_start = 0;
 +	fl->fl_end = OFFSET_MAX;
 +
 +	if (fl->fl_type == F_UNLCK)
++=======
+ 	/*
+ 	 * VFS doesn't require the open mode to match a flock() lock's type.
+ 	 * NFS, however, may simulate flock() locking with posix locking which
+ 	 * requires the open mode to match the lock type.
+ 	 */
+ 	switch (fl->fl_type) {
+ 	case F_UNLCK:
++>>>>>>> e12937279c8b (NFS: Move the flock open mode check into nfs_flock())
  		return do_unlk(filp, cmd, fl, is_local);
+ 	case F_RDLCK:
+ 		if (!(filp->f_mode & FMODE_READ))
+ 			return -EBADF;
+ 		break;
+ 	case F_WRLCK:
+ 		if (!(filp->f_mode & FMODE_WRITE))
+ 			return -EBADF;
+ 	}
+ 
  	return do_setlk(filp, cmd, fl, is_local);
  }
  EXPORT_SYMBOL_GPL(nfs_flock);
diff --cc fs/nfs/nfs4proc.c
index 2f4df4d62ee1,c52f72c86940..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -6287,30 -6464,16 +6287,43 @@@ nfs4_proc_lock(struct file *filp, int c
  
  	if (state == NULL)
  		return -ENOLCK;
++<<<<<<< HEAD
 +	/*
 +	 * Don't rely on the VFS having checked the file open mode,
 +	 * since it won't do this for flock() locks.
 +	 */
 +	switch (request->fl_type) {
 +	case F_RDLCK:
 +		if (!(filp->f_mode & FMODE_READ))
 +			return -EBADF;
 +		break;
 +	case F_WRLCK:
 +		if (!(filp->f_mode & FMODE_WRITE))
 +			return -EBADF;
 +	}
 +
 +	do {
 +		status = nfs4_proc_setlk(state, cmd, request);
 +		if ((status != -EAGAIN) || IS_SETLK(cmd))
 +			break;
 +		timeout = nfs4_set_lock_task_retry(timeout);
 +		status = -ERESTARTSYS;
 +		if (signalled())
 +			break;
 +	} while(status < 0);
 +	return status;
++=======
+ 
+ 	if ((request->fl_flags & FL_POSIX) &&
+ 	    !test_bit(NFS_STATE_POSIX_LOCKS, &state->flags))
+ 		return -ENOLCK;
+ 
+ 	status = nfs4_set_lock_state(state, request);
+ 	if (status != 0)
+ 		return status;
+ 
+ 	return nfs4_retry_setlk(state, cmd, request);
++>>>>>>> e12937279c8b (NFS: Move the flock open mode check into nfs_flock())
  }
  
  int nfs4_lock_delegation_recall(struct file_lock *fl, struct nfs4_state *state, const nfs4_stateid *stateid)
* Unmerged path fs/nfs/file.c
* Unmerged path fs/nfs/nfs4proc.c
