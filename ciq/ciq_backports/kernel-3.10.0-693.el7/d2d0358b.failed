scsi: megaraid_sas: MR_TargetIdToLdGet u8 to u16 and avoid invalid raid-map access

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] megaraid_sas: MR_TargetIdToLdGet u8 to u16 and avoid invalid raid-map access (Tomas Henzl) [1417038]
Rebuild_FUZZ: 96.20%
commit-author Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
commit d2d0358bcd09139a8e71afbca35bcd6b219dd1bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d2d0358b.failed

Change MR_TargetIdToLdGet return type from u8 to u16.

ld id range check is added at two places in this patch -
@megasas_build_ldio_fusion and @megasas_build_ld_nonrw_fusion.  Previous
driver code used different data type for lds TargetId returned from
MR_TargetIdToLdGet.  Prior to this change, above two functions was
safeguarded due to function always return u8 and maximum value of ld id
returned was 255.

In below check, fw_supported_vd_count as of today is 64 or 256 and valid
range to support is either 0-63 or 0-255. Ideally want to filter
accessing raid map for ld ids which are not valid. With the u16 change,
invalid ld id value is 0xFFFF and we will see kernel panic due to random
memory access in MR_LdRaidGet.  The changes will ensure we do not call
MR_LdRaidGet if ld id is beyond size of ldSpanMap array.

               if (ld < instance->fw_supported_vd_count)

>From firmware perspective,ld id 0xFF is invalid and even though current
driver code forward such command, firmware fails with target not
available.

ld target id issue occurs mainly whenever driver loops to populate raid
map (ea. MR_ValidateMapInfo).  These are the only two places where we
may see out of range target ids and wants to protect raid map access
based on range provided by Firmware API.

	Signed-off-by: Shivasharan S <shivasharan.srikanteshwara@broadcom.com>
	Signed-off-by: Kashyap Desai <kashyap.desai@broadcom.com>
	Reviewed-by: Tomas Henzl <thenzl@redhat.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit d2d0358bcd09139a8e71afbca35bcd6b219dd1bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/megaraid/megaraid_sas_fusion.c
diff --cc drivers/scsi/megaraid/megaraid_sas_fusion.c
index 3d939ec71312,4aaf30769c94..000000000000
--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c
@@@ -1940,11 -2303,14 +1941,22 @@@ megasas_build_ldio_fusion(struct megasa
  		io_info.isRead = 1;
  
  	local_map_ptr = fusion->ld_drv_map[(instance->map_id & 1)];
++<<<<<<< HEAD
 +
 +	if ((MR_TargetIdToLdGet(device_id, local_map_ptr) >=
 +		instance->fw_supported_vd_count) || (!fusion->fast_path_io)) {
 +		io_request->RaidContext.raid_context.regLockFlags  = 0;
 +		fp_possible = 0;
++=======
+ 	ld = MR_TargetIdToLdGet(device_id, local_map_ptr);
+ 
+ 	if (ld < instance->fw_supported_vd_count)
+ 		raid = MR_LdRaidGet(ld, local_map_ptr);
+ 
+ 	if (!raid || (!fusion->fast_path_io)) {
+ 		io_request->RaidContext.raid_context.reg_lock_flags  = 0;
+ 		fp_possible = false;
++>>>>>>> d2d0358bcd09 (scsi: megaraid_sas: MR_TargetIdToLdGet u8 to u16 and avoid invalid raid-map access)
  	} else {
  		if (MR_BuildRaidContext(instance, &io_info,
  					&io_request->RaidContext.raid_context,
diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h
index b56fc034d83f..5747677346a0 100644
--- a/drivers/scsi/megaraid/megaraid_sas.h
+++ b/drivers/scsi/megaraid/megaraid_sas.h
@@ -2358,7 +2358,7 @@ MR_BuildRaidContext(struct megasas_instance *instance,
 		    struct IO_REQUEST_INFO *io_info,
 		    struct RAID_CONTEXT *pRAID_Context,
 		    struct MR_DRV_RAID_MAP_ALL *map, u8 **raidLUN);
-u8 MR_TargetIdToLdGet(u32 ldTgtId, struct MR_DRV_RAID_MAP_ALL *map);
+u16 MR_TargetIdToLdGet(u32 ldTgtId, struct MR_DRV_RAID_MAP_ALL *map);
 struct MR_LD_RAID *MR_LdRaidGet(u32 ld, struct MR_DRV_RAID_MAP_ALL *map);
 u16 MR_ArPdGet(u32 ar, u32 arm, struct MR_DRV_RAID_MAP_ALL *map);
 u16 MR_LdSpanArrayGet(u32 ld, u32 span, struct MR_DRV_RAID_MAP_ALL *map);
diff --git a/drivers/scsi/megaraid/megaraid_sas_fp.c b/drivers/scsi/megaraid/megaraid_sas_fp.c
index 53238db53032..b5393f6ca24d 100644
--- a/drivers/scsi/megaraid/megaraid_sas_fp.c
+++ b/drivers/scsi/megaraid/megaraid_sas_fp.c
@@ -160,7 +160,7 @@ u16 MR_GetLDTgtId(u32 ld, struct MR_DRV_RAID_MAP_ALL *map)
 	return le16_to_cpu(map->raidMap.ldSpanMap[ld].ldRaid.targetId);
 }
 
-u8 MR_TargetIdToLdGet(u32 ldTgtId, struct MR_DRV_RAID_MAP_ALL *map)
+u16 MR_TargetIdToLdGet(u32 ldTgtId, struct MR_DRV_RAID_MAP_ALL *map)
 {
 	return map->raidMap.ldTgtIdToLd[ldTgtId];
 }
@@ -933,7 +933,7 @@ MR_BuildRaidContext(struct megasas_instance *instance,
 {
 	struct fusion_context *fusion;
 	struct MR_LD_RAID  *raid;
-	u32         ld, stripSize, stripe_mask;
+	u32         stripSize, stripe_mask;
 	u64         endLba, endStrip, endRow, start_row, start_strip;
 	u64         regStart;
 	u32         regSize;
@@ -945,6 +945,7 @@ MR_BuildRaidContext(struct megasas_instance *instance,
 	u8	    retval = 0;
 	u8	    startlba_span = SPAN_INVALID;
 	u64 *pdBlock = &io_info->pdBlock;
+	u16	    ld;
 
 	ldStartBlock = io_info->ldStartBlock;
 	numBlocks = io_info->numBlocks;
* Unmerged path drivers/scsi/megaraid/megaraid_sas_fusion.c
