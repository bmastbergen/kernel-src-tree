tools/power turbostat: fix bugs in --add option

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [tools] power turbostat: fix bugs in --add option (Prarit Bhargava) [1447265]
Rebuild_FUZZ: 93.18%
commit-author Len Brown <len.brown@intel.com>
commit 678a3bd1b3de6d2ebf604e7d708bc8150bb667e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/678a3bd1.failed

When --add was used more than once, overflowed buffers
caused some counters to be stored on top of others,
corrupting the results.  Simplify the code by simply
reserving space for up to 16 added counters per each
cpu, core, package.

Per-cpu added counters were being printed only per-core.

	Signed-off-by: Len Brown <len.brown@intel.com>
(cherry picked from commit 678a3bd1b3de6d2ebf604e7d708bc8150bb667e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/power/x86/turbostat/turbostat.c
diff --cc tools/power/x86/turbostat/turbostat.c
index 92e6f5e6c99d,c7fadf0faa4b..000000000000
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@@ -154,6 -167,7 +155,10 @@@ struct thread_data 
  	unsigned int flags;
  #define CPU_IS_FIRST_THREAD_IN_CORE	0x2
  #define CPU_IS_FIRST_CORE_IN_PACKAGE	0x4
++<<<<<<< HEAD
++=======
+ 	unsigned long long counter[MAX_ADDED_COUNTERS];
++>>>>>>> 678a3bd1b3de (tools/power turbostat: fix bugs in --add option)
  } *thread_even, *thread_odd;
  
  struct core_data {
@@@ -162,6 -176,7 +167,10 @@@
  	unsigned long long c7;
  	unsigned int core_temp_c;
  	unsigned int core_id;
++<<<<<<< HEAD
++=======
+ 	unsigned long long counter[MAX_ADDED_COUNTERS];
++>>>>>>> 678a3bd1b3de (tools/power turbostat: fix bugs in --add option)
  } *core_even, *core_odd;
  
  struct pkg_data {
@@@ -184,7 -201,7 +193,11 @@@
  	unsigned int rapl_pkg_perf_status;	/* MSR_PKG_PERF_STATUS */
  	unsigned int rapl_dram_perf_status;	/* MSR_DRAM_PERF_STATUS */
  	unsigned int pkg_temp_c;
++<<<<<<< HEAD
 +
++=======
+ 	unsigned long long counter[MAX_ADDED_COUNTERS];
++>>>>>>> 678a3bd1b3de (tools/power turbostat: fix bugs in --add option)
  } *package_even, *package_odd;
  
  #define ODD_COUNTERS thread_odd, core_odd, package_odd
@@@ -198,6 -215,28 +211,31 @@@
  	(core_base + (pkg_no) * topo.num_cores_per_pkg + (core_no))
  #define GET_PKG(pkg_base, pkg_no) (pkg_base + pkg_no)
  
++<<<<<<< HEAD
++=======
+ enum counter_scope {SCOPE_CPU, SCOPE_CORE, SCOPE_PACKAGE};
+ enum counter_type {COUNTER_CYCLES, COUNTER_SECONDS};
+ enum counter_format {FORMAT_RAW, FORMAT_DELTA, FORMAT_PERCENT};
+ 
+ struct msr_counter {
+ 	unsigned int msr_num;
+ 	char name[NAME_BYTES];
+ 	unsigned int width;
+ 	enum counter_type type;
+ 	enum counter_format format;
+ 	struct msr_counter *next;
+ };
+ 
+ struct sys_counters {
+ 	unsigned int added_thread_counters;
+ 	unsigned int added_core_counters;
+ 	unsigned int added_package_counters;
+ 	struct msr_counter *tp;
+ 	struct msr_counter *cp;
+ 	struct msr_counter *pp;
+ } sys;
+ 
++>>>>>>> 678a3bd1b3de (tools/power turbostat: fix bugs in --add option)
  struct system_summary {
  	struct thread_data threads;
  	struct core_data cores;
@@@ -296,51 -349,80 +334,74 @@@ int get_msr(int cpu, off_t offset, unsi
  
  void print_header(void)
  {
 -	struct msr_counter *mp;
 -
  	if (show_pkg)
 -		outp += sprintf(outp, "\tPackage");
 +		outp += sprintf(outp, " Package");
  	if (show_core)
 -		outp += sprintf(outp, "\tCore");
 +		outp += sprintf(outp, "    Core");
  	if (show_cpu)
 -		outp += sprintf(outp, "\tCPU");
 +		outp += sprintf(outp, "     CPU");
  	if (has_aperf)
 -		outp += sprintf(outp, "\tAvg_MHz");
 +		outp += sprintf(outp, " Avg_MHz");
  	if (has_aperf)
 -		outp += sprintf(outp, "\tBusy%%");
 +		outp += sprintf(outp, "   %%Busy");
  	if (has_aperf)
 -		outp += sprintf(outp, "\tBzy_MHz");
 -	outp += sprintf(outp, "\tTSC_MHz");
 -
 -	if (!debug)
 -		goto done;
 +		outp += sprintf(outp, " Bzy_MHz");
 +	outp += sprintf(outp, " TSC_MHz");
 +
 +	if (extra_delta_offset32)
 +		outp += sprintf(outp, "  count 0x%03X", extra_delta_offset32);
 +	if (extra_delta_offset64)
 +		outp += sprintf(outp, "  COUNT 0x%03X", extra_delta_offset64);
 +	if (extra_msr_offset32)
 +		outp += sprintf(outp, "   MSR 0x%03X", extra_msr_offset32);
 +	if (extra_msr_offset64)
 +		outp += sprintf(outp, "           MSR 0x%03X", extra_msr_offset64);
  
 -	if (do_irq)
 -		outp += sprintf(outp, "\tIRQ");
  	if (do_smi)
 -		outp += sprintf(outp, "\tSMI");
 +		outp += sprintf(outp, "     SMI");
  
  	if (do_nhm_cstates)
++<<<<<<< HEAD
 +		outp += sprintf(outp, "  CPU%%c1");
 +	if (do_nhm_cstates && !do_slm_cstates && !do_knl_cstates)
 +		outp += sprintf(outp, "  CPU%%c3");
 +	if (do_nhm_cstates)
 +		outp += sprintf(outp, "  CPU%%c6");
 +	if (do_snb_cstates)
 +		outp += sprintf(outp, "  CPU%%c7");
++=======
+ 		outp += sprintf(outp, "\tCPU%%c1");
+ 
+ 	for (mp = sys.tp; mp; mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 64)
+ 				outp += sprintf(outp, "\t%18.18s", mp->name);
+ 			else
+ 				outp += sprintf(outp, "\t%10.10s", mp->name);
+ 		} else {
+ 			outp += sprintf(outp, "\t%-7.7s", mp->name);
+ 		}
+ 	}
++>>>>>>> 678a3bd1b3de (tools/power turbostat: fix bugs in --add option)
+ 
+ 	if (do_nhm_cstates && !do_slm_cstates && !do_knl_cstates)
+ 		outp += sprintf(outp, "\tCPU%%c3");
+ 	if (do_nhm_cstates)
+ 		outp += sprintf(outp, "\tCPU%%c6");
+ 	if (do_snb_cstates)
+ 		outp += sprintf(outp, "\tCPU%%c7");
+ 
  
  	if (do_dts)
 -		outp += sprintf(outp, "\tCoreTmp");
 -
 -	for (mp = sys.cp; mp; mp = mp->next) {
 -		if (mp->format == FORMAT_RAW) {
 -			if (mp->width == 64)
 -				outp += sprintf(outp, "\t%18.18s", mp->name);
 -			else
 -				outp += sprintf(outp, "\t%10.10s", mp->name);
 -		} else {
 -			outp += sprintf(outp, "\t%-7.7s", mp->name);
 -		}
 -	}
 -
 +		outp += sprintf(outp, " CoreTmp");
  	if (do_ptm)
 -		outp += sprintf(outp, "\tPkgTmp");
 -
 -	if (do_gfx_rc6_ms)
 -		outp += sprintf(outp, "\tGFX%%rc6");
 -
 -	if (do_gfx_mhz)
 -		outp += sprintf(outp, "\tGFXMHz");
 +		outp += sprintf(outp, "  PkgTmp");
  
  	if (do_skl_residency) {
 -		outp += sprintf(outp, "\tTotl%%C0");
 -		outp += sprintf(outp, "\tAny%%C0");
 -		outp += sprintf(outp, "\tGFX%%C0");
 -		outp += sprintf(outp, "\tCPUGFX%%");
 +		outp += sprintf(outp, " Totl%%C0");
 +		outp += sprintf(outp, "  Any%%C0");
 +		outp += sprintf(outp, "  GFX%%C0");
 +		outp += sprintf(outp, " CPUGFX%%");
  	}
  
  	if (do_pc2)
@@@ -539,28 -636,53 +600,69 @@@ int format_counters(struct thread_data 
  
  	/* SMI */
  	if (do_smi)
 -		outp += sprintf(outp, "\t%d", t->smi_count);
 +		outp += sprintf(outp, "%8d", t->smi_count);
  
++<<<<<<< HEAD
 +	if (do_nhm_cstates) {
 +		if (!skip_c1)
 +			outp += sprintf(outp, "%8.2f", 100.0 * t->c1/t->tsc);
 +		else
 +			outp += sprintf(outp, "********");
 +	}
++=======
+ 	/* C1 */
+ 	if (do_nhm_cstates)
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * t->c1/t->tsc);
++>>>>>>> 678a3bd1b3de (tools/power turbostat: fix bugs in --add option)
+ 
+ 	/* Added counters */
+ 	for (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 32)
+ 				outp += sprintf(outp, "\t0x%08lx", (unsigned long) t->counter[i]);
+ 			else
+ 				outp += sprintf(outp, "\t0x%016llx", t->counter[i]);
+ 		} else if (mp->format == FORMAT_DELTA) {
+ 			outp += sprintf(outp, "\t%lld", t->counter[i]);
+ 		} else if (mp->format == FORMAT_PERCENT) {
+ 			outp += sprintf(outp, "\t%.2f", 100.0 * t->counter[i]/t->tsc);
+ 		}
+ 	}
  
  	/* print per-core data only for 1st thread in core */
  	if (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))
  		goto done;
  
  	if (do_nhm_cstates && !do_slm_cstates && !do_knl_cstates)
 -		outp += sprintf(outp, "\t%.2f", 100.0 * c->c3/t->tsc);
 +		outp += sprintf(outp, "%8.2f", 100.0 * c->c3/t->tsc);
  	if (do_nhm_cstates)
 -		outp += sprintf(outp, "\t%.2f", 100.0 * c->c6/t->tsc);
 +		outp += sprintf(outp, "%8.2f", 100.0 * c->c6/t->tsc);
  	if (do_snb_cstates)
++<<<<<<< HEAD
 +		outp += sprintf(outp, "%8.2f", 100.0 * c->c7/t->tsc);
 +
 +	if (do_dts)
 +		outp += sprintf(outp, "%8d", c->core_temp_c);
++=======
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * c->c7/t->tsc);
+ 
+ 
+ 	if (do_dts)
+ 		outp += sprintf(outp, "\t%d", c->core_temp_c);
+ 
+ 	for (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 32)
+ 				outp += sprintf(outp, "\t0x%08lx", (unsigned long) c->counter[i]);
+ 			else
+ 				outp += sprintf(outp, "\t0x%016llx", c->counter[i]);
+ 		} else if (mp->format == FORMAT_DELTA) {
+ 			outp += sprintf(outp, "\t%lld", c->counter[i]);
+ 		} else if (mp->format == FORMAT_PERCENT) {
+ 			outp += sprintf(outp, "\t%.2f", 100.0 * c->counter[i]/t->tsc);
+ 		}
+ 	}
++>>>>>>> 678a3bd1b3de (tools/power turbostat: fix bugs in --add option)
  
  	/* print per-package data only for 1st core in package */
  	if (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))
@@@ -632,6 -768,19 +734,22 @@@
  		if (do_rapl & RAPL_DRAM_PERF_STATUS)
  			outp += sprintf(outp, fmt8, 100.0 * p->rapl_dram_perf_status * rapl_time_units / interval_float);
  	}
++<<<<<<< HEAD
++=======
+ 	for (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 32)
+ 				outp += sprintf(outp, "\t0x%08lx", (unsigned long) p->counter[i]);
+ 			else
+ 				outp += sprintf(outp, "\t0x%016llx", p->counter[i]);
+ 		} else if (mp->format == FORMAT_DELTA) {
+ 			outp += sprintf(outp, "\t%lld", p->counter[i]);
+ 		} else if (mp->format == FORMAT_PERCENT) {
+ 			outp += sprintf(outp, "\t%.2f", 100.0 * p->counter[i]/t->tsc);
+ 		}
+ 	}
+ 
++>>>>>>> 678a3bd1b3de (tools/power turbostat: fix bugs in --add option)
  done:
  	outp += sprintf(outp, "\n");
  
@@@ -854,6 -1038,17 +972,20 @@@ void clear_counters(struct thread_data 
  	p->rapl_pkg_perf_status = 0;
  	p->rapl_dram_perf_status = 0;
  	p->pkg_temp_c = 0;
++<<<<<<< HEAD
++=======
+ 
+ 	p->gfx_rc6_ms = 0;
+ 	p->gfx_mhz = 0;
+ 	for (i = 0, mp = sys.tp; mp; i++, mp = mp->next)
+ 		t->counter[i] = 0;
+ 
+ 	for (i = 0, mp = sys.cp; mp; i++, mp = mp->next)
+ 		c->counter[i] = 0;
+ 
+ 	for (i = 0, mp = sys.pp; mp; i++, mp = mp->next)
+ 		p->counter[i] = 0;
++>>>>>>> 678a3bd1b3de (tools/power turbostat: fix bugs in --add option)
  }
  int sum_counters(struct thread_data *t, struct core_data *c,
  	struct pkg_data *p)
@@@ -3184,6 -3884,167 +3316,170 @@@ void print_version() 
  		" - Len Brown <lenb@kernel.org>\n");
  }
  
++<<<<<<< HEAD
++=======
+ int add_counter(unsigned int msr_num, char *name, unsigned int width,
+ 	enum counter_scope scope, enum counter_type type,
+ 	enum counter_format format)
+ {
+ 	struct msr_counter *msrp;
+ 
+ 	msrp = calloc(1, sizeof(struct msr_counter));
+ 	if (msrp == NULL) {
+ 		perror("calloc");
+ 		exit(1);
+ 	}
+ 
+ 	msrp->msr_num = msr_num;
+ 	strncpy(msrp->name, name, NAME_BYTES);
+ 	msrp->width = width;
+ 	msrp->type = type;
+ 	msrp->format = format;
+ 
+ 	switch (scope) {
+ 
+ 	case SCOPE_CPU:
+ 		msrp->next = sys.tp;
+ 		sys.tp = msrp;
+ 		sys.added_thread_counters++;
+ 		if (sys.added_thread_counters > MAX_ADDED_COUNTERS) {
+ 			fprintf(stderr, "exceeded max %d added thread counters\n",
+ 				MAX_ADDED_COUNTERS);
+ 			exit(-1);
+ 		}
+ 		break;
+ 
+ 	case SCOPE_CORE:
+ 		msrp->next = sys.cp;
+ 		sys.cp = msrp;
+ 		sys.added_core_counters++;
+ 		if (sys.added_core_counters > MAX_ADDED_COUNTERS) {
+ 			fprintf(stderr, "exceeded max %d added core counters\n",
+ 				MAX_ADDED_COUNTERS);
+ 			exit(-1);
+ 		}
+ 		break;
+ 
+ 	case SCOPE_PACKAGE:
+ 		msrp->next = sys.pp;
+ 		sys.pp = msrp;
+ 		sys.added_package_counters++;
+ 		if (sys.added_package_counters > MAX_ADDED_COUNTERS) {
+ 			fprintf(stderr, "exceeded max %d added package counters\n",
+ 				MAX_ADDED_COUNTERS);
+ 			exit(-1);
+ 		}
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void parse_add_command(char *add_command)
+ {
+ 	int msr_num = 0;
+ 	char name_buffer[NAME_BYTES];
+ 	int width = 64;
+ 	int fail = 0;
+ 	enum counter_scope scope = SCOPE_CPU;
+ 	enum counter_type type = COUNTER_CYCLES;
+ 	enum counter_format format = FORMAT_DELTA;
+ 
+ 	while (add_command) {
+ 
+ 		if (sscanf(add_command, "msr0x%x", &msr_num) == 1)
+ 			goto next;
+ 
+ 		if (sscanf(add_command, "msr%d", &msr_num) == 1)
+ 			goto next;
+ 
+ 		if (sscanf(add_command, "u%d", &width) == 1) {
+ 			if ((width == 32) || (width == 64))
+ 				goto next;
+ 			width = 64;
+ 		}
+ 		if (!strncmp(add_command, "cpu", strlen("cpu"))) {
+ 			scope = SCOPE_CPU;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "core", strlen("core"))) {
+ 			scope = SCOPE_CORE;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "package", strlen("package"))) {
+ 			scope = SCOPE_PACKAGE;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "cycles", strlen("cycles"))) {
+ 			type = COUNTER_CYCLES;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "seconds", strlen("seconds"))) {
+ 			type = COUNTER_SECONDS;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "raw", strlen("raw"))) {
+ 			format = FORMAT_RAW;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "delta", strlen("delta"))) {
+ 			format = FORMAT_DELTA;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "percent", strlen("percent"))) {
+ 			format = FORMAT_PERCENT;
+ 			goto next;
+ 		}
+ 
+ 		if (sscanf(add_command, "%18s,%*s", name_buffer) == 1) {	/* 18 < NAME_BYTES */
+ 			char *eos;
+ 
+ 			eos = strchr(name_buffer, ',');
+ 			if (eos)
+ 				*eos = '\0';
+ 			goto next;
+ 		}
+ 
+ next:
+ 		add_command = strchr(add_command, ',');
+ 		if (add_command)
+ 			add_command++;
+ 
+ 	}
+ 	if (msr_num == 0) {
+ 		fprintf(stderr, "--add: (msrDDD | msr0xXXX) required\n");
+ 		fail++;
+ 	}
+ 
+ 	/* generate default column header */
+ 	if (*name_buffer == '\0') {
+ 		if (format == FORMAT_RAW) {
+ 			if (width == 32)
+ 				sprintf(name_buffer, "msr%d", msr_num);
+ 			else
+ 				sprintf(name_buffer, "MSR%d", msr_num);
+ 		} else if (format == FORMAT_DELTA) {
+ 			if (width == 32)
+ 				sprintf(name_buffer, "cnt%d", msr_num);
+ 			else
+ 				sprintf(name_buffer, "CNT%d", msr_num);
+ 		} else if (format == FORMAT_PERCENT) {
+ 			if (width == 32)
+ 				sprintf(name_buffer, "msr%d%%", msr_num);
+ 			else
+ 				sprintf(name_buffer, "MSR%d%%", msr_num);
+ 		}
+ 	}
+ 
+ 	if (add_counter(msr_num, name_buffer, width, scope, type, format))
+ 		fail++;
+ 
+ 	if (fail) {
+ 		help();
+ 		exit(1);
+ 	}
+ }
++>>>>>>> 678a3bd1b3de (tools/power turbostat: fix bugs in --add option)
  void cmdline(int argc, char **argv)
  {
  	int opt;
* Unmerged path tools/power/x86/turbostat/turbostat.c
