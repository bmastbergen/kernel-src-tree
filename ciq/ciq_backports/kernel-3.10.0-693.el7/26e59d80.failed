net/mlx5e: Implement mlx5e interface attach/detach callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Implement mlx5e interface attach/detach callbacks (Don Dutile) [1385214 1385330 1417285]
Rebuild_FUZZ: 96.55%
commit-author Mohamad Haj Yahia <mohamad@mellanox.com>
commit 26e59d8077a31972dc81fe5ff75aa4fd5b260b71
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/26e59d80.failed

Needed to support seamless and lightweight PCI/Internal error recovery.
Implement the attach/detach interface callbacks.
In attach callback we only allocate HW resources.
In detach callback we only deallocate HW resources.
All SW/kernel objects initialzing/destroying is kept in add/remove
callbacks.

	Signed-off-by: Mohamad Haj Yahia <mohamad@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 26e59d8077a31972dc81fe5ff75aa4fd5b260b71)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index b01f5bb32ed7,a9358cf7386a..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -645,6 -788,69 +645,46 @@@ extern const struct dcbnl_rtnl_ops mlx5
  int mlx5e_dcbnl_ieee_setets_core(struct mlx5e_priv *priv, struct ieee_ets *ets);
  #endif
  
 -#ifndef CONFIG_RFS_ACCEL
 -static inline int mlx5e_arfs_create_tables(struct mlx5e_priv *priv)
 -{
 -	return 0;
 -}
 -
 -static inline void mlx5e_arfs_destroy_tables(struct mlx5e_priv *priv) {}
 -
 -static inline int mlx5e_arfs_enable(struct mlx5e_priv *priv)
 -{
 -	return -ENOTSUPP;
 -}
 -
 -static inline int mlx5e_arfs_disable(struct mlx5e_priv *priv)
 -{
 -	return -ENOTSUPP;
 -}
 -#else
 -int mlx5e_arfs_create_tables(struct mlx5e_priv *priv);
 -void mlx5e_arfs_destroy_tables(struct mlx5e_priv *priv);
 -int mlx5e_arfs_enable(struct mlx5e_priv *priv);
 -int mlx5e_arfs_disable(struct mlx5e_priv *priv);
 -int mlx5e_rx_flow_steer(struct net_device *dev, const struct sk_buff *skb,
 -			u16 rxq_index, u32 flow_id);
 -#endif
 -
  u16 mlx5e_get_max_inline_cap(struct mlx5_core_dev *mdev);
++<<<<<<< HEAD
++=======
+ int mlx5e_create_tir(struct mlx5_core_dev *mdev,
+ 		     struct mlx5e_tir *tir, u32 *in, int inlen);
+ void mlx5e_destroy_tir(struct mlx5_core_dev *mdev,
+ 		       struct mlx5e_tir *tir);
+ int mlx5e_create_mdev_resources(struct mlx5_core_dev *mdev);
+ void mlx5e_destroy_mdev_resources(struct mlx5_core_dev *mdev);
+ int mlx5e_refresh_tirs_self_loopback_enable(struct mlx5_core_dev *mdev);
+ 
+ struct mlx5_eswitch_rep;
+ int mlx5e_vport_rep_load(struct mlx5_eswitch *esw,
+ 			 struct mlx5_eswitch_rep *rep);
+ void mlx5e_vport_rep_unload(struct mlx5_eswitch *esw,
+ 			    struct mlx5_eswitch_rep *rep);
+ int mlx5e_nic_rep_load(struct mlx5_eswitch *esw, struct mlx5_eswitch_rep *rep);
+ void mlx5e_nic_rep_unload(struct mlx5_eswitch *esw,
+ 			  struct mlx5_eswitch_rep *rep);
+ int mlx5e_add_sqs_fwd_rules(struct mlx5e_priv *priv);
+ void mlx5e_remove_sqs_fwd_rules(struct mlx5e_priv *priv);
+ int mlx5e_attr_get(struct net_device *dev, struct switchdev_attr *attr);
+ 
+ int mlx5e_create_direct_rqts(struct mlx5e_priv *priv);
+ void mlx5e_destroy_rqt(struct mlx5e_priv *priv, struct mlx5e_rqt *rqt);
+ int mlx5e_create_direct_tirs(struct mlx5e_priv *priv);
+ void mlx5e_destroy_direct_tirs(struct mlx5e_priv *priv);
+ int mlx5e_create_tises(struct mlx5e_priv *priv);
+ void mlx5e_cleanup_nic_tx(struct mlx5e_priv *priv);
+ int mlx5e_close(struct net_device *netdev);
+ int mlx5e_open(struct net_device *netdev);
+ void mlx5e_update_stats_work(struct work_struct *work);
+ struct net_device *mlx5e_create_netdev(struct mlx5_core_dev *mdev,
+ 				       const struct mlx5e_profile *profile,
+ 				       void *ppriv);
+ void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, struct mlx5e_priv *priv);
+ int mlx5e_attach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev);
+ void mlx5e_detach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev);
+ struct rtnl_link_stats64 *
+ mlx5e_get_stats(struct net_device *dev, struct rtnl_link_stats64 *stats);
++>>>>>>> 26e59d8077a3 (net/mlx5e: Implement mlx5e interface attach/detach callbacks)
  
  #endif /* __MLX5_EN_H__ */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 8d737e76ff7e,af4c61e6d589..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -3003,18 -3247,173 +3006,185 @@@ static int mlx5e_create_umr_mkey(struc
  	return err;
  }
  
++<<<<<<< HEAD
 +static void *mlx5e_create_netdev(struct mlx5_core_dev *mdev)
++=======
+ static void mlx5e_nic_init(struct mlx5_core_dev *mdev,
+ 			   struct net_device *netdev,
+ 			   const struct mlx5e_profile *profile,
+ 			   void *ppriv)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	mlx5e_build_nic_netdev_priv(mdev, netdev, profile, ppriv);
+ 	mlx5e_build_nic_netdev(netdev);
+ 	mlx5e_vxlan_init(priv);
+ }
+ 
+ static void mlx5e_nic_cleanup(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 
+ 	mlx5e_vxlan_cleanup(priv);
+ 
+ 	if (MLX5_CAP_GEN(mdev, vport_group_manager))
+ 		mlx5_eswitch_unregister_vport_rep(esw, 0);
+ }
+ 
+ static int mlx5e_init_nic_rx(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	int err;
+ 	int i;
+ 
+ 	err = mlx5e_create_indirect_rqts(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create indirect rqts failed, %d\n", err);
+ 		return err;
+ 	}
+ 
+ 	err = mlx5e_create_direct_rqts(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create direct rqts failed, %d\n", err);
+ 		goto err_destroy_indirect_rqts;
+ 	}
+ 
+ 	err = mlx5e_create_indirect_tirs(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create indirect tirs failed, %d\n", err);
+ 		goto err_destroy_direct_rqts;
+ 	}
+ 
+ 	err = mlx5e_create_direct_tirs(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create direct tirs failed, %d\n", err);
+ 		goto err_destroy_indirect_tirs;
+ 	}
+ 
+ 	err = mlx5e_create_flow_steering(priv);
+ 	if (err) {
+ 		mlx5_core_warn(mdev, "create flow steering failed, %d\n", err);
+ 		goto err_destroy_direct_tirs;
+ 	}
+ 
+ 	err = mlx5e_tc_init(priv);
+ 	if (err)
+ 		goto err_destroy_flow_steering;
+ 
+ 	return 0;
+ 
+ err_destroy_flow_steering:
+ 	mlx5e_destroy_flow_steering(priv);
+ err_destroy_direct_tirs:
+ 	mlx5e_destroy_direct_tirs(priv);
+ err_destroy_indirect_tirs:
+ 	mlx5e_destroy_indirect_tirs(priv);
+ err_destroy_direct_rqts:
+ 	for (i = 0; i < priv->profile->max_nch(mdev); i++)
+ 		mlx5e_destroy_rqt(priv, &priv->direct_tir[i].rqt);
+ err_destroy_indirect_rqts:
+ 	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
+ 	return err;
+ }
+ 
+ static void mlx5e_cleanup_nic_rx(struct mlx5e_priv *priv)
+ {
+ 	int i;
+ 
+ 	mlx5e_tc_cleanup(priv);
+ 	mlx5e_destroy_flow_steering(priv);
+ 	mlx5e_destroy_direct_tirs(priv);
+ 	mlx5e_destroy_indirect_tirs(priv);
+ 	for (i = 0; i < priv->profile->max_nch(priv->mdev); i++)
+ 		mlx5e_destroy_rqt(priv, &priv->direct_tir[i].rqt);
+ 	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
+ }
+ 
+ static int mlx5e_init_nic_tx(struct mlx5e_priv *priv)
+ {
+ 	int err;
+ 
+ 	err = mlx5e_create_tises(priv);
+ 	if (err) {
+ 		mlx5_core_warn(priv->mdev, "create tises failed, %d\n", err);
+ 		return err;
+ 	}
+ 
+ #ifdef CONFIG_MLX5_CORE_EN_DCB
+ 	mlx5e_dcbnl_ieee_setets_core(priv, &priv->params.ets);
+ #endif
+ 	return 0;
+ }
+ 
+ static void mlx5e_nic_enable(struct mlx5e_priv *priv)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	struct mlx5_eswitch_rep rep;
+ 
+ 	mlx5_lag_add(mdev, netdev);
+ 
+ 	if (mlx5e_vxlan_allowed(mdev)) {
+ 		rtnl_lock();
+ 		udp_tunnel_get_rx_info(netdev);
+ 		rtnl_unlock();
+ 	}
+ 
+ 	mlx5e_enable_async_events(priv);
+ 	queue_work(priv->wq, &priv->set_rx_mode_work);
+ 
+ 	if (MLX5_CAP_GEN(mdev, vport_group_manager)) {
+ 		mlx5_query_nic_vport_mac_address(mdev, 0, rep.hw_id);
+ 		rep.load = mlx5e_nic_rep_load;
+ 		rep.unload = mlx5e_nic_rep_unload;
+ 		rep.vport = 0;
+ 		rep.priv_data = priv;
+ 		mlx5_eswitch_register_vport_rep(esw, &rep);
+ 	}
+ }
+ 
+ static void mlx5e_nic_disable(struct mlx5e_priv *priv)
  {
+ 	queue_work(priv->wq, &priv->set_rx_mode_work);
+ 	mlx5e_disable_async_events(priv);
+ 	mlx5_lag_remove(priv->mdev);
+ }
+ 
+ static const struct mlx5e_profile mlx5e_nic_profile = {
+ 	.init		   = mlx5e_nic_init,
+ 	.cleanup	   = mlx5e_nic_cleanup,
+ 	.init_rx	   = mlx5e_init_nic_rx,
+ 	.cleanup_rx	   = mlx5e_cleanup_nic_rx,
+ 	.init_tx	   = mlx5e_init_nic_tx,
+ 	.cleanup_tx	   = mlx5e_cleanup_nic_tx,
+ 	.enable		   = mlx5e_nic_enable,
+ 	.disable	   = mlx5e_nic_disable,
+ 	.update_stats	   = mlx5e_update_stats,
+ 	.max_nch	   = mlx5e_get_max_num_channels,
+ 	.max_tc		   = MLX5E_MAX_NUM_TC,
+ };
+ 
+ struct net_device *mlx5e_create_netdev(struct mlx5_core_dev *mdev,
+ 				       const struct mlx5e_profile *profile,
+ 				       void *ppriv)
++>>>>>>> 26e59d8077a3 (net/mlx5e: Implement mlx5e interface attach/detach callbacks)
+ {
+ 	int nch = profile->max_nch(mdev);
  	struct net_device *netdev;
  	struct mlx5e_priv *priv;
++<<<<<<< HEAD
 +	int nch = mlx5e_get_max_num_channels(mdev);
 +	int err;
++=======
++>>>>>>> 26e59d8077a3 (net/mlx5e: Implement mlx5e interface attach/detach callbacks)
 +
 +	if (mlx5e_check_required_hca_cap(mdev))
 +		return NULL;
  
  	netdev = alloc_etherdev_mqs(sizeof(struct mlx5e_priv),
 -				    nch * profile->max_tc,
 +				    nch * MLX5E_MAX_NUM_TC,
  				    nch);
  	if (!netdev) {
  		mlx5_core_err(mdev, "alloc_etherdev_mqs() failed\n");
@@@ -3030,43 -3428,36 +3200,67 @@@
  
  	priv->wq = create_singlethread_workqueue("mlx5e");
  	if (!priv->wq)
- 		goto err_free_netdev;
+ 		goto err_cleanup_nic;
+ 
+ 	return netdev;
+ 
+ err_cleanup_nic:
+ 	profile->cleanup(priv);
+ 	free_netdev(netdev);
+ 
+ 	return NULL;
+ }
+ 
+ int mlx5e_attach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev)
+ {
+ 	const struct mlx5e_profile *profile;
+ 	struct mlx5e_priv *priv;
+ 	int err;
+ 
+ 	priv = netdev_priv(netdev);
+ 	profile = priv->profile;
+ 	clear_bit(MLX5E_STATE_DESTROYING, &priv->state);
  
 -	err = mlx5e_create_umr_mkey(priv);
 +	err = mlx5_alloc_map_uar(mdev, &priv->cq_uar, false);
  	if (err) {
++<<<<<<< HEAD
 +		mlx5_core_err(mdev, "alloc_map uar failed, %d\n", err);
 +		goto err_destroy_wq;
++=======
+ 		mlx5_core_err(mdev, "create umr mkey failed, %d\n", err);
+ 		goto out;
++>>>>>>> 26e59d8077a3 (net/mlx5e: Implement mlx5e interface attach/detach callbacks)
  	}
  
 -	err = profile->init_tx(priv);
 -	if (err)
 +	err = mlx5_core_alloc_pd(mdev, &priv->pdn);
 +	if (err) {
 +		mlx5_core_err(mdev, "alloc pd failed, %d\n", err);
 +		goto err_unmap_free_uar;
 +	}
 +
 +	err = mlx5_core_alloc_transport_domain(mdev, &priv->tdn);
 +	if (err) {
 +		mlx5_core_err(mdev, "alloc td failed, %d\n", err);
 +		goto err_dealloc_pd;
 +	}
 +
 +	err = mlx5e_create_mkey(priv, priv->pdn, &priv->mkey);
 +	if (err) {
 +		mlx5_core_err(mdev, "create mkey failed, %d\n", err);
 +		goto err_dealloc_transport_domain;
 +	}
 +
 +	err = mlx5e_create_umr_mkey(priv);
 +	if (err) {
 +		mlx5_core_err(mdev, "create umr mkey failed, %d\n", err);
 +		goto err_destroy_mkey;
 +	}
 +
 +	err = mlx5e_create_tises(priv);
 +	if (err) {
 +		mlx5_core_warn(mdev, "create tises failed, %d\n", err);
  		goto err_destroy_umr_mkey;
 +	}
  
  	err = mlx5e_open_drop_rq(priv);
  	if (err) {
@@@ -3104,33 -3475,16 +3298,46 @@@
  
  	mlx5e_set_dev_port_mtu(netdev);
  
++<<<<<<< HEAD
 +	err = register_netdev(netdev);
 +	if (err) {
 +		mlx5_core_err(mdev, "register_netdev failed, %d\n", err);
 +		goto err_dealloc_q_counters;
 +	}
 +
 +	if (mlx5e_vxlan_allowed(mdev)) {
 +		rtnl_lock();
 +		vxlan_get_rx_port(netdev);
 +		rtnl_unlock();
 +	}
 +
 +	mlx5e_enable_async_events(priv);
 +	queue_work(priv->wq, &priv->set_rx_mode_work);
++=======
+ 	if (profile->enable)
+ 		profile->enable(priv);
++>>>>>>> 26e59d8077a3 (net/mlx5e: Implement mlx5e interface attach/detach callbacks)
  
- 	return priv;
+ 	rtnl_lock();
+ 	if (netif_running(netdev))
+ 		mlx5e_open(netdev);
+ 	netif_device_attach(netdev);
+ 	rtnl_unlock();
  
++<<<<<<< HEAD
 +
 +err_dealloc_q_counters:
 +	mlx5e_destroy_q_counter(priv);
 +	mlx5e_destroy_flow_tables(priv);
 +
 +err_destroy_tirs:
 +	mlx5e_destroy_tirs(priv);
 +
 +err_destroy_rqts:
 +	mlx5e_destroy_rqts(priv);
++=======
+ 	return 0;
++>>>>>>> 26e59d8077a3 (net/mlx5e: Implement mlx5e interface attach/detach callbacks)
  
  err_close_drop_rq:
  	mlx5e_close_drop_rq(priv);
@@@ -3141,63 -3495,175 +3348,217 @@@ err_destroy_tises
  err_destroy_umr_mkey:
  	mlx5_core_destroy_mkey(mdev, &priv->umr_mkey);
  
++<<<<<<< HEAD
 +err_destroy_mkey:
 +	mlx5_core_destroy_mkey(mdev, &priv->mkey);
 +
 +err_dealloc_transport_domain:
 +	mlx5_core_dealloc_transport_domain(mdev, priv->tdn);
 +
 +err_dealloc_pd:
 +	mlx5_core_dealloc_pd(mdev, priv->pdn);
 +
 +err_unmap_free_uar:
 +	mlx5_unmap_free_uar(mdev, &priv->cq_uar);
 +
 +err_destroy_wq:
 +	destroy_workqueue(priv->wq);
 +
 +err_free_netdev:
 +	free_netdev(netdev);
 +
 +	return NULL;
++=======
+ out:
+ 	return err;
++>>>>>>> 26e59d8077a3 (net/mlx5e: Implement mlx5e interface attach/detach callbacks)
  }
  
 -static void mlx5e_register_vport_rep(struct mlx5_core_dev *mdev)
 +static void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, void *vpriv)
  {
++<<<<<<< HEAD
 +	struct mlx5e_priv *priv = vpriv;
 +	struct net_device *netdev = priv->netdev;
++=======
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	int vport;
+ 	u8 mac[ETH_ALEN];
+ 
+ 	if (!MLX5_CAP_GEN(mdev, vport_group_manager))
+ 		return;
+ 
+ 	mlx5_query_nic_vport_mac_address(mdev, 0, mac);
+ 
+ 	for (vport = 1; vport < total_vfs; vport++) {
+ 		struct mlx5_eswitch_rep rep;
+ 
+ 		rep.load = mlx5e_vport_rep_load;
+ 		rep.unload = mlx5e_vport_rep_unload;
+ 		rep.vport = vport;
+ 		ether_addr_copy(rep.hw_id, mac);
+ 		mlx5_eswitch_register_vport_rep(esw, &rep);
+ 	}
+ }
+ 
+ void mlx5e_detach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	const struct mlx5e_profile *profile = priv->profile;
++>>>>>>> 26e59d8077a3 (net/mlx5e: Implement mlx5e interface attach/detach callbacks)
  
  	set_bit(MLX5E_STATE_DESTROYING, &priv->state);
 -	if (profile->disable)
 -		profile->disable(priv);
  
 +	queue_work(priv->wq, &priv->set_rx_mode_work);
 +	mlx5e_disable_async_events(priv);
  	flush_workqueue(priv->wq);
- 	if (test_bit(MLX5_INTERFACE_STATE_SHUTDOWN, &mdev->intf_state)) {
- 		netif_device_detach(netdev);
+ 
+ 	rtnl_lock();
+ 	if (netif_running(netdev))
  		mlx5e_close(netdev);
- 	} else {
- 		unregister_netdev(netdev);
- 	}
+ 	netif_device_detach(netdev);
+ 	rtnl_unlock();
  
 +	mlx5e_vxlan_cleanup(priv);
  	mlx5e_destroy_q_counter(priv);
 -	profile->cleanup_rx(priv);
 +	mlx5e_destroy_flow_tables(priv);
 +	mlx5e_destroy_tirs(priv);
 +	mlx5e_destroy_rqts(priv);
  	mlx5e_close_drop_rq(priv);
 -	profile->cleanup_tx(priv);
 +	mlx5e_destroy_tises(priv);
  	mlx5_core_destroy_mkey(priv->mdev, &priv->umr_mkey);
 +	mlx5_core_destroy_mkey(priv->mdev, &priv->mkey);
 +	mlx5_core_dealloc_transport_domain(priv->mdev, priv->tdn);
 +	mlx5_core_dealloc_pd(priv->mdev, priv->pdn);
 +	mlx5_unmap_free_uar(priv->mdev, &priv->cq_uar);
  	cancel_delayed_work_sync(&priv->update_stats_work);
+ }
+ 
+ /* mlx5e_attach and mlx5e_detach scope should be only creating/destroying
+  * hardware contexts and to connect it to the current netdev.
+  */
+ static int mlx5e_attach(struct mlx5_core_dev *mdev, void *vpriv)
+ {
+ 	struct mlx5e_priv *priv = vpriv;
+ 	struct net_device *netdev = priv->netdev;
+ 	int err;
+ 
+ 	if (netif_device_present(netdev))
+ 		return 0;
+ 
+ 	err = mlx5e_create_mdev_resources(mdev);
+ 	if (err)
+ 		return err;
+ 
+ 	err = mlx5e_attach_netdev(mdev, netdev);
+ 	if (err) {
+ 		mlx5e_destroy_mdev_resources(mdev);
+ 		return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void mlx5e_detach(struct mlx5_core_dev *mdev, void *vpriv)
+ {
+ 	struct mlx5e_priv *priv = vpriv;
+ 	struct net_device *netdev = priv->netdev;
+ 
+ 	if (!netif_device_present(netdev))
+ 		return;
+ 
+ 	mlx5e_detach_netdev(mdev, netdev);
+ 	mlx5e_destroy_mdev_resources(mdev);
+ }
+ 
+ static void *mlx5e_add(struct mlx5_core_dev *mdev)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	void *ppriv = NULL;
+ 	void *priv;
+ 	int vport;
+ 	int err;
+ 	struct net_device *netdev;
+ 
+ 	err = mlx5e_check_required_hca_cap(mdev);
+ 	if (err)
+ 		return NULL;
+ 
+ 	mlx5e_register_vport_rep(mdev);
+ 
+ 	if (MLX5_CAP_GEN(mdev, vport_group_manager))
+ 		ppriv = &esw->offloads.vport_reps[0];
+ 
+ 	netdev = mlx5e_create_netdev(mdev, &mlx5e_nic_profile, ppriv);
+ 	if (!netdev) {
+ 		mlx5_core_err(mdev, "mlx5e_create_netdev failed\n");
+ 		goto err_unregister_reps;
+ 	}
+ 
+ 	priv = netdev_priv(netdev);
+ 
+ 	err = mlx5e_attach(mdev, priv);
+ 	if (err) {
+ 		mlx5_core_err(mdev, "mlx5e_attach failed, %d\n", err);
+ 		goto err_destroy_netdev;
+ 	}
+ 
+ 	err = register_netdev(netdev);
+ 	if (err) {
+ 		mlx5_core_err(mdev, "register_netdev failed, %d\n", err);
+ 		goto err_detach;
+ 	}
+ 
+ 	return priv;
+ 
+ err_detach:
+ 	mlx5e_detach(mdev, priv);
+ 
+ err_destroy_netdev:
+ 	mlx5e_destroy_netdev(mdev, priv);
+ 
+ err_unregister_reps:
+ 	for (vport = 1; vport < total_vfs; vport++)
+ 		mlx5_eswitch_unregister_vport_rep(esw, vport);
+ 
+ 	return NULL;
+ }
+ 
+ void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, struct mlx5e_priv *priv)
+ {
+ 	const struct mlx5e_profile *profile = priv->profile;
+ 	struct net_device *netdev = priv->netdev;
+ 
+ 	unregister_netdev(netdev);
  	destroy_workqueue(priv->wq);
++<<<<<<< HEAD
 +
 +	if (!test_bit(MLX5_INTERFACE_STATE_SHUTDOWN, &mdev->intf_state))
 +		free_netdev(netdev);
 +}
 +
++=======
+ 	if (profile->cleanup)
+ 		profile->cleanup(priv);
+ 	free_netdev(netdev);
+ }
+ 
+ static void mlx5e_remove(struct mlx5_core_dev *mdev, void *vpriv)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	struct mlx5e_priv *priv = vpriv;
+ 	int vport;
+ 
+ 	for (vport = 1; vport < total_vfs; vport++)
+ 		mlx5_eswitch_unregister_vport_rep(esw, vport);
+ 
+ 	mlx5e_detach(mdev, vpriv);
+ 	mlx5e_destroy_netdev(mdev, priv);
+ }
+ 
++>>>>>>> 26e59d8077a3 (net/mlx5e: Implement mlx5e interface attach/detach callbacks)
  static void *mlx5e_get_netdev(void *vpriv)
  {
  	struct mlx5e_priv *priv = vpriv;
@@@ -3206,8 -3672,10 +3567,15 @@@
  }
  
  static struct mlx5_interface mlx5e_interface = {
++<<<<<<< HEAD
 +	.add       = mlx5e_create_netdev,
 +	.remove    = mlx5e_destroy_netdev,
++=======
+ 	.add       = mlx5e_add,
+ 	.remove    = mlx5e_remove,
+ 	.attach    = mlx5e_attach,
+ 	.detach    = mlx5e_detach,
++>>>>>>> 26e59d8077a3 (net/mlx5e: Implement mlx5e interface attach/detach callbacks)
  	.event     = mlx5e_async_event,
  	.protocol  = MLX5_INTERFACE_PROTOCOL_ETH,
  	.get_dev   = mlx5e_get_netdev,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
