fix copy_tree() regression

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 12a5b5294cb1896e9a3c9fca8ff5a7e3def4e8c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/12a5b529.failed

Since 3.14 we had copy_tree() get the shadowing wrong - if we had one
vfsmount shadowing another (i.e. if A is a slave of B, C is mounted
on A/foo, then D got mounted on B/foo creating D' on A/foo shadowed
by C), copy_tree() of A would make a copy of D' shadow the the copy of
C, not the other way around.

It's easy to fix, fortunately - just make sure that mount follows
the one that shadows it in mnt_child as well as in mnt_hash, and when
copy_tree() decides to attach a new mount, check if the last child
it has added to the same parent should be shadowing the new one.
And if it should, just use the same logics commit_tree() has - put the
new mount into the hash and children lists right after the one that
should shadow it.

	Cc: stable@vger.kernel.org [3.14 and later]
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 12a5b5294cb1896e9a3c9fca8ff5a7e3def4e8c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index a82db7875df0,be3f6f23a47d..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -740,9 -810,7 +754,13 @@@ static void commit_tree(struct mount *m
  
  	list_splice(&head, n->list.prev);
  
++<<<<<<< HEAD
 +	list_add_tail(&mnt->mnt_hash, mount_hashtable +
 +				hash(&parent->mnt, mnt->mnt_mountpoint));
 +	list_add_tail(&mnt->mnt_child, &parent->mnt_mounts);
++=======
+ 	attach_shadowed(mnt, parent, shadows);
++>>>>>>> 12a5b5294cb1 (fix copy_tree() regression)
  	touch_mnt_namespace(n);
  }
  
@@@ -1428,10 -1503,17 +1447,22 @@@ struct mount *copy_tree(struct mount *m
  			q = clone_mnt(p, p->mnt.mnt_root, flag);
  			if (IS_ERR(q))
  				goto out;
 -			lock_mount_hash();
 +			br_write_lock(&vfsmount_lock);
  			list_add_tail(&q->mnt_list, &res->mnt_list);
++<<<<<<< HEAD
 +			attach_mnt(q, parent, p->mnt_mp);
 +			br_write_unlock(&vfsmount_lock);
++=======
+ 			mnt_set_mountpoint(parent, p->mnt_mp, q);
+ 			if (!list_empty(&parent->mnt_mounts)) {
+ 				t = list_last_entry(&parent->mnt_mounts,
+ 					struct mount, mnt_child);
+ 				if (t->mnt_mp != p->mnt_mp)
+ 					t = NULL;
+ 			}
+ 			attach_shadowed(q, parent, t);
+ 			unlock_mount_hash();
++>>>>>>> 12a5b5294cb1 (fix copy_tree() regression)
  		}
  	}
  	return res;
* Unmerged path fs/namespace.c
