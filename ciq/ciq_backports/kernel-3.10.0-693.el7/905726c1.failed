xen-netfront: Remove the meaningless code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Li, Liang Z <liang.z.li@intel.com>
commit 905726c1c5a3ca620ba7d73c78eddfb91de5ce28
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/905726c1.failed

The function netif_set_real_num_tx_queues() will return -EINVAL if
the second parameter < 1, so call this function with the second
parameter set to 0 is meaningless.

	Signed-off-by: Liang Li <liang.z.li@intel.com>
	Reviewed-by: David Vrabel <david.vrabel@citrix.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 905726c1c5a3ca620ba7d73c78eddfb91de5ce28)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/xen-netfront.c
diff --cc drivers/net/xen-netfront.c
index 8896052a2ee0,1807cd175a96..000000000000
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@@ -1282,58 -1245,23 +1282,62 @@@ static struct net_device *xennet_create
  	np                   = netdev_priv(netdev);
  	np->xbdev            = dev;
  
++<<<<<<< HEAD
 +	spin_lock_init(&np->tx_lock);
 +	spin_lock_init(&np->rx_lock);
 +
 +	skb_queue_head_init(&np->rx_batch);
 +	np->rx_target     = RX_DFL_MIN_TARGET;
 +	np->rx_min_target = RX_DFL_MIN_TARGET;
 +	np->rx_max_target = RX_MAX_TARGET;
 +
 +	init_timer(&np->rx_refill_timer);
 +	np->rx_refill_timer.data = (unsigned long)netdev;
 +	np->rx_refill_timer.function = rx_refill_timeout;
++=======
+ 	np->queues = NULL;
++>>>>>>> 905726c1c5a3 (xen-netfront: Remove the meaningless code)
  
  	err = -ENOMEM;
 -	np->rx_stats = netdev_alloc_pcpu_stats(struct netfront_stats);
 -	if (np->rx_stats == NULL)
 -		goto exit;
 -	np->tx_stats = netdev_alloc_pcpu_stats(struct netfront_stats);
 -	if (np->tx_stats == NULL)
 +	np->stats = alloc_percpu(struct netfront_stats);
 +	if (np->stats == NULL)
  		goto exit;
  
 +	/* Initialise tx_skbs as a free chain containing every entry. */
 +	np->tx_skb_freelist = 0;
 +	for (i = 0; i < NET_TX_RING_SIZE; i++) {
 +		skb_entry_set_link(&np->tx_skbs[i], i+1);
 +		np->grant_tx_ref[i] = GRANT_INVALID_REF;
 +	}
 +
 +	/* Clear out rx_skbs */
 +	for (i = 0; i < NET_RX_RING_SIZE; i++) {
 +		np->rx_skbs[i] = NULL;
 +		np->grant_rx_ref[i] = GRANT_INVALID_REF;
 +		np->grant_tx_page[i] = NULL;
 +	}
 +
 +	/* A grant for every tx ring slot */
 +	if (gnttab_alloc_grant_references(TX_MAX_TARGET,
 +					  &np->gref_tx_head) < 0) {
 +		pr_alert("can't alloc tx grant refs\n");
 +		err = -ENOMEM;
 +		goto exit_free_stats;
 +	}
 +	/* A grant for every rx ring slot */
 +	if (gnttab_alloc_grant_references(RX_MAX_TARGET,
 +					  &np->gref_rx_head) < 0) {
 +		pr_alert("can't alloc rx grant refs\n");
 +		err = -ENOMEM;
 +		goto exit_free_tx;
 +	}
 +
  	netdev->netdev_ops	= &xennet_netdev_ops;
  
 +	netif_napi_add(netdev, &np->napi, xennet_poll, 64);
  	netdev->features        = NETIF_F_IP_CSUM | NETIF_F_RXCSUM |
  				  NETIF_F_GSO_ROBUST;
 -	netdev->hw_features	= NETIF_F_SG |
 -				  NETIF_F_IPV6_CSUM |
 -				  NETIF_F_TSO | NETIF_F_TSO6;
 +	netdev->hw_features	= NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_TSO;
  
  	/*
           * Assume that all hw features are available for now. This set
@@@ -1722,10 -1889,13 +1726,15 @@@ again
  	return 0;
  
   abort_transaction:
 -	xenbus_dev_fatal(dev, err, "%s", message);
 -abort_transaction_no_dev_fatal:
  	xenbus_transaction_end(xbt, 1);
 +	xenbus_dev_fatal(dev, err, "%s", message);
   destroy_ring:
  	xennet_disconnect_backend(info);
++<<<<<<< HEAD
++=======
+ 	kfree(info->queues);
+ 	info->queues = NULL;
++>>>>>>> 905726c1c5a3 (xen-netfront: Remove the meaningless code)
   out:
  	return err;
  }
* Unmerged path drivers/net/xen-netfront.c
