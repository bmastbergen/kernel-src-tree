sysfs, kernfs: introduce kernfs_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tejun Heo <tj@kernel.org>
commit f6acf8bb6a40ba3bfcf542e4c4c9e8968c8cb57a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f6acf8bb.failed

We're in the process of separating out core sysfs functionality into
kernfs which will deal with sysfs_dirents directly.  This patch
introduces kernfs_ops which hosts methods kernfs users implement and
updates fs/sysfs/file.c such that sysfs_kf_*() functions populate
kernfs_ops and kernfs_file_*() functions call the matching entries
from kernfs_ops.

kernfs_ops contains the following groups of methods.

* seq_show() - for kernfs files which use seq_file for reads.

* read() - for direct read implementations.  Used iff seq_show() is
  not implemented.

* write() - for writes.

* mmap() - for mmaps.

Notes:

* sysfs_elem_attr->ops is added so that kernfs_ops can be accessed
  from sysfs_dirent.  kernfs_ops() helper is added to verify locking
  and access the field.

* SYSFS_FLAG_HAS_(SEQ_SHOW|MMAP) added.  sd->s_attr->ops is accessible
  only while holding active_ref and there are cases where we want to
  take different actions depending on which ops are implemented.
  These two flags cache whether the two ops are implemented for those.

* kernfs_file_*() no longer test sysfs type but chooses different
  behaviors depending on which methods in kernfs_ops are implemented.
  The conversions are trivial except for the open path.  As
  kernfs_file_open() now decides whether to allow read/write accesses
  depending on the kernfs_ops implemented, the presence of methods in
  kobjs and attribute_bin should be propagated to kernfs_ops.
  sysfs_add_file_mode_ns() is updated so that it propagates presence /
  absence of the callbacks through _empty, _ro, _wo, _rw kernfs_ops.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit f6acf8bb6a40ba3bfcf542e4c4c9e8968c8cb57a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/file.c
#	fs/sysfs/sysfs.h
#	include/linux/kernfs.h
diff --cc fs/sysfs/file.c
index 602f56db0442,cbebc335af8c..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -39,52 -44,72 +39,74 @@@ struct sysfs_open_dirent 
  	atomic_t		refcnt;
  	atomic_t		event;
  	wait_queue_head_t	poll;
 -	struct list_head	files; /* goes through sysfs_open_file.list */
 +	struct list_head	buffers; /* goes through sysfs_buffer.list */
  };
  
 -static bool sysfs_is_bin(struct sysfs_dirent *sd)
 -{
 -	return sysfs_type(sd) == SYSFS_KOBJ_BIN_ATTR;
 -}
 +struct sysfs_buffer {
 +	size_t			count;
 +	loff_t			pos;
 +	char			* page;
 +	const struct sysfs_ops	* ops;
 +	struct mutex		mutex;
 +	int			needs_read_fill;
 +	int			event;
 +	struct list_head	list;
 +};
  
++<<<<<<< HEAD
 +/**
 + *	fill_read_buffer - allocate and fill buffer from object.
 + *	@dentry:	dentry pointer.
 + *	@buffer:	data buffer for file.
 + *
 + *	Allocate @buffer->page, if it hasn't been already, then call the
 + *	kobject's show() method to fill the buffer with this attribute's 
 + *	data. 
 + *	This is called only once, on the file's first read unless an error
 + *	is returned.
++=======
+ static struct sysfs_open_file *sysfs_of(struct file *file)
+ {
+ 	return ((struct seq_file *)file->private_data)->private;
+ }
+ 
+ /*
+  * Determine the kernfs_ops for the given sysfs_dirent.  This function must
+  * be called while holding an active reference.
+  */
+ static const struct kernfs_ops *kernfs_ops(struct sysfs_dirent *sd)
+ {
+ 	if (!sysfs_ignore_lockdep(sd))
+ 		lockdep_assert_held(sd);
+ 	return sd->s_attr.ops;
+ }
+ 
+ /*
+  * Determine ktype->sysfs_ops for the given sysfs_dirent.  This function
+  * must be called while holding an active reference.
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
   */
 -static const struct sysfs_ops *sysfs_file_ops(struct sysfs_dirent *sd)
 +static int fill_read_buffer(struct dentry * dentry, struct sysfs_buffer * buffer)
  {
 -	struct kobject *kobj = sd->s_parent->priv;
 +	struct sysfs_dirent *attr_sd = dentry->d_fsdata;
 +	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 +	const struct sysfs_ops * ops = buffer->ops;
 +	int ret = 0;
 +	ssize_t count;
  
 -	if (!sysfs_ignore_lockdep(sd))
 -		lockdep_assert_held(sd);
 -	return kobj->ktype ? kobj->ktype->sysfs_ops : NULL;
 -}
 +	if (!buffer->page)
 +		buffer->page = (char *) get_zeroed_page(GFP_KERNEL);
 +	if (!buffer->page)
 +		return -ENOMEM;
  
 -/*
 - * Reads on sysfs are handled through seq_file, which takes care of hairy
 - * details like buffering and seeking.  The following function pipes
 - * sysfs_ops->show() result through seq_file.
 - */
 -static int sysfs_kf_seq_show(struct seq_file *sf, void *v)
 -{
 -	struct sysfs_open_file *of = sf->private;
 -	struct kobject *kobj = of->sd->s_parent->priv;
 -	const struct sysfs_ops *ops = sysfs_file_ops(of->sd);
 -	ssize_t count;
 -	char *buf;
 +	/* need attr_sd for attr and ops, its parent for kobj */
 +	if (!sysfs_get_active(attr_sd))
 +		return -ENODEV;
  
 -	/* acquire buffer and ensure that it's >= PAGE_SIZE */
 -	count = seq_get_buf(sf, &buf);
 -	if (count < PAGE_SIZE) {
 -		seq_commit(sf, -1);
 -		return 0;
 -	}
 +	buffer->event = atomic_read(&attr_sd->s_attr.open->event);
 +	count = ops->show(kobj, attr_sd->s_attr.attr, buffer->page);
  
 -	/*
 -	 * Invoke show().  Control may reach here via seq file lseek even
 -	 * if @ops->show() isn't implemented.
 -	 */
 -	if (ops->show) {
 -		count = ops->show(kobj, of->sd->priv, buf);
 -		if (count < 0)
 -			return count;
 -	}
 +	sysfs_put_active(attr_sd);
  
  	/*
  	 * The code works fine with PAGE_SIZE return but it's likely to
@@@ -96,112 -121,470 +118,516 @@@
  		/* Try to struggle along */
  		count = PAGE_SIZE - 1;
  	}
 -	seq_commit(sf, count);
 -	return 0;
 -}
 -
 -static ssize_t sysfs_kf_bin_read(struct sysfs_open_file *of, char *buf,
 -				 size_t count, loff_t pos)
 -{
 -	struct bin_attribute *battr = of->sd->priv;
 -	struct kobject *kobj = of->sd->s_parent->priv;
 -	loff_t size = file_inode(of->file)->i_size;
 -
 -	if (!count)
 -		return 0;
 -
 -	if (size) {
 -		if (pos > size)
 -			return 0;
 -		if (pos + count > size)
 -			count = size - pos;
 +	if (count >= 0) {
 +		buffer->needs_read_fill = 0;
 +		buffer->count = count;
 +	} else {
 +		ret = count;
  	}
++<<<<<<< HEAD
 +	return ret;
++=======
+ 
+ 	if (!battr->read)
+ 		return -EIO;
+ 
+ 	return battr->read(of->file, kobj, battr, buf, pos, count);
+ }
+ 
+ static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)
+ {
+ 	struct sysfs_open_file *of = sf->private;
+ 
+ 	/*
+ 	 * @of->mutex nests outside active ref and is just to ensure that
+ 	 * the ops aren't called concurrently for the same open file.
+ 	 */
+ 	mutex_lock(&of->mutex);
+ 	if (!sysfs_get_active(of->sd))
+ 		return ERR_PTR(-ENODEV);
+ 
+ 	/*
+ 	 * The same behavior and code as single_open().  Returns !NULL if
+ 	 * pos is at the beginning; otherwise, NULL.
+ 	 */
+ 	return NULL + !*ppos;
+ }
+ 
+ static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)
+ {
+ 	/*
+ 	 * The same behavior and code as single_open(), always terminate
+ 	 * after the initial read.
+ 	 */
+ 	++*ppos;
+ 	return NULL;
+ }
+ 
+ static void kernfs_seq_stop(struct seq_file *sf, void *v)
+ {
+ 	struct sysfs_open_file *of = sf->private;
+ 
+ 	sysfs_put_active(of->sd);
+ 	mutex_unlock(&of->mutex);
+ }
+ 
+ static int kernfs_seq_show(struct seq_file *sf, void *v)
+ {
+ 	struct sysfs_open_file *of = sf->private;
+ 
+ 	of->event = atomic_read(&of->sd->s_attr.open->event);
+ 
+ 	return of->sd->s_attr.ops->seq_show(sf, v);
+ }
+ 
+ static const struct seq_operations kernfs_seq_ops = {
+ 	.start = kernfs_seq_start,
+ 	.next = kernfs_seq_next,
+ 	.stop = kernfs_seq_stop,
+ 	.show = kernfs_seq_show,
+ };
+ 
+ /*
+  * As reading a bin file can have side-effects, the exact offset and bytes
+  * specified in read(2) call should be passed to the read callback making
+  * it difficult to use seq_file.  Implement simplistic custom buffering for
+  * bin files.
+  */
+ static ssize_t kernfs_file_direct_read(struct sysfs_open_file *of,
+ 				       char __user *user_buf, size_t count,
+ 				       loff_t *ppos)
+ {
+ 	ssize_t len = min_t(size_t, count, PAGE_SIZE);
+ 	const struct kernfs_ops *ops;
+ 	char *buf;
+ 
+ 	buf = kmalloc(len, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	/*
+ 	 * @of->mutex nests outside active ref and is just to ensure that
+ 	 * the ops aren't called concurrently for the same open file.
+ 	 */
+ 	mutex_lock(&of->mutex);
+ 	if (!sysfs_get_active(of->sd)) {
+ 		len = -ENODEV;
+ 		mutex_unlock(&of->mutex);
+ 		goto out_free;
+ 	}
+ 
+ 	ops = kernfs_ops(of->sd);
+ 	if (ops->read)
+ 		len = ops->read(of, buf, len, *ppos);
+ 	else
+ 		len = -EINVAL;
+ 
+ 	sysfs_put_active(of->sd);
+ 	mutex_unlock(&of->mutex);
+ 
+ 	if (len < 0)
+ 		goto out_free;
+ 
+ 	if (copy_to_user(user_buf, buf, len)) {
+ 		len = -EFAULT;
+ 		goto out_free;
+ 	}
+ 
+ 	*ppos += len;
+ 
+  out_free:
+ 	kfree(buf);
+ 	return len;
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  }
  
  /**
 - * kernfs_file_read - kernfs vfs read callback
 - * @file: file pointer
 - * @user_buf: data to write
 - * @count: number of bytes
 - * @ppos: starting offset
 + *	sysfs_read_file - read an attribute. 
 + *	@file:	file pointer.
 + *	@buf:	buffer to fill.
 + *	@count:	number of bytes to read.
 + *	@ppos:	starting offset in file.
 + *
 + *	Userspace wants to read an attribute file. The attribute descriptor
 + *	is in the file's ->d_fsdata. The target object is in the directory's
 + *	->d_fsdata.
 + *
 + *	We call fill_read_buffer() to allocate and fill the buffer from the
 + *	object's show() method exactly once (if the read is happening from
 + *	the beginning of the file). That should fill the entire buffer with
 + *	all the data the object has to offer for that attribute.
 + *	We then call flush_read_buffer() to copy the buffer to userspace
 + *	in the increments specified.
   */
 -static ssize_t kernfs_file_read(struct file *file, char __user *user_buf,
 -				size_t count, loff_t *ppos)
 -{
 -	struct sysfs_open_file *of = sysfs_of(file);
  
 +static ssize_t
 +sysfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 +{
 +	struct sysfs_buffer * buffer = file->private_data;
 +	ssize_t retval = 0;
 +
++<<<<<<< HEAD
 +	mutex_lock(&buffer->mutex);
 +	if (buffer->needs_read_fill || *ppos == 0) {
 +		retval = fill_read_buffer(file->f_path.dentry,buffer);
 +		if (retval)
 +			goto out;
++=======
+ 	if (of->sd->s_flags & SYSFS_FLAG_HAS_SEQ_SHOW)
+ 		return seq_read(file, user_buf, count, ppos);
+ 	else
+ 		return kernfs_file_direct_read(of, user_buf, count, ppos);
+ }
+ 
+ /* kernfs write callback for regular sysfs files */
+ static ssize_t sysfs_kf_write(struct sysfs_open_file *of, char *buf,
+ 			      size_t count, loff_t pos)
+ {
+ 	const struct sysfs_ops *ops = sysfs_file_ops(of->sd);
+ 	struct kobject *kobj = of->sd->s_parent->priv;
+ 
+ 	if (!count)
+ 		return 0;
+ 
+ 	return ops->store(kobj, of->sd->priv, buf, count);
+ }
+ 
+ /* kernfs write callback for bin sysfs files */
+ static ssize_t sysfs_kf_bin_write(struct sysfs_open_file *of, char *buf,
+ 				  size_t count, loff_t pos)
+ {
+ 	struct bin_attribute *battr = of->sd->priv;
+ 	struct kobject *kobj = of->sd->s_parent->priv;
+ 	loff_t size = file_inode(of->file)->i_size;
+ 
+ 	if (size) {
+ 		if (size <= pos)
+ 			return 0;
+ 		count = min_t(ssize_t, count, size - pos);
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  	}
 -	if (!count)
 -		return 0;
 -
 -	if (!battr->write)
 -		return -EIO;
 -
 -	return battr->write(of->file, kobj, battr, buf, pos, count);
 +	pr_debug("%s: count = %zd, ppos = %lld, buf = %s\n",
 +		 __func__, count, *ppos, buffer->page);
 +	retval = simple_read_from_buffer(buf, count, ppos, buffer->page,
 +					 buffer->count);
 +out:
 +	mutex_unlock(&buffer->mutex);
 +	return retval;
  }
  
  /**
 - * kernfs_file_write - kernfs vfs write callback
 - * @file: file pointer
 - * @user_buf: data to write
 - * @count: number of bytes
 - * @ppos: starting offset
 + *	fill_write_buffer - copy buffer from userspace.
 + *	@buffer:	data buffer for file.
 + *	@buf:		data from user.
 + *	@count:		number of bytes in @userbuf.
   *
 - * Copy data in from userland and pass it to the matching kernfs write
 - * operation.
 - *
 - * There is no easy way for us to know if userspace is only doing a partial
 - * write, so we don't support them. We expect the entire buffer to come on
 - * the first write.  Hint: if you're writing a value, first read the file,
 - * modify only the the value you're changing, then write entire buffer
 - * back.
 + *	Allocate @buffer->page if it hasn't been already, then
 + *	copy the user-supplied buffer into it.
   */
++<<<<<<< HEAD
++=======
+ static ssize_t kernfs_file_write(struct file *file, const char __user *user_buf,
+ 				 size_t count, loff_t *ppos)
+ {
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	ssize_t len = min_t(size_t, count, PAGE_SIZE);
+ 	const struct kernfs_ops *ops;
+ 	char *buf;
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  
 -	buf = kmalloc(len + 1, GFP_KERNEL);
 -	if (!buf)
 +static int 
 +fill_write_buffer(struct sysfs_buffer * buffer, const char __user * buf, size_t count)
 +{
 +	int error;
 +
 +	if (!buffer->page)
 +		buffer->page = (char *)get_zeroed_page(GFP_KERNEL);
 +	if (!buffer->page)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	if (count >= PAGE_SIZE)
 +		count = PAGE_SIZE - 1;
 +	error = copy_from_user(buffer->page,buf,count);
 +	buffer->needs_read_fill = 1;
 +	/* if buf is assumed to contain a string, terminate it by \0,
 +	   so e.g. sscanf() can scan the string easily */
 +	buffer->page[count] = 0;
 +	return error ? -EFAULT : count;
++=======
+ 	if (copy_from_user(buf, user_buf, len)) {
+ 		len = -EFAULT;
+ 		goto out_free;
+ 	}
+ 	buf[len] = '\0';	/* guarantee string termination */
+ 
+ 	/*
+ 	 * @of->mutex nests outside active ref and is just to ensure that
+ 	 * the ops aren't called concurrently for the same open file.
+ 	 */
+ 	mutex_lock(&of->mutex);
+ 	if (!sysfs_get_active(of->sd)) {
+ 		mutex_unlock(&of->mutex);
+ 		len = -ENODEV;
+ 		goto out_free;
+ 	}
+ 
+ 	ops = kernfs_ops(of->sd);
+ 	if (ops->write)
+ 		len = ops->write(of, buf, len, *ppos);
+ 	else
+ 		len = -EINVAL;
+ 
+ 	sysfs_put_active(of->sd);
+ 	mutex_unlock(&of->mutex);
+ 
+ 	if (len > 0)
+ 		*ppos += len;
+ out_free:
+ 	kfree(buf);
+ 	return len;
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  }
  
 -static int sysfs_kf_bin_mmap(struct sysfs_open_file *of,
 -			     struct vm_area_struct *vma)
 +
 +/**
 + *	flush_write_buffer - push buffer to kobject.
 + *	@dentry:	dentry to the attribute
 + *	@buffer:	data buffer for file.
 + *	@count:		number of bytes
 + *
 + *	Get the correct pointers for the kobject and the attribute we're
 + *	dealing with, then call the store() method for the attribute, 
 + *	passing the buffer that we acquired in fill_write_buffer().
 + */
 +
 +static int
 +flush_write_buffer(struct dentry * dentry, struct sysfs_buffer * buffer, size_t count)
  {
++<<<<<<< HEAD
 +	struct sysfs_dirent *attr_sd = dentry->d_fsdata;
 +	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 +	const struct sysfs_ops * ops = buffer->ops;
++=======
+ 	struct bin_attribute *battr = of->sd->priv;
+ 	struct kobject *kobj = of->sd->s_parent->priv;
+ 
+ 	if (!battr->mmap)
+ 		return -ENODEV;
+ 
+ 	return battr->mmap(of->file, kobj, battr, vma);
+ }
+ 
+ static void kernfs_vma_open(struct vm_area_struct *vma)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 
+ 	if (!of->vm_ops)
+ 		return;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return;
+ 
+ 	if (of->vm_ops->open)
+ 		of->vm_ops->open(vma);
+ 
+ 	sysfs_put_active(of->sd);
+ }
+ 
+ static int kernfs_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	int ret;
+ 
+ 	if (!of->vm_ops)
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	ret = VM_FAULT_SIGBUS;
+ 	if (of->vm_ops->fault)
+ 		ret = of->vm_ops->fault(vma, vmf);
+ 
+ 	sysfs_put_active(of->sd);
+ 	return ret;
+ }
+ 
+ static int kernfs_vma_page_mkwrite(struct vm_area_struct *vma,
+ 				   struct vm_fault *vmf)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	int ret;
+ 
+ 	if (!of->vm_ops)
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return VM_FAULT_SIGBUS;
+ 
+ 	ret = 0;
+ 	if (of->vm_ops->page_mkwrite)
+ 		ret = of->vm_ops->page_mkwrite(vma, vmf);
+ 	else
+ 		file_update_time(file);
+ 
+ 	sysfs_put_active(of->sd);
+ 	return ret;
+ }
+ 
+ static int kernfs_vma_access(struct vm_area_struct *vma, unsigned long addr,
+ 			     void *buf, int len, int write)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	int ret;
+ 
+ 	if (!of->vm_ops)
+ 		return -EINVAL;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return -EINVAL;
+ 
+ 	ret = -EINVAL;
+ 	if (of->vm_ops->access)
+ 		ret = of->vm_ops->access(vma, addr, buf, len, write);
+ 
+ 	sysfs_put_active(of->sd);
+ 	return ret;
+ }
+ 
+ #ifdef CONFIG_NUMA
+ static int kernfs_vma_set_policy(struct vm_area_struct *vma,
+ 				 struct mempolicy *new)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	int ret;
+ 
+ 	if (!of->vm_ops)
+ 		return 0;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return -EINVAL;
+ 
+ 	ret = 0;
+ 	if (of->vm_ops->set_policy)
+ 		ret = of->vm_ops->set_policy(vma, new);
+ 
+ 	sysfs_put_active(of->sd);
+ 	return ret;
+ }
+ 
+ static struct mempolicy *kernfs_vma_get_policy(struct vm_area_struct *vma,
+ 					       unsigned long addr)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	struct mempolicy *pol;
+ 
+ 	if (!of->vm_ops)
+ 		return vma->vm_policy;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return vma->vm_policy;
+ 
+ 	pol = vma->vm_policy;
+ 	if (of->vm_ops->get_policy)
+ 		pol = of->vm_ops->get_policy(vma, addr);
+ 
+ 	sysfs_put_active(of->sd);
+ 	return pol;
+ }
+ 
+ static int kernfs_vma_migrate(struct vm_area_struct *vma,
+ 			      const nodemask_t *from, const nodemask_t *to,
+ 			      unsigned long flags)
+ {
+ 	struct file *file = vma->vm_file;
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	int ret;
+ 
+ 	if (!of->vm_ops)
+ 		return 0;
+ 
+ 	if (!sysfs_get_active(of->sd))
+ 		return 0;
+ 
+ 	ret = 0;
+ 	if (of->vm_ops->migrate)
+ 		ret = of->vm_ops->migrate(vma, from, to, flags);
+ 
+ 	sysfs_put_active(of->sd);
+ 	return ret;
+ }
+ #endif
+ 
+ static const struct vm_operations_struct kernfs_vm_ops = {
+ 	.open		= kernfs_vma_open,
+ 	.fault		= kernfs_vma_fault,
+ 	.page_mkwrite	= kernfs_vma_page_mkwrite,
+ 	.access		= kernfs_vma_access,
+ #ifdef CONFIG_NUMA
+ 	.set_policy	= kernfs_vma_set_policy,
+ 	.get_policy	= kernfs_vma_get_policy,
+ 	.migrate	= kernfs_vma_migrate,
+ #endif
+ };
+ 
+ static int kernfs_file_mmap(struct file *file, struct vm_area_struct *vma)
+ {
+ 	struct sysfs_open_file *of = sysfs_of(file);
+ 	const struct kernfs_ops *ops;
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  	int rc;
  
 -	mutex_lock(&of->mutex);
 +	/* need attr_sd for attr and ops, its parent for kobj */
 +	if (!sysfs_get_active(attr_sd))
 +		return -ENODEV;
  
 -	rc = -ENODEV;
 -	if (!sysfs_get_active(of->sd))
 -		goto out_unlock;
 +	rc = ops->store(kobj, attr_sd->s_attr.attr, buffer->page, count);
  
++<<<<<<< HEAD
 +	sysfs_put_active(attr_sd);
++=======
+ 	ops = kernfs_ops(of->sd);
+ 	if (ops->mmap)
+ 		rc = ops->mmap(of, vma);
+ 	if (rc)
+ 		goto out_put;
+ 
+ 	/*
+ 	 * PowerPC's pci_mmap of legacy_mem uses shmem_zero_setup()
+ 	 * to satisfy versions of X which crash if the mmap fails: that
+ 	 * substitutes a new vm_file, and we don't then want bin_vm_ops.
+ 	 */
+ 	if (vma->vm_file != file)
+ 		goto out_put;
+ 
+ 	rc = -EINVAL;
+ 	if (of->mmapped && of->vm_ops != vma->vm_ops)
+ 		goto out_put;
+ 
+ 	/*
+ 	 * It is not possible to successfully wrap close.
+ 	 * So error if someone is trying to use close.
+ 	 */
+ 	rc = -EINVAL;
+ 	if (vma->vm_ops && vma->vm_ops->close)
+ 		goto out_put;
+ 
+ 	rc = 0;
+ 	of->mmapped = 1;
+ 	of->vm_ops = vma->vm_ops;
+ 	vma->vm_ops = &kernfs_vm_ops;
+ out_put:
+ 	sysfs_put_active(of->sd);
+ out_unlock:
+ 	mutex_unlock(&of->mutex);
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  
  	return rc;
  }
@@@ -323,62 -677,80 +749,115 @@@ static void sysfs_put_open_dirent(struc
  	kfree(od);
  }
  
 -static int kernfs_file_open(struct inode *inode, struct file *file)
 +static int sysfs_open_file(struct inode *inode, struct file *file)
  {
  	struct sysfs_dirent *attr_sd = file->f_path.dentry->d_fsdata;
++<<<<<<< HEAD
 +	struct kobject *kobj = attr_sd->s_parent->s_dir.kobj;
 +	struct sysfs_buffer *buffer;
 +	const struct sysfs_ops *ops;
++=======
+ 	const struct kernfs_ops *ops;
+ 	struct sysfs_open_file *of;
+ 	bool has_read, has_write, has_mmap;
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  	int error = -EACCES;
  
- 	/* need attr_sd for attr and ops, its parent for kobj */
  	if (!sysfs_get_active(attr_sd))
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	/* every kobject with an attribute needs a ktype assigned */
 +	if (kobj->ktype && kobj->ktype->sysfs_ops)
 +		ops = kobj->ktype->sysfs_ops;
 +	else {
 +		WARN(1, KERN_ERR "missing sysfs attribute operations for "
 +		       "kobject: %s\n", kobject_name(kobj));
 +		goto err_out;
 +	}
++=======
+ 	ops = kernfs_ops(attr_sd);
+ 
+ 	has_read = ops->seq_show || ops->read || ops->mmap;
+ 	has_write = ops->write || ops->mmap;
+ 	has_mmap = ops->mmap;
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  
 -	/* check perms and supported operations */
 -	if ((file->f_mode & FMODE_WRITE) &&
 -	    (!(inode->i_mode & S_IWUGO) || !has_write))
 -		goto err_out;
 +	/* File needs write support.
 +	 * The inode's perms must say it's ok, 
 +	 * and we must have a store method.
 +	 */
 +	if (file->f_mode & FMODE_WRITE) {
 +		if (!(inode->i_mode & S_IWUGO) || !ops->store)
 +			goto err_out;
 +	}
  
 -	if ((file->f_mode & FMODE_READ) &&
 -	    (!(inode->i_mode & S_IRUGO) || !has_read))
 -		goto err_out;
 +	/* File needs read support.
 +	 * The inode's perms must say it's ok, and we there
 +	 * must be a show method for it.
 +	 */
 +	if (file->f_mode & FMODE_READ) {
 +		if (!(inode->i_mode & S_IRUGO) || !ops->show)
 +			goto err_out;
 +	}
  
 -	/* allocate a sysfs_open_file for the file */
 +	/* No error? Great, allocate a buffer for the file, and store it
 +	 * it in file->private_data for easy access.
 +	 */
  	error = -ENOMEM;
 -	of = kzalloc(sizeof(struct sysfs_open_file), GFP_KERNEL);
 -	if (!of)
 +	buffer = kzalloc(sizeof(struct sysfs_buffer), GFP_KERNEL);
 +	if (!buffer)
  		goto err_out;
  
++<<<<<<< HEAD
 +	mutex_init(&buffer->mutex);
 +	buffer->needs_read_fill = 1;
 +	buffer->ops = ops;
 +	file->private_data = buffer;
++=======
+ 	/*
+ 	 * The following is done to give a different lockdep key to
+ 	 * @of->mutex for files which implement mmap.  This is a rather
+ 	 * crude way to avoid false positive lockdep warning around
+ 	 * mm->mmap_sem - mmap nests @of->mutex under mm->mmap_sem and
+ 	 * reading /sys/block/sda/trace/act_mask grabs sr_mutex, under
+ 	 * which mm->mmap_sem nests, while holding @of->mutex.  As each
+ 	 * open file has a separate mutex, it's okay as long as those don't
+ 	 * happen on the same file.  At this point, we can't easily give
+ 	 * each file a separate locking class.  Let's differentiate on
+ 	 * whether the file has mmap or not for now.
+ 	 */
+ 	if (has_mmap)
+ 		mutex_init(&of->mutex);
+ 	else
+ 		mutex_init(&of->mutex);
+ 
+ 	of->sd = attr_sd;
+ 	of->file = file;
+ 
+ 	/*
+ 	 * Always instantiate seq_file even if read access doesn't use
+ 	 * seq_file or is not requested.  This unifies private data access
+ 	 * and readable regular files are the vast majority anyway.
+ 	 */
+ 	if (ops->seq_show)
+ 		error = seq_open(file, &kernfs_seq_ops);
+ 	else
+ 		error = seq_open(file, NULL);
+ 	if (error)
+ 		goto err_free;
+ 
+ 	((struct seq_file *)file->private_data)->private = of;
+ 
+ 	/* seq_file clears PWRITE unconditionally, restore it if WRITE */
+ 	if (file->f_mode & FMODE_WRITE)
+ 		file->f_mode |= FMODE_PWRITE;
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  
  	/* make sure we have open dirent struct */
 -	error = sysfs_get_open_dirent(attr_sd, of);
 +	error = sysfs_get_open_dirent(attr_sd, buffer);
  	if (error)
 -		goto err_close;
 +		goto err_free;
  
  	/* open succeeded, put active references */
  	sysfs_put_active(attr_sd);
@@@ -405,6 -777,32 +884,35 @@@ static int sysfs_release(struct inode *
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ void sysfs_unmap_bin_file(struct sysfs_dirent *sd)
+ {
+ 	struct sysfs_open_dirent *od;
+ 	struct sysfs_open_file *of;
+ 
+ 	if (!(sd->s_flags & SYSFS_FLAG_HAS_MMAP))
+ 		return;
+ 
+ 	spin_lock_irq(&sysfs_open_dirent_lock);
+ 	od = sd->s_attr.open;
+ 	if (od)
+ 		atomic_inc(&od->refcnt);
+ 	spin_unlock_irq(&sysfs_open_dirent_lock);
+ 	if (!od)
+ 		return;
+ 
+ 	mutex_lock(&sysfs_open_file_mutex);
+ 	list_for_each_entry(of, &od->files, list) {
+ 		struct inode *inode = file_inode(of->file);
+ 		unmap_mapping_range(inode->i_mapping, 0, 0, 1);
+ 	}
+ 	mutex_unlock(&sysfs_open_file_mutex);
+ 
+ 	sysfs_put_open_dirent(sd, NULL);
+ }
+ 
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  /* Sysfs attribute files are pollable.  The idea is that you read
   * the content and then you use 'poll' or 'select' to wait for
   * the content to change.  When the content changes (assuming the
@@@ -476,76 -875,108 +984,162 @@@ void sysfs_notify(struct kobject *k, co
  }
  EXPORT_SYMBOL_GPL(sysfs_notify);
  
 -const struct file_operations kernfs_file_operations = {
 -	.read		= kernfs_file_read,
 -	.write		= kernfs_file_write,
 +const struct file_operations sysfs_file_operations = {
 +	.read		= sysfs_read_file,
 +	.write		= sysfs_write_file,
  	.llseek		= generic_file_llseek,
 -	.mmap		= kernfs_file_mmap,
 -	.open		= kernfs_file_open,
 -	.release	= kernfs_file_release,
 -	.poll		= kernfs_file_poll,
 +	.open		= sysfs_open_file,
 +	.release	= sysfs_release,
 +	.poll		= sysfs_poll,
  };
  
++<<<<<<< HEAD
 +static int sysfs_attr_ns(struct kobject *kobj, const struct attribute *attr,
 +			 const void **pns)
 +{
 +	struct sysfs_dirent *dir_sd = kobj->sd;
 +	const struct sysfs_ops *ops;
 +	const void *ns = NULL;
 +	int err;
 +
 +	if (!dir_sd) {
 +		WARN(1, KERN_ERR "sysfs: kobject %s without dirent\n",
 +			kobject_name(kobj));
 +		return -ENOENT;
 +	}
 +
 +	err = 0;
 +	if (!sysfs_ns_type(dir_sd))
 +		goto out;
 +
 +	err = -EINVAL;
 +	if (!kobj->ktype)
 +		goto out;
 +	ops = kobj->ktype->sysfs_ops;
 +	if (!ops)
 +		goto out;
 +	if (!ops->namespace)
 +		goto out;
 +
 +	err = 0;
 +	ns = ops->namespace(kobj, attr);
 +out:
 +	if (err) {
 +		WARN(1, KERN_ERR "missing sysfs namespace attribute operation for "
 +		     "kobject: %s\n", kobject_name(kobj));
 +	}
 +	*pns = ns;
 +	return err;
 +}
 +
 +int sysfs_add_file_mode(struct sysfs_dirent *dir_sd,
 +			const struct attribute *attr, int type, umode_t amode)
++=======
+ static const struct kernfs_ops sysfs_file_kfops_empty = {
+ };
+ 
+ static const struct kernfs_ops sysfs_file_kfops_ro = {
+ 	.seq_show	= sysfs_kf_seq_show,
+ };
+ 
+ static const struct kernfs_ops sysfs_file_kfops_wo = {
+ 	.write		= sysfs_kf_write,
+ };
+ 
+ static const struct kernfs_ops sysfs_file_kfops_rw = {
+ 	.seq_show	= sysfs_kf_seq_show,
+ 	.write		= sysfs_kf_write,
+ };
+ 
+ static const struct kernfs_ops sysfs_bin_kfops_ro = {
+ 	.read		= sysfs_kf_bin_read,
+ };
+ 
+ static const struct kernfs_ops sysfs_bin_kfops_wo = {
+ 	.write		= sysfs_kf_bin_write,
+ };
+ 
+ static const struct kernfs_ops sysfs_bin_kfops_rw = {
+ 	.read		= sysfs_kf_bin_read,
+ 	.write		= sysfs_kf_bin_write,
+ 	.mmap		= sysfs_kf_bin_mmap,
+ };
+ 
+ int sysfs_add_file_mode_ns(struct sysfs_dirent *dir_sd,
+ 			   const struct attribute *attr, int type,
+ 			   umode_t amode, const void *ns)
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  {
  	umode_t mode = (amode & S_IALLUGO) | S_IFREG;
+ 	const struct kernfs_ops *ops;
  	struct sysfs_addrm_cxt acxt;
  	struct sysfs_dirent *sd;
 +	const void *ns;
  	int rc;
  
++<<<<<<< HEAD
 +	rc = sysfs_attr_ns(dir_sd->s_dir.kobj, attr, &ns);
 +	if (rc)
 +		return rc;
++=======
+ 	if (type == SYSFS_KOBJ_ATTR) {
+ 		struct kobject *kobj = dir_sd->priv;
+ 		const struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;
+ 
+ 		/* every kobject with an attribute needs a ktype assigned */
+ 		if (WARN(!sysfs_ops, KERN_ERR
+ 			 "missing sysfs attribute operations for kobject: %s\n",
+ 			 kobject_name(kobj)))
+ 			return -EINVAL;
+ 
+ 		if (sysfs_ops->show && sysfs_ops->store)
+ 			ops = &sysfs_file_kfops_rw;
+ 		else if (sysfs_ops->show)
+ 			ops = &sysfs_file_kfops_ro;
+ 		else if (sysfs_ops->store)
+ 			ops = &sysfs_file_kfops_wo;
+ 		else
+ 			ops = &sysfs_file_kfops_empty;
+ 	} else {
+ 		struct bin_attribute *battr = (void *)attr;
+ 
+ 		if ((battr->read && battr->write) || battr->mmap)
+ 			ops = &sysfs_bin_kfops_rw;
+ 		else if (battr->read)
+ 			ops = &sysfs_bin_kfops_ro;
+ 		else if (battr->write)
+ 			ops = &sysfs_bin_kfops_wo;
+ 		else
+ 			ops = &sysfs_file_kfops_empty;
+ 	}
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  
  	sd = sysfs_new_dirent(attr->name, mode, type);
  	if (!sd)
  		return -ENOMEM;
  
+ 	sd->s_attr.ops = ops;
  	sd->s_ns = ns;
 -	sd->priv = (void *)attr;
 +	sd->s_attr.attr = (void *)attr;
  	sysfs_dirent_init_lockdep(sd);
  
++<<<<<<< HEAD
 +	sysfs_addrm_start(&acxt, dir_sd);
 +	rc = sysfs_add_one(&acxt, sd);
++=======
+ 	/*
+ 	 * sd->s_attr.ops is accesible only while holding active ref.  We
+ 	 * need to know whether some ops are implemented outside active
+ 	 * ref.  Cache their existence in flags.
+ 	 */
+ 	if (ops->seq_show)
+ 		sd->s_flags |= SYSFS_FLAG_HAS_SEQ_SHOW;
+ 	if (ops->mmap)
+ 		sd->s_flags |= SYSFS_FLAG_HAS_MMAP;
+ 
+ 	sysfs_addrm_start(&acxt);
+ 	rc = sysfs_add_one(&acxt, sd, dir_sd);
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  	sysfs_addrm_finish(&acxt);
  
  	if (rc)
diff --cc fs/sysfs/sysfs.h
index d1e4043eb0c3,c05e0ddd0268..000000000000
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@@ -29,7 -27,7 +29,11 @@@ struct sysfs_elem_symlink 
  };
  
  struct sysfs_elem_attr {
++<<<<<<< HEAD
 +	struct attribute	*attr;
++=======
+ 	const struct kernfs_ops	*ops;
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  	struct sysfs_open_dirent *open;
  };
  
@@@ -93,12 -87,11 +97,14 @@@ struct sysfs_dirent 
  #define SYSFS_COPY_NAME			(SYSFS_DIR | SYSFS_KOBJ_LINK)
  #define SYSFS_ACTIVE_REF		(SYSFS_KOBJ_ATTR | SYSFS_KOBJ_BIN_ATTR)
  
 -#define SYSFS_FLAG_MASK			~SYSFS_TYPE_MASK
 -#define SYSFS_FLAG_NS			0x01000
 +/* identify any namespace tag on sysfs_dirents */
 +#define SYSFS_NS_TYPE_MASK		0xf00
 +#define SYSFS_NS_TYPE_SHIFT		8
 +
 +#define SYSFS_FLAG_MASK			~(SYSFS_NS_TYPE_MASK|SYSFS_TYPE_MASK)
  #define SYSFS_FLAG_REMOVED		0x02000
+ #define SYSFS_FLAG_HAS_SEQ_SHOW		0x04000
+ #define SYSFS_FLAG_HAS_MMAP		0x08000
  
  static inline unsigned int sysfs_type(struct sysfs_dirent *sd)
  {
diff --cc include/linux/kernfs.h
index 254b9e872b09,97c6c0f91325..000000000000
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@@ -7,6 -7,115 +7,108 @@@
  #ifndef __LINUX_KERNFS_H
  #define __LINUX_KERNFS_H
  
 -#include <linux/kernel.h>
 -#include <linux/err.h>
 -#include <linux/list.h>
 -#include <linux/mutex.h>
 -
 -struct file;
 -struct iattr;
 -struct seq_file;
 -struct vm_area_struct;
 -
  struct sysfs_dirent;
  
++<<<<<<< HEAD
++=======
+ struct sysfs_open_file {
+ 	/* published fields */
+ 	struct sysfs_dirent	*sd;
+ 	struct file		*file;
+ 
+ 	/* private fields, do not use outside kernfs proper */
+ 	struct mutex		mutex;
+ 	int			event;
+ 	struct list_head	list;
+ 
+ 	bool			mmapped;
+ 	const struct vm_operations_struct *vm_ops;
+ };
+ 
+ struct kernfs_ops {
+ 	/*
+ 	 * Read is handled by either seq_file or raw_read().
+ 	 *
+ 	 * If seq_show() is present, seq_file path is active.  The behavior
+ 	 * is equivalent to single_open().  @sf->private points to the
+ 	 * associated sysfs_open_file.
+ 	 *
+ 	 * read() is bounced through kernel buffer and a read larger than
+ 	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
+ 	 */
+ 	int (*seq_show)(struct seq_file *sf, void *v);
+ 
+ 	ssize_t (*read)(struct sysfs_open_file *of, char *buf, size_t bytes,
+ 			loff_t off);
+ 
+ 	/*
+ 	 * write() is bounced through kernel buffer and a write larger than
+ 	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
+ 	 */
+ 	ssize_t (*write)(struct sysfs_open_file *of, char *buf, size_t bytes,
+ 			 loff_t off);
+ 
+ 	int (*mmap)(struct sysfs_open_file *of, struct vm_area_struct *vma);
+ };
+ 
+ #ifdef CONFIG_SYSFS
+ 
+ struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
+ 					  const char *name, void *priv,
+ 					  const void *ns);
+ struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
+ 					const char *name,
+ 					struct sysfs_dirent *target);
+ void kernfs_remove(struct sysfs_dirent *sd);
+ int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
+ 			     const void *ns);
+ int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
+ 		     const char *new_name, const void *new_ns);
+ void kernfs_enable_ns(struct sysfs_dirent *sd);
+ int kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr);
+ 
+ #else	/* CONFIG_SYSFS */
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_dir_ns(struct sysfs_dirent *parent, const char *name, void *priv,
+ 		     const void *ns)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_link(struct sysfs_dirent *parent, const char *name,
+ 		   struct sysfs_dirent *target)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline void kernfs_remove(struct sysfs_dirent *sd) { }
+ 
+ static inline int kernfs_remove_by_name_ns(struct sysfs_dirent *parent,
+ 					   const char *name, const void *ns)
+ { return -ENOSYS; }
+ 
+ static inline int kernfs_rename_ns(struct sysfs_dirent *sd,
+ 				   struct sysfs_dirent *new_parent,
+ 				   const char *new_name, const void *new_ns)
+ { return -ENOSYS; }
+ 
+ static inline void kernfs_enable_ns(struct sysfs_dirent *sd) { }
+ 
+ static inline int kernfs_setattr(struct sysfs_dirent *sd,
+ 				 const struct iattr *iattr)
+ { return -ENOSYS; }
+ 
+ #endif	/* CONFIG_SYSFS */
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_dir(struct sysfs_dirent *parent, const char *name, void *priv)
+ {
+ 	return kernfs_create_dir_ns(parent, name, priv, NULL);
+ }
+ 
+ static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,
+ 					const char *name)
+ {
+ 	return kernfs_remove_by_name_ns(parent, name, NULL);
+ }
+ 
++>>>>>>> f6acf8bb6a40 (sysfs, kernfs: introduce kernfs_ops)
  #endif	/* __LINUX_KERNFS_H */
* Unmerged path fs/sysfs/file.c
* Unmerged path fs/sysfs/sysfs.h
* Unmerged path include/linux/kernfs.h
