bridge: add API to notify bridge driver of learned FBD on offloaded device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Scott Feldman <sfeldma@gmail.com>
commit cf6b8e1eedffd9ef9a22c0c9453d752b07daf89a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/cf6b8e1e.failed

When the swdev device learns a new mac/vlan on a port, it sends some async
notification to the driver and the driver installs an FDB in the device.
To give a holistic system view, the learned mac/vlan should be reflected
in the bridge's FBD table, so the user, using normal iproute2 cmds, can view
what is currently learned by the device.  This API on the bridge driver gives
a way for the swdev driver to install an FBD entry in the bridge FBD table.
(And remove one).

This is equivalent to the device running these cmds:

  bridge fdb [add|del] <mac> dev <dev> vid <vlan id> master

This patch needs some extra eyeballs for review, in paricular around the
locking and contexts.

	Signed-off-by: Scott Feldman <sfeldma@gmail.com>
	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cf6b8e1eedffd9ef9a22c0c9453d752b07daf89a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/if_bridge.h
#	net/bridge/br_private.h
diff --cc include/linux/if_bridge.h
index 38a04e1bb6e7,fa2eca625129..000000000000
--- a/include/linux/if_bridge.h
+++ b/include/linux/if_bridge.h
@@@ -49,9 -36,46 +49,32 @@@ extern void brioctl_set(int (*ioctl_hoo
  
  typedef int br_should_route_hook_t(struct sk_buff *skb);
  extern br_should_route_hook_t __rcu *br_should_route_hook;
++<<<<<<< HEAD
 +#if 0
 +/* RHEL: not yet fully supported */
++=======
+ 
+ #if IS_ENABLED(CONFIG_BRIDGE)
+ int br_fdb_external_learn_add(struct net_device *dev,
+ 			      const unsigned char *addr, u16 vid);
+ int br_fdb_external_learn_del(struct net_device *dev,
+ 			      const unsigned char *addr, u16 vid);
+ #else
+ static inline int br_fdb_external_learn_add(struct net_device *dev,
+ 					    const unsigned char *addr, u16 vid)
+ {
+ 	return 0;
+ }
+ static inline int br_fdb_external_learn_del(struct net_device *dev,
+ 					    const unsigned char *addr, u16 vid)
+ {
+ 	return 0;
+ }
+ #endif
+ 
+ #if IS_ENABLED(CONFIG_BRIDGE) && IS_ENABLED(CONFIG_BRIDGE_IGMP_SNOOPING)
++>>>>>>> cf6b8e1eedff (bridge: add API to notify bridge driver of learned FBD on offloaded device)
  int br_multicast_list_adjacent(struct net_device *dev,
  			       struct list_head *br_ip_list);
 -bool br_multicast_has_querier_anywhere(struct net_device *dev, int proto);
 -bool br_multicast_has_querier_adjacent(struct net_device *dev, int proto);
 -#else
 -static inline int br_multicast_list_adjacent(struct net_device *dev,
 -					     struct list_head *br_ip_list)
 -{
 -	return 0;
 -}
 -static inline bool br_multicast_has_querier_anywhere(struct net_device *dev,
 -						     int proto)
 -{
 -	return false;
 -}
 -static inline bool br_multicast_has_querier_adjacent(struct net_device *dev,
 -						     int proto)
 -{
 -	return false;
 -}
  #endif
 -
  #endif
diff --cc net/bridge/br_private.h
index 40e90db9226f,cc36fb3efbdd..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -92,11 -97,12 +92,18 @@@ struct net_bridge_fdb_entr
  	unsigned long			updated;
  	unsigned long			used;
  	mac_addr			addr;
++<<<<<<< HEAD
++=======
+ 	unsigned char			is_local:1,
+ 					is_static:1,
+ 					added_by_user:1,
+ 					added_by_external_learn:1;
++>>>>>>> cf6b8e1eedff (bridge: add API to notify bridge driver of learned FBD on offloaded device)
  	__u16				vlan_id;
 +	unsigned char			is_local;
 +	unsigned char			is_static;
 +	unsigned char			added_by_user;
 +	struct rcu_head			rcu;
  };
  
  struct net_bridge_port_group {
* Unmerged path include/linux/if_bridge.h
diff --git a/include/uapi/linux/neighbour.h b/include/uapi/linux/neighbour.h
index 97971601773b..26e74a6cb872 100644
--- a/include/uapi/linux/neighbour.h
+++ b/include/uapi/linux/neighbour.h
@@ -39,6 +39,7 @@ enum {
 #define NTF_SELF	0x02
 #define NTF_MASTER	0x04
 #define NTF_PROXY	0x08	/* == ATF_PUBL */
+#define NTF_EXT_LEARNED	0x10
 #define NTF_ROUTER	0x80
 
 /*
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index b30545c7ced8..d41c516409c8 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -481,6 +481,7 @@ static struct net_bridge_fdb_entry *fdb_create(struct hlist_head *head,
 		fdb->is_local = 0;
 		fdb->is_static = 0;
 		fdb->added_by_user = 0;
+		fdb->added_by_external_learn = 0;
 		fdb->updated = fdb->used = jiffies;
 		hlist_add_head_rcu(&fdb->hlist, head);
 	}
@@ -613,7 +614,7 @@ static int fdb_fill_info(struct sk_buff *skb, const struct net_bridge *br,
 	ndm->ndm_family	 = AF_BRIDGE;
 	ndm->ndm_pad1    = 0;
 	ndm->ndm_pad2    = 0;
-	ndm->ndm_flags	 = 0;
+	ndm->ndm_flags	 = fdb->added_by_external_learn ? NTF_EXT_LEARNED : 0;
 	ndm->ndm_type	 = 0;
 	ndm->ndm_ifindex = fdb->dst ? fdb->dst->dev->ifindex : br->dev->ifindex;
 	ndm->ndm_state   = fdb_to_nud(fdb);
@@ -983,3 +984,91 @@ void br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p)
 		}
 	}
 }
+
+int br_fdb_external_learn_add(struct net_device *dev,
+			      const unsigned char *addr, u16 vid)
+{
+	struct net_bridge_port *p;
+	struct net_bridge *br;
+	struct hlist_head *head;
+	struct net_bridge_fdb_entry *fdb;
+	int err = 0;
+
+	rtnl_lock();
+
+	p = br_port_get_rtnl(dev);
+	if (!p) {
+		pr_info("bridge: %s not a bridge port\n", dev->name);
+		err = -EINVAL;
+		goto err_rtnl_unlock;
+	}
+
+	br = p->br;
+
+	spin_lock_bh(&br->hash_lock);
+
+	head = &br->hash[br_mac_hash(addr, vid)];
+	fdb = fdb_find(head, addr, vid);
+	if (!fdb) {
+		fdb = fdb_create(head, p, addr, vid);
+		if (!fdb) {
+			err = -ENOMEM;
+			goto err_unlock;
+		}
+		fdb->added_by_external_learn = 1;
+		fdb_notify(br, fdb, RTM_NEWNEIGH);
+	} else if (fdb->added_by_external_learn) {
+		/* Refresh entry */
+		fdb->updated = fdb->used = jiffies;
+	} else if (!fdb->added_by_user) {
+		/* Take over SW learned entry */
+		fdb->added_by_external_learn = 1;
+		fdb->updated = jiffies;
+		fdb_notify(br, fdb, RTM_NEWNEIGH);
+	}
+
+err_unlock:
+	spin_unlock_bh(&br->hash_lock);
+err_rtnl_unlock:
+	rtnl_unlock();
+
+	return err;
+}
+EXPORT_SYMBOL(br_fdb_external_learn_add);
+
+int br_fdb_external_learn_del(struct net_device *dev,
+			      const unsigned char *addr, u16 vid)
+{
+	struct net_bridge_port *p;
+	struct net_bridge *br;
+	struct hlist_head *head;
+	struct net_bridge_fdb_entry *fdb;
+	int err = 0;
+
+	rtnl_lock();
+
+	p = br_port_get_rtnl(dev);
+	if (!p) {
+		pr_info("bridge: %s not a bridge port\n", dev->name);
+		err = -EINVAL;
+		goto err_rtnl_unlock;
+	}
+
+	br = p->br;
+
+	spin_lock_bh(&br->hash_lock);
+
+	head = &br->hash[br_mac_hash(addr, vid)];
+	fdb = fdb_find(head, addr, vid);
+	if (fdb && fdb->added_by_external_learn)
+		fdb_delete(br, fdb);
+	else
+		err = -ENOENT;
+
+	spin_unlock_bh(&br->hash_lock);
+err_rtnl_unlock:
+	rtnl_unlock();
+
+	return err;
+}
+EXPORT_SYMBOL(br_fdb_external_learn_del);
* Unmerged path net/bridge/br_private.h
