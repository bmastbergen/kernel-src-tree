mmc: sdhci-of-esdhc: fixup PRESENT_STATE read

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mmc] sdhci-of-esdhc: fixup PRESENT_STATE read (Don Zickus) [1430497]
Rebuild_FUZZ: 94.12%
commit-author Michael Walle <michael@walle.cc>
commit b0921d5c9ed6ffa8a4d6afc5ee5f136b87445f14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b0921d5c.failed

Since commit 87a18a6a5652 ("mmc: mmc: Use ->card_busy() to detect busy
cards in __mmc_switch()") the ESDHC driver is broken:
  mmc0: Card stuck in programming state! __mmc_switch
  mmc0: error -110 whilst initialising MMC card

Since this commit __mmc_switch() uses ->card_busy(), which is
sdhci_card_busy() for the esdhc driver. sdhci_card_busy() uses the
PRESENT_STATE register, specifically the DAT0 signal level bit. But the
ESDHC uses a non-conformant PRESENT_STATE register, thus a read fixup is
required to make the driver work again.

	Signed-off-by: Michael Walle <michael@walle.cc>
Fixes: 87a18a6a5652 ("mmc: mmc: Use ->card_busy() to detect busy cards in __mmc_switch()")
	Acked-by: Yangbo Lu <yangbo.lu@nxp.com>
	Acked-by: Adrian Hunter <adrian.hunter@intel.com>
	Cc: <stable@vger.kernel.org> # v4.8+
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit b0921d5c9ed6ffa8a4d6afc5ee5f136b87445f14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci-of-esdhc.c
diff --cc drivers/mmc/host/sdhci-of-esdhc.c
index 5e68adc2461e,1bb11e4a9fe5..000000000000
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@@ -33,18 -57,30 +33,36 @@@ static u32 esdhc_readl(struct sdhci_hos
  	 * SDHC register, so set fake flag SDHCI_CAN_DO_ADMA2 when ADMA is
  	 * supported by eSDHC.
  	 * And for many FSL eSDHC controller, the reset value of field
 -	 * SDHCI_CAN_DO_ADMA1 is 1, but some of them can't support ADMA,
 +	 * SDHCI_CAN_DO_ADMA1 is one, but some of them can't support ADMA,
  	 * only these vendor version is greater than 2.2/0x12 support ADMA.
 +	 * For FSL eSDHC, must aligned 4-byte, so use 0xFC to read the
 +	 * the verdor version number, oxFE is SDHCI_HOST_VERSION.
  	 */
 -	if ((spec_reg == SDHCI_CAPABILITIES) && (value & SDHCI_CAN_DO_ADMA1)) {
 -		if (esdhc->vendor_ver > VENDOR_V_22) {
 -			ret = value | SDHCI_CAN_DO_ADMA2;
 -			return ret;
 -		}
 +	if ((reg == SDHCI_CAPABILITIES) && (ret & SDHCI_CAN_DO_ADMA1)) {
 +		u32 tmp = in_be32(host->ioaddr + SDHCI_SLOT_INT_STATUS);
 +		tmp = (tmp & SDHCI_VENDOR_VER_MASK) >> SDHCI_VENDOR_VER_SHIFT;
 +		if (tmp > VENDOR_V_22)
 +			ret |= SDHCI_CAN_DO_ADMA2;
  	}
++<<<<<<< HEAD
 +
++=======
+ 	/*
+ 	 * The DAT[3:0] line signal levels and the CMD line signal level are
+ 	 * not compatible with standard SDHC register. The line signal levels
+ 	 * DAT[7:0] are at bits 31:24 and the command line signal level is at
+ 	 * bit 23. All other bits are the same as in the standard SDHC
+ 	 * register.
+ 	 */
+ 	if (spec_reg == SDHCI_PRESENT_STATE) {
+ 		ret = value & 0x000fffff;
+ 		ret |= (value >> 4) & SDHCI_DATA_LVL_MASK;
+ 		ret |= (value << 1) & SDHCI_CMD_LVL;
+ 		return ret;
+ 	}
+ 
+ 	ret = value;
++>>>>>>> b0921d5c9ed6 (mmc: sdhci-of-esdhc: fixup PRESENT_STATE read)
  	return ret;
  }
  
* Unmerged path drivers/mmc/host/sdhci-of-esdhc.c
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 2aa8067fc807..cfff733d8728 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -73,6 +73,7 @@
 #define  SDHCI_DATA_LVL_MASK	0x00F00000
 #define   SDHCI_DATA_LVL_SHIFT	20
 #define   SDHCI_DATA_0_LVL_MASK	0x00100000
+#define  SDHCI_CMD_LVL		0x01000000
 
 #define SDHCI_HOST_CONTROL	0x28
 #define  SDHCI_CTRL_LED		0x01
