scsi: replace "mq" with "first_chunk" in SG functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] replace "mq" with "first_chunk" in SG functions (David Milburn) [1384526 1389755 1366753 1374291 1383834]
Rebuild_FUZZ: 94.00%
commit-author Ming Lin <ming.l@ssi.samsung.com>
commit 22cc3d4c6f4c529f4bf17445c60893b13e7611fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/22cc3d4c.failed

Parameter "bool mq" is block driver specific.
Change it to "first_chunk" to make it more generic.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Ming Lin <ming.l@ssi.samsung.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 22cc3d4c6f4c529f4bf17445c60893b13e7611fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_lib.c
diff --cc drivers/scsi/scsi_lib.c
index f484f378d9a4,9675353770e9..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -594,34 -583,32 +594,52 @@@ static struct scatterlist *scsi_sg_allo
  	return mempool_alloc(sgp->pool, gfp_mask);
  }
  
++<<<<<<< HEAD
 +static void scsi_free_sgtable(struct scsi_data_buffer *sdb, bool mq)
 +{
 +	if (mq && sdb->table.orig_nents <= SCSI_MAX_SG_SEGMENTS)
 +		return;
 +	__sg_free_table(&sdb->table, SCSI_MAX_SG_SEGMENTS, mq, scsi_sg_free);
 +}
 +
 +static int scsi_alloc_sgtable(struct scsi_data_buffer *sdb, int nents,
 +			      gfp_t gfp_mask, bool mq)
++=======
+ static void scsi_free_sgtable(struct sg_table *table, bool first_chunk)
+ {
+ 	if (first_chunk && table->orig_nents <= SCSI_MAX_SG_SEGMENTS)
+ 		return;
+ 	__sg_free_table(table, SCSI_MAX_SG_SEGMENTS, first_chunk, scsi_sg_free);
+ }
+ 
+ static int scsi_alloc_sgtable(struct sg_table *table, int nents,
+ 		struct scatterlist *first_chunk)
++>>>>>>> 22cc3d4c6f4c (scsi: replace "mq" with "first_chunk" in SG functions)
  {
- 	struct scatterlist *first_chunk = NULL;
  	int ret;
  
  	BUG_ON(!nents);
  
- 	if (mq) {
+ 	if (first_chunk) {
  		if (nents <= SCSI_MAX_SG_SEGMENTS) {
 -			table->nents = table->orig_nents = nents;
 -			sg_init_table(table->sgl, nents);
 +			sdb->table.nents = sdb->table.orig_nents = nents;
 +			sg_init_table(sdb->table.sgl, nents);
  			return 0;
  		}
++<<<<<<< HEAD
 +		first_chunk = sdb->table.sgl;
++=======
++>>>>>>> 22cc3d4c6f4c (scsi: replace "mq" with "first_chunk" in SG functions)
  	}
  
 -	ret = __sg_alloc_table(table, nents, SCSI_MAX_SG_SEGMENTS,
 -			       first_chunk, GFP_ATOMIC, scsi_sg_alloc);
 +	ret = __sg_alloc_table(&sdb->table, nents, SCSI_MAX_SG_SEGMENTS,
 +			       first_chunk, gfp_mask, scsi_sg_alloc);
  	if (unlikely(ret))
++<<<<<<< HEAD
 +		scsi_free_sgtable(sdb, mq);
++=======
+ 		scsi_free_sgtable(table, (bool)first_chunk);
++>>>>>>> 22cc3d4c6f4c (scsi: replace "mq" with "first_chunk" in SG functions)
  	return ret;
  }
  
@@@ -1101,12 -1089,10 +1119,17 @@@ static int scsi_init_sgtable(struct req
  	/*
  	 * If sg table allocation fails, requeue request later.
  	 */
++<<<<<<< HEAD
 +	if (unlikely(scsi_alloc_sgtable(sdb, req->nr_phys_segments,
 +					gfp_mask, req->mq_ctx != NULL)))
++=======
+ 	if (unlikely(scsi_alloc_sgtable(&sdb->table, req->nr_phys_segments,
+ 					sdb->table.sgl)))
++>>>>>>> 22cc3d4c6f4c (scsi: replace "mq" with "first_chunk" in SG functions)
  		return BLKPREP_DEFER;
  
 +	req->buffer = NULL;
 +
  	/* 
  	 * Next, walk the list, and fill in the addresses and sizes of
  	 * each segment.
@@@ -1177,7 -1162,8 +1200,12 @@@ int scsi_init_io(struct scsi_cmnd *cmd
  
  		ivecs = blk_rq_count_integrity_sg(rq->q, rq->bio);
  
++<<<<<<< HEAD
 +		if (scsi_alloc_sgtable(prot_sdb, ivecs, gfp_mask, is_mq)) {
++=======
+ 		if (scsi_alloc_sgtable(&prot_sdb->table, ivecs,
+ 				prot_sdb->table.sgl)) {
++>>>>>>> 22cc3d4c6f4c (scsi: replace "mq" with "first_chunk" in SG functions)
  			error = BLKPREP_DEFER;
  			goto err_exit;
  		}
* Unmerged path drivers/scsi/scsi_lib.c
