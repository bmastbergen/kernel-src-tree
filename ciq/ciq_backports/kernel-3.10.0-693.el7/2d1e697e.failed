IB/mlx5: Add support to match inner packet fields

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Moses Reuben <mosesr@mellanox.com>
commit 2d1e697e9b716b8a692bc9c197e5f4ffd10d7307
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2d1e697e.failed

Add support to match packet fields which are tunneled,
i.e. support matching the header of the inner packet which is the result of
or bit operation of the original header and the IB_FLOW_SPEC_INNER type.

The combination of IB_FLOW_SPEC_INNER | IB_FLOW_SPEC_VXLAN_TUNNEL is not
needed to be checked, because the IB core has this check already.

	Signed-off-by: Moses Reuben <mosesr@mellanox.com>
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 2d1e697e9b716b8a692bc9c197e5f4ffd10d7307)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index f175e47d8d06,f7a299431e6c..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -1495,13 -1566,28 +1511,36 @@@ static void set_tos(void *outer_c, voi
  		   sizeof(filter.field))
  
  static int parse_flow_attr(u32 *match_c, u32 *match_v,
 -			   const union ib_flow_spec *ib_spec)
 -{
 +			   union ib_flow_spec *ib_spec)
 +{
++<<<<<<< HEAD
 +	void *outer_headers_c = MLX5_ADDR_OF(fte_match_param, match_c,
 +					     outer_headers);
 +	void *outer_headers_v = MLX5_ADDR_OF(fte_match_param, match_v,
 +					     outer_headers);
 +	switch (ib_spec->type) {
++=======
+ 	void *misc_params_c = MLX5_ADDR_OF(fte_match_param, match_c,
+ 					   misc_parameters);
+ 	void *misc_params_v = MLX5_ADDR_OF(fte_match_param, match_v,
+ 					   misc_parameters);
+ 	void *headers_c;
+ 	void *headers_v;
+ 
+ 	if (ib_spec->type & IB_FLOW_SPEC_INNER) {
+ 		headers_c = MLX5_ADDR_OF(fte_match_param, match_c,
+ 					 inner_headers);
+ 		headers_v = MLX5_ADDR_OF(fte_match_param, match_v,
+ 					 inner_headers);
+ 	} else {
+ 		headers_c = MLX5_ADDR_OF(fte_match_param, match_c,
+ 					 outer_headers);
+ 		headers_v = MLX5_ADDR_OF(fte_match_param, match_v,
+ 					 outer_headers);
+ 	}
+ 
+ 	switch (ib_spec->type & ~IB_FLOW_SPEC_INNER) {
++>>>>>>> 2d1e697e9b71 (IB/mlx5: Add support to match inner packet fields)
  	case IB_FLOW_SPEC_ETH:
  		if (FIELDS_NOT_SUPPORTED(ib_spec->eth.mask, LAST_ETH_FIELD))
  			return -ENOTSUPP;
@@@ -1607,6 -1693,20 +1646,23 @@@
  				    dst_ipv4_dst_ipv6.ipv6_layout.ipv6),
  		       &ib_spec->ipv6.val.dst_ip,
  		       sizeof(ib_spec->ipv6.val.dst_ip));
++<<<<<<< HEAD
++=======
+ 
+ 		set_tos(headers_c, headers_v,
+ 			ib_spec->ipv6.mask.traffic_class,
+ 			ib_spec->ipv6.val.traffic_class);
+ 
+ 		set_proto(headers_c, headers_v,
+ 			  ib_spec->ipv6.mask.next_hdr,
+ 			  ib_spec->ipv6.val.next_hdr);
+ 
+ 		set_flow_label(misc_params_c, misc_params_v,
+ 			       ntohl(ib_spec->ipv6.mask.flow_label),
+ 			       ntohl(ib_spec->ipv6.val.flow_label),
+ 			       ib_spec->type & IB_FLOW_SPEC_INNER);
+ 
++>>>>>>> 2d1e697e9b71 (IB/mlx5: Add support to match inner packet fields)
  		break;
  	case IB_FLOW_SPEC_TCP:
  		if (FIELDS_NOT_SUPPORTED(ib_spec->tcp_udp.mask,
* Unmerged path drivers/infiniband/hw/mlx5/main.c
