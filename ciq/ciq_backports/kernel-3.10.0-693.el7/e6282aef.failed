nvme: simplify stripe quirk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [nvme] simplify stripe quirk (David Milburn) [1384526 1389755 1366753 1374291 1383834]
Rebuild_FUZZ: 87.50%
commit-author Keith Busch <keith.busch@intel.com>
commit e6282aef7b89a11d26e731060c4409b7aac278bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e6282aef.failed

Some OEMs believe they own the Identify Controller vendor specific
region and will repurpose it with their own values. While not common,
we can't rely on the PCI VID:DID to tell use how to decode the field
we reserved for this as the stripe size so we need to do something else
for the list of devices using this quirk.

The field was supposed to allow flexibility on the device's back-end
striping, but it turned out that never materialized; the chunk is always
the same as MDTS in the products subscribing to this quirk, so this
patch removes the stripe_size field and sets the chunk to the max hw
transfer size for the devices using this quirk.

	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit e6282aef7b89a11d26e731060c4409b7aac278bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 0588703d149f,2fc86dc7a8df..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -866,11 -1193,12 +866,17 @@@ static void nvme_set_queue_limits(struc
  		blk_queue_max_hw_sectors(q, ctrl->max_hw_sectors);
  		blk_queue_max_segments(q, min_t(u32, max_segments, USHRT_MAX));
  	}
++<<<<<<< HEAD
 +	if (ctrl->stripe_size)
 +		blk_queue_chunk_sectors(q, ctrl->stripe_size >> 9);
++=======
+ 	if (ctrl->quirks & NVME_QUIRK_STRIPE_SIZE)
+ 		blk_queue_chunk_sectors(q, ctrl->max_hw_sectors);
+ 	blk_queue_virt_boundary(q, ctrl->page_size - 1);
++>>>>>>> e6282aef7b89 (nvme: simplify stripe quirk)
  	if (ctrl->vwc & NVME_CTRL_VWC_PRESENT)
 -		vwc = true;
 -	blk_queue_write_cache(q, vwc, vwc);
 +		blk_queue_flush(q, REQ_FLUSH | REQ_FUA);
 +	blk_queue_virt_boundary(q, ctrl->page_size - 1);
  }
  
  /*
@@@ -922,24 -1250,36 +928,11 @@@ int nvme_init_identify(struct nvme_ctr
  	ctrl->max_hw_sectors =
  		min_not_zero(ctrl->max_hw_sectors, max_hw_sectors);
  
- 	if ((ctrl->quirks & NVME_QUIRK_STRIPE_SIZE) && id->vs[3]) {
- 		unsigned int max_hw_sectors;
- 
- 		ctrl->stripe_size = 1 << (id->vs[3] + page_shift);
- 		max_hw_sectors = ctrl->stripe_size >> (page_shift - 9);
- 		if (ctrl->max_hw_sectors) {
- 			ctrl->max_hw_sectors = min(max_hw_sectors,
- 							ctrl->max_hw_sectors);
- 		} else {
- 			ctrl->max_hw_sectors = max_hw_sectors;
- 		}
- 	}
- 
  	nvme_set_queue_limits(ctrl, ctrl->admin_q);
 -	ctrl->sgls = le32_to_cpu(id->sgls);
 -	ctrl->kas = le16_to_cpu(id->kas);
 -
 -	if (ctrl->ops->is_fabrics) {
 -		ctrl->icdoff = le16_to_cpu(id->icdoff);
 -		ctrl->ioccsz = le32_to_cpu(id->ioccsz);
 -		ctrl->iorcsz = le32_to_cpu(id->iorcsz);
 -		ctrl->maxcmd = le16_to_cpu(id->maxcmd);
 -
 -		/*
 -		 * In fabrics we need to verify the cntlid matches the
 -		 * admin connect
 -		 */
 -		if (ctrl->cntlid != le16_to_cpu(id->cntlid))
 -			ret = -EINVAL;
 -
 -		if (!ctrl->opts->discovery_nqn && !ctrl->kas) {
 -			dev_err(ctrl->dev,
 -				"keep-alive support is mandatory for fabrics\n");
 -			ret = -EINVAL;
 -		}
 -	} else {
 -		ctrl->cntlid = le16_to_cpu(id->cntlid);
 -	}
  
  	kfree(id);
 -	return ret;
 +	return 0;
  }
 -EXPORT_SYMBOL_GPL(nvme_init_identify);
  
  static int nvme_dev_open(struct inode *inode, struct file *file)
  {
* Unmerged path drivers/nvme/host/core.c
diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h
index ddd7fc3f3881..d18a341fa020 100644
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@ -98,7 +98,6 @@ struct nvme_ctrl {
 
 	u32 page_size;
 	u32 max_hw_sectors;
-	u32 stripe_size;
 	u16 oncs;
 	u16 vid;
 	atomic_t abort_limit;
