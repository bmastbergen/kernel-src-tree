HID: wacom: make sure touch arbitration is applied consistently

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: make sure touch arbitration is applied consistently (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.87%
commit-author Ping Cheng <pinglinux@gmail.com>
commit 9b61aa864ab6c2e12e463559eb83cf83cbd06889
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9b61aa86.failed

stylus_in_proximity is used to make sure no touch event is sent while pen is in
proximity. touch_down is used to make sure a touch up event is sent when pen
comes into proximity while touch is down.

Two touch routines didn't store touch_down. One touch routine forgot to check
stylus_in_proximity before sending touch events. This patch fixes those issues.

	Signed-off-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 9b61aa864ab6c2e12e463559eb83cf83cbd06889)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index e76dca5e56b8,6d490f602cfd..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -880,11 -1037,12 +880,16 @@@ static int wacom_24hdt_irq(struct wacom
  	if (current_num_contacts)
  		wacom->num_contacts_left = current_num_contacts;
  
 -	/* There are at most 4 contacts per packet */
 -	contacts_to_send = min(4, wacom->num_contacts_left);
 +	contacts_to_send = min(num_contacts_left, wacom->num_contacts_left);
  
  	for (i = 0; i < contacts_to_send; i++) {
++<<<<<<< HEAD
 +		int offset = (byte_per_packet * i) + 1;
 +		bool touch = data[offset] & 0x1 && !wacom->shared->stylus_in_proximity;
++=======
+ 		int offset = (WACOM_BYTES_PER_24HDT_PACKET * i) + 1;
+ 		bool touch = (data[offset] & 0x1) && !wacom->shared->stylus_in_proximity;
++>>>>>>> 9b61aa864ab6 (HID: wacom: make sure touch arbitration is applied consistently)
  		int slot = input_mt_get_slot_by_key(input, data[offset + 1]);
  
  		if (slot < 0)
@@@ -947,8 -1101,8 +953,13 @@@ static int wacom_mt_touch(struct wacom_
  
  	for (i = 0; i < contacts_to_send; i++) {
  		int offset = (WACOM_BYTES_PER_MT_PACKET + x_offset) * i + 3;
++<<<<<<< HEAD
 +		bool touch = data[offset] & 0x1;
 +		int id = le16_to_cpup((__le16 *)&data[offset + 1]);
++=======
+ 		bool touch = (data[offset] & 0x1) && !wacom->shared->stylus_in_proximity;
+ 		int id = get_unaligned_le16(&data[offset + 1]);
++>>>>>>> 9b61aa864ab6 (HID: wacom: make sure touch arbitration is applied consistently)
  		int slot = input_mt_get_slot_by_key(input, id);
  
  		if (slot < 0)
* Unmerged path drivers/hid/wacom_wac.c
