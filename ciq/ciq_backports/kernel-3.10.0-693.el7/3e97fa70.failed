gre/ipip: use be16 variants of netlink functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] gre: use be16 variants of netlink functions (Jakub Sitnicki) [1369158]
Rebuild_FUZZ: 94.51%
commit-author Sabrina Dubroca <sd@queasysnail.net>
commit 3e97fa7059c19f7cc2566dfb30fe9282f6f1e673
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3e97fa70.failed

encap.sport and encap.dport are __be16, use nla_{get,put}_be16 instead
of nla_{get,put}_u16.

Fixes the sparse warnings:

warning: incorrect type in assignment (different base types)
   expected restricted __be32 [addressable] [usertype] o_key
   got restricted __be16 [addressable] [usertype] i_flags
warning: incorrect type in assignment (different base types)
   expected restricted __be16 [usertype] sport
   got unsigned short
warning: incorrect type in assignment (different base types)
   expected restricted __be16 [usertype] dport
   got unsigned short
warning: incorrect type in argument 3 (different base types)
   expected unsigned short [unsigned] [usertype] value
   got restricted __be16 [usertype] sport
warning: incorrect type in argument 3 (different base types)
   expected unsigned short [unsigned] [usertype] value
   got restricted __be16 [usertype] dport

	Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3e97fa7059c19f7cc2566dfb30fe9282f6f1e673)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ipip.c
diff --cc net/ipv4/ipip.c
index 8a09cef5a5aa,915d215a7d14..000000000000
--- a/net/ipv4/ipip.c
+++ b/net/ipv4/ipip.c
@@@ -342,6 -343,40 +342,43 @@@ static void ipip_netlink_parms(struct n
  		parms->iph.frag_off = htons(IP_DF);
  }
  
++<<<<<<< HEAD
++=======
+ /* This function returns true when ENCAP attributes are present in the nl msg */
+ static bool ipip_netlink_encap_parms(struct nlattr *data[],
+ 				     struct ip_tunnel_encap *ipencap)
+ {
+ 	bool ret = false;
+ 
+ 	memset(ipencap, 0, sizeof(*ipencap));
+ 
+ 	if (!data)
+ 		return ret;
+ 
+ 	if (data[IFLA_IPTUN_ENCAP_TYPE]) {
+ 		ret = true;
+ 		ipencap->type = nla_get_u16(data[IFLA_IPTUN_ENCAP_TYPE]);
+ 	}
+ 
+ 	if (data[IFLA_IPTUN_ENCAP_FLAGS]) {
+ 		ret = true;
+ 		ipencap->flags = nla_get_u16(data[IFLA_IPTUN_ENCAP_FLAGS]);
+ 	}
+ 
+ 	if (data[IFLA_IPTUN_ENCAP_SPORT]) {
+ 		ret = true;
+ 		ipencap->sport = nla_get_be16(data[IFLA_IPTUN_ENCAP_SPORT]);
+ 	}
+ 
+ 	if (data[IFLA_IPTUN_ENCAP_DPORT]) {
+ 		ret = true;
+ 		ipencap->dport = nla_get_be16(data[IFLA_IPTUN_ENCAP_DPORT]);
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 3e97fa7059c1 (gre/ipip: use be16 variants of netlink functions)
  static int ipip_newlink(struct net *src_net, struct net_device *dev,
  			struct nlattr *tb[], struct nlattr *data[])
  {
@@@ -396,6 -457,17 +433,20 @@@ static int ipip_fill_info(struct sk_buf
  	    nla_put_u8(skb, IFLA_IPTUN_PMTUDISC,
  		       !!(parm->iph.frag_off & htons(IP_DF))))
  		goto nla_put_failure;
++<<<<<<< HEAD
++=======
+ 
+ 	if (nla_put_u16(skb, IFLA_IPTUN_ENCAP_TYPE,
+ 			tunnel->encap.type) ||
+ 	    nla_put_be16(skb, IFLA_IPTUN_ENCAP_SPORT,
+ 			 tunnel->encap.sport) ||
+ 	    nla_put_be16(skb, IFLA_IPTUN_ENCAP_DPORT,
+ 			 tunnel->encap.dport) ||
+ 	    nla_put_u16(skb, IFLA_IPTUN_ENCAP_FLAGS,
+ 			tunnel->encap.flags))
+ 		goto nla_put_failure;
+ 
++>>>>>>> 3e97fa7059c1 (gre/ipip: use be16 variants of netlink functions)
  	return 0;
  
  nla_put_failure:
diff --git a/net/ipv4/ip_gre.c b/net/ipv4/ip_gre.c
index 8396b8010518..e9a6ef3ca11d 100644
--- a/net/ipv4/ip_gre.c
+++ b/net/ipv4/ip_gre.c
@@ -1047,12 +1047,12 @@ static bool ipgre_netlink_encap_parms(struct nlattr *data[],
 
 	if (data[IFLA_GRE_ENCAP_SPORT]) {
 		ret = true;
-		ipencap->sport = nla_get_u16(data[IFLA_GRE_ENCAP_SPORT]);
+		ipencap->sport = nla_get_be16(data[IFLA_GRE_ENCAP_SPORT]);
 	}
 
 	if (data[IFLA_GRE_ENCAP_DPORT]) {
 		ret = true;
-		ipencap->dport = nla_get_u16(data[IFLA_GRE_ENCAP_DPORT]);
+		ipencap->dport = nla_get_be16(data[IFLA_GRE_ENCAP_DPORT]);
 	}
 
 	return ret;
@@ -1178,10 +1178,10 @@ static int ipgre_fill_info(struct sk_buff *skb, const struct net_device *dev)
 
 	if (nla_put_u16(skb, IFLA_GRE_ENCAP_TYPE,
 			t->encap.type) ||
-	    nla_put_u16(skb, IFLA_GRE_ENCAP_SPORT,
-			t->encap.sport) ||
-	    nla_put_u16(skb, IFLA_GRE_ENCAP_DPORT,
-			t->encap.dport) ||
+	    nla_put_be16(skb, IFLA_GRE_ENCAP_SPORT,
+			 t->encap.sport) ||
+	    nla_put_be16(skb, IFLA_GRE_ENCAP_DPORT,
+			 t->encap.dport) ||
 	    nla_put_u16(skb, IFLA_GRE_ENCAP_FLAGS,
 			t->encap.dport))
 		goto nla_put_failure;
* Unmerged path net/ipv4/ipip.c
