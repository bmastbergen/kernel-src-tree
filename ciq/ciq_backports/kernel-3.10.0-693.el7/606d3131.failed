mmc: sdhci: Rename sdhci_set_power() to sdhci_set_power_noreg()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mmc] sdhci: Rename sdhci_set_power() to sdhci_set_power_noreg() (Don Zickus) [1430497]
Rebuild_FUZZ: 95.87%
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 606d313124094d87050896a10894200cdd2b0514
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/606d3131.failed

Unlike other cases, sdhci_set_power() does not reflect the default
implementation of the ->set_power() callback. Rename it and create
sdhci_set_power() that is the default implementation.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Jisheng Zhang <jszhang@marvell.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 606d313124094d87050896a10894200cdd2b0514)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci-pxav3.c
#	drivers/mmc/host/sdhci.c
#	drivers/mmc/host/sdhci.h
diff --cc drivers/mmc/host/sdhci-pxav3.c
index 1ae358e0662d,d0f5c05fbc19..000000000000
--- a/drivers/mmc/host/sdhci-pxav3.c
+++ b/drivers/mmc/host/sdhci-pxav3.c
@@@ -163,8 -307,27 +163,30 @@@ static int pxav3_set_uhs_signaling(stru
  	dev_dbg(mmc_dev(host->mmc),
  		"%s uhs = %d, ctrl_2 = %04X\n",
  		__func__, uhs, ctrl_2);
 -}
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ static void pxav3_set_power(struct sdhci_host *host, unsigned char mode,
+ 			    unsigned short vdd)
+ {
+ 	struct mmc_host *mmc = host->mmc;
+ 	u8 pwr = host->pwr;
+ 
+ 	sdhci_set_power_noreg(host, mode, vdd);
+ 
+ 	if (host->pwr == pwr)
+ 		return;
+ 
+ 	if (host->pwr == 0)
+ 		vdd = 0;
+ 
+ 	if (!IS_ERR(mmc->supply.vmmc)) {
+ 		spin_unlock_irq(&host->lock);
+ 		mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);
+ 		spin_lock_irq(&host->lock);
+ 	}
++>>>>>>> 606d31312409 (mmc: sdhci: Rename sdhci_set_power() to sdhci_set_power_noreg())
  }
  
  static const struct sdhci_ops pxav3_sdhci_ops = {
diff --cc drivers/mmc/host/sdhci.c
index 1da88535b772,223a91e039dc..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -1379,10 -1379,24 +1379,27 @@@ void sdhci_set_clock(struct sdhci_host 
  }
  EXPORT_SYMBOL_GPL(sdhci_set_clock);
  
 -static void sdhci_set_power_reg(struct sdhci_host *host, unsigned char mode,
 -				unsigned short vdd)
 +static void sdhci_set_power(struct sdhci_host *host, unsigned char mode,
 +			    unsigned short vdd)
  {
  	struct mmc_host *mmc = host->mmc;
++<<<<<<< HEAD
++=======
+ 
+ 	spin_unlock_irq(&host->lock);
+ 	mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);
+ 	spin_lock_irq(&host->lock);
+ 
+ 	if (mode != MMC_POWER_OFF)
+ 		sdhci_writeb(host, SDHCI_POWER_ON, SDHCI_POWER_CONTROL);
+ 	else
+ 		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
+ }
+ 
+ void sdhci_set_power_noreg(struct sdhci_host *host, unsigned char mode,
+ 			   unsigned short vdd)
+ {
++>>>>>>> 606d31312409 (mmc: sdhci: Rename sdhci_set_power() to sdhci_set_power_noreg())
  	u8 pwr = 0;
  
  	if (mode != MMC_POWER_OFF) {
@@@ -1445,13 -1458,18 +1462,27 @@@
  		if (host->quirks & SDHCI_QUIRK_DELAY_AFTER_POWER)
  			mdelay(10);
  	}
++<<<<<<< HEAD
 +
 +	if (!IS_ERR(mmc->supply.vmmc)) {
 +		spin_unlock_irq(&host->lock);
 +		mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);
 +		spin_lock_irq(&host->lock);
 +	}
++=======
+ }
+ EXPORT_SYMBOL_GPL(sdhci_set_power_noreg);
+ 
+ void sdhci_set_power(struct sdhci_host *host, unsigned char mode,
+ 		     unsigned short vdd)
+ {
+ 	if (IS_ERR(host->mmc->supply.vmmc))
+ 		sdhci_set_power_noreg(host, mode, vdd);
+ 	else
+ 		sdhci_set_power_reg(host, mode, vdd);
++>>>>>>> 606d31312409 (mmc: sdhci: Rename sdhci_set_power() to sdhci_set_power_noreg())
  }
+ EXPORT_SYMBOL_GPL(sdhci_set_power);
  
  /*****************************************************************************\
   *                                                                           *
@@@ -1592,7 -1610,10 +1623,14 @@@ static void sdhci_set_ios(struct mmc_ho
  		}
  	}
  
++<<<<<<< HEAD
 +	sdhci_set_power(host, ios->power_mode, ios->vdd);
++=======
+ 	if (host->ops->set_power)
+ 		host->ops->set_power(host, ios->power_mode, ios->vdd);
+ 	else
+ 		sdhci_set_power(host, ios->power_mode, ios->vdd);
++>>>>>>> 606d31312409 (mmc: sdhci: Rename sdhci_set_power() to sdhci_set_power_noreg())
  
  	if (host->ops->platform_send_init_74_clocks)
  		host->ops->platform_send_init_74_clocks(host, ios->power_mode);
diff --cc drivers/mmc/host/sdhci.h
index 2aa8067fc807,766df17fb7eb..000000000000
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@@ -677,6 -681,10 +677,13 @@@ static inline bool sdhci_sdio_irq_enabl
  u16 sdhci_calc_clk(struct sdhci_host *host, unsigned int clock,
  		   unsigned int *actual_clock);
  void sdhci_set_clock(struct sdhci_host *host, unsigned int clock);
++<<<<<<< HEAD
++=======
+ void sdhci_set_power(struct sdhci_host *host, unsigned char mode,
+ 		     unsigned short vdd);
+ void sdhci_set_power_noreg(struct sdhci_host *host, unsigned char mode,
+ 			   unsigned short vdd);
++>>>>>>> 606d31312409 (mmc: sdhci: Rename sdhci_set_power() to sdhci_set_power_noreg())
  void sdhci_set_bus_width(struct sdhci_host *host, int width);
  void sdhci_reset(struct sdhci_host *host, u8 mask);
  void sdhci_set_uhs_signaling(struct sdhci_host *host, unsigned timing);
* Unmerged path drivers/mmc/host/sdhci-pxav3.c
* Unmerged path drivers/mmc/host/sdhci.c
* Unmerged path drivers/mmc/host/sdhci.h
