perf/core: Fix concurrent sys_perf_event_open() vs. 'move_group' race

jira LE-1907
cve CVE-2017-6001
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 321027c1fe77f892f4ea07846aeae08cefbbb290
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/321027c1.failed

Di Shen reported a race between two concurrent sys_perf_event_open()
calls where both try and move the same pre-existing software group
into a hardware context.

The problem is exactly that described in commit:

  f63a8daa5812 ("perf: Fix event->ctx locking")

... where, while we wait for a ctx->mutex acquisition, the event->ctx
relation can have changed under us.

That very same commit failed to recognise sys_perf_event_context() as an
external access vector to the events and thereby didn't apply the
established locking rules correctly.

So while one sys_perf_event_open() call is stuck waiting on
mutex_lock_double(), the other (which owns said locks) moves the group
about. So by the time the former sys_perf_event_open() acquires the
locks, the context we've acquired is stale (and possibly dead).

Apply the established locking rules as per perf_event_ctx_lock_nested()
to the mutex_lock_double() for the 'move_group' case. This obviously means
we need to validate state after we acquire the locks.

	Reported-by: Di Shen (Keen Lab)
	Tested-by: John Dias <joaodias@google.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Min Chong <mchong@google.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
Fixes: f63a8daa5812 ("perf: Fix event->ctx locking")
Link: http://lkml.kernel.org/r/20170106131444.GZ3174@twins.programming.kicks-ass.net
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 321027c1fe77f892f4ea07846aeae08cefbbb290)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/core.c
diff --cc kernel/events/core.c
index 44be586a54d8,cbc5937265da..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -8489,6 -9492,74 +8489,77 @@@ static void mutex_lock_double(struct mu
  	mutex_lock_nested(b, SINGLE_DEPTH_NESTING);
  }
  
++<<<<<<< HEAD
++=======
+ static int perf_event_set_clock(struct perf_event *event, clockid_t clk_id)
+ {
+ 	bool nmi_safe = false;
+ 
+ 	switch (clk_id) {
+ 	case CLOCK_MONOTONIC:
+ 		event->clock = &ktime_get_mono_fast_ns;
+ 		nmi_safe = true;
+ 		break;
+ 
+ 	case CLOCK_MONOTONIC_RAW:
+ 		event->clock = &ktime_get_raw_fast_ns;
+ 		nmi_safe = true;
+ 		break;
+ 
+ 	case CLOCK_REALTIME:
+ 		event->clock = &ktime_get_real_ns;
+ 		break;
+ 
+ 	case CLOCK_BOOTTIME:
+ 		event->clock = &ktime_get_boot_ns;
+ 		break;
+ 
+ 	case CLOCK_TAI:
+ 		event->clock = &ktime_get_tai_ns;
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!nmi_safe && !(event->pmu->capabilities & PERF_PMU_CAP_NO_NMI))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Variation on perf_event_ctx_lock_nested(), except we take two context
+  * mutexes.
+  */
+ static struct perf_event_context *
+ __perf_event_ctx_lock_double(struct perf_event *group_leader,
+ 			     struct perf_event_context *ctx)
+ {
+ 	struct perf_event_context *gctx;
+ 
+ again:
+ 	rcu_read_lock();
+ 	gctx = READ_ONCE(group_leader->ctx);
+ 	if (!atomic_inc_not_zero(&gctx->refcount)) {
+ 		rcu_read_unlock();
+ 		goto again;
+ 	}
+ 	rcu_read_unlock();
+ 
+ 	mutex_lock_double(&gctx->mutex, &ctx->mutex);
+ 
+ 	if (group_leader->ctx != gctx) {
+ 		mutex_unlock(&ctx->mutex);
+ 		mutex_unlock(&gctx->mutex);
+ 		put_ctx(gctx);
+ 		goto again;
+ 	}
+ 
+ 	return gctx;
+ }
+ 
++>>>>>>> 321027c1fe77 (perf/core: Fix concurrent sys_perf_event_open() vs. 'move_group' race)
  /**
   * sys_perf_event_open - open a performance event, associate it to a task/cpu
   *
@@@ -8804,9 -9929,14 +8894,9 @@@ SYSCALL_DEFINE5(perf_event_open
  	perf_unpin_context(ctx);
  
  	if (move_group)
- 		mutex_unlock(&gctx->mutex);
+ 		perf_event_ctx_unlock(group_leader, gctx);
  	mutex_unlock(&ctx->mutex);
  
 -	if (task) {
 -		mutex_unlock(&task->signal->cred_guard_mutex);
 -		put_task_struct(task);
 -	}
 -
  	put_online_cpus();
  
  	mutex_lock(&current->perf_event_mutex);
* Unmerged path kernel/events/core.c
