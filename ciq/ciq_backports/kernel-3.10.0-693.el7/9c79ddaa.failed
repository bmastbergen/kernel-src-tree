qed*: Add support for QL41xxx adapters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit 9c79ddaa0f962d1f26537a670b0652ff509a6fe0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9c79ddaa.failed

This adds the necessary infrastructure changes for initializing
and working with the new series of QL41xxx adapaters.

It also adds 2 new PCI device-IDs to qede:
  - 0x8070 for QL41xxx PFs
  - 0x8090 for VFs spawning from QL41xxx PFs

	Signed-off-by: Tomer Tayar <Tomer.Tayar@cavium.com>
	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9c79ddaa0f962d1f26537a670b0652ff509a6fe0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_dev.c
#	drivers/net/ethernet/qlogic/qed/qed_ptp.c
#	drivers/net/ethernet/qlogic/qed/qed_reg_addr.h
#	drivers/net/ethernet/qlogic/qede/qede_main.c
#	include/linux/qed/qed_if.h
diff --cc drivers/net/ethernet/qlogic/qed/qed_dev.c
index dd5a058891f9,bd4f43ffb5a1..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@@ -1468,47 -1585,252 +1496,291 @@@ static void qed_hw_set_feat(struct qed_
  		   RESC_NUM(p_hwfn, QED_SB), num_features);
  }
  
++<<<<<<< HEAD
 +static int qed_hw_get_resc(struct qed_hwfn *p_hwfn)
 +{
 +	u8 enabled_func_idx = p_hwfn->enabled_func_idx;
 +	u32 *resc_start = p_hwfn->hw_info.resc_start;
 +	u8 num_funcs = p_hwfn->num_funcs_on_engine;
 +	u32 *resc_num = p_hwfn->hw_info.resc_num;
 +	struct qed_sb_cnt_info sb_cnt_info;
 +	int i, max_vf_vlan_filters;
++=======
+ static enum resource_id_enum qed_hw_get_mfw_res_id(enum qed_resources res_id)
+ {
+ 	enum resource_id_enum mfw_res_id = RESOURCE_NUM_INVALID;
+ 
+ 	switch (res_id) {
+ 	case QED_SB:
+ 		mfw_res_id = RESOURCE_NUM_SB_E;
+ 		break;
+ 	case QED_L2_QUEUE:
+ 		mfw_res_id = RESOURCE_NUM_L2_QUEUE_E;
+ 		break;
+ 	case QED_VPORT:
+ 		mfw_res_id = RESOURCE_NUM_VPORT_E;
+ 		break;
+ 	case QED_RSS_ENG:
+ 		mfw_res_id = RESOURCE_NUM_RSS_ENGINES_E;
+ 		break;
+ 	case QED_PQ:
+ 		mfw_res_id = RESOURCE_NUM_PQ_E;
+ 		break;
+ 	case QED_RL:
+ 		mfw_res_id = RESOURCE_NUM_RL_E;
+ 		break;
+ 	case QED_MAC:
+ 	case QED_VLAN:
+ 		/* Each VFC resource can accommodate both a MAC and a VLAN */
+ 		mfw_res_id = RESOURCE_VFC_FILTER_E;
+ 		break;
+ 	case QED_ILT:
+ 		mfw_res_id = RESOURCE_ILT_E;
+ 		break;
+ 	case QED_LL2_QUEUE:
+ 		mfw_res_id = RESOURCE_LL2_QUEUE_E;
+ 		break;
+ 	case QED_RDMA_CNQ_RAM:
+ 	case QED_CMDQS_CQS:
+ 		/* CNQ/CMDQS are the same resource */
+ 		mfw_res_id = RESOURCE_CQS_E;
+ 		break;
+ 	case QED_RDMA_STATS_QUEUE:
+ 		mfw_res_id = RESOURCE_RDMA_STATS_QUEUE_E;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return mfw_res_id;
+ }
+ 
+ static u32 qed_hw_get_dflt_resc_num(struct qed_hwfn *p_hwfn,
+ 				    enum qed_resources res_id)
+ {
+ 	u8 num_funcs = p_hwfn->num_funcs_on_engine;
+ 	bool b_ah = QED_IS_AH(p_hwfn->cdev);
+ 	struct qed_sb_cnt_info sb_cnt_info;
+ 	u32 dflt_resc_num = 0;
+ 
+ 	switch (res_id) {
+ 	case QED_SB:
+ 		memset(&sb_cnt_info, 0, sizeof(sb_cnt_info));
+ 		qed_int_get_num_sbs(p_hwfn, &sb_cnt_info);
+ 		dflt_resc_num = sb_cnt_info.sb_cnt;
+ 		break;
+ 	case QED_L2_QUEUE:
+ 		dflt_resc_num = (b_ah ? MAX_NUM_L2_QUEUES_K2
+ 				      : MAX_NUM_L2_QUEUES_BB) / num_funcs;
+ 		break;
+ 	case QED_VPORT:
+ 		dflt_resc_num = MAX_NUM_VPORTS_BB / num_funcs;
+ 		dflt_resc_num = (b_ah ? MAX_NUM_VPORTS_K2
+ 				      : MAX_NUM_VPORTS_BB) / num_funcs;
+ 		break;
+ 	case QED_RSS_ENG:
+ 		dflt_resc_num = (b_ah ? ETH_RSS_ENGINE_NUM_K2
+ 				      : ETH_RSS_ENGINE_NUM_BB) / num_funcs;
+ 		break;
+ 	case QED_PQ:
+ 		/* The granularity of the PQs is 8 */
+ 		dflt_resc_num = (b_ah ? MAX_QM_TX_QUEUES_K2
+ 				      : MAX_QM_TX_QUEUES_BB) / num_funcs;
+ 		dflt_resc_num &= ~0x7;
+ 		break;
+ 	case QED_RL:
+ 		dflt_resc_num = MAX_QM_GLOBAL_RLS / num_funcs;
+ 		break;
+ 	case QED_MAC:
+ 	case QED_VLAN:
+ 		/* Each VFC resource can accommodate both a MAC and a VLAN */
+ 		dflt_resc_num = ETH_NUM_MAC_FILTERS / num_funcs;
+ 		break;
+ 	case QED_ILT:
+ 		dflt_resc_num = (b_ah ? PXP_NUM_ILT_RECORDS_K2
+ 				      : PXP_NUM_ILT_RECORDS_BB) / num_funcs;
+ 		break;
+ 	case QED_LL2_QUEUE:
+ 		dflt_resc_num = MAX_NUM_LL2_RX_QUEUES / num_funcs;
+ 		break;
+ 	case QED_RDMA_CNQ_RAM:
+ 	case QED_CMDQS_CQS:
+ 		/* CNQ/CMDQS are the same resource */
+ 		dflt_resc_num = NUM_OF_CMDQS_CQS / num_funcs;
+ 		break;
+ 	case QED_RDMA_STATS_QUEUE:
+ 		dflt_resc_num = (b_ah ? RDMA_NUM_STATISTIC_COUNTERS_K2
+ 				      : RDMA_NUM_STATISTIC_COUNTERS_BB) /
+ 				num_funcs;
+ 
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return dflt_resc_num;
+ }
+ 
+ static const char *qed_hw_get_resc_name(enum qed_resources res_id)
+ {
+ 	switch (res_id) {
+ 	case QED_SB:
+ 		return "SB";
+ 	case QED_L2_QUEUE:
+ 		return "L2_QUEUE";
+ 	case QED_VPORT:
+ 		return "VPORT";
+ 	case QED_RSS_ENG:
+ 		return "RSS_ENG";
+ 	case QED_PQ:
+ 		return "PQ";
+ 	case QED_RL:
+ 		return "RL";
+ 	case QED_MAC:
+ 		return "MAC";
+ 	case QED_VLAN:
+ 		return "VLAN";
+ 	case QED_RDMA_CNQ_RAM:
+ 		return "RDMA_CNQ_RAM";
+ 	case QED_ILT:
+ 		return "ILT";
+ 	case QED_LL2_QUEUE:
+ 		return "LL2_QUEUE";
+ 	case QED_CMDQS_CQS:
+ 		return "CMDQS_CQS";
+ 	case QED_RDMA_STATS_QUEUE:
+ 		return "RDMA_STATS_QUEUE";
+ 	default:
+ 		return "UNKNOWN_RESOURCE";
+ 	}
+ }
+ 
+ static int qed_hw_set_resc_info(struct qed_hwfn *p_hwfn,
+ 				enum qed_resources res_id)
+ {
+ 	u32 dflt_resc_num = 0, dflt_resc_start = 0, mcp_resp, mcp_param;
+ 	u32 *p_resc_num, *p_resc_start;
+ 	struct resource_info resc_info;
+ 	int rc;
+ 
+ 	p_resc_num = &RESC_NUM(p_hwfn, res_id);
+ 	p_resc_start = &RESC_START(p_hwfn, res_id);
+ 
+ 	/* Default values assumes that each function received equal share */
+ 	dflt_resc_num = qed_hw_get_dflt_resc_num(p_hwfn, res_id);
+ 	if (!dflt_resc_num) {
+ 		DP_ERR(p_hwfn,
+ 		       "Failed to get default amount for resource %d [%s]\n",
+ 		       res_id, qed_hw_get_resc_name(res_id));
+ 		return -EINVAL;
+ 	}
+ 	dflt_resc_start = dflt_resc_num * p_hwfn->enabled_func_idx;
+ 
+ 	memset(&resc_info, 0, sizeof(resc_info));
+ 	resc_info.res_id = qed_hw_get_mfw_res_id(res_id);
+ 	if (resc_info.res_id == RESOURCE_NUM_INVALID) {
+ 		DP_ERR(p_hwfn,
+ 		       "Failed to match resource %d [%s] with the MFW resources\n",
+ 		       res_id, qed_hw_get_resc_name(res_id));
+ 		return -EINVAL;
+ 	}
+ 
+ 	rc = qed_mcp_get_resc_info(p_hwfn, p_hwfn->p_main_ptt, &resc_info,
+ 				   &mcp_resp, &mcp_param);
+ 	if (rc) {
+ 		DP_NOTICE(p_hwfn,
+ 			  "MFW response failure for an allocation request for resource %d [%s]\n",
+ 			  res_id, qed_hw_get_resc_name(res_id));
+ 		return rc;
+ 	}
+ 
+ 	/* Default driver values are applied in the following cases:
+ 	 * - The resource allocation MB command is not supported by the MFW
+ 	 * - There is an internal error in the MFW while processing the request
+ 	 * - The resource ID is unknown to the MFW
+ 	 */
+ 	if (mcp_resp != FW_MSG_CODE_RESOURCE_ALLOC_OK &&
+ 	    mcp_resp != FW_MSG_CODE_RESOURCE_ALLOC_DEPRECATED) {
+ 		DP_NOTICE(p_hwfn,
+ 			  "Resource %d [%s]: No allocation info was received [mcp_resp 0x%x]. Applying default values [num %d, start %d].\n",
+ 			  res_id,
+ 			  qed_hw_get_resc_name(res_id),
+ 			  mcp_resp, dflt_resc_num, dflt_resc_start);
+ 		*p_resc_num = dflt_resc_num;
+ 		*p_resc_start = dflt_resc_start;
+ 		goto out;
+ 	}
+ 
+ 	/* Special handling for status blocks; Would be revised in future */
+ 	if (res_id == QED_SB) {
+ 		resc_info.size -= 1;
+ 		resc_info.offset -= p_hwfn->enabled_func_idx;
+ 	}
+ 
+ 	*p_resc_num = resc_info.size;
+ 	*p_resc_start = resc_info.offset;
+ 
+ out:
+ 	/* PQs have to divide by 8 [that's the HW granularity].
+ 	 * Reduce number so it would fit.
+ 	 */
+ 	if ((res_id == QED_PQ) && ((*p_resc_num % 8) || (*p_resc_start % 8))) {
+ 		DP_INFO(p_hwfn,
+ 			"PQs need to align by 8; Number %08x --> %08x, Start %08x --> %08x\n",
+ 			*p_resc_num,
+ 			(*p_resc_num) & ~0x7,
+ 			*p_resc_start, (*p_resc_start) & ~0x7);
+ 		*p_resc_num &= ~0x7;
+ 		*p_resc_start &= ~0x7;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int qed_hw_get_resc(struct qed_hwfn *p_hwfn)
+ {
+ 	bool b_ah = QED_IS_AH(p_hwfn->cdev);
+ 	u8 res_id;
+ 	int rc;
++>>>>>>> 9c79ddaa0f96 (qed*: Add support for QL41xxx adapters)
  
 -	for (res_id = 0; res_id < QED_MAX_RESC; res_id++) {
 -		rc = qed_hw_set_resc_info(p_hwfn, res_id);
 -		if (rc)
 -			return rc;
 -	}
 +	memset(&sb_cnt_info, 0, sizeof(sb_cnt_info));
 +
 +#ifdef CONFIG_QED_SRIOV
 +	max_vf_vlan_filters = QED_ETH_MAX_VF_NUM_VLAN_FILTERS;
 +#else
 +	max_vf_vlan_filters = 0;
 +#endif
 +
 +	qed_int_get_num_sbs(p_hwfn, &sb_cnt_info);
 +
 +	resc_num[QED_SB] = min_t(u32,
 +				 (MAX_SB_PER_PATH_BB / num_funcs),
 +				 sb_cnt_info.sb_cnt);
 +	resc_num[QED_L2_QUEUE] = MAX_NUM_L2_QUEUES_BB / num_funcs;
 +	resc_num[QED_VPORT] = MAX_NUM_VPORTS_BB / num_funcs;
 +	resc_num[QED_RSS_ENG] = ETH_RSS_ENGINE_NUM_BB / num_funcs;
 +	resc_num[QED_PQ] = MAX_QM_TX_QUEUES_BB / num_funcs;
 +	resc_num[QED_RL] = min_t(u32, 64, resc_num[QED_VPORT]);
 +	resc_num[QED_MAC] = ETH_NUM_MAC_FILTERS / num_funcs;
 +	resc_num[QED_VLAN] = (ETH_NUM_VLAN_FILTERS - 1 /*For vlan0*/) /
 +			     num_funcs;
 +	resc_num[QED_ILT] = PXP_NUM_ILT_RECORDS_BB / num_funcs;
 +	resc_num[QED_LL2_QUEUE] = MAX_NUM_LL2_RX_QUEUES / num_funcs;
 +	resc_num[QED_RDMA_CNQ_RAM] = NUM_OF_CMDQS_CQS / num_funcs;
 +	resc_num[QED_RDMA_STATS_QUEUE] = RDMA_NUM_STATISTIC_COUNTERS_BB /
 +					 num_funcs;
 +
 +	for (i = 0; i < QED_MAX_RESC; i++)
 +		resc_start[i] = resc_num[i] * enabled_func_idx;
  
  	/* Sanity for ILT */
++<<<<<<< HEAD
 +	if (RESC_END(p_hwfn, QED_ILT) > PXP_NUM_ILT_RECORDS_BB) {
++=======
+ 	if ((b_ah && (RESC_END(p_hwfn, QED_ILT) > PXP_NUM_ILT_RECORDS_K2)) ||
+ 	    (!b_ah && (RESC_END(p_hwfn, QED_ILT) > PXP_NUM_ILT_RECORDS_BB))) {
++>>>>>>> 9c79ddaa0f96 (qed*: Add support for QL41xxx adapters)
  		DP_NOTICE(p_hwfn, "Can't assign ILT pages [%08x,...,%08x]\n",
  			  RESC_START(p_hwfn, QED_ILT),
  			  RESC_END(p_hwfn, QED_ILT) - 1);
@@@ -1758,30 -2073,18 +2042,18 @@@ static void qed_get_num_funcs(struct qe
  
  	DP_VERBOSE(p_hwfn,
  		   NETIF_MSG_PROBE,
 -		   "PF [rel_id %d, abs_id %d] occupies index %d within the %d enabled functions on the engine\n",
 +		   "PF [rel_id %d, abs_id %d] within the %d enabled functions on the engine\n",
  		   p_hwfn->rel_pf_id,
  		   p_hwfn->abs_pf_id,
 -		   p_hwfn->enabled_func_idx, p_hwfn->num_funcs_on_engine);
 +		   p_hwfn->num_funcs_on_engine);
  }
  
- static int
- qed_get_hw_info(struct qed_hwfn *p_hwfn,
- 		struct qed_ptt *p_ptt,
- 		enum qed_pci_personality personality)
+ static void qed_hw_info_port_num_bb(struct qed_hwfn *p_hwfn,
+ 				    struct qed_ptt *p_ptt)
  {
  	u32 port_mode;
- 	int rc;
  
- 	/* Since all information is common, only first hwfns should do this */
- 	if (IS_LEAD_HWFN(p_hwfn)) {
- 		rc = qed_iov_hw_info(p_hwfn);
- 		if (rc)
- 			return rc;
- 	}
- 
- 	/* Read the port mode */
- 	port_mode = qed_rd(p_hwfn, p_ptt,
- 			   CNIG_REG_NW_PORT_MODE_BB_B0);
+ 	port_mode = qed_rd(p_hwfn, p_ptt, CNIG_REG_NW_PORT_MODE_BB_B0);
  
  	if (port_mode < 3) {
  		p_hwfn->cdev->num_ports_in_engines = 1;
diff --cc drivers/net/ethernet/qlogic/qed/qed_reg_addr.h
index b414a0542177,6d4ac7e2ee83..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_reg_addr.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_reg_addr.h
@@@ -1455,4 -1519,44 +1455,47 @@@
  #define DORQ_REG_PF_ICID_BIT_SHIFT_NORM	0x100448UL
  #define DORQ_REG_PF_MIN_ADDR_REG1 0x100400UL
  #define DORQ_REG_PF_DPI_BIT_SHIFT 0x100450UL
++<<<<<<< HEAD
++=======
+ #define NIG_REG_RX_PTP_EN 0x501900UL
+ #define NIG_REG_TX_PTP_EN 0x501904UL
+ #define NIG_REG_LLH_PTP_TO_HOST	0x501908UL
+ #define NIG_REG_LLH_PTP_TO_MCP 0x50190cUL
+ #define NIG_REG_PTP_SW_TXTSEN 0x501910UL
+ #define NIG_REG_LLH_PTP_ETHERTYPE_1 0x501914UL
+ #define NIG_REG_LLH_PTP_MAC_DA_2_LSB 0x501918UL
+ #define NIG_REG_LLH_PTP_MAC_DA_2_MSB 0x50191cUL
+ #define NIG_REG_LLH_PTP_PARAM_MASK 0x501920UL
+ #define NIG_REG_LLH_PTP_RULE_MASK 0x501924UL
+ #define NIG_REG_TX_LLH_PTP_PARAM_MASK 0x501928UL
+ #define NIG_REG_TX_LLH_PTP_RULE_MASK 0x50192cUL
+ #define NIG_REG_LLH_PTP_HOST_BUF_SEQID 0x501930UL
+ #define NIG_REG_LLH_PTP_HOST_BUF_TS_LSB 0x501934UL
+ #define NIG_REG_LLH_PTP_HOST_BUF_TS_MSB	0x501938UL
+ #define NIG_REG_LLH_PTP_MCP_BUF_SEQID 0x50193cUL
+ #define NIG_REG_LLH_PTP_MCP_BUF_TS_LSB 0x501940UL
+ #define NIG_REG_LLH_PTP_MCP_BUF_TS_MSB 0x501944UL
+ #define NIG_REG_TX_LLH_PTP_BUF_SEQID 0x501948UL
+ #define NIG_REG_TX_LLH_PTP_BUF_TS_LSB 0x50194cUL
+ #define NIG_REG_TX_LLH_PTP_BUF_TS_MSB 0x501950UL
+ #define NIG_REG_RX_PTP_TS_MSB_ERR 0x501954UL
+ #define NIG_REG_TX_PTP_TS_MSB_ERR 0x501958UL
+ #define NIG_REG_TSGEN_SYNC_TIME_LSB 0x5088c0UL
+ #define NIG_REG_TSGEN_SYNC_TIME_MSB 0x5088c4UL
+ #define NIG_REG_TSGEN_RST_DRIFT_CNTR 0x5088d8UL
+ #define NIG_REG_TSGEN_DRIFT_CNTR_CONF 0x5088dcUL
+ #define NIG_REG_TS_OUTPUT_ENABLE_PDA 0x508870UL
+ #define NIG_REG_TIMESYNC_GEN_REG_BB 0x500d00UL
+ #define NIG_REG_TSGEN_FREE_CNT_VALUE_LSB 0x5088a8UL
+ #define NIG_REG_TSGEN_FREE_CNT_VALUE_MSB 0x5088acUL
+ #define NIG_REG_PTP_LATCH_OSTS_PKT_TIME 0x509040UL
+ 
+ #define PGLUE_B_REG_PGL_ADDR_E8_F0_K2 0x2aaf98UL
+ #define PGLUE_B_REG_PGL_ADDR_EC_F0_K2 0x2aaf9cUL
+ #define PGLUE_B_REG_PGL_ADDR_F0_F0_K2 0x2aafa0UL
+ #define PGLUE_B_REG_PGL_ADDR_F4_F0_K2 0x2aafa4UL
+ #define NIG_REG_TSGEN_FREECNT_UPDATE_K2 0x509008UL
+ #define CNIG_REG_NIG_PORT0_CONF_K2 0x218200UL
+ 
++>>>>>>> 9c79ddaa0f96 (qed*: Add support for QL41xxx adapters)
  #endif
diff --cc drivers/net/ethernet/qlogic/qede/qede_main.c
index 356ca114d243,abd99109e532..000000000000
--- a/drivers/net/ethernet/qlogic/qede/qede_main.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_main.c
@@@ -1713,122 -327,131 +1723,142 @@@ void qede_fill_by_demand_stats(struct q
  	struct qed_eth_stats stats;
  
  	edev->ops->get_vport_stats(edev->cdev, &stats);
- 	edev->stats.no_buff_discards = stats.no_buff_discards;
- 	edev->stats.packet_too_big_discard = stats.packet_too_big_discard;
- 	edev->stats.ttl0_discard = stats.ttl0_discard;
- 	edev->stats.rx_ucast_bytes = stats.rx_ucast_bytes;
- 	edev->stats.rx_mcast_bytes = stats.rx_mcast_bytes;
- 	edev->stats.rx_bcast_bytes = stats.rx_bcast_bytes;
- 	edev->stats.rx_ucast_pkts = stats.rx_ucast_pkts;
- 	edev->stats.rx_mcast_pkts = stats.rx_mcast_pkts;
- 	edev->stats.rx_bcast_pkts = stats.rx_bcast_pkts;
- 	edev->stats.mftag_filter_discards = stats.mftag_filter_discards;
- 	edev->stats.mac_filter_discards = stats.mac_filter_discards;
- 
- 	edev->stats.tx_ucast_bytes = stats.tx_ucast_bytes;
- 	edev->stats.tx_mcast_bytes = stats.tx_mcast_bytes;
- 	edev->stats.tx_bcast_bytes = stats.tx_bcast_bytes;
- 	edev->stats.tx_ucast_pkts = stats.tx_ucast_pkts;
- 	edev->stats.tx_mcast_pkts = stats.tx_mcast_pkts;
- 	edev->stats.tx_bcast_pkts = stats.tx_bcast_pkts;
- 	edev->stats.tx_err_drop_pkts = stats.tx_err_drop_pkts;
- 	edev->stats.coalesced_pkts = stats.tpa_coalesced_pkts;
- 	edev->stats.coalesced_events = stats.tpa_coalesced_events;
- 	edev->stats.coalesced_aborts_num = stats.tpa_aborts_num;
- 	edev->stats.non_coalesced_pkts = stats.tpa_not_coalesced_pkts;
- 	edev->stats.coalesced_bytes = stats.tpa_coalesced_bytes;
- 
- 	edev->stats.rx_64_byte_packets = stats.rx_64_byte_packets;
- 	edev->stats.rx_65_to_127_byte_packets = stats.rx_65_to_127_byte_packets;
- 	edev->stats.rx_128_to_255_byte_packets =
- 				stats.rx_128_to_255_byte_packets;
- 	edev->stats.rx_256_to_511_byte_packets =
- 				stats.rx_256_to_511_byte_packets;
- 	edev->stats.rx_512_to_1023_byte_packets =
- 				stats.rx_512_to_1023_byte_packets;
- 	edev->stats.rx_1024_to_1518_byte_packets =
- 				stats.rx_1024_to_1518_byte_packets;
- 	edev->stats.rx_1519_to_1522_byte_packets =
- 				stats.rx_1519_to_1522_byte_packets;
- 	edev->stats.rx_1519_to_2047_byte_packets =
- 				stats.rx_1519_to_2047_byte_packets;
- 	edev->stats.rx_2048_to_4095_byte_packets =
- 				stats.rx_2048_to_4095_byte_packets;
- 	edev->stats.rx_4096_to_9216_byte_packets =
- 				stats.rx_4096_to_9216_byte_packets;
- 	edev->stats.rx_9217_to_16383_byte_packets =
- 				stats.rx_9217_to_16383_byte_packets;
- 	edev->stats.rx_crc_errors = stats.rx_crc_errors;
- 	edev->stats.rx_mac_crtl_frames = stats.rx_mac_crtl_frames;
- 	edev->stats.rx_pause_frames = stats.rx_pause_frames;
- 	edev->stats.rx_pfc_frames = stats.rx_pfc_frames;
- 	edev->stats.rx_align_errors = stats.rx_align_errors;
- 	edev->stats.rx_carrier_errors = stats.rx_carrier_errors;
- 	edev->stats.rx_oversize_packets = stats.rx_oversize_packets;
- 	edev->stats.rx_jabbers = stats.rx_jabbers;
- 	edev->stats.rx_undersize_packets = stats.rx_undersize_packets;
- 	edev->stats.rx_fragments = stats.rx_fragments;
- 	edev->stats.tx_64_byte_packets = stats.tx_64_byte_packets;
- 	edev->stats.tx_65_to_127_byte_packets = stats.tx_65_to_127_byte_packets;
- 	edev->stats.tx_128_to_255_byte_packets =
- 				stats.tx_128_to_255_byte_packets;
- 	edev->stats.tx_256_to_511_byte_packets =
- 				stats.tx_256_to_511_byte_packets;
- 	edev->stats.tx_512_to_1023_byte_packets =
- 				stats.tx_512_to_1023_byte_packets;
- 	edev->stats.tx_1024_to_1518_byte_packets =
- 				stats.tx_1024_to_1518_byte_packets;
- 	edev->stats.tx_1519_to_2047_byte_packets =
- 				stats.tx_1519_to_2047_byte_packets;
- 	edev->stats.tx_2048_to_4095_byte_packets =
- 				stats.tx_2048_to_4095_byte_packets;
- 	edev->stats.tx_4096_to_9216_byte_packets =
- 				stats.tx_4096_to_9216_byte_packets;
- 	edev->stats.tx_9217_to_16383_byte_packets =
- 				stats.tx_9217_to_16383_byte_packets;
- 	edev->stats.tx_pause_frames = stats.tx_pause_frames;
- 	edev->stats.tx_pfc_frames = stats.tx_pfc_frames;
- 	edev->stats.tx_lpi_entry_count = stats.tx_lpi_entry_count;
- 	edev->stats.tx_total_collisions = stats.tx_total_collisions;
- 	edev->stats.brb_truncates = stats.brb_truncates;
- 	edev->stats.brb_discards = stats.brb_discards;
- 	edev->stats.tx_mac_ctrl_frames = stats.tx_mac_ctrl_frames;
+ 
+ 	p_common->no_buff_discards = stats.common.no_buff_discards;
+ 	p_common->packet_too_big_discard = stats.common.packet_too_big_discard;
+ 	p_common->ttl0_discard = stats.common.ttl0_discard;
+ 	p_common->rx_ucast_bytes = stats.common.rx_ucast_bytes;
+ 	p_common->rx_mcast_bytes = stats.common.rx_mcast_bytes;
+ 	p_common->rx_bcast_bytes = stats.common.rx_bcast_bytes;
+ 	p_common->rx_ucast_pkts = stats.common.rx_ucast_pkts;
+ 	p_common->rx_mcast_pkts = stats.common.rx_mcast_pkts;
+ 	p_common->rx_bcast_pkts = stats.common.rx_bcast_pkts;
+ 	p_common->mftag_filter_discards = stats.common.mftag_filter_discards;
+ 	p_common->mac_filter_discards = stats.common.mac_filter_discards;
+ 
+ 	p_common->tx_ucast_bytes = stats.common.tx_ucast_bytes;
+ 	p_common->tx_mcast_bytes = stats.common.tx_mcast_bytes;
+ 	p_common->tx_bcast_bytes = stats.common.tx_bcast_bytes;
+ 	p_common->tx_ucast_pkts = stats.common.tx_ucast_pkts;
+ 	p_common->tx_mcast_pkts = stats.common.tx_mcast_pkts;
+ 	p_common->tx_bcast_pkts = stats.common.tx_bcast_pkts;
+ 	p_common->tx_err_drop_pkts = stats.common.tx_err_drop_pkts;
+ 	p_common->coalesced_pkts = stats.common.tpa_coalesced_pkts;
+ 	p_common->coalesced_events = stats.common.tpa_coalesced_events;
+ 	p_common->coalesced_aborts_num = stats.common.tpa_aborts_num;
+ 	p_common->non_coalesced_pkts = stats.common.tpa_not_coalesced_pkts;
+ 	p_common->coalesced_bytes = stats.common.tpa_coalesced_bytes;
+ 
+ 	p_common->rx_64_byte_packets = stats.common.rx_64_byte_packets;
+ 	p_common->rx_65_to_127_byte_packets =
+ 	    stats.common.rx_65_to_127_byte_packets;
+ 	p_common->rx_128_to_255_byte_packets =
+ 	    stats.common.rx_128_to_255_byte_packets;
+ 	p_common->rx_256_to_511_byte_packets =
+ 	    stats.common.rx_256_to_511_byte_packets;
+ 	p_common->rx_512_to_1023_byte_packets =
+ 	    stats.common.rx_512_to_1023_byte_packets;
+ 	p_common->rx_1024_to_1518_byte_packets =
+ 	    stats.common.rx_1024_to_1518_byte_packets;
+ 	p_common->rx_crc_errors = stats.common.rx_crc_errors;
+ 	p_common->rx_mac_crtl_frames = stats.common.rx_mac_crtl_frames;
+ 	p_common->rx_pause_frames = stats.common.rx_pause_frames;
+ 	p_common->rx_pfc_frames = stats.common.rx_pfc_frames;
+ 	p_common->rx_align_errors = stats.common.rx_align_errors;
+ 	p_common->rx_carrier_errors = stats.common.rx_carrier_errors;
+ 	p_common->rx_oversize_packets = stats.common.rx_oversize_packets;
+ 	p_common->rx_jabbers = stats.common.rx_jabbers;
+ 	p_common->rx_undersize_packets = stats.common.rx_undersize_packets;
+ 	p_common->rx_fragments = stats.common.rx_fragments;
+ 	p_common->tx_64_byte_packets = stats.common.tx_64_byte_packets;
+ 	p_common->tx_65_to_127_byte_packets =
+ 	    stats.common.tx_65_to_127_byte_packets;
+ 	p_common->tx_128_to_255_byte_packets =
+ 	    stats.common.tx_128_to_255_byte_packets;
+ 	p_common->tx_256_to_511_byte_packets =
+ 	    stats.common.tx_256_to_511_byte_packets;
+ 	p_common->tx_512_to_1023_byte_packets =
+ 	    stats.common.tx_512_to_1023_byte_packets;
+ 	p_common->tx_1024_to_1518_byte_packets =
+ 	    stats.common.tx_1024_to_1518_byte_packets;
+ 	p_common->tx_pause_frames = stats.common.tx_pause_frames;
+ 	p_common->tx_pfc_frames = stats.common.tx_pfc_frames;
+ 	p_common->brb_truncates = stats.common.brb_truncates;
+ 	p_common->brb_discards = stats.common.brb_discards;
+ 	p_common->tx_mac_ctrl_frames = stats.common.tx_mac_ctrl_frames;
+ 
+ 	if (QEDE_IS_BB(edev)) {
+ 		struct qede_stats_bb *p_bb = &edev->stats.bb;
+ 
+ 		p_bb->rx_1519_to_1522_byte_packets =
+ 		    stats.bb.rx_1519_to_1522_byte_packets;
+ 		p_bb->rx_1519_to_2047_byte_packets =
+ 		    stats.bb.rx_1519_to_2047_byte_packets;
+ 		p_bb->rx_2048_to_4095_byte_packets =
+ 		    stats.bb.rx_2048_to_4095_byte_packets;
+ 		p_bb->rx_4096_to_9216_byte_packets =
+ 		    stats.bb.rx_4096_to_9216_byte_packets;
+ 		p_bb->rx_9217_to_16383_byte_packets =
+ 		    stats.bb.rx_9217_to_16383_byte_packets;
+ 		p_bb->tx_1519_to_2047_byte_packets =
+ 		    stats.bb.tx_1519_to_2047_byte_packets;
+ 		p_bb->tx_2048_to_4095_byte_packets =
+ 		    stats.bb.tx_2048_to_4095_byte_packets;
+ 		p_bb->tx_4096_to_9216_byte_packets =
+ 		    stats.bb.tx_4096_to_9216_byte_packets;
+ 		p_bb->tx_9217_to_16383_byte_packets =
+ 		    stats.bb.tx_9217_to_16383_byte_packets;
+ 		p_bb->tx_lpi_entry_count = stats.bb.tx_lpi_entry_count;
+ 		p_bb->tx_total_collisions = stats.bb.tx_total_collisions;
+ 	} else {
+ 		struct qede_stats_ah *p_ah = &edev->stats.ah;
+ 
+ 		p_ah->rx_1519_to_max_byte_packets =
+ 		    stats.ah.rx_1519_to_max_byte_packets;
+ 		p_ah->tx_1519_to_max_byte_packets =
+ 		    stats.ah.tx_1519_to_max_byte_packets;
+ 	}
  }
  
 -static void qede_get_stats64(struct net_device *dev,
 -			     struct rtnl_link_stats64 *stats)
 +static
 +struct rtnl_link_stats64 *qede_get_stats64(struct net_device *dev,
 +					   struct rtnl_link_stats64 *stats)
  {
  	struct qede_dev *edev = netdev_priv(dev);
+ 	struct qede_stats_common *p_common;
  
  	qede_fill_by_demand_stats(edev);
+ 	p_common = &edev->stats.common;
  
- 	stats->rx_packets = edev->stats.rx_ucast_pkts +
- 			    edev->stats.rx_mcast_pkts +
- 			    edev->stats.rx_bcast_pkts;
- 	stats->tx_packets = edev->stats.tx_ucast_pkts +
- 			    edev->stats.tx_mcast_pkts +
- 			    edev->stats.tx_bcast_pkts;
+ 	stats->rx_packets = p_common->rx_ucast_pkts + p_common->rx_mcast_pkts +
+ 			    p_common->rx_bcast_pkts;
+ 	stats->tx_packets = p_common->tx_ucast_pkts + p_common->tx_mcast_pkts +
+ 			    p_common->tx_bcast_pkts;
  
- 	stats->rx_bytes = edev->stats.rx_ucast_bytes +
- 			  edev->stats.rx_mcast_bytes +
- 			  edev->stats.rx_bcast_bytes;
+ 	stats->rx_bytes = p_common->rx_ucast_bytes + p_common->rx_mcast_bytes +
+ 			  p_common->rx_bcast_bytes;
+ 	stats->tx_bytes = p_common->tx_ucast_bytes + p_common->tx_mcast_bytes +
+ 			  p_common->tx_bcast_bytes;
  
- 	stats->tx_bytes = edev->stats.tx_ucast_bytes +
- 			  edev->stats.tx_mcast_bytes +
- 			  edev->stats.tx_bcast_bytes;
+ 	stats->tx_errors = p_common->tx_err_drop_pkts;
+ 	stats->multicast = p_common->rx_mcast_pkts + p_common->rx_bcast_pkts;
  
- 	stats->tx_errors = edev->stats.tx_err_drop_pkts;
- 	stats->multicast = edev->stats.rx_mcast_pkts +
- 			   edev->stats.rx_bcast_pkts;
+ 	stats->rx_fifo_errors = p_common->no_buff_discards;
  
++<<<<<<< HEAD
 +	stats->rx_fifo_errors = edev->stats.no_buff_discards;
 +
 +	stats->collisions = edev->stats.tx_total_collisions;
 +	stats->rx_crc_errors = edev->stats.rx_crc_errors;
 +	stats->rx_frame_errors = edev->stats.rx_align_errors;
 +
 +	return stats;
++=======
+ 	if (QEDE_IS_BB(edev))
+ 		stats->collisions = edev->stats.bb.tx_total_collisions;
+ 	stats->rx_crc_errors = p_common->rx_crc_errors;
+ 	stats->rx_frame_errors = p_common->rx_align_errors;
++>>>>>>> 9c79ddaa0f96 (qed*: Add support for QL41xxx adapters)
  }
  
  #ifdef CONFIG_QED_SRIOV
diff --cc include/linux/qed/qed_if.h
index 2b9c21bc615a,8e0065c52857..000000000000
--- a/include/linux/qed/qed_if.h
+++ b/include/linux/qed/qed_if.h
@@@ -268,6 -326,12 +273,15 @@@ struct qed_dev_info 
  	u32		flash_size;
  	u8		mf_mode;
  	bool		tx_switching;
++<<<<<<< HEAD
++=======
+ 	bool		rdma_supported;
+ 	u16		mtu;
+ 
+ 	bool wol_support;
+ 
+ 	enum qed_dev_type dev_type;
++>>>>>>> 9c79ddaa0f96 (qed*: Add support for QL41xxx adapters)
  };
  
  enum qed_sb_type {
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_ptp.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed.h b/drivers/net/ethernet/qlogic/qed/qed.h
index ad910881f098..edd873a6c569 100644
--- a/drivers/net/ethernet/qlogic/qed/qed.h
+++ b/drivers/net/ethernet/qlogic/qed/qed.h
@@ -187,7 +187,9 @@ enum QED_PORT_MODE {
 	QED_PORT_MODE_DE_4X20G,
 	QED_PORT_MODE_DE_1X40G,
 	QED_PORT_MODE_DE_2X25G,
-	QED_PORT_MODE_DE_1X25G
+	QED_PORT_MODE_DE_1X25G,
+	QED_PORT_MODE_DE_4X25G,
+	QED_PORT_MODE_DE_2X10G,
 };
 
 enum qed_dev_cap {
@@ -328,7 +330,8 @@ struct qed_hwfn {
 #define IS_LEAD_HWFN(edev)              (!((edev)->my_id))
 	u8				rel_pf_id;      /* Relative to engine*/
 	u8				abs_pf_id;
-#define QED_PATH_ID(_p_hwfn)		((_p_hwfn)->abs_pf_id & 1)
+#define QED_PATH_ID(_p_hwfn) \
+	(QED_IS_K2((_p_hwfn)->cdev) ? 0 : ((_p_hwfn)->abs_pf_id & 1))
 	u8				port_id;
 	bool				b_active;
 
@@ -485,9 +488,7 @@ struct qed_dev {
 	u8	dp_level;
 	char	name[NAME_SIZE];
 
-	u8	type;
-#define QED_DEV_TYPE_BB (0 << 0)
-#define QED_DEV_TYPE_AH BIT(0)
+	enum	qed_dev_type type;
 /* Translate type/revision combo into the proper conditions */
 #define QED_IS_BB(dev)  ((dev)->type == QED_DEV_TYPE_BB)
 #define QED_IS_BB_A0(dev)       (QED_IS_BB(dev) && \
@@ -502,6 +503,9 @@ struct qed_dev {
 
 	u16	vendor_id;
 	u16	device_id;
+#define QED_DEV_ID_MASK		0xff00
+#define QED_DEV_ID_MASK_BB	0x1600
+#define QED_DEV_ID_MASK_AH	0x8000
 
 	u16	chip_num;
 #define CHIP_NUM_MASK                   0xffff
@@ -609,10 +613,16 @@ struct qed_dev {
 	u32 rdma_max_srq_sge;
 };
 
-#define NUM_OF_VFS(dev)         MAX_NUM_VFS_BB
-#define NUM_OF_L2_QUEUES(dev)	MAX_NUM_L2_QUEUES_BB
-#define NUM_OF_SBS(dev)         MAX_SB_PER_PATH_BB
-#define NUM_OF_ENG_PFS(dev)     MAX_NUM_PFS_BB
+#define NUM_OF_VFS(dev)         (QED_IS_BB(dev) ? MAX_NUM_VFS_BB \
+						: MAX_NUM_VFS_K2)
+#define NUM_OF_L2_QUEUES(dev)   (QED_IS_BB(dev) ? MAX_NUM_L2_QUEUES_BB \
+						: MAX_NUM_L2_QUEUES_K2)
+#define NUM_OF_PORTS(dev)       (QED_IS_BB(dev) ? MAX_NUM_PORTS_BB \
+						: MAX_NUM_PORTS_K2)
+#define NUM_OF_SBS(dev)         (QED_IS_BB(dev) ? MAX_SB_PER_PATH_BB \
+						: MAX_SB_PER_PATH_K2)
+#define NUM_OF_ENG_PFS(dev)     (QED_IS_BB(dev) ? MAX_NUM_PFS_BB \
+						: MAX_NUM_PFS_K2)
 
 /**
  * @brief qed_concrete_to_sw_fid - get the sw function id from
@@ -647,6 +657,7 @@ void qed_configure_vp_wfq_on_link_change(struct qed_dev *cdev, u32 min_pf_rate);
 
 void qed_clean_wfq_db(struct qed_hwfn *p_hwfn, struct qed_ptt *p_ptt);
 #define QED_LEADING_HWFN(dev)   (&dev->hwfns[0])
+int qed_device_num_engines(struct qed_dev *cdev);
 
 /* Other Linux specific common definitions */
 #define DP_NAME(cdev) ((cdev)->name)
diff --git a/drivers/net/ethernet/qlogic/qed/qed_debug.c b/drivers/net/ethernet/qlogic/qed/qed_debug.c
index 68f19ca57f96..b1e9851cd0e9 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_debug.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_debug.c
@@ -1424,7 +1424,7 @@ static enum dbg_status qed_dbg_dev_init(struct qed_hwfn *p_hwfn,
 		dev_data->mode_enable[MODE_K2] = 1;
 	} else if (QED_IS_BB_B0(p_hwfn->cdev)) {
 		dev_data->chip_id = CHIP_BB_B0;
-		dev_data->mode_enable[MODE_BB_B0] = 1;
+		dev_data->mode_enable[MODE_BB] = 1;
 	} else {
 		return DBG_STATUS_UNKNOWN_CHIP;
 	}
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_dev.c
diff --git a/drivers/net/ethernet/qlogic/qed/qed_hsi.h b/drivers/net/ethernet/qlogic/qed/qed_hsi.h
index 54fc4901dd36..1cf02470559f 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_hsi.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_hsi.h
@@ -2378,7 +2378,7 @@ struct fw_info_location {
 
 enum init_modes {
 	MODE_RESERVED,
-	MODE_BB_B0,
+	MODE_BB,
 	MODE_K2,
 	MODE_ASIC,
 	MODE_RESERVED2,
@@ -8038,11 +8038,24 @@ struct eth_stats {
 	u64 r511;
 	u64 r1023;
 	u64 r1518;
-	u64 r1522;
-	u64 r2047;
-	u64 r4095;
-	u64 r9216;
-	u64 r16383;
+
+	union {
+		struct {
+			u64 r1522;
+			u64 r2047;
+			u64 r4095;
+			u64 r9216;
+			u64 r16383;
+		} bb0;
+		struct {
+			u64 unused1;
+			u64 r1519_to_max;
+			u64 unused2;
+			u64 unused3;
+			u64 unused4;
+		} ah0;
+	} u0;
+
 	u64 rfcs;
 	u64 rxcf;
 	u64 rxpf;
@@ -8059,14 +8072,36 @@ struct eth_stats {
 	u64 t511;
 	u64 t1023;
 	u64 t1518;
-	u64 t2047;
-	u64 t4095;
-	u64 t9216;
-	u64 t16383;
+
+	union {
+		struct {
+			u64 t2047;
+			u64 t4095;
+			u64 t9216;
+			u64 t16383;
+		} bb1;
+		struct {
+			u64 t1519_to_max;
+			u64 unused6;
+			u64 unused7;
+			u64 unused8;
+		} ah1;
+	} u1;
+
 	u64 txpf;
 	u64 txpp;
-	u64 tlpiec;
-	u64 tncl;
+
+	union {
+		struct {
+			u64 tlpiec;
+			u64 tncl;
+		} bb2;
+		struct {
+			u64 unused9;
+			u64 unused10;
+		} ah2;
+	} u2;
+
 	u64 rbyte;
 	u64 rxuca;
 	u64 rxmca;
@@ -8744,6 +8779,8 @@ struct nvm_cfg1_glob {
 #define NVM_CFG1_GLOB_NETWORK_PORT_MODE_2X25G		0xC
 #define NVM_CFG1_GLOB_NETWORK_PORT_MODE_1X25G		0xD
 #define NVM_CFG1_GLOB_NETWORK_PORT_MODE_4X25G		0xE
+#define NVM_CFG1_GLOB_NETWORK_PORT_MODE_2X10G		0xF
+
 	u32 e_lane_cfg1;
 	u32 e_lane_cfg2;
 	u32 f_lane_cfg1;
diff --git a/drivers/net/ethernet/qlogic/qed/qed_l2.c b/drivers/net/ethernet/qlogic/qed/qed_l2.c
index 067efdc6ddbd..6f0c22ec224f 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_l2.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_l2.c
@@ -1343,13 +1343,20 @@ static void __qed_get_vport_pstats(struct qed_hwfn *p_hwfn,
 	memset(&pstats, 0, sizeof(pstats));
 	qed_memcpy_from(p_hwfn, p_ptt, &pstats, pstats_addr, pstats_len);
 
-	p_stats->tx_ucast_bytes += HILO_64_REGPAIR(pstats.sent_ucast_bytes);
-	p_stats->tx_mcast_bytes += HILO_64_REGPAIR(pstats.sent_mcast_bytes);
-	p_stats->tx_bcast_bytes += HILO_64_REGPAIR(pstats.sent_bcast_bytes);
-	p_stats->tx_ucast_pkts += HILO_64_REGPAIR(pstats.sent_ucast_pkts);
-	p_stats->tx_mcast_pkts += HILO_64_REGPAIR(pstats.sent_mcast_pkts);
-	p_stats->tx_bcast_pkts += HILO_64_REGPAIR(pstats.sent_bcast_pkts);
-	p_stats->tx_err_drop_pkts += HILO_64_REGPAIR(pstats.error_drop_pkts);
+	p_stats->common.tx_ucast_bytes +=
+	    HILO_64_REGPAIR(pstats.sent_ucast_bytes);
+	p_stats->common.tx_mcast_bytes +=
+	    HILO_64_REGPAIR(pstats.sent_mcast_bytes);
+	p_stats->common.tx_bcast_bytes +=
+	    HILO_64_REGPAIR(pstats.sent_bcast_bytes);
+	p_stats->common.tx_ucast_pkts +=
+	    HILO_64_REGPAIR(pstats.sent_ucast_pkts);
+	p_stats->common.tx_mcast_pkts +=
+	    HILO_64_REGPAIR(pstats.sent_mcast_pkts);
+	p_stats->common.tx_bcast_pkts +=
+	    HILO_64_REGPAIR(pstats.sent_bcast_pkts);
+	p_stats->common.tx_err_drop_pkts +=
+	    HILO_64_REGPAIR(pstats.error_drop_pkts);
 }
 
 static void __qed_get_vport_tstats(struct qed_hwfn *p_hwfn,
@@ -1375,10 +1382,10 @@ static void __qed_get_vport_tstats(struct qed_hwfn *p_hwfn,
 	memset(&tstats, 0, sizeof(tstats));
 	qed_memcpy_from(p_hwfn, p_ptt, &tstats, tstats_addr, tstats_len);
 
-	p_stats->mftag_filter_discards +=
-		HILO_64_REGPAIR(tstats.mftag_filter_discard);
-	p_stats->mac_filter_discards +=
-		HILO_64_REGPAIR(tstats.eth_mac_filter_discard);
+	p_stats->common.mftag_filter_discards +=
+	    HILO_64_REGPAIR(tstats.mftag_filter_discard);
+	p_stats->common.mac_filter_discards +=
+	    HILO_64_REGPAIR(tstats.eth_mac_filter_discard);
 }
 
 static void __qed_get_vport_ustats_addrlen(struct qed_hwfn *p_hwfn,
@@ -1412,12 +1419,15 @@ static void __qed_get_vport_ustats(struct qed_hwfn *p_hwfn,
 	memset(&ustats, 0, sizeof(ustats));
 	qed_memcpy_from(p_hwfn, p_ptt, &ustats, ustats_addr, ustats_len);
 
-	p_stats->rx_ucast_bytes += HILO_64_REGPAIR(ustats.rcv_ucast_bytes);
-	p_stats->rx_mcast_bytes += HILO_64_REGPAIR(ustats.rcv_mcast_bytes);
-	p_stats->rx_bcast_bytes += HILO_64_REGPAIR(ustats.rcv_bcast_bytes);
-	p_stats->rx_ucast_pkts += HILO_64_REGPAIR(ustats.rcv_ucast_pkts);
-	p_stats->rx_mcast_pkts += HILO_64_REGPAIR(ustats.rcv_mcast_pkts);
-	p_stats->rx_bcast_pkts += HILO_64_REGPAIR(ustats.rcv_bcast_pkts);
+	p_stats->common.rx_ucast_bytes +=
+	    HILO_64_REGPAIR(ustats.rcv_ucast_bytes);
+	p_stats->common.rx_mcast_bytes +=
+	    HILO_64_REGPAIR(ustats.rcv_mcast_bytes);
+	p_stats->common.rx_bcast_bytes +=
+	    HILO_64_REGPAIR(ustats.rcv_bcast_bytes);
+	p_stats->common.rx_ucast_pkts += HILO_64_REGPAIR(ustats.rcv_ucast_pkts);
+	p_stats->common.rx_mcast_pkts += HILO_64_REGPAIR(ustats.rcv_mcast_pkts);
+	p_stats->common.rx_bcast_pkts += HILO_64_REGPAIR(ustats.rcv_bcast_pkts);
 }
 
 static void __qed_get_vport_mstats_addrlen(struct qed_hwfn *p_hwfn,
@@ -1451,23 +1461,26 @@ static void __qed_get_vport_mstats(struct qed_hwfn *p_hwfn,
 	memset(&mstats, 0, sizeof(mstats));
 	qed_memcpy_from(p_hwfn, p_ptt, &mstats, mstats_addr, mstats_len);
 
-	p_stats->no_buff_discards += HILO_64_REGPAIR(mstats.no_buff_discard);
-	p_stats->packet_too_big_discard +=
-		HILO_64_REGPAIR(mstats.packet_too_big_discard);
-	p_stats->ttl0_discard += HILO_64_REGPAIR(mstats.ttl0_discard);
-	p_stats->tpa_coalesced_pkts +=
-		HILO_64_REGPAIR(mstats.tpa_coalesced_pkts);
-	p_stats->tpa_coalesced_events +=
-		HILO_64_REGPAIR(mstats.tpa_coalesced_events);
-	p_stats->tpa_aborts_num += HILO_64_REGPAIR(mstats.tpa_aborts_num);
-	p_stats->tpa_coalesced_bytes +=
-		HILO_64_REGPAIR(mstats.tpa_coalesced_bytes);
+	p_stats->common.no_buff_discards +=
+	    HILO_64_REGPAIR(mstats.no_buff_discard);
+	p_stats->common.packet_too_big_discard +=
+	    HILO_64_REGPAIR(mstats.packet_too_big_discard);
+	p_stats->common.ttl0_discard += HILO_64_REGPAIR(mstats.ttl0_discard);
+	p_stats->common.tpa_coalesced_pkts +=
+	    HILO_64_REGPAIR(mstats.tpa_coalesced_pkts);
+	p_stats->common.tpa_coalesced_events +=
+	    HILO_64_REGPAIR(mstats.tpa_coalesced_events);
+	p_stats->common.tpa_aborts_num +=
+	    HILO_64_REGPAIR(mstats.tpa_aborts_num);
+	p_stats->common.tpa_coalesced_bytes +=
+	    HILO_64_REGPAIR(mstats.tpa_coalesced_bytes);
 }
 
 static void __qed_get_vport_port_stats(struct qed_hwfn *p_hwfn,
 				       struct qed_ptt *p_ptt,
 				       struct qed_eth_stats *p_stats)
 {
+	struct qed_eth_stats_common *p_common = &p_stats->common;
 	struct port_stats port_stats;
 	int j;
 
@@ -1478,54 +1491,75 @@ static void __qed_get_vport_port_stats(struct qed_hwfn *p_hwfn,
 			offsetof(struct public_port, stats),
 			sizeof(port_stats));
 
-	p_stats->rx_64_byte_packets		+= port_stats.eth.r64;
-	p_stats->rx_65_to_127_byte_packets	+= port_stats.eth.r127;
-	p_stats->rx_128_to_255_byte_packets	+= port_stats.eth.r255;
-	p_stats->rx_256_to_511_byte_packets	+= port_stats.eth.r511;
-	p_stats->rx_512_to_1023_byte_packets	+= port_stats.eth.r1023;
-	p_stats->rx_1024_to_1518_byte_packets	+= port_stats.eth.r1518;
-	p_stats->rx_1519_to_1522_byte_packets	+= port_stats.eth.r1522;
-	p_stats->rx_1519_to_2047_byte_packets	+= port_stats.eth.r2047;
-	p_stats->rx_2048_to_4095_byte_packets	+= port_stats.eth.r4095;
-	p_stats->rx_4096_to_9216_byte_packets	+= port_stats.eth.r9216;
-	p_stats->rx_9217_to_16383_byte_packets	+= port_stats.eth.r16383;
-	p_stats->rx_crc_errors			+= port_stats.eth.rfcs;
-	p_stats->rx_mac_crtl_frames		+= port_stats.eth.rxcf;
-	p_stats->rx_pause_frames		+= port_stats.eth.rxpf;
-	p_stats->rx_pfc_frames			+= port_stats.eth.rxpp;
-	p_stats->rx_align_errors		+= port_stats.eth.raln;
-	p_stats->rx_carrier_errors		+= port_stats.eth.rfcr;
-	p_stats->rx_oversize_packets		+= port_stats.eth.rovr;
-	p_stats->rx_jabbers			+= port_stats.eth.rjbr;
-	p_stats->rx_undersize_packets		+= port_stats.eth.rund;
-	p_stats->rx_fragments			+= port_stats.eth.rfrg;
-	p_stats->tx_64_byte_packets		+= port_stats.eth.t64;
-	p_stats->tx_65_to_127_byte_packets	+= port_stats.eth.t127;
-	p_stats->tx_128_to_255_byte_packets	+= port_stats.eth.t255;
-	p_stats->tx_256_to_511_byte_packets	+= port_stats.eth.t511;
-	p_stats->tx_512_to_1023_byte_packets	+= port_stats.eth.t1023;
-	p_stats->tx_1024_to_1518_byte_packets	+= port_stats.eth.t1518;
-	p_stats->tx_1519_to_2047_byte_packets	+= port_stats.eth.t2047;
-	p_stats->tx_2048_to_4095_byte_packets	+= port_stats.eth.t4095;
-	p_stats->tx_4096_to_9216_byte_packets	+= port_stats.eth.t9216;
-	p_stats->tx_9217_to_16383_byte_packets	+= port_stats.eth.t16383;
-	p_stats->tx_pause_frames		+= port_stats.eth.txpf;
-	p_stats->tx_pfc_frames			+= port_stats.eth.txpp;
-	p_stats->tx_lpi_entry_count		+= port_stats.eth.tlpiec;
-	p_stats->tx_total_collisions		+= port_stats.eth.tncl;
-	p_stats->rx_mac_bytes			+= port_stats.eth.rbyte;
-	p_stats->rx_mac_uc_packets		+= port_stats.eth.rxuca;
-	p_stats->rx_mac_mc_packets		+= port_stats.eth.rxmca;
-	p_stats->rx_mac_bc_packets		+= port_stats.eth.rxbca;
-	p_stats->rx_mac_frames_ok		+= port_stats.eth.rxpok;
-	p_stats->tx_mac_bytes			+= port_stats.eth.tbyte;
-	p_stats->tx_mac_uc_packets		+= port_stats.eth.txuca;
-	p_stats->tx_mac_mc_packets		+= port_stats.eth.txmca;
-	p_stats->tx_mac_bc_packets		+= port_stats.eth.txbca;
-	p_stats->tx_mac_ctrl_frames		+= port_stats.eth.txcf;
+	p_common->rx_64_byte_packets += port_stats.eth.r64;
+	p_common->rx_65_to_127_byte_packets += port_stats.eth.r127;
+	p_common->rx_128_to_255_byte_packets += port_stats.eth.r255;
+	p_common->rx_256_to_511_byte_packets += port_stats.eth.r511;
+	p_common->rx_512_to_1023_byte_packets += port_stats.eth.r1023;
+	p_common->rx_1024_to_1518_byte_packets += port_stats.eth.r1518;
+	p_common->rx_crc_errors += port_stats.eth.rfcs;
+	p_common->rx_mac_crtl_frames += port_stats.eth.rxcf;
+	p_common->rx_pause_frames += port_stats.eth.rxpf;
+	p_common->rx_pfc_frames += port_stats.eth.rxpp;
+	p_common->rx_align_errors += port_stats.eth.raln;
+	p_common->rx_carrier_errors += port_stats.eth.rfcr;
+	p_common->rx_oversize_packets += port_stats.eth.rovr;
+	p_common->rx_jabbers += port_stats.eth.rjbr;
+	p_common->rx_undersize_packets += port_stats.eth.rund;
+	p_common->rx_fragments += port_stats.eth.rfrg;
+	p_common->tx_64_byte_packets += port_stats.eth.t64;
+	p_common->tx_65_to_127_byte_packets += port_stats.eth.t127;
+	p_common->tx_128_to_255_byte_packets += port_stats.eth.t255;
+	p_common->tx_256_to_511_byte_packets += port_stats.eth.t511;
+	p_common->tx_512_to_1023_byte_packets += port_stats.eth.t1023;
+	p_common->tx_1024_to_1518_byte_packets += port_stats.eth.t1518;
+	p_common->tx_pause_frames += port_stats.eth.txpf;
+	p_common->tx_pfc_frames += port_stats.eth.txpp;
+	p_common->rx_mac_bytes += port_stats.eth.rbyte;
+	p_common->rx_mac_uc_packets += port_stats.eth.rxuca;
+	p_common->rx_mac_mc_packets += port_stats.eth.rxmca;
+	p_common->rx_mac_bc_packets += port_stats.eth.rxbca;
+	p_common->rx_mac_frames_ok += port_stats.eth.rxpok;
+	p_common->tx_mac_bytes += port_stats.eth.tbyte;
+	p_common->tx_mac_uc_packets += port_stats.eth.txuca;
+	p_common->tx_mac_mc_packets += port_stats.eth.txmca;
+	p_common->tx_mac_bc_packets += port_stats.eth.txbca;
+	p_common->tx_mac_ctrl_frames += port_stats.eth.txcf;
 	for (j = 0; j < 8; j++) {
-		p_stats->brb_truncates	+= port_stats.brb.brb_truncate[j];
-		p_stats->brb_discards	+= port_stats.brb.brb_discard[j];
+		p_common->brb_truncates += port_stats.brb.brb_truncate[j];
+		p_common->brb_discards += port_stats.brb.brb_discard[j];
+	}
+
+	if (QED_IS_BB(p_hwfn->cdev)) {
+		struct qed_eth_stats_bb *p_bb = &p_stats->bb;
+
+		p_bb->rx_1519_to_1522_byte_packets +=
+		    port_stats.eth.u0.bb0.r1522;
+		p_bb->rx_1519_to_2047_byte_packets +=
+		    port_stats.eth.u0.bb0.r2047;
+		p_bb->rx_2048_to_4095_byte_packets +=
+		    port_stats.eth.u0.bb0.r4095;
+		p_bb->rx_4096_to_9216_byte_packets +=
+		    port_stats.eth.u0.bb0.r9216;
+		p_bb->rx_9217_to_16383_byte_packets +=
+		    port_stats.eth.u0.bb0.r16383;
+		p_bb->tx_1519_to_2047_byte_packets +=
+		    port_stats.eth.u1.bb1.t2047;
+		p_bb->tx_2048_to_4095_byte_packets +=
+		    port_stats.eth.u1.bb1.t4095;
+		p_bb->tx_4096_to_9216_byte_packets +=
+		    port_stats.eth.u1.bb1.t9216;
+		p_bb->tx_9217_to_16383_byte_packets +=
+		    port_stats.eth.u1.bb1.t16383;
+		p_bb->tx_lpi_entry_count += port_stats.eth.u2.bb2.tlpiec;
+		p_bb->tx_total_collisions += port_stats.eth.u2.bb2.tncl;
+	} else {
+		struct qed_eth_stats_ah *p_ah = &p_stats->ah;
+
+		p_ah->rx_1519_to_max_byte_packets +=
+		    port_stats.eth.u0.ah0.r1519_to_max;
+		p_ah->tx_1519_to_max_byte_packets =
+		    port_stats.eth.u1.ah1.t1519_to_max;
 	}
 }
 
diff --git a/drivers/net/ethernet/qlogic/qed/qed_main.c b/drivers/net/ethernet/qlogic/qed/qed_main.c
index 82cda70ecd7a..e973cd87aed9 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_main.c
@@ -216,6 +216,7 @@ int qed_fill_dev_info(struct qed_dev *cdev,
 	dev_info->rdma_supported = (cdev->hwfns[0].hw_info.personality ==
 				    QED_PCI_ETH_ROCE);
 	dev_info->is_mf_default = IS_MF_DEFAULT(&cdev->hwfns[0]);
+	dev_info->dev_type = cdev->type;
 	ether_addr_copy(dev_info->hw_mac, cdev->hwfns[0].hw_info.hw_mac_addr);
 
 	if (IS_PF(cdev)) {
@@ -1473,8 +1474,10 @@ void qed_get_protocol_stats(struct qed_dev *cdev,
 	switch (type) {
 	case QED_MCP_LAN_STATS:
 		qed_get_vport_stats(cdev, &eth_stats);
-		stats->lan_stats.ucast_rx_pkts = eth_stats.rx_ucast_pkts;
-		stats->lan_stats.ucast_tx_pkts = eth_stats.tx_ucast_pkts;
+		stats->lan_stats.ucast_rx_pkts =
+					eth_stats.common.rx_ucast_pkts;
+		stats->lan_stats.ucast_tx_pkts =
+					eth_stats.common.tx_ucast_pkts;
 		stats->lan_stats.fcs_err = -1;
 		break;
 	default:
diff --git a/drivers/net/ethernet/qlogic/qed/qed_mcp.h b/drivers/net/ethernet/qlogic/qed/qed_mcp.h
index 72a78b32e5f2..4464cf93a4cb 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.h
@@ -365,11 +365,10 @@ int qed_mcp_bist_nvm_test_get_image_att(struct qed_hwfn *p_hwfn,
 					    rel_pfid)
 #define MCP_PF_ID(p_hwfn) MCP_PF_ID_BY_REL(p_hwfn, (p_hwfn)->rel_pf_id)
 
-/* TODO - this is only correct as long as only BB is supported, and
- * no port-swapping is implemented; Afterwards we'll need to fix it.
- */
-#define MFW_PORT(_p_hwfn)       ((_p_hwfn)->abs_pf_id %	\
-				 ((_p_hwfn)->cdev->num_ports_in_engines * 2))
+#define MFW_PORT(_p_hwfn)       ((_p_hwfn)->abs_pf_id %			  \
+				 ((_p_hwfn)->cdev->num_ports_in_engines * \
+				  qed_device_num_engines((_p_hwfn)->cdev)))
+
 struct qed_mcp_info {
 	spinlock_t				lock;
 	bool					block_mb_sending;
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_ptp.c
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_reg_addr.h
diff --git a/drivers/net/ethernet/qlogic/qed/qed_sriov.c b/drivers/net/ethernet/qlogic/qed/qed_sriov.c
index d6d70462790a..b4f0a08eff52 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_sriov.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_sriov.c
@@ -535,14 +535,30 @@ int qed_iov_hw_info(struct qed_hwfn *p_hwfn)
 		return 0;
 	}
 
-	/* Calculate the first VF index - this is a bit tricky; Basically,
-	 * VFs start at offset 16 relative to PF0, and 2nd engine VFs begin
-	 * after the first engine's VFs.
+	/* First VF index based on offset is tricky:
+	 *  - If ARI is supported [likely], offset - (16 - pf_id) would
+	 *    provide the number for eng0. 2nd engine Vfs would begin
+	 *    after the first engine's VFs.
+	 *  - If !ARI, VFs would start on next device.
+	 *    so offset - (256 - pf_id) would provide the number.
+	 * Utilize the fact that (256 - pf_id) is achieved only by later
+	 * to diffrentiate between the two.
 	 */
-	cdev->p_iov_info->first_vf_in_pf = p_hwfn->cdev->p_iov_info->offset +
-					   p_hwfn->abs_pf_id - 16;
-	if (QED_PATH_ID(p_hwfn))
-		cdev->p_iov_info->first_vf_in_pf -= MAX_NUM_VFS_BB;
+
+	if (p_hwfn->cdev->p_iov_info->offset < (256 - p_hwfn->abs_pf_id)) {
+		u32 first = p_hwfn->cdev->p_iov_info->offset +
+			    p_hwfn->abs_pf_id - 16;
+
+		cdev->p_iov_info->first_vf_in_pf = first;
+
+		if (QED_PATH_ID(p_hwfn))
+			cdev->p_iov_info->first_vf_in_pf -= MAX_NUM_VFS_BB;
+	} else {
+		u32 first = p_hwfn->cdev->p_iov_info->offset +
+			    p_hwfn->abs_pf_id - 256;
+
+		cdev->p_iov_info->first_vf_in_pf = first;
+	}
 
 	DP_VERBOSE(p_hwfn, QED_MSG_IOV,
 		   "First VF in hwfn 0x%08x\n",
diff --git a/drivers/net/ethernet/qlogic/qede/qede.h b/drivers/net/ethernet/qlogic/qede/qede.h
index 1b7b1accb2cc..b841f7d2161f 100644
--- a/drivers/net/ethernet/qlogic/qede/qede.h
+++ b/drivers/net/ethernet/qlogic/qede/qede.h
@@ -34,7 +34,7 @@
 
 #define DRV_MODULE_SYM		qede
 
-struct qede_stats {
+struct qede_stats_common {
 	u64 no_buff_discards;
 	u64 packet_too_big_discard;
 	u64 ttl0_discard;
@@ -66,11 +66,6 @@ struct qede_stats {
 	u64 rx_256_to_511_byte_packets;
 	u64 rx_512_to_1023_byte_packets;
 	u64 rx_1024_to_1518_byte_packets;
-	u64 rx_1519_to_1522_byte_packets;
-	u64 rx_1519_to_2047_byte_packets;
-	u64 rx_2048_to_4095_byte_packets;
-	u64 rx_4096_to_9216_byte_packets;
-	u64 rx_9217_to_16383_byte_packets;
 	u64 rx_crc_errors;
 	u64 rx_mac_crtl_frames;
 	u64 rx_pause_frames;
@@ -87,17 +82,39 @@ struct qede_stats {
 	u64 tx_256_to_511_byte_packets;
 	u64 tx_512_to_1023_byte_packets;
 	u64 tx_1024_to_1518_byte_packets;
+	u64 tx_pause_frames;
+	u64 tx_pfc_frames;
+	u64 brb_truncates;
+	u64 brb_discards;
+	u64 tx_mac_ctrl_frames;
+};
+
+struct qede_stats_bb {
+	u64 rx_1519_to_1522_byte_packets;
+	u64 rx_1519_to_2047_byte_packets;
+	u64 rx_2048_to_4095_byte_packets;
+	u64 rx_4096_to_9216_byte_packets;
+	u64 rx_9217_to_16383_byte_packets;
 	u64 tx_1519_to_2047_byte_packets;
 	u64 tx_2048_to_4095_byte_packets;
 	u64 tx_4096_to_9216_byte_packets;
 	u64 tx_9217_to_16383_byte_packets;
-	u64 tx_pause_frames;
-	u64 tx_pfc_frames;
 	u64 tx_lpi_entry_count;
 	u64 tx_total_collisions;
-	u64 brb_truncates;
-	u64 brb_discards;
-	u64 tx_mac_ctrl_frames;
+};
+
+struct qede_stats_ah {
+	u64 rx_1519_to_max_byte_packets;
+	u64 tx_1519_to_max_byte_packets;
+};
+
+struct qede_stats {
+	struct qede_stats_common common;
+
+	union {
+		struct qede_stats_bb bb;
+		struct qede_stats_ah ah;
+	};
 };
 
 struct qede_vlan {
@@ -123,6 +140,10 @@ struct qede_dev {
 	struct qed_dev_eth_info dev_info;
 #define QEDE_MAX_RSS_CNT(edev)	((edev)->dev_info.num_queues)
 #define QEDE_MAX_TSS_CNT(edev)	((edev)->dev_info.num_queues)
+#define QEDE_IS_BB(edev) \
+	((edev)->dev_info.common.dev_type == QED_DEV_TYPE_BB)
+#define QEDE_IS_AH(edev) \
+	((edev)->dev_info.common.dev_type == QED_DEV_TYPE_AH)
 
 	struct qede_fastpath		*fp_array;
 	u8				req_num_tx;
diff --git a/drivers/net/ethernet/qlogic/qede/qede_ethtool.c b/drivers/net/ethernet/qlogic/qede/qede_ethtool.c
index 4c5145c9f11a..b1d57711eb58 100644
--- a/drivers/net/ethernet/qlogic/qede/qede_ethtool.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_ethtool.c
@@ -49,16 +49,33 @@ static const struct {
 	QEDE_TQSTAT(stopped_cnt),
 };
 
-#define QEDE_STAT_OFFSET(stat_name) (offsetof(struct qede_stats, stat_name))
-#define QEDE_STAT_STRING(stat_name) (#stat_name)
-#define _QEDE_STAT(stat_name, pf_only) \
-	 {QEDE_STAT_OFFSET(stat_name), QEDE_STAT_STRING(stat_name), pf_only}
-#define QEDE_PF_STAT(stat_name)	_QEDE_STAT(stat_name, true)
-#define QEDE_STAT(stat_name)	_QEDE_STAT(stat_name, false)
+#define QEDE_STAT_OFFSET(stat_name, type, base) \
+	(offsetof(type, stat_name) + (base))
+#define QEDE_STAT_STRING(stat_name)	(#stat_name)
+#define _QEDE_STAT(stat_name, type, base, attr) \
+	{QEDE_STAT_OFFSET(stat_name, type, base), \
+	 QEDE_STAT_STRING(stat_name), \
+	 attr}
+#define QEDE_STAT(stat_name) \
+	_QEDE_STAT(stat_name, struct qede_stats_common, 0, 0x0)
+#define QEDE_PF_STAT(stat_name) \
+	_QEDE_STAT(stat_name, struct qede_stats_common, 0, \
+		   BIT(QEDE_STAT_PF_ONLY))
+#define QEDE_PF_BB_STAT(stat_name) \
+	_QEDE_STAT(stat_name, struct qede_stats_bb, \
+		   offsetof(struct qede_stats, bb), \
+		   BIT(QEDE_STAT_PF_ONLY) | BIT(QEDE_STAT_BB_ONLY))
+#define QEDE_PF_AH_STAT(stat_name) \
+	_QEDE_STAT(stat_name, struct qede_stats_ah, \
+		   offsetof(struct qede_stats, ah), \
+		   BIT(QEDE_STAT_PF_ONLY) | BIT(QEDE_STAT_AH_ONLY))
 static const struct {
 	u64 offset;
 	char string[ETH_GSTRING_LEN];
-	bool pf_only;
+	unsigned long attr;
+#define QEDE_STAT_PF_ONLY	0
+#define QEDE_STAT_BB_ONLY	1
+#define QEDE_STAT_AH_ONLY	2
 } qede_stats_arr[] = {
 	QEDE_STAT(rx_ucast_bytes),
 	QEDE_STAT(rx_mcast_bytes),
@@ -80,22 +97,23 @@ static const struct {
 	QEDE_PF_STAT(rx_256_to_511_byte_packets),
 	QEDE_PF_STAT(rx_512_to_1023_byte_packets),
 	QEDE_PF_STAT(rx_1024_to_1518_byte_packets),
-	QEDE_PF_STAT(rx_1519_to_1522_byte_packets),
-	QEDE_PF_STAT(rx_1519_to_2047_byte_packets),
-	QEDE_PF_STAT(rx_2048_to_4095_byte_packets),
-	QEDE_PF_STAT(rx_4096_to_9216_byte_packets),
-	QEDE_PF_STAT(rx_9217_to_16383_byte_packets),
+	QEDE_PF_BB_STAT(rx_1519_to_1522_byte_packets),
+	QEDE_PF_BB_STAT(rx_1519_to_2047_byte_packets),
+	QEDE_PF_BB_STAT(rx_2048_to_4095_byte_packets),
+	QEDE_PF_BB_STAT(rx_4096_to_9216_byte_packets),
+	QEDE_PF_BB_STAT(rx_9217_to_16383_byte_packets),
+	QEDE_PF_AH_STAT(rx_1519_to_max_byte_packets),
 	QEDE_PF_STAT(tx_64_byte_packets),
 	QEDE_PF_STAT(tx_65_to_127_byte_packets),
 	QEDE_PF_STAT(tx_128_to_255_byte_packets),
 	QEDE_PF_STAT(tx_256_to_511_byte_packets),
 	QEDE_PF_STAT(tx_512_to_1023_byte_packets),
 	QEDE_PF_STAT(tx_1024_to_1518_byte_packets),
-	QEDE_PF_STAT(tx_1519_to_2047_byte_packets),
-	QEDE_PF_STAT(tx_2048_to_4095_byte_packets),
-	QEDE_PF_STAT(tx_4096_to_9216_byte_packets),
-	QEDE_PF_STAT(tx_9217_to_16383_byte_packets),
-
+	QEDE_PF_BB_STAT(tx_1519_to_2047_byte_packets),
+	QEDE_PF_BB_STAT(tx_2048_to_4095_byte_packets),
+	QEDE_PF_BB_STAT(tx_4096_to_9216_byte_packets),
+	QEDE_PF_BB_STAT(tx_9217_to_16383_byte_packets),
+	QEDE_PF_AH_STAT(tx_1519_to_max_byte_packets),
 	QEDE_PF_STAT(rx_mac_crtl_frames),
 	QEDE_PF_STAT(tx_mac_ctrl_frames),
 	QEDE_PF_STAT(rx_pause_frames),
@@ -110,8 +128,8 @@ static const struct {
 	QEDE_PF_STAT(rx_jabbers),
 	QEDE_PF_STAT(rx_undersize_packets),
 	QEDE_PF_STAT(rx_fragments),
-	QEDE_PF_STAT(tx_lpi_entry_count),
-	QEDE_PF_STAT(tx_total_collisions),
+	QEDE_PF_BB_STAT(tx_lpi_entry_count),
+	QEDE_PF_BB_STAT(tx_total_collisions),
 	QEDE_PF_STAT(brb_truncates),
 	QEDE_PF_STAT(brb_discards),
 	QEDE_STAT(no_buff_discards),
@@ -129,6 +147,12 @@ static const struct {
 };
 
 #define QEDE_NUM_STATS	ARRAY_SIZE(qede_stats_arr)
+#define QEDE_STAT_IS_PF_ONLY(i) \
+	test_bit(QEDE_STAT_PF_ONLY, &qede_stats_arr[i].attr)
+#define QEDE_STAT_IS_BB_ONLY(i) \
+	test_bit(QEDE_STAT_BB_ONLY, &qede_stats_arr[i].attr)
+#define QEDE_STAT_IS_AH_ONLY(i) \
+	test_bit(QEDE_STAT_AH_ONLY, &qede_stats_arr[i].attr)
 
 enum {
 	QEDE_PRI_FLAG_CMT,
@@ -182,6 +206,13 @@ static void qede_get_strings_stats_rxq(struct qede_dev *edev,
 	}
 }
 
+static bool qede_is_irrelevant_stat(struct qede_dev *edev, int stat_index)
+{
+	return (IS_VF(edev) && QEDE_STAT_IS_PF_ONLY(stat_index)) ||
+	       (QEDE_IS_BB(edev) && QEDE_STAT_IS_AH_ONLY(stat_index)) ||
+	       (QEDE_IS_AH(edev) && QEDE_STAT_IS_BB_ONLY(stat_index));
+}
+
 static void qede_get_strings_stats(struct qede_dev *edev, u8 *buf)
 {
 	struct qede_fastpath *fp;
@@ -200,7 +231,7 @@ static void qede_get_strings_stats(struct qede_dev *edev, u8 *buf)
 
 	/* Account for non-queue statistics */
 	for (i = 0; i < QEDE_NUM_STATS; i++) {
-		if (IS_VF(edev) && qede_stats_arr[i].pf_only)
+		if (qede_is_irrelevant_stat(edev, i))
 			continue;
 		strcpy(buf, qede_stats_arr[i].string);
 		buf += ETH_GSTRING_LEN;
@@ -270,7 +301,7 @@ static void qede_get_ethtool_stats(struct net_device *dev,
 	}
 
 	for (i = 0; i < QEDE_NUM_STATS; i++) {
-		if (IS_VF(edev) && qede_stats_arr[i].pf_only)
+		if (qede_is_irrelevant_stat(edev, i))
 			continue;
 		*buf = *((u64 *)(((void *)&edev->stats) +
 				 qede_stats_arr[i].offset));
@@ -284,17 +315,13 @@ static void qede_get_ethtool_stats(struct net_device *dev,
 static int qede_get_sset_count(struct net_device *dev, int stringset)
 {
 	struct qede_dev *edev = netdev_priv(dev);
-	int num_stats = QEDE_NUM_STATS;
+	int num_stats = QEDE_NUM_STATS, i;
 
 	switch (stringset) {
 	case ETH_SS_STATS:
-		if (IS_VF(edev)) {
-			int i;
-
-			for (i = 0; i < QEDE_NUM_STATS; i++)
-				if (qede_stats_arr[i].pf_only)
-					num_stats--;
-		}
+		for (i = 0; i < QEDE_NUM_STATS; i++)
+			if (qede_is_irrelevant_stat(edev, i))
+				num_stats--;
 
 		/* Account for the Regular Tx statistics */
 		num_stats += QEDE_TSS_COUNT(edev) * QEDE_NUM_TQSTATS;
* Unmerged path drivers/net/ethernet/qlogic/qede/qede_main.c
* Unmerged path include/linux/qed/qed_if.h
diff --git a/include/linux/qed/rdma_common.h b/include/linux/qed/rdma_common.h
index 7663725faa94..240ec1bef6f0 100644
--- a/include/linux/qed/rdma_common.h
+++ b/include/linux/qed/rdma_common.h
@@ -28,7 +28,8 @@
 #define RDMA_MAX_PDS                            (64 * 1024)
 
 #define RDMA_NUM_STATISTIC_COUNTERS                     MAX_NUM_VPORTS
-#define RDMA_NUM_STATISTIC_COUNTERS_BB			MAX_NUM_VPORTS_BB
+#define RDMA_NUM_STATISTIC_COUNTERS_K2                  MAX_NUM_VPORTS_K2
+#define RDMA_NUM_STATISTIC_COUNTERS_BB                  MAX_NUM_VPORTS_BB
 
 #define RDMA_TASK_TYPE (PROTOCOLID_ROCE)
 
