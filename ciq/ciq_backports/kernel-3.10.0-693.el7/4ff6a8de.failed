perf/core: Generalize event->group_flags

jira LE-1907
cve CVE-2017-6001
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Carrillo-Cisneros <davidcc@google.com>
commit 4ff6a8debf48a7bf48e93c01da720785070d3a25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4ff6a8de.failed

Currently, PERF_GROUP_SOFTWARE is used in the group_flags field of a
group's leader to indicate that is_software_event(event) is true for all
events in a group. This is the only usage of event->group_flags.

This pattern of setting a group level flags when all events in the group
share a property is useful for the flag introduced in the next patch and
for future CQM/CMT flags. So this patches generalizes group_flags to work
as an aggregate of event level flags.

PERF_GROUP_SOFTWARE denotes an inmutable event's property. All other flags
that I intend to add are also determinable at event initialization.
To better convey the above, this patch renames event's group_flags to
group_caps and PERF_GROUP_SOFTWARE to PERF_EV_CAP_SOFTWARE.

Individual event flags are stored in the new event->event_caps. Since the
cap flags do not change after event initialization, there is no need to
serialize event_caps. This new field is used when events are added to a
context, similarly to how PERF_GROUP_SOFTWARE and is_software_event()
worked.

Lastly, for consistency, updates is_software_event() to rely in event_cap
instead of the context index.

	Signed-off-by: David Carrillo-Cisneros <davidcc@google.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Kan Liang <kan.liang@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Paul Turner <pjt@google.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vegard Nossum <vegard.nossum@gmail.com>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
Link: http://lkml.kernel.org/r/1471467307-61171-3-git-send-email-davidcc@google.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 4ff6a8debf48a7bf48e93c01da720785070d3a25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/core.c
diff --cc kernel/events/core.c
index 44be586a54d8,8c42a5ae9030..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -8602,6 -9481,15 +8599,18 @@@ SYSCALL_DEFINE5(perf_event_open
  	 */
  	pmu = event->pmu;
  
++<<<<<<< HEAD
++=======
+ 	if (attr.use_clockid) {
+ 		err = perf_event_set_clock(event, attr.clockid);
+ 		if (err)
+ 			goto err_alloc;
+ 	}
+ 
+ 	if (pmu->task_ctx_nr == perf_sw_context)
+ 		event->event_caps |= PERF_EV_CAP_SOFTWARE;
+ 
++>>>>>>> 4ff6a8debf48 (perf/core: Generalize event->group_flags)
  	if (group_leader &&
  	    (is_software_event(event) != is_software_event(group_leader))) {
  		if (is_software_event(event)) {
diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index 6141b9801ed0..73f9926c924b 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -347,9 +347,12 @@ typedef void (*perf_overflow_handler_t)(struct perf_event *,
 					struct perf_sample_data *,
 					struct pt_regs *regs);
 
-enum perf_group_flag {
-	PERF_GROUP_SOFTWARE		= 0x1,
-};
+/*
+ * Event capabilities. For event_caps and groups caps.
+ *
+ * PERF_EV_CAP_SOFTWARE: Is a software event.
+ */
+#define PERF_EV_CAP_SOFTWARE		BIT(0)
 
 #define SWEVENT_HLIST_BITS		8
 #define SWEVENT_HLIST_SIZE		(1 << SWEVENT_HLIST_BITS)
@@ -390,7 +393,12 @@ struct perf_event {
 	struct list_head		sibling_list;
 	struct hlist_node		hlist_entry;
 	int				nr_siblings;
-	int				group_flags;
+
+	/* Not serialized. Only written during event initialization. */
+	int				event_caps;
+	/* The cumulative AND of all event_caps for events in this group. */
+	int				group_caps;
+
 	struct perf_event		*group_leader;
 	struct pmu			*pmu;
 
@@ -804,7 +812,7 @@ static inline bool is_sampling_event(struct perf_event *event)
  */
 static inline int is_software_event(struct perf_event *event)
 {
-	return event->pmu->task_ctx_nr == perf_sw_context;
+	return event->event_caps & PERF_EV_CAP_SOFTWARE;
 }
 
 extern struct static_key perf_swevent_enabled[PERF_COUNT_SW_MAX];
* Unmerged path kernel/events/core.c
