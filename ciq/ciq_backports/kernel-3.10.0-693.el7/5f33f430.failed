HID: wacom: Clean up value reading

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Clean up value reading (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 92.06%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 5f33f430efe3ce2dfe4e9c5eeabb89ea5df145b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5f33f430.failed

Make the logic for reading X, Y, distance, and pressure a bit more
clear. An additional bit was stuffed into the packet format many
models back, and /most/ devices in use will use it. If we happen
to be dealing with a particularly old tablet, just shift it off
the end to pretend we never read it.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 5f33f430efe3ce2dfe4e9c5eeabb89ea5df145b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index bdf17efa93aa,0008650e3bdb..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -488,334 -756,243 +488,365 @@@ static int wacom_intuos_inout(struct wa
  	return 0;
  }
  
 -static int wacom_remote_irq(struct wacom_wac *wacom_wac, size_t len)
 +static void wacom_intuos_general(struct wacom_wac *wacom)
  {
 -	unsigned char *data = wacom_wac->data;
 -	struct input_dev *input = wacom_wac->pad_input;
 -	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
 -	struct wacom_features *features = &wacom_wac->features;
 -	int bat_charging, bat_percent, touch_ring_mode;
 -	__u32 serial;
 -	int i;
 +	struct wacom_features *features = &wacom->features;
 +	unsigned char *data = wacom->data;
++<<<<<<< HEAD
 +	struct input_dev *input = wacom->input;
 +	unsigned int t;
++=======
++	struct input_dev *input = wacom->pen_input;
++	int idx = (features->type == INTUOS) ? (data[1] & 0x01) : 0;
++	unsigned char type = (data[1] >> 1) & 0x0F;
++	unsigned int x, y, distance, t;
++>>>>>>> 5f33f430efe3 (HID: wacom: Clean up value reading)
  
 -	if (data[0] != WACOM_REPORT_REMOTE) {
 -		dev_dbg(input->dev.parent,
 -			"%s: received unknown report #%d", __func__, data[0]);
 -		return 0;
 +	/* general pen packet */
 +	if ((data[1] & 0xb8) == 0xa0) {
 +		t = (data[6] << 2) | ((data[7] >> 6) & 3);
 +		if (features->type >= INTUOS4S && features->type <= WACOM_24HD) {
 +			t = (t << 1) | (data[1] & 1);
 +		}
 +		input_report_abs(input, ABS_PRESSURE, t);
 +		input_report_abs(input, ABS_TILT_X,
 +				 (((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
 +		input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
 +		input_report_key(input, BTN_STYLUS, data[1] & 2);
 +		input_report_key(input, BTN_STYLUS2, data[1] & 4);
 +		input_report_key(input, BTN_TOUCH, t > 10);
  	}
  
 -	serial = data[3] + (data[4] << 8) + (data[5] << 16);
 -	wacom_wac->id[0] = PAD_DEVICE_ID;
 -
 -	input_report_key(input, BTN_0, (data[9] & 0x01));
 -	input_report_key(input, BTN_1, (data[9] & 0x02));
 -	input_report_key(input, BTN_2, (data[9] & 0x04));
 -	input_report_key(input, BTN_3, (data[9] & 0x08));
 -	input_report_key(input, BTN_4, (data[9] & 0x10));
 -	input_report_key(input, BTN_5, (data[9] & 0x20));
 -	input_report_key(input, BTN_6, (data[9] & 0x40));
 -	input_report_key(input, BTN_7, (data[9] & 0x80));
 -
 -	input_report_key(input, BTN_8, (data[10] & 0x01));
 -	input_report_key(input, BTN_9, (data[10] & 0x02));
 -	input_report_key(input, BTN_A, (data[10] & 0x04));
 -	input_report_key(input, BTN_B, (data[10] & 0x08));
 -	input_report_key(input, BTN_C, (data[10] & 0x10));
 -	input_report_key(input, BTN_X, (data[10] & 0x20));
 -	input_report_key(input, BTN_Y, (data[10] & 0x40));
 -	input_report_key(input, BTN_Z, (data[10] & 0x80));
 -
 -	input_report_key(input, BTN_BASE, (data[11] & 0x01));
 -	input_report_key(input, BTN_BASE2, (data[11] & 0x02));
 -
 -	if (data[12] & 0x80)
 -		input_report_abs(input, ABS_WHEEL, (data[12] & 0x7f));
 -	else
 -		input_report_abs(input, ABS_WHEEL, 0);
 -
 -	bat_percent = data[7] & 0x7f;
 -	bat_charging = !!(data[7] & 0x80);
 -
 -	if (data[9] | data[10] | (data[11] & 0x03) | data[12])
 -		input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 -	else
 -		input_report_abs(input, ABS_MISC, 0);
 -
 -	input_event(input, EV_MSC, MSC_SERIAL, serial);
 +	/* airbrush second packet */
 +	if ((data[1] & 0xbc) == 0xb4) {
 +		input_report_abs(input, ABS_WHEEL,
 +				(data[6] << 2) | ((data[7] >> 6) & 3));
 +		input_report_abs(input, ABS_TILT_X,
 +				 (((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
 +		input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
 +	}
 +}
  
 -	/*Which mode select (LED light) is currently on?*/
 -	touch_ring_mode = (data[11] & 0xC0) >> 6;
 +static int wacom_intuos_irq(struct wacom_wac *wacom)
 +{
 +	struct wacom_features *features = &wacom->features;
 +	unsigned char *data = wacom->data;
 +	struct input_dev *input = wacom->input;
 +	unsigned int t;
 +	int idx = 0, result;
  
 -	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
 -		if (wacom_wac->serial[i] == serial)
 -			wacom->led.select[i] = touch_ring_mode;
 +	if (data[0] != WACOM_REPORT_PENABLED &&
 +	    data[0] != WACOM_REPORT_INTUOSREAD &&
 +	    data[0] != WACOM_REPORT_INTUOSWRITE &&
 +	    data[0] != WACOM_REPORT_INTUOSPAD &&
 +	    data[0] != WACOM_REPORT_CINTIQ &&
 +	    data[0] != WACOM_REPORT_CINTIQPAD &&
 +	    data[0] != WACOM_REPORT_INTUOS5PAD) {
 +		dev_dbg(input->dev.parent,
 +			"%s: received unknown report #%d\n", __func__, data[0]);
 +                return 0;
  	}
  
 -	if (!wacom->battery &&
 -	    !(features->quirks & WACOM_QUIRK_BATTERY)) {
 -		features->quirks |= WACOM_QUIRK_BATTERY;
 -		INIT_WORK(&wacom->work, wacom_battery_work);
 -		wacom_schedule_work(wacom_wac);
 -	}
 +	/* tool number */
 +	if (features->type == INTUOS)
 +		idx = data[1] & 0x01;
  
 -	wacom_notify_battery(wacom_wac, bat_percent, bat_charging, 1,
 -			     bat_charging);
 +	/* pad packets. Works as a second tool and is always in prox */
 +	if (data[0] == WACOM_REPORT_INTUOSPAD || data[0] == WACOM_REPORT_INTUOS5PAD ||
 +	    data[0] == WACOM_REPORT_CINTIQPAD) {
 +		if (features->type >= INTUOS4S && features->type <= INTUOS4L) {
 +			input_report_key(input, BTN_0, (data[2] & 0x01));
 +			input_report_key(input, BTN_1, (data[3] & 0x01));
 +			input_report_key(input, BTN_2, (data[3] & 0x02));
 +			input_report_key(input, BTN_3, (data[3] & 0x04));
 +			input_report_key(input, BTN_4, (data[3] & 0x08));
 +			input_report_key(input, BTN_5, (data[3] & 0x10));
 +			input_report_key(input, BTN_6, (data[3] & 0x20));
 +			if (data[1] & 0x80) {
 +				input_report_abs(input, ABS_WHEEL, (data[1] & 0x7f));
 +			} else {
 +				/* Out of proximity, clear wheel value. */
 +				input_report_abs(input, ABS_WHEEL, 0);
 +			}
 +			if (features->type != INTUOS4S) {
 +				input_report_key(input, BTN_7, (data[3] & 0x40));
 +				input_report_key(input, BTN_8, (data[3] & 0x80));
 +			}
 +			if (data[1] | (data[2] & 0x01) | data[3]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type == DTK) {
 +			input_report_key(input, BTN_0, (data[6] & 0x01));
 +			input_report_key(input, BTN_1, (data[6] & 0x02));
 +			input_report_key(input, BTN_2, (data[6] & 0x04));
 +			input_report_key(input, BTN_3, (data[6] & 0x08));
 +			input_report_key(input, BTN_4, (data[6] & 0x10));
 +			input_report_key(input, BTN_5, (data[6] & 0x20));
 +			if (data[6] & 0x3f) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type == WACOM_13HD) {
 +			input_report_key(input, BTN_0, (data[3] & 0x01));
 +			input_report_key(input, BTN_1, (data[4] & 0x01));
 +			input_report_key(input, BTN_2, (data[4] & 0x02));
 +			input_report_key(input, BTN_3, (data[4] & 0x04));
 +			input_report_key(input, BTN_4, (data[4] & 0x08));
 +			input_report_key(input, BTN_5, (data[4] & 0x10));
 +			input_report_key(input, BTN_6, (data[4] & 0x20));
 +			input_report_key(input, BTN_7, (data[4] & 0x40));
 +			input_report_key(input, BTN_8, (data[4] & 0x80));
 +			if ((data[3] & 0x01) | data[4]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type == WACOM_24HD) {
 +			input_report_key(input, BTN_0, (data[6] & 0x01));
 +			input_report_key(input, BTN_1, (data[6] & 0x02));
 +			input_report_key(input, BTN_2, (data[6] & 0x04));
 +			input_report_key(input, BTN_3, (data[6] & 0x08));
 +			input_report_key(input, BTN_4, (data[6] & 0x10));
 +			input_report_key(input, BTN_5, (data[6] & 0x20));
 +			input_report_key(input, BTN_6, (data[6] & 0x40));
 +			input_report_key(input, BTN_7, (data[6] & 0x80));
 +			input_report_key(input, BTN_8, (data[8] & 0x01));
 +			input_report_key(input, BTN_9, (data[8] & 0x02));
 +			input_report_key(input, BTN_A, (data[8] & 0x04));
 +			input_report_key(input, BTN_B, (data[8] & 0x08));
 +			input_report_key(input, BTN_C, (data[8] & 0x10));
 +			input_report_key(input, BTN_X, (data[8] & 0x20));
 +			input_report_key(input, BTN_Y, (data[8] & 0x40));
 +			input_report_key(input, BTN_Z, (data[8] & 0x80));
  
 -	return 1;
 -}
 +			/*
 +			 * Three "buttons" are available on the 24HD which are
 +			 * physically implemented as a touchstrip. Each button
 +			 * is approximately 3 bits wide with a 2 bit spacing.
 +			 * The raw touchstrip bits are stored at:
 +			 *    ((data[3] & 0x1f) << 8) | data[4])
 +			 */
 +			input_report_key(input, KEY_PROG1, data[4] & 0x07);
 +			input_report_key(input, KEY_PROG2, data[4] & 0xE0);
 +			input_report_key(input, KEY_PROG3, data[3] & 0x1C);
  
 -static int wacom_remote_status_irq(struct wacom_wac *wacom_wac, size_t len)
 -{
 -	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
 -	unsigned char *data = wacom_wac->data;
 -	int i;
 +			if (data[1] & 0x80) {
 +				input_report_abs(input, ABS_WHEEL, (data[1] & 0x7f));
 +			} else {
 +				/* Out of proximity, clear wheel value. */
 +				input_report_abs(input, ABS_WHEEL, 0);
 +			}
  
 -	if (data[0] != WACOM_REPORT_DEVICE_LIST)
 -		return 0;
 +			if (data[2] & 0x80) {
 +				input_report_abs(input, ABS_THROTTLE, (data[2] & 0x7f));
 +			} else {
 +				/* Out of proximity, clear second wheel value. */
 +				input_report_abs(input, ABS_THROTTLE, 0);
 +			}
  
 -	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
 -		int j = i * 6;
 -		int serial = (data[j+6] << 16) + (data[j+5] << 8) + data[j+4];
 -		bool connected = data[j+2];
 +			if (data[1] | data[2] | (data[3] & 0x1f) | data[4] | data[6] | data[8]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type == WACOM_27QHD) {
 +			input_report_key(input, KEY_PROG1, data[2] & 0x01);
 +			input_report_key(input, KEY_PROG2, data[2] & 0x02);
 +			input_report_key(input, KEY_PROG3, data[2] & 0x04);
 +
 +			input_report_abs(input, ABS_X, be16_to_cpup((__be16 *)&data[4]));
 +			input_report_abs(input, ABS_Y, be16_to_cpup((__be16 *)&data[6]));
 +			input_report_abs(input, ABS_Z, be16_to_cpup((__be16 *)&data[8]));
 +			if ((data[2] & 0x07) | data[4] | data[5] | data[6] | data[7] | data[8] | data[9]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type >= INTUOS5S && features->type <= INTUOSPL) {
 +			int i;
  
 -		if (connected) {
 -			int k;
 +			/* Touch ring mode switch has no capacitive sensor */
 +			input_report_key(input, BTN_0, (data[3] & 0x01));
  
 -			if (wacom_wac->serial[i] == serial)
 -				continue;
 +			/*
 +			 * ExpressKeys on Intuos5/Intuos Pro have a capacitive sensor in
 +			 * addition to the mechanical switch. Switch data is
 +			 * stored in data[4], capacitive data in data[5].
 +			 */
 +			for (i = 0; i < 8; i++)
 +				input_report_key(input, BTN_1 + i, data[4] & (1 << i));
  
 -			if (wacom_wac->serial[i]) {
 -				wacom_remote_destroy_attr_group(wacom,
 -							wacom_wac->serial[i]);
 +			if (data[2] & 0x80) {
 +				input_report_abs(input, ABS_WHEEL, (data[2] & 0x7f));
 +			} else {
 +				/* Out of proximity, clear wheel value. */
 +				input_report_abs(input, ABS_WHEEL, 0);
  			}
  
 -			/* A remote can pair more than once with an EKR,
 -			 * check to make sure this serial isn't already paired.
 -			 */
 -			for (k = 0; k < WACOM_MAX_REMOTES; k++) {
 -				if (wacom_wac->serial[k] == serial)
 -					break;
 +			if (data[2] | (data[3] & 0x01) | data[4] | data[5]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
  			}
 -
 -			if (k < WACOM_MAX_REMOTES) {
 -				wacom_wac->serial[i] = serial;
 -				continue;
 +		} else {
 +			if (features->type == WACOM_21UX2 || features->type == WACOM_22HD) {
 +				input_report_key(input, BTN_0, (data[5] & 0x01));
 +				input_report_key(input, BTN_1, (data[6] & 0x01));
 +				input_report_key(input, BTN_2, (data[6] & 0x02));
 +				input_report_key(input, BTN_3, (data[6] & 0x04));
 +				input_report_key(input, BTN_4, (data[6] & 0x08));
 +				input_report_key(input, BTN_5, (data[6] & 0x10));
 +				input_report_key(input, BTN_6, (data[6] & 0x20));
 +				input_report_key(input, BTN_7, (data[6] & 0x40));
 +				input_report_key(input, BTN_8, (data[6] & 0x80));
 +				input_report_key(input, BTN_9, (data[7] & 0x01));
 +				input_report_key(input, BTN_A, (data[8] & 0x01));
 +				input_report_key(input, BTN_B, (data[8] & 0x02));
 +				input_report_key(input, BTN_C, (data[8] & 0x04));
 +				input_report_key(input, BTN_X, (data[8] & 0x08));
 +				input_report_key(input, BTN_Y, (data[8] & 0x10));
 +				input_report_key(input, BTN_Z, (data[8] & 0x20));
 +				input_report_key(input, BTN_BASE, (data[8] & 0x40));
 +				input_report_key(input, BTN_BASE2, (data[8] & 0x80));
 +
 +				if (features->type == WACOM_22HD) {
 +					input_report_key(input, KEY_PROG1, data[9] & 0x01);
 +					input_report_key(input, KEY_PROG2, data[9] & 0x02);
 +					input_report_key(input, KEY_PROG3, data[9] & 0x04);
 +				}
 +			} else {
 +				input_report_key(input, BTN_0, (data[5] & 0x01));
 +				input_report_key(input, BTN_1, (data[5] & 0x02));
 +				input_report_key(input, BTN_2, (data[5] & 0x04));
 +				input_report_key(input, BTN_3, (data[5] & 0x08));
 +				input_report_key(input, BTN_4, (data[6] & 0x01));
 +				input_report_key(input, BTN_5, (data[6] & 0x02));
 +				input_report_key(input, BTN_6, (data[6] & 0x04));
 +				input_report_key(input, BTN_7, (data[6] & 0x08));
 +				input_report_key(input, BTN_8, (data[5] & 0x10));
 +				input_report_key(input, BTN_9, (data[6] & 0x10));
  			}
 -			wacom_remote_create_attr_group(wacom, serial, i);
 +			input_report_abs(input, ABS_RX, ((data[1] & 0x1f) << 8) | data[2]);
 +			input_report_abs(input, ABS_RY, ((data[3] & 0x1f) << 8) | data[4]);
  
 -		} else if (wacom_wac->serial[i]) {
 -			wacom_remote_destroy_attr_group(wacom,
 -							wacom_wac->serial[i]);
 +			if ((data[5] & 0x1f) | data[6] | (data[1] & 0x1f) |
 +				data[2] | (data[3] & 0x1f) | data[4] | data[8] |
 +				(data[7] & 0x01)) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
  		}
 +		input_event(input, EV_MSC, MSC_SERIAL, 0xffffffff);
 +                return 1;
  	}
  
 -	return 0;
 -}
 -
 -static int wacom_intuos_general(struct wacom_wac *wacom)
 -{
 -	struct wacom_features *features = &wacom->features;
 -	unsigned char *data = wacom->data;
 -	struct input_dev *input = wacom->pen_input;
 -	int idx = (features->type == INTUOS) ? (data[1] & 0x01) : 0;
 -	unsigned char type = (data[1] >> 1) & 0x0F;
 -	unsigned int x, y, distance, t;
 -
 -	if (data[0] != WACOM_REPORT_PENABLED && data[0] != WACOM_REPORT_CINTIQ &&
 -		data[0] != WACOM_REPORT_INTUOS_PEN)
 -		return 0;
 +	/* process in/out prox events */
 +	result = wacom_intuos_inout(wacom);
 +	if (result)
 +                return result - 1;
  
- 	if (features->type >= INTUOS3S) {
- 		input_report_abs(input, ABS_X, (data[2] << 9) | (data[3] << 1) | ((data[9] >> 1) & 1));
- 		input_report_abs(input, ABS_Y, (data[4] << 9) | (data[5] << 1) | (data[9] & 1));
- 		input_report_abs(input, ABS_DISTANCE, ((data[9] >> 2) & 0x3f));
- 	} else {
- 		input_report_abs(input, ABS_X, be16_to_cpup((__be16 *)&data[2]));
- 		input_report_abs(input, ABS_Y, be16_to_cpup((__be16 *)&data[4]));
- 		input_report_abs(input, ABS_DISTANCE, ((data[9] >> 3) & 0x1f));
+ 	x = (be16_to_cpup((__be16 *)&data[2]) << 1) | ((data[9] >> 1) & 1);
+ 	y = (be16_to_cpup((__be16 *)&data[4]) << 1) | (data[9] & 1);
+ 	distance = data[9] >> 2;
+ 	if (features->type < INTUOS3S) {
+ 		x >>= 1;
+ 		y >>= 1;
+ 		distance >>= 1;
  	}
+ 	input_report_abs(input, ABS_X, x);
+ 	input_report_abs(input, ABS_Y, y);
+ 	input_report_abs(input, ABS_DISTANCE, distance);
  
++<<<<<<< HEAD
 +	/* process general packets */
 +	wacom_intuos_general(wacom);
++=======
+ 	switch (type) {
+ 	case 0x00:
+ 	case 0x01:
+ 	case 0x02:
+ 	case 0x03:
+ 		/* general pen packet */
+ 		t = (data[6] << 3) | ((data[7] & 0xC0) >> 5) | (data[1] & 1);
+ 		if (features->pressure_max < 2047)
+ 			t >>= 1;
+ 		input_report_abs(input, ABS_PRESSURE, t);
+ 		if (features->type != INTUOSHT2) {
+ 		    input_report_abs(input, ABS_TILT_X,
+ 				 (((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
+ 		    input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
+ 		}
+ 		input_report_key(input, BTN_STYLUS, data[1] & 2);
+ 		input_report_key(input, BTN_STYLUS2, data[1] & 4);
+ 		input_report_key(input, BTN_TOUCH, t > 10);
+ 		break;
++>>>>>>> 5f33f430efe3 (HID: wacom: Clean up value reading)
  
 -	case 0x0a:
 -		/* airbrush second packet */
 -		input_report_abs(input, ABS_WHEEL,
 -				(data[6] << 2) | ((data[7] >> 6) & 3));
 -		input_report_abs(input, ABS_TILT_X,
 -				 (((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
 -		input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
 -		break;
 -
 -	case 0x05:
 -		/* Rotation packet */
 -		if (features->type >= INTUOS3S) {
 -			/* I3 marker pen rotation */
 -			t = (data[6] << 3) | ((data[7] >> 5) & 7);
 -			t = (data[7] & 0x20) ? ((t > 900) ? ((t-1) / 2 - 1350) :
 -				((t-1) / 2 + 450)) : (450 - t / 2) ;
 -			input_report_abs(input, ABS_Z, t);
 -		} else {
 -			/* 4D mouse 2nd packet */
 -			t = (data[6] << 3) | ((data[7] >> 5) & 7);
 -			input_report_abs(input, ABS_RZ, (data[7] & 0x20) ?
 -				((t - 1) / 2) : -t / 2);
 -		}
 -		break;
 -
 -	case 0x04:
 -		/* 4D mouse 1st packet */
 -		input_report_key(input, BTN_LEFT,   data[8] & 0x01);
 -		input_report_key(input, BTN_MIDDLE, data[8] & 0x02);
 -		input_report_key(input, BTN_RIGHT,  data[8] & 0x04);
 -
 -		input_report_key(input, BTN_SIDE,   data[8] & 0x20);
 -		input_report_key(input, BTN_EXTRA,  data[8] & 0x10);
 -		t = (data[6] << 2) | ((data[7] >> 6) & 3);
 -		input_report_abs(input, ABS_THROTTLE, (data[8] & 0x08) ? -t : t);
 -		break;
 +	/* 4D mouse, 2D mouse, marker pen rotation, tilt mouse, or Lens cursor packets */
 +	if ((data[1] & 0xbc) == 0xa8 || (data[1] & 0xbe) == 0xb0 || (data[1] & 0xbc) == 0xac) {
  
 -	case 0x06:
 -		/* I4 mouse */
 -		input_report_key(input, BTN_LEFT,   data[6] & 0x01);
 -		input_report_key(input, BTN_MIDDLE, data[6] & 0x02);
 -		input_report_key(input, BTN_RIGHT,  data[6] & 0x04);
 -		input_report_rel(input, REL_WHEEL, ((data[7] & 0x80) >> 7)
 -				 - ((data[7] & 0x40) >> 6));
 -		input_report_key(input, BTN_SIDE,   data[6] & 0x08);
 -		input_report_key(input, BTN_EXTRA,  data[6] & 0x10);
 +		if (data[1] & 0x02) {
 +			/* Rotation packet */
 +			if (features->type >= INTUOS3S) {
 +				/* I3 marker pen rotation */
 +				t = (data[6] << 3) | ((data[7] >> 5) & 7);
 +				t = (data[7] & 0x20) ? ((t > 900) ? ((t-1) / 2 - 1350) :
 +					((t-1) / 2 + 450)) : (450 - t / 2) ;
 +				input_report_abs(input, ABS_Z, t);
 +			} else {
 +				/* 4D mouse rotation packet */
 +				t = (data[6] << 3) | ((data[7] >> 5) & 7);
 +				input_report_abs(input, ABS_RZ, (data[7] & 0x20) ?
 +					((t - 1) / 2) : -t / 2);
 +			}
  
 -		input_report_abs(input, ABS_TILT_X,
 -			(((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
 -		input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
 -		break;
 +		} else if (!(data[1] & 0x10) && features->type < INTUOS3S) {
 +			/* 4D mouse packet */
 +			input_report_key(input, BTN_LEFT,   data[8] & 0x01);
 +			input_report_key(input, BTN_MIDDLE, data[8] & 0x02);
 +			input_report_key(input, BTN_RIGHT,  data[8] & 0x04);
  
 -	case 0x08:
 -		if (wacom->tool[idx] == BTN_TOOL_MOUSE) {
 -			/* 2D mouse packet */
 -			input_report_key(input, BTN_LEFT,   data[8] & 0x04);
 -			input_report_key(input, BTN_MIDDLE, data[8] & 0x08);
 -			input_report_key(input, BTN_RIGHT,  data[8] & 0x10);
 -			input_report_rel(input, REL_WHEEL, (data[8] & 0x01)
 -					 - ((data[8] & 0x02) >> 1));
 -
 -			/* I3 2D mouse side buttons */
 -			if (features->type >= INTUOS3S && features->type <= INTUOS3L) {
 -				input_report_key(input, BTN_SIDE,   data[8] & 0x40);
 -				input_report_key(input, BTN_EXTRA,  data[8] & 0x20);
 +			input_report_key(input, BTN_SIDE,   data[8] & 0x20);
 +			input_report_key(input, BTN_EXTRA,  data[8] & 0x10);
 +			t = (data[6] << 2) | ((data[7] >> 6) & 3);
 +			input_report_abs(input, ABS_THROTTLE, (data[8] & 0x08) ? -t : t);
 +
 +		} else if (wacom->tool[idx] == BTN_TOOL_MOUSE) {
 +			/* I4 mouse */
 +			if (features->type >= INTUOS4S && features->type <= INTUOSPL) {
 +				input_report_key(input, BTN_LEFT,   data[6] & 0x01);
 +				input_report_key(input, BTN_MIDDLE, data[6] & 0x02);
 +				input_report_key(input, BTN_RIGHT,  data[6] & 0x04);
 +				input_report_rel(input, REL_WHEEL, ((data[7] & 0x80) >> 7)
 +						 - ((data[7] & 0x40) >> 6));
 +				input_report_key(input, BTN_SIDE,   data[6] & 0x08);
 +				input_report_key(input, BTN_EXTRA,  data[6] & 0x10);
 +
 +				input_report_abs(input, ABS_TILT_X,
 +					(((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
 +				input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
 +			} else {
 +				/* 2D mouse packet */
 +				input_report_key(input, BTN_LEFT,   data[8] & 0x04);
 +				input_report_key(input, BTN_MIDDLE, data[8] & 0x08);
 +				input_report_key(input, BTN_RIGHT,  data[8] & 0x10);
 +				input_report_rel(input, REL_WHEEL, (data[8] & 0x01)
 +						 - ((data[8] & 0x02) >> 1));
 +
 +				/* I3 2D mouse side buttons */
 +				if (features->type >= INTUOS3S && features->type <= INTUOS3L) {
 +					input_report_key(input, BTN_SIDE,   data[8] & 0x40);
 +					input_report_key(input, BTN_EXTRA,  data[8] & 0x20);
 +				}
  			}
 -		}
 -		else if (wacom->tool[idx] == BTN_TOOL_LENS) {
 +		} else if ((features->type < INTUOS3S || features->type == INTUOS3L ||
 +				features->type == INTUOS4L || features->type == INTUOS5L ||
 +				features->type == INTUOSPL) &&
 +			   wacom->tool[idx] == BTN_TOOL_LENS) {
  			/* Lens cursor packets */
  			input_report_key(input, BTN_LEFT,   data[8] & 0x01);
  			input_report_key(input, BTN_MIDDLE, data[8] & 0x02);
* Unmerged path drivers/hid/wacom_wac.c
