KVM: PPC: Book3S HV: Add tunable to control H_IPI redirection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Suresh E. Warrier <warrier@linux.vnet.ibm.com>
commit 520fe9c607d3acea96391aad27e17518bd7d39bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/520fe9c6.failed

Redirecting the wakeup of a VCPU from the H_IPI hypercall to
a core running in the host is usually a good idea, most workloads
seemed to benefit. However, in one heavily interrupt-driven SMT1
workload, some regression was observed. This patch adds a kvm_hv
module parameter called h_ipi_redirect to control this feature.

The default value for this tunable is 1 - that is enable the feature.

	Signed-off-by: Suresh Warrier <warrier@linux.vnet.ibm.com>
	Signed-off-by: Paul Mackerras <paulus@samba.org>
(cherry picked from commit 520fe9c607d3acea96391aad27e17518bd7d39bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/kvm_ppc.h
#	arch/powerpc/kvm/book3s_hv_rm_xics.c
diff --cc arch/powerpc/include/asm/kvm_ppc.h
index 19c0b19b88fc,197a8aca2871..000000000000
--- a/arch/powerpc/include/asm/kvm_ppc.h
+++ b/arch/powerpc/include/asm/kvm_ppc.h
@@@ -441,7 -463,11 +441,12 @@@ extern u64 kvmppc_xics_get_icp(struct k
  extern int kvmppc_xics_set_icp(struct kvm_vcpu *vcpu, u64 icpval);
  extern int kvmppc_xics_connect_vcpu(struct kvm_device *dev,
  			struct kvm_vcpu *vcpu, u32 cpu);
++<<<<<<< HEAD
++=======
+ extern void kvmppc_xics_ipi_action(void);
+ extern int h_ipi_redirect;
++>>>>>>> 520fe9c607d3 (KVM: PPC: Book3S HV: Add tunable to control H_IPI redirection)
  #else
 -static inline void kvmppc_alloc_host_rm_ops(void) {};
 -static inline void kvmppc_free_host_rm_ops(void) {};
  static inline int kvmppc_xics_enabled(struct kvm_vcpu *vcpu)
  	{ return 0; }
  static inline void kvmppc_xics_free_icp(struct kvm_vcpu *vcpu) { }
diff --cc arch/powerpc/kvm/book3s_hv_rm_xics.c
index 1ec9b5d6ad10,980d8a6f7284..000000000000
--- a/arch/powerpc/kvm/book3s_hv_rm_xics.c
+++ b/arch/powerpc/kvm/book3s_hv_rm_xics.c
@@@ -66,11 -143,22 +69,23 @@@ static void icp_rm_set_vcpu_irq(struct 
  		return;
  	}
  
 -	/*
 -	 * Check if the core is loaded,
 -	 * if not, find an available host core to post to wake the VCPU,
 -	 * if we can't find one, set up state to eventually return too hard.
 -	 */
 +	/* Check if the core is loaded, if not, too hard */
  	cpu = vcpu->arch.thread_cpu;
  	if (cpu < 0 || cpu >= nr_cpu_ids) {
++<<<<<<< HEAD
 +		this_icp->rm_action |= XICS_RM_KICK_VCPU;
 +		this_icp->rm_kick_target = vcpu;
++=======
+ 		hcore = -1;
+ 		if (kvmppc_host_rm_ops_hv && h_ipi_redirect)
+ 			hcore = find_available_hostcore(XICS_RM_KICK_VCPU);
+ 		if (hcore != -1) {
+ 			icp_send_hcore_msg(hcore, vcpu);
+ 		} else {
+ 			this_icp->rm_action |= XICS_RM_KICK_VCPU;
+ 			this_icp->rm_kick_target = vcpu;
+ 		}
++>>>>>>> 520fe9c607d3 (KVM: PPC: Book3S HV: Add tunable to control H_IPI redirection)
  		return;
  	}
  
* Unmerged path arch/powerpc/include/asm/kvm_ppc.h
diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c
index 32dd0caea96b..cc722d2fed37 100644
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@ -87,6 +87,17 @@ static int target_smt_mode;
 module_param(target_smt_mode, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(target_smt_mode, "Target threads per core (0 = max)");
 
+#ifdef CONFIG_KVM_XICS
+static struct kernel_param_ops module_param_ops = {
+	.set = param_set_int,
+	.get = param_get_int,
+};
+
+module_param_cb(h_ipi_redirect, &module_param_ops, &h_ipi_redirect,
+							S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(h_ipi_redirect, "Redirect H_IPI wakeup to a free host core");
+#endif
+
 static void kvmppc_end_cede(struct kvm_vcpu *vcpu);
 static int kvmppc_hv_setup_htab_rma(struct kvm_vcpu *vcpu);
 
* Unmerged path arch/powerpc/kvm/book3s_hv_rm_xics.c
