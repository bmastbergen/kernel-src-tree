flow_dissect: use programable dissector in skb_flow_dissect and friends

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] flow_dissector: use programable dissector in skb_flow_dissect and friends (Jonathan Toppins) [1428557]
Rebuild_FUZZ: 98.61%
commit-author Jiri Pirko <jiri@resnulli.us>
commit 06635a35d13d42b95422bba6633f175245cc644e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/06635a35.failed

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 06635a35d13d42b95422bba6633f175245cc644e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc_drv.c
#	include/net/flow_keys.h
#	net/core/flow_dissector.c
#	net/sched/cls_flow.c
diff --cc drivers/net/hyperv/netvsc_drv.c
index 2e3746e1a2e8,8e5fe888a0ec..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -203,11 -152,71 +203,73 @@@ static void *init_ppi_data(struct rndis
  	return ppi;
  }
  
++<<<<<<< HEAD
++=======
+ union sub_key {
+ 	u64 k;
+ 	struct {
+ 		u8 pad[3];
+ 		u8 kb;
+ 		u32 ka;
+ 	};
+ };
+ 
+ /* Toeplitz hash function
+  * data: network byte order
+  * return: host byte order
+  */
+ static u32 comp_hash(u8 *key, int klen, void *data, int dlen)
+ {
+ 	union sub_key subk;
+ 	int k_next = 4;
+ 	u8 dt;
+ 	int i, j;
+ 	u32 ret = 0;
+ 
+ 	subk.k = 0;
+ 	subk.ka = ntohl(*(u32 *)key);
+ 
+ 	for (i = 0; i < dlen; i++) {
+ 		subk.kb = key[k_next];
+ 		k_next = (k_next + 1) % klen;
+ 		dt = ((u8 *)data)[i];
+ 		for (j = 0; j < 8; j++) {
+ 			if (dt & 0x80)
+ 				ret ^= subk.ka;
+ 			dt <<= 1;
+ 			subk.k <<= 1;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static bool netvsc_set_hash(u32 *hash, struct sk_buff *skb)
+ {
+ 	struct flow_keys flow;
+ 	int data_len;
+ 
+ 	if (!skb_flow_dissect_flow_keys(skb, &flow) ||
+ 	    !(flow.basic.n_proto == htons(ETH_P_IP) ||
+ 	      flow.basic.n_proto == htons(ETH_P_IPV6)))
+ 		return false;
+ 
+ 	if (flow.basic.ip_proto == IPPROTO_TCP)
+ 		data_len = 12;
+ 	else
+ 		data_len = 8;
+ 
+ 	*hash = comp_hash(netvsc_hash_key, HASH_KEYLEN, &flow, data_len);
+ 
+ 	return true;
+ }
+ 
++>>>>>>> 06635a35d13d (flow_dissect: use programable dissector in skb_flow_dissect and friends)
  static u16 netvsc_select_queue(struct net_device *ndev, struct sk_buff *skb,
 -			void *accel_priv, select_queue_fallback_t fallback)
 +		       void *accel_priv, select_queue_fallback_t fallback)
  {
  	struct net_device_context *net_device_ctx = netdev_priv(ndev);
 -	struct hv_device *hdev =  net_device_ctx->device_ctx;
 -	struct netvsc_device *nvsc_dev = hv_get_drvdata(hdev);
 +	struct netvsc_device *nvsc_dev = net_device_ctx->nvdev;
  	u32 hash;
  	u16 q_idx = 0;
  
diff --cc include/net/flow_keys.h
index 815087552a43,0c8d406fb730..000000000000
--- a/include/net/flow_keys.h
+++ b/include/net/flow_keys.h
@@@ -59,44 -59,54 +59,84 @@@ struct flow_dissector 
  	unsigned short int offset[FLOW_DISSECTOR_KEY_MAX];
  };
  
++<<<<<<< HEAD:include/net/flow_keys.h
 +/* struct flow_keys:
 + *	@src: source ip address in case of IPv4
 + *	      For IPv6 it contains 32bit hash of src address
 + *	@dst: destination ip address in case of IPv4
 + *	      For IPv6 it contains 32bit hash of dst address
 + *	@ports: port numbers of Transport header
 + *		port16[0]: src port number
 + *		port16[1]: dst port number
 + *	@thoff: Transport header offset
 + *	@n_proto: Network header protocol (eg. IPv4/IPv6)
 + *	@ip_proto: Transport header protocol (eg. TCP/UDP)
 + * All the members, except thoff, are in network byte order.
 + */
 +struct flow_keys {
 +	/* (src,dst) must be grouped, in the same way than in IP header */
 +	__be32 src;
 +	__be32 dst;
 +	union {
 +		__be32 ports;
 +		__be16 port16[2];
 +	};
 +	u16 thoff;
 +	u16 n_proto;
 +	u8 ip_proto;
 +};
 +
++=======
++>>>>>>> 06635a35d13d (flow_dissect: use programable dissector in skb_flow_dissect and friends):include/net/flow_dissector.h
  void skb_flow_dissector_init(struct flow_dissector *flow_dissector,
  			     const struct flow_dissector_key *key,
  			     unsigned int key_count);
- bool __skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow,
+ 
+ bool __skb_flow_dissect(const struct sk_buff *skb,
+ 			struct flow_dissector *flow_dissector,
+ 			void *target_container,
  			void *data, __be16 proto, int nhoff, int hlen);
++<<<<<<< HEAD:include/net/flow_keys.h
 +static inline bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow)
++=======
+ 
+ static inline bool skb_flow_dissect(const struct sk_buff *skb,
+ 				    struct flow_dissector *flow_dissector,
+ 				    void *target_container)
++>>>>>>> 06635a35d13d (flow_dissect: use programable dissector in skb_flow_dissect and friends):include/net/flow_dissector.h
+ {
+ 	return __skb_flow_dissect(skb, flow_dissector, target_container,
+ 				  NULL, 0, 0, 0);
+ }
+ 
+ struct flow_keys {
+ 	struct flow_dissector_key_addrs addrs;
+ 	struct flow_dissector_key_ports ports;
+ 	struct flow_dissector_key_basic basic;
+ };
+ 
+ extern struct flow_dissector flow_keys_dissector;
+ extern struct flow_dissector flow_keys_buf_dissector;
+ 
+ static inline bool skb_flow_dissect_flow_keys(const struct sk_buff *skb,
+ 					      struct flow_keys *flow)
+ {
+ 	memset(flow, 0, sizeof(*flow));
+ 	return __skb_flow_dissect(skb, &flow_keys_dissector, flow,
+ 				  NULL, 0, 0, 0);
+ }
+ 
+ static inline bool skb_flow_dissect_flow_keys_buf(struct flow_keys *flow,
+ 						  void *data, __be16 proto,
+ 						  int nhoff, int hlen)
  {
- 	return __skb_flow_dissect(skb, flow, NULL, 0, 0, 0);
+ 	memset(flow, 0, sizeof(*flow));
+ 	return __skb_flow_dissect(NULL, &flow_keys_buf_dissector, flow,
+ 				  data, proto, nhoff, hlen);
  }
 -
  __be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,
  			    void *data, int hlen_proto);
 -
 -static inline __be32 skb_flow_get_ports(const struct sk_buff *skb,
 -					int thoff, u8 ip_proto)
 +static inline __be32 skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto)
  {
  	return __skb_flow_get_ports(skb, thoff, ip_proto, NULL, 0);
  }
diff --cc net/core/flow_dissector.c
index fbf58a98e819,6a49acaa6651..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -13,7 -13,8 +13,12 @@@
  #include <linux/if_tunnel.h>
  #include <linux/if_pppox.h>
  #include <linux/ppp_defs.h>
++<<<<<<< HEAD
 +#include <net/flow_keys.h>
++=======
+ #include <linux/stddef.h>
+ #include <net/flow_dissector.h>
++>>>>>>> 06635a35d13d (flow_dissect: use programable dissector in skb_flow_dissect and friends)
  #include <scsi/fc/fc_fcoe.h>
  
  static bool skb_flow_dissector_uses_key(struct flow_dissector *flow_dissector,
@@@ -148,33 -153,64 +157,79 @@@ ip
  		if (ip_is_fragment(iph))
  			ip_proto = 0;
  
++<<<<<<< HEAD
 +		iph_to_flow_copy_addrs(flow, iph);
++=======
+ 		if (!skb_flow_dissector_uses_key(flow_dissector,
+ 						 FLOW_DISSECTOR_KEY_IPV4_ADDRS))
+ 			break;
+ 		key_addrs = skb_flow_dissector_target(flow_dissector,
+ 						      FLOW_DISSECTOR_KEY_IPV4_ADDRS,
+ 						      target_container);
+ 		memcpy(key_addrs, &iph->saddr, sizeof(*key_addrs));
++>>>>>>> 06635a35d13d (flow_dissect: use programable dissector in skb_flow_dissect and friends)
  		break;
  	}
 -	case htons(ETH_P_IPV6): {
 +	case __constant_htons(ETH_P_IPV6): {
  		const struct ipv6hdr *iph;
  		struct ipv6hdr _iph;
 -		__be32 flow_label;
 -
  ipv6:
  		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
  		if (!iph)
  			return false;
  
  		ip_proto = iph->nexthdr;
 +		flow->src = (__force __be32)ipv6_addr_hash(&iph->saddr);
 +		flow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);
  		nhoff += sizeof(struct ipv6hdr);
  
++<<<<<<< HEAD
 +		/* skip the flow label processing if skb is NULL.  The
 +		 * assumption here is that if there is no skb we are not
 +		 * looking for flow info as much as we are length.
 +		 */
 +		if (!skb)
++=======
+ 		if (!skb_flow_dissector_uses_key(flow_dissector,
+ 						 FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS))
++>>>>>>> 06635a35d13d (flow_dissect: use programable dissector in skb_flow_dissect and friends)
  			break;
+ 		key_addrs = skb_flow_dissector_target(flow_dissector,
+ 						      FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS,
+ 						      target_container);
+ 
++<<<<<<< HEAD
++=======
+ 		key_addrs->src = (__force __be32)ipv6_addr_hash(&iph->saddr);
+ 		key_addrs->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);
+ 
+ 		flow_label = ip6_flowlabel(iph);
+ 		if (flow_label) {
+ 			/* Awesome, IPv6 packet has a flow label so we can
+ 			 * use that to represent the ports without any
+ 			 * further dissection.
+ 			 */
+ 
+ 			key_basic->n_proto = proto;
+ 			key_basic->ip_proto = ip_proto;
+ 			key_basic->thoff = (u16)nhoff;
+ 
+ 			if (!skb_flow_dissector_uses_key(flow_dissector,
+ 							 FLOW_DISSECTOR_KEY_PORTS))
+ 				break;
+ 			key_ports = skb_flow_dissector_target(flow_dissector,
+ 							      FLOW_DISSECTOR_KEY_PORTS,
+ 							      target_container);
+ 			key_ports->ports = flow_label;
+ 
+ 			return true;
+ 		}
  
++>>>>>>> 06635a35d13d (flow_dissect: use programable dissector in skb_flow_dissect and friends)
  		break;
  	}
 -	case htons(ETH_P_8021AD):
 -	case htons(ETH_P_8021Q): {
 +	case __constant_htons(ETH_P_8021AD):
 +	case __constant_htons(ETH_P_8021Q): {
  		const struct vlan_hdr *vlan;
  		struct vlan_hdr _vlan;
  
@@@ -275,11 -319,25 +338,33 @@@
  		break;
  	}
  
++<<<<<<< HEAD
 +	flow->n_proto = proto;
 +	flow->ip_proto = ip_proto;
 +	flow->ports = __skb_flow_get_ports(skb, nhoff, ip_proto, data, hlen);
 +	flow->thoff = (u16) nhoff;
 +
++=======
+ 	/* It is ensured by skb_flow_dissector_init() that basic key will
+ 	 * be always present.
+ 	 */
+ 	key_basic = skb_flow_dissector_target(flow_dissector,
+ 					      FLOW_DISSECTOR_KEY_BASIC,
+ 					      target_container);
+ 	key_basic->n_proto = proto;
+ 	key_basic->ip_proto = ip_proto;
+ 	key_basic->thoff = (u16) nhoff;
+ 
+ 	if (skb_flow_dissector_uses_key(flow_dissector,
+ 					FLOW_DISSECTOR_KEY_PORTS)) {
+ 		key_ports = skb_flow_dissector_target(flow_dissector,
+ 						      FLOW_DISSECTOR_KEY_PORTS,
+ 						      target_container);
+ 		key_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,
+ 							data, hlen);
+ 	}
+ 
++>>>>>>> 06635a35d13d (flow_dissect: use programable dissector in skb_flow_dissect and friends)
  	return true;
  }
  EXPORT_SYMBOL(__skb_flow_dissect);
@@@ -301,16 -358,17 +386,23 @@@ static inline u32 __flow_hash_from_keys
  	u32 hash;
  
  	/* get a consistent hash (same value on both flow directions) */
- 	if (((__force u32)keys->dst < (__force u32)keys->src) ||
- 	    (((__force u32)keys->dst == (__force u32)keys->src) &&
- 	     ((__force u16)keys->port16[1] < (__force u16)keys->port16[0]))) {
- 		swap(keys->dst, keys->src);
- 		swap(keys->port16[0], keys->port16[1]);
+ 	if (((__force u32)keys->addrs.dst < (__force u32)keys->addrs.src) ||
+ 	    (((__force u32)keys->addrs.dst == (__force u32)keys->addrs.src) &&
+ 	     ((__force u16)keys->ports.port16[1] < (__force u16)keys->ports.port16[0]))) {
+ 		swap(keys->addrs.dst, keys->addrs.src);
+ 		swap(keys->ports.port16[0], keys->ports.port16[1]);
  	}
  
++<<<<<<< HEAD
 +	hash = __flow_hash_3words((__force u32)keys->dst,
 +				  (__force u32)keys->src,
 +				  (__force u32)keys->ports);
++=======
+ 	hash = __flow_hash_3words((__force u32)keys->addrs.dst,
+ 				  (__force u32)keys->addrs.src,
+ 				  (__force u32)keys->ports.ports,
+ 				  keyval);
++>>>>>>> 06635a35d13d (flow_dissect: use programable dissector in skb_flow_dissect and friends)
  	if (!hash)
  		hash = 1;
  
@@@ -323,8 -382,47 +415,52 @@@ u32 flow_hash_from_keys(struct flow_key
  }
  EXPORT_SYMBOL(flow_hash_from_keys);
  
++<<<<<<< HEAD
 +/*
 + * __skb_get_hash: calculate a flow hash based on src/dst addresses
++=======
+ static inline u32 ___skb_get_hash(const struct sk_buff *skb,
+ 				  struct flow_keys *keys, u32 keyval)
+ {
+ 	if (!skb_flow_dissect_flow_keys(skb, keys))
+ 		return 0;
+ 
+ 	return __flow_hash_from_keys(keys, keyval);
+ }
+ 
+ struct _flow_keys_digest_data {
+ 	__be16	n_proto;
+ 	u8	ip_proto;
+ 	u8	padding;
+ 	__be32	ports;
+ 	__be32	src;
+ 	__be32	dst;
+ };
+ 
+ void make_flow_keys_digest(struct flow_keys_digest *digest,
+ 			   const struct flow_keys *flow)
+ {
+ 	struct _flow_keys_digest_data *data =
+ 	    (struct _flow_keys_digest_data *)digest;
+ 
+ 	BUILD_BUG_ON(sizeof(*data) > sizeof(*digest));
+ 
+ 	memset(digest, 0, sizeof(*digest));
+ 
+ 	data->n_proto = flow->basic.n_proto;
+ 	data->ip_proto = flow->basic.ip_proto;
+ 	data->ports = flow->ports.ports;
+ 	data->src = flow->addrs.src;
+ 	data->dst = flow->addrs.dst;
+ }
+ EXPORT_SYMBOL(make_flow_keys_digest);
+ 
+ /**
+  * __skb_get_hash: calculate a flow hash
+  * @skb: sk_buff to calculate flow hash from
+  *
+  * This function calculates a flow hash based on src/dst addresses
++>>>>>>> 06635a35d13d (flow_dissect: use programable dissector in skb_flow_dissect and friends)
   * and src/dst port numbers.  Sets hash in skb to non-zero hash value
   * on success, zero indicates no valid hash.  Also, sets l4_hash in skb
   * if hash is a canonical 4-tuple hash over transport ports.
@@@ -332,14 -430,17 +468,18 @@@
  void __skb_get_hash(struct sk_buff *skb)
  {
  	struct flow_keys keys;
 -	u32 hash;
 -
 -	__flow_hash_secret_init();
  
 -	hash = ___skb_get_hash(skb, &keys, hashrnd);
 -	if (!hash)
 +	if (!skb_flow_dissect(skb, &keys))
  		return;
++<<<<<<< HEAD
 +
 +	if (keys.ports)
++=======
+ 	if (keys.ports.ports)
++>>>>>>> 06635a35d13d (flow_dissect: use programable dissector in skb_flow_dissect and friends)
  		skb->l4_hash = 1;
 -	skb->sw_hash = 1;
 -	skb->hash = hash;
 +
 +	skb->hash = __flow_hash_from_keys(&keys);
  }
  EXPORT_SYMBOL(__skb_get_hash);
  
@@@ -374,19 -455,20 +514,19 @@@ EXPORT_SYMBOL(__skb_tx_hash)
  u32 __skb_get_poff(const struct sk_buff *skb, void *data,
  		   const struct flow_keys *keys, int hlen)
  {
- 	u32 poff = keys->thoff;
+ 	u32 poff = keys->basic.thoff;
  
- 	switch (keys->ip_proto) {
+ 	switch (keys->basic.ip_proto) {
  	case IPPROTO_TCP: {
 -		/* access doff as u8 to avoid unaligned access */
 -		const u8 *doff;
 -		u8 _doff;
 +		const struct tcphdr *tcph;
 +		struct tcphdr _tcph;
  
 -		doff = __skb_header_pointer(skb, poff + 12, sizeof(_doff),
 -					    data, hlen, &_doff);
 -		if (!doff)
 +		tcph = __skb_header_pointer(skb, poff, sizeof(_tcph),
 +					    data, hlen, &_tcph);
 +		if (!tcph)
  			return poff;
  
 -		poff += max_t(u32, sizeof(struct tcphdr), (*doff & 0xF0) >> 2);
 +		poff += max_t(u32, sizeof(struct tcphdr), tcph->doff * 4);
  		break;
  	}
  	case IPPROTO_UDP:
diff --cc net/sched/cls_flow.c
index c999e8f9936b,4b3e3e30bf4d..000000000000
--- a/net/sched/cls_flow.c
+++ b/net/sched/cls_flow.c
@@@ -75,9 -75,9 +75,15 @@@ static u32 flow_get_src(const struct sk
  
  static u32 flow_get_dst(const struct sk_buff *skb, const struct flow_keys *flow)
  {
++<<<<<<< HEAD
 +	if (flow->dst)
 +		return ntohl(flow->dst);
 +	return addr_fold(skb_dst(skb)) ^ (__force u16)skb->protocol;
++=======
+ 	if (flow->addrs.dst)
+ 		return ntohl(flow->addrs.dst);
+ 	return addr_fold(skb_dst(skb)) ^ (__force u16) tc_skb_protocol(skb);
++>>>>>>> 06635a35d13d (flow_dissect: use programable dissector in skb_flow_dissect and friends)
  }
  
  static u32 flow_get_proto(const struct sk_buff *skb, const struct flow_keys *flow)
@@@ -95,10 -95,10 +101,10 @@@ static u32 flow_get_proto_src(const str
  
  static u32 flow_get_proto_dst(const struct sk_buff *skb, const struct flow_keys *flow)
  {
- 	if (flow->ports)
- 		return ntohs(flow->port16[1]);
+ 	if (flow->ports.ports)
+ 		return ntohs(flow->ports.port16[1]);
  
 -	return addr_fold(skb_dst(skb)) ^ (__force u16) tc_skb_protocol(skb);
 +	return addr_fold(skb_dst(skb)) ^ (__force u16)skb->protocol;
  }
  
  static u32 flow_get_iif(const struct sk_buff *skb)
diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c
index 0fd8f39dab0c..704c64b09d40 100644
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@ -3094,16 +3094,16 @@ static bool bond_flow_dissect(struct bonding *bond, struct sk_buff *skb,
 	int noff, proto = -1;
 
 	if (bond->params.xmit_policy > BOND_XMIT_POLICY_LAYER23)
-		return skb_flow_dissect(skb, fk);
+		return skb_flow_dissect_flow_keys(skb, fk);
 
-	fk->ports = 0;
+	fk->ports.ports = 0;
 	noff = skb_network_offset(skb);
 	if (skb->protocol == htons(ETH_P_IP)) {
 		if (unlikely(!pskb_may_pull(skb, noff + sizeof(*iph))))
 			return false;
 		iph = ip_hdr(skb);
-		fk->src = iph->saddr;
-		fk->dst = iph->daddr;
+		fk->addrs.src = iph->saddr;
+		fk->addrs.dst = iph->daddr;
 		noff += iph->ihl << 2;
 		if (!ip_is_fragment(iph))
 			proto = iph->protocol;
@@ -3111,15 +3111,15 @@ static bool bond_flow_dissect(struct bonding *bond, struct sk_buff *skb,
 		if (unlikely(!pskb_may_pull(skb, noff + sizeof(*iph6))))
 			return false;
 		iph6 = ipv6_hdr(skb);
-		fk->src = (__force __be32)ipv6_addr_hash(&iph6->saddr);
-		fk->dst = (__force __be32)ipv6_addr_hash(&iph6->daddr);
+		fk->addrs.src = (__force __be32)ipv6_addr_hash(&iph6->saddr);
+		fk->addrs.dst = (__force __be32)ipv6_addr_hash(&iph6->daddr);
 		noff += sizeof(*iph6);
 		proto = iph6->nexthdr;
 	} else {
 		return false;
 	}
 	if (bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER34 && proto >= 0)
-		fk->ports = skb_flow_get_ports(skb, noff, proto);
+		fk->ports.ports = skb_flow_get_ports(skb, noff, proto);
 
 	return true;
 }
@@ -3149,8 +3149,8 @@ u32 bond_xmit_hash(struct bonding *bond, struct sk_buff *skb)
 	    bond->params.xmit_policy == BOND_XMIT_POLICY_ENCAP23)
 		hash = bond_eth_hash(skb);
 	else
-		hash = (__force u32)flow.ports;
-	hash ^= (__force u32)flow.dst ^ (__force u32)flow.src;
+		hash = (__force u32)flow.ports.ports;
+	hash ^= (__force u32)flow.addrs.dst ^ (__force u32)flow.addrs.src;
 	hash ^= (hash >> 16);
 	hash ^= (hash >> 8);
 
diff --git a/drivers/net/ethernet/cisco/enic/enic_clsf.c b/drivers/net/ethernet/cisco/enic/enic_clsf.c
index e2fbefe5772f..e9757730cb0f 100644
--- a/drivers/net/ethernet/cisco/enic/enic_clsf.c
+++ b/drivers/net/ethernet/cisco/enic/enic_clsf.c
@@ -22,7 +22,7 @@ int enic_addfltr_5t(struct enic *enic, struct flow_keys *keys, u16 rq)
 	int res;
 	struct filter data;
 
-	switch (keys->ip_proto) {
+	switch (keys->basic.ip_proto) {
 	case IPPROTO_TCP:
 		data.u.ipv4.protocol = PROTO_TCP;
 		break;
@@ -33,10 +33,10 @@ int enic_addfltr_5t(struct enic *enic, struct flow_keys *keys, u16 rq)
 		return -EPROTONOSUPPORT;
 	};
 	data.type = FILTER_IPV4_5TUPLE;
-	data.u.ipv4.src_addr = ntohl(keys->src);
-	data.u.ipv4.dst_addr = ntohl(keys->dst);
-	data.u.ipv4.src_port = ntohs(keys->port16[0]);
-	data.u.ipv4.dst_port = ntohs(keys->port16[1]);
+	data.u.ipv4.src_addr = ntohl(keys->addrs.src);
+	data.u.ipv4.dst_addr = ntohl(keys->addrs.dst);
+	data.u.ipv4.src_port = ntohs(keys->ports.port16[0]);
+	data.u.ipv4.dst_port = ntohs(keys->ports.port16[1]);
 	data.u.ipv4.flags = FILTER_FIELDS_IPV4_5TUPLE;
 
 	spin_lock_bh(&enic->devcmd_lock);
@@ -158,11 +158,11 @@ static struct enic_rfs_fltr_node *htbl_key_search(struct hlist_head *h,
 	struct enic_rfs_fltr_node *tpos;
 
 	hlist_for_each_entry(tpos, h, node)
-		if (tpos->keys.src == k->src &&
-		    tpos->keys.dst == k->dst &&
-		    tpos->keys.ports == k->ports &&
-		    tpos->keys.ip_proto == k->ip_proto &&
-		    tpos->keys.n_proto == k->n_proto)
+		if (tpos->keys.addrs.src == k->addrs.src &&
+		    tpos->keys.addrs.dst == k->addrs.dst &&
+		    tpos->keys.ports.ports == k->ports.ports &&
+		    tpos->keys.basic.ip_proto == k->basic.ip_proto &&
+		    tpos->keys.basic.n_proto == k->basic.n_proto)
 			return tpos;
 	return NULL;
 }
@@ -177,9 +177,10 @@ int enic_rx_flow_steer(struct net_device *dev, const struct sk_buff *skb,
 	int res, i;
 
 	enic = netdev_priv(dev);
-	res = skb_flow_dissect(skb, &keys);
-	if (!res || keys.n_proto != htons(ETH_P_IP) ||
-	    (keys.ip_proto != IPPROTO_TCP && keys.ip_proto != IPPROTO_UDP))
+	res = skb_flow_dissect_flow_keys(skb, &keys);
+	if (!res || keys.basic.n_proto != htons(ETH_P_IP) ||
+	    (keys.basic.ip_proto != IPPROTO_TCP &&
+	     keys.basic.ip_proto != IPPROTO_UDP))
 		return -EPROTONOSUPPORT;
 
 	tbl_idx = skb_get_hash_raw(skb) & ENIC_RFS_FLW_MASK;
diff --git a/drivers/net/ethernet/cisco/enic/enic_ethtool.c b/drivers/net/ethernet/cisco/enic/enic_ethtool.c
index e7557a372ed3..48ddb36b3adb 100644
--- a/drivers/net/ethernet/cisco/enic/enic_ethtool.c
+++ b/drivers/net/ethernet/cisco/enic/enic_ethtool.c
@@ -364,7 +364,7 @@ static int enic_grxclsrule(struct enic *enic, struct ethtool_rxnfc *cmd)
 	n = htbl_fltr_search(enic, (u16)fsp->location);
 	if (!n)
 		return -EINVAL;
-	switch (n->keys.ip_proto) {
+	switch (n->keys.basic.ip_proto) {
 	case IPPROTO_TCP:
 		fsp->flow_type = TCP_V4_FLOW;
 		break;
@@ -376,16 +376,16 @@ static int enic_grxclsrule(struct enic *enic, struct ethtool_rxnfc *cmd)
 		break;
 	}
 
-	fsp->h_u.tcp_ip4_spec.ip4src = n->keys.src;
+	fsp->h_u.tcp_ip4_spec.ip4src = n->keys.addrs.src;
 	fsp->m_u.tcp_ip4_spec.ip4src = (__u32)~0;
 
-	fsp->h_u.tcp_ip4_spec.ip4dst = n->keys.dst;
+	fsp->h_u.tcp_ip4_spec.ip4dst = n->keys.addrs.dst;
 	fsp->m_u.tcp_ip4_spec.ip4dst = (__u32)~0;
 
-	fsp->h_u.tcp_ip4_spec.psrc = n->keys.port16[0];
+	fsp->h_u.tcp_ip4_spec.psrc = n->keys.ports.port16[0];
 	fsp->m_u.tcp_ip4_spec.psrc = (__u16)~0;
 
-	fsp->h_u.tcp_ip4_spec.pdst = n->keys.port16[1];
+	fsp->h_u.tcp_ip4_spec.pdst = n->keys.ports.port16[1];
 	fsp->m_u.tcp_ip4_spec.pdst = (__u16)~0;
 
 	fsp->ring_cookie = n->rq_id;
* Unmerged path drivers/net/hyperv/netvsc_drv.c
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 449d0a455cd2..02361178d869 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -1984,8 +1984,8 @@ static inline void skb_probe_transport_header(struct sk_buff *skb,
 
 	if (skb_transport_header_was_set(skb))
 		return;
-	else if (skb_flow_dissect(skb, &keys))
-		skb_set_transport_header(skb, keys.thoff);
+	else if (skb_flow_dissect_flow_keys(skb, &keys))
+		skb_set_transport_header(skb, keys.basic.thoff);
 	else
 		skb_set_transport_header(skb, offset_hint);
 }
* Unmerged path include/net/flow_keys.h
diff --git a/include/net/ip.h b/include/net/ip.h
index 5506ed81f7f4..476347ec7546 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -362,10 +362,10 @@ static inline void inet_set_txhash(struct sock *sk)
 	struct inet_sock *inet = inet_sk(sk);
 	struct flow_keys keys;
 
-	keys.src = inet->inet_saddr;
-	keys.dst = inet->inet_daddr;
-	keys.port16[0] = inet->inet_sport;
-	keys.port16[1] = inet->inet_dport;
+	keys.addrs.src = inet->inet_saddr;
+	keys.addrs.dst = inet->inet_daddr;
+	keys.ports.port16[0] = inet->inet_sport;
+	keys.ports.port16[1] = inet->inet_dport;
 
 	sk->sk_txhash = flow_hash_from_keys(&keys);
 }
diff --git a/include/net/ipv6.h b/include/net/ipv6.h
index 9b1513b769fd..8a31fcb2afab 100644
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -705,10 +705,10 @@ static inline void ip6_set_txhash(struct sock *sk)
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct flow_keys keys;
 
-	keys.src = (__force __be32)ipv6_addr_hash(&np->saddr);
-	keys.dst = (__force __be32)ipv6_addr_hash(&sk->sk_v6_daddr);
-	keys.port16[0] = inet->inet_sport;
-	keys.port16[1] = inet->inet_dport;
+	keys.addrs.src = (__force __be32)ipv6_addr_hash(&np->saddr);
+	keys.addrs.dst = (__force __be32)ipv6_addr_hash(&sk->sk_v6_daddr);
+	keys.ports.port16[0] = inet->inet_sport;
+	keys.ports.port16[1] = inet->inet_dport;
 
 	sk->sk_txhash = flow_hash_from_keys(&keys);
 }
* Unmerged path net/core/flow_dissector.c
diff --git a/net/ethernet/eth.c b/net/ethernet/eth.c
index de86b55317f9..d35761b396e5 100644
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@ -167,9 +167,9 @@ u32 eth_get_headlen(void *data, unsigned int len)
 		return len;
 
 	/* parse any remaining L2/L3 headers, check for L4 */
-	if (!__skb_flow_dissect(NULL, &keys, data,
-				eth->h_proto, sizeof(*eth), len))
-		return max_t(u32, keys.thoff, sizeof(*eth));
+	if (!skb_flow_dissect_flow_keys_buf(&keys, data, eth->h_proto,
+					    sizeof(*eth), len))
+		return max_t(u32, keys.basic.thoff, sizeof(*eth));
 
 	/* parse for any L4 headers */
 	return min_t(u32, __skb_get_poff(NULL, data, &keys, len), len);
* Unmerged path net/sched/cls_flow.c
diff --git a/net/sched/sch_choke.c b/net/sched/sch_choke.c
index ecb70f411ff4..f1de02a9ef03 100644
--- a/net/sched/sch_choke.c
+++ b/net/sched/sch_choke.c
@@ -170,13 +170,13 @@ static bool choke_match_flow(struct sk_buff *skb1,
 
 	if (!choke_skb_cb(skb1)->keys_valid) {
 		choke_skb_cb(skb1)->keys_valid = 1;
-		skb_flow_dissect(skb1, &temp);
+		skb_flow_dissect_flow_keys(skb1, &temp);
 		make_flow_keys_digest(&choke_skb_cb(skb1)->keys, &temp);
 	}
 
 	if (!choke_skb_cb(skb2)->keys_valid) {
 		choke_skb_cb(skb2)->keys_valid = 1;
-		skb_flow_dissect(skb2, &temp);
+		skb_flow_dissect_flow_keys(skb2, &temp);
 		make_flow_keys_digest(&choke_skb_cb(skb2)->keys, &temp);
 	}
 
