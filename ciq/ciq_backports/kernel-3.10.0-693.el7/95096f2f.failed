uio-hv-generic: new userspace i/o driver for VMBus

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Stephen Hemminger <sthemmin@microsoft.com>
commit 95096f2fbd10186d3e78a328b327afc71428f65f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/95096f2f.failed

This is a new driver to enable userspace networking on VMBus.
It is based largely on the similar driver that already exists
for PCI, and earlier work done by Brocade to support DPDK.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 95096f2fbd10186d3e78a328b327afc71428f65f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	MAINTAINERS
#	drivers/uio/Kconfig
#	drivers/uio/Makefile
diff --cc MAINTAINERS
index 34330c037ee5,d19faf724ac6..000000000000
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@@ -3968,14 -5848,31 +3968,19 @@@ F:	arch/x86/include/uapi/asm/hyperv.
  F:	arch/x86/kernel/cpu/mshyperv.c
  F:	drivers/hid/hid-hyperv.c
  F:	drivers/hv/
 -F:	drivers/input/serio/hyperv-keyboard.c
 -F:	drivers/pci/host/pci-hyperv.c
  F:	drivers/net/hyperv/
  F:	drivers/scsi/storvsc_drv.c
++<<<<<<< HEAD
 +F:	drivers/video/hyperv_fb.c
++=======
+ F:	drivers/uio/uio_hv_generic.c
+ F:	drivers/video/fbdev/hyperv_fb.c
++>>>>>>> 95096f2fbd10 (uio-hv-generic: new userspace i/o driver for VMBus)
  F:	include/linux/hyperv.h
  F:	tools/hv/
 -F:	Documentation/ABI/stable/sysfs-bus-vmbus
 -
 -I2C MUXES
 -M:	Peter Rosin <peda@axentia.se>
 -L:	linux-i2c@vger.kernel.org
 -S:	Maintained
 -F:	Documentation/i2c/i2c-topology
 -F:	Documentation/i2c/muxes/
 -F:	Documentation/devicetree/bindings/i2c/i2c-mux*
 -F:	Documentation/devicetree/bindings/i2c/i2c-arb*
 -F:	Documentation/devicetree/bindings/i2c/i2c-gate*
 -F:	drivers/i2c/i2c-mux.c
 -F:	drivers/i2c/muxes/
 -F:	include/linux/i2c-mux.h
  
  I2C OVER PARALLEL PORT
 -M:	Jean Delvare <jdelvare@suse.com>
 +M:	Jean Delvare <khali@linux-fr.org>
  L:	linux-i2c@vger.kernel.org
  S:	Maintained
  F:	Documentation/i2c/busses/i2c-parport
diff --cc drivers/uio/Kconfig
index 5295be0342c1,7e8dc78a9796..000000000000
--- a/drivers/uio/Kconfig
+++ b/drivers/uio/Kconfig
@@@ -128,4 -142,26 +128,29 @@@ config UIO_PRUS
  	  To compile this driver as a module, choose M here: the module
  	  will be called uio_pruss.
  
++<<<<<<< HEAD
++=======
+ config UIO_MF624
+ 	tristate "Humusoft MF624 DAQ PCI card driver"
+ 	depends on PCI
+ 	help
+ 	  Userspace I/O interface for the Humusoft MF624 PCI card.
+ 	  A sample userspace application using this driver is available
+ 	  (among other MF624 related information and software components)
+ 	  for download in a git repository:
+ 
+ 	    git clone git://rtime.felk.cvut.cz/mf6xx.git
+ 
+ 	  If you compile this as a module, it will be called uio_mf624.
+ 
+ config UIO_HV_GENERIC
+ 	tristate "Generic driver for Hyper-V VMBus"
+ 	depends on HYPERV
+ 	help
+ 	  Generic driver that you can bind, dynamically, to any
+ 	  Hyper-V VMBus device. It is useful to provide direct access
+ 	  to network and storage devices from userspace.
+ 
+ 	  If you compile this as a module, it will be called uio_hv_generic.
++>>>>>>> 95096f2fbd10 (uio-hv-generic: new userspace i/o driver for VMBus)
  endif
diff --cc drivers/uio/Makefile
index b354c539507a,e9663bb8a4c7..000000000000
--- a/drivers/uio/Makefile
+++ b/drivers/uio/Makefile
@@@ -8,3 -7,6 +8,9 @@@ obj-$(CONFIG_UIO_SERCOS3)	+= uio_sercos
  obj-$(CONFIG_UIO_PCI_GENERIC)	+= uio_pci_generic.o
  obj-$(CONFIG_UIO_NETX)	+= uio_netx.o
  obj-$(CONFIG_UIO_PRUSS)         += uio_pruss.o
++<<<<<<< HEAD
++=======
+ obj-$(CONFIG_UIO_MF624)         += uio_mf624.o
+ obj-$(CONFIG_UIO_FSL_ELBC_GPCM)	+= uio_fsl_elbc_gpcm.o
+ obj-$(CONFIG_UIO_HV_GENERIC)	+= uio_hv_generic.o
++>>>>>>> 95096f2fbd10 (uio-hv-generic: new userspace i/o driver for VMBus)
* Unmerged path MAINTAINERS
diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index c99b75404dbd..1833c213376e 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -39,6 +39,7 @@ struct vmbus_connection vmbus_connection = {
 	.conn_state		= DISCONNECTED,
 	.next_gpadl_handle	= ATOMIC_INIT(0xE1E10),
 };
+EXPORT_SYMBOL_GPL(vmbus_connection);
 
 /*
  * Negotiated protocol version with the host.
* Unmerged path drivers/uio/Kconfig
* Unmerged path drivers/uio/Makefile
diff --git a/drivers/uio/uio_hv_generic.c b/drivers/uio/uio_hv_generic.c
new file mode 100644
index 000000000000..ad3ab5805ad8
--- /dev/null
+++ b/drivers/uio/uio_hv_generic.c
@@ -0,0 +1,218 @@
+/*
+ * uio_hv_generic - generic UIO driver for VMBus
+ *
+ * Copyright (c) 2013-2016 Brocade Communications Systems, Inc.
+ * Copyright (c) 2016, Microsoft Corporation.
+ *
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2.
+ *
+ * Since the driver does not declare any device ids, you must allocate
+ * id and bind the device to the driver yourself.  For example:
+ *
+ * # echo "f8615163-df3e-46c5-913f-f2d2f965ed0e" \
+ *    > /sys/bus/vmbus/drivers/uio_hv_generic
+ * # echo -n vmbus-ed963694-e847-4b2a-85af-bc9cfc11d6f3 \
+ *    > /sys/bus/vmbus/drivers/hv_netvsc/unbind
+ * # echo -n vmbus-ed963694-e847-4b2a-85af-bc9cfc11d6f3 \
+ *    > /sys/bus/vmbus/drivers/uio_hv_generic/bind
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/uio_driver.h>
+#include <linux/netdevice.h>
+#include <linux/if_ether.h>
+#include <linux/skbuff.h>
+#include <linux/hyperv.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+
+#include "../hv/hyperv_vmbus.h"
+
+#define DRIVER_VERSION	"0.02.0"
+#define DRIVER_AUTHOR	"Stephen Hemminger <sthemmin at microsoft.com>"
+#define DRIVER_DESC	"Generic UIO driver for VMBus devices"
+
+/*
+ * List of resources to be mapped to user space
+ * can be extended up to MAX_UIO_MAPS(5) items
+ */
+enum hv_uio_map {
+	TXRX_RING_MAP = 0,
+	INT_PAGE_MAP,
+	MON_PAGE_MAP,
+};
+
+#define HV_RING_SIZE	512
+
+struct hv_uio_private_data {
+	struct uio_info info;
+	struct hv_device *device;
+};
+
+static int
+hv_uio_mmap(struct uio_info *info, struct vm_area_struct *vma)
+{
+	int mi;
+
+	if (vma->vm_pgoff >= MAX_UIO_MAPS)
+		return -EINVAL;
+
+	if (info->mem[vma->vm_pgoff].size == 0)
+		return -EINVAL;
+
+	mi = (int)vma->vm_pgoff;
+
+	return remap_pfn_range(vma, vma->vm_start,
+			virt_to_phys((void *)info->mem[mi].addr) >> PAGE_SHIFT,
+			vma->vm_end - vma->vm_start, vma->vm_page_prot);
+}
+
+/*
+ * This is the irqcontrol callback to be registered to uio_info.
+ * It can be used to disable/enable interrupt from user space processes.
+ *
+ * @param info
+ *  pointer to uio_info.
+ * @param irq_state
+ *  state value. 1 to enable interrupt, 0 to disable interrupt.
+ */
+static int
+hv_uio_irqcontrol(struct uio_info *info, s32 irq_state)
+{
+	struct hv_uio_private_data *pdata = info->priv;
+	struct hv_device *dev = pdata->device;
+
+	dev->channel->inbound.ring_buffer->interrupt_mask = !irq_state;
+	virt_mb();
+
+	return 0;
+}
+
+/*
+ * Callback from vmbus_event when something is in inbound ring.
+ */
+static void hv_uio_channel_cb(void *context)
+{
+	struct hv_uio_private_data *pdata = context;
+	struct hv_device *dev = pdata->device;
+
+	dev->channel->inbound.ring_buffer->interrupt_mask = 1;
+	virt_mb();
+
+	uio_event_notify(&pdata->info);
+}
+
+static int
+hv_uio_probe(struct hv_device *dev,
+	     const struct hv_vmbus_device_id *dev_id)
+{
+	struct hv_uio_private_data *pdata;
+	int ret;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	ret = vmbus_open(dev->channel, HV_RING_SIZE * PAGE_SIZE,
+			 HV_RING_SIZE * PAGE_SIZE, NULL, 0,
+			 hv_uio_channel_cb, pdata);
+	if (ret)
+		goto fail;
+
+	dev->channel->inbound.ring_buffer->interrupt_mask = 1;
+	dev->channel->batched_reading = false;
+
+	/* Fill general uio info */
+	pdata->info.name = "uio_hv_generic";
+	pdata->info.version = DRIVER_VERSION;
+	pdata->info.irqcontrol = hv_uio_irqcontrol;
+	pdata->info.mmap = hv_uio_mmap;
+	pdata->info.irq = UIO_IRQ_CUSTOM;
+
+	/* mem resources */
+	pdata->info.mem[TXRX_RING_MAP].name = "txrx_rings";
+	pdata->info.mem[TXRX_RING_MAP].addr
+		= (phys_addr_t)dev->channel->ringbuffer_pages;
+	pdata->info.mem[TXRX_RING_MAP].size
+		= dev->channel->ringbuffer_pagecount * PAGE_SIZE;
+	pdata->info.mem[TXRX_RING_MAP].memtype = UIO_MEM_LOGICAL;
+
+	pdata->info.mem[INT_PAGE_MAP].name = "int_page";
+	pdata->info.mem[INT_PAGE_MAP].addr =
+		(phys_addr_t)vmbus_connection.int_page;
+	pdata->info.mem[INT_PAGE_MAP].size = PAGE_SIZE;
+	pdata->info.mem[INT_PAGE_MAP].memtype = UIO_MEM_LOGICAL;
+
+	pdata->info.mem[MON_PAGE_MAP].name = "monitor_pages";
+	pdata->info.mem[MON_PAGE_MAP].addr =
+		(phys_addr_t)vmbus_connection.monitor_pages[1];
+	pdata->info.mem[MON_PAGE_MAP].size = PAGE_SIZE;
+	pdata->info.mem[MON_PAGE_MAP].memtype = UIO_MEM_LOGICAL;
+
+	pdata->info.priv = pdata;
+	pdata->device = dev;
+
+	ret = uio_register_device(&dev->device, &pdata->info);
+	if (ret) {
+		dev_err(&dev->device, "hv_uio register failed\n");
+		goto fail_close;
+	}
+
+	hv_set_drvdata(dev, pdata);
+
+	return 0;
+
+fail_close:
+	vmbus_close(dev->channel);
+fail:
+	kfree(pdata);
+
+	return ret;
+}
+
+static int
+hv_uio_remove(struct hv_device *dev)
+{
+	struct hv_uio_private_data *pdata = hv_get_drvdata(dev);
+
+	if (!pdata)
+		return 0;
+
+	uio_unregister_device(&pdata->info);
+	hv_set_drvdata(dev, NULL);
+	vmbus_close(dev->channel);
+	kfree(pdata);
+	return 0;
+}
+
+static struct hv_driver hv_uio_drv = {
+	.name = "uio_hv_generic",
+	.id_table = NULL, /* only dynamic id's */
+	.probe = hv_uio_probe,
+	.remove = hv_uio_remove,
+};
+
+static int __init
+hyperv_module_init(void)
+{
+	return vmbus_driver_register(&hv_uio_drv);
+}
+
+static void __exit
+hyperv_module_exit(void)
+{
+	vmbus_driver_unregister(&hv_uio_drv);
+}
+
+module_init(hyperv_module_init);
+module_exit(hyperv_module_exit);
+
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
