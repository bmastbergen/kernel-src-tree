bnxt_en: Cap the msix vector with the max completion rings.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] bnxt_en: Cap the msix vector with the max completion rings (Jonathan Toppins) [1451915]
Rebuild_FUZZ: 99.15%
commit-author Michael Chan <michael.chan@broadcom.com>
commit 68a946bb81e07ed0e59a99e0c068d091ed42cc1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/68a946bb.failed

The current code enables up to the maximum MSIX vectors in the PCIE
config space without considering the max completion rings available.
An MSIX vector is only useful when it has an associated completion
ring, so it is better to cap it.

	Signed-off-by: Michael Chan <michael.chan@broadcom.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 68a946bb81e07ed0e59a99e0c068d091ed42cc1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnxt/bnxt.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 625e63f5fc00,43b7342c6e82..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@@ -4810,16 -5063,148 +4810,156 @@@ static int bnxt_trim_rings(struct bnxt 
  	return 0;
  }
  
 -static void bnxt_setup_msix(struct bnxt *bp)
 +static int bnxt_setup_msix(struct bnxt *bp)
  {
++<<<<<<< HEAD
++=======
+ 	const int len = sizeof(bp->irq_tbl[0].name);
+ 	struct net_device *dev = bp->dev;
+ 	int tcs, i;
+ 
+ 	tcs = netdev_get_num_tc(dev);
+ 	if (tcs > 1) {
+ 		int i, off, count;
+ 
+ 		for (i = 0; i < tcs; i++) {
+ 			count = bp->tx_nr_rings_per_tc;
+ 			off = i * count;
+ 			netdev_set_tc_queue(dev, i, count, off);
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < bp->cp_nr_rings; i++) {
+ 		char *attr;
+ 
+ 		if (bp->flags & BNXT_FLAG_SHARED_RINGS)
+ 			attr = "TxRx";
+ 		else if (i < bp->rx_nr_rings)
+ 			attr = "rx";
+ 		else
+ 			attr = "tx";
+ 
+ 		snprintf(bp->irq_tbl[i].name, len, "%s-%s-%d", dev->name, attr,
+ 			 i);
+ 		bp->irq_tbl[i].handler = bnxt_msix;
+ 	}
+ }
+ 
+ static void bnxt_setup_inta(struct bnxt *bp)
+ {
+ 	const int len = sizeof(bp->irq_tbl[0].name);
+ 
+ 	if (netdev_get_num_tc(bp->dev))
+ 		netdev_reset_tc(bp->dev);
+ 
+ 	snprintf(bp->irq_tbl[0].name, len, "%s-%s-%d", bp->dev->name, "TxRx",
+ 		 0);
+ 	bp->irq_tbl[0].handler = bnxt_inta;
+ }
+ 
+ static int bnxt_setup_int_mode(struct bnxt *bp)
+ {
+ 	int rc;
+ 
+ 	if (bp->flags & BNXT_FLAG_USING_MSIX)
+ 		bnxt_setup_msix(bp);
+ 	else
+ 		bnxt_setup_inta(bp);
+ 
+ 	rc = bnxt_set_real_num_queues(bp);
+ 	return rc;
+ }
+ 
+ #ifdef CONFIG_RFS_ACCEL
+ static unsigned int bnxt_get_max_func_rss_ctxs(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_rsscos_ctxs;
+ #endif
+ 	return bp->pf.max_rsscos_ctxs;
+ }
+ 
+ static unsigned int bnxt_get_max_func_vnics(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_vnics;
+ #endif
+ 	return bp->pf.max_vnics;
+ }
+ #endif
+ 
+ unsigned int bnxt_get_max_func_stat_ctxs(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_stat_ctxs;
+ #endif
+ 	return bp->pf.max_stat_ctxs;
+ }
+ 
+ void bnxt_set_max_func_stat_ctxs(struct bnxt *bp, unsigned int max)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		bp->vf.max_stat_ctxs = max;
+ 	else
+ #endif
+ 		bp->pf.max_stat_ctxs = max;
+ }
+ 
+ unsigned int bnxt_get_max_func_cp_rings(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return bp->vf.max_cp_rings;
+ #endif
+ 	return bp->pf.max_cp_rings;
+ }
+ 
+ void bnxt_set_max_func_cp_rings(struct bnxt *bp, unsigned int max)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		bp->vf.max_cp_rings = max;
+ 	else
+ #endif
+ 		bp->pf.max_cp_rings = max;
+ }
+ 
+ static unsigned int bnxt_get_max_func_irqs(struct bnxt *bp)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		return min_t(unsigned int, bp->vf.max_irqs,
+ 			     bp->vf.max_cp_rings);
+ #endif
+ 	return min_t(unsigned int, bp->pf.max_irqs, bp->pf.max_cp_rings);
+ }
+ 
+ void bnxt_set_max_func_irqs(struct bnxt *bp, unsigned int max_irqs)
+ {
+ #if defined(CONFIG_BNXT_SRIOV)
+ 	if (BNXT_VF(bp))
+ 		bp->vf.max_irqs = max_irqs;
+ 	else
+ #endif
+ 		bp->pf.max_irqs = max_irqs;
+ }
+ 
+ static int bnxt_init_msix(struct bnxt *bp)
+ {
+ 	int i, total_vecs, rc = 0, min = 1;
++>>>>>>> 68a946bb81e0 (bnxt_en: Cap the msix vector with the max completion rings.)
  	struct msix_entry *msix_ent;
 +	struct net_device *dev = bp->dev;
 +	int i, total_vecs, rc = 0, min = 1;
 +	const int len = sizeof(bp->irq_tbl[0].name);
 +
 +	bp->flags &= ~BNXT_FLAG_USING_MSIX;
 +	total_vecs = bp->cp_nr_rings;
  
 -	total_vecs = bnxt_get_max_func_irqs(bp);
  	msix_ent = kcalloc(total_vecs, sizeof(struct msix_entry), GFP_KERNEL);
  	if (!msix_ent)
  		return -ENOMEM;
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt.c
