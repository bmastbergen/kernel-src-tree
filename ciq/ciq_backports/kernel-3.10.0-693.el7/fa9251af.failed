SUNRPC: Call the default socket callbacks instead of open coding

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit fa9251afc33c81606d70cfe91800a779096442ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fa9251af.failed

Rather than code up our own versions of the socket callbacks, just
call the defaults.
This also allows us to merge svc_udp_data_ready() and svc_tcp_data_ready().

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit fa9251afc33c81606d70cfe91800a779096442ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/svcsock.c
diff --cc net/sunrpc/svcsock.c
index a3ebe6c6b21b,03134708deeb..000000000000
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@@ -60,7 -60,6 +60,10 @@@
  
  static struct svc_sock *svc_setup_socket(struct svc_serv *, struct socket *,
  					 int flags);
++<<<<<<< HEAD
 +static void		svc_udp_data_ready(struct sock *, int);
++=======
++>>>>>>> fa9251afc33c (SUNRPC: Call the default socket callbacks instead of open coding)
  static int		svc_udp_recvfrom(struct svc_rqst *);
  static int		svc_udp_sendto(struct svc_rqst *);
  static void		svc_sock_detach(struct svc_xprt *);
@@@ -402,40 -400,15 +405,19 @@@ static int svc_sock_secure_port(struct 
  /*
   * INET callback when data has been received on the socket.
   */
++<<<<<<< HEAD
 +static void svc_udp_data_ready(struct sock *sk, int count)
++=======
+ static void svc_data_ready(struct sock *sk)
++>>>>>>> fa9251afc33c (SUNRPC: Call the default socket callbacks instead of open coding)
  {
  	struct svc_sock	*svsk = (struct svc_sock *)sk->sk_user_data;
- 	wait_queue_head_t *wq = sk_sleep(sk);
  
  	if (svsk) {
 -		dprintk("svc: socket %p(inet %p), busy=%d\n",
 -			svsk, sk,
 +		dprintk("svc: socket %p(inet %p), count=%d, busy=%d\n",
 +			svsk, sk, count,
  			test_bit(XPT_BUSY, &svsk->sk_xprt.xpt_flags));
+ 		svsk->sk_odata(sk);
  		set_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);
  		svc_xprt_enqueue(&svsk->sk_xprt);
  	}
@@@ -785,10 -753,9 +763,9 @@@ static void svc_udp_init(struct svc_soc
   * A data_ready event on a listening socket means there's a connection
   * pending. Do not use state_change as a substitute for it.
   */
 -static void svc_tcp_listen_data_ready(struct sock *sk)
 +static void svc_tcp_listen_data_ready(struct sock *sk, int count_unused)
  {
  	struct svc_sock	*svsk = (struct svc_sock *)sk->sk_user_data;
- 	wait_queue_head_t *wq;
  
  	dprintk("svc: socket %p TCP (listen) state change %d\n",
  		sk, sk->sk_state);
@@@ -833,23 -798,6 +808,26 @@@ static void svc_tcp_state_change(struc
  		set_bit(XPT_CLOSE, &svsk->sk_xprt.xpt_flags);
  		svc_xprt_enqueue(&svsk->sk_xprt);
  	}
++<<<<<<< HEAD
 +	if (sunrpc_waitqueue_active(wq))
 +		wake_up_interruptible_all(wq);
 +}
 +
 +static void svc_tcp_data_ready(struct sock *sk, int count)
 +{
 +	struct svc_sock *svsk = (struct svc_sock *)sk->sk_user_data;
 +	wait_queue_head_t *wq = sk_sleep(sk);
 +
 +	dprintk("svc: socket %p TCP data ready (svsk %p)\n",
 +		sk, sk->sk_user_data);
 +	if (svsk) {
 +		set_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);
 +		svc_xprt_enqueue(&svsk->sk_xprt);
 +	}
 +	if (sunrpc_waitqueue_active(wq))
 +		wake_up_interruptible(wq);
++=======
++>>>>>>> fa9251afc33c (SUNRPC: Call the default socket callbacks instead of open coding)
  }
  
  /*
* Unmerged path net/sunrpc/svcsock.c
