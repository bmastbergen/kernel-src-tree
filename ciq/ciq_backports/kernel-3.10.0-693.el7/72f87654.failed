userfaultfd: non-cooperative: add mremap() event

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Pavel Emelyanov <xemul@parallels.com>
commit 72f87654c69690ff4721bd9b4a39983f971de9a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/72f87654.failed

The event denotes that an area [start:end] moves to different location.
Length change isn't reported as "new" addresses, if they appear on the
uffd reader side they will not contain any data and the latter can just
zeromap them.

Waiting for the event ACK is also done outside of mmap sem, as for fork
event.

Link: http://lkml.kernel.org/r/20161216144821.5183-12-aarcange@redhat.com
	Signed-off-by: Pavel Emelyanov <xemul@parallels.com>
	Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
	Cc: "Dr. David Alan Gilbert" <dgilbert@redhat.com>
	Cc: Hillf Danton <hillf.zj@alibaba-inc.com>
	Cc: Michael Rapoport <RAPOPORT@il.ibm.com>
	Cc: Mike Kravetz <mike.kravetz@oracle.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 72f87654c69690ff4721bd9b4a39983f971de9a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/userfaultfd.c
#	include/linux/userfaultfd_k.h
#	include/uapi/linux/userfaultfd.h
#	mm/mremap.c
diff --cc fs/userfaultfd.c
index 30b4fae4cd64,68f978beefac..000000000000
--- a/fs/userfaultfd.c
+++ b/fs/userfaultfd.c
@@@ -516,6 -523,116 +516,119 @@@ static void userfaultfd_event_complete(
  	__remove_wait_queue(&ctx->event_wqh, &ewq->wq);
  }
  
++<<<<<<< HEAD
++=======
+ int dup_userfaultfd(struct vm_area_struct *vma, struct list_head *fcs)
+ {
+ 	struct userfaultfd_ctx *ctx = NULL, *octx;
+ 	struct userfaultfd_fork_ctx *fctx;
+ 
+ 	octx = vma->vm_userfaultfd_ctx.ctx;
+ 	if (!octx || !(octx->features & UFFD_FEATURE_EVENT_FORK)) {
+ 		vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;
+ 		vma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);
+ 		return 0;
+ 	}
+ 
+ 	list_for_each_entry(fctx, fcs, list)
+ 		if (fctx->orig == octx) {
+ 			ctx = fctx->new;
+ 			break;
+ 		}
+ 
+ 	if (!ctx) {
+ 		fctx = kmalloc(sizeof(*fctx), GFP_KERNEL);
+ 		if (!fctx)
+ 			return -ENOMEM;
+ 
+ 		ctx = kmem_cache_alloc(userfaultfd_ctx_cachep, GFP_KERNEL);
+ 		if (!ctx) {
+ 			kfree(fctx);
+ 			return -ENOMEM;
+ 		}
+ 
+ 		atomic_set(&ctx->refcount, 1);
+ 		ctx->flags = octx->flags;
+ 		ctx->state = UFFD_STATE_RUNNING;
+ 		ctx->features = octx->features;
+ 		ctx->released = false;
+ 		ctx->mm = vma->vm_mm;
+ 		atomic_inc(&ctx->mm->mm_count);
+ 
+ 		userfaultfd_ctx_get(octx);
+ 		fctx->orig = octx;
+ 		fctx->new = ctx;
+ 		list_add_tail(&fctx->list, fcs);
+ 	}
+ 
+ 	vma->vm_userfaultfd_ctx.ctx = ctx;
+ 	return 0;
+ }
+ 
+ static int dup_fctx(struct userfaultfd_fork_ctx *fctx)
+ {
+ 	struct userfaultfd_ctx *ctx = fctx->orig;
+ 	struct userfaultfd_wait_queue ewq;
+ 
+ 	msg_init(&ewq.msg);
+ 
+ 	ewq.msg.event = UFFD_EVENT_FORK;
+ 	ewq.msg.arg.reserved.reserved1 = (unsigned long)fctx->new;
+ 
+ 	return userfaultfd_event_wait_completion(ctx, &ewq);
+ }
+ 
+ void dup_userfaultfd_complete(struct list_head *fcs)
+ {
+ 	int ret = 0;
+ 	struct userfaultfd_fork_ctx *fctx, *n;
+ 
+ 	list_for_each_entry_safe(fctx, n, fcs, list) {
+ 		if (!ret)
+ 			ret = dup_fctx(fctx);
+ 		list_del(&fctx->list);
+ 		kfree(fctx);
+ 	}
+ }
+ 
+ void mremap_userfaultfd_prep(struct vm_area_struct *vma,
+ 			     struct vm_userfaultfd_ctx *vm_ctx)
+ {
+ 	struct userfaultfd_ctx *ctx;
+ 
+ 	ctx = vma->vm_userfaultfd_ctx.ctx;
+ 	if (ctx && (ctx->features & UFFD_FEATURE_EVENT_REMAP)) {
+ 		vm_ctx->ctx = ctx;
+ 		userfaultfd_ctx_get(ctx);
+ 	}
+ }
+ 
+ void mremap_userfaultfd_complete(struct vm_userfaultfd_ctx vm_ctx,
+ 				 unsigned long from, unsigned long to,
+ 				 unsigned long len)
+ {
+ 	struct userfaultfd_ctx *ctx = vm_ctx.ctx;
+ 	struct userfaultfd_wait_queue ewq;
+ 
+ 	if (!ctx)
+ 		return;
+ 
+ 	if (to & ~PAGE_MASK) {
+ 		userfaultfd_ctx_put(ctx);
+ 		return;
+ 	}
+ 
+ 	msg_init(&ewq.msg);
+ 
+ 	ewq.msg.event = UFFD_EVENT_REMAP;
+ 	ewq.msg.arg.remap.from = from;
+ 	ewq.msg.arg.remap.to = to;
+ 	ewq.msg.arg.remap.len = len;
+ 
+ 	userfaultfd_event_wait_completion(ctx, &ewq);
+ }
+ 
++>>>>>>> 72f87654c696 (userfaultfd: non-cooperative: add mremap() event)
  static int userfaultfd_release(struct inode *inode, struct file *file)
  {
  	struct userfaultfd_ctx *ctx = file->private_data;
diff --cc include/linux/userfaultfd_k.h
index 587480ad41b7,7f318a46044b..000000000000
--- a/include/linux/userfaultfd_k.h
+++ b/include/linux/userfaultfd_k.h
@@@ -53,6 -52,15 +53,18 @@@ static inline bool userfaultfd_armed(st
  	return vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP);
  }
  
++<<<<<<< HEAD
++=======
+ extern int dup_userfaultfd(struct vm_area_struct *, struct list_head *);
+ extern void dup_userfaultfd_complete(struct list_head *);
+ 
+ extern void mremap_userfaultfd_prep(struct vm_area_struct *,
+ 				    struct vm_userfaultfd_ctx *);
+ extern void mremap_userfaultfd_complete(struct vm_userfaultfd_ctx,
+ 					unsigned long from, unsigned long to,
+ 					unsigned long len);
+ 
++>>>>>>> 72f87654c696 (userfaultfd: non-cooperative: add mremap() event)
  #else /* CONFIG_USERFAULTFD */
  
  /* mm helpers */
@@@ -80,6 -85,27 +92,30 @@@ static inline bool userfaultfd_armed(st
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int dup_userfaultfd(struct vm_area_struct *vma,
+ 				  struct list_head *l)
+ {
+ 	return 0;
+ }
+ 
+ static inline void dup_userfaultfd_complete(struct list_head *l)
+ {
+ }
+ 
+ static inline void mremap_userfaultfd_prep(struct vm_area_struct *vma,
+ 					   struct vm_userfaultfd_ctx *ctx)
+ {
+ }
+ 
+ static inline void mremap_userfaultfd_complete(struct vm_userfaultfd_ctx ctx,
+ 					       unsigned long from,
+ 					       unsigned long to,
+ 					       unsigned long len)
+ {
+ }
++>>>>>>> 72f87654c696 (userfaultfd: non-cooperative: add mremap() event)
  #endif /* CONFIG_USERFAULTFD */
  
  #endif /* _LINUX_USERFAULTFD_K_H */
diff --cc include/uapi/linux/userfaultfd.h
index d9111d5b3ae2,79a85e5bd388..000000000000
--- a/include/uapi/linux/userfaultfd.h
+++ b/include/uapi/linux/userfaultfd.h
@@@ -18,12 -18,8 +18,17 @@@
   * means the userland is reading).
   */
  #define UFFD_API ((__u64)0xAA)
++<<<<<<< HEAD
 +/*
 + * After implementing the respective features it will become:
 + * #define UFFD_API_FEATURES (UFFD_FEATURE_PAGEFAULT_FLAG_WP | \
 + *			      UFFD_FEATURE_EVENT_FORK)
 + */
 +#define UFFD_API_FEATURES (0)
++=======
+ #define UFFD_API_FEATURES (UFFD_FEATURE_EVENT_FORK |	    \
+ 			   UFFD_FEATURE_EVENT_REMAP)
++>>>>>>> 72f87654c696 (userfaultfd: non-cooperative: add mremap() event)
  #define UFFD_API_IOCTLS				\
  	((__u64)1 << _UFFDIO_REGISTER |		\
  	 (__u64)1 << _UFFDIO_UNREGISTER |	\
@@@ -78,6 -74,16 +83,19 @@@ struct uffd_msg 
  		} pagefault;
  
  		struct {
++<<<<<<< HEAD
++=======
+ 			__u32	ufd;
+ 		} fork;
+ 
+ 		struct {
+ 			__u64	from;
+ 			__u64	to;
+ 			__u64	len;
+ 		} remap;
+ 
+ 		struct {
++>>>>>>> 72f87654c696 (userfaultfd: non-cooperative: add mremap() event)
  			/* unused reserved fields */
  			__u64	reserved1;
  			__u64	reserved2;
@@@ -90,9 -96,8 +108,13 @@@
   * Start at 0x12 and not at 0 to be more strict against bugs.
   */
  #define UFFD_EVENT_PAGEFAULT	0x12
 +#if 0 /* not available yet */
  #define UFFD_EVENT_FORK		0x13
++<<<<<<< HEAD
 +#endif
++=======
+ #define UFFD_EVENT_REMAP	0x14
++>>>>>>> 72f87654c696 (userfaultfd: non-cooperative: add mremap() event)
  
  /* flags for UFFD_EVENT_PAGEFAULT */
  #define UFFD_PAGEFAULT_FLAG_WRITE	(1<<0)	/* If this was a write fault */
@@@ -111,10 -116,9 +133,14 @@@ struct uffdio_api 
  	 * are to be considered implicitly always enabled in all kernels as
  	 * long as the uffdio_api.api requested matches UFFD_API.
  	 */
 +#if 0 /* not available yet */
  #define UFFD_FEATURE_PAGEFAULT_FLAG_WP		(1<<0)
  #define UFFD_FEATURE_EVENT_FORK			(1<<1)
++<<<<<<< HEAD
 +#endif
++=======
+ #define UFFD_FEATURE_EVENT_REMAP		(1<<2)
++>>>>>>> 72f87654c696 (userfaultfd: non-cooperative: add mremap() event)
  	__u64 features;
  
  	__u64 ioctls;
diff --cc mm/mremap.c
index 4ee507690d73,504b560c013c..000000000000
--- a/mm/mremap.c
+++ b/mm/mremap.c
@@@ -20,11 -20,10 +20,12 @@@
  #include <linux/security.h>
  #include <linux/syscalls.h>
  #include <linux/mmu_notifier.h>
 +#include <linux/sched/sysctl.h>
  #include <linux/uaccess.h>
  #include <linux/mm-arch-hooks.h>
+ #include <linux/userfaultfd_k.h>
  
 +#include <asm/uaccess.h>
  #include <asm/cacheflush.h>
  #include <asm/tlbflush.h>
  
@@@ -288,14 -309,9 +290,18 @@@ static unsigned long move_vma(struct vm
  		vma = new_vma;
  		old_len = new_len;
  		old_addr = new_addr;
 -		new_addr = err;
 +		new_addr = -ENOMEM;
  	} else {
++<<<<<<< HEAD
 +		if (vm_flags & VM_FOP_EXTEND) {
 +			struct file_operations_extend *fop = to_fop_extend(vma->vm_file->f_op);
 +			if (fop->mremap)
 +				fop->mremap(vma->vm_file, new_vma);
 +		
 +		}
++=======
+ 		mremap_userfaultfd_prep(new_vma, uf);
++>>>>>>> 72f87654c696 (userfaultfd: non-cooperative: add mremap() event)
  		arch_remap(mm, old_addr, old_addr + old_len,
  			   new_addr, new_addr + new_len);
  	}
@@@ -454,11 -459,11 +461,16 @@@ static unsigned long mremap_to(unsigne
  	ret = get_unmapped_area(vma->vm_file, new_addr, new_len, vma->vm_pgoff +
  				((addr - vma->vm_start) >> PAGE_SHIFT),
  				map_flags);
 -	if (offset_in_page(ret))
 +	if (ret & ~PAGE_MASK)
  		goto out1;
  
++<<<<<<< HEAD
 +	ret = move_vma(vma, addr, old_len, new_len, new_addr, locked);
 +	if (!(ret & ~PAGE_MASK))
++=======
+ 	ret = move_vma(vma, addr, old_len, new_len, new_addr, locked, uf);
+ 	if (!(offset_in_page(ret)))
++>>>>>>> 72f87654c696 (userfaultfd: non-cooperative: add mremap() event)
  		goto out;
  out1:
  	vm_unacct_memory(charged);
@@@ -496,14 -501,16 +508,15 @@@ SYSCALL_DEFINE5(mremap, unsigned long, 
  	unsigned long ret = -EINVAL;
  	unsigned long charged = 0;
  	bool locked = false;
+ 	struct vm_userfaultfd_ctx uf = NULL_VM_UFFD_CTX;
  
 -	if (flags & ~(MREMAP_FIXED | MREMAP_MAYMOVE))
 -		return ret;
 +	down_write(&current->mm->mmap_sem);
  
 -	if (flags & MREMAP_FIXED && !(flags & MREMAP_MAYMOVE))
 -		return ret;
 +	if (flags & ~(MREMAP_FIXED | MREMAP_MAYMOVE))
 +		goto out;
  
 -	if (offset_in_page(addr))
 -		return ret;
 +	if (addr & ~PAGE_MASK)
 +		goto out;
  
  	old_len = PAGE_ALIGN(old_len);
  	new_len = PAGE_ALIGN(new_len);
@@@ -514,12 -521,14 +527,17 @@@
  	 * a zero new-len is nonsensical.
  	 */
  	if (!new_len)
 -		return ret;
 -
 -	if (down_write_killable(&current->mm->mmap_sem))
 -		return -EINTR;
 +		goto out;
  
  	if (flags & MREMAP_FIXED) {
++<<<<<<< HEAD
 +		if (flags & MREMAP_MAYMOVE)
 +			ret = mremap_to(addr, old_len, new_addr, new_len,
 +					&locked);
++=======
+ 		ret = mremap_to(addr, old_len, new_addr, new_len,
+ 				&locked, &uf);
++>>>>>>> 72f87654c696 (userfaultfd: non-cooperative: add mremap() event)
  		goto out;
  	}
  
@@@ -588,11 -597,14 +606,12 @@@
  			goto out;
  		}
  
- 		ret = move_vma(vma, addr, old_len, new_len, new_addr, &locked);
+ 		ret = move_vma(vma, addr, old_len, new_len, new_addr,
+ 			       &locked, &uf);
  	}
  out:
 -	if (offset_in_page(ret)) {
 +	if (ret & ~PAGE_MASK)
  		vm_unacct_memory(charged);
 -		locked = 0;
 -	}
  	up_write(&current->mm->mmap_sem);
  	if (locked && new_len > old_len)
  		mm_populate(new_addr + old_len, new_len - old_len);
* Unmerged path fs/userfaultfd.c
* Unmerged path include/linux/userfaultfd_k.h
* Unmerged path include/uapi/linux/userfaultfd.h
* Unmerged path mm/mremap.c
