mlxsw: spectrum: Limit number of FDB records per learning session

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 1803e0fb7ef9534154e6a1abf77bc2ca352f72e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1803e0fb.failed

Up until now a learning session ended whenever the number of queried
records was zero. This turned out to be problematic in situations where
a large number of MACs (48K) had to be processed by the switch driver,
as RTNL mutex is held during the learning session.

Instead, limit the number of FDB records that can be processed in a
session to 64. This means that every time the device is queried for
learning notifications (currently, every 100ms), up to 64 records will
be processed by the switch driver.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1803e0fb7ef9534154e6a1abf77bc2ca352f72e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
index 3cfb2782765a,02de24080e79..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
@@@ -1494,19 -1495,19 +1494,35 @@@ static void mlxsw_sp_fdb_notify_work(st
  
  	mlxsw_sp = container_of(work, struct mlxsw_sp, fdb_notify.dw.work);
  
++<<<<<<< HEAD
 +	do {
 +		mlxsw_reg_sfn_pack(sfn_pl);
 +		err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(sfn), sfn_pl);
 +		if (err) {
 +			dev_err_ratelimited(mlxsw_sp->bus_info->dev, "Failed to get FDB notifications\n");
 +			break;
 +		}
 +		num_rec = mlxsw_reg_sfn_num_rec_get(sfn_pl);
 +		for (i = 0; i < num_rec; i++)
 +			mlxsw_sp_fdb_notify_rec_process(mlxsw_sp, sfn_pl, i);
 +
 +	} while (num_rec);
 +
++=======
+ 	rtnl_lock();
+ 	mlxsw_reg_sfn_pack(sfn_pl);
+ 	err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(sfn), sfn_pl);
+ 	if (err) {
+ 		dev_err_ratelimited(mlxsw_sp->bus_info->dev, "Failed to get FDB notifications\n");
+ 		goto out;
+ 	}
+ 	num_rec = mlxsw_reg_sfn_num_rec_get(sfn_pl);
+ 	for (i = 0; i < num_rec; i++)
+ 		mlxsw_sp_fdb_notify_rec_process(mlxsw_sp, sfn_pl, i);
+ 
+ out:
+ 	rtnl_unlock();
++>>>>>>> 1803e0fb7ef9 (mlxsw: spectrum: Limit number of FDB records per learning session)
  	kfree(sfn_pl);
  	mlxsw_sp_fdb_notify_work_schedule(mlxsw_sp);
  }
diff --git a/drivers/net/ethernet/mellanox/mlxsw/reg.h b/drivers/net/ethernet/mellanox/mlxsw/reg.h
index 1721098eef13..b83d0a7a0b49 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/reg.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/reg.h
@@ -591,6 +591,12 @@ static const struct mlxsw_reg_info mlxsw_reg_sfn = {
  */
 MLXSW_ITEM32(reg, sfn, swid, 0x00, 24, 8);
 
+/* reg_sfn_end
+ * Forces the current session to end.
+ * Access: OP
+ */
+MLXSW_ITEM32(reg, sfn, end, 0x04, 20, 1);
+
 /* reg_sfn_num_rec
  * Request: Number of learned notifications and aged-out notification
  * records requested.
@@ -605,6 +611,7 @@ static inline void mlxsw_reg_sfn_pack(char *payload)
 {
 	MLXSW_REG_ZERO(sfn, payload);
 	mlxsw_reg_sfn_swid_set(payload, 0);
+	mlxsw_reg_sfn_end_set(payload, 1);
 	mlxsw_reg_sfn_num_rec_set(payload, MLXSW_REG_SFN_REC_MAX_COUNT);
 }
 
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
