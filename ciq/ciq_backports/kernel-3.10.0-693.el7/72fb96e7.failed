l2tp: do not use udp_ioctl()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 72fb96e7bdbbdd4421b0726992496531060f3636
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/72fb96e7.failed

udp_ioctl(), as its name suggests, is used by UDP protocols,
but is also used by L2TP :(

L2TP should use its own handler, because it really does not
look the same.

SIOCINQ for instance should not assume UDP checksum or headers.

Thanks to Andrey and syzkaller team for providing the report
and a nice reproducer.

While crashes only happen on recent kernels (after commit
7c13f97ffde6 ("udp: do fwd memory scheduling on dequeue")), this
probably needs to be backported to older kernels.

Fixes: 7c13f97ffde6 ("udp: do fwd memory scheduling on dequeue")
Fixes: 85584672012e ("udp: Fix udp_poll() and ioctl()")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: Andrey Konovalov <andreyknvl@google.com>
	Acked-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 72fb96e7bdbbdd4421b0726992496531060f3636)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/l2tp/l2tp_core.h
diff --cc net/l2tp/l2tp_core.h
index 255d7efe7f84,aebf281d09ee..000000000000
--- a/net/l2tp/l2tp_core.h
+++ b/net/l2tp/l2tp_core.h
@@@ -235,29 -230,40 +235,36 @@@ out
  	return tunnel;
  }
  
 -struct l2tp_session *l2tp_session_find(struct net *net,
 -				       struct l2tp_tunnel *tunnel,
 -				       u32 session_id);
 -struct l2tp_session *l2tp_session_find_nth(struct l2tp_tunnel *tunnel, int nth);
 -struct l2tp_session *l2tp_session_find_by_ifname(struct net *net, char *ifname);
 -struct l2tp_tunnel *l2tp_tunnel_find(struct net *net, u32 tunnel_id);
 -struct l2tp_tunnel *l2tp_tunnel_find_nth(struct net *net, int nth);
 -
 -int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id,
 -		       u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg,
 -		       struct l2tp_tunnel **tunnelp);
 -void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel);
 -int l2tp_tunnel_delete(struct l2tp_tunnel *tunnel);
 -struct l2tp_session *l2tp_session_create(int priv_size,
 -					 struct l2tp_tunnel *tunnel,
 -					 u32 session_id, u32 peer_session_id,
 -					 struct l2tp_session_cfg *cfg);
 -void __l2tp_session_unhash(struct l2tp_session *session);
 -int l2tp_session_delete(struct l2tp_session *session);
 -void l2tp_session_free(struct l2tp_session *session);
 -void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,
 -		      unsigned char *ptr, unsigned char *optr, u16 hdrflags,
 -		      int length, int (*payload_hook)(struct sk_buff *skb));
 -int l2tp_session_queue_purge(struct l2tp_session *session);
 -int l2tp_udp_encap_recv(struct sock *sk, struct sk_buff *skb);
 -void l2tp_session_set_header_len(struct l2tp_session *session, int version);
 -
 -int l2tp_xmit_skb(struct l2tp_session *session, struct sk_buff *skb,
 -		  int hdr_len);
 -
 +extern struct sock *l2tp_tunnel_sock_lookup(struct l2tp_tunnel *tunnel);
 +extern void l2tp_tunnel_sock_put(struct sock *sk);
 +extern struct l2tp_session *l2tp_session_find(struct net *net, struct l2tp_tunnel *tunnel, u32 session_id);
 +extern struct l2tp_session *l2tp_session_find_nth(struct l2tp_tunnel *tunnel, int nth);
 +extern struct l2tp_session *l2tp_session_find_by_ifname(struct net *net, char *ifname);
 +extern struct l2tp_tunnel *l2tp_tunnel_find(struct net *net, u32 tunnel_id);
 +extern struct l2tp_tunnel *l2tp_tunnel_find_nth(struct net *net, int nth);
 +
 +extern int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id, u32 peer_tunnel_id, struct l2tp_tunnel_cfg *cfg, struct l2tp_tunnel **tunnelp);
 +extern void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel);
 +extern int l2tp_tunnel_delete(struct l2tp_tunnel *tunnel);
 +extern struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg);
 +extern void __l2tp_session_unhash(struct l2tp_session *session);
 +extern int l2tp_session_delete(struct l2tp_session *session);
 +extern void l2tp_session_free(struct l2tp_session *session);
 +extern void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb, unsigned char *ptr, unsigned char *optr, u16 hdrflags, int length, int (*payload_hook)(struct sk_buff *skb));
 +extern int l2tp_session_queue_purge(struct l2tp_session *session);
 +extern int l2tp_udp_encap_recv(struct sock *sk, struct sk_buff *skb);
 +
 +extern int l2tp_xmit_skb(struct l2tp_session *session, struct sk_buff *skb, int hdr_len);
 +
++<<<<<<< HEAD
 +extern int l2tp_nl_register_ops(enum l2tp_pwtype pw_type, const struct l2tp_nl_cmd_ops *ops);
 +extern void l2tp_nl_unregister_ops(enum l2tp_pwtype pw_type);
++=======
+ int l2tp_nl_register_ops(enum l2tp_pwtype pw_type,
+ 			 const struct l2tp_nl_cmd_ops *ops);
+ void l2tp_nl_unregister_ops(enum l2tp_pwtype pw_type);
+ int l2tp_ioctl(struct sock *sk, int cmd, unsigned long arg);
++>>>>>>> 72fb96e7bdbb (l2tp: do not use udp_ioctl())
  
  /* Session reference counts. Incremented when code obtains a reference
   * to a session.
* Unmerged path net/l2tp/l2tp_core.h
diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c
index 0fc8e647a166..d684dcd2b39e 100644
--- a/net/l2tp/l2tp_ip.c
+++ b/net/l2tp/l2tp_ip.c
@@ -11,6 +11,7 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <asm/ioctls.h>
 #include <linux/icmp.h>
 #include <linux/module.h>
 #include <linux/skbuff.h>
@@ -552,6 +553,30 @@ out:
 	return err ? err : copied;
 }
 
+int l2tp_ioctl(struct sock *sk, int cmd, unsigned long arg)
+{
+	struct sk_buff *skb;
+	int amount;
+
+	switch (cmd) {
+	case SIOCOUTQ:
+		amount = sk_wmem_alloc_get(sk);
+		break;
+	case SIOCINQ:
+		spin_lock_bh(&sk->sk_receive_queue.lock);
+		skb = skb_peek(&sk->sk_receive_queue);
+		amount = skb ? skb->len : 0;
+		spin_unlock_bh(&sk->sk_receive_queue.lock);
+		break;
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+
+	return put_user(amount, (int __user *)arg);
+}
+EXPORT_SYMBOL(l2tp_ioctl);
+
 static struct proto l2tp_ip_prot = {
 	.name		   = "L2TP/IP",
 	.owner		   = THIS_MODULE,
@@ -560,7 +585,7 @@ static struct proto l2tp_ip_prot = {
 	.bind		   = l2tp_ip_bind,
 	.connect	   = l2tp_ip_connect,
 	.disconnect	   = l2tp_ip_disconnect,
-	.ioctl		   = udp_ioctl,
+	.ioctl		   = l2tp_ioctl,
 	.destroy	   = l2tp_ip_destroy_sock,
 	.setsockopt	   = ip_setsockopt,
 	.getsockopt	   = ip_getsockopt,
diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c
index aae2af6e81df..f0c765f8122d 100644
--- a/net/l2tp/l2tp_ip6.c
+++ b/net/l2tp/l2tp_ip6.c
@@ -717,7 +717,7 @@ static struct proto l2tp_ip6_prot = {
 	.bind		   = l2tp_ip6_bind,
 	.connect	   = l2tp_ip6_connect,
 	.disconnect	   = l2tp_ip6_disconnect,
-	.ioctl		   = udp_ioctl,
+	.ioctl		   = l2tp_ioctl,
 	.destroy	   = l2tp_ip6_destroy_sock,
 	.setsockopt	   = ipv6_setsockopt,
 	.getsockopt	   = ipv6_getsockopt,
