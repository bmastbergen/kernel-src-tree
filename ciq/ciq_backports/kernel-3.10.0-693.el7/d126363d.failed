kvm/page_track: call notifiers with kvm_page_track_notifier_node

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jike Song <jike.song@intel.com>
commit d126363d8fe946c9bb2538839de9b09f5b3b8ba3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d126363d.failed

The user of page_track might needs extra information, so pass
the kvm_page_track_notifier_node to callbacks.

	Signed-off-by: Jike Song <jike.song@intel.com>
	Reviewed-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit d126363d8fe946c9bb2538839de9b09f5b3b8ba3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_page_track.h
#	arch/x86/kvm/mmu.c
#	arch/x86/kvm/page_track.c
diff --cc arch/x86/kvm/mmu.c
index 9645a520c25f,87c5880ba3b7..000000000000
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@@ -4364,8 -4404,9 +4364,14 @@@ static u64 *get_written_sptes(struct kv
  	return spte;
  }
  
++<<<<<<< HEAD
 +void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,
 +		       const u8 *new, int bytes)
++=======
+ static void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,
+ 			      const u8 *new, int bytes,
+ 			      struct kvm_page_track_notifier_node *node)
++>>>>>>> d126363d8fe9 (kvm/page_track: call notifiers with kvm_page_track_notifier_node)
  {
  	gfn_t gfn = gpa >> PAGE_SHIFT;
  	struct kvm_mmu_page *sp;
@@@ -4579,8 -4618,31 +4585,34 @@@ void kvm_mmu_setup(struct kvm_vcpu *vcp
  	init_kvm_mmu(vcpu);
  }
  
++<<<<<<< HEAD
++=======
+ static void kvm_mmu_invalidate_zap_pages_in_memslot(struct kvm *kvm,
+ 			struct kvm_memory_slot *slot,
+ 			struct kvm_page_track_notifier_node *node)
+ {
+ 	kvm_mmu_invalidate_zap_all_pages(kvm);
+ }
+ 
+ void kvm_mmu_init_vm(struct kvm *kvm)
+ {
+ 	struct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;
+ 
+ 	node->track_write = kvm_mmu_pte_write;
+ 	node->track_flush_slot = kvm_mmu_invalidate_zap_pages_in_memslot;
+ 	kvm_page_track_register_notifier(kvm, node);
+ }
+ 
+ void kvm_mmu_uninit_vm(struct kvm *kvm)
+ {
+ 	struct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;
+ 
+ 	kvm_page_track_unregister_notifier(kvm, node);
+ }
+ 
++>>>>>>> d126363d8fe9 (kvm/page_track: call notifiers with kvm_page_track_notifier_node)
  /* The return value indicates if tlb flush on all vcpus is needed. */
 -typedef bool (*slot_level_handler) (struct kvm *kvm, struct kvm_rmap_head *rmap_head);
 +typedef bool (*slot_level_handler) (struct kvm *kvm, unsigned long *rmap);
  
  /* The caller should hold mmu-lock before calling this function. */
  static bool
* Unmerged path arch/x86/include/asm/kvm_page_track.h
* Unmerged path arch/x86/kvm/page_track.c
* Unmerged path arch/x86/include/asm/kvm_page_track.h
* Unmerged path arch/x86/kvm/mmu.c
* Unmerged path arch/x86/kvm/page_track.c
