ipv6: lock socket in ip6_datagram_connect()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 03645a11a570d52e70631838cb786eb4253eb463
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/03645a11.failed

ip6_datagram_connect() is doing a lot of socket changes without
socket being locked.

This looks wrong, at least for udp_lib_rehash() which could corrupt
lists because of concurrent udp_sk(sk)->udp_portaddr_hash accesses.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 03645a11a570d52e70631838cb786eb4253eb463)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/datagram.c
diff --cc net/ipv6/datagram.c
index 053beb286c7e,b10a88986a98..000000000000
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@@ -40,114 -40,18 +40,118 @@@ static bool ipv6_mapped_addr_any(const 
  	return ipv6_addr_v4mapped(a) && (a->s6_addr32[3] == 0);
  }
  
++<<<<<<< HEAD
 +static void ip6_datagram_flow_key_init(struct flowi6 *fl6, struct sock *sk)
 +{
 +	struct inet_sock *inet = inet_sk(sk);
 +	struct ipv6_pinfo *np = inet6_sk(sk);
 +
 +	memset(fl6, 0, sizeof(*fl6));
 +	fl6->flowi6_proto = sk->sk_protocol;
 +	fl6->daddr = sk->sk_v6_daddr;
 +	fl6->saddr = np->saddr;
 +	fl6->flowi6_oif = sk->sk_bound_dev_if;
 +	fl6->flowi6_mark = sk->sk_mark;
 +	fl6->fl6_dport = inet->inet_dport;
 +	fl6->fl6_sport = inet->inet_sport;
 +	fl6->flowlabel = np->flow_label;
 +
 +	if (!fl6->flowi6_oif)
 +		fl6->flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;
 +
 +	if (!fl6->flowi6_oif && ipv6_addr_is_multicast(&fl6->daddr))
 +		fl6->flowi6_oif = np->mcast_oif;
 +
 +	security_sk_classify_flow(sk, flowi6_to_flowi(fl6));
 +}
 +
 +int ip6_datagram_dst_update(struct sock *sk, bool fix_sk_saddr)
 +{
 +	struct ip6_flowlabel *flowlabel = NULL;
 +	struct in6_addr *final_p, final;
 +	struct ipv6_txoptions *opt;
 +	struct dst_entry *dst;
 +	struct inet_sock *inet = inet_sk(sk);
 +	struct ipv6_pinfo *np = inet6_sk(sk);
 +	struct flowi6 fl6;
 +	int err = 0;
 +
 +	if (np->sndflow && (np->flow_label & IPV6_FLOWLABEL_MASK)) {
 +		flowlabel = fl6_sock_lookup(sk, np->flow_label);
 +		if (!flowlabel)
 +			return -EINVAL;
 +	}
 +	ip6_datagram_flow_key_init(&fl6, sk);
 +
 +	rcu_read_lock();
 +	opt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);
 +	final_p = fl6_update_dst(&fl6, opt, &final);
 +	rcu_read_unlock();
 +
 +	dst = ip6_dst_lookup_flow(sk, &fl6, final_p);
 +	if (IS_ERR(dst)) {
 +		err = PTR_ERR(dst);
 +		goto out;
 +	}
 +
 +	if (fix_sk_saddr) {
 +		if (ipv6_addr_any(&np->saddr))
 +			np->saddr = fl6.saddr;
 +
 +		if (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {
 +			sk->sk_v6_rcv_saddr = fl6.saddr;
 +			inet->inet_rcv_saddr = LOOPBACK4_IPV6;
 +			if (sk->sk_prot->rehash)
 +				sk->sk_prot->rehash(sk);
 +		}
 +	}
 +
 +	ip6_dst_store(sk, dst,
 +		      ipv6_addr_equal(&fl6.daddr, &sk->sk_v6_daddr) ?
 +		      &sk->sk_v6_daddr : NULL,
 +#ifdef CONFIG_IPV6_SUBTREES
 +		      ipv6_addr_equal(&fl6.saddr, &np->saddr) ?
 +		      &np->saddr :
 +#endif
 +		      NULL);
 +
 +out:
 +	fl6_sock_release(flowlabel);
 +	return err;
 +}
 +
 +void ip6_datagram_release_cb(struct sock *sk)
 +{
 +	struct dst_entry *dst;
 +
 +	if (ipv6_addr_v4mapped(&sk->sk_v6_daddr))
 +		return;
 +
 +	rcu_read_lock();
 +	dst = __sk_dst_get(sk);
 +	if (!dst || !dst->obsolete ||
 +	    dst->ops->check(dst, inet6_sk(sk)->dst_cookie)) {
 +		rcu_read_unlock();
 +		return;
 +	}
 +	rcu_read_unlock();
 +
 +	ip6_datagram_dst_update(sk, false);
 +}
 +EXPORT_SYMBOL_GPL(ip6_datagram_release_cb);
 +
 +int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
++=======
+ static int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
++>>>>>>> 03645a11a570 (ipv6: lock socket in ip6_datagram_connect())
  {
  	struct sockaddr_in6	*usin = (struct sockaddr_in6 *) uaddr;
 -	struct inet_sock	*inet = inet_sk(sk);
 -	struct ipv6_pinfo	*np = inet6_sk(sk);
 -	struct in6_addr	*daddr, *final_p, final;
 -	struct dst_entry	*dst;
 -	struct flowi6		fl6;
 -	struct ip6_flowlabel	*flowlabel = NULL;
 -	struct ipv6_txoptions	*opt;
 +	struct inet_sock      	*inet = inet_sk(sk);
 +	struct ipv6_pinfo      	*np = inet6_sk(sk);
 +	struct in6_addr		*daddr;
  	int			addr_type;
  	int			err;
 +	__be32			fl6_flowlabel = 0;
  
  	if (usin->sin6_family == AF_INET) {
  		if (__ipv6_only_sock(sk))
@@@ -250,10 -201,31 +254,20 @@@ ipv4_connected
  	sk->sk_state = TCP_ESTABLISHED;
  	ip6_set_txhash(sk);
  out:
 -	fl6_sock_release(flowlabel);
  	return err;
  }
+ 
+ int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
+ {
+ 	int res;
+ 
+ 	lock_sock(sk);
+ 	res = __ip6_datagram_connect(sk, uaddr, addr_len);
+ 	release_sock(sk);
+ 	return res;
+ }
  EXPORT_SYMBOL_GPL(ip6_datagram_connect);
  
 -int ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *uaddr,
 -				 int addr_len)
 -{
 -	DECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, uaddr);
 -	if (sin6->sin6_family != AF_INET6)
 -		return -EAFNOSUPPORT;
 -	return ip6_datagram_connect(sk, uaddr, addr_len);
 -}
 -EXPORT_SYMBOL_GPL(ip6_datagram_connect_v6_only);
 -
  void ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,
  		     __be16 port, u32 info, u8 *payload)
  {
diff --git a/include/net/ip.h b/include/net/ip.h
index 5506ed81f7f4..1898197d08eb 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -161,6 +161,7 @@ static inline __u8 get_rtconn_flags(struct ipcm_cookie* ipc, struct sock* sk)
 }
 
 /* datagram.c */
+int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
 int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
 
 void ip4_datagram_release_cb(struct sock *sk);
diff --git a/net/ipv4/datagram.c b/net/ipv4/datagram.c
index 90c0e8386116..574fad9cca05 100644
--- a/net/ipv4/datagram.c
+++ b/net/ipv4/datagram.c
@@ -20,7 +20,7 @@
 #include <net/route.h>
 #include <net/tcp_states.h>
 
-int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
+int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 {
 	struct inet_sock *inet = inet_sk(sk);
 	struct sockaddr_in *usin = (struct sockaddr_in *) uaddr;
@@ -39,8 +39,6 @@ int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 
 	sk_dst_reset(sk);
 
-	lock_sock(sk);
-
 	oif = sk->sk_bound_dev_if;
 	saddr = inet->inet_saddr;
 	if (ipv4_is_multicast(usin->sin_addr.s_addr)) {
@@ -82,9 +80,19 @@ int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	sk_dst_set(sk, &rt->dst);
 	err = 0;
 out:
-	release_sock(sk);
 	return err;
 }
+EXPORT_SYMBOL(__ip4_datagram_connect);
+
+int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
+{
+	int res;
+
+	lock_sock(sk);
+	res = __ip4_datagram_connect(sk, uaddr, addr_len);
+	release_sock(sk);
+	return res;
+}
 EXPORT_SYMBOL(ip4_datagram_connect);
 
 /* Because UDP xmit path can manipulate sk_dst_cache without holding
* Unmerged path net/ipv6/datagram.c
