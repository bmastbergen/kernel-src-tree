libcxgb,iw_cxgb4,cxgbit: add cxgb_best_mtu()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [target] libcxgb, iw_cxgb4, cxgbit: add cxgb_best_mtu() (Don Dutile) [1385866 1417285]
Rebuild_FUZZ: 97.78%
commit-author Varun Prakash <varun@chelsio.com>
commit 44c6d06992ac663e5163bdbe00844cb845ed5703
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/44c6d069.failed

Add cxgb_best_mtu() in libcxgb_cm.h to remove
it's duplicate definitions from cxgb4/cm.c and
cxgbit/cxgbit_cm.c

	Signed-off-by: Varun Prakash <varun@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 44c6d06992ac663e5163bdbe00844cb845ed5703)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
diff --cc drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
index 1d7bd82a1fb1,7fb4feb3c221..000000000000
--- a/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
+++ b/drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
@@@ -30,33 -30,48 +30,77 @@@
   * SOFTWARE.
   */
  
++<<<<<<< HEAD:drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
 +/*
 + * This file is conditionally built on PowerPC only.  Otherwise weak symbol
 + * versions of the functions exported from here are used.
++=======
+ #ifndef __LIBCXGB_CM_H__
+ #define __LIBCXGB_CM_H__
+ 
+ 
+ #include <net/tcp.h>
+ 
+ #include <cxgb4.h>
+ #include <t4_msg.h>
+ 
+ void
+ cxgb_get_4tuple(struct cpl_pass_accept_req *, enum chip_type,
+ 		int *, __u8 *, __u8 *, __be16 *, __be16 *);
+ struct dst_entry *
+ cxgb_find_route(struct cxgb4_lld_info *,
+ 		struct net_device *(*)(struct net_device *),
+ 		__be32, __be32, __be16,	__be16, u8);
+ struct dst_entry *
+ cxgb_find_route6(struct cxgb4_lld_info *,
+ 		 struct net_device *(*)(struct net_device *),
+ 		 __u8 *, __u8 *, __be16, __be16, u8, __u32);
+ 
+ /* Returns whether a CPL status conveys negative advice.
++>>>>>>> 44c6d06992ac (libcxgb,iw_cxgb4,cxgbit: add cxgb_best_mtu()):drivers/net/ethernet/chelsio/libcxgb/libcxgb_cm.h
 + */
 +
 +#include "ipath_kernel.h"
 +
 +/**
 + * ipath_enable_wc - enable write combining for MMIO writes to the device
 + * @dd: infinipath device
 + *
 + * Nothing to do on PowerPC, so just return without error.
 + */
 +int ipath_enable_wc(struct ipath_devdata *dd)
 +{
 +	return 0;
 +}
 +
 +/**
 + * ipath_unordered_wc - indicate whether write combining is unordered
 + *
 + * Because our performance depends on our ability to do write
 + * combining mmio writes in the most efficient way, we need to
 + * know if we are on a processor that may reorder stores when
 + * write combining.
   */
 -static inline bool cxgb_is_neg_adv(unsigned int status)
 +int ipath_unordered_wc(void)
  {
 -	return status == CPL_ERR_RTX_NEG_ADVICE ||
 -	       status == CPL_ERR_PERSIST_NEG_ADVICE ||
 -	       status == CPL_ERR_KEEPALV_NEG_ADVICE;
 +	return 1;
  }
++<<<<<<< HEAD:drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
++=======
+ 
+ static inline void
+ cxgb_best_mtu(const unsigned short *mtus, unsigned short mtu,
+ 	      unsigned int *idx, int use_ts, int ipv6)
+ {
+ 	unsigned short hdr_size = (ipv6 ?
+ 				   sizeof(struct ipv6hdr) :
+ 				   sizeof(struct iphdr)) +
+ 				  sizeof(struct tcphdr) +
+ 				  (use_ts ?
+ 				   round_up(TCPOLEN_TIMESTAMP, 4) : 0);
+ 	unsigned short data_size = mtu - hdr_size;
+ 
+ 	cxgb4_best_aligned_mtu(mtus, hdr_size, data_size, 8, idx);
+ }
+ #endif
++>>>>>>> 44c6d06992ac (libcxgb,iw_cxgb4,cxgbit: add cxgb_best_mtu()):drivers/net/ethernet/chelsio/libcxgb/libcxgb_cm.h
diff --git a/drivers/infiniband/hw/cxgb4/cm.c b/drivers/infiniband/hw/cxgb4/cm.c
index 7fc4048a8a8f..407f17e07575 100644
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@ -744,20 +744,6 @@ static int send_abort(struct c4iw_ep *ep)
 	return c4iw_l2t_send(&ep->com.dev->rdev, req_skb, ep->l2t);
 }
 
-static void best_mtu(const unsigned short *mtus, unsigned short mtu,
-		     unsigned int *idx, int use_ts, int ipv6)
-{
-	unsigned short hdr_size = (ipv6 ?
-				   sizeof(struct ipv6hdr) :
-				   sizeof(struct iphdr)) +
-				  sizeof(struct tcphdr) +
-				  (use_ts ?
-				   round_up(TCPOLEN_TIMESTAMP, 4) : 0);
-	unsigned short data_size = mtu - hdr_size;
-
-	cxgb4_best_aligned_mtu(mtus, hdr_size, data_size, 8, idx);
-}
-
 static int send_connect(struct c4iw_ep *ep)
 {
 	struct cpl_act_open_req *req = NULL;
@@ -817,9 +803,9 @@ static int send_connect(struct c4iw_ep *ep)
 	}
 	set_wr_txq(skb, CPL_PRIORITY_SETUP, ep->ctrlq_idx);
 
-	best_mtu(ep->com.dev->rdev.lldi.mtus, ep->mtu, &mtu_idx,
-		 enable_tcp_timestamps,
-		 (AF_INET == ep->com.remote_addr.ss_family) ? 0 : 1);
+	cxgb_best_mtu(ep->com.dev->rdev.lldi.mtus, ep->mtu, &mtu_idx,
+		      enable_tcp_timestamps,
+		      (ep->com.remote_addr.ss_family == AF_INET) ? 0 : 1);
 	wscale = compute_wscale(rcv_win);
 
 	/*
@@ -1997,9 +1983,9 @@ static int send_fw_act_open_req(struct c4iw_ep *ep, unsigned int atid)
 			htons(FW_OFLD_CONNECTION_WR_CPLRXDATAACK_F);
 	req->tcb.tx_max = (__force __be32) jiffies;
 	req->tcb.rcv_adv = htons(1);
-	best_mtu(ep->com.dev->rdev.lldi.mtus, ep->mtu, &mtu_idx,
-		 enable_tcp_timestamps,
-		 (AF_INET == ep->com.remote_addr.ss_family) ? 0 : 1);
+	cxgb_best_mtu(ep->com.dev->rdev.lldi.mtus, ep->mtu, &mtu_idx,
+		      enable_tcp_timestamps,
+		      (ep->com.remote_addr.ss_family == AF_INET) ? 0 : 1);
 	wscale = compute_wscale(rcv_win);
 
 	/*
@@ -2446,9 +2432,9 @@ static int accept_cr(struct c4iw_ep *ep, struct sk_buff *skb,
 	OPCODE_TID(rpl) = cpu_to_be32(MK_OPCODE_TID(CPL_PASS_ACCEPT_RPL,
 						    ep->hwtid));
 
-	best_mtu(ep->com.dev->rdev.lldi.mtus, ep->mtu, &mtu_idx,
-		 enable_tcp_timestamps && req->tcpopt.tstamp,
-		 (AF_INET == ep->com.remote_addr.ss_family) ? 0 : 1);
+	cxgb_best_mtu(ep->com.dev->rdev.lldi.mtus, ep->mtu, &mtu_idx,
+		      enable_tcp_timestamps && req->tcpopt.tstamp,
+		      (ep->com.remote_addr.ss_family == AF_INET) ? 0 : 1);
 	wscale = compute_wscale(rcv_win);
 
 	/*
* Unmerged path drivers/infiniband/hw/ipath/ipath_wc_ppc64.c
diff --git a/drivers/target/iscsi/cxgbit/cxgbit_cm.c b/drivers/target/iscsi/cxgbit/cxgbit_cm.c
index 0ae0b131abfc..4a92060f725b 100644
--- a/drivers/target/iscsi/cxgbit/cxgbit_cm.c
+++ b/drivers/target/iscsi/cxgbit/cxgbit_cm.c
@@ -1108,20 +1108,6 @@ cxgbit_l2t_send(struct cxgbit_device *cdev, struct sk_buff *skb,
 	return ret < 0 ? ret : 0;
 }
 
-static void
-cxgbit_best_mtu(const unsigned short *mtus, unsigned short mtu,
-		unsigned int *idx, int use_ts, int ipv6)
-{
-	unsigned short hdr_size = (ipv6 ? sizeof(struct ipv6hdr) :
-				   sizeof(struct iphdr)) +
-				   sizeof(struct tcphdr) +
-				   (use_ts ? round_up(TCPOLEN_TIMESTAMP,
-				    4) : 0);
-	unsigned short data_size = mtu - hdr_size;
-
-	cxgb4_best_aligned_mtu(mtus, hdr_size, data_size, 8, idx);
-}
-
 static void cxgbit_send_rx_credits(struct cxgbit_sock *csk, struct sk_buff *skb)
 {
 	if (csk->com.state != CSK_STATE_ESTABLISHED) {
@@ -1246,9 +1232,9 @@ cxgbit_pass_accept_rpl(struct cxgbit_sock *csk, struct cpl_pass_accept_req *req)
 	INIT_TP_WR(rpl5, csk->tid);
 	OPCODE_TID(rpl5) = cpu_to_be32(MK_OPCODE_TID(CPL_PASS_ACCEPT_RPL,
 						     csk->tid));
-	cxgbit_best_mtu(csk->com.cdev->lldi.mtus, csk->mtu, &mtu_idx,
-			req->tcpopt.tstamp,
-			(csk->com.remote_addr.ss_family == AF_INET) ? 0 : 1);
+	cxgb_best_mtu(csk->com.cdev->lldi.mtus, csk->mtu, &mtu_idx,
+		      req->tcpopt.tstamp,
+		      (csk->com.remote_addr.ss_family == AF_INET) ? 0 : 1);
 	wscale = cxgbit_compute_wscale(csk->rcv_win);
 	/*
 	 * Specify the largest window that will fit in opt0. The
