NTB: Fix zero size or integer overflow in ntb_set_mw

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [ntb] Fix zero size or integer overflow in ntb_set_mw (Suravee Suthikulpanit) [1303727]
Rebuild_FUZZ: 94.95%
commit-author Allen Hubbe <Allen.Hubbe@emc.com>
commit 8c9edf63e75f036b42afb4502deb20bbfb5004b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8c9edf63.failed

A plain 32 bit integer will overflow for values over 4GiB.

Change the plain integer size to the appropriate size type in
ntb_set_mw.  Change the type of the size parameter and two local
variables used for size.

Even if there is no overflow, a size of zero is invalid here.

	Reported-by: Juyoung Jung <jjung@micron.com>
	Signed-off-by: Allen Hubbe <Allen.Hubbe@emc.com>
	Signed-off-by: Jon Mason <jdmason@kudzu.us>
(cherry picked from commit 8c9edf63e75f036b42afb4502deb20bbfb5004b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ntb/ntb_transport.c
diff --cc drivers/ntb/ntb_transport.c
index 0d5e96e60628,bc556e2d7f62..000000000000
--- a/drivers/ntb/ntb_transport.c
+++ b/drivers/ntb/ntb_transport.c
@@@ -556,27 -628,38 +556,50 @@@ static void ntb_free_mw(struct ntb_tran
  	mw->virt_addr = NULL;
  }
  
++<<<<<<< HEAD
 +static int ntb_set_mw(struct ntb_transport *nt, int num_mw, unsigned int size)
 +{
 +	struct ntb_transport_mw *mw = &nt->mw[num_mw];
 +	struct pci_dev *pdev = ntb_query_pdev(nt->ndev);
++=======
+ static int ntb_set_mw(struct ntb_transport_ctx *nt, int num_mw,
+ 		      resource_size_t size)
+ {
+ 	struct ntb_transport_mw *mw = &nt->mw_vec[num_mw];
+ 	struct pci_dev *pdev = nt->ndev->pdev;
+ 	size_t xlat_size, buff_size;
+ 	int rc;
+ 
+ 	if (!size)
+ 		return -EINVAL;
+ 
+ 	xlat_size = round_up(size, mw->xlat_align_size);
+ 	buff_size = round_up(size, mw->xlat_align);
++>>>>>>> 8c9edf63e75f (NTB: Fix zero size or integer overflow in ntb_set_mw)
  
  	/* No need to re-setup */
 -	if (mw->xlat_size == xlat_size)
 +	if (mw->size == ALIGN(size, 4096))
  		return 0;
  
 -	if (mw->buff_size)
 +	if (mw->size != 0)
  		ntb_free_mw(nt, num_mw);
  
 -	/* Alloc memory for receiving data.  Must be aligned */
 -	mw->xlat_size = xlat_size;
 -	mw->buff_size = buff_size;
 +	/* Alloc memory for receiving data.  Must be 4k aligned */
 +	mw->size = ALIGN(size, 4096);
  
 -	mw->virt_addr = dma_alloc_coherent(&pdev->dev, buff_size,
 -					   &mw->dma_addr, GFP_KERNEL);
 +	mw->virt_addr = dma_alloc_coherent(&pdev->dev, mw->size, &mw->dma_addr,
 +					   GFP_KERNEL);
  	if (!mw->virt_addr) {
++<<<<<<< HEAD
 +		mw->size = 0;
 +		dev_err(&pdev->dev, "Unable to allocate MW buffer of size %d\n",
 +		       (int) mw->size);
++=======
+ 		mw->xlat_size = 0;
+ 		mw->buff_size = 0;
+ 		dev_err(&pdev->dev, "Unable to alloc MW buff of size %zu\n",
+ 			buff_size);
++>>>>>>> 8c9edf63e75f (NTB: Fix zero size or integer overflow in ntb_set_mw)
  		return -ENOMEM;
  	}
  
* Unmerged path drivers/ntb/ntb_transport.c
