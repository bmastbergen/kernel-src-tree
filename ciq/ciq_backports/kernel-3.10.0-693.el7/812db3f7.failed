tools/power turbostat: Add --show and --hide parameters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [tools] power turbostat: Add --show and --hide parameters (Prarit Bhargava) [1447265]
Rebuild_FUZZ: 94.23%
commit-author Len Brown <len.brown@intel.com>
commit 812db3f77b9a3f6ed59baf7a0d5c3fd8ec8ef86a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/812db3f7.failed

Add the "--show" and "--hide" cmdline parameters.

By default, turbostat shows all columns.

turbostat --hide counter_list
will continue showing all columns, except for those listed.

turbostat --show counter_list
will show _only_ the listed columns

These features work for built-in counters, and have no effect
on columns added with the --add parameter.

	Signed-off-by: Len Brown <len.brown@intel.com>
(cherry picked from commit 812db3f77b9a3f6ed59baf7a0d5c3fd8ec8ef86a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/power/x86/turbostat/turbostat.c
diff --cc tools/power/x86/turbostat/turbostat.c
index 92e6f5e6c99d,fff280b50af0..000000000000
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@@ -49,9 -52,6 +49,12 @@@ unsigned int debug
  unsigned int rapl_joules;
  unsigned int summary_only;
  unsigned int dump_only;
++<<<<<<< HEAD
 +unsigned int skip_c0;
 +unsigned int skip_c1;
 +unsigned int do_nhm_cstates;
++=======
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  unsigned int do_snb_cstates;
  unsigned int do_knl_cstates;
  unsigned int do_pc2;
@@@ -68,12 -70,7 +71,15 @@@ unsigned int units = 1000000;	/* MHz et
  unsigned int genuine_intel;
  unsigned int has_invariant_tsc;
  unsigned int do_nhm_platform_info;
 +unsigned int extra_msr_offset32;
 +unsigned int extra_msr_offset64;
 +unsigned int extra_delta_offset32;
 +unsigned int extra_delta_offset64;
  unsigned int aperf_mperf_multiplier = 1;
++<<<<<<< HEAD
 +int do_smi;
++=======
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  double bclk;
  double base_hz;
  unsigned int has_base_hz;
@@@ -87,6 -81,8 +90,11 @@@ char *output_buffer, *outp
  unsigned int do_rapl;
  unsigned int do_dts;
  unsigned int do_ptm;
++<<<<<<< HEAD
++=======
+ unsigned long long  gfx_cur_rc6_ms;
+ unsigned int gfx_cur_mhz;
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  unsigned int tcc_activation_temp;
  unsigned int tcc_activation_temp_override;
  double rapl_power_units, rapl_time_units;
@@@ -198,6 -207,31 +206,34 @@@ struct pkg_data 
  	(core_base + (pkg_no) * topo.num_cores_per_pkg + (core_no))
  #define GET_PKG(pkg_base, pkg_no) (pkg_base + pkg_no)
  
++<<<<<<< HEAD
++=======
+ enum counter_scope {SCOPE_CPU, SCOPE_CORE, SCOPE_PACKAGE};
+ enum counter_type {COUNTER_CYCLES, COUNTER_SECONDS};
+ enum counter_format {FORMAT_RAW, FORMAT_DELTA, FORMAT_PERCENT};
+ 
+ struct msr_counter {
+ 	unsigned int msr_num;
+ 	char name[NAME_BYTES];
+ 	unsigned int width;
+ 	enum counter_type type;
+ 	enum counter_format format;
+ 	struct msr_counter *next;
+ 	unsigned int flags;
+ #define	FLAGS_HIDE	(1 << 0)
+ #define	FLAGS_SHOW	(1 << 1)
+ };
+ 
+ struct sys_counters {
+ 	unsigned int added_thread_counters;
+ 	unsigned int added_core_counters;
+ 	unsigned int added_package_counters;
+ 	struct msr_counter *tp;
+ 	struct msr_counter *cp;
+ 	struct msr_counter *pp;
+ } sys;
+ 
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  struct system_summary {
  	struct thread_data threads;
  	struct core_data cores;
@@@ -288,59 -336,202 +324,250 @@@ int get_msr(int cpu, off_t offset, unsi
  }
  
  /*
++<<<<<<< HEAD
 + * Example Format w/ field column widths:
 + *
 + *  Package    Core     CPU Avg_MHz Bzy_MHz TSC_MHz     SMI   %Busy CPU_%c1 CPU_%c3 CPU_%c6 CPU_%c7 CoreTmp  PkgTmp Pkg%pc2 Pkg%pc3 Pkg%pc6 Pkg%pc7 PkgWatt CorWatt GFXWatt
 + * 123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678
++=======
+  * Each string in this array is compared in --show and --hide cmdline.
+  * Thus, strings that are proper sub-sets must follow their more specific peers.
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
+  */
+ struct msr_counter bic[] = {
+ 	{ 0x0, "Package" },
+ 	{ 0x0, "Avg_MHz" },
+ 	{ 0x0, "Bzy_MHz" },
+ 	{ 0x0, "TSC_MHz" },
+ 	{ 0x0, "IRQ" },
+ 	{ 0x0, "SMI", 32, 0, FORMAT_DELTA, NULL},
+ 	{ 0x0, "Busy%" },
+ 	{ 0x0, "CPU%c1" },
+ 	{ 0x0, "CPU%c3" },
+ 	{ 0x0, "CPU%c6" },
+ 	{ 0x0, "CPU%c7" },
+ 	{ 0x0, "ThreadC" },
+ 	{ 0x0, "CoreTmp" },
+ 	{ 0x0, "CoreCnt" },
+ 	{ 0x0, "PkgTmp" },
+ 	{ 0x0, "GFX%rc6" },
+ 	{ 0x0, "GFXMHz" },
+ 	{ 0x0, "Pkg%pc2" },
+ 	{ 0x0, "Pkg%pc3" },
+ 	{ 0x0, "Pkg%pc6" },
+ 	{ 0x0, "Pkg%pc7" },
+ 	{ 0x0, "PkgWatt" },
+ 	{ 0x0, "CorWatt" },
+ 	{ 0x0, "GFXWatt" },
+ 	{ 0x0, "PkgCnt" },
+ 	{ 0x0, "RAMWatt" },
+ 	{ 0x0, "PKG_%" },
+ 	{ 0x0, "RAM_%" },
+ 	{ 0x0, "Pkg_J" },
+ 	{ 0x0, "Cor_J" },
+ 	{ 0x0, "GFX_J" },
+ 	{ 0x0, "RAM_J" },
+ 	{ 0x0, "Core" },
+ 	{ 0x0, "CPU" },
+ };
+ 
+ #define MAX_BIC (sizeof(bic) / sizeof(struct msr_counter))
+ #define	BIC_Package	(1ULL << 0)
+ #define	BIC_Avg_MHz	(1ULL << 1)
+ #define	BIC_Bzy_MHz	(1ULL << 2)
+ #define	BIC_TSC_MHz	(1ULL << 3)
+ #define	BIC_IRQ		(1ULL << 4)
+ #define	BIC_SMI		(1ULL << 5)
+ #define	BIC_Busy	(1ULL << 6)
+ #define	BIC_CPU_c1	(1ULL << 7)
+ #define	BIC_CPU_c3	(1ULL << 8)
+ #define	BIC_CPU_c6	(1ULL << 9)
+ #define	BIC_CPU_c7	(1ULL << 10)
+ #define	BIC_ThreadC	(1ULL << 11)
+ #define	BIC_CoreTmp	(1ULL << 12)
+ #define	BIC_CoreCnt	(1ULL << 13)
+ #define	BIC_PkgTmp	(1ULL << 14)
+ #define	BIC_GFX_rc6	(1ULL << 15)
+ #define	BIC_GFXMHz	(1ULL << 16)
+ #define	BIC_Pkgpc2	(1ULL << 17)
+ #define	BIC_Pkgpc3	(1ULL << 18)
+ #define	BIC_Pkgpc6	(1ULL << 19)
+ #define	BIC_Pkgpc7	(1ULL << 20)
+ #define	BIC_PkgWatt	(1ULL << 21)
+ #define	BIC_CorWatt	(1ULL << 22)
+ #define	BIC_GFXWatt	(1ULL << 23)
+ #define	BIC_PkgCnt	(1ULL << 24)
+ #define	BIC_RAMWatt	(1ULL << 27)
+ #define	BIC_PKG__	(1ULL << 28)
+ #define	BIC_RAM__	(1ULL << 29)
+ #define	BIC_Pkg_J	(1ULL << 30)
+ #define	BIC_Cor_J	(1ULL << 31)
+ #define	BIC_GFX_J	(1ULL << 30)
+ #define	BIC_RAM_J	(1ULL << 31)
+ #define	BIC_Core	(1ULL << 32)
+ #define	BIC_CPU		(1ULL << 33)
+ 
+ unsigned long long bic_enabled = 0xFFFFFFFFFFFFFFFFULL;
+ unsigned long long bic_present;
+ 
+ #define DO_BIC(COUNTER_NAME) (bic_enabled & bic_present & COUNTER_NAME)
+ #define BIC_PRESENT(COUNTER_BIT) (bic_present |= COUNTER_BIT)
+ 
+ /*
+  * bic_lookup
+  * for all the strings in comma separate name_list,
+  * set the approprate bit in return value.
   */
+ unsigned long long bic_lookup(char *name_list)
+ {
+ 	int i;
+ 	unsigned long long retval = 0;
+ 
+ 	while (name_list) {
+ 		char *comma;
+ 
+ 		comma = strchr(name_list, ',');
+ 
+ 		if (comma)
+ 			*comma = '\0';
+ 
+ 		for (i = 0; i < MAX_BIC; ++i) {
+ 			if (!strcmp(name_list, bic[i].name)) {
+ 				retval |= (1ULL << i);
+ 				break;
+ 			}
+ 		}
+ 		if (i == MAX_BIC) {
+ 			fprintf(stderr, "Invalid counter name: %s\n", name_list);
+ 			exit(-1);
+ 		}
+ 
+ 		name_list = comma;
+ 		if (name_list)
+ 			name_list++;
+ 
+ 	}
+ 	return retval;
+ }
  
  void print_header(void)
  {
++<<<<<<< HEAD
 +	if (show_pkg)
 +		outp += sprintf(outp, " Package");
 +	if (show_core)
 +		outp += sprintf(outp, "    Core");
 +	if (show_cpu)
 +		outp += sprintf(outp, "     CPU");
 +	if (has_aperf)
 +		outp += sprintf(outp, " Avg_MHz");
 +	if (has_aperf)
 +		outp += sprintf(outp, "   %%Busy");
 +	if (has_aperf)
 +		outp += sprintf(outp, " Bzy_MHz");
 +	outp += sprintf(outp, " TSC_MHz");
++=======
+ 	struct msr_counter *mp;
+ 
+ 	if (DO_BIC(BIC_Package))
+ 		outp += sprintf(outp, "\tPackage");
+ 	if (DO_BIC(BIC_Core))
+ 		outp += sprintf(outp, "\tCore");
+ 	if (DO_BIC(BIC_CPU))
+ 		outp += sprintf(outp, "\tCPU");
+ 	if (DO_BIC(BIC_Avg_MHz))
+ 		outp += sprintf(outp, "\tAvg_MHz");
+ 	if (DO_BIC(BIC_Busy))
+ 		outp += sprintf(outp, "\tBusy%%");
+ 	if (DO_BIC(BIC_Bzy_MHz))
+ 		outp += sprintf(outp, "\tBzy_MHz");
+ 	if (DO_BIC(BIC_TSC_MHz))
+ 		outp += sprintf(outp, "\tTSC_MHz");
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
 +
 +	if (extra_delta_offset32)
 +		outp += sprintf(outp, "  count 0x%03X", extra_delta_offset32);
 +	if (extra_delta_offset64)
 +		outp += sprintf(outp, "  COUNT 0x%03X", extra_delta_offset64);
 +	if (extra_msr_offset32)
 +		outp += sprintf(outp, "   MSR 0x%03X", extra_msr_offset32);
 +	if (extra_msr_offset64)
 +		outp += sprintf(outp, "           MSR 0x%03X", extra_msr_offset64);
 +
++<<<<<<< HEAD
 +	if (do_smi)
 +		outp += sprintf(outp, "     SMI");
 +
 +	if (do_nhm_cstates)
 +		outp += sprintf(outp, "  CPU%%c1");
 +	if (do_nhm_cstates && !do_slm_cstates && !do_knl_cstates)
 +		outp += sprintf(outp, "  CPU%%c3");
 +	if (do_nhm_cstates)
 +		outp += sprintf(outp, "  CPU%%c6");
 +	if (do_snb_cstates)
 +		outp += sprintf(outp, "  CPU%%c7");
  
 -	if (!debug)
 -		goto done;
 -
 +	if (do_dts)
 +		outp += sprintf(outp, " CoreTmp");
 +	if (do_ptm)
 +		outp += sprintf(outp, "  PkgTmp");
++=======
+ 	if (DO_BIC(BIC_IRQ))
+ 		outp += sprintf(outp, "\tIRQ");
+ 	if (DO_BIC(BIC_SMI))
+ 		outp += sprintf(outp, "\tSMI");
+ 
+ 	if (DO_BIC(BIC_CPU_c1))
+ 		outp += sprintf(outp, "\tCPU%%c1");
+ 
+ 	for (mp = sys.tp; mp; mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 64)
+ 				outp += sprintf(outp, "\t%18.18s", mp->name);
+ 			else
+ 				outp += sprintf(outp, "\t%10.10s", mp->name);
+ 		} else {
+ 			outp += sprintf(outp, "\t%-7.7s", mp->name);
+ 		}
+ 	}
+ 
+ 	if (DO_BIC(BIC_CPU_c3) && !do_slm_cstates && !do_knl_cstates)
+ 		outp += sprintf(outp, "\tCPU%%c3");
+ 	if (DO_BIC(BIC_CPU_c6))
+ 		outp += sprintf(outp, "\tCPU%%c6");
+ 	if (DO_BIC(BIC_CPU_c7))
+ 		outp += sprintf(outp, "\tCPU%%c7");
+ 
+ 
+ 	if (DO_BIC(BIC_CoreTmp))
+ 		outp += sprintf(outp, "\tCoreTmp");
+ 
+ 	for (mp = sys.cp; mp; mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 64)
+ 				outp += sprintf(outp, "\t%18.18s", mp->name);
+ 			else
+ 				outp += sprintf(outp, "\t%10.10s", mp->name);
+ 		} else {
+ 			outp += sprintf(outp, "\t%-7.7s", mp->name);
+ 		}
+ 	}
+ 
+ 	if (DO_BIC(BIC_PkgTmp))
+ 		outp += sprintf(outp, "\tPkgTmp");
+ 
+ 	if (DO_BIC(BIC_GFX_rc6))
+ 		outp += sprintf(outp, "\tGFX%%rc6");
+ 
+ 	if (DO_BIC(BIC_GFXMHz))
+ 		outp += sprintf(outp, "\tGFXMHz");
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  
  	if (do_skl_residency) {
 -		outp += sprintf(outp, "\tTotl%%C0");
 -		outp += sprintf(outp, "\tAny%%C0");
 -		outp += sprintf(outp, "\tGFX%%C0");
 -		outp += sprintf(outp, "\tCPUGFX%%");
 +		outp += sprintf(outp, " Totl%%C0");
 +		outp += sprintf(outp, "  Any%%C0");
 +		outp += sprintf(outp, "  GFX%%C0");
 +		outp += sprintf(outp, " CPUGFX%%");
  	}
  
  	if (do_pc2)
@@@ -358,32 -549,44 +585,60 @@@
  	}
  
  	if (do_rapl && !rapl_joules) {
++<<<<<<< HEAD
 +		if (do_rapl & RAPL_PKG)
 +			outp += sprintf(outp, " PkgWatt");
 +		if (do_rapl & RAPL_CORES_ENERGY_STATUS)
 +			outp += sprintf(outp, " CorWatt");
 +		if (do_rapl & RAPL_GFX)
 +			outp += sprintf(outp, " GFXWatt");
 +		if (do_rapl & RAPL_DRAM)
 +			outp += sprintf(outp, " RAMWatt");
 +		if (do_rapl & RAPL_PKG_PERF_STATUS)
 +			outp += sprintf(outp, "   PKG_%%");
 +		if (do_rapl & RAPL_DRAM_PERF_STATUS)
 +			outp += sprintf(outp, "   RAM_%%");
 +	} else if (do_rapl && rapl_joules) {
 +		if (do_rapl & RAPL_PKG)
 +			outp += sprintf(outp, "   Pkg_J");
 +		if (do_rapl & RAPL_CORES_ENERGY_STATUS)
 +			outp += sprintf(outp, "   Cor_J");
 +		if (do_rapl & RAPL_GFX)
 +			outp += sprintf(outp, "   GFX_J");
 +		if (do_rapl & RAPL_DRAM)
 +			outp += sprintf(outp, "   RAM_J");
 +		if (do_rapl & RAPL_PKG_PERF_STATUS)
 +			outp += sprintf(outp, "   PKG_%%");
 +		if (do_rapl & RAPL_DRAM_PERF_STATUS)
 +			outp += sprintf(outp, "   RAM_%%");
++=======
+ 		if (DO_BIC(BIC_PkgWatt))
+ 			outp += sprintf(outp, "\tPkgWatt");
+ 		if (DO_BIC(BIC_CorWatt))
+ 			outp += sprintf(outp, "\tCorWatt");
+ 		if (DO_BIC(BIC_GFXWatt))
+ 			outp += sprintf(outp, "\tGFXWatt");
+ 		if (DO_BIC(BIC_RAMWatt))
+ 			outp += sprintf(outp, "\tRAMWatt");
+ 		if (DO_BIC(BIC_PKG__))
+ 			outp += sprintf(outp, "\tPKG_%%");
+ 		if (DO_BIC(BIC_RAM__))
+ 			outp += sprintf(outp, "\tRAM_%%");
+ 	} else if (do_rapl && rapl_joules) {
+ 		if (DO_BIC(BIC_Pkg_J))
+ 			outp += sprintf(outp, "\tPkg_J");
+ 		if (DO_BIC(BIC_Cor_J))
+ 			outp += sprintf(outp, "\tCor_J");
+ 		if (DO_BIC(BIC_GFX_J))
+ 			outp += sprintf(outp, "\tGFX_J");
+ 		if (DO_BIC(BIC_RAM_J))
+ 			outp += sprintf(outp, "\tRAM_J");
+ 		if (DO_BIC(BIC_PKG__))
+ 			outp += sprintf(outp, "\tPKG_%%");
+ 		if (DO_BIC(BIC_RAM__))
+ 			outp += sprintf(outp, "\tRAM_%%");
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  	}
 -	for (mp = sys.pp; mp; mp = mp->next) {
 -		if (mp->format == FORMAT_RAW) {
 -			if (mp->width == 64)
 -				outp += sprintf(outp, "\t%18.18s", mp->name);
 -			else
 -				outp += sprintf(outp, "\t%10.10s", mp->name);
 -		} else {
 -			outp += sprintf(outp, "\t%-7.7s", mp->name);
 -		}
 -	}
 -
 -done:
  	outp += sprintf(outp, "\n");
  }
  
@@@ -399,16 -605,16 +654,23 @@@ int dump_counters(struct thread_data *t
  		outp += sprintf(outp, "aperf: %016llX\n", t->aperf);
  		outp += sprintf(outp, "mperf: %016llX\n", t->mperf);
  		outp += sprintf(outp, "c1: %016llX\n", t->c1);
++<<<<<<< HEAD
 +		outp += sprintf(outp, "msr0x%x: %08llX\n",
 +			extra_delta_offset32, t->extra_delta32);
 +		outp += sprintf(outp, "msr0x%x: %016llX\n",
 +			extra_delta_offset64, t->extra_delta64);
 +		outp += sprintf(outp, "msr0x%x: %08llX\n",
 +			extra_msr_offset32, t->extra_msr32);
 +		outp += sprintf(outp, "msr0x%x: %016llX\n",
 +			extra_msr_offset64, t->extra_msr64);
 +		if (do_smi)
++=======
+ 
+ 		if (DO_BIC(BIC_IRQ))
+ 			outp += sprintf(outp, "IRQ: %08X\n", t->irq_count);
+ 		if (DO_BIC(BIC_SMI))
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  			outp += sprintf(outp, "SMI: %08X\n", t->smi_count);
 -
 -		for (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {
 -			outp += sprintf(outp, "tADDED [%d] msr0x%x: %08llX\n",
 -				i, mp->msr_num, t->counter[i]);
 -		}
  	}
  
  	if (c) {
@@@ -474,101 -692,124 +736,198 @@@ int format_counters(struct thread_data 
  
  	/* topo columns, print blanks on 1st (average) line */
  	if (t == &average.threads) {
++<<<<<<< HEAD
 +		if (show_pkg)
 +			outp += sprintf(outp, "       -");
 +		if (show_core)
 +			outp += sprintf(outp, "       -");
 +		if (show_cpu)
 +			outp += sprintf(outp, "       -");
++=======
+ 		if (DO_BIC(BIC_Package))
+ 			outp += sprintf(outp, "\t-");
+ 		if (DO_BIC(BIC_Core))
+ 			outp += sprintf(outp, "\t-");
+ 		if (DO_BIC(BIC_CPU))
+ 			outp += sprintf(outp, "\t-");
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  	} else {
- 		if (show_pkg) {
+ 		if (DO_BIC(BIC_Package)) {
  			if (p)
 -				outp += sprintf(outp, "\t%d", p->package_id);
 +				outp += sprintf(outp, "%8d", p->package_id);
  			else
 -				outp += sprintf(outp, "\t-");
 +				outp += sprintf(outp, "       -");
  		}
- 		if (show_core) {
+ 		if (DO_BIC(BIC_Core)) {
  			if (c)
 -				outp += sprintf(outp, "\t%d", c->core_id);
 +				outp += sprintf(outp, "%8d", c->core_id);
  			else
 -				outp += sprintf(outp, "\t-");
 +				outp += sprintf(outp, "       -");
  		}
++<<<<<<< HEAD
 +		if (show_cpu)
 +			outp += sprintf(outp, "%8d", t->cpu_id);
 +	}
 +
 +	/* Avg_MHz */
 +	if (has_aperf)
 +		outp += sprintf(outp, "%8.0f",
 +			1.0 / units * t->aperf / interval_float);
 +
 +	/* %Busy */
 +	if (has_aperf) {
 +		if (!skip_c0)
 +			outp += sprintf(outp, "%8.2f", 100.0 * t->mperf/t->tsc/tsc_tweak);
 +		else
 +			outp += sprintf(outp, "********");
 +	}
++=======
+ 		if (DO_BIC(BIC_CPU))
+ 			outp += sprintf(outp, "\t%d", t->cpu_id);
+ 	}
  
- 	/* Bzy_MHz */
- 	if (has_aperf) {
+ 	if (DO_BIC(BIC_Avg_MHz))
+ 		outp += sprintf(outp, "\t%.0f",
+ 			1.0 / units * t->aperf / interval_float);
+ 
+ 	if (DO_BIC(BIC_Busy))
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * t->mperf/t->tsc/tsc_tweak);
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
+ 
+ 	if (DO_BIC(BIC_Bzy_MHz)) {
  		if (has_base_hz)
 -			outp += sprintf(outp, "\t%.0f", base_hz / units * t->aperf / t->mperf);
 +			outp += sprintf(outp, "%8.0f", base_hz / units * t->aperf / t->mperf);
  		else
 -			outp += sprintf(outp, "\t%.0f",
 +			outp += sprintf(outp, "%8.0f",
  				1.0 * t->tsc / units * t->aperf / t->mperf / interval_float);
  	}
  
++<<<<<<< HEAD
 +	/* TSC_MHz */
 +	outp += sprintf(outp, "%8.0f", 1.0 * t->tsc/units/interval_float);
++=======
+ 	if (DO_BIC(BIC_TSC_MHz))
+ 		outp += sprintf(outp, "\t%.0f", 1.0 * t->tsc/units/interval_float);
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  
 -	if (!debug)
 -		goto done;
 +	/* delta */
 +	if (extra_delta_offset32)
 +		outp += sprintf(outp, "  %11llu", t->extra_delta32);
 +
++<<<<<<< HEAD
 +	/* DELTA */
 +	if (extra_delta_offset64)
 +		outp += sprintf(outp, "  %11llu", t->extra_delta64);
 +	/* msr */
 +	if (extra_msr_offset32)
 +		outp += sprintf(outp, "  0x%08llx", t->extra_msr32);
 +
 +	/* MSR */
 +	if (extra_msr_offset64)
 +		outp += sprintf(outp, "  0x%016llx", t->extra_msr64);
  
 +	/* SMI */
 +	if (do_smi)
 +		outp += sprintf(outp, "%8d", t->smi_count);
 +
 +	if (do_nhm_cstates) {
 +		if (!skip_c1)
 +			outp += sprintf(outp, "%8.2f", 100.0 * t->c1/t->tsc);
 +		else
 +			outp += sprintf(outp, "********");
++=======
+ 	/* IRQ */
+ 	if (DO_BIC(BIC_IRQ))
+ 		outp += sprintf(outp, "\t%d", t->irq_count);
+ 
+ 	/* SMI */
+ 	if (DO_BIC(BIC_SMI))
+ 		outp += sprintf(outp, "\t%d", t->smi_count);
+ 
+ 	/* C1 */
+ 	if (DO_BIC(BIC_CPU_c1))
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * t->c1/t->tsc);
+ 
+ 	/* Added counters */
+ 	for (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 32)
+ 				outp += sprintf(outp, "\t0x%08lx", (unsigned long) t->counter[i]);
+ 			else
+ 				outp += sprintf(outp, "\t0x%016llx", t->counter[i]);
+ 		} else if (mp->format == FORMAT_DELTA) {
+ 			outp += sprintf(outp, "\t%lld", t->counter[i]);
+ 		} else if (mp->format == FORMAT_PERCENT) {
+ 			outp += sprintf(outp, "\t%.2f", 100.0 * t->counter[i]/t->tsc);
+ 		}
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  	}
  
  	/* print per-core data only for 1st thread in core */
  	if (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))
  		goto done;
  
++<<<<<<< HEAD
 +	if (do_nhm_cstates && !do_slm_cstates && !do_knl_cstates)
 +		outp += sprintf(outp, "%8.2f", 100.0 * c->c3/t->tsc);
 +	if (do_nhm_cstates)
 +		outp += sprintf(outp, "%8.2f", 100.0 * c->c6/t->tsc);
 +	if (do_snb_cstates)
 +		outp += sprintf(outp, "%8.2f", 100.0 * c->c7/t->tsc);
 +
 +	if (do_dts)
 +		outp += sprintf(outp, "%8d", c->core_temp_c);
++=======
+ 	if (DO_BIC(BIC_CPU_c3) && !do_slm_cstates && !do_knl_cstates)
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * c->c3/t->tsc);
+ 	if (DO_BIC(BIC_CPU_c6))
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * c->c6/t->tsc);
+ 	if (DO_BIC(BIC_CPU_c7))
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * c->c7/t->tsc);
+ 
+ 	if (DO_BIC(BIC_CoreTmp))
+ 		outp += sprintf(outp, "\t%d", c->core_temp_c);
+ 
+ 	for (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 32)
+ 				outp += sprintf(outp, "\t0x%08lx", (unsigned long) c->counter[i]);
+ 			else
+ 				outp += sprintf(outp, "\t0x%016llx", c->counter[i]);
+ 		} else if (mp->format == FORMAT_DELTA) {
+ 			outp += sprintf(outp, "\t%lld", c->counter[i]);
+ 		} else if (mp->format == FORMAT_PERCENT) {
+ 			outp += sprintf(outp, "\t%.2f", 100.0 * c->counter[i]/t->tsc);
+ 		}
+ 	}
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  
  	/* print per-package data only for 1st core in package */
  	if (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))
  		goto done;
  
  	/* PkgTmp */
++<<<<<<< HEAD
 +	if (do_ptm)
 +		outp += sprintf(outp, "%8d", p->pkg_temp_c);
++=======
+ 	if (DO_BIC(BIC_PkgTmp))
+ 		outp += sprintf(outp, "\t%d", p->pkg_temp_c);
+ 
+ 	/* GFXrc6 */
+ 	if (DO_BIC(BIC_GFX_rc6)) {
+ 		if (p->gfx_rc6_ms == -1) {	/* detect GFX counter reset */
+ 			outp += sprintf(outp, "\t**.**");
+ 		} else {
+ 			outp += sprintf(outp, "\t%.2f",
+ 				p->gfx_rc6_ms / 10.0 / interval_float);
+ 		}
+ 	}
+ 
+ 	/* GFXMHz */
+ 	if (DO_BIC(BIC_GFXMHz))
+ 		outp += sprintf(outp, "\t%d", p->gfx_mhz);
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  
  	/* Totl%C0, Any%C0 GFX%C0 CPUGFX% */
  	if (do_skl_residency) {
@@@ -601,37 -842,40 +960,74 @@@
  	else
  		fmt8 = "%6.0f**";
  
++<<<<<<< HEAD
 +	if (do_rapl && !rapl_joules) {
 +		if (do_rapl & RAPL_PKG)
 +			outp += sprintf(outp, fmt8, p->energy_pkg * rapl_energy_units / interval_float);
 +		if (do_rapl & RAPL_CORES_ENERGY_STATUS)
 +			outp += sprintf(outp, fmt8, p->energy_cores * rapl_energy_units / interval_float);
 +		if (do_rapl & RAPL_GFX)
 +			outp += sprintf(outp, fmt8, p->energy_gfx * rapl_energy_units / interval_float);
 +		if (do_rapl & RAPL_DRAM)
 +			outp += sprintf(outp, fmt8, p->energy_dram * rapl_dram_energy_units / interval_float);
 +		if (do_rapl & RAPL_PKG_PERF_STATUS)
 +			outp += sprintf(outp, fmt8, 100.0 * p->rapl_pkg_perf_status * rapl_time_units / interval_float);
 +		if (do_rapl & RAPL_DRAM_PERF_STATUS)
 +			outp += sprintf(outp, fmt8, 100.0 * p->rapl_dram_perf_status * rapl_time_units / interval_float);
 +	} else if (do_rapl && rapl_joules) {
 +		if (do_rapl & RAPL_PKG)
 +			outp += sprintf(outp, fmt8,
 +					p->energy_pkg * rapl_energy_units);
 +		if (do_rapl & RAPL_CORES)
 +			outp += sprintf(outp, fmt8,
 +					p->energy_cores * rapl_energy_units);
 +		if (do_rapl & RAPL_GFX)
 +			outp += sprintf(outp, fmt8,
 +					p->energy_gfx * rapl_energy_units);
 +		if (do_rapl & RAPL_DRAM)
 +			outp += sprintf(outp, fmt8,
 +					p->energy_dram * rapl_dram_energy_units);
 +		if (do_rapl & RAPL_PKG_PERF_STATUS)
 +			outp += sprintf(outp, fmt8, 100.0 * p->rapl_pkg_perf_status * rapl_time_units / interval_float);
 +		if (do_rapl & RAPL_DRAM_PERF_STATUS)
 +			outp += sprintf(outp, fmt8, 100.0 * p->rapl_dram_perf_status * rapl_time_units / interval_float);
 +	}
++=======
+ 	if (DO_BIC(BIC_PkgWatt))
+ 		outp += sprintf(outp, fmt8, p->energy_pkg * rapl_energy_units / interval_float);
+ 	if (DO_BIC(BIC_CorWatt))
+ 		outp += sprintf(outp, fmt8, p->energy_cores * rapl_energy_units / interval_float);
+ 	if (DO_BIC(BIC_GFXWatt))
+ 		outp += sprintf(outp, fmt8, p->energy_gfx * rapl_energy_units / interval_float);
+ 	if (DO_BIC(BIC_RAMWatt))
+ 		outp += sprintf(outp, fmt8, p->energy_dram * rapl_dram_energy_units / interval_float);
+ 	if (DO_BIC(BIC_Pkg_J))
+ 		outp += sprintf(outp, fmt8, p->energy_pkg * rapl_energy_units);
+ 	if (DO_BIC(BIC_Cor_J))
+ 		outp += sprintf(outp, fmt8, p->energy_cores * rapl_energy_units);
+ 	if (DO_BIC(BIC_GFX_J))
+ 		outp += sprintf(outp, fmt8, p->energy_gfx * rapl_energy_units);
+ 	if (DO_BIC(BIC_RAM_J))
+ 		outp += sprintf(outp, fmt8, p->energy_dram * rapl_dram_energy_units);
+ 	if (DO_BIC(BIC_PKG__))
+ 		outp += sprintf(outp, fmt8, 100.0 * p->rapl_pkg_perf_status * rapl_time_units / interval_float);
+ 	if (DO_BIC(BIC_RAM__))
+ 		outp += sprintf(outp, fmt8, 100.0 * p->rapl_dram_perf_status * rapl_time_units / interval_float);
+ 
+ 	for (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 32)
+ 				outp += sprintf(outp, "\t0x%08lx", (unsigned long) p->counter[i]);
+ 			else
+ 				outp += sprintf(outp, "\t0x%016llx", p->counter[i]);
+ 		} else if (mp->format == FORMAT_DELTA) {
+ 			outp += sprintf(outp, "\t%lld", p->counter[i]);
+ 		} else if (mp->format == FORMAT_PERCENT) {
+ 			outp += sprintf(outp, "\t%.2f", 100.0 * p->counter[i]/t->tsc);
+ 		}
+ 	}
+ 
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  done:
  	outp += sprintf(outp, "\n");
  
@@@ -779,19 -1052,19 +1175,24 @@@ delta_thread(struct thread_data *new, s
  		old->mperf = 1;	/* divide by 0 protection */
  	}
  
++<<<<<<< HEAD
 +	old->extra_delta32 = new->extra_delta32 - old->extra_delta32;
 +	old->extra_delta32 &= 0xFFFFFFFF;
 +
 +	old->extra_delta64 = new->extra_delta64 - old->extra_delta64;
 +
 +	/*
 +	 * Extra MSR is just a snapshot, simply copy latest w/o subtracting
 +	 */
 +	old->extra_msr32 = new->extra_msr32;
 +	old->extra_msr64 = new->extra_msr64;
++=======
+ 	if (DO_BIC(BIC_IRQ))
+ 		old->irq_count = new->irq_count - old->irq_count;
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  
- 	if (do_smi)
+ 	if (DO_BIC(BIC_SMI))
  		old->smi_count = new->smi_count - old->smi_count;
 -
 -	for (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {
 -		if (mp->format == FORMAT_RAW)
 -			old->counter[i] = new->counter[i];
 -		else
 -			old->counter[i] = new->counter[i] - old->counter[i];
 -	}
 -	return 0;
  }
  
  int delta_cpu(struct thread_data *t, struct core_data *c,
@@@ -979,18 -1309,68 +1380,45 @@@ int get_counters(struct thread_data *t
  		return -1;
  	}
  
 -retry:
  	t->tsc = rdtsc();	/* we are running on local CPU of interest */
  
++<<<<<<< HEAD
 +	if (has_aperf) {
++=======
+ 	if (DO_BIC(BIC_Avg_MHz) || DO_BIC(BIC_Busy) || DO_BIC(BIC_Bzy_MHz)) {
+ 		unsigned long long tsc_before, tsc_between, tsc_after, aperf_time, mperf_time;
+ 
+ 		/*
+ 		 * The TSC, APERF and MPERF must be read together for
+ 		 * APERF/MPERF and MPERF/TSC to give accurate results.
+ 		 *
+ 		 * Unfortunately, APERF and MPERF are read by
+ 		 * individual system call, so delays may occur
+ 		 * between them.  If the time to read them
+ 		 * varies by a large amount, we re-read them.
+ 		 */
+ 
+ 		/*
+ 		 * This initial dummy APERF read has been seen to
+ 		 * reduce jitter in the subsequent reads.
+ 		 */
+ 
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  		if (get_msr(cpu, MSR_IA32_APERF, &t->aperf))
  			return -3;
 -
 -		t->tsc = rdtsc();	/* re-read close to APERF */
 -
 -		tsc_before = t->tsc;
 -
 -		if (get_msr(cpu, MSR_IA32_APERF, &t->aperf))
 -			return -3;
 -
 -		tsc_between = rdtsc();
 -
  		if (get_msr(cpu, MSR_IA32_MPERF, &t->mperf))
  			return -4;
 -
 -		tsc_after = rdtsc();
 -
 -		aperf_time = tsc_between - tsc_before;
 -		mperf_time = tsc_after - tsc_between;
 -
 -		/*
 -		 * If the system call latency to read APERF and MPERF
 -		 * differ by more than 2x, then try again.
 -		 */
 -		if ((aperf_time > (2 * mperf_time)) || (mperf_time > (2 * aperf_time))) {
 -			aperf_mperf_retry_count++;
 -			if (aperf_mperf_retry_count < 5)
 -				goto retry;
 -			else
 -				warnx("cpu%d jitter %lld %lld",
 -					cpu, aperf_time, mperf_time);
 -		}
 -		aperf_mperf_retry_count = 0;
 -
  		t->aperf = t->aperf * aperf_mperf_multiplier;
  		t->mperf = t->mperf * aperf_mperf_multiplier;
  	}
  
++<<<<<<< HEAD
 +	if (do_smi) {
++=======
+ 	if (DO_BIC(BIC_IRQ))
+ 		t->irq_count = irqs_per_cpu[cpu];
+ 	if (DO_BIC(BIC_SMI)) {
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  		if (get_msr(cpu, MSR_SMI_COUNT, &msr))
  			return -5;
  		t->smi_count = msr & 0xFFFFFFFF;
@@@ -1117,6 -1488,18 +1545,21 @@@
  			return -17;
  		p->pkg_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (DO_BIC(BIC_GFX_rc6))
+ 		p->gfx_rc6_ms = gfx_cur_rc6_ms;
+ 
+ 	if (DO_BIC(BIC_GFXMHz))
+ 		p->gfx_mhz = gfx_cur_mhz;
+ 
+ 	for (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {
+ 		if (get_msr(cpu, mp->msr_num, &p->counter[i]))
+ 			return -10;
+ 	}
+ 
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  	return 0;
  }
  
@@@ -1688,6 -2129,136 +2131,139 @@@ int mark_cpu_present(int cpu
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * snapshot_proc_interrupts()
+  *
+  * read and record summary of /proc/interrupts
+  *
+  * return 1 if config change requires a restart, else return 0
+  */
+ int snapshot_proc_interrupts(void)
+ {
+ 	static FILE *fp;
+ 	int column, retval;
+ 
+ 	if (fp == NULL)
+ 		fp = fopen_or_die("/proc/interrupts", "r");
+ 	else
+ 		rewind(fp);
+ 
+ 	/* read 1st line of /proc/interrupts to get cpu* name for each column */
+ 	for (column = 0; column < topo.num_cpus; ++column) {
+ 		int cpu_number;
+ 
+ 		retval = fscanf(fp, " CPU%d", &cpu_number);
+ 		if (retval != 1)
+ 			break;
+ 
+ 		if (cpu_number > topo.max_cpu_num) {
+ 			warn("/proc/interrupts: cpu%d: > %d", cpu_number, topo.max_cpu_num);
+ 			return 1;
+ 		}
+ 
+ 		irq_column_2_cpu[column] = cpu_number;
+ 		irqs_per_cpu[cpu_number] = 0;
+ 	}
+ 
+ 	/* read /proc/interrupt count lines and sum up irqs per cpu */
+ 	while (1) {
+ 		int column;
+ 		char buf[64];
+ 
+ 		retval = fscanf(fp, " %s:", buf);	/* flush irq# "N:" */
+ 		if (retval != 1)
+ 			break;
+ 
+ 		/* read the count per cpu */
+ 		for (column = 0; column < topo.num_cpus; ++column) {
+ 
+ 			int cpu_number, irq_count;
+ 
+ 			retval = fscanf(fp, " %d", &irq_count);
+ 			if (retval != 1)
+ 				break;
+ 
+ 			cpu_number = irq_column_2_cpu[column];
+ 			irqs_per_cpu[cpu_number] += irq_count;
+ 
+ 		}
+ 
+ 		while (getc(fp) != '\n')
+ 			;	/* flush interrupt description */
+ 
+ 	}
+ 	return 0;
+ }
+ /*
+  * snapshot_gfx_rc6_ms()
+  *
+  * record snapshot of
+  * /sys/class/drm/card0/power/rc6_residency_ms
+  *
+  * return 1 if config change requires a restart, else return 0
+  */
+ int snapshot_gfx_rc6_ms(void)
+ {
+ 	FILE *fp;
+ 	int retval;
+ 
+ 	fp = fopen_or_die("/sys/class/drm/card0/power/rc6_residency_ms", "r");
+ 
+ 	retval = fscanf(fp, "%lld", &gfx_cur_rc6_ms);
+ 	if (retval != 1)
+ 		err(1, "GFX rc6");
+ 
+ 	fclose(fp);
+ 
+ 	return 0;
+ }
+ /*
+  * snapshot_gfx_mhz()
+  *
+  * record snapshot of
+  * /sys/class/graphics/fb0/device/drm/card0/gt_cur_freq_mhz
+  *
+  * return 1 if config change requires a restart, else return 0
+  */
+ int snapshot_gfx_mhz(void)
+ {
+ 	static FILE *fp;
+ 	int retval;
+ 
+ 	if (fp == NULL)
+ 		fp = fopen_or_die("/sys/class/graphics/fb0/device/drm/card0/gt_cur_freq_mhz", "r");
+ 	else
+ 		rewind(fp);
+ 
+ 	retval = fscanf(fp, "%d", &gfx_cur_mhz);
+ 	if (retval != 1)
+ 		err(1, "GFX MHz");
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * snapshot /proc and /sys files
+  *
+  * return 1 if configuration restart needed, else return 0
+  */
+ int snapshot_proc_sysfs_files(void)
+ {
+ 	if (snapshot_proc_interrupts())
+ 		return 1;
+ 
+ 	if (DO_BIC(BIC_GFX_rc6))
+ 		snapshot_gfx_rc6_ms();
+ 
+ 	if (DO_BIC(BIC_GFXMHz))
+ 		snapshot_gfx_mhz();
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  void turbostat_loop()
  {
  	int retval;
@@@ -2201,41 -2881,104 +2777,112 @@@ void rapl_probe(unsigned int family, un
  		return;
  
  	switch (model) {
 -	case INTEL_FAM6_SANDYBRIDGE:
 -	case INTEL_FAM6_IVYBRIDGE:
 -	case INTEL_FAM6_HASWELL_CORE:	/* HSW */
 -	case INTEL_FAM6_HASWELL_ULT:	/* HSW */
 -	case INTEL_FAM6_HASWELL_GT3E:	/* HSW */
 -	case INTEL_FAM6_BROADWELL_CORE:	/* BDW */
 -	case INTEL_FAM6_BROADWELL_GT3E:	/* BDW */
 +	case 0x2A:
 +	case 0x3A:
 +	case 0x3C:	/* HSW */
 +	case 0x45:	/* HSW */
 +	case 0x46:	/* HSW */
 +	case 0x3D:	/* BDW */
 +	case 0x47:	/* BDW */
  		do_rapl = RAPL_PKG | RAPL_CORES | RAPL_CORE_POLICY | RAPL_GFX | RAPL_PKG_POWER_INFO;
+ 		if (rapl_joules) {
+ 			BIC_PRESENT(BIC_Pkg_J);
+ 			BIC_PRESENT(BIC_Cor_J);
+ 			BIC_PRESENT(BIC_GFX_J);
+ 		} else {
+ 			BIC_PRESENT(BIC_PkgWatt);
+ 			BIC_PRESENT(BIC_CorWatt);
+ 			BIC_PRESENT(BIC_GFXWatt);
+ 		}
  		break;
 -	case INTEL_FAM6_ATOM_GOLDMONT:	/* BXT */
 +	case 0x5C:	/* BXT */
  		do_rapl = RAPL_PKG | RAPL_PKG_POWER_INFO;
+ 		if (rapl_joules)
+ 			BIC_PRESENT(BIC_Pkg_J);
+ 		else
+ 			BIC_PRESENT(BIC_PkgWatt);
  		break;
 -	case INTEL_FAM6_SKYLAKE_MOBILE:	/* SKL */
 -	case INTEL_FAM6_SKYLAKE_DESKTOP:	/* SKL */
 -	case INTEL_FAM6_KABYLAKE_MOBILE:	/* KBL */
 -	case INTEL_FAM6_KABYLAKE_DESKTOP:	/* KBL */
 +	case 0x4E:	/* SKL */
 +	case 0x5E:	/* SKL */
 +	case 0x8E:	/* KBL */
 +	case 0x9E:	/* KBL */
  		do_rapl = RAPL_PKG | RAPL_DRAM | RAPL_DRAM_PERF_STATUS | RAPL_PKG_PERF_STATUS | RAPL_PKG_POWER_INFO;
+ 		BIC_PRESENT(BIC_PKG__);
+ 		BIC_PRESENT(BIC_RAM__);
+ 		if (rapl_joules) {
+ 			BIC_PRESENT(BIC_Pkg_J);
+ 			BIC_PRESENT(BIC_Cor_J);
+ 			BIC_PRESENT(BIC_RAM_J);
+ 		} else {
+ 			BIC_PRESENT(BIC_PkgWatt);
+ 			BIC_PRESENT(BIC_CorWatt);
+ 			BIC_PRESENT(BIC_RAMWatt);
+ 		}
  		break;
 -	case INTEL_FAM6_HASWELL_X:	/* HSX */
 -	case INTEL_FAM6_BROADWELL_X:	/* BDX */
 -	case INTEL_FAM6_BROADWELL_XEON_D:	/* BDX-DE */
 -	case INTEL_FAM6_SKYLAKE_X:	/* SKX */
 -	case INTEL_FAM6_XEON_PHI_KNL:	/* KNL */
 -	case INTEL_FAM6_XEON_PHI_KNM:
 +	case 0x3F:	/* HSX */
 +		do_rapl = RAPL_PKG | RAPL_DRAM | RAPL_DRAM_PERF_STATUS | RAPL_PKG_PERF_STATUS | RAPL_PKG_POWER_INFO;
 +		break;
 +	case 0x2D:
 +	case 0x3E:
 +	case 0x4F:	/* BDX */
 +	case 0x56:	/* BDX-DE */
 +	case 0x55:	/* SKX */
 +	case 0x57:	/* KNL */
  		do_rapl = RAPL_PKG | RAPL_DRAM | RAPL_DRAM_POWER_INFO | RAPL_DRAM_PERF_STATUS | RAPL_PKG_PERF_STATUS | RAPL_PKG_POWER_INFO;
+ 		BIC_PRESENT(BIC_PKG__);
+ 		BIC_PRESENT(BIC_RAM__);
+ 		if (rapl_joules) {
+ 			BIC_PRESENT(BIC_Pkg_J);
+ 			BIC_PRESENT(BIC_RAM_J);
+ 		} else {
+ 			BIC_PRESENT(BIC_PkgWatt);
+ 			BIC_PRESENT(BIC_RAMWatt);
+ 		}
  		break;
++<<<<<<< HEAD
 +	case 0x37:	/* BYT */
 +	case 0x4D:	/* AVN */
++=======
+ 	case INTEL_FAM6_SANDYBRIDGE_X:
+ 	case INTEL_FAM6_IVYBRIDGE_X:
+ 		do_rapl = RAPL_PKG | RAPL_CORES | RAPL_CORE_POLICY | RAPL_DRAM | RAPL_DRAM_POWER_INFO | RAPL_PKG_PERF_STATUS | RAPL_DRAM_PERF_STATUS | RAPL_PKG_POWER_INFO;
+ 		BIC_PRESENT(BIC_PKG__);
+ 		BIC_PRESENT(BIC_RAM__);
+ 		if (rapl_joules) {
+ 			BIC_PRESENT(BIC_Pkg_J);
+ 			BIC_PRESENT(BIC_Cor_J);
+ 			BIC_PRESENT(BIC_RAM_J);
+ 		} else {
+ 			BIC_PRESENT(BIC_PkgWatt);
+ 			BIC_PRESENT(BIC_CorWatt);
+ 			BIC_PRESENT(BIC_RAMWatt);
+ 		}
+ 		break;
+ 	case INTEL_FAM6_ATOM_SILVERMONT1:	/* BYT */
+ 	case INTEL_FAM6_ATOM_SILVERMONT2:	/* AVN */
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  		do_rapl = RAPL_PKG | RAPL_CORES;
+ 		if (rapl_joules) {
+ 			BIC_PRESENT(BIC_Pkg_J);
+ 			BIC_PRESENT(BIC_Cor_J);
+ 		} else {
+ 			BIC_PRESENT(BIC_PkgWatt);
+ 			BIC_PRESENT(BIC_CorWatt);
+ 		}
  		break;
 -	case INTEL_FAM6_ATOM_DENVERTON:	/* DNV */
 +	case 0x5f:	/* DNV */
  		do_rapl = RAPL_PKG | RAPL_DRAM | RAPL_DRAM_POWER_INFO | RAPL_DRAM_PERF_STATUS | RAPL_PKG_PERF_STATUS | RAPL_PKG_POWER_INFO | RAPL_CORES_ENERGY_STATUS;
+ 		BIC_PRESENT(BIC_PKG__);
+ 		BIC_PRESENT(BIC_RAM__);
+ 		if (rapl_joules) {
+ 			BIC_PRESENT(BIC_Pkg_J);
+ 			BIC_PRESENT(BIC_Cor_J);
+ 			BIC_PRESENT(BIC_RAM_J);
+ 		} else {
+ 			BIC_PRESENT(BIC_PkgWatt);
+ 			BIC_PRESENT(BIC_CorWatt);
+ 			BIC_PRESENT(BIC_RAMWatt);
+ 		}
  		break;
  	default:
  		return;
@@@ -2769,10 -3553,24 +3416,27 @@@ void process_cpuid(
  	 * this check is valid for both Intel and AMD
  	 */
  
 -	__cpuid(0x6, eax, ebx, ecx, edx);
 +	__get_cpuid(0x6, &eax, &ebx, &ecx, &edx);
  	has_aperf = ecx & (1 << 0);
+ 	if (has_aperf) {
+ 		BIC_PRESENT(BIC_Avg_MHz);
+ 		BIC_PRESENT(BIC_Busy);
+ 		BIC_PRESENT(BIC_Bzy_MHz);
+ 	}
  	do_dts = eax & (1 << 0);
+ 	if (do_dts)
+ 		BIC_PRESENT(BIC_CoreTmp);
  	do_ptm = eax & (1 << 6);
++<<<<<<< HEAD
++=======
+ 	if (do_ptm)
+ 		BIC_PRESENT(BIC_PkgTmp);
+ 	has_hwp = eax & (1 << 7);
+ 	has_hwp_notify = eax & (1 << 8);
+ 	has_hwp_activity_window = eax & (1 << 9);
+ 	has_hwp_epp = eax & (1 << 10);
+ 	has_hwp_pkg = eax & (1 << 11);
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  	has_epb = ecx & (1 << 3);
  
  	if (debug)
@@@ -2832,8 -3663,22 +3496,25 @@@
  	if (has_aperf)
  		aperf_mperf_multiplier = get_aperf_mperf_multiplier(family, model);
  
- 	do_nhm_platform_info = do_nhm_cstates = do_smi = probe_nhm_msrs(family, model);
+ 	BIC_PRESENT(BIC_IRQ);
+ 	BIC_PRESENT(BIC_TSC_MHz);
+ 
+ 	if (probe_nhm_msrs(family, model)) {
+ 		do_nhm_platform_info = 1;
+ 		BIC_PRESENT(BIC_CPU_c1);
+ 		BIC_PRESENT(BIC_CPU_c3);
+ 		BIC_PRESENT(BIC_CPU_c6);
+ 		BIC_PRESENT(BIC_SMI);
+ 	}
  	do_snb_cstates = has_snb_msrs(family, model);
++<<<<<<< HEAD
++=======
+ 
+ 	if (do_snb_cstates)
+ 		BIC_PRESENT(BIC_CPU_c7);
+ 
+ 	do_irtl_snb = has_snb_msrs(family, model);
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  	do_pc2 = do_snb_cstates && (pkg_cstate_limit >= PCL__2);
  	do_pc3 = (pkg_cstate_limit >= PCL__3);
  	do_pc6 = (pkg_cstate_limit >= PCL__6);
@@@ -2852,6 -3701,12 +3533,15 @@@
  	if (has_skl_msrs(family, model))
  		calculate_tsc_tweak();
  
++<<<<<<< HEAD
++=======
+ 	if (!access("/sys/class/drm/card0/power/rc6_residency_ms", R_OK))
+ 		BIC_PRESENT(BIC_GFX_rc6);
+ 
+ 	if (!access("/sys/class/graphics/fb0/device/drm/card0/gt_cur_freq_mhz", R_OK))
+ 		BIC_PRESENT(BIC_GFXMHz);
+ 
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  	return;
  }
  
@@@ -2910,10 -3764,10 +3600,10 @@@ void topology_probe(
  	topo.max_cpu_num = 0;
  	for_all_proc_cpus(count_cpus);
  	if (!summary_only && topo.num_cpus > 1)
- 		show_cpu = 1;
+ 		BIC_PRESENT(BIC_CPU);
  
  	if (debug > 1)
 -		fprintf(outf, "num_cpus %d max_cpu_num %d\n", topo.num_cpus, topo.max_cpu_num);
 +		fprintf(stderr, "num_cpus %d max_cpu_num %d\n", topo.num_cpus, topo.max_cpu_num);
  
  	cpus = calloc(1, (topo.max_cpu_num  + 1) * sizeof(struct cpu_topology));
  	if (cpus == NULL)
@@@ -2968,17 -3822,17 +3658,17 @@@
  	}
  	topo.num_cores_per_pkg = max_core_id + 1;
  	if (debug > 1)
 -		fprintf(outf, "max_core_id %d, sizing for %d cores per package\n",
 +		fprintf(stderr, "max_core_id %d, sizing for %d cores per package\n",
  			max_core_id, topo.num_cores_per_pkg);
  	if (debug && !summary_only && topo.num_cores_per_pkg > 1)
- 		show_core = 1;
+ 		BIC_PRESENT(BIC_Core);
  
  	topo.num_packages = max_package_id + 1;
  	if (debug > 1)
 -		fprintf(outf, "max_package_id %d, sizing for %d packages\n",
 +		fprintf(stderr, "max_package_id %d, sizing for %d packages\n",
  			max_package_id, topo.num_packages);
  	if (debug && !summary_only && topo.num_packages > 1)
- 		show_pkg = 1;
+ 		BIC_PRESENT(BIC_Package);
  
  	topo.num_threads_per_core = max_siblings;
  	if (debug > 1)
@@@ -3184,26 -4065,220 +3874,226 @@@ void print_version() 
  		" - Len Brown <lenb@kernel.org>\n");
  }
  
++<<<<<<< HEAD
++=======
+ int add_counter(unsigned int msr_num, char *name, unsigned int width,
+ 	enum counter_scope scope, enum counter_type type,
+ 	enum counter_format format)
+ {
+ 	struct msr_counter *msrp;
+ 
+ 	msrp = calloc(1, sizeof(struct msr_counter));
+ 	if (msrp == NULL) {
+ 		perror("calloc");
+ 		exit(1);
+ 	}
+ 
+ 	msrp->msr_num = msr_num;
+ 	strncpy(msrp->name, name, NAME_BYTES);
+ 	msrp->width = width;
+ 	msrp->type = type;
+ 	msrp->format = format;
+ 
+ 	switch (scope) {
+ 
+ 	case SCOPE_CPU:
+ 		msrp->next = sys.tp;
+ 		sys.tp = msrp;
+ 		sys.added_thread_counters++;
+ 		if (sys.added_thread_counters > MAX_ADDED_COUNTERS) {
+ 			fprintf(stderr, "exceeded max %d added thread counters\n",
+ 				MAX_ADDED_COUNTERS);
+ 			exit(-1);
+ 		}
+ 		break;
+ 
+ 	case SCOPE_CORE:
+ 		msrp->next = sys.cp;
+ 		sys.cp = msrp;
+ 		sys.added_core_counters++;
+ 		if (sys.added_core_counters > MAX_ADDED_COUNTERS) {
+ 			fprintf(stderr, "exceeded max %d added core counters\n",
+ 				MAX_ADDED_COUNTERS);
+ 			exit(-1);
+ 		}
+ 		break;
+ 
+ 	case SCOPE_PACKAGE:
+ 		msrp->next = sys.pp;
+ 		sys.pp = msrp;
+ 		sys.added_package_counters++;
+ 		if (sys.added_package_counters > MAX_ADDED_COUNTERS) {
+ 			fprintf(stderr, "exceeded max %d added package counters\n",
+ 				MAX_ADDED_COUNTERS);
+ 			exit(-1);
+ 		}
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void parse_add_command(char *add_command)
+ {
+ 	int msr_num = 0;
+ 	char name_buffer[NAME_BYTES];
+ 	int width = 64;
+ 	int fail = 0;
+ 	enum counter_scope scope = SCOPE_CPU;
+ 	enum counter_type type = COUNTER_CYCLES;
+ 	enum counter_format format = FORMAT_DELTA;
+ 
+ 	while (add_command) {
+ 
+ 		if (sscanf(add_command, "msr0x%x", &msr_num) == 1)
+ 			goto next;
+ 
+ 		if (sscanf(add_command, "msr%d", &msr_num) == 1)
+ 			goto next;
+ 
+ 		if (sscanf(add_command, "u%d", &width) == 1) {
+ 			if ((width == 32) || (width == 64))
+ 				goto next;
+ 			width = 64;
+ 		}
+ 		if (!strncmp(add_command, "cpu", strlen("cpu"))) {
+ 			scope = SCOPE_CPU;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "core", strlen("core"))) {
+ 			scope = SCOPE_CORE;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "package", strlen("package"))) {
+ 			scope = SCOPE_PACKAGE;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "cycles", strlen("cycles"))) {
+ 			type = COUNTER_CYCLES;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "seconds", strlen("seconds"))) {
+ 			type = COUNTER_SECONDS;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "raw", strlen("raw"))) {
+ 			format = FORMAT_RAW;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "delta", strlen("delta"))) {
+ 			format = FORMAT_DELTA;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "percent", strlen("percent"))) {
+ 			format = FORMAT_PERCENT;
+ 			goto next;
+ 		}
+ 
+ 		if (sscanf(add_command, "%18s,%*s", name_buffer) == 1) {	/* 18 < NAME_BYTES */
+ 			char *eos;
+ 
+ 			eos = strchr(name_buffer, ',');
+ 			if (eos)
+ 				*eos = '\0';
+ 			goto next;
+ 		}
+ 
+ next:
+ 		add_command = strchr(add_command, ',');
+ 		if (add_command)
+ 			add_command++;
+ 
+ 	}
+ 	if (msr_num == 0) {
+ 		fprintf(stderr, "--add: (msrDDD | msr0xXXX) required\n");
+ 		fail++;
+ 	}
+ 
+ 	/* generate default column header */
+ 	if (*name_buffer == '\0') {
+ 		if (format == FORMAT_RAW) {
+ 			if (width == 32)
+ 				sprintf(name_buffer, "msr%d", msr_num);
+ 			else
+ 				sprintf(name_buffer, "MSR%d", msr_num);
+ 		} else if (format == FORMAT_DELTA) {
+ 			if (width == 32)
+ 				sprintf(name_buffer, "cnt%d", msr_num);
+ 			else
+ 				sprintf(name_buffer, "CNT%d", msr_num);
+ 		} else if (format == FORMAT_PERCENT) {
+ 			if (width == 32)
+ 				sprintf(name_buffer, "msr%d%%", msr_num);
+ 			else
+ 				sprintf(name_buffer, "MSR%d%%", msr_num);
+ 		}
+ 	}
+ 
+ 	if (add_counter(msr_num, name_buffer, width, scope, type, format))
+ 		fail++;
+ 
+ 	if (fail) {
+ 		help();
+ 		exit(1);
+ 	}
+ }
+ /*
+  * HIDE_LIST - hide this list of counters, show the rest [default]
+  * SHOW_LIST - show this list of counters, hide the rest
+  */
+ enum show_hide_mode { SHOW_LIST, HIDE_LIST } global_show_hide_mode = HIDE_LIST;
+ 
+ int shown;
+ /*
+  * parse_show_hide() - process cmdline to set default counter action
+  */
+ void parse_show_hide(char *optarg, enum show_hide_mode new_mode)
+ {
+ 	/*
+ 	 * --show: show only those specified
+ 	 *  The 1st invocation will clear and replace the enabled mask
+ 	 *  subsequent invocations can add to it.
+ 	 */
+ 	if (new_mode == SHOW_LIST) {
+ 		if (shown == 0)
+ 			bic_enabled = bic_lookup(optarg);
+ 		else
+ 			bic_enabled |= bic_lookup(optarg);
+ 		shown = 1;
+ 
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * --hide: do not show those specified
+ 	 *  multiple invocations simply clear more bits in enabled mask
+ 	 */
+ 	bic_enabled &= ~bic_lookup(optarg);
+ }
+ 
++>>>>>>> 812db3f77b9a (tools/power turbostat: Add --show and --hide parameters)
  void cmdline(int argc, char **argv)
  {
  	int opt;
  	int option_index = 0;
  	static struct option long_options[] = {
 -		{"add",		required_argument,	0, 'a'},
 +		{"Counter",	required_argument,	0, 'C'},
 +		{"counter",	required_argument,	0, 'c'},
  		{"Dump",	no_argument,		0, 'D'},
  		{"debug",	no_argument,		0, 'd'},
 +		{"verbose",	no_argument,		0, 'v'},
  		{"interval",	required_argument,	0, 'i'},
  		{"help",	no_argument,		0, 'h'},
+ 		{"hide",	required_argument,	0, 'H'},	// meh, -h taken by --help
  		{"Joules",	no_argument,		0, 'J'},
 -		{"out",		required_argument,	0, 'o'},
 +		{"MSR",		required_argument,	0, 'M'},
 +		{"msr",		required_argument,	0, 'm'},
  		{"Package",	no_argument,		0, 'p'},
  		{"processor",	no_argument,		0, 'p'},
+ 		{"show",	required_argument,	0, 's'},
  		{"Summary",	no_argument,		0, 'S'},
  		{"TCC",		required_argument,	0, 'T'},
 -		{"version",	no_argument,		0, 'v' },
 +		{"version",	no_argument,		0, 'V' },
  		{0,		0,			0,  0 }
  	};
  
@@@ -3222,9 -4294,11 +4112,12 @@@
  			dump_only++;
  			break;
  		case 'd':
 +		case 'v':
  			debug++;
  			break;
+ 		case 'H':
+ 			parse_show_hide(optarg, HIDE_LIST);
+ 			break;
  		case 'h':
  		default:
  			help();
diff --git a/tools/power/x86/turbostat/turbostat.8 b/tools/power/x86/turbostat/turbostat.8
index a7cc18d34bc1..f7a669b304ee 100644
--- a/tools/power/x86/turbostat/turbostat.8
+++ b/tools/power/x86/turbostat/turbostat.8
@@ -29,6 +29,10 @@ name as necessary to disambiguate it from others is necessary.  Note that option
 .PP
 \fB--counter MSR#\fP shows the delta of the specified 32-bit MSR counter.
 .PP
+\fB--hide column\fP do not show the specified columns.  May be invoked multiple times, or with a comma-separated list of column names.
+.PP
+\fB--show column\fP show only the specified columns.  May be invoked multiple times, or with a comma-separated list of column names.
+.PP
 \fB--Dump\fP displays the raw counter values.
 .PP
 \fB--debug\fP displays additional system configuration information.  Invoking this parameter
* Unmerged path tools/power/x86/turbostat/turbostat.c
