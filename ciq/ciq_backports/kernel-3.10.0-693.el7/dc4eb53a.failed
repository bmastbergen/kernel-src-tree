bridge: adhere to querier election mechanism specified by RFCs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Linus Lüssing <linus.luessing@web.de>
commit dc4eb53a996a78bfb8ea07b47423ff5a3aadc362
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/dc4eb53a.failed

MLDv1 (RFC2710 section 6), MLDv2 (RFC3810 section 7.6.2), IGMPv2
(RFC2236 section 3) and IGMPv3 (RFC3376 section 6.6.2) specify that the
querier with lowest source address shall become the selected
querier.

So far the bridge stopped its querier as soon as it heard another
querier regardless of its source address. This results in the "wrong"
querier potentially becoming the active querier or a potential,
unnecessary querying delay.

With this patch the bridge memorizes the source address of the currently
selected querier and ignores queries from queriers with a higher source
address than the currently selected one. This slight optimization is
supposed to make it more RFC compliant (but is rather uncritical and
therefore probably not necessary to be queued for stable kernels).

	Signed-off-by: Linus Lüssing <linus.luessing@web.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dc4eb53a996a78bfb8ea07b47423ff5a3aadc362)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
diff --cc net/bridge/br_multicast.c
index 251bf0711bce,b3f17c9b4d06..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -803,12 -812,14 +815,20 @@@ static void __br_multicast_send_query(s
  		return;
  
  	if (port) {
 -		__skb_push(skb, sizeof(struct ethhdr));
  		skb->dev = port->dev;
++<<<<<<< HEAD
 +		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, NULL, skb,
 +			NULL, skb->dev,
 +			br_dev_queue_push_xmit);
 +	} else
++=======
+ 		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT, skb, NULL, skb->dev,
+ 			dev_queue_xmit);
+ 	} else {
+ 		br_multicast_select_own_querier(br, ip, skb);
++>>>>>>> dc4eb53a996a (bridge: adhere to querier election mechanism specified by RFCs)
  		netif_rx(skb);
+ 	}
  }
  
  static void br_multicast_send_query(struct net_bridge *br,
* Unmerged path net/bridge/br_multicast.c
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index dadd34070a9c..782422e6ccaa 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -69,6 +69,11 @@ struct bridge_mcast_other_query {
 	struct timer_list		timer;
 	unsigned long			delay_time;
 };
+
+/* selected querier */
+struct bridge_mcast_querier {
+	struct br_ip addr;
+};
 #endif
 
 struct net_port_vlans {
@@ -270,9 +275,11 @@ struct net_bridge
 	struct timer_list		multicast_router_timer;
 	struct bridge_mcast_other_query	ip4_other_query;
 	struct bridge_mcast_own_query	ip4_own_query;
+	struct bridge_mcast_querier	ip4_querier;
 #if IS_ENABLED(CONFIG_IPV6)
 	struct bridge_mcast_other_query	ip6_other_query;
 	struct bridge_mcast_own_query	ip6_own_query;
+	struct bridge_mcast_querier	ip6_querier;
 #endif /* IS_ENABLED(CONFIG_IPV6) */
 #endif
 
