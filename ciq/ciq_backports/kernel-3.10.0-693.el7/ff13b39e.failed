nvme/pci: Delete misleading queue-wrap comment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [nvme] pci: Delete misleading queue-wrap comment (David Milburn) [1384526 1389755 1366753 1374291 1383834]
Rebuild_FUZZ: 94.25%
commit-author Keith Busch <keith.busch@intel.com>
commit ff13b39ecf726715a96fcd3c23e50eb792ef6516
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ff13b39e.failed

It is not theoretically possible for this driver to wrap twice while
processing completions. The driver allocates only 'queue_depth - 1'
tags, so there can never be more than that to reap when processing a
completion queue. Removing this misleading comment makes it a little
less likely people with broken controllers will blame the driver for
their spurious interrupts.

	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit ff13b39ecf726715a96fcd3c23e50eb792ef6516)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/pci.c
index f32ea6cfb9f0,151ce59f4ffb..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -699,22 -710,12 +699,21 @@@ static int nvme_process_cq(struct nvme_
  		}
  
  		req = blk_mq_tag_to_rq(*nvmeq->tags, cqe.command_id);
++<<<<<<< HEAD
 +		if (req->cmd_type == REQ_TYPE_DRV_PRIV) {
 +			u32 result = le32_to_cpu(cqe.result);
 +			req->special = (void *)(uintptr_t)result;
 +		}
 +		blk_mq_complete_request(req, status >> 1);
 +
++=======
+ 		nvme_req(req)->result = cqe.result;
+ 		blk_mq_complete_request(req, le16_to_cpu(cqe.status) >> 1);
++>>>>>>> ff13b39ecf72 (nvme/pci: Delete misleading queue-wrap comment)
  	}
  
- 	/* If the controller ignores the cq head doorbell and continuously
- 	 * writes to the queue, it is theoretically possible to wrap around
- 	 * the queue twice and mistakenly return IRQ_NONE.  Linux only
- 	 * requires that 0.1% of your interrupts are handled, so this isn't
- 	 * a big problem.
- 	 */
  	if (head == nvmeq->cq_head && phase == nvmeq->cq_phase)
 -		return;
 +		return 0;
  
  	if (likely(nvmeq->cq_vector >= 0))
  		writel(head, nvmeq->q_db + nvmeq->dev->db_stride);
* Unmerged path drivers/nvme/host/pci.c
