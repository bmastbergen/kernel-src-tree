i40e: refactor i40e_put_mac_in_vlan to avoid changing f->vlan

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 5feb3d7b0c0a66c8537ca8a79d8f80f54783e73f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5feb3d7b.failed

When a PVID has been assigned to a VSI, the function
i40e_put_mac_in_vlan arbitrarily modifies all filters
to have the same VLAN. This is obviously incorrect
because it could be modifying active filters without
putting them into the NEW state. The correct method
is to remove then re-add filters which is already done
in the code where we assign the PVID.

Fix this issue and a few other minor nits at the same
time. First, when we have a PVID don't even bother
looping and simply add the filter with the PVID immediately.

In the case of the loop, we now can remove several checks.
We also don't need to use i40e_find_filter first before
calling i40e_add_filter, since i40e_add_filter implicitly
does a lookup already.

Finally, update the return semantics of this function so
that on failure to add a filter it returns NULL, but on
success, it returns the last filter added. Otherwise,
we're just returning the last filter in the list. An
alternative fix might be to return 0 or an error code,
but this is pretty invasive to every call site.

Change-ID: I2325dfd843aec76d89fb0d7cb0e7c4f290a34840
	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 5feb3d7b0c0a66c8537ca8a79d8f80f54783e73f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 6f5b9c2cdeec,c09609339bd2..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -1223,75 -1207,6 +1223,85 @@@ bool i40e_is_vsi_in_vlan(struct i40e_vs
  	return false;
  }
  
 +/**
 + * i40e_put_mac_in_vlan - Make macvlan filters from macaddrs and vlans
 + * @vsi: the VSI to be searched
 + * @macaddr: the mac address to be filtered
 + * @is_vf: true if it is a VF
 + * @is_netdev: true if it is a netdev
 + *
-  * Goes through all the macvlan filters and adds a
-  * macvlan filter for each unique vlan that already exists
++ * Goes through all the macvlan filters and adds a macvlan filter for each
++ * unique vlan that already exists. If a PVID has been assigned, instead only
++ * add the macaddr to that VLAN.
 + *
-  * Returns first filter found on success, else NULL
++ * Returns last filter added on success, else NULL
 + **/
 +struct i40e_mac_filter *i40e_put_mac_in_vlan(struct i40e_vsi *vsi, u8 *macaddr,
 +					     bool is_vf, bool is_netdev)
 +{
- 	struct i40e_mac_filter *f;
++	struct i40e_mac_filter *f, *add = NULL;
++
++	if (vsi->info.pvid)
++		return i40e_add_filter(vsi, macaddr,
++				       le16_to_cpu(vsi->info.pvid));
 +
 +	list_for_each_entry(f, &vsi->mac_filter_list, list) {
++<<<<<<< HEAD
 +		if (vsi->info.pvid)
 +			f->vlan = le16_to_cpu(vsi->info.pvid);
 +		if (!i40e_find_filter(vsi, macaddr, f->vlan,
 +				      is_vf, is_netdev)) {
 +			if (!i40e_add_filter(vsi, macaddr, f->vlan,
 +					     is_vf, is_netdev))
 +				return NULL;
 +		}
++=======
++		add = i40e_add_filter(vsi, macaddr, f->vlan);
++		if (!add)
++			return NULL;
++>>>>>>> 5feb3d7b0c0a (i40e: refactor i40e_put_mac_in_vlan to avoid changing f->vlan)
 +	}
 +
- 	return list_first_entry_or_null(&vsi->mac_filter_list,
- 					struct i40e_mac_filter, list);
++	return add;
 +}
 +
 +/**
 + * i40e_del_mac_all_vlan - Remove a MAC filter from all VLANS
 + * @vsi: the VSI to be searched
 + * @macaddr: the mac address to be removed
 + * @is_vf: true if it is a VF
 + * @is_netdev: true if it is a netdev
 + *
 + * Removes a given MAC address from a VSI, regardless of VLAN
 + *
 + * Returns 0 for success, or error
 + **/
 +int i40e_del_mac_all_vlan(struct i40e_vsi *vsi, u8 *macaddr,
 +			  bool is_vf, bool is_netdev)
 +{
 +	struct i40e_mac_filter *f = NULL;
 +	int changed = 0;
 +
 +	WARN(!spin_is_locked(&vsi->mac_filter_list_lock),
 +	     "Missing mac_filter_list_lock\n");
 +	list_for_each_entry(f, &vsi->mac_filter_list, list) {
 +		if ((ether_addr_equal(macaddr, f->macaddr)) &&
 +		    (is_vf == f->is_vf) &&
 +		    (is_netdev == f->is_netdev)) {
 +			f->counter--;
 +			changed = 1;
 +			if (f->counter == 0)
 +				f->state = I40E_FILTER_REMOVE;
 +		}
 +	}
 +	if (changed) {
 +		vsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;
 +		vsi->back->flags |= I40E_FLAG_FILTER_SYNC;
 +		return 0;
 +	}
 +	return -ENOENT;
 +}
 +
  /**
   * i40e_add_filter - Add a mac/vlan filter to the VSI
   * @vsi: the VSI to be searched
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
