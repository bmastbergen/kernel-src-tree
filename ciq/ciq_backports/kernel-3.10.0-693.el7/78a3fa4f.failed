ovl: use generic_readlink

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 78a3fa4f3249055b472983065b30c02392cf7e2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/78a3fa4f.failed

All filesystems that are backers for overlayfs would also use
generic_readlink().  Move this logic to the overlay itself, which is a nice
cleanup.

	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit 78a3fa4f3249055b472983065b30c02392cf7e2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/inode.c
diff --cc fs/overlayfs/inode.c
index 2a89e2b4ad30,50dc214c44f2..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -169,65 -167,16 +169,69 @@@ static void *ovl_follow_link(struct den
  	realdentry = ovl_dentry_real(dentry);
  	realinode = realdentry->d_inode;
  
 -	if (WARN_ON(!realinode->i_op->get_link))
 +	if (WARN_ON(!realinode->i_op->follow_link))
  		return ERR_PTR(-EPERM);
  
 +	if (realinode->i_op->put_link) {
 +		data = kmalloc(sizeof(struct ovl_link_data), GFP_KERNEL);
 +		if (!data)
 +			return ERR_PTR(-ENOMEM);
 +		data->realdentry = realdentry;
 +	}
 +
 +	old_cred = ovl_override_creds(dentry->d_sb);
 +	ret = realinode->i_op->follow_link(realdentry, nd);
 +	revert_creds(old_cred);
 +	if (IS_ERR(ret)) {
 +		kfree(data);
 +		return ret;
 +	}
 +
 +	if (data)
 +		data->cookie = ret;
 +
 +	return data;
 +}
 +
 +static void ovl_put_link(struct dentry *dentry, struct nameidata *nd, void *c)
 +{
 +	struct inode *realinode;
 +	struct ovl_link_data *data = c;
 +
 +	if (!data)
 +		return;
 +
 +	realinode = data->realdentry->d_inode;
 +	realinode->i_op->put_link(data->realdentry, nd, data->cookie);
 +	kfree(data);
 +}
 +
++<<<<<<< HEAD
 +static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
 +{
 +	struct path realpath;
 +	struct inode *realinode;
 +	const struct cred *old_cred;
 +	int err;
 +
 +	ovl_path_real(dentry, &realpath);
 +	realinode = realpath.dentry->d_inode;
 +
 +	if (!realinode->i_op->readlink)
 +		return -EINVAL;
 +
 +	touch_atime(&realpath);
 +
  	old_cred = ovl_override_creds(dentry->d_sb);
 -	p = realinode->i_op->get_link(realdentry, realinode, done);
 +	err = realinode->i_op->readlink(realpath.dentry, buf, bufsiz);
  	revert_creds(old_cred);
 -	return p;
 +	return err;
  }
  
 +static bool ovl_is_private_xattr(const char *name)
++=======
+ bool ovl_is_private_xattr(const char *name)
++>>>>>>> 78a3fa4f3249 (ovl: use generic_readlink)
  {
  	return strncmp(name, OVL_XATTR_PREFIX,
  		       sizeof(OVL_XATTR_PREFIX) - 1) == 0;
@@@ -393,14 -361,14 +397,19 @@@ static const struct inode_operations_wr
  
  static const struct inode_operations ovl_symlink_inode_operations = {
  	.setattr	= ovl_setattr,
++<<<<<<< HEAD
 +	.follow_link	= ovl_follow_link,
 +	.put_link	= ovl_put_link,
 +	.readlink	= ovl_readlink,
++=======
+ 	.get_link	= ovl_get_link,
+ 	.readlink	= generic_readlink,
++>>>>>>> 78a3fa4f3249 (ovl: use generic_readlink)
  	.getattr	= ovl_getattr,
  	.setxattr	= generic_setxattr,
 -	.getxattr	= generic_getxattr,
 +	.getxattr	= ovl_getxattr,
  	.listxattr	= ovl_listxattr,
  	.removexattr	= generic_removexattr,
 -	.update_time	= ovl_update_time,
  };
  
  static void ovl_fill_inode(struct inode *inode, umode_t mode)
* Unmerged path fs/overlayfs/inode.c
