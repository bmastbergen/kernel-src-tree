sysfs, kernfs: prepare mount path for kernfs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tejun Heo <tj@kernel.org>
commit 4b93dc9b1c684d0587fe44d36bbfdf45bd3bea9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4b93dc9b.failed

We're in the process of separating out core sysfs functionality into
kernfs which will deal with sysfs_dirents directly.  This patch
rearranges mount path so that the kernfs and sysfs parts are separate.

* As sysfs_super_info won't be visible outside kernfs proper,
  kernfs_super_ns() is added to allow kernfs users to access a
  super_block's namespace tag.

* Generic mount operation is separated out into kernfs_mount_ns().
  sysfs_mount() now just performs sysfs-specific permission check,
  acquires namespace tag, and invokes kernfs_mount_ns().

* Generic superblock release is separated out into kernfs_kill_sb()
  which can be used directly as file_system_type->kill_sb().  As sysfs
  needs to put the namespace tag, sysfs_kill_sb() wraps
  kernfs_kill_sb() with ns tag put.

* sysfs_dir_cachep init and sysfs_inode_init() are separated out into
  kernfs_init().  kernfs_init() uses only small amount of memory and
  trying to handle and propagate kernfs_init() failure doesn't make
  much sense.  Use SLAB_PANIC for sysfs_dir_cachep and make
  sysfs_inode_init() panic on failure.

  After this change, kernfs_init() should be called before
  sysfs_init(), fs/namespace.c::mnt_init() modified accordingly.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Cc: linux-fsdevel@vger.kernel.org
	Cc: Christoph Hellwig <hch@infradead.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 4b93dc9b1c684d0587fe44d36bbfdf45bd3bea9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/kernfs/inode.c
#	fs/kernfs/kernfs-internal.h
#	fs/namespace.c
#	fs/sysfs/mount.c
#	include/linux/kernfs.h
diff --cc fs/kernfs/inode.c
index 86bfeea07de2,b4cae6fd717b..000000000000
--- a/fs/kernfs/inode.c
+++ b/fs/kernfs/inode.c
@@@ -7,3 -7,331 +7,334 @@@
   *
   * This file is released under the GPLv2.
   */
++<<<<<<< HEAD
++=======
+ 
+ #include <linux/pagemap.h>
+ #include <linux/backing-dev.h>
+ #include <linux/capability.h>
+ #include <linux/errno.h>
+ #include <linux/slab.h>
+ #include <linux/xattr.h>
+ #include <linux/security.h>
+ 
+ #include "kernfs-internal.h"
+ 
+ static const struct address_space_operations sysfs_aops = {
+ 	.readpage	= simple_readpage,
+ 	.write_begin	= simple_write_begin,
+ 	.write_end	= simple_write_end,
+ };
+ 
+ static struct backing_dev_info sysfs_backing_dev_info = {
+ 	.name		= "sysfs",
+ 	.ra_pages	= 0,	/* No readahead */
+ 	.capabilities	= BDI_CAP_NO_ACCT_AND_WRITEBACK,
+ };
+ 
+ static const struct inode_operations sysfs_inode_operations = {
+ 	.permission	= sysfs_permission,
+ 	.setattr	= sysfs_setattr,
+ 	.getattr	= sysfs_getattr,
+ 	.setxattr	= sysfs_setxattr,
+ };
+ 
+ void __init sysfs_inode_init(void)
+ {
+ 	if (bdi_init(&sysfs_backing_dev_info))
+ 		panic("failed to init sysfs_backing_dev_info");
+ }
+ 
+ static struct sysfs_inode_attrs *sysfs_init_inode_attrs(struct sysfs_dirent *sd)
+ {
+ 	struct sysfs_inode_attrs *attrs;
+ 	struct iattr *iattrs;
+ 
+ 	attrs = kzalloc(sizeof(struct sysfs_inode_attrs), GFP_KERNEL);
+ 	if (!attrs)
+ 		return NULL;
+ 	iattrs = &attrs->ia_iattr;
+ 
+ 	/* assign default attributes */
+ 	iattrs->ia_mode = sd->s_mode;
+ 	iattrs->ia_uid = GLOBAL_ROOT_UID;
+ 	iattrs->ia_gid = GLOBAL_ROOT_GID;
+ 	iattrs->ia_atime = iattrs->ia_mtime = iattrs->ia_ctime = CURRENT_TIME;
+ 
+ 	return attrs;
+ }
+ 
+ static int __kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr)
+ {
+ 	struct sysfs_inode_attrs *sd_attrs;
+ 	struct iattr *iattrs;
+ 	unsigned int ia_valid = iattr->ia_valid;
+ 
+ 	sd_attrs = sd->s_iattr;
+ 
+ 	if (!sd_attrs) {
+ 		/* setting attributes for the first time, allocate now */
+ 		sd_attrs = sysfs_init_inode_attrs(sd);
+ 		if (!sd_attrs)
+ 			return -ENOMEM;
+ 		sd->s_iattr = sd_attrs;
+ 	}
+ 	/* attributes were changed at least once in past */
+ 	iattrs = &sd_attrs->ia_iattr;
+ 
+ 	if (ia_valid & ATTR_UID)
+ 		iattrs->ia_uid = iattr->ia_uid;
+ 	if (ia_valid & ATTR_GID)
+ 		iattrs->ia_gid = iattr->ia_gid;
+ 	if (ia_valid & ATTR_ATIME)
+ 		iattrs->ia_atime = iattr->ia_atime;
+ 	if (ia_valid & ATTR_MTIME)
+ 		iattrs->ia_mtime = iattr->ia_mtime;
+ 	if (ia_valid & ATTR_CTIME)
+ 		iattrs->ia_ctime = iattr->ia_ctime;
+ 	if (ia_valid & ATTR_MODE) {
+ 		umode_t mode = iattr->ia_mode;
+ 		iattrs->ia_mode = sd->s_mode = mode;
+ 	}
+ 	return 0;
+ }
+ 
+ /**
+  * kernfs_setattr - set iattr on a node
+  * @sd: target node
+  * @iattr: iattr to set
+  *
+  * Returns 0 on success, -errno on failure.
+  */
+ int kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&sysfs_mutex);
+ 	ret = __kernfs_setattr(sd, iattr);
+ 	mutex_unlock(&sysfs_mutex);
+ 	return ret;
+ }
+ 
+ int sysfs_setattr(struct dentry *dentry, struct iattr *iattr)
+ {
+ 	struct inode *inode = dentry->d_inode;
+ 	struct sysfs_dirent *sd = dentry->d_fsdata;
+ 	int error;
+ 
+ 	if (!sd)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&sysfs_mutex);
+ 	error = inode_change_ok(inode, iattr);
+ 	if (error)
+ 		goto out;
+ 
+ 	error = __kernfs_setattr(sd, iattr);
+ 	if (error)
+ 		goto out;
+ 
+ 	/* this ignores size changes */
+ 	setattr_copy(inode, iattr);
+ 
+ out:
+ 	mutex_unlock(&sysfs_mutex);
+ 	return error;
+ }
+ 
+ static int sysfs_sd_setsecdata(struct sysfs_dirent *sd, void **secdata,
+ 			       u32 *secdata_len)
+ {
+ 	struct sysfs_inode_attrs *iattrs;
+ 	void *old_secdata;
+ 	size_t old_secdata_len;
+ 
+ 	if (!sd->s_iattr) {
+ 		sd->s_iattr = sysfs_init_inode_attrs(sd);
+ 		if (!sd->s_iattr)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	iattrs = sd->s_iattr;
+ 	old_secdata = iattrs->ia_secdata;
+ 	old_secdata_len = iattrs->ia_secdata_len;
+ 
+ 	iattrs->ia_secdata = *secdata;
+ 	iattrs->ia_secdata_len = *secdata_len;
+ 
+ 	*secdata = old_secdata;
+ 	*secdata_len = old_secdata_len;
+ 	return 0;
+ }
+ 
+ int sysfs_setxattr(struct dentry *dentry, const char *name, const void *value,
+ 		size_t size, int flags)
+ {
+ 	struct sysfs_dirent *sd = dentry->d_fsdata;
+ 	void *secdata;
+ 	int error;
+ 	u32 secdata_len = 0;
+ 
+ 	if (!sd)
+ 		return -EINVAL;
+ 
+ 	if (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN)) {
+ 		const char *suffix = name + XATTR_SECURITY_PREFIX_LEN;
+ 		error = security_inode_setsecurity(dentry->d_inode, suffix,
+ 						value, size, flags);
+ 		if (error)
+ 			goto out;
+ 		error = security_inode_getsecctx(dentry->d_inode,
+ 						&secdata, &secdata_len);
+ 		if (error)
+ 			goto out;
+ 
+ 		mutex_lock(&sysfs_mutex);
+ 		error = sysfs_sd_setsecdata(sd, &secdata, &secdata_len);
+ 		mutex_unlock(&sysfs_mutex);
+ 
+ 		if (secdata)
+ 			security_release_secctx(secdata, secdata_len);
+ 	} else
+ 		return -EINVAL;
+ out:
+ 	return error;
+ }
+ 
+ static inline void set_default_inode_attr(struct inode *inode, umode_t mode)
+ {
+ 	inode->i_mode = mode;
+ 	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+ }
+ 
+ static inline void set_inode_attr(struct inode *inode, struct iattr *iattr)
+ {
+ 	inode->i_uid = iattr->ia_uid;
+ 	inode->i_gid = iattr->ia_gid;
+ 	inode->i_atime = iattr->ia_atime;
+ 	inode->i_mtime = iattr->ia_mtime;
+ 	inode->i_ctime = iattr->ia_ctime;
+ }
+ 
+ static void sysfs_refresh_inode(struct sysfs_dirent *sd, struct inode *inode)
+ {
+ 	struct sysfs_inode_attrs *iattrs = sd->s_iattr;
+ 
+ 	inode->i_mode = sd->s_mode;
+ 	if (iattrs) {
+ 		/* sysfs_dirent has non-default attributes
+ 		 * get them from persistent copy in sysfs_dirent
+ 		 */
+ 		set_inode_attr(inode, &iattrs->ia_iattr);
+ 		security_inode_notifysecctx(inode,
+ 					    iattrs->ia_secdata,
+ 					    iattrs->ia_secdata_len);
+ 	}
+ 
+ 	if (sysfs_type(sd) == SYSFS_DIR)
+ 		set_nlink(inode, sd->s_dir.subdirs + 2);
+ }
+ 
+ int sysfs_getattr(struct vfsmount *mnt, struct dentry *dentry,
+ 		  struct kstat *stat)
+ {
+ 	struct sysfs_dirent *sd = dentry->d_fsdata;
+ 	struct inode *inode = dentry->d_inode;
+ 
+ 	mutex_lock(&sysfs_mutex);
+ 	sysfs_refresh_inode(sd, inode);
+ 	mutex_unlock(&sysfs_mutex);
+ 
+ 	generic_fillattr(inode, stat);
+ 	return 0;
+ }
+ 
+ static void sysfs_init_inode(struct sysfs_dirent *sd, struct inode *inode)
+ {
+ 	kernfs_get(sd);
+ 	inode->i_private = sd;
+ 	inode->i_mapping->a_ops = &sysfs_aops;
+ 	inode->i_mapping->backing_dev_info = &sysfs_backing_dev_info;
+ 	inode->i_op = &sysfs_inode_operations;
+ 
+ 	set_default_inode_attr(inode, sd->s_mode);
+ 	sysfs_refresh_inode(sd, inode);
+ 
+ 	/* initialize inode according to type */
+ 	switch (sysfs_type(sd)) {
+ 	case SYSFS_DIR:
+ 		inode->i_op = &sysfs_dir_inode_operations;
+ 		inode->i_fop = &sysfs_dir_operations;
+ 		break;
+ 	case SYSFS_KOBJ_ATTR:
+ 		inode->i_size = sd->s_attr.size;
+ 		inode->i_fop = &kernfs_file_operations;
+ 		break;
+ 	case SYSFS_KOBJ_LINK:
+ 		inode->i_op = &sysfs_symlink_inode_operations;
+ 		break;
+ 	default:
+ 		BUG();
+ 	}
+ 
+ 	unlock_new_inode(inode);
+ }
+ 
+ /**
+  *	sysfs_get_inode - get inode for sysfs_dirent
+  *	@sb: super block
+  *	@sd: sysfs_dirent to allocate inode for
+  *
+  *	Get inode for @sd.  If such inode doesn't exist, a new inode
+  *	is allocated and basics are initialized.  New inode is
+  *	returned locked.
+  *
+  *	LOCKING:
+  *	Kernel thread context (may sleep).
+  *
+  *	RETURNS:
+  *	Pointer to allocated inode on success, NULL on failure.
+  */
+ struct inode *sysfs_get_inode(struct super_block *sb, struct sysfs_dirent *sd)
+ {
+ 	struct inode *inode;
+ 
+ 	inode = iget_locked(sb, sd->s_ino);
+ 	if (inode && (inode->i_state & I_NEW))
+ 		sysfs_init_inode(sd, inode);
+ 
+ 	return inode;
+ }
+ 
+ /*
+  * The sysfs_dirent serves as both an inode and a directory entry for sysfs.
+  * To prevent the sysfs inode numbers from being freed prematurely we take a
+  * reference to sysfs_dirent from the sysfs inode.  A
+  * super_operations.evict_inode() implementation is needed to drop that
+  * reference upon inode destruction.
+  */
+ void sysfs_evict_inode(struct inode *inode)
+ {
+ 	struct sysfs_dirent *sd  = inode->i_private;
+ 
+ 	truncate_inode_pages(&inode->i_data, 0);
+ 	clear_inode(inode);
+ 	kernfs_put(sd);
+ }
+ 
+ int sysfs_permission(struct inode *inode, int mask)
+ {
+ 	struct sysfs_dirent *sd;
+ 
+ 	if (mask & MAY_NOT_BLOCK)
+ 		return -ECHILD;
+ 
+ 	sd = inode->i_private;
+ 
+ 	mutex_lock(&sysfs_mutex);
+ 	sysfs_refresh_inode(sd, inode);
+ 	mutex_unlock(&sysfs_mutex);
+ 
+ 	return generic_permission(inode, mask);
+ }
++>>>>>>> 4b93dc9b1c68 (sysfs, kernfs: prepare mount path for kernfs)
diff --cc fs/namespace.c
index 5bfed5a73a95,a511ea003f89..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -2847,7 -2790,7 +2847,11 @@@ void __init mnt_init(void
  	for (u = 0; u < HASH_SIZE; u++)
  		INIT_LIST_HEAD(&mountpoint_hashtable[u]);
  
++<<<<<<< HEAD
 +	br_lock_init(&vfsmount_lock);
++=======
+ 	kernfs_init();
++>>>>>>> 4b93dc9b1c68 (sysfs, kernfs: prepare mount path for kernfs)
  
  	err = sysfs_init();
  	if (err)
diff --cc fs/sysfs/mount.c
index afd83273e6ce,5384732700ba..000000000000
--- a/fs/sysfs/mount.c
+++ b/fs/sysfs/mount.c
@@@ -96,31 -86,67 +96,81 @@@ static int sysfs_set_super(struct super
  	return error;
  }
  
- static void free_sysfs_super_info(struct sysfs_super_info *info)
+ /**
+  * kernfs_super_ns - determine the namespace tag of a kernfs super_block
+  * @sb: super_block of interest
+  *
+  * Return the namespace tag associated with kernfs super_block @sb.
+  */
+ const void *kernfs_super_ns(struct super_block *sb)
  {
++<<<<<<< HEAD
 +	int type;
 +	for (type = KOBJ_NS_TYPE_NONE; type < KOBJ_NS_TYPES; type++)
 +		kobj_ns_drop(type, info->ns[type]);
 +	kfree(info);
++=======
+ 	struct sysfs_super_info *info = sysfs_info(sb);
+ 
+ 	return info->ns;
++>>>>>>> 4b93dc9b1c68 (sysfs, kernfs: prepare mount path for kernfs)
  }
  
  static struct dentry *sysfs_mount(struct file_system_type *fs_type,
  	int flags, const char *dev_name, void *data)
  {
++<<<<<<< HEAD
 +	struct sysfs_super_info *info;
 +	enum kobj_ns_type type;
 +	struct super_block *sb;
 +	int error;
++=======
+ 	struct dentry *root;
+ 	void *ns;
++>>>>>>> 4b93dc9b1c68 (sysfs, kernfs: prepare mount path for kernfs)
  
 -	if (!(flags & MS_KERNMOUNT)) {
 -		if (!capable(CAP_SYS_ADMIN) && !fs_fully_visible(fs_type))
 -			return ERR_PTR(-EPERM);
 -
 -		if (!kobj_ns_current_may_mount(KOBJ_NS_TYPE_NET))
 -			return ERR_PTR(-EPERM);
 -	}
 +	if (!(flags & MS_KERNMOUNT) && !current_user_ns()->may_mount_sysfs)
 +		return ERR_PTR(-EPERM);
  
+ 	ns = kobj_ns_grab_current(KOBJ_NS_TYPE_NET);
+ 	root = kernfs_mount_ns(fs_type, flags, sysfs_root, ns);
+ 	if (IS_ERR(root))
+ 		kobj_ns_drop(KOBJ_NS_TYPE_NET, ns);
+ 	return root;
+ }
+ 
+ /**
+  * kernfs_mount_ns - kernfs mount helper
+  * @fs_type: file_system_type of the fs being mounted
+  * @flags: mount flags specified for the mount
+  * @root: kernfs_root of the hierarchy being mounted
+  * @ns: optional namespace tag of the mount
+  *
+  * This is to be called from each kernfs user's file_system_type->mount()
+  * implementation, which should pass through the specified @fs_type and
+  * @flags, and specify the hierarchy and namespace tag to mount via @root
+  * and @ns, respectively.
+  *
+  * The return value can be passed to the vfs layer verbatim.
+  */
+ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
+ 			       struct kernfs_root *root, const void *ns)
+ {
+ 	struct super_block *sb;
+ 	struct sysfs_super_info *info;
+ 	int error;
+ 
  	info = kzalloc(sizeof(*info), GFP_KERNEL);
  	if (!info)
  		return ERR_PTR(-ENOMEM);
  
++<<<<<<< HEAD
 +	for (type = KOBJ_NS_TYPE_NONE; type < KOBJ_NS_TYPES; type++)
 +		info->ns[type] = kobj_ns_grab_current(type);
++=======
+ 	info->root = root;
+ 	info->ns = ns;
++>>>>>>> 4b93dc9b1c68 (sysfs, kernfs: prepare mount path for kernfs)
  
  	sb = sget(fs_type, sysfs_test_super, sysfs_set_super, flags, info);
  	if (IS_ERR(sb) || sb->s_fs_info != info)
@@@ -140,13 -166,31 +190,32 @@@
  }
  
  static void sysfs_kill_sb(struct super_block *sb)
+ {
+ 	kernfs_kill_sb(sb);
+ 	kobj_ns_drop(KOBJ_NS_TYPE_NET, (void *)kernfs_super_ns(sb));
+ }
+ 
+ /**
+  * kernfs_kill_sb - kill_sb for kernfs
+  * @sb: super_block being killed
+  *
+  * This can be used directly for file_system_type->kill_sb().  If a kernfs
+  * user needs extra cleanup, it can implement its own kill_sb() and call
+  * this function at the end.
+  */
+ void kernfs_kill_sb(struct super_block *sb)
  {
  	struct sysfs_super_info *info = sysfs_info(sb);
 -	struct sysfs_dirent *root_sd = sb->s_root->d_fsdata;
 -
 -	/*
 -	 * Remove the superblock from fs_supers/s_instances
 +	/* Remove the superblock from fs_supers/s_instances
  	 * so we can't find it, before freeing sysfs_super_info.
  	 */
  	kill_anon_super(sb);
++<<<<<<< HEAD
 +	free_sysfs_super_info(info);
++=======
+ 	kfree(info);
+ 	kernfs_put(root_sd);
++>>>>>>> 4b93dc9b1c68 (sysfs, kernfs: prepare mount path for kernfs)
  }
  
  static struct file_system_type sysfs_fs_type = {
@@@ -156,50 -200,29 +225,74 @@@
  	.fs_flags	= FS_USERNS_MOUNT,
  };
  
+ void __init kernfs_init(void)
+ {
+ 	sysfs_dir_cachep = kmem_cache_create("sysfs_dir_cache",
+ 					      sizeof(struct sysfs_dirent),
+ 					      0, SLAB_PANIC, NULL);
+ 	sysfs_inode_init();
+ }
+ 
  int __init sysfs_init(void)
  {
 -	int err;
 +	int err = -ENOMEM;
 +
++<<<<<<< HEAD
 +	sysfs_dir_cachep = kmem_cache_create("sysfs_dir_cache",
 +					      sizeof(struct sysfs_dirent),
 +					      0, 0, NULL);
 +	if (!sysfs_dir_cachep)
 +		goto out;
 +
 +	err = sysfs_inode_init();
 +	if (err)
 +		goto out_err;
  
 +	err = register_filesystem(&sysfs_fs_type);
 +	if (!err) {
 +		sysfs_mnt = kern_mount(&sysfs_fs_type);
 +		if (IS_ERR(sysfs_mnt)) {
 +			printk(KERN_ERR "sysfs: could not mount!\n");
 +			err = PTR_ERR(sysfs_mnt);
 +			sysfs_mnt = NULL;
 +			unregister_filesystem(&sysfs_fs_type);
 +			goto out_err;
 +		}
 +	} else
 +		goto out_err;
 +out:
 +	return err;
 +out_err:
 +	kmem_cache_destroy(sysfs_dir_cachep);
 +	sysfs_dir_cachep = NULL;
 +	goto out;
++=======
+ 	sysfs_root = kernfs_create_root(NULL);
+ 	if (IS_ERR(sysfs_root))
+ 		return PTR_ERR(sysfs_root);
+ 
+ 	sysfs_root_sd = sysfs_root->sd;
+ 
+ 	err = register_filesystem(&sysfs_fs_type);
+ 	if (err) {
+ 		kernfs_destroy_root(sysfs_root);
+ 		return err;
+ 	}
+ 
+ 	return 0;
++>>>>>>> 4b93dc9b1c68 (sysfs, kernfs: prepare mount path for kernfs)
 +}
 +
 +#undef sysfs_get
 +struct sysfs_dirent *sysfs_get(struct sysfs_dirent *sd)
 +{
 +	return __sysfs_get(sd);
 +}
 +EXPORT_SYMBOL_GPL(sysfs_get);
 +
 +#undef sysfs_put
 +void sysfs_put(struct sysfs_dirent *sd)
 +{
 +	__sysfs_put(sd);
  }
 +EXPORT_SYMBOL_GPL(sysfs_put);
diff --cc include/linux/kernfs.h
index 254b9e872b09,75fcbe5c9d65..000000000000
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@@ -7,6 -7,226 +7,231 @@@
  #ifndef __LINUX_KERNFS_H
  #define __LINUX_KERNFS_H
  
++<<<<<<< HEAD
 +struct sysfs_dirent;
 +
++=======
+ #include <linux/kernel.h>
+ #include <linux/err.h>
+ #include <linux/list.h>
+ #include <linux/mutex.h>
+ #include <linux/idr.h>
+ #include <linux/lockdep.h>
+ 
+ struct file;
+ struct iattr;
+ struct seq_file;
+ struct vm_area_struct;
+ struct super_block;
+ struct file_system_type;
+ 
+ struct sysfs_dirent;
+ 
+ struct kernfs_root {
+ 	/* published fields */
+ 	struct sysfs_dirent	*sd;
+ 
+ 	/* private fields, do not use outside kernfs proper */
+ 	struct ida		ino_ida;
+ };
+ 
+ struct sysfs_open_file {
+ 	/* published fields */
+ 	struct sysfs_dirent	*sd;
+ 	struct file		*file;
+ 
+ 	/* private fields, do not use outside kernfs proper */
+ 	struct mutex		mutex;
+ 	int			event;
+ 	struct list_head	list;
+ 
+ 	bool			mmapped;
+ 	const struct vm_operations_struct *vm_ops;
+ };
+ 
+ struct kernfs_ops {
+ 	/*
+ 	 * Read is handled by either seq_file or raw_read().
+ 	 *
+ 	 * If seq_show() is present, seq_file path is active.  Other seq
+ 	 * operations are optional and if not implemented, the behavior is
+ 	 * equivalent to single_open().  @sf->private points to the
+ 	 * associated sysfs_open_file.
+ 	 *
+ 	 * read() is bounced through kernel buffer and a read larger than
+ 	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
+ 	 */
+ 	int (*seq_show)(struct seq_file *sf, void *v);
+ 
+ 	void *(*seq_start)(struct seq_file *sf, loff_t *ppos);
+ 	void *(*seq_next)(struct seq_file *sf, void *v, loff_t *ppos);
+ 	void (*seq_stop)(struct seq_file *sf, void *v);
+ 
+ 	ssize_t (*read)(struct sysfs_open_file *of, char *buf, size_t bytes,
+ 			loff_t off);
+ 
+ 	/*
+ 	 * write() is bounced through kernel buffer and a write larger than
+ 	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
+ 	 */
+ 	ssize_t (*write)(struct sysfs_open_file *of, char *buf, size_t bytes,
+ 			 loff_t off);
+ 
+ 	int (*mmap)(struct sysfs_open_file *of, struct vm_area_struct *vma);
+ 
+ #ifdef CONFIG_DEBUG_LOCK_ALLOC
+ 	struct lock_class_key	lockdep_key;
+ #endif
+ };
+ 
+ #ifdef CONFIG_SYSFS
+ 
+ struct sysfs_dirent *kernfs_find_and_get_ns(struct sysfs_dirent *parent,
+ 					    const char *name, const void *ns);
+ void kernfs_get(struct sysfs_dirent *sd);
+ void kernfs_put(struct sysfs_dirent *sd);
+ 
+ struct kernfs_root *kernfs_create_root(void *priv);
+ void kernfs_destroy_root(struct kernfs_root *root);
+ 
+ struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
+ 					  const char *name, void *priv,
+ 					  const void *ns);
+ struct sysfs_dirent *kernfs_create_file_ns_key(struct sysfs_dirent *parent,
+ 					       const char *name,
+ 					       umode_t mode, loff_t size,
+ 					       const struct kernfs_ops *ops,
+ 					       void *priv, const void *ns,
+ 					       struct lock_class_key *key);
+ struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
+ 					const char *name,
+ 					struct sysfs_dirent *target);
+ void kernfs_remove(struct sysfs_dirent *sd);
+ int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
+ 			     const void *ns);
+ int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
+ 		     const char *new_name, const void *new_ns);
+ void kernfs_enable_ns(struct sysfs_dirent *sd);
+ int kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr);
+ void kernfs_notify(struct sysfs_dirent *sd);
+ 
+ const void *kernfs_super_ns(struct super_block *sb);
+ struct dentry *kernfs_mount_ns(struct file_system_type *fs_type, int flags,
+ 			       struct kernfs_root *root, const void *ns);
+ void kernfs_kill_sb(struct super_block *sb);
+ 
+ void kernfs_init(void);
+ 
+ #else	/* CONFIG_SYSFS */
+ 
+ static inline struct sysfs_dirent *
+ kernfs_find_and_get_ns(struct sysfs_dirent *parent, const char *name,
+ 		       const void *ns)
+ { return NULL; }
+ 
+ static inline void kernfs_get(struct sysfs_dirent *sd) { }
+ static inline void kernfs_put(struct sysfs_dirent *sd) { }
+ 
+ static inline struct kernfs_root *kernfs_create_root(void *priv)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline void kernfs_destroy_root(struct kernfs_root *root) { }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_dir_ns(struct sysfs_dirent *parent, const char *name, void *priv,
+ 		     const void *ns)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_file_ns_key(struct sysfs_dirent *parent, const char *name,
+ 			  umode_t mode, loff_t size,
+ 			  const struct kernfs_ops *ops, void *priv,
+ 			  const void *ns, struct lock_class_key *key)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_link(struct sysfs_dirent *parent, const char *name,
+ 		   struct sysfs_dirent *target)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline void kernfs_remove(struct sysfs_dirent *sd) { }
+ 
+ static inline int kernfs_remove_by_name_ns(struct sysfs_dirent *parent,
+ 					   const char *name, const void *ns)
+ { return -ENOSYS; }
+ 
+ static inline int kernfs_rename_ns(struct sysfs_dirent *sd,
+ 				   struct sysfs_dirent *new_parent,
+ 				   const char *new_name, const void *new_ns)
+ { return -ENOSYS; }
+ 
+ static inline void kernfs_enable_ns(struct sysfs_dirent *sd) { }
+ 
+ static inline int kernfs_setattr(struct sysfs_dirent *sd,
+ 				 const struct iattr *iattr)
+ { return -ENOSYS; }
+ 
+ static inline void kernfs_notify(struct sysfs_dirent *sd) { }
+ 
+ static inline const void *kernfs_super_ns(struct super_block *sb)
+ { return NULL; }
+ 
+ static inline struct dentry *
+ kernfs_mount_ns(struct file_system_type *fs_type, int flags,
+ 		struct kernfs_root *root, const void *ns)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline void kernfs_kill_sb(struct super_block *sb) { }
+ 
+ static inline void kernfs_init(void) { }
+ 
+ #endif	/* CONFIG_SYSFS */
+ 
+ static inline struct sysfs_dirent *
+ kernfs_find_and_get(struct sysfs_dirent *sd, const char *name)
+ {
+ 	return kernfs_find_and_get_ns(sd, name, NULL);
+ }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_dir(struct sysfs_dirent *parent, const char *name, void *priv)
+ {
+ 	return kernfs_create_dir_ns(parent, name, priv, NULL);
+ }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_file_ns(struct sysfs_dirent *parent, const char *name,
+ 		      umode_t mode, loff_t size, const struct kernfs_ops *ops,
+ 		      void *priv, const void *ns)
+ {
+ 	struct lock_class_key *key = NULL;
+ 
+ #ifdef CONFIG_DEBUG_LOCK_ALLOC
+ 	key = (struct lock_class_key *)&ops->lockdep_key;
+ #endif
+ 	return kernfs_create_file_ns_key(parent, name, mode, size, ops, priv,
+ 					 ns, key);
+ }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_file(struct sysfs_dirent *parent, const char *name, umode_t mode,
+ 		   loff_t size, const struct kernfs_ops *ops, void *priv)
+ {
+ 	return kernfs_create_file_ns(parent, name, mode, size, ops, priv, NULL);
+ }
+ 
+ static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,
+ 					const char *name)
+ {
+ 	return kernfs_remove_by_name_ns(parent, name, NULL);
+ }
+ 
+ static inline struct dentry *
+ kernfs_mount(struct file_system_type *fs_type, int flags,
+ 	     struct kernfs_root *root)
+ {
+ 	return kernfs_mount_ns(fs_type, flags, root, NULL);
+ }
+ 
++>>>>>>> 4b93dc9b1c68 (sysfs, kernfs: prepare mount path for kernfs)
  #endif	/* __LINUX_KERNFS_H */
* Unmerged path fs/kernfs/kernfs-internal.h
* Unmerged path fs/kernfs/inode.c
* Unmerged path fs/kernfs/kernfs-internal.h
* Unmerged path fs/namespace.c
* Unmerged path fs/sysfs/mount.c
* Unmerged path include/linux/kernfs.h
