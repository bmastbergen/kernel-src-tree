ipv6: Cleanup IPv6 tunnel receive path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tom Herbert <tom@herbertland.com>
commit 0d3c703a9d1723c7707e0680019ac8ff5922db42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0d3c703a.failed

Some basic changes to make IPv6 tunnel receive path look more like
IPv4 path:
  - Make ip6_tnl_rcv non-static so that GREv6 and others can call it
  - Make ip6_tnl_rcv look like ip_tunnel_rcv
  - Switch to gro_cells_receive
  - Make ip6_tnl_rcv non-static and export it

	Signed-off-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0d3c703a9d1723c7707e0680019ac8ff5922db42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_tunnel.c
diff --cc net/ipv6/ip6_tunnel.c
index 1f58811499c9,94ed065eff7f..000000000000
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@@ -751,84 -754,143 +752,150 @@@ int ip6_tnl_rcv_ctl(struct ip6_tnl *t
  }
  EXPORT_SYMBOL_GPL(ip6_tnl_rcv_ctl);
  
- /**
-  * ip6_tnl_rcv - decapsulate IPv6 packet and retransmit it locally
-  *   @skb: received socket buffer
-  *   @protocol: ethernet protocol ID
-  *   @dscp_ecn_decapsulate: the function to decapsulate DSCP code and ECN
-  *
-  * Return: 0
-  **/
- 
- static int ip6_tnl_rcv(struct sk_buff *skb, __u16 protocol,
- 		       __u8 ipproto,
- 		       int (*dscp_ecn_decapsulate)(const struct ip6_tnl *t,
- 						   const struct ipv6hdr *ipv6h,
- 						   struct sk_buff *skb))
+ static int __ip6_tnl_rcv(struct ip6_tnl *tunnel, struct sk_buff *skb,
+ 			 const struct tnl_ptk_info *tpi,
+ 			 struct metadata_dst *tun_dst,
+ 			 int (*dscp_ecn_decapsulate)(const struct ip6_tnl *t,
+ 						const struct ipv6hdr *ipv6h,
+ 						struct sk_buff *skb),
+ 			 bool log_ecn_err)
  {
- 	struct ip6_tnl *t;
+ 	struct pcpu_sw_netstats *tstats;
  	const struct ipv6hdr *ipv6h = ipv6_hdr(skb);
- 	u8 tproto;
  	int err;
  
- 	rcu_read_lock();
- 
- 	if ((t = ip6_tnl_lookup(dev_net(skb->dev), &ipv6h->saddr,
- 					&ipv6h->daddr)) != NULL) {
- 		struct pcpu_sw_netstats *tstats;
+ 	if ((!(tpi->flags & TUNNEL_CSUM) &&
+ 	     (tunnel->parms.i_flags & TUNNEL_CSUM)) ||
+ 	    ((tpi->flags & TUNNEL_CSUM) &&
+ 	     !(tunnel->parms.i_flags & TUNNEL_CSUM))) {
+ 		tunnel->dev->stats.rx_crc_errors++;
+ 		tunnel->dev->stats.rx_errors++;
+ 		goto drop;
+ 	}
  
- 		tproto = ACCESS_ONCE(t->parms.proto);
- 		if (tproto != ipproto && tproto != 0) {
- 			rcu_read_unlock();
- 			goto discard;
+ 	if (tunnel->parms.i_flags & TUNNEL_SEQ) {
+ 		if (!(tpi->flags & TUNNEL_SEQ) ||
+ 		    (tunnel->i_seqno &&
+ 		     (s32)(ntohl(tpi->seq) - tunnel->i_seqno) < 0)) {
+ 			tunnel->dev->stats.rx_fifo_errors++;
+ 			tunnel->dev->stats.rx_errors++;
+ 			goto drop;
  		}
+ 		tunnel->i_seqno = ntohl(tpi->seq) + 1;
+ 	}
  
- 		if (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {
- 			rcu_read_unlock();
- 			goto discard;
- 		}
+ 	skb->protocol = tpi->proto;
  
- 		if (!ip6_tnl_rcv_ctl(t, &ipv6h->daddr, &ipv6h->saddr)) {
- 			t->dev->stats.rx_dropped++;
- 			rcu_read_unlock();
- 			goto discard;
+ 	/* Warning: All skb pointers will be invalidated! */
+ 	if (tunnel->dev->type == ARPHRD_ETHER) {
+ 		if (!pskb_may_pull(skb, ETH_HLEN)) {
+ 			tunnel->dev->stats.rx_length_errors++;
+ 			tunnel->dev->stats.rx_errors++;
+ 			goto drop;
  		}
- 		skb->mac_header = skb->network_header;
- 		skb_reset_network_header(skb);
- 		skb->protocol = htons(protocol);
- 		memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
- 
- 		__skb_tunnel_rx(skb, t->dev, t->net);
- 
- 		err = dscp_ecn_decapsulate(t, ipv6h, skb);
- 		if (unlikely(err)) {
- 			if (log_ecn_error)
- 				net_info_ratelimited("non-ECT from %pI6 with dsfield=%#x\n",
- 						     &ipv6h->saddr,
- 						     ipv6_get_dsfield(ipv6h));
- 			if (err > 1) {
- 				++t->dev->stats.rx_frame_errors;
- 				++t->dev->stats.rx_errors;
- 				rcu_read_unlock();
- 				goto discard;
- 			}
+ 
+ 		ipv6h = ipv6_hdr(skb);
+ 		skb->protocol = eth_type_trans(skb, tunnel->dev);
+ 		skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);
+ 	} else {
+ 		skb->dev = tunnel->dev;
+ 	}
+ 
+ 	skb_reset_network_header(skb);
+ 	memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
+ 
+ 	__skb_tunnel_rx(skb, tunnel->dev, tunnel->net);
+ 
+ 	err = dscp_ecn_decapsulate(tunnel, ipv6h, skb);
+ 	if (unlikely(err)) {
+ 		if (log_ecn_err)
+ 			net_info_ratelimited("non-ECT from %pI6 with DS=%#x\n",
+ 					     &ipv6h->saddr,
+ 					     ipv6_get_dsfield(ipv6h));
+ 		if (err > 1) {
+ 			++tunnel->dev->stats.rx_frame_errors;
+ 			++tunnel->dev->stats.rx_errors;
+ 			goto drop;
  		}
+ 	}
  
- 		tstats = this_cpu_ptr(t->dev->tstats);
- 		u64_stats_update_begin(&tstats->syncp);
- 		tstats->rx_packets++;
- 		tstats->rx_bytes += skb->len;
- 		u64_stats_update_end(&tstats->syncp);
+ 	tstats = this_cpu_ptr(tunnel->dev->tstats);
+ 	u64_stats_update_begin(&tstats->syncp);
+ 	tstats->rx_packets++;
+ 	tstats->rx_bytes += skb->len;
+ 	u64_stats_update_end(&tstats->syncp);
  
- 		netif_rx(skb);
+ 	skb_scrub_packet(skb, !net_eq(tunnel->net, dev_net(tunnel->dev)));
  
- 		rcu_read_unlock();
- 		return 0;
+ 	gro_cells_receive(&tunnel->gro_cells, skb);
+ 	return 0;
+ 
+ drop:
+ 	kfree_skb(skb);
+ 	return 0;
+ }
+ 
+ int ip6_tnl_rcv(struct ip6_tnl *t, struct sk_buff *skb,
+ 		const struct tnl_ptk_info *tpi,
+ 		struct metadata_dst *tun_dst,
+ 		bool log_ecn_err)
+ {
+ 	return __ip6_tnl_rcv(t, skb, tpi, NULL, ip6ip6_dscp_ecn_decapsulate,
+ 			     log_ecn_err);
+ }
+ EXPORT_SYMBOL(ip6_tnl_rcv);
+ 
+ static const struct tnl_ptk_info tpi_v6 = {
+ 	/* no tunnel info required for ipxip6. */
+ 	.proto = htons(ETH_P_IPV6),
+ };
+ 
+ static const struct tnl_ptk_info tpi_v4 = {
+ 	/* no tunnel info required for ipxip6. */
+ 	.proto = htons(ETH_P_IP),
+ };
+ 
+ static int ipxip6_rcv(struct sk_buff *skb, u8 ipproto,
+ 		      const struct tnl_ptk_info *tpi,
+ 		      int (*dscp_ecn_decapsulate)(const struct ip6_tnl *t,
+ 						  const struct ipv6hdr *ipv6h,
+ 						  struct sk_buff *skb))
+ {
+ 	struct ip6_tnl *t;
+ 	const struct ipv6hdr *ipv6h = ipv6_hdr(skb);
+ 	int ret = -1;
+ 
+ 	rcu_read_lock();
++<<<<<<< HEAD
++
++	if ((t = ip6_tnl_lookup(dev_net(skb->dev), &ipv6h->saddr,
++					&ipv6h->daddr)) != NULL) {
++		struct pcpu_sw_netstats *tstats;
++=======
+ 	t = ip6_tnl_lookup(dev_net(skb->dev), &ipv6h->saddr, &ipv6h->daddr);
+ 
+ 	if (t) {
+ 		u8 tproto = ACCESS_ONCE(t->parms.proto);
++>>>>>>> 0d3c703a9d17 (ipv6: Cleanup IPv6 tunnel receive path)
+ 
+ 		if (tproto != ipproto && tproto != 0)
+ 			goto drop;
+ 		if (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))
+ 			goto drop;
+ 		if (!ip6_tnl_rcv_ctl(t, &ipv6h->daddr, &ipv6h->saddr))
+ 			goto drop;
+ 		if (iptunnel_pull_header(skb, 0, tpi->proto, false))
+ 			goto drop;
+ 		ret = __ip6_tnl_rcv(t, skb, tpi, NULL, dscp_ecn_decapsulate,
+ 				    log_ecn_error);
  	}
+ 
  	rcu_read_unlock();
- 	return 1;
  
- discard:
+ 	return ret;
+ 
+ drop:
+ 	rcu_read_unlock();
  	kfree_skb(skb);
  	return 0;
  }
diff --git a/include/net/ip6_tunnel.h b/include/net/ip6_tunnel.h
index a1b9a6553a41..c2e3df670327 100644
--- a/include/net/ip6_tunnel.h
+++ b/include/net/ip6_tunnel.h
@@ -42,6 +42,7 @@ struct ip6_tnl {
 	struct __ip6_tnl_parm parms;	/* tunnel configuration parameters */
 	struct flowi fl;	/* flowi template for xmit */
 	struct dst_cache dst_cache;	/* cached dst */
+	struct gro_cells gro_cells;
 
 	int err_count;
 	unsigned long err_time;
@@ -63,6 +64,9 @@ struct ipv6_tlv_tnl_enc_lim {
 
 int ip6_tnl_rcv_ctl(struct ip6_tnl *t, const struct in6_addr *laddr,
 		const struct in6_addr *raddr);
+int ip6_tnl_rcv(struct ip6_tnl *tunnel, struct sk_buff *skb,
+		const struct tnl_ptk_info *tpi, struct metadata_dst *tun_dst,
+		bool log_ecn_error);
 int ip6_tnl_xmit_ctl(struct ip6_tnl *t, const struct in6_addr *laddr,
 		     const struct in6_addr *raddr);
 __u16 ip6_tnl_parse_tlv_enc_lim(struct sk_buff *skb, __u8 *raw);
* Unmerged path net/ipv6/ip6_tunnel.c
