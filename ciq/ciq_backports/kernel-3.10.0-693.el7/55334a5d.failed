net_sched: act: refuse to remove bound action outside

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: act: refuse to remove bound action outside (Ivan Vecera) [1428588]
Rebuild_FUZZ: 96.08%
commit-author WANG Cong <xiyou.wangcong@gmail.com>
commit 55334a5db5cd32b207ac697cec3ec8e078f345d4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/55334a5d.failed

When an action is bonnd to a filter, there is no point to
remove it outside. Currently we just silently decrease the refcnt,
we should reject this explicitly with EPERM.

	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Cc: David S. Miller <davem@davemloft.net>
	Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 55334a5db5cd32b207ac697cec3ec8e078f345d4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_api.c
diff --cc net/sched/act_api.c
index 34e255487d7a,27e4c531ade1..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -117,12 -117,15 +119,13 @@@ nla_put_failure
  	goto done;
  }
  
 -static int tcf_del_walker(struct sk_buff *skb, struct tc_action *a)
 +static int tcf_del_walker(struct sk_buff *skb, struct tc_action *a,
 +			  struct tcf_hashinfo *hinfo)
  {
 -	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 -	struct hlist_head *head;
 -	struct hlist_node *n;
 -	struct tcf_common *p;
 +	struct tcf_common *p, *s_p;
  	struct nlattr *nest;
  	int i = 0, n_i = 0;
+ 	int ret = -EINVAL;
  
  	nest = nla_nest_start(skb, a->order);
  	if (nest == NULL)
@@@ -130,14 -133,15 +133,26 @@@
  	if (nla_put_string(skb, TCA_KIND, a->ops->kind))
  		goto nla_put_failure;
  	for (i = 0; i < (hinfo->hmask + 1); i++) {
++<<<<<<< HEAD
 +		p = hinfo->htab[tcf_hash(i, hinfo->hmask)];
 +
 +		while (p != NULL) {
 +			s_p = p->tcfc_next;
 +			if (ACT_P_DELETED == tcf_hash_release(p, 0, hinfo))
 +				module_put(a->ops->owner);
 +			n_i++;
 +			p = s_p;
++=======
+ 		head = &hinfo->htab[tcf_hash(i, hinfo->hmask)];
+ 		hlist_for_each_entry_safe(p, n, head, tcfc_head) {
+ 			a->priv = p;
+ 			ret = tcf_hash_release(a, 0);
+ 			if (ret == ACT_P_DELETED) {
+ 				module_put(a->ops->owner);
+ 				n_i++;
+ 			} else if (ret < 0)
+ 				goto nla_put_failure;
++>>>>>>> 55334a5db5cd (net_sched: act: refuse to remove bound action outside)
  		}
  	}
  	if (nla_put_u32(skb, TCA_FCNT, n_i))
@@@ -377,13 -406,17 +392,21 @@@ exec_done
  }
  EXPORT_SYMBOL(tcf_action_exec);
  
- void tcf_action_destroy(struct list_head *actions, int bind)
+ int tcf_action_destroy(struct list_head *actions, int bind)
  {
  	struct tc_action *a, *tmp;
+ 	int ret = 0;
  
  	list_for_each_entry_safe(a, tmp, actions, list) {
++<<<<<<< HEAD
 +		if (a->ops->cleanup(a, bind) == ACT_P_DELETED)
++=======
+ 		ret = tcf_hash_release(a, bind);
+ 		if (ret == ACT_P_DELETED)
++>>>>>>> 55334a5db5cd (net_sched: act: refuse to remove bound action outside)
  			module_put(a->ops->owner);
+ 		else if (ret < 0)
+ 			return ret;
  		list_del(&a->list);
  		kfree(a);
  	}
diff --git a/include/net/act_api.h b/include/net/act_api.h
index 11aac9abd0ca..ac759f66f3fd 100644
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@ -92,7 +92,7 @@ void tcf_hash_insert(struct tcf_common *p, struct tcf_hashinfo *hinfo);
 
 int tcf_register_action(struct tc_action_ops *a);
 int tcf_unregister_action(struct tc_action_ops *a);
-void tcf_action_destroy(struct list_head *actions, int bind);
+int tcf_action_destroy(struct list_head *actions, int bind);
 int tcf_action_exec(struct sk_buff *skb, const struct list_head *actions,
 		    struct tcf_result *res);
 int tcf_action_init(struct net *net, struct nlattr *nla,
* Unmerged path net/sched/act_api.c
