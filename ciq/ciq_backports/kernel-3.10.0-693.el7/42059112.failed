selinux: Minor cleanups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 420591128cb206201dc444c2d42fb6f299b2ecd0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/42059112.failed

Fix the comment for function __inode_security_revalidate, which returns
an integer.

Use the LABEL_* constants consistently for isec->initialized.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 420591128cb206201dc444c2d42fb6f299b2ecd0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
diff --cc security/selinux/hooks.c
index 85f0076df17e,1c0721708ccc..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -231,6 -243,79 +232,82 @@@ static int inode_alloc_security(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int inode_doinit_with_dentry(struct inode *inode, struct dentry *opt_dentry);
+ 
+ /*
+  * Try reloading inode security labels that have been marked as invalid.  The
+  * @may_sleep parameter indicates when sleeping and thus reloading labels is
+  * allowed; when set to false, returns -ECHILD when the label is
+  * invalid.  The @opt_dentry parameter should be set to a dentry of the inode;
+  * when no dentry is available, set it to NULL instead.
+  */
+ static int __inode_security_revalidate(struct inode *inode,
+ 				       struct dentry *opt_dentry,
+ 				       bool may_sleep)
+ {
+ 	struct inode_security_struct *isec = inode->i_security;
+ 
+ 	might_sleep_if(may_sleep);
+ 
+ 	if (ss_initialized && isec->initialized != LABEL_INITIALIZED) {
+ 		if (!may_sleep)
+ 			return -ECHILD;
+ 
+ 		/*
+ 		 * Try reloading the inode security label.  This will fail if
+ 		 * @opt_dentry is NULL and no dentry for this inode can be
+ 		 * found; in that case, continue using the old label.
+ 		 */
+ 		inode_doinit_with_dentry(inode, opt_dentry);
+ 	}
+ 	return 0;
+ }
+ 
+ static struct inode_security_struct *inode_security_novalidate(struct inode *inode)
+ {
+ 	return inode->i_security;
+ }
+ 
+ static struct inode_security_struct *inode_security_rcu(struct inode *inode, bool rcu)
+ {
+ 	int error;
+ 
+ 	error = __inode_security_revalidate(inode, NULL, !rcu);
+ 	if (error)
+ 		return ERR_PTR(error);
+ 	return inode->i_security;
+ }
+ 
+ /*
+  * Get the security label of an inode.
+  */
+ static struct inode_security_struct *inode_security(struct inode *inode)
+ {
+ 	__inode_security_revalidate(inode, NULL, true);
+ 	return inode->i_security;
+ }
+ 
+ static struct inode_security_struct *backing_inode_security_novalidate(struct dentry *dentry)
+ {
+ 	struct inode *inode = d_backing_inode(dentry);
+ 
+ 	return inode->i_security;
+ }
+ 
+ /*
+  * Get the security label of a dentry's backing inode.
+  */
+ static struct inode_security_struct *backing_inode_security(struct dentry *dentry)
+ {
+ 	struct inode *inode = d_backing_inode(dentry);
+ 
+ 	__inode_security_revalidate(inode, dentry, true);
+ 	return inode->i_security;
+ }
+ 
++>>>>>>> 420591128cb2 (selinux: Minor cleanups)
  static void inode_free_rcu(struct rcu_head *head)
  {
  	struct inode_security_struct *isec;
* Unmerged path security/selinux/hooks.c
diff --git a/security/selinux/selinuxfs.c b/security/selinux/selinuxfs.c
index ff427733c290..e89edc244e37 100644
--- a/security/selinux/selinuxfs.c
+++ b/security/selinux/selinuxfs.c
@@ -1268,7 +1268,7 @@ static int sel_make_bools(void)
 			goto out;
 
 		isec->sid = sid;
-		isec->initialized = 1;
+		isec->initialized = LABEL_INITIALIZED;
 		inode->i_fop = &sel_bool_ops;
 		inode->i_ino = i|SEL_BOOL_INO_OFFSET;
 		d_add(dentry, inode);
@@ -1830,7 +1830,7 @@ static int sel_fill_super(struct super_block *sb, void *data, int silent)
 	isec = (struct inode_security_struct *)inode->i_security;
 	isec->sid = SECINITSID_DEVNULL;
 	isec->sclass = SECCLASS_CHR_FILE;
-	isec->initialized = 1;
+	isec->initialized = LABEL_INITIALIZED;
 
 	init_special_inode(inode, S_IFCHR | S_IRUGO | S_IWUGO, MKDEV(MEM_MAJOR, 3));
 	d_add(dentry, inode);
