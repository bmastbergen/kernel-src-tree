i40e: don't warn every time we clear an Rx timestamp register

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit e6e3fc2bd3ee03117e1ce388c897fc3b2da97d65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e6e3fc2b.failed

The intent of this message was to indicate to a user that we might have
missed a timestamp event for a valid packet. The original method of
detecting the missed events relied on waiting until all 4 registers were
filled.

A recent commit d55458c0cd7a5 ("i40e: replace PTP Rx timestamp hang
logic") replaced this logic with much better detection
scheme that could detect a stalled Rx timestamp register even when other
registers were still functional.

The new logic means that a message will be displayed almost as soon as
a timestamp for a dropped frame occurs. This new logic highlights that
the hardware will attempt timestamp for frames which it later decides to
drop. The most prominent example is when a multicast PTP frame is
received on a multicast address that we are not subscribed to.

Because the hardware initiates the Rx timestamp as soon as possible, it
will latch an RXTIME register, but then drop the packet.

This results in users being confused by the message as they are not
expecting to see dropped timestamp messages unless their application
also indicates that timestamps were missing.

Resolve this by reducing the severity and frequency of the displayed
message. We now only print the message if 3 or 4 of the RXTIME registers
are stalled and get cleared within the same watchdog event. This ensures
that the common case does not constantly display the message.
Additionally, since the message is likely not as meaningful to most
users, reduce the message to a dev_dbg instead of a dev_warn.

Users can still get a count of the number of timestamps dropped by
reading the ethtool statistics value, if necessary.

Change-ID: I35494442226a444c418dfb4f91a3070d06c8435c
	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit e6e3fc2bd3ee03117e1ce388c897fc3b2da97d65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_ptp.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_ptp.c
index b83754c73a1f,2caee35528fa..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_ptp.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ptp.c
@@@ -239,10 -280,7 +239,14 @@@ void i40e_ptp_rx_hang(struct i40e_vsi *
  {
  	struct i40e_pf *pf = vsi->back;
  	struct i40e_hw *hw = &pf->hw;
++<<<<<<< HEAD
 +	struct i40e_ring *rx_ring;
 +	unsigned long rx_event;
 +	u32 prttsyn_stat;
 +	int n;
++=======
+ 	unsigned int i, cleared = 0;
++>>>>>>> e6e3fc2bd3ee (i40e: don't warn every time we clear an Rx timestamp register)
  
  	/* Since we cannot turn off the Rx timestamp logic if the device is
  	 * configured for Tx timestamping, we check if Rx timestamping is
@@@ -252,42 -290,41 +256,69 @@@
  	if (!(pf->flags & I40E_FLAG_PTP) || !pf->ptp_rx)
  		return;
  
 -	spin_lock_bh(&pf->ptp_rx_lock);
 -
 -	/* Update current latch times for Rx events */
 -	i40e_ptp_get_rx_events(pf);
 +	prttsyn_stat = rd32(hw, I40E_PRTTSYN_STAT_1);
  
 -	/* Check all the currently latched Rx events and see whether they have
 -	 * been latched for over a second. It is assumed that any timestamp
 -	 * should have been cleared within this time, or else it was captured
 -	 * for a dropped frame that the driver never received. Thus, we will
 -	 * clear any timestamp that has been latched for over 1 second.
 +	/* Unless all four receive timestamp registers are latched, we are not
 +	 * concerned about a possible PTP Rx hang, so just update the timeout
 +	 * counter and exit.
  	 */
++<<<<<<< HEAD
 +	if (!(prttsyn_stat & ((I40E_PRTTSYN_STAT_1_RXT0_MASK <<
 +			       I40E_PRTTSYN_STAT_1_RXT0_SHIFT) |
 +			      (I40E_PRTTSYN_STAT_1_RXT1_MASK <<
 +			       I40E_PRTTSYN_STAT_1_RXT1_SHIFT) |
 +			      (I40E_PRTTSYN_STAT_1_RXT2_MASK <<
 +			       I40E_PRTTSYN_STAT_1_RXT2_SHIFT) |
 +			      (I40E_PRTTSYN_STAT_1_RXT3_MASK <<
 +			       I40E_PRTTSYN_STAT_1_RXT3_SHIFT)))) {
 +		pf->last_rx_ptp_check = jiffies;
 +		return;
 +	}
 +
 +	/* Determine the most recent watchdog or rx_timestamp event. */
 +	rx_event = pf->last_rx_ptp_check;
 +	for (n = 0; n < vsi->num_queue_pairs; n++) {
 +		rx_ring = vsi->rx_rings[n];
 +		if (time_after(rx_ring->last_rx_timestamp, rx_event))
 +			rx_event = rx_ring->last_rx_timestamp;
 +	}
 +
 +	/* Only need to read the high RXSTMP register to clear the lock */
 +	if (time_is_before_jiffies(rx_event + 5 * HZ)) {
 +		rd32(hw, I40E_PRTTSYN_RXTIME_H(0));
 +		rd32(hw, I40E_PRTTSYN_RXTIME_H(1));
 +		rd32(hw, I40E_PRTTSYN_RXTIME_H(2));
 +		rd32(hw, I40E_PRTTSYN_RXTIME_H(3));
 +		pf->last_rx_ptp_check = jiffies;
 +		pf->rx_hwtstamp_cleared++;
 +		WARN_ONCE(1, "Detected Rx timestamp register hang\n");
 +	}
++=======
+ 	for (i = 0; i < 4; i++) {
+ 		if ((pf->latch_event_flags & BIT(i)) &&
+ 		    time_is_before_jiffies(pf->latch_events[i] + HZ)) {
+ 			rd32(hw, I40E_PRTTSYN_RXTIME_H(i));
+ 			pf->latch_event_flags &= ~BIT(i);
+ 			cleared++;
+ 		}
+ 	}
+ 
+ 	spin_unlock_bh(&pf->ptp_rx_lock);
+ 
+ 	/* Log a warning if more than 2 timestamps got dropped in the same
+ 	 * check. We don't want to warn about all drops because it can occur
+ 	 * in normal scenarios such as PTP frames on multicast addresses we
+ 	 * aren't listening to. However, administrator should know if this is
+ 	 * the reason packets aren't receiving timestamps.
+ 	 */
+ 	if (cleared > 2)
+ 		dev_dbg(&pf->pdev->dev,
+ 			"Dropped %d missed RXTIME timestamp events\n",
+ 			cleared);
+ 
+ 	/* Finally, update the rx_hwtstamp_cleared counter */
+ 	pf->rx_hwtstamp_cleared += cleared;
++>>>>>>> e6e3fc2bd3ee (i40e: don't warn every time we clear an Rx timestamp register)
  }
  
  /**
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_ptp.c
