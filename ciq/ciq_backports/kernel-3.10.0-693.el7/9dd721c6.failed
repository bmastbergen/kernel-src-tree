x86, kaslr: fix module lock ordering problem

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] kaslr: fix module lock ordering problem (Baoquan He) [1290840]
Rebuild_FUZZ: 93.98%
commit-author Kees Cook <keescook@chromium.org>
commit 9dd721c6dbfc310f94306902611f86dda87a45fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9dd721c6.failed

There was a potential lock ordering problem with the module kASLR patch
("x86, kaslr: randomize module base load address"). This patch removes
the usage of the module_mutex and creates a new mutex to protect the
module base address offset value.

Chain exists of:
  text_mutex --> kprobe_insn_slots.mutex --> module_mutex

[    0.515561]  Possible unsafe locking scenario:
[    0.515561]
[    0.515561]        CPU0                    CPU1
[    0.515561]        ----                    ----
[    0.515561]   lock(module_mutex);
[    0.515561]                                lock(kprobe_insn_slots.mutex);
[    0.515561]                                lock(module_mutex);
[    0.515561]   lock(text_mutex);
[    0.515561]
[    0.515561]  *** DEADLOCK ***

	Reported-by: Fengguang Wu <fengguang.wu@intel.com>
	Signed-off-by: Andy Honig <ahonig@google.com>
	Signed-off-by: Kees Cook <keescook@chromium.org>
	Reviewed-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
(cherry picked from commit 9dd721c6dbfc310f94306902611f86dda87a45fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/module.c
diff --cc arch/x86/kernel/module.c
index 7c1efc437dc0,e69f9882bf95..000000000000
--- a/arch/x86/kernel/module.c
+++ b/arch/x86/kernel/module.c
@@@ -43,6 -44,43 +43,46 @@@ do {							
  } while (0)
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_RANDOMIZE_BASE
+ static unsigned long module_load_offset;
+ static int randomize_modules = 1;
+ 
+ /* Mutex protects the module_load_offset. */
+ static DEFINE_MUTEX(module_kaslr_mutex);
+ 
+ static int __init parse_nokaslr(char *p)
+ {
+ 	randomize_modules = 0;
+ 	return 0;
+ }
+ early_param("nokaslr", parse_nokaslr);
+ 
+ static unsigned long int get_module_load_offset(void)
+ {
+ 	if (randomize_modules) {
+ 		mutex_lock(&module_kaslr_mutex);
+ 		/*
+ 		 * Calculate the module_load_offset the first time this
+ 		 * code is called. Once calculated it stays the same until
+ 		 * reboot.
+ 		 */
+ 		if (module_load_offset == 0)
+ 			module_load_offset =
+ 				(get_random_int() % 1024 + 1) * PAGE_SIZE;
+ 		mutex_unlock(&module_kaslr_mutex);
+ 	}
+ 	return module_load_offset;
+ }
+ #else
+ static unsigned long int get_module_load_offset(void)
+ {
+ 	return 0;
+ }
+ #endif
+ 
++>>>>>>> 9dd721c6dbfc (x86, kaslr: fix module lock ordering problem)
  void *module_alloc(unsigned long size)
  {
  	if (PAGE_ALIGN(size) > MODULES_LEN)
* Unmerged path arch/x86/kernel/module.c
