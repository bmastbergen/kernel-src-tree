HID: wacom - enable LED support for Wireless Intuos5/Pro

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom - enable LED support for Wireless Intuos5/Pro (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.33%
commit-author Ping Cheng <pinglinux@gmail.com>
commit 912ca216b548e0fe399f300b4511b0277fb874e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/912ca216.failed

And associate all LED/OLED to PAD device

	Signed-off-by: Ping Cheng <pingc@wacom.com>
	Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 912ca216b548e0fe399f300b4511b0277fb874e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,9e4e1886828d..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -13,48 -13,11 +13,49 @@@
  
  #include "wacom_wac.h"
  #include "wacom.h"
 -#include <linux/hid.h>
  
 +/* defines to get HID report descriptor */
 +#define HID_DEVICET_HID		(USB_TYPE_CLASS | 0x01)
 +#define HID_DEVICET_REPORT	(USB_TYPE_CLASS | 0x02)
 +#define HID_USAGE_UNDEFINED		0x00
 +#define HID_USAGE_PAGE			0x05
 +#define HID_USAGE_PAGE_DIGITIZER	0x0d
 +#define HID_USAGE_PAGE_DESKTOP		0x01
 +#define HID_USAGE			0x09
 +#define HID_USAGE_X			0x30
 +#define HID_USAGE_Y			0x31
 +#define HID_USAGE_X_TILT		0x3d
 +#define HID_USAGE_Y_TILT		0x3e
 +#define HID_USAGE_FINGER		0x22
 +#define HID_USAGE_STYLUS		0x20
 +#define HID_USAGE_CONTACTMAX		0x55
 +#define HID_COLLECTION			0xa1
 +#define HID_COLLECTION_LOGICAL		0x02
 +#define HID_COLLECTION_END		0xc0
 +
 +enum {
 +	WCM_UNDEFINED = 0,
 +	WCM_DESKTOP,
 +	WCM_DIGITIZER,
 +};
 +
 +struct hid_descriptor {
 +	struct usb_descriptor_header header;
 +	__le16   bcdHID;
 +	u8       bCountryCode;
 +	u8       bNumDescriptors;
 +	u8       bDescriptorType;
 +	__le16   wDescriptorLength;
 +} __attribute__ ((packed));
 +
 +/* defines to get/set USB message */
 +#define USB_REQ_GET_REPORT	0x01
 +#define USB_REQ_SET_REPORT	0x09
 +
 +#define WAC_HID_FEATURE_REPORT	0x03
  #define WAC_MSG_RETRIES		5
  
+ #define WAC_CMD_WL_LED_CONTROL	0x03
  #define WAC_CMD_LED_CONTROL	0x20
  #define WAC_CMD_ICON_START	0x21
  #define WAC_CMD_ICON_XFER	0x23
@@@ -771,8 -537,8 +785,13 @@@ static int wacom_led_control(struct wac
  		buf[4] = wacom->led.img_lum;
  	}
  
++<<<<<<< HEAD
 +	retval = wacom_set_report(wacom->intf, 0x03, WAC_CMD_LED_CONTROL,
 +				  buf, 9, WAC_CMD_RETRIES);
++=======
+ 	retval = wacom_set_report(wacom->hdev, HID_FEATURE_REPORT, buf, buf_size,
+ 				  WAC_CMD_RETRIES);
++>>>>>>> 912ca216b548 (HID: wacom - enable LED support for Wireless Intuos5/Pro)
  	kfree(buf);
  
  	return retval;
@@@ -1127,11 -983,79 +1146,50 @@@ static void wacom_destroy_battery(struc
  	}
  }
  
 -static ssize_t wacom_show_speed(struct device *dev,
 -				struct device_attribute
 -				*attr, char *buf)
 -{
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -
 -	return snprintf(buf, PAGE_SIZE, "%i\n", wacom->wacom_wac.bt_high_speed);
 -}
 -
 -static ssize_t wacom_store_speed(struct device *dev,
 -				struct device_attribute *attr,
 -				const char *buf, size_t count)
 -{
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	u8 new_speed;
 -
 -	if (kstrtou8(buf, 0, &new_speed))
 -		return -EINVAL;
 -
 -	if (new_speed != 0 && new_speed != 1)
 -		return -EINVAL;
 -
 -	wacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);
 -
 -	return count;
 -}
 -
 -static DEVICE_ATTR(speed, DEV_ATTR_RW_PERM,
 -		wacom_show_speed, wacom_store_speed);
 -
 -static struct input_dev *wacom_allocate_input(struct wacom *wacom)
 +static int wacom_register_input(struct wacom *wacom)
  {
  	struct input_dev *input_dev;
++<<<<<<< HEAD
 +	struct usb_interface *intf = wacom->intf;
 +	struct usb_device *dev = interface_to_usbdev(intf);
++=======
+ 	struct hid_device *hdev = wacom->hdev;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	input_dev = input_allocate_device();
+ 	if (!input_dev)
+ 		return NULL;
+ 
+ 	input_dev->name = wacom_wac->name;
+ 	input_dev->phys = hdev->phys;
+ 	input_dev->dev.parent = &hdev->dev;
+ 	input_dev->open = wacom_open;
+ 	input_dev->close = wacom_close;
+ 	input_dev->uniq = hdev->uniq;
+ 	input_dev->id.bustype = hdev->bus;
+ 	input_dev->id.vendor  = hdev->vendor;
+ 	input_dev->id.product = hdev->product;
+ 	input_dev->id.version = hdev->version;
+ 	input_set_drvdata(input_dev, wacom);
+ 
+ 	return input_dev;
+ }
+ 
+ static void wacom_unregister_inputs(struct wacom *wacom)
+ {
+ 	if (wacom->wacom_wac.input)
+ 		input_unregister_device(wacom->wacom_wac.input);
+ 	if (wacom->wacom_wac.pad_input)
+ 		input_unregister_device(wacom->wacom_wac.pad_input);
+ 	wacom->wacom_wac.input = NULL;
+ 	wacom->wacom_wac.pad_input = NULL;
+ 	wacom_destroy_leds(wacom);
+ }
+ 
+ static int wacom_register_inputs(struct wacom *wacom)
+ {
+ 	struct input_dev *input_dev, *pad_input_dev;
++>>>>>>> 912ca216b548 (HID: wacom - enable LED support for Wireless Intuos5/Pro)
  	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
  	int error;
  
@@@ -1157,12 -1078,38 +1215,39 @@@
  	if (error)
  		goto fail2;
  
++<<<<<<< HEAD
 +	return 0;
 +
++=======
+ 	error = wacom_setup_pad_input_capabilities(pad_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no pad in use on this interface */
+ 		input_free_device(pad_input_dev);
+ 		wacom_wac->pad_input = NULL;
+ 		pad_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(pad_input_dev);
+ 		if (error)
+ 			goto fail3;
+ 
+ 		error = wacom_initialize_leds(wacom);
+ 		if (error)
+ 			goto fail4;
+ 	}
+ 
+ 	return 0;
+ 
+ fail4:
+ 	input_unregister_device(pad_input_dev);
+ 	pad_input_dev = NULL;
+ fail3:
+ 	input_unregister_device(input_dev);
+ 	input_dev = NULL;
++>>>>>>> 912ca216b548 (HID: wacom - enable LED support for Wireless Intuos5/Pro)
  fail2:
 +	input_free_device(input_dev);
  	wacom_wac->input = NULL;
 -	wacom_wac->pad_input = NULL;
  fail1:
 -	if (input_dev)
 -		input_free_device(input_dev);
 -	if (pad_input_dev)
 -		input_free_device(pad_input_dev);
  	return error;
  }
  
@@@ -1224,7 -1169,12 +1309,16 @@@ static void wacom_wireless_work(struct 
  		wacom_wac1->features.device_type = BTN_TOOL_PEN;
  		snprintf(wacom_wac1->name, WACOM_NAME_MAX, "%s (WL) Pen",
  			 wacom_wac1->features.name);
++<<<<<<< HEAD
 +		error = wacom_register_input(wacom1);
++=======
+ 		snprintf(wacom_wac1->pad_name, WACOM_NAME_MAX, "%s (WL) Pad",
+ 			 wacom_wac1->features.name);
+ 		wacom_wac1->shared->touch_max = wacom_wac1->features.touch_max;
+ 		wacom_wac1->shared->type = wacom_wac1->features.type;
+ 		wacom_wac1->pid = wacom_wac->pid;
+ 		error = wacom_register_inputs(wacom1);
++>>>>>>> 912ca216b548 (HID: wacom - enable LED support for Wireless Intuos5/Pro)
  		if (error)
  			goto fail;
  
@@@ -1241,9 -1192,16 +1335,16 @@@
  			else
  				snprintf(wacom_wac2->name, WACOM_NAME_MAX,
  					 "%s (WL) Pad",wacom_wac2->features.name);
++<<<<<<< HEAD
 +			error = wacom_register_input(wacom2);
++=======
+ 			snprintf(wacom_wac2->pad_name, WACOM_NAME_MAX,
+ 				 "%s (WL) Pad", wacom_wac2->features.name);
+ 			wacom_wac2->pid = wacom_wac->pid;
+ 			error = wacom_register_inputs(wacom2);
++>>>>>>> 912ca216b548 (HID: wacom - enable LED support for Wireless Intuos5/Pro)
  			if (error)
  				goto fail;
 -
 -			if (wacom_wac1->features.type == INTUOSHT &&
 -			    wacom_wac1->features.touch_max)
 -				wacom_wac->shared->touch_input = wacom_wac2->input;
  		}
  
  		error = wacom_initialize_battery(wacom);
@@@ -1386,69 -1372,76 +1487,108 @@@ static int wacom_probe(struct usb_inter
  		else
  			strlcat(wacom_wac->name, " Pad", WACOM_NAME_MAX);
  
++<<<<<<< HEAD
 +		other_dev = wacom_get_sibling(dev, features->oVid, features->oPid);
 +		if (other_dev == NULL || wacom_get_usbdev_data(other_dev) == NULL)
 +			other_dev = dev;
 +		error = wacom_add_shared_data(wacom_wac, other_dev);
++=======
+ 		error = wacom_add_shared_data(hdev);
  		if (error)
- 			goto fail3;
+ 			goto fail1;
  	}
  
+ 	if (!(features->quirks & WACOM_QUIRK_MONITOR) &&
+ 	     (features->quirks & WACOM_QUIRK_BATTERY)) {
+ 		error = wacom_initialize_battery(wacom);
++>>>>>>> 912ca216b548 (HID: wacom - enable LED support for Wireless Intuos5/Pro)
+ 		if (error)
+ 			goto fail2;
+ 	}
+ 
++<<<<<<< HEAD
 +	usb_fill_int_urb(wacom->irq, dev,
 +			 usb_rcvintpipe(dev, endpoint->bEndpointAddress),
 +			 wacom_wac->data, features->pktlen,
 +			 wacom_sys_irq, wacom, endpoint->bInterval);
 +	wacom->irq->transfer_dma = wacom->data_dma;
 +	wacom->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
++=======
+ 	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
+ 		error = wacom_register_inputs(wacom);
+ 		if (error)
+ 			goto fail3;
+ 	}
++>>>>>>> 912ca216b548 (HID: wacom - enable LED support for Wireless Intuos5/Pro)
 +
 +	error = wacom_initialize_leds(wacom);
 +	if (error)
 +		goto fail4;
  
 -	if (hdev->bus == BUS_BLUETOOTH) {
 -		error = device_create_file(&hdev->dev, &dev_attr_speed);
 +	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
 +		error = wacom_register_input(wacom);
  		if (error)
 -			hid_warn(hdev,
 -				 "can't create sysfs speed attribute err: %d\n",
 -				 error);
 +			goto fail5;
  	}
  
  	/* Note that if query fails it is not a hard failure */
 -	wacom_query_tablet_data(hdev, features);
 +	wacom_query_tablet_data(intf, features);
  
++<<<<<<< HEAD
 +	usb_set_intfdata(intf, wacom);
++=======
+ 	/* Regular HID work starts now */
+ 	error = hid_hw_start(hdev, HID_CONNECT_HIDRAW);
+ 	if (error) {
+ 		hid_err(hdev, "hw start failed\n");
+ 		goto fail4;
+ 	}
++>>>>>>> 912ca216b548 (HID: wacom - enable LED support for Wireless Intuos5/Pro)
  
 -	if (features->quirks & WACOM_QUIRK_MONITOR)
 -		error = hid_hw_open(hdev);
 -
 -	if (wacom_wac->features.type == INTUOSHT && wacom_wac->features.touch_max) {
 -		if (wacom_wac->features.device_type == BTN_TOOL_FINGER)
 -			wacom_wac->shared->touch_input = wacom_wac->input;
 +	if (features->quirks & WACOM_QUIRK_MONITOR) {
 +		if (usb_submit_urb(wacom->irq, GFP_KERNEL)) {
 +			error = -EIO;
 +			goto fail5;
 +		}
  	}
  
  	return 0;
  
++<<<<<<< HEAD
 + fail5: wacom_destroy_leds(wacom);
 + fail4:	wacom_remove_shared_data(wacom_wac);
 + fail3:	usb_free_urb(wacom->irq);
 + fail2:	usb_free_coherent(dev, WACOM_PKGLEN_MAX, wacom_wac->data, wacom->data_dma);
++=======
+  fail4:	if (hdev->bus == BUS_BLUETOOTH)
+ 		device_remove_file(&hdev->dev, &dev_attr_speed);
+ 	wacom_unregister_inputs(wacom);
+  fail3:	wacom_destroy_battery(wacom);
+  fail2:	wacom_remove_shared_data(wacom_wac);
++>>>>>>> 912ca216b548 (HID: wacom - enable LED support for Wireless Intuos5/Pro)
   fail1:	kfree(wacom);
 -	hid_set_drvdata(hdev, NULL);
  	return error;
  }
  
 -static void wacom_remove(struct hid_device *hdev)
 +static void wacom_disconnect(struct usb_interface *intf)
  {
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 +	struct wacom *wacom = usb_get_intfdata(intf);
  
 -	hid_hw_stop(hdev);
 +	usb_set_intfdata(intf, NULL);
  
 +	usb_kill_urb(wacom->irq);
  	cancel_work_sync(&wacom->work);
 -	wacom_unregister_inputs(wacom);
 -	if (hdev->bus == BUS_BLUETOOTH)
 -		device_remove_file(&hdev->dev, &dev_attr_speed);
 +	if (wacom->wacom_wac.input)
 +		input_unregister_device(wacom->wacom_wac.input);
  	wacom_destroy_battery(wacom);
++<<<<<<< HEAD
 +	wacom_destroy_leds(wacom);
 +	usb_free_urb(wacom->irq);
 +	usb_free_coherent(interface_to_usbdev(intf), WACOM_PKGLEN_MAX,
 +			wacom->wacom_wac.data, wacom->data_dma);
++=======
++>>>>>>> 912ca216b548 (HID: wacom - enable LED support for Wireless Intuos5/Pro)
  	wacom_remove_shared_data(&wacom->wacom_wac);
 -
 -	hid_set_drvdata(hdev, NULL);
  	kfree(wacom);
  }
  
* Unmerged path drivers/hid/wacom_sys.c
