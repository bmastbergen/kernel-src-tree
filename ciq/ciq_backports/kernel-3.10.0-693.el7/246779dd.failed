rhashtable: Remove GFP flag from rhashtable_walk_init

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit 246779dd090bd1b74d2652b3a6ca7759f593b27a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/246779dd.failed

The commit 8f6fd83c6c5ec66a4a70c728535ddcdfef4f3697 ("rhashtable:
accept GFP flags in rhashtable_walk_init") added a GFP flag argument
to rhashtable_walk_init because some users wish to use the walker
in an unsleepable context.

In fact we don't need to allocate memory in rhashtable_walk_init
at all.  The walker is always paired with an iterator so we could
just stash ourselves there.

This patch does that by introducing a new enter function to replace
the existing init function.  This way we don't have to churn all
the existing users again.

	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 246779dd090bd1b74d2652b3a6ca7759f593b27a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/rhashtable.h
#	lib/rhashtable.c
diff --cc include/linux/rhashtable.h
index 63bd7601b6de,8b72ee710f95..000000000000
--- a/include/linux/rhashtable.h
+++ b/include/linux/rhashtable.h
@@@ -346,7 -346,8 +346,12 @@@ struct bucket_table *rhashtable_insert_
  					    struct bucket_table *old_tbl);
  int rhashtable_insert_rehash(struct rhashtable *ht, struct bucket_table *tbl);
  
++<<<<<<< HEAD
 +int rhashtable_walk_init(struct rhashtable *ht, struct rhashtable_iter *iter);
++=======
+ void rhashtable_walk_enter(struct rhashtable *ht,
+ 			   struct rhashtable_iter *iter);
++>>>>>>> 246779dd090b (rhashtable: Remove GFP flag from rhashtable_walk_init)
  void rhashtable_walk_exit(struct rhashtable_iter *iter);
  int rhashtable_walk_start(struct rhashtable_iter *iter) __acquires(RCU);
  void *rhashtable_walk_next(struct rhashtable_iter *iter);
diff --cc lib/rhashtable.c
index 2af5f0267c1c,97e3cf08142c..000000000000
--- a/lib/rhashtable.c
+++ b/lib/rhashtable.c
@@@ -506,29 -506,22 +506,33 @@@ EXPORT_SYMBOL_GPL(rhashtable_insert_slo
   * This function may sleep so you must not call it from interrupt
   * context or with spin locks held.
   *
-  * You must call rhashtable_walk_exit if this function returns
-  * successfully.
+  * You must call rhashtable_walk_exit after this function returns.
   */
++<<<<<<< HEAD
 +int rhashtable_walk_init(struct rhashtable *ht, struct rhashtable_iter *iter)
++=======
+ void rhashtable_walk_enter(struct rhashtable *ht, struct rhashtable_iter *iter)
++>>>>>>> 246779dd090b (rhashtable: Remove GFP flag from rhashtable_walk_init)
  {
  	iter->ht = ht;
  	iter->p = NULL;
  	iter->slot = 0;
  	iter->skip = 0;
  
++<<<<<<< HEAD
 +	iter->walker = kmalloc(sizeof(*iter->walker), GFP_KERNEL);
 +	if (!iter->walker)
 +		return -ENOMEM;
 +
++=======
++>>>>>>> 246779dd090b (rhashtable: Remove GFP flag from rhashtable_walk_init)
  	spin_lock(&ht->lock);
- 	iter->walker->tbl =
+ 	iter->walker.tbl =
  		rcu_dereference_protected(ht->tbl, lockdep_is_held(&ht->lock));
- 	list_add(&iter->walker->list, &iter->walker->tbl->walkers);
+ 	list_add(&iter->walker.list, &iter->walker.tbl->walkers);
  	spin_unlock(&ht->lock);
- 
- 	return 0;
  }
- EXPORT_SYMBOL_GPL(rhashtable_walk_init);
+ EXPORT_SYMBOL_GPL(rhashtable_walk_enter);
  
  /**
   * rhashtable_walk_exit - Free an iterator
* Unmerged path include/linux/rhashtable.h
* Unmerged path lib/rhashtable.c
