switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jiri Pirko <jiri@resnulli.us>
commit ebb9a03a590e2325f747be43c8db450e92509501
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ebb9a03a.failed

Turned out that "switchdev" sticks. So just unify all related terms to use
this prefix.

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: Scott Feldman <sfeldma@gmail.com>
	Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Acked-by: Andy Gospodarek <gospo@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ebb9a03a590e2325f747be43c8db450e92509501)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
#	drivers/net/ethernet/rocker/rocker.c
#	drivers/net/team/team.c
#	include/net/switchdev.h
#	net/bridge/br.c
#	net/bridge/br_stp.c
#	net/core/rtnetlink.c
#	net/ipv4/fib_trie.c
#	net/switchdev/switchdev.c
diff --cc drivers/net/bonding/bond_main.c
index ce8e9750aae0,a475a0389cc7..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -4085,6 -4039,8 +4085,11 @@@ static const struct net_device_ops bond
  	.ndo_add_slave		= bond_enslave,
  	.ndo_del_slave		= bond_release,
  	.ndo_fix_features	= bond_fix_features,
++<<<<<<< HEAD
++=======
+ 	.ndo_bridge_setlink	= ndo_dflt_switchdev_port_bridge_setlink,
+ 	.ndo_bridge_dellink	= ndo_dflt_switchdev_port_bridge_dellink,
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  	.ndo_features_check	= passthru_features_check,
  };
  
diff --cc drivers/net/team/team.c
index 75ab1983f4c3,cfe84965afb6..000000000000
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@@ -2004,6 -1977,8 +2004,11 @@@ static const struct net_device_ops team
  	.ndo_del_slave		= team_del_slave,
  	.ndo_fix_features	= team_fix_features,
  	.ndo_change_carrier     = team_change_carrier,
++<<<<<<< HEAD
++=======
+ 	.ndo_bridge_setlink     = ndo_dflt_switchdev_port_bridge_setlink,
+ 	.ndo_bridge_dellink     = ndo_dflt_switchdev_port_bridge_dellink,
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  	.ndo_features_check	= passthru_features_check,
  };
  
diff --cc net/bridge/br.c
index 8a1ecd1e7f96,a1abe4936fe1..000000000000
--- a/net/bridge/br.c
+++ b/net/bridge/br.c
@@@ -22,6 -22,166 +22,168 @@@
  
  #include "br_private.h"
  
++<<<<<<< HEAD
++=======
+ /*
+  * Handle changes in state of network devices enslaved to a bridge.
+  *
+  * Note: don't care about up/down if bridge itself is down, because
+  *     port state is checked when bridge is brought up.
+  */
+ static int br_device_event(struct notifier_block *unused, unsigned long event, void *ptr)
+ {
+ 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+ 	struct net_bridge_port *p;
+ 	struct net_bridge *br;
+ 	bool changed_addr;
+ 	int err;
+ 
+ 	/* register of bridge completed, add sysfs entries */
+ 	if ((dev->priv_flags & IFF_EBRIDGE) && event == NETDEV_REGISTER) {
+ 		br_sysfs_addbr(dev);
+ 		return NOTIFY_DONE;
+ 	}
+ 
+ 	/* not a port of a bridge */
+ 	p = br_port_get_rtnl(dev);
+ 	if (!p)
+ 		return NOTIFY_DONE;
+ 
+ 	br = p->br;
+ 
+ 	switch (event) {
+ 	case NETDEV_CHANGEMTU:
+ 		dev_set_mtu(br->dev, br_min_mtu(br));
+ 		break;
+ 
+ 	case NETDEV_CHANGEADDR:
+ 		spin_lock_bh(&br->lock);
+ 		br_fdb_changeaddr(p, dev->dev_addr);
+ 		changed_addr = br_stp_recalculate_bridge_id(br);
+ 		spin_unlock_bh(&br->lock);
+ 
+ 		if (changed_addr)
+ 			call_netdevice_notifiers(NETDEV_CHANGEADDR, br->dev);
+ 
+ 		break;
+ 
+ 	case NETDEV_CHANGE:
+ 		br_port_carrier_check(p);
+ 		break;
+ 
+ 	case NETDEV_FEAT_CHANGE:
+ 		netdev_update_features(br->dev);
+ 		break;
+ 
+ 	case NETDEV_DOWN:
+ 		spin_lock_bh(&br->lock);
+ 		if (br->dev->flags & IFF_UP)
+ 			br_stp_disable_port(p);
+ 		spin_unlock_bh(&br->lock);
+ 		break;
+ 
+ 	case NETDEV_UP:
+ 		if (netif_running(br->dev) && netif_oper_up(dev)) {
+ 			spin_lock_bh(&br->lock);
+ 			br_stp_enable_port(p);
+ 			spin_unlock_bh(&br->lock);
+ 		}
+ 		break;
+ 
+ 	case NETDEV_UNREGISTER:
+ 		br_del_if(br, dev);
+ 		break;
+ 
+ 	case NETDEV_CHANGENAME:
+ 		err = br_sysfs_renameif(p);
+ 		if (err)
+ 			return notifier_from_errno(err);
+ 		break;
+ 
+ 	case NETDEV_PRE_TYPE_CHANGE:
+ 		/* Forbid underlaying device to change its type. */
+ 		return NOTIFY_BAD;
+ 
+ 	case NETDEV_RESEND_IGMP:
+ 		/* Propagate to master device */
+ 		call_netdevice_notifiers(event, br->dev);
+ 		break;
+ 	}
+ 
+ 	/* Events that may cause spanning tree to refresh */
+ 	if (event == NETDEV_CHANGEADDR || event == NETDEV_UP ||
+ 	    event == NETDEV_CHANGE || event == NETDEV_DOWN)
+ 		br_ifinfo_notify(RTM_NEWLINK, p);
+ 
+ 	return NOTIFY_DONE;
+ }
+ 
+ static struct notifier_block br_device_notifier = {
+ 	.notifier_call = br_device_event
+ };
+ 
+ static int br_switchdev_event(struct notifier_block *unused,
+ 			      unsigned long event, void *ptr)
+ {
+ 	struct net_device *dev = switchdev_notifier_info_to_dev(ptr);
+ 	struct net_bridge_port *p;
+ 	struct net_bridge *br;
+ 	struct switchdev_notifier_fdb_info *fdb_info;
+ 	int err = NOTIFY_DONE;
+ 
+ 	rtnl_lock();
+ 	p = br_port_get_rtnl(dev);
+ 	if (!p)
+ 		goto out;
+ 
+ 	br = p->br;
+ 
+ 	switch (event) {
+ 	case SWITCHDEV_FDB_ADD:
+ 		fdb_info = ptr;
+ 		err = br_fdb_external_learn_add(br, p, fdb_info->addr,
+ 						fdb_info->vid);
+ 		if (err)
+ 			err = notifier_from_errno(err);
+ 		break;
+ 	case SWITCHDEV_FDB_DEL:
+ 		fdb_info = ptr;
+ 		err = br_fdb_external_learn_del(br, p, fdb_info->addr,
+ 						fdb_info->vid);
+ 		if (err)
+ 			err = notifier_from_errno(err);
+ 		break;
+ 	}
+ 
+ out:
+ 	rtnl_unlock();
+ 	return err;
+ }
+ 
+ static struct notifier_block br_switchdev_notifier = {
+ 	.notifier_call = br_switchdev_event,
+ };
+ 
+ static void __net_exit br_net_exit(struct net *net)
+ {
+ 	struct net_device *dev;
+ 	LIST_HEAD(list);
+ 
+ 	rtnl_lock();
+ 	for_each_netdev(net, dev)
+ 		if (dev->priv_flags & IFF_EBRIDGE)
+ 			br_dev_delete(dev, &list);
+ 
+ 	unregister_netdevice_many(&list);
+ 	rtnl_unlock();
+ 
+ }
+ 
+ static struct pernet_operations br_net_ops = {
+ 	.exit	= br_net_exit,
+ };
+ 
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  static const struct stp_proto br_stp_proto = {
  	.rcv	= br_stp_rcv,
  };
@@@ -56,9 -214,13 +218,16 @@@ static int __init br_init(void
  	if (err)
  		goto err_out3;
  
++<<<<<<< HEAD
++=======
+ 	err = register_switchdev_notifier(&br_switchdev_notifier);
+ 	if (err)
+ 		goto err_out4;
+ 
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  	err = br_netlink_init();
  	if (err)
 -		goto err_out5;
 +		goto err_out4;
  
  	brioctl_set(br_ioctl_deviceless_stub);
  
@@@ -72,8 -234,10 +241,13 @@@
  
  	return 0;
  
++<<<<<<< HEAD
++=======
+ err_out5:
+ 	unregister_switchdev_notifier(&br_switchdev_notifier);
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  err_out4:
 -	unregister_netdevice_notifier(&br_device_notifier);
 +	unregister_netdevice_notifier_rh(&br_device_notifier);
  err_out3:
  	br_nf_core_fini();
  err_out2:
@@@ -89,7 -253,8 +263,12 @@@ static void __exit br_deinit(void
  {
  	stp_proto_unregister(&br_stp_proto);
  	br_netlink_fini();
++<<<<<<< HEAD
 +	unregister_netdevice_notifier_rh(&br_device_notifier);
++=======
+ 	unregister_switchdev_notifier(&br_switchdev_notifier);
+ 	unregister_netdevice_notifier(&br_device_notifier);
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  	brioctl_set(NULL);
  	unregister_pernet_subsys(&br_net_ops);
  
diff --cc net/bridge/br_stp.c
index 2b047bcf42a4,28e3f4bc01e0..000000000000
--- a/net/bridge/br_stp.c
+++ b/net/bridge/br_stp.c
@@@ -38,7 -39,13 +38,14 @@@ void br_log_state(const struct net_brid
  
  void br_set_state(struct net_bridge_port *p, unsigned int state)
  {
 -	int err;
 -
  	p->state = state;
++<<<<<<< HEAD
++=======
+ 	err = switchdev_port_stp_update(p->dev, state);
+ 	if (err && err != -EOPNOTSUPP)
+ 		br_warn(p->br, "error setting offload STP state on port %u(%s)\n",
+ 				(unsigned int) p->port_no, p->dev->name);
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  }
  
  /* called under bridge lock */
diff --cc net/core/rtnetlink.c
index 590c29aca2b6,fcd41fcd7e70..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1022,6 -983,42 +1022,45 @@@ static int rtnl_phys_port_id_fill(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int rtnl_phys_port_name_fill(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	char name[IFNAMSIZ];
+ 	int err;
+ 
+ 	err = dev_get_phys_port_name(dev, name, sizeof(name));
+ 	if (err) {
+ 		if (err == -EOPNOTSUPP)
+ 			return 0;
+ 		return err;
+ 	}
+ 
+ 	if (nla_put(skb, IFLA_PHYS_PORT_NAME, strlen(name), name))
+ 		return -EMSGSIZE;
+ 
+ 	return 0;
+ }
+ 
+ static int rtnl_phys_switch_id_fill(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	int err;
+ 	struct netdev_phys_item_id psid;
+ 
+ 	err = switchdev_parent_id_get(dev, &psid);
+ 	if (err) {
+ 		if (err == -EOPNOTSUPP)
+ 			return 0;
+ 		return err;
+ 	}
+ 
+ 	if (nla_put(skb, IFLA_PHYS_SWITCH_ID, psid.id_len, psid.id))
+ 		return -EMSGSIZE;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
  			    int type, u32 pid, u32 seq, u32 change,
  			    unsigned int flags, u32 ext_filter_mask)
diff --cc net/ipv4/fib_trie.c
index 9511456e5325,03444c6ae342..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -1155,7 -1165,19 +1155,21 @@@ int fib_table_insert(struct fib_table *
  			new_fa->fa_state = state & ~FA_S_ACCESSED;
  			new_fa->fa_slen = fa->fa_slen;
  
++<<<<<<< HEAD
++=======
+ 			err = switchdev_fib_ipv4_add(key, plen, fi,
+ 						     new_fa->fa_tos,
+ 						     cfg->fc_type,
+ 						     cfg->fc_nlflags,
+ 						     tb->tb_id);
+ 			if (err) {
+ 				switchdev_fib_ipv4_abort(fi);
+ 				kmem_cache_free(fn_alias_kmem, new_fa);
+ 				goto out;
+ 			}
+ 
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  			hlist_replace_rcu(&fa->fa_list, &new_fa->fa_list);
 -
  			alias_free_mem_rcu(fa);
  
  			fib_release_info(fi_drop);
@@@ -1190,6 -1212,15 +1204,18 @@@
  	new_fa->fa_type = cfg->fc_type;
  	new_fa->fa_state = 0;
  	new_fa->fa_slen = slen;
++<<<<<<< HEAD
++=======
+ 	new_fa->tb_id = tb->tb_id;
+ 
+ 	/* (Optionally) offload fib entry to switch hardware. */
+ 	err = switchdev_fib_ipv4_add(key, plen, fi, tos, cfg->fc_type,
+ 				     cfg->fc_nlflags, tb->tb_id);
+ 	if (err) {
+ 		switchdev_fib_ipv4_abort(fi);
+ 		goto out_free_new_fa;
+ 	}
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  
  	/* Insert new entry to the list. */
  	err = fib_insert_alias(t, tp, l, new_fa, fa, key);
@@@ -1205,6 -1236,8 +1231,11 @@@
  succeeded:
  	return 0;
  
++<<<<<<< HEAD
++=======
+ out_sw_fib_del:
+ 	switchdev_fib_ipv4_del(key, plen, fi, tos, cfg->fc_type, tb->tb_id);
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  out_free_new_fa:
  	kmem_cache_free(fn_alias_kmem, new_fa);
  out:
@@@ -1480,6 -1515,9 +1511,12 @@@ int fib_table_delete(struct fib_table *
  	if (!fa_to_delete)
  		return -ESRCH;
  
++<<<<<<< HEAD
++=======
+ 	switchdev_fib_ipv4_del(key, plen, fa_to_delete->fa_info, tos,
+ 			       cfg->fc_type, tb->tb_id);
+ 
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  	rtmsg_fib(RTM_DELROUTE, htonl(key), fa_to_delete, plen, tb->tb_id,
  		  &cfg->fc_nlinfo, 0);
  
@@@ -1554,6 -1592,196 +1591,199 @@@ found
  	return n;
  }
  
++<<<<<<< HEAD
++=======
+ static void fib_trie_free(struct fib_table *tb)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *pn = t->kv;
+ 	unsigned long cindex = 1;
+ 	struct hlist_node *tmp;
+ 	struct fib_alias *fa;
+ 
+ 	/* walk trie in reverse order and free everything */
+ 	for (;;) {
+ 		struct key_vector *n;
+ 
+ 		if (!(cindex--)) {
+ 			t_key pkey = pn->key;
+ 
+ 			if (IS_TRIE(pn))
+ 				break;
+ 
+ 			n = pn;
+ 			pn = node_parent(pn);
+ 
+ 			/* drop emptied tnode */
+ 			put_child_root(pn, n->key, NULL);
+ 			node_free(n);
+ 
+ 			cindex = get_index(pkey, pn);
+ 
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = get_child(pn, cindex);
+ 		if (!n)
+ 			continue;
+ 
+ 		if (IS_TNODE(n)) {
+ 			/* record pn and cindex for leaf walking */
+ 			pn = n;
+ 			cindex = 1ul << n->bits;
+ 
+ 			continue;
+ 		}
+ 
+ 		hlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {
+ 			hlist_del_rcu(&fa->fa_list);
+ 			alias_free_mem_rcu(fa);
+ 		}
+ 
+ 		put_child_root(pn, n->key, NULL);
+ 		node_free(n);
+ 	}
+ 
+ #ifdef CONFIG_IP_FIB_TRIE_STATS
+ 	free_percpu(t->stats);
+ #endif
+ 	kfree(tb);
+ }
+ 
+ struct fib_table *fib_trie_unmerge(struct fib_table *oldtb)
+ {
+ 	struct trie *ot = (struct trie *)oldtb->tb_data;
+ 	struct key_vector *l, *tp = ot->kv;
+ 	struct fib_table *local_tb;
+ 	struct fib_alias *fa;
+ 	struct trie *lt;
+ 	t_key key = 0;
+ 
+ 	if (oldtb->tb_data == oldtb->__data)
+ 		return oldtb;
+ 
+ 	local_tb = fib_trie_table(RT_TABLE_LOCAL, NULL);
+ 	if (!local_tb)
+ 		return NULL;
+ 
+ 	lt = (struct trie *)local_tb->tb_data;
+ 
+ 	while ((l = leaf_walk_rcu(&tp, key)) != NULL) {
+ 		struct key_vector *local_l = NULL, *local_tp;
+ 
+ 		hlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {
+ 			struct fib_alias *new_fa;
+ 
+ 			if (local_tb->tb_id != fa->tb_id)
+ 				continue;
+ 
+ 			/* clone fa for new local table */
+ 			new_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);
+ 			if (!new_fa)
+ 				goto out;
+ 
+ 			memcpy(new_fa, fa, sizeof(*fa));
+ 
+ 			/* insert clone into table */
+ 			if (!local_l)
+ 				local_l = fib_find_node(lt, &local_tp, l->key);
+ 
+ 			if (fib_insert_alias(lt, local_tp, local_l, new_fa,
+ 					     NULL, l->key))
+ 				goto out;
+ 		}
+ 
+ 		/* stop loop if key wrapped back to 0 */
+ 		key = l->key + 1;
+ 		if (key < l->key)
+ 			break;
+ 	}
+ 
+ 	return local_tb;
+ out:
+ 	fib_trie_free(local_tb);
+ 
+ 	return NULL;
+ }
+ 
+ /* Caller must hold RTNL */
+ void fib_table_flush_external(struct fib_table *tb)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *pn = t->kv;
+ 	unsigned long cindex = 1;
+ 	struct hlist_node *tmp;
+ 	struct fib_alias *fa;
+ 
+ 	/* walk trie in reverse order */
+ 	for (;;) {
+ 		unsigned char slen = 0;
+ 		struct key_vector *n;
+ 
+ 		if (!(cindex--)) {
+ 			t_key pkey = pn->key;
+ 
+ 			/* cannot resize the trie vector */
+ 			if (IS_TRIE(pn))
+ 				break;
+ 
+ 			/* resize completed node */
+ 			pn = resize(t, pn);
+ 			cindex = get_index(pkey, pn);
+ 
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = get_child(pn, cindex);
+ 		if (!n)
+ 			continue;
+ 
+ 		if (IS_TNODE(n)) {
+ 			/* record pn and cindex for leaf walking */
+ 			pn = n;
+ 			cindex = 1ul << n->bits;
+ 
+ 			continue;
+ 		}
+ 
+ 		hlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {
+ 			struct fib_info *fi = fa->fa_info;
+ 
+ 			/* if alias was cloned to local then we just
+ 			 * need to remove the local copy from main
+ 			 */
+ 			if (tb->tb_id != fa->tb_id) {
+ 				hlist_del_rcu(&fa->fa_list);
+ 				alias_free_mem_rcu(fa);
+ 				continue;
+ 			}
+ 
+ 			/* record local slen */
+ 			slen = fa->fa_slen;
+ 
+ 			if (!fi || !(fi->fib_flags & RTNH_F_EXTERNAL))
+ 				continue;
+ 
+ 			switchdev_fib_ipv4_del(n->key, KEYLENGTH - fa->fa_slen,
+ 					       fi, fa->fa_tos, fa->fa_type,
+ 					       tb->tb_id);
+ 		}
+ 
+ 		/* update leaf slen */
+ 		n->slen = slen;
+ 
+ 		if (hlist_empty(&n->leaf)) {
+ 			put_child_root(pn, n->key, NULL);
+ 			node_free(n);
+ 		} else {
+ 			leaf_pull_suffix(pn, n);
+ 		}
+ 	}
+ }
+ 
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  /* Caller must hold RTNL. */
  int fib_table_flush(struct fib_table *tb)
  {
@@@ -1604,6 -1832,9 +1834,12 @@@
  				continue;
  			}
  
++<<<<<<< HEAD
++=======
+ 			switchdev_fib_ipv4_del(n->key, KEYLENGTH - fa->fa_slen,
+ 					       fi, fa->fa_tos, fa->fa_type,
+ 					       tb->tb_id);
++>>>>>>> ebb9a03a590e (switchdev: s/netdev_switch_/switchdev_/ and s/NETDEV_SWITCH_/SWITCHDEV_/)
  			hlist_del_rcu(&fa->fa_list);
  			fib_release_info(fa->fa_info);
  			alias_free_mem_rcu(fa);
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path include/net/switchdev.h
* Unmerged path net/switchdev/switchdev.c
* Unmerged path drivers/net/bonding/bond_main.c
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path drivers/net/team/team.c
* Unmerged path include/net/switchdev.h
* Unmerged path net/bridge/br.c
diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c
index 389930889e03..17becaad826c 100644
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@ -546,8 +546,7 @@ int br_setlink(struct net_device *dev, struct nlmsghdr *nlh, u16 flags)
 	if (p && !(flags & BRIDGE_FLAGS_SELF)) {
 		/* set bridge attributes in hardware if supported
 		 */
-		ret_offload = netdev_switch_port_bridge_setlink(dev, nlh,
-								flags);
+		ret_offload = switchdev_port_bridge_setlink(dev, nlh, flags);
 		if (ret_offload && ret_offload != -EOPNOTSUPP)
 			br_warn(p->br, "error setting attrs on port %u(%s)\n",
 				(unsigned int)p->port_no, p->dev->name);
@@ -586,8 +585,7 @@ int br_dellink(struct net_device *dev, struct nlmsghdr *nlh, u16 flags)
 	if (p && !(flags & BRIDGE_FLAGS_SELF)) {
 		/* del bridge attributes in hardware
 		 */
-		ret_offload = netdev_switch_port_bridge_dellink(dev, nlh,
-								flags);
+		ret_offload = switchdev_port_bridge_dellink(dev, nlh, flags);
 		if (ret_offload && ret_offload != -EOPNOTSUPP)
 			br_warn(p->br, "error deleting attrs on port %u (%s)\n",
 				(unsigned int)p->port_no, p->dev->name);
* Unmerged path net/bridge/br_stp.c
diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c
index c7c996a3d5f5..f1a48f43f30b 100644
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@ -418,7 +418,7 @@ static ssize_t phys_switch_id_show(struct device *dev,
 	if (dev_isalive(netdev)) {
 		struct netdev_phys_item_id ppid;
 
-		ret = netdev_switch_parent_id_get(netdev, &ppid);
+		ret = switchdev_parent_id_get(netdev, &ppid);
 		if (!ret)
 			ret = sprintf(buf, "%*phN\n", ppid.id_len, ppid.id);
 	}
* Unmerged path net/core/rtnetlink.c
* Unmerged path net/ipv4/fib_trie.c
* Unmerged path net/switchdev/switchdev.c
