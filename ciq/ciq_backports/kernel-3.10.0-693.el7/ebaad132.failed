ntb: initialize max_mw for Atom before using it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [ntb] initialize max_mw for Atom before using it (Suravee Suthikulpanit) [1303727]
Rebuild_FUZZ: 94.38%
commit-author Daniel Verkamp <daniel.verkamp@intel.com>
commit ebaad1322d8080a1a8367ec631b345405d9879e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ebaad132.failed

Commit ab760a0 (ntb: Adding split BAR support for Haswell platforms)
changed ntb_device's mw from a fixed-size array into a pointer that is
allocated based on limits.max_mw; however, on Atom platforms, max_mw
is not initialized until ntb_device_setup(), which happens after the
allocation.

Fill out max_mw in ntb_atom_detect() to match ntb_xeon_detect(); this
happens before the use of max_mw in the ndev->mw allocation.

Fixes a null pointer dereference on Atom platforms with ntb hardware.

v2: fix typo (mw_max should be max_mw)

	Signed-off-by: Daniel Verkamp <daniel.verkamp@intel.com>
	Acked-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Jon Mason <jdmason@kudzu.us>
(cherry picked from commit ebaad1322d8080a1a8367ec631b345405d9879e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ntb/ntb_hw.c
diff --cc drivers/ntb/ntb_hw.c
index 77b56fc386fb,15f9b7c9e4d3..000000000000
--- a/drivers/ntb/ntb_hw.c
+++ b/drivers/ntb/ntb_hw.c
@@@ -1167,6 -1547,161 +1167,164 @@@ static void ntb_free_debugfs(struct ntb
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void ntb_hw_link_up(struct ntb_device *ndev)
+ {
+ 	if (ndev->conn_type == NTB_CONN_TRANSPARENT)
+ 		ntb_link_event(ndev, NTB_LINK_UP);
+ 	else {
+ 		u32 ntb_cntl;
+ 
+ 		/* Let's bring the NTB link up */
+ 		ntb_cntl = readl(ndev->reg_ofs.lnk_cntl);
+ 		ntb_cntl &= ~(NTB_CNTL_LINK_DISABLE | NTB_CNTL_CFG_LOCK);
+ 		ntb_cntl |= NTB_CNTL_P2S_BAR23_SNOOP | NTB_CNTL_S2P_BAR23_SNOOP;
+ 		ntb_cntl |= NTB_CNTL_P2S_BAR4_SNOOP | NTB_CNTL_S2P_BAR4_SNOOP;
+ 		if (ndev->split_bar)
+ 			ntb_cntl |= NTB_CNTL_P2S_BAR5_SNOOP |
+ 				    NTB_CNTL_S2P_BAR5_SNOOP;
+ 
+ 		writel(ntb_cntl, ndev->reg_ofs.lnk_cntl);
+ 	}
+ }
+ 
+ static void ntb_hw_link_down(struct ntb_device *ndev)
+ {
+ 	u32 ntb_cntl;
+ 
+ 	if (ndev->conn_type == NTB_CONN_TRANSPARENT) {
+ 		ntb_link_event(ndev, NTB_LINK_DOWN);
+ 		return;
+ 	}
+ 
+ 	/* Bring NTB link down */
+ 	ntb_cntl = readl(ndev->reg_ofs.lnk_cntl);
+ 	ntb_cntl &= ~(NTB_CNTL_P2S_BAR23_SNOOP | NTB_CNTL_S2P_BAR23_SNOOP);
+ 	ntb_cntl &= ~(NTB_CNTL_P2S_BAR4_SNOOP | NTB_CNTL_S2P_BAR4_SNOOP);
+ 	if (ndev->split_bar)
+ 		ntb_cntl &= ~(NTB_CNTL_P2S_BAR5_SNOOP |
+ 			      NTB_CNTL_S2P_BAR5_SNOOP);
+ 	ntb_cntl |= NTB_CNTL_LINK_DISABLE | NTB_CNTL_CFG_LOCK;
+ 	writel(ntb_cntl, ndev->reg_ofs.lnk_cntl);
+ }
+ 
+ static void ntb_max_mw_detect(struct ntb_device *ndev)
+ {
+ 	if (ndev->split_bar)
+ 		ndev->limits.max_mw = HSX_SPLITBAR_MAX_MW;
+ 	else
+ 		ndev->limits.max_mw = SNB_MAX_MW;
+ }
+ 
+ static int ntb_xeon_detect(struct ntb_device *ndev)
+ {
+ 	int rc, bars_mask;
+ 	u32 bars;
+ 	u8 ppd;
+ 
+ 	ndev->hw_type = SNB_HW;
+ 
+ 	rc = pci_read_config_byte(ndev->pdev, NTB_PPD_OFFSET, &ppd);
+ 	if (rc)
+ 		return -EIO;
+ 
+ 	if (ppd & SNB_PPD_DEV_TYPE)
+ 		ndev->dev_type = NTB_DEV_USD;
+ 	else
+ 		ndev->dev_type = NTB_DEV_DSD;
+ 
+ 	ndev->split_bar = (ppd & SNB_PPD_SPLIT_BAR) ? 1 : 0;
+ 
+ 	switch (ppd & SNB_PPD_CONN_TYPE) {
+ 	case NTB_CONN_B2B:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = B2B\n");
+ 		ndev->conn_type = NTB_CONN_B2B;
+ 		break;
+ 	case NTB_CONN_RP:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = RP\n");
+ 		ndev->conn_type = NTB_CONN_RP;
+ 		break;
+ 	case NTB_CONN_TRANSPARENT:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = TRANSPARENT\n");
+ 		ndev->conn_type = NTB_CONN_TRANSPARENT;
+ 		/*
+ 		 * This mode is default to USD/DSP. HW does not report
+ 		 * properly in transparent mode as it has no knowledge of
+ 		 * NTB. We will just force correct here.
+ 		 */
+ 		ndev->dev_type = NTB_DEV_USD;
+ 
+ 		/*
+ 		 * This is a way for transparent BAR to figure out if we
+ 		 * are doing split BAR or not. There is no way for the hw
+ 		 * on the transparent side to know and set the PPD.
+ 		 */
+ 		bars_mask = pci_select_bars(ndev->pdev, IORESOURCE_MEM);
+ 		bars = hweight32(bars_mask);
+ 		if (bars == (HSX_SPLITBAR_MAX_MW + 1))
+ 			ndev->split_bar = 1;
+ 
+ 		break;
+ 	default:
+ 		dev_err(&ndev->pdev->dev, "Unknown PPD %x\n", ppd);
+ 		return -ENODEV;
+ 	}
+ 
+ 	ntb_max_mw_detect(ndev);
+ 
+ 	return 0;
+ }
+ 
+ static int ntb_atom_detect(struct ntb_device *ndev)
+ {
+ 	int rc;
+ 	u32 ppd;
+ 
+ 	ndev->hw_type = BWD_HW;
+ 	ndev->limits.max_mw = BWD_MAX_MW;
+ 
+ 	rc = pci_read_config_dword(ndev->pdev, NTB_PPD_OFFSET, &ppd);
+ 	if (rc)
+ 		return rc;
+ 
+ 	switch ((ppd & BWD_PPD_CONN_TYPE) >> 8) {
+ 	case NTB_CONN_B2B:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = B2B\n");
+ 		ndev->conn_type = NTB_CONN_B2B;
+ 		break;
+ 	case NTB_CONN_RP:
+ 	default:
+ 		dev_err(&ndev->pdev->dev, "Unsupported NTB configuration\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (ppd & BWD_PPD_DEV_TYPE)
+ 		ndev->dev_type = NTB_DEV_DSD;
+ 	else
+ 		ndev->dev_type = NTB_DEV_USD;
+ 
+ 	return 0;
+ }
+ 
+ static int ntb_device_detect(struct ntb_device *ndev)
+ {
+ 	int rc;
+ 
+ 	if (is_ntb_xeon(ndev))
+ 		rc = ntb_xeon_detect(ndev);
+ 	else if (is_ntb_atom(ndev))
+ 		rc = ntb_atom_detect(ndev);
+ 	else
+ 		rc = -ENODEV;
+ 
+ 	dev_info(&ndev->pdev->dev, "Device Type = %s\n",
+ 		 ndev->dev_type == NTB_DEV_USD ? "USD/DSP" : "DSD/USP");
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> ebaad1322d80 (ntb: initialize max_mw for Atom before using it)
  static int ntb_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
  {
  	struct ntb_device *ndev;
* Unmerged path drivers/ntb/ntb_hw.c
