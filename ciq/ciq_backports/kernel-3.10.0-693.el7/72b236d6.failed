HID: wacom: Add support for Express Key Remote.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Add support for Express Key Remote (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 93.18%
commit-author Aaron Skomra <skomra@gmail.com>
commit 72b236d60218fe211a8e1210be31c31e81684b86
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/72b236d6.failed

This device is pad (buttons) only, there is no stylus or touch. Up to
five remotes can pair with the device's associated USB dongle.

	Signed-off-by: Aaron Skomra <aaron.skomra@wacom.com>
	Reviewed-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 72b236d60218fe211a8e1210be31c31e81684b86)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/ABI/testing/sysfs-driver-wacom
#	drivers/hid/wacom.h
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
#	drivers/hid/wacom_wac.h
diff --cc Documentation/ABI/testing/sysfs-driver-wacom
index 7fc781048b79,dca429340772..000000000000
--- a/Documentation/ABI/testing/sysfs-driver-wacom
+++ b/Documentation/ABI/testing/sysfs-driver-wacom
@@@ -93,3 -72,27 +93,30 @@@ Description
  		byte chunk encodes the image data for two consecutive lines on
  		the display. The low nibble of each byte contains the first
  		line, and the high nibble contains the second line.
++<<<<<<< HEAD
++=======
+ 		When the Wacom Intuos 4 is connected over Bluetooth, the
+ 		image has to contain 256 bytes (64x32 px 1 bit colour).
+ 		The format is also scrambled, like in the USB mode, and it can
+ 		be summarized by converting 76543210 into GECA6420.
+ 					    HGFEDCBA      HFDB7531
+ 
+ What:		/sys/bus/hid/devices/<bus>:<vid>:<pid>.<n>/wacom_remote/unpair_remote
+ Date:		July 2015
+ Contact:	linux-input@vger.kernel.org
+ Description:
+ 		Writing the character sequence '*' followed by a newline to
+ 		this file will delete all of the current pairings on the
+ 		device. Other character sequences are reserved. This file is
+ 		write only.
+ 
+ What:		/sys/bus/hid/devices/<bus>:<vid>:<pid>.<n>/wacom_remote/<serial_number>/remote_mode
+ Date:		July 2015
+ Contact:	linux-input@vger.kernel.org
+ Description:
+ 		Reading from this file reports the mode status of the
+ 		remote as indicated by the LED lights on the device. If no
+ 		reports have been received from the paired device, reading
+ 		from this file will report '-1'. The mode is read-only
+ 		and cannot be set through the driver.
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
diff --cc drivers/hid/wacom.h
index 87d2c48e3adc,4681a65a4579..000000000000
--- a/drivers/hid/wacom.h
+++ b/drivers/hid/wacom.h
@@@ -110,23 -106,25 +110,32 @@@ MODULE_LICENSE(DRIVER_LICENSE)
  #define USB_VENDOR_ID_LENOVO	0x17ef
  
  struct wacom {
 +	dma_addr_t data_dma;
  	struct usb_device *usbdev;
  	struct usb_interface *intf;
 +	struct urb *irq;
  	struct wacom_wac wacom_wac;
 -	struct hid_device *hdev;
  	struct mutex lock;
  	struct work_struct work;
 +	bool open;
 +	char phys[32];
  	struct wacom_led {
- 		u8 select[2]; /* status led selector (0..3) */
+ 		u8 select[5]; /* status led selector (0..3) */
  		u8 llv;       /* status led brightness no button (1..127) */
  		u8 hlv;       /* status led brightness button pressed (1..127) */
  		u8 img_lum;   /* OLED matrix display brightness */
  	} led;
  	bool led_initialized;
++<<<<<<< HEAD
 +	struct power_supply battery;
++=======
+ 	struct power_supply *battery;
+ 	struct power_supply *ac;
+ 	struct power_supply_desc battery_desc;
+ 	struct power_supply_desc ac_desc;
+ 	struct kobject *remote_dir;
+ 	struct attribute_group remote_group[5];
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
  };
  
  static inline void wacom_schedule_work(struct wacom_wac *wacom_wac)
@@@ -135,10 -133,23 +144,26 @@@
  	schedule_work(&wacom->work);
  }
  
 -extern const struct hid_device_id wacom_ids[];
 +extern const struct usb_device_id wacom_ids[];
  
  void wacom_wac_irq(struct wacom_wac *wacom_wac, size_t len);
 -void wacom_setup_device_quirks(struct wacom *wacom);
 -int wacom_setup_pen_input_capabilities(struct input_dev *input_dev,
 +void wacom_setup_device_quirks(struct wacom_features *features);
 +int wacom_setup_input_capabilities(struct input_dev *input_dev,
  				   struct wacom_wac *wacom_wac);
++<<<<<<< HEAD
++=======
+ int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac);
+ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
+ 				       struct wacom_wac *wacom_wac);
+ void wacom_wac_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage);
+ int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value);
+ void wacom_wac_report(struct hid_device *hdev, struct hid_report *report);
+ void wacom_battery_work(struct work_struct *work);
+ int wacom_remote_create_attr_group(struct wacom *wacom, __u32 serial,
+ 				   int index);
+ void wacom_remote_destroy_attr_group(struct wacom *wacom, __u32 serial);
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
  #endif
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,5f6e48e55df9..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -58,12 -20,20 +58,24 @@@ struct hid_descriptor 
  #define WAC_CMD_LED_CONTROL	0x20
  #define WAC_CMD_ICON_START	0x21
  #define WAC_CMD_ICON_XFER	0x23
 -#define WAC_CMD_ICON_BT_XFER	0x26
  #define WAC_CMD_RETRIES		10
+ #define WAC_CMD_DELETE_PAIRING	0x20
+ #define WAC_CMD_UNPAIR_ALL	0xFF
+ #define WAC_REMOTE_SERIAL_MAX_STRLEN	9
  
++<<<<<<< HEAD
 +static int wacom_get_report(struct usb_interface *intf, u8 type, u8 id,
 +			    void *buf, size_t size, unsigned int retries)
++=======
+ #define DEV_ATTR_RW_PERM (S_IRUGO | S_IWUSR | S_IWGRP)
+ #define DEV_ATTR_WO_PERM (S_IWUSR | S_IWGRP)
+ #define DEV_ATTR_RO_PERM (S_IRUSR | S_IRGRP)
+ 
+ static int wacom_get_report(struct hid_device *hdev, u8 type, u8 *buf,
+ 			    size_t size, unsigned int retries)
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
  {
 +	struct usb_device *dev = interface_to_usbdev(intf);
  	int retval;
  
  	do {
@@@ -1127,42 -1091,370 +1139,388 @@@ static void wacom_destroy_battery(struc
  	}
  }
  
++<<<<<<< HEAD
 +static int wacom_register_input(struct wacom *wacom)
++=======
+ static ssize_t wacom_show_speed(struct device *dev,
+ 				struct device_attribute
+ 				*attr, char *buf)
+ {
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 
+ 	return snprintf(buf, PAGE_SIZE, "%i\n", wacom->wacom_wac.bt_high_speed);
+ }
+ 
+ static ssize_t wacom_store_speed(struct device *dev,
+ 				struct device_attribute *attr,
+ 				const char *buf, size_t count)
+ {
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	u8 new_speed;
+ 
+ 	if (kstrtou8(buf, 0, &new_speed))
+ 		return -EINVAL;
+ 
+ 	if (new_speed != 0 && new_speed != 1)
+ 		return -EINVAL;
+ 
+ 	wacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);
+ 
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR(speed, DEV_ATTR_RW_PERM,
+ 		wacom_show_speed, wacom_store_speed);
+ 
+ 
+ static ssize_t wacom_show_remote_mode(struct kobject *kobj,
+ 				      struct kobj_attribute *kattr,
+ 				      char *buf, int index)
+ {
+ 	struct device *dev = container_of(kobj->parent, struct device, kobj);
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	u8 mode;
+ 
+ 	mode = wacom->led.select[index];
+ 	if (mode >= 0 && mode < 3)
+ 		return snprintf(buf, PAGE_SIZE, "%d\n", mode);
+ 	else
+ 		return snprintf(buf, PAGE_SIZE, "%d\n", -1);
+ }
+ 
+ #define DEVICE_EKR_ATTR_GROUP(SET_ID)					\
+ static ssize_t wacom_show_remote##SET_ID##_mode(struct kobject *kobj,	\
+ 			       struct kobj_attribute *kattr, char *buf)	\
+ {									\
+ 	return wacom_show_remote_mode(kobj, kattr, buf, SET_ID);	\
+ }									\
+ static struct kobj_attribute remote##SET_ID##_mode_attr = {		\
+ 	.attr = {.name = "remote_mode",					\
+ 		.mode = DEV_ATTR_RO_PERM},				\
+ 	.show = wacom_show_remote##SET_ID##_mode,			\
+ };									\
+ static struct attribute *remote##SET_ID##_serial_attrs[] = {		\
+ 	&remote##SET_ID##_mode_attr.attr,				\
+ 	NULL								\
+ };									\
+ static struct attribute_group remote##SET_ID##_serial_group = {		\
+ 	.name = NULL,							\
+ 	.attrs = remote##SET_ID##_serial_attrs,				\
+ }
+ 
+ DEVICE_EKR_ATTR_GROUP(0);
+ DEVICE_EKR_ATTR_GROUP(1);
+ DEVICE_EKR_ATTR_GROUP(2);
+ DEVICE_EKR_ATTR_GROUP(3);
+ DEVICE_EKR_ATTR_GROUP(4);
+ 
+ int wacom_remote_create_attr_group(struct wacom *wacom, __u32 serial, int index)
+ {
+ 	int error = 0;
+ 	char *buf;
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	wacom_wac->serial[index] = serial;
+ 
+ 	buf = kzalloc(WAC_REMOTE_SERIAL_MAX_STRLEN, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 	snprintf(buf, WAC_REMOTE_SERIAL_MAX_STRLEN, "%d", serial);
+ 	wacom->remote_group[index].name = buf;
+ 
+ 	error = sysfs_create_group(wacom->remote_dir,
+ 				   &wacom->remote_group[index]);
+ 	if (error) {
+ 		hid_err(wacom->hdev,
+ 			"cannot create sysfs group err: %d\n", error);
+ 		kobject_put(wacom->remote_dir);
+ 		return error;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void wacom_remote_destroy_attr_group(struct wacom *wacom, __u32 serial)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	int i;
+ 
+ 	if (!serial)
+ 		return;
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		if (wacom_wac->serial[i] == serial) {
+ 			wacom_wac->serial[i] = 0;
+ 			wacom->led.select[i] = WACOM_STATUS_UNKNOWN;
+ 			if (wacom->remote_group[i].name) {
+ 				sysfs_remove_group(wacom->remote_dir,
+ 						   &wacom->remote_group[i]);
+ 				kfree(wacom->remote_group[i].name);
+ 				wacom->remote_group[i].name = NULL;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ static int wacom_cmd_unpair_remote(struct wacom *wacom, unsigned char selector)
+ {
+ 	const size_t buf_size = 2;
+ 	unsigned char *buf;
+ 	int retval;
+ 
+ 	buf = kzalloc(buf_size, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	buf[0] = WAC_CMD_DELETE_PAIRING;
+ 	buf[1] = selector;
+ 
+ 	retval = wacom_set_report(wacom->hdev, HID_OUTPUT_REPORT, buf,
+ 				  buf_size, WAC_CMD_RETRIES);
+ 	kfree(buf);
+ 
+ 	return retval;
+ }
+ 
+ static ssize_t wacom_store_unpair_remote(struct kobject *kobj,
+ 					 struct kobj_attribute *attr,
+ 					 const char *buf, size_t count)
+ {
+ 	unsigned char selector = 0;
+ 	struct device *dev = container_of(kobj->parent, struct device, kobj);
+ 	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	int err;
+ 
+ 	if (!strncmp(buf, "*\n", 2)) {
+ 		selector = WAC_CMD_UNPAIR_ALL;
+ 	} else {
+ 		hid_info(wacom->hdev, "remote: unrecognized unpair code: %s\n",
+ 			 buf);
+ 		return -1;
+ 	}
+ 
+ 	mutex_lock(&wacom->lock);
+ 
+ 	err = wacom_cmd_unpair_remote(wacom, selector);
+ 	mutex_unlock(&wacom->lock);
+ 
+ 	return err < 0 ? err : count;
+ }
+ 
+ static struct kobj_attribute unpair_remote_attr = {
+ 	.attr = {.name = "unpair_remote", .mode = 0200},
+ 	.store = wacom_store_unpair_remote,
+ };
+ 
+ static const struct attribute *remote_unpair_attrs[] = {
+ 	&unpair_remote_attr.attr,
+ 	NULL
+ };
+ 
+ static int wacom_initialize_remote(struct wacom *wacom)
+ {
+ 	int error = 0;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 	int i;
+ 
+ 	if (wacom->wacom_wac.features.type != REMOTE)
+ 		return 0;
+ 
+ 	wacom->remote_group[0] = remote0_serial_group;
+ 	wacom->remote_group[1] = remote1_serial_group;
+ 	wacom->remote_group[2] = remote2_serial_group;
+ 	wacom->remote_group[3] = remote3_serial_group;
+ 	wacom->remote_group[4] = remote4_serial_group;
+ 
+ 	wacom->remote_dir = kobject_create_and_add("wacom_remote",
+ 						   &wacom->hdev->dev.kobj);
+ 	if (!wacom->remote_dir)
+ 		return -ENOMEM;
+ 
+ 	error = sysfs_create_files(wacom->remote_dir, remote_unpair_attrs);
+ 
+ 	if (error) {
+ 		hid_err(wacom->hdev,
+ 			"cannot create sysfs group err: %d\n", error);
+ 		return error;
+ 	}
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		wacom->led.select[i] = WACOM_STATUS_UNKNOWN;
+ 		wacom_wac->serial[i] = 0;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static struct input_dev *wacom_allocate_input(struct wacom *wacom)
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
  {
  	struct input_dev *input_dev;
 -	struct hid_device *hdev = wacom->hdev;
 +	struct usb_interface *intf = wacom->intf;
 +	struct usb_device *dev = interface_to_usbdev(intf);
  	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 +	int error;
  
  	input_dev = input_allocate_device();
 -	if (!input_dev)
 -		return NULL;
 +	if (!input_dev) {
 +		error = -ENOMEM;
 +		goto fail1;
 +	}
  
 -	input_dev->name = wacom_wac->features.name;
 -	input_dev->phys = hdev->phys;
 -	input_dev->dev.parent = &hdev->dev;
 +	input_dev->name = wacom_wac->name;
 +	input_dev->dev.parent = &intf->dev;
  	input_dev->open = wacom_open;
  	input_dev->close = wacom_close;
 -	input_dev->uniq = hdev->uniq;
 -	input_dev->id.bustype = hdev->bus;
 -	input_dev->id.vendor  = hdev->vendor;
 -	input_dev->id.product = wacom_wac->pid ? wacom_wac->pid : hdev->product;
 -	input_dev->id.version = hdev->version;
 +	usb_to_input_id(dev, &input_dev->id);
  	input_set_drvdata(input_dev, wacom);
  
 -	return input_dev;
 -}
 +	wacom_wac->input = input_dev;
 +	error = wacom_setup_input_capabilities(input_dev, wacom_wac);
 +	if (error)
 +		goto fail1;
 +
++<<<<<<< HEAD
 +	error = input_register_device(input_dev);
 +	if (error)
 +		goto fail2;
 +
 +	return 0;
  
 +fail2:
 +	input_free_device(input_dev);
 +	wacom_wac->input = NULL;
 +fail1:
++=======
+ static void wacom_clean_inputs(struct wacom *wacom)
+ {
+ 	if (wacom->wacom_wac.pen_input) {
+ 		if (wacom->wacom_wac.pen_registered)
+ 			input_unregister_device(wacom->wacom_wac.pen_input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.pen_input);
+ 	}
+ 	if (wacom->wacom_wac.touch_input) {
+ 		if (wacom->wacom_wac.touch_registered)
+ 			input_unregister_device(wacom->wacom_wac.touch_input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.touch_input);
+ 	}
+ 	if (wacom->wacom_wac.pad_input) {
+ 		if (wacom->wacom_wac.pad_registered)
+ 			input_unregister_device(wacom->wacom_wac.pad_input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.pad_input);
+ 	}
+ 	if (wacom->remote_dir)
+ 		kobject_put(wacom->remote_dir);
+ 	wacom->wacom_wac.pen_input = NULL;
+ 	wacom->wacom_wac.touch_input = NULL;
+ 	wacom->wacom_wac.pad_input = NULL;
+ 	wacom_destroy_leds(wacom);
+ }
+ 
+ static int wacom_allocate_inputs(struct wacom *wacom)
+ {
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	wacom_wac->pen_input = wacom_allocate_input(wacom);
+ 	wacom_wac->touch_input = wacom_allocate_input(wacom);
+ 	wacom_wac->pad_input = wacom_allocate_input(wacom);
+ 	if (!wacom_wac->pen_input || !wacom_wac->touch_input || !wacom_wac->pad_input) {
+ 		wacom_clean_inputs(wacom);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	wacom_wac->pen_input->name = wacom_wac->pen_name;
+ 	wacom_wac->touch_input->name = wacom_wac->touch_name;
+ 	wacom_wac->pad_input->name = wacom_wac->pad_name;
+ 
+ 	return 0;
+ }
+ 
+ static int wacom_register_inputs(struct wacom *wacom)
+ {
+ 	struct input_dev *pen_input_dev, *touch_input_dev, *pad_input_dev;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 	int error = 0;
+ 
+ 	pen_input_dev = wacom_wac->pen_input;
+ 	touch_input_dev = wacom_wac->touch_input;
+ 	pad_input_dev = wacom_wac->pad_input;
+ 
+ 	if (!pen_input_dev || !touch_input_dev || !pad_input_dev)
+ 		return -EINVAL;
+ 
+ 	error = wacom_setup_pen_input_capabilities(pen_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no pen in use on this interface */
+ 		input_free_device(pen_input_dev);
+ 		wacom_wac->pen_input = NULL;
+ 		pen_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(pen_input_dev);
+ 		if (error)
+ 			goto fail_register_pen_input;
+ 		wacom_wac->pen_registered = true;
+ 	}
+ 
+ 	error = wacom_setup_touch_input_capabilities(touch_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no touch in use on this interface */
+ 		input_free_device(touch_input_dev);
+ 		wacom_wac->touch_input = NULL;
+ 		touch_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(touch_input_dev);
+ 		if (error)
+ 			goto fail_register_touch_input;
+ 		wacom_wac->touch_registered = true;
+ 	}
+ 
+ 	error = wacom_setup_pad_input_capabilities(pad_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no pad in use on this interface */
+ 		input_free_device(pad_input_dev);
+ 		wacom_wac->pad_input = NULL;
+ 		pad_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(pad_input_dev);
+ 		if (error)
+ 			goto fail_register_pad_input;
+ 		wacom_wac->pad_registered = true;
+ 
+ 		error = wacom_initialize_leds(wacom);
+ 		if (error)
+ 			goto fail_leds;
+ 
+ 		error = wacom_initialize_remote(wacom);
+ 		if (error)
+ 			goto fail_remote;
+ 	}
+ 
+ 	return 0;
+ 
+ fail_remote:
+ 	wacom_destroy_leds(wacom);
+ fail_leds:
+ 	input_unregister_device(pad_input_dev);
+ 	pad_input_dev = NULL;
+ 	wacom_wac->pad_registered = false;
+ fail_register_pad_input:
+ 	input_unregister_device(touch_input_dev);
+ 	wacom_wac->touch_input = NULL;
+ 	wacom_wac->touch_registered = false;
+ fail_register_touch_input:
+ 	input_unregister_device(pen_input_dev);
+ 	wacom_wac->pen_input = NULL;
+ 	wacom_wac->pen_registered = false;
+ fail_register_pen_input:
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
  	return error;
  }
  
diff --cc drivers/hid/wacom_wac.c
index bdf17efa93aa,391a68731fe3..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1469,11 -2400,40 +1600,48 @@@ void wacom_setup_device_quirks(struct w
  		features->y_max = 1023;
  	}
  
++<<<<<<< HEAD
 +	/* these device have multiple inputs */
 +	if (features->type >= WIRELESS ||
 +	    (features->type >= INTUOS5S && features->type <= INTUOSPL) ||
 +	    (features->oVid && features->oPid))
 +		features->quirks |= WACOM_QUIRK_MULTI_INPUT;
++=======
+ 	/*
+ 	 * Intuos5/Pro and Bamboo 3rd gen have no useful data about its
+ 	 * touch interface in its HID descriptor. If this is the touch
+ 	 * interface (PacketSize of WACOM_PKGLEN_BBTOUCH3), override the
+ 	 * tablet values.
+ 	 */
+ 	if ((features->type >= INTUOS5S && features->type <= INTUOSHT) ||
+ 		(features->type == BAMBOO_PT)) {
+ 		if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 			if (features->touch_max)
+ 				features->device_type |= WACOM_DEVICETYPE_TOUCH;
+ 			if (features->type == BAMBOO_PT || features->type == INTUOSHT)
+ 				features->device_type |= WACOM_DEVICETYPE_PAD;
+ 
+ 			features->x_max = 4096;
+ 			features->y_max = 4096;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Raw Wacom-mode pen and touch events both come from interface
+ 	 * 0, whose HID descriptor has an application usage of 0xFF0D
+ 	 * (i.e., WACOM_VENDORDEFINED_PEN). We route pen packets back
+ 	 * out through the HID_GENERIC device created for interface 1,
+ 	 * so rewrite this one to be of type WACOM_DEVICETYPE_TOUCH.
+ 	 */
+ 	if (features->type == BAMBOO_PAD)
+ 		features->device_type = WACOM_DEVICETYPE_TOUCH;
+ 
+ 	if (features->type == REMOTE)
+ 		features->device_type = WACOM_DEVICETYPE_PAD;
+ 
+ 	if (wacom->hdev->bus == BUS_BLUETOOTH)
+ 		features->quirks |= WACOM_QUIRK_BATTERY;
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
  
  	/* quirk for bamboo touch with 2 low res touches */
  	if (features->type == BAMBOO_PT &&
@@@ -1798,38 -2598,267 +1966,200 @@@ int wacom_setup_input_capabilities(stru
  		__clear_bit(ABS_MISC, input_dev->absbit);
  
  		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
 -		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 -		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 -		__set_bit(BTN_STYLUS, input_dev->keybit);
 -		__set_bit(BTN_STYLUS2, input_dev->keybit);
 -		input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 -				      features->distance_max,
 -				      0, 0);
 -		break;
 -	case BAMBOO_PAD:
 -		__clear_bit(ABS_MISC, input_dev->absbit);
 -		break;
 -	}
 -	return 0;
 -}
 -
 -int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
 -					 struct wacom_wac *wacom_wac)
 -{
 -	struct wacom_features *features = &wacom_wac->features;
 -
 -	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
 -
 -	if (!(features->device_type & WACOM_DEVICETYPE_TOUCH))
 -		return -ENODEV;
 -
 -	if (features->type == HID_GENERIC)
 -		/* setup has already been done */
 -		return 0;
 -
 -	__set_bit(BTN_TOUCH, input_dev->keybit);
 -
 -	if (features->touch_max == 1) {
 -		input_set_abs_params(input_dev, ABS_X, 0,
 -			features->x_max, features->x_fuzz, 0);
 -		input_set_abs_params(input_dev, ABS_Y, 0,
 -			features->y_max, features->y_fuzz, 0);
 -		input_abs_set_res(input_dev, ABS_X,
 -				  features->x_resolution);
 -		input_abs_set_res(input_dev, ABS_Y,
 -				  features->y_resolution);
 -	}
 -	else if (features->touch_max > 1) {
 -		input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
 -			features->x_max, features->x_fuzz, 0);
 -		input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
 -			features->y_max, features->y_fuzz, 0);
 -		input_abs_set_res(input_dev, ABS_MT_POSITION_X,
 -				  features->x_resolution);
 -		input_abs_set_res(input_dev, ABS_MT_POSITION_Y,
 -				  features->y_resolution);
 -	}
 -
 -	switch (features->type) {
 -	case INTUOS5:
 -	case INTUOS5L:
 -	case INTUOSPM:
 -	case INTUOSPL:
 -	case INTUOS5S:
 -	case INTUOSPS:
 -		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
 -
 -		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
 -		input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, features->y_max, 0, 0);
 -		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
 -		break;
 -
 -	case WACOM_24HDT:
 -		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
 -		input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
 -		input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
 -		input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
 -		/* fall through */
 -
 -	case WACOM_27QHDT:
 -	case MTSCREEN:
 -	case MTTPC:
 -	case MTTPC_B:
 -	case TABLETPC2FG:
 -		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);
 -		/*fall through */
 -
 -	case TABLETPC:
 -	case TABLETPCE:
 -		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
 -		break;
 -
 -	case INTUOSHT:
 -		input_dev->evbit[0] |= BIT_MASK(EV_SW);
 -		__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
 -		/* fall through */
  
 -	case BAMBOO_PT:
 -		if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
 -			input_set_abs_params(input_dev,
 -				     ABS_MT_TOUCH_MAJOR,
 -				     0, features->x_max, 0, 0);
 -			input_set_abs_params(input_dev,
 -				     ABS_MT_TOUCH_MINOR,
 -				     0, features->y_max, 0, 0);
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			unsigned int flags = INPUT_MT_POINTER;
 +
 +			__set_bit(BTN_LEFT, input_dev->keybit);
 +			__set_bit(BTN_FORWARD, input_dev->keybit);
 +			__set_bit(BTN_BACK, input_dev->keybit);
 +			__set_bit(BTN_RIGHT, input_dev->keybit);
 +
 +			if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MAJOR,
 +						     0, features->x_max, 0, 0);
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MINOR,
 +						     0, features->y_max, 0, 0);
 +			} else {
 +				__set_bit(BTN_TOOL_FINGER, input_dev->keybit);
 +				__set_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);
 +				flags = 0;
 +			}
 +			input_mt_init_slots(input_dev, features->touch_max, flags);
 +		} else if (features->device_type == BTN_TOOL_PEN) {
 +			__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +			__set_bit(BTN_STYLUS, input_dev->keybit);
 +			__set_bit(BTN_STYLUS2, input_dev->keybit);
 +			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 +					      features->distance_max,
 +					      0, 0);
  		}
 -		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
  		break;
++<<<<<<< HEAD
++=======
+ 
+ 	case BAMBOO_PAD:
+ 		input_mt_init_slots(input_dev, features->touch_max,
+ 				    INPUT_MT_POINTER);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ void wacom_setup_numbered_buttons(struct input_dev *input_dev,
+ 				int button_count)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < button_count && i < 10; i++)
+ 		__set_bit(BTN_0 + i, input_dev->keybit);
+ 	for (i = 10; i < button_count && i < 16; i++)
+ 		__set_bit(BTN_A + (i-10), input_dev->keybit);
+ 	for (i = 16; i < button_count && i < 18; i++)
+ 		__set_bit(BTN_BASE + (i-16), input_dev->keybit);
+ }
+ 
+ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_PAD))
+ 		return -ENODEV;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	/* kept for making legacy xf86-input-wacom working with the wheels */
+ 	__set_bit(ABS_MISC, input_dev->absbit);
+ 
+ 	/* kept for making legacy xf86-input-wacom accepting the pad */
+ 	input_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);
+ 
+ 	/* kept for making udev and libwacom accepting the pad */
+ 	__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 	wacom_setup_numbered_buttons(input_dev, features->numbered_buttons);
+ 
+ 	switch (features->type) {
+ 
+ 	case CINTIQ_HYBRID:
+ 	case DTK:
+ 	case DTUS:
+ 	case GRAPHIRE_BT:
+ 		break;
+ 
+ 	case WACOM_MO:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_G4:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
+ 		break;
+ 
+ 	case WACOM_24HD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_THROTTLE, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_27QHD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_X, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_X, 1024); /* points/g */
+ 		input_set_abs_params(input_dev, ABS_Y, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Y, 1024);
+ 		input_set_abs_params(input_dev, ABS_Z, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 1024);
+ 		__set_bit(INPUT_PROP_ACCELEROMETER, input_dev->propbit);
+ 		break;
+ 
+ 	case WACOM_22HD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case WACOM_21UX2:
+ 	case WACOM_BEE:
+ 	case CINTIQ:
+ 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
+ 		break;
+ 
+ 	case WACOM_13HD:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOS3:
+ 	case INTUOS3L:
+ 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
+ 		/* fall through */
+ 
+ 	case INTUOS3S:
+ 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
+ 		break;
+ 
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOS4WL:
+ 		/*
+ 		 * For Bluetooth devices, the udev rule does not work correctly
+ 		 * for pads unless we add a stylus capability, which forces
+ 		 * ID_INPUT_TABLET to be set.
+ 		 */
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case INTUOS4:
+ 	case INTUOS4L:
+ 	case INTUOS4S:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 	case BAMBOO_PT:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 
+ 		break;
+ 
+ 	case REMOTE:
+ 		input_set_capability(input_dev, EV_MSC, MSC_SERIAL);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	default:
+ 		/* no pad supported */
+ 		return -ENODEV;
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
  	}
  	return 0;
  }
@@@ -2103,136 -3157,201 +2433,173 @@@ static const struct wacom_features waco
  	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x5e };
  static const struct wacom_features wacom_features_0x5E =
  	{ "Wacom Cintiq 22HDT", .type = WACOM_24HDT,
 -	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x5b, .touch_max = 10,
 -	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
 +	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x5b, .touch_max = 10 };
  static const struct wacom_features wacom_features_0x90 =
 -	{ "Wacom ISDv4 90", 26202, 16325, 255, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 90",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  255,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x93 =
 -	{ "Wacom ISDv4 93", 26202, 16325, 255, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 93",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  255,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x97 =
 -	{ "Wacom ISDv4 97", 26202, 16325, 511, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 97",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  511,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x9A =
 -	{ "Wacom ISDv4 9A", 26202, 16325, 255, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 9A",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  255,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x9F =
 -	{ "Wacom ISDv4 9F", 26202, 16325, 255, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 9F",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  255,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xE2 =
 -	{ "Wacom ISDv4 E2", 26202, 16325, 255, 0,
 -	  TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom ISDv4 E2",       WACOM_PKGLEN_TPC2FG,    26202, 16325,  255,
 +	  0, TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xE3 =
 -	{ "Wacom ISDv4 E3", 26202, 16325, 255, 0,
 -	  TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom ISDv4 E3",       WACOM_PKGLEN_TPC2FG,    26202, 16325,  255,
 +	  0, TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xE5 =
 -	{ "Wacom ISDv4 E5", 26202, 16325, 255, 0,
 -	  MTSCREEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 E5",       WACOM_PKGLEN_MTOUCH,    26202, 16325,  255,
 +	  0, MTSCREEN, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xE6 =
 -	{ "Wacom ISDv4 E6", 27760, 15694, 255, 0,
 -	  TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom ISDv4 E6",       WACOM_PKGLEN_TPC2FG,    27760, 15694,  255,
 +	  0, TABLETPC2FG, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xEC =
 -	{ "Wacom ISDv4 EC", 25710, 14500, 255, 0,
 -	  TABLETPC,    WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 EC",       WACOM_PKGLEN_GRAPHIRE,  25710, 14500,  255,
 +	  0, TABLETPC,    WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xED =
 -	{ "Wacom ISDv4 ED", 26202, 16325, 255, 0,
 -	  TABLETPCE, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 ED",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  255,
 +	  0, TABLETPCE, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xEF =
 -	{ "Wacom ISDv4 EF", 26202, 16325, 255, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 EF",       WACOM_PKGLEN_GRAPHIRE,  26202, 16325,  255,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x100 =
 -	{ "Wacom ISDv4 100", 26202, 16325, 255, 0,
 -	  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 100",      WACOM_PKGLEN_MTTPC,     26202, 16325,  255,
 +	  0, MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x101 =
 -	{ "Wacom ISDv4 101", 26202, 16325, 255, 0,
 -	  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 101",      WACOM_PKGLEN_MTTPC,     26202, 16325,  255,
 +	  0, MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x10D =
 -	{ "Wacom ISDv4 10D", 26202, 16325, 255, 0,
 -	  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x10E =
 -	{ "Wacom ISDv4 10E", 27760, 15694, 255, 0,
 -	  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x10F =
 -	{ "Wacom ISDv4 10F", 27760, 15694, 255, 0,
 -	  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x116 =
 -	{ "Wacom ISDv4 116", 26202, 16325, 255, 0,
 -	  TABLETPCE, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x12C =
 -	{ "Wacom ISDv4 12C", 27848, 15752, 2047, 0,
 -	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 10D",      WACOM_PKGLEN_MTTPC,     26202, 16325,  255,
 +	  0, MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x4001 =
 -	{ "Wacom ISDv4 4001", 26202, 16325, 255, 0,
 -	  MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x4004 =
 -	{ "Wacom ISDv4 4004", 11060, 6220, 255, 0,
 -	  MTTPC_B, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x5000 =
 -	{ "Wacom ISDv4 5000", 27848, 15752, 1023, 0,
 -	  MTTPC_B, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x5002 =
 -	{ "Wacom ISDv4 5002", 29576, 16724, 1023, 0,
 -	  MTTPC_B, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom ISDv4 4001",      WACOM_PKGLEN_MTTPC,     26202, 16325,  255,
 +	  0, MTTPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x47 =
 -	{ "Wacom Intuos2 6x8", 20320, 16240, 1023, 31,
 -	  INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom Intuos2 6x8",    WACOM_PKGLEN_INTUOS,    20320, 16240, 1023,
 +	  31, INTUOS, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0x84 =
 -	{ "Wacom Wireless Receiver", 0, 0, 0, 0,
 -	  WIRELESS, 0, 0, .touch_max = 16 };
 +	{ "Wacom Wireless Receiver", WACOM_PKGLEN_WIRELESS, 0, 0, 0,
 +	  0, WIRELESS, 0, 0, .touch_max = 16 };
  static const struct wacom_features wacom_features_0xD0 =
 -	{ "Wacom Bamboo 2FG", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom Bamboo 2FG",     WACOM_PKGLEN_BBFUN,     14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xD1 =
 -	{ "Wacom Bamboo 2FG 4x5", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom Bamboo 2FG 4x5", WACOM_PKGLEN_BBFUN,     14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xD2 =
 -	{ "Wacom Bamboo Craft", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom Bamboo Craft",   WACOM_PKGLEN_BBFUN,     14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xD3 =
 -	{ "Wacom Bamboo 2FG 6x8", 21648, 13700, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom Bamboo 2FG 6x8", WACOM_PKGLEN_BBFUN,     21648, 13700, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xD4 =
 -	{ "Wacom Bamboo Pen", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom Bamboo Pen",     WACOM_PKGLEN_BBFUN,     14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xD5 =
 -	{ "Wacom Bamboo Pen 6x8", 21648, 13700, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +	{ "Wacom Bamboo Pen 6x8",     WACOM_PKGLEN_BBFUN, 21648, 13700, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xD6 =
 -	{ "Wacom BambooPT 2FG 4x5", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom BambooPT 2FG 4x5", WACOM_PKGLEN_BBFUN,   14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xD7 =
 -	{ "Wacom BambooPT 2FG Small", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom BambooPT 2FG Small", WACOM_PKGLEN_BBFUN, 14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xD8 =
 -	{ "Wacom Bamboo Comic 2FG", 21648, 13700, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom Bamboo Comic 2FG", WACOM_PKGLEN_BBFUN,   21648, 13700, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xDA =
 -	{ "Wacom Bamboo 2FG 4x5 SE", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 -static const struct wacom_features wacom_features_0xDB =
 -	{ "Wacom Bamboo 2FG 6x8 SE", 21648, 13700, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 2 };
 +	{ "Wacom Bamboo 2FG 4x5 SE", WACOM_PKGLEN_BBFUN,  14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
 +static struct wacom_features wacom_features_0xDB =
 +	{ "Wacom Bamboo 2FG 6x8 SE", WACOM_PKGLEN_BBFUN,  21648, 13700, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 2 };
  static const struct wacom_features wacom_features_0xDD =
 -        { "Wacom Bamboo Connect", 14720, 9200, 1023, 31,
 -          BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 +        { "Wacom Bamboo Connect", WACOM_PKGLEN_BBPEN,     14720,  9200, 1023,
 +          31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
  static const struct wacom_features wacom_features_0xDE =
 -        { "Wacom Bamboo 16FG 4x5", 14720, 9200, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16 };
 +        { "Wacom Bamboo 16FG 4x5", WACOM_PKGLEN_BBPEN,    14720,  9200, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 16 };
  static const struct wacom_features wacom_features_0xDF =
 -        { "Wacom Bamboo 16FG 6x8", 21648, 13700, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16 };
 -static const struct wacom_features wacom_features_0x300 =
 -	{ "Wacom Bamboo One S", 14720, 9225, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x301 =
 -	{ "Wacom Bamboo One M", 21648, 13530, 1023, 31,
 -	  BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
 -static const struct wacom_features wacom_features_0x302 =
 -	{ "Wacom Intuos PT S", 15200, 9500, 1023, 31,
 -	  INTUOSHT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16,
 -	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
 -static const struct wacom_features wacom_features_0x303 =
 -	{ "Wacom Intuos PT M", 21600, 13500, 1023, 31,
 -	  INTUOSHT, WACOM_INTUOS_RES, WACOM_INTUOS_RES, .touch_max = 16,
 -	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
 -static const struct wacom_features wacom_features_0x30E =
 -	{ "Wacom Intuos S", 15200, 9500, 1023, 31,
 -	  INTUOSHT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 -	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
 +        { "Wacom Bamboo 16FG 6x8", WACOM_PKGLEN_BBPEN,    21648, 13700, 1023,
 +	  31, BAMBOO_PT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
 +	  .touch_max = 16 };
  static const struct wacom_features wacom_features_0x6004 =
++<<<<<<< HEAD
 +	{ "ISD-V4",               WACOM_PKGLEN_GRAPHIRE,  12800,  8000,  255,
 +	  0, TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
++=======
+ 	{ "ISD-V4", 12800, 8000, 255, 0,
+ 	  TABLETPC, WACOM_INTUOS_RES, WACOM_INTUOS_RES };
+ static const struct wacom_features wacom_features_0x307 =
+ 	{ "Wacom ISDv5 307", 59152, 33448, 2047, 63,
+ 	  CINTIQ_HYBRID, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9,
+ 	  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,
+ 	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x309 };
+ static const struct wacom_features wacom_features_0x309 =
+ 	{ "Wacom ISDv5 309", .type = WACOM_24HDT, /* Touch */
+ 	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x0307, .touch_max = 10,
+ 	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
+ static const struct wacom_features wacom_features_0x30A =
+ 	{ "Wacom ISDv5 30A", 59152, 33448, 2047, 63,
+ 	  CINTIQ_HYBRID, WACOM_INTUOS3_RES, WACOM_INTUOS3_RES, 9,
+ 	  WACOM_CINTIQ_OFFSET, WACOM_CINTIQ_OFFSET,
+ 	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x30C };
+ static const struct wacom_features wacom_features_0x30C =
+ 	{ "Wacom ISDv5 30C", .type = WACOM_24HDT, /* Touch */
+ 	  .oVid = USB_VENDOR_ID_WACOM, .oPid = 0x30A, .touch_max = 10,
+ 	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
+ static const struct wacom_features wacom_features_0x318 =
+ 	{ "Wacom USB Bamboo PAD", 4095, 4095, /* Touch */
+ 	  .type = BAMBOO_PAD, 35, 48, .touch_max = 4 };
+ static const struct wacom_features wacom_features_0x319 =
+ 	{ "Wacom Wireless Bamboo PAD", 4095, 4095, /* Touch */
+ 	  .type = BAMBOO_PAD, 35, 48, .touch_max = 4 };
+ static const struct wacom_features wacom_features_0x323 =
+ 	{ "Wacom Intuos P M", 21600, 13500, 1023, 31,
+ 	  INTUOSHT, WACOM_INTUOS_RES, WACOM_INTUOS_RES,
+ 	  .check_for_hid_type = true, .hid_type = HID_TYPE_USBNONE };
+ static const struct wacom_features wacom_features_0x331 =
+ 	{ "Wacom Express Key Remote", 0, 0, 0, 0,
+ 	  REMOTE, 0, 0, 18, .check_for_hid_type = true,
+ 	  .hid_type = HID_TYPE_USBNONE };
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
  
 -static const struct wacom_features wacom_features_HID_ANY_ID =
 -	{ "Wacom HID", .type = HID_GENERIC };
 -
 -#define USB_DEVICE_WACOM(prod)						\
 -	HID_DEVICE(BUS_USB, HID_GROUP_WACOM, USB_VENDOR_ID_WACOM, prod),\
 -	.driver_data = (kernel_ulong_t)&wacom_features_##prod
 +#define USB_DEVICE_WACOM(prod)					\
 +	USB_DEVICE(USB_VENDOR_ID_WACOM, prod),			\
 +	.driver_info = (kernel_ulong_t)&wacom_features_##prod
  
 -#define BT_DEVICE_WACOM(prod)						\
 -	HID_DEVICE(BUS_BLUETOOTH, HID_GROUP_WACOM, USB_VENDOR_ID_WACOM, prod),\
 -	.driver_data = (kernel_ulong_t)&wacom_features_##prod
 -
 -#define I2C_DEVICE_WACOM(prod)						\
 -	HID_DEVICE(BUS_I2C, HID_GROUP_WACOM, USB_VENDOR_ID_WACOM, prod),\
 -	.driver_data = (kernel_ulong_t)&wacom_features_##prod
 +#define USB_DEVICE_DETAILED(prod, class, sub, proto)			\
 +	USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_WACOM, prod, class,	\
 +				      sub, proto),			\
 +	.driver_info = (kernel_ulong_t)&wacom_features_##prod
  
  #define USB_DEVICE_LENOVO(prod)					\
 -	HID_USB_DEVICE(USB_VENDOR_ID_LENOVO, prod),			\
 -	.driver_data = (kernel_ulong_t)&wacom_features_##prod
 +	USB_DEVICE(USB_VENDOR_ID_LENOVO, prod),			\
 +	.driver_info = (kernel_ulong_t)&wacom_features_##prod
  
 -const struct hid_device_id wacom_ids[] = {
 +const struct usb_device_id wacom_ids[] = {
  	{ USB_DEVICE_WACOM(0x00) },
 -	{ USB_DEVICE_WACOM(0x03) },
  	{ USB_DEVICE_WACOM(0x10) },
  	{ USB_DEVICE_WACOM(0x11) },
  	{ USB_DEVICE_WACOM(0x12) },
@@@ -2347,13 -3483,19 +2714,21 @@@
  	{ USB_DEVICE_WACOM(0x32A) },
  	{ USB_DEVICE_WACOM(0x32B) },
  	{ USB_DEVICE_WACOM(0x32C) },
++<<<<<<< HEAD
++=======
+ 	{ USB_DEVICE_WACOM(0x32F) },
+ 	{ USB_DEVICE_WACOM(0x331) },
+ 	{ USB_DEVICE_WACOM(0x333) },
+ 	{ USB_DEVICE_WACOM(0x335) },
+ 	{ USB_DEVICE_WACOM(0x336) },
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
  	{ USB_DEVICE_WACOM(0x4001) },
 -	{ USB_DEVICE_WACOM(0x4004) },
 -	{ USB_DEVICE_WACOM(0x5000) },
 -	{ USB_DEVICE_WACOM(0x5002) },
 +	{ USB_DEVICE_WACOM(0x47) },
 +	{ USB_DEVICE_WACOM(0xF4) },
 +	{ USB_DEVICE_WACOM(0xF8) },
 +	{ USB_DEVICE_DETAILED(0xF6, USB_CLASS_HID, 0, 0) },
 +	{ USB_DEVICE_WACOM(0xFA) },
  	{ USB_DEVICE_LENOVO(0x6004) },
 -
 -	{ USB_DEVICE_WACOM(HID_ANY_ID) },
 -	{ I2C_DEVICE_WACOM(HID_ANY_ID) },
  	{ }
  };
 -MODULE_DEVICE_TABLE(hid, wacom_ids);
 +MODULE_DEVICE_TABLE(usb, wacom_ids);
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,1e270d401e18..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -15,13 -16,13 +15,15 @@@
  #define WACOM_PKGLEN_MAX	192
  
  #define WACOM_NAME_MAX		64
+ #define WACOM_MAX_REMOTES	5
+ #define WACOM_STATUS_UNKNOWN	255
  
  /* packet length for individual models */
 +#define WACOM_PKGLEN_PENPRTN	 7
 +#define WACOM_PKGLEN_GRAPHIRE	 8
  #define WACOM_PKGLEN_BBFUN	 9
 +#define WACOM_PKGLEN_INTUOS	10
  #define WACOM_PKGLEN_TPC1FG	 5
 -#define WACOM_PKGLEN_TPC1FG_B	10
  #define WACOM_PKGLEN_TPC2FG	14
  #define WACOM_PKGLEN_BBTOUCH	20
  #define WACOM_PKGLEN_BBTOUCH3	64
@@@ -53,16 -54,44 +55,25 @@@
  #define WACOM_REPORT_TPC1FG		6
  #define WACOM_REPORT_TPC2FG		13
  #define WACOM_REPORT_TPCMT		13
 -#define WACOM_REPORT_TPCMT2		3
  #define WACOM_REPORT_TPCHID		15
 -#define WACOM_REPORT_CINTIQ		16
 -#define WACOM_REPORT_CINTIQPAD		17
  #define WACOM_REPORT_TPCST		16
 -#define WACOM_REPORT_DTUS		17
  #define WACOM_REPORT_TPC1FGE		18
  #define WACOM_REPORT_24HDT		1
++<<<<<<< HEAD
++=======
+ #define WACOM_REPORT_WL			128
+ #define WACOM_REPORT_USB		192
+ #define WACOM_REPORT_BPAD_PEN		3
+ #define WACOM_REPORT_BPAD_TOUCH		16
+ #define WACOM_REPORT_DEVICE_LIST	16
+ #define WACOM_REPORT_REMOTE		17
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
  
  /* device quirks */
 -#define WACOM_QUIRK_BBTOUCH_LOWRES	0x0001
 -#define WACOM_QUIRK_BATTERY		0x0008
 -
 -/* device types */
 -#define WACOM_DEVICETYPE_NONE           0x0000
 -#define WACOM_DEVICETYPE_PEN            0x0001
 -#define WACOM_DEVICETYPE_TOUCH          0x0002
 -#define WACOM_DEVICETYPE_PAD            0x0004
 -#define WACOM_DEVICETYPE_WL_MONITOR     0x0008
 -
 -#define WACOM_VENDORDEFINED_PEN		0xff0d0001
 -
 -#define WACOM_PEN_FIELD(f)	(((f)->logical == HID_DG_STYLUS) || \
 -				 ((f)->physical == HID_DG_STYLUS) || \
 -				 ((f)->physical == HID_DG_PEN) || \
 -				 ((f)->application == HID_DG_PEN) || \
 -				 ((f)->application == HID_DG_DIGITIZER) || \
 -				 ((f)->application == WACOM_VENDORDEFINED_PEN))
 -#define WACOM_FINGER_FIELD(f)	(((f)->logical == HID_DG_FINGER) || \
 -				 ((f)->physical == HID_DG_FINGER) || \
 -				 ((f)->application == HID_DG_TOUCHSCREEN))
 +#define WACOM_QUIRK_MULTI_INPUT		0x0001
 +#define WACOM_QUIRK_BBTOUCH_LOWRES	0x0002
 +#define WACOM_QUIRK_NO_INPUT		0x0004
 +#define WACOM_QUIRK_MONITOR		0x0008
  
  enum {
  	PENPARTNER = 0,
@@@ -97,6 -132,8 +108,11 @@@
  	BAMBOO_PT,
  	WACOM_24HDT,
  	WACOM_27QHDT,
++<<<<<<< HEAD
++=======
+ 	BAMBOO_PAD,
+ 	REMOTE,
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
  	TABLETPC,   /* add new TPC below */
  	TABLETPCE,
  	TABLETPC2FG,
@@@ -138,14 -181,48 +154,19 @@@ struct wacom_shared 
  };
  
  struct wacom_wac {
 -	char pen_name[WACOM_NAME_MAX];
 -	char touch_name[WACOM_NAME_MAX];
 -	char pad_name[WACOM_NAME_MAX];
 -	char bat_name[WACOM_NAME_MAX];
 -	char ac_name[WACOM_NAME_MAX];
 -	unsigned char data[WACOM_PKGLEN_MAX];
 +	char name[WACOM_NAME_MAX];
 +	unsigned char *data;
  	int tool[2];
  	int id[2];
++<<<<<<< HEAD
 +	__u32 serial[2];
++=======
+ 	__u32 serial[5];
+ 	bool reporting_data;
++>>>>>>> 72b236d60218 (HID: wacom: Add support for Express Key Remote.)
  	struct wacom_features features;
  	struct wacom_shared *shared;
 -	struct input_dev *pen_input;
 -	struct input_dev *touch_input;
 -	struct input_dev *pad_input;
 -	bool pen_registered;
 -	bool touch_registered;
 -	bool pad_registered;
 +	struct input_dev *input;
  	int pid;
  	int battery_capacity;
  	int num_contacts_left;
* Unmerged path Documentation/ABI/testing/sysfs-driver-wacom
* Unmerged path drivers/hid/wacom.h
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
* Unmerged path drivers/hid/wacom_wac.h
