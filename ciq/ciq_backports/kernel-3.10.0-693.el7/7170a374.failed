tools/power turbostat: Denverton: use HW CC1 counter, skip C3, C7

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [tools] power turbostat: denverton: use HW CC1 counter, skip C3, C7 (Prarit Bhargava) [1447265]
Rebuild_FUZZ: 95.16%
commit-author Len Brown <len.brown@intel.com>
commit 7170a374377d7c70d63a2d3eb38f8fe32e6ffadd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7170a374.failed

The CC1 column in tubostat can be computed by subtracting
the core c-state residency countes from the total Cx residency.

CC1 = (Idle_time_as_measured by MPERF) - (all core C-states with
residency counters)

However, as the underlying counter reads are not atomic,
error can be noticed in this calculations, especially
when the numbers are small.

Denverton has a hardware CC1 residency counter
to improve the accuracy of the cc1 statistic -- use it.

At the same time, Denverton has no concept of CC3, PC3, CC7, PC7,
so skip collecting and printing those columns.

Finally, a note of clarification.
Turbostat prints the standard PC2 residency counter,
but on Denverton hardware, that actually means PC1E.
Turbostat prints the standard PC6 residency counter,
but on Denverton hardware, that actually means PC2.

At this point, we document that differnce in this commit message,
rather than adding a quirk to the software.

	Signed-off-by: Len Brown <len.brown@intel.com>
(cherry picked from commit 7170a374377d7c70d63a2d3eb38f8fe32e6ffadd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/power/x86/turbostat/turbostat.c
diff --cc tools/power/x86/turbostat/turbostat.c
index 92e6f5e6c99d,1010135ee973..000000000000
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@@ -1882,13 -2552,50 +1882,49 @@@ int probe_nhm_msrs(unsigned int family
  	has_base_hz = 1;
  	return 1;
  }
++<<<<<<< HEAD
++=======
+ /*
+  * SLV client has supporet for unique MSRs:
+  *
+  * MSR_CC6_DEMOTION_POLICY_CONFIG
+  * MSR_MC6_DEMOTION_POLICY_CONFIG
+  */
+ 
+ int has_slv_msrs(unsigned int family, unsigned int model)
+ {
+ 	if (!genuine_intel)
+ 		return 0;
+ 
+ 	switch (model) {
+ 	case INTEL_FAM6_ATOM_SILVERMONT1:
+ 	case INTEL_FAM6_ATOM_MERRIFIELD:
+ 	case INTEL_FAM6_ATOM_MOOREFIELD:
+ 		return 1;
+ 	}
+ 	return 0;
+ }
+ int is_dnv(unsigned int family, unsigned int model)
+ {
+ 
+ 	if (!genuine_intel)
+ 		return 0;
+ 
+ 	switch (model) {
+ 	case INTEL_FAM6_ATOM_DENVERTON:
+ 		return 1;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 7170a374377d (tools/power turbostat: Denverton: use HW CC1 counter, skip C3, C7)
  int has_nhm_turbo_ratio_limit(unsigned int family, unsigned int model)
  {
 -	if (has_slv_msrs(family, model))
 -		return 0;
 -
  	switch (model) {
  	/* Nehalem compatible, but do not include turbo-ratio limit support */
 -	case INTEL_FAM6_NEHALEM_EX:	/* Nehalem-EX Xeon - Beckton */
 -	case INTEL_FAM6_WESTMERE_EX:	/* Westmere-EX Xeon - Eagleton */
 -	case INTEL_FAM6_XEON_PHI_KNL:	/* PHI - Knights Landing (different MSR definition) */
 -	case INTEL_FAM6_XEON_PHI_KNM:
 +	case 0x2E:	/* Nehalem-EX Xeon - Beckton */
 +	case 0x2F:	/* Westmere-EX Xeon - Eagleton */
 +	case 0x57:	/* PHI - Knights Landing (different MSR definition) */
  		return 0;
  	default:
  		return 1;
@@@ -2832,13 -3831,52 +2868,51 @@@ void process_cpuid(
  	if (has_aperf)
  		aperf_mperf_multiplier = get_aperf_mperf_multiplier(family, model);
  
 -	BIC_PRESENT(BIC_IRQ);
 -	BIC_PRESENT(BIC_TSC_MHz);
 -
 -	if (probe_nhm_msrs(family, model)) {
 -		do_nhm_platform_info = 1;
 -		BIC_PRESENT(BIC_CPU_c1);
 -		BIC_PRESENT(BIC_CPU_c3);
 -		BIC_PRESENT(BIC_CPU_c6);
 -		BIC_PRESENT(BIC_SMI);
 -	}
 +	do_nhm_platform_info = do_nhm_cstates = do_smi = probe_nhm_msrs(family, model);
  	do_snb_cstates = has_snb_msrs(family, model);
++<<<<<<< HEAD
 +	do_pc2 = do_snb_cstates && (pkg_cstate_limit >= PCL__2);
 +	do_pc3 = (pkg_cstate_limit >= PCL__3);
 +	do_pc6 = (pkg_cstate_limit >= PCL__6);
 +	do_pc7 = do_snb_cstates && (pkg_cstate_limit >= PCL__7);
 +	do_c8_c9_c10 = has_hsw_msrs(family, model);
++=======
+ 
+ 	if (do_snb_cstates)
+ 		BIC_PRESENT(BIC_CPU_c7);
+ 
+ 	do_irtl_snb = has_snb_msrs(family, model);
+ 	if (do_snb_cstates && (pkg_cstate_limit >= PCL__2))
+ 		BIC_PRESENT(BIC_Pkgpc2);
+ 	if (pkg_cstate_limit >= PCL__3)
+ 		BIC_PRESENT(BIC_Pkgpc3);
+ 	if (pkg_cstate_limit >= PCL__6)
+ 		BIC_PRESENT(BIC_Pkgpc6);
+ 	if (do_snb_cstates && (pkg_cstate_limit >= PCL__7))
+ 		BIC_PRESENT(BIC_Pkgpc7);
+ 	if (has_slv_msrs(family, model)) {
+ 		BIC_NOT_PRESENT(BIC_Pkgpc2);
+ 		BIC_NOT_PRESENT(BIC_Pkgpc3);
+ 		BIC_PRESENT(BIC_Pkgpc6);
+ 		BIC_NOT_PRESENT(BIC_Pkgpc7);
+ 		BIC_PRESENT(BIC_Mod_c6);
+ 		use_c1_residency_msr = 1;
+ 	}
+ 	if (is_dnv(family, model)) {
+ 		BIC_PRESENT(BIC_CPU_c1);
+ 		BIC_NOT_PRESENT(BIC_CPU_c3);
+ 		BIC_NOT_PRESENT(BIC_Pkgpc3);
+ 		BIC_NOT_PRESENT(BIC_CPU_c7);
+ 		BIC_NOT_PRESENT(BIC_Pkgpc7);
+ 		use_c1_residency_msr = 1;
+ 	}
+ 	if (has_hsw_msrs(family, model)) {
+ 		BIC_PRESENT(BIC_Pkgpc8);
+ 		BIC_PRESENT(BIC_Pkgpc9);
+ 		BIC_PRESENT(BIC_Pkgpc10);
+ 	}
+ 	do_irtl_hsw = has_hsw_msrs(family, model);
++>>>>>>> 7170a374377d (tools/power turbostat: Denverton: use HW CC1 counter, skip C3, C7)
  	do_skl_residency = has_skl_msrs(family, model);
  	do_slm_cstates = is_slm(family, model);
  	do_knl_cstates  = is_knl(family, model);
* Unmerged path tools/power/x86/turbostat/turbostat.c
