HID: wacom: wacom_setup_numbered_buttons is local to wacom_wac

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: wacom_setup_numbered_buttons is local to wacom_wac (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.80%
commit-author Jiri Kosina <jkosina@suse.cz>
commit 5397df15fd993acd23d9590dbb29d39219d80e3d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5397df15.failed

wacom_setup_numbered_buttons() is not used outside of wacom_wac.c,
make it static.

	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 5397df15fd993acd23d9590dbb29d39219d80e3d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index bdf17efa93aa,c40a6d14c8f2..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1798,38 -2598,267 +1798,200 @@@ int wacom_setup_input_capabilities(stru
  		__clear_bit(ABS_MISC, input_dev->absbit);
  
  		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
 -		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 -		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 -		__set_bit(BTN_STYLUS, input_dev->keybit);
 -		__set_bit(BTN_STYLUS2, input_dev->keybit);
 -		input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 -				      features->distance_max,
 -				      0, 0);
 -		break;
 -	case BAMBOO_PAD:
 -		__clear_bit(ABS_MISC, input_dev->absbit);
 -		break;
 -	}
 -	return 0;
 -}
 -
 -int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
 -					 struct wacom_wac *wacom_wac)
 -{
 -	struct wacom_features *features = &wacom_wac->features;
 -
 -	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
 -
 -	if (!(features->device_type & WACOM_DEVICETYPE_TOUCH))
 -		return -ENODEV;
 -
 -	if (features->type == HID_GENERIC)
 -		/* setup has already been done */
 -		return 0;
 -
 -	__set_bit(BTN_TOUCH, input_dev->keybit);
 -
 -	if (features->touch_max == 1) {
 -		input_set_abs_params(input_dev, ABS_X, 0,
 -			features->x_max, features->x_fuzz, 0);
 -		input_set_abs_params(input_dev, ABS_Y, 0,
 -			features->y_max, features->y_fuzz, 0);
 -		input_abs_set_res(input_dev, ABS_X,
 -				  features->x_resolution);
 -		input_abs_set_res(input_dev, ABS_Y,
 -				  features->y_resolution);
 -	}
 -	else if (features->touch_max > 1) {
 -		input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
 -			features->x_max, features->x_fuzz, 0);
 -		input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
 -			features->y_max, features->y_fuzz, 0);
 -		input_abs_set_res(input_dev, ABS_MT_POSITION_X,
 -				  features->x_resolution);
 -		input_abs_set_res(input_dev, ABS_MT_POSITION_Y,
 -				  features->y_resolution);
 -	}
 -
 -	switch (features->type) {
 -	case INTUOS5:
 -	case INTUOS5L:
 -	case INTUOSPM:
 -	case INTUOSPL:
 -	case INTUOS5S:
 -	case INTUOSPS:
 -		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
 -
 -		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
 -		input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, features->y_max, 0, 0);
 -		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
 -		break;
 -
 -	case WACOM_24HDT:
 -		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
 -		input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
 -		input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
 -		input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
 -		/* fall through */
 -
 -	case WACOM_27QHDT:
 -	case MTSCREEN:
 -	case MTTPC:
 -	case MTTPC_B:
 -	case TABLETPC2FG:
 -		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);
 -		/*fall through */
 -
 -	case TABLETPC:
 -	case TABLETPCE:
 -		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
 -		break;
 -
 -	case INTUOSHT:
 -		input_dev->evbit[0] |= BIT_MASK(EV_SW);
 -		__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
 -		/* fall through */
  
 -	case BAMBOO_PT:
 -		if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
 -			input_set_abs_params(input_dev,
 -				     ABS_MT_TOUCH_MAJOR,
 -				     0, features->x_max, 0, 0);
 -			input_set_abs_params(input_dev,
 -				     ABS_MT_TOUCH_MINOR,
 -				     0, features->y_max, 0, 0);
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			unsigned int flags = INPUT_MT_POINTER;
 +
 +			__set_bit(BTN_LEFT, input_dev->keybit);
 +			__set_bit(BTN_FORWARD, input_dev->keybit);
 +			__set_bit(BTN_BACK, input_dev->keybit);
 +			__set_bit(BTN_RIGHT, input_dev->keybit);
 +
 +			if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MAJOR,
 +						     0, features->x_max, 0, 0);
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MINOR,
 +						     0, features->y_max, 0, 0);
 +			} else {
 +				__set_bit(BTN_TOOL_FINGER, input_dev->keybit);
 +				__set_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);
 +				flags = 0;
 +			}
 +			input_mt_init_slots(input_dev, features->touch_max, flags);
 +		} else if (features->device_type == BTN_TOOL_PEN) {
 +			__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +			__set_bit(BTN_STYLUS, input_dev->keybit);
 +			__set_bit(BTN_STYLUS2, input_dev->keybit);
 +			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 +					      features->distance_max,
 +					      0, 0);
  		}
 -		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
  		break;
++<<<<<<< HEAD
++=======
+ 
+ 	case BAMBOO_PAD:
+ 		input_mt_init_slots(input_dev, features->touch_max,
+ 				    INPUT_MT_POINTER);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static void wacom_setup_numbered_buttons(struct input_dev *input_dev,
+ 				int button_count)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < button_count && i < 10; i++)
+ 		__set_bit(BTN_0 + i, input_dev->keybit);
+ 	for (i = 10; i < button_count && i < 16; i++)
+ 		__set_bit(BTN_A + (i-10), input_dev->keybit);
+ 	for (i = 16; i < button_count && i < 18; i++)
+ 		__set_bit(BTN_BASE + (i-16), input_dev->keybit);
+ }
+ 
+ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_PAD))
+ 		return -ENODEV;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	/* kept for making legacy xf86-input-wacom working with the wheels */
+ 	__set_bit(ABS_MISC, input_dev->absbit);
+ 
+ 	/* kept for making legacy xf86-input-wacom accepting the pad */
+ 	input_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);
+ 
+ 	/* kept for making udev and libwacom accepting the pad */
+ 	__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 	wacom_setup_numbered_buttons(input_dev, features->numbered_buttons);
+ 
+ 	switch (features->type) {
+ 
+ 	case CINTIQ_HYBRID:
+ 	case DTK:
+ 	case DTUS:
+ 	case GRAPHIRE_BT:
+ 		break;
+ 
+ 	case WACOM_MO:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_G4:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
+ 		break;
+ 
+ 	case WACOM_24HD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_THROTTLE, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_27QHD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_X, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_X, 1024); /* points/g */
+ 		input_set_abs_params(input_dev, ABS_Y, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Y, 1024);
+ 		input_set_abs_params(input_dev, ABS_Z, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 1024);
+ 		__set_bit(INPUT_PROP_ACCELEROMETER, input_dev->propbit);
+ 		break;
+ 
+ 	case WACOM_22HD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case WACOM_21UX2:
+ 	case WACOM_BEE:
+ 	case CINTIQ:
+ 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
+ 		break;
+ 
+ 	case WACOM_13HD:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOS3:
+ 	case INTUOS3L:
+ 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
+ 		/* fall through */
+ 
+ 	case INTUOS3S:
+ 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
+ 		break;
+ 
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOS4WL:
+ 		/*
+ 		 * For Bluetooth devices, the udev rule does not work correctly
+ 		 * for pads unless we add a stylus capability, which forces
+ 		 * ID_INPUT_TABLET to be set.
+ 		 */
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case INTUOS4:
+ 	case INTUOS4L:
+ 	case INTUOS4S:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 	case BAMBOO_PT:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 
+ 		break;
+ 
+ 	case REMOTE:
+ 		input_set_capability(input_dev, EV_MSC, MSC_SERIAL);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	default:
+ 		/* no pad supported */
+ 		return -ENODEV;
++>>>>>>> 5397df15fd99 (HID: wacom: wacom_setup_numbered_buttons is local to wacom_wac)
  	}
  	return 0;
  }
* Unmerged path drivers/hid/wacom_wac.c
