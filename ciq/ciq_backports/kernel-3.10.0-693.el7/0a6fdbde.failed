IB/srp: Fix race conditions related to task management

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 0a6fdbdeb1c25e31763c1fb333fa2723a7d2aba6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0a6fdbde.failed

Avoid that srp_process_rsp() overwrites the status information
in ch if the SRP target response timed out and processing of
another task management function has already started. Avoid that
issuing multiple task management functions concurrently triggers
list corruption. This patch prevents that the following stack
trace appears in the system log:

WARNING: CPU: 8 PID: 9269 at lib/list_debug.c:52 __list_del_entry_valid+0xbc/0xc0
list_del corruption. prev->next should be ffffc90004bb7b00, but was ffff8804052ecc68
CPU: 8 PID: 9269 Comm: sg_reset Tainted: G        W       4.10.0-rc7-dbg+ #3
Call Trace:
 dump_stack+0x68/0x93
 __warn+0xc6/0xe0
 warn_slowpath_fmt+0x4a/0x50
 __list_del_entry_valid+0xbc/0xc0
 wait_for_completion_timeout+0x12e/0x170
 srp_send_tsk_mgmt+0x1ef/0x2d0 [ib_srp]
 srp_reset_device+0x5b/0x110 [ib_srp]
 scsi_ioctl_reset+0x1c7/0x290
 scsi_ioctl+0x12a/0x420
 sd_ioctl+0x9d/0x100
 blkdev_ioctl+0x51e/0x9f0
 block_ioctl+0x38/0x40
 do_vfs_ioctl+0x8f/0x700
 SyS_ioctl+0x3c/0x70
 entry_SYSCALL_64_fastpath+0x18/0xad

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Cc: Israel Rukshin <israelr@mellanox.com>
	Cc: Max Gurtovoy <maxg@mellanox.com>
	Cc: Laurence Oberman <loberman@redhat.com>
	Cc: Steve Feeley <Steve.Feeley@sandisk.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 0a6fdbdeb1c25e31763c1fb333fa2723a7d2aba6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srp/ib_srp.c
diff --cc drivers/infiniband/ulp/srp/ib_srp.c
index a3de4b72da86,d9b57f5958b5..000000000000
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@@ -2544,27 -2525,15 +2549,32 @@@ srp_change_queue_type(struct scsi_devic
   * Returns queue depth.
   */
  static int
 -srp_change_queue_depth(struct scsi_device *sdev, int qdepth)
 +srp_change_queue_depth(struct scsi_device *sdev, int qdepth, int reason)
  {
 -	if (!sdev->tagged_supported)
 -		qdepth = 1;
 -	return scsi_change_queue_depth(sdev, qdepth);
 +	struct Scsi_Host *shost = sdev->host;
 +	int max_depth;
 +	if (reason == SCSI_QDEPTH_DEFAULT || reason == SCSI_QDEPTH_RAMP_UP) {
 +		max_depth = shost->can_queue;
 +		if (!sdev->tagged_supported)
 +			max_depth = 1;
 +		if (qdepth > max_depth)
 +			qdepth = max_depth;
 +		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), qdepth);
 +	} else if (reason == SCSI_QDEPTH_QFULL)
 +		scsi_track_queue_full(sdev, qdepth);
 +	else
 +		return -EOPNOTSUPP;
 +
 +	return sdev->queue_depth;
  }
  
++<<<<<<< HEAD
 +static int srp_send_tsk_mgmt(struct srp_rdma_ch *ch, u64 req_tag,
 +			     unsigned int lun, u8 func)
++=======
+ static int srp_send_tsk_mgmt(struct srp_rdma_ch *ch, u64 req_tag, u64 lun,
+ 			     u8 func, u8 *status)
++>>>>>>> 0a6fdbdeb1c2 (IB/srp: Fix race conditions related to task management)
  {
  	struct srp_target_port *target = ch->target;
  	struct srp_rport *rport = target->rport;
* Unmerged path drivers/infiniband/ulp/srp/ib_srp.c
diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h
index 6d4b3b974141..e1e3cfbd57b1 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.h
+++ b/drivers/infiniband/ulp/srp/ib_srp.h
@@ -165,6 +165,7 @@ struct srp_rdma_ch {
 	int			max_ti_iu_len;
 	int			comp_vector;
 
+	u64			tsk_mgmt_tag;
 	struct completion	tsk_mgmt_done;
 	u8			tsk_mgmt_status;
 	bool			connected;
