btrfs: btrfs_test_opt and friends should take a btrfs_fs_info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jeff Mahoney <jeffm@suse.com>
commit 3cdde2240d4533ff71fbb8dc9c32d5d57d3cdeed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3cdde224.failed

btrfs_test_opt and friends only use the root pointer to access
the fs_info.  Let's pass the fs_info directly in preparation to
eliminate similar patterns all over btrfs.

	Signed-off-by: Jeff Mahoney <jeffm@suse.com>
	Signed-off-by: David Sterba <dsterba@suse.com>
(cherry picked from commit 3cdde2240d4533ff71fbb8dc9c32d5d57d3cdeed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/disk-io.c
#	fs/btrfs/super.c
#	fs/btrfs/transaction.c
diff --cc fs/btrfs/disk-io.c
index f1b6251aa1de,802a3113854f..000000000000
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@@ -2990,11 -3019,10 +2990,11 @@@ retry_root_backup
  	if (IS_ERR(fs_info->transaction_kthread))
  		goto fail_cleaner;
  
- 	if (!btrfs_test_opt(tree_root, SSD) &&
- 	    !btrfs_test_opt(tree_root, NOSSD) &&
+ 	if (!btrfs_test_opt(tree_root->fs_info, SSD) &&
+ 	    !btrfs_test_opt(tree_root->fs_info, NOSSD) &&
  	    !fs_info->fs_devices->rotating) {
 -		btrfs_info(fs_info, "detected SSD devices, enabling SSD mode");
 +		printk(KERN_INFO "BTRFS: detected SSD devices, enabling SSD "
 +		       "mode\n");
  		btrfs_set_opt(fs_info->mount_opt, SSD);
  	}
  
@@@ -3020,8 -3049,9 +3020,14 @@@
  	if (ret)
  		goto fail_trans_kthread;
  
++<<<<<<< HEAD
 +	/* do not make disk changes in broken FS */
 +	if (btrfs_super_log_root(disk_super) != 0) {
++=======
+ 	/* do not make disk changes in broken FS or nologreplay is given */
+ 	if (btrfs_super_log_root(disk_super) != 0 &&
+ 	    !btrfs_test_opt(tree_root->fs_info, NOLOGREPLAY)) {
++>>>>>>> 3cdde2240d45 (btrfs: btrfs_test_opt and friends should take a btrfs_fs_info)
  		ret = btrfs_replay_log(fs_info, fs_devices);
  		if (ret) {
  			err = ret;
@@@ -3062,6 -3092,18 +3068,21 @@@
  	if (sb->s_flags & MS_RDONLY)
  		return 0;
  
++<<<<<<< HEAD
++=======
+ 	if (btrfs_test_opt(tree_root->fs_info, FREE_SPACE_TREE) &&
+ 	    !btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE)) {
+ 		btrfs_info(fs_info, "creating free space tree");
+ 		ret = btrfs_create_free_space_tree(fs_info);
+ 		if (ret) {
+ 			btrfs_warn(fs_info,
+ 				"failed to create free space tree: %d", ret);
+ 			close_ctree(tree_root);
+ 			return ret;
+ 		}
+ 	}
+ 
++>>>>>>> 3cdde2240d45 (btrfs: btrfs_test_opt and friends should take a btrfs_fs_info)
  	down_read(&fs_info->cleanup_work_sem);
  	if ((ret = btrfs_orphan_cleanup(fs_info->fs_root)) ||
  	    (ret = btrfs_orphan_cleanup(fs_info->tree_root))) {
@@@ -3087,23 -3129,35 +3108,38 @@@
  
  	btrfs_qgroup_rescan_resume(fs_info);
  
++<<<<<<< HEAD
++=======
+ 	if (btrfs_test_opt(tree_root->fs_info, CLEAR_CACHE) &&
+ 	    btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE)) {
+ 		btrfs_info(fs_info, "clearing free space tree");
+ 		ret = btrfs_clear_free_space_tree(fs_info);
+ 		if (ret) {
+ 			btrfs_warn(fs_info,
+ 				"failed to clear free space tree: %d", ret);
+ 			close_ctree(tree_root);
+ 			return ret;
+ 		}
+ 	}
+ 
++>>>>>>> 3cdde2240d45 (btrfs: btrfs_test_opt and friends should take a btrfs_fs_info)
  	if (!fs_info->uuid_root) {
 -		btrfs_info(fs_info, "creating UUID tree");
 +		pr_info("BTRFS: creating UUID tree\n");
  		ret = btrfs_create_uuid_tree(fs_info);
  		if (ret) {
 -			btrfs_warn(fs_info,
 -				"failed to create the UUID tree: %d", ret);
 +			pr_warn("BTRFS: failed to create the UUID tree %d\n",
 +				ret);
  			close_ctree(tree_root);
  			return ret;
  		}
- 	} else if (btrfs_test_opt(tree_root, RESCAN_UUID_TREE) ||
+ 	} else if (btrfs_test_opt(tree_root->fs_info, RESCAN_UUID_TREE) ||
  		   fs_info->generation !=
  				btrfs_super_uuid_tree_generation(disk_super)) {
 -		btrfs_info(fs_info, "checking UUID tree");
 +		pr_info("BTRFS: checking UUID tree\n");
  		ret = btrfs_check_uuid_tree(fs_info);
  		if (ret) {
 -			btrfs_warn(fs_info,
 -				"failed to check the UUID tree: %d", ret);
 +			pr_warn("BTRFS: failed to check the UUID tree %d\n",
 +				ret);
  			close_ctree(tree_root);
  			return ret;
  		}
@@@ -3167,7 -3227,7 +3203,11 @@@ fail
  	return err;
  
  recovery_tree_root:
++<<<<<<< HEAD
 +	if (!btrfs_test_opt(tree_root, RECOVERY))
++=======
+ 	if (!btrfs_test_opt(tree_root->fs_info, USEBACKUPROOT))
++>>>>>>> 3cdde2240d45 (btrfs: btrfs_test_opt and friends should take a btrfs_fs_info)
  		goto fail_tree_roots;
  
  	free_root_pointers(fs_info, 0);
diff --cc fs/btrfs/super.c
index 92d06671fd90,4a0c0aeb0041..000000000000
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@@ -617,11 -631,16 +618,19 @@@ int btrfs_parse_options(struct btrfs_ro
  					   "disabling tree log");
  			break;
  		case Opt_treelog:
- 			btrfs_clear_and_info(root, NOTREELOG,
+ 			btrfs_clear_and_info(info, NOTREELOG,
  					     "enabling tree log");
  			break;
++<<<<<<< HEAD
++=======
+ 		case Opt_norecovery:
+ 		case Opt_nologreplay:
+ 			btrfs_set_and_info(info, NOLOGREPLAY,
+ 					   "disabling log replay at mount time");
+ 			break;
++>>>>>>> 3cdde2240d45 (btrfs: btrfs_test_opt and friends should take a btrfs_fs_info)
  		case Opt_flushoncommit:
- 			btrfs_set_and_info(root, FLUSHONCOMMIT,
+ 			btrfs_set_and_info(info, FLUSHONCOMMIT,
  					   "turning on flush-on-commit");
  			break;
  		case Opt_noflushoncommit:
@@@ -650,15 -669,38 +659,48 @@@
  					     "turning off discard");
  			break;
  		case Opt_space_cache:
++<<<<<<< HEAD
 +			btrfs_set_and_info(root, SPACE_CACHE,
 +					   "enabling disk space caching");
++=======
+ 		case Opt_space_cache_version:
+ 			if (token == Opt_space_cache ||
+ 			    strcmp(args[0].from, "v1") == 0) {
+ 				btrfs_clear_opt(root->fs_info->mount_opt,
+ 						FREE_SPACE_TREE);
+ 				btrfs_set_and_info(info, SPACE_CACHE,
+ 						   "enabling disk space caching");
+ 			} else if (strcmp(args[0].from, "v2") == 0) {
+ 				btrfs_clear_opt(root->fs_info->mount_opt,
+ 						SPACE_CACHE);
+ 				btrfs_set_and_info(info,
+ 						   FREE_SPACE_TREE,
+ 						   "enabling free space tree");
+ 			} else {
+ 				ret = -EINVAL;
+ 				goto out;
+ 			}
++>>>>>>> 3cdde2240d45 (btrfs: btrfs_test_opt and friends should take a btrfs_fs_info)
  			break;
  		case Opt_rescan_uuid_tree:
  			btrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);
  			break;
  		case Opt_no_space_cache:
++<<<<<<< HEAD
 +			btrfs_clear_and_info(root, SPACE_CACHE,
 +					     "disabling disk space caching");
++=======
+ 			if (btrfs_test_opt(info, SPACE_CACHE)) {
+ 				btrfs_clear_and_info(info,
+ 						     SPACE_CACHE,
+ 						     "disabling disk space caching");
+ 			}
+ 			if (btrfs_test_opt(info, FREE_SPACE_TREE)) {
+ 				btrfs_clear_and_info(info,
+ 						     FREE_SPACE_TREE,
+ 						     "disabling free space tree");
+ 			}
++>>>>>>> 3cdde2240d45 (btrfs: btrfs_test_opt and friends should take a btrfs_fs_info)
  			break;
  		case Opt_inode_cache:
  			btrfs_set_pending_and_info(info, INODE_MAP_CACHE,
@@@ -786,9 -832,27 +828,33 @@@
  			break;
  		}
  	}
++<<<<<<< HEAD
 +out:
 +	if (!ret && btrfs_test_opt(root, SPACE_CACHE))
 +		btrfs_info(root->fs_info, "disk space caching is enabled");
++=======
+ check:
+ 	/*
+ 	 * Extra check for current option against current flag
+ 	 */
+ 	if (btrfs_test_opt(info, NOLOGREPLAY) && !(new_flags & MS_RDONLY)) {
+ 		btrfs_err(root->fs_info,
+ 			  "nologreplay must be used with ro mount option");
+ 		ret = -EINVAL;
+ 	}
+ out:
+ 	if (btrfs_fs_compat_ro(root->fs_info, FREE_SPACE_TREE) &&
+ 	    !btrfs_test_opt(info, FREE_SPACE_TREE) &&
+ 	    !btrfs_test_opt(info, CLEAR_CACHE)) {
+ 		btrfs_err(root->fs_info, "cannot disable free space tree");
+ 		ret = -EINVAL;
+ 
+ 	}
+ 	if (!ret && btrfs_test_opt(info, SPACE_CACHE))
+ 		btrfs_info(root->fs_info, "disk space caching is enabled");
+ 	if (!ret && btrfs_test_opt(info, FREE_SPACE_TREE))
+ 		btrfs_info(root->fs_info, "using free space tree");
++>>>>>>> 3cdde2240d45 (btrfs: btrfs_test_opt and friends should take a btrfs_fs_info)
  	kfree(orig);
  	return ret;
  }
@@@ -1178,44 -1243,46 +1244,55 @@@ static int btrfs_show_options(struct se
  		else
  			seq_printf(seq, ",compress=%s", compress_type);
  	}
- 	if (btrfs_test_opt(root, NOSSD))
+ 	if (btrfs_test_opt(info, NOSSD))
  		seq_puts(seq, ",nossd");
- 	if (btrfs_test_opt(root, SSD_SPREAD))
+ 	if (btrfs_test_opt(info, SSD_SPREAD))
  		seq_puts(seq, ",ssd_spread");
- 	else if (btrfs_test_opt(root, SSD))
+ 	else if (btrfs_test_opt(info, SSD))
  		seq_puts(seq, ",ssd");
- 	if (btrfs_test_opt(root, NOTREELOG))
+ 	if (btrfs_test_opt(info, NOTREELOG))
  		seq_puts(seq, ",notreelog");
++<<<<<<< HEAD
 +	if (btrfs_test_opt(root, FLUSHONCOMMIT))
++=======
+ 	if (btrfs_test_opt(info, NOLOGREPLAY))
+ 		seq_puts(seq, ",nologreplay");
+ 	if (btrfs_test_opt(info, FLUSHONCOMMIT))
++>>>>>>> 3cdde2240d45 (btrfs: btrfs_test_opt and friends should take a btrfs_fs_info)
  		seq_puts(seq, ",flushoncommit");
- 	if (btrfs_test_opt(root, DISCARD))
+ 	if (btrfs_test_opt(info, DISCARD))
  		seq_puts(seq, ",discard");
  	if (!(root->fs_info->sb->s_flags & MS_POSIXACL))
  		seq_puts(seq, ",noacl");
- 	if (btrfs_test_opt(root, SPACE_CACHE))
+ 	if (btrfs_test_opt(info, SPACE_CACHE))
  		seq_puts(seq, ",space_cache");
++<<<<<<< HEAD
++=======
+ 	else if (btrfs_test_opt(info, FREE_SPACE_TREE))
+ 		seq_puts(seq, ",space_cache=v2");
++>>>>>>> 3cdde2240d45 (btrfs: btrfs_test_opt and friends should take a btrfs_fs_info)
  	else
  		seq_puts(seq, ",nospace_cache");
- 	if (btrfs_test_opt(root, RESCAN_UUID_TREE))
+ 	if (btrfs_test_opt(info, RESCAN_UUID_TREE))
  		seq_puts(seq, ",rescan_uuid_tree");
- 	if (btrfs_test_opt(root, CLEAR_CACHE))
+ 	if (btrfs_test_opt(info, CLEAR_CACHE))
  		seq_puts(seq, ",clear_cache");
- 	if (btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))
+ 	if (btrfs_test_opt(info, USER_SUBVOL_RM_ALLOWED))
  		seq_puts(seq, ",user_subvol_rm_allowed");
- 	if (btrfs_test_opt(root, ENOSPC_DEBUG))
+ 	if (btrfs_test_opt(info, ENOSPC_DEBUG))
  		seq_puts(seq, ",enospc_debug");
- 	if (btrfs_test_opt(root, AUTO_DEFRAG))
+ 	if (btrfs_test_opt(info, AUTO_DEFRAG))
  		seq_puts(seq, ",autodefrag");
- 	if (btrfs_test_opt(root, INODE_MAP_CACHE))
+ 	if (btrfs_test_opt(info, INODE_MAP_CACHE))
  		seq_puts(seq, ",inode_cache");
- 	if (btrfs_test_opt(root, SKIP_BALANCE))
+ 	if (btrfs_test_opt(info, SKIP_BALANCE))
  		seq_puts(seq, ",skip_balance");
 +	if (btrfs_test_opt(root, RECOVERY))
 +		seq_puts(seq, ",recovery");
  #ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY
- 	if (btrfs_test_opt(root, CHECK_INTEGRITY_INCLUDING_EXTENT_DATA))
+ 	if (btrfs_test_opt(info, CHECK_INTEGRITY_INCLUDING_EXTENT_DATA))
  		seq_puts(seq, ",check_int_data");
- 	else if (btrfs_test_opt(root, CHECK_INTEGRITY))
+ 	else if (btrfs_test_opt(info, CHECK_INTEGRITY))
  		seq_puts(seq, ",check_int");
  	if (info->check_integrity_print_mask)
  		seq_printf(seq, ",check_int_print_mask=%d",
diff --cc fs/btrfs/transaction.c
index 8287524e73a2,d986447d19a4..000000000000
--- a/fs/btrfs/transaction.c
+++ b/fs/btrfs/transaction.c
@@@ -1903,8 -1902,8 +1903,13 @@@ static inline int btrfs_start_delalloc_
  
  static inline void btrfs_wait_delalloc_flush(struct btrfs_fs_info *fs_info)
  {
++<<<<<<< HEAD
 +	if (btrfs_test_opt(fs_info->tree_root, FLUSHONCOMMIT))
 +		btrfs_wait_ordered_roots(fs_info, -1);
++=======
+ 	if (btrfs_test_opt(fs_info, FLUSHONCOMMIT))
+ 		btrfs_wait_ordered_roots(fs_info, -1, 0, (u64)-1);
++>>>>>>> 3cdde2240d45 (btrfs: btrfs_test_opt and friends should take a btrfs_fs_info)
  }
  
  static inline void
diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index eaff9105e433..cdb996b7a0b9 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -1263,21 +1263,21 @@ struct btrfs_root {
 #define btrfs_clear_opt(o, opt)		((o) &= ~BTRFS_MOUNT_##opt)
 #define btrfs_set_opt(o, opt)		((o) |= BTRFS_MOUNT_##opt)
 #define btrfs_raw_test_opt(o, opt)	((o) & BTRFS_MOUNT_##opt)
-#define btrfs_test_opt(root, opt)	((root)->fs_info->mount_opt & \
+#define btrfs_test_opt(fs_info, opt)	((fs_info)->mount_opt & \
 					 BTRFS_MOUNT_##opt)
 
-#define btrfs_set_and_info(root, opt, fmt, args...)			\
+#define btrfs_set_and_info(fs_info, opt, fmt, args...)			\
 {									\
-	if (!btrfs_test_opt(root, opt))					\
-		btrfs_info(root->fs_info, fmt, ##args);			\
-	btrfs_set_opt(root->fs_info->mount_opt, opt);			\
+	if (!btrfs_test_opt(fs_info, opt))				\
+		btrfs_info(fs_info, fmt, ##args);			\
+	btrfs_set_opt(fs_info->mount_opt, opt);				\
 }
 
-#define btrfs_clear_and_info(root, opt, fmt, args...)			\
+#define btrfs_clear_and_info(fs_info, opt, fmt, args...)		\
 {									\
-	if (btrfs_test_opt(root, opt))					\
-		btrfs_info(root->fs_info, fmt, ##args);			\
-	btrfs_clear_opt(root->fs_info->mount_opt, opt);			\
+	if (btrfs_test_opt(fs_info, opt))				\
+		btrfs_info(fs_info, fmt, ##args);			\
+	btrfs_clear_opt(fs_info->mount_opt, opt);			\
 }
 
 #ifdef CONFIG_BTRFS_DEBUG
@@ -1285,9 +1285,9 @@ static inline int
 btrfs_should_fragment_free_space(struct btrfs_root *root,
 				 struct btrfs_block_group_cache *block_group)
 {
-	return (btrfs_test_opt(root, FRAGMENT_METADATA) &&
+	return (btrfs_test_opt(root->fs_info, FRAGMENT_METADATA) &&
 		block_group->flags & BTRFS_BLOCK_GROUP_METADATA) ||
-	       (btrfs_test_opt(root, FRAGMENT_DATA) &&
+	       (btrfs_test_opt(root->fs_info, FRAGMENT_DATA) &&
 		block_group->flags &  BTRFS_BLOCK_GROUP_DATA);
 }
 #endif
diff --git a/fs/btrfs/dev-replace.c b/fs/btrfs/dev-replace.c
index 8c4d587ea821..fc9f68ea1033 100644
--- a/fs/btrfs/dev-replace.c
+++ b/fs/btrfs/dev-replace.c
@@ -142,7 +142,7 @@ no_valid_dev_replace_entry_found:
 		 * missing
 		 */
 		if (!dev_replace->srcdev &&
-		    !btrfs_test_opt(dev_root, DEGRADED)) {
+		    !btrfs_test_opt(dev_root->fs_info, DEGRADED)) {
 			ret = -EIO;
 			btrfs_warn(fs_info,
 			   "cannot mount because device replace operation is ongoing and");
@@ -151,7 +151,7 @@ no_valid_dev_replace_entry_found:
 			   src_devid);
 		}
 		if (!dev_replace->tgtdev &&
-		    !btrfs_test_opt(dev_root, DEGRADED)) {
+		    !btrfs_test_opt(dev_root->fs_info, DEGRADED)) {
 			ret = -EIO;
 			btrfs_warn(fs_info,
 			   "cannot mount because device replace operation is ongoing and");
* Unmerged path fs/btrfs/disk-io.c
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 51360de1f70c..935e6bb9769d 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -3418,7 +3418,7 @@ again:
 
 	spin_lock(&block_group->lock);
 	if (block_group->cached != BTRFS_CACHE_FINISHED ||
-	    !btrfs_test_opt(root, SPACE_CACHE)) {
+	    !btrfs_test_opt(root->fs_info, SPACE_CACHE)) {
 		/*
 		 * don't bother trying to write stuff out _if_
 		 * a) we're not cached,
@@ -3495,7 +3495,7 @@ int btrfs_setup_space_cache(struct btrfs_trans_handle *trans,
 	struct btrfs_path *path;
 
 	if (list_empty(&cur_trans->dirty_bgs) ||
-	    !btrfs_test_opt(root, SPACE_CACHE))
+	    !btrfs_test_opt(root->fs_info, SPACE_CACHE))
 		return 0;
 
 	path = btrfs_alloc_path();
@@ -4358,7 +4358,7 @@ void check_system_chunk(struct btrfs_trans_handle *trans,
 	thresh = btrfs_calc_trunc_metadata_size(root, num_devs) +
 		btrfs_calc_trans_metadata_size(root, 1);
 
-	if (left < thresh && btrfs_test_opt(root, ENOSPC_DEBUG)) {
+	if (left < thresh && btrfs_test_opt(root->fs_info, ENOSPC_DEBUG)) {
 		btrfs_info(root->fs_info, "left=%llu, need=%llu, flags=%llu",
 			left, thresh, type);
 		dump_space_info(info, 0, 0);
@@ -5923,7 +5923,7 @@ static int update_block_group(struct btrfs_trans_handle *trans,
 		spin_lock(&cache->space_info->lock);
 		spin_lock(&cache->lock);
 
-		if (btrfs_test_opt(root, SPACE_CACHE) &&
+		if (btrfs_test_opt(root->fs_info, SPACE_CACHE) &&
 		    cache->disk_cache_state < BTRFS_DC_CLEAR)
 			cache->disk_cache_state = BTRFS_DC_CLEAR;
 
@@ -6254,7 +6254,7 @@ fetch_cluster_info(struct btrfs_root *root, struct btrfs_space_info *space_info,
 		   u64 *empty_cluster)
 {
 	struct btrfs_free_cluster *ret = NULL;
-	bool ssd = btrfs_test_opt(root, SSD);
+	bool ssd = btrfs_test_opt(root->fs_info, SSD);
 
 	*empty_cluster = 0;
 	if (btrfs_mixed_space_info(space_info))
@@ -6387,7 +6387,7 @@ int btrfs_finish_extent_commit(struct btrfs_trans_handle *trans,
 			break;
 		}
 
-		if (btrfs_test_opt(root, DISCARD))
+		if (btrfs_test_opt(root->fs_info, DISCARD))
 			ret = btrfs_discard_extent(root, start,
 						   end + 1 - start, NULL);
 
@@ -7596,7 +7596,7 @@ again:
 			if (num_bytes == min_alloc_size)
 				final_tried = true;
 			goto again;
-		} else if (btrfs_test_opt(root, ENOSPC_DEBUG)) {
+		} else if (btrfs_test_opt(root->fs_info, ENOSPC_DEBUG)) {
 			struct btrfs_space_info *sinfo;
 
 			sinfo = __find_space_info(root->fs_info, flags);
@@ -7627,7 +7627,7 @@ static int __btrfs_free_reserved_extent(struct btrfs_root *root,
 	if (pin)
 		pin_down_extent(root, cache, start, len, 1);
 	else {
-		if (btrfs_test_opt(root, DISCARD))
+		if (btrfs_test_opt(root->fs_info, DISCARD))
 			ret = btrfs_discard_extent(root, start, len, NULL);
 		btrfs_add_free_space(cache, start, len);
 		btrfs_update_reserved_bytes(cache, len, RESERVE_FREE, delalloc);
@@ -7925,7 +7925,7 @@ again:
 		goto again;
 	}
 
-	if (btrfs_test_opt(root, ENOSPC_DEBUG)) {
+	if (btrfs_test_opt(root->fs_info, ENOSPC_DEBUG)) {
 		static DEFINE_RATELIMIT_STATE(_rs,
 				DEFAULT_RATELIMIT_INTERVAL * 10,
 				/*DEFAULT_RATELIMIT_BURST*/ 1);
@@ -9356,7 +9356,7 @@ int btrfs_can_relocate(struct btrfs_root *root, u64 bytenr)
 	int full = 0;
 	int ret = 0;
 
-	debug = btrfs_test_opt(root, ENOSPC_DEBUG);
+	debug = btrfs_test_opt(root->fs_info, ENOSPC_DEBUG);
 
 	block_group = btrfs_lookup_block_group(root->fs_info, bytenr);
 
@@ -9767,10 +9767,10 @@ int btrfs_read_block_groups(struct btrfs_root *root)
 	path->reada = 1;
 
 	cache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);
-	if (btrfs_test_opt(root, SPACE_CACHE) &&
+	if (btrfs_test_opt(root->fs_info, SPACE_CACHE) &&
 	    btrfs_super_generation(root->fs_info->super_copy) != cache_gen)
 		need_clear = 1;
-	if (btrfs_test_opt(root, CLEAR_CACHE))
+	if (btrfs_test_opt(root->fs_info, CLEAR_CACHE))
 		need_clear = 1;
 
 	while (1) {
@@ -9801,7 +9801,7 @@ int btrfs_read_block_groups(struct btrfs_root *root)
 			 * b) Setting 'dirty flag' makes sure that we flush
 			 *    the new space cache info onto disk.
 			 */
-			if (btrfs_test_opt(root, SPACE_CACHE))
+			if (btrfs_test_opt(root->fs_info, SPACE_CACHE))
 				cache->disk_cache_state = BTRFS_DC_CLEAR;
 		}
 
@@ -10257,7 +10257,7 @@ int btrfs_remove_block_group(struct btrfs_trans_handle *trans,
 	spin_lock(&block_group->space_info->lock);
 	list_del_init(&block_group->ro_list);
 
-	if (btrfs_test_opt(root, ENOSPC_DEBUG)) {
+	if (btrfs_test_opt(root->fs_info, ENOSPC_DEBUG)) {
 		WARN_ON(block_group->space_info->total_bytes
 			< block_group->key.offset);
 		WARN_ON(block_group->space_info->bytes_readonly
@@ -10521,7 +10521,7 @@ void btrfs_delete_unused_bgs(struct btrfs_fs_info *fs_info)
 		spin_unlock(&space_info->lock);
 
 		/* DISCARD can flip during remount */
-		trimming = btrfs_test_opt(root, DISCARD);
+		trimming = btrfs_test_opt(root->fs_info, DISCARD);
 
 		/* Implicit trim during transaction commit. */
 		if (trimming)
diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c
index e43faf9abaf6..e8e294f07805 100644
--- a/fs/btrfs/file.c
+++ b/fs/btrfs/file.c
@@ -132,7 +132,7 @@ static int __btrfs_add_inode_defrag(struct inode *inode,
 
 static inline int __need_auto_defrag(struct btrfs_root *root)
 {
-	if (!btrfs_test_opt(root, AUTO_DEFRAG))
+	if (!btrfs_test_opt(root->fs_info, AUTO_DEFRAG))
 		return 0;
 
 	if (btrfs_fs_closing(root->fs_info))
diff --git a/fs/btrfs/free-space-cache.c b/fs/btrfs/free-space-cache.c
index 4c2a64aa0c50..026328f6a4cc 100644
--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@ -3028,7 +3028,7 @@ int btrfs_find_space_cluster(struct btrfs_root *root,
 	 * For metadata, allow allocates with smaller extents.  For
 	 * data, keep it dense.
 	 */
-	if (btrfs_test_opt(root, SSD_SPREAD)) {
+	if (btrfs_test_opt(root->fs_info, SSD_SPREAD)) {
 		cont1_bytes = min_bytes = bytes + empty_size;
 	} else if (block_group->flags & BTRFS_BLOCK_GROUP_METADATA) {
 		cont1_bytes = bytes;
@@ -3472,7 +3472,7 @@ int load_free_ino_cache(struct btrfs_fs_info *fs_info, struct btrfs_root *root)
 	int ret = 0;
 	u64 root_gen = btrfs_root_generation(&root->root_item);
 
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return 0;
 
 	/*
@@ -3516,7 +3516,7 @@ int btrfs_write_out_ino_cache(struct btrfs_root *root,
 	struct btrfs_io_ctl io_ctl;
 	bool release_metadata = true;
 
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return 0;
 
 	memset(&io_ctl, 0, sizeof(io_ctl));
diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c
index 8d4cffdaf181..aee7ea14b951 100644
--- a/fs/btrfs/inode-map.c
+++ b/fs/btrfs/inode-map.c
@@ -38,7 +38,7 @@ static int caching_kthread(void *data)
 	int slot;
 	int ret;
 
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return 0;
 
 	path = btrfs_alloc_path();
@@ -141,7 +141,7 @@ static void start_caching(struct btrfs_root *root)
 	int ret;
 	u64 objectid;
 
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return;
 
 	spin_lock(&root->ino_cache_lock);
@@ -185,7 +185,7 @@ static void start_caching(struct btrfs_root *root)
 
 int btrfs_find_free_ino(struct btrfs_root *root, u64 *objectid)
 {
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return btrfs_find_free_objectid(root, objectid);
 
 again:
@@ -211,7 +211,7 @@ void btrfs_return_ino(struct btrfs_root *root, u64 objectid)
 {
 	struct btrfs_free_space_ctl *pinned = root->free_ino_pinned;
 
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return;
 again:
 	if (root->ino_cache_state == BTRFS_CACHE_FINISHED) {
@@ -251,7 +251,7 @@ void btrfs_unpin_free_ino(struct btrfs_root *root)
 	struct rb_node *n;
 	u64 count;
 
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return;
 
 	while (1) {
@@ -412,7 +412,7 @@ int btrfs_save_ino_cache(struct btrfs_root *root,
 	if (btrfs_root_refs(&root->root_item) == 0)
 		return 0;
 
-	if (!btrfs_test_opt(root, INODE_MAP_CACHE))
+	if (!btrfs_test_opt(root->fs_info, INODE_MAP_CACHE))
 		return 0;
 
 	path = btrfs_alloc_path();
diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index e6496b484d20..30fa87666b60 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -370,12 +370,12 @@ static inline int inode_need_compress(struct inode *inode)
 	struct btrfs_root *root = BTRFS_I(inode)->root;
 
 	/* force compress */
-	if (btrfs_test_opt(root, FORCE_COMPRESS))
+	if (btrfs_test_opt(root->fs_info, FORCE_COMPRESS))
 		return 1;
 	/* bad compression ratios */
 	if (BTRFS_I(inode)->flags & BTRFS_INODE_NOCOMPRESS)
 		return 0;
-	if (btrfs_test_opt(root, COMPRESS) ||
+	if (btrfs_test_opt(root->fs_info, COMPRESS) ||
 	    BTRFS_I(inode)->flags & BTRFS_INODE_COMPRESS ||
 	    BTRFS_I(inode)->force_compress)
 		return 1;
@@ -616,7 +616,7 @@ cont:
 		nr_pages_ret = 0;
 
 		/* flag the file so we don't compress in the future */
-		if (!btrfs_test_opt(root, FORCE_COMPRESS) &&
+		if (!btrfs_test_opt(root->fs_info, FORCE_COMPRESS) &&
 		    !(BTRFS_I(inode)->force_compress)) {
 			BTRFS_I(inode)->flags |= BTRFS_INODE_NOCOMPRESS;
 		}
@@ -1148,7 +1148,7 @@ static int cow_file_range_async(struct inode *inode, struct page *locked_page,
 		async_cow->start = start;
 
 		if (BTRFS_I(inode)->flags & BTRFS_INODE_NOCOMPRESS &&
-		    !btrfs_test_opt(root, FORCE_COMPRESS))
+		    !btrfs_test_opt(root->fs_info, FORCE_COMPRESS))
 			cur_end = end;
 		else
 			cur_end = min(end, start + 512 * 1024 - 1);
@@ -6236,9 +6236,9 @@ static struct inode *btrfs_new_inode(struct btrfs_trans_handle *trans,
 	btrfs_inherit_iflags(inode, dir);
 
 	if (S_ISREG(mode)) {
-		if (btrfs_test_opt(root, NODATASUM))
+		if (btrfs_test_opt(root->fs_info, NODATASUM))
 			BTRFS_I(inode)->flags |= BTRFS_INODE_NODATASUM;
-		if (btrfs_test_opt(root, NODATACOW))
+		if (btrfs_test_opt(root->fs_info, NODATACOW))
 			BTRFS_I(inode)->flags |= BTRFS_INODE_NODATACOW |
 				BTRFS_INODE_NODATASUM;
 	}
diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c
index 59bf429024a6..c1793096f1ef 100644
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -2408,7 +2408,7 @@ static noinline int btrfs_ioctl_snap_destroy(struct file *file,
 		 * rmdir(2).
 		 */
 		err = -EPERM;
-		if (!btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))
+		if (!btrfs_test_opt(root->fs_info, USER_SUBVOL_RM_ALLOWED))
 			goto out_dput;
 
 		/*
* Unmerged path fs/btrfs/super.c
* Unmerged path fs/btrfs/transaction.c
diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c
index 31ee2f991f00..d9e53883a580 100644
--- a/fs/btrfs/tree-log.c
+++ b/fs/btrfs/tree-log.c
@@ -2757,7 +2757,7 @@ int btrfs_sync_log(struct btrfs_trans_handle *trans,
 	while (1) {
 		int batch = atomic_read(&root->log_batch);
 		/* when we're on an ssd, just kick the log commit out */
-		if (!btrfs_test_opt(root, SSD) &&
+		if (!btrfs_test_opt(root->fs_info, SSD) &&
 		    test_bit(BTRFS_ROOT_MULTI_LOG_TASKS, &root->state)) {
 			mutex_unlock(&root->log_mutex);
 			schedule_timeout_uninterruptible(1);
@@ -5328,7 +5328,7 @@ static int btrfs_log_inode_parent(struct btrfs_trans_handle *trans,
 
 	sb = inode->i_sb;
 
-	if (btrfs_test_opt(root, NOTREELOG)) {
+	if (btrfs_test_opt(root->fs_info, NOTREELOG)) {
 		ret = 1;
 		goto end_no_trans;
 	}
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 1d1e7d3852c3..b720c9ee2180 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -3928,7 +3928,7 @@ int btrfs_resume_balance_async(struct btrfs_fs_info *fs_info)
 	}
 	spin_unlock(&fs_info->balance_lock);
 
-	if (btrfs_test_opt(fs_info->tree_root, SKIP_BALANCE)) {
+	if (btrfs_test_opt(fs_info, SKIP_BALANCE)) {
 		btrfs_info(fs_info, "force skipping balance");
 		return 0;
 	}
@@ -6512,7 +6512,8 @@ static int read_one_chunk(struct btrfs_root *root, struct btrfs_key *key,
 				   BTRFS_UUID_SIZE);
 		map->stripes[i].dev = btrfs_find_device(root->fs_info, devid,
 							uuid, NULL);
-		if (!map->stripes[i].dev && !btrfs_test_opt(root, DEGRADED)) {
+		if (!map->stripes[i].dev &&
+		    !btrfs_test_opt(root->fs_info, DEGRADED)) {
 			free_extent_map(em);
 			return -EIO;
 		}
@@ -6580,7 +6581,7 @@ static struct btrfs_fs_devices *open_seed_devices(struct btrfs_root *root,
 
 	fs_devices = find_fsid(fsid);
 	if (!fs_devices) {
-		if (!btrfs_test_opt(root, DEGRADED))
+		if (!btrfs_test_opt(root->fs_info, DEGRADED))
 			return ERR_PTR(-ENOENT);
 
 		fs_devices = alloc_fs_devices(fsid);
@@ -6642,7 +6643,7 @@ static int read_one_dev(struct btrfs_root *root,
 
 	device = btrfs_find_device(root->fs_info, devid, dev_uuid, fs_uuid);
 	if (!device) {
-		if (!btrfs_test_opt(root, DEGRADED))
+		if (!btrfs_test_opt(root->fs_info, DEGRADED))
 			return -EIO;
 
 		device = add_missing_dev(root, fs_devices, devid, dev_uuid);
@@ -6651,7 +6652,7 @@ static int read_one_dev(struct btrfs_root *root,
 		btrfs_warn(root->fs_info, "devid %llu uuid %pU missing",
 				devid, dev_uuid);
 	} else {
-		if (!device->bdev && !btrfs_test_opt(root, DEGRADED))
+		if (!device->bdev && !btrfs_test_opt(root->fs_info, DEGRADED))
 			return -EIO;
 
 		if(!device->bdev && !device->missing) {
