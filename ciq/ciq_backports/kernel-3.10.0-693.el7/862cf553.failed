HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.65%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 862cf5535c0cf4b39ce71a3b7e9a1c22ae4f70ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/862cf553.failed

Historically, both the touch and pad tools would have shared the
'BTN_TOOL_FINGER' type. Any time you needed to distinguish the two, you
had to use some other bit of knowledge (e.g. that the pad was on the same
interface as the pen, and thus 'touch_max' would be zero).

To make these checks more readable, we introduce WACOM_DEVICETYPE_PAD.
Although we still have to rely on other bits of knowledge to set this
bit on the right interface (since it cannot be detected from the HID
descriptor), it can be done just once inside 'wacom_setup_device_quirks'.

This patch introduces no functional changes.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 862cf5535c0cf4b39ce71a3b7e9a1c22ae4f70ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,aaa9c84fd985..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1009,17 -895,14 +1012,28 @@@ static int wacom_initialize_leds(struc
  	case INTUOSPS:
  	case INTUOSPM:
  	case INTUOSPL:
++<<<<<<< HEAD
 +		if (wacom->wacom_wac.features.device_type == BTN_TOOL_PEN) {
 +			wacom->led.select[0] = 0;
 +			wacom->led.select[1] = 0;
 +			wacom->led.llv = 32;
 +			wacom->led.hlv = 0;
 +			wacom->led.img_lum = 0;
 +
 +			error = sysfs_create_group(&wacom->intf->dev.kobj,
 +						  &intuos5_led_attr_group);
 +		} else
 +			return 0;
++=======
+ 		wacom->led.select[0] = 0;
+ 		wacom->led.select[1] = 0;
+ 		wacom->led.llv = 32;
+ 		wacom->led.hlv = 0;
+ 		wacom->led.img_lum = 0;
+ 
+ 		error = sysfs_create_group(&wacom->hdev->dev.kobj,
+ 					  &intuos5_led_attr_group);
++>>>>>>> 862cf5535c0c (HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type)
  		break;
  
  	default:
@@@ -1064,9 -951,8 +1081,14 @@@ static void wacom_destroy_leds(struct w
  	case INTUOSPS:
  	case INTUOSPM:
  	case INTUOSPL:
++<<<<<<< HEAD
 +		if (wacom->wacom_wac.features.device_type == BTN_TOOL_PEN)
 +			sysfs_remove_group(&wacom->intf->dev.kobj,
 +					   &intuos5_led_attr_group);
++=======
+ 		sysfs_remove_group(&wacom->hdev->dev.kobj,
+ 				   &intuos5_led_attr_group);
++>>>>>>> 862cf5535c0c (HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type)
  		break;
  	}
  }
@@@ -1220,30 -1297,48 +1242,54 @@@ static void wacom_wireless_work(struct 
  
  		/* Stylus interface */
  		wacom_wac1->features =
++<<<<<<< HEAD
 +			*((struct wacom_features *)id->driver_info);
 +		wacom_wac1->features.device_type = BTN_TOOL_PEN;
++=======
+ 			*((struct wacom_features *)id->driver_data);
+ 		wacom_wac1->features.device_type |= WACOM_DEVICETYPE_PEN;
+ 		if (wacom_wac1->features.type != INTUOSHT &&
+ 		    wacom_wac1->features.type != BAMBOO_PT)
+ 			wacom_wac1->features.device_type |= WACOM_DEVICETYPE_PAD;
++>>>>>>> 862cf5535c0c (HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type)
  		snprintf(wacom_wac1->name, WACOM_NAME_MAX, "%s (WL) Pen",
  			 wacom_wac1->features.name);
 -		snprintf(wacom_wac1->pad_name, WACOM_NAME_MAX, "%s (WL) Pad",
 -			 wacom_wac1->features.name);
 -		wacom_wac1->shared->touch_max = wacom_wac1->features.touch_max;
 -		wacom_wac1->shared->type = wacom_wac1->features.type;
 -		wacom_wac1->pid = wacom_wac->pid;
 -		error = wacom_allocate_inputs(wacom1) ||
 -			wacom_register_inputs(wacom1);
 +		error = wacom_register_input(wacom1);
  		if (error)
  			goto fail;
  
  		/* Touch interface */
 -		if (wacom_wac1->features.touch_max ||
 -		    wacom_wac1->features.type == INTUOSHT) {
 +		if (wacom_wac1->features.touch_max) {
  			wacom_wac2->features =
 -				*((struct wacom_features *)id->driver_data);
 +				*((struct wacom_features *)id->driver_info);
  			wacom_wac2->features.pktlen = WACOM_PKGLEN_BBTOUCH3;
++<<<<<<< HEAD
 +			wacom_wac2->features.device_type = BTN_TOOL_FINGER;
 +			wacom_wac2->features.x_max = wacom_wac2->features.y_max = 4096;
 +			if (wacom_wac2->features.touch_max)
 +				snprintf(wacom_wac2->name, WACOM_NAME_MAX,
 +					 "%s (WL) Finger",wacom_wac2->features.name);
 +			else
 +				snprintf(wacom_wac2->name, WACOM_NAME_MAX,
 +					 "%s (WL) Pad",wacom_wac2->features.name);
 +			error = wacom_register_input(wacom2);
++=======
+ 			wacom_wac2->features.x_max = wacom_wac2->features.y_max = 4096;
+ 			snprintf(wacom_wac2->name, WACOM_NAME_MAX,
+ 				 "%s (WL) Finger",wacom_wac2->features.name);
+ 			snprintf(wacom_wac2->pad_name, WACOM_NAME_MAX,
+ 				 "%s (WL) Pad",wacom_wac2->features.name);
+ 			if (wacom_wac1->features.touch_max)
+ 				wacom_wac2->features.device_type |= WACOM_DEVICETYPE_TOUCH;
+ 			if (wacom_wac1->features.type == INTUOSHT ||
+ 			    wacom_wac1->features.type == BAMBOO_PT)
+ 				wacom_wac2->features.device_type |= WACOM_DEVICETYPE_PAD;
+ 			wacom_wac2->pid = wacom_wac->pid;
+ 			error = wacom_allocate_inputs(wacom2) ||
+ 				wacom_register_inputs(wacom2);
++>>>>>>> 862cf5535c0c (HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type)
  			if (error)
  				goto fail;
 -
 -			if (wacom_wac1->features.type == INTUOSHT &&
 -			    wacom_wac1->features.touch_max)
 -				wacom_wac->shared->touch_input = wacom_wac2->input;
  		}
  
  		error = wacom_initialize_battery(wacom);
@@@ -1293,10 -1401,80 +1339,84 @@@ static void wacom_calculate_res(struct 
  						    features->unitExpo);
  }
  
 -static size_t wacom_compute_pktlen(struct hid_device *hdev)
 +static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *id)
  {
++<<<<<<< HEAD
++=======
+ 	struct hid_report_enum *report_enum;
+ 	struct hid_report *report;
+ 	size_t size = 0;
+ 
+ 	report_enum = hdev->report_enum + HID_INPUT_REPORT;
+ 
+ 	list_for_each_entry(report, &report_enum->report_list, list) {
+ 		size_t report_size = hid_report_len(report);
+ 		if (report_size > size)
+ 			size = report_size;
+ 	}
+ 
+ 	return size;
+ }
+ 
+ static void wacom_update_name(struct wacom *wacom)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	char name[WACOM_NAME_MAX];
+ 
+ 	/* Generic devices name unspecified */
+ 	if ((features->type == HID_GENERIC) && !strcmp("Wacom HID", features->name)) {
+ 		if (strstr(wacom->hdev->name, "Wacom") ||
+ 		    strstr(wacom->hdev->name, "wacom") ||
+ 		    strstr(wacom->hdev->name, "WACOM")) {
+ 			/* name is in HID descriptor, use it */
+ 			strlcpy(name, wacom->hdev->name, sizeof(name));
+ 
+ 			/* strip out excess whitespaces */
+ 			while (1) {
+ 				char *gap = strstr(name, "  ");
+ 				if (gap == NULL)
+ 					break;
+ 				/* shift everything including the terminator */
+ 				memmove(gap, gap+1, strlen(gap));
+ 			}
+ 			/* get rid of trailing whitespace */
+ 			if (name[strlen(name)-1] == ' ')
+ 				name[strlen(name)-1] = '\0';
+ 		} else {
+ 			/* no meaningful name retrieved. use product ID */
+ 			snprintf(name, sizeof(name),
+ 				 "%s %X", features->name, wacom->hdev->product);
+ 		}
+ 	} else {
+ 		strlcpy(name, features->name, sizeof(name));
+ 	}
+ 
+ 	/* Append the device type to the name */
+ 	snprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),
+ 		"%s Pad", name);
+ 
+ 	if (features->device_type & WACOM_DEVICETYPE_PEN) {
+ 		snprintf(wacom_wac->name, sizeof(wacom_wac->name),
+ 			"%s Pen", name);
+ 	}
+ 	else if (features->device_type & WACOM_DEVICETYPE_TOUCH) {
+ 		snprintf(wacom_wac->name, sizeof(wacom_wac->name),
+ 			"%s Finger", name);
+ 	}
+ 	else if (features->device_type & WACOM_DEVICETYPE_PAD) {
+ 		snprintf(wacom_wac->name, sizeof(wacom_wac->name),
+ 			"%s Pad", name);
+ 	}
+ }
+ 
+ static int wacom_probe(struct hid_device *hdev,
+ 		const struct hid_device_id *id)
+ {
+ 	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
++>>>>>>> 862cf5535c0c (HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type)
  	struct usb_device *dev = interface_to_usbdev(intf);
 +	struct usb_endpoint_descriptor *endpoint;
  	struct wacom *wacom;
  	struct wacom_wac *wacom_wac;
  	struct wacom_features *features;
@@@ -1412,15 -1604,14 +1532,21 @@@
  	}
  
  	/* Note that if query fails it is not a hard failure */
 -	wacom_query_tablet_data(hdev, features);
 +	wacom_query_tablet_data(intf, features);
  
 -	if (features->quirks & WACOM_QUIRK_MONITOR)
 -		error = hid_hw_open(hdev);
 +	usb_set_intfdata(intf, wacom);
  
++<<<<<<< HEAD
 +	if (features->quirks & WACOM_QUIRK_MONITOR) {
 +		if (usb_submit_urb(wacom->irq, GFP_KERNEL)) {
 +			error = -EIO;
 +			goto fail5;
 +		}
++=======
+ 	if (wacom_wac->features.type == INTUOSHT && 
+ 	    wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH) {
+ 			wacom_wac->shared->touch_input = wacom_wac->input;
++>>>>>>> 862cf5535c0c (HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type)
  	}
  
  	return 0;
diff --cc drivers/hid/wacom_wac.c
index bc916ccd4c20,564a06d5d727..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1474,20 -2162,57 +1474,63 @@@ static void wacom_setup_intuos(struct w
  	input_set_abs_params(input_dev, ABS_THROTTLE, -1023, 1023, 0, 0);
  }
  
 -void wacom_setup_device_quirks(struct wacom *wacom)
 +void wacom_setup_device_quirks(struct wacom_features *features)
  {
 -	struct wacom_features *features = &wacom->wacom_wac.features;
  
+ 	/* The pen and pad share the same interface on most devices */
+ 	if (features->type == GRAPHIRE_BT || features->type == WACOM_G4 ||
+ 	    features->type == DTUS || features->type == WACOM_MO ||
+ 	    (features->type >= INTUOS3S && features->type <= WACOM_13HD && 
+ 	     features->type != INTUOSHT)) {
+ 		if (features->device_type & WACOM_DEVICETYPE_PEN)
+ 			features->device_type |= WACOM_DEVICETYPE_PAD;
+ 	}
+ 
  	/* touch device found but size is not defined. use default */
 -	if (features->device_type & WACOM_DEVICETYPE_TOUCH && !features->x_max) {
 +	if (features->device_type == BTN_TOOL_FINGER && !features->x_max) {
  		features->x_max = 1023;
  		features->y_max = 1023;
  	}
  
++<<<<<<< HEAD
 +	/* these device have multiple inputs */
 +	if (features->type >= WIRELESS ||
 +	    (features->type >= INTUOS5S && features->type <= INTUOSPL) ||
 +	    (features->oVid && features->oPid))
 +		features->quirks |= WACOM_QUIRK_MULTI_INPUT;
++=======
+ 	/*
+ 	 * Intuos5/Pro and Bamboo 3rd gen have no useful data about its
+ 	 * touch interface in its HID descriptor. If this is the touch
+ 	 * interface (PacketSize of WACOM_PKGLEN_BBTOUCH3), override the
+ 	 * tablet values.
+ 	 */
+ 	if ((features->type >= INTUOS5S && features->type <= INTUOSHT) ||
+ 		(features->type == BAMBOO_PT)) {
+ 		if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 			if (features->touch_max)
+ 				features->device_type |= WACOM_DEVICETYPE_TOUCH;
+ 			if (features->type == BAMBOO_PT || features->type == INTUOSHT)
+ 				features->device_type |= WACOM_DEVICETYPE_PAD;
+ 
+ 			features->x_max = 4096;
+ 			features->y_max = 4096;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Raw Wacom-mode pen and touch events both come from interface
+ 	 * 0, whose HID descriptor has an application usage of 0xFF0D
+ 	 * (i.e., WACOM_VENDORDEFINED_PEN). We route pen packets back
+ 	 * out through the HID_GENERIC device created for interface 1,
+ 	 * so rewrite this one to be of type BTN_TOOL_FINGER.
+ 	 */
+ 	if (features->type == BAMBOO_PAD)
+ 		features->device_type |= WACOM_DEVICETYPE_TOUCH;
+ 
+ 	if (wacom->hdev->bus == BUS_BLUETOOTH)
+ 		features->quirks |= WACOM_QUIRK_BATTERY;
++>>>>>>> 862cf5535c0c (HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type)
  
  	/* quirk for bamboo touch with 2 low res touches */
  	if (features->type == BAMBOO_PT &&
@@@ -1526,8 -2253,8 +1569,13 @@@ static void wacom_abs_set_axis(struct i
  		/* penabled devices have fixed resolution for each model */
  		input_abs_set_res(input_dev, ABS_X, features->x_resolution);
  		input_abs_set_res(input_dev, ABS_Y, features->y_resolution);
++<<<<<<< HEAD
 +	} else {
 +		if (features->touch_max <= 2) {
++=======
+ 	} else if (features->device_type & WACOM_DEVICETYPE_TOUCH) {
+ 		if (features->touch_max == 1) {
++>>>>>>> 862cf5535c0c (HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type)
  			input_set_abs_params(input_dev, ABS_X, 0,
  				features->x_max, features->x_fuzz, 0);
  			input_set_abs_params(input_dev, ABS_Y, 0,
@@@ -1592,6 -2321,212 +1640,215 @@@ int wacom_setup_input_capabilities(stru
  		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
++<<<<<<< HEAD
++=======
+ 	case WACOM_27QHD:
+ 	case WACOM_24HD:
+ 	case DTK:
+ 	case WACOM_22HD:
+ 	case WACOM_21UX2:
+ 	case WACOM_BEE:
+ 	case CINTIQ:
+ 	case WACOM_13HD:
+ 	case CINTIQ_HYBRID:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 287);
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		wacom_setup_cintiq(wacom_wac);
+ 		break;
+ 
+ 	case INTUOS3:
+ 	case INTUOS3L:
+ 	case INTUOS3S:
+ 	case INTUOS4:
+ 	case INTUOS4WL:
+ 	case INTUOS4L:
+ 	case INTUOS4S:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 287);
+ 		/* fall through */
+ 
+ 	case INTUOS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		wacom_setup_intuos(wacom_wac);
+ 		break;
+ 
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		if (features->device_type & WACOM_DEVICETYPE_PEN) {
+ 			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 					      features->distance_max,
+ 					      0, 0);
+ 
+ 			input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 			input_abs_set_res(input_dev, ABS_Z, 287);
+ 
+ 			wacom_setup_intuos(wacom_wac);
+ 		} else if (features->device_type & WACOM_DEVICETYPE_TOUCH) {
+ 			__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,
+ 			                     0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR,
+ 			                     0, features->y_max, 0, 0);
+ 			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		}
+ 		break;
+ 
+ 	case WACOM_24HDT:
+ 		if (features->device_type & WACOM_DEVICETYPE_TOUCH) {
+ 			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
+ 		}
+ 		/* fall through */
+ 
+ 	case WACOM_27QHDT:
+ 	case MTSCREEN:
+ 	case MTTPC:
+ 	case MTTPC_B:
+ 	case TABLETPC2FG:
+ 		if (features->device_type & WACOM_DEVICETYPE_TOUCH && features->touch_max > 1)
+ 			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);
+ 		/* fall through */
+ 
+ 	case TABLETPC:
+ 	case TABLETPCE:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 
+ 		if (!(features->device_type & WACOM_DEVICETYPE_PEN))
+ 			break;  /* no need to process stylus stuff */
+ 
+ 		/* fall through */
+ 
+ 	case DTUS:
+ 	case DTUSX:
+ 	case PL:
+ 	case DTU:
+ 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		break;
+ 
+ 	case PTU:
+ 		__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case PENPARTNER:
+ 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 		if (features->device_type & WACOM_DEVICETYPE_TOUCH) {
+ 			input_dev->evbit[0] |= BIT_MASK(EV_SW);
+ 			__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
+ 		}
+ 		/* fall through */
+ 
+ 	case BAMBOO_PT:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		if (features->device_type & WACOM_DEVICETYPE_TOUCH) {
+ 			if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 				input_set_abs_params(input_dev,
+ 					     ABS_MT_TOUCH_MAJOR,
+ 					     0, features->x_max, 0, 0);
+ 				input_set_abs_params(input_dev,
+ 					     ABS_MT_TOUCH_MINOR,
+ 					     0, features->y_max, 0, 0);
+ 			}
+ 			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		}
+ 		if (features->device_type & WACOM_DEVICETYPE_PAD) {
+ 			/* buttons/keys only interface */
+ 			__clear_bit(ABS_X, input_dev->absbit);
+ 			__clear_bit(ABS_Y, input_dev->absbit);
+ 			__clear_bit(BTN_TOUCH, input_dev->keybit);
+ 
+ 			/* PAD is setup by wacom_setup_pad_input_capabilities later */
+ 			return 1;
+ 		}
+ 		if (features->device_type & WACOM_DEVICETYPE_PEN) {
+ 			__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 			__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 			__set_bit(BTN_STYLUS, input_dev->keybit);
+ 			__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 					      features->distance_max,
+ 					      0, 0);
+ 		}
+ 		break;
+ 	case BAMBOO_PAD:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 		input_mt_init_slots(input_dev, features->touch_max,
+ 				    INPUT_MT_POINTER);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	int i;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_PAD))
+ 		return -ENODEV;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	/* kept for making legacy xf86-input-wacom working with the wheels */
+ 	__set_bit(ABS_MISC, input_dev->absbit);
+ 
+ 	/* kept for making legacy xf86-input-wacom accepting the pad */
+ 	input_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);
+ 
+ 	/* kept for making udev and libwacom accepting the pad */
+ 	__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 	switch (features->type) {
+ 	case GRAPHIRE_BT:
+ 		__set_bit(BTN_0, input_dev->keybit);
+ 		__set_bit(BTN_1, input_dev->keybit);
+ 		break;
+ 
+ 	case WACOM_MO:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_G4:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
+ 		break;
+ 
++>>>>>>> 862cf5535c0c (HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type)
  	case WACOM_24HD:
  		__set_bit(BTN_A, input_dev->keybit);
  		__set_bit(BTN_B, input_dev->keybit);
@@@ -1713,29 -2631,20 +1970,34 @@@
  
  	case INTUOS5S:
  	case INTUOSPS:
++<<<<<<< HEAD
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
 +
 +		if (features->device_type == BTN_TOOL_PEN) {
 +			for (i = 0; i < 7; i++)
 +				__set_bit(BTN_0 + i, input_dev->keybit);
++=======
+ 		for (i = 0; i < 7; i++)
+ 			__set_bit(BTN_0 + i, input_dev->keybit);
++>>>>>>> 862cf5535c0c (HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type)
  
 -		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
 -		break;
 +			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 +					      features->distance_max,
 +					      0, 0);
  
 -	case INTUOS4WL:
 -		/*
 -		 * For Bluetooth devices, the udev rule does not work correctly
 -		 * for pads unless we add a stylus capability, which forces
 -		 * ID_INPUT_TABLET to be set.
 -		 */
 -		__set_bit(BTN_STYLUS, input_dev->keybit);
 -		/* fall through */
 +			input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
 +
 +			wacom_setup_intuos(wacom_wac);
 +		} else if (features->device_type == BTN_TOOL_FINGER) {
 +			__clear_bit(ABS_MISC, input_dev->absbit);
 +
 +			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,
 +			                     0, features->x_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR,
 +			                     0, features->y_max, 0, 0);
 +			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
 +		}
 +		break;
  
  	case INTUOS4:
  	case INTUOS4L:
@@@ -1747,103 -2656,34 +2009,108 @@@
  		for (i = 0; i < 7; i++)
  			__set_bit(BTN_0 + i, input_dev->keybit);
  
 -		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
 +		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
 +		wacom_setup_intuos(wacom_wac);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
 -	case CINTIQ_HYBRID:
 -		for (i = 0; i < 9; i++)
 -			__set_bit(BTN_0 + i, input_dev->keybit);
 +	case WACOM_24HDT:
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
 +		}
 +		/* fall through */
  
 -		break;
 +	case MTSCREEN:
 +	case MTTPC:
 +	case TABLETPC2FG:
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			unsigned int flags = INPUT_MT_DIRECT;
  
 -	case DTUS:
 -		for (i = 0; i < 4; i++)
 -			__set_bit(BTN_0 + i, input_dev->keybit);
 -		break;
 +			if (wacom_wac->features.type == TABLETPC2FG)
 +				flags = 0;
  
++<<<<<<< HEAD
 +			input_mt_init_slots(input_dev, features->touch_max, flags);
 +		}
 +		/* fall through */
 +
 +	case TABLETPC:
 +	case TABLETPCE:
++=======
+ 	case INTUOSHT:
+ 	case BAMBOO_PT:
++>>>>>>> 862cf5535c0c (HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type)
  		__clear_bit(ABS_MISC, input_dev->absbit);
  
 -		__set_bit(BTN_LEFT, input_dev->keybit);
 -		__set_bit(BTN_FORWARD, input_dev->keybit);
 -		__set_bit(BTN_BACK, input_dev->keybit);
 -		__set_bit(BTN_RIGHT, input_dev->keybit);
 +		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
 +
 +		if (features->device_type != BTN_TOOL_PEN)
 +			break;  /* no need to process stylus stuff */
 +
 +		/* fall through */
 +
 +	case PL:
 +	case DTU:
 +		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +		__set_bit(BTN_STYLUS, input_dev->keybit);
 +		__set_bit(BTN_STYLUS2, input_dev->keybit);
  
 +		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
  		break;
  
 -	default:
 -		/* no pad supported */
 -		return -ENODEV;
 +	case PTU:
 +		__set_bit(BTN_STYLUS2, input_dev->keybit);
 +		/* fall through */
 +
 +	case PENPARTNER:
 +		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +		__set_bit(BTN_STYLUS, input_dev->keybit);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
 +		break;
 +
 +	case BAMBOO_PT:
 +		__clear_bit(ABS_MISC, input_dev->absbit);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
 +
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			unsigned int flags = INPUT_MT_POINTER;
 +
 +			__set_bit(BTN_LEFT, input_dev->keybit);
 +			__set_bit(BTN_FORWARD, input_dev->keybit);
 +			__set_bit(BTN_BACK, input_dev->keybit);
 +			__set_bit(BTN_RIGHT, input_dev->keybit);
 +
 +			if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MAJOR,
 +						     0, features->x_max, 0, 0);
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MINOR,
 +						     0, features->y_max, 0, 0);
 +			} else {
 +				__set_bit(BTN_TOOL_FINGER, input_dev->keybit);
 +				__set_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);
 +				flags = 0;
 +			}
 +			input_mt_init_slots(input_dev, features->touch_max, flags);
 +		} else if (features->device_type == BTN_TOOL_PEN) {
 +			__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +			__set_bit(BTN_STYLUS, input_dev->keybit);
 +			__set_bit(BTN_STYLUS2, input_dev->keybit);
 +			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 +					      features->distance_max,
 +					      0, 0);
 +		}
 +		break;
  	}
  	return 0;
  }
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,c873c9f5b562..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -53,16 -52,43 +53,41 @@@
  #define WACOM_REPORT_TPC1FG		6
  #define WACOM_REPORT_TPC2FG		13
  #define WACOM_REPORT_TPCMT		13
 -#define WACOM_REPORT_TPCMT2		3
  #define WACOM_REPORT_TPCHID		15
 -#define WACOM_REPORT_CINTIQ		16
 -#define WACOM_REPORT_CINTIQPAD		17
  #define WACOM_REPORT_TPCST		16
 -#define WACOM_REPORT_DTUS		17
  #define WACOM_REPORT_TPC1FGE		18
  #define WACOM_REPORT_24HDT		1
 -#define WACOM_REPORT_WL			128
 -#define WACOM_REPORT_USB		192
 -#define WACOM_REPORT_BPAD_PEN		3
 -#define WACOM_REPORT_BPAD_TOUCH		16
  
  /* device quirks */
++<<<<<<< HEAD
 +#define WACOM_QUIRK_MULTI_INPUT		0x0001
 +#define WACOM_QUIRK_BBTOUCH_LOWRES	0x0002
 +#define WACOM_QUIRK_NO_INPUT		0x0004
 +#define WACOM_QUIRK_MONITOR		0x0008
++=======
+ #define WACOM_QUIRK_BBTOUCH_LOWRES	0x0001
+ #define WACOM_QUIRK_NO_INPUT		0x0002
+ #define WACOM_QUIRK_MONITOR		0x0004
+ #define WACOM_QUIRK_BATTERY		0x0008
+ 
+ /* device types */
+ #define WACOM_DEVICETYPE_NONE           0x0000
+ #define WACOM_DEVICETYPE_PEN            0x0001
+ #define WACOM_DEVICETYPE_TOUCH          0x0002
+ #define WACOM_DEVICETYPE_PAD            0x0004
+ 
+ #define WACOM_VENDORDEFINED_PEN		0xff0d0001
+ 
+ #define WACOM_PEN_FIELD(f)	(((f)->logical == HID_DG_STYLUS) || \
+ 				 ((f)->physical == HID_DG_STYLUS) || \
+ 				 ((f)->physical == HID_DG_PEN) || \
+ 				 ((f)->application == HID_DG_PEN) || \
+ 				 ((f)->application == HID_DG_DIGITIZER) || \
+ 				 ((f)->application == WACOM_VENDORDEFINED_PEN))
+ #define WACOM_FINGER_FIELD(f)	(((f)->logical == HID_DG_FINGER) || \
+ 				 ((f)->physical == HID_DG_FINGER) || \
+ 				 ((f)->application == HID_DG_TOUCHSCREEN))
++>>>>>>> 862cf5535c0c (HID: wacom: Introduce a new WACOM_DEVICETYPE_PAD device_type)
  
  enum {
  	PENPARTNER = 0,
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
* Unmerged path drivers/hid/wacom_wac.h
