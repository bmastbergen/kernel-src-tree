bridge: vlan: use br_vlan_should_use to simplify __vlan_add/del

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit 6be144f62f64c8a67e11b2f8b86c7bf390b87411
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6be144f6.failed

The checks that lead to num_vlans change are always what
br_vlan_should_use checks for, namely if the vlan is only a context or
not and depending on that it's either not counted or counted
as a real/used vlan respectively.
Also give better explanation in br_vlan_should_use's comment.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6be144f62f64c8a67e11b2f8b86c7bf390b87411)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_private.h
#	net/bridge/br_vlan.c
diff --cc net/bridge/br_private.h
index b75519ca3c51,1ff6a0faef3f..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -331,6 -388,31 +331,34 @@@ static inline int br_is_root_bridge(con
  	return !memcmp(&br->bridge_id, &br->designated_root, 8);
  }
  
++<<<<<<< HEAD
++=======
+ /* check if a VLAN entry is global */
+ static inline bool br_vlan_is_master(const struct net_bridge_vlan *v)
+ {
+ 	return v->flags & BRIDGE_VLAN_INFO_MASTER;
+ }
+ 
+ /* check if a VLAN entry is used by the bridge */
+ static inline bool br_vlan_is_brentry(const struct net_bridge_vlan *v)
+ {
+ 	return v->flags & BRIDGE_VLAN_INFO_BRENTRY;
+ }
+ 
+ /* check if we should use the vlan entry, returns false if it's only context */
+ static inline bool br_vlan_should_use(const struct net_bridge_vlan *v)
+ {
+ 	if (br_vlan_is_master(v)) {
+ 		if (br_vlan_is_brentry(v))
+ 			return true;
+ 		else
+ 			return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
++>>>>>>> 6be144f62f64 (bridge: vlan: use br_vlan_should_use to simplify __vlan_add/del)
  /* br_device.c */
  void br_dev_setup(struct net_device *dev);
  void br_dev_delete(struct net_device *dev, struct list_head *list);
diff --cc net/bridge/br_vlan.c
index 1122c9d717ea,b879111582f0..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -20,70 -46,268 +20,164 @@@ static void __vlan_delete_pvid(struct n
  		return;
  
  	smp_wmb();
 -	vg->pvid = 0;
 +	v->pvid = 0;
  }
  
 -static void __vlan_add_flags(struct net_bridge_vlan *v, u16 flags)
 +static void __vlan_add_flags(struct net_port_vlans *v, u16 vid, u16 flags)
  {
 -	struct net_bridge_vlan_group *vg;
 -
 -	if (br_vlan_is_master(v))
 -		vg = v->br->vlgrp;
 -	else
 -		vg = v->port->vlgrp;
 -
  	if (flags & BRIDGE_VLAN_INFO_PVID)
 -		__vlan_add_pvid(vg, v->vid);
 +		__vlan_add_pvid(v, vid);
  	else
 -		__vlan_delete_pvid(vg, v->vid);
 +		__vlan_delete_pvid(v, vid);
  
  	if (flags & BRIDGE_VLAN_INFO_UNTAGGED)
 -		v->flags |= BRIDGE_VLAN_INFO_UNTAGGED;
 +		set_bit(vid, v->untagged_bitmap);
  	else
 -		v->flags &= ~BRIDGE_VLAN_INFO_UNTAGGED;
 -}
 -
 -static int __vlan_vid_add(struct net_device *dev, struct net_bridge *br,
 -			  u16 vid, u16 flags)
 -{
 -	const struct net_device_ops *ops = dev->netdev_ops;
 -	int err;
 -
 -	/* If driver uses VLAN ndo ops, use 8021q to install vid
 -	 * on device, otherwise try switchdev ops to install vid.
 -	 */
 -
 -	if (ops->ndo_vlan_rx_add_vid) {
 -		err = vlan_vid_add(dev, br->vlan_proto, vid);
 -	} else {
 -		struct switchdev_obj_port_vlan v = {
 -			.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,
 -			.flags = flags,
 -			.vid_begin = vid,
 -			.vid_end = vid,
 -		};
 -
 -		err = switchdev_port_obj_add(dev, &v.obj);
 -		if (err == -EOPNOTSUPP)
 -			err = 0;
 -	}
 -
 -	return err;
 -}
 -
 -static void __vlan_add_list(struct net_bridge_vlan *v)
 -{
 -	struct list_head *headp, *hpos;
 -	struct net_bridge_vlan *vent;
 -
 -	headp = br_vlan_is_master(v) ? &v->br->vlgrp->vlan_list :
 -				       &v->port->vlgrp->vlan_list;
 -	list_for_each_prev(hpos, headp) {
 -		vent = list_entry(hpos, struct net_bridge_vlan, vlist);
 -		if (v->vid < vent->vid)
 -			continue;
 -		else
 -			break;
 -	}
 -	list_add_rcu(&v->vlist, hpos);
 -}
 -
 -static void __vlan_del_list(struct net_bridge_vlan *v)
 -{
 -	list_del_rcu(&v->vlist);
 +		clear_bit(vid, v->untagged_bitmap);
  }
  
 -static int __vlan_vid_del(struct net_device *dev, struct net_bridge *br,
 -			  u16 vid)
 +static int __vlan_add(struct net_port_vlans *v, u16 vid, u16 flags)
  {
 -	const struct net_device_ops *ops = dev->netdev_ops;
 -	int err = 0;
 -
 -	/* If driver uses VLAN ndo ops, use 8021q to delete vid
 -	 * on device, otherwise try switchdev ops to delete vid.
 -	 */
 -
 -	if (ops->ndo_vlan_rx_kill_vid) {
 -		vlan_vid_del(dev, br->vlan_proto, vid);
 -	} else {
 -		struct switchdev_obj_port_vlan v = {
 -			.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,
 -			.vid_begin = vid,
 -			.vid_end = vid,
 -		};
 -
 -		err = switchdev_port_obj_del(dev, &v.obj);
 -		if (err == -EOPNOTSUPP)
 -			err = 0;
 -	}
 -
 -	return err;
 -}
 -
 -/* Returns a master vlan, if it didn't exist it gets created. In all cases a
 - * a reference is taken to the master vlan before returning.
 - */
 -static struct net_bridge_vlan *br_vlan_get_master(struct net_bridge *br, u16 vid)
 -{
 -	struct net_bridge_vlan *masterv;
 -
 -	masterv = br_vlan_find(br->vlgrp, vid);
 -	if (!masterv) {
 -		/* missing global ctx, create it now */
 -		if (br_vlan_add(br, vid, 0))
 -			return NULL;
 -		masterv = br_vlan_find(br->vlgrp, vid);
 -		if (WARN_ON(!masterv))
 -			return NULL;
 -	}
 -	atomic_inc(&masterv->refcnt);
 -
 -	return masterv;
 -}
 -
 -static void br_vlan_put_master(struct net_bridge_vlan *masterv)
 -{
 -	if (!br_vlan_is_master(masterv))
 -		return;
 -
 -	if (atomic_dec_and_test(&masterv->refcnt)) {
 -		rhashtable_remove_fast(&masterv->br->vlgrp->vlan_hash,
 -				       &masterv->vnode, br_vlan_rht_params);
 -		__vlan_del_list(masterv);
 -		kfree_rcu(masterv, rcu);
 -	}
 -}
 -
 -/* This is the shared VLAN add function which works for both ports and bridge
 - * devices. There are four possible calls to this function in terms of the
 - * vlan entry type:
 - * 1. vlan is being added on a port (no master flags, global entry exists)
 - * 2. vlan is being added on a bridge (both master and brvlan flags)
 - * 3. vlan is being added on a port, but a global entry didn't exist which
 - *    is being created right now (master flag set, brvlan flag unset), the
 - *    global entry is used for global per-vlan features, but not for filtering
 - * 4. same as 3 but with both master and brvlan flags set so the entry
 - *    will be used for filtering in both the port and the bridge
 - */
 -static int __vlan_add(struct net_bridge_vlan *v, u16 flags)
 -{
 -	struct net_bridge_vlan *masterv = NULL;
  	struct net_bridge_port *p = NULL;
++<<<<<<< HEAD
++=======
+ 	struct net_bridge_vlan_group *vg;
+ 	struct net_device *dev;
++>>>>>>> 6be144f62f64 (bridge: vlan: use br_vlan_should_use to simplify __vlan_add/del)
  	struct net_bridge *br;
 +	struct net_device *dev;
  	int err;
  
++<<<<<<< HEAD
 +	if (test_bit(vid, v->vlan_bitmap)) {
 +		__vlan_add_flags(v, vid, flags);
 +		return 0;
 +	}
 +
 +	if (v->port_idx) {
 +		p = v->parent.port;
 +		br = p->br;
 +		dev = p->dev;
 +	} else {
 +		br = v->parent.br;
 +		dev = br->dev;
++=======
+ 	if (br_vlan_is_master(v)) {
+ 		br = v->br;
+ 		dev = br->dev;
+ 		vg = br->vlgrp;
+ 	} else {
+ 		p = v->port;
+ 		br = p->br;
+ 		dev = p->dev;
+ 		vg = p->vlgrp;
++>>>>>>> 6be144f62f64 (bridge: vlan: use br_vlan_should_use to simplify __vlan_add/del)
  	}
  
 -	if (p) {
 +	/* Toggle HW filters when filtering is enabled */
 +	if (p && p->br->vlan_enabled) {
  		/* Add VLAN to the device filter if it is supported.
  		 * This ensures tagged traffic enters the bridge when
  		 * promiscuous mode is disabled by br_manage_promisc().
  		 */
 -		err = __vlan_vid_add(dev, br, v->vid, flags);
 +		err = vlan_vid_add(dev, br->vlan_proto, vid);
  		if (err)
 -			goto out;
 -
 -		/* need to work on the master vlan too */
 -		if (flags & BRIDGE_VLAN_INFO_MASTER) {
 -			err = br_vlan_add(br, v->vid, flags |
 -						      BRIDGE_VLAN_INFO_BRENTRY);
 -			if (err)
 -				goto out_filt;
 -		}
 +			return err;
 +	}
  
 -		masterv = br_vlan_get_master(br, v->vid);
 -		if (!masterv)
 -			goto out_filt;
 -		v->brvlan = masterv;
++<<<<<<< HEAD
 +	err = br_fdb_insert(br, p, dev->dev_addr, vid);
 +	if (err) {
 +		br_err(br, "failed insert local address into bridge "
 +		       "forwarding table\n");
 +		goto out_filt;
  	}
  
 +	set_bit(vid, v->vlan_bitmap);
 +	v->num_vlans++;
 +	__vlan_add_flags(v, vid, flags);
 +
 +	return 0;
 +
 +out_filt:
 +	if (p && p->br->vlan_enabled)
 +		vlan_vid_del(dev, br->vlan_proto, vid);
++=======
+ 	/* Add the dev mac and count the vlan only if it's usable */
+ 	if (br_vlan_should_use(v)) {
+ 		err = br_fdb_insert(br, p, dev->dev_addr, v->vid);
+ 		if (err) {
+ 			br_err(br, "failed insert local address into bridge forwarding table\n");
+ 			goto out_filt;
+ 		}
+ 		vg->num_vlans++;
+ 	}
+ 
+ 	err = rhashtable_lookup_insert_fast(&vg->vlan_hash, &v->vnode,
+ 					    br_vlan_rht_params);
+ 	if (err)
+ 		goto out_fdb_insert;
+ 
+ 	__vlan_add_list(v);
+ 	__vlan_add_flags(v, flags);
+ out:
+ 	return err;
+ 
+ out_fdb_insert:
+ 	if (br_vlan_should_use(v)) {
+ 		br_fdb_find_delete_local(br, p, dev->dev_addr, v->vid);
+ 		vg->num_vlans--;
+ 	}
+ 
+ out_filt:
+ 	if (p) {
+ 		__vlan_vid_del(dev, br, v->vid);
+ 		if (masterv) {
+ 			br_vlan_put_master(masterv);
+ 			v->brvlan = NULL;
+ 		}
+ 	}
+ 
+ 	goto out;
+ }
+ 
+ static int __vlan_del(struct net_bridge_vlan *v)
+ {
+ 	struct net_bridge_vlan *masterv = v;
+ 	struct net_bridge_vlan_group *vg;
+ 	struct net_bridge_port *p = NULL;
+ 	int err = 0;
+ 
+ 	if (br_vlan_is_master(v)) {
+ 		vg = v->br->vlgrp;
+ 	} else {
+ 		p = v->port;
+ 		vg = v->port->vlgrp;
+ 		masterv = v->brvlan;
+ 	}
+ 
+ 	__vlan_delete_pvid(vg, v->vid);
+ 	if (p) {
+ 		err = __vlan_vid_del(p->dev, p->br, v->vid);
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ 	if (br_vlan_should_use(v)) {
+ 		v->flags &= ~BRIDGE_VLAN_INFO_BRENTRY;
+ 		vg->num_vlans--;
+ 	}
+ 
+ 	if (masterv != v) {
+ 		rhashtable_remove_fast(&vg->vlan_hash, &v->vnode,
+ 				       br_vlan_rht_params);
+ 		__vlan_del_list(v);
+ 		kfree_rcu(v, rcu);
+ 	}
+ 
+ 	br_vlan_put_master(masterv);
+ out:
++>>>>>>> 6be144f62f64 (bridge: vlan: use br_vlan_should_use to simplify __vlan_add/del)
  	return err;
  }
  
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_vlan.c
