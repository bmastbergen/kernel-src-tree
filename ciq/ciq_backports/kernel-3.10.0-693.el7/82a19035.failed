amd-xgbe: Add ACPI support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit 82a19035d000c8b4fd7d6f61b614f63dec75d389
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/82a19035.failed

Add support for ACPI to the amd-xgbe and amd-xgbe-phy drivers. This
support converts many of the device tree APIs to the new device_property
APIs.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 82a19035d000c8b4fd7d6f61b614f63dec75d389)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/Kconfig
#	drivers/net/ethernet/amd/xgbe/xgbe-dev.c
#	drivers/net/ethernet/amd/xgbe/xgbe-main.c
#	drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
#	drivers/net/ethernet/amd/xgbe/xgbe-ptp.c
#	drivers/net/ethernet/amd/xgbe/xgbe.h
#	drivers/net/phy/Kconfig
diff --cc drivers/net/ethernet/amd/Kconfig
index 13d74aa4033d,5d3b5202327c..000000000000
--- a/drivers/net/ethernet/amd/Kconfig
+++ b/drivers/net/ethernet/amd/Kconfig
@@@ -179,4 -177,29 +179,32 @@@ config SUNLANC
  	  To compile this driver as a module, choose M here: the module
  	  will be called sunlance.
  
++<<<<<<< HEAD
++=======
+ config AMD_XGBE
+ 	tristate "AMD 10GbE Ethernet driver"
+ 	depends on (OF_NET || ACPI) && HAS_IOMEM
+ 	select PHYLIB
+ 	select AMD_XGBE_PHY
+ 	select BITREVERSE
+ 	select CRC32
+ 	select PTP_1588_CLOCK
+ 	---help---
+ 	  This driver supports the AMD 10GbE Ethernet device found on an
+ 	  AMD SoC.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called amd-xgbe.
+ 
+ config AMD_XGBE_DCB
+ 	bool "Data Center Bridging (DCB) support"
+ 	default n
+ 	depends on AMD_XGBE && DCB
+ 	---help---
+ 	  Say Y here to enable Data Center Bridging (DCB) support in the
+ 	  driver.
+ 
+ 	  If unsure, say N.
+ 
++>>>>>>> 82a19035d000 (amd-xgbe: Add ACPI support)
  endif # NET_VENDOR_AMD
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-dev.c
index ec5481f846ee,da593c42d183..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
@@@ -130,7 -131,7 +130,11 @@@ static unsigned int xgbe_usec_to_riwt(s
  
  	DBGPR("-->xgbe_usec_to_riwt\n");
  
++<<<<<<< HEAD
 +	rate = clk_get_rate(pdata->sysclock);
++=======
+ 	rate = pdata->sysclk_rate;
++>>>>>>> 82a19035d000 (amd-xgbe: Add ACPI support)
  
  	/*
  	 * Convert the input usec value to the watchdog timer value. Each
@@@ -153,7 -154,7 +157,11 @@@ static unsigned int xgbe_riwt_to_usec(s
  
  	DBGPR("-->xgbe_riwt_to_usec\n");
  
++<<<<<<< HEAD
 +	rate = clk_get_rate(pdata->sysclock);
++=======
+ 	rate = pdata->sysclk_rate;
++>>>>>>> 82a19035d000 (amd-xgbe: Add ACPI support)
  
  	/*
  	 * Convert the input watchdog timer value to the usec value. Each
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-main.c
index 51cdca78ec38,32dd65137051..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-main.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-main.c
@@@ -225,7 -263,8 +318,12 @@@ static int xgbe_probe(struct platform_d
  	struct net_device *netdev;
  	struct device *dev = &pdev->dev;
  	struct resource *res;
++<<<<<<< HEAD
 +	const u8 *mac_addr;
++=======
+ 	const char *phy_mode;
+ 	unsigned int i;
++>>>>>>> 82a19035d000 (amd-xgbe: Add ACPI support)
  	int ret;
  
  	DBGPR("--> xgbe_probe\n");
@@@ -246,7 -286,12 +345,10 @@@
  
  	spin_lock_init(&pdata->lock);
  	mutex_init(&pdata->xpcs_mutex);
 -	mutex_init(&pdata->rss_mutex);
 -	spin_lock_init(&pdata->tstamp_lock);
  
+ 	/* Check if we should use ACPI or DT */
+ 	pdata->use_acpi = (!pdata->adev || acpi_disabled) ? 0 : 1;
+ 
  	/* Set and validate the number of descriptors for a ring */
  	BUILD_BUG_ON_NOT_POWER_OF_2(XGBE_TX_DESC_CNT);
  	pdata->tx_desc_count = XGBE_TX_DESC_CNT;
@@@ -265,14 -310,6 +367,17 @@@
  		goto err_io;
  	}
  
++<<<<<<< HEAD
 +	/* Obtain the system clock setting */
 +	pdata->sysclock = devm_clk_get(dev, NULL);
 +	if (IS_ERR(pdata->sysclock)) {
 +		dev_err(dev, "devm_clk_get failed\n");
 +		ret = PTR_ERR(pdata->sysclock);
 +		goto err_io;
 +	}
 +
++=======
++>>>>>>> 82a19035d000 (amd-xgbe: Add ACPI support)
  	/* Obtain the mmio areas for the device */
  	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
  	pdata->xgmac_regs = devm_ioremap_resource(dev, res);
@@@ -311,13 -374,26 +442,27 @@@
  		pdata->awcache = XGBE_DMA_SYS_AWCACHE;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Set the DMA mask */
+ 	if (!dev->dma_mask)
+ 		dev->dma_mask = &dev->coherent_dma_mask;
+ 	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(40));
+ 	if (ret) {
+ 		dev_err(dev, "dma_set_mask_and_coherent failed\n");
+ 		goto err_io;
+ 	}
+ 
+ 	/* Get the device interrupt */
++>>>>>>> 82a19035d000 (amd-xgbe: Add ACPI support)
  	ret = platform_get_irq(pdev, 0);
  	if (ret < 0) {
 -		dev_err(dev, "platform_get_irq 0 failed\n");
 +		dev_err(dev, "platform_get_irq failed\n");
  		goto err_io;
  	}
 -	pdata->dev_irq = ret;
 -
 -	netdev->irq = pdata->dev_irq;
 +	netdev->irq = ret;
  	netdev->base_addr = (unsigned long)pdata->xgmac_regs;
+ 	memcpy(netdev->dev_addr, pdata->mac_addr, netdev->addr_len);
  
  	/* Set all the function pointers */
  	xgbe_init_all_fptrs(pdata);
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
index 8514b5841ecd,59e267f3f1b7..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
@@@ -278,27 -205,16 +278,32 @@@ void xgbe_dump_phy_registers(struct xgb
  
  int xgbe_mdio_register(struct xgbe_prv_data *pdata)
  {
++<<<<<<< HEAD
 +	struct net_device *netdev = pdata->netdev;
 +	struct device_node *phy_node;
++=======
++>>>>>>> 82a19035d000 (amd-xgbe: Add ACPI support)
  	struct mii_bus *mii;
  	struct phy_device *phydev;
  	int ret = 0;
  
  	DBGPR("-->xgbe_mdio_register\n");
  
++<<<<<<< HEAD
 +	/* Retrieve the phy-handle */
 +	phy_node = of_parse_phandle(pdata->dev->of_node, "phy-handle", 0);
 +	if (!phy_node) {
 +		dev_err(pdata->dev, "unable to parse phy-handle\n");
 +		return -EINVAL;
 +	}
 +
 +	/* Register with the MDIO bus */
++=======
++>>>>>>> 82a19035d000 (amd-xgbe: Add ACPI support)
  	mii = mdiobus_alloc();
 -	if (!mii) {
 +	if (mii == NULL) {
  		dev_err(pdata->dev, "mdiobus_alloc failed\n");
- 		ret = -ENOMEM;
- 		goto err_node_get;
+ 		return -ENOMEM;
  	}
  
  	/* Register on the MDIO bus (don't probe any PHYs) */
diff --cc drivers/net/ethernet/amd/xgbe/xgbe.h
index 1d8899bca25d,13e8f95c077c..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@@ -162,6 -182,25 +162,28 @@@
  #define XGBE_PHY_NAME		"amd_xgbe_phy"
  #define XGBE_PRTAD		0
  
++<<<<<<< HEAD
++=======
+ /* Common property names */
+ #define XGBE_MAC_ADDR_PROPERTY	"mac-address"
+ #define XGBE_PHY_MODE_PROPERTY	"phy-mode"
+ #define XGBE_DMA_IRQS_PROPERTY	"amd,per-channel-interrupt"
+ 
+ /* Device-tree clock names */
+ #define XGBE_DMA_CLOCK		"dma_clk"
+ #define XGBE_PTP_CLOCK		"ptp_clk"
+ 
+ /* ACPI property names */
+ #define XGBE_ACPI_DMA_FREQ	"amd,dma-freq"
+ #define XGBE_ACPI_PTP_FREQ	"amd,ptp-freq"
+ 
+ /* Timestamp support - values based on 50MHz PTP clock
+  *   50MHz => 20 nsec
+  */
+ #define XGBE_TSTAMP_SSINC	20
+ #define XGBE_TSTAMP_SNSINC	0
+ 
++>>>>>>> 82a19035d000 (amd-xgbe: Add ACPI support)
  /* Driver PMT macros */
  #define XGMAC_DRIVER_CONTEXT	1
  #define XGMAC_IOCTL_CONTEXT	2
@@@ -598,8 -752,32 +626,37 @@@ struct xgbe_prv_data 
  	struct napi_struct napi;
  	struct xgbe_mmc_stats mmc_stats;
  
++<<<<<<< HEAD
 +	/* System clock value used for Rx watchdog */
 +	struct clk *sysclock;
++=======
+ 	/* Filtering support */
+ 	unsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
+ 
+ 	/* Device clocks */
+ 	struct clk *sysclk;
+ 	unsigned long sysclk_rate;
+ 	struct clk *ptpclk;
+ 	unsigned long ptpclk_rate;
+ 
+ 	/* Timestamp support */
+ 	spinlock_t tstamp_lock;
+ 	struct ptp_clock_info ptp_clock_info;
+ 	struct ptp_clock *ptp_clock;
+ 	struct hwtstamp_config tstamp_config;
+ 	struct cyclecounter tstamp_cc;
+ 	struct timecounter tstamp_tc;
+ 	unsigned int tstamp_addend;
+ 	struct work_struct tx_tstamp_work;
+ 	struct sk_buff *tx_tstamp_skb;
+ 	u64 tx_tstamp;
+ 
+ 	/* DCB support */
+ 	struct ieee_ets *ets;
+ 	struct ieee_pfc *pfc;
+ 	unsigned int q2tc_map[XGBE_MAX_QUEUES];
+ 	unsigned int prio2q_map[IEEE_8021QAZ_MAX_TCS];
++>>>>>>> 82a19035d000 (amd-xgbe: Add ACPI support)
  
  	/* Hardware features of the device */
  	struct xgbe_hw_features hw_feat;
diff --cc drivers/net/phy/Kconfig
index d11186ce57fb,16adbc481772..000000000000
--- a/drivers/net/phy/Kconfig
+++ b/drivers/net/phy/Kconfig
@@@ -24,6 -24,12 +24,15 @@@ config AMD_PH
  	---help---
  	  Currently supports the am79c874
  
++<<<<<<< HEAD
++=======
+ config AMD_XGBE_PHY
+ 	tristate "Driver for the AMD 10GbE (amd-xgbe) PHYs"
+ 	depends on (OF || ACPI) && HAS_IOMEM
+ 	---help---
+ 	  Currently supports the AMD 10GbE PHY
+ 
++>>>>>>> 82a19035d000 (amd-xgbe: Add ACPI support)
  config MARVELL_PHY
  	tristate "Drivers for Marvell PHYs"
  	---help---
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-ptp.c
* Unmerged path drivers/net/ethernet/amd/Kconfig
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-dev.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-main.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-ptp.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe.h
* Unmerged path drivers/net/phy/Kconfig
diff --git a/drivers/net/phy/amd-xgbe-phy.c b/drivers/net/phy/amd-xgbe-phy.c
index f36aaae1f87a..ec87dce7b9ae 100644
--- a/drivers/net/phy/amd-xgbe-phy.c
+++ b/drivers/net/phy/amd-xgbe-phy.c
@@ -76,6 +76,8 @@
 #include <linux/of_device.h>
 #include <linux/uaccess.h>
 #include <linux/bitops.h>
+#include <linux/property.h>
+#include <linux/acpi.h>
 
 MODULE_AUTHOR("Tom Lendacky <thomas.lendacky@amd.com>");
 MODULE_LICENSE("Dual BSD/GPL");
@@ -323,12 +325,13 @@ enum amd_xgbe_phy_mode {
 };
 
 enum amd_xgbe_phy_speedset {
-	AMD_XGBE_PHY_SPEEDSET_1000_10000,
+	AMD_XGBE_PHY_SPEEDSET_1000_10000 = 0,
 	AMD_XGBE_PHY_SPEEDSET_2500_10000,
 };
 
 struct amd_xgbe_phy_priv {
 	struct platform_device *pdev;
+	struct acpi_device *adev;
 	struct device *dev;
 
 	struct phy_device *phydev;
@@ -1420,46 +1423,94 @@ static int amd_xgbe_phy_resume(struct phy_device *phydev)
 	return 0;
 }
 
+static unsigned int amd_xgbe_phy_resource_count(struct platform_device *pdev,
+						unsigned int type)
+{
+	unsigned int count;
+	int i;
+
+	for (i = 0, count = 0; i < pdev->num_resources; i++) {
+		struct resource *r = &pdev->resource[i];
+
+		if (type == resource_type(r))
+			count++;
+	}
+
+	return count;
+}
+
 static int amd_xgbe_phy_probe(struct phy_device *phydev)
 {
 	struct amd_xgbe_phy_priv *priv;
-	struct platform_device *pdev;
-	struct device *dev;
-	const __be32 *property;
-	unsigned int speed_set;
+	struct platform_device *phy_pdev;
+	struct device *dev, *phy_dev;
+	unsigned int phy_resnum, phy_irqnum;
 	int ret;
 
-	if (!phydev->dev.of_node)
+	if (!phydev->bus || !phydev->bus->parent)
 		return -EINVAL;
 
-	pdev = of_find_device_by_node(phydev->dev.of_node);
-	if (!pdev)
-		return -EINVAL;
-	dev = &pdev->dev;
+	dev = phydev->bus->parent;
 
 	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		ret = -ENOMEM;
-		goto err_pdev;
-	}
+	if (!priv)
+		return -ENOMEM;
 
-	priv->pdev = pdev;
+	priv->pdev = to_platform_device(dev);
+	priv->adev = ACPI_COMPANION(dev);
 	priv->dev = dev;
 	priv->phydev = phydev;
 	mutex_init(&priv->an_mutex);
 	INIT_WORK(&priv->an_irq_work, amd_xgbe_an_irq_work);
 	INIT_WORK(&priv->an_work, amd_xgbe_an_state_machine);
 
+	if (!priv->adev || acpi_disabled) {
+		struct device_node *bus_node;
+		struct device_node *phy_node;
+
+		bus_node = priv->dev->of_node;
+		phy_node = of_parse_phandle(bus_node, "phy-handle", 0);
+		if (!phy_node) {
+			dev_err(dev, "unable to parse phy-handle\n");
+			ret = -EINVAL;
+			goto err_priv;
+		}
+
+		phy_pdev = of_find_device_by_node(phy_node);
+		of_node_put(phy_node);
+
+		if (!phy_pdev) {
+			dev_err(dev, "unable to obtain phy device\n");
+			ret = -EINVAL;
+			goto err_priv;
+		}
+
+		phy_resnum = 0;
+		phy_irqnum = 0;
+	} else {
+		/* In ACPI, the XGBE and PHY resources are the grouped
+		 * together with the PHY resources at the end
+		 */
+		phy_pdev = priv->pdev;
+		phy_resnum = amd_xgbe_phy_resource_count(phy_pdev,
+							 IORESOURCE_MEM) - 3;
+		phy_irqnum = amd_xgbe_phy_resource_count(phy_pdev,
+							 IORESOURCE_IRQ) - 1;
+	}
+	phy_dev = &phy_pdev->dev;
+
 	/* Get the device mmio areas */
-	priv->rxtx_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->rxtx_res = platform_get_resource(phy_pdev, IORESOURCE_MEM,
+					       phy_resnum++);
 	priv->rxtx_regs = devm_ioremap_resource(dev, priv->rxtx_res);
 	if (IS_ERR(priv->rxtx_regs)) {
 		dev_err(dev, "rxtx ioremap failed\n");
 		ret = PTR_ERR(priv->rxtx_regs);
-		goto err_priv;
+		goto err_put;
 	}
 
-	priv->sir0_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	priv->sir0_res = platform_get_resource(phy_pdev, IORESOURCE_MEM,
+					       phy_resnum++);
 	priv->sir0_regs = devm_ioremap_resource(dev, priv->sir0_res);
 	if (IS_ERR(priv->sir0_regs)) {
 		dev_err(dev, "sir0 ioremap failed\n");
@@ -1467,7 +1518,8 @@ static int amd_xgbe_phy_probe(struct phy_device *phydev)
 		goto err_rxtx;
 	}
 
-	priv->sir1_res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	priv->sir1_res = platform_get_resource(phy_pdev, IORESOURCE_MEM,
+					       phy_resnum++);
 	priv->sir1_regs = devm_ioremap_resource(dev, priv->sir1_res);
 	if (IS_ERR(priv->sir1_regs)) {
 		dev_err(dev, "sir1 ioremap failed\n");
@@ -1476,7 +1528,7 @@ static int amd_xgbe_phy_probe(struct phy_device *phydev)
 	}
 
 	/* Get the auto-negotiation interrupt */
-	ret = platform_get_irq(pdev, 0);
+	ret = platform_get_irq(phy_pdev, phy_irqnum);
 	if (ret < 0) {
 		dev_err(dev, "platform_get_irq failed\n");
 		goto err_sir1;
@@ -1484,28 +1536,29 @@ static int amd_xgbe_phy_probe(struct phy_device *phydev)
 	priv->an_irq = ret;
 
 	/* Get the device speed set property */
-	speed_set = 0;
-	property = of_get_property(dev->of_node, XGBE_PHY_SPEEDSET_PROPERTY,
-				   NULL);
-	if (property)
-		speed_set = be32_to_cpu(*property);
-
-	switch (speed_set) {
-	case 0:
-		priv->speed_set = AMD_XGBE_PHY_SPEEDSET_1000_10000;
-		break;
-	case 1:
-		priv->speed_set = AMD_XGBE_PHY_SPEEDSET_2500_10000;
+	ret = device_property_read_u32(phy_dev, XGBE_PHY_SPEEDSET_PROPERTY,
+				       &priv->speed_set);
+	if (ret) {
+		dev_err(dev, "invalid %s property\n",
+			XGBE_PHY_SPEEDSET_PROPERTY);
+		goto err_sir1;
+	}
+
+	switch (priv->speed_set) {
+	case AMD_XGBE_PHY_SPEEDSET_1000_10000:
+	case AMD_XGBE_PHY_SPEEDSET_2500_10000:
 		break;
 	default:
-		dev_err(dev, "invalid amd,speed-set property\n");
+		dev_err(dev, "invalid %s property\n",
+			XGBE_PHY_SPEEDSET_PROPERTY);
 		ret = -EINVAL;
 		goto err_sir1;
 	}
 
 	phydev->priv = priv;
 
-	of_dev_put(pdev);
+	if (!priv->adev || acpi_disabled)
+		platform_device_put(phy_pdev);
 
 	return 0;
 
@@ -1524,12 +1577,13 @@ err_rxtx:
 	devm_release_mem_region(dev, priv->rxtx_res->start,
 				resource_size(priv->rxtx_res));
 
+err_put:
+	if (!priv->adev || acpi_disabled)
+		platform_device_put(phy_pdev);
+
 err_priv:
 	devm_kfree(dev, priv);
 
-err_pdev:
-	of_dev_put(pdev);
-
 	return ret;
 }
 
