ipv6: fix ip6_tnl_parse_tlv_enc_lim()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric Dumazet <edumazet@google.com>
commit fbfa743a9d2a0ffa24251764f10afc13eb21e739
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fbfa743a.failed

This function suffers from multiple issues.

First one is that pskb_may_pull() may reallocate skb->head,
so the 'raw' pointer needs either to be reloaded or not used at all.

Second issue is that NEXTHDR_DEST handling does not validate
that the options are present in skb->data, so we might read
garbage or access non existent memory.

With help from Willem de Bruijn.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Reported-by: Dmitry Vyukov  <dvyukov@google.com>
	Cc: Willem de Bruijn <willemb@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fbfa743a9d2a0ffa24251764f10afc13eb21e739)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_tunnel.c
diff --cc net/ipv6/ip6_tunnel.c
index 2a4b43ddc51c,ff8ee06491c3..000000000000
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@@ -387,18 -400,19 +387,30 @@@ ip6_tnl_dev_uninit(struct net_device *d
  
  __u16 ip6_tnl_parse_tlv_enc_lim(struct sk_buff *skb, __u8 *raw)
  {
++<<<<<<< HEAD
 +	const struct ipv6hdr *ipv6h = (const struct ipv6hdr *) raw;
 +	__u8 nexthdr = ipv6h->nexthdr;
 +	__u16 off = sizeof (*ipv6h);
++=======
+ 	const struct ipv6hdr *ipv6h = (const struct ipv6hdr *)raw;
+ 	unsigned int nhoff = raw - skb->data;
+ 	unsigned int off = nhoff + sizeof(*ipv6h);
+ 	u8 next, nexthdr = ipv6h->nexthdr;
++>>>>>>> fbfa743a9d2a (ipv6: fix ip6_tnl_parse_tlv_enc_lim())
  
  	while (ipv6_ext_hdr(nexthdr) && nexthdr != NEXTHDR_NONE) {
- 		__u16 optlen = 0;
  		struct ipv6_opt_hdr *hdr;
++<<<<<<< HEAD
 +		if (raw + off + sizeof (*hdr) > skb->data &&
 +		    !pskb_may_pull(skb, raw - skb->data + off + sizeof (*hdr)))
++=======
+ 		u16 optlen;
+ 
+ 		if (!pskb_may_pull(skb, off + sizeof(*hdr)))
++>>>>>>> fbfa743a9d2a (ipv6: fix ip6_tnl_parse_tlv_enc_lim())
  			break;
  
- 		hdr = (struct ipv6_opt_hdr *) (raw + off);
+ 		hdr = (struct ipv6_opt_hdr *)(skb->data + off);
  		if (nexthdr == NEXTHDR_FRAGMENT) {
  			struct frag_hdr *frag_hdr = (struct frag_hdr *) hdr;
  			if (frag_hdr->frag_off)
* Unmerged path net/ipv6/ip6_tunnel.c
