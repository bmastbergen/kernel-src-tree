vfs: add copy_file_range syscall and vfs helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Zach Brown <zab@redhat.com>
commit 29732938a6289a15e907da234d6692a2ead71855
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/29732938.failed

Add a copy_file_range() system call for offloading copies between
regular files.

This gives an interface to underlying layers of the storage stack which
can copy without reading and writing all the data.  There are a few
candidates that should support copy offloading in the nearer term:

- btrfs shares extent references with its clone ioctl
- NFS has patches to add a COPY command which copies on the server
- SCSI has a family of XCOPY commands which copy in the device

This system call avoids the complexity of also accelerating the creation
of the destination file by operating on an existing destination file
descriptor, not a path.

Currently the high level vfs entry point limits copy offloading to files
on the same mount and super (and not in the same file).  This can be
relaxed if we get implementations which can copy between file systems
safely.

	Signed-off-by: Zach Brown <zab@redhat.com>
[Anna Schumaker: Change -EINVAL to -EBADF during file verification,
                 Change flags parameter from int to unsigned int,
                 Add function to include/linux/syscalls.h,
                 Check copy len after file open mode,
                 Don't forbid ranges inside the same file,
                 Use rw_verify_area() to veriy ranges,
                 Use file_out rather than file_in,
                 Add COPY_FR_REFLINK flag]
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 29732938a6289a15e907da234d6692a2ead71855)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/read_write.c
#	include/linux/fs.h
#	include/linux/syscalls.h
#	include/uapi/asm-generic/unistd.h
#	kernel/sys_ni.c
diff --cc fs/read_write.c
index b7e6d43449bd,173140029a7a..000000000000
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@@ -17,7 -16,7 +17,11 @@@
  #include <linux/pagemap.h>
  #include <linux/splice.h>
  #include <linux/compat.h>
++<<<<<<< HEAD
 +#include <linux/fs.h>
++=======
+ #include <linux/mount.h>
++>>>>>>> 29732938a628 (vfs: add copy_file_range syscall and vfs helper)
  #include "internal.h"
  
  #include <asm/uaccess.h>
diff --cc include/linux/fs.h
index 98b7caca3399,e8a736242b1a..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -1696,24 -1622,19 +1696,32 @@@ struct file_operations 
  	int (*flock) (struct file *, int, struct file_lock *);
  	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
  	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
 -	int (*setlease)(struct file *, long, struct file_lock **, void **);
 +	RH_KABI_REPLACE(int (*setlease)(struct file *, long, struct file_lock **), int (*setlease)(struct file *, long, struct file_lock **, void **))
  	long (*fallocate)(struct file *file, int mode, loff_t offset,
  			  loff_t len);
++<<<<<<< HEAD
 +	int (*show_fdinfo)(struct seq_file *m, struct file *f);
++=======
+ 	void (*show_fdinfo)(struct seq_file *m, struct file *f);
+ #ifndef CONFIG_MMU
+ 	unsigned (*mmap_capabilities)(struct file *);
+ #endif
+ 	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
++>>>>>>> 29732938a628 (vfs: add copy_file_range syscall and vfs helper)
  };
  
 +/* RH usage only, not for external modules use */
 +struct file_operations_extend {
 +	struct file_operations kabi_fops;
 +	void (*mremap)(struct file *, struct vm_area_struct *);
 +};
 +
 +#define to_fop_extend(fop)	\
 +	container_of((fop), struct file_operations_extend, kabi_fops)
 +
  struct inode_operations {
  	struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
 -	const char * (*follow_link) (struct dentry *, void **);
 +	void * (*follow_link) (struct dentry *, struct nameidata *);
  	int (*permission) (struct inode *, int);
  	struct posix_acl * (*get_acl)(struct inode *, int);
  
diff --cc include/linux/syscalls.h
index f7e027947e33,185815c96433..000000000000
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@@ -860,4 -875,21 +860,24 @@@ asmlinkage long sys_process_vm_writev(p
  asmlinkage long sys_kcmp(pid_t pid1, pid_t pid2, int type,
  			 unsigned long idx1, unsigned long idx2);
  asmlinkage long sys_finit_module(int fd, const char __user *uargs, int flags);
++<<<<<<< HEAD
++=======
+ asmlinkage long sys_seccomp(unsigned int op, unsigned int flags,
+ 			    const char __user *uargs);
+ asmlinkage long sys_getrandom(char __user *buf, size_t count,
+ 			      unsigned int flags);
+ asmlinkage long sys_bpf(int cmd, union bpf_attr *attr, unsigned int size);
+ 
+ asmlinkage long sys_execveat(int dfd, const char __user *filename,
+ 			const char __user *const __user *argv,
+ 			const char __user *const __user *envp, int flags);
+ 
+ asmlinkage long sys_membarrier(int cmd, int flags);
+ asmlinkage long sys_copy_file_range(int fd_in, loff_t __user *off_in,
+ 				    int fd_out, loff_t __user *off_out,
+ 				    size_t len, unsigned int flags);
+ 
+ asmlinkage long sys_mlock2(unsigned long start, size_t len, int flags);
+ 
++>>>>>>> 29732938a628 (vfs: add copy_file_range syscall and vfs helper)
  #endif
diff --cc include/uapi/asm-generic/unistd.h
index 0cc74c4403e4,2622b33fb2ec..000000000000
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@@ -692,9 -693,33 +692,39 @@@ __SC_COMP(__NR_process_vm_writev, sys_p
  __SYSCALL(__NR_kcmp, sys_kcmp)
  #define __NR_finit_module 273
  __SYSCALL(__NR_finit_module, sys_finit_module)
++<<<<<<< HEAD
 +
 +#undef __NR_syscalls
 +#define __NR_syscalls 274
++=======
+ #define __NR_sched_setattr 274
+ __SYSCALL(__NR_sched_setattr, sys_sched_setattr)
+ #define __NR_sched_getattr 275
+ __SYSCALL(__NR_sched_getattr, sys_sched_getattr)
+ #define __NR_renameat2 276
+ __SYSCALL(__NR_renameat2, sys_renameat2)
+ #define __NR_seccomp 277
+ __SYSCALL(__NR_seccomp, sys_seccomp)
+ #define __NR_getrandom 278
+ __SYSCALL(__NR_getrandom, sys_getrandom)
+ #define __NR_memfd_create 279
+ __SYSCALL(__NR_memfd_create, sys_memfd_create)
+ #define __NR_bpf 280
+ __SYSCALL(__NR_bpf, sys_bpf)
+ #define __NR_execveat 281
+ __SC_COMP(__NR_execveat, sys_execveat, compat_sys_execveat)
+ #define __NR_userfaultfd 282
+ __SYSCALL(__NR_userfaultfd, sys_userfaultfd)
+ #define __NR_membarrier 283
+ __SYSCALL(__NR_membarrier, sys_membarrier)
+ #define __NR_mlock2 284
+ __SYSCALL(__NR_mlock2, sys_mlock2)
+ #define __NR_copy_file_range 285
+ __SYSCALL(__NR_copy_file_range, sys_copy_file_range)
+ 
+ #undef __NR_syscalls
+ #define __NR_syscalls 286
++>>>>>>> 29732938a628 (vfs: add copy_file_range syscall and vfs helper)
  
  /*
   * All syscalls below here should go away really,
diff --cc kernel/sys_ni.c
index 432df2b697ce,2c5e3a8e00d7..000000000000
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@@ -152,6 -156,25 +152,28 @@@ cond_syscall(sys_process_vm_readv)
  cond_syscall(sys_process_vm_writev);
  cond_syscall(compat_sys_process_vm_readv);
  cond_syscall(compat_sys_process_vm_writev);
++<<<<<<< HEAD
++=======
+ cond_syscall(sys_uselib);
+ cond_syscall(sys_fadvise64);
+ cond_syscall(sys_fadvise64_64);
+ cond_syscall(sys_madvise);
+ cond_syscall(sys_setuid);
+ cond_syscall(sys_setregid);
+ cond_syscall(sys_setgid);
+ cond_syscall(sys_setreuid);
+ cond_syscall(sys_setresuid);
+ cond_syscall(sys_getresuid);
+ cond_syscall(sys_setresgid);
+ cond_syscall(sys_getresgid);
+ cond_syscall(sys_setgroups);
+ cond_syscall(sys_getgroups);
+ cond_syscall(sys_setfsuid);
+ cond_syscall(sys_setfsgid);
+ cond_syscall(sys_capget);
+ cond_syscall(sys_capset);
+ cond_syscall(sys_copy_file_range);
++>>>>>>> 29732938a628 (vfs: add copy_file_range syscall and vfs helper)
  
  /* arch-specific weak syscall entries */
  cond_syscall(sys_pciconfig_read);
* Unmerged path fs/read_write.c
* Unmerged path include/linux/fs.h
* Unmerged path include/linux/syscalls.h
* Unmerged path include/uapi/asm-generic/unistd.h
* Unmerged path kernel/sys_ni.c
