xfs: debug mode forced buffered write failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 801cc4e17a34c32e1527827292fac9cec5d3393b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/801cc4e1.failed

Add a DEBUG mode-only sysfs knob to enable forced buffered write
failure. An additional side effect of this mode is brute force killing
of delayed allocation blocks in the range of the write. The latter is
the prime motiviation behind this patch, as userspace test
infrastructure requires a reliable mechanism to create and split
delalloc extents without causing extent conversion.

Certain fallocate operations (i.e., zero range) were used for this in
the past, but the implementations have changed such that delalloc
extents are flushed and converted to real blocks, rendering the test
useless.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 801cc4e17a34c32e1527827292fac9cec5d3393b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_mount.h
#	fs/xfs/xfs_sysfs.c
diff --cc fs/xfs/xfs_mount.h
index dd34ef8b5b74,546cf46a97ce..000000000000
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@@ -176,7 -147,17 +176,21 @@@ typedef struct xfs_mount 
  	 * to various other kinds of pain inflicted on the pNFS server.
  	 */
  	__uint32_t		m_generation;
++<<<<<<< HEAD
 +	bool			m_fail_unmount;
++=======
+ 
+ #ifdef DEBUG
+ 	/*
+ 	 * DEBUG mode instrumentation to test and/or trigger delayed allocation
+ 	 * block killing in the event of failed writes. When enabled, all
+ 	 * buffered writes are forced to fail. All delalloc blocks in the range
+ 	 * of the write (including pre-existing delalloc blocks!) are tossed as
+ 	 * part of the write failure error handling sequence.
+ 	 */
+ 	bool			m_fail_writes;
+ #endif
++>>>>>>> 801cc4e17a34 (xfs: debug mode forced buffered write failure)
  } xfs_mount_t;
  
  /*
diff --cc fs/xfs/xfs_sysfs.c
index 9b869def86c1,6ced4f143494..000000000000
--- a/fs/xfs/xfs_sysfs.c
+++ b/fs/xfs/xfs_sysfs.c
@@@ -17,11 -17,10 +17,18 @@@
   */
  
  #include "xfs.h"
++<<<<<<< HEAD
 +#include "xfs_shared.h"
 +#include "xfs_format.h"
 +#include "xfs_log_format.h"
 +#include "xfs_trans_resv.h"
 +#include "xfs_sysfs.h"
++=======
+ #include "xfs_sysfs.h"
+ #include "xfs_format.h"
+ #include "xfs_log_format.h"
+ #include "xfs_trans_resv.h"
++>>>>>>> 801cc4e17a34 (xfs: debug mode forced buffered write failure)
  #include "xfs_log.h"
  #include "xfs_log_priv.h"
  #include "xfs_stats.h"
diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c
index acf6c4a54883..1eb4706818ca 100644
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@ -1773,6 +1773,7 @@ xfs_vm_write_failed(
 	loff_t			from = pos & (PAGE_CACHE_SIZE - 1);
 	loff_t			to = from + len;
 	struct buffer_head	*bh, *head;
+	struct xfs_mount	*mp = XFS_I(inode)->i_mount;
 
 	/*
 	 * The request pos offset might be 32 or 64 bit, this is all fine
@@ -1814,7 +1815,8 @@ xfs_vm_write_failed(
 		if (!buffer_delay(bh) && !buffer_unwritten(bh))
 			continue;
 
-		if (!buffer_new(bh) && block_offset < i_size_read(inode))
+		if (!xfs_mp_fail_writes(mp) && !buffer_new(bh) &&
+		    block_offset < i_size_read(inode))
 			continue;
 
 		if (buffer_delay(bh))
@@ -1854,6 +1856,7 @@ xfs_vm_write_begin(
 	pgoff_t			index = pos >> PAGE_CACHE_SHIFT;
 	struct page		*page;
 	int			status;
+	struct xfs_mount	*mp = XFS_I(mapping->host)->i_mount;
 
 	ASSERT(len <= PAGE_CACHE_SIZE);
 
@@ -1862,6 +1865,8 @@ xfs_vm_write_begin(
 		return -ENOMEM;
 
 	status = __block_write_begin(page, pos, len, xfs_get_blocks);
+	if (xfs_mp_fail_writes(mp))
+		status = -EIO;
 	if (unlikely(status)) {
 		struct inode	*inode = mapping->host;
 		size_t		isize = i_size_read(inode);
@@ -1874,6 +1879,8 @@ xfs_vm_write_begin(
 		 * allocated in this write, not blocks that were previously
 		 * written successfully.
 		 */
+		if (xfs_mp_fail_writes(mp))
+			isize = 0;
 		if (pos + len > isize) {
 			ssize_t start = max_t(ssize_t, pos, isize);
 
* Unmerged path fs/xfs/xfs_mount.h
* Unmerged path fs/xfs/xfs_sysfs.c
