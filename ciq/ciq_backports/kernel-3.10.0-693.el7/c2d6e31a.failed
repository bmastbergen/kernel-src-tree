net/mlx5: Align sriov/eswitch modules with the new load/unload flow.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Align sriov/eswitch modules with the new load/unload flow (Don Dutile) [1385214 1385330 1417285]
Rebuild_FUZZ: 96.18%
commit-author Mohamad Haj Yahia <mohamad@mellanox.com>
commit c2d6e31a0008f8188f935f8dd81c81c44697b256
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c2d6e31a.failed

Init/cleanup sriov/eswitch in the core software context init/cleanup
flows.
Attach/detach sriov/eswitch in the core load/unload flows.

	Signed-off-by: Mohamad Haj Yahia <mohamad@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c2d6e31a0008f8188f935f8dd81c81c44697b256)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/main.c
#	drivers/net/ethernet/mellanox/mlx5/core/sriov.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/main.c
index e782d0fde09e,16660cf16e0d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@@ -994,8 -1093,102 +994,107 @@@ static void mlx5_pci_close(struct mlx5_
  	debugfs_remove(priv->dbg_root);
  }
  
++<<<<<<< HEAD
 +#define MLX5_IB_MOD "mlx5_ib"
 +static int mlx5_load_one(struct mlx5_core_dev *dev, struct mlx5_priv *priv)
++=======
+ static int mlx5_init_once(struct mlx5_core_dev *dev, struct mlx5_priv *priv)
+ {
+ 	struct pci_dev *pdev = dev->pdev;
+ 	int err;
+ 
+ 	err = mlx5_query_hca_caps(dev);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "query hca failed\n");
+ 		goto out;
+ 	}
+ 
+ 	err = mlx5_query_board_id(dev);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "query board id failed\n");
+ 		goto out;
+ 	}
+ 
+ 	err = mlx5_eq_init(dev);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "failed to initialize eq\n");
+ 		goto out;
+ 	}
+ 
+ 	MLX5_INIT_DOORBELL_LOCK(&priv->cq_uar_lock);
+ 
+ 	err = mlx5_init_cq_table(dev);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "failed to initialize cq table\n");
+ 		goto err_eq_cleanup;
+ 	}
+ 
+ 	mlx5_init_qp_table(dev);
+ 
+ 	mlx5_init_srq_table(dev);
+ 
+ 	mlx5_init_mkey_table(dev);
+ 
+ 	err = mlx5_init_rl_table(dev);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "Failed to init rate limiting\n");
+ 		goto err_tables_cleanup;
+ 	}
+ 
+ #ifdef CONFIG_MLX5_CORE_EN
+ 	err = mlx5_eswitch_init(dev);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "Failed to init eswitch %d\n", err);
+ 		goto err_rl_cleanup;
+ 	}
+ #endif
+ 
+ 	err = mlx5_sriov_init(dev);
+ 	if (err) {
+ 		dev_err(&pdev->dev, "Failed to init sriov %d\n", err);
+ 		goto err_eswitch_cleanup;
+ 	}
+ 
+ 	return 0;
+ 
+ err_eswitch_cleanup:
+ #ifdef CONFIG_MLX5_CORE_EN
+ 	mlx5_eswitch_cleanup(dev->priv.eswitch);
+ 
+ err_rl_cleanup:
+ #endif
+ 	mlx5_cleanup_rl_table(dev);
+ 
+ err_tables_cleanup:
+ 	mlx5_cleanup_mkey_table(dev);
+ 	mlx5_cleanup_srq_table(dev);
+ 	mlx5_cleanup_qp_table(dev);
+ 	mlx5_cleanup_cq_table(dev);
+ 
+ err_eq_cleanup:
+ 	mlx5_eq_cleanup(dev);
+ 
+ out:
+ 	return err;
+ }
+ 
+ static void mlx5_cleanup_once(struct mlx5_core_dev *dev)
+ {
+ 	mlx5_sriov_cleanup(dev);
+ #ifdef CONFIG_MLX5_CORE_EN
+ 	mlx5_eswitch_cleanup(dev->priv.eswitch);
+ #endif
+ 	mlx5_cleanup_rl_table(dev);
+ 	mlx5_cleanup_mkey_table(dev);
+ 	mlx5_cleanup_srq_table(dev);
+ 	mlx5_cleanup_qp_table(dev);
+ 	mlx5_cleanup_cq_table(dev);
+ 	mlx5_eq_cleanup(dev);
+ }
+ 
+ static int mlx5_load_one(struct mlx5_core_dev *dev, struct mlx5_priv *priv,
+ 			 bool boot)
++>>>>>>> c2d6e31a0008 (net/mlx5: Align sriov/eswitch modules with the new load/unload flow.)
  {
  	struct pci_dev *pdev = dev->pdev;
  	int err;
@@@ -1144,15 -1317,12 +1243,11 @@@
  		dev_err(&pdev->dev, "Failed to init flow steering\n");
  		goto err_fs;
  	}
 -
  #ifdef CONFIG_MLX5_CORE_EN
- 	err = mlx5_eswitch_init(dev);
- 	if (err) {
- 		dev_err(&pdev->dev, "eswitch init failed %d\n", err);
- 		goto err_reg_dev;
- 	}
+ 	mlx5_eswitch_attach(dev->priv.eswitch);
  #endif
  
- 	err = mlx5_sriov_init(dev);
+ 	err = mlx5_sriov_attach(dev);
  	if (err) {
  		dev_err(&pdev->dev, "sriov init failed %d\n", err);
  		goto err_sriov;
@@@ -1175,21 -1345,19 +1270,27 @@@ out
  
  	return 0;
  
++<<<<<<< HEAD
++=======
+ err_reg_dev:
+ 	mlx5_sriov_detach(dev);
+ 
++>>>>>>> c2d6e31a0008 (net/mlx5: Align sriov/eswitch modules with the new load/unload flow.)
  err_sriov:
 +	if (mlx5_sriov_cleanup(dev))
 +		dev_err(&dev->pdev->dev, "sriov cleanup failed\n");
 +
  #ifdef CONFIG_MLX5_CORE_EN
- 	mlx5_eswitch_cleanup(dev->priv.eswitch);
+ 	mlx5_eswitch_detach(dev->priv.eswitch);
  #endif
 +err_reg_dev:
  	mlx5_cleanup_fs(dev);
 -
  err_fs:
 +	mlx5_cleanup_mkey_table(dev);
 +	mlx5_cleanup_srq_table(dev);
 +	mlx5_cleanup_qp_table(dev);
 +	mlx5_cleanup_cq_table(dev);
  	mlx5_irq_clear_affinity_hints(dev);
 -
 -err_affinity_hints:
  	free_comp_eqs(dev);
  
  err_stop_eqs:
@@@ -1246,18 -1408,19 +1347,26 @@@ static int mlx5_unload_one(struct mlx5_
  	if (test_bit(MLX5_INTERFACE_STATE_DOWN, &dev->intf_state)) {
  		dev_warn(&dev->pdev->dev, "%s: interface is down, NOP\n",
  			 __func__);
 -		if (cleanup)
 -			mlx5_cleanup_once(dev);
  		goto out;
  	}
++<<<<<<< HEAD
 +	mlx5_unregister_device(dev);
++=======
+ 
+ 	if (mlx5_device_registered(dev))
+ 		mlx5_detach_device(dev);
+ 
+ 	mlx5_sriov_detach(dev);
++>>>>>>> c2d6e31a0008 (net/mlx5: Align sriov/eswitch modules with the new load/unload flow.)
  #ifdef CONFIG_MLX5_CORE_EN
- 	mlx5_eswitch_cleanup(dev->priv.eswitch);
+ 	mlx5_eswitch_detach(dev->priv.eswitch);
  #endif
 +
  	mlx5_cleanup_fs(dev);
 +	mlx5_cleanup_mkey_table(dev);
 +	mlx5_cleanup_srq_table(dev);
 +	mlx5_cleanup_qp_table(dev);
 +	mlx5_cleanup_cq_table(dev);
  	mlx5_irq_clear_affinity_hints(dev);
  	free_comp_eqs(dev);
  	mlx5_stop_eqs(dev);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/sriov.c
index d6a3f412ba9f,e08627785590..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
@@@ -204,30 -222,15 +204,39 @@@ int mlx5_sriov_init(struct mlx5_core_de
  	if (!sriov->vfs_ctx)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	sriov->enabled_vfs = cur_vfs;
 +
 +	mlx5_core_init_vfs(dev, cur_vfs);
 +#ifdef CONFIG_MLX5_CORE_EN
 +	if (cur_vfs)
 +		mlx5_eswitch_enable_sriov(dev->priv.eswitch, cur_vfs);
 +#endif
 +
 +	enable_vfs(dev, cur_vfs);
 +
++=======
++>>>>>>> c2d6e31a0008 (net/mlx5: Align sriov/eswitch modules with the new load/unload flow.)
  	return 0;
  }
  
 -void mlx5_sriov_cleanup(struct mlx5_core_dev *dev)
 +int mlx5_sriov_cleanup(struct mlx5_core_dev *dev)
  {
 -	struct mlx5_core_sriov *sriov = &dev->priv.sriov;
 +	struct pci_dev *pdev = dev->pdev;
 +	int err;
  
  	if (!mlx5_core_is_pf(dev))
++<<<<<<< HEAD
 +		return 0;
 +
 +	err = mlx5_core_sriov_configure(pdev, 0);
 +	if (err)
 +		return err;
 +
 +	return 0;
++=======
+ 		return;
+ 
+ 	kfree(sriov->vfs_ctx);
++>>>>>>> c2d6e31a0008 (net/mlx5: Align sriov/eswitch modules with the new load/unload flow.)
  }
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 084178cfa483..c1d4d9a3b1b8 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -1380,7 +1380,6 @@ int mlx5_eswitch_init(struct mlx5_core_dev *dev)
 	esw->total_vports = total_vports;
 	esw->enabled_vports = 0;
 
-	mlx5_eswitch_attach(esw);
 	dev->priv.eswitch = esw;
 	return 0;
 abort:
@@ -1400,7 +1399,6 @@ void mlx5_eswitch_cleanup(struct mlx5_eswitch *esw)
 
 	esw_info(esw->dev, "cleanup\n");
 
-	mlx5_eswitch_detach(esw);
 	esw->dev->priv.eswitch = NULL;
 	destroy_workqueue(esw->work_queue);
 	kfree(esw->l2_table.bitmap);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/sriov.c
