KVM: PPC: select IRQ_BYPASS_MANAGER

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Suresh Warrier <warrier@linux.vnet.ibm.com>
commit 9576730d0e6e301343c5aead5418ad53fcecfd14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9576730d.failed

Select IRQ_BYPASS_MANAGER for PPC when CONFIG_KVM is set.
Add the PPC producer functions for add and del producer.

[paulus@ozlabs.org - Moved new functions from book3s.c to powerpc.c
 so booke compiles; added kvm_arch_has_irq_bypass implementation.]

	Signed-off-by: Suresh Warrier <warrier@linux.vnet.ibm.com>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit 9576730d0e6e301343c5aead5418ad53fcecfd14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/Kconfig
#	arch/powerpc/kvm/powerpc.c
diff --cc arch/powerpc/kvm/Kconfig
index 4ec24122d057,029be26b5a17..000000000000
--- a/arch/powerpc/kvm/Kconfig
+++ b/arch/powerpc/kvm/Kconfig
@@@ -21,6 -21,10 +21,13 @@@ config KV
  	select PREEMPT_NOTIFIERS
  	select ANON_INODES
  	select HAVE_KVM_EVENTFD
++<<<<<<< HEAD
++=======
+ 	select SRCU
+ 	select KVM_VFIO
+ 	select IRQ_BYPASS_MANAGER
+ 	select HAVE_KVM_IRQ_BYPASS
++>>>>>>> 9576730d0e6e (KVM: PPC: select IRQ_BYPASS_MANAGER)
  
  config KVM_BOOK3S_HANDLER
  	bool
diff --cc arch/powerpc/kvm/powerpc.c
index 64a0fde48c79,0b7d66422650..000000000000
--- a/arch/powerpc/kvm/powerpc.c
+++ b/arch/powerpc/kvm/powerpc.c
@@@ -739,10 -741,40 +741,47 @@@ void kvm_arch_vcpu_put(struct kvm_vcpu 
  #endif
  }
  
++<<<<<<< HEAD
 +static void kvmppc_complete_dcr_load(struct kvm_vcpu *vcpu,
 +                                     struct kvm_run *run)
 +{
 +	kvmppc_set_gpr(vcpu, vcpu->arch.io_gpr, run->dcr.data);
++=======
+ /*
+  * irq_bypass_add_producer and irq_bypass_del_producer are only
+  * useful if the architecture supports PCI passthrough.
+  * irq_bypass_stop and irq_bypass_start are not needed and so
+  * kvm_ops are not defined for them.
+  */
+ bool kvm_arch_has_irq_bypass(void)
+ {
+ 	return ((kvmppc_hv_ops && kvmppc_hv_ops->irq_bypass_add_producer) ||
+ 		(kvmppc_pr_ops && kvmppc_pr_ops->irq_bypass_add_producer));
+ }
+ 
+ int kvm_arch_irq_bypass_add_producer(struct irq_bypass_consumer *cons,
+ 				     struct irq_bypass_producer *prod)
+ {
+ 	struct kvm_kernel_irqfd *irqfd =
+ 		container_of(cons, struct kvm_kernel_irqfd, consumer);
+ 	struct kvm *kvm = irqfd->kvm;
+ 
+ 	if (kvm->arch.kvm_ops->irq_bypass_add_producer)
+ 		return kvm->arch.kvm_ops->irq_bypass_add_producer(cons, prod);
+ 
+ 	return 0;
+ }
+ 
+ void kvm_arch_irq_bypass_del_producer(struct irq_bypass_consumer *cons,
+ 				      struct irq_bypass_producer *prod)
+ {
+ 	struct kvm_kernel_irqfd *irqfd =
+ 		container_of(cons, struct kvm_kernel_irqfd, consumer);
+ 	struct kvm *kvm = irqfd->kvm;
+ 
+ 	if (kvm->arch.kvm_ops->irq_bypass_del_producer)
+ 		kvm->arch.kvm_ops->irq_bypass_del_producer(cons, prod);
++>>>>>>> 9576730d0e6e (KVM: PPC: select IRQ_BYPASS_MANAGER)
  }
  
  static void kvmppc_complete_mmio_load(struct kvm_vcpu *vcpu,
diff --git a/arch/powerpc/include/asm/kvm_ppc.h b/arch/powerpc/include/asm/kvm_ppc.h
index 4af3129ec8aa..cf8827a4d68f 100644
--- a/arch/powerpc/include/asm/kvm_ppc.h
+++ b/arch/powerpc/include/asm/kvm_ppc.h
@@ -273,6 +273,10 @@ struct kvmppc_ops {
 	long (*arch_vm_ioctl)(struct file *filp, unsigned int ioctl,
 			      unsigned long arg);
 	int (*hcall_implemented)(unsigned long hcall);
+	int (*irq_bypass_add_producer)(struct irq_bypass_consumer *,
+				       struct irq_bypass_producer *);
+	void (*irq_bypass_del_producer)(struct irq_bypass_consumer *,
+					struct irq_bypass_producer *);
 };
 
 extern struct kvmppc_ops *kvmppc_hv_ops;
* Unmerged path arch/powerpc/kvm/Kconfig
* Unmerged path arch/powerpc/kvm/powerpc.c
