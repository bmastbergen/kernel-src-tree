net/mlx5: Query and cache PCAM, MCAM registers on initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Query and cache PCAM, MCAM registers on initialization (Kamal Heib) [1409101]
Rebuild_FUZZ: 96.77%
commit-author Gal Pressman <galp@mellanox.com>
commit 71862561f3a62015a11de16d1c306481e8415c08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/71862561.failed

On load_one, we now cache our capabilities registers internally, similar
to QUERY_HCA_CAP. Capabilities can later be queried using macros
introduced in this patch.

	Signed-off-by: Gal Pressman <galp@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 71862561f3a62015a11de16d1c306481e8415c08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fw.c
#	include/linux/mlx5/device.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fw.c
index 6a560c38d5cd,d0bbefa08af7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fw.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fw.c
@@@ -151,6 -162,18 +165,21 @@@ int mlx5_query_hca_caps(struct mlx5_cor
  			return err;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (MLX5_CAP_GEN(dev, qos)) {
+ 		err = mlx5_core_get_caps(dev, MLX5_CAP_QOS);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (MLX5_CAP_GEN(dev, pcam_reg))
+ 		mlx5_get_pcam_reg(dev);
+ 
+ 	if (MLX5_CAP_GEN(dev, mcam_reg))
+ 		mlx5_get_mcam_reg(dev);
+ 
++>>>>>>> 71862561f3a6 (net/mlx5: Query and cache PCAM, MCAM registers on initialization)
  	return 0;
  }
  
diff --cc include/linux/mlx5/device.h
index bcbc4ce3547e,f21528abfb74..000000000000
--- a/include/linux/mlx5/device.h
+++ b/include/linux/mlx5/device.h
@@@ -1220,6 -1078,15 +1220,18 @@@ enum mlx5_cap_type 
  	MLX5_GET(vector_calc_cap, \
  		 mdev->hca_caps_cur[MLX5_CAP_VECTOR_CALC], cap)
  
++<<<<<<< HEAD
++=======
+ #define MLX5_CAP_QOS(mdev, cap)\
+ 	MLX5_GET(qos_cap, mdev->hca_caps_cur[MLX5_CAP_QOS], cap)
+ 
+ #define MLX5_CAP_PCAM_FEATURE(mdev, fld) \
+ 	MLX5_GET(pcam_reg, (mdev)->caps.pcam, feature_cap_mask.enhanced_features.fld)
+ 
+ #define MLX5_CAP_MCAM_FEATURE(mdev, fld) \
+ 	MLX5_GET(mcam_reg, (mdev)->caps.mcam, mng_feature_cap_mask.enhanced_features.fld)
+ 
++>>>>>>> 71862561f3a6 (net/mlx5: Query and cache PCAM, MCAM registers on initialization)
  enum {
  	MLX5_CMD_STAT_OK			= 0x0,
  	MLX5_CMD_STAT_INT_ERR			= 0x1,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fw.c
* Unmerged path include/linux/mlx5/device.h
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index b16df05fa672..4c9e3fa2f47d 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -568,6 +568,10 @@ struct mlx5_core_dev {
 	struct mlx5_port_caps	port_caps[MLX5_MAX_PORTS];
 	u32 hca_caps_cur[MLX5_CAP_NUM][MLX5_UN_SZ_DW(hca_cap_union)];
 	u32 hca_caps_max[MLX5_CAP_NUM][MLX5_UN_SZ_DW(hca_cap_union)];
+	struct {
+		u32 pcam[MLX5_ST_SZ_DW(pcam_reg)];
+		u32 mcam[MLX5_ST_SZ_DW(mcam_reg)];
+	} caps;
 	phys_addr_t		iseg_base;
 	struct mlx5_init_seg __iomem *iseg;
 	enum mlx5_device_state	state;
