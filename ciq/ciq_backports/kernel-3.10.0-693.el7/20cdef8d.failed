selinux: delay inode label lookup as long as possible

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Paul Moore <paul@paul-moore.com>
commit 20cdef8d57591ec8674f65ccfe555aca5fd10b64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/20cdef8d.failed

Since looking up an inode's label can result in revalidation, delay
the lookup as long as possible to limit the performance impact.

	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit 20cdef8d57591ec8674f65ccfe555aca5fd10b64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
diff --cc security/selinux/hooks.c
index 85f0076df17e,b09aad7ad423..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -1665,6 -1781,32 +1665,35 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Determine the label for an inode that might be unioned.
+  */
+ static int selinux_determine_inode_label(struct inode *dir,
+ 					 const struct qstr *name,
+ 					 u16 tclass,
+ 					 u32 *_new_isid)
+ {
+ 	const struct superblock_security_struct *sbsec = dir->i_sb->s_security;
+ 	const struct task_security_struct *tsec = current_security();
+ 
+ 	if ((sbsec->flags & SE_SBINITIALIZED) &&
+ 	    (sbsec->behavior == SECURITY_FS_USE_MNTPOINT)) {
+ 		*_new_isid = sbsec->mntpoint_sid;
+ 	} else if ((sbsec->flags & SBLABEL_MNT) &&
+ 		   tsec->create_sid) {
+ 		*_new_isid = tsec->create_sid;
+ 	} else {
+ 		const struct inode_security_struct *dsec = inode_security(dir);
+ 		return security_transition_sid(tsec->sid, dsec->sid, tclass,
+ 					       name, _new_isid);
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 20cdef8d5759 (selinux: delay inode label lookup as long as possible)
  /* Check whether a task can create a file. */
  static int may_create(struct inode *dir,
  		      struct dentry *dentry,
@@@ -1900,6 -2039,75 +1929,78 @@@ static inline u32 open_file_to_av(struc
  
  /* Hook functions begin here. */
  
++<<<<<<< HEAD
++=======
+ static int selinux_binder_set_context_mgr(struct task_struct *mgr)
+ {
+ 	u32 mysid = current_sid();
+ 	u32 mgrsid = task_sid(mgr);
+ 
+ 	return avc_has_perm(mysid, mgrsid, SECCLASS_BINDER,
+ 			    BINDER__SET_CONTEXT_MGR, NULL);
+ }
+ 
+ static int selinux_binder_transaction(struct task_struct *from,
+ 				      struct task_struct *to)
+ {
+ 	u32 mysid = current_sid();
+ 	u32 fromsid = task_sid(from);
+ 	u32 tosid = task_sid(to);
+ 	int rc;
+ 
+ 	if (mysid != fromsid) {
+ 		rc = avc_has_perm(mysid, fromsid, SECCLASS_BINDER,
+ 				  BINDER__IMPERSONATE, NULL);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	return avc_has_perm(fromsid, tosid, SECCLASS_BINDER, BINDER__CALL,
+ 			    NULL);
+ }
+ 
+ static int selinux_binder_transfer_binder(struct task_struct *from,
+ 					  struct task_struct *to)
+ {
+ 	u32 fromsid = task_sid(from);
+ 	u32 tosid = task_sid(to);
+ 
+ 	return avc_has_perm(fromsid, tosid, SECCLASS_BINDER, BINDER__TRANSFER,
+ 			    NULL);
+ }
+ 
+ static int selinux_binder_transfer_file(struct task_struct *from,
+ 					struct task_struct *to,
+ 					struct file *file)
+ {
+ 	u32 sid = task_sid(to);
+ 	struct file_security_struct *fsec = file->f_security;
+ 	struct dentry *dentry = file->f_path.dentry;
+ 	struct inode_security_struct *isec;
+ 	struct common_audit_data ad;
+ 	int rc;
+ 
+ 	ad.type = LSM_AUDIT_DATA_PATH;
+ 	ad.u.path = file->f_path;
+ 
+ 	if (sid != fsec->sid) {
+ 		rc = avc_has_perm(sid, fsec->sid,
+ 				  SECCLASS_FD,
+ 				  FD__USE,
+ 				  &ad);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
+ 		return 0;
+ 
+ 	isec = backing_inode_security(dentry);
+ 	return avc_has_perm(sid, isec->sid, isec->sclass, file_to_av(file),
+ 			    &ad);
+ }
+ 
++>>>>>>> 20cdef8d5759 (selinux: delay inode label lookup as long as possible)
  static int selinux_ptrace_access_check(struct task_struct *child,
  				     unsigned int mode)
  {
@@@ -2902,8 -3057,8 +3003,13 @@@ static int selinux_inode_setotherxattr(
  static int selinux_inode_setxattr(struct dentry *dentry, const char *name,
  				  const void *value, size_t size, int flags)
  {
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_inode;
 +	struct inode_security_struct *isec = inode->i_security;
++=======
+ 	struct inode *inode = d_backing_inode(dentry);
+ 	struct inode_security_struct *isec;
++>>>>>>> 20cdef8d5759 (selinux: delay inode label lookup as long as possible)
  	struct superblock_security_struct *sbsec;
  	struct common_audit_data ad;
  	u32 newsid, sid = current_sid();
@@@ -2979,8 -3135,8 +3086,13 @@@ static void selinux_inode_post_setxattr
  					const void *value, size_t size,
  					int flags)
  {
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_inode;
 +	struct inode_security_struct *isec = inode->i_security;
++=======
+ 	struct inode *inode = d_backing_inode(dentry);
+ 	struct inode_security_struct *isec;
++>>>>>>> 20cdef8d5759 (selinux: delay inode label lookup as long as possible)
  	u32 newsid;
  	int rc;
  
@@@ -2997,9 -3153,10 +3109,10 @@@
  		return;
  	}
  
+ 	isec = backing_inode_security(dentry);
  	isec->sclass = inode_mode_to_security_class(inode->i_mode);
  	isec->sid = newsid;
 -	isec->initialized = LABEL_INITIALIZED;
 +	isec->initialized = 1;
  
  	return;
  }
@@@ -3038,7 -3195,7 +3151,11 @@@ static int selinux_inode_getsecurity(co
  	u32 size;
  	int error;
  	char *context = NULL;
++<<<<<<< HEAD
 +	struct inode_security_struct *isec = inode->i_security;
++=======
+ 	struct inode_security_struct *isec;
++>>>>>>> 20cdef8d5759 (selinux: delay inode label lookup as long as possible)
  
  	if (strcmp(name, XATTR_SELINUX_SUFFIX))
  		return -EOPNOTSUPP;
@@@ -3052,8 -3209,12 +3169,17 @@@
  	 * and lack of permission just means that we fall back to the
  	 * in-core context value, not a denial.
  	 */
++<<<<<<< HEAD
 +	error = selinux_capable(current_cred(), &init_user_ns, CAP_MAC_ADMIN,
 +				SECURITY_CAP_NOAUDIT);
++=======
+ 	error = cap_capable(current_cred(), &init_user_ns, CAP_MAC_ADMIN,
+ 			    SECURITY_CAP_NOAUDIT);
+ 	if (!error)
+ 		error = cred_has_capability(current_cred(), CAP_MAC_ADMIN,
+ 					    SECURITY_CAP_NOAUDIT);
+ 	isec = inode_security(inode);
++>>>>>>> 20cdef8d5759 (selinux: delay inode label lookup as long as possible)
  	if (!error)
  		error = security_sid_to_context_force(isec->sid, &context,
  						      &size);
@@@ -3152,6 -3314,47 +3278,50 @@@ static void selinux_file_free_security(
  	file_free_security(file);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Check whether a task has the ioctl permission and cmd
+  * operation to an inode.
+  */
+ static int ioctl_has_perm(const struct cred *cred, struct file *file,
+ 		u32 requested, u16 cmd)
+ {
+ 	struct common_audit_data ad;
+ 	struct file_security_struct *fsec = file->f_security;
+ 	struct inode *inode = file_inode(file);
+ 	struct inode_security_struct *isec;
+ 	struct lsm_ioctlop_audit ioctl;
+ 	u32 ssid = cred_sid(cred);
+ 	int rc;
+ 	u8 driver = cmd >> 8;
+ 	u8 xperm = cmd & 0xff;
+ 
+ 	ad.type = LSM_AUDIT_DATA_IOCTL_OP;
+ 	ad.u.op = &ioctl;
+ 	ad.u.op->cmd = cmd;
+ 	ad.u.op->path = file->f_path;
+ 
+ 	if (ssid != fsec->sid) {
+ 		rc = avc_has_perm(ssid, fsec->sid,
+ 				SECCLASS_FD,
+ 				FD__USE,
+ 				&ad);
+ 		if (rc)
+ 			goto out;
+ 	}
+ 
+ 	if (unlikely(IS_PRIVATE(inode)))
+ 		return 0;
+ 
+ 	isec = inode_security(inode);
+ 	rc = avc_has_extended_perms(ssid, isec->sid, isec->sclass,
+ 			requested, driver, xperm, &ad);
+ out:
+ 	return rc;
+ }
+ 
++>>>>>>> 20cdef8d5759 (selinux: delay inode label lookup as long as possible)
  static int selinux_file_ioctl(struct file *file, unsigned int cmd,
  			      unsigned long arg)
  {
@@@ -3536,6 -3736,52 +3706,55 @@@ static int selinux_kernel_module_reques
  			    SYSTEM__MODULE_REQUEST, &ad);
  }
  
++<<<<<<< HEAD
++=======
+ static int selinux_kernel_module_from_file(struct file *file)
+ {
+ 	struct common_audit_data ad;
+ 	struct inode_security_struct *isec;
+ 	struct file_security_struct *fsec;
+ 	u32 sid = current_sid();
+ 	int rc;
+ 
+ 	/* init_module */
+ 	if (file == NULL)
+ 		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
+ 					SYSTEM__MODULE_LOAD, NULL);
+ 
+ 	/* finit_module */
+ 
+ 	ad.type = LSM_AUDIT_DATA_PATH;
+ 	ad.u.path = file->f_path;
+ 
+ 	fsec = file->f_security;
+ 	if (sid != fsec->sid) {
+ 		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	isec = inode_security(file_inode(file));
+ 	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
+ 				SYSTEM__MODULE_LOAD, &ad);
+ }
+ 
+ static int selinux_kernel_read_file(struct file *file,
+ 				    enum kernel_read_file_id id)
+ {
+ 	int rc = 0;
+ 
+ 	switch (id) {
+ 	case READING_MODULE:
+ 		rc = selinux_kernel_module_from_file(file);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return rc;
+ }
+ 
++>>>>>>> 20cdef8d5759 (selinux: delay inode label lookup as long as possible)
  static int selinux_task_setpgid(struct task_struct *p, pid_t pgid)
  {
  	return current_has_perm(p, PROCESS__SETPGID);
* Unmerged path security/selinux/hooks.c
