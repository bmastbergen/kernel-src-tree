amd-xgbe: Checkpatch fixes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit 1d67d7f6e925af985345e2a93ddc6aeaec3bc354
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1d67d7f6.failed

This set of patches resolves some checks reported by the checkpatch
tool.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1d67d7f6e925af985345e2a93ddc6aeaec3bc354)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-drv.c
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index 8bd8b6363c16,e2e921768185..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@@ -489,7 -682,115 +489,119 @@@ static void xgbe_free_rx_skbuff(struct 
  		}
  	}
  
++<<<<<<< HEAD
 +	DBGPR("<--xgbe_free_rx_skbuff\n");
++=======
+ 	DBGPR("<--xgbe_free_rx_data\n");
+ }
+ 
+ static void xgbe_adjust_link(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	struct phy_device *phydev = pdata->phydev;
+ 	int new_state = 0;
+ 
+ 	if (!phydev)
+ 		return;
+ 
+ 	if (phydev->link) {
+ 		/* Flow control support */
+ 		if (pdata->pause_autoneg) {
+ 			if (phydev->pause || phydev->asym_pause) {
+ 				pdata->tx_pause = 1;
+ 				pdata->rx_pause = 1;
+ 			} else {
+ 				pdata->tx_pause = 0;
+ 				pdata->rx_pause = 0;
+ 			}
+ 		}
+ 
+ 		if (pdata->tx_pause != pdata->phy_tx_pause) {
+ 			hw_if->config_tx_flow_control(pdata);
+ 			pdata->phy_tx_pause = pdata->tx_pause;
+ 		}
+ 
+ 		if (pdata->rx_pause != pdata->phy_rx_pause) {
+ 			hw_if->config_rx_flow_control(pdata);
+ 			pdata->phy_rx_pause = pdata->rx_pause;
+ 		}
+ 
+ 		/* Speed support */
+ 		if (phydev->speed != pdata->phy_speed) {
+ 			new_state = 1;
+ 
+ 			switch (phydev->speed) {
+ 			case SPEED_10000:
+ 				hw_if->set_xgmii_speed(pdata);
+ 				break;
+ 
+ 			case SPEED_2500:
+ 				hw_if->set_gmii_2500_speed(pdata);
+ 				break;
+ 
+ 			case SPEED_1000:
+ 				hw_if->set_gmii_speed(pdata);
+ 				break;
+ 			}
+ 			pdata->phy_speed = phydev->speed;
+ 		}
+ 
+ 		if (phydev->link != pdata->phy_link) {
+ 			new_state = 1;
+ 			pdata->phy_link = 1;
+ 		}
+ 	} else if (pdata->phy_link) {
+ 		new_state = 1;
+ 		pdata->phy_link = 0;
+ 		pdata->phy_speed = SPEED_UNKNOWN;
+ 	}
+ 
+ 	if (new_state)
+ 		phy_print_status(phydev);
+ }
+ 
+ static int xgbe_phy_init(struct xgbe_prv_data *pdata)
+ {
+ 	struct net_device *netdev = pdata->netdev;
+ 	struct phy_device *phydev = pdata->phydev;
+ 	int ret;
+ 
+ 	pdata->phy_link = -1;
+ 	pdata->phy_speed = SPEED_UNKNOWN;
+ 	pdata->phy_tx_pause = pdata->tx_pause;
+ 	pdata->phy_rx_pause = pdata->rx_pause;
+ 
+ 	ret = phy_connect_direct(netdev, phydev, &xgbe_adjust_link,
+ 				 pdata->phy_mode);
+ 	if (ret) {
+ 		netdev_err(netdev, "phy_connect_direct failed\n");
+ 		return ret;
+ 	}
+ 
+ 	if (!phydev->drv || (phydev->drv->phy_id == 0)) {
+ 		netdev_err(netdev, "phy_id not valid\n");
+ 		ret = -ENODEV;
+ 		goto err_phy_connect;
+ 	}
+ 	DBGPR("  phy_connect_direct succeeded for PHY %s, link=%d\n",
+ 	      dev_name(&phydev->dev), phydev->link);
+ 
+ 	return 0;
+ 
+ err_phy_connect:
+ 	phy_disconnect(phydev);
+ 
+ 	return ret;
+ }
+ 
+ static void xgbe_phy_exit(struct xgbe_prv_data *pdata)
+ {
+ 	if (!pdata->phydev)
+ 		return;
+ 
+ 	phy_disconnect(pdata->phydev);
++>>>>>>> 1d67d7f6e925 (amd-xgbe: Checkpatch fixes)
  }
  
  int xgbe_powerdown(struct net_device *netdev, unsigned int caller)
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c b/drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c
index a3c11355a34d..12273a9b8175 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c
@@ -329,7 +329,7 @@ void xgbe_debugfs_init(struct xgbe_prv_data *pdata)
 
 	buf = kasprintf(GFP_KERNEL, "amd-xgbe-%s", pdata->netdev->name);
 	pdata->xgbe_debugfs = debugfs_create_dir(buf, NULL);
-	if (pdata->xgbe_debugfs == NULL) {
+	if (!pdata->xgbe_debugfs) {
 		netdev_err(pdata->netdev, "debugfs_create_dir failed\n");
 		return;
 	}
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c b/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
index eecd360430a4..53da4f249695 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
@@ -295,7 +295,7 @@ int xgbe_mdio_register(struct xgbe_prv_data *pdata)
 
 	/* Register with the MDIO bus */
 	mii = mdiobus_alloc();
-	if (mii == NULL) {
+	if (!mii) {
 		dev_err(pdata->dev, "mdiobus_alloc failed\n");
 		ret = -ENOMEM;
 		goto err_node_get;
