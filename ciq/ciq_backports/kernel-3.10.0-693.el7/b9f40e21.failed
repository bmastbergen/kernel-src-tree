net-timestamp: move timestamp flags out of sk_flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] timestamp: move timestamp flags out of sk_flags (Hangbin Liu) [1389283]
Rebuild_FUZZ: 95.92%
commit-author Willem de Bruijn <willemb@google.com>
commit b9f40e21ef4298650ab33e35740fa85bd57706d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b9f40e21.failed

sk_flags is reaching its limit. New timestamping options will not fit.
Move all of them into a new field sk->sk_tsflags.

Added benefit is that this removes boilerplate code to convert between
SOF_TIMESTAMPING_.. and SOCK_TIMESTAMPING_.. in getsockopt/setsockopt.

SOCK_TIMESTAMPING_RX_SOFTWARE is also used to toggle the receive
timestamp logic (netstamp_needed). That can be simplified and this
last key removed, but will leave that for a separate patch.

	Signed-off-by: Willem de Bruijn <willemb@google.com>

----

The u16 in sock can be moved into a 16-bit hole below sk_gso_max_segs,
though that scatters tstamp fields throughout the struct.
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b9f40e21ef4298650ab33e35740fa85bd57706d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/sock.h
#	net/core/sock.c
#	net/socket.c
diff --cc include/net/sock.h
index 66e87003d1ca,a21129716aae..000000000000
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@@ -71,10 -67,8 +71,11 @@@
  #include <linux/atomic.h>
  #include <net/dst.h>
  #include <net/checksum.h>
+ #include <linux/net_tstamp.h>
  
 +#include <linux/rh_kabi.h>
 +#include <net/tcp_states.h>
 +
  struct cgroup;
  struct cgroup_subsys;
  #ifdef CONFIG_NET
@@@ -720,13 -704,7 +723,13 @@@ enum sock_flags 
  	SOCK_LOCALROUTE, /* route locally only, %SO_DONTROUTE setting */
  	SOCK_QUEUE_SHRUNK, /* write queue has been shrunk recently */
  	SOCK_MEMALLOC, /* VM depends on this socket for swapping */
- 	SOCK_TIMESTAMPING_TX_HARDWARE,  /* %SOF_TIMESTAMPING_TX_HARDWARE */
- 	SOCK_TIMESTAMPING_TX_SOFTWARE,  /* %SOF_TIMESTAMPING_TX_SOFTWARE */
- 	SOCK_TIMESTAMPING_RX_HARDWARE,  /* %SOF_TIMESTAMPING_RX_HARDWARE */
  	SOCK_TIMESTAMPING_RX_SOFTWARE,  /* %SOF_TIMESTAMPING_RX_SOFTWARE */
++<<<<<<< HEAD
 +	SOCK_TIMESTAMPING_SOFTWARE,     /* %SOF_TIMESTAMPING_SOFTWARE */
 +	SOCK_TIMESTAMPING_RAW_HARDWARE, /* %SOF_TIMESTAMPING_RAW_HARDWARE */
 +	SOCK_TIMESTAMPING_SYS_HARDWARE, /* %SOF_TIMESTAMPING_SYS_HARDWARE */
++=======
++>>>>>>> b9f40e21ef42 (net-timestamp: move timestamp flags out of sk_flags)
  	SOCK_FASYNC, /* fasync() active */
  	SOCK_RXQ_OVFL,
  	SOCK_ZEROCOPY, /* buffers from userspace */
@@@ -2240,21 -2158,17 +2243,30 @@@ sock_recv_timestamp(struct msghdr *msg
  
  	/*
  	 * generate control messages if
- 	 * - receive time stamping in software requested (SOCK_RCVTSTAMP
- 	 *   or SOCK_TIMESTAMPING_RX_SOFTWARE)
+ 	 * - receive time stamping in software requested
  	 * - software time stamp available and wanted
- 	 *   (SOCK_TIMESTAMPING_SOFTWARE)
  	 * - hardware time stamps available and wanted
++<<<<<<< HEAD
 +	 *   (SOCK_TIMESTAMPING_SYS_HARDWARE or
 +	 *   SOCK_TIMESTAMPING_RAW_HARDWARE)
 +	 */
 +	if (sock_flag(sk, SOCK_RCVTSTAMP) ||
 +	    sock_flag(sk, SOCK_TIMESTAMPING_RX_SOFTWARE) ||
 +	    (kt.tv64 && sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) ||
 +	    (hwtstamps->hwtstamp.tv64 &&
 +	     sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE)) ||
 +	    (hwtstamps->syststamp.tv64 &&
 +	     sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE)))
++=======
+ 	 */
+ 	if (sock_flag(sk, SOCK_RCVTSTAMP) ||
+ 	    (sk->sk_tsflags & SOF_TIMESTAMPING_RX_SOFTWARE) ||
+ 	    (kt.tv64 &&
+ 	     (sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ||
+ 	      skb_shinfo(skb)->tx_flags & SKBTX_ANY_SW_TSTAMP)) ||
+ 	    (hwtstamps->hwtstamp.tv64 &&
+ 	     (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE)))
++>>>>>>> b9f40e21ef42 (net-timestamp: move timestamp flags out of sk_flags)
  		__sock_recv_timestamp(msg, sk, skb);
  	else
  		sk->sk_stamp = kt;
@@@ -2270,12 -2184,11 +2282,18 @@@ static inline void sock_recv_ts_and_dro
  					  struct sk_buff *skb)
  {
  #define FLAGS_TS_OR_DROPS ((1UL << SOCK_RXQ_OVFL)			| \
++<<<<<<< HEAD
 +			   (1UL << SOCK_RCVTSTAMP)			| \
 +			   (1UL << SOCK_TIMESTAMPING_SOFTWARE)		| \
 +			   (1UL << SOCK_TIMESTAMPING_RAW_HARDWARE)	| \
 +			   (1UL << SOCK_TIMESTAMPING_SYS_HARDWARE))
++=======
+ 			   (1UL << SOCK_RCVTSTAMP))
+ #define TSFLAGS_ANY	  (SOF_TIMESTAMPING_SOFTWARE			| \
+ 			   SOF_TIMESTAMPING_RAW_HARDWARE)
++>>>>>>> b9f40e21ef42 (net-timestamp: move timestamp flags out of sk_flags)
  
- 	if (sk->sk_flags & FLAGS_TS_OR_DROPS)
+ 	if (sk->sk_flags & FLAGS_TS_OR_DROPS || sk->sk_tsflags & TSFLAGS_ANY)
  		__sock_recv_ts_and_drops(msg, sk, skb);
  	else
  		sk->sk_stamp = skb->tstamp;
@@@ -2285,10 -2198,8 +2303,8 @@@
   * sock_tx_timestamp - checks whether the outgoing packet is to be time stamped
   * @sk:		socket sending this packet
   * @tx_flags:	filled with instructions for time stamping
-  *
-  * Currently only depends on SOCK_TIMESTAMPING* flags.
   */
 -void sock_tx_timestamp(struct sock *sk, __u8 *tx_flags);
 +extern void sock_tx_timestamp(struct sock *sk, __u8 *tx_flags);
  
  /**
   * sk_eat_skb - Release a skb if it is no longer needed
diff --cc net/core/sock.c
index 960b698f3aa7,47c9377e14b9..000000000000
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@@ -845,12 -855,6 +840,15 @@@ set_rcvbuf
  		else
  			sock_disable_timestamp(sk,
  					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
++<<<<<<< HEAD
 +		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
 +				  val & SOF_TIMESTAMPING_SOFTWARE);
 +		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
 +				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
 +		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
 +				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
++=======
++>>>>>>> b9f40e21ef42 (net-timestamp: move timestamp flags out of sk_flags)
  		break;
  
  	case SO_RCVLOWAT:
@@@ -1077,21 -1080,7 +1075,25 @@@ int sock_getsockopt(struct socket *sock
  		break;
  
  	case SO_TIMESTAMPING:
++<<<<<<< HEAD
 +		v.val = 0;
 +		if (sock_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE))
 +			v.val |= SOF_TIMESTAMPING_TX_HARDWARE;
 +		if (sock_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE))
 +			v.val |= SOF_TIMESTAMPING_TX_SOFTWARE;
 +		if (sock_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE))
 +			v.val |= SOF_TIMESTAMPING_RX_HARDWARE;
 +		if (sock_flag(sk, SOCK_TIMESTAMPING_RX_SOFTWARE))
 +			v.val |= SOF_TIMESTAMPING_RX_SOFTWARE;
 +		if (sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE))
 +			v.val |= SOF_TIMESTAMPING_SOFTWARE;
 +		if (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE))
 +			v.val |= SOF_TIMESTAMPING_SYS_HARDWARE;
 +		if (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE))
 +			v.val |= SOF_TIMESTAMPING_RAW_HARDWARE;
++=======
+ 		v.val = sk->sk_tsflags;
++>>>>>>> b9f40e21ef42 (net-timestamp: move timestamp flags out of sk_flags)
  		break;
  
  	case SO_RCVTIMEO:
diff --cc net/socket.c
index 29a2111ee79f,255d9b802723..000000000000
--- a/net/socket.c
+++ b/net/socket.c
@@@ -698,22 -722,18 +698,33 @@@ void __sock_recv_timestamp(struct msghd
  		}
  	}
  
++<<<<<<< HEAD
 +
 +	memset(ts, 0, sizeof(ts));
 +	if (sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE) &&
 +	    ktime_to_timespec_cond(skb->tstamp, ts + 0))
++=======
+ 	memset(&tss, 0, sizeof(tss));
+ 	if ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ||
+ 	     skb_shinfo(skb)->tx_flags & SKBTX_ANY_SW_TSTAMP) &&
+ 	    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))
+ 		empty = 0;
+ 	if (shhwtstamps &&
+ 	    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&
+ 	    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))
++>>>>>>> b9f40e21ef42 (net-timestamp: move timestamp flags out of sk_flags)
  		empty = 0;
 +	if (shhwtstamps) {
 +		if (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE) &&
 +		    ktime_to_timespec_cond(shhwtstamps->syststamp, ts + 1))
 +			empty = 0;
 +		if (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE) &&
 +		    ktime_to_timespec_cond(shhwtstamps->hwtstamp, ts + 2))
 +			empty = 0;
 +	}
  	if (!empty)
  		put_cmsg(msg, SOL_SOCKET,
 -			 SCM_TIMESTAMPING, sizeof(tss), &tss);
 +			 SCM_TIMESTAMPING, sizeof(ts), &ts);
  }
  EXPORT_SYMBOL_GPL(__sock_recv_timestamp);
  
* Unmerged path include/net/sock.h
* Unmerged path net/core/sock.c
* Unmerged path net/socket.c
