x86/perf/intel/uncore: Make the Intel uncore PMU driver modular

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] perf/intel/uncore: Make the Intel uncore PMU driver modular (Jiri Olsa) [1405101]
Rebuild_FUZZ: 96.72%
commit-author Kan Liang <kan.liang@intel.com>
commit e633c65a1d5859da170a83d537d9762c07d12213
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e633c65a.failed

By default, the uncore driver will be built into the kernel. If it is
configured as a module, the supported CPU model can be auto loaded.

This patch also cleans up the code of uncore_cpu_init() and
uncore_pci_init().

Based-on-a-patch-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Kan Liang <kan.liang@intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
Link: http://lkml.kernel.org/r/1458462817-2475-1-git-send-email-kan.liang@intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit e633c65a1d5859da170a83d537d9762c07d12213)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/Kconfig
#	arch/x86/events/Makefile
#	arch/x86/events/intel/uncore.c
diff --cc arch/x86/Kconfig
index d30a5322b64f,496218b8236b..000000000000
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@@ -969,15 -1038,75 +969,23 @@@ config X86_THERMAL_VECTO
  	def_bool y
  	depends on X86_MCE_INTEL
  
++<<<<<<< HEAD
 +config VM86
 +	bool "Enable VM86 support" if EXPERT
 +	default y
++=======
+ source "arch/x86/Kconfig.perf"
+ 
+ config X86_LEGACY_VM86
+ 	bool "Legacy VM86 support"
+ 	default n
++>>>>>>> e633c65a1d58 (x86/perf/intel/uncore: Make the Intel uncore PMU driver modular)
  	depends on X86_32
  	---help---
 -	  This option allows user programs to put the CPU into V8086
 -	  mode, which is an 80286-era approximation of 16-bit real mode.
 -
 -	  Some very old versions of X and/or vbetool require this option
 -	  for user mode setting.  Similarly, DOSEMU will use it if
 -	  available to accelerate real mode DOS programs.  However, any
 -	  recent version of DOSEMU, X, or vbetool should be fully
 -	  functional even without kernel VM86 support, as they will all
 -	  fall back to software emulation. Nevertheless, if you are using
 -	  a 16-bit DOS program where 16-bit performance matters, vm86
 -	  mode might be faster than emulation and you might want to
 -	  enable this option.
 -
 -	  Note that any app that works on a 64-bit kernel is unlikely to
 -	  need this option, as 64-bit kernels don't, and can't, support
 -	  V8086 mode. This option is also unrelated to 16-bit protected
 -	  mode and is not needed to run most 16-bit programs under Wine.
 -
 -	  Enabling this option increases the complexity of the kernel
 -	  and slows down exception handling a tiny bit.
 -
 -	  If unsure, say N here.
 -
 -config VM86
 -       bool
 -       default X86_LEGACY_VM86
 -
 -config X86_16BIT
 -	bool "Enable support for 16-bit segments" if EXPERT
 -	default y
 -	depends on MODIFY_LDT_SYSCALL
 -	---help---
 -	  This option is required by programs like Wine to run 16-bit
 -	  protected mode legacy code on x86 processors.  Disabling
 -	  this option saves about 300 bytes on i386, or around 6K text
 -	  plus 16K runtime memory on x86-64,
 -
 -config X86_ESPFIX32
 -	def_bool y
 -	depends on X86_16BIT && X86_32
 -
 -config X86_ESPFIX64
 -	def_bool y
 -	depends on X86_16BIT && X86_64
 -
 -config X86_VSYSCALL_EMULATION
 -       bool "Enable vsyscall emulation" if EXPERT
 -       default y
 -       depends on X86_64
 -       ---help---
 -	 This enables emulation of the legacy vsyscall page.  Disabling
 -	 it is roughly equivalent to booting with vsyscall=none, except
 -	 that it will also disable the helpful warning if a program
 -	 tries to use a vsyscall.  With this option set to N, offending
 -	 programs will just segfault, citing addresses of the form
 -	 0xffffffffff600?00.
 -
 -	 This option is required by many programs built before 2013, and
 -	 care should be used even with newer programs if set to N.
 -
 -	 Disabling this option saves about 7K of kernel size and
 -	 possibly 4K of additional runtime pagetable memory.
 +	  This option is required by programs like DOSEMU to run 16-bit legacy
 +	  code on X86 processors. It also may be needed by software like
 +	  XFree86 to initialize some video cards via BIOS. Disabling this
 +	  option saves about 6k.
  
  config TOSHIBA
  	tristate "Toshiba Laptop support"
diff --cc arch/x86/events/Makefile
index 73dca4ff0066,1d392c39fe56..000000000000
--- a/arch/x86/events/Makefile
+++ b/arch/x86/events/Makefile
@@@ -1,10 -1,11 +1,21 @@@
  obj-y			+= core.o
  
  obj-$(CONFIG_CPU_SUP_AMD)               += amd/core.o amd/uncore.o
++<<<<<<< HEAD
 +obj-$(CONFIG_X86_LOCAL_APIC)            += amd/ibs.o
 +obj-$(CONFIG_CPU_SUP_INTEL)		+= intel/core.o intel/bts.o intel/cqm.o
 +obj-$(CONFIG_CPU_SUP_INTEL)		+= intel/ds.o intel/knc.o
 +obj-$(CONFIG_CPU_SUP_INTEL)		+= intel/lbr.o intel/p4.o intel/p6.o intel/pt.o
 +obj-$(CONFIG_CPU_SUP_INTEL)		+= intel/rapl.o
 +obj-$(CONFIG_CPU_SUP_INTEL)		+= intel/uncore.o intel/uncore_nhmex.o
 +obj-$(CONFIG_CPU_SUP_INTEL)		+= intel/uncore_snb.o intel/uncore_snbep.o
++=======
+ obj-$(CONFIG_PERF_EVENTS_AMD_POWER)	+= amd/power.o
+ obj-$(CONFIG_X86_LOCAL_APIC)            += amd/ibs.o msr.o
+ ifdef CONFIG_AMD_IOMMU
+ obj-$(CONFIG_CPU_SUP_AMD)               += amd/iommu.o
+ endif
+ 
+ obj-$(CONFIG_CPU_SUP_INTEL)		+= msr.o
+ obj-$(CONFIG_CPU_SUP_INTEL)		+= intel/
++>>>>>>> e633c65a1d58 (x86/perf/intel/uncore: Make the Intel uncore PMU driver modular)
diff --cc arch/x86/events/intel/uncore.c
index 53ff22fa4cd0,17734a6ef474..000000000000
--- a/arch/x86/events/intel/uncore.c
+++ b/arch/x86/events/intel/uncore.c
@@@ -1,4 -1,4 +1,8 @@@
++<<<<<<< HEAD
 +#include <linux/crash_dump.h>
++=======
+ #include <asm/cpu_device_id.h>
++>>>>>>> e633c65a1d58 (x86/perf/intel/uncore: Make the Intel uncore PMU driver modular)
  #include "uncore.h"
  
  static struct intel_uncore_type *empty_uncore[] = { NULL, };
@@@ -1408,13 -1403,19 +1428,22 @@@ static int __init intel_uncore_init(voi
  	if (cpu_has_hypervisor)
  		return -ENODEV;
  
 +	if (is_kdump_kernel())
 +		return -ENODEV;
 +
  	max_packages = topology_max_packages();
  
- 	pret = uncore_pci_init();
- 	cret = uncore_cpu_init();
+ 	uncore_init = (struct intel_uncore_init_fun *)id->driver_data;
+ 	if (uncore_init->pci_init) {
+ 		pret = uncore_init->pci_init();
+ 		if (!pret)
+ 			pret = uncore_pci_init();
+ 	}
+ 
+ 	if (uncore_init->cpu_init) {
+ 		uncore_init->cpu_init();
+ 		cret = uncore_cpu_init();
+ 	}
  
  	if (cret && pret)
  		return -ENODEV;
* Unmerged path arch/x86/Kconfig
diff --git a/arch/x86/Kconfig.perf b/arch/x86/Kconfig.perf
new file mode 100644
index 000000000000..90b7f5878c96
--- /dev/null
+++ b/arch/x86/Kconfig.perf
@@ -0,0 +1,11 @@
+menu "Performance monitoring"
+
+config PERF_EVENTS_INTEL_UNCORE
+	tristate "Intel uncore performance events"
+	depends on PERF_EVENTS && CPU_SUP_INTEL && PCI
+	default y
+	---help---
+	Include support for Intel uncore performance events. These are
+	available on NehalemEX and more modern processors.
+
+endmenu
* Unmerged path arch/x86/events/Makefile
diff --git a/arch/x86/events/intel/Makefile b/arch/x86/events/intel/Makefile
new file mode 100644
index 000000000000..a6c744871a73
--- /dev/null
+++ b/arch/x86/events/intel/Makefile
@@ -0,0 +1,6 @@
+obj-$(CONFIG_CPU_SUP_INTEL)		+= core.o bts.o cqm.o
+obj-$(CONFIG_CPU_SUP_INTEL)		+= cstate.o ds.o knc.o
+obj-$(CONFIG_CPU_SUP_INTEL)		+= lbr.o p4.o p6.o pt.o
+obj-$(CONFIG_CPU_SUP_INTEL)		+= rapl.o
+obj-$(CONFIG_PERF_EVENTS_INTEL_UNCORE)	+= intel-uncore.o
+intel-uncore-objs			:= uncore.o uncore_nhmex.o uncore_snb.o uncore_snbep.o
* Unmerged path arch/x86/events/intel/uncore.c
