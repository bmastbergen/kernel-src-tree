lib/kasprintf.c: introduce kvasprintf_const

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [lib] kasprintf.c: introduce kvasprintf_const (David Arcari) [1415327]
Rebuild_FUZZ: 95.12%
commit-author Rasmus Villemoes <linux@rasmusvillemoes.dk>
commit 0a9df786a6ae2f898114bdd242b64920dedf53bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0a9df786.failed

This adds kvasprintf_const which tries to use kstrdup_const if possible:
If the format string contains no % characters, or if the format string is
exactly "%s", we delegate to kstrdup_const.  Otherwise, we fall back to
kvasprintf.

Just as for kstrdup_const, the main motivation is to save memory by
reusing .rodata when possible.

The return value should be freed by kfree_const, just like for
kstrdup_const.

There is deliberately no kasprintf_const: In the vast majority of cases,
the format string argument is a literal, so one can determine statically
whether one could instead use kstrdup_const directly (which would also
require one to change all corresponding kfree calls to kfree_const).

	Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
	Cc: Greg KH <greg@kroah.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0a9df786a6ae2f898114bdd242b64920dedf53bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kernel.h
diff --cc include/linux/kernel.h
index 4ee809347a72,2c13f747ac2e..000000000000
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@@ -413,7 -411,10 +413,14 @@@ extern __printf(3, 0
  int vscnprintf(char *buf, size_t size, const char *fmt, va_list args);
  extern __printf(2, 3)
  char *kasprintf(gfp_t gfp, const char *fmt, ...);
++<<<<<<< HEAD
 +extern char *kvasprintf(gfp_t gfp, const char *fmt, va_list args);
++=======
+ extern __printf(2, 0)
+ char *kvasprintf(gfp_t gfp, const char *fmt, va_list args);
+ extern __printf(2, 0)
+ const char *kvasprintf_const(gfp_t gfp, const char *fmt, va_list args);
++>>>>>>> 0a9df786a6ae (lib/kasprintf.c: introduce kvasprintf_const)
  
  extern __scanf(2, 3)
  int sscanf(const char *, const char *, ...);
* Unmerged path include/linux/kernel.h
diff --git a/lib/kasprintf.c b/lib/kasprintf.c
index 32f12150fc4f..f194e6e593e1 100644
--- a/lib/kasprintf.c
+++ b/lib/kasprintf.c
@@ -31,6 +31,22 @@ char *kvasprintf(gfp_t gfp, const char *fmt, va_list ap)
 }
 EXPORT_SYMBOL(kvasprintf);
 
+/*
+ * If fmt contains no % (or is exactly %s), use kstrdup_const. If fmt
+ * (or the sole vararg) points to rodata, we will then save a memory
+ * allocation and string copy. In any case, the return value should be
+ * freed using kfree_const().
+ */
+const char *kvasprintf_const(gfp_t gfp, const char *fmt, va_list ap)
+{
+	if (!strchr(fmt, '%'))
+		return kstrdup_const(fmt, gfp);
+	if (!strcmp(fmt, "%s"))
+		return kstrdup_const(va_arg(ap, const char*), gfp);
+	return kvasprintf(gfp, fmt, ap);
+}
+EXPORT_SYMBOL(kvasprintf_const);
+
 char *kasprintf(gfp_t gfp, const char *fmt, ...)
 {
 	va_list ap;
