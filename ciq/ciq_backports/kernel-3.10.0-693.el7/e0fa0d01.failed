pNFS: Always set NFS_LAYOUT_RETURN_REQUESTED with lo->plh_return_iomode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit e0fa0d0189f6be61343dbff1f71bef20125576e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e0fa0d01.failed

When setting the layout return mode, we must always also set the
NFS_LAYOUT_RETURN_REQUESTED flag to ensure that we send a layoutreturn.
Otherwise pnfs_error_mark_layout_for_return() could set the mode, but
fail to send the layoutreturn because another is already in flight.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit e0fa0d0189f6be61343dbff1f71bef20125576e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pnfs.c
diff --cc fs/nfs/pnfs.c
index 1e9ea46d9552,5064f23ca8cc..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -1728,12 -1730,34 +1728,37 @@@ out_forget_reply
  	goto out;
  }
  
++<<<<<<< HEAD
 +void
++=======
+ static void
+ pnfs_set_plh_return_iomode(struct pnfs_layout_hdr *lo, enum pnfs_iomode iomode)
+ {
+ 	if (lo->plh_return_iomode == iomode)
+ 		return;
+ 	if (lo->plh_return_iomode != 0)
+ 		iomode = IOMODE_ANY;
+ 	lo->plh_return_iomode = iomode;
+ 	set_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags);
+ }
+ 
+ /**
+  * pnfs_mark_matching_lsegs_return - Free or return matching layout segments
+  * @lo: pointer to layout header
+  * @tmp_list: list header to be used with pnfs_free_lseg_list()
+  * @return_range: describe layout segment ranges to be returned
+  *
+  * This function is mainly intended for use by layoutrecall. It attempts
+  * to free the layout segment immediately, or else to mark it for return
+  * as soon as its reference count drops to zero.
+  */
+ int
++>>>>>>> e0fa0d0189f6 (pNFS: Always set NFS_LAYOUT_RETURN_REQUESTED with lo->plh_return_iomode)
  pnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,
  				struct list_head *tmp_list,
 -				const struct pnfs_layout_range *return_range)
 +				struct pnfs_layout_range *return_range)
  {
  	struct pnfs_layout_segment *lseg, *next;
 -	int remaining = 0;
  
  	dprintk("%s:Begin lo %p\n", __func__, lo);
  
@@@ -1749,11 -1773,13 +1774,15 @@@
  				lseg, lseg->pls_range.iomode,
  				lseg->pls_range.offset,
  				lseg->pls_range.length);
 -			if (mark_lseg_invalid(lseg, tmp_list))
 -				continue;
 -			remaining++;
  			set_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags);
++<<<<<<< HEAD
 +			mark_lseg_invalid(lseg, tmp_list);
 +			set_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,
 +					&lo->plh_flags);
++=======
+ 			pnfs_set_plh_return_iomode(lo, return_range->iomode);
++>>>>>>> e0fa0d0189f6 (pNFS: Always set NFS_LAYOUT_RETURN_REQUESTED with lo->plh_return_iomode)
  		}
 -	return remaining;
  }
  
  void pnfs_error_mark_layout_for_return(struct inode *inode,
* Unmerged path fs/nfs/pnfs.c
