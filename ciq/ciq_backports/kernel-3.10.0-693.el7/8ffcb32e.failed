VFS: Make delayed_free() call free_vfsmnt()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Howells <dhowells@redhat.com>
commit 8ffcb32e05239f0e53abfb0a1bc4eee4855b7fd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8ffcb32e.failed

Make delayed_free() call free_vfsmnt() so that we don't have two functions
doing the same job.  This requires the calls to mnt_free_id() in free_vfsmnt()
to be moved into the callers of that function.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 8ffcb32e05239f0e53abfb0a1bc4eee4855b7fd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index a82db7875df0,182bc41cd887..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -547,9 -574,36 +546,39 @@@ static void free_vfsmnt(struct mount *m
  	kmem_cache_free(mnt_cache, mnt);
  }
  
++<<<<<<< HEAD
++=======
+ static void delayed_free_vfsmnt(struct rcu_head *head)
+ {
+ 	free_vfsmnt(container_of(head, struct mount, mnt_rcu));
+ }
+ 
+ /* call under rcu_read_lock */
+ bool legitimize_mnt(struct vfsmount *bastard, unsigned seq)
+ {
+ 	struct mount *mnt;
+ 	if (read_seqretry(&mount_lock, seq))
+ 		return false;
+ 	if (bastard == NULL)
+ 		return true;
+ 	mnt = real_mount(bastard);
+ 	mnt_add_count(mnt, 1);
+ 	if (likely(!read_seqretry(&mount_lock, seq)))
+ 		return true;
+ 	if (bastard->mnt_flags & MNT_SYNC_UMOUNT) {
+ 		mnt_add_count(mnt, -1);
+ 		return false;
+ 	}
+ 	rcu_read_unlock();
+ 	mntput(bastard);
+ 	rcu_read_lock();
+ 	return false;
+ }
+ 
++>>>>>>> 8ffcb32e0523 (VFS: Make delayed_free() call free_vfsmnt())
  /*
   * find the first mount at @dentry on vfsmount @mnt.
 - * call under rcu_read_lock()
 + * vfsmount_lock must be held for read or write.
   */
  struct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)
  {
@@@ -924,7 -984,8 +955,12 @@@ put_again
  	fsnotify_vfsmount_delete(&mnt->mnt);
  	dput(mnt->mnt.mnt_root);
  	deactivate_super(mnt->mnt.mnt_sb);
++<<<<<<< HEAD
 +	free_vfsmnt(mnt);
++=======
+ 	mnt_free_id(mnt);
+ 	call_rcu(&mnt->mnt_rcu, delayed_free_vfsmnt);
++>>>>>>> 8ffcb32e0523 (VFS: Make delayed_free() call free_vfsmnt())
  }
  
  void mntput(struct vfsmount *mnt)
* Unmerged path fs/namespace.c
