btrfs: synchronize incompat feature bits with sysfs files

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Sterba <dsterba@suse.com>
commit 14e46e04958df740c6c6a94849f176159a333f13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/14e46e04.failed

The files under /sys/fs/UUID/features get out of sync with the actual
incompat bits set for the filesystem if they change after mount (eg. the
LZO compression).

Synchronize the feature bits with the sysfs files representing them
right after we set/clear them.

	Signed-off-by: David Sterba <dsterba@suse.com>
(cherry picked from commit 14e46e04958df740c6c6a94849f176159a333f13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/free-space-tree.c
#	fs/btrfs/super.c
diff --cc fs/btrfs/free-space-tree.c
index cbe36dd0d97b,94e887f5ec4e..000000000000
--- a/fs/btrfs/free-space-tree.c
+++ b/fs/btrfs/free-space-tree.c
@@@ -1164,6 -1170,10 +1165,13 @@@ int btrfs_create_free_space_tree(struc
  	}
  
  	btrfs_set_fs_compat_ro(fs_info, FREE_SPACE_TREE);
++<<<<<<< HEAD
++=======
+ 	btrfs_sysfs_feature_update(fs_info,
+ 		BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE, FEAT_COMPAT_RO);
+ 
+ 	fs_info->creating_free_space_tree = 0;
++>>>>>>> 14e46e04958d (btrfs: synchronize incompat feature bits with sysfs files)
  
  	ret = btrfs_commit_transaction(trans, tree_root);
  	if (ret)
diff --cc fs/btrfs/super.c
index a840b471f796,5a1bab11984d..000000000000
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@@ -481,7 -478,9 +482,13 @@@ int btrfs_parse_options(struct btrfs_ro
  				btrfs_clear_opt(info->mount_opt, NODATACOW);
  				btrfs_clear_opt(info->mount_opt, NODATASUM);
  				btrfs_set_fs_incompat(info, COMPRESS_LZO);
++<<<<<<< HEAD
 +				no_compress = 0;
++=======
+ 				btrfs_sysfs_feature_update(root->fs_info,
+ 					BTRFS_FEATURE_INCOMPAT_COMPRESS_LZO,
+ 					FEAT_INCOMPAT);
++>>>>>>> 14e46e04958d (btrfs: synchronize incompat feature bits with sysfs files)
  			} else if (strncmp(args[0].from, "no", 2) == 0) {
  				compress_type = "no";
  				btrfs_clear_opt(info->mount_opt, COMPRESS);
* Unmerged path fs/btrfs/free-space-tree.c
diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c
index 706646587ce4..90d8b988dfbb 100644
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -1457,6 +1457,8 @@ int btrfs_defrag_file(struct inode *inode, struct file *file,
 
 	if (range->compress_type == BTRFS_COMPRESS_LZO) {
 		btrfs_set_fs_incompat(root->fs_info, COMPRESS_LZO);
+		btrfs_sysfs_feature_update(root->fs_info,
+			BTRFS_FEATURE_INCOMPAT_COMPRESS_LZO, FEAT_INCOMPAT);
 	}
 
 	ret = defrag_count;
@@ -4145,6 +4147,8 @@ static long btrfs_ioctl_default_subvol(struct file *file, void __user *argp)
 	btrfs_free_path(path);
 
 	btrfs_set_fs_incompat(root->fs_info, DEFAULT_SUBVOL);
+	btrfs_sysfs_feature_update(root->fs_info,
+		BTRFS_FEATURE_INCOMPAT_DEFAULT_SUBVOL, FEAT_INCOMPAT);
 	btrfs_end_transaction(trans, root);
 out:
 	mnt_drop_write_file(file);
* Unmerged path fs/btrfs/super.c
diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c
index 67269fd66a89..a97e903c1115 100644
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -4470,6 +4470,8 @@ static void check_raid56_incompat_flag(struct btrfs_fs_info *info, u64 type)
 		return;
 
 	btrfs_set_fs_incompat(info, RAID56);
+	btrfs_sysfs_feature_update(info, BTRFS_FEATURE_INCOMPAT_RAID56,
+		FEAT_INCOMPAT);
 }
 
 #define BTRFS_MAX_DEVS(r) ((BTRFS_LEAF_DATA_SIZE(r)		\
