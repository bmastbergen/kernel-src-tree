sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tejun Heo <tj@kernel.org>
commit 879f40d193bb3c6c13930e88e3e9d5d7baf84d19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/879f40d1.failed

Introduce kernfs removal interfaces - kernfs_remove() and
kernfs_remove_by_name[_ns]().

These are just renames of sysfs_remove() and sysfs_hash_and_remove().
No functional changes.

v2: Dummy kernfs_remove_by_name_ns() for !CONFIG_SYSFS updated to
    return -ENOSYS instead of 0.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 879f40d193bb3c6c13930e88e3e9d5d7baf84d19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/dir.c
#	fs/sysfs/file.c
#	fs/sysfs/group.c
#	fs/sysfs/symlink.c
#	fs/sysfs/sysfs.h
diff --cc fs/sysfs/dir.c
index 3f68344137e5,edbde4e6e5e0..000000000000
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@@ -812,41 -774,128 +812,104 @@@ const struct inode_operations sysfs_dir
  	.setxattr	= sysfs_setxattr,
  };
  
 -static struct sysfs_dirent *sysfs_leftmost_descendant(struct sysfs_dirent *pos)
 +static void remove_dir(struct sysfs_dirent *sd)
  {
 -	struct sysfs_dirent *last;
 -
 -	while (true) {
 -		struct rb_node *rbn;
 -
 -		last = pos;
 -
 -		if (sysfs_type(pos) != SYSFS_DIR)
 -			break;
 -
 -		rbn = rb_first(&pos->s_dir.children);
 -		if (!rbn)
 -			break;
 -
 -		pos = to_sysfs_dirent(rbn);
 -	}
 +	struct sysfs_addrm_cxt acxt;
  
 -	return last;
 +	sysfs_addrm_start(&acxt, sd->s_parent);
 +	sysfs_remove_one(&acxt, sd);
 +	sysfs_addrm_finish(&acxt);
  }
  
 -/**
 - * sysfs_next_descendant_post - find the next descendant for post-order walk
 - * @pos: the current position (%NULL to initiate traversal)
 - * @root: sysfs_dirent whose descendants to walk
 - *
 - * Find the next descendant to visit for post-order traversal of @root's
 - * descendants.  @root is included in the iteration and the last node to be
 - * visited.
 - */
 -static struct sysfs_dirent *sysfs_next_descendant_post(struct sysfs_dirent *pos,
 -						       struct sysfs_dirent *root)
 +void sysfs_remove_subdir(struct sysfs_dirent *sd)
  {
 -	struct rb_node *rbn;
 -
 -	lockdep_assert_held(&sysfs_mutex);
 -
 -	/* if first iteration, visit leftmost descendant which may be root */
 -	if (!pos)
 -		return sysfs_leftmost_descendant(root);
 -
 -	/* if we visited @root, we're done */
 -	if (pos == root)
 -		return NULL;
 -
 -	/* if there's an unvisited sibling, visit its leftmost descendant */
 -	rbn = rb_next(&pos->s_rb);
 -	if (rbn)
 -		return sysfs_leftmost_descendant(to_sysfs_dirent(rbn));
 -
 -	/* no sibling left, visit parent */
 -	return pos->s_parent;
 +	remove_dir(sd);
  }
  
++<<<<<<< HEAD
++=======
+ static void __kernfs_remove(struct sysfs_addrm_cxt *acxt,
+ 			    struct sysfs_dirent *sd)
+ {
+ 	struct sysfs_dirent *pos, *next;
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  
 -	if (!sd)
 +static void __sysfs_remove_dir(struct sysfs_dirent *dir_sd)
 +{
 +	struct sysfs_addrm_cxt acxt;
 +	struct rb_node *pos;
 +
 +	if (!dir_sd)
  		return;
  
++<<<<<<< HEAD
 +	pr_debug("sysfs %s: removing dir\n", dir_sd->s_name);
 +	sysfs_addrm_start(&acxt, dir_sd);
 +	pos = rb_first(&dir_sd->s_dir.children);
 +	while (pos) {
 +		struct sysfs_dirent *sd = to_sysfs_dirent(pos);
 +		pos = rb_next(pos);
 +		if (sysfs_type(sd) != SYSFS_DIR)
 +			sysfs_remove_one(&acxt, sd);
 +	}
++=======
+ 	pr_debug("sysfs %s: removing\n", sd->s_name);
+ 
+ 	next = NULL;
+ 	do {
+ 		pos = next;
+ 		next = sysfs_next_descendant_post(pos, sd);
+ 		if (pos)
+ 			sysfs_remove_one(acxt, pos);
+ 	} while (next);
+ }
+ 
+ /**
+  * kernfs_remove - remove a sysfs_dirent recursively
+  * @sd: the sysfs_dirent to remove
+  *
+  * Remove @sd along with all its subdirectories and files.
+  */
+ void kernfs_remove(struct sysfs_dirent *sd)
+ {
+ 	struct sysfs_addrm_cxt acxt;
+ 
+ 	sysfs_addrm_start(&acxt);
+ 	__kernfs_remove(&acxt, sd);
+ 	sysfs_addrm_finish(&acxt);
+ }
+ 
+ /**
+  * kernfs_remove_by_name_ns - find a sysfs_dirent by name and remove it
+  * @dir_sd: parent of the target
+  * @name: name of the sysfs_dirent to remove
+  * @ns: namespace tag of the sysfs_dirent to remove
+  *
+  * Look for the sysfs_dirent with @name and @ns under @dir_sd and remove
+  * it.  Returns 0 on success, -ENOENT if such entry doesn't exist.
+  */
+ int kernfs_remove_by_name_ns(struct sysfs_dirent *dir_sd, const char *name,
+ 			     const void *ns)
+ {
+ 	struct sysfs_addrm_cxt acxt;
+ 	struct sysfs_dirent *sd;
+ 
+ 	if (!dir_sd) {
+ 		WARN(1, KERN_WARNING "sysfs: can not remove '%s', no directory\n",
+ 			name);
+ 		return -ENOENT;
+ 	}
+ 
+ 	sysfs_addrm_start(&acxt);
+ 
+ 	sd = sysfs_find_dirent(dir_sd, name, ns);
+ 	if (sd)
+ 		__kernfs_remove(&acxt, sd);
+ 
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  	sysfs_addrm_finish(&acxt);
  
 -	if (sd)
 -		return 0;
 -	else
 -		return -ENOENT;
 +	remove_dir(dir_sd);
  }
  
  /**
@@@ -862,16 -910,30 +925,23 @@@ void sysfs_remove_dir(struct kobject * 
  {
  	struct sysfs_dirent *sd = kobj->sd;
  
 -	/*
 -	 * In general, kboject owner is responsible for ensuring removal
 -	 * doesn't race with other operations and sysfs doesn't provide any
 -	 * protection; however, when @kobj is used as a symlink target, the
 -	 * symlinking entity usually doesn't own @kobj and thus has no
 -	 * control over removal.  @kobj->sd may be removed anytime and
 -	 * symlink code may end up dereferencing an already freed sd.
 -	 *
 -	 * sysfs_symlink_target_lock synchronizes @kobj->sd disassociation
 -	 * against symlink operations so that symlink code can safely
 -	 * dereference @kobj->sd.
 -	 */
 -	spin_lock(&sysfs_symlink_target_lock);
 +	spin_lock(&sysfs_assoc_lock);
  	kobj->sd = NULL;
 -	spin_unlock(&sysfs_symlink_target_lock);
 +	spin_unlock(&sysfs_assoc_lock);
  
++<<<<<<< HEAD
 +	__sysfs_remove_dir(sd);
++=======
+ 	if (sd) {
+ 		WARN_ON_ONCE(sysfs_type(sd) != SYSFS_DIR);
+ 		kernfs_remove(sd);
+ 	}
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  }
  
 -int sysfs_rename(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent_sd,
 -		 const char *new_name, const void *new_ns)
 +int sysfs_rename(struct sysfs_dirent *sd,
 +	struct sysfs_dirent *new_parent_sd, const void *new_ns,
 +	const char *new_name)
  {
  	int error;
  
diff --cc fs/sysfs/file.c
index 602f56db0442,5664410136ba..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -652,26 -939,24 +652,30 @@@ int sysfs_chmod_file(struct kobject *ko
  }
  EXPORT_SYMBOL_GPL(sysfs_chmod_file);
  
 +
  /**
 - * sysfs_remove_file_ns - remove an object attribute with a custom ns tag
 - * @kobj: object we're acting for
 - * @attr: attribute descriptor
 - * @ns: namespace tag of the file to remove
 + *	sysfs_remove_file - remove an object attribute.
 + *	@kobj:	object we're acting for.
 + *	@attr:	attribute descriptor.
   *
 - * Hash the attribute name and namespace tag and kill the victim.
 + *	Hash the attribute name and kill the victim.
   */
 -void sysfs_remove_file_ns(struct kobject *kobj, const struct attribute *attr,
 -			  const void *ns)
 +
 +void sysfs_remove_file(struct kobject * kobj, const struct attribute * attr)
  {
 -	struct sysfs_dirent *dir_sd = kobj->sd;
 +	const void *ns;
  
++<<<<<<< HEAD
 +	if (sysfs_attr_ns(kobj, attr, &ns))
 +		return;
 +
 +	sysfs_hash_and_remove(kobj->sd, ns, attr->name);
++=======
+ 	kernfs_remove_by_name_ns(dir_sd, attr->name, ns);
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  }
 -EXPORT_SYMBOL_GPL(sysfs_remove_file_ns);
  
 -void sysfs_remove_files(struct kobject *kobj, const struct attribute **ptr)
 +void sysfs_remove_files(struct kobject * kobj, const struct attribute **ptr)
  {
  	int i;
  	for (i = 0; ptr[i]; i++)
@@@ -694,12 -980,38 +698,45 @@@ void sysfs_remove_file_from_group(struc
  	else
  		dir_sd = sysfs_get(kobj->sd);
  	if (dir_sd) {
++<<<<<<< HEAD
 +		sysfs_hash_and_remove(dir_sd, NULL, attr->name);
++=======
+ 		kernfs_remove_by_name(dir_sd, attr->name);
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  		sysfs_put(dir_sd);
  	}
  }
  EXPORT_SYMBOL_GPL(sysfs_remove_file_from_group);
  
++<<<<<<< HEAD
++=======
+ /**
+  *	sysfs_create_bin_file - create binary file for object.
+  *	@kobj:	object.
+  *	@attr:	attribute descriptor.
+  */
+ int sysfs_create_bin_file(struct kobject *kobj,
+ 			  const struct bin_attribute *attr)
+ {
+ 	BUG_ON(!kobj || !kobj->sd || !attr);
+ 
+ 	return sysfs_add_file(kobj->sd, &attr->attr, SYSFS_KOBJ_BIN_ATTR);
+ }
+ EXPORT_SYMBOL_GPL(sysfs_create_bin_file);
+ 
+ /**
+  *	sysfs_remove_bin_file - remove binary file for object.
+  *	@kobj:	object.
+  *	@attr:	attribute descriptor.
+  */
+ void sysfs_remove_bin_file(struct kobject *kobj,
+ 			   const struct bin_attribute *attr)
+ {
+ 	kernfs_remove_by_name(kobj->sd, attr->attr.name);
+ }
+ EXPORT_SYMBOL_GPL(sysfs_remove_bin_file);
+ 
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  struct sysfs_schedule_callback_struct {
  	struct list_head	workq_list;
  	struct kobject		*kobj;
diff --cc fs/sysfs/group.c
index 1a6e16c0db91,4bd997340830..000000000000
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@@ -26,7 -26,7 +26,11 @@@ static void remove_files(struct sysfs_d
  
  	if (grp->attrs)
  		for (attr = grp->attrs; *attr; attr++)
++<<<<<<< HEAD
 +			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
++=======
+ 			kernfs_remove_by_name(dir_sd, (*attr)->name);
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  	if (grp->bin_attrs)
  		for (bin_attr = grp->bin_attrs; *bin_attr; bin_attr++)
  			sysfs_remove_bin_file(kobj, *bin_attr);
@@@ -49,8 -49,7 +53,12 @@@ static int create_files(struct sysfs_di
  			 * re-adding (if required) the file.
  			 */
  			if (update)
++<<<<<<< HEAD
 +				sysfs_hash_and_remove(dir_sd, NULL,
 +						      (*attr)->name);
++=======
+ 				kernfs_remove_by_name(dir_sd, (*attr)->name);
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  			if (grp->is_visible) {
  				mode = grp->is_visible(kobj, *attr, i);
  				if (!mode)
@@@ -110,7 -110,7 +118,11 @@@ static int internal_create_group(struc
  	error = create_files(sd, kobj, grp, update);
  	if (error) {
  		if (grp->name)
++<<<<<<< HEAD
 +			sysfs_remove_subdir(sd);
++=======
+ 			kernfs_remove(sd);
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  	}
  	sysfs_put(sd);
  	return error;
@@@ -218,7 -218,7 +230,11 @@@ void sysfs_remove_group(struct kobject 
  
  	remove_files(sd, kobj, grp);
  	if (grp->name)
++<<<<<<< HEAD
 +		sysfs_remove_subdir(sd);
++=======
+ 		kernfs_remove(sd);
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  
  	sysfs_put(sd);
  }
@@@ -269,7 -269,7 +285,11 @@@ int sysfs_merge_group(struct kobject *k
  		error = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);
  	if (error) {
  		while (--i >= 0)
++<<<<<<< HEAD
 +			sysfs_hash_and_remove(dir_sd, NULL, (*--attr)->name);
++=======
+ 			kernfs_remove_by_name(dir_sd, (*--attr)->name);
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  	}
  	sysfs_put(dir_sd);
  
@@@ -288,10 -288,10 +308,14 @@@ void sysfs_unmerge_group(struct kobjec
  	struct sysfs_dirent *dir_sd;
  	struct attribute *const *attr;
  
 -	dir_sd = sysfs_get_dirent(kobj->sd, grp->name);
 +	dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
  	if (dir_sd) {
  		for (attr = grp->attrs; *attr; ++attr)
++<<<<<<< HEAD
 +			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
++=======
+ 			kernfs_remove_by_name(dir_sd, (*attr)->name);
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  		sysfs_put(dir_sd);
  	}
  }
@@@ -332,9 -332,9 +356,13 @@@ void sysfs_remove_link_from_group(struc
  {
  	struct sysfs_dirent *dir_sd;
  
 -	dir_sd = sysfs_get_dirent(kobj->sd, group_name);
 +	dir_sd = sysfs_get_dirent(kobj->sd, NULL, group_name);
  	if (dir_sd) {
++<<<<<<< HEAD
 +		sysfs_hash_and_remove(dir_sd, NULL, link_name);
++=======
+ 		kernfs_remove_by_name(dir_sd, link_name);
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  		sysfs_put(dir_sd);
  	}
  }
diff --cc fs/sysfs/symlink.c
index 8c940df97a52,71583fc8100a..000000000000
--- a/fs/sysfs/symlink.c
+++ b/fs/sysfs/symlink.c
@@@ -154,11 -143,17 +154,16 @@@ void sysfs_delete_link(struct kobject *
  			const char *name)
  {
  	const void *ns = NULL;
 -
 -	/*
 -	 * We don't own @target and it may be removed at any time.
 -	 * Synchronize using sysfs_symlink_target_lock.  See
 -	 * sysfs_remove_dir() for details.
 -	 */
 -	spin_lock(&sysfs_symlink_target_lock);
 -	if (targ->sd && (kobj->sd->s_flags & SYSFS_FLAG_NS))
 +	spin_lock(&sysfs_assoc_lock);
 +	if (targ->sd && sysfs_ns_type(kobj->sd))
  		ns = targ->sd->s_ns;
++<<<<<<< HEAD
 +	spin_unlock(&sysfs_assoc_lock);
 +	sysfs_hash_and_remove(kobj->sd, ns, name);
++=======
+ 	spin_unlock(&sysfs_symlink_target_lock);
+ 	kernfs_remove_by_name_ns(kobj->sd, name, ns);
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  }
  
  /**
@@@ -176,11 -170,12 +181,15 @@@ void sysfs_remove_link(struct kobject 
  	else
  		parent_sd = kobj->sd;
  
++<<<<<<< HEAD
 +	sysfs_hash_and_remove(parent_sd, NULL, name);
++=======
+ 	kernfs_remove_by_name(parent_sd, name);
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  }
 -EXPORT_SYMBOL_GPL(sysfs_remove_link);
  
  /**
 - *	sysfs_rename_link_ns - rename symlink in object's directory.
 + *	sysfs_rename_link - rename symlink in object's directory.
   *	@kobj:	object we're acting for.
   *	@targ:	object we're pointing to.
   *	@old:	previous name of the symlink.
diff --cc fs/sysfs/sysfs.h
index d1e4043eb0c3,97625b15ca03..000000000000
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@@ -162,14 -165,14 +162,23 @@@ extern const struct dentry_operations s
  extern const struct file_operations sysfs_dir_operations;
  extern const struct inode_operations sysfs_dir_inode_operations;
  
 +struct dentry *sysfs_get_dentry(struct sysfs_dirent *sd);
  struct sysfs_dirent *sysfs_get_active(struct sysfs_dirent *sd);
  void sysfs_put_active(struct sysfs_dirent *sd);
++<<<<<<< HEAD
 +void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt,
 +		       struct sysfs_dirent *parent_sd);
 +int __sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
 +int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
 +void sysfs_remove_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
++=======
+ void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt);
+ void sysfs_warn_dup(struct sysfs_dirent *parent, const char *name);
+ int __sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd,
+ 		    struct sysfs_dirent *parent_sd);
+ int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd,
+ 		  struct sysfs_dirent *parent_sd);
++>>>>>>> 879f40d193bb (sysfs, kernfs: introduce kernfs_remove[_by_name[_ns]]())
  void sysfs_addrm_finish(struct sysfs_addrm_cxt *acxt);
  
  struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,
* Unmerged path fs/sysfs/dir.c
* Unmerged path fs/sysfs/file.c
* Unmerged path fs/sysfs/group.c
* Unmerged path fs/sysfs/symlink.c
* Unmerged path fs/sysfs/sysfs.h
diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 254b9e872b09..83e151ad0619 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -7,6 +7,30 @@
 #ifndef __LINUX_KERNFS_H
 #define __LINUX_KERNFS_H
 
+#include <linux/kernel.h>
+
 struct sysfs_dirent;
 
+#ifdef CONFIG_SYSFS
+
+void kernfs_remove(struct sysfs_dirent *sd);
+int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
+			     const void *ns);
+
+#else	/* CONFIG_SYSFS */
+
+static inline void kernfs_remove(struct sysfs_dirent *sd) { }
+
+static inline int kernfs_remove_by_name_ns(struct sysfs_dirent *parent,
+					   const char *name, const void *ns)
+{ return -ENOSYS; }
+
+#endif	/* CONFIG_SYSFS */
+
+static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,
+					const char *name)
+{
+	return kernfs_remove_by_name_ns(parent, name, NULL);
+}
+
 #endif	/* __LINUX_KERNFS_H */
