mm: validate device_hotplug is held for memory hotplug

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mm] validate device_hotplug is held for memory hotplug (Jeff Moyer) [1438579]
Rebuild_FUZZ: 96.15%
commit-author Dan Williams <dan.j.williams@intel.com>
commit 3fc21924100b13f73c734d0ce8dfcfe913fcf7a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3fc21924.failed

mem_hotplug_begin() assumes that it can set mem_hotplug.active_writer
and run the hotplug process without racing another thread.  Validate
this assumption with a lockdep assertion.

Link: http://lkml.kernel.org/r/148693886229.16345.1770484669403334689.stgit@dwillia2-desk3.amr.corp.intel.com
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Reported-by: Ben Hutchings <ben@decadent.org.uk>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Toshi Kani <toshi.kani@hpe.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Logan Gunthorpe <logang@deltatee.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3fc21924100b13f73c734d0ce8dfcfe913fcf7a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory_hotplug.c
diff --cc mm/memory_hotplug.c
index 53747167957f,92a242af5a91..000000000000
--- a/mm/memory_hotplug.c
+++ b/mm/memory_hotplug.c
@@@ -49,19 -49,104 +49,45 @@@
  static void generic_online_page(struct page *page);
  
  static online_page_callback_t online_page_callback = generic_online_page;
 -static DEFINE_MUTEX(online_page_callback_lock);
 -
 -/* The same as the cpu_hotplug lock, but for memory hotplug. */
 -static struct {
 -	struct task_struct *active_writer;
 -	struct mutex lock; /* Synchronizes accesses to refcount, */
 -	/*
 -	 * Also blocks the new readers during
 -	 * an ongoing mem hotplug operation.
 -	 */
 -	int refcount;
  
 -#ifdef CONFIG_DEBUG_LOCK_ALLOC
 -	struct lockdep_map dep_map;
 -#endif
 -} mem_hotplug = {
 -	.active_writer = NULL,
 -	.lock = __MUTEX_INITIALIZER(mem_hotplug.lock),
 -	.refcount = 0,
 -#ifdef CONFIG_DEBUG_LOCK_ALLOC
 -	.dep_map = {.name = "mem_hotplug.lock" },
 -#endif
 -};
 -
 -/* Lockdep annotations for get/put_online_mems() and mem_hotplug_begin/end() */
 -#define memhp_lock_acquire_read() lock_map_acquire_read(&mem_hotplug.dep_map)
 -#define memhp_lock_acquire()      lock_map_acquire(&mem_hotplug.dep_map)
 -#define memhp_lock_release()      lock_map_release(&mem_hotplug.dep_map)
 -
 -#ifndef CONFIG_MEMORY_HOTPLUG_DEFAULT_ONLINE
 -bool memhp_auto_online;
 -#else
 -bool memhp_auto_online = true;
 -#endif
 -EXPORT_SYMBOL_GPL(memhp_auto_online);
 +DEFINE_MUTEX(mem_hotplug_mutex);
  
 -static int __init setup_memhp_default_state(char *str)
 +void lock_memory_hotplug(void)
  {
 -	if (!strcmp(str, "online"))
 -		memhp_auto_online = true;
 -	else if (!strcmp(str, "offline"))
 -		memhp_auto_online = false;
 -
 -	return 1;
 +	mutex_lock(&mem_hotplug_mutex);
  }
 -__setup("memhp_default_state=", setup_memhp_default_state);
  
 -void get_online_mems(void)
 +void unlock_memory_hotplug(void)
  {
 -	might_sleep();
 -	if (mem_hotplug.active_writer == current)
 -		return;
 -	memhp_lock_acquire_read();
 -	mutex_lock(&mem_hotplug.lock);
 -	mem_hotplug.refcount++;
 -	mutex_unlock(&mem_hotplug.lock);
 -
 -}
 -
 -void put_online_mems(void)
 -{
 -	if (mem_hotplug.active_writer == current)
 -		return;
 -	mutex_lock(&mem_hotplug.lock);
 -
 -	if (WARN_ON(!mem_hotplug.refcount))
 -		mem_hotplug.refcount++; /* try to fix things up */
 -
 -	if (!--mem_hotplug.refcount && unlikely(mem_hotplug.active_writer))
 -		wake_up_process(mem_hotplug.active_writer);
 -	mutex_unlock(&mem_hotplug.lock);
 -	memhp_lock_release();
 -
 +	mutex_unlock(&mem_hotplug_mutex);
  }
  
++<<<<<<< HEAD
++=======
+ void mem_hotplug_begin(void)
+ {
+ 	assert_held_device_hotplug();
+ 
+ 	mem_hotplug.active_writer = current;
+ 
+ 	memhp_lock_acquire();
+ 	for (;;) {
+ 		mutex_lock(&mem_hotplug.lock);
+ 		if (likely(!mem_hotplug.refcount))
+ 			break;
+ 		__set_current_state(TASK_UNINTERRUPTIBLE);
+ 		mutex_unlock(&mem_hotplug.lock);
+ 		schedule();
+ 	}
+ }
+ 
+ void mem_hotplug_done(void)
+ {
+ 	mem_hotplug.active_writer = NULL;
+ 	mutex_unlock(&mem_hotplug.lock);
+ 	memhp_lock_release();
+ }
++>>>>>>> 3fc21924100b (mm: validate device_hotplug is held for memory hotplug)
  
  /* add this memory to iomem resource */
  static struct resource *register_memory_resource(u64 start, u64 size)
diff --git a/drivers/base/core.c b/drivers/base/core.c
index cb4115569ad8..e489b62553dd 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -72,6 +72,11 @@ int lock_device_hotplug_sysfs(void)
 	return restart_syscall();
 }
 
+void assert_held_device_hotplug(void)
+{
+	lockdep_assert_held(&device_hotplug_lock);
+}
+
 #ifdef CONFIG_BLOCK
 static inline int device_is_not_partition(struct device *dev)
 {
diff --git a/include/linux/device.h b/include/linux/device.h
index b11af8a6145d..9619f3efcc59 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -994,6 +994,7 @@ static inline bool device_supports_offline(struct device *dev)
 extern void lock_device_hotplug(void);
 extern void unlock_device_hotplug(void);
 extern int lock_device_hotplug_sysfs(void);
+void assert_held_device_hotplug(void);
 extern int device_offline(struct device *dev);
 extern int device_online(struct device *dev);
 extern void set_primary_fwnode(struct device *dev, struct fwnode_handle *fwnode);
* Unmerged path mm/memory_hotplug.c
