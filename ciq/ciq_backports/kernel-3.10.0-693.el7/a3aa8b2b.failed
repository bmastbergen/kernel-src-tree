xprtrdma: Save I/O direction in struct rpcrdma_frwr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit a3aa8b2b84a59ddd5f624aae9ee0f8b3333793e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a3aa8b2b.failed

Move the the I/O direction field from rpcrdma_mr_seg into the
rpcrdma_frmr.

This makes it possible to DMA-unmap the frwr long after an RPC has
exited and its rpcrdma_mr_seg array has been released and re-used.
This might occur if an RPC times out while waiting for a new
connection to be established.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Tested-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit a3aa8b2b84a59ddd5f624aae9ee0f8b3333793e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/frwr_ops.c
#	net/sunrpc/xprtrdma/xprt_rdma.h
diff --cc net/sunrpc/xprtrdma/frwr_ops.c
index ee5e390519e0,e1e6ac142d48..000000000000
--- a/net/sunrpc/xprtrdma/frwr_ops.c
+++ b/net/sunrpc/xprtrdma/frwr_ops.c
@@@ -415,12 -415,13 +415,17 @@@ frwr_op_map(struct rpcrdma_xprt *r_xprt
  		    offset_in_page((seg-1)->mr_offset + (seg-1)->mr_len))
  			break;
  	}
++<<<<<<< HEAD
 +	frmr->sg_nents = i;
++=======
+ 	frmr->fr_nents = i;
+ 	frmr->fr_dir = direction;
++>>>>>>> a3aa8b2b84a5 (xprtrdma: Save I/O direction in struct rpcrdma_frwr)
  
 -	dma_nents = ib_dma_map_sg(device, frmr->fr_sg, frmr->fr_nents, direction);
 +	dma_nents = ib_dma_map_sg(device, frmr->sg, frmr->sg_nents, direction);
  	if (!dma_nents) {
  		pr_err("RPC:       %s: failed to dma map sg %p sg_nents %u\n",
 -		       __func__, frmr->fr_sg, frmr->fr_nents);
 +		       __func__, frmr->sg, frmr->sg_nents);
  		return -ENOMEM;
  	}
  
@@@ -500,7 -500,7 +504,11 @@@ __frwr_dma_unmap(struct rpcrdma_xprt *r
  
  	seg->rl_mw = NULL;
  
++<<<<<<< HEAD
 +	ib_dma_unmap_sg(device, f->sg, f->sg_nents, seg->mr_dir);
++=======
+ 	ib_dma_unmap_sg(device, f->fr_sg, f->fr_nents, f->fr_dir);
++>>>>>>> a3aa8b2b84a5 (xprtrdma: Save I/O direction in struct rpcrdma_frwr)
  
  	if (!rc)
  		rpcrdma_put_mw(r_xprt, mw);
@@@ -611,7 -611,7 +619,11 @@@ frwr_op_unmap(struct rpcrdma_xprt *r_xp
  	invalidate_wr->ex.invalidate_rkey = frmr->fr_mr->rkey;
  	DECR_CQCOUNT(&r_xprt->rx_ep);
  
++<<<<<<< HEAD
 +	ib_dma_unmap_sg(ia->ri_device, frmr->sg, frmr->sg_nents, seg1->mr_dir);
++=======
+ 	ib_dma_unmap_sg(ia->ri_device, frmr->fr_sg, frmr->fr_nents, frmr->fr_dir);
++>>>>>>> a3aa8b2b84a5 (xprtrdma: Save I/O direction in struct rpcrdma_frwr)
  	read_lock(&ia->ri_qplock);
  	rc = ib_post_send(ia->ri_id->qp, invalidate_wr, &bad_wr);
  	read_unlock(&ia->ri_qplock);
diff --cc net/sunrpc/xprtrdma/xprt_rdma.h
index 61999b694a15,b5793cb59d5c..000000000000
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@@ -222,8 -222,9 +222,14 @@@ enum rpcrdma_frmr_state 
  };
  
  struct rpcrdma_frmr {
++<<<<<<< HEAD
 +	struct scatterlist		*sg;
 +	int				sg_nents;
++=======
+ 	struct scatterlist		*fr_sg;
+ 	int				fr_nents;
+ 	enum dma_data_direction		fr_dir;
++>>>>>>> a3aa8b2b84a5 (xprtrdma: Save I/O direction in struct rpcrdma_frwr)
  	struct ib_mr			*fr_mr;
  	struct ib_cqe			fr_cqe;
  	enum rpcrdma_frmr_state		fr_state;
* Unmerged path net/sunrpc/xprtrdma/frwr_ops.c
* Unmerged path net/sunrpc/xprtrdma/xprt_rdma.h
