bridge: vlan: use rcu for vlan_list traversal in br_fill_ifinfo

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit e9c953eff7f0ec69a52cfa87b912ab48902a0314
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e9c953ef.failed

br_fill_ifinfo is called by br_ifinfo_notify which can be called from
many contexts with different locks held, sometimes it relies upon
bridge's spinlock only which is a problem for the vlan code, so use
explicitly rcu for that to avoid problems.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Reviewed-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e9c953eff7f0ec69a52cfa87b912ab48902a0314)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_netlink.c
diff --cc net/bridge/br_netlink.c
index 52cf83faf183,94b4de8c4646..000000000000
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@@ -112,13 -252,15 +112,18 @@@ static int br_fill_ifvlaninfo_compresse
  	 * and mark vlan info with begin and end flags
  	 * if vlaninfo represents a range
  	 */
++<<<<<<< HEAD
 +	pvid = br_get_pvid(pv);
 +	for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
++=======
+ 	pvid = br_get_pvid(vg);
+ 	list_for_each_entry_rcu(v, &vg->vlan_list, vlist) {
++>>>>>>> e9c953eff7f0 (bridge: vlan: use rcu for vlan_list traversal in br_fill_ifinfo)
  		flags = 0;
 -		if (!br_vlan_should_use(v))
 -			continue;
 -		if (v->vid == pvid)
 +		if (vid == pvid)
  			flags |= BRIDGE_VLAN_INFO_PVID;
  
 -		if (v->flags & BRIDGE_VLAN_INFO_UNTAGGED)
 +		if (test_bit(vid, pv->untagged_bitmap))
  			flags |= BRIDGE_VLAN_INFO_UNTAGGED;
  
  		if (vid_range_start == 0) {
@@@ -154,19 -296,23 +159,28 @@@ initvars
  }
  
  static int br_fill_ifvlaninfo(struct sk_buff *skb,
 -			      struct net_bridge_vlan_group *vg)
 +			      const struct net_port_vlans *pv)
  {
  	struct bridge_vlan_info vinfo;
 -	struct net_bridge_vlan *v;
 -	u16 pvid;
 +	u16 pvid, vid;
  
++<<<<<<< HEAD
 +	pvid = br_get_pvid(pv);
 +	for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
 +		vinfo.vid = vid;
++=======
+ 	pvid = br_get_pvid(vg);
+ 	list_for_each_entry_rcu(v, &vg->vlan_list, vlist) {
+ 		if (!br_vlan_should_use(v))
+ 			continue;
+ 
+ 		vinfo.vid = v->vid;
++>>>>>>> e9c953eff7f0 (bridge: vlan: use rcu for vlan_list traversal in br_fill_ifinfo)
  		vinfo.flags = 0;
 -		if (v->vid == pvid)
 +		if (vid == pvid)
  			vinfo.flags |= BRIDGE_VLAN_INFO_PVID;
  
 -		if (v->flags & BRIDGE_VLAN_INFO_UNTAGGED)
 +		if (test_bit(vid, pv->untagged_bitmap))
  			vinfo.flags |= BRIDGE_VLAN_INFO_UNTAGGED;
  
  		if (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,
@@@ -240,22 -386,27 +254,39 @@@ static int br_fill_ifinfo(struct sk_buf
  		struct nlattr *af;
  		int err;
  
+ 		/* RCU needed because of the VLAN locking rules (rcu || rtnl) */
+ 		rcu_read_lock();
  		if (port)
++<<<<<<< HEAD
 +			pv = nbp_get_vlan_info(port);
 +		else
 +			pv = br_get_vlan_info(br);
 +
 +		if (!pv || bitmap_empty(pv->vlan_bitmap, VLAN_N_VID))
- 			goto done;
++=======
+ 			vg = nbp_vlan_group_rcu(port);
+ 		else
+ 			vg = br_vlan_group_rcu(br);
  
+ 		if (!vg || !vg->num_vlans) {
+ 			rcu_read_unlock();
++>>>>>>> e9c953eff7f0 (bridge: vlan: use rcu for vlan_list traversal in br_fill_ifinfo)
+ 			goto done;
+ 		}
  		af = nla_nest_start(skb, IFLA_AF_SPEC);
- 		if (!af)
+ 		if (!af) {
+ 			rcu_read_unlock();
  			goto nla_put_failure;
- 
+ 		}
  		if (filter_mask & RTEXT_FILTER_BRVLAN_COMPRESSED)
 -			err = br_fill_ifvlaninfo_compressed(skb, vg);
 +			err = br_fill_ifvlaninfo_compressed(skb, pv);
  		else
++<<<<<<< HEAD
 +			err = br_fill_ifvlaninfo(skb, pv);
++=======
+ 			err = br_fill_ifvlaninfo(skb, vg);
+ 		rcu_read_unlock();
++>>>>>>> e9c953eff7f0 (bridge: vlan: use rcu for vlan_list traversal in br_fill_ifinfo)
  		if (err)
  			goto nla_put_failure;
  		nla_nest_end(skb, af);
* Unmerged path net/bridge/br_netlink.c
