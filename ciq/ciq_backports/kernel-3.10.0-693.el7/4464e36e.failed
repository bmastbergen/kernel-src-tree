dm raid: fix table line argument order in status

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Heinz Mauelshagen <heinzm@redhat.com>
commit 4464e36e06470e3d68dc26a874f0dbdffa09a6e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4464e36e.failed

Commit 3a1c1ef2f ("dm raid: enhance status interface and fixup
takeover/raid0") added new table line arguments and introduced an
ordering flaw.  The sequence of the raid10_copies and raid10_format
raid parameters got reversed which causes lvm2 userspace to fail by
falsely assuming a changed table line.

Sequence those 2 parameters as before so that old lvm2 can function
properly with new kernels by adjusting the table line output as
documented in Documentation/device-mapper/dm-raid.txt.

Also, add missing version 1.10.1 highlight to the documention.

Fixes: 3a1c1ef2f ("dm raid: enhance status interface and fixup takeover/raid0")
	Signed-off-by: Heinz Mauelshagen <heinzm@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 4464e36e06470e3d68dc26a874f0dbdffa09a6e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/device-mapper/dm-raid.txt
#	drivers/md/dm-raid.c
diff --cc Documentation/device-mapper/dm-raid.txt
index 50ecc7c9d3eb,95c4c8dd6dd1..000000000000
--- a/Documentation/device-mapper/dm-raid.txt
+++ b/Documentation/device-mapper/dm-raid.txt
@@@ -314,3 -330,7 +314,10 @@@ Version Histor
  	fails reading a superblock. Correctly emit 'maj:min1 maj:min2' and
  	'D' on the status line.  If '- -' is passed into the constructor, emit
  	'- -' on the table line and '-' as the status line health character.
++<<<<<<< HEAD
++=======
+ 1.10.0  Add support for raid4/5/6 journal device
+ 1.10.1  Fix data corruption on reshape request
+ 1.11.0  Fix table line argument order
+ 	(wrong raid10_copies/raid10_format sequence)
++>>>>>>> 4464e36e0647 (dm raid: fix table line argument order in status)
diff --cc drivers/md/dm-raid.c
index 8c0e46544ce4,e07185fca638..000000000000
--- a/drivers/md/dm-raid.c
+++ b/drivers/md/dm-raid.c
@@@ -3268,34 -3380,16 +3268,20 @@@ static void raid_status(struct dm_targe
  		raid_param_cnt += rebuild_disks * 2 +
  				  write_mostly_params +
  				  hweight32(rs->ctr_flags & CTR_FLAG_OPTIONS_NO_ARGS) +
++<<<<<<< HEAD
 +				  hweight32(rs->ctr_flags & CTR_FLAG_OPTIONS_ONE_ARG) * 2;
++=======
+ 				  hweight32(rs->ctr_flags & CTR_FLAG_OPTIONS_ONE_ARG) * 2 +
+ 				  (test_bit(__CTR_FLAG_JOURNAL_DEV, &rs->ctr_flags) ? 2 : 0);
+ 
++>>>>>>> 4464e36e0647 (dm raid: fix table line argument order in status)
  		/* Emit table line */
+ 		/* This has to be in the documented order for userspace! */
  		DMEMIT("%s %u %u", rs->raid_type->name, raid_param_cnt, mddev->new_chunk_sectors);
- 		if (test_bit(__CTR_FLAG_RAID10_FORMAT, &rs->ctr_flags))
- 			DMEMIT(" %s %s", dm_raid_arg_name_by_flag(CTR_FLAG_RAID10_FORMAT),
- 					 raid10_md_layout_to_format(mddev->layout));
- 		if (test_bit(__CTR_FLAG_RAID10_COPIES, &rs->ctr_flags))
- 			DMEMIT(" %s %d", dm_raid_arg_name_by_flag(CTR_FLAG_RAID10_COPIES),
- 					 raid10_md_layout_to_copies(mddev->layout));
- 		if (test_bit(__CTR_FLAG_NOSYNC, &rs->ctr_flags))
- 			DMEMIT(" %s", dm_raid_arg_name_by_flag(CTR_FLAG_NOSYNC));
  		if (test_bit(__CTR_FLAG_SYNC, &rs->ctr_flags))
  			DMEMIT(" %s", dm_raid_arg_name_by_flag(CTR_FLAG_SYNC));
- 		if (test_bit(__CTR_FLAG_REGION_SIZE, &rs->ctr_flags))
- 			DMEMIT(" %s %llu", dm_raid_arg_name_by_flag(CTR_FLAG_REGION_SIZE),
- 					   (unsigned long long) to_sector(mddev->bitmap_info.chunksize));
- 		if (test_bit(__CTR_FLAG_DATA_OFFSET, &rs->ctr_flags))
- 			DMEMIT(" %s %llu", dm_raid_arg_name_by_flag(CTR_FLAG_DATA_OFFSET),
- 					   (unsigned long long) rs->data_offset);
- 		if (test_bit(__CTR_FLAG_DAEMON_SLEEP, &rs->ctr_flags))
- 			DMEMIT(" %s %lu", dm_raid_arg_name_by_flag(CTR_FLAG_DAEMON_SLEEP),
- 					  mddev->bitmap_info.daemon_sleep);
- 		if (test_bit(__CTR_FLAG_DELTA_DISKS, &rs->ctr_flags))
- 			DMEMIT(" %s %d", dm_raid_arg_name_by_flag(CTR_FLAG_DELTA_DISKS),
- 					 max(rs->delta_disks, mddev->delta_disks));
- 		if (test_bit(__CTR_FLAG_STRIPE_CACHE, &rs->ctr_flags))
- 			DMEMIT(" %s %d", dm_raid_arg_name_by_flag(CTR_FLAG_STRIPE_CACHE),
- 					 max_nr_stripes);
+ 		if (test_bit(__CTR_FLAG_NOSYNC, &rs->ctr_flags))
+ 			DMEMIT(" %s", dm_raid_arg_name_by_flag(CTR_FLAG_NOSYNC));
  		if (rebuild_disks)
  			for (i = 0; i < rs->raid_disks; i++)
  				if (test_bit(rs->dev[i].rdev.raid_disk, (void *) rs->rebuild_disks))
@@@ -3309,12 -3412,27 +3304,36 @@@
  		if (test_bit(__CTR_FLAG_MAX_WRITE_BEHIND, &rs->ctr_flags))
  			DMEMIT(" %s %lu", dm_raid_arg_name_by_flag(CTR_FLAG_MAX_WRITE_BEHIND),
  					  mddev->bitmap_info.max_write_behind);
++<<<<<<< HEAD
 +		if (test_bit(__CTR_FLAG_MAX_RECOVERY_RATE, &rs->ctr_flags))
 +			DMEMIT(" %s %d", dm_raid_arg_name_by_flag(CTR_FLAG_MAX_RECOVERY_RATE),
 +					 mddev->sync_speed_max);
 +		if (test_bit(__CTR_FLAG_MIN_RECOVERY_RATE, &rs->ctr_flags))
 +			DMEMIT(" %s %d", dm_raid_arg_name_by_flag(CTR_FLAG_MIN_RECOVERY_RATE),
 +					 mddev->sync_speed_min);
++=======
+ 		if (test_bit(__CTR_FLAG_STRIPE_CACHE, &rs->ctr_flags))
+ 			DMEMIT(" %s %d", dm_raid_arg_name_by_flag(CTR_FLAG_STRIPE_CACHE),
+ 					 max_nr_stripes);
+ 		if (test_bit(__CTR_FLAG_REGION_SIZE, &rs->ctr_flags))
+ 			DMEMIT(" %s %llu", dm_raid_arg_name_by_flag(CTR_FLAG_REGION_SIZE),
+ 					   (unsigned long long) to_sector(mddev->bitmap_info.chunksize));
+ 		if (test_bit(__CTR_FLAG_RAID10_COPIES, &rs->ctr_flags))
+ 			DMEMIT(" %s %d", dm_raid_arg_name_by_flag(CTR_FLAG_RAID10_COPIES),
+ 					 raid10_md_layout_to_copies(mddev->layout));
+ 		if (test_bit(__CTR_FLAG_RAID10_FORMAT, &rs->ctr_flags))
+ 			DMEMIT(" %s %s", dm_raid_arg_name_by_flag(CTR_FLAG_RAID10_FORMAT),
+ 					 raid10_md_layout_to_format(mddev->layout));
+ 		if (test_bit(__CTR_FLAG_DELTA_DISKS, &rs->ctr_flags))
+ 			DMEMIT(" %s %d", dm_raid_arg_name_by_flag(CTR_FLAG_DELTA_DISKS),
+ 					 max(rs->delta_disks, mddev->delta_disks));
+ 		if (test_bit(__CTR_FLAG_DATA_OFFSET, &rs->ctr_flags))
+ 			DMEMIT(" %s %llu", dm_raid_arg_name_by_flag(CTR_FLAG_DATA_OFFSET),
+ 					   (unsigned long long) rs->data_offset);
+ 		if (test_bit(__CTR_FLAG_JOURNAL_DEV, &rs->ctr_flags))
+ 			DMEMIT(" %s %s", dm_raid_arg_name_by_flag(CTR_FLAG_JOURNAL_DEV),
+ 					__get_dev_name(rs->journal_dev.dev));
++>>>>>>> 4464e36e0647 (dm raid: fix table line argument order in status)
  		DMEMIT(" %d", rs->raid_disks);
  		for (i = 0; i < rs->raid_disks; i++)
  			DMEMIT(" %s %s", __get_dev_name(rs->dev[i].meta_dev),
@@@ -3668,27 -3791,9 +3687,31 @@@ static void raid_resume(struct dm_targe
  		mddev_resume(mddev);
  }
  
 +static int raid_merge(struct dm_target *ti, struct bvec_merge_data *bvm,
 +		      struct bio_vec *biovec, int max_size)
 +{
 +	struct raid_set *rs = ti->private;
 +	struct md_personality *pers = rs->md.pers;
 +
 +	if (pers && pers->mergeable_bvec)
 +		return min(max_size, pers->mergeable_bvec(&rs->md, bvm, biovec));
 +
 +	/*
 +	 * In case we can't request the personality because
 +	 * the raid set is not running yet
 +	 *
 +	 * -> return safe minimum
 +	 */
 +	return rs->md.chunk_sectors;
 +}
 +
  static struct target_type raid_target = {
  	.name = "raid",
++<<<<<<< HEAD
 +	.version = {1, 9, 2},
++=======
+ 	.version = {1, 11, 0},
++>>>>>>> 4464e36e0647 (dm raid: fix table line argument order in status)
  	.module = THIS_MODULE,
  	.ctr = raid_ctr,
  	.dtr = raid_dtr,
* Unmerged path Documentation/device-mapper/dm-raid.txt
* Unmerged path drivers/md/dm-raid.c
