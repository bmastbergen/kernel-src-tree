Drivers: hv: vmbus: add an API vmbus_hvsock_device_unregister()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hv] vmbus: add an API vmbus_hvsock_device_unregister() (Vitaly Kuznetsov) [1406404 1418889]
Rebuild_FUZZ: 88.50%
commit-author Dexuan Cui <decui@microsoft.com>
commit 85d9aa705184a4504d0330017e3956fcdae8a9d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/85d9aa70.failed

The hvsock driver needs this API to release all the resources related
to the channel.

	Signed-off-by: Dexuan Cui <decui@microsoft.com>
	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 85d9aa705184a4504d0330017e3956fcdae8a9d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/channel_mgmt.c
diff --cc drivers/hv/channel_mgmt.c
index 1d08f1f4296e,cf311be88cb4..000000000000
--- a/drivers/hv/channel_mgmt.c
+++ b/drivers/hv/channel_mgmt.c
@@@ -761,6 -747,10 +767,13 @@@ static void vmbus_onoffer_rescind(struc
  	spin_unlock_irqrestore(&channel->lock, flags);
  
  	if (channel->device_obj) {
++<<<<<<< HEAD
++=======
+ 		if (channel->chn_rescind_callback) {
+ 			channel->chn_rescind_callback(channel);
+ 			goto out;
+ 		}
++>>>>>>> 85d9aa705184 (Drivers: hv: vmbus: add an API vmbus_hvsock_device_unregister())
  		/*
  		 * We will have to unregister this device from the
  		 * driver core.
* Unmerged path drivers/hv/channel_mgmt.c
diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c
index 2cf10be44060..fcf8a02dc0ea 100644
--- a/drivers/hv/connection.c
+++ b/drivers/hv/connection.c
@@ -296,7 +296,8 @@ struct vmbus_channel *relid2channel(u32 relid)
 	struct list_head *cur, *tmp;
 	struct vmbus_channel *cur_sc;
 
-	mutex_lock(&vmbus_connection.channel_mutex);
+	BUG_ON(!mutex_is_locked(&vmbus_connection.channel_mutex));
+
 	list_for_each_entry(channel, &vmbus_connection.chn_list, listentry) {
 		if (channel->offermsg.child_relid == relid) {
 			found_channel = channel;
@@ -315,7 +316,6 @@ struct vmbus_channel *relid2channel(u32 relid)
 			}
 		}
 	}
-	mutex_unlock(&vmbus_connection.channel_mutex);
 
 	return found_channel;
 }
diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h
index e40e5568b432..33f856781900 100644
--- a/include/linux/hyperv.h
+++ b/include/linux/hyperv.h
@@ -1073,6 +1073,8 @@ int __must_check __vmbus_driver_register(struct hv_driver *hv_driver,
 					 const char *mod_name);
 void vmbus_driver_unregister(struct hv_driver *hv_driver);
 
+void vmbus_hvsock_device_unregister(struct vmbus_channel *channel);
+
 int vmbus_allocate_mmio(struct resource **new, struct hv_device *device_obj,
 			resource_size_t min, resource_size_t max,
 			resource_size_t size, resource_size_t align,
