GSO: Add GSO type for fixed IPv4 ID

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit cbc53e08a793b073e79f42ca33f1f3568703540d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/cbc53e08.failed

This patch adds support for TSO using IPv4 headers with a fixed IP ID
field.  This is meant to allow us to do a lossless GRO in the case of TCP
flows that use a fixed IP ID such as those that convert IPv6 header to IPv4
headers.

In addition I am adding a feature that for now I am referring to TSO with
IP ID mangling.  Basically when this flag is enabled the device has the
option to either output the flow with incrementing IP IDs or with a fixed
IP ID regardless of what the original IP ID ordering was.  This is useful
in cases where the DF bit is set and we do not care if the original IP ID
value is maintained.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cbc53e08a793b073e79f42ca33f1f3568703540d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdev_features.h
#	include/linux/skbuff.h
#	net/core/dev.c
#	net/ipv4/af_inet.c
#	net/ipv4/gre_offload.c
#	net/ipv4/tcp_offload.c
#	net/ipv6/ip6_offload.c
#	net/mpls/mpls_gso.c
diff --cc include/linux/netdev_features.h
index 733a4fde7215,7cf272a4b5c8..000000000000
--- a/include/linux/netdev_features.h
+++ b/include/linux/netdev_features.h
@@@ -144,9 -121,8 +145,13 @@@ enum 
  #define NETIF_F_GSO_SIT		__NETIF_F(GSO_SIT)
  #define NETIF_F_GSO_UDP_TUNNEL	__NETIF_F(GSO_UDP_TUNNEL)
  #define NETIF_F_GSO_UDP_TUNNEL_CSUM __NETIF_F(GSO_UDP_TUNNEL_CSUM)
++<<<<<<< HEAD
 +#define NETIF_F_GSO_MPLS	__NETIF_F(GSO_MPLS)
++=======
+ #define NETIF_F_TSO_MANGLEID	__NETIF_F(TSO_MANGLEID)
++>>>>>>> cbc53e08a793 (GSO: Add GSO type for fixed IPv4 ID)
  #define NETIF_F_GSO_TUNNEL_REMCSUM __NETIF_F(GSO_TUNNEL_REMCSUM)
 +#define NETIF_F_GSO_SCTP	__NETIF_F(GSO_SCTP)
  #define NETIF_F_HW_VLAN_STAG_FILTER __NETIF_F(HW_VLAN_STAG_FILTER)
  #define NETIF_F_HW_VLAN_STAG_RX	__NETIF_F(HW_VLAN_STAG_RX)
  #define NETIF_F_HW_VLAN_STAG_TX	__NETIF_F(HW_VLAN_STAG_TX)
@@@ -168,15 -144,13 +173,22 @@@
  		~NETIF_F_NEVER_CHANGE)
  
  /* Segmentation offload feature mask */
 -#define NETIF_F_GSO_MASK	(__NETIF_F_BIT(NETIF_F_GSO_LAST + 1) - \
 -		__NETIF_F_BIT(NETIF_F_GSO_SHIFT))
 +#define NETIF_F_GSO2_MASK (NETIF_F_GSO_GRE_CSUM|NETIF_F_GSO_UDP_TUNNEL_CSUM|\
 +			   NETIF_F_GSO_TUNNEL_REMCSUM|NETIF_F_GSO_SCTP)
 +#define NETIF_F_GSO_MASK	((__NETIF_F_BIT(NETIF_F_GSO_LAST + 1) - \
 +				 __NETIF_F_BIT(NETIF_F_GSO_SHIFT)) | \
 +				NETIF_F_GSO2_MASK)
 +
 +#define NETIF_F_GSO2_SHIFT (NETIF_F_GSO_GRE_CSUM_BIT - \
 +		(NETIF_F_GSO_LAST + 1 - NETIF_F_GSO_SHIFT))
  
++<<<<<<< HEAD
++=======
+ /* List of features with software fallbacks. */
+ #define NETIF_F_GSO_SOFTWARE	(NETIF_F_TSO | NETIF_F_TSO_ECN | \
+ 				 NETIF_F_TSO_MANGLEID | \
+ 				 NETIF_F_TSO6 | NETIF_F_UFO)
++>>>>>>> cbc53e08a793 (GSO: Add GSO type for fixed IPv4 ID)
  
  /* List of IP checksum features. Note that NETIF_F_ HW_CSUM should not be
   * set in features when NETIF_F_IP_CSUM or NETIF_F_IPV6_CSUM are set--
diff --cc include/linux/skbuff.h
index 49c3fe129351,5fba16658f9d..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -412,35 -465,27 +412,50 @@@ enum 
  	/* This indicates the tcp segment has CWR set. */
  	SKB_GSO_TCP_ECN = 1 << 3,
  
- 	SKB_GSO_TCPV6 = 1 << 4,
+ 	SKB_GSO_TCP_FIXEDID = 1 << 4,
  
- 	SKB_GSO_FCOE = 1 << 5,
+ 	SKB_GSO_TCPV6 = 1 << 5,
  
- 	SKB_GSO_GRE = 1 << 6,
+ 	SKB_GSO_FCOE = 1 << 6,
  
++<<<<<<< HEAD
 +	SKB_GSO_IPIP = 1 << 7,
 +
 +	SKB_GSO_SIT = 1 << 8,
 +
 +	SKB_GSO_UDP_TUNNEL = 1 << 9,
 +
 +	SKB_GSO_MPLS = 1 << 10,
 +
 +	/* GSO_MASK2, see netdev_features.h */
 +	SKB_GSO_GRE_CSUM = 1 << 11,
++=======
+ 	SKB_GSO_GRE = 1 << 7,
+ 
+ 	SKB_GSO_GRE_CSUM = 1 << 8,
+ 
+ 	SKB_GSO_IPIP = 1 << 9,
+ 
+ 	SKB_GSO_SIT = 1 << 10,
+ 
+ 	SKB_GSO_UDP_TUNNEL = 1 << 11,
++>>>>>>> cbc53e08a793 (GSO: Add GSO type for fixed IPv4 ID)
  
  	SKB_GSO_UDP_TUNNEL_CSUM = 1 << 12,
  
  	SKB_GSO_TUNNEL_REMCSUM = 1 << 13,
++<<<<<<< HEAD
 +
 +	SKB_GSO_SCTP = 1 << 14,
++=======
++>>>>>>> cbc53e08a793 (GSO: Add GSO type for fixed IPv4 ID)
  };
  
 +/* NETIF_F_GSO flags are no longer part of a single range */
 +#define SKB_GSO1_MASK (SKB_GSO_GRE_CSUM - 1)
 +#define SKB_GSO2_MASK (SKB_GSO_GRE_CSUM|SKB_GSO_UDP_TUNNEL_CSUM|\
 +		       SKB_GSO_TUNNEL_REMCSUM|SKB_GSO_SCTP)
 +
  #if BITS_PER_LONG > 32
  #define NET_SKBUFF_DATA_USES_OFFSET 1
  #endif
diff --cc net/core/dev.c
index e2ceb23207bd,e896b1953ab6..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -2656,10 -2851,10 +2679,17 @@@ static netdev_features_t gso_features_c
  netdev_features_t netif_skb_features(struct sk_buff *skb)
  {
  	struct net_device *dev = skb->dev;
++<<<<<<< HEAD
 +	netdev_features_t features = skb->dev->features;
 +
 +	if (skb_shinfo(skb)->gso_segs > skb->dev->gso_max_segs)
 +		features &= ~NETIF_F_GSO_MASK;
++=======
+ 	netdev_features_t features = dev->features;
+ 
+ 	if (skb_is_gso(skb))
+ 		features = gso_features_check(skb, dev, features);
++>>>>>>> cbc53e08a793 (GSO: Add GSO type for fixed IPv4 ID)
  
  	/* If encapsulation offload request, verify we are testing
  	 * hardware encapsulation features instead of standard
diff --cc net/ipv4/af_inet.c
index 3068a0e54f0b,5bbea9a0ce96..000000000000
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@@ -1216,6 -1205,23 +1216,26 @@@ static struct sk_buff *inet_gso_segment
  	int ihl;
  	int id;
  
++<<<<<<< HEAD
++=======
+ 	if (unlikely(skb_shinfo(skb)->gso_type &
+ 		     ~(SKB_GSO_TCPV4 |
+ 		       SKB_GSO_UDP |
+ 		       SKB_GSO_DODGY |
+ 		       SKB_GSO_TCP_ECN |
+ 		       SKB_GSO_GRE |
+ 		       SKB_GSO_GRE_CSUM |
+ 		       SKB_GSO_IPIP |
+ 		       SKB_GSO_SIT |
+ 		       SKB_GSO_TCPV6 |
+ 		       SKB_GSO_UDP_TUNNEL |
+ 		       SKB_GSO_UDP_TUNNEL_CSUM |
+ 		       SKB_GSO_TCP_FIXEDID |
+ 		       SKB_GSO_TUNNEL_REMCSUM |
+ 		       0)))
+ 		goto out;
+ 
++>>>>>>> cbc53e08a793 (GSO: Add GSO type for fixed IPv4 ID)
  	skb_reset_network_header(skb);
  	nhoff = skb_network_header(skb) - skb_mac_header(skb);
  	if (unlikely(!pskb_may_pull(skb, sizeof(*iph))))
@@@ -1260,12 -1269,11 +1283,11 @@@
  	do {
  		iph = (struct iphdr *)(skb_mac_header(skb) + nhoff);
  		if (udpfrag) {
- 			iph->id = htons(id);
  			iph->frag_off = htons(offset >> 3);
 -			if (skb->next)
 +			if (skb->next != NULL)
  				iph->frag_off |= htons(IP_MF);
  			offset += skb->len - nhoff - ihl;
- 		} else {
+ 		} else if (!fixedid) {
  			iph->id = htons(id++);
  		}
  		iph->tot_len = htons(skb->len - nhoff);
diff --cc net/ipv4/gre_offload.c
index b0328bedf364,6376b0cdf693..000000000000
--- a/net/ipv4/gre_offload.c
+++ b/net/ipv4/gre_offload.c
@@@ -26,6 -26,19 +26,22 @@@ static struct sk_buff *gre_gso_segment(
  	int gre_offset, outer_hlen;
  	bool need_csum, ufo;
  
++<<<<<<< HEAD
++=======
+ 	if (unlikely(skb_shinfo(skb)->gso_type &
+ 				~(SKB_GSO_TCPV4 |
+ 				  SKB_GSO_TCPV6 |
+ 				  SKB_GSO_UDP |
+ 				  SKB_GSO_DODGY |
+ 				  SKB_GSO_TCP_ECN |
+ 				  SKB_GSO_TCP_FIXEDID |
+ 				  SKB_GSO_GRE |
+ 				  SKB_GSO_GRE_CSUM |
+ 				  SKB_GSO_IPIP |
+ 				  SKB_GSO_SIT)))
+ 		goto out;
+ 
++>>>>>>> cbc53e08a793 (GSO: Add GSO type for fixed IPv4 ID)
  	if (!skb->encapsulation)
  		goto out;
  
diff --cc net/ipv4/tcp_offload.c
index 64b23b193f30,08dd25d835af..000000000000
--- a/net/ipv4/tcp_offload.c
+++ b/net/ipv4/tcp_offload.c
@@@ -68,6 -83,25 +68,28 @@@ struct sk_buff *tcp_gso_segment(struct 
  
  	if (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {
  		/* Packet is from an untrusted source, reset gso_segs. */
++<<<<<<< HEAD
++=======
+ 		int type = skb_shinfo(skb)->gso_type;
+ 
+ 		if (unlikely(type &
+ 			     ~(SKB_GSO_TCPV4 |
+ 			       SKB_GSO_DODGY |
+ 			       SKB_GSO_TCP_ECN |
+ 			       SKB_GSO_TCP_FIXEDID |
+ 			       SKB_GSO_TCPV6 |
+ 			       SKB_GSO_GRE |
+ 			       SKB_GSO_GRE_CSUM |
+ 			       SKB_GSO_IPIP |
+ 			       SKB_GSO_SIT |
+ 			       SKB_GSO_UDP_TUNNEL |
+ 			       SKB_GSO_UDP_TUNNEL_CSUM |
+ 			       SKB_GSO_TUNNEL_REMCSUM |
+ 			       0) ||
+ 			     !(type & (SKB_GSO_TCPV4 |
+ 				       SKB_GSO_TCPV6))))
+ 			goto out;
++>>>>>>> cbc53e08a793 (GSO: Add GSO type for fixed IPv4 ID)
  
  		skb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);
  
diff --cc net/ipv6/ip6_offload.c
index 3facfa14ba14,b3a779393d71..000000000000
--- a/net/ipv6/ip6_offload.c
+++ b/net/ipv6/ip6_offload.c
@@@ -67,6 -68,23 +67,26 @@@ static struct sk_buff *ipv6_gso_segment
  	bool encap, udpfrag;
  	int nhoff;
  
++<<<<<<< HEAD
++=======
+ 	if (unlikely(skb_shinfo(skb)->gso_type &
+ 		     ~(SKB_GSO_TCPV4 |
+ 		       SKB_GSO_UDP |
+ 		       SKB_GSO_DODGY |
+ 		       SKB_GSO_TCP_ECN |
+ 		       SKB_GSO_TCP_FIXEDID |
+ 		       SKB_GSO_TCPV6 |
+ 		       SKB_GSO_GRE |
+ 		       SKB_GSO_GRE_CSUM |
+ 		       SKB_GSO_IPIP |
+ 		       SKB_GSO_SIT |
+ 		       SKB_GSO_UDP_TUNNEL |
+ 		       SKB_GSO_UDP_TUNNEL_CSUM |
+ 		       SKB_GSO_TUNNEL_REMCSUM |
+ 		       0)))
+ 		goto out;
+ 
++>>>>>>> cbc53e08a793 (GSO: Add GSO type for fixed IPv4 ID)
  	skb_reset_network_header(skb);
  	nhoff = skb_network_header(skb) - skb_mac_header(skb);
  	if (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))
diff --cc net/mpls/mpls_gso.c
index 5f912656b138,bbcf60465e5c..000000000000
--- a/net/mpls/mpls_gso.c
+++ b/net/mpls/mpls_gso.c
@@@ -26,6 -26,15 +26,18 @@@ static struct sk_buff *mpls_gso_segment
  	netdev_features_t mpls_features;
  	__be16 mpls_protocol;
  
++<<<<<<< HEAD
++=======
+ 	if (unlikely(skb_shinfo(skb)->gso_type &
+ 				~(SKB_GSO_TCPV4 |
+ 				  SKB_GSO_TCPV6 |
+ 				  SKB_GSO_UDP |
+ 				  SKB_GSO_DODGY |
+ 				  SKB_GSO_TCP_FIXEDID |
+ 				  SKB_GSO_TCP_ECN)))
+ 		goto out;
+ 
++>>>>>>> cbc53e08a793 (GSO: Add GSO type for fixed IPv4 ID)
  	/* Setup inner SKB. */
  	mpls_protocol = skb->protocol;
  	skb->protocol = skb->inner_protocol;
* Unmerged path include/linux/netdev_features.h
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 0c457a76a538..7b93c15d4c82 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -3891,6 +3891,7 @@ static inline bool net_gso_ok(netdev_features_t features, int gso_type)
 	BUILD_BUG_ON(SKB_GSO_UDP     != (NETIF_F_UFO >> NETIF_F_GSO_SHIFT));
 	BUILD_BUG_ON(SKB_GSO_DODGY   != (NETIF_F_GSO_ROBUST >> NETIF_F_GSO_SHIFT));
 	BUILD_BUG_ON(SKB_GSO_TCP_ECN != (NETIF_F_TSO_ECN >> NETIF_F_GSO_SHIFT));
+	BUILD_BUG_ON(SKB_GSO_TCP_FIXEDID != (NETIF_F_TSO_MANGLEID >> NETIF_F_GSO_SHIFT));
 	BUILD_BUG_ON(SKB_GSO_TCPV6   != (NETIF_F_TSO6 >> NETIF_F_GSO_SHIFT));
 	BUILD_BUG_ON(SKB_GSO_FCOE    != (NETIF_F_FSO >> NETIF_F_GSO_SHIFT));
 	BUILD_BUG_ON(SKB_GSO_GRE     != (NETIF_F_GSO_GRE >> NETIF_F_GSO_SHIFT));
* Unmerged path include/linux/skbuff.h
* Unmerged path net/core/dev.c
diff --git a/net/core/ethtool.c b/net/core/ethtool.c
index 939c077f6470..2a9bcaa8f096 100644
--- a/net/core/ethtool.c
+++ b/net/core/ethtool.c
@@ -79,6 +79,7 @@ static const char netdev_features_strings[NETDEV_FEATURE_COUNT][ETH_GSTRING_LEN]
 	[NETIF_F_UFO_BIT] =              "tx-udp-fragmentation",
 	[NETIF_F_GSO_ROBUST_BIT] =       "tx-gso-robust",
 	[NETIF_F_TSO_ECN_BIT] =          "tx-tcp-ecn-segmentation",
+	[NETIF_F_TSO_MANGLEID_BIT] =	 "tx-tcp-mangleid-segmentation",
 	[NETIF_F_TSO6_BIT] =             "tx-tcp6-segmentation",
 	[NETIF_F_FSO_BIT] =              "tx-fcoe-segmentation",
 	[NETIF_F_GSO_GRE_BIT] =		 "tx-gre-segmentation",
* Unmerged path net/ipv4/af_inet.c
* Unmerged path net/ipv4/gre_offload.c
* Unmerged path net/ipv4/tcp_offload.c
* Unmerged path net/ipv6/ip6_offload.c
* Unmerged path net/mpls/mpls_gso.c
