net/mlx5: PCI error recovery health care simulation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [kernel] mlx5: PCI error recovery health care simulation (Don Dutile) [1385330 1417285]
Rebuild_FUZZ: 95.92%
commit-author Mohamad Haj Yahia <mohamad@mellanox.com>
commit 04c0c1ab38e95105d950db5b84e727637e149ce7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/04c0c1ab.failed

In case that the kernel PCI error handlers are not called, we will
trigger our own recovery flow.

The health work will give priority to the kernel pci error handlers to
recover the PCI by waiting for a small period, if the pci error handlers
are not triggered the manual recovery flow will be executed.

We don't save pci state in case of manual recovery because it will ruin the
pci configuration space and we will lose dma sync.

Fixes: 89d44f0a6c73 ('net/mlx5_core: Add pci error handlers to mlx5_core driver')
	Signed-off-by: Mohamad Haj Yahia <mohamad@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 04c0c1ab38e95105d950db5b84e727637e149ce7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/health.c
#	drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/health.c
index 2cb4094c9c49,5bcf93422ee0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/health.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/health.c
@@@ -61,10 -61,15 +61,19 @@@ enum 
  enum {
  	MLX5_NIC_IFC_FULL		= 0,
  	MLX5_NIC_IFC_DISABLED		= 1,
- 	MLX5_NIC_IFC_NO_DRAM_NIC	= 2
+ 	MLX5_NIC_IFC_NO_DRAM_NIC	= 2,
+ 	MLX5_NIC_IFC_INVALID		= 3
  };
  
++<<<<<<< HEAD
 +static u8 get_nic_interface(struct mlx5_core_dev *dev)
++=======
+ enum {
+ 	MLX5_DROP_NEW_HEALTH_WORK,
+ };
+ 
+ static u8 get_nic_state(struct mlx5_core_dev *dev)
++>>>>>>> 04c0c1ab38e9 (net/mlx5: PCI error recovery health care simulation)
  {
  	return (ioread32be(&dev->iseg->cmdq_addr_l_sz) >> 8) & 3;
  }
@@@ -298,6 -344,17 +341,20 @@@ void mlx5_stop_health_poll(struct mlx5_
  	del_timer_sync(&health->timer);
  }
  
++<<<<<<< HEAD
++=======
+ void mlx5_drain_health_wq(struct mlx5_core_dev *dev)
+ {
+ 	struct mlx5_core_health *health = &dev->priv.health;
+ 
+ 	spin_lock(&health->wq_lock);
+ 	set_bit(MLX5_DROP_NEW_HEALTH_WORK, &health->flags);
+ 	spin_unlock(&health->wq_lock);
+ 	cancel_delayed_work_sync(&health->recover_work);
+ 	cancel_work_sync(&health->work);
+ }
+ 
++>>>>>>> 04c0c1ab38e9 (net/mlx5: PCI error recovery health care simulation)
  void mlx5_health_cleanup(struct mlx5_core_dev *dev)
  {
  	struct mlx5_core_health *health = &dev->priv.health;
@@@ -317,9 -374,13 +374,10 @@@ int mlx5_health_init(struct mlx5_core_d
  
  	strcpy(name, "mlx5_health");
  	strcat(name, dev_name(&dev->pdev->dev));
 -	health->wq = create_singlethread_workqueue(name);
  	kfree(name);
 -	if (!health->wq)
 -		return -ENOMEM;
 -	spin_lock_init(&health->wq_lock);
 +
  	INIT_WORK(&health->work, health_care);
+ 	INIT_DELAYED_WORK(&health->recover_work, health_recover);
  
  	return 0;
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index f0d87046af8e,187662c8ea96..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@@ -94,7 -83,13 +94,15 @@@ void mlx5_core_event(struct mlx5_core_d
  		     unsigned long param);
  void mlx5_enter_error_state(struct mlx5_core_dev *dev);
  void mlx5_disable_device(struct mlx5_core_dev *dev);
++<<<<<<< HEAD
++=======
+ void mlx5_recover_device(struct mlx5_core_dev *dev);
+ int mlx5_sriov_init(struct mlx5_core_dev *dev);
+ void mlx5_sriov_cleanup(struct mlx5_core_dev *dev);
+ int mlx5_sriov_attach(struct mlx5_core_dev *dev);
+ void mlx5_sriov_detach(struct mlx5_core_dev *dev);
++>>>>>>> 04c0c1ab38e9 (net/mlx5: PCI error recovery health care simulation)
  int mlx5_core_sriov_configure(struct pci_dev *dev, int num_vfs);
 -bool mlx5_sriov_is_enabled(struct mlx5_core_dev *dev);
  int mlx5_core_enable_hca(struct mlx5_core_dev *dev, u16 func_id);
  int mlx5_core_disable_hca(struct mlx5_core_dev *dev, u16 func_id);
  int mlx5_wait_for_vf_pages(struct mlx5_core_dev *dev);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/health.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c
index e782d0fde09e..a9d4a0e6d66b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -1390,6 +1390,7 @@ static pci_ers_result_t mlx5_pci_err_detected(struct pci_dev *pdev,
 	struct mlx5_priv *priv = &dev->priv;
 
 	dev_info(&pdev->dev, "%s was called\n", __func__);
+
 	mlx5_enter_error_state(dev);
 	mlx5_unload_one(dev, priv);
 	pci_save_state(pdev);
@@ -1450,11 +1451,6 @@ static pci_ers_result_t mlx5_pci_slot_reset(struct pci_dev *pdev)
 	return PCI_ERS_RESULT_RECOVERED;
 }
 
-void mlx5_disable_device(struct mlx5_core_dev *dev)
-{
-	mlx5_pci_err_detected(dev->pdev, 0);
-}
-
 static void mlx5_pci_resume(struct pci_dev *pdev)
 {
 	struct mlx5_core_dev *dev = pci_get_drvdata(pdev);
@@ -1504,6 +1500,18 @@ static const struct pci_device_id mlx5_core_pci_table[] = {
 
 MODULE_DEVICE_TABLE(pci, mlx5_core_pci_table);
 
+void mlx5_disable_device(struct mlx5_core_dev *dev)
+{
+	mlx5_pci_err_detected(dev->pdev, 0);
+}
+
+void mlx5_recover_device(struct mlx5_core_dev *dev)
+{
+	mlx5_pci_disable_device(dev);
+	if (mlx5_pci_slot_reset(dev->pdev) == PCI_ERS_RESULT_RECOVERED)
+		mlx5_pci_resume(dev->pdev);
+}
+
 static struct pci_driver mlx5_core_driver = {
 	.name           = DRIVER_NAME,
 	.id_table       = mlx5_core_pci_table,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h
index c937f7e77b74..e76cba5f348e 100644
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@ -419,6 +419,7 @@ struct mlx5_core_health {
 	bool				sick;
 	struct workqueue_struct	       *wq;
 	struct work_struct		work;
+	struct delayed_work		recover_work;
 };
 
 struct mlx5_cq_table {
