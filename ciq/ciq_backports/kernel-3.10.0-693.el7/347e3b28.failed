switchdev: remove FIB offload infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jiri Pirko <jiri@mellanox.com>
commit 347e3b28c1ba24c1ae2f30290d8247480ab9ce14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/347e3b28.failed

Since this is now taken care of by FIB notifier, remove the code, with
all unused dependencies.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 347e3b28c1ba24c1ae2f30290d8247480ab9ce14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip_fib.h
#	include/net/switchdev.h
#	net/ipv4/fib_rules.c
#	net/ipv4/fib_trie.c
#	net/switchdev/switchdev.c
diff --cc include/net/ip_fib.h
index 9927afab7c39,b9314b48e39f..000000000000
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@@ -194,15 -237,14 +194,20 @@@ struct fib_table 
  
  int fib_table_lookup(struct fib_table *tb, const struct flowi4 *flp,
  		     struct fib_result *res, int fib_flags);
 -int fib_table_insert(struct net *, struct fib_table *, struct fib_config *);
 -int fib_table_delete(struct net *, struct fib_table *, struct fib_config *);
 +int fib_table_insert(struct fib_table *, struct fib_config *);
 +int fib_table_delete(struct fib_table *, struct fib_config *);
  int fib_table_dump(struct fib_table *table, struct sk_buff *skb,
  		   struct netlink_callback *cb);
++<<<<<<< HEAD
 +int fib_table_flush(struct fib_table *table);
++=======
+ int fib_table_flush(struct net *net, struct fib_table *table);
+ struct fib_table *fib_trie_unmerge(struct fib_table *main_tb);
++>>>>>>> 347e3b28c1ba (switchdev: remove FIB offload infrastructure)
  void fib_free_table(struct fib_table *tb);
  
 +
 +
  #ifndef CONFIG_IP_MULTIPLE_TABLES
  
  #define TABLE_LOCAL_INDEX	(RT_TABLE_LOCAL & (FIB_TABLE_HASHSZ - 1))
@@@ -325,6 -354,7 +330,10 @@@ static inline int fib_num_tclassid_user
  	return 0;
  }
  #endif
++<<<<<<< HEAD
++=======
+ int fib_unmerge(struct net *net);
++>>>>>>> 347e3b28c1ba (switchdev: remove FIB offload infrastructure)
  
  /* Exported by fib_semantics.c */
  int ip_fib_check_default(__be32 gw, struct net_device *dev);
diff --cc net/ipv4/fib_rules.c
index 87cf295c5f91,2e50062f642d..000000000000
--- a/net/ipv4/fib_rules.c
+++ b/net/ipv4/fib_rules.c
@@@ -182,6 -228,8 +182,11 @@@ static int fib4_rule_configure(struct f
  	rule4->tos = frh->tos;
  
  	net->ipv4.fib_has_custom_rules = true;
++<<<<<<< HEAD
++=======
+ 	call_fib_rule_notifiers(net, FIB_EVENT_RULE_ADD);
+ 
++>>>>>>> 347e3b28c1ba (switchdev: remove FIB offload infrastructure)
  	err = 0;
  errout:
  	return err;
@@@ -197,6 -250,9 +202,12 @@@ static void fib4_rule_delete(struct fib
  		net->ipv4.fib_num_tclassid_users--;
  #endif
  	net->ipv4.fib_has_custom_rules = true;
++<<<<<<< HEAD
++=======
+ 	call_fib_rule_notifiers(net, FIB_EVENT_RULE_DEL);
+ errout:
+ 	return err;
++>>>>>>> 347e3b28c1ba (switchdev: remove FIB offload infrastructure)
  }
  
  static int fib4_rule_compare(struct fib_rule *rule, struct fib_rule_hdr *frh,
diff --cc net/ipv4/fib_trie.c
index a731822edc22,31cef3602585..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -79,8 -81,47 +79,12 @@@
  #include <net/tcp.h>
  #include <net/sock.h>
  #include <net/ip_fib.h>
++<<<<<<< HEAD
++=======
+ #include <trace/events/fib.h>
++>>>>>>> 347e3b28c1ba (switchdev: remove FIB offload infrastructure)
  #include "fib_lookup.h"
  
 -static BLOCKING_NOTIFIER_HEAD(fib_chain);
 -
 -int register_fib_notifier(struct notifier_block *nb)
 -{
 -	return blocking_notifier_chain_register(&fib_chain, nb);
 -}
 -EXPORT_SYMBOL(register_fib_notifier);
 -
 -int unregister_fib_notifier(struct notifier_block *nb)
 -{
 -	return blocking_notifier_chain_unregister(&fib_chain, nb);
 -}
 -EXPORT_SYMBOL(unregister_fib_notifier);
 -
 -int call_fib_notifiers(struct net *net, enum fib_event_type event_type,
 -		       struct fib_notifier_info *info)
 -{
 -	info->net = net;
 -	return blocking_notifier_call_chain(&fib_chain, event_type, info);
 -}
 -
 -static int call_fib_entry_notifiers(struct net *net,
 -				    enum fib_event_type event_type, u32 dst,
 -				    int dst_len, struct fib_info *fi,
 -				    u8 tos, u8 type, u32 tb_id, u32 nlflags)
 -{
 -	struct fib_entry_notifier_info info = {
 -		.dst = dst,
 -		.dst_len = dst_len,
 -		.fi = fi,
 -		.tos = tos,
 -		.type = type,
 -		.tb_id = tb_id,
 -		.nlflags = nlflags,
 -	};
 -	return call_fib_notifiers(net, event_type, &info.info);
 -}
 -
  #define MAX_STAT_DEPTH 32
  
  #define KEYLENGTH	(8*sizeof(t_key))
@@@ -1154,8 -1211,11 +1158,13 @@@ int fib_table_insert(struct fib_table *
  			state = fa->fa_state;
  			new_fa->fa_state = state & ~FA_S_ACCESSED;
  			new_fa->fa_slen = fa->fa_slen;
++<<<<<<< HEAD
++=======
+ 			new_fa->tb_id = tb->tb_id;
+ 			new_fa->fa_default = -1;
++>>>>>>> 347e3b28c1ba (switchdev: remove FIB offload infrastructure)
  
  			hlist_replace_rcu(&fa->fa_list, &new_fa->fa_list);
 -
  			alias_free_mem_rcu(fa);
  
  			fib_release_info(fi_drop);
@@@ -1190,6 -1258,8 +1199,11 @@@
  	new_fa->fa_type = cfg->fc_type;
  	new_fa->fa_state = 0;
  	new_fa->fa_slen = slen;
++<<<<<<< HEAD
++=======
+ 	new_fa->tb_id = tb->tb_id;
+ 	new_fa->fa_default = -1;
++>>>>>>> 347e3b28c1ba (switchdev: remove FIB offload infrastructure)
  
  	/* Insert new entry to the list. */
  	err = fib_insert_alias(t, tp, l, new_fa, fa, key);
@@@ -1480,6 -1569,9 +1494,12 @@@ int fib_table_delete(struct fib_table *
  	if (!fa_to_delete)
  		return -ESRCH;
  
++<<<<<<< HEAD
++=======
+ 	call_fib_entry_notifiers(net, FIB_EVENT_ENTRY_DEL, key, plen,
+ 				 fa_to_delete->fa_info, tos, cfg->fc_type,
+ 				 tb->tb_id, 0);
++>>>>>>> 347e3b28c1ba (switchdev: remove FIB offload infrastructure)
  	rtmsg_fib(RTM_DELROUTE, htonl(key), fa_to_delete, plen, tb->tb_id,
  		  &cfg->fc_nlinfo, 0);
  
@@@ -1554,8 -1646,122 +1574,125 @@@ found
  	return n;
  }
  
++<<<<<<< HEAD
++=======
+ static void fib_trie_free(struct fib_table *tb)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *pn = t->kv;
+ 	unsigned long cindex = 1;
+ 	struct hlist_node *tmp;
+ 	struct fib_alias *fa;
+ 
+ 	/* walk trie in reverse order and free everything */
+ 	for (;;) {
+ 		struct key_vector *n;
+ 
+ 		if (!(cindex--)) {
+ 			t_key pkey = pn->key;
+ 
+ 			if (IS_TRIE(pn))
+ 				break;
+ 
+ 			n = pn;
+ 			pn = node_parent(pn);
+ 
+ 			/* drop emptied tnode */
+ 			put_child_root(pn, n->key, NULL);
+ 			node_free(n);
+ 
+ 			cindex = get_index(pkey, pn);
+ 
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = get_child(pn, cindex);
+ 		if (!n)
+ 			continue;
+ 
+ 		if (IS_TNODE(n)) {
+ 			/* record pn and cindex for leaf walking */
+ 			pn = n;
+ 			cindex = 1ul << n->bits;
+ 
+ 			continue;
+ 		}
+ 
+ 		hlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {
+ 			hlist_del_rcu(&fa->fa_list);
+ 			alias_free_mem_rcu(fa);
+ 		}
+ 
+ 		put_child_root(pn, n->key, NULL);
+ 		node_free(n);
+ 	}
+ 
+ #ifdef CONFIG_IP_FIB_TRIE_STATS
+ 	free_percpu(t->stats);
+ #endif
+ 	kfree(tb);
+ }
+ 
+ struct fib_table *fib_trie_unmerge(struct fib_table *oldtb)
+ {
+ 	struct trie *ot = (struct trie *)oldtb->tb_data;
+ 	struct key_vector *l, *tp = ot->kv;
+ 	struct fib_table *local_tb;
+ 	struct fib_alias *fa;
+ 	struct trie *lt;
+ 	t_key key = 0;
+ 
+ 	if (oldtb->tb_data == oldtb->__data)
+ 		return oldtb;
+ 
+ 	local_tb = fib_trie_table(RT_TABLE_LOCAL, NULL);
+ 	if (!local_tb)
+ 		return NULL;
+ 
+ 	lt = (struct trie *)local_tb->tb_data;
+ 
+ 	while ((l = leaf_walk_rcu(&tp, key)) != NULL) {
+ 		struct key_vector *local_l = NULL, *local_tp;
+ 
+ 		hlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {
+ 			struct fib_alias *new_fa;
+ 
+ 			if (local_tb->tb_id != fa->tb_id)
+ 				continue;
+ 
+ 			/* clone fa for new local table */
+ 			new_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);
+ 			if (!new_fa)
+ 				goto out;
+ 
+ 			memcpy(new_fa, fa, sizeof(*fa));
+ 
+ 			/* insert clone into table */
+ 			if (!local_l)
+ 				local_l = fib_find_node(lt, &local_tp, l->key);
+ 
+ 			if (fib_insert_alias(lt, local_tp, local_l, new_fa,
+ 					     NULL, l->key))
+ 				goto out;
+ 		}
+ 
+ 		/* stop loop if key wrapped back to 0 */
+ 		key = l->key + 1;
+ 		if (key < l->key)
+ 			break;
+ 	}
+ 
+ 	return local_tb;
+ out:
+ 	fib_trie_free(local_tb);
+ 
+ 	return NULL;
+ }
+ 
++>>>>>>> 347e3b28c1ba (switchdev: remove FIB offload infrastructure)
  /* Caller must hold RTNL. */
 -int fib_table_flush(struct net *net, struct fib_table *tb)
 +int fib_table_flush(struct fib_table *tb)
  {
  	struct trie *t = (struct trie *)tb->tb_data;
  	struct key_vector *pn = t->kv;
@@@ -1604,6 -1810,11 +1741,14 @@@
  				continue;
  			}
  
++<<<<<<< HEAD
++=======
+ 			call_fib_entry_notifiers(net, FIB_EVENT_ENTRY_DEL,
+ 						 n->key,
+ 						 KEYLENGTH - fa->fa_slen,
+ 						 fi, fa->fa_tos, fa->fa_type,
+ 						 tb->tb_id, 0);
++>>>>>>> 347e3b28c1ba (switchdev: remove FIB offload infrastructure)
  			hlist_del_rcu(&fa->fa_list);
  			fib_release_info(fa->fa_info);
  			alias_free_mem_rcu(fa);
* Unmerged path include/net/switchdev.h
* Unmerged path net/switchdev/switchdev.c
* Unmerged path include/net/ip_fib.h
* Unmerged path include/net/switchdev.h
* Unmerged path net/ipv4/fib_rules.c
* Unmerged path net/ipv4/fib_trie.c
* Unmerged path net/switchdev/switchdev.c
