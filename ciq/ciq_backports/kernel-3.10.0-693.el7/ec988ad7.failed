phy: Don't increment MDIO bus refcount unless it's a different owner

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Florian Fainelli <f.fainelli@gmail.com>
commit ec988ad78ed6d184a7f4ca6b8e962b0e8f1de461
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ec988ad7.failed

Commit 3e3aaf649416 ("phy: fix mdiobus module safety") fixed the way we
dealt with MDIO bus module reference count, but sort of introduced a
regression in that, if an Ethernet driver registers its own MDIO bus
driver, as is common, we will end up with the Ethernet driver's
module->refnct set to 1, thus preventing this driver from any removal.

Fix this by comparing the network device's device driver owner against
the MDIO bus driver owner, and only if they are different, increment the
MDIO bus module refcount.

Fixes: 3e3aaf649416 ("phy: fix mdiobus module safety")
	Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ec988ad78ed6d184a7f4ca6b8e962b0e8f1de461)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phy_device.c
diff --cc drivers/net/phy/phy_device.c
index 94906f97acd5,c4ceb082e970..000000000000
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@@ -592,11 -857,17 +592,22 @@@ EXPORT_SYMBOL(phy_init_hw)
  int phy_attach_direct(struct net_device *dev, struct phy_device *phydev,
  		      u32 flags, phy_interface_t interface)
  {
++<<<<<<< HEAD
 +	struct mii_bus *bus = phydev->bus;
 +	struct device *d = &phydev->dev;
++=======
+ 	struct module *ndev_owner = dev->dev.parent->driver->owner;
+ 	struct mii_bus *bus = phydev->mdio.bus;
+ 	struct device *d = &phydev->mdio.dev;
++>>>>>>> ec988ad78ed6 (phy: Don't increment MDIO bus refcount unless it's a different owner)
  	int err;
  
- 	if (!try_module_get(bus->owner)) {
+ 	/* For Ethernet device drivers that register their own MDIO bus, we
+ 	 * will have bus->owner match ndev_mod, so we do not want to increment
+ 	 * our own module->refcnt here, otherwise we would not be able to
+ 	 * unload later on.
+ 	 */
+ 	if (ndev_owner != bus->owner && !try_module_get(bus->owner)) {
  		dev_err(&dev->dev, "failed to get the bus module\n");
  		return -EIO;
  	}
@@@ -721,10 -1004,11 +735,16 @@@ void phy_detach(struct phy_device *phyd
  	 * The phydev might go away on the put_device() below, so avoid
  	 * a use-after-free bug by reading the underlying bus first.
  	 */
 -	bus = phydev->mdio.bus;
 +	bus = phydev->bus;
  
++<<<<<<< HEAD
 +	put_device(&phydev->dev);
 +	module_put(bus->owner);
++=======
+ 	put_device(&phydev->mdio.dev);
+ 	if (ndev_owner != bus->owner)
+ 		module_put(bus->owner);
++>>>>>>> ec988ad78ed6 (phy: Don't increment MDIO bus refcount unless it's a different owner)
  }
  EXPORT_SYMBOL(phy_detach);
  
* Unmerged path drivers/net/phy/phy_device.c
