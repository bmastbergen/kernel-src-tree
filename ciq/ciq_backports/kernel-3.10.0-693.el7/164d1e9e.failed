nfp: add support for ethtool .set_channels

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 164d1e9e5d5235c44851e606d01dd699d8bb15d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/164d1e9e.failed

Allow changing the number of rings via ethtool .set_channels API.
Runtime reconfig needs to be extended to handle number of rings.
We need to be able to activate interrupt vectors before rings are
assigned to them.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 164d1e9e5d5235c44851e606d01dd699d8bb15d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
#	drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net.h
index aecadca0b473,486e7c6453bc..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@@ -560,6 -583,13 +560,16 @@@ struct nfp_net 
  	struct dentry *debugfs_dir;
  };
  
++<<<<<<< HEAD
++=======
+ struct nfp_net_ring_set {
+ 	unsigned int n_rings;
+ 	unsigned int mtu;
+ 	unsigned int dcnt;
+ 	void *rings;
+ };
+ 
++>>>>>>> 164d1e9e5d52 (nfp: add support for ethtool .set_channels)
  /* Functions to read/write from/to a BAR
   * Performs any endian conversion necessary.
   */
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 2a625a67a222,506362729607..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -1553,10 -1582,10 +1553,10 @@@ nfp_net_shadow_tx_rings_prepare(struct 
  	if (!rings)
  		return NULL;
  
- 	for (r = 0; r < nn->num_tx_rings; r++) {
- 		nfp_net_tx_ring_init(&rings[r], nn->tx_rings[r].r_vec, r);
+ 	for (r = 0; r < s->n_rings; r++) {
+ 		nfp_net_tx_ring_init(&rings[r], &nn->r_vecs[r], r);
  
 -		if (nfp_net_tx_ring_alloc(&rings[r], s->dcnt))
 +		if (nfp_net_tx_ring_alloc(&rings[r], buf_cnt))
  			goto err_free_prev;
  	}
  
@@@ -1569,28 -1598,27 +1569,42 @@@ err_free_prev
  	return NULL;
  }
  
 -static void
 -nfp_net_tx_ring_set_swap(struct nfp_net *nn, struct nfp_net_ring_set *s)
 +static struct nfp_net_tx_ring *
 +nfp_net_shadow_tx_rings_swap(struct nfp_net *nn, struct nfp_net_tx_ring *rings)
  {
 -	struct nfp_net_ring_set new = *s;
 +	struct nfp_net_tx_ring *old = nn->tx_rings;
 +	unsigned int r;
 +
++<<<<<<< HEAD
 +	for (r = 0; r < nn->num_tx_rings; r++)
 +		old[r].r_vec->tx_ring = &rings[r];
  
 +	nn->tx_rings = rings;
 +	return old;
++=======
+ 	s->dcnt = nn->txd_cnt;
+ 	s->rings = nn->tx_rings;
+ 	s->n_rings = nn->num_tx_rings;
+ 
+ 	nn->txd_cnt = new.dcnt;
+ 	nn->tx_rings = new.rings;
+ 	nn->num_tx_rings = new.n_rings;
++>>>>>>> 164d1e9e5d52 (nfp: add support for ethtool .set_channels)
  }
  
  static void
 -nfp_net_tx_ring_set_free(struct nfp_net *nn, struct nfp_net_ring_set *s)
 +nfp_net_shadow_tx_rings_free(struct nfp_net *nn, struct nfp_net_tx_ring *rings)
  {
 -	struct nfp_net_tx_ring *rings = s->rings;
  	unsigned int r;
  
++<<<<<<< HEAD
 +	if (!rings)
 +		return;
 +
 +	for (r = 0; r < nn->num_tx_rings; r++)
++=======
+ 	for (r = 0; r < s->n_rings; r++)
++>>>>>>> 164d1e9e5d52 (nfp: add support for ethtool .set_channels)
  		nfp_net_tx_ring_free(&rings[r]);
  
  	kfree(rings);
@@@ -1672,10 -1700,10 +1686,10 @@@ nfp_net_shadow_rx_rings_prepare(struct 
  	if (!rings)
  		return NULL;
  
- 	for (r = 0; r < nn->num_rx_rings; r++) {
- 		nfp_net_rx_ring_init(&rings[r], nn->rx_rings[r].r_vec, r);
+ 	for (r = 0; r < s->n_rings; r++) {
+ 		nfp_net_rx_ring_init(&rings[r], &nn->r_vecs[r], r);
  
 -		if (nfp_net_rx_ring_alloc(&rings[r], fl_bufsz, s->dcnt))
 +		if (nfp_net_rx_ring_alloc(&rings[r], fl_bufsz, buf_cnt))
  			goto err_free_prev;
  
  		if (nfp_net_rx_ring_bufs_alloc(nn, &rings[r]))
@@@ -1694,28 -1722,30 +1708,45 @@@ err_free_ring
  	return NULL;
  }
  
 -static void
 -nfp_net_rx_ring_set_swap(struct nfp_net *nn, struct nfp_net_ring_set *s)
 +static struct nfp_net_rx_ring *
 +nfp_net_shadow_rx_rings_swap(struct nfp_net *nn, struct nfp_net_rx_ring *rings)
  {
 -	struct nfp_net_ring_set new = *s;
 +	struct nfp_net_rx_ring *old = nn->rx_rings;
 +	unsigned int r;
 +
++<<<<<<< HEAD
 +	for (r = 0; r < nn->num_rx_rings; r++)
 +		old[r].r_vec->rx_ring = &rings[r];
  
 +	nn->rx_rings = rings;
 +	return old;
++=======
+ 	s->mtu = nn->netdev->mtu;
+ 	s->dcnt = nn->rxd_cnt;
+ 	s->rings = nn->rx_rings;
+ 	s->n_rings = nn->num_rx_rings;
+ 
+ 	nn->netdev->mtu = new.mtu;
+ 	nn->fl_bufsz = nfp_net_calc_fl_bufsz(nn, new.mtu);
+ 	nn->rxd_cnt = new.dcnt;
+ 	nn->rx_rings = new.rings;
+ 	nn->num_rx_rings = new.n_rings;
++>>>>>>> 164d1e9e5d52 (nfp: add support for ethtool .set_channels)
  }
  
  static void
 -nfp_net_rx_ring_set_free(struct nfp_net *nn, struct nfp_net_ring_set *s)
 +nfp_net_shadow_rx_rings_free(struct nfp_net *nn, struct nfp_net_rx_ring *rings)
  {
 -	struct nfp_net_rx_ring *rings = s->rings;
  	unsigned int r;
  
++<<<<<<< HEAD
 +	if (!rings)
 +		return;
 +
 +	for (r = 0; r < nn->num_rx_rings; r++) {
++=======
+ 	for (r = 0; r < s->n_rings; r++) {
++>>>>>>> 164d1e9e5d52 (nfp: add support for ethtool .set_channels)
  		nfp_net_rx_ring_bufs_free(nn, &rings[r]);
  		nfp_net_rx_ring_free(&rings[r]);
  	}
@@@ -1730,19 -1768,9 +1761,25 @@@ nfp_net_prepare_vector(struct nfp_net *
  	struct msix_entry *entry = &nn->irq_entries[r_vec->irq_idx];
  	int err;
  
++<<<<<<< HEAD
 +	if (idx < nn->num_tx_rings) {
 +		r_vec->tx_ring = &nn->tx_rings[idx];
 +		nfp_net_tx_ring_init(r_vec->tx_ring, r_vec, idx);
 +	} else {
 +		r_vec->tx_ring = NULL;
 +	}
 +
 +	if (idx < nn->num_rx_rings) {
 +		r_vec->rx_ring = &nn->rx_rings[idx];
 +		nfp_net_rx_ring_init(r_vec->rx_ring, r_vec, idx);
 +	} else {
 +		r_vec->rx_ring = NULL;
 +	}
++=======
+ 	/* Setup NAPI */
+ 	netif_napi_add(nn->netdev, &r_vec->napi,
+ 		       nfp_net_poll, NAPI_POLL_WEIGHT);
++>>>>>>> 164d1e9e5d52 (nfp: add support for ethtool .set_channels)
  
  	snprintf(r_vec->name, sizeof(r_vec->name),
  		 "%s-rxtx-%d", nn->netdev->name, idx);
@@@ -2207,94 -2236,104 +2243,189 @@@ static void nfp_net_set_rx_mode(struct 
  	nn->ctrl = new_ctrl;
  }
  
++<<<<<<< HEAD
 +static int nfp_net_change_mtu(struct net_device *netdev, int new_mtu)
 +{
 +	unsigned int old_mtu, old_fl_bufsz, new_fl_bufsz;
 +	struct nfp_net *nn = netdev_priv(netdev);
 +	struct nfp_net_rx_ring *tmp_rings;
 +	int err;
 +
 +	if (new_mtu < 68 || new_mtu > nn->max_mtu) {
 +		nn_err(nn, "New MTU (%d) is not valid\n", new_mtu);
 +		return -EINVAL;
 +	}
 +
 +	old_mtu = netdev->mtu;
 +	old_fl_bufsz = nn->fl_bufsz;
 +	new_fl_bufsz = NFP_NET_MAX_PREPEND + ETH_HLEN + VLAN_HLEN * 2 + new_mtu;
 +
 +	if (!netif_running(netdev)) {
 +		netdev->mtu = new_mtu;
 +		nn->fl_bufsz = new_fl_bufsz;
++=======
+ static void nfp_net_rss_init_itbl(struct nfp_net *nn)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < sizeof(nn->rss_itbl); i++)
+ 		nn->rss_itbl[i] =
+ 			ethtool_rxfh_indir_default(i, nn->num_rx_rings);
+ }
+ 
+ static int
+ nfp_net_ring_swap_enable(struct nfp_net *nn, unsigned int *num_vecs,
+ 			 struct nfp_net_ring_set *rx,
+ 			 struct nfp_net_ring_set *tx)
+ {
+ 	unsigned int r;
+ 	int err;
+ 
+ 	if (rx)
+ 		nfp_net_rx_ring_set_swap(nn, rx);
+ 	if (tx)
+ 		nfp_net_tx_ring_set_swap(nn, tx);
+ 
+ 	swap(*num_vecs, nn->num_r_vecs);
+ 
+ 	for (r = 0; r <	nn->max_r_vecs; r++)
+ 		nfp_net_vector_assign_rings(nn, &nn->r_vecs[r], r);
+ 
+ 	if (nn->netdev->real_num_rx_queues != nn->num_rx_rings) {
+ 		if (!netif_is_rxfh_configured(nn->netdev))
+ 			nfp_net_rss_init_itbl(nn);
+ 
+ 		err = netif_set_real_num_rx_queues(nn->netdev,
+ 						   nn->num_rx_rings);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (nn->netdev->real_num_tx_queues != nn->num_tx_rings) {
+ 		err = netif_set_real_num_tx_queues(nn->netdev,
+ 						   nn->num_tx_rings);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return __nfp_net_set_config_and_enable(nn);
+ }
+ 
+ static void
+ nfp_net_ring_reconfig_down(struct nfp_net *nn,
+ 			   struct nfp_net_ring_set *rx,
+ 			   struct nfp_net_ring_set *tx,
+ 			   unsigned int num_vecs)
+ {
+ 	nn->netdev->mtu = rx ? rx->mtu : nn->netdev->mtu;
+ 	nn->fl_bufsz = nfp_net_calc_fl_bufsz(nn, nn->netdev->mtu);
+ 	nn->rxd_cnt = rx ? rx->dcnt : nn->rxd_cnt;
+ 	nn->txd_cnt = tx ? tx->dcnt : nn->txd_cnt;
+ 	nn->num_rx_rings = rx ? rx->n_rings : nn->num_rx_rings;
+ 	nn->num_tx_rings = tx ? tx->n_rings : nn->num_tx_rings;
+ 	nn->num_r_vecs = num_vecs;
+ 
+ 	if (!netif_is_rxfh_configured(nn->netdev))
+ 		nfp_net_rss_init_itbl(nn);
+ }
+ 
+ int
+ nfp_net_ring_reconfig(struct nfp_net *nn, struct nfp_net_ring_set *rx,
+ 		      struct nfp_net_ring_set *tx)
+ {
+ 	unsigned int num_vecs, r;
+ 	int err;
+ 
+ 	num_vecs = max(rx ? rx->n_rings : nn->num_rx_rings,
+ 		       tx ? tx->n_rings : nn->num_tx_rings);
+ 
+ 	if (!netif_running(nn->netdev)) {
+ 		nfp_net_ring_reconfig_down(nn, rx, tx, num_vecs);
++>>>>>>> 164d1e9e5d52 (nfp: add support for ethtool .set_channels)
  		return 0;
  	}
  
  	/* Prepare new rings */
++<<<<<<< HEAD
 +	tmp_rings = nfp_net_shadow_rx_rings_prepare(nn, new_fl_bufsz,
 +						    nn->rxd_cnt);
 +	if (!tmp_rings)
 +		return -ENOMEM;
 +
 +	/* Stop device, swap in new rings, try to start the firmware */
 +	nfp_net_close_stack(nn);
 +	nfp_net_clear_config_and_disable(nn);
 +
 +	tmp_rings = nfp_net_shadow_rx_rings_swap(nn, tmp_rings);
 +
 +	netdev->mtu = new_mtu;
 +	nn->fl_bufsz = new_fl_bufsz;
 +
 +	err = nfp_net_set_config_and_enable(nn);
 +	if (err) {
 +		const int err_new = err;
 +
 +		/* Try with old configuration and old rings */
 +		tmp_rings = nfp_net_shadow_rx_rings_swap(nn, tmp_rings);
 +
 +		netdev->mtu = old_mtu;
 +		nn->fl_bufsz = old_fl_bufsz;
 +
 +		err = __nfp_net_set_config_and_enable(nn);
 +		if (err)
 +			nn_err(nn, "Can't restore MTU - FW communication failed (%d,%d)\n",
 +			       err_new, err);
 +	}
 +
 +	nfp_net_shadow_rx_rings_free(nn, tmp_rings);
 +
 +	nfp_net_open_stack(nn);
 +
 +	return err;
 +}
 +
 +int nfp_net_set_ring_size(struct nfp_net *nn, u32 rxd_cnt, u32 txd_cnt)
 +{
 +	struct nfp_net_tx_ring *tx_rings = NULL;
 +	struct nfp_net_rx_ring *rx_rings = NULL;
 +	u32 old_rxd_cnt, old_txd_cnt;
 +	int err;
 +
 +	if (!netif_running(nn->netdev)) {
 +		nn->rxd_cnt = rxd_cnt;
 +		nn->txd_cnt = txd_cnt;
 +		return 0;
 +	}
 +
 +	old_rxd_cnt = nn->rxd_cnt;
 +	old_txd_cnt = nn->txd_cnt;
 +
 +	/* Prepare new rings */
 +	if (nn->rxd_cnt != rxd_cnt) {
 +		rx_rings = nfp_net_shadow_rx_rings_prepare(nn, nn->fl_bufsz,
 +							   rxd_cnt);
 +		if (!rx_rings)
 +			return -ENOMEM;
++=======
+ 	for (r = nn->num_r_vecs; r < num_vecs; r++) {
+ 		err = nfp_net_prepare_vector(nn, &nn->r_vecs[r], r);
+ 		if (err) {
+ 			num_vecs = r;
+ 			goto err_cleanup_vecs;
+ 		}
+ 	}
+ 	if (rx) {
+ 		if (!nfp_net_rx_ring_set_prepare(nn, rx)) {
+ 			err = -ENOMEM;
+ 			goto err_cleanup_vecs;
+ 		}
++>>>>>>> 164d1e9e5d52 (nfp: add support for ethtool .set_channels)
  	}
 -	if (tx) {
 -		if (!nfp_net_tx_ring_set_prepare(nn, tx)) {
 -			err = -ENOMEM;
 -			goto err_free_rx;
 +	if (nn->txd_cnt != txd_cnt) {
 +		tx_rings = nfp_net_shadow_tx_rings_prepare(nn, txd_cnt);
 +		if (!tx_rings) {
 +			nfp_net_shadow_rx_rings_free(nn, rx_rings);
 +			return -ENOMEM;
  		}
  	}
  
@@@ -2302,39 -2341,49 +2433,75 @@@
  	nfp_net_close_stack(nn);
  	nfp_net_clear_config_and_disable(nn);
  
++<<<<<<< HEAD
 +	if (rx_rings)
 +		rx_rings = nfp_net_shadow_rx_rings_swap(nn, rx_rings);
 +	if (tx_rings)
 +		tx_rings = nfp_net_shadow_tx_rings_swap(nn, tx_rings);
++=======
+ 	err = nfp_net_ring_swap_enable(nn, &num_vecs, rx, tx);
+ 	if (err) {
+ 		int err2;
++>>>>>>> 164d1e9e5d52 (nfp: add support for ethtool .set_channels)
  
 -		nfp_net_clear_config_and_disable(nn);
 +	nn->rxd_cnt = rxd_cnt;
 +	nn->txd_cnt = txd_cnt;
 +
 +	err = nfp_net_set_config_and_enable(nn);
 +	if (err) {
 +		const int err_new = err;
  
  		/* Try with old configuration and old rings */
++<<<<<<< HEAD
 +		if (rx_rings)
 +			rx_rings = nfp_net_shadow_rx_rings_swap(nn, rx_rings);
 +		if (tx_rings)
 +			tx_rings = nfp_net_shadow_tx_rings_swap(nn, tx_rings);
 +
 +		nn->rxd_cnt = old_rxd_cnt;
 +		nn->txd_cnt = old_txd_cnt;
 +
 +		err = __nfp_net_set_config_and_enable(nn);
 +		if (err)
++=======
+ 		err2 = nfp_net_ring_swap_enable(nn, &num_vecs, rx, tx);
+ 		if (err2)
++>>>>>>> 164d1e9e5d52 (nfp: add support for ethtool .set_channels)
  			nn_err(nn, "Can't restore ring config - FW communication failed (%d,%d)\n",
 -			       err, err2);
 +			       err_new, err);
  	}
+ 	for (r = num_vecs - 1; r >= nn->num_r_vecs; r--)
+ 		nfp_net_cleanup_vector(nn, &nn->r_vecs[r]);
  
 -	if (rx)
 -		nfp_net_rx_ring_set_free(nn, rx);
 -	if (tx)
 -		nfp_net_tx_ring_set_free(nn, tx);
 +	nfp_net_shadow_rx_rings_free(nn, rx_rings);
 +	nfp_net_shadow_tx_rings_free(nn, tx_rings);
  
  	nfp_net_open_stack(nn);
  
  	return err;
++<<<<<<< HEAD
++=======
+ 
+ err_free_rx:
+ 	if (rx)
+ 		nfp_net_rx_ring_set_free(nn, rx);
+ err_cleanup_vecs:
+ 	for (r = num_vecs - 1; r >= nn->num_r_vecs; r--)
+ 		nfp_net_cleanup_vector(nn, &nn->r_vecs[r]);
+ 	return err;
+ }
+ 
+ static int nfp_net_change_mtu(struct net_device *netdev, int new_mtu)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 	struct nfp_net_ring_set rx = {
+ 		.n_rings = nn->num_rx_rings,
+ 		.mtu = new_mtu,
+ 		.dcnt = nn->rxd_cnt,
+ 	};
+ 
+ 	return nfp_net_ring_reconfig(nn, &rx, NULL);
++>>>>>>> 164d1e9e5d52 (nfp: add support for ethtool .set_channels)
  }
  
  static struct rtnl_link_stats64 *nfp_net_stat64(struct net_device *netdev,
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
index 2ec44232cd0b,b87f1b73f200..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
@@@ -146,6 -158,27 +146,30 @@@ static void nfp_net_get_ringparam(struc
  	ring->tx_pending = nn->txd_cnt;
  }
  
++<<<<<<< HEAD
++=======
+ static int nfp_net_set_ring_size(struct nfp_net *nn, u32 rxd_cnt, u32 txd_cnt)
+ {
+ 	struct nfp_net_ring_set *reconfig_rx = NULL, *reconfig_tx = NULL;
+ 	struct nfp_net_ring_set rx = {
+ 		.n_rings = nn->num_rx_rings,
+ 		.mtu = nn->netdev->mtu,
+ 		.dcnt = rxd_cnt,
+ 	};
+ 	struct nfp_net_ring_set tx = {
+ 		.n_rings = nn->num_tx_rings,
+ 		.dcnt = txd_cnt,
+ 	};
+ 
+ 	if (nn->rxd_cnt != rxd_cnt)
+ 		reconfig_rx = &rx;
+ 	if (nn->txd_cnt != txd_cnt)
+ 		reconfig_tx = &tx;
+ 
+ 	return nfp_net_ring_reconfig(nn, reconfig_rx, reconfig_tx);
+ }
+ 
++>>>>>>> 164d1e9e5d52 (nfp: add support for ethtool .set_channels)
  static int nfp_net_set_ringparam(struct net_device *netdev,
  				 struct ethtool_ringparam *ring)
  {
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c b/drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
index f7c9a5bc4aa3..f7cc25404e41 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_debugfs.c
@@ -208,13 +208,13 @@ void nfp_net_debugfs_adapter_add(struct nfp_net *nn)
 	if (IS_ERR_OR_NULL(rx) || IS_ERR_OR_NULL(tx))
 		return;
 
-	for (i = 0; i < nn->num_rx_rings; i++) {
+	for (i = 0; i < min(nn->max_rx_rings, nn->max_r_vecs); i++) {
 		sprintf(int_name, "%d", i);
 		debugfs_create_file(int_name, S_IRUSR, rx,
 				    &nn->r_vecs[i], &nfp_rx_q_fops);
 	}
 
-	for (i = 0; i < nn->num_tx_rings; i++) {
+	for (i = 0; i < min(nn->max_tx_rings, nn->max_r_vecs); i++) {
 		sprintf(int_name, "%d", i);
 		debugfs_create_file(int_name, S_IRUSR, tx,
 				    &nn->r_vecs[i], &nfp_tx_q_fops);
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
