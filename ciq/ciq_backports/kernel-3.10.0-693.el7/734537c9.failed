mm: fix use-after-free if memory allocation failed in vma_adjust()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mm] fix use-after-free if memory allocation failed in vma_adjust() (Andrea Arcangeli) [1374548]
Rebuild_FUZZ: 96.88%
commit-author Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
commit 734537c9cb725fc8005ee7a25c48f1ad10fce5df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/734537c9.failed

There's one case when vma_adjust() expands the vma, overlapping with
*two* next vma.  See case 6 of mprotect, described in the comment to
vma_merge().

To handle this (and only this) situation we iterate twice over main part
of the function.  See "goto again".

Vegard reported[1] that he sees out-of-bounds access complain from
KASAN, if anon_vma_clone() on the *second* iteration fails.

This happens because we free 'next' vma by the end of first iteration
and don't have a way to undo this if anon_vma_clone() fails on the
second iteration.

The solution is to do all required allocations upfront, before we touch
vmas.

The allocation on the second iteration is only required if first two
vmas don't have anon_vma, but third does.  So we need, in total, one
anon_vma_clone() call.

It's easy to adjust 'exporter' to the third vma for such case.

[1] http://lkml.kernel.org/r/1469514843-23778-1-git-send-email-vegard.nossum@oracle.com

Link: http://lkml.kernel.org/r/1469625255-126641-1-git-send-email-kirill.shutemov@linux.intel.com
	Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 734537c9cb725fc8005ee7a25c48f1ad10fce5df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mmap.c
diff --cc mm/mmap.c
index 2cc2556c0b9f,d44bee96a5fe..000000000000
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@@ -763,11 -674,16 +770,16 @@@ int vma_adjust(struct vm_area_struct *v
  		 * shrinking vma had, to cover any anon pages imported.
  		 */
  		if (exporter && exporter->anon_vma && !importer->anon_vma) {
 -			int error;
 -
  			importer->anon_vma = exporter->anon_vma;
 -			error = anon_vma_clone(importer, exporter);
 -			if (error)
 -				return error;
 +			if (anon_vma_clone(importer, exporter))
 +				return -ENOMEM;
  		}
  	}
++<<<<<<< HEAD
++=======
+ again:
+ 	vma_adjust_trans_huge(vma, start, end, adjust_next);
++>>>>>>> 734537c9cb72 (mm: fix use-after-free if memory allocation failed in vma_adjust())
  
  	if (file) {
  		mapping = file->f_mapping;
* Unmerged path mm/mmap.c
