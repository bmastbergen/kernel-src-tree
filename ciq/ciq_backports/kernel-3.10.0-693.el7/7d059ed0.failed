HID: wacom: use wacom_wac_finger_count_touches to set touch_down

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: use wacom_wac_finger_count_touches to set touch_down (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.93%
commit-author Ping Cheng <pinglinux@gmail.com>
commit 7d059ed01ca18d20e0a94ef785ee81a45c19d78c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7d059ed0.failed

Counting number of touching fingers by wacom_wac_finger_count_touches so we
don't have to count them inside individual routines.

	Signed-off-by: Ping Cheng <pingc@wacom.com>
	Reviewed-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 7d059ed01ca18d20e0a94ef785ee81a45c19d78c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index 27dda3639500,59b8e27909d4..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -853,6 -1019,74 +853,77 @@@ static int int_dist(int x1, int y1, in
  	return int_sqrt(x*x + y*y);
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_intuos_bt_process_data(struct wacom_wac *wacom,
+ 		unsigned char *data)
+ {
+ 	memcpy(wacom->data, data, 10);
+ 	wacom_intuos_irq(wacom);
+ 
+ 	input_sync(wacom->input);
+ 	if (wacom->pad_input)
+ 		input_sync(wacom->pad_input);
+ }
+ 
+ static int wacom_intuos_bt_irq(struct wacom_wac *wacom, size_t len)
+ {
+ 	unsigned char data[WACOM_PKGLEN_MAX];
+ 	int i = 1;
+ 	unsigned power_raw, battery_capacity, bat_charging, ps_connected;
+ 
+ 	memcpy(data, wacom->data, len);
+ 
+ 	switch (data[0]) {
+ 	case 0x04:
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		/* fall through */
+ 	case 0x03:
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		power_raw = data[i];
+ 		bat_charging = (power_raw & 0x08) ? 1 : 0;
+ 		ps_connected = (power_raw & 0x10) ? 1 : 0;
+ 		battery_capacity = batcap_i4[power_raw & 0x07];
+ 		wacom_notify_battery(wacom, battery_capacity, bat_charging,
+ 				     battery_capacity || bat_charging,
+ 				     ps_connected);
+ 		break;
+ 	default:
+ 		dev_dbg(wacom->input->dev.parent,
+ 				"Unknown report: %d,%d size:%zu\n",
+ 				data[0], data[1], len);
+ 		return 0;
+ 	}
+ 	return 0;
+ }
+ 
+ static int wacom_wac_finger_count_touches(struct wacom_wac *wacom)
+ {
+ 	struct input_dev *input = wacom->input;
+ 	unsigned touch_max = wacom->features.touch_max;
+ 	int count = 0;
+ 	int i;
+ 
+ 	/* non-HID_GENERIC single touch input doesn't call this routine */
+ 	if ((touch_max == 1) && (wacom->features.type == HID_GENERIC))
+ 		return wacom->hid_data.tipswitch &&
+ 		       !wacom->shared->stylus_in_proximity;
+ 
+ 	for (i = 0; i < input->mt->num_slots; i++) {
+ 		struct input_mt_slot *ps = &input->mt->slots[i];
+ 		int id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);
+ 		if (id >= 0)
+ 			count++;
+ 	}
+ 
+ 	return count;
+ }
+ 
++>>>>>>> 7d059ed01ca1 (HID: wacom: use wacom_wac_finger_count_touches to set touch_down)
  static int wacom_24hdt_irq(struct wacom_wac *wacom)
  {
  	struct input_dev *input = wacom->input;
@@@ -916,9 -1148,10 +987,14 @@@
  	input_mt_sync_frame(input);
  
  	wacom->num_contacts_left -= contacts_to_send;
 -	if (wacom->num_contacts_left <= 0) {
 +	if (wacom->num_contacts_left <= 0)
  		wacom->num_contacts_left = 0;
++<<<<<<< HEAD
 +
++=======
+ 		wacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);
+ 	}
++>>>>>>> 7d059ed01ca1 (HID: wacom: use wacom_wac_finger_count_touches to set touch_down)
  	return 1;
  }
  
@@@ -966,9 -1199,10 +1042,14 @@@ static int wacom_mt_touch(struct wacom_
  	input_mt_sync_frame(input);
  
  	wacom->num_contacts_left -= contacts_to_send;
 -	if (wacom->num_contacts_left <= 0) {
 +	if (wacom->num_contacts_left < 0)
  		wacom->num_contacts_left = 0;
++<<<<<<< HEAD
 +
++=======
+ 		wacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);
+ 	}
++>>>>>>> 7d059ed01ca1 (HID: wacom: use wacom_wac_finger_count_touches to set touch_down)
  	return 1;
  }
  
@@@ -1104,6 -1335,295 +1183,298 @@@ static int wacom_tpc_irq(struct wacom_w
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_map_usage(struct wacom *wacom, struct hid_usage *usage,
+ 		struct hid_field *field, __u8 type, __u16 code, int fuzz)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 	int fmin = field->logical_minimum;
+ 	int fmax = field->logical_maximum;
+ 
+ 	usage->type = type;
+ 	usage->code = code;
+ 
+ 	set_bit(type, input->evbit);
+ 
+ 	switch (type) {
+ 	case EV_ABS:
+ 		input_set_abs_params(input, code, fmin, fmax, fuzz, 0);
+ 		input_abs_set_res(input, code,
+ 				  hidinput_calc_abs_res(field, code));
+ 		break;
+ 	case EV_KEY:
+ 		input_set_capability(input, EV_KEY, code);
+ 		break;
+ 	case EV_MSC:
+ 		input_set_capability(input, EV_MSC, code);
+ 		break;
+ 	}
+ }
+ 
+ static void wacom_wac_pen_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		wacom_map_usage(wacom, usage, field, EV_ABS, ABS_X, 4);
+ 		break;
+ 	case HID_GD_Y:
+ 		wacom_map_usage(wacom, usage, field, EV_ABS, ABS_Y, 4);
+ 		break;
+ 	case HID_DG_TIPPRESSURE:
+ 		wacom_map_usage(wacom, usage, field, EV_ABS, ABS_PRESSURE, 0);
+ 		break;
+ 	case HID_DG_INRANGE:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_TOOL_PEN, 0);
+ 		break;
+ 	case HID_DG_INVERT:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY,
+ 				BTN_TOOL_RUBBER, 0);
+ 		break;
+ 	case HID_DG_ERASER:
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_TOUCH, 0);
+ 		break;
+ 	case HID_DG_BARRELSWITCH:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_STYLUS, 0);
+ 		break;
+ 	case HID_DG_BARRELSWITCH2:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_STYLUS2, 0);
+ 		break;
+ 	case HID_DG_TOOLSERIALNUMBER:
+ 		wacom_map_usage(wacom, usage, field, EV_MSC, MSC_SERIAL, 0);
+ 		break;
+ 	}
+ }
+ 
+ static int wacom_wac_pen_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 
+ 	/* checking which Tool / tip switch to send */
+ 	switch (usage->hid) {
+ 	case HID_DG_INRANGE:
+ 		wacom_wac->hid_data.inrange_state = value;
+ 		return 0;
+ 	case HID_DG_INVERT:
+ 		wacom_wac->hid_data.invert_state = value;
+ 		return 0;
+ 	case HID_DG_ERASER:
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_wac->hid_data.tipswitch |= value;
+ 		return 0;
+ 	}
+ 
+ 	/* send pen events only when touch is up or forced out */
+ 	if (!usage->type || wacom_wac->shared->touch_down)
+ 		return 0;
+ 
+ 	input_event(input, usage->type, usage->code, value);
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_wac_pen_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 	bool prox = wacom_wac->hid_data.inrange_state;
+ 
+ 	if (!wacom_wac->shared->stylus_in_proximity) /* first in prox */
+ 		/* Going into proximity select tool */
+ 		wacom_wac->tool[0] = wacom_wac->hid_data.invert_state ?
+ 						BTN_TOOL_RUBBER : BTN_TOOL_PEN;
+ 
+ 	/* keep pen state for touch events */
+ 	wacom_wac->shared->stylus_in_proximity = prox;
+ 
+ 	/* send pen events only when touch is up or forced out */
+ 	if (!wacom_wac->shared->touch_down) {
+ 		input_report_key(input, BTN_TOUCH,
+ 				wacom_wac->hid_data.tipswitch);
+ 		input_report_key(input, wacom_wac->tool[0], prox);
+ 
+ 		wacom_wac->hid_data.tipswitch = false;
+ 
+ 		input_sync(input);
+ 	}
+ }
+ 
+ static void wacom_wac_finger_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	unsigned touch_max = wacom_wac->features.touch_max;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		features->last_slot_field = usage->hid;
+ 		if (touch_max == 1)
+ 			wacom_map_usage(wacom, usage, field, EV_ABS, ABS_X, 4);
+ 		else
+ 			wacom_map_usage(wacom, usage, field, EV_ABS,
+ 					ABS_MT_POSITION_X, 4);
+ 		break;
+ 	case HID_GD_Y:
+ 		features->last_slot_field = usage->hid;
+ 		if (touch_max == 1)
+ 			wacom_map_usage(wacom, usage, field, EV_ABS, ABS_Y, 4);
+ 		else
+ 			wacom_map_usage(wacom, usage, field, EV_ABS,
+ 					ABS_MT_POSITION_Y, 4);
+ 		break;
+ 	case HID_DG_CONTACTID:
+ 		features->last_slot_field = usage->hid;
+ 		break;
+ 	case HID_DG_INRANGE:
+ 		features->last_slot_field = usage->hid;
+ 		break;
+ 	case HID_DG_INVERT:
+ 		features->last_slot_field = usage->hid;
+ 		break;
+ 	case HID_DG_TIPSWITCH:
+ 		features->last_slot_field = usage->hid;
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_TOUCH, 0);
+ 		break;
+ 	}
+ }
+ 
+ static void wacom_wac_finger_slot(struct wacom_wac *wacom_wac,
+ 		struct input_dev *input)
+ {
+ 	struct hid_data *hid_data = &wacom_wac->hid_data;
+ 	bool mt = wacom_wac->features.touch_max > 1;
+ 	bool prox = hid_data->tipswitch &&
+ 		    !wacom_wac->shared->stylus_in_proximity;
+ 
+ 	if (mt) {
+ 		int slot;
+ 
+ 		slot = input_mt_get_slot_by_key(input, hid_data->id);
+ 		input_mt_slot(input, slot);
+ 		input_mt_report_slot_state(input, MT_TOOL_FINGER, prox);
+ 	}
+ 	else {
+ 		input_report_key(input, BTN_TOUCH, prox);
+ 	}
+ 
+ 	if (prox) {
+ 		input_report_abs(input, mt ? ABS_MT_POSITION_X : ABS_X,
+ 				 hid_data->x);
+ 		input_report_abs(input, mt ? ABS_MT_POSITION_Y : ABS_Y,
+ 				 hid_data->y);
+ 	}
+ }
+ 
+ static int wacom_wac_finger_event(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		wacom_wac->hid_data.x = value;
+ 		break;
+ 	case HID_GD_Y:
+ 		wacom_wac->hid_data.y = value;
+ 		break;
+ 	case HID_DG_CONTACTID:
+ 		wacom_wac->hid_data.id = value;
+ 		break;
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_wac->hid_data.tipswitch = value;
+ 		break;
+ 	}
+ 
+ 
+ 	if (usage->usage_index + 1 == field->report_count) {
+ 		if (usage->hid == wacom_wac->features.last_slot_field)
+ 			wacom_wac_finger_slot(wacom_wac, wacom_wac->input);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_wac_finger_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 	unsigned touch_max = wacom_wac->features.touch_max;
+ 
+ 	if (touch_max > 1)
+ 		input_mt_sync_frame(input);
+ 
+ 	input_sync(input);
+ 
+ 	/* keep touch state for pen event */
+ 	wacom_wac->shared->touch_down = wacom_wac_finger_count_touches(wacom_wac);
+ }
+ 
+ void wacom_wac_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 
+ 	/* currently, only direct devices have proper hid report descriptors */
+ 	__set_bit(INPUT_PROP_DIRECT, input->propbit);
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_usage_mapping(hdev, field, usage);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_usage_mapping(hdev, field, usage);
+ }
+ 
+ int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 
+ 	if (wacom->wacom_wac.features.type != HID_GENERIC)
+ 		return 0;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_event(hdev, field, usage, value);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_event(hdev, field, usage, value);
+ 
+ 	return 0;
+ }
+ 
+ void wacom_wac_report(struct hid_device *hdev, struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_field *field = report->field[0];
+ 
+ 	if (wacom_wac->features.type != HID_GENERIC)
+ 		return;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_report(hdev, report);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_report(hdev, report);
+ }
+ 
++>>>>>>> 7d059ed01ca1 (HID: wacom: use wacom_wac_finger_count_touches to set touch_down)
  static int wacom_bpt_touch(struct wacom_wac *wacom)
  {
  	struct wacom_features *features = &wacom->features;
@@@ -1142,14 -1663,13 +1513,22 @@@
  
  	input_mt_sync_frame(input);
  
++<<<<<<< HEAD
 +	input_report_key(input, BTN_LEFT, (data[1] & 0x08) != 0);
 +	input_report_key(input, BTN_FORWARD, (data[1] & 0x04) != 0);
 +	input_report_key(input, BTN_BACK, (data[1] & 0x02) != 0);
 +	input_report_key(input, BTN_RIGHT, (data[1] & 0x01) != 0);
++=======
+ 	input_report_key(pad_input, BTN_LEFT, (data[1] & 0x08) != 0);
+ 	input_report_key(pad_input, BTN_FORWARD, (data[1] & 0x04) != 0);
+ 	input_report_key(pad_input, BTN_BACK, (data[1] & 0x02) != 0);
+ 	input_report_key(pad_input, BTN_RIGHT, (data[1] & 0x01) != 0);
+ 	wacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);
++>>>>>>> 7d059ed01ca1 (HID: wacom: use wacom_wac_finger_count_touches to set touch_down)
  
 -	return 1;
 +	input_sync(input);
 +
 +	return 0;
  }
  
  static void wacom_bpt3_touch_msg(struct wacom_wac *wacom, unsigned char *data)
@@@ -1227,10 -1753,9 +1606,14 @@@ static int wacom_bpt3_touch(struct waco
  
  	}
  	input_mt_sync_frame(input);
++<<<<<<< HEAD
++=======
+ 	wacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);
++>>>>>>> 7d059ed01ca1 (HID: wacom: use wacom_wac_finger_count_touches to set touch_down)
  
 -	return 1;
 +	input_sync(input);
 +
 +	return 0;
  }
  
  static int wacom_bpt_pen(struct wacom_wac *wacom)
* Unmerged path drivers/hid/wacom_wac.c
