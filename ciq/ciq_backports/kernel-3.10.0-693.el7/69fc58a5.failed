net: phy: Manage fixed PHY address space using IDA

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] phy: Manage fixed PHY address space using IDA (Ivan Vecera) [1382040]
Rebuild_FUZZ: 94.74%
commit-author Florian Fainelli <f.fainelli@gmail.com>
commit 69fc58a57e56bf5e39b48809aefffdaa1b04c945
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/69fc58a5.failed

If we have a system which uses fixed PHY devices and calls
fixed_phy_register() then fixed_phy_unregister() we can exhaust the
number of fixed PHYs available after a while, since we keep incrementing
the variable phy_fixed_addr, but we never decrement it.

This patch fixes that by converting the fixed PHY allocation to using
IDA, which takes care of the allocation/dealloaction of the PHY
addresses for us.

Fixes: a75951217472 ("net: phy: extend fixed driver with fixed_phy_register()")
	Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 69fc58a57e56bf5e39b48809aefffdaa1b04c945)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/fixed_phy.c
diff --cc drivers/net/phy/fixed_phy.c
index 0b6b5e8ee74c,9ec7f7353434..000000000000
--- a/drivers/net/phy/fixed_phy.c
+++ b/drivers/net/phy/fixed_phy.c
@@@ -22,6 -22,8 +22,11 @@@
  #include <linux/err.h>
  #include <linux/slab.h>
  #include <linux/of.h>
++<<<<<<< HEAD
++=======
+ #include <linux/gpio.h>
+ #include <linux/idr.h>
++>>>>>>> 69fc58a57e56 (net: phy: Manage fixed PHY address space using IDA)
  
  #define MII_REGS_NUM 29
  
@@@ -246,7 -287,9 +251,13 @@@ err_regs
  }
  EXPORT_SYMBOL_GPL(fixed_phy_add);
  
++<<<<<<< HEAD
 +void fixed_phy_del(int phy_addr)
++=======
+ static DEFINE_IDA(phy_fixed_ida);
+ 
+ static void fixed_phy_del(int phy_addr)
++>>>>>>> 69fc58a57e56 (net: phy: Manage fixed PHY address space using IDA)
  {
  	struct fixed_mdio_bus *fmb = &platform_fmb;
  	struct fixed_phy *fp, *tmp;
@@@ -254,42 -297,52 +265,62 @@@
  	list_for_each_entry_safe(fp, tmp, &fmb->phys, node) {
  		if (fp->addr == phy_addr) {
  			list_del(&fp->node);
 -			if (gpio_is_valid(fp->link_gpio))
 -				gpio_free(fp->link_gpio);
  			kfree(fp);
+ 			ida_simple_remove(&phy_fixed_ida, phy_addr);
  			return;
  		}
  	}
  }
 +EXPORT_SYMBOL_GPL(fixed_phy_del);
 +
++<<<<<<< HEAD
 +static int phy_fixed_addr;
 +static DEFINE_SPINLOCK(phy_fixed_addr_lock);
  
 +int fixed_phy_register(unsigned int irq,
 +		       struct fixed_phy_status *status,
 +		       struct device_node *np)
++=======
+ struct phy_device *fixed_phy_register(unsigned int irq,
+ 				      struct fixed_phy_status *status,
+ 				      int link_gpio,
+ 				      struct device_node *np)
++>>>>>>> 69fc58a57e56 (net: phy: Manage fixed PHY address space using IDA)
  {
  	struct fixed_mdio_bus *fmb = &platform_fmb;
  	struct phy_device *phy;
  	int phy_addr;
  	int ret;
  
 -	if (!fmb->mii_bus || fmb->mii_bus->state != MDIOBUS_REGISTERED)
 -		return ERR_PTR(-EPROBE_DEFER);
 -
  	/* Get the next available PHY address, up to PHY_MAX_ADDR */
++<<<<<<< HEAD
 +	spin_lock(&phy_fixed_addr_lock);
 +	if (phy_fixed_addr == PHY_MAX_ADDR) {
 +		spin_unlock(&phy_fixed_addr_lock);
 +		return -ENOSPC;
 +	}
 +	phy_addr = phy_fixed_addr++;
 +	spin_unlock(&phy_fixed_addr_lock);
 +
 +	ret = fixed_phy_add(PHY_POLL, phy_addr, status);
 +	if (ret < 0)
 +		return ret;
++=======
+ 	phy_addr = ida_simple_get(&phy_fixed_ida, 0, PHY_MAX_ADDR, GFP_KERNEL);
+ 	if (phy_addr < 0)
+ 		return ERR_PTR(phy_addr);
+ 
+ 	ret = fixed_phy_add(irq, phy_addr, status, link_gpio);
+ 	if (ret < 0) {
+ 		ida_simple_remove(&phy_fixed_ida, phy_addr);
+ 		return ERR_PTR(ret);
+ 	}
++>>>>>>> 69fc58a57e56 (net: phy: Manage fixed PHY address space using IDA)
  
  	phy = get_phy_device(fmb->mii_bus, phy_addr, false);
 -	if (IS_ERR(phy)) {
 +	if (!phy || IS_ERR(phy)) {
  		fixed_phy_del(phy_addr);
 -		return ERR_PTR(-EINVAL);
 -	}
 -
 -	/* propagate the fixed link values to struct phy_device */
 -	phy->link = status->link;
 -	if (status->link) {
 -		phy->speed = status->speed;
 -		phy->duplex = status->duplex;
 -		phy->pause = status->pause;
 -		phy->asym_pause = status->asym_pause;
 +		return -EINVAL;
  	}
  
  	of_node_get(np);
* Unmerged path drivers/net/phy/fixed_phy.c
