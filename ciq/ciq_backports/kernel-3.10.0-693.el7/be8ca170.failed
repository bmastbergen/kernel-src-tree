KVM: x86: Introducing kvm_x86_ops.apicv_post_state_restore

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
commit be8ca170edf342cc45ae4a6431ef192e5cbe211e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/be8ca170.failed

Adding kvm_x86_ops hooks to allow APICv to do post state restore.
This is required to support VM save and restore feature.

	Signed-off-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit be8ca170edf342cc45ae4a6431ef192e5cbe211e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
#	arch/x86/kvm/svm.c
diff --cc arch/x86/kvm/lapic.c
index 47c6b9ccd177,539675c6daa2..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -2010,15 -1957,17 +2010,21 @@@ int kvm_apic_set_state(struct kvm_vcpu 
  	update_divide_count(apic);
  	start_apic_timer(apic);
  	apic->irr_pending = true;
 -	apic->isr_count = vcpu->arch.apicv_active ?
 +	apic->isr_count = kvm_x86_ops->hwapic_isr_update ?
  				1 : count_vectors(apic->regs + APIC_ISR);
  	apic->highest_isr_cache = -1;
++<<<<<<< HEAD
 +	if (kvm_x86_ops->hwapic_irr_update)
++=======
+ 	if (vcpu->arch.apicv_active) {
+ 		if (kvm_x86_ops->apicv_post_state_restore)
+ 			kvm_x86_ops->apicv_post_state_restore(vcpu);
++>>>>>>> be8ca170edf3 (KVM: x86: Introducing kvm_x86_ops.apicv_post_state_restore)
  		kvm_x86_ops->hwapic_irr_update(vcpu,
  				apic_find_highest_irr(apic));
 +	if (unlikely(kvm_x86_ops->hwapic_isr_update))
  		kvm_x86_ops->hwapic_isr_update(vcpu->kvm,
  				apic_find_highest_isr(apic));
 -	}
  	kvm_make_request(KVM_REQ_EVENT, vcpu);
  	if (ioapic_in_kernel(vcpu->kvm))
  		kvm_rtc_eoi_tracking_restore_one(vcpu);
diff --cc arch/x86/kvm/svm.c
index b645837920e7,8c85b8ee68b6..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -4307,9 -4917,13 +4316,15 @@@ static struct kvm_x86_ops svm_x86_ops 
  	.enable_irq_window = enable_irq_window,
  	.update_cr8_intercept = update_cr8_intercept,
  	.set_virtual_x2apic_mode = svm_set_virtual_x2apic_mode,
 -	.get_enable_apicv = svm_get_enable_apicv,
 -	.refresh_apicv_exec_ctrl = svm_refresh_apicv_exec_ctrl,
 +	.cpu_uses_apicv = svm_cpu_uses_apicv,
  	.load_eoi_exitmap = svm_load_eoi_exitmap,
  	.sync_pir_to_irr = svm_sync_pir_to_irr,
++<<<<<<< HEAD
++=======
+ 	.hwapic_irr_update = svm_hwapic_irr_update,
+ 	.hwapic_isr_update = svm_hwapic_isr_update,
+ 	.apicv_post_state_restore = avic_post_state_restore,
++>>>>>>> be8ca170edf3 (KVM: x86: Introducing kvm_x86_ops.apicv_post_state_restore)
  
  	.set_tss_addr = svm_set_tss_addr,
  	.get_tdp_level = get_npt_level,
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index e9b71b8ce24b..32c478afa138 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -893,6 +893,7 @@ struct kvm_x86_ops {
 	void (*post_block)(struct kvm_vcpu *vcpu);
 	int (*update_pi_irte)(struct kvm *kvm, unsigned int host_irq,
 			      uint32_t guest_irq, bool set);
+	void (*apicv_post_state_restore)(struct kvm_vcpu *vcpu);
 };
 
 struct kvm_arch_async_pf {
* Unmerged path arch/x86/kvm/lapic.c
* Unmerged path arch/x86/kvm/svm.c
