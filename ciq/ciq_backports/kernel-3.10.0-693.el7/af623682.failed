nfp: add very basic access to NSP logs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit af623682ac2eba96769f9ba2270438c1f9438d7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/af623682.failed

Allow dumping "arm.diag" resource with ethtool -w.  This resource
should contain a text log of the NSP (control processor) application.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit af623682ac2eba96769f9ba2270438c1f9438d7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net.h
#	drivers/net/ethernet/netronome/nfp/nfpcore/nfp.h
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net.h
index aecadca0b473,e614a376b595..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@@ -467,6 -492,9 +467,12 @@@ static inline bool nfp_net_fw_ver_eq(st
   * @tx_bar:             Pointer to mapped TX queues
   * @rx_bar:             Pointer to mapped FL/RX queues
   * @debugfs_dir:	Device directory in debugfs
++<<<<<<< HEAD
++=======
+  * @ethtool_dump_flag:	Ethtool dump flag
+  * @port_list:		Entry on device port list
+  * @cpp:		CPP device handle if available
++>>>>>>> af623682ac2e (nfp: add very basic access to NSP logs)
   */
  struct nfp_net {
  	struct pci_dev *pdev;
@@@ -558,6 -580,18 +564,21 @@@
  	u8 __iomem *rx_bar;
  
  	struct dentry *debugfs_dir;
++<<<<<<< HEAD
++=======
+ 	u32 ethtool_dump_flag;
+ 
+ 	struct list_head port_list;
+ 
+ 	struct nfp_cpp *cpp;
+ };
+ 
+ struct nfp_net_ring_set {
+ 	unsigned int n_rings;
+ 	unsigned int mtu;
+ 	unsigned int dcnt;
+ 	void *rings;
++>>>>>>> af623682ac2e (nfp: add very basic access to NSP logs)
  };
  
  /* Functions to read/write from/to a BAR
* Unmerged path drivers/net/ethernet/netronome/nfp/nfpcore/nfp.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net.h
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c b/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
index 2ec44232cd0b..41360854ec27 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_ethtool.c
@@ -50,6 +50,10 @@
 #include "nfp_net_ctrl.h"
 #include "nfp_net.h"
 
+enum nfp_dump_diag {
+	NFP_DUMP_NSP_DIAG = 0,
+};
+
 /* Support for stats. Returns netdev, driver, and device stats */
 enum { NETDEV_ET_STATS, NFP_NET_DRV_ET_STATS, NFP_NET_DEV_ET_STATS };
 struct _nfp_net_et_stats {
@@ -524,6 +528,75 @@ static int nfp_net_get_coalesce(struct net_device *netdev,
 	return 0;
 }
 
+/* Other debug dumps
+ */
+static int
+nfp_dump_nsp_diag(struct nfp_net *nn, struct ethtool_dump *dump, void *buffer)
+{
+	struct nfp_resource *res;
+	int ret;
+
+	if (!nn->cpp)
+		return -EOPNOTSUPP;
+
+	dump->version = 1;
+	dump->flag = NFP_DUMP_NSP_DIAG;
+
+	res = nfp_resource_acquire(nn->cpp, NFP_RESOURCE_NSP_DIAG);
+	if (IS_ERR(res))
+		return PTR_ERR(res);
+
+	if (buffer) {
+		if (dump->len != nfp_resource_size(res)) {
+			ret = -EINVAL;
+			goto exit_release;
+		}
+
+		ret = nfp_cpp_read(nn->cpp, nfp_resource_cpp_id(res),
+				   nfp_resource_address(res),
+				   buffer, dump->len);
+		if (ret != dump->len)
+			ret = ret < 0 ? ret : -EIO;
+		else
+			ret = 0;
+	} else {
+		dump->len = nfp_resource_size(res);
+		ret = 0;
+	}
+exit_release:
+	nfp_resource_release(res);
+
+	return ret;
+}
+
+static int nfp_net_set_dump(struct net_device *netdev, struct ethtool_dump *val)
+{
+	struct nfp_net *nn = netdev_priv(netdev);
+
+	if (!nn->cpp)
+		return -EOPNOTSUPP;
+
+	if (val->flag != NFP_DUMP_NSP_DIAG)
+		return -EINVAL;
+
+	nn->ethtool_dump_flag = val->flag;
+
+	return 0;
+}
+
+static int
+nfp_net_get_dump_flag(struct net_device *netdev, struct ethtool_dump *dump)
+{
+	return nfp_dump_nsp_diag(netdev_priv(netdev), dump, NULL);
+}
+
+static int
+nfp_net_get_dump_data(struct net_device *netdev, struct ethtool_dump *dump,
+		      void *buffer)
+{
+	return nfp_dump_nsp_diag(netdev_priv(netdev), dump, buffer);
+}
+
 static int nfp_net_set_coalesce(struct net_device *netdev,
 				struct ethtool_coalesce *ec)
 {
@@ -633,6 +706,9 @@ static const struct ethtool_ops nfp_net_ethtool_ops = {
 	.set_rxfh		= nfp_net_set_rxfh,
 	.get_regs_len		= nfp_net_get_regs_len,
 	.get_regs		= nfp_net_get_regs,
+	.set_dump		= nfp_net_set_dump,
+	.get_dump_flag		= nfp_net_get_dump_flag,
+	.get_dump_data		= nfp_net_get_dump_data,
 	.get_coalesce           = nfp_net_get_coalesce,
 	.set_coalesce           = nfp_net_set_coalesce,
 	.get_channels		= nfp_net_get_channels,
* Unmerged path drivers/net/ethernet/netronome/nfp/nfpcore/nfp.h
