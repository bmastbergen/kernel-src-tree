mmc: sd: Meet alignment requirements for raw_ssr DMA

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mmc] sd: Meet alignment requirements for raw_ssr DMA (Don Zickus) [1430497]
Rebuild_FUZZ: 94.95%
commit-author Paul Burton <paul.burton@imgtec.com>
commit e85baa8868b016513c0f5738362402495b1a66a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e85baa88.failed

The mmc_read_ssr() function results in DMA to the raw_ssr member of
struct mmc_card, which is not guaranteed to be cache line aligned & thus
might not meet the requirements set out in Documentation/DMA-API.txt:

  Warnings:  Memory coherency operates at a granularity called the cache
  line width.  In order for memory mapped by this API to operate
  correctly, the mapped region must begin exactly on a cache line
  boundary and end exactly on one (to prevent two separately mapped
  regions from sharing a single cache line).  Since the cache line size
  may not be known at compile time, the API will not enforce this
  requirement.  Therefore, it is recommended that driver writers who
  don't take special care to determine the cache line size at run time
  only map virtual regions that begin and end on page boundaries (which
  are guaranteed also to be cache line boundaries).

On some systems where DMA is non-coherent this can lead to us losing
data that shares cache lines with the raw_ssr array.

Fix this by kmalloc'ing a temporary buffer to perform DMA into. kmalloc
will ensure the buffer is suitably aligned, allowing the DMA to be
performed without any loss of data.

	Signed-off-by: Paul Burton <paul.burton@imgtec.com>
Fixes: 5275a652d296 ("mmc: sd: Export SD Status via “ssr” device attribute")
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit e85baa8868b016513c0f5738362402495b1a66a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/core/sd.c
diff --cc drivers/mmc/core/sd.c
index b8b30a10066d,a614f37faf27..000000000000
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@@ -223,8 -223,8 +223,13 @@@ static int mmc_decode_scr(struct mmc_ca
  static int mmc_read_ssr(struct mmc_card *card)
  {
  	unsigned int au, es, et, eo;
++<<<<<<< HEAD
 +	int err, i;
 +	u32 *ssr;
++=======
+ 	u32 *raw_ssr;
+ 	int i;
++>>>>>>> e85baa8868b0 (mmc: sd: Meet alignment requirements for raw_ssr DMA)
  
  	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
  		pr_warn("%s: card lacks mandatory SD Status function\n",
@@@ -232,20 -232,21 +237,38 @@@
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	ssr = kmalloc(64, GFP_KERNEL);
 +	if (!ssr)
 +		return -ENOMEM;
 +
 +	err = mmc_app_sd_status(card, ssr);
 +	if (err) {
 +		pr_warn("%s: problem reading SD Status register\n",
 +			mmc_hostname(card->host));
 +		err = 0;
 +		goto out;
 +	}
 +
 +	for (i = 0; i < 16; i++)
 +		ssr[i] = be32_to_cpu(ssr[i]);
++=======
+ 	raw_ssr = kmalloc(sizeof(card->raw_ssr), GFP_KERNEL);
+ 	if (!raw_ssr)
+ 		return -ENOMEM;
+ 
+ 	if (mmc_app_sd_status(card, raw_ssr)) {
+ 		pr_warn("%s: problem reading SD Status register\n",
+ 			mmc_hostname(card->host));
+ 		kfree(raw_ssr);
+ 		return 0;
+ 	}
+ 
+ 	for (i = 0; i < 16; i++)
+ 		card->raw_ssr[i] = be32_to_cpu(raw_ssr[i]);
+ 
+ 	kfree(raw_ssr);
++>>>>>>> e85baa8868b0 (mmc: sd: Meet alignment requirements for raw_ssr DMA)
  
  	/*
  	 * UNSTUFF_BITS only works with four u32s so we have to offset the
* Unmerged path drivers/mmc/core/sd.c
