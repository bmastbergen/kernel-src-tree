sched: Move p->nr_cpus_allowed check to select_task_rq()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Wanpeng Li <wanpeng.li@linux.intel.com>
commit 6c1d9410f007a26d13173cf17204cfd965f49b83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6c1d9410.failed

Move the p->nr_cpus_allowed check into kernel/sched/core.c: select_task_rq().
This change will make fair.c, rt.c, and deadline.c all start with the
same logic.

Suggested-and-Acked-by: Steven Rostedt <rostedt@goodmis.org>
	Signed-off-by: Wanpeng Li <wanpeng.li@linux.intel.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: "pang.xunlei" <pang.xunlei@linaro.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
Link: http://lkml.kernel.org/r/1415150077-59053-1-git-send-email-wanpeng.li@linux.intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 6c1d9410f007a26d13173cf17204cfd965f49b83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/fair.c
diff --cc kernel/sched/fair.c
index 163712a85701,8bca292f0803..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -4487,14 -4730,8 +4487,19 @@@ select_task_rq_fair(struct task_struct 
  	int want_affine = 0;
  	int sync = wake_flags & WF_SYNC;
  
++<<<<<<< HEAD
 +	if (p->nr_cpus_allowed == 1)
 +		return prev_cpu;
 +
 +	if (sd_flag & SD_BALANCE_WAKE) {
 +		if (cpumask_test_cpu(cpu, tsk_cpus_allowed(p)))
 +			want_affine = 1;
 +		new_cpu = prev_cpu;
 +	}
++=======
+ 	if (sd_flag & SD_BALANCE_WAKE)
+ 		want_affine = cpumask_test_cpu(cpu, tsk_cpus_allowed(p));
++>>>>>>> 6c1d9410f007 (sched: Move p->nr_cpus_allowed check to select_task_rq())
  
  	rcu_read_lock();
  	for_each_domain(cpu, tmp) {
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 8dcc6799195b..b627821df21e 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -1446,7 +1446,8 @@ out:
 static inline
 int select_task_rq(struct task_struct *p, int cpu, int sd_flags, int wake_flags)
 {
-	cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);
+	if (p->nr_cpus_allowed > 1)
+		cpu = p->sched_class->select_task_rq(p, cpu, sd_flags, wake_flags);
 
 	/*
 	 * In order not to call set_task_cpu() on a blocking task we need
diff --git a/kernel/sched/deadline.c b/kernel/sched/deadline.c
index 4913e4fed8f8..9badc0c88645 100644
--- a/kernel/sched/deadline.c
+++ b/kernel/sched/deadline.c
@@ -970,9 +970,6 @@ select_task_rq_dl(struct task_struct *p, int cpu, int sd_flag, int flags)
 	struct task_struct *curr;
 	struct rq *rq;
 
-	if (p->nr_cpus_allowed == 1)
-		goto out;
-
 	if (sd_flag != SD_BALANCE_WAKE)
 		goto out;
 
* Unmerged path kernel/sched/fair.c
diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c
index 12441ec4210e..8f2e5d78fd8c 100644
--- a/kernel/sched/rt.c
+++ b/kernel/sched/rt.c
@@ -1220,9 +1220,6 @@ select_task_rq_rt(struct task_struct *p, int cpu, int sd_flag, int flags)
 	struct task_struct *curr;
 	struct rq *rq;
 
-	if (p->nr_cpus_allowed == 1)
-		goto out;
-
 	/* For anything but wake ups, just return the task_cpu */
 	if (sd_flag != SD_BALANCE_WAKE && sd_flag != SD_BALANCE_FORK)
 		goto out;
