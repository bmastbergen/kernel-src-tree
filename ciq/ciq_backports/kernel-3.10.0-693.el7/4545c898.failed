x86: introduce kaslr_offset()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] introduce kaslr_offset() (Baoquan He) [1290840]
Rebuild_FUZZ: 90.57%
commit-author Jiri Kosina <jkosina@suse.cz>
commit 4545c89880138b30a868159bc1b209867b8a5f32
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4545c898.failed

Offset that has been chosen for kaslr during kernel decompression can be
easily computed as a difference between _text and __START_KERNEL. We are
already making use of this in dump_kernel_offset() notifier and in
arch_crash_save_vmcoreinfo().

Introduce kaslr_offset() that makes this computation instead of hard-coding
it, so that other kernel code (such as live patching) can make use of it.
Also convert existing users to make use of it.

This patch is equivalent transofrmation without any effects on the resulting
code:

	$ diff -u vmlinux.old.asm vmlinux.new.asm
	--- vmlinux.old.asm     2015-04-28 17:55:19.520983368 +0200
	+++ vmlinux.new.asm     2015-04-28 17:55:24.141206072 +0200
	@@ -1,5 +1,5 @@

	-vmlinux.old:     file format elf64-x86-64
	+vmlinux.new:     file format elf64-x86-64

	Disassembly of section .text:
	$

	Acked-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 4545c89880138b30a868159bc1b209867b8a5f32)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/setup.h
#	arch/x86/kernel/setup.c
diff --cc arch/x86/include/asm/setup.h
index b704295f0650,785ac2f27271..000000000000
--- a/arch/x86/include/asm/setup.h
+++ b/arch/x86/include/asm/setup.h
@@@ -67,7 -65,18 +67,21 @@@ static inline void x86_ce4100_early_set
   * This is set up by the setup-routine at boot-time
   */
  extern struct boot_params boot_params;
+ extern char _text[];
  
++<<<<<<< HEAD
++=======
+ static inline bool kaslr_enabled(void)
+ {
+ 	return !!(boot_params.hdr.loadflags & KASLR_FLAG);
+ }
+ 
+ static inline unsigned long kaslr_offset(void)
+ {
+ 	return (unsigned long)&_text - __START_KERNEL;
+ }
+ 
++>>>>>>> 4545c8988013 (x86: introduce kaslr_offset())
  /*
   * Do NOT EVER look at the BIOS memory size location.
   * It does not work on many machines.
diff --cc arch/x86/kernel/setup.c
index 7c228560d4bb,5056d3cfe266..000000000000
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@@ -934,10 -832,15 +934,22 @@@ static void rh_check_supported(void
  static int
  dump_kernel_offset(struct notifier_block *self, unsigned long v, void *p)
  {
++<<<<<<< HEAD
 +	pr_emerg("Kernel Offset: 0x%lx from 0x%lx "
 +		 "(relocation range: 0x%lx-0x%lx)\n",
 +		 (unsigned long)&_text - __START_KERNEL, __START_KERNEL,
 +		 __START_KERNEL_map, MODULES_VADDR-1);
++=======
+ 	if (kaslr_enabled()) {
+ 		pr_emerg("Kernel Offset: 0x%lx from 0x%lx (relocation range: 0x%lx-0x%lx)\n",
+ 			 kaslr_offset(),
+ 			 __START_KERNEL,
+ 			 __START_KERNEL_map,
+ 			 MODULES_VADDR-1);
+ 	} else {
+ 		pr_emerg("Kernel Offset: disabled\n");
+ 	}
++>>>>>>> 4545c8988013 (x86: introduce kaslr_offset())
  
  	return 0;
  }
* Unmerged path arch/x86/include/asm/setup.h
diff --git a/arch/x86/kernel/machine_kexec_64.c b/arch/x86/kernel/machine_kexec_64.c
index 485981059a40..c319aee4fc8b 100644
--- a/arch/x86/kernel/machine_kexec_64.c
+++ b/arch/x86/kernel/machine_kexec_64.c
@@ -24,6 +24,7 @@
 #include <asm/mmu_context.h>
 #include <asm/debugreg.h>
 #include <asm/kexec-bzimage64.h>
+#include <asm/setup.h>
 
 #ifdef CONFIG_KEXEC_FILE
 static struct kexec_file_ops *kexec_file_loaders[] = {
@@ -333,7 +334,7 @@ void arch_crash_save_vmcoreinfo(void)
 	VMCOREINFO_LENGTH(node_data, MAX_NUMNODES);
 #endif
 	vmcoreinfo_append_str("KERNELOFFSET=%lx\n",
-			      (unsigned long)&_text - __START_KERNEL);
+			      kaslr_offset());
 }
 
 /* arch-dependent functionality related to kexec file-based syscall */
* Unmerged path arch/x86/kernel/setup.c
