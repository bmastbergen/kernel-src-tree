ovl: update atime on upper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit d719e8f268fa4f9944b24b60814da9017dfb7787
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d719e8f2.failed

Fix atime update logic in overlayfs.

This patch adds an i_op->update_time() handler to overlayfs inodes.  This
forwards atime updates to the upper layer only.  No atime updates are done
on lower layers.

Remove implicit atime updates to underlying files and directories with
O_NOATIME.  Remove explicit atime update in ovl_readlink().

Clear atime related mnt flags from cloned upper mount.  This means atime
updates are controlled purely by overlayfs mount options.

	Reported-by: Konstantin Khlebnikov <koct9i@gmail.com> 
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
(cherry picked from commit d719e8f268fa4f9944b24b60814da9017dfb7787)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/dir.c
#	fs/overlayfs/inode.c
diff --cc fs/overlayfs/dir.c
index 8a9cb79d9d70,b4eac8173f93..000000000000
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@@ -1062,11 -938,10 +1062,15 @@@ const struct inode_operations_wrapper o
  	.mknod		= ovl_mknod,
  	.permission	= ovl_permission,
  	.getattr	= ovl_dir_getattr,
 -	.setxattr	= ovl_setxattr,
 +	.setxattr	= generic_setxattr,
  	.getxattr	= ovl_getxattr,
  	.listxattr	= ovl_listxattr,
 -	.removexattr	= ovl_removexattr,
 +	.removexattr	= generic_removexattr,
  	.get_acl	= ovl_get_acl,
++<<<<<<< HEAD
 +	},
 +	.rename2	= ovl_rename2,
++=======
+ 	.update_time	= ovl_update_time,
++>>>>>>> d719e8f268fa (ovl: update atime on upper)
  };
diff --cc fs/overlayfs/inode.c
index 2e733e855f5b,041db9c6621c..000000000000
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@@ -376,36 -365,66 +374,77 @@@ int ovl_open_maybe_copy_up(struct dentr
  	return err;
  }
  
++<<<<<<< HEAD
 +static const struct inode_operations_wrapper ovl_file_inode_operations = {
 +	.ops = {
++=======
+ int ovl_update_time(struct inode *inode, struct timespec *ts, int flags)
+ {
+ 	struct dentry *alias;
+ 	struct path upperpath;
+ 
+ 	if (!(flags & S_ATIME))
+ 		return 0;
+ 
+ 	alias = d_find_any_alias(inode);
+ 	if (!alias)
+ 		return 0;
+ 
+ 	ovl_path_upper(alias, &upperpath);
+ 	if (upperpath.dentry) {
+ 		touch_atime(&upperpath);
+ 		inode->i_atime = d_inode(upperpath.dentry)->i_atime;
+ 	}
+ 
+ 	dput(alias);
+ 
+ 	return 0;
+ }
+ 
+ static const struct inode_operations ovl_file_inode_operations = {
++>>>>>>> d719e8f268fa (ovl: update atime on upper)
  	.setattr	= ovl_setattr,
  	.permission	= ovl_permission,
  	.getattr	= ovl_getattr,
 -	.setxattr	= ovl_setxattr,
 +	.setxattr	= generic_setxattr,
  	.getxattr	= ovl_getxattr,
  	.listxattr	= ovl_listxattr,
 -	.removexattr	= ovl_removexattr,
 +	.removexattr	= generic_removexattr,
  	.get_acl	= ovl_get_acl,
++<<<<<<< HEAD
 +	},
++=======
+ 	.update_time	= ovl_update_time,
++>>>>>>> d719e8f268fa (ovl: update atime on upper)
  };
  
  static const struct inode_operations ovl_symlink_inode_operations = {
  	.setattr	= ovl_setattr,
 -	.get_link	= ovl_get_link,
 +	.follow_link	= ovl_follow_link,
 +	.put_link	= ovl_put_link,
  	.readlink	= ovl_readlink,
  	.getattr	= ovl_getattr,
 -	.setxattr	= ovl_setxattr,
 +	.setxattr	= generic_setxattr,
  	.getxattr	= ovl_getxattr,
  	.listxattr	= ovl_listxattr,
++<<<<<<< HEAD
 +	.removexattr	= generic_removexattr,
++=======
+ 	.removexattr	= ovl_removexattr,
+ 	.update_time	= ovl_update_time,
++>>>>>>> d719e8f268fa (ovl: update atime on upper)
  };
  
 -struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,
 -			    struct ovl_entry *oe)
 +static void ovl_fill_inode(struct inode *inode, umode_t mode)
  {
 -	struct inode *inode;
 -
 -	inode = new_inode(sb);
 -	if (!inode)
 -		return NULL;
 -
  	inode->i_ino = get_next_ino();
  	inode->i_mode = mode;
++<<<<<<< HEAD
 +	inode->i_flags |= S_NOATIME | S_NOCMTIME;
++=======
+ 	inode->i_flags |= S_NOCMTIME;
+ 	inode->i_private = oe;
++>>>>>>> d719e8f268fa (ovl: update atime on upper)
  
  	mode &= S_IFMT;
  	switch (mode) {
* Unmerged path fs/overlayfs/dir.c
* Unmerged path fs/overlayfs/inode.c
diff --git a/fs/overlayfs/overlayfs.h b/fs/overlayfs/overlayfs.h
index d2c18d8054aa..4b14c6af6900 100644
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@ -190,6 +190,7 @@ ssize_t ovl_getxattr(struct dentry *dentry, const char *name,
 ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
 struct posix_acl *ovl_get_acl(struct inode *inode, int type);
 int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
+int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
 
 struct inode *ovl_new_inode(struct super_block *sb, umode_t mode);
 struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode);
@@ -198,6 +199,9 @@ static inline void ovl_copyattr(struct inode *from, struct inode *to)
 	to->i_uid = from->i_uid;
 	to->i_gid = from->i_gid;
 	to->i_mode = from->i_mode;
+	to->i_atime = from->i_atime;
+	to->i_mtime = from->i_mtime;
+	to->i_ctime = from->i_ctime;
 }
 
 /* dir.c */
diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c
index fbd72a932315..b2b66ce0d19a 100644
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -619,7 +619,7 @@ out:
 
 struct file *ovl_path_open(struct path *path, int flags)
 {
-	return dentry_open(path, flags, current_cred());
+	return dentry_open(path, flags | O_NOATIME, current_cred());
 }
 
 static void ovl_put_super(struct super_block *sb)
@@ -1202,6 +1202,10 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 			pr_err("overlayfs: failed to clone upperpath\n");
 			goto out_put_lowerpath;
 		}
+		/* Don't inherit atime flags */
+		ufs->upper_mnt->mnt_flags &= ~(MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME);
+
+		sb->s_time_gran = ufs->upper_mnt->mnt_sb->s_time_gran;
 
 		ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
 		err = PTR_ERR(ufs->workdir);
@@ -1250,7 +1254,7 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)
 		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 		 * will fail instead of modifying lower fs.
 		 */
-		mnt->mnt_flags |= MNT_READONLY;
+		mnt->mnt_flags |= MNT_READONLY | MNT_NOATIME;
 
 		ufs->lower_mnt[ufs->numlower] = mnt;
 		ufs->numlower++;
