fs: try to clone files first in vfs_copy_file_range

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] try to clone files first in vfs_copy_file_range (Steve Dickson) [1356123]
Rebuild_FUZZ: 95.92%
commit-author Christoph Hellwig <hch@lst.de>
commit a76b5b04375f974579c83433b06466758c0c552c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a76b5b04.failed

A clone is a perfectly fine implementation of a file copy, so most
file systems just implement the copy that way.  Instead of duplicating
this logic move it to the VFS.  Currently btrfs and XFS implement copies
the same way as clones and there is no behavior change for them, cifs
only implements clones and grow support for copy_file_range with this
patch.  NFS implements both, so this will allow copy_file_range to work
on servers that only implement CLONE and be lot more efficient on servers
that implements CLONE and COPY.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit a76b5b04375f974579c83433b06466758c0c552c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/ctree.h
#	fs/btrfs/file.c
#	fs/btrfs/ioctl.c
#	fs/read_write.c
#	fs/xfs/xfs_file.c
diff --cc fs/btrfs/ctree.h
index 3f31d6850aec,05f75a949af4..000000000000
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@@ -4054,6 -3232,8 +4054,11 @@@ int btrfs_dirty_pages(struct btrfs_roo
  		      loff_t pos, size_t write_bytes,
  		      struct extent_state **cached);
  int btrfs_fdatawrite_range(struct inode *inode, loff_t start, loff_t end);
++<<<<<<< HEAD
++=======
+ int btrfs_clone_file_range(struct file *file_in, loff_t pos_in,
+ 			   struct file *file_out, loff_t pos_out, u64 len);
++>>>>>>> a76b5b04375f (fs: try to clone files first in vfs_copy_file_range)
  
  /* tree-defrag.c */
  int btrfs_defrag_leaves(struct btrfs_trans_handle *trans,
diff --cc fs/btrfs/file.c
index 8cf385cc7c91,991cc991fd29..000000000000
--- a/fs/btrfs/file.c
+++ b/fs/btrfs/file.c
@@@ -2960,8 -2996,10 +2960,13 @@@ const struct file_operations btrfs_file
  	.fallocate	= btrfs_fallocate,
  	.unlocked_ioctl	= btrfs_ioctl,
  #ifdef CONFIG_COMPAT
 -	.compat_ioctl	= btrfs_compat_ioctl,
 +	.compat_ioctl	= btrfs_ioctl,
  #endif
++<<<<<<< HEAD
++=======
+ 	.clone_file_range = btrfs_clone_file_range,
+ 	.dedupe_file_range = btrfs_dedupe_file_range,
++>>>>>>> a76b5b04375f (fs: try to clone files first in vfs_copy_file_range)
  };
  
  void btrfs_auto_defrag_exit(void)
diff --cc fs/btrfs/ioctl.c
index 4557a0834a64,dab746298758..000000000000
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@@ -4009,14 -3980,10 +4009,21 @@@ out_drop_write
  	return ret;
  }
  
++<<<<<<< HEAD
 +static long btrfs_ioctl_clone_range(struct file *file, void __user *argp)
 +{
 +	struct btrfs_ioctl_clone_range_args args;
 +
 +	if (copy_from_user(&args, argp, sizeof(args)))
 +		return -EFAULT;
 +	return btrfs_ioctl_clone(file, args.src_fd, args.src_offset,
 +				 args.src_length, args.dest_offset);
++=======
+ int btrfs_clone_file_range(struct file *src_file, loff_t off,
+ 		struct file *dst_file, loff_t destoff, u64 len)
+ {
+ 	return btrfs_clone_files(dst_file, src_file, off, len, destoff);
++>>>>>>> a76b5b04375f (fs: try to clone files first in vfs_copy_file_range)
  }
  
  /*
diff --cc fs/read_write.c
index b7e6d43449bd,6674a4b83c54..000000000000
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@@ -1328,3 -1501,322 +1328,325 @@@ COMPAT_SYSCALL_DEFINE4(sendfile64, int
  	return do_sendfile(out_fd, in_fd, NULL, count, 0);
  }
  #endif
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * copy_file_range() differs from regular file read and write in that it
+  * specifically allows return partial success.  When it does so is up to
+  * the copy_file_range method.
+  */
+ ssize_t vfs_copy_file_range(struct file *file_in, loff_t pos_in,
+ 			    struct file *file_out, loff_t pos_out,
+ 			    size_t len, unsigned int flags)
+ {
+ 	struct inode *inode_in = file_inode(file_in);
+ 	struct inode *inode_out = file_inode(file_out);
+ 	ssize_t ret;
+ 
+ 	if (flags != 0)
+ 		return -EINVAL;
+ 
+ 	ret = rw_verify_area(READ, file_in, &pos_in, len);
+ 	if (unlikely(ret))
+ 		return ret;
+ 
+ 	ret = rw_verify_area(WRITE, file_out, &pos_out, len);
+ 	if (unlikely(ret))
+ 		return ret;
+ 
+ 	if (!(file_in->f_mode & FMODE_READ) ||
+ 	    !(file_out->f_mode & FMODE_WRITE) ||
+ 	    (file_out->f_flags & O_APPEND))
+ 		return -EBADF;
+ 
+ 	/* this could be relaxed once a method supports cross-fs copies */
+ 	if (inode_in->i_sb != inode_out->i_sb)
+ 		return -EXDEV;
+ 
+ 	if (len == 0)
+ 		return 0;
+ 
+ 	ret = mnt_want_write_file(file_out);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/*
+ 	 * Try cloning first, this is supported by more file systems, and
+ 	 * more efficient if both clone and copy are supported (e.g. NFS).
+ 	 */
+ 	if (file_in->f_op->clone_file_range) {
+ 		ret = file_in->f_op->clone_file_range(file_in, pos_in,
+ 				file_out, pos_out, len);
+ 		if (ret == 0) {
+ 			ret = len;
+ 			goto done;
+ 		}
+ 	}
+ 
+ 	if (file_out->f_op->copy_file_range) {
+ 		ret = file_out->f_op->copy_file_range(file_in, pos_in, file_out,
+ 						      pos_out, len, flags);
+ 		if (ret != -EOPNOTSUPP)
+ 			goto done;
+ 	}
+ 
+ 	ret = do_splice_direct(file_in, &pos_in, file_out, &pos_out,
+ 			len > MAX_RW_COUNT ? MAX_RW_COUNT : len, 0);
+ 
+ done:
+ 	if (ret > 0) {
+ 		fsnotify_access(file_in);
+ 		add_rchar(current, ret);
+ 		fsnotify_modify(file_out);
+ 		add_wchar(current, ret);
+ 	}
+ 
+ 	inc_syscr(current);
+ 	inc_syscw(current);
+ 
+ 	mnt_drop_write_file(file_out);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL(vfs_copy_file_range);
+ 
+ SYSCALL_DEFINE6(copy_file_range, int, fd_in, loff_t __user *, off_in,
+ 		int, fd_out, loff_t __user *, off_out,
+ 		size_t, len, unsigned int, flags)
+ {
+ 	loff_t pos_in;
+ 	loff_t pos_out;
+ 	struct fd f_in;
+ 	struct fd f_out;
+ 	ssize_t ret = -EBADF;
+ 
+ 	f_in = fdget(fd_in);
+ 	if (!f_in.file)
+ 		goto out2;
+ 
+ 	f_out = fdget(fd_out);
+ 	if (!f_out.file)
+ 		goto out1;
+ 
+ 	ret = -EFAULT;
+ 	if (off_in) {
+ 		if (copy_from_user(&pos_in, off_in, sizeof(loff_t)))
+ 			goto out;
+ 	} else {
+ 		pos_in = f_in.file->f_pos;
+ 	}
+ 
+ 	if (off_out) {
+ 		if (copy_from_user(&pos_out, off_out, sizeof(loff_t)))
+ 			goto out;
+ 	} else {
+ 		pos_out = f_out.file->f_pos;
+ 	}
+ 
+ 	ret = vfs_copy_file_range(f_in.file, pos_in, f_out.file, pos_out, len,
+ 				  flags);
+ 	if (ret > 0) {
+ 		pos_in += ret;
+ 		pos_out += ret;
+ 
+ 		if (off_in) {
+ 			if (copy_to_user(off_in, &pos_in, sizeof(loff_t)))
+ 				ret = -EFAULT;
+ 		} else {
+ 			f_in.file->f_pos = pos_in;
+ 		}
+ 
+ 		if (off_out) {
+ 			if (copy_to_user(off_out, &pos_out, sizeof(loff_t)))
+ 				ret = -EFAULT;
+ 		} else {
+ 			f_out.file->f_pos = pos_out;
+ 		}
+ 	}
+ 
+ out:
+ 	fdput(f_out);
+ out1:
+ 	fdput(f_in);
+ out2:
+ 	return ret;
+ }
+ 
+ static int clone_verify_area(struct file *file, loff_t pos, u64 len, bool write)
+ {
+ 	struct inode *inode = file_inode(file);
+ 
+ 	if (unlikely(pos < 0))
+ 		return -EINVAL;
+ 
+ 	 if (unlikely((loff_t) (pos + len) < 0))
+ 		return -EINVAL;
+ 
+ 	if (unlikely(inode->i_flctx && mandatory_lock(inode))) {
+ 		loff_t end = len ? pos + len - 1 : OFFSET_MAX;
+ 		int retval;
+ 
+ 		retval = locks_mandatory_area(inode, file, pos, end,
+ 				write ? F_WRLCK : F_RDLCK);
+ 		if (retval < 0)
+ 			return retval;
+ 	}
+ 
+ 	return security_file_permission(file, write ? MAY_WRITE : MAY_READ);
+ }
+ 
+ int vfs_clone_file_range(struct file *file_in, loff_t pos_in,
+ 		struct file *file_out, loff_t pos_out, u64 len)
+ {
+ 	struct inode *inode_in = file_inode(file_in);
+ 	struct inode *inode_out = file_inode(file_out);
+ 	int ret;
+ 
+ 	if (inode_in->i_sb != inode_out->i_sb ||
+ 	    file_in->f_path.mnt != file_out->f_path.mnt)
+ 		return -EXDEV;
+ 
+ 	if (S_ISDIR(inode_in->i_mode) || S_ISDIR(inode_out->i_mode))
+ 		return -EISDIR;
+ 	if (!S_ISREG(inode_in->i_mode) || !S_ISREG(inode_out->i_mode))
+ 		return -EINVAL;
+ 
+ 	if (!(file_in->f_mode & FMODE_READ) ||
+ 	    !(file_out->f_mode & FMODE_WRITE) ||
+ 	    (file_out->f_flags & O_APPEND))
+ 		return -EBADF;
+ 
+ 	if (!file_in->f_op->clone_file_range)
+ 		return -EOPNOTSUPP;
+ 
+ 	ret = clone_verify_area(file_in, pos_in, len, false);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = clone_verify_area(file_out, pos_out, len, true);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (pos_in + len > i_size_read(inode_in))
+ 		return -EINVAL;
+ 
+ 	ret = mnt_want_write_file(file_out);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = file_in->f_op->clone_file_range(file_in, pos_in,
+ 			file_out, pos_out, len);
+ 	if (!ret) {
+ 		fsnotify_access(file_in);
+ 		fsnotify_modify(file_out);
+ 	}
+ 
+ 	mnt_drop_write_file(file_out);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(vfs_clone_file_range);
+ 
+ int vfs_dedupe_file_range(struct file *file, struct file_dedupe_range *same)
+ {
+ 	struct file_dedupe_range_info *info;
+ 	struct inode *src = file_inode(file);
+ 	u64 off;
+ 	u64 len;
+ 	int i;
+ 	int ret;
+ 	bool is_admin = capable(CAP_SYS_ADMIN);
+ 	u16 count = same->dest_count;
+ 	struct file *dst_file;
+ 	loff_t dst_off;
+ 	ssize_t deduped;
+ 
+ 	if (!(file->f_mode & FMODE_READ))
+ 		return -EINVAL;
+ 
+ 	if (same->reserved1 || same->reserved2)
+ 		return -EINVAL;
+ 
+ 	off = same->src_offset;
+ 	len = same->src_length;
+ 
+ 	ret = -EISDIR;
+ 	if (S_ISDIR(src->i_mode))
+ 		goto out;
+ 
+ 	ret = -EINVAL;
+ 	if (!S_ISREG(src->i_mode))
+ 		goto out;
+ 
+ 	ret = clone_verify_area(file, off, len, false);
+ 	if (ret < 0)
+ 		goto out;
+ 	ret = 0;
+ 
+ 	/* pre-format output fields to sane values */
+ 	for (i = 0; i < count; i++) {
+ 		same->info[i].bytes_deduped = 0ULL;
+ 		same->info[i].status = FILE_DEDUPE_RANGE_SAME;
+ 	}
+ 
+ 	for (i = 0, info = same->info; i < count; i++, info++) {
+ 		struct inode *dst;
+ 		struct fd dst_fd = fdget(info->dest_fd);
+ 
+ 		dst_file = dst_fd.file;
+ 		if (!dst_file) {
+ 			info->status = -EBADF;
+ 			goto next_loop;
+ 		}
+ 		dst = file_inode(dst_file);
+ 
+ 		ret = mnt_want_write_file(dst_file);
+ 		if (ret) {
+ 			info->status = ret;
+ 			goto next_loop;
+ 		}
+ 
+ 		dst_off = info->dest_offset;
+ 		ret = clone_verify_area(dst_file, dst_off, len, true);
+ 		if (ret < 0) {
+ 			info->status = ret;
+ 			goto next_file;
+ 		}
+ 		ret = 0;
+ 
+ 		if (info->reserved) {
+ 			info->status = -EINVAL;
+ 		} else if (!(is_admin || (dst_file->f_mode & FMODE_WRITE))) {
+ 			info->status = -EINVAL;
+ 		} else if (file->f_path.mnt != dst_file->f_path.mnt) {
+ 			info->status = -EXDEV;
+ 		} else if (S_ISDIR(dst->i_mode)) {
+ 			info->status = -EISDIR;
+ 		} else if (dst_file->f_op->dedupe_file_range == NULL) {
+ 			info->status = -EINVAL;
+ 		} else {
+ 			deduped = dst_file->f_op->dedupe_file_range(file, off,
+ 							len, dst_file,
+ 							info->dest_offset);
+ 			if (deduped == -EBADE)
+ 				info->status = FILE_DEDUPE_RANGE_DIFFERS;
+ 			else if (deduped < 0)
+ 				info->status = deduped;
+ 			else
+ 				info->bytes_deduped += deduped;
+ 		}
+ 
+ next_file:
+ 		mnt_drop_write_file(dst_file);
+ next_loop:
+ 		fdput(dst_fd);
+ 
+ 		if (fatal_signal_pending(current))
+ 			goto out;
+ 	}
+ 
+ out:
+ 	return ret;
+ }
+ EXPORT_SYMBOL(vfs_dedupe_file_range);
++>>>>>>> a76b5b04375f (fs: try to clone files first in vfs_copy_file_range)
diff --cc fs/xfs/xfs_file.c
index 815d8f3721f9,86ecc9b49e15..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -1083,6 -909,43 +1083,46 @@@ out_unlock
  	return error;
  }
  
++<<<<<<< HEAD
++=======
+ STATIC int
+ xfs_file_clone_range(
+ 	struct file	*file_in,
+ 	loff_t		pos_in,
+ 	struct file	*file_out,
+ 	loff_t		pos_out,
+ 	u64		len)
+ {
+ 	return xfs_reflink_remap_range(file_in, pos_in, file_out, pos_out,
+ 				     len, false);
+ }
+ 
+ #define XFS_MAX_DEDUPE_LEN	(16 * 1024 * 1024)
+ STATIC ssize_t
+ xfs_file_dedupe_range(
+ 	struct file	*src_file,
+ 	u64		loff,
+ 	u64		len,
+ 	struct file	*dst_file,
+ 	u64		dst_loff)
+ {
+ 	int		error;
+ 
+ 	/*
+ 	 * Limit the total length we will dedupe for each operation.
+ 	 * This is intended to bound the total time spent in this
+ 	 * ioctl to something sane.
+ 	 */
+ 	if (len > XFS_MAX_DEDUPE_LEN)
+ 		len = XFS_MAX_DEDUPE_LEN;
+ 
+ 	error = xfs_reflink_remap_range(src_file, loff, dst_file, dst_loff,
+ 				     len, true);
+ 	if (error)
+ 		return error;
+ 	return len;
+ }
++>>>>>>> a76b5b04375f (fs: try to clone files first in vfs_copy_file_range)
  
  STATIC int
  xfs_file_open(
@@@ -1748,7 -1605,10 +1788,12 @@@ const struct file_operations xfs_file_o
  	.open		= xfs_file_open,
  	.release	= xfs_file_release,
  	.fsync		= xfs_file_fsync,
 -	.get_unmapped_area = thp_get_unmapped_area,
  	.fallocate	= xfs_file_fallocate,
++<<<<<<< HEAD
++=======
+ 	.clone_file_range = xfs_file_clone_range,
+ 	.dedupe_file_range = xfs_file_dedupe_range,
++>>>>>>> a76b5b04375f (fs: try to clone files first in vfs_copy_file_range)
  };
  
  const struct file_operations xfs_dir_file_operations = {
* Unmerged path fs/btrfs/ctree.h
* Unmerged path fs/btrfs/file.c
* Unmerged path fs/btrfs/ioctl.c
* Unmerged path fs/read_write.c
* Unmerged path fs/xfs/xfs_file.c
