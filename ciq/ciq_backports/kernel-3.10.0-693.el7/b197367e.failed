selinux: Inode label revalidation performance fix

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit b197367ed1ba81b0d26f7e7f76f61731ac6e5842
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b197367e.failed

Commit 5d226df4 has introduced a performance regression of about
10% in the UnixBench pipe benchmark.  It turns out that the call
to inode_security in selinux_file_permission can be moved below
the zero-mask test and that inode_security_revalidate can be
removed entirely, which brings us back to roughly the original
performance.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit b197367ed1ba81b0d26f7e7f76f61731ac6e5842)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
diff --cc security/selinux/hooks.c
index 47406b6a55bb,f8110cfd80ff..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -231,6 -242,72 +231,75 @@@ static int inode_alloc_security(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int inode_doinit_with_dentry(struct inode *inode, struct dentry *opt_dentry);
+ 
+ /*
+  * Try reloading inode security labels that have been marked as invalid.  The
+  * @may_sleep parameter indicates when sleeping and thus reloading labels is
+  * allowed; when set to false, returns ERR_PTR(-ECHILD) when the label is
+  * invalid.  The @opt_dentry parameter should be set to a dentry of the inode;
+  * when no dentry is available, set it to NULL instead.
+  */
+ static int __inode_security_revalidate(struct inode *inode,
+ 				       struct dentry *opt_dentry,
+ 				       bool may_sleep)
+ {
+ 	struct inode_security_struct *isec = inode->i_security;
+ 
+ 	might_sleep_if(may_sleep);
+ 
+ 	if (isec->initialized == LABEL_INVALID) {
+ 		if (!may_sleep)
+ 			return -ECHILD;
+ 
+ 		/*
+ 		 * Try reloading the inode security label.  This will fail if
+ 		 * @opt_dentry is NULL and no dentry for this inode can be
+ 		 * found; in that case, continue using the old label.
+ 		 */
+ 		inode_doinit_with_dentry(inode, opt_dentry);
+ 	}
+ 	return 0;
+ }
+ 
+ static struct inode_security_struct *inode_security_novalidate(struct inode *inode)
+ {
+ 	return inode->i_security;
+ }
+ 
+ static struct inode_security_struct *inode_security_rcu(struct inode *inode, bool rcu)
+ {
+ 	int error;
+ 
+ 	error = __inode_security_revalidate(inode, NULL, !rcu);
+ 	if (error)
+ 		return ERR_PTR(error);
+ 	return inode->i_security;
+ }
+ 
+ /*
+  * Get the security label of an inode.
+  */
+ static struct inode_security_struct *inode_security(struct inode *inode)
+ {
+ 	__inode_security_revalidate(inode, NULL, true);
+ 	return inode->i_security;
+ }
+ 
+ /*
+  * Get the security label of a dentry's backing inode.
+  */
+ static struct inode_security_struct *backing_inode_security(struct dentry *dentry)
+ {
+ 	struct inode *inode = d_backing_inode(dentry);
+ 
+ 	__inode_security_revalidate(inode, dentry, true);
+ 	return inode->i_security;
+ }
+ 
++>>>>>>> b197367ed1ba (selinux: Inode label revalidation performance fix)
  static void inode_free_rcu(struct rcu_head *head)
  {
  	struct inode_security_struct *isec;
@@@ -3127,7 -3272,7 +3196,11 @@@ static int selinux_file_permission(stru
  {
  	struct inode *inode = file_inode(file);
  	struct file_security_struct *fsec = file->f_security;
++<<<<<<< HEAD
 +	struct inode_security_struct *isec = inode->i_security;
++=======
+ 	struct inode_security_struct *isec;
++>>>>>>> b197367ed1ba (selinux: Inode label revalidation performance fix)
  	u32 sid = current_sid();
  
  	if (!mask)
* Unmerged path security/selinux/hooks.c
