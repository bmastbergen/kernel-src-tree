scsi: rename SCSI_MAX_{SG, SG_CHAIN}_SEGMENTS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] rename SCSI_MAX_{SG, SG_CHAIN}_SEGMENTS (Don Dutile) [1417284]
Rebuild_FUZZ: 92.86%
commit-author Ming Lin <ming.l@ssi.samsung.com>
commit 65e8617fba17732b4c68d3369a621725838b6f28
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/65e8617f.failed

Rename SCSI_MAX_SG_SEGMENTS to SG_CHUNK_SIZE, which means the amount
we fit into a single scatterlist chunk.

Rename SCSI_MAX_SG_CHAIN_SEGMENTS to SG_MAX_SEGMENTS.

Will move these 2 generic definitions to scatterlist.h later.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Bart Van Assche <bart.vanassche@sandisk.com> (for ib_srp changes)
	Signed-off-by: Ming Lin <ming.l@ssi.samsung.com>
	Acked-by: Tejun Heo <tj@kernel.org>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 65e8617fba17732b4c68d3369a621725838b6f28)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/esas2r/esas2r_main.c
#	drivers/scsi/hisi_sas/hisi_sas.h
#	drivers/scsi/scsi_debug.c
#	drivers/scsi/scsi_lib.c
#	include/scsi/scsi.h
diff --cc drivers/scsi/scsi_debug.c
index a9186db45d11,06b151711cdd..000000000000
--- a/drivers/scsi/scsi_debug.c
+++ b/drivers/scsi/scsi_debug.c
@@@ -3938,19 -5296,22 +3938,25 @@@ static struct scsi_host_template sdebug
  	.slave_configure =	scsi_debug_slave_configure,
  	.slave_destroy =	scsi_debug_slave_destroy,
  	.ioctl =		scsi_debug_ioctl,
 -	.queuecommand =		sdebug_queuecommand_lock_or_not,
 -	.change_queue_depth =	sdebug_change_qdepth,
 +	.queuecommand =		scsi_debug_queuecommand,
  	.eh_abort_handler =	scsi_debug_abort,
 -	.eh_device_reset_handler = scsi_debug_device_reset,
 -	.eh_target_reset_handler = scsi_debug_target_reset,
  	.eh_bus_reset_handler = scsi_debug_bus_reset,
 +	.eh_device_reset_handler = scsi_debug_device_reset,
  	.eh_host_reset_handler = scsi_debug_host_reset,
 +	.bios_param =		scsi_debug_biosparam,
  	.can_queue =		SCSI_DEBUG_CANQUEUE,
  	.this_id =		7,
++<<<<<<< HEAD
 +	.sg_tablesize =		256,
 +	.cmd_per_lun =		16,
 +	.max_sectors =		0xffff,
++=======
+ 	.sg_tablesize =		SG_MAX_SEGMENTS,
+ 	.cmd_per_lun =		DEF_CMD_PER_LUN,
+ 	.max_sectors =		-1U,
++>>>>>>> 65e8617fba17 (scsi: rename SCSI_MAX_{SG, SG_CHAIN}_SEGMENTS)
  	.use_clustering = 	DISABLE_CLUSTERING,
  	.module =		THIS_MODULE,
 -	.track_queue_depth =	1,
 -	.cmd_size =		sizeof(struct sdebug_scmd_extra_t),
  };
  
  static int sdebug_driver_probe(struct device * dev)
diff --cc drivers/scsi/scsi_lib.c
index f484f378d9a4,8f776f1e95ce..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -51,20 -51,20 +51,20 @@@ struct scsi_host_sg_pool 
  };
  
  #define SP(x) { .size = x, "sgpool-" __stringify(x) }
- #if (SCSI_MAX_SG_SEGMENTS < 32)
- #error SCSI_MAX_SG_SEGMENTS is too small (must be 32 or greater)
+ #if (SG_CHUNK_SIZE < 32)
+ #error SG_CHUNK_SIZE is too small (must be 32 or greater)
  #endif
 -static struct sg_pool sg_pools[] = {
 +static struct scsi_host_sg_pool scsi_sg_pools[] = {
  	SP(8),
  	SP(16),
- #if (SCSI_MAX_SG_SEGMENTS > 32)
+ #if (SG_CHUNK_SIZE > 32)
  	SP(32),
- #if (SCSI_MAX_SG_SEGMENTS > 64)
+ #if (SG_CHUNK_SIZE > 64)
  	SP(64),
- #if (SCSI_MAX_SG_SEGMENTS > 128)
+ #if (SG_CHUNK_SIZE > 128)
  	SP(128),
- #if (SCSI_MAX_SG_SEGMENTS > 256)
- #error SCSI_MAX_SG_SEGMENTS is too large (256 MAX)
+ #if (SG_CHUNK_SIZE > 256)
+ #error SG_CHUNK_SIZE is too large (256 MAX)
  #endif
  #endif
  #endif
@@@ -594,34 -583,32 +594,52 @@@ static struct scatterlist *scsi_sg_allo
  	return mempool_alloc(sgp->pool, gfp_mask);
  }
  
 -static void sg_free_table_chained(struct sg_table *table, bool first_chunk)
 +static void scsi_free_sgtable(struct scsi_data_buffer *sdb, bool mq)
  {
++<<<<<<< HEAD
 +	if (mq && sdb->table.orig_nents <= SCSI_MAX_SG_SEGMENTS)
 +		return;
 +	__sg_free_table(&sdb->table, SCSI_MAX_SG_SEGMENTS, mq, scsi_sg_free);
++=======
+ 	if (first_chunk && table->orig_nents <= SG_CHUNK_SIZE)
+ 		return;
+ 	__sg_free_table(table, SG_CHUNK_SIZE, first_chunk, sg_pool_free);
++>>>>>>> 65e8617fba17 (scsi: rename SCSI_MAX_{SG, SG_CHAIN}_SEGMENTS)
  }
  
 -static int sg_alloc_table_chained(struct sg_table *table, int nents,
 -		struct scatterlist *first_chunk)
 +static int scsi_alloc_sgtable(struct scsi_data_buffer *sdb, int nents,
 +			      gfp_t gfp_mask, bool mq)
  {
 +	struct scatterlist *first_chunk = NULL;
  	int ret;
  
  	BUG_ON(!nents);
  
++<<<<<<< HEAD
 +	if (mq) {
 +		if (nents <= SCSI_MAX_SG_SEGMENTS) {
 +			sdb->table.nents = sdb->table.orig_nents = nents;
 +			sg_init_table(sdb->table.sgl, nents);
++=======
+ 	if (first_chunk) {
+ 		if (nents <= SG_CHUNK_SIZE) {
+ 			table->nents = table->orig_nents = nents;
+ 			sg_init_table(table->sgl, nents);
++>>>>>>> 65e8617fba17 (scsi: rename SCSI_MAX_{SG, SG_CHAIN}_SEGMENTS)
  			return 0;
  		}
 +		first_chunk = sdb->table.sgl;
  	}
  
++<<<<<<< HEAD
 +	ret = __sg_alloc_table(&sdb->table, nents, SCSI_MAX_SG_SEGMENTS,
 +			       first_chunk, gfp_mask, scsi_sg_alloc);
++=======
+ 	ret = __sg_alloc_table(table, nents, SG_CHUNK_SIZE,
+ 			       first_chunk, GFP_ATOMIC, sg_pool_alloc);
++>>>>>>> 65e8617fba17 (scsi: rename SCSI_MAX_{SG, SG_CHAIN}_SEGMENTS)
  	if (unlikely(ret))
 -		sg_free_table_chained(table, (bool)first_chunk);
 +		scsi_free_sgtable(sdb, mq);
  	return ret;
  }
  
diff --cc include/scsi/scsi.h
index b351ddee7cb0,74dafa75bae7..000000000000
--- a/include/scsi/scsi.h
+++ b/include/scsi/scsi.h
@@@ -25,16 -24,16 +25,21 @@@ enum scsi_timeouts 
   * to SG_MAX_SINGLE_ALLOC to pack correctly at the highest order.  The
   * minimum value is 32
   */
- #define SCSI_MAX_SG_SEGMENTS	128
+ #define SG_CHUNK_SIZE	128
  
  /*
-  * Like SCSI_MAX_SG_SEGMENTS, but for archs that have sg chaining. This limit
+  * Like SG_CHUNK_SIZE, but for archs that have sg chaining. This limit
   * is totally arbitrary, a setting of 2048 will get you at least 8mb ios.
   */
++<<<<<<< HEAD
 +#ifdef ARCH_HAS_SG_CHAIN
 +#define SCSI_MAX_SG_CHAIN_SEGMENTS	2048
++=======
+ #ifdef CONFIG_ARCH_HAS_SG_CHAIN
+ #define SG_MAX_SEGMENTS	2048
++>>>>>>> 65e8617fba17 (scsi: rename SCSI_MAX_{SG, SG_CHAIN}_SEGMENTS)
  #else
- #define SCSI_MAX_SG_CHAIN_SEGMENTS	SCSI_MAX_SG_SEGMENTS
+ #define SG_MAX_SEGMENTS	SG_CHUNK_SIZE
  #endif
  
  /*
* Unmerged path drivers/scsi/esas2r/esas2r_main.c
* Unmerged path drivers/scsi/hisi_sas/hisi_sas.h
diff --git a/drivers/ata/pata_icside.c b/drivers/ata/pata_icside.c
index d7c732042a4f..188f2f2eb21f 100644
--- a/drivers/ata/pata_icside.c
+++ b/drivers/ata/pata_icside.c
@@ -294,7 +294,7 @@ static int icside_dma_init(struct pata_icside_info *info)
 
 static struct scsi_host_template pata_icside_sht = {
 	ATA_BASE_SHT(DRV_NAME),
-	.sg_tablesize		= SCSI_MAX_SG_CHAIN_SEGMENTS,
+	.sg_tablesize		= SG_MAX_SEGMENTS,
 	.dma_boundary		= IOMD_DMA_BOUNDARY,
 };
 
diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c
index 83341d524906..9182c7e27b51 100644
--- a/drivers/infiniband/ulp/srp/ib_srp.c
+++ b/drivers/infiniband/ulp/srp/ib_srp.c
@@ -82,7 +82,7 @@ MODULE_PARM_DESC(cmd_sg_entries,
 
 module_param(indirect_sg_entries, uint, 0444);
 MODULE_PARM_DESC(indirect_sg_entries,
-		 "Default max number of gather/scatter entries (default is 12, max is " __stringify(SCSI_MAX_SG_CHAIN_SEGMENTS) ")");
+		 "Default max number of gather/scatter entries (default is 12, max is " __stringify(SG_MAX_SEGMENTS) ")");
 
 module_param(allow_ext_sg, bool, 0444);
 MODULE_PARM_DESC(allow_ext_sg,
@@ -3226,7 +3226,7 @@ static int srp_parse_options(const char *buf, struct srp_target_port *target)
 
 		case SRP_OPT_SG_TABLESIZE:
 			if (match_int(args, &token) || token < 1 ||
-					token > SCSI_MAX_SG_CHAIN_SEGMENTS) {
+					token > SG_MAX_SEGMENTS) {
 				pr_warn("bad max sg_tablesize parameter '%s'\n",
 					p);
 				goto out;
diff --git a/drivers/scsi/arm/cumana_2.c b/drivers/scsi/arm/cumana_2.c
index 58915f29055b..a8de1686bf18 100644
--- a/drivers/scsi/arm/cumana_2.c
+++ b/drivers/scsi/arm/cumana_2.c
@@ -365,7 +365,7 @@ static struct scsi_host_template cumanascsi2_template = {
 	.eh_abort_handler		= fas216_eh_abort,
 	.can_queue			= 1,
 	.this_id			= 7,
-	.sg_tablesize			= SCSI_MAX_SG_CHAIN_SEGMENTS,
+	.sg_tablesize			= SG_MAX_SEGMENTS,
 	.dma_boundary			= IOMD_DMA_BOUNDARY,
 	.cmd_per_lun			= 1,
 	.use_clustering			= DISABLE_CLUSTERING,
diff --git a/drivers/scsi/arm/eesox.c b/drivers/scsi/arm/eesox.c
index 5bf3c0d134b4..e58037f8163c 100644
--- a/drivers/scsi/arm/eesox.c
+++ b/drivers/scsi/arm/eesox.c
@@ -484,7 +484,7 @@ static struct scsi_host_template eesox_template = {
 	.eh_abort_handler		= fas216_eh_abort,
 	.can_queue			= 1,
 	.this_id			= 7,
-	.sg_tablesize			= SCSI_MAX_SG_CHAIN_SEGMENTS,
+	.sg_tablesize			= SG_MAX_SEGMENTS,
 	.dma_boundary			= IOMD_DMA_BOUNDARY,
 	.cmd_per_lun			= 1,
 	.use_clustering			= DISABLE_CLUSTERING,
diff --git a/drivers/scsi/arm/powertec.c b/drivers/scsi/arm/powertec.c
index abc9593615e9..1c4cdec17f83 100644
--- a/drivers/scsi/arm/powertec.c
+++ b/drivers/scsi/arm/powertec.c
@@ -291,7 +291,7 @@ static struct scsi_host_template powertecscsi_template = {
 
 	.can_queue			= 8,
 	.this_id			= 7,
-	.sg_tablesize			= SCSI_MAX_SG_CHAIN_SEGMENTS,
+	.sg_tablesize			= SG_MAX_SEGMENTS,
 	.dma_boundary			= IOMD_DMA_BOUNDARY,
 	.cmd_per_lun			= 2,
 	.use_clustering			= ENABLE_CLUSTERING,
* Unmerged path drivers/scsi/esas2r/esas2r_main.c
* Unmerged path drivers/scsi/hisi_sas/hisi_sas.h
diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.c b/drivers/scsi/mpt3sas/mpt3sas_base.c
index 4df666db79f3..436cddb455ef 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@ -3221,10 +3221,10 @@ _base_allocate_memory_pools(struct MPT3SAS_ADAPTER *ioc)
 		sg_tablesize = MPT_MIN_PHYS_SEGMENTS;
 	else if (sg_tablesize > MPT_MAX_PHYS_SEGMENTS) {
 		sg_tablesize = min_t(unsigned short, sg_tablesize,
-				      SCSI_MAX_SG_CHAIN_SEGMENTS);
+				      SG_MAX_SEGMENTS);
 		pr_warn(MPT3SAS_FMT
 		 "sg_tablesize(%u) is bigger than kernel"
-		 " defined SCSI_MAX_SG_SEGMENTS(%u)\n", ioc->name,
+		 " defined SG_CHUNK_SIZE(%u)\n", ioc->name,
 		 sg_tablesize, MPT_MAX_PHYS_SEGMENTS);
 	}
 	ioc->shost->sg_tablesize = sg_tablesize;
diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.h b/drivers/scsi/mpt3sas/mpt3sas_base.h
index b2b4d16c0da6..6a1600be3a07 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_base.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h
@@ -90,7 +90,7 @@
 /*
  * Set MPT3SAS_SG_DEPTH value based on user input.
  */
-#define MPT_MAX_PHYS_SEGMENTS	SCSI_MAX_SG_SEGMENTS
+#define MPT_MAX_PHYS_SEGMENTS	SG_CHUNK_SIZE
 #define MPT_MIN_PHYS_SEGMENTS	16
 
 #ifdef CONFIG_SCSI_MPT3SAS_MAX_SGE
* Unmerged path drivers/scsi/scsi_debug.c
* Unmerged path drivers/scsi/scsi_lib.c
diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index c922d8b64362..c7aa4506d25d 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -564,7 +564,7 @@ static const struct scsi_host_template usb_stor_host_template = {
 	.target_alloc =			target_alloc,
 
 	/* lots of sg segments can be handled */
-	.sg_tablesize =			SCSI_MAX_SG_CHAIN_SEGMENTS,
+	.sg_tablesize =			SG_MAX_SEGMENTS,
 
 	/* limit the total size of a transfer to 120 KB */
 	.max_sectors =                  240,
* Unmerged path include/scsi/scsi.h
diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index 5dae387b9846..3ddee70ffaf0 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -41,7 +41,7 @@ struct blk_queue_tags;
  *	 used in one scatter-gather request.
  */
 #define SG_NONE 0
-#define SG_ALL	SCSI_MAX_SG_SEGMENTS
+#define SG_ALL	SG_CHUNK_SIZE
 
 #define MODE_UNKNOWN 0x00
 #define MODE_INITIATOR 0x01
