nfp: rename ring allocation helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 0ae42dfcf249a6b6535d37e119e06efb31eef979
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0ae42dfc.failed

"Shadow" in ring helpers used to mean that the helper will allocate
rings without touching existing configuration, this was used for
reconfiguration while the device was running.  We will soon use
the same helpers for .ndo_open() path, so replace "shadow" with
"ring_set".

No functional changes.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0ae42dfcf249a6b6535d37e119e06efb31eef979)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 36b6294ec9a7,b7b2851ebb6b..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -1544,7 -1573,7 +1544,11 @@@ err_alloc
  }
  
  static struct nfp_net_tx_ring *
++<<<<<<< HEAD
 +nfp_net_shadow_tx_rings_prepare(struct nfp_net *nn, u32 buf_cnt)
++=======
+ nfp_net_tx_ring_set_prepare(struct nfp_net *nn, struct nfp_net_ring_set *s)
++>>>>>>> 0ae42dfcf249 (nfp: rename ring allocation helpers)
  {
  	struct nfp_net_tx_ring *rings;
  	unsigned int r;
@@@ -1569,27 -1598,29 +1573,36 @@@ err_free_prev
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static struct nfp_net_tx_ring *
 +nfp_net_shadow_tx_rings_swap(struct nfp_net *nn, struct nfp_net_tx_ring *rings)
++=======
+ static void
+ nfp_net_tx_ring_set_swap(struct nfp_net *nn, struct nfp_net_ring_set *s)
++>>>>>>> 0ae42dfcf249 (nfp: rename ring allocation helpers)
  {
 -	struct nfp_net_tx_ring *rings = s->rings;
 -	struct nfp_net_ring_set new = *s;
 +	struct nfp_net_tx_ring *old = nn->tx_rings;
  	unsigned int r;
  
 -	s->dcnt = nn->txd_cnt;
 -	s->rings = nn->tx_rings;
 -
  	for (r = 0; r < nn->num_tx_rings; r++)
 -		nn->tx_rings[r].r_vec->tx_ring = &rings[r];
 +		old[r].r_vec->tx_ring = &rings[r];
  
 -	nn->txd_cnt = new.dcnt;
 -	nn->tx_rings = new.rings;
 +	nn->tx_rings = rings;
 +	return old;
  }
  
  static void
++<<<<<<< HEAD
 +nfp_net_shadow_tx_rings_free(struct nfp_net *nn, struct nfp_net_tx_ring *rings)
++=======
+ nfp_net_tx_ring_set_free(struct nfp_net *nn, struct nfp_net_ring_set *s)
++>>>>>>> 0ae42dfcf249 (nfp: rename ring allocation helpers)
  {
 -	struct nfp_net_tx_ring *rings = s->rings;
  	unsigned int r;
  
 +	if (!rings)
 +		return;
 +
  	for (r = 0; r < nn->num_tx_rings; r++)
  		nfp_net_tx_ring_free(&rings[r]);
  
@@@ -1662,9 -1693,9 +1675,13 @@@ err_alloc
  }
  
  static struct nfp_net_rx_ring *
++<<<<<<< HEAD
 +nfp_net_shadow_rx_rings_prepare(struct nfp_net *nn, unsigned int fl_bufsz,
 +				u32 buf_cnt)
++=======
+ nfp_net_rx_ring_set_prepare(struct nfp_net *nn, struct nfp_net_ring_set *s)
++>>>>>>> 0ae42dfcf249 (nfp: rename ring allocation helpers)
  {
 -	unsigned int fl_bufsz =	nfp_net_calc_fl_bufsz(nn, s->mtu);
  	struct nfp_net_rx_ring *rings;
  	unsigned int r;
  
@@@ -1694,27 -1725,32 +1711,36 @@@ err_free_ring
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static struct nfp_net_rx_ring *
 +nfp_net_shadow_rx_rings_swap(struct nfp_net *nn, struct nfp_net_rx_ring *rings)
++=======
+ static void
+ nfp_net_rx_ring_set_swap(struct nfp_net *nn, struct nfp_net_ring_set *s)
++>>>>>>> 0ae42dfcf249 (nfp: rename ring allocation helpers)
  {
 -	struct nfp_net_rx_ring *rings = s->rings;
 -	struct nfp_net_ring_set new = *s;
 +	struct nfp_net_rx_ring *old = nn->rx_rings;
  	unsigned int r;
  
 -	s->mtu = nn->netdev->mtu;
 -	s->dcnt = nn->rxd_cnt;
 -	s->rings = nn->rx_rings;
 -
  	for (r = 0; r < nn->num_rx_rings; r++)
 -		nn->rx_rings[r].r_vec->rx_ring = &rings[r];
 +		old[r].r_vec->rx_ring = &rings[r];
  
 -	nn->netdev->mtu = new.mtu;
 -	nn->fl_bufsz = nfp_net_calc_fl_bufsz(nn, new.mtu);
 -	nn->rxd_cnt = new.dcnt;
 -	nn->rx_rings = new.rings;
 +	nn->rx_rings = rings;
 +	return old;
  }
  
  static void
++<<<<<<< HEAD
 +nfp_net_shadow_rx_rings_free(struct nfp_net *nn, struct nfp_net_rx_ring *rings)
++=======
+ nfp_net_rx_ring_set_free(struct nfp_net *nn, struct nfp_net_ring_set *s)
++>>>>>>> 0ae42dfcf249 (nfp: rename ring allocation helpers)
  {
 -	struct nfp_net_rx_ring *rings = s->rings;
  	unsigned int r;
  
 +	if (!rings)
 +		return;
 +
  	for (r = 0; r < nn->num_rx_rings; r++) {
  		nfp_net_rx_ring_bufs_free(nn, &rings[r]);
  		nfp_net_rx_ring_free(&rings[r]);
@@@ -2227,71 -2262,34 +2253,102 @@@ static void nfp_net_set_rx_mode(struct 
  	nn->ctrl = new_ctrl;
  }
  
++<<<<<<< HEAD
 +static int nfp_net_change_mtu(struct net_device *netdev, int new_mtu)
++=======
+ static int
+ nfp_net_ring_swap_enable(struct nfp_net *nn,
+ 			 struct nfp_net_ring_set *rx,
+ 			 struct nfp_net_ring_set *tx)
+ {
+ 	if (rx)
+ 		nfp_net_rx_ring_set_swap(nn, rx);
+ 	if (tx)
+ 		nfp_net_tx_ring_set_swap(nn, tx);
+ 
+ 	return __nfp_net_set_config_and_enable(nn);
+ }
+ 
+ static void
+ nfp_net_ring_reconfig_down(struct nfp_net *nn,
+ 			   struct nfp_net_ring_set *rx,
+ 			   struct nfp_net_ring_set *tx)
+ {
+ 	nn->netdev->mtu = rx ? rx->mtu : nn->netdev->mtu;
+ 	nn->fl_bufsz = nfp_net_calc_fl_bufsz(nn, nn->netdev->mtu);
+ 	nn->rxd_cnt = rx ? rx->dcnt : nn->rxd_cnt;
+ 	nn->txd_cnt = tx ? tx->dcnt : nn->txd_cnt;
+ }
+ 
+ int
+ nfp_net_ring_reconfig(struct nfp_net *nn, struct nfp_net_ring_set *rx,
+ 		      struct nfp_net_ring_set *tx)
++>>>>>>> 0ae42dfcf249 (nfp: rename ring allocation helpers)
 +{
 +	unsigned int old_mtu, old_fl_bufsz, new_fl_bufsz;
 +	struct nfp_net *nn = netdev_priv(netdev);
 +	struct nfp_net_rx_ring *tmp_rings;
 +	int err;
 +
 +	if (new_mtu < 68 || new_mtu > nn->max_mtu) {
 +		nn_err(nn, "New MTU (%d) is not valid\n", new_mtu);
 +		return -EINVAL;
 +	}
 +
 +	old_mtu = netdev->mtu;
 +	old_fl_bufsz = nn->fl_bufsz;
 +	new_fl_bufsz = NFP_NET_MAX_PREPEND + ETH_HLEN + VLAN_HLEN * 2 + new_mtu;
 +
 +	if (!netif_running(netdev)) {
 +		netdev->mtu = new_mtu;
 +		nn->fl_bufsz = new_fl_bufsz;
 +		return 0;
 +	}
 +
 +	/* Prepare new rings */
++<<<<<<< HEAD
 +	tmp_rings = nfp_net_shadow_rx_rings_prepare(nn, new_fl_bufsz,
 +						    nn->rxd_cnt);
 +	if (!tmp_rings)
 +		return -ENOMEM;
 +
 +	/* Stop device, swap in new rings, try to start the firmware */
 +	nfp_net_close_stack(nn);
 +	nfp_net_clear_config_and_disable(nn);
 +
 +	tmp_rings = nfp_net_shadow_rx_rings_swap(nn, tmp_rings);
 +
 +	netdev->mtu = new_mtu;
 +	nn->fl_bufsz = new_fl_bufsz;
 +
 +	err = nfp_net_set_config_and_enable(nn);
 +	if (err) {
 +		const int err_new = err;
 +
 +		/* Try with old configuration and old rings */
 +		tmp_rings = nfp_net_shadow_rx_rings_swap(nn, tmp_rings);
 +
 +		netdev->mtu = old_mtu;
 +		nn->fl_bufsz = old_fl_bufsz;
 +
 +		err = __nfp_net_set_config_and_enable(nn);
 +		if (err)
 +			nn_err(nn, "Can't restore MTU - FW communication failed (%d,%d)\n",
 +			       err_new, err);
 +	}
 +
 +	nfp_net_shadow_rx_rings_free(nn, tmp_rings);
 +
 +	nfp_net_open_stack(nn);
 +
 +	return err;
 +}
 +
 +int nfp_net_set_ring_size(struct nfp_net *nn, u32 rxd_cnt, u32 txd_cnt)
  {
 +	struct nfp_net_tx_ring *tx_rings = NULL;
 +	struct nfp_net_rx_ring *rx_rings = NULL;
 +	u32 old_rxd_cnt, old_txd_cnt;
  	int err;
  
  	if (!netif_running(nn->netdev)) {
@@@ -2300,21 -2297,15 +2357,31 @@@
  		return 0;
  	}
  
 +	old_rxd_cnt = nn->rxd_cnt;
 +	old_txd_cnt = nn->txd_cnt;
 +
  	/* Prepare new rings */
 +	if (nn->rxd_cnt != rxd_cnt) {
 +		rx_rings = nfp_net_shadow_rx_rings_prepare(nn, nn->fl_bufsz,
 +							   rxd_cnt);
 +		if (!rx_rings)
 +			return -ENOMEM;
 +	}
 +	if (nn->txd_cnt != txd_cnt) {
 +		tx_rings = nfp_net_shadow_tx_rings_prepare(nn, txd_cnt);
 +		if (!tx_rings) {
 +			nfp_net_shadow_rx_rings_free(nn, rx_rings);
 +			return -ENOMEM;
++=======
+ 	if (rx) {
+ 		if (!nfp_net_rx_ring_set_prepare(nn, rx))
+ 			return -ENOMEM;
+ 	}
+ 	if (tx) {
+ 		if (!nfp_net_tx_ring_set_prepare(nn, tx)) {
+ 			err = -ENOMEM;
+ 			goto err_free_rx;
++>>>>>>> 0ae42dfcf249 (nfp: rename ring allocation helpers)
  		}
  	}
  
@@@ -2322,39 -2313,43 +2389,65 @@@
  	nfp_net_close_stack(nn);
  	nfp_net_clear_config_and_disable(nn);
  
 -	err = nfp_net_ring_swap_enable(nn, rx, tx);
 -	if (err) {
 -		int err2;
 +	if (rx_rings)
 +		rx_rings = nfp_net_shadow_rx_rings_swap(nn, rx_rings);
 +	if (tx_rings)
 +		tx_rings = nfp_net_shadow_tx_rings_swap(nn, tx_rings);
  
 -		nfp_net_clear_config_and_disable(nn);
 +	nn->rxd_cnt = rxd_cnt;
 +	nn->txd_cnt = txd_cnt;
 +
 +	err = nfp_net_set_config_and_enable(nn);
 +	if (err) {
 +		const int err_new = err;
  
  		/* Try with old configuration and old rings */
 -		err2 = nfp_net_ring_swap_enable(nn, rx, tx);
 -		if (err2)
 +		if (rx_rings)
 +			rx_rings = nfp_net_shadow_rx_rings_swap(nn, rx_rings);
 +		if (tx_rings)
 +			tx_rings = nfp_net_shadow_tx_rings_swap(nn, tx_rings);
 +
 +		nn->rxd_cnt = old_rxd_cnt;
 +		nn->txd_cnt = old_txd_cnt;
 +
 +		err = __nfp_net_set_config_and_enable(nn);
 +		if (err)
  			nn_err(nn, "Can't restore ring config - FW communication failed (%d,%d)\n",
 -			       err, err2);
 +			       err_new, err);
  	}
  
++<<<<<<< HEAD
 +	nfp_net_shadow_rx_rings_free(nn, rx_rings);
 +	nfp_net_shadow_tx_rings_free(nn, tx_rings);
++=======
+ 	if (rx)
+ 		nfp_net_rx_ring_set_free(nn, rx);
+ 	if (tx)
+ 		nfp_net_tx_ring_set_free(nn, tx);
++>>>>>>> 0ae42dfcf249 (nfp: rename ring allocation helpers)
  
  	nfp_net_open_stack(nn);
  
  	return err;
++<<<<<<< HEAD
++=======
+ 
+ err_free_rx:
+ 	if (rx)
+ 		nfp_net_rx_ring_set_free(nn, rx);
+ 	return err;
+ }
+ 
+ static int nfp_net_change_mtu(struct net_device *netdev, int new_mtu)
+ {
+ 	struct nfp_net *nn = netdev_priv(netdev);
+ 	struct nfp_net_ring_set rx = {
+ 		.mtu = new_mtu,
+ 		.dcnt = nn->rxd_cnt,
+ 	};
+ 
+ 	return nfp_net_ring_reconfig(nn, &rx, NULL);
++>>>>>>> 0ae42dfcf249 (nfp: rename ring allocation helpers)
  }
  
  static struct rtnl_link_stats64 *nfp_net_stat64(struct net_device *netdev,
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
