flow_dissector: Add control/reporting of encapsulation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tom Herbert <tom@herbertland.com>
commit 823b96939578eae67b9d6c0e33a39d6a7b6401e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/823b9693.failed

Add an input flag to flow dissector on rather dissection should stop
when encapsulation is detected (IP/IP or GRE). Also, add a key_control
flag that indicates encapsulation was encountered during the
dissection.

	Signed-off-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 823b96939578eae67b9d6c0e33a39d6a7b6401e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_dissector.h
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,8d890132e2d7..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -241,30 -357,52 +241,53 @@@ ip_proto_again
  		 * Only look inside GRE if version zero and no
  		 * routing
  		 */
 -		if (hdr->flags & (GRE_VERSION | GRE_ROUTING))
 -			break;
 -
 -		proto = hdr->proto;
 -		nhoff += 4;
 -		if (hdr->flags & GRE_CSUM)
 +		if (!(hdr->flags & (GRE_VERSION|GRE_ROUTING))) {
 +			proto = hdr->proto;
  			nhoff += 4;
 -		if (hdr->flags & GRE_KEY) {
 -			const __be32 *keyid;
 -			__be32 _keyid;
 -
 -			keyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),
 -						     data, hlen, &_keyid);
 -
 -			if (!keyid)
 -				goto out_bad;
 -
 -			if (skb_flow_dissector_uses_key(flow_dissector,
 -							FLOW_DISSECTOR_KEY_GRE_KEYID)) {
 -				key_keyid = skb_flow_dissector_target(flow_dissector,
 -								      FLOW_DISSECTOR_KEY_GRE_KEYID,
 -								      target_container);
 -				key_keyid->keyid = *keyid;
 +			if (hdr->flags & GRE_CSUM)
 +				nhoff += 4;
 +			if (hdr->flags & GRE_KEY)
 +				nhoff += 4;
 +			if (hdr->flags & GRE_SEQ)
 +				nhoff += 4;
 +			if (proto == htons(ETH_P_TEB)) {
 +				const struct ethhdr *eth;
 +				struct ethhdr _eth;
 +
 +				eth = __skb_header_pointer(skb, nhoff,
 +							   sizeof(_eth),
 +							   data, hlen, &_eth);
 +				if (!eth)
 +					return false;
 +				proto = eth->h_proto;
 +				nhoff += sizeof(*eth);
  			}
 -			nhoff += 4;
 +			goto again;
  		}
++<<<<<<< HEAD
 +		break;
++=======
+ 		if (hdr->flags & GRE_SEQ)
+ 			nhoff += 4;
+ 		if (proto == htons(ETH_P_TEB)) {
+ 			const struct ethhdr *eth;
+ 			struct ethhdr _eth;
+ 
+ 			eth = __skb_header_pointer(skb, nhoff,
+ 						   sizeof(_eth),
+ 						   data, hlen, &_eth);
+ 			if (!eth)
+ 				goto out_bad;
+ 			proto = eth->h_proto;
+ 			nhoff += sizeof(*eth);
+ 		}
+ 
+ 		key_control->encapsulation = 1;
+ 		if (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP)
+ 			goto out_good;
+ 
+ 		goto again;
++>>>>>>> 823b96939578 (flow_dissector: Add control/reporting of encapsulation)
  	}
  	case NEXTHDR_HOP:
  	case NEXTHDR_ROUTING:
@@@ -314,7 -457,15 +342,12 @@@
  		goto ip;
  	case IPPROTO_IPV6:
  		proto = htons(ETH_P_IPV6);
+ 
+ 		key_control->encapsulation = 1;
+ 		if (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP)
+ 			goto out_good;
+ 
  		goto ipv6;
 -	case IPPROTO_MPLS:
 -		proto = htons(ETH_P_MPLS_UC);
 -		goto mpls;
  	default:
  		break;
  	}
* Unmerged path include/net/flow_dissector.h
* Unmerged path include/net/flow_dissector.h
* Unmerged path net/core/flow_dissector.c
