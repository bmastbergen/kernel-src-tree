crypto: ccp - Shorten the fields of the action structure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] ccp - Shorten the fields of the action structure (Suravee Suthikulpanit) [1390820]
Rebuild_FUZZ: 92.31%
commit-author Gary R Hook <gary.hook@amd.com>
commit a43eb98507574acfc435c38a6b7fb1fab6605519
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a43eb985.failed

Use more concise field names; "perform_" is too verbose.

	Signed-off-by: Gary R Hook <gary.hook@amd.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit a43eb98507574acfc435c38a6b7fb1fab6605519)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/ccp/ccp-dev-v3.c
#	drivers/crypto/ccp/ccp-dev.h
#	drivers/crypto/ccp/ccp-ops.c
diff --cc drivers/crypto/ccp/ccp-dev.h
index 72bf1536b653,46d3ef30c6e9..000000000000
--- a/drivers/crypto/ccp/ccp-dev.h
+++ b/drivers/crypto/ccp/ccp-dev.h
@@@ -139,6 -145,30 +139,33 @@@
  #define CCP_ECC_RESULT_OFFSET		60
  #define CCP_ECC_RESULT_SUCCESS		0x0001
  
++<<<<<<< HEAD
++=======
+ struct ccp_op;
+ 
+ /* Structure for computation functions that are device-specific */
+ struct ccp_actions {
+ 	int (*aes)(struct ccp_op *);
+ 	int (*xts_aes)(struct ccp_op *);
+ 	int (*sha)(struct ccp_op *);
+ 	int (*rsa)(struct ccp_op *);
+ 	int (*passthru)(struct ccp_op *);
+ 	int (*ecc)(struct ccp_op *);
+ 	int (*init)(struct ccp_device *);
+ 	void (*destroy)(struct ccp_device *);
+ 	irqreturn_t (*irqhandler)(int, void *);
+ };
+ 
+ /* Structure to hold CCP version-specific values */
+ struct ccp_vdata {
+ 	unsigned int version;
+ 	const struct ccp_actions *perform;
+ 	const unsigned int bar;
+ 	const unsigned int offset;
+ };
+ 
+ extern struct ccp_vdata ccpv3;
++>>>>>>> a43eb9850757 (crypto: ccp - Shorten the fields of the action structure)
  
  struct ccp_device;
  struct ccp_cmd;
diff --cc drivers/crypto/ccp/ccp-ops.c
index 23dbb41465d1,d1024771e926..000000000000
--- a/drivers/crypto/ccp/ccp-ops.c
+++ b/drivers/crypto/ccp/ccp-ops.c
@@@ -1,9 -1,10 +1,10 @@@
  /*
   * AMD Cryptographic Coprocessor (CCP) driver
   *
 - * Copyright (C) 2013,2016 Advanced Micro Devices, Inc.
 + * Copyright (C) 2013 Advanced Micro Devices, Inc.
   *
   * Author: Tom Lendacky <thomas.lendacky@amd.com>
+  * Author: Gary R Hook <gary.hook@amd.com>
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 as
@@@ -835,7 -479,7 +836,11 @@@ static int ccp_copy_to_from_ksb(struct 
  
  	op.u.passthru.byte_swap = byte_swap;
  
++<<<<<<< HEAD
 +	return ccp_perform_passthru(&op);
++=======
+ 	return cmd_q->ccp->vdata->perform->passthru(&op);
++>>>>>>> a43eb9850757 (crypto: ccp - Shorten the fields of the action structure)
  }
  
  static int ccp_copy_to_ksb(struct ccp_cmd_queue *cmd_q,
@@@ -967,7 -611,7 +972,11 @@@ static int ccp_run_aes_cmac_cmd(struct 
  			}
  		}
  
++<<<<<<< HEAD
 +		ret = ccp_perform_aes(&op);
++=======
+ 		ret = cmd_q->ccp->vdata->perform->aes(&op);
++>>>>>>> a43eb9850757 (crypto: ccp - Shorten the fields of the action structure)
  		if (ret) {
  			cmd->engine_error = cmd_q->cmd_error;
  			goto e_src;
@@@ -1129,7 -773,7 +1138,11 @@@ static int ccp_run_aes_cmd(struct ccp_c
  				op.soc = 1;
  		}
  
++<<<<<<< HEAD
 +		ret = ccp_perform_aes(&op);
++=======
+ 		ret = cmd_q->ccp->vdata->perform->aes(&op);
++>>>>>>> a43eb9850757 (crypto: ccp - Shorten the fields of the action structure)
  		if (ret) {
  			cmd->engine_error = cmd_q->cmd_error;
  			goto e_dst;
@@@ -1294,7 -938,7 +1307,11 @@@ static int ccp_run_xts_aes_cmd(struct c
  		if (!src.sg_wa.bytes_left)
  			op.eom = 1;
  
++<<<<<<< HEAD
 +		ret = ccp_perform_xts_aes(&op);
++=======
+ 		ret = cmd_q->ccp->vdata->perform->xts_aes(&op);
++>>>>>>> a43eb9850757 (crypto: ccp - Shorten the fields of the action structure)
  		if (ret) {
  			cmd->engine_error = cmd_q->cmd_error;
  			goto e_dst;
@@@ -1427,7 -1095,7 +1444,11 @@@ static int ccp_run_sha_cmd(struct ccp_c
  		if (sha->final && !src.sg_wa.bytes_left)
  			op.eom = 1;
  
++<<<<<<< HEAD
 +		ret = ccp_perform_sha(&op);
++=======
+ 		ret = cmd_q->ccp->vdata->perform->sha(&op);
++>>>>>>> a43eb9850757 (crypto: ccp - Shorten the fields of the action structure)
  		if (ret) {
  			cmd->engine_error = cmd_q->cmd_error;
  			goto e_data;
@@@ -1541,7 -1275,7 +1562,11 @@@ static int ccp_run_rsa_cmd(struct ccp_c
  	op.u.rsa.mod_size = rsa->key_size;
  	op.u.rsa.input_len = i_len;
  
++<<<<<<< HEAD
 +	ret = ccp_perform_rsa(&op);
++=======
+ 	ret = cmd_q->ccp->vdata->perform->rsa(&op);
++>>>>>>> a43eb9850757 (crypto: ccp - Shorten the fields of the action structure)
  	if (ret) {
  		cmd->engine_error = cmd_q->cmd_error;
  		goto e_dst;
@@@ -1666,7 -1400,7 +1691,11 @@@ static int ccp_run_passthru_cmd(struct 
  		op.dst.u.dma.offset = dst.sg_wa.sg_used;
  		op.dst.u.dma.length = op.src.u.dma.length;
  
++<<<<<<< HEAD
 +		ret = ccp_perform_passthru(&op);
++=======
+ 		ret = cmd_q->ccp->vdata->perform->passthru(&op);
++>>>>>>> a43eb9850757 (crypto: ccp - Shorten the fields of the action structure)
  		if (ret) {
  			cmd->engine_error = cmd_q->cmd_error;
  			goto e_dst;
@@@ -1694,6 -1428,70 +1723,73 @@@ e_mask
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int ccp_run_passthru_nomap_cmd(struct ccp_cmd_queue *cmd_q,
+ 				      struct ccp_cmd *cmd)
+ {
+ 	struct ccp_passthru_nomap_engine *pt = &cmd->u.passthru_nomap;
+ 	struct ccp_dm_workarea mask;
+ 	struct ccp_op op;
+ 	int ret;
+ 
+ 	if (!pt->final && (pt->src_len & (CCP_PASSTHRU_BLOCKSIZE - 1)))
+ 		return -EINVAL;
+ 
+ 	if (!pt->src_dma || !pt->dst_dma)
+ 		return -EINVAL;
+ 
+ 	if (pt->bit_mod != CCP_PASSTHRU_BITWISE_NOOP) {
+ 		if (pt->mask_len != CCP_PASSTHRU_MASKSIZE)
+ 			return -EINVAL;
+ 		if (!pt->mask)
+ 			return -EINVAL;
+ 	}
+ 
+ 	BUILD_BUG_ON(CCP_PASSTHRU_KSB_COUNT != 1);
+ 
+ 	memset(&op, 0, sizeof(op));
+ 	op.cmd_q = cmd_q;
+ 	op.jobid = ccp_gen_jobid(cmd_q->ccp);
+ 
+ 	if (pt->bit_mod != CCP_PASSTHRU_BITWISE_NOOP) {
+ 		/* Load the mask */
+ 		op.ksb_key = cmd_q->ksb_key;
+ 
+ 		mask.length = pt->mask_len;
+ 		mask.dma.address = pt->mask;
+ 		mask.dma.length = pt->mask_len;
+ 
+ 		ret = ccp_copy_to_ksb(cmd_q, &mask, op.jobid, op.ksb_key,
+ 				     CCP_PASSTHRU_BYTESWAP_NOOP);
+ 		if (ret) {
+ 			cmd->engine_error = cmd_q->cmd_error;
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	/* Send data to the CCP Passthru engine */
+ 	op.eom = 1;
+ 	op.soc = 1;
+ 
+ 	op.src.type = CCP_MEMTYPE_SYSTEM;
+ 	op.src.u.dma.address = pt->src_dma;
+ 	op.src.u.dma.offset = 0;
+ 	op.src.u.dma.length = pt->src_len;
+ 
+ 	op.dst.type = CCP_MEMTYPE_SYSTEM;
+ 	op.dst.u.dma.address = pt->dst_dma;
+ 	op.dst.u.dma.offset = 0;
+ 	op.dst.u.dma.length = pt->src_len;
+ 
+ 	ret = cmd_q->ccp->vdata->perform->passthru(&op);
+ 	if (ret)
+ 		cmd->engine_error = cmd_q->cmd_error;
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> a43eb9850757 (crypto: ccp - Shorten the fields of the action structure)
  static int ccp_run_ecc_mm_cmd(struct ccp_cmd_queue *cmd_q, struct ccp_cmd *cmd)
  {
  	struct ccp_ecc_engine *ecc = &cmd->u.ecc;
@@@ -1772,7 -1576,7 +1868,11 @@@
  
  	op.u.ecc.function = cmd->u.ecc.function;
  
++<<<<<<< HEAD
 +	ret = ccp_perform_ecc(&op);
++=======
+ 	ret = cmd_q->ccp->vdata->perform->ecc(&op);
++>>>>>>> a43eb9850757 (crypto: ccp - Shorten the fields of the action structure)
  	if (ret) {
  		cmd->engine_error = cmd_q->cmd_error;
  		goto e_dst;
@@@ -1921,7 -1740,7 +2021,11 @@@ static int ccp_run_ecc_pm_cmd(struct cc
  
  	op.u.ecc.function = cmd->u.ecc.function;
  
++<<<<<<< HEAD
 +	ret = ccp_perform_ecc(&op);
++=======
+ 	ret = cmd_q->ccp->vdata->perform->ecc(&op);
++>>>>>>> a43eb9850757 (crypto: ccp - Shorten the fields of the action structure)
  	if (ret) {
  		cmd->engine_error = cmd_q->cmd_error;
  		goto e_dst;
* Unmerged path drivers/crypto/ccp/ccp-dev-v3.c
* Unmerged path drivers/crypto/ccp/ccp-dev-v3.c
* Unmerged path drivers/crypto/ccp/ccp-dev.h
* Unmerged path drivers/crypto/ccp/ccp-ops.c
