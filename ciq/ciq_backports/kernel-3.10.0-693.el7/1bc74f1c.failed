powerpc/powernv: Fix stale PE primary bus

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [powerpc] powernv: Fix stale PE primary bus (Steve Best) [1395275]
Rebuild_FUZZ: 89.19%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit 1bc74f1ccd457832dc515fc1febe6655985fdcd2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1bc74f1c.failed

When PCI bus is unplugged during full hotplug for EEH recovery,
the platform PE instance (struct pnv_ioda_pe) isn't released and
it dereferences the stale PCI bus that has been released. It leads
to kernel crash when referring to the stale PCI bus.

This fixes the issue by correcting the PE's primary bus when it's
oneline at plugging time, in pnv_pci_dma_bus_setup() which is to
be called by pcibios_fixup_bus().

	Cc: stable@vger.kernel.org # v4.1+
	Reported-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
	Reported-by: Pradipta Ghosh <pradghos@in.ibm.com>
	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Tested-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 1bc74f1ccd457832dc515fc1febe6655985fdcd2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/pci.c
diff --cc arch/powerpc/platforms/powernv/pci.c
index 18c20c8232fd,d25ff2292ae2..000000000000
--- a/arch/powerpc/platforms/powernv/pci.c
+++ b/arch/powerpc/platforms/powernv/pci.c
@@@ -768,15 -760,24 +768,36 @@@ void pnv_pci_dma_dev_setup(struct pci_d
  		phb->dma_dev_setup(phb, pdev);
  }
  
++<<<<<<< HEAD
 +u64 pnv_pci_dma_get_required_mask(struct pci_dev *pdev)
 +{
 +	struct pci_controller *hose = pci_bus_to_host(pdev->bus);
 +	struct pnv_phb *phb = hose->private_data;
 +
 +	if (phb && phb->dma_get_required_mask)
 +		return phb->dma_get_required_mask(phb, pdev);
 +
 +	return __dma_get_required_mask(&pdev->dev);
++=======
+ void pnv_pci_dma_bus_setup(struct pci_bus *bus)
+ {
+ 	struct pci_controller *hose = bus->sysdata;
+ 	struct pnv_phb *phb = hose->private_data;
+ 	struct pnv_ioda_pe *pe;
+ 
+ 	list_for_each_entry(pe, &phb->ioda.pe_list, list) {
+ 		if (!(pe->flags & (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL)))
+ 			continue;
+ 
+ 		if (!pe->pbus)
+ 			continue;
+ 
+ 		if (bus->number == ((pe->rid >> 8) & 0xFF)) {
+ 			pe->pbus = bus;
+ 			break;
+ 		}
+ 	}
++>>>>>>> 1bc74f1ccd45 (powerpc/powernv: Fix stale PE primary bus)
  }
  
  void pnv_pci_shutdown(void)
diff --git a/arch/powerpc/platforms/powernv/pci-ioda.c b/arch/powerpc/platforms/powernv/pci-ioda.c
index 68c97e126e2a..057c11e20cf9 100644
--- a/arch/powerpc/platforms/powernv/pci-ioda.c
+++ b/arch/powerpc/platforms/powernv/pci-ioda.c
@@ -3042,6 +3042,7 @@ static void pnv_pci_ioda_shutdown(struct pci_controller *hose)
 
 static const struct pci_controller_ops pnv_pci_ioda_controller_ops = {
        .dma_dev_setup = pnv_pci_dma_dev_setup,
+       .dma_bus_setup = pnv_pci_dma_bus_setup,
 #ifdef CONFIG_PCI_MSI
        .setup_msi_irqs = pnv_setup_msi_irqs,
        .teardown_msi_irqs = pnv_teardown_msi_irqs,
* Unmerged path arch/powerpc/platforms/powernv/pci.c
diff --git a/arch/powerpc/platforms/powernv/pci.h b/arch/powerpc/platforms/powernv/pci.h
index 5e8e7221b5ba..a0a9e5bd311c 100644
--- a/arch/powerpc/platforms/powernv/pci.h
+++ b/arch/powerpc/platforms/powernv/pci.h
@@ -245,6 +245,7 @@ extern void pnv_pci_reset_secondary_bus(struct pci_dev *dev);
 extern int pnv_eeh_phb_reset(struct pci_controller *hose, int option);
 
 extern void pnv_pci_dma_dev_setup(struct pci_dev *pdev);
+extern void pnv_pci_dma_bus_setup(struct pci_bus *bus);
 extern int pnv_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type);
 extern void pnv_teardown_msi_irqs(struct pci_dev *pdev);
 
