autofs: use path_is_mountpoint() to fix unreliable d_mountpoint() checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ian Kent <ikent@redhat.com>
commit cfaf86ab6ccdf0acf47ebe474a4a844114bc0e10
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/cfaf86ab.failed

If an automount mount is clone(2)ed into a file system that is propagation
private, when it later expires in the originating namespace, subsequent
calls to autofs ->d_automount() for that dentry in the original namespace
will return ELOOP until the mount is umounted in the cloned namespace.

Now that a struct path is available where needed use path_is_mountpoint()
instead of d_mountpoint() so we don't get false positives when checking if
a dentry is a mount point in the current namespace.

Link: http://lkml.kernel.org/r/20161011053418.27645.15241.stgit@pluto.themaw.net
	Signed-off-by: Ian Kent <raven@themaw.net>
	Cc: Al Viro <viro@ZenIV.linux.org.uk>
	Cc: Eric W. Biederman <ebiederm@xmission.com>
	Cc: Omar Sandoval <osandov@osandov.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit cfaf86ab6ccdf0acf47ebe474a4a844114bc0e10)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/autofs4/root.c
diff --cc fs/autofs4/root.c
index b538a83d1c8b,9355608cb495..000000000000
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@@ -373,10 -372,10 +373,10 @@@ static struct vfsmount *autofs4_d_autom
  
  	/*
  	 * If the dentry is a symlink it's equivalent to a directory
- 	 * having d_mountpoint() true, so there's no need to call back
- 	 * to the daemon.
+ 	 * having path_is_mountpoint() true, so there's no need to call
+ 	 * back to the daemon.
  	 */
 -	if (d_really_is_positive(dentry) && d_is_symlink(dentry)) {
 +	if (dentry->d_inode && S_ISLNK(dentry->d_inode->i_mode)) {
  		spin_unlock(&sbi->fs_lock);
  		goto done;
  	}
@@@ -461,11 -460,12 +461,11 @@@ static int autofs4_d_manage(struct dent
  		 * a mount-trap.
  		 */
  		struct inode *inode;
 -
 -		if (ino->flags & AUTOFS_INF_WANT_EXPIRE)
 +		if (ino->flags & (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU))
  			return 0;
- 		if (d_mountpoint(dentry))
+ 		if (path_is_mountpoint(path))
  			return 0;
 -		inode = d_inode_rcu(dentry);
 +		inode = ACCESS_ONCE(dentry->d_inode);
  		if (inode && S_ISLNK(inode->i_mode))
  			return -EISDIR;
  		if (list_empty(&dentry->d_subdirs))
@@@ -490,8 -490,8 +490,13 @@@
  		 * we can avoid needless calls ->d_automount() and avoid
  		 * an incorrect ELOOP error return.
  		 */
++<<<<<<< HEAD
 +		if ((!d_mountpoint(dentry) && !simple_empty(dentry)) ||
 +		    (dentry->d_inode && S_ISLNK(dentry->d_inode->i_mode)))
++=======
+ 		if ((!path_is_mountpoint(path) && !simple_empty(dentry)) ||
+ 		    (d_really_is_positive(dentry) && d_is_symlink(dentry)))
++>>>>>>> cfaf86ab6ccd (autofs: use path_is_mountpoint() to fix unreliable d_mountpoint() checks)
  			status = -EISDIR;
  	}
  	spin_unlock(&sbi->fs_lock);
* Unmerged path fs/autofs4/root.c
