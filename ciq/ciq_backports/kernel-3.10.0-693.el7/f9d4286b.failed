arch/powerpc: Update parameters for csum_tcpudp_magic & csum_tcpudp_nofold

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [powerpc] Update parameters for csum_tcpudp_magic & csum_tcpudp_nofold (Gustavo Duarte) [1430834]
Rebuild_FUZZ: 89.55%
commit-author Ivan Vecera <ivecera@redhat.com>
commit f9d4286b9516b02e795214412d36885f572b57ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f9d4286b.failed

Commit 01cfbad "ipv4: Update parameters for csum_tcpudp_magic to their
original types" changed parameters for csum_tcpudp_magic and
csum_tcpudp_nofold for many platforms but not for PowerPC.

Fixes: 01cfbad "ipv4: Update parameters for csum_tcpudp_magic to their original types"
	Cc: Alexander Duyck <aduyck@mirantis.com>
	Signed-off-by: Ivan Vecera <ivecera@redhat.com>
	Acked-by: Alexander Duyck <alexander.h.duyck@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f9d4286b9516b02e795214412d36885f572b57ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/checksum.h
diff --cc arch/powerpc/include/asm/checksum.h
index 0ffd793cff0f,1e8fceb308a5..000000000000
--- a/arch/powerpc/include/asm/checksum.h
+++ b/arch/powerpc/include/asm/checksum.h
@@@ -83,19 -53,8 +83,24 @@@ static inline __sum16 csum_fold(__wsum 
  	return (__force __sum16)(~((__force u32)sum + tmp) >> 16);
  }
  
++<<<<<<< HEAD
 +/*
 + * this routine is used for miscellaneous IP-like checksums, mainly
 + * in icmp.c
 + */
 +static inline __sum16 ip_compute_csum(const void *buff, int len)
 +{
 +	return csum_fold(csum_partial(buff, len, 0));
 +}
 +
 +static inline __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr,
 +                                     unsigned short len,
 +                                     unsigned short proto,
 +                                     __wsum sum)
++=======
+ static inline __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr, __u32 len,
+ 					__u8 proto, __wsum sum)
++>>>>>>> f9d4286b9516 (arch/powerpc: Update parameters for csum_tcpudp_magic & csum_tcpudp_nofold)
  {
  #ifdef __powerpc64__
  	unsigned long s = (__force u32)sum;
@@@ -118,6 -77,132 +123,135 @@@
  #endif
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * computes the checksum of the TCP/UDP pseudo-header
+  * returns a 16-bit checksum, already complemented
+  */
+ static inline __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr, __u32 len,
+ 					__u8 proto, __wsum sum)
+ {
+ 	return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));
+ }
+ 
+ #define HAVE_ARCH_CSUM_ADD
+ static inline __wsum csum_add(__wsum csum, __wsum addend)
+ {
+ #ifdef __powerpc64__
+ 	u64 res = (__force u64)csum;
+ #endif
+ 	if (__builtin_constant_p(csum) && csum == 0)
+ 		return addend;
+ 	if (__builtin_constant_p(addend) && addend == 0)
+ 		return csum;
+ 
+ #ifdef __powerpc64__
+ 	res += (__force u64)addend;
+ 	return (__force __wsum)((u32)res + (res >> 32));
+ #else
+ 	asm("addc %0,%0,%1;"
+ 	    "addze %0,%0;"
+ 	    : "+r" (csum) : "r" (addend) : "xer");
+ 	return csum;
+ #endif
+ }
+ 
+ /*
+  * This is a version of ip_compute_csum() optimized for IP headers,
+  * which always checksum on 4 octet boundaries.  ihl is the number
+  * of 32-bit words and is always >= 5.
+  */
+ static inline __wsum ip_fast_csum_nofold(const void *iph, unsigned int ihl)
+ {
+ 	const u32 *ptr = (const u32 *)iph + 1;
+ #ifdef __powerpc64__
+ 	unsigned int i;
+ 	u64 s = *(const u32 *)iph;
+ 
+ 	for (i = 0; i < ihl - 1; i++, ptr++)
+ 		s += *ptr;
+ 	s += (s >> 32);
+ 	return (__force __wsum)s;
+ #else
+ 	__wsum sum, tmp;
+ 
+ 	asm("mtctr %3;"
+ 	    "addc %0,%4,%5;"
+ 	    "1: lwzu %1, 4(%2);"
+ 	    "adde %0,%0,%1;"
+ 	    "bdnz 1b;"
+ 	    "addze %0,%0;"
+ 	    : "=r" (sum), "=r" (tmp), "+b" (ptr)
+ 	    : "r" (ihl - 2), "r" (*(const u32 *)iph), "r" (*ptr)
+ 	    : "ctr", "xer", "memory");
+ 
+ 	return sum;
+ #endif
+ }
+ 
+ static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
+ {
+ 	return csum_fold(ip_fast_csum_nofold(iph, ihl));
+ }
+ 
+ /*
+  * computes the checksum of a memory block at buff, length len,
+  * and adds in "sum" (32-bit)
+  *
+  * returns a 32-bit number suitable for feeding into itself
+  * or csum_tcpudp_magic
+  *
+  * this function must be called with even lengths, except
+  * for the last fragment, which may be odd
+  *
+  * it's best to have buff aligned on a 32-bit boundary
+  */
+ __wsum __csum_partial(const void *buff, int len, __wsum sum);
+ 
+ static inline __wsum csum_partial(const void *buff, int len, __wsum sum)
+ {
+ 	if (__builtin_constant_p(len) && len <= 16 && (len & 1) == 0) {
+ 		if (len == 2)
+ 			sum = csum_add(sum, (__force __wsum)*(const u16 *)buff);
+ 		if (len >= 4)
+ 			sum = csum_add(sum, (__force __wsum)*(const u32 *)buff);
+ 		if (len == 6)
+ 			sum = csum_add(sum, (__force __wsum)
+ 					    *(const u16 *)(buff + 4));
+ 		if (len >= 8)
+ 			sum = csum_add(sum, (__force __wsum)
+ 					    *(const u32 *)(buff + 4));
+ 		if (len == 10)
+ 			sum = csum_add(sum, (__force __wsum)
+ 					    *(const u16 *)(buff + 8));
+ 		if (len >= 12)
+ 			sum = csum_add(sum, (__force __wsum)
+ 					    *(const u32 *)(buff + 8));
+ 		if (len == 14)
+ 			sum = csum_add(sum, (__force __wsum)
+ 					    *(const u16 *)(buff + 12));
+ 		if (len >= 16)
+ 			sum = csum_add(sum, (__force __wsum)
+ 					    *(const u32 *)(buff + 12));
+ 	} else if (__builtin_constant_p(len) && (len & 3) == 0) {
+ 		sum = csum_add(sum, ip_fast_csum_nofold(buff, len >> 2));
+ 	} else {
+ 		sum = __csum_partial(buff, len, sum);
+ 	}
+ 	return sum;
+ }
+ 
+ /*
+  * this routine is used for miscellaneous IP-like checksums, mainly
+  * in icmp.c
+  */
+ static inline __sum16 ip_compute_csum(const void *buff, int len)
+ {
+ 	return csum_fold(csum_partial(buff, len, 0));
+ }
+ 
++>>>>>>> f9d4286b9516 (arch/powerpc: Update parameters for csum_tcpudp_magic & csum_tcpudp_nofold)
  #endif
  #endif /* __KERNEL__ */
  #endif
* Unmerged path arch/powerpc/include/asm/checksum.h
