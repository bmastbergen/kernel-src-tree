vfs: guard end of device for mpage interface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Akinobu Mita <akinobu.mita@gmail.com>
commit 4db96b71e3caea5bb39053d57683129e0682c66f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4db96b71.failed

Add guard_bio_eod() check for mpage code in order to allow us to do IO
even on the odd last sectors of a device, even if the block size is some
multiple of the physical sector size.

Using mpage_readpages() for block device requires this guard check.

	Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
	Cc: Jens Axboe <axboe@kernel.dk>
	Cc: Alexander Viro <viro@zeniv.linux.org.uk>
	Cc: Jeff Moyer <jmoyer@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 4db96b71e3caea5bb39053d57683129e0682c66f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/buffer.c
diff --cc fs/buffer.c
index ace86fe2bca8,7bd5c4685e98..000000000000
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@@ -2941,10 -2966,11 +2941,14 @@@ static void end_bio_bh_io_sync(struct b
   * errors, this only handles the "we need to be able to
   * do IO at the final sector" case.
   */
++<<<<<<< HEAD
 +static void guard_bh_eod(int rw, struct bio *bio, struct buffer_head *bh)
++=======
+ void guard_bio_eod(int rw, struct bio *bio)
++>>>>>>> 4db96b71e3ca (vfs: guard end of device for mpage interface)
  {
  	sector_t maxsector;
 -	struct bio_vec *bvec = &bio->bi_io_vec[bio->bi_vcnt - 1];
 -	unsigned truncated_bytes;
 +	unsigned bytes;
  
  	maxsector = i_size_read(bio->bi_bdev->bd_inode) >> 9;
  	if (!maxsector)
* Unmerged path fs/buffer.c
diff --git a/fs/internal.h b/fs/internal.h
index 3b41f3e8a80a..a604ab589655 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -36,6 +36,11 @@ static inline int __sync_blockdev(struct block_device *bdev, int wait)
 }
 #endif
 
+/*
+ * buffer.c
+ */
+extern void guard_bio_eod(int rw, struct bio *bio);
+
 /*
  * char_dev.c
  */
diff --git a/fs/mpage.c b/fs/mpage.c
index 9a5c19c68127..5f69658231ea 100644
--- a/fs/mpage.c
+++ b/fs/mpage.c
@@ -28,6 +28,7 @@
 #include <linux/backing-dev.h>
 #include <linux/pagevec.h>
 #include <linux/cleancache.h>
+#include "internal.h"
 
 /*
  * I/O completion handler for multipage BIOs.
@@ -57,6 +58,7 @@ static void mpage_end_io(struct bio *bio, int err)
 static struct bio *mpage_bio_submit(int rw, struct bio *bio)
 {
 	bio->bi_end_io = mpage_end_io;
+	guard_bio_eod(rw, bio);
 	submit_bio(rw, bio);
 	return NULL;
 }
