qeth: add layer 2 RX/TX checksum offloading

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Thomas Richter <tmricht@linux.vnet.ibm.com>
commit 4d7def2a12386dbf56443016114c187df50e3442
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4d7def2a.failed

Checksum offloading for send and receive is already
supported for layer 3 (IP layer). This patch
adds support for RX and TX hardware checksum offloading
for layer 2 (MAC layer). The hardware calculates the checksum
for IP UDP and TCP packets.

This patch moves the hardware checksum offloading setup
to the set of common functions in qeth_core_main.c.
Layer 2 and layer 3 now simply call the same common functions.

Also note that TX checksum offloading is always enabled.
The device driver relies on the TCP/IP stack to make use of
this feature.

	Signed-off-by: Thomas Richter <tmricht@linux.vnet.ibm.com>
	Signed-off-by: Ursula Braun <ursula.braun@de.ibm.com>
	Reviewed-by: Eugene Crosser <Eugene.Crosser@ru.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4d7def2a12386dbf56443016114c187df50e3442)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_l2_main.c
#	drivers/s390/net/qeth_l3_main.c
diff --cc drivers/s390/net/qeth_l2_main.c
index 87b4499b880d,dc905b37aa12..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -240,8 -252,25 +240,25 @@@ static inline int qeth_l2_get_cast_type
  	return RTN_UNSPEC;
  }
  
+ static inline void qeth_l2_hdr_csum(struct qeth_card *card,
+ 				    struct qeth_hdr *hdr, struct sk_buff *skb)
+ {
+ 	struct iphdr *iph = ip_hdr(skb);
+ 
+ 	/* tcph->check contains already the pseudo hdr checksum
+ 	 * so just set the header flags
+ 	 */
+ 	if (iph->protocol == IPPROTO_UDP)
+ 		hdr->hdr.l2.flags[1] |= QETH_HDR_EXT_UDP;
+ 	hdr->hdr.l2.flags[1] |= QETH_HDR_EXT_CSUM_TRANSP_REQ |
+ 		QETH_HDR_EXT_CSUM_HDR_REQ;
+ 	iph->check = 0;
+ 	if (card->options.performance_stats)
+ 		card->perf_stats.tx_csum++;
+ }
+ 
  static void qeth_l2_fill_header(struct qeth_card *card, struct qeth_hdr *hdr,
 -			struct sk_buff *skb, int cast_type)
 +			struct sk_buff *skb, int ipv, int cast_type)
  {
  	struct vlan_ethhdr *veth = (struct vlan_ethhdr *)skb_mac_header(skb);
  
@@@ -367,13 -404,43 +384,49 @@@ static int qeth_l2_vlan_rx_kill_vid(str
  		kfree(tmpid);
  	}
  	qeth_l2_set_multicast_list(card->dev);
 -	return rc;
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static int qeth_l2_stop_card(struct qeth_card *card, int recovery_mode)
++=======
+ static netdev_features_t qeth_l2_fix_features(struct net_device *dev,
+ 					      netdev_features_t features)
+ {
+ 	struct qeth_card *card = dev->ml_priv;
+ 
+ 	QETH_DBF_TEXT(SETUP, 2, "fixfeat");
+ 	if (!qeth_is_supported(card, IPA_OUTBOUND_CHECKSUM))
+ 		features &= ~NETIF_F_IP_CSUM;
+ 	if (!qeth_is_supported(card, IPA_INBOUND_CHECKSUM))
+ 		features &= ~NETIF_F_RXCSUM;
+ 	QETH_DBF_HEX(SETUP, 2, &features, sizeof(features));
+ 	return features;
+ }
+ 
+ static int qeth_l2_set_features(struct net_device *dev,
+ 				netdev_features_t features)
+ {
+ 	struct qeth_card *card = dev->ml_priv;
+ 	netdev_features_t changed = dev->features ^ features;
+ 
+ 	QETH_DBF_TEXT(SETUP, 2, "setfeat");
+ 	QETH_DBF_HEX(SETUP, 2, &features, sizeof(features));
+ 
+ 	if (card->state == CARD_STATE_DOWN ||
+ 	    card->state == CARD_STATE_RECOVER)
+ 		return 0;
+ 
+ 	if (!(changed & NETIF_F_RXCSUM))
+ 		return 0;
+ 	return qeth_set_rx_csum(card, features & NETIF_F_RXCSUM ? 1 : 0);
+ }
+ 
+ static void qeth_l2_stop_card(struct qeth_card *card, int recovery_mode)
++>>>>>>> 4d7def2a1238 (qeth: add layer 2 RX/TX checksum offloading)
  {
 +	int rc = 0;
 +
  	QETH_DBF_TEXT(SETUP , 2, "stopcard");
  	QETH_DBF_HEX(SETUP, 2, &card, sizeof(void *));
  
@@@ -809,7 -859,9 +870,13 @@@ static int qeth_l2_hard_start_xmit(stru
  			hdr = (struct qeth_hdr *)skb_push(new_skb,
  						sizeof(struct qeth_hdr));
  			skb_set_mac_header(new_skb, sizeof(struct qeth_hdr));
++<<<<<<< HEAD
 +			qeth_l2_fill_header(card, hdr, new_skb, ipv, cast_type);
++=======
+ 			qeth_l2_fill_header(card, hdr, new_skb, cast_type);
+ 			if (new_skb->ip_summed == CHECKSUM_PARTIAL)
+ 				qeth_l2_hdr_csum(card, hdr, new_skb);
++>>>>>>> 4d7def2a1238 (qeth: add layer 2 RX/TX checksum offloading)
  		}
  	}
  
@@@ -999,11 -1054,15 +1068,16 @@@ static int qeth_l2_setup_netdev(struct 
  	card->dev->watchdog_timeo = QETH_TX_TIMEOUT;
  	card->dev->mtu = card->info.initial_mtu;
  	card->dev->netdev_ops = &qeth_l2_netdev_ops;
 -	card->dev->ethtool_ops =
 -		(card->info.type != QETH_CARD_TYPE_OSN) ?
 -		&qeth_l2_ethtool_ops : &qeth_l2_osn_ops;
 +	if (card->info.type != QETH_CARD_TYPE_OSN)
 +		SET_ETHTOOL_OPS(card->dev, &qeth_l2_ethtool_ops);
 +	else
 +		SET_ETHTOOL_OPS(card->dev, &qeth_l2_osn_ops);
  	card->dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
+ 	if (card->info.type == QETH_CARD_TYPE_OSD && !card->info.guestlan) {
+ 		card->dev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM;
+ 		/* Turn on RX offloading per default */
+ 		card->dev->features |= NETIF_F_RXCSUM;
+ 	}
  	card->info.broadcast_capable = 1;
  	qeth_l2_request_initial_mac(card);
  	SET_NETDEV_DEV(card->dev, &card->gdev->dev);
@@@ -1460,8 -1525,8 +1541,13 @@@ static void qeth_bridge_emit_host_event
  			env[i] = str[i]; i++;
  		}
  		if (code & IPA_ADDR_CHANGE_CODE_MACADDR) {
++<<<<<<< HEAD
 +			snprintf(str[i], sizeof(str[i]), "MAC=%pM6",
 +				&addr_lnid->mac);
++=======
+ 			snprintf(str[i], sizeof(str[i]), "MAC=%pM",
+ 				addr_lnid->mac);
++>>>>>>> 4d7def2a1238 (qeth: add layer 2 RX/TX checksum offloading)
  			env[i] = str[i]; i++;
  		}
  		snprintf(str[i], sizeof(str[i]), "NTOK_BUSID=%x.%x.%04x",
diff --cc drivers/s390/net/qeth_l3_main.c
index 460eb41bbb92,543960e96b42..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -1090,29 -1075,14 +1069,38 @@@ static int qeth_l3_send_simple_setasspa
  	QETH_CARD_TEXT(card, 4, "simassp6");
  	iob = qeth_l3_get_setassparms_cmd(card, ipa_func, cmd_code,
  				       0, QETH_PROT_IPV6);
++<<<<<<< HEAD
 +	rc = qeth_l3_send_setassparms(card, iob, 0, 0,
++=======
+ 	if (!iob)
+ 		return -ENOMEM;
+ 	rc = qeth_send_setassparms(card, iob, 0, 0,
++>>>>>>> 4d7def2a1238 (qeth: add layer 2 RX/TX checksum offloading)
  				   qeth_l3_default_setassparms_cb, NULL);
  	return rc;
  }
  #endif
  
++<<<<<<< HEAD
 +static int qeth_l3_send_simple_setassparms(struct qeth_card *card,
 +		enum qeth_ipa_funcs ipa_func, __u16 cmd_code, long data)
 +{
 +	int rc;
 +	int length = 0;
 +	struct qeth_cmd_buffer *iob;
 +
 +	QETH_CARD_TEXT(card, 4, "simassp4");
 +	if (data)
 +		length = sizeof(__u32);
 +	iob = qeth_l3_get_setassparms_cmd(card, ipa_func, cmd_code,
 +				       length, QETH_PROT_IPV4);
 +	rc = qeth_l3_send_setassparms(card, iob, length, data,
 +				   qeth_l3_default_setassparms_cb, NULL);
 +	return rc;
 +}
 +
++=======
++>>>>>>> 4d7def2a1238 (qeth: add layer 2 RX/TX checksum offloading)
  static int qeth_l3_start_ipa_arp_processing(struct qeth_card *card)
  {
  	int rc;
@@@ -2535,7 -2443,9 +2456,13 @@@ static int qeth_l3_arp_add_entry(struc
  				       IPA_CMD_ASS_ARP_ADD_ENTRY,
  				       sizeof(struct qeth_arp_cache_entry),
  				       QETH_PROT_IPV4);
++<<<<<<< HEAD
 +	rc = qeth_l3_send_setassparms(card, iob,
++=======
+ 	if (!iob)
+ 		return -ENOMEM;
+ 	rc = qeth_send_setassparms(card, iob,
++>>>>>>> 4d7def2a1238 (qeth: add layer 2 RX/TX checksum offloading)
  				   sizeof(struct qeth_arp_cache_entry),
  				   (unsigned long) entry,
  				   qeth_l3_default_setassparms_cb, NULL);
@@@ -2574,7 -2484,9 +2501,13 @@@ static int qeth_l3_arp_remove_entry(str
  				       IPA_CMD_ASS_ARP_REMOVE_ENTRY,
  				       12,
  				       QETH_PROT_IPV4);
++<<<<<<< HEAD
 +	rc = qeth_l3_send_setassparms(card, iob,
++=======
+ 	if (!iob)
+ 		return -ENOMEM;
+ 	rc = qeth_send_setassparms(card, iob,
++>>>>>>> 4d7def2a1238 (qeth: add layer 2 RX/TX checksum offloading)
  				   12, (unsigned long)buf,
  				   qeth_l3_default_setassparms_cb, NULL);
  	if (rc) {
diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h
index 2df51659febe..157aef23a1a6 100644
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -984,6 +984,15 @@ int qeth_hw_trap(struct qeth_card *, enum qeth_diags_trap_action);
 int qeth_query_ipassists(struct qeth_card *, enum qeth_prot_versions prot);
 void qeth_trace_features(struct qeth_card *);
 void qeth_close_dev(struct qeth_card *);
+int qeth_send_simple_setassparms(struct qeth_card *, enum qeth_ipa_funcs,
+				 __u16, long);
+int qeth_send_setassparms(struct qeth_card *, struct qeth_cmd_buffer *, __u16,
+			  long,
+			  int (*reply_cb)(struct qeth_card *,
+					  struct qeth_reply *, unsigned long),
+			  void *);
+int qeth_start_ipa_tx_checksum(struct qeth_card *);
+int qeth_set_rx_csum(struct qeth_card *, int);
 
 /* exports for OSN */
 int qeth_osn_assist(struct net_device *, void *, int);
diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c
index 3c6d072961cd..d08e5a84be67 100644
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -4891,13 +4891,11 @@ static void qeth_core_free_card(struct qeth_card *card)
 void qeth_trace_features(struct qeth_card *card)
 {
 	QETH_CARD_TEXT(card, 2, "features");
-	QETH_CARD_TEXT_(card, 2, "%x", card->options.ipa4.supported_funcs);
-	QETH_CARD_TEXT_(card, 2, "%x", card->options.ipa4.enabled_funcs);
-	QETH_CARD_TEXT_(card, 2, "%x", card->options.ipa6.supported_funcs);
-	QETH_CARD_TEXT_(card, 2, "%x", card->options.ipa6.enabled_funcs);
-	QETH_CARD_TEXT_(card, 2, "%x", card->options.adp.supported_funcs);
-	QETH_CARD_TEXT_(card, 2, "%x", card->options.adp.enabled_funcs);
-	QETH_CARD_TEXT_(card, 2, "%x", card->info.diagass_support);
+	QETH_CARD_HEX(card, 2, &card->options.ipa4, sizeof(card->options.ipa4));
+	QETH_CARD_HEX(card, 2, &card->options.ipa6, sizeof(card->options.ipa6));
+	QETH_CARD_HEX(card, 2, &card->options.adp, sizeof(card->options.adp));
+	QETH_CARD_HEX(card, 2, &card->info.diagass_support,
+		      sizeof(card->info.diagass_support));
 }
 EXPORT_SYMBOL_GPL(qeth_trace_features);
 
@@ -4996,6 +4994,7 @@ retriable:
 	}
 
 	card->options.ipa4.supported_funcs = 0;
+	card->options.ipa6.supported_funcs = 0;
 	card->options.adp.supported_funcs = 0;
 	card->options.sbp.supported_funcs = 0;
 	card->info.diagass_support = 0;
@@ -5164,6 +5163,102 @@ no_mem:
 }
 EXPORT_SYMBOL_GPL(qeth_core_get_next_skb);
 
+static int qeth_setassparms_cb(struct qeth_card *card,
+			       struct qeth_reply *reply, unsigned long data)
+{
+	struct qeth_ipa_cmd *cmd;
+
+	QETH_CARD_TEXT(card, 4, "defadpcb");
+
+	cmd = (struct qeth_ipa_cmd *) data;
+	if (cmd->hdr.return_code == 0) {
+		cmd->hdr.return_code = cmd->data.setassparms.hdr.return_code;
+		if (cmd->hdr.prot_version == QETH_PROT_IPV4)
+			card->options.ipa4.enabled_funcs = cmd->hdr.ipa_enabled;
+		if (cmd->hdr.prot_version == QETH_PROT_IPV6)
+			card->options.ipa6.enabled_funcs = cmd->hdr.ipa_enabled;
+	}
+	if (cmd->data.setassparms.hdr.assist_no == IPA_INBOUND_CHECKSUM &&
+	    cmd->data.setassparms.hdr.command_code == IPA_CMD_ASS_START) {
+		card->info.csum_mask = cmd->data.setassparms.data.flags_32bit;
+		QETH_CARD_TEXT_(card, 3, "csum:%d", card->info.csum_mask);
+	}
+	if (cmd->data.setassparms.hdr.assist_no == IPA_OUTBOUND_CHECKSUM &&
+	    cmd->data.setassparms.hdr.command_code == IPA_CMD_ASS_START) {
+		card->info.tx_csum_mask =
+			cmd->data.setassparms.data.flags_32bit;
+		QETH_CARD_TEXT_(card, 3, "tcsu:%d", card->info.tx_csum_mask);
+	}
+
+	return 0;
+}
+
+static struct qeth_cmd_buffer *qeth_get_setassparms_cmd(struct qeth_card *card,
+						  enum qeth_ipa_funcs ipa_func,
+						  __u16 cmd_code, __u16 len,
+						  enum qeth_prot_versions prot)
+{
+	struct qeth_cmd_buffer *iob;
+	struct qeth_ipa_cmd *cmd;
+
+	QETH_CARD_TEXT(card, 4, "getasscm");
+	iob = qeth_get_ipacmd_buffer(card, IPA_CMD_SETASSPARMS, prot);
+
+	if (iob) {
+		cmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);
+		cmd->data.setassparms.hdr.assist_no = ipa_func;
+		cmd->data.setassparms.hdr.length = 8 + len;
+		cmd->data.setassparms.hdr.command_code = cmd_code;
+		cmd->data.setassparms.hdr.return_code = 0;
+		cmd->data.setassparms.hdr.seq_no = 0;
+	}
+
+	return iob;
+}
+
+int qeth_send_setassparms(struct qeth_card *card,
+			  struct qeth_cmd_buffer *iob, __u16 len, long data,
+			  int (*reply_cb)(struct qeth_card *,
+					  struct qeth_reply *, unsigned long),
+			  void *reply_param)
+{
+	int rc;
+	struct qeth_ipa_cmd *cmd;
+
+	QETH_CARD_TEXT(card, 4, "sendassp");
+
+	cmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);
+	if (len <= sizeof(__u32))
+		cmd->data.setassparms.data.flags_32bit = (__u32) data;
+	else   /* (len > sizeof(__u32)) */
+		memcpy(&cmd->data.setassparms.data, (void *) data, len);
+
+	rc = qeth_send_ipa_cmd(card, iob, reply_cb, reply_param);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(qeth_send_setassparms);
+
+int qeth_send_simple_setassparms(struct qeth_card *card,
+				 enum qeth_ipa_funcs ipa_func,
+				 __u16 cmd_code, long data)
+{
+	int rc;
+	int length = 0;
+	struct qeth_cmd_buffer *iob;
+
+	QETH_CARD_TEXT(card, 4, "simassp4");
+	if (data)
+		length = sizeof(__u32);
+	iob = qeth_get_setassparms_cmd(card, ipa_func, cmd_code,
+				       length, QETH_PROT_IPV4);
+	if (!iob)
+		return -ENOMEM;
+	rc = qeth_send_setassparms(card, iob, length, data,
+				   qeth_setassparms_cb, NULL);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(qeth_send_simple_setassparms);
+
 static void qeth_unregister_dbf_views(void)
 {
 	int x;
@@ -5848,6 +5943,75 @@ int qeth_core_ethtool_get_settings(struct net_device *netdev,
 }
 EXPORT_SYMBOL_GPL(qeth_core_ethtool_get_settings);
 
+static int qeth_send_checksum_command(struct qeth_card *card)
+{
+	int rc;
+
+	rc = qeth_send_simple_setassparms(card, IPA_INBOUND_CHECKSUM,
+					  IPA_CMD_ASS_START, 0);
+	if (rc) {
+		dev_warn(&card->gdev->dev, "Starting HW checksumming for %s "
+			"failed, using SW checksumming\n",
+			QETH_CARD_IFNAME(card));
+		return rc;
+	}
+	rc = qeth_send_simple_setassparms(card, IPA_INBOUND_CHECKSUM,
+					  IPA_CMD_ASS_ENABLE,
+					  card->info.csum_mask);
+	if (rc) {
+		dev_warn(&card->gdev->dev, "Enabling HW checksumming for %s "
+			"failed, using SW checksumming\n",
+			QETH_CARD_IFNAME(card));
+		return rc;
+	}
+	return 0;
+}
+
+int qeth_set_rx_csum(struct qeth_card *card, int on)
+{
+	int rc;
+
+	if (on) {
+		rc = qeth_send_checksum_command(card);
+		if (rc)
+			return -EIO;
+		dev_info(&card->gdev->dev,
+			"HW Checksumming (inbound) enabled\n");
+	} else {
+		rc = qeth_send_simple_setassparms(card,
+			IPA_INBOUND_CHECKSUM, IPA_CMD_ASS_STOP, 0);
+		if (rc)
+			return -EIO;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(qeth_set_rx_csum);
+
+int qeth_start_ipa_tx_checksum(struct qeth_card *card)
+{
+	int rc = 0;
+
+	if (!qeth_is_supported(card, IPA_OUTBOUND_CHECKSUM))
+		return rc;
+	rc = qeth_send_simple_setassparms(card, IPA_OUTBOUND_CHECKSUM,
+					  IPA_CMD_ASS_START, 0);
+	if (rc)
+		goto err_out;
+	rc = qeth_send_simple_setassparms(card, IPA_OUTBOUND_CHECKSUM,
+					  IPA_CMD_ASS_ENABLE,
+					  card->info.tx_csum_mask);
+	if (rc)
+		goto err_out;
+
+	dev_info(&card->gdev->dev, "HW TX Checksumming enabled\n");
+	return rc;
+err_out:
+	dev_warn(&card->gdev->dev, "Enabling HW TX checksumming for %s "
+		"failed, using SW TX checksumming\n", QETH_CARD_IFNAME(card));
+	return rc;
+}
+EXPORT_SYMBOL_GPL(qeth_start_ipa_tx_checksum);
+
 static int __init qeth_core_init(void)
 {
 	int rc;
* Unmerged path drivers/s390/net/qeth_l2_main.c
* Unmerged path drivers/s390/net/qeth_l3_main.c
