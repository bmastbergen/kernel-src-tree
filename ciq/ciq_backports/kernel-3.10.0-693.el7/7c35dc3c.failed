HID: wacom: EKR: allocate one input node per remote

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: ekr: allocate one input node per remote (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 94.85%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 7c35dc3cd4d114019ed4b26cab313e253396d7c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7c35dc3c.failed

Thanks to devres, we can now afford to create more than one input node
without having to overload the remove/failure paths. Having one input
node per remote is something which should have been implemented from start
but the probability of having users with several remotes is quite low.
Anyway, still, better looking at the future and implement things properly.

Remote input nodes will be freed/unregistered magically as they are
created in the devres group &remote->remotes[index].

We need to open the hid node now that the remotes are dynamically
allocated.

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 7c35dc3cd4d114019ed4b26cab313e253396d7c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom.h
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom.h
index 87d2c48e3adc,393b5af871d9..000000000000
--- a/drivers/hid/wacom.h
+++ b/drivers/hid/wacom.h
@@@ -109,18 -106,40 +109,43 @@@ MODULE_LICENSE(DRIVER_LICENSE)
  #define USB_VENDOR_ID_WACOM	0x056a
  #define USB_VENDOR_ID_LENOVO	0x17ef
  
++<<<<<<< HEAD
++=======
+ enum wacom_worker {
+ 	WACOM_WORKER_WIRELESS,
+ 	WACOM_WORKER_BATTERY,
+ 	WACOM_WORKER_REMOTE,
+ };
+ 
+ struct wacom_group_leds {
+ 	u8 select; /* status led selector (0..3) */
+ };
+ 
+ struct wacom_remote {
+ 	spinlock_t remote_lock;
+ 	struct kfifo remote_fifo;
+ 	struct kobject *remote_dir;
+ 	struct {
+ 		struct attribute_group group;
+ 		u32 serial;
+ 		struct input_dev *input;
+ 		bool registered;
+ 	} remotes[WACOM_MAX_REMOTES];
+ };
+ 
++>>>>>>> 7c35dc3cd4d1 (HID: wacom: EKR: allocate one input node per remote)
  struct wacom {
 +	dma_addr_t data_dma;
  	struct usb_device *usbdev;
  	struct usb_interface *intf;
 +	struct urb *irq;
  	struct wacom_wac wacom_wac;
 -	struct hid_device *hdev;
  	struct mutex lock;
 -	struct work_struct wireless_work;
 -	struct work_struct battery_work;
 -	struct work_struct remote_work;
 -	struct wacom_remote *remote;
 -	struct wacom_leds {
 -		struct wacom_group_leds *groups;
 +	struct work_struct work;
 +	bool open;
 +	char phys[32];
 +	struct wacom_led {
 +		u8 select[2]; /* status led selector (0..3) */
  		u8 llv;       /* status led brightness no button (1..127) */
  		u8 hlv;       /* status led brightness button pressed (1..127) */
  		u8 img_lum;   /* OLED matrix display brightness */
diff --cc drivers/hid/wacom_sys.c
index e75b5002a526,f2f5b4b248cb..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1293,10 -1588,454 +1293,458 @@@ static void wacom_calculate_res(struct 
  						    features->unitExpo);
  }
  
 -void wacom_battery_work(struct work_struct *work)
 +static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *id)
  {
++<<<<<<< HEAD
++=======
+ 	struct wacom *wacom = container_of(work, struct wacom, battery_work);
+ 
+ 	if ((wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 	     !wacom->battery) {
+ 		wacom_initialize_battery(wacom);
+ 	}
+ 	else if (!(wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) &&
+ 		 wacom->battery) {
+ 		wacom_destroy_battery(wacom);
+ 	}
+ }
+ 
+ static size_t wacom_compute_pktlen(struct hid_device *hdev)
+ {
+ 	struct hid_report_enum *report_enum;
+ 	struct hid_report *report;
+ 	size_t size = 0;
+ 
+ 	report_enum = hdev->report_enum + HID_INPUT_REPORT;
+ 
+ 	list_for_each_entry(report, &report_enum->report_list, list) {
+ 		size_t report_size = hid_report_len(report);
+ 		if (report_size > size)
+ 			size = report_size;
+ 	}
+ 
+ 	return size;
+ }
+ 
+ static void wacom_update_name(struct wacom *wacom, const char *suffix)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	char name[WACOM_NAME_MAX];
+ 
+ 	/* Generic devices name unspecified */
+ 	if ((features->type == HID_GENERIC) && !strcmp("Wacom HID", features->name)) {
+ 		if (strstr(wacom->hdev->name, "Wacom") ||
+ 		    strstr(wacom->hdev->name, "wacom") ||
+ 		    strstr(wacom->hdev->name, "WACOM")) {
+ 			/* name is in HID descriptor, use it */
+ 			strlcpy(name, wacom->hdev->name, sizeof(name));
+ 
+ 			/* strip out excess whitespaces */
+ 			while (1) {
+ 				char *gap = strstr(name, "  ");
+ 				if (gap == NULL)
+ 					break;
+ 				/* shift everything including the terminator */
+ 				memmove(gap, gap+1, strlen(gap));
+ 			}
+ 			/* get rid of trailing whitespace */
+ 			if (name[strlen(name)-1] == ' ')
+ 				name[strlen(name)-1] = '\0';
+ 		} else {
+ 			/* no meaningful name retrieved. use product ID */
+ 			snprintf(name, sizeof(name),
+ 				 "%s %X", features->name, wacom->hdev->product);
+ 		}
+ 	} else {
+ 		strlcpy(name, features->name, sizeof(name));
+ 	}
+ 
+ 	/* Append the device type to the name */
+ 	snprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),
+ 		"%s%s Pen", name, suffix);
+ 	snprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),
+ 		"%s%s Finger", name, suffix);
+ 	snprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),
+ 		"%s%s Pad", name, suffix);
+ }
+ 
+ static void wacom_release_resources(struct wacom *wacom)
+ {
+ 	struct hid_device *hdev = wacom->hdev;
+ 
+ 	if (!wacom->resources)
+ 		return;
+ 
+ 	devres_release_group(&hdev->dev, wacom);
+ 
+ 	wacom->resources = false;
+ 
+ 	wacom->wacom_wac.pen_input = NULL;
+ 	wacom->wacom_wac.touch_input = NULL;
+ 	wacom->wacom_wac.pad_input = NULL;
+ }
+ 
+ static int wacom_parse_and_register(struct wacom *wacom, bool wireless)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	struct hid_device *hdev = wacom->hdev;
+ 	int error;
+ 	unsigned int connect_mask = HID_CONNECT_HIDRAW;
+ 
+ 	features->pktlen = wacom_compute_pktlen(hdev);
+ 	if (features->pktlen > WACOM_PKGLEN_MAX)
+ 		return -EINVAL;
+ 
+ 	if (!devres_open_group(&hdev->dev, wacom, GFP_KERNEL))
+ 		return -ENOMEM;
+ 
+ 	wacom->resources = true;
+ 
+ 	error = wacom_allocate_inputs(wacom);
+ 	if (error)
+ 		goto fail;
+ 
+ 	/*
+ 	 * Bamboo Pad has a generic hid handling for the Pen, and we switch it
+ 	 * into debug mode for the touch part.
+ 	 * We ignore the other interfaces.
+ 	 */
+ 	if (features->type == BAMBOO_PAD) {
+ 		if (features->pktlen == WACOM_PKGLEN_PENABLED) {
+ 			features->type = HID_GENERIC;
+ 		} else if ((features->pktlen != WACOM_PKGLEN_BPAD_TOUCH) &&
+ 			   (features->pktlen != WACOM_PKGLEN_BPAD_TOUCH_USB)) {
+ 			error = -ENODEV;
+ 			goto fail;
+ 		}
+ 	}
+ 
+ 	/* set the default size in case we do not get them from hid */
+ 	wacom_set_default_phy(features);
+ 
+ 	/* Retrieve the physical and logical size for touch devices */
+ 	wacom_retrieve_hid_descriptor(hdev, features);
+ 	wacom_setup_device_quirks(wacom);
+ 
+ 	if (features->device_type == WACOM_DEVICETYPE_NONE &&
+ 	    features->type != WIRELESS) {
+ 		error = features->type == HID_GENERIC ? -ENODEV : 0;
+ 
+ 		dev_warn(&hdev->dev, "Unknown device_type for '%s'. %s.",
+ 			 hdev->name,
+ 			 error ? "Ignoring" : "Assuming pen");
+ 
+ 		if (error)
+ 			goto fail;
+ 
+ 		features->device_type |= WACOM_DEVICETYPE_PEN;
+ 	}
+ 
+ 	wacom_calculate_res(features);
+ 
+ 	wacom_update_name(wacom, wireless ? " (WL)" : "");
+ 
+ 	error = wacom_add_shared_data(hdev);
+ 	if (error)
+ 		goto fail;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_WL_MONITOR) &&
+ 	     (features->quirks & WACOM_QUIRK_BATTERY)) {
+ 		error = wacom_initialize_battery(wacom);
+ 		if (error)
+ 			goto fail;
+ 	}
+ 
+ 	error = wacom_register_inputs(wacom);
+ 	if (error)
+ 		goto fail;
+ 
+ 	if (wacom->wacom_wac.features.device_type & WACOM_DEVICETYPE_PAD) {
+ 		error = wacom_initialize_leds(wacom);
+ 		if (error)
+ 			goto fail;
+ 
+ 		error = wacom_initialize_remotes(wacom);
+ 		if (error)
+ 			goto fail;
+ 	}
+ 
+ 	if (features->type == HID_GENERIC)
+ 		connect_mask |= HID_CONNECT_DRIVER;
+ 
+ 	/* Regular HID work starts now */
+ 	error = hid_hw_start(hdev, connect_mask);
+ 	if (error) {
+ 		hid_err(hdev, "hw start failed\n");
+ 		goto fail;
+ 	}
+ 
+ 	if (!wireless) {
+ 		/* Note that if query fails it is not a hard failure */
+ 		wacom_query_tablet_data(hdev, features);
+ 	}
+ 
+ 	/* touch only Bamboo doesn't support pen */
+ 	if ((features->type == BAMBOO_TOUCH) &&
+ 	    (features->device_type & WACOM_DEVICETYPE_PEN)) {
+ 		error = -ENODEV;
+ 		goto fail_quirks;
+ 	}
+ 
+ 	/* pen only Bamboo neither support touch nor pad */
+ 	if ((features->type == BAMBOO_PEN) &&
+ 	    ((features->device_type & WACOM_DEVICETYPE_TOUCH) ||
+ 	    (features->device_type & WACOM_DEVICETYPE_PAD))) {
+ 		error = -ENODEV;
+ 		goto fail_quirks;
+ 	}
+ 
+ 	if (features->device_type & WACOM_DEVICETYPE_WL_MONITOR)
+ 		error = hid_hw_open(hdev);
+ 
+ 	if ((wacom_wac->features.type == INTUOSHT ||
+ 	     wacom_wac->features.type == INTUOSHT2) &&
+ 	    (wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH)) {
+ 		wacom_wac->shared->type = wacom_wac->features.type;
+ 		wacom_wac->shared->touch_input = wacom_wac->touch_input;
+ 	}
+ 
+ 	devres_close_group(&hdev->dev, wacom);
+ 
+ 	return 0;
+ 
+ fail_quirks:
+ 	hid_hw_stop(hdev);
+ fail:
+ 	wacom_release_resources(wacom);
+ 	return error;
+ }
+ 
+ static void wacom_wireless_work(struct work_struct *work)
+ {
+ 	struct wacom *wacom = container_of(work, struct wacom, wireless_work);
+ 	struct usb_device *usbdev = wacom->usbdev;
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_device *hdev1, *hdev2;
+ 	struct wacom *wacom1, *wacom2;
+ 	struct wacom_wac *wacom_wac1, *wacom_wac2;
+ 	int error;
+ 
+ 	/*
+ 	 * Regardless if this is a disconnect or a new tablet,
+ 	 * remove any existing input and battery devices.
+ 	 */
+ 
+ 	wacom_destroy_battery(wacom);
+ 
+ 	/* Stylus interface */
+ 	hdev1 = usb_get_intfdata(usbdev->config->interface[1]);
+ 	wacom1 = hid_get_drvdata(hdev1);
+ 	wacom_wac1 = &(wacom1->wacom_wac);
+ 	wacom_release_resources(wacom1);
+ 
+ 	/* Touch interface */
+ 	hdev2 = usb_get_intfdata(usbdev->config->interface[2]);
+ 	wacom2 = hid_get_drvdata(hdev2);
+ 	wacom_wac2 = &(wacom2->wacom_wac);
+ 	wacom_release_resources(wacom2);
+ 
+ 	if (wacom_wac->pid == 0) {
+ 		hid_info(wacom->hdev, "wireless tablet disconnected\n");
+ 	} else {
+ 		const struct hid_device_id *id = wacom_ids;
+ 
+ 		hid_info(wacom->hdev, "wireless tablet connected with PID %x\n",
+ 			 wacom_wac->pid);
+ 
+ 		while (id->bus) {
+ 			if (id->vendor == USB_VENDOR_ID_WACOM &&
+ 			    id->product == wacom_wac->pid)
+ 				break;
+ 			id++;
+ 		}
+ 
+ 		if (!id->bus) {
+ 			hid_info(wacom->hdev, "ignoring unknown PID.\n");
+ 			return;
+ 		}
+ 
+ 		/* Stylus interface */
+ 		wacom_wac1->features =
+ 			*((struct wacom_features *)id->driver_data);
+ 
+ 		wacom_wac1->pid = wacom_wac->pid;
+ 		hid_hw_stop(hdev1);
+ 		error = wacom_parse_and_register(wacom1, true);
+ 		if (error)
+ 			goto fail;
+ 
+ 		/* Touch interface */
+ 		if (wacom_wac1->features.touch_max ||
+ 		    (wacom_wac1->features.type >= INTUOSHT &&
+ 		    wacom_wac1->features.type <= BAMBOO_PT)) {
+ 			wacom_wac2->features =
+ 				*((struct wacom_features *)id->driver_data);
+ 			wacom_wac2->pid = wacom_wac->pid;
+ 			hid_hw_stop(hdev2);
+ 			error = wacom_parse_and_register(wacom2, true);
+ 			if (error)
+ 				goto fail;
+ 		}
+ 
+ 		error = wacom_initialize_battery(wacom);
+ 		if (error)
+ 			goto fail;
+ 	}
+ 
+ 	return;
+ 
+ fail:
+ 	wacom_release_resources(wacom1);
+ 	wacom_release_resources(wacom2);
+ 	return;
+ }
+ 
+ static void wacom_remote_destroy_one(struct wacom *wacom, unsigned int index)
+ {
+ 	struct wacom_remote *remote = wacom->remote;
+ 	u32 serial = remote->remotes[index].serial;
+ 	int i;
+ 	unsigned long flags;
+ 
+ 	spin_lock_irqsave(&remote->remote_lock, flags);
+ 	remote->remotes[index].registered = false;
+ 	spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 
+ 	if (remote->remotes[index].group.name)
+ 		devres_release_group(&wacom->hdev->dev,
+ 				     &remote->remotes[index]);
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		if (remote->remotes[i].serial == serial) {
+ 			remote->remotes[i].serial = 0;
+ 			remote->remotes[i].group.name = NULL;
+ 			remote->remotes[i].registered = false;
+ 			wacom->led.groups[i].select = WACOM_STATUS_UNKNOWN;
+ 		}
+ 	}
+ }
+ 
+ static int wacom_remote_create_one(struct wacom *wacom, u32 serial,
+ 				   unsigned int index)
+ {
+ 	struct wacom_remote *remote = wacom->remote;
+ 	struct device *dev = &wacom->hdev->dev;
+ 	int error, k;
+ 
+ 	/* A remote can pair more than once with an EKR,
+ 	 * check to make sure this serial isn't already paired.
+ 	 */
+ 	for (k = 0; k < WACOM_MAX_REMOTES; k++) {
+ 		if (remote->remotes[k].serial == serial)
+ 			break;
+ 	}
+ 
+ 	if (k < WACOM_MAX_REMOTES) {
+ 		remote->remotes[index].serial = serial;
+ 		return 0;
+ 	}
+ 
+ 	if (!devres_open_group(dev, &remote->remotes[index], GFP_KERNEL))
+ 		return -ENOMEM;
+ 
+ 	error = wacom_remote_create_attr_group(wacom, serial, index);
+ 	if (error)
+ 		goto fail;
+ 
+ 	remote->remotes[index].input = wacom_allocate_input(wacom);
+ 	if (!remote->remotes[index].input) {
+ 		error = -ENOMEM;
+ 		goto fail;
+ 	}
+ 	remote->remotes[index].input->uniq = remote->remotes[index].group.name;
+ 	remote->remotes[index].input->name = wacom->wacom_wac.pad_name;
+ 
+ 	if (!remote->remotes[index].input->name) {
+ 		error = -EINVAL;
+ 		goto fail;
+ 	}
+ 
+ 	error = wacom_setup_pad_input_capabilities(remote->remotes[index].input,
+ 						   &wacom->wacom_wac);
+ 	if (error)
+ 		goto fail;
+ 
+ 	remote->remotes[index].serial = serial;
+ 
+ 	error = input_register_device(remote->remotes[index].input);
+ 	if (error)
+ 		goto fail;
+ 
+ 	remote->remotes[index].registered = true;
+ 
+ 	devres_close_group(dev, &remote->remotes[index]);
+ 	return 0;
+ 
+ fail:
+ 	devres_release_group(dev, &remote->remotes[index]);
+ 	remote->remotes[index].serial = 0;
+ 	return error;
+ }
+ 
+ static void wacom_remote_work(struct work_struct *work)
+ {
+ 	struct wacom *wacom = container_of(work, struct wacom, remote_work);
+ 	struct wacom_remote *remote = wacom->remote;
+ 	struct wacom_remote_data data;
+ 	unsigned long flags;
+ 	unsigned int count;
+ 	u32 serial;
+ 	int i;
+ 
+ 	spin_lock_irqsave(&remote->remote_lock, flags);
+ 
+ 	count = kfifo_out(&remote->remote_fifo, &data, sizeof(data));
+ 
+ 	if (count != sizeof(data)) {
+ 		hid_err(wacom->hdev,
+ 			"workitem triggered without status available\n");
+ 		spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 		return;
+ 	}
+ 
+ 	if (!kfifo_is_empty(&remote->remote_fifo))
+ 		wacom_schedule_work(&wacom->wacom_wac, WACOM_WORKER_REMOTE);
+ 
+ 	spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		serial = data.remote[i].serial;
+ 		if (data.remote[i].connected) {
+ 
+ 			if (remote->remotes[i].serial == serial)
+ 				continue;
+ 
+ 			if (remote->remotes[i].serial)
+ 				wacom_remote_destroy_one(wacom, i);
+ 
+ 			wacom_remote_create_one(wacom, serial, i);
+ 
+ 		} else if (remote->remotes[i].serial) {
+ 			wacom_remote_destroy_one(wacom, i);
+ 		}
+ 	}
+ }
+ 
+ static int wacom_probe(struct hid_device *hdev,
+ 		const struct hid_device_id *id)
+ {
+ 	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
++>>>>>>> 7c35dc3cd4d1 (HID: wacom: EKR: allocate one input node per remote)
  	struct usb_device *dev = interface_to_usbdev(intf);
 +	struct usb_endpoint_descriptor *endpoint;
  	struct wacom *wacom;
  	struct wacom_wac *wacom_wac;
  	struct wacom_features *features;
diff --cc drivers/hid/wacom_wac.c
index 98c7d65145c2,99d688a3ee71..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -488,7 -748,139 +488,143 @@@ static int wacom_intuos_inout(struct wa
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void wacom_intuos_general(struct wacom_wac *wacom)
++=======
+ static int wacom_remote_irq(struct wacom_wac *wacom_wac, size_t len)
+ {
+ 	unsigned char *data = wacom_wac->data;
+ 	struct input_dev *input;
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	struct wacom_remote *remote = wacom->remote;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	int bat_charging, bat_percent, touch_ring_mode;
+ 	__u32 serial;
+ 	int i, index = -1;
+ 	unsigned long flags;
+ 
+ 	if (data[0] != WACOM_REPORT_REMOTE) {
+ 		hid_dbg(wacom->hdev, "%s: received unknown report #%d",
+ 			__func__, data[0]);
+ 		return 0;
+ 	}
+ 
+ 	serial = data[3] + (data[4] << 8) + (data[5] << 16);
+ 	wacom_wac->id[0] = PAD_DEVICE_ID;
+ 
+ 	spin_lock_irqsave(&remote->remote_lock, flags);
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		if (remote->remotes[i].serial == serial) {
+ 			index = i;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (index < 0 || !remote->remotes[index].registered)
+ 		goto out;
+ 
+ 	input = remote->remotes[index].input;
+ 
+ 	input_report_key(input, BTN_0, (data[9] & 0x01));
+ 	input_report_key(input, BTN_1, (data[9] & 0x02));
+ 	input_report_key(input, BTN_2, (data[9] & 0x04));
+ 	input_report_key(input, BTN_3, (data[9] & 0x08));
+ 	input_report_key(input, BTN_4, (data[9] & 0x10));
+ 	input_report_key(input, BTN_5, (data[9] & 0x20));
+ 	input_report_key(input, BTN_6, (data[9] & 0x40));
+ 	input_report_key(input, BTN_7, (data[9] & 0x80));
+ 
+ 	input_report_key(input, BTN_8, (data[10] & 0x01));
+ 	input_report_key(input, BTN_9, (data[10] & 0x02));
+ 	input_report_key(input, BTN_A, (data[10] & 0x04));
+ 	input_report_key(input, BTN_B, (data[10] & 0x08));
+ 	input_report_key(input, BTN_C, (data[10] & 0x10));
+ 	input_report_key(input, BTN_X, (data[10] & 0x20));
+ 	input_report_key(input, BTN_Y, (data[10] & 0x40));
+ 	input_report_key(input, BTN_Z, (data[10] & 0x80));
+ 
+ 	input_report_key(input, BTN_BASE, (data[11] & 0x01));
+ 	input_report_key(input, BTN_BASE2, (data[11] & 0x02));
+ 
+ 	if (data[12] & 0x80)
+ 		input_report_abs(input, ABS_WHEEL, (data[12] & 0x7f));
+ 	else
+ 		input_report_abs(input, ABS_WHEEL, 0);
+ 
+ 	bat_percent = data[7] & 0x7f;
+ 	bat_charging = !!(data[7] & 0x80);
+ 
+ 	if (data[9] | data[10] | (data[11] & 0x03) | data[12])
+ 		input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 	else
+ 		input_report_abs(input, ABS_MISC, 0);
+ 
+ 	input_event(input, EV_MSC, MSC_SERIAL, serial);
+ 
+ 	input_sync(input);
+ 
+ 	/*Which mode select (LED light) is currently on?*/
+ 	touch_ring_mode = (data[11] & 0xC0) >> 6;
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		if (remote->remotes[i].serial == serial)
+ 			wacom->led.groups[i].select = touch_ring_mode;
+ 	}
+ 
+ 	if (!wacom->battery &&
+ 	    !(features->quirks & WACOM_QUIRK_BATTERY)) {
+ 		features->quirks |= WACOM_QUIRK_BATTERY;
+ 		wacom_schedule_work(wacom_wac, WACOM_WORKER_BATTERY);
+ 	}
+ 
+ 	wacom_notify_battery(wacom_wac, bat_percent, bat_charging, 1,
+ 			     bat_charging);
+ 
+ out:
+ 	spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 	return 0;
+ }
+ 
+ static void wacom_remote_status_irq(struct wacom_wac *wacom_wac, size_t len)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	unsigned char *data = wacom_wac->data;
+ 	struct wacom_remote *remote = wacom->remote;
+ 	struct wacom_remote_data remote_data;
+ 	unsigned long flags;
+ 	int i, ret;
+ 
+ 	if (data[0] != WACOM_REPORT_DEVICE_LIST)
+ 		return;
+ 
+ 	memset(&remote_data, 0, sizeof(struct wacom_remote_data));
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		int j = i * 6;
+ 		int serial = (data[j+6] << 16) + (data[j+5] << 8) + data[j+4];
+ 		bool connected = data[j+2];
+ 
+ 		remote_data.remote[i].serial = serial;
+ 		remote_data.remote[i].connected = connected;
+ 	}
+ 
+ 	spin_lock_irqsave(&remote->remote_lock, flags);
+ 
+ 	ret = kfifo_in(&remote->remote_fifo, &remote_data, sizeof(remote_data));
+ 	if (ret != sizeof(remote_data)) {
+ 		spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 		hid_err(wacom->hdev, "Can't queue Remote status event.\n");
+ 		return;
+ 	}
+ 
+ 	spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 
+ 	wacom_schedule_work(wacom_wac, WACOM_WORKER_REMOTE);
+ }
+ 
+ static int wacom_intuos_general(struct wacom_wac *wacom)
++>>>>>>> 7c35dc3cd4d1 (HID: wacom: EKR: allocate one input node per remote)
  {
  	struct wacom_features *features = &wacom->features;
  	unsigned char *data = wacom->data;
@@@ -1486,58 -2473,16 +1622,61 @@@ void wacom_setup_device_quirks(struct w
  	}
  
  	if (features->type == WIRELESS) {
 -		if (features->device_type == WACOM_DEVICETYPE_WL_MONITOR) {
 -			features->quirks |= WACOM_QUIRK_BATTERY;
 +
 +		/* monitor never has input and pen/touch have delayed create */
 +		features->quirks |= WACOM_QUIRK_NO_INPUT;
 +
 +		/* must be monitor interface if no device_type set */
 +		if (!features->device_type)
 +			features->quirks |= WACOM_QUIRK_MONITOR;
 +	}
 +}
 +
 +static void wacom_abs_set_axis(struct input_dev *input_dev,
 +			       struct wacom_wac *wacom_wac)
 +{
 +	struct wacom_features *features = &wacom_wac->features;
 +
 +	if (features->device_type == BTN_TOOL_PEN) {
 +		input_set_abs_params(input_dev, ABS_X, features->x_min,
 +				     features->x_max, features->x_fuzz, 0);
 +		input_set_abs_params(input_dev, ABS_Y, features->y_min,
 +				     features->y_max, features->y_fuzz, 0);
 +		input_set_abs_params(input_dev, ABS_PRESSURE, 0,
 +			features->pressure_max, features->pressure_fuzz, 0);
 +
 +		/* penabled devices have fixed resolution for each model */
 +		input_abs_set_res(input_dev, ABS_X, features->x_resolution);
 +		input_abs_set_res(input_dev, ABS_Y, features->y_resolution);
 +	} else {
 +		if (features->touch_max <= 2) {
 +			input_set_abs_params(input_dev, ABS_X, 0,
 +				features->x_max, features->x_fuzz, 0);
 +			input_set_abs_params(input_dev, ABS_Y, 0,
 +				features->y_max, features->y_fuzz, 0);
 +			input_abs_set_res(input_dev, ABS_X,
 +					  features->x_resolution);
 +			input_abs_set_res(input_dev, ABS_Y,
 +					  features->y_resolution);
 +		}
 +
 +		if (features->touch_max > 1) {
 +			input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
 +				features->x_max, features->x_fuzz, 0);
 +			input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
 +				features->y_max, features->y_fuzz, 0);
 +			input_abs_set_res(input_dev, ABS_MT_POSITION_X,
 +					  features->x_resolution);
 +			input_abs_set_res(input_dev, ABS_MT_POSITION_Y,
 +					  features->y_resolution);
  		}
  	}
+ 
+ 	if (features->type == REMOTE)
+ 		features->device_type |= WACOM_DEVICETYPE_WL_MONITOR;
  }
  
 -int wacom_setup_pen_input_capabilities(struct input_dev *input_dev,
 +int wacom_setup_input_capabilities(struct input_dev *input_dev,
  				   struct wacom_wac *wacom_wac)
  {
  	struct wacom_features *features = &wacom_wac->features;
@@@ -1826,10 -2639,284 +1965,287 @@@
  			__set_bit(BTN_STYLUS, input_dev->keybit);
  			__set_bit(BTN_STYLUS2, input_dev->keybit);
  			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 -				      features->distance_max,
 -				      features->distance_fuzz, 0);
 +					      features->distance_max,
 +					      0, 0);
  		}
  		break;
++<<<<<<< HEAD
++=======
+ 	case BAMBOO_PAD:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
+ 					 struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_TOUCH))
+ 		return -ENODEV;
+ 
+ 	if (features->type == HID_GENERIC)
+ 		/* setup has already been done */
+ 		return 0;
+ 
+ 	__set_bit(BTN_TOUCH, input_dev->keybit);
+ 
+ 	if (features->touch_max == 1) {
+ 		input_set_abs_params(input_dev, ABS_X, 0,
+ 			features->x_max, features->x_fuzz, 0);
+ 		input_set_abs_params(input_dev, ABS_Y, 0,
+ 			features->y_max, features->y_fuzz, 0);
+ 		input_abs_set_res(input_dev, ABS_X,
+ 				  features->x_resolution);
+ 		input_abs_set_res(input_dev, ABS_Y,
+ 				  features->y_resolution);
+ 	}
+ 	else if (features->touch_max > 1) {
+ 		input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+ 			features->x_max, features->x_fuzz, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+ 			features->y_max, features->y_fuzz, 0);
+ 		input_abs_set_res(input_dev, ABS_MT_POSITION_X,
+ 				  features->x_resolution);
+ 		input_abs_set_res(input_dev, ABS_MT_POSITION_Y,
+ 				  features->y_resolution);
+ 	}
+ 
+ 	switch (features->type) {
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, features->y_max, 0, 0);
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		break;
+ 
+ 	case WACOM_24HDT:
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
+ 		/* fall through */
+ 
+ 	case WACOM_27QHDT:
+ 	case MTSCREEN:
+ 	case MTTPC:
+ 	case MTTPC_B:
+ 	case TABLETPC2FG:
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);
+ 		/*fall through */
+ 
+ 	case TABLETPC:
+ 	case TABLETPCE:
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 	case INTUOSHT2:
+ 		input_dev->evbit[0] |= BIT_MASK(EV_SW);
+ 		__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
+ 		/* fall through */
+ 
+ 	case BAMBOO_PT:
+ 	case BAMBOO_TOUCH:
+ 		if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 			input_set_abs_params(input_dev,
+ 				     ABS_MT_TOUCH_MAJOR,
+ 				     0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev,
+ 				     ABS_MT_TOUCH_MINOR,
+ 				     0, features->y_max, 0, 0);
+ 		}
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		break;
+ 
+ 	case BAMBOO_PAD:
+ 		input_mt_init_slots(input_dev, features->touch_max,
+ 				    INPUT_MT_POINTER);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ static void wacom_setup_numbered_buttons(struct input_dev *input_dev,
+ 				int button_count)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < button_count && i < 10; i++)
+ 		__set_bit(BTN_0 + i, input_dev->keybit);
+ 	for (i = 10; i < button_count && i < 16; i++)
+ 		__set_bit(BTN_A + (i-10), input_dev->keybit);
+ 	for (i = 16; i < button_count && i < 18; i++)
+ 		__set_bit(BTN_BASE + (i-16), input_dev->keybit);
+ }
+ 
+ static void wacom_report_numbered_buttons(struct input_dev *input_dev,
+ 				int button_count, int mask)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < button_count && i < 10; i++)
+ 		input_report_key(input_dev, BTN_0 + i, mask & (1 << i));
+ 	for (i = 10; i < button_count && i < 16; i++)
+ 		input_report_key(input_dev, BTN_A + (i-10), mask & (1 << i));
+ 	for (i = 16; i < button_count && i < 18; i++)
+ 		input_report_key(input_dev, BTN_BASE + (i-16), mask & (1 << i));
+ }
+ 
+ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_PAD))
+ 		return -ENODEV;
+ 
+ 	if (features->type == REMOTE && input_dev == wacom_wac->pad_input)
+ 		return -ENODEV;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	/* kept for making legacy xf86-input-wacom working with the wheels */
+ 	__set_bit(ABS_MISC, input_dev->absbit);
+ 
+ 	/* kept for making legacy xf86-input-wacom accepting the pad */
+ 	input_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);
+ 
+ 	/* kept for making udev and libwacom accepting the pad */
+ 	__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 	wacom_setup_numbered_buttons(input_dev, features->numbered_buttons);
+ 
+ 	switch (features->type) {
+ 
+ 	case CINTIQ_HYBRID:
+ 	case CINTIQ_COMPANION_2:
+ 	case DTK:
+ 	case DTUS:
+ 	case GRAPHIRE_BT:
+ 		break;
+ 
+ 	case WACOM_MO:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_G4:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
+ 		break;
+ 
+ 	case WACOM_24HD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_THROTTLE, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_27QHD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_X, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_X, 1024); /* points/g */
+ 		input_set_abs_params(input_dev, ABS_Y, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Y, 1024);
+ 		input_set_abs_params(input_dev, ABS_Z, -2048, 2048, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 1024);
+ 		__set_bit(INPUT_PROP_ACCELEROMETER, input_dev->propbit);
+ 		break;
+ 
+ 	case WACOM_22HD:
+ 		__set_bit(KEY_PROG1, input_dev->keybit);
+ 		__set_bit(KEY_PROG2, input_dev->keybit);
+ 		__set_bit(KEY_PROG3, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case WACOM_21UX2:
+ 	case WACOM_BEE:
+ 	case CINTIQ:
+ 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
+ 		break;
+ 
+ 	case WACOM_13HD:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOS3:
+ 	case INTUOS3L:
+ 		input_set_abs_params(input_dev, ABS_RY, 0, 4096, 0, 0);
+ 		/* fall through */
+ 
+ 	case INTUOS3S:
+ 		input_set_abs_params(input_dev, ABS_RX, 0, 4096, 0, 0);
+ 		break;
+ 
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOS4WL:
+ 		/*
+ 		 * For Bluetooth devices, the udev rule does not work correctly
+ 		 * for pads unless we add a stylus capability, which forces
+ 		 * ID_INPUT_TABLET to be set.
+ 		 */
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case INTUOS4:
+ 	case INTUOS4L:
+ 	case INTUOS4S:
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 	case BAMBOO_PT:
+ 	case BAMBOO_TOUCH:
+ 	case INTUOSHT2:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 
+ 		break;
+ 
+ 	case REMOTE:
+ 		input_set_capability(input_dev, EV_MSC, MSC_SERIAL);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	default:
+ 		/* no pad supported */
+ 		return -ENODEV;
++>>>>>>> 7c35dc3cd4d1 (HID: wacom: EKR: allocate one input node per remote)
  	}
  	return 0;
  }
* Unmerged path drivers/hid/wacom.h
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
