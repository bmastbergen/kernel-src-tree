bridge: allow adding of fdb entries pointing to the bridge device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Roopa Prabhu <roopa@cumulusnetworks.com>
commit 3741873b4f73b572b8f8835e6bd114e08316a160
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3741873b.failed

This patch enables adding of fdb entries pointing to the bridge device.
This can be used to propagate mac address of vlan interfaces
configured on top of the vlan filtering bridge.

Before:
$bridge fdb add 44:38:39:00:27:9f dev bridge
RTNETLINK answers: Invalid argument

After:
$bridge fdb add 44:38:39:00:27:9f dev bridge

	Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3741873b4f73b572b8f8835e6bd114e08316a160)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_fdb.c
diff --cc net/bridge/br_fdb.c
index 46b89ee4408e,f43ce05c66a6..000000000000
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@@ -618,10 -638,10 +619,10 @@@ static int fdb_fill_info(struct sk_buf
  	ndm->ndm_family	 = AF_BRIDGE;
  	ndm->ndm_pad1    = 0;
  	ndm->ndm_pad2    = 0;
 -	ndm->ndm_flags	 = fdb->added_by_external_learn ? NTF_EXT_LEARNED : 0;
 +	ndm->ndm_flags	 = 0;
  	ndm->ndm_type	 = 0;
  	ndm->ndm_ifindex = fdb->dst ? fdb->dst->dev->ifindex : br->dev->ifindex;
- 	ndm->ndm_state   = fdb_to_nud(fdb);
+ 	ndm->ndm_state   = fdb_to_nud(br, fdb);
  
  	if (nla_put(skb, NDA_LLADDR, ETH_ALEN, &fdb->addr))
  		goto nla_put_failure;
@@@ -812,9 -846,11 +813,16 @@@ int br_fdb_add(struct ndmsg *ndm, struc
  	       struct net_device *dev,
  	       const unsigned char *addr, u16 vid, u16 nlh_flags)
  {
++<<<<<<< HEAD
 +	struct net_bridge_port *p;
++=======
+ 	struct net_bridge_vlan_group *vg;
+ 	struct net_bridge_port *p = NULL;
+ 	struct net_bridge_vlan *v;
+ 	struct net_bridge *br = NULL;
++>>>>>>> 3741873b4f73 (bridge: allow adding of fdb entries pointing to the bridge device)
  	int err = 0;
 +	struct net_port_vlans *pv;
  
  	if (!(ndm->ndm_state & (NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE))) {
  		pr_info("bridge: RTM_NEWNEIGH with invalid state %#x\n", ndm->ndm_state);
@@@ -826,34 -862,51 +834,69 @@@
  		return -EINVAL;
  	}
  
- 	p = br_port_get_rtnl(dev);
- 	if (p == NULL) {
- 		pr_info("bridge: RTM_NEWNEIGH %s not a bridge port\n",
- 			dev->name);
- 		return -EINVAL;
+ 	if (dev->priv_flags & IFF_EBRIDGE) {
+ 		br = netdev_priv(dev);
+ 		vg = br_vlan_group(br);
+ 	} else {
+ 		p = br_port_get_rtnl(dev);
+ 		if (!p) {
+ 			pr_info("bridge: RTM_NEWNEIGH %s not a bridge port\n",
+ 				dev->name);
+ 			return -EINVAL;
+ 		}
+ 		vg = nbp_vlan_group(p);
  	}
  
++<<<<<<< HEAD
 +	pv = nbp_get_vlan_info(p);
 +	if (vid) {
 +		if (!pv || !test_bit(vid, pv->vlan_bitmap)) {
 +			pr_info("bridge: RTM_NEWNEIGH with unconfigured "
 +				"vlan %d on port %s\n", vid, dev->name);
++=======
+ 	if (vid) {
+ 		v = br_vlan_find(vg, vid);
+ 		if (!v || !br_vlan_should_use(v)) {
+ 			pr_info("bridge: RTM_NEWNEIGH with unconfigured vlan %d on %s\n", vid, dev->name);
++>>>>>>> 3741873b4f73 (bridge: allow adding of fdb entries pointing to the bridge device)
  			return -EINVAL;
  		}
  
  		/* VID was specified, so use it. */
- 		err = __br_fdb_add(ndm, p, addr, nlh_flags, vid);
+ 		if (dev->priv_flags & IFF_EBRIDGE)
+ 			err = br_fdb_insert(br, NULL, addr, vid);
+ 		else
+ 			err = __br_fdb_add(ndm, p, addr, nlh_flags, vid);
  	} else {
++<<<<<<< HEAD
 +		err = __br_fdb_add(ndm, p, addr, nlh_flags, 0);
 +		if (err || !pv)
++=======
+ 		if (dev->priv_flags & IFF_EBRIDGE)
+ 			err = br_fdb_insert(br, NULL, addr, 0);
+ 		else
+ 			err = __br_fdb_add(ndm, p, addr, nlh_flags, 0);
+ 		if (err || !vg || !vg->num_vlans)
++>>>>>>> 3741873b4f73 (bridge: allow adding of fdb entries pointing to the bridge device)
  			goto out;
  
  		/* We have vlans configured on this port and user didn't
  		 * specify a VLAN.  To be nice, add/update entry for every
  		 * vlan on this port.
  		 */
++<<<<<<< HEAD
 +		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
 +			err = __br_fdb_add(ndm, p, addr, nlh_flags, vid);
++=======
+ 		list_for_each_entry(v, &vg->vlan_list, vlist) {
+ 			if (!br_vlan_should_use(v))
+ 				continue;
+ 			if (dev->priv_flags & IFF_EBRIDGE)
+ 				err = br_fdb_insert(br, NULL, addr, v->vid);
+ 			else
+ 				err = __br_fdb_add(ndm, p, addr, nlh_flags,
+ 						   v->vid);
++>>>>>>> 3741873b4f73 (bridge: allow adding of fdb entries pointing to the bridge device)
  			if (err)
  				goto out;
  		}
@@@ -895,38 -974,53 +964,79 @@@ int br_fdb_delete(struct ndmsg *ndm, st
  		  struct net_device *dev,
  		  const unsigned char *addr, u16 vid)
  {
++<<<<<<< HEAD
 +	struct net_bridge_port *p;
++=======
+ 	struct net_bridge_vlan_group *vg;
+ 	struct net_bridge_port *p = NULL;
+ 	struct net_bridge_vlan *v;
+ 	struct net_bridge *br = NULL;
++>>>>>>> 3741873b4f73 (bridge: allow adding of fdb entries pointing to the bridge device)
  	int err;
 +	struct net_port_vlans *pv;
  
- 	p = br_port_get_rtnl(dev);
- 	if (p == NULL) {
- 		pr_info("bridge: RTM_DELNEIGH %s not a bridge port\n",
- 			dev->name);
- 		return -EINVAL;
+ 	if (dev->priv_flags & IFF_EBRIDGE) {
+ 		br = netdev_priv(dev);
+ 		vg = br_vlan_group(br);
+ 	} else {
+ 		p = br_port_get_rtnl(dev);
+ 		if (!p) {
+ 			pr_info("bridge: RTM_DELNEIGH %s not a bridge port\n",
+ 				dev->name);
+ 			return -EINVAL;
+ 		}
+ 		vg = nbp_vlan_group(p);
  	}
  
++<<<<<<< HEAD
 +	pv = nbp_get_vlan_info(p);
 +	if (vid) {
 +		if (!pv || !test_bit(vid, pv->vlan_bitmap)) {
 +			pr_info("bridge: RTM_DELNEIGH with unconfigured "
 +				"vlan %d on port %s\n", vid, dev->name);
++=======
+ 	if (vid) {
+ 		v = br_vlan_find(vg, vid);
+ 		if (!v) {
+ 			pr_info("bridge: RTM_DELNEIGH with unconfigured vlan %d on %s\n", vid, dev->name);
++>>>>>>> 3741873b4f73 (bridge: allow adding of fdb entries pointing to the bridge device)
  			return -EINVAL;
  		}
  
- 		err = __br_fdb_delete(p, addr, vid);
+ 		if (dev->priv_flags & IFF_EBRIDGE)
+ 			err = __br_fdb_delete_by_addr(br, addr, vid);
+ 		else
+ 			err = __br_fdb_delete(p, addr, vid);
  	} else {
  		err = -ENOENT;
++<<<<<<< HEAD
 +		err &= __br_fdb_delete(p, addr, 0);
 +		if (!pv)
 +			goto out;
 +
 +		/* We have vlans configured on this port and user didn't
 +		 * specify a VLAN.  To be nice, add/update entry for every
 +		 * vlan on this port.
 +		 */
 +		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
 +			err &= __br_fdb_delete(p, addr, vid);
++=======
+ 		if (dev->priv_flags & IFF_EBRIDGE)
+ 			err = __br_fdb_delete_by_addr(br, addr, 0);
+ 		else
+ 			err &= __br_fdb_delete(p, addr, 0);
+ 
+ 		if (!vg || !vg->num_vlans)
+ 			goto out;
+ 
+ 		list_for_each_entry(v, &vg->vlan_list, vlist) {
+ 			if (!br_vlan_should_use(v))
+ 				continue;
+ 			if (dev->priv_flags & IFF_EBRIDGE)
+ 				err = __br_fdb_delete_by_addr(br, addr, v->vid);
+ 			else
+ 				err &= __br_fdb_delete(p, addr, v->vid);
++>>>>>>> 3741873b4f73 (bridge: allow adding of fdb entries pointing to the bridge device)
  		}
  	}
  out:
* Unmerged path net/bridge/br_fdb.c
diff --git a/net/bridge/br_vlan.c b/net/bridge/br_vlan.c
index 1122c9d717ea..e8fa93efdd3c 100644
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@ -348,6 +348,7 @@ int br_vlan_delete(struct net_bridge *br, u16 vid)
 		return -EINVAL;
 
 	br_fdb_find_delete_local(br, NULL, br->dev->dev_addr, vid);
+	br_fdb_delete_by_port(br, NULL, vid, 0);
 
 	__vlan_del(pv, vid);
 	return 0;
