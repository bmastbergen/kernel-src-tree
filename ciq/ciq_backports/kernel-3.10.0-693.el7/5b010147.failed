geneve: avoid use-after-free of skb->data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Sabrina Dubroca <sd@queasysnail.net>
commit 5b01014759991887b1e450c9def01e58c02ab81b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5b010147.failed

geneve{,6}_build_skb can end up doing a pskb_expand_head(), which
makes the ip_hdr(skb) reference we stashed earlier stale. Since it's
only needed as an argument to ip_tunnel_ecn_encap(), move this
directly in the function call.

Fixes: 08399efc6319 ("geneve: ensure ECN info is handled properly in all tx/rx paths")
	Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
	Reviewed-by: John W. Linville <linville@tuxdriver.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5b01014759991887b1e450c9def01e58c02ab81b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/geneve.c
diff --cc drivers/net/geneve.c
index d6abacdaaf40,8b4822ad27cb..000000000000
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@@ -851,9 -857,8 +851,8 @@@ static netdev_tx_t geneve_xmit_skb(stru
  				   struct ip_tunnel_info *info)
  {
  	struct geneve_dev *geneve = netdev_priv(dev);
 -	struct geneve_sock *gs4;
 +	struct geneve_sock *gs4 = geneve->sock4;
  	struct rtable *rt = NULL;
- 	const struct iphdr *iip; /* interior IP header */
  	int err = -EINVAL;
  	struct flowi4 fl4;
  	__u8 tos, ttl;
@@@ -899,18 -906,18 +896,18 @@@
  		err = geneve_build_skb(rt, skb, key->tun_flags, vni,
  				       info->options_len, opts, flags, xnet);
  		if (unlikely(err))
 -			goto tx_error;
 +			goto err;
  
- 		tos = ip_tunnel_ecn_encap(key->tos, iip, skb);
+ 		tos = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);
  		ttl = key->ttl;
  		df = key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;
  	} else {
  		err = geneve_build_skb(rt, skb, 0, geneve->vni,
  				       0, NULL, flags, xnet);
  		if (unlikely(err))
 -			goto tx_error;
 +			goto err;
  
- 		tos = ip_tunnel_ecn_encap(fl4.flowi4_tos, iip, skb);
+ 		tos = ip_tunnel_ecn_encap(fl4.flowi4_tos, ip_hdr(skb), skb);
  		ttl = geneve->ttl;
  		if (!ttl && IN_MULTICAST(ntohl(fl4.daddr)))
  			ttl = 1;
@@@ -941,9 -948,8 +938,13 @@@ static netdev_tx_t geneve6_xmit_skb(str
  				    struct ip_tunnel_info *info)
  {
  	struct geneve_dev *geneve = netdev_priv(dev);
 +	struct geneve_sock *gs6 = geneve->sock6;
  	struct dst_entry *dst = NULL;
++<<<<<<< HEAD
 +	const struct iphdr *iip; /* interior IP header */
++=======
+ 	struct geneve_sock *gs6;
++>>>>>>> 5b0101475999 (geneve: avoid use-after-free of skb->data)
  	int err = -EINVAL;
  	struct flowi6 fl6;
  	__u8 prio, ttl;
@@@ -988,19 -996,19 +987,19 @@@
  					info->options_len, opts,
  					flags, xnet);
  		if (unlikely(err))
 -			goto tx_error;
 +			goto err;
  
- 		prio = ip_tunnel_ecn_encap(key->tos, iip, skb);
+ 		prio = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);
  		ttl = key->ttl;
  		label = info->key.label;
  	} else {
  		err = geneve6_build_skb(dst, skb, 0, geneve->vni,
  					0, NULL, flags, xnet);
  		if (unlikely(err))
 -			goto tx_error;
 +			goto err;
  
  		prio = ip_tunnel_ecn_encap(ip6_tclass(fl6.flowlabel),
- 					   iip, skb);
+ 					   ip_hdr(skb), skb);
  		ttl = geneve->ttl;
  		if (!ttl && ipv6_addr_is_multicast(&fl6.daddr))
  			ttl = 1;
* Unmerged path drivers/net/geneve.c
