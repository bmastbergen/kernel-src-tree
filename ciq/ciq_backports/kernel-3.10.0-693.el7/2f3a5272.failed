ipv4: fib: Add events for FIB replace and append

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 2f3a5272e5c16c3c10fbba06928a513f9b1e2fcd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2f3a5272.failed

The FIB notification chain currently uses the NLM_F_{REPLACE,APPEND}
flags to signal routes being replaced or appended.

Instead of using netlink flags for in-kernel notifications we can simply
introduce two new events in the FIB notification chain. This has the
added advantage of making the API cleaner, thereby making it clear that
these events should be supported by listeners of the notification chain.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
CC: Patrick McHardy <kaber@trash.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2f3a5272e5c16c3c10fbba06928a513f9b1e2fcd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip_fib.h
#	net/ipv4/fib_trie.c
diff --cc include/net/ip_fib.h
index 9927afab7c39,368bb4024b78..000000000000
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@@ -184,6 -199,42 +184,45 @@@ __be32 fib_info_update_nh_saddr(struct 
  #define FIB_RES_PREFSRC(net, res)	((res).fi->fib_prefsrc ? : \
  					 FIB_RES_SADDR(net, res))
  
++<<<<<<< HEAD
++=======
+ struct fib_notifier_info {
+ 	struct net *net;
+ };
+ 
+ struct fib_entry_notifier_info {
+ 	struct fib_notifier_info info; /* must be first */
+ 	u32 dst;
+ 	int dst_len;
+ 	struct fib_info *fi;
+ 	u8 tos;
+ 	u8 type;
+ 	u32 tb_id;
+ };
+ 
+ struct fib_nh_notifier_info {
+ 	struct fib_notifier_info info; /* must be first */
+ 	struct fib_nh *fib_nh;
+ };
+ 
+ enum fib_event_type {
+ 	FIB_EVENT_ENTRY_REPLACE,
+ 	FIB_EVENT_ENTRY_APPEND,
+ 	FIB_EVENT_ENTRY_ADD,
+ 	FIB_EVENT_ENTRY_DEL,
+ 	FIB_EVENT_RULE_ADD,
+ 	FIB_EVENT_RULE_DEL,
+ 	FIB_EVENT_NH_ADD,
+ 	FIB_EVENT_NH_DEL,
+ };
+ 
+ int register_fib_notifier(struct notifier_block *nb,
+ 			  void (*cb)(struct notifier_block *nb));
+ int unregister_fib_notifier(struct notifier_block *nb);
+ int call_fib_notifiers(struct net *net, enum fib_event_type event_type,
+ 		       struct fib_notifier_info *info);
+ 
++>>>>>>> 2f3a5272e5c1 (ipv4: fib: Add events for FIB replace and append)
  struct fib_table {
  	struct hlist_node	tb_hlist;
  	u32			tb_id;
diff --cc net/ipv4/fib_trie.c
index a731822edc22,d8cea210af0e..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -79,8 -81,134 +79,136 @@@
  #include <net/tcp.h>
  #include <net/sock.h>
  #include <net/ip_fib.h>
 -#include <trace/events/fib.h>
  #include "fib_lookup.h"
  
++<<<<<<< HEAD
++=======
+ static unsigned int fib_seq_sum(void)
+ {
+ 	unsigned int fib_seq = 0;
+ 	struct net *net;
+ 
+ 	rtnl_lock();
+ 	for_each_net(net)
+ 		fib_seq += net->ipv4.fib_seq;
+ 	rtnl_unlock();
+ 
+ 	return fib_seq;
+ }
+ 
+ static ATOMIC_NOTIFIER_HEAD(fib_chain);
+ 
+ static int call_fib_notifier(struct notifier_block *nb, struct net *net,
+ 			     enum fib_event_type event_type,
+ 			     struct fib_notifier_info *info)
+ {
+ 	info->net = net;
+ 	return nb->notifier_call(nb, event_type, info);
+ }
+ 
+ static void fib_rules_notify(struct net *net, struct notifier_block *nb,
+ 			     enum fib_event_type event_type)
+ {
+ #ifdef CONFIG_IP_MULTIPLE_TABLES
+ 	struct fib_notifier_info info;
+ 
+ 	if (net->ipv4.fib_has_custom_rules)
+ 		call_fib_notifier(nb, net, event_type, &info);
+ #endif
+ }
+ 
+ static void fib_notify(struct net *net, struct notifier_block *nb,
+ 		       enum fib_event_type event_type);
+ 
+ static int call_fib_entry_notifier(struct notifier_block *nb, struct net *net,
+ 				   enum fib_event_type event_type, u32 dst,
+ 				   int dst_len, struct fib_info *fi,
+ 				   u8 tos, u8 type, u32 tb_id)
+ {
+ 	struct fib_entry_notifier_info info = {
+ 		.dst = dst,
+ 		.dst_len = dst_len,
+ 		.fi = fi,
+ 		.tos = tos,
+ 		.type = type,
+ 		.tb_id = tb_id,
+ 	};
+ 	return call_fib_notifier(nb, net, event_type, &info.info);
+ }
+ 
+ static bool fib_dump_is_consistent(struct notifier_block *nb,
+ 				   void (*cb)(struct notifier_block *nb),
+ 				   unsigned int fib_seq)
+ {
+ 	atomic_notifier_chain_register(&fib_chain, nb);
+ 	if (fib_seq == fib_seq_sum())
+ 		return true;
+ 	atomic_notifier_chain_unregister(&fib_chain, nb);
+ 	if (cb)
+ 		cb(nb);
+ 	return false;
+ }
+ 
+ #define FIB_DUMP_MAX_RETRIES 5
+ int register_fib_notifier(struct notifier_block *nb,
+ 			  void (*cb)(struct notifier_block *nb))
+ {
+ 	int retries = 0;
+ 
+ 	do {
+ 		unsigned int fib_seq = fib_seq_sum();
+ 		struct net *net;
+ 
+ 		/* Mutex semantics guarantee that every change done to
+ 		 * FIB tries before we read the change sequence counter
+ 		 * is now visible to us.
+ 		 */
+ 		rcu_read_lock();
+ 		for_each_net_rcu(net) {
+ 			fib_rules_notify(net, nb, FIB_EVENT_RULE_ADD);
+ 			fib_notify(net, nb, FIB_EVENT_ENTRY_ADD);
+ 		}
+ 		rcu_read_unlock();
+ 
+ 		if (fib_dump_is_consistent(nb, cb, fib_seq))
+ 			return 0;
+ 	} while (++retries < FIB_DUMP_MAX_RETRIES);
+ 
+ 	return -EBUSY;
+ }
+ EXPORT_SYMBOL(register_fib_notifier);
+ 
+ int unregister_fib_notifier(struct notifier_block *nb)
+ {
+ 	return atomic_notifier_chain_unregister(&fib_chain, nb);
+ }
+ EXPORT_SYMBOL(unregister_fib_notifier);
+ 
+ int call_fib_notifiers(struct net *net, enum fib_event_type event_type,
+ 		       struct fib_notifier_info *info)
+ {
+ 	net->ipv4.fib_seq++;
+ 	info->net = net;
+ 	return atomic_notifier_call_chain(&fib_chain, event_type, info);
+ }
+ 
+ static int call_fib_entry_notifiers(struct net *net,
+ 				    enum fib_event_type event_type, u32 dst,
+ 				    int dst_len, struct fib_info *fi,
+ 				    u8 tos, u8 type, u32 tb_id)
+ {
+ 	struct fib_entry_notifier_info info = {
+ 		.dst = dst,
+ 		.dst_len = dst_len,
+ 		.fi = fi,
+ 		.tos = tos,
+ 		.type = type,
+ 		.tb_id = tb_id,
+ 	};
+ 	return call_fib_notifiers(net, event_type, &info.info);
+ }
+ 
++>>>>>>> 2f3a5272e5c1 (ipv4: fib: Add events for FIB replace and append)
  #define MAX_STAT_DEPTH 32
  
  #define KEYLENGTH	(8*sizeof(t_key))
@@@ -1065,8 -1193,10 +1193,9 @@@ static int fib_insert_alias(struct tri
  }
  
  /* Caller must hold RTNL. */
 -int fib_table_insert(struct net *net, struct fib_table *tb,
 -		     struct fib_config *cfg)
 +int fib_table_insert(struct fib_table *tb, struct fib_config *cfg)
  {
+ 	enum fib_event_type event = FIB_EVENT_ENTRY_ADD;
  	struct trie *t = (struct trie *)tb->tb_data;
  	struct fib_alias *fa, *new_fa;
  	struct key_vector *l, *tp;
@@@ -1154,8 -1291,18 +1283,20 @@@
  			state = fa->fa_state;
  			new_fa->fa_state = state & ~FA_S_ACCESSED;
  			new_fa->fa_slen = fa->fa_slen;
++<<<<<<< HEAD
++=======
+ 			new_fa->tb_id = tb->tb_id;
+ 			new_fa->fa_default = -1;
+ 
+ 			call_fib_entry_notifiers(net, FIB_EVENT_ENTRY_REPLACE,
+ 						 key, plen, fi,
+ 						 new_fa->fa_tos, cfg->fc_type,
+ 						 tb->tb_id);
+ 			rtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen,
+ 				  tb->tb_id, &cfg->fc_nlinfo, nlflags);
++>>>>>>> 2f3a5272e5c1 (ipv4: fib: Add events for FIB replace and append)
  
  			hlist_replace_rcu(&fa->fa_list, &new_fa->fa_list);
 -
  			alias_free_mem_rcu(fa);
  
  			fib_release_info(fi_drop);
@@@ -1173,8 -1318,12 +1314,16 @@@
  		if (fa_match)
  			goto out;
  
++<<<<<<< HEAD
 +		if (!(cfg->fc_nlflags & NLM_F_APPEND))
++=======
+ 		if (cfg->fc_nlflags & NLM_F_APPEND) {
+ 			event = FIB_EVENT_ENTRY_APPEND;
+ 			nlflags |= NLM_F_APPEND;
+ 		} else {
++>>>>>>> 2f3a5272e5c1 (ipv4: fib: Add events for FIB replace and append)
  			fa = fa_first;
+ 		}
  	}
  	err = -ENOENT;
  	if (!(cfg->fc_nlflags & NLM_F_CREATE))
@@@ -1200,8 -1352,10 +1349,15 @@@
  		tb->tb_num_default++;
  
  	rt_cache_flush(cfg->fc_nlinfo.nl_net);
++<<<<<<< HEAD
 +	rtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, tb->tb_id,
 +		  &cfg->fc_nlinfo, 0);
++=======
+ 	call_fib_entry_notifiers(net, event, key, plen, fi, tos, cfg->fc_type,
+ 				 tb->tb_id);
+ 	rtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, new_fa->tb_id,
+ 		  &cfg->fc_nlinfo, nlflags);
++>>>>>>> 2f3a5272e5c1 (ipv4: fib: Add events for FIB replace and append)
  succeeded:
  	return 0;
  
@@@ -1480,6 -1653,9 +1636,12 @@@ int fib_table_delete(struct fib_table *
  	if (!fa_to_delete)
  		return -ESRCH;
  
++<<<<<<< HEAD
++=======
+ 	call_fib_entry_notifiers(net, FIB_EVENT_ENTRY_DEL, key, plen,
+ 				 fa_to_delete->fa_info, tos,
+ 				 fa_to_delete->fa_type, tb->tb_id);
++>>>>>>> 2f3a5272e5c1 (ipv4: fib: Add events for FIB replace and append)
  	rtmsg_fib(RTM_DELROUTE, htonl(key), fa_to_delete, plen, tb->tb_id,
  		  &cfg->fc_nlinfo, 0);
  
@@@ -1604,6 -1970,11 +1766,14 @@@ int fib_table_flush(struct fib_table *t
  				continue;
  			}
  
++<<<<<<< HEAD
++=======
+ 			call_fib_entry_notifiers(net, FIB_EVENT_ENTRY_DEL,
+ 						 n->key,
+ 						 KEYLENGTH - fa->fa_slen,
+ 						 fi, fa->fa_tos, fa->fa_type,
+ 						 tb->tb_id);
++>>>>>>> 2f3a5272e5c1 (ipv4: fib: Add events for FIB replace and append)
  			hlist_del_rcu(&fa->fa_list);
  			fib_release_info(fa->fa_info);
  			alias_free_mem_rcu(fa);
@@@ -1623,14 -1994,70 +1793,73 @@@
  	return found;
  }
  
++<<<<<<< HEAD
++=======
+ static void fib_leaf_notify(struct net *net, struct key_vector *l,
+ 			    struct fib_table *tb, struct notifier_block *nb,
+ 			    enum fib_event_type event_type)
+ {
+ 	struct fib_alias *fa;
+ 
+ 	hlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {
+ 		struct fib_info *fi = fa->fa_info;
+ 
+ 		if (!fi)
+ 			continue;
+ 
+ 		/* local and main table can share the same trie,
+ 		 * so don't notify twice for the same entry.
+ 		 */
+ 		if (tb->tb_id != fa->tb_id)
+ 			continue;
+ 
+ 		call_fib_entry_notifier(nb, net, event_type, l->key,
+ 					KEYLENGTH - fa->fa_slen, fi, fa->fa_tos,
+ 					fa->fa_type, fa->tb_id);
+ 	}
+ }
+ 
+ static void fib_table_notify(struct net *net, struct fib_table *tb,
+ 			     struct notifier_block *nb,
+ 			     enum fib_event_type event_type)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *l, *tp = t->kv;
+ 	t_key key = 0;
+ 
+ 	while ((l = leaf_walk_rcu(&tp, key)) != NULL) {
+ 		fib_leaf_notify(net, l, tb, nb, event_type);
+ 
+ 		key = l->key + 1;
+ 		/* stop in case of wrap around */
+ 		if (key < l->key)
+ 			break;
+ 	}
+ }
+ 
+ static void fib_notify(struct net *net, struct notifier_block *nb,
+ 		       enum fib_event_type event_type)
+ {
+ 	unsigned int h;
+ 
+ 	for (h = 0; h < FIB_TABLE_HASHSZ; h++) {
+ 		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
+ 		struct fib_table *tb;
+ 
+ 		hlist_for_each_entry_rcu(tb, head, tb_hlist)
+ 			fib_table_notify(net, tb, nb, event_type);
+ 	}
+ }
+ 
++>>>>>>> 2f3a5272e5c1 (ipv4: fib: Add events for FIB replace and append)
  static void __trie_free_rcu(struct rcu_head *head)
  {
 -	struct fib_table *tb = container_of(head, struct fib_table, rcu);
 +	struct trie *t = container_of(head, struct trie, rcu);
 +	unsigned long *tb_data = (unsigned long *)t;
 +	struct fib_table *tb = container_of(tb_data, struct fib_table,
 +					    tb_data[0]);
  #ifdef CONFIG_IP_FIB_TRIE_STATS
 -	struct trie *t = (struct trie *)tb->tb_data;
 -
 -	if (tb->tb_data == tb->__data)
 -		free_percpu(t->stats);
 +	free_percpu(t->stats);
  #endif /* CONFIG_IP_FIB_TRIE_STATS */
  	kfree(tb);
  }
* Unmerged path include/net/ip_fib.h
* Unmerged path net/ipv4/fib_trie.c
