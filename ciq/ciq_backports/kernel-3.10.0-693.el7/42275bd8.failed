switchdev: don't use anonymous union on switchdev attr/obj structs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Scott Feldman <sfeldma@gmail.com>
commit 42275bd8fcb351f951781d8882f359d25976824b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/42275bd8.failed

Older gcc versions (e.g.  gcc version 4.4.6) don't like anonymous unions
which was causing build issues on the newly added switchdev attr/obj
structs.  Fix this by using named union on structs.

	Signed-off-by: Scott Feldman <sfeldma@gmail.com>
	Reported-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 42275bd8fcb351f951781d8882f359d25976824b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/rocker/rocker.c
#	include/net/switchdev.h
#	net/bridge/br_stp.c
#	net/core/net-sysfs.c
#	net/core/rtnetlink.c
#	net/dsa/slave.c
#	net/switchdev/switchdev.c
diff --cc net/bridge/br_stp.c
index 2b047bcf42a4,45f1ff113af9..000000000000
--- a/net/bridge/br_stp.c
+++ b/net/bridge/br_stp.c
@@@ -38,7 -39,17 +38,16 @@@ void br_log_state(const struct net_brid
  
  void br_set_state(struct net_bridge_port *p, unsigned int state)
  {
++<<<<<<< HEAD
++=======
+ 	struct switchdev_attr attr = {
+ 		.id = SWITCHDEV_ATTR_PORT_STP_STATE,
+ 		.u.stp_state = state,
+ 	};
+ 	int err;
+ 
++>>>>>>> 42275bd8fcb3 (switchdev: don't use anonymous union on switchdev attr/obj structs)
  	p->state = state;
 -	err = switchdev_port_attr_set(p->dev, &attr);
 -	if (err && err != -EOPNOTSUPP)
 -		br_warn(p->br, "error setting offload STP state on port %u(%s)\n",
 -				(unsigned int) p->port_no, p->dev->name);
  }
  
  /* called under bridge lock */
diff --cc net/core/net-sysfs.c
index c7c996a3d5f5,18b34d771ed4..000000000000
--- a/net/core/net-sysfs.c
+++ b/net/core/net-sysfs.c
@@@ -416,11 -458,15 +416,16 @@@ static ssize_t phys_switch_id_show(stru
  		return restart_syscall();
  
  	if (dev_isalive(netdev)) {
 -		struct switchdev_attr attr = {
 -			.id = SWITCHDEV_ATTR_PORT_PARENT_ID,
 -			.flags = SWITCHDEV_F_NO_RECURSE,
 -		};
 +		struct netdev_phys_item_id ppid;
  
 -		ret = switchdev_port_attr_get(netdev, &attr);
 +		ret = netdev_switch_parent_id_get(netdev, &ppid);
  		if (!ret)
++<<<<<<< HEAD
 +			ret = sprintf(buf, "%*phN\n", ppid.id_len, ppid.id);
++=======
+ 			ret = sprintf(buf, "%*phN\n", attr.u.ppid.id_len,
+ 				      attr.u.ppid.id);
++>>>>>>> 42275bd8fcb3 (switchdev: don't use anonymous union on switchdev attr/obj structs)
  	}
  	rtnl_unlock();
  
diff --cc net/core/rtnetlink.c
index 590c29aca2b6,141ccc357e2e..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -1022,6 -983,46 +1022,49 @@@ static int rtnl_phys_port_id_fill(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int rtnl_phys_port_name_fill(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	char name[IFNAMSIZ];
+ 	int err;
+ 
+ 	err = dev_get_phys_port_name(dev, name, sizeof(name));
+ 	if (err) {
+ 		if (err == -EOPNOTSUPP)
+ 			return 0;
+ 		return err;
+ 	}
+ 
+ 	if (nla_put(skb, IFLA_PHYS_PORT_NAME, strlen(name), name))
+ 		return -EMSGSIZE;
+ 
+ 	return 0;
+ }
+ 
+ static int rtnl_phys_switch_id_fill(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	int err;
+ 	struct switchdev_attr attr = {
+ 		.id = SWITCHDEV_ATTR_PORT_PARENT_ID,
+ 		.flags = SWITCHDEV_F_NO_RECURSE,
+ 	};
+ 
+ 	err = switchdev_port_attr_get(dev, &attr);
+ 	if (err) {
+ 		if (err == -EOPNOTSUPP)
+ 			return 0;
+ 		return err;
+ 	}
+ 
+ 	if (nla_put(skb, IFLA_PHYS_SWITCH_ID, attr.u.ppid.id_len,
+ 		    attr.u.ppid.id))
+ 		return -EMSGSIZE;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 42275bd8fcb3 (switchdev: don't use anonymous union on switchdev attr/obj structs)
  static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
  			    int type, u32 pid, u32 seq, u32 change,
  			    unsigned int flags, u32 ext_filter_mask)
diff --cc net/dsa/slave.c
index 6ebd8fbd9285,04ffad311704..000000000000
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@@ -171,6 -308,134 +171,137 @@@ static int dsa_slave_ioctl(struct net_d
  	return -EOPNOTSUPP;
  }
  
++<<<<<<< HEAD
++=======
+ /* Return a bitmask of all ports being currently bridged within a given bridge
+  * device. Note that on leave, the mask will still return the bitmask of ports
+  * currently bridged, prior to port removal, and this is exactly what we want.
+  */
+ static u32 dsa_slave_br_port_mask(struct dsa_switch *ds,
+ 				  struct net_device *bridge)
+ {
+ 	struct dsa_slave_priv *p;
+ 	unsigned int port;
+ 	u32 mask = 0;
+ 
+ 	for (port = 0; port < DSA_MAX_PORTS; port++) {
+ 		if (!dsa_is_port_initialized(ds, port))
+ 			continue;
+ 
+ 		p = netdev_priv(ds->ports[port]);
+ 
+ 		if (ds->ports[port]->priv_flags & IFF_BRIDGE_PORT &&
+ 		    p->bridge_dev == bridge)
+ 			mask |= 1 << port;
+ 	}
+ 
+ 	return mask;
+ }
+ 
+ static int dsa_slave_stp_update(struct net_device *dev, u8 state)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->parent;
+ 	int ret = -EOPNOTSUPP;
+ 
+ 	if (ds->drv->port_stp_update)
+ 		ret = ds->drv->port_stp_update(ds, p->port, state);
+ 
+ 	return ret;
+ }
+ 
+ static int dsa_slave_port_attr_set(struct net_device *dev,
+ 				   struct switchdev_attr *attr)
+ {
+ 	int ret = 0;
+ 
+ 	switch (attr->id) {
+ 	case SWITCHDEV_ATTR_PORT_STP_STATE:
+ 		if (attr->trans == SWITCHDEV_TRANS_COMMIT)
+ 			ret = dsa_slave_stp_update(dev, attr->u.stp_state);
+ 		break;
+ 	default:
+ 		ret = -EOPNOTSUPP;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int dsa_slave_bridge_port_join(struct net_device *dev,
+ 				      struct net_device *br)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->parent;
+ 	int ret = -EOPNOTSUPP;
+ 
+ 	p->bridge_dev = br;
+ 
+ 	if (ds->drv->port_join_bridge)
+ 		ret = ds->drv->port_join_bridge(ds, p->port,
+ 						dsa_slave_br_port_mask(ds, br));
+ 
+ 	return ret;
+ }
+ 
+ static int dsa_slave_bridge_port_leave(struct net_device *dev)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->parent;
+ 	int ret = -EOPNOTSUPP;
+ 
+ 
+ 	if (ds->drv->port_leave_bridge)
+ 		ret = ds->drv->port_leave_bridge(ds, p->port,
+ 						 dsa_slave_br_port_mask(ds, p->bridge_dev));
+ 
+ 	p->bridge_dev = NULL;
+ 
+ 	/* Port left the bridge, put in BR_STATE_DISABLED by the bridge layer,
+ 	 * so allow it to be in BR_STATE_FORWARDING to be kept functional
+ 	 */
+ 	dsa_slave_stp_update(dev, BR_STATE_FORWARDING);
+ 
+ 	return ret;
+ }
+ 
+ static int dsa_slave_port_attr_get(struct net_device *dev,
+ 				   struct switchdev_attr *attr)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->parent;
+ 
+ 	switch (attr->id) {
+ 	case SWITCHDEV_ATTR_PORT_PARENT_ID:
+ 		attr->u.ppid.id_len = sizeof(ds->index);
+ 		memcpy(&attr->u.ppid.id, &ds->index, attr->u.ppid.id_len);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static netdev_tx_t dsa_slave_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 
+ 	return p->xmit(skb, dev);
+ }
+ 
+ static netdev_tx_t dsa_slave_notag_xmit(struct sk_buff *skb,
+ 					struct net_device *dev)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 
+ 	skb->dev = p->parent->dst->master_netdev;
+ 	dev_queue_xmit(skb);
+ 
+ 	return NETDEV_TX_OK;
+ }
+ 
++>>>>>>> 42275bd8fcb3 (switchdev: don't use anonymous union on switchdev attr/obj structs)
  
  /* ethtool operations *******************************************************/
  static int
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path include/net/switchdev.h
* Unmerged path net/switchdev/switchdev.c
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path include/net/switchdev.h
* Unmerged path net/bridge/br_stp.c
* Unmerged path net/core/net-sysfs.c
* Unmerged path net/core/rtnetlink.c
* Unmerged path net/dsa/slave.c
* Unmerged path net/switchdev/switchdev.c
