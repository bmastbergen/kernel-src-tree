perf record: Add clockid parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 814c8c38e13c7050259c72f89bb01f3fc903f642
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/814c8c38.failed

Teach perf-record about the new perf_event_attr::{use_clockid, clockid}
fields. Add a simple parameter to set the clock (if any) to be used for
the events to be recorded into the data file.

Since we store the entire perf_event_attr in the EVENT_DESC section we
also already store the used clockid in the data file.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: David Ahern <dsahern@gmail.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: John Stultz <john.stultz@linaro.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Yunlong Song <yunlong.song@huawei.com>
Link: http://lkml.kernel.org/r/20150407154851.GR23123@twins.programming.kicks-ass.net
[ Conditionally define CLOCK_BOOTTIME, at least rhel6 doesn't have it - dsahern
  Ditto for CLOCK_MONOTONIC_RAW, sles11sp2 doesn't have it - yunlong.song ]
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 814c8c38e13c7050259c72f89bb01f3fc903f642)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-record.txt
#	tools/perf/builtin-record.c
#	tools/perf/perf.h
#	tools/perf/util/evsel.c
diff --cc tools/perf/Documentation/perf-record.txt
index 051dd21d7926,4847a793de65..000000000000
--- a/tools/perf/Documentation/perf-record.txt
+++ b/tools/perf/Documentation/perf-record.txt
@@@ -303,30 -250,12 +303,39 @@@ symbolic names, e.g. on x86, ax, si. T
  --running-time::
  Record running and enabled time for read events (:S)
  
++<<<<<<< HEAD
 +-S::
 +--snapshot::
 +Select AUX area tracing Snapshot Mode. This option is valid only with an
 +AUX area tracing event. Optionally the number of bytes to capture per
 +snapshot can be specified. In Snapshot Mode, trace data is captured only when
 +signal SIGUSR2 is received.
 +
 +--proc-map-timeout::
 +When processing pre-existing threads /proc/XXX/mmap, it may take a long time,
 +because the file may be huge. A time out is needed in such cases.
 +This option sets the time out limit. The default value is 500 ms.
 +
 +--switch-events::
 +Record context switch events i.e. events of type PERF_RECORD_SWITCH or
 +PERF_RECORD_SWITCH_CPU_WIDE.
 +
 +--buildid-all::
 +Record build-id of all DSOs regardless whether it's actually hit or not.
 +
 +--all-kernel::
 +Configure all used events to run in kernel space.
 +
 +--all-user::
 +Configure all used events to run in user space.
++=======
+ -k::
+ --clockid::
+ Sets the clock id to use for the various time fields in the perf_event_type
+ records. See clock_gettime(). In particular CLOCK_MONOTONIC and
+ CLOCK_MONOTONIC_RAW are supported, some events might also allow
+ CLOCK_BOOTTIME, CLOCK_REALTIME and CLOCK_TAI.
++>>>>>>> 814c8c38e13c (perf record: Add clockid parameter)
  
  SEE ALSO
  --------
diff --cc tools/perf/builtin-record.c
index 9dd9b9ad314f,ac610488d2e1..000000000000
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@@ -1124,47 -711,88 +1124,132 @@@ static int perf_record_config(const cha
  	return perf_default_config(var, value, cb);
  }
  
++<<<<<<< HEAD
 +static int record__parse_mmap_pages(const struct option *opt,
 +				    const char *str,
 +				    int unset __maybe_unused)
 +{
 +	struct record_opts *opts = opt->value;
 +	char *s, *p;
 +	unsigned int mmap_pages;
 +	int ret;
 +
 +	if (!str)
 +		return -EINVAL;
 +
 +	s = strdup(str);
 +	if (!s)
 +		return -ENOMEM;
 +
 +	p = strchr(s, ',');
 +	if (p)
 +		*p = '\0';
 +
 +	if (*s) {
 +		ret = __perf_evlist__parse_mmap_pages(&mmap_pages, s);
 +		if (ret)
 +			goto out_free;
 +		opts->mmap_pages = mmap_pages;
 +	}
 +
 +	if (!p) {
 +		ret = 0;
 +		goto out_free;
 +	}
 +
 +	ret = __perf_evlist__parse_mmap_pages(&mmap_pages, p + 1);
 +	if (ret)
 +		goto out_free;
 +
 +	opts->auxtrace_mmap_pages = mmap_pages;
 +
 +out_free:
 +	free(s);
 +	return ret;
++=======
+ struct clockid_map {
+ 	const char *name;
+ 	int clockid;
+ };
+ 
+ #define CLOCKID_MAP(n, c)	\
+ 	{ .name = n, .clockid = (c), }
+ 
+ #define CLOCKID_END	{ .name = NULL, }
+ 
+ 
+ /*
+  * Add the missing ones, we need to build on many distros...
+  */
+ #ifndef CLOCK_MONOTONIC_RAW
+ #define CLOCK_MONOTONIC_RAW 4
+ #endif
+ #ifndef CLOCK_BOOTTIME
+ #define CLOCK_BOOTTIME 7
+ #endif
+ #ifndef CLOCK_TAI
+ #define CLOCK_TAI 11
+ #endif
+ 
+ static const struct clockid_map clockids[] = {
+ 	/* available for all events, NMI safe */
+ 	CLOCKID_MAP("monotonic", CLOCK_MONOTONIC),
+ 	CLOCKID_MAP("monotonic_raw", CLOCK_MONOTONIC_RAW),
+ 
+ 	/* available for some events */
+ 	CLOCKID_MAP("realtime", CLOCK_REALTIME),
+ 	CLOCKID_MAP("boottime", CLOCK_BOOTTIME),
+ 	CLOCKID_MAP("tai", CLOCK_TAI),
+ 
+ 	/* available for the lazy */
+ 	CLOCKID_MAP("mono", CLOCK_MONOTONIC),
+ 	CLOCKID_MAP("raw", CLOCK_MONOTONIC_RAW),
+ 	CLOCKID_MAP("real", CLOCK_REALTIME),
+ 	CLOCKID_MAP("boot", CLOCK_BOOTTIME),
+ 
+ 	CLOCKID_END,
+ };
+ 
+ static int parse_clockid(const struct option *opt, const char *str, int unset)
+ {
+ 	struct record_opts *opts = (struct record_opts *)opt->value;
+ 	const struct clockid_map *cm;
+ 	const char *ostr = str;
+ 
+ 	if (unset) {
+ 		opts->use_clockid = 0;
+ 		return 0;
+ 	}
+ 
+ 	/* no arg passed */
+ 	if (!str)
+ 		return 0;
+ 
+ 	/* no setting it twice */
+ 	if (opts->use_clockid)
+ 		return -1;
+ 
+ 	opts->use_clockid = true;
+ 
+ 	/* if its a number, we're done */
+ 	if (sscanf(str, "%d", &opts->clockid) == 1)
+ 		return 0;
+ 
+ 	/* allow a "CLOCK_" prefix to the name */
+ 	if (!strncasecmp(str, "CLOCK_", 6))
+ 		str += 6;
+ 
+ 	for (cm = clockids; cm->name; cm++) {
+ 		if (!strcasecmp(str, cm->name)) {
+ 			opts->clockid = cm->clockid;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	opts->use_clockid = false;
+ 	ui__warning("unknown clockid %s, check man page\n", ostr);
+ 	return -1;
++>>>>>>> 814c8c38e13c (perf record: Add clockid parameter)
  }
  
  static const char * const __record_usage[] = {
@@@ -1298,27 -922,13 +1383,33 @@@ struct option __record_options[] = 
  		    "sample transaction flags (special events only)"),
  	OPT_BOOLEAN(0, "per-thread", &record.opts.target.per_thread,
  		    "use per-thread mmaps"),
 -	OPT_BOOLEAN('I', "intr-regs", &record.opts.sample_intr_regs,
 -		    "Sample machine registers on interrupt"),
 +	OPT_CALLBACK_OPTARG('I', "intr-regs", &record.opts.sample_intr_regs, NULL, "any register",
 +		    "sample selected machine registers on interrupt,"
 +		    " use -I ? to list register names", parse_regs),
  	OPT_BOOLEAN(0, "running-time", &record.opts.running_time,
  		    "Record running/enabled time of read (:S) events"),
++<<<<<<< HEAD
 +	OPT_STRING_OPTARG('S', "snapshot", &record.opts.auxtrace_snapshot_opts,
 +			  "opts", "AUX area tracing Snapshot Mode", ""),
 +	OPT_UINTEGER(0, "proc-map-timeout", &record.opts.proc_map_timeout,
 +			"per thread proc mmap processing timeout in ms"),
 +	OPT_BOOLEAN(0, "switch-events", &record.opts.record_switch_events,
 +		    "Record context switch events"),
 +	OPT_BOOLEAN_FLAG(0, "all-kernel", &record.opts.all_kernel,
 +			 "Configure all used events to run in kernel space.",
 +			 PARSE_OPT_EXCLUSIVE),
 +	OPT_BOOLEAN_FLAG(0, "all-user", &record.opts.all_user,
 +			 "Configure all used events to run in user space.",
 +			 PARSE_OPT_EXCLUSIVE),
 +	OPT_BOOLEAN(0, "buildid-all", &record.buildid_all,
 +		    "Record build-id of all DSOs regardless of hits"),
 +	OPT_BOOLEAN(0, "timestamp-filename", &record.timestamp_filename,
 +		    "append timestamp to output filename"),
++=======
+ 	OPT_CALLBACK('k', "clockid", &record.opts,
+ 	"clockid", "clockid to use for events, see clock_gettime()",
+ 	parse_clockid),
++>>>>>>> 814c8c38e13c (perf record: Add clockid parameter)
  	OPT_END()
  };
  
diff --cc tools/perf/perf.h
index 693cda7dcc6f,e14bb637255c..000000000000
--- a/tools/perf/perf.h
+++ b/tools/perf/perf.h
@@@ -51,28 -51,19 +51,33 @@@ struct record_opts 
  	bool	     sample_address;
  	bool	     sample_weight;
  	bool	     sample_time;
 +	bool	     sample_time_set;
 +	bool	     callgraph_set;
  	bool	     period;
 -	bool	     sample_intr_regs;
  	bool	     running_time;
 +	bool	     full_auxtrace;
 +	bool	     auxtrace_snapshot_mode;
 +	bool	     record_switch_events;
 +	bool	     all_kernel;
 +	bool	     all_user;
  	unsigned int freq;
  	unsigned int mmap_pages;
 +	unsigned int auxtrace_mmap_pages;
  	unsigned int user_freq;
  	u64          branch_stack;
 +	u64	     sample_intr_regs;
  	u64	     default_interval;
  	u64	     user_interval;
 +	size_t	     auxtrace_snapshot_size;
 +	const char   *auxtrace_snapshot_opts;
  	bool	     sample_transaction;
  	unsigned     initial_delay;
++<<<<<<< HEAD
 +	unsigned int proc_map_timeout;
++=======
+ 	bool         use_clockid;
+ 	clockid_t    clockid;
++>>>>>>> 814c8c38e13c (perf record: Add clockid parameter)
  };
  
  struct option;
diff --cc tools/perf/util/evsel.c
index f76f126b80c9,d190f99a3a97..000000000000
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@@ -34,9 -32,12 +34,16 @@@ static struct 
  	bool exclude_guest;
  	bool mmap2;
  	bool cloexec;
++<<<<<<< HEAD
 +	bool lbr_flags;
++=======
+ 	bool clockid;
+ 	bool clockid_wrong;
++>>>>>>> 814c8c38e13c (perf record: Add clockid parameter)
  } perf_missing_features;
  
+ static clockid_t clockid;
+ 
  static int perf_evsel__no_extra_init(struct perf_evsel *evsel __maybe_unused)
  {
  	return 0;
@@@ -930,24 -766,11 +937,32 @@@ void perf_evsel__config(struct perf_evs
  		attr->enable_on_exec = 0;
  	}
  
++<<<<<<< HEAD
 +	if (evsel->precise_max)
 +		perf_event_attr__set_max_precise_ip(attr);
 +
 +	if (opts->all_user) {
 +		attr->exclude_kernel = 1;
 +		attr->exclude_user   = 0;
 +	}
 +
 +	if (opts->all_kernel) {
 +		attr->exclude_kernel = 0;
 +		attr->exclude_user   = 1;
 +	}
 +
 +	/*
 +	 * Apply event specific term settings,
 +	 * it overloads any global configuration.
 +	 */
 +	apply_config_terms(evsel, opts);
++=======
+ 	clockid = opts->clockid;
+ 	if (opts->use_clockid) {
+ 		attr->use_clockid = 1;
+ 		attr->clockid = opts->clockid;
+ 	}
++>>>>>>> 814c8c38e13c (perf record: Add clockid parameter)
  }
  
  static int perf_evsel__alloc_fd(struct perf_evsel *evsel, int ncpus, int nthreads)
@@@ -1236,135 -1011,66 +1251,166 @@@ static int get_group_fd(struct perf_evs
  	return fd;
  }
  
 -#define __PRINT_ATTR(fmt, cast, field)  \
 -	fprintf(fp, "  %-19s "fmt"\n", #field, cast attr->field)
 -
 -#define PRINT_ATTR_U32(field)  __PRINT_ATTR("%u" , , field)
 -#define PRINT_ATTR_X32(field)  __PRINT_ATTR("%#x", , field)
 -#define PRINT_ATTR_U64(field)  __PRINT_ATTR("%" PRIu64, (uint64_t), field)
 -#define PRINT_ATTR_X64(field)  __PRINT_ATTR("%#"PRIx64, (uint64_t), field)
 +struct bit_names {
 +	int bit;
 +	const char *name;
 +};
  
 -#define PRINT_ATTR2N(name1, field1, name2, field2)	\
 -	fprintf(fp, "  %-19s %u    %-19s %u\n",		\
 -	name1, attr->field1, name2, attr->field2)
 +static void __p_bits(char *buf, size_t size, u64 value, struct bit_names *bits)
 +{
 +	bool first_bit = true;
 +	int i = 0;
  
 -#define PRINT_ATTR2(field1, field2) \
 -	PRINT_ATTR2N(#field1, field1, #field2, field2)
 +	do {
 +		if (value & bits[i].bit) {
 +			buf += scnprintf(buf, size, "%s%s", first_bit ? "" : "|", bits[i].name);
 +			first_bit = false;
 +		}
 +	} while (bits[++i].name != NULL);
 +}
  
 -static size_t perf_event_attr__fprintf(struct perf_event_attr *attr, FILE *fp)
 +static void __p_sample_type(char *buf, size_t size, u64 value)
  {
 -	size_t ret = 0;
 -
 -	ret += fprintf(fp, "%.60s\n", graph_dotted_line);
 -	ret += fprintf(fp, "perf_event_attr:\n");
 +#define bit_name(n) { PERF_SAMPLE_##n, #n }
 +	struct bit_names bits[] = {
 +		bit_name(IP), bit_name(TID), bit_name(TIME), bit_name(ADDR),
 +		bit_name(READ), bit_name(CALLCHAIN), bit_name(ID), bit_name(CPU),
 +		bit_name(PERIOD), bit_name(STREAM_ID), bit_name(RAW),
 +		bit_name(BRANCH_STACK), bit_name(REGS_USER), bit_name(STACK_USER),
 +		bit_name(IDENTIFIER), bit_name(REGS_INTR), bit_name(DATA_SRC),
 +		bit_name(WEIGHT),
 +		{ .name = NULL, }
 +	};
 +#undef bit_name
 +	__p_bits(buf, size, value, bits);
 +}
  
 -	ret += PRINT_ATTR_U32(type);
 -	ret += PRINT_ATTR_U32(size);
 -	ret += PRINT_ATTR_X64(config);
 -	ret += PRINT_ATTR_U64(sample_period);
 -	ret += PRINT_ATTR_U64(sample_freq);
 -	ret += PRINT_ATTR_X64(sample_type);
 -	ret += PRINT_ATTR_X64(read_format);
++<<<<<<< HEAD
 +static void __p_branch_sample_type(char *buf, size_t size, u64 value)
 +{
 +#define bit_name(n) { PERF_SAMPLE_BRANCH_##n, #n }
 +	struct bit_names bits[] = {
 +		bit_name(USER), bit_name(KERNEL), bit_name(HV), bit_name(ANY),
 +		bit_name(ANY_CALL), bit_name(ANY_RETURN), bit_name(IND_CALL),
 +		bit_name(ABORT_TX), bit_name(IN_TX), bit_name(NO_TX),
 +		bit_name(COND), bit_name(CALL_STACK), bit_name(IND_JUMP),
 +		bit_name(CALL), bit_name(NO_FLAGS), bit_name(NO_CYCLES),
 +		{ .name = NULL, }
 +	};
 +#undef bit_name
 +	__p_bits(buf, size, value, bits);
 +}
  
 +static void __p_read_format(char *buf, size_t size, u64 value)
 +{
 +#define bit_name(n) { PERF_FORMAT_##n, #n }
 +	struct bit_names bits[] = {
 +		bit_name(TOTAL_TIME_ENABLED), bit_name(TOTAL_TIME_RUNNING),
 +		bit_name(ID), bit_name(GROUP),
 +		{ .name = NULL, }
 +	};
 +#undef bit_name
 +	__p_bits(buf, size, value, bits);
 +}
++=======
+ 	ret += PRINT_ATTR2(disabled, inherit);
+ 	ret += PRINT_ATTR2(pinned, exclusive);
+ 	ret += PRINT_ATTR2(exclude_user, exclude_kernel);
+ 	ret += PRINT_ATTR2(exclude_hv, exclude_idle);
+ 	ret += PRINT_ATTR2(mmap, comm);
+ 	ret += PRINT_ATTR2(freq, inherit_stat);
+ 	ret += PRINT_ATTR2(enable_on_exec, task);
+ 	ret += PRINT_ATTR2(watermark, precise_ip);
+ 	ret += PRINT_ATTR2(mmap_data, sample_id_all);
+ 	ret += PRINT_ATTR2(exclude_host, exclude_guest);
+ 	ret += PRINT_ATTR2N("excl.callchain_kern", exclude_callchain_kernel,
+ 			    "excl.callchain_user", exclude_callchain_user);
+ 	ret += PRINT_ATTR2(mmap2, comm_exec);
+ 	ret += __PRINT_ATTR("%u",,use_clockid);
+ 
+ 
+ 	ret += PRINT_ATTR_U32(wakeup_events);
+ 	ret += PRINT_ATTR_U32(wakeup_watermark);
+ 	ret += PRINT_ATTR_X32(bp_type);
+ 	ret += PRINT_ATTR_X64(bp_addr);
+ 	ret += PRINT_ATTR_X64(config1);
+ 	ret += PRINT_ATTR_U64(bp_len);
+ 	ret += PRINT_ATTR_X64(config2);
+ 	ret += PRINT_ATTR_X64(branch_sample_type);
+ 	ret += PRINT_ATTR_X64(sample_regs_user);
+ 	ret += PRINT_ATTR_U32(sample_stack_user);
+ 	ret += PRINT_ATTR_U32(clockid);
+ 	ret += PRINT_ATTR_X64(sample_regs_intr);
++>>>>>>> 814c8c38e13c (perf record: Add clockid parameter)
 +
 +#define BUF_SIZE		1024
  
 -	ret += fprintf(fp, "%.60s\n", graph_dotted_line);
 +#define p_hex(val)		snprintf(buf, BUF_SIZE, "%#"PRIx64, (uint64_t)(val))
 +#define p_unsigned(val)		snprintf(buf, BUF_SIZE, "%"PRIu64, (uint64_t)(val))
 +#define p_signed(val)		snprintf(buf, BUF_SIZE, "%"PRId64, (int64_t)(val))
 +#define p_sample_type(val)	__p_sample_type(buf, BUF_SIZE, val)
 +#define p_branch_sample_type(val) __p_branch_sample_type(buf, BUF_SIZE, val)
 +#define p_read_format(val)	__p_read_format(buf, BUF_SIZE, val)
 +
 +#define PRINT_ATTRn(_n, _f, _p)				\
 +do {							\
 +	if (attr->_f) {					\
 +		_p(attr->_f);				\
 +		ret += attr__fprintf(fp, _n, buf, priv);\
 +	}						\
 +} while (0)
 +
 +#define PRINT_ATTRf(_f, _p)	PRINT_ATTRn(#_f, _f, _p)
 +
 +int perf_event_attr__fprintf(FILE *fp, struct perf_event_attr *attr,
 +			     attr__fprintf_f attr__fprintf, void *priv)
 +{
 +	char buf[BUF_SIZE];
 +	int ret = 0;
 +
 +	PRINT_ATTRf(type, p_unsigned);
 +	PRINT_ATTRf(size, p_unsigned);
 +	PRINT_ATTRf(config, p_hex);
 +	PRINT_ATTRn("{ sample_period, sample_freq }", sample_period, p_unsigned);
 +	PRINT_ATTRf(sample_type, p_sample_type);
 +	PRINT_ATTRf(read_format, p_read_format);
 +
 +	PRINT_ATTRf(disabled, p_unsigned);
 +	PRINT_ATTRf(inherit, p_unsigned);
 +	PRINT_ATTRf(pinned, p_unsigned);
 +	PRINT_ATTRf(exclusive, p_unsigned);
 +	PRINT_ATTRf(exclude_user, p_unsigned);
 +	PRINT_ATTRf(exclude_kernel, p_unsigned);
 +	PRINT_ATTRf(exclude_hv, p_unsigned);
 +	PRINT_ATTRf(exclude_idle, p_unsigned);
 +	PRINT_ATTRf(mmap, p_unsigned);
 +	PRINT_ATTRf(comm, p_unsigned);
 +	PRINT_ATTRf(freq, p_unsigned);
 +	PRINT_ATTRf(inherit_stat, p_unsigned);
 +	PRINT_ATTRf(enable_on_exec, p_unsigned);
 +	PRINT_ATTRf(task, p_unsigned);
 +	PRINT_ATTRf(watermark, p_unsigned);
 +	PRINT_ATTRf(precise_ip, p_unsigned);
 +	PRINT_ATTRf(mmap_data, p_unsigned);
 +	PRINT_ATTRf(sample_id_all, p_unsigned);
 +	PRINT_ATTRf(exclude_host, p_unsigned);
 +	PRINT_ATTRf(exclude_guest, p_unsigned);
 +	PRINT_ATTRf(exclude_callchain_kernel, p_unsigned);
 +	PRINT_ATTRf(exclude_callchain_user, p_unsigned);
 +	PRINT_ATTRf(mmap2, p_unsigned);
 +	PRINT_ATTRf(comm_exec, p_unsigned);
 +	PRINT_ATTRf(context_switch, p_unsigned);
 +	PRINT_ATTRf(write_backward, p_unsigned);
 +
 +	PRINT_ATTRn("{ wakeup_events, wakeup_watermark }", wakeup_events, p_unsigned);
 +	PRINT_ATTRf(bp_type, p_unsigned);
 +	PRINT_ATTRn("{ bp_addr, config1 }", bp_addr, p_hex);
 +	PRINT_ATTRn("{ bp_len, config2 }", bp_len, p_hex);
 +	PRINT_ATTRf(branch_sample_type, p_branch_sample_type);
 +	PRINT_ATTRf(sample_regs_user, p_hex);
 +	PRINT_ATTRf(sample_stack_user, p_unsigned);
 +	PRINT_ATTRf(sample_regs_intr, p_hex);
 +	PRINT_ATTRf(aux_watermark, p_unsigned);
  
  	return ret;
  }
@@@ -2312,40 -2080,51 +2385,83 @@@ int perf_evsel__fprintf(struct perf_evs
  
  	printed += fprintf(fp, "%s", perf_evsel__name(evsel));
  
 -	if (details->verbose || details->freq) {
 -		printed += comma_fprintf(fp, &first, " sample_freq=%" PRIu64,
 -					 (u64)evsel->attr.sample_freq);
 +	if (details->verbose) {
 +		printed += perf_event_attr__fprintf(fp, &evsel->attr,
 +						    __print_attr__fprintf, &first);
 +	} else if (details->freq) {
 +		const char *term = "sample_freq";
 +
 +		if (!evsel->attr.freq)
 +			term = "sample_period";
 +
 +		printed += comma_fprintf(fp, &first, " %s=%" PRIu64,
 +					 term, (u64)evsel->attr.sample_freq);
  	}
  
++<<<<<<< HEAD
 +	if (details->trace_fields) {
 +		struct format_field *field;
 +
 +		if (evsel->attr.type != PERF_TYPE_TRACEPOINT) {
 +			printed += comma_fprintf(fp, &first, " (not a tracepoint)");
 +			goto out;
 +		}
 +
 +		field = evsel->tp_format->format.fields;
 +		if (field == NULL) {
 +			printed += comma_fprintf(fp, &first, " (no trace field)");
 +			goto out;
 +		}
 +
 +		printed += comma_fprintf(fp, &first, " trace_fields: %s", field->name);
 +
 +		field = field->next;
 +		while (field) {
 +			printed += comma_fprintf(fp, &first, "%s", field->name);
 +			field = field->next;
 +		}
++=======
+ 	if (details->verbose) {
+ 		if_print(type);
+ 		if_print(config);
+ 		if_print(config1);
+ 		if_print(config2);
+ 		if_print(size);
+ 		printed += sample_type__fprintf(fp, &first, evsel->attr.sample_type);
+ 		if (evsel->attr.read_format)
+ 			printed += read_format__fprintf(fp, &first, evsel->attr.read_format);
+ 		if_print(disabled);
+ 		if_print(inherit);
+ 		if_print(pinned);
+ 		if_print(exclusive);
+ 		if_print(exclude_user);
+ 		if_print(exclude_kernel);
+ 		if_print(exclude_hv);
+ 		if_print(exclude_idle);
+ 		if_print(mmap);
+ 		if_print(comm);
+ 		if_print(freq);
+ 		if_print(inherit_stat);
+ 		if_print(enable_on_exec);
+ 		if_print(task);
+ 		if_print(watermark);
+ 		if_print(precise_ip);
+ 		if_print(mmap_data);
+ 		if_print(sample_id_all);
+ 		if_print(exclude_host);
+ 		if_print(exclude_guest);
+ 		if_print(mmap2);
+ 		if_print(comm_exec);
+ 		if_print(use_clockid);
+ 		if_print(__reserved_1);
+ 		if_print(wakeup_events);
+ 		if_print(bp_type);
+ 		if_print(branch_sample_type);
+ 		if_print(sample_regs_user);
+ 		if_print(sample_stack_user);
+ 		if_print(clockid);
+ 		if_print(sample_regs_intr);
++>>>>>>> 814c8c38e13c (perf record: Add clockid parameter)
  	}
  out:
  	fputc('\n', fp);
* Unmerged path tools/perf/Documentation/perf-record.txt
* Unmerged path tools/perf/builtin-record.c
* Unmerged path tools/perf/perf.h
* Unmerged path tools/perf/util/evsel.c
diff --git a/tools/perf/util/header.c b/tools/perf/util/header.c
index ea25918195d9..15c2f622f54b 100644
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@ -1287,6 +1287,9 @@ static void print_event_desc(struct perf_header *ph, int fd, FILE *fp)
 			}
 			fprintf(fp, " }");
 		}
+		if (evsel->attr.use_clockid)
+			fprintf(fp, ", clockid = %d", evsel->attr.clockid);
+
 
 		perf_event_attr__fprintf(fp, &evsel->attr, __desc_attr__fprintf, NULL);
 
