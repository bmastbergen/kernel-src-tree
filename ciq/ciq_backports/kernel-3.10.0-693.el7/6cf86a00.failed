btrfs: create a helper function to read the disk super

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Anand Jain <anand.jain@oracle.com>
commit 6cf86a006be9f2a77434d5a06ea289719815ad7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6cf86a00.failed

A part of code from btrfs_scan_one_device() is moved to a new function
btrfs_read_disk_super(), so that former function looks cleaner. (In this
process it also moves the code which ensures null terminating label). So
this creates easy opportunity to merge various duplicate codes on read
disk super. Earlier attempt to merge duplicate codes highlighted that
there were some issues for which there are duplicate codes (to read disk
super), however it was not clear what was the issue. So until we figure
that out, its better to keep them in a separate functions.

	Signed-off-by: Anand Jain <anand.jain@oracle.com>
[ use GFP_KERNEL, PAGE_CACHE_ removal related fixups ]
	Signed-off-by: David Sterba <dsterba@suse.com>
(cherry picked from commit 6cf86a006be9f2a77434d5a06ea289719815ad7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/volumes.c
diff --cc fs/btrfs/volumes.c
index 6798f7ce7f00,5006683283ae..000000000000
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@@ -1024,35 -1071,9 +1071,41 @@@ int btrfs_scan_one_device(const char *p
  		goto error;
  	}
  
++<<<<<<< HEAD
 +	/* make sure our super fits in the device */
 +	if (bytenr + PAGE_CACHE_SIZE >= i_size_read(bdev->bd_inode))
 +		goto error_bdev_put;
 +
 +	/* make sure our super fits in the page */
 +	if (sizeof(*disk_super) > PAGE_CACHE_SIZE)
 +		goto error_bdev_put;
 +
 +	/* make sure our super doesn't straddle pages on disk */
 +	index = bytenr >> PAGE_CACHE_SHIFT;
 +	if ((bytenr + sizeof(*disk_super) - 1) >> PAGE_CACHE_SHIFT != index)
 +		goto error_bdev_put;
 +
 +	/* pull in the page with our super */
 +	page = read_cache_page_gfp(bdev->bd_inode->i_mapping,
 +				   index, GFP_NOFS);
 +
 +	if (IS_ERR_OR_NULL(page))
 +		goto error_bdev_put;
 +
 +	p = kmap(page);
 +
 +	/* align our pointer to the offset of the super block */
 +	disk_super = p + (bytenr & ~PAGE_CACHE_MASK);
 +
 +	if (btrfs_super_bytenr(disk_super) != bytenr ||
 +	    btrfs_super_magic(disk_super) != BTRFS_MAGIC)
 +		goto error_unmap;
 +
++=======
+ 	if (btrfs_read_disk_super(bdev, bytenr, &page, &disk_super))
+ 		goto error_bdev_put;
+ 
++>>>>>>> 6cf86a006be9 (btrfs: create a helper function to read the disk super)
  	devid = btrfs_stack_device_id(&disk_super->dev_item);
  	transid = btrfs_super_generation(disk_super);
  	total_devices = btrfs_super_num_devices(disk_super);
@@@ -1073,9 -1092,7 +1124,13 @@@
  	if (!ret && fs_devices_ret)
  		(*fs_devices_ret)->total_devices = total_devices;
  
++<<<<<<< HEAD
 +error_unmap:
 +	kunmap(page);
 +	page_cache_release(page);
++=======
+ 	btrfs_release_disk_super(page);
++>>>>>>> 6cf86a006be9 (btrfs: create a helper function to read the disk super)
  
  error_bdev_put:
  	blkdev_put(bdev, flags);
* Unmerged path fs/btrfs/volumes.c
