amd-xgbe: Set DMA mask based on hardware register value

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit 386d325dbdf16919f3416a1b6f26fcfd1c9549ff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/386d325d.failed

The hardware supplies a value that indicates the DMA range that it
is capable of using. Use this value rather than hard-coding it in
the driver.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 386d325dbdf16919f3416a1b6f26fcfd1c9549ff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-drv.c
#	drivers/net/ethernet/amd/xgbe/xgbe-main.c
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index add1b5ac7b5d,ef4625e48976..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@@ -387,7 -539,37 +388,41 @@@ void xgbe_get_all_hw_features(struct xg
  	hw_feat->pps_out_num  = XGMAC_GET_BITS(mac_hfr2, MAC_HWF2R, PPSOUTNUM);
  	hw_feat->aux_snap_num = XGMAC_GET_BITS(mac_hfr2, MAC_HWF2R, AUXSNAPNUM);
  
++<<<<<<< HEAD
 +	/* The Queue and Channel counts are zero based so increment them
++=======
+ 	/* Translate the Hash Table size into actual number */
+ 	switch (hw_feat->hash_table_size) {
+ 	case 0:
+ 		break;
+ 	case 1:
+ 		hw_feat->hash_table_size = 64;
+ 		break;
+ 	case 2:
+ 		hw_feat->hash_table_size = 128;
+ 		break;
+ 	case 3:
+ 		hw_feat->hash_table_size = 256;
+ 		break;
+ 	}
+ 
+ 	/* Translate the address width setting into actual number */
+ 	switch (hw_feat->dma_width) {
+ 	case 0:
+ 		hw_feat->dma_width = 32;
+ 		break;
+ 	case 1:
+ 		hw_feat->dma_width = 40;
+ 		break;
+ 	case 2:
+ 		hw_feat->dma_width = 48;
+ 		break;
+ 	default:
+ 		hw_feat->dma_width = 32;
+ 	}
+ 
+ 	/* The Queue, Channel and TC counts are zero based so increment them
++>>>>>>> 386d325dbdf1 (amd-xgbe: Set DMA mask based on hardware register value)
  	 * to get the actual number
  	 */
  	hw_feat->rx_q_cnt++;
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-main.c
index 51cdca78ec38,2e4c22d94a6b..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-main.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-main.c
@@@ -292,16 -329,42 +292,55 @@@ static int xgbe_probe(struct platform_d
  	}
  	DBGPR("  xpcs_regs  = %p\n", pdata->xpcs_regs);
  
++<<<<<<< HEAD
 +	/* Set the DMA mask */
 +	if (!dev->dma_mask)
 +		dev->dma_mask = &dev->coherent_dma_mask;
 +	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(40));
 +	if (ret) {
 +		dev_err(dev, "dma_set_mask_and_coherent failed\n");
 +		goto err_io;
 +	}
 +
 +	if (of_property_read_bool(dev->of_node, "dma-coherent")) {
++=======
+ 	/* Retrieve the MAC address */
+ 	ret = device_property_read_u8_array(dev, XGBE_MAC_ADDR_PROPERTY,
+ 					    pdata->mac_addr,
+ 					    sizeof(pdata->mac_addr));
+ 	if (ret || !is_valid_ether_addr(pdata->mac_addr)) {
+ 		dev_err(dev, "invalid %s property\n", XGBE_MAC_ADDR_PROPERTY);
+ 		if (!ret)
+ 			ret = -EINVAL;
+ 		goto err_io;
+ 	}
+ 
+ 	/* Retrieve the PHY mode - it must be "xgmii" */
+ 	ret = device_property_read_string(dev, XGBE_PHY_MODE_PROPERTY,
+ 					  &phy_mode);
+ 	if (ret || strcmp(phy_mode, phy_modes(PHY_INTERFACE_MODE_XGMII))) {
+ 		dev_err(dev, "invalid %s property\n", XGBE_PHY_MODE_PROPERTY);
+ 		if (!ret)
+ 			ret = -EINVAL;
+ 		goto err_io;
+ 	}
+ 	pdata->phy_mode = PHY_INTERFACE_MODE_XGMII;
+ 
+ 	/* Check for per channel interrupt support */
+ 	if (device_property_present(dev, XGBE_DMA_IRQS_PROPERTY))
+ 		pdata->per_channel_irq = 1;
+ 
+ 	/* Obtain device settings unique to ACPI/OF */
+ 	if (pdata->use_acpi)
+ 		ret = xgbe_acpi_support(pdata);
+ 	else
+ 		ret = xgbe_of_support(pdata);
+ 	if (ret)
+ 		goto err_io;
+ 
+ 	/* Set the DMA coherency values */
+ 	if (pdata->coherent) {
++>>>>>>> 386d325dbdf1 (amd-xgbe: Set DMA mask based on hardware register value)
  		pdata->axdomain = XGBE_DMA_OS_AXDOMAIN;
  		pdata->arcache = XGBE_DMA_OS_ARCACHE;
  		pdata->awcache = XGBE_DMA_OS_AWCACHE;
@@@ -311,13 -374,17 +350,17 @@@
  		pdata->awcache = XGBE_DMA_SYS_AWCACHE;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Get the device interrupt */
++>>>>>>> 386d325dbdf1 (amd-xgbe: Set DMA mask based on hardware register value)
  	ret = platform_get_irq(pdev, 0);
  	if (ret < 0) {
 -		dev_err(dev, "platform_get_irq 0 failed\n");
 +		dev_err(dev, "platform_get_irq failed\n");
  		goto err_io;
  	}
 -	pdata->dev_irq = ret;
 -
 -	netdev->irq = pdata->dev_irq;
 +	netdev->irq = ret;
  	netdev->base_addr = (unsigned long)pdata->xgmac_regs;
 -	memcpy(netdev->dev_addr, pdata->mac_addr, netdev->addr_len);
  
  	/* Set all the function pointers */
  	xgbe_init_all_fptrs(pdata);
@@@ -350,10 -400,28 +393,30 @@@
  	/* Set default configuration data */
  	xgbe_default_config(pdata);
  
++<<<<<<< HEAD
 +	/* Calculate the number of Tx and Rx rings to be created */
++=======
+ 	/* Set the DMA mask */
+ 	if (!dev->dma_mask)
+ 		dev->dma_mask = &dev->coherent_dma_mask;
+ 	ret = dma_set_mask_and_coherent(dev,
+ 					DMA_BIT_MASK(pdata->hw_feat.dma_width));
+ 	if (ret) {
+ 		dev_err(dev, "dma_set_mask_and_coherent failed\n");
+ 		goto err_io;
+ 	}
+ 
+ 	/* Calculate the number of Tx and Rx rings to be created
+ 	 *  -Tx (DMA) Channels map 1-to-1 to Tx Queues so set
+ 	 *   the number of Tx queues to the number of Tx channels
+ 	 *   enabled
+ 	 *  -Rx (DMA) Channels do not map 1-to-1 so use the actual
+ 	 *   number of Rx queues
+ 	 */
++>>>>>>> 386d325dbdf1 (amd-xgbe: Set DMA mask based on hardware register value)
  	pdata->tx_ring_count = min_t(unsigned int, num_online_cpus(),
  				     pdata->hw_feat.tx_ch_cnt);
 -	pdata->tx_q_count = pdata->tx_ring_count;
 -	ret = netif_set_real_num_tx_queues(netdev, pdata->tx_ring_count);
 -	if (ret) {
 +	if (netif_set_real_num_tx_queues(netdev, pdata->tx_ring_count)) {
  		dev_err(dev, "error setting real tx queue count\n");
  		goto err_io;
  	}
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-common.h b/drivers/net/ethernet/amd/xgbe/xgbe-common.h
index 3373e9ef2003..907a4ec484e7 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-common.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-common.h
@@ -347,6 +347,8 @@
 #define MAC_HWF0R_TXCOESEL_WIDTH	1
 #define MAC_HWF0R_VLHASH_INDEX		4
 #define MAC_HWF0R_VLHASH_WIDTH		1
+#define MAC_HWF1R_ADDR64_INDEX		14
+#define MAC_HWF1R_ADDR64_WIDTH		2
 #define MAC_HWF1R_ADVTHWORD_INDEX	13
 #define MAC_HWF1R_ADVTHWORD_WIDTH	1
 #define MAC_HWF1R_DBGMEMA_INDEX		19
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-main.c
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe.h b/drivers/net/ethernet/amd/xgbe/xgbe.h
index 1d8899bca25d..6cc2ebcc07a4 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@ -497,6 +497,7 @@ struct xgbe_hw_features {
 	unsigned int rx_fifo_size;	/* MTL Receive FIFO Size */
 	unsigned int tx_fifo_size;	/* MTL Transmit FIFO Size */
 	unsigned int adv_ts_hi;		/* Advance Timestamping High Word */
+	unsigned int dma_width;		/* DMA width */
 	unsigned int dcb;		/* DCB Feature */
 	unsigned int sph;		/* Split Header Feature */
 	unsigned int tso;		/* TCP Segmentation Offload */
