autofs races

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit ea01a18494b3d7a91b2f1f2a6a5aaef4741bc294
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ea01a184.failed

* make autofs4_expire_indirect() skip the dentries being in process of
expiry
* do *not* mess with list_move(); making sure that dentry with
AUTOFS_INF_EXPIRING are not picked for expiry is enough.
* do not remove NO_RCU when we set EXPIRING, don't bother with smp_mb()
there.  Clear it at the same time we clear EXPIRING.  Makes a bunch of
tests simpler.
* rename NO_RCU to WANT_EXPIRE, which is what it really is.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit ea01a18494b3d7a91b2f1f2a6a5aaef4741bc294)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/autofs4/autofs_i.h
#	fs/autofs4/expire.c
#	fs/autofs4/root.c
diff --cc fs/autofs4/autofs_i.h
index 463026a80dfa,a439548de785..000000000000
--- a/fs/autofs4/autofs_i.h
+++ b/fs/autofs4/autofs_i.h
@@@ -78,10 -69,14 +78,19 @@@ struct autofs_info 
  	kgid_t gid;
  };
  
++<<<<<<< HEAD
 +#define AUTOFS_INF_EXPIRING	(1<<0) /* dentry is in the process of expiring */
 +#define AUTOFS_INF_NO_RCU	(1<<1) /* the dentry is being considered
++=======
+ #define AUTOFS_INF_EXPIRING	(1<<0) /* dentry in the process of expiring */
+ #define AUTOFS_INF_WANT_EXPIRE	(1<<1) /* the dentry is being considered
++>>>>>>> ea01a18494b3 (autofs races)
  					* for expiry, so RCU_walk is
- 					* not permitted
+ 					* not permitted.  If it progresses to
+ 					* actual expiry attempt, the flag is
+ 					* not cleared when EXPIRING is set -
+ 					* in that case it gets cleared only
+ 					* when it comes to clearing EXPIRING.
  					*/
  #define AUTOFS_INF_PENDING	(1<<2) /* dentry pending mount */
  
diff --cc fs/autofs4/expire.c
index 683a5b9ce22a,b493909e7492..000000000000
--- a/fs/autofs4/expire.c
+++ b/fs/autofs4/expire.c
@@@ -479,20 -471,10 +477,21 @@@ struct dentry *autofs4_expire_indirect(
  	return NULL;
  
  found:
 -	pr_debug("returning %p %pd\n", expired, expired);
 +	DPRINTK("returning %p %.*s",
 +		expired, (int)expired->d_name.len, expired->d_name.name);
  	ino->flags |= AUTOFS_INF_EXPIRING;
- 	smp_mb();
- 	ino->flags &= ~AUTOFS_INF_NO_RCU;
  	init_completion(&ino->expire_complete);
  	spin_unlock(&sbi->fs_lock);
++<<<<<<< HEAD
 +	spin_lock(&sbi->lookup_lock);
 +	spin_lock(&expired->d_parent->d_lock);
 +	spin_lock_nested(&expired->d_lock, DENTRY_D_LOCK_NESTED);
 +	list_move(&expired->d_parent->d_subdirs, &expired->d_u.d_child);
 +	spin_unlock(&expired->d_lock);
 +	spin_unlock(&expired->d_parent->d_lock);
 +	spin_unlock(&sbi->lookup_lock);
++=======
++>>>>>>> ea01a18494b3 (autofs races)
  	return expired;
  }
  
diff --cc fs/autofs4/root.c
index c8ae501dec34,3767f6641af1..000000000000
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@@ -459,7 -457,8 +459,12 @@@ static int autofs4_d_manage(struct dent
  		 * a mount-trap.
  		 */
  		struct inode *inode;
++<<<<<<< HEAD
 +		if (ino->flags & (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU))
++=======
+ 
+ 		if (ino->flags & AUTOFS_INF_WANT_EXPIRE)
++>>>>>>> ea01a18494b3 (autofs races)
  			return 0;
  		if (d_mountpoint(dentry))
  			return 0;
* Unmerged path fs/autofs4/autofs_i.h
* Unmerged path fs/autofs4/expire.c
* Unmerged path fs/autofs4/root.c
