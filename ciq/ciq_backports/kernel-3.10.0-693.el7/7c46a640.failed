net: Merge VXLAN and GENEVE push notifiers into a single notifier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] Merge VXLAN and GENEVE push notifiers into a single notifier (Sabrina Dubroca) [1326309]
Rebuild_FUZZ: 96.00%
commit-author Alexander Duyck <aduyck@mirantis.com>
commit 7c46a640de6fcc4f35d0702710356a024eadf68f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7c46a640.failed

This patch merges the notifiers for VXLAN and GENEVE into a single UDP
tunnel notifier.  The idea is that we will want to only have to make one
notifier call to receive the list of ports for VXLAN and GENEVE tunnels
that need to be offloaded.

In addition we add a new set of ndo functions named ndo_udp_tunnel_add and
ndo_udp_tunnel_del that are meant to allow us to track the tunnel meta-data
such as port and address family as tunnels are added and removed.  The
tunnel meta-data is now transported in a structure named udp_tunnel_info
which for now carries the type, address family, and port number.  In the
future this could be updated so that we can include a tuple of values
including things such as the destination IP address and other fields.

I also ended up going with a naming scheme that consisted of using the
prefix udp_tunnel on function names.  I applied this to the notifier and
ndo ops as well so that it hopefully points to the fact that these are
primarily used in the udp_tunnel functions.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7c46a640de6fcc4f35d0702710356a024eadf68f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
diff --cc include/linux/netdevice.h
index 0c457a76a538,577d2a1814b1..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -63,9 -60,9 +63,15 @@@ struct phy_device
  struct wireless_dev;
  /* 802.15.4 specific */
  struct wpan_dev;
++<<<<<<< HEAD
 +					/* source back-compat hooks */
 +#define SET_ETHTOOL_OPS(netdev,ops) \
 +	( (netdev)->ethtool_ops = (ops) )
++=======
+ struct mpls_dev;
+ /* UDP Tunnel offloads */
+ struct udp_tunnel_info;
++>>>>>>> 7c46a640de6f (net: Merge VXLAN and GENEVE push notifiers into a single notifier)
  
  void netdev_set_default_ethtool_ops(struct net_device *dev,
  				    const struct ethtool_ops *ops);
@@@ -1106,12 -1052,40 +1112,49 @@@ struct net_device_ops_extended 
   *	address family that vxlan is not listening to anymore. The operation
   *	is protected by the vxlan_net->sock_lock.
   *
++<<<<<<< HEAD
 + * int (*ndo_get_iflink)(const struct net_device *dev);
 + *	Called to get the iflink value of this device.
 + *
 + * netdev_features_t (*ndo_features_check) (struct sk_buff *skb,
 + *					    struct net_device *dev
 + *					    netdev_features_t features);
++=======
+  * void (*ndo_udp_tunnel_add)(struct net_device *dev,
+  *			      struct udp_tunnel_info *ti);
+  *	Called by UDP tunnel to notify a driver about the UDP port and socket
+  *	address family that a UDP tunnel is listnening to. It is called only
+  *	when a new port starts listening. The operation is protected by the
+  *	RTNL.
+  *
+  * void (*ndo_udp_tunnel_del)(struct net_device *dev,
+  *			      struct udp_tunnel_info *ti);
+  *	Called by UDP tunnel to notify the driver about a UDP port and socket
+  *	address family that the UDP tunnel is not listening to anymore. The
+  *	operation is protected by the RTNL.
+  *
+  * void* (*ndo_dfwd_add_station)(struct net_device *pdev,
+  *				 struct net_device *dev)
+  *	Called by upper layer devices to accelerate switching or other
+  *	station functionality into hardware. 'pdev is the lowerdev
+  *	to use for the offload and 'dev' is the net device that will
+  *	back the offload. Returns a pointer to the private structure
+  *	the upper layer will maintain.
+  * void (*ndo_dfwd_del_station)(struct net_device *pdev, void *priv)
+  *	Called by upper layer device to delete the station created
+  *	by 'ndo_dfwd_add_station'. 'pdev' is the net device backing
+  *	the station and priv is the structure returned by the add
+  *	operation.
+  * netdev_tx_t (*ndo_dfwd_start_xmit)(struct sk_buff *skb,
+  *				      struct net_device *dev,
+  *				      void *priv);
+  *	Callback to use for xmit over the accelerated station. This
+  *	is used in place of ndo_start_xmit on accelerated net
+  *	devices.
+  * netdev_features_t (*ndo_features_check)(struct sk_buff *skb,
+  *					   struct net_device *dev
+  *					   netdev_features_t features);
++>>>>>>> 7c46a640de6f (net: Merge VXLAN and GENEVE push notifiers into a single notifier)
   *	Called by core transmit path to determine if device is capable of
   *	performing offload operations on a given packet. This is to give
   *	the device an opportunity to implement any restrictions that cannot
@@@ -1283,71 -1278,37 +1326,88 @@@ struct net_device_ops 
  	void			(*ndo_del_vxlan_port)(struct  net_device *dev,
  						      sa_family_t sa_family,
  						      __be16 port);
++<<<<<<< HEAD
++=======
+ 	void			(*ndo_add_geneve_port)(struct  net_device *dev,
+ 						       sa_family_t sa_family,
+ 						       __be16 port);
+ 	void			(*ndo_del_geneve_port)(struct  net_device *dev,
+ 						       sa_family_t sa_family,
+ 						       __be16 port);
+ 	void			(*ndo_udp_tunnel_add)(struct net_device *dev,
+ 						      struct udp_tunnel_info *ti);
+ 	void			(*ndo_udp_tunnel_del)(struct net_device *dev,
+ 						      struct udp_tunnel_info *ti);
+ 	void*			(*ndo_dfwd_add_station)(struct net_device *pdev,
+ 							struct net_device *dev);
+ 	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
+ 							void *priv);
++>>>>>>> 7c46a640de6f (net: Merge VXLAN and GENEVE push notifiers into a single notifier)
 +
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, int	(*ndo_get_iflink)(const struct net_device *dev))
 +	RH_KABI_USE_P(2, netdev_features_t
 +				(*ndo_features_check)(struct sk_buff *skb,
 +						      struct net_device *dev,
 +						      netdev_features_t features))
 +	RH_KABI_USE_P(3, int	(*ndo_set_vf_rate)(struct net_device *dev,
 +						   int vf, int min_tx_rate,
 +						   int max_tx_rate))
 +	RH_KABI_USE_P(4, int	(*ndo_get_vf_stats)(struct net_device *dev,
 +						    int vf,
 +						    struct ifla_vf_stats
 +						    *vf_stats))
 +	RH_KABI_USE_P(5, int    (*ndo_set_vf_rss_query_en)(struct net_device *dev,
 +							   int vf, bool setting))
  
 -	netdev_tx_t		(*ndo_dfwd_start_xmit) (struct sk_buff *skb,
 -							struct net_device *dev,
 -							void *priv);
 -	int			(*ndo_get_lock_subclass)(struct net_device *dev);
 -	int			(*ndo_set_tx_maxrate)(struct net_device *dev,
 -						      int queue_index,
 -						      u32 maxrate);
 -	int			(*ndo_get_iflink)(const struct net_device *dev);
 -	int			(*ndo_change_proto_down)(struct net_device *dev,
 -							 bool proto_down);
 -	int			(*ndo_fill_metadata_dst)(struct net_device *dev,
 -						       struct sk_buff *skb);
 -	void			(*ndo_set_rx_headroom)(struct net_device *dev,
 -						       int needed_headroom);
 +	RH_KABI_USE_P(6, int	(*ndo_fdb_add)(struct ndmsg *ndm,
 +					       struct nlattr *tb[],
 +					       struct net_device *dev,
 +					       const unsigned char *addr,
 +					       u16 vid,
 +					       u16 flags))
 +	RH_KABI_USE_P(7,int	(*ndo_setup_tc)(struct net_device *dev,
 +						u32 handle,
 +						__be16 protocol,
 +						struct tc_to_netdev *tc))
 +	RH_KABI_USE_P(8, int	(*ndo_fill_metadata_dst)(struct net_device *dev,
 +						       struct sk_buff *skb))
 +	RH_KABI_USE_P(9, void	(*ndo_add_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_USE_P(10, void	(*ndo_del_geneve_port)(struct  net_device *dev,
 +						       sa_family_t sa_family,
 +						       __be16 port))
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_USE_P(16, size_t ndo_size)
 +	/* RHEL: put all new non-performance critical ndo's into
 +	 * net_device_ops_extended. The reserved slots above can be used
 +	 * only for performance critical operations.
 +	 * Drivers may access the extended fields directly from
 +	 * net_device_ops, if they allocated the net_device_ops structure
 +	 * themselves (usually statically). The kernel core and drivers
 +	 * using others' net_device_ops must access the extended fields
 +	 * using the get_ndo_ext macro.
 +	 */
 +	RH_KABI_EXTEND(struct net_device_ops_extended extended)
  };
  
 +#define get_ndo_ext(ops, field)		({				\
 +	const struct net_device_ops *__ops = (ops);			\
 +	size_t __off = offsetof(struct net_device_ops, extended.field);	\
 +	__ops->ndo_size > __off ? __ops->extended.field : NULL;		\
 +	})
 +
  /**
   * enum net_device_priv_flags - &struct net_device priv_flags
   *
@@@ -2225,12 -2272,10 +2285,18 @@@ struct netdev_lag_lower_state_info 
  #define NETDEV_PRECHANGEMTU	0x0017 /* notify before mtu change happened */
  #define NETDEV_CHANGEINFODATA	0x0018
  #define NETDEV_BONDING_INFO	0x0019
++<<<<<<< HEAD
 +#define NETDEV_OFFLOAD_PUSH_VXLAN	0x001C
 +#define NETDEV_OFFLOAD_PUSH_GENEVE	0x001D
++=======
+ #define NETDEV_PRECHANGEUPPER	0x001A
+ #define NETDEV_CHANGELOWERSTATE	0x001B
+ #define NETDEV_UDP_TUNNEL_PUSH_INFO	0x001C
++>>>>>>> 7c46a640de6f (net: Merge VXLAN and GENEVE push notifiers into a single notifier)
  
 +/* (Un)registration functions for the notifiers that takes
 + * 'struct net_device *' as parameter
 + */
  int register_netdevice_notifier(struct notifier_block *nb);
  int unregister_netdevice_notifier(struct notifier_block *nb);
  
diff --git a/drivers/net/geneve.c b/drivers/net/geneve.c
index d6abacdaaf40..c7b326d9eec4 100644
--- a/drivers/net/geneve.c
+++ b/drivers/net/geneve.c
@@ -1519,7 +1519,7 @@ static int geneve_netdevice_event(struct notifier_block *unused,
 {
 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
 
-	if (event == NETDEV_OFFLOAD_PUSH_GENEVE)
+	if (event == NETDEV_UDP_TUNNEL_PUSH_INFO)
 		geneve_push_rx_ports(dev);
 
 	return NOTIFY_DONE;
diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index 7b2e26d64c03..ebf03bb8b4f8 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -3255,7 +3255,7 @@ static int vxlan_netdevice_event(struct notifier_block *unused,
 
 	if (event == NETDEV_UNREGISTER)
 		vxlan_handle_lowerdev_unregister(vn, dev);
-	else if (event == NETDEV_OFFLOAD_PUSH_VXLAN)
+	else if (event == NETDEV_UDP_TUNNEL_PUSH_INFO)
 		vxlan_push_rx_ports(dev);
 
 	return NOTIFY_DONE;
* Unmerged path include/linux/netdevice.h
diff --git a/include/net/geneve.h b/include/net/geneve.h
index a3163ec068ae..4983b219b95c 100644
--- a/include/net/geneve.h
+++ b/include/net/geneve.h
@@ -64,8 +64,7 @@ struct genevehdr {
 
 static inline void geneve_get_rx_port(struct net_device *netdev)
 {
-	ASSERT_RTNL();
-	call_netdevice_notifiers(NETDEV_OFFLOAD_PUSH_GENEVE, netdev);
+	udp_tunnel_get_rx_info(netdev);
 }
 
 #ifdef CONFIG_INET
diff --git a/include/net/udp_tunnel.h b/include/net/udp_tunnel.h
index e4e2d6200085..9ae88547cee7 100644
--- a/include/net/udp_tunnel.h
+++ b/include/net/udp_tunnel.h
@@ -117,6 +117,12 @@ void udp_tunnel_push_rx_port(struct net_device *dev, struct socket *sock,
 void udp_tunnel_notify_add_rx_port(struct socket *sock, unsigned short type);
 void udp_tunnel_notify_del_rx_port(struct socket *sock, unsigned short type);
 
+static inline void udp_tunnel_get_rx_info(struct net_device *dev)
+{
+	ASSERT_RTNL();
+	call_netdevice_notifiers(NETDEV_UDP_TUNNEL_PUSH_INFO, dev);
+}
+
 /* Transmit the skb using UDP encapsulation. */
 void udp_tunnel_xmit_skb(struct rtable *rt, struct sock *sk, struct sk_buff *skb,
 			 __be32 src, __be32 dst, __u8 tos, __u8 ttl,
diff --git a/include/net/vxlan.h b/include/net/vxlan.h
index d243713534f5..6a1e289547a4 100644
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@ -8,6 +8,7 @@
 #include <linux/netdevice.h>
 #include <linux/udp.h>
 #include <net/dst_metadata.h>
+#include <net/udp_tunnel.h>
 
 /* VXLAN protocol (RFC 7348) header:
  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
@@ -394,8 +395,7 @@ static inline __be32 vxlan_compute_rco(unsigned int start, unsigned int offset)
 
 static inline void vxlan_get_rx_port(struct net_device *netdev)
 {
-	ASSERT_RTNL();
-	call_netdevice_notifiers(NETDEV_OFFLOAD_PUSH_VXLAN, netdev);
+	udp_tunnel_get_rx_info(netdev);
 }
 
 static inline unsigned short vxlan_get_sk_family(struct vxlan_sock *vs)
diff --git a/net/ipv4/udp_tunnel.c b/net/ipv4/udp_tunnel.c
index 087388dbb91a..197e01d38436 100644
--- a/net/ipv4/udp_tunnel.c
+++ b/net/ipv4/udp_tunnel.c
@@ -81,6 +81,11 @@ EXPORT_SYMBOL_GPL(setup_udp_tunnel_sock);
 static void __udp_tunnel_push_rx_port(struct net_device *dev,
 				      struct udp_tunnel_info *ti)
 {
+	if (dev->netdev_ops->ndo_udp_tunnel_add) {
+		dev->netdev_ops->ndo_udp_tunnel_add(dev, ti);
+		return;
+	}
+
 	switch (ti->type) {
 	case UDP_TUNNEL_TYPE_VXLAN:
 		if (!dev->netdev_ops->ndo_add_vxlan_port)
@@ -139,6 +144,11 @@ EXPORT_SYMBOL_GPL(udp_tunnel_notify_add_rx_port);
 static void __udp_tunnel_pull_rx_port(struct net_device *dev,
 				      struct udp_tunnel_info *ti)
 {
+	if (dev->netdev_ops->ndo_udp_tunnel_del) {
+		dev->netdev_ops->ndo_udp_tunnel_del(dev, ti);
+		return;
+	}
+
 	switch (ti->type) {
 	case UDP_TUNNEL_TYPE_VXLAN:
 		if (!dev->netdev_ops->ndo_del_vxlan_port)
