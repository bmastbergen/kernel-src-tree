blk-mq: Add a kick_requeue_list argument to blk_mq_requeue_request()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 2b053aca76b48e681be57b34ca3a8c2c10b275c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2b053aca.failed

Most blk_mq_requeue_request() and blk_mq_add_to_requeue_list() calls
are followed by kicking the requeue list. Hence add an argument to
these two functions that allows to kick the requeue list. This was
proposed by Christoph Hellwig.

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Cc: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 2b053aca76b48e681be57b34ca3a8c2c10b275c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/xen-blkfront.c
#	include/linux/blk-mq.h
diff --cc drivers/block/xen-blkfront.c
index f6a97f7f4ca5,c000fdf048b2..000000000000
--- a/drivers/block/xen-blkfront.c
+++ b/drivers/block/xen-blkfront.c
@@@ -1545,11 -2043,12 +1545,15 @@@ static int blkif_recover(struct blkfron
  		/* Requeue pending requests (flush or discard) */
  		list_del_init(&req->queuelist);
  		BUG_ON(req->nr_phys_segments > segs);
++<<<<<<< HEAD
 +		blk_requeue_request(info->rq, req);
++=======
+ 		blk_mq_requeue_request(req, false);
++>>>>>>> 2b053aca76b4 (blk-mq: Add a kick_requeue_list argument to blk_mq_requeue_request())
  	}
 -	blk_mq_start_stopped_hw_queues(info->rq, true);
 -	blk_mq_kick_requeue_list(info->rq);
 +	spin_unlock_irq(&info->io_lock);
  
 -	while ((bio = bio_list_pop(&info->bio_list)) != NULL) {
 +	while ((bio = bio_list_pop(&bio_list)) != NULL) {
  		/* Traverse the list of pending bios and re-queue them */
  		if (bio_segments(bio) > segs) {
  			/*
diff --cc include/linux/blk-mq.h
index 0e7b0244ac77,35a0af5ede6d..000000000000
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@@ -251,10 -218,11 +251,16 @@@ void blk_mq_start_request(struct reques
  void blk_mq_end_request(struct request *rq, int error);
  void __blk_mq_end_request(struct request *rq, int error);
  
++<<<<<<< HEAD
 +void blk_mq_requeue_request(struct request *rq);
 +void blk_mq_add_to_requeue_list(struct request *rq, bool at_head);
 +void blk_mq_cancel_requeue_work(struct request_queue *q);
++=======
+ void blk_mq_requeue_request(struct request *rq, bool kick_requeue_list);
+ void blk_mq_add_to_requeue_list(struct request *rq, bool at_head,
+ 				bool kick_requeue_list);
++>>>>>>> 2b053aca76b4 (blk-mq: Add a kick_requeue_list argument to blk_mq_requeue_request())
  void blk_mq_kick_requeue_list(struct request_queue *q);
 -void blk_mq_delay_kick_requeue_list(struct request_queue *q, unsigned long msecs);
  void blk_mq_abort_requeue_list(struct request_queue *q);
  void blk_mq_complete_request(struct request *rq, int error);
  
diff --git a/block/blk-flush.c b/block/blk-flush.c
index 8eb6a08792c8..c1b0c5d26d78 100644
--- a/block/blk-flush.c
+++ b/block/blk-flush.c
@@ -133,10 +133,7 @@ static void blk_flush_restore_request(struct request *rq)
 static bool blk_flush_queue_rq(struct request *rq, bool add_front)
 {
 	if (rq->q->mq_ops) {
-		struct request_queue *q = rq->q;
-
-		blk_mq_add_to_requeue_list(rq, add_front);
-		blk_mq_kick_requeue_list(q);
+		blk_mq_add_to_requeue_list(rq, add_front, true);
 		return false;
 	} else {
 		if (add_front)
diff --git a/block/blk-mq.c b/block/blk-mq.c
index 1fb8b36f35c6..d4a1e4d2a2ed 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -446,12 +446,12 @@ static void __blk_mq_requeue_request(struct request *rq)
 	}
 }
 
-void blk_mq_requeue_request(struct request *rq)
+void blk_mq_requeue_request(struct request *rq, bool kick_requeue_list)
 {
 	__blk_mq_requeue_request(rq);
 
 	BUG_ON(blk_queued_rq(rq));
-	blk_mq_add_to_requeue_list(rq, true);
+	blk_mq_add_to_requeue_list(rq, true, kick_requeue_list);
 }
 EXPORT_SYMBOL(blk_mq_requeue_request);
 
@@ -489,7 +489,8 @@ static void blk_mq_requeue_work(struct work_struct *work)
 	blk_mq_start_hw_queues(q);
 }
 
-void blk_mq_add_to_requeue_list(struct request *rq, bool at_head)
+void blk_mq_add_to_requeue_list(struct request *rq, bool at_head,
+				bool kick_requeue_list)
 {
 	struct request_queue *q = rq->q;
 	unsigned long flags;
@@ -508,6 +509,9 @@ void blk_mq_add_to_requeue_list(struct request *rq, bool at_head)
 		list_add_tail(&rq->queuelist, &q->requeue_list);
 	}
 	spin_unlock_irqrestore(&q->requeue_lock, flags);
+
+	if (kick_requeue_list)
+		blk_mq_kick_requeue_list(q);
 }
 EXPORT_SYMBOL(blk_mq_add_to_requeue_list);
 
* Unmerged path drivers/block/xen-blkfront.c
diff --git a/drivers/md/dm-rq.c b/drivers/md/dm-rq.c
index 63a5735de609..372a515e25e5 100644
--- a/drivers/md/dm-rq.c
+++ b/drivers/md/dm-rq.c
@@ -346,7 +346,7 @@ EXPORT_SYMBOL(dm_mq_kick_requeue_list);
 
 static void dm_mq_delay_requeue_request(struct request *rq, unsigned long msecs)
 {
-	blk_mq_requeue_request(rq);
+	blk_mq_requeue_request(rq, false);
 	__dm_mq_kick_requeue_list(rq->q, msecs);
 }
 
diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index b10275d9cb61..db415cbccfc5 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -102,7 +102,7 @@ void nvme_requeue_req(struct request *req)
 {
 	unsigned long flags;
 
-	blk_mq_requeue_request(req);
+	blk_mq_requeue_request(req, false);
 	spin_lock_irqsave(req->q->queue_lock, flags);
 	if (!blk_queue_stopped(req->q))
 		blk_mq_kick_requeue_list(req->q);
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index f0252ebf3ca9..0cca3a92fc0f 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -121,10 +121,8 @@ scsi_set_blocked(struct scsi_cmnd *cmd, int reason)
 static void scsi_mq_requeue_cmd(struct scsi_cmnd *cmd)
 {
 	struct scsi_device *sdev = cmd->device;
-	struct request_queue *q = cmd->request->q;
 
-	blk_mq_requeue_request(cmd->request);
-	blk_mq_kick_requeue_list(q);
+	blk_mq_requeue_request(cmd->request, true);
 	put_device(&sdev->sdev_gendev);
 }
 
* Unmerged path include/linux/blk-mq.h
