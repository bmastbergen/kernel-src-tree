mnt: Fix a memory stomp in umount

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit c297abfdf15b4480704d6b566ca5ca9438b12456
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c297abfd.failed

While reviewing the code of umount_tree I realized that when we append
to a preexisting unmounted list we do not change pprev of the former
first item in the list.

Which means later in namespace_unlock hlist_del_init(&mnt->mnt_hash) on
the former first item of the list will stomp unmounted.first leaving
it set to some random mount point which we are likely to free soon.

This isn't likely to hit, but if it does I don't know how anyone could
track it down.

[ This happened because we don't have all the same operations for
  hlist's as we do for normal doubly-linked lists. In particular,
  list_splice() is easy on our standard doubly-linked lists, while
  hlist_splice() doesn't exist and needs both start/end entries of the
  hlist.  And commit 38129a13e6e7 incorrectly open-coded that missing
  hlist_splice().

  We should think about making these kinds of "mindless" conversions
  easier to get right by adding the missing hlist helpers   - Linus ]

Fixes: 38129a13e6e71f666e0468e99fdd932a687b4d7e switch mnt_hash to hlist
	Cc: stable@vger.kernel.org
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c297abfdf15b4480704d6b566ca5ca9438b12456)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index 07e51358b239,cd1e9681a0cf..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -1239,8 -1366,15 +1239,19 @@@ void umount_tree(struct mount *mnt, in
  			p->mnt_mp = NULL;
  		}
  		change_mnt_propagation(p, MS_PRIVATE);
++<<<<<<< HEAD
++=======
+ 		last = p;
+ 	}
+ 	if (last) {
+ 		last->mnt_hash.next = unmounted.first;
+ 		if (unmounted.first)
+ 			unmounted.first->pprev = &last->mnt_hash.next;
+ 		unmounted.first = tmp_list.first;
+ 		unmounted.first->pprev = &unmounted.first;
++>>>>>>> c297abfdf15b (mnt: Fix a memory stomp in umount)
  	}
 +	list_splice(&tmp_list, &unmounted);
  }
  
  static void shrink_submounts(struct mount *mnt);
* Unmerged path fs/namespace.c
