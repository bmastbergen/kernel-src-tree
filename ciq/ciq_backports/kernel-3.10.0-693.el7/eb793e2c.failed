nvme.h: add NVMe over Fabrics definitions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Christoph Hellwig <hch@lst.de>
commit eb793e2c9286cca415423edff4942e4ba28e3cd4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/eb793e2c.failed

The NVMe over Fabrics specification defines a protocol interface and
related extensions to NVMe that enable operation over network protocols.
The NVMe over Fabrics specification has an NVMe Transport binding for
each NVMe Transport.

This patch adds the fabrics related definitions:
- fabric specific command set and error codes
- transport addressing and binding definitions
- fabrics sgl extensions
- controller identification fabrics enhancements
- discovery log page definition

	Signed-off-by: Armen Baloyan <armenx.baloyan@intel.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Jay Freyensee <james.p.freyensee@intel.com>
	Signed-off-by: Ming Lin <ming.l@ssi.samsung.com>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit eb793e2c9286cca415423edff4942e4ba28e3cd4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/nvme.h
diff --cc include/linux/nvme.h
index 2b82f05fe4ec,75250303bcb3..000000000000
--- a/include/linux/nvme.h
+++ b/include/linux/nvme.h
@@@ -590,7 -844,22 +844,25 @@@ struct nvme_command 
  	};
  };
  
++<<<<<<< HEAD
++=======
+ static inline bool nvme_is_write(struct nvme_command *cmd)
+ {
+ 	/*
+ 	 * What a mess...
+ 	 *
+ 	 * Why can't we simply have a Fabrics In and Fabrics out command?
+ 	 */
+ 	if (unlikely(cmd->common.opcode == nvme_fabrics_command))
+ 		return cmd->fabrics.opcode & 1;
+ 	return cmd->common.opcode & 1;
+ }
+ 
++>>>>>>> eb793e2c9286 (nvme.h: add NVMe over Fabrics definitions)
  enum {
+ 	/*
+ 	 * Generic Command Status:
+ 	 */
  	NVME_SC_SUCCESS			= 0x0,
  	NVME_SC_INVALID_OPCODE		= 0x1,
  	NVME_SC_INVALID_FIELD		= 0x2,
diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index 63f6b5f40b5c..fdfca309ca2c 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -323,7 +323,7 @@ int nvme_get_features(struct nvme_ctrl *dev, unsigned fid, unsigned nsid,
 	memset(&c, 0, sizeof(c));
 	c.features.opcode = nvme_admin_get_features;
 	c.features.nsid = cpu_to_le32(nsid);
-	c.features.prp1 = cpu_to_le64(dma_addr);
+	c.features.dptr.prp1 = cpu_to_le64(dma_addr);
 	c.features.fid = cpu_to_le32(fid);
 
 	return __nvme_submit_sync_cmd(dev->admin_q, &c, NULL, 0, result, 0);
@@ -336,7 +336,7 @@ int nvme_set_features(struct nvme_ctrl *dev, unsigned fid, unsigned dword11,
 
 	memset(&c, 0, sizeof(c));
 	c.features.opcode = nvme_admin_set_features;
-	c.features.prp1 = cpu_to_le64(dma_addr);
+	c.features.dptr.prp1 = cpu_to_le64(dma_addr);
 	c.features.fid = cpu_to_le32(fid);
 	c.features.dword11 = cpu_to_le32(dword11);
 
diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c
index 6cf19a97b3a4..73e88c1aba0f 100644
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@ -496,8 +496,8 @@ static int nvme_map_data(struct nvme_dev *dev, struct request *req,
 			goto out_unmap;
 	}
 
-	cmnd->rw.prp1 = cpu_to_le64(sg_dma_address(iod->sg));
-	cmnd->rw.prp2 = cpu_to_le64(iod->first_dma);
+	cmnd->rw.dptr.prp1 = cpu_to_le64(sg_dma_address(iod->sg));
+	cmnd->rw.dptr.prp2 = cpu_to_le64(iod->first_dma);
 	if (blk_integrity_rq(req))
 		cmnd->rw.metadata = cpu_to_le64(sg_dma_address(iod->meta_sg));
 	return BLK_MQ_RQ_QUEUE_OK;
* Unmerged path include/linux/nvme.h
