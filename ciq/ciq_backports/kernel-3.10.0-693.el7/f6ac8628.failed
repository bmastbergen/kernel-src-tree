amd-xgbe: Add receive side scaling ethtool support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit f6ac862845bbe9daac9a02c7690efa01bfb62fa5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f6ac8628.failed

This patch adds support for ethtool receive side scaling (RSS) commands.
Support is added to get/set the RSS hash key and the RSS lookup table.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f6ac862845bbe9daac9a02c7690efa01bfb62fa5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/xgbe-dev.c
#	drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
#	drivers/net/ethernet/amd/xgbe/xgbe.h
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-dev.c
index 2da3691ffcd6,7daa2cd9af5f..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
@@@ -334,6 -335,161 +334,164 @@@ static void xgbe_config_tso_mode(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void xgbe_config_sph_mode(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel;
+ 	unsigned int i;
+ 
+ 	channel = pdata->channel;
+ 	for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 		if (!channel->rx_ring)
+ 			break;
+ 
+ 		XGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_CR, SPH, 1);
+ 	}
+ 
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RCR, HDSMS, XGBE_SPH_HDSMS_SIZE);
+ }
+ 
+ static int xgbe_write_rss_reg(struct xgbe_prv_data *pdata, unsigned int type,
+ 			      unsigned int index, unsigned int val)
+ {
+ 	unsigned int wait;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&pdata->rss_mutex);
+ 
+ 	if (XGMAC_IOREAD_BITS(pdata, MAC_RSSAR, OB)) {
+ 		ret = -EBUSY;
+ 		goto unlock;
+ 	}
+ 
+ 	XGMAC_IOWRITE(pdata, MAC_RSSDR, val);
+ 
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, RSSIA, index);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, ADDRT, type);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, CT, 0);
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, OB, 1);
+ 
+ 	wait = 1000;
+ 	while (wait--) {
+ 		if (!XGMAC_IOREAD_BITS(pdata, MAC_RSSAR, OB))
+ 			goto unlock;
+ 
+ 		usleep_range(1000, 1500);
+ 	}
+ 
+ 	ret = -EBUSY;
+ 
+ unlock:
+ 	mutex_unlock(&pdata->rss_mutex);
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_write_rss_hash_key(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int key_regs = sizeof(pdata->rss_key) / sizeof(u32);
+ 	unsigned int *key = (unsigned int *)&pdata->rss_key;
+ 	int ret;
+ 
+ 	while (key_regs--) {
+ 		ret = xgbe_write_rss_reg(pdata, XGBE_RSS_HASH_KEY_TYPE,
+ 					 key_regs, *key++);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_write_rss_lookup_table(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int i;
+ 	int ret;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++) {
+ 		ret = xgbe_write_rss_reg(pdata,
+ 					 XGBE_RSS_LOOKUP_TABLE_TYPE, i,
+ 					 pdata->rss_table[i]);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_rss_hash_key(struct xgbe_prv_data *pdata, const u8 *key)
+ {
+ 	memcpy(pdata->rss_key, key, sizeof(pdata->rss_key));
+ 
+ 	return xgbe_write_rss_hash_key(pdata);
+ }
+ 
+ static int xgbe_set_rss_lookup_table(struct xgbe_prv_data *pdata,
+ 				     const u32 *table)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++)
+ 		XGMAC_SET_BITS(pdata->rss_table[i], MAC_RSSDR, DMCH, table[i]);
+ 
+ 	return xgbe_write_rss_lookup_table(pdata);
+ }
+ 
+ static int xgbe_enable_rss(struct xgbe_prv_data *pdata)
+ {
+ 	int ret;
+ 
+ 	if (!pdata->hw_feat.rss)
+ 		return -EOPNOTSUPP;
+ 
+ 	/* Program the hash key */
+ 	ret = xgbe_write_rss_hash_key(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Program the lookup table */
+ 	ret = xgbe_write_rss_lookup_table(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Set the RSS options */
+ 	XGMAC_IOWRITE(pdata, MAC_RSSCR, pdata->rss_options);
+ 
+ 	/* Enable RSS */
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSCR, RSSE, 1);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_disable_rss(struct xgbe_prv_data *pdata)
+ {
+ 	if (!pdata->hw_feat.rss)
+ 		return -EOPNOTSUPP;
+ 
+ 	XGMAC_IOWRITE_BITS(pdata, MAC_RSSCR, RSSE, 0);
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_config_rss(struct xgbe_prv_data *pdata)
+ {
+ 	int ret;
+ 
+ 	if (!pdata->hw_feat.rss)
+ 		return;
+ 
+ 	if (pdata->netdev->features & NETIF_F_RXHASH)
+ 		ret = xgbe_enable_rss(pdata);
+ 	else
+ 		ret = xgbe_disable_rss(pdata);
+ 
+ 	if (ret)
+ 		netdev_err(pdata->netdev,
+ 			   "error configuring RSS, RSS disabled\n");
+ }
+ 
++>>>>>>> f6ac862845bb (amd-xgbe: Add receive side scaling ethtool support)
  static int xgbe_disable_tx_flow_control(struct xgbe_prv_data *pdata)
  {
  	unsigned int max_q_count, q_count;
@@@ -2209,5 -2763,22 +2367,25 @@@ void xgbe_init_function_ptrs_dev(struc
  	hw_if->rx_mmc_int = xgbe_rx_mmc_int;
  	hw_if->read_mmc_stats = xgbe_read_mmc_stats;
  
++<<<<<<< HEAD
++=======
+ 	/* For PTP config */
+ 	hw_if->config_tstamp = xgbe_config_tstamp;
+ 	hw_if->update_tstamp_addend = xgbe_update_tstamp_addend;
+ 	hw_if->set_tstamp_time = xgbe_set_tstamp_time;
+ 	hw_if->get_tstamp_time = xgbe_get_tstamp_time;
+ 	hw_if->get_tx_tstamp = xgbe_get_tx_tstamp;
+ 
+ 	/* For Data Center Bridging config */
+ 	hw_if->config_dcb_tc = xgbe_config_dcb_tc;
+ 	hw_if->config_dcb_pfc = xgbe_config_dcb_pfc;
+ 
+ 	/* For Receive Side Scaling */
+ 	hw_if->enable_rss = xgbe_enable_rss;
+ 	hw_if->disable_rss = xgbe_disable_rss;
+ 	hw_if->set_rss_hash_key = xgbe_set_rss_hash_key;
+ 	hw_if->set_rss_lookup_table = xgbe_set_rss_lookup_table;
+ 
++>>>>>>> f6ac862845bb (amd-xgbe: Add receive side scaling ethtool support)
  	DBGPR("<--xgbe_init_function_ptrs\n");
  }
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
index 477038ad98fd,95d44538357f..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
@@@ -479,6 -481,108 +479,111 @@@ static int xgbe_set_coalesce(struct net
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int xgbe_get_rxnfc(struct net_device *netdev,
+ 			  struct ethtool_rxnfc *rxnfc, u32 *rule_locs)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	switch (rxnfc->cmd) {
+ 	case ETHTOOL_GRXRINGS:
+ 		rxnfc->data = pdata->rx_ring_count;
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u32 xgbe_get_rxfh_key_size(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	return sizeof(pdata->rss_key);
+ }
+ 
+ static u32 xgbe_get_rxfh_indir_size(struct net_device *netdev)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	return ARRAY_SIZE(pdata->rss_table);
+ }
+ 
+ static int xgbe_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	unsigned int i;
+ 
+ 	if (indir) {
+ 		for (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++)
+ 			indir[i] = XGMAC_GET_BITS(pdata->rss_table[i],
+ 						  MAC_RSSDR, DMCH);
+ 	}
+ 
+ 	if (key)
+ 		memcpy(key, pdata->rss_key, sizeof(pdata->rss_key));
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_set_rxfh(struct net_device *netdev, const u32 *indir,
+ 			 const u8 *key)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 	struct xgbe_hw_if *hw_if = &pdata->hw_if;
+ 	unsigned int ret;
+ 
+ 	if (indir) {
+ 		ret = hw_if->set_rss_lookup_table(pdata, indir);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	if (key) {
+ 		ret = hw_if->set_rss_hash_key(pdata, key);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_get_ts_info(struct net_device *netdev,
+ 			    struct ethtool_ts_info *ts_info)
+ {
+ 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
+ 
+ 	ts_info->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |
+ 				   SOF_TIMESTAMPING_RX_SOFTWARE |
+ 				   SOF_TIMESTAMPING_SOFTWARE |
+ 				   SOF_TIMESTAMPING_TX_HARDWARE |
+ 				   SOF_TIMESTAMPING_RX_HARDWARE |
+ 				   SOF_TIMESTAMPING_RAW_HARDWARE;
+ 
+ 	if (pdata->ptp_clock)
+ 		ts_info->phc_index = ptp_clock_index(pdata->ptp_clock);
+ 	else
+ 		ts_info->phc_index = -1;
+ 
+ 	ts_info->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);
+ 	ts_info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |
+ 			      (1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |
+ 			      (1 << HWTSTAMP_FILTER_ALL);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> f6ac862845bb (amd-xgbe: Add receive side scaling ethtool support)
  static const struct ethtool_ops xgbe_ethtool_ops = {
  	.get_settings = xgbe_get_settings,
  	.set_settings = xgbe_set_settings,
@@@ -491,6 -595,12 +596,15 @@@
  	.get_strings = xgbe_get_strings,
  	.get_ethtool_stats = xgbe_get_ethtool_stats,
  	.get_sset_count = xgbe_get_sset_count,
++<<<<<<< HEAD
++=======
+ 	.get_rxnfc = xgbe_get_rxnfc,
+ 	.get_rxfh_key_size = xgbe_get_rxfh_key_size,
+ 	.get_rxfh_indir_size = xgbe_get_rxfh_indir_size,
+ 	.get_rxfh = xgbe_get_rxfh,
+ 	.set_rxfh = xgbe_set_rxfh,
+ 	.get_ts_info = xgbe_get_ts_info,
++>>>>>>> f6ac862845bb (amd-xgbe: Add receive side scaling ethtool support)
  };
  
  struct ethtool_ops *xgbe_get_ethtool_ops(void)
diff --cc drivers/net/ethernet/amd/xgbe/xgbe.h
index 30435fbd04b3,aa8da9f4f1f9..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@@ -461,6 -541,24 +461,27 @@@ struct xgbe_hw_if 
  	void (*rx_mmc_int)(struct xgbe_prv_data *);
  	void (*tx_mmc_int)(struct xgbe_prv_data *);
  	void (*read_mmc_stats)(struct xgbe_prv_data *);
++<<<<<<< HEAD
++=======
+ 
+ 	/* For Timestamp config */
+ 	int (*config_tstamp)(struct xgbe_prv_data *, unsigned int);
+ 	void (*update_tstamp_addend)(struct xgbe_prv_data *, unsigned int);
+ 	void (*set_tstamp_time)(struct xgbe_prv_data *, unsigned int sec,
+ 				unsigned int nsec);
+ 	u64 (*get_tstamp_time)(struct xgbe_prv_data *);
+ 	u64 (*get_tx_tstamp)(struct xgbe_prv_data *);
+ 
+ 	/* For Data Center Bridging config */
+ 	void (*config_dcb_tc)(struct xgbe_prv_data *);
+ 	void (*config_dcb_pfc)(struct xgbe_prv_data *);
+ 
+ 	/* For Receive Side Scaling */
+ 	int (*enable_rss)(struct xgbe_prv_data *);
+ 	int (*disable_rss)(struct xgbe_prv_data *);
+ 	int (*set_rss_hash_key)(struct xgbe_prv_data *, const u8 *);
+ 	int (*set_rss_lookup_table)(struct xgbe_prv_data *, const u32 *);
++>>>>>>> f6ac862845bb (amd-xgbe: Add receive side scaling ethtool support)
  };
  
  struct xgbe_desc_if {
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-dev.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-ethtool.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe.h
