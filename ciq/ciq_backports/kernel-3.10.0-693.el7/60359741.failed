autofs: use path_has_submounts() to fix unreliable have_submount() checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ian Kent <ikent@redhat.com>
commit 60359741473438f66fef7297d1fa2435640dbe79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/60359741.failed

If an automount mount is clone(2)ed into a file system that is propagation
private, when it later expires in the originating namespace, subsequent
calls to autofs ->d_automount() for that dentry in the original namespace
will return ELOOP until the mount is umounted in the cloned namespace.

Now that a struct path is available where needed use path_has_submounts()
instead of have_submounts() so we don't get false positives when checking
if a dentry is a mount point or contains mounts in the current namespace.

Link: http://lkml.kernel.org/r/20161011053423.27645.91233.stgit@pluto.themaw.net
	Signed-off-by: Ian Kent <raven@themaw.net>
	Cc: Al Viro <viro@ZenIV.linux.org.uk>
	Cc: Eric W. Biederman <ebiederm@xmission.com>
	Cc: Omar Sandoval <osandov@osandov.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 60359741473438f66fef7297d1fa2435640dbe79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/autofs4/waitq.c
diff --cc fs/autofs4/waitq.c
index 71b3baf9aaca,1278335ce366..000000000000
--- a/fs/autofs4/waitq.c
+++ b/fs/autofs4/waitq.c
@@@ -247,9 -249,10 +247,15 @@@ autofs4_find_wait(struct autofs_sb_inf
   */
  static int validate_request(struct autofs_wait_queue **wait,
  			    struct autofs_sb_info *sbi,
++<<<<<<< HEAD
 +			    struct qstr *qstr,
 +			    struct dentry*dentry, enum autofs_notify notify)
++=======
+ 			    const struct qstr *qstr,
+ 			    const struct path *path, enum autofs_notify notify)
++>>>>>>> 603597414734 (autofs: use path_has_submounts() to fix unreliable have_submount() checks)
  {
+ 	struct dentry *dentry = path->dentry;
  	struct autofs_wait_queue *wq;
  	struct autofs_info *ino;
  
diff --git a/fs/autofs4/dev-ioctl.c b/fs/autofs4/dev-ioctl.c
index 057998d862e0..c9a6f171b003 100644
--- a/fs/autofs4/dev-ioctl.c
+++ b/fs/autofs4/dev-ioctl.c
@@ -570,7 +570,7 @@ static int autofs_dev_ioctl_ismountpoint(struct file *fp,
 
 		devid = new_encode_dev(dev);
 
-		err = have_submounts(path.dentry);
+		err = path_has_submounts(&path);
 
 		if (follow_down_one(&path))
 			magic = path.dentry->d_sb->s_magic;
diff --git a/fs/autofs4/root.c b/fs/autofs4/root.c
index b538a83d1c8b..acafb4b13541 100644
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@ -385,16 +385,16 @@ static struct vfsmount *autofs4_d_automount(struct path *path)
 		/*
 		 * It's possible that user space hasn't removed directories
 		 * after umounting a rootless multi-mount, although it
-		 * should. For v5 have_submounts() is sufficient to handle
-		 * this because the leaves of the directory tree under the
-		 * mount never trigger mounts themselves (they have an autofs
-		 * trigger mount mounted on them). But v4 pseudo direct mounts
-		 * do need the leaves to trigger mounts. In this case we
-		 * have no choice but to use the list_empty() check and
+		 * should. For v5 path_has_submounts() is sufficient to
+		 * handle this because the leaves of the directory tree under
+		 * the mount never trigger mounts themselves (they have an
+		 * autofs trigger mount mounted on them). But v4 pseudo direct
+		 * mounts do need the leaves to trigger mounts. In this case
+		 * we have no choice but to use the list_empty() check and
 		 * require user space behave.
 		 */
 		if (sbi->version > 4) {
-			if (have_submounts(dentry)) {
+			if (path_has_submounts(path)) {
 				spin_unlock(&sbi->fs_lock);
 				goto done;
 			}
* Unmerged path fs/autofs4/waitq.c
