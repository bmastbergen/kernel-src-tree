vfs: move permission checking into notify_change() for utimes(NULL)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit f2b20f6ee842313a0d681dbbf7f87b70291a6a3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f2b20f6e.failed

This fixes a bug where the permission was not properly checked in
overlayfs.  The testcase is ltp/utimensat01.

It is also cleaner and safer to do the permission checking in the vfs
helper instead of the caller.

This patch introduces an additional ia_valid flag ATTR_TOUCH (since
touch(1) is the most obvious user of utimes(NULL)) that is passed into
notify_change whenever the conditions for this special permission checking
mode are met.

	Reported-by: Aihua Zhang <zhangaihua1@huawei.com>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
	Tested-by: Aihua Zhang <zhangaihua1@huawei.com>
	Cc: <stable@vger.kernel.org> # v3.18+
(cherry picked from commit f2b20f6ee842313a0d681dbbf7f87b70291a6a3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/attr.c
#	fs/utimes.c
diff --cc fs/attr.c
index 7262f3beb8b5,3c42cab06b5d..000000000000
--- a/fs/attr.c
+++ b/fs/attr.c
@@@ -202,9 -202,19 +202,25 @@@ int notify_change(struct dentry * dentr
  			return -EPERM;
  	}
  
++<<<<<<< HEAD
 +	if ((ia_valid & ATTR_SIZE) && IS_I_VERSION(inode)) {
 +		if (attr->ia_size != inode->i_size)
 +			inode_inc_iversion(inode);
++=======
+ 	/*
+ 	 * If utimes(2) and friends are called with times == NULL (or both
+ 	 * times are UTIME_NOW), then we need to check for write permission
+ 	 */
+ 	if (ia_valid & ATTR_TOUCH) {
+ 		if (IS_IMMUTABLE(inode))
+ 			return -EPERM;
+ 
+ 		if (!inode_owner_or_capable(inode)) {
+ 			error = inode_permission(inode, MAY_WRITE);
+ 			if (error)
+ 				return error;
+ 		}
++>>>>>>> f2b20f6ee842 (vfs: move permission checking into notify_change() for utimes(NULL))
  	}
  
  	if ((ia_valid & ATTR_MODE)) {
diff --cc fs/utimes.c
index aa138d64560a,ba54b9e648c9..000000000000
--- a/fs/utimes.c
+++ b/fs/utimes.c
@@@ -87,25 -87,12 +87,29 @@@ static int utimes_common(struct path *p
  		 */
  		newattrs.ia_valid |= ATTR_TIMES_SET;
  	} else {
++<<<<<<< HEAD
 +		/*
 +		 * If times is NULL (or both times are UTIME_NOW),
 +		 * then we need to check permissions, because
 +		 * inode_change_ok() won't do it.
 +		 */
 +		error = -EACCES;
 +                if (IS_IMMUTABLE(inode))
 +			goto mnt_drop_write_and_out;
 +
 +		if (!inode_owner_or_capable(inode)) {
 +			error = inode_permission(inode, MAY_WRITE);
 +			if (error)
 +				goto mnt_drop_write_and_out;
 +		}
++=======
+ 		newattrs.ia_valid |= ATTR_TOUCH;
++>>>>>>> f2b20f6ee842 (vfs: move permission checking into notify_change() for utimes(NULL))
  	}
  retry_deleg:
 -	inode_lock(inode);
 +	mutex_lock(&inode->i_mutex);
  	error = notify_change(path->dentry, &newattrs, &delegated_inode);
 -	inode_unlock(inode);
 +	mutex_unlock(&inode->i_mutex);
  	if (delegated_inode) {
  		error = break_deleg_wait(&delegated_inode);
  		if (!error)
* Unmerged path fs/attr.c
* Unmerged path fs/utimes.c
diff --git a/include/linux/fs.h b/include/linux/fs.h
index e5f546c9e338..0e9ab7783bcc 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -218,6 +218,7 @@ typedef void (dax_iodone_t)(struct buffer_head *bh_map, int uptodate);
 #define ATTR_KILL_PRIV	(1 << 14)
 #define ATTR_OPEN	(1 << 15) /* Truncating from open(O_TRUNC) */
 #define ATTR_TIMES_SET	(1 << 16)
+#define ATTR_TOUCH	(1 << 17)
 
 /*
  * Whiteout is represented by a char device.  The following constants define the
