md/bitmap: change all printk() to pr_*()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [md] bitmap: change all printk() to pr_*() (Jes Sorensen) [1380016]
Rebuild_FUZZ: 96.10%
commit-author NeilBrown <neilb@suse.com>
commit ec0cc226854a79c0cf2969a7a86eddea5f8e8b09
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ec0cc226.failed

Follow err/warn distinction introduced in md.c
Join multi-part strings into single string.

	Signed-off-by: NeilBrown <neilb@suse.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit ec0cc226854a79c0cf2969a7a86eddea5f8e8b09)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/bitmap.c
diff --cc drivers/md/bitmap.c
index 5d638c495205,23563f545651..000000000000
--- a/drivers/md/bitmap.c
+++ b/drivers/md/bitmap.c
@@@ -552,6 -572,22 +552,25 @@@ static int bitmap_read_sb(struct bitma
  		return -ENOMEM;
  	bitmap->storage.sb_page = sb_page;
  
++<<<<<<< HEAD
++=======
+ re_read:
+ 	/* If cluster_slot is set, the cluster is setup */
+ 	if (bitmap->cluster_slot >= 0) {
+ 		sector_t bm_blocks = bitmap->mddev->resync_max_sectors;
+ 
+ 		sector_div(bm_blocks,
+ 			   bitmap->mddev->bitmap_info.chunksize >> 9);
+ 		/* bits to bytes */
+ 		bm_blocks = ((bm_blocks+7) >> 3) + sizeof(bitmap_super_t);
+ 		/* to 4k blocks */
+ 		bm_blocks = DIV_ROUND_UP_SECTOR_T(bm_blocks, 4096);
+ 		offset = bitmap->mddev->bitmap_info.offset + (bitmap->cluster_slot * (bm_blocks << 3));
+ 		pr_debug("%s:%d bm slot: %d offset: %llu\n", __func__, __LINE__,
+ 			bitmap->cluster_slot, offset);
+ 	}
+ 
++>>>>>>> ec0cc226854a (md/bitmap: change all printk() to pr_*())
  	if (bitmap->storage.file) {
  		loff_t isize = i_size_read(bitmap->storage.file->f_mapping->host);
  		int bytes = isize > PAGE_SIZE ? PAGE_SIZE : isize;
@@@ -609,12 -653,10 +627,19 @@@
  			goto out;
  		}
  		events = le64_to_cpu(sb->events);
++<<<<<<< HEAD
 +		if (events < bitmap->mddev->events) {
 +			printk(KERN_INFO
 +			       "%s: bitmap file is out of date (%llu < %llu) "
 +			       "-- forcing full recovery\n",
 +			       bmname(bitmap), events,
 +			       (unsigned long long) bitmap->mddev->events);
++=======
+ 		if (!nodes && (events < bitmap->mddev->events)) {
+ 			pr_warn("%s: bitmap file is out of date (%llu < %llu) -- forcing full recovery\n",
+ 				bmname(bitmap), events,
+ 				(unsigned long long) bitmap->mddev->events);
++>>>>>>> ec0cc226854a (md/bitmap: change all printk() to pr_*())
  			set_bit(BITMAP_STALE, &bitmap->flags);
  		}
  	}
@@@ -624,9 -666,25 +649,26 @@@
  	if (le32_to_cpu(sb->version) == BITMAP_MAJOR_HOSTENDIAN)
  		set_bit(BITMAP_HOSTENDIAN, &bitmap->flags);
  	bitmap->events_cleared = le64_to_cpu(sb->events_cleared);
 -	strlcpy(bitmap->mddev->bitmap_info.cluster_name, sb->cluster_name, 64);
  	err = 0;
 -
  out:
  	kunmap_atomic(sb);
++<<<<<<< HEAD
++=======
+ 	/* Assiging chunksize is required for "re_read" */
+ 	bitmap->mddev->bitmap_info.chunksize = chunksize;
+ 	if (err == 0 && nodes && (bitmap->cluster_slot < 0)) {
+ 		err = md_setup_cluster(bitmap->mddev, nodes);
+ 		if (err) {
+ 			pr_warn("%s: Could not setup cluster service (%d)\n",
+ 				bmname(bitmap), err);
+ 			goto out_no_sb;
+ 		}
+ 		bitmap->cluster_slot = md_cluster_ops->slot_number(bitmap->mddev);
+ 		goto re_read;
+ 	}
+ 
+ 
++>>>>>>> ec0cc226854a (md/bitmap: change all printk() to pr_*())
  out_no_sb:
  	if (test_bit(BITMAP_STALE, &bitmap->flags))
  		bitmap->events_cleared = bitmap->mddev->events;
@@@ -775,12 -841,11 +817,11 @@@ static void bitmap_file_kick(struct bit
  		if (bitmap->storage.file) {
  			path = kmalloc(PAGE_SIZE, GFP_KERNEL);
  			if (path)
 -				ptr = file_path(bitmap->storage.file,
 +				ptr = d_path(&bitmap->storage.file->f_path,
  					     path, PAGE_SIZE);
  
- 			printk(KERN_ALERT
- 			      "%s: kicking failed bitmap file %s from array!\n",
- 			      bmname(bitmap), IS_ERR(ptr) ? "" : ptr);
+ 			pr_warn("%s: kicking failed bitmap file %s from array!\n",
+ 				bmname(bitmap), IS_ERR(ptr) ? "" : ptr);
  
  			kfree(path);
  		} else
@@@ -1693,15 -1818,17 +1731,15 @@@ int bitmap_create(struct mddev *mddev
  	if (err)
  		goto error;
  
- 	printk(KERN_INFO "created bitmap (%lu pages) for device %s\n",
- 	       bitmap->counts.pages, bmname(bitmap));
+ 	pr_debug("created bitmap (%lu pages) for device %s\n",
+ 		 bitmap->counts.pages, bmname(bitmap));
  
 -	err = test_bit(BITMAP_WRITE_ERROR, &bitmap->flags) ? -EIO : 0;
 -	if (err)
 -		goto error;
 +	mddev->bitmap = bitmap;
 +	return test_bit(BITMAP_WRITE_ERROR, &bitmap->flags) ? -EIO : 0;
  
 -	return bitmap;
   error:
  	bitmap_free(bitmap);
 -	return ERR_PTR(err);
 +	return err;
  }
  
  int bitmap_load(struct mddev *mddev)
@@@ -1878,6 -2062,35 +1916,38 @@@ int bitmap_resize(struct bitmap *bitmap
  		     chunks << chunkshift);
  
  	spin_lock_irq(&bitmap->counts.lock);
++<<<<<<< HEAD
++=======
+ 	/* For cluster raid, need to pre-allocate bitmap */
+ 	if (mddev_is_clustered(bitmap->mddev)) {
+ 		unsigned long page;
+ 		for (page = 0; page < pages; page++) {
+ 			ret = bitmap_checkpage(&bitmap->counts, page, 1, 1);
+ 			if (ret) {
+ 				unsigned long k;
+ 
+ 				/* deallocate the page memory */
+ 				for (k = 0; k < page; k++) {
+ 					kfree(new_bp[k].map);
+ 				}
+ 
+ 				/* restore some fields from old_counts */
+ 				bitmap->counts.bp = old_counts.bp;
+ 				bitmap->counts.pages = old_counts.pages;
+ 				bitmap->counts.missing_pages = old_counts.pages;
+ 				bitmap->counts.chunkshift = old_counts.chunkshift;
+ 				bitmap->counts.chunks = old_counts.chunks;
+ 				bitmap->mddev->bitmap_info.chunksize = 1 << (old_counts.chunkshift +
+ 									     BITMAP_BLOCK_SHIFT);
+ 				blocks = old_counts.chunks << old_counts.chunkshift;
+ 				pr_warn("Could not pre-allocate in-memory bitmap for cluster raid\n");
+ 				break;
+ 			} else
+ 				bitmap->counts.bp[page].count += 1;
+ 		}
+ 	}
+ 
++>>>>>>> ec0cc226854a (md/bitmap: change all printk() to pr_*())
  	for (block = 0; block < blocks; ) {
  		bitmap_counter_t *bmc_old, *bmc_new;
  		int set;
* Unmerged path drivers/md/bitmap.c
