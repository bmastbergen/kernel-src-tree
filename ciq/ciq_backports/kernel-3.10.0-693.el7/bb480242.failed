qed: Prevent stack corruption on MFW interaction

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit bb48024284327768debd03a197d7c4179ec6ca05
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/bb480242.failed

Driver uses a union for copying data to & from management firmware
when interacting with it.
Problem is that the function always copies sizeof(union) while commit
2edbff8dcb5d ("qed: Learn resources from management firmware") is casting
a union elements which is of smaller size [24-byte instead of 88-bytes].

Also, the union contains some inappropriate elements which increase its
size [should have been 32-bytes]. While this shouldn't corrupt other
PF messages to the MFW [as management firmware enforces permissions so
that each PF is allowed to write only to its own mailbox] we fix this
here as well.

Fixes: 2edbff8dcb5d ("qed: Learn resources from management firmware")
	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bb48024284327768debd03a197d7c4179ec6ca05)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_mcp.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_mcp.c
index dae4c0af6504,6dd3ce443484..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@@ -1406,3 -1683,53 +1406,56 @@@ int qed_mcp_bist_nvm_test_get_image_att
  
  	return rc;
  }
++<<<<<<< HEAD
++=======
+ 
+ #define QED_RESC_ALLOC_VERSION_MAJOR    1
+ #define QED_RESC_ALLOC_VERSION_MINOR    0
+ #define QED_RESC_ALLOC_VERSION				     \
+ 	((QED_RESC_ALLOC_VERSION_MAJOR <<		     \
+ 	  DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MAJOR_SHIFT) | \
+ 	 (QED_RESC_ALLOC_VERSION_MINOR <<		     \
+ 	  DRV_MB_PARAM_RESOURCE_ALLOC_VERSION_MINOR_SHIFT))
+ int qed_mcp_get_resc_info(struct qed_hwfn *p_hwfn,
+ 			  struct qed_ptt *p_ptt,
+ 			  struct resource_info *p_resc_info,
+ 			  u32 *p_mcp_resp, u32 *p_mcp_param)
+ {
+ 	struct qed_mcp_mb_params mb_params;
+ 	union drv_union_data union_data;
+ 	int rc;
+ 
+ 	memset(&mb_params, 0, sizeof(mb_params));
+ 	memset(&union_data, 0, sizeof(union_data));
+ 	mb_params.cmd = DRV_MSG_GET_RESOURCE_ALLOC_MSG;
+ 	mb_params.param = QED_RESC_ALLOC_VERSION;
+ 
+ 	/* Need to have a sufficient large struct, as the cmd_and_union
+ 	 * is going to do memcpy from and to it.
+ 	 */
+ 	memcpy(&union_data.resource, p_resc_info, sizeof(*p_resc_info));
+ 
+ 	mb_params.p_data_src = &union_data;
+ 	mb_params.p_data_dst = &union_data;
+ 	rc = qed_mcp_cmd_and_union(p_hwfn, p_ptt, &mb_params);
+ 	if (rc)
+ 		return rc;
+ 
+ 	/* Copy the data back */
+ 	memcpy(p_resc_info, &union_data.resource, sizeof(*p_resc_info));
+ 	*p_mcp_resp = mb_params.mcp_resp;
+ 	*p_mcp_param = mb_params.mcp_param;
+ 
+ 	DP_VERBOSE(p_hwfn,
+ 		   QED_MSG_SP,
+ 		   "MFW resource_info: version 0x%x, res_id 0x%x, size 0x%x, offset 0x%x, vf_size 0x%x, vf_offset 0x%x, flags 0x%x\n",
+ 		   *p_mcp_param,
+ 		   p_resc_info->res_id,
+ 		   p_resc_info->size,
+ 		   p_resc_info->offset,
+ 		   p_resc_info->vf_size,
+ 		   p_resc_info->vf_offset, p_resc_info->flags);
+ 
+ 	return 0;
+ }
++>>>>>>> bb4802428432 (qed: Prevent stack corruption on MFW interaction)
diff --git a/drivers/net/ethernet/qlogic/qed/qed_hsi.h b/drivers/net/ethernet/qlogic/qed/qed_hsi.h
index 3601aad5e229..af576c8bbb63 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_hsi.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_hsi.h
@@ -8546,7 +8546,6 @@ union drv_union_data {
 	struct drv_version_stc drv_version;
 
 	struct lan_stats_stc lan_stats;
-	u64 reserved_stats[11];
 	struct ocbb_data_stc ocbb_info;
 	struct temperature_status_stc temp_info;
 	struct bist_nvm_image_att nvm_image_att;
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_mcp.c
