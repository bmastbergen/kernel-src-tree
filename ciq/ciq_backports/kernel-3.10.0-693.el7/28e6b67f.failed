net: sched: fix refcount imbalance in actions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: fix refcount imbalance in actions (Ivan Vecera) [1428588]
Rebuild_FUZZ: 94.12%
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 28e6b67f0b292f557468c139085303b15f1a678f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/28e6b67f.failed

Since commit 55334a5db5cd ("net_sched: act: refuse to remove bound action
outside"), we end up with a wrong reference count for a tc action.

Test case 1:

  FOO="1,6 0 0 4294967295,"
  BAR="1,6 0 0 4294967294,"
  tc filter add dev foo parent 1: bpf bytecode "$FOO" flowid 1:1 \
     action bpf bytecode "$FOO"
  tc actions show action bpf
    action order 0: bpf bytecode '1,6 0 0 4294967295' default-action pipe
    index 1 ref 1 bind 1
  tc actions replace action bpf bytecode "$BAR" index 1
  tc actions show action bpf
    action order 0: bpf bytecode '1,6 0 0 4294967294' default-action pipe
    index 1 ref 2 bind 1
  tc actions replace action bpf bytecode "$FOO" index 1
  tc actions show action bpf
    action order 0: bpf bytecode '1,6 0 0 4294967295' default-action pipe
    index 1 ref 3 bind 1

Test case 2:

  FOO="1,6 0 0 4294967295,"
  tc filter add dev foo parent 1: bpf bytecode "$FOO" flowid 1:1 action ok
  tc actions show action gact
    action order 0: gact action pass
    random type none pass val 0
     index 1 ref 1 bind 1
  tc actions add action drop index 1
    RTNETLINK answers: File exists [...]
  tc actions show action gact
    action order 0: gact action pass
     random type none pass val 0
     index 1 ref 2 bind 1
  tc actions add action drop index 1
    RTNETLINK answers: File exists [...]
  tc actions show action gact
    action order 0: gact action pass
     random type none pass val 0
     index 1 ref 3 bind 1

What happens is that in tcf_hash_check(), we check tcf_common for a given
index and increase tcfc_refcnt and conditionally tcfc_bindcnt when we've
found an existing action. Now there are the following cases:

  1) We do a late binding of an action. In that case, we leave the
     tcfc_refcnt/tcfc_bindcnt increased and are done with the ->init()
     handler. This is correctly handeled.

  2) We replace the given action, or we try to add one without replacing
     and find out that the action at a specific index already exists
     (thus, we go out with error in that case).

In case of 2), we have to undo the reference count increase from
tcf_hash_check() in the tcf_hash_check() function. Currently, we fail to
do so because of the 'tcfc_bindcnt > 0' check which bails out early with
an -EPERM error.

Now, while commit 55334a5db5cd prevents 'tc actions del action ...' on an
already classifier-bound action to drop the reference count (which could
then become negative, wrap around etc), this restriction only accounts for
invocations outside a specific action's ->init() handler.

One possible solution would be to add a flag thus we possibly trigger
the -EPERM ony in situations where it is indeed relevant.

After the patch, above test cases have correct reference count again.

Fixes: 55334a5db5cd ("net_sched: act: refuse to remove bound action outside")
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Reviewed-by: Cong Wang <cwang@twopensource.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 28e6b67f0b292f557468c139085303b15f1a678f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/act_api.h
#	net/sched/act_api.c
diff --cc include/net/act_api.h
index 11aac9abd0ca,931738bc5bba..000000000000
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@@ -77,22 -97,25 +77,42 @@@ struct tc_action_ops 
  	int     (*walk)(struct sk_buff *, struct netlink_callback *, int, struct tc_action *);
  };
  
++<<<<<<< HEAD
 +struct tcf_common *tcf_hash_lookup(u32 index, struct tcf_hashinfo *hinfo);
 +void tcf_hash_destroy(struct tcf_common *p, struct tcf_hashinfo *hinfo);
 +int tcf_hash_release(struct tcf_common *p, int bind,
 +		     struct tcf_hashinfo *hinfo);
 +u32 tcf_hash_new_index(u32 *idx_gen, struct tcf_hashinfo *hinfo);
 +struct tcf_common *tcf_hash_check(u32 index, struct tc_action *a,
 +				  int bind, struct tcf_hashinfo *hinfo);
 +struct tcf_common *tcf_hash_create(u32 index, struct nlattr *est,
 +				   struct tc_action *a, int size,
 +				   int bind, u32 *idx_gen,
 +				   struct tcf_hashinfo *hinfo);
 +void tcf_hash_insert(struct tcf_common *p, struct tcf_hashinfo *hinfo);
 +
 +int tcf_register_action(struct tc_action_ops *a);
++=======
+ int tcf_hash_search(struct tc_action *a, u32 index);
+ void tcf_hash_destroy(struct tc_action *a);
+ u32 tcf_hash_new_index(struct tcf_hashinfo *hinfo);
+ int tcf_hash_check(u32 index, struct tc_action *a, int bind);
+ int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
+ 		    int size, int bind);
+ void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est);
+ void tcf_hash_insert(struct tc_action *a);
+ 
+ int __tcf_hash_release(struct tc_action *a, bool bind, bool strict);
+ 
+ static inline int tcf_hash_release(struct tc_action *a, bool bind)
+ {
+ 	return __tcf_hash_release(a, bind, false);
+ }
+ 
+ int tcf_register_action(struct tc_action_ops *a, unsigned int mask);
++>>>>>>> 28e6b67f0b29 (net: sched: fix refcount imbalance in actions)
  int tcf_unregister_action(struct tc_action_ops *a);
 -int tcf_action_destroy(struct list_head *actions, int bind);
 +void tcf_action_destroy(struct list_head *actions, int bind);
  int tcf_action_exec(struct sk_buff *skb, const struct list_head *actions,
  		    struct tcf_result *res);
  int tcf_action_init(struct net *net, struct nlattr *nla,
diff --cc net/sched/act_api.c
index 45d305cc522a,43ec92680ae8..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -51,14 -45,16 +51,23 @@@ void tcf_hash_destroy(struct tcf_commo
  }
  EXPORT_SYMBOL(tcf_hash_destroy);
  
++<<<<<<< HEAD
 +int tcf_hash_release(struct tcf_common *p, int bind,
 +		     struct tcf_hashinfo *hinfo)
++=======
+ int __tcf_hash_release(struct tc_action *a, bool bind, bool strict)
++>>>>>>> 28e6b67f0b29 (net: sched: fix refcount imbalance in actions)
  {
 -	struct tcf_common *p = a->priv;
  	int ret = 0;
  
  	if (p) {
  		if (bind)
  			p->tcfc_bindcnt--;
++<<<<<<< HEAD
++=======
+ 		else if (strict && p->tcfc_bindcnt > 0)
+ 			return -EPERM;
++>>>>>>> 28e6b67f0b29 (net: sched: fix refcount imbalance in actions)
  
  		p->tcfc_refcnt--;
  		if (p->tcfc_bindcnt <= 0 && p->tcfc_refcnt <= 0) {
@@@ -66,13 -64,16 +75,14 @@@
  			ret = 1;
  		}
  	}
+ 
  	return ret;
  }
- EXPORT_SYMBOL(tcf_hash_release);
+ EXPORT_SYMBOL(__tcf_hash_release);
  
  static int tcf_dump_walker(struct sk_buff *skb, struct netlink_callback *cb,
 -			   struct tc_action *a)
 +			   struct tc_action *a, struct tcf_hashinfo *hinfo)
  {
 -	struct tcf_hashinfo *hinfo = a->ops->hinfo;
 -	struct hlist_head *head;
  	struct tcf_common *p;
  	int err = 0, index = -1, i = 0, s_i = 0, n_i = 0;
  	struct nlattr *nest;
@@@ -130,14 -134,15 +140,22 @@@ static int tcf_del_walker(struct sk_buf
  	if (nla_put_string(skb, TCA_KIND, a->ops->kind))
  		goto nla_put_failure;
  	for (i = 0; i < (hinfo->hmask + 1); i++) {
++<<<<<<< HEAD
 +		p = hinfo->htab[tcf_hash(i, hinfo->hmask)];
 +
 +		while (p != NULL) {
 +			s_p = p->tcfc_next;
 +			if (ACT_P_DELETED == tcf_hash_release(p, 0, hinfo))
++=======
+ 		head = &hinfo->htab[tcf_hash(i, hinfo->hmask)];
+ 		hlist_for_each_entry_safe(p, n, head, tcfc_head) {
+ 			a->priv = p;
+ 			ret = __tcf_hash_release(a, false, true);
+ 			if (ret == ACT_P_DELETED) {
++>>>>>>> 28e6b67f0b29 (net: sched: fix refcount imbalance in actions)
  				module_put(a->ops->owner);
 -				n_i++;
 -			} else if (ret < 0)
 -				goto nla_put_failure;
 +			n_i++;
 +			p = s_p;
  		}
  	}
  	if (nla_put_u32(skb, TCA_FCNT, n_i))
@@@ -372,13 -403,17 +390,18 @@@ exec_done
  }
  EXPORT_SYMBOL(tcf_action_exec);
  
 -int tcf_action_destroy(struct list_head *actions, int bind)
 +void tcf_action_destroy(struct list_head *actions, int bind)
  {
  	struct tc_action *a, *tmp;
 -	int ret = 0;
  
  	list_for_each_entry_safe(a, tmp, actions, list) {
++<<<<<<< HEAD
 +		if (a->ops->cleanup(a, bind) == ACT_P_DELETED)
++=======
+ 		ret = __tcf_hash_release(a, bind, true);
+ 		if (ret == ACT_P_DELETED)
++>>>>>>> 28e6b67f0b29 (net: sched: fix refcount imbalance in actions)
  			module_put(a->ops->owner);
 -		else if (ret < 0)
 -			return ret;
  		list_del(&a->list);
  		kfree(a);
  	}
* Unmerged path include/net/act_api.h
* Unmerged path net/sched/act_api.c
