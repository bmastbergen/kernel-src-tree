mmc: dw_mmc: remove DW_MCI_QUIRK_BROKEN_CARD_DETECTION quirk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mmc] dw_mmc: remove DW_MCI_QUIRK_BROKEN_CARD_DETECTION quirk (Don Zickus) [1430497]
Rebuild_FUZZ: 95.65%
commit-author Shawn Lin <shawn.lin@rock-chips.com>
commit e8cc37b8fc3a94d17a2689cd77a7744d70477c14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e8cc37b8.failed

dw_mmc already use mmc_of_parse to get "broken-cd" property,
but it considered "broken-cd" to be a quirk in its driver. We
don't need this quirk here, and just take what we need from
mmc->caps.

	Signed-off-by: Shawn Lin <shawn.lin@rock-chips.com>
	Tested-by: Jaehoon Chung <jh80.chung@samsung.com>
	Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit e8cc37b8fc3a94d17a2689cd77a7744d70477c14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/dw_mmc.c
diff --cc drivers/mmc/host/dw_mmc.c
index bc3a1bc4940f,8cb8c1c8b3dd..000000000000
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@@ -865,13 -1447,15 +865,22 @@@ static int dw_mci_get_cd(struct mmc_hos
  {
  	int present;
  	struct dw_mci_slot *slot = mmc_priv(mmc);
++<<<<<<< HEAD
 +	struct dw_mci_board *brd = slot->host->pdata;
 +
 +	/* Use platform get_cd function, else try onboard card detect */
 +	if (brd->quirks & DW_MCI_QUIRK_BROKEN_CARD_DETECTION)
++=======
+ 	struct dw_mci *host = slot->host;
+ 	int gpio_cd = mmc_gpio_get_cd(mmc);
+ 
+ 	/* Use platform get_cd function, else try onboard card detect */
+ 	if ((mmc->caps & MMC_CAP_NEEDS_POLL) ||
+ 	    (mmc->caps & MMC_CAP_NONREMOVABLE))
++>>>>>>> e8cc37b8fc3a (mmc: dw_mmc: remove DW_MCI_QUIRK_BROKEN_CARD_DETECTION quirk)
  		present = 1;
 -	else if (!IS_ERR_VALUE(gpio_cd))
 -		present = gpio_cd;
 +	else if (brd->get_cd)
 +		present = !brd->get_cd(slot->id);
  	else
  		present = (mci_readl(slot->host, CDETECT) & (1 << slot->id))
  			== 0 ? 1 : 0;
@@@ -2103,33 -2758,125 +2112,41 @@@ static bool mci_wait_reset(struct devic
  	return false;
  }
  
 -static bool dw_mci_reset(struct dw_mci *host)
 -{
 -	u32 flags = SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET;
 -	bool ret = false;
 -
 -	/*
 -	 * Reseting generates a block interrupt, hence setting
 -	 * the scatter-gather pointer to NULL.
 -	 */
 -	if (host->sg) {
 -		sg_miter_stop(&host->sg_miter);
 -		host->sg = NULL;
 -	}
 -
 -	if (host->use_dma)
 -		flags |= SDMMC_CTRL_DMA_RESET;
 -
 -	if (dw_mci_ctrl_reset(host, flags)) {
 -		/*
 -		 * In all cases we clear the RAWINTS register to clear any
 -		 * interrupts.
 -		 */
 -		mci_writel(host, RINTSTS, 0xFFFFFFFF);
 -
 -		/* if using dma we wait for dma_req to clear */
 -		if (host->use_dma) {
 -			unsigned long timeout = jiffies + msecs_to_jiffies(500);
 -			u32 status;
 -
 -			do {
 -				status = mci_readl(host, STATUS);
 -				if (!(status & SDMMC_STATUS_DMA_REQ))
 -					break;
 -				cpu_relax();
 -			} while (time_before(jiffies, timeout));
 -
 -			if (status & SDMMC_STATUS_DMA_REQ) {
 -				dev_err(host->dev,
 -					"%s: Timeout waiting for dma_req to clear during reset\n",
 -					__func__);
 -				goto ciu_out;
 -			}
 -
 -			/* when using DMA next we reset the fifo again */
 -			if (!dw_mci_ctrl_reset(host, SDMMC_CTRL_FIFO_RESET))
 -				goto ciu_out;
 -		}
 -	} else {
 -		/* if the controller reset bit did clear, then set clock regs */
 -		if (!(mci_readl(host, CTRL) & SDMMC_CTRL_RESET)) {
 -			dev_err(host->dev,
 -				"%s: fifo/dma reset bits didn't clear but ciu was reset, doing clock update\n",
 -				__func__);
 -			goto ciu_out;
 -		}
 -	}
 -
 -	if (host->use_dma == TRANS_MODE_IDMAC)
 -		/* It is also recommended that we reset and reprogram idmac */
 -		dw_mci_idmac_reset(host);
 -
 -	ret = true;
 -
 -ciu_out:
 -	/* After a CTRL reset we need to have CIU set clock registers  */
 -	mci_send_cmd(host->cur_slot, SDMMC_CMD_UPD_CLK, 0);
 -
 -	return ret;
 -}
 -
 -static void dw_mci_cmd11_timer(unsigned long arg)
 -{
 -	struct dw_mci *host = (struct dw_mci *)arg;
 -
 -	if (host->state != STATE_SENDING_CMD11) {
 -		dev_warn(host->dev, "Unexpected CMD11 timeout\n");
 -		return;
 -	}
 -
 -	host->cmd_status = SDMMC_INT_RTO;
 -	set_bit(EVENT_CMD_COMPLETE, &host->pending_events);
 -	tasklet_schedule(&host->tasklet);
 -}
 -
 -static void dw_mci_dto_timer(unsigned long arg)
 -{
 -	struct dw_mci *host = (struct dw_mci *)arg;
 -
 -	switch (host->state) {
 -	case STATE_SENDING_DATA:
 -	case STATE_DATA_BUSY:
 -		/*
 -		 * If DTO interrupt does NOT come in sending data state,
 -		 * we should notify the driver to terminate current transfer
 -		 * and report a data timeout to the core.
 -		 */
 -		host->data_status = SDMMC_INT_DRTO;
 -		set_bit(EVENT_DATA_ERROR, &host->pending_events);
 -		set_bit(EVENT_DATA_COMPLETE, &host->pending_events);
 -		tasklet_schedule(&host->tasklet);
 -		break;
 -	default:
 -		break;
 -	}
 -}
 -
  #ifdef CONFIG_OF
++<<<<<<< HEAD
 +static struct dw_mci_of_quirks {
 +	char *quirk;
 +	int id;
 +} of_quirks[] = {
 +	{
 +		.quirk	= "supports-highspeed",
 +		.id	= DW_MCI_QUIRK_HIGHSPEED,
 +	}, {
 +		.quirk	= "broken-cd",
 +		.id	= DW_MCI_QUIRK_BROKEN_CARD_DETECTION,
 +	},
 +};
 +
++=======
++>>>>>>> e8cc37b8fc3a (mmc: dw_mmc: remove DW_MCI_QUIRK_BROKEN_CARD_DETECTION quirk)
  static struct dw_mci_board *dw_mci_parse_dt(struct dw_mci *host)
  {
  	struct dw_mci_board *pdata;
  	struct device *dev = host->dev;
  	struct device_node *np = dev->of_node;
  	const struct dw_mci_drv_data *drv_data = host->drv_data;
++<<<<<<< HEAD
 +	int idx, ret;
++=======
+ 	int ret;
+ 	u32 clock_frequency;
++>>>>>>> e8cc37b8fc3a (mmc: dw_mmc: remove DW_MCI_QUIRK_BROKEN_CARD_DETECTION quirk)
  
  	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
 -	if (!pdata)
 +	if (!pdata) {
 +		dev_err(dev, "could not allocate memory for pdata\n");
  		return ERR_PTR(-ENOMEM);
 +	}
  
  	/* find out number of slots supported */
  	if (of_property_read_u32(dev->of_node, "num-slots",
@@@ -2139,14 -2886,9 +2156,9 @@@
  		pdata->num_slots = 1;
  	}
  
- 	/* get quirks */
- 	for (idx = 0; idx < ARRAY_SIZE(of_quirks); idx++)
- 		if (of_get_property(np, of_quirks[idx].quirk, NULL))
- 			pdata->quirks |= of_quirks[idx].id;
- 
  	if (of_property_read_u32(np, "fifo-depth", &pdata->fifo_depth))
 -		dev_info(dev,
 -			 "fifo-depth property not found, using value of FIFOTH register as default\n");
 +		dev_info(dev, "fifo-depth property not found, using "
 +				"value of FIFOTH register as default\n");
  
  	of_property_read_u32(np, "card-detect-delay", &pdata->detect_delay_ms);
  
@@@ -2172,6 -2916,35 +2184,38 @@@ static struct dw_mci_board *dw_mci_pars
  }
  #endif /* CONFIG_OF */
  
++<<<<<<< HEAD
++=======
+ static void dw_mci_enable_cd(struct dw_mci *host)
+ {
+ 	unsigned long irqflags;
+ 	u32 temp;
+ 	int i;
+ 	struct dw_mci_slot *slot;
+ 
+ 	/*
+ 	 * No need for CD if all slots have a non-error GPIO
+ 	 * as well as broken card detection is found.
+ 	 */
+ 	for (i = 0; i < host->num_slots; i++) {
+ 		slot = host->slot[i];
+ 		if (slot->mmc->caps & MMC_CAP_NEEDS_POLL)
+ 			return;
+ 
+ 		if (IS_ERR_VALUE(mmc_gpio_get_cd(slot->mmc)))
+ 			break;
+ 	}
+ 	if (i == host->num_slots)
+ 		return;
+ 
+ 	spin_lock_irqsave(&host->irq_lock, irqflags);
+ 	temp = mci_readl(host, INTMASK);
+ 	temp  |= SDMMC_INT_CD;
+ 	mci_writel(host, INTMASK, temp);
+ 	spin_unlock_irqrestore(&host->irq_lock, irqflags);
+ }
+ 
++>>>>>>> e8cc37b8fc3a (mmc: dw_mmc: remove DW_MCI_QUIRK_BROKEN_CARD_DETECTION quirk)
  int dw_mci_probe(struct dw_mci *host)
  {
  	const struct dw_mci_drv_data *drv_data = host->drv_data;
* Unmerged path drivers/mmc/host/dw_mmc.c
diff --git a/include/linux/mmc/dw_mmc.h b/include/linux/mmc/dw_mmc.h
index 1abe9e2c7dd3..1de64ce5ecfe 100644
--- a/include/linux/mmc/dw_mmc.h
+++ b/include/linux/mmc/dw_mmc.h
@@ -229,10 +229,8 @@ struct dw_mci_dma_ops {
 };
 
 /* IP Quirks/flags. */
-/* Unreliable card detection */
-#define DW_MCI_QUIRK_BROKEN_CARD_DETECTION	BIT(0)
 /* Timer for broken data transfer over scheme */
-#define DW_MCI_QUIRK_BROKEN_DTO			BIT(1)
+#define DW_MCI_QUIRK_BROKEN_DTO			BIT(0)
 
 struct dma_pdata;
 
