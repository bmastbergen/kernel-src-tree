gre: remove superfluous pskb_may_pull

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 00b2034029840ddad255352c46db0ae21342ce56
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/00b20340.failed

The call to gre_parse_header is either followed by iptunnel_pull_header, or
in the case of ICMP error path, the actual header is not accessed at all.

In the first case, iptunnel_pull_header will call pskb_may_pull anyway and
it's pointless to do it twice. The only difference is what call will fail
with what error code but the net effect is still the same in all call sites.

In the second case, pskb_may_pull is pointless, as skb->data is at the outer
IP header and not at the GRE header.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 00b2034029840ddad255352c46db0ae21342ce56)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/gre_demux.c
diff --cc net/ipv4/gre_demux.c
index d9c552a721fc,d78e2eefc0f7..000000000000
--- a/net/ipv4/gre_demux.c
+++ b/net/ipv4/gre_demux.c
@@@ -60,6 -60,67 +60,70 @@@ int gre_del_protocol(const struct gre_p
  }
  EXPORT_SYMBOL_GPL(gre_del_protocol);
  
++<<<<<<< HEAD
++=======
+ /* Fills in tpi and returns header length to be pulled. */
+ int gre_parse_header(struct sk_buff *skb, struct tnl_ptk_info *tpi,
+ 		     bool *csum_err)
+ {
+ 	const struct gre_base_hdr *greh;
+ 	__be32 *options;
+ 	int hdr_len;
+ 
+ 	if (unlikely(!pskb_may_pull(skb, sizeof(struct gre_base_hdr))))
+ 		return -EINVAL;
+ 
+ 	greh = (struct gre_base_hdr *)skb_transport_header(skb);
+ 	if (unlikely(greh->flags & (GRE_VERSION | GRE_ROUTING)))
+ 		return -EINVAL;
+ 
+ 	tpi->flags = gre_flags_to_tnl_flags(greh->flags);
+ 	hdr_len = gre_calc_hlen(tpi->flags);
+ 
+ 	if (!pskb_may_pull(skb, hdr_len))
+ 		return -EINVAL;
+ 
+ 	greh = (struct gre_base_hdr *)skb_transport_header(skb);
+ 	tpi->proto = greh->protocol;
+ 
+ 	options = (__be32 *)(greh + 1);
+ 	if (greh->flags & GRE_CSUM) {
+ 		if (skb_checksum_simple_validate(skb)) {
+ 			*csum_err = true;
+ 			return -EINVAL;
+ 		}
+ 
+ 		skb_checksum_try_convert(skb, IPPROTO_GRE, 0,
+ 					 null_compute_pseudo);
+ 		options++;
+ 	}
+ 
+ 	if (greh->flags & GRE_KEY) {
+ 		tpi->key = *options;
+ 		options++;
+ 	} else {
+ 		tpi->key = 0;
+ 	}
+ 	if (unlikely(greh->flags & GRE_SEQ)) {
+ 		tpi->seq = *options;
+ 		options++;
+ 	} else {
+ 		tpi->seq = 0;
+ 	}
+ 	/* WCCP version 1 and 2 protocol decoding.
+ 	 * - Change protocol to IP
+ 	 * - When dealing with WCCPv2, Skip extra 4 bytes in GRE header
+ 	 */
+ 	if (greh->flags == 0 && tpi->proto == htons(ETH_P_WCCP)) {
+ 		tpi->proto = htons(ETH_P_IP);
+ 		if ((*(u8 *)options & 0xF0) != 0x40)
+ 			hdr_len += 4;
+ 	}
+ 	return hdr_len;
+ }
+ EXPORT_SYMBOL(gre_parse_header);
+ 
++>>>>>>> 00b203402984 (gre: remove superfluous pskb_may_pull)
  static int gre_rcv(struct sk_buff *skb)
  {
  	const struct gre_protocol *proto;
* Unmerged path net/ipv4/gre_demux.c
