netfilter: conntrack: built-in support for DCCP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Davide Caratti <dcaratti@redhat.com>
commit c51d39010a1bccc9c1294e2d7c00005aefeb2b5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c51d3901.failed

CONFIG_NF_CT_PROTO_DCCP is no more a tristate. When set to y, connection
tracking support for DCCP protocol is built-in into nf_conntrack.ko.

footprint test:
$ ls -l net/netfilter/nf_conntrack{_proto_dccp,}.ko \
        net/ipv4/netfilter/nf_conntrack_ipv4.ko \
        net/ipv6/netfilter/nf_conntrack_ipv6.ko

(builtin)||  dccp  |  ipv4  |  ipv6  | nf_conntrack
---------++--------+--------+--------+--------------
none     || 469140 | 828755 | 828676 | 6141434
DCCP     ||   -    | 830566 | 829935 | 6533526

	Signed-off-by: Davide Caratti <dcaratti@redhat.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit c51d39010a1bccc9c1294e2d7c00005aefeb2b5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netns/conntrack.h
#	net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
#	net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
#	net/netfilter/nf_conntrack_proto_dccp.c
diff --cc include/net/netns/conntrack.h
index 4303c98010df,440b781baf0b..000000000000
--- a/include/net/netns/conntrack.h
+++ b/include/net/netns/conntrack.h
@@@ -4,7 -4,11 +4,10 @@@
  #include <linux/list.h>
  #include <linux/list_nulls.h>
  #include <linux/atomic.h>
 -#include <linux/workqueue.h>
  #include <linux/netfilter/nf_conntrack_tcp.h>
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ #include <linux/netfilter/nf_conntrack_dccp.h>
+ #endif
  #include <linux/seqlock.h>
  
  struct ctl_table_header;
@@@ -57,9 -65,8 +68,14 @@@ struct nf_ip_net 
  	struct nf_udp_net	udp;
  	struct nf_icmp_net	icmp;
  	struct nf_icmp_net	icmpv6;
++<<<<<<< HEAD
 +#if defined(CONFIG_SYSCTL) && defined(CONFIG_NF_CONNTRACK_PROC_COMPAT)
 +	struct ctl_table_header *ctl_table_header;
 +	struct ctl_table	*ctl_table;
++=======
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	struct nf_dccp_net	dccp;
++>>>>>>> c51d39010a1b (netfilter: conntrack: built-in support for DCCP)
  #endif
  };
  
diff --cc net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
index 311c90294dd4,cb3cf770b00c..000000000000
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
@@@ -408,6 -336,15 +408,18 @@@ MODULE_ALIAS("nf_conntrack-" __stringif
  MODULE_ALIAS("ip_conntrack");
  MODULE_LICENSE("GPL");
  
++<<<<<<< HEAD
++=======
+ static struct nf_conntrack_l4proto *builtin_l4proto4[] = {
+ 	&nf_conntrack_l4proto_tcp4,
+ 	&nf_conntrack_l4proto_udp4,
+ 	&nf_conntrack_l4proto_icmp,
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	&nf_conntrack_l4proto_dccp4,
+ #endif
+ };
+ 
++>>>>>>> c51d39010a1b (netfilter: conntrack: built-in support for DCCP)
  static int ipv4_net_init(struct net *net)
  {
  	int ret = 0;
diff --cc net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
index 8f8c8ed94a2f,f52338d02951..000000000000
--- a/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
@@@ -350,6 -336,15 +350,18 @@@ static struct nf_sockopt_ops so_getorig
  	.owner		= THIS_MODULE,
  };
  
++<<<<<<< HEAD
++=======
+ static struct nf_conntrack_l4proto *builtin_l4proto6[] = {
+ 	&nf_conntrack_l4proto_tcp6,
+ 	&nf_conntrack_l4proto_udp6,
+ 	&nf_conntrack_l4proto_icmpv6,
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	&nf_conntrack_l4proto_dccp6,
+ #endif
+ };
+ 
++>>>>>>> c51d39010a1b (netfilter: conntrack: built-in support for DCCP)
  static int ipv6_net_init(struct net *net)
  {
  	int ret = 0;
diff --cc net/netfilter/nf_conntrack_proto_dccp.c
index 59359bec328a,b68ce6ac13b3..000000000000
--- a/net/netfilter/nf_conntrack_proto_dccp.c
+++ b/net/netfilter/nf_conntrack_proto_dccp.c
@@@ -384,17 -383,9 +383,21 @@@ dccp_state_table[CT_DCCP_ROLE_MAX + 1][
  	},
  };
  
++<<<<<<< HEAD
 +/* this module per-net specifics */
 +static int dccp_net_id __read_mostly;
 +struct dccp_net {
 +	struct nf_proto_net pn;
 +	int dccp_loose;
 +	unsigned int dccp_timeout[CT_DCCP_MAX + 1];
 +};
 +
 +static inline struct dccp_net *dccp_pernet(struct net *net)
++=======
+ static inline struct nf_dccp_net *dccp_pernet(struct net *net)
++>>>>>>> c51d39010a1b (netfilter: conntrack: built-in support for DCCP)
  {
- 	return net_generic(net, dccp_net_id);
+ 	return &net->ct.nf_ct_proto.dccp;
  }
  
  static bool dccp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,
@@@ -929,78 -923,6 +932,81 @@@ struct nf_conntrack_l4proto nf_conntrac
  		.nla_policy	= dccp_timeout_nla_policy,
  	},
  #endif /* CONFIG_NF_CT_NETLINK_TIMEOUT */
- 	.net_id			= &dccp_net_id,
  	.init_net		= dccp_init_net,
  };
++<<<<<<< HEAD
 +
 +static __net_init int dccp_net_init(struct net *net)
 +{
 +	int ret = 0;
 +	ret = nf_ct_l4proto_pernet_register(net, &dccp_proto4);
 +	if (ret < 0) {
 +		pr_err("nf_conntrack_dccp4: pernet registration failed.\n");
 +		goto out;
 +	}
 +	ret = nf_ct_l4proto_pernet_register(net, &dccp_proto6);
 +	if (ret < 0) {
 +		pr_err("nf_conntrack_dccp6: pernet registration failed.\n");
 +		goto cleanup_dccp4;
 +	}
 +	return 0;
 +cleanup_dccp4:
 +	nf_ct_l4proto_pernet_unregister(net, &dccp_proto4);
 +out:
 +	return ret;
 +}
 +
 +static __net_exit void dccp_net_exit(struct net *net)
 +{
 +	nf_ct_l4proto_pernet_unregister(net, &dccp_proto6);
 +	nf_ct_l4proto_pernet_unregister(net, &dccp_proto4);
 +}
 +
 +static struct pernet_operations dccp_net_ops = {
 +	.init = dccp_net_init,
 +	.exit = dccp_net_exit,
 +	.id   = &dccp_net_id,
 +	.size = sizeof(struct dccp_net),
 +};
 +
 +static int __init nf_conntrack_proto_dccp_init(void)
 +{
 +	int ret;
 +
 +	ret = register_pernet_subsys(&dccp_net_ops);
 +	if (ret < 0)
 +		goto out_pernet;
 +
 +	ret = nf_ct_l4proto_register(&dccp_proto4);
 +	if (ret < 0)
 +		goto out_dccp4;
 +
 +	ret = nf_ct_l4proto_register(&dccp_proto6);
 +	if (ret < 0)
 +		goto out_dccp6;
 +
 +	return 0;
 +out_dccp6:
 +	nf_ct_l4proto_unregister(&dccp_proto4);
 +out_dccp4:
 +	unregister_pernet_subsys(&dccp_net_ops);
 +out_pernet:
 +	return ret;
 +}
 +
 +static void __exit nf_conntrack_proto_dccp_fini(void)
 +{
 +	nf_ct_l4proto_unregister(&dccp_proto6);
 +	nf_ct_l4proto_unregister(&dccp_proto4);
 +	unregister_pernet_subsys(&dccp_net_ops);
 +}
 +
 +module_init(nf_conntrack_proto_dccp_init);
 +module_exit(nf_conntrack_proto_dccp_fini);
 +
 +MODULE_AUTHOR("Patrick McHardy <kaber@trash.net>");
 +MODULE_DESCRIPTION("DCCP connection tracking protocol helper");
 +MODULE_LICENSE("GPL");
++=======
+ EXPORT_SYMBOL_GPL(nf_conntrack_l4proto_dccp6);
++>>>>>>> c51d39010a1b (netfilter: conntrack: built-in support for DCCP)
diff --git a/include/linux/netfilter/nf_conntrack_dccp.h b/include/linux/netfilter/nf_conntrack_dccp.h
index 40dcc82058d1..ff721d7325cf 100644
--- a/include/linux/netfilter/nf_conntrack_dccp.h
+++ b/include/linux/netfilter/nf_conntrack_dccp.h
@@ -25,7 +25,7 @@ enum ct_dccp_roles {
 #define CT_DCCP_ROLE_MAX	(__CT_DCCP_ROLE_MAX - 1)
 
 #ifdef __KERNEL__
-#include <net/netfilter/nf_conntrack_tuple.h>
+#include <linux/netfilter/nf_conntrack_tuple_common.h>
 
 struct nf_ct_dccp {
 	u_int8_t	role[IP_CT_DIR_MAX];
diff --git a/include/net/netfilter/ipv4/nf_conntrack_ipv4.h b/include/net/netfilter/ipv4/nf_conntrack_ipv4.h
index 6c3d12e2949f..91ba5ebad8f0 100644
--- a/include/net/netfilter/ipv4/nf_conntrack_ipv4.h
+++ b/include/net/netfilter/ipv4/nf_conntrack_ipv4.h
@@ -15,6 +15,9 @@ extern struct nf_conntrack_l3proto nf_conntrack_l3proto_ipv4;
 extern struct nf_conntrack_l4proto nf_conntrack_l4proto_tcp4;
 extern struct nf_conntrack_l4proto nf_conntrack_l4proto_udp4;
 extern struct nf_conntrack_l4proto nf_conntrack_l4proto_icmp;
+#ifdef CONFIG_NF_CT_PROTO_DCCP
+extern struct nf_conntrack_l4proto nf_conntrack_l4proto_dccp4;
+#endif
 
 int nf_conntrack_ipv4_compat_init(void);
 void nf_conntrack_ipv4_compat_fini(void);
diff --git a/include/net/netfilter/ipv6/nf_conntrack_ipv6.h b/include/net/netfilter/ipv6/nf_conntrack_ipv6.h
index a4c993685795..5ec66c0d21c4 100644
--- a/include/net/netfilter/ipv6/nf_conntrack_ipv6.h
+++ b/include/net/netfilter/ipv6/nf_conntrack_ipv6.h
@@ -6,6 +6,9 @@ extern struct nf_conntrack_l3proto nf_conntrack_l3proto_ipv6;
 extern struct nf_conntrack_l4proto nf_conntrack_l4proto_tcp6;
 extern struct nf_conntrack_l4proto nf_conntrack_l4proto_udp6;
 extern struct nf_conntrack_l4proto nf_conntrack_l4proto_icmpv6;
+#ifdef CONFIG_NF_CT_PROTO_DCCP
+extern struct nf_conntrack_l4proto nf_conntrack_l4proto_dccp6;
+#endif
 
 #include <linux/sysctl.h>
 extern struct ctl_table nf_ct_ipv6_sysctl_table[];
* Unmerged path include/net/netns/conntrack.h
* Unmerged path net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_conntrack_l3proto_ipv6.c
diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
index a7265625168d..fb759638a8d3 100644
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -134,14 +134,14 @@ config NF_CONNTRACK_LABELS
 	  to connection tracking entries.  It selected by the connlabel match.
 
 config NF_CT_PROTO_DCCP
-	tristate 'DCCP protocol connection tracking support'
+	bool 'DCCP protocol connection tracking support'
 	depends on NETFILTER_ADVANCED
-	default IP_DCCP
+	default y
 	help
 	  With this option enabled, the layer 3 independent connection
 	  tracking code will be able to do state tracking on DCCP connections.
 
-	  If unsure, say 'N'.
+	  If unsure, say Y.
 
 config NF_CT_PROTO_GRE
 	tristate
diff --git a/net/netfilter/Makefile b/net/netfilter/Makefile
index 2a3dcb487568..0f009c5fa12c 100644
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -5,6 +5,7 @@ nf_conntrack-$(CONFIG_NF_CONNTRACK_TIMEOUT) += nf_conntrack_timeout.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_TIMESTAMP) += nf_conntrack_timestamp.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_EVENTS) += nf_conntrack_ecache.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_LABELS) += nf_conntrack_labels.o
+nf_conntrack-$(CONFIG_NF_CT_PROTO_DCCP) += nf_conntrack_proto_dccp.o
 
 obj-$(CONFIG_NETFILTER) = netfilter.o
 
@@ -18,8 +19,6 @@ obj-$(CONFIG_NETFILTER_NETLINK_LOG) += nfnetlink_log.o
 # connection tracking
 obj-$(CONFIG_NF_CONNTRACK) += nf_conntrack.o
 
-# SCTP protocol connection tracking
-obj-$(CONFIG_NF_CT_PROTO_DCCP) += nf_conntrack_proto_dccp.o
 obj-$(CONFIG_NF_CT_PROTO_GRE) += nf_conntrack_proto_gre.o
 obj-$(CONFIG_NF_CT_PROTO_SCTP) += nf_conntrack_proto_sctp.o
 obj-$(CONFIG_NF_CT_PROTO_UDPLITE) += nf_conntrack_proto_udplite.o
* Unmerged path net/netfilter/nf_conntrack_proto_dccp.c
