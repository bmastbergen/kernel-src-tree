pNFS: Handle NFS4ERR_RECALLCONFLICT correctly in LAYOUTGET

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 66b53f325876703b7ab815c482cd104609f8772c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/66b53f32.failed

Instead of giving up altogether and falling back to doing I/O
through the MDS, which may make the situation worse, wait for
2 lease periods for the callback to resolve itself, and then
try destroying the existing layout.

Only if this was an attempt at getting a first layout, do we
give up altogether, as the server is clearly crazy.

Fixes: 183d9e7b112aa ("pnfs: rework LAYOUTGET retry handling")
	Cc: stable@vger.kernel.org # 4.7
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
	Reviewed-by: Jeff Layton <jlayton@redhat.com>
(cherry picked from commit 66b53f325876703b7ab815c482cd104609f8772c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pnfs.c
diff --cc fs/nfs/pnfs.c
index fe569dd6f6b9,7d992362ff04..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -1512,11 -1498,14 +1512,17 @@@ pnfs_update_layout(struct inode *ino
  		.offset = pos,
  		.length = count,
  	};
 -	unsigned pg_offset, seq;
 +	unsigned pg_offset;
  	struct nfs_server *server = NFS_SERVER(ino);
  	struct nfs_client *clp = server->nfs_client;
 -	struct pnfs_layout_hdr *lo = NULL;
 +	struct pnfs_layout_hdr *lo;
  	struct pnfs_layout_segment *lseg = NULL;
++<<<<<<< HEAD
++=======
+ 	nfs4_stateid stateid;
+ 	long timeout = 0;
+ 	unsigned long giveup = jiffies + (clp->cl_lease_time << 1);
++>>>>>>> 66b53f325876 (pNFS: Handle NFS4ERR_RECALLCONFLICT correctly in LAYOUTGET)
  	bool first;
  
  	if (!pnfs_enabled_sb(NFS_SERVER(ino))) {
@@@ -1631,12 -1640,49 +1637,52 @@@ lookup_again
  		arg.length += pg_offset;
  	}
  	if (arg.length != NFS4_MAX_UINT64)
 -		arg.length = PAGE_ALIGN(arg.length);
 +		arg.length = PAGE_CACHE_ALIGN(arg.length);
  
 -	lseg = send_layoutget(lo, ctx, &stateid, &arg, &timeout, gfp_flags);
 -	trace_pnfs_update_layout(ino, pos, count, iomode, lo, lseg,
 -				 PNFS_UPDATE_LAYOUT_SEND_LAYOUTGET);
 +	lseg = send_layoutget(lo, ctx, &arg, gfp_flags);
  	atomic_dec(&lo->plh_outstanding);
++<<<<<<< HEAD
 +	trace_pnfs_update_layout(ino, pos, count, iomode, lo,
 +				 PNFS_UPDATE_LAYOUT_SEND_LAYOUTGET);
++=======
+ 	if (IS_ERR(lseg)) {
+ 		switch(PTR_ERR(lseg)) {
+ 		case -EBUSY:
+ 			if (time_after(jiffies, giveup))
+ 				lseg = NULL;
+ 			break;
+ 		case -ERECALLCONFLICT:
+ 			/* Huh? We hold no layouts, how is there a recall? */
+ 			if (first) {
+ 				lseg = NULL;
+ 				break;
+ 			}
+ 			/* Destroy the existing layout and start over */
+ 			if (time_after(jiffies, giveup))
+ 				pnfs_destroy_layout(NFS_I(ino));
+ 			/* Fallthrough */
+ 		case -EAGAIN:
+ 			break;
+ 		default:
+ 			if (!nfs_error_is_fatal(PTR_ERR(lseg))) {
+ 				pnfs_layout_clear_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));
+ 				lseg = NULL;
+ 			}
+ 			goto out_put_layout_hdr;
+ 		}
+ 		if (lseg) {
+ 			if (first)
+ 				pnfs_clear_first_layoutget(lo);
+ 			trace_pnfs_update_layout(ino, pos, count,
+ 				iomode, lo, lseg, PNFS_UPDATE_LAYOUT_RETRY);
+ 			pnfs_put_layout_hdr(lo);
+ 			goto lookup_again;
+ 		}
+ 	} else {
+ 		pnfs_layout_clear_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));
+ 	}
+ 
++>>>>>>> 66b53f325876 (pNFS: Handle NFS4ERR_RECALLCONFLICT correctly in LAYOUTGET)
  out_put_layout_hdr:
  	if (first)
  		pnfs_clear_first_layoutget(lo);
* Unmerged path fs/nfs/pnfs.c
