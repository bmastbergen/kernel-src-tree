RAID1: ignore discard error

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Shaohua Li <shli@fb.com>
commit e3f948cd3283e4fbe5907f1f3967c839912f480e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e3f948cd.failed

If a write error occurs, raid1 will try to rewrite the bio in small
chunk size. If the rewrite fails, raid1 will record the error in bad
block. narrow_write_error will always use WRITE for the bio, but
actually it could be a discard. Since discard bio hasn't payload, write
the bio will cause different issues. But discard error isn't fatal, we
can safely ignore it. This is what this patch does.

This issue should exist since discard is added, but only exposed with
recent arbitrary bio size feature.

Reported-and-tested-by: Sitsofe Wheeler <sitsofe@gmail.com>
	Cc: stable@vger.kernel.org (v3.6)
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit e3f948cd3283e4fbe5907f1f3967c839912f480e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid1.c
diff --cc drivers/md/raid1.c
index a6fac906a440,db536a68b2ee..000000000000
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@@ -398,24 -395,24 +398,38 @@@ static void r1_bio_write_done(struct r1
  	}
  }
  
 -static void raid1_end_write_request(struct bio *bio)
 +static void raid1_end_write_request(struct bio *bio, int error)
  {
 +	int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);
  	struct r1bio *r1_bio = bio->bi_private;
 -	int behind = test_bit(R1BIO_BehindIO, &r1_bio->state);
 +	int mirror, behind = test_bit(R1BIO_BehindIO, &r1_bio->state);
  	struct r1conf *conf = r1_bio->mddev->private;
  	struct bio *to_put = NULL;
++<<<<<<< HEAD
 +
 +	mirror = find_bio_disk(r1_bio, bio);
++=======
+ 	int mirror = find_bio_disk(r1_bio, bio);
+ 	struct md_rdev *rdev = conf->mirrors[mirror].rdev;
+ 	bool discard_error;
+ 
+ 	discard_error = bio->bi_error && bio_op(bio) == REQ_OP_DISCARD;
++>>>>>>> e3f948cd3283 (RAID1: ignore discard error)
  
  	/*
  	 * 'one mirror IO has finished' event handler:
  	 */
++<<<<<<< HEAD
 +	if (!uptodate) {
 +		set_bit(WriteErrorSeen,
 +			&conf->mirrors[mirror].rdev->flags);
 +		if (!test_and_set_bit(WantReplacement,
 +				      &conf->mirrors[mirror].rdev->flags))
++=======
+ 	if (bio->bi_error && !discard_error) {
+ 		set_bit(WriteErrorSeen,	&rdev->flags);
+ 		if (!test_and_set_bit(WantReplacement, &rdev->flags))
++>>>>>>> e3f948cd3283 (RAID1: ignore discard error)
  			set_bit(MD_RECOVERY_NEEDED, &
  				conf->mddev->recovery);
  
@@@ -449,9 -446,8 +463,14 @@@
  			set_bit(R1BIO_Uptodate, &r1_bio->state);
  
  		/* Maybe we can clear some bad blocks. */
++<<<<<<< HEAD
 +		if (is_badblock(conf->mirrors[mirror].rdev,
 +				r1_bio->sector, r1_bio->sectors,
 +				&first_bad, &bad_sectors)) {
++=======
+ 		if (is_badblock(rdev, r1_bio->sector, r1_bio->sectors,
+ 				&first_bad, &bad_sectors) && !discard_error) {
++>>>>>>> e3f948cd3283 (RAID1: ignore discard error)
  			r1_bio->bios[mirror] = IO_MADE_GOOD;
  			set_bit(R1BIO_MadeGood, &r1_bio->state);
  		}
* Unmerged path drivers/md/raid1.c
