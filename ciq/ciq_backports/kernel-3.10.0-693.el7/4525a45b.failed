net/mlx5e: Check ets capability before initializing ets settings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Check ets capability before initializing ets settings (Don Dutile) [1386547 1385330 1417286]
Rebuild_FUZZ: 96.77%
commit-author Huy Nguyen <huyn@mellanox.com>
commit 4525a45bfad55a00ef218c5fbe5d98a3d8170bf5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4525a45b.failed

During the initial setup, the ets command is sent to firmware
without checking if the HCA supports ets. This causes the invalid
command error. Add the ets capiblity check before sending firmware
command to initialize ets settings.

Fixes: e207b7e99176 ("net/mlx5e: ConnectX-4 firmware support for DCBX")
	Signed-off-by: Huy Nguyen <huyn@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4525a45bfad55a00ef218c5fbe5d98a3d8170bf5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
index 762af16ed021,f0b460f47f29..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
@@@ -313,4 -682,73 +313,59 @@@ const struct dcbnl_rtnl_ops mlx5e_dcbnl
  	.ieee_setpfc	= mlx5e_dcbnl_ieee_setpfc,
  	.getdcbx	= mlx5e_dcbnl_getdcbx,
  	.setdcbx	= mlx5e_dcbnl_setdcbx,
 -
 -/* CEE interfaces */
 -	.setall         = mlx5e_dcbnl_setall,
 -	.getstate       = mlx5e_dcbnl_getstate,
 -	.getpermhwaddr  = mlx5e_dcbnl_getpermhwaddr,
 -
 -	.setpgtccfgtx   = mlx5e_dcbnl_setpgtccfgtx,
 -	.setpgbwgcfgtx  = mlx5e_dcbnl_setpgbwgcfgtx,
 -	.getpgtccfgtx   = mlx5e_dcbnl_getpgtccfgtx,
 -	.getpgbwgcfgtx  = mlx5e_dcbnl_getpgbwgcfgtx,
 -
 -	.setpfccfg      = mlx5e_dcbnl_setpfccfg,
 -	.getpfccfg      = mlx5e_dcbnl_getpfccfg,
 -	.getcap         = mlx5e_dcbnl_getcap,
 -	.getnumtcs      = mlx5e_dcbnl_getnumtcs,
 -	.getpfcstate    = mlx5e_dcbnl_getpfcstate,
 -	.setpfcstate    = mlx5e_dcbnl_setpfcstate,
  };
++<<<<<<< HEAD
++=======
+ 
+ static void mlx5e_dcbnl_query_dcbx_mode(struct mlx5e_priv *priv,
+ 					enum mlx5_dcbx_oper_mode *mode)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(dcbx_param)];
+ 
+ 	*mode = MLX5E_DCBX_PARAM_VER_OPER_HOST;
+ 
+ 	if (!mlx5_query_port_dcbx_param(priv->mdev, out))
+ 		*mode = MLX5_GET(dcbx_param, out, version_oper);
+ 
+ 	/* From driver's point of view, we only care if the mode
+ 	 * is host (HOST) or non-host (AUTO)
+ 	 */
+ 	if (*mode != MLX5E_DCBX_PARAM_VER_OPER_HOST)
+ 		*mode = MLX5E_DCBX_PARAM_VER_OPER_AUTO;
+ }
+ 
+ static void mlx5e_ets_init(struct mlx5e_priv *priv)
+ {
+ 	int i;
+ 	struct ieee_ets ets;
+ 
+ 	if (!MLX5_CAP_GEN(priv->mdev, ets))
+ 		return;
+ 
+ 	memset(&ets, 0, sizeof(ets));
+ 	ets.ets_cap = mlx5_max_tc(priv->mdev) + 1;
+ 	for (i = 0; i < ets.ets_cap; i++) {
+ 		ets.tc_tx_bw[i] = MLX5E_MAX_BW_ALLOC;
+ 		ets.tc_tsa[i] = IEEE_8021QAZ_TSA_VENDOR;
+ 		ets.prio_tc[i] = i;
+ 	}
+ 
+ 	memcpy(priv->dcbx.tc_tsa, ets.tc_tsa, sizeof(ets.tc_tsa));
+ 
+ 	/* tclass[prio=0]=1, tclass[prio=1]=0, tclass[prio=i]=i (for i>1) */
+ 	ets.prio_tc[0] = 1;
+ 	ets.prio_tc[1] = 0;
+ 
+ 	mlx5e_dcbnl_ieee_setets_core(priv, &ets);
+ }
+ 
+ void mlx5e_dcbnl_initialize(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_dcbx *dcbx = &priv->dcbx;
+ 
+ 	if (MLX5_CAP_GEN(priv->mdev, dcbx))
+ 		mlx5e_dcbnl_query_dcbx_mode(priv, &dcbx->mode);
+ 
+ 	mlx5e_ets_init(priv);
+ }
++>>>>>>> 4525a45bfad5 (net/mlx5e: Check ets capability before initializing ets settings)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
