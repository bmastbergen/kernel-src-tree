x86/cpufeature: Cleanup get_cpu_cap()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] cpufeature: Cleanup get_cpu_cap() (David Arcari) [1389383]
Rebuild_FUZZ: 94.29%
commit-author Borislav Petkov <bp@suse.de>
commit 39c06df4dc10a41de5fe706f4378ee5f09beba73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/39c06df4.failed

Add an enum for the ->x86_capability array indices and cleanup
get_cpu_cap() by killing some redundant local vars.

	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: http://lkml.kernel.org/r/1449481182-27541-3-git-send-email-bp@alien8.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 39c06df4dc10a41de5fe706f4378ee5f09beba73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/cpufeature.h
#	arch/x86/kernel/cpu/common.c
diff --cc arch/x86/include/asm/cpufeature.h
index 9d2d987cf6d5,35401fef0d75..000000000000
--- a/arch/x86/include/asm/cpufeature.h
+++ b/arch/x86/include/asm/cpufeature.h
@@@ -273,8 -288,41 +273,32 @@@
  #include <asm/asm.h>
  #include <linux/bitops.h>
  
++<<<<<<< HEAD
++=======
+ enum cpuid_leafs
+ {
+ 	CPUID_1_EDX		= 0,
+ 	CPUID_8000_0001_EDX,
+ 	CPUID_8086_0001_EDX,
+ 	CPUID_LNX_1,
+ 	CPUID_1_ECX,
+ 	CPUID_C000_0001_EDX,
+ 	CPUID_8000_0001_ECX,
+ 	CPUID_LNX_2,
+ 	CPUID_LNX_3,
+ 	CPUID_7_0_EBX,
+ 	CPUID_D_1_EAX,
+ 	CPUID_F_0_EDX,
+ 	CPUID_F_1_EDX,
+ 	CPUID_8000_0008_EBX,
+ 	CPUID_6_EAX,
+ 	CPUID_8000_000A_EDX,
+ };
+ 
+ #ifdef CONFIG_X86_FEATURE_NAMES
++>>>>>>> 39c06df4dc10 (x86/cpufeature: Cleanup get_cpu_cap())
  extern const char * const x86_cap_flags[NCAPINTS*32];
  extern const char * const x86_power_flags[32];
 -#define X86_CAP_FMT "%s"
 -#define x86_cap_flag(flag) x86_cap_flags[flag]
 -#else
 -#define X86_CAP_FMT "%d:%d"
 -#define x86_cap_flag(flag) ((flag) >> 5), ((flag) & 31)
 -#endif
 -
 -/*
 - * In order to save room, we index into this array by doing
 - * X86_BUG_<name> - NCAPINTS*32.
 - */
 -extern const char * const x86_bug_flags[NBUGINTS*32];
  
  #define test_cpu_cap(c, bit)						\
  	 test_bit(bit, (unsigned long *)((c)->x86_capability))
diff --cc arch/x86/kernel/cpu/common.c
index d805b498a12b,e14d5bd8671f..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -653,11 -611,11 +651,15 @@@ void get_cpu_cap(struct cpuinfo_x86 *c
  
  	/* Additional Intel-defined flags: level 0x00000007 */
  	if (c->cpuid_level >= 0x00000007) {
- 		u32 eax, ebx, ecx, edx;
- 
  		cpuid_count(0x00000007, 0, &eax, &ebx, &ecx, &edx);
  
++<<<<<<< HEAD
 +		c->x86_capability[9] = ebx;
++=======
+ 		c->x86_capability[CPUID_7_0_EBX] = ebx;
+ 
+ 		c->x86_capability[CPUID_6_EAX] = cpuid_eax(0x00000006);
++>>>>>>> 39c06df4dc10 (x86/cpufeature: Cleanup get_cpu_cap())
  	}
  
  	/* Extended state features: level 0x0000000d */
@@@ -671,30 -627,26 +671,42 @@@
  
  	/* Additional Intel-defined flags: level 0x0000000F */
  	if (c->cpuid_level >= 0x0000000F) {
++<<<<<<< HEAD
 +		u32 eax, ebx, ecx, edx;
 +		struct rh_cpuinfo_x86 *rh_c =
 +			(c == &boot_cpu_data) ? &rh_boot_cpu_data
 +			: &rh_cpu_data(c->cpu_index);
++=======
++>>>>>>> 39c06df4dc10 (x86/cpufeature: Cleanup get_cpu_cap())
  
  		/* QoS sub-leaf, EAX=0Fh, ECX=0 */
  		cpuid_count(0x0000000F, 0, &eax, &ebx, &ecx, &edx);
- 		c->x86_capability[11] = edx;
+ 		c->x86_capability[CPUID_F_0_EDX] = edx;
+ 
  		if (cpu_has(c, X86_FEATURE_CQM_LLC)) {
  			/* will be overridden if occupancy monitoring exists */
 -			c->x86_cache_max_rmid = ebx;
 +			rh_c->x86_cache_max_rmid = ebx;
  
  			/* QoS sub-leaf, EAX=0Fh, ECX=1 */
  			cpuid_count(0x0000000F, 1, &eax, &ebx, &ecx, &edx);
++<<<<<<< HEAD
 +			c->x86_capability[12] = edx;
 +			if ((cpu_has(c, X86_FEATURE_CQM_OCCUP_LLC)) ||
 +			      ((cpu_has(c, X86_FEATURE_CQM_MBM_TOTAL)) ||
 +			       (cpu_has(c, X86_FEATURE_CQM_MBM_LOCAL)))) {
 +				rh_c->x86_cache_max_rmid = ecx;
 +				rh_c->x86_cache_occ_scale = ebx;
++=======
+ 			c->x86_capability[CPUID_F_1_EDX] = edx;
+ 
+ 			if (cpu_has(c, X86_FEATURE_CQM_OCCUP_LLC)) {
+ 				c->x86_cache_max_rmid = ecx;
+ 				c->x86_cache_occ_scale = ebx;
++>>>>>>> 39c06df4dc10 (x86/cpufeature: Cleanup get_cpu_cap())
  			}
  		} else {
 -			c->x86_cache_max_rmid = -1;
 -			c->x86_cache_occ_scale = -1;
 +			rh_c->x86_cache_max_rmid = -1;
 +			rh_c->x86_cache_occ_scale = -1;
  		}
  	}
  
@@@ -714,6 -668,7 +728,10 @@@
  
  		c->x86_virt_bits = (eax >> 8) & 0xff;
  		c->x86_phys_bits = eax & 0xff;
++<<<<<<< HEAD
++=======
+ 		c->x86_capability[CPUID_8000_0008_EBX] = ebx;
++>>>>>>> 39c06df4dc10 (x86/cpufeature: Cleanup get_cpu_cap())
  	}
  #ifdef CONFIG_X86_32
  	else if (cpu_has(c, X86_FEATURE_PAE) || cpu_has(c, X86_FEATURE_PSE36))
@@@ -723,6 -678,9 +741,12 @@@
  	if (c->extended_cpuid_level >= 0x80000007)
  		c->x86_power = cpuid_edx(0x80000007);
  
++<<<<<<< HEAD
++=======
+ 	if (c->extended_cpuid_level >= 0x8000000a)
+ 		c->x86_capability[CPUID_8000_000A_EDX] = cpuid_edx(0x8000000a);
+ 
++>>>>>>> 39c06df4dc10 (x86/cpufeature: Cleanup get_cpu_cap())
  	init_scattered_cpuid_features(c);
  }
  
* Unmerged path arch/x86/include/asm/cpufeature.h
diff --git a/arch/x86/kernel/cpu/centaur.c b/arch/x86/kernel/cpu/centaur.c
index f9ff97902eac..5049ea7a6f3b 100644
--- a/arch/x86/kernel/cpu/centaur.c
+++ b/arch/x86/kernel/cpu/centaur.c
@@ -43,7 +43,7 @@ static void init_c3(struct cpuinfo_x86 *c)
 		/* store Centaur Extended Feature Flags as
 		 * word 5 of the CPU capability bit array
 		 */
-		c->x86_capability[5] = cpuid_edx(0xC0000001);
+		c->x86_capability[CPUID_C000_0001_EDX] = cpuid_edx(0xC0000001);
 	}
 #ifdef CONFIG_X86_32
 	/* Cyrix III family needs CX8 & PGE explicitly enabled. */
* Unmerged path arch/x86/kernel/cpu/common.c
diff --git a/arch/x86/kernel/cpu/transmeta.c b/arch/x86/kernel/cpu/transmeta.c
index 3fa0e5ad86b4..252da7aceca6 100644
--- a/arch/x86/kernel/cpu/transmeta.c
+++ b/arch/x86/kernel/cpu/transmeta.c
@@ -12,7 +12,7 @@ static void early_init_transmeta(struct cpuinfo_x86 *c)
 	xlvl = cpuid_eax(0x80860000);
 	if ((xlvl & 0xffff0000) == 0x80860000) {
 		if (xlvl >= 0x80860001)
-			c->x86_capability[2] = cpuid_edx(0x80860001);
+			c->x86_capability[CPUID_8086_0001_EDX] = cpuid_edx(0x80860001);
 	}
 }
 
@@ -82,7 +82,7 @@ static void init_transmeta(struct cpuinfo_x86 *c)
 	/* Unhide possibly hidden capability flags */
 	rdmsr(0x80860004, cap_mask, uk);
 	wrmsr(0x80860004, ~0, uk);
-	c->x86_capability[0] = cpuid_edx(0x00000001);
+	c->x86_capability[CPUID_1_EDX] = cpuid_edx(0x00000001);
 	wrmsr(0x80860004, cap_mask, uk);
 
 	/* All Transmeta CPUs have a constant TSC */
