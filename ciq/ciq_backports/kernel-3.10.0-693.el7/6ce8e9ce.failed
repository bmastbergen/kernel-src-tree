new helper: memcpy_from_msg()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] new helper memcpy_from_msg() (Neil Horman) [1364038]
Rebuild_FUZZ: 98.25%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 6ce8e9ce5989ae13f493062975304700be86d20e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6ce8e9ce.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 6ce8e9ce5989ae13f493062975304700be86d20e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/mgmt.c
#	net/ieee802154/dgram.c
#	net/ieee802154/raw.c
#	net/ipv4/ping.c
diff --cc net/bluetooth/mgmt.c
index 9e4b931588cf,f3e4a16fb157..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -5501,769 -5682,179 +5501,775 @@@ unlock
  	return err;
  }
  
 -static const struct mgmt_handler {
 -	int (*func) (struct sock *sk, struct hci_dev *hdev, void *data,
 -		     u16 data_len);
 -	bool var_len;
 -	size_t data_len;
 -} mgmt_handlers[] = {
 -	{ NULL }, /* 0x0000 (no command) */
 -	{ read_version,           false, MGMT_READ_VERSION_SIZE },
 -	{ read_commands,          false, MGMT_READ_COMMANDS_SIZE },
 -	{ read_index_list,        false, MGMT_READ_INDEX_LIST_SIZE },
 -	{ read_controller_info,   false, MGMT_READ_INFO_SIZE },
 -	{ set_powered,            false, MGMT_SETTING_SIZE },
 -	{ set_discoverable,       false, MGMT_SET_DISCOVERABLE_SIZE },
 -	{ set_connectable,        false, MGMT_SETTING_SIZE },
 -	{ set_fast_connectable,   false, MGMT_SETTING_SIZE },
 -	{ set_bondable,           false, MGMT_SETTING_SIZE },
 -	{ set_link_security,      false, MGMT_SETTING_SIZE },
 -	{ set_ssp,                false, MGMT_SETTING_SIZE },
 -	{ set_hs,                 false, MGMT_SETTING_SIZE },
 -	{ set_le,                 false, MGMT_SETTING_SIZE },
 -	{ set_dev_class,          false, MGMT_SET_DEV_CLASS_SIZE },
 -	{ set_local_name,         false, MGMT_SET_LOCAL_NAME_SIZE },
 -	{ add_uuid,               false, MGMT_ADD_UUID_SIZE },
 -	{ remove_uuid,            false, MGMT_REMOVE_UUID_SIZE },
 -	{ load_link_keys,         true,  MGMT_LOAD_LINK_KEYS_SIZE },
 -	{ load_long_term_keys,    true,  MGMT_LOAD_LONG_TERM_KEYS_SIZE },
 -	{ disconnect,             false, MGMT_DISCONNECT_SIZE },
 -	{ get_connections,        false, MGMT_GET_CONNECTIONS_SIZE },
 -	{ pin_code_reply,         false, MGMT_PIN_CODE_REPLY_SIZE },
 -	{ pin_code_neg_reply,     false, MGMT_PIN_CODE_NEG_REPLY_SIZE },
 -	{ set_io_capability,      false, MGMT_SET_IO_CAPABILITY_SIZE },
 -	{ pair_device,            false, MGMT_PAIR_DEVICE_SIZE },
 -	{ cancel_pair_device,     false, MGMT_CANCEL_PAIR_DEVICE_SIZE },
 -	{ unpair_device,          false, MGMT_UNPAIR_DEVICE_SIZE },
 -	{ user_confirm_reply,     false, MGMT_USER_CONFIRM_REPLY_SIZE },
 -	{ user_confirm_neg_reply, false, MGMT_USER_CONFIRM_NEG_REPLY_SIZE },
 -	{ user_passkey_reply,     false, MGMT_USER_PASSKEY_REPLY_SIZE },
 -	{ user_passkey_neg_reply, false, MGMT_USER_PASSKEY_NEG_REPLY_SIZE },
 -	{ read_local_oob_data,    false, MGMT_READ_LOCAL_OOB_DATA_SIZE },
 -	{ add_remote_oob_data,    true,  MGMT_ADD_REMOTE_OOB_DATA_SIZE },
 -	{ remove_remote_oob_data, false, MGMT_REMOVE_REMOTE_OOB_DATA_SIZE },
 -	{ start_discovery,        false, MGMT_START_DISCOVERY_SIZE },
 -	{ stop_discovery,         false, MGMT_STOP_DISCOVERY_SIZE },
 -	{ confirm_name,           false, MGMT_CONFIRM_NAME_SIZE },
 -	{ block_device,           false, MGMT_BLOCK_DEVICE_SIZE },
 -	{ unblock_device,         false, MGMT_UNBLOCK_DEVICE_SIZE },
 -	{ set_device_id,          false, MGMT_SET_DEVICE_ID_SIZE },
 -	{ set_advertising,        false, MGMT_SETTING_SIZE },
 -	{ set_bredr,              false, MGMT_SETTING_SIZE },
 -	{ set_static_address,     false, MGMT_SET_STATIC_ADDRESS_SIZE },
 -	{ set_scan_params,        false, MGMT_SET_SCAN_PARAMS_SIZE },
 -	{ set_secure_conn,        false, MGMT_SETTING_SIZE },
 -	{ set_debug_keys,         false, MGMT_SETTING_SIZE },
 -	{ set_privacy,            false, MGMT_SET_PRIVACY_SIZE },
 -	{ load_irks,              true,  MGMT_LOAD_IRKS_SIZE },
 -	{ get_conn_info,          false, MGMT_GET_CONN_INFO_SIZE },
 -	{ get_clock_info,         false, MGMT_GET_CLOCK_INFO_SIZE },
 -	{ add_device,             false, MGMT_ADD_DEVICE_SIZE },
 -	{ remove_device,          false, MGMT_REMOVE_DEVICE_SIZE },
 -	{ load_conn_param,        true,  MGMT_LOAD_CONN_PARAM_SIZE },
 -	{ read_unconf_index_list, false, MGMT_READ_UNCONF_INDEX_LIST_SIZE },
 -	{ read_config_info,       false, MGMT_READ_CONFIG_INFO_SIZE },
 -	{ set_external_config,    false, MGMT_SET_EXTERNAL_CONFIG_SIZE },
 -	{ set_public_address,     false, MGMT_SET_PUBLIC_ADDRESS_SIZE },
 -};
 +static inline u16 eir_append_data(u8 *eir, u16 eir_len, u8 type, u8 *data,
 +				  u8 data_len)
 +{
 +	eir[eir_len++] = sizeof(type) + data_len;
 +	eir[eir_len++] = type;
 +	memcpy(&eir[eir_len], data, data_len);
 +	eir_len += data_len;
 +
 +	return eir_len;
 +}
  
 -int mgmt_control(struct sock *sk, struct msghdr *msg, size_t msglen)
 +static void read_local_oob_ext_data_complete(struct hci_dev *hdev, u8 status,
 +					     u16 opcode, struct sk_buff *skb)
  {
 -	void *buf;
 -	u8 *cp;
 -	struct mgmt_hdr *hdr;
 -	u16 opcode, index, len;
 -	struct hci_dev *hdev = NULL;
 -	const struct mgmt_handler *handler;
 +	const struct mgmt_cp_read_local_oob_ext_data *mgmt_cp;
 +	struct mgmt_rp_read_local_oob_ext_data *mgmt_rp;
 +	u8 *h192, *r192, *h256, *r256;
 +	struct mgmt_pending_cmd *cmd;
 +	u16 eir_len;
  	int err;
  
 -	BT_DBG("got %zu bytes", msglen);
 +	BT_DBG("%s status %u", hdev->name, status);
  
 -	if (msglen < sizeof(*hdr))
 -		return -EINVAL;
 +	cmd = pending_find(MGMT_OP_READ_LOCAL_OOB_EXT_DATA, hdev);
 +	if (!cmd)
 +		return;
 +
 +	mgmt_cp = cmd->param;
  
 -	buf = kmalloc(msglen, GFP_KERNEL);
 -	if (!buf)
 +	if (status) {
 +		status = mgmt_status(status);
 +		eir_len = 0;
 +
 +		h192 = NULL;
 +		r192 = NULL;
 +		h256 = NULL;
 +		r256 = NULL;
 +	} else if (opcode == HCI_OP_READ_LOCAL_OOB_DATA) {
 +		struct hci_rp_read_local_oob_data *rp;
 +
 +		if (skb->len != sizeof(*rp)) {
 +			status = MGMT_STATUS_FAILED;
 +			eir_len = 0;
 +		} else {
 +			status = MGMT_STATUS_SUCCESS;
 +			rp = (void *)skb->data;
 +
 +			eir_len = 5 + 18 + 18;
 +			h192 = rp->hash;
 +			r192 = rp->rand;
 +			h256 = NULL;
 +			r256 = NULL;
 +		}
 +	} else {
 +		struct hci_rp_read_local_oob_ext_data *rp;
 +
 +		if (skb->len != sizeof(*rp)) {
 +			status = MGMT_STATUS_FAILED;
 +			eir_len = 0;
 +		} else {
 +			status = MGMT_STATUS_SUCCESS;
 +			rp = (void *)skb->data;
 +
 +			if (hci_dev_test_flag(hdev, HCI_SC_ONLY)) {
 +				eir_len = 5 + 18 + 18;
 +				h192 = NULL;
 +				r192 = NULL;
 +			} else {
 +				eir_len = 5 + 18 + 18 + 18 + 18;
 +				h192 = rp->hash192;
 +				r192 = rp->rand192;
 +			}
 +
 +			h256 = rp->hash256;
 +			r256 = rp->rand256;
 +		}
 +	}
 +
 +	mgmt_rp = kmalloc(sizeof(*mgmt_rp) + eir_len, GFP_KERNEL);
 +	if (!mgmt_rp)
 +		goto done;
 +
 +	if (status)
 +		goto send_rsp;
 +
 +	eir_len = eir_append_data(mgmt_rp->eir, 0, EIR_CLASS_OF_DEV,
 +				  hdev->dev_class, 3);
 +
 +	if (h192 && r192) {
 +		eir_len = eir_append_data(mgmt_rp->eir, eir_len,
 +					  EIR_SSP_HASH_C192, h192, 16);
 +		eir_len = eir_append_data(mgmt_rp->eir, eir_len,
 +					  EIR_SSP_RAND_R192, r192, 16);
 +	}
 +
 +	if (h256 && r256) {
 +		eir_len = eir_append_data(mgmt_rp->eir, eir_len,
 +					  EIR_SSP_HASH_C256, h256, 16);
 +		eir_len = eir_append_data(mgmt_rp->eir, eir_len,
 +					  EIR_SSP_RAND_R256, r256, 16);
 +	}
 +
 +send_rsp:
 +	mgmt_rp->type = mgmt_cp->type;
 +	mgmt_rp->eir_len = cpu_to_le16(eir_len);
 +
 +	err = mgmt_cmd_complete(cmd->sk, hdev->id,
 +				MGMT_OP_READ_LOCAL_OOB_EXT_DATA, status,
 +				mgmt_rp, sizeof(*mgmt_rp) + eir_len);
 +	if (err < 0 || status)
 +		goto done;
 +
 +	hci_sock_set_flag(cmd->sk, HCI_MGMT_OOB_DATA_EVENTS);
 +
 +	err = mgmt_limited_event(MGMT_EV_LOCAL_OOB_DATA_UPDATED, hdev,
 +				 mgmt_rp, sizeof(*mgmt_rp) + eir_len,
 +				 HCI_MGMT_OOB_DATA_EVENTS, cmd->sk);
 +done:
 +	kfree(mgmt_rp);
 +	mgmt_pending_remove(cmd);
 +}
 +
 +static int read_local_ssp_oob_req(struct hci_dev *hdev, struct sock *sk,
 +				  struct mgmt_cp_read_local_oob_ext_data *cp)
 +{
 +	struct mgmt_pending_cmd *cmd;
 +	struct hci_request req;
 +	int err;
 +
 +	cmd = mgmt_pending_add(sk, MGMT_OP_READ_LOCAL_OOB_EXT_DATA, hdev,
 +			       cp, sizeof(*cp));
 +	if (!cmd)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	hci_req_init(&req, hdev);
 +
 +	if (bredr_sc_enabled(hdev))
 +		hci_req_add(&req, HCI_OP_READ_LOCAL_OOB_EXT_DATA, 0, NULL);
 +	else
 +		hci_req_add(&req, HCI_OP_READ_LOCAL_OOB_DATA, 0, NULL);
 +
 +	err = hci_req_run_skb(&req, read_local_oob_ext_data_complete);
 +	if (err < 0) {
 +		mgmt_pending_remove(cmd);
 +		return err;
++=======
+ 	if (memcpy_from_msg(buf, msg, msglen)) {
+ 		err = -EFAULT;
+ 		goto done;
++>>>>>>> 6ce8e9ce5989 (new helper: memcpy_from_msg())
 +	}
 +
 +	return 0;
 +}
 +
 +static int read_local_oob_ext_data(struct sock *sk, struct hci_dev *hdev,
 +				   void *data, u16 data_len)
 +{
 +	struct mgmt_cp_read_local_oob_ext_data *cp = data;
 +	struct mgmt_rp_read_local_oob_ext_data *rp;
 +	size_t rp_len;
 +	u16 eir_len;
 +	u8 status, flags, role, addr[7], hash[16], rand[16];
 +	int err;
 +
 +	BT_DBG("%s", hdev->name);
 +
 +	if (hdev_is_powered(hdev)) {
 +		switch (cp->type) {
 +		case BIT(BDADDR_BREDR):
 +			status = mgmt_bredr_support(hdev);
 +			if (status)
 +				eir_len = 0;
 +			else
 +				eir_len = 5;
 +			break;
 +		case (BIT(BDADDR_LE_PUBLIC) | BIT(BDADDR_LE_RANDOM)):
 +			status = mgmt_le_support(hdev);
 +			if (status)
 +				eir_len = 0;
 +			else
 +				eir_len = 9 + 3 + 18 + 18 + 3;
 +			break;
 +		default:
 +			status = MGMT_STATUS_INVALID_PARAMS;
 +			eir_len = 0;
 +			break;
 +		}
 +	} else {
 +		status = MGMT_STATUS_NOT_POWERED;
 +		eir_len = 0;
 +	}
 +
 +	rp_len = sizeof(*rp) + eir_len;
 +	rp = kmalloc(rp_len, GFP_ATOMIC);
 +	if (!rp)
 +		return -ENOMEM;
 +
 +	if (status)
 +		goto complete;
 +
 +	hci_dev_lock(hdev);
 +
 +	eir_len = 0;
 +	switch (cp->type) {
 +	case BIT(BDADDR_BREDR):
 +		if (hci_dev_test_flag(hdev, HCI_SSP_ENABLED)) {
 +			err = read_local_ssp_oob_req(hdev, sk, cp);
 +			hci_dev_unlock(hdev);
 +			if (!err)
 +				goto done;
 +
 +			status = MGMT_STATUS_FAILED;
 +			goto complete;
 +		} else {
 +			eir_len = eir_append_data(rp->eir, eir_len,
 +						  EIR_CLASS_OF_DEV,
 +						  hdev->dev_class, 3);
 +		}
 +		break;
 +	case (BIT(BDADDR_LE_PUBLIC) | BIT(BDADDR_LE_RANDOM)):
 +		if (hci_dev_test_flag(hdev, HCI_SC_ENABLED) &&
 +		    smp_generate_oob(hdev, hash, rand) < 0) {
 +			hci_dev_unlock(hdev);
 +			status = MGMT_STATUS_FAILED;
 +			goto complete;
 +		}
 +
 +		/* This should return the active RPA, but since the RPA
 +		 * is only programmed on demand, it is really hard to fill
 +		 * this in at the moment. For now disallow retrieving
 +		 * local out-of-band data when privacy is in use.
 +		 *
 +		 * Returning the identity address will not help here since
 +		 * pairing happens before the identity resolving key is
 +		 * known and thus the connection establishment happens
 +		 * based on the RPA and not the identity address.
 +		 */
 +		if (hci_dev_test_flag(hdev, HCI_PRIVACY)) {
 +			hci_dev_unlock(hdev);
 +			status = MGMT_STATUS_REJECTED;
 +			goto complete;
 +		}
 +
 +		if (hci_dev_test_flag(hdev, HCI_FORCE_STATIC_ADDR) ||
 +		   !bacmp(&hdev->bdaddr, BDADDR_ANY) ||
 +		   (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED) &&
 +		    bacmp(&hdev->static_addr, BDADDR_ANY))) {
 +			memcpy(addr, &hdev->static_addr, 6);
 +			addr[6] = 0x01;
 +		} else {
 +			memcpy(addr, &hdev->bdaddr, 6);
 +			addr[6] = 0x00;
 +		}
 +
 +		eir_len = eir_append_data(rp->eir, eir_len, EIR_LE_BDADDR,
 +					  addr, sizeof(addr));
 +
 +		if (hci_dev_test_flag(hdev, HCI_ADVERTISING))
 +			role = 0x02;
 +		else
 +			role = 0x01;
 +
 +		eir_len = eir_append_data(rp->eir, eir_len, EIR_LE_ROLE,
 +					  &role, sizeof(role));
 +
 +		if (hci_dev_test_flag(hdev, HCI_SC_ENABLED)) {
 +			eir_len = eir_append_data(rp->eir, eir_len,
 +						  EIR_LE_SC_CONFIRM,
 +						  hash, sizeof(hash));
 +
 +			eir_len = eir_append_data(rp->eir, eir_len,
 +						  EIR_LE_SC_RANDOM,
 +						  rand, sizeof(rand));
 +		}
 +
 +		flags = mgmt_get_adv_discov_flags(hdev);
 +
 +		if (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED))
 +			flags |= LE_AD_NO_BREDR;
 +
 +		eir_len = eir_append_data(rp->eir, eir_len, EIR_FLAGS,
 +					  &flags, sizeof(flags));
 +		break;
 +	}
 +
 +	hci_dev_unlock(hdev);
 +
 +	hci_sock_set_flag(sk, HCI_MGMT_OOB_DATA_EVENTS);
 +
 +	status = MGMT_STATUS_SUCCESS;
 +
 +complete:
 +	rp->type = cp->type;
 +	rp->eir_len = cpu_to_le16(eir_len);
 +
 +	err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_EXT_DATA,
 +				status, rp, sizeof(*rp) + eir_len);
 +	if (err < 0 || status)
 +		goto done;
 +
 +	err = mgmt_limited_event(MGMT_EV_LOCAL_OOB_DATA_UPDATED, hdev,
 +				 rp, sizeof(*rp) + eir_len,
 +				 HCI_MGMT_OOB_DATA_EVENTS, sk);
 +
 +done:
 +	kfree(rp);
 +
 +	return err;
 +}
 +
 +static u32 get_supported_adv_flags(struct hci_dev *hdev)
 +{
 +	u32 flags = 0;
 +
 +	flags |= MGMT_ADV_FLAG_CONNECTABLE;
 +	flags |= MGMT_ADV_FLAG_DISCOV;
 +	flags |= MGMT_ADV_FLAG_LIMITED_DISCOV;
 +	flags |= MGMT_ADV_FLAG_MANAGED_FLAGS;
 +
 +	if (hdev->adv_tx_power != HCI_TX_POWER_INVALID)
 +		flags |= MGMT_ADV_FLAG_TX_POWER;
 +
 +	return flags;
 +}
 +
 +static int read_adv_features(struct sock *sk, struct hci_dev *hdev,
 +			     void *data, u16 data_len)
 +{
 +	struct mgmt_rp_read_adv_features *rp;
 +	size_t rp_len;
 +	int err;
 +	struct adv_info *adv_instance;
 +	u32 supported_flags;
 +	u8 *instance;
 +
 +	BT_DBG("%s", hdev->name);
 +
 +	if (!lmp_le_capable(hdev))
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_READ_ADV_FEATURES,
 +				       MGMT_STATUS_REJECTED);
 +
 +	hci_dev_lock(hdev);
 +
 +	rp_len = sizeof(*rp) + hdev->adv_instance_cnt;
 +	rp = kmalloc(rp_len, GFP_ATOMIC);
 +	if (!rp) {
 +		hci_dev_unlock(hdev);
 +		return -ENOMEM;
 +	}
 +
 +	supported_flags = get_supported_adv_flags(hdev);
 +
 +	rp->supported_flags = cpu_to_le32(supported_flags);
 +	rp->max_adv_data_len = HCI_MAX_AD_LENGTH;
 +	rp->max_scan_rsp_len = HCI_MAX_AD_LENGTH;
 +	rp->max_instances = HCI_MAX_ADV_INSTANCES;
 +	rp->num_instances = hdev->adv_instance_cnt;
 +
 +	instance = rp->instance;
 +	list_for_each_entry(adv_instance, &hdev->adv_instances, list) {
 +		*instance = adv_instance->instance;
 +		instance++;
 +	}
 +
 +	hci_dev_unlock(hdev);
 +
 +	err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_ADV_FEATURES,
 +				MGMT_STATUS_SUCCESS, rp, rp_len);
 +
 +	kfree(rp);
 +
 +	return err;
 +}
 +
 +static bool tlv_data_is_valid(struct hci_dev *hdev, u32 adv_flags, u8 *data,
 +			      u8 len, bool is_adv_data)
 +{
 +	u8 max_len = HCI_MAX_AD_LENGTH;
 +	int i, cur_len;
 +	bool flags_managed = false;
 +	bool tx_power_managed = false;
 +
 +	if (is_adv_data) {
 +		if (adv_flags & (MGMT_ADV_FLAG_DISCOV |
 +				 MGMT_ADV_FLAG_LIMITED_DISCOV |
 +				 MGMT_ADV_FLAG_MANAGED_FLAGS)) {
 +			flags_managed = true;
 +			max_len -= 3;
 +		}
 +
 +		if (adv_flags & MGMT_ADV_FLAG_TX_POWER) {
 +			tx_power_managed = true;
 +			max_len -= 3;
 +		}
 +	}
 +
 +	if (len > max_len)
 +		return false;
 +
 +	/* Make sure that the data is correctly formatted. */
 +	for (i = 0, cur_len = 0; i < len; i += (cur_len + 1)) {
 +		cur_len = data[i];
 +
 +		if (flags_managed && data[i + 1] == EIR_FLAGS)
 +			return false;
 +
 +		if (tx_power_managed && data[i + 1] == EIR_TX_POWER)
 +			return false;
 +
 +		/* If the current field length would exceed the total data
 +		 * length, then it's invalid.
 +		 */
 +		if (i + cur_len >= len)
 +			return false;
 +	}
 +
 +	return true;
 +}
 +
 +static void add_advertising_complete(struct hci_dev *hdev, u8 status,
 +				     u16 opcode)
 +{
 +	struct mgmt_pending_cmd *cmd;
 +	struct mgmt_cp_add_advertising *cp;
 +	struct mgmt_rp_add_advertising rp;
 +	struct adv_info *adv_instance, *n;
 +	u8 instance;
 +
 +	BT_DBG("status %d", status);
 +
 +	hci_dev_lock(hdev);
 +
 +	cmd = pending_find(MGMT_OP_ADD_ADVERTISING, hdev);
 +
 +	list_for_each_entry_safe(adv_instance, n, &hdev->adv_instances, list) {
 +		if (!adv_instance->pending)
 +			continue;
 +
 +		if (!status) {
 +			adv_instance->pending = false;
 +			continue;
 +		}
 +
 +		instance = adv_instance->instance;
 +
 +		if (hdev->cur_adv_instance == instance)
 +			cancel_adv_timeout(hdev);
 +
 +		hci_remove_adv_instance(hdev, instance);
 +		mgmt_advertising_removed(cmd ? cmd->sk : NULL, hdev, instance);
 +	}
 +
 +	if (!cmd)
 +		goto unlock;
 +
 +	cp = cmd->param;
 +	rp.instance = cp->instance;
 +
 +	if (status)
 +		mgmt_cmd_status(cmd->sk, cmd->index, cmd->opcode,
 +				mgmt_status(status));
 +	else
 +		mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode,
 +				  mgmt_status(status), &rp, sizeof(rp));
 +
 +	mgmt_pending_remove(cmd);
 +
 +unlock:
 +	hci_dev_unlock(hdev);
 +}
 +
 +static int add_advertising(struct sock *sk, struct hci_dev *hdev,
 +			   void *data, u16 data_len)
 +{
 +	struct mgmt_cp_add_advertising *cp = data;
 +	struct mgmt_rp_add_advertising rp;
 +	u32 flags;
 +	u32 supported_flags;
 +	u8 status;
 +	u16 timeout, duration;
 +	unsigned int prev_instance_cnt = hdev->adv_instance_cnt;
 +	u8 schedule_instance = 0;
 +	struct adv_info *next_instance;
 +	int err;
 +	struct mgmt_pending_cmd *cmd;
 +	struct hci_request req;
 +
 +	BT_DBG("%s", hdev->name);
 +
 +	status = mgmt_le_support(hdev);
 +	if (status)
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
 +				       status);
 +
 +	if (cp->instance < 1 || cp->instance > HCI_MAX_ADV_INSTANCES)
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
 +				       MGMT_STATUS_INVALID_PARAMS);
 +
 +	if (data_len != sizeof(*cp) + cp->adv_data_len + cp->scan_rsp_len)
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
 +				       MGMT_STATUS_INVALID_PARAMS);
 +
 +	flags = __le32_to_cpu(cp->flags);
 +	timeout = __le16_to_cpu(cp->timeout);
 +	duration = __le16_to_cpu(cp->duration);
 +
 +	/* The current implementation only supports a subset of the specified
 +	 * flags.
 +	 */
 +	supported_flags = get_supported_adv_flags(hdev);
 +	if (flags & ~supported_flags)
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
 +				       MGMT_STATUS_INVALID_PARAMS);
 +
 +	hci_dev_lock(hdev);
 +
 +	if (timeout && !hdev_is_powered(hdev)) {
 +		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
 +				      MGMT_STATUS_REJECTED);
 +		goto unlock;
 +	}
 +
 +	if (pending_find(MGMT_OP_ADD_ADVERTISING, hdev) ||
 +	    pending_find(MGMT_OP_REMOVE_ADVERTISING, hdev) ||
 +	    pending_find(MGMT_OP_SET_LE, hdev)) {
 +		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
 +				      MGMT_STATUS_BUSY);
 +		goto unlock;
 +	}
 +
 +	if (!tlv_data_is_valid(hdev, flags, cp->data, cp->adv_data_len, true) ||
 +	    !tlv_data_is_valid(hdev, flags, cp->data + cp->adv_data_len,
 +			       cp->scan_rsp_len, false)) {
 +		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
 +				      MGMT_STATUS_INVALID_PARAMS);
 +		goto unlock;
 +	}
 +
 +	err = hci_add_adv_instance(hdev, cp->instance, flags,
 +				   cp->adv_data_len, cp->data,
 +				   cp->scan_rsp_len,
 +				   cp->data + cp->adv_data_len,
 +				   timeout, duration);
 +	if (err < 0) {
 +		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
 +				      MGMT_STATUS_FAILED);
 +		goto unlock;
 +	}
 +
 +	/* Only trigger an advertising added event if a new instance was
 +	 * actually added.
 +	 */
 +	if (hdev->adv_instance_cnt > prev_instance_cnt)
 +		mgmt_advertising_added(sk, hdev, cp->instance);
 +
 +	if (hdev->cur_adv_instance == cp->instance) {
 +		/* If the currently advertised instance is being changed then
 +		 * cancel the current advertising and schedule the next
 +		 * instance. If there is only one instance then the overridden
 +		 * advertising data will be visible right away.
 +		 */
 +		cancel_adv_timeout(hdev);
 +
 +		next_instance = hci_get_next_instance(hdev, cp->instance);
 +		if (next_instance)
 +			schedule_instance = next_instance->instance;
 +	} else if (!hdev->adv_instance_timeout) {
 +		/* Immediately advertise the new instance if no other
 +		 * instance is currently being advertised.
 +		 */
 +		schedule_instance = cp->instance;
 +	}
 +
 +	/* If the HCI_ADVERTISING flag is set or the device isn't powered or
 +	 * there is no instance to be advertised then we have no HCI
 +	 * communication to make. Simply return.
 +	 */
 +	if (!hdev_is_powered(hdev) ||
 +	    hci_dev_test_flag(hdev, HCI_ADVERTISING) ||
 +	    !schedule_instance) {
 +		rp.instance = cp->instance;
 +		err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_ADVERTISING,
 +					MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
 +		goto unlock;
 +	}
 +
 +	/* We're good to go, update advertising data, parameters, and start
 +	 * advertising.
 +	 */
 +	cmd = mgmt_pending_add(sk, MGMT_OP_ADD_ADVERTISING, hdev, data,
 +			       data_len);
 +	if (!cmd) {
 +		err = -ENOMEM;
 +		goto unlock;
 +	}
 +
 +	hci_req_init(&req, hdev);
 +
 +	err = __hci_req_schedule_adv_instance(&req, schedule_instance, true);
 +
 +	if (!err)
 +		err = hci_req_run(&req, add_advertising_complete);
 +
 +	if (err < 0)
 +		mgmt_pending_remove(cmd);
 +
 +unlock:
 +	hci_dev_unlock(hdev);
 +
 +	return err;
 +}
 +
 +static void remove_advertising_complete(struct hci_dev *hdev, u8 status,
 +					u16 opcode)
 +{
 +	struct mgmt_pending_cmd *cmd;
 +	struct mgmt_cp_remove_advertising *cp;
 +	struct mgmt_rp_remove_advertising rp;
 +
 +	BT_DBG("status %d", status);
 +
 +	hci_dev_lock(hdev);
 +
 +	/* A failure status here only means that we failed to disable
 +	 * advertising. Otherwise, the advertising instance has been removed,
 +	 * so report success.
 +	 */
 +	cmd = pending_find(MGMT_OP_REMOVE_ADVERTISING, hdev);
 +	if (!cmd)
 +		goto unlock;
 +
 +	cp = cmd->param;
 +	rp.instance = cp->instance;
 +
 +	mgmt_cmd_complete(cmd->sk, cmd->index, cmd->opcode, MGMT_STATUS_SUCCESS,
 +			  &rp, sizeof(rp));
 +	mgmt_pending_remove(cmd);
 +
 +unlock:
 +	hci_dev_unlock(hdev);
 +}
 +
 +static int remove_advertising(struct sock *sk, struct hci_dev *hdev,
 +			      void *data, u16 data_len)
 +{
 +	struct mgmt_cp_remove_advertising *cp = data;
 +	struct mgmt_rp_remove_advertising rp;
 +	struct mgmt_pending_cmd *cmd;
 +	struct hci_request req;
 +	int err;
 +
 +	BT_DBG("%s", hdev->name);
 +
 +	hci_dev_lock(hdev);
 +
 +	if (cp->instance && !hci_find_adv_instance(hdev, cp->instance)) {
 +		err = mgmt_cmd_status(sk, hdev->id,
 +				      MGMT_OP_REMOVE_ADVERTISING,
 +				      MGMT_STATUS_INVALID_PARAMS);
 +		goto unlock;
 +	}
 +
 +	if (pending_find(MGMT_OP_ADD_ADVERTISING, hdev) ||
 +	    pending_find(MGMT_OP_REMOVE_ADVERTISING, hdev) ||
 +	    pending_find(MGMT_OP_SET_LE, hdev)) {
 +		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADVERTISING,
 +				      MGMT_STATUS_BUSY);
 +		goto unlock;
 +	}
 +
 +	if (list_empty(&hdev->adv_instances)) {
 +		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADVERTISING,
 +				      MGMT_STATUS_INVALID_PARAMS);
 +		goto unlock;
 +	}
 +
 +	hci_req_init(&req, hdev);
 +
 +	hci_req_clear_adv_instance(hdev, &req, cp->instance, true);
 +
 +	if (list_empty(&hdev->adv_instances))
 +		__hci_req_disable_advertising(&req);
 +
 +	/* If no HCI commands have been collected so far or the HCI_ADVERTISING
 +	 * flag is set or the device isn't powered then we have no HCI
 +	 * communication to make. Simply return.
 +	 */
 +	if (skb_queue_empty(&req.cmd_q) ||
 +	    !hdev_is_powered(hdev) ||
 +	    hci_dev_test_flag(hdev, HCI_ADVERTISING)) {
 +		rp.instance = cp->instance;
 +		err = mgmt_cmd_complete(sk, hdev->id,
 +					MGMT_OP_REMOVE_ADVERTISING,
 +					MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
 +		goto unlock;
  	}
  
 -	hdr = buf;
 -	opcode = __le16_to_cpu(hdr->opcode);
 -	index = __le16_to_cpu(hdr->index);
 -	len = __le16_to_cpu(hdr->len);
 -
 -	if (len != msglen - sizeof(*hdr)) {
 -		err = -EINVAL;
 -		goto done;
 +	cmd = mgmt_pending_add(sk, MGMT_OP_REMOVE_ADVERTISING, hdev, data,
 +			       data_len);
 +	if (!cmd) {
 +		err = -ENOMEM;
 +		goto unlock;
  	}
  
 -	if (index != MGMT_INDEX_NONE) {
 -		hdev = hci_dev_get(index);
 -		if (!hdev) {
 -			err = cmd_status(sk, index, opcode,
 -					 MGMT_STATUS_INVALID_INDEX);
 -			goto done;
 -		}
 +	err = hci_req_run(&req, remove_advertising_complete);
 +	if (err < 0)
 +		mgmt_pending_remove(cmd);
  
 -		if (test_bit(HCI_SETUP, &hdev->dev_flags) ||
 -		    test_bit(HCI_CONFIG, &hdev->dev_flags) ||
 -		    test_bit(HCI_USER_CHANNEL, &hdev->dev_flags)) {
 -			err = cmd_status(sk, index, opcode,
 -					 MGMT_STATUS_INVALID_INDEX);
 -			goto done;
 -		}
 +unlock:
 +	hci_dev_unlock(hdev);
  
 -		if (test_bit(HCI_UNCONFIGURED, &hdev->dev_flags) &&
 -		    opcode != MGMT_OP_READ_CONFIG_INFO &&
 -		    opcode != MGMT_OP_SET_EXTERNAL_CONFIG &&
 -		    opcode != MGMT_OP_SET_PUBLIC_ADDRESS) {
 -			err = cmd_status(sk, index, opcode,
 -					 MGMT_STATUS_INVALID_INDEX);
 -			goto done;
 -		}
 -	}
 +	return err;
 +}
  
 -	if (opcode >= ARRAY_SIZE(mgmt_handlers) ||
 -	    mgmt_handlers[opcode].func == NULL) {
 -		BT_DBG("Unknown op %u", opcode);
 -		err = cmd_status(sk, index, opcode,
 -				 MGMT_STATUS_UNKNOWN_COMMAND);
 -		goto done;
 -	}
 +static u8 tlv_data_max_len(u32 adv_flags, bool is_adv_data)
 +{
 +	u8 max_len = HCI_MAX_AD_LENGTH;
  
 -	if (hdev && (opcode <= MGMT_OP_READ_INDEX_LIST ||
 -		     opcode == MGMT_OP_READ_UNCONF_INDEX_LIST)) {
 -		err = cmd_status(sk, index, opcode,
 -				 MGMT_STATUS_INVALID_INDEX);
 -		goto done;
 -	}
 +	if (is_adv_data) {
 +		if (adv_flags & (MGMT_ADV_FLAG_DISCOV |
 +				 MGMT_ADV_FLAG_LIMITED_DISCOV |
 +				 MGMT_ADV_FLAG_MANAGED_FLAGS))
 +			max_len -= 3;
  
 -	if (!hdev && (opcode > MGMT_OP_READ_INDEX_LIST &&
 -		      opcode != MGMT_OP_READ_UNCONF_INDEX_LIST)) {
 -		err = cmd_status(sk, index, opcode,
 -				 MGMT_STATUS_INVALID_INDEX);
 -		goto done;
 +		if (adv_flags & MGMT_ADV_FLAG_TX_POWER)
 +			max_len -= 3;
  	}
  
 -	handler = &mgmt_handlers[opcode];
 +	return max_len;
 +}
  
 -	if ((handler->var_len && len < handler->data_len) ||
 -	    (!handler->var_len && len != handler->data_len)) {
 -		err = cmd_status(sk, index, opcode,
 -				 MGMT_STATUS_INVALID_PARAMS);
 -		goto done;
 -	}
 +static int get_adv_size_info(struct sock *sk, struct hci_dev *hdev,
 +			     void *data, u16 data_len)
 +{
 +	struct mgmt_cp_get_adv_size_info *cp = data;
 +	struct mgmt_rp_get_adv_size_info rp;
 +	u32 flags, supported_flags;
 +	int err;
  
 -	if (hdev)
 -		mgmt_init_hdev(sk, hdev);
 +	BT_DBG("%s", hdev->name);
  
 -	cp = buf + sizeof(*hdr);
 +	if (!lmp_le_capable(hdev))
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,
 +				       MGMT_STATUS_REJECTED);
  
 -	err = handler->func(sk, hdev, cp, len);
 -	if (err < 0)
 -		goto done;
 +	if (cp->instance < 1 || cp->instance > HCI_MAX_ADV_INSTANCES)
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,
 +				       MGMT_STATUS_INVALID_PARAMS);
  
 -	err = msglen;
 +	flags = __le32_to_cpu(cp->flags);
  
 -done:
 -	if (hdev)
 -		hci_dev_put(hdev);
 +	/* The current implementation only supports a subset of the specified
 +	 * flags.
 +	 */
 +	supported_flags = get_supported_adv_flags(hdev);
 +	if (flags & ~supported_flags)
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,
 +				       MGMT_STATUS_INVALID_PARAMS);
 +
 +	rp.instance = cp->instance;
 +	rp.flags = cp->flags;
 +	rp.max_adv_data_len = tlv_data_max_len(flags, true);
 +	rp.max_scan_rsp_len = tlv_data_max_len(flags, false);
 +
 +	err = mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_ADV_SIZE_INFO,
 +				MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
  
 -	kfree(buf);
  	return err;
  }
  
diff --cc net/ipv4/ping.c
index 291ac786a807,ef8f6ee90473..000000000000
--- a/net/ipv4/ping.c
+++ b/net/ipv4/ping.c
@@@ -459,8 -641,49 +459,54 @@@ static int ping_push_pending_frames(str
  	return ip_push_pending_frames(sk, fl4);
  }
  
++<<<<<<< HEAD
 +static int ping_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 +			size_t len)
++=======
+ int ping_common_sendmsg(int family, struct msghdr *msg, size_t len,
+ 			void *user_icmph, size_t icmph_len) {
+ 	u8 type, code;
+ 
+ 	if (len > 0xFFFF)
+ 		return -EMSGSIZE;
+ 
+ 	/*
+ 	 *	Check the flags.
+ 	 */
+ 
+ 	/* Mirror BSD error message compatibility */
+ 	if (msg->msg_flags & MSG_OOB)
+ 		return -EOPNOTSUPP;
+ 
+ 	/*
+ 	 *	Fetch the ICMP header provided by the userland.
+ 	 *	iovec is modified! The ICMP header is consumed.
+ 	 */
+ 	if (memcpy_from_msg(user_icmph, msg, icmph_len))
+ 		return -EFAULT;
+ 
+ 	if (family == AF_INET) {
+ 		type = ((struct icmphdr *) user_icmph)->type;
+ 		code = ((struct icmphdr *) user_icmph)->code;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	} else if (family == AF_INET6) {
+ 		type = ((struct icmp6hdr *) user_icmph)->icmp6_type;
+ 		code = ((struct icmp6hdr *) user_icmph)->icmp6_code;
+ #endif
+ 	} else {
+ 		BUG();
+ 	}
+ 
+ 	if (!ping_supported(family, type, code))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(ping_common_sendmsg);
+ 
+ static int ping_v4_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+ 			   size_t len)
++>>>>>>> 6ce8e9ce5989 (new helper: memcpy_from_msg())
  {
  	struct net *net = sock_net(sk);
  	struct flowi4 fl4;
* Unmerged path net/ieee802154/dgram.c
* Unmerged path net/ieee802154/raw.c
diff --git a/crypto/algif_skcipher.c b/crypto/algif_skcipher.c
index 83187f497c7c..c3b482bee208 100644
--- a/crypto/algif_skcipher.c
+++ b/crypto/algif_skcipher.c
@@ -298,9 +298,9 @@ static int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,
 			len = min_t(unsigned long, len,
 				    PAGE_SIZE - sg->offset - sg->length);
 
-			err = memcpy_fromiovec(page_address(sg_page(sg)) +
-					       sg->offset + sg->length,
-					       msg->msg_iov, len);
+			err = memcpy_from_msg(page_address(sg_page(sg)) +
+					      sg->offset + sg->length,
+					      msg, len);
 			if (err)
 				goto unlock;
 
@@ -337,8 +337,8 @@ static int skcipher_sendmsg(struct kiocb *unused, struct socket *sock,
 			if (!sg_page(sg + i))
 				goto unlock;
 
-			err = memcpy_fromiovec(page_address(sg_page(sg + i)),
-					       msg->msg_iov, plen);
+			err = memcpy_from_msg(page_address(sg_page(sg + i)),
+					      msg, plen);
 			if (err) {
 				__free_page(sg_page(sg + i));
 				sg_assign_page(sg + i, NULL);
diff --git a/drivers/isdn/mISDN/socket.c b/drivers/isdn/mISDN/socket.c
index 5cefb479c707..2e81fec7c54e 100644
--- a/drivers/isdn/mISDN/socket.c
+++ b/drivers/isdn/mISDN/socket.c
@@ -204,7 +204,7 @@ mISDN_sock_sendmsg(struct kiocb *iocb, struct socket *sock,
 	if (!skb)
 		goto done;
 
-	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
+	if (memcpy_from_msg(skb_put(skb, len), msg, len)) {
 		err = -EFAULT;
 		goto done;
 	}
diff --git a/drivers/net/ppp/pppoe.c b/drivers/net/ppp/pppoe.c
index ad6fbcd7be5d..16ad775b7d68 100644
--- a/drivers/net/ppp/pppoe.c
+++ b/drivers/net/ppp/pppoe.c
@@ -888,7 +888,7 @@ static int pppoe_sendmsg(struct kiocb *iocb, struct socket *sock,
 	ph = (struct pppoe_hdr *)skb_put(skb, total_len + sizeof(struct pppoe_hdr));
 	start = (char *)&ph->tag[0];
 
-	error = memcpy_fromiovec(start, m->msg_iov, total_len);
+	error = memcpy_from_msg(start, m, total_len);
 	if (error < 0) {
 		kfree_skb(skb);
 		goto end;
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index d816dfc48c6b..622c8cf37da8 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -2812,6 +2812,11 @@ int skb_ensure_writable(struct sk_buff *skb, int write_len);
 int skb_vlan_pop(struct sk_buff *skb);
 int skb_vlan_push(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci);
 
+static inline int memcpy_from_msg(void *data, struct msghdr *msg, int len)
+{
+	return memcpy_fromiovec(data, msg->msg_iov, len);
+}
+
 struct skb_checksum_ops {
 	__wsum (*update)(const void *mem, int len, __wsum wsum);
 	__wsum (*combine)(__wsum csum, __wsum csum2, int offset, int len);
diff --git a/include/net/sctp/sm.h b/include/net/sctp/sm.h
index 5ca449f35190..eb990f067983 100644
--- a/include/net/sctp/sm.h
+++ b/include/net/sctp/sm.h
@@ -226,7 +226,7 @@ struct sctp_chunk *sctp_make_abort_no_data(const struct sctp_association *,
 				      const struct sctp_chunk *,
 				      __u32 tsn);
 struct sctp_chunk *sctp_make_abort_user(const struct sctp_association *,
-					const struct msghdr *, size_t msg_len);
+					struct msghdr *, size_t msg_len);
 struct sctp_chunk *sctp_make_abort_violation(const struct sctp_association *,
 				   const struct sctp_chunk *,
 				   const __u8 *,
diff --git a/net/appletalk/ddp.c b/net/appletalk/ddp.c
index 3e362d7127b4..d7c02df293b0 100644
--- a/net/appletalk/ddp.c
+++ b/net/appletalk/ddp.c
@@ -1662,7 +1662,7 @@ static int atalk_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr
 
 	SOCK_DEBUG(sk, "SK %p: Copy user data (%Zd bytes).\n", sk, len);
 
-	err = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
+	err = memcpy_from_msg(skb_put(skb, len), msg, len);
 	if (err) {
 		kfree_skb(skb);
 		err = -EFAULT;
diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index ade1cd58c484..1cf964d43259 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -1552,7 +1552,7 @@ static int ax25_sendmsg(struct kiocb *iocb, struct socket *sock,
 	skb_reserve(skb, size - len);
 
 	/* User data follows immediately after the AX.25 data */
-	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
+	if (memcpy_from_msg(skb_put(skb, len), msg, len)) {
 		err = -EFAULT;
 		kfree_skb(skb);
 		goto out;
diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
index 6d1d0e526ce6..f049cb99a0f6 100644
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@ -1346,7 +1346,7 @@ static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock,
 	if (!skb)
 		goto done;
 
-	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
+	if (memcpy_from_msg(skb_put(skb, len), msg, len)) {
 		err = -EFAULT;
 		goto drop;
 	}
* Unmerged path net/bluetooth/mgmt.c
diff --git a/net/bluetooth/rfcomm/sock.c b/net/bluetooth/rfcomm/sock.c
index b14c90644cbf..17150af75426 100644
--- a/net/bluetooth/rfcomm/sock.c
+++ b/net/bluetooth/rfcomm/sock.c
@@ -591,7 +591,7 @@ static int rfcomm_sock_sendmsg(struct kiocb *iocb, struct socket *sock,
 		}
 		skb_reserve(skb, RFCOMM_SKB_HEAD_RESERVE);
 
-		err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
+		err = memcpy_from_msg(skb_put(skb, size), msg, size);
 		if (err) {
 			kfree_skb(skb);
 			if (sent == 0)
diff --git a/net/bluetooth/sco.c b/net/bluetooth/sco.c
index 567e88058ba7..f0706136a052 100644
--- a/net/bluetooth/sco.c
+++ b/net/bluetooth/sco.c
@@ -287,7 +287,7 @@ static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)
 	if (!skb)
 		return err;
 
-	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
+	if (memcpy_from_msg(skb_put(skb, len), msg, len)) {
 		kfree_skb(skb);
 		return -EFAULT;
 	}
diff --git a/net/caif/caif_socket.c b/net/caif/caif_socket.c
index 0b614acbf1de..22062916e293 100644
--- a/net/caif/caif_socket.c
+++ b/net/caif/caif_socket.c
@@ -576,7 +576,7 @@ static int caif_seqpkt_sendmsg(struct kiocb *kiocb, struct socket *sock,
 
 	skb_reserve(skb, cf_sk->headroom);
 
-	ret = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
+	ret = memcpy_from_msg(skb_put(skb, len), msg, len);
 
 	if (ret)
 		goto err;
@@ -651,7 +651,7 @@ static int caif_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,
 		 */
 		size = min_t(int, size, skb_tailroom(skb));
 
-		err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
+		err = memcpy_from_msg(skb_put(skb, size), msg, size);
 		if (err) {
 			kfree_skb(skb);
 			goto out_err;
diff --git a/net/can/bcm.c b/net/can/bcm.c
index c194ec9964c2..a192e8509d71 100644
--- a/net/can/bcm.c
+++ b/net/can/bcm.c
@@ -859,8 +859,7 @@ static int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
 
 		/* update can_frames content */
 		for (i = 0; i < msg_head->nframes; i++) {
-			err = memcpy_fromiovec((u8 *)&op->frames[i],
-					       msg->msg_iov, CFSIZ);
+			err = memcpy_from_msg((u8 *)&op->frames[i], msg, CFSIZ);
 
 			if (op->frames[i].can_dlc > 8)
 				err = -EINVAL;
@@ -895,8 +894,7 @@ static int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
 			op->frames = &op->sframe;
 
 		for (i = 0; i < msg_head->nframes; i++) {
-			err = memcpy_fromiovec((u8 *)&op->frames[i],
-					       msg->msg_iov, CFSIZ);
+			err = memcpy_from_msg((u8 *)&op->frames[i], msg, CFSIZ);
 
 			if (op->frames[i].can_dlc > 8)
 				err = -EINVAL;
@@ -1025,9 +1023,8 @@ static int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
 
 		if (msg_head->nframes) {
 			/* update can_frames content */
-			err = memcpy_fromiovec((u8 *)op->frames,
-					       msg->msg_iov,
-					       msg_head->nframes * CFSIZ);
+			err = memcpy_from_msg((u8 *)op->frames, msg,
+					      msg_head->nframes * CFSIZ);
 			if (err < 0)
 				return err;
 
@@ -1073,8 +1070,8 @@ static int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
 		}
 
 		if (msg_head->nframes) {
-			err = memcpy_fromiovec((u8 *)op->frames, msg->msg_iov,
-					       msg_head->nframes * CFSIZ);
+			err = memcpy_from_msg((u8 *)op->frames, msg,
+					      msg_head->nframes * CFSIZ);
 			if (err < 0) {
 				if (op->frames != &op->sframe)
 					kfree(op->frames);
@@ -1210,7 +1207,7 @@ static int bcm_tx_send(struct msghdr *msg, int ifindex, struct sock *sk)
 
 	can_skb_reserve(skb);
 
-	err = memcpy_fromiovec(skb_put(skb, CFSIZ), msg->msg_iov, CFSIZ);
+	err = memcpy_from_msg(skb_put(skb, CFSIZ), msg, CFSIZ);
 	if (err < 0) {
 		kfree_skb(skb);
 		return err;
@@ -1288,7 +1285,7 @@ static int bcm_sendmsg(struct kiocb *iocb, struct socket *sock,
 
 	/* read message head information */
 
-	ret = memcpy_fromiovec((u8 *)&msg_head, msg->msg_iov, MHSIZ);
+	ret = memcpy_from_msg((u8 *)&msg_head, msg, MHSIZ);
 	if (ret < 0)
 		return ret;
 
diff --git a/net/can/raw.c b/net/can/raw.c
index 18a8d2ba707a..749a65597e3f 100644
--- a/net/can/raw.c
+++ b/net/can/raw.c
@@ -759,7 +759,7 @@ static int raw_sendmsg(struct kiocb *iocb, struct socket *sock,
 	can_skb_prv(skb)->ifindex = dev->ifindex;
 	can_skb_prv(skb)->skbcnt = 0;
 
-	err = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);
+	err = memcpy_from_msg(skb_put(skb, size), msg, size);
 	if (err < 0)
 		goto free_skb;
 
diff --git a/net/dccp/proto.c b/net/dccp/proto.c
index 63649bc44f22..7547e3e769a0 100644
--- a/net/dccp/proto.c
+++ b/net/dccp/proto.c
@@ -781,7 +781,7 @@ int dccp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		goto out_release;
 
 	skb_reserve(skb, sk->sk_prot->max_header);
-	rc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
+	rc = memcpy_from_msg(skb_put(skb, len), msg, len);
 	if (rc != 0)
 		goto out_discard;
 
diff --git a/net/decnet/af_decnet.c b/net/decnet/af_decnet.c
index 4536ba236159..1876b0f04f91 100644
--- a/net/decnet/af_decnet.c
+++ b/net/decnet/af_decnet.c
@@ -2033,7 +2033,7 @@ static int dn_sendmsg(struct kiocb *iocb, struct socket *sock,
 
 		skb_reserve(skb, 64 + DN_MAX_NSP_DATA_HEADER);
 
-		if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
+		if (memcpy_from_msg(skb_put(skb, len), msg, len)) {
 			err = -EFAULT;
 			goto out;
 		}
* Unmerged path net/ieee802154/dgram.c
* Unmerged path net/ieee802154/raw.c
* Unmerged path net/ipv4/ping.c
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 82210b952832..da7a20ea3508 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -4429,7 +4429,7 @@ int tcp_send_rcvq(struct sock *sk, struct msghdr *msg, size_t size)
 	if (tcp_try_rmem_schedule(sk, skb, skb->truesize))
 		goto err_free;
 
-	if (memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size))
+	if (memcpy_from_msg(skb_put(skb, size), msg, size))
 		goto err_free;
 
 	TCP_SKB_CB(skb)->seq = tcp_sk(sk)->rcv_nxt;
diff --git a/net/irda/af_irda.c b/net/irda/af_irda.c
index f8133ff5b081..17b695b44cc6 100644
--- a/net/irda/af_irda.c
+++ b/net/irda/af_irda.c
@@ -1343,7 +1343,7 @@ static int irda_sendmsg(struct kiocb *iocb, struct socket *sock,
 	skb_reserve(skb, self->max_header_size + 16);
 	skb_reset_transport_header(skb);
 	skb_put(skb, len);
-	err = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);
+	err = memcpy_from_msg(skb_transport_header(skb), msg, len);
 	if (err) {
 		kfree_skb(skb);
 		goto out_err;
@@ -1598,7 +1598,7 @@ static int irda_sendmsg_dgram(struct kiocb *iocb, struct socket *sock,
 
 	IRDA_DEBUG(4, "%s(), appending user data\n", __func__);
 	skb_put(skb, len);
-	err = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);
+	err = memcpy_from_msg(skb_transport_header(skb), msg, len);
 	if (err) {
 		kfree_skb(skb);
 		goto out;
@@ -1707,7 +1707,7 @@ static int irda_sendmsg_ultra(struct kiocb *iocb, struct socket *sock,
 
 	IRDA_DEBUG(4, "%s(), appending user data\n", __func__);
 	skb_put(skb, len);
-	err = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);
+	err = memcpy_from_msg(skb_transport_header(skb), msg, len);
 	if (err) {
 		kfree_skb(skb);
 		goto out;
diff --git a/net/iucv/af_iucv.c b/net/iucv/af_iucv.c
index 195cacf41b94..912393e6e0c9 100644
--- a/net/iucv/af_iucv.c
+++ b/net/iucv/af_iucv.c
@@ -1117,7 +1117,7 @@ static int iucv_sock_sendmsg(struct kiocb *iocb, struct socket *sock,
 		goto out;
 	if (iucv->transport == AF_IUCV_TRANS_HIPER)
 		skb_reserve(skb, sizeof(struct af_iucv_trans_hdr) + ETH_HLEN);
-	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
+	if (memcpy_from_msg(skb_put(skb, len), msg, len)) {
 		err = -EFAULT;
 		goto fail;
 	}
diff --git a/net/key/af_key.c b/net/key/af_key.c
index 00bca8409825..963d55e3f058 100644
--- a/net/key/af_key.c
+++ b/net/key/af_key.c
@@ -3621,7 +3621,7 @@ static int pfkey_sendmsg(struct kiocb *kiocb,
 		goto out;
 
 	err = -EFAULT;
-	if (memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len))
+	if (memcpy_from_msg(skb_put(skb,len), msg, len))
 		goto out;
 
 	hdr = pfkey_get_base_msg(skb, &err);
diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c
index 0fc8e647a166..5af3b2514de0 100644
--- a/net/l2tp/l2tp_ip.c
+++ b/net/l2tp/l2tp_ip.c
@@ -441,7 +441,7 @@ static int l2tp_ip_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *m
 	*((__be32 *) skb_put(skb, 4)) = 0;
 
 	/* Copy user data into skb */
-	rc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
+	rc = memcpy_from_msg(skb_put(skb, len), msg, len);
 	if (rc < 0) {
 		kfree_skb(skb);
 		goto error;
diff --git a/net/l2tp/l2tp_ppp.c b/net/l2tp/l2tp_ppp.c
index ce63092ef909..e235d75a5b26 100644
--- a/net/l2tp/l2tp_ppp.c
+++ b/net/l2tp/l2tp_ppp.c
@@ -344,8 +344,7 @@ static int pppol2tp_sendmsg(struct kiocb *iocb, struct socket *sock, struct msgh
 	skb_put(skb, 2);
 
 	/* Copy user data into skb */
-	error = memcpy_fromiovec(skb_put(skb, total_len), m->msg_iov,
-				 total_len);
+	error = memcpy_from_msg(skb_put(skb, total_len), m, total_len);
 	if (error < 0) {
 		kfree_skb(skb);
 		goto error_put_sess_tun;
diff --git a/net/llc/af_llc.c b/net/llc/af_llc.c
index f883bc51dd62..4a020dd53cde 100644
--- a/net/llc/af_llc.c
+++ b/net/llc/af_llc.c
@@ -921,7 +921,7 @@ static int llc_ui_sendmsg(struct kiocb *iocb, struct socket *sock,
 	skb->dev      = llc->dev;
 	skb->protocol = llc_proto_type(addr->sllc_arphrd);
 	skb_reserve(skb, hdrlen);
-	rc = memcpy_fromiovec(skb_put(skb, copied), msg->msg_iov, copied);
+	rc = memcpy_from_msg(skb_put(skb, copied), msg, copied);
 	if (rc)
 		goto out;
 	if (sk->sk_type == SOCK_DGRAM || addr->sllc_ua) {
diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
index a5ed40c3d4ca..c2a986d6f268 100644
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -2387,7 +2387,7 @@ static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
 	NETLINK_CB(skb).flags	= netlink_skb_flags;
 
 	err = -EFAULT;
-	if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
+	if (memcpy_from_msg(skb_put(skb, len), msg, len)) {
 		kfree_skb(skb);
 		goto out;
 	}
diff --git a/net/netrom/af_netrom.c b/net/netrom/af_netrom.c
index 44abd5094f38..a3322646a667 100644
--- a/net/netrom/af_netrom.c
+++ b/net/netrom/af_netrom.c
@@ -1113,7 +1113,7 @@ static int nr_sendmsg(struct kiocb *iocb, struct socket *sock,
 	skb_put(skb, len);
 
 	/* User data follows immediately after the NET/ROM transport header */
-	if (memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len)) {
+	if (memcpy_from_msg(skb_transport_header(skb), msg, len)) {
 		kfree_skb(skb);
 		err = -EFAULT;
 		goto out;
diff --git a/net/nfc/llcp_commands.c b/net/nfc/llcp_commands.c
index c1b23eef83ca..b2e4ddb18db9 100644
--- a/net/nfc/llcp_commands.c
+++ b/net/nfc/llcp_commands.c
@@ -687,7 +687,7 @@ int nfc_llcp_send_i_frame(struct nfc_llcp_sock *sock,
 	if (msg_data == NULL)
 		return -ENOMEM;
 
-	if (memcpy_fromiovec(msg_data, msg->msg_iov, len)) {
+	if (memcpy_from_msg(msg_data, msg, len)) {
 		kfree(msg_data);
 		return -EFAULT;
 	}
@@ -751,7 +751,7 @@ int nfc_llcp_send_ui_frame(struct nfc_llcp_sock *sock, u8 ssap, u8 dsap,
 	if (msg_data == NULL)
 		return -ENOMEM;
 
-	if (memcpy_fromiovec(msg_data, msg->msg_iov, len)) {
+	if (memcpy_from_msg(msg_data, msg, len)) {
 		kfree(msg_data);
 		return -EFAULT;
 	}
diff --git a/net/nfc/rawsock.c b/net/nfc/rawsock.c
index 5d11f4ac3ecb..8035242138e0 100644
--- a/net/nfc/rawsock.c
+++ b/net/nfc/rawsock.c
@@ -209,7 +209,7 @@ static int rawsock_sendmsg(struct kiocb *iocb, struct socket *sock,
 	if (skb == NULL)
 		return rc;
 
-	rc = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
+	rc = memcpy_from_msg(skb_put(skb, len), msg, len);
 	if (rc < 0) {
 		kfree_skb(skb);
 		return rc;
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 1933da1dcb82..b877ba71018a 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -1612,7 +1612,7 @@ retry:
 			if (len < hhlen)
 				skb_reset_network_header(skb);
 		}
-		err = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
+		err = memcpy_from_msg(skb_put(skb, len), msg, len);
 		if (err)
 			goto out_free;
 		goto retry;
@@ -2351,8 +2351,7 @@ static int packet_snd(struct socket *sock,
 
 		len -= vnet_hdr_len;
 
-		err = memcpy_fromiovec((void *)&vnet_hdr, msg->msg_iov,
-				       vnet_hdr_len);
+		err = memcpy_from_msg((void *)&vnet_hdr, msg, vnet_hdr_len);
 		if (err < 0)
 			goto out_unlock;
 
diff --git a/net/phonet/datagram.c b/net/phonet/datagram.c
index 38946b26e471..eb8ff560df4a 100644
--- a/net/phonet/datagram.c
+++ b/net/phonet/datagram.c
@@ -110,7 +110,7 @@ static int pn_sendmsg(struct kiocb *iocb, struct sock *sk,
 		return err;
 	skb_reserve(skb, MAX_PHONET_HEADER);
 
-	err = memcpy_fromiovec((void *)skb_put(skb, len), msg->msg_iov, len);
+	err = memcpy_from_msg((void *)skb_put(skb, len), msg, len);
 	if (err < 0) {
 		kfree_skb(skb);
 		return err;
diff --git a/net/phonet/pep.c b/net/phonet/pep.c
index e77411735de8..b75db0357597 100644
--- a/net/phonet/pep.c
+++ b/net/phonet/pep.c
@@ -1143,7 +1143,7 @@ static int pep_sendmsg(struct kiocb *iocb, struct sock *sk,
 		return err;
 
 	skb_reserve(skb, MAX_PHONET_HEADER + 3 + pn->aligned);
-	err = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
+	err = memcpy_from_msg(skb_put(skb, len), msg, len);
 	if (err < 0)
 		goto outfree;
 
diff --git a/net/rose/af_rose.c b/net/rose/af_rose.c
index 1ea4320ffc6b..708c3a0ee061 100644
--- a/net/rose/af_rose.c
+++ b/net/rose/af_rose.c
@@ -1121,7 +1121,7 @@ static int rose_sendmsg(struct kiocb *iocb, struct socket *sock,
 	skb_reset_transport_header(skb);
 	skb_put(skb, len);
 
-	err = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);
+	err = memcpy_from_msg(skb_transport_header(skb), msg, len);
 	if (err) {
 		kfree_skb(skb);
 		return err;
diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c
index c189f65b6b71..cd3788d378ea 100644
--- a/net/sctp/sm_make_chunk.c
+++ b/net/sctp/sm_make_chunk.c
@@ -1028,7 +1028,7 @@ no_mem:
 
 /* Helper to create ABORT with a SCTP_ERROR_USER_ABORT error.  */
 struct sctp_chunk *sctp_make_abort_user(const struct sctp_association *asoc,
-					const struct msghdr *msg,
+					struct msghdr *msg,
 					size_t paylen)
 {
 	struct sctp_chunk *retval;
@@ -1045,7 +1045,7 @@ struct sctp_chunk *sctp_make_abort_user(const struct sctp_association *asoc,
 		if (!payload)
 			goto err_payload;
 
-		err = memcpy_fromiovec(payload, msg->msg_iov, paylen);
+		err = memcpy_from_msg(payload, msg, paylen);
 		if (err < 0)
 			goto err_copy;
 	}
diff --git a/net/x25/af_x25.c b/net/x25/af_x25.c
index 01b99ffc4da1..47bbf447bedd 100644
--- a/net/x25/af_x25.c
+++ b/net/x25/af_x25.c
@@ -1168,7 +1168,7 @@ static int x25_sendmsg(struct kiocb *iocb, struct socket *sock,
 	skb_reset_transport_header(skb);
 	skb_put(skb, len);
 
-	rc = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);
+	rc = memcpy_from_msg(skb_transport_header(skb), msg, len);
 	if (rc)
 		goto out_kfree_skb;
 
