net: sched: run ingress qdisc without locks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: run ingress qdisc without locks (Ivan Vecera) [1428588]
Rebuild_FUZZ: 93.83%
commit-author Alexei Starovoitov <ast@plumgrid.com>
commit 087c1a601ad7f851a2d31f5fa0e5e9dfc766df55
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/087c1a60.failed

TC classifiers/actions were converted to RCU by John in the series:
http://thread.gmane.org/gmane.linux.network/329739/focus=329739
and many follow on patches.
This is the last patch from that series that finally drops
ingress spin_lock.

Single cpu ingress+u32 performance goes from 22.9 Mpps to 24.5 Mpps.

In two cpu case when both cores are receiving traffic on the same
device and go into the same ingress+u32 the performance jumps
from 4.5 + 4.5 Mpps to 23.5 + 23.5 Mpps

	Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
	Signed-off-by: Alexei Starovoitov <ast@plumgrid.com>
	Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 087c1a601ad7f851a2d31f5fa0e5e9dfc766df55)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_ingress.c
diff --cc net/sched/sch_ingress.c
index f92df45a3719,a89cc3278bfb..000000000000
--- a/net/sched/sch_ingress.c
+++ b/net/sched/sch_ingress.c
@@@ -59,11 -60,12 +59,11 @@@ static int ingress_enqueue(struct sk_bu
  {
  	struct ingress_qdisc_data *p = qdisc_priv(sch);
  	struct tcf_result res;
 -	struct tcf_proto *fl = rcu_dereference_bh(p->filter_list);
  	int result;
  
 -	result = tc_classify(skb, fl, &res);
 +	result = tc_classify(skb, p->filter_list, &res);
  
- 	qdisc_bstats_update(sch, skb);
+ 	qdisc_bstats_update_cpu(sch, skb);
  	switch (result) {
  	case TC_ACT_SHOT:
  		result = TC_ACT_SHOT;
@@@ -86,6 -88,14 +86,17 @@@
  
  /* ------------------------------------------------------------- */
  
++<<<<<<< HEAD
++=======
+ static int ingress_init(struct Qdisc *sch, struct nlattr *opt)
+ {
+ 	net_inc_ingress_queue();
+ 	sch->flags |= TCQ_F_CPUSTATS;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 087c1a601ad7 (net: sched: run ingress qdisc without locks)
  static void ingress_destroy(struct Qdisc *sch)
  {
  	struct ingress_qdisc_data *p = qdisc_priv(sch);
diff --git a/net/core/dev.c b/net/core/dev.c
index 48cb2232de86..28566b4389dd 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -3646,10 +3646,8 @@ static int ing_filter(struct sk_buff *skb, struct netdev_queue *rxq)
 
 	q = rcu_dereference(rxq->qdisc);
 	if (q != &noop_qdisc) {
-		spin_lock(qdisc_lock(q));
 		if (likely(!test_bit(__QDISC_STATE_DEACTIVATED, &q->state)))
 			result = qdisc_enqueue_root(skb, q);
-		spin_unlock(qdisc_lock(q));
 	}
 
 	return result;
* Unmerged path net/sched/sch_ingress.c
