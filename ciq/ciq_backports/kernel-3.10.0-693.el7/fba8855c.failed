crypto: ccp - Abstract PCI info for the CCP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] ccp - Abstract PCI info for the CCP (Suravee Suthikulpanit) [1390820]
Rebuild_FUZZ: 89.74%
commit-author Gary R Hook <gary.hook@amd.com>
commit fba8855cb2403707b0639bdff0d34149699f14a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fba8855c.failed

Device-specific values for the BAR and offset should be found
in the version data structure.

	Signed-off-by: Gary R Hook <gary.hook@amd.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit fba8855cb2403707b0639bdff0d34149699f14a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/ccp/ccp-dev-v3.c
#	drivers/crypto/ccp/ccp-dev.h
diff --cc drivers/crypto/ccp/ccp-dev.h
index 72bf1536b653,8824e41677c6..000000000000
--- a/drivers/crypto/ccp/ccp-dev.h
+++ b/drivers/crypto/ccp/ccp-dev.h
@@@ -1,9 -1,10 +1,10 @@@
  /*
   * AMD Cryptographic Coprocessor (CCP) driver
   *
 - * Copyright (C) 2013,2016 Advanced Micro Devices, Inc.
 + * Copyright (C) 2013 Advanced Micro Devices, Inc.
   *
   * Author: Tom Lendacky <thomas.lendacky@amd.com>
+  * Author: Gary R Hook <gary.hook@amd.com>
   *
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 2 as
@@@ -139,6 -145,30 +140,33 @@@
  #define CCP_ECC_RESULT_OFFSET		60
  #define CCP_ECC_RESULT_SUCCESS		0x0001
  
++<<<<<<< HEAD
++=======
+ struct ccp_op;
+ 
+ /* Structure for computation functions that are device-specific */
+ struct ccp_actions {
+ 	int (*perform_aes)(struct ccp_op *);
+ 	int (*perform_xts_aes)(struct ccp_op *);
+ 	int (*perform_sha)(struct ccp_op *);
+ 	int (*perform_rsa)(struct ccp_op *);
+ 	int (*perform_passthru)(struct ccp_op *);
+ 	int (*perform_ecc)(struct ccp_op *);
+ 	int (*init)(struct ccp_device *);
+ 	void (*destroy)(struct ccp_device *);
+ 	irqreturn_t (*irqhandler)(int, void *);
+ };
+ 
+ /* Structure to hold CCP version-specific values */
+ struct ccp_vdata {
+ 	unsigned int version;
+ 	const struct ccp_actions *perform;
+ 	const unsigned int bar;
+ 	const unsigned int offset;
+ };
+ 
+ extern struct ccp_vdata ccpv3;
++>>>>>>> fba8855cb240 (crypto: ccp - Abstract PCI info for the CCP)
  
  struct ccp_device;
  struct ccp_cmd;
* Unmerged path drivers/crypto/ccp/ccp-dev-v3.c
* Unmerged path drivers/crypto/ccp/ccp-dev-v3.c
* Unmerged path drivers/crypto/ccp/ccp-dev.h
diff --git a/drivers/crypto/ccp/ccp-pci.c b/drivers/crypto/ccp/ccp-pci.c
index 15741de944bc..884945751925 100644
--- a/drivers/crypto/ccp/ccp-pci.c
+++ b/drivers/crypto/ccp/ccp-pci.c
@@ -4,6 +4,7 @@
  * Copyright (C) 2013 Advanced Micro Devices, Inc.
  *
  * Author: Tom Lendacky <thomas.lendacky@amd.com>
+ * Author: Gary R Hook <gary.hook@amd.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -25,9 +26,6 @@
 
 #include "ccp-dev.h"
 
-#define IO_BAR				2
-#define IO_OFFSET			0x20000
-
 #define MSIX_VECTORS			2
 
 struct ccp_msix {
@@ -154,10 +152,11 @@ static int ccp_find_mmio_area(struct ccp_device *ccp)
 	resource_size_t io_len;
 	unsigned long io_flags;
 
-	io_flags = pci_resource_flags(pdev, IO_BAR);
-	io_len = pci_resource_len(pdev, IO_BAR);
-	if ((io_flags & IORESOURCE_MEM) && (io_len >= (IO_OFFSET + 0x800)))
-		return IO_BAR;
+	io_flags = pci_resource_flags(pdev, ccp->vdata->bar);
+	io_len = pci_resource_len(pdev, ccp->vdata->bar);
+	if ((io_flags & IORESOURCE_MEM) &&
+	    (io_len >= (ccp->vdata->offset + 0x800)))
+		return ccp->vdata->bar;
 
 	return -EIO;
 }
@@ -209,7 +208,7 @@ static int ccp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 		dev_err(dev, "pci_iomap failed\n");
 		goto e_device;
 	}
-	ccp->io_regs = ccp->io_map + IO_OFFSET;
+	ccp->io_regs = ccp->io_map + ccp->vdata->offset;
 
 	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(48));
 	if (ret) {
