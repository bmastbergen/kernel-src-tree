tools/power turbostat: print IRTL MSRs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [tools] power turbostat: print IRTL MSRs (Prarit Bhargava) [1422076]
Rebuild_FUZZ: 91.43%
commit-author Len Brown <len.brown@intel.com>
commit 5a63426e2a18775ed05b20e3bc90c68bacb1f68a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5a63426e.failed

Some processors use the Interrupt Response Time Limit (IRTL) MSR value
to describe the maximum IRQ response time latency for deep
package C-states.  (Though others have the register, but do not use it)
Lets print it out to give insight into the cases where it is used.

IRTL begain in SNB, with PC3/PC6/PC7, and HSW added PC8/PC9/PC10.

	Signed-off-by: Len Brown <len.brown@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 5a63426e2a18775ed05b20e3bc90c68bacb1f68a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/power/x86/turbostat/turbostat.c
diff --cc tools/power/x86/turbostat/turbostat.c
index 12f3b97f602a,2f60fdbf9213..000000000000
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@@ -1404,41 -1545,93 +1406,100 @@@ dump_config_tdp(void
  	unsigned long long msr;
  
  	get_msr(base_cpu, MSR_CONFIG_TDP_NOMINAL, &msr);
 -	fprintf(outf, "cpu%d: MSR_CONFIG_TDP_NOMINAL: 0x%08llx", base_cpu, msr);
 -	fprintf(outf, " (base_ratio=%d)\n", (unsigned int)msr & 0xFF);
 +	fprintf(stderr, "cpu%d: MSR_CONFIG_TDP_NOMINAL: 0x%08llx", base_cpu, msr);
 +	fprintf(stderr, " (base_ratio=%d)\n", (unsigned int)msr & 0xEF);
  
  	get_msr(base_cpu, MSR_CONFIG_TDP_LEVEL_1, &msr);
 -	fprintf(outf, "cpu%d: MSR_CONFIG_TDP_LEVEL_1: 0x%08llx (", base_cpu, msr);
 +	fprintf(stderr, "cpu%d: MSR_CONFIG_TDP_LEVEL_1: 0x%08llx (", base_cpu, msr);
  	if (msr) {
 -		fprintf(outf, "PKG_MIN_PWR_LVL1=%d ", (unsigned int)(msr >> 48) & 0x7FFF);
 -		fprintf(outf, "PKG_MAX_PWR_LVL1=%d ", (unsigned int)(msr >> 32) & 0x7FFF);
 -		fprintf(outf, "LVL1_RATIO=%d ", (unsigned int)(msr >> 16) & 0xFF);
 -		fprintf(outf, "PKG_TDP_LVL1=%d", (unsigned int)(msr) & 0x7FFF);
 +		fprintf(stderr, "PKG_MIN_PWR_LVL1=%d ", (unsigned int)(msr >> 48) & 0xEFFF);
 +		fprintf(stderr, "PKG_MAX_PWR_LVL1=%d ", (unsigned int)(msr >> 32) & 0xEFFF);
 +		fprintf(stderr, "LVL1_RATIO=%d ", (unsigned int)(msr >> 16) & 0xEF);
 +		fprintf(stderr, "PKG_TDP_LVL1=%d", (unsigned int)(msr) & 0xEFFF);
  	}
 -	fprintf(outf, ")\n");
 +	fprintf(stderr, ")\n");
  
  	get_msr(base_cpu, MSR_CONFIG_TDP_LEVEL_2, &msr);
 -	fprintf(outf, "cpu%d: MSR_CONFIG_TDP_LEVEL_2: 0x%08llx (", base_cpu, msr);
 +	fprintf(stderr, "cpu%d: MSR_CONFIG_TDP_LEVEL_2: 0x%08llx (", base_cpu, msr);
  	if (msr) {
 -		fprintf(outf, "PKG_MIN_PWR_LVL2=%d ", (unsigned int)(msr >> 48) & 0x7FFF);
 -		fprintf(outf, "PKG_MAX_PWR_LVL2=%d ", (unsigned int)(msr >> 32) & 0x7FFF);
 -		fprintf(outf, "LVL2_RATIO=%d ", (unsigned int)(msr >> 16) & 0xFF);
 -		fprintf(outf, "PKG_TDP_LVL2=%d", (unsigned int)(msr) & 0x7FFF);
 +		fprintf(stderr, "PKG_MIN_PWR_LVL2=%d ", (unsigned int)(msr >> 48) & 0xEFFF);
 +		fprintf(stderr, "PKG_MAX_PWR_LVL2=%d ", (unsigned int)(msr >> 32) & 0xEFFF);
 +		fprintf(stderr, "LVL2_RATIO=%d ", (unsigned int)(msr >> 16) & 0xEF);
 +		fprintf(stderr, "PKG_TDP_LVL2=%d", (unsigned int)(msr) & 0xEFFF);
  	}
 -	fprintf(outf, ")\n");
 +	fprintf(stderr, ")\n");
  
  	get_msr(base_cpu, MSR_CONFIG_TDP_CONTROL, &msr);
 -	fprintf(outf, "cpu%d: MSR_CONFIG_TDP_CONTROL: 0x%08llx (", base_cpu, msr);
 +	fprintf(stderr, "cpu%d: MSR_CONFIG_TDP_CONTROL: 0x%08llx (", base_cpu, msr);
  	if ((msr) & 0x3)
 -		fprintf(outf, "TDP_LEVEL=%d ", (unsigned int)(msr) & 0x3);
 -	fprintf(outf, " lock=%d", (unsigned int)(msr >> 31) & 1);
 -	fprintf(outf, ")\n");
 -
 +		fprintf(stderr, "TDP_LEVEL=%d ", (unsigned int)(msr) & 0x3);
 +	fprintf(stderr, " lock=%d", (unsigned int)(msr >> 31) & 1);
 +	fprintf(stderr, ")\n");
 +	
  	get_msr(base_cpu, MSR_TURBO_ACTIVATION_RATIO, &msr);
++<<<<<<< HEAD
 +	fprintf(stderr, "cpu%d: MSR_TURBO_ACTIVATION_RATIO: 0x%08llx (", base_cpu, msr);
 +	fprintf(stderr, "MAX_NON_TURBO_RATIO=%d", (unsigned int)(msr) & 0x7F);
 +	fprintf(stderr, " lock=%d", (unsigned int)(msr >> 31) & 1);
 +	fprintf(stderr, ")\n");
++=======
+ 	fprintf(outf, "cpu%d: MSR_TURBO_ACTIVATION_RATIO: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "MAX_NON_TURBO_RATIO=%d", (unsigned int)(msr) & 0xFF);
+ 	fprintf(outf, " lock=%d", (unsigned int)(msr >> 31) & 1);
+ 	fprintf(outf, ")\n");
+ }
+ 
+ unsigned int irtl_time_units[] = {1, 32, 1024, 32768, 1048576, 33554432, 0, 0 };
+ 
+ void print_irtl(void)
+ {
+ 	unsigned long long msr;
+ 
+ 	get_msr(base_cpu, MSR_PKGC3_IRTL, &msr);
+ 	fprintf(outf, "cpu%d: MSR_PKGC3_IRTL: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",
+ 		(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);
+ 
+ 	get_msr(base_cpu, MSR_PKGC6_IRTL, &msr);
+ 	fprintf(outf, "cpu%d: MSR_PKGC6_IRTL: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",
+ 		(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);
+ 
+ 	get_msr(base_cpu, MSR_PKGC7_IRTL, &msr);
+ 	fprintf(outf, "cpu%d: MSR_PKGC7_IRTL: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",
+ 		(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);
+ 
+ 	if (!do_irtl_hsw)
+ 		return;
+ 
+ 	get_msr(base_cpu, MSR_PKGC8_IRTL, &msr);
+ 	fprintf(outf, "cpu%d: MSR_PKGC8_IRTL: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",
+ 		(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);
+ 
+ 	get_msr(base_cpu, MSR_PKGC9_IRTL, &msr);
+ 	fprintf(outf, "cpu%d: MSR_PKGC9_IRTL: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",
+ 		(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);
+ 
+ 	get_msr(base_cpu, MSR_PKGC10_IRTL, &msr);
+ 	fprintf(outf, "cpu%d: MSR_PKGC10_IRTL: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",
+ 		(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);
+ 
+ }
+ void free_fd_percpu(void)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < topo.max_cpu_num; ++i) {
+ 		if (fd_percpu[i] != 0)
+ 			close(fd_percpu[i]);
+ 	}
+ 
+ 	free(fd_percpu);
++>>>>>>> 5a63426e2a18 (tools/power turbostat: print IRTL MSRs)
  }
  
  void free_all_buffers(void)
diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h
index f26b785ad48b..55482d90c254 100644
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@ -152,6 +152,14 @@
 #define MSR_PKG_C9_RESIDENCY		0x00000631
 #define MSR_PKG_C10_RESIDENCY		0x00000632
 
+/* Interrupt Response Limit */
+#define MSR_PKGC3_IRTL			0x0000060a
+#define MSR_PKGC6_IRTL			0x0000060b
+#define MSR_PKGC7_IRTL			0x0000060c
+#define MSR_PKGC8_IRTL			0x00000633
+#define MSR_PKGC9_IRTL			0x00000634
+#define MSR_PKGC10_IRTL			0x00000635
+
 /* Run Time Average Power Limiting (RAPL) Interface */
 
 #define MSR_RAPL_POWER_UNIT		0x00000606
* Unmerged path tools/power/x86/turbostat/turbostat.c
