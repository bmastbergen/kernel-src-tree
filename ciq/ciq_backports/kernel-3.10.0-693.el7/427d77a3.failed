x86/smpboot: Prevent false positive out of bounds cpumask access warning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] smpboot: Prevent false positive out of bounds cpumask access warning (Baoquan He) [1440629]
Rebuild_FUZZ: 97.14%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 427d77a32365d5f942d335248305a5c237baf63a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/427d77a3.failed

prefill_possible_map() reinitializes the cpu_possible_map by setting the
possible cpu bits and clearing all other bits up to NR_CPUS.

This is technically always correct because cpu_possible_map is statically
allocated and sized NR_CPUS. With CPUMASK_OFFSTACK and DEBUG_PER_CPU_MAPS
enabled the bounds check of cpu masks happens on nr_cpu_ids. nr_cpu_ids is
initialized to NR_CPUS and only limited after the set/clear bit loops have
been executed. 

But if the system was booted with "nr_cpus=N" on the command line, where N
is < NR_CPUS then nr_cpu_ids is limited in the parameter parsing function
before prefill_possible_map() is invoked. As a consequence the cpumask
bounds check triggers when clearing the bits past nr_cpu_ids.

Add a helper which allows to reset cpu_possible_map w/o the bounds check
and then set only the possible bits which are well inside bounds.

	Reported-by: Dmitry Safonov <dsafonov@virtuozzo.com>
	Cc: Rusty Russell <rusty@rustcorp.com.au>
	Cc: 0x7f454c46@gmail.com
	Cc: Jan Beulich <JBeulich@novell.com>
Link: http://lkml.kernel.org/r/alpine.DEB.2.20.1612131836050.3415@nanos
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit 427d77a32365d5f942d335248305a5c237baf63a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/cpumask.h
diff --cc include/linux/cpumask.h
index a99fc609e946,c717f5ea88cb..000000000000
--- a/include/linux/cpumask.h
+++ b/include/linux/cpumask.h
@@@ -745,6 -722,48 +745,51 @@@ void init_cpu_present(const struct cpum
  void init_cpu_possible(const struct cpumask *src);
  void init_cpu_online(const struct cpumask *src);
  
++<<<<<<< HEAD
++=======
+ static inline void reset_cpu_possible_mask(void)
+ {
+ 	bitmap_zero(cpumask_bits(&__cpu_possible_mask), NR_CPUS);
+ }
+ 
+ static inline void
+ set_cpu_possible(unsigned int cpu, bool possible)
+ {
+ 	if (possible)
+ 		cpumask_set_cpu(cpu, &__cpu_possible_mask);
+ 	else
+ 		cpumask_clear_cpu(cpu, &__cpu_possible_mask);
+ }
+ 
+ static inline void
+ set_cpu_present(unsigned int cpu, bool present)
+ {
+ 	if (present)
+ 		cpumask_set_cpu(cpu, &__cpu_present_mask);
+ 	else
+ 		cpumask_clear_cpu(cpu, &__cpu_present_mask);
+ }
+ 
+ static inline void
+ set_cpu_online(unsigned int cpu, bool online)
+ {
+ 	if (online)
+ 		cpumask_set_cpu(cpu, &__cpu_online_mask);
+ 	else
+ 		cpumask_clear_cpu(cpu, &__cpu_online_mask);
+ }
+ 
+ static inline void
+ set_cpu_active(unsigned int cpu, bool active)
+ {
+ 	if (active)
+ 		cpumask_set_cpu(cpu, &__cpu_active_mask);
+ 	else
+ 		cpumask_clear_cpu(cpu, &__cpu_active_mask);
+ }
+ 
+ 
++>>>>>>> 427d77a32365 (x86/smpboot: Prevent false positive out of bounds cpumask access warning)
  /**
   * to_cpumask - convert an NR_CPUS bitmap to a struct cpumask *
   * @bitmap: the bitmap
diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c
index def98499d298..507bf199572e 100644
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -1431,15 +1431,15 @@ __init void prefill_possible_map(void)
 		possible = i;
 	}
 
+	nr_cpu_ids = possible;
+
 	pr_info("Allowing %d CPUs, %d hotplug CPUs\n",
 		possible, max_t(int, possible - num_processors, 0));
 
+	reset_cpu_possible_mask();
+
 	for (i = 0; i < possible; i++)
 		set_cpu_possible(i, true);
-	for (; i < NR_CPUS; i++)
-		set_cpu_possible(i, false);
-
-	nr_cpu_ids = possible;
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
* Unmerged path include/linux/cpumask.h
