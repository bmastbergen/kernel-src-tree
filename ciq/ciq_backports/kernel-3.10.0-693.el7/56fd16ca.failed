timekeeping: Increment clock_was_set_seq in timekeeping_init()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 56fd16cabac9cd8f15e2902898a9d0cc96e2fa70
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/56fd16ca.failed

timekeeping_init() can set the wall time offset, so we need to
increment the clock_was_set_seq counter. That way hrtimers will pick
up the early offset immediately. Otherwise on a machine which does not
set wall time later in the boot process the hrtimer offset is stale at
0 and wall time timers are going to expire with a delay of 45 years.

Fixes: 868a3e915f7f "hrtimer: Make offset update smarter"
Reported-and-tested-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Stefan Liebler <stli@linux.vnet.ibm.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: John Stultz <john.stultz@linaro.org>
(cherry picked from commit 56fd16cabac9cd8f15e2902898a9d0cc96e2fa70)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/timekeeping.c
diff --cc kernel/time/timekeeping.c
index 1f122214a691,44d2cc0436f4..000000000000
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@@ -1130,13 -1251,9 +1130,17 @@@ void __init timekeeping_init(void
  	set_normalized_timespec64(&tmp, -boot.tv_sec, -boot.tv_nsec);
  	tk_set_wall_to_mono(tk, tmp);
  
++<<<<<<< HEAD
 +	tmp.tv_sec = 0;
 +	tmp.tv_nsec = 0;
 +	tk_set_sleep_time(tk, tmp);
++=======
+ 	timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);
++>>>>>>> 56fd16cabac9 (timekeeping: Increment clock_was_set_seq in timekeeping_init())
 +
 +	memcpy(&shadow_timekeeper, &timekeeper, sizeof(timekeeper));
  
 -	write_seqcount_end(&tk_core.seq);
 +	write_seqcount_end(&timekeeper_seq);
  	raw_spin_unlock_irqrestore(&timekeeper_lock, flags);
  }
  
* Unmerged path kernel/time/timekeeping.c
