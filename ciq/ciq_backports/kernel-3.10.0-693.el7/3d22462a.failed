cifs: stuff the fl_owner into "pid" field in the lock request

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jeff Layton <jlayton@poochiereds.net>
commit 3d22462ae915743f3be5bf1ab3d4a6b72c2bb6c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3d22462a.failed

Right now, we send the tgid cross the wire. What we really want to send
though is a hashed fl_owner_t since samba treats this field as a generic
lockowner.

It turns out that because we enforce and release locks locally before
they are ever sent to the server, this patch makes no difference in
behavior. Still, setting OFD locks on the server using the process
pid seems wrong, so I think this patch still makes sense.

	Signed-off-by: Jeff Layton <jlayton@poochiereds.net>
	Signed-off-by: Steve French <smfrench@gmail.com>
	Acked-by: Pavel Shilovsky <pshilovsky@samba.org>
	Acked-by: Sachin Prabhu <sprabhu@redhat.com>
(cherry picked from commit 3d22462ae915743f3be5bf1ab3d4a6b72c2bb6c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/file.c
diff --cc fs/cifs/file.c
index c259c09ba911,d4890b6dc22d..000000000000
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@@ -1111,10 -1112,11 +1111,18 @@@ cifs_push_mandatory_locks(struct cifsFi
  	return rc;
  }
  
++<<<<<<< HEAD
 +/* copied from fs/locks.c with a name change */
 +#define cifs_for_each_lock(inode, lockp) \
 +	for (lockp = &inode->i_flock; *lockp != NULL; \
 +	     lockp = &(*lockp)->fl_next)
++=======
+ static __u32
+ hash_lockowner(fl_owner_t owner)
+ {
+ 	return cifs_lock_secret ^ hash32_ptr((const void *)owner);
+ }
++>>>>>>> 3d22462ae915 (cifs: stuff the fl_owner into "pid" field in the lock request)
  
  struct lock_to_push {
  	struct list_head llist;
diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c
index 9f6ff2423731..d571365b6f8f 100644
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@ -86,6 +86,7 @@ extern mempool_t *cifs_req_poolp;
 extern mempool_t *cifs_mid_poolp;
 
 struct workqueue_struct	*cifsiod_wq;
+__u32 cifs_lock_secret;
 
 /*
  * Bumps refcount for cifs super block.
@@ -1251,6 +1252,8 @@ init_cifs(void)
 	spin_lock_init(&cifs_file_list_lock);
 	spin_lock_init(&GlobalMid_Lock);
 
+	get_random_bytes(&cifs_lock_secret, sizeof(cifs_lock_secret));
+
 	if (cifs_max_pending < 2) {
 		cifs_max_pending = 2;
 		cifs_dbg(FYI, "cifs_max_pending set to min of 2\n");
diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h
index 9d14926531ba..22e22b43c72a 100644
--- a/fs/cifs/cifsglob.h
+++ b/fs/cifs/cifsglob.h
@@ -1617,6 +1617,7 @@ void cifs_oplock_break(struct work_struct *work);
 
 extern const struct slow_work_ops cifs_oplock_break_ops;
 extern struct workqueue_struct *cifsiod_wq;
+extern __u32 cifs_lock_secret;
 
 extern mempool_t *cifs_mid_poolp;
 
* Unmerged path fs/cifs/file.c
