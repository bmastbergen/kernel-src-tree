x86/boot: Extract error reporting functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] boot: Extract error reporting functions (Baoquan He) [1290840]
Rebuild_FUZZ: 95.12%
commit-author Kees Cook <keescook@chromium.org>
commit dc425a6e140bca99bdb4823e9909c9d9b8ba36b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/dc425a6e.failed

Currently to use warn(), a caller would need to include misc.h. However,
this means they would get the (unavailable during compressed boot)
gcc built-in memcpy family of functions. But since string.c is defining
these memcpy functions for use by misc.c, we end up in a weird circular
dependency.

To break this loop, move the error reporting functions outside of misc.c
with their own header so that they can be independently included by
other sources. Since the screen-writing routines use memmove(), keep the
low-level *_putstr() functions in misc.c.

	Signed-off-by: Kees Cook <keescook@chromium.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Baoquan He <bhe@redhat.com>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Lasse Collin <lasse.collin@tukaani.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: One Thousand Gnomes <gnomes@lxorguk.ukuu.org.uk>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Yinghai Lu <yinghai@kernel.org>
Link: http://lkml.kernel.org/r/1462229461-3370-2-git-send-email-keescook@chromium.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit dc425a6e140bca99bdb4823e9909c9d9b8ba36b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/Makefile
#	arch/x86/boot/compressed/kaslr.c
#	arch/x86/boot/compressed/misc.c
#	arch/x86/boot/compressed/misc.h
diff --cc arch/x86/boot/compressed/Makefile
index 1dc427850e11,77ce3a04d46e..000000000000
--- a/arch/x86/boot/compressed/Makefile
+++ b/arch/x86/boot/compressed/Makefile
@@@ -26,9 -57,24 +26,30 @@@ LDFLAGS_vmlinux := -
  hostprogs-y	:= mkpiggy
  HOST_EXTRACFLAGS += -I$(srctree)/tools/include
  
++<<<<<<< HEAD
 +VMLINUX_OBJS = $(obj)/vmlinux.lds $(obj)/head_$(BITS).o $(obj)/misc.o \
 +	$(obj)/string.o $(obj)/cmdline.o $(obj)/early_serial_console.o \
 +	$(obj)/piggy.o
++=======
+ sed-voffset := -e 's/^\([0-9a-fA-F]*\) [ABCDGRSTVW] \(_text\|__bss_start\|_end\)$$/\#define VO_\2 _AC(0x\1,UL)/p'
+ 
+ quiet_cmd_voffset = VOFFSET $@
+       cmd_voffset = $(NM) $< | sed -n $(sed-voffset) > $@
+ 
+ targets += ../voffset.h
+ 
+ $(obj)/../voffset.h: vmlinux FORCE
+ 	$(call if_changed,voffset)
+ 
+ $(obj)/misc.o: $(obj)/../voffset.h
+ 
+ vmlinux-objs-y := $(obj)/vmlinux.lds $(obj)/head_$(BITS).o $(obj)/misc.o \
+ 	$(obj)/string.o $(obj)/cmdline.o $(obj)/error.o \
+ 	$(obj)/piggy.o $(obj)/cpuflags.o
+ 
+ vmlinux-objs-$(CONFIG_EARLY_PRINTK) += $(obj)/early_serial_console.o
+ vmlinux-objs-$(CONFIG_RANDOMIZE_BASE) += $(obj)/kaslr.o
++>>>>>>> dc425a6e140b (x86/boot: Extract error reporting functions)
  
  $(obj)/eboot.o: KBUILD_CFLAGS += -fshort-wchar -mno-red-zone
  
diff --cc arch/x86/boot/compressed/misc.c
index 243fb14b38e2,9536d778149e..000000000000
--- a/arch/x86/boot/compressed/misc.c
+++ b/arch/x86/boot/compressed/misc.c
@@@ -10,98 -12,22 +10,99 @@@
   */
  
  #include "misc.h"
+ #include "error.h"
  #include "../string.h"
 -#include "../voffset.h"
 +
 +/* WARNING!!
 + * This code is compiled with -fPIC and it is relocated dynamically
 + * at run time, but no relocation processing is performed.
 + * This means that it is not safe to place pointers in static structures.
 + */
  
  /*
 - * WARNING!!
 - * This code is compiled with -fPIC and it is relocated dynamically at
 - * run time, but no relocation processing is performed. This means that
 - * it is not safe to place pointers in static structures.
 + * Getting to provable safe in place decompression is hard.
 + * Worst case behaviours need to be analyzed.
 + * Background information:
 + *
 + * The file layout is:
 + *    magic[2]
 + *    method[1]
 + *    flags[1]
 + *    timestamp[4]
 + *    extraflags[1]
 + *    os[1]
 + *    compressed data blocks[N]
 + *    crc[4] orig_len[4]
 + *
 + * resulting in 18 bytes of non compressed data overhead.
 + *
 + * Files divided into blocks
 + * 1 bit (last block flag)
 + * 2 bits (block type)
 + *
 + * 1 block occurs every 32K -1 bytes or when there 50% compression
 + * has been achieved. The smallest block type encoding is always used.
 + *
 + * stored:
 + *    32 bits length in bytes.
 + *
 + * fixed:
 + *    magic fixed tree.
 + *    symbols.
 + *
 + * dynamic:
 + *    dynamic tree encoding.
 + *    symbols.
 + *
 + *
 + * The buffer for decompression in place is the length of the
 + * uncompressed data, plus a small amount extra to keep the algorithm safe.
 + * The compressed data is placed at the end of the buffer.  The output
 + * pointer is placed at the start of the buffer and the input pointer
 + * is placed where the compressed data starts.  Problems will occur
 + * when the output pointer overruns the input pointer.
 + *
 + * The output pointer can only overrun the input pointer if the input
 + * pointer is moving faster than the output pointer.  A condition only
 + * triggered by data whose compressed form is larger than the uncompressed
 + * form.
 + *
 + * The worst case at the block level is a growth of the compressed data
 + * of 5 bytes per 32767 bytes.
 + *
 + * The worst case internal to a compressed block is very hard to figure.
 + * The worst case can at least be boundined by having one bit that represents
 + * 32764 bytes and then all of the rest of the bytes representing the very
 + * very last byte.
 + *
 + * All of which is enough to compute an amount of extra data that is required
 + * to be safe.  To avoid problems at the block level allocating 5 extra bytes
 + * per 32767 bytes of data is sufficient.  To avoind problems internal to a
 + * block adding an extra 32767 bytes (the worst case uncompressed block size)
 + * is sufficient, to ensure that in the worst case the decompressed data for
 + * block will stop the byte before the compressed data for a block begins.
 + * To avoid problems with the compressed data's meta information an extra 18
 + * bytes are needed.  Leading to the formula:
 + *
 + * extra_bytes = (uncompressed_size >> 12) + 32768 + 18 + decompressor_size.
 + *
 + * Adding 8 bytes per 32K is a bit excessive but much easier to calculate.
 + * Adding 32768 instead of 32767 just makes for round numbers.
 + * Adding the decompressor_size is necessary as it musht live after all
 + * of the data as well.  Last I measured the decompressor is about 14K.
 + * 10K of actual data and 4K of bss.
 + *
   */
  
 -/* Macros used by the included decompressor code below. */
 +/*
 + * gzip declarations
 + */
  #define STATIC		static
  
 +#undef memcpy
 +
  /*
 - * Use normal definitions of mem*() from string.c. There are already
 + * Use a normal definition of memset() from string.c. There are already
   * included header files which expect a definition of memset() and by
   * the time we define memset macro, it is too late.
   */
@@@ -109,8 -36,7 +110,12 @@@
  #define memzero(s, n)	memset((s), 0, (n))
  #define memmove		memmove
  
++<<<<<<< HEAD
 +
 +static void error(char *m);
++=======
+ /* Functions used by the included decompressor code below. */
++>>>>>>> dc425a6e140b (x86/boot: Extract error reporting functions)
  void *memmove(void *dest, const void *src, size_t n);
  
  /*
@@@ -224,14 -152,21 +229,32 @@@ void __putstr(const char *s
  	outb(0xff & (pos >> 1), vidport+1);
  }
  
++<<<<<<< HEAD
 +static void error(char *x)
 +{
 +	error_putstr("\n\n");
 +	error_putstr(x);
 +	error_putstr("\n\n -- System halted");
 +
 +	while (1)
 +		asm("hlt");
++=======
+ void __puthex(unsigned long value)
+ {
+ 	char alpha[2] = "0";
+ 	int bits;
+ 
+ 	for (bits = sizeof(value) * 8 - 4; bits >= 0; bits -= 4) {
+ 		unsigned long digit = (value >> bits) & 0xf;
+ 
+ 		if (digit < 0xA)
+ 			alpha[0] = '0' + digit;
+ 		else
+ 			alpha[0] = 'a' + (digit - 0xA);
+ 
+ 		__putstr(alpha);
+ 	}
++>>>>>>> dc425a6e140b (x86/boot: Extract error reporting functions)
  }
  
  #if CONFIG_X86_NEED_RELOCS
diff --cc arch/x86/boot/compressed/misc.h
index 674019d8e235,9887e0d4aaeb..000000000000
--- a/arch/x86/boot/compressed/misc.h
+++ b/arch/x86/boot/compressed/misc.h
@@@ -23,10 -23,20 +23,14 @@@
  #define BOOT_BOOT_H
  #include "../ctype.h"
  
 -#ifdef CONFIG_X86_64
 -#define memptr long
 -#else
 -#define memptr unsigned
 -#endif
 -
  /* misc.c */
 -extern memptr free_mem_ptr;
 -extern memptr free_mem_end_ptr;
 -extern struct boot_params *boot_params;
 +extern struct boot_params *real_mode;		/* Pointer to real-mode data */
  void __putstr(const char *s);
++<<<<<<< HEAD
++=======
+ void __puthex(unsigned long value);
++>>>>>>> dc425a6e140b (x86/boot: Extract error reporting functions)
  #define error_putstr(__x)  __putstr(__x)
 -#define error_puthex(__x)  __puthex(__x)
  
  #ifdef CONFIG_X86_VERBOSE_BOOTUP
  
* Unmerged path arch/x86/boot/compressed/kaslr.c
* Unmerged path arch/x86/boot/compressed/Makefile
diff --git a/arch/x86/boot/compressed/error.c b/arch/x86/boot/compressed/error.c
new file mode 100644
index 000000000000..6248740b68b5
--- /dev/null
+++ b/arch/x86/boot/compressed/error.c
@@ -0,0 +1,22 @@
+/*
+ * Callers outside of misc.c need access to the error reporting routines,
+ * but the *_putstr() functions need to stay in misc.c because of how
+ * memcpy() and memmove() are defined for the compressed boot environment.
+ */
+#include "misc.h"
+
+void warn(char *m)
+{
+	error_putstr("\n\n");
+	error_putstr(m);
+	error_putstr("\n\n");
+}
+
+void error(char *m)
+{
+	warn(m);
+	error_putstr(" -- System halted");
+
+	while (1)
+		asm("hlt");
+}
diff --git a/arch/x86/boot/compressed/error.h b/arch/x86/boot/compressed/error.h
new file mode 100644
index 000000000000..2e59dac07f9e
--- /dev/null
+++ b/arch/x86/boot/compressed/error.h
@@ -0,0 +1,7 @@
+#ifndef BOOT_COMPRESSED_ERROR_H
+#define BOOT_COMPRESSED_ERROR_H
+
+void warn(char *m);
+void error(char *m);
+
+#endif /* BOOT_COMPRESSED_ERROR_H */
* Unmerged path arch/x86/boot/compressed/kaslr.c
* Unmerged path arch/x86/boot/compressed/misc.c
* Unmerged path arch/x86/boot/compressed/misc.h
diff --git a/arch/x86/boot/compressed/string.c b/arch/x86/boot/compressed/string.c
index 2befeca1aada..faa4dc7dc66b 100644
--- a/arch/x86/boot/compressed/string.c
+++ b/arch/x86/boot/compressed/string.c
@@ -5,6 +5,8 @@
  * trust the gcc built-in implementations as they may do unexpected things
  * (e.g. FPU ops) in the minimal decompression stub execution environment.
  */
+#include "error.h"
+
 #include "../string.c"
 
 #ifdef CONFIG_X86_32
