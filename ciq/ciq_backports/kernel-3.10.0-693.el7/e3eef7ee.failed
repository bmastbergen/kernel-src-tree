qede: Postpone reallocation until NAPI end

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mintz, Yuval <Yuval.Mintz@cavium.com>
commit e3eef7ee0201dbe5f4fc011b58d26228b57736ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e3eef7ee.failed

During Rx flow driver allocates a replacement buffer each time
it consumes an Rx buffer. Failing to do so, it would consume the
currently processed buffer and re-post it on the ring.
As a result, the Rx ring is always completely full [from driver POV].

We now allow the Rx ring to shorten by doing the re-allocations
at the end of the NAPI run. The only limitation is that we still want to
make sure each time we reallocate that we'd still have sufficient
elements in the Rx ring to guarantee that FW would be able to post
additional data and trigger an interrupt.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e3eef7ee0201dbe5f4fc011b58d26228b57736ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qede/qede.h
#	drivers/net/ethernet/qlogic/qede/qede_fp.c
#	drivers/net/ethernet/qlogic/qede/qede_main.c
diff --cc drivers/net/ethernet/qlogic/qede/qede.h
index 1b7b1accb2cc,1c5aac4b6139..000000000000
--- a/drivers/net/ethernet/qlogic/qede/qede.h
+++ b/drivers/net/ethernet/qlogic/qede/qede.h
@@@ -232,27 -269,43 +232,56 @@@ struct qede_agg_info 
  };
  
  struct qede_rx_queue {
++<<<<<<< HEAD
 +	__le16			*hw_cons_ptr;
 +	struct sw_rx_data	*sw_rx_ring;
 +	u16			sw_rx_cons;
 +	u16			sw_rx_prod;
 +	struct qed_chain	rx_bd_ring;
 +	struct qed_chain	rx_comp_ring;
 +	void __iomem		*hw_rxq_prod_addr;
++=======
+ 	__le16 *hw_cons_ptr;
+ 	void __iomem *hw_rxq_prod_addr;
+ 
+ 	/* Required for the allocation of replacement buffers */
+ 	struct device *dev;
+ 
+ 	struct bpf_prog *xdp_prog;
+ 
+ 	u16 sw_rx_cons;
+ 	u16 sw_rx_prod;
+ 
+ 	u16 filled_buffers;
+ 	u8 data_direction;
+ 	u8 rxq_id;
+ 
+ 	u32 rx_buf_size;
+ 	u32 rx_buf_seg_size;
+ 
+ 	u64 rcv_pkts;
+ 
+ 	struct sw_rx_data *sw_rx_ring;
+ 	struct qed_chain rx_bd_ring;
+ 	struct qed_chain rx_comp_ring ____cacheline_aligned;
++>>>>>>> e3eef7ee0201 (qede: Postpone reallocation until NAPI end)
+ 
+ 	/* Used once per each NAPI run */
+ 	u16 num_rx_buffers;
  
  	/* GRO */
 -	struct qede_agg_info tpa_info[ETH_TPA_MAX_AGGS_NUM];
 +	struct qede_agg_info	tpa_info[ETH_TPA_MAX_AGGS_NUM];
  
 -	u64 rx_hw_errors;
 -	u64 rx_alloc_errors;
 -	u64 rx_ip_frags;
 +	int			rx_buf_size;
 +	unsigned int		rx_buf_seg_size;
  
 -	u64 xdp_no_pass;
 +	u16			num_rx_buffers;
 +	u16			rxq_id;
  
 -	void *handle;
 +	u64			rcv_pkts;
 +	u64			rx_hw_errors;
 +	u64			rx_alloc_errors;
 +	u64			rx_ip_frags;
  };
  
  union db_prod {
@@@ -327,10 -402,47 +356,45 @@@ struct qede_fastpath 
  #define QEDE_SP_VXLAN_PORT_CONFIG	2
  #define QEDE_SP_GENEVE_PORT_CONFIG	3
  
 -struct qede_reload_args {
 -	void (*func)(struct qede_dev *edev, struct qede_reload_args *args);
 -	union {
 -		netdev_features_t features;
 -		struct bpf_prog *new_prog;
 -		u16 mtu;
 -	} u;
 +union qede_reload_args {
 +	u16 mtu;
  };
  
++<<<<<<< HEAD
++=======
+ /* Datapath functions definition */
+ netdev_tx_t qede_start_xmit(struct sk_buff *skb, struct net_device *ndev);
+ netdev_features_t qede_features_check(struct sk_buff *skb,
+ 				      struct net_device *dev,
+ 				      netdev_features_t features);
+ void qede_tx_log_print(struct qede_dev *edev, struct qede_fastpath *fp);
+ int qede_alloc_rx_buffer(struct qede_rx_queue *rxq, bool allow_lazy);
+ int qede_free_tx_pkt(struct qede_dev *edev,
+ 		     struct qede_tx_queue *txq, int *len);
+ int qede_poll(struct napi_struct *napi, int budget);
+ irqreturn_t qede_msix_fp_int(int irq, void *fp_cookie);
+ 
+ /* Filtering function definitions */
+ void qede_force_mac(void *dev, u8 *mac, bool forced);
+ int qede_set_mac_addr(struct net_device *ndev, void *p);
+ 
+ int qede_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid);
+ int qede_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid);
+ void qede_vlan_mark_nonconfigured(struct qede_dev *edev);
+ int qede_configure_vlan_filters(struct qede_dev *edev);
+ 
+ int qede_set_features(struct net_device *dev, netdev_features_t features);
+ void qede_set_rx_mode(struct net_device *ndev);
+ void qede_config_rx_mode(struct net_device *ndev);
+ void qede_fill_rss_params(struct qede_dev *edev,
+ 			  struct qed_update_vport_rss_params *rss, u8 *update);
+ 
+ void qede_udp_tunnel_add(struct net_device *dev, struct udp_tunnel_info *ti);
+ void qede_udp_tunnel_del(struct net_device *dev, struct udp_tunnel_info *ti);
+ 
+ int qede_xdp(struct net_device *dev, struct netdev_xdp *xdp);
+ 
++>>>>>>> e3eef7ee0201 (qede: Postpone reallocation until NAPI end)
  #ifdef CONFIG_DCB
  void qede_set_dcbnl_ops(struct net_device *ndev);
  #endif
diff --cc drivers/net/ethernet/qlogic/qede/qede_main.c
index 356ca114d243,be4121c867c3..000000000000
--- a/drivers/net/ethernet/qlogic/qede/qede_main.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_main.c
@@@ -2889,8 -1154,9 +2889,13 @@@ static int qede_alloc_mem_rxq(struct qe
  		goto err;
  
  	/* Allocate buffers for the Rx ring */
+ 	rxq->filled_buffers = 0;
  	for (i = 0; i < rxq->num_rx_buffers; i++) {
++<<<<<<< HEAD
 +		rc = qede_alloc_rx_buffer(edev, rxq);
++=======
+ 		rc = qede_alloc_rx_buffer(rxq, false);
++>>>>>>> e3eef7ee0201 (qede: Postpone reallocation until NAPI end)
  		if (rc) {
  			DP_ERR(edev,
  			       "Rx buffers allocation failed at index %d\n", i);
* Unmerged path drivers/net/ethernet/qlogic/qede/qede_fp.c
* Unmerged path drivers/net/ethernet/qlogic/qede/qede.h
* Unmerged path drivers/net/ethernet/qlogic/qede/qede_fp.c
* Unmerged path drivers/net/ethernet/qlogic/qede/qede_main.c
