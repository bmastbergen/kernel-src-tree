net: phy: adjust fixed_phy_register() return value

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] phy: adjust fixed_phy_register() return value (Ivan Vecera) [1382040]
Rebuild_FUZZ: 94.74%
commit-author Petri Gynther <pgynther@google.com>
commit fd2ef0ba3071c92ac6272ab22ea3f2b16d88a4eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fd2ef0ba.failed

Adjust fixed_phy_register() to return struct phy_device *, so that
it becomes easy to use fixed PHYs without device tree support:

  phydev = fixed_phy_register(PHY_POLL, &fixed_phy_status, NULL);
  fixed_phy_set_link_update(phydev, fixed_phy_link_update);
  phy_connect_direct(netdev, phydev, handler_fn, phy_interface);

This change is a prerequisite for modifying bcmgenet driver to work
without a device tree on Broadcom's MIPS-based 7xxx platforms.

	Signed-off-by: Petri Gynther <pgynther@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fd2ef0ba3071c92ac6272ab22ea3f2b16d88a4eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/of_mdio.c
diff --cc drivers/of/of_mdio.c
index d5a57a9e329c,1bd43053b8c7..000000000000
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@@ -211,39 -231,92 +211,114 @@@ struct phy_device *of_phy_connect(struc
  EXPORT_SYMBOL(of_phy_connect);
  
  /**
 - * of_phy_attach - Attach to a PHY without starting the state machine
 + * of_phy_connect_fixed_link - Parse fixed-link property and return a dummy phy
   * @dev: pointer to net_device claiming the phy
 - * @phy_np: Node pointer for the PHY
 - * @flags: flags to pass to the PHY
 + * @hndlr: Link state callback for the network device
   * @iface: PHY data interface type
 + *
 + * This function is a temporary stop-gap and will be removed soon.  It is
 + * only to support the fs_enet, ucc_geth and gianfar Ethernet drivers.  Do
 + * not call this function from new drivers.
   */
 -struct phy_device *of_phy_attach(struct net_device *dev,
 -				 struct device_node *phy_np, u32 flags,
 -				 phy_interface_t iface)
 +struct phy_device *of_phy_connect_fixed_link(struct net_device *dev,
 +					     void (*hndlr)(struct net_device *),
 +					     phy_interface_t iface)
  {
 -	struct phy_device *phy = of_phy_find_device(phy_np);
 +	struct device_node *net_np;
 +	char bus_id[MII_BUS_ID_SIZE + 3];
 +	struct phy_device *phy;
 +	const __be32 *phy_id;
 +	int sz;
  
 -	if (!phy)
 +	if (!dev->dev.parent)
 +		return NULL;
 +
 +	net_np = dev->dev.parent->of_node;
 +	if (!net_np)
  		return NULL;
  
 -	return phy_attach_direct(dev, phy, flags, iface) ? NULL : phy;
 +	phy_id = of_get_property(net_np, "fixed-link", &sz);
 +	if (!phy_id || sz < sizeof(*phy_id))
 +		return NULL;
 +
 +	sprintf(bus_id, PHY_ID_FMT, "fixed-0", be32_to_cpu(phy_id[0]));
 +
 +	phy = phy_connect(dev, bus_id, hndlr, iface);
 +	return IS_ERR(phy) ? NULL : phy;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(of_phy_connect_fixed_link);
++=======
+ EXPORT_SYMBOL(of_phy_attach);
+ 
+ #if defined(CONFIG_FIXED_PHY)
+ /*
+  * of_phy_is_fixed_link() and of_phy_register_fixed_link() must
+  * support two DT bindings:
+  * - the old DT binding, where 'fixed-link' was a property with 5
+  *   cells encoding various informations about the fixed PHY
+  * - the new DT binding, where 'fixed-link' is a sub-node of the
+  *   Ethernet device.
+  */
+ bool of_phy_is_fixed_link(struct device_node *np)
+ {
+ 	struct device_node *dn;
+ 	int len;
+ 
+ 	/* New binding */
+ 	dn = of_get_child_by_name(np, "fixed-link");
+ 	if (dn) {
+ 		of_node_put(dn);
+ 		return true;
+ 	}
+ 
+ 	/* Old binding */
+ 	if (of_get_property(np, "fixed-link", &len) &&
+ 	    len == (5 * sizeof(__be32)))
+ 		return true;
+ 
+ 	return false;
+ }
+ EXPORT_SYMBOL(of_phy_is_fixed_link);
+ 
+ int of_phy_register_fixed_link(struct device_node *np)
+ {
+ 	struct fixed_phy_status status = {};
+ 	struct device_node *fixed_link_node;
+ 	const __be32 *fixed_link_prop;
+ 	int len;
+ 	struct phy_device *phy;
+ 
+ 	/* New binding */
+ 	fixed_link_node = of_get_child_by_name(np, "fixed-link");
+ 	if (fixed_link_node) {
+ 		status.link = 1;
+ 		status.duplex = of_property_read_bool(fixed_link_node,
+ 						      "full-duplex");
+ 		if (of_property_read_u32(fixed_link_node, "speed", &status.speed))
+ 			return -EINVAL;
+ 		status.pause = of_property_read_bool(fixed_link_node, "pause");
+ 		status.asym_pause = of_property_read_bool(fixed_link_node,
+ 							  "asym-pause");
+ 		of_node_put(fixed_link_node);
+ 		phy = fixed_phy_register(PHY_POLL, &status, np);
+ 		return IS_ERR(phy) ? PTR_ERR(phy) : 0;
+ 	}
+ 
+ 	/* Old binding */
+ 	fixed_link_prop = of_get_property(np, "fixed-link", &len);
+ 	if (fixed_link_prop && len == (5 * sizeof(__be32))) {
+ 		status.link = 1;
+ 		status.duplex = be32_to_cpu(fixed_link_prop[1]);
+ 		status.speed = be32_to_cpu(fixed_link_prop[2]);
+ 		status.pause = be32_to_cpu(fixed_link_prop[3]);
+ 		status.asym_pause = be32_to_cpu(fixed_link_prop[4]);
+ 		phy = fixed_phy_register(PHY_POLL, &status, np);
+ 		return IS_ERR(phy) ? PTR_ERR(phy) : 0;
+ 	}
+ 
+ 	return -ENODEV;
+ }
+ EXPORT_SYMBOL(of_phy_register_fixed_link);
+ #endif
++>>>>>>> fd2ef0ba3071 (net: phy: adjust fixed_phy_register() return value)
diff --git a/drivers/net/phy/fixed_phy.c b/drivers/net/phy/fixed_phy.c
index 24dad3be2c22..b3da87afb2e6 100644
--- a/drivers/net/phy/fixed_phy.c
+++ b/drivers/net/phy/fixed_phy.c
@@ -262,9 +262,9 @@ EXPORT_SYMBOL_GPL(fixed_phy_del);
 static int phy_fixed_addr;
 static DEFINE_SPINLOCK(phy_fixed_addr_lock);
 
-int fixed_phy_register(unsigned int irq,
-		       struct fixed_phy_status *status,
-		       struct device_node *np)
+struct phy_device *fixed_phy_register(unsigned int irq,
+				      struct fixed_phy_status *status,
+				      struct device_node *np)
 {
 	struct fixed_mdio_bus *fmb = &platform_fmb;
 	struct phy_device *phy;
@@ -275,19 +275,19 @@ int fixed_phy_register(unsigned int irq,
 	spin_lock(&phy_fixed_addr_lock);
 	if (phy_fixed_addr == PHY_MAX_ADDR) {
 		spin_unlock(&phy_fixed_addr_lock);
-		return -ENOSPC;
+		return ERR_PTR(-ENOSPC);
 	}
 	phy_addr = phy_fixed_addr++;
 	spin_unlock(&phy_fixed_addr_lock);
 
 	ret = fixed_phy_add(PHY_POLL, phy_addr, status);
 	if (ret < 0)
-		return ret;
+		return ERR_PTR(ret);
 
 	phy = get_phy_device(fmb->mii_bus, phy_addr, false);
 	if (!phy || IS_ERR(phy)) {
 		fixed_phy_del(phy_addr);
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 	}
 
 	of_node_get(np);
@@ -298,10 +298,10 @@ int fixed_phy_register(unsigned int irq,
 		phy_device_free(phy);
 		of_node_put(np);
 		fixed_phy_del(phy_addr);
-		return ret;
+		return ERR_PTR(ret);
 	}
 
-	return 0;
+	return phy;
 }
 EXPORT_SYMBOL_GPL(fixed_phy_register);
 
* Unmerged path drivers/of/of_mdio.c
diff --git a/include/linux/phy_fixed.h b/include/linux/phy_fixed.h
index 1ae156fd15c7..fe5732d53eda 100644
--- a/include/linux/phy_fixed.h
+++ b/include/linux/phy_fixed.h
@@ -14,9 +14,9 @@ struct device_node;
 #if IS_ENABLED(CONFIG_FIXED_PHY)
 extern int fixed_phy_add(unsigned int irq, int phy_id,
 			 struct fixed_phy_status *status);
-extern int fixed_phy_register(unsigned int irq,
-			      struct fixed_phy_status *status,
-			      struct device_node *np);
+extern struct phy_device *fixed_phy_register(unsigned int irq,
+					     struct fixed_phy_status *status,
+					     struct device_node *np);
 extern void fixed_phy_del(int phy_addr);
 extern int fixed_phy_set_link_update(struct phy_device *phydev,
 			int (*link_update)(struct net_device *,
@@ -30,11 +30,11 @@ static inline int fixed_phy_add(unsigned int irq, int phy_id,
 {
 	return -ENODEV;
 }
-static inline int fixed_phy_register(unsigned int irq,
-				     struct fixed_phy_status *status,
-				     struct device_node *np)
+static inline struct phy_device *fixed_phy_register(unsigned int irq,
+						struct fixed_phy_status *status,
+						struct device_node *np)
 {
-	return -ENODEV;
+	return ERR_PTR(-ENODEV);
 }
 static inline int fixed_phy_del(int phy_addr)
 {
