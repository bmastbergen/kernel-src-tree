btrfs: limit async_work allocation and worker func duration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Maxim Patlasov <mpatlasov@virtuozzo.com>
commit 2939e1a86f758b55cdba73e29397dd3d94df13bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2939e1a8.failed

Problem statement: unprivileged user who has read-write access to more than
one btrfs subvolume may easily consume all kernel memory (eventually
triggering oom-killer).

Reproducer (./mkrmdir below essentially loops over mkdir/rmdir):

[root@kteam1 ~]# cat prep.sh

DEV=/dev/sdb
mkfs.btrfs -f $DEV
mount $DEV /mnt
for i in `seq 1 16`
do
	mkdir /mnt/$i
	btrfs subvolume create /mnt/SV_$i
	ID=`btrfs subvolume list /mnt |grep "SV_$i$" |cut -d ' ' -f 2`
	mount -t btrfs -o subvolid=$ID $DEV /mnt/$i
	chmod a+rwx /mnt/$i
done

[root@kteam1 ~]# sh prep.sh

[maxim@kteam1 ~]$ for i in `seq 1 16`; do ./mkrmdir /mnt/$i 2000 2000 & done

[root@kteam1 ~]# for i in `seq 1 4`; do grep "kmalloc-128" /proc/slabinfo | grep -v dma; sleep 60; done
kmalloc-128        10144  10144    128   32    1 : tunables    0    0    0 : slabdata    317    317      0
kmalloc-128       9992352 9992352    128   32    1 : tunables    0    0    0 : slabdata 312261 312261      0
kmalloc-128       24226752 24226752    128   32    1 : tunables    0    0    0 : slabdata 757086 757086      0
kmalloc-128       42754240 42754240    128   32    1 : tunables    0    0    0 : slabdata 1336070 1336070      0

The huge numbers above come from insane number of async_work-s allocated
and queued by btrfs_wq_run_delayed_node.

The problem is caused by btrfs_wq_run_delayed_node() queuing more and more
works if the number of delayed items is above BTRFS_DELAYED_BACKGROUND. The
worker func (btrfs_async_run_delayed_root) processes at least
BTRFS_DELAYED_BATCH items (if they are present in the list). So, the machinery
works as expected while the list is almost empty. As soon as it is getting
bigger, worker func starts to process more than one item at a time, it takes
longer, and the chances to have async_works queued more than needed is getting
higher.

The problem above is worsened by another flaw of delayed-inode implementation:
if async_work was queued in a throttling branch (number of items >=
BTRFS_DELAYED_WRITEBACK), corresponding worker func won't quit until
the number of items < BTRFS_DELAYED_BACKGROUND / 2. So, it is possible that
the func occupies CPU infinitely (up to 30sec in my experiments): while the
func is trying to drain the list, the user activity may add more and more
items to the list.

The patch fixes both problems in straightforward way: refuse queuing too
many works in btrfs_wq_run_delayed_node and bail out of worker func if
at least BTRFS_DELAYED_WRITEBACK items are processed.

Changed in v2: remove support of thresh == NO_THRESHOLD.

	Signed-off-by: Maxim Patlasov <mpatlasov@virtuozzo.com>
	Signed-off-by: Chris Mason <clm@fb.com>
	Cc: stable@vger.kernel.org # v3.15+
(cherry picked from commit 2939e1a86f758b55cdba73e29397dd3d94df13bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/async-thread.c
#	fs/btrfs/async-thread.h
diff --cc fs/btrfs/async-thread.c
index 5fb60ea7eee2,63d197724519..000000000000
--- a/fs/btrfs/async-thread.c
+++ b/fs/btrfs/async-thread.c
@@@ -70,6 -74,32 +70,35 @@@ void btrfs_##name(struct work_struct *a
  	normal_work_helper(work);					\
  }
  
++<<<<<<< HEAD
++=======
+ struct btrfs_fs_info *
+ btrfs_workqueue_owner(struct __btrfs_workqueue *wq)
+ {
+ 	return wq->fs_info;
+ }
+ 
+ struct btrfs_fs_info *
+ btrfs_work_owner(struct btrfs_work *work)
+ {
+ 	return work->wq->fs_info;
+ }
+ 
+ bool btrfs_workqueue_normal_congested(struct btrfs_workqueue *wq)
+ {
+ 	/*
+ 	 * We could compare wq->normal->pending with num_online_cpus()
+ 	 * to support "thresh == NO_THRESHOLD" case, but it requires
+ 	 * moving up atomic_inc/dec in thresh_queue/exec_hook. Let's
+ 	 * postpone it until someone needs the support of that case.
+ 	 */
+ 	if (wq->normal->thresh == NO_THRESHOLD)
+ 		return false;
+ 
+ 	return atomic_read(&wq->normal->pending) > wq->normal->thresh * 2;
+ }
+ 
++>>>>>>> 2939e1a86f75 (btrfs: limit async_work allocation and worker func duration)
  BTRFS_WORK_HELPER(worker_helper);
  BTRFS_WORK_HELPER(delalloc_helper);
  BTRFS_WORK_HELPER(flush_delalloc_helper);
diff --cc fs/btrfs/async-thread.h
index 5231d3586e32,1f9597355c9d..000000000000
--- a/fs/btrfs/async-thread.h
+++ b/fs/btrfs/async-thread.h
@@@ -79,4 -82,7 +79,10 @@@ void btrfs_queue_work(struct btrfs_work
  void btrfs_destroy_workqueue(struct btrfs_workqueue *wq);
  void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max);
  void btrfs_set_work_high_priority(struct btrfs_work *work);
++<<<<<<< HEAD
++=======
+ struct btrfs_fs_info *btrfs_work_owner(struct btrfs_work *work);
+ struct btrfs_fs_info *btrfs_workqueue_owner(struct __btrfs_workqueue *wq);
+ bool btrfs_workqueue_normal_congested(struct btrfs_workqueue *wq);
++>>>>>>> 2939e1a86f75 (btrfs: limit async_work allocation and worker func duration)
  #endif
* Unmerged path fs/btrfs/async-thread.c
* Unmerged path fs/btrfs/async-thread.h
diff --git a/fs/btrfs/delayed-inode.c b/fs/btrfs/delayed-inode.c
index 8da4df4fc073..3f2872aeb3c7 100644
--- a/fs/btrfs/delayed-inode.c
+++ b/fs/btrfs/delayed-inode.c
@@ -1353,7 +1353,8 @@ release_path:
 	total_done++;
 
 	btrfs_release_prepared_delayed_node(delayed_node);
-	if (async_work->nr == 0 || total_done < async_work->nr)
+	if ((async_work->nr == 0 && total_done < BTRFS_DELAYED_WRITEBACK) ||
+	    total_done < async_work->nr)
 		goto again;
 
 free_path:
@@ -1369,7 +1370,8 @@ static int btrfs_wq_run_delayed_node(struct btrfs_delayed_root *delayed_root,
 {
 	struct btrfs_async_delayed_work *async_work;
 
-	if (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND)
+	if (atomic_read(&delayed_root->items) < BTRFS_DELAYED_BACKGROUND ||
+	    btrfs_workqueue_normal_congested(fs_info->delayed_workers))
 		return 0;
 
 	async_work = kmalloc(sizeof(*async_work), GFP_NOFS);
