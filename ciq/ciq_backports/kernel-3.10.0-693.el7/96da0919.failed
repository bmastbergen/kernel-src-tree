btrfs: Introduce new mount option to disable tree log replay

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Qu Wenruo <quwenruo@cn.fujitsu.com>
commit 96da09192cda57a356467bd7c91a3641a2e78490
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/96da0919.failed

Introduce a new mount option "nologreplay" to co-operate with "ro" mount
option to get real readonly mount, like "norecovery" in ext* and xfs.

Since the new parse_options() need to check new flags at remount time,
so add a new parameter for parse_options().

	Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
	Reviewed-by: Chandan Rajendra <chandan@linux.vnet.ibm.com>
	Tested-by: Austin S. Hemmelgarn <ahferroin7@gmail.com>
	Signed-off-by: David Sterba <dsterba@suse.com>
(cherry picked from commit 96da09192cda57a356467bd7c91a3641a2e78490)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/filesystems/btrfs.txt
#	fs/btrfs/ctree.h
#	fs/btrfs/super.c
diff --cc Documentation/filesystems/btrfs.txt
index f97b4dc0578f,6593d2e415c5..000000000000
--- a/Documentation/filesystems/btrfs.txt
+++ b/Documentation/filesystems/btrfs.txt
@@@ -168,10 -168,23 +168,25 @@@ Options with (*) are default options an
    notreelog
  	Enable/disable the tree logging used for fsync and O_SYNC writes.
  
++<<<<<<< HEAD
 +  recovery
 +	Enable autorecovery attempts if a bad tree root is found at mount time.
 +	Currently this scans a list of several previous tree roots and tries to 
++=======
+   nologreplay
+ 	Disable the log tree replay at mount time to prevent filesystem
+ 	from getting modified.
+ 	Must be used with 'ro' mount option.
+ 	A filesystem mounted with this option cannot transition to a
+ 	read-write mount via remount,rw - the filesystem must be unmounted
+ 	and mounted back again if read-write access is desired.
+ 
+   usebackuproot
+ 	Enable attempts to use backup tree roots if a bad tree root is found at
+ 	mount time.
+ 	Currently this scans a list of 4 previous tree roots and tries to
++>>>>>>> 96da09192cda (btrfs: Introduce new mount option to disable tree log replay)
  	use the first readable.
 -	And since the mount option doesn't affect any behavior after mount,
 -	it won't be shown in mount info.
 -	Prior to 4.6, this was done by 'recovery' option that has been
 -	deprecated, but will work.
  
    rescan_uuid_tree
  	Force check and rebuild procedure of the UUID tree. This should not
diff --cc fs/btrfs/ctree.h
index c4e61965ae55,a79bb734f6c3..000000000000
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@@ -2271,6 -2249,8 +2271,11 @@@ struct btrfs_ioctl_defrag_range_args 
  #define BTRFS_MOUNT_RESCAN_UUID_TREE	(1 << 23)
  #define BTRFS_MOUNT_FRAGMENT_DATA	(1 << 24)
  #define BTRFS_MOUNT_FRAGMENT_METADATA	(1 << 25)
++<<<<<<< HEAD
++=======
+ #define BTRFS_MOUNT_FREE_SPACE_TREE	(1 << 26)
+ #define BTRFS_MOUNT_NOLOGREPLAY		(1 << 27)
++>>>>>>> 96da09192cda (btrfs: Introduce new mount option to disable tree log replay)
  
  #define BTRFS_DEFAULT_COMMIT_INTERVAL	(30)
  #define BTRFS_DEFAULT_MAX_INLINE	(8192)
diff --cc fs/btrfs/super.c
index a840b471f796,e8a7a9f88195..000000000000
--- a/fs/btrfs/super.c
+++ b/fs/btrfs/super.c
@@@ -302,7 -303,8 +302,12 @@@ enum 
  	Opt_check_integrity_print_mask, Opt_fatal_errors, Opt_rescan_uuid_tree,
  	Opt_commit_interval, Opt_barrier, Opt_nodefrag, Opt_nodiscard,
  	Opt_noenospc_debug, Opt_noflushoncommit, Opt_acl, Opt_datacow,
++<<<<<<< HEAD
 +	Opt_datasum, Opt_treelog, Opt_noinode_cache,
++=======
+ 	Opt_datasum, Opt_treelog, Opt_noinode_cache, Opt_usebackuproot,
+ 	Opt_nologreplay,
++>>>>>>> 96da09192cda (btrfs: Introduce new mount option to disable tree log replay)
  #ifdef CONFIG_BTRFS_DEBUG
  	Opt_fragment_data, Opt_fragment_metadata, Opt_fragment_all,
  #endif
@@@ -386,11 -392,17 +393,15 @@@ int btrfs_parse_options(struct btrfs_ro
  	int no_compress = 0;
  
  	cache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);
 -	if (btrfs_fs_compat_ro(root->fs_info, FREE_SPACE_TREE))
 -		btrfs_set_opt(info->mount_opt, FREE_SPACE_TREE);
 -	else if (cache_gen)
 +	if (cache_gen)
  		btrfs_set_opt(info->mount_opt, SPACE_CACHE);
  
+ 	/*
+ 	 * Even the options are empty, we still need to do extra check
+ 	 * against new flags
+ 	 */
  	if (!options)
- 		goto out;
+ 		goto check;
  
  	/*
  	 * strsep changes the string, duplicate it because parse_options
@@@ -768,9 -808,27 +783,18 @@@
  			break;
  		}
  	}
+ check:
+ 	/*
+ 	 * Extra check for current option against current flag
+ 	 */
+ 	if (btrfs_test_opt(root, NOLOGREPLAY) && !(new_flags & MS_RDONLY)) {
+ 		btrfs_err(root->fs_info,
+ 			  "nologreplay must be used with ro mount option");
+ 		ret = -EINVAL;
+ 	}
  out:
 -	if (btrfs_fs_compat_ro(root->fs_info, FREE_SPACE_TREE) &&
 -	    !btrfs_test_opt(root, FREE_SPACE_TREE) &&
 -	    !btrfs_test_opt(root, CLEAR_CACHE)) {
 -		btrfs_err(root->fs_info, "cannot disable free space tree");
 -		ret = -EINVAL;
 -
 -	}
  	if (!ret && btrfs_test_opt(root, SPACE_CACHE))
  		btrfs_info(root->fs_info, "disk space caching is enabled");
 -	if (!ret && btrfs_test_opt(root, FREE_SPACE_TREE))
 -		btrfs_info(root->fs_info, "using free space tree");
  	kfree(orig);
  	return ret;
  }
* Unmerged path Documentation/filesystems/btrfs.txt
* Unmerged path fs/btrfs/ctree.h
diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index f496335743a6..9ac3fed4cb3b 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -2732,7 +2732,7 @@ int open_ctree(struct super_block *sb,
 	 */
 	fs_info->compress_type = BTRFS_COMPRESS_ZLIB;
 
-	ret = btrfs_parse_options(tree_root, options);
+	ret = btrfs_parse_options(tree_root, options, sb->s_flags);
 	if (ret) {
 		err = ret;
 		goto fail_alloc;
@@ -3011,8 +3011,9 @@ retry_root_backup:
 	if (ret)
 		goto fail_trans_kthread;
 
-	/* do not make disk changes in broken FS */
-	if (btrfs_super_log_root(disk_super) != 0) {
+	/* do not make disk changes in broken FS or nologreplay is given */
+	if (btrfs_super_log_root(disk_super) != 0 &&
+	    !btrfs_test_opt(tree_root, NOLOGREPLAY)) {
 		ret = btrfs_replay_log(fs_info, fs_devices);
 		if (ret) {
 			err = ret;
* Unmerged path fs/btrfs/super.c
