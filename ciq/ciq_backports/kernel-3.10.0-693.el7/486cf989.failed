blk-mq: Introduce blk_mq_reinit_tagset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Sagi Grimberg <sagi@grimberg.me>
commit 486cf9899e311838b6ab95d19ff87c4da44d6508
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/486cf989.failed

The new nvme-rdma driver will need to reinitialize all the tags as part of
the error recovery procedure (realloc the tag memory region). Add a helper
in blk-mq for it that can iterate over all requests in a tagset to make
this easier.

	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Tested-by: Ming Lin <ming.l@ssi.samsung.com>
	Reviewed-by: Stephen Bates <Stephen.Bates@pmcs.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Steve Wise <swise@opengridcomputing.com>
	Tested-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 486cf9899e311838b6ab95d19ff87c4da44d6508)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/blk-mq.h
diff --cc include/linux/blk-mq.h
index 0e7b0244ac77,e43bbffb5b7a..000000000000
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@@ -176,15 -146,7 +177,19 @@@ struct blk_mq_ops 
  	 */
  	init_request_fn		*init_request;
  	exit_request_fn		*exit_request;
++<<<<<<< HEAD
 +#endif
 +
 +	/*
 +	 * Called when the block layer side of a hardware queue has been
 +	 * set up, allowing the driver to allocate/init matching structures.
 +	 * Ditto for exit/teardown.
 +	 */
 +	init_hctx_fn		*init_hctx;
 +	exit_hctx_fn		*exit_hctx;
++=======
+ 	reinit_request_fn	*reinit_request;
++>>>>>>> 486cf9899e31 (blk-mq: Introduce blk_mq_reinit_tagset)
  };
  
  enum {
diff --git a/block/blk-mq-tag.c b/block/blk-mq-tag.c
index d97f0822078c..7323c4337604 100644
--- a/block/blk-mq-tag.c
+++ b/block/blk-mq-tag.c
@@ -480,6 +480,32 @@ void blk_mq_tagset_busy_iter(struct blk_mq_tag_set *tagset,
 }
 EXPORT_SYMBOL(blk_mq_tagset_busy_iter);
 
+int blk_mq_reinit_tagset(struct blk_mq_tag_set *set)
+{
+	int i, j, ret = 0;
+
+	if (!set->ops->reinit_request)
+		goto out;
+
+	for (i = 0; i < set->nr_hw_queues; i++) {
+		struct blk_mq_tags *tags = set->tags[i];
+
+		for (j = 0; j < tags->nr_tags; j++) {
+			if (!tags->rqs[j])
+				continue;
+
+			ret = set->ops->reinit_request(set->driver_data,
+						tags->rqs[j]);
+			if (ret)
+				goto out;
+		}
+	}
+
+out:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(blk_mq_reinit_tagset);
+
 void blk_mq_queue_tag_busy_iter(struct request_queue *q, busy_iter_fn *fn,
 		void *priv)
 {
* Unmerged path include/linux/blk-mq.h
