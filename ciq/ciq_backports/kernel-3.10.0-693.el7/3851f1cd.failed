SUNRPC: Limit the reconnect backoff timer to the max RPC message timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 3851f1cdb2b8d507b10395fc110d4c37d6121285
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3851f1cd.failed

...and ensure that we propagate it to new transports on the same
client.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 3851f1cdb2b8d507b10395fc110d4c37d6121285)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtsock.c
diff --cc net/sunrpc/xprtsock.c
index 90ddaee8ee0a,8ede3bc52481..000000000000
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@@ -2361,6 -2385,25 +2360,28 @@@ out
  	xprt_wake_pending_tasks(xprt, status);
  }
  
++<<<<<<< HEAD
++=======
+ static unsigned long xs_reconnect_delay(const struct rpc_xprt *xprt)
+ {
+ 	unsigned long start, now = jiffies;
+ 
+ 	start = xprt->stat.connect_start + xprt->reestablish_timeout;
+ 	if (time_after(start, now))
+ 		return start - now;
+ 	return 0;
+ }
+ 
+ static void xs_reconnect_backoff(struct rpc_xprt *xprt)
+ {
+ 	xprt->reestablish_timeout <<= 1;
+ 	if (xprt->reestablish_timeout > xprt->max_reconnect_timeout)
+ 		xprt->reestablish_timeout = xprt->max_reconnect_timeout;
+ 	if (xprt->reestablish_timeout < XS_TCP_INIT_REEST_TO)
+ 		xprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;
+ }
+ 
++>>>>>>> 3851f1cdb2b8 (SUNRPC: Limit the reconnect backoff timer to the max RPC message timeout)
  /**
   * xs_connect - connect a socket to a remote endpoint
   * @xprt: pointer to transport structure
@@@ -2389,19 -2433,15 +2410,26 @@@ static void xs_connect(struct rpc_xprt 
  		/* Start by resetting any existing state */
  		xs_reset_transport(transport);
  
++<<<<<<< HEAD
 +		queue_delayed_work(rpciod_workqueue,
 +				   &transport->connect_worker,
 +				   xprt->reestablish_timeout);
 +		xprt->reestablish_timeout <<= 1;
 +		if (xprt->reestablish_timeout < XS_TCP_INIT_REEST_TO)
 +			xprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;
 +		if (xprt->reestablish_timeout > XS_TCP_MAX_REEST_TO)
 +			xprt->reestablish_timeout = XS_TCP_MAX_REEST_TO;
 +	} else {
++=======
+ 		delay = xs_reconnect_delay(xprt);
+ 		xs_reconnect_backoff(xprt);
+ 
+ 	} else
++>>>>>>> 3851f1cdb2b8 (SUNRPC: Limit the reconnect backoff timer to the max RPC message timeout)
  		dprintk("RPC:       xs_connect scheduled xprt %p\n", xprt);
 -
 -	queue_delayed_work(xprtiod_workqueue,
 -			&transport->connect_worker,
 -			delay);
 +		queue_delayed_work(rpciod_workqueue,
 +				   &transport->connect_worker, 0);
 +	}
  }
  
  /**
diff --git a/include/linux/sunrpc/xprt.h b/include/linux/sunrpc/xprt.h
index a5425a2a0462..07c79237a87c 100644
--- a/include/linux/sunrpc/xprt.h
+++ b/include/linux/sunrpc/xprt.h
@@ -218,7 +218,8 @@ struct rpc_xprt {
 	struct work_struct	task_cleanup;
 	struct timer_list	timer;
 	unsigned long		last_used,
-				idle_timeout;
+				idle_timeout,
+				max_reconnect_timeout;
 
 	/*
 	 * Send stuff
diff --git a/net/sunrpc/clnt.c b/net/sunrpc/clnt.c
index 591f1fbf3cc2..442bcb49bca1 100644
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@ -2689,6 +2689,7 @@ int rpc_clnt_add_xprt(struct rpc_clnt *clnt,
 {
 	struct rpc_xprt_switch *xps;
 	struct rpc_xprt *xprt;
+	unsigned long reconnect_timeout;
 	unsigned char resvport;
 	int ret = 0;
 
@@ -2700,6 +2701,7 @@ int rpc_clnt_add_xprt(struct rpc_clnt *clnt,
 		return -EAGAIN;
 	}
 	resvport = xprt->resvport;
+	reconnect_timeout = xprt->max_reconnect_timeout;
 	rcu_read_unlock();
 
 	xprt = xprt_create_transport(xprtargs);
@@ -2708,6 +2710,7 @@ int rpc_clnt_add_xprt(struct rpc_clnt *clnt,
 		goto out_put_switch;
 	}
 	xprt->resvport = resvport;
+	xprt->max_reconnect_timeout = reconnect_timeout;
 
 	rpc_xprt_switch_set_roundrobin(xps);
 	if (setup) {
* Unmerged path net/sunrpc/xprtsock.c
