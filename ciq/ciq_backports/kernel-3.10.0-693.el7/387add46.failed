IB/srpt: Fix wait list processing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 387add460dc2f61567fa127bd76dab8ba6833234
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/387add46.failed

Since the wait list is not protected against concurrent access
it must be processed from the context of the completion handler.
Replace the wait list processing code in the IB CM RTU callback
handler by code that triggers a completion handler. This patch
fixes the following rare crash:

WARNING: CPU: 2 PID: 78656 at lib/list_debug.c:53 __list_del_entry+0x67/0xd0()
list_del corruption, ffff88041ae404b8->next is LIST_POISON1 (dead000000000100)
Call Trace:
 [<ffffffff81251c6b>] dump_stack+0x4f/0x74
 [<ffffffff810574ab>] warn_slowpath_common+0x8b/0xd0
 [<ffffffff81057591>] warn_slowpath_fmt+0x41/0x70
 [<ffffffff8126f007>] __list_del_entry+0x67/0xd0
 [<ffffffff8126f081>] list_del+0x11/0x40
 [<ffffffffa0265242>] srpt_cm_handler+0x172/0x1a4 [ib_srpt]
 [<ffffffffa0370370>] cm_process_work+0x20/0xf0 [ib_cm]
 [<ffffffffa0370dae>] cm_establish_handler+0xbe/0x110 [ib_cm]
 [<ffffffffa03733e7>] cm_work_handler+0x67/0xd0 [ib_cm]
 [<ffffffff8107184d>] process_one_work+0x1bd/0x460
 [<ffffffff81073148>] worker_thread+0x118/0x420
 [<ffffffff81078444>] kthread+0xe4/0x100
 [<ffffffff8151caff>] ret_from_fork+0x3f/0x70

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Alex Estrin <alex.estrin@intel.com>
	Cc: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 387add460dc2f61567fa127bd76dab8ba6833234)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/srpt/ib_srpt.c
diff --cc drivers/infiniband/ulp/srpt/ib_srpt.c
index 316f3bbb1b05,25bdaeef2520..000000000000
--- a/drivers/infiniband/ulp/srpt/ib_srpt.c
+++ b/drivers/infiniband/ulp/srpt/ib_srpt.c
@@@ -98,6 -96,7 +98,10 @@@ static void srpt_release_channel(struc
  static int srpt_queue_status(struct se_cmd *cmd);
  static void srpt_recv_done(struct ib_cq *cq, struct ib_wc *wc);
  static void srpt_send_done(struct ib_cq *cq, struct ib_wc *wc);
++<<<<<<< HEAD
++=======
+ static void srpt_process_wait_list(struct srpt_rdma_ch *ch);
++>>>>>>> 387add460dc2 (IB/srpt: Fix wait list processing)
  
  /*
   * The only allowed channel state changes are those that change the channel
@@@ -797,6 -811,39 +801,42 @@@ out
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * srpt_zerolength_write() - Perform a zero-length RDMA write.
+  *
+  * A quote from the InfiniBand specification: C9-88: For an HCA responder
+  * using Reliable Connection service, for each zero-length RDMA READ or WRITE
+  * request, the R_Key shall not be validated, even if the request includes
+  * Immediate data.
+  */
+ static int srpt_zerolength_write(struct srpt_rdma_ch *ch)
+ {
+ 	struct ib_send_wr wr, *bad_wr;
+ 
+ 	memset(&wr, 0, sizeof(wr));
+ 	wr.opcode = IB_WR_RDMA_WRITE;
+ 	wr.wr_cqe = &ch->zw_cqe;
+ 	wr.send_flags = IB_SEND_SIGNALED;
+ 	return ib_post_send(ch->qp, &wr, &bad_wr);
+ }
+ 
+ static void srpt_zerolength_write_done(struct ib_cq *cq, struct ib_wc *wc)
+ {
+ 	struct srpt_rdma_ch *ch = cq->cq_context;
+ 
+ 	if (wc->status == IB_WC_SUCCESS) {
+ 		srpt_process_wait_list(ch);
+ 	} else {
+ 		if (srpt_set_ch_state(ch, CH_DISCONNECTED))
+ 			schedule_work(&ch->release_work);
+ 		else
+ 			WARN_ONCE("%s-%d\n", ch->sess_name, ch->qp->qp_num);
+ 	}
+ }
+ 
+ /**
++>>>>>>> 387add460dc2 (IB/srpt: Fix wait list processing)
   * srpt_get_desc_tbl() - Parse the data descriptors of an SRP_CMD request.
   * @ioctx: Pointer to the I/O context associated with the request.
   * @srp_cmd: Pointer to the SRP_CMD request data.
* Unmerged path drivers/infiniband/ulp/srpt/ib_srpt.c
