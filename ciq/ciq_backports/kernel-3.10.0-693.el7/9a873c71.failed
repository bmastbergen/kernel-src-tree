net/xen-netfront: only clean up queues if present

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] xen-netfront: only clean up queues if present (Vitaly Kuznetsov) [1102638]
Rebuild_FUZZ: 95.74%
commit-author Chas Williams <3chas3@gmail.com>
commit 9a873c71e91cabf4c10fd9bbd8358c22deaf6c9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9a873c71.failed

If you simply load and unload the module without starting the interfaces,
the queues are never created and you get a bad pointer dereference.

	Signed-off-by: Chas Williams <3chas3@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9a873c71e91cabf4c10fd9bbd8358c22deaf6c9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/xen-netfront.c
diff --cc drivers/net/xen-netfront.c
index 8896052a2ee0,002062db2f1d..000000000000
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@@ -1415,30 -1331,39 +1415,60 @@@ static void xennet_end_access(int ref, 
  
  static void xennet_disconnect_backend(struct netfront_info *info)
  {
 -	unsigned int i = 0;
 -	unsigned int num_queues = info->netdev->real_num_tx_queues;
 -
 +	/* Stop old i/f to prevent errors whilst we rebuild the state. */
 +	spin_lock_bh(&info->rx_lock);
 +	spin_lock_irq(&info->tx_lock);
  	netif_carrier_off(info->netdev);
 -
 +	spin_unlock_irq(&info->tx_lock);
 +	spin_unlock_bh(&info->rx_lock);
 +
++<<<<<<< HEAD
 +	if (info->tx_irq && (info->tx_irq == info->rx_irq))
 +		unbind_from_irqhandler(info->tx_irq, info);
 +	if (info->tx_irq && (info->tx_irq != info->rx_irq)) {
 +		unbind_from_irqhandler(info->tx_irq, info);
 +		unbind_from_irqhandler(info->rx_irq, info);
++=======
+ 	for (i = 0; i < num_queues && info->queues; ++i) {
+ 		struct netfront_queue *queue = &info->queues[i];
+ 
+ 		if (queue->tx_irq && (queue->tx_irq == queue->rx_irq))
+ 			unbind_from_irqhandler(queue->tx_irq, queue);
+ 		if (queue->tx_irq && (queue->tx_irq != queue->rx_irq)) {
+ 			unbind_from_irqhandler(queue->tx_irq, queue);
+ 			unbind_from_irqhandler(queue->rx_irq, queue);
+ 		}
+ 		queue->tx_evtchn = queue->rx_evtchn = 0;
+ 		queue->tx_irq = queue->rx_irq = 0;
+ 
+ 		napi_synchronize(&queue->napi);
+ 
+ 		xennet_release_tx_bufs(queue);
+ 		xennet_release_rx_bufs(queue);
+ 		gnttab_free_grant_references(queue->gref_tx_head);
+ 		gnttab_free_grant_references(queue->gref_rx_head);
+ 
+ 		/* End access and free the pages */
+ 		xennet_end_access(queue->tx_ring_ref, queue->tx.sring);
+ 		xennet_end_access(queue->rx_ring_ref, queue->rx.sring);
+ 
+ 		queue->tx_ring_ref = GRANT_INVALID_REF;
+ 		queue->rx_ring_ref = GRANT_INVALID_REF;
+ 		queue->tx.sring = NULL;
+ 		queue->rx.sring = NULL;
++>>>>>>> 9a873c71e91c (net/xen-netfront: only clean up queues if present)
  	}
 +	info->tx_evtchn = info->rx_evtchn = 0;
 +	info->tx_irq = info->rx_irq = 0;
 +
 +	/* End access and free the pages */
 +	xennet_end_access(info->tx_ring_ref, info->tx.sring);
 +	xennet_end_access(info->rx_ring_ref, info->rx.sring);
 +
 +	info->tx_ring_ref = GRANT_INVALID_REF;
 +	info->rx_ring_ref = GRANT_INVALID_REF;
 +	info->tx.sring = NULL;
 +	info->rx.sring = NULL;
  }
  
  /**
@@@ -2046,15 -2099,11 +2076,21 @@@ static int xennet_remove(struct xenbus_
  
  	xennet_disconnect_backend(info);
  
 +	xennet_sysfs_delif(info->netdev);
 +
  	unregister_netdev(info->netdev);
  
++<<<<<<< HEAD
 +	del_timer_sync(&info->rx_refill_timer);
 +
 +	free_percpu(info->stats);
 +
 +	free_netdev(info->netdev);
++=======
+ 	if (info->queues)
+ 		xennet_destroy_queues(info);
+ 	xennet_free_netdev(info->netdev);
++>>>>>>> 9a873c71e91c (net/xen-netfront: only clean up queues if present)
  
  	return 0;
  }
* Unmerged path drivers/net/xen-netfront.c
