flow_dissector: Don't use bit fields.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David S. Miller <davem@davemloft.net>
commit 4b36993d3df0834eff3b4172962de0343a4d9123
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4b36993d.failed

Just have a flags member instead.

   In file included from include/linux/linkage.h:4:0,
                    from include/linux/kernel.h:6,
                    from net/core/flow_dissector.c:1:
   In function 'flow_keys_hash_start',
       inlined from 'flow_hash_from_keys' at net/core/flow_dissector.c:553:34:
>> include/linux/compiler.h:447:38: error: call to '__compiletime_assert_459' declared with attribute error: BUILD_BUG_ON failed: FLOW_KEYS_HASH_OFFSET % sizeof(u32)

	Reported-by: kbuild test robot <fengguang.wu@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4b36993d3df0834eff3b4172962de0343a4d9123)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_dissector.h
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,8d32020303c6..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -145,15 -177,39 +145,43 @@@ ip
  		nhoff += iph->ihl * 4;
  
  		ip_proto = iph->protocol;
 +		if (ip_is_fragment(iph))
 +			ip_proto = 0;
  
++<<<<<<< HEAD
 +		iph_to_flow_copy_addrs(flow, iph);
++=======
+ 		if (!skb_flow_dissector_uses_key(flow_dissector,
+ 						 FLOW_DISSECTOR_KEY_IPV4_ADDRS))
+ 			break;
+ 
+ 		key_addrs = skb_flow_dissector_target(flow_dissector,
+ 			      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);
+ 		memcpy(&key_addrs->v4addrs, &iph->saddr,
+ 		       sizeof(key_addrs->v4addrs));
+ 		key_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
+ 
+ 		if (ip_is_fragment(iph)) {
+ 			key_control->flags |= FLOW_DIS_IS_FRAGMENT;
+ 
+ 			if (iph->frag_off & htons(IP_OFFSET)) {
+ 				goto out_good;
+ 			} else {
+ 				key_control->flags |= FLOW_DIS_FIRST_FRAG;
+ 				if (!(flags & FLOW_DISSECTOR_F_PARSE_1ST_FRAG))
+ 					goto out_good;
+ 			}
+ 		}
+ 
+ 		if (flags & FLOW_DISSECTOR_F_STOP_AT_L3)
+ 			goto out_good;
+ 
++>>>>>>> 4b36993d3df0 (flow_dissector: Don't use bit fields.)
  		break;
  	}
 -	case htons(ETH_P_IPV6): {
 +	case __constant_htons(ETH_P_IPV6): {
  		const struct ipv6hdr *iph;
  		struct ipv6hdr _iph;
 -		__be32 flow_label;
 -
  ipv6:
  		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
  		if (!iph)
@@@ -241,30 -357,52 +269,53 @@@ ip_proto_again
  		 * Only look inside GRE if version zero and no
  		 * routing
  		 */
 -		if (hdr->flags & (GRE_VERSION | GRE_ROUTING))
 -			break;
 -
 -		proto = hdr->proto;
 -		nhoff += 4;
 -		if (hdr->flags & GRE_CSUM)
 +		if (!(hdr->flags & (GRE_VERSION|GRE_ROUTING))) {
 +			proto = hdr->proto;
  			nhoff += 4;
 -		if (hdr->flags & GRE_KEY) {
 -			const __be32 *keyid;
 -			__be32 _keyid;
 -
 -			keyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),
 -						     data, hlen, &_keyid);
 -
 -			if (!keyid)
 -				goto out_bad;
 -
 -			if (skb_flow_dissector_uses_key(flow_dissector,
 -							FLOW_DISSECTOR_KEY_GRE_KEYID)) {
 -				key_keyid = skb_flow_dissector_target(flow_dissector,
 -								      FLOW_DISSECTOR_KEY_GRE_KEYID,
 -								      target_container);
 -				key_keyid->keyid = *keyid;
 +			if (hdr->flags & GRE_CSUM)
 +				nhoff += 4;
 +			if (hdr->flags & GRE_KEY)
 +				nhoff += 4;
 +			if (hdr->flags & GRE_SEQ)
 +				nhoff += 4;
 +			if (proto == htons(ETH_P_TEB)) {
 +				const struct ethhdr *eth;
 +				struct ethhdr _eth;
 +
 +				eth = __skb_header_pointer(skb, nhoff,
 +							   sizeof(_eth),
 +							   data, hlen, &_eth);
 +				if (!eth)
 +					return false;
 +				proto = eth->h_proto;
 +				nhoff += sizeof(*eth);
  			}
 -			nhoff += 4;
 +			goto again;
  		}
++<<<<<<< HEAD
 +		break;
++=======
+ 		if (hdr->flags & GRE_SEQ)
+ 			nhoff += 4;
+ 		if (proto == htons(ETH_P_TEB)) {
+ 			const struct ethhdr *eth;
+ 			struct ethhdr _eth;
+ 
+ 			eth = __skb_header_pointer(skb, nhoff,
+ 						   sizeof(_eth),
+ 						   data, hlen, &_eth);
+ 			if (!eth)
+ 				goto out_bad;
+ 			proto = eth->h_proto;
+ 			nhoff += sizeof(*eth);
+ 		}
+ 
+ 		key_control->flags |= FLOW_DIS_ENCAPSULATION;
+ 		if (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP)
+ 			goto out_good;
+ 
+ 		goto again;
++>>>>>>> 4b36993d3df0 (flow_dissector: Don't use bit fields.)
  	}
  	case NEXTHDR_HOP:
  	case NEXTHDR_ROUTING:
@@@ -311,10 -449,23 +362,26 @@@
  	}
  	case IPPROTO_IPIP:
  		proto = htons(ETH_P_IP);
++<<<<<<< HEAD
 +		goto ip;
 +	case IPPROTO_IPV6:
 +		proto = htons(ETH_P_IPV6);
++=======
+ 
+ 		key_control->flags |= FLOW_DIS_ENCAPSULATION;
+ 		if (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP)
+ 			goto out_good;
+ 
+ 		goto ip;
+ 	case IPPROTO_IPV6:
+ 		proto = htons(ETH_P_IPV6);
+ 
+ 		key_control->flags |= FLOW_DIS_ENCAPSULATION;
+ 		if (flags & FLOW_DISSECTOR_F_STOP_AT_ENCAP)
+ 			goto out_good;
+ 
++>>>>>>> 4b36993d3df0 (flow_dissector: Don't use bit fields.)
  		goto ipv6;
 -	case IPPROTO_MPLS:
 -		proto = htons(ETH_P_MPLS_UC);
 -		goto mpls;
  	default:
  		break;
  	}
* Unmerged path include/net/flow_dissector.h
* Unmerged path include/net/flow_dissector.h
* Unmerged path net/core/flow_dissector.c
