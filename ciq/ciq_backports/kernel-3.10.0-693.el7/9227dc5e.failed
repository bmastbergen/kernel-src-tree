amd-xgbe: Add support for per DMA channel interrupts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit 9227dc5e579b6b2ef58ad0d3d0d23ddac77846ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9227dc5e.failed

This patch provides support for interrupts that are generated by the
Tx/Rx DMA channel pairs of the device.  This allows for Tx and Rx
processing to run across multiple processsors.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9227dc5e579b6b2ef58ad0d3d0d23ddac77846ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/devicetree/bindings/net/amd-xgbe.txt
#	drivers/net/ethernet/amd/xgbe/xgbe-drv.c
#	drivers/net/ethernet/amd/xgbe/xgbe.h
diff --cc Documentation/devicetree/bindings/net/amd-xgbe.txt
index f6db1ba87a3f,26efd526d16c..000000000000
--- a/Documentation/devicetree/bindings/net/amd-xgbe.txt
+++ b/Documentation/devicetree/bindings/net/amd-xgbe.txt
@@@ -7,11 -7,18 +7,26 @@@ Required properties
     - PCS registers
  - interrupt-parent: Should be the phandle for the interrupt controller
    that services interrupts for this device
++<<<<<<< HEAD
 +- interrupts: Should contain the amd-xgbe interrupt
 +- clocks: Should be the DMA clock for the amd-xgbe device (used for
 +  calculating the correct Rx interrupt watchdog timer value on a DMA
 +  channel for coalescing)
 +- clock-names: Should be the name of the DMA clock, "dma_clk"
++=======
+ - interrupts: Should contain the amd-xgbe interrupt(s). The first interrupt
+   listed is required and is the general device interrupt. If the optional
+   amd,per-channel-interrupt property is specified, then one additional
+   interrupt for each DMA channel supported by the device should be specified
+ - clocks:
+    - DMA clock for the amd-xgbe device (used for calculating the
+      correct Rx interrupt watchdog timer value on a DMA channel
+      for coalescing)
+    - PTP clock for the amd-xgbe device
+ - clock-names: Should be the names of the clocks
+    - "dma_clk" for the DMA clock
+    - "ptp_clk" for the PTP clock
++>>>>>>> 9227dc5e579b (amd-xgbe: Add support for per DMA channel interrupts)
  - phy-handle: See ethernet.txt file in the same directory
  - phy-mode: See ethernet.txt file in the same directory
  
@@@ -26,9 -36,11 +44,17 @@@ Example
  		reg = <0 0xe0700000 0 0x80000>,
  		      <0 0xe0780000 0 0x80000>;
  		interrupt-parent = <&gic>;
++<<<<<<< HEAD
 +		interrupts = <0 325 4>;
 +		clocks = <&xgbe_clk>;
 +		clock-names = "dma_clk";
++=======
+ 		interrupts = <0 325 4>,
+ 			     <0 326 1>, <0 327 1>, <0 328 1>, <0 329 1>;
+ 		amd,per-channel-interrupt;
+ 		clocks = <&xgbe_dma_clk>, <&xgbe_ptp_clk>;
+ 		clock-names = "dma_clk", "ptp_clk";
++>>>>>>> 9227dc5e579b (amd-xgbe: Add support for per DMA channel interrupts)
  		phy-handle = <&phy>;
  		phy-mode = "xgmii";
  		mac-address = [ 02 a1 a2 a3 a4 a5 ];
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index 6baf601c4282,c3533e104c61..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@@ -124,10 -127,99 +125,106 @@@
  #include "xgbe.h"
  #include "xgbe-common.h"
  
++<<<<<<< HEAD
 +
 +static int xgbe_poll(struct napi_struct *, int);
 +static void xgbe_set_rx_mode(struct net_device *);
 +
++=======
+ static int xgbe_one_poll(struct napi_struct *, int);
+ static int xgbe_all_poll(struct napi_struct *, int);
+ static void xgbe_set_rx_mode(struct net_device *);
+ 
+ static int xgbe_alloc_channels(struct xgbe_prv_data *pdata)
+ {
+ 	struct xgbe_channel *channel_mem, *channel;
+ 	struct xgbe_ring *tx_ring, *rx_ring;
+ 	unsigned int count, i;
+ 	int ret = -ENOMEM;
+ 
+ 	count = max_t(unsigned int, pdata->tx_ring_count, pdata->rx_ring_count);
+ 
+ 	channel_mem = kcalloc(count, sizeof(struct xgbe_channel), GFP_KERNEL);
+ 	if (!channel_mem)
+ 		goto err_channel;
+ 
+ 	tx_ring = kcalloc(pdata->tx_ring_count, sizeof(struct xgbe_ring),
+ 			  GFP_KERNEL);
+ 	if (!tx_ring)
+ 		goto err_tx_ring;
+ 
+ 	rx_ring = kcalloc(pdata->rx_ring_count, sizeof(struct xgbe_ring),
+ 			  GFP_KERNEL);
+ 	if (!rx_ring)
+ 		goto err_rx_ring;
+ 
+ 	for (i = 0, channel = channel_mem; i < count; i++, channel++) {
+ 		snprintf(channel->name, sizeof(channel->name), "channel-%d", i);
+ 		channel->pdata = pdata;
+ 		channel->queue_index = i;
+ 		channel->dma_regs = pdata->xgmac_regs + DMA_CH_BASE +
+ 				    (DMA_CH_INC * i);
+ 
+ 		if (pdata->per_channel_irq) {
+ 			/* Get the DMA interrupt (offset 1) */
+ 			ret = platform_get_irq(pdata->pdev, i + 1);
+ 			if (ret < 0) {
+ 				netdev_err(pdata->netdev,
+ 					   "platform_get_irq %u failed\n",
+ 					   i + 1);
+ 				goto err_irq;
+ 			}
+ 
+ 			channel->dma_irq = ret;
+ 		}
+ 
+ 		if (i < pdata->tx_ring_count) {
+ 			spin_lock_init(&tx_ring->lock);
+ 			channel->tx_ring = tx_ring++;
+ 		}
+ 
+ 		if (i < pdata->rx_ring_count) {
+ 			spin_lock_init(&rx_ring->lock);
+ 			channel->rx_ring = rx_ring++;
+ 		}
+ 
+ 		DBGPR("  %s: queue=%u, dma_regs=%p, dma_irq=%d, tx=%p, rx=%p\n",
+ 		      channel->name, channel->queue_index, channel->dma_regs,
+ 		      channel->dma_irq, channel->tx_ring, channel->rx_ring);
+ 	}
+ 
+ 	pdata->channel = channel_mem;
+ 	pdata->channel_count = count;
+ 
+ 	return 0;
+ 
+ err_irq:
+ 	kfree(rx_ring);
+ 
+ err_rx_ring:
+ 	kfree(tx_ring);
+ 
+ err_tx_ring:
+ 	kfree(channel_mem);
+ 
+ err_channel:
+ 	return ret;
+ }
+ 
+ static void xgbe_free_channels(struct xgbe_prv_data *pdata)
+ {
+ 	if (!pdata->channel)
+ 		return;
+ 
+ 	kfree(pdata->channel->rx_ring);
+ 	kfree(pdata->channel->tx_ring);
+ 	kfree(pdata->channel);
+ 
+ 	pdata->channel = NULL;
+ 	pdata->channel_count = 0;
+ }
+ 
++>>>>>>> 9227dc5e579b (amd-xgbe: Add support for per DMA channel interrupts)
  static inline unsigned int xgbe_tx_avail_desc(struct xgbe_ring *ring)
  {
  	return (ring->rdesc_count - (ring->cur - ring->dirty));
@@@ -625,10 -906,15 +774,15 @@@ static void xgbe_restart_dev(struct xgb
  		return;
  
  	xgbe_stop(pdata);
- 	synchronize_irq(pdata->irq_number);
+ 	synchronize_irq(pdata->dev_irq);
+ 	if (pdata->per_channel_irq) {
+ 		channel = pdata->channel;
+ 		for (i = 0; i < pdata->channel_count; i++, channel++)
+ 			synchronize_irq(channel->dma_irq);
+ 	}
  
 -	xgbe_free_tx_data(pdata);
 -	xgbe_free_rx_data(pdata);
 +	xgbe_free_tx_skbuff(pdata);
 +	xgbe_free_rx_skbuff(pdata);
  
  	/* Issue software reset to device if requested */
  	if (reset)
@@@ -776,20 -1273,44 +933,43 @@@ static int xgbe_open(struct net_device 
  	/* Allocate the ring descriptors and buffers */
  	ret = desc_if->alloc_ring_resources(pdata);
  	if (ret)
 -		goto err_channels;
 +		goto err_clk;
  
 -	/* Initialize the device restart and Tx timestamp work struct */
 +	/* Initialize the device restart work struct */
  	INIT_WORK(&pdata->restart_work, xgbe_restart);
 -	INIT_WORK(&pdata->tx_tstamp_work, xgbe_tx_tstamp);
  
  	/* Request interrupts */
- 	ret = devm_request_irq(pdata->dev, netdev->irq, xgbe_isr, 0,
+ 	ret = devm_request_irq(pdata->dev, pdata->dev_irq, xgbe_isr, 0,
  			       netdev->name, pdata);
  	if (ret) {
  		netdev_alert(netdev, "error requesting irq %d\n",
++<<<<<<< HEAD
 +			     pdata->irq_number);
 +		goto err_irq;
++=======
+ 			     pdata->dev_irq);
+ 		goto err_rings;
++>>>>>>> 9227dc5e579b (amd-xgbe: Add support for per DMA channel interrupts)
+ 	}
+ 
+ 	if (pdata->per_channel_irq) {
+ 		channel = pdata->channel;
+ 		for (i = 0; i < pdata->channel_count; i++, channel++) {
+ 			snprintf(dma_irq_name, sizeof(dma_irq_name) - 1,
+ 				 "%s-TxRx-%u", netdev_name(netdev),
+ 				 channel->queue_index);
+ 
+ 			ret = devm_request_irq(pdata->dev, channel->dma_irq,
+ 					       xgbe_dma_isr, 0, dma_irq_name,
+ 					       channel);
+ 			if (ret) {
+ 				netdev_alert(netdev,
+ 					     "error requesting irq %d\n",
+ 					     channel->dma_irq);
+ 				goto err_irq;
+ 			}
+ 		}
  	}
- 	pdata->irq_number = netdev->irq;
  
  	ret = xgbe_start(pdata);
  	if (ret)
@@@ -802,14 -1323,29 +982,20 @@@
  err_start:
  	hw_if->exit(pdata);
  
- 	devm_free_irq(pdata->dev, pdata->irq_number, pdata);
- 	pdata->irq_number = 0;
+ err_irq:
+ 	if (pdata->per_channel_irq) {
+ 		/* Using an unsigned int, 'i' will go to UINT_MAX and exit */
+ 		for (i--, channel--; i < pdata->channel_count; i--, channel--)
+ 			devm_free_irq(pdata->dev, channel->dma_irq, channel);
+ 	}
+ 
+ 	devm_free_irq(pdata->dev, pdata->dev_irq, pdata);
  
 -err_rings:
 +err_irq:
  	desc_if->free_ring_resources(pdata);
  
 -err_channels:
 -	xgbe_free_channels(pdata);
 -
 -err_ptpclk:
 -	clk_disable_unprepare(pdata->ptpclk);
 -
 -err_sysclk:
 -	clk_disable_unprepare(pdata->sysclk);
 -
 -err_phy_init:
 -	xgbe_phy_exit(pdata);
 +err_clk:
 +	clk_disable_unprepare(pdata->sysclock);
  
  	return ret;
  }
@@@ -828,17 -1366,26 +1016,29 @@@ static int xgbe_close(struct net_devic
  	/* Issue software reset to device */
  	hw_if->exit(pdata);
  
 -	/* Free the ring descriptors and buffers */
 +	/* Free all the ring data */
  	desc_if->free_ring_resources(pdata);
  
++<<<<<<< HEAD
 +	/* Release the interrupt */
 +	if (pdata->irq_number != 0) {
 +		devm_free_irq(pdata->dev, pdata->irq_number, pdata);
 +		pdata->irq_number = 0;
++=======
+ 	/* Free the channel and ring structures */
+ 	xgbe_free_channels(pdata);
+ 
+ 	/* Release the interrupts */
+ 	devm_free_irq(pdata->dev, pdata->dev_irq, pdata);
+ 	if (pdata->per_channel_irq) {
+ 		channel = pdata->channel;
+ 		for (i = 0; i < pdata->channel_count; i++, channel++)
+ 			devm_free_irq(pdata->dev, channel->dma_irq, channel);
++>>>>>>> 9227dc5e579b (amd-xgbe: Add support for per DMA channel interrupts)
  	}
  
 -	/* Disable the clocks */
 -	clk_disable_unprepare(pdata->ptpclk);
 -	clk_disable_unprepare(pdata->sysclk);
 -
 -	/* Release the phy */
 -	xgbe_phy_exit(pdata);
 +	/* Disable the clock */
 +	clk_disable_unprepare(pdata->sysclock);
  
  	DBGPR("<--xgbe_close\n");
  
@@@ -1159,10 -1815,13 +1365,11 @@@ static int xgbe_rx_poll(struct xgbe_cha
  	struct xgbe_ring_data *rdata;
  	struct xgbe_packet_data *packet;
  	struct net_device *netdev = pdata->netdev;
+ 	struct napi_struct *napi;
  	struct sk_buff *skb;
 -	struct skb_shared_hwtstamps *hwtstamps;
 -	unsigned int incomplete, error, context_next, context;
 -	unsigned int len, put_len, max_len;
 -	unsigned int received = 0;
 -	int packet_count = 0;
 +	unsigned int incomplete, error;
 +	unsigned int cur_len, put_len, max_len;
 +	int received = 0;
  
  	DBGPR("-->xgbe_rx_poll: budget=%d\n", budget);
  
@@@ -1170,17 -1829,32 +1377,23 @@@
  	if (!ring)
  		return 0;
  
++<<<<<<< HEAD
++=======
+ 	napi = (pdata->per_channel_irq) ? &channel->napi : &pdata->napi;
+ 
+ 	rdata = XGBE_GET_DESC_DATA(ring, ring->cur);
++>>>>>>> 9227dc5e579b (amd-xgbe: Add support for per DMA channel interrupts)
  	packet = &ring->packet_data;
 -	while (packet_count < budget) {
 +	while (received < budget) {
  		DBGPR("  cur = %d\n", ring->cur);
  
 -		/* First time in loop see if we need to restore state */
 -		if (!received && rdata->state_saved) {
 -			incomplete = rdata->state.incomplete;
 -			context_next = rdata->state.context_next;
 -			skb = rdata->state.skb;
 -			error = rdata->state.error;
 -			len = rdata->state.len;
 -		} else {
 -			memset(packet, 0, sizeof(*packet));
 -			incomplete = 0;
 -			context_next = 0;
 -			skb = NULL;
 -			error = 0;
 -			len = 0;
 -		}
 +		/* Clear the packet data information */
 +		memset(packet, 0, sizeof(*packet));
 +		skb = NULL;
 +		error = 0;
 +		cur_len = 0;
  
  read_again:
 -		rdata = XGBE_GET_DESC_DATA(ring, ring->cur);
 -
  		if (ring->dirty > (XGBE_RX_DESC_CNT >> 3))
  			xgbe_rx_refresh(channel);
  
@@@ -1265,18 -1953,70 +1478,53 @@@
  		skb->dev = netdev;
  		skb->protocol = eth_type_trans(skb, netdev);
  		skb_record_rx_queue(skb, channel->queue_index);
- 		skb_mark_napi_id(skb, &pdata->napi);
+ 		skb_mark_napi_id(skb, napi);
  
  		netdev->last_rx = jiffies;
++<<<<<<< HEAD
 +		napi_gro_receive(&pdata->napi, skb);
++=======
+ 		napi_gro_receive(napi, skb);
+ 
+ next_packet:
+ 		packet_count++;
++>>>>>>> 9227dc5e579b (amd-xgbe: Add support for per DMA channel interrupts)
  	}
  
 -	/* Check if we need to save state before leaving */
 -	if (received && (incomplete || context_next)) {
 -		rdata = XGBE_GET_DESC_DATA(ring, ring->cur);
 -		rdata->state_saved = 1;
 -		rdata->state.incomplete = incomplete;
 -		rdata->state.context_next = context_next;
 -		rdata->state.skb = skb;
 -		rdata->state.len = len;
 -		rdata->state.error = error;
 -	}
 -
 -	DBGPR("<--xgbe_rx_poll: packet_count = %d\n", packet_count);
 +	DBGPR("<--xgbe_rx_poll: received = %d\n", received);
  
 -	return packet_count;
 +	return received;
  }
  
- static int xgbe_poll(struct napi_struct *napi, int budget)
+ static int xgbe_one_poll(struct napi_struct *napi, int budget)
+ {
+ 	struct xgbe_channel *channel = container_of(napi, struct xgbe_channel,
+ 						    napi);
+ 	int processed = 0;
+ 
+ 	DBGPR("-->xgbe_one_poll: budget=%d\n", budget);
+ 
+ 	/* Cleanup Tx ring first */
+ 	xgbe_tx_poll(channel);
+ 
+ 	/* Process Rx ring next */
+ 	processed = xgbe_rx_poll(channel, budget);
+ 
+ 	/* If we processed everything, we are done */
+ 	if (processed < budget) {
+ 		/* Turn off polling */
+ 		napi_complete(napi);
+ 
+ 		/* Enable Tx and Rx interrupts */
+ 		enable_irq(channel->dma_irq);
+ 	}
+ 
+ 	DBGPR("<--xgbe_one_poll: received = %d\n", processed);
+ 
+ 	return processed;
+ }
+ 
+ static int xgbe_all_poll(struct napi_struct *napi, int budget)
  {
  	struct xgbe_prv_data *pdata = container_of(napi, struct xgbe_prv_data,
  						   napi);
diff --cc drivers/net/ethernet/amd/xgbe/xgbe.h
index 30435fbd04b3,55c935f4884a..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@@ -162,6 -170,17 +162,20 @@@
  #define XGBE_PHY_NAME		"amd_xgbe_phy"
  #define XGBE_PRTAD		0
  
++<<<<<<< HEAD
++=======
+ /* Device-tree clock names */
+ #define XGBE_DMA_CLOCK		"dma_clk"
+ #define XGBE_PTP_CLOCK		"ptp_clk"
+ #define XGBE_DMA_IRQS		"amd,per-channel-interrupt"
+ 
+ /* Timestamp support - values based on 50MHz PTP clock
+  *   50MHz => 20 nsec
+  */
+ #define XGBE_TSTAMP_SSINC	20
+ #define XGBE_TSTAMP_SNSINC	0
+ 
++>>>>>>> 9227dc5e579b (amd-xgbe: Add support for per DMA channel interrupts)
  /* Driver PMT macros */
  #define XGMAC_DRIVER_CONTEXT	1
  #define XGMAC_IOCTL_CONTEXT	2
* Unmerged path Documentation/devicetree/bindings/net/amd-xgbe.txt
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
index 2da3691ffcd6..172f7d9f9591 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
@@ -455,17 +455,21 @@ static void xgbe_enable_dma_interrupts(struct xgbe_prv_data *pdata)
 
 		if (channel->tx_ring) {
 			/* Enable the following Tx interrupts
-			 *   TIE  - Transmit Interrupt Enable (unless polling)
+			 *   TIE  - Transmit Interrupt Enable (unless using
+			 *          per channel interrupts)
 			 */
-			XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TIE, 1);
+			if (!pdata->per_channel_irq)
+				XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TIE, 1);
 		}
 		if (channel->rx_ring) {
 			/* Enable following Rx interrupts
 			 *   RBUE - Receive Buffer Unavailable Enable
-			 *   RIE  - Receive Interrupt Enable
+			 *   RIE  - Receive Interrupt Enable (unless using
+			 *          per channel interrupts)
 			 */
 			XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RBUE, 1);
-			XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RIE, 1);
+			if (!pdata->per_channel_irq)
+				XGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RIE, 1);
 		}
 
 		XGMAC_DMA_IOWRITE(channel, DMA_CH_IER, dma_ch_ier);
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-main.c b/drivers/net/ethernet/amd/xgbe/xgbe-main.c
index 5ad0a540825b..48fb78aa6d88 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-main.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-main.c
@@ -310,12 +310,18 @@ static int xgbe_probe(struct platform_device *pdev)
 		pdata->awcache = XGBE_DMA_SYS_AWCACHE;
 	}
 
+	/* Check for per channel interrupt support */
+	if (of_property_read_bool(dev->of_node, XGBE_DMA_IRQS))
+		pdata->per_channel_irq = 1;
+
 	ret = platform_get_irq(pdev, 0);
 	if (ret < 0) {
-		dev_err(dev, "platform_get_irq failed\n");
+		dev_err(dev, "platform_get_irq 0 failed\n");
 		goto err_io;
 	}
-	netdev->irq = ret;
+	pdata->dev_irq = ret;
+
+	netdev->irq = pdata->dev_irq;
 	netdev->base_addr = (unsigned long)pdata->xgmac_regs;
 
 	/* Set all the function pointers */
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe.h
