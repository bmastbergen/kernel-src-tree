bridge: use is_skb_forwardable in forward path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Vlad Yasevich <vyasevic@redhat.com>
commit f6367b4660dde412f9b7af94763efb1d89cefb74
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f6367b46.failed

Use existing function instead of trying to use our own.

	Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f6367b4660dde412f9b7af94763efb1d89cefb74)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_forward.c
diff --cc net/bridge/br_forward.c
index 20c11b41fe6a,056b67b0e277..000000000000
--- a/net/bridge/br_forward.c
+++ b/net/bridge/br_forward.c
@@@ -35,44 -35,24 +35,57 @@@ static inline int should_deliver(const 
  		p->state == BR_STATE_FORWARDING;
  }
  
++<<<<<<< HEAD
 +static inline unsigned int packet_length(const struct sk_buff *skb)
 +{
 +	return skb->len - (skb->protocol == htons(ETH_P_8021Q) ? VLAN_HLEN : 0);
 +}
 +
 +int br_dev_queue_push_xmit(struct sock *sk, struct sk_buff *skb)
 +{
 +	if (!is_skb_forwardable(skb->dev, skb))
 +		goto drop;
 +
 +	skb_push(skb, ETH_HLEN);
 +	br_drop_fake_rtable(skb);
 +
 +	if (skb->ip_summed == CHECKSUM_PARTIAL &&
 +	    (skb->protocol == htons(ETH_P_8021Q) ||
 +	     skb->protocol == htons(ETH_P_8021AD))) {
 +		int depth;
 +
 +		if (!__vlan_get_protocol(skb, skb->protocol, &depth))
 +			goto drop;
 +
 +		skb_set_network_header(skb, depth);
++=======
+ int br_dev_queue_push_xmit(struct sk_buff *skb)
+ {
+ 	/* ip_fragment doesn't copy the MAC header */
+ 	if (nf_bridge_maybe_copy_header(skb) ||
+ 	    !is_skb_forwardable(skb->dev, skb)) {
+ 		kfree_skb(skb);
+ 	} else {
+ 		skb_push(skb, ETH_HLEN);
+ 		br_drop_fake_rtable(skb);
+ 		dev_queue_xmit(skb);
++>>>>>>> f6367b4660dd (bridge: use is_skb_forwardable in forward path)
  	}
  
 +	dev_queue_xmit(skb);
 +
 +	return 0;
 +
 +drop:
 +	kfree_skb(skb);
  	return 0;
  }
 +EXPORT_SYMBOL_GPL(br_dev_queue_push_xmit);
  
 -int br_forward_finish(struct sk_buff *skb)
 +int br_forward_finish(struct sock *sk, struct sk_buff *skb)
  {
 -	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING, skb, NULL, skb->dev,
 +	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING, sk, skb,
 +		       NULL, skb->dev,
  		       br_dev_queue_push_xmit);
  
  }
* Unmerged path net/bridge/br_forward.c
