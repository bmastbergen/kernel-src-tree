svm: Add interrupt injection via AVIC

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
commit 340d3bc3664e5d3fb922fe6e3ae2d901d4900d88
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/340d3bc3.failed

This patch introduces a new mechanism to inject interrupt using AVIC.
Since VINTR is not supported when enable AVIC, we need to inject
interrupt via APIC backing page instead.

This patch also adds support for AVIC doorbell, which is used by
KVM to signal a running vcpu to check IRR for injected interrupts.

	Signed-off-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 340d3bc3664e5d3fb922fe6e3ae2d901d4900d88)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm.c
diff --cc arch/x86/kvm/svm.c
index b645837920e7,95d9b5c4c431..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -253,6 -289,23 +255,26 @@@ static inline struct vcpu_svm *to_svm(s
  	return container_of(vcpu, struct vcpu_svm, vcpu);
  }
  
++<<<<<<< HEAD
++=======
+ static inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)
+ {
+ 	svm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;
+ 	mark_dirty(svm->vmcb, VMCB_AVIC);
+ }
+ 
+ static inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)
+ {
+ 	struct vcpu_svm *svm = to_svm(vcpu);
+ 	u64 *entry = svm->avic_physical_id_cache;
+ 
+ 	if (!entry)
+ 		return false;
+ 
+ 	return (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);
+ }
+ 
++>>>>>>> 340d3bc3664e (svm: Add interrupt injection via AVIC)
  static void recalc_intercepts(struct vcpu_svm *svm)
  {
  	struct vmcb_control_area *c, *h;
* Unmerged path arch/x86/kvm/svm.c
