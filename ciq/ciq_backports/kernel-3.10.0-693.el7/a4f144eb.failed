perf/core: Fix crash due to account/unaccount_sb_event() inconsistency

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Carrillo-Cisneros <davidcc@google.com>
commit a4f144ebbdf6f7807c477bce8e136047ed27321f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a4f144eb.failed

unaccount_pmu_sb_event() did not check for attributes in event->attr
before calling detach_sb_event(), while account_pmu_event() did.

This caused NULL pointer reference in cgroup events that did not
have any of the attributes checked by account_pmu_event().

To trigger the bug just wait for a cgroup event to terminate, e.g.:

  $ mkdir /dev/cgroup/devices/test
  $ perf stat -e cycles -a -G test sleep 0

... see crash ...

	Signed-off-by: David Carrillo-Cisneros <davidcc@google.com>
	Reviewed-by: Stephane Eranian <eranian@google.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Kan Liang <kan.liang@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Zheng <zheng.z.yan@intel.com>
Link: http://lkml.kernel.org/r/1464809585-66072-1-git-send-email-davidcc@google.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a4f144ebbdf6f7807c477bce8e136047ed27321f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/core.c
diff --cc kernel/events/core.c
index 22bb9b56c671,ae081a141a4a..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -3598,7 -3670,41 +3598,45 @@@ static void free_event_rcu(struct rcu_h
  	kfree(event);
  }
  
++<<<<<<< HEAD
 +static void ring_buffer_detach(struct perf_event *event, struct ring_buffer *rb);
++=======
+ static void ring_buffer_attach(struct perf_event *event,
+ 			       struct ring_buffer *rb);
+ 
+ static void detach_sb_event(struct perf_event *event)
+ {
+ 	struct pmu_event_list *pel = per_cpu_ptr(&pmu_sb_events, event->cpu);
+ 
+ 	raw_spin_lock(&pel->lock);
+ 	list_del_rcu(&event->sb_list);
+ 	raw_spin_unlock(&pel->lock);
+ }
+ 
+ static bool is_sb_event(struct perf_event *event)
+ {
+ 	struct perf_event_attr *attr = &event->attr;
+ 
+ 	if (event->parent)
+ 		return false;
+ 
+ 	if (event->attach_state & PERF_ATTACH_TASK)
+ 		return false;
+ 
+ 	if (attr->mmap || attr->mmap_data || attr->mmap2 ||
+ 	    attr->comm || attr->comm_exec ||
+ 	    attr->task ||
+ 	    attr->context_switch)
+ 		return true;
+ 	return false;
+ }
+ 
+ static void unaccount_pmu_sb_event(struct perf_event *event)
+ {
+ 	if (is_sb_event(event))
+ 		detach_sb_event(event);
+ }
++>>>>>>> a4f144ebbdf6 (perf/core: Fix crash due to account/unaccount_sb_event() inconsistency)
  
  static void unaccount_event_cpu(struct perf_event *event, int cpu)
  {
@@@ -7880,6 -8661,28 +7918,31 @@@ unlock
  	return pmu;
  }
  
++<<<<<<< HEAD
++=======
+ static void attach_sb_event(struct perf_event *event)
+ {
+ 	struct pmu_event_list *pel = per_cpu_ptr(&pmu_sb_events, event->cpu);
+ 
+ 	raw_spin_lock(&pel->lock);
+ 	list_add_rcu(&event->sb_list, &pel->list);
+ 	raw_spin_unlock(&pel->lock);
+ }
+ 
+ /*
+  * We keep a list of all !task (and therefore per-cpu) events
+  * that need to receive side-band records.
+  *
+  * This avoids having to scan all the various PMU per-cpu contexts
+  * looking for them.
+  */
+ static void account_pmu_sb_event(struct perf_event *event)
+ {
+ 	if (is_sb_event(event))
+ 		attach_sb_event(event);
+ }
+ 
++>>>>>>> a4f144ebbdf6 (perf/core: Fix crash due to account/unaccount_sb_event() inconsistency)
  static void account_event_cpu(struct perf_event *event, int cpu)
  {
  	if (event->parent)
* Unmerged path kernel/events/core.c
