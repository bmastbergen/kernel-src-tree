bridge: mcast: add support for temporary port router

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit a55d8246abcc910346771175b521ee2bce5a69b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a55d8246.failed

Add support for a temporary router port which doesn't depend only on the
incoming query. It can be refreshed if set to the same value, which is
a no-op for the rest.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a55d8246abcc910346771175b521ee2bce5a69b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_bridge.h
#	net/bridge/br_multicast.c
diff --cc include/uapi/linux/if_bridge.h
index 8218dc361221,74ee03a47e79..000000000000
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@@ -164,6 -169,22 +164,25 @@@ enum 
  };
  #define MDBA_MDB_ENTRY_MAX (__MDBA_MDB_ENTRY_MAX - 1)
  
++<<<<<<< HEAD
++=======
+ /* per mdb entry additional attributes */
+ enum {
+ 	MDBA_MDB_EATTR_UNSPEC,
+ 	MDBA_MDB_EATTR_TIMER,
+ 	__MDBA_MDB_EATTR_MAX
+ };
+ #define MDBA_MDB_EATTR_MAX (__MDBA_MDB_EATTR_MAX - 1)
+ 
+ /* multicast router types */
+ enum {
+ 	MDB_RTR_TYPE_DISABLED,
+ 	MDB_RTR_TYPE_TEMP_QUERY,
+ 	MDB_RTR_TYPE_PERM,
+ 	MDB_RTR_TYPE_TEMP
+ };
+ 
++>>>>>>> a55d8246abcc (bridge: mcast: add support for temporary port router)
  enum {
  	MDBA_ROUTER_UNSPEC,
  	MDBA_ROUTER_PORT,
diff --cc net/bridge/br_multicast.c
index f9002e7e306f,a4c15df2b792..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -760,12 -759,17 +760,24 @@@ static void br_multicast_router_expired
  	struct net_bridge *br = port->br;
  
  	spin_lock(&br->multicast_lock);
++<<<<<<< HEAD
 +	if (port->multicast_router != 1 ||
++=======
+ 	if (port->multicast_router == MDB_RTR_TYPE_DISABLED ||
+ 	    port->multicast_router == MDB_RTR_TYPE_PERM ||
++>>>>>>> a55d8246abcc (bridge: mcast: add support for temporary port router)
  	    timer_pending(&port->multicast_router_timer) ||
  	    hlist_unhashed(&port->rlist))
  		goto out;
  
  	hlist_del_init_rcu(&port->rlist);
++<<<<<<< HEAD
++=======
+ 	br_rtr_notify(br->dev, port, RTM_DELMDB);
+ 	/* Don't allow timer refresh if the router expired */
+ 	if (port->multicast_router == MDB_RTR_TYPE_TEMP)
+ 		port->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
++>>>>>>> a55d8246abcc (bridge: mcast: add support for temporary port router)
  
  out:
  	spin_unlock(&br->multicast_lock);
@@@ -960,11 -979,16 +972,19 @@@ void br_multicast_disable_port(struct n
  
  	spin_lock(&br->multicast_lock);
  	hlist_for_each_entry_safe(pg, n, &port->mglist, mglist)
 -		if (!(pg->flags & MDB_PG_FLAGS_PERMANENT))
 +		if (pg->state == MDB_TEMPORARY)
  			br_multicast_del_pg(br, pg);
  
 -	if (!hlist_unhashed(&port->rlist)) {
 +	if (!hlist_unhashed(&port->rlist))
  		hlist_del_init_rcu(&port->rlist);
++<<<<<<< HEAD
++=======
+ 		br_rtr_notify(br->dev, port, RTM_DELMDB);
+ 		/* Don't allow timer refresh if disabling */
+ 		if (port->multicast_router == MDB_RTR_TYPE_TEMP)
+ 			port->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
+ 	}
++>>>>>>> a55d8246abcc (bridge: mcast: add support for temporary port router)
  	del_timer(&port->multicast_router_timer);
  	del_timer(&port->ip4_own_query.timer);
  #if IS_ENABLED(CONFIG_IPV6)
@@@ -1154,7 -1241,8 +1174,12 @@@ static void br_multicast_mark_router(st
  		return;
  	}
  
++<<<<<<< HEAD
 +	if (port->multicast_router != 1)
++=======
+ 	if (port->multicast_router == MDB_RTR_TYPE_DISABLED ||
+ 	    port->multicast_router == MDB_RTR_TYPE_PERM)
++>>>>>>> a55d8246abcc (bridge: mcast: add support for temporary port router)
  		return;
  
  	br_multicast_add_router(br, port);
@@@ -1914,27 -1871,29 +1944,36 @@@ int br_multicast_set_port_router(struc
  		goto unlock;
  	}
  	switch (val) {
 -	case MDB_RTR_TYPE_DISABLED:
 -		p->multicast_router = MDB_RTR_TYPE_DISABLED;
 -		__del_port_router(p);
 -		del_timer(&p->multicast_router_timer);
 -		break;
 -	case MDB_RTR_TYPE_TEMP_QUERY:
 -		p->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
 -		__del_port_router(p);
 -		break;
 -	case MDB_RTR_TYPE_PERM:
 -		p->multicast_router = MDB_RTR_TYPE_PERM;
 +	case 0:
 +	case 1:
 +	case 2:
 +		p->multicast_router = val;
 +		err = 0;
 +
 +		if (val < 2 && !hlist_unhashed(&p->rlist))
 +			hlist_del_init_rcu(&p->rlist);
 +
 +		if (val == 1)
 +			break;
 +
  		del_timer(&p->multicast_router_timer);
 +
 +		if (val == 0)
 +			break;
 +
  		br_multicast_add_router(br, p);
  		break;
++<<<<<<< HEAD
++=======
+ 	case MDB_RTR_TYPE_TEMP:
+ 		p->multicast_router = MDB_RTR_TYPE_TEMP;
+ 		br_multicast_mark_router(br, p);
+ 		break;
+ 	default:
+ 		goto unlock;
++>>>>>>> a55d8246abcc (bridge: mcast: add support for temporary port router)
  	}
 -	err = 0;
 -unlock:
 +
  	spin_unlock(&br->multicast_lock);
  
  	return err;
* Unmerged path include/uapi/linux/if_bridge.h
* Unmerged path net/bridge/br_multicast.c
