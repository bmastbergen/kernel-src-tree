resizable namespace.c hashes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 0818bf27c05b2de56c5b2bd08cfae2a939bd5f52
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0818bf27.failed

* switch allocation to alloc_large_system_hash()
* make sizes overridable by boot parameters (mhash_entries=, mphash_entries=)
* switch mountpoint_hashtable from list_head to hlist_head

	Cc: stable@vger.kernel.org
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 0818bf27c05b2de56c5b2bd08cfae2a939bd5f52)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index a82db7875df0,3b648da55d87..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -26,18 -27,40 +27,50 @@@
  #include "pnode.h"
  #include "internal.h"
  
++<<<<<<< HEAD
 +#define HASH_SHIFT 12
 +#define HASH_SIZE (1UL << HASH_SHIFT)
++=======
+ static unsigned int m_hash_mask __read_mostly;
+ static unsigned int m_hash_shift __read_mostly;
+ static unsigned int mp_hash_mask __read_mostly;
+ static unsigned int mp_hash_shift __read_mostly;
+ 
+ static __initdata unsigned long mhash_entries;
+ static int __init set_mhash_entries(char *str)
+ {
+ 	if (!str)
+ 		return 0;
+ 	mhash_entries = simple_strtoul(str, &str, 0);
+ 	return 1;
+ }
+ __setup("mhash_entries=", set_mhash_entries);
+ 
+ static __initdata unsigned long mphash_entries;
+ static int __init set_mphash_entries(char *str)
+ {
+ 	if (!str)
+ 		return 0;
+ 	mphash_entries = simple_strtoul(str, &str, 0);
+ 	return 1;
+ }
+ __setup("mphash_entries=", set_mphash_entries);
++>>>>>>> 0818bf27c05b (resizable namespace.c hashes)
  
 -static int event;
 +static u64 event;
  static DEFINE_IDA(mnt_id_ida);
  static DEFINE_IDA(mnt_group_ida);
  static DEFINE_SPINLOCK(mnt_id_lock);
  static int mnt_id_start = 0;
  static int mnt_group_start = 1;
  
++<<<<<<< HEAD
 +static struct list_head mount_hashtable[HASH_SIZE];
 +static struct list_head mountpoint_hashtable[HASH_SIZE];
++=======
+ static struct list_head *mount_hashtable __read_mostly;
+ static struct hlist_head *mountpoint_hashtable __read_mostly;
++>>>>>>> 0818bf27c05b (resizable namespace.c hashes)
  static struct kmem_cache *mnt_cache __read_mostly;
  static DECLARE_RWSEM(namespace_sem);
  
@@@ -53,9 -76,9 +86,9 @@@ EXPORT_SYMBOL_GPL(fs_kobj)
   * It should be taken for write in all cases where the vfsmount
   * tree or hash is modified or when a vfsmount structure is modified.
   */
 -__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock);
 +DEFINE_BRLOCK(vfsmount_lock);
  
- static inline unsigned long hash(struct vfsmount *mnt, struct dentry *dentry)
+ static inline struct list_head *m_hash(struct vfsmount *mnt, struct dentry *dentry)
  {
  	unsigned long tmp = ((unsigned long)mnt / L1_CACHE_BYTES);
  	tmp += ((unsigned long)dentry / L1_CACHE_BYTES);
@@@ -553,10 -605,10 +593,10 @@@ static void free_vfsmnt(struct mount *m
   */
  struct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)
  {
- 	struct list_head *head = mount_hashtable + hash(mnt, dentry);
+ 	struct list_head *head = m_hash(mnt, dentry);
  	struct mount *p;
  
 -	list_for_each_entry_rcu(p, head, mnt_hash)
 +	list_for_each_entry(p, head, mnt_hash)
  		if (&p->mnt_parent->mnt == mnt && p->mnt_mountpoint == dentry)
  			return p;
  	return NULL;
@@@ -2797,14 -2806,26 +2836,32 @@@ void __init mnt_init(void
  	mnt_cache = kmem_cache_create("mnt_cache", sizeof(struct mount),
  			0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);
  
++<<<<<<< HEAD
 +	printk(KERN_INFO "Mount-cache hash table entries: %lu\n", HASH_SIZE);
 +
 +	for (u = 0; u < HASH_SIZE; u++)
++=======
+ 	mount_hashtable = alloc_large_system_hash("Mount-cache",
+ 				sizeof(struct list_head),
+ 				mhash_entries, 19,
+ 				0,
+ 				&m_hash_shift, &m_hash_mask, 0, 0);
+ 	mountpoint_hashtable = alloc_large_system_hash("Mountpoint-cache",
+ 				sizeof(struct hlist_head),
+ 				mphash_entries, 19,
+ 				0,
+ 				&mp_hash_shift, &mp_hash_mask, 0, 0);
+ 
+ 	if (!mount_hashtable || !mountpoint_hashtable)
+ 		panic("Failed to allocate mount hash table\n");
+ 
+ 	for (u = 0; u <= m_hash_mask; u++)
++>>>>>>> 0818bf27c05b (resizable namespace.c hashes)
  		INIT_LIST_HEAD(&mount_hashtable[u]);
- 	for (u = 0; u < HASH_SIZE; u++)
- 		INIT_LIST_HEAD(&mountpoint_hashtable[u]);
+ 	for (u = 0; u <= mp_hash_mask; u++)
+ 		INIT_HLIST_HEAD(&mountpoint_hashtable[u]);
  
 -	kernfs_init();
 +	br_lock_init(&vfsmount_lock);
  
  	err = sysfs_init();
  	if (err)
diff --git a/fs/mount.h b/fs/mount.h
index 78d1559796ee..196fc464f0c9 100644
--- a/fs/mount.h
+++ b/fs/mount.h
@@ -19,7 +19,7 @@ struct mnt_pcp {
 };
 
 struct mountpoint {
-	struct list_head m_hash;
+	struct hlist_node m_hash;
 	struct dentry *m_dentry;
 	int m_count;
 };
* Unmerged path fs/namespace.c
