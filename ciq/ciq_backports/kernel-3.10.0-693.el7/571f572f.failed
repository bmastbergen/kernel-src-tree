HID: wacom: Further clean up wacom_intuos_general packet decoder

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Further clean up wacom_intuos_general packet decoder (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.93%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 571f572f9acf7e03fd0e8eb1449e75447295d457
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/571f572f.failed

Continue re-organizing and trimming cases to make it easier to wrap
the brain around. A number of changes were made after consulting the
protocol spec and so don't necessarily follow from the code itself.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 571f572f9acf7e03fd0e8eb1449e75447295d457)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index bdf17efa93aa,ce3afab806cc..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -752,70 -903,95 +752,162 @@@ static int wacom_intuos_irq(struct waco
  		input_report_abs(input, ABS_DISTANCE, ((data[9] >> 3) & 0x1f));
  	}
  
++<<<<<<< HEAD
 +	/* process general packets */
 +	wacom_intuos_general(wacom);
 +
 +	/* 4D mouse, 2D mouse, marker pen rotation, tilt mouse, or Lens cursor packets */
 +	if ((data[1] & 0xbc) == 0xa8 || (data[1] & 0xbe) == 0xb0 || (data[1] & 0xbc) == 0xac) {
 +
 +		if (data[1] & 0x02) {
 +			/* Rotation packet */
 +			if (features->type >= INTUOS3S) {
 +				/* I3 marker pen rotation */
 +				t = (data[6] << 3) | ((data[7] >> 5) & 7);
 +				t = (data[7] & 0x20) ? ((t > 900) ? ((t-1) / 2 - 1350) :
 +					((t-1) / 2 + 450)) : (450 - t / 2) ;
 +				input_report_abs(input, ABS_Z, t);
 +			} else {
 +				/* 4D mouse rotation packet */
 +				t = (data[6] << 3) | ((data[7] >> 5) & 7);
 +				input_report_abs(input, ABS_RZ, (data[7] & 0x20) ?
 +					((t - 1) / 2) : -t / 2);
 +			}
 +
 +		} else if (!(data[1] & 0x10) && features->type < INTUOS3S) {
 +			/* 4D mouse packet */
 +			input_report_key(input, BTN_LEFT,   data[8] & 0x01);
 +			input_report_key(input, BTN_MIDDLE, data[8] & 0x02);
 +			input_report_key(input, BTN_RIGHT,  data[8] & 0x04);
 +
 +			input_report_key(input, BTN_SIDE,   data[8] & 0x20);
 +			input_report_key(input, BTN_EXTRA,  data[8] & 0x10);
 +			t = (data[6] << 2) | ((data[7] >> 6) & 3);
 +			input_report_abs(input, ABS_THROTTLE, (data[8] & 0x08) ? -t : t);
 +
 +		} else if (wacom->tool[idx] == BTN_TOOL_MOUSE) {
 +			/* I4 mouse */
 +			if (features->type >= INTUOS4S && features->type <= INTUOSPL) {
 +				input_report_key(input, BTN_LEFT,   data[6] & 0x01);
 +				input_report_key(input, BTN_MIDDLE, data[6] & 0x02);
 +				input_report_key(input, BTN_RIGHT,  data[6] & 0x04);
 +				input_report_rel(input, REL_WHEEL, ((data[7] & 0x80) >> 7)
 +						 - ((data[7] & 0x40) >> 6));
 +				input_report_key(input, BTN_SIDE,   data[6] & 0x08);
 +				input_report_key(input, BTN_EXTRA,  data[6] & 0x10);
 +
 +				input_report_abs(input, ABS_TILT_X,
 +					(((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
 +				input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
 +			} else {
 +				/* 2D mouse packet */
 +				input_report_key(input, BTN_LEFT,   data[8] & 0x04);
 +				input_report_key(input, BTN_MIDDLE, data[8] & 0x08);
 +				input_report_key(input, BTN_RIGHT,  data[8] & 0x10);
 +				input_report_rel(input, REL_WHEEL, (data[8] & 0x01)
 +						 - ((data[8] & 0x02) >> 1));
 +
 +				/* I3 2D mouse side buttons */
 +				if (features->type >= INTUOS3S && features->type <= INTUOS3L) {
 +					input_report_key(input, BTN_SIDE,   data[8] & 0x40);
 +					input_report_key(input, BTN_EXTRA,  data[8] & 0x20);
 +				}
 +			}
 +		} else if ((features->type < INTUOS3S || features->type == INTUOS3L ||
 +				features->type == INTUOS4L || features->type == INTUOS5L ||
 +				features->type == INTUOSPL) &&
 +			   wacom->tool[idx] == BTN_TOOL_LENS) {
++=======
+ 	switch (type) {
+ 	case 0x00:
+ 	case 0x01:
+ 	case 0x02:
+ 	case 0x03:
+ 		/* general pen packet */
+ 		t = (data[6] << 2) | ((data[7] >> 6) & 3);
+ 		if (features->pressure_max == 2047) {
+ 			t = (t << 1) | (data[1] & 1);
+ 		}
+ 		input_report_abs(input, ABS_PRESSURE, t);
+ 		if (features->type != INTUOSHT2) {
+ 		    input_report_abs(input, ABS_TILT_X,
+ 				 (((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
+ 		    input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
+ 		}
+ 		input_report_key(input, BTN_STYLUS, data[1] & 2);
+ 		input_report_key(input, BTN_STYLUS2, data[1] & 4);
+ 		input_report_key(input, BTN_TOUCH, t > 10);
+ 		break;
+ 
+ 	case 0x0a:
+ 		/* airbrush second packet */
+ 		input_report_abs(input, ABS_WHEEL,
+ 				(data[6] << 2) | ((data[7] >> 6) & 3));
+ 		input_report_abs(input, ABS_TILT_X,
+ 				 (((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
+ 		input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
+ 		break;
+ 
+ 	case 0x05:
+ 		/* Rotation packet */
+ 		if (features->type >= INTUOS3S) {
+ 			/* I3 marker pen rotation */
+ 			t = (data[6] << 3) | ((data[7] >> 5) & 7);
+ 			t = (data[7] & 0x20) ? ((t > 900) ? ((t-1) / 2 - 1350) :
+ 				((t-1) / 2 + 450)) : (450 - t / 2) ;
+ 			input_report_abs(input, ABS_Z, t);
+ 		} else {
+ 			/* 4D mouse 2nd packet */
+ 			t = (data[6] << 3) | ((data[7] >> 5) & 7);
+ 			input_report_abs(input, ABS_RZ, (data[7] & 0x20) ?
+ 				((t - 1) / 2) : -t / 2);
+ 		}
+ 		break;
+ 
+ 	case 0x04:
+ 		/* 4D mouse 1st packet */
+ 		input_report_key(input, BTN_LEFT,   data[8] & 0x01);
+ 		input_report_key(input, BTN_MIDDLE, data[8] & 0x02);
+ 		input_report_key(input, BTN_RIGHT,  data[8] & 0x04);
+ 
+ 		input_report_key(input, BTN_SIDE,   data[8] & 0x20);
+ 		input_report_key(input, BTN_EXTRA,  data[8] & 0x10);
+ 		t = (data[6] << 2) | ((data[7] >> 6) & 3);
+ 		input_report_abs(input, ABS_THROTTLE, (data[8] & 0x08) ? -t : t);
+ 		break;
+ 
+ 	case 0x06:
+ 		/* I4 mouse */
+ 		input_report_key(input, BTN_LEFT,   data[6] & 0x01);
+ 		input_report_key(input, BTN_MIDDLE, data[6] & 0x02);
+ 		input_report_key(input, BTN_RIGHT,  data[6] & 0x04);
+ 		input_report_rel(input, REL_WHEEL, ((data[7] & 0x80) >> 7)
+ 				 - ((data[7] & 0x40) >> 6));
+ 		input_report_key(input, BTN_SIDE,   data[6] & 0x08);
+ 		input_report_key(input, BTN_EXTRA,  data[6] & 0x10);
+ 
+ 		input_report_abs(input, ABS_TILT_X,
+ 			(((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
+ 		input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
+ 		break;
+ 
+ 	case 0x08:
+ 		if (wacom->tool[idx] == BTN_TOOL_MOUSE) {
+ 			/* 2D mouse packet */
+ 			input_report_key(input, BTN_LEFT,   data[8] & 0x04);
+ 			input_report_key(input, BTN_MIDDLE, data[8] & 0x08);
+ 			input_report_key(input, BTN_RIGHT,  data[8] & 0x10);
+ 			input_report_rel(input, REL_WHEEL, (data[8] & 0x01)
+ 					 - ((data[8] & 0x02) >> 1));
+ 
+ 			/* I3 2D mouse side buttons */
+ 			if (features->type >= INTUOS3S && features->type <= INTUOS3L) {
+ 				input_report_key(input, BTN_SIDE,   data[8] & 0x40);
+ 				input_report_key(input, BTN_EXTRA,  data[8] & 0x20);
+ 			}
+ 		}
+ 		else if (wacom->tool[idx] == BTN_TOOL_LENS) {
++>>>>>>> 571f572f9acf (HID: wacom: Further clean up wacom_intuos_general packet decoder)
  			/* Lens cursor packets */
  			input_report_key(input, BTN_LEFT,   data[8] & 0x01);
  			input_report_key(input, BTN_MIDDLE, data[8] & 0x02);
@@@ -823,6 -999,17 +915,20 @@@
  			input_report_key(input, BTN_SIDE,   data[8] & 0x10);
  			input_report_key(input, BTN_EXTRA,  data[8] & 0x08);
  		}
++<<<<<<< HEAD
++=======
+ 		break;
+ 
+ 	case 0x07:
+ 	case 0x09:
+ 	case 0x0b:
+ 	case 0x0c:
+ 	case 0x0d:
+ 	case 0x0e:
+ 	case 0x0f:
+ 		/* unhandled */
+ 		break;
++>>>>>>> 571f572f9acf (HID: wacom: Further clean up wacom_intuos_general packet decoder)
  	}
  
  	input_report_abs(input, ABS_MISC, wacom->id[idx]); /* report tool id */
* Unmerged path drivers/hid/wacom_wac.c
