netfilter: bridge: honor frag_max_size when refragmenting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Florian Westphal <fw@strlen.de>
commit 4ca60d08cbe65f501baad64af50fceba79c19fbb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4ca60d08.failed

consider a bridge with mtu 9000, but end host sending smaller
packets to another host with mtu < 9000.

In this case, after reassembly, bridge+defrag would refragment,
and then attempt to send the reassembled packet as long as it
was below 9k.

Instead we have to cap by the largest fragment size seen.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 4ca60d08cbe65f501baad64af50fceba79c19fbb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_netfilter_hooks.c
diff --cc net/bridge/br_netfilter_hooks.c
index 3c13f8ee3a66,3c5185021c1c..000000000000
--- a/net/bridge/br_netfilter_hooks.c
+++ b/net/bridge/br_netfilter_hooks.c
@@@ -729,21 -719,22 +729,28 @@@ static unsigned int nf_bridge_mtu_reduc
  	return 0;
  }
  
 -static int br_nf_dev_queue_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)
 +static int br_nf_dev_queue_xmit(struct sock *sk, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	struct nf_bridge_info *nf_bridge;
 +	unsigned int mtu_reserved;
 +	struct net *net = dev_net(skb_dst(skb)->dev);
++=======
+ 	struct nf_bridge_info *nf_bridge = nf_bridge_info_get(skb);
+ 	unsigned int mtu, mtu_reserved;
++>>>>>>> 4ca60d08cbe6 (netfilter: bridge: honor frag_max_size when refragmenting)
  
  	mtu_reserved = nf_bridge_mtu_reduction(skb);
+ 	mtu = skb->dev->mtu;
+ 
+ 	if (nf_bridge->frag_max_size && nf_bridge->frag_max_size < mtu)
+ 		mtu = nf_bridge->frag_max_size;
  
- 	if (skb_is_gso(skb) || skb->len + mtu_reserved <= skb->dev->mtu) {
+ 	if (skb_is_gso(skb) || skb->len + mtu_reserved <= mtu) {
  		nf_bridge_info_free(skb);
 -		return br_dev_queue_push_xmit(net, sk, skb);
 +		return br_dev_queue_push_xmit(sk, skb);
  	}
  
- 	nf_bridge = nf_bridge_info_get(skb);
- 
  	/* This is wrong! We should preserve the original fragment
  	 * boundaries by preserving frag_list rather than refragmenting.
  	 */
* Unmerged path net/bridge/br_netfilter_hooks.c
