bridge: implement missing ndo_uninit()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit b6fe0440c63716e09cfc0d1484e3898a0f29d1d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b6fe0440.failed

While the bridge driver implements an ndo_init(), it was missing a
symmetric ndo_uninit(), causing the different de-initialization
operations to be scattered around its dellink() and destructor().

Implement a symmetric ndo_uninit() and remove the overlapping operations
from its dellink() and destructor().

This is a prerequisite for the next patch, as it allows us to have a
proper cleanup upon changelink() failure during the bridge's newlink().

Fixes: b6677449dff6 ("bridge: netlink: call br_changelink() during br_dev_newlink()")
	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b6fe0440c63716e09cfc0d1484e3898a0f29d1d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_multicast.c
index 5c51f3f096e5,faa7261a992f..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -2145,4 -2343,245 +2145,173 @@@ unlock
  	return count;
  }
  EXPORT_SYMBOL_GPL(br_multicast_list_adjacent);
 -
 -/**
 - * br_multicast_has_querier_anywhere - Checks for a querier on a bridge
 - * @dev: The bridge port providing the bridge on which to check for a querier
 - * @proto: The protocol family to check for: IGMP -> ETH_P_IP, MLD -> ETH_P_IPV6
 - *
 - * Checks whether the given interface has a bridge on top and if so returns
 - * true if a valid querier exists anywhere on the bridged link layer.
 - * Otherwise returns false.
 - */
 -bool br_multicast_has_querier_anywhere(struct net_device *dev, int proto)
 -{
 -	struct net_bridge *br;
 -	struct net_bridge_port *port;
 -	struct ethhdr eth;
 -	bool ret = false;
 -
 -	rcu_read_lock();
 -	if (!br_port_exists(dev))
 -		goto unlock;
 -
 -	port = br_port_get_rcu(dev);
 -	if (!port || !port->br)
 -		goto unlock;
 -
 -	br = port->br;
 -
 -	memset(&eth, 0, sizeof(eth));
 -	eth.h_proto = htons(proto);
 -
 -	ret = br_multicast_querier_exists(br, &eth);
 -
 -unlock:
 -	rcu_read_unlock();
 -	return ret;
 -}
 -EXPORT_SYMBOL_GPL(br_multicast_has_querier_anywhere);
 -
 -/**
 - * br_multicast_has_querier_adjacent - Checks for a querier behind a bridge port
 - * @dev: The bridge port adjacent to which to check for a querier
 - * @proto: The protocol family to check for: IGMP -> ETH_P_IP, MLD -> ETH_P_IPV6
 - *
 - * Checks whether the given interface has a bridge on top and if so returns
 - * true if a selected querier is behind one of the other ports of this
 - * bridge. Otherwise returns false.
 - */
 -bool br_multicast_has_querier_adjacent(struct net_device *dev, int proto)
 -{
 -	struct net_bridge *br;
 -	struct net_bridge_port *port;
 -	bool ret = false;
 -
 -	rcu_read_lock();
 -	if (!br_port_exists(dev))
 -		goto unlock;
 -
 -	port = br_port_get_rcu(dev);
 -	if (!port || !port->br)
 -		goto unlock;
 -
 -	br = port->br;
 -
 -	switch (proto) {
 -	case ETH_P_IP:
 -		if (!timer_pending(&br->ip4_other_query.timer) ||
 -		    rcu_dereference(br->ip4_querier.port) == port)
 -			goto unlock;
 -		break;
 -#if IS_ENABLED(CONFIG_IPV6)
 -	case ETH_P_IPV6:
 -		if (!timer_pending(&br->ip6_other_query.timer) ||
 -		    rcu_dereference(br->ip6_querier.port) == port)
 -			goto unlock;
 -		break;
  #endif
++<<<<<<< HEAD
++=======
+ 	default:
+ 		goto unlock;
+ 	}
+ 
+ 	ret = true;
+ unlock:
+ 	rcu_read_unlock();
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(br_multicast_has_querier_adjacent);
+ 
+ static void br_mcast_stats_add(struct bridge_mcast_stats __percpu *stats,
+ 			       const struct sk_buff *skb, u8 type, u8 dir)
+ {
+ 	struct bridge_mcast_stats *pstats = this_cpu_ptr(stats);
+ 	__be16 proto = skb->protocol;
+ 	unsigned int t_len;
+ 
+ 	u64_stats_update_begin(&pstats->syncp);
+ 	switch (proto) {
+ 	case htons(ETH_P_IP):
+ 		t_len = ntohs(ip_hdr(skb)->tot_len) - ip_hdrlen(skb);
+ 		switch (type) {
+ 		case IGMP_HOST_MEMBERSHIP_REPORT:
+ 			pstats->mstats.igmp_v1reports[dir]++;
+ 			break;
+ 		case IGMPV2_HOST_MEMBERSHIP_REPORT:
+ 			pstats->mstats.igmp_v2reports[dir]++;
+ 			break;
+ 		case IGMPV3_HOST_MEMBERSHIP_REPORT:
+ 			pstats->mstats.igmp_v3reports[dir]++;
+ 			break;
+ 		case IGMP_HOST_MEMBERSHIP_QUERY:
+ 			if (t_len != sizeof(struct igmphdr)) {
+ 				pstats->mstats.igmp_v3queries[dir]++;
+ 			} else {
+ 				unsigned int offset = skb_transport_offset(skb);
+ 				struct igmphdr *ih, _ihdr;
+ 
+ 				ih = skb_header_pointer(skb, offset,
+ 							sizeof(_ihdr), &_ihdr);
+ 				if (!ih)
+ 					break;
+ 				if (!ih->code)
+ 					pstats->mstats.igmp_v1queries[dir]++;
+ 				else
+ 					pstats->mstats.igmp_v2queries[dir]++;
+ 			}
+ 			break;
+ 		case IGMP_HOST_LEAVE_MESSAGE:
+ 			pstats->mstats.igmp_leaves[dir]++;
+ 			break;
+ 		}
+ 		break;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case htons(ETH_P_IPV6):
+ 		t_len = ntohs(ipv6_hdr(skb)->payload_len) +
+ 			sizeof(struct ipv6hdr);
+ 		t_len -= skb_network_header_len(skb);
+ 		switch (type) {
+ 		case ICMPV6_MGM_REPORT:
+ 			pstats->mstats.mld_v1reports[dir]++;
+ 			break;
+ 		case ICMPV6_MLD2_REPORT:
+ 			pstats->mstats.mld_v2reports[dir]++;
+ 			break;
+ 		case ICMPV6_MGM_QUERY:
+ 			if (t_len != sizeof(struct mld_msg))
+ 				pstats->mstats.mld_v2queries[dir]++;
+ 			else
+ 				pstats->mstats.mld_v1queries[dir]++;
+ 			break;
+ 		case ICMPV6_MGM_REDUCTION:
+ 			pstats->mstats.mld_leaves[dir]++;
+ 			break;
+ 		}
+ 		break;
+ #endif /* CONFIG_IPV6 */
+ 	}
+ 	u64_stats_update_end(&pstats->syncp);
+ }
+ 
+ void br_multicast_count(struct net_bridge *br, const struct net_bridge_port *p,
+ 			const struct sk_buff *skb, u8 type, u8 dir)
+ {
+ 	struct bridge_mcast_stats __percpu *stats;
+ 
+ 	/* if multicast_disabled is true then igmp type can't be set */
+ 	if (!type || !br->multicast_stats_enabled)
+ 		return;
+ 
+ 	if (p)
+ 		stats = p->mcast_stats;
+ 	else
+ 		stats = br->mcast_stats;
+ 	if (WARN_ON(!stats))
+ 		return;
+ 
+ 	br_mcast_stats_add(stats, skb, type, dir);
+ }
+ 
+ int br_multicast_init_stats(struct net_bridge *br)
+ {
+ 	br->mcast_stats = netdev_alloc_pcpu_stats(struct bridge_mcast_stats);
+ 	if (!br->mcast_stats)
+ 		return -ENOMEM;
+ 
+ 	return 0;
+ }
+ 
+ void br_multicast_uninit_stats(struct net_bridge *br)
+ {
+ 	free_percpu(br->mcast_stats);
+ }
+ 
+ static void mcast_stats_add_dir(u64 *dst, u64 *src)
+ {
+ 	dst[BR_MCAST_DIR_RX] += src[BR_MCAST_DIR_RX];
+ 	dst[BR_MCAST_DIR_TX] += src[BR_MCAST_DIR_TX];
+ }
+ 
+ void br_multicast_get_stats(const struct net_bridge *br,
+ 			    const struct net_bridge_port *p,
+ 			    struct br_mcast_stats *dest)
+ {
+ 	struct bridge_mcast_stats __percpu *stats;
+ 	struct br_mcast_stats tdst;
+ 	int i;
+ 
+ 	memset(dest, 0, sizeof(*dest));
+ 	if (p)
+ 		stats = p->mcast_stats;
+ 	else
+ 		stats = br->mcast_stats;
+ 	if (WARN_ON(!stats))
+ 		return;
+ 
+ 	memset(&tdst, 0, sizeof(tdst));
+ 	for_each_possible_cpu(i) {
+ 		struct bridge_mcast_stats *cpu_stats = per_cpu_ptr(stats, i);
+ 		struct br_mcast_stats temp;
+ 		unsigned int start;
+ 
+ 		do {
+ 			start = u64_stats_fetch_begin_irq(&cpu_stats->syncp);
+ 			memcpy(&temp, &cpu_stats->mstats, sizeof(temp));
+ 		} while (u64_stats_fetch_retry_irq(&cpu_stats->syncp, start));
+ 
+ 		mcast_stats_add_dir(tdst.igmp_v1queries, temp.igmp_v1queries);
+ 		mcast_stats_add_dir(tdst.igmp_v2queries, temp.igmp_v2queries);
+ 		mcast_stats_add_dir(tdst.igmp_v3queries, temp.igmp_v3queries);
+ 		mcast_stats_add_dir(tdst.igmp_leaves, temp.igmp_leaves);
+ 		mcast_stats_add_dir(tdst.igmp_v1reports, temp.igmp_v1reports);
+ 		mcast_stats_add_dir(tdst.igmp_v2reports, temp.igmp_v2reports);
+ 		mcast_stats_add_dir(tdst.igmp_v3reports, temp.igmp_v3reports);
+ 		tdst.igmp_parse_errors += temp.igmp_parse_errors;
+ 
+ 		mcast_stats_add_dir(tdst.mld_v1queries, temp.mld_v1queries);
+ 		mcast_stats_add_dir(tdst.mld_v2queries, temp.mld_v2queries);
+ 		mcast_stats_add_dir(tdst.mld_leaves, temp.mld_leaves);
+ 		mcast_stats_add_dir(tdst.mld_v1reports, temp.mld_v1reports);
+ 		mcast_stats_add_dir(tdst.mld_v2reports, temp.mld_v2reports);
+ 		tdst.mld_parse_errors += temp.mld_parse_errors;
+ 	}
+ 	memcpy(dest, &tdst, sizeof(*dest));
+ }
++>>>>>>> b6fe0440c637 (bridge: implement missing ndo_uninit())
diff --cc net/bridge/br_private.h
index 1e1daa30e106,0d177280aa84..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -475,7 -614,16 +475,20 @@@ br_multicast_new_port_group(struct net_
  void br_mdb_init(void);
  void br_mdb_uninit(void);
  void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
++<<<<<<< HEAD
 +		   struct br_ip *group, int type);
++=======
+ 		   struct br_ip *group, int type, u8 flags);
+ void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
+ 		   int type);
+ void br_multicast_count(struct net_bridge *br, const struct net_bridge_port *p,
+ 			const struct sk_buff *skb, u8 type, u8 dir);
+ int br_multicast_init_stats(struct net_bridge *br);
+ void br_multicast_uninit_stats(struct net_bridge *br);
+ void br_multicast_get_stats(const struct net_bridge *br,
+ 			    const struct net_bridge_port *p,
+ 			    struct br_mcast_stats *dest);
++>>>>>>> b6fe0440c637 (bridge: implement missing ndo_uninit())
  
  #define mlock_dereference(X, br) \
  	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
@@@ -595,6 -747,28 +608,30 @@@ static inline void br_mdb_init(void
  static inline void br_mdb_uninit(void)
  {
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline void br_multicast_count(struct net_bridge *br,
+ 				      const struct net_bridge_port *p,
+ 				      const struct sk_buff *skb,
+ 				      u8 type, u8 dir)
+ {
+ }
+ 
+ static inline int br_multicast_init_stats(struct net_bridge *br)
+ {
+ 	return 0;
+ }
+ 
+ static inline void br_multicast_uninit_stats(struct net_bridge *br)
+ {
+ }
+ 
+ static inline int br_multicast_igmp_type(const struct sk_buff *skb)
+ {
+ 	return 0;
+ }
++>>>>>>> b6fe0440c637 (bridge: implement missing ndo_uninit())
  #endif
  
  /* br_vlan.c */
diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
index 59112a1972e0..843e3a8391c9 100644
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@ -111,6 +111,15 @@ static int br_dev_init(struct net_device *dev)
 	return err;
 }
 
+static void br_dev_uninit(struct net_device *dev)
+{
+	struct net_bridge *br = netdev_priv(dev);
+
+	br_multicast_uninit_stats(br);
+	br_vlan_flush(br);
+	free_percpu(br->stats);
+}
+
 static int br_dev_open(struct net_device *dev)
 {
 	struct net_bridge *br = netdev_priv(dev);
@@ -327,6 +336,7 @@ static const struct net_device_ops br_netdev_ops = {
 	.ndo_open		 = br_dev_open,
 	.ndo_stop		 = br_dev_stop,
 	.ndo_init		 = br_dev_init,
+	.ndo_uninit		 = br_dev_uninit,
 	.ndo_start_xmit		 = br_dev_xmit,
 	.ndo_get_stats64	 = br_get_stats64,
 	.ndo_set_mac_address	 = br_set_mac_address,
@@ -351,14 +361,6 @@ static const struct net_device_ops br_netdev_ops = {
 	.ndo_features_check	 = passthru_features_check,
 };
 
-static void br_dev_free(struct net_device *dev)
-{
-	struct net_bridge *br = netdev_priv(dev);
-
-	free_percpu(br->stats);
-	free_netdev(dev);
-}
-
 static struct device_type br_type = {
 	.name	= "bridge",
 };
@@ -371,7 +373,7 @@ void br_dev_setup(struct net_device *dev)
 	ether_setup(dev);
 
 	dev->netdev_ops = &br_netdev_ops;
-	dev->destructor = br_dev_free;
+	dev->destructor = free_netdev;
 	dev->ethtool_ops = &br_ethtool_ops;
 	SET_NETDEV_DEVTYPE(dev, &br_type);
 	dev->priv_flags = IFF_EBRIDGE | IFF_NO_QUEUE;
diff --git a/net/bridge/br_if.c b/net/bridge/br_if.c
index 9445aee8bbee..24c1fefb2ba1 100644
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -308,7 +308,6 @@ void br_dev_delete(struct net_device *dev, struct list_head *head)
 
 	br_fdb_delete_by_port(br, NULL, 0, 1);
 
-	br_vlan_flush(br);
 	br_multicast_dev_del(br);
 	del_timer_sync(&br->gc_timer);
 
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_private.h
