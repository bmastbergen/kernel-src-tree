vfio: support notifier chain in vfio_group

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jike Song <jike.song@intel.com>
commit ccd46dbae77dbf0d33f42e04b59536f108c395e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ccd46dba.failed

Beyond vfio_iommu events, users might also be interested in
vfio_group events. For example, if a vfio_group is used along
with Qemu/KVM, whenever kvm pointer is set to/cleared from the
vfio_group, users could be notified.

Currently only VFIO_GROUP_NOTIFY_SET_KVM supported.

	Cc: Kirti Wankhede <kwankhede@nvidia.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Xiao Guangrong <guangrong.xiao@linux.intel.com>
	Signed-off-by: Jike Song <jike.song@intel.com>
[aw: remove use of new typedef]
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
(cherry picked from commit ccd46dbae77dbf0d33f42e04b59536f108c395e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vfio/vfio.c
#	include/linux/vfio.h
diff --cc drivers/vfio/vfio.c
index 4ed340b370b6,9901c4671e2f..000000000000
--- a/drivers/vfio/vfio.c
+++ b/drivers/vfio/vfio.c
@@@ -2015,6 -2014,189 +2021,192 @@@ err_unpin_pages
  }
  EXPORT_SYMBOL(vfio_unpin_pages);
  
++<<<<<<< HEAD
++=======
+ static int vfio_register_iommu_notifier(struct vfio_group *group,
+ 					unsigned long *events,
+ 					struct notifier_block *nb)
+ {
+ 	struct vfio_container *container;
+ 	struct vfio_iommu_driver *driver;
+ 	int ret;
+ 
+ 	ret = vfio_group_add_container_user(group);
+ 	if (ret)
+ 		return -EINVAL;
+ 
+ 	container = group->container;
+ 	down_read(&container->group_lock);
+ 
+ 	driver = container->iommu_driver;
+ 	if (likely(driver && driver->ops->register_notifier))
+ 		ret = driver->ops->register_notifier(container->iommu_data,
+ 						     events, nb);
+ 	else
+ 		ret = -ENOTTY;
+ 
+ 	up_read(&container->group_lock);
+ 	vfio_group_try_dissolve_container(group);
+ 
+ 	return ret;
+ }
+ 
+ static int vfio_unregister_iommu_notifier(struct vfio_group *group,
+ 					  struct notifier_block *nb)
+ {
+ 	struct vfio_container *container;
+ 	struct vfio_iommu_driver *driver;
+ 	int ret;
+ 
+ 	ret = vfio_group_add_container_user(group);
+ 	if (ret)
+ 		return -EINVAL;
+ 
+ 	container = group->container;
+ 	down_read(&container->group_lock);
+ 
+ 	driver = container->iommu_driver;
+ 	if (likely(driver && driver->ops->unregister_notifier))
+ 		ret = driver->ops->unregister_notifier(container->iommu_data,
+ 						       nb);
+ 	else
+ 		ret = -ENOTTY;
+ 
+ 	up_read(&container->group_lock);
+ 	vfio_group_try_dissolve_container(group);
+ 
+ 	return ret;
+ }
+ 
+ void vfio_group_set_kvm(struct vfio_group *group, struct kvm *kvm)
+ {
+ 	group->kvm = kvm;
+ 	blocking_notifier_call_chain(&group->notifier,
+ 				VFIO_GROUP_NOTIFY_SET_KVM, kvm);
+ }
+ EXPORT_SYMBOL_GPL(vfio_group_set_kvm);
+ 
+ static int vfio_register_group_notifier(struct vfio_group *group,
+ 					unsigned long *events,
+ 					struct notifier_block *nb)
+ {
+ 	struct vfio_container *container;
+ 	int ret;
+ 	bool set_kvm = false;
+ 
+ 	if (*events & VFIO_GROUP_NOTIFY_SET_KVM)
+ 		set_kvm = true;
+ 
+ 	/* clear known events */
+ 	*events &= ~VFIO_GROUP_NOTIFY_SET_KVM;
+ 
+ 	/* refuse to continue if still events remaining */
+ 	if (*events)
+ 		return -EINVAL;
+ 
+ 	ret = vfio_group_add_container_user(group);
+ 	if (ret)
+ 		return -EINVAL;
+ 
+ 	container = group->container;
+ 	down_read(&container->group_lock);
+ 
+ 	ret = blocking_notifier_chain_register(&group->notifier, nb);
+ 
+ 	/*
+ 	 * The attaching of kvm and vfio_group might already happen, so
+ 	 * here we replay once upon registration.
+ 	 */
+ 	if (!ret && set_kvm && group->kvm)
+ 		blocking_notifier_call_chain(&group->notifier,
+ 					VFIO_GROUP_NOTIFY_SET_KVM, group->kvm);
+ 
+ 	up_read(&container->group_lock);
+ 	vfio_group_try_dissolve_container(group);
+ 
+ 	return ret;
+ }
+ 
+ static int vfio_unregister_group_notifier(struct vfio_group *group,
+ 					 struct notifier_block *nb)
+ {
+ 	struct vfio_container *container;
+ 	int ret;
+ 
+ 	ret = vfio_group_add_container_user(group);
+ 	if (ret)
+ 		return -EINVAL;
+ 
+ 	container = group->container;
+ 	down_read(&container->group_lock);
+ 
+ 	ret = blocking_notifier_chain_unregister(&group->notifier, nb);
+ 
+ 	up_read(&container->group_lock);
+ 	vfio_group_try_dissolve_container(group);
+ 
+ 	return ret;
+ }
+ 
+ int vfio_register_notifier(struct device *dev, enum vfio_notify_type type,
+ 			   unsigned long *events, struct notifier_block *nb)
+ {
+ 	struct vfio_group *group;
+ 	int ret;
+ 
+ 	if (!dev || !nb || !events || (*events == 0))
+ 		return -EINVAL;
+ 
+ 	group = vfio_group_get_from_dev(dev);
+ 	if (!group)
+ 		return -ENODEV;
+ 
+ 	switch (type) {
+ 	case VFIO_IOMMU_NOTIFY:
+ 		ret = vfio_register_iommu_notifier(group, events, nb);
+ 		break;
+ 	case VFIO_GROUP_NOTIFY:
+ 		ret = vfio_register_group_notifier(group, events, nb);
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 	}
+ 
+ 	vfio_group_put(group);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(vfio_register_notifier);
+ 
+ int vfio_unregister_notifier(struct device *dev, enum vfio_notify_type type,
+ 			     struct notifier_block *nb)
+ {
+ 	struct vfio_group *group;
+ 	int ret;
+ 
+ 	if (!dev || !nb)
+ 		return -EINVAL;
+ 
+ 	group = vfio_group_get_from_dev(dev);
+ 	if (!group)
+ 		return -ENODEV;
+ 
+ 	switch (type) {
+ 	case VFIO_IOMMU_NOTIFY:
+ 		ret = vfio_unregister_iommu_notifier(group, nb);
+ 		break;
+ 	case VFIO_GROUP_NOTIFY:
+ 		ret = vfio_unregister_group_notifier(group, nb);
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 	}
+ 
+ 	vfio_group_put(group);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(vfio_unregister_notifier);
+ 
++>>>>>>> ccd46dbae77d (vfio: support notifier chain in vfio_group)
  /**
   * Module/class support
   */
diff --cc include/linux/vfio.h
index 6428de7ec03f,edf9b2cad277..000000000000
--- a/include/linux/vfio.h
+++ b/include/linux/vfio.h
@@@ -101,6 -108,29 +101,32 @@@ extern int vfio_pin_pages(struct devic
  extern int vfio_unpin_pages(struct device *dev, unsigned long *user_pfn,
  			    int npage);
  
++<<<<<<< HEAD
++=======
+ /* each type has independent events */
+ enum vfio_notify_type {
+ 	VFIO_IOMMU_NOTIFY = 0,
+ 	VFIO_GROUP_NOTIFY = 1,
+ };
+ 
+ /* events for VFIO_IOMMU_NOTIFY */
+ #define VFIO_IOMMU_NOTIFY_DMA_UNMAP	BIT(0)
+ 
+ /* events for VFIO_GROUP_NOTIFY */
+ #define VFIO_GROUP_NOTIFY_SET_KVM	BIT(0)
+ 
+ extern int vfio_register_notifier(struct device *dev,
+ 				  enum vfio_notify_type type,
+ 				  unsigned long *required_events,
+ 				  struct notifier_block *nb);
+ extern int vfio_unregister_notifier(struct device *dev,
+ 				    enum vfio_notify_type type,
+ 				    struct notifier_block *nb);
+ 
+ struct kvm;
+ extern void vfio_group_set_kvm(struct vfio_group *group, struct kvm *kvm);
+ 
++>>>>>>> ccd46dbae77d (vfio: support notifier chain in vfio_group)
  /*
   * Sub-module helpers
   */
* Unmerged path drivers/vfio/vfio.c
* Unmerged path include/linux/vfio.h
