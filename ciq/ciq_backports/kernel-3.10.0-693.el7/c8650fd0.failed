NTB: Fix transport stats for multiple devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [ntb] Fix transport stats for multiple devices (Suravee Suthikulpanit) [1303727]
Rebuild_FUZZ: 94.12%
commit-author Dave Jiang <dave.jiang@intel.com>
commit c8650fd03d320e9c39f44435a583933cacea5259
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c8650fd0.failed

Currently the debugfs does not have files for all NTB transport queue
pairs.  When there are multiple NTBs present in a system, the QP names
of the last transport clobber the names of previously added transport
QPs.  Only the last added QPs can be observed via debugfs.

Create a directory per NTB transport to associate the QPs with that
transport.  Name the directory the same as the PCI device.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Jon Mason <jdmason@kudzu.us>
(cherry picked from commit c8650fd03d320e9c39f44435a583933cacea5259)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ntb/ntb_transport.c
diff --cc drivers/ntb/ntb_transport.c
index 3458260f41b6,25e973ff64cf..000000000000
--- a/drivers/ntb/ntb_transport.c
+++ b/drivers/ntb/ntb_transport.c
@@@ -167,14 -200,20 +167,16 @@@ struct ntb_transport 
  	struct list_head entry;
  	struct list_head client_devs;
  
 -	struct ntb_dev *ndev;
 -
 -	struct ntb_transport_mw *mw_vec;
 -	struct ntb_transport_qp *qp_vec;
 -	unsigned int mw_count;
 -	unsigned int qp_count;
 -	u64 qp_bitmap;
 -	u64 qp_bitmap_free;
 -
 -	bool link_is_up;
 +	struct ntb_device *ndev;
 +	struct ntb_transport_mw *mw;
 +	struct ntb_transport_qp *qps;
 +	unsigned int max_qps;
 +	unsigned long qp_bitmap;
 +	bool transport_link;
  	struct delayed_work link_work;
  	struct work_struct link_cleanup;
+ 
+ 	struct dentry *debugfs_node_dir;
  };
  
  enum {
@@@ -891,12 -947,12 +893,20 @@@ static int ntb_transport_init_queue(str
  	qp->tx_max_frame = min(transport_mtu, tx_size / 2);
  	qp->tx_max_entry = tx_size / qp->tx_max_frame;
  
++<<<<<<< HEAD
 +	if (ntb_query_debugfs(nt->ndev)) {
++=======
+ 	if (nt->debugfs_node_dir) {
++>>>>>>> c8650fd03d32 (NTB: Fix transport stats for multiple devices)
  		char debugfs_name[4];
  
  		snprintf(debugfs_name, 4, "qp%d", qp_num);
  		qp->debugfs_dir = debugfs_create_dir(debugfs_name,
++<<<<<<< HEAD
 +						 ntb_query_debugfs(nt->ndev));
++=======
+ 						     nt->debugfs_node_dir);
++>>>>>>> c8650fd03d32 (NTB: Fix transport stats for multiple devices)
  
  		qp->debugfs_stats = debugfs_create_file("stats", S_IRUSR,
  							qp->debugfs_dir, qp,
@@@ -951,9 -1055,13 +961,19 @@@ int ntb_transport_init(struct pci_dev *
  		goto err2;
  	}
  
++<<<<<<< HEAD
 +	nt->qp_bitmap = ((u64) 1 << nt->max_qps) - 1;
 +
 +	for (i = 0; i < nt->max_qps; i++) {
++=======
+ 	if (nt_debugfs_dir) {
+ 		nt->debugfs_node_dir =
+ 			debugfs_create_dir(pci_name(ndev->pdev),
+ 					   nt_debugfs_dir);
+ 	}
+ 
+ 	for (i = 0; i < qp_count; i++) {
++>>>>>>> c8650fd03d32 (NTB: Fix transport stats for multiple devices)
  		rc = ntb_transport_init_queue(nt, i);
  		if (rc)
  			goto err3;
* Unmerged path drivers/ntb/ntb_transport.c
