firmware: dmi_scan: add SBMIOS entry and DMI tables

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [firmware] dmi_scan: add SBMIOS entry and DMI tables (Prarit Bhargava) [1386195]
Rebuild_FUZZ: 89.13%
commit-author Ivan Khoronzhuk <ivan.khoronzhuk@globallogic.com>
commit d7f96f97c4031fa4ffdb7801f9aae23e96170a6f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d7f96f97.failed

Some utils, like dmidecode and smbios, need to access SMBIOS entry
table area in order to get information like SMBIOS version, size, etc.
Currently it's done via /dev/mem. But for situation when /dev/mem
usage is disabled, the utils have to use dmi sysfs instead, which
doesn't represent SMBIOS entry and adds code/delay redundancy when direct
access for table is needed.

So this patch creates dmi/tables and adds SMBIOS entry point to allow
utils in question to work correctly without /dev/mem. Also patch adds
raw dmi table to simplify dmi table processing in user space, as
proposed by Jean Delvare.

	Tested-by: Roy Franz <roy.franz@linaro.org>
	Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@globallogic.com>
	Signed-off-by: Jean Delvare <jdelvare@suse.de>
(cherry picked from commit d7f96f97c4031fa4ffdb7801f9aae23e96170a6f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	MAINTAINERS
#	drivers/firmware/dmi-sysfs.c
diff --cc MAINTAINERS
index fc1c44f04dab,ca473689d0f4..000000000000
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@@ -2684,18 -3285,26 +2684,29 @@@ S:	Maintaine
  F:	Documentation/hwmon/dme1737
  F:	drivers/hwmon/dme1737.c
  
++<<<<<<< HEAD
 +DOCKING STATION DRIVER
 +M:	Shaohua Li <shaohua.li@intel.com>
 +L:	linux-acpi@vger.kernel.org
 +S:	Supported
 +F:	drivers/acpi/dock.c
++=======
+ DMI/SMBIOS SUPPORT
+ M:	Jean Delvare <jdelvare@suse.de>
+ S:	Maintained
+ T:	quilt http://jdelvare.nerim.net/devel/linux/jdelvare-dmi/
+ F:	Documentation/ABI/testing/sysfs-firmware-dmi-tables
+ F:	drivers/firmware/dmi-id.c
+ F:	drivers/firmware/dmi_scan.c
+ F:	include/linux/dmi.h
++>>>>>>> d7f96f97c403 (firmware: dmi_scan: add SBMIOS entry and DMI tables)
  
  DOCUMENTATION
 -M:	Jonathan Corbet <corbet@lwn.net>
 +M:	Rob Landley <rob@landley.net>
  L:	linux-doc@vger.kernel.org
 +T:	TBD
  S:	Maintained
  F:	Documentation/
 -X:	Documentation/ABI/
 -X:	Documentation/devicetree/
 -X:	Documentation/acpi
 -X:	Documentation/power
 -X:	Documentation/spi
 -T:	git git://git.lwn.net/linux-2.6.git docs-next
  
  DOUBLETALK DRIVER
  M:	"James R. Van Zandt" <jrv@vanzandt.mv.com>
diff --cc drivers/firmware/dmi-sysfs.c
index eb26d62e5188,ef76e5eecf0b..000000000000
--- a/drivers/firmware/dmi-sysfs.c
+++ b/drivers/firmware/dmi-sysfs.c
@@@ -685,7 -686,6 +686,10 @@@ static void __exit dmi_sysfs_exit(void
  	pr_debug("dmi-sysfs: unloading.\n");
  	cleanup_entry_list();
  	kset_unregister(dmi_kset);
++<<<<<<< HEAD
 +	kobject_put(dmi_kobj);
++=======
++>>>>>>> d7f96f97c403 (firmware: dmi_scan: add SBMIOS entry and DMI tables)
  }
  
  module_init(dmi_sysfs_init);
diff --git a/Documentation/ABI/testing/sysfs-firmware-dmi-tables b/Documentation/ABI/testing/sysfs-firmware-dmi-tables
new file mode 100644
index 000000000000..ff3cac8ed0bd
--- /dev/null
+++ b/Documentation/ABI/testing/sysfs-firmware-dmi-tables
@@ -0,0 +1,22 @@
+What:		/sys/firmware/dmi/tables/
+Date:		April 2015
+Contact:	Ivan Khoronzhuk <ivan.khoronzhuk@globallogic.com>
+Description:
+		The firmware provides DMI structures as a packed list of
+		data referenced by a SMBIOS table entry point. The SMBIOS
+		entry point contains general information, like SMBIOS
+		version, DMI table size, etc. The structure, content and
+		size of SMBIOS entry point is dependent on SMBIOS version.
+		The format of SMBIOS entry point and DMI structures
+		can be read in SMBIOS specification.
+
+		The dmi/tables provides raw SMBIOS entry point and DMI tables
+		through sysfs as an alternative to utilities reading them
+		from /dev/mem. The raw SMBIOS entry point and DMI table are
+		presented as binary attributes and are accessible via:
+
+		/sys/firmware/dmi/tables/smbios_entry_point
+		/sys/firmware/dmi/tables/DMI
+
+		The complete DMI information can be obtained using these two
+		tables.
* Unmerged path MAINTAINERS
* Unmerged path drivers/firmware/dmi-sysfs.c
diff --git a/drivers/firmware/dmi_scan.c b/drivers/firmware/dmi_scan.c
index f9c93863556e..7c3214f91b26 100644
--- a/drivers/firmware/dmi_scan.c
+++ b/drivers/firmware/dmi_scan.c
@@ -10,6 +10,9 @@
 #include <asm/dmi.h>
 #include <asm/unaligned.h>
 
+struct kobject *dmi_kobj;
+EXPORT_SYMBOL_GPL(dmi_kobj);
+
 /*
  * DMI stands for "Desktop Management Interface".  It is part
  * of and an antecedent to, SMBIOS, which stands for System
@@ -20,6 +23,9 @@ static const char dmi_empty_string[] = "        ";
 static u32 dmi_ver __initdata;
 static u32 dmi_len;
 static u16 dmi_num;
+static u8 smbios_entry_point[32];
+static int smbios_entry_point_size;
+
 /*
  * Catch too early calls to dmi_check_system():
  */
@@ -493,6 +499,8 @@ static int __init dmi_present(const u8 *buf)
 	if (memcmp(buf, "_SM_", 4) == 0 &&
 	    buf[5] < 32 && dmi_checksum(buf, buf[5])) {
 		smbios_ver = get_unaligned_be16(buf + 6);
+		smbios_entry_point_size = buf[5];
+		memcpy(smbios_entry_point, buf, smbios_entry_point_size);
 
 		/* Some BIOS report weird SMBIOS version, fix that up */
 		switch (smbios_ver) {
@@ -528,6 +536,9 @@ static int __init dmi_present(const u8 *buf)
 				pr_info("SMBIOS %d.%d present.\n",
 					dmi_ver >> 16, (dmi_ver >> 8) & 0xFF);
 			} else {
+				smbios_entry_point_size = 15;
+				memcpy(smbios_entry_point, buf,
+				       smbios_entry_point_size);
 				pr_info("Legacy DMI %d.%d present.\n",
 					dmi_ver >> 16, (dmi_ver >> 8) & 0xFF);
 			}
@@ -552,6 +563,8 @@ static int __init dmi_smbios3_present(const u8 *buf)
 		dmi_num = 0;			/* No longer specified */
 		dmi_len = get_unaligned_le32(buf + 12);
 		dmi_base = get_unaligned_le64(buf + 16);
+		smbios_entry_point_size = buf[6];
+		memcpy(smbios_entry_point, buf, smbios_entry_point_size);
 
 		if (dmi_walk_early(dmi_decode) == 0) {
 			pr_info("SMBIOS %d.%d.%d present.\n",
@@ -643,6 +656,71 @@ void __init dmi_scan_machine(void)
 	dmi_initialized = 1;
 }
 
+static ssize_t raw_table_read(struct file *file, struct kobject *kobj,
+			      struct bin_attribute *attr, char *buf,
+			      loff_t pos, size_t count)
+{
+	memcpy(buf, attr->private + pos, count);
+	return count;
+}
+
+static BIN_ATTR(smbios_entry_point, S_IRUSR, raw_table_read, NULL, 0);
+static BIN_ATTR(DMI, S_IRUSR, raw_table_read, NULL, 0);
+
+static int __init dmi_init(void)
+{
+	struct kobject *tables_kobj;
+	u8 *dmi_table;
+	int ret = -ENOMEM;
+
+	if (!dmi_available) {
+		ret = -ENODATA;
+		goto err;
+	}
+
+	/*
+	 * Set up dmi directory at /sys/firmware/dmi. This entry should stay
+	 * even after farther error, as it can be used by other modules like
+	 * dmi-sysfs.
+	 */
+	dmi_kobj = kobject_create_and_add("dmi", firmware_kobj);
+	if (!dmi_kobj)
+		goto err;
+
+	tables_kobj = kobject_create_and_add("tables", dmi_kobj);
+	if (!tables_kobj)
+		goto err;
+
+	dmi_table = dmi_remap(dmi_base, dmi_len);
+	if (!dmi_table)
+		goto err_tables;
+
+	bin_attr_smbios_entry_point.size = smbios_entry_point_size;
+	bin_attr_smbios_entry_point.private = smbios_entry_point;
+	ret = sysfs_create_bin_file(tables_kobj, &bin_attr_smbios_entry_point);
+	if (ret)
+		goto err_unmap;
+
+	bin_attr_DMI.size = dmi_len;
+	bin_attr_DMI.private = dmi_table;
+	ret = sysfs_create_bin_file(tables_kobj, &bin_attr_DMI);
+	if (!ret)
+		return 0;
+
+	sysfs_remove_bin_file(tables_kobj,
+			      &bin_attr_smbios_entry_point);
+ err_unmap:
+	dmi_unmap(dmi_table);
+ err_tables:
+	kobject_del(tables_kobj);
+	kobject_put(tables_kobj);
+ err:
+	pr_err("dmi: Firmware registration failed.\n");
+
+	return ret;
+}
+subsys_initcall(dmi_init);
+
 /**
  * dmi_set_dump_stack_arch_desc - set arch description for dump_stack()
  *
diff --git a/include/linux/dmi.h b/include/linux/dmi.h
index 0bed810e4b3f..4112fea23cbe 100644
--- a/include/linux/dmi.h
+++ b/include/linux/dmi.h
@@ -2,6 +2,7 @@
 #define __DMI_H__
 
 #include <linux/list.h>
+#include <linux/kobject.h>
 #include <linux/mod_devicetable.h>
 
 /* enum dmi_field is in mod_devicetable.h */
@@ -95,6 +96,7 @@ struct dmi_dev_onboard {
 	int devfn;
 };
 
+extern struct kobject *dmi_kobj;
 extern int dmi_check_system(const struct dmi_system_id *list);
 const struct dmi_system_id *dmi_first_match(const struct dmi_system_id *list);
 extern const char * dmi_get_system_info(int field);
