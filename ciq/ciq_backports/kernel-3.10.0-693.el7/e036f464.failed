NFS: pnfs_mark_matching_lsegs_return() should match the layout sequence id

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit e036f46453f252539cb62bf91d82c3d08e37e73c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e036f464.failed

When determining which layout segments to return, we do want
pnfs_mark_matching_lsegs_return to check that they match the layout
sequence id. This ensures that we don't waste time if the server
is replaying a layout recall that has already been satisfied.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit e036f46453f252539cb62bf91d82c3d08e37e73c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pnfs.c
diff --cc fs/nfs/pnfs.c
index 3653071b6302,52b2a4dfdcb0..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -524,8 -515,50 +515,55 @@@ static int mark_lseg_invalid(struct pnf
  	return rv;
  }
  
++<<<<<<< HEAD
 +/* Returns count of number of matching invalid lsegs remaining in list
 + * after call.
++=======
+ /*
+  * Compare 2 layout stateid sequence ids, to see which is newer,
+  * taking into account wraparound issues.
+  */
+ static bool pnfs_seqid_is_newer(u32 s1, u32 s2)
+ {
+ 	return (s32)(s1 - s2) > 0;
+ }
+ 
+ static bool
+ pnfs_should_free_range(const struct pnfs_layout_range *lseg_range,
+ 		 const struct pnfs_layout_range *recall_range)
+ {
+ 	return (recall_range->iomode == IOMODE_ANY ||
+ 		lseg_range->iomode == recall_range->iomode) &&
+ 	       pnfs_lseg_range_intersecting(lseg_range, recall_range);
+ }
+ 
+ static bool
+ pnfs_match_lseg_recall(const struct pnfs_layout_segment *lseg,
+ 		const struct pnfs_layout_range *recall_range,
+ 		u32 seq)
+ {
+ 	if (seq != 0 && pnfs_seqid_is_newer(lseg->pls_seq, seq))
+ 		return false;
+ 	if (recall_range == NULL)
+ 		return true;
+ 	return pnfs_should_free_range(&lseg->pls_range, recall_range);
+ }
+ 
+ /**
+  * pnfs_mark_matching_lsegs_invalid - tear down lsegs or mark them for later
+  * @lo: layout header containing the lsegs
+  * @tmp_list: list head where doomed lsegs should go
+  * @recall_range: optional recall range argument to match (may be NULL)
+  * @seq: only invalidate lsegs obtained prior to this sequence (may be 0)
+  *
+  * Walk the list of lsegs in the layout header, and tear down any that should
+  * be destroyed. If "recall_range" is specified then the segment must match
+  * that range. If "seq" is non-zero, then only match segments that were handed
+  * out at or before that sequence.
+  *
+  * Returns number of matching invalid lsegs remaining in list after scanning
+  * it and purging them.
++>>>>>>> e036f46453f2 (NFS: pnfs_mark_matching_lsegs_return() should match the layout sequence id)
   */
  int
  pnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,
@@@ -540,12 -574,11 +578,17 @@@
  	if (list_empty(&lo->plh_segs))
  		return 0;
  	list_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)
++<<<<<<< HEAD
 +		if (!recall_range ||
 +		    should_free_lseg(&lseg->pls_range, recall_range)) {
 +			dprintk("%s: freeing lseg %p iomode %d "
++=======
+ 		if (pnfs_match_lseg_recall(lseg, recall_range, seq)) {
+ 			dprintk("%s: freeing lseg %p iomode %d seq %u"
++>>>>>>> e036f46453f2 (NFS: pnfs_mark_matching_lsegs_return() should match the layout sequence id)
  				"offset %llu length %llu\n", __func__,
 -				lseg, lseg->pls_range.iomode, lseg->pls_seq,
 -				lseg->pls_range.offset, lseg->pls_range.length);
 +				lseg, lseg->pls_range.iomode, lseg->pls_range.offset,
 +				lseg->pls_range.length);
  			if (!mark_lseg_invalid(lseg, tmp_list))
  				remaining++;
  		}
* Unmerged path fs/nfs/pnfs.c
