HID: wacom: retrieve name from HID descriptor for generic devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: retrieve name from HID descriptor for generic devices (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 96.00%
commit-author Ping Cheng <pinglinux@gmail.com>
commit c24eab4e0e449845ba98e649b0605ab0450193db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c24eab4e.failed

HID generic devices share the same default name, "Wacom HID". This
causes userland programs to show same device names for different
devices, which would confuse end users with same device names for
different devices too.

This patch uses name retrieved from HID descriptor, if a meaningful
name is reported. Otherwise, affix its product ID to "Wacom HID".

Names from descriptor may contain extra whitespaces. To comfort
readers' eyes, we removed those extra whitespaces too.

	Signed-off-by: Ping Cheng <pingc@wacom.com>
	Reviewed-by: Jason Gerecke <killertofu@gmail.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit c24eab4e0e449845ba98e649b0605ab0450193db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,9c57ac092f77..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1293,10 -1385,74 +1293,78 @@@ static void wacom_calculate_res(struct 
  						    features->unitExpo);
  }
  
 -static size_t wacom_compute_pktlen(struct hid_device *hdev)
 +static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *id)
  {
++<<<<<<< HEAD
++=======
+ 	struct hid_report_enum *report_enum;
+ 	struct hid_report *report;
+ 	size_t size = 0;
+ 
+ 	report_enum = hdev->report_enum + HID_INPUT_REPORT;
+ 
+ 	list_for_each_entry(report, &report_enum->report_list, list) {
+ 		size_t report_size = hid_report_len(report);
+ 		if (report_size > size)
+ 			size = report_size;
+ 	}
+ 
+ 	return size;
+ }
+ 
+ static void wacom_update_name(struct wacom *wacom)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	/* Generic devices name unspecified */
+ 	if ((features->type == HID_GENERIC) && !strcmp("Wacom HID", features->name)) {
+ 		if (strstr(wacom->hdev->name, "Wacom") ||
+ 		    strstr(wacom->hdev->name, "wacom") ||
+ 		    strstr(wacom->hdev->name, "WACOM")) {
+ 			/* name is in HID descriptor, use it */
+ 			strlcpy(wacom_wac->name, wacom->hdev->name,
+ 				sizeof(wacom_wac->name));
+ 
+ 			/* strip out excess whitespaces */
+ 			while (1) {
+ 				char *gap = strstr(wacom_wac->name, "  ");
+ 				if (gap == NULL)
+ 					break;
+ 				/* shift everything including the terminator */
+ 				memmove(gap, gap+1, strlen(gap));
+ 			}
+ 			/* get rid of trailing whitespace */
+ 			if (wacom_wac->name[strlen(wacom_wac->name)-1] == ' ')
+ 				wacom_wac->name[strlen(wacom_wac->name)-1] = '\0';
+ 		} else {
+ 			/* no meaningful name retrieved. use product ID */
+ 			snprintf(wacom_wac->name, sizeof(wacom_wac->name),
+ 				 "%s %X", features->name, wacom->hdev->product);
+ 		}
+ 	} else {
+ 		strlcpy(wacom_wac->name, features->name, sizeof(wacom_wac->name));
+ 	}
+ 
+ 	/* Append the device type to the name */
+ 	snprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),
+ 		"%s Pad", wacom_wac->name);
+ 
+ 	if (features->device_type != BTN_TOOL_FINGER)
+ 		strlcat(wacom_wac->name, " Pen", WACOM_NAME_MAX);
+ 	else if (features->touch_max)
+ 		strlcat(wacom_wac->name, " Finger", WACOM_NAME_MAX);
+ 	else
+ 		strlcat(wacom_wac->name, " Pad", WACOM_NAME_MAX);
+ }
+ 
+ static int wacom_probe(struct hid_device *hdev,
+ 		const struct hid_device_id *id)
+ {
+ 	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
++>>>>>>> c24eab4e0e44 (HID: wacom: retrieve name from HID descriptor for generic devices)
  	struct usb_device *dev = interface_to_usbdev(intf);
 +	struct usb_endpoint_descriptor *endpoint;
  	struct wacom *wacom;
  	struct wacom_wac *wacom_wac;
  	struct wacom_features *features;
@@@ -1364,51 -1521,50 +1432,55 @@@
  		}
  	}
  
 -	/* set the default size in case we do not get them from hid */
 -	wacom_set_default_phy(features);
 +	wacom_setup_device_quirks(features);
  
 -	/* Retrieve the physical and logical size for touch devices */
 -	wacom_retrieve_hid_descriptor(hdev, features);
 -
 -	wacom_setup_device_quirks(wacom);
 +	/* set unit to "100th of a mm" for devices not reported by HID */
 +	if (!features->unit) {
 +		features->unit = 0x11;
 +		features->unitExpo = 16 - 3;
 +	}
  	wacom_calculate_res(features);
  
++<<<<<<< HEAD
 +	strlcpy(wacom_wac->name, features->name, sizeof(wacom_wac->name));
 +
 +	if (features->quirks & WACOM_QUIRK_MULTI_INPUT) {
 +		struct usb_device *other_dev;
++=======
+ 	wacom_update_name(wacom);
++>>>>>>> c24eab4e0e44 (HID: wacom: retrieve name from HID descriptor for generic devices)
  
 -	error = wacom_add_shared_data(hdev);
 -	if (error)
 -		goto fail_shared_data;
 +		/* Append the device type to the name */
 +		if (features->device_type != BTN_TOOL_FINGER)
 +			strlcat(wacom_wac->name, " Pen", WACOM_NAME_MAX);
 +		else if (features->touch_max)
 +			strlcat(wacom_wac->name, " Finger", WACOM_NAME_MAX);
 +		else
 +			strlcat(wacom_wac->name, " Pad", WACOM_NAME_MAX);
  
 -	if (!(features->quirks & WACOM_QUIRK_MONITOR) &&
 -	     (features->quirks & WACOM_QUIRK_BATTERY)) {
 -		error = wacom_initialize_battery(wacom);
 +		other_dev = wacom_get_sibling(dev, features->oVid, features->oPid);
 +		if (other_dev == NULL || wacom_get_usbdev_data(other_dev) == NULL)
 +			other_dev = dev;
 +		error = wacom_add_shared_data(wacom_wac, other_dev);
  		if (error)
 -			goto fail_battery;
 +			goto fail3;
  	}
  
 -	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
 -		error = wacom_register_inputs(wacom);
 -		if (error)
 -			goto fail_register_inputs;
 -	}
 +	usb_fill_int_urb(wacom->irq, dev,
 +			 usb_rcvintpipe(dev, endpoint->bEndpointAddress),
 +			 wacom_wac->data, features->pktlen,
 +			 wacom_sys_irq, wacom, endpoint->bInterval);
 +	wacom->irq->transfer_dma = wacom->data_dma;
 +	wacom->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
  
 -	if (hdev->bus == BUS_BLUETOOTH) {
 -		error = device_create_file(&hdev->dev, &dev_attr_speed);
 -		if (error)
 -			hid_warn(hdev,
 -				 "can't create sysfs speed attribute err: %d\n",
 -				 error);
 -	}
 -
 -	if (features->type == HID_GENERIC)
 -		connect_mask |= HID_CONNECT_DRIVER;
 +	error = wacom_initialize_leds(wacom);
 +	if (error)
 +		goto fail4;
  
 -	/* Regular HID work starts now */
 -	error = hid_hw_start(hdev, connect_mask);
 -	if (error) {
 -		hid_err(hdev, "hw start failed\n");
 -		goto fail_hw_start;
 +	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
 +		error = wacom_register_input(wacom);
 +		if (error)
 +			goto fail5;
  	}
  
  	/* Note that if query fails it is not a hard failure */
* Unmerged path drivers/hid/wacom_sys.c
