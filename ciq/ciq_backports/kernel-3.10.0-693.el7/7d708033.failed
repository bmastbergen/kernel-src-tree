scsi: lpfc: Finalize Kconfig options for nvme

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] lpfc: Finalize Kconfig options for nvme (Ewan Milne) [1384922]
Rebuild_FUZZ: 92.86%
commit-author James Smart <jsmart2021@gmail.com>
commit 7d7080335f8d93a51e8238b6e85be8af4ba452b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7d708033.failed

Reviewing the result of what was just added for Kconfig, we made a poor
choice. It worked well for full kernel builds, but not so much for how
it would be deployed on a distro.

Here's the final result:
- lpfc will compile in NVME initiator and/or NVME target support based
  on whether the kernel has the corresponding subsystem support.
  Kconfig is not used to drive this specifically for lpfc.
- There is a module parameter, lpfc_enable_fc4_type, that indicates
  whether the ports will do FCP-only or FCP & NVME (NVME-only not yet
  possible due to dependency on fc transport). As FCP & NVME divvys up
  exchange resources, and given NVME will not be often initially, the
  default is changed to FCP only.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 7d7080335f8d93a51e8238b6e85be8af4ba452b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_attr.c
#	drivers/scsi/lpfc/lpfc_init.c
#	drivers/scsi/lpfc/lpfc_nvme.c
#	drivers/scsi/lpfc/lpfc_nvmet.c
diff --cc drivers/scsi/lpfc/lpfc_attr.c
index c5f7d60f9dff,84aa62f1a4de..000000000000
--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@@ -3110,6 -3285,59 +3110,62 @@@ static DEVICE_ATTR(lpfc_devloss_tmo, S_
  		   lpfc_devloss_tmo_show, lpfc_devloss_tmo_store);
  
  /*
++<<<<<<< HEAD
++=======
+  * lpfc_suppress_rsp: Enable suppress rsp feature is firmware supports it
+  * lpfc_suppress_rsp = 0  Disable
+  * lpfc_suppress_rsp = 1  Enable (default)
+  *
+  */
+ LPFC_ATTR_R(suppress_rsp, 1, 0, 1,
+ 	    "Enable suppress rsp feature is firmware supports it");
+ 
+ /*
+  * lpfc_nvmet_mrq: Specify number of RQ pairs for processing NVMET cmds
+  * lpfc_nvmet_mrq = 1  use a single RQ pair
+  * lpfc_nvmet_mrq >= 2  use specified RQ pairs for MRQ
+  *
+  */
+ LPFC_ATTR_R(nvmet_mrq,
+ 	    1, 1, 16,
+ 	    "Specify number of RQ pairs for processing NVMET cmds");
+ 
+ /*
+  * lpfc_nvmet_mrq_post: Specify number buffers to post on every MRQ
+  *
+  */
+ LPFC_ATTR_R(nvmet_mrq_post, LPFC_DEF_MRQ_POST,
+ 	    LPFC_MIN_MRQ_POST, LPFC_MAX_MRQ_POST,
+ 	    "Specify number of buffers to post on every MRQ");
+ 
+ /*
+  * lpfc_enable_fc4_type: Defines what FC4 types are supported.
+  * Supported Values:  1 - register just FCP
+  *                    3 - register both FCP and NVME
+  * Supported values are [1,3]. Default value is 1
+  */
+ LPFC_ATTR_R(enable_fc4_type, LPFC_ENABLE_FCP,
+ 	    LPFC_ENABLE_FCP, LPFC_ENABLE_BOTH,
+ 	    "Define fc4 type to register with fabric.");
+ 
+ /*
+  * lpfc_xri_split: Defines the division of XRI resources between SCSI and NVME
+  * This parameter is only used if:
+  *     lpfc_enable_fc4_type is 3 - register both FCP and NVME and
+  *     port is not configured for NVMET.
+  *
+  * ELS/CT always get 10% of XRIs, up to a maximum of 250
+  * The remaining XRIs get split up based on lpfc_xri_split per port:
+  *
+  * Supported Values are in percentages
+  * the xri_split value is the percentage the SCSI port will get. The remaining
+  * percentage will go to NVME.
+  */
+ LPFC_ATTR_R(xri_split, 50, 10, 90,
+ 	     "Division of XRI resources between SCSI and NVME");
+ 
+ /*
++>>>>>>> 7d7080335f8d (scsi: lpfc: Finalize Kconfig options for nvme)
  # lpfc_log_verbose: Only turn this flag on if you are willing to risk being
  # deluged with LOTS of information.
  # You can set a bit mask to record specific types of verbose messages:
diff --cc drivers/scsi/lpfc/lpfc_init.c
index bbd4080d8122,6cc561b04211..000000000000
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@@ -5399,6 -5861,53 +5399,56 @@@ lpfc_sli4_driver_resource_setup(struct 
  		goto out_free_bsmbx;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Check for NVMET being configured */
+ 	phba->nvmet_support = 0;
+ 	if (lpfc_enable_nvmet_cnt) {
+ 
+ 		/* First get WWN of HBA instance */
+ 		lpfc_read_nv(phba, mboxq);
+ 		rc = lpfc_sli_issue_mbox(phba, mboxq, MBX_POLL);
+ 		if (rc != MBX_SUCCESS) {
+ 			lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
+ 					"6016 Mailbox failed , mbxCmd x%x "
+ 					"READ_NV, mbxStatus x%x\n",
+ 					bf_get(lpfc_mqe_command, &mboxq->u.mqe),
+ 					bf_get(lpfc_mqe_status, &mboxq->u.mqe));
+ 			rc = -EIO;
+ 			goto out_free_bsmbx;
+ 		}
+ 		mb = &mboxq->u.mb;
+ 		memcpy(&wwn, (char *)mb->un.varRDnvp.nodename,
+ 		       sizeof(uint64_t));
+ 		wwn = cpu_to_be64(wwn);
+ 		phba->sli4_hba.wwnn.u.name = wwn;
+ 		memcpy(&wwn, (char *)mb->un.varRDnvp.portname,
+ 		       sizeof(uint64_t));
+ 		/* wwn is WWPN of HBA instance */
+ 		wwn = cpu_to_be64(wwn);
+ 		phba->sli4_hba.wwpn.u.name = wwn;
+ 
+ 		/* Check to see if it matches any module parameter */
+ 		for (i = 0; i < lpfc_enable_nvmet_cnt; i++) {
+ 			if (wwn == lpfc_enable_nvmet[i]) {
+ #if (IS_ENABLED(CONFIG_NVME_TARGET_FC))
+ 				lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 						"6017 NVME Target %016llx\n",
+ 						wwn);
+ 				phba->nvmet_support = 1; /* a match */
+ #else
+ 				lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 						"6021 Can't enable NVME Target."
+ 						" NVME_TARGET_FC infrastructure"
+ 						" is not in kernel\n");
+ #endif
+ 			}
+ 		}
+ 	}
+ 
+ 	lpfc_nvme_mod_param_dep(phba);
+ 
++>>>>>>> 7d7080335f8d (scsi: lpfc: Finalize Kconfig options for nvme)
  	/* Get the Supported Pages if PORT_CAPABILITIES is supported by port. */
  	lpfc_supported_pages(mboxq);
  	rc = lpfc_sli_issue_mbox(phba, mboxq, MBX_POLL);
* Unmerged path drivers/scsi/lpfc/lpfc_nvme.c
* Unmerged path drivers/scsi/lpfc/lpfc_nvmet.c
* Unmerged path drivers/scsi/lpfc/lpfc_attr.c
* Unmerged path drivers/scsi/lpfc/lpfc_init.c
* Unmerged path drivers/scsi/lpfc/lpfc_nvme.c
* Unmerged path drivers/scsi/lpfc/lpfc_nvmet.c
