dax: remote unused fault wrappers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ross Zwisler <ross.zwisler@linux.intel.com>
commit 6b524995a71d49ae032dba308d117dbf2a18d175
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6b524995.failed

Remove the unused wrappers dax_fault() and dax_pmd_fault().  After this
removal, rename __dax_fault() and __dax_pmd_fault() to dax_fault() and
dax_pmd_fault() respectively, and update all callers.

The dax_fault() and dax_pmd_fault() wrappers were initially intended to
capture some filesystem independent functionality around page faults
(calling sb_start_pagefault() & sb_end_pagefault(), updating file mtime
and ctime).

However, the following commits:

   5726b27b09cc ("ext2: Add locking for DAX faults")
   ea3d7209ca01 ("ext4: fix races between page faults and hole punching")

added locking to the ext2 and ext4 filesystems after these common
operations but before __dax_fault() and __dax_pmd_fault() were called.
This means that these wrappers are no longer used, and are unlikely to
be used in the future.

XFS has had locking analogous to what was recently added to ext2 and
ext4 since DAX support was initially introduced by:

   6b698edeeef0 ("xfs: add DAX file operations support")

Link: http://lkml.kernel.org/r/20160714214049.20075-2-ross.zwisler@linux.intel.com
	Signed-off-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Cc: "Theodore Ts'o" <tytso@mit.edu>
	Cc: Alexander Viro <viro@zeniv.linux.org.uk>
	Cc: Andreas Dilger <adilger.kernel@dilger.ca>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Chinner <david@fromorbit.com>
	Reviewed-by: Jan Kara <jack@suse.cz>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 6b524995a71d49ae032dba308d117dbf2a18d175)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
#	fs/ext2/file.c
#	fs/ext4/file.c
#	fs/xfs/xfs_file.c
#	include/linux/dax.h
diff --cc fs/dax.c
index 3ad95e9ec809,432b9e6dd63b..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -622,19 -823,13 +622,24 @@@ static int dax_insert_mapping(struct in
   * @vma: The virtual memory area where the fault occurred
   * @vmf: The description of the fault
   * @get_block: The filesystem method used to translate file offsets to blocks
 + * @complete_unwritten: The filesystem method used to convert unwritten blocks
 + *	to written so the data written to them is exposed. This is required for
 + *	required by write faults for filesystems that will return unwritten
 + *	extent mappings from @get_block, but it is optional for reads as
 + *	dax_insert_mapping() will always zero unwritten blocks. If the fs does
 + *	not support unwritten extents, the it should pass NULL.
   *
   * When a page fault occurs, filesystems may call this helper in their
-  * fault handler for DAX files. __dax_fault() assumes the caller has done all
+  * fault handler for DAX files. dax_fault() assumes the caller has done all
   * the necessary locking for the page fault to proceed successfully.
   */
++<<<<<<< HEAD
 +int __dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,
 +			get_block_t get_block, dax_iodone_t complete_unwritten)
++=======
+ int dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,
+ 			get_block_t get_block)
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  {
  	struct file *file = vma->vm_file;
  	struct address_space *mapping = file->f_mapping;
@@@ -762,53 -912,45 +767,88 @@@
  	if ((error < 0) && (error != -EBUSY))
  		return VM_FAULT_SIGBUS | major;
  	return VM_FAULT_NOPAGE | major;
 +
 + unlock_page:
 +	if (page) {
 +		unlock_page(page);
 +		page_cache_release(page);
 +	}
 +	goto out;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(__dax_fault);
 +
 +/**
 + * dax_fault - handle a page fault on a DAX file
 + * @vma: The virtual memory area where the fault occurred
 + * @vmf: The description of the fault
 + * @get_block: The filesystem method used to translate file offsets to blocks
 + *
 + * When a page fault occurs, filesystems may call this helper in their
 + * fault handler for DAX files.
 + */
 +int dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,
 +	      get_block_t get_block, dax_iodone_t complete_unwritten)
 +{
 +	int result;
 +	struct super_block *sb = file_inode(vma->vm_file)->i_sb;
 +
 +	if (vmf->flags & FAULT_FLAG_WRITE) {
 +		sb_start_pagefault(sb);
 +		file_update_time(vma->vm_file);
 +	}
 +	result = __dax_fault(vma, vmf, get_block, complete_unwritten);
 +	if (vmf->flags & FAULT_FLAG_WRITE)
 +		sb_end_pagefault(sb);
 +
 +	return result;
 +}
++=======
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  EXPORT_SYMBOL_GPL(dax_fault);
  
 -#if defined(CONFIG_TRANSPARENT_HUGEPAGE)
 +#ifdef CONFIG_TRANSPARENT_HUGEPAGE
  /*
   * The 'colour' (ie low bits) within a PMD of a page offset.  This comes up
   * more often than one might expect in the below function.
   */
  #define PG_PMD_COLOUR	((PMD_SIZE >> PAGE_SHIFT) - 1)
  
++<<<<<<< HEAD
 +int __dax_pmd_fault(struct vm_area_struct *vma, unsigned long address,
 +		pmd_t *pmd, unsigned int flags, get_block_t get_block,
 +		dax_iodone_t complete_unwritten)
++=======
+ static void __dax_dbg(struct buffer_head *bh, unsigned long address,
+ 		const char *reason, const char *fn)
+ {
+ 	if (bh) {
+ 		char bname[BDEVNAME_SIZE];
+ 		bdevname(bh->b_bdev, bname);
+ 		pr_debug("%s: %s addr: %lx dev %s state %lx start %lld "
+ 			"length %zd fallback: %s\n", fn, current->comm,
+ 			address, bname, bh->b_state, (u64)bh->b_blocknr,
+ 			bh->b_size, reason);
+ 	} else {
+ 		pr_debug("%s: %s addr: %lx fallback: %s\n", fn,
+ 			current->comm, address, reason);
+ 	}
+ }
+ 
+ #define dax_pmd_dbg(bh, address, reason)	__dax_dbg(bh, address, reason, "dax_pmd")
+ 
+ /**
+  * dax_pmd_fault - handle a PMD fault on a DAX file
+  * @vma: The virtual memory area where the fault occurred
+  * @vmf: The description of the fault
+  * @get_block: The filesystem method used to translate file offsets to blocks
+  *
+  * When a page fault occurs, filesystems may call this helper in their
+  * pmd_fault handler for DAX files.
+  */
+ int dax_pmd_fault(struct vm_area_struct *vma, unsigned long address,
+ 		pmd_t *pmd, unsigned int flags, get_block_t get_block)
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  {
  	struct file *file = vma->vm_file;
  	struct address_space *mapping = file->f_mapping;
@@@ -997,35 -1130,6 +1037,38 @@@
  	result = VM_FAULT_FALLBACK;
  	goto out;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(__dax_pmd_fault);
 +
 +/**
 + * dax_pmd_fault - handle a PMD fault on a DAX file
 + * @vma: The virtual memory area where the fault occurred
 + * @vmf: The description of the fault
 + * @get_block: The filesystem method used to translate file offsets to blocks
 + *
 + * When a page fault occurs, filesystems may call this helper in their
 + * pmd_fault handler for DAX files.
 + */
 +int dax_pmd_fault(struct vm_area_struct *vma, unsigned long address,
 +			pmd_t *pmd, unsigned int flags, get_block_t get_block,
 +			dax_iodone_t complete_unwritten)
 +{
 +	int result;
 +	struct super_block *sb = file_inode(vma->vm_file)->i_sb;
 +
 +	if (flags & FAULT_FLAG_WRITE) {
 +		sb_start_pagefault(sb);
 +		file_update_time(vma->vm_file);
 +	}
 +	result = __dax_pmd_fault(vma, address, pmd, flags, get_block,
 +				complete_unwritten);
 +	if (flags & FAULT_FLAG_WRITE)
 +		sb_end_pagefault(sb);
 +
 +	return result;
 +}
++=======
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  EXPORT_SYMBOL_GPL(dax_pmd_fault);
  #endif /* CONFIG_TRANSPARENT_HUGEPAGE */
  
diff --cc fs/ext2/file.c
index 97f094d5601e,5efeefe17abb..000000000000
--- a/fs/ext2/file.c
+++ b/fs/ext2/file.c
@@@ -51,7 -51,7 +51,11 @@@ static int ext2_dax_fault(struct vm_are
  	}
  	down_read(&ei->dax_sem);
  
++<<<<<<< HEAD
 +	ret = __dax_fault(vma, vmf, ext2_get_block, NULL);
++=======
+ 	ret = dax_fault(vma, vmf, ext2_get_block);
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  
  	up_read(&ei->dax_sem);
  	if (vmf->flags & FAULT_FLAG_WRITE)
@@@ -72,7 -72,7 +76,11 @@@ static int ext2_dax_pmd_fault(struct vm
  	}
  	down_read(&ei->dax_sem);
  
++<<<<<<< HEAD
 +	ret = __dax_pmd_fault(vma, addr, pmd, flags, ext2_get_block, NULL);
++=======
+ 	ret = dax_pmd_fault(vma, addr, pmd, flags, ext2_get_block);
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  
  	up_read(&ei->dax_sem);
  	if (flags & FAULT_FLAG_WRITE)
diff --cc fs/ext4/file.c
index de8914c0fbc1,6664f9c82005..000000000000
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@@ -222,7 -202,7 +222,11 @@@ static int ext4_dax_fault(struct vm_are
  	if (IS_ERR(handle))
  		result = VM_FAULT_SIGBUS;
  	else
++<<<<<<< HEAD
 +		result = __dax_fault(vma, vmf, ext4_dax_mmap_get_block, NULL);
++=======
+ 		result = dax_fault(vma, vmf, ext4_dax_get_block);
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  
  	if (write) {
  		if (!IS_ERR(handle))
@@@ -257,8 -237,8 +261,13 @@@ static int ext4_dax_pmd_fault(struct vm
  	if (IS_ERR(handle))
  		result = VM_FAULT_SIGBUS;
  	else
++<<<<<<< HEAD
 +		result = __dax_pmd_fault(vma, addr, pmd, flags,
 +				ext4_dax_mmap_get_block, NULL);
++=======
+ 		result = dax_pmd_fault(vma, addr, pmd, flags,
+ 					 ext4_dax_get_block);
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  
  	if (write) {
  		if (!IS_ERR(handle))
diff --cc fs/xfs/xfs_file.c
index 815d8f3721f9,1b3dc9dd8861..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -1595,9 -1551,9 +1595,13 @@@ xfs_filemap_page_mkwrite
  	xfs_ilock(XFS_I(inode), XFS_MMAPLOCK_SHARED);
  
  	if (IS_DAX(inode)) {
++<<<<<<< HEAD
 +		ret = __dax_mkwrite(vma, vmf, xfs_get_blocks_dax_fault, NULL);
++=======
+ 		ret = dax_mkwrite(vma, vmf, xfs_get_blocks_dax_fault);
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  	} else {
 -		ret = block_page_mkwrite(vma, vmf, xfs_get_blocks);
 +		ret = __block_page_mkwrite(vma, vmf, xfs_get_blocks);
  		ret = block_page_mkwrite_return(ret);
  	}
  
@@@ -1629,7 -1585,7 +1633,11 @@@ xfs_filemap_fault
  		 * changes to xfs_get_blocks_direct() to map unwritten extent
  		 * ioend for conversion on read-only mappings.
  		 */
++<<<<<<< HEAD
 +		ret = __dax_fault(vma, vmf, xfs_get_blocks_dax_fault, NULL);
++=======
+ 		ret = dax_fault(vma, vmf, xfs_get_blocks_dax_fault);
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  	} else
  		ret = filemap_fault(vma, vmf);
  	xfs_iunlock(XFS_I(inode), XFS_MMAPLOCK_SHARED);
@@@ -1666,8 -1622,7 +1674,12 @@@ xfs_filemap_pmd_fault
  	}
  
  	xfs_ilock(XFS_I(inode), XFS_MMAPLOCK_SHARED);
++<<<<<<< HEAD
 +	ret = __dax_pmd_fault(vma, addr, pmd, flags, xfs_get_blocks_dax_fault,
 +			      NULL);
++=======
+ 	ret = dax_pmd_fault(vma, addr, pmd, flags, xfs_get_blocks_dax_fault);
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  	xfs_iunlock(XFS_I(inode), XFS_MMAPLOCK_SHARED);
  
  	if (flags & FAULT_FLAG_WRITE)
diff --cc include/linux/dax.h
index 7ccafd8f7b0c,9c6dc7704043..000000000000
--- a/include/linux/dax.h
+++ b/include/linux/dax.h
@@@ -6,16 -6,17 +6,23 @@@
  #include <linux/radix-tree.h>
  #include <asm/pgtable.h>
  
 -/* We use lowest available exceptional entry bit for locking */
 -#define RADIX_DAX_ENTRY_LOCK (1 << RADIX_TREE_EXCEPTIONAL_SHIFT)
 -
 -ssize_t dax_do_io(struct kiocb *, struct inode *, struct iov_iter *,
 -		  get_block_t, dio_iodone_t, int flags);
 +ssize_t dax_do_io(int rw, struct kiocb *iocb, struct inode *inode,
 +                  const struct iovec *iov, loff_t pos, unsigned long nr_segs,
 +                  get_block_t get_block, dio_iodone_t end_io, int flags);
 +int dax_clear_sectors(struct block_device *bdev, sector_t _sector, long _size);
  int dax_zero_page_range(struct inode *, loff_t from, unsigned len, get_block_t);
  int dax_truncate_page(struct inode *, loff_t from, get_block_t);
++<<<<<<< HEAD
 +int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t,
 +		dax_iodone_t);
 +int __dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t,
 +		dax_iodone_t);
++=======
+ int dax_fault(struct vm_area_struct *, struct vm_fault *, get_block_t);
+ int dax_delete_mapping_entry(struct address_space *mapping, pgoff_t index);
+ void dax_wake_mapping_entry_waiter(struct address_space *mapping,
+ 				   pgoff_t index, bool wake_all);
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  
  #ifdef CONFIG_FS_DAX
  struct page *read_dax_sector(struct block_device *bdev, sector_t n);
@@@ -25,25 -29,31 +32,32 @@@ static inline struct page *read_dax_sec
  {
  	return ERR_PTR(-ENXIO);
  }
 -/* Shouldn't ever be called when dax is disabled. */
 -static inline void dax_unlock_mapping_entry(struct address_space *mapping,
 -					    pgoff_t index)
 -{
 -	BUG();
 -}
 -static inline int __dax_zero_page_range(struct block_device *bdev,
 -		sector_t sector, unsigned int offset, unsigned int length)
 -{
 -	return -ENXIO;
 -}
  #endif
  
 -#if defined(CONFIG_TRANSPARENT_HUGEPAGE)
 +#ifdef CONFIG_TRANSPARENT_HUGEPAGE
  int dax_pmd_fault(struct vm_area_struct *, unsigned long addr, pmd_t *,
++<<<<<<< HEAD
 +				unsigned int flags, get_block_t, dax_iodone_t);
 +int __dax_pmd_fault(struct vm_area_struct *, unsigned long addr, pmd_t *,
 +				unsigned int flags, get_block_t, dax_iodone_t);
++=======
+ 				unsigned int flags, get_block_t);
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  #else
  static inline int dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,
 -				pmd_t *pmd, unsigned int flags, get_block_t gb)
 +				pmd_t *pmd, unsigned int flags, get_block_t gb,
 +				dax_iodone_t di)
  {
  	return VM_FAULT_FALLBACK;
  }
- #define __dax_pmd_fault dax_pmd_fault
  #endif
  int dax_pfn_mkwrite(struct vm_area_struct *, struct vm_fault *);
++<<<<<<< HEAD
 +#define dax_mkwrite(vma, vmf, gb, iod)		dax_fault(vma, vmf, gb, iod)
 +#define __dax_mkwrite(vma, vmf, gb, iod)	__dax_fault(vma, vmf, gb, iod)
++=======
+ #define dax_mkwrite(vma, vmf, gb)	dax_fault(vma, vmf, gb)
++>>>>>>> 6b524995a71d (dax: remote unused fault wrappers)
  
  static inline bool vma_is_dax(struct vm_area_struct *vma)
  {
* Unmerged path fs/dax.c
* Unmerged path fs/ext2/file.c
* Unmerged path fs/ext4/file.c
* Unmerged path fs/xfs/xfs_file.c
* Unmerged path include/linux/dax.h
