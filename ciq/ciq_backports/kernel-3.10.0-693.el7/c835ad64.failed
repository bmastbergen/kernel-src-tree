net/mlx5: Implement PCAM, MCAM access register commands

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Implement PCAM, MCAM access register commands (Kamal Heib) [1409101]
Rebuild_FUZZ: 96.23%
commit-author Gal Pressman <galp@mellanox.com>
commit c835ad64683bd3e2d1b31ed2cb1ff4366932edb1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c835ad64.failed

Introduced registers will expose capabilities of new registers and
features related to port/management.
Driver will query MCAM and PCAM in order to avoid failing on old
firmwares with lack of support.

	Signed-off-by: Gal Pressman <galp@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit c835ad64683bd3e2d1b31ed2cb1ff4366932edb1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index 1f3289b370d9,b3dabe6e8836..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@@ -103,6 -113,41 +103,44 @@@ u32 mlx5_get_msix_vec(struct mlx5_core_
  struct mlx5_eq *mlx5_eqn2eq(struct mlx5_core_dev *dev, int eqn);
  void mlx5_cq_tasklet_cb(unsigned long data);
  
++<<<<<<< HEAD
++=======
+ int mlx5_query_pcam_reg(struct mlx5_core_dev *dev, u32 *pcam, u8 feature_group,
+ 			u8 access_reg_group);
+ int mlx5_query_mcam_reg(struct mlx5_core_dev *dev, u32 *mcap, u8 feature_group,
+ 			u8 access_reg_group);
+ 
+ void mlx5_lag_add(struct mlx5_core_dev *dev, struct net_device *netdev);
+ void mlx5_lag_remove(struct mlx5_core_dev *dev);
+ 
+ void mlx5_add_device(struct mlx5_interface *intf, struct mlx5_priv *priv);
+ void mlx5_remove_device(struct mlx5_interface *intf, struct mlx5_priv *priv);
+ void mlx5_attach_device(struct mlx5_core_dev *dev);
+ void mlx5_detach_device(struct mlx5_core_dev *dev);
+ bool mlx5_device_registered(struct mlx5_core_dev *dev);
+ int mlx5_register_device(struct mlx5_core_dev *dev);
+ void mlx5_unregister_device(struct mlx5_core_dev *dev);
+ void mlx5_add_dev_by_protocol(struct mlx5_core_dev *dev, int protocol);
+ void mlx5_remove_dev_by_protocol(struct mlx5_core_dev *dev, int protocol);
+ struct mlx5_core_dev *mlx5_get_next_phys_dev(struct mlx5_core_dev *dev);
+ void mlx5_dev_list_lock(void);
+ void mlx5_dev_list_unlock(void);
+ int mlx5_dev_list_trylock(void);
+ int mlx5_encap_alloc(struct mlx5_core_dev *dev,
+ 		     int header_type,
+ 		     size_t size,
+ 		     void *encap_header,
+ 		     u32 *encap_id);
+ void mlx5_encap_dealloc(struct mlx5_core_dev *dev, u32 encap_id);
+ 
+ bool mlx5_lag_intf_add(struct mlx5_interface *intf, struct mlx5_priv *priv);
+ 
+ int mlx5_query_mtpps(struct mlx5_core_dev *dev, u32 *mtpps, u32 mtpps_size);
+ int mlx5_set_mtpps(struct mlx5_core_dev *mdev, u32 *mtpps, u32 mtpps_size);
+ int mlx5_query_mtppse(struct mlx5_core_dev *mdev, u8 pin, u8 *arm, u8 *mode);
+ int mlx5_set_mtppse(struct mlx5_core_dev *mdev, u8 pin, u8 arm, u8 mode);
+ 
++>>>>>>> c835ad64683b (net/mlx5: Implement PCAM, MCAM access register commands)
  void mlx5e_init(void);
  void mlx5e_cleanup(void);
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/port.c b/drivers/net/ethernet/mellanox/mlx5/core/port.c
index 96224f6777b6..df3c9a15311e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/port.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/port.c
@@ -75,6 +75,30 @@ out:
 }
 EXPORT_SYMBOL_GPL(mlx5_core_access_reg);
 
+int mlx5_query_pcam_reg(struct mlx5_core_dev *dev, u32 *pcam, u8 feature_group,
+			u8 access_reg_group)
+{
+	u32 in[MLX5_ST_SZ_DW(pcam_reg)] = {0};
+	int sz = MLX5_ST_SZ_BYTES(pcam_reg);
+
+	MLX5_SET(pcam_reg, in, feature_group, feature_group);
+	MLX5_SET(pcam_reg, in, access_reg_group, access_reg_group);
+
+	return mlx5_core_access_reg(dev, in, sz, pcam, sz, MLX5_REG_PCAM, 0, 0);
+}
+
+int mlx5_query_mcam_reg(struct mlx5_core_dev *dev, u32 *mcam, u8 feature_group,
+			u8 access_reg_group)
+{
+	u32 in[MLX5_ST_SZ_DW(mcam_reg)] = {0};
+	int sz = MLX5_ST_SZ_BYTES(mcam_reg);
+
+	MLX5_SET(mcam_reg, in, feature_group, feature_group);
+	MLX5_SET(mcam_reg, in, access_reg_group, access_reg_group);
+
+	return mlx5_core_access_reg(dev, in, sz, mcam, sz, MLX5_REG_MCAM, 0, 0);
+}
+
 struct mlx5_reg_pcap {
 	u8			rsvd0;
 	u8			port_num;
