net/mlx5: Introduce alloc_encap and dealloc_encap commands

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Introduce alloc_encap and dealloc_encap commands (Don Dutile) [1385330 1417285]
Rebuild_FUZZ: 96.43%
commit-author Ilya Lesokhin <ilyal@mellanox.com>
commit 575ddf5888eaf8f271cb3df7b0806cb2db2c333a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/575ddf58.failed

Implement low-level commands to support vxlan encapsulation.

	Signed-off-by: Ilya Lesokhin <ilyal@mellanox.com>
	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
(cherry picked from commit 575ddf5888eaf8f271cb3df7b0806cb2db2c333a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
#	drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
index 9255fb6f5d9d,7aaefa9aaf1c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
@@@ -353,6 -359,116 +353,120 @@@ int mlx5_cmd_fc_query(struct mlx5_core_
  	stats = MLX5_ADDR_OF(query_flow_counter_out, out, flow_statistics);
  	*packets = MLX5_GET64(traffic_counter, stats, packets);
  	*bytes = MLX5_GET64(traffic_counter, stats, octets);
 +
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ struct mlx5_cmd_fc_bulk {
+ 	u16 id;
+ 	int num;
+ 	int outlen;
+ 	u32 out[0];
+ };
+ 
+ struct mlx5_cmd_fc_bulk *
+ mlx5_cmd_fc_bulk_alloc(struct mlx5_core_dev *dev, u16 id, int num)
+ {
+ 	struct mlx5_cmd_fc_bulk *b;
+ 	int outlen = sizeof(*b) +
+ 		MLX5_ST_SZ_BYTES(query_flow_counter_out) +
+ 		MLX5_ST_SZ_BYTES(traffic_counter) * num;
+ 
+ 	b = kzalloc(outlen, GFP_KERNEL);
+ 	if (!b)
+ 		return NULL;
+ 
+ 	b->id = id;
+ 	b->num = num;
+ 	b->outlen = outlen;
+ 
+ 	return b;
+ }
+ 
+ void mlx5_cmd_fc_bulk_free(struct mlx5_cmd_fc_bulk *b)
+ {
+ 	kfree(b);
+ }
+ 
+ int
+ mlx5_cmd_fc_bulk_query(struct mlx5_core_dev *dev, struct mlx5_cmd_fc_bulk *b)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(query_flow_counter_in)] = {0};
+ 
+ 	MLX5_SET(query_flow_counter_in, in, opcode,
+ 		 MLX5_CMD_OP_QUERY_FLOW_COUNTER);
+ 	MLX5_SET(query_flow_counter_in, in, op_mod, 0);
+ 	MLX5_SET(query_flow_counter_in, in, flow_counter_id, b->id);
+ 	MLX5_SET(query_flow_counter_in, in, num_of_counters, b->num);
+ 	return mlx5_cmd_exec(dev, in, sizeof(in), b->out, b->outlen);
+ }
+ 
+ void mlx5_cmd_fc_bulk_get(struct mlx5_core_dev *dev,
+ 			  struct mlx5_cmd_fc_bulk *b, u16 id,
+ 			  u64 *packets, u64 *bytes)
+ {
+ 	int index = id - b->id;
+ 	void *stats;
+ 
+ 	if (index < 0 || index >= b->num) {
+ 		mlx5_core_warn(dev, "Flow counter id (0x%x) out of range (0x%x..0x%x). Counter ignored.\n",
+ 			       id, b->id, b->id + b->num - 1);
+ 		return;
+ 	}
+ 
+ 	stats = MLX5_ADDR_OF(query_flow_counter_out, b->out,
+ 			     flow_statistics[index]);
+ 	*packets = MLX5_GET64(traffic_counter, stats, packets);
+ 	*bytes = MLX5_GET64(traffic_counter, stats, octets);
+ }
+ 
+ #define MAX_ENCAP_SIZE (128)
+ 
+ int mlx5_cmd_alloc_encap(struct mlx5_core_dev *dev,
+ 			 int header_type,
+ 			 size_t size,
+ 			 void *encap_header,
+ 			 u32 *encap_id)
+ {
+ 	u32 out[MLX5_ST_SZ_DW(alloc_encap_header_out)];
+ 	u32 in[MLX5_ST_SZ_DW(alloc_encap_header_in) +
+ 	      (MAX_ENCAP_SIZE / sizeof(u32))];
+ 	void *encap_header_in = MLX5_ADDR_OF(alloc_encap_header_in, in,
+ 					     encap_header);
+ 	void *header = MLX5_ADDR_OF(encap_header_in, encap_header_in,
+ 				    encap_header);
+ 	int inlen = header - (void *)in  + size;
+ 	int err;
+ 
+ 	if (size > MAX_ENCAP_SIZE)
+ 		return -EINVAL;
+ 
+ 	memset(in, 0, inlen);
+ 	MLX5_SET(alloc_encap_header_in, in, opcode,
+ 		 MLX5_CMD_OP_ALLOC_ENCAP_HEADER);
+ 	MLX5_SET(encap_header_in, encap_header_in, encap_header_size, size);
+ 	MLX5_SET(encap_header_in, encap_header_in, header_type, header_type);
+ 	memcpy(header, encap_header, size);
+ 
+ 	memset(out, 0, sizeof(out));
+ 	err = mlx5_cmd_exec(dev, in, inlen, out, sizeof(out));
+ 
+ 	*encap_id = MLX5_GET(alloc_encap_header_out, out, encap_id);
+ 	return err;
+ }
+ 
+ void mlx5_cmd_dealloc_encap(struct mlx5_core_dev *dev, u32 encap_id)
+ {
+ 	u32 in[MLX5_ST_SZ_DW(dealloc_encap_header_in)];
+ 	u32 out[MLX5_ST_SZ_DW(dealloc_encap_header_out)];
+ 
+ 	memset(in, 0, sizeof(in));
+ 	MLX5_SET(dealloc_encap_header_in, in, opcode,
+ 		 MLX5_CMD_OP_DEALLOC_ENCAP_HEADER);
+ 	MLX5_SET(dealloc_encap_header_in, in, encap_id, encap_id);
+ 
+ 	mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
+ }
++>>>>>>> 575ddf5888ea (net/mlx5: Introduce alloc_encap and dealloc_encap commands)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
index ef9e0168938b,ac52fdfb5096..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
@@@ -74,4 -76,23 +74,26 @@@ int mlx5_cmd_fc_alloc(struct mlx5_core_
  int mlx5_cmd_fc_free(struct mlx5_core_dev *dev, u16 id);
  int mlx5_cmd_fc_query(struct mlx5_core_dev *dev, u16 id,
  		      u64 *packets, u64 *bytes);
++<<<<<<< HEAD
++=======
+ 
+ struct mlx5_cmd_fc_bulk;
+ 
+ struct mlx5_cmd_fc_bulk *
+ mlx5_cmd_fc_bulk_alloc(struct mlx5_core_dev *dev, u16 id, int num);
+ void mlx5_cmd_fc_bulk_free(struct mlx5_cmd_fc_bulk *b);
+ int
+ mlx5_cmd_fc_bulk_query(struct mlx5_core_dev *dev, struct mlx5_cmd_fc_bulk *b);
+ void mlx5_cmd_fc_bulk_get(struct mlx5_core_dev *dev,
+ 			  struct mlx5_cmd_fc_bulk *b, u16 id,
+ 			  u64 *packets, u64 *bytes);
+ 
+ int mlx5_cmd_alloc_encap(struct mlx5_core_dev *dev,
+ 			 int header_type,
+ 			 size_t size,
+ 			 void *encap_header,
+ 			 u32 *encap_id);
+ void mlx5_cmd_dealloc_encap(struct mlx5_core_dev *dev, u32 encap_id);
+ 
++>>>>>>> 575ddf5888ea (net/mlx5: Introduce alloc_encap and dealloc_encap commands)
  #endif
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
index 131d0987d49f..2ad78b194a3a 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
@@ -316,6 +316,7 @@ static int mlx5_internal_err_ret_value(struct mlx5_core_dev *dev, u16 op,
 	case MLX5_CMD_OP_MODIFY_FLOW_TABLE:
 	case MLX5_CMD_OP_SET_FLOW_TABLE_ENTRY:
 	case MLX5_CMD_OP_SET_FLOW_TABLE_ROOT:
+	case MLX5_CMD_OP_DEALLOC_ENCAP_HEADER:
 		return MLX5_CMD_STAT_OK;
 
 	case MLX5_CMD_OP_QUERY_HCA_CAP:
@@ -417,6 +418,7 @@ static int mlx5_internal_err_ret_value(struct mlx5_core_dev *dev, u16 op,
 	case MLX5_CMD_OP_QUERY_FLOW_TABLE_ENTRY:
 	case MLX5_CMD_OP_ALLOC_FLOW_COUNTER:
 	case MLX5_CMD_OP_QUERY_FLOW_COUNTER:
+	case MLX5_CMD_OP_ALLOC_ENCAP_HEADER:
 		*status = MLX5_DRIVER_STATUS_ABORTED;
 		*synd = MLX5_DRIVER_SYND;
 		return -EIO;
@@ -565,6 +567,8 @@ const char *mlx5_command_str(int command)
 	MLX5_COMMAND_STR_CASE(DEALLOC_FLOW_COUNTER);
 	MLX5_COMMAND_STR_CASE(QUERY_FLOW_COUNTER);
 	MLX5_COMMAND_STR_CASE(MODIFY_FLOW_TABLE);
+	MLX5_COMMAND_STR_CASE(ALLOC_ENCAP_HEADER);
+	MLX5_COMMAND_STR_CASE(DEALLOC_ENCAP_HEADER);
 	default: return "unknown command opcode";
 	}
 }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
