net/mlx4_en: Fixes for DCBX

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx4_en: Fixes for DCBX (Don Dutile) [1385329 1417284]
Rebuild_FUZZ: 92.00%
commit-author Tariq Toukan <tariqt@mellanox.com>
commit 564ed9b187082da79726a2f25bb88a58ebeec7e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/564ed9b1.failed

This patch adds a capability check before enabling DCBX.
In addition, it re-organizes the relevant data structures,
and fixes a typo in a define.

Fixes: af7d51852631 ("net/mlx4_en: Add DCB PFC support through CEE netlink commands")
	Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 564ed9b187082da79726a2f25bb88a58ebeec7e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
#	drivers/net/ethernet/mellanox/mlx4/en_netdev.c
#	drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
#	drivers/net/ethernet/mellanox/mlx4/port.c
diff --cc drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
index 9aacffd7b7f8,b04760a5034b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
@@@ -80,6 -85,199 +80,202 @@@ struct mlx4_congestion_control_mb_prio_
  	__be32 reserved3[4];
  };
  
++<<<<<<< HEAD
++=======
+ static u8 mlx4_en_dcbnl_getcap(struct net_device *dev, int capid, u8 *cap)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 
+ 	switch (capid) {
+ 	case DCB_CAP_ATTR_PFC:
+ 		*cap = true;
+ 		break;
+ 	case DCB_CAP_ATTR_DCBX:
+ 		*cap = priv->dcbx_cap;
+ 		break;
+ 	case DCB_CAP_ATTR_PFC_TCS:
+ 		*cap = 1 <<  mlx4_max_tc(priv->mdev->dev);
+ 		break;
+ 	default:
+ 		*cap = false;
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u8 mlx4_en_dcbnl_getpfcstate(struct net_device *netdev)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 
+ 	return priv->cee_config.pfc_state;
+ }
+ 
+ static void mlx4_en_dcbnl_setpfcstate(struct net_device *netdev, u8 state)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 
+ 	priv->cee_config.pfc_state = state;
+ }
+ 
+ static void mlx4_en_dcbnl_get_pfc_cfg(struct net_device *netdev, int priority,
+ 				      u8 *setting)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 
+ 	*setting = priv->cee_config.dcb_pfc[priority];
+ }
+ 
+ static void mlx4_en_dcbnl_set_pfc_cfg(struct net_device *netdev, int priority,
+ 				      u8 setting)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 
+ 	priv->cee_config.dcb_pfc[priority] = setting;
+ 	priv->cee_config.pfc_state = true;
+ }
+ 
+ static int mlx4_en_dcbnl_getnumtcs(struct net_device *netdev, int tcid, u8 *num)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 
+ 	if (!(priv->flags & MLX4_EN_FLAG_DCB_ENABLED))
+ 		return -EINVAL;
+ 
+ 	if (tcid == DCB_NUMTCS_ATTR_PFC)
+ 		*num = mlx4_max_tc(priv->mdev->dev);
+ 	else
+ 		*num = 0;
+ 
+ 	return 0;
+ }
+ 
+ static u8 mlx4_en_dcbnl_set_all(struct net_device *netdev)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 	struct mlx4_en_dev *mdev = priv->mdev;
+ 
+ 	if (!(priv->dcbx_cap & DCB_CAP_DCBX_VER_CEE))
+ 		return 1;
+ 
+ 	if (priv->cee_config.pfc_state) {
+ 		int tc;
+ 
+ 		priv->prof->rx_pause = 0;
+ 		priv->prof->tx_pause = 0;
+ 		for (tc = 0; tc < CEE_DCBX_MAX_PRIO; tc++) {
+ 			u8 tc_mask = 1 << tc;
+ 
+ 			switch (priv->cee_config.dcb_pfc[tc]) {
+ 			case pfc_disabled:
+ 				priv->prof->tx_ppp &= ~tc_mask;
+ 				priv->prof->rx_ppp &= ~tc_mask;
+ 				break;
+ 			case pfc_enabled_full:
+ 				priv->prof->tx_ppp |= tc_mask;
+ 				priv->prof->rx_ppp |= tc_mask;
+ 				break;
+ 			case pfc_enabled_tx:
+ 				priv->prof->tx_ppp |= tc_mask;
+ 				priv->prof->rx_ppp &= ~tc_mask;
+ 				break;
+ 			case pfc_enabled_rx:
+ 				priv->prof->tx_ppp &= ~tc_mask;
+ 				priv->prof->rx_ppp |= tc_mask;
+ 				break;
+ 			default:
+ 				break;
+ 			}
+ 		}
+ 		en_dbg(DRV, priv, "Set pfc on\n");
+ 	} else {
+ 		priv->prof->rx_pause = 1;
+ 		priv->prof->tx_pause = 1;
+ 		en_dbg(DRV, priv, "Set pfc off\n");
+ 	}
+ 
+ 	if (mlx4_SET_PORT_general(mdev->dev, priv->port,
+ 				  priv->rx_skb_size + ETH_FCS_LEN,
+ 				  priv->prof->tx_pause,
+ 				  priv->prof->tx_ppp,
+ 				  priv->prof->rx_pause,
+ 				  priv->prof->rx_ppp)) {
+ 		en_err(priv, "Failed setting pause params\n");
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u8 mlx4_en_dcbnl_get_state(struct net_device *dev)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 
+ 	if (priv->flags & MLX4_EN_FLAG_DCB_ENABLED)
+ 		return MLX4_CEE_STATE_UP;
+ 
+ 	return MLX4_CEE_STATE_DOWN;
+ }
+ 
+ static u8 mlx4_en_dcbnl_set_state(struct net_device *dev, u8 state)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 	int num_tcs = 0;
+ 
+ 	if (!(priv->dcbx_cap & DCB_CAP_DCBX_VER_CEE))
+ 		return 1;
+ 
+ 	if (!!(state) == !!(priv->flags & MLX4_EN_FLAG_DCB_ENABLED))
+ 		return 0;
+ 
+ 	if (state) {
+ 		priv->flags |= MLX4_EN_FLAG_DCB_ENABLED;
+ 		num_tcs = IEEE_8021QAZ_MAX_TCS;
+ 	} else {
+ 		priv->flags &= ~MLX4_EN_FLAG_DCB_ENABLED;
+ 	}
+ 
+ 	if (mlx4_en_setup_tc(dev, num_tcs))
+ 		return 1;
+ 
+ 	return 0;
+ }
+ 
+ /* On success returns a non-zero 802.1p user priority bitmap
+  * otherwise returns 0 as the invalid user priority bitmap to
+  * indicate an error.
+  */
+ static int mlx4_en_dcbnl_getapp(struct net_device *netdev, u8 idtype, u16 id)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 	struct dcb_app app = {
+ 				.selector = idtype,
+ 				.protocol = id,
+ 			     };
+ 	if (!(priv->dcbx_cap & DCB_CAP_DCBX_VER_CEE))
+ 		return 0;
+ 
+ 	return dcb_getapp(netdev, &app);
+ }
+ 
+ static int mlx4_en_dcbnl_setapp(struct net_device *netdev, u8 idtype,
+ 				u16 id, u8 up)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 	struct dcb_app app;
+ 
+ 	if (!(priv->dcbx_cap & DCB_CAP_DCBX_VER_CEE))
+ 		return -EINVAL;
+ 
+ 	memset(&app, 0, sizeof(struct dcb_app));
+ 	app.selector = idtype;
+ 	app.protocol = id;
+ 	app.priority = up;
+ 
+ 	return dcb_setapp(netdev, &app);
+ }
+ 
++>>>>>>> 564ed9b18708 (net/mlx4_en: Fixes for DCBX)
  static int mlx4_en_dcbnl_ieee_getets(struct net_device *dev,
  				   struct ieee_ets *ets)
  {
@@@ -237,18 -434,51 +433,60 @@@ static int mlx4_en_dcbnl_ieee_setpfc(st
  
  static u8 mlx4_en_dcbnl_getdcbx(struct net_device *dev)
  {
++<<<<<<< HEAD
 +	return DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_IEEE;
++=======
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 
+ 	return priv->dcbx_cap;
++>>>>>>> 564ed9b18708 (net/mlx4_en: Fixes for DCBX)
  }
  
  static u8 mlx4_en_dcbnl_setdcbx(struct net_device *dev, u8 mode)
  {
++<<<<<<< HEAD
++=======
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 	struct ieee_ets ets = {0};
+ 	struct ieee_pfc pfc = {0};
+ 
+ 	if (mode == priv->dcbx_cap)
+ 		return 0;
+ 
++>>>>>>> 564ed9b18708 (net/mlx4_en: Fixes for DCBX)
  	if ((mode & DCB_CAP_DCBX_LLD_MANAGED) ||
 -	    ((mode & DCB_CAP_DCBX_VER_IEEE) &&
 -	     (mode & DCB_CAP_DCBX_VER_CEE)) ||
 +	    (mode & DCB_CAP_DCBX_VER_CEE) ||
 +	    !(mode & DCB_CAP_DCBX_VER_IEEE) ||
  	    !(mode & DCB_CAP_DCBX_HOST))
++<<<<<<< HEAD
 +		return 1;
++=======
+ 		goto err;
+ 
+ 	priv->dcbx_cap = mode;
+ 
+ 	ets.ets_cap = IEEE_8021QAZ_MAX_TCS;
+ 	pfc.pfc_cap = IEEE_8021QAZ_MAX_TCS;
+ 
+ 	if (mode & DCB_CAP_DCBX_VER_IEEE) {
+ 		if (mlx4_en_dcbnl_ieee_setets(dev, &ets))
+ 			goto err;
+ 		if (mlx4_en_dcbnl_ieee_setpfc(dev, &pfc))
+ 			goto err;
+ 	} else if (mode & DCB_CAP_DCBX_VER_CEE) {
+ 		if (mlx4_en_dcbnl_set_all(dev))
+ 			goto err;
+ 	} else {
+ 		if (mlx4_en_dcbnl_ieee_setets(dev, &ets))
+ 			goto err;
+ 		if (mlx4_en_dcbnl_ieee_setpfc(dev, &pfc))
+ 			goto err;
+ 		if (mlx4_en_setup_tc(dev, 0))
+ 			goto err;
+ 	}
++>>>>>>> 564ed9b18708 (net/mlx4_en: Fixes for DCBX)
  
  	return 0;
 -err:
 -	return 1;
  }
  
  #define MLX4_RATELIMIT_UNITS_IN_KB 100000 /* rate-limit HW unit in Kbps */
diff --cc drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 5e3b15bcd2e7,fedb829276f4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@@ -67,6 -68,18 +67,21 @@@ int mlx4_en_setup_tc(struct net_device 
  		offset += priv->num_tx_rings_p_up;
  	}
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_MLX4_EN_DCB
+ 	if (!mlx4_is_slave(priv->mdev->dev)) {
+ 		if (up) {
+ 			if (priv->dcbx_cap)
+ 				priv->flags |= MLX4_EN_FLAG_DCB_ENABLED;
+ 		} else {
+ 			priv->flags &= ~MLX4_EN_FLAG_DCB_ENABLED;
+ 			priv->cee_config.pfc_state = false;
+ 		}
+ 	}
+ #endif /* CONFIG_MLX4_EN_DCB */
+ 
++>>>>>>> 564ed9b18708 (net/mlx4_en: Fixes for DCBX)
  	return 0;
  }
  
@@@ -2977,9 -3115,16 +2992,20 @@@ int mlx4_en_init_netdev(struct mlx4_en_
  	priv->msg_enable = MLX4_EN_MSG_LEVEL;
  #ifdef CONFIG_MLX4_EN_DCB
  	if (!mlx4_is_slave(priv->mdev->dev)) {
++<<<<<<< HEAD
++=======
+ 		priv->dcbx_cap = DCB_CAP_DCBX_VER_CEE | DCB_CAP_DCBX_HOST |
+ 			DCB_CAP_DCBX_VER_IEEE;
+ 		priv->flags |= MLX4_EN_DCB_ENABLED;
+ 		priv->cee_config.pfc_state = false;
+ 
+ 		for (i = 0; i < MLX4_EN_NUM_UP; i++)
+ 			priv->cee_config.dcb_pfc[i] = pfc_disabled;
+ 
++>>>>>>> 564ed9b18708 (net/mlx4_en: Fixes for DCBX)
  		if (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_ETS_CFG) {
  			dev->dcbnl_ops = &mlx4_en_dcbnl_ops;
 +			dev->dcbnl_ops_ext = &mlx4_en_dcbnl_ops_ext;
  		} else {
  			en_info(priv, "enabling only PFC DCB ops\n");
  			dev->dcbnl_ops = &mlx4_en_dcbnl_pfc_ops;
diff --cc drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index 54b1e1a61da0,9099dbd04951..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@@ -458,6 -475,17 +458,20 @@@ struct mlx4_en_frag_info 
  
  #define MLX4_EN_TC_ETS 7
  
++<<<<<<< HEAD
++=======
+ enum dcb_pfc_type {
+ 	pfc_disabled = 0,
+ 	pfc_enabled_full,
+ 	pfc_enabled_tx,
+ 	pfc_enabled_rx
+ };
+ 
+ struct mlx4_en_cee_config {
+ 	bool	pfc_state;
+ 	enum	dcb_pfc_type dcb_pfc[MLX4_EN_NUM_UP];
+ };
++>>>>>>> 564ed9b18708 (net/mlx4_en: Fixes for DCBX)
  #endif
  
  struct ethtool_flow_id {
@@@ -583,6 -613,9 +597,11 @@@ struct mlx4_en_priv 
  	struct ieee_ets ets;
  	u16 maxrate[IEEE_8021QAZ_MAX_TCS];
  	enum dcbnl_cndd_states cndd_state[IEEE_8021QAZ_MAX_TCS];
++<<<<<<< HEAD
++=======
+ 	struct mlx4_en_cee_config cee_config;
+ 	u8 dcbx_cap;
++>>>>>>> 564ed9b18708 (net/mlx4_en: Fixes for DCBX)
  #endif
  #ifdef CONFIG_RFS_ACCEL
  	spinlock_t filters_lock;
diff --cc drivers/net/ethernet/mellanox/mlx4/port.c
index 087b23b320cb,c5b2064297a1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/port.c
+++ b/drivers/net/ethernet/mellanox/mlx4/port.c
@@@ -52,6 -52,7 +52,10 @@@
  
  #define MLX4_FLAG_V_IGNORE_FCS_MASK		0x2
  #define MLX4_IGNORE_FCS_MASK			0x1
++<<<<<<< HEAD
++=======
+ #define MLX4_TC_MAX_NUMBER			8
++>>>>>>> 564ed9b18708 (net/mlx4_en: Fixes for DCBX)
  
  void mlx4_init_mac_table(struct mlx4_dev *dev, struct mlx4_mac_table *table)
  {
@@@ -2015,3 -2016,14 +2019,17 @@@ out
  	return ret;
  }
  EXPORT_SYMBOL(mlx4_get_module_info);
++<<<<<<< HEAD
++=======
+ 
+ int mlx4_max_tc(struct mlx4_dev *dev)
+ {
+ 	u8 num_tc = dev->caps.max_tc_eth;
+ 
+ 	if (!num_tc)
+ 		num_tc = MLX4_TC_MAX_NUMBER;
+ 
+ 	return num_tc;
+ }
+ EXPORT_SYMBOL(mlx4_max_tc);
++>>>>>>> 564ed9b18708 (net/mlx4_en: Fixes for DCBX)
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_netdev.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx4/port.c
