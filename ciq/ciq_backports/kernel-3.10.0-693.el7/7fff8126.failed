drm/i915/gen9+: Enable hotplug detection early

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [drm] i915/gen9+: Enable hotplug detection early (Rob Clark) [1422186]
Rebuild_FUZZ: 95.45%
commit-author Imre Deak <imre.deak@intel.com>
commit 7fff8126d9cc902b2636d05d5d34894a75174993
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7fff8126.failed

For LSPCON resume time initialization we need to sample the
corresponding pin's HPD level, but this is only available when HPD
detection is enabled. Currently we enable detection only when enabling
HPD interrupts which is too late, so bring the enabling of detection
earlier.

This is needed by the next patch.

	Cc: Shashank Sharma <shashank.sharma@intel.com>
	Cc: Jani Nikula <jani.nikula@linux.intel.com>
	Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: <stable@vger.kernel.org> # v4.9+
	Signed-off-by: Imre Deak <imre.deak@intel.com>
	Reviewed-by: Shashank Sharma <shashank.sharma@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1485509961-9010-2-git-send-email-imre.deak@intel.com
(cherry picked from commit 7fff8126d9cc902b2636d05d5d34894a75174993)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_irq.c
diff --cc drivers/gpu/drm/i915/i915_irq.c
index 14622610756d,8b868405e99b..000000000000
--- a/drivers/gpu/drm/i915/i915_irq.c
+++ b/drivers/gpu/drm/i915/i915_irq.c
@@@ -3437,15 -3129,9 +3437,15 @@@ static void ibx_hpd_irq_setup(struct dr
  	I915_WRITE(PCH_PORT_HOTPLUG, hotplug);
  }
  
++<<<<<<< HEAD
 +static void spt_hpd_irq_setup(struct drm_device *dev)
 +{
 +	struct drm_i915_private *dev_priv = dev->dev_private;
 +	u32 hotplug_irqs, hotplug, enabled_irqs;
- 
- 	hotplug_irqs = SDE_HOTPLUG_MASK_SPT;
- 	enabled_irqs = intel_hpd_enabled_irqs(dev, hpd_spt);
- 
- 	ibx_display_interrupt_update(dev_priv, hotplug_irqs, enabled_irqs);
++=======
+ static void spt_hpd_detection_setup(struct drm_i915_private *dev_priv)
+ {
+ 	u32 hotplug;
  
  	/* Enable digital hotplug on the PCH */
  	hotplug = I915_READ(PCH_PORT_HOTPLUG);
@@@ -3458,19 -3146,30 +3460,32 @@@
  	I915_WRITE(PCH_PORT_HOTPLUG2, hotplug);
  }
  
+ static void spt_hpd_irq_setup(struct drm_i915_private *dev_priv)
+ {
+ 	u32 hotplug_irqs, enabled_irqs;
++>>>>>>> 7fff8126d9cc (drm/i915/gen9+: Enable hotplug detection early)
+ 
+ 	hotplug_irqs = SDE_HOTPLUG_MASK_SPT;
 -	enabled_irqs = intel_hpd_enabled_irqs(dev_priv, hpd_spt);
++	enabled_irqs = intel_hpd_enabled_irqs(dev, hpd_spt);
+ 
+ 	ibx_display_interrupt_update(dev_priv, hotplug_irqs, enabled_irqs);
+ 
+ 	spt_hpd_detection_setup(dev_priv);
+ }
+ 
 -static void ilk_hpd_irq_setup(struct drm_i915_private *dev_priv)
 +static void ilk_hpd_irq_setup(struct drm_device *dev)
  {
 +	struct drm_i915_private *dev_priv = dev->dev_private;
  	u32 hotplug_irqs, hotplug, enabled_irqs;
  
 -	if (INTEL_GEN(dev_priv) >= 8) {
 +	if (INTEL_INFO(dev)->gen >= 8) {
  		hotplug_irqs = GEN8_PORT_DP_A_HOTPLUG;
 -		enabled_irqs = intel_hpd_enabled_irqs(dev_priv, hpd_bdw);
 +		enabled_irqs = intel_hpd_enabled_irqs(dev, hpd_bdw);
  
  		bdw_update_port_irq(dev_priv, hotplug_irqs, enabled_irqs);
 -	} else if (INTEL_GEN(dev_priv) >= 7) {
 +	} else if (INTEL_INFO(dev)->gen >= 7) {
  		hotplug_irqs = DE_DP_A_HOTPLUG_IVB;
 -		enabled_irqs = intel_hpd_enabled_irqs(dev_priv, hpd_ivb);
 +		enabled_irqs = intel_hpd_enabled_irqs(dev, hpd_ivb);
  
  		ilk_update_display_irq(dev_priv, hotplug_irqs, enabled_irqs);
  	} else {
@@@ -3490,34 -3189,66 +3505,82 @@@
  	hotplug |= DIGITAL_PORTA_HOTPLUG_ENABLE | DIGITAL_PORTA_PULSE_DURATION_2ms;
  	I915_WRITE(DIGITAL_PORT_HOTPLUG_CNTRL, hotplug);
  
 -	ibx_hpd_irq_setup(dev_priv);
 +	ibx_hpd_irq_setup(dev);
  }
  
++<<<<<<< HEAD
 +static void bxt_hpd_irq_setup(struct drm_device *dev)
 +{
 +	struct drm_i915_private *dev_priv = dev->dev_private;
 +	u32 hotplug_irqs, hotplug, enabled_irqs;
 +
 +	enabled_irqs = intel_hpd_enabled_irqs(dev, hpd_bxt);
 +	hotplug_irqs = BXT_DE_PORT_HOTPLUG_MASK;
 +
 +	bdw_update_port_irq(dev_priv, hotplug_irqs, enabled_irqs);
 +
 +	hotplug = I915_READ(PCH_PORT_HOTPLUG);
 +	hotplug |= PORTC_HOTPLUG_ENABLE | PORTB_HOTPLUG_ENABLE |
 +		PORTA_HOTPLUG_ENABLE;
++=======
+ static void __bxt_hpd_detection_setup(struct drm_i915_private *dev_priv,
+ 				      u32 enabled_irqs)
+ {
+ 	u32 hotplug;
+ 
+ 	hotplug = I915_READ(PCH_PORT_HOTPLUG);
+ 	hotplug |= PORTA_HOTPLUG_ENABLE |
+ 		   PORTB_HOTPLUG_ENABLE |
+ 		   PORTC_HOTPLUG_ENABLE;
+ 
+ 	DRM_DEBUG_KMS("Invert bit setting: hp_ctl:%x hp_port:%x\n",
+ 		      hotplug, enabled_irqs);
+ 	hotplug &= ~BXT_DDI_HPD_INVERT_MASK;
+ 
+ 	/*
+ 	 * For BXT invert bit has to be set based on AOB design
+ 	 * for HPD detection logic, update it based on VBT fields.
+ 	 */
+ 	if ((enabled_irqs & BXT_DE_PORT_HP_DDIA) &&
+ 	    intel_bios_is_port_hpd_inverted(dev_priv, PORT_A))
+ 		hotplug |= BXT_DDIA_HPD_INVERT;
+ 	if ((enabled_irqs & BXT_DE_PORT_HP_DDIB) &&
+ 	    intel_bios_is_port_hpd_inverted(dev_priv, PORT_B))
+ 		hotplug |= BXT_DDIB_HPD_INVERT;
+ 	if ((enabled_irqs & BXT_DE_PORT_HP_DDIC) &&
+ 	    intel_bios_is_port_hpd_inverted(dev_priv, PORT_C))
+ 		hotplug |= BXT_DDIC_HPD_INVERT;
+ 
++>>>>>>> 7fff8126d9cc (drm/i915/gen9+: Enable hotplug detection early)
  	I915_WRITE(PCH_PORT_HOTPLUG, hotplug);
  }
  
+ static void bxt_hpd_detection_setup(struct drm_i915_private *dev_priv)
+ {
+ 	__bxt_hpd_detection_setup(dev_priv, BXT_DE_PORT_HOTPLUG_MASK);
+ }
+ 
+ static void bxt_hpd_irq_setup(struct drm_i915_private *dev_priv)
+ {
+ 	u32 hotplug_irqs, enabled_irqs;
+ 
+ 	enabled_irqs = intel_hpd_enabled_irqs(dev_priv, hpd_bxt);
+ 	hotplug_irqs = BXT_DE_PORT_HOTPLUG_MASK;
+ 
+ 	bdw_update_port_irq(dev_priv, hotplug_irqs, enabled_irqs);
+ 
+ 	__bxt_hpd_detection_setup(dev_priv, enabled_irqs);
+ }
+ 
  static void ibx_irq_postinstall(struct drm_device *dev)
  {
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 +	struct drm_i915_private *dev_priv = dev->dev_private;
  	u32 mask;
  
 -	if (HAS_PCH_NOP(dev_priv))
 +	if (HAS_PCH_NOP(dev))
  		return;
  
 -	if (HAS_PCH_IBX(dev_priv))
 +	if (HAS_PCH_IBX(dev))
  		mask = SDE_GMBUS | SDE_AUX_MASK | SDE_POISON;
  	else
  		mask = SDE_GMBUS_CPT | SDE_AUX_MASK_CPT;
@@@ -3817,6 -3471,10 +3886,13 @@@ static void gen8_de_irq_postinstall(str
  					  de_pipe_enables);
  
  	GEN5_IRQ_INIT(GEN8_DE_PORT_, ~de_port_masked, de_port_enables);
++<<<<<<< HEAD
++=======
+ 	GEN5_IRQ_INIT(GEN8_DE_MISC_, ~de_misc_masked, de_misc_masked);
+ 
+ 	if (IS_GEN9_LP(dev_priv))
+ 		bxt_hpd_detection_setup(dev_priv);
++>>>>>>> 7fff8126d9cc (drm/i915/gen9+: Enable hotplug detection early)
  }
  
  static int gen8_irq_postinstall(struct drm_device *dev)
* Unmerged path drivers/gpu/drm/i915/i915_irq.c
