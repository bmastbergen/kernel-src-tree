xfs: fix eofblocks race with file extending async dio writes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Brian Foster <bfoster@redhat.com>
commit e4229d6b0bc9280f29624faf170cf76a9f1ca60e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e4229d6b.failed

It's possible for post-eof blocks to end up being used for direct I/O
writes. dio write performs an upfront unwritten extent allocation, sends
the dio and then updates the inode size (if necessary) on write
completion. If a file release occurs while a file extending dio write is
in flight, it is possible to mistake the post-eof blocks for speculative
preallocation and incorrectly truncate them from the inode. This means
that the resulting dio write completion can discover a hole and allocate
new blocks rather than perform unwritten extent conversion.

This requires a strange mix of I/O and is thus not likely to reproduce
in real world workloads. It is intermittently reproduced by generic/299.
The error manifests as an assert failure due to transaction overrun
because the aforementioned write completion transaction has only
reserved enough blocks for btree operations:

  XFS: Assertion failed: tp->t_blk_res_used <= tp->t_blk_res, \
   file: fs/xfs//xfs_trans.c, line: 309

The root cause is that xfs_free_eofblocks() uses i_size to truncate
post-eof blocks from the inode, but async, file extending direct writes
do not update i_size until write completion, long after inode locks are
dropped. Therefore, xfs_free_eofblocks() effectively truncates the inode
to the incorrect size.

Update xfs_free_eofblocks() to serialize against dio similar to how
extending writes are serialized against i_size updates before post-eof
block zeroing. Specifically, wait on dio while under the iolock. This
ensures that dio write completions have updated i_size before post-eof
blocks are processed.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit e4229d6b0bc9280f29624faf170cf76a9f1ca60e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/xfs_bmap_util.c
index 935fc7ad67c0,eb890ed1ed5c..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -895,26 -959,13 +895,34 @@@ xfs_free_eofblocks
  		if (error)
  			return error;
  
++<<<<<<< HEAD
 +		/*
 +		 * There are blocks after the end of file.
 +		 * Free them up now by truncating the file to
 +		 * its current size.
 +		 */
 +		tp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);
 +
 +		if (need_iolock) {
 +			if (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {
 +				xfs_trans_cancel(tp);
 +				return -EAGAIN;
 +			}
 +		}
 +
 +		error = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);
++=======
+ 		/* wait on dio to ensure i_size has settled */
+ 		inode_dio_wait(VFS_I(ip));
+ 
+ 		error = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0,
+ 				&tp);
++>>>>>>> e4229d6b0bc9 (xfs: fix eofblocks race with file extending async dio writes)
  		if (error) {
  			ASSERT(XFS_FORCED_SHUTDOWN(mp));
 +			xfs_trans_cancel(tp);
 +			if (need_iolock)
 +				xfs_iunlock(ip, XFS_IOLOCK_EXCL);
  			return error;
  		}
  
* Unmerged path fs/xfs/xfs_bmap_util.c
