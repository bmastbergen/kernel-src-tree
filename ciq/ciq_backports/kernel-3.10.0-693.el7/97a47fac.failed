net: rtnetlink: add linkxstats callbacks and attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] rtnetlink: add linkxstats callbacks and attribute (Ivan Vecera) [1352289]
Rebuild_FUZZ: 95.15%
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit 97a47facf3468fb6ebd697324fc2a7245755c417
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/97a47fac.failed

Add callbacks to calculate the size and fill link extended statistics
which can be split into multiple messages and are dumped via the new
rtnl stats API (RTM_GETSTATS) with the IFLA_STATS_LINK_XSTATS attribute.
Also add that attribute to the idx mask check since it is expected to
be able to save state and resume dumping (e.g. future bridge per-vlan
stats will be dumped via this attribute and callbacks).
Each link type should nest its private attributes under the per-link type
attribute. This allows to have any number of separated private attributes
and to avoid one call to get the dev link type.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 97a47facf3468fb6ebd697324fc2a7245755c417)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/rtnetlink.h
#	include/uapi/linux/if_link.h
#	net/core/rtnetlink.c
diff --cc include/net/rtnetlink.h
index 7ab6d3e8deb8,006a7b81d758..000000000000
--- a/include/net/rtnetlink.h
+++ b/include/net/rtnetlink.h
@@@ -82,34 -84,24 +85,43 @@@ struct rtnl_link_ops 
  	unsigned int		(*get_num_tx_queues)(void);
  	unsigned int		(*get_num_rx_queues)(void);
  
 -	int			slave_maxtype;
 -	const struct nla_policy	*slave_policy;
 -	int			(*slave_validate)(struct nlattr *tb[],
 -						  struct nlattr *data[]);
 -	int			(*slave_changelink)(struct net_device *dev,
 +	/* RHEL SPECIFIC
 +	 *
 +	 * The following padding has been inserted before ABI freeze to
 +	 * allow extending the structure while preserve ABI. Feel free
 +	 * to replace reserved slots with required structure field
 +	 * additions of your backport.
 +	 */
 +	RH_KABI_USE_P(1, struct net	*(*get_link_net)(const struct net_device *dev))
 +	RH_KABI_USE_P(2, int	slave_maxtype)
 +	RH_KABI_USE_P(3, const struct nla_policy *slave_policy)
 +	RH_KABI_USE_P(4, int	(*slave_validate)(struct nlattr *tb[], struct nlattr *data[]))
 +	RH_KABI_USE_P(5, int	(*slave_changelink)(struct net_device *dev,
  						    struct net_device *slave_dev,
 -						    struct nlattr *tb[],
 -						    struct nlattr *data[]);
 -	size_t			(*get_slave_size)(const struct net_device *dev,
 -						  const struct net_device *slave_dev);
 -	int			(*fill_slave_info)(struct sk_buff *skb,
 +						    struct nlattr *tb[], struct nlattr *data[]))
 +	RH_KABI_USE_P(6, size_t	(*get_slave_size)(const struct net_device *dev,
 +						  const struct net_device *slave_dev))
 +	RH_KABI_USE_P(7, int	(*fill_slave_info)(struct sk_buff *skb,
  						   const struct net_device *dev,
++<<<<<<< HEAD
 +						   const struct net_device *slave_dev))
 +	RH_KABI_RESERVE_P(8)
 +	RH_KABI_RESERVE_P(9)
 +	RH_KABI_RESERVE_P(10)
 +	RH_KABI_RESERVE_P(11)
 +	RH_KABI_RESERVE_P(12)
 +	RH_KABI_RESERVE_P(13)
 +	RH_KABI_RESERVE_P(14)
 +	RH_KABI_RESERVE_P(15)
 +	RH_KABI_RESERVE_P(16)
++=======
+ 						   const struct net_device *slave_dev);
+ 	struct net		*(*get_link_net)(const struct net_device *dev);
+ 	size_t			(*get_linkxstats_size)(const struct net_device *dev);
+ 	int			(*fill_linkxstats)(struct sk_buff *skb,
+ 						   const struct net_device *dev,
+ 						   int *prividx);
++>>>>>>> 97a47facf346 (net: rtnetlink: add linkxstats callbacks and attribute)
  };
  
  int __rtnl_link_register(struct rtnl_link_ops *ops);
diff --cc include/uapi/linux/if_link.h
index 1b43f8aab560,2bfdb9c58342..000000000000
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@@ -665,4 -778,55 +665,58 @@@ enum 
  
  #define IFLA_IPOIB_MAX (__IFLA_IPOIB_MAX - 1)
  
++<<<<<<< HEAD
++=======
+ 
+ /* HSR section */
+ 
+ enum {
+ 	IFLA_HSR_UNSPEC,
+ 	IFLA_HSR_SLAVE1,
+ 	IFLA_HSR_SLAVE2,
+ 	IFLA_HSR_MULTICAST_SPEC,	/* Last byte of supervision addr */
+ 	IFLA_HSR_SUPERVISION_ADDR,	/* Supervision frame multicast addr */
+ 	IFLA_HSR_SEQ_NR,
+ 	IFLA_HSR_VERSION,		/* HSR version */
+ 	__IFLA_HSR_MAX,
+ };
+ 
+ #define IFLA_HSR_MAX (__IFLA_HSR_MAX - 1)
+ 
+ /* STATS section */
+ 
+ struct if_stats_msg {
+ 	__u8  family;
+ 	__u8  pad1;
+ 	__u16 pad2;
+ 	__u32 ifindex;
+ 	__u32 filter_mask;
+ };
+ 
+ /* A stats attribute can be netdev specific or a global stat.
+  * For netdev stats, lets use the prefix IFLA_STATS_LINK_*
+  */
+ enum {
+ 	IFLA_STATS_UNSPEC, /* also used as 64bit pad attribute */
+ 	IFLA_STATS_LINK_64,
+ 	IFLA_STATS_LINK_XSTATS,
+ 	__IFLA_STATS_MAX,
+ };
+ 
+ #define IFLA_STATS_MAX (__IFLA_STATS_MAX - 1)
+ 
+ #define IFLA_STATS_FILTER_BIT(ATTR)	(1 << (ATTR - 1))
+ 
+ /* These are embedded into IFLA_STATS_LINK_XSTATS:
+  * [IFLA_STATS_LINK_XSTATS]
+  * -> [LINK_XSTATS_TYPE_xxx]
+  *    -> [rtnl link type specific attributes]
+  */
+ enum {
+ 	LINK_XSTATS_TYPE_UNSPEC,
+ 	__LINK_XSTATS_TYPE_MAX
+ };
+ #define LINK_XSTATS_TYPE_MAX (__LINK_XSTATS_TYPE_MAX - 1)
+ 
++>>>>>>> 97a47facf346 (net: rtnetlink: add linkxstats callbacks and attribute)
  #endif /* _UAPI_LINUX_IF_LINK_H */
diff --cc net/core/rtnetlink.c
index 8209decfe5a9,d471f097c739..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -3213,6 -3444,202 +3213,205 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static bool stats_attr_valid(unsigned int mask, int attrid, int idxattr)
+ {
+ 	return (mask & IFLA_STATS_FILTER_BIT(attrid)) &&
+ 	       (!idxattr || idxattr == attrid);
+ }
+ 
+ static int rtnl_fill_statsinfo(struct sk_buff *skb, struct net_device *dev,
+ 			       int type, u32 pid, u32 seq, u32 change,
+ 			       unsigned int flags, unsigned int filter_mask,
+ 			       int *idxattr, int *prividx)
+ {
+ 	struct if_stats_msg *ifsm;
+ 	struct nlmsghdr *nlh;
+ 	struct nlattr *attr;
+ 	int s_prividx = *prividx;
+ 
+ 	ASSERT_RTNL();
+ 
+ 	nlh = nlmsg_put(skb, pid, seq, type, sizeof(*ifsm), flags);
+ 	if (!nlh)
+ 		return -EMSGSIZE;
+ 
+ 	ifsm = nlmsg_data(nlh);
+ 	ifsm->ifindex = dev->ifindex;
+ 	ifsm->filter_mask = filter_mask;
+ 
+ 	if (stats_attr_valid(filter_mask, IFLA_STATS_LINK_64, *idxattr)) {
+ 		struct rtnl_link_stats64 *sp;
+ 
+ 		attr = nla_reserve_64bit(skb, IFLA_STATS_LINK_64,
+ 					 sizeof(struct rtnl_link_stats64),
+ 					 IFLA_STATS_UNSPEC);
+ 		if (!attr)
+ 			goto nla_put_failure;
+ 
+ 		sp = nla_data(attr);
+ 		dev_get_stats(dev, sp);
+ 	}
+ 
+ 	if (stats_attr_valid(filter_mask, IFLA_STATS_LINK_XSTATS, *idxattr)) {
+ 		const struct rtnl_link_ops *ops = dev->rtnl_link_ops;
+ 
+ 		if (ops && ops->fill_linkxstats) {
+ 			int err;
+ 
+ 			*idxattr = IFLA_STATS_LINK_XSTATS;
+ 			attr = nla_nest_start(skb,
+ 					      IFLA_STATS_LINK_XSTATS);
+ 			if (!attr)
+ 				goto nla_put_failure;
+ 
+ 			err = ops->fill_linkxstats(skb, dev, prividx);
+ 			nla_nest_end(skb, attr);
+ 			if (err)
+ 				goto nla_put_failure;
+ 			*idxattr = 0;
+ 		}
+ 	}
+ 
+ 	nlmsg_end(skb, nlh);
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	/* not a multi message or no progress mean a real error */
+ 	if (!(flags & NLM_F_MULTI) || s_prividx == *prividx)
+ 		nlmsg_cancel(skb, nlh);
+ 	else
+ 		nlmsg_end(skb, nlh);
+ 
+ 	return -EMSGSIZE;
+ }
+ 
+ static const struct nla_policy ifla_stats_policy[IFLA_STATS_MAX + 1] = {
+ 	[IFLA_STATS_LINK_64]	= { .len = sizeof(struct rtnl_link_stats64) },
+ };
+ 
+ static size_t if_nlmsg_stats_size(const struct net_device *dev,
+ 				  u32 filter_mask)
+ {
+ 	size_t size = 0;
+ 
+ 	if (stats_attr_valid(filter_mask, IFLA_STATS_LINK_64, 0))
+ 		size += nla_total_size_64bit(sizeof(struct rtnl_link_stats64));
+ 
+ 	if (stats_attr_valid(filter_mask, IFLA_STATS_LINK_XSTATS, 0)) {
+ 		const struct rtnl_link_ops *ops = dev->rtnl_link_ops;
+ 
+ 		if (ops && ops->get_linkxstats_size) {
+ 			size += nla_total_size(ops->get_linkxstats_size(dev));
+ 			/* for IFLA_STATS_LINK_XSTATS */
+ 			size += nla_total_size(0);
+ 		}
+ 	}
+ 
+ 	return size;
+ }
+ 
+ static int rtnl_stats_get(struct sk_buff *skb, struct nlmsghdr *nlh)
+ {
+ 	struct net *net = sock_net(skb->sk);
+ 	struct net_device *dev = NULL;
+ 	int idxattr = 0, prividx = 0;
+ 	struct if_stats_msg *ifsm;
+ 	struct sk_buff *nskb;
+ 	u32 filter_mask;
+ 	int err;
+ 
+ 	ifsm = nlmsg_data(nlh);
+ 	if (ifsm->ifindex > 0)
+ 		dev = __dev_get_by_index(net, ifsm->ifindex);
+ 	else
+ 		return -EINVAL;
+ 
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	filter_mask = ifsm->filter_mask;
+ 	if (!filter_mask)
+ 		return -EINVAL;
+ 
+ 	nskb = nlmsg_new(if_nlmsg_stats_size(dev, filter_mask), GFP_KERNEL);
+ 	if (!nskb)
+ 		return -ENOBUFS;
+ 
+ 	err = rtnl_fill_statsinfo(nskb, dev, RTM_NEWSTATS,
+ 				  NETLINK_CB(skb).portid, nlh->nlmsg_seq, 0,
+ 				  0, filter_mask, &idxattr, &prividx);
+ 	if (err < 0) {
+ 		/* -EMSGSIZE implies BUG in if_nlmsg_stats_size */
+ 		WARN_ON(err == -EMSGSIZE);
+ 		kfree_skb(nskb);
+ 	} else {
+ 		err = rtnl_unicast(nskb, net, NETLINK_CB(skb).portid);
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int rtnl_stats_dump(struct sk_buff *skb, struct netlink_callback *cb)
+ {
+ 	int h, s_h, err, s_idx, s_idxattr, s_prividx;
+ 	struct net *net = sock_net(skb->sk);
+ 	unsigned int flags = NLM_F_MULTI;
+ 	struct if_stats_msg *ifsm;
+ 	struct hlist_head *head;
+ 	struct net_device *dev;
+ 	u32 filter_mask = 0;
+ 	int idx = 0;
+ 
+ 	s_h = cb->args[0];
+ 	s_idx = cb->args[1];
+ 	s_idxattr = cb->args[2];
+ 	s_prividx = cb->args[3];
+ 
+ 	cb->seq = net->dev_base_seq;
+ 
+ 	ifsm = nlmsg_data(cb->nlh);
+ 	filter_mask = ifsm->filter_mask;
+ 	if (!filter_mask)
+ 		return -EINVAL;
+ 
+ 	for (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {
+ 		idx = 0;
+ 		head = &net->dev_index_head[h];
+ 		hlist_for_each_entry(dev, head, index_hlist) {
+ 			if (idx < s_idx)
+ 				goto cont;
+ 			err = rtnl_fill_statsinfo(skb, dev, RTM_NEWSTATS,
+ 						  NETLINK_CB(cb->skb).portid,
+ 						  cb->nlh->nlmsg_seq, 0,
+ 						  flags, filter_mask,
+ 						  &s_idxattr, &s_prividx);
+ 			/* If we ran out of room on the first message,
+ 			 * we're in trouble
+ 			 */
+ 			WARN_ON((err == -EMSGSIZE) && (skb->len == 0));
+ 
+ 			if (err < 0)
+ 				goto out;
+ 			s_prividx = 0;
+ 			s_idxattr = 0;
+ 			nl_dump_check_consistent(cb, nlmsg_hdr(skb));
+ cont:
+ 			idx++;
+ 		}
+ 	}
+ out:
+ 	cb->args[3] = s_prividx;
+ 	cb->args[2] = s_idxattr;
+ 	cb->args[1] = idx;
+ 	cb->args[0] = h;
+ 
+ 	return skb->len;
+ }
+ 
++>>>>>>> 97a47facf346 (net: rtnetlink: add linkxstats callbacks and attribute)
  /* Process one rtnetlink message. */
  
  static int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
* Unmerged path include/net/rtnetlink.h
* Unmerged path include/uapi/linux/if_link.h
* Unmerged path net/core/rtnetlink.c
