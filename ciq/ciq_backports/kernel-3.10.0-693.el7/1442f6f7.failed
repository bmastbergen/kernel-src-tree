ipvs: explicitly forbid ipv6 service/dest creation if ipv6 mod is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Paolo Abeni <pabeni@redhat.com>
commit 1442f6f7c1b77de1c508318164a527e240c24a4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1442f6f7.failed

When creating a new ipvs service, ipv6 addresses are always accepted
if CONFIG_IP_VS_IPV6 is enabled. On dest creation the address family
is not explicitly checked.

This allows the user-space to configure ipvs services even if the
system is booted with ipv6.disable=1. On specific configuration, ipvs
can try to call ipv6 routing code at setup time, causing the kernel to
oops due to fib6_rules_ops being NULL.

This change addresses the issue adding a check for the ipv6
module being enabled while validating ipv6 service operations and
adding the same validation for dest operations.

According to git history, this issue is apparently present since
the introduction of ipv6 support, and the oops can be triggered
since commit 09571c7ae30865ad ("IPVS: Add function to determine
if IPv6 address is local")

Fixes: 09571c7ae30865ad ("IPVS: Add function to determine if IPv6 address is local")
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Acked-by: Julian Anastasov <ja@ssi.bg>
	Signed-off-by: Simon Horman <horms@verge.net.au>
(cherry picked from commit 1442f6f7c1b77de1c508318164a527e240c24a4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipvs/ip_vs_ctl.c
diff --cc net/netfilter/ipvs/ip_vs_ctl.c
index 0d8330f1d178,4d753beaac32..000000000000
--- a/net/netfilter/ipvs/ip_vs_ctl.c
+++ b/net/netfilter/ipvs/ip_vs_ctl.c
@@@ -3011,7 -3078,18 +3011,22 @@@ nla_put_failure
  	return skb->len;
  }
  
++<<<<<<< HEAD
 +static int ip_vs_genl_parse_service(struct net *net,
++=======
+ static bool ip_vs_is_af_valid(int af)
+ {
+ 	if (af == AF_INET)
+ 		return true;
+ #ifdef CONFIG_IP_VS_IPV6
+ 	if (af == AF_INET6 && ipv6_mod_enabled())
+ 		return true;
+ #endif
+ 	return false;
+ }
+ 
+ static int ip_vs_genl_parse_service(struct netns_ipvs *ipvs,
++>>>>>>> 1442f6f7c1b7 (ipvs: explicitly forbid ipv6 service/dest creation if ipv6 mod is disabled)
  				    struct ip_vs_service_user_kern *usvc,
  				    struct nlattr *nla, int full_entry,
  				    struct ip_vs_service **ret_svc)
@@@ -3456,6 -3607,40 +3467,43 @@@ static int ip_vs_genl_set_cmd(struct sk
  					    need_full_dest);
  		if (ret)
  			goto out;
++<<<<<<< HEAD
++=======
+ 
+ 		/* Old protocols did not allow the user to specify address
+ 		 * family, so we set it to zero instead.  We also didn't
+ 		 * allow heterogeneous pools in the old code, so it's safe
+ 		 * to assume that this will have the same address family as
+ 		 * the service.
+ 		 */
+ 		if (udest.af == 0)
+ 			udest.af = svc->af;
+ 
+ 		if (!ip_vs_is_af_valid(udest.af)) {
+ 			ret = -EAFNOSUPPORT;
+ 			goto out;
+ 		}
+ 
+ 		if (udest.af != svc->af && cmd != IPVS_CMD_DEL_DEST) {
+ 			/* The synchronization protocol is incompatible
+ 			 * with mixed family services
+ 			 */
+ 			if (ipvs->sync_state) {
+ 				ret = -EINVAL;
+ 				goto out;
+ 			}
+ 
+ 			/* Which connection types do we support? */
+ 			switch (udest.conn_flags) {
+ 			case IP_VS_CONN_F_TUNNEL:
+ 				/* We are able to forward this */
+ 				break;
+ 			default:
+ 				ret = -EINVAL;
+ 				goto out;
+ 			}
+ 		}
++>>>>>>> 1442f6f7c1b7 (ipvs: explicitly forbid ipv6 service/dest creation if ipv6 mod is disabled)
  	}
  
  	switch (cmd) {
* Unmerged path net/netfilter/ipvs/ip_vs_ctl.c
