dm table: simplify dm_table_determine_type()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 5b8c01f74cf03b1ec013fcf358b384706233f2f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5b8c01f7.failed

Use a single loop instead of two loops to determine whether or not
all_blk_mq has to be set.

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 5b8c01f74cf03b1ec013fcf358b384706233f2f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-table.c
diff --cc drivers/md/dm-table.c
index 15241060f605,0a427de23ed2..000000000000
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@@ -843,12 -871,20 +843,16 @@@ static int dm_table_set_type(struct dm_
  {
  	unsigned i;
  	unsigned bio_based = 0, request_based = 0, hybrid = 0;
++<<<<<<< HEAD
 +	bool use_blk_mq = false;
++=======
+ 	unsigned sq_count = 0, mq_count = 0;
++>>>>>>> 5b8c01f74cf0 (dm table: simplify dm_table_determine_type())
  	struct dm_target *tgt;
  	struct dm_dev_internal *dd;
 -	struct list_head *devices = dm_table_get_devices(t);
 +	struct list_head *devices;
  	unsigned live_md_type = dm_get_md_type(t->md);
  
 -	if (t->type != DM_TYPE_NONE) {
 -		/* target already set the table's type */
 -		if (t->type == DM_TYPE_BIO_BASED)
 -			return 0;
 -		BUG_ON(t->type == DM_TYPE_DAX_BIO_BASED);
 -		goto verify_rq_based;
 -	}
 -
  	for (i = 0; i < t->num_targets; i++) {
  		tgt = t->targets + i;
  		if (dm_target_hybrid(tgt))
@@@ -908,25 -966,15 +912,37 @@@
  		}
  
  		if (q->mq_ops)
++<<<<<<< HEAD
 +			use_blk_mq = true;
 +	}
 +
 +	if (use_blk_mq) {
 +		/* verify _all_ devices in the table are blk-mq devices */
 +		list_for_each_entry(dd, devices, list)
 +			if (!bdev_get_queue(dd->dm_dev->bdev)->mq_ops) {
 +				DMERR("table load rejected: not all devices"
 +				      " are blk-mq request-stackable");
 +				return -EINVAL;
 +			}
 +		t->type = DM_TYPE_MQ_REQUEST_BASED;
 +
 +	} else if (list_empty(devices) && __table_type_request_based(live_md_type)) {
 +		/* inherit live MD type */
 +		t->type = live_md_type;
 +
 +	} else
 +		t->type = DM_TYPE_REQUEST_BASED;
++=======
+ 			mq_count++;
+ 		else
+ 			sq_count++;
+ 	}
+ 	if (sq_count && mq_count) {
+ 		DMERR("table load rejected: not all devices are blk-mq request-stackable");
+ 		return -EINVAL;
+ 	}
+ 	t->all_blk_mq = mq_count > 0;
++>>>>>>> 5b8c01f74cf0 (dm table: simplify dm_table_determine_type())
  
  	if (t->type == DM_TYPE_MQ_REQUEST_BASED && !t->all_blk_mq) {
  		DMERR("table load rejected: all devices are not blk-mq request-stackable");
* Unmerged path drivers/md/dm-table.c
