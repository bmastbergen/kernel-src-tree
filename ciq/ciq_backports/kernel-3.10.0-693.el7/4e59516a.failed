kvm: vmx: ensure VMCS is current while enabling PML

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Peter Feiner <pfeiner@google.com>
commit 4e59516a12a6ef6dcb660cb3a3f70c64bd60cfec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4e59516a.failed

Between loading the new VMCS and enabling PML, the CPU was unpinned.
If the vCPU thread were migrated to another CPU in the interim (e.g.,
due to preemption or sleeping alloc_page), then the VMWRITEs to enable
PML would target the wrong VMCS -- or no VMCS at all:

  [ 2087.266950] vmwrite error: reg 200e value 3fe1d52000 (err -506126336)
  [ 2087.267062] vmwrite error: reg 812 value 1ff (err 511)
  [ 2087.267125] vmwrite error: reg 401e value 12229c00 (err 304258048)

This patch ensures that the VMCS remains current while enabling PML by
doing the VMWRITEs while the CPU is pinned. Allocation of the PML buffer
is hoisted out of the critical section.

	Signed-off-by: Peter Feiner <pfeiner@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 4e59516a12a6ef6dcb660cb3a3f70c64bd60cfec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index b6b99a62ce0a,e34965b37a88..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -4832,6 -4976,15 +4832,18 @@@ static int vmx_vcpu_setup(struct vcpu_v
  	vmcs_writel(CR0_GUEST_HOST_MASK, ~0UL);
  	set_cr4_guest_host_mask(vmx);
  
++<<<<<<< HEAD
++=======
+ 	if (vmx_xsaves_supported())
+ 		vmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP);
+ 
+ 	if (enable_pml) {
+ 		ASSERT(vmx->pml_pg);
+ 		vmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));
+ 		vmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);
+ 	}
+ 
++>>>>>>> 4e59516a12a6 (kvm: vmx: ensure VMCS is current while enabling PML)
  	return 0;
  }
  
* Unmerged path arch/x86/kvm/vmx.c
