gre: receive also TEB packets for lwtunnels

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jiri Benc <jbenc@redhat.com>
commit 125372faa4feb15e86f410c1adabbca9186d9c4a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/125372fa.failed

For ipgre interfaces in collect metadata mode, receive also traffic with
encapsulated Ethernet headers. The lwtunnel users are supposed to sort this
out correctly. This allows to have mixed Ethernet + L3-only traffic on the
same lwtunnel interface. This is the same way as VXLAN-GPE behaves.

To keep backwards compatibility and prevent any surprises, gretap interfaces
have priority in receiving packets with Ethernet headers.

	Signed-off-by: Jiri Benc <jbenc@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 125372faa4feb15e86f410c1adabbca9186d9c4a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_gre.c
diff --cc net/ipv4/ip_gre.c
index 5cd0e7261a0a,2b267e71ebf5..000000000000
--- a/net/ipv4/ip_gre.c
+++ b/net/ipv4/ip_gre.c
@@@ -380,11 -260,10 +380,14 @@@ static __be32 tunnel_id_to_key(__be64 x
  #endif
  }
  
++<<<<<<< HEAD
 +static int ipgre_rcv(struct sk_buff *skb, const struct tnl_ptk_info *tpi)
++=======
+ static int __ipgre_rcv(struct sk_buff *skb, const struct tnl_ptk_info *tpi,
+ 		       struct ip_tunnel_net *itn, int hdr_len, bool raw_proto)
++>>>>>>> 125372faa4fe (gre: receive also TEB packets for lwtunnels)
  {
- 	struct net *net = dev_net(skb->dev);
  	struct metadata_dst *tun_dst = NULL;
- 	struct ip_tunnel_net *itn;
  	const struct iphdr *iph;
  	struct ip_tunnel *tunnel;
  
@@@ -398,6 -272,10 +396,13 @@@
  				  iph->saddr, iph->daddr, tpi->key);
  
  	if (tunnel) {
++<<<<<<< HEAD
++=======
+ 		if (__iptunnel_pull_header(skb, hdr_len, tpi->proto,
+ 					   raw_proto, false) < 0)
+ 			goto drop;
+ 
++>>>>>>> 125372faa4fe (gre: receive also TEB packets for lwtunnels)
  		skb_pop_mac_header(skb);
  		if (tunnel->collect_md) {
  			__be16 flags;
@@@ -413,7 -291,34 +418,38 @@@
  		ip_tunnel_rcv(tunnel, skb, tpi, tun_dst, log_ecn_error);
  		return PACKET_RCVD;
  	}
++<<<<<<< HEAD
 +	return PACKET_REJECT;
++=======
+ 	return PACKET_NEXT;
+ 
+ drop:
+ 	kfree_skb(skb);
+ 	return PACKET_RCVD;
++>>>>>>> 125372faa4fe (gre: receive also TEB packets for lwtunnels)
+ }
+ 
+ static int ipgre_rcv(struct sk_buff *skb, const struct tnl_ptk_info *tpi,
+ 		     int hdr_len)
+ {
+ 	struct net *net = dev_net(skb->dev);
+ 	struct ip_tunnel_net *itn;
+ 	int res;
+ 
+ 	if (tpi->proto == htons(ETH_P_TEB))
+ 		itn = net_generic(net, gre_tap_net_id);
+ 	else
+ 		itn = net_generic(net, ipgre_net_id);
+ 
+ 	res = __ipgre_rcv(skb, tpi, itn, hdr_len, false);
+ 	if (res == PACKET_NEXT && tpi->proto == htons(ETH_P_TEB)) {
+ 		/* ipgre tunnels in collect metadata mode should receive
+ 		 * also ETH_P_TEB traffic.
+ 		 */
+ 		itn = net_generic(net, ipgre_net_id);
+ 		res = __ipgre_rcv(skb, tpi, itn, hdr_len, true);
+ 	}
+ 	return res;
  }
  
  static int gre_rcv(struct sk_buff *skb)
diff --git a/include/net/ip_tunnels.h b/include/net/ip_tunnels.h
index c62b45515469..353c46f48008 100644
--- a/include/net/ip_tunnels.h
+++ b/include/net/ip_tunnels.h
@@ -165,6 +165,7 @@ struct tnl_ptk_info {
 
 #define PACKET_RCVD	0
 #define PACKET_REJECT	1
+#define PACKET_NEXT	2
 
 #define IP_TNL_HASH_BITS   7
 #define IP_TNL_HASH_SIZE   (1 << IP_TNL_HASH_BITS)
* Unmerged path net/ipv4/ip_gre.c
