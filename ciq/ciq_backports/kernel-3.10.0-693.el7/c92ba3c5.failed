NTB: invalid buf pointer in multi-MW setups

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [ntb] invalid buf pointer in multi-MW setups (Suravee Suthikulpanit) [1303727]
Rebuild_FUZZ: 93.83%
commit-author Jon Mason <jdmason@kudzu.us>
commit c92ba3c5d97de59c016d1a23ebab17293a792621
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c92ba3c5.failed

Order of operations issue with the QP Num and MW count, which would
result in the receive buffer pointer being invalid if there are more
than 1 MW.  Corrected with parenthesis to enforce the proper order of
operations.

	Reported-by: John I. Kading <John.Kading@gd-ms.com>
	Signed-off-by: Jon Mason <jdmason@kudzu.us>
(cherry picked from commit c92ba3c5d97de59c016d1a23ebab17293a792621)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ntb/ntb_transport.c
diff --cc drivers/ntb/ntb_transport.c
index 0d5e96e60628,be9389599e75..000000000000
--- a/drivers/ntb/ntb_transport.c
+++ b/drivers/ntb/ntb_transport.c
@@@ -501,26 -560,52 +501,31 @@@ out
  	return entry;
  }
  
 -static struct ntb_queue_entry *ntb_list_mv(spinlock_t *lock,
 -					   struct list_head *list,
 -					   struct list_head *to_list)
 +static void ntb_transport_setup_qp_mw(struct ntb_transport *nt,
 +				      unsigned int qp_num)
  {
 -	struct ntb_queue_entry *entry;
 -	unsigned long flags;
 -
 -	spin_lock_irqsave(lock, flags);
 -
 -	if (list_empty(list)) {
 -		entry = NULL;
 -	} else {
 -		entry = list_first_entry(list, struct ntb_queue_entry, entry);
 -		list_move_tail(&entry->entry, to_list);
 -	}
 -
 -	spin_unlock_irqrestore(lock, flags);
 -
 -	return entry;
 -}
 -
 -static int ntb_transport_setup_qp_mw(struct ntb_transport_ctx *nt,
 -				     unsigned int qp_num)
 -{
 -	struct ntb_transport_qp *qp = &nt->qp_vec[qp_num];
 -	struct ntb_transport_mw *mw;
 +	struct ntb_transport_qp *qp = &nt->qps[qp_num];
  	unsigned int rx_size, num_qps_mw;
 -	unsigned int mw_num, mw_count, qp_count;
 +	u8 mw_num, mw_max;
  	unsigned int i;
  
 -	mw_count = nt->mw_count;
 -	qp_count = nt->qp_count;
 -
 -	mw_num = QP_TO_MW(nt, qp_num);
 -	mw = &nt->mw_vec[mw_num];
 +	mw_max = ntb_max_mw(nt->ndev);
 +	mw_num = QP_TO_MW(nt->ndev, qp_num);
  
 -	if (!mw->virt_addr)
 -		return -ENOMEM;
 +	WARN_ON(nt->mw[mw_num].virt_addr == NULL);
  
 -	if (qp_count % mw_count && mw_num + 1 < qp_count / mw_count)
 -		num_qps_mw = qp_count / mw_count + 1;
 +	if (nt->max_qps % mw_max && mw_num + 1 < nt->max_qps / mw_max)
 +		num_qps_mw = nt->max_qps / mw_max + 1;
  	else
 -		num_qps_mw = qp_count / mw_count;
 +		num_qps_mw = nt->max_qps / mw_max;
  
++<<<<<<< HEAD
 +	rx_size = (unsigned int) nt->mw[mw_num].size / num_qps_mw;
 +	qp->rx_buff = nt->mw[mw_num].virt_addr + qp_num / mw_max * rx_size;
++=======
+ 	rx_size = (unsigned int)mw->xlat_size / num_qps_mw;
+ 	qp->rx_buff = mw->virt_addr + rx_size * (qp_num / mw_count);
++>>>>>>> c92ba3c5d97d (NTB: invalid buf pointer in multi-MW setups)
  	rx_size -= sizeof(struct ntb_rx_info);
  
  	qp->remote_rx_info = qp->rx_buff + rx_size;
@@@ -869,18 -943,22 +874,28 @@@ static int ntb_transport_init_queue(str
  	qp->qp_num = qp_num;
  	qp->transport = nt;
  	qp->ndev = nt->ndev;
 -	qp->client_ready = false;
 +	qp->qp_link = NTB_LINK_DOWN;
 +	qp->client_ready = NTB_LINK_DOWN;
  	qp->event_handler = NULL;
 -	ntb_qp_link_down_reset(qp);
  
 -	if (qp_count % mw_count && mw_num + 1 < qp_count / mw_count)
 -		num_qps_mw = qp_count / mw_count + 1;
 +	if (nt->max_qps % mw_max && mw_num + 1 < nt->max_qps / mw_max)
 +		num_qps_mw = nt->max_qps / mw_max + 1;
  	else
 -		num_qps_mw = qp_count / mw_count;
 +		num_qps_mw = nt->max_qps / mw_max;
  
++<<<<<<< HEAD
 +	tx_size = (unsigned int) ntb_get_mw_size(qp->ndev, mw_num) / num_qps_mw;
 +	qp_offset = qp_num / mw_max * tx_size;
 +	qp->tx_mw = ntb_get_mw_vbase(nt->ndev, mw_num) + qp_offset;
++=======
+ 	mw_base = nt->mw_vec[mw_num].phys_addr;
+ 	mw_size = nt->mw_vec[mw_num].phys_size;
+ 
+ 	tx_size = (unsigned int)mw_size / num_qps_mw;
+ 	qp_offset = tx_size * (qp_num / mw_count);
+ 
+ 	qp->tx_mw = nt->mw_vec[mw_num].vbase + qp_offset;
++>>>>>>> c92ba3c5d97d (NTB: invalid buf pointer in multi-MW setups)
  	if (!qp->tx_mw)
  		return -EINVAL;
  
* Unmerged path drivers/ntb/ntb_transport.c
