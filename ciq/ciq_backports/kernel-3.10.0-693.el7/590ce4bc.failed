mnt: Add MNT_UMOUNT flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 590ce4bcbfb4e0462a720a4ad901e84416080bba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/590ce4bc.failed

In some instances it is necessary to know if the the unmounting
process has begun on a mount.  Add MNT_UMOUNT to make that reliably
testable.

This fix gets used in fixing locked mounts in MNT_DETACH

	Cc: stable@vger.kernel.org
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 590ce4bcbfb4e0462a720a4ad901e84416080bba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
#	fs/pnode.c
diff --cc fs/namespace.c
index 07e51358b239,d1708147eb45..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -1217,13 -1330,24 +1217,21 @@@ void umount_tree(struct mount *mnt, in
  	LIST_HEAD(tmp_list);
  	struct mount *p;
  
++<<<<<<< HEAD
 +	for (p = mnt; p; p = next_mnt(p, mnt))
 +		list_move(&p->mnt_hash, &tmp_list);
++=======
+ 	/* Gather the mounts to umount */
+ 	for (p = mnt; p; p = next_mnt(p, mnt)) {
+ 		p->mnt.mnt_flags |= MNT_UMOUNT;
+ 		list_move(&p->mnt_list, &tmp_list);
+ 	}
++>>>>>>> 590ce4bcbfb4 (mnt: Add MNT_UMOUNT flag)
  
 -	/* Hide the mounts from lookup_mnt and mnt_mounts */
 -	list_for_each_entry(p, &tmp_list, mnt_list) {
 -		hlist_del_init_rcu(&p->mnt_hash);
 -		list_del_init(&p->mnt_child);
 -	}
 -
 -	/* Add propogated mounts to the tmp_list */
 -	if (how & UMOUNT_PROPAGATE)
 +	if (propagate)
  		propagate_umount(&tmp_list);
  
 -	while (!list_empty(&tmp_list)) {
 -		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 +	list_for_each_entry(p, &tmp_list, mnt_hash) {
  		list_del_init(&p->mnt_expire);
  		list_del_init(&p->mnt_list);
  		__touch_mnt_namespace(p->mnt_ns);
diff --cc fs/pnode.c
index 4cba0cce1f85,ac3aa0d43b90..000000000000
--- a/fs/pnode.c
+++ b/fs/pnode.c
@@@ -389,8 -381,12 +389,17 @@@ static void __propagate_umount(struct m
  		 * umount the child only if the child has no
  		 * other children
  		 */
++<<<<<<< HEAD
 +		if (child && list_empty(&child->mnt_mounts))
 +			list_move_tail(&child->mnt_hash, &mnt->mnt_hash);
++=======
+ 		if (child && list_empty(&child->mnt_mounts)) {
+ 			list_del_init(&child->mnt_child);
+ 			hlist_del_init_rcu(&child->mnt_hash);
+ 			child->mnt.mnt_flags |= MNT_UMOUNT;
+ 			list_move_tail(&child->mnt_list, &mnt->mnt_list);
+ 		}
++>>>>>>> 590ce4bcbfb4 (mnt: Add MNT_UMOUNT flag)
  	}
  }
  
* Unmerged path fs/namespace.c
* Unmerged path fs/pnode.c
diff --git a/include/linux/mount.h b/include/linux/mount.h
index ff7641f32d5f..c9b58f5b946f 100644
--- a/include/linux/mount.h
+++ b/include/linux/mount.h
@@ -53,6 +53,7 @@ struct mnt_namespace;
 #define MNT_LOCKED		0x800000
 
 #define MNT_MARKED		0x4000000
+#define MNT_UMOUNT		0x8000000
 
 struct vfsmount {
 	struct dentry *mnt_root;	/* root of the mounted tree */
