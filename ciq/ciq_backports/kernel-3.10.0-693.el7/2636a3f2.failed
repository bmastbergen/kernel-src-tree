HID: wacom: Split apart 'wacom_setup_pentouch_input_capabilites'

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Split apart wacom_setup_pentouch_input_capabilites (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 94.21%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 2636a3f2d1421e3e629dfc96489c23727bab17d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2636a3f2.failed

This splits the 'wacom_setup_pentouch_input_capabilites' function into
pieces dedicated to doing setup for just the pen interface and just
the touch interface. This makes it easier to focus on the relevant
piece when making changes.

This patch introduces no functional changes.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 2636a3f2d1421e3e629dfc96489c23727bab17d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom.h
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom.h
index 87d2c48e3adc,a533787a6d85..000000000000
--- a/drivers/hid/wacom.h
+++ b/drivers/hid/wacom.h
@@@ -135,10 -131,20 +135,17 @@@ static inline void wacom_schedule_work(
  	schedule_work(&wacom->work);
  }
  
 -extern const struct hid_device_id wacom_ids[];
 +extern const struct usb_device_id wacom_ids[];
  
  void wacom_wac_irq(struct wacom_wac *wacom_wac, size_t len);
++<<<<<<< HEAD
 +void wacom_setup_device_quirks(struct wacom_features *features);
 +int wacom_setup_input_capabilities(struct input_dev *input_dev,
++=======
+ void wacom_setup_device_quirks(struct wacom *wacom);
+ int wacom_setup_pen_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac);
+ int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
++>>>>>>> 2636a3f2d142 (HID: wacom: Split apart 'wacom_setup_pentouch_input_capabilites')
  				   struct wacom_wac *wacom_wac);
 -int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
 -				       struct wacom_wac *wacom_wac);
 -void wacom_wac_usage_mapping(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage);
 -int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
 -		struct hid_usage *usage, __s32 value);
 -void wacom_wac_report(struct hid_device *hdev, struct hid_report *report);
 -void wacom_battery_work(struct work_struct *work);
  #endif
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,ca15c7f59dc7..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1127,35 -1088,153 +1127,54 @@@ static void wacom_destroy_battery(struc
  	}
  }
  
 -static ssize_t wacom_show_speed(struct device *dev,
 -				struct device_attribute
 -				*attr, char *buf)
 -{
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -
 -	return snprintf(buf, PAGE_SIZE, "%i\n", wacom->wacom_wac.bt_high_speed);
 -}
 -
 -static ssize_t wacom_store_speed(struct device *dev,
 -				struct device_attribute *attr,
 -				const char *buf, size_t count)
 -{
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	u8 new_speed;
 -
 -	if (kstrtou8(buf, 0, &new_speed))
 -		return -EINVAL;
 -
 -	if (new_speed != 0 && new_speed != 1)
 -		return -EINVAL;
 -
 -	wacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);
 -
 -	return count;
 -}
 -
 -static DEVICE_ATTR(speed, DEV_ATTR_RW_PERM,
 -		wacom_show_speed, wacom_store_speed);
 -
 -static struct input_dev *wacom_allocate_input(struct wacom *wacom)
 +static int wacom_register_input(struct wacom *wacom)
  {
  	struct input_dev *input_dev;
 -	struct hid_device *hdev = wacom->hdev;
 -	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 -
 -	input_dev = input_allocate_device();
 -	if (!input_dev)
 -		return NULL;
 -
 -	input_dev->name = wacom_wac->name;
 -	input_dev->phys = hdev->phys;
 -	input_dev->dev.parent = &hdev->dev;
 -	input_dev->open = wacom_open;
 -	input_dev->close = wacom_close;
 -	input_dev->uniq = hdev->uniq;
 -	input_dev->id.bustype = hdev->bus;
 -	input_dev->id.vendor  = hdev->vendor;
 -	input_dev->id.product = wacom_wac->pid ? wacom_wac->pid : hdev->product;
 -	input_dev->id.version = hdev->version;
 -	input_set_drvdata(input_dev, wacom);
 -
 -	return input_dev;
 -}
 -
 -static void wacom_free_inputs(struct wacom *wacom)
 -{
 -	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 -
 -	if (wacom_wac->input)
 -		input_free_device(wacom_wac->input);
 -	if (wacom_wac->pad_input)
 -		input_free_device(wacom_wac->pad_input);
 -	wacom_wac->input = NULL;
 -	wacom_wac->pad_input = NULL;
 -}
 -
 -static int wacom_allocate_inputs(struct wacom *wacom)
 -{
 -	struct input_dev *input_dev, *pad_input_dev;
 -	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 -
 -	input_dev = wacom_allocate_input(wacom);
 -	pad_input_dev = wacom_allocate_input(wacom);
 -	if (!input_dev || !pad_input_dev) {
 -		wacom_free_inputs(wacom);
 -		return -ENOMEM;
 -	}
 -
 -	wacom_wac->input = input_dev;
 -	wacom_wac->pad_input = pad_input_dev;
 -	wacom_wac->pad_input->name = wacom_wac->pad_name;
 -
 -	return 0;
 -}
 -
 -static void wacom_clean_inputs(struct wacom *wacom)
 -{
 -	if (wacom->wacom_wac.input) {
 -		if (wacom->wacom_wac.input_registered)
 -			input_unregister_device(wacom->wacom_wac.input);
 -		else
 -			input_free_device(wacom->wacom_wac.input);
 -	}
 -	if (wacom->wacom_wac.pad_input) {
 -		if (wacom->wacom_wac.pad_registered)
 -			input_unregister_device(wacom->wacom_wac.pad_input);
 -		else
 -			input_free_device(wacom->wacom_wac.pad_input);
 -	}
 -	wacom->wacom_wac.input = NULL;
 -	wacom->wacom_wac.pad_input = NULL;
 -	wacom_destroy_leds(wacom);
 -}
 -
 -static int wacom_register_inputs(struct wacom *wacom)
 -{
 -	struct input_dev *input_dev, *pad_input_dev;
 +	struct usb_interface *intf = wacom->intf;
 +	struct usb_device *dev = interface_to_usbdev(intf);
  	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
- 	int error;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	int error = 0;
  
++<<<<<<< HEAD
 +	input_dev = input_allocate_device();
 +	if (!input_dev) {
 +		error = -ENOMEM;
 +		goto fail1;
++=======
+ 	input_dev = wacom_wac->input;
+ 	pad_input_dev = wacom_wac->pad_input;
+ 
+ 	if (!input_dev || !pad_input_dev)
+ 		return -EINVAL;
+ 
+ 	if (features->device_type & WACOM_DEVICETYPE_PEN)
+ 		error = wacom_setup_pen_input_capabilities(input_dev, wacom_wac);
+ 	if (!error && features->device_type & WACOM_DEVICETYPE_TOUCH)
+ 		error = wacom_setup_touch_input_capabilities(input_dev, wacom_wac);
+ 	if (!error) {
+ 		error = input_register_device(input_dev);
+ 		if (error)
+ 			return error;
+ 		wacom_wac->input_registered = true;
++>>>>>>> 2636a3f2d142 (HID: wacom: Split apart 'wacom_setup_pentouch_input_capabilites')
  	}
  
 -	error = wacom_setup_pad_input_capabilities(pad_input_dev, wacom_wac);
 -	if (error) {
 -		/* no pad in use on this interface */
 -		input_free_device(pad_input_dev);
 -		wacom_wac->pad_input = NULL;
 -		pad_input_dev = NULL;
 -	} else {
 -		error = input_register_device(pad_input_dev);
 -		if (error)
 -			goto fail_register_pad_input;
 -		wacom_wac->pad_registered = true;
 +	input_dev->name = wacom_wac->name;
 +	input_dev->dev.parent = &intf->dev;
 +	input_dev->open = wacom_open;
 +	input_dev->close = wacom_close;
 +	usb_to_input_id(dev, &input_dev->id);
 +	input_set_drvdata(input_dev, wacom);
  
 -		error = wacom_initialize_leds(wacom);
 -		if (error)
 -			goto fail_leds;
 -	}
 +	wacom_wac->input = input_dev;
 +	error = wacom_setup_input_capabilities(input_dev, wacom_wac);
 +	if (error)
 +		goto fail1;
 +
 +	error = input_register_device(input_dev);
 +	if (error)
 +		goto fail2;
  
  	return 0;
  
diff --cc drivers/hid/wacom_wac.c
index bc916ccd4c20,b80a67a860b4..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1505,53 -2230,14 +1505,57 @@@ void wacom_setup_device_quirks(struct w
  		features->quirks |= WACOM_QUIRK_NO_INPUT;
  
  		/* must be monitor interface if no device_type set */
 -		if (features->device_type == WACOM_DEVICETYPE_NONE) {
 +		if (!features->device_type)
  			features->quirks |= WACOM_QUIRK_MONITOR;
 -			features->quirks |= WACOM_QUIRK_BATTERY;
 +	}
 +}
 +
++<<<<<<< HEAD
 +static void wacom_abs_set_axis(struct input_dev *input_dev,
 +			       struct wacom_wac *wacom_wac)
 +{
 +	struct wacom_features *features = &wacom_wac->features;
 +
 +	if (features->device_type == BTN_TOOL_PEN) {
 +		input_set_abs_params(input_dev, ABS_X, features->x_min,
 +				     features->x_max, features->x_fuzz, 0);
 +		input_set_abs_params(input_dev, ABS_Y, features->y_min,
 +				     features->y_max, features->y_fuzz, 0);
 +		input_set_abs_params(input_dev, ABS_PRESSURE, 0,
 +			features->pressure_max, features->pressure_fuzz, 0);
 +
 +		/* penabled devices have fixed resolution for each model */
 +		input_abs_set_res(input_dev, ABS_X, features->x_resolution);
 +		input_abs_set_res(input_dev, ABS_Y, features->y_resolution);
 +	} else {
 +		if (features->touch_max <= 2) {
 +			input_set_abs_params(input_dev, ABS_X, 0,
 +				features->x_max, features->x_fuzz, 0);
 +			input_set_abs_params(input_dev, ABS_Y, 0,
 +				features->y_max, features->y_fuzz, 0);
 +			input_abs_set_res(input_dev, ABS_X,
 +					  features->x_resolution);
 +			input_abs_set_res(input_dev, ABS_Y,
 +					  features->y_resolution);
 +		}
 +
 +		if (features->touch_max > 1) {
 +			input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
 +				features->x_max, features->x_fuzz, 0);
 +			input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
 +				features->y_max, features->y_fuzz, 0);
 +			input_abs_set_res(input_dev, ABS_MT_POSITION_X,
 +					  features->x_resolution);
 +			input_abs_set_res(input_dev, ABS_MT_POSITION_Y,
 +					  features->y_resolution);
  		}
  	}
  }
  
 +int wacom_setup_input_capabilities(struct input_dev *input_dev,
++=======
+ int wacom_setup_pen_input_capabilities(struct input_dev *input_dev,
++>>>>>>> 2636a3f2d142 (HID: wacom: Split apart 'wacom_setup_pentouch_input_capabilites')
  				   struct wacom_wac *wacom_wac)
  {
  	struct wacom_features *features = &wacom_wac->features;
@@@ -1559,21 -2244,37 +1563,41 @@@
  
  	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
  
++<<<<<<< HEAD
++=======
+ 	if (!(features->device_type & WACOM_DEVICETYPE_PEN))
+ 		return -ENODEV;
+ 
+ 	if (features->type == HID_GENERIC)
+ 		/* setup has already been done */
+ 		return 0;
+ 
++>>>>>>> 2636a3f2d142 (HID: wacom: Split apart 'wacom_setup_pentouch_input_capabilites')
  	__set_bit(BTN_TOUCH, input_dev->keybit);
  	__set_bit(ABS_MISC, input_dev->absbit);
  
- 	wacom_abs_set_axis(input_dev, wacom_wac);
+ 	input_set_abs_params(input_dev, ABS_X, features->x_min,
+ 			     features->x_max, features->x_fuzz, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, features->y_min,
+ 			     features->y_max, features->y_fuzz, 0);
+ 	input_set_abs_params(input_dev, ABS_PRESSURE, 0,
+ 		features->pressure_max, features->pressure_fuzz, 0);
+ 
+ 	/* penabled devices have fixed resolution for each model */
+ 	input_abs_set_res(input_dev, ABS_X, features->x_resolution);
+ 	input_abs_set_res(input_dev, ABS_Y, features->y_resolution);
+ 
  
 -	switch (features->type) {
 -	case GRAPHIRE_BT:
 -		__clear_bit(ABS_MISC, input_dev->absbit);
 -
 +	switch (wacom_wac->features.type) {
  	case WACOM_MO:
 +		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
 +		/* fall through */
 +
  	case WACOM_G4:
 -		input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 -					      features->distance_max,
 -					      0, 0);
 +		input_set_capability(input_dev, EV_MSC, MSC_SERIAL);
 +
 +		__set_bit(BTN_BACK, input_dev->keybit);
 +		__set_bit(BTN_FORWARD, input_dev->keybit);
  		/* fall through */
  
  	case GRAPHIRE:
@@@ -1592,6 -2293,250 +1616,253 @@@
  		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
++<<<<<<< HEAD
++=======
+ 	case WACOM_27QHD:
+ 	case WACOM_24HD:
+ 	case DTK:
+ 	case WACOM_22HD:
+ 	case WACOM_21UX2:
+ 	case WACOM_BEE:
+ 	case CINTIQ:
+ 	case WACOM_13HD:
+ 	case CINTIQ_HYBRID:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 287);
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		wacom_setup_cintiq(wacom_wac);
+ 		break;
+ 
+ 	case INTUOS3:
+ 	case INTUOS3L:
+ 	case INTUOS3S:
+ 	case INTUOS4:
+ 	case INTUOS4WL:
+ 	case INTUOS4L:
+ 	case INTUOS4S:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 287);
+ 		/* fall through */
+ 
+ 	case INTUOS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		wacom_setup_intuos(wacom_wac);
+ 		break;
+ 
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 				      features->distance_max,
+ 				      0, 0);
+ 
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 287);
+ 
+ 		wacom_setup_intuos(wacom_wac);
+ 		break;
+ 
+ 	case WACOM_24HDT:
+ 	case WACOM_27QHDT:
+ 	case MTSCREEN:
+ 	case MTTPC:
+ 	case MTTPC_B:
+ 	case TABLETPC2FG:
+ 	case TABLETPC:
+ 	case TABLETPCE:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 		/* fall through */
+ 
+ 	case DTUS:
+ 	case DTUSX:
+ 	case PL:
+ 	case DTU:
+ 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		break;
+ 
+ 	case PTU:
+ 		__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case PENPARTNER:
+ 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 	case BAMBOO_PT:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 				      features->distance_max,
+ 				      0, 0);
+ 		break;
+ 	case BAMBOO_PAD:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ int wacom_setup_touch_input_capabilities(struct input_dev *input_dev,
+ 					 struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_TOUCH))
+ 		return -ENODEV;
+ 
+ 	if (features->type == HID_GENERIC)
+ 		/* setup has already been done */
+ 		return 0;
+ 
+ 	__set_bit(BTN_TOUCH, input_dev->keybit);
+ 
+ 	if (features->touch_max == 1) {
+ 		input_set_abs_params(input_dev, ABS_X, 0,
+ 			features->x_max, features->x_fuzz, 0);
+ 		input_set_abs_params(input_dev, ABS_Y, 0,
+ 			features->y_max, features->y_fuzz, 0);
+ 		input_abs_set_res(input_dev, ABS_X,
+ 				  features->x_resolution);
+ 		input_abs_set_res(input_dev, ABS_Y,
+ 				  features->y_resolution);
+ 	}
+ 	else if (features->touch_max > 1) {
+ 		input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+ 			features->x_max, features->x_fuzz, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+ 			features->y_max, features->y_fuzz, 0);
+ 		input_abs_set_res(input_dev, ABS_MT_POSITION_X,
+ 				  features->x_resolution);
+ 		input_abs_set_res(input_dev, ABS_MT_POSITION_Y,
+ 				  features->y_resolution);
+ 	}
+ 
+ 	switch (features->type) {
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR, 0, features->y_max, 0, 0);
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		break;
+ 
+ 	case WACOM_24HDT:
+ 		input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
+ 		/* fall through */
+ 
+ 	case WACOM_27QHDT:
+ 	case MTSCREEN:
+ 	case MTTPC:
+ 	case MTTPC_B:
+ 	case TABLETPC2FG:
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);
+ 		/*fall through */
+ 
+ 	case TABLETPC:
+ 	case TABLETPCE:
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 		input_dev->evbit[0] |= BIT_MASK(EV_SW);
+ 		__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
+ 		/* fall through */
+ 
+ 	case BAMBOO_PT:
+ 		if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 			input_set_abs_params(input_dev,
+ 				     ABS_MT_TOUCH_MAJOR,
+ 				     0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev,
+ 				     ABS_MT_TOUCH_MINOR,
+ 				     0, features->y_max, 0, 0);
+ 		}
+ 		input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		break;
+ 
+ 	case BAMBOO_PAD:
+ 		input_mt_init_slots(input_dev, features->touch_max,
+ 				    INPUT_MT_POINTER);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	int i;
+ 
+ 	if (!(features->device_type & WACOM_DEVICETYPE_PAD))
+ 		return -ENODEV;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	/* kept for making legacy xf86-input-wacom working with the wheels */
+ 	__set_bit(ABS_MISC, input_dev->absbit);
+ 
+ 	/* kept for making legacy xf86-input-wacom accepting the pad */
+ 	input_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);
+ 
+ 	/* kept for making udev and libwacom accepting the pad */
+ 	__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 	switch (features->type) {
+ 	case GRAPHIRE_BT:
+ 		__set_bit(BTN_0, input_dev->keybit);
+ 		__set_bit(BTN_1, input_dev->keybit);
+ 		break;
+ 
+ 	case WACOM_MO:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_G4:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
+ 		break;
+ 
++>>>>>>> 2636a3f2d142 (HID: wacom: Split apart 'wacom_setup_pentouch_input_capabilites')
  	case WACOM_24HD:
  		__set_bit(BTN_A, input_dev->keybit);
  		__set_bit(BTN_B, input_dev->keybit);
* Unmerged path drivers/hid/wacom.h
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
