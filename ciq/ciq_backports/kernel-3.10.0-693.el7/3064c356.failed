death to mnt_pinned

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 3064c3563ba4c23e2c7a47254ec056ed9ba0098a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3064c356.failed

Rather than playing silly buggers with vfsmount refcounts, just have
acct_on() ask fs/namespace.c for internal clone of file->f_path.mnt
and replace it with said clone.  Then attach the pin to original
vfsmount.  Voila - the clone will be alive until the file gets closed,
making sure that underlying superblock remains active, etc., and
we can drop the original vfsmount, so that it's not kept busy.
If the file lives until the final mntput of the original vfsmount,
we'll notice that there's an fs_pin (one in bsd_acct_struct that
holds that file) and mnt_pin_kill() will take it out.  Since
->kill() is synchronous, we won't proceed past that point until
these files are closed (and private clones of our vfsmount are
gone), so we get the same ordering warranties we used to get.

mnt_pin()/mnt_unpin()/->mnt_pinned is gone now, and good riddance -
it never became usable outside of kernel/acct.c (and racy wrt
umount even there).

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 3064c3563ba4c23e2c7a47254ec056ed9ba0098a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/mount.h
#	fs/namespace.c
#	kernel/acct.c
diff --cc fs/mount.h
index 78d1559796ee,6740a6215529..000000000000
--- a/fs/mount.h
+++ b/fs/mount.h
@@@ -54,7 -55,7 +54,11 @@@ struct mount 
  	int mnt_id;			/* mount identifier */
  	int mnt_group_id;		/* peer group identifier */
  	int mnt_expiry_mark;		/* true if marked for expiry */
++<<<<<<< HEAD
 +	int mnt_pinned;
++=======
+ 	struct hlist_head mnt_pins;
++>>>>>>> 3064c3563ba4 (death to mnt_pinned)
  	struct path mnt_ex_mountpoint;
  };
  
diff --cc fs/namespace.c
index a82db7875df0,65af9d0e0d67..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -876,39 -937,28 +876,53 @@@ static struct mount *clone_mnt(struct m
  
  static void mntput_no_expire(struct mount *mnt)
  {
 -	rcu_read_lock();
 -	mnt_add_count(mnt, -1);
 -	if (likely(mnt->mnt_ns)) { /* shouldn't be the last one */
 -		rcu_read_unlock();
++<<<<<<< HEAD
 +put_again:
 +#ifdef CONFIG_SMP
 +	br_read_lock(&vfsmount_lock);
 +	if (likely(mnt->mnt_ns)) {
 +		/* shouldn't be the last one */
 +		mnt_add_count(mnt, -1);
 +		br_read_unlock(&vfsmount_lock);
  		return;
  	}
 -	lock_mount_hash();
 +	br_read_unlock(&vfsmount_lock);
 +
 +	br_write_lock(&vfsmount_lock);
++=======
++	rcu_read_lock();
++>>>>>>> 3064c3563ba4 (death to mnt_pinned)
 +	mnt_add_count(mnt, -1);
  	if (mnt_get_count(mnt)) {
 -		rcu_read_unlock();
 -		unlock_mount_hash();
 +		br_write_unlock(&vfsmount_lock);
  		return;
  	}
++<<<<<<< HEAD
 +#else
 +	mnt_add_count(mnt, -1);
 +	if (likely(mnt_get_count(mnt)))
 +		return;
 +	br_write_lock(&vfsmount_lock);
 +#endif
 +	if (unlikely(mnt->mnt_pinned)) {
 +		mnt_add_count(mnt, mnt->mnt_pinned + 1);
 +		mnt->mnt_pinned = 0;
 +		br_write_unlock(&vfsmount_lock);
 +		acct_auto_close_mnt(&mnt->mnt);
 +		goto put_again;
 +	}
++=======
+ 	if (unlikely(mnt->mnt.mnt_flags & MNT_DOOMED)) {
+ 		rcu_read_unlock();
+ 		unlock_mount_hash();
+ 		return;
+ 	}
+ 	mnt->mnt.mnt_flags |= MNT_DOOMED;
+ 	rcu_read_unlock();
++>>>>>>> 3064c3563ba4 (death to mnt_pinned)
  
  	list_del(&mnt->mnt_instance);
 -	unlock_mount_hash();
 +	br_write_unlock(&vfsmount_lock);
  
  	/*
  	 * This probably indicates that somebody messed
@@@ -947,25 -1000,15 +963,35 @@@ struct vfsmount *mntget(struct vfsmoun
  }
  EXPORT_SYMBOL(mntget);
  
- void mnt_pin(struct vfsmount *mnt)
+ struct vfsmount *mnt_clone_internal(struct path *path)
  {
++<<<<<<< HEAD
 +	br_write_lock(&vfsmount_lock);
 +	real_mount(mnt)->mnt_pinned++;
 +	br_write_unlock(&vfsmount_lock);
 +}
 +EXPORT_SYMBOL(mnt_pin);
 +
 +void mnt_unpin(struct vfsmount *m)
 +{
 +	struct mount *mnt = real_mount(m);
 +	br_write_lock(&vfsmount_lock);
 +	if (mnt->mnt_pinned) {
 +		mnt_add_count(mnt, 1);
 +		mnt->mnt_pinned--;
 +	}
 +	br_write_unlock(&vfsmount_lock);
 +}
 +EXPORT_SYMBOL(mnt_unpin);
++=======
+ 	struct mount *p;
+ 	p = clone_mnt(real_mount(path->mnt), path->dentry, CL_PRIVATE);
+ 	if (IS_ERR(p))
+ 		return ERR_CAST(p);
+ 	p->mnt.mnt_flags |= MNT_INTERNAL;
+ 	return &p->mnt;
+ }
++>>>>>>> 3064c3563ba4 (death to mnt_pinned)
  
  static inline void mangle(struct seq_file *m, const char *s)
  {
diff --cc kernel/acct.c
index 7ffb48430dba,2e6cf818021d..000000000000
--- a/kernel/acct.c
+++ b/kernel/acct.c
@@@ -147,40 -120,44 +147,49 @@@ static int check_free_space(struct bsd_
  	}
  
  	acct->needcheck = jiffies + ACCT_TIMEOUT*HZ;
 +	res = acct->active;
  out:
 -	return acct->active;
 +	spin_unlock(&acct_lock);
 +	return res;
  }
  
 -static struct bsd_acct_struct *acct_get(struct pid_namespace *ns)
 +static void acct_put(struct bsd_acct_struct *p)
 +{
++<<<<<<< HEAD
 +	spin_lock(&acct_lock);
 +	if (!--p->count)
 +		kfree(p);
 +	spin_unlock(&acct_lock);
 +}
 +
 +static struct bsd_acct_struct *acct_get(struct bsd_acct_struct **p)
  {
  	struct bsd_acct_struct *res;
 +	spin_lock(&acct_lock);
  again:
 -	smp_rmb();
 -	rcu_read_lock();
 -	res = ACCESS_ONCE(ns->bacct);
 -	if (!res) {
 -		rcu_read_unlock();
 -		return NULL;
 -	}
 -	if (!atomic_long_inc_not_zero(&res->pin.count)) {
 -		rcu_read_unlock();
 -		cpu_relax();
 -		goto again;
 -	}
 -	rcu_read_unlock();
 -	mutex_lock(&res->lock);
 -	if (!res->ns) {
 -		mutex_unlock(&res->lock);
 -		pin_put(&res->pin);
 -		goto again;
 +	res = *p;
 +	if (res)
 +		res->count++;
 +	spin_unlock(&acct_lock);
 +	if (res) {
 +		mutex_lock(&res->lock);
 +		if (!res->ns) {
 +			mutex_unlock(&res->lock);
 +			spin_lock(&acct_lock);
 +			if (!--res->count)
 +				kfree(res);
 +			goto again;
 +		}
  	}
  	return res;
 -}
 -
 -static void close_work(struct work_struct *work)
 -{
++=======
+ 	struct bsd_acct_struct *acct = container_of(work, struct bsd_acct_struct, work);
+ 	struct file *file = acct->file;
+ 	if (file->f_op->flush)
+ 		file->f_op->flush(file, NULL);
+ 	__fput_sync(file);
+ 	complete(&acct->done);
++>>>>>>> 3064c3563ba4 (death to mnt_pinned)
  }
  
  static void acct_kill(struct bsd_acct_struct *acct,
@@@ -238,25 -222,39 +248,51 @@@ static int acct_on(struct filename *pat
  		filp_close(file, NULL);
  		return -EIO;
  	}
+ 	internal = mnt_clone_internal(&file->f_path);
+ 	if (IS_ERR(internal)) {
+ 		kfree(acct);
+ 		filp_close(file, NULL);
+ 		return PTR_ERR(internal);
+ 	}
+ 	err = mnt_want_write(internal);
+ 	if (err) {
+ 		mntput(internal);
+ 		kfree(acct);
+ 		filp_close(file, NULL);
+ 		return err;
+ 	}
+ 	mnt = file->f_path.mnt;
+ 	file->f_path.mnt = internal;
  
 -	atomic_long_set(&acct->pin.count, 1);
 -	acct->pin.kill = acct_pin_kill;
 +	acct->count = 1;
  	acct->file = file;
  	acct->needcheck = jiffies;
  	acct->ns = ns;
  	mutex_init(&acct->lock);
++<<<<<<< HEAD
 +	mnt = file->f_path.mnt;
++=======
+ 	mutex_lock_nested(&acct->lock, 1);	/* nobody has seen it yet */
+ 	pin_insert(&acct->pin, mnt);
++>>>>>>> 3064c3563ba4 (death to mnt_pinned)
  
 -	old = acct_get(ns);
 -	if (old)
 +	old = acct_get(&ns->bacct);
 +	if (old) {
  		acct_kill(old, acct);
 -	else
 +	} else {
 +		spin_lock(&acct_lock);
  		ns->bacct = acct;
++<<<<<<< HEAD
 +		mnt_pin(mnt);
 +		list_add(&acct->list, &acct_list);
 +		spin_unlock(&acct_lock);
 +	}
 +	mntput(mnt); /* it's pinned, now give up active reference */
++=======
+ 	mutex_unlock(&acct->lock);
+ 	mnt_drop_write(mnt);
+ 	mntput(mnt);
++>>>>>>> 3064c3563ba4 (death to mnt_pinned)
  	return 0;
  }
  
* Unmerged path fs/mount.h
* Unmerged path fs/namespace.c
diff --git a/include/linux/mount.h b/include/linux/mount.h
index ff7641f32d5f..1daa0f4e7867 100644
--- a/include/linux/mount.h
+++ b/include/linux/mount.h
@@ -61,6 +61,7 @@ struct vfsmount {
 };
 
 struct file; /* forward dec */
+struct path;
 
 extern int mnt_want_write(struct vfsmount *mnt);
 extern int mnt_want_write_file(struct file *file);
@@ -69,8 +70,7 @@ extern void mnt_drop_write(struct vfsmount *mnt);
 extern void mnt_drop_write_file(struct file *file);
 extern void mntput(struct vfsmount *mnt);
 extern struct vfsmount *mntget(struct vfsmount *mnt);
-extern void mnt_pin(struct vfsmount *mnt);
-extern void mnt_unpin(struct vfsmount *mnt);
+extern struct vfsmount *mnt_clone_internal(struct path *path);
 extern int __mnt_is_readonly(struct vfsmount *mnt);
 
 struct path;
* Unmerged path kernel/acct.c
