kvm: x86: don't print warning messages for unimplemented msrs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Bandan Das <bsd@redhat.com>
commit ae0f5499511e5b1723792c848e44d661d0d4e22f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ae0f5499.failed

Change unimplemented msrs messages to use pr_debug.
If CONFIG_DYNAMIC_DEBUG is set, then these messages can be
enabled at run time or else -DDEBUG can be used at compile
time to enable them. These messages will still be printed if
ignore_msrs=1.

	Signed-off-by: Bandan Das <bsd@redhat.com>
	Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
(cherry picked from commit ae0f5499511e5b1723792c848e44d661d0d4e22f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
#	include/linux/kvm_host.h
diff --cc arch/x86/kvm/x86.c
index ae62c46b426c,6f9c9ad13f88..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -2385,7 -2277,7 +2385,11 @@@ int kvm_set_msr_common(struct kvm_vcpu 
  		if (kvm_pmu_is_valid_msr(vcpu, msr))
  			return kvm_pmu_set_msr(vcpu, msr_info);
  		if (!ignore_msrs) {
++<<<<<<< HEAD
 +			vcpu_unimpl(vcpu, "unhandled wrmsr: 0x%x data %llx\n",
++=======
+ 			vcpu_debug_ratelimited(vcpu, "unhandled wrmsr: 0x%x data 0x%llx\n",
++>>>>>>> ae0f5499511e (kvm: x86: don't print warning messages for unimplemented msrs)
  				    msr, data);
  			return 1;
  		} else {
diff --cc include/linux/kvm_host.h
index b42a4bf67232,274bf343cbd0..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -437,6 -453,11 +440,14 @@@ struct kvm 
  
  #define vcpu_debug(vcpu, fmt, ...)					\
  	kvm_debug("vcpu%i " fmt, (vcpu)->vcpu_id, ## __VA_ARGS__)
++<<<<<<< HEAD
++=======
+ #define vcpu_debug_ratelimited(vcpu, fmt, ...)				\
+ 	kvm_debug_ratelimited("vcpu%i " fmt, (vcpu)->vcpu_id,           \
+ 			      ## __VA_ARGS__)
+ #define vcpu_err(vcpu, fmt, ...)					\
+ 	kvm_err("vcpu%i " fmt, (vcpu)->vcpu_id, ## __VA_ARGS__)
++>>>>>>> ae0f5499511e (kvm: x86: don't print warning messages for unimplemented msrs)
  
  static inline struct kvm_vcpu *kvm_get_vcpu(struct kvm *kvm, int i)
  {
diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c
index 70c3ecb68058..90b58087ea73 100644
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@ -4884,7 +4884,7 @@ void kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm, struct kvm_memslots *slots)
 	 * zap all shadow pages.
 	 */
 	if (unlikely((slots->generation & MMIO_GEN_MASK) == 0)) {
-		printk_ratelimited(KERN_DEBUG "kvm: zapping shadow pages for mmio generation wraparound\n");
+		kvm_debug_ratelimited("kvm: zapping shadow pages for mmio generation wraparound\n");
 		kvm_mmu_invalidate_zap_all_pages(kvm);
 	}
 }
* Unmerged path arch/x86/kvm/x86.c
* Unmerged path include/linux/kvm_host.h
