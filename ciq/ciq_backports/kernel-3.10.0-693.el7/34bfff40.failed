amd-xgbe: Support defining PHY resources in ETH device node

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit 34bfff404ca2eb2f0e60f82f301ad6abcdd22150
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/34bfff40.failed

Simplify the device tree support of the amd-xgbe driver by defining
the PHY-related resources within the ethernet device node. The support
provides backwards compatibility with the original way.

Update the driver version to 1.0.2.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 34bfff404ca2eb2f0e60f82f301ad6abcdd22150)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/devicetree/bindings/net/amd-xgbe.txt
#	drivers/net/ethernet/amd/xgbe/xgbe-main.c
#	drivers/net/ethernet/amd/xgbe/xgbe.h
diff --cc Documentation/devicetree/bindings/net/amd-xgbe.txt
index f6db1ba87a3f,4bb624a73b54..000000000000
--- a/Documentation/devicetree/bindings/net/amd-xgbe.txt
+++ b/Documentation/devicetree/bindings/net/amd-xgbe.txt
@@@ -5,31 -5,73 +5,96 @@@ Required properties
  - reg: Address and length of the register sets for the device
     - MAC registers
     - PCS registers
+    - SerDes Rx/Tx registers
+    - SerDes integration registers (1/2)
+    - SerDes integration registers (2/2)
  - interrupt-parent: Should be the phandle for the interrupt controller
    that services interrupts for this device
++<<<<<<< HEAD
 +- interrupts: Should contain the amd-xgbe interrupt
 +- clocks: Should be the DMA clock for the amd-xgbe device (used for
 +  calculating the correct Rx interrupt watchdog timer value on a DMA
 +  channel for coalescing)
 +- clock-names: Should be the name of the DMA clock, "dma_clk"
 +- phy-handle: See ethernet.txt file in the same directory
++=======
+ - interrupts: Should contain the amd-xgbe interrupt(s). The first interrupt
+   listed is required and is the general device interrupt. If the optional
+   amd,per-channel-interrupt property is specified, then one additional
+   interrupt for each DMA channel supported by the device should be specified.
+   The last interrupt listed should be the PCS auto-negotiation interrupt.
+ - clocks:
+    - DMA clock for the amd-xgbe device (used for calculating the
+      correct Rx interrupt watchdog timer value on a DMA channel
+      for coalescing)
+    - PTP clock for the amd-xgbe device
+ - clock-names: Should be the names of the clocks
+    - "dma_clk" for the DMA clock
+    - "ptp_clk" for the PTP clock
++>>>>>>> 34bfff404ca2 (amd-xgbe: Support defining PHY resources in ETH device node)
  - phy-mode: See ethernet.txt file in the same directory
  
  Optional properties:
  - mac-address: mac address to be assigned to the device. Can be overridden
    by UEFI.
  - dma-coherent: Present if dma operations are coherent
++<<<<<<< HEAD
++=======
+ - amd,per-channel-interrupt: Indicates that Rx and Tx complete will generate
+   a unique interrupt for each DMA channel - this requires an additional
+   interrupt be configured for each DMA channel
+ - amd,speed-set: Speed capabilities of the device
+     0 - 1GbE and 10GbE (default)
+     1 - 2.5GbE and 10GbE
+ 
+ The following optional properties are represented by an array with each
+ value corresponding to a particular speed. The first array value represents
+ the setting for the 1GbE speed, the second value for the 2.5GbE speed and
+ the third value for the 10GbE speed.  All three values are required if the
+ property is used.
+ - amd,serdes-blwc: Baseline wandering correction enablement
+     0 - Off
+     1 - On
+ - amd,serdes-cdr-rate: CDR rate speed selection
+ - amd,serdes-pq-skew: PQ (data sampling) skew
+ - amd,serdes-tx-amp: TX amplitude boost
+ - amd,serdes-dfe-tap-config: DFE taps available to run
+ - amd,serdes-dfe-tap-enable: DFE taps to enable
++>>>>>>> 34bfff404ca2 (amd-xgbe: Support defining PHY resources in ETH device node)
  
  Example:
  	xgbe@e0700000 {
  		compatible = "amd,xgbe-seattle-v1a";
  		reg = <0 0xe0700000 0 0x80000>,
++<<<<<<< HEAD
 +		      <0 0xe0780000 0 0x80000>;
 +		interrupt-parent = <&gic>;
 +		interrupts = <0 325 4>;
 +		clocks = <&xgbe_clk>;
 +		clock-names = "dma_clk";
 +		phy-handle = <&phy>;
 +		phy-mode = "xgmii";
 +		mac-address = [ 02 a1 a2 a3 a4 a5 ];
++=======
+ 		      <0 0xe0780000 0 0x80000>,
+ 		      <0 0xe1240800 0 0x00400>,
+ 		      <0 0xe1250000 0 0x00060>,
+ 		      <0 0xe1250080 0 0x00004>;
+ 		interrupt-parent = <&gic>;
+ 		interrupts = <0 325 4>,
+ 			     <0 326 1>, <0 327 1>, <0 328 1>, <0 329 1>,
+ 			     <0 323 4>;
+ 		amd,per-channel-interrupt;
+ 		clocks = <&xgbe_dma_clk>, <&xgbe_ptp_clk>;
+ 		clock-names = "dma_clk", "ptp_clk";
+ 		phy-mode = "xgmii";
+ 		mac-address = [ 02 a1 a2 a3 a4 a5 ];
+ 		amd,speed-set = <0>;
+ 		amd,serdes-blwc = <1>, <1>, <0>;
+ 		amd,serdes-cdr-rate = <2>, <2>, <7>;
+ 		amd,serdes-pq-skew = <10>, <10>, <30>;
+ 		amd,serdes-tx-amp = <15>, <15>, <10>;
+ 		amd,serdes-dfe-tap-config = <3>, <3>, <1>;
+ 		amd,serdes-dfe-tap-enable = <0>, <0>, <127>;
++>>>>>>> 34bfff404ca2 (amd-xgbe: Support defining PHY resources in ETH device node)
  	};
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-main.c
index 51cdca78ec38,34c521d8b578..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-main.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-main.c
@@@ -217,6 -208,157 +217,159 @@@ static void xgbe_init_all_fptrs(struct 
  	xgbe_init_function_ptrs_desc(&pdata->desc_if);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ACPI
+ static int xgbe_acpi_support(struct xgbe_prv_data *pdata)
+ {
+ 	struct acpi_device *adev = pdata->adev;
+ 	struct device *dev = pdata->dev;
+ 	u32 property;
+ 	acpi_handle handle;
+ 	acpi_status status;
+ 	unsigned long long data;
+ 	int cca;
+ 	int ret;
+ 
+ 	/* Obtain the system clock setting */
+ 	ret = device_property_read_u32(dev, XGBE_ACPI_DMA_FREQ, &property);
+ 	if (ret) {
+ 		dev_err(dev, "unable to obtain %s property\n",
+ 			XGBE_ACPI_DMA_FREQ);
+ 		return ret;
+ 	}
+ 	pdata->sysclk_rate = property;
+ 
+ 	/* Obtain the PTP clock setting */
+ 	ret = device_property_read_u32(dev, XGBE_ACPI_PTP_FREQ, &property);
+ 	if (ret) {
+ 		dev_err(dev, "unable to obtain %s property\n",
+ 			XGBE_ACPI_PTP_FREQ);
+ 		return ret;
+ 	}
+ 	pdata->ptpclk_rate = property;
+ 
+ 	/* Retrieve the device cache coherency value */
+ 	handle = adev->handle;
+ 	do {
+ 		status = acpi_evaluate_integer(handle, "_CCA", NULL, &data);
+ 		if (!ACPI_FAILURE(status)) {
+ 			cca = data;
+ 			break;
+ 		}
+ 
+ 		status = acpi_get_parent(handle, &handle);
+ 	} while (!ACPI_FAILURE(status));
+ 
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_err(dev, "error obtaining acpi coherency value\n");
+ 		return -EINVAL;
+ 	}
+ 	pdata->coherent = !!cca;
+ 
+ 	return 0;
+ }
+ #else   /* CONFIG_ACPI */
+ static int xgbe_acpi_support(struct xgbe_prv_data *pdata)
+ {
+ 	return -EINVAL;
+ }
+ #endif  /* CONFIG_ACPI */
+ 
+ #ifdef CONFIG_OF
+ static int xgbe_of_support(struct xgbe_prv_data *pdata)
+ {
+ 	struct device *dev = pdata->dev;
+ 
+ 	/* Obtain the system clock setting */
+ 	pdata->sysclk = devm_clk_get(dev, XGBE_DMA_CLOCK);
+ 	if (IS_ERR(pdata->sysclk)) {
+ 		dev_err(dev, "dma devm_clk_get failed\n");
+ 		return PTR_ERR(pdata->sysclk);
+ 	}
+ 	pdata->sysclk_rate = clk_get_rate(pdata->sysclk);
+ 
+ 	/* Obtain the PTP clock setting */
+ 	pdata->ptpclk = devm_clk_get(dev, XGBE_PTP_CLOCK);
+ 	if (IS_ERR(pdata->ptpclk)) {
+ 		dev_err(dev, "ptp devm_clk_get failed\n");
+ 		return PTR_ERR(pdata->ptpclk);
+ 	}
+ 	pdata->ptpclk_rate = clk_get_rate(pdata->ptpclk);
+ 
+ 	/* Retrieve the device cache coherency value */
+ 	pdata->coherent = of_dma_is_coherent(dev->of_node);
+ 
+ 	return 0;
+ }
+ 
+ static struct platform_device *xgbe_of_get_phy_pdev(struct xgbe_prv_data *pdata)
+ {
+ 	struct device *dev = pdata->dev;
+ 	struct device_node *phy_node;
+ 	struct platform_device *phy_pdev;
+ 
+ 	phy_node = of_parse_phandle(dev->of_node, "phy-handle", 0);
+ 	if (phy_node) {
+ 		/* Old style device tree:
+ 		 *   The XGBE and PHY resources are separate
+ 		 */
+ 		phy_pdev = of_find_device_by_node(phy_node);
+ 		of_node_put(phy_node);
+ 	} else {
+ 		/* New style device tree:
+ 		 *   The XGBE and PHY resources are grouped together with
+ 		 *   the PHY resources listed last
+ 		 */
+ 		get_device(dev);
+ 		phy_pdev = pdata->pdev;
+ 	}
+ 
+ 	return phy_pdev;
+ }
+ #else   /* CONFIG_OF */
+ static int xgbe_of_support(struct xgbe_prv_data *pdata)
+ {
+ 	return -EINVAL;
+ }
+ 
+ static struct platform_device *xgbe_of_get_phy_pdev(struct xgbe_prv_data *pdata)
+ {
+ 	return NULL;
+ }
+ #endif  /* CONFIG_OF */
+ 
+ static unsigned int xgbe_resource_count(struct platform_device *pdev,
+ 					unsigned int type)
+ {
+ 	unsigned int count;
+ 	int i;
+ 
+ 	for (i = 0, count = 0; i < pdev->num_resources; i++) {
+ 		struct resource *res = &pdev->resource[i];
+ 
+ 		if (type == resource_type(res))
+ 			count++;
+ 	}
+ 
+ 	return count;
+ }
+ 
+ static struct platform_device *xgbe_get_phy_pdev(struct xgbe_prv_data *pdata)
+ {
+ 	struct platform_device *phy_pdev;
+ 
+ 	if (pdata->use_acpi) {
+ 		get_device(pdata->dev);
+ 		phy_pdev = pdata->pdev;
+ 	} else {
+ 		phy_pdev = xgbe_of_get_phy_pdev(pdata);
+ 	}
+ 
+ 	return phy_pdev;
+ }
+ 
++>>>>>>> 34bfff404ca2 (amd-xgbe: Support defining PHY resources in ETH device node)
  static int xgbe_probe(struct platform_device *pdev)
  {
  	struct xgbe_prv_data *pdata;
@@@ -246,6 -389,38 +399,41 @@@
  
  	spin_lock_init(&pdata->lock);
  	mutex_init(&pdata->xpcs_mutex);
++<<<<<<< HEAD
++=======
+ 	mutex_init(&pdata->rss_mutex);
+ 	spin_lock_init(&pdata->tstamp_lock);
+ 
+ 	pdata->msg_enable = netif_msg_init(debug, default_msg_level);
+ 
+ 	set_bit(XGBE_DOWN, &pdata->dev_state);
+ 
+ 	/* Check if we should use ACPI or DT */
+ 	pdata->use_acpi = (!pdata->adev || acpi_disabled) ? 0 : 1;
+ 
+ 	phy_pdev = xgbe_get_phy_pdev(pdata);
+ 	if (!phy_pdev) {
+ 		dev_err(dev, "unable to obtain phy device\n");
+ 		ret = -EINVAL;
+ 		goto err_phydev;
+ 	}
+ 	phy_dev = &phy_pdev->dev;
+ 
+ 	if (pdev == phy_pdev) {
+ 		/* New style device tree or ACPI:
+ 		 *   The XGBE and PHY resources are grouped together with
+ 		 *   the PHY resources listed last
+ 		 */
+ 		phy_memnum = xgbe_resource_count(pdev, IORESOURCE_MEM) - 3;
+ 		phy_irqnum = xgbe_resource_count(pdev, IORESOURCE_IRQ) - 1;
+ 	} else {
+ 		/* Old style device tree:
+ 		 *   The XGBE and PHY resources are separate
+ 		 */
+ 		phy_memnum = 0;
+ 		phy_irqnum = 0;
+ 	}
++>>>>>>> 34bfff404ca2 (amd-xgbe: Support defining PHY resources in ETH device node)
  
  	/* Set and validate the number of descriptors for a ring */
  	BUILD_BUG_ON_NOT_POWER_OF_2(XGBE_TX_DESC_CNT);
diff --cc drivers/net/ethernet/amd/xgbe/xgbe.h
index 1903f878545a,f535d19da803..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@@ -121,10 -121,15 +121,14 @@@
  #include <linux/netdevice.h>
  #include <linux/workqueue.h>
  #include <linux/phy.h>
 -#include <linux/if_vlan.h>
 -#include <linux/bitops.h>
 -#include <linux/ptp_clock_kernel.h>
 -#include <linux/timecounter.h>
 -#include <linux/net_tstamp.h>
 -#include <net/dcbnl.h>
 +
  
  #define XGBE_DRV_NAME		"amd-xgbe"
++<<<<<<< HEAD
 +#define XGBE_DRV_VERSION	"1.0.0-a"
++=======
+ #define XGBE_DRV_VERSION	"1.0.2"
++>>>>>>> 34bfff404ca2 (amd-xgbe: Support defining PHY resources in ETH device node)
  #define XGBE_DRV_DESC		"AMD 10 Gigabit Ethernet Driver"
  
  /* Descriptor related defines */
* Unmerged path Documentation/devicetree/bindings/net/amd-xgbe.txt
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-main.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe.h
