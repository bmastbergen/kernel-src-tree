crash: move crashkernel parsing and vmcore related code under CONFIG_CRASH_CORE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Hari Bathini <hbathini@linux.vnet.ibm.com>
commit 692f66f26a4c19d73249736aa973c13a1521b387
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/692f66f2.failed

Patch series "kexec/fadump: remove dependency with CONFIG_KEXEC and
reuse crashkernel parameter for fadump", v4.

Traditionally, kdump is used to save vmcore in case of a crash.  Some
architectures like powerpc can save vmcore using architecture specific
support instead of kexec/kdump mechanism.  Such architecture specific
support also needs to reserve memory, to be used by dump capture kernel.
crashkernel parameter can be a reused, for memory reservation, by such
architecture specific infrastructure.

This patchset removes dependency with CONFIG_KEXEC for crashkernel
parameter and vmcoreinfo related code as it can be reused without kexec
support.  Also, crashkernel parameter is reused instead of
fadump_reserve_mem to reserve memory for fadump.

The first patch moves crashkernel parameter parsing and vmcoreinfo
related code under CONFIG_CRASH_CORE instead of CONFIG_KEXEC_CORE.  The
second patch reuses the definitions of append_elf_note() & final_note()
functions under CONFIG_CRASH_CORE in IA64 arch code.  The third patch
removes dependency on CONFIG_KEXEC for firmware-assisted dump (fadump)
in powerpc.  The next patch reuses crashkernel parameter for reserving
memory for fadump, instead of the fadump_reserve_mem parameter.  This
has the advantage of using all syntaxes crashkernel parameter supports,
for fadump as well.  The last patch updates fadump kernel documentation
about use of crashkernel parameter.

This patch (of 5):

Traditionally, kdump is used to save vmcore in case of a crash.  Some
architectures like powerpc can save vmcore using architecture specific
support instead of kexec/kdump mechanism.  Such architecture specific
support also needs to reserve memory, to be used by dump capture kernel.
crashkernel parameter can be a reused, for memory reservation, by such
architecture specific infrastructure.

But currently, code related to vmcoreinfo and parsing of crashkernel
parameter is built under CONFIG_KEXEC_CORE.  This patch introduces
CONFIG_CRASH_CORE and moves the above mentioned code under this config,
allowing code reuse without dependency on CONFIG_KEXEC.  There is no
functional change with this patch.

Link: http://lkml.kernel.org/r/149035338104.6881.4550894432615189948.stgit@hbathini.in.ibm.com
	Signed-off-by: Hari Bathini <hbathini@linux.vnet.ibm.com>
	Acked-by: Dave Young <dyoung@redhat.com>
	Cc: Fenghua Yu <fenghua.yu@intel.com>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Eric Biederman <ebiederm@xmission.com>
	Cc: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
	Cc: Vivek Goyal <vgoyal@redhat.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 692f66f26a4c19d73249736aa973c13a1521b387)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/Kconfig
#	include/linux/kexec.h
#	include/linux/printk.h
#	kernel/Makefile
#	kernel/kexec_core.c
#	kernel/ksysfs.c
#	kernel/printk.c
diff --cc arch/Kconfig
index a5207995dce3,dcbd462b68b1..000000000000
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@@ -2,6 -2,16 +2,19 @@@
  # General architecture dependent options
  #
  
++<<<<<<< HEAD
++=======
+ config CRASH_CORE
+ 	bool
+ 
+ config KEXEC_CORE
+ 	select CRASH_CORE
+ 	bool
+ 
+ config HAVE_IMA_KEXEC
+ 	bool
+ 
++>>>>>>> 692f66f26a4c (crash: move crashkernel parsing and vmcore related code under CONFIG_CRASH_CORE)
  config OPROFILE
  	tristate "OProfile system profiling"
  	depends on PROFILING
diff --cc include/linux/kexec.h
index 21b70826e398,c9481ebcbc0c..000000000000
--- a/include/linux/kexec.h
+++ b/include/linux/kexec.h
@@@ -1,15 -1,28 +1,31 @@@
  #ifndef LINUX_KEXEC_H
  #define LINUX_KEXEC_H
  
++<<<<<<< HEAD
++=======
+ #define IND_DESTINATION_BIT 0
+ #define IND_INDIRECTION_BIT 1
+ #define IND_DONE_BIT        2
+ #define IND_SOURCE_BIT      3
+ 
+ #define IND_DESTINATION  (1 << IND_DESTINATION_BIT)
+ #define IND_INDIRECTION  (1 << IND_INDIRECTION_BIT)
+ #define IND_DONE         (1 << IND_DONE_BIT)
+ #define IND_SOURCE       (1 << IND_SOURCE_BIT)
+ #define IND_FLAGS (IND_DESTINATION | IND_INDIRECTION | IND_DONE | IND_SOURCE)
+ 
+ #if !defined(__ASSEMBLY__)
+ 
+ #include <linux/crash_core.h>
+ #include <asm/io.h>
+ 
++>>>>>>> 692f66f26a4c (crash: move crashkernel parsing and vmcore related code under CONFIG_CRASH_CORE)
  #include <uapi/linux/kexec.h>
  
 -#ifdef CONFIG_KEXEC_CORE
 +#ifdef CONFIG_KEXEC
  #include <linux/list.h>
- #include <linux/linkage.h>
  #include <linux/compat.h>
  #include <linux/ioport.h>
- #include <linux/elfcore.h>
- #include <linux/elf.h>
  #include <linux/module.h>
  #include <asm/kexec.h>
  
@@@ -231,36 -248,8 +243,39 @@@ extern void *kexec_purgatory_get_symbol
  extern void __crash_kexec(struct pt_regs *);
  extern void crash_kexec(struct pt_regs *);
  int kexec_should_crash(struct task_struct *);
 -int kexec_crash_loaded(void);
  void crash_save_cpu(struct pt_regs *regs, int cpu);
++<<<<<<< HEAD
 +void crash_save_vmcoreinfo(void);
 +void crash_map_reserved_pages(void);
 +void crash_unmap_reserved_pages(void);
 +void arch_crash_save_vmcoreinfo(void);
 +__printf(1, 2)
 +void vmcoreinfo_append_str(const char *fmt, ...);
 +unsigned long paddr_vmcoreinfo_note(void);
 +
 +#define VMCOREINFO_OSRELEASE(value) \
 +	vmcoreinfo_append_str("OSRELEASE=%s\n", value)
 +#define VMCOREINFO_PAGESIZE(value) \
 +	vmcoreinfo_append_str("PAGESIZE=%ld\n", value)
 +#define VMCOREINFO_SYMBOL(name) \
 +	vmcoreinfo_append_str("SYMBOL(%s)=%lx\n", #name, (unsigned long)&name)
 +#define VMCOREINFO_SIZE(name) \
 +	vmcoreinfo_append_str("SIZE(%s)=%lu\n", #name, \
 +			      (unsigned long)sizeof(name))
 +#define VMCOREINFO_STRUCT_SIZE(name) \
 +	vmcoreinfo_append_str("SIZE(%s)=%lu\n", #name, \
 +			      (unsigned long)sizeof(struct name))
 +#define VMCOREINFO_OFFSET(name, field) \
 +	vmcoreinfo_append_str("OFFSET(%s.%s)=%lu\n", #name, #field, \
 +			      (unsigned long)offsetof(struct name, field))
 +#define VMCOREINFO_LENGTH(name, value) \
 +	vmcoreinfo_append_str("LENGTH(%s)=%lu\n", #name, (unsigned long)value)
 +#define VMCOREINFO_NUMBER(name) \
 +	vmcoreinfo_append_str("NUMBER(%s)=%ld\n", #name, (long)name)
 +#define VMCOREINFO_CONFIG(name) \
 +	vmcoreinfo_append_str("CONFIG_%s=y\n", #name)
++=======
++>>>>>>> 692f66f26a4c (crash: move crashkernel parsing and vmcore related code under CONFIG_CRASH_CORE)
  
  extern struct kimage *kexec_image;
  extern struct kimage *kexec_crash_image;
diff --cc include/linux/printk.h
index 305515986f8e,e10f27468322..000000000000
--- a/include/linux/printk.h
+++ b/include/linux/printk.h
@@@ -145,15 -190,22 +145,21 @@@ extern int printk_delay_msec
  extern int dmesg_restrict;
  extern int kptr_restrict;
  
 -extern int
 -devkmsg_sysctl_set_loglvl(struct ctl_table *table, int write, void __user *buf,
 -			  size_t *lenp, loff_t *ppos);
 -
  extern void wake_up_klogd(void);
  
++<<<<<<< HEAD
 +typedef int(*printk_func_t)(const char *fmt, va_list args);
 +
 +void log_buf_kexec_setup(void);
++=======
+ char *log_buf_addr_get(void);
+ u32 log_buf_len_get(void);
+ void log_buf_vmcoreinfo_setup(void);
++>>>>>>> 692f66f26a4c (crash: move crashkernel parsing and vmcore related code under CONFIG_CRASH_CORE)
  void __init setup_log_buf(int early);
 -__printf(1, 2) void dump_stack_set_arch_desc(const char *fmt, ...);
 +void dump_stack_set_arch_desc(const char *fmt, ...);
  void dump_stack_print_info(const char *log_lvl);
  void show_regs_print_info(const char *log_lvl);
 -extern void printk_safe_init(void);
 -extern void printk_safe_flush(void);
 -extern void printk_safe_flush_on_panic(void);
  #else
  static inline __printf(1, 0)
  int vprintk(const char *s, va_list args)
@@@ -184,7 -236,17 +190,21 @@@ static inline void wake_up_klogd(void
  {
  }
  
++<<<<<<< HEAD
 +static inline void log_buf_kexec_setup(void)
++=======
+ static inline char *log_buf_addr_get(void)
+ {
+ 	return NULL;
+ }
+ 
+ static inline u32 log_buf_len_get(void)
+ {
+ 	return 0;
+ }
+ 
+ static inline void log_buf_vmcoreinfo_setup(void)
++>>>>>>> 692f66f26a4c (crash: move crashkernel parsing and vmcore related code under CONFIG_CRASH_CORE)
  {
  }
  
diff --cc kernel/Makefile
index c7912dcc7638,72aa080f91f0..000000000000
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@@ -49,23 -54,18 +49,28 @@@ obj-$(CONFIG_SMP) += smp.
  ifneq ($(CONFIG_SMP),y)
  obj-y += up.o
  endif
 +obj-$(CONFIG_SMP) += spinlock.o
 +obj-$(CONFIG_DEBUG_SPINLOCK) += spinlock.o
 +obj-$(CONFIG_PROVE_LOCKING) += spinlock.o
  obj-$(CONFIG_UID16) += uid16.o
 +obj-$(CONFIG_SYSTEM_TRUSTED_KEYRING) += system_keyring.o system_certificates.o
  obj-$(CONFIG_MODULES) += module.o
  obj-$(CONFIG_MODULE_SIG) += module_signing.o
 +obj-$(CONFIG_MODULE_SIG_UEFI) += modsign_uefi.o
  obj-$(CONFIG_KALLSYMS) += kallsyms.o
  obj-$(CONFIG_BSD_PROCESS_ACCT) += acct.o
++<<<<<<< HEAD
++=======
+ obj-$(CONFIG_CRASH_CORE) += crash_core.o
+ obj-$(CONFIG_KEXEC_CORE) += kexec_core.o
++>>>>>>> 692f66f26a4c (crash: move crashkernel parsing and vmcore related code under CONFIG_CRASH_CORE)
  obj-$(CONFIG_KEXEC) += kexec.o
 -obj-$(CONFIG_KEXEC_FILE) += kexec_file.o
  obj-$(CONFIG_BACKTRACE_SELF_TEST) += backtracetest.o
  obj-$(CONFIG_COMPAT) += compat.o
 -obj-$(CONFIG_CGROUPS) += cgroup/
 +obj-$(CONFIG_CGROUPS) += cgroup.o
 +obj-$(CONFIG_CGROUP_FREEZER) += cgroup_freezer.o
 +obj-$(CONFIG_CGROUP_PIDS) += cgroup_pids.o
 +obj-$(CONFIG_CPUSETS) += cpuset.o
  obj-$(CONFIG_UTS_NS) += utsname.o
  obj-$(CONFIG_USER_NS) += user_namespace.o
  obj-$(CONFIG_PID_NS) += pid_namespace.o
diff --cc kernel/ksysfs.c
index 6ada93c23a9a,23cd70651238..000000000000
--- a/kernel/ksysfs.c
+++ b/kernel/ksysfs.c
@@@ -130,7 -138,7 +134,11 @@@ static ssize_t vmcoreinfo_show(struct k
  }
  KERNEL_ATTR_RO(vmcoreinfo);
  
++<<<<<<< HEAD
 +#endif /* CONFIG_KEXEC */
++=======
+ #endif /* CONFIG_CRASH_CORE */
++>>>>>>> 692f66f26a4c (crash: move crashkernel parsing and vmcore related code under CONFIG_CRASH_CORE)
  
  /* whether file capabilities are enabled */
  static ssize_t fscaps_show(struct kobject *kobj,
@@@ -194,9 -223,14 +202,11 @@@ static struct attribute * kernel_attrs[
  	&kexec_loaded_attr.attr,
  	&kexec_crash_loaded_attr.attr,
  	&kexec_crash_size_attr.attr,
+ #endif
+ #ifdef CONFIG_CRASH_CORE
  	&vmcoreinfo_attr.attr,
  #endif
 -#ifndef CONFIG_TINY_RCU
  	&rcu_expedited_attr.attr,
 -	&rcu_normal_attr.attr,
 -#endif
  	NULL
  };
  
diff --cc kernel/printk.c
index a82a80b98ce6,fb2d1591f671..000000000000
--- a/kernel/printk.c
+++ b/kernel/printk.c
@@@ -32,9 -31,8 +32,9 @@@
  #include <linux/security.h>
  #include <linux/bootmem.h>
  #include <linux/memblock.h>
 +#include <linux/aio.h>
  #include <linux/syscalls.h>
- #include <linux/kexec.h>
+ #include <linux/crash_core.h>
  #include <linux/kdb.h>
  #include <linux/ratelimit.h>
  #include <linux/kmsg_dump.h>
@@@ -718,11 -1002,11 +718,15 @@@ const struct file_operations kmsg_fops 
  	.release = devkmsg_release,
  };
  
++<<<<<<< HEAD:kernel/printk.c
 +#ifdef CONFIG_KEXEC
++=======
+ #ifdef CONFIG_CRASH_CORE
++>>>>>>> 692f66f26a4c (crash: move crashkernel parsing and vmcore related code under CONFIG_CRASH_CORE):kernel/printk/printk.c
  /*
 - * This appends the listed symbols to /proc/vmcore
 + * This appends the listed symbols to /proc/vmcoreinfo
   *
 - * /proc/vmcore is used by various utilities, like crash and makedumpfile to
 + * /proc/vmcoreinfo is used by various utiilties, like crash and makedumpfile to
   * obtain access to symbols that are otherwise very difficult to locate.  These
   * symbols are specifically used so that utilities can access and extract the
   * dmesg log from a vmcore file after a crash.
* Unmerged path kernel/kexec_core.c
* Unmerged path arch/Kconfig
diff --git a/include/linux/crash_core.h b/include/linux/crash_core.h
new file mode 100644
index 000000000000..18d0f946fda3
--- /dev/null
+++ b/include/linux/crash_core.h
@@ -0,0 +1,65 @@
+#ifndef LINUX_CRASH_CORE_H
+#define LINUX_CRASH_CORE_H
+
+#include <linux/linkage.h>
+#include <linux/elfcore.h>
+#include <linux/elf.h>
+
+#define CRASH_CORE_NOTE_NAME	   "CORE"
+#define CRASH_CORE_NOTE_HEAD_BYTES ALIGN(sizeof(struct elf_note), 4)
+#define CRASH_CORE_NOTE_NAME_BYTES ALIGN(sizeof(CRASH_CORE_NOTE_NAME), 4)
+#define CRASH_CORE_NOTE_DESC_BYTES ALIGN(sizeof(struct elf_prstatus), 4)
+
+#define CRASH_CORE_NOTE_BYTES	   ((CRASH_CORE_NOTE_HEAD_BYTES * 2) +	\
+				     CRASH_CORE_NOTE_NAME_BYTES +	\
+				     CRASH_CORE_NOTE_DESC_BYTES)
+
+#define VMCOREINFO_BYTES	   (4096)
+#define VMCOREINFO_NOTE_NAME	   "VMCOREINFO"
+#define VMCOREINFO_NOTE_NAME_BYTES ALIGN(sizeof(VMCOREINFO_NOTE_NAME), 4)
+#define VMCOREINFO_NOTE_SIZE	   ((CRASH_CORE_NOTE_HEAD_BYTES * 2) +	\
+				     VMCOREINFO_NOTE_NAME_BYTES +	\
+				     VMCOREINFO_BYTES)
+
+typedef u32 note_buf_t[CRASH_CORE_NOTE_BYTES/4];
+
+void crash_save_vmcoreinfo(void);
+void arch_crash_save_vmcoreinfo(void);
+__printf(1, 2)
+void vmcoreinfo_append_str(const char *fmt, ...);
+phys_addr_t paddr_vmcoreinfo_note(void);
+
+#define VMCOREINFO_OSRELEASE(value) \
+	vmcoreinfo_append_str("OSRELEASE=%s\n", value)
+#define VMCOREINFO_PAGESIZE(value) \
+	vmcoreinfo_append_str("PAGESIZE=%ld\n", value)
+#define VMCOREINFO_SYMBOL(name) \
+	vmcoreinfo_append_str("SYMBOL(%s)=%lx\n", #name, (unsigned long)&name)
+#define VMCOREINFO_SIZE(name) \
+	vmcoreinfo_append_str("SIZE(%s)=%lu\n", #name, \
+			      (unsigned long)sizeof(name))
+#define VMCOREINFO_STRUCT_SIZE(name) \
+	vmcoreinfo_append_str("SIZE(%s)=%lu\n", #name, \
+			      (unsigned long)sizeof(struct name))
+#define VMCOREINFO_OFFSET(name, field) \
+	vmcoreinfo_append_str("OFFSET(%s.%s)=%lu\n", #name, #field, \
+			      (unsigned long)offsetof(struct name, field))
+#define VMCOREINFO_LENGTH(name, value) \
+	vmcoreinfo_append_str("LENGTH(%s)=%lu\n", #name, (unsigned long)value)
+#define VMCOREINFO_NUMBER(name) \
+	vmcoreinfo_append_str("NUMBER(%s)=%ld\n", #name, (long)name)
+#define VMCOREINFO_CONFIG(name) \
+	vmcoreinfo_append_str("CONFIG_%s=y\n", #name)
+
+extern u32 vmcoreinfo_note[VMCOREINFO_NOTE_SIZE/4];
+extern size_t vmcoreinfo_size;
+extern size_t vmcoreinfo_max_size;
+
+int __init parse_crashkernel(char *cmdline, unsigned long long system_ram,
+		unsigned long long *crash_size, unsigned long long *crash_base);
+int parse_crashkernel_high(char *cmdline, unsigned long long system_ram,
+		unsigned long long *crash_size, unsigned long long *crash_base);
+int parse_crashkernel_low(char *cmdline, unsigned long long system_ram,
+		unsigned long long *crash_size, unsigned long long *crash_base);
+
+#endif /* LINUX_CRASH_CORE_H */
* Unmerged path include/linux/kexec.h
* Unmerged path include/linux/printk.h
* Unmerged path kernel/Makefile
diff --git a/kernel/crash_core.c b/kernel/crash_core.c
new file mode 100644
index 000000000000..4261587a34d2
--- /dev/null
+++ b/kernel/crash_core.c
@@ -0,0 +1,445 @@
+/*
+ * crash.c - kernel crash support code.
+ * Copyright (C) 2002-2004 Eric Biederman  <ebiederm@xmission.com>
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2.  See the file COPYING for more details.
+ */
+
+#include <linux/crash_core.h>
+#include <linux/utsname.h>
+#include <linux/vmalloc.h>
+
+#include <asm/page.h>
+#include <asm/sections.h>
+
+/* vmcoreinfo stuff */
+static unsigned char vmcoreinfo_data[VMCOREINFO_BYTES];
+u32 vmcoreinfo_note[VMCOREINFO_NOTE_SIZE/4];
+size_t vmcoreinfo_size;
+size_t vmcoreinfo_max_size = sizeof(vmcoreinfo_data);
+
+/*
+ * parsing the "crashkernel" commandline
+ *
+ * this code is intended to be called from architecture specific code
+ */
+
+
+/*
+ * This function parses command lines in the format
+ *
+ *   crashkernel=ramsize-range:size[,...][@offset]
+ *
+ * The function returns 0 on success and -EINVAL on failure.
+ */
+static int __init parse_crashkernel_mem(char *cmdline,
+					unsigned long long system_ram,
+					unsigned long long *crash_size,
+					unsigned long long *crash_base)
+{
+	char *cur = cmdline, *tmp;
+
+	/* for each entry of the comma-separated list */
+	do {
+		unsigned long long start, end = ULLONG_MAX, size;
+
+		/* get the start of the range */
+		start = memparse(cur, &tmp);
+		if (cur == tmp) {
+			pr_warn("crashkernel: Memory value expected\n");
+			return -EINVAL;
+		}
+		cur = tmp;
+		if (*cur != '-') {
+			pr_warn("crashkernel: '-' expected\n");
+			return -EINVAL;
+		}
+		cur++;
+
+		/* if no ':' is here, than we read the end */
+		if (*cur != ':') {
+			end = memparse(cur, &tmp);
+			if (cur == tmp) {
+				pr_warn("crashkernel: Memory value expected\n");
+				return -EINVAL;
+			}
+			cur = tmp;
+			if (end <= start) {
+				pr_warn("crashkernel: end <= start\n");
+				return -EINVAL;
+			}
+		}
+
+		if (*cur != ':') {
+			pr_warn("crashkernel: ':' expected\n");
+			return -EINVAL;
+		}
+		cur++;
+
+		size = memparse(cur, &tmp);
+		if (cur == tmp) {
+			pr_warn("Memory value expected\n");
+			return -EINVAL;
+		}
+		cur = tmp;
+		if (size >= system_ram) {
+			pr_warn("crashkernel: invalid size\n");
+			return -EINVAL;
+		}
+
+		/* match ? */
+		if (system_ram >= start && system_ram < end) {
+			*crash_size = size;
+			break;
+		}
+	} while (*cur++ == ',');
+
+	if (*crash_size > 0) {
+		while (*cur && *cur != ' ' && *cur != '@')
+			cur++;
+		if (*cur == '@') {
+			cur++;
+			*crash_base = memparse(cur, &tmp);
+			if (cur == tmp) {
+				pr_warn("Memory value expected after '@'\n");
+				return -EINVAL;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * That function parses "simple" (old) crashkernel command lines like
+ *
+ *	crashkernel=size[@offset]
+ *
+ * It returns 0 on success and -EINVAL on failure.
+ */
+static int __init parse_crashkernel_simple(char *cmdline,
+					   unsigned long long *crash_size,
+					   unsigned long long *crash_base)
+{
+	char *cur = cmdline;
+
+	*crash_size = memparse(cmdline, &cur);
+	if (cmdline == cur) {
+		pr_warn("crashkernel: memory value expected\n");
+		return -EINVAL;
+	}
+
+	if (*cur == '@')
+		*crash_base = memparse(cur+1, &cur);
+	else if (*cur != ' ' && *cur != '\0') {
+		pr_warn("crashkernel: unrecognized char: %c\n", *cur);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#define SUFFIX_HIGH 0
+#define SUFFIX_LOW  1
+#define SUFFIX_NULL 2
+static __initdata char *suffix_tbl[] = {
+	[SUFFIX_HIGH] = ",high",
+	[SUFFIX_LOW]  = ",low",
+	[SUFFIX_NULL] = NULL,
+};
+
+/*
+ * That function parses "suffix"  crashkernel command lines like
+ *
+ *	crashkernel=size,[high|low]
+ *
+ * It returns 0 on success and -EINVAL on failure.
+ */
+static int __init parse_crashkernel_suffix(char *cmdline,
+					   unsigned long long	*crash_size,
+					   const char *suffix)
+{
+	char *cur = cmdline;
+
+	*crash_size = memparse(cmdline, &cur);
+	if (cmdline == cur) {
+		pr_warn("crashkernel: memory value expected\n");
+		return -EINVAL;
+	}
+
+	/* check with suffix */
+	if (strncmp(cur, suffix, strlen(suffix))) {
+		pr_warn("crashkernel: unrecognized char: %c\n", *cur);
+		return -EINVAL;
+	}
+	cur += strlen(suffix);
+	if (*cur != ' ' && *cur != '\0') {
+		pr_warn("crashkernel: unrecognized char: %c\n", *cur);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static __init char *get_last_crashkernel(char *cmdline,
+			     const char *name,
+			     const char *suffix)
+{
+	char *p = cmdline, *ck_cmdline = NULL;
+
+	/* find crashkernel and use the last one if there are more */
+	p = strstr(p, name);
+	while (p) {
+		char *end_p = strchr(p, ' ');
+		char *q;
+
+		if (!end_p)
+			end_p = p + strlen(p);
+
+		if (!suffix) {
+			int i;
+
+			/* skip the one with any known suffix */
+			for (i = 0; suffix_tbl[i]; i++) {
+				q = end_p - strlen(suffix_tbl[i]);
+				if (!strncmp(q, suffix_tbl[i],
+					     strlen(suffix_tbl[i])))
+					goto next;
+			}
+			ck_cmdline = p;
+		} else {
+			q = end_p - strlen(suffix);
+			if (!strncmp(q, suffix, strlen(suffix)))
+				ck_cmdline = p;
+		}
+next:
+		p = strstr(p+1, name);
+	}
+
+	if (!ck_cmdline)
+		return NULL;
+
+	return ck_cmdline;
+}
+
+static int __init __parse_crashkernel(char *cmdline,
+			     unsigned long long system_ram,
+			     unsigned long long *crash_size,
+			     unsigned long long *crash_base,
+			     const char *name,
+			     const char *suffix)
+{
+	char	*first_colon, *first_space;
+	char	*ck_cmdline;
+
+	BUG_ON(!crash_size || !crash_base);
+	*crash_size = 0;
+	*crash_base = 0;
+
+	ck_cmdline = get_last_crashkernel(cmdline, name, suffix);
+
+	if (!ck_cmdline)
+		return -EINVAL;
+
+	ck_cmdline += strlen(name);
+
+	if (suffix)
+		return parse_crashkernel_suffix(ck_cmdline, crash_size,
+				suffix);
+	/*
+	 * if the commandline contains a ':', then that's the extended
+	 * syntax -- if not, it must be the classic syntax
+	 */
+	first_colon = strchr(ck_cmdline, ':');
+	first_space = strchr(ck_cmdline, ' ');
+	if (first_colon && (!first_space || first_colon < first_space))
+		return parse_crashkernel_mem(ck_cmdline, system_ram,
+				crash_size, crash_base);
+
+	return parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);
+}
+
+/*
+ * That function is the entry point for command line parsing and should be
+ * called from the arch-specific code.
+ */
+int __init parse_crashkernel(char *cmdline,
+			     unsigned long long system_ram,
+			     unsigned long long *crash_size,
+			     unsigned long long *crash_base)
+{
+	return __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,
+					"crashkernel=", NULL);
+}
+
+int __init parse_crashkernel_high(char *cmdline,
+			     unsigned long long system_ram,
+			     unsigned long long *crash_size,
+			     unsigned long long *crash_base)
+{
+	return __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,
+				"crashkernel=", suffix_tbl[SUFFIX_HIGH]);
+}
+
+int __init parse_crashkernel_low(char *cmdline,
+			     unsigned long long system_ram,
+			     unsigned long long *crash_size,
+			     unsigned long long *crash_base)
+{
+	return __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,
+				"crashkernel=", suffix_tbl[SUFFIX_LOW]);
+}
+
+static u32 *append_elf_note(u32 *buf, char *name, unsigned int type,
+			    void *data, size_t data_len)
+{
+	struct elf_note note;
+
+	note.n_namesz = strlen(name) + 1;
+	note.n_descsz = data_len;
+	note.n_type   = type;
+	memcpy(buf, &note, sizeof(note));
+	buf += (sizeof(note) + 3)/4;
+	memcpy(buf, name, note.n_namesz);
+	buf += (note.n_namesz + 3)/4;
+	memcpy(buf, data, note.n_descsz);
+	buf += (note.n_descsz + 3)/4;
+
+	return buf;
+}
+
+static void final_note(u32 *buf)
+{
+	struct elf_note note;
+
+	note.n_namesz = 0;
+	note.n_descsz = 0;
+	note.n_type   = 0;
+	memcpy(buf, &note, sizeof(note));
+}
+
+static void update_vmcoreinfo_note(void)
+{
+	u32 *buf = vmcoreinfo_note;
+
+	if (!vmcoreinfo_size)
+		return;
+	buf = append_elf_note(buf, VMCOREINFO_NOTE_NAME, 0, vmcoreinfo_data,
+			      vmcoreinfo_size);
+	final_note(buf);
+}
+
+void crash_save_vmcoreinfo(void)
+{
+	vmcoreinfo_append_str("CRASHTIME=%ld\n", get_seconds());
+	update_vmcoreinfo_note();
+}
+
+void vmcoreinfo_append_str(const char *fmt, ...)
+{
+	va_list args;
+	char buf[0x50];
+	size_t r;
+
+	va_start(args, fmt);
+	r = vscnprintf(buf, sizeof(buf), fmt, args);
+	va_end(args);
+
+	r = min(r, vmcoreinfo_max_size - vmcoreinfo_size);
+
+	memcpy(&vmcoreinfo_data[vmcoreinfo_size], buf, r);
+
+	vmcoreinfo_size += r;
+}
+
+/*
+ * provide an empty default implementation here -- architecture
+ * code may override this
+ */
+void __weak arch_crash_save_vmcoreinfo(void)
+{}
+
+phys_addr_t __weak paddr_vmcoreinfo_note(void)
+{
+	return __pa_symbol((unsigned long)(char *)&vmcoreinfo_note);
+}
+
+static int __init crash_save_vmcoreinfo_init(void)
+{
+	VMCOREINFO_OSRELEASE(init_uts_ns.name.release);
+	VMCOREINFO_PAGESIZE(PAGE_SIZE);
+
+	VMCOREINFO_SYMBOL(init_uts_ns);
+	VMCOREINFO_SYMBOL(node_online_map);
+#ifdef CONFIG_MMU
+	VMCOREINFO_SYMBOL(swapper_pg_dir);
+#endif
+	VMCOREINFO_SYMBOL(_stext);
+	VMCOREINFO_SYMBOL(vmap_area_list);
+
+#ifndef CONFIG_NEED_MULTIPLE_NODES
+	VMCOREINFO_SYMBOL(mem_map);
+	VMCOREINFO_SYMBOL(contig_page_data);
+#endif
+#ifdef CONFIG_SPARSEMEM
+	VMCOREINFO_SYMBOL(mem_section);
+	VMCOREINFO_LENGTH(mem_section, NR_SECTION_ROOTS);
+	VMCOREINFO_STRUCT_SIZE(mem_section);
+	VMCOREINFO_OFFSET(mem_section, section_mem_map);
+#endif
+	VMCOREINFO_STRUCT_SIZE(page);
+	VMCOREINFO_STRUCT_SIZE(pglist_data);
+	VMCOREINFO_STRUCT_SIZE(zone);
+	VMCOREINFO_STRUCT_SIZE(free_area);
+	VMCOREINFO_STRUCT_SIZE(list_head);
+	VMCOREINFO_SIZE(nodemask_t);
+	VMCOREINFO_OFFSET(page, flags);
+	VMCOREINFO_OFFSET(page, _refcount);
+	VMCOREINFO_OFFSET(page, mapping);
+	VMCOREINFO_OFFSET(page, lru);
+	VMCOREINFO_OFFSET(page, _mapcount);
+	VMCOREINFO_OFFSET(page, private);
+	VMCOREINFO_OFFSET(page, compound_dtor);
+	VMCOREINFO_OFFSET(page, compound_order);
+	VMCOREINFO_OFFSET(page, compound_head);
+	VMCOREINFO_OFFSET(pglist_data, node_zones);
+	VMCOREINFO_OFFSET(pglist_data, nr_zones);
+#ifdef CONFIG_FLAT_NODE_MEM_MAP
+	VMCOREINFO_OFFSET(pglist_data, node_mem_map);
+#endif
+	VMCOREINFO_OFFSET(pglist_data, node_start_pfn);
+	VMCOREINFO_OFFSET(pglist_data, node_spanned_pages);
+	VMCOREINFO_OFFSET(pglist_data, node_id);
+	VMCOREINFO_OFFSET(zone, free_area);
+	VMCOREINFO_OFFSET(zone, vm_stat);
+	VMCOREINFO_OFFSET(zone, spanned_pages);
+	VMCOREINFO_OFFSET(free_area, free_list);
+	VMCOREINFO_OFFSET(list_head, next);
+	VMCOREINFO_OFFSET(list_head, prev);
+	VMCOREINFO_OFFSET(vmap_area, va_start);
+	VMCOREINFO_OFFSET(vmap_area, list);
+	VMCOREINFO_LENGTH(zone.free_area, MAX_ORDER);
+	log_buf_vmcoreinfo_setup();
+	VMCOREINFO_LENGTH(free_area.free_list, MIGRATE_TYPES);
+	VMCOREINFO_NUMBER(NR_FREE_PAGES);
+	VMCOREINFO_NUMBER(PG_lru);
+	VMCOREINFO_NUMBER(PG_private);
+	VMCOREINFO_NUMBER(PG_swapcache);
+	VMCOREINFO_NUMBER(PG_slab);
+#ifdef CONFIG_MEMORY_FAILURE
+	VMCOREINFO_NUMBER(PG_hwpoison);
+#endif
+	VMCOREINFO_NUMBER(PG_head_mask);
+	VMCOREINFO_NUMBER(PAGE_BUDDY_MAPCOUNT_VALUE);
+#ifdef CONFIG_HUGETLB_PAGE
+	VMCOREINFO_NUMBER(HUGETLB_PAGE_DTOR);
+#endif
+
+	arch_crash_save_vmcoreinfo();
+	update_vmcoreinfo_note();
+
+	return 0;
+}
+
+subsys_initcall(crash_save_vmcoreinfo_init);
* Unmerged path kernel/kexec_core.c
* Unmerged path kernel/ksysfs.c
* Unmerged path kernel/printk.c
