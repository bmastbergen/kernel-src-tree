random: limit the contribution of the hw rng to at most half

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit 48d6be955a7167b0d0e025ae6c39e795e3544499
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/48d6be95.failed

For people who don't trust a hardware RNG which can not be audited,
the changes to add support for RDSEED can be troubling since 97% or
more of the entropy will be contributed from the in-CPU hardware RNG.

We now have a in-kernel khwrngd, so for those people who do want to
implicitly trust the CPU-based system, we could create an arch-rng
hw_random driver, and allow khwrng refill the entropy pool.  This
allows system administrator whether or not they trust the CPU (I
assume the NSA will trust RDRAND/RDSEED implicitly :-), and if so,
what level of entropy derating they want to use.

The reason why this is a really good idea is that if different people
use different levels of entropy derating, it will make it much more
difficult to design a backdoor'ed hwrng that can be generally
exploited in terms of the output of /dev/random when different attack
targets are using differing levels of entropy derating.

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit 48d6be955a7167b0d0e025ae6c39e795e3544499)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/random.c
diff --cc drivers/char/random.c
index 0d7813b08ad2,6e455bc4a39e..000000000000
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@@ -890,12 -910,13 +890,18 @@@ void add_interrupt_randomness(int irq, 
  
  	/*
  	 * If we have architectural seed generator, produce a seed and
- 	 * add it to the pool.  For the sake of paranoia count it as
- 	 * 50% entropic.
+ 	 * add it to the pool.  For the sake of paranoia don't let the
+ 	 * architectural seed generator dominate the input from the
+ 	 * interrupt noise.
  	 */
  	if (arch_get_random_seed_long(&seed)) {
++<<<<<<< HEAD
 +		__mix_pool_bytes(r, &seed, sizeof(seed), NULL);
 +		credit += sizeof(seed) * 4;
++=======
+ 		__mix_pool_bytes(r, &seed, sizeof(seed));
+ 		credit = 1;
++>>>>>>> 48d6be955a71 (random: limit the contribution of the hw rng to at most half)
  	}
  	spin_unlock(&r->lock);
  
@@@ -1316,53 -1337,33 +1322,65 @@@ random_read(struct file *file, char __u
  	if (nbytes == 0)
  		return 0;
  
 -	nbytes = min_t(size_t, nbytes, SEC_XFER_SIZE);
 -	while (1) {
 -		n = extract_entropy_user(&blocking_pool, buf, nbytes);
 -		if (n < 0)
 -			return n;
 -		trace_random_read(n*8, (nbytes-n)*8,
 -				  ENTROPY_BITS(&blocking_pool),
 -				  ENTROPY_BITS(&input_pool));
 -		if (n > 0)
 -			return n;
 +	while (nbytes > 0) {
 +		n = nbytes;
 +		if (n > SEC_XFER_SIZE)
 +			n = SEC_XFER_SIZE;
 +
++<<<<<<< HEAD
 +		DEBUG_ENT("reading %zu bits\n", n*8);
 +
 +		n = extract_entropy_user(&blocking_pool, buf, n);
 +
 +		if (n < 0) {
 +			retval = n;
 +			break;
 +		}
 +
 +		DEBUG_ENT("read got %zd bits (%zd still needed)\n",
 +			  n*8, (nbytes-n)*8);
 +
 +		if (n == 0) {
 +			if (file->f_flags & O_NONBLOCK) {
 +				retval = -EAGAIN;
 +				break;
 +			}
 +
 +			DEBUG_ENT("sleeping?\n");
 +
 +			wait_event_interruptible(random_read_wait,
 +				ENTROPY_BITS(&input_pool) >=
 +				random_read_wakeup_thresh);
 +
 +			DEBUG_ENT("awake\n");
 +
 +			if (signal_pending(current)) {
 +				retval = -ERESTARTSYS;
 +				break;
 +			}
 +
 +			continue;
 +		}
  
 +		count += n;
 +		buf += n;
 +		nbytes -= n;
 +		break;		/* This break makes the device work */
 +				/* like a named pipe */
++=======
+ 		/* Pool is (near) empty.  Maybe wait and retry. */
+ 		if (nonblock)
+ 			return -EAGAIN;
+ 
+ 		wait_event_interruptible(random_read_wait,
+ 			ENTROPY_BITS(&input_pool) >=
+ 			random_read_wakeup_bits);
+ 		if (signal_pending(current))
+ 			return -ERESTARTSYS;
++>>>>>>> 48d6be955a71 (random: limit the contribution of the hw rng to at most half)
  	}
 -}
  
 -static ssize_t
 -random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 -{
 -	return _random_read(file->f_flags & O_NONBLOCK, buf, nbytes);
 +	return (count ? count : retval);
  }
  
  static ssize_t
* Unmerged path drivers/char/random.c
