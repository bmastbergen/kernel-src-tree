fq_codel: fix NET_XMIT_CN behavior

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: fq_codel: fix NET_XMIT_CN behavior (Ivan Vecera) [1382040]
Rebuild_FUZZ: 90.67%
commit-author Eric Dumazet <edumazet@google.com>
commit 80e509db54c81247b32fcb75bb1730fc789b893d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/80e509db.failed

My prior attempt to fix the backlogs of parents failed.

If we return NET_XMIT_CN, our parents wont increase their backlog,
so our qdisc_tree_reduce_backlog() should take this into account.

v2: Florian Westphal pointed out that we could drop the packet,
so we need to save qdisc_pkt_len(skb) in a temp variable before
calling fq_codel_drop()

Fixes: 9d18562a2278 ("fq_codel: add batch ability to fq_codel_drop()")
Fixes: 2ccccf5fb43f ("net_sched: update hierarchical backlog too")
	Reported-by: Stas Nichiporovich <stasn77@gmail.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: WANG Cong <xiyou.wangcong@gmail.com>
	Cc: Jamal Hadi Salim <jhs@mojatatu.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 80e509db54c81247b32fcb75bb1730fc789b893d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_fq_codel.c
diff --cc net/sched/sch_fq_codel.c
index 325552fe3cde,fff7867f4a4f..000000000000
--- a/net/sched/sch_fq_codel.c
+++ b/net/sched/sch_fq_codel.c
@@@ -180,9 -196,11 +180,14 @@@ static unsigned int fq_codel_qdisc_drop
  static int fq_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch)
  {
  	struct fq_codel_sched_data *q = qdisc_priv(sch);
 -	unsigned int idx, prev_backlog, prev_qlen;
 +	unsigned int idx;
  	struct fq_codel_flow *flow;
  	int uninitialized_var(ret);
++<<<<<<< HEAD
++=======
+ 	unsigned int pkt_len;
+ 	bool memory_limited;
++>>>>>>> 80e509db54c8 (fq_codel: fix NET_XMIT_CN behavior)
  
  	idx = fq_codel_classify(skb, sch, &ret);
  	if (idx == 0) {
@@@ -205,18 -223,39 +210,49 @@@
  		flow->deficit = q->quantum;
  		flow->dropped = 0;
  	}
 -	q->memory_usage += skb->truesize;
 -	memory_limited = q->memory_usage > q->memory_limit;
 -	if (++sch->q.qlen <= sch->limit && !memory_limited)
 +	if (++sch->q.qlen <= sch->limit)
  		return NET_XMIT_SUCCESS;
  
++<<<<<<< HEAD
 +	q->drop_overlimit++;
 +	/* Return Congestion Notification only if we dropped a packet
 +	 * from this flow.
++=======
+ 	prev_backlog = sch->qstats.backlog;
+ 	prev_qlen = sch->q.qlen;
+ 
+ 	/* save this packet length as it might be dropped by fq_codel_drop() */
+ 	pkt_len = qdisc_pkt_len(skb);
+ 	/* fq_codel_drop() is quite expensive, as it performs a linear search
+ 	 * in q->backlogs[] to find a fat flow.
+ 	 * So instead of dropping a single packet, drop half of its backlog
+ 	 * with a 64 packets limit to not add a too big cpu spike here.
++>>>>>>> 80e509db54c8 (fq_codel: fix NET_XMIT_CN behavior)
  	 */
 -	ret = fq_codel_drop(sch, q->drop_batch_size);
 +	if (fq_codel_drop(sch) == idx)
 +		return NET_XMIT_CN;
  
++<<<<<<< HEAD
 +	/* As we dropped a packet, better let upper stack know this */
 +	qdisc_tree_decrease_qlen(sch, 1);
++=======
+ 	prev_qlen -= sch->q.qlen;
+ 	prev_backlog -= sch->qstats.backlog;
+ 	q->drop_overlimit += prev_qlen;
+ 	if (memory_limited)
+ 		q->drop_overmemory += prev_qlen;
+ 
+ 	/* As we dropped packet(s), better let upper stack know this.
+ 	 * If we dropped a packet for this flow, return NET_XMIT_CN,
+ 	 * but in this case, our parents wont increase their backlogs.
+ 	 */
+ 	if (ret == idx) {
+ 		qdisc_tree_reduce_backlog(sch, prev_qlen - 1,
+ 					  prev_backlog - pkt_len);
+ 		return NET_XMIT_CN;
+ 	}
+ 	qdisc_tree_reduce_backlog(sch, prev_qlen, prev_backlog);
++>>>>>>> 80e509db54c8 (fq_codel: fix NET_XMIT_CN behavior)
  	return NET_XMIT_SUCCESS;
  }
  
* Unmerged path net/sched/sch_fq_codel.c
