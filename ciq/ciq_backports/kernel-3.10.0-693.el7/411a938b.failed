mnt: Delay removal from the mount hash.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] mnt: Delay removal from the mount hash ("Eric W. Biederman") [1247935]
Rebuild_FUZZ: 98.70%
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 411a938b5abc9cb126c41cccf5975ae464fe0f3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/411a938b.failed

- Modify __lookup_mnt_hash_last to ignore mounts that have MNT_UMOUNTED set.
- Don't remove mounts from the mount hash table in propogate_umount
- Don't remove mounts from the mount hash table in umount_tree before
  the entire list of mounts to be umounted is selected.
- Remove mounts from the mount hash table as the last thing that
  happens in the case where a mount has a parent in umount_tree.
  Mounts without parents are not hashed (by definition).

This paves the way for delaying removal from the mount hash table even
farther and fixing the MNT_LOCKED vs MNT_DETACH issue.

	Cc: stable@vger.kernel.org
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 411a938b5abc9cb126c41cccf5975ae464fe0f3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
#	fs/pnode.c
diff --cc fs/namespace.c
index 07e51358b239,083e3401a808..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -568,13 -632,20 +568,30 @@@ struct mount *__lookup_mnt(struct vfsmo
   */
  struct mount *__lookup_mnt_last(struct vfsmount *mnt, struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	struct list_head *head = mount_hashtable + hash(mnt, dentry);
 +	struct mount *p;
 +
 +	list_for_each_entry_reverse(p, head, mnt_hash)
 +		if (&p->mnt_parent->mnt == mnt && p->mnt_mountpoint == dentry)
 +			return p;
 +	return NULL;
++=======
+ 	struct mount *p, *res = NULL;
+ 	p = __lookup_mnt(mnt, dentry);
+ 	if (!p)
+ 		goto out;
+ 	if (!(p->mnt.mnt_flags & MNT_UMOUNT))
+ 		res = p;
+ 	hlist_for_each_entry_continue(p, mnt_hash) {
+ 		if (&p->mnt_parent->mnt != mnt || p->mnt_mountpoint != dentry)
+ 			break;
+ 		if (!(p->mnt.mnt_flags & MNT_UMOUNT))
+ 			res = p;
+ 	}
+ out:
+ 	return res;
++>>>>>>> 411a938b5abc (mnt: Delay removal from the mount hash.)
  }
  
  /*
@@@ -1217,13 -1333,23 +1234,23 @@@ void umount_tree(struct mount *mnt, in
  	LIST_HEAD(tmp_list);
  	struct mount *p;
  
 -	/* Gather the mounts to umount */
 -	for (p = mnt; p; p = next_mnt(p, mnt)) {
 -		p->mnt.mnt_flags |= MNT_UMOUNT;
 -		list_move(&p->mnt_list, &tmp_list);
 -	}
 +	for (p = mnt; p; p = next_mnt(p, mnt))
 +		list_move(&p->mnt_hash, &tmp_list);
  
++<<<<<<< HEAD
 +	if (propagate)
++=======
+ 	/* Hide the mounts from mnt_mounts */
+ 	list_for_each_entry(p, &tmp_list, mnt_list) {
+ 		list_del_init(&p->mnt_child);
+ 	}
+ 
+ 	/* Add propogated mounts to the tmp_list */
+ 	if (how & UMOUNT_PROPAGATE)
++>>>>>>> 411a938b5abc (mnt: Delay removal from the mount hash.)
  		propagate_umount(&tmp_list);
  
 -	while (!list_empty(&tmp_list)) {
 -		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 +	list_for_each_entry(p, &tmp_list, mnt_hash) {
  		list_del_init(&p->mnt_expire);
  		list_del_init(&p->mnt_list);
  		__touch_mnt_namespace(p->mnt_ns);
diff --cc fs/pnode.c
index 4cba0cce1f85,c27ae38ee250..000000000000
--- a/fs/pnode.c
+++ b/fs/pnode.c
@@@ -389,8 -381,11 +389,16 @@@ static void __propagate_umount(struct m
  		 * umount the child only if the child has no
  		 * other children
  		 */
++<<<<<<< HEAD
 +		if (child && list_empty(&child->mnt_mounts))
 +			list_move_tail(&child->mnt_hash, &mnt->mnt_hash);
++=======
+ 		if (child && list_empty(&child->mnt_mounts)) {
+ 			list_del_init(&child->mnt_child);
+ 			child->mnt.mnt_flags |= MNT_UMOUNT;
+ 			list_move_tail(&child->mnt_list, &mnt->mnt_list);
+ 		}
++>>>>>>> 411a938b5abc (mnt: Delay removal from the mount hash.)
  	}
  }
  
* Unmerged path fs/namespace.c
* Unmerged path fs/pnode.c
