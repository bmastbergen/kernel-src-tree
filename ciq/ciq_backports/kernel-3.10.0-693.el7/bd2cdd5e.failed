scsi: lpfc: NVME Initiator: Add debugfs support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] lpfc: NVME Initiator: Add debugfs support (Ewan Milne) [1384922]
Rebuild_FUZZ: 93.18%
commit-author James Smart <jsmart2021@gmail.com>
commit bd2cdd5e400f5914bc30d5cfb0a0185cf51e4424
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/bd2cdd5e.failed

NVME Initiator: Add debugfs support

Adds debugfs snippets to cover the new NVME initiator functionality

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit bd2cdd5e400f5914bc30d5cfb0a0185cf51e4424)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_ct.c
#	drivers/scsi/lpfc/lpfc_debugfs.c
#	drivers/scsi/lpfc/lpfc_nvme.c
#	drivers/scsi/lpfc/lpfc_nvme.h
diff --cc drivers/scsi/lpfc/lpfc_ct.c
index 63e48d4277b0,2c051369857a..000000000000
--- a/drivers/scsi/lpfc/lpfc_ct.c
+++ b/drivers/scsi/lpfc/lpfc_ct.c
@@@ -453,8 -454,90 +453,92 @@@ lpfc_find_vport_by_did(struct lpfc_hba 
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ lpfc_prep_node_fc4type(struct lpfc_vport *vport, uint32_t Did, uint8_t fc4_type)
+ {
+ 	struct lpfc_nodelist *ndlp;
+ 
+ 	if ((vport->port_type != LPFC_NPIV_PORT) ||
+ 	    !(vport->ct_flags & FC_CT_RFF_ID) || !vport->cfg_restrict_login) {
+ 
+ 		ndlp = lpfc_setup_disc_node(vport, Did);
+ 
+ 		if (ndlp && NLP_CHK_NODE_ACT(ndlp)) {
+ 			lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,
+ 				"Parse GID_FTrsp: did:x%x flg:x%x x%x",
+ 				Did, ndlp->nlp_flag, vport->fc_flag);
+ 
+ 			/* By default, the driver expects to support FCP FC4 */
+ 			if (fc4_type == FC_TYPE_FCP)
+ 				ndlp->nlp_fc4_type |= NLP_FC4_FCP;
+ 
+ 			if (fc4_type == FC_TYPE_NVME)
+ 				ndlp->nlp_fc4_type |= NLP_FC4_NVME;
+ 
+ 			lpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,
+ 					 "0238 Process x%06x NameServer Rsp "
+ 					 "Data: x%x x%x x%x x%x\n", Did,
+ 					 ndlp->nlp_flag, ndlp->nlp_fc4_type,
+ 					 vport->fc_flag,
+ 					 vport->fc_rscn_id_cnt);
+ 		} else {
+ 			lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,
+ 				"Skip1 GID_FTrsp: did:x%x flg:x%x cnt:%d",
+ 				Did, vport->fc_flag, vport->fc_rscn_id_cnt);
+ 
+ 			lpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,
+ 					 "0239 Skip x%06x NameServer Rsp "
+ 					 "Data: x%x x%x\n", Did,
+ 					 vport->fc_flag,
+ 					 vport->fc_rscn_id_cnt);
+ 		}
+ 	} else {
+ 		if (!(vport->fc_flag & FC_RSCN_MODE) ||
+ 		    lpfc_rscn_payload_check(vport, Did)) {
+ 			lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,
+ 				"Query GID_FTrsp: did:x%x flg:x%x cnt:%d",
+ 				Did, vport->fc_flag, vport->fc_rscn_id_cnt);
+ 
+ 			/*
+ 			 * This NPortID was previously a FCP target,
+ 			 * Don't even bother to send GFF_ID.
+ 			 */
+ 			ndlp = lpfc_findnode_did(vport, Did);
+ 			if (ndlp && NLP_CHK_NODE_ACT(ndlp))
+ 				ndlp->nlp_fc4_type = fc4_type;
+ 
+ 			if (ndlp && NLP_CHK_NODE_ACT(ndlp)) {
+ 				ndlp->nlp_fc4_type = fc4_type;
+ 
+ 				if (ndlp->nlp_type & NLP_FCP_TARGET)
+ 					lpfc_setup_disc_node(vport, Did);
+ 
+ 				else if (lpfc_ns_cmd(vport, SLI_CTNS_GFF_ID,
+ 							0, Did) == 0)
+ 					vport->num_disc_nodes++;
+ 
+ 				else
+ 					lpfc_setup_disc_node(vport, Did);
+ 			}
+ 		} else {
+ 			lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,
+ 				"Skip2 GID_FTrsp: did:x%x flg:x%x cnt:%d",
+ 				Did, vport->fc_flag, vport->fc_rscn_id_cnt);
+ 
+ 			lpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,
+ 					 "0245 Skip x%06x NameServer Rsp "
+ 					 "Data: x%x x%x\n", Did,
+ 					 vport->fc_flag,
+ 					 vport->fc_rscn_id_cnt);
+ 		}
+ 	}
+ }
+ 
++>>>>>>> bd2cdd5e400f (scsi: lpfc: NVME Initiator: Add debugfs support)
  static int
 -lpfc_ns_rsp(struct lpfc_vport *vport, struct lpfc_dmabuf *mp, uint8_t fc4_type,
 -	    uint32_t Size)
 +lpfc_ns_rsp(struct lpfc_vport *vport, struct lpfc_dmabuf *mp, uint32_t Size)
  {
  	struct lpfc_hba  *phba = vport->phba;
  	struct lpfc_sli_ct_request *Response =
@@@ -881,6 -893,60 +965,63 @@@ out
  	return;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ lpfc_cmpl_ct_cmd_gft_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,
+ 				struct lpfc_iocbq *rspiocb)
+ {
+ 	struct lpfc_vport *vport = cmdiocb->vport;
+ 	IOCB_t *irsp = &rspiocb->iocb;
+ 	struct lpfc_dmabuf *inp = (struct lpfc_dmabuf *)cmdiocb->context1;
+ 	struct lpfc_dmabuf *outp = (struct lpfc_dmabuf *)cmdiocb->context2;
+ 	struct lpfc_sli_ct_request *CTrsp;
+ 	int did;
+ 	struct lpfc_nodelist *ndlp;
+ 	uint32_t fc4_data_0, fc4_data_1;
+ 
+ 	did = ((struct lpfc_sli_ct_request *)inp->virt)->un.gft.PortId;
+ 	did = be32_to_cpu(did);
+ 
+ 	lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,
+ 			      "GFT_ID cmpl: status:x%x/x%x did:x%x",
+ 			      irsp->ulpStatus, irsp->un.ulpWord[4], did);
+ 
+ 	if (irsp->ulpStatus == IOSTAT_SUCCESS) {
+ 		/* Good status, continue checking */
+ 		CTrsp = (struct lpfc_sli_ct_request *)outp->virt;
+ 		fc4_data_0 = be32_to_cpu(CTrsp->un.gft_acc.fc4_types[0]);
+ 		fc4_data_1 = be32_to_cpu(CTrsp->un.gft_acc.fc4_types[1]);
+ 		lpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,
+ 				 "3062 DID x%06x GFT Wd0 x%08x Wd1 x%08x\n",
+ 				 did, fc4_data_0, fc4_data_1);
+ 
+ 		ndlp = lpfc_findnode_did(vport, did);
+ 		if (ndlp) {
+ 			/* The bitmask value for FCP and NVME FCP types is
+ 			 * the same because they are 32 bits distant from
+ 			 * each other in word0 and word0.
+ 			 */
+ 			if (fc4_data_0 & LPFC_FC4_TYPE_BITMASK)
+ 				ndlp->nlp_fc4_type |= NLP_FC4_FCP;
+ 			if (fc4_data_1 &  LPFC_FC4_TYPE_BITMASK)
+ 				ndlp->nlp_fc4_type |= NLP_FC4_NVME;
+ 			lpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,
+ 					 "3064 Setting ndlp %p, DID x%06x with "
+ 					 "FC4 x%08x, Data: x%08x x%08x\n",
+ 					 ndlp, did, ndlp->nlp_fc4_type,
+ 					 FC_TYPE_FCP, FC_TYPE_NVME);
+ 		}
+ 		ndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;
+ 		lpfc_nlp_set_state(vport, ndlp, NLP_STE_PRLI_ISSUE);
+ 		lpfc_issue_els_prli(vport, ndlp, 0);
+ 	} else
+ 		lpfc_printf_vlog(vport, KERN_ERR, LOG_DISCOVERY,
+ 				 "3065 GFT_ID failed x%08x\n", irsp->ulpStatus);
+ 
+ 	lpfc_ct_free_iocb(phba, cmdiocb);
+ }
++>>>>>>> bd2cdd5e400f (scsi: lpfc: NVME Initiator: Add debugfs support)
  
  static void
  lpfc_cmpl_ct(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,
diff --cc drivers/scsi/lpfc/lpfc_debugfs.c
index 4dc8eba541b9,3fcba26623eb..000000000000
--- a/drivers/scsi/lpfc/lpfc_debugfs.c
+++ b/drivers/scsi/lpfc/lpfc_debugfs.c
@@@ -531,7 -544,11 +541,15 @@@ lpfc_debugfs_nodelist_data(struct lpfc_
  	int cnt;
  	struct Scsi_Host *shost = lpfc_shost_from_vport(vport);
  	struct lpfc_nodelist *ndlp;
++<<<<<<< HEAD
 +	unsigned char *statep, *name;
++=======
+ 	unsigned char *statep;
+ 	struct nvme_fc_local_port *localport;
+ 	struct lpfc_nvme_lport *lport;
+ 	struct lpfc_nvme_rport *rport;
+ 	struct nvme_fc_remote_port *nrport;
++>>>>>>> bd2cdd5e400f (scsi: lpfc: NVME Initiator: Add debugfs support)
  
  	cnt = (LPFC_NODELIST_SIZE / LPFC_NODELIST_ENTRY_SIZE);
  
@@@ -611,8 -625,362 +629,364 @@@
  		len +=  snprintf(buf+len, size-len, "\n");
  	}
  	spin_unlock_irq(shost->host_lock);
++<<<<<<< HEAD
++=======
+ 
+ 	len += snprintf(buf + len, size - len,
+ 				"\nNVME Lport/Rport Entries ...\n");
+ 
+ 	localport = vport->localport;
+ 	if (!localport)
+ 		goto out_exit;
+ 
+ 	spin_lock_irq(shost->host_lock);
+ 	lport = (struct lpfc_nvme_lport *)localport->private;
+ 
+ 	/* Port state is only one of two values for now. */
+ 	if (localport->port_id)
+ 		statep = "ONLINE";
+ 	else
+ 		statep = "UNKNOWN ";
+ 
+ 	len += snprintf(buf + len, size - len,
+ 			"Lport DID x%06x PortState %s\n",
+ 			localport->port_id, statep);
+ 
+ 	len += snprintf(buf + len, size - len, "\tRport List:\n");
+ 	list_for_each_entry(rport, &lport->rport_list, list) {
+ 		/* local short-hand pointer. */
+ 		nrport = rport->remoteport;
+ 
+ 		/* Port state is only one of two values for now. */
+ 		switch (nrport->port_state) {
+ 		case FC_OBJSTATE_ONLINE:
+ 			statep = "ONLINE";
+ 			break;
+ 		case FC_OBJSTATE_UNKNOWN:
+ 			statep = "UNKNOWN ";
+ 			break;
+ 		default:
+ 			statep = "UNSUPPORTED";
+ 			break;
+ 		}
+ 
+ 		/* Tab in to show lport ownership. */
+ 		len += snprintf(buf + len, size - len,
+ 				"\t%s Port ID:x%06x ",
+ 				statep, nrport->port_id);
+ 		len += snprintf(buf + len, size - len, "WWPN x%llx ",
+ 				nrport->port_name);
+ 		len += snprintf(buf + len, size - len, "WWNN x%llx ",
+ 				nrport->node_name);
+ 		switch (nrport->port_role) {
+ 		case FC_PORT_ROLE_NVME_INITIATOR:
+ 			len +=  snprintf(buf + len, size - len,
+ 					 "NVME INITIATOR ");
+ 			break;
+ 		case FC_PORT_ROLE_NVME_TARGET:
+ 			len +=  snprintf(buf + len, size - len,
+ 					 "NVME TARGET ");
+ 			break;
+ 		case FC_PORT_ROLE_NVME_DISCOVERY:
+ 			len +=  snprintf(buf + len, size - len,
+ 					 "NVME DISCOVERY ");
+ 			break;
+ 		default:
+ 			len +=  snprintf(buf + len, size - len,
+ 					 "UNKNOWN ROLE x%x",
+ 					 nrport->port_role);
+ 			break;
+ 		}
+ 
+ 		/* Terminate the string. */
+ 		len +=  snprintf(buf + len, size - len, "\n");
+ 	}
+ 
+ 	spin_unlock_irq(shost->host_lock);
+  out_exit:
+ 	return len;
+ }
+ 
+ /**
+  * lpfc_debugfs_nvmestat_data - Dump target node list to a buffer
+  * @vport: The vport to gather target node info from.
+  * @buf: The buffer to dump log into.
+  * @size: The maximum amount of data to process.
+  *
+  * Description:
+  * This routine dumps the NVME statistics associated with @vport
+  *
+  * Return Value:
+  * This routine returns the amount of bytes that were dumped into @buf and will
+  * not exceed @size.
+  **/
+ static int
+ lpfc_debugfs_nvmestat_data(struct lpfc_vport *vport, char *buf, int size)
+ {
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	int len = 0;
+ 
+ 	if (phba->nvmet_support == 0) {
+ 		if (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME))
+ 			return len;
+ 
+ 		len += snprintf(buf + len, size - len,
+ 				"\nNVME Lport Statistics\n");
+ 
+ 		len += snprintf(buf + len, size - len,
+ 				"LS: Xmt %016llx Cmpl %016llx\n",
+ 				phba->fc4NvmeLsRequests,
+ 				phba->fc4NvmeLsCmpls);
+ 
+ 		len += snprintf(buf + len, size - len,
+ 				"FCP: Rd %016llx Wr %016llx IO %016llx\n",
+ 				phba->fc4NvmeInputRequests,
+ 				phba->fc4NvmeOutputRequests,
+ 				phba->fc4NvmeControlRequests);
+ 
+ 		len += snprintf(buf + len, size - len,
+ 				"    Cmpl %016llx\n", phba->fc4NvmeIoCmpls);
+ 	}
+ 
+ 	return len;
+ }
+ 
+ 
+ /**
+  * lpfc_debugfs_nvmektime_data - Dump target node list to a buffer
+  * @vport: The vport to gather target node info from.
+  * @buf: The buffer to dump log into.
+  * @size: The maximum amount of data to process.
+  *
+  * Description:
+  * This routine dumps the NVME statistics associated with @vport
+  *
+  * Return Value:
+  * This routine returns the amount of bytes that were dumped into @buf and will
+  * not exceed @size.
+  **/
+ static int
+ lpfc_debugfs_nvmektime_data(struct lpfc_vport *vport, char *buf, int size)
+ {
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	int len = 0;
+ 
+ 	if (phba->nvmet_support == 0) {
+ 		/* NVME Initiator */
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"ktime %s: Total Samples: %lld\n",
+ 				(phba->ktime_on ?  "Enabled" : "Disabled"),
+ 				phba->ktime_data_samples);
+ 		if (phba->ktime_data_samples == 0)
+ 			return len;
+ 
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"Segment 1: Last NVME Cmd cmpl "
+ 			"done -to- Start of next NVME cnd (in driver)\n");
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg1_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg1_min,
+ 			phba->ktime_seg1_max);
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"Segment 2: Driver start of NVME cmd "
+ 			"-to- Firmware WQ doorbell\n");
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg2_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg2_min,
+ 			phba->ktime_seg2_max);
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"Segment 3: Firmware WQ doorbell -to- "
+ 			"MSI-X ISR cmpl\n");
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg3_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg3_min,
+ 			phba->ktime_seg3_max);
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"Segment 4: MSI-X ISR cmpl -to- "
+ 			"NVME cmpl done\n");
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg4_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg4_min,
+ 			phba->ktime_seg4_max);
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"Total IO avg time: %08lld\n",
+ 			((phba->ktime_seg1_total +
+ 			phba->ktime_seg2_total  +
+ 			phba->ktime_seg3_total +
+ 			phba->ktime_seg4_total) /
+ 			phba->ktime_data_samples));
+ 		return len;
+ 	}
+ 
+ 	return len;
+ }
+ 
+ /**
+  * lpfc_debugfs_nvmeio_trc_data - Dump NVME IO trace list to a buffer
+  * @phba: The phba to gather target node info from.
+  * @buf: The buffer to dump log into.
+  * @size: The maximum amount of data to process.
+  *
+  * Description:
+  * This routine dumps the NVME IO trace associated with @phba
+  *
+  * Return Value:
+  * This routine returns the amount of bytes that were dumped into @buf and will
+  * not exceed @size.
+  **/
+ static int
+ lpfc_debugfs_nvmeio_trc_data(struct lpfc_hba *phba, char *buf, int size)
+ {
+ 	struct lpfc_debugfs_nvmeio_trc *dtp;
+ 	int i, state, index, skip;
+ 	int len = 0;
+ 
+ 	state = phba->nvmeio_trc_on;
+ 
+ 	index = (atomic_read(&phba->nvmeio_trc_cnt) + 1) &
+ 		(phba->nvmeio_trc_size - 1);
+ 	skip = phba->nvmeio_trc_output_idx;
+ 
+ 	len += snprintf(buf + len, size - len,
+ 			"%s IO Trace %s: next_idx %d skip %d size %d\n",
+ 			(phba->nvmet_support ? "NVME" : "NVMET"),
+ 			(state ? "Enabled" : "Disabled"),
+ 			index, skip, phba->nvmeio_trc_size);
+ 
+ 	if (!phba->nvmeio_trc || state)
+ 		return len;
+ 
+ 	/* trace MUST bhe off to continue */
+ 
+ 	for (i = index; i < phba->nvmeio_trc_size; i++) {
+ 		if (skip) {
+ 			skip--;
+ 			continue;
+ 		}
+ 		dtp = phba->nvmeio_trc + i;
+ 		phba->nvmeio_trc_output_idx++;
+ 
+ 		if (!dtp->fmt)
+ 			continue;
+ 
+ 		len +=  snprintf(buf + len, size - len, dtp->fmt,
+ 			dtp->data1, dtp->data2, dtp->data3);
+ 
+ 		if (phba->nvmeio_trc_output_idx >= phba->nvmeio_trc_size) {
+ 			phba->nvmeio_trc_output_idx = 0;
+ 			len += snprintf(buf + len, size - len,
+ 					"Trace Complete\n");
+ 			goto out;
+ 		}
+ 
+ 		if (len >= (size - LPFC_DEBUG_OUT_LINE_SZ)) {
+ 			len += snprintf(buf + len, size - len,
+ 					"Trace Continue (%d of %d)\n",
+ 					phba->nvmeio_trc_output_idx,
+ 					phba->nvmeio_trc_size);
+ 			goto out;
+ 		}
+ 	}
+ 	for (i = 0; i < index; i++) {
+ 		if (skip) {
+ 			skip--;
+ 			continue;
+ 		}
+ 		dtp = phba->nvmeio_trc + i;
+ 		phba->nvmeio_trc_output_idx++;
+ 
+ 		if (!dtp->fmt)
+ 			continue;
+ 
+ 		len +=  snprintf(buf + len, size - len, dtp->fmt,
+ 			dtp->data1, dtp->data2, dtp->data3);
+ 
+ 		if (phba->nvmeio_trc_output_idx >= phba->nvmeio_trc_size) {
+ 			phba->nvmeio_trc_output_idx = 0;
+ 			len += snprintf(buf + len, size - len,
+ 					"Trace Complete\n");
+ 			goto out;
+ 		}
+ 
+ 		if (len >= (size - LPFC_DEBUG_OUT_LINE_SZ)) {
+ 			len += snprintf(buf + len, size - len,
+ 					"Trace Continue (%d of %d)\n",
+ 					phba->nvmeio_trc_output_idx,
+ 					phba->nvmeio_trc_size);
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	len += snprintf(buf + len, size - len,
+ 			"Trace Done\n");
+ out:
+ 	return len;
+ }
+ 
+ /**
+  * lpfc_debugfs_cpucheck_data - Dump target node list to a buffer
+  * @vport: The vport to gather target node info from.
+  * @buf: The buffer to dump log into.
+  * @size: The maximum amount of data to process.
+  *
+  * Description:
+  * This routine dumps the NVME statistics associated with @vport
+  *
+  * Return Value:
+  * This routine returns the amount of bytes that were dumped into @buf and will
+  * not exceed @size.
+  **/
+ static int
+ lpfc_debugfs_cpucheck_data(struct lpfc_vport *vport, char *buf, int size)
+ {
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	int i;
+ 	int len = 0;
+ 	uint32_t tot_xmt = 0;
+ 	uint32_t tot_cmpl = 0;
+ 
+ 	if (phba->nvmet_support == 0) {
+ 		/* NVME Initiator */
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"CPUcheck %s\n",
+ 				(phba->cpucheck_on & LPFC_CHECK_NVME_IO ?
+ 					"Enabled" : "Disabled"));
+ 		for (i = 0; i < phba->sli4_hba.num_present_cpu; i++) {
+ 			if (i >= LPFC_CHECK_CPU_CNT)
+ 				break;
+ 			len += snprintf(buf + len, PAGE_SIZE - len,
+ 					"%02d: xmit x%08x cmpl x%08x\n",
+ 					i, phba->cpucheck_xmt_io[i],
+ 					phba->cpucheck_cmpl_io[i]);
+ 			tot_xmt += phba->cpucheck_xmt_io[i];
+ 			tot_cmpl += phba->cpucheck_cmpl_io[i];
+ 		}
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"tot:xmit x%08x cmpl x%08x\n",
+ 				tot_xmt, tot_cmpl);
+ 		return len;
+ 	}
+ 
++>>>>>>> bd2cdd5e400f (scsi: lpfc: NVME Initiator: Add debugfs support)
  	return len;
  }
 -
  #endif
  
  /**
@@@ -2541,25 -3320,63 +3299,69 @@@ lpfc_idiag_queacc_write(struct file *fi
  			idiag.ptr_private = phba->sli4_hba.els_cq;
  			goto pass_check;
  		}
++<<<<<<< HEAD
++=======
+ 		/* NVME LS complete queue */
+ 		if (phba->sli4_hba.nvmels_cq &&
+ 		    phba->sli4_hba.nvmels_cq->queue_id == queid) {
+ 			/* Sanity check */
+ 			rc = lpfc_idiag_que_param_check(
+ 					phba->sli4_hba.nvmels_cq, index, count);
+ 			if (rc)
+ 				goto error_out;
+ 			idiag.ptr_private = phba->sli4_hba.nvmels_cq;
+ 			goto pass_check;
+ 		}
+ 		/* NVME LS complete queue */
+ 		if (phba->sli4_hba.nvmels_cq &&
+ 		    phba->sli4_hba.nvmels_cq->queue_id == queid) {
+ 			/* Sanity check */
+ 			rc = lpfc_idiag_que_param_check(
+ 					phba->sli4_hba.nvmels_cq, index, count);
+ 			if (rc)
+ 				goto error_out;
+ 			idiag.ptr_private = phba->sli4_hba.nvmels_cq;
+ 			goto pass_check;
+ 		}
++>>>>>>> bd2cdd5e400f (scsi: lpfc: NVME Initiator: Add debugfs support)
  		/* FCP complete queue */
  		if (phba->sli4_hba.fcp_cq) {
 -			for (qidx = 0; qidx < phba->cfg_fcp_io_channel;
 -								qidx++) {
 -				qp = phba->sli4_hba.fcp_cq[qidx];
 -				if (qp && qp->queue_id == queid) {
 +			qidx = 0;
 +			do {
 +				if (phba->sli4_hba.fcp_cq[qidx] &&
 +				    phba->sli4_hba.fcp_cq[qidx]->queue_id ==
 +				    queid) {
  					/* Sanity check */
  					rc = lpfc_idiag_que_param_check(
 -						qp, index, count);
 +						phba->sli4_hba.fcp_cq[qidx],
 +						index, count);
  					if (rc)
  						goto error_out;
 -					idiag.ptr_private = qp;
 +					idiag.ptr_private =
 +						phba->sli4_hba.fcp_cq[qidx];
  					goto pass_check;
  				}
 -			}
 +			} while (++qidx < phba->cfg_fcp_io_channel);
  		}
+ 		/* NVME complete queue */
+ 		if (phba->sli4_hba.nvme_cq) {
+ 			qidx = 0;
+ 			do {
+ 				if (phba->sli4_hba.nvme_cq[qidx] &&
+ 				    phba->sli4_hba.nvme_cq[qidx]->queue_id ==
+ 				    queid) {
+ 					/* Sanity check */
+ 					rc = lpfc_idiag_que_param_check(
+ 						phba->sli4_hba.nvme_cq[qidx],
+ 						index, count);
+ 					if (rc)
+ 						goto error_out;
+ 					idiag.ptr_private =
+ 						phba->sli4_hba.nvme_cq[qidx];
+ 					goto pass_check;
+ 				}
+ 			} while (++qidx < phba->cfg_nvme_io_channel);
+ 		}
  		goto error_out;
  		break;
  	case LPFC_IDIAG_MQ:
@@@ -2588,6 -3405,28 +3390,31 @@@
  			idiag.ptr_private = phba->sli4_hba.els_wq;
  			goto pass_check;
  		}
++<<<<<<< HEAD
++=======
+ 		/* NVME LS work queue */
+ 		if (phba->sli4_hba.nvmels_wq &&
+ 		    phba->sli4_hba.nvmels_wq->queue_id == queid) {
+ 			/* Sanity check */
+ 			rc = lpfc_idiag_que_param_check(
+ 					phba->sli4_hba.nvmels_wq, index, count);
+ 			if (rc)
+ 				goto error_out;
+ 			idiag.ptr_private = phba->sli4_hba.nvmels_wq;
+ 			goto pass_check;
+ 		}
+ 		/* NVME LS work queue */
+ 		if (phba->sli4_hba.nvmels_wq &&
+ 		    phba->sli4_hba.nvmels_wq->queue_id == queid) {
+ 			/* Sanity check */
+ 			rc = lpfc_idiag_que_param_check(
+ 					phba->sli4_hba.nvmels_wq, index, count);
+ 			if (rc)
+ 				goto error_out;
+ 			idiag.ptr_private = phba->sli4_hba.nvmels_wq;
+ 			goto pass_check;
+ 		}
++>>>>>>> bd2cdd5e400f (scsi: lpfc: NVME Initiator: Add debugfs support)
  		/* FCP work queue */
  		if (phba->sli4_hba.fcp_wq) {
  			for (qidx = 0; qidx < phba->cfg_fcp_io_channel;
@@@ -4177,6 -5087,61 +5064,64 @@@ lpfc_debugfs_initialize(struct lpfc_vpo
  				(sizeof(struct lpfc_debugfs_trc) *
  				lpfc_debugfs_max_slow_ring_trc));
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		snprintf(name, sizeof(name), "nvmeio_trc");
+ 		phba->debug_nvmeio_trc =
+ 			debugfs_create_file(name, 0644,
+ 					    phba->hba_debugfs_root,
+ 					    phba, &lpfc_debugfs_op_nvmeio_trc);
+ 		if (!phba->debug_nvmeio_trc) {
+ 			lpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,
+ 					 "0574 No create debugfs nvmeio_trc\n");
+ 			goto debug_failed;
+ 		}
+ 
+ 		atomic_set(&phba->nvmeio_trc_cnt, 0);
+ 		if (lpfc_debugfs_max_nvmeio_trc) {
+ 			num = lpfc_debugfs_max_nvmeio_trc - 1;
+ 			if (num & lpfc_debugfs_max_disc_trc) {
+ 				/* Change to be a power of 2 */
+ 				num = lpfc_debugfs_max_nvmeio_trc;
+ 				i = 0;
+ 				while (num > 1) {
+ 					num = num >> 1;
+ 					i++;
+ 				}
+ 				lpfc_debugfs_max_nvmeio_trc = (1 << i);
+ 				lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 						"0575 lpfc_debugfs_max_nvmeio_trc "
+ 						"changed to %d\n",
+ 						lpfc_debugfs_max_nvmeio_trc);
+ 			}
+ 			phba->nvmeio_trc_size = lpfc_debugfs_max_nvmeio_trc;
+ 
+ 			/* Allocate trace buffer and initialize */
+ 			phba->nvmeio_trc = kmalloc(
+ 				(sizeof(struct lpfc_debugfs_nvmeio_trc) *
+ 				phba->nvmeio_trc_size), GFP_KERNEL);
+ 
+ 			if (!phba->nvmeio_trc) {
+ 				lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 						"0576 Cannot create debugfs "
+ 						"nvmeio_trc buffer\n");
+ 				goto nvmeio_off;
+ 			}
+ 			memset(phba->nvmeio_trc, 0,
+ 			       (sizeof(struct lpfc_debugfs_nvmeio_trc) *
+ 			       phba->nvmeio_trc_size));
+ 			phba->nvmeio_trc_on = 1;
+ 			phba->nvmeio_trc_output_idx = 0;
+ 			phba->nvmeio_trc = NULL;
+ 		} else {
+ nvmeio_off:
+ 			phba->nvmeio_trc_size = 0;
+ 			phba->nvmeio_trc_on = 0;
+ 			phba->nvmeio_trc_output_idx = 0;
+ 			phba->nvmeio_trc = NULL;
+ 		}
++>>>>>>> bd2cdd5e400f (scsi: lpfc: NVME Initiator: Add debugfs support)
  	}
  
  	snprintf(name, sizeof(name), "vport%d", vport->vpi);
* Unmerged path drivers/scsi/lpfc/lpfc_nvme.c
* Unmerged path drivers/scsi/lpfc/lpfc_nvme.h
diff --git a/drivers/scsi/lpfc/lpfc.h b/drivers/scsi/lpfc/lpfc.h
index 79f57d03022e..f16d68726af1 100644
--- a/drivers/scsi/lpfc/lpfc.h
+++ b/drivers/scsi/lpfc/lpfc.h
@@ -428,6 +428,9 @@ struct lpfc_vport {
 #ifdef CONFIG_SCSI_LPFC_DEBUG_FS
 	struct dentry *debug_disc_trc;
 	struct dentry *debug_nodelist;
+	struct dentry *debug_nvmestat;
+	struct dentry *debug_nvmektime;
+	struct dentry *debug_cpucheck;
 	struct dentry *vport_debugfs_root;
 	struct lpfc_debugfs_trc *disc_trc;
 	atomic_t disc_trc_cnt;
@@ -921,6 +924,12 @@ struct lpfc_hba {
 	struct dentry *debug_readApp;    /* inject read app_tag errors */
 	struct dentry *debug_readRef;    /* inject read ref_tag errors */
 
+	struct dentry *debug_nvmeio_trc;
+	struct lpfc_debugfs_nvmeio_trc *nvmeio_trc;
+	atomic_t nvmeio_trc_cnt;
+	uint32_t nvmeio_trc_size;
+	uint32_t nvmeio_trc_output_idx;
+
 	/* T10 DIF error injection */
 	uint32_t lpfc_injerr_wgrd_cnt;
 	uint32_t lpfc_injerr_wapp_cnt;
@@ -948,6 +957,7 @@ struct lpfc_hba {
 	struct dentry *idiag_ext_acc;
 	uint8_t lpfc_idiag_last_eq;
 #endif
+	uint16_t nvmeio_trc_on;
 
 	/* Used for deferred freeing of ELS data buffers */
 	struct list_head elsbuf;
@@ -1020,6 +1030,51 @@ struct lpfc_hba {
 #define LPFC_TRANSGRESSION_LOW_RXPOWER		0x4000
 	uint16_t sfp_alarm;
 	uint16_t sfp_warning;
+
+#ifdef CONFIG_SCSI_LPFC_DEBUG_FS
+#define LPFC_CHECK_CPU_CNT    32
+	uint32_t cpucheck_rcv_io[LPFC_CHECK_CPU_CNT];
+	uint32_t cpucheck_xmt_io[LPFC_CHECK_CPU_CNT];
+	uint32_t cpucheck_cmpl_io[LPFC_CHECK_CPU_CNT];
+	uint32_t cpucheck_ccmpl_io[LPFC_CHECK_CPU_CNT];
+	uint16_t cpucheck_on;
+#define LPFC_CHECK_OFF		0
+#define LPFC_CHECK_NVME_IO	1
+	uint16_t ktime_on;
+	uint64_t ktime_data_samples;
+	uint64_t ktime_status_samples;
+	uint64_t ktime_last_cmd;
+	uint64_t ktime_seg1_total;
+	uint64_t ktime_seg1_min;
+	uint64_t ktime_seg1_max;
+	uint64_t ktime_seg2_total;
+	uint64_t ktime_seg2_min;
+	uint64_t ktime_seg2_max;
+	uint64_t ktime_seg3_total;
+	uint64_t ktime_seg3_min;
+	uint64_t ktime_seg3_max;
+	uint64_t ktime_seg4_total;
+	uint64_t ktime_seg4_min;
+	uint64_t ktime_seg4_max;
+	uint64_t ktime_seg5_total;
+	uint64_t ktime_seg5_min;
+	uint64_t ktime_seg5_max;
+	uint64_t ktime_seg6_total;
+	uint64_t ktime_seg6_min;
+	uint64_t ktime_seg6_max;
+	uint64_t ktime_seg7_total;
+	uint64_t ktime_seg7_min;
+	uint64_t ktime_seg7_max;
+	uint64_t ktime_seg8_total;
+	uint64_t ktime_seg8_min;
+	uint64_t ktime_seg8_max;
+	uint64_t ktime_seg9_total;
+	uint64_t ktime_seg9_min;
+	uint64_t ktime_seg9_max;
+	uint64_t ktime_seg10_total;
+	uint64_t ktime_seg10_min;
+	uint64_t ktime_seg10_max;
+#endif
 };
 
 static inline struct Scsi_Host *
diff --git a/drivers/scsi/lpfc/lpfc_crtn.h b/drivers/scsi/lpfc/lpfc_crtn.h
index 5d7cb958427c..e87f19adbd12 100644
--- a/drivers/scsi/lpfc/lpfc_crtn.h
+++ b/drivers/scsi/lpfc/lpfc_crtn.h
@@ -375,9 +375,11 @@ void lpfc_host_attrib_init(struct Scsi_Host *);
 extern void lpfc_debugfs_initialize(struct lpfc_vport *);
 extern void lpfc_debugfs_terminate(struct lpfc_vport *);
 extern void lpfc_debugfs_disc_trc(struct lpfc_vport *, int, char *, uint32_t,
-	uint32_t, uint32_t);
+				  uint32_t, uint32_t);
 extern void lpfc_debugfs_slow_ring_trc(struct lpfc_hba *, char *, uint32_t,
-	uint32_t, uint32_t);
+				       uint32_t, uint32_t);
+extern void lpfc_debugfs_nvme_trc(struct lpfc_hba *phba, char *fmt,
+				uint16_t data1, uint16_t data2, uint32_t data3);
 extern struct lpfc_hbq_init *lpfc_hbq_defs[];
 
 /* SLI4 if_type 2 externs. */
* Unmerged path drivers/scsi/lpfc/lpfc_ct.c
* Unmerged path drivers/scsi/lpfc/lpfc_debugfs.c
diff --git a/drivers/scsi/lpfc/lpfc_debugfs.h b/drivers/scsi/lpfc/lpfc_debugfs.h
index 9ae2c4b5fd12..0c73e3829646 100644
--- a/drivers/scsi/lpfc/lpfc_debugfs.h
+++ b/drivers/scsi/lpfc/lpfc_debugfs.h
@@ -48,6 +48,14 @@ enum {
 	DUMP_ELS,
 };
 
+/* nvmestat output buffer size */
+#define LPFC_NVMESTAT_SIZE 8192
+#define LPFC_NVMEKTIME_SIZE 8192
+#define LPFC_CPUCHECK_SIZE 8192
+#define LPFC_NVMEIO_TRC_SIZE 8192
+
+#define LPFC_DEBUG_OUT_LINE_SZ	80
+
 /*
  * For SLI4 iDiag debugfs diagnostics tool
  */
@@ -194,6 +202,12 @@ enum {
 #define SIZE_U16 sizeof(uint16_t)
 #define SIZE_U32 sizeof(uint32_t)
 
+#define lpfc_nvmeio_data(phba, fmt, arg...) \
+	{ \
+	if (phba->nvmeio_trc_on) \
+		lpfc_debugfs_nvme_trc(phba, fmt, ##arg); \
+	}
+
 struct lpfc_debug {
 	char *i_private;
 	char op;
@@ -212,6 +226,13 @@ struct lpfc_debugfs_trc {
 	unsigned long jif;
 };
 
+struct lpfc_debugfs_nvmeio_trc {
+	char *fmt;
+	uint16_t data1;
+	uint16_t data2;
+	uint32_t data3;
+};
+
 struct lpfc_idiag_offset {
 	uint32_t last_rd;
 };
* Unmerged path drivers/scsi/lpfc/lpfc_nvme.c
* Unmerged path drivers/scsi/lpfc/lpfc_nvme.h
diff --git a/drivers/scsi/lpfc/lpfc_sli.c b/drivers/scsi/lpfc/lpfc_sli.c
index c1522c6b2e42..4fc6bdb99aab 100644
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@ -12687,6 +12687,11 @@ lpfc_sli4_hba_intr_handler(int irq, void *dev_id)
 	if (unlikely(!fpeq))
 		return IRQ_NONE;
 
+#ifdef CONFIG_SCSI_LPFC_DEBUG_FS
+	if (phba->ktime_on)
+		fpeq->isr_timestamp = ktime_get_ns();
+#endif
+
 	if (lpfc_fcp_look_ahead) {
 		if (atomic_dec_and_test(&fcp_eq_hdl->fcp_eq_in_use))
 			lpfc_sli4_eq_clr_intr(fpeq);
