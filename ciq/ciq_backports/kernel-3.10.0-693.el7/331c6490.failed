random: If we have arch_get_random_seed*(), try it before blocking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author H. Peter Anvin <hpa@linux.intel.com>
commit 331c6490c7f10dcf263712e313b7c0bc7fb6d77a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/331c6490.failed

If we have arch_get_random_seed*(), try to use it for emergency refill
of the entropy pool before giving up and blocking on /dev/random.  It
may or may not work in the moment, but if it does work, it will give
the user better service than blocking will.

	Reviewed-by: Ingo Molnar <mingo@kernel.org>
	Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit 331c6490c7f10dcf263712e313b7c0bc7fb6d77a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/random.c
diff --cc drivers/char/random.c
index e014a74135d7,c35cee268e13..000000000000
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@@ -1285,53 -1330,32 +1313,75 @@@ random_read(struct file *file, char __u
  	if (nbytes == 0)
  		return 0;
  
++<<<<<<< HEAD
 +	while (nbytes > 0) {
 +		n = nbytes;
 +		if (n > SEC_XFER_SIZE)
 +			n = SEC_XFER_SIZE;
 +
 +		DEBUG_ENT("reading %zu bits\n", n*8);
++=======
+ 	nbytes = min_t(size_t, nbytes, SEC_XFER_SIZE);
+ 	while (1) {
+ 		n = extract_entropy_user(&blocking_pool, buf, nbytes);
+ 		if (n < 0)
+ 			return n;
+ 		trace_random_read(n*8, (nbytes-n)*8,
+ 				  ENTROPY_BITS(&blocking_pool),
+ 				  ENTROPY_BITS(&input_pool));
+ 		if (n > 0)
+ 			return n;
+ 
+ 		/* Pool is (near) empty.  Maybe wait and retry. */
+ 
+ 		/* First try an emergency refill */
+ 		if (arch_random_refill())
+ 			continue;
+ 
+ 		if (file->f_flags & O_NONBLOCK)
+ 			return -EAGAIN;
++>>>>>>> 331c6490c7f1 (random: If we have arch_get_random_seed*(), try it before blocking)
  
 -		wait_event_interruptible(random_read_wait,
 -			ENTROPY_BITS(&input_pool) >=
 -			random_read_wakeup_bits);
 -		if (signal_pending(current))
 -			return -ERESTARTSYS;
 +		n = extract_entropy_user(&blocking_pool, buf, n);
 +
 +		if (n < 0) {
 +			retval = n;
 +			break;
 +		}
 +
 +		DEBUG_ENT("read got %zd bits (%zd still needed)\n",
 +			  n*8, (nbytes-n)*8);
 +
 +		if (n == 0) {
 +			if (file->f_flags & O_NONBLOCK) {
 +				retval = -EAGAIN;
 +				break;
 +			}
 +
 +			DEBUG_ENT("sleeping?\n");
 +
 +			wait_event_interruptible(random_read_wait,
 +				ENTROPY_BITS(&input_pool) >=
 +				random_read_wakeup_thresh);
 +
 +			DEBUG_ENT("awake\n");
 +
 +			if (signal_pending(current)) {
 +				retval = -ERESTARTSYS;
 +				break;
 +			}
 +
 +			continue;
 +		}
 +
 +		count += n;
 +		buf += n;
 +		nbytes -= n;
 +		break;		/* This break makes the device work */
 +				/* like a named pipe */
  	}
 +
 +	return (count ? count : retval);
  }
  
  static ssize_t
* Unmerged path drivers/char/random.c
