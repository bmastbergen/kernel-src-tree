net/mlx5: Add option to add fwd rule with counter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Add option to add fwd rule with counter (Don Dutile) [1385330 1417286]
Rebuild_FUZZ: 95.74%
commit-author Mark Bloch <markb@mellanox.com>
commit ae05831424ed99f1432492d6df7e8bfe139d2449
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ae058314.failed

Currently the code supports only drop rules to possess counters,
add that ability also for fwd rules.

	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
(cherry picked from commit ae05831424ed99f1432492d6df7e8bfe139d2449)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index b32d85f4e0ff,0dfd998cf49e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -387,13 -393,27 +388,31 @@@ static void del_rule(struct fs_node *no
  		list_del(&rule->next_ft);
  		mutex_unlock(&rule->dest_attr.ft->lock);
  	}
+ 
+ 	if (rule->dest_attr.type == MLX5_FLOW_DESTINATION_TYPE_COUNTER  &&
+ 	    --fte->dests_size) {
+ 		modify_mask = BIT(MLX5_SET_FTE_MODIFY_ENABLE_MASK_ACTION);
+ 		fte->action &= ~MLX5_FLOW_CONTEXT_ACTION_COUNT;
+ 		update_fte = true;
+ 		goto out;
+ 	}
+ 
  	if ((fte->action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) &&
  	    --fte->dests_size) {
++<<<<<<< HEAD
 +		err = mlx5_cmd_update_fte(dev, ft,
 +					  fg->id, fte);
++=======
+ 		modify_mask = BIT(MLX5_SET_FTE_MODIFY_ENABLE_MASK_DESTINATION_LIST),
+ 		update_fte = true;
+ 	}
+ out:
+ 	if (update_fte && fte->dests_size) {
+ 		err = mlx5_cmd_update_fte(dev, ft, fg->id, modify_mask, fte);
++>>>>>>> ae05831424ed (net/mlx5: Add option to add fwd rule with counter)
  		if (err)
 -			mlx5_core_warn(dev,
 -				       "%s can't del rule fg id=%d fte_index=%d\n",
 -				       __func__, fg->id, fte->index);
 +			pr_warn("%s can't del rule fg id=%d fte_index=%d\n",
 +				__func__, fg->id, fte->index);
  	}
  	kvfree(match_value);
  }
@@@ -1101,23 -1272,70 +1120,78 @@@ unlock_fte
  	unlock_ref_node(&fte->node);
  unlock_fg:
  	unlock_ref_node(&fg->node);
 -	return handle;
 +	return rule;
  }
  
++<<<<<<< HEAD
 +static struct mlx5_flow_rule *
 +_mlx5_add_flow_rule(struct mlx5_flow_table *ft,
 +		    u8 match_criteria_enable,
 +		    u32 *match_criteria,
 +		    u32 *match_value,
 +		    u32 action,
 +		    u32 flow_tag,
 +		    struct mlx5_flow_destination *dest)
++=======
+ struct mlx5_fc *mlx5_flow_rule_counter(struct mlx5_flow_handle *handle)
+ {
+ 	struct mlx5_flow_rule *dst;
+ 	struct fs_fte *fte;
+ 
+ 	fs_get_obj(fte, handle->rule[0]->node.parent);
+ 
+ 	fs_for_each_dst(dst, fte) {
+ 		if (dst->dest_attr.type == MLX5_FLOW_DESTINATION_TYPE_COUNTER)
+ 			return dst->dest_attr.counter;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static bool counter_is_valid(struct mlx5_fc *counter, u32 action)
+ {
+ 	if (!(action & MLX5_FLOW_CONTEXT_ACTION_COUNT))
+ 		return !counter;
+ 
+ 	if (!counter)
+ 		return false;
+ 
+ 	return (action & (MLX5_FLOW_CONTEXT_ACTION_DROP |
+ 			  MLX5_FLOW_CONTEXT_ACTION_FWD_DEST)) &&
+ 		(action & MLX5_FLOW_CONTEXT_ACTION_COUNT);
+ }
+ 
+ static bool dest_is_valid(struct mlx5_flow_destination *dest,
+ 			  u32 action,
+ 			  struct mlx5_flow_table *ft)
+ {
+ 	if (dest && (dest->type == MLX5_FLOW_DESTINATION_TYPE_COUNTER))
+ 		return counter_is_valid(dest->counter, action);
+ 
+ 	if (!(action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST))
+ 		return true;
+ 
+ 	if (!dest || ((dest->type ==
+ 	    MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE) &&
+ 	    (dest->ft->level <= ft->level)))
+ 		return false;
+ 	return true;
+ }
+ 
+ static struct mlx5_flow_handle *
+ _mlx5_add_flow_rules(struct mlx5_flow_table *ft,
+ 		     struct mlx5_flow_spec *spec,
+ 		     u32 action,
+ 		     u32 flow_tag,
+ 		     struct mlx5_flow_destination *dest,
+ 		     int dest_num)
++>>>>>>> ae05831424ed (net/mlx5: Add option to add fwd rule with counter)
  {
  	struct mlx5_flow_group *g;
 -	struct mlx5_flow_handle *rule;
 -	int i;
 +	struct mlx5_flow_rule *rule;
  
 -	for (i = 0; i < dest_num; i++) {
 -		if (!dest_is_valid(&dest[i], action, ft))
 -			return ERR_PTR(-EINVAL);
 -	}
 +	if ((action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) && !dest)
 +		return ERR_PTR(-EINVAL);
  
  	nested_lock_ref_node(&ft->node, FS_MUTEX_GRANDPARENT);
  	fs_for_each_fg(g, ft)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
