workqueue: handle NUMA_NO_NODE for unbound pool_workqueue lookup

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [kernel] workqueue: handle NUMA_NO_NODE for unbound pool_workqueue (Waiman Long) [1452675]
Rebuild_FUZZ: 94.21%
commit-author Tejun Heo <tj@kernel.org>
commit d6e022f1d207a161cd88e08ef0371554680ffc46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d6e022f1.failed

When looking up the pool_workqueue to use for an unbound workqueue,
workqueue assumes that the target CPU is always bound to a valid NUMA
node.  However, currently, when a CPU goes offline, the mapping is
destroyed and cpu_to_node() returns NUMA_NO_NODE.

This has always been broken but hasn't triggered often enough before
874bbfe600a6 ("workqueue: make sure delayed work run in local cpu").
After the commit, workqueue forcifully assigns the local CPU for
delayed work items without explicit target CPU to fix a different
issue.  This widens the window where CPU can go offline while a
delayed work item is pending causing delayed work items dispatched
with target CPU set to an already offlined CPU.  The resulting
NUMA_NO_NODE mapping makes workqueue try to queue the work item on a
NULL pool_workqueue and thus crash.

While 874bbfe600a6 has been reverted for a different reason making the
bug less visible again, it can still happen.  Fix it by mapping
NUMA_NO_NODE to the default pool_workqueue from unbound_pwq_by_node().
This is a temporary workaround.  The long term solution is keeping CPU
-> NODE mapping stable across CPU off/online cycles which is being
worked on.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Reported-by: Mike Galbraith <umgwanakikbuti@gmail.com>
	Cc: Tang Chen <tangchen@cn.fujitsu.com>
	Cc: Rafael J. Wysocki <rafael@kernel.org>
	Cc: Len Brown <len.brown@intel.com>
	Cc: stable@vger.kernel.org
Link: http://lkml.kernel.org/g/1454424264.11183.46.camel@gmail.com
Link: http://lkml.kernel.org/g/1453702100-2597-1-git-send-email-tangchen@cn.fujitsu.com
(cherry picked from commit d6e022f1d207a161cd88e08ef0371554680ffc46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/workqueue.c
diff --cc kernel/workqueue.c
index 8ce6c9c5916d,7ff5dc7d2ac5..000000000000
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@@ -566,7 -585,17 +566,21 @@@ static int worker_pool_assign_id(struc
  static struct pool_workqueue *unbound_pwq_by_node(struct workqueue_struct *wq,
  						  int node)
  {
++<<<<<<< HEAD
 +	assert_rcu_or_wq_mutex(wq);
++=======
+ 	assert_rcu_or_wq_mutex_or_pool_mutex(wq);
+ 
+ 	/*
+ 	 * XXX: @node can be NUMA_NO_NODE if CPU goes offline while a
+ 	 * delayed item is pending.  The plan is to keep CPU -> NODE
+ 	 * mapping valid and stable across CPU on/offlines.  Once that
+ 	 * happens, this workaround can be removed.
+ 	 */
+ 	if (unlikely(node == NUMA_NO_NODE))
+ 		return wq->dfl_pwq;
+ 
++>>>>>>> d6e022f1d207 (workqueue: handle NUMA_NO_NODE for unbound pool_workqueue lookup)
  	return rcu_dereference_raw(wq->numa_pwq_tbl[node]);
  }
  
* Unmerged path kernel/workqueue.c
