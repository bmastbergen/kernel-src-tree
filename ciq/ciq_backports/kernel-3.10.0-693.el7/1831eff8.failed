device property: ACPI: Make use of the new DMA Attribute APIs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Suthikulpanit, Suravee <Suravee.Suthikulpanit@amd.com>
commit 1831eff876bd0bb8d64e9965a7ff47486c9a3ecd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1831eff8.failed

Now that we have the new DMA attribute APIs, we can replace the older
acpi_check_dma() and device_dma_is_coherent().

	Signed-off-by: Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
	Acked-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Hanjun Guo <hanjun.guo@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 1831eff876bd0bb8d64e9965a7ff47486c9a3ecd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/acpi_platform.c
#	drivers/acpi/glue.c
#	drivers/crypto/ccp/ccp-platform.c
#	drivers/net/ethernet/amd/xgbe/xgbe-main.c
diff --cc drivers/acpi/acpi_platform.c
index b3ba9c50e38e,296b7a14893a..000000000000
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@@ -103,6 -103,12 +103,15 @@@ struct platform_device *acpi_create_pla
  	pdevinfo.res = resources;
  	pdevinfo.num_res = count;
  	pdevinfo.fwnode = acpi_fwnode_handle(adev);
++<<<<<<< HEAD
++=======
+ 
+ 	if (acpi_dma_supported(adev))
+ 		pdevinfo.dma_mask = DMA_BIT_MASK(32);
+ 	else
+ 		pdevinfo.dma_mask = 0;
+ 
++>>>>>>> 1831eff876bd (device property: ACPI: Make use of the new DMA Attribute APIs)
  	pdev = platform_device_register_full(&pdevinfo);
  	if (IS_ERR(pdev))
  		dev_err(&adev->dev, "platform device creation failed: %ld\n",
diff --cc drivers/acpi/glue.c
index 88d84c3c923b,a66e77676b8a..000000000000
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@@ -167,6 -168,7 +167,10 @@@ int acpi_bind_one(struct device *dev, s
  	struct list_head *physnode_list;
  	unsigned int node_id;
  	int retval = -EINVAL;
++<<<<<<< HEAD
++=======
+ 	enum dev_dma_attr attr;
++>>>>>>> 1831eff876bd (device property: ACPI: Make use of the new DMA Attribute APIs)
  
  	if (has_acpi_companion(dev)) {
  		if (acpi_dev) {
@@@ -221,6 -225,11 +225,14 @@@
  	if (!has_acpi_companion(dev))
  		ACPI_COMPANION_SET(dev, acpi_dev);
  
++<<<<<<< HEAD
++=======
+ 	attr = acpi_get_dma_attr(acpi_dev);
+ 	if (attr != DEV_DMA_NOT_SUPPORTED)
+ 		arch_setup_dma_ops(dev, 0, 0, NULL,
+ 				   attr == DEV_DMA_COHERENT);
+ 
++>>>>>>> 1831eff876bd (device property: ACPI: Make use of the new DMA Attribute APIs)
  	acpi_physnode_link_name(physical_node_name, node_id);
  	retval = sysfs_create_link(&acpi_dev->dev.kobj, &dev->kobj,
  				   physical_node_name);
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-main.c
index 51cdca78ec38,c607b3f88f0b..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-main.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-main.c
@@@ -220,12 -212,137 +220,18 @@@ static void xgbe_init_all_fptrs(struct 
  static int xgbe_probe(struct platform_device *pdev)
  {
  	struct xgbe_prv_data *pdata;
 +	struct xgbe_hw_if *hw_if;
 +	struct xgbe_desc_if *desc_if;
  	struct net_device *netdev;
 -	struct device *dev = &pdev->dev, *phy_dev;
 -	struct platform_device *phy_pdev;
 +	struct device *dev = &pdev->dev;
  	struct resource *res;
++<<<<<<< HEAD
 +	const u8 *mac_addr;
++=======
+ 	const char *phy_mode;
+ 	unsigned int i, phy_memnum, phy_irqnum;
+ 	enum dev_dma_attr attr;
++>>>>>>> 1831eff876bd (device property: ACPI: Make use of the new DMA Attribute APIs)
  	int ret;
  
  	DBGPR("--> xgbe_probe\n");
@@@ -301,7 -500,123 +307,127 @@@
  		goto err_io;
  	}
  
++<<<<<<< HEAD
 +	if (of_property_read_bool(dev->of_node, "dma-coherent")) {
++=======
+ 	switch (pdata->speed_set) {
+ 	case XGBE_SPEEDSET_1000_10000:
+ 	case XGBE_SPEEDSET_2500_10000:
+ 		break;
+ 	default:
+ 		dev_err(dev, "invalid %s property\n", XGBE_SPEEDSET_PROPERTY);
+ 		ret = -EINVAL;
+ 		goto err_io;
+ 	}
+ 
+ 	/* Retrieve the PHY configuration properties */
+ 	if (device_property_present(phy_dev, XGBE_BLWC_PROPERTY)) {
+ 		ret = device_property_read_u32_array(phy_dev,
+ 						     XGBE_BLWC_PROPERTY,
+ 						     pdata->serdes_blwc,
+ 						     XGBE_SPEEDS);
+ 		if (ret) {
+ 			dev_err(dev, "invalid %s property\n",
+ 				XGBE_BLWC_PROPERTY);
+ 			goto err_io;
+ 		}
+ 	} else {
+ 		memcpy(pdata->serdes_blwc, xgbe_serdes_blwc,
+ 		       sizeof(pdata->serdes_blwc));
+ 	}
+ 
+ 	if (device_property_present(phy_dev, XGBE_CDR_RATE_PROPERTY)) {
+ 		ret = device_property_read_u32_array(phy_dev,
+ 						     XGBE_CDR_RATE_PROPERTY,
+ 						     pdata->serdes_cdr_rate,
+ 						     XGBE_SPEEDS);
+ 		if (ret) {
+ 			dev_err(dev, "invalid %s property\n",
+ 				XGBE_CDR_RATE_PROPERTY);
+ 			goto err_io;
+ 		}
+ 	} else {
+ 		memcpy(pdata->serdes_cdr_rate, xgbe_serdes_cdr_rate,
+ 		       sizeof(pdata->serdes_cdr_rate));
+ 	}
+ 
+ 	if (device_property_present(phy_dev, XGBE_PQ_SKEW_PROPERTY)) {
+ 		ret = device_property_read_u32_array(phy_dev,
+ 						     XGBE_PQ_SKEW_PROPERTY,
+ 						     pdata->serdes_pq_skew,
+ 						     XGBE_SPEEDS);
+ 		if (ret) {
+ 			dev_err(dev, "invalid %s property\n",
+ 				XGBE_PQ_SKEW_PROPERTY);
+ 			goto err_io;
+ 		}
+ 	} else {
+ 		memcpy(pdata->serdes_pq_skew, xgbe_serdes_pq_skew,
+ 		       sizeof(pdata->serdes_pq_skew));
+ 	}
+ 
+ 	if (device_property_present(phy_dev, XGBE_TX_AMP_PROPERTY)) {
+ 		ret = device_property_read_u32_array(phy_dev,
+ 						     XGBE_TX_AMP_PROPERTY,
+ 						     pdata->serdes_tx_amp,
+ 						     XGBE_SPEEDS);
+ 		if (ret) {
+ 			dev_err(dev, "invalid %s property\n",
+ 				XGBE_TX_AMP_PROPERTY);
+ 			goto err_io;
+ 		}
+ 	} else {
+ 		memcpy(pdata->serdes_tx_amp, xgbe_serdes_tx_amp,
+ 		       sizeof(pdata->serdes_tx_amp));
+ 	}
+ 
+ 	if (device_property_present(phy_dev, XGBE_DFE_CFG_PROPERTY)) {
+ 		ret = device_property_read_u32_array(phy_dev,
+ 						     XGBE_DFE_CFG_PROPERTY,
+ 						     pdata->serdes_dfe_tap_cfg,
+ 						     XGBE_SPEEDS);
+ 		if (ret) {
+ 			dev_err(dev, "invalid %s property\n",
+ 				XGBE_DFE_CFG_PROPERTY);
+ 			goto err_io;
+ 		}
+ 	} else {
+ 		memcpy(pdata->serdes_dfe_tap_cfg, xgbe_serdes_dfe_tap_cfg,
+ 		       sizeof(pdata->serdes_dfe_tap_cfg));
+ 	}
+ 
+ 	if (device_property_present(phy_dev, XGBE_DFE_ENA_PROPERTY)) {
+ 		ret = device_property_read_u32_array(phy_dev,
+ 						     XGBE_DFE_ENA_PROPERTY,
+ 						     pdata->serdes_dfe_tap_ena,
+ 						     XGBE_SPEEDS);
+ 		if (ret) {
+ 			dev_err(dev, "invalid %s property\n",
+ 				XGBE_DFE_ENA_PROPERTY);
+ 			goto err_io;
+ 		}
+ 	} else {
+ 		memcpy(pdata->serdes_dfe_tap_ena, xgbe_serdes_dfe_tap_ena,
+ 		       sizeof(pdata->serdes_dfe_tap_ena));
+ 	}
+ 
+ 	/* Obtain device settings unique to ACPI/OF */
+ 	if (pdata->use_acpi)
+ 		ret = xgbe_acpi_support(pdata);
+ 	else
+ 		ret = xgbe_of_support(pdata);
+ 	if (ret)
+ 		goto err_io;
+ 
+ 	/* Set the DMA coherency values */
+ 	attr = device_get_dma_attr(dev);
+ 	if (attr == DEV_DMA_NOT_SUPPORTED) {
+ 		dev_err(dev, "DMA is not supported");
+ 		goto err_io;
+ 	}
+ 	pdata->coherent = (attr == DEV_DMA_COHERENT);
+ 	if (pdata->coherent) {
++>>>>>>> 1831eff876bd (device property: ACPI: Make use of the new DMA Attribute APIs)
  		pdata->axdomain = XGBE_DMA_OS_AXDOMAIN;
  		pdata->arcache = XGBE_DMA_OS_ARCACHE;
  		pdata->awcache = XGBE_DMA_OS_AWCACHE;
* Unmerged path drivers/crypto/ccp/ccp-platform.c
* Unmerged path drivers/acpi/acpi_platform.c
* Unmerged path drivers/acpi/glue.c
* Unmerged path drivers/crypto/ccp/ccp-platform.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-main.c
