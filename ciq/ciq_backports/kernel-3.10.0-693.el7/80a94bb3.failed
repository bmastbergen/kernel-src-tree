scsi: aacraid: avoid open-coded upper_32_bits

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] aacraid: avoid open-coded upper_32_bits (Scott Benesh) [1384213]
Rebuild_FUZZ: 92.86%
commit-author Arnd Bergmann <arnd@arndb.de>
commit 80a94bb357813901e61f2dc80deae2015c50fdcd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/80a94bb3.failed

Shifting a dma_addr_t right by 32 bits causes a compile-time warning
when that type is only 32 bit wide:

drivers/scsi/aacraid/src.c: In function 'aac_src_start_adapter':
drivers/scsi/aacraid/src.c:414:29: error: right shift count >= width of type [-Werror=shift-count-overflow]

This changes the driver to use the predefined macros consistently,
including one correct but open-coded upper_32_bits() instance.

Fixes: d1ef4da8487f ("scsi: aacraid: added support for init_struct_8")
Fixes: 423400e64d37 ("scsi: aacraid: Include HBA direct interface")
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 80a94bb357813901e61f2dc80deae2015c50fdcd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/aacraid/src.c
diff --cc drivers/scsi/aacraid/src.c
index d48e0ad56e25,8e4e2ddbafd7..000000000000
--- a/drivers/scsi/aacraid/src.c
+++ b/drivers/scsi/aacraid/src.c
@@@ -479,48 -536,65 +479,83 @@@ static int aac_src_deliver_message(stru
  
  	atomic_inc(&dev->rrq_outstanding[vector_no]);
  
 -	if (native_hba) {
 +	if ((dev->comm_interface == AAC_COMM_MESSAGE_TYPE2) ||
 +		(dev->comm_interface == AAC_COMM_MESSAGE_TYPE3)) {
 +		/* Calculate the amount to the fibsize bits */
 +		fibsize = (hdr_size + 127) / 128 - 1;
 +		if (fibsize > (ALIGN32 - 1))
 +			return -EMSGSIZE;
 +		/* New FIB header, 32-bit */
  		address = fib->hw_fib_pa;
 -		fibsize = (fib->hbacmd_size + 127) / 128 - 1;
 -		if (fibsize > 31)
 -			fibsize = 31;
 +		fib->hw_fib_va->header.StructType = FIB_MAGIC2;
 +		fib->hw_fib_va->header.SenderFibAddress = (u32)address;
 +		fib->hw_fib_va->header.u.TimeStamp = 0;
 +		BUG_ON(upper_32_bits(address) != 0L);
  		address |= fibsize;
 -#if defined(writeq)
 -		src_writeq(dev, MUnit.IQN_L, (u64)address);
 -#else
 -		spin_lock_irqsave(&fib->dev->iq_lock, flags);
 -		src_writel(dev, MUnit.IQN_H,
 -			upper_32_bits(address) & 0xffffffff);
 -		src_writel(dev, MUnit.IQN_L, address & 0xffffffff);
 -		spin_unlock_irqrestore(&fib->dev->iq_lock, flags);
 -#endif
  	} else {
++<<<<<<< HEAD
 +		/* Calculate the amount to the fibsize bits */
 +		fibsize = (sizeof(struct aac_fib_xporthdr) + hdr_size + 127) / 128 - 1;
 +		if (fibsize > (ALIGN32 - 1))
 +			return -EMSGSIZE;
++=======
+ 		if (dev->comm_interface == AAC_COMM_MESSAGE_TYPE2 ||
+ 			dev->comm_interface == AAC_COMM_MESSAGE_TYPE3) {
+ 			/* Calculate the amount to the fibsize bits */
+ 			fibsize = (le16_to_cpu(fib->hw_fib_va->header.Size)
+ 				+ 127) / 128 - 1;
+ 			/* New FIB header, 32-bit */
+ 			address = fib->hw_fib_pa;
+ 			fib->hw_fib_va->header.StructType = FIB_MAGIC2;
+ 			fib->hw_fib_va->header.SenderFibAddress =
+ 				cpu_to_le32((u32)address);
+ 			fib->hw_fib_va->header.u.TimeStamp = 0;
+ 			WARN_ON(upper_32_bits(address) != 0L);
+ 		} else {
+ 			/* Calculate the amount to the fibsize bits */
+ 			fibsize = (sizeof(struct aac_fib_xporthdr) +
+ 				le16_to_cpu(fib->hw_fib_va->header.Size)
+ 				+ 127) / 128 - 1;
+ 			/* Fill XPORT header */
+ 			pFibX = (struct aac_fib_xporthdr *)
+ 				((unsigned char *)fib->hw_fib_va -
+ 				sizeof(struct aac_fib_xporthdr));
+ 			pFibX->Handle = fib->hw_fib_va->header.Handle;
+ 			pFibX->HostAddress =
+ 				cpu_to_le64((u64)fib->hw_fib_pa);
+ 			pFibX->Size = cpu_to_le32(
+ 				le16_to_cpu(fib->hw_fib_va->header.Size));
+ 			address = fib->hw_fib_pa -
+ 				(u64)sizeof(struct aac_fib_xporthdr);
+ 		}
+ 		if (fibsize > 31)
+ 			fibsize = 31;
+ 		address |= fibsize;
++>>>>>>> 80a94bb35781 (scsi: aacraid: avoid open-coded upper_32_bits)
 +
 +		/* Fill XPORT header */
 +		pFibX = (void *)fib->hw_fib_va - sizeof(struct aac_fib_xporthdr);
 +		pFibX->Handle = cpu_to_le32(fib->hw_fib_va->header.Handle);
 +		pFibX->HostAddress = cpu_to_le64(fib->hw_fib_pa);
 +		pFibX->Size = cpu_to_le32(hdr_size);
  
 +		/*
 +		 * The xport header has been 32-byte aligned for us so that fibsize
 +		 * can be masked out of this address by hardware. -- BenC
 +		 */
 +		address = fib->hw_fib_pa - sizeof(struct aac_fib_xporthdr);
 +		if (address & (ALIGN32 - 1))
 +			return -EINVAL;
 +		address |= fibsize;
 +	}
  #if defined(writeq)
 -		src_writeq(dev, MUnit.IQ_L, (u64)address);
 +	src_writeq(dev, MUnit.IQ_L, (u64)address);
  #else
 -		spin_lock_irqsave(&fib->dev->iq_lock, flags);
 -		src_writel(dev, MUnit.IQ_H,
 -			upper_32_bits(address) & 0xffffffff);
 -		src_writel(dev, MUnit.IQ_L, address & 0xffffffff);
 -		spin_unlock_irqrestore(&fib->dev->iq_lock, flags);
 +	spin_lock_irqsave(&fib->dev->iq_lock, flags);
 +	src_writel(dev, MUnit.IQ_H, upper_32_bits(address) & 0xffffffff);
 +	src_writel(dev, MUnit.IQ_L, address & 0xffffffff);
 +	spin_unlock_irqrestore(&fib->dev->iq_lock, flags);
  #endif
 -	}
  	return 0;
  }
  
* Unmerged path drivers/scsi/aacraid/src.c
