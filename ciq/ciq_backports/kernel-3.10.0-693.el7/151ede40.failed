mmc: sdhci-of-esdhc: fix host version for T4240-R1.0-R2.0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mmc] sdhci-of-esdhc: fix host version for T4240-R1.0-R2.0 (Don Zickus) [1430497]
Rebuild_FUZZ: 95.41%
commit-author yangbo lu <yangbo.lu@nxp.com>
commit 151ede40fd6999b0bdf5fd508e6035cf02b5dc8b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/151ede40.failed

The eSDHC of T4240-R1.0-R2.0 has incorrect vender version and spec version.
Acturally the right version numbers should be VVN=0x13 and SVN = 0x1.
This patch adds the GUTS driver support for eSDHC driver to match SoC.
And fix host version to avoid that incorrect version numbers break down
the ADMA data transfer.

	Signed-off-by: Yangbo Lu <yangbo.lu@nxp.com>
	Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
	Acked-by: Scott Wood <oss@buserror.net>
	Acked-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 151ede40fd6999b0bdf5fd508e6035cf02b5dc8b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/sdhci-of-esdhc.c
diff --cc drivers/mmc/host/sdhci-of-esdhc.c
index 5e68adc2461e,9a6eb4492172..000000000000
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@@ -23,11 -25,35 +24,38 @@@
  
  #define VENDOR_V_22	0x12
  #define VENDOR_V_23	0x13
++<<<<<<< HEAD
 +static u32 esdhc_readl(struct sdhci_host *host, int reg)
++=======
+ 
+ struct sdhci_esdhc {
+ 	u8 vendor_ver;
+ 	u8 spec_ver;
+ 	bool quirk_incorrect_hostver;
+ };
+ 
+ /**
+  * esdhc_read*_fixup - Fixup the value read from incompatible eSDHC register
+  *		       to make it compatible with SD spec.
+  *
+  * @host: pointer to sdhci_host
+  * @spec_reg: SD spec register address
+  * @value: 32bit eSDHC register value on spec_reg address
+  *
+  * In SD spec, there are 8/16/32/64 bits registers, while all of eSDHC
+  * registers are 32 bits. There are differences in register size, register
+  * address, register function, bit position and function between eSDHC spec
+  * and SD spec.
+  *
+  * Return a fixed up register value
+  */
+ static u32 esdhc_readl_fixup(struct sdhci_host *host,
+ 				     int spec_reg, u32 value)
++>>>>>>> 151ede40fd69 (mmc: sdhci-of-esdhc: fix host version for T4240-R1.0-R2.0)
  {
 -	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 -	struct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);
  	u32 ret;
  
 +	ret = in_be32(host->ioaddr + reg);
  	/*
  	 * The bit of ADMA flag in eSDHC is not compatible with standard
  	 * SDHC register, so set fake flag SDHCI_CAN_DO_ADMA2 when ADMA is
@@@ -48,16 -85,25 +76,28 @@@
  	return ret;
  }
  
 -static u16 esdhc_readw_fixup(struct sdhci_host *host,
 -				     int spec_reg, u32 value)
 +static u16 esdhc_readw(struct sdhci_host *host, int reg)
  {
+ 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+ 	struct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);
  	u16 ret;
 -	int shift = (spec_reg & 0x2) * 8;
 +	int base = reg & ~0x3;
 +	int shift = (reg & 0x2) * 8;
  
 -	if (spec_reg == SDHCI_HOST_VERSION)
 -		ret = value & 0xffff;
 +	if (unlikely(reg == SDHCI_HOST_VERSION))
 +		ret = in_be32(host->ioaddr + base) & 0xffff;
  	else
++<<<<<<< HEAD
 +		ret = (in_be32(host->ioaddr + base) >> shift) & 0xffff;
++=======
+ 		ret = (value >> shift) & 0xffff;
+ 	/* Workaround for T4240-R1.0-R2.0 eSDHC which has incorrect
+ 	 * vendor version and spec version information.
+ 	 */
+ 	if ((spec_reg == SDHCI_HOST_VERSION) &&
+ 	    (esdhc->quirk_incorrect_hostver))
+ 		ret = (VENDOR_V_23 << SDHCI_VENDOR_VER_SHIFT) | SDHCI_SPEC_200;
++>>>>>>> 151ede40fd69 (mmc: sdhci-of-esdhc: fix host version for T4240-R1.0-R2.0)
  	return ret;
  }
  
@@@ -217,57 -530,149 +257,130 @@@ static void esdhc_of_resume(struct sdhc
  }
  #endif
  
++<<<<<<< HEAD
 +static void esdhc_of_platform_init(struct sdhci_host *host)
++=======
+ static SIMPLE_DEV_PM_OPS(esdhc_of_dev_pm_ops,
+ 			esdhc_of_suspend,
+ 			esdhc_of_resume);
+ 
+ static const struct sdhci_ops sdhci_esdhc_be_ops = {
+ 	.read_l = esdhc_be_readl,
+ 	.read_w = esdhc_be_readw,
+ 	.read_b = esdhc_be_readb,
+ 	.write_l = esdhc_be_writel,
+ 	.write_w = esdhc_be_writew,
+ 	.write_b = esdhc_be_writeb,
+ 	.set_clock = esdhc_of_set_clock,
+ 	.enable_dma = esdhc_of_enable_dma,
+ 	.get_max_clock = esdhc_of_get_max_clock,
+ 	.get_min_clock = esdhc_of_get_min_clock,
+ 	.adma_workaround = esdhc_of_adma_workaround,
+ 	.set_bus_width = esdhc_pltfm_set_bus_width,
+ 	.reset = esdhc_reset,
+ 	.set_uhs_signaling = sdhci_set_uhs_signaling,
+ };
+ 
+ static const struct sdhci_ops sdhci_esdhc_le_ops = {
+ 	.read_l = esdhc_le_readl,
+ 	.read_w = esdhc_le_readw,
+ 	.read_b = esdhc_le_readb,
+ 	.write_l = esdhc_le_writel,
+ 	.write_w = esdhc_le_writew,
+ 	.write_b = esdhc_le_writeb,
+ 	.set_clock = esdhc_of_set_clock,
+ 	.enable_dma = esdhc_of_enable_dma,
+ 	.get_max_clock = esdhc_of_get_max_clock,
+ 	.get_min_clock = esdhc_of_get_min_clock,
+ 	.adma_workaround = esdhc_of_adma_workaround,
+ 	.set_bus_width = esdhc_pltfm_set_bus_width,
+ 	.reset = esdhc_reset,
+ 	.set_uhs_signaling = sdhci_set_uhs_signaling,
+ };
+ 
+ static const struct sdhci_pltfm_data sdhci_esdhc_be_pdata = {
+ 	.quirks = ESDHC_DEFAULT_QUIRKS | SDHCI_QUIRK_BROKEN_CARD_DETECTION
+ 		| SDHCI_QUIRK_NO_CARD_NO_RESET
+ 		| SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
+ 	.ops = &sdhci_esdhc_be_ops,
+ };
+ 
+ static const struct sdhci_pltfm_data sdhci_esdhc_le_pdata = {
+ 	.quirks = ESDHC_DEFAULT_QUIRKS | SDHCI_QUIRK_BROKEN_CARD_DETECTION
+ 		| SDHCI_QUIRK_NO_CARD_NO_RESET
+ 		| SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
+ 	.ops = &sdhci_esdhc_le_ops,
+ };
+ 
+ static struct soc_device_attribute soc_incorrect_hostver[] = {
+ 	{ .family = "QorIQ T4240", .revision = "1.0", },
+ 	{ .family = "QorIQ T4240", .revision = "2.0", },
+ 	{ },
+ };
+ 
+ static void esdhc_init(struct platform_device *pdev, struct sdhci_host *host)
++>>>>>>> 151ede40fd69 (mmc: sdhci-of-esdhc: fix host version for T4240-R1.0-R2.0)
  {
 -	struct sdhci_pltfm_host *pltfm_host;
 -	struct sdhci_esdhc *esdhc;
 -	u16 host_ver;
 +	u32 vvn;
  
 -	pltfm_host = sdhci_priv(host);
 -	esdhc = sdhci_pltfm_priv(pltfm_host);
 +	vvn = in_be32(host->ioaddr + SDHCI_SLOT_INT_STATUS);
 +	vvn = (vvn & SDHCI_VENDOR_VER_MASK) >> SDHCI_VENDOR_VER_SHIFT;
 +	if (vvn == VENDOR_V_22)
 +		host->quirks2 |= SDHCI_QUIRK2_HOST_NO_CMD23;
  
++<<<<<<< HEAD
 +	if (vvn > VENDOR_V_22)
 +		host->quirks &= ~SDHCI_QUIRK_NO_BUSY_IRQ;
++=======
+ 	host_ver = sdhci_readw(host, SDHCI_HOST_VERSION);
+ 	esdhc->vendor_ver = (host_ver & SDHCI_VENDOR_VER_MASK) >>
+ 			     SDHCI_VENDOR_VER_SHIFT;
+ 	esdhc->spec_ver = host_ver & SDHCI_SPEC_VER_MASK;
+ 	if (soc_device_match(soc_incorrect_hostver))
+ 		esdhc->quirk_incorrect_hostver = true;
+ 	else
+ 		esdhc->quirk_incorrect_hostver = false;
++>>>>>>> 151ede40fd69 (mmc: sdhci-of-esdhc: fix host version for T4240-R1.0-R2.0)
  }
  
 -static int sdhci_esdhc_probe(struct platform_device *pdev)
 -{
 -	struct sdhci_host *host;
 -	struct device_node *np;
 -	struct sdhci_pltfm_host *pltfm_host;
 -	struct sdhci_esdhc *esdhc;
 -	int ret;
 -
 -	np = pdev->dev.of_node;
 -
 -	if (of_property_read_bool(np, "little-endian"))
 -		host = sdhci_pltfm_init(pdev, &sdhci_esdhc_le_pdata,
 -					sizeof(struct sdhci_esdhc));
 -	else
 -		host = sdhci_pltfm_init(pdev, &sdhci_esdhc_be_pdata,
 -					sizeof(struct sdhci_esdhc));
 -
 -	if (IS_ERR(host))
 -		return PTR_ERR(host);
 -
 -	esdhc_init(pdev, host);
 -
 -	sdhci_get_of_property(pdev);
 -
 -	pltfm_host = sdhci_priv(host);
 -	esdhc = sdhci_pltfm_priv(pltfm_host);
 -	if (esdhc->vendor_ver == VENDOR_V_22)
 -		host->quirks2 |= SDHCI_QUIRK2_HOST_NO_CMD23;
 -
 -	if (esdhc->vendor_ver > VENDOR_V_22)
 -		host->quirks &= ~SDHCI_QUIRK_NO_BUSY_IRQ;
 -
 -	if (of_device_is_compatible(np, "fsl,p5040-esdhc") ||
 -	    of_device_is_compatible(np, "fsl,p5020-esdhc") ||
 -	    of_device_is_compatible(np, "fsl,p4080-esdhc") ||
 -	    of_device_is_compatible(np, "fsl,p1020-esdhc") ||
 -	    of_device_is_compatible(np, "fsl,t1040-esdhc") ||
 -	    of_device_is_compatible(np, "fsl,ls1021a-esdhc"))
 -		host->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;
 -
 -	if (of_device_is_compatible(np, "fsl,ls1021a-esdhc"))
 -		host->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;
 -
 -	if (of_device_is_compatible(np, "fsl,p2020-esdhc")) {
 -		/*
 -		 * Freescale messed up with P2020 as it has a non-standard
 -		 * host control register
 -		 */
 -		host->quirks2 |= SDHCI_QUIRK2_BROKEN_HOST_CONTROL;
 -	}
 -
 -	/* call to generic mmc_of_parse to support additional capabilities */
 -	ret = mmc_of_parse(host->mmc);
 -	if (ret)
 -		goto err;
 +static const struct sdhci_ops sdhci_esdhc_ops = {
 +	.read_l = esdhc_readl,
 +	.read_w = esdhc_readw,
 +	.read_b = esdhc_readb,
 +	.write_l = esdhc_writel,
 +	.write_w = esdhc_writew,
 +	.write_b = esdhc_writeb,
 +	.set_clock = esdhc_of_set_clock,
 +	.enable_dma = esdhc_of_enable_dma,
 +	.get_max_clock = esdhc_of_get_max_clock,
 +	.get_min_clock = esdhc_of_get_min_clock,
 +	.platform_init = esdhc_of_platform_init,
 +#ifdef CONFIG_PM
 +	.platform_suspend = esdhc_of_suspend,
 +	.platform_resume = esdhc_of_resume,
 +#endif
 +	.adma_workaround = esdhci_of_adma_workaround,
 +};
  
 -	mmc_of_parse_voltage(np, &host->ocr_mask);
 +static const struct sdhci_pltfm_data sdhci_esdhc_pdata = {
 +	/*
 +	 * card detection could be handled via GPIO
 +	 * eSDHC cannot support End Attribute in NOP ADMA descriptor
 +	 */
 +	.quirks = ESDHC_DEFAULT_QUIRKS | SDHCI_QUIRK_BROKEN_CARD_DETECTION
 +		| SDHCI_QUIRK_NO_CARD_NO_RESET
 +		| SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
 +	.ops = &sdhci_esdhc_ops,
 +};
  
 -	ret = sdhci_add_host(host);
 -	if (ret)
 -		goto err;
 +static int sdhci_esdhc_probe(struct platform_device *pdev)
 +{
 +	return sdhci_pltfm_register(pdev, &sdhci_esdhc_pdata);
 +}
  
 -	return 0;
 - err:
 -	sdhci_pltfm_free(pdev);
 -	return ret;
 +static int sdhci_esdhc_remove(struct platform_device *pdev)
 +{
 +	return sdhci_pltfm_unregister(pdev);
  }
  
  static const struct of_device_id sdhci_esdhc_of_match[] = {
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 2ecc2f5f10e1..db306cef888a 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -123,6 +123,7 @@ config MMC_SDHCI_OF_ESDHC
 	depends on MMC_SDHCI_PLTFM
 	depends on PPC || ARCH_MXC || ARCH_LAYERSCAPE
 	select MMC_SDHCI_IO_ACCESSORS
+	select FSL_GUTS
 	help
 	  This selects the Freescale eSDHC controller support.
 
* Unmerged path drivers/mmc/host/sdhci-of-esdhc.c
