HID: wacom: cleanup input devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: cleanup input devices (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 91.80%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 17f28470f4c705811ad6870162f30275143da235
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/17f28470.failed

Just some cleaning up when the input devices are unregistered.

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 17f28470f4c705811ad6870162f30275143da235)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,9a410351d56a..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1095,67 -1012,435 +1095,178 @@@ static int wacom_battery_get_property(s
  	return ret;
  }
  
 -static int wacom_ac_get_property(struct power_supply *psy,
 -				enum power_supply_property psp,
 -				union power_supply_propval *val)
 -{
 -	struct wacom *wacom = power_supply_get_drvdata(psy);
 -	int ret = 0;
 -
 -	switch (psp) {
 -	case POWER_SUPPLY_PROP_PRESENT:
 -		/* fall through */
 -	case POWER_SUPPLY_PROP_ONLINE:
 -		val->intval = wacom->wacom_wac.ps_connected;
 -		break;
 -	case POWER_SUPPLY_PROP_SCOPE:
 -		val->intval = POWER_SUPPLY_SCOPE_DEVICE;
 -		break;
 -	default:
 -		ret = -EINVAL;
 -		break;
 -	}
 -	return ret;
 -}
 -
  static int wacom_initialize_battery(struct wacom *wacom)
 -{
 -	static atomic_t battery_no = ATOMIC_INIT(0);
 -	struct power_supply_config psy_cfg = { .drv_data = wacom, };
 -	unsigned long n;
 -
 -	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_BATTERY) {
 -		struct power_supply_desc *bat_desc = &wacom->battery_desc;
 -		struct power_supply_desc *ac_desc = &wacom->ac_desc;
 -		n = atomic_inc_return(&battery_no) - 1;
 -
 -		bat_desc->properties = wacom_battery_props;
 -		bat_desc->num_properties = ARRAY_SIZE(wacom_battery_props);
 -		bat_desc->get_property = wacom_battery_get_property;
 -		sprintf(wacom->wacom_wac.bat_name, "wacom_battery_%ld", n);
 -		bat_desc->name = wacom->wacom_wac.bat_name;
 -		bat_desc->type = POWER_SUPPLY_TYPE_BATTERY;
 -		bat_desc->use_for_apm = 0;
 -
 -		ac_desc->properties = wacom_ac_props;
 -		ac_desc->num_properties = ARRAY_SIZE(wacom_ac_props);
 -		ac_desc->get_property = wacom_ac_get_property;
 -		sprintf(wacom->wacom_wac.ac_name, "wacom_ac_%ld", n);
 -		ac_desc->name = wacom->wacom_wac.ac_name;
 -		ac_desc->type = POWER_SUPPLY_TYPE_MAINS;
 -		ac_desc->use_for_apm = 0;
 -
 -		wacom->battery = power_supply_register(&wacom->hdev->dev,
 -					      &wacom->battery_desc, &psy_cfg);
 -		if (IS_ERR(wacom->battery))
 -			return PTR_ERR(wacom->battery);
 -
 -		power_supply_powers(wacom->battery, &wacom->hdev->dev);
 -
 -		wacom->ac = power_supply_register(&wacom->hdev->dev,
 -						  &wacom->ac_desc,
 -						  &psy_cfg);
 -		if (IS_ERR(wacom->ac)) {
 -			power_supply_unregister(wacom->battery);
 -			return PTR_ERR(wacom->ac);
 -		}
 -
 -		power_supply_powers(wacom->ac, &wacom->hdev->dev);
 -	}
 -
 -	return 0;
 -}
 -
 -static void wacom_destroy_battery(struct wacom *wacom)
 -{
 -	if (wacom->battery) {
 -		power_supply_unregister(wacom->battery);
 -		wacom->battery = NULL;
 -		power_supply_unregister(wacom->ac);
 -		wacom->ac = NULL;
 -	}
 -}
 -
 -static ssize_t wacom_show_speed(struct device *dev,
 -				struct device_attribute
 -				*attr, char *buf)
 -{
 -	struct hid_device *hdev = to_hid_device(dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -
 -	return snprintf(buf, PAGE_SIZE, "%i\n", wacom->wacom_wac.bt_high_speed);
 -}
 -
 -static ssize_t wacom_store_speed(struct device *dev,
 -				struct device_attribute *attr,
 -				const char *buf, size_t count)
 -{
 -	struct hid_device *hdev = to_hid_device(dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	u8 new_speed;
 -
 -	if (kstrtou8(buf, 0, &new_speed))
 -		return -EINVAL;
 -
 -	if (new_speed != 0 && new_speed != 1)
 -		return -EINVAL;
 -
 -	wacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);
 -
 -	return count;
 -}
 -
 -static DEVICE_ATTR(speed, DEV_ATTR_RW_PERM,
 -		wacom_show_speed, wacom_store_speed);
 -
 -
 -static ssize_t wacom_show_remote_mode(struct kobject *kobj,
 -				      struct kobj_attribute *kattr,
 -				      char *buf, int index)
 -{
 -	struct device *dev = kobj_to_dev(kobj->parent);
 -	struct hid_device *hdev = to_hid_device(dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	u8 mode;
 -
 -	mode = wacom->led.select[index];
 -	if (mode >= 0 && mode < 3)
 -		return snprintf(buf, PAGE_SIZE, "%d\n", mode);
 -	else
 -		return snprintf(buf, PAGE_SIZE, "%d\n", -1);
 -}
 -
 -#define DEVICE_EKR_ATTR_GROUP(SET_ID)					\
 -static ssize_t wacom_show_remote##SET_ID##_mode(struct kobject *kobj,	\
 -			       struct kobj_attribute *kattr, char *buf)	\
 -{									\
 -	return wacom_show_remote_mode(kobj, kattr, buf, SET_ID);	\
 -}									\
 -static struct kobj_attribute remote##SET_ID##_mode_attr = {		\
 -	.attr = {.name = "remote_mode",					\
 -		.mode = DEV_ATTR_RO_PERM},				\
 -	.show = wacom_show_remote##SET_ID##_mode,			\
 -};									\
 -static struct attribute *remote##SET_ID##_serial_attrs[] = {		\
 -	&remote##SET_ID##_mode_attr.attr,				\
 -	NULL								\
 -};									\
 -static struct attribute_group remote##SET_ID##_serial_group = {		\
 -	.name = NULL,							\
 -	.attrs = remote##SET_ID##_serial_attrs,				\
 -}
 -
 -DEVICE_EKR_ATTR_GROUP(0);
 -DEVICE_EKR_ATTR_GROUP(1);
 -DEVICE_EKR_ATTR_GROUP(2);
 -DEVICE_EKR_ATTR_GROUP(3);
 -DEVICE_EKR_ATTR_GROUP(4);
 -
 -int wacom_remote_create_attr_group(struct wacom *wacom, __u32 serial, int index)
  {
  	int error = 0;
 -	char *buf;
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
  
 -	wacom_wac->serial[index] = serial;
 +	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_MONITOR) {
 +		wacom->battery.properties = wacom_battery_props;
 +		wacom->battery.num_properties = ARRAY_SIZE(wacom_battery_props);
 +		wacom->battery.get_property = wacom_battery_get_property;
 +		wacom->battery.name = "wacom_battery";
 +		wacom->battery.type = POWER_SUPPLY_TYPE_BATTERY;
 +		wacom->battery.use_for_apm = 0;
  
 -	buf = kzalloc(WAC_REMOTE_SERIAL_MAX_STRLEN, GFP_KERNEL);
 -	if (!buf)
 -		return -ENOMEM;
 -	snprintf(buf, WAC_REMOTE_SERIAL_MAX_STRLEN, "%d", serial);
 -	wacom->remote_group[index].name = buf;
 +		error = power_supply_register(&wacom->usbdev->dev,
 +					      &wacom->battery);
  
 -	error = sysfs_create_group(wacom->remote_dir,
 -				   &wacom->remote_group[index]);
 -	if (error) {
 -		hid_err(wacom->hdev,
 -			"cannot create sysfs group err: %d\n", error);
 -		kobject_put(wacom->remote_dir);
 -		return error;
 +		if (!error)
 +			power_supply_powers(&wacom->battery,
 +					    &wacom->usbdev->dev);
  	}
  
 -	return 0;
 -}
 -
 -void wacom_remote_destroy_attr_group(struct wacom *wacom, __u32 serial)
 -{
 -	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
 -	int i;
 -
 -	if (!serial)
 -		return;
 -
 -	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
 -		if (wacom_wac->serial[i] == serial) {
 -			wacom_wac->serial[i] = 0;
 -			wacom->led.select[i] = WACOM_STATUS_UNKNOWN;
 -			if (wacom->remote_group[i].name) {
 -				sysfs_remove_group(wacom->remote_dir,
 -						   &wacom->remote_group[i]);
 -				kfree(wacom->remote_group[i].name);
 -				wacom->remote_group[i].name = NULL;
 -			}
 -		}
 -	}
 -}
 -
 -static int wacom_cmd_unpair_remote(struct wacom *wacom, unsigned char selector)
 -{
 -	const size_t buf_size = 2;
 -	unsigned char *buf;
 -	int retval;
 -
 -	buf = kzalloc(buf_size, GFP_KERNEL);
 -	if (!buf)
 -		return -ENOMEM;
 -
 -	buf[0] = WAC_CMD_DELETE_PAIRING;
 -	buf[1] = selector;
 -
 -	retval = wacom_set_report(wacom->hdev, HID_OUTPUT_REPORT, buf,
 -				  buf_size, WAC_CMD_RETRIES);
 -	kfree(buf);
 -
 -	return retval;
 -}
 -
 -static ssize_t wacom_store_unpair_remote(struct kobject *kobj,
 -					 struct kobj_attribute *attr,
 -					 const char *buf, size_t count)
 -{
 -	unsigned char selector = 0;
 -	struct device *dev = kobj_to_dev(kobj->parent);
 -	struct hid_device *hdev = to_hid_device(dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	int err;
 -
 -	if (!strncmp(buf, "*\n", 2)) {
 -		selector = WAC_CMD_UNPAIR_ALL;
 -	} else {
 -		hid_info(wacom->hdev, "remote: unrecognized unpair code: %s\n",
 -			 buf);
 -		return -1;
 -	}
 -
 -	mutex_lock(&wacom->lock);
 -
 -	err = wacom_cmd_unpair_remote(wacom, selector);
 -	mutex_unlock(&wacom->lock);
 -
 -	return err < 0 ? err : count;
 +	return error;
  }
  
 -static struct kobj_attribute unpair_remote_attr = {
 -	.attr = {.name = "unpair_remote", .mode = 0200},
 -	.store = wacom_store_unpair_remote,
 -};
 -
 -static const struct attribute *remote_unpair_attrs[] = {
 -	&unpair_remote_attr.attr,
 -	NULL
 -};
 -
 -static int wacom_initialize_remote(struct wacom *wacom)
 +static void wacom_destroy_battery(struct wacom *wacom)
  {
 -	int error = 0;
 -	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 -	int i;
 -
 -	if (wacom->wacom_wac.features.type != REMOTE)
 -		return 0;
 -
 -	wacom->remote_group[0] = remote0_serial_group;
 -	wacom->remote_group[1] = remote1_serial_group;
 -	wacom->remote_group[2] = remote2_serial_group;
 -	wacom->remote_group[3] = remote3_serial_group;
 -	wacom->remote_group[4] = remote4_serial_group;
 -
 -	wacom->remote_dir = kobject_create_and_add("wacom_remote",
 -						   &wacom->hdev->dev.kobj);
 -	if (!wacom->remote_dir)
 -		return -ENOMEM;
 -
 -	error = sysfs_create_files(wacom->remote_dir, remote_unpair_attrs);
 -
 -	if (error) {
 -		hid_err(wacom->hdev,
 -			"cannot create sysfs group err: %d\n", error);
 -		return error;
 -	}
 -
 -	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
 -		wacom->led.select[i] = WACOM_STATUS_UNKNOWN;
 -		wacom_wac->serial[i] = 0;
 +	if (wacom->wacom_wac.features.quirks & WACOM_QUIRK_MONITOR &&
 +	    wacom->battery.dev) {
 +		power_supply_unregister(&wacom->battery);
 +		wacom->battery.dev = NULL;
  	}
 -
 -	return 0;
  }
  
 -static struct input_dev *wacom_allocate_input(struct wacom *wacom)
 +static int wacom_register_input(struct wacom *wacom)
  {
  	struct input_dev *input_dev;
 -	struct hid_device *hdev = wacom->hdev;
 +	struct usb_interface *intf = wacom->intf;
 +	struct usb_device *dev = interface_to_usbdev(intf);
  	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 +	int error;
  
  	input_dev = input_allocate_device();
 -	if (!input_dev)
 -		return NULL;
 +	if (!input_dev) {
 +		error = -ENOMEM;
 +		goto fail1;
 +	}
  
 -	input_dev->name = wacom_wac->features.name;
 -	input_dev->phys = hdev->phys;
 -	input_dev->dev.parent = &hdev->dev;
 +	input_dev->name = wacom_wac->name;
 +	input_dev->dev.parent = &intf->dev;
  	input_dev->open = wacom_open;
  	input_dev->close = wacom_close;
 -	input_dev->uniq = hdev->uniq;
 -	input_dev->id.bustype = hdev->bus;
 -	input_dev->id.vendor  = hdev->vendor;
 -	input_dev->id.product = wacom_wac->pid ? wacom_wac->pid : hdev->product;
 -	input_dev->id.version = hdev->version;
 +	usb_to_input_id(dev, &input_dev->id);
  	input_set_drvdata(input_dev, wacom);
  
 -	return input_dev;
 -}
 +	wacom_wac->input = input_dev;
 +	error = wacom_setup_input_capabilities(input_dev, wacom_wac);
 +	if (error)
 +		goto fail1;
  
++<<<<<<< HEAD
 +	error = input_register_device(input_dev);
 +	if (error)
 +		goto fail2;
++=======
+ static void wacom_clean_inputs(struct wacom *wacom)
+ {
+ 	if (wacom->wacom_wac.pen_input) {
+ 		if (wacom->wacom_wac.pen_registered)
+ 			input_unregister_device(wacom->wacom_wac.pen_input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.pen_input);
+ 	}
+ 	if (wacom->wacom_wac.touch_input) {
+ 		if (wacom->wacom_wac.touch_registered)
+ 			input_unregister_device(wacom->wacom_wac.touch_input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.touch_input);
+ 	}
+ 	if (wacom->wacom_wac.pad_input) {
+ 		if (wacom->wacom_wac.pad_registered)
+ 			input_unregister_device(wacom->wacom_wac.pad_input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.pad_input);
+ 	}
+ 	kobject_put(wacom->remote_dir);
+ 	wacom->wacom_wac.pen_input = NULL;
+ 	wacom->wacom_wac.touch_input = NULL;
+ 	wacom->wacom_wac.pad_input = NULL;
+ 	wacom->wacom_wac.pen_registered = false;
+ 	wacom->wacom_wac.touch_registered = false;
+ 	wacom->wacom_wac.pad_registered = false;
+ 	wacom_destroy_leds(wacom);
+ }
+ 
+ static int wacom_allocate_inputs(struct wacom *wacom)
+ {
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	wacom_wac->pen_input = wacom_allocate_input(wacom);
+ 	wacom_wac->touch_input = wacom_allocate_input(wacom);
+ 	wacom_wac->pad_input = wacom_allocate_input(wacom);
+ 	if (!wacom_wac->pen_input || !wacom_wac->touch_input || !wacom_wac->pad_input) {
+ 		wacom_clean_inputs(wacom);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	wacom_wac->pen_input->name = wacom_wac->pen_name;
+ 	wacom_wac->touch_input->name = wacom_wac->touch_name;
+ 	wacom_wac->pad_input->name = wacom_wac->pad_name;
+ 
+ 	return 0;
+ }
+ 
+ static int wacom_register_inputs(struct wacom *wacom)
+ {
+ 	struct input_dev *pen_input_dev, *touch_input_dev, *pad_input_dev;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 	int error = 0;
+ 
+ 	pen_input_dev = wacom_wac->pen_input;
+ 	touch_input_dev = wacom_wac->touch_input;
+ 	pad_input_dev = wacom_wac->pad_input;
+ 
+ 	if (!pen_input_dev || !touch_input_dev || !pad_input_dev)
+ 		return -EINVAL;
+ 
+ 	error = wacom_setup_pen_input_capabilities(pen_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no pen in use on this interface */
+ 		input_free_device(pen_input_dev);
+ 		wacom_wac->pen_input = NULL;
+ 		pen_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(pen_input_dev);
+ 		if (error)
+ 			goto fail_register_pen_input;
+ 		wacom_wac->pen_registered = true;
+ 	}
+ 
+ 	error = wacom_setup_touch_input_capabilities(touch_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no touch in use on this interface */
+ 		input_free_device(touch_input_dev);
+ 		wacom_wac->touch_input = NULL;
+ 		touch_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(touch_input_dev);
+ 		if (error)
+ 			goto fail_register_touch_input;
+ 		wacom_wac->touch_registered = true;
+ 	}
+ 
+ 	error = wacom_setup_pad_input_capabilities(pad_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no pad in use on this interface */
+ 		input_free_device(pad_input_dev);
+ 		wacom_wac->pad_input = NULL;
+ 		pad_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(pad_input_dev);
+ 		if (error)
+ 			goto fail_register_pad_input;
+ 		wacom_wac->pad_registered = true;
+ 
+ 		error = wacom_initialize_leds(wacom);
+ 		if (error)
+ 			goto fail_leds;
+ 
+ 		error = wacom_initialize_remote(wacom);
+ 		if (error)
+ 			goto fail_remote;
+ 	}
++>>>>>>> 17f28470f4c7 (HID: wacom: cleanup input devices)
  
  	return 0;
  
* Unmerged path drivers/hid/wacom_sys.c
