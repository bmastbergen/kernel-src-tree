autofs: use dentry flags to block walks during expire

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ian Kent <raven@themaw.net>
commit 7cbdb4a286a60c5d519cb9223fe2134d26870d39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7cbdb4a2.failed

Somewhere along the way the autofs expire operation has changed to hold
a spin lock over expired dentry selection.  The autofs indirect mount
expired dentry selection is complicated and quite lengthy so it isn't
appropriate to hold a spin lock over the operation.

Commit 47be61845c77 ("fs/dcache.c: avoid soft-lockup in dput()") added a
might_sleep() to dput() causing a WARN_ONCE() about this usage to be
issued.

But the spin lock doesn't need to be held over this check, the autofs
dentry info.  flags are enough to block walks into dentrys during the
expire.

I've left the direct mount expire as it is (for now) because it is much
simpler and quicker than the indirect mount expire and adding spin lock
release and re-aquires would do nothing more than add overhead.

Fixes: 47be61845c77 ("fs/dcache.c: avoid soft-lockup in dput()")
Link: http://lkml.kernel.org/r/20160912014017.1773.73060.stgit@pluto.themaw.net
	Signed-off-by: Ian Kent <raven@themaw.net>
	Reported-by: Takashi Iwai <tiwai@suse.de>
	Tested-by: Takashi Iwai <tiwai@suse.de>
	Cc: Takashi Iwai <tiwai@suse.de>
	Cc: NeilBrown <neilb@suse.com>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 7cbdb4a286a60c5d519cb9223fe2134d26870d39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/autofs4/expire.c
diff --cc fs/autofs4/expire.c
index 683a5b9ce22a,d8e6d421c27f..000000000000
--- a/fs/autofs4/expire.c
+++ b/fs/autofs4/expire.c
@@@ -450,31 -444,46 +452,58 @@@ struct dentry *autofs4_expire_indirect(
  
  	dentry = NULL;
  	while ((dentry = get_next_positive_subdir(dentry, root))) {
+ 		int flags = how;
+ 
  		spin_lock(&sbi->fs_lock);
  		ino = autofs4_dentry_ino(dentry);
++<<<<<<< HEAD
 +		if (ino->flags & AUTOFS_INF_NO_RCU)
 +			expired = NULL;
 +		else
 +			expired = should_expire(dentry, mnt, timeout, how);
 +		if (!expired) {
++=======
+ 		if (ino->flags & AUTOFS_INF_WANT_EXPIRE) {
++>>>>>>> 7cbdb4a286a6 (autofs: use dentry flags to block walks during expire)
  			spin_unlock(&sbi->fs_lock);
  			continue;
  		}
+ 		spin_unlock(&sbi->fs_lock);
+ 
+ 		expired = should_expire(dentry, mnt, timeout, flags);
+ 		if (!expired)
+ 			continue;
+ 
+ 		spin_lock(&sbi->fs_lock);
  		ino = autofs4_dentry_ino(expired);
 -		ino->flags |= AUTOFS_INF_WANT_EXPIRE;
 +		ino->flags |= AUTOFS_INF_NO_RCU;
  		spin_unlock(&sbi->fs_lock);
  		synchronize_rcu();
- 		spin_lock(&sbi->fs_lock);
- 		if (should_expire(expired, mnt, timeout, how)) {
- 			if (expired != dentry)
- 				dput(dentry);
- 			goto found;
- 		}
  
++<<<<<<< HEAD
 +		ino->flags &= ~AUTOFS_INF_NO_RCU;
++=======
+ 		/* Make sure a reference is not taken on found if
+ 		 * things have changed.
+ 		 */
+ 		flags &= ~AUTOFS_EXP_LEAVES;
+ 		found = should_expire(expired, mnt, timeout, how);
+ 		if (!found || found != expired)
+ 			/* Something has changed, continue */
+ 			goto next;
+ 
  		if (expired != dentry)
- 			dput(expired);
+ 			dput(dentry);
+ 
+ 		spin_lock(&sbi->fs_lock);
+ 		goto found;
+ next:
+ 		spin_lock(&sbi->fs_lock);
+ 		ino->flags &= ~AUTOFS_INF_WANT_EXPIRE;
  		spin_unlock(&sbi->fs_lock);
++>>>>>>> 7cbdb4a286a6 (autofs: use dentry flags to block walks during expire)
+ 		if (expired != dentry)
+ 			dput(expired);
  	}
  	return NULL;
  
@@@ -501,19 -500,30 +530,31 @@@ int autofs4_expire_wait(struct dentry *
  	struct autofs_sb_info *sbi = autofs4_sbi(dentry->d_sb);
  	struct autofs_info *ino = autofs4_dentry_ino(dentry);
  	int status;
+ 	int state;
  
  	/* Block on any pending expire */
 -	if (!(ino->flags & AUTOFS_INF_WANT_EXPIRE))
 +	if (!(ino->flags & (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU)))
  		return 0;
  	if (rcu_walk)
  		return -ECHILD;
  
+ retry:
  	spin_lock(&sbi->fs_lock);
- 	if (ino->flags & AUTOFS_INF_EXPIRING) {
+ 	state = ino->flags & (AUTOFS_INF_WANT_EXPIRE | AUTOFS_INF_EXPIRING);
+ 	if (state == AUTOFS_INF_WANT_EXPIRE) {
+ 		spin_unlock(&sbi->fs_lock);
+ 		/*
+ 		 * Possibly being selected for expire, wait until
+ 		 * it's selected or not.
+ 		 */
+ 		schedule_timeout_uninterruptible(HZ/10);
+ 		goto retry;
+ 	}
+ 	if (state & AUTOFS_INF_EXPIRING) {
  		spin_unlock(&sbi->fs_lock);
  
 -		pr_debug("waiting for expire %p name=%pd\n", dentry, dentry);
 +		DPRINTK("waiting for expire %p name=%.*s",
 +			 dentry, dentry->d_name.len, dentry->d_name.name);
  
  		status = autofs4_wait(sbi, dentry, NFY_NONE);
  		wait_for_completion(&ino->expire_complete);
* Unmerged path fs/autofs4/expire.c
