btrfs: make state preallocation more speculative in __set_extent_bit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Sterba <dsterba@suse.com>
commit 059f791c6bbaba72dc3c1bd6e2657aacc8552849
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/059f791c.failed

Similar to __clear_extent_bit, do not fail if the state preallocation
fails as we might not need it. One less BUG_ON.

	Signed-off-by: David Sterba <dsterba@suse.com>
(cherry picked from commit 059f791c6bbaba72dc3c1bd6e2657aacc8552849)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/extent_io.c
diff --cc fs/btrfs/extent_io.c
index 4153678ab6b8,8707bcc615ff..000000000000
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@@ -872,9 -872,15 +872,19 @@@ __set_extent_bit(struct extent_io_tree 
  
  	bits |= EXTENT_FIRST_DELALLOC;
  again:
++<<<<<<< HEAD
 +	if (!prealloc && (mask & __GFP_WAIT)) {
++=======
+ 	if (!prealloc && gfpflags_allow_blocking(mask)) {
+ 		/*
+ 		 * Don't care for allocation failure here because we might end
+ 		 * up not needing the pre-allocated extent state at all, which
+ 		 * is the case if we only have in the tree extent states that
+ 		 * cover our input range and don't cover too any other range.
+ 		 * If we end up needing a new extent state we allocate it later.
+ 		 */
++>>>>>>> 059f791c6bba (btrfs: make state preallocation more speculative in __set_extent_bit)
  		prealloc = alloc_extent_state(mask);
- 		BUG_ON(!prealloc);
  	}
  
  	spin_lock(&tree->lock);
* Unmerged path fs/btrfs/extent_io.c
