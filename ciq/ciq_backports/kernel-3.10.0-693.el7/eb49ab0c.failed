IB/mlx5: Add port counter support for raw packet QP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alex Vesker <valex@mellanox.com>
commit eb49ab0c5f3d8e5efb696f100978bf966ecf6be3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/eb49ab0c.failed

Counters weren't updated due to raw packet QPs' traffic since the
counter-id was not associated with the QP. Added support for
associating the q-counter-id with the raw packet QP. The attachment
is done only when changing RQ raw packet QP state from RST to INIT
in modify-RQ command. FW support is required for the above, without
this support raw packet QP counters will not count.

	Signed-off-by: Alex Vesker <valex@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit eb49ab0c5f3d8e5efb696f100978bf966ecf6be3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 0f82de09f2d9,b4dc71bb36eb..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -77,6 -77,21 +77,24 @@@ struct mlx5_wqe_eth_pad 
  	u8 rsvd0[16];
  };
  
++<<<<<<< HEAD
++=======
+ enum raw_qp_set_mask_map {
+ 	MLX5_RAW_QP_MOD_SET_RQ_Q_CTR_ID		= 1UL << 0,
+ };
+ 
+ struct mlx5_modify_raw_qp_param {
+ 	u16 operation;
+ 
+ 	u32 set_mask; /* raw_qp_set_mask_map */
+ 	u8 rq_q_ctr_id;
+ };
+ 
+ static void get_cqs(enum ib_qp_type qp_type,
+ 		    struct ib_cq *ib_send_cq, struct ib_cq *ib_recv_cq,
+ 		    struct mlx5_ib_cq **send_cq, struct mlx5_ib_cq **recv_cq);
+ 
++>>>>>>> eb49ab0c5f3d (IB/mlx5: Add port counter support for raw packet QP)
  static int is_qp0(enum ib_qp_type qp_type)
  {
  	return qp_type == IB_QPT_SMI;
@@@ -2470,8 -2539,8 +2501,9 @@@ static int __mlx5_ib_modify_qp(struct i
  	struct mlx5_ib_qp_base *base = &qp->trans_qp.base;
  	struct mlx5_ib_cq *send_cq, *recv_cq;
  	struct mlx5_qp_context *context;
 +	struct mlx5_modify_qp_mbox_in *in;
  	struct mlx5_ib_pd *pd;
+ 	struct mlx5_ib_port *mibport = NULL;
  	enum mlx5_qp_state mlx5_cur, mlx5_new;
  	enum mlx5_qp_optpar optpar;
  	int sqd_event;
@@@ -2647,13 -2715,21 +2678,27 @@@
  	op = optab[mlx5_cur][mlx5_new];
  	optpar = ib_mask_to_mlx5_opt(attr_mask);
  	optpar &= opt_mask[mlx5_cur][mlx5_new][mlx5_st];
 +	in->optparam = cpu_to_be32(optpar);
  
++<<<<<<< HEAD
 +	if (qp->ibqp.qp_type == IB_QPT_RAW_PACKET)
 +		err = modify_raw_packet_qp(dev, qp, op);
 +	else
 +		err = mlx5_core_qp_modify(dev->mdev, op, in, sqd_event,
++=======
+ 	if (qp->ibqp.qp_type == IB_QPT_RAW_PACKET) {
+ 		struct mlx5_modify_raw_qp_param raw_qp_param = {};
+ 
+ 		raw_qp_param.operation = op;
+ 		if (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {
+ 			raw_qp_param.rq_q_ctr_id = mibport->q_cnt_id;
+ 			raw_qp_param.set_mask |= MLX5_RAW_QP_MOD_SET_RQ_Q_CTR_ID;
+ 		}
+ 		err = modify_raw_packet_qp(dev, qp, &raw_qp_param);
+ 	} else {
+ 		err = mlx5_core_qp_modify(dev->mdev, op, optpar, context,
++>>>>>>> eb49ab0c5f3d (IB/mlx5: Add port counter support for raw packet QP)
  					  &base->mqp);
 -	}
 -
  	if (err)
  		goto out;
  
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
