switchdev; add VLAN support for port's bridge_getlink

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] switchdev: add VLAN support for port's bridge_getlink (Ivan Vecera) [1275772 1297841 1331748]
Rebuild_FUZZ: 98.11%
commit-author Scott Feldman <sfeldma@gmail.com>
commit 7d4f8d871ab15bd50a5771382ca2c9355b38d73c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/7d4f8d87.failed

One more missing piece of the puzzle.  Add vlan dump support to switchdev
port's bridge_getlink.  iproute2 "bridge vlan show" cmd already knows how
to show the vlans installed on the bridge and the device , but (until now)
no one implemented the port vlan part of the netlink PF_BRIDGE:RTM_GETLINK
msg.  Before this patch, "bridge vlan show":

	$ bridge -c vlan show
	port    vlan ids
	sw1p1    30-34			<< bridge side vlans
		 57

	sw1p1				<< device side vlans (missing)

	sw1p2    57

	sw1p2

	sw1p3

	sw1p4

	br0     None

(When the port is bridged, the output repeats the vlan list for the vlans
on the bridge side of the port and the vlans on the device side of the
port.  The listing above show no vlans for the device side even though they
are installed).

After this patch:

	$ bridge -c vlan show
	port    vlan ids
	sw1p1    30-34			<< bridge side vlan
		 57

	sw1p1    30-34			<< device side vlans
		 57
		 3840 PVID

	sw1p2    57

	sw1p2    57
		 3840 PVID

	sw1p3    3842 PVID

	sw1p4    3843 PVID

	br0     None

I re-used ndo_dflt_bridge_getlink to add vlan fill call-back func.
switchdev support adds an obj dump for VLAN objects, using the same
call-back scheme as FDB dump.  Support included for both compressed and
un-compressed vlan dumps.

	Signed-off-by: Scott Feldman <sfeldma@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7d4f8d871ab15bd50a5771382ca2c9355b38d73c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
#	drivers/net/ethernet/rocker/rocker.c
#	net/core/rtnetlink.c
#	net/switchdev/switchdev.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index ba9ffd107028,48a52b35b614..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -9024,9 -8066,14 +9024,17 @@@ static int i40e_ndo_bridge_setlink(stru
   * Return the mode in which the hardware bridge is operating in
   * i.e VEB or VEPA.
   **/
 -#ifdef HAVE_BRIDGE_FILTER
  static int i40e_ndo_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
  				   struct net_device *dev,
++<<<<<<< HEAD
 +				   u32 __always_unused filter_mask, int nlflags)
++=======
+ 				   u32 filter_mask, int nlflags)
+ #else
+ static int i40e_ndo_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
+ 				   struct net_device *dev, int nlflags)
+ #endif /* HAVE_BRIDGE_FILTER */
++>>>>>>> 7d4f8d871ab1 (switchdev; add VLAN support for port's bridge_getlink)
  {
  	struct i40e_netdev_priv *np = netdev_priv(dev);
  	struct i40e_vsi *vsi = np->vsi;
@@@ -9047,34 -8094,12 +9055,39 @@@
  	if (!veb)
  		return 0;
  
++<<<<<<< HEAD
 +	return ndo_dflt_bridge_getlink(skb, pid, seq, dev, veb->bridge_mode, 0,
 +				       0, nlflags);
 +}
 +
 +/* Hardware supports L4 tunnel length of 128B (=2^7) which includes
 + * inner mac plus all inner ethertypes.
 + */
 +#define I40E_MAX_TUNNEL_HDR_LEN 128
 +/**
 + * i40e_features_check - Validate encapsulated packet conforms to limits
 + * @skb: skb buff
 + * @dev: This physical port's netdev
 + * @features: Offload features that the stack believes apply
 + **/
 +static netdev_features_t i40e_features_check(struct sk_buff *skb,
 +					     struct net_device *dev,
 +					     netdev_features_t features)
 +{
 +	if (skb->encapsulation &&
 +	    ((skb_inner_network_header(skb) - skb_transport_header(skb)) >
 +	     I40E_MAX_TUNNEL_HDR_LEN))
 +		return features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);
 +
 +	return features;
++=======
+ 	return ndo_dflt_bridge_getlink(skb, pid, seq, dev, veb->bridge_mode,
+ 				       nlflags, 0, 0, filter_mask, NULL);
++>>>>>>> 7d4f8d871ab1 (switchdev; add VLAN support for port's bridge_getlink)
  }
 -#endif /* HAVE_BRIDGE_ATTRIBS */
  
  static const struct net_device_ops i40e_netdev_ops = {
 +	.ndo_size		= sizeof(struct net_device_ops),
  	.ndo_open		= i40e_open,
  	.ndo_stop		= i40e_close,
  	.ndo_start_xmit		= i40e_lan_xmit_frame,
diff --cc net/core/rtnetlink.c
index 590c29aca2b6,01ced4a889e0..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -2936,6 -2954,20 +2941,23 @@@ int ndo_dflt_bridge_getlink(struct sk_b
  		nla_nest_cancel(skb, br_afspec);
  		goto nla_put_failure;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (mode != BRIDGE_MODE_UNDEF) {
+ 		if (nla_put_u16(skb, IFLA_BRIDGE_MODE, mode)) {
+ 			nla_nest_cancel(skb, br_afspec);
+ 			goto nla_put_failure;
+ 		}
+ 	}
+ 	if (vlan_fill) {
+ 		err = vlan_fill(skb, dev, filter_mask);
+ 		if (err) {
+ 			nla_nest_cancel(skb, br_afspec);
+ 			goto nla_put_failure;
+ 		}
+ 	}
++>>>>>>> 7d4f8d871ab1 (switchdev; add VLAN support for port's bridge_getlink)
  	nla_nest_end(skb, br_afspec);
  
  	protinfo = nla_nest_start(skb, IFLA_PROTINFO | NLA_F_NESTED);
* Unmerged path drivers/net/ethernet/rocker/rocker.c
* Unmerged path net/switchdev/switchdev.c
diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c
index 3c53bf4c522d..85a97dd54acf 100644
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@ -4726,7 +4726,7 @@ static int be_ndo_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
 	return ndo_dflt_bridge_getlink(skb, pid, seq, dev,
 				       hsw_mode == PORT_FWD_TYPE_VEPA ?
 				       BRIDGE_MODE_VEPA : BRIDGE_MODE_VEB,
-				       0, 0, nlflags);
+				       0, 0, nlflags, filter_mask, NULL);
 }
 
 #ifdef CONFIG_BE2NET_VXLAN
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index b28281c1d6ab..6a0dde4a14c3 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -8562,7 +8562,8 @@ static int ixgbe_ndo_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
 		return 0;
 
 	return ndo_dflt_bridge_getlink(skb, pid, seq, dev,
-				       adapter->bridge_mode, 0, 0, nlflags);
+				       adapter->bridge_mode, 0, 0, nlflags,
+				       filter_mask, NULL);
 }
 
 static void *ixgbe_fwd_add(struct net_device *pdev, struct net_device *vdev)
* Unmerged path drivers/net/ethernet/rocker/rocker.c
diff --git a/include/linux/rtnetlink.h b/include/linux/rtnetlink.h
index d6a6fc967679..2a6695d03df0 100644
--- a/include/linux/rtnetlink.h
+++ b/include/linux/rtnetlink.h
@@ -99,5 +99,9 @@ extern int ndo_dflt_fdb_del(struct ndmsg *ndm,
 
 extern int ndo_dflt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
 				   struct net_device *dev, u16 mode,
-				   u32 flags, u32 mask, int nlflags);
+				   u32 flags, u32 mask, int nlflags,
+				   u32 filter_mask,
+				   int (*vlan_fill)(struct sk_buff *skb,
+						    struct net_device *dev,
+						    u32 filter_mask));
 #endif	/* __LINUX_RTNETLINK_H */
* Unmerged path net/core/rtnetlink.c
* Unmerged path net/switchdev/switchdev.c
