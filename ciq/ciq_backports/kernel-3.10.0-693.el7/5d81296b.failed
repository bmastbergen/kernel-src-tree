ALSA: line6: Always setup isochronous transfer properties

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Andrej Krutak <dev@andree.sk>
commit 5d81296b5e7849ba3bcc5bf430ffd37bf67ff7dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5d81296b.failed

While not all line6 devices currently support PCM, it causes no
harm to 'have it prepared'.

This also fixes toneport, which only has PCM - in which case
we previously skipped the USB transfer properties detection completely.

	Signed-off-by: Andrej Krutak <dev@andree.sk>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 5d81296b5e7849ba3bcc5bf430ffd37bf67ff7dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/line6/driver.c
diff --cc sound/usb/line6/driver.c
index 8911306f2be5,0ff5a7d2e19f..000000000000
--- a/sound/usb/line6/driver.c
+++ b/sound/usb/line6/driver.c
@@@ -520,8 -522,148 +516,151 @@@ static void line6_get_usb_properties(st
  		line6->interval = LINE6_FALLBACK_INTERVAL;
  		line6->max_packet_size = LINE6_FALLBACK_MAXPACKETSIZE;
  	}
+ 
++<<<<<<< HEAD
++=======
+ 	/* Isochronous transfer properties */
+ 	if (usbdev->speed == USB_SPEED_LOW) {
+ 		line6->intervals_per_second = USB_LOW_INTERVALS_PER_SECOND;
+ 		line6->iso_buffers = USB_LOW_ISO_BUFFERS;
+ 	} else {
+ 		line6->intervals_per_second = USB_HIGH_INTERVALS_PER_SECOND;
+ 		line6->iso_buffers = USB_HIGH_ISO_BUFFERS;
+ 	}
+ }
+ 
+ /* Enable buffering of incoming messages, flush the buffer */
+ static int line6_hwdep_open(struct snd_hwdep *hw, struct file *file)
+ {
+ 	struct usb_line6 *line6 = hw->private_data;
+ 
+ 	/* NOTE: hwdep layer provides atomicity here */
+ 
+ 	line6->messages.active = 1;
+ 
+ 	return 0;
+ }
+ 
+ /* Stop buffering */
+ static int line6_hwdep_release(struct snd_hwdep *hw, struct file *file)
+ {
+ 	struct usb_line6 *line6 = hw->private_data;
+ 
+ 	line6->messages.active = 0;
+ 
+ 	return 0;
+ }
+ 
+ /* Read from circular buffer, return to user */
+ static long
+ line6_hwdep_read(struct snd_hwdep *hwdep, char __user *buf, long count,
+ 					loff_t *offset)
+ {
+ 	struct usb_line6 *line6 = hwdep->private_data;
+ 	long rv = 0;
+ 	unsigned int out_count;
+ 
+ 	if (mutex_lock_interruptible(&line6->messages.read_lock))
+ 		return -ERESTARTSYS;
+ 
+ 	while (kfifo_len(&line6->messages.fifo) == 0) {
+ 		mutex_unlock(&line6->messages.read_lock);
+ 
+ 		rv = wait_event_interruptible(
+ 			line6->messages.wait_queue,
+ 			kfifo_len(&line6->messages.fifo) != 0);
+ 		if (rv < 0)
+ 			return rv;
+ 
+ 		if (mutex_lock_interruptible(&line6->messages.read_lock))
+ 			return -ERESTARTSYS;
+ 	}
+ 
+ 	if (kfifo_peek_len(&line6->messages.fifo) > count) {
+ 		/* Buffer too small; allow re-read of the current item... */
+ 		rv = -EINVAL;
+ 	} else {
+ 		rv = kfifo_to_user(&line6->messages.fifo, buf, count, &out_count);
+ 		if (rv == 0)
+ 			rv = out_count;
+ 	}
+ 
+ 	mutex_unlock(&line6->messages.read_lock);
+ 	return rv;
+ }
+ 
+ /* Write directly (no buffering) to device by user*/
+ static long
+ line6_hwdep_write(struct snd_hwdep *hwdep, const char __user *data, long count,
+ 					loff_t *offset)
+ {
+ 	struct usb_line6 *line6 = hwdep->private_data;
+ 	int rv;
+ 	char *data_copy;
+ 
+ 	if (count > line6->max_packet_size * LINE6_RAW_MESSAGES_MAXCOUNT) {
+ 		/* This is an arbitrary limit - still better than nothing... */
+ 		return -EINVAL;
+ 	}
+ 
+ 	data_copy = memdup_user(data, count);
+ 	if (IS_ERR(data_copy))
+ 		return PTR_ERR(data_copy);
+ 
+ 	rv = line6_send_raw_message(line6, data_copy, count);
+ 
+ 	kfree(data_copy);
+ 	return rv;
+ }
+ 
+ static const struct snd_hwdep_ops hwdep_ops = {
+ 	.open    = line6_hwdep_open,
+ 	.release = line6_hwdep_release,
+ 	.read    = line6_hwdep_read,
+ 	.write   = line6_hwdep_write,
+ };
+ 
+ /* Insert into circular buffer */
+ static void line6_hwdep_push_message(struct usb_line6 *line6)
+ {
+ 	if (!line6->messages.active)
+ 		return;
+ 
+ 	if (kfifo_avail(&line6->messages.fifo) >= line6->message_length) {
+ 		/* No race condition here, there's only one writer */
+ 		kfifo_in(&line6->messages.fifo,
+ 			line6->buffer_message, line6->message_length);
+ 	} /* else TODO: signal overflow */
+ 
+ 	wake_up_interruptible(&line6->messages.wait_queue);
+ }
+ 
+ static int line6_hwdep_init(struct usb_line6 *line6)
+ {
+ 	int err;
+ 	struct snd_hwdep *hwdep;
+ 
+ 	/* TODO: usb_driver_claim_interface(); */
+ 	line6->process_message = line6_hwdep_push_message;
+ 	line6->messages.active = 0;
+ 	init_waitqueue_head(&line6->messages.wait_queue);
+ 	mutex_init(&line6->messages.read_lock);
+ 	INIT_KFIFO(line6->messages.fifo);
+ 
+ 	err = snd_hwdep_new(line6->card, "config", 0, &hwdep);
+ 	if (err < 0)
+ 		goto end;
+ 	strcpy(hwdep->name, "config");
+ 	hwdep->iface = SNDRV_HWDEP_IFACE_LINE6;
+ 	hwdep->ops = hwdep_ops;
+ 	hwdep->private_data = line6;
+ 	hwdep->exclusive = true;
+ 
+ end:
+ 	return err;
  }
  
++>>>>>>> 5d81296b5e78 (ALSA: line6: Always setup isochronous transfer properties)
  static int line6_init_cap_control(struct usb_line6 *line6)
  {
  	int ret;
* Unmerged path sound/usb/line6/driver.c
