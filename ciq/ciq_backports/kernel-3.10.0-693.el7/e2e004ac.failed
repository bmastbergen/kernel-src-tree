xen-netfront: Improve error handling during initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ross Lagerwall <ross.lagerwall@citrix.com>
commit e2e004acc7cbe3c531e752a270a74e95cde3ea48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e2e004ac.failed

This fixes a crash when running out of grant refs when creating many
queues across many netdevs.

* If creating queues fails (i.e. there are no grant refs available),
call xenbus_dev_fatal() to ensure that the xenbus device is set to the
closed state.
* If no queues are created, don't call xennet_disconnect_backend as
netdev->real_num_tx_queues will not have been set correctly.
* If setup_netfront() fails, ensure that all the queues created are
cleaned up, not just those that have been set up.
* If any queues were set up and an error occurs, call
xennet_destroy_queues() to clean up the napi context.
* If any fatal error occurs, unregister and destroy the netdev to avoid
leaving around a half setup network device.

	Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
	Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e2e004acc7cbe3c531e752a270a74e95cde3ea48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/xen-netfront.c
diff --cc drivers/net/xen-netfront.c
index 8896052a2ee0,d3812581c6c0..000000000000
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@@ -1638,11 -1802,48 +1638,34 @@@ static int talk_to_netback(struct xenbu
  	const char *message;
  	struct xenbus_transaction xbt;
  	int err;
 -	unsigned int feature_split_evtchn;
 -	unsigned int i = 0;
 -	unsigned int max_queues = 0;
 -	struct netfront_queue *queue = NULL;
 -	unsigned int num_queues = 1;
  
 -	info->netdev->irq = 0;
 -
 -	/* Check if backend supports multiple queues */
 -	max_queues = xenbus_read_unsigned(info->xbdev->otherend,
 -					  "multi-queue-max-queues", 1);
 -	num_queues = min(max_queues, xennet_max_queues);
 -
 -	/* Check feature-split-event-channels */
 -	feature_split_evtchn = xenbus_read_unsigned(info->xbdev->otherend,
 -					"feature-split-event-channels", 0);
 -
 -	/* Read mac addr. */
 -	err = xen_net_read_mac(dev, info->netdev->dev_addr);
 -	if (err) {
 -		xenbus_dev_fatal(dev, err, "parsing %s/mac", dev->nodename);
 +	/* Create shared ring, alloc event channel. */
 +	err = setup_netfront(dev, info);
 +	if (err)
  		goto out;
++<<<<<<< HEAD
++=======
+ 	}
+ 
+ 	if (info->queues)
+ 		xennet_destroy_queues(info);
+ 
+ 	err = xennet_create_queues(info, &num_queues);
+ 	if (err < 0) {
+ 		xenbus_dev_fatal(dev, err, "creating queues");
+ 		kfree(info->queues);
+ 		info->queues = NULL;
+ 		goto out;
+ 	}
+ 
+ 	/* Create shared ring, alloc event channel -- for each queue */
+ 	for (i = 0; i < num_queues; ++i) {
+ 		queue = &info->queues[i];
+ 		err = setup_netfront(dev, queue, feature_split_evtchn);
+ 		if (err)
+ 			goto destroy_ring;
+ 	}
++>>>>>>> e2e004acc7cb (xen-netfront: Improve error handling during initialization)
  
  again:
  	err = xenbus_transaction_start(&xbt);
@@@ -1722,11 -1927,15 +1745,17 @@@
  	return 0;
  
   abort_transaction:
 -	xenbus_dev_fatal(dev, err, "%s", message);
 -abort_transaction_no_dev_fatal:
  	xenbus_transaction_end(xbt, 1);
 +	xenbus_dev_fatal(dev, err, "%s", message);
   destroy_ring:
  	xennet_disconnect_backend(info);
++<<<<<<< HEAD
++=======
+ 	xennet_destroy_queues(info);
++>>>>>>> e2e004acc7cb (xen-netfront: Improve error handling during initialization)
   out:
+ 	unregister_netdev(info->netdev);
+ 	xennet_free_netdev(info->netdev);
  	return err;
  }
  
* Unmerged path drivers/net/xen-netfront.c
