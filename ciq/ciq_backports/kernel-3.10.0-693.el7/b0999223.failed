alx: add ability to allocate and free alx_napi structures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tobias Regnery <tobias.regnery@gmail.com>
commit b0999223f224187318c67f1de653e34fb1f04f6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b0999223.failed

Add new functions to allocate and free the alx_napi structures and use them
in __alx_open and __alx_stop. We only allocate one of these structures for
now, as the rest of the driver is not yet ready for multiple queues.

We switch over the setup of the interrupt mask and the call to netif_napi_add
to the new function because we must adjust these later on a per queue basis.

Based on the downstream driver at github.com/qca/alx

	Signed-off-by: Tobias Regnery <tobias.regnery@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b0999223f224187318c67f1de653e34fb1f04f6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/atheros/alx/main.c
diff --cc drivers/net/ethernet/atheros/alx/main.c
index b165b9e58ad3,193da6799979..000000000000
--- a/drivers/net/ethernet/atheros/alx/main.c
+++ b/drivers/net/ethernet/atheros/alx/main.c
@@@ -684,15 -653,75 +670,87 @@@ static void alx_free_rings(struct alx_p
  	kfree(alx->txq.bufs);
  	kfree(alx->rxq.bufs);
  
++<<<<<<< HEAD
 +	if (alx->rx_page) {
 +		put_page(alx->rx_page);
 +		alx->rx_page = NULL;
 +	}
 +
 +	dma_free_coherent(&alx->hw.pdev->dev,
 +			  alx->descmem.size,
 +			  alx->descmem.virt,
 +			  alx->descmem.dma);
++=======
+ 	if (!alx->descmem.virt)
+ 		dma_free_coherent(&alx->hw.pdev->dev,
+ 				  alx->descmem.size,
+ 				  alx->descmem.virt,
+ 				  alx->descmem.dma);
+ }
+ 
+ static void alx_free_napis(struct alx_priv *alx)
+ {
+ 	struct alx_napi *np;
+ 
+ 	np = alx->qnapi[0];
+ 	if (!np)
+ 		return;
+ 
+ 	netif_napi_del(&alx->napi);
+ 	kfree(np->txq);
+ 	kfree(np->rxq);
+ 	kfree(np);
+ 	alx->qnapi[0] = NULL;
+ }
+ 
+ static int alx_alloc_napis(struct alx_priv *alx)
+ {
+ 	struct alx_napi *np;
+ 	struct alx_rx_queue *rxq;
+ 	struct alx_tx_queue *txq;
+ 
+ 	alx->int_mask &= ~ALX_ISR_ALL_QUEUES;
+ 	alx->int_mask |= ALX_ISR_TX_Q0 | ALX_ISR_RX_Q0;
+ 
+ 	/* allocate alx_napi structures */
+ 	np = kzalloc(sizeof(struct alx_napi), GFP_KERNEL);
+ 	if (!np)
+ 		goto err_out;
+ 
+ 	np->alx = alx;
+ 	netif_napi_add(alx->dev, &alx->napi, alx_poll, 64);
+ 	alx->qnapi[0] = np;
+ 
+ 	/* allocate tx queues */
+ 	np = alx->qnapi[0];
+ 	txq = kzalloc(sizeof(*txq), GFP_KERNEL);
+ 	if (!txq)
+ 		goto err_out;
+ 
+ 	np->txq = txq;
+ 	txq->count = alx->tx_ringsz;
+ 	txq->netdev = alx->dev;
+ 	txq->dev = &alx->hw.pdev->dev;
+ 
+ 	/* allocate rx queues */
+ 	np = alx->qnapi[0];
+ 	rxq = kzalloc(sizeof(*rxq), GFP_KERNEL);
+ 	if (!rxq)
+ 		goto err_out;
+ 
+ 	np->rxq = rxq;
+ 	rxq->np = alx->qnapi[0];
+ 	rxq->count = alx->rx_ringsz;
+ 	rxq->netdev = alx->dev;
+ 	rxq->dev = &alx->hw.pdev->dev;
+ 
+ 	return 0;
+ 
+ err_out:
+ 	netdev_err(alx->dev, "error allocating internal structures\n");
+ 	alx_free_napis(alx);
+ 	return -ENOMEM;
++>>>>>>> b0999223f224 (alx: add ability to allocate and free alx_napi structures)
  }
  
  static void alx_config_vector_mapping(struct alx_priv *alx)
* Unmerged path drivers/net/ethernet/atheros/alx/main.c
