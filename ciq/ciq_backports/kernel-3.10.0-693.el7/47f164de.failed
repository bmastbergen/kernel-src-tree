amd-xgbe: Add PCI device support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit 47f164deab22a02a2999f56ca51fdabab4565167
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/47f164de.failed

Add support for new PCI devices to the driver.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 47f164deab22a02a2999f56ca51fdabab4565167)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/Kconfig
#	drivers/net/ethernet/amd/xgbe/Makefile
#	drivers/net/ethernet/amd/xgbe/xgbe-common.h
#	drivers/net/ethernet/amd/xgbe/xgbe-drv.c
#	drivers/net/ethernet/amd/xgbe/xgbe-main.c
#	drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
#	drivers/net/ethernet/amd/xgbe/xgbe-platform.c
#	drivers/net/ethernet/amd/xgbe/xgbe.h
diff --cc drivers/net/ethernet/amd/Kconfig
index 13d74aa4033d,9255ce4c654b..000000000000
--- a/drivers/net/ethernet/amd/Kconfig
+++ b/drivers/net/ethernet/amd/Kconfig
@@@ -179,4 -171,28 +179,31 @@@ config SUNLANC
  	  To compile this driver as a module, choose M here: the module
  	  will be called sunlance.
  
++<<<<<<< HEAD
++=======
+ config AMD_XGBE
+ 	tristate "AMD 10GbE Ethernet driver"
+ 	depends on ((OF_NET && OF_ADDRESS) || ACPI || PCI) && HAS_IOMEM && HAS_DMA
+ 	depends on X86 || ARM64 || COMPILE_TEST
+ 	select BITREVERSE
+ 	select CRC32
+ 	select PTP_1588_CLOCK
+ 	---help---
+ 	  This driver supports the AMD 10GbE Ethernet device found on an
+ 	  AMD SoC.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called amd-xgbe.
+ 
+ config AMD_XGBE_DCB
+ 	bool "Data Center Bridging (DCB) support"
+ 	default n
+ 	depends on AMD_XGBE && DCB
+ 	---help---
+ 	  Say Y here to enable Data Center Bridging (DCB) support in the
+ 	  driver.
+ 
+ 	  If unsure, say N.
+ 
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  endif # NET_VENDOR_AMD
diff --cc drivers/net/ethernet/amd/xgbe/Makefile
index 26cf9af1642f,d1ce1c1ad146..000000000000
--- a/drivers/net/ethernet/amd/xgbe/Makefile
+++ b/drivers/net/ethernet/amd/xgbe/Makefile
@@@ -1,6 -1,11 +1,16 @@@
  obj-$(CONFIG_AMD_XGBE) += amd-xgbe.o
  
  amd-xgbe-objs := xgbe-main.o xgbe-drv.o xgbe-dev.o \
++<<<<<<< HEAD
 +		 xgbe-desc.o xgbe-ethtool.o xgbe-mdio.o
 +
++=======
+ 		 xgbe-desc.o xgbe-ethtool.o xgbe-mdio.o \
+ 		 xgbe-ptp.o \
+ 		 xgbe-phy-v1.o xgbe-phy-v2.o \
+ 		 xgbe-platform.o
+ 
+ amd-xgbe-$(CONFIG_PCI) += xgbe-pci.o
+ amd-xgbe-$(CONFIG_AMD_XGBE_DCB) += xgbe-dcb.o
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  amd-xgbe-$(CONFIG_DEBUG_FS) += xgbe-debugfs.o
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-common.h
index 3373e9ef2003,b54862bb7fb4..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-common.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-common.h
@@@ -743,16 -856,107 +743,83 @@@
  #define MTL_TSA_SP			0x00
  #define MTL_TSA_ETS			0x02
  
++<<<<<<< HEAD
 +
 +/* PCS MMD select register offset
 + *  The MMD select register is used for accessing PCS registers
 + *  when the underlying APB3 interface is using indirect addressing.
 + *  Indirect addressing requires accessing registers in two phases,
 + *  an address phase and a data phase.  The address phases requires
 + *  writing an address selection value to the MMD select regiesters.
 + */
 +#define PCS_MMD_SELECT			0xff
- 
++=======
+ /* PCS register offsets */
+ #define PCS_V1_WINDOW_SELECT		0x03fc
+ #define PCS_V2_WINDOW_DEF		0x9060
+ #define PCS_V2_WINDOW_SELECT		0x9064
+ 
+ /* PCS register entry bit positions and sizes */
+ #define PCS_V2_WINDOW_DEF_OFFSET_INDEX	6
+ #define PCS_V2_WINDOW_DEF_OFFSET_WIDTH	14
+ #define PCS_V2_WINDOW_DEF_SIZE_INDEX	2
+ #define PCS_V2_WINDOW_DEF_SIZE_WIDTH	4
+ 
+ /* SerDes integration register offsets */
+ #define SIR0_KR_RT_1			0x002c
+ #define SIR0_STATUS			0x0040
+ #define SIR1_SPEED			0x0000
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
+ 
 -/* SerDes integration register entry bit positions and sizes */
 -#define SIR0_KR_RT_1_RESET_INDEX	11
 -#define SIR0_KR_RT_1_RESET_WIDTH	1
 -#define SIR0_STATUS_RX_READY_INDEX	0
 -#define SIR0_STATUS_RX_READY_WIDTH	1
 -#define SIR0_STATUS_TX_READY_INDEX	8
 -#define SIR0_STATUS_TX_READY_WIDTH	1
 -#define SIR1_SPEED_CDR_RATE_INDEX	12
 -#define SIR1_SPEED_CDR_RATE_WIDTH	4
 -#define SIR1_SPEED_DATARATE_INDEX	4
 -#define SIR1_SPEED_DATARATE_WIDTH	2
 -#define SIR1_SPEED_PLLSEL_INDEX		3
 -#define SIR1_SPEED_PLLSEL_WIDTH		1
 -#define SIR1_SPEED_RATECHANGE_INDEX	6
 -#define SIR1_SPEED_RATECHANGE_WIDTH	1
 -#define SIR1_SPEED_TXAMP_INDEX		8
 -#define SIR1_SPEED_TXAMP_WIDTH		4
 -#define SIR1_SPEED_WORDMODE_INDEX	0
 -#define SIR1_SPEED_WORDMODE_WIDTH	3
 -
 -/* SerDes RxTx register offsets */
 -#define RXTX_REG6			0x0018
 -#define RXTX_REG20			0x0050
 -#define RXTX_REG22			0x0058
 -#define RXTX_REG114			0x01c8
 -#define RXTX_REG129			0x0204
 -
 -/* SerDes RxTx register entry bit positions and sizes */
 -#define RXTX_REG6_RESETB_RXD_INDEX	8
 -#define RXTX_REG6_RESETB_RXD_WIDTH	1
 -#define RXTX_REG20_BLWC_ENA_INDEX	2
 -#define RXTX_REG20_BLWC_ENA_WIDTH	1
 -#define RXTX_REG114_PQ_REG_INDEX	9
 -#define RXTX_REG114_PQ_REG_WIDTH	7
 -#define RXTX_REG129_RXDFE_CONFIG_INDEX	14
 -#define RXTX_REG129_RXDFE_CONFIG_WIDTH	2
+ 
+ /* MAC Control register offsets */
+ #define XP_PROP_0			0x0000
+ #define XP_PROP_1			0x0004
+ #define XP_PROP_2			0x0008
+ #define XP_PROP_3			0x000c
+ #define XP_PROP_4			0x0010
+ #define XP_PROP_5			0x0014
+ #define XP_MAC_ADDR_LO			0x0020
+ #define XP_MAC_ADDR_HI			0x0024
+ #define XP_DRIVER_INT_REQ		0x0060
+ #define XP_DRIVER_INT_RO		0x0064
+ #define XP_DRIVER_SCRATCH_0		0x0068
+ #define XP_DRIVER_SCRATCH_1		0x006c
+ #define XP_INT_EN			0x0078
+ 
+ /* MAC Control register entry bit positions and sizes */
+ #define XP_DRIVER_INT_REQ_REQUEST_INDEX		0
+ #define XP_DRIVER_INT_REQ_REQUEST_WIDTH		1
+ #define XP_DRIVER_INT_RO_STATUS_INDEX		0
+ #define XP_DRIVER_INT_RO_STATUS_WIDTH		1
+ #define XP_DRIVER_SCRATCH_0_COMMAND_INDEX	0
+ #define XP_DRIVER_SCRATCH_0_COMMAND_WIDTH	8
+ #define XP_DRIVER_SCRATCH_0_SUB_COMMAND_INDEX	8
+ #define XP_DRIVER_SCRATCH_0_SUB_COMMAND_WIDTH	8
+ #define XP_MAC_ADDR_HI_VALID_INDEX		31
+ #define XP_MAC_ADDR_HI_VALID_WIDTH		1
+ #define XP_PROP_0_CONN_TYPE_INDEX		28
+ #define XP_PROP_0_CONN_TYPE_WIDTH		3
+ #define XP_PROP_0_MDIO_ADDR_INDEX		16
+ #define XP_PROP_0_MDIO_ADDR_WIDTH		5
+ #define XP_PROP_0_PORT_ID_INDEX			0
+ #define XP_PROP_0_PORT_ID_WIDTH			8
+ #define XP_PROP_0_PORT_MODE_INDEX		8
+ #define XP_PROP_0_PORT_MODE_WIDTH		4
+ #define XP_PROP_0_PORT_SPEEDS_INDEX		23
+ #define XP_PROP_0_PORT_SPEEDS_WIDTH		4
+ #define XP_PROP_1_MAX_RX_DMA_INDEX		24
+ #define XP_PROP_1_MAX_RX_DMA_WIDTH		5
+ #define XP_PROP_1_MAX_RX_QUEUES_INDEX		8
+ #define XP_PROP_1_MAX_RX_QUEUES_WIDTH		5
+ #define XP_PROP_1_MAX_TX_DMA_INDEX		16
+ #define XP_PROP_1_MAX_TX_DMA_WIDTH		5
+ #define XP_PROP_1_MAX_TX_QUEUES_INDEX		0
+ #define XP_PROP_1_MAX_TX_QUEUES_WIDTH		5
+ #define XP_PROP_2_RX_FIFO_SIZE_INDEX		16
+ #define XP_PROP_2_RX_FIFO_SIZE_WIDTH		16
+ #define XP_PROP_2_TX_FIFO_SIZE_INDEX		0
+ #define XP_PROP_2_TX_FIFO_SIZE_WIDTH		16
  
  /* Descriptor/Packet entry bit positions and sizes */
  #define RX_PACKET_ERRORS_CRC_INDEX		2
@@@ -979,13 -1296,137 +1046,60 @@@ do {									
  /* Macros for building, reading or writing register values or bits
   * within the register values of XPCS registers.
   */
++<<<<<<< HEAD
 +#define XPCS_IOWRITE(_pdata, _off, _val)				\
++=======
+ #define XPCS_GET_BITS(_var, _prefix, _field)				\
+ 	GET_BITS((_var),                                                \
+ 		 _prefix##_##_field##_INDEX,                            \
+ 		 _prefix##_##_field##_WIDTH)
+ 
+ #define XPCS_SET_BITS(_var, _prefix, _field, _val)                      \
+ 	SET_BITS((_var),                                                \
+ 		 _prefix##_##_field##_INDEX,                            \
+ 		 _prefix##_##_field##_WIDTH, (_val))
+ 
+ #define XPCS32_IOWRITE(_pdata, _off, _val)				\
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  	iowrite32(_val, (_pdata)->xpcs_regs + (_off))
  
 -#define XPCS32_IOREAD(_pdata, _off)					\
 +#define XPCS_IOREAD(_pdata, _off)					\
  	ioread32((_pdata)->xpcs_regs + (_off))
  
 -#define XPCS16_IOWRITE(_pdata, _off, _val)				\
 -	iowrite16(_val, (_pdata)->xpcs_regs + (_off))
 -
 -#define XPCS16_IOREAD(_pdata, _off)					\
 -	ioread16((_pdata)->xpcs_regs + (_off))
 -
 -/* Macros for building, reading or writing register values or bits
 - * within the register values of SerDes integration registers.
 - */
 -#define XSIR_GET_BITS(_var, _prefix, _field)                            \
 -	GET_BITS((_var),                                                \
 -		 _prefix##_##_field##_INDEX,                            \
 -		 _prefix##_##_field##_WIDTH)
 -
 -#define XSIR_SET_BITS(_var, _prefix, _field, _val)                      \
 -	SET_BITS((_var),                                                \
 -		 _prefix##_##_field##_INDEX,                            \
 -		 _prefix##_##_field##_WIDTH, (_val))
 -
 -#define XSIR0_IOREAD(_pdata, _reg)					\
 -	ioread16((_pdata)->sir0_regs + _reg)
 -
 -#define XSIR0_IOREAD_BITS(_pdata, _reg, _field)				\
 -	GET_BITS(XSIR0_IOREAD((_pdata), _reg),				\
 -		 _reg##_##_field##_INDEX,				\
 -		 _reg##_##_field##_WIDTH)
 -
 -#define XSIR0_IOWRITE(_pdata, _reg, _val)				\
 -	iowrite16((_val), (_pdata)->sir0_regs + _reg)
 -
 -#define XSIR0_IOWRITE_BITS(_pdata, _reg, _field, _val)			\
 -do {									\
 -	u16 reg_val = XSIR0_IOREAD((_pdata), _reg);			\
 -	SET_BITS(reg_val,						\
 -		 _reg##_##_field##_INDEX,				\
 -		 _reg##_##_field##_WIDTH, (_val));			\
 -	XSIR0_IOWRITE((_pdata), _reg, reg_val);				\
 -} while (0)
 -
 -#define XSIR1_IOREAD(_pdata, _reg)					\
 -	ioread16((_pdata)->sir1_regs + _reg)
 -
 -#define XSIR1_IOREAD_BITS(_pdata, _reg, _field)				\
 -	GET_BITS(XSIR1_IOREAD((_pdata), _reg),				\
 -		 _reg##_##_field##_INDEX,				\
 -		 _reg##_##_field##_WIDTH)
 -
 -#define XSIR1_IOWRITE(_pdata, _reg, _val)				\
 -	iowrite16((_val), (_pdata)->sir1_regs + _reg)
 -
 -#define XSIR1_IOWRITE_BITS(_pdata, _reg, _field, _val)			\
 -do {									\
 -	u16 reg_val = XSIR1_IOREAD((_pdata), _reg);			\
 -	SET_BITS(reg_val,						\
 -		 _reg##_##_field##_INDEX,				\
 -		 _reg##_##_field##_WIDTH, (_val));			\
 -	XSIR1_IOWRITE((_pdata), _reg, reg_val);				\
 -} while (0)
 -
 -/* Macros for building, reading or writing register values or bits
 - * within the register values of SerDes RxTx registers.
 - */
 -#define XRXTX_IOREAD(_pdata, _reg)					\
 -	ioread16((_pdata)->rxtx_regs + _reg)
 -
 -#define XRXTX_IOREAD_BITS(_pdata, _reg, _field)				\
 -	GET_BITS(XRXTX_IOREAD((_pdata), _reg),				\
 -		 _reg##_##_field##_INDEX,				\
 -		 _reg##_##_field##_WIDTH)
 -
 -#define XRXTX_IOWRITE(_pdata, _reg, _val)				\
 -	iowrite16((_val), (_pdata)->rxtx_regs + _reg)
 -
 -#define XRXTX_IOWRITE_BITS(_pdata, _reg, _field, _val)			\
 -do {									\
 -	u16 reg_val = XRXTX_IOREAD((_pdata), _reg);			\
 -	SET_BITS(reg_val,						\
 -		 _reg##_##_field##_INDEX,				\
 -		 _reg##_##_field##_WIDTH, (_val));			\
 -	XRXTX_IOWRITE((_pdata), _reg, reg_val);				\
 -} while (0)
  
+ /* Macros for building, reading or writing register values or bits
+  * within the register values of MAC Control registers.
+  */
+ #define XP_GET_BITS(_var, _prefix, _field)				\
+ 	GET_BITS((_var),						\
+ 		 _prefix##_##_field##_INDEX,				\
+ 		 _prefix##_##_field##_WIDTH)
+ 
+ #define XP_SET_BITS(_var, _prefix, _field, _val)			\
+ 	SET_BITS((_var),						\
+ 		 _prefix##_##_field##_INDEX,				\
+ 		 _prefix##_##_field##_WIDTH, (_val))
+ 
+ #define XP_IOREAD(_pdata, _reg)						\
+ 	ioread32((_pdata)->xprop_regs + (_reg))
+ 
+ #define XP_IOREAD_BITS(_pdata, _reg, _field)				\
+ 	GET_BITS(XP_IOREAD((_pdata), (_reg)),				\
+ 		 _reg##_##_field##_INDEX,				\
+ 		 _reg##_##_field##_WIDTH)
+ 
+ #define XP_IOWRITE(_pdata, _reg, _val)					\
+ 	iowrite32((_val), (_pdata)->xprop_regs + (_reg))
+ 
+ #define XP_IOWRITE_BITS(_pdata, _reg, _field, _val)			\
+ do {									\
+ 	u32 reg_val = XP_IOREAD((_pdata), (_reg));			\
+ 	SET_BITS(reg_val,						\
+ 		 _reg##_##_field##_INDEX,				\
+ 		 _reg##_##_field##_WIDTH, (_val));			\
+ 	XP_IOWRITE((_pdata), (_reg), reg_val);				\
+ } while (0)
+ 
  /* Macros for building, reading or writing register values or bits
   * using MDIO.  Different from above because of the use of standardized
   * Linux include values.  No shifting is performed with the bit
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index d58e85811bc9,efa01a5a81b6..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@@ -254,11 -360,23 +254,17 @@@ static irqreturn_t xgbe_isr(int irq, vo
  
  		if (XGMAC_GET_BITS(mac_isr, MAC_ISR, MMCRXIS))
  			hw_if->rx_mmc_int(pdata);
 -
 -		if (XGMAC_GET_BITS(mac_isr, MAC_ISR, TSIS)) {
 -			mac_tssr = XGMAC_IOREAD(pdata, MAC_TSSR);
 -
 -			if (XGMAC_GET_BITS(mac_tssr, MAC_TSSR, TXTSC)) {
 -				/* Read Tx Timestamp to clear interrupt */
 -				pdata->tx_tstamp =
 -					hw_if->get_tx_tstamp(pdata);
 -				queue_work(pdata->dev_workqueue,
 -					   &pdata->tx_tstamp_work);
 -			}
 -		}
  	}
  
++<<<<<<< HEAD
 +	DBGPR("  DMA_ISR = %08x\n", XGMAC_IOREAD(pdata, DMA_ISR));
 +
 +	DBGPR("<--xgbe_isr\n");
++=======
+ 	/* If there is not a separate AN irq, handle it here */
+ 	if (pdata->dev_irq == pdata->an_irq)
+ 		pdata->phy_if.an_isr(irq, pdata);
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  
  isr_done:
  	return IRQ_HANDLED;
@@@ -576,11 -865,18 +582,23 @@@ static int xgbe_start(struct xgbe_prv_d
  
  	DBGPR("-->xgbe_start\n");
  
 +	xgbe_set_rx_mode(netdev);
 +
  	hw_if->init(pdata);
  
++<<<<<<< HEAD
 +	phy_start(pdata->phydev);
++=======
+ 	xgbe_napi_enable(pdata, 1);
+ 
+ 	ret = xgbe_request_irqs(pdata);
+ 	if (ret)
+ 		goto err_napi;
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
+ 
+ 	ret = phy_if->phy_start(pdata);
+ 	if (ret)
+ 		goto err_irqs;
  
  	hw_if->enable_tx(pdata);
  	hw_if->enable_rx(pdata);
@@@ -593,6 -889,16 +611,19 @@@
  	DBGPR("<--xgbe_start\n");
  
  	return 0;
++<<<<<<< HEAD
++=======
+ 
+ err_irqs:
+ 	xgbe_free_irqs(pdata);
+ 
+ err_napi:
+ 	xgbe_napi_disable(pdata, 1);
+ 
+ 	hw_if->exit(pdata);
+ 
+ 	return ret;
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  }
  
  static void xgbe_stop(struct xgbe_prv_data *pdata)
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-main.c
index e79ba9088346,697483a61b16..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-main.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-main.c
@@@ -240,92 -180,31 +240,93 @@@ static int xgbe_probe(struct platform_d
  	SET_NETDEV_DEV(netdev, dev);
  	pdata = netdev_priv(netdev);
  	pdata->netdev = netdev;
 +	pdata->pdev = pdev;
  	pdata->dev = dev;
 +	platform_set_drvdata(pdev, netdev);
  
  	spin_lock_init(&pdata->lock);
 -	spin_lock_init(&pdata->xpcs_lock);
 -	mutex_init(&pdata->rss_mutex);
 -	spin_lock_init(&pdata->tstamp_lock);
 +	mutex_init(&pdata->xpcs_mutex);
  
 -	pdata->msg_enable = netif_msg_init(debug, default_msg_level);
 +	/* Set and validate the number of descriptors for a ring */
 +	BUILD_BUG_ON_NOT_POWER_OF_2(XGBE_TX_DESC_CNT);
 +	pdata->tx_desc_count = XGBE_TX_DESC_CNT;
 +	if (pdata->tx_desc_count & (pdata->tx_desc_count - 1)) {
 +		dev_err(dev, "tx descriptor count (%d) is not valid\n",
 +			pdata->tx_desc_count);
 +		ret = -EINVAL;
 +		goto err_io;
 +	}
 +	BUILD_BUG_ON_NOT_POWER_OF_2(XGBE_RX_DESC_CNT);
 +	pdata->rx_desc_count = XGBE_RX_DESC_CNT;
 +	if (pdata->rx_desc_count & (pdata->rx_desc_count - 1)) {
 +		dev_err(dev, "rx descriptor count (%d) is not valid\n",
 +			pdata->rx_desc_count);
 +		ret = -EINVAL;
 +		goto err_io;
 +	}
  
 -	set_bit(XGBE_DOWN, &pdata->dev_state);
++<<<<<<< HEAD
 +	/* Obtain the system clock setting */
 +	pdata->sysclock = devm_clk_get(dev, NULL);
 +	if (IS_ERR(pdata->sysclock)) {
 +		dev_err(dev, "devm_clk_get failed\n");
 +		ret = PTR_ERR(pdata->sysclock);
 +		goto err_io;
 +	}
  
 -	return pdata;
 -}
 +	/* Obtain the mmio areas for the device */
 +	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 +	pdata->xgmac_regs = devm_ioremap_resource(dev, res);
 +	if (IS_ERR(pdata->xgmac_regs)) {
 +		dev_err(dev, "xgmac ioremap failed\n");
 +		ret = PTR_ERR(pdata->xgmac_regs);
 +		goto err_io;
 +	}
 +	DBGPR("  xgmac_regs = %p\n", pdata->xgmac_regs);
 +
 +	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
 +	pdata->xpcs_regs = devm_ioremap_resource(dev, res);
 +	if (IS_ERR(pdata->xpcs_regs)) {
 +		dev_err(dev, "xpcs ioremap failed\n");
 +		ret = PTR_ERR(pdata->xpcs_regs);
 +		goto err_io;
 +	}
 +	DBGPR("  xpcs_regs  = %p\n", pdata->xpcs_regs);
  
 -void xgbe_free_pdata(struct xgbe_prv_data *pdata)
 -{
 -	struct net_device *netdev = pdata->netdev;
 +	/* Set the DMA mask */
 +	if (!dev->dma_mask)
 +		dev->dma_mask = &dev->coherent_dma_mask;
 +	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(40));
 +	if (ret) {
 +		dev_err(dev, "dma_set_mask_and_coherent failed\n");
 +		goto err_io;
 +	}
  
 -	free_netdev(netdev);
 -}
 +	if (of_property_read_bool(dev->of_node, "dma-coherent")) {
 +		pdata->axdomain = XGBE_DMA_OS_AXDOMAIN;
 +		pdata->arcache = XGBE_DMA_OS_ARCACHE;
 +		pdata->awcache = XGBE_DMA_OS_AWCACHE;
 +	} else {
 +		pdata->axdomain = XGBE_DMA_SYS_AXDOMAIN;
 +		pdata->arcache = XGBE_DMA_SYS_ARCACHE;
 +		pdata->awcache = XGBE_DMA_SYS_AWCACHE;
 +	}
 +
 +	ret = platform_get_irq(pdev, 0);
 +	if (ret < 0) {
 +		dev_err(dev, "platform_get_irq failed\n");
 +		goto err_io;
 +	}
 +	netdev->irq = ret;
 +	netdev->base_addr = (unsigned long)pdata->xgmac_regs;
  
 -void xgbe_set_counts(struct xgbe_prv_data *pdata)
 -{
  	/* Set all the function pointers */
  	xgbe_init_all_fptrs(pdata);
 +	hw_if = &pdata->hw_if;
 +	desc_if = &pdata->desc_if;
 +
 +	/* Issue software reset to device */
 +	hw_if->exit(pdata);
  
  	/* Populate the hardware features */
  	xgbe_get_all_hw_features(pdata);
@@@ -350,9 -270,41 +351,25 @@@
  	/* Set default configuration data */
  	xgbe_default_config(pdata);
  
 -	/* Set the DMA mask */
 -	ret = dma_set_mask_and_coherent(dev,
 -					DMA_BIT_MASK(pdata->hw_feat.dma_width));
 -	if (ret) {
 -		dev_err(dev, "dma_set_mask_and_coherent failed\n");
 -		return ret;
 -	}
 -
 -	/* Set default max values if not provided */
 -	if (!pdata->tx_max_fifo_size)
 -		pdata->tx_max_fifo_size = pdata->hw_feat.tx_fifo_size;
 -	if (!pdata->rx_max_fifo_size)
 -		pdata->rx_max_fifo_size = pdata->hw_feat.rx_fifo_size;
 -
 -	/* Set and validate the number of descriptors for a ring */
 -	BUILD_BUG_ON_NOT_POWER_OF_2(XGBE_TX_DESC_CNT);
 -	pdata->tx_desc_count = XGBE_TX_DESC_CNT;
 -
 -	BUILD_BUG_ON_NOT_POWER_OF_2(XGBE_RX_DESC_CNT);
 -	pdata->rx_desc_count = XGBE_RX_DESC_CNT;
 -
 +	/* Calculate the number of Tx and Rx rings to be created */
 +	pdata->tx_ring_count = min_t(unsigned int, num_online_cpus(),
 +				     pdata->hw_feat.tx_ch_cnt);
++=======
+ 	/* Adjust the number of queues based on interrupts assigned */
+ 	if (pdata->channel_irq_count) {
+ 		pdata->tx_ring_count = min_t(unsigned int, pdata->tx_ring_count,
+ 					     pdata->channel_irq_count);
+ 		pdata->rx_ring_count = min_t(unsigned int, pdata->rx_ring_count,
+ 					     pdata->channel_irq_count);
+ 
+ 		if (netif_msg_probe(pdata))
+ 			dev_dbg(pdata->dev,
+ 				"adjusted TX/RX DMA channel count = %u/%u\n",
+ 				pdata->tx_ring_count, pdata->rx_ring_count);
+ 	}
+ 
+ 	/* Set the number of queues */
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  	ret = netif_set_real_num_tx_queues(netdev, pdata->tx_ring_count);
  	if (ret) {
  		dev_err(dev, "error setting real tx queue count\n");
@@@ -418,14 -378,38 +435,21 @@@
  	ret = register_netdev(netdev);
  	if (ret) {
  		dev_err(dev, "net device registration failed\n");
 -		return ret;
 -	}
 -
 -	/* Create the PHY/ANEG name based on netdev name */
 -	snprintf(pdata->an_name, sizeof(pdata->an_name) - 1, "%s-pcs",
 -		 netdev_name(netdev));
 -
 -	/* Create workqueues */
 -	pdata->dev_workqueue =
 -		create_singlethread_workqueue(netdev_name(netdev));
 -	if (!pdata->dev_workqueue) {
 -		netdev_err(netdev, "device workqueue creation failed\n");
 -		ret = -ENOMEM;
 -		goto err_netdev;
 -	}
 -
 -	pdata->an_workqueue =
 -		create_singlethread_workqueue(pdata->an_name);
 -	if (!pdata->an_workqueue) {
 -		netdev_err(netdev, "phy workqueue creation failed\n");
 -		ret = -ENOMEM;
 -		goto err_wq;
 +		goto err_reg_netdev;
  	}
  
 -	xgbe_ptp_register(pdata);
 -
  	xgbe_debugfs_init(pdata);
  
++<<<<<<< HEAD
 +	netdev_notice(netdev, "net device enabled\n");
 +
 +	DBGPR("<-- xgbe_probe\n");
++=======
+ 	netif_dbg(pdata, drv, pdata->netdev, "%u Tx software queues\n",
+ 		  pdata->tx_ring_count);
+ 	netif_dbg(pdata, drv, pdata->netdev, "%u Rx software queues\n",
+ 		  pdata->rx_ring_count);
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  
  	return 0;
  
@@@ -444,84 -422,46 +468,94 @@@ err_alloc
  	return ret;
  }
  
 -void xgbe_deconfig_netdev(struct xgbe_prv_data *pdata)
 +static int xgbe_remove(struct platform_device *pdev)
  {
 -	struct net_device *netdev = pdata->netdev;
 -
 -	xgbe_debugfs_exit(pdata);
 +	struct net_device *netdev = platform_get_drvdata(pdev);
 +	struct xgbe_prv_data *pdata = netdev_priv(netdev);
  
 -	xgbe_ptp_unregister(pdata);
 +	DBGPR("-->xgbe_remove\n");
  
 -	pdata->phy_if.phy_exit(pdata);
 +	xgbe_debugfs_exit(pdata);
  
 -	flush_workqueue(pdata->an_workqueue);
 -	destroy_workqueue(pdata->an_workqueue);
 +	unregister_netdev(netdev);
  
 -	flush_workqueue(pdata->dev_workqueue);
 -	destroy_workqueue(pdata->dev_workqueue);
 +	xgbe_mdio_unregister(pdata);
  
 -	unregister_netdev(netdev);
 -}
 +	kfree(pdata->mii_bus_id);
  
 -static int __init xgbe_mod_init(void)
 -{
 -	int ret;
 +	free_netdev(netdev);
  
 -	ret = xgbe_platform_init();
 -	if (ret)
 -		return ret;
 +	DBGPR("<--xgbe_remove\n");
  
+ 	ret = xgbe_pci_init();
+ 	if (ret)
+ 		return ret;
+ 
  	return 0;
  }
  
 -static void __exit xgbe_mod_exit(void)
 +#ifdef CONFIG_PM
 +static int xgbe_suspend(struct device *dev)
  {
++<<<<<<< HEAD
 +	struct net_device *netdev = dev_get_drvdata(dev);
 +	int ret;
 +
 +	DBGPR("-->xgbe_suspend\n");
 +
 +	if (!netif_running(netdev)) {
 +		DBGPR("<--xgbe_dev_suspend\n");
 +		return -EINVAL;
 +	}
 +
 +	ret = xgbe_powerdown(netdev, XGMAC_DRIVER_CONTEXT);
 +
 +	DBGPR("<--xgbe_suspend\n");
 +
 +	return ret;
++=======
+ 	xgbe_pci_exit();
+ 
+ 	xgbe_platform_exit();
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  }
  
 -module_init(xgbe_mod_init);
 -module_exit(xgbe_mod_exit);
 +static int xgbe_resume(struct device *dev)
 +{
 +	struct net_device *netdev = dev_get_drvdata(dev);
 +	int ret;
 +
 +	DBGPR("-->xgbe_resume\n");
 +
 +	if (!netif_running(netdev)) {
 +		DBGPR("<--xgbe_dev_resume\n");
 +		return -EINVAL;
 +	}
 +
 +	ret = xgbe_powerup(netdev, XGMAC_DRIVER_CONTEXT);
 +
 +	DBGPR("<--xgbe_resume\n");
 +
 +	return ret;
 +}
 +#endif /* CONFIG_PM */
 +
 +static const struct of_device_id xgbe_of_match[] = {
 +	{ .compatible = "amd,xgbe-seattle-v1a", },
 +	{},
 +};
 +
 +MODULE_DEVICE_TABLE(of, xgbe_of_match);
 +static SIMPLE_DEV_PM_OPS(xgbe_pm_ops, xgbe_suspend, xgbe_resume);
 +
 +static struct platform_driver xgbe_driver = {
 +	.driver = {
 +		.name = "amd-xgbe",
 +		.of_match_table = xgbe_of_match,
 +		.pm = &xgbe_pm_ops,
 +	},
 +	.probe = xgbe_probe,
 +	.remove = xgbe_remove,
 +};
 +
 +module_platform_driver(xgbe_driver);
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
index 8514b5841ecd,6d99943f84b2..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
@@@ -124,73 -125,896 +124,927 @@@
  #include "xgbe.h"
  #include "xgbe-common.h"
  
 -static void xgbe_an37_clear_interrupts(struct xgbe_prv_data *pdata)
 +
 +static int xgbe_mdio_read(struct mii_bus *mii, int prtad, int mmd_reg)
  {
 -	int reg;
 +	struct xgbe_prv_data *pdata = mii->priv;
 +	struct xgbe_hw_if *hw_if = &pdata->hw_if;
 +	int mmd_data;
  
 -	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT);
 -	reg &= ~XGBE_AN_CL37_INT_MASK;
 -	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT, reg);
 +	DBGPR_MDIO("-->xgbe_mdio_read: prtad=%#x mmd_reg=%#x\n",
 +		   prtad, mmd_reg);
 +
 +	mmd_data = hw_if->read_mmd_regs(pdata, prtad, mmd_reg);
 +
 +	DBGPR_MDIO("<--xgbe_mdio_read: mmd_data=%#x\n", mmd_data);
 +
 +	return mmd_data;
  }
  
 -static void xgbe_an37_disable_interrupts(struct xgbe_prv_data *pdata)
 +static int xgbe_mdio_write(struct mii_bus *mii, int prtad, int mmd_reg,
 +			   u16 mmd_val)
  {
 -	int reg;
 +	struct xgbe_prv_data *pdata = mii->priv;
 +	struct xgbe_hw_if *hw_if = &pdata->hw_if;
 +	int mmd_data = mmd_val;
  
 -	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL);
 -	reg &= ~XGBE_AN_CL37_INT_MASK;
 -	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL, reg);
 +	DBGPR_MDIO("-->xgbe_mdio_write: prtad=%#x mmd_reg=%#x mmd_data=%#x\n",
 +		   prtad, mmd_reg, mmd_data);
  
 -	reg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL);
 -	reg &= ~XGBE_PCS_CL37_BP;
 -	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL, reg);
 +	hw_if->write_mmd_regs(pdata, prtad, mmd_reg, mmd_data);
 +
 +	DBGPR_MDIO("<--xgbe_mdio_write\n");
 +
 +	return 0;
  }
  
++<<<<<<< HEAD
 +static void xgbe_adjust_link(struct net_device *netdev)
++=======
+ static void xgbe_an37_enable_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL);
+ 	reg |= XGBE_PCS_CL37_BP;
+ 	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_PCS_DIG_CTRL, reg);
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL);
+ 	reg |= XGBE_AN_CL37_INT_MASK;
+ 	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL, reg);
+ }
+ 
+ static void xgbe_an73_clear_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INT, 0);
+ }
+ 
+ static void xgbe_an73_disable_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INTMASK, 0);
+ }
+ 
+ static void xgbe_an73_enable_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INTMASK, XGBE_AN_CL73_INT_MASK);
+ }
+ 
+ static void xgbe_an_enable_interrupts(struct xgbe_prv_data *pdata)
+ {
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 		xgbe_an73_enable_interrupts(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_enable_interrupts(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void xgbe_an_clear_interrupts_all(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an73_clear_interrupts(pdata);
+ 	xgbe_an37_clear_interrupts(pdata);
+ }
+ 
+ static void xgbe_an73_enable_kr_training(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL);
+ 
+ 	reg |= XGBE_KR_TRAINING_ENABLE;
+ 	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL, reg);
+ }
+ 
+ static void xgbe_an73_disable_kr_training(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL);
+ 
+ 	reg &= ~XGBE_KR_TRAINING_ENABLE;
+ 	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL, reg);
+ }
+ 
+ static void xgbe_kr_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Enable KR training */
+ 	xgbe_an73_enable_kr_training(pdata);
+ 
+ 	/* Set MAC to 10G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_10000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_KR);
+ }
+ 
+ static void xgbe_kx_2500_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 2.5G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_2500);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_KX_2500);
+ }
+ 
+ static void xgbe_kx_1000_mode(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable KR training */
+ 	xgbe_an73_disable_kr_training(pdata);
+ 
+ 	/* Set MAC to 1G speed */
+ 	pdata->hw_if.set_speed(pdata, SPEED_1000);
+ 
+ 	/* Call PHY implementation support to complete rate change */
+ 	pdata->phy_if.phy_impl.set_mode(pdata, XGBE_MODE_KX_1000);
+ }
+ 
+ static enum xgbe_mode xgbe_cur_mode(struct xgbe_prv_data *pdata)
+ {
+ 	return pdata->phy_if.phy_impl.cur_mode(pdata);
+ }
+ 
+ static bool xgbe_in_kr_mode(struct xgbe_prv_data *pdata)
+ {
+ 	return (xgbe_cur_mode(pdata) == XGBE_MODE_KR);
+ }
+ 
+ static void xgbe_change_mode(struct xgbe_prv_data *pdata,
+ 			     enum xgbe_mode mode)
+ {
+ 	switch (mode) {
+ 	case XGBE_MODE_KX_1000:
+ 		xgbe_kx_1000_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_KX_2500:
+ 		xgbe_kx_2500_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_KR:
+ 		xgbe_kr_mode(pdata);
+ 		break;
+ 	case XGBE_MODE_UNKNOWN:
+ 		break;
+ 	default:
+ 		netif_dbg(pdata, link, pdata->netdev,
+ 			  "invalid operation mode requested (%u)\n", mode);
+ 	}
+ }
+ 
+ static void xgbe_switch_mode(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_change_mode(pdata, pdata->phy_if.phy_impl.switch_mode(pdata));
+ }
+ 
+ static void xgbe_set_mode(struct xgbe_prv_data *pdata,
+ 			  enum xgbe_mode mode)
+ {
+ 	if (mode == xgbe_cur_mode(pdata))
+ 		return;
+ 
+ 	xgbe_change_mode(pdata, mode);
+ }
+ 
+ static bool xgbe_use_mode(struct xgbe_prv_data *pdata,
+ 			  enum xgbe_mode mode)
+ {
+ 	return pdata->phy_if.phy_impl.use_mode(pdata, mode);
+ }
+ 
+ static void xgbe_an37_set(struct xgbe_prv_data *pdata, bool enable,
+ 			  bool restart)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_CTRL1);
+ 	reg &= ~MDIO_VEND2_CTRL1_AN_ENABLE;
+ 
+ 	if (enable)
+ 		reg |= MDIO_VEND2_CTRL1_AN_ENABLE;
+ 
+ 	if (restart)
+ 		reg |= MDIO_VEND2_CTRL1_AN_RESTART;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_CTRL1, reg);
+ }
+ 
+ static void xgbe_an37_restart(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an37_enable_interrupts(pdata);
+ 	xgbe_an37_set(pdata, true, true);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL37 AN enabled/restarted\n");
+ }
+ 
+ static void xgbe_an37_disable(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an37_set(pdata, false, false);
+ 	xgbe_an37_disable_interrupts(pdata);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL37 AN disabled\n");
+ }
+ 
+ static void xgbe_an73_set(struct xgbe_prv_data *pdata, bool enable,
+ 			  bool restart)
+ {
+ 	unsigned int reg;
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_CTRL1);
+ 	reg &= ~MDIO_AN_CTRL1_ENABLE;
+ 
+ 	if (enable)
+ 		reg |= MDIO_AN_CTRL1_ENABLE;
+ 
+ 	if (restart)
+ 		reg |= MDIO_AN_CTRL1_RESTART;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_CTRL1, reg);
+ }
+ 
+ static void xgbe_an73_restart(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an73_enable_interrupts(pdata);
+ 	xgbe_an73_set(pdata, true, true);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL73 AN enabled/restarted\n");
+ }
+ 
+ static void xgbe_an73_disable(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an73_set(pdata, false, false);
+ 	xgbe_an73_disable_interrupts(pdata);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL73 AN disabled\n");
+ }
+ 
+ static void xgbe_an_restart(struct xgbe_prv_data *pdata)
+ {
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 		xgbe_an73_restart(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_restart(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void xgbe_an_disable(struct xgbe_prv_data *pdata)
+ {
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 		xgbe_an73_disable(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_disable(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static void xgbe_an_disable_all(struct xgbe_prv_data *pdata)
+ {
+ 	xgbe_an73_disable(pdata);
+ 	xgbe_an37_disable(pdata);
+ }
+ 
+ static enum xgbe_an xgbe_an73_tx_training(struct xgbe_prv_data *pdata,
+ 					  enum xgbe_rx *state)
+ {
+ 	unsigned int ad_reg, lp_reg, reg;
+ 
+ 	*state = XGBE_RX_COMPLETE;
+ 
+ 	/* If we're not in KR mode then we're done */
+ 	if (!xgbe_in_kr_mode(pdata))
+ 		return XGBE_AN_PAGE_RECEIVED;
+ 
+ 	/* Enable/Disable FEC */
+ 	ad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2);
+ 	lp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 2);
+ 
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_FECCTRL);
+ 	reg &= ~(MDIO_PMA_10GBR_FECABLE_ABLE | MDIO_PMA_10GBR_FECABLE_ERRABLE);
+ 	if ((ad_reg & 0xc000) && (lp_reg & 0xc000))
+ 		reg |= pdata->fec_ability;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_FECCTRL, reg);
+ 
+ 	/* Start KR training */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL);
+ 	if (reg & XGBE_KR_TRAINING_ENABLE) {
+ 		if (pdata->phy_if.phy_impl.kr_training_pre)
+ 			pdata->phy_if.phy_impl.kr_training_pre(pdata);
+ 
+ 		reg |= XGBE_KR_TRAINING_START;
+ 		XMDIO_WRITE(pdata, MDIO_MMD_PMAPMD, MDIO_PMA_10GBR_PMD_CTRL,
+ 			    reg);
+ 
+ 		if (pdata->phy_if.phy_impl.kr_training_post)
+ 			pdata->phy_if.phy_impl.kr_training_post(pdata);
+ 
+ 		netif_dbg(pdata, link, pdata->netdev,
+ 			  "KR training initiated\n");
+ 	}
+ 
+ 	return XGBE_AN_PAGE_RECEIVED;
+ }
+ 
+ static enum xgbe_an xgbe_an73_tx_xnp(struct xgbe_prv_data *pdata,
+ 				     enum xgbe_rx *state)
+ {
+ 	u16 msg;
+ 
+ 	*state = XGBE_RX_XNP;
+ 
+ 	msg = XGBE_XNP_MCF_NULL_MESSAGE;
+ 	msg |= XGBE_XNP_MP_FORMATTED;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_XNP + 2, 0);
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_XNP + 1, 0);
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_XNP, msg);
+ 
+ 	return XGBE_AN_PAGE_RECEIVED;
+ }
+ 
+ static enum xgbe_an xgbe_an73_rx_bpa(struct xgbe_prv_data *pdata,
+ 				     enum xgbe_rx *state)
+ {
+ 	unsigned int link_support;
+ 	unsigned int reg, ad_reg, lp_reg;
+ 
+ 	/* Read Base Ability register 2 first */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 1);
+ 
+ 	/* Check for a supported mode, otherwise restart in a different one */
+ 	link_support = xgbe_in_kr_mode(pdata) ? 0x80 : 0x20;
+ 	if (!(reg & link_support))
+ 		return XGBE_AN_INCOMPAT_LINK;
+ 
+ 	/* Check Extended Next Page support */
+ 	ad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE);
+ 	lp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA);
+ 
+ 	return ((ad_reg & XGBE_XNP_NP_EXCHANGE) ||
+ 		(lp_reg & XGBE_XNP_NP_EXCHANGE))
+ 	       ? xgbe_an73_tx_xnp(pdata, state)
+ 	       : xgbe_an73_tx_training(pdata, state);
+ }
+ 
+ static enum xgbe_an xgbe_an73_rx_xnp(struct xgbe_prv_data *pdata,
+ 				     enum xgbe_rx *state)
+ {
+ 	unsigned int ad_reg, lp_reg;
+ 
+ 	/* Check Extended Next Page support */
+ 	ad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_XNP);
+ 	lp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPX);
+ 
+ 	return ((ad_reg & XGBE_XNP_NP_EXCHANGE) ||
+ 		(lp_reg & XGBE_XNP_NP_EXCHANGE))
+ 	       ? xgbe_an73_tx_xnp(pdata, state)
+ 	       : xgbe_an73_tx_training(pdata, state);
+ }
+ 
+ static enum xgbe_an xgbe_an73_page_received(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_rx *state;
+ 	unsigned long an_timeout;
+ 	enum xgbe_an ret;
+ 
+ 	if (!pdata->an_start) {
+ 		pdata->an_start = jiffies;
+ 	} else {
+ 		an_timeout = pdata->an_start +
+ 			     msecs_to_jiffies(XGBE_AN_MS_TIMEOUT);
+ 		if (time_after(jiffies, an_timeout)) {
+ 			/* Auto-negotiation timed out, reset state */
+ 			pdata->kr_state = XGBE_RX_BPA;
+ 			pdata->kx_state = XGBE_RX_BPA;
+ 
+ 			pdata->an_start = jiffies;
+ 
+ 			netif_dbg(pdata, link, pdata->netdev,
+ 				  "CL73 AN timed out, resetting state\n");
+ 		}
+ 	}
+ 
+ 	state = xgbe_in_kr_mode(pdata) ? &pdata->kr_state
+ 				       : &pdata->kx_state;
+ 
+ 	switch (*state) {
+ 	case XGBE_RX_BPA:
+ 		ret = xgbe_an73_rx_bpa(pdata, state);
+ 		break;
+ 
+ 	case XGBE_RX_XNP:
+ 		ret = xgbe_an73_rx_xnp(pdata, state);
+ 		break;
+ 
+ 	default:
+ 		ret = XGBE_AN_ERROR;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static enum xgbe_an xgbe_an73_incompat_link(struct xgbe_prv_data *pdata)
+ {
+ 	/* Be sure we aren't looping trying to negotiate */
+ 	if (xgbe_in_kr_mode(pdata)) {
+ 		pdata->kr_state = XGBE_RX_ERROR;
+ 
+ 		if (!(pdata->phy.advertising & ADVERTISED_1000baseKX_Full) &&
+ 		    !(pdata->phy.advertising & ADVERTISED_2500baseX_Full))
+ 			return XGBE_AN_NO_LINK;
+ 
+ 		if (pdata->kx_state != XGBE_RX_BPA)
+ 			return XGBE_AN_NO_LINK;
+ 	} else {
+ 		pdata->kx_state = XGBE_RX_ERROR;
+ 
+ 		if (!(pdata->phy.advertising & ADVERTISED_10000baseKR_Full))
+ 			return XGBE_AN_NO_LINK;
+ 
+ 		if (pdata->kr_state != XGBE_RX_BPA)
+ 			return XGBE_AN_NO_LINK;
+ 	}
+ 
+ 	xgbe_an73_disable(pdata);
+ 
+ 	xgbe_switch_mode(pdata);
+ 
+ 	xgbe_an73_restart(pdata);
+ 
+ 	return XGBE_AN_INCOMPAT_LINK;
+ }
+ 
+ static void xgbe_an37_isr(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	/* Disable AN interrupts */
+ 	xgbe_an37_disable_interrupts(pdata);
+ 
+ 	/* Save the interrupt(s) that fired */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT);
+ 	pdata->an_int = reg & XGBE_AN_CL37_INT_MASK;
+ 	pdata->an_status = reg & ~XGBE_AN_CL37_INT_MASK;
+ 
+ 	if (pdata->an_int) {
+ 		/* Clear the interrupt(s) that fired and process them */
+ 		reg &= ~XGBE_AN_CL37_INT_MASK;
+ 		XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_STAT, reg);
+ 
+ 		queue_work(pdata->an_workqueue, &pdata->an_irq_work);
+ 	} else {
+ 		/* Enable AN interrupts */
+ 		xgbe_an37_enable_interrupts(pdata);
+ 	}
+ }
+ 
+ static void xgbe_an73_isr(struct xgbe_prv_data *pdata)
+ {
+ 	/* Disable AN interrupts */
+ 	xgbe_an73_disable_interrupts(pdata);
+ 
+ 	/* Save the interrupt(s) that fired */
+ 	pdata->an_int = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_INT);
+ 
+ 	if (pdata->an_int) {
+ 		/* Clear the interrupt(s) that fired and process them */
+ 		XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_INT, ~pdata->an_int);
+ 
+ 		queue_work(pdata->an_workqueue, &pdata->an_irq_work);
+ 	} else {
+ 		/* Enable AN interrupts */
+ 		xgbe_an73_enable_interrupts(pdata);
+ 	}
+ }
+ 
+ static irqreturn_t xgbe_an_isr(int irq, void *data)
+ {
+ 	struct xgbe_prv_data *pdata = (struct xgbe_prv_data *)data;
+ 
+ 	netif_dbg(pdata, intr, pdata->netdev, "AN interrupt received\n");
+ 
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 		xgbe_an73_isr(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_isr(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static irqreturn_t xgbe_an_combined_isr(int irq, struct xgbe_prv_data *pdata)
+ {
+ 	return xgbe_an_isr(irq, pdata);
+ }
+ 
+ static void xgbe_an_irq_work(struct work_struct *work)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(work,
+ 						   struct xgbe_prv_data,
+ 						   an_irq_work);
+ 
+ 	/* Avoid a race between enabling the IRQ and exiting the work by
+ 	 * waiting for the work to finish and then queueing it
+ 	 */
+ 	flush_work(&pdata->an_work);
+ 	queue_work(pdata->an_workqueue, &pdata->an_work);
+ }
+ 
+ static const char *xgbe_state_as_string(enum xgbe_an state)
+ {
+ 	switch (state) {
+ 	case XGBE_AN_READY:
+ 		return "Ready";
+ 	case XGBE_AN_PAGE_RECEIVED:
+ 		return "Page-Received";
+ 	case XGBE_AN_INCOMPAT_LINK:
+ 		return "Incompatible-Link";
+ 	case XGBE_AN_COMPLETE:
+ 		return "Complete";
+ 	case XGBE_AN_NO_LINK:
+ 		return "No-Link";
+ 	case XGBE_AN_ERROR:
+ 		return "Error";
+ 	default:
+ 		return "Undefined";
+ 	}
+ }
+ 
+ static void xgbe_an37_state_machine(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_an cur_state = pdata->an_state;
+ 
+ 	if (!pdata->an_int)
+ 		return;
+ 
+ 	if (pdata->an_int & XGBE_AN_CL37_INT_CMPLT) {
+ 		pdata->an_state = XGBE_AN_COMPLETE;
+ 		pdata->an_int &= ~XGBE_AN_CL37_INT_CMPLT;
+ 
+ 		/* If SGMII is enabled, check the link status */
+ 		if ((pdata->an_mode == XGBE_AN_MODE_CL37_SGMII) &&
+ 		    !(pdata->an_status & XGBE_SGMII_AN_LINK_STATUS))
+ 			pdata->an_state = XGBE_AN_NO_LINK;
+ 	}
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL37 AN %s\n",
+ 		  xgbe_state_as_string(pdata->an_state));
+ 
+ 	cur_state = pdata->an_state;
+ 
+ 	switch (pdata->an_state) {
+ 	case XGBE_AN_READY:
+ 		break;
+ 
+ 	case XGBE_AN_COMPLETE:
+ 		netif_dbg(pdata, link, pdata->netdev,
+ 			  "Auto negotiation successful\n");
+ 		break;
+ 
+ 	case XGBE_AN_NO_LINK:
+ 		break;
+ 
+ 	default:
+ 		pdata->an_state = XGBE_AN_ERROR;
+ 	}
+ 
+ 	if (pdata->an_state == XGBE_AN_ERROR) {
+ 		netdev_err(pdata->netdev,
+ 			   "error during auto-negotiation, state=%u\n",
+ 			   cur_state);
+ 
+ 		pdata->an_int = 0;
+ 		xgbe_an37_clear_interrupts(pdata);
+ 	}
+ 
+ 	if (pdata->an_state >= XGBE_AN_COMPLETE) {
+ 		pdata->an_result = pdata->an_state;
+ 		pdata->an_state = XGBE_AN_READY;
+ 
+ 		netif_dbg(pdata, link, pdata->netdev, "CL37 AN result: %s\n",
+ 			  xgbe_state_as_string(pdata->an_result));
+ 	}
+ 
+ 	xgbe_an37_enable_interrupts(pdata);
+ }
+ 
+ static void xgbe_an73_state_machine(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_an cur_state = pdata->an_state;
+ 
+ 	if (!pdata->an_int)
+ 		return;
+ 
+ next_int:
+ 	if (pdata->an_int & XGBE_AN_CL73_PG_RCV) {
+ 		pdata->an_state = XGBE_AN_PAGE_RECEIVED;
+ 		pdata->an_int &= ~XGBE_AN_CL73_PG_RCV;
+ 	} else if (pdata->an_int & XGBE_AN_CL73_INC_LINK) {
+ 		pdata->an_state = XGBE_AN_INCOMPAT_LINK;
+ 		pdata->an_int &= ~XGBE_AN_CL73_INC_LINK;
+ 	} else if (pdata->an_int & XGBE_AN_CL73_INT_CMPLT) {
+ 		pdata->an_state = XGBE_AN_COMPLETE;
+ 		pdata->an_int &= ~XGBE_AN_CL73_INT_CMPLT;
+ 	} else {
+ 		pdata->an_state = XGBE_AN_ERROR;
+ 	}
+ 
+ again:
+ 	netif_dbg(pdata, link, pdata->netdev, "CL73 AN %s\n",
+ 		  xgbe_state_as_string(pdata->an_state));
+ 
+ 	cur_state = pdata->an_state;
+ 
+ 	switch (pdata->an_state) {
+ 	case XGBE_AN_READY:
+ 		pdata->an_supported = 0;
+ 		break;
+ 
+ 	case XGBE_AN_PAGE_RECEIVED:
+ 		pdata->an_state = xgbe_an73_page_received(pdata);
+ 		pdata->an_supported++;
+ 		break;
+ 
+ 	case XGBE_AN_INCOMPAT_LINK:
+ 		pdata->an_supported = 0;
+ 		pdata->parallel_detect = 0;
+ 		pdata->an_state = xgbe_an73_incompat_link(pdata);
+ 		break;
+ 
+ 	case XGBE_AN_COMPLETE:
+ 		pdata->parallel_detect = pdata->an_supported ? 0 : 1;
+ 		netif_dbg(pdata, link, pdata->netdev, "%s successful\n",
+ 			  pdata->an_supported ? "Auto negotiation"
+ 					      : "Parallel detection");
+ 		break;
+ 
+ 	case XGBE_AN_NO_LINK:
+ 		break;
+ 
+ 	default:
+ 		pdata->an_state = XGBE_AN_ERROR;
+ 	}
+ 
+ 	if (pdata->an_state == XGBE_AN_NO_LINK) {
+ 		pdata->an_int = 0;
+ 		xgbe_an73_clear_interrupts(pdata);
+ 	} else if (pdata->an_state == XGBE_AN_ERROR) {
+ 		netdev_err(pdata->netdev,
+ 			   "error during auto-negotiation, state=%u\n",
+ 			   cur_state);
+ 
+ 		pdata->an_int = 0;
+ 		xgbe_an73_clear_interrupts(pdata);
+ 	}
+ 
+ 	if (pdata->an_state >= XGBE_AN_COMPLETE) {
+ 		pdata->an_result = pdata->an_state;
+ 		pdata->an_state = XGBE_AN_READY;
+ 		pdata->kr_state = XGBE_RX_BPA;
+ 		pdata->kx_state = XGBE_RX_BPA;
+ 		pdata->an_start = 0;
+ 
+ 		netif_dbg(pdata, link, pdata->netdev, "CL73 AN result: %s\n",
+ 			  xgbe_state_as_string(pdata->an_result));
+ 	}
+ 
+ 	if (cur_state != pdata->an_state)
+ 		goto again;
+ 
+ 	if (pdata->an_int)
+ 		goto next_int;
+ 
+ 	xgbe_an73_enable_interrupts(pdata);
+ }
+ 
+ static void xgbe_an_state_machine(struct work_struct *work)
+ {
+ 	struct xgbe_prv_data *pdata = container_of(work,
+ 						   struct xgbe_prv_data,
+ 						   an_work);
+ 
+ 	mutex_lock(&pdata->an_mutex);
+ 
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 		xgbe_an73_state_machine(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_state_machine(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	mutex_unlock(&pdata->an_mutex);
+ }
+ 
+ static void xgbe_an37_init(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	/* Set up Advertisement register */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_ADVERTISE);
+ 	if (pdata->phy.advertising & ADVERTISED_Pause)
+ 		reg |= 0x100;
+ 	else
+ 		reg &= ~0x100;
+ 
+ 	if (pdata->phy.advertising & ADVERTISED_Asym_Pause)
+ 		reg |= 0x80;
+ 	else
+ 		reg &= ~0x80;
+ 
+ 	/* Full duplex, but not half */
+ 	reg |= XGBE_AN_CL37_FD_MASK;
+ 	reg &= ~XGBE_AN_CL37_HD_MASK;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_ADVERTISE, reg);
+ 
+ 	/* Set up the Control register */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL);
+ 	reg &= XGBE_AN_CL37_TX_CONFIG_MASK;
+ 	reg &= XGBE_AN_CL37_PCS_MODE_MASK;
+ 
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL37:
+ 		reg |= XGBE_AN_CL37_PCS_MODE_BASEX;
+ 		break;
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		reg |= XGBE_AN_CL37_PCS_MODE_SGMII;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_VEND2, MDIO_VEND2_AN_CTRL, reg);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL37 AN (%s) initialized\n",
+ 		  (pdata->an_mode == XGBE_AN_MODE_CL37) ? "BaseX" : "SGMII");
+ }
+ 
+ static void xgbe_an73_init(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int reg;
+ 
+ 	/* Set up Advertisement register 3 first */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2);
+ 	if (pdata->phy.advertising & ADVERTISED_10000baseR_FEC)
+ 		reg |= 0xc000;
+ 	else
+ 		reg &= ~0xc000;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2, reg);
+ 
+ 	/* Set up Advertisement register 2 next */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1);
+ 	if (pdata->phy.advertising & ADVERTISED_10000baseKR_Full)
+ 		reg |= 0x80;
+ 	else
+ 		reg &= ~0x80;
+ 
+ 	if ((pdata->phy.advertising & ADVERTISED_1000baseKX_Full) ||
+ 	    (pdata->phy.advertising & ADVERTISED_2500baseX_Full))
+ 		reg |= 0x20;
+ 	else
+ 		reg &= ~0x20;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1, reg);
+ 
+ 	/* Set up Advertisement register 1 last */
+ 	reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE);
+ 	if (pdata->phy.advertising & ADVERTISED_Pause)
+ 		reg |= 0x400;
+ 	else
+ 		reg &= ~0x400;
+ 
+ 	if (pdata->phy.advertising & ADVERTISED_Asym_Pause)
+ 		reg |= 0x800;
+ 	else
+ 		reg &= ~0x800;
+ 
+ 	/* We don't intend to perform XNP */
+ 	reg &= ~XGBE_XNP_NP_EXCHANGE;
+ 
+ 	XMDIO_WRITE(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE, reg);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "CL73 AN initialized\n");
+ }
+ 
+ static void xgbe_an_init(struct xgbe_prv_data *pdata)
+ {
+ 	/* Set up advertisement registers based on current settings */
+ 	pdata->an_mode = pdata->phy_if.phy_impl.an_mode(pdata);
+ 	switch (pdata->an_mode) {
+ 	case XGBE_AN_MODE_CL73:
+ 		xgbe_an73_init(pdata);
+ 		break;
+ 	case XGBE_AN_MODE_CL37:
+ 	case XGBE_AN_MODE_CL37_SGMII:
+ 		xgbe_an37_init(pdata);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static const char *xgbe_phy_fc_string(struct xgbe_prv_data *pdata)
+ {
+ 	if (pdata->tx_pause && pdata->rx_pause)
+ 		return "rx/tx";
+ 	else if (pdata->rx_pause)
+ 		return "rx";
+ 	else if (pdata->tx_pause)
+ 		return "tx";
+ 	else
+ 		return "off";
+ }
+ 
+ static const char *xgbe_phy_speed_string(int speed)
+ {
+ 	switch (speed) {
+ 	case SPEED_1000:
+ 		return "1Gbps";
+ 	case SPEED_2500:
+ 		return "2.5Gbps";
+ 	case SPEED_10000:
+ 		return "10Gbps";
+ 	case SPEED_UNKNOWN:
+ 		return "Unknown";
+ 	default:
+ 		return "Unsupported";
+ 	}
+ }
+ 
+ static void xgbe_phy_print_status(struct xgbe_prv_data *pdata)
+ {
+ 	if (pdata->phy.link)
+ 		netdev_info(pdata->netdev,
+ 			    "Link is Up - %s/%s - flow control %s\n",
+ 			    xgbe_phy_speed_string(pdata->phy.speed),
+ 			    pdata->phy.duplex == DUPLEX_FULL ? "Full" : "Half",
+ 			    xgbe_phy_fc_string(pdata));
+ 	else
+ 		netdev_info(pdata->netdev, "Link is Down\n");
+ }
+ 
+ static void xgbe_phy_adjust_link(struct xgbe_prv_data *pdata)
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  {
 +	struct xgbe_prv_data *pdata = netdev_priv(netdev);
 +	struct xgbe_hw_if *hw_if = &pdata->hw_if;
 +	struct phy_device *phydev = pdata->phydev;
  	int new_state = 0;
  
 -	if (pdata->phy.link) {
 +	if (phydev == NULL)
 +		return;
 +
 +	DBGPR_MDIO("-->xgbe_adjust_link: address=%d, newlink=%d, curlink=%d\n",
 +		   phydev->addr, phydev->link, pdata->phy_link);
 +
 +	if (phydev->link) {
  		/* Flow control support */
 -		pdata->pause_autoneg = pdata->phy.pause_autoneg;
 +		if (pdata->pause_autoneg) {
 +			if (phydev->pause || phydev->asym_pause) {
 +				pdata->tx_pause = 1;
 +				pdata->rx_pause = 1;
 +			} else {
 +				pdata->tx_pause = 0;
 +				pdata->rx_pause = 0;
 +			}
 +		}
  
 -		if (pdata->tx_pause != pdata->phy.tx_pause) {
 -			new_state = 1;
 -			pdata->hw_if.config_tx_flow_control(pdata);
 -			pdata->tx_pause = pdata->phy.tx_pause;
 +		if (pdata->tx_pause != pdata->phy_tx_pause) {
 +			hw_if->config_tx_flow_control(pdata);
 +			pdata->phy_tx_pause = pdata->tx_pause;
  		}
  
 -		if (pdata->rx_pause != pdata->phy.rx_pause) {
 -			new_state = 1;
 -			pdata->hw_if.config_rx_flow_control(pdata);
 -			pdata->rx_pause = pdata->phy.rx_pause;
 +		if (pdata->rx_pause != pdata->phy_rx_pause) {
 +			hw_if->config_rx_flow_control(pdata);
 +			pdata->phy_rx_pause = pdata->rx_pause;
  		}
  
  		/* Speed support */
@@@ -223,206 -1033,425 +1077,503 @@@
  		pdata->phy_speed = SPEED_UNKNOWN;
  	}
  
 -	if (new_state && netif_msg_link(pdata))
 -		xgbe_phy_print_status(pdata);
 +	if (new_state)
 +		phy_print_status(phydev);
 +
 +	DBGPR_MDIO("<--xgbe_adjust_link\n");
  }
  
++<<<<<<< HEAD
 +void xgbe_dump_phy_registers(struct xgbe_prv_data *pdata)
++=======
+ static bool xgbe_phy_valid_speed(struct xgbe_prv_data *pdata, int speed)
+ {
+ 	return pdata->phy_if.phy_impl.valid_speed(pdata, speed);
+ }
+ 
+ static int xgbe_phy_config_fixed(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_mode mode;
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "fixed PHY configuration\n");
+ 
+ 	/* Disable auto-negotiation */
+ 	xgbe_an_disable(pdata);
+ 
+ 	/* Set specified mode for specified speed */
+ 	mode = pdata->phy_if.phy_impl.get_mode(pdata, pdata->phy.speed);
+ 	switch (mode) {
+ 	case XGBE_MODE_KX_1000:
+ 	case XGBE_MODE_KX_2500:
+ 	case XGBE_MODE_KR:
+ 		break;
+ 	case XGBE_MODE_UNKNOWN:
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Validate duplex mode */
+ 	if (pdata->phy.duplex != DUPLEX_FULL)
+ 		return -EINVAL;
+ 
+ 	xgbe_set_mode(pdata, mode);
+ 
+ 	return 0;
+ }
+ 
+ static int __xgbe_phy_config_aneg(struct xgbe_prv_data *pdata)
+ {
+ 	set_bit(XGBE_LINK_INIT, &pdata->dev_state);
+ 	pdata->link_check = jiffies;
+ 
+ 	if (pdata->phy.autoneg != AUTONEG_ENABLE)
+ 		return xgbe_phy_config_fixed(pdata);
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "AN PHY configuration\n");
+ 
+ 	/* Disable auto-negotiation interrupt */
+ 	disable_irq(pdata->an_irq);
+ 
+ 	/* Start auto-negotiation in a supported mode */
+ 	if (xgbe_use_mode(pdata, XGBE_MODE_KR)) {
+ 		xgbe_set_mode(pdata, XGBE_MODE_KR);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_KX_2500)) {
+ 		xgbe_set_mode(pdata, XGBE_MODE_KX_2500);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_KX_1000)) {
+ 		xgbe_set_mode(pdata, XGBE_MODE_KX_1000);
+ 	} else {
+ 		enable_irq(pdata->an_irq);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Disable and stop any in progress auto-negotiation */
+ 	xgbe_an_disable_all(pdata);
+ 
+ 	/* Clear any auto-negotitation interrupts */
+ 	xgbe_an_clear_interrupts_all(pdata);
+ 
+ 	pdata->an_result = XGBE_AN_READY;
+ 	pdata->an_state = XGBE_AN_READY;
+ 	pdata->kr_state = XGBE_RX_BPA;
+ 	pdata->kx_state = XGBE_RX_BPA;
+ 
+ 	/* Re-enable auto-negotiation interrupt */
+ 	enable_irq(pdata->an_irq);
+ 
+ 	xgbe_an_init(pdata);
+ 	xgbe_an_restart(pdata);
+ 
+ 	return 0;
+ }
+ 
+ static int xgbe_phy_config_aneg(struct xgbe_prv_data *pdata)
+ {
+ 	int ret;
+ 
+ 	mutex_lock(&pdata->an_mutex);
+ 
+ 	ret = __xgbe_phy_config_aneg(pdata);
+ 	if (ret)
+ 		set_bit(XGBE_LINK_ERR, &pdata->dev_state);
+ 	else
+ 		clear_bit(XGBE_LINK_ERR, &pdata->dev_state);
+ 
+ 	mutex_unlock(&pdata->an_mutex);
+ 
+ 	return ret;
+ }
+ 
+ static bool xgbe_phy_aneg_done(struct xgbe_prv_data *pdata)
+ {
+ 	return (pdata->an_result == XGBE_AN_COMPLETE);
+ }
+ 
+ static void xgbe_check_link_timeout(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned long link_timeout;
+ 
+ 	link_timeout = pdata->link_check + (XGBE_LINK_TIMEOUT * HZ);
+ 	if (time_after(jiffies, link_timeout)) {
+ 		netif_dbg(pdata, link, pdata->netdev, "AN link timeout\n");
+ 		xgbe_phy_config_aneg(pdata);
+ 	}
+ }
+ 
+ static enum xgbe_mode xgbe_phy_status_aneg(struct xgbe_prv_data *pdata)
+ {
+ 	return pdata->phy_if.phy_impl.an_outcome(pdata);
+ }
+ 
+ static void xgbe_phy_status_result(struct xgbe_prv_data *pdata)
+ {
+ 	enum xgbe_mode mode;
+ 
+ 	pdata->phy.lp_advertising = 0;
+ 
+ 	if ((pdata->phy.autoneg != AUTONEG_ENABLE) || pdata->parallel_detect)
+ 		mode = xgbe_cur_mode(pdata);
+ 	else
+ 		mode = xgbe_phy_status_aneg(pdata);
+ 
+ 	switch (mode) {
+ 	case XGBE_MODE_KX_1000:
+ 		pdata->phy.speed = SPEED_1000;
+ 		break;
+ 	case XGBE_MODE_KX_2500:
+ 		pdata->phy.speed = SPEED_2500;
+ 		break;
+ 	case XGBE_MODE_KR:
+ 		pdata->phy.speed = SPEED_10000;
+ 		break;
+ 	case XGBE_MODE_UNKNOWN:
+ 	default:
+ 		pdata->phy.speed = SPEED_UNKNOWN;
+ 	}
+ 
+ 	pdata->phy.duplex = DUPLEX_FULL;
+ 
+ 	xgbe_set_mode(pdata, mode);
+ }
+ 
+ static void xgbe_phy_status(struct xgbe_prv_data *pdata)
+ {
+ 	unsigned int link_aneg;
+ 
+ 	if (test_bit(XGBE_LINK_ERR, &pdata->dev_state)) {
+ 		netif_carrier_off(pdata->netdev);
+ 
+ 		pdata->phy.link = 0;
+ 		goto adjust_link;
+ 	}
+ 
+ 	link_aneg = (pdata->phy.autoneg == AUTONEG_ENABLE);
+ 
+ 	pdata->phy.link = pdata->phy_if.phy_impl.link_status(pdata);
+ 	if (pdata->phy.link) {
+ 		if (link_aneg && !xgbe_phy_aneg_done(pdata)) {
+ 			xgbe_check_link_timeout(pdata);
+ 			return;
+ 		}
+ 
+ 		xgbe_phy_status_result(pdata);
+ 
+ 		if (test_bit(XGBE_LINK_INIT, &pdata->dev_state))
+ 			clear_bit(XGBE_LINK_INIT, &pdata->dev_state);
+ 
+ 		netif_carrier_on(pdata->netdev);
+ 	} else {
+ 		if (test_bit(XGBE_LINK_INIT, &pdata->dev_state)) {
+ 			xgbe_check_link_timeout(pdata);
+ 
+ 			if (link_aneg)
+ 				return;
+ 		}
+ 
+ 		xgbe_phy_status_result(pdata);
+ 
+ 		netif_carrier_off(pdata->netdev);
+ 	}
+ 
+ adjust_link:
+ 	xgbe_phy_adjust_link(pdata);
+ }
+ 
+ static void xgbe_phy_stop(struct xgbe_prv_data *pdata)
+ {
+ 	netif_dbg(pdata, link, pdata->netdev, "stopping PHY\n");
+ 
+ 	if (!pdata->phy_started)
+ 		return;
+ 
+ 	/* Indicate the PHY is down */
+ 	pdata->phy_started = 0;
+ 
+ 	/* Disable auto-negotiation */
+ 	xgbe_an_disable_all(pdata);
+ 
+ 	if (pdata->dev_irq != pdata->an_irq)
+ 		devm_free_irq(pdata->dev, pdata->an_irq, pdata);
+ 
+ 	pdata->phy_if.phy_impl.stop(pdata);
+ 
+ 	pdata->phy.link = 0;
+ 	netif_carrier_off(pdata->netdev);
+ 
+ 	xgbe_phy_adjust_link(pdata);
+ }
+ 
+ static int xgbe_phy_start(struct xgbe_prv_data *pdata)
+ {
+ 	struct net_device *netdev = pdata->netdev;
+ 	int ret;
+ 
+ 	netif_dbg(pdata, link, pdata->netdev, "starting PHY\n");
+ 
+ 	ret = pdata->phy_if.phy_impl.start(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* If we have a separate AN irq, enable it */
+ 	if (pdata->dev_irq != pdata->an_irq) {
+ 		ret = devm_request_irq(pdata->dev, pdata->an_irq,
+ 				       xgbe_an_isr, 0, pdata->an_name,
+ 				       pdata);
+ 		if (ret) {
+ 			netdev_err(netdev, "phy irq request failed\n");
+ 			goto err_stop;
+ 		}
+ 	}
+ 
+ 	/* Set initial mode - call the mode setting routines
+ 	 * directly to insure we are properly configured
+ 	 */
+ 	if (xgbe_use_mode(pdata, XGBE_MODE_KR)) {
+ 		xgbe_kr_mode(pdata);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_KX_2500)) {
+ 		xgbe_kx_2500_mode(pdata);
+ 	} else if (xgbe_use_mode(pdata, XGBE_MODE_KX_1000)) {
+ 		xgbe_kx_1000_mode(pdata);
+ 	} else {
+ 		ret = -EINVAL;
+ 		goto err_irq;
+ 	}
+ 
+ 	/* Indicate the PHY is up and running */
+ 	pdata->phy_started = 1;
+ 
+ 	xgbe_an_init(pdata);
+ 	xgbe_an_enable_interrupts(pdata);
+ 
+ 	return xgbe_phy_config_aneg(pdata);
+ 
+ err_irq:
+ 	if (pdata->dev_irq != pdata->an_irq)
+ 		devm_free_irq(pdata->dev, pdata->an_irq, pdata);
+ 
+ err_stop:
+ 	pdata->phy_if.phy_impl.stop(pdata);
+ 
+ 	return ret;
+ }
+ 
+ static int xgbe_phy_reset(struct xgbe_prv_data *pdata)
+ {
+ 	int ret;
+ 
+ 	ret = pdata->phy_if.phy_impl.reset(pdata);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Disable auto-negotiation for now */
+ 	xgbe_an_disable_all(pdata);
+ 
+ 	/* Clear auto-negotiation interrupts */
+ 	xgbe_an_clear_interrupts_all(pdata);
+ 
+ 	return 0;
+ }
+ 
+ static void xgbe_dump_phy_registers(struct xgbe_prv_data *pdata)
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  {
  	struct device *dev = pdata->dev;
 -
 -	dev_dbg(dev, "\n************* PHY Reg dump **********************\n");
 -
 -	dev_dbg(dev, "PCS Control Reg (%#06x) = %#06x\n", MDIO_CTRL1,
 -		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1));
 -	dev_dbg(dev, "PCS Status Reg (%#06x) = %#06x\n", MDIO_STAT1,
 -		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1));
 -	dev_dbg(dev, "Phy Id (PHYS ID 1 %#06x)= %#06x\n", MDIO_DEVID1,
 -		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVID1));
 -	dev_dbg(dev, "Phy Id (PHYS ID 2 %#06x)= %#06x\n", MDIO_DEVID2,
 -		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVID2));
 -	dev_dbg(dev, "Devices in Package (%#06x)= %#06x\n", MDIO_DEVS1,
 -		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVS1));
 -	dev_dbg(dev, "Devices in Package (%#06x)= %#06x\n", MDIO_DEVS2,
 -		XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVS2));
 -
 -	dev_dbg(dev, "Auto-Neg Control Reg (%#06x) = %#06x\n", MDIO_CTRL1,
 -		XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_CTRL1));
 -	dev_dbg(dev, "Auto-Neg Status Reg (%#06x) = %#06x\n", MDIO_STAT1,
 -		XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_STAT1));
 -	dev_dbg(dev, "Auto-Neg Ad Reg 1 (%#06x) = %#06x\n",
 -		MDIO_AN_ADVERTISE,
 -		XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE));
 -	dev_dbg(dev, "Auto-Neg Ad Reg 2 (%#06x) = %#06x\n",
 -		MDIO_AN_ADVERTISE + 1,
 -		XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1));
 -	dev_dbg(dev, "Auto-Neg Ad Reg 3 (%#06x) = %#06x\n",
 -		MDIO_AN_ADVERTISE + 2,
 -		XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2));
 -	dev_dbg(dev, "Auto-Neg Completion Reg (%#06x) = %#06x\n",
 -		MDIO_AN_COMP_STAT,
 -		XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_COMP_STAT));
 -
 -	dev_dbg(dev, "\n*************************************************\n");
 -}
 -
 -static int xgbe_phy_best_advertised_speed(struct xgbe_prv_data *pdata)
 +	struct phy_device *phydev = pdata->mii->phy_map[XGBE_PRTAD];
 +	int i;
 +
 +	dev_alert(dev, "\n************* PHY Reg dump **********************\n");
 +
 +	dev_alert(dev, "PCS Control Reg (%#04x) = %#04x\n", MDIO_CTRL1,
 +		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1));
 +	dev_alert(dev, "PCS Status Reg (%#04x) = %#04x\n", MDIO_STAT1,
 +		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1));
 +	dev_alert(dev, "Phy Id (PHYS ID 1 %#04x)= %#04x\n", MDIO_DEVID1,
 +		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVID1));
 +	dev_alert(dev, "Phy Id (PHYS ID 2 %#04x)= %#04x\n", MDIO_DEVID2,
 +		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVID2));
 +	dev_alert(dev, "Devices in Package (%#04x)= %#04x\n", MDIO_DEVS1,
 +		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVS1));
 +	dev_alert(dev, "Devices in Package (%#04x)= %#04x\n", MDIO_DEVS2,
 +		  XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_DEVS2));
 +
 +	dev_alert(dev, "Auto-Neg Control Reg (%#04x) = %#04x\n", MDIO_CTRL1,
 +		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_CTRL1));
 +	dev_alert(dev, "Auto-Neg Status Reg (%#04x) = %#04x\n", MDIO_STAT1,
 +		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_STAT1));
 +	dev_alert(dev, "Auto-Neg Ad Reg 1 (%#04x) = %#04x\n",
 +		  MDIO_AN_ADVERTISE,
 +		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE));
 +	dev_alert(dev, "Auto-Neg Ad Reg 2 (%#04x) = %#04x\n",
 +		  MDIO_AN_ADVERTISE + 1,
 +		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1));
 +	dev_alert(dev, "Auto-Neg Ad Reg 3 (%#04x) = %#04x\n",
 +		  MDIO_AN_ADVERTISE + 2,
 +		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2));
 +	dev_alert(dev, "Auto-Neg Completion Reg (%#04x) = %#04x\n",
 +		  MDIO_AN_COMP_STAT,
 +		  XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_COMP_STAT));
 +
 +	dev_alert(dev, "MMD Device Mask = %#x\n",
 +		  phydev->c45_ids.devices_in_package);
 +	for (i = 0; i < ARRAY_SIZE(phydev->c45_ids.device_ids); i++)
 +		dev_alert(dev, "  MMD %d: ID = %#08x\n", i,
 +			  phydev->c45_ids.device_ids[i]);
 +
 +	dev_alert(dev, "\n*************************************************\n");
 +}
 +
 +int xgbe_mdio_register(struct xgbe_prv_data *pdata)
  {
 -	if (pdata->phy.advertising & ADVERTISED_10000baseKR_Full)
 -		return SPEED_10000;
 -	else if (pdata->phy.advertising & ADVERTISED_2500baseX_Full)
 -		return SPEED_2500;
 -	else if (pdata->phy.advertising & ADVERTISED_1000baseKX_Full)
 -		return SPEED_1000;
 +	struct net_device *netdev = pdata->netdev;
 +	struct device_node *phy_node;
 +	struct mii_bus *mii;
 +	struct phy_device *phydev;
 +	int ret = 0;
  
 -	return SPEED_UNKNOWN;
 -}
 +	DBGPR("-->xgbe_mdio_register\n");
  
 -static void xgbe_phy_exit(struct xgbe_prv_data *pdata)
 -{
 -	xgbe_phy_stop(pdata);
 +	/* Retrieve the phy-handle */
 +	phy_node = of_parse_phandle(pdata->dev->of_node, "phy-handle", 0);
 +	if (!phy_node) {
 +		dev_err(pdata->dev, "unable to parse phy-handle\n");
 +		return -EINVAL;
 +	}
  
 -	pdata->phy_if.phy_impl.exit(pdata);
 -}
 +	/* Register with the MDIO bus */
 +	mii = mdiobus_alloc();
 +	if (mii == NULL) {
 +		dev_err(pdata->dev, "mdiobus_alloc failed\n");
 +		ret = -ENOMEM;
 +		goto err_node_get;
 +	}
  
 -static int xgbe_phy_init(struct xgbe_prv_data *pdata)
 -{
 -	int ret;
 +	/* Register on the MDIO bus (don't probe any PHYs) */
 +	mii->name = XGBE_PHY_NAME;
 +	mii->read = xgbe_mdio_read;
 +	mii->write = xgbe_mdio_write;
 +	snprintf(mii->id, sizeof(mii->id), "%s", pdata->mii_bus_id);
 +	mii->priv = pdata;
 +	mii->phy_mask = ~0;
 +	mii->parent = pdata->dev;
 +	ret = mdiobus_register(mii);
 +	if (ret) {
 +		dev_err(pdata->dev, "mdiobus_register failed\n");
 +		goto err_mdiobus_alloc;
 +	}
 +	DBGPR("  mdiobus_register succeeded for %s\n", pdata->mii_bus_id);
 +
 +	/* Probe the PCS using Clause 45 */
 +	phydev = get_phy_device(mii, XGBE_PRTAD, true);
 +	if (IS_ERR(phydev) || !phydev ||
 +	    !phydev->c45_ids.device_ids[MDIO_MMD_PCS]) {
 +		dev_err(pdata->dev, "get_phy_device failed\n");
 +		ret = phydev ? PTR_ERR(phydev) : -ENOLINK;
 +		goto err_mdiobus_register;
 +	}
 +	request_module(MDIO_MODULE_PREFIX MDIO_ID_FMT,
 +		       MDIO_ID_ARGS(phydev->c45_ids.device_ids[MDIO_MMD_PCS]));
 +
 +	of_node_get(phy_node);
 +	phydev->dev.of_node = phy_node;
 +	ret = phy_device_register(phydev);
 +	if (ret) {
 +		dev_err(pdata->dev, "phy_device_register failed\n");
 +		of_node_put(phy_node);
 +		goto err_phy_device;
 +	}
 +	if (!phydev->dev.driver) {
 +		dev_err(pdata->dev, "phy driver probe failed\n");
 +		ret = -EIO;
 +		goto err_phy_device;
 +	}
  
 -	mutex_init(&pdata->an_mutex);
 -	INIT_WORK(&pdata->an_irq_work, xgbe_an_irq_work);
 -	INIT_WORK(&pdata->an_work, xgbe_an_state_machine);
 -	pdata->mdio_mmd = MDIO_MMD_PCS;
 +	/* Add a reference to the PHY driver so it can't be unloaded */
 +	pdata->phy_module = phydev->dev.driver->owner;
 +	if (!try_module_get(pdata->phy_module)) {
 +		dev_err(pdata->dev, "try_module_get failed\n");
 +		ret = -EIO;
 +		goto err_phy_device;
 +	}
  
 -	/* Check for FEC support */
 -	pdata->fec_ability = XMDIO_READ(pdata, MDIO_MMD_PMAPMD,
 -					MDIO_PMA_10GBR_FECABLE);
 -	pdata->fec_ability &= (MDIO_PMA_10GBR_FECABLE_ABLE |
 -			       MDIO_PMA_10GBR_FECABLE_ERRABLE);
 +	pdata->mii = mii;
 +	pdata->mdio_mmd = MDIO_MMD_PCS;
  
 -	/* Setup the phy (including supported features) */
 -	ret = pdata->phy_if.phy_impl.init(pdata);
 -	if (ret)
 -		return ret;
 -	pdata->phy.advertising = pdata->phy.supported;
 +	pdata->phy_link = -1;
 +	pdata->phy_speed = SPEED_UNKNOWN;
 +	pdata->phy_tx_pause = pdata->tx_pause;
 +	pdata->phy_rx_pause = pdata->rx_pause;
  
 -	pdata->phy.address = 0;
 +	ret = phy_connect_direct(netdev, phydev, &xgbe_adjust_link,
 +				 pdata->phy_mode);
 +	if (ret) {
 +		netdev_err(netdev, "phy_connect_direct failed\n");
 +		goto err_phy_device;
 +	}
  
 -	if (pdata->phy.advertising & ADVERTISED_Autoneg) {
 -		pdata->phy.autoneg = AUTONEG_ENABLE;
 -		pdata->phy.speed = SPEED_UNKNOWN;
 -		pdata->phy.duplex = DUPLEX_UNKNOWN;
 -	} else {
 -		pdata->phy.autoneg = AUTONEG_DISABLE;
 -		pdata->phy.speed = xgbe_phy_best_advertised_speed(pdata);
 -		pdata->phy.duplex = DUPLEX_FULL;
 +	if (!phydev->drv || (phydev->drv->phy_id == 0)) {
 +		netdev_err(netdev, "phy_id not valid\n");
 +		ret = -ENODEV;
 +		goto err_phy_connect;
  	}
 +	DBGPR("  phy_connect_direct succeeded for PHY %s, link=%d\n",
 +	      dev_name(&phydev->dev), phydev->link);
  
 -	pdata->phy.link = 0;
 +	phydev->autoneg = pdata->default_autoneg;
 +	if (phydev->autoneg == AUTONEG_DISABLE) {
 +		phydev->speed = pdata->default_speed;
 +		phydev->duplex = DUPLEX_FULL;
  
 -	pdata->phy.pause_autoneg = pdata->pause_autoneg;
 -	pdata->phy.tx_pause = pdata->tx_pause;
 -	pdata->phy.rx_pause = pdata->rx_pause;
 +		phydev->advertising &= ~ADVERTISED_Autoneg;
 +	}
  
 -	/* Fix up Flow Control advertising */
 -	pdata->phy.advertising &= ~ADVERTISED_Pause;
 -	pdata->phy.advertising &= ~ADVERTISED_Asym_Pause;
 +	pdata->phydev = phydev;
  
 -	if (pdata->rx_pause) {
 -		pdata->phy.advertising |= ADVERTISED_Pause;
 -		pdata->phy.advertising |= ADVERTISED_Asym_Pause;
 -	}
 +	of_node_put(phy_node);
  
 -	if (pdata->tx_pause)
 -		pdata->phy.advertising ^= ADVERTISED_Asym_Pause;
 +	DBGPHY_REGS(pdata);
  
 -	if (netif_msg_drv(pdata))
 -		xgbe_dump_phy_registers(pdata);
 +	DBGPR("<--xgbe_mdio_register\n");
  
  	return 0;
 +
 +err_phy_connect:
 +	phy_disconnect(phydev);
 +
 +err_phy_device:
 +	phy_device_free(phydev);
 +
 +err_mdiobus_register:
 +	mdiobus_unregister(mii);
 +
 +err_mdiobus_alloc:
 +	mdiobus_free(mii);
 +
 +err_node_get:
 +	of_node_put(phy_node);
 +
 +	return ret;
  }
  
 -void xgbe_init_function_ptrs_phy(struct xgbe_phy_if *phy_if)
 +void xgbe_mdio_unregister(struct xgbe_prv_data *pdata)
  {
 -	phy_if->phy_init        = xgbe_phy_init;
 -	phy_if->phy_exit        = xgbe_phy_exit;
 +	DBGPR("-->xgbe_mdio_unregister\n");
 +
 +	phy_disconnect(pdata->phydev);
 +	pdata->phydev = NULL;
 +
 +	module_put(pdata->phy_module);
 +	pdata->phy_module = NULL;
  
 -	phy_if->phy_reset       = xgbe_phy_reset;
 -	phy_if->phy_start       = xgbe_phy_start;
 -	phy_if->phy_stop        = xgbe_phy_stop;
++<<<<<<< HEAD
 +	mdiobus_unregister(pdata->mii);
 +	pdata->mii->priv = NULL;
  
 -	phy_if->phy_status      = xgbe_phy_status;
 -	phy_if->phy_config_aneg = xgbe_phy_config_aneg;
 +	mdiobus_free(pdata->mii);
 +	pdata->mii = NULL;
  
 +	DBGPR("<--xgbe_mdio_unregister\n");
++=======
+ 	phy_if->phy_valid_speed = xgbe_phy_valid_speed;
+ 
+ 	phy_if->an_isr          = xgbe_an_combined_isr;
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  }
diff --cc drivers/net/ethernet/amd/xgbe/xgbe.h
index 1903f878545a,e22156e6088b..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@@ -157,10 -178,47 +157,52 @@@
  #define XGMAC_MAX_STD_PACKET	1518
  #define XGMAC_JUMBO_PACKET_MTU	9000
  #define XGMAC_MAX_JUMBO_PACKET	9018
 -#define XGMAC_ETH_PREAMBLE	(12 + 8)	/* Inter-frame gap + preamble */
  
++<<<<<<< HEAD
 +/* MDIO bus phy name */
 +#define XGBE_PHY_NAME		"amd_xgbe_phy"
 +#define XGBE_PRTAD		0
++=======
+ #define XGMAC_PFC_DATA_LEN	46
+ #define XGMAC_PFC_DELAYS	14000
+ 
+ #define XGMAC_PRIO_QUEUES(_cnt)					\
+ 	min_t(unsigned int, IEEE_8021QAZ_MAX_TCS, (_cnt))
+ 
+ /* Common property names */
+ #define XGBE_MAC_ADDR_PROPERTY	"mac-address"
+ #define XGBE_PHY_MODE_PROPERTY	"phy-mode"
+ #define XGBE_DMA_IRQS_PROPERTY	"amd,per-channel-interrupt"
+ #define XGBE_SPEEDSET_PROPERTY	"amd,speed-set"
+ 
+ /* Device-tree clock names */
+ #define XGBE_DMA_CLOCK		"dma_clk"
+ #define XGBE_PTP_CLOCK		"ptp_clk"
+ 
+ /* ACPI property names */
+ #define XGBE_ACPI_DMA_FREQ	"amd,dma-freq"
+ #define XGBE_ACPI_PTP_FREQ	"amd,ptp-freq"
+ 
+ /* PCI BAR mapping */
+ #define XGBE_XGMAC_BAR		0
+ #define XGBE_XPCS_BAR		1
+ #define XGBE_MAC_PROP_OFFSET	0x1d000
+ #define XGBE_I2C_CTRL_OFFSET	0x1e000
+ 
+ /* PCI MSIx support */
+ #define XGBE_MSIX_BASE_COUNT	4
+ #define XGBE_MSIX_MIN_COUNT	(XGBE_MSIX_BASE_COUNT + 1)
+ 
+ /* PCI clock frequencies */
+ #define XGBE_V2_DMA_CLOCK_FREQ	500000000	/* 500 MHz */
+ #define XGBE_V2_PTP_CLOCK_FREQ	125000000	/* 125 MHz */
+ 
+ /* Timestamp support - values based on 50MHz PTP clock
+  *   50MHz => 20 nsec
+  */
+ #define XGBE_TSTAMP_SSINC	20
+ #define XGBE_TSTAMP_SNSINC	0
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  
  /* Driver PMT macros */
  #define XGMAC_DRIVER_CONTEXT	1
@@@ -461,6 -671,92 +503,95 @@@ struct xgbe_hw_if 
  	void (*rx_mmc_int)(struct xgbe_prv_data *);
  	void (*tx_mmc_int)(struct xgbe_prv_data *);
  	void (*read_mmc_stats)(struct xgbe_prv_data *);
++<<<<<<< HEAD
++=======
+ 
+ 	/* For Timestamp config */
+ 	int (*config_tstamp)(struct xgbe_prv_data *, unsigned int);
+ 	void (*update_tstamp_addend)(struct xgbe_prv_data *, unsigned int);
+ 	void (*set_tstamp_time)(struct xgbe_prv_data *, unsigned int sec,
+ 				unsigned int nsec);
+ 	u64 (*get_tstamp_time)(struct xgbe_prv_data *);
+ 	u64 (*get_tx_tstamp)(struct xgbe_prv_data *);
+ 
+ 	/* For Data Center Bridging config */
+ 	void (*config_tc)(struct xgbe_prv_data *);
+ 	void (*config_dcb_tc)(struct xgbe_prv_data *);
+ 	void (*config_dcb_pfc)(struct xgbe_prv_data *);
+ 
+ 	/* For Receive Side Scaling */
+ 	int (*enable_rss)(struct xgbe_prv_data *);
+ 	int (*disable_rss)(struct xgbe_prv_data *);
+ 	int (*set_rss_hash_key)(struct xgbe_prv_data *, const u8 *);
+ 	int (*set_rss_lookup_table)(struct xgbe_prv_data *, const u32 *);
+ };
+ 
+ /* This structure represents implementation specific routines for an
+  * implementation of a PHY. All routines are required unless noted below.
+  *   Optional routines:
+  *     kr_training_pre, kr_training_post
+  */
+ struct xgbe_phy_impl_if {
+ 	/* Perform Setup/teardown actions */
+ 	int (*init)(struct xgbe_prv_data *);
+ 	void (*exit)(struct xgbe_prv_data *);
+ 
+ 	/* Perform start/stop specific actions */
+ 	int (*reset)(struct xgbe_prv_data *);
+ 	int (*start)(struct xgbe_prv_data *);
+ 	void (*stop)(struct xgbe_prv_data *);
+ 
+ 	/* Return the link status */
+ 	int (*link_status)(struct xgbe_prv_data *);
+ 
+ 	/* Indicate if a particular speed is valid */
+ 	bool (*valid_speed)(struct xgbe_prv_data *, int);
+ 
+ 	/* Check if the specified mode can/should be used */
+ 	bool (*use_mode)(struct xgbe_prv_data *, enum xgbe_mode);
+ 	/* Switch the PHY into various modes */
+ 	void (*set_mode)(struct xgbe_prv_data *, enum xgbe_mode);
+ 	/* Retrieve mode needed for a specific speed */
+ 	enum xgbe_mode (*get_mode)(struct xgbe_prv_data *, int);
+ 	/* Retrieve new/next mode when trying to auto-negotiate */
+ 	enum xgbe_mode (*switch_mode)(struct xgbe_prv_data *);
+ 	/* Retrieve current mode */
+ 	enum xgbe_mode (*cur_mode)(struct xgbe_prv_data *);
+ 
+ 	/* Retrieve current auto-negotiation mode */
+ 	enum xgbe_an_mode (*an_mode)(struct xgbe_prv_data *);
+ 
+ 	/* Process results of auto-negotiation */
+ 	enum xgbe_mode (*an_outcome)(struct xgbe_prv_data *);
+ 
+ 	/* Pre/Post KR training enablement support */
+ 	void (*kr_training_pre)(struct xgbe_prv_data *);
+ 	void (*kr_training_post)(struct xgbe_prv_data *);
+ };
+ 
+ struct xgbe_phy_if {
+ 	/* For PHY setup/teardown */
+ 	int (*phy_init)(struct xgbe_prv_data *);
+ 	void (*phy_exit)(struct xgbe_prv_data *);
+ 
+ 	/* For PHY support when setting device up/down */
+ 	int (*phy_reset)(struct xgbe_prv_data *);
+ 	int (*phy_start)(struct xgbe_prv_data *);
+ 	void (*phy_stop)(struct xgbe_prv_data *);
+ 
+ 	/* For PHY support while device is up */
+ 	void (*phy_status)(struct xgbe_prv_data *);
+ 	int (*phy_config_aneg)(struct xgbe_prv_data *);
+ 
+ 	/* For PHY settings validation */
+ 	bool (*phy_valid_speed)(struct xgbe_prv_data *, int);
+ 
+ 	/* For single interrupt support */
+ 	irqreturn_t (*an_isr)(int, struct xgbe_prv_data *);
+ 
+ 	/* PHY implementation specific services */
+ 	struct xgbe_phy_impl_if phy_impl;
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  };
  
  struct xgbe_desc_if {
@@@ -514,24 -816,67 +645,57 @@@ struct xgbe_hw_features 
  	unsigned int aux_snap_num;	/* Number of Aux snapshot inputs */
  };
  
 -struct xgbe_version_data {
 -	void (*init_function_ptrs_phy_impl)(struct xgbe_phy_if *);
 -	enum xgbe_xpcs_access xpcs_access;
 -	unsigned int mmc_64bit;
 -	unsigned int tx_max_fifo_size;
 -	unsigned int rx_max_fifo_size;
 -	unsigned int tx_tstamp_workaround;
 -};
 -
  struct xgbe_prv_data {
  	struct net_device *netdev;
++<<<<<<< HEAD
 +	struct platform_device *pdev;
++=======
+ 	struct pci_dev *pcidev;
+ 	struct platform_device *platdev;
+ 	struct acpi_device *adev;
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  	struct device *dev;
 -	struct platform_device *phy_platdev;
 -	struct device *phy_dev;
 -
 -	/* Version related data */
 -	struct xgbe_version_data *vdata;
 -
 -	/* ACPI or DT flag */
 -	unsigned int use_acpi;
  
  	/* XGMAC/XPCS related mmio registers */
  	void __iomem *xgmac_regs;	/* XGMAC CSRs */
  	void __iomem *xpcs_regs;	/* XPCS MMD registers */
++<<<<<<< HEAD
++=======
+ 	void __iomem *rxtx_regs;	/* SerDes Rx/Tx CSRs */
+ 	void __iomem *sir0_regs;	/* SerDes integration registers (1/2) */
+ 	void __iomem *sir1_regs;	/* SerDes integration registers (2/2) */
+ 	void __iomem *xprop_regs;	/* XGBE property registers */
+ 	void __iomem *xi2c_regs;	/* XGBE I2C CSRs */
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  
  	/* Overall device lock */
  	spinlock_t lock;
  
 -	/* XPCS indirect addressing lock */
 -	spinlock_t xpcs_lock;
 -	unsigned int xpcs_window;
 -	unsigned int xpcs_window_size;
 -	unsigned int xpcs_window_mask;
 +	/* XPCS indirect addressing mutex */
 +	struct mutex xpcs_mutex;
  
++<<<<<<< HEAD
 +	int irq_number;
++=======
+ 	/* RSS addressing mutex */
+ 	struct mutex rss_mutex;
+ 
+ 	/* Flags representing xgbe_state */
+ 	unsigned long dev_state;
+ 
+ 	struct msix_entry *msix_entries;
+ 	int dev_irq;
+ 	int ecc_irq;
+ 	int i2c_irq;
+ 	int channel_irq[XGBE_MAX_DMA_CHANNELS];
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
+ 
+ 	unsigned int per_channel_irq;
+ 	unsigned int irq_shared;
+ 	unsigned int irq_count;
+ 	unsigned int channel_irq_count;
  
  	struct xgbe_hw_if hw_if;
 -	struct xgbe_phy_if phy_if;
  	struct xgbe_desc_if desc_if;
  
  	/* AXI DMA settings */
@@@ -622,18 -1042,39 +788,41 @@@
  };
  
  /* Function prototypes*/
++<<<<<<< HEAD
++
++void xgbe_init_function_ptrs_dev(struct xgbe_hw_if *);
++=======
+ struct xgbe_prv_data *xgbe_alloc_pdata(struct device *);
+ void xgbe_free_pdata(struct xgbe_prv_data *);
+ void xgbe_set_counts(struct xgbe_prv_data *);
+ int xgbe_config_netdev(struct xgbe_prv_data *);
+ void xgbe_deconfig_netdev(struct xgbe_prv_data *);
+ 
+ int xgbe_platform_init(void);
+ void xgbe_platform_exit(void);
+ #ifdef CONFIG_PCI
+ int xgbe_pci_init(void);
+ void xgbe_pci_exit(void);
+ #else
+ static inline int xgbe_pci_init(void) { return 0; }
+ static inline void xgbe_pci_exit(void) { }
+ #endif
  
  void xgbe_init_function_ptrs_dev(struct xgbe_hw_if *);
+ void xgbe_init_function_ptrs_phy(struct xgbe_phy_if *);
+ void xgbe_init_function_ptrs_phy_v1(struct xgbe_phy_if *);
+ void xgbe_init_function_ptrs_phy_v2(struct xgbe_phy_if *);
++>>>>>>> 47f164deab22 (amd-xgbe: Add PCI device support)
  void xgbe_init_function_ptrs_desc(struct xgbe_desc_if *);
 -const struct net_device_ops *xgbe_get_netdev_ops(void);
 -const struct ethtool_ops *xgbe_get_ethtool_ops(void);
 -
 -#ifdef CONFIG_AMD_XGBE_DCB
 -const struct dcbnl_rtnl_ops *xgbe_get_dcbnl_ops(void);
 -#endif
 +struct net_device_ops *xgbe_get_netdev_ops(void);
 +struct ethtool_ops *xgbe_get_ethtool_ops(void);
  
 -void xgbe_ptp_register(struct xgbe_prv_data *);
 -void xgbe_ptp_unregister(struct xgbe_prv_data *);
 -void xgbe_dump_tx_desc(struct xgbe_prv_data *, struct xgbe_ring *,
 -		       unsigned int, unsigned int, unsigned int);
 -void xgbe_dump_rx_desc(struct xgbe_prv_data *, struct xgbe_ring *,
 +int xgbe_mdio_register(struct xgbe_prv_data *);
 +void xgbe_mdio_unregister(struct xgbe_prv_data *);
 +void xgbe_dump_phy_registers(struct xgbe_prv_data *);
 +void xgbe_dump_tx_desc(struct xgbe_ring *, unsigned int, unsigned int,
 +		       unsigned int);
 +void xgbe_dump_rx_desc(struct xgbe_ring *, struct xgbe_ring_desc *,
  		       unsigned int);
  void xgbe_print_pkt(struct net_device *, struct sk_buff *, bool);
  void xgbe_get_all_hw_features(struct xgbe_prv_data *);
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-platform.c
* Unmerged path drivers/net/ethernet/amd/Kconfig
* Unmerged path drivers/net/ethernet/amd/xgbe/Makefile
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-common.h
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c b/drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c
index 5d2904a2cee6..f1f3d44ea81a 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c
@@ -317,6 +317,66 @@ static const struct file_operations xpcs_reg_value_fops = {
 	.write = xpcs_reg_value_write,
 };
 
+static ssize_t xprop_reg_addr_read(struct file *filp, char __user *buffer,
+				   size_t count, loff_t *ppos)
+{
+	struct xgbe_prv_data *pdata = filp->private_data;
+
+	return xgbe_common_read(buffer, count, ppos, pdata->debugfs_xprop_reg);
+}
+
+static ssize_t xprop_reg_addr_write(struct file *filp,
+				    const char __user *buffer,
+				    size_t count, loff_t *ppos)
+{
+	struct xgbe_prv_data *pdata = filp->private_data;
+
+	return xgbe_common_write(buffer, count, ppos,
+				 &pdata->debugfs_xprop_reg);
+}
+
+static ssize_t xprop_reg_value_read(struct file *filp, char __user *buffer,
+				    size_t count, loff_t *ppos)
+{
+	struct xgbe_prv_data *pdata = filp->private_data;
+	unsigned int value;
+
+	value = XP_IOREAD(pdata, pdata->debugfs_xprop_reg);
+
+	return xgbe_common_read(buffer, count, ppos, value);
+}
+
+static ssize_t xprop_reg_value_write(struct file *filp,
+				     const char __user *buffer,
+				     size_t count, loff_t *ppos)
+{
+	struct xgbe_prv_data *pdata = filp->private_data;
+	unsigned int value;
+	ssize_t len;
+
+	len = xgbe_common_write(buffer, count, ppos, &value);
+	if (len < 0)
+		return len;
+
+	XP_IOWRITE(pdata, pdata->debugfs_xprop_reg, value);
+
+	return len;
+}
+
+static const struct file_operations xprop_reg_addr_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read =  xprop_reg_addr_read,
+	.write = xprop_reg_addr_write,
+};
+
+static const struct file_operations xprop_reg_value_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read =  xprop_reg_value_read,
+	.write = xprop_reg_value_write,
+};
+
 void xgbe_debugfs_init(struct xgbe_prv_data *pdata)
 {
 	struct dentry *pfile;
@@ -368,6 +428,22 @@ void xgbe_debugfs_init(struct xgbe_prv_data *pdata)
 	if (!pfile)
 		netdev_err(pdata->netdev, "debugfs_create_file failed\n");
 
+	if (pdata->xprop_regs) {
+		pfile = debugfs_create_file("xprop_register", 0600,
+					    pdata->xgbe_debugfs, pdata,
+					    &xprop_reg_addr_fops);
+		if (!pfile)
+			netdev_err(pdata->netdev,
+				   "debugfs_create_file failed\n");
+
+		pfile = debugfs_create_file("xprop_register_value", 0600,
+					    pdata->xgbe_debugfs, pdata,
+					    &xprop_reg_value_fops);
+		if (!pfile)
+			netdev_err(pdata->netdev,
+				   "debugfs_create_file failed\n");
+	}
+
 	kfree(buf);
 }
 
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-drv.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-main.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-mdio.c
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-pci.c b/drivers/net/ethernet/amd/xgbe/xgbe-pci.c
new file mode 100644
index 000000000000..fe77945bc49e
--- /dev/null
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-pci.c
@@ -0,0 +1,523 @@
+/*
+ * AMD 10Gb Ethernet driver
+ *
+ * This file is available to you under your choice of the following two
+ * licenses:
+ *
+ * License 1: GPLv2
+ *
+ * Copyright (c) 2016 Advanced Micro Devices, Inc.
+ *
+ * This file is free software; you may copy, redistribute and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+ *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+ *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+ *     and you.
+ *
+ *     The Software IS NOT an item of Licensed Software or Licensed Product
+ *     under any End User Software License Agreement or Agreement for Licensed
+ *     Product with Synopsys or any supplement thereto.  Permission is hereby
+ *     granted, free of charge, to any person obtaining a copy of this software
+ *     annotated with this license and the Software, to deal in the Software
+ *     without restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+ *     of the Software, and to permit persons to whom the Software is furnished
+ *     to do so, subject to the following conditions:
+ *
+ *     The above copyright notice and this permission notice shall be included
+ *     in all copies or substantial portions of the Software.
+ *
+ *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+ *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+ *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *     THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * License 2: Modified BSD
+ *
+ * Copyright (c) 2016 Advanced Micro Devices, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Advanced Micro Devices, Inc. nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+ *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+ *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+ *     and you.
+ *
+ *     The Software IS NOT an item of Licensed Software or Licensed Product
+ *     under any End User Software License Agreement or Agreement for Licensed
+ *     Product with Synopsys or any supplement thereto.  Permission is hereby
+ *     granted, free of charge, to any person obtaining a copy of this software
+ *     annotated with this license and the Software, to deal in the Software
+ *     without restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+ *     of the Software, and to permit persons to whom the Software is furnished
+ *     to do so, subject to the following conditions:
+ *
+ *     The above copyright notice and this permission notice shall be included
+ *     in all copies or substantial portions of the Software.
+ *
+ *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+ *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+ *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *     THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/pci.h>
+#include <linux/log2.h>
+
+#include "xgbe.h"
+#include "xgbe-common.h"
+
+static int xgbe_config_msi(struct xgbe_prv_data *pdata)
+{
+	unsigned int msi_count;
+	unsigned int i, j;
+	int ret;
+
+	msi_count = XGBE_MSIX_BASE_COUNT;
+	msi_count += max(pdata->rx_ring_count,
+			 pdata->tx_ring_count);
+	msi_count = roundup_pow_of_two(msi_count);
+
+	ret = pci_enable_msi_exact(pdata->pcidev, msi_count);
+	if (ret < 0) {
+		dev_info(pdata->dev, "MSI request for %u interrupts failed\n",
+			 msi_count);
+
+		ret = pci_enable_msi(pdata->pcidev);
+		if (ret < 0) {
+			dev_info(pdata->dev, "MSI enablement failed\n");
+			return ret;
+		}
+
+		msi_count = 1;
+	}
+
+	pdata->irq_count = msi_count;
+
+	pdata->dev_irq = pdata->pcidev->irq;
+
+	if (msi_count > 1) {
+		pdata->ecc_irq = pdata->pcidev->irq + 1;
+		pdata->i2c_irq = pdata->pcidev->irq + 2;
+		pdata->an_irq = pdata->pcidev->irq + 3;
+
+		for (i = XGBE_MSIX_BASE_COUNT, j = 0;
+		     (i < msi_count) && (j < XGBE_MAX_DMA_CHANNELS);
+		     i++, j++)
+			pdata->channel_irq[j] = pdata->pcidev->irq + i;
+		pdata->channel_irq_count = j;
+
+		pdata->per_channel_irq = 1;
+	} else {
+		pdata->ecc_irq = pdata->pcidev->irq;
+		pdata->i2c_irq = pdata->pcidev->irq;
+		pdata->an_irq = pdata->pcidev->irq;
+	}
+
+	if (netif_msg_probe(pdata))
+		dev_dbg(pdata->dev, "MSI interrupts enabled\n");
+
+	return 0;
+}
+
+static int xgbe_config_msix(struct xgbe_prv_data *pdata)
+{
+	unsigned int msix_count;
+	unsigned int i, j;
+	int ret;
+
+	msix_count = XGBE_MSIX_BASE_COUNT;
+	msix_count += max(pdata->rx_ring_count,
+			  pdata->tx_ring_count);
+
+	pdata->msix_entries = devm_kcalloc(pdata->dev, msix_count,
+					   sizeof(struct msix_entry),
+					   GFP_KERNEL);
+	if (!pdata->msix_entries)
+		return -ENOMEM;
+
+	for (i = 0; i < msix_count; i++)
+		pdata->msix_entries[i].entry = i;
+
+	ret = pci_enable_msix_range(pdata->pcidev, pdata->msix_entries,
+				    XGBE_MSIX_MIN_COUNT, msix_count);
+	if (ret < 0) {
+		dev_info(pdata->dev, "MSI-X enablement failed\n");
+		devm_kfree(pdata->dev, pdata->msix_entries);
+		pdata->msix_entries = NULL;
+		return ret;
+	}
+
+	pdata->irq_count = ret;
+
+	pdata->dev_irq = pdata->msix_entries[0].vector;
+	pdata->ecc_irq = pdata->msix_entries[1].vector;
+	pdata->i2c_irq = pdata->msix_entries[2].vector;
+	pdata->an_irq = pdata->msix_entries[3].vector;
+
+	for (i = XGBE_MSIX_BASE_COUNT, j = 0; i < ret; i++, j++)
+		pdata->channel_irq[j] = pdata->msix_entries[i].vector;
+	pdata->channel_irq_count = j;
+
+	pdata->per_channel_irq = 1;
+
+	if (netif_msg_probe(pdata))
+		dev_dbg(pdata->dev, "MSI-X interrupts enabled\n");
+
+	return 0;
+}
+
+static int xgbe_config_irqs(struct xgbe_prv_data *pdata)
+{
+	int ret;
+
+	ret = xgbe_config_msix(pdata);
+	if (!ret)
+		goto out;
+
+	ret = xgbe_config_msi(pdata);
+	if (!ret)
+		goto out;
+
+	pdata->irq_count = 1;
+	pdata->irq_shared = 1;
+
+	pdata->dev_irq = pdata->pcidev->irq;
+	pdata->ecc_irq = pdata->pcidev->irq;
+	pdata->i2c_irq = pdata->pcidev->irq;
+	pdata->an_irq = pdata->pcidev->irq;
+
+out:
+	if (netif_msg_probe(pdata)) {
+		unsigned int i;
+
+		dev_dbg(pdata->dev, " dev irq=%d\n", pdata->dev_irq);
+		dev_dbg(pdata->dev, " ecc irq=%d\n", pdata->ecc_irq);
+		dev_dbg(pdata->dev, " i2c irq=%d\n", pdata->i2c_irq);
+		dev_dbg(pdata->dev, "  an irq=%d\n", pdata->an_irq);
+		for (i = 0; i < pdata->channel_irq_count; i++)
+			dev_dbg(pdata->dev, " dma%u irq=%d\n",
+				i, pdata->channel_irq[i]);
+	}
+
+	return 0;
+}
+
+static int xgbe_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	struct xgbe_prv_data *pdata;
+	struct device *dev = &pdev->dev;
+	void __iomem * const *iomap_table;
+	unsigned int ma_lo, ma_hi;
+	unsigned int reg;
+	int bar_mask;
+	int ret;
+
+	pdata = xgbe_alloc_pdata(dev);
+	if (IS_ERR(pdata)) {
+		ret = PTR_ERR(pdata);
+		goto err_alloc;
+	}
+
+	pdata->pcidev = pdev;
+	pci_set_drvdata(pdev, pdata);
+
+	/* Get the version data */
+	pdata->vdata = (struct xgbe_version_data *)id->driver_data;
+
+	ret = pcim_enable_device(pdev);
+	if (ret) {
+		dev_err(dev, "pcim_enable_device failed\n");
+		goto err_pci_enable;
+	}
+
+	/* Obtain the mmio areas for the device */
+	bar_mask = pci_select_bars(pdev, IORESOURCE_MEM);
+	ret = pcim_iomap_regions(pdev, bar_mask, XGBE_DRV_NAME);
+	if (ret) {
+		dev_err(dev, "pcim_iomap_regions failed\n");
+		goto err_pci_enable;
+	}
+
+	iomap_table = pcim_iomap_table(pdev);
+	if (!iomap_table) {
+		dev_err(dev, "pcim_iomap_table failed\n");
+		ret = -ENOMEM;
+		goto err_pci_enable;
+	}
+
+	pdata->xgmac_regs = iomap_table[XGBE_XGMAC_BAR];
+	if (!pdata->xgmac_regs) {
+		dev_err(dev, "xgmac ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_pci_enable;
+	}
+	pdata->xprop_regs = pdata->xgmac_regs + XGBE_MAC_PROP_OFFSET;
+	pdata->xi2c_regs = pdata->xgmac_regs + XGBE_I2C_CTRL_OFFSET;
+	if (netif_msg_probe(pdata)) {
+		dev_dbg(dev, "xgmac_regs = %p\n", pdata->xgmac_regs);
+		dev_dbg(dev, "xprop_regs = %p\n", pdata->xprop_regs);
+		dev_dbg(dev, "xi2c_regs  = %p\n", pdata->xi2c_regs);
+	}
+
+	pdata->xpcs_regs = iomap_table[XGBE_XPCS_BAR];
+	if (!pdata->xpcs_regs) {
+		dev_err(dev, "xpcs ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_pci_enable;
+	}
+	if (netif_msg_probe(pdata))
+		dev_dbg(dev, "xpcs_regs  = %p\n", pdata->xpcs_regs);
+
+	/* Configure the PCS indirect addressing support */
+	reg = XPCS32_IOREAD(pdata, PCS_V2_WINDOW_DEF);
+	pdata->xpcs_window = XPCS_GET_BITS(reg, PCS_V2_WINDOW_DEF, OFFSET);
+	pdata->xpcs_window <<= 6;
+	pdata->xpcs_window_size = XPCS_GET_BITS(reg, PCS_V2_WINDOW_DEF, SIZE);
+	pdata->xpcs_window_size = 1 << (pdata->xpcs_window_size + 7);
+	pdata->xpcs_window_mask = pdata->xpcs_window_size - 1;
+	if (netif_msg_probe(pdata)) {
+		dev_dbg(dev, "xpcs window      = %#010x\n",
+			pdata->xpcs_window);
+		dev_dbg(dev, "xpcs window size = %#010x\n",
+			pdata->xpcs_window_size);
+		dev_dbg(dev, "xpcs window mask = %#010x\n",
+			pdata->xpcs_window_mask);
+	}
+
+	pci_set_master(pdev);
+
+	/* Enable all interrupts in the hardware */
+	XP_IOWRITE(pdata, XP_INT_EN, 0x1fffff);
+
+	/* Retrieve the MAC address */
+	ma_lo = XP_IOREAD(pdata, XP_MAC_ADDR_LO);
+	ma_hi = XP_IOREAD(pdata, XP_MAC_ADDR_HI);
+	pdata->mac_addr[0] = ma_lo & 0xff;
+	pdata->mac_addr[1] = (ma_lo >> 8) & 0xff;
+	pdata->mac_addr[2] = (ma_lo >> 16) & 0xff;
+	pdata->mac_addr[3] = (ma_lo >> 24) & 0xff;
+	pdata->mac_addr[4] = ma_hi & 0xff;
+	pdata->mac_addr[5] = (ma_hi >> 8) & 0xff;
+	if (!XP_GET_BITS(ma_hi, XP_MAC_ADDR_HI, VALID) ||
+	    !is_valid_ether_addr(pdata->mac_addr)) {
+		dev_err(dev, "invalid mac address\n");
+		ret = -EINVAL;
+		goto err_pci_enable;
+	}
+
+	/* Clock settings */
+	pdata->sysclk_rate = XGBE_V2_DMA_CLOCK_FREQ;
+	pdata->ptpclk_rate = XGBE_V2_PTP_CLOCK_FREQ;
+
+	/* Set the DMA coherency values */
+	pdata->coherent = 1;
+	pdata->axdomain = XGBE_DMA_OS_AXDOMAIN;
+	pdata->arcache = XGBE_DMA_OS_ARCACHE;
+	pdata->awcache = XGBE_DMA_OS_AWCACHE;
+
+	/* Set the maximum channels and queues */
+	reg = XP_IOREAD(pdata, XP_PROP_1);
+	pdata->tx_max_channel_count = XP_GET_BITS(reg, XP_PROP_1, MAX_TX_DMA);
+	pdata->rx_max_channel_count = XP_GET_BITS(reg, XP_PROP_1, MAX_RX_DMA);
+	pdata->tx_max_q_count = XP_GET_BITS(reg, XP_PROP_1, MAX_TX_QUEUES);
+	pdata->rx_max_q_count = XP_GET_BITS(reg, XP_PROP_1, MAX_RX_QUEUES);
+	if (netif_msg_probe(pdata)) {
+		dev_dbg(dev, "max tx/rx channel count = %u/%u\n",
+			pdata->tx_max_channel_count,
+			pdata->tx_max_channel_count);
+		dev_dbg(dev, "max tx/rx hw queue count = %u/%u\n",
+			pdata->tx_max_q_count, pdata->rx_max_q_count);
+	}
+
+	/* Set the hardware channel and queue counts */
+	xgbe_set_counts(pdata);
+
+	/* Set the maximum fifo amounts */
+	reg = XP_IOREAD(pdata, XP_PROP_2);
+	pdata->tx_max_fifo_size = XP_GET_BITS(reg, XP_PROP_2, TX_FIFO_SIZE);
+	pdata->tx_max_fifo_size *= 16384;
+	pdata->tx_max_fifo_size = min(pdata->tx_max_fifo_size,
+				      pdata->vdata->tx_max_fifo_size);
+	pdata->rx_max_fifo_size = XP_GET_BITS(reg, XP_PROP_2, RX_FIFO_SIZE);
+	pdata->rx_max_fifo_size *= 16384;
+	pdata->rx_max_fifo_size = min(pdata->rx_max_fifo_size,
+				      pdata->vdata->rx_max_fifo_size);
+	if (netif_msg_probe(pdata))
+		dev_dbg(dev, "max tx/rx max fifo size = %u/%u\n",
+			pdata->tx_max_fifo_size, pdata->rx_max_fifo_size);
+
+	/* Configure interrupt support */
+	ret = xgbe_config_irqs(pdata);
+	if (ret)
+		goto err_pci_enable;
+
+	/* Configure the netdev resource */
+	ret = xgbe_config_netdev(pdata);
+	if (ret)
+		goto err_pci_enable;
+
+	netdev_notice(pdata->netdev, "net device enabled\n");
+
+	return 0;
+
+err_pci_enable:
+	xgbe_free_pdata(pdata);
+
+err_alloc:
+	dev_notice(dev, "net device not enabled\n");
+
+	return ret;
+}
+
+static void xgbe_pci_remove(struct pci_dev *pdev)
+{
+	struct xgbe_prv_data *pdata = pci_get_drvdata(pdev);
+
+	xgbe_deconfig_netdev(pdata);
+
+	xgbe_free_pdata(pdata);
+}
+
+#ifdef CONFIG_PM
+static int xgbe_pci_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	struct xgbe_prv_data *pdata = pci_get_drvdata(pdev);
+	struct net_device *netdev = pdata->netdev;
+	int ret = 0;
+
+	if (netif_running(netdev))
+		ret = xgbe_powerdown(netdev, XGMAC_DRIVER_CONTEXT);
+
+	pdata->lpm_ctrl = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);
+	pdata->lpm_ctrl |= MDIO_CTRL1_LPOWER;
+	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, pdata->lpm_ctrl);
+
+	return ret;
+}
+
+static int xgbe_pci_resume(struct pci_dev *pdev)
+{
+	struct xgbe_prv_data *pdata = pci_get_drvdata(pdev);
+	struct net_device *netdev = pdata->netdev;
+	int ret = 0;
+
+	pdata->lpm_ctrl &= ~MDIO_CTRL1_LPOWER;
+	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, pdata->lpm_ctrl);
+
+	if (netif_running(netdev)) {
+		ret = xgbe_powerup(netdev, XGMAC_DRIVER_CONTEXT);
+
+		/* Schedule a restart in case the link or phy state changed
+		 * while we were powered down.
+		 */
+		schedule_work(&pdata->restart_work);
+	}
+
+	return ret;
+}
+#endif /* CONFIG_PM */
+
+static const struct xgbe_version_data xgbe_v2a = {
+	.init_function_ptrs_phy_impl	= xgbe_init_function_ptrs_phy_v2,
+	.xpcs_access			= XGBE_XPCS_ACCESS_V2,
+	.mmc_64bit			= 1,
+	.tx_max_fifo_size		= 229376,
+	.rx_max_fifo_size		= 229376,
+	.tx_tstamp_workaround		= 1,
+};
+
+static const struct xgbe_version_data xgbe_v2b = {
+	.init_function_ptrs_phy_impl	= xgbe_init_function_ptrs_phy_v2,
+	.xpcs_access			= XGBE_XPCS_ACCESS_V2,
+	.mmc_64bit			= 1,
+	.tx_max_fifo_size		= 65536,
+	.rx_max_fifo_size		= 65536,
+	.tx_tstamp_workaround		= 1,
+};
+
+static const struct pci_device_id xgbe_pci_table[] = {
+	{ PCI_VDEVICE(AMD, 0x1458),
+	  .driver_data = (kernel_ulong_t)&xgbe_v2a },
+	{ PCI_VDEVICE(AMD, 0x1459),
+	  .driver_data = (kernel_ulong_t)&xgbe_v2b },
+	/* Last entry must be zero */
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, xgbe_pci_table);
+
+static struct pci_driver xgbe_driver = {
+	.name = XGBE_DRV_NAME,
+	.id_table = xgbe_pci_table,
+	.probe = xgbe_pci_probe,
+	.remove = xgbe_pci_remove,
+#ifdef CONFIG_PM
+	.suspend = xgbe_pci_suspend,
+	.resume = xgbe_pci_resume,
+#endif
+};
+
+int xgbe_pci_init(void)
+{
+	return pci_register_driver(&xgbe_driver);
+}
+
+void xgbe_pci_exit(void)
+{
+	pci_unregister_driver(&xgbe_driver);
+}
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c b/drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
new file mode 100644
index 000000000000..7ae0abcd1bd5
--- /dev/null
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
@@ -0,0 +1,854 @@
+/*
+ * AMD 10Gb Ethernet driver
+ *
+ * This file is available to you under your choice of the following two
+ * licenses:
+ *
+ * License 1: GPLv2
+ *
+ * Copyright (c) 2016 Advanced Micro Devices, Inc.
+ *
+ * This file is free software; you may copy, redistribute and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+ *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+ *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+ *     and you.
+ *
+ *     The Software IS NOT an item of Licensed Software or Licensed Product
+ *     under any End User Software License Agreement or Agreement for Licensed
+ *     Product with Synopsys or any supplement thereto.  Permission is hereby
+ *     granted, free of charge, to any person obtaining a copy of this software
+ *     annotated with this license and the Software, to deal in the Software
+ *     without restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+ *     of the Software, and to permit persons to whom the Software is furnished
+ *     to do so, subject to the following conditions:
+ *
+ *     The above copyright notice and this permission notice shall be included
+ *     in all copies or substantial portions of the Software.
+ *
+ *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+ *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+ *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *     THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * License 2: Modified BSD
+ *
+ * Copyright (c) 2016 Advanced Micro Devices, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Advanced Micro Devices, Inc. nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+ *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+ *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+ *     and you.
+ *
+ *     The Software IS NOT an item of Licensed Software or Licensed Product
+ *     under any End User Software License Agreement or Agreement for Licensed
+ *     Product with Synopsys or any supplement thereto.  Permission is hereby
+ *     granted, free of charge, to any person obtaining a copy of this software
+ *     annotated with this license and the Software, to deal in the Software
+ *     without restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+ *     of the Software, and to permit persons to whom the Software is furnished
+ *     to do so, subject to the following conditions:
+ *
+ *     The above copyright notice and this permission notice shall be included
+ *     in all copies or substantial portions of the Software.
+ *
+ *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+ *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+ *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *     THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/mdio.h>
+#include <linux/phy.h>
+
+#include "xgbe.h"
+#include "xgbe-common.h"
+
+#define XGBE_PHY_PORT_SPEED_100		BIT(0)
+#define XGBE_PHY_PORT_SPEED_1000	BIT(1)
+#define XGBE_PHY_PORT_SPEED_2500	BIT(2)
+#define XGBE_PHY_PORT_SPEED_10000	BIT(3)
+
+/* Rate-change complete wait/retry count */
+#define XGBE_RATECHANGE_COUNT		500
+
+enum xgbe_port_mode {
+	XGBE_PORT_MODE_RSVD = 0,
+	XGBE_PORT_MODE_BACKPLANE,
+	XGBE_PORT_MODE_BACKPLANE_2500,
+	XGBE_PORT_MODE_1000BASE_T,
+	XGBE_PORT_MODE_1000BASE_X,
+	XGBE_PORT_MODE_NBASE_T,
+	XGBE_PORT_MODE_10GBASE_T,
+	XGBE_PORT_MODE_10GBASE_R,
+	XGBE_PORT_MODE_SFP,
+	XGBE_PORT_MODE_MAX,
+};
+
+enum xgbe_conn_type {
+	XGBE_CONN_TYPE_NONE = 0,
+	XGBE_CONN_TYPE_SFP,
+	XGBE_CONN_TYPE_MDIO,
+	XGBE_CONN_TYPE_BACKPLANE,
+	XGBE_CONN_TYPE_MAX,
+};
+
+/* PHY related configuration information */
+struct xgbe_phy_data {
+	enum xgbe_port_mode port_mode;
+
+	unsigned int port_id;
+
+	unsigned int port_speeds;
+
+	enum xgbe_conn_type conn_type;
+
+	enum xgbe_mode cur_mode;
+	enum xgbe_mode start_mode;
+
+	unsigned int rrc_count;
+};
+
+static enum xgbe_mode xgbe_phy_an_outcome(struct xgbe_prv_data *pdata)
+{
+	enum xgbe_mode mode;
+	unsigned int ad_reg, lp_reg;
+
+	pdata->phy.lp_advertising |= ADVERTISED_Autoneg;
+	pdata->phy.lp_advertising |= ADVERTISED_Backplane;
+
+	/* Compare Advertisement and Link Partner register 1 */
+	ad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE);
+	lp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA);
+	if (lp_reg & 0x400)
+		pdata->phy.lp_advertising |= ADVERTISED_Pause;
+	if (lp_reg & 0x800)
+		pdata->phy.lp_advertising |= ADVERTISED_Asym_Pause;
+
+	if (pdata->phy.pause_autoneg) {
+		/* Set flow control based on auto-negotiation result */
+		pdata->phy.tx_pause = 0;
+		pdata->phy.rx_pause = 0;
+
+		if (ad_reg & lp_reg & 0x400) {
+			pdata->phy.tx_pause = 1;
+			pdata->phy.rx_pause = 1;
+		} else if (ad_reg & lp_reg & 0x800) {
+			if (ad_reg & 0x400)
+				pdata->phy.rx_pause = 1;
+			else if (lp_reg & 0x400)
+				pdata->phy.tx_pause = 1;
+		}
+	}
+
+	/* Compare Advertisement and Link Partner register 2 */
+	ad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 1);
+	lp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 1);
+	if (lp_reg & 0x80)
+		pdata->phy.lp_advertising |= ADVERTISED_10000baseKR_Full;
+	if (lp_reg & 0x20)
+		pdata->phy.lp_advertising |= ADVERTISED_1000baseKX_Full;
+
+	ad_reg &= lp_reg;
+	if (ad_reg & 0x80)
+		mode = XGBE_MODE_KR;
+	else if (ad_reg & 0x20)
+		mode = XGBE_MODE_KX_1000;
+	else
+		mode = XGBE_MODE_UNKNOWN;
+
+	/* Compare Advertisement and Link Partner register 3 */
+	ad_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_ADVERTISE + 2);
+	lp_reg = XMDIO_READ(pdata, MDIO_MMD_AN, MDIO_AN_LPA + 2);
+	if (lp_reg & 0xc000)
+		pdata->phy.lp_advertising |= ADVERTISED_10000baseR_FEC;
+
+	return mode;
+}
+
+static enum xgbe_an_mode xgbe_phy_an_mode(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+
+	switch (phy_data->port_mode) {
+	case XGBE_PORT_MODE_BACKPLANE:
+		return XGBE_AN_MODE_CL73;
+	case XGBE_PORT_MODE_BACKPLANE_2500:
+		return XGBE_AN_MODE_NONE;
+	case XGBE_PORT_MODE_1000BASE_T:
+	case XGBE_PORT_MODE_1000BASE_X:
+	case XGBE_PORT_MODE_NBASE_T:
+	case XGBE_PORT_MODE_10GBASE_T:
+	case XGBE_PORT_MODE_10GBASE_R:
+	case XGBE_PORT_MODE_SFP:
+	default:
+		return XGBE_AN_MODE_NONE;
+	}
+}
+
+static void xgbe_phy_start_ratechange(struct xgbe_prv_data *pdata)
+{
+	if (!XP_IOREAD_BITS(pdata, XP_DRIVER_INT_RO, STATUS))
+		return;
+
+	/* Log if a previous command did not complete */
+	netif_dbg(pdata, link, pdata->netdev,
+		  "firmware mailbox not ready for command\n");
+}
+
+static void xgbe_phy_complete_ratechange(struct xgbe_prv_data *pdata)
+{
+	unsigned int wait;
+
+	/* Wait for command to complete */
+	wait = XGBE_RATECHANGE_COUNT;
+	while (wait--) {
+		if (!XP_IOREAD_BITS(pdata, XP_DRIVER_INT_RO, STATUS))
+			return;
+
+		usleep_range(1000, 2000);
+	}
+
+	netif_dbg(pdata, link, pdata->netdev,
+		  "firmware mailbox command did not complete\n");
+}
+
+static void xgbe_phy_rrc(struct xgbe_prv_data *pdata)
+{
+	unsigned int s0;
+
+	xgbe_phy_start_ratechange(pdata);
+
+	/* Receiver Reset Cycle */
+	s0 = 0;
+	XP_SET_BITS(s0, XP_DRIVER_SCRATCH_0, COMMAND, 5);
+	XP_SET_BITS(s0, XP_DRIVER_SCRATCH_0, SUB_COMMAND, 0);
+
+	/* Call FW to make the change */
+	XP_IOWRITE(pdata, XP_DRIVER_SCRATCH_0, s0);
+	XP_IOWRITE(pdata, XP_DRIVER_SCRATCH_1, 0);
+	XP_IOWRITE_BITS(pdata, XP_DRIVER_INT_REQ, REQUEST, 1);
+
+	xgbe_phy_complete_ratechange(pdata);
+
+	netif_dbg(pdata, link, pdata->netdev, "receiver reset complete\n");
+}
+
+static void xgbe_phy_power_off(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+
+	xgbe_phy_start_ratechange(pdata);
+
+	/* Call FW to make the change */
+	XP_IOWRITE(pdata, XP_DRIVER_SCRATCH_0, 0);
+	XP_IOWRITE(pdata, XP_DRIVER_SCRATCH_1, 0);
+	XP_IOWRITE_BITS(pdata, XP_DRIVER_INT_REQ, REQUEST, 1);
+
+	xgbe_phy_complete_ratechange(pdata);
+
+	phy_data->cur_mode = XGBE_MODE_UNKNOWN;
+
+	netif_dbg(pdata, link, pdata->netdev, "phy powered off\n");
+}
+
+static void xgbe_phy_kr_mode(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+	unsigned int s0;
+
+	xgbe_phy_start_ratechange(pdata);
+
+	/* 10G/KR */
+	s0 = 0;
+	XP_SET_BITS(s0, XP_DRIVER_SCRATCH_0, COMMAND, 4);
+	XP_SET_BITS(s0, XP_DRIVER_SCRATCH_0, SUB_COMMAND, 0);
+
+	/* Call FW to make the change */
+	XP_IOWRITE(pdata, XP_DRIVER_SCRATCH_0, s0);
+	XP_IOWRITE(pdata, XP_DRIVER_SCRATCH_1, 0);
+	XP_IOWRITE_BITS(pdata, XP_DRIVER_INT_REQ, REQUEST, 1);
+
+	xgbe_phy_complete_ratechange(pdata);
+
+	phy_data->cur_mode = XGBE_MODE_KR;
+
+	netif_dbg(pdata, link, pdata->netdev, "10GbE KR mode set\n");
+}
+
+static void xgbe_phy_kx_2500_mode(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+	unsigned int s0;
+
+	xgbe_phy_start_ratechange(pdata);
+
+	/* 2.5G/KX */
+	s0 = 0;
+	XP_SET_BITS(s0, XP_DRIVER_SCRATCH_0, COMMAND, 2);
+	XP_SET_BITS(s0, XP_DRIVER_SCRATCH_0, SUB_COMMAND, 0);
+
+	/* Call FW to make the change */
+	XP_IOWRITE(pdata, XP_DRIVER_SCRATCH_0, s0);
+	XP_IOWRITE(pdata, XP_DRIVER_SCRATCH_1, 0);
+	XP_IOWRITE_BITS(pdata, XP_DRIVER_INT_REQ, REQUEST, 1);
+
+	xgbe_phy_complete_ratechange(pdata);
+
+	phy_data->cur_mode = XGBE_MODE_KX_2500;
+
+	netif_dbg(pdata, link, pdata->netdev, "2.5GbE KX mode set\n");
+}
+
+static void xgbe_phy_kx_1000_mode(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+	unsigned int s0;
+
+	xgbe_phy_start_ratechange(pdata);
+
+	/* 1G/KX */
+	s0 = 0;
+	XP_SET_BITS(s0, XP_DRIVER_SCRATCH_0, COMMAND, 1);
+	XP_SET_BITS(s0, XP_DRIVER_SCRATCH_0, SUB_COMMAND, 3);
+
+	/* Call FW to make the change */
+	XP_IOWRITE(pdata, XP_DRIVER_SCRATCH_0, s0);
+	XP_IOWRITE(pdata, XP_DRIVER_SCRATCH_1, 0);
+	XP_IOWRITE_BITS(pdata, XP_DRIVER_INT_REQ, REQUEST, 1);
+
+	xgbe_phy_complete_ratechange(pdata);
+
+	phy_data->cur_mode = XGBE_MODE_KX_1000;
+
+	netif_dbg(pdata, link, pdata->netdev, "1GbE KX mode set\n");
+}
+
+static enum xgbe_mode xgbe_phy_cur_mode(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+
+	return phy_data->cur_mode;
+}
+
+static enum xgbe_mode xgbe_phy_switch_bp_2500_mode(struct xgbe_prv_data *pdata)
+{
+	return XGBE_MODE_KX_2500;
+}
+
+static enum xgbe_mode xgbe_phy_switch_bp_mode(struct xgbe_prv_data *pdata)
+{
+	/* If we are in KR switch to KX, and vice-versa */
+	switch (xgbe_phy_cur_mode(pdata)) {
+	case XGBE_MODE_KX_1000:
+		return XGBE_MODE_KR;
+	case XGBE_MODE_KR:
+	default:
+		return XGBE_MODE_KX_1000;
+	}
+}
+
+static enum xgbe_mode xgbe_phy_switch_mode(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+
+	switch (phy_data->port_mode) {
+	case XGBE_PORT_MODE_BACKPLANE:
+		return xgbe_phy_switch_bp_mode(pdata);
+	case XGBE_PORT_MODE_BACKPLANE_2500:
+		return xgbe_phy_switch_bp_2500_mode(pdata);
+	case XGBE_PORT_MODE_1000BASE_T:
+	case XGBE_PORT_MODE_1000BASE_X:
+	case XGBE_PORT_MODE_NBASE_T:
+	case XGBE_PORT_MODE_10GBASE_T:
+	case XGBE_PORT_MODE_10GBASE_R:
+	case XGBE_PORT_MODE_SFP:
+	default:
+		return XGBE_MODE_UNKNOWN;
+	}
+}
+
+static enum xgbe_mode xgbe_phy_get_bp_2500_mode(int speed)
+{
+	switch (speed) {
+	case SPEED_2500:
+		return XGBE_MODE_KX_2500;
+	default:
+		return XGBE_MODE_UNKNOWN;
+	}
+}
+
+static enum xgbe_mode xgbe_phy_get_bp_mode(int speed)
+{
+	switch (speed) {
+	case SPEED_1000:
+		return XGBE_MODE_KX_1000;
+	case SPEED_10000:
+		return XGBE_MODE_KR;
+	default:
+		return XGBE_MODE_UNKNOWN;
+	}
+}
+
+static enum xgbe_mode xgbe_phy_get_mode(struct xgbe_prv_data *pdata,
+					int speed)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+
+	switch (phy_data->port_mode) {
+	case XGBE_PORT_MODE_BACKPLANE:
+		return xgbe_phy_get_bp_mode(speed);
+	case XGBE_PORT_MODE_BACKPLANE_2500:
+		return xgbe_phy_get_bp_2500_mode(speed);
+	case XGBE_PORT_MODE_1000BASE_T:
+	case XGBE_PORT_MODE_1000BASE_X:
+	case XGBE_PORT_MODE_NBASE_T:
+	case XGBE_PORT_MODE_10GBASE_T:
+	case XGBE_PORT_MODE_10GBASE_R:
+	case XGBE_PORT_MODE_SFP:
+	default:
+		return XGBE_MODE_UNKNOWN;
+	}
+}
+
+static void xgbe_phy_set_mode(struct xgbe_prv_data *pdata, enum xgbe_mode mode)
+{
+	switch (mode) {
+	case XGBE_MODE_KX_1000:
+		xgbe_phy_kx_1000_mode(pdata);
+		break;
+	case XGBE_MODE_KX_2500:
+		xgbe_phy_kx_2500_mode(pdata);
+		break;
+	case XGBE_MODE_KR:
+		xgbe_phy_kr_mode(pdata);
+		break;
+	default:
+		break;
+	}
+}
+
+static bool xgbe_phy_check_mode(struct xgbe_prv_data *pdata,
+				enum xgbe_mode mode, u32 advert)
+{
+	if (pdata->phy.autoneg == AUTONEG_ENABLE) {
+		if (pdata->phy.advertising & advert)
+			return true;
+	} else {
+		enum xgbe_mode cur_mode;
+
+		cur_mode = xgbe_phy_get_mode(pdata, pdata->phy.speed);
+		if (cur_mode == mode)
+			return true;
+	}
+
+	return false;
+}
+
+static bool xgbe_phy_use_bp_2500_mode(struct xgbe_prv_data *pdata,
+				      enum xgbe_mode mode)
+{
+	switch (mode) {
+	case XGBE_MODE_KX_2500:
+		return xgbe_phy_check_mode(pdata, mode,
+					   ADVERTISED_2500baseX_Full);
+	default:
+		return false;
+	}
+}
+
+static bool xgbe_phy_use_bp_mode(struct xgbe_prv_data *pdata,
+				 enum xgbe_mode mode)
+{
+	switch (mode) {
+	case XGBE_MODE_KX_1000:
+		return xgbe_phy_check_mode(pdata, mode,
+					   ADVERTISED_1000baseKX_Full);
+	case XGBE_MODE_KR:
+		return xgbe_phy_check_mode(pdata, mode,
+					   ADVERTISED_10000baseKR_Full);
+	default:
+		return false;
+	}
+}
+
+static bool xgbe_phy_use_mode(struct xgbe_prv_data *pdata, enum xgbe_mode mode)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+
+	switch (phy_data->port_mode) {
+	case XGBE_PORT_MODE_BACKPLANE:
+		return xgbe_phy_use_bp_mode(pdata, mode);
+	case XGBE_PORT_MODE_BACKPLANE_2500:
+		return xgbe_phy_use_bp_2500_mode(pdata, mode);
+	case XGBE_PORT_MODE_1000BASE_T:
+	case XGBE_PORT_MODE_1000BASE_X:
+	case XGBE_PORT_MODE_NBASE_T:
+	case XGBE_PORT_MODE_10GBASE_T:
+	case XGBE_PORT_MODE_10GBASE_R:
+	case XGBE_PORT_MODE_SFP:
+	default:
+		return false;
+	}
+}
+
+static bool xgbe_phy_valid_speed_bp_2500_mode(int speed)
+{
+	switch (speed) {
+	case SPEED_2500:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool xgbe_phy_valid_speed_bp_mode(int speed)
+{
+	switch (speed) {
+	case SPEED_1000:
+	case SPEED_10000:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool xgbe_phy_valid_speed(struct xgbe_prv_data *pdata, int speed)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+
+	switch (phy_data->port_mode) {
+	case XGBE_PORT_MODE_BACKPLANE:
+		return xgbe_phy_valid_speed_bp_mode(speed);
+	case XGBE_PORT_MODE_BACKPLANE_2500:
+		return xgbe_phy_valid_speed_bp_2500_mode(speed);
+	case XGBE_PORT_MODE_1000BASE_T:
+	case XGBE_PORT_MODE_1000BASE_X:
+	case XGBE_PORT_MODE_NBASE_T:
+	case XGBE_PORT_MODE_10GBASE_T:
+	case XGBE_PORT_MODE_10GBASE_R:
+	case XGBE_PORT_MODE_SFP:
+	default:
+		return false;
+	}
+}
+
+static int xgbe_phy_link_status(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+	unsigned int reg;
+
+	/* Link status is latched low, so read once to clear
+	 * and then read again to get current state
+	 */
+	reg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1);
+	reg = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_STAT1);
+	if (reg & MDIO_STAT1_LSTATUS)
+		return 1;
+
+	/* No link, attempt a receiver reset cycle */
+	if (phy_data->rrc_count++) {
+		phy_data->rrc_count = 0;
+		xgbe_phy_rrc(pdata);
+	}
+
+	return 0;
+}
+
+static bool xgbe_phy_port_mode_mismatch(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+
+	switch (phy_data->port_mode) {
+	case XGBE_PORT_MODE_BACKPLANE:
+		if ((phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) ||
+		    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000))
+			return false;
+		break;
+	case XGBE_PORT_MODE_BACKPLANE_2500:
+		if (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_2500)
+			return false;
+		break;
+	case XGBE_PORT_MODE_1000BASE_T:
+		if ((phy_data->port_speeds & XGBE_PHY_PORT_SPEED_100) ||
+		    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000))
+			return false;
+		break;
+	case XGBE_PORT_MODE_1000BASE_X:
+		if (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000)
+			return false;
+		break;
+	case XGBE_PORT_MODE_NBASE_T:
+		if ((phy_data->port_speeds & XGBE_PHY_PORT_SPEED_100) ||
+		    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) ||
+		    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_2500))
+			return false;
+		break;
+	case XGBE_PORT_MODE_10GBASE_T:
+		if ((phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) ||
+		    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000))
+			return false;
+		break;
+	case XGBE_PORT_MODE_10GBASE_R:
+		if (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000)
+			return false;
+		break;
+	case XGBE_PORT_MODE_SFP:
+		if ((phy_data->port_speeds & XGBE_PHY_PORT_SPEED_100) ||
+		    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) ||
+		    (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000))
+			return false;
+		break;
+	default:
+		break;
+	}
+
+	return true;
+}
+
+static bool xgbe_phy_conn_type_mismatch(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+
+	switch (phy_data->port_mode) {
+	case XGBE_PORT_MODE_BACKPLANE:
+	case XGBE_PORT_MODE_BACKPLANE_2500:
+		if (phy_data->conn_type == XGBE_CONN_TYPE_BACKPLANE)
+			return false;
+		break;
+	case XGBE_PORT_MODE_1000BASE_T:
+	case XGBE_PORT_MODE_1000BASE_X:
+	case XGBE_PORT_MODE_NBASE_T:
+	case XGBE_PORT_MODE_10GBASE_T:
+	case XGBE_PORT_MODE_10GBASE_R:
+		if (phy_data->conn_type == XGBE_CONN_TYPE_MDIO)
+			return false;
+		break;
+	case XGBE_PORT_MODE_SFP:
+		if (phy_data->conn_type == XGBE_CONN_TYPE_SFP)
+			return false;
+		break;
+	default:
+		break;
+	}
+
+	return true;
+}
+
+static bool xgbe_phy_port_enabled(struct xgbe_prv_data *pdata)
+{
+	unsigned int reg;
+
+	reg = XP_IOREAD(pdata, XP_PROP_0);
+	if (!XP_GET_BITS(reg, XP_PROP_0, PORT_SPEEDS))
+		return false;
+	if (!XP_GET_BITS(reg, XP_PROP_0, CONN_TYPE))
+		return false;
+
+	return true;
+}
+
+static void xgbe_phy_stop(struct xgbe_prv_data *pdata)
+{
+	/* Power off the PHY */
+	xgbe_phy_power_off(pdata);
+}
+
+static int xgbe_phy_start(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+
+	/* Start in highest supported mode */
+	xgbe_phy_set_mode(pdata, phy_data->start_mode);
+
+	return 0;
+}
+
+static int xgbe_phy_reset(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data = pdata->phy_data;
+	enum xgbe_mode cur_mode;
+
+	/* Reset by power cycling the PHY */
+	cur_mode = phy_data->cur_mode;
+	xgbe_phy_power_off(pdata);
+	xgbe_phy_set_mode(pdata, cur_mode);
+
+	return 0;
+}
+
+static void xgbe_phy_exit(struct xgbe_prv_data *pdata)
+{
+	/* Nothing uniquely required for exit */
+}
+
+static int xgbe_phy_init(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_phy_data *phy_data;
+	unsigned int reg;
+
+	/* Check if enabled */
+	if (!xgbe_phy_port_enabled(pdata)) {
+		dev_info(pdata->dev, "device is not enabled\n");
+		return -ENODEV;
+	}
+
+	phy_data = devm_kzalloc(pdata->dev, sizeof(*phy_data), GFP_KERNEL);
+	if (!phy_data)
+		return -ENOMEM;
+	pdata->phy_data = phy_data;
+
+	reg = XP_IOREAD(pdata, XP_PROP_0);
+	phy_data->port_mode = XP_GET_BITS(reg, XP_PROP_0, PORT_MODE);
+	phy_data->port_id = XP_GET_BITS(reg, XP_PROP_0, PORT_ID);
+	phy_data->port_speeds = XP_GET_BITS(reg, XP_PROP_0, PORT_SPEEDS);
+	phy_data->conn_type = XP_GET_BITS(reg, XP_PROP_0, CONN_TYPE);
+	if (netif_msg_probe(pdata)) {
+		dev_dbg(pdata->dev, "port mode=%u\n", phy_data->port_mode);
+		dev_dbg(pdata->dev, "port id=%u\n", phy_data->port_id);
+		dev_dbg(pdata->dev, "port speeds=%#x\n", phy_data->port_speeds);
+		dev_dbg(pdata->dev, "conn type=%u\n", phy_data->conn_type);
+	}
+
+	/* Validate the connection requested */
+	if (xgbe_phy_conn_type_mismatch(pdata)) {
+		dev_err(pdata->dev, "phy mode/connection mismatch (%#x/%#x)\n",
+			phy_data->port_mode, phy_data->conn_type);
+	}
+
+	/* Validate the mode requested */
+	if (xgbe_phy_port_mode_mismatch(pdata)) {
+		dev_err(pdata->dev, "phy mode/speed mismatch (%#x/%#x)\n",
+			phy_data->port_mode, phy_data->port_speeds);
+		return -EINVAL;
+	}
+
+	/* Indicate current mode is unknown */
+	phy_data->cur_mode = XGBE_MODE_UNKNOWN;
+
+	/* Initialize supported features */
+	pdata->phy.supported = 0;
+
+	switch (phy_data->port_mode) {
+	case XGBE_PORT_MODE_BACKPLANE:
+		pdata->phy.supported |= SUPPORTED_Autoneg;
+		pdata->phy.supported |= SUPPORTED_Pause | SUPPORTED_Asym_Pause;
+		pdata->phy.supported |= SUPPORTED_Backplane;
+		if (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_1000) {
+			pdata->phy.supported |= SUPPORTED_1000baseKX_Full;
+			phy_data->start_mode = XGBE_MODE_KX_1000;
+		}
+		if (phy_data->port_speeds & XGBE_PHY_PORT_SPEED_10000) {
+			pdata->phy.supported |= SUPPORTED_10000baseKR_Full;
+			if (pdata->fec_ability & MDIO_PMA_10GBR_FECABLE_ABLE)
+				pdata->phy.supported |=
+					SUPPORTED_10000baseR_FEC;
+			phy_data->start_mode = XGBE_MODE_KR;
+		}
+		break;
+	case XGBE_PORT_MODE_BACKPLANE_2500:
+		pdata->phy.supported |= SUPPORTED_Pause | SUPPORTED_Asym_Pause;
+		pdata->phy.supported |= SUPPORTED_Backplane;
+		pdata->phy.supported |= SUPPORTED_2500baseX_Full;
+		phy_data->start_mode = XGBE_MODE_KX_2500;
+		break;
+	case XGBE_PORT_MODE_1000BASE_T:
+	case XGBE_PORT_MODE_1000BASE_X:
+	case XGBE_PORT_MODE_NBASE_T:
+	case XGBE_PORT_MODE_10GBASE_T:
+	case XGBE_PORT_MODE_10GBASE_R:
+	case XGBE_PORT_MODE_SFP:
+	default:
+		return -EINVAL;
+	}
+
+	if (netif_msg_probe(pdata))
+		dev_dbg(pdata->dev, "phy supported=%#x\n",
+			pdata->phy.supported);
+
+	return 0;
+}
+
+void xgbe_init_function_ptrs_phy_v2(struct xgbe_phy_if *phy_if)
+{
+	struct xgbe_phy_impl_if *phy_impl = &phy_if->phy_impl;
+
+	phy_impl->init			= xgbe_phy_init;
+	phy_impl->exit			= xgbe_phy_exit;
+
+	phy_impl->reset			= xgbe_phy_reset;
+	phy_impl->start			= xgbe_phy_start;
+	phy_impl->stop			= xgbe_phy_stop;
+
+	phy_impl->link_status		= xgbe_phy_link_status;
+
+	phy_impl->valid_speed		= xgbe_phy_valid_speed;
+
+	phy_impl->use_mode		= xgbe_phy_use_mode;
+	phy_impl->set_mode		= xgbe_phy_set_mode;
+	phy_impl->get_mode		= xgbe_phy_get_mode;
+	phy_impl->switch_mode		= xgbe_phy_switch_mode;
+	phy_impl->cur_mode		= xgbe_phy_cur_mode;
+
+	phy_impl->an_mode		= xgbe_phy_an_mode;
+
+	phy_impl->an_outcome		= xgbe_phy_an_outcome;
+}
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-platform.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe.h
