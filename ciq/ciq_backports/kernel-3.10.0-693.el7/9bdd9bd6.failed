xfs: buffer ->bi_end_io function requires irq-safe lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 9bdd9bd69b826875531bb1b2efb6aeb8d70e6f72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9bdd9bd6.failed

Reports have surfaced of a lockdep splat complaining about an
irq-safe -> irq-unsafe locking order in the xfs_buf_bio_end_io() bio
completion handler. This only occurs when I/O errors are present
because bp->b_lock is only acquired in this context to protect
setting an error on the buffer. The problem is that this lock can be
acquired with the (request_queue) q->queue_lock held. See
scsi_end_request() or ata_qc_schedule_eh(), for example.

Replace the locked test/set of b_io_error with a cmpxchg() call.
This eliminates the need for the lock and thus the lock ordering
problem goes away.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 9bdd9bd69b826875531bb1b2efb6aeb8d70e6f72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_buf.c
diff --cc fs/xfs/xfs_buf.c
index 52df2bc56800,e71cfbd5acb3..000000000000
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@@ -1223,23 -1100,18 +1223,28 @@@ xfs_bwrite
  	return error;
  }
  
- STATIC void
+ static void
  xfs_buf_bio_end_io(
 -	struct bio		*bio)
 +	struct bio		*bio,
 +	int			error)
  {
- 	xfs_buf_t		*bp = (xfs_buf_t *)bio->bi_private;
+ 	struct xfs_buf		*bp = (struct xfs_buf *)bio->bi_private;
  
  	/*
  	 * don't overwrite existing errors - otherwise we can lose errors on
  	 * buffers that require multiple bios to complete.
  	 */
++<<<<<<< HEAD
 +	if (error) {
 +		spin_lock(&bp->b_lock);
 +		if (!bp->b_io_error)
 +			bp->b_io_error = error;
 +		spin_unlock(&bp->b_lock);
 +	}
++=======
+ 	if (bio->bi_error)
+ 		cmpxchg(&bp->b_io_error, 0, bio->bi_error);
++>>>>>>> 9bdd9bd69b82 (xfs: buffer ->bi_end_io function requires irq-safe lock)
  
  	if (!bp->b_error && xfs_buf_is_vmapped(bp) && (bp->b_flags & XBF_READ))
  		invalidate_kernel_vmap_range(bp->b_addr, xfs_buf_vmap_len(bp));
* Unmerged path fs/xfs/xfs_buf.c
