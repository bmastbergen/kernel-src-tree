scsi: lpfc: NVME Target: Merge into FC discovery

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] lpfc: NVME Target: Merge into FC discovery (Ewan Milne) [1384922]
Rebuild_FUZZ: 93.33%
commit-author James Smart <jsmart2021@gmail.com>
commit 8c258641e01cfcc5620c4fb191300bea224bcc99
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8c258641.failed

NVME Target: Merge into FC discovery

Adds NVME PRLI handling and Nameserver registrations for NVME

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 8c258641e01cfcc5620c4fb191300bea224bcc99)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_ct.c
#	drivers/scsi/lpfc/lpfc_els.c
#	drivers/scsi/lpfc/lpfc_hbadisc.c
#	drivers/scsi/lpfc/lpfc_nportdisc.c
diff --cc drivers/scsi/lpfc/lpfc_ct.c
index 63e48d4277b0,d576da4d3afb..000000000000
--- a/drivers/scsi/lpfc/lpfc_ct.c
+++ b/drivers/scsi/lpfc/lpfc_ct.c
@@@ -1316,7 -1425,31 +1316,35 @@@ lpfc_ns_cmd(struct lpfc_vport *vport, i
  		    cpu_to_be16(SLI_CTNS_RFF_ID);
  		CtReq->un.rff.PortId = cpu_to_be32(vport->fc_myDID);
  		CtReq->un.rff.fbits = FC4_FEATURE_INIT;
++<<<<<<< HEAD
 +		CtReq->un.rff.type_code = FC_TYPE_FCP;
++=======
+ 
+ 		/* The driver always supports FC_TYPE_FCP.  However, the
+ 		 * caller can specify NVME (type x28) as well.  But only
+ 		 * these that FC4 type is supported.
+ 		 */
+ 		if (((phba->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||
+ 		     (phba->cfg_enable_fc4_type == LPFC_ENABLE_NVME)) &&
+ 		    (context == FC_TYPE_NVME)) {
+ 			if ((vport == phba->pport) && phba->nvmet_support) {
+ 				CtReq->un.rff.fbits = (FC4_FEATURE_TARGET |
+ 					FC4_FEATURE_NVME_DISC);
+ 				/* todo: update targetport attributes */
+ 			} else {
+ 				lpfc_nvme_update_localport(vport);
+ 			}
+ 			CtReq->un.rff.type_code = context;
+ 
+ 		} else if (((phba->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||
+ 			    (phba->cfg_enable_fc4_type == LPFC_ENABLE_FCP)) &&
+ 			   (context == FC_TYPE_FCP))
+ 			CtReq->un.rff.type_code = context;
+ 
+ 		else
+ 			goto ns_cmd_free_bmpvirt;
+ 
++>>>>>>> 8c258641e01c (scsi: lpfc: NVME Target: Merge into FC discovery)
  		cmpl = lpfc_cmpl_ct_cmd_rff_id;
  		break;
  	}
diff --cc drivers/scsi/lpfc/lpfc_els.c
index 00bce46470a8,5ee3ae88a080..000000000000
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@@ -2000,7 -2001,7 +2000,11 @@@ lpfc_issue_els_plogi(struct lpfc_vport 
  		sp->cmn.fcphHigh = FC_PH3;
  
  	sp->cmn.valid_vendor_ver_level = 0;
++<<<<<<< HEAD
 +	memset(sp->vendorVersion, 0, sizeof(sp->vendorVersion));
++=======
+ 	memset(sp->un.vendorVersion, 0, sizeof(sp->un.vendorVersion));
++>>>>>>> 8c258641e01c (scsi: lpfc: NVME Target: Merge into FC discovery)
  
  	lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,
  		"Issue PLOGI:     did:x%x",
@@@ -2131,29 -2168,69 +2144,92 @@@ lpfc_issue_els_prli(struct lpfc_vport *
  	pcmd = (uint8_t *) (((struct lpfc_dmabuf *) elsiocb->context2)->virt);
  
  	/* For PRLI request, remainder of payload is service parameters */
 -	memset(pcmd, 0, cmdsize);
 +	memset(pcmd, 0, (sizeof(PRLI) + sizeof(uint32_t)));
 +	*((uint32_t *) (pcmd)) = ELS_CMD_PRLI;
 +	pcmd += sizeof(uint32_t);
  
++<<<<<<< HEAD
 +	/* For PRLI, remainder of payload is PRLI parameter page */
 +	npr = (PRLI *) pcmd;
 +	/*
 +	 * If our firmware version is 3.20 or later,
 +	 * set the following bits for FC-TAPE support.
 +	 */
 +	if (phba->vpd.rev.feaLevelHigh >= 0x02) {
 +		npr->ConfmComplAllowed = 1;
 +		npr->Retry = 1;
 +		npr->TaskRetryIdReq = 1;
++=======
+ 	if (local_nlp_type & NLP_FC4_FCP) {
+ 		/* Remainder of payload is FCP PRLI parameter page.
+ 		 * Note: this data structure is defined as
+ 		 * BE/LE in the structure definition so no
+ 		 * byte swap call is made.
+ 		 */
+ 		*((uint32_t *)(pcmd)) = ELS_CMD_PRLI;
+ 		pcmd += sizeof(uint32_t);
+ 		npr = (PRLI *)pcmd;
+ 
+ 		/*
+ 		 * If our firmware version is 3.20 or later,
+ 		 * set the following bits for FC-TAPE support.
+ 		 */
+ 		if (phba->vpd.rev.feaLevelHigh >= 0x02) {
+ 			npr->ConfmComplAllowed = 1;
+ 			npr->Retry = 1;
+ 			npr->TaskRetryIdReq = 1;
+ 		}
+ 		npr->estabImagePair = 1;
+ 		npr->readXferRdyDis = 1;
+ 		if (vport->cfg_first_burst_size)
+ 			npr->writeXferRdyDis = 1;
+ 
+ 		/* For FCP support */
+ 		npr->prliType = PRLI_FCP_TYPE;
+ 		npr->initiatorFunc = 1;
+ 		elsiocb->iocb_flag |= LPFC_PRLI_FCP_REQ;
+ 
+ 		/* Remove FCP type - processed. */
+ 		local_nlp_type &= ~NLP_FC4_FCP;
+ 	} else if (local_nlp_type & NLP_FC4_NVME) {
+ 		/* Remainder of payload is NVME PRLI parameter page.
+ 		 * This data structure is the newer definition that
+ 		 * uses bf macros so a byte swap is required.
+ 		 */
+ 		*((uint32_t *)(pcmd)) = ELS_CMD_NVMEPRLI;
+ 		pcmd += sizeof(uint32_t);
+ 		npr_nvme = (struct lpfc_nvme_prli *)pcmd;
+ 		bf_set(prli_type_code, npr_nvme, PRLI_NVME_TYPE);
+ 		bf_set(prli_estabImagePair, npr_nvme, 0);  /* Should be 0 */
+ 
+ 		/* Only initiators request first burst. */
+ 		if ((phba->cfg_nvme_enable_fb) &&
+ 		    !phba->nvmet_support)
+ 			bf_set(prli_fba, npr_nvme, 1);
+ 
+ 		if (phba->nvmet_support) {
+ 			bf_set(prli_tgt, npr_nvme, 1);
+ 			bf_set(prli_disc, npr_nvme, 1);
+ 
+ 		} else {
+ 			bf_set(prli_init, npr_nvme, 1);
+ 		}
+ 		npr_nvme->word1 = cpu_to_be32(npr_nvme->word1);
+ 		npr_nvme->word4 = cpu_to_be32(npr_nvme->word4);
+ 		elsiocb->iocb_flag |= LPFC_PRLI_NVME_REQ;
+ 
+ 		/* Remove NVME type - processed. */
+ 		local_nlp_type &= ~NLP_FC4_NVME;
++>>>>>>> 8c258641e01c (scsi: lpfc: NVME Target: Merge into FC discovery)
  	}
 +	npr->estabImagePair = 1;
 +	npr->readXferRdyDis = 1;
 +	 if (vport->cfg_first_burst_size)
 +		npr->writeXferRdyDis = 1;
 +
 +	/* For FCP support */
 +	npr->prliType = PRLI_FCP_TYPE;
 +	npr->initiatorFunc = 1;
  
  	lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,
  		"Issue PRLI:      did:x%x",
@@@ -2543,6 -2633,14 +2619,17 @@@ out
  	if ((vport->fc_flag & FC_PT2PT) &&
  		!(vport->fc_flag & FC_PT2PT_PLOGI)) {
  		phba->pport->fc_myDID = 0;
++<<<<<<< HEAD
++=======
+ 
+ 		if ((phba->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||
+ 		    (phba->cfg_enable_fc4_type == LPFC_ENABLE_NVME)) {
+ 			if (!phba->nvmet_support)
+ 				lpfc_nvme_update_localport(phba->pport);
+ 			/* todo: tgt: update targetport attributes */
+ 		}
+ 
++>>>>>>> 8c258641e01c (scsi: lpfc: NVME Target: Merge into FC discovery)
  		mbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);
  		if (mbox) {
  			lpfc_config_link(phba, mbox);
@@@ -3986,7 -4098,18 +4073,22 @@@ lpfc_els_rsp_acc(struct lpfc_vport *vpo
  			       sizeof(struct serv_parm));
  
  			sp->cmn.valid_vendor_ver_level = 0;
++<<<<<<< HEAD
 +			memset(sp->vendorVersion, 0, sizeof(sp->vendorVersion));
++=======
+ 			memset(sp->un.vendorVersion, 0,
+ 			       sizeof(sp->un.vendorVersion));
+ 
+ 			/* If our firmware supports this feature, convey that
+ 			 * info to the target using the vendor specific field.
+ 			 */
+ 			if (phba->sli.sli_flag & LPFC_SLI_SUPPRESS_RSP) {
+ 				sp->cmn.valid_vendor_ver_level = 1;
+ 				sp->un.vv.vid = cpu_to_be32(LPFC_VV_EMLX_ID);
+ 				sp->un.vv.flags =
+ 					cpu_to_be32(LPFC_VV_SUPPRESS_RSP);
+ 			}
++>>>>>>> 8c258641e01c (scsi: lpfc: NVME Target: Merge into FC discovery)
  		}
  
  		lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,
@@@ -4254,28 -4404,65 +4356,55 @@@ lpfc_els_rsp_prli_acc(struct lpfc_vpor
  	pcmd += sizeof(uint32_t);
  
  	/* For PRLI, remainder of payload is PRLI parameter page */
 -	vpd = &phba->vpd;
 +	memset(pcmd, 0, sizeof(PRLI));
  
 -	if (prli_fc4_req == PRLI_FCP_TYPE) {
 -		/*
 -		 * If the remote port is a target and our firmware version
 -		 * is 3.20 or later, set the following bits for FC-TAPE
 -		 * support.
 -		 */
 -		npr = (PRLI *) pcmd;
 -		if ((ndlp->nlp_type & NLP_FCP_TARGET) &&
 -		    (vpd->rev.feaLevelHigh >= 0x02)) {
 -			npr->ConfmComplAllowed = 1;
 -			npr->Retry = 1;
 -			npr->TaskRetryIdReq = 1;
 -		}
 -		npr->acceptRspCode = PRLI_REQ_EXECUTED;
 -		npr->estabImagePair = 1;
 -		npr->readXferRdyDis = 1;
 +	npr = (PRLI *) pcmd;
 +	vpd = &phba->vpd;
 +	/*
 +	 * If the remote port is a target and our firmware version is 3.20 or
 +	 * later, set the following bits for FC-TAPE support.
 +	 */
 +	if ((ndlp->nlp_type & NLP_FCP_TARGET) &&
 +	    (vpd->rev.feaLevelHigh >= 0x02)) {
  		npr->ConfmComplAllowed = 1;
++<<<<<<< HEAD
 +		npr->Retry = 1;
 +		npr->TaskRetryIdReq = 1;
 +	}
++=======
+ 		npr->prliType = PRLI_FCP_TYPE;
+ 		npr->initiatorFunc = 1;
+ 	} else if (prli_fc4_req & PRLI_NVME_TYPE) {
+ 		/* Respond with an NVME PRLI Type */
+ 		npr_nvme = (struct lpfc_nvme_prli *) pcmd;
+ 		bf_set(prli_type_code, npr_nvme, PRLI_NVME_TYPE);
+ 		bf_set(prli_estabImagePair, npr_nvme, 0);  /* Should be 0 */
+ 		bf_set(prli_acc_rsp_code, npr_nvme, PRLI_REQ_EXECUTED);
+ 		if (phba->nvmet_support) {
+ 			bf_set(prli_tgt, npr_nvme, 1);
+ 			bf_set(prli_disc, npr_nvme, 1);
+ 			if (phba->cfg_nvme_enable_fb) {
+ 				bf_set(prli_fba, npr_nvme, 1);
+ 
+ 				/* TBD.  Target mode needs to post buffers
+ 				 * that support the configured first burst
+ 				 * byte size.
+ 				 */
+ 				bf_set(prli_fb_sz, npr_nvme,
+ 				       phba->cfg_nvmet_fb_size);
+ 			}
+ 		} else {
+ 			bf_set(prli_init, npr_nvme, 1);
+ 		}
++>>>>>>> 8c258641e01c (scsi: lpfc: NVME Target: Merge into FC discovery)
  
 -		lpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC,
 -				 "6015 NVME issue PRLI ACC word1 x%08x "
 -				 "word4 x%08x word5 x%08x flag x%x, "
 -				 "fcp_info x%x nlp_type x%x\n",
 -				 npr_nvme->word1, npr_nvme->word4,
 -				 npr_nvme->word5, ndlp->nlp_flag,
 -				 ndlp->nlp_fcp_info, ndlp->nlp_type);
 -		npr_nvme->word1 = cpu_to_be32(npr_nvme->word1);
 -		npr_nvme->word4 = cpu_to_be32(npr_nvme->word4);
 -		npr_nvme->word5 = cpu_to_be32(npr_nvme->word5);
 -	} else
 -		lpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,
 -				 "6128 Unknown FC_TYPE x%x x%x ndlp x%06x\n",
 -				 prli_fc4_req, ndlp->nlp_fc4_type,
 -				 ndlp->nlp_DID);
 +	npr->acceptRspCode = PRLI_REQ_EXECUTED;
 +	npr->estabImagePair = 1;
 +	npr->readXferRdyDis = 1;
 +	npr->ConfmComplAllowed = 1;
 +
 +	npr->prliType = PRLI_FCP_TYPE;
 +	npr->initiatorFunc = 1;
  
  	lpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,
  		"Issue ACC PRLI:  did:x%x flg:x%x",
diff --cc drivers/scsi/lpfc/lpfc_hbadisc.c
index 27f6a0bdf820,6bbb988dd8da..000000000000
--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@@ -897,7 -906,17 +897,19 @@@ lpfc_linkdown(struct lpfc_hba *phba
  		for (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {
  			/* Issue a LINK DOWN event to all nodes */
  			lpfc_linkdown_port(vports[i]);
++<<<<<<< HEAD
++=======
+ 
+ 			vports[i]->fc_myDID = 0;
+ 
+ 			if ((phba->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||
+ 			    (phba->cfg_enable_fc4_type == LPFC_ENABLE_NVME)) {
+ 				if (!phba->nvmet_support)
+ 					lpfc_nvme_update_localport(vports[i]);
+ 				/* todo: tgt: update targetport attributes */
+ 			}
++>>>>>>> 8c258641e01c (scsi: lpfc: NVME Target: Merge into FC discovery)
  		}
 -	}
  	lpfc_destroy_vport_work_array(phba, vports);
  	/* Clean up any firmware default rpi's */
  	mb = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);
@@@ -3554,6 -3584,13 +3566,16 @@@ lpfc_mbx_cmpl_reg_vpi(struct lpfc_hba *
  		vport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);
  		spin_unlock_irq(shost->host_lock);
  		vport->fc_myDID = 0;
++<<<<<<< HEAD
++=======
+ 
+ 		if ((phba->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||
+ 		    (phba->cfg_enable_fc4_type == LPFC_ENABLE_NVME)) {
+ 			if (!phba->nvmet_support)
+ 				lpfc_nvme_update_localport(vport);
+ 			/* todo: update targetport attributes */
+ 		}
++>>>>>>> 8c258641e01c (scsi: lpfc: NVME Target: Merge into FC discovery)
  		goto out;
  	}
  
@@@ -4037,23 -4140,56 +4059,51 @@@ lpfc_nlp_state_cleanup(struct lpfc_vpor
  	if (new_state == NLP_STE_NPR_NODE)
  		ndlp->nlp_flag &= ~NLP_RCV_PLOGI;
  
 -	/* FCP and NVME Transport interface */
 -	if ((old_state == NLP_STE_MAPPED_NODE ||
 -	     old_state == NLP_STE_UNMAPPED_NODE)) {
 -		if (ndlp->rport) {
 -			vport->phba->nport_event_cnt++;
 -			lpfc_unregister_remote_port(ndlp);
 -		}
 -
 -		/* Notify the NVME transport of this rport's loss */
 -		if (((phba->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||
 -		     (phba->cfg_enable_fc4_type == LPFC_ENABLE_NVME)) &&
 -		    (vport->phba->nvmet_support == 0) &&
 -		    ((ndlp->nlp_fc4_type & NLP_FC4_NVME) ||
 -		    (ndlp->nlp_DID == Fabric_DID))) {
 -			vport->phba->nport_event_cnt++;
 -			lpfc_nvme_unregister_port(vport, ndlp);
 -		}
 +	/* Transport interface */
 +	if (ndlp->rport && (old_state == NLP_STE_MAPPED_NODE ||
 +			    old_state == NLP_STE_UNMAPPED_NODE)) {
 +		vport->phba->nport_event_cnt++;
 +		lpfc_unregister_remote_port(ndlp);
  	}
  
 -	/* FCP and NVME Transport interfaces */
 -
  	if (new_state ==  NLP_STE_MAPPED_NODE ||
  	    new_state == NLP_STE_UNMAPPED_NODE) {
++<<<<<<< HEAD
 +		vport->phba->nport_event_cnt++;
 +		/*
 +		 * Tell the fc transport about the port, if we haven't
 +		 * already. If we have, and it's a scsi entity, be
 +		 * sure to unblock any attached scsi devices
 +		 */
 +		lpfc_register_remote_port(vport, ndlp);
++=======
+ 		if ((ndlp->nlp_fc4_type & NLP_FC4_FCP) ||
+ 		    (ndlp->nlp_DID == Fabric_DID)) {
+ 			vport->phba->nport_event_cnt++;
+ 			/*
+ 			 * Tell the fc transport about the port, if we haven't
+ 			 * already. If we have, and it's a scsi entity, be
+ 			 */
+ 			lpfc_register_remote_port(vport, ndlp);
+ 		}
+ 		/* Notify the NVME transport of this new rport. */
+ 		if (ndlp->nlp_fc4_type & NLP_FC4_NVME) {
+ 			if (vport->phba->nvmet_support == 0) {
+ 				/* Register this rport with the transport.
+ 				 * Initiators take the NDLP ref count in
+ 				 * the register.
+ 				 */
+ 				vport->phba->nport_event_cnt++;
+ 				lpfc_nvme_register_port(vport, ndlp);
+ 			} else {
+ 				/* Just take an NDLP ref count since the
+ 				 * target does not register rports.
+ 				 */
+ 				lpfc_nlp_get(ndlp);
+ 			}
+ 		}
++>>>>>>> 8c258641e01c (scsi: lpfc: NVME Target: Merge into FC discovery)
  	}
 -
  	if ((new_state ==  NLP_STE_MAPPED_NODE) &&
  		(vport->stat_data_enabled)) {
  		/*
diff --cc drivers/scsi/lpfc/lpfc_nportdisc.c
index 56a3df4fddb0,0716818f269f..000000000000
--- a/drivers/scsi/lpfc/lpfc_nportdisc.c
+++ b/drivers/scsi/lpfc/lpfc_nportdisc.c
@@@ -1489,8 -1533,38 +1518,42 @@@ lpfc_rcv_prli_reglogin_issue(struct lpf
  			     uint32_t evt)
  {
  	struct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;
+ 	struct ls_rjt     stat;
  
++<<<<<<< HEAD
 +	lpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);
++=======
+ 	if (vport->phba->nvmet_support) {
+ 		/* NVME Target mode.  Handle and respond to the PRLI and
+ 		 * transition to UNMAPPED provided the RPI has completed
+ 		 * registration.
+ 		 */
+ 		if (ndlp->nlp_flag & NLP_RPI_REGISTERED) {
+ 			lpfc_rcv_prli(vport, ndlp, cmdiocb);
+ 			lpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);
+ 			lpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);
+ 		} else {
+ 			/* RPI registration has not completed. Reject the PRLI
+ 			 * to prevent an illegal state transition when the
+ 			 * rpi registration does complete.
+ 			 */
+ 			lpfc_printf_vlog(vport, KERN_WARNING, LOG_NVME_DISC,
+ 					 "6115 NVMET ndlp rpi %d state "
+ 					 "unknown, state x%x flags x%08x\n",
+ 					 ndlp->nlp_rpi, ndlp->nlp_state,
+ 					 ndlp->nlp_flag);
+ 			memset(&stat, 0, sizeof(struct ls_rjt));
+ 			stat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;
+ 			stat.un.b.lsRjtRsnCodeExp = LSEXP_CMD_IN_PROGRESS;
+ 			lpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb,
+ 					    ndlp, NULL);
+ 		}
+ 	} else {
+ 		/* Initiator mode. */
+ 		lpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);
+ 	}
+ 
++>>>>>>> 8c258641e01c (scsi: lpfc: NVME Target: Merge into FC discovery)
  	return ndlp->nlp_state;
  }
  
@@@ -1621,8 -1725,16 +1684,21 @@@ lpfc_cmpl_reglogin_reglogin_issue(struc
  		lpfc_nlp_set_state(vport, ndlp, NLP_STE_PRLI_ISSUE);
  		lpfc_issue_els_prli(vport, ndlp, 0);
  	} else {
++<<<<<<< HEAD
 +		ndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;
 +		lpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);
++=======
+ 		if ((vport->fc_flag & FC_PT2PT) && phba->nvmet_support)
+ 			phba->targetport->port_id = vport->fc_myDID;
+ 
+ 		/* Only Fabric ports should transition. NVME target
+ 		 * must complete PRLI.
+ 		 */
+ 		if (ndlp->nlp_type & NLP_FABRIC) {
+ 			ndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;
+ 			lpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);
+ 		}
++>>>>>>> 8c258641e01c (scsi: lpfc: NVME Target: Merge into FC discovery)
  	}
  	return ndlp->nlp_state;
  }
@@@ -1663,7 -1775,14 +1739,18 @@@ lpfc_device_recov_reglogin_issue(struc
  	ndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;
  	lpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);
  	spin_lock_irq(shost->host_lock);
++<<<<<<< HEAD
 +	ndlp->nlp_flag |= NLP_IGNR_REG_CMPL;
++=======
+ 
+ 	/* If we are a target we won't immediately transition into PRLI,
+ 	 * so if REG_LOGIN already completed we don't need to ignore it.
+ 	 */
+ 	if (!(ndlp->nlp_flag & NLP_RPI_REGISTERED) ||
+ 	    !vport->phba->nvmet_support)
+ 		ndlp->nlp_flag |= NLP_IGNR_REG_CMPL;
+ 
++>>>>>>> 8c258641e01c (scsi: lpfc: NVME Target: Merge into FC discovery)
  	ndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);
  	spin_unlock_irq(shost->host_lock);
  	lpfc_disc_set_adisc(vport, ndlp);
* Unmerged path drivers/scsi/lpfc/lpfc_ct.c
* Unmerged path drivers/scsi/lpfc/lpfc_els.c
* Unmerged path drivers/scsi/lpfc/lpfc_hbadisc.c
diff --git a/drivers/scsi/lpfc/lpfc_hw.h b/drivers/scsi/lpfc/lpfc_hw.h
index 3b970d370600..e2fb1c774deb 100644
--- a/drivers/scsi/lpfc/lpfc_hw.h
+++ b/drivers/scsi/lpfc/lpfc_hw.h
@@ -492,7 +492,15 @@ struct serv_parm {	/* Structure is in Big Endian format */
 	struct class_parms cls2;
 	struct class_parms cls3;
 	struct class_parms cls4;
-	uint8_t vendorVersion[16];
+	union {
+		uint8_t vendorVersion[16];
+		struct {
+			uint32_t vid;
+#define LPFC_VV_EMLX_ID	0x454d4c58	/* EMLX */
+			uint32_t flags;
+#define LPFC_VV_SUPPRESS_RSP	1
+		} vv;
+	} un;
 };
 
 /*
* Unmerged path drivers/scsi/lpfc/lpfc_nportdisc.c
