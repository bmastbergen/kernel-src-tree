btrfs: qgroup: Refactor btrfs_qgroup_insert_dirty_extent()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Qu Wenruo <quwenruo@cn.fujitsu.com>
commit cb93b52cc005ba0e470845b519c662e661d5113c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/cb93b52c.failed

Refactor btrfs_qgroup_insert_dirty_extent() function, to two functions:
1. btrfs_qgroup_insert_dirty_extent_nolock()
   Almost the same with original code.
   For delayed_ref usage, which has delayed refs locked.

   Change the return value type to int, since caller never needs the
   pointer, but only needs to know if they need to free the allocated
   memory.

2. btrfs_qgroup_insert_dirty_extent()
   The more encapsulated version.

   Will do the delayed_refs lock, memory allocation, quota enabled check
   and other things.

The original design is to keep exported functions to minimal, but since
more btrfs hacks exposed, like replacing path in balance, we need to
record dirty extents manually, so we have to add such functions.

Also, add comment for both functions, to info developers how to keep
qgroup correct when doing hacks.

	Cc: Mark Fasheh <mfasheh@suse.de>
	Signed-off-by: Qu Wenruo <quwenruo@cn.fujitsu.com>
Reviewed-and-Tested-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
	Signed-off-by: David Sterba <dsterba@suse.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit cb93b52cc005ba0e470845b519c662e661d5113c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/delayed-ref.c
#	fs/btrfs/extent-tree.c
#	fs/btrfs/qgroup.c
#	fs/btrfs/qgroup.h
diff --cc fs/btrfs/delayed-ref.c
index 6c4a18010682,ac02e041464b..000000000000
--- a/fs/btrfs/delayed-ref.c
+++ b/fs/btrfs/delayed-ref.c
@@@ -606,9 -605,8 +605,14 @@@ add_delayed_ref_head(struct btrfs_fs_in
  		qrecord->num_bytes = num_bytes;
  		qrecord->old_roots = NULL;
  
++<<<<<<< HEAD
 +		qexisting = btrfs_qgroup_insert_dirty_extent(delayed_refs,
 +							     qrecord);
 +		if (qexisting)
++=======
+ 		if(btrfs_qgroup_insert_dirty_extent_nolock(fs_info,
+ 					delayed_refs, qrecord))
++>>>>>>> cb93b52cc005 (btrfs: qgroup: Refactor btrfs_qgroup_insert_dirty_extent())
  			kfree(qrecord);
  	}
  
diff --cc fs/btrfs/extent-tree.c
index 449311609978,d10872748c43..000000000000
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@@ -8144,34 -8521,6 +8144,37 @@@ reada
  	wc->reada_slot = slot;
  }
  
++<<<<<<< HEAD
 +/*
 + * These may not be seen by the usual inc/dec ref code so we have to
 + * add them here.
 + */
 +static int record_one_subtree_extent(struct btrfs_trans_handle *trans,
 +				     struct btrfs_root *root, u64 bytenr,
 +				     u64 num_bytes)
 +{
 +	struct btrfs_qgroup_extent_record *qrecord;
 +	struct btrfs_delayed_ref_root *delayed_refs;
 +
 +	qrecord = kmalloc(sizeof(*qrecord), GFP_NOFS);
 +	if (!qrecord)
 +		return -ENOMEM;
 +
 +	qrecord->bytenr = bytenr;
 +	qrecord->num_bytes = num_bytes;
 +	qrecord->old_roots = NULL;
 +
 +	delayed_refs = &trans->transaction->delayed_refs;
 +	spin_lock(&delayed_refs->lock);
 +	if (btrfs_qgroup_insert_dirty_extent(delayed_refs, qrecord))
 +		kfree(qrecord);
 +	spin_unlock(&delayed_refs->lock);
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> cb93b52cc005 (btrfs: qgroup: Refactor btrfs_qgroup_insert_dirty_extent())
  static int account_leaf_items(struct btrfs_trans_handle *trans,
  			      struct btrfs_root *root,
  			      struct extent_buffer *eb)
diff --cc fs/btrfs/qgroup.c
index 70c263934517,8db2e29fdcf4..000000000000
--- a/fs/btrfs/qgroup.c
+++ b/fs/btrfs/qgroup.c
@@@ -1453,9 -1453,9 +1453,15 @@@ int btrfs_qgroup_prepare_account_extent
  	return ret;
  }
  
++<<<<<<< HEAD
 +struct btrfs_qgroup_extent_record
 +*btrfs_qgroup_insert_dirty_extent(struct btrfs_delayed_ref_root *delayed_refs,
 +				  struct btrfs_qgroup_extent_record *record)
++=======
+ int btrfs_qgroup_insert_dirty_extent_nolock(struct btrfs_fs_info *fs_info,
+ 				struct btrfs_delayed_ref_root *delayed_refs,
+ 				struct btrfs_qgroup_extent_record *record)
++>>>>>>> cb93b52cc005 (btrfs: qgroup: Refactor btrfs_qgroup_insert_dirty_extent())
  {
  	struct rb_node **p = &delayed_refs->dirty_extent_root.rb_node;
  	struct rb_node *parent_node = NULL;
diff --cc fs/btrfs/qgroup.h
index 3d73e4c9c7df,1bc64c864b62..000000000000
--- a/fs/btrfs/qgroup.h
+++ b/fs/btrfs/qgroup.h
@@@ -64,9 -64,35 +64,41 @@@ void btrfs_free_qgroup_config(struct bt
  struct btrfs_delayed_extent_op;
  int btrfs_qgroup_prepare_account_extents(struct btrfs_trans_handle *trans,
  					 struct btrfs_fs_info *fs_info);
++<<<<<<< HEAD
 +struct btrfs_qgroup_extent_record
 +*btrfs_qgroup_insert_dirty_extent(struct btrfs_delayed_ref_root *delayed_refs,
 +				  struct btrfs_qgroup_extent_record *record);
++=======
+ /*
+  * Insert one dirty extent record into @delayed_refs, informing qgroup to
+  * account that extent at commit trans time.
+  *
+  * No lock version, caller must acquire delayed ref lock and allocate memory.
+  *
+  * Return 0 for success insert
+  * Return >0 for existing record, caller can free @record safely.
+  * Error is not possible
+  */
+ int btrfs_qgroup_insert_dirty_extent_nolock(
+ 		struct btrfs_fs_info *fs_info,
+ 		struct btrfs_delayed_ref_root *delayed_refs,
+ 		struct btrfs_qgroup_extent_record *record);
+ 
+ /*
+  * Insert one dirty extent record into @delayed_refs, informing qgroup to
+  * account that extent at commit trans time.
+  *
+  * Better encapsulated version.
+  *
+  * Return 0 if the operation is done.
+  * Return <0 for error, like memory allocation failure or invalid parameter
+  * (NULL trans)
+  */
+ int btrfs_qgroup_insert_dirty_extent(struct btrfs_trans_handle *trans,
+ 		struct btrfs_fs_info *fs_info, u64 bytenr, u64 num_bytes,
+ 		gfp_t gfp_flag);
+ 
++>>>>>>> cb93b52cc005 (btrfs: qgroup: Refactor btrfs_qgroup_insert_dirty_extent())
  int
  btrfs_qgroup_account_extent(struct btrfs_trans_handle *trans,
  			    struct btrfs_fs_info *fs_info,
* Unmerged path fs/btrfs/delayed-ref.c
* Unmerged path fs/btrfs/extent-tree.c
* Unmerged path fs/btrfs/qgroup.c
* Unmerged path fs/btrfs/qgroup.h
