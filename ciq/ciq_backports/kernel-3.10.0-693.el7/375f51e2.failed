net/mlx5: E-Switch, Don't allow changing inline mode when flows are configured

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Don't allow changing inline mode when flows are configured (Jonathan Toppins) [1446112]
Rebuild_FUZZ: 97.37%
commit-author Roi Dayan <roid@mellanox.com>
commit 375f51e2b5b7b9a42b3139aea519cbb1bfc5d6ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/375f51e2.failed

Changing the eswitch inline mode can potentially cause already configured
flows not to match the policy. E.g. set policy L4, add some L4 rules,
set policy to L2 --> bad! Hence we disallow it.

Keep track of how many offloaded rules are now set and refuse
inline mode changes if this isn't zero.

Fixes: bffaa916588e ("net/mlx5: E-Switch, Add control for inline mode")
	Signed-off-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 375f51e2b5b7b9a42b3139aea519cbb1bfc5d6ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 7b5e70f8cc22,ad329b1680b4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -130,9 -159,57 +130,63 @@@ struct mlx5_l2_table 
  
  struct mlx5_eswitch_fdb {
  	void *fdb;
++<<<<<<< HEAD
 +	struct mlx5_flow_group *addr_grp;
 +	struct mlx5_flow_group *allmulti_grp;
 +	struct mlx5_flow_group *promisc_grp;
++=======
+ 	union {
+ 		struct legacy_fdb {
+ 			struct mlx5_flow_group *addr_grp;
+ 			struct mlx5_flow_group *allmulti_grp;
+ 			struct mlx5_flow_group *promisc_grp;
+ 		} legacy;
+ 
+ 		struct offloads_fdb {
+ 			struct mlx5_flow_table *fdb;
+ 			struct mlx5_flow_group *send_to_vport_grp;
+ 			struct mlx5_flow_group *miss_grp;
+ 			struct mlx5_flow_handle *miss_rule;
+ 			int vlan_push_pop_refcount;
+ 		} offloads;
+ 	};
+ };
+ 
+ enum {
+ 	SRIOV_NONE,
+ 	SRIOV_LEGACY,
+ 	SRIOV_OFFLOADS
+ };
+ 
+ struct mlx5_esw_sq {
+ 	struct mlx5_flow_handle	*send_to_vport_rule;
+ 	struct list_head	 list;
+ };
+ 
+ struct mlx5_eswitch_rep {
+ 	int		       (*load)(struct mlx5_eswitch *esw,
+ 				       struct mlx5_eswitch_rep *rep);
+ 	void		       (*unload)(struct mlx5_eswitch *esw,
+ 					 struct mlx5_eswitch_rep *rep);
+ 	u16		       vport;
+ 	u8		       hw_id[ETH_ALEN];
+ 	struct net_device      *netdev;
+ 
+ 	struct mlx5_flow_handle *vport_rx_rule;
+ 	struct list_head       vport_sqs_list;
+ 	u16		       vlan;
+ 	u32		       vlan_refcount;
+ 	bool		       valid;
+ };
+ 
+ struct mlx5_esw_offload {
+ 	struct mlx5_flow_table *ft_offloads;
+ 	struct mlx5_flow_group *vport_rx_group;
+ 	struct mlx5_eswitch_rep *vport_reps;
+ 	DECLARE_HASHTABLE(encap_tbl, 8);
+ 	u8 inline_mode;
+ 	u64 num_flows;
++>>>>>>> 375f51e2b5b7 (net/mlx5: E-Switch, Don't allow changing inline mode when flows are configured)
  };
  
  struct mlx5_eswitch {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
