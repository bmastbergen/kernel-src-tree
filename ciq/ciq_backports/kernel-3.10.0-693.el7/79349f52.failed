x86/RAS: Simplify SMCA bank descriptor struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] ras: Simplify SMCA bank descriptor struct (Suravee Suthikulpanit) [1303712]
Rebuild_FUZZ: 95.35%
commit-author Borislav Petkov <bp@suse.de>
commit 79349f529ab1a629b9e43e81b4a5b2c22d1e9a65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/79349f52.failed

Call the struct simply smca_bank, it's instance ID can be simply ->id.
Makes the code much more readable.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Tested-by: Yazen Ghannam <yazen.ghannam@amd.com>
Link: http://lkml.kernel.org/r/20161103125556.15482-1-bp@alien8.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 79349f529ab1a629b9e43e81b4a5b2c22d1e9a65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mce.h
#	arch/x86/kernel/cpu/mcheck/mce_amd.c
diff --cc arch/x86/include/asm/mce.h
index cb08d9d92582,4d97875d9543..000000000000
--- a/arch/x86/include/asm/mce.h
+++ b/arch/x86/include/asm/mce.h
@@@ -295,4 -332,53 +295,56 @@@ struct cper_sec_mem_err
  extern void apei_mce_report_mem_error(int corrected,
  				      struct cper_sec_mem_err *mem_err);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Enumerate new IP types and HWID values in AMD processors which support
+  * Scalable MCA.
+  */
+ #ifdef CONFIG_X86_MCE_AMD
+ 
+ /* These may be used by multiple smca_hwid_mcatypes */
+ enum smca_bank_types {
+ 	SMCA_LS = 0,	/* Load Store */
+ 	SMCA_IF,	/* Instruction Fetch */
+ 	SMCA_L2_CACHE,	/* L2 Cache */
+ 	SMCA_DE,	/* Decoder Unit */
+ 	SMCA_EX,	/* Execution Unit */
+ 	SMCA_FP,	/* Floating Point */
+ 	SMCA_L3_CACHE,	/* L3 Cache */
+ 	SMCA_CS,	/* Coherent Slave */
+ 	SMCA_PIE,	/* Power, Interrupts, etc. */
+ 	SMCA_UMC,	/* Unified Memory Controller */
+ 	SMCA_PB,	/* Parameter Block */
+ 	SMCA_PSP,	/* Platform Security Processor */
+ 	SMCA_SMU,	/* System Management Unit */
+ 	N_SMCA_BANK_TYPES
+ };
+ 
+ struct smca_bank_name {
+ 	const char *name;	/* Short name for sysfs */
+ 	const char *long_name;	/* Long name for pretty-printing */
+ };
+ 
+ extern struct smca_bank_name smca_bank_names[N_SMCA_BANK_TYPES];
+ 
+ #define HWID_MCATYPE(hwid, mcatype) ((hwid << 16) | mcatype)
+ 
+ struct smca_hwid_mcatype {
+ 	unsigned int bank_type;	/* Use with smca_bank_types for easy indexing. */
+ 	u32 hwid_mcatype;	/* (hwid,mcatype) tuple */
+ 	u32 xec_bitmap;		/* Bitmap of valid ExtErrorCodes; current max is 21. */
+ };
+ 
+ struct smca_bank {
+ 	struct smca_hwid_mcatype *type;
+ 	/* Instance ID */
+ 	u32 id;
+ };
+ 
+ extern struct smca_bank smca_banks[MAX_NR_BANKS];
+ 
+ #endif
+ 
++>>>>>>> 79349f529ab1 (x86/RAS: Simplify SMCA bank descriptor struct)
  #endif /* _ASM_X86_MCE_H */
diff --cc arch/x86/kernel/cpu/mcheck/mce_amd.c
index 95ca733e89ae,ac2f4f2cad18..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce_amd.c
+++ b/arch/x86/kernel/cpu/mcheck/mce_amd.c
@@@ -63,6 -64,72 +63,75 @@@ static const char * const th_names[] = 
  	"execution_unit",
  };
  
++<<<<<<< HEAD
++=======
+ static const char * const smca_umc_block_names[] = {
+ 	"dram_ecc",
+ 	"misc_umc"
+ };
+ 
+ struct smca_bank_name smca_bank_names[] = {
+ 	[SMCA_LS]	= { "load_store",	"Load Store Unit" },
+ 	[SMCA_IF]	= { "insn_fetch",	"Instruction Fetch Unit" },
+ 	[SMCA_L2_CACHE]	= { "l2_cache",		"L2 Cache" },
+ 	[SMCA_DE]	= { "decode_unit",	"Decode Unit" },
+ 	[SMCA_EX]	= { "execution_unit",	"Execution Unit" },
+ 	[SMCA_FP]	= { "floating_point",	"Floating Point Unit" },
+ 	[SMCA_L3_CACHE]	= { "l3_cache",		"L3 Cache" },
+ 	[SMCA_CS]	= { "coherent_slave",	"Coherent Slave" },
+ 	[SMCA_PIE]	= { "pie",		"Power, Interrupts, etc." },
+ 	[SMCA_UMC]	= { "umc",		"Unified Memory Controller" },
+ 	[SMCA_PB]	= { "param_block",	"Parameter Block" },
+ 	[SMCA_PSP]	= { "psp",		"Platform Security Processor" },
+ 	[SMCA_SMU]	= { "smu",		"System Management Unit" },
+ };
+ EXPORT_SYMBOL_GPL(smca_bank_names);
+ 
+ static struct smca_hwid_mcatype smca_hwid_mcatypes[] = {
+ 	/* { bank_type, hwid_mcatype, xec_bitmap } */
+ 
+ 	/* ZN Core (HWID=0xB0) MCA types */
+ 	{ SMCA_LS,	 HWID_MCATYPE(0xB0, 0x0), 0x1FFFEF },
+ 	{ SMCA_IF,	 HWID_MCATYPE(0xB0, 0x1), 0x3FFF },
+ 	{ SMCA_L2_CACHE, HWID_MCATYPE(0xB0, 0x2), 0xF },
+ 	{ SMCA_DE,	 HWID_MCATYPE(0xB0, 0x3), 0x1FF },
+ 	/* HWID 0xB0 MCATYPE 0x4 is Reserved */
+ 	{ SMCA_EX,	 HWID_MCATYPE(0xB0, 0x5), 0x7FF },
+ 	{ SMCA_FP,	 HWID_MCATYPE(0xB0, 0x6), 0x7F },
+ 	{ SMCA_L3_CACHE, HWID_MCATYPE(0xB0, 0x7), 0xFF },
+ 
+ 	/* Data Fabric MCA types */
+ 	{ SMCA_CS,	 HWID_MCATYPE(0x2E, 0x0), 0x1FF },
+ 	{ SMCA_PIE,	 HWID_MCATYPE(0x2E, 0x1), 0xF },
+ 
+ 	/* Unified Memory Controller MCA type */
+ 	{ SMCA_UMC,	 HWID_MCATYPE(0x96, 0x0), 0x3F },
+ 
+ 	/* Parameter Block MCA type */
+ 	{ SMCA_PB,	 HWID_MCATYPE(0x05, 0x0), 0x1 },
+ 
+ 	/* Platform Security Processor MCA type */
+ 	{ SMCA_PSP,	 HWID_MCATYPE(0xFF, 0x0), 0x1 },
+ 
+ 	/* System Management Unit MCA type */
+ 	{ SMCA_SMU,	 HWID_MCATYPE(0x01, 0x0), 0x1 },
+ };
+ 
+ struct smca_bank smca_banks[MAX_NR_BANKS];
+ EXPORT_SYMBOL_GPL(smca_banks);
+ 
+ /*
+  * In SMCA enabled processors, we can have multiple banks for a given IP type.
+  * So to define a unique name for each bank, we use a temp c-string to append
+  * the MCA_IPID[InstanceId] to type's name in get_name().
+  *
+  * InstanceId is 32 bits which is 8 characters. Make sure MAX_MCATYPE_NAME_LEN
+  * is greater than 8 plus 1 (for underscore) plus length of longest type name.
+  */
+ #define MAX_MCATYPE_NAME_LEN	30
+ static char buf_mcatype[MAX_MCATYPE_NAME_LEN];
+ 
++>>>>>>> 79349f529ab1 (x86/RAS: Simplify SMCA bank descriptor struct)
  static DEFINE_PER_CPU(struct threshold_bank **, threshold_banks);
  static DEFINE_PER_CPU(unsigned int, bank_map);	/* see which banks are on */
  
@@@ -79,6 -146,36 +148,39 @@@ void (*deferred_error_int_vector)(void
   * CPU Initialization
   */
  
++<<<<<<< HEAD
++=======
+ static void get_smca_bank_info(unsigned int bank)
+ {
+ 	unsigned int i, hwid_mcatype, cpu = smp_processor_id();
+ 	struct smca_hwid_mcatype *type;
+ 	u32 high, instance_id;
+ 	u16 hwid, mcatype;
+ 
+ 	/* Collect bank_info using CPU 0 for now. */
+ 	if (cpu)
+ 		return;
+ 
+ 	if (rdmsr_safe_on_cpu(cpu, MSR_AMD64_SMCA_MCx_IPID(bank), &instance_id, &high)) {
+ 		pr_warn("Failed to read MCA_IPID for bank %d\n", bank);
+ 		return;
+ 	}
+ 
+ 	hwid = high & MCI_IPID_HWID;
+ 	mcatype = (high & MCI_IPID_MCATYPE) >> 16;
+ 	hwid_mcatype = HWID_MCATYPE(hwid, mcatype);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(smca_hwid_mcatypes); i++) {
+ 		type = &smca_hwid_mcatypes[i];
+ 		if (hwid_mcatype == type->hwid_mcatype) {
+ 			smca_banks[bank].type = type;
+ 			smca_banks[bank].id = instance_id;
+ 			break;
+ 		}
+ 	}
+ }
+ 
++>>>>>>> 79349f529ab1 (x86/RAS: Simplify SMCA bank descriptor struct)
  struct thresh_restart {
  	struct threshold_block	*b;
  	int			reset;
@@@ -651,6 -815,34 +753,37 @@@ static struct kobj_type threshold_ktyp
  	.default_attrs		= default_attrs,
  };
  
++<<<<<<< HEAD
++=======
+ static const char *get_name(unsigned int bank, struct threshold_block *b)
+ {
+ 	unsigned int bank_type;
+ 
+ 	if (!mce_flags.smca) {
+ 		if (b && bank == 4)
+ 			return bank4_names(b);
+ 
+ 		return th_names[bank];
+ 	}
+ 
+ 	if (!smca_banks[bank].type)
+ 		return NULL;
+ 
+ 	bank_type = smca_banks[bank].type->bank_type;
+ 
+ 	if (b && bank_type == SMCA_UMC) {
+ 		if (b->block < ARRAY_SIZE(smca_umc_block_names))
+ 			return smca_umc_block_names[b->block];
+ 		return NULL;
+ 	}
+ 
+ 	snprintf(buf_mcatype, MAX_MCATYPE_NAME_LEN,
+ 		 "%s_%x", smca_bank_names[bank_type].name,
+ 			  smca_banks[bank].id);
+ 	return buf_mcatype;
+ }
+ 
++>>>>>>> 79349f529ab1 (x86/RAS: Simplify SMCA bank descriptor struct)
  static int allocate_threshold_blocks(unsigned int cpu, unsigned int bank,
  				     unsigned int block, u32 address)
  {
* Unmerged path arch/x86/include/asm/mce.h
* Unmerged path arch/x86/kernel/cpu/mcheck/mce_amd.c
