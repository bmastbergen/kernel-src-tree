net/mlx5e: Save the represntor netdevice as part of the representor

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Save the represntor netdevice as part of the representor (Don Dutile) [1385330 1417286]
Rebuild_FUZZ: 96.92%
commit-author Hadar Hen Zion <hadarh@mellanox.com>
commit 726293f1f851242c1c308e71ef9dfd0c2251f94a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/726293f1.failed

Replace the representor private data to a net_device pointer holding the
representor netdevice, instead of void pointer holding mlx5e_priv.

It will be used by a new eswitch service function, returning the uplink representor
netdevice.

	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 726293f1f851242c1c308e71ef9dfd0c2251f94a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 2aca61ab5499,9def5cc378a3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -3003,18 -3748,105 +3003,102 @@@ static int mlx5e_create_umr_mkey(struc
  	return err;
  }
  
 -static void mlx5e_cleanup_nic_rx(struct mlx5e_priv *priv)
 +static void *mlx5e_create_netdev(struct mlx5_core_dev *mdev)
  {
++<<<<<<< HEAD
++=======
+ 	int i;
+ 
+ 	mlx5e_tc_cleanup(priv);
+ 	mlx5e_destroy_flow_steering(priv);
+ 	mlx5e_destroy_direct_tirs(priv);
+ 	mlx5e_destroy_indirect_tirs(priv);
+ 	for (i = 0; i < priv->profile->max_nch(priv->mdev); i++)
+ 		mlx5e_destroy_rqt(priv, &priv->direct_tir[i].rqt);
+ 	mlx5e_destroy_rqt(priv, &priv->indir_rqt);
+ }
+ 
+ static int mlx5e_init_nic_tx(struct mlx5e_priv *priv)
+ {
+ 	int err;
+ 
+ 	err = mlx5e_create_tises(priv);
+ 	if (err) {
+ 		mlx5_core_warn(priv->mdev, "create tises failed, %d\n", err);
+ 		return err;
+ 	}
+ 
+ #ifdef CONFIG_MLX5_CORE_EN_DCB
+ 	mlx5e_dcbnl_initialize(priv);
+ #endif
+ 	return 0;
+ }
+ 
+ static void mlx5e_nic_enable(struct mlx5e_priv *priv)
+ {
+ 	struct net_device *netdev = priv->netdev;
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	struct mlx5_eswitch_rep rep;
+ 
+ 	mlx5_lag_add(mdev, netdev);
+ 
+ 	if (mlx5e_vxlan_allowed(mdev)) {
+ 		rtnl_lock();
+ 		udp_tunnel_get_rx_info(netdev);
+ 		rtnl_unlock();
+ 	}
+ 
+ 	mlx5e_enable_async_events(priv);
+ 	queue_work(priv->wq, &priv->set_rx_mode_work);
+ 
+ 	if (MLX5_CAP_GEN(mdev, vport_group_manager)) {
+ 		mlx5_query_nic_vport_mac_address(mdev, 0, rep.hw_id);
+ 		rep.load = mlx5e_nic_rep_load;
+ 		rep.unload = mlx5e_nic_rep_unload;
+ 		rep.vport = FDB_UPLINK_VPORT;
+ 		rep.netdev = netdev;
+ 		mlx5_eswitch_register_vport_rep(esw, 0, &rep);
+ 	}
+ }
+ 
+ static void mlx5e_nic_disable(struct mlx5e_priv *priv)
+ {
+ 	queue_work(priv->wq, &priv->set_rx_mode_work);
+ 	mlx5e_disable_async_events(priv);
+ 	mlx5_lag_remove(priv->mdev);
+ }
+ 
+ static const struct mlx5e_profile mlx5e_nic_profile = {
+ 	.init		   = mlx5e_nic_init,
+ 	.cleanup	   = mlx5e_nic_cleanup,
+ 	.init_rx	   = mlx5e_init_nic_rx,
+ 	.cleanup_rx	   = mlx5e_cleanup_nic_rx,
+ 	.init_tx	   = mlx5e_init_nic_tx,
+ 	.cleanup_tx	   = mlx5e_cleanup_nic_tx,
+ 	.enable		   = mlx5e_nic_enable,
+ 	.disable	   = mlx5e_nic_disable,
+ 	.update_stats	   = mlx5e_update_stats,
+ 	.max_nch	   = mlx5e_get_max_num_channels,
+ 	.max_tc		   = MLX5E_MAX_NUM_TC,
+ };
+ 
+ struct net_device *mlx5e_create_netdev(struct mlx5_core_dev *mdev,
+ 				       const struct mlx5e_profile *profile,
+ 				       void *ppriv)
+ {
+ 	int nch = profile->max_nch(mdev);
++>>>>>>> 726293f1f851 (net/mlx5e: Save the represntor netdevice as part of the representor)
  	struct net_device *netdev;
  	struct mlx5e_priv *priv;
 +	int nch = mlx5e_get_max_num_channels(mdev);
 +	int err;
 +
 +	if (mlx5e_check_required_hca_cap(mdev))
 +		return NULL;
  
  	netdev = alloc_etherdev_mqs(sizeof(struct mlx5e_priv),
 -				    nch * profile->max_tc,
 +				    nch * MLX5E_MAX_NUM_TC,
  				    nch);
  	if (!netdev) {
  		mlx5_core_err(mdev, "alloc_etherdev_mqs() failed\n");
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 7b5e70f8cc22,8661dd3f542c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -130,9 -151,56 +130,62 @@@ struct mlx5_l2_table 
  
  struct mlx5_eswitch_fdb {
  	void *fdb;
++<<<<<<< HEAD
 +	struct mlx5_flow_group *addr_grp;
 +	struct mlx5_flow_group *allmulti_grp;
 +	struct mlx5_flow_group *promisc_grp;
++=======
+ 	union {
+ 		struct legacy_fdb {
+ 			struct mlx5_flow_group *addr_grp;
+ 			struct mlx5_flow_group *allmulti_grp;
+ 			struct mlx5_flow_group *promisc_grp;
+ 		} legacy;
+ 
+ 		struct offloads_fdb {
+ 			struct mlx5_flow_table *fdb;
+ 			struct mlx5_flow_group *send_to_vport_grp;
+ 			struct mlx5_flow_group *miss_grp;
+ 			struct mlx5_flow_handle *miss_rule;
+ 			int vlan_push_pop_refcount;
+ 		} offloads;
+ 	};
+ };
+ 
+ enum {
+ 	SRIOV_NONE,
+ 	SRIOV_LEGACY,
+ 	SRIOV_OFFLOADS
+ };
+ 
+ struct mlx5_esw_sq {
+ 	struct mlx5_flow_handle	*send_to_vport_rule;
+ 	struct list_head	 list;
+ };
+ 
+ struct mlx5_eswitch_rep {
+ 	int		       (*load)(struct mlx5_eswitch *esw,
+ 				       struct mlx5_eswitch_rep *rep);
+ 	void		       (*unload)(struct mlx5_eswitch *esw,
+ 					 struct mlx5_eswitch_rep *rep);
+ 	u16		       vport;
+ 	u8		       hw_id[ETH_ALEN];
+ 	struct net_device      *netdev;
+ 
+ 	struct mlx5_flow_handle *vport_rx_rule;
+ 	struct list_head       vport_sqs_list;
+ 	u16		       vlan;
+ 	u32		       vlan_refcount;
+ 	bool		       valid;
+ };
+ 
+ struct mlx5_esw_offload {
+ 	struct mlx5_flow_table *ft_offloads;
+ 	struct mlx5_flow_group *vport_rx_group;
+ 	struct mlx5_eswitch_rep *vport_reps;
+ 	DECLARE_HASHTABLE(encap_tbl, 8);
+ 	u8 inline_mode;
++>>>>>>> 726293f1f851 (net/mlx5e: Save the represntor netdevice as part of the representor)
  };
  
  struct mlx5_eswitch {
@@@ -170,4 -256,85 +223,88 @@@ int mlx5_eswitch_get_vport_stats(struc
  				 int vport,
  				 struct ifla_vf_stats *vf_stats);
  
++<<<<<<< HEAD
++=======
+ struct mlx5_flow_spec;
+ struct mlx5_esw_flow_attr;
+ 
+ struct mlx5_flow_handle *
+ mlx5_eswitch_add_offloaded_rule(struct mlx5_eswitch *esw,
+ 				struct mlx5_flow_spec *spec,
+ 				struct mlx5_esw_flow_attr *attr);
+ struct mlx5_flow_handle *
+ mlx5_eswitch_create_vport_rx_rule(struct mlx5_eswitch *esw, int vport, u32 tirn);
+ 
+ enum {
+ 	SET_VLAN_STRIP	= BIT(0),
+ 	SET_VLAN_INSERT	= BIT(1)
+ };
+ 
+ #define MLX5_FLOW_CONTEXT_ACTION_VLAN_POP  0x40
+ #define MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH 0x80
+ 
+ struct mlx5_encap_info {
+ 	__be32 daddr;
+ 	__be32 tun_id;
+ 	__be16 tp_dst;
+ };
+ 
+ struct mlx5_encap_entry {
+ 	struct hlist_node encap_hlist;
+ 	struct list_head flows;
+ 	u32 encap_id;
+ 	struct neighbour *n;
+ 	struct mlx5_encap_info tun_info;
+ 	unsigned char h_dest[ETH_ALEN];	/* destination eth addr	*/
+ 
+ 	struct net_device *out_dev;
+ 	int tunnel_type;
+ };
+ 
+ struct mlx5_esw_flow_attr {
+ 	struct mlx5_eswitch_rep *in_rep;
+ 	struct mlx5_eswitch_rep *out_rep;
+ 
+ 	int	action;
+ 	u16	vlan;
+ 	bool	vlan_handled;
+ 	struct mlx5_encap_entry *encap;
+ };
+ 
+ int mlx5_eswitch_sqs2vport_start(struct mlx5_eswitch *esw,
+ 				 struct mlx5_eswitch_rep *rep,
+ 				 u16 *sqns_array, int sqns_num);
+ void mlx5_eswitch_sqs2vport_stop(struct mlx5_eswitch *esw,
+ 				 struct mlx5_eswitch_rep *rep);
+ 
+ int mlx5_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode);
+ int mlx5_devlink_eswitch_mode_get(struct devlink *devlink, u16 *mode);
+ int mlx5_devlink_eswitch_inline_mode_set(struct devlink *devlink, u8 mode);
+ int mlx5_devlink_eswitch_inline_mode_get(struct devlink *devlink, u8 *mode);
+ int mlx5_eswitch_inline_mode_get(struct mlx5_eswitch *esw, int nvfs, u8 *mode);
+ void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
+ 				     int vport_index,
+ 				     struct mlx5_eswitch_rep *rep);
+ void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
+ 				       int vport_index);
+ struct net_device *mlx5_eswitch_get_uplink_netdev(struct mlx5_eswitch *esw);
+ 
+ int mlx5_eswitch_add_vlan_action(struct mlx5_eswitch *esw,
+ 				 struct mlx5_esw_flow_attr *attr);
+ int mlx5_eswitch_del_vlan_action(struct mlx5_eswitch *esw,
+ 				 struct mlx5_esw_flow_attr *attr);
+ int __mlx5_eswitch_set_vport_vlan(struct mlx5_eswitch *esw,
+ 				  int vport, u16 vlan, u8 qos, u8 set_flags);
+ 
+ #define MLX5_DEBUG_ESWITCH_MASK BIT(3)
+ 
+ #define esw_info(dev, format, ...)				\
+ 	pr_info("(%s): E-Switch: " format, (dev)->priv.name, ##__VA_ARGS__)
+ 
+ #define esw_warn(dev, format, ...)				\
+ 	pr_warn("(%s): E-Switch: " format, (dev)->priv.name, ##__VA_ARGS__)
+ 
+ #define esw_debug(dev, format, ...)				\
+ 	mlx5_core_dbg_mask(dev, MLX5_DEBUG_ESWITCH_MASK, format, ##__VA_ARGS__)
++>>>>>>> 726293f1f851 (net/mlx5e: Save the represntor netdevice as part of the representor)
  #endif /* __MLX5_ESWITCH_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
