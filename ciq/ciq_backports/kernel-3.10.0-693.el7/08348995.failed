netronome: don't access real_num_rx_queues directly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Arnd Bergmann <arnd@arndb.de>
commit 08348995c47ec0e6ad3712c08eb88fb4df2e8180
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/08348995.failed

The netdev->real_num_rx_queues setting is only available if CONFIG_SYSFS
is enabled, so we now get a build failure when that is turned off:

netronome/nfp/nfp_net_common.c: In function 'nfp_net_ring_swap_enable':
netronome/nfp/nfp_net_common.c:2489:18: error: 'struct net_device' has no member named 'real_num_rx_queues'; did you mean 'real_num_tx_queues'?

As far as I can tell, the check here is only used as an optimization that
we can skip in order to fix the compilation. If sysfs is disabled,
the following netif_set_real_num_rx_queues() has no effect.

Fixes: 164d1e9e5d52 ("nfp: add support for ethtool .set_channels")
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 08348995c47ec0e6ad3712c08eb88fb4df2e8180)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 2a625a67a222,eb3715700c95..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -2207,15 -2455,68 +2207,61 @@@ static void nfp_net_set_rx_mode(struct 
  	nn->ctrl = new_ctrl;
  }
  
 -static void nfp_net_rss_init_itbl(struct nfp_net *nn)
 -{
 -	int i;
 -
 -	for (i = 0; i < sizeof(nn->rss_itbl); i++)
 -		nn->rss_itbl[i] =
 -			ethtool_rxfh_indir_default(i, nn->num_rx_rings);
 -}
 -
 -static int
 -nfp_net_ring_swap_enable(struct nfp_net *nn, unsigned int *num_vecs,
 -			 unsigned int *stack_tx_rings,
 -			 struct bpf_prog **xdp_prog,
 -			 struct nfp_net_ring_set *rx,
 -			 struct nfp_net_ring_set *tx)
 +static int nfp_net_change_mtu(struct net_device *netdev, int new_mtu)
  {
 -	unsigned int r;
 +	unsigned int old_mtu, old_fl_bufsz, new_fl_bufsz;
 +	struct nfp_net *nn = netdev_priv(netdev);
 +	struct nfp_net_rx_ring *tmp_rings;
  	int err;
  
++<<<<<<< HEAD
 +	if (new_mtu < 68 || new_mtu > nn->max_mtu) {
 +		nn_err(nn, "New MTU (%d) is not valid\n", new_mtu);
++=======
+ 	if (rx)
+ 		nfp_net_rx_ring_set_swap(nn, rx);
+ 	if (tx)
+ 		nfp_net_tx_ring_set_swap(nn, tx);
+ 
+ 	swap(*num_vecs, nn->num_r_vecs);
+ 	swap(*stack_tx_rings, nn->num_stack_tx_rings);
+ 	*xdp_prog = xchg(&nn->xdp_prog, *xdp_prog);
+ 
+ 	for (r = 0; r <	nn->max_r_vecs; r++)
+ 		nfp_net_vector_assign_rings(nn, &nn->r_vecs[r], r);
+ 
+ 	if (!netif_is_rxfh_configured(nn->netdev))
+ 		nfp_net_rss_init_itbl(nn);
+ 
+ 	err = netif_set_real_num_rx_queues(nn->netdev,
+ 					   nn->num_rx_rings);
+ 	if (err)
+ 		return err;
+ 
+ 	if (nn->netdev->real_num_tx_queues != nn->num_stack_tx_rings) {
+ 		err = netif_set_real_num_tx_queues(nn->netdev,
+ 						   nn->num_stack_tx_rings);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return __nfp_net_set_config_and_enable(nn);
+ }
+ 
+ static int
+ nfp_net_check_config(struct nfp_net *nn, struct bpf_prog *xdp_prog,
+ 		     struct nfp_net_ring_set *rx, struct nfp_net_ring_set *tx)
+ {
+ 	/* XDP-enabled tests */
+ 	if (!xdp_prog)
+ 		return 0;
+ 	if (rx && nfp_net_calc_fl_bufsz(nn, rx->mtu) > PAGE_SIZE) {
+ 		nn_warn(nn, "MTU too large w/ XDP enabled\n");
+ 		return -EINVAL;
+ 	}
+ 	if (tx && tx->n_rings > nn->max_tx_rings) {
+ 		nn_warn(nn, "Insufficient number of TX rings w/ XDP enabled\n");
++>>>>>>> 08348995c47e (netronome: don't access real_num_rx_queues directly)
  		return -EINVAL;
  	}
  
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
