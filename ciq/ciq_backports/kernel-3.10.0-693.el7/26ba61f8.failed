HID: wacom: fix an Oops caused by wacom_wac_finger_count_touches

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: fix an Oops caused by wacom_wac_finger_count_touches (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.93%
commit-author Ping Cheng <pinglinux@gmail.com>
commit 26ba61f871b4aa9958bcebffcbeb558094d75928
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/26ba61f8.failed

We assumed all touch interfaces report touch data. But, Bamboo
and Intuos non-touch devices report express keys on touch
interface. We need to check touch_max before counting touches.

	Reported-by: Tasos Sahanidis <tasos@tasossah.com>
	Signed-off-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 26ba61f871b4aa9958bcebffcbeb558094d75928)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index bc916ccd4c20,adf959dcfa5d..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -853,6 -1019,77 +853,80 @@@ static int int_dist(int x1, int y1, in
  	return int_sqrt(x*x + y*y);
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_intuos_bt_process_data(struct wacom_wac *wacom,
+ 		unsigned char *data)
+ {
+ 	memcpy(wacom->data, data, 10);
+ 	wacom_intuos_irq(wacom);
+ 
+ 	input_sync(wacom->input);
+ 	if (wacom->pad_input)
+ 		input_sync(wacom->pad_input);
+ }
+ 
+ static int wacom_intuos_bt_irq(struct wacom_wac *wacom, size_t len)
+ {
+ 	unsigned char data[WACOM_PKGLEN_MAX];
+ 	int i = 1;
+ 	unsigned power_raw, battery_capacity, bat_charging, ps_connected;
+ 
+ 	memcpy(data, wacom->data, len);
+ 
+ 	switch (data[0]) {
+ 	case 0x04:
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		/* fall through */
+ 	case 0x03:
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		power_raw = data[i];
+ 		bat_charging = (power_raw & 0x08) ? 1 : 0;
+ 		ps_connected = (power_raw & 0x10) ? 1 : 0;
+ 		battery_capacity = batcap_i4[power_raw & 0x07];
+ 		wacom_notify_battery(wacom, battery_capacity, bat_charging,
+ 				     battery_capacity || bat_charging,
+ 				     ps_connected);
+ 		break;
+ 	default:
+ 		dev_dbg(wacom->input->dev.parent,
+ 				"Unknown report: %d,%d size:%zu\n",
+ 				data[0], data[1], len);
+ 		return 0;
+ 	}
+ 	return 0;
+ }
+ 
+ static int wacom_wac_finger_count_touches(struct wacom_wac *wacom)
+ {
+ 	struct input_dev *input = wacom->input;
+ 	unsigned touch_max = wacom->features.touch_max;
+ 	int count = 0;
+ 	int i;
+ 
+ 	if (!touch_max)
+ 		return 0;
+ 
+ 	/* non-HID_GENERIC single touch input doesn't call this routine */
+ 	if ((touch_max == 1) && (wacom->features.type == HID_GENERIC))
+ 		return wacom->hid_data.tipswitch &&
+ 		       !wacom->shared->stylus_in_proximity;
+ 
+ 	for (i = 0; i < input->mt->num_slots; i++) {
+ 		struct input_mt_slot *ps = &input->mt->slots[i];
+ 		int id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);
+ 		if (id >= 0)
+ 			count++;
+ 	}
+ 
+ 	return count;
+ }
+ 
++>>>>>>> 26ba61f871b4 (HID: wacom: fix an Oops caused by wacom_wac_finger_count_touches)
  static int wacom_24hdt_irq(struct wacom_wac *wacom)
  {
  	struct input_dev *input = wacom->input;
* Unmerged path drivers/hid/wacom_wac.c
