PM / sleep: prohibit devices probing during suspend/hibernation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Strashko, Grygorii <grygorii.strashko@ti.com>
commit 013c074f8642d8e815ad670601f8e27155a74b57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/013c074f.failed

It is unsafe [1] if probing of devices will happen during suspend or
hibernation and system behavior will be unpredictable in this case.
So, let's prohibit device's probing in dpm_prepare() and defer their
probing instead. The normal behavior will be restored in
dpm_complete().

This patch introduces new DD core APIs:
 device_block_probing()
   It will disable probing of devices and defer their probes instead.
 device_unblock_probing()
   It will restore normal behavior and trigger re-probing of deferred
   devices.

[1] https://lkml.org/lkml/2015/9/11/554

	Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
	Acked-by: Pavel Machek <pavel@ucw.cz>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 013c074f8642d8e815ad670601f8e27155a74b57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/dd.c
#	drivers/base/power/main.c
diff --cc drivers/base/dd.c
index 1e8ed1dd4c00,b605f734b882..000000000000
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@@ -54,7 -54,14 +54,18 @@@ static LIST_HEAD(deferred_probe_active_
  static struct workqueue_struct *deferred_wq;
  static atomic_t deferred_trigger_count = ATOMIC_INIT(0);
  
++<<<<<<< HEAD
 +/**
++=======
+ /*
+  * In some cases, like suspend to RAM or hibernation, It might be reasonable
+  * to prohibit probing of devices as it could be unsafe.
+  * Once defer_all_probes is true all drivers probes will be forcibly deferred.
+  */
+ static bool defer_all_probes;
+ 
+ /*
++>>>>>>> 013c074f8642 (PM / sleep: prohibit devices probing during suspend/hibernation)
   * deferred_probe_work_func() - Retry probing devices in the active list.
   */
  static void deferred_probe_work_func(struct work_struct *work)
diff --cc drivers/base/power/main.c
index a37dac9fb45c,9d626ac08d9c..000000000000
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@@ -792,6 -963,10 +792,13 @@@ void dpm_complete(pm_message_t state
  	}
  	list_splice(&list, &dpm_list);
  	mutex_unlock(&dpm_list_mtx);
++<<<<<<< HEAD
++=======
+ 
+ 	/* Allow device probing and trigger re-probing of deferred devices */
+ 	device_unblock_probing();
+ 	trace_suspend_resume(TPS("dpm_complete"), state.event, false);
++>>>>>>> 013c074f8642 (PM / sleep: prohibit devices probing during suspend/hibernation)
  }
  
  /**
@@@ -1286,8 -1624,23 +1293,22 @@@ int dpm_prepare(pm_message_t state
  {
  	int error = 0;
  
 -	trace_suspend_resume(TPS("dpm_prepare"), state.event, true);
  	might_sleep();
  
+ 	/*
+ 	 * Give a chance for the known devices to complete their probes, before
+ 	 * disable probing of devices. This sync point is important at least
+ 	 * at boot time + hibernation restore.
+ 	 */
+ 	wait_for_device_probe();
+ 	/*
+ 	 * It is unsafe if probing of devices will happen during suspend or
+ 	 * hibernation and system behavior will be unpredictable in this case.
+ 	 * So, let's prohibit device's probing here and defer their probes
+ 	 * instead. The normal behavior will be restored in dpm_complete().
+ 	 */
+ 	device_block_probing();
+ 
  	mutex_lock(&dpm_list_mtx);
  	while (!list_empty(&dpm_list)) {
  		struct device *dev = to_device(dpm_list.next);
diff --git a/drivers/base/base.h b/drivers/base/base.h
index 24f424249d9b..f0e534303b76 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -133,6 +133,8 @@ extern void device_remove_groups(struct device *dev,
 extern char *make_class_name(const char *name, struct kobject *kobj);
 
 extern int devres_release_all(struct device *dev);
+extern void device_block_probing(void);
+extern void device_unblock_probing(void);
 
 /* /sys/devices directory */
 extern struct kset *devices_kset;
* Unmerged path drivers/base/dd.c
* Unmerged path drivers/base/power/main.c
