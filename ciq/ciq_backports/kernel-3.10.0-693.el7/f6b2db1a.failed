userns: Make the count of user namespaces per user

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit f6b2db1a3e8d141dd144df58900fb0444d5d7c53
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f6b2db1a.failed

Add a structure that is per user and per user ns and use it to hold
the count of user namespaces.  This makes prevents one user from
creating denying service to another user by creating the maximum
number of user namespaces.

Rename the sysctl export of the maximum count from
/proc/sys/userns/max_user_namespaces to /proc/sys/user/max_user_namespaces
to reflect that the count is now per user.

	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit f6b2db1a3e8d141dd144df58900fb0444d5d7c53)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/user_namespace.h
#	kernel/fork.c
#	kernel/ucount.c
#	kernel/user_namespace.c
diff --cc include/linux/user_namespace.h
index 9b176275291d,826de7a12a20..000000000000
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@@ -39,11 -40,29 +40,37 @@@ struct user_namespace 
  	struct key		*persistent_keyring_register;
  	struct rw_semaphore	persistent_keyring_register_sem;
  #endif
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(int level)
 +	RH_KABI_EXTEND(unsigned long flags)
 +};
 +
 +extern struct user_namespace init_user_ns;
++=======
+ 	struct work_struct	work;
+ #ifdef CONFIG_SYSCTL
+ 	struct ctl_table_set	set;
+ 	struct ctl_table_header *sysctls;
+ #endif
+ 	struct ucounts		*ucounts;
+ 	int max_user_namespaces;
+ };
+ 
+ struct ucounts {
+ 	struct hlist_node node;
+ 	struct user_namespace *ns;
+ 	kuid_t uid;
+ 	atomic_t count;
+ 	atomic_t user_namespaces;
+ };
+ 
+ extern struct user_namespace init_user_ns;
+ 
+ bool setup_userns_sysctls(struct user_namespace *ns);
+ void retire_userns_sysctls(struct user_namespace *ns);
+ struct ucounts *inc_user_namespaces(struct user_namespace *ns, kuid_t uid);
+ void dec_user_namespaces(struct ucounts *ucounts);
++>>>>>>> f6b2db1a3e8d (userns: Make the count of user namespaces per user)
  
  #ifdef CONFIG_USER_NS
  
diff --cc kernel/fork.c
index 4d1b25f88335,d8cde533ace3..000000000000
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@@ -309,9 -321,11 +309,14 @@@ void __init fork_init(unsigned long mem
  	init_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;
  	init_task.signal->rlim[RLIMIT_SIGPENDING] =
  		init_task.signal->rlim[RLIMIT_NPROC];
++<<<<<<< HEAD
++=======
+ 
+ 	init_user_ns.max_user_namespaces = max_threads/2;
++>>>>>>> f6b2db1a3e8d (userns: Make the count of user namespaces per user)
  }
  
 -int __weak arch_dup_task_struct(struct task_struct *dst,
 +int __attribute__((weak)) arch_dup_task_struct(struct task_struct *dst,
  					       struct task_struct *src)
  {
  	*dst = *src;
diff --cc kernel/user_namespace.c
index 57f036cb8f03,58c67e5f851c..000000000000
--- a/kernel/user_namespace.c
+++ b/kernel/user_namespace.c
@@@ -30,6 -29,7 +30,10 @@@ static DEFINE_MUTEX(userns_state_mutex)
  static bool new_idmap_permitted(const struct file *file,
  				struct user_namespace *ns, int cap_setid,
  				struct uid_gid_map *map);
++<<<<<<< HEAD
++=======
+ static void free_user_ns(struct work_struct *work);
++>>>>>>> f6b2db1a3e8d (userns: Make the count of user namespaces per user)
  
  static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)
  {
@@@ -68,17 -63,16 +72,26 @@@ int create_user_ns(struct cred *new
  	struct user_namespace *ns, *parent_ns = new->user_ns;
  	kuid_t owner = new->euid;
  	kgid_t group = new->egid;
+ 	struct ucounts *ucounts;
  	int ret;
 +	static int __read_mostly called_mark_tech_preview = 0;
 +
 +	if (!enable_user_ns_creation)
 +		return -EINVAL;
 +
 +	if (!called_mark_tech_preview && !xchg(&called_mark_tech_preview, 1))
 +		mark_tech_preview("user namespace", NULL);
  
 -	ret = -EUSERS;
  	if (parent_ns->level > 32)
++<<<<<<< HEAD
 +		return -EUSERS;
++=======
+ 		goto fail;
+ 
+ 	ucounts = inc_user_namespaces(parent_ns, owner);
+ 	if (!ucounts)
+ 		goto fail;
++>>>>>>> f6b2db1a3e8d (userns: Make the count of user namespaces per user)
  
  	/*
  	 * Verify that we can not violate the policy of which files
@@@ -113,6 -109,9 +126,12 @@@
  	ns->level = parent_ns->level + 1;
  	ns->owner = owner;
  	ns->group = group;
++<<<<<<< HEAD
++=======
+ 	INIT_WORK(&ns->work, free_user_ns);
+ 	ns->max_user_namespaces = INT_MAX;
+ 	ns->ucounts = ucounts;
++>>>>>>> f6b2db1a3e8d (userns: Make the count of user namespaces per user)
  
  	/* Inherit USERNS_SETGROUPS_ALLOWED from our parent */
  	mutex_lock(&userns_state_mutex);
@@@ -126,7 -121,23 +145,21 @@@
  #ifdef CONFIG_PERSISTENT_KEYRINGS
  	init_rwsem(&ns->persistent_keyring_register_sem);
  #endif
 -	ret = -ENOMEM;
 -	if (!setup_userns_sysctls(ns))
 -		goto fail_keyring;
 -
 -	set_cred_user_ns(new, ns);
  	return 0;
++<<<<<<< HEAD
++=======
+ fail_keyring:
+ #ifdef CONFIG_PERSISTENT_KEYRINGS
+ 	key_put(ns->persistent_keyring_register);
+ #endif
+ 	ns_free_inum(&ns->ns);
+ fail_free:
+ 	kmem_cache_free(user_ns_cachep, ns);
+ fail_dec:
+ 	dec_user_namespaces(ucounts);
+ fail:
+ 	return ret;
++>>>>>>> f6b2db1a3e8d (userns: Make the count of user namespaces per user)
  }
  
  int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)
@@@ -149,17 -160,21 +182,22 @@@
  	return err;
  }
  
 -static void free_user_ns(struct work_struct *work)
 +void free_user_ns(struct user_namespace *ns)
  {
 -	struct user_namespace *parent, *ns =
 -		container_of(work, struct user_namespace, work);
 +	struct user_namespace *parent;
  
  	do {
+ 		struct ucounts *ucounts = ns->ucounts;
  		parent = ns->parent;
 -		retire_userns_sysctls(ns);
  #ifdef CONFIG_PERSISTENT_KEYRINGS
  		key_put(ns->persistent_keyring_register);
  #endif
 -		ns_free_inum(&ns->ns);
 +		proc_free_inum(ns->proc_inum);
  		kmem_cache_free(user_ns_cachep, ns);
++<<<<<<< HEAD
++=======
+ 		dec_user_namespaces(ucounts);
++>>>>>>> f6b2db1a3e8d (userns: Make the count of user namespaces per user)
  		ns = parent;
  	} while (atomic_dec_and_test(&parent->count));
  }
* Unmerged path kernel/ucount.c
* Unmerged path include/linux/user_namespace.h
* Unmerged path kernel/fork.c
* Unmerged path kernel/ucount.c
* Unmerged path kernel/user_namespace.c
