ipv6: introduce neighbour discovery ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alexander Aring <aar@pengutronix.de>
commit f997c55c1dc8841b3ee4df0493d0ac7966d42165
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f997c55c.failed

This patch introduces neighbour discovery ops callback structure. The
idea is to separate the handling for 6LoWPAN into the 6lowpan module.

These callback offers 6lowpan different handling, such as 802.15.4 short
address handling or RFC6775 (Neighbor Discovery Optimization for IPv6
over 6LoWPANs).

	Cc: David S. Miller <davem@davemloft.net>
	Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
	Cc: James Morris <jmorris@namei.org>
	Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
	Cc: Patrick McHardy <kaber@trash.net>
	Acked-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
	Signed-off-by: Alexander Aring <aar@pengutronix.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f997c55c1dc8841b3ee4df0493d0ac7966d42165)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	include/net/ndisc.h
#	net/ipv6/addrconf.c
#	net/ipv6/ndisc.c
diff --cc include/linux/netdevice.h
index 2f7ec2ad350a,890158e99159..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -1451,11 -1390,216 +1451,222 @@@ enum netdev_priv_flags 
  #define IFF_RXFH_CONFIGURED		IFF_RXFH_CONFIGURED
  #define IFF_MACSEC			IFF_MACSEC
  
++<<<<<<< HEAD
 +/*
 + *	The DEVICE structure.
 + *	Actually, this whole structure is a big mistake.  It mixes I/O
 + *	data with strictly "high-level" data, and it has to know about
 + *	almost every data structure used in the INET module.
++=======
+ /**
+  *	struct net_device - The DEVICE structure.
+  *		Actually, this whole structure is a big mistake.  It mixes I/O
+  *		data with strictly "high-level" data, and it has to know about
+  *		almost every data structure used in the INET module.
+  *
+  *	@name:	This is the first field of the "visible" part of this structure
+  *		(i.e. as seen by users in the "Space.c" file).  It is the name
+  *	 	of the interface.
+  *
+  *	@name_hlist: 	Device name hash chain, please keep it close to name[]
+  *	@ifalias:	SNMP alias
+  *	@mem_end:	Shared memory end
+  *	@mem_start:	Shared memory start
+  *	@base_addr:	Device I/O address
+  *	@irq:		Device IRQ number
+  *
+  *	@carrier_changes:	Stats to monitor carrier on<->off transitions
+  *
+  *	@state:		Generic network queuing layer state, see netdev_state_t
+  *	@dev_list:	The global list of network devices
+  *	@napi_list:	List entry used for polling NAPI devices
+  *	@unreg_list:	List entry  when we are unregistering the
+  *			device; see the function unregister_netdev
+  *	@close_list:	List entry used when we are closing the device
+  *	@ptype_all:     Device-specific packet handlers for all protocols
+  *	@ptype_specific: Device-specific, protocol-specific packet handlers
+  *
+  *	@adj_list:	Directly linked devices, like slaves for bonding
+  *	@all_adj_list:	All linked devices, *including* neighbours
+  *	@features:	Currently active device features
+  *	@hw_features:	User-changeable features
+  *
+  *	@wanted_features:	User-requested features
+  *	@vlan_features:		Mask of features inheritable by VLAN devices
+  *
+  *	@hw_enc_features:	Mask of features inherited by encapsulating devices
+  *				This field indicates what encapsulation
+  *				offloads the hardware is capable of doing,
+  *				and drivers will need to set them appropriately.
+  *
+  *	@mpls_features:	Mask of features inheritable by MPLS
+  *
+  *	@ifindex:	interface index
+  *	@group:		The group the device belongs to
+  *
+  *	@stats:		Statistics struct, which was left as a legacy, use
+  *			rtnl_link_stats64 instead
+  *
+  *	@rx_dropped:	Dropped packets by core network,
+  *			do not use this in drivers
+  *	@tx_dropped:	Dropped packets by core network,
+  *			do not use this in drivers
+  *	@rx_nohandler:	nohandler dropped packets by core network on
+  *			inactive devices, do not use this in drivers
+  *
+  *	@wireless_handlers:	List of functions to handle Wireless Extensions,
+  *				instead of ioctl,
+  *				see <net/iw_handler.h> for details.
+  *	@wireless_data:	Instance data managed by the core of wireless extensions
+  *
+  *	@netdev_ops:	Includes several pointers to callbacks,
+  *			if one wants to override the ndo_*() functions
+  *	@ethtool_ops:	Management operations
+  *	@ndisc_ops:	Includes callbacks for different IPv6 neighbour
+  *			discovery handling. Necessary for e.g. 6LoWPAN.
+  *	@header_ops:	Includes callbacks for creating,parsing,caching,etc
+  *			of Layer 2 headers.
+  *
+  *	@flags:		Interface flags (a la BSD)
+  *	@priv_flags:	Like 'flags' but invisible to userspace,
+  *			see if.h for the definitions
+  *	@gflags:	Global flags ( kept as legacy )
+  *	@padded:	How much padding added by alloc_netdev()
+  *	@operstate:	RFC2863 operstate
+  *	@link_mode:	Mapping policy to operstate
+  *	@if_port:	Selectable AUI, TP, ...
+  *	@dma:		DMA channel
+  *	@mtu:		Interface MTU value
+  *	@type:		Interface hardware type
+  *	@hard_header_len: Maximum hardware header length.
+  *
+  *	@needed_headroom: Extra headroom the hardware may need, but not in all
+  *			  cases can this be guaranteed
+  *	@needed_tailroom: Extra tailroom the hardware may need, but not in all
+  *			  cases can this be guaranteed. Some cases also use
+  *			  LL_MAX_HEADER instead to allocate the skb
+  *
+  *	interface address info:
+  *
+  * 	@perm_addr:		Permanent hw address
+  * 	@addr_assign_type:	Hw address assignment type
+  * 	@addr_len:		Hardware address length
+  *	@neigh_priv_len:	Used in neigh_alloc()
+  * 	@dev_id:		Used to differentiate devices that share
+  * 				the same link layer address
+  * 	@dev_port:		Used to differentiate devices that share
+  * 				the same function
+  *	@addr_list_lock:	XXX: need comments on this one
+  *	@uc_promisc:		Counter that indicates promiscuous mode
+  *				has been enabled due to the need to listen to
+  *				additional unicast addresses in a device that
+  *				does not implement ndo_set_rx_mode()
+  *	@uc:			unicast mac addresses
+  *	@mc:			multicast mac addresses
+  *	@dev_addrs:		list of device hw addresses
+  *	@queues_kset:		Group of all Kobjects in the Tx and RX queues
+  *	@promiscuity:		Number of times the NIC is told to work in
+  *				promiscuous mode; if it becomes 0 the NIC will
+  *				exit promiscuous mode
+  *	@allmulti:		Counter, enables or disables allmulticast mode
+  *
+  *	@vlan_info:	VLAN info
+  *	@dsa_ptr:	dsa specific data
+  *	@tipc_ptr:	TIPC specific data
+  *	@atalk_ptr:	AppleTalk link
+  *	@ip_ptr:	IPv4 specific data
+  *	@dn_ptr:	DECnet specific data
+  *	@ip6_ptr:	IPv6 specific data
+  *	@ax25_ptr:	AX.25 specific data
+  *	@ieee80211_ptr:	IEEE 802.11 specific data, assign before registering
+  *
+  *	@last_rx:	Time of last Rx
+  *	@dev_addr:	Hw address (before bcast,
+  *			because most packets are unicast)
+  *
+  *	@_rx:			Array of RX queues
+  *	@num_rx_queues:		Number of RX queues
+  *				allocated at register_netdev() time
+  *	@real_num_rx_queues: 	Number of RX queues currently active in device
+  *
+  *	@rx_handler:		handler for received packets
+  *	@rx_handler_data: 	XXX: need comments on this one
+  *	@ingress_queue:		XXX: need comments on this one
+  *	@broadcast:		hw bcast address
+  *
+  *	@rx_cpu_rmap:	CPU reverse-mapping for RX completion interrupts,
+  *			indexed by RX queue number. Assigned by driver.
+  *			This must only be set if the ndo_rx_flow_steer
+  *			operation is defined
+  *	@index_hlist:		Device index hash chain
+  *
+  *	@_tx:			Array of TX queues
+  *	@num_tx_queues:		Number of TX queues allocated at alloc_netdev_mq() time
+  *	@real_num_tx_queues: 	Number of TX queues currently active in device
+  *	@qdisc:			Root qdisc from userspace point of view
+  *	@tx_queue_len:		Max frames per queue allowed
+  *	@tx_global_lock: 	XXX: need comments on this one
+  *
+  *	@xps_maps:	XXX: need comments on this one
+  *
+  *	@offload_fwd_mark:	Offload device fwding mark
+  *
+  *	@watchdog_timeo:	Represents the timeout that is used by
+  *				the watchdog (see dev_watchdog())
+  *	@watchdog_timer:	List of timers
+  *
+  *	@pcpu_refcnt:		Number of references to this device
+  *	@todo_list:		Delayed register/unregister
+  *	@link_watch_list:	XXX: need comments on this one
+  *
+  *	@reg_state:		Register/unregister state machine
+  *	@dismantle:		Device is going to be freed
+  *	@rtnl_link_state:	This enum represents the phases of creating
+  *				a new link
+  *
+  *	@destructor:		Called from unregister,
+  *				can be used to call free_netdev
+  *	@npinfo:		XXX: need comments on this one
+  * 	@nd_net:		Network namespace this network device is inside
+  *
+  * 	@ml_priv:	Mid-layer private
+  * 	@lstats:	Loopback statistics
+  * 	@tstats:	Tunnel statistics
+  * 	@dstats:	Dummy statistics
+  * 	@vstats:	Virtual ethernet statistics
+  *
+  *	@garp_port:	GARP
+  *	@mrp_port:	MRP
+  *
+  *	@dev:		Class/net/name entry
+  *	@sysfs_groups:	Space for optional device, statistics and wireless
+  *			sysfs groups
+  *
+  *	@sysfs_rx_queue_group:	Space for optional per-rx queue attributes
+  *	@rtnl_link_ops:	Rtnl_link_ops
+  *
+  *	@gso_max_size:	Maximum size of generic segmentation offload
+  *	@gso_max_segs:	Maximum number of segments that can be passed to the
+  *			NIC for GSO
+  *
+  *	@dcbnl_ops:	Data Center Bridging netlink ops
+  *	@num_tc:	Number of traffic classes in the net device
+  *	@tc_to_txq:	XXX: need comments on this one
+  *	@prio_tc_map	XXX: need comments on this one
+  *
+  *	@fcoe_ddp_xid:	Max exchange id for FCoE LRO by ddp
+  *
+  *	@priomap:	XXX: need comments on this one
+  *	@phydev:	Physical device may attach itself
+  *			for hardware timestamping
+  *
+  *	@qdisc_tx_busylock: lockdep class annotating Qdisc->busylock spinlock
+  *	@qdisc_running_key: lockdep class annotating Qdisc->running seqcount
+  *
+  *	@proto_down:	protocol port state information can be sent to the
+  *			switch driver and used to set the phys state of the
+  *			switch port.
++>>>>>>> f997c55c1dc8 (ipv6: introduce neighbour discovery ops)
   *
   *	FIXME: cleanup struct net_device such that network protocol info
   *	moves out.
@@@ -1495,69 -1631,71 +1706,81 @@@ struct net_device 
  	struct list_head	dev_list;
  	struct list_head	napi_list;
  	struct list_head	unreg_list;
 -	struct list_head	close_list;
 -	struct list_head	ptype_all;
 -	struct list_head	ptype_specific;
 +	struct list_head	upper_dev_list; /* List of upper devices */
  
 -	struct {
 -		struct list_head upper;
 -		struct list_head lower;
 -	} adj_list;
 -
 -	struct {
 -		struct list_head upper;
 -		struct list_head lower;
 -	} all_adj_list;
  
 +	/* currently active device features */
  	netdev_features_t	features;
 +	/* user-changeable features */
  	netdev_features_t	hw_features;
 +	/* user-requested features */
  	netdev_features_t	wanted_features;
 +	/* mask of features inheritable by VLAN devices */
  	netdev_features_t	vlan_features;
 +	/* mask of features inherited by encapsulating devices
 +	 * This field indicates what encapsulation offloads
 +	 * the hardware is capable of doing, and drivers will
 +	 * need to set them appropriately.
 +	 */
  	netdev_features_t	hw_enc_features;
 +	/* mask of fetures inheritable by MPLS */
  	netdev_features_t	mpls_features;
 -	netdev_features_t	gso_partial_features;
  
 +	/* Interface index. Unique device identifier	*/
  	int			ifindex;
 -	int			group;
 +	int			iflink;
  
  	struct net_device_stats	stats;
 -
 -	atomic_long_t		rx_dropped;
 -	atomic_long_t		tx_dropped;
 -	atomic_long_t		rx_nohandler;
 +	atomic_long_t		rx_dropped; /* dropped packets by core network
 +					     * Do not use this in drivers.
 +					     */
  
  #ifdef CONFIG_WIRELESS_EXT
 -	const struct iw_handler_def *wireless_handlers;
 -	struct iw_public_data	*wireless_data;
 +	/* List of functions to handle Wireless Extensions (instead of ioctl).
 +	 * See <net/iw_handler.h> for details. Jean II */
 +	const struct iw_handler_def *	wireless_handlers;
 +	/* Instance data managed by the core of Wireless Extensions. */
 +	struct iw_public_data *	wireless_data;
  #endif
 +	/* Management operations */
  	const struct net_device_ops *netdev_ops;
  	const struct ethtool_ops *ethtool_ops;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NET_SWITCHDEV
+ 	const struct switchdev_ops *switchdev_ops;
+ #endif
+ #ifdef CONFIG_NET_L3_MASTER_DEV
+ 	const struct l3mdev_ops	*l3mdev_ops;
+ #endif
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	const struct ndisc_ops *ndisc_ops;
+ #endif
++>>>>>>> f997c55c1dc8 (ipv6: introduce neighbour discovery ops)
  
 +	/* Hardware header description */
  	const struct header_ops *header_ops;
  
 -	unsigned int		flags;
 -	unsigned int		priv_flags;
 -
 +	unsigned int		flags;	/* interface flags (a la BSD)	*/
 +	unsigned int		priv_flags; /* Like 'flags' but invisible to userspace.
 +					     * See if.h for definitions. */
  	unsigned short		gflags;
 -	unsigned short		padded;
 +	unsigned short		padded;	/* How much padding added by alloc_netdev() */
  
 -	unsigned char		operstate;
 -	unsigned char		link_mode;
 +	unsigned char		operstate; /* RFC2863 operstate */
 +	unsigned char		link_mode; /* mapping policy to operstate */
  
 -	unsigned char		if_port;
 -	unsigned char		dma;
 +	unsigned char		if_port;	/* Selectable AUI, TP,..*/
 +	unsigned char		dma;		/* DMA channel		*/
  
 -	unsigned int		mtu;
 -	unsigned short		type;
 -	unsigned short		hard_header_len;
 +	unsigned int		mtu;	/* interface MTU value		*/
 +	unsigned short		type;	/* interface hardware type	*/
 +	unsigned short		hard_header_len;	/* hardware hdr length	*/
  
 +	/* extra head- and tailroom the hardware may need, but not in all cases
 +	 * can this be guaranteed, especially tailroom. Some cases also use
 +	 * LL_MAX_HEADER instead to allocate the skb.
 +	 */
  	unsigned short		needed_headroom;
  	unsigned short		needed_tailroom;
  
diff --cc include/net/ndisc.h
index 4a7a80f7a6d2,a5e276703cb3..000000000000
--- a/include/net/ndisc.h
+++ b/include/net/ndisc.h
@@@ -110,8 -111,181 +111,186 @@@ struct ndisc_options 
  
  #define NDISC_OPT_SPACE(len) (((len)+2+7)&~7)
  
++<<<<<<< HEAD
 +extern struct ndisc_options *ndisc_parse_options(u8 *opt, int opt_len,
 +						 struct ndisc_options *ndopts);
++=======
+ struct ndisc_options *ndisc_parse_options(const struct net_device *dev,
+ 					  u8 *opt, int opt_len,
+ 					  struct ndisc_options *ndopts);
++>>>>>>> f997c55c1dc8 (ipv6: introduce neighbour discovery ops)
+ 
+ #define NDISC_OPS_REDIRECT_DATA_SPACE	2
+ 
+ /*
+  * This structure defines the hooks for IPv6 neighbour discovery.
+  * The following hooks can be defined; unless noted otherwise, they are
+  * optional and can be filled with a null pointer.
+  *
+  * int (*is_useropt)(u8 nd_opt_type):
+  *     This function is called when IPv6 decide RA userspace options. if
+  *     this function returns 1 then the option given by nd_opt_type will
+  *     be handled as userspace option additional to the IPv6 options.
+  *
+  * int (*parse_options)(const struct net_device *dev,
+  *			struct nd_opt_hdr *nd_opt,
+  *			struct ndisc_options *ndopts):
+  *     This function is called while parsing ndisc ops and put each position
+  *     as pointer into ndopts. If this function return unequal 0, then this
+  *     function took care about the ndisc option, if 0 then the IPv6 ndisc
+  *     option parser will take care about that option.
+  *
+  * void (*update)(const struct net_device *dev, struct neighbour *n,
+  *		  u32 flags, u8 icmp6_type,
+  *		  const struct ndisc_options *ndopts):
+  *     This function is called when IPv6 ndisc updates the neighbour cache
+  *     entry. Additional options which can be updated may be previously
+  *     parsed by parse_opts callback and accessible over ndopts parameter.
+  *
+  * int (*opt_addr_space)(const struct net_device *dev, u8 icmp6_type,
+  *			 struct neighbour *neigh, u8 *ha_buf,
+  *			 u8 **ha):
+  *     This function is called when the necessary option space will be
+  *     calculated before allocating a skb. The parameters neigh, ha_buf
+  *     abd ha are available on NDISC_REDIRECT messages only.
+  *
+  * void (*fill_addr_option)(const struct net_device *dev,
+  *			    struct sk_buff *skb, u8 icmp6_type,
+  *			    const u8 *ha):
+  *     This function is called when the skb will finally fill the option
+  *     fields inside skb. NOTE: this callback should fill the option
+  *     fields to the skb which are previously indicated by opt_space
+  *     parameter. That means the decision to add such option should
+  *     not lost between these two callbacks, e.g. protected by interface
+  *     up state.
+  *
+  * void (*prefix_rcv_add_addr)(struct net *net, struct net_device *dev,
+  *			       const struct prefix_info *pinfo,
+  *			       struct inet6_dev *in6_dev,
+  *			       struct in6_addr *addr,
+  *			       int addr_type, u32 addr_flags,
+  *			       bool sllao, bool tokenized,
+  *			       __u32 valid_lft, u32 prefered_lft,
+  *			       bool dev_addr_generated):
+  *     This function is called when a RA messages is received with valid
+  *     PIO option fields and an IPv6 address will be added to the interface
+  *     for autoconfiguration. The parameter dev_addr_generated reports about
+  *     if the address was based on dev->dev_addr or not. This can be used
+  *     to add a second address if link-layer operates with two link layer
+  *     addresses. E.g. 802.15.4 6LoWPAN.
+  */
+ struct ndisc_ops {
+ 	int	(*is_useropt)(u8 nd_opt_type);
+ 	int	(*parse_options)(const struct net_device *dev,
+ 				 struct nd_opt_hdr *nd_opt,
+ 				 struct ndisc_options *ndopts);
+ 	void	(*update)(const struct net_device *dev, struct neighbour *n,
+ 			  u32 flags, u8 icmp6_type,
+ 			  const struct ndisc_options *ndopts);
+ 	int	(*opt_addr_space)(const struct net_device *dev, u8 icmp6_type,
+ 				  struct neighbour *neigh, u8 *ha_buf,
+ 				  u8 **ha);
+ 	void	(*fill_addr_option)(const struct net_device *dev,
+ 				    struct sk_buff *skb, u8 icmp6_type,
+ 				    const u8 *ha);
+ 	void	(*prefix_rcv_add_addr)(struct net *net, struct net_device *dev,
+ 				       const struct prefix_info *pinfo,
+ 				       struct inet6_dev *in6_dev,
+ 				       struct in6_addr *addr,
+ 				       int addr_type, u32 addr_flags,
+ 				       bool sllao, bool tokenized,
+ 				       __u32 valid_lft, u32 prefered_lft,
+ 				       bool dev_addr_generated);
+ };
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static inline int ndisc_ops_is_useropt(const struct net_device *dev,
+ 				       u8 nd_opt_type)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->is_useropt)
+ 		return dev->ndisc_ops->is_useropt(nd_opt_type);
+ 	else
+ 		return 0;
+ }
+ 
+ static inline int ndisc_ops_parse_options(const struct net_device *dev,
+ 					  struct nd_opt_hdr *nd_opt,
+ 					  struct ndisc_options *ndopts)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->parse_options)
+ 		return dev->ndisc_ops->parse_options(dev, nd_opt, ndopts);
+ 	else
+ 		return 0;
+ }
+ 
+ static inline void ndisc_ops_update(const struct net_device *dev,
+ 					  struct neighbour *n, u32 flags,
+ 					  u8 icmp6_type,
+ 					  const struct ndisc_options *ndopts)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->update)
+ 		dev->ndisc_ops->update(dev, n, flags, icmp6_type, ndopts);
+ }
+ 
+ static inline int ndisc_ops_opt_addr_space(const struct net_device *dev,
+ 					   u8 icmp6_type)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->opt_addr_space &&
+ 	    icmp6_type != NDISC_REDIRECT)
+ 		return dev->ndisc_ops->opt_addr_space(dev, icmp6_type, NULL,
+ 						      NULL, NULL);
+ 	else
+ 		return 0;
+ }
+ 
+ static inline int ndisc_ops_redirect_opt_addr_space(const struct net_device *dev,
+ 						    struct neighbour *neigh,
+ 						    u8 *ha_buf, u8 **ha)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->opt_addr_space)
+ 		return dev->ndisc_ops->opt_addr_space(dev, NDISC_REDIRECT,
+ 						      neigh, ha_buf, ha);
+ 	else
+ 		return 0;
+ }
+ 
+ static inline void ndisc_ops_fill_addr_option(const struct net_device *dev,
+ 					      struct sk_buff *skb,
+ 					      u8 icmp6_type)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->fill_addr_option &&
+ 	    icmp6_type != NDISC_REDIRECT)
+ 		dev->ndisc_ops->fill_addr_option(dev, skb, icmp6_type, NULL);
+ }
+ 
+ static inline void ndisc_ops_fill_redirect_addr_option(const struct net_device *dev,
+ 						       struct sk_buff *skb,
+ 						       const u8 *ha)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->fill_addr_option)
+ 		dev->ndisc_ops->fill_addr_option(dev, skb, NDISC_REDIRECT, ha);
+ }
+ 
+ static inline void ndisc_ops_prefix_rcv_add_addr(struct net *net,
+ 						 struct net_device *dev,
+ 						 const struct prefix_info *pinfo,
+ 						 struct inet6_dev *in6_dev,
+ 						 struct in6_addr *addr,
+ 						 int addr_type, u32 addr_flags,
+ 						 bool sllao, bool tokenized,
+ 						 __u32 valid_lft,
+ 						 u32 prefered_lft,
+ 						 bool dev_addr_generated)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->prefix_rcv_add_addr)
+ 		dev->ndisc_ops->prefix_rcv_add_addr(net, dev, pinfo, in6_dev,
+ 						    addr, addr_type,
+ 						    addr_flags, sllao,
+ 						    tokenized, valid_lft,
+ 						    prefered_lft,
+ 						    dev_addr_generated);
+ }
+ #endif
  
  /*
   * Return the padding between the option length and the start of the
@@@ -200,35 -371,31 +393,38 @@@ static inline struct neighbour *__ipv6_
  	return n;
  }
  
 -int ndisc_init(void);
 -int ndisc_late_init(void);
 +extern int			ndisc_init(void);
 +extern int			ndisc_late_init(void);
  
 -void ndisc_late_cleanup(void);
 -void ndisc_cleanup(void);
 +extern void			ndisc_late_cleanup(void);
 +extern void			ndisc_cleanup(void);
  
 -int ndisc_rcv(struct sk_buff *skb);
 +extern int			ndisc_rcv(struct sk_buff *skb);
  
 -void ndisc_send_ns(struct net_device *dev, const struct in6_addr *solicit,
 -		   const struct in6_addr *daddr, const struct in6_addr *saddr);
 +extern void			ndisc_send_ns(struct net_device *dev,
 +					      struct neighbour *neigh,
 +					      const struct in6_addr *solicit,
 +					      const struct in6_addr *daddr,
 +					      const struct in6_addr *saddr);
  
 -void ndisc_send_rs(struct net_device *dev,
 -		   const struct in6_addr *saddr, const struct in6_addr *daddr);
 -void ndisc_send_na(struct net_device *dev, const struct in6_addr *daddr,
 -		   const struct in6_addr *solicited_addr,
 -		   bool router, bool solicited, bool override, bool inc_opt);
 +extern void			ndisc_send_rs(struct net_device *dev,
 +					      const struct in6_addr *saddr,
 +					      const struct in6_addr *daddr);
 +extern void			ndisc_send_na(struct net_device *dev, struct neighbour *neigh,
 +					      const struct in6_addr *daddr,
 +					      const struct in6_addr *solicited_addr,
 +					      bool router, bool solicited, bool override,
 +					      bool inc_opt);
  
 -void ndisc_send_redirect(struct sk_buff *skb, const struct in6_addr *target);
 +extern void			ndisc_send_redirect(struct sk_buff *skb,
 +						    const struct in6_addr *target);
  
 -int ndisc_mc_map(const struct in6_addr *addr, char *buf, struct net_device *dev,
 -		 int dir);
 +extern int			ndisc_mc_map(const struct in6_addr *addr, char *buf,
 +					     struct net_device *dev, int dir);
  
+ void ndisc_update(const struct net_device *dev, struct neighbour *neigh,
+ 		  const u8 *lladdr, u8 new, u32 flags, u8 icmp6_type,
+ 		  struct ndisc_options *ndopts);
  
  /*
   *	IGMP
diff --cc net/ipv6/addrconf.c
index ee6298c84794,b6e9bdc610f2..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -2247,10 -2530,8 +2247,14 @@@ void addrconf_prefix_rcv(struct net_dev
  	/* Try to figure out our local address for this prefix */
  
  	if (pinfo->autoconf && in6_dev->cnf.autoconf) {
 +		struct inet6_ifaddr *ifp;
  		struct in6_addr addr;
++<<<<<<< HEAD
 +		int create = 0, update_lft = 0;
 +		bool tokenized = false;
++=======
+ 		bool tokenized = false, dev_addr_generated = false;
++>>>>>>> f997c55c1dc8 (ipv6: introduce neighbour discovery ops)
  
  		if (pinfo->prefix_len == 64) {
  			memcpy(&addr, &pinfo->prefix, 8);
@@@ -2261,131 -2542,43 +2265,156 @@@
  				       in6_dev->token.s6_addr + 8, 8);
  				read_unlock_bh(&in6_dev->lock);
  				tokenized = true;
 -			} else if (is_addr_mode_generate_stable(in6_dev) &&
 -				   !ipv6_generate_stable_address(&addr, 0,
 -								 in6_dev)) {
 -				addr_flags |= IFA_F_STABLE_PRIVACY;
 -				goto ok;
  			} else if (ipv6_generate_eui64(addr.s6_addr + 8, dev) &&
  				   ipv6_inherit_eui64(addr.s6_addr + 8, in6_dev)) {
++<<<<<<< HEAD
 +				in6_dev_put(in6_dev);
 +				return;
++=======
+ 				goto put;
+ 			} else {
+ 				dev_addr_generated = true;
++>>>>>>> f997c55c1dc8 (ipv6: introduce neighbour discovery ops)
  			}
  			goto ok;
  		}
  		net_dbg_ratelimited("IPv6 addrconf: prefix with wrong length %d\n",
  				    pinfo->prefix_len);
 -		goto put;
 +		in6_dev_put(in6_dev);
 +		return;
  
  ok:
++<<<<<<< HEAD
 +
 +		ifp = ipv6_get_ifaddr(net, &addr, dev, 1);
 +
 +		if (ifp == NULL && valid_lft) {
 +			int max_addresses = in6_dev->cnf.max_addresses;
 +			u32 addr_flags = 0;
 +
 +#ifdef CONFIG_IPV6_OPTIMISTIC_DAD
 +			if (in6_dev->cnf.optimistic_dad &&
 +			    !net->ipv6.devconf_all->forwarding && sllao)
 +				addr_flags |= IFA_F_OPTIMISTIC;
 +#endif
 +
 +			/* Do not allow to create too much of autoconfigured
 +			 * addresses; this would be too easy way to crash kernel.
 +			 */
 +			if (!max_addresses ||
 +			    ipv6_count_addresses(in6_dev) < max_addresses)
 +				ifp = ipv6_add_addr(in6_dev, &addr, NULL,
 +						    pinfo->prefix_len,
 +						    addr_type&IPV6_ADDR_SCOPE_MASK,
 +						    addr_flags, valid_lft,
 +						    prefered_lft);
 +
 +			if (IS_ERR_OR_NULL(ifp)) {
 +				in6_dev_put(in6_dev);
 +				return;
 +			}
 +
 +			update_lft = 0;
 +			create = 1;
 +			spin_lock_bh(&ifp->lock);
 +			ifp->flags |= IFA_F_MANAGETEMPADDR;
 +			ifp->cstamp = jiffies;
 +			ifp->tokenized = tokenized;
 +			spin_unlock_bh(&ifp->lock);
 +			addrconf_dad_start(ifp);
 +		}
 +
 +		if (ifp) {
 +			u32 flags;
 +			unsigned long now;
 +			u32 stored_lft;
 +
 +			/* update lifetime (RFC2462 5.5.3 e) */
 +			spin_lock_bh(&ifp->lock);
 +			now = jiffies;
 +			if (ifp->valid_lft > (now - ifp->tstamp) / HZ)
 +				stored_lft = ifp->valid_lft - (now - ifp->tstamp) / HZ;
 +			else
 +				stored_lft = 0;
 +			if (!update_lft && !create && stored_lft) {
 +				if (valid_lft > MIN_VALID_LIFETIME ||
 +				    valid_lft > stored_lft)
 +					update_lft = 1;
 +				else if (stored_lft <= MIN_VALID_LIFETIME) {
 +					/* valid_lft <= stored_lft is always true */
 +					/*
 +					 * RFC 4862 Section 5.5.3e:
 +					 * "Note that the preferred lifetime of
 +					 *  the corresponding address is always
 +					 *  reset to the Preferred Lifetime in
 +					 *  the received Prefix Information
 +					 *  option, regardless of whether the
 +					 *  valid lifetime is also reset or
 +					 *  ignored."
 +					 *
 +					 *  So if the preferred lifetime in
 +					 *  this advertisement is different
 +					 *  than what we have stored, but the
 +					 *  valid lifetime is invalid, just
 +					 *  reset prefered_lft.
 +					 *
 +					 *  We must set the valid lifetime
 +					 *  to the stored lifetime since we'll
 +					 *  be updating the timestamp below,
 +					 *  else we'll set it back to the
 +					 *  minimum.
 +					 */
 +					if (prefered_lft != ifp->prefered_lft) {
 +						valid_lft = stored_lft;
 +						update_lft = 1;
 +					}
 +				} else {
 +					valid_lft = MIN_VALID_LIFETIME;
 +					if (valid_lft < prefered_lft)
 +						prefered_lft = valid_lft;
 +					update_lft = 1;
 +				}
 +			}
 +
 +			if (update_lft) {
 +				ifp->valid_lft = valid_lft;
 +				ifp->prefered_lft = prefered_lft;
 +				ifp->tstamp = now;
 +				flags = ifp->flags;
 +				ifp->flags &= ~IFA_F_DEPRECATED;
 +				spin_unlock_bh(&ifp->lock);
 +
 +				if (!(flags&IFA_F_TENTATIVE))
 +					ipv6_ifa_notify(0, ifp);
 +			} else
 +				spin_unlock_bh(&ifp->lock);
 +
 +			manage_tempaddrs(in6_dev, ifp, valid_lft, prefered_lft,
 +					 create, now);
 +
 +			in6_ifa_put(ifp);
 +			addrconf_verify();
 +		}
++=======
+ 		err = addrconf_prefix_rcv_add_addr(net, dev, pinfo, in6_dev,
+ 						   &addr, addr_type,
+ 						   addr_flags, sllao,
+ 						   tokenized, valid_lft,
+ 						   prefered_lft);
+ 		if (err)
+ 			goto put;
+ 
+ 		/* Ignore error case here because previous prefix add addr was
+ 		 * successful which will be notified.
+ 		 */
+ 		ndisc_ops_prefix_rcv_add_addr(net, dev, pinfo, in6_dev, &addr,
+ 					      addr_type, addr_flags, sllao,
+ 					      tokenized, valid_lft,
+ 					      prefered_lft,
+ 					      dev_addr_generated);
++>>>>>>> f997c55c1dc8 (ipv6: introduce neighbour discovery ops)
  	}
  	inet6_prefix_notify(RTM_NEWPREFIX, in6_dev, pinfo);
 -put:
  	in6_dev_put(in6_dev);
  }
  
diff --cc net/ipv6/ndisc.c
index 48c6e50e8b35,2f4afd17954b..000000000000
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@@ -199,11 -216,12 +211,17 @@@ static struct nd_opt_hdr *ndisc_next_us
  		return NULL;
  	do {
  		cur = ((void *)cur) + (cur->nd_opt_len << 3);
++<<<<<<< HEAD
 +	} while(cur < end && !ndisc_is_useropt(cur));
 +	return cur <= end && ndisc_is_useropt(cur) ? cur : NULL;
++=======
+ 	} while (cur < end && !ndisc_is_useropt(dev, cur));
+ 	return cur <= end && ndisc_is_useropt(dev, cur) ? cur : NULL;
++>>>>>>> f997c55c1dc8 (ipv6: introduce neighbour discovery ops)
  }
  
- struct ndisc_options *ndisc_parse_options(u8 *opt, int opt_len,
+ struct ndisc_options *ndisc_parse_options(const struct net_device *dev,
+ 					  u8 *opt, int opt_len,
  					  struct ndisc_options *ndopts)
  {
  	struct nd_opt_hdr *nd_opt = (struct nd_opt_hdr *)opt;
@@@ -841,12 -891,12 +875,13 @@@ static void ndisc_recv_ns(struct sk_buf
  	neigh = __neigh_lookup(&nd_tbl, saddr, dev,
  			       !inc || lladdr || !dev->addr_len);
  	if (neigh)
- 		neigh_update(neigh, lladdr, NUD_STALE,
+ 		ndisc_update(dev, neigh, lladdr, NUD_STALE,
  			     NEIGH_UPDATE_F_WEAK_OVERRIDE|
- 			     NEIGH_UPDATE_F_OVERRIDE);
+ 			     NEIGH_UPDATE_F_OVERRIDE,
+ 			     NDISC_NEIGHBOUR_SOLICITATION, &ndopts);
  	if (neigh || !dev->header_ops) {
 -		ndisc_send_na(dev, saddr, &msg->target, !!is_router,
 +		ndisc_send_na(dev, neigh, saddr, &msg->target,
 +			      !!is_router,
  			      true, (ifp != NULL && inc), inc);
  		if (neigh)
  			neigh_release(neigh);
@@@ -888,7 -939,15 +923,19 @@@ static void ndisc_recv_na(struct sk_buf
  		return;
  	}
  
++<<<<<<< HEAD
 +	if (!ndisc_parse_options(msg->opt, ndoptlen, &ndopts)) {
++=======
+ 	/* For some 802.11 wireless deployments (and possibly other networks),
+ 	 * there will be a NA proxy and unsolicitd packets are attacks
+ 	 * and thus should not be accepted.
+ 	 */
+ 	if (!msg->icmph.icmp6_solicited && idev &&
+ 	    idev->cnf.drop_unsolicited_na)
+ 		return;
+ 
+ 	if (!ndisc_parse_options(dev, msg->opt, ndoptlen, &ndopts)) {
++>>>>>>> f997c55c1dc8 (ipv6: introduce neighbour discovery ops)
  		ND_PRINTK(2, warn, "NS: invalid ND option\n");
  		return;
  	}
@@@ -1267,15 -1371,26 +1316,16 @@@ skip_linkparms
  			     NEIGH_UPDATE_F_WEAK_OVERRIDE|
  			     NEIGH_UPDATE_F_OVERRIDE|
  			     NEIGH_UPDATE_F_OVERRIDE_ISROUTER|
- 			     NEIGH_UPDATE_F_ISROUTER);
+ 			     NEIGH_UPDATE_F_ISROUTER,
+ 			     NDISC_ROUTER_ADVERTISEMENT, &ndopts);
  	}
  
 -	if (!ipv6_accept_ra(in6_dev)) {
 -		ND_PRINTK(2, info,
 -			  "RA: %s, accept_ra is false for dev: %s\n",
 -			  __func__, skb->dev->name);
 +	if (!ipv6_accept_ra(in6_dev))
  		goto out;
 -	}
  
  #ifdef CONFIG_IPV6_ROUTE_INFO
 -	if (!in6_dev->cnf.accept_ra_from_local &&
 -	    ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr,
 -			  in6_dev->dev, 0)) {
 -		ND_PRINTK(2, info,
 -			  "RA from local address detected on dev: %s: router info ignored.\n",
 -			  skb->dev->name);
 +	if (ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr, NULL, 0))
  		goto skip_routeinfo;
 -	}
  
  	if (in6_dev->cnf.accept_ra_rtr_pref && ndopts.nd_opts_ri) {
  		struct nd_opt_hdr *p;
@@@ -1421,7 -1544,9 +1472,13 @@@ void ndisc_send_redirect(struct sk_buf
  	struct dst_entry *dst;
  	struct flowi6 fl6;
  	int rd_len;
++<<<<<<< HEAD
 +	u8 ha_buf[MAX_ADDR_LEN], *ha = NULL;
++=======
+ 	u8 ha_buf[MAX_ADDR_LEN], *ha = NULL,
+ 	   ops_data_buf[NDISC_OPS_REDIRECT_DATA_SPACE], *ops_data = NULL;
+ 	int oif = l3mdev_fib_oif(dev);
++>>>>>>> f997c55c1dc8 (ipv6: introduce neighbour discovery ops)
  	bool ret;
  
  	if (ipv6_get_lladdr(dev, &saddr_buf, IFA_F_TENTATIVE)) {
* Unmerged path include/linux/netdevice.h
* Unmerged path include/net/ndisc.h
* Unmerged path net/ipv6/addrconf.c
* Unmerged path net/ipv6/ndisc.c
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index ac268c7a7261..8ccc617e6509 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -2177,7 +2177,7 @@ static void rt6_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_bu
 	 *	first-hop router for the specified ICMP Destination Address.
 	 */
 
-	if (!ndisc_parse_options(msg->opt, optlen, &ndopts)) {
+	if (!ndisc_parse_options(skb->dev, msg->opt, optlen, &ndopts)) {
 		net_dbg_ratelimited("rt6_redirect: invalid ND options\n");
 		return;
 	}
@@ -2212,12 +2212,12 @@ static void rt6_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_bu
 	 *	We have finally decided to accept it.
 	 */
 
-	neigh_update(neigh, lladdr, NUD_STALE,
+	ndisc_update(skb->dev, neigh, lladdr, NUD_STALE,
 		     NEIGH_UPDATE_F_WEAK_OVERRIDE|
 		     NEIGH_UPDATE_F_OVERRIDE|
 		     (on_link ? 0 : (NEIGH_UPDATE_F_OVERRIDE_ISROUTER|
-				     NEIGH_UPDATE_F_ISROUTER))
-		     );
+				     NEIGH_UPDATE_F_ISROUTER)),
+		     NDISC_REDIRECT, &ndopts);
 
 	nrt = ip6_rt_cache_alloc(rt, &msg->dest, NULL);
 	if (!nrt)
