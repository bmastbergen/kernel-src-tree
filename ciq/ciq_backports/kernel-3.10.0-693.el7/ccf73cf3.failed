sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tejun Heo <tj@kernel.org>
commit ccf73cf336dc55bc52748205dee998d2fd4a8808
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ccf73cf3.failed

Introduce kernfs interface for finding, getting and putting
sysfs_dirents.

* sysfs_find_dirent() is renamed to kernfs_find_ns() and lockdep
  assertion for sysfs_mutex is added.

* sysfs_get_dirent_ns() is renamed to kernfs_find_and_get().

* Macro inline dancing around __sysfs_get/put() are removed and
  kernfs_get/put() are made proper functions implemented in
  fs/sysfs/dir.c.

While the conversions are mostly equivalent, there's one difference -
kernfs_get() doesn't return the input param as its return value.  This
change is intentional.  While passing through the input increases
writability in some areas, it is unnecessary and has been shown to
cause confusion regarding how the last ref is handled.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit ccf73cf336dc55bc52748205dee998d2fd4a8808)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/dir.c
#	fs/sysfs/file.c
#	fs/sysfs/group.c
#	fs/sysfs/inode.c
#	fs/sysfs/symlink.c
#	fs/sysfs/sysfs.h
#	include/linux/kernfs.h
#	include/linux/sysfs.h
diff --cc fs/sysfs/dir.c
index 3f68344137e5,0d806efcc9a6..000000000000
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@@ -258,7 -240,26 +258,30 @@@ static void sysfs_free_ino(unsigned in
  	spin_unlock(&sysfs_ino_lock);
  }
  
++<<<<<<< HEAD
 +void release_sysfs_dirent(struct sysfs_dirent * sd)
++=======
+ /**
+  * kernfs_get - get a reference count on a sysfs_dirent
+  * @sd: the target sysfs_dirent
+  */
+ void kernfs_get(struct sysfs_dirent *sd)
+ {
+ 	if (sd) {
+ 		WARN_ON(!atomic_read(&sd->s_count));
+ 		atomic_inc(&sd->s_count);
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(kernfs_get);
+ 
+ /**
+  * kernfs_put - put a reference count on a sysfs_dirent
+  * @sd: the target sysfs_dirent
+  *
+  * Put a reference count of @sd and destroy it if it reached zero.
+  */
+ void kernfs_put(struct sysfs_dirent *sd)
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  {
  	struct sysfs_dirent *parent_sd;
  
@@@ -452,8 -451,12 +478,17 @@@ int __sysfs_add_one(struct sysfs_addrm_
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	sd->s_hash = sysfs_name_hash(sd->s_ns, sd->s_name);
 +	sd->s_parent = sysfs_get(acxt->parent_sd);
++=======
+ 	if (sysfs_type(parent_sd) != SYSFS_DIR)
+ 		return -EINVAL;
+ 
+ 	sd->s_hash = sysfs_name_hash(sd->s_name, sd->s_ns);
+ 	sd->s_parent = parent_sd;
+ 	kernfs_get(parent_sd);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  
  	ret = sysfs_link_sibling(sd);
  	if (ret)
@@@ -593,35 -575,34 +628,59 @@@ void sysfs_addrm_finish(struct sysfs_ad
  		acxt->removed = sd->u.removed_list;
  
  		sysfs_deactivate(sd);
++<<<<<<< HEAD
 +		unmap_bin_file(sd);
 +		sysfs_put(sd);
++=======
+ 		sysfs_unmap_bin_file(sd);
+ 		kernfs_put(sd);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	}
  }
  
  /**
++<<<<<<< HEAD
 + *	sysfs_find_dirent - find sysfs_dirent with the given name
 + *	@parent_sd: sysfs_dirent to search under
 + *	@name: name to look for
++=======
+  * kernfs_find_ns - find sysfs_dirent with the given name
+  * @parent: sysfs_dirent to search under
+  * @name: name to look for
+  * @ns: the namespace tag to use
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
   *
-  *	Look for sysfs_dirent with name @name under @parent_sd.
-  *
-  *	LOCKING:
-  *	mutex_lock(sysfs_mutex)
-  *
-  *	RETURNS:
-  *	Pointer to sysfs_dirent if found, NULL if not.
+  * Look for sysfs_dirent with name @name under @parent.  Returns pointer to
+  * the found sysfs_dirent on success, %NULL on failure.
   */
++<<<<<<< HEAD
 +struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,
 +				       const void *ns,
 +				       const unsigned char *name)
 +{
 +	struct rb_node *node = parent_sd->s_dir.children.rb_node;
 +	unsigned int hash;
 +
 +	if (!!sysfs_ns_type(parent_sd) != !!ns) {
 +		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
 +			sysfs_ns_type(parent_sd)? "required": "invalid",
 +			parent_sd->s_name, name);
++=======
+ static struct sysfs_dirent *kernfs_find_ns(struct sysfs_dirent *parent,
+ 					   const unsigned char *name,
+ 					   const void *ns)
+ {
+ 	struct rb_node *node = parent->s_dir.children.rb_node;
+ 	bool has_ns = parent->s_flags & SYSFS_FLAG_NS;
+ 	unsigned int hash;
+ 
+ 	lockdep_assert_held(&sysfs_mutex);
+ 
+ 	if (has_ns != (bool)ns) {
+ 		WARN(1, KERN_WARNING "sysfs: ns %s in '%s' for '%s'\n",
+ 		     has_ns ? "required" : "invalid",
+ 		     parent->s_name, name);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  		return NULL;
  	}
  
@@@ -643,39 -624,43 +702,55 @@@
  }
  
  /**
++<<<<<<< HEAD
 + *	sysfs_get_dirent - find and get sysfs_dirent with the given name
 + *	@parent_sd: sysfs_dirent to search under
 + *	@name: name to look for
++=======
+  * kernfs_find_and_get_ns - find and get sysfs_dirent with the given name
+  * @parent: sysfs_dirent to search under
+  * @name: name to look for
+  * @ns: the namespace tag to use
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
   *
-  *	Look for sysfs_dirent with name @name under @parent_sd and get
-  *	it if found.
-  *
-  *	LOCKING:
-  *	Kernel thread context (may sleep).  Grabs sysfs_mutex.
-  *
-  *	RETURNS:
-  *	Pointer to sysfs_dirent if found, NULL if not.
+  * Look for sysfs_dirent with name @name under @parent and get a reference
+  * if found.  This function may sleep and returns pointer to the found
+  * sysfs_dirent on success, %NULL on failure.
   */
++<<<<<<< HEAD
 +struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd,
 +				      const void *ns,
 +				      const unsigned char *name)
++=======
+ struct sysfs_dirent *kernfs_find_and_get_ns(struct sysfs_dirent *parent,
+ 					    const char *name, const void *ns)
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  {
  	struct sysfs_dirent *sd;
  
  	mutex_lock(&sysfs_mutex);
++<<<<<<< HEAD
 +	sd = sysfs_find_dirent(parent_sd, ns, name);
 +	sysfs_get(sd);
++=======
+ 	sd = kernfs_find_ns(parent, name, ns);
+ 	kernfs_get(sd);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	mutex_unlock(&sysfs_mutex);
  
  	return sd;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(sysfs_get_dirent);
++=======
+ EXPORT_SYMBOL_GPL(kernfs_find_and_get_ns);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  
 -/**
 - * kernfs_create_dir_ns - create a directory
 - * @parent: parent in which to create a new directory
 - * @name: name of the new directory
 - * @priv: opaque data associated with the new directory
 - * @ns: optional namespace tag of the directory
 - *
 - * Returns the created node on success, ERR_PTR() value on failure.
 - */
 -struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
 -					  const char *name, void *priv,
 -					  const void *ns)
 +static int create_dir(struct kobject *kobj, struct sysfs_dirent *parent_sd,
 +	enum kobj_ns_type type, const void *ns, const char *name,
 +	struct sysfs_dirent **p_sd)
  {
 -	umode_t mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
 +	umode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;
  	struct sysfs_addrm_cxt acxt;
  	struct sysfs_dirent *sd;
  	int rc;
@@@ -683,30 -668,21 +758,35 @@@
  	/* allocate */
  	sd = sysfs_new_dirent(name, mode, SYSFS_DIR);
  	if (!sd)
 -		return ERR_PTR(-ENOMEM);
 +		return -ENOMEM;
  
 +	sd->s_flags |= (type << SYSFS_NS_TYPE_SHIFT);
  	sd->s_ns = ns;
 -	sd->priv = priv;
 +	sd->s_dir.kobj = kobj;
  
  	/* link in */
 -	sysfs_addrm_start(&acxt);
 -	rc = sysfs_add_one(&acxt, sd, parent);
 +	sysfs_addrm_start(&acxt, parent_sd);
 +	rc = sysfs_add_one(&acxt, sd);
  	sysfs_addrm_finish(&acxt);
  
 -	if (!rc)
 -		return sd;
 +	if (rc == 0)
 +		*p_sd = sd;
 +	else
 +		sysfs_put(sd);
 +
++<<<<<<< HEAD
 +	return rc;
 +}
  
 +int sysfs_create_subdir(struct kobject *kobj, const char *name,
 +			struct sysfs_dirent **p_sd)
 +{
 +	return create_dir(kobj, kobj->sd,
 +			  KOBJ_NS_TYPE_NONE, NULL, name, p_sd);
++=======
+ 	kernfs_put(sd);
+ 	return ERR_PTR(rc);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  }
  
  /**
@@@ -778,10 -727,10 +858,14 @@@ static struct dentry * sysfs_lookup(str
  
  	mutex_lock(&sysfs_mutex);
  
 -	if (parent_sd->s_flags & SYSFS_FLAG_NS)
 -		ns = sysfs_info(dir->i_sb)->ns;
 +	type = sysfs_ns_type(parent_sd);
 +	ns = sysfs_info(dir->i_sb)->ns[type];
  
++<<<<<<< HEAD
 +	sd = sysfs_find_dirent(parent_sd, ns, dentry->d_name.name);
++=======
+ 	sd = kernfs_find_ns(parent_sd, dentry->d_name.name, ns);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  
  	/* no such entry */
  	if (!sd) {
@@@ -812,41 -762,128 +897,51 @@@ const struct inode_operations sysfs_dir
  	.setxattr	= sysfs_setxattr,
  };
  
 -static struct sysfs_dirent *sysfs_leftmost_descendant(struct sysfs_dirent *pos)
 +static void remove_dir(struct sysfs_dirent *sd)
  {
 -	struct sysfs_dirent *last;
 -
 -	while (true) {
 -		struct rb_node *rbn;
 -
 -		last = pos;
 -
 -		if (sysfs_type(pos) != SYSFS_DIR)
 -			break;
 -
 -		rbn = rb_first(&pos->s_dir.children);
 -		if (!rbn)
 -			break;
 -
 -		pos = to_sysfs_dirent(rbn);
 -	}
 +	struct sysfs_addrm_cxt acxt;
  
 -	return last;
 +	sysfs_addrm_start(&acxt, sd->s_parent);
 +	sysfs_remove_one(&acxt, sd);
 +	sysfs_addrm_finish(&acxt);
  }
  
 -/**
 - * sysfs_next_descendant_post - find the next descendant for post-order walk
 - * @pos: the current position (%NULL to initiate traversal)
 - * @root: sysfs_dirent whose descendants to walk
 - *
 - * Find the next descendant to visit for post-order traversal of @root's
 - * descendants.  @root is included in the iteration and the last node to be
 - * visited.
 - */
 -static struct sysfs_dirent *sysfs_next_descendant_post(struct sysfs_dirent *pos,
 -						       struct sysfs_dirent *root)
 +void sysfs_remove_subdir(struct sysfs_dirent *sd)
  {
 -	struct rb_node *rbn;
 -
 -	lockdep_assert_held(&sysfs_mutex);
 -
 -	/* if first iteration, visit leftmost descendant which may be root */
 -	if (!pos)
 -		return sysfs_leftmost_descendant(root);
 -
 -	/* if we visited @root, we're done */
 -	if (pos == root)
 -		return NULL;
 -
 -	/* if there's an unvisited sibling, visit its leftmost descendant */
 -	rbn = rb_next(&pos->s_rb);
 -	if (rbn)
 -		return sysfs_leftmost_descendant(to_sysfs_dirent(rbn));
 -
 -	/* no sibling left, visit parent */
 -	return pos->s_parent;
 +	remove_dir(sd);
  }
  
 -static void __kernfs_remove(struct sysfs_addrm_cxt *acxt,
 -			    struct sysfs_dirent *sd)
 -{
 -	struct sysfs_dirent *pos, *next;
  
 -	if (!sd)
 -		return;
 -
 -	pr_debug("sysfs %s: removing\n", sd->s_name);
 -
 -	next = NULL;
 -	do {
 -		pos = next;
 -		next = sysfs_next_descendant_post(pos, sd);
 -		if (pos)
 -			sysfs_remove_one(acxt, pos);
 -	} while (next);
 -}
 -
 -/**
 - * kernfs_remove - remove a sysfs_dirent recursively
 - * @sd: the sysfs_dirent to remove
 - *
 - * Remove @sd along with all its subdirectories and files.
 - */
 -void kernfs_remove(struct sysfs_dirent *sd)
 +static void __sysfs_remove_dir(struct sysfs_dirent *dir_sd)
  {
  	struct sysfs_addrm_cxt acxt;
 +	struct rb_node *pos;
  
 -	sysfs_addrm_start(&acxt);
 -	__kernfs_remove(&acxt, sd);
 -	sysfs_addrm_finish(&acxt);
 -}
 -
 -/**
 - * kernfs_remove_by_name_ns - find a sysfs_dirent by name and remove it
 - * @dir_sd: parent of the target
 - * @name: name of the sysfs_dirent to remove
 - * @ns: namespace tag of the sysfs_dirent to remove
 - *
 - * Look for the sysfs_dirent with @name and @ns under @dir_sd and remove
 - * it.  Returns 0 on success, -ENOENT if such entry doesn't exist.
 - */
 -int kernfs_remove_by_name_ns(struct sysfs_dirent *dir_sd, const char *name,
 -			     const void *ns)
 -{
 -	struct sysfs_addrm_cxt acxt;
 -	struct sysfs_dirent *sd;
 +	if (!dir_sd)
 +		return;
  
 -	if (!dir_sd) {
 -		WARN(1, KERN_WARNING "sysfs: can not remove '%s', no directory\n",
 -			name);
 -		return -ENOENT;
 +	pr_debug("sysfs %s: removing dir\n", dir_sd->s_name);
 +	sysfs_addrm_start(&acxt, dir_sd);
 +	pos = rb_first(&dir_sd->s_dir.children);
 +	while (pos) {
 +		struct sysfs_dirent *sd = to_sysfs_dirent(pos);
 +		pos = rb_next(pos);
 +		if (sysfs_type(sd) != SYSFS_DIR)
 +			sysfs_remove_one(&acxt, sd);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	sysfs_addrm_start(&acxt);
+ 
+ 	sd = kernfs_find_ns(dir_sd, name, ns);
+ 	if (sd)
+ 		__kernfs_remove(&acxt, sd);
+ 
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	sysfs_addrm_finish(&acxt);
  
 -	if (sd)
 -		return 0;
 -	else
 -		return -ENOENT;
 +	remove_dir(dir_sd);
  }
  
  /**
@@@ -883,7 -940,7 +978,11 @@@ int sysfs_rename(struct sysfs_dirent *s
  		goto out;	/* nothing to rename */
  
  	error = -EEXIST;
++<<<<<<< HEAD
 +	if (sysfs_find_dirent(new_parent_sd, new_ns, new_name))
++=======
+ 	if (kernfs_find_ns(new_parent, new_name, new_ns))
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  		goto out;
  
  	/* rename sysfs_dirent */
@@@ -897,13 -954,15 +996,18 @@@
  		sd->s_name = new_name;
  	}
  
 -	/*
 -	 * Move to the appropriate place in the appropriate directories rbtree.
 -	 */
 +	/* Move to the appropriate place in the appropriate directories rbtree. */
  	sysfs_unlink_sibling(sd);
++<<<<<<< HEAD
 +	sysfs_get(new_parent_sd);
 +	sysfs_put(sd->s_parent);
++=======
+ 	kernfs_get(new_parent);
+ 	kernfs_put(sd->s_parent);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	sd->s_ns = new_ns;
 -	sd->s_hash = sysfs_name_hash(sd->s_name, sd->s_ns);
 -	sd->s_parent = new_parent;
 +	sd->s_hash = sysfs_name_hash(sd->s_ns, sd->s_name);
 +	sd->s_parent = new_parent_sd;
  	sysfs_link_sibling(sd);
  
  	error = 0;
@@@ -999,68 -1069,40 +1103,80 @@@ static struct sysfs_dirent *sysfs_dir_n
  	return pos;
  }
  
 -static int sysfs_readdir(struct file *file, struct dir_context *ctx)
 +static int sysfs_readdir(struct file * filp, void * dirent, filldir_t filldir)
  {
 -	struct dentry *dentry = file->f_path.dentry;
 -	struct sysfs_dirent *parent_sd = dentry->d_fsdata;
 -	struct sysfs_dirent *pos = file->private_data;
 -	const void *ns = NULL;
 -
 -	if (!dir_emit_dots(file, ctx))
 -		return 0;
 +	struct dentry *dentry = filp->f_path.dentry;
 +	struct sysfs_dirent * parent_sd = dentry->d_fsdata;
 +	struct sysfs_dirent *pos = filp->private_data;
 +	enum kobj_ns_type type;
 +	const void *ns;
 +	ino_t ino;
 +	loff_t off;
 +
 +	type = sysfs_ns_type(parent_sd);
 +	ns = sysfs_info(dentry->d_sb)->ns[type];
 +
 +	if (filp->f_pos == 0) {
 +		ino = parent_sd->s_ino;
 +		if (filldir(dirent, ".", 1, filp->f_pos, ino, DT_DIR) == 0)
 +			filp->f_pos++;
 +		else
 +			return 0;
 +	}
 +	if (filp->f_pos == 1) {
 +		if (parent_sd->s_parent)
 +			ino = parent_sd->s_parent->s_ino;
 +		else
 +			ino = parent_sd->s_ino;
 +		if (filldir(dirent, "..", 2, filp->f_pos, ino, DT_DIR) == 0)
 +			filp->f_pos++;
 +		else
 +			return 0;
 +	}
  	mutex_lock(&sysfs_mutex);
 -
 -	if (parent_sd->s_flags & SYSFS_FLAG_NS)
 -		ns = sysfs_info(dentry->d_sb)->ns;
 -
 -	for (pos = sysfs_dir_pos(ns, parent_sd, ctx->pos, pos);
 +	off = filp->f_pos;
 +	for (pos = sysfs_dir_pos(ns, parent_sd, filp->f_pos, pos);
  	     pos;
++<<<<<<< HEAD
 +	     pos = sysfs_dir_next_pos(ns, parent_sd, filp->f_pos, pos)) {
 +		const char * name;
 +		unsigned int type;
 +		int len, ret;
 +
 +		name = pos->s_name;
 +		len = strlen(name);
 +		ino = pos->s_ino;
 +		type = dt_type(pos);
 +		off = filp->f_pos = pos->s_hash;
 +		filp->private_data = sysfs_get(pos);
++=======
+ 	     pos = sysfs_dir_next_pos(ns, parent_sd, ctx->pos, pos)) {
+ 		const char *name = pos->s_name;
+ 		unsigned int type = dt_type(pos);
+ 		int len = strlen(name);
+ 		ino_t ino = pos->s_ino;
+ 
+ 		ctx->pos = pos->s_hash;
+ 		file->private_data = pos;
+ 		kernfs_get(pos);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  
  		mutex_unlock(&sysfs_mutex);
 -		if (!dir_emit(ctx, name, len, ino, type))
 -			return 0;
 +		ret = filldir(dirent, name, len, off, ino, type);
  		mutex_lock(&sysfs_mutex);
 +		if (ret < 0)
 +			break;
  	}
  	mutex_unlock(&sysfs_mutex);
 -	file->private_data = NULL;
 -	ctx->pos = INT_MAX;
 +
 +	/* don't reference last entry if its refcount is dropped */
 +	if (!pos) {
 +		filp->private_data = NULL;
 +
 +		/* EOF and not changed as 0 or 1 in read/write path */
 +		if (off == filp->f_pos && off > 1)
 +			filp->f_pos = INT_MAX;
 +	}
  	return 0;
  }
  
diff --cc fs/sysfs/file.c
index 602f56db0442,7f0a79fa2ed8..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -461,114 -878,200 +461,139 @@@ EXPORT_SYMBOL_GPL(sysfs_notify_dirent)
  
  void sysfs_notify(struct kobject *k, const char *dir, const char *attr)
  {
 -	struct sysfs_dirent *sd = k->sd, *tmp;
 +	struct sysfs_dirent *sd = k->sd;
 +
 +	mutex_lock(&sysfs_mutex);
  
  	if (sd && dir)
++<<<<<<< HEAD
 +		sd = sysfs_find_dirent(sd, NULL, dir);
 +	if (sd && attr)
 +		sd = sysfs_find_dirent(sd, NULL, attr);
 +	if (sd)
 +		sysfs_notify_dirent(sd);
 +
 +	mutex_unlock(&sysfs_mutex);
++=======
+ 		sd = kernfs_find_and_get(sd, dir);
+ 	else
+ 		kernfs_get(sd);
+ 
+ 	if (sd && attr) {
+ 		tmp = kernfs_find_and_get(sd, attr);
+ 		kernfs_put(sd);
+ 		sd = tmp;
+ 	}
+ 
+ 	if (sd) {
+ 		kernfs_notify(sd);
+ 		kernfs_put(sd);
+ 	}
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  }
  EXPORT_SYMBOL_GPL(sysfs_notify);
  
 -const struct file_operations kernfs_file_operations = {
 -	.read		= kernfs_file_read,
 -	.write		= kernfs_file_write,
 +const struct file_operations sysfs_file_operations = {
 +	.read		= sysfs_read_file,
 +	.write		= sysfs_write_file,
  	.llseek		= generic_file_llseek,
 -	.mmap		= kernfs_file_mmap,
 -	.open		= kernfs_file_open,
 -	.release	= kernfs_file_release,
 -	.poll		= kernfs_file_poll,
 -};
 -
 -static const struct kernfs_ops sysfs_file_kfops_empty = {
 -};
 -
 -static const struct kernfs_ops sysfs_file_kfops_ro = {
 -	.seq_show	= sysfs_kf_seq_show,
 -};
 -
 -static const struct kernfs_ops sysfs_file_kfops_wo = {
 -	.write		= sysfs_kf_write,
 -};
 -
 -static const struct kernfs_ops sysfs_file_kfops_rw = {
 -	.seq_show	= sysfs_kf_seq_show,
 -	.write		= sysfs_kf_write,
 -};
 -
 -static const struct kernfs_ops sysfs_bin_kfops_ro = {
 -	.read		= sysfs_kf_bin_read,
 -};
 -
 -static const struct kernfs_ops sysfs_bin_kfops_wo = {
 -	.write		= sysfs_kf_bin_write,
 -};
 -
 -static const struct kernfs_ops sysfs_bin_kfops_rw = {
 -	.read		= sysfs_kf_bin_read,
 -	.write		= sysfs_kf_bin_write,
 -	.mmap		= sysfs_kf_bin_mmap,
 +	.open		= sysfs_open_file,
 +	.release	= sysfs_release,
 +	.poll		= sysfs_poll,
  };
  
 -int sysfs_add_file_mode_ns(struct sysfs_dirent *dir_sd,
 -			   const struct attribute *attr, bool is_bin,
 -			   umode_t mode, const void *ns)
 +static int sysfs_attr_ns(struct kobject *kobj, const struct attribute *attr,
 +			 const void **pns)
  {
 -	struct lock_class_key *key = NULL;
 -	const struct kernfs_ops *ops;
 -	struct sysfs_dirent *sd;
 -	loff_t size;
 -
 -	if (!is_bin) {
 -		struct kobject *kobj = dir_sd->priv;
 -		const struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;
 -
 -		/* every kobject with an attribute needs a ktype assigned */
 -		if (WARN(!sysfs_ops, KERN_ERR
 -			 "missing sysfs attribute operations for kobject: %s\n",
 -			 kobject_name(kobj)))
 -			return -EINVAL;
 -
 -		if (sysfs_ops->show && sysfs_ops->store)
 -			ops = &sysfs_file_kfops_rw;
 -		else if (sysfs_ops->show)
 -			ops = &sysfs_file_kfops_ro;
 -		else if (sysfs_ops->store)
 -			ops = &sysfs_file_kfops_wo;
 -		else
 -			ops = &sysfs_file_kfops_empty;
 -
 -		size = PAGE_SIZE;
 -	} else {
 -		struct bin_attribute *battr = (void *)attr;
 -
 -		if ((battr->read && battr->write) || battr->mmap)
 -			ops = &sysfs_bin_kfops_rw;
 -		else if (battr->read)
 -			ops = &sysfs_bin_kfops_ro;
 -		else if (battr->write)
 -			ops = &sysfs_bin_kfops_wo;
 -		else
 -			ops = &sysfs_file_kfops_empty;
 -
 -		size = battr->size;
 +	struct sysfs_dirent *dir_sd = kobj->sd;
 +	const struct sysfs_ops *ops;
 +	const void *ns = NULL;
 +	int err;
 +
 +	if (!dir_sd) {
 +		WARN(1, KERN_ERR "sysfs: kobject %s without dirent\n",
 +			kobject_name(kobj));
 +		return -ENOENT;
  	}
  
 -#ifdef CONFIG_DEBUG_LOCK_ALLOC
 -	if (!attr->ignore_lockdep)
 -		key = attr->key ?: (struct lock_class_key *)&attr->skey;
 -#endif
 -	sd = kernfs_create_file_ns_key(dir_sd, attr->name, mode, size,
 -				       ops, (void *)attr, ns, key);
 -	if (IS_ERR(sd)) {
 -		if (PTR_ERR(sd) == -EEXIST)
 -			sysfs_warn_dup(dir_sd, attr->name);
 -		return PTR_ERR(sd);
 +	err = 0;
 +	if (!sysfs_ns_type(dir_sd))
 +		goto out;
 +
 +	err = -EINVAL;
 +	if (!kobj->ktype)
 +		goto out;
 +	ops = kobj->ktype->sysfs_ops;
 +	if (!ops)
 +		goto out;
 +	if (!ops->namespace)
 +		goto out;
 +
 +	err = 0;
 +	ns = ops->namespace(kobj, attr);
 +out:
 +	if (err) {
 +		WARN(1, KERN_ERR "missing sysfs namespace attribute operation for "
 +		     "kobject: %s\n", kobject_name(kobj));
  	}
 -	return 0;
 +	*pns = ns;
 +	return err;
  }
  
 -/**
 - * kernfs_create_file_ns_key - create a file
 - * @parent: directory to create the file in
 - * @name: name of the file
 - * @mode: mode of the file
 - * @size: size of the file
 - * @ops: kernfs operations for the file
 - * @priv: private data for the file
 - * @ns: optional namespace tag of the file
 - * @key: lockdep key for the file's active_ref, %NULL to disable lockdep
 - *
 - * Returns the created node on success, ERR_PTR() value on error.
 - */
 -struct sysfs_dirent *kernfs_create_file_ns_key(struct sysfs_dirent *parent,
 -					       const char *name,
 -					       umode_t mode, loff_t size,
 -					       const struct kernfs_ops *ops,
 -					       void *priv, const void *ns,
 -					       struct lock_class_key *key)
 +int sysfs_add_file_mode(struct sysfs_dirent *dir_sd,
 +			const struct attribute *attr, int type, umode_t amode)
  {
 +	umode_t mode = (amode & S_IALLUGO) | S_IFREG;
  	struct sysfs_addrm_cxt acxt;
  	struct sysfs_dirent *sd;
 +	const void *ns;
  	int rc;
  
 -	sd = sysfs_new_dirent(name, (mode & S_IALLUGO) | S_IFREG,
 -			      SYSFS_KOBJ_ATTR);
 +	rc = sysfs_attr_ns(dir_sd->s_dir.kobj, attr, &ns);
 +	if (rc)
 +		return rc;
 +
 +	sd = sysfs_new_dirent(attr->name, mode, type);
  	if (!sd)
 -		return ERR_PTR(-ENOMEM);
 +		return -ENOMEM;
  
 -	sd->s_attr.ops = ops;
 -	sd->s_attr.size = size;
  	sd->s_ns = ns;
 -	sd->priv = priv;
 -
 -#ifdef CONFIG_DEBUG_LOCK_ALLOC
 -	if (key) {
 -		lockdep_init_map(&sd->dep_map, "s_active", key, 0);
 -		sd->s_flags |= SYSFS_FLAG_LOCKDEP;
 -	}
 -#endif
 +	sd->s_attr.attr = (void *)attr;
 +	sysfs_dirent_init_lockdep(sd);
  
 -	/*
 -	 * sd->s_attr.ops is accesible only while holding active ref.  We
 -	 * need to know whether some ops are implemented outside active
 -	 * ref.  Cache their existence in flags.
 -	 */
 -	if (ops->seq_show)
 -		sd->s_flags |= SYSFS_FLAG_HAS_SEQ_SHOW;
 -	if (ops->mmap)
 -		sd->s_flags |= SYSFS_FLAG_HAS_MMAP;
 -
 -	sysfs_addrm_start(&acxt);
 -	rc = sysfs_add_one(&acxt, sd, parent);
 +	sysfs_addrm_start(&acxt, dir_sd);
 +	rc = sysfs_add_one(&acxt, sd);
  	sysfs_addrm_finish(&acxt);
  
++<<<<<<< HEAD
 +	if (rc)
 +		sysfs_put(sd);
 +
 +	return rc;
++=======
+ 	if (rc) {
+ 		kernfs_put(sd);
+ 		return ERR_PTR(rc);
+ 	}
+ 	return sd;
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  }
  
 +
  int sysfs_add_file(struct sysfs_dirent *dir_sd, const struct attribute *attr,
 -		   bool is_bin)
 +		   int type)
  {
 -	return sysfs_add_file_mode_ns(dir_sd, attr, is_bin, attr->mode, NULL);
 +	return sysfs_add_file_mode(dir_sd, attr, type, attr->mode);
  }
  
 +
  /**
 - * sysfs_create_file_ns - create an attribute file for an object with custom ns
 - * @kobj: object we're creating for
 - * @attr: attribute descriptor
 - * @ns: namespace the new file should belong to
 + *	sysfs_create_file - create an attribute file for an object.
 + *	@kobj:	object we're creating for. 
 + *	@attr:	attribute descriptor.
   */
 -int sysfs_create_file_ns(struct kobject *kobj, const struct attribute *attr,
 -			 const void *ns)
 +
 +int sysfs_create_file(struct kobject * kobj, const struct attribute * attr)
  {
  	BUG_ON(!kobj || !kobj->sd || !attr);
  
@@@ -601,16 -1106,18 +626,30 @@@ int sysfs_add_file_to_group(struct kobj
  	struct sysfs_dirent *dir_sd;
  	int error;
  
++<<<<<<< HEAD
 +	if (group)
 +		dir_sd = sysfs_get_dirent(kobj->sd, NULL, group);
 +	else
 +		dir_sd = sysfs_get(kobj->sd);
++=======
+ 	if (group) {
+ 		dir_sd = kernfs_find_and_get(kobj->sd, group);
+ 	} else {
+ 		dir_sd = kobj->sd;
+ 		kernfs_get(dir_sd);
+ 	}
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  
  	if (!dir_sd)
  		return -ENOENT;
  
++<<<<<<< HEAD
 +	error = sysfs_add_file(dir_sd, attr, SYSFS_KOBJ_ATTR);
 +	sysfs_put(dir_sd);
++=======
+ 	error = sysfs_add_file(dir_sd, attr, false);
+ 	kernfs_put(dir_sd);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  
  	return error;
  }
@@@ -628,26 -1135,18 +667,36 @@@ int sysfs_chmod_file(struct kobject *ko
  {
  	struct sysfs_dirent *sd;
  	struct iattr newattrs;
 +	const void *ns;
  	int rc;
  
++<<<<<<< HEAD
 +	rc = sysfs_attr_ns(kobj, attr, &ns);
 +	if (rc)
 +		return rc;
 +
 +	mutex_lock(&sysfs_mutex);
 +
 +	rc = -ENOENT;
 +	sd = sysfs_find_dirent(kobj->sd, ns, attr->name);
++=======
+ 	sd = kernfs_find_and_get(kobj->sd, attr->name);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	if (!sd)
 -		return -ENOENT;
 +		goto out;
  
  	newattrs.ia_mode = (mode & S_IALLUGO) | (sd->s_mode & ~S_IALLUGO);
  	newattrs.ia_valid = ATTR_MODE;
 +	rc = sysfs_sd_setattr(sd, &newattrs);
  
++<<<<<<< HEAD
 + out:
 +	mutex_unlock(&sysfs_mutex);
++=======
+ 	rc = kernfs_setattr(sd, &newattrs);
+ 
+ 	kernfs_put(sd);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	return rc;
  }
  EXPORT_SYMBOL_GPL(sysfs_chmod_file);
@@@ -689,13 -1187,16 +738,26 @@@ void sysfs_remove_file_from_group(struc
  {
  	struct sysfs_dirent *dir_sd;
  
++<<<<<<< HEAD
 +	if (group)
 +		dir_sd = sysfs_get_dirent(kobj->sd, NULL, group);
 +	else
 +		dir_sd = sysfs_get(kobj->sd);
 +	if (dir_sd) {
 +		sysfs_hash_and_remove(dir_sd, NULL, attr->name);
 +		sysfs_put(dir_sd);
++=======
+ 	if (group) {
+ 		dir_sd = kernfs_find_and_get(kobj->sd, group);
+ 	} else {
+ 		dir_sd = kobj->sd;
+ 		kernfs_get(dir_sd);
+ 	}
+ 
+ 	if (dir_sd) {
+ 		kernfs_remove_by_name(dir_sd, attr->name);
+ 		kernfs_put(dir_sd);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	}
  }
  EXPORT_SYMBOL_GPL(sysfs_remove_file_from_group);
diff --cc fs/sysfs/group.c
index 1a6e16c0db91,7177532b8f7b..000000000000
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@@ -101,18 -100,21 +101,18 @@@ static int internal_create_group(struc
  		return -EINVAL;
  	}
  	if (grp->name) {
 -		sd = kernfs_create_dir(kobj->sd, grp->name, kobj);
 -		if (IS_ERR(sd)) {
 -			if (PTR_ERR(sd) == -EEXIST)
 -				sysfs_warn_dup(kobj->sd, grp->name);
 -			return PTR_ERR(sd);
 -		}
 +		error = sysfs_create_subdir(kobj, grp->name, &sd);
 +		if (error)
 +			return error;
  	} else
  		sd = kobj->sd;
- 	sysfs_get(sd);
+ 	kernfs_get(sd);
  	error = create_files(sd, kobj, grp, update);
  	if (error) {
  		if (grp->name)
 -			kernfs_remove(sd);
 +			sysfs_remove_subdir(sd);
  	}
- 	sysfs_put(sd);
+ 	kernfs_put(sd);
  	return error;
  }
  
@@@ -206,7 -208,7 +206,11 @@@ void sysfs_remove_group(struct kobject 
  	struct sysfs_dirent *sd;
  
  	if (grp->name) {
++<<<<<<< HEAD
 +		sd = sysfs_get_dirent(dir_sd, NULL, grp->name);
++=======
+ 		sd = kernfs_find_and_get(dir_sd, grp->name);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  		if (!sd) {
  			WARN(!sd, KERN_WARNING
  			     "sysfs group %p not found for kobject '%s'\n",
@@@ -218,9 -222,9 +224,9 @@@
  
  	remove_files(sd, kobj, grp);
  	if (grp->name)
 -		kernfs_remove(sd);
 +		sysfs_remove_subdir(sd);
  
- 	sysfs_put(sd);
+ 	kernfs_put(sd);
  }
  EXPORT_SYMBOL_GPL(sysfs_remove_group);
  
@@@ -261,17 -265,17 +267,21 @@@ int sysfs_merge_group(struct kobject *k
  	struct attribute *const *attr;
  	int i;
  
++<<<<<<< HEAD
 +	dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
++=======
+ 	dir_sd = kernfs_find_and_get(kobj->sd, grp->name);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	if (!dir_sd)
  		return -ENOENT;
  
  	for ((i = 0, attr = grp->attrs); *attr && !error; (++i, ++attr))
 -		error = sysfs_add_file(dir_sd, *attr, false);
 +		error = sysfs_add_file(dir_sd, *attr, SYSFS_KOBJ_ATTR);
  	if (error) {
  		while (--i >= 0)
 -			kernfs_remove_by_name(dir_sd, (*--attr)->name);
 +			sysfs_hash_and_remove(dir_sd, NULL, (*--attr)->name);
  	}
- 	sysfs_put(dir_sd);
+ 	kernfs_put(dir_sd);
  
  	return error;
  }
@@@ -288,11 -292,11 +298,19 @@@ void sysfs_unmerge_group(struct kobjec
  	struct sysfs_dirent *dir_sd;
  	struct attribute *const *attr;
  
++<<<<<<< HEAD
 +	dir_sd = sysfs_get_dirent(kobj->sd, NULL, grp->name);
 +	if (dir_sd) {
 +		for (attr = grp->attrs; *attr; ++attr)
 +			sysfs_hash_and_remove(dir_sd, NULL, (*attr)->name);
 +		sysfs_put(dir_sd);
++=======
+ 	dir_sd = kernfs_find_and_get(kobj->sd, grp->name);
+ 	if (dir_sd) {
+ 		for (attr = grp->attrs; *attr; ++attr)
+ 			kernfs_remove_by_name(dir_sd, (*attr)->name);
+ 		kernfs_put(dir_sd);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	}
  }
  EXPORT_SYMBOL_GPL(sysfs_unmerge_group);
@@@ -310,7 -314,7 +328,11 @@@ int sysfs_add_link_to_group(struct kobj
  	struct sysfs_dirent *dir_sd;
  	int error = 0;
  
++<<<<<<< HEAD
 +	dir_sd = sysfs_get_dirent(kobj->sd, NULL, group_name);
++=======
+ 	dir_sd = kernfs_find_and_get(kobj->sd, group_name);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	if (!dir_sd)
  		return -ENOENT;
  
@@@ -332,10 -336,10 +354,17 @@@ void sysfs_remove_link_from_group(struc
  {
  	struct sysfs_dirent *dir_sd;
  
++<<<<<<< HEAD
 +	dir_sd = sysfs_get_dirent(kobj->sd, NULL, group_name);
 +	if (dir_sd) {
 +		sysfs_hash_and_remove(dir_sd, NULL, link_name);
 +		sysfs_put(dir_sd);
++=======
+ 	dir_sd = kernfs_find_and_get(kobj->sd, group_name);
+ 	if (dir_sd) {
+ 		kernfs_remove_by_name(dir_sd, link_name);
+ 		kernfs_put(dir_sd);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	}
  }
  EXPORT_SYMBOL_GPL(sysfs_remove_link_from_group);
diff --cc fs/sysfs/inode.c
index 270a1324c133,bfe4478f82bf..000000000000
--- a/fs/sysfs/inode.c
+++ b/fs/sysfs/inode.c
@@@ -237,9 -254,8 +237,14 @@@ int sysfs_getattr(struct vfsmount *mnt
  
  static void sysfs_init_inode(struct sysfs_dirent *sd, struct inode *inode)
  {
++<<<<<<< HEAD
 +	struct bin_attribute *bin_attr;
 +
 +	inode->i_private = sysfs_get(sd);
++=======
+ 	kernfs_get(sd);
+ 	inode->i_private = sd;
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	inode->i_mapping->a_ops = &sysfs_aops;
  	inode->i_mapping->backing_dev_info = &sysfs_backing_dev_info;
  	inode->i_op = &sysfs_inode_operations;
@@@ -309,36 -320,11 +314,36 @@@ void sysfs_evict_inode(struct inode *in
  {
  	struct sysfs_dirent *sd  = inode->i_private;
  
 -	truncate_inode_pages(&inode->i_data, 0);
 +	truncate_inode_pages_final(&inode->i_data);
  	clear_inode(inode);
- 	sysfs_put(sd);
+ 	kernfs_put(sd);
  }
  
 +int sysfs_hash_and_remove(struct sysfs_dirent *dir_sd, const void *ns, const char *name)
 +{
 +	struct sysfs_addrm_cxt acxt;
 +	struct sysfs_dirent *sd;
 +
 +	if (!dir_sd) {
 +		WARN(1, KERN_WARNING "sysfs: can not remove '%s', no directory\n",
 +			name);
 +		return -ENOENT;
 +	}
 +
 +	sysfs_addrm_start(&acxt, dir_sd);
 +
 +	sd = sysfs_find_dirent(dir_sd, ns, name);
 +	if (sd)
 +		sysfs_remove_one(&acxt, sd);
 +
 +	sysfs_addrm_finish(&acxt);
 +
 +	if (sd)
 +		return 0;
 +	else
 +		return -ENOENT;
 +}
 +
  int sysfs_permission(struct inode *inode, int mask)
  {
  	struct sysfs_dirent *sd;
diff --cc fs/sysfs/symlink.c
index 8c940df97a52,b137aa3a486c..000000000000
--- a/fs/sysfs/symlink.c
+++ b/fs/sysfs/symlink.c
@@@ -21,6 -21,43 +21,46 @@@
  
  #include "sysfs.h"
  
++<<<<<<< HEAD
++=======
+ /**
+  * kernfs_create_link - create a symlink
+  * @parent: directory to create the symlink in
+  * @name: name of the symlink
+  * @target: target node for the symlink to point to
+  *
+  * Returns the created node on success, ERR_PTR() value on error.
+  */
+ struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
+ 					const char *name,
+ 					struct sysfs_dirent *target)
+ {
+ 	struct sysfs_dirent *sd;
+ 	struct sysfs_addrm_cxt acxt;
+ 	int error;
+ 
+ 	sd = sysfs_new_dirent(name, S_IFLNK|S_IRWXUGO, SYSFS_KOBJ_LINK);
+ 	if (!sd)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	if (parent->s_flags & SYSFS_FLAG_NS)
+ 		sd->s_ns = target->s_ns;
+ 	sd->s_symlink.target_sd = target;
+ 	kernfs_get(target);	/* ref owned by symlink */
+ 
+ 	sysfs_addrm_start(&acxt);
+ 	error = sysfs_add_one(&acxt, sd, parent);
+ 	sysfs_addrm_finish(&acxt);
+ 
+ 	if (!error)
+ 		return sd;
+ 
+ 	kernfs_put(sd);
+ 	return ERR_PTR(error);
+ }
+ 
+ 
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  static int sysfs_do_create_link_sd(struct sysfs_dirent *parent_sd,
  				   struct kobject *target,
  				   const char *name, int warn)
@@@ -33,57 -66,30 +73,78 @@@
  
  	BUG_ON(!name || !parent_sd);
  
 -	/*
 -	 * We don't own @target and it may be removed at any time.
 -	 * Synchronize using sysfs_symlink_target_lock.  See
 -	 * sysfs_remove_dir() for details.
 +	/* target->sd can go away beneath us but is protected with
 +	 * sysfs_assoc_lock.  Fetch target_sd from it.
  	 */
++<<<<<<< HEAD
 +	spin_lock(&sysfs_assoc_lock);
 +	if (target->sd)
 +		target_sd = sysfs_get(target->sd);
 +	spin_unlock(&sysfs_assoc_lock);
++=======
+ 	spin_lock(&sysfs_symlink_target_lock);
+ 	if (target->sd) {
+ 		target_sd = target->sd;
+ 		kernfs_get(target_sd);
+ 	}
+ 	spin_unlock(&sysfs_symlink_target_lock);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  
 +	error = -ENOENT;
  	if (!target_sd)
 -		return -ENOENT;
 +		goto out_put;
 +
++<<<<<<< HEAD
 +	error = -ENOMEM;
 +	sd = sysfs_new_dirent(name, S_IFLNK|S_IRWXUGO, SYSFS_KOBJ_LINK);
 +	if (!sd)
 +		goto out_put;
 +
 +	ns_type = sysfs_ns_type(parent_sd);
 +	if (ns_type)
 +		sd->s_ns = target->ktype->namespace(target);
 +	sd->s_symlink.target_sd = target_sd;
 +	target_sd = NULL;	/* reference is now owned by the symlink */
 +
 +	sysfs_addrm_start(&acxt, parent_sd);
 +	/* Symlinks must be between directories with the same ns_type */
 +	if (!ns_type ||
 +	    (ns_type == sysfs_ns_type(sd->s_symlink.target_sd->s_parent))) {
 +		if (warn)
 +			error = sysfs_add_one(&acxt, sd);
 +		else
 +			error = __sysfs_add_one(&acxt, sd);
 +	} else {
 +		error = -EINVAL;
 +		WARN(1, KERN_WARNING
 +			"sysfs: symlink across ns_types %s/%s -> %s/%s\n",
 +			parent_sd->s_name,
 +			sd->s_name,
 +			sd->s_symlink.target_sd->s_parent->s_name,
 +			sd->s_symlink.target_sd->s_name);
 +	}
 +	sysfs_addrm_finish(&acxt);
 +
 +	if (error)
 +		goto out_put;
 +
 +	return 0;
  
 + out_put:
 +	sysfs_put(target_sd);
 +	sysfs_put(sd);
 +	return error;
++=======
+ 	sd = kernfs_create_link(parent_sd, name, target_sd);
+ 	kernfs_put(target_sd);
+ 
+ 	if (!IS_ERR(sd))
+ 		return 0;
+ 
+ 	if (warn && PTR_ERR(sd) == -EEXIST)
+ 		sysfs_warn_dup(parent_sd, name);
+ 	return PTR_ERR(sd);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  }
  
  /**
@@@ -204,25 -218,23 +265,29 @@@ int sysfs_rename_link(struct kobject *k
  		old_ns = targ->sd->s_ns;
  
  	result = -ENOENT;
++<<<<<<< HEAD
 +	sd = sysfs_get_dirent(parent_sd, old_ns, old);
++=======
+ 	sd = kernfs_find_and_get_ns(parent_sd, old, old_ns);
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  	if (!sd)
  		goto out;
  
  	result = -EINVAL;
  	if (sysfs_type(sd) != SYSFS_KOBJ_LINK)
  		goto out;
 -	if (sd->s_symlink.target_sd->priv != targ)
 +	if (sd->s_symlink.target_sd->s_dir.kobj != targ)
  		goto out;
  
 -	result = kernfs_rename_ns(sd, parent_sd, new, new_ns);
 +	if (sysfs_ns_type(parent_sd))
 +		new_ns = targ->ktype->namespace(targ);
 +
 +	result = sysfs_rename(sd, parent_sd, new_ns, new);
  
  out:
- 	sysfs_put(sd);
+ 	kernfs_put(sd);
  	return result;
  }
 -EXPORT_SYMBOL_GPL(sysfs_rename_link_ns);
  
  static int sysfs_get_target_path(struct sysfs_dirent *parent_sd,
  				 struct sysfs_dirent *target_sd, char *path)
diff --cc fs/sysfs/sysfs.h
index d1e4043eb0c3,85315e228408..000000000000
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@@ -162,50 -133,16 +162,55 @@@ extern const struct dentry_operations s
  extern const struct file_operations sysfs_dir_operations;
  extern const struct inode_operations sysfs_dir_inode_operations;
  
 +struct dentry *sysfs_get_dentry(struct sysfs_dirent *sd);
  struct sysfs_dirent *sysfs_get_active(struct sysfs_dirent *sd);
  void sysfs_put_active(struct sysfs_dirent *sd);
 -void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt);
 -void sysfs_warn_dup(struct sysfs_dirent *parent, const char *name);
 -int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd,
 -		  struct sysfs_dirent *parent_sd);
 +void sysfs_addrm_start(struct sysfs_addrm_cxt *acxt,
 +		       struct sysfs_dirent *parent_sd);
 +int __sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
 +int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
 +void sysfs_remove_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd);
  void sysfs_addrm_finish(struct sysfs_addrm_cxt *acxt);
  
++<<<<<<< HEAD
 +struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,
 +				       const void *ns,
 +				       const unsigned char *name);
 +struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd,
 +				      const void *ns,
 +				      const unsigned char *name);
  struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type);
  
 +void release_sysfs_dirent(struct sysfs_dirent *sd);
 +
 +int sysfs_create_subdir(struct kobject *kobj, const char *name,
 +			struct sysfs_dirent **p_sd);
 +void sysfs_remove_subdir(struct sysfs_dirent *sd);
 +
 +int sysfs_rename(struct sysfs_dirent *sd,
 +	struct sysfs_dirent *new_parent_sd, const void *ns, const char *new_name);
 +
 +static inline struct sysfs_dirent *__sysfs_get(struct sysfs_dirent *sd)
 +{
 +	if (sd) {
 +		WARN_ON(!atomic_read(&sd->s_count));
 +		atomic_inc(&sd->s_count);
 +	}
 +	return sd;
 +}
 +#define sysfs_get(sd) __sysfs_get(sd)
 +
 +static inline void __sysfs_put(struct sysfs_dirent *sd)
 +{
 +	if (sd && atomic_dec_and_test(&sd->s_count))
 +		release_sysfs_dirent(sd);
 +}
 +#define sysfs_put(sd) __sysfs_put(sd)
 +
++=======
++struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type);
++
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  /*
   * inode.c
   */
diff --cc include/linux/kernfs.h
index 254b9e872b09,fd8f574ef2fe..000000000000
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@@ -7,6 -7,181 +7,173 @@@
  #ifndef __LINUX_KERNFS_H
  #define __LINUX_KERNFS_H
  
 -#include <linux/kernel.h>
 -#include <linux/err.h>
 -#include <linux/list.h>
 -#include <linux/mutex.h>
 -#include <linux/lockdep.h>
 -
 -struct file;
 -struct iattr;
 -struct seq_file;
 -struct vm_area_struct;
 -
  struct sysfs_dirent;
  
++<<<<<<< HEAD
++=======
+ struct sysfs_open_file {
+ 	/* published fields */
+ 	struct sysfs_dirent	*sd;
+ 	struct file		*file;
+ 
+ 	/* private fields, do not use outside kernfs proper */
+ 	struct mutex		mutex;
+ 	int			event;
+ 	struct list_head	list;
+ 
+ 	bool			mmapped;
+ 	const struct vm_operations_struct *vm_ops;
+ };
+ 
+ struct kernfs_ops {
+ 	/*
+ 	 * Read is handled by either seq_file or raw_read().
+ 	 *
+ 	 * If seq_show() is present, seq_file path is active.  Other seq
+ 	 * operations are optional and if not implemented, the behavior is
+ 	 * equivalent to single_open().  @sf->private points to the
+ 	 * associated sysfs_open_file.
+ 	 *
+ 	 * read() is bounced through kernel buffer and a read larger than
+ 	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
+ 	 */
+ 	int (*seq_show)(struct seq_file *sf, void *v);
+ 
+ 	void *(*seq_start)(struct seq_file *sf, loff_t *ppos);
+ 	void *(*seq_next)(struct seq_file *sf, void *v, loff_t *ppos);
+ 	void (*seq_stop)(struct seq_file *sf, void *v);
+ 
+ 	ssize_t (*read)(struct sysfs_open_file *of, char *buf, size_t bytes,
+ 			loff_t off);
+ 
+ 	/*
+ 	 * write() is bounced through kernel buffer and a write larger than
+ 	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
+ 	 */
+ 	ssize_t (*write)(struct sysfs_open_file *of, char *buf, size_t bytes,
+ 			 loff_t off);
+ 
+ 	int (*mmap)(struct sysfs_open_file *of, struct vm_area_struct *vma);
+ 
+ #ifdef CONFIG_DEBUG_LOCK_ALLOC
+ 	struct lock_class_key	lockdep_key;
+ #endif
+ };
+ 
+ #ifdef CONFIG_SYSFS
+ 
+ struct sysfs_dirent *kernfs_find_and_get_ns(struct sysfs_dirent *parent,
+ 					    const char *name, const void *ns);
+ void kernfs_get(struct sysfs_dirent *sd);
+ void kernfs_put(struct sysfs_dirent *sd);
+ 
+ struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
+ 					  const char *name, void *priv,
+ 					  const void *ns);
+ struct sysfs_dirent *kernfs_create_file_ns_key(struct sysfs_dirent *parent,
+ 					       const char *name,
+ 					       umode_t mode, loff_t size,
+ 					       const struct kernfs_ops *ops,
+ 					       void *priv, const void *ns,
+ 					       struct lock_class_key *key);
+ struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
+ 					const char *name,
+ 					struct sysfs_dirent *target);
+ void kernfs_remove(struct sysfs_dirent *sd);
+ int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
+ 			     const void *ns);
+ int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
+ 		     const char *new_name, const void *new_ns);
+ void kernfs_enable_ns(struct sysfs_dirent *sd);
+ int kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr);
+ void kernfs_notify(struct sysfs_dirent *sd);
+ 
+ #else	/* CONFIG_SYSFS */
+ 
+ static inline struct sysfs_dirent *
+ kernfs_find_and_get_ns(struct sysfs_dirent *parent, const char *name,
+ 		       const void *ns)
+ { return NULL; }
+ 
+ static inline void kernfs_get(struct sysfs_dirent *sd) { }
+ static inline void kernfs_put(struct sysfs_dirent *sd) { }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_dir_ns(struct sysfs_dirent *parent, const char *name, void *priv,
+ 		     const void *ns)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_file_ns_key(struct sysfs_dirent *parent, const char *name,
+ 			  umode_t mode, loff_t size,
+ 			  const struct kernfs_ops *ops, void *priv,
+ 			  const void *ns, struct lock_class_key *key)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_link(struct sysfs_dirent *parent, const char *name,
+ 		   struct sysfs_dirent *target)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline void kernfs_remove(struct sysfs_dirent *sd) { }
+ 
+ static inline int kernfs_remove_by_name_ns(struct sysfs_dirent *parent,
+ 					   const char *name, const void *ns)
+ { return -ENOSYS; }
+ 
+ static inline int kernfs_rename_ns(struct sysfs_dirent *sd,
+ 				   struct sysfs_dirent *new_parent,
+ 				   const char *new_name, const void *new_ns)
+ { return -ENOSYS; }
+ 
+ static inline void kernfs_enable_ns(struct sysfs_dirent *sd) { }
+ 
+ static inline int kernfs_setattr(struct sysfs_dirent *sd,
+ 				 const struct iattr *iattr)
+ { return -ENOSYS; }
+ 
+ static inline void kernfs_notify(struct sysfs_dirent *sd) { }
+ 
+ #endif	/* CONFIG_SYSFS */
+ 
+ static inline struct sysfs_dirent *
+ kernfs_find_and_get(struct sysfs_dirent *sd, const char *name)
+ {
+ 	return kernfs_find_and_get_ns(sd, name, NULL);
+ }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_dir(struct sysfs_dirent *parent, const char *name, void *priv)
+ {
+ 	return kernfs_create_dir_ns(parent, name, priv, NULL);
+ }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_file_ns(struct sysfs_dirent *parent, const char *name,
+ 		      umode_t mode, loff_t size, const struct kernfs_ops *ops,
+ 		      void *priv, const void *ns)
+ {
+ 	struct lock_class_key *key = NULL;
+ 
+ #ifdef CONFIG_DEBUG_LOCK_ALLOC
+ 	key = (struct lock_class_key *)&ops->lockdep_key;
+ #endif
+ 	return kernfs_create_file_ns_key(parent, name, mode, size, ops, priv,
+ 					 ns, key);
+ }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_file(struct sysfs_dirent *parent, const char *name, umode_t mode,
+ 		   loff_t size, const struct kernfs_ops *ops, void *priv)
+ {
+ 	return kernfs_create_file_ns(parent, name, mode, size, ops, priv, NULL);
+ }
+ 
+ static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,
+ 					const char *name)
+ {
+ 	return kernfs_remove_by_name_ns(parent, name, NULL);
+ }
+ 
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  #endif	/* __LINUX_KERNFS_H */
diff --cc include/linux/sysfs.h
index a0524344cf5a,cd8f90bf51a7..000000000000
--- a/include/linux/sysfs.h
+++ b/include/linux/sysfs.h
@@@ -239,17 -241,8 +239,20 @@@ int sysfs_add_link_to_group(struct kobj
  			    struct kobject *target, const char *link_name);
  void sysfs_remove_link_from_group(struct kobject *kobj, const char *group_name,
  				  const char *link_name);
 +int __compat_only_sysfs_link_entry_to_kobj(struct kobject *kobj,
 +				      struct kobject *target_kobj,
 +				      const char *target_name);
  
  void sysfs_notify(struct kobject *kobj, const char *dir, const char *attr);
++<<<<<<< HEAD
 +void sysfs_notify_dirent(struct sysfs_dirent *sd);
 +struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd,
 +				      const void *ns,
 +				      const unsigned char *name);
 +struct sysfs_dirent *sysfs_get(struct sysfs_dirent *sd);
 +void sysfs_put(struct sysfs_dirent *sd);
++=======
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  
  int __must_check sysfs_init(void);
  
@@@ -422,23 -412,6 +425,26 @@@ static inline void sysfs_notify(struct 
  				const char *attr)
  {
  }
++<<<<<<< HEAD
 +static inline void sysfs_notify_dirent(struct sysfs_dirent *sd)
 +{
 +}
 +static inline
 +struct sysfs_dirent *sysfs_get_dirent(struct sysfs_dirent *parent_sd,
 +				      const void *ns,
 +				      const unsigned char *name)
 +{
 +	return NULL;
 +}
 +static inline struct sysfs_dirent *sysfs_get(struct sysfs_dirent *sd)
 +{
 +	return NULL;
 +}
 +static inline void sysfs_put(struct sysfs_dirent *sd)
 +{
 +}
++=======
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  
  static inline int __must_check sysfs_init(void)
  {
@@@ -447,4 -420,44 +453,47 @@@
  
  #endif /* CONFIG_SYSFS */
  
++<<<<<<< HEAD
++=======
+ static inline int __must_check sysfs_create_file(struct kobject *kobj,
+ 						 const struct attribute *attr)
+ {
+ 	return sysfs_create_file_ns(kobj, attr, NULL);
+ }
+ 
+ static inline void sysfs_remove_file(struct kobject *kobj,
+ 				     const struct attribute *attr)
+ {
+ 	return sysfs_remove_file_ns(kobj, attr, NULL);
+ }
+ 
+ static inline int sysfs_rename_link(struct kobject *kobj, struct kobject *target,
+ 				    const char *old_name, const char *new_name)
+ {
+ 	return sysfs_rename_link_ns(kobj, target, old_name, new_name, NULL);
+ }
+ 
+ static inline void sysfs_notify_dirent(struct sysfs_dirent *sd)
+ {
+ 	kernfs_notify(sd);
+ }
+ 
+ static inline struct sysfs_dirent *
+ sysfs_get_dirent(struct sysfs_dirent *parent_sd, const unsigned char *name)
+ {
+ 	return kernfs_find_and_get(parent_sd, name);
+ }
+ 
+ static inline struct sysfs_dirent *sysfs_get(struct sysfs_dirent *sd)
+ {
+ 	kernfs_get(sd);
+ 	return sd;
+ }
+ 
+ static inline void sysfs_put(struct sysfs_dirent *sd)
+ {
+ 	kernfs_put(sd);
+ }
+ 
++>>>>>>> ccf73cf336dc (sysfs, kernfs: introduce kernfs[_find_and]_get() and kernfs_put())
  #endif /* _SYSFS_H_ */
* Unmerged path fs/sysfs/dir.c
* Unmerged path fs/sysfs/file.c
* Unmerged path fs/sysfs/group.c
* Unmerged path fs/sysfs/inode.c
diff --git a/fs/sysfs/mount.c b/fs/sysfs/mount.c
index afd83273e6ce..0416890ef8d0 100644
--- a/fs/sysfs/mount.c
+++ b/fs/sysfs/mount.c
@@ -189,17 +189,3 @@ out_err:
 	sysfs_dir_cachep = NULL;
 	goto out;
 }
-
-#undef sysfs_get
-struct sysfs_dirent *sysfs_get(struct sysfs_dirent *sd)
-{
-	return __sysfs_get(sd);
-}
-EXPORT_SYMBOL_GPL(sysfs_get);
-
-#undef sysfs_put
-void sysfs_put(struct sysfs_dirent *sd)
-{
-	__sysfs_put(sd);
-}
-EXPORT_SYMBOL_GPL(sysfs_put);
* Unmerged path fs/sysfs/symlink.c
* Unmerged path fs/sysfs/sysfs.h
* Unmerged path include/linux/kernfs.h
* Unmerged path include/linux/sysfs.h
