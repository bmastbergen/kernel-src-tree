net: sched: fix tc_should_offload for specific clsact classes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: fix tc_should_offload for specific clsact classes (Jonathan Toppins) [1393375]
Rebuild_FUZZ: 95.73%
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 92c075dbdeed02bdf293cb0f513bad70aa714b8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/92c075db.failed

When offloading classifiers such as u32 or flower to hardware, and the
qdisc is clsact (TC_H_CLSACT), then we need to differentiate its classes,
since not all of them handle ingress, therefore we must leave those in
software path. Add a .tcf_cl_offload() callback, so we can generically
handle them, tested on ixgbe.

Fixes: 10cbc6843446 ("net/sched: cls_flower: Hardware offloaded filters statistics support")
Fixes: 5b33f48842fa ("net/flower: Introduce hardware offload support")
Fixes: a1b7c5fd7fe9 ("net: sched: add cls_u32 offload hooks for netdevs")
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: John Fastabend <john.r.fastabend@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 92c075dbdeed02bdf293cb0f513bad70aa714b8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_cls.h
#	include/net/sch_generic.h
#	net/sched/cls_flower.c
#	net/sched/cls_u32.c
#	net/sched/sch_ingress.c
diff --cc include/net/pkt_cls.h
index b606c03c3836,3722dda0199d..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -392,9 -392,54 +392,28 @@@ struct tc_cls_u32_offload 
  	};
  };
  
++<<<<<<< HEAD
 +static inline bool tc_should_offload(struct net_device *dev)
 +{
 +	return dev->netdev_ops->ndo_setup_tc;
++=======
+ static inline bool tc_should_offload(const struct net_device *dev,
+ 				     const struct tcf_proto *tp, u32 flags)
+ {
+ 	const struct Qdisc *sch = tp->q;
+ 	const struct Qdisc_class_ops *cops = sch->ops->cl_ops;
+ 
+ 	if (!(dev->features & NETIF_F_HW_TC))
+ 		return false;
+ 	if (flags & TCA_CLS_FLAGS_SKIP_HW)
+ 		return false;
+ 	if (!dev->netdev_ops->ndo_setup_tc)
+ 		return false;
+ 	if (cops && cops->tcf_cl_offload)
+ 		return cops->tcf_cl_offload(tp->classid);
+ 
+ 	return true;
++>>>>>>> 92c075dbdeed (net: sched: fix tc_should_offload for specific clsact classes)
  }
  
 -static inline bool tc_skip_sw(u32 flags)
 -{
 -	return (flags & TCA_CLS_FLAGS_SKIP_SW) ? true : false;
 -}
 -
 -/* SKIP_HW and SKIP_SW are mutually exclusive flags. */
 -static inline bool tc_flags_valid(u32 flags)
 -{
 -	if (flags & ~(TCA_CLS_FLAGS_SKIP_HW | TCA_CLS_FLAGS_SKIP_SW))
 -		return false;
 -
 -	if (!(flags ^ (TCA_CLS_FLAGS_SKIP_HW | TCA_CLS_FLAGS_SKIP_SW)))
 -		return false;
 -
 -	return true;
 -}
 -
 -enum tc_fl_command {
 -	TC_CLSFLOWER_REPLACE,
 -	TC_CLSFLOWER_DESTROY,
 -	TC_CLSFLOWER_STATS,
 -};
 -
 -struct tc_cls_flower_offload {
 -	enum tc_fl_command command;
 -	unsigned long cookie;
 -	struct flow_dissector *dissector;
 -	struct fl_flow_key *mask;
 -	struct fl_flow_key *key;
 -	struct tcf_exts *exts;
 -};
 -
  #endif
diff --cc include/net/sch_generic.h
index 96bed6f81e99,62d553184e91..000000000000
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@@ -162,7 -167,8 +162,12 @@@ struct Qdisc_class_ops 
  	void			(*walk)(struct Qdisc *, struct qdisc_walker * arg);
  
  	/* Filter manipulation */
++<<<<<<< HEAD
 +	struct tcf_proto **	(*tcf_chain)(struct Qdisc *, unsigned long);
++=======
+ 	struct tcf_proto __rcu ** (*tcf_chain)(struct Qdisc *, unsigned long);
+ 	bool			(*tcf_cl_offload)(u32 classid);
++>>>>>>> 92c075dbdeed (net: sched: fix tc_should_offload for specific clsact classes)
  	unsigned long		(*bind_tcf)(struct Qdisc *, unsigned long,
  					u32 classid);
  	void			(*unbind_tcf)(struct Qdisc *, unsigned long);
diff --cc net/sched/cls_u32.c
index 9fba35eb571c,27b99fd774d7..000000000000
--- a/net/sched/cls_u32.c
+++ b/net/sched/cls_u32.c
@@@ -431,7 -440,7 +431,11 @@@ static void u32_remove_hw_knode(struct 
  	offload.type = TC_SETUP_CLSU32;
  	offload.cls_u32 = &u32_offload;
  
++<<<<<<< HEAD
 +	if (tc_should_offload(dev)) {
++=======
+ 	if (tc_should_offload(dev, tp, 0)) {
++>>>>>>> 92c075dbdeed (net: sched: fix tc_should_offload for specific clsact classes)
  		offload.cls_u32->command = TC_CLSU32_DELETE_KNODE;
  		offload.cls_u32->knode.handle = handle;
  		dev->netdev_ops->ndo_setup_tc(dev, tp->q->handle,
@@@ -444,6 -455,10 +448,13 @@@ static void u32_replace_hw_hnode(struc
  	struct net_device *dev = tp->q->dev_queue->dev;
  	struct tc_cls_u32_offload u32_offload = {0};
  	struct tc_to_netdev offload;
++<<<<<<< HEAD
++=======
+ 	int err;
+ 
+ 	if (!tc_should_offload(dev, tp, flags))
+ 		return tc_skip_sw(flags) ? -EINVAL : 0;
++>>>>>>> 92c075dbdeed (net: sched: fix tc_should_offload for specific clsact classes)
  
  	offload.type = TC_SETUP_CLSU32;
  	offload.cls_u32 = &u32_offload;
@@@ -468,7 -485,7 +479,11 @@@ static void u32_clear_hw_hnode(struct t
  	offload.type = TC_SETUP_CLSU32;
  	offload.cls_u32 = &u32_offload;
  
++<<<<<<< HEAD
 +	if (tc_should_offload(dev)) {
++=======
+ 	if (tc_should_offload(dev, tp, 0)) {
++>>>>>>> 92c075dbdeed (net: sched: fix tc_should_offload for specific clsact classes)
  		offload.cls_u32->command = TC_CLSU32_DELETE_HNODE;
  		offload.cls_u32->hnode.divisor = h->divisor;
  		offload.cls_u32->hnode.handle = h->handle;
@@@ -488,7 -508,7 +503,11 @@@ static void u32_replace_hw_knode(struc
  	offload.type = TC_SETUP_CLSU32;
  	offload.cls_u32 = &u32_offload;
  
++<<<<<<< HEAD
 +	if (tc_should_offload(dev)) {
++=======
+ 	if (tc_should_offload(dev, tp, flags)) {
++>>>>>>> 92c075dbdeed (net: sched: fix tc_should_offload for specific clsact classes)
  		offload.cls_u32->command = TC_CLSU32_REPLACE_KNODE;
  		offload.cls_u32->knode.handle = n->handle;
  		offload.cls_u32->knode.fshift = n->fshift;
diff --cc net/sched/sch_ingress.c
index f92df45a3719,8fe6999b642a..000000000000
--- a/net/sched/sch_ingress.c
+++ b/net/sched/sch_ingress.c
@@@ -127,9 -105,96 +133,90 @@@ static struct Qdisc_ops ingress_qdisc_o
  	.owner		=	THIS_MODULE,
  };
  
++<<<<<<< HEAD
++=======
+ static unsigned long clsact_get(struct Qdisc *sch, u32 classid)
+ {
+ 	switch (TC_H_MIN(classid)) {
+ 	case TC_H_MIN(TC_H_MIN_INGRESS):
+ 	case TC_H_MIN(TC_H_MIN_EGRESS):
+ 		return TC_H_MIN(classid);
+ 	default:
+ 		return 0;
+ 	}
+ }
+ 
+ static bool clsact_cl_offload(u32 classid)
+ {
+ 	return TC_H_MIN(classid) == TC_H_MIN(TC_H_MIN_INGRESS);
+ }
+ 
+ static unsigned long clsact_bind_filter(struct Qdisc *sch,
+ 					unsigned long parent, u32 classid)
+ {
+ 	return clsact_get(sch, classid);
+ }
+ 
+ static struct tcf_proto __rcu **clsact_find_tcf(struct Qdisc *sch,
+ 						unsigned long cl)
+ {
+ 	struct net_device *dev = qdisc_dev(sch);
+ 
+ 	switch (cl) {
+ 	case TC_H_MIN(TC_H_MIN_INGRESS):
+ 		return &dev->ingress_cl_list;
+ 	case TC_H_MIN(TC_H_MIN_EGRESS):
+ 		return &dev->egress_cl_list;
+ 	default:
+ 		return NULL;
+ 	}
+ }
+ 
+ static int clsact_init(struct Qdisc *sch, struct nlattr *opt)
+ {
+ 	net_inc_ingress_queue();
+ 	net_inc_egress_queue();
+ 
+ 	sch->flags |= TCQ_F_CPUSTATS;
+ 
+ 	return 0;
+ }
+ 
+ static void clsact_destroy(struct Qdisc *sch)
+ {
+ 	struct net_device *dev = qdisc_dev(sch);
+ 
+ 	tcf_destroy_chain(&dev->ingress_cl_list);
+ 	tcf_destroy_chain(&dev->egress_cl_list);
+ 
+ 	net_dec_ingress_queue();
+ 	net_dec_egress_queue();
+ }
+ 
+ static const struct Qdisc_class_ops clsact_class_ops = {
+ 	.leaf		=	ingress_leaf,
+ 	.get		=	clsact_get,
+ 	.put		=	ingress_put,
+ 	.walk		=	ingress_walk,
+ 	.tcf_chain	=	clsact_find_tcf,
+ 	.tcf_cl_offload	=	clsact_cl_offload,
+ 	.bind_tcf	=	clsact_bind_filter,
+ 	.unbind_tcf	=	ingress_put,
+ };
+ 
+ static struct Qdisc_ops clsact_qdisc_ops __read_mostly = {
+ 	.cl_ops		=	&clsact_class_ops,
+ 	.id		=	"clsact",
+ 	.init		=	clsact_init,
+ 	.destroy	=	clsact_destroy,
+ 	.dump		=	ingress_dump,
+ 	.owner		=	THIS_MODULE,
+ };
+ 
++>>>>>>> 92c075dbdeed (net: sched: fix tc_should_offload for specific clsact classes)
  static int __init ingress_module_init(void)
  {
 -	int ret;
 -
 -	ret = register_qdisc(&ingress_qdisc_ops);
 -	if (!ret) {
 -		ret = register_qdisc(&clsact_qdisc_ops);
 -		if (ret)
 -			unregister_qdisc(&ingress_qdisc_ops);
 -	}
 -
 -	return ret;
 +	return register_qdisc(&ingress_qdisc_ops);
  }
  
  static void __exit ingress_module_exit(void)
* Unmerged path net/sched/cls_flower.c
* Unmerged path include/net/pkt_cls.h
* Unmerged path include/net/sch_generic.h
* Unmerged path net/sched/cls_flower.c
* Unmerged path net/sched/cls_u32.c
* Unmerged path net/sched/sch_ingress.c
