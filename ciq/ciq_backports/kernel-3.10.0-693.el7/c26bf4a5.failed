pktgen: Add UDPCSUM flag to support UDP checksums

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Thomas Graf <tgraf@suug.ch>
commit c26bf4a51308c85a6f97628253b99767a84ff90a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c26bf4a5.failed

UDP checksums are optional, hence pktgen has been omitting them in
favour of performance. The optional flag UDPCSUM enables UDP
checksumming. If the output device supports hardware checksumming
the skb is prepared and marked CHECKSUM_PARTIAL, otherwise the
checksum is generated in software.

	Signed-off-by: Thomas Graf <tgraf@suug.ch>
	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Ben Greear <greearb@candelatech.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c26bf4a51308c85a6f97628253b99767a84ff90a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/pktgen.c
diff --cc net/core/pktgen.c
index e06341827eab,48cebf2c3e7a..000000000000
--- a/net/core/pktgen.c
+++ b/net/core/pktgen.c
@@@ -198,7 -199,7 +199,11 @@@
  #define F_QUEUE_MAP_RND (1<<13)	/* queue map Random */
  #define F_QUEUE_MAP_CPU (1<<14)	/* queue map mirrors smp_processor_id() */
  #define F_NODE          (1<<15)	/* Node memory alloc*/
++<<<<<<< HEAD
 +#define F_NO_TIMESTAMP  (1<<17)	/* Don't timestamp packets (default TS) */
++=======
+ #define F_UDPCSUM       (1<<16)	/* Include UDP checksum */
++>>>>>>> c26bf4a51308 (pktgen: Add UDPCSUM flag to support UDP checksums)
  
  /* Thread control flag bits */
  #define T_STOP        (1<<0)	/* Stop run */
@@@ -636,8 -633,8 +641,13 @@@ static int pktgen_if_show(struct seq_fi
  	if (pkt_dev->flags & F_UDPDST_RND)
  		seq_printf(seq, "UDPDST_RND  ");
  
++<<<<<<< HEAD
 +	if (pkt_dev->flags & F_NO_TIMESTAMP)
 +		seq_puts(seq, "NO_TIMESTAMP  ");
++=======
+ 	if (pkt_dev->flags & F_UDPCSUM)
+ 		seq_printf(seq, "UDPCSUM  ");
++>>>>>>> c26bf4a51308 (pktgen: Add UDPCSUM flag to support UDP checksums)
  
  	if (pkt_dev->flags & F_MPLS_RND)
  		seq_printf(seq,  "MPLS_RND  ");
@@@ -1249,8 -1233,11 +1259,16 @@@ static ssize_t pktgen_if_write(struct f
  		else if (strcmp(f, "!NODE_ALLOC") == 0)
  			pkt_dev->flags &= ~F_NODE;
  
++<<<<<<< HEAD
 +		else if (strcmp(f, "NO_TIMESTAMP") == 0)
 +			pkt_dev->flags |= F_NO_TIMESTAMP;
++=======
+ 		else if (strcmp(f, "UDPCSUM") == 0)
+ 			pkt_dev->flags |= F_UDPCSUM;
+ 
+ 		else if (strcmp(f, "!UDPCSUM") == 0)
+ 			pkt_dev->flags &= ~F_UDPCSUM;
++>>>>>>> c26bf4a51308 (pktgen: Add UDPCSUM flag to support UDP checksums)
  
  		else {
  			sprintf(pg_result,
diff --git a/include/net/udp.h b/include/net/udp.h
index 2c87c23321fa..cd3e32cbd5b1 100644
--- a/include/net/udp.h
+++ b/include/net/udp.h
@@ -236,6 +236,7 @@ extern int udp_sendmsg(struct kiocb *iocb, struct sock *sk,
 			    struct msghdr *msg, size_t len);
 extern int udp_push_pending_frames(struct sock *sk);
 extern void udp_flush_pending_frames(struct sock *sk);
+extern void udp4_hwcsum(struct sk_buff *skb, __be32 src, __be32 dst);
 extern int udp_rcv(struct sk_buff *skb);
 extern int udp_ioctl(struct sock *sk, int cmd, unsigned long arg);
 extern int udp_disconnect(struct sock *sk, int flags);
* Unmerged path net/core/pktgen.c
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index a02b20ab0f64..c4d8994feceb 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -712,7 +712,7 @@ EXPORT_SYMBOL(udp_flush_pending_frames);
  *	@src:	source IP address
  *	@dst:	destination IP address
  */
-static void udp4_hwcsum(struct sk_buff *skb, __be32 src, __be32 dst)
+void udp4_hwcsum(struct sk_buff *skb, __be32 src, __be32 dst)
 {
 	struct udphdr *uh = udp_hdr(skb);
 	struct sk_buff *frags = skb_shinfo(skb)->frag_list;
@@ -748,6 +748,7 @@ static void udp4_hwcsum(struct sk_buff *skb, __be32 src, __be32 dst)
 			uh->check = CSUM_MANGLED_0;
 	}
 }
+EXPORT_SYMBOL_GPL(udp4_hwcsum);
 
 /* Function to set UDP checksum for an IPv4 UDP packet. This is intended
  * for the simple case like when setting the checksum for a UDP tunnel.
