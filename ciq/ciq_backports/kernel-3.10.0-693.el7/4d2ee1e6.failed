scsi: be2iscsi: Fix POST check and reset sequence

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] be2iscsi: Fix POST check and reset sequence (Maurizio Lombardi) [1382263]
Rebuild_FUZZ: 93.48%
commit-author Jitendra Bhivare <jitendra.bhivare@broadcom.com>
commit 4d2ee1e688a26ee580b9f3e824afa278bbb178a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4d2ee1e6.failed

SLIPORT FUNCTION_RESET does not reset the chip.
So POST status needs to be checked before issuing FUNCTION_RESET.
The completion of FUNCTION_RESET is indicated in BMBX Rdy bit.

be_cmd_fw_initialize too needs to be done before issuing any cmd to FW.
be_cmd_fw_initialize is renamed as beiscsi_cmd_special_wrb.
Rearrange and rename few functions in init and cleanup path.

	Signed-off-by: Jitendra Bhivare <jitendra.bhivare@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 4d2ee1e688a26ee580b9f3e824afa278bbb178a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/be2iscsi/be_cmds.c
#	drivers/scsi/be2iscsi/be_main.c
diff --cc drivers/scsi/be2iscsi/be_cmds.c
index 403296239ae9,771670c0682b..000000000000
--- a/drivers/scsi/be2iscsi/be_cmds.c
+++ b/drivers/scsi/be2iscsi/be_cmds.c
@@@ -1327,3 -1223,425 +1198,428 @@@ int be_cmd_set_vlan(struct beiscsi_hba 
  
  	return tag;
  }
++<<<<<<< HEAD
++=======
+ 
+ int beiscsi_check_supported_fw(struct be_ctrl_info *ctrl,
+ 			       struct beiscsi_hba *phba)
+ {
+ 	struct be_dma_mem nonemb_cmd;
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct be_mgmt_controller_attributes *req;
+ 	struct be_sge *sge = nonembedded_sgl(wrb);
+ 	int status = 0;
+ 
+ 	nonemb_cmd.va = pci_alloc_consistent(ctrl->pdev,
+ 				sizeof(struct be_mgmt_controller_attributes),
+ 				&nonemb_cmd.dma);
+ 	if (nonemb_cmd.va == NULL) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : pci_alloc_consistent failed in %s\n",
+ 			    __func__);
+ 		return -ENOMEM;
+ 	}
+ 	nonemb_cmd.size = sizeof(struct be_mgmt_controller_attributes);
+ 	req = nonemb_cmd.va;
+ 	memset(req, 0, sizeof(*req));
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	be_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);
+ 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_GET_CNTL_ATTRIBUTES, sizeof(*req));
+ 	sge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd.dma));
+ 	sge->pa_lo = cpu_to_le32(nonemb_cmd.dma & 0xFFFFFFFF);
+ 	sge->len = cpu_to_le32(nonemb_cmd.size);
+ 	status = be_mbox_notify(ctrl);
+ 	if (!status) {
+ 		struct be_mgmt_controller_attributes_resp *resp = nonemb_cmd.va;
+ 
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : Firmware Version of CMD : %s\n"
+ 			    "Firmware Version is : %s\n"
+ 			    "Developer Build, not performing version check...\n",
+ 			    resp->params.hba_attribs
+ 			    .flashrom_version_string,
+ 			    resp->params.hba_attribs.
+ 			    firmware_version_string);
+ 
+ 		phba->fw_config.iscsi_features =
+ 				resp->params.hba_attribs.iscsi_features;
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BM_%d : phba->fw_config.iscsi_features = %d\n",
+ 			    phba->fw_config.iscsi_features);
+ 		memcpy(phba->fw_ver_str, resp->params.hba_attribs.
+ 		       firmware_version_string, BEISCSI_VER_STRLEN);
+ 	} else
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d :  Failed in beiscsi_check_supported_fw\n");
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	if (nonemb_cmd.va)
+ 		pci_free_consistent(ctrl->pdev, nonemb_cmd.size,
+ 				    nonemb_cmd.va, nonemb_cmd.dma);
+ 
+ 	return status;
+ }
+ 
+ /**
+  * beiscsi_get_fw_config()- Get the FW config for the function
+  * @ctrl: ptr to Ctrl Info
+  * @phba: ptr to the dev priv structure
+  *
+  * Get the FW config and resources available for the function.
+  * The resources are created based on the count received here.
+  *
+  * return
+  *	Success: 0
+  *	Failure: Non-Zero Value
+  **/
+ int beiscsi_get_fw_config(struct be_ctrl_info *ctrl,
+ 			  struct beiscsi_hba *phba)
+ {
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct be_fw_cfg *pfw_cfg = embedded_payload(wrb);
+ 	uint32_t cid_count, icd_count;
+ 	int status = -EINVAL;
+ 	uint8_t ulp_num = 0;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	be_wrb_hdr_prepare(wrb, sizeof(*pfw_cfg), true, 0);
+ 
+ 	be_cmd_hdr_prepare(&pfw_cfg->hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_QUERY_FIRMWARE_CONFIG,
+ 			   EMBED_MBX_MAX_PAYLOAD_SIZE);
+ 
+ 	if (be_mbox_notify(ctrl)) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : Failed in beiscsi_get_fw_config\n");
+ 		goto fail_init;
+ 	}
+ 
+ 	/* FW response formats depend on port id */
+ 	phba->fw_config.phys_port = pfw_cfg->phys_port;
+ 	if (phba->fw_config.phys_port >= BEISCSI_PHYS_PORT_MAX) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : invalid physical port id %d\n",
+ 			    phba->fw_config.phys_port);
+ 		goto fail_init;
+ 	}
+ 
+ 	/* populate and check FW config against min and max values */
+ 	if (!is_chip_be2_be3r(phba)) {
+ 		phba->fw_config.eqid_count = pfw_cfg->eqid_count;
+ 		phba->fw_config.cqid_count = pfw_cfg->cqid_count;
+ 		if (phba->fw_config.eqid_count == 0 ||
+ 		    phba->fw_config.eqid_count > 2048) {
+ 			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 				    "BG_%d : invalid EQ count %d\n",
+ 				    phba->fw_config.eqid_count);
+ 			goto fail_init;
+ 		}
+ 		if (phba->fw_config.cqid_count == 0 ||
+ 		    phba->fw_config.cqid_count > 4096) {
+ 			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 				    "BG_%d : invalid CQ count %d\n",
+ 				    phba->fw_config.cqid_count);
+ 			goto fail_init;
+ 		}
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : EQ_Count : %d CQ_Count : %d\n",
+ 			    phba->fw_config.eqid_count,
+ 			    phba->fw_config.cqid_count);
+ 	}
+ 
+ 	/**
+ 	 * Check on which all ULP iSCSI Protocol is loaded.
+ 	 * Set the Bit for those ULP. This set flag is used
+ 	 * at all places in the code to check on which ULP
+ 	 * iSCSi Protocol is loaded
+ 	 **/
+ 	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {
+ 		if (pfw_cfg->ulp[ulp_num].ulp_mode &
+ 		    BEISCSI_ULP_ISCSI_INI_MODE) {
+ 			set_bit(ulp_num, &phba->fw_config.ulp_supported);
+ 
+ 			/* Get the CID, ICD and Chain count for each ULP */
+ 			phba->fw_config.iscsi_cid_start[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].sq_base;
+ 			phba->fw_config.iscsi_cid_count[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].sq_count;
+ 
+ 			phba->fw_config.iscsi_icd_start[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].icd_base;
+ 			phba->fw_config.iscsi_icd_count[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].icd_count;
+ 
+ 			phba->fw_config.iscsi_chain_start[ulp_num] =
+ 				pfw_cfg->chain_icd[ulp_num].chain_base;
+ 			phba->fw_config.iscsi_chain_count[ulp_num] =
+ 				pfw_cfg->chain_icd[ulp_num].chain_count;
+ 
+ 			beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 				    "BG_%d : Function loaded on ULP : %d\n"
+ 				    "\tiscsi_cid_count : %d\n"
+ 				    "\tiscsi_cid_start : %d\n"
+ 				    "\t iscsi_icd_count : %d\n"
+ 				    "\t iscsi_icd_start : %d\n",
+ 				    ulp_num,
+ 				    phba->fw_config.
+ 				    iscsi_cid_count[ulp_num],
+ 				    phba->fw_config.
+ 				    iscsi_cid_start[ulp_num],
+ 				    phba->fw_config.
+ 				    iscsi_icd_count[ulp_num],
+ 				    phba->fw_config.
+ 				    iscsi_icd_start[ulp_num]);
+ 		}
+ 	}
+ 
+ 	if (phba->fw_config.ulp_supported == 0) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : iSCSI initiator mode not set: ULP0 %x ULP1 %x\n",
+ 			    pfw_cfg->ulp[BEISCSI_ULP0].ulp_mode,
+ 			    pfw_cfg->ulp[BEISCSI_ULP1].ulp_mode);
+ 		goto fail_init;
+ 	}
+ 
+ 	/**
+ 	 * ICD is shared among ULPs. Use icd_count of any one loaded ULP
+ 	 **/
+ 	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)
+ 		if (test_bit(ulp_num, &phba->fw_config.ulp_supported))
+ 			break;
+ 	icd_count = phba->fw_config.iscsi_icd_count[ulp_num];
+ 	if (icd_count == 0 || icd_count > 65536) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d: invalid ICD count %d\n", icd_count);
+ 		goto fail_init;
+ 	}
+ 
+ 	cid_count = BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP0) +
+ 		    BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP1);
+ 	if (cid_count == 0 || cid_count > 4096) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d: invalid CID count %d\n", cid_count);
+ 		goto fail_init;
+ 	}
+ 
+ 	/**
+ 	 * Check FW is dual ULP aware i.e. can handle either
+ 	 * of the protocols.
+ 	 */
+ 	phba->fw_config.dual_ulp_aware = (pfw_cfg->function_mode &
+ 					  BEISCSI_FUNC_DUA_MODE);
+ 
+ 	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 		    "BG_%d : DUA Mode : 0x%x\n",
+ 		    phba->fw_config.dual_ulp_aware);
+ 
+ 	/* all set, continue using this FW config */
+ 	status = 0;
+ fail_init:
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return status;
+ }
+ 
+ /**
+  * beiscsi_get_port_name()- Get port name for the function
+  * @ctrl: ptr to Ctrl Info
+  * @phba: ptr to the dev priv structure
+  *
+  * Get the alphanumeric character for port
+  *
+  **/
+ int beiscsi_get_port_name(struct be_ctrl_info *ctrl, struct beiscsi_hba *phba)
+ {
+ 	int ret = 0;
+ 	struct be_mcc_wrb *wrb;
+ 	struct be_cmd_get_port_name *ioctl;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	ioctl = embedded_payload(wrb);
+ 
+ 	be_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);
+ 	be_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_GET_PORT_NAME,
+ 			   EMBED_MBX_MAX_PAYLOAD_SIZE);
+ 	ret = be_mbox_notify(ctrl);
+ 	phba->port_name = 0;
+ 	if (!ret) {
+ 		phba->port_name = ioctl->p.resp.port_names >>
+ 				  (phba->fw_config.phys_port * 8) & 0xff;
+ 	} else {
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : GET_PORT_NAME ret 0x%x status 0x%x\n",
+ 			    ret, ioctl->h.resp_hdr.status);
+ 	}
+ 
+ 	if (phba->port_name == 0)
+ 		phba->port_name = '?';
+ 
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return ret;
+ }
+ 
+ int beiscsi_set_uer_feature(struct beiscsi_hba *phba)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct be_cmd_set_features *ioctl;
+ 	struct be_mcc_wrb *wrb;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	ioctl = embedded_payload(wrb);
+ 
+ 	be_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);
+ 	be_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_SET_FEATURES,
+ 			   EMBED_MBX_MAX_PAYLOAD_SIZE);
+ 	ioctl->feature = BE_CMD_SET_FEATURE_UER;
+ 	ioctl->param_len = sizeof(ioctl->param.req);
+ 	ioctl->param.req.uer = BE_CMD_UER_SUPP_BIT;
+ 	ret = be_mbox_notify(ctrl);
+ 	if (!ret) {
+ 		phba->ue2rp = ioctl->param.resp.ue2rp;
+ 		set_bit(BEISCSI_HBA_UER_SUPP, &phba->state);
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : HBA error recovery supported\n");
+ 	} else {
+ 		/**
+ 		 * Check "MCC_STATUS_INVALID_LENGTH" for SKH.
+ 		 * Older FW versions return this error.
+ 		 */
+ 		if (ret == MCC_STATUS_ILLEGAL_REQUEST ||
+ 		    ret == MCC_STATUS_INVALID_LENGTH)
+ 			__beiscsi_log(phba, KERN_INFO,
+ 				      "BG_%d : HBA error recovery not supported\n");
+ 	}
+ 
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return ret;
+ }
+ 
+ static u32 beiscsi_get_post_stage(struct beiscsi_hba *phba)
+ {
+ 	u32 sem;
+ 
+ 	if (is_chip_be2_be3r(phba))
+ 		sem = ioread32(phba->csr_va + SLIPORT_SEMAPHORE_OFFSET_BEx);
+ 	else
+ 		pci_read_config_dword(phba->pcidev,
+ 				      SLIPORT_SEMAPHORE_OFFSET_SH, &sem);
+ 	return sem;
+ }
+ 
+ int beiscsi_check_fw_rdy(struct beiscsi_hba *phba)
+ {
+ 	u32 loop, post, rdy = 0;
+ 
+ 	loop = 1000;
+ 	while (loop--) {
+ 		post = beiscsi_get_post_stage(phba);
+ 		if (post & POST_ERROR_BIT)
+ 			break;
+ 		if ((post & POST_STAGE_MASK) == POST_STAGE_ARMFW_RDY) {
+ 			rdy = 1;
+ 			break;
+ 		}
+ 		msleep(60);
+ 	}
+ 
+ 	if (!rdy) {
+ 		__beiscsi_log(phba, KERN_ERR,
+ 			      "BC_%d : FW not ready 0x%x\n", post);
+ 	}
+ 
+ 	return rdy;
+ }
+ 
+ static int beiscsi_cmd_function_reset(struct beiscsi_hba  *phba)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct be_post_sgl_pages_req *req = embedded_payload(wrb);
+ 	int status;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 
+ 	req = embedded_payload(wrb);
+ 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
+ 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_FUNCTION_RESET, sizeof(*req));
+ 	status = be_mbox_notify(ctrl);
+ 
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return status;
+ }
+ 
+ int beiscsi_cmd_special_wrb(struct be_ctrl_info *ctrl, u32 load)
+ {
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);
+ 	u8 *endian_check;
+ 	int status;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 
+ 	endian_check = (u8 *) wrb;
+ 	if (load) {
+ 		/* to start communicating */
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0x12;
+ 		*endian_check++ = 0x34;
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0x56;
+ 		*endian_check++ = 0x78;
+ 		*endian_check++ = 0xFF;
+ 	} else {
+ 		/* to stop communicating */
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0xAA;
+ 		*endian_check++ = 0xBB;
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0xFF;
+ 		*endian_check++ = 0xCC;
+ 		*endian_check++ = 0xDD;
+ 		*endian_check = 0xFF;
+ 	}
+ 	be_dws_cpu_to_le(wrb, sizeof(*wrb));
+ 
+ 	status = be_mbox_notify(ctrl);
+ 	if (status)
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BC_%d : special WRB message failed\n");
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return status;
+ }
+ 
+ int beiscsi_init_sliport(struct beiscsi_hba *phba)
+ {
+ 	int status;
+ 
+ 	/* check POST stage before talking to FW */
+ 	status = beiscsi_check_fw_rdy(phba);
+ 	if (!status)
+ 		return -EIO;
+ 
+ 	/*
+ 	 * SLI COMMON_FUNCTION_RESET completion is indicated by BMBX RDY bit.
+ 	 * It should clean up any stale info in FW for this fn.
+ 	 */
+ 	status = beiscsi_cmd_function_reset(phba);
+ 	if (status) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BC_%d : SLI Function Reset failed\n");
+ 		return status;
+ 	}
+ 
+ 	/* indicate driver is loading */
+ 	return beiscsi_cmd_special_wrb(&phba->ctrl, 1);
+ }
++>>>>>>> 4d2ee1e688a2 (scsi: be2iscsi: Fix POST check and reset sequence)
diff --cc drivers/scsi/be2iscsi/be_main.c
index 8e3a0f9d2ac4,b4e6fc222d60..000000000000
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@@ -5280,21 -5008,22 +5280,40 @@@ static void beiscsi_quiesce(struct beis
  		irq_poll_disable(&pbe_eq->iopoll);
  	}
  
++<<<<<<< HEAD
 +	if (unload_state == BEISCSI_CLEAN_UNLOAD) {
 +		destroy_workqueue(phba->wq);
 +		beiscsi_clean_port(phba);
 +		beiscsi_free_mem(phba);
 +
 +		beiscsi_unmap_pci_function(phba);
 +		pci_free_consistent(phba->pcidev,
 +				    phba->ctrl.mbox_mem_alloced.size,
 +				    phba->ctrl.mbox_mem_alloced.va,
 +				    phba->ctrl.mbox_mem_alloced.dma);
 +	} else {
 +		hwi_purge_eq(phba);
 +		hwi_cleanup(phba);
 +	}
 +
++=======
+ 	/* PCI_ERR is set then check if driver is not unloading */
+ 	if (test_bit(BEISCSI_HBA_RUNNING, &phba->state) &&
+ 	    test_bit(BEISCSI_HBA_PCI_ERR, &phba->state)) {
+ 		hwi_cleanup_port(phba);
+ 		return;
+ 	}
+ 
+ 	destroy_workqueue(phba->wq);
+ 	beiscsi_cleanup_port(phba);
+ 	beiscsi_free_mem(phba);
+ 
+ 	beiscsi_unmap_pci_function(phba);
+ 	pci_free_consistent(phba->pcidev,
+ 			    phba->ctrl.mbox_mem_alloced.size,
+ 			    phba->ctrl.mbox_mem_alloced.va,
+ 			    phba->ctrl.mbox_mem_alloced.dma);
++>>>>>>> 4d2ee1e688a2 (scsi: be2iscsi: Fix POST check and reset sequence)
  }
  
  static void beiscsi_remove(struct pci_dev *pcidev)
@@@ -5645,22 -5620,11 +5652,30 @@@ static int beiscsi_dev_probe(struct pci
  		goto hba_free;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * FUNCTION_RESET should clean up any stale info in FW for this fn
 +	 */
 +	ret = beiscsi_cmd_reset_function(phba);
 +	if (ret) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 +			    "BM_%d : Reset Failed\n");
 +		goto hba_free;
 +	}
 +	ret = be_chk_reset_complete(phba);
 +	if (ret) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 +			    "BM_%d : Failed to get out of reset.\n");
 +		goto hba_free;
 +	}
 +
++=======
+ 	ret = beiscsi_init_sliport(phba);
+ 	if (ret)
+ 		goto hba_free;
+ 
+ 	set_bit(BEISCSI_HBA_RUNNING, &phba->state);
++>>>>>>> 4d2ee1e688a2 (scsi: be2iscsi: Fix POST check and reset sequence)
  	spin_lock_init(&phba->io_sgl_lock);
  	spin_lock_init(&phba->mgmt_sgl_lock);
  	spin_lock_init(&phba->async_pdu_lock);
* Unmerged path drivers/scsi/be2iscsi/be_cmds.c
diff --git a/drivers/scsi/be2iscsi/be_cmds.h b/drivers/scsi/be2iscsi/be_cmds.h
index c50b74afd00a..a4288494a522 100644
--- a/drivers/scsi/be2iscsi/be_cmds.h
+++ b/drivers/scsi/be2iscsi/be_cmds.h
@@ -97,11 +97,23 @@ struct be_mcc_compl {
 #define MPU_MAILBOX_DB_RDY_MASK	0x1	/* bit 0 */
 #define MPU_MAILBOX_DB_HI_MASK	0x2	/* bit 1 */
 
-/********** MPU semphore ******************/
-#define MPU_EP_SEMAPHORE_OFFSET 0xac
-#define EP_SEMAPHORE_POST_STAGE_MASK 0x0000FFFF
-#define EP_SEMAPHORE_POST_ERR_MASK 0x1
-#define EP_SEMAPHORE_POST_ERR_SHIFT 31
+/********** MPU semphore: used for SH & BE ******************/
+#define SLIPORT_SOFTRESET_OFFSET		0x5c	/* CSR BAR offset */
+#define SLIPORT_SEMAPHORE_OFFSET_BEx		0xac	/* CSR BAR offset */
+#define SLIPORT_SEMAPHORE_OFFSET_SH		0x94	/* PCI-CFG offset */
+#define POST_STAGE_MASK				0x0000FFFF
+#define POST_ERROR_BIT				0x80000000
+#define POST_ERR_RECOVERY_CODE_MASK		0xF000
+
+/* Soft Reset register masks */
+#define SLIPORT_SOFTRESET_SR_MASK		0x00000080	/* SR bit */
+
+/* MPU semphore POST stage values */
+#define POST_STAGE_AWAITING_HOST_RDY	0x1 /* FW awaiting goahead from host */
+#define POST_STAGE_HOST_RDY		0x2 /* Host has given go-ahed to FW */
+#define POST_STAGE_BE_RESET		0x3 /* Host wants to reset chip */
+#define POST_STAGE_ARMFW_RDY		0xC000 /* FW is done with POST */
+#define POST_STAGE_RECOVERABLE_ERR	0xE000 /* Recoverable err detected */
 
 /********** MCC door bell ************/
 #define DB_MCCQ_OFFSET 0x140
@@ -109,9 +121,6 @@ struct be_mcc_compl {
 /* Number of entries posted */
 #define DB_MCCQ_NUM_POSTED_SHIFT 16		/* bits 16 - 29 */
 
-/* MPU semphore POST stage values */
-#define POST_STAGE_ARMFW_RDY		0xc000	/* FW is done with POST */
-
 /**
  * When the async bit of mcc_compl is set, the last 4 bytes of
  * mcc_compl is interpreted as follows:
@@ -717,6 +726,12 @@ struct be_cmd_hba_name {
 	u8 initiator_alias[BEISCSI_ALIAS_LEN];
 } __packed;
 
+int beiscsi_cmd_special_wrb(struct be_ctrl_info *ctrl, u32 load);
+
+int beiscsi_check_fw_rdy(struct beiscsi_hba *phba);
+
+int beiscsi_init_sliport(struct beiscsi_hba *phba);
+
 int beiscsi_cmd_eq_create(struct be_ctrl_info *ctrl,
 			  struct be_queue_info *eq, int eq_delay);
 
@@ -744,9 +759,6 @@ int beiscsi_mccq_compl_wait(struct beiscsi_hba *phba,
 			    uint32_t tag, struct be_mcc_wrb **wrb,
 			    struct be_dma_mem *mbx_cmd_mem);
 /*ISCSI Functuions */
-int be_cmd_fw_initialize(struct be_ctrl_info *ctrl);
-int be_cmd_fw_uninit(struct be_ctrl_info *ctrl);
-
 struct be_mcc_wrb *wrb_from_mbox(struct be_dma_mem *mbox_mem);
 int be_mcc_compl_poll(struct beiscsi_hba *phba, unsigned int tag);
 void be_mcc_notify(struct beiscsi_hba *phba, unsigned int tag);
@@ -775,8 +787,6 @@ int be_cmd_iscsi_post_sgl_pages(struct be_ctrl_info *ctrl,
 				struct be_dma_mem *q_mem, u32 page_offset,
 				u32 num_pages);
 
-int beiscsi_cmd_reset_function(struct beiscsi_hba *phba);
-
 int be_cmd_wrbq_create(struct be_ctrl_info *ctrl, struct be_dma_mem *q_mem,
 		       struct be_queue_info *wrbq,
 		       struct hwi_wrb_context *pwrb_context,
@@ -1376,8 +1386,6 @@ struct be_cmd_get_port_name {
 						 * the cxn
 						 */
 
-int be_chk_reset_complete(struct beiscsi_hba *phba);
-
 void be_wrb_hdr_prepare(struct be_mcc_wrb *wrb, int payload_len,
 			bool embedded, u8 sge_cnt);
 
* Unmerged path drivers/scsi/be2iscsi/be_main.c
diff --git a/drivers/scsi/be2iscsi/be_main.h b/drivers/scsi/be2iscsi/be_main.h
index 90cdc10c01fb..2523a1f58df7 100644
--- a/drivers/scsi/be2iscsi/be_main.h
+++ b/drivers/scsi/be2iscsi/be_main.h
@@ -82,14 +82,6 @@
 #define BEISCSI_MAX_FRAGS_INIT	192
 #define BE_NUM_MSIX_ENTRIES	1
 
-#define MPU_EP_CONTROL          0
-#define MPU_EP_SEMAPHORE        0xac
-#define BE2_SOFT_RESET          0x5c
-#define BE2_PCI_ONLINE0         0xb0
-#define BE2_PCI_ONLINE1         0xb4
-#define BE2_SET_RESET           0x80
-#define BE2_MPU_IRAM_ONLINE     0x00000080
-
 #define BE_SENSE_INFO_SIZE		258
 #define BE_ISCSI_PDU_HEADER_SIZE	64
 #define BE_MIN_MEM_SIZE			16384
