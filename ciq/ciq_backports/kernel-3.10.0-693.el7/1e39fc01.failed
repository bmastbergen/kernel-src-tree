fsnotify: document mark locking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jan Kara <jack@suse.com>
commit 1e39fc01836d02a11515aaabd97a0a938326bfe2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1e39fc01.failed

	Signed-off-by: Jan Kara <jack@suse.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 1e39fc01836d02a11515aaabd97a0a938326bfe2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/fsnotify_backend.h
diff --cc include/linux/fsnotify_backend.h
index 6b41e8a76df9,dd6ddb0287ed..000000000000
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@@ -194,50 -195,44 +194,80 @@@ struct fsnotify_group 
  #define FSNOTIFY_EVENT_INODE	2
  
  /*
++<<<<<<< HEAD
 + * Inode specific fields in an fsnotify_mark
 + */
 +struct fsnotify_inode_mark {
 +	struct inode *inode;		/* inode this mark is associated with */
 +	struct hlist_node i_list;	/* list of marks by inode->i_fsnotify_marks */
 +	struct list_head free_i_list;	/* tmp list used when freeing this mark */
 +};
 +
 +/*
 + * Mount point specific fields in an fsnotify_mark
 + */
 +struct fsnotify_vfsmount_mark {
 +	struct vfsmount *mnt;		/* vfsmount this mark is associated with */
 +	struct hlist_node m_list;	/* list of marks by inode->i_fsnotify_marks */
 +	struct list_head free_m_list;	/* tmp list used when freeing this mark */
 +};
 +
 +/*
 + * a mark is simply an object attached to an in core inode which allows an
++=======
+  * A mark is simply an object attached to an in core inode which allows an
++>>>>>>> 1e39fc01836d (fsnotify: document mark locking)
   * fsnotify listener to indicate they are either no longer interested in events
   * of a type matching mask or only interested in those events.
   *
-  * these are flushed when an inode is evicted from core and may be flushed
-  * when the inode is modified (as seen by fsnotify_access).  Some fsnotify users
-  * (such as dnotify) will flush these when the open fd is closed and not at
-  * inode eviction or modification.
+  * These are flushed when an inode is evicted from core and may be flushed
+  * when the inode is modified (as seen by fsnotify_access).  Some fsnotify
+  * users (such as dnotify) will flush these when the open fd is closed and not
+  * at inode eviction or modification.
+  *
+  * Text in brackets is showing the lock(s) protecting modifications of a
+  * particular entry. obj_lock means either inode->i_lock or
+  * mnt->mnt_root->d_lock depending on the mark type.
   */
  struct fsnotify_mark {
- 	__u32 mask;			/* mask this mark is for */
- 	/* we hold ref for each i_list and g_list.  also one ref for each 'thing'
+ 	/* Mask this mark is for [mark->lock, group->mark_mutex] */
+ 	__u32 mask;
+ 	/* We hold one for presence in g_list. Also one ref for each 'thing'
  	 * in kernel that found and may be using this mark. */
++<<<<<<< HEAD
 +	atomic_t refcnt;		/* active things looking at this mark */
 +	struct fsnotify_group *group;	/* group this mark is for */
 +	struct list_head g_list;	/* list of marks by group->i_fsnotify_marks
 +					 * Also reused for queueing mark into
 +					 * destroy_list when it's waiting for
 +					 * the end of SRCU period before it can
 +					 * be freed */
 +	spinlock_t lock;		/* protect group and inode */
 +	union {
 +		struct fsnotify_inode_mark i;
 +		struct fsnotify_vfsmount_mark m;
++=======
+ 	atomic_t refcnt;
+ 	/* Group this mark is for. Set on mark creation, stable until last ref
+ 	 * is dropped */
+ 	struct fsnotify_group *group;
+ 	/* List of marks by group->i_fsnotify_marks. Also reused for queueing
+ 	 * mark into destroy_list when it's waiting for the end of SRCU period
+ 	 * before it can be freed. [group->mark_mutex] */
+ 	struct list_head g_list;
+ 	/* Protects inode / mnt pointers, flags, masks */
+ 	spinlock_t lock;
+ 	/* List of marks for inode / vfsmount [obj_lock] */
+ 	struct hlist_node obj_list;
+ 	/* tmp list used when freeing this mark */
+ 	struct list_head free_list;
+ 	union {	/* Object pointer [mark->lock, group->mark_mutex] */
+ 		struct inode *inode;	/* inode this mark is associated with */
+ 		struct vfsmount *mnt;	/* vfsmount this mark is associated with */
++>>>>>>> 1e39fc01836d (fsnotify: document mark locking)
  	};
- 	__u32 ignored_mask;		/* events types to ignore */
+ 	/* Events types to ignore [mark->lock, group->mark_mutex] */
+ 	__u32 ignored_mask;
  #define FSNOTIFY_MARK_FLAG_INODE		0x01
  #define FSNOTIFY_MARK_FLAG_VFSMOUNT		0x02
  #define FSNOTIFY_MARK_FLAG_OBJECT_PINNED	0x04
* Unmerged path include/linux/fsnotify_backend.h
