treewide: Fix typo in printk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Masanari Iida <standby24x7@gmail.com>
commit 8b513d0cf603c0a9ccf86a92cb22931f05a7bc86
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8b513d0c.failed

Correct spelling typo in various part of drivers

	Signed-off-by: Masanari Iida <standby24x7@gmail.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 8b513d0cf603c0a9ccf86a92cb22931f05a7bc86)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/radeon/radeon_fb.c
#	drivers/infiniband/ulp/isert/ib_isert.c
#	drivers/misc/mei/hbm.c
#	fs/btrfs/free-space-cache.c
diff --cc drivers/gpu/drm/radeon/radeon_fb.c
index 0e3143acb565,665ced3b7313..000000000000
--- a/drivers/gpu/drm/radeon/radeon_fb.c
+++ b/drivers/gpu/drm/radeon/radeon_fb.c
@@@ -230,7 -231,7 +230,11 @@@ static int radeonfb_create(struct drm_f
  	ret = radeon_framebuffer_init(rdev->ddev, &rfbdev->rfb, &mode_cmd, gobj);
  	if (ret) {
  		DRM_ERROR("failed to initialize framebuffer %d\n", ret);
++<<<<<<< HEAD
 +		goto out_destroy_fbi;
++=======
+ 		goto out_unref;
++>>>>>>> 8b513d0cf603 (treewide: Fix typo in printk)
  	}
  
  	fb = &rfbdev->rfb.base;
diff --cc drivers/infiniband/ulp/isert/ib_isert.c
index d5679182bb65,2693129055c1..000000000000
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@@ -2260,9 -1585,9 +2260,13 @@@ isert_put_nopin(struct iscsi_cmd *cmd, 
  			       &isert_cmd->tx_desc.iscsi_header,
  			       nopout_response);
  	isert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);
 -	isert_init_send_wr(isert_cmd, send_wr);
 +	isert_init_send_wr(isert_conn, isert_cmd, send_wr);
  
++<<<<<<< HEAD
 +	isert_dbg("conn %p Posting NOPIN Response\n", isert_conn);
++=======
+ 	pr_debug("Posting NOPIN Response IB_WR_SEND >>>>>>>>>>>>>>>>>>>>>>\n");
++>>>>>>> 8b513d0cf603 (treewide: Fix typo in printk)
  
  	return isert_post_response(isert_conn, isert_cmd);
  }
diff --cc drivers/misc/mei/hbm.c
index e7b7aad0999b,54ffcbc24c70..000000000000
--- a/drivers/misc/mei/hbm.c
+++ b/drivers/misc/mei/hbm.c
@@@ -230,15 -131,16 +230,20 @@@ int mei_hbm_start_wait(struct mei_devic
  		return 0;
  
  	mutex_unlock(&dev->device_lock);
 -	ret = wait_event_interruptible_timeout(dev->wait_recvd_msg,
 -			dev->hbm_state == MEI_HBM_IDLE ||
 -			dev->hbm_state > MEI_HBM_START,
 -			mei_secs_to_jiffies(MEI_INTEROP_TIMEOUT));
 +	ret = wait_event_timeout(dev->wait_hbm_start,
 +			dev->hbm_state != MEI_HBM_STARTING,
 +			mei_secs_to_jiffies(MEI_HBM_TIMEOUT));
  	mutex_lock(&dev->device_lock);
  
 -	if (ret <= 0 && (dev->hbm_state <= MEI_HBM_START)) {
 +	if (ret == 0 && (dev->hbm_state <= MEI_HBM_STARTING)) {
  		dev->hbm_state = MEI_HBM_IDLE;
++<<<<<<< HEAD
 +		dev_err(dev->dev, "waiting for mei start failed\n");
 +		return -ETIME;
++=======
+ 		dev_err(&dev->pdev->dev, "waiting for mei start failed\n");
+ 		return -ETIMEDOUT;
++>>>>>>> 8b513d0cf603 (treewide: Fix typo in printk)
  	}
  	return 0;
  }
diff --cc fs/btrfs/free-space-cache.c
index f331ef7d573a,2750b5023526..000000000000
--- a/fs/btrfs/free-space-cache.c
+++ b/fs/btrfs/free-space-cache.c
@@@ -3706,4 -3085,408 +3706,411 @@@ out
  	spin_unlock(&ctl->tree_lock);
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * Use this if you need to make a bitmap or extent entry specifically, it
+  * doesn't do any of the merging that add_free_space does, this acts a lot like
+  * how the free space cache loading stuff works, so you can get really weird
+  * configurations.
+  */
+ static int add_free_space_entry(struct btrfs_block_group_cache *cache,
+ 				u64 offset, u64 bytes, bool bitmap)
+ {
+ 	struct btrfs_free_space_ctl *ctl = cache->free_space_ctl;
+ 	struct btrfs_free_space *info = NULL, *bitmap_info;
+ 	void *map = NULL;
+ 	u64 bytes_added;
+ 	int ret;
+ 
+ again:
+ 	if (!info) {
+ 		info = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);
+ 		if (!info)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	if (!bitmap) {
+ 		spin_lock(&ctl->tree_lock);
+ 		info->offset = offset;
+ 		info->bytes = bytes;
+ 		ret = link_free_space(ctl, info);
+ 		spin_unlock(&ctl->tree_lock);
+ 		if (ret)
+ 			kmem_cache_free(btrfs_free_space_cachep, info);
+ 		return ret;
+ 	}
+ 
+ 	if (!map) {
+ 		map = kzalloc(PAGE_CACHE_SIZE, GFP_NOFS);
+ 		if (!map) {
+ 			kmem_cache_free(btrfs_free_space_cachep, info);
+ 			return -ENOMEM;
+ 		}
+ 	}
+ 
+ 	spin_lock(&ctl->tree_lock);
+ 	bitmap_info = tree_search_offset(ctl, offset_to_bitmap(ctl, offset),
+ 					 1, 0);
+ 	if (!bitmap_info) {
+ 		info->bitmap = map;
+ 		map = NULL;
+ 		add_new_bitmap(ctl, info, offset);
+ 		bitmap_info = info;
+ 	}
+ 
+ 	bytes_added = add_bytes_to_bitmap(ctl, bitmap_info, offset, bytes);
+ 	bytes -= bytes_added;
+ 	offset += bytes_added;
+ 	spin_unlock(&ctl->tree_lock);
+ 
+ 	if (bytes)
+ 		goto again;
+ 
+ 	if (map)
+ 		kfree(map);
+ 	return 0;
+ }
+ 
+ /*
+  * This test just does basic sanity checking, making sure we can add an exten
+  * entry and remove space from either end and the middle, and make sure we can
+  * remove space that covers adjacent extent entries.
+  */
+ static int test_extents(struct btrfs_block_group_cache *cache)
+ {
+ 	int ret = 0;
+ 
+ 	printk(KERN_ERR "Running extent only tests\n");
+ 
+ 	/* First just make sure we can remove an entire entry */
+ 	ret = btrfs_add_free_space(cache, 0, 4 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Error adding initial extents %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, 0, 4 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Error removing extent %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	if (check_exists(cache, 0, 4 * 1024 * 1024)) {
+ 		printk(KERN_ERR "Full remove left some lingering space\n");
+ 		return -1;
+ 	}
+ 
+ 	/* Ok edge and middle cases now */
+ 	ret = btrfs_add_free_space(cache, 0, 4 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Error adding half extent %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, 3 * 1024 * 1024, 1 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Error removing tail end %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, 0, 1 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Error removing front end %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, 2 * 1024 * 1024, 4096);
+ 	if (ret) {
+ 		printk(KERN_ERR "Error removing middle piece %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	if (check_exists(cache, 0, 1 * 1024 * 1024)) {
+ 		printk(KERN_ERR "Still have space at the front\n");
+ 		return -1;
+ 	}
+ 
+ 	if (check_exists(cache, 2 * 1024 * 1024, 4096)) {
+ 		printk(KERN_ERR "Still have space in the middle\n");
+ 		return -1;
+ 	}
+ 
+ 	if (check_exists(cache, 3 * 1024 * 1024, 1 * 1024 * 1024)) {
+ 		printk(KERN_ERR "Still have space at the end\n");
+ 		return -1;
+ 	}
+ 
+ 	/* Cleanup */
+ 	__btrfs_remove_free_space_cache(cache->free_space_ctl);
+ 
+ 	return 0;
+ }
+ 
+ static int test_bitmaps(struct btrfs_block_group_cache *cache)
+ {
+ 	u64 next_bitmap_offset;
+ 	int ret;
+ 
+ 	printk(KERN_ERR "Running bitmap only tests\n");
+ 
+ 	ret = add_free_space_entry(cache, 0, 4 * 1024 * 1024, 1);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't create a bitmap entry %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, 0, 4 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Error removing bitmap full range %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	if (check_exists(cache, 0, 4 * 1024 * 1024)) {
+ 		printk(KERN_ERR "Left some space in bitmap\n");
+ 		return -1;
+ 	}
+ 
+ 	ret = add_free_space_entry(cache, 0, 4 * 1024 * 1024, 1);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't add to our bitmap entry %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, 1 * 1024 * 1024, 2 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't remove middle chunk %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	/*
+ 	 * The first bitmap we have starts at offset 0 so the next one is just
+ 	 * at the end of the first bitmap.
+ 	 */
+ 	next_bitmap_offset = (u64)(BITS_PER_BITMAP * 4096);
+ 
+ 	/* Test a bit straddling two bitmaps */
+ 	ret = add_free_space_entry(cache, next_bitmap_offset -
+ 				   (2 * 1024 * 1024), 4 * 1024 * 1024, 1);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't add space that straddles two bitmaps"
+ 		       " %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, next_bitmap_offset -
+ 				      (1 * 1024 * 1024), 2 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't remove overlapping space %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	if (check_exists(cache, next_bitmap_offset - (1 * 1024 * 1024),
+ 			 2 * 1024 * 1024)) {
+ 		printk(KERN_ERR "Left some space when removing overlapping\n");
+ 		return -1;
+ 	}
+ 
+ 	__btrfs_remove_free_space_cache(cache->free_space_ctl);
+ 
+ 	return 0;
+ }
+ 
+ /* This is the high grade jackassery */
+ static int test_bitmaps_and_extents(struct btrfs_block_group_cache *cache)
+ {
+ 	u64 bitmap_offset = (u64)(BITS_PER_BITMAP * 4096);
+ 	int ret;
+ 
+ 	printk(KERN_ERR "Running bitmap and extent tests\n");
+ 
+ 	/*
+ 	 * First let's do something simple, an extent at the same offset as the
+ 	 * bitmap, but the free space completely in the extent and then
+ 	 * completely in the bitmap.
+ 	 */
+ 	ret = add_free_space_entry(cache, 4 * 1024 * 1024, 1 * 1024 * 1024, 1);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't create bitmap entry %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = add_free_space_entry(cache, 0, 1 * 1024 * 1024, 0);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't add extent entry %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, 0, 1 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't remove extent entry %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	if (check_exists(cache, 0, 1 * 1024 * 1024)) {
+ 		printk(KERN_ERR "Left remnants after our remove\n");
+ 		return -1;
+ 	}
+ 
+ 	/* Now to add back the extent entry and remove from the bitmap */
+ 	ret = add_free_space_entry(cache, 0, 1 * 1024 * 1024, 0);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't re-add extent entry %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, 4 * 1024 * 1024, 1 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't remove from bitmap %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	if (check_exists(cache, 4 * 1024 * 1024, 1 * 1024 * 1024)) {
+ 		printk(KERN_ERR "Left remnants in the bitmap\n");
+ 		return -1;
+ 	}
+ 
+ 	/*
+ 	 * Ok so a little more evil, extent entry and bitmap at the same offset,
+ 	 * removing an overlapping chunk.
+ 	 */
+ 	ret = add_free_space_entry(cache, 1 * 1024 * 1024, 4 * 1024 * 1024, 1);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't add to a bitmap %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, 512 * 1024, 3 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't remove overlapping space %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	if (check_exists(cache, 512 * 1024, 3 * 1024 * 1024)) {
+ 		printk(KERN_ERR "Left over peices after removing "
+ 		       "overlapping\n");
+ 		return -1;
+ 	}
+ 
+ 	__btrfs_remove_free_space_cache(cache->free_space_ctl);
+ 
+ 	/* Now with the extent entry offset into the bitmap */
+ 	ret = add_free_space_entry(cache, 4 * 1024 * 1024, 4 * 1024 * 1024, 1);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't add space to the bitmap %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = add_free_space_entry(cache, 2 * 1024 * 1024, 2 * 1024 * 1024, 0);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't add extent to the cache %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, 3 * 1024 * 1024, 4 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Problem removing overlapping space %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	if (check_exists(cache, 3 * 1024 * 1024, 4 * 1024 * 1024)) {
+ 		printk(KERN_ERR "Left something behind when removing space");
+ 		return -1;
+ 	}
+ 
+ 	/*
+ 	 * This has blown up in the past, the extent entry starts before the
+ 	 * bitmap entry, but we're trying to remove an offset that falls
+ 	 * completely within the bitmap range and is in both the extent entry
+ 	 * and the bitmap entry, looks like this
+ 	 *
+ 	 *   [ extent ]
+ 	 *      [ bitmap ]
+ 	 *        [ del ]
+ 	 */
+ 	__btrfs_remove_free_space_cache(cache->free_space_ctl);
+ 	ret = add_free_space_entry(cache, bitmap_offset + 4 * 1024 * 1024,
+ 				   4 * 1024 * 1024, 1);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't add bitmap %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = add_free_space_entry(cache, bitmap_offset - 1 * 1024 * 1024,
+ 				   5 * 1024 * 1024, 0);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't add extent entry %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, bitmap_offset + 1 * 1024 * 1024,
+ 				      5 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Failed to free our space %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	if (check_exists(cache, bitmap_offset + 1 * 1024 * 1024,
+ 			 5 * 1024 * 1024)) {
+ 		printk(KERN_ERR "Left stuff over\n");
+ 		return -1;
+ 	}
+ 
+ 	__btrfs_remove_free_space_cache(cache->free_space_ctl);
+ 
+ 	/*
+ 	 * This blew up before, we have part of the free space in a bitmap and
+ 	 * then the entirety of the rest of the space in an extent.  This used
+ 	 * to return -EAGAIN back from btrfs_remove_extent, make sure this
+ 	 * doesn't happen.
+ 	 */
+ 	ret = add_free_space_entry(cache, 1 * 1024 * 1024, 2 * 1024 * 1024, 1);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't add bitmap entry %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = add_free_space_entry(cache, 3 * 1024 * 1024, 1 * 1024 * 1024, 0);
+ 	if (ret) {
+ 		printk(KERN_ERR "Couldn't add extent entry %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	ret = btrfs_remove_free_space(cache, 1 * 1024 * 1024, 3 * 1024 * 1024);
+ 	if (ret) {
+ 		printk(KERN_ERR "Error removing bitmap and extent "
+ 		       "overlapping %d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	__btrfs_remove_free_space_cache(cache->free_space_ctl);
+ 	return 0;
+ }
+ 
+ void btrfs_test_free_space_cache(void)
+ {
+ 	struct btrfs_block_group_cache *cache;
+ 
+ 	printk(KERN_ERR "Running btrfs free space cache tests\n");
+ 
+ 	cache = init_test_block_group();
+ 	if (!cache) {
+ 		printk(KERN_ERR "Couldn't run the tests\n");
+ 		return;
+ 	}
+ 
+ 	if (test_extents(cache))
+ 		goto out;
+ 	if (test_bitmaps(cache))
+ 		goto out;
+ 	if (test_bitmaps_and_extents(cache))
+ 		goto out;
+ out:
+ 	__btrfs_remove_free_space_cache(cache->free_space_ctl);
+ 	kfree(cache->free_space_ctl);
+ 	kfree(cache);
+ 	printk(KERN_ERR "Free space cache tests finished\n");
+ }
++>>>>>>> 8b513d0cf603 (treewide: Fix typo in printk)
  #endif /* CONFIG_BTRFS_FS_RUN_SANITY_TESTS */
* Unmerged path drivers/gpu/drm/radeon/radeon_fb.c
* Unmerged path drivers/infiniband/ulp/isert/ib_isert.c
diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c b/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c
index 00b07032f4f0..5296385153d5 100644
--- a/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c
+++ b/drivers/media/platform/s5p-mfc/s5p_mfc_dec.c
@@ -954,7 +954,7 @@ static int s5p_mfc_queue_setup(struct vb2_queue *vq,
 		psize[0] = ctx->dec_src_buf_size;
 		allocators[0] = ctx->dev->alloc_ctx[MFC_BANK1_ALLOC_CTX];
 	} else {
-		mfc_err("This video node is dedicated to decoding. Decoding not initalised\n");
+		mfc_err("This video node is dedicated to decoding. Decoding not initialized\n");
 		return -EINVAL;
 	}
 	return 0;
diff --git a/drivers/misc/dummy-irq.c b/drivers/misc/dummy-irq.c
index c37eeedfe215..4d0db15df115 100644
--- a/drivers/misc/dummy-irq.c
+++ b/drivers/misc/dummy-irq.c
@@ -26,7 +26,7 @@ static irqreturn_t dummy_interrupt(int irq, void *dev_id)
 	static int count = 0;
 
 	if (count == 0) {
-		printk(KERN_INFO "dummy-irq: interrupt occured on IRQ %d\n",
+		printk(KERN_INFO "dummy-irq: interrupt occurred on IRQ %d\n",
 				irq);
 		count++;
 	}
diff --git a/drivers/misc/lattice-ecp3-config.c b/drivers/misc/lattice-ecp3-config.c
index bb26f086bd8b..61fbe6acabef 100644
--- a/drivers/misc/lattice-ecp3-config.c
+++ b/drivers/misc/lattice-ecp3-config.c
@@ -170,7 +170,7 @@ static void firmware_load(const struct firmware *fw, void *context)
 
 	/* Check result */
 	if (status & FPGA_STATUS_DONE)
-		dev_info(&spi->dev, "FPGA succesfully configured!\n");
+		dev_info(&spi->dev, "FPGA successfully configured!\n");
 	else
 		dev_info(&spi->dev, "FPGA not configured (DONE not set)\n");
 
* Unmerged path drivers/misc/mei/hbm.c
diff --git a/drivers/misc/mei/init.c b/drivers/misc/mei/init.c
index 91c6a4b4255f..e2f4575f238c 100644
--- a/drivers/misc/mei/init.c
+++ b/drivers/misc/mei/init.c
@@ -37,7 +37,7 @@ const char *mei_dev_state_str(int state)
 	MEI_DEV_STATE(POWER_DOWN);
 	MEI_DEV_STATE(POWER_UP);
 	default:
-		return "unkown";
+		return "unknown";
 	}
 #undef MEI_DEV_STATE
 }
diff --git a/drivers/nfc/pn533.c b/drivers/nfc/pn533.c
index 8f6f2baa930d..ec269e6f0375 100644
--- a/drivers/nfc/pn533.c
+++ b/drivers/nfc/pn533.c
@@ -1697,7 +1697,7 @@ static int pn533_poll_complete(struct pn533 *dev, void *arg,
 		goto done;
 
 	if (!dev->poll_mod_count) {
-		nfc_dev_dbg(&dev->interface->dev, "Polling has been stoped.");
+		nfc_dev_dbg(&dev->interface->dev, "Polling has been stopped.");
 		goto done;
 	}
 
diff --git a/drivers/scsi/pm8001/pm80xx_hwi.c b/drivers/scsi/pm8001/pm80xx_hwi.c
index bd6322edc028..fd4ed2a0b1d4 100644
--- a/drivers/scsi/pm8001/pm80xx_hwi.c
+++ b/drivers/scsi/pm8001/pm80xx_hwi.c
@@ -3491,7 +3491,7 @@ static void process_one_iomb(struct pm8001_hba_info *pm8001_ha, void *piomb)
 		break;
 	case OPC_OUB_DEREG_DEV:
 		PM8001_MSG_DBG(pm8001_ha,
-			pm8001_printk("unresgister the deviece\n"));
+			pm8001_printk("unregister the device\n"));
 		pm8001_mpi_dereg_resp(pm8001_ha, piomb);
 		break;
 	case OPC_OUB_GET_DEV_HANDLE:
diff --git a/drivers/tty/serial/serial-tegra.c b/drivers/tty/serial/serial-tegra.c
index 357a8370ce2a..cf1a7a196542 100644
--- a/drivers/tty/serial/serial-tegra.c
+++ b/drivers/tty/serial/serial-tegra.c
@@ -1379,7 +1379,7 @@ static int __init tegra_uart_init(void)
 
 	ret = platform_driver_register(&tegra_uart_platform_driver);
 	if (ret < 0) {
-		pr_err("Uart platfrom driver register failed, e = %d\n", ret);
+		pr_err("Uart platform driver register failed, e = %d\n", ret);
 		uart_unregister_driver(&tegra_uart_driver);
 		return ret;
 	}
diff --git a/drivers/usb/musb/musb_dsps.c b/drivers/usb/musb/musb_dsps.c
index ed5fab9c8c57..2eacad43883b 100644
--- a/drivers/usb/musb/musb_dsps.c
+++ b/drivers/usb/musb/musb_dsps.c
@@ -550,7 +550,7 @@ static int dsps_create_musb_pdev(struct dsps_glue *glue, u8 id)
 		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 		if (!pdata) {
 			dev_err(&pdev->dev,
-				"failed to allocate musb platfrom data\n");
+				"failed to allocate musb platform data\n");
 			ret = -ENOMEM;
 			goto err2;
 		}
diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 628b93fe5ccc..2325ef6bdeed 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -513,7 +513,7 @@ static int omap2430_probe(struct platform_device *pdev)
 		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
 		if (!pdata) {
 			dev_err(&pdev->dev,
-				"failed to allocate musb platfrom data\n");
+				"failed to allocate musb platform data\n");
 			goto err2;
 		}
 
diff --git a/drivers/video/omap2/displays/panel-n8x0.c b/drivers/video/omap2/displays/panel-n8x0.c
index f94ead6a3183..860b18014ad7 100644
--- a/drivers/video/omap2/displays/panel-n8x0.c
+++ b/drivers/video/omap2/displays/panel-n8x0.c
@@ -527,7 +527,7 @@ static int n8x0_panel_update(struct omap_dss_device *dssdev,
 	dh = dssdev->panel.timings.y_res;
 
 	if (x != 0 || y != 0 || w != dw || h != dh) {
-		dev_err(&dssdev->dev, "invaid update region %d, %d, %d, %d\n",
+		dev_err(&dssdev->dev, "invalid update region %d, %d, %d, %d\n",
 			x, y, w, h);
 		return -EINVAL;
 	}
* Unmerged path fs/btrfs/free-space-cache.c
diff --git a/tools/testing/ktest/ktest.pl b/tools/testing/ktest/ktest.pl
index 0d7fd8b51544..999eab1bc64f 100755
--- a/tools/testing/ktest/ktest.pl
+++ b/tools/testing/ktest/ktest.pl
@@ -1796,7 +1796,7 @@ sub monitor {
 		# We already booted into the kernel we are testing,
 		# but now we booted into another kernel?
 		# Consider this a triple fault.
-		doprint "Aleady booted in Linux kernel $version, but now\n";
+		doprint "Already booted in Linux kernel $version, but now\n";
 		doprint "we booted into Linux kernel $1.\n";
 		doprint "Assuming that this is a triple fault.\n";
 		doprint "To disable this: set DETECT_TRIPLE_FAULT to 0\n";
