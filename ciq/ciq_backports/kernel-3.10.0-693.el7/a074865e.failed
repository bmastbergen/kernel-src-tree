perf tools: Introduce perf hooks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit a074865e60edd762b99ec5dacec69b406f702e66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a074865e.failed

Perf hooks allow hooking user code at perf events. They can be used for
manipulation of BPF maps, taking snapshot and reporting results. In this
patch two perf hook points are introduced: record_start and record_end.

To avoid buggy user actions, a SIGSEGV signal handler is introduced into
'perf record'. It turns off perf hook if it causes a segfault and report
an error to help debugging.

A test case for perf hook is introduced.

Test result:
  $ ./buildperf/perf test -v hook
  50: Test perf hooks                                          :
  --- start ---
  test child forked, pid 10311
  SIGSEGV is observed as expected, try to recover.
  Fatal error (SEGFAULT) in perf hook 'test'
  test child finished with 0
  ---- end ----
  Test perf hooks: Ok

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Cc: Alexei Starovoitov <ast@fb.com>
	Cc: He Kuang <hekuang@huawei.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Joe Stringer <joe@ovn.org>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/20161126070354.141764-5-wangnan0@huawei.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit a074865e60edd762b99ec5dacec69b406f702e66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-record.c
#	tools/perf/tests/Build
#	tools/perf/tests/builtin-test.c
#	tools/perf/tests/tests.h
diff --cc tools/perf/builtin-record.c
index 9dd9b9ad314f,fa26865364b6..000000000000
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@@ -33,6 -34,10 +33,13 @@@
  #include "util/tsc.h"
  #include "util/parse-branch-options.h"
  #include "util/parse-regs-options.h"
++<<<<<<< HEAD
++=======
+ #include "util/llvm-utils.h"
+ #include "util/bpf-loader.h"
+ #include "util/trigger.h"
+ #include "util/perf-hooks.h"
++>>>>>>> a074865e60ed (perf tools: Introduce perf hooks)
  #include "asm/bug.h"
  
  #include <unistd.h>
@@@ -811,10 -840,14 +824,11 @@@ static int __cmd_record(struct record *
  	signal(SIGCHLD, sig_handler);
  	signal(SIGINT, sig_handler);
  	signal(SIGTERM, sig_handler);
+ 	signal(SIGSEGV, sigsegv_handler);
  
 -	if (rec->opts.auxtrace_snapshot_mode || rec->switch_output) {
 +	if (rec->opts.auxtrace_snapshot_mode) {
  		signal(SIGUSR2, snapshot_sig_handler);
 -		if (rec->opts.auxtrace_snapshot_mode)
 -			trigger_on(&auxtrace_snapshot_trigger);
 -		if (rec->switch_output)
 -			trigger_on(&switch_output_trigger);
 +		auxtrace_snapshot_on();
  	} else {
  		signal(SIGUSR2, SIG_IGN);
  	}
@@@ -933,7 -976,9 +947,13 @@@
  		perf_evlist__enable(rec->evlist);
  	}
  
++<<<<<<< HEAD
 +	auxtrace_snapshot_enable();
++=======
+ 	trigger_ready(&auxtrace_snapshot_trigger);
+ 	trigger_ready(&switch_output_trigger);
+ 	perf_hooks__invoke_record_start();
++>>>>>>> a074865e60ed (perf tools: Introduce perf hooks)
  	for (;;) {
  		unsigned long long hits = rec->samples;
  
diff --cc tools/perf/tests/Build
index 0940f32e3e4a,af3ec94869aa..000000000000
--- a/tools/perf/tests/Build
+++ b/tools/perf/tests/Build
@@@ -37,6 -39,38 +37,41 @@@ perf-y += stat.
  perf-y += event_update.o
  perf-y += event-times.o
  perf-y += backward-ring-buffer.o
++<<<<<<< HEAD
++=======
+ perf-y += sdt.o
+ perf-y += is_printable_array.o
+ perf-y += bitmap.o
+ perf-y += perf-hooks.o
+ 
+ $(OUTPUT)tests/llvm-src-base.c: tests/bpf-script-example.c tests/Build
+ 	$(call rule_mkdir)
+ 	$(Q)echo '#include <tests/llvm.h>' > $@
+ 	$(Q)echo 'const char test_llvm__bpf_base_prog[] =' >> $@
+ 	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
+ 	$(Q)echo ';' >> $@
+ 
+ $(OUTPUT)tests/llvm-src-kbuild.c: tests/bpf-script-test-kbuild.c tests/Build
+ 	$(call rule_mkdir)
+ 	$(Q)echo '#include <tests/llvm.h>' > $@
+ 	$(Q)echo 'const char test_llvm__bpf_test_kbuild_prog[] =' >> $@
+ 	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
+ 	$(Q)echo ';' >> $@
+ 
+ $(OUTPUT)tests/llvm-src-prologue.c: tests/bpf-script-test-prologue.c tests/Build
+ 	$(call rule_mkdir)
+ 	$(Q)echo '#include <tests/llvm.h>' > $@
+ 	$(Q)echo 'const char test_llvm__bpf_test_prologue_prog[] =' >> $@
+ 	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
+ 	$(Q)echo ';' >> $@
+ 
+ $(OUTPUT)tests/llvm-src-relocation.c: tests/bpf-script-test-relocation.c tests/Build
+ 	$(call rule_mkdir)
+ 	$(Q)echo '#include <tests/llvm.h>' > $@
+ 	$(Q)echo 'const char test_llvm__bpf_test_relocation[] =' >> $@
+ 	$(Q)sed -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/g' $< >> $@
+ 	$(Q)echo ';' >> $@
++>>>>>>> a074865e60ed (perf tools: Introduce perf hooks)
  
  ifeq ($(ARCH),$(filter $(ARCH),x86 arm arm64 powerpc))
  perf-$(CONFIG_DWARF_UNWIND) += dwarf-unwind.o
diff --cc tools/perf/tests/builtin-test.c
index da4eec430844,dab83f7042fa..000000000000
--- a/tools/perf/tests/builtin-test.c
+++ b/tools/perf/tests/builtin-test.c
@@@ -200,6 -218,22 +200,25 @@@ static struct test generic_tests[] = 
  		.func = test__cpu_map_print,
  	},
  	{
++<<<<<<< HEAD
++=======
+ 		.desc = "Test SDT event probing",
+ 		.func = test__sdt_event,
+ 	},
+ 	{
+ 		.desc = "Test is_printable_array function",
+ 		.func = test__is_printable_array,
+ 	},
+ 	{
+ 		.desc = "Test bitmap print",
+ 		.func = test__bitmap_print,
+ 	},
+ 	{
+ 		.desc = "Test perf hooks",
+ 		.func = test__perf_hooks,
+ 	},
+ 	{
++>>>>>>> a074865e60ed (perf tools: Introduce perf hooks)
  		.func = NULL,
  	},
  };
diff --cc tools/perf/tests/tests.h
index cda0d2d339ef,3a1f98f291ba..000000000000
--- a/tools/perf/tests/tests.h
+++ b/tools/perf/tests/tests.h
@@@ -75,6 -88,10 +75,13 @@@ int test__event_update(int subtest)
  int test__event_times(int subtest);
  int test__backward_ring_buffer(int subtest);
  int test__cpu_map_print(int subtest);
++<<<<<<< HEAD
++=======
+ int test__sdt_event(int subtest);
+ int test__is_printable_array(int subtest);
+ int test__bitmap_print(int subtest);
+ int test__perf_hooks(int subtest);
++>>>>>>> a074865e60ed (perf tools: Introduce perf hooks)
  
  #if defined(__arm__) || defined(__aarch64__)
  #ifdef HAVE_DWARF_UNWIND_SUPPORT
* Unmerged path tools/perf/builtin-record.c
* Unmerged path tools/perf/tests/Build
* Unmerged path tools/perf/tests/builtin-test.c
diff --git a/tools/perf/tests/perf-hooks.c b/tools/perf/tests/perf-hooks.c
new file mode 100644
index 000000000000..9338cb2c25ab
--- /dev/null
+++ b/tools/perf/tests/perf-hooks.c
@@ -0,0 +1,44 @@
+#include <signal.h>
+#include <stdlib.h>
+
+#include "tests.h"
+#include "debug.h"
+#include "util.h"
+#include "perf-hooks.h"
+
+static void sigsegv_handler(int sig __maybe_unused)
+{
+	pr_debug("SIGSEGV is observed as expected, try to recover.\n");
+	perf_hooks__recover();
+	signal(SIGSEGV, SIG_DFL);
+	raise(SIGSEGV);
+	exit(-1);
+}
+
+static int hook_flags;
+
+static void the_hook(void)
+{
+	int *p = NULL;
+
+	hook_flags = 1234;
+
+	/* Generate a segfault, test perf_hooks__recover */
+	*p = 0;
+}
+
+int test__perf_hooks(int subtest __maybe_unused)
+{
+	signal(SIGSEGV, sigsegv_handler);
+	perf_hooks__set_hook("test", the_hook);
+	perf_hooks__invoke_test();
+
+	/* hook is triggered? */
+	if (hook_flags != 1234)
+		return TEST_FAIL;
+
+	/* the buggy hook is removed? */
+	if (perf_hooks__get_hook("test"))
+		return TEST_FAIL;
+	return TEST_OK;
+}
* Unmerged path tools/perf/tests/tests.h
diff --git a/tools/perf/util/Build b/tools/perf/util/Build
index 09bbe84a21c0..1d20693236d8 100644
--- a/tools/perf/util/Build
+++ b/tools/perf/util/Build
@@ -117,6 +117,8 @@ libperf-$(CONFIG_LIBELF) += genelf.o
 libperf-$(CONFIG_DWARF) += genelf_debug.o
 endif
 
+libperf-y += perf-hooks.o
+
 CFLAGS_config.o   += -DETC_PERFCONFIG="BUILD_STR($(ETC_PERFCONFIG_SQ))"
 # avoid compiler warnings in 32-bit mode
 CFLAGS_genelf_debug.o  += -Wno-packed
diff --git a/tools/perf/util/perf-hooks-list.h b/tools/perf/util/perf-hooks-list.h
new file mode 100644
index 000000000000..2867c07ee84e
--- /dev/null
+++ b/tools/perf/util/perf-hooks-list.h
@@ -0,0 +1,3 @@
+PERF_HOOK(record_start)
+PERF_HOOK(record_end)
+PERF_HOOK(test)
diff --git a/tools/perf/util/perf-hooks.c b/tools/perf/util/perf-hooks.c
new file mode 100644
index 000000000000..4ce88e37dd63
--- /dev/null
+++ b/tools/perf/util/perf-hooks.c
@@ -0,0 +1,84 @@
+/*
+ * perf_hooks.c
+ *
+ * Copyright (C) 2016 Wang Nan <wangnan0@huawei.com>
+ * Copyright (C) 2016 Huawei Inc.
+ */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <setjmp.h>
+#include <linux/err.h>
+#include "util/util.h"
+#include "util/debug.h"
+#include "util/perf-hooks.h"
+
+static sigjmp_buf jmpbuf;
+static const struct perf_hook_desc *current_perf_hook;
+
+void perf_hooks__invoke(const struct perf_hook_desc *desc)
+{
+	if (!(desc && desc->p_hook_func && *desc->p_hook_func))
+		return;
+
+	if (sigsetjmp(jmpbuf, 1)) {
+		pr_warning("Fatal error (SEGFAULT) in perf hook '%s'\n",
+			   desc->hook_name);
+		*(current_perf_hook->p_hook_func) = NULL;
+	} else {
+		current_perf_hook = desc;
+		(**desc->p_hook_func)();
+	}
+	current_perf_hook = NULL;
+}
+
+void perf_hooks__recover(void)
+{
+	if (current_perf_hook)
+		siglongjmp(jmpbuf, 1);
+}
+
+#define PERF_HOOK(name)					\
+perf_hook_func_t __perf_hook_func_##name = NULL;	\
+struct perf_hook_desc __perf_hook_desc_##name =		\
+	{.hook_name = #name, .p_hook_func = &__perf_hook_func_##name};
+#include "perf-hooks-list.h"
+#undef PERF_HOOK
+
+#define PERF_HOOK(name)		\
+	&__perf_hook_desc_##name,
+
+static struct perf_hook_desc *perf_hooks[] = {
+#include "perf-hooks-list.h"
+};
+#undef PERF_HOOK
+
+int perf_hooks__set_hook(const char *hook_name,
+			 perf_hook_func_t hook_func)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(perf_hooks); i++) {
+		if (strcmp(hook_name, perf_hooks[i]->hook_name) != 0)
+			continue;
+
+		if (*(perf_hooks[i]->p_hook_func))
+			pr_warning("Overwrite existing hook: %s\n", hook_name);
+		*(perf_hooks[i]->p_hook_func) = hook_func;
+		return 0;
+	}
+	return -ENOENT;
+}
+
+perf_hook_func_t perf_hooks__get_hook(const char *hook_name)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(perf_hooks); i++) {
+		if (strcmp(hook_name, perf_hooks[i]->hook_name) != 0)
+			continue;
+
+		return *(perf_hooks[i]->p_hook_func);
+	}
+	return ERR_PTR(-ENOENT);
+}
diff --git a/tools/perf/util/perf-hooks.h b/tools/perf/util/perf-hooks.h
new file mode 100644
index 000000000000..1d482b26b4b9
--- /dev/null
+++ b/tools/perf/util/perf-hooks.h
@@ -0,0 +1,37 @@
+#ifndef PERF_UTIL_PERF_HOOKS_H
+#define PERF_UTIL_PERF_HOOKS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void (*perf_hook_func_t)(void);
+struct perf_hook_desc {
+	const char * const hook_name;
+	perf_hook_func_t * const p_hook_func;
+};
+
+extern void perf_hooks__invoke(const struct perf_hook_desc *);
+extern void perf_hooks__recover(void);
+
+#define PERF_HOOK(name)					\
+extern struct perf_hook_desc __perf_hook_desc_##name;	\
+static inline void perf_hooks__invoke_##name(void)	\
+{ 							\
+	perf_hooks__invoke(&__perf_hook_desc_##name);	\
+}
+
+#include "perf-hooks-list.h"
+#undef PERF_HOOK
+
+extern int
+perf_hooks__set_hook(const char *hook_name,
+		     perf_hook_func_t hook_func);
+
+extern perf_hook_func_t
+perf_hooks__get_hook(const char *hook_name);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
