net/sock: add an explicit sk argument for ip_cmsg_recv_offset()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sock: add an explicit sk argument for ip_cmsg_recv_offset() (Paolo Abeni) [1388467]
Rebuild_FUZZ: 96.72%
commit-author Paolo Abeni <pabeni@redhat.com>
commit ad959036a70890bea121403c6a4e373dff5b7311
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ad959036.failed

So that we can use it even after orphaining the skbuff.

	Suggested-by: Eric Dumazet <eric.dumazet@gmail.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ad959036a70890bea121403c6a4e373dff5b7311)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip.h
#	net/ipv4/ip_sockglue.c
#	net/ipv4/udp.c
#	net/ipv6/udp.c
diff --cc include/net/ip.h
index 5506ed81f7f4,f48c67cab222..000000000000
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@@ -528,8 -579,10 +528,15 @@@ int ip_options_rcv_srr(struct sk_buff *
   */
  
  void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb);
++<<<<<<< HEAD
 +void ip_cmsg_recv(struct msghdr *msg, struct sk_buff *skb);
 +int ip_cmsg_send(struct net *net, struct msghdr *msg, struct ipcm_cookie *ipc);
++=======
+ void ip_cmsg_recv_offset(struct msghdr *msg, struct sock *sk,
+ 			 struct sk_buff *skb, int tlen, int offset);
+ int ip_cmsg_send(struct sock *sk, struct msghdr *msg,
+ 		 struct ipcm_cookie *ipc, bool allow_ipv6);
++>>>>>>> ad959036a708 (net/sock: add an explicit sk argument for ip_cmsg_recv_offset())
  int ip_setsockopt(struct sock *sk, int level, int optname, char __user *optval,
  		  unsigned int optlen);
  int ip_getsockopt(struct sock *sk, int level, int optname, char __user *optval,
@@@ -547,6 -600,15 +554,18 @@@ void ip_icmp_error(struct sock *sk, str
  void ip_local_error(struct sock *sk, int err, __be32 daddr, __be16 dport,
  		    u32 info);
  
++<<<<<<< HEAD
++=======
+ static inline void ip_cmsg_recv(struct msghdr *msg, struct sk_buff *skb)
+ {
+ 	ip_cmsg_recv_offset(msg, skb->sk, skb, 0, 0);
+ }
+ 
+ bool icmp_global_allow(void);
+ extern int sysctl_icmp_msgs_per_sec;
+ extern int sysctl_icmp_msgs_burst;
+ 
++>>>>>>> ad959036a708 (net/sock: add an explicit sk argument for ip_cmsg_recv_offset())
  #ifdef CONFIG_PROC_FS
  int ip_misc_proc_init(void);
  #endif
diff --cc net/ipv4/ip_sockglue.c
index 29d411fe019d,8b13881ed064..000000000000
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@@ -145,9 -164,10 +145,14 @@@ static void ip_cmsg_recv_dstaddr(struc
  	put_cmsg(msg, SOL_IP, IP_ORIGDSTADDR, sizeof(sin), &sin);
  }
  
++<<<<<<< HEAD
 +void ip_cmsg_recv(struct msghdr *msg, struct sk_buff *skb)
++=======
+ void ip_cmsg_recv_offset(struct msghdr *msg, struct sock *sk,
+ 			 struct sk_buff *skb, int tlen, int offset)
++>>>>>>> ad959036a708 (net/sock: add an explicit sk argument for ip_cmsg_recv_offset())
  {
- 	struct inet_sock *inet = inet_sk(skb->sk);
+ 	struct inet_sock *inet = inet_sk(sk);
  	unsigned int flags = inet->cmsg_flags;
  
  	/* Ordered by supposed usage frequency */
diff --cc net/ipv4/udp.c
index a02b20ab0f64,28a0165cb848..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -1313,7 -1421,7 +1313,11 @@@ try_again
  		*addr_len = sizeof(*sin);
  	}
  	if (inet->cmsg_flags)
++<<<<<<< HEAD
 +		ip_cmsg_recv(msg, skb);
++=======
+ 		ip_cmsg_recv_offset(msg, sk, skb, sizeof(struct udphdr), off);
++>>>>>>> ad959036a708 (net/sock: add an explicit sk argument for ip_cmsg_recv_offset())
  
  	err = copied;
  	if (flags & MSG_TRUNC)
diff --cc net/ipv6/udp.c
index addc33af6bd2,b5a23ce8981d..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -494,12 -419,17 +494,17 @@@ try_again
  		}
  		*addr_len = sizeof(*sin6);
  	}
 -
 -	if (np->rxopt.all)
 -		ip6_datagram_recv_common_ctl(sk, msg, skb);
 -
  	if (is_udp4) {
  		if (inet->cmsg_flags)
++<<<<<<< HEAD
 +			ip_cmsg_recv(msg, skb);
++=======
+ 			ip_cmsg_recv_offset(msg, sk, skb,
+ 					    sizeof(struct udphdr), off);
++>>>>>>> ad959036a708 (net/sock: add an explicit sk argument for ip_cmsg_recv_offset())
  	} else {
  		if (np->rxopt.all)
 -			ip6_datagram_recv_specific_ctl(sk, msg, skb);
 +			ip6_datagram_recv_ctl(sk, msg, skb);
  	}
  
  	err = copied;
* Unmerged path include/net/ip.h
* Unmerged path net/ipv4/ip_sockglue.c
* Unmerged path net/ipv4/udp.c
* Unmerged path net/ipv6/udp.c
