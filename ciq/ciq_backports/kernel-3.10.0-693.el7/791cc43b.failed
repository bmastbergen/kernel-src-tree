Make __xfs_xattr_put_listen preperly report errors.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] Make __xfs_xattr_put_listen preperly report errors (Brian Foster) [1419532]
Rebuild_FUZZ: 99.01%
commit-author Artem Savkov <asavkov@redhat.com>
commit 791cc43b36eb1f88166c8505900cad1b43c7fe1a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/791cc43b.failed

Commit 2a6fba6 "xfs: only return -errno or success from attr ->put_listent"
changes the returnvalue of __xfs_xattr_put_listen to 0 in case when there is
insufficient space in the buffer assuming that setting context->count to -1
would be enough, but all of the ->put_listent callers only check seen_enough.
This results in a failed assertion:
XFS: Assertion failed: context->count >= 0, file: fs/xfs/xfs_xattr.c, line: 175
in insufficient buffer size case.

This is only reproducible with at least 2 xattrs and only when the buffer
gets depleted before the last one.

Furthermore if buffersize is such that it is enough to hold the last xattr's
name, but not enough to hold the sum of preceeding xattr names listxattr won't
fail with ERANGE, but will suceed returning last xattr's name without the
first character. The first character end's up overwriting data stored at
(context->alist - 1).

	Signed-off-by: Artem Savkov <asavkov@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 791cc43b36eb1f88166c8505900cad1b43c7fe1a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_xattr.c
diff --cc fs/xfs/xfs_xattr.c
index 2a753b46d3d8,62900938f26d..000000000000
--- a/fs/xfs/xfs_xattr.c
+++ b/fs/xfs/xfs_xattr.c
@@@ -133,24 -130,36 +133,46 @@@ const struct xattr_handler *xfs_xattr_h
  	NULL
  };
  
 -static int
 -__xfs_xattr_put_listent(
 -	struct xfs_attr_list_context *context,
 -	char *prefix,
 -	int prefix_len,
 -	unsigned char *name,
 -	int namelen)
 +static unsigned int xfs_xattr_prefix_len(int flags)
  {
 -	char *offset;
 -	int arraytop;
 +	if (flags & XFS_ATTR_SECURE)
 +		return sizeof("security");
 +	else if (flags & XFS_ATTR_ROOT)
 +		return sizeof("trusted");
 +	else
 +		return sizeof("user");
 +}
  
++<<<<<<< HEAD
 +static const char *xfs_xattr_prefix(int flags)
 +{
 +	if (flags & XFS_ATTR_SECURE)
 +		return xfs_xattr_security_handler.prefix;
 +	else if (flags & XFS_ATTR_ROOT)
 +		return xfs_xattr_trusted_handler.prefix;
 +	else
 +		return xfs_xattr_user_handler.prefix;
++=======
+ 	if (!context->alist)
+ 		goto compute_size;
+ 
+ 	arraytop = context->count + prefix_len + namelen + 1;
+ 	if (arraytop > context->firstu) {
+ 		context->count = -1;	/* insufficient space */
+ 		context->seen_enough = 1;
+ 		return 0;
+ 	}
+ 	offset = (char *)context->alist + context->count;
+ 	strncpy(offset, prefix, prefix_len);
+ 	offset += prefix_len;
+ 	strncpy(offset, (char *)name, namelen);			/* real name */
+ 	offset += namelen;
+ 	*offset = '\0';
+ 
+ compute_size:
+ 	context->count += prefix_len + namelen + 1;
+ 	return 0;
++>>>>>>> 791cc43b36eb (Make __xfs_xattr_put_listen preperly report errors.)
  }
  
  static int
* Unmerged path fs/xfs/xfs_xattr.c
