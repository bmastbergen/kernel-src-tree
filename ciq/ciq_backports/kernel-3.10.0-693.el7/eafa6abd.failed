net/mlx5: remove a duplicate condition

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: remove a duplicate condition (Don Dutile) [1385330 1417286]
Rebuild_FUZZ: 94.44%
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit eafa6abd99eadb8971c01a4c591295ac4d8d0a9b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/eafa6abd.failed

We verified that MLX5_FLOW_CONTEXT_ACTION_COUNT was set on the first
line of the function so we don't need to check again here.

	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Acked-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit eafa6abd99eadb8971c01a4c591295ac4d8d0a9b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index b32d85f4e0ff,a263d8904a4c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -1101,23 -1280,69 +1101,77 @@@ unlock_fte
  	unlock_ref_node(&fte->node);
  unlock_fg:
  	unlock_ref_node(&fg->node);
 -	return handle;
 +	return rule;
  }
  
++<<<<<<< HEAD
 +static struct mlx5_flow_rule *
 +_mlx5_add_flow_rule(struct mlx5_flow_table *ft,
 +		    u8 match_criteria_enable,
 +		    u32 *match_criteria,
 +		    u32 *match_value,
 +		    u32 action,
 +		    u32 flow_tag,
 +		    struct mlx5_flow_destination *dest)
++=======
+ struct mlx5_fc *mlx5_flow_rule_counter(struct mlx5_flow_handle *handle)
+ {
+ 	struct mlx5_flow_rule *dst;
+ 	struct fs_fte *fte;
+ 
+ 	fs_get_obj(fte, handle->rule[0]->node.parent);
+ 
+ 	fs_for_each_dst(dst, fte) {
+ 		if (dst->dest_attr.type == MLX5_FLOW_DESTINATION_TYPE_COUNTER)
+ 			return dst->dest_attr.counter;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static bool counter_is_valid(struct mlx5_fc *counter, u32 action)
+ {
+ 	if (!(action & MLX5_FLOW_CONTEXT_ACTION_COUNT))
+ 		return !counter;
+ 
+ 	if (!counter)
+ 		return false;
+ 
+ 	return (action & (MLX5_FLOW_CONTEXT_ACTION_DROP |
+ 			  MLX5_FLOW_CONTEXT_ACTION_FWD_DEST));
+ }
+ 
+ static bool dest_is_valid(struct mlx5_flow_destination *dest,
+ 			  u32 action,
+ 			  struct mlx5_flow_table *ft)
+ {
+ 	if (dest && (dest->type == MLX5_FLOW_DESTINATION_TYPE_COUNTER))
+ 		return counter_is_valid(dest->counter, action);
+ 
+ 	if (!(action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST))
+ 		return true;
+ 
+ 	if (!dest || ((dest->type ==
+ 	    MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE) &&
+ 	    (dest->ft->level <= ft->level)))
+ 		return false;
+ 	return true;
+ }
+ 
+ static struct mlx5_flow_handle *
+ _mlx5_add_flow_rules(struct mlx5_flow_table *ft,
+ 		     struct mlx5_flow_spec *spec,
+ 		     struct mlx5_flow_act *flow_act,
+ 		     struct mlx5_flow_destination *dest,
+ 		     int dest_num)
+ 
++>>>>>>> eafa6abd99ea (net/mlx5: remove a duplicate condition)
  {
  	struct mlx5_flow_group *g;
 -	struct mlx5_flow_handle *rule;
 -	int i;
 +	struct mlx5_flow_rule *rule;
  
 -	for (i = 0; i < dest_num; i++) {
 -		if (!dest_is_valid(&dest[i], flow_act->action, ft))
 -			return ERR_PTR(-EINVAL);
 -	}
 +	if ((action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST) && !dest)
 +		return ERR_PTR(-EINVAL);
  
  	nested_lock_ref_node(&ft->node, FS_MUTEX_GRANDPARENT);
  	fs_for_each_fg(g, ft)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
