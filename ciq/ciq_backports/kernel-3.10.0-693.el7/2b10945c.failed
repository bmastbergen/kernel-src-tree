dax: Remove dead zeroing code from fault handlers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jan Kara <jack@suse.cz>
commit 2b10945c532c165a824f541df76a15ed0be04d78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2b10945c.failed

Now that all filesystems zero out blocks allocated for a fault handler,
we can just remove the zeroing from the handler itself. Also add checks
that no filesystem returns to us unwritten or new buffer.

	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
(cherry picked from commit 2b10945c532c165a824f541df76a15ed0be04d78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
diff --cc fs/dax.c
index ac0232cd059c,ccb8bc399d78..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -598,10 -587,6 +598,13 @@@ static int dax_insert_mapping(struct in
  		error = PTR_ERR(dax.addr);
  		goto out;
  	}
++<<<<<<< HEAD
 +
 +	if (buffer_unwritten(bh) || buffer_new(bh)) {
 +		clear_pmem(dax.addr, PAGE_SIZE);
 +	}
++=======
++>>>>>>> 2b10945c532c (dax: Remove dead zeroing code from fault handlers)
  	dax_unmap_atomic(bdev, &dax);
  
  	error = dax_radix_entry(mapping, vmf->pgoff, dax.sector, false,
@@@ -737,23 -716,9 +740,28 @@@ int __dax_fault(struct vm_area_struct *
  		page = NULL;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * If we successfully insert the new mapping over an unwritten extent,
 +	 * we need to ensure we convert the unwritten extent. If there is an
 +	 * error inserting the mapping, the filesystem needs to leave it as
 +	 * unwritten to prevent exposure of the stale underlying data to
 +	 * userspace, but we still need to call the completion function so
 +	 * the private resources on the mapping buffer can be released. We
 +	 * indicate what the callback should do via the uptodate variable, same
 +	 * as for normal BH based IO completions.
 +	 */
++=======
+ 	/* Filesystem should not return unwritten buffers to us! */
+ 	WARN_ON_ONCE(buffer_unwritten(&bh) || buffer_new(&bh));
++>>>>>>> 2b10945c532c (dax: Remove dead zeroing code from fault handlers)
  	error = dax_insert_mapping(inode, &bh, vma, vmf);
 +	if (buffer_unwritten(&bh)) {
 +		if (complete_unwritten)
 +			complete_unwritten(&bh, !error);
 +		else
 +			WARN_ON_ONCE(!(vmf->flags & FAULT_FLAG_WRITE));
 +	}
  
   out:
  	if (error == -ENOMEM)
@@@ -856,6 -849,7 +864,10 @@@ int __dax_pmd_fault(struct vm_area_stru
  		if (get_block(inode, block, &bh, 1) != 0)
  			return VM_FAULT_SIGBUS;
  		alloc = true;
++<<<<<<< HEAD
++=======
+ 		WARN_ON_ONCE(buffer_unwritten(&bh) || buffer_new(&bh));
++>>>>>>> 2b10945c532c (dax: Remove dead zeroing code from fault handlers)
  	}
  
  	bdev = bh.b_bdev;
@@@ -949,13 -942,12 +961,16 @@@
  			dax_unmap_atomic(bdev, &dax);
  			goto fallback;
  		}
++<<<<<<< HEAD
  
 -		if (!pfn_t_devmap(dax.pfn)) {
 -			dax_unmap_atomic(bdev, &dax);
 -			dax_pmd_dbg(&bh, address, "pfn not in memmap");
 -			goto fallback;
 +		if (buffer_unwritten(&bh) || buffer_new(&bh)) {
 +			clear_pmem(dax.addr, PMD_SIZE);
 +			count_vm_event(PGMAJFAULT);
 +			mem_cgroup_count_vm_event(vma->vm_mm, PGMAJFAULT);
 +			result |= VM_FAULT_MAJOR;
  		}
++=======
++>>>>>>> 2b10945c532c (dax: Remove dead zeroing code from fault handlers)
  		dax_unmap_atomic(bdev, &dax);
  
  		/*
* Unmerged path fs/dax.c
