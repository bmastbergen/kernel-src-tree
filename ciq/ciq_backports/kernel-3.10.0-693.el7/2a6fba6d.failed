xfs: only return -errno or success from attr ->put_listent

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric Sandeen <sandeen@sandeen.net>
commit 2a6fba6d2311151598abaa1e7c9abd5f8d024a43
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2a6fba6d.failed

Today, the put_listent formatters return either 1 or 0; if
they return 1, some callers treat this as an error and return
it up the stack, despite "1" not being a valid (negative)
error code.

The intent seems to be that if the input buffer is full,
we set seen_enough or set count = -1, and return 1;
but some callers check the return before checking the
seen_enough or count fields of the context.

Fix this by only returning non-zero for actual errors
encountered, and rely on the caller to first check the
return value, then check the values in the context to
decide what to do.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 2a6fba6d2311151598abaa1e7c9abd5f8d024a43)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_xattr.c
diff --cc fs/xfs/xfs_xattr.c
index 2a753b46d3d8,f2201299311f..000000000000
--- a/fs/xfs/xfs_xattr.c
+++ b/fs/xfs/xfs_xattr.c
@@@ -133,24 -129,35 +133,45 @@@ const struct xattr_handler *xfs_xattr_h
  	NULL
  };
  
 -static int
 -__xfs_xattr_put_listent(
 -	struct xfs_attr_list_context *context,
 -	char *prefix,
 -	int prefix_len,
 -	unsigned char *name,
 -	int namelen)
 +static unsigned int xfs_xattr_prefix_len(int flags)
  {
 -	char *offset;
 -	int arraytop;
 +	if (flags & XFS_ATTR_SECURE)
 +		return sizeof("security");
 +	else if (flags & XFS_ATTR_ROOT)
 +		return sizeof("trusted");
 +	else
 +		return sizeof("user");
 +}
  
++<<<<<<< HEAD
 +static const char *xfs_xattr_prefix(int flags)
 +{
 +	if (flags & XFS_ATTR_SECURE)
 +		return xfs_xattr_security_handler.prefix;
 +	else if (flags & XFS_ATTR_ROOT)
 +		return xfs_xattr_trusted_handler.prefix;
 +	else
 +		return xfs_xattr_user_handler.prefix;
++=======
+ 	if (!context->alist)
+ 		goto compute_size;
+ 
+ 	arraytop = context->count + prefix_len + namelen + 1;
+ 	if (arraytop > context->firstu) {
+ 		context->count = -1;	/* insufficient space */
+ 		return 0;
+ 	}
+ 	offset = (char *)context->alist + context->count;
+ 	strncpy(offset, prefix, prefix_len);
+ 	offset += prefix_len;
+ 	strncpy(offset, (char *)name, namelen);			/* real name */
+ 	offset += namelen;
+ 	*offset = '\0';
+ 
+ compute_size:
+ 	context->count += prefix_len + namelen + 1;
+ 	return 0;
++>>>>>>> 2a6fba6d2311 (xfs: only return -errno or success from attr ->put_listent)
  }
  
  static int
@@@ -224,8 -228,8 +248,13 @@@ xfs_vn_listxattr
  {
  	struct xfs_attr_list_context context;
  	struct attrlist_cursor_kern cursor = { 0 };
++<<<<<<< HEAD
 +	struct inode		*inode = dentry->d_inode;
 +	int			error;
++=======
+ 	struct inode	*inode = d_inode(dentry);
+ 	int		error;
++>>>>>>> 2a6fba6d2311 (xfs: only return -errno or success from attr ->put_listent)
  
  	/*
  	 * First read the regular on-disk attributes.
@@@ -234,16 -238,14 +263,18 @@@
  	context.dp = XFS_I(inode);
  	context.cursor = &cursor;
  	context.resynch = 1;
 -	context.alist = size ? data : NULL;
 +	context.alist = data;
  	context.bufsize = size;
  	context.firstu = context.bufsize;
 -	context.put_listent = xfs_xattr_put_listent;
 +
 +	if (size)
 +		context.put_listent = xfs_xattr_put_listent;
 +	else
 +		context.put_listent = xfs_xattr_put_listent_sizes;
  
- 	xfs_attr_list_int(&context);
+ 	error = xfs_attr_list_int(&context);
+ 	if (error)
+ 		return error;
  	if (context.count < 0)
  		return -ERANGE;
  
diff --git a/fs/xfs/xfs_attr.h b/fs/xfs/xfs_attr.h
index dd4824589470..234331227c0c 100644
--- a/fs/xfs/xfs_attr.h
+++ b/fs/xfs/xfs_attr.h
@@ -112,6 +112,7 @@ typedef struct attrlist_cursor_kern {
  *========================================================================*/
 
 
+/* Return 0 on success, or -errno; other state communicated via *context */
 typedef int (*put_listent_func_t)(struct xfs_attr_list_context *, int,
 			      unsigned char *, int, int, unsigned char *);
 
diff --git a/fs/xfs/xfs_attr_list.c b/fs/xfs/xfs_attr_list.c
index 4fa14820e2e2..c8be331a3196 100644
--- a/fs/xfs/xfs_attr_list.c
+++ b/fs/xfs/xfs_attr_list.c
@@ -108,16 +108,14 @@ xfs_attr_shortform_list(xfs_attr_list_context_t *context)
 					   (int)sfe->namelen,
 					   (int)sfe->valuelen,
 					   &sfe->nameval[sfe->namelen]);
-
+			if (error)
+				return error;
 			/*
 			 * Either search callback finished early or
 			 * didn't fit it all in the buffer after all.
 			 */
 			if (context->seen_enough)
 				break;
-
-			if (error)
-				return error;
 			sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
 		}
 		trace_xfs_attr_list_sf_all(context);
@@ -581,7 +579,7 @@ xfs_attr_put_listent(
 		trace_xfs_attr_list_full(context);
 		alist->al_more = 1;
 		context->seen_enough = 1;
-		return 1;
+		return 0;
 	}
 
 	aep = (attrlist_ent_t *)&context->alist[context->firstu];
* Unmerged path fs/xfs/xfs_xattr.c
