s390/cpuinfo: show maximum thread id

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [s390] cpuinfo: show maximum thread id (Hendrik Brueckner) [1399563]
Rebuild_FUZZ: 92.54%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit 10f4954ae67b3be6dac3cdfb1e0057c3779542be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/10f4954a.failed

Expose the maximum thread id with /proc/cpuinfo.
With the new line the output looks like this:

vendor_id       : IBM/S390
bogomips per cpu: 20325.00
max thread id   : 1

With this new interface it is possible to always tell the correct
number of cpu threads potentially being used by the kernel.

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 10f4954ae67b3be6dac3cdfb1e0057c3779542be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kernel/processor.c
diff --cc arch/s390/kernel/processor.c
index 37adaeef71e8,81d0808085e6..000000000000
--- a/arch/s390/kernel/processor.c
+++ b/arch/s390/kernel/processor.c
@@@ -54,30 -97,27 +54,52 @@@ static int show_cpuinfo(struct seq_fil
  	static const char * const int_hwcap_str[] = {
  		"sie"
  	};
 -	int i, cpu;
 -
 +	unsigned long n = (unsigned long) v - 1;
 +	int i;
 +
++<<<<<<< HEAD
 +	if (!n) {
 +		s390_adjust_jiffies();
 +		seq_printf(m, "vendor_id       : IBM/S390\n"
 +			   "# processors    : %i\n"
 +			   "bogomips per cpu: %lu.%02lu\n",
 +			   num_online_cpus(), loops_per_jiffy/(500000/HZ),
 +			   (loops_per_jiffy/(5000/HZ))%100);
 +		seq_puts(m, "features\t: ");
 +		for (i = 0; i < ARRAY_SIZE(hwcap_str); i++)
 +			if (hwcap_str[i] && (elf_hwcap & (1UL << i)))
 +				seq_printf(m, "%s ", hwcap_str[i]);
 +		for (i = 0; i < ARRAY_SIZE(int_hwcap_str); i++)
 +			if (int_hwcap_str[i] && (int_hwcap & (1UL << i)))
 +				seq_printf(m, "%s ", int_hwcap_str[i]);
 +		seq_puts(m, "\n");
 +		show_cacheinfo(m);
 +	}
 +	get_online_cpus();
 +	if (cpu_online(n)) {
 +		struct cpuid *id = &per_cpu(cpu_id, n);
 +		seq_printf(m, "processor %li: "
++=======
+ 	seq_printf(m, "vendor_id       : IBM/S390\n"
+ 		   "# processors    : %i\n"
+ 		   "bogomips per cpu: %lu.%02lu\n",
+ 		   num_online_cpus(), loops_per_jiffy/(500000/HZ),
+ 		   (loops_per_jiffy/(5000/HZ))%100);
+ 	seq_printf(m, "max thread id   : %d\n", smp_cpu_mtid);
+ 	seq_puts(m, "features\t: ");
+ 	for (i = 0; i < ARRAY_SIZE(hwcap_str); i++)
+ 		if (hwcap_str[i] && (elf_hwcap & (1UL << i)))
+ 			seq_printf(m, "%s ", hwcap_str[i]);
+ 	for (i = 0; i < ARRAY_SIZE(int_hwcap_str); i++)
+ 		if (int_hwcap_str[i] && (int_hwcap & (1UL << i)))
+ 			seq_printf(m, "%s ", int_hwcap_str[i]);
+ 	seq_puts(m, "\n");
+ 	show_cacheinfo(m);
+ 	for_each_online_cpu(cpu) {
+ 		struct cpuid *id = &per_cpu(cpu_info.cpu_id, cpu);
+ 
+ 		seq_printf(m, "processor %d: "
++>>>>>>> 10f4954ae67b (s390/cpuinfo: show maximum thread id)
  			   "version = %02X,  "
  			   "identification = %06X,  "
  			   "machine = %04X\n",
* Unmerged path arch/s390/kernel/processor.c
