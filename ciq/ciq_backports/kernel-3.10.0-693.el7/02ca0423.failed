ip6_tunnel: Account for tunnel header in tunnel MTU

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jakub Sitnicki <jkbs@redhat.com>
commit 02ca0423fd65a0a9c4d70da0dbb8f4b8503f08c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/02ca0423.failed

With ip6gre we have a tunnel header which also makes the tunnel MTU
smaller. We need to reserve room for it. Previously we were using up
space reserved for the Tunnel Encapsulation Limit option
header (RFC 2473).

Also, after commit b05229f44228 ("gre6: Cleanup GREv6 transmit path,
call common GRE functions") our contract with the caller has
changed. Now we check if the packet length exceeds the tunnel MTU after
the tunnel header has been pushed, unlike before.

This is reflected in the check where we look at the packet length minus
the size of the tunnel header, which is already accounted for in tunnel
MTU.

Fixes: b05229f44228 ("gre6: Cleanup GREv6 transmit path, call common GRE functions")
	Signed-off-by: Jakub Sitnicki <jkbs@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 02ca0423fd65a0a9c4d70da0dbb8f4b8503f08c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_tunnel.c
diff --cc net/ipv6/ip6_tunnel.c
index 100f1422a6ea,753d6d0860fb..000000000000
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@@ -1004,16 -1108,16 +1004,24 @@@ static int ip6_tnl_xmit2(struct sk_buf
  				     t->parms.name);
  		goto tx_err_dst_release;
  	}
++<<<<<<< HEAD
 +	mtu = dst_mtu(dst) - sizeof (*ipv6h);
++=======
+ 	mtu = dst_mtu(dst) - psh_hlen - t->tun_hlen;
++>>>>>>> 02ca0423fd65 (ip6_tunnel: Account for tunnel header in tunnel MTU)
  	if (encap_limit >= 0) {
  		max_headroom += 8;
  		mtu -= 8;
  	}
  	if (mtu < IPV6_MIN_MTU)
  		mtu = IPV6_MIN_MTU;
 -	if (skb_dst(skb) && !t->parms.collect_md)
 +	if (skb_dst(skb))
  		skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL, skb, mtu);
++<<<<<<< HEAD
 +	if (skb->len > mtu) {
++=======
+ 	if (skb->len - t->tun_hlen > mtu && !skb_is_gso(skb)) {
++>>>>>>> 02ca0423fd65 (ip6_tunnel: Account for tunnel header in tunnel MTU)
  		*pmtu = mtu;
  		err = -EMSGSIZE;
  		goto tx_err_dst_release;
* Unmerged path net/ipv6/ip6_tunnel.c
