target: allow ALUA setup for some passthrough backends

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [target] allow ALUA setup for some passthrough backends (Mike Christie) [1429008 1407016]
Rebuild_FUZZ: 92.00%
commit-author Mike Christie <mchristi@redhat.com>
commit 530c6891b1220cba780b6c18f4691d85a3435080
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/530c6891.failed

This patch allows passthrough backends to use the core/base LIO
ALUA setup and state checks, but still handle the execution of
commands.

This will allow the target_core_user module to execute STPG and RTPG
in userspace, and not have to duplicate the ALUA state checks, path
information (needed so we can check if command is executable on
specific paths) and setup (rtslib sets/updates the configfs ALUA
interface like it does for iblock or file).

For STPG, the target_core_user userspace daemon, tcmu-runner will
still execute the STPG, and to update the core/base LIO state it
will use the existing configfs interface. For RTPG, tcmu-runner
will loop over configfs and/or cache the state.

	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 530c6891b1220cba780b6c18f4691d85a3435080)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/target_core_alua.c
#	drivers/target/target_core_tpg.c
#	include/target/target_core_backend.h
diff --cc drivers/target/target_core_alua.c
index 4f8d4d459aa4,a41bbb8087cf..000000000000
--- a/drivers/target/target_core_alua.c
+++ b/drivers/target/target_core_alua.c
@@@ -704,11 -691,9 +704,11 @@@ target_alua_state_check(struct se_cmd *
  
  	if (dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE)
  		return 0;
- 	if (dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH)
+ 	if (dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_ALUA)
  		return 0;
  
 +	if (!port)
 +		return 0;
  	/*
  	 * First, check for a struct se_port specific secondary ALUA target port
  	 * access state: OFFLINE
@@@ -2021,12 -1973,9 +2021,18 @@@ ssize_t core_alua_store_tg_pt_gp_info
  	unsigned char buf[TG_PT_GROUP_NAME_BUF];
  	int move = 0;
  
++<<<<<<< HEAD
 +	tpg = port->sep_tpg;
 +	lun = port->sep_lun;
 +
 +	tg_pt_gp_mem = port->sep_alua_tg_pt_gp_mem;
 +	if (!tg_pt_gp_mem)
 +		return 0;
++=======
+ 	if (dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_ALUA ||
+ 	    (dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE))
+ 		return -ENODEV;
++>>>>>>> 530c6891b122 (target: allow ALUA setup for some passthrough backends)
  
  	if (count > TG_PT_GROUP_NAME_BUF) {
  		pr_err("ALUA Target Port Group alias too large!\n");
@@@ -2285,7 -2230,8 +2291,12 @@@ ssize_t core_alua_store_offline_bit
  	unsigned long tmp;
  	int ret;
  
++<<<<<<< HEAD
 +	if (!lun->lun_sep)
++=======
+ 	if (dev->transport->transport_flags & TRANSPORT_FLAG_PASSTHROUGH_ALUA ||
+ 	    (dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE))
++>>>>>>> 530c6891b122 (target: allow ALUA setup for some passthrough backends)
  		return -ENODEV;
  
  	ret = kstrtoul(page, 0, &tmp);
diff --cc drivers/target/target_core_tpg.c
index 0696de9553d3,6fb191914f45..000000000000
--- a/drivers/target/target_core_tpg.c
+++ b/drivers/target/target_core_tpg.c
@@@ -823,20 -596,40 +823,44 @@@ int core_tpg_add_lun
  	ret = percpu_ref_init(&lun->lun_ref, core_tpg_lun_ref_release, 0,
  			      GFP_KERNEL);
  	if (ret < 0)
 -		goto out;
 +		return ret;
  
 -	ret = core_alloc_rtpi(lun, dev);
 -	if (ret)
 -		goto out_kill_ref;
 +	ret = core_dev_export(dev, tpg, lun);
 +	if (ret < 0) {
 +		percpu_ref_exit(&lun->lun_ref);
 +		return ret;
 +	}
  
++<<<<<<< HEAD
 +	spin_lock(&tpg->tpg_lun_lock);
 +	lun->lun_access = lun_access;
 +	lun->lun_status = TRANSPORT_LUN_STATUS_ACTIVE;
 +	spin_unlock(&tpg->tpg_lun_lock);
++=======
+ 	if (!(dev->transport->transport_flags &
+ 	     TRANSPORT_FLAG_PASSTHROUGH_ALUA) &&
+ 	    !(dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE))
+ 		target_attach_tg_pt_gp(lun, dev->t10_alua.default_tg_pt_gp);
+ 
+ 	mutex_lock(&tpg->tpg_lun_mutex);
+ 
+ 	spin_lock(&dev->se_port_lock);
+ 	lun->lun_index = dev->dev_index;
+ 	rcu_assign_pointer(lun->lun_se_dev, dev);
+ 	dev->export_count++;
+ 	list_add_tail(&lun->lun_dev_link, &dev->dev_sep_list);
+ 	spin_unlock(&dev->se_port_lock);
+ 
+ 	if (dev->dev_flags & DF_READ_ONLY)
+ 		lun->lun_access_ro = true;
+ 	else
+ 		lun->lun_access_ro = lun_access_ro;
+ 	if (!(dev->se_hba->hba_flags & HBA_FLAGS_INTERNAL_USE))
+ 		hlist_add_head_rcu(&lun->link, &tpg->tpg_lun_hlist);
+ 	mutex_unlock(&tpg->tpg_lun_mutex);
++>>>>>>> 530c6891b122 (target: allow ALUA setup for some passthrough backends)
  
  	return 0;
 -
 -out_kill_ref:
 -	percpu_ref_exit(&lun->lun_ref);
 -out:
 -	return ret;
  }
  
  void core_tpg_remove_lun(
diff --cc include/target/target_core_backend.h
index 3254006d8d2e,1b0f447ce850..000000000000
--- a/include/target/target_core_backend.h
+++ b/include/target/target_core_backend.h
@@@ -1,20 -1,20 +1,32 @@@
  #ifndef TARGET_CORE_BACKEND_H
  #define TARGET_CORE_BACKEND_H
  
++<<<<<<< HEAD
 +#define TRANSPORT_FLAG_PASSTHROUGH		1
++=======
+ #include <linux/types.h>
+ #include <target/target_core_base.h>
+ 
+ #define TRANSPORT_FLAG_PASSTHROUGH		0x1
+ /*
+  * ALUA commands, state checks and setup operations are handled by the
+  * backend module.
+  */
+ #define TRANSPORT_FLAG_PASSTHROUGH_ALUA		0x2
++>>>>>>> 530c6891b122 (target: allow ALUA setup for some passthrough backends)
 +
 +struct target_backend_cits {
 +	struct config_item_type tb_dev_cit;
 +	struct config_item_type tb_dev_attrib_cit;
 +	struct config_item_type tb_dev_pr_cit;
 +	struct config_item_type tb_dev_wwn_cit;
 +	struct config_item_type tb_dev_alua_tg_pt_gps_cit;
 +	struct config_item_type tb_dev_stat_cit;
 +};
  
 -struct request_queue;
 -struct scatterlist;
 +struct se_subsystem_api {
 +	struct list_head sub_api_list;
  
 -struct target_backend_ops {
  	char name[16];
  	char inquiry_prod[16];
  	char inquiry_rev[4];
* Unmerged path drivers/target/target_core_alua.c
diff --git a/drivers/target/target_core_pscsi.c b/drivers/target/target_core_pscsi.c
index a18411484b3c..59a8a2963c0e 100644
--- a/drivers/target/target_core_pscsi.c
+++ b/drivers/target/target_core_pscsi.c
@@ -1192,7 +1192,8 @@ static struct configfs_attribute *pscsi_backend_dev_attrs[] = {
 static struct se_subsystem_api pscsi_template = {
 	.name			= "pscsi",
 	.owner			= THIS_MODULE,
-	.transport_flags	= TRANSPORT_FLAG_PASSTHROUGH,
+	.transport_flags	= TRANSPORT_FLAG_PASSTHROUGH |
+				  TRANSPORT_FLAG_PASSTHROUGH_ALUA,
 	.attach_hba		= pscsi_attach_hba,
 	.detach_hba		= pscsi_detach_hba,
 	.pmode_enable_hba	= pscsi_pmode_enable_hba,
* Unmerged path drivers/target/target_core_tpg.c
* Unmerged path include/target/target_core_backend.h
