scsi: qla2xxx: Fix Target mode handling with Multiqueue changes.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Fix Target mode handling with Multiqueue changes (Chad Dupuis) [1414957]
Rebuild_FUZZ: 94.21%
commit-author Quinn Tran <quinn.tran@cavium.com>
commit 093df73771bac8a37d607c0e705d157a8cef4c5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/093df737.failed

- Fix race condition between dpc_thread accessing Multiqueue resources
  and qla2x00_remove_one thread trying to free resource.
- Fix out of order free for Multiqueue resources. Also, Multiqueue
  interrupts needs a workqueue. Interrupt needed to stop before
  the wq can be destroyed.

	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Quinn Tran <quinn.tran@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 093df73771bac8a37d607c0e705d157a8cef4c5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_init.c
#	drivers/scsi/qla2xxx/qla_isr.c
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3968a8462b15,f7df01b76714..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -2707,8 -2732,10 +2707,15 @@@ struct isp_operations 
  #define QLA_MSIX_FW_MODE(m)	(((m) & (BIT_7|BIT_8|BIT_9)) >> 7)
  #define QLA_MSIX_FW_MODE_1(m)	(QLA_MSIX_FW_MODE(m) == 1)
  
++<<<<<<< HEAD
 +#define QLA_MSIX_DEFAULT	0x00
 +#define QLA_MSIX_RSP_Q		0x01
++=======
+ #define QLA_MSIX_DEFAULT		0x00
+ #define QLA_MSIX_RSP_Q			0x01
+ #define QLA_ATIO_VECTOR		0x02
+ #define QLA_MSIX_QPAIR_MULTIQ_RSP_Q	0x03
++>>>>>>> 093df73771ba (scsi: qla2xxx: Fix Target mode handling with Multiqueue changes.)
  
  #define QLA_MIDX_DEFAULT	0
  #define QLA_MIDX_RSP_Q		1
diff --cc drivers/scsi/qla2xxx/qla_init.c
index c64ee86b3feb,632d5f30386a..000000000000
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@@ -6588,3 -6721,162 +6588,165 @@@ qla24xx_update_all_fcp_prio(scsi_qla_ho
  
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
+ struct qla_qpair *qla2xxx_create_qpair(struct scsi_qla_host *vha, int qos, int vp_idx)
+ {
+ 	int rsp_id = 0;
+ 	int  req_id = 0;
+ 	int i;
+ 	struct qla_hw_data *ha = vha->hw;
+ 	uint16_t qpair_id = 0;
+ 	struct qla_qpair *qpair = NULL;
+ 	struct qla_msix_entry *msix;
+ 
+ 	if (!(ha->fw_attributes & BIT_6) || !ha->flags.msix_enabled) {
+ 		ql_log(ql_log_warn, vha, 0x00181,
+ 		    "FW/Driver is not multi-queue capable.\n");
+ 		return NULL;
+ 	}
+ 
+ 	if (ql2xmqsupport) {
+ 		qpair = kzalloc(sizeof(struct qla_qpair), GFP_KERNEL);
+ 		if (qpair == NULL) {
+ 			ql_log(ql_log_warn, vha, 0x0182,
+ 			    "Failed to allocate memory for queue pair.\n");
+ 			return NULL;
+ 		}
+ 		memset(qpair, 0, sizeof(struct qla_qpair));
+ 
+ 		qpair->hw = vha->hw;
+ 
+ 		/* Assign available que pair id */
+ 		mutex_lock(&ha->mq_lock);
+ 		qpair_id = find_first_zero_bit(ha->qpair_qid_map, ha->max_qpairs);
+ 		if (qpair_id >= ha->max_qpairs) {
+ 			mutex_unlock(&ha->mq_lock);
+ 			ql_log(ql_log_warn, vha, 0x0183,
+ 			    "No resources to create additional q pair.\n");
+ 			goto fail_qid_map;
+ 		}
+ 		set_bit(qpair_id, ha->qpair_qid_map);
+ 		ha->queue_pair_map[qpair_id] = qpair;
+ 		qpair->id = qpair_id;
+ 		qpair->vp_idx = vp_idx;
+ 
+ 		for (i = 0; i < ha->msix_count; i++) {
+ 			msix = &ha->msix_entries[i];
+ 			if (msix->in_use)
+ 				continue;
+ 			qpair->msix = msix;
+ 			ql_log(ql_dbg_multiq, vha, 0xc00f,
+ 			    "Vector %x selected for qpair\n", msix->vector);
+ 			break;
+ 		}
+ 		if (!qpair->msix) {
+ 			ql_log(ql_log_warn, vha, 0x0184,
+ 			    "Out of MSI-X vectors!.\n");
+ 			goto fail_msix;
+ 		}
+ 
+ 		qpair->msix->in_use = 1;
+ 		list_add_tail(&qpair->qp_list_elem, &vha->qp_list);
+ 
+ 		mutex_unlock(&ha->mq_lock);
+ 
+ 		/* Create response queue first */
+ 		rsp_id = qla25xx_create_rsp_que(ha, 0, 0, 0, qpair);
+ 		if (!rsp_id) {
+ 			ql_log(ql_log_warn, vha, 0x0185,
+ 			    "Failed to create response queue.\n");
+ 			goto fail_rsp;
+ 		}
+ 
+ 		qpair->rsp = ha->rsp_q_map[rsp_id];
+ 
+ 		/* Create request queue */
+ 		req_id = qla25xx_create_req_que(ha, 0, vp_idx, 0, rsp_id, qos);
+ 		if (!req_id) {
+ 			ql_log(ql_log_warn, vha, 0x0186,
+ 			    "Failed to create request queue.\n");
+ 			goto fail_req;
+ 		}
+ 
+ 		qpair->req = ha->req_q_map[req_id];
+ 		qpair->rsp->req = qpair->req;
+ 
+ 		if (IS_T10_PI_CAPABLE(ha) && ql2xenabledif) {
+ 			if (ha->fw_attributes & BIT_4)
+ 				qpair->difdix_supported = 1;
+ 		}
+ 
+ 		qpair->srb_mempool = mempool_create_slab_pool(SRB_MIN_REQ, srb_cachep);
+ 		if (!qpair->srb_mempool) {
+ 			ql_log(ql_log_warn, vha, 0x0191,
+ 			    "Failed to create srb mempool for qpair %d\n",
+ 			    qpair->id);
+ 			goto fail_mempool;
+ 		}
+ 
+ 		/* Mark as online */
+ 		qpair->online = 1;
+ 
+ 		if (!vha->flags.qpairs_available)
+ 			vha->flags.qpairs_available = 1;
+ 
+ 		ql_dbg(ql_dbg_multiq, vha, 0xc00d,
+ 		    "Request/Response queue pair created, id %d\n",
+ 		    qpair->id);
+ 		ql_dbg(ql_dbg_init, vha, 0x0187,
+ 		    "Request/Response queue pair created, id %d\n",
+ 		    qpair->id);
+ 	}
+ 	return qpair;
+ 
+ fail_mempool:
+ fail_req:
+ 	qla25xx_delete_rsp_que(vha, qpair->rsp);
+ fail_rsp:
+ 	mutex_lock(&ha->mq_lock);
+ 	qpair->msix->in_use = 0;
+ 	list_del(&qpair->qp_list_elem);
+ 	if (list_empty(&vha->qp_list))
+ 		vha->flags.qpairs_available = 0;
+ fail_msix:
+ 	ha->queue_pair_map[qpair_id] = NULL;
+ 	clear_bit(qpair_id, ha->qpair_qid_map);
+ 	mutex_unlock(&ha->mq_lock);
+ fail_qid_map:
+ 	kfree(qpair);
+ 	return NULL;
+ }
+ 
+ int qla2xxx_delete_qpair(struct scsi_qla_host *vha, struct qla_qpair *qpair)
+ {
+ 	int ret;
+ 	struct qla_hw_data *ha = qpair->hw;
+ 
+ 	qpair->delete_in_progress = 1;
+ 	while (atomic_read(&qpair->ref_count))
+ 		msleep(500);
+ 
+ 	ret = qla25xx_delete_req_que(vha, qpair->req);
+ 	if (ret != QLA_SUCCESS)
+ 		goto fail;
+ 	ret = qla25xx_delete_rsp_que(vha, qpair->rsp);
+ 	if (ret != QLA_SUCCESS)
+ 		goto fail;
+ 
+ 	mutex_lock(&ha->mq_lock);
+ 	ha->queue_pair_map[qpair->id] = NULL;
+ 	clear_bit(qpair->id, ha->qpair_qid_map);
+ 	list_del(&qpair->qp_list_elem);
+ 	if (list_empty(&vha->qp_list))
+ 		vha->flags.qpairs_available = 0;
+ 	mempool_destroy(qpair->srb_mempool);
+ 	kfree(qpair);
+ 	mutex_unlock(&ha->mq_lock);
+ 
+ 	return QLA_SUCCESS;
+ fail:
+ 	return ret;
+ }
++>>>>>>> 093df73771ba (scsi: qla2xxx: Fix Target mode handling with Multiqueue changes.)
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index 816b38009f31,af840bf587d5..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -2954,50 -3002,23 +2954,57 @@@ struct qla_init_msix_entry 
  	irq_handler_t handler;
  };
  
 -static struct qla_init_msix_entry msix_entries[] = {
 +static struct qla_init_msix_entry msix_entries[3] = {
  	{ "qla2xxx (default)", qla24xx_msix_default },
  	{ "qla2xxx (rsp_q)", qla24xx_msix_rsp_q },
++<<<<<<< HEAD
 +	{ "qla2xxx (multiq)", qla25xx_msix_rsp_q },
++=======
+ 	{ "qla2xxx (atio_q)", qla83xx_msix_atio_q },
+ 	{ "qla2xxx (qpair_multiq)", qla2xxx_msix_rsp_q },
++>>>>>>> 093df73771ba (scsi: qla2xxx: Fix Target mode handling with Multiqueue changes.)
  };
  
 -static struct qla_init_msix_entry qla82xx_msix_entries[] = {
 +static struct qla_init_msix_entry qla82xx_msix_entries[2] = {
  	{ "qla2xxx (default)", qla82xx_msix_default },
  	{ "qla2xxx (rsp_q)", qla82xx_msix_rsp_q },
  };
  
++<<<<<<< HEAD
 +static struct qla_init_msix_entry qla83xx_msix_entries[3] = {
 +	{ "qla2xxx (default)", qla24xx_msix_default },
 +	{ "qla2xxx (rsp_q)", qla24xx_msix_rsp_q },
 +	{ "qla2xxx (atio_q)", qla83xx_msix_atio_q },
 +};
 +
 +static void
 +qla24xx_disable_msix(struct qla_hw_data *ha)
 +{
 +	int i;
 +	struct qla_msix_entry *qentry;
 +	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
 +
 +	for (i = 0; i < ha->msix_count; i++) {
 +		qentry = &ha->msix_entries[i];
 +		if (qentry->have_irq)
 +			free_irq(qentry->vector, qentry->rsp);
 +	}
 +	pci_disable_msix(ha->pdev);
 +	kfree(ha->msix_entries);
 +	ha->msix_entries = NULL;
 +	ha->flags.msix_enabled = 0;
 +	ql_dbg(ql_dbg_init, vha, 0x0042,
 +	    "Disabled the MSI.\n");
 +}
 +
++=======
++>>>>>>> 093df73771ba (scsi: qla2xxx: Fix Target mode handling with Multiqueue changes.)
  static int
  qla24xx_enable_msix(struct qla_hw_data *ha, struct rsp_que *rsp)
  {
  #define MIN_MSIX_COUNT	2
- #define ATIO_VECTOR	2
  	int i, ret;
 +	struct msix_entry *entries;
  	struct qla_msix_entry *qentry;
  	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
  
@@@ -3047,8 -3074,12 +3054,8 @@@
  	}
  
  	/* Enable MSI-X vectors for the base queue */
- 	for (i = 0; i < 2; i++) {
+ 	for (i = 0; i < (QLA_MSIX_RSP_Q + 1); i++) {
  		qentry = &ha->msix_entries[i];
 -		qentry->handle = rsp;
 -		rsp->msix = qentry;
 -		scnprintf(qentry->name, sizeof(qentry->name),
 -		    msix_entries[i].name);
  		if (IS_P3P_TYPE(ha))
  			ret = request_irq(qentry->vector,
  				qla82xx_msix_entries[i].handler,
@@@ -3060,8 -3091,19 +3067,24 @@@
  		if (ret)
  			goto msix_register_fail;
  		qentry->have_irq = 1;
++<<<<<<< HEAD
 +		qentry->rsp = rsp;
 +		rsp->msix = qentry;
++=======
+ 		qentry->in_use = 1;
+ 
+ 		/* Register for CPU affinity notification. */
+ 		irq_set_affinity_notifier(qentry->vector, &qentry->irq_notify);
+ 
+ 		/* Schedule work (ie. trigger a notification) to read cpu
+ 		 * mask for this specific irq.
+ 		 * kref_get is required because
+ 		* irq_affinity_notify() will do
+ 		* kref_put().
+ 		*/
+ 		kref_get(&qentry->irq_notify.kref);
+ 		schedule_work(&qentry->irq_notify.work);
++>>>>>>> 093df73771ba (scsi: qla2xxx: Fix Target mode handling with Multiqueue changes.)
  	}
  
  	/*
@@@ -3069,13 -3111,16 +3092,22 @@@
  	 * queue.
  	 */
  	if (QLA_TGT_MODE_ENABLED() && IS_ATIO_MSIX_CAPABLE(ha)) {
++<<<<<<< HEAD
 +		qentry = &ha->msix_entries[ATIO_VECTOR];
++=======
+ 		qentry = &ha->msix_entries[QLA_ATIO_VECTOR];
+ 		rsp->msix = qentry;
+ 		qentry->handle = rsp;
+ 		scnprintf(qentry->name, sizeof(qentry->name),
+ 		    msix_entries[QLA_ATIO_VECTOR].name);
+ 		qentry->in_use = 1;
++>>>>>>> 093df73771ba (scsi: qla2xxx: Fix Target mode handling with Multiqueue changes.)
  		ret = request_irq(qentry->vector,
- 			qla83xx_msix_entries[ATIO_VECTOR].handler,
- 			0, qla83xx_msix_entries[ATIO_VECTOR].name, rsp);
+ 			msix_entries[QLA_ATIO_VECTOR].handler,
+ 			0, msix_entries[QLA_ATIO_VECTOR].name, rsp);
  		qentry->have_irq = 1;
 +		qentry->rsp = rsp;
 +		rsp->msix = qentry;
  	}
  
  msix_register_fail:
diff --cc drivers/scsi/qla2xxx/qla_os.c
index f1f989d1fce1,8521cfe302e9..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -407,18 -439,41 +407,35 @@@ static void qla2x00_free_queues(struct 
  	struct req_que *req;
  	struct rsp_que *rsp;
  	int cnt;
+ 	unsigned long flags;
  
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
  	for (cnt = 0; cnt < ha->max_req_queues; cnt++) {
 -		if (!test_bit(cnt, ha->req_qid_map))
 -			continue;
 -
  		req = ha->req_q_map[cnt];
+ 		clear_bit(cnt, ha->req_qid_map);
+ 		ha->req_q_map[cnt] = NULL;
+ 
+ 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
  		qla2x00_free_req_que(ha, req);
+ 		spin_lock_irqsave(&ha->hardware_lock, flags);
  	}
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 
  	kfree(ha->req_q_map);
  	ha->req_q_map = NULL;
  
+ 
+ 	spin_lock_irqsave(&ha->hardware_lock, flags);
  	for (cnt = 0; cnt < ha->max_rsp_queues; cnt++) {
 -		if (!test_bit(cnt, ha->rsp_qid_map))
 -			continue;
 -
  		rsp = ha->rsp_q_map[cnt];
+ 		clear_bit(cnt, ha->req_qid_map);
+ 		ha->rsp_q_map[cnt] =  NULL;
+ 		spin_unlock_irqrestore(&ha->hardware_lock, flags);
  		qla2x00_free_rsp_que(ha, rsp);
+ 		spin_lock_irqsave(&ha->hardware_lock, flags);
  	}
+ 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+ 
  	kfree(ha->rsp_q_map);
  	ha->rsp_q_map = NULL;
  }
@@@ -1754,26 -1906,28 +1771,48 @@@ qla83xx_iospace_config(struct qla_hw_da
  		/* Read MSIX vector size of the board */
  		pci_read_config_word(ha->pdev,
  		    QLA_83XX_PCI_MSIX_CONTROL, &msix);
++<<<<<<< HEAD
 +		ha->msix_count = msix;
 +		/* Max queues are bounded by available msix vectors */
 +		/* queue 0 uses two msix vectors */
 +		if (ql2xmultique_tag) {
 +			cpus = num_online_cpus();
 +			ha->max_rsp_queues = (ha->msix_count - 1 > cpus) ?
 +				(cpus + 1) : (ha->msix_count - 1);
 +			ha->max_req_queues = 2;
 +		} else if (ql2xmaxqueues > 1) {
 +			ha->max_req_queues = ql2xmaxqueues > QLA_MQ_SIZE ?
 +						QLA_MQ_SIZE : ql2xmaxqueues;
 +			ql_dbg_pci(ql_dbg_multiq, ha->pdev, 0xc00c,
 +			    "QoS mode set, max no of request queues:%d.\n",
 +			    ha->max_req_queues);
 +			ql_dbg_pci(ql_dbg_init, ha->pdev, 0x011b,
 +			    "QoS mode set, max no of request queues:%d.\n",
 +			    ha->max_req_queues);
++=======
+ 		ha->msix_count = msix + 1;
+ 		/*
+ 		 * By default, driver uses at least two msix vectors
+ 		 * (default & rspq)
+ 		 */
+ 		if (ql2xmqsupport) {
+ 			/* MB interrupt uses 1 vector */
+ 			ha->max_req_queues = ha->msix_count - 1;
+ 			ha->max_rsp_queues = ha->max_req_queues;
+ 
+ 			/* ATIOQ needs 1 vector. That's 1 less QPair */
+ 			if (QLA_TGT_MODE_ENABLED())
+ 				ha->max_req_queues--;
+ 
+ 			/* Queue pairs is the max value minus
+ 			 * the base queue pair */
+ 			ha->max_qpairs = ha->max_req_queues - 1;
+ 			ql_dbg_pci(ql_dbg_init, ha->pdev, 0x0190,
+ 			    "Max no of queues pairs: %d.\n", ha->max_qpairs);
++>>>>>>> 093df73771ba (scsi: qla2xxx: Fix Target mode handling with Multiqueue changes.)
  		}
  		ql_log_pci(ql_log_info, ha->pdev, 0x011c,
 -		    "MSI-X vector count: %d.\n", ha->msix_count);
 +		    "MSI-X vector count: %d.\n", msix);
  	} else
  		ql_log_pci(ql_log_info, ha->pdev, 0x011e,
  		    "BAR 1 not enabled.\n");
@@@ -2830,11 -3013,12 +2871,20 @@@ que_init
  	    host->can_queue, base_vha->req,
  	    base_vha->mgmt_svr_loop_id, host->sg_tablesize);
  
++<<<<<<< HEAD
 +	if (ha->mqenable) {
 +		if (qla25xx_setup_mode(base_vha)) {
 +			ql_log(ql_log_warn, base_vha, 0x00ec,
 +			    "Failed to create queues, falling back to single queue mode.\n");
 +			goto que_init;
++=======
+ 	if (ha->mqenable && qla_ini_mode_enabled(base_vha)) {
+ 		ha->wq = alloc_workqueue("qla2xxx_wq", WQ_MEM_RECLAIM, 1);
+ 		/* Create start of day qpairs for Block MQ */
+ 		if (shost_use_blk_mq(host)) {
+ 			for (i = 0; i < ha->max_qpairs; i++)
+ 				qla2xxx_create_qpair(base_vha, 5, 0);
++>>>>>>> 093df73771ba (scsi: qla2xxx: Fix Target mode handling with Multiqueue changes.)
  		}
  	}
  
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
* Unmerged path drivers/scsi/qla2xxx/qla_init.c
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
