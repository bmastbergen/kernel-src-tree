bridge: memorize and export selected IGMP/MLD querier port

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Linus Lüssing <linus.luessing@web.de>
commit 2cd4143192e8c60f66cb32c3a30c76d0470a372d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2cd41431.failed

Adding bridge support to the batman-adv multicast optimization requires
batman-adv knowing about the existence of bridged-in IGMP/MLD queriers
to be able to reliably serve any multicast listener behind this same
bridge.

	Signed-off-by: Linus Lüssing <linus.luessing@web.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2cd4143192e8c60f66cb32c3a30c76d0470a372d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/if_bridge.h
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
diff --cc include/linux/if_bridge.h
index d66e75e57470,fd22789d7b2e..000000000000
--- a/include/linux/if_bridge.h
+++ b/include/linux/if_bridge.h
@@@ -55,9 -36,8 +55,14 @@@ extern void brioctl_set(int (*ioctl_hoo
  
  typedef int br_should_route_hook_t(struct sk_buff *skb);
  extern br_should_route_hook_t __rcu *br_should_route_hook;
 +#if 0
 +/* RHEL: not yet fully supported */
  int br_multicast_list_adjacent(struct net_device *dev,
  			       struct list_head *br_ip_list);
++<<<<<<< HEAD
 +#endif
++=======
+ bool br_multicast_has_querier_adjacent(struct net_device *dev, int proto);
+ 
++>>>>>>> 2cd4143192e8 (bridge: memorize and export selected IGMP/MLD querier port)
  #endif
diff --cc net/bridge/br_multicast.c
index 251bf0711bce,cd3cf394c477..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -1078,6 -1080,71 +1078,74 @@@ static int br_ip6_multicast_mld2_report
  }
  #endif
  
++<<<<<<< HEAD
++=======
+ static bool br_ip4_multicast_select_querier(struct net_bridge *br,
+ 					    struct net_bridge_port *port,
+ 					    __be32 saddr)
+ {
+ 	if (!timer_pending(&br->ip4_own_query.timer) &&
+ 	    !timer_pending(&br->ip4_other_query.timer))
+ 		goto update;
+ 
+ 	if (!br->ip4_querier.addr.u.ip4)
+ 		goto update;
+ 
+ 	if (ntohl(saddr) <= ntohl(br->ip4_querier.addr.u.ip4))
+ 		goto update;
+ 
+ 	return false;
+ 
+ update:
+ 	br->ip4_querier.addr.u.ip4 = saddr;
+ 
+ 	/* update protected by general multicast_lock by caller */
+ 	rcu_assign_pointer(br->ip4_querier.port, port);
+ 
+ 	return true;
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static bool br_ip6_multicast_select_querier(struct net_bridge *br,
+ 					    struct net_bridge_port *port,
+ 					    struct in6_addr *saddr)
+ {
+ 	if (!timer_pending(&br->ip6_own_query.timer) &&
+ 	    !timer_pending(&br->ip6_other_query.timer))
+ 		goto update;
+ 
+ 	if (ipv6_addr_cmp(saddr, &br->ip6_querier.addr.u.ip6) <= 0)
+ 		goto update;
+ 
+ 	return false;
+ 
+ update:
+ 	br->ip6_querier.addr.u.ip6 = *saddr;
+ 
+ 	/* update protected by general multicast_lock by caller */
+ 	rcu_assign_pointer(br->ip6_querier.port, port);
+ 
+ 	return true;
+ }
+ #endif
+ 
+ static bool br_multicast_select_querier(struct net_bridge *br,
+ 					struct net_bridge_port *port,
+ 					struct br_ip *saddr)
+ {
+ 	switch (saddr->proto) {
+ 	case htons(ETH_P_IP):
+ 		return br_ip4_multicast_select_querier(br, port, saddr->u.ip4);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case htons(ETH_P_IPV6):
+ 		return br_ip6_multicast_select_querier(br, port, &saddr->u.ip6);
+ #endif
+ 	}
+ 
+ 	return false;
+ }
+ 
++>>>>>>> 2cd4143192e8 (bridge: memorize and export selected IGMP/MLD querier port)
  static void
  br_multicast_update_query_timer(struct net_bridge *br,
  				struct bridge_mcast_other_query *query,
@@@ -1140,15 -1207,13 +1208,19 @@@ timer
  static void br_multicast_query_received(struct net_bridge *br,
  					struct net_bridge_port *port,
  					struct bridge_mcast_other_query *query,
 -					struct br_ip *saddr,
 +					int saddr,
 +					bool is_general_query,
  					unsigned long max_delay)
  {
++<<<<<<< HEAD
 +	if (saddr && is_general_query)
 +		br_multicast_update_query_timer(br, query, max_delay);
 +	else if (timer_pending(&query->timer))
++=======
+ 	if (!br_multicast_select_querier(br, port, saddr))
++>>>>>>> 2cd4143192e8 (bridge: memorize and export selected IGMP/MLD querier port)
  		return;
  
 -	br_multicast_update_query_timer(br, query, max_delay);
  	br_multicast_mark_router(br, port);
  }
  
@@@ -2145,4 -2212,50 +2221,54 @@@ unlock
  	return count;
  }
  EXPORT_SYMBOL_GPL(br_multicast_list_adjacent);
++<<<<<<< HEAD
 +#endif
++=======
+ 
+ /**
+  * br_multicast_has_querier_adjacent - Checks for a querier behind a bridge port
+  * @dev: The bridge port adjacent to which to check for a querier
+  * @proto: The protocol family to check for: IGMP -> ETH_P_IP, MLD -> ETH_P_IPV6
+  *
+  * Checks whether the given interface has a bridge on top and if so returns
+  * true if a selected querier is behind one of the other ports of this
+  * bridge. Otherwise returns false.
+  */
+ bool br_multicast_has_querier_adjacent(struct net_device *dev, int proto)
+ {
+ 	struct net_bridge *br;
+ 	struct net_bridge_port *port;
+ 	bool ret = false;
+ 
+ 	rcu_read_lock();
+ 	if (!br_port_exists(dev))
+ 		goto unlock;
+ 
+ 	port = br_port_get_rcu(dev);
+ 	if (!port || !port->br)
+ 		goto unlock;
+ 
+ 	br = port->br;
+ 
+ 	switch (proto) {
+ 	case ETH_P_IP:
+ 		if (!timer_pending(&br->ip4_other_query.timer) ||
+ 		    rcu_dereference(br->ip4_querier.port) == port)
+ 			goto unlock;
+ 		break;
+ 	case ETH_P_IPV6:
+ 		if (!timer_pending(&br->ip6_other_query.timer) ||
+ 		    rcu_dereference(br->ip6_querier.port) == port)
+ 			goto unlock;
+ 		break;
+ 	default:
+ 		goto unlock;
+ 	}
+ 
+ 	ret = true;
+ unlock:
+ 	rcu_read_unlock();
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(br_multicast_has_querier_adjacent);
++>>>>>>> 2cd4143192e8 (bridge: memorize and export selected IGMP/MLD querier port)
diff --cc net/bridge/br_private.h
index dadd34070a9c,8346e9504cdb..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -69,6 -66,12 +69,15 @@@ struct bridge_mcast_other_query 
  	struct timer_list		timer;
  	unsigned long			delay_time;
  };
++<<<<<<< HEAD
++=======
+ 
+ /* selected querier */
+ struct bridge_mcast_querier {
+ 	struct br_ip addr;
+ 	struct net_bridge_port __rcu	*port;
+ };
++>>>>>>> 2cd4143192e8 (bridge: memorize and export selected IGMP/MLD querier port)
  #endif
  
  struct net_port_vlans {
* Unmerged path include/linux/if_bridge.h
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_private.h
