nvme : Add sysfs entry for NVMe CMBs when appropriate

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Stephen Bates <sbates@raithlin.com>
commit 202021c1a63c6ed69b3260e0fe10530c51f1e53e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/202021c1.failed

Add a sysfs attribute that contains salient information about the NVMe
Controller Memory Buffer when one is present. For now, just display the
information about the CMB available from the control registers. We attach
the CMB attribute file to the existing nvme_ctrl sysfs group so it can
handle the sysfs teardown.

	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: Jay Freyensee <james_p_freyensee@linux.intel.com>
	Signed-off-by: Stephen Bates <sbates@raithlin.com>
	Acked-by Jon Derrick: <jonathan.derrick@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 202021c1a63c6ed69b3260e0fe10530c51f1e53e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/pci.c
diff --cc drivers/nvme/host/pci.c
index 3dc63da6bd14,a7c6e9d74943..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -101,11 -99,7 +101,15 @@@ struct nvme_dev 
  	dma_addr_t cmb_dma_addr;
  	u64 cmb_size;
  	u32 cmbsz;
++<<<<<<< HEAD
 +	unsigned long flags;
 +
 +#define NVME_CTRL_RESETTING    0
 +#define NVME_CTRL_REMOVING     1
 +
++=======
+ 	u32 cmbloc;
++>>>>>>> 202021c1a63c (nvme : Add sysfs entry for NVMe CMBs when appropriate)
  	struct nvme_ctrl ctrl;
  	struct completion ioq_wait;
  };
@@@ -1665,9 -1613,37 +1678,41 @@@ static int nvme_pci_enable(struct nvme_
  	dev->q_depth = min_t(int, NVME_CAP_MQES(cap) + 1, NVME_Q_DEPTH);
  	dev->db_stride = 1 << NVME_CAP_STRIDE(cap);
  	dev->dbs = dev->bar + 4096;
++<<<<<<< HEAD
 +	if (readl(dev->bar + NVME_REG_VS) >= NVME_VS(1, 2))
++=======
+ 
+ 	/*
+ 	 * Temporary fix for the Apple controller found in the MacBook8,1 and
+ 	 * some MacBook7,1 to avoid controller resets and data loss.
+ 	 */
+ 	if (pdev->vendor == PCI_VENDOR_ID_APPLE && pdev->device == 0x2001) {
+ 		dev->q_depth = 2;
+ 		dev_warn(dev->dev, "detected Apple NVMe controller, set "
+ 			"queue depth=%u to work around controller resets\n",
+ 			dev->q_depth);
+ 	}
+ 
+ 	/*
+ 	 * CMBs can currently only exist on >=1.2 PCIe devices. We only
+ 	 * populate sysfs if a CMB is implemented. Note that we add the
+ 	 * CMB attribute to the nvme_ctrl kobj which removes the need to remove
+ 	 * it on exit. Since nvme_dev_attrs_group has no name we can pass
+ 	 * NULL as final argument to sysfs_add_file_to_group.
+ 	 */
+ 
+ 	if (readl(dev->bar + NVME_REG_VS) >= NVME_VS(1, 2)) {
++>>>>>>> 202021c1a63c (nvme : Add sysfs entry for NVMe CMBs when appropriate)
  		dev->cmb = nvme_map_cmb(dev);
  
+ 		if (dev->cmbsz) {
+ 			if (sysfs_add_file_to_group(&dev->ctrl.device->kobj,
+ 						    &dev_attr_cmb.attr, NULL))
+ 				dev_warn(dev->dev,
+ 					 "failed to add sysfs attribute for CMB\n");
+ 		}
+ 	}
+ 
  	pci_enable_pcie_error_reporting(pdev);
  	pci_save_state(pdev);
  	return 0;
* Unmerged path drivers/nvme/host/pci.c
