HID: wacom: Introduce new 'touch_input' device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Introduce new touch_input device (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 91.76%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 2a6cdbdd4cc0da0b0190b9a43648dff7b44adc0a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2a6cdbdd.failed

Instead of having a single 'input_dev' device that will take either pen
or touch data depending on the type of the device, create seperate devices
devices for each. By splitting things like this, we can support devices
(e.g. the I2C "AES" sensors in some newer tablet PCs) that send both pen
and touch reports from a single endpoint.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 2a6cdbdd4cc0da0b0190b9a43648dff7b44adc0a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,4c0ffca97bef..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -290,248 -180,144 +290,328 @@@ static void wacom_retrieve_report_data(
   * interfaces haven't supported pressure or distance, this is enough
   * information to override invalid values in the wacom_features table.
   *
 - * Intuos5 touch interface and 3rd gen Bamboo Touch do not contain useful
 - * data. We deal with them after returning from this function.
 + * 3rd gen Bamboo Touch no longer define a Digitizer-Finger Pysical
 + * Collection. Instead they define a Logical Collection with a single
 + * Logical Maximum for both X and Y.
 + *
 + * Intuos5 touch interface does not contain useful data. We deal with
 + * this after returning from this function.
   */
++<<<<<<< HEAD
 +static int wacom_parse_hid(struct usb_interface *intf,
 +			   struct hid_descriptor *hid_desc,
++=======
+ static void wacom_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_features *features = &wacom->wacom_wac.features;
+ 	bool finger = WACOM_FINGER_FIELD(field);
+ 	bool pen = WACOM_PEN_FIELD(field);
+ 
+ 	/*
+ 	* Requiring Stylus Usage will ignore boot mouse
+ 	* X/Y values and some cases of invalid Digitizer X/Y
+ 	* values commonly reported.
+ 	*/
+ 	if (pen)
+ 		features->device_type |= WACOM_DEVICETYPE_PEN;
+ 	else if (finger)
+ 		features->device_type |= WACOM_DEVICETYPE_TOUCH;
+ 	else
+ 		return;
+ 
+ 	/*
+ 	 * Bamboo models do not support HID_DG_CONTACTMAX.
+ 	 * And, Bamboo Pen only descriptor contains touch.
+ 	 */
+ 	if (features->type != BAMBOO_PT) {
+ 		/* ISDv4 touch devices at least supports one touch point */
+ 		if (finger && !features->touch_max)
+ 			features->touch_max = 1;
+ 	}
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		features->x_max = field->logical_maximum;
+ 		if (finger) {
+ 			features->x_phy = field->physical_maximum;
+ 			if (features->type != BAMBOO_PT) {
+ 				features->unit = field->unit;
+ 				features->unitExpo = field->unit_exponent;
+ 			}
+ 		}
+ 		break;
+ 	case HID_GD_Y:
+ 		features->y_max = field->logical_maximum;
+ 		if (finger) {
+ 			features->y_phy = field->physical_maximum;
+ 			if (features->type != BAMBOO_PT) {
+ 				features->unit = field->unit;
+ 				features->unitExpo = field->unit_exponent;
+ 			}
+ 		}
+ 		break;
+ 	case HID_DG_TIPPRESSURE:
+ 		if (pen)
+ 			features->pressure_max = field->logical_maximum;
+ 		break;
+ 	}
+ 
+ 	if (features->type == HID_GENERIC)
+ 		wacom_wac_usage_mapping(hdev, field, usage);
+ }
+ 
+ static void wacom_post_parse_hid(struct hid_device *hdev,
+ 				 struct wacom_features *features)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	if (features->type == HID_GENERIC) {
+ 		/* Any last-minute generic device setup */
+ 		if (features->touch_max > 1) {
+ 			input_mt_init_slots(wacom_wac->touch_input, wacom_wac->features.touch_max,
+ 				    INPUT_MT_DIRECT);
+ 		}
+ 	}
+ }
+ 
+ static void wacom_parse_hid(struct hid_device *hdev,
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  			   struct wacom_features *features)
  {
 -	struct hid_report_enum *rep_enum;
 -	struct hid_report *hreport;
 -	int i, j;
 -
 -	/* check features first */
 -	rep_enum = &hdev->report_enum[HID_FEATURE_REPORT];
 -	list_for_each_entry(hreport, &rep_enum->report_list, list) {
 -		for (i = 0; i < hreport->maxfield; i++) {
 -			/* Ignore if report count is out of bounds. */
 -			if (hreport->field[i]->report_count < 1)
 -				continue;
 -
 -			for (j = 0; j < hreport->field[i]->maxusage; j++) {
 -				wacom_feature_mapping(hdev, hreport->field[i],
 -						hreport->field[i]->usage + j);
 +	struct usb_device *dev = interface_to_usbdev(intf);
 +	char limit = 0;
 +	/* result has to be defined as int for some devices */
 +	int result = 0;
 +	int i = 0, usage = WCM_UNDEFINED, finger = 0, pen = 0;
 +	unsigned char *report;
 +
 +	report = kzalloc(hid_desc->wDescriptorLength, GFP_KERNEL);
 +	if (!report)
 +		return -ENOMEM;
 +
 +	/* retrive report descriptors */
 +	do {
 +		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 +			USB_REQ_GET_DESCRIPTOR,
 +			USB_RECIP_INTERFACE | USB_DIR_IN,
 +			HID_DEVICET_REPORT << 8,
 +			intf->altsetting[0].desc.bInterfaceNumber, /* interface */
 +			report,
 +			hid_desc->wDescriptorLength,
 +			5000); /* 5 secs */
 +	} while (result < 0 && limit++ < WAC_MSG_RETRIES);
 +
 +	/* No need to parse the Descriptor. It isn't an error though */
 +	if (result < 0)
 +		goto out;
 +
 +	for (i = 0; i < hid_desc->wDescriptorLength; i++) {
 +
 +		switch (report[i]) {
 +		case HID_USAGE_PAGE:
 +			switch (report[i + 1]) {
 +			case HID_USAGE_PAGE_DIGITIZER:
 +				usage = WCM_DIGITIZER;
 +				i++;
 +				break;
 +
 +			case HID_USAGE_PAGE_DESKTOP:
 +				usage = WCM_DESKTOP;
 +				i++;
 +				break;
  			}
 -		}
 -	}
 +			break;
  
 -	/* now check the input usages */
 -	rep_enum = &hdev->report_enum[HID_INPUT_REPORT];
 -	list_for_each_entry(hreport, &rep_enum->report_list, list) {
 +		case HID_USAGE:
 +			switch (report[i + 1]) {
 +			case HID_USAGE_X:
 +				if (usage == WCM_DESKTOP) {
 +					if (finger) {
 +						features->device_type = BTN_TOOL_FINGER;
 +
 +						switch (features->type) {
 +						case TABLETPC2FG:
 +							features->pktlen = WACOM_PKGLEN_TPC2FG;
 +							break;
 +
 +						case MTSCREEN:
 +						case WACOM_24HDT:
 +							features->pktlen = WACOM_PKGLEN_MTOUCH;
 +							break;
 +
 +						case MTTPC:
 +							features->pktlen = WACOM_PKGLEN_MTTPC;
 +							break;
 +
 +						case BAMBOO_PT:
 +							features->pktlen = WACOM_PKGLEN_BBTOUCH;
 +							break;
 +
 +						default:
 +							features->pktlen = WACOM_PKGLEN_GRAPHIRE;
 +							break;
 +						}
 +
 +						switch (features->type) {
 +						case BAMBOO_PT:
 +							features->x_phy =
 +								get_unaligned_le16(&report[i + 5]);
 +							features->x_max =
 +								get_unaligned_le16(&report[i + 8]);
 +							i += 15;
 +							break;
 +
 +						case WACOM_24HDT:
 +							features->x_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->x_phy =
 +								get_unaligned_le16(&report[i + 8]);
 +							features->unit = report[i - 1];
 +							features->unitExpo = report[i - 3];
 +							i += 12;
 +							break;
 +
 +						case WACOM_27QHDT:
 +							if (!features->x_max) {
 +								features->x_max =
 +									get_unaligned_le16(&report[i - 4]);
 +								features->x_phy =
 +									get_unaligned_le16(&report[i - 7]);
 +								features->unit = report[i - 13];
 +								features->unitExpo = report[i - 11];
 +							}
 +							i += 9;
 +							break;
 +
 +						default:
 +							features->x_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->x_phy =
 +								get_unaligned_le16(&report[i + 6]);
 +							features->unit = report[i + 9];
 +							features->unitExpo = report[i + 11];
 +							i += 12;
 +							break;
 +						}
 +					} else if (pen) {
 +						/* penabled only accepts exact bytes of data */
 +						if (features->type >= TABLETPC)
 +							features->pktlen = WACOM_PKGLEN_GRAPHIRE;
 +						features->device_type = BTN_TOOL_PEN;
 +						features->x_max =
 +							get_unaligned_le16(&report[i + 3]);
 +						i += 4;
 +					}
 +				}
 +				break;
  
 -		if (!hreport->maxfield)
 -			continue;
 +			case HID_USAGE_Y:
 +				if (usage == WCM_DESKTOP) {
 +					if (finger) {
 +						switch (features->type) {
 +						case TABLETPC2FG:
 +						case MTSCREEN:
 +						case MTTPC:
 +							features->y_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->y_phy =
 +								get_unaligned_le16(&report[i + 6]);
 +							i += 7;
 +							break;
 +
 +						case WACOM_24HDT:
 +							features->y_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->y_phy =
 +								get_unaligned_le16(&report[i - 2]);
 +							i += 7;
 +							break;
 +
 +						case BAMBOO_PT:
 +							features->y_phy =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->y_max =
 +								get_unaligned_le16(&report[i + 6]);
 +							i += 12;
 +							break;
 +
 +						case WACOM_27QHDT:
 +							if (!features->y_max) {
 +								features->y_max =
 +									get_unaligned_le16(&report[i - 2]);
 +								features->y_phy =
 +									get_unaligned_le16(&report[i - 5]);
 +							}
 +							i += 2;
 +							break;
 +
 +						default:
 +							features->y_max =
 +								features->x_max;
 +							features->y_phy =
 +								get_unaligned_le16(&report[i + 3]);
 +							i += 4;
 +							break;
 +						}
 +					} else if (pen) {
 +						features->y_max =
 +							get_unaligned_le16(&report[i + 3]);
 +						i += 4;
 +					}
 +				}
 +				break;
  
 -		for (i = 0; i < hreport->maxfield; i++)
 -			for (j = 0; j < hreport->field[i]->maxusage; j++)
 -				wacom_usage_mapping(hdev, hreport->field[i],
 -						hreport->field[i]->usage + j);
 -	}
 +			case HID_USAGE_FINGER:
 +				finger = 1;
 +				i++;
 +				break;
  
 -	wacom_post_parse_hid(hdev, features);
 -}
 +			/*
 +			 * Requiring Stylus Usage will ignore boot mouse
 +			 * X/Y values and some cases of invalid Digitizer X/Y
 +			 * values commonly reported.
 +			 */
 +			case HID_USAGE_STYLUS:
 +				pen = 1;
 +				i++;
 +				break;
  
 -static int wacom_hid_set_device_mode(struct hid_device *hdev)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct hid_data *hid_data = &wacom->wacom_wac.hid_data;
 -	struct hid_report *r;
 -	struct hid_report_enum *re;
 +			case HID_USAGE_CONTACTMAX:
 +				/* leave touch_max as is if predefined */
 +				if (!features->touch_max)
 +					wacom_retrieve_report_data(intf, features);
 +				i++;
 +				break;
 +			}
 +			break;
  
 -	if (hid_data->inputmode < 0)
 -		return 0;
 +		case HID_COLLECTION_END:
 +			/* reset UsagePage and Finger */
 +			finger = usage = 0;
 +			break;
  
 -	re = &(hdev->report_enum[HID_FEATURE_REPORT]);
 -	r = re->report_id_hash[hid_data->inputmode];
 -	if (r) {
 -		r->field[0]->value[hid_data->inputmode_index] = 2;
 -		hid_hw_request(hdev, r, HID_REQ_SET_REPORT);
 +		case HID_COLLECTION:
 +			i++;
 +			switch (report[i]) {
 +			case HID_COLLECTION_LOGICAL:
 +				i += wacom_parse_logical_collection(&report[i],
 +								    features);
 +				break;
 +			}
 +			break;
 +		}
  	}
 -	return 0;
 +
 + out:
 +	result = 0;
 +	kfree(report);
 +	return result;
  }
  
 -static int wacom_set_device_mode(struct hid_device *hdev, int report_id,
 -		int length, int mode)
 +static int wacom_set_device_mode(struct usb_interface *intf, int report_id, int length, int mode)
  {
  	unsigned char *rep_data;
  	int error = -ENOMEM, limit = 0;
@@@ -1127,42 -1088,197 +1207,188 @@@ static void wacom_destroy_battery(struc
  	}
  }
  
 -static ssize_t wacom_show_speed(struct device *dev,
 -				struct device_attribute
 -				*attr, char *buf)
 -{
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -
 -	return snprintf(buf, PAGE_SIZE, "%i\n", wacom->wacom_wac.bt_high_speed);
 -}
 -
 -static ssize_t wacom_store_speed(struct device *dev,
 -				struct device_attribute *attr,
 -				const char *buf, size_t count)
 -{
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	u8 new_speed;
 -
 -	if (kstrtou8(buf, 0, &new_speed))
 -		return -EINVAL;
 -
 -	if (new_speed != 0 && new_speed != 1)
 -		return -EINVAL;
 -
 -	wacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);
 -
 -	return count;
 -}
 -
 -static DEVICE_ATTR(speed, DEV_ATTR_RW_PERM,
 -		wacom_show_speed, wacom_store_speed);
 -
 -static struct input_dev *wacom_allocate_input(struct wacom *wacom)
 +static int wacom_register_input(struct wacom *wacom)
  {
  	struct input_dev *input_dev;
 -	struct hid_device *hdev = wacom->hdev;
 +	struct usb_interface *intf = wacom->intf;
 +	struct usb_device *dev = interface_to_usbdev(intf);
  	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 +	int error;
  
  	input_dev = input_allocate_device();
 -	if (!input_dev)
 -		return NULL;
 +	if (!input_dev) {
 +		error = -ENOMEM;
 +		goto fail1;
 +	}
  
++<<<<<<< HEAD
 +	input_dev->name = wacom_wac->name;
 +	input_dev->dev.parent = &intf->dev;
++=======
+ 	input_dev->name = wacom_wac->pen_name;
+ 	input_dev->phys = hdev->phys;
+ 	input_dev->dev.parent = &hdev->dev;
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	input_dev->open = wacom_open;
  	input_dev->close = wacom_close;
 -	input_dev->uniq = hdev->uniq;
 -	input_dev->id.bustype = hdev->bus;
 -	input_dev->id.vendor  = hdev->vendor;
 -	input_dev->id.product = wacom_wac->pid ? wacom_wac->pid : hdev->product;
 -	input_dev->id.version = hdev->version;
 +	usb_to_input_id(dev, &input_dev->id);
  	input_set_drvdata(input_dev, wacom);
  
++<<<<<<< HEAD
 +	wacom_wac->input = input_dev;
 +	error = wacom_setup_input_capabilities(input_dev, wacom_wac);
 +	if (error)
 +		goto fail1;
 +
 +	error = input_register_device(input_dev);
 +	if (error)
 +		goto fail2;
 +
 +	return 0;
 +
 +fail2:
 +	input_free_device(input_dev);
 +	wacom_wac->input = NULL;
 +fail1:
++=======
+ 	return input_dev;
+ }
+ 
+ static void wacom_free_inputs(struct wacom *wacom)
+ {
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	if (wacom_wac->pen_input)
+ 		input_free_device(wacom_wac->pen_input);
+ 	if (wacom_wac->touch_input)
+ 		input_free_device(wacom_wac->touch_input);
+ 	if (wacom_wac->pad_input)
+ 		input_free_device(wacom_wac->pad_input);
+ 	wacom_wac->pen_input = NULL;
+ 	wacom_wac->touch_input = NULL;
+ 	wacom_wac->pad_input = NULL;
+ }
+ 
+ static int wacom_allocate_inputs(struct wacom *wacom)
+ {
+ 	struct input_dev *pen_input_dev, *touch_input_dev, *pad_input_dev;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	pen_input_dev = wacom_allocate_input(wacom);
+ 	touch_input_dev = wacom_allocate_input(wacom);
+ 	pad_input_dev = wacom_allocate_input(wacom);
+ 	if (!pen_input_dev || !touch_input_dev || !pad_input_dev) {
+ 		wacom_free_inputs(wacom);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	wacom_wac->pen_input = pen_input_dev;
+ 	wacom_wac->touch_input = touch_input_dev;
+ 	wacom_wac->touch_input->name = wacom_wac->touch_name;
+ 	wacom_wac->pad_input = pad_input_dev;
+ 	wacom_wac->pad_input->name = wacom_wac->pad_name;
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_clean_inputs(struct wacom *wacom)
+ {
+ 	if (wacom->wacom_wac.pen_input) {
+ 		if (wacom->wacom_wac.pen_registered)
+ 			input_unregister_device(wacom->wacom_wac.pen_input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.pen_input);
+ 	}
+ 	if (wacom->wacom_wac.touch_input) {
+ 		if (wacom->wacom_wac.touch_registered)
+ 			input_unregister_device(wacom->wacom_wac.touch_input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.touch_input);
+ 	}
+ 	if (wacom->wacom_wac.pad_input) {
+ 		if (wacom->wacom_wac.pad_registered)
+ 			input_unregister_device(wacom->wacom_wac.pad_input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.pad_input);
+ 	}
+ 	wacom->wacom_wac.pen_input = NULL;
+ 	wacom->wacom_wac.touch_input = NULL;
+ 	wacom->wacom_wac.pad_input = NULL;
+ 	wacom_destroy_leds(wacom);
+ }
+ 
+ static int wacom_register_inputs(struct wacom *wacom)
+ {
+ 	struct input_dev *pen_input_dev, *touch_input_dev, *pad_input_dev;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 	int error = 0;
+ 
+ 	pen_input_dev = wacom_wac->pen_input;
+ 	touch_input_dev = wacom_wac->touch_input;
+ 	pad_input_dev = wacom_wac->pad_input;
+ 
+ 	if (!pen_input_dev || !touch_input_dev || !pad_input_dev)
+ 		return -EINVAL;
+ 
+ 	error = wacom_setup_pen_input_capabilities(pen_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no pen in use on this interface */
+ 		input_free_device(pen_input_dev);
+ 		wacom_wac->pen_input = NULL;
+ 		pen_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(pen_input_dev);
+ 		if (error)
+ 			goto fail_register_pen_input;
+ 		wacom_wac->pen_registered = true;
+ 	}
+ 
+ 	error = wacom_setup_touch_input_capabilities(touch_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no touch in use on this interface */
+ 		input_free_device(touch_input_dev);
+ 		wacom_wac->touch_input = NULL;
+ 		touch_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(touch_input_dev);
+ 		if (error)
+ 			goto fail_register_touch_input;
+ 		wacom_wac->touch_registered = true;
+ 	}
+ 
+ 	error = wacom_setup_pad_input_capabilities(pad_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no pad in use on this interface */
+ 		input_free_device(pad_input_dev);
+ 		wacom_wac->pad_input = NULL;
+ 		pad_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(pad_input_dev);
+ 		if (error)
+ 			goto fail_register_pad_input;
+ 		wacom_wac->pad_registered = true;
+ 
+ 		error = wacom_initialize_leds(wacom);
+ 		if (error)
+ 			goto fail_leds;
+ 	}
+ 
+ 	return 0;
+ 
+ fail_leds:
+ 	input_unregister_device(pad_input_dev);
+ 	pad_input_dev = NULL;
+ 	wacom_wac->pad_registered = false;
+ fail_register_pad_input:
+ 	input_unregister_device(touch_input_dev);
+ 	wacom_wac->touch_input = NULL;
+ 	wacom_wac->touch_registered = false;
+ fail_register_touch_input:
+ 	input_unregister_device(pen_input_dev);
+ 	wacom_wac->pen_input = NULL;
+ 	wacom_wac->pen_registered = false;
+ fail_register_pen_input:
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	return error;
  }
  
@@@ -1220,30 -1334,48 +1446,60 @@@ static void wacom_wireless_work(struct 
  
  		/* Stylus interface */
  		wacom_wac1->features =
++<<<<<<< HEAD
 +			*((struct wacom_features *)id->driver_info);
 +		wacom_wac1->features.device_type = BTN_TOOL_PEN;
 +		snprintf(wacom_wac1->name, WACOM_NAME_MAX, "%s (WL) Pen",
++=======
+ 			*((struct wacom_features *)id->driver_data);
+ 		wacom_wac1->features.device_type |= WACOM_DEVICETYPE_PEN;
+ 		if (wacom_wac1->features.type != INTUOSHT &&
+ 		    wacom_wac1->features.type != BAMBOO_PT)
+ 			wacom_wac1->features.device_type |= WACOM_DEVICETYPE_PAD;
+ 		snprintf(wacom_wac1->pen_name, WACOM_NAME_MAX, "%s (WL) Pen",
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  			 wacom_wac1->features.name);
 -		snprintf(wacom_wac1->pad_name, WACOM_NAME_MAX, "%s (WL) Pad",
 -			 wacom_wac1->features.name);
 -		wacom_wac1->shared->touch_max = wacom_wac1->features.touch_max;
 -		wacom_wac1->shared->type = wacom_wac1->features.type;
 -		wacom_wac1->pid = wacom_wac->pid;
 -		error = wacom_allocate_inputs(wacom1) ||
 -			wacom_register_inputs(wacom1);
 +		error = wacom_register_input(wacom1);
  		if (error)
  			goto fail;
  
  		/* Touch interface */
 -		if (wacom_wac1->features.touch_max ||
 -		    wacom_wac1->features.type == INTUOSHT) {
 +		if (wacom_wac1->features.touch_max) {
  			wacom_wac2->features =
 -				*((struct wacom_features *)id->driver_data);
 +				*((struct wacom_features *)id->driver_info);
  			wacom_wac2->features.pktlen = WACOM_PKGLEN_BBTOUCH3;
 +			wacom_wac2->features.device_type = BTN_TOOL_FINGER;
  			wacom_wac2->features.x_max = wacom_wac2->features.y_max = 4096;
++<<<<<<< HEAD
 +			if (wacom_wac2->features.touch_max)
 +				snprintf(wacom_wac2->name, WACOM_NAME_MAX,
 +					 "%s (WL) Finger",wacom_wac2->features.name);
 +			else
 +				snprintf(wacom_wac2->name, WACOM_NAME_MAX,
 +					 "%s (WL) Pad",wacom_wac2->features.name);
 +			error = wacom_register_input(wacom2);
 +			if (error)
 +				goto fail;
++=======
+ 			snprintf(wacom_wac2->touch_name, WACOM_NAME_MAX,
+ 				 "%s (WL) Finger",wacom_wac2->features.name);
+ 			snprintf(wacom_wac2->pad_name, WACOM_NAME_MAX,
+ 				 "%s (WL) Pad",wacom_wac2->features.name);
+ 			if (wacom_wac1->features.touch_max)
+ 				wacom_wac2->features.device_type |= WACOM_DEVICETYPE_TOUCH;
+ 			if (wacom_wac1->features.type == INTUOSHT ||
+ 			    wacom_wac1->features.type == BAMBOO_PT)
+ 				wacom_wac2->features.device_type |= WACOM_DEVICETYPE_PAD;
+ 			wacom_wac2->pid = wacom_wac->pid;
+ 			error = wacom_allocate_inputs(wacom2) ||
+ 				wacom_register_inputs(wacom2);
+ 			if (error)
+ 				goto fail;
+ 
+ 			if (wacom_wac1->features.type == INTUOSHT &&
+ 			    wacom_wac1->features.touch_max)
+ 				wacom_wac->shared->touch_input = wacom_wac2->touch_input;
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  		}
  
  		error = wacom_initialize_battery(wacom);
@@@ -1293,10 -1438,71 +1549,75 @@@ static void wacom_calculate_res(struct 
  						    features->unitExpo);
  }
  
 -static size_t wacom_compute_pktlen(struct hid_device *hdev)
 +static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *id)
  {
++<<<<<<< HEAD
++=======
+ 	struct hid_report_enum *report_enum;
+ 	struct hid_report *report;
+ 	size_t size = 0;
+ 
+ 	report_enum = hdev->report_enum + HID_INPUT_REPORT;
+ 
+ 	list_for_each_entry(report, &report_enum->report_list, list) {
+ 		size_t report_size = hid_report_len(report);
+ 		if (report_size > size)
+ 			size = report_size;
+ 	}
+ 
+ 	return size;
+ }
+ 
+ static void wacom_update_name(struct wacom *wacom)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	char name[WACOM_NAME_MAX];
+ 
+ 	/* Generic devices name unspecified */
+ 	if ((features->type == HID_GENERIC) && !strcmp("Wacom HID", features->name)) {
+ 		if (strstr(wacom->hdev->name, "Wacom") ||
+ 		    strstr(wacom->hdev->name, "wacom") ||
+ 		    strstr(wacom->hdev->name, "WACOM")) {
+ 			/* name is in HID descriptor, use it */
+ 			strlcpy(name, wacom->hdev->name, sizeof(name));
+ 
+ 			/* strip out excess whitespaces */
+ 			while (1) {
+ 				char *gap = strstr(name, "  ");
+ 				if (gap == NULL)
+ 					break;
+ 				/* shift everything including the terminator */
+ 				memmove(gap, gap+1, strlen(gap));
+ 			}
+ 			/* get rid of trailing whitespace */
+ 			if (name[strlen(name)-1] == ' ')
+ 				name[strlen(name)-1] = '\0';
+ 		} else {
+ 			/* no meaningful name retrieved. use product ID */
+ 			snprintf(name, sizeof(name),
+ 				 "%s %X", features->name, wacom->hdev->product);
+ 		}
+ 	} else {
+ 		strlcpy(name, features->name, sizeof(name));
+ 	}
+ 
+ 	/* Append the device type to the name */
+ 	snprintf(wacom_wac->pen_name, sizeof(wacom_wac->pen_name),
+ 		"%s Pen", name);
+ 	snprintf(wacom_wac->touch_name, sizeof(wacom_wac->touch_name),
+ 		"%s Finger", name);
+ 	snprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),
+ 		"%s Pad", name);
+ }
+ 
+ static int wacom_probe(struct hid_device *hdev,
+ 		const struct hid_device_id *id)
+ {
+ 	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	struct usb_device *dev = interface_to_usbdev(intf);
 +	struct usb_endpoint_descriptor *endpoint;
  	struct wacom *wacom;
  	struct wacom_wac *wacom_wac;
  	struct wacom_features *features;
@@@ -1412,15 -1632,14 +1733,21 @@@
  	}
  
  	/* Note that if query fails it is not a hard failure */
 -	wacom_query_tablet_data(hdev, features);
 +	wacom_query_tablet_data(intf, features);
  
 -	if (features->quirks & WACOM_QUIRK_MONITOR)
 -		error = hid_hw_open(hdev);
 +	usb_set_intfdata(intf, wacom);
  
++<<<<<<< HEAD
 +	if (features->quirks & WACOM_QUIRK_MONITOR) {
 +		if (usb_submit_urb(wacom->irq, GFP_KERNEL)) {
 +			error = -EIO;
 +			goto fail5;
 +		}
++=======
+ 	if (wacom_wac->features.type == INTUOSHT && 
+ 	    wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH) {
+ 			wacom_wac->shared->touch_input = wacom_wac->touch_input;
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	}
  
  	return 0;
diff --cc drivers/hid/wacom_wac.c
index bc916ccd4c20,d811e878a105..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -182,10 -214,9 +182,16 @@@ static int wacom_ptu_irq(struct wacom_w
  
  static int wacom_dtu_irq(struct wacom_wac *wacom)
  {
++<<<<<<< HEAD
 +	struct wacom_features *features = &wacom->features;
 +	char *data = wacom->data;
 +	struct input_dev *input = wacom->input;
 +	int prox = data[1] & 0x20, pressure;
++=======
+ 	unsigned char *data = wacom->data;
+ 	struct input_dev *input = wacom->pen_input;
+ 	int prox = data[1] & 0x20;
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  
  	dev_dbg(input->dev.parent,
  		"%s: received report #%d", __func__, data[0]);
@@@ -214,11 -242,64 +220,71 @@@
  	return 1;
  }
  
++<<<<<<< HEAD
++=======
+ static int wacom_dtus_irq(struct wacom_wac *wacom)
+ {
+ 	char *data = wacom->data;
+ 	struct input_dev *input = wacom->pen_input;
+ 	unsigned short prox, pressure = 0;
+ 
+ 	if (data[0] != WACOM_REPORT_DTUS && data[0] != WACOM_REPORT_DTUSPAD) {
+ 		dev_dbg(input->dev.parent,
+ 			"%s: received unknown report #%d", __func__, data[0]);
+ 		return 0;
+ 	} else if (data[0] == WACOM_REPORT_DTUSPAD) {
+ 		input = wacom->pad_input;
+ 		input_report_key(input, BTN_0, (data[1] & 0x01));
+ 		input_report_key(input, BTN_1, (data[1] & 0x02));
+ 		input_report_key(input, BTN_2, (data[1] & 0x04));
+ 		input_report_key(input, BTN_3, (data[1] & 0x08));
+ 		input_report_abs(input, ABS_MISC,
+ 				 data[1] & 0x0f ? PAD_DEVICE_ID : 0);
+ 		return 1;
+ 	} else {
+ 		prox = data[1] & 0x80;
+ 		if (prox) {
+ 			switch ((data[1] >> 3) & 3) {
+ 			case 1: /* Rubber */
+ 				wacom->tool[0] = BTN_TOOL_RUBBER;
+ 				wacom->id[0] = ERASER_DEVICE_ID;
+ 				break;
+ 
+ 			case 2: /* Pen */
+ 				wacom->tool[0] = BTN_TOOL_PEN;
+ 				wacom->id[0] = STYLUS_DEVICE_ID;
+ 				break;
+ 			}
+ 		}
+ 
+ 		input_report_key(input, BTN_STYLUS, data[1] & 0x20);
+ 		input_report_key(input, BTN_STYLUS2, data[1] & 0x40);
+ 		input_report_abs(input, ABS_X, get_unaligned_be16(&data[3]));
+ 		input_report_abs(input, ABS_Y, get_unaligned_be16(&data[5]));
+ 		pressure = ((data[1] & 0x03) << 8) | (data[2] & 0xff);
+ 		input_report_abs(input, ABS_PRESSURE, pressure);
+ 		input_report_key(input, BTN_TOUCH, pressure > 10);
+ 
+ 		if (!prox) /* out-prox */
+ 			wacom->id[0] = 0;
+ 		input_report_key(input, wacom->tool[0], prox);
+ 		input_report_abs(input, ABS_MISC, wacom->id[0]);
+ 		return 1;
+ 	}
+ }
+ 
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  static int wacom_graphire_irq(struct wacom_wac *wacom)
  {
  	struct wacom_features *features = &wacom->features;
  	unsigned char *data = wacom->data;
++<<<<<<< HEAD
 +	struct input_dev *input = wacom->input;
++=======
+ 	struct input_dev *input = wacom->pen_input;
+ 	struct input_dev *pad_input = wacom->pad_input;
+ 	int battery_capacity, ps_connected;
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	int prox;
  	int rw = 0;
  	int retval = 0;
@@@ -853,12 -1019,79 +919,86 @@@ static int int_dist(int x1, int y1, in
  	return int_sqrt(x*x + y*y);
  }
  
++<<<<<<< HEAD
 +static int wacom_24hdt_irq(struct wacom_wac *wacom)
 +{
 +	struct input_dev *input = wacom->input;
 +	char *data = wacom->data;
++=======
+ static void wacom_intuos_bt_process_data(struct wacom_wac *wacom,
+ 		unsigned char *data)
+ {
+ 	memcpy(wacom->data, data, 10);
+ 	wacom_intuos_irq(wacom);
+ 
+ 	input_sync(wacom->pen_input);
+ 	if (wacom->pad_input)
+ 		input_sync(wacom->pad_input);
+ }
+ 
+ static int wacom_intuos_bt_irq(struct wacom_wac *wacom, size_t len)
+ {
+ 	unsigned char data[WACOM_PKGLEN_MAX];
+ 	int i = 1;
+ 	unsigned power_raw, battery_capacity, bat_charging, ps_connected;
+ 
+ 	memcpy(data, wacom->data, len);
+ 
+ 	switch (data[0]) {
+ 	case 0x04:
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		/* fall through */
+ 	case 0x03:
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		power_raw = data[i];
+ 		bat_charging = (power_raw & 0x08) ? 1 : 0;
+ 		ps_connected = (power_raw & 0x10) ? 1 : 0;
+ 		battery_capacity = batcap_i4[power_raw & 0x07];
+ 		wacom_notify_battery(wacom, battery_capacity, bat_charging,
+ 				     battery_capacity || bat_charging,
+ 				     ps_connected);
+ 		break;
+ 	default:
+ 		dev_dbg(wacom->pen_input->dev.parent,
+ 				"Unknown report: %d,%d size:%zu\n",
+ 				data[0], data[1], len);
+ 		return 0;
+ 	}
+ 	return 0;
+ }
+ 
+ static int wacom_wac_finger_count_touches(struct wacom_wac *wacom)
+ {
+ 	struct input_dev *input = wacom->touch_input;
+ 	unsigned touch_max = wacom->features.touch_max;
+ 	int count = 0;
+ 	int i;
+ 
+ 	if (touch_max == 1)
+ 		return test_bit(BTN_TOUCH, input->key) &&
+ 		       !wacom->shared->stylus_in_proximity;
+ 
+ 	for (i = 0; i < input->mt->num_slots; i++) {
+ 		struct input_mt_slot *ps = &input->mt->slots[i];
+ 		int id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);
+ 		if (id >= 0)
+ 			count++;
+ 	}
+ 
+ 	return count;
+ }
+ 
+ static int wacom_24hdt_irq(struct wacom_wac *wacom)
+ {
+ 	struct input_dev *input = wacom->touch_input;
+ 	unsigned char *data = wacom->data;
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	int i;
 -	int current_num_contacts = data[61];
 +	int current_num_contacts = 0;
  	int contacts_to_send = 0;
  	int num_contacts_left = 4; /* maximum contacts per packet */
  	int byte_per_packet = WACOM_BYTES_PER_24HDT_PACKET;
@@@ -924,8 -1156,8 +1064,13 @@@
  
  static int wacom_mt_touch(struct wacom_wac *wacom)
  {
++<<<<<<< HEAD
 +	struct input_dev *input = wacom->input;
 +	char *data = wacom->data;
++=======
+ 	struct input_dev *input = wacom->touch_input;
+ 	unsigned char *data = wacom->data;
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	int i;
  	int current_num_contacts = data[2];
  	int contacts_to_send = 0;
@@@ -974,9 -1207,8 +1119,9 @@@
  
  static int wacom_tpc_mt_touch(struct wacom_wac *wacom)
  {
- 	struct input_dev *input = wacom->input;
+ 	struct input_dev *input = wacom->touch_input;
  	unsigned char *data = wacom->data;
 +	int contact_with_no_pen_down_count = 0;
  	int i;
  
  	for (i = 0; i < 2; i++) {
@@@ -1004,9 -1235,9 +1149,15 @@@
  
  static int wacom_tpc_single_touch(struct wacom_wac *wacom, size_t len)
  {
++<<<<<<< HEAD
 +	char *data = wacom->data;
 +	struct input_dev *input = wacom->input;
 +	bool prox;
++=======
+ 	unsigned char *data = wacom->data;
+ 	struct input_dev *input = wacom->touch_input;
+ 	bool prox = !wacom->shared->stylus_in_proximity;
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	int x = 0, y = 0;
  
  	if (wacom->features.touch_max > 1 || len > WACOM_PKGLEN_TPC2FG)
@@@ -1040,10 -1271,8 +1191,15 @@@
  
  static int wacom_tpc_pen(struct wacom_wac *wacom)
  {
++<<<<<<< HEAD
 +	struct wacom_features *features = &wacom->features;
 +	char *data = wacom->data;
 +	struct input_dev *input = wacom->input;
 +	int pressure;
++=======
+ 	unsigned char *data = wacom->data;
+ 	struct input_dev *input = wacom->pen_input;
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	bool prox = data[1] & 0x20;
  
  	if (!wacom->shared->stylus_in_proximity) /* first in prox */
@@@ -1073,10 -1299,14 +1229,14 @@@
  
  static int wacom_tpc_irq(struct wacom_wac *wacom, size_t len)
  {
 -	unsigned char *data = wacom->data;
 +	char *data = wacom->data;
  
- 	dev_dbg(wacom->input->dev.parent,
- 		"%s: received report #%d\n", __func__, data[0]);
+ 	if (wacom->pen_input)
+ 		dev_dbg(wacom->pen_input->dev.parent,
+ 			"%s: received report #%d\n", __func__, data[0]);
+ 	else if (wacom->touch_input)
+ 		dev_dbg(wacom->touch_input->dev.parent,
+ 			"%s: received report #%d\n", __func__, data[0]);
  
  	switch (len) {
  	case WACOM_PKGLEN_TPC1FG:
@@@ -1104,10 -1338,301 +1264,308 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int wacom_bpt_touch(struct wacom_wac *wacom)
 +{
 +	struct wacom_features *features = &wacom->features;
 +	struct input_dev *input = wacom->input;
++=======
+ static void wacom_map_usage(struct input_dev *input, struct hid_usage *usage,
+ 		struct hid_field *field, __u8 type, __u16 code, int fuzz)
+ {
+ 	int fmin = field->logical_minimum;
+ 	int fmax = field->logical_maximum;
+ 
+ 	usage->type = type;
+ 	usage->code = code;
+ 
+ 	set_bit(type, input->evbit);
+ 
+ 	switch (type) {
+ 	case EV_ABS:
+ 		input_set_abs_params(input, code, fmin, fmax, fuzz, 0);
+ 		input_abs_set_res(input, code,
+ 				  hidinput_calc_abs_res(field, code));
+ 		break;
+ 	case EV_KEY:
+ 		input_set_capability(input, EV_KEY, code);
+ 		break;
+ 	case EV_MSC:
+ 		input_set_capability(input, EV_MSC, code);
+ 		break;
+ 	}
+ }
+ 
+ static void wacom_wac_pen_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->pen_input;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_X, 4);
+ 		break;
+ 	case HID_GD_Y:
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 4);
+ 		break;
+ 	case HID_DG_TIPPRESSURE:
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_PRESSURE, 0);
+ 		break;
+ 	case HID_DG_INRANGE:
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_TOOL_PEN, 0);
+ 		break;
+ 	case HID_DG_INVERT:
+ 		wacom_map_usage(input, usage, field, EV_KEY,
+ 				BTN_TOOL_RUBBER, 0);
+ 		break;
+ 	case HID_DG_ERASER:
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);
+ 		break;
+ 	case HID_DG_BARRELSWITCH:
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_STYLUS, 0);
+ 		break;
+ 	case HID_DG_BARRELSWITCH2:
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_STYLUS2, 0);
+ 		break;
+ 	case HID_DG_TOOLSERIALNUMBER:
+ 		wacom_map_usage(input, usage, field, EV_MSC, MSC_SERIAL, 0);
+ 		break;
+ 	}
+ }
+ 
+ static int wacom_wac_pen_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->pen_input;
+ 
+ 	/* checking which Tool / tip switch to send */
+ 	switch (usage->hid) {
+ 	case HID_DG_INRANGE:
+ 		wacom_wac->hid_data.inrange_state = value;
+ 		return 0;
+ 	case HID_DG_INVERT:
+ 		wacom_wac->hid_data.invert_state = value;
+ 		return 0;
+ 	case HID_DG_ERASER:
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_wac->hid_data.tipswitch |= value;
+ 		return 0;
+ 	}
+ 
+ 	/* send pen events only when touch is up or forced out */
+ 	if (!usage->type || wacom_wac->shared->touch_down)
+ 		return 0;
+ 
+ 	input_event(input, usage->type, usage->code, value);
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_wac_pen_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->pen_input;
+ 	bool prox = wacom_wac->hid_data.inrange_state;
+ 
+ 	if (!wacom_wac->shared->stylus_in_proximity) /* first in prox */
+ 		/* Going into proximity select tool */
+ 		wacom_wac->tool[0] = wacom_wac->hid_data.invert_state ?
+ 						BTN_TOOL_RUBBER : BTN_TOOL_PEN;
+ 
+ 	/* keep pen state for touch events */
+ 	wacom_wac->shared->stylus_in_proximity = prox;
+ 
+ 	/* send pen events only when touch is up or forced out */
+ 	if (!wacom_wac->shared->touch_down) {
+ 		input_report_key(input, BTN_TOUCH,
+ 				wacom_wac->hid_data.tipswitch);
+ 		input_report_key(input, wacom_wac->tool[0], prox);
+ 
+ 		wacom_wac->hid_data.tipswitch = false;
+ 
+ 		input_sync(input);
+ 	}
+ }
+ 
+ static void wacom_wac_finger_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	struct input_dev *input = wacom_wac->touch_input;
+ 	unsigned touch_max = wacom_wac->features.touch_max;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		features->last_slot_field = usage->hid;
+ 		if (touch_max == 1)
+ 			wacom_map_usage(input, usage, field, EV_ABS, ABS_X, 4);
+ 		else
+ 			wacom_map_usage(input, usage, field, EV_ABS,
+ 					ABS_MT_POSITION_X, 4);
+ 		break;
+ 	case HID_GD_Y:
+ 		features->last_slot_field = usage->hid;
+ 		if (touch_max == 1)
+ 			wacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 4);
+ 		else
+ 			wacom_map_usage(input, usage, field, EV_ABS,
+ 					ABS_MT_POSITION_Y, 4);
+ 		break;
+ 	case HID_DG_CONTACTID:
+ 		features->last_slot_field = usage->hid;
+ 		break;
+ 	case HID_DG_INRANGE:
+ 		features->last_slot_field = usage->hid;
+ 		break;
+ 	case HID_DG_INVERT:
+ 		features->last_slot_field = usage->hid;
+ 		break;
+ 	case HID_DG_TIPSWITCH:
+ 		features->last_slot_field = usage->hid;
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);
+ 		break;
+ 	}
+ }
+ 
+ static void wacom_wac_finger_slot(struct wacom_wac *wacom_wac,
+ 		struct input_dev *input)
+ {
+ 	struct hid_data *hid_data = &wacom_wac->hid_data;
+ 	bool mt = wacom_wac->features.touch_max > 1;
+ 	bool prox = hid_data->tipswitch &&
+ 		    !wacom_wac->shared->stylus_in_proximity;
+ 
+ 	if (mt) {
+ 		int slot;
+ 
+ 		slot = input_mt_get_slot_by_key(input, hid_data->id);
+ 		input_mt_slot(input, slot);
+ 		input_mt_report_slot_state(input, MT_TOOL_FINGER, prox);
+ 	}
+ 	else {
+ 		input_report_key(input, BTN_TOUCH, prox);
+ 	}
+ 
+ 	if (prox) {
+ 		input_report_abs(input, mt ? ABS_MT_POSITION_X : ABS_X,
+ 				 hid_data->x);
+ 		input_report_abs(input, mt ? ABS_MT_POSITION_Y : ABS_Y,
+ 				 hid_data->y);
+ 	}
+ }
+ 
+ static int wacom_wac_finger_event(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		wacom_wac->hid_data.x = value;
+ 		break;
+ 	case HID_GD_Y:
+ 		wacom_wac->hid_data.y = value;
+ 		break;
+ 	case HID_DG_CONTACTID:
+ 		wacom_wac->hid_data.id = value;
+ 		break;
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_wac->hid_data.tipswitch = value;
+ 		break;
+ 	}
+ 
+ 
+ 	if (usage->usage_index + 1 == field->report_count) {
+ 		if (usage->hid == wacom_wac->features.last_slot_field)
+ 			wacom_wac_finger_slot(wacom_wac, wacom_wac->touch_input);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_wac_finger_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->touch_input;
+ 	unsigned touch_max = wacom_wac->features.touch_max;
+ 
+ 	if (touch_max > 1)
+ 		input_mt_sync_frame(input);
+ 
+ 	input_sync(input);
+ 
+ 	/* keep touch state for pen event */
+ 	wacom_wac->shared->touch_down = wacom_wac_finger_count_touches(wacom_wac);
+ }
+ 
+ void wacom_wac_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	/* currently, only direct devices have proper hid report descriptors */
+ 	__set_bit(INPUT_PROP_DIRECT, wacom_wac->pen_input->propbit);
+ 	__set_bit(INPUT_PROP_DIRECT, wacom_wac->touch_input->propbit);
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_usage_mapping(hdev, field, usage);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_usage_mapping(hdev, field, usage);
+ }
+ 
+ int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 
+ 	if (wacom->wacom_wac.features.type != HID_GENERIC)
+ 		return 0;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_event(hdev, field, usage, value);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_event(hdev, field, usage, value);
+ 
+ 	return 0;
+ }
+ 
+ void wacom_wac_report(struct hid_device *hdev, struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_field *field = report->field[0];
+ 
+ 	if (wacom_wac->features.type != HID_GENERIC)
+ 		return;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_report(hdev, report);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_report(hdev, report);
+ }
+ 
+ static int wacom_bpt_touch(struct wacom_wac *wacom)
+ {
+ 	struct wacom_features *features = &wacom->features;
+ 	struct input_dev *input = wacom->touch_input;
+ 	struct input_dev *pad_input = wacom->pad_input;
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	unsigned char *data = wacom->data;
  	int i;
  
@@@ -1226,16 -1755,20 +1683,30 @@@ static int wacom_bpt3_touch(struct waco
  			wacom_bpt3_button_msg(wacom, data + offset);
  
  	}
++<<<<<<< HEAD
 +	input_mt_sync_frame(input);
++=======
+ 
+ 	/* only update the touch if we actually have a touchpad */
+ 	if (wacom->touch_registered) {
+ 		input_mt_sync_frame(wacom->touch_input);
+ 		wacom->shared->touch_down = wacom_wac_finger_count_touches(wacom);
+ 	}
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  
 -	return 1;
 +	input_sync(input);
 +
 +	return 0;
  }
  
  static int wacom_bpt_pen(struct wacom_wac *wacom)
  {
++<<<<<<< HEAD
 +	struct input_dev *input = wacom->input;
++=======
+ 	struct wacom_features *features = &wacom->features;
+ 	struct input_dev *input = wacom->pen_input;
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	unsigned char *data = wacom->data;
  	int prox = 0, x = 0, y = 0, p = 0, d = 0, pen = 0, btn1 = 0, btn2 = 0;
  
@@@ -1315,6 -1848,91 +1786,94 @@@ static int wacom_bpt_irq(struct wacom_w
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_bamboo_pad_pen_event(struct wacom_wac *wacom,
+ 		unsigned char *data)
+ {
+ 	unsigned char prefix;
+ 
+ 	/*
+ 	 * We need to reroute the event from the debug interface to the
+ 	 * pen interface.
+ 	 * We need to add the report ID to the actual pen report, so we
+ 	 * temporary overwrite the first byte to prevent having to kzalloc/kfree
+ 	 * and memcpy the report.
+ 	 */
+ 	prefix = data[0];
+ 	data[0] = WACOM_REPORT_BPAD_PEN;
+ 
+ 	/*
+ 	 * actually reroute the event.
+ 	 * No need to check if wacom->shared->pen is valid, hid_input_report()
+ 	 * will check for us.
+ 	 */
+ 	hid_input_report(wacom->shared->pen, HID_INPUT_REPORT, data,
+ 			 WACOM_PKGLEN_PENABLED, 1);
+ 
+ 	data[0] = prefix;
+ }
+ 
+ static int wacom_bamboo_pad_touch_event(struct wacom_wac *wacom,
+ 		unsigned char *data)
+ {
+ 	struct input_dev *input = wacom->touch_input;
+ 	unsigned char *finger_data, prefix;
+ 	unsigned id;
+ 	int x, y;
+ 	bool valid;
+ 
+ 	prefix = data[0];
+ 
+ 	for (id = 0; id < wacom->features.touch_max; id++) {
+ 		valid = !!(prefix & BIT(id)) &&
+ 			!wacom->shared->stylus_in_proximity;
+ 
+ 		input_mt_slot(input, id);
+ 		input_mt_report_slot_state(input, MT_TOOL_FINGER, valid);
+ 
+ 		if (!valid)
+ 			continue;
+ 
+ 		finger_data = data + 1 + id * 3;
+ 		x = finger_data[0] | ((finger_data[1] & 0x0f) << 8);
+ 		y = (finger_data[2] << 4) | (finger_data[1] >> 4);
+ 
+ 		input_report_abs(input, ABS_MT_POSITION_X, x);
+ 		input_report_abs(input, ABS_MT_POSITION_Y, y);
+ 	}
+ 
+ 	input_mt_sync_frame(input);
+ 
+ 	input_report_key(input, BTN_LEFT, prefix & 0x40);
+ 	input_report_key(input, BTN_RIGHT, prefix & 0x80);
+ 
+ 	/* keep touch state for pen event */
+ 	wacom->shared->touch_down = !!prefix &&
+ 				    !wacom->shared->stylus_in_proximity;
+ 
+ 	return 1;
+ }
+ 
+ static int wacom_bamboo_pad_irq(struct wacom_wac *wacom, size_t len)
+ {
+ 	unsigned char *data = wacom->data;
+ 
+ 	if (!((len == WACOM_PKGLEN_BPAD_TOUCH) ||
+ 	      (len == WACOM_PKGLEN_BPAD_TOUCH_USB)) ||
+ 	    (data[0] != WACOM_REPORT_BPAD_TOUCH))
+ 		return 0;
+ 
+ 	if (data[1] & 0x01)
+ 		wacom_bamboo_pad_pen_event(wacom, &data[1]);
+ 
+ 	if (data[1] & 0x02)
+ 		return wacom_bamboo_pad_touch_event(wacom, &data[9]);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  static int wacom_wireless_irq(struct wacom_wac *wacom, size_t len)
  {
  	unsigned char *data = wacom->data;
@@@ -1429,8 -2120,14 +1988,19 @@@ void wacom_wac_irq(struct wacom_wac *wa
  		break;
  	}
  
++<<<<<<< HEAD
 +	if (sync)
 +		input_sync(wacom_wac->input);
++=======
+ 	if (sync) {
+ 		if (wacom_wac->pen_input)
+ 			input_sync(wacom_wac->pen_input);
+ 		if (wacom_wac->touch_input)
+ 			input_sync(wacom_wac->touch_input);
+ 		if (wacom_wac->pad_input)
+ 			input_sync(wacom_wac->pad_input);
+ 	}
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  }
  
  static void wacom_setup_cintiq(struct wacom_wac *wacom_wac)
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,2978c303909d..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -138,14 -176,44 +138,32 @@@ struct wacom_shared 
  };
  
  struct wacom_wac {
++<<<<<<< HEAD
 +	char name[WACOM_NAME_MAX];
 +	unsigned char *data;
++=======
+ 	char pen_name[WACOM_NAME_MAX];
+ 	char touch_name[WACOM_NAME_MAX];
+ 	char pad_name[WACOM_NAME_MAX];
+ 	char bat_name[WACOM_NAME_MAX];
+ 	char ac_name[WACOM_NAME_MAX];
+ 	unsigned char data[WACOM_PKGLEN_MAX];
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	int tool[2];
  	int id[2];
  	__u32 serial[2];
 -	bool reporting_data;
  	struct wacom_features features;
  	struct wacom_shared *shared;
++<<<<<<< HEAD
 +	struct input_dev *input;
++=======
+ 	struct input_dev *pen_input;
+ 	struct input_dev *touch_input;
+ 	struct input_dev *pad_input;
+ 	bool pen_registered;
+ 	bool touch_registered;
+ 	bool pad_registered;
++>>>>>>> 2a6cdbdd4cc0 (HID: wacom: Introduce new 'touch_input' device)
  	int pid;
  	int battery_capacity;
  	int num_contacts_left;
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
* Unmerged path drivers/hid/wacom_wac.h
