dax: Remove zeroing from dax_io()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jan Kara <jack@suse.cz>
commit 069c77bc9eaee70fa9ecbd942372b1693b8cdeb0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/069c77bc.failed

All the filesystems are now zeroing blocks themselves for DAX IO to avoid
races between dax_io() and dax_fault(). Remove the zeroing code from
dax_io() and add warning to catch the case when somebody unexpectedly
returns new or unwritten buffer.

	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
(cherry picked from commit 069c77bc9eaee70fa9ecbd942372b1693b8cdeb0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
diff --cc fs/dax.c
index ac0232cd059c,7c0036dd1570..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -110,18 -119,6 +110,21 @@@ int dax_clear_sectors(struct block_devi
  }
  EXPORT_SYMBOL_GPL(dax_clear_sectors);
  
++<<<<<<< HEAD
 +/* the clear_pmem() calls are ordered by a wmb_pmem() in the caller */
 +static void dax_new_buf(void *addr, unsigned size, unsigned first,
 +		loff_t pos, loff_t end)
 +{
 +	loff_t final = end - pos + first; /* The final byte of the buffer */
 +
 +	if (first > 0)
 +		clear_pmem(addr, first);
 +	if (final < size)
 +		clear_pmem(addr + final, size - final);
 +}
 +
++=======
++>>>>>>> 069c77bc9eae (dax: Remove zeroing from dax_io())
  static bool buffer_written(struct buffer_head *bh)
  {
  	return buffer_mapped(bh) && !buffer_unwritten(bh);
@@@ -167,20 -145,22 +170,23 @@@ static sector_t to_sector(const struct 
  	return sector;
  }
  
 -static ssize_t dax_io(struct inode *inode, struct iov_iter *iter,
 -		      loff_t start, loff_t end, get_block_t get_block,
 -		      struct buffer_head *bh)
 +static ssize_t dax_io(int rw, struct inode *inode, const struct iovec *iov,
 +			loff_t start, loff_t end, get_block_t get_block,
 +			struct buffer_head *bh)
  {
  	loff_t pos = start, max = start, bh_max = start;
 -	bool hole = false, need_wmb = false;
 +	bool hole = false;
  	struct block_device *bdev = NULL;
 -	int rw = iov_iter_rw(iter), rc;
 +	int rc;
  	long map_len = 0;
  	struct blk_dax_ctl dax = {
 -		.addr = (void __pmem *) ERR_PTR(-EIO),
 +		.addr = ERR_PTR(-EIO),
  	};
+ 	unsigned blkbits = inode->i_blkbits;
+ 	sector_t file_blks = (i_size_read(inode) + (1 << blkbits) - 1)
+ 								>> blkbits;
  
 +	rw &= RW_MASK;
  	if (rw == READ)
  		end = min(end, i_size_read(inode));
  
@@@ -222,10 -208,6 +234,13 @@@
  					rc = map_len;
  					break;
  				}
++<<<<<<< HEAD
 +				if (buffer_unwritten(bh) || buffer_new(bh)) {
 +					dax_new_buf(dax.addr, map_len, first,
 +							pos, end);
 +				}
++=======
++>>>>>>> 069c77bc9eae (dax: Remove zeroing from dax_io())
  				dax.addr += first;
  				size = map_len - first;
  			}
* Unmerged path fs/dax.c
