btrfs: Continue write in case of can_not_nocow

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Zhao Lei <zhaolei@cn.fujitsu.com>
commit 4da2e26a2a32b174878744bd0f07db180c875f26
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4da2e26a.failed

btrfs failed in xfstests btrfs/080 with -o nodatacow.

Can be reproduced by following script:
  DEV=/dev/vdg
  MNT=/mnt/tmp

  umount $DEV &>/dev/null
  mkfs.btrfs -f $DEV
  mount -o nodatacow $DEV $MNT

  dd if=/dev/zero of=$MNT/test bs=1 count=2048 &
  btrfs subvolume snapshot -r $MNT $MNT/test_snap &
  wait
  --
  We can see dd failed on NO_SPACE.

Reason:
  __btrfs_buffered_write should run cow write when no_cow impossible,
  and current code is designed with above logic.
  But check_can_nocow() have 2 type of return value(0 and <0) on
  can_not_no_cow, and current code only continue write on first case,
  the second case happened in doing subvolume.

Fix:
  Continue write when check_can_nocow() return 0 and <0.

	Reviewed-by: Filipe Manana <fdmanana@suse.com>
	Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
(cherry picked from commit 4da2e26a2a32b174878744bd0f07db180c875f26)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/file.c
diff --cc fs/btrfs/file.c
index 6d5c677ecb95,cadfebaaf8c4..000000000000
--- a/fs/btrfs/file.c
+++ b/fs/btrfs/file.c
@@@ -1533,33 -1523,26 +1533,53 @@@ static noinline ssize_t __btrfs_buffere
  			break;
  		}
  
 -		reserve_bytes = num_pages << PAGE_CACHE_SHIFT;
 +		sector_offset = pos & (root->sectorsize - 1);
 +		reserve_bytes = round_up(write_bytes + sector_offset,
 +				root->sectorsize);
  
++<<<<<<< HEAD
 +		if (BTRFS_I(inode)->flags & (BTRFS_INODE_NODATACOW |
 +					     BTRFS_INODE_PREALLOC)) {
 +			ret = check_can_nocow(inode, pos, &write_bytes);
 +			if (ret < 0)
 +				break;
 +			if (ret > 0) {
 +				/*
 +				 * For nodata cow case, no need to reserve
 +				 * data space.
 +				 */
 +				only_release_metadata = true;
 +				/*
 +				 * our prealloc extent may be smaller than
 +				 * write_bytes, so scale down.
 +				 */
 +				num_pages = DIV_ROUND_UP(write_bytes + offset,
 +							 PAGE_CACHE_SIZE);
 +				reserve_bytes = round_up(write_bytes
 +							+ sector_offset,
 +							root->sectorsize);
 +				goto reserve_metadata;
 +			}
++=======
+ 		if ((BTRFS_I(inode)->flags & (BTRFS_INODE_NODATACOW |
+ 					      BTRFS_INODE_PREALLOC)) &&
+ 		    check_can_nocow(inode, pos, &write_bytes) > 0) {
+ 			/*
+ 			 * For nodata cow case, no need to reserve
+ 			 * data space.
+ 			 */
+ 			only_release_metadata = true;
+ 			/*
+ 			 * our prealloc extent may be smaller than
+ 			 * write_bytes, so scale down.
+ 			 */
+ 			num_pages = DIV_ROUND_UP(write_bytes + offset,
+ 						 PAGE_CACHE_SIZE);
+ 			reserve_bytes = num_pages << PAGE_CACHE_SHIFT;
+ 			goto reserve_metadata;
++>>>>>>> 4da2e26a2a32 (btrfs: Continue write in case of can_not_nocow)
  		}
+ 
  		ret = btrfs_check_data_free_space(inode, pos, write_bytes);
  		if (ret < 0)
  			break;
* Unmerged path fs/btrfs/file.c
