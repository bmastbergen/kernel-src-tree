dax: don't pass buffer_head to copy_user_dax

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Christoph Hellwig <hch@lst.de>
commit b0d5e82fcf8249b5aca52d235c1cfabd68b253e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b0d5e82f.failed

This way we can use this helper for the iomap based DAX implementation
as well.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ross Zwisler <ross.zwisler@linux.intel.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit b0d5e82fcf8249b5aca52d235c1cfabd68b253e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/dax.c
diff --cc fs/dax.c
index 3ad95e9ec809,84343ce8be70..000000000000
--- a/fs/dax.c
+++ b/fs/dax.c
@@@ -684,9 -861,26 +683,30 @@@ int __dax_fault(struct vm_area_struct *
  	if (!error && (bh.b_size < PAGE_SIZE))
  		error = -EIO;		/* fs corruption? */
  	if (error)
 -		goto unlock_entry;
 +		goto unlock_page;
  
++<<<<<<< HEAD
 +	if (!buffer_mapped(&bh) && !vmf->cow_page) {
++=======
+ 	if (vmf->cow_page) {
+ 		struct page *new_page = vmf->cow_page;
+ 		if (buffer_written(&bh))
+ 			error = copy_user_dax(bh.b_bdev, to_sector(&bh, inode),
+ 					bh.b_size, new_page, vaddr);
+ 		else
+ 			clear_user_highpage(new_page, vaddr);
+ 		if (error)
+ 			goto unlock_entry;
+ 		if (!radix_tree_exceptional_entry(entry)) {
+ 			vmf->page = entry;
+ 			return VM_FAULT_LOCKED;
+ 		}
+ 		vmf->entry = entry;
+ 		return VM_FAULT_DAX_LOCKED;
+ 	}
+ 
+ 	if (!buffer_mapped(&bh)) {
++>>>>>>> b0d5e82fcf82 (dax: don't pass buffer_head to copy_user_dax)
  		if (vmf->flags & FAULT_FLAG_WRITE) {
  			error = get_block(inode, block, &bh, 1);
  			count_vm_event(PGMAJFAULT);
* Unmerged path fs/dax.c
