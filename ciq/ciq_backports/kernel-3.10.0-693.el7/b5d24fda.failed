mm, devm_memremap_pages: hold device_hotplug lock over mem_hotplug_{begin, done}

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mm] devm_memremap_pages: hold device_hotplug lock over mem_hotplug_{begin, done} (Jeff Moyer) [1438579]
Rebuild_FUZZ: 97.44%
commit-author Dan Williams <dan.j.williams@intel.com>
commit b5d24fda9c3dce51fcb4eee459550a458eaaf1e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b5d24fda.failed

The mem_hotplug_{begin,done} lock coordinates with {get,put}_online_mems()
to hold off "readers" of the current state of memory from new hotplug
actions.  mem_hotplug_begin() expects exclusive access, via the
device_hotplug lock, to set mem_hotplug.active_writer.  Calling
mem_hotplug_begin() without locking device_hotplug can lead to
corrupting mem_hotplug.refcount and missed wakeups / soft lockups.

[dan.j.williams@intel.com: v2]
  Link: http://lkml.kernel.org/r/148728203365.38457.17804568297887708345.stgit@dwillia2-desk3.amr.corp.intel.com
Link: http://lkml.kernel.org/r/148693885680.16345.17802627926777862337.stgit@dwillia2-desk3.amr.corp.intel.com
Fixes: f931ab479dd2 ("mm: fix devm_memremap_pages crash, use mem_hotplug_{begin, done}")
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Reported-by: Ben Hutchings <ben@decadent.org.uk>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Toshi Kani <toshi.kani@hpe.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Logan Gunthorpe <logang@deltatee.com>
	Cc: Masayoshi Mizuma <m.mizuma@jp.fujitsu.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit b5d24fda9c3dce51fcb4eee459550a458eaaf1e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/memremap.c
diff --cc kernel/memremap.c
index 8e338960b262,06123234f118..000000000000
--- a/kernel/memremap.c
+++ b/kernel/memremap.c
@@@ -229,7 -246,14 +229,18 @@@ static void devm_memremap_pages_release
  	/* pages are dead and unused, undo the arch mapping */
  	align_start = res->start & ~(SECTION_SIZE - 1);
  	align_size = ALIGN(resource_size(res), SECTION_SIZE);
++<<<<<<< HEAD
 +	arch_remove_memory(align_start, align_size);
++=======
+ 
+ 	lock_device_hotplug();
+ 	mem_hotplug_begin();
+ 	arch_remove_memory(align_start, align_size);
+ 	mem_hotplug_done();
+ 	unlock_device_hotplug();
+ 
+ 	untrack_pfn(NULL, PHYS_PFN(align_start), align_size);
++>>>>>>> b5d24fda9c3d (mm, devm_memremap_pages: hold device_hotplug lock over mem_hotplug_{begin, done})
  	pgmap_radix_release(res);
  	dev_WARN_ONCE(dev, pgmap->altmap && pgmap->altmap->alloc,
  			"%s: failed to free all reserved pages\n", __func__);
@@@ -339,7 -359,16 +350,20 @@@ void *devm_memremap_pages(struct devic
  	if (nid < 0)
  		nid = numa_mem_id();
  
++<<<<<<< HEAD
++	error = arch_add_memory(nid, align_start, align_size, true);
++=======
+ 	error = track_pfn_remap(NULL, &pgprot, PHYS_PFN(align_start), 0,
+ 			align_size);
+ 	if (error)
+ 		goto err_pfn_remap;
+ 
+ 	lock_device_hotplug();
+ 	mem_hotplug_begin();
  	error = arch_add_memory(nid, align_start, align_size, true);
+ 	mem_hotplug_done();
+ 	unlock_device_hotplug();
++>>>>>>> b5d24fda9c3d (mm, devm_memremap_pages: hold device_hotplug lock over mem_hotplug_{begin, done})
  	if (error)
  		goto err_add_memory;
  
* Unmerged path kernel/memremap.c
