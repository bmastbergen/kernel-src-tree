net/sched: Enable netdev drivers to update statistics of offloaded actions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: Enable netdev drivers to update statistics of offloaded actions (Ivan Vecera) [1390693]
Rebuild_FUZZ: 97.22%
commit-author Amir Vadai <amirva@mellanox.com>
commit 3804070235264ea883c3fdccd9ed16fef20b5ccb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/38040702.failed

Introduce stats_update callback. netdev driver could call it for offloaded
actions to update the basic statistics (packets, bytes and last use).
Since bstats_update() and bstats_cpu_update() use skb as an argument to
get the counters, _bstats_update() and _bstats_cpu_update(), that get
bytes and packets as arguments, were added.

	Signed-off-by: Amir Vadai <amirva@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3804070235264ea883c3fdccd9ed16fef20b5ccb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/act_api.h
#	include/net/sch_generic.h
diff --cc include/net/act_api.h
index 11aac9abd0ca,2cd9e9bb059a..000000000000
--- a/include/net/act_api.h
+++ b/include/net/act_api.h
@@@ -74,25 -104,63 +74,31 @@@ struct tc_action_ops 
  	int     (*init)(struct net *net, struct nlattr *nla,
  			struct nlattr *est, struct tc_action *act, int ovr,
  			int bind);
++<<<<<<< HEAD
 +	int     (*walk)(struct sk_buff *, struct netlink_callback *, int, struct tc_action *);
++=======
+ 	int     (*walk)(struct net *, struct sk_buff *,
+ 			struct netlink_callback *, int, struct tc_action *);
+ 	void	(*stats_update)(struct tc_action *, u64, u32, u64);
++>>>>>>> 380407023526 (net/sched: Enable netdev drivers to update statistics of offloaded actions)
  };
  
 -struct tc_action_net {
 -	struct tcf_hashinfo *hinfo;
 -	const struct tc_action_ops *ops;
 -};
 -
 -static inline
 -int tc_action_net_init(struct tc_action_net *tn, const struct tc_action_ops *ops,
 -		       unsigned int mask)
 -{
 -	int err = 0;
 -
 -	tn->hinfo = kmalloc(sizeof(*tn->hinfo), GFP_KERNEL);
 -	if (!tn->hinfo)
 -		return -ENOMEM;
 -	tn->ops = ops;
 -	err = tcf_hashinfo_init(tn->hinfo, mask);
 -	if (err)
 -		kfree(tn->hinfo);
 -	return err;
 -}
 -
 -void tcf_hashinfo_destroy(const struct tc_action_ops *ops,
 -			  struct tcf_hashinfo *hinfo);
 -
 -static inline void tc_action_net_exit(struct tc_action_net *tn)
 -{
 -	tcf_hashinfo_destroy(tn->ops, tn->hinfo);
 -	kfree(tn->hinfo);
 -}
 -
 -int tcf_generic_walker(struct tc_action_net *tn, struct sk_buff *skb,
 -		       struct netlink_callback *cb, int type,
 -		       struct tc_action *a);
 -int tcf_hash_search(struct tc_action_net *tn, struct tc_action *a, u32 index);
 -u32 tcf_hash_new_index(struct tc_action_net *tn);
 -int tcf_hash_check(struct tc_action_net *tn, u32 index, struct tc_action *a,
 -		   int bind);
 -int tcf_hash_create(struct tc_action_net *tn, u32 index, struct nlattr *est,
 -		    struct tc_action *a, int size, int bind, bool cpustats);
 -void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est);
 -void tcf_hash_insert(struct tc_action_net *tn, struct tc_action *a);
 -
 -int __tcf_hash_release(struct tc_action *a, bool bind, bool strict);
 -
 -static inline int tcf_hash_release(struct tc_action *a, bool bind)
 -{
 -	return __tcf_hash_release(a, bind, false);
 -}
 -
 -int tcf_register_action(struct tc_action_ops *a, struct pernet_operations *ops);
 -int tcf_unregister_action(struct tc_action_ops *a, struct pernet_operations *ops);
 -int tcf_action_destroy(struct list_head *actions, int bind);
 +struct tcf_common *tcf_hash_lookup(u32 index, struct tcf_hashinfo *hinfo);
 +void tcf_hash_destroy(struct tcf_common *p, struct tcf_hashinfo *hinfo);
 +int tcf_hash_release(struct tcf_common *p, int bind,
 +		     struct tcf_hashinfo *hinfo);
 +u32 tcf_hash_new_index(u32 *idx_gen, struct tcf_hashinfo *hinfo);
 +struct tcf_common *tcf_hash_check(u32 index, struct tc_action *a,
 +				  int bind, struct tcf_hashinfo *hinfo);
 +struct tcf_common *tcf_hash_create(u32 index, struct nlattr *est,
 +				   struct tc_action *a, int size,
 +				   int bind, u32 *idx_gen,
 +				   struct tcf_hashinfo *hinfo);
 +void tcf_hash_insert(struct tcf_common *p, struct tcf_hashinfo *hinfo);
 +
 +int tcf_register_action(struct tc_action_ops *a);
 +int tcf_unregister_action(struct tc_action_ops *a);
 +void tcf_action_destroy(struct list_head *actions, int bind);
  int tcf_action_exec(struct sk_buff *skb, const struct list_head *actions,
  		    struct tcf_result *res);
  int tcf_action_init(struct net *net, struct nlattr *nla,
@@@ -105,5 -173,27 +111,30 @@@ int tcf_action_dump(struct sk_buff *skb
  int tcf_action_dump_old(struct sk_buff *skb, struct tc_action *a, int, int);
  int tcf_action_dump_1(struct sk_buff *skb, struct tc_action *a, int, int);
  int tcf_action_copy_stats(struct sk_buff *, struct tc_action *, int);
++<<<<<<< HEAD
++=======
+ 
+ #define tc_no_actions(_exts) \
+ 	(list_empty(&(_exts)->actions))
+ 
+ #define tc_for_each_action(_a, _exts) \
+ 	list_for_each_entry(a, &(_exts)->actions, list)
+ 
+ static inline void tcf_action_stats_update(struct tc_action *a, u64 bytes,
+ 					   u64 packets, u64 lastuse)
+ {
+ 	if (!a->ops->stats_update)
+ 		return;
+ 
+ 	a->ops->stats_update(a, bytes, packets, lastuse);
+ }
+ 
+ #else /* CONFIG_NET_CLS_ACT */
+ 
+ #define tc_no_actions(_exts) true
+ #define tc_for_each_action(_a, _exts) while (0)
+ #define tcf_action_stats_update(a, bytes, packets, lastuse)
+ 
++>>>>>>> 380407023526 (net/sched: Enable netdev drivers to update statistics of offloaded actions)
  #endif /* CONFIG_NET_CLS_ACT */
  #endif
diff --cc include/net/sch_generic.h
index 96bed6f81e99,a1fd76c22a59..000000000000
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@@ -499,20 -522,48 +499,38 @@@ static inline int qdisc_enqueue(struct 
  	return sch->enqueue(skb, sch);
  }
  
 -static inline bool qdisc_is_percpu_stats(const struct Qdisc *q)
 +static inline int qdisc_enqueue_root(struct sk_buff *skb, struct Qdisc *sch)
  {
 -	return q->flags & TCQ_F_CPUSTATS;
 +	qdisc_skb_cb(skb)->pkt_len = skb->len;
 +	return qdisc_enqueue(skb, sch) & NET_XMIT_MASK;
  }
  
++<<<<<<< HEAD
++=======
+ static inline void _bstats_update(struct gnet_stats_basic_packed *bstats,
+ 				  __u64 bytes, __u32 packets)
+ {
+ 	bstats->bytes += bytes;
+ 	bstats->packets += packets;
+ }
++>>>>>>> 380407023526 (net/sched: Enable netdev drivers to update statistics of offloaded actions)
  
  static inline void bstats_update(struct gnet_stats_basic_packed *bstats,
  				 const struct sk_buff *skb)
  {
- 	bstats->bytes += qdisc_pkt_len(skb);
- 	bstats->packets += skb_is_gso(skb) ? skb_shinfo(skb)->gso_segs : 1;
+ 	_bstats_update(bstats,
+ 		       qdisc_pkt_len(skb),
+ 		       skb_is_gso(skb) ? skb_shinfo(skb)->gso_segs : 1);
+ }
+ 
+ static inline void _bstats_cpu_update(struct gnet_stats_basic_cpu *bstats,
+ 				      __u64 bytes, __u32 packets)
+ {
+ 	u64_stats_update_begin(&bstats->syncp);
+ 	_bstats_update(&bstats->bstats, bytes, packets);
+ 	u64_stats_update_end(&bstats->syncp);
  }
  
 -static inline void bstats_cpu_update(struct gnet_stats_basic_cpu *bstats,
 -				     const struct sk_buff *skb)
 -{
 -	u64_stats_update_begin(&bstats->syncp);
 -	bstats_update(&bstats->bstats, skb);
 -	u64_stats_update_end(&bstats->syncp);
 -}
 -
 -static inline void qdisc_bstats_cpu_update(struct Qdisc *sch,
 -					   const struct sk_buff *skb)
 -{
 -	bstats_cpu_update(this_cpu_ptr(sch->cpu_bstats), skb);
 -}
 -
  static inline void qdisc_bstats_update(struct Qdisc *sch,
  				       const struct sk_buff *skb)
  {
* Unmerged path include/net/act_api.h
* Unmerged path include/net/sch_generic.h
