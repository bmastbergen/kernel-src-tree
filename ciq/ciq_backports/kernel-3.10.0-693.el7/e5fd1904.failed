pNFS: Ensure layoutreturn acts as a completion for layout callbacks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit e5fd1904b8422615a2a286777e2b7c881ad53e73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e5fd1904.failed

When we return NFS_OK to the CB_LAYOUTRECALL, we are required to
send a layoutreturn that "completes" that layout recall request, using
the correct stateid.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit e5fd1904b8422615a2a286777e2b7c881ad53e73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pnfs.c
diff --cc fs/nfs/pnfs.c
index 3653071b6302,878dc4b7085a..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -899,14 -874,37 +899,34 @@@ void pnfs_clear_layoutreturn_waitbit(st
  	rpc_wake_up(&NFS_SERVER(lo->plh_inode)->roc_rpcwaitq);
  }
  
 -static void
 -pnfs_clear_layoutreturn_info(struct pnfs_layout_hdr *lo)
 -{
 -	lo->plh_return_iomode = 0;
 -	lo->plh_return_seq = 0;
 -	clear_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags);
 -}
 -
  static bool
- pnfs_prepare_layoutreturn(struct pnfs_layout_hdr *lo)
+ pnfs_prepare_layoutreturn(struct pnfs_layout_hdr *lo,
+ 		nfs4_stateid *stateid,
+ 		enum pnfs_iomode *iomode)
  {
  	if (test_and_set_bit(NFS_LAYOUT_RETURN, &lo->plh_flags))
  		return false;
 +	lo->plh_return_iomode = 0;
  	pnfs_get_layout_hdr(lo);
++<<<<<<< HEAD
 +	clear_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE, &lo->plh_flags);
++=======
+ 	if (test_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags)) {
+ 		if (stateid != NULL) {
+ 			nfs4_stateid_copy(stateid, &lo->plh_stateid);
+ 			if (lo->plh_return_seq != 0)
+ 				stateid->seqid = cpu_to_be32(lo->plh_return_seq);
+ 		}
+ 		if (iomode != NULL)
+ 			*iomode = lo->plh_return_iomode;
+ 		pnfs_clear_layoutreturn_info(lo);
+ 		return true;
+ 	}
+ 	if (stateid != NULL)
+ 		nfs4_stateid_copy(stateid, &lo->plh_stateid);
+ 	if (iomode != NULL)
+ 		*iomode = IOMODE_ANY;
++>>>>>>> e5fd1904b842 (pNFS: Ensure layoutreturn acts as a completion for layout callbacks)
  	return true;
  }
  
@@@ -974,9 -972,7 +994,13 @@@ static void pnfs_layoutreturn_before_pu
  		enum pnfs_iomode iomode;
  		bool send;
  
++<<<<<<< HEAD
 +		nfs4_stateid_copy(&stateid, &lo->plh_stateid);
 +		iomode = lo->plh_return_iomode;
 +		send = pnfs_prepare_layoutreturn(lo);
++=======
+ 		send = pnfs_prepare_layoutreturn(lo, &stateid, &iomode);
++>>>>>>> e5fd1904b842 (pNFS: Ensure layoutreturn acts as a completion for layout callbacks)
  		spin_unlock(&inode->i_lock);
  		if (send) {
  			/* Send an async layoutreturn so we dont deadlock */
@@@ -1104,11 -1099,10 +1127,16 @@@ bool pnfs_roc(struct inode *ino
  			goto out_noroc;
  	}
  
- 	nfs4_stateid_copy(&stateid, &lo->plh_stateid);
  	/* always send layoutreturn if being marked so */
++<<<<<<< HEAD
 +	if (test_and_clear_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,
 +				   &lo->plh_flags))
 +		layoutreturn = pnfs_prepare_layoutreturn(lo);
++=======
+ 	if (test_bit(NFS_LAYOUT_RETURN_REQUESTED, &lo->plh_flags))
+ 		layoutreturn = pnfs_prepare_layoutreturn(lo,
+ 				&stateid, NULL);
++>>>>>>> e5fd1904b842 (pNFS: Ensure layoutreturn acts as a completion for layout callbacks)
  
  	list_for_each_entry_safe(lseg, tmp, &lo->plh_segs, pls_list)
  		/* If we are sending layoutreturn, invalidate all valid lsegs */
@@@ -1798,8 -1882,19 +1826,24 @@@ void pnfs_error_mark_layout_for_return(
  	 * segments at hand when sending layoutreturn. See pnfs_put_lseg()
  	 * for how it works.
  	 */
++<<<<<<< HEAD
 +	pnfs_mark_matching_lsegs_return(lo, &free_me, &range);
 +	spin_unlock(&inode->i_lock);
++=======
+ 	if (!pnfs_mark_matching_lsegs_return(lo, &free_me,
+ 						&range, lseg->pls_seq)) {
+ 		nfs4_stateid stateid;
+ 		enum pnfs_iomode iomode;
+ 
+ 		return_now = pnfs_prepare_layoutreturn(lo, &stateid, &iomode);
+ 		spin_unlock(&inode->i_lock);
+ 		if (return_now)
+ 			pnfs_send_layoutreturn(lo, &stateid, iomode, false);
+ 	} else {
+ 		spin_unlock(&inode->i_lock);
+ 		nfs_commit_inode(inode, 0);
+ 	}
++>>>>>>> e5fd1904b842 (pNFS: Ensure layoutreturn acts as a completion for layout callbacks)
  	pnfs_free_lseg_list(&free_me);
  }
  EXPORT_SYMBOL_GPL(pnfs_error_mark_layout_for_return);
* Unmerged path fs/nfs/pnfs.c
