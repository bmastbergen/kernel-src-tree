flow_dissector: introduce support for ipv6 addressses

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jiri Pirko <jiri@resnulli.us>
commit b924933cbbfbdcaa2831a39780c116ec6e48c397
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b924933c.failed

So far, only hashes made out of ipv6 addresses could be dissected. This
patch introduces support for dissection of full ipv6 addresses.

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b924933cbbfbdcaa2831a39780c116ec6e48c397)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index fbf58a98e819,1b95d5ccc9d6..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -160,16 -173,52 +160,63 @@@ ipv6
  			return false;
  
  		ip_proto = iph->nexthdr;
 +		flow->src = (__force __be32)ipv6_addr_hash(&iph->saddr);
 +		flow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);
  		nhoff += sizeof(struct ipv6hdr);
  
++<<<<<<< HEAD
 +		/* skip the flow label processing if skb is NULL.  The
 +		 * assumption here is that if there is no skb we are not
 +		 * looking for flow info as much as we are length.
 +		 */
 +		if (!skb)
 +			break;
++=======
+ 		if (skb_flow_dissector_uses_key(flow_dissector,
+ 						FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS)) {
+ 			key_addrs = skb_flow_dissector_target(flow_dissector,
+ 							      FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS,
+ 							      target_container);
+ 
+ 			key_addrs->src = (__force __be32)ipv6_addr_hash(&iph->saddr);
+ 			key_addrs->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);
+ 			goto flow_label;
+ 		}
+ 		if (skb_flow_dissector_uses_key(flow_dissector,
+ 						FLOW_DISSECTOR_KEY_IPV6_ADDRS)) {
+ 			struct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;
+ 
+ 			key_ipv6_addrs = skb_flow_dissector_target(flow_dissector,
+ 								   FLOW_DISSECTOR_KEY_IPV6_ADDRS,
+ 								   target_container);
+ 
+ 			memcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));
+ 			goto flow_label;
+ 		}
+ 		break;
+ flow_label:
+ 		flow_label = ip6_flowlabel(iph);
+ 		if (flow_label) {
+ 			/* Awesome, IPv6 packet has a flow label so we can
+ 			 * use that to represent the ports without any
+ 			 * further dissection.
+ 			 */
+ 
+ 			key_basic->n_proto = proto;
+ 			key_basic->ip_proto = ip_proto;
+ 			key_basic->thoff = (u16)nhoff;
+ 
+ 			if (!skb_flow_dissector_uses_key(flow_dissector,
+ 							 FLOW_DISSECTOR_KEY_PORTS))
+ 				break;
+ 			key_ports = skb_flow_dissector_target(flow_dissector,
+ 							      FLOW_DISSECTOR_KEY_PORTS,
+ 							      target_container);
+ 			key_ports->ports = flow_label;
+ 
+ 			return true;
+ 		}
++>>>>>>> b924933cbbfb (flow_dissector: introduce support for ipv6 addressses)
  
  		break;
  	}
diff --git a/include/net/flow_keys.h b/include/net/flow_keys.h
index e4cae922c24d..2e7044c1ed0c 100644
--- a/include/net/flow_keys.h
+++ b/include/net/flow_keys.h
@@ -3,6 +3,7 @@
 
 #include <linux/types.h>
 #include <linux/skbuff.h>
+#include <linux/in6.h>
 
 /**
  * struct flow_dissector_key_basic:
@@ -42,11 +43,23 @@ struct flow_dissector_key_ports {
 	};
 };
 
+/**
+ * struct flow_dissector_key_ipv6_addrs:
+ * @src: source ip address
+ * @dst: destination ip address
+ */
+struct flow_dissector_key_ipv6_addrs {
+	/* (src,dst) must be grouped, in the same way than in IP header */
+	struct in6_addr src;
+	struct in6_addr dst;
+};
+
 enum flow_dissector_key_id {
 	FLOW_DISSECTOR_KEY_BASIC, /* struct flow_dissector_key_basic */
 	FLOW_DISSECTOR_KEY_IPV4_ADDRS, /* struct flow_dissector_key_addrs */
 	FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS, /* struct flow_dissector_key_addrs */
 	FLOW_DISSECTOR_KEY_PORTS, /* struct flow_dissector_key_ports */
+	FLOW_DISSECTOR_KEY_IPV6_ADDRS, /* struct flow_dissector_key_ipv6_addrs */
 
 	FLOW_DISSECTOR_KEY_MAX,
 };
* Unmerged path net/core/flow_dissector.c
