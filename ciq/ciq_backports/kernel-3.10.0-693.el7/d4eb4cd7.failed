net/mlx5: Add handling for port module event

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [kernel] mlx5: Add handling for port module event (Don Dutile) [1385330 1417286]
Rebuild_FUZZ: 95.24%
commit-author Huy Nguyen <huyn@mellanox.com>
commit d4eb4cd78b0774c7061db56844ed2ea7790cc77c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d4eb4cd7.failed

For each asynchronous port module event:
  1. print with ratelimit to the dmesg log
  2. increment the corresponding event counter

	Signed-off-by: Huy Nguyen <huyn@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d4eb4cd78b0774c7061db56844ed2ea7790cc77c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mlx5/driver.h
diff --cc include/linux/mlx5/driver.h
index 40b8a2606851,7336c8e529d7..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -464,8 -469,60 +464,33 @@@ struct mlx5_irq_info 
  	char name[MLX5_MAX_IRQ_NAME];
  };
  
 -struct mlx5_fc_stats {
 -	struct rb_root counters;
 -	struct list_head addlist;
 -	/* protect addlist add/splice operations */
 -	spinlock_t addlist_lock;
 -
 -	struct workqueue_struct *wq;
 -	struct delayed_work work;
 -	unsigned long next_query;
 -};
 -
  struct mlx5_eswitch;
 -struct mlx5_lag;
 -
 -struct mlx5_rl_entry {
 -	u32                     rate;
 -	u16                     index;
 -	u16                     refcount;
 -};
 -
 -struct mlx5_rl_table {
 -	/* protect rate limit table */
 -	struct mutex            rl_lock;
 -	u16                     max_size;
 -	u32                     max_rate;
 -	u32                     min_rate;
 -	struct mlx5_rl_entry   *rl_entry;
 -};
  
+ enum port_module_event_status_type {
+ 	MLX5_MODULE_STATUS_PLUGGED   = 0x1,
+ 	MLX5_MODULE_STATUS_UNPLUGGED = 0x2,
+ 	MLX5_MODULE_STATUS_ERROR     = 0x3,
+ 	MLX5_MODULE_STATUS_NUM       = 0x3,
+ };
+ 
+ enum  port_module_event_error_type {
+ 	MLX5_MODULE_EVENT_ERROR_POWER_BUDGET_EXCEEDED,
+ 	MLX5_MODULE_EVENT_ERROR_LONG_RANGE_FOR_NON_MLNX_CABLE_MODULE,
+ 	MLX5_MODULE_EVENT_ERROR_BUS_STUCK,
+ 	MLX5_MODULE_EVENT_ERROR_NO_EEPROM_RETRY_TIMEOUT,
+ 	MLX5_MODULE_EVENT_ERROR_ENFORCE_PART_NUMBER_LIST,
+ 	MLX5_MODULE_EVENT_ERROR_UNKNOWN_IDENTIFIER,
+ 	MLX5_MODULE_EVENT_ERROR_HIGH_TEMPERATURE,
+ 	MLX5_MODULE_EVENT_ERROR_BAD_CABLE,
+ 	MLX5_MODULE_EVENT_ERROR_UNKNOWN,
+ 	MLX5_MODULE_EVENT_ERROR_NUM,
+ };
+ 
+ struct mlx5_port_module_event_stats {
+ 	u64 status_counters[MLX5_MODULE_STATUS_NUM];
+ 	u64 error_counters[MLX5_MODULE_EVENT_ERROR_NUM];
+ };
+ 
  struct mlx5_priv {
  	char			name[MLX5_MAX_NAME_LEN];
  	struct mlx5_eq_table	eq_table;
@@@ -520,11 -577,15 +545,18 @@@
  	struct list_head        ctx_list;
  	spinlock_t              ctx_lock;
  
 -	struct mlx5_flow_steering *steering;
  	struct mlx5_eswitch     *eswitch;
  	struct mlx5_core_sriov	sriov;
 -	struct mlx5_lag		*lag;
  	unsigned long		pci_dev_data;
++<<<<<<< HEAD
 +	struct mlx5_flow_root_namespace *root_ns;
 +	struct mlx5_flow_root_namespace *fdb_root_ns;
++=======
+ 	struct mlx5_fc_stats		fc_stats;
+ 	struct mlx5_rl_table            rl_table;
+ 
+ 	struct mlx5_port_module_event_stats  pme_stats;
++>>>>>>> d4eb4cd78b07 (net/mlx5: Add handling for port module event)
  };
  
  enum mlx5_device_state {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eq.c b/drivers/net/ethernet/mellanox/mlx5/core/eq.c
index 1c218506675f..7441a839a0d4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eq.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eq.c
@@ -143,6 +143,8 @@ static const char *eqe_type_str(u8 type)
 		return "MLX5_EVENT_TYPE_PORT_CHANGE";
 	case MLX5_EVENT_TYPE_GPIO_EVENT:
 		return "MLX5_EVENT_TYPE_GPIO_EVENT";
+	case MLX5_EVENT_TYPE_PORT_MODULE_EVENT:
+		return "MLX5_EVENT_TYPE_PORT_MODULE_EVENT";
 	case MLX5_EVENT_TYPE_REMOTE_CONFIG:
 		return "MLX5_EVENT_TYPE_REMOTE_CONFIG";
 	case MLX5_EVENT_TYPE_DB_BF_CONGESTION:
@@ -289,6 +291,11 @@ static int mlx5_eq_int(struct mlx5_core_dev *dev, struct mlx5_eq *eq)
 			mlx5_eswitch_vport_event(dev->priv.eswitch, eqe);
 			break;
 #endif
+
+		case MLX5_EVENT_TYPE_PORT_MODULE_EVENT:
+			mlx5_port_module_event(dev, eqe);
+			break;
+
 		default:
 			mlx5_core_warn(dev, "Unhandled event 0x%x on EQ 0x%x\n",
 				       eqe->type, eq->eqn);
@@ -485,6 +492,11 @@ int mlx5_start_eqs(struct mlx5_core_dev *dev)
 	    mlx5_core_is_pf(dev))
 		async_event_mask |= (1ull << MLX5_EVENT_TYPE_NIC_VPORT_CHANGE);
 
+	if (MLX5_CAP_GEN(dev, port_module_event))
+		async_event_mask |= (1ull << MLX5_EVENT_TYPE_PORT_MODULE_EVENT);
+	else
+		mlx5_core_dbg(dev, "port_module_event is not set\n");
+
 	err = mlx5_create_map_eq(dev, &table->cmd_eq, MLX5_EQ_VEC_CMD,
 				 MLX5_NUM_CMD_EQE, 1ull << MLX5_EVENT_TYPE_CMD,
 				 "mlx5_cmd_eq", &dev->priv.uuari.uars[0]);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index 1f3289b370d9..c9e6c4427602 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@ -92,6 +92,7 @@ int mlx5_cmd_init_hca(struct mlx5_core_dev *dev);
 int mlx5_cmd_teardown_hca(struct mlx5_core_dev *dev);
 void mlx5_core_event(struct mlx5_core_dev *dev, enum mlx5_dev_event event,
 		     unsigned long param);
+void mlx5_port_module_event(struct mlx5_core_dev *dev, struct mlx5_eqe *eqe);
 void mlx5_enter_error_state(struct mlx5_core_dev *dev);
 void mlx5_disable_device(struct mlx5_core_dev *dev);
 int mlx5_core_sriov_configure(struct pci_dev *dev, int num_vfs);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/port.c b/drivers/net/ethernet/mellanox/mlx5/core/port.c
index 5e93288e237d..6df10c24ae02 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/port.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/port.c
@@ -797,3 +797,60 @@ void mlx5_query_port_fcs(struct mlx5_core_dev *mdev, bool *supported,
 	*supported = !!(MLX5_GET(pcmr_reg, out, fcs_cap));
 	*enabled = !!(MLX5_GET(pcmr_reg, out, fcs_chk));
 }
+
+static const char *mlx5_pme_status[MLX5_MODULE_STATUS_NUM] = {
+	"Cable plugged",   /* MLX5_MODULE_STATUS_PLUGGED    = 0x1 */
+	"Cable unplugged", /* MLX5_MODULE_STATUS_UNPLUGGED  = 0x2 */
+	"Cable error",     /* MLX5_MODULE_STATUS_ERROR      = 0x3 */
+};
+
+static const char *mlx5_pme_error[MLX5_MODULE_EVENT_ERROR_NUM] = {
+	"Power budget exceeded",
+	"Long Range for non MLNX cable",
+	"Bus stuck(I2C or data shorted)",
+	"No EEPROM/retry timeout",
+	"Enforce part number list",
+	"Unknown identifier",
+	"High Temperature",
+	"Bad or shorted cable/module",
+	"Unknown status",
+};
+
+void mlx5_port_module_event(struct mlx5_core_dev *dev, struct mlx5_eqe *eqe)
+{
+	enum port_module_event_status_type module_status;
+	enum port_module_event_error_type error_type;
+	struct mlx5_eqe_port_module *module_event_eqe;
+	struct mlx5_priv *priv = &dev->priv;
+	u8 module_num;
+
+	module_event_eqe = &eqe->data.port_module;
+	module_num = module_event_eqe->module;
+	module_status = module_event_eqe->module_status &
+			PORT_MODULE_EVENT_MODULE_STATUS_MASK;
+	error_type = module_event_eqe->error_type &
+		     PORT_MODULE_EVENT_ERROR_TYPE_MASK;
+
+	if (module_status < MLX5_MODULE_STATUS_ERROR) {
+		priv->pme_stats.status_counters[module_status - 1]++;
+	} else if (module_status == MLX5_MODULE_STATUS_ERROR) {
+		if (error_type >= MLX5_MODULE_EVENT_ERROR_UNKNOWN)
+			/* Unknown error type */
+			error_type = MLX5_MODULE_EVENT_ERROR_UNKNOWN;
+		priv->pme_stats.error_counters[error_type]++;
+	}
+
+	if (!printk_ratelimit())
+		return;
+
+	if (module_status < MLX5_MODULE_STATUS_ERROR)
+		mlx5_core_info(dev,
+			       "Port module event: module %u, %s\n",
+			       module_num, mlx5_pme_status[module_status - 1]);
+
+	else if (module_status == MLX5_MODULE_STATUS_ERROR)
+		mlx5_core_info(dev,
+			       "Port module event[error]: module %u, %s, %s\n",
+			       module_num, mlx5_pme_status[module_status - 1],
+			       mlx5_pme_error[error_type]);
+}
* Unmerged path include/linux/mlx5/driver.h
