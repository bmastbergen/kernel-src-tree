scsi: replace "scsi_data_buffer" with "sg_table" in SG functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] replace "scsi_data_buffer" with "sg_table" in SG functions (David Milburn) [1384526 1389755 1366753 1374291 1383834]
Rebuild_FUZZ: 95.08%
commit-author Ming Lin <ming.l@ssi.samsung.com>
commit 91dbc08d64fba7c1426a32be4c57ebb63c4be124
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/91dbc08d.failed

Replace parameter "struct scsi_data_buffer" with "struct sg_table" in
SG alloc/free functions to make them generic.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Ming Lin <ming.l@ssi.samsung.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 91dbc08d64fba7c1426a32be4c57ebb63c4be124)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/scsi_lib.c
diff --cc drivers/scsi/scsi_lib.c
index f484f378d9a4,4229c183648b..000000000000
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@@ -594,15 -583,14 +594,19 @@@ static struct scatterlist *scsi_sg_allo
  	return mempool_alloc(sgp->pool, gfp_mask);
  }
  
- static void scsi_free_sgtable(struct scsi_data_buffer *sdb, bool mq)
+ static void scsi_free_sgtable(struct sg_table *table, bool mq)
  {
- 	if (mq && sdb->table.orig_nents <= SCSI_MAX_SG_SEGMENTS)
+ 	if (mq && table->orig_nents <= SCSI_MAX_SG_SEGMENTS)
  		return;
- 	__sg_free_table(&sdb->table, SCSI_MAX_SG_SEGMENTS, mq, scsi_sg_free);
+ 	__sg_free_table(table, SCSI_MAX_SG_SEGMENTS, mq, scsi_sg_free);
  }
  
++<<<<<<< HEAD
 +static int scsi_alloc_sgtable(struct scsi_data_buffer *sdb, int nents,
 +			      gfp_t gfp_mask, bool mq)
++=======
+ static int scsi_alloc_sgtable(struct sg_table *table, int nents, bool mq)
++>>>>>>> 91dbc08d64fb (scsi: replace "scsi_data_buffer" with "sg_table" in SG functions)
  {
  	struct scatterlist *first_chunk = NULL;
  	int ret;
@@@ -611,17 -599,17 +615,22 @@@
  
  	if (mq) {
  		if (nents <= SCSI_MAX_SG_SEGMENTS) {
- 			sdb->table.nents = sdb->table.orig_nents = nents;
- 			sg_init_table(sdb->table.sgl, nents);
+ 			table->nents = table->orig_nents = nents;
+ 			sg_init_table(table->sgl, nents);
  			return 0;
  		}
- 		first_chunk = sdb->table.sgl;
+ 		first_chunk = table->sgl;
  	}
  
++<<<<<<< HEAD
 +	ret = __sg_alloc_table(&sdb->table, nents, SCSI_MAX_SG_SEGMENTS,
 +			       first_chunk, gfp_mask, scsi_sg_alloc);
++=======
+ 	ret = __sg_alloc_table(table, nents, SCSI_MAX_SG_SEGMENTS,
+ 			       first_chunk, GFP_ATOMIC, scsi_sg_alloc);
++>>>>>>> 91dbc08d64fb (scsi: replace "scsi_data_buffer" with "sg_table" in SG functions)
  	if (unlikely(ret))
- 		scsi_free_sgtable(sdb, mq);
+ 		scsi_free_sgtable(table, mq);
  	return ret;
  }
  
@@@ -678,17 -671,16 +692,17 @@@ static void scsi_mq_uninit_cmd(struct s
   *		the __init_io() function.  Primarily this would involve
   *		the scatter-gather table.
   */
 -static void scsi_release_buffers(struct scsi_cmnd *cmd)
 +void scsi_release_buffers(struct scsi_cmnd *cmd)
  {
  	if (cmd->sdb.table.nents)
- 		scsi_free_sgtable(&cmd->sdb, false);
+ 		scsi_free_sgtable(&cmd->sdb.table, false);
  
  	memset(&cmd->sdb, 0, sizeof(cmd->sdb));
  
  	if (scsi_prot_sg_count(cmd))
- 		scsi_free_sgtable(cmd->prot_sdb, false);
+ 		scsi_free_sgtable(&cmd->prot_sdb->table, false);
  }
 +EXPORT_SYMBOL(scsi_release_buffers);
  
  static void scsi_release_bidi_buffers(struct scsi_cmnd *cmd)
  {
@@@ -1101,12 -1090,10 +1115,17 @@@ static int scsi_init_sgtable(struct req
  	/*
  	 * If sg table allocation fails, requeue request later.
  	 */
++<<<<<<< HEAD
 +	if (unlikely(scsi_alloc_sgtable(sdb, req->nr_phys_segments,
 +					gfp_mask, req->mq_ctx != NULL)))
++=======
+ 	if (unlikely(scsi_alloc_sgtable(&sdb->table, req->nr_phys_segments,
+ 					req->mq_ctx != NULL)))
++>>>>>>> 91dbc08d64fb (scsi: replace "scsi_data_buffer" with "sg_table" in SG functions)
  		return BLKPREP_DEFER;
  
 +	req->buffer = NULL;
 +
  	/* 
  	 * Next, walk the list, and fill in the addresses and sizes of
  	 * each segment.
@@@ -1177,7 -1163,7 +1196,11 @@@ int scsi_init_io(struct scsi_cmnd *cmd
  
  		ivecs = blk_rq_count_integrity_sg(rq->q, rq->bio);
  
++<<<<<<< HEAD
 +		if (scsi_alloc_sgtable(prot_sdb, ivecs, gfp_mask, is_mq)) {
++=======
+ 		if (scsi_alloc_sgtable(&prot_sdb->table, ivecs, is_mq)) {
++>>>>>>> 91dbc08d64fb (scsi: replace "scsi_data_buffer" with "sg_table" in SG functions)
  			error = BLKPREP_DEFER;
  			goto err_exit;
  		}
* Unmerged path drivers/scsi/scsi_lib.c
