SUNRPC: Change TCP socket space reservation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 637600f3ffbf1af0c2efd5587ac357b900c4c999
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/637600f3.failed

The current server rpc tcp code attempts to predict how much writeable
socket space will be available to a given RPC call before accepting it
for processing.  On a 40GigE network, we've found this throttles
individual clients long before the network or disk is saturated.  The
server may handle more clients easily, but the bandwidth of individual
clients is still artificially limited.

Instead of trying (and failing) to predict how much writeable socket space
will be available to the RPC call, just fall back to the simple model of
deferring processing until the socket is uncongested.

This may increase the risk of fast clients starving slower clients; in
such cases, the previous patch allows setting a hard per-connection
limit.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 637600f3ffbf1af0c2efd5587ac357b900c4c999)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/svcsock.c
diff --cc net/sunrpc/svcsock.c
index a3ebe6c6b21b,bc3ef0734f2f..000000000000
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@@ -472,33 -435,7 +470,37 @@@ static int svc_tcp_has_wspace(struct sv
  
  	if (test_bit(XPT_LISTENER, &xprt->xpt_flags))
  		return 1;
++<<<<<<< HEAD
 +	required = atomic_read(&xprt->xpt_reserved) + serv->sv_max_mesg;
 +	if (sk_stream_wspace(svsk->sk_sk) >= required ||
 +	    (sk_stream_min_wspace(svsk->sk_sk) == 0 &&
 +	     atomic_read(&xprt->xpt_reserved) == 0))
 +		return 1;
 +	set_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);
 +	return 0;
 +}
 +
 +static void svc_tcp_write_space(struct sock *sk)
 +{
 +	struct svc_sock *svsk = (struct svc_sock *)(sk->sk_user_data);
 +	struct socket *sock = sk->sk_socket;
 +
 +	if (!sk_stream_is_writeable(sk) || !sock)
 +		return;
 +	if (!svsk || svc_tcp_has_wspace(&svsk->sk_xprt))
 +		clear_bit(SOCK_NOSPACE, &sock->flags);
 +	svc_write_space(sk);
 +}
 +
 +static void svc_tcp_adjust_wspace(struct svc_xprt *xprt)
 +{
 +	struct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);
 +
 +	if (svc_tcp_has_wspace(xprt))
 +		clear_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);
++=======
+ 	return !test_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);
++>>>>>>> 637600f3ffbf (SUNRPC: Change TCP socket space reservation)
  }
  
  /*
@@@ -1359,8 -1279,8 +1360,13 @@@ static void svc_tcp_init(struct svc_soc
  	} else {
  		dprintk("setting up TCP socket for reading\n");
  		sk->sk_state_change = svc_tcp_state_change;
++<<<<<<< HEAD
 +		sk->sk_data_ready = svc_tcp_data_ready;
 +		sk->sk_write_space = svc_tcp_write_space;
++=======
+ 		sk->sk_data_ready = svc_data_ready;
+ 		sk->sk_write_space = svc_write_space;
++>>>>>>> 637600f3ffbf (SUNRPC: Change TCP socket space reservation)
  
  		svsk->sk_reclen = 0;
  		svsk->sk_tcplen = 0;
* Unmerged path net/sunrpc/svcsock.c
