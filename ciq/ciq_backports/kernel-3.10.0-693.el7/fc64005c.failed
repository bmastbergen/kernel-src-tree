don't bother with ->d_inode->i_sb - it's always equal to ->d_sb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit fc64005c93090c052637f63578d810b037abb1a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fc64005c.failed

... and neither can ever be NULL

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit fc64005c93090c052637f63578d810b037abb1a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/9p/vfs_inode.c
#	fs/btrfs/tree-log.c
#	fs/efs/namei.c
#	fs/exofs/super.c
#	fs/ext2/namei.c
#	fs/ext4/namei.c
#	fs/f2fs/namei.c
#	fs/gfs2/ops_fstype.c
#	fs/gfs2/super.c
#	fs/jffs2/dir.c
#	fs/jffs2/super.c
#	fs/jfs/namei.c
#	fs/namei.c
#	fs/nfs/direct.c
#	fs/nfsd/nfs3proc.c
#	fs/nfsd/nfs3xdr.c
#	fs/nfsd/nfsfh.c
#	fs/nilfs2/namei.c
#	fs/ocfs2/file.c
#	fs/udf/namei.c
#	fs/ufs/super.c
#	include/trace/events/ext4.h
#	kernel/audit_watch.c
#	security/integrity/evm/evm_main.c
#	security/selinux/hooks.c
#	security/smack/smack_lsm.c
diff --cc fs/9p/vfs_inode.c
index c05c0a842783,f4645c515262..000000000000
--- a/fs/9p/vfs_inode.c
+++ b/fs/9p/vfs_inode.c
@@@ -1074,8 -1071,8 +1074,13 @@@ v9fs_vfs_getattr(struct vfsmount *mnt, 
  	if (IS_ERR(st))
  		return PTR_ERR(st);
  
++<<<<<<< HEAD
 +	v9fs_stat2inode(st, dentry->d_inode, dentry->d_inode->i_sb);
 +	generic_fillattr(dentry->d_inode, stat);
++=======
+ 	v9fs_stat2inode(st, d_inode(dentry), dentry->d_sb);
+ 	generic_fillattr(d_inode(dentry), stat);
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  
  	p9stat_free(st);
  	kfree(st);
diff --cc fs/btrfs/tree-log.c
index 733bdf74f2c8,a82e20ecbee1..000000000000
--- a/fs/btrfs/tree-log.c
+++ b/fs/btrfs/tree-log.c
@@@ -4792,9 -4851,9 +4792,13 @@@ static noinline int check_parent_dirs_f
  			goto out;
  
  	if (!S_ISDIR(inode->i_mode)) {
++<<<<<<< HEAD
 +		if (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)
++=======
+ 		if (!parent || d_really_is_negative(parent) || sb != parent->d_sb)
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  			goto out;
 -		inode = d_inode(parent);
 +		inode = parent->d_inode;
  	}
  
  	while (1) {
@@@ -4820,7 -4872,7 +4824,11 @@@
  			break;
  		}
  
++<<<<<<< HEAD
 +		if (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)
++=======
+ 		if (!parent || d_really_is_negative(parent) || sb != parent->d_sb)
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  			break;
  
  		if (IS_ROOT(parent))
@@@ -5227,10 -5285,10 +5235,14 @@@ static int btrfs_log_inode_parent(struc
  	}
  
  	while (1) {
++<<<<<<< HEAD
 +		if (!parent || !parent->d_inode || sb != parent->d_inode->i_sb)
++=======
+ 		if (!parent || d_really_is_negative(parent) || sb != parent->d_sb)
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  			break;
  
 -		inode = d_inode(parent);
 +		inode = parent->d_inode;
  		if (root != BTRFS_I(inode)->root)
  			break;
  
diff --cc fs/efs/namei.c
index 96f66d213a19,d34a40edcdb2..000000000000
--- a/fs/efs/namei.c
+++ b/fs/efs/namei.c
@@@ -108,9 -111,9 +108,13 @@@ struct dentry *efs_get_parent(struct de
  	struct dentry *parent = ERR_PTR(-ENOENT);
  	efs_ino_t ino;
  
 -	ino = efs_find_entry(d_inode(child), "..", 2);
 +	ino = efs_find_entry(child->d_inode, "..", 2);
  	if (ino)
++<<<<<<< HEAD
 +		parent = d_obtain_alias(efs_iget(child->d_inode->i_sb, ino));
++=======
+ 		parent = d_obtain_alias(efs_iget(child->d_sb, ino));
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  
  	return parent;
  }
diff --cc fs/exofs/super.c
index 9d9763328734,192373653dfb..000000000000
--- a/fs/exofs/super.c
+++ b/fs/exofs/super.c
@@@ -958,7 -958,7 +958,11 @@@ static struct dentry *exofs_get_parent(
  	if (!ino)
  		return ERR_PTR(-ESTALE);
  
++<<<<<<< HEAD
 +	return d_obtain_alias(exofs_iget(child->d_inode->i_sb, ino));
++=======
+ 	return d_obtain_alias(exofs_iget(child->d_sb, ino));
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  }
  
  static struct inode *exofs_nfs_get_inode(struct super_block *sb,
diff --cc fs/ext2/namei.c
index b4dfbbe2f211,1a7eb49a115d..000000000000
--- a/fs/ext2/namei.c
+++ b/fs/ext2/namei.c
@@@ -79,10 -79,10 +79,14 @@@ static struct dentry *ext2_lookup(struc
  struct dentry *ext2_get_parent(struct dentry *child)
  {
  	struct qstr dotdot = QSTR_INIT("..", 2);
 -	unsigned long ino = ext2_inode_by_name(d_inode(child), &dotdot);
 +	unsigned long ino = ext2_inode_by_name(child->d_inode, &dotdot);
  	if (!ino)
  		return ERR_PTR(-ENOENT);
++<<<<<<< HEAD
 +	return d_obtain_alias(ext2_iget(child->d_inode->i_sb, ino));
++=======
+ 	return d_obtain_alias(ext2_iget(child->d_sb, ino));
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  } 
  
  /*
diff --cc fs/ext4/namei.c
index 0738842d53b3,5611ec9348d7..000000000000
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@@ -1461,13 -1638,13 +1461,22 @@@ struct dentry *ext4_get_parent(struct d
  	ino = le32_to_cpu(de->inode);
  	brelse(bh);
  
++<<<<<<< HEAD
 +	if (!ext4_valid_inum(child->d_inode->i_sb, ino)) {
 +		EXT4_ERROR_INODE(child->d_inode,
++=======
+ 	if (!ext4_valid_inum(child->d_sb, ino)) {
+ 		EXT4_ERROR_INODE(d_inode(child),
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  				 "bad parent inode number: %u", ino);
 -		return ERR_PTR(-EFSCORRUPTED);
 +		return ERR_PTR(-EIO);
  	}
  
++<<<<<<< HEAD
 +	return d_obtain_alias(ext4_iget_normal(child->d_inode->i_sb, ino));
++=======
+ 	return d_obtain_alias(ext4_iget_normal(child->d_sb, ino));
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  }
  
  /*
diff --cc fs/f2fs/namei.c
index 47abc9722b17,db874ad3514a..000000000000
--- a/fs/f2fs/namei.c
+++ b/fs/f2fs/namei.c
@@@ -200,10 -199,57 +200,61 @@@ out
  struct dentry *f2fs_get_parent(struct dentry *child)
  {
  	struct qstr dotdot = QSTR_INIT("..", 2);
 -	unsigned long ino = f2fs_inode_by_name(d_inode(child), &dotdot);
 +	unsigned long ino = f2fs_inode_by_name(child->d_inode, &dotdot);
  	if (!ino)
  		return ERR_PTR(-ENOENT);
++<<<<<<< HEAD
 +	return d_obtain_alias(f2fs_iget(child->d_inode->i_sb, ino));
++=======
+ 	return d_obtain_alias(f2fs_iget(child->d_sb, ino));
+ }
+ 
+ static int __recover_dot_dentries(struct inode *dir, nid_t pino)
+ {
+ 	struct f2fs_sb_info *sbi = F2FS_I_SB(dir);
+ 	struct qstr dot = QSTR_INIT(".", 1);
+ 	struct qstr dotdot = QSTR_INIT("..", 2);
+ 	struct f2fs_dir_entry *de;
+ 	struct page *page;
+ 	int err = 0;
+ 
+ 	if (f2fs_readonly(sbi->sb)) {
+ 		f2fs_msg(sbi->sb, KERN_INFO,
+ 			"skip recovering inline_dots inode (ino:%lu, pino:%u) "
+ 			"in readonly mountpoint", dir->i_ino, pino);
+ 		return 0;
+ 	}
+ 
+ 	f2fs_balance_fs(sbi, true);
+ 
+ 	f2fs_lock_op(sbi);
+ 
+ 	de = f2fs_find_entry(dir, &dot, &page);
+ 	if (de) {
+ 		f2fs_dentry_kunmap(dir, page);
+ 		f2fs_put_page(page, 0);
+ 	} else {
+ 		err = __f2fs_add_link(dir, &dot, NULL, dir->i_ino, S_IFDIR);
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ 	de = f2fs_find_entry(dir, &dotdot, &page);
+ 	if (de) {
+ 		f2fs_dentry_kunmap(dir, page);
+ 		f2fs_put_page(page, 0);
+ 	} else {
+ 		err = __f2fs_add_link(dir, &dotdot, NULL, pino, S_IFDIR);
+ 	}
+ out:
+ 	if (!err) {
+ 		clear_inode_flag(F2FS_I(dir), FI_INLINE_DOTS);
+ 		mark_inode_dirty(dir);
+ 	}
+ 
+ 	f2fs_unlock_op(sbi);
+ 	return err;
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  }
  
  static struct dentry *f2fs_lookup(struct inode *dir, struct dentry *dentry,
diff --cc fs/gfs2/ops_fstype.c
index 6a2d89c05bf8,c09c63dcd7a2..000000000000
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@@ -1398,10 -1360,10 +1398,14 @@@ static struct dentry *gfs2_mount_meta(s
  		return ERR_PTR(error);
  	}
  	s = sget(&gfs2_fs_type, test_gfs2_super, set_meta_super, flags,
++<<<<<<< HEAD
 +		 path.dentry->d_inode->i_sb->s_bdev);
++=======
+ 		 path.dentry->d_sb->s_bdev);
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  	path_put(&path);
  	if (IS_ERR(s)) {
 -		pr_warn("gfs2 mount does not exist\n");
 +		printk(KERN_WARNING "GFS2: gfs2 mount does not exist\n");
  		return ERR_CAST(s);
  	}
  	if ((flags ^ s->s_flags) & MS_RDONLY) {
diff --cc fs/gfs2/super.c
index e88f9229419d,9b2ff353e45f..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1136,7 -1176,7 +1136,11 @@@ static int gfs2_statfs_i(struct gfs2_sb
  
  static int gfs2_statfs(struct dentry *dentry, struct kstatfs *buf)
  {
++<<<<<<< HEAD
 +	struct super_block *sb = dentry->d_inode->i_sb;
++=======
+ 	struct super_block *sb = dentry->d_sb;
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  	struct gfs2_sbd *sdp = sb->s_fs_info;
  	struct gfs2_statfs_change_host sc;
  	int error;
diff --cc fs/jffs2/dir.c
index acd46a4160cb,7a9579e03dbb..000000000000
--- a/fs/jffs2/dir.c
+++ b/fs/jffs2/dir.c
@@@ -260,8 -241,8 +260,13 @@@ static int jffs2_unlink(struct inode *d
  
  static int jffs2_link (struct dentry *old_dentry, struct inode *dir_i, struct dentry *dentry)
  {
++<<<<<<< HEAD
 +	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dentry->d_inode->i_sb);
 +	struct jffs2_inode_info *f = JFFS2_INODE_INFO(old_dentry->d_inode);
++=======
+ 	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dentry->d_sb);
+ 	struct jffs2_inode_info *f = JFFS2_INODE_INFO(d_inode(old_dentry));
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  	struct jffs2_inode_info *dir_f = JFFS2_INODE_INFO(dir_i);
  	int ret;
  	uint8_t type;
diff --cc fs/jffs2/super.c
index 0defb1cc2a35,5ef21f4c4c77..000000000000
--- a/fs/jffs2/super.c
+++ b/fs/jffs2/super.c
@@@ -147,7 -147,7 +147,11 @@@ static struct dentry *jffs2_get_parent(
  	JFFS2_DEBUG("Parent of directory ino #%u is #%u\n",
  		    f->inocache->ino, pino);
  
++<<<<<<< HEAD
 +	return d_obtain_alias(jffs2_iget(child->d_inode->i_sb, pino));
++=======
+ 	return d_obtain_alias(jffs2_iget(child->d_sb, pino));
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  }
  
  static const struct export_operations jffs2_export_ops = {
diff --cc fs/jfs/namei.c
index 25e171702de6,8a40941ac9a6..000000000000
--- a/fs/jfs/namei.c
+++ b/fs/jfs/namei.c
@@@ -1502,9 -1522,9 +1502,13 @@@ struct dentry *jfs_get_parent(struct de
  	unsigned long parent_ino;
  
  	parent_ino =
 -		le32_to_cpu(JFS_IP(d_inode(dentry))->i_dtroot.header.idotdot);
 +		le32_to_cpu(JFS_IP(dentry->d_inode)->i_dtroot.header.idotdot);
  
++<<<<<<< HEAD
 +	return d_obtain_alias(jfs_iget(dentry->d_inode->i_sb, parent_ino));
++=======
+ 	return d_obtain_alias(jfs_iget(dentry->d_sb, parent_ino));
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  }
  
  const struct inode_operations jfs_dir_inode_operations = {
diff --cc fs/namei.c
index 5ce79acbacb6,c0d551fc43a0..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -2647,12 -2676,14 +2647,17 @@@ struct dentry *lock_rename(struct dentr
  
  void unlock_rename(struct dentry *p1, struct dentry *p2)
  {
 -	inode_unlock(p1->d_inode);
 +	mutex_unlock(&p1->d_inode->i_mutex);
  	if (p1 != p2) {
++<<<<<<< HEAD
 +		mutex_unlock(&p2->d_inode->i_mutex);
 +		mutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);
++=======
+ 		inode_unlock(p2->d_inode);
+ 		mutex_unlock(&p1->d_sb->s_vfs_rename_mutex);
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  	}
  }
 -EXPORT_SYMBOL(unlock_rename);
  
  int vfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
  		bool want_excl)
diff --cc fs/nfs/direct.c
index 07e5f6823c61,e5daa932b823..000000000000
--- a/fs/nfs/direct.c
+++ b/fs/nfs/direct.c
@@@ -400,8 -396,8 +400,13 @@@ static void nfs_direct_complete(struct 
  static void nfs_direct_readpage_release(struct nfs_page *req)
  {
  	dprintk("NFS: direct read done (%s/%llu %d@%lld)\n",
++<<<<<<< HEAD
 +		req->wb_context->dentry->d_inode->i_sb->s_id,
 +		(unsigned long long)NFS_FILEID(req->wb_context->dentry->d_inode),
++=======
+ 		req->wb_context->dentry->d_sb->s_id,
+ 		(unsigned long long)NFS_FILEID(d_inode(req->wb_context->dentry)),
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  		req->wb_bytes,
  		(long long)req_offset(req));
  	nfs_release_request(req);
diff --cc fs/nfsd/nfs3proc.c
index 88afc45fdeb9,d818e4ffd79f..000000000000
--- a/fs/nfsd/nfs3proc.c
+++ b/fs/nfsd/nfs3proc.c
@@@ -552,7 -552,7 +552,11 @@@ nfsd3_proc_fsinfo(struct svc_rqst * rqs
  	 * different read/write sizes for file systems known to have
  	 * problems with large blocks */
  	if (nfserr == 0) {
++<<<<<<< HEAD
 +		struct super_block *sb = argp->fh.fh_dentry->d_inode->i_sb;
++=======
+ 		struct super_block *sb = argp->fh.fh_dentry->d_sb;
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  
  		/* Note that we don't care for remote fs's here */
  		if (sb->s_magic == MSDOS_SUPER_MAGIC) {
@@@ -588,7 -588,7 +592,11 @@@ nfsd3_proc_pathconf(struct svc_rqst * r
  	nfserr = fh_verify(rqstp, &argp->fh, 0, NFSD_MAY_NOP);
  
  	if (nfserr == 0) {
++<<<<<<< HEAD
 +		struct super_block *sb = argp->fh.fh_dentry->d_inode->i_sb;
++=======
+ 		struct super_block *sb = argp->fh.fh_dentry->d_sb;
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  
  		/* Note that we don't care for remote fs's here */
  		switch (sb->s_magic) {
diff --cc fs/nfsd/nfs3xdr.c
index c93fef3a1bd6,93d5853f8c99..000000000000
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@@ -146,7 -146,7 +146,11 @@@ static __be32 *encode_fsid(__be32 *p, s
  	default:
  	case FSIDSOURCE_DEV:
  		p = xdr_encode_hyper(p, (u64)huge_encode_dev
++<<<<<<< HEAD
 +				     (fhp->fh_dentry->d_inode->i_sb->s_dev));
++=======
+ 				     (fhp->fh_dentry->d_sb->s_dev));
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  		break;
  	case FSIDSOURCE_FSID:
  		p = xdr_encode_hyper(p, (u64) fhp->fh_export->ex_fsid);
diff --cc fs/nfsd/nfsfh.c
index 165f56f78802,a8919444c460..000000000000
--- a/fs/nfsd/nfsfh.c
+++ b/fs/nfsd/nfsfh.c
@@@ -426,7 -426,7 +426,11 @@@ static bool is_root_export(struct svc_e
  
  static struct super_block *exp_sb(struct svc_export *exp)
  {
++<<<<<<< HEAD
 +	return exp->ex_path.dentry->d_inode->i_sb;
++=======
+ 	return exp->ex_path.dentry->d_sb;
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  }
  
  static bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)
diff --cc fs/nilfs2/namei.c
index 9de78f08989e,38d67f3e25bc..000000000000
--- a/fs/nilfs2/namei.c
+++ b/fs/nilfs2/namei.c
@@@ -448,9 -455,9 +448,13 @@@ static struct dentry *nilfs_get_parent(
  	if (!ino)
  		return ERR_PTR(-ENOENT);
  
 -	root = NILFS_I(d_inode(child))->i_root;
 +	root = NILFS_I(child->d_inode)->i_root;
  
++<<<<<<< HEAD
 +	inode = nilfs_iget(child->d_inode->i_sb, root, ino);
++=======
+ 	inode = nilfs_iget(child->d_sb, root, ino);
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  	if (IS_ERR(inode))
  		return ERR_CAST(inode);
  
diff --cc fs/ocfs2/file.c
index 2bcf1677a59b,c6fdcbd46bba..000000000000
--- a/fs/ocfs2/file.c
+++ b/fs/ocfs2/file.c
@@@ -1253,8 -1289,8 +1253,13 @@@ int ocfs2_getattr(struct vfsmount *mnt
  		  struct dentry *dentry,
  		  struct kstat *stat)
  {
++<<<<<<< HEAD
 +	struct inode *inode = dentry->d_inode;
 +	struct super_block *sb = dentry->d_inode->i_sb;
++=======
+ 	struct inode *inode = d_inode(dentry);
+ 	struct super_block *sb = dentry->d_sb;
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  	struct ocfs2_super *osb = sb->s_fs_info;
  	int err;
  
diff --cc fs/udf/namei.c
index 102c072c6bbf,c3e5c9679371..000000000000
--- a/fs/udf/namei.c
+++ b/fs/udf/namei.c
@@@ -1205,13 -1250,11 +1205,19 @@@ static struct dentry *udf_get_parent(st
  	brelse(fibh.sbh);
  
  	tloc = lelb_to_cpu(cfi.icb.extLocation);
++<<<<<<< HEAD
 +	inode = udf_iget(child->d_inode->i_sb, &tloc);
 +	if (!inode)
 +		goto out_unlock;
++=======
+ 	inode = udf_iget(child->d_sb, &tloc);
+ 	if (IS_ERR(inode))
+ 		return ERR_CAST(inode);
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  
  	return d_obtain_alias(inode);
 +out_unlock:
 +	return ERR_PTR(-EACCES);
  }
  
  
diff --cc fs/ufs/super.c
index 329f2f53b7ed,f04ab232d08d..000000000000
--- a/fs/ufs/super.c
+++ b/fs/ufs/super.c
@@@ -149,10 -129,10 +149,14 @@@ static struct dentry *ufs_get_parent(st
  	struct qstr dot_dot = QSTR_INIT("..", 2);
  	ino_t ino;
  
 -	ino = ufs_inode_by_name(d_inode(child), &dot_dot);
 +	ino = ufs_inode_by_name(child->d_inode, &dot_dot);
  	if (!ino)
  		return ERR_PTR(-ENOENT);
++<<<<<<< HEAD
 +	return d_obtain_alias(ufs_iget(child->d_inode->i_sb, ino));
++=======
+ 	return d_obtain_alias(ufs_iget(child->d_sb, ino));
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  }
  
  static const struct export_operations ufs_export_ops = {
diff --cc include/trace/events/ext4.h
index 7b429f35fbff,09c71e9aaebf..000000000000
--- a/include/trace/events/ext4.h
+++ b/include/trace/events/ext4.h
@@@ -852,10 -872,10 +852,15 @@@ TRACE_EVENT(ext4_sync_file_enter
  	TP_fast_assign(
  		struct dentry *dentry = file->f_path.dentry;
  
++<<<<<<< HEAD
 +		__entry->dev		= dentry->d_inode->i_sb->s_dev;
 +		__entry->ino		= dentry->d_inode->i_ino;
++=======
+ 		__entry->dev		= dentry->d_sb->s_dev;
+ 		__entry->ino		= d_inode(dentry)->i_ino;
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  		__entry->datasync	= datasync;
 -		__entry->parent		= d_inode(dentry->d_parent)->i_ino;
 +		__entry->parent		= dentry->d_parent->d_inode->i_ino;
  	),
  
  	TP_printk("dev %d,%d ino %lu parent %lu datasync %d ",
@@@ -1433,10 -1451,10 +1438,15 @@@ TRACE_EVENT(ext4_unlink_enter
  	),
  
  	TP_fast_assign(
++<<<<<<< HEAD
 +		__entry->dev		= dentry->d_inode->i_sb->s_dev;
 +		__entry->ino		= dentry->d_inode->i_ino;
++=======
+ 		__entry->dev		= dentry->d_sb->s_dev;
+ 		__entry->ino		= d_inode(dentry)->i_ino;
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  		__entry->parent		= parent->i_ino;
 -		__entry->size		= d_inode(dentry)->i_size;
 +		__entry->size		= dentry->d_inode->i_size;
  	),
  
  	TP_printk("dev %d,%d ino %lu size %lld parent %lu",
@@@ -1457,8 -1475,8 +1467,13 @@@ TRACE_EVENT(ext4_unlink_exit
  	),
  
  	TP_fast_assign(
++<<<<<<< HEAD
 +		__entry->dev		= dentry->d_inode->i_sb->s_dev;
 +		__entry->ino		= dentry->d_inode->i_ino;
++=======
+ 		__entry->dev		= dentry->d_sb->s_dev;
+ 		__entry->ino		= d_inode(dentry)->i_ino;
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  		__entry->ret		= ret;
  	),
  
diff --cc kernel/audit_watch.c
index 4e6869e3e688,d6709eb70970..000000000000
--- a/kernel/audit_watch.c
+++ b/kernel/audit_watch.c
@@@ -364,11 -364,11 +364,16 @@@ static int audit_get_nd(struct audit_wa
  	struct dentry *d = kern_path_locked(watch->path, parent);
  	if (IS_ERR(d))
  		return PTR_ERR(d);
 -	inode_unlock(d_backing_inode(parent->dentry));
 -	if (d_is_positive(d)) {
 +	mutex_unlock(&parent->dentry->d_inode->i_mutex);
 +	if (d->d_inode) {
  		/* update watch filter fields */
++<<<<<<< HEAD
 +		watch->dev = d->d_inode->i_sb->s_dev;
 +		watch->ino = d->d_inode->i_ino;
++=======
+ 		watch->dev = d->d_sb->s_dev;
+ 		watch->ino = d_backing_inode(d)->i_ino;
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  	}
  	dput(d);
  	return 0;
diff --cc security/integrity/evm/evm_main.c
index 3315414a64e2,84c6d11fc096..000000000000
--- a/security/integrity/evm/evm_main.c
+++ b/security/integrity/evm/evm_main.c
@@@ -262,9 -288,33 +262,36 @@@ static int evm_protect_xattr(struct den
  		if ((evm_status == INTEGRITY_PASS) ||
  		    (evm_status == INTEGRITY_NOXATTRS))
  			return 0;
 -		goto out;
 +		return -EPERM;
  	}
  	evm_status = evm_verify_current_integrity(dentry);
++<<<<<<< HEAD
++=======
+ 	if (evm_status == INTEGRITY_NOXATTRS) {
+ 		struct integrity_iint_cache *iint;
+ 
+ 		iint = integrity_iint_find(d_backing_inode(dentry));
+ 		if (iint && (iint->flags & IMA_NEW_FILE))
+ 			return 0;
+ 
+ 		/* exception for pseudo filesystems */
+ 		if (dentry->d_sb->s_magic == TMPFS_MAGIC
+ 		    || dentry->d_sb->s_magic == SYSFS_MAGIC)
+ 			return 0;
+ 
+ 		integrity_audit_msg(AUDIT_INTEGRITY_METADATA,
+ 				    dentry->d_inode, dentry->d_name.name,
+ 				    "update_metadata",
+ 				    integrity_status_msg[evm_status],
+ 				    -EPERM, 0);
+ 	}
+ out:
+ 	if (evm_status != INTEGRITY_PASS)
+ 		integrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),
+ 				    dentry->d_name.name, "appraise_metadata",
+ 				    integrity_status_msg[evm_status],
+ 				    -EPERM, 0);
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  	return evm_status == INTEGRITY_PASS ? 0 : -EPERM;
  }
  
diff --cc security/selinux/hooks.c
index 2e8d9da677e0,889cd59ca5a7..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -1200,12 -1310,13 +1200,16 @@@ static inline u16 socket_type_to_securi
  	return SECCLASS_SOCKET;
  }
  
 -static int selinux_genfs_get_sid(struct dentry *dentry,
 -				 u16 tclass,
 -				 u16 flags,
 -				 u32 *sid)
 +#ifdef CONFIG_PROC_FS
 +static int selinux_proc_get_sid(struct dentry *dentry,
 +				u16 tclass,
 +				u32 *sid)
  {
  	int rc;
++<<<<<<< HEAD
++=======
+ 	struct super_block *sb = dentry->d_sb;
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  	char *buffer, *path;
  
  	buffer = (char *)__get_free_page(GFP_KERNEL);
diff --cc security/smack/smack_lsm.c
index 3af62fbedea0,50bcca26c0b7..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -932,18 -1426,36 +932,38 @@@ static int smack_inode_removexattr(stru
  	} else
  		rc = cap_inode_removexattr(dentry, name);
  
 -	if (rc != 0)
 -		return rc;
 -
  	smk_ad_init(&ad, __func__, LSM_AUDIT_DATA_DENTRY);
  	smk_ad_setfield_u_fs_path_dentry(&ad, dentry);
 +	if (rc == 0)
 +		rc = smk_curacc(smk_of_inode(dentry->d_inode), MAY_WRITE, &ad);
  
++<<<<<<< HEAD
 +	if (rc == 0) {
 +		isp = dentry->d_inode->i_security;
++=======
+ 	rc = smk_curacc(smk_of_inode(d_backing_inode(dentry)), MAY_WRITE, &ad);
+ 	rc = smk_bu_inode(d_backing_inode(dentry), MAY_WRITE, rc);
+ 	if (rc != 0)
+ 		return rc;
+ 
+ 	isp = d_backing_inode(dentry)->i_security;
+ 	/*
+ 	 * Don't do anything special for these.
+ 	 *	XATTR_NAME_SMACKIPIN
+ 	 *	XATTR_NAME_SMACKIPOUT
+ 	 */
+ 	if (strcmp(name, XATTR_NAME_SMACK) == 0) {
+ 		struct super_block *sbp = dentry->d_sb;
+ 		struct superblock_smack *sbsp = sbp->s_security;
+ 
+ 		isp->smk_inode = sbsp->smk_default;
+ 	} else if (strcmp(name, XATTR_NAME_SMACKEXEC) == 0)
++>>>>>>> fc64005c9309 (don't bother with ->d_inode->i_sb - it's always equal to ->d_sb)
  		isp->smk_task = NULL;
 -	else if (strcmp(name, XATTR_NAME_SMACKMMAP) == 0)
  		isp->smk_mmap = NULL;
 -	else if (strcmp(name, XATTR_NAME_SMACKTRANSMUTE) == 0)
 -		isp->smk_flags &= ~SMK_INODE_TRANSMUTE;
 +	}
  
 -	return 0;
 +	return rc;
  }
  
  /**
* Unmerged path fs/9p/vfs_inode.c
* Unmerged path fs/btrfs/tree-log.c
diff --git a/fs/cifs/cifs_dfs_ref.c b/fs/cifs/cifs_dfs_ref.c
index 61dccbcb756b..ec9dbbcca3b9 100644
--- a/fs/cifs/cifs_dfs_ref.c
+++ b/fs/cifs/cifs_dfs_ref.c
@@ -306,7 +306,7 @@ static struct vfsmount *cifs_dfs_do_automount(struct dentry *mntpt)
 	if (full_path == NULL)
 		goto cdda_exit;
 
-	cifs_sb = CIFS_SB(d_inode(mntpt)->i_sb);
+	cifs_sb = CIFS_SB(mntpt->d_sb);
 	tlink = cifs_sb_tlink(cifs_sb);
 	if (IS_ERR(tlink)) {
 		mnt = ERR_CAST(tlink);
diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c
index a8010b9f6d0c..8823e153c354 100644
--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -2439,8 +2439,7 @@ cifs_setattr_exit:
 int
 cifs_setattr(struct dentry *direntry, struct iattr *attrs)
 {
-	struct inode *inode = d_inode(direntry);
-	struct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);
+	struct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);
 	struct cifs_tcon *pTcon = cifs_sb_master_tcon(cifs_sb);
 
 	if (pTcon->unix_ext)
diff --git a/fs/cifs/readdir.c b/fs/cifs/readdir.c
index 20e4ad6993f3..21b460621a27 100644
--- a/fs/cifs/readdir.c
+++ b/fs/cifs/readdir.c
@@ -78,7 +78,7 @@ cifs_prime_dcache(struct dentry *parent, struct qstr *name,
 {
 	struct dentry *dentry, *alias;
 	struct inode *inode;
-	struct super_block *sb = d_inode(parent)->i_sb;
+	struct super_block *sb = parent->d_sb;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(sb);
 
 	cifs_dbg(FYI, "%s: for %s\n", __func__, name->name);
diff --git a/fs/cifs/xattr.c b/fs/cifs/xattr.c
index ff9e1f8b16a4..cd8be61c8bc3 100644
--- a/fs/cifs/xattr.c
+++ b/fs/cifs/xattr.c
@@ -52,9 +52,7 @@ int cifs_removexattr(struct dentry *direntry, const char *ea_name)
 		return -EIO;
 	if (d_really_is_negative(direntry))
 		return -EIO;
-	sb = d_inode(direntry)->i_sb;
-	if (sb == NULL)
-		return -EIO;
+	sb = direntry->d_sb;
 
 	cifs_sb = CIFS_SB(sb);
 	tlink = cifs_sb_tlink(cifs_sb);
@@ -113,9 +111,7 @@ int cifs_setxattr(struct dentry *direntry, const char *ea_name,
 		return -EIO;
 	if (d_really_is_negative(direntry))
 		return -EIO;
-	sb = d_inode(direntry)->i_sb;
-	if (sb == NULL)
-		return -EIO;
+	sb = direntry->d_sb;
 
 	cifs_sb = CIFS_SB(sb);
 	tlink = cifs_sb_tlink(cifs_sb);
@@ -248,9 +244,7 @@ ssize_t cifs_getxattr(struct dentry *direntry, const char *ea_name,
 		return -EIO;
 	if (d_really_is_negative(direntry))
 		return -EIO;
-	sb = d_inode(direntry)->i_sb;
-	if (sb == NULL)
-		return -EIO;
+	sb = direntry->d_sb;
 
 	cifs_sb = CIFS_SB(sb);
 	tlink = cifs_sb_tlink(cifs_sb);
@@ -384,9 +378,7 @@ ssize_t cifs_listxattr(struct dentry *direntry, char *data, size_t buf_size)
 		return -EIO;
 	if (d_really_is_negative(direntry))
 		return -EIO;
-	sb = d_inode(direntry)->i_sb;
-	if (sb == NULL)
-		return -EIO;
+	sb = direntry->d_sb;
 
 	cifs_sb = CIFS_SB(sb);
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)
* Unmerged path fs/efs/namei.c
* Unmerged path fs/exofs/super.c
* Unmerged path fs/ext2/namei.c
* Unmerged path fs/ext4/namei.c
* Unmerged path fs/f2fs/namei.c
* Unmerged path fs/gfs2/ops_fstype.c
* Unmerged path fs/gfs2/super.c
* Unmerged path fs/jffs2/dir.c
* Unmerged path fs/jffs2/super.c
* Unmerged path fs/jfs/namei.c
* Unmerged path fs/namei.c
* Unmerged path fs/nfs/direct.c
* Unmerged path fs/nfsd/nfs3proc.c
* Unmerged path fs/nfsd/nfs3xdr.c
* Unmerged path fs/nfsd/nfsfh.c
* Unmerged path fs/nilfs2/namei.c
* Unmerged path fs/ocfs2/file.c
* Unmerged path fs/udf/namei.c
* Unmerged path fs/ufs/super.c
* Unmerged path include/trace/events/ext4.h
* Unmerged path kernel/audit_watch.c
* Unmerged path security/integrity/evm/evm_main.c
* Unmerged path security/selinux/hooks.c
* Unmerged path security/smack/smack_lsm.c
