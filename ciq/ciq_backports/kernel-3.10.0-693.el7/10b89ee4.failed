net: move *skb_get_poff declarations into correct header

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] move *skb_get_poff declarations into correct header (Jonathan Toppins) [1428557]
Rebuild_FUZZ: 95.33%
commit-author Jiri Pirko <jiri@resnulli.us>
commit 10b89ee43e849544eddfe34e535341fc077464ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/10b89ee4.failed

Since these functions are defined in flow_dissector.c, move header
declarations from skbuff.h into flow_dissector.h

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 10b89ee43e849544eddfe34e535341fc077464ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	include/net/flow_keys.h
#	net/ethernet/eth.c
diff --cc include/linux/skbuff.h
index 449d0a455cd2,17607ab9e7a2..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -3530,9 -3419,10 +3530,16 @@@ static inline void skb_checksum_none_as
  
  bool skb_partial_csum_set(struct sk_buff *skb, u16 start, u16 off);
  
++<<<<<<< HEAD
 +u32 skb_get_poff(const struct sk_buff *skb);
 +u32 __skb_get_poff(const struct sk_buff *skb, void *data,
 +		   const struct flow_keys *keys, int hlen);
++=======
+ int skb_checksum_setup(struct sk_buff *skb, bool recalculate);
+ struct sk_buff *skb_checksum_trimmed(struct sk_buff *skb,
+ 				     unsigned int transport_len,
+ 				     __sum16(*skb_chkf)(struct sk_buff *skb));
++>>>>>>> 10b89ee43e84 (net: move *skb_get_poff declarations into correct header)
  
  /**
   * skb_head_is_locked - Determine if the skb->head is locked down
diff --cc include/net/flow_keys.h
index 7ee2df083542,4570ccafe59d..000000000000
--- a/include/net/flow_keys.h
+++ b/include/net/flow_keys.h
@@@ -39,7 -44,25 +39,29 @@@ static inline __be32 skb_flow_get_ports
  {
  	return __skb_flow_get_ports(skb, thoff, ip_proto, NULL, 0);
  }
 -
  u32 flow_hash_from_keys(struct flow_keys *keys);
++<<<<<<< HEAD:include/net/flow_keys.h
 +unsigned int flow_get_hlen(const unsigned char *data, unsigned int max_len,
 +			   __be16 protocol);
++=======
+ u32 skb_get_poff(const struct sk_buff *skb);
+ u32 __skb_get_poff(const struct sk_buff *skb, void *data,
+ 		   const struct flow_keys *keys, int hlen);
+ 
+ /* struct flow_keys_digest:
+  *
+  * This structure is used to hold a digest of the full flow keys. This is a
+  * larger "hash" of a flow to allow definitively matching specific flows where
+  * the 32 bit skb->hash is not large enough. The size is limited to 16 bytes so
+  * that it can by used in CB of skb (see sch_choke for an example).
+  */
+ #define FLOW_KEYS_DIGEST_LEN	16
+ struct flow_keys_digest {
+ 	u8	data[FLOW_KEYS_DIGEST_LEN];
+ };
+ 
+ void make_flow_keys_digest(struct flow_keys_digest *digest,
+ 			   const struct flow_keys *flow);
+ 
++>>>>>>> 10b89ee43e84 (net: move *skb_get_poff declarations into correct header):include/net/flow_dissector.h
  #endif
diff --cc net/ethernet/eth.c
index de86b55317f9,9332a0ab0698..000000000000
--- a/net/ethernet/eth.c
+++ b/net/ethernet/eth.c
@@@ -62,7 -58,8 +62,12 @@@
  #include <net/ipv6.h>
  #include <net/ip.h>
  #include <net/dsa.h>
++<<<<<<< HEAD
 +#include <asm/uaccess.h>
++=======
+ #include <net/flow_dissector.h>
+ #include <linux/uaccess.h>
++>>>>>>> 10b89ee43e84 (net: move *skb_get_poff declarations into correct header)
  
  __setup("ether=", netdev_boot_setup);
  
* Unmerged path include/linux/skbuff.h
* Unmerged path include/net/flow_keys.h
diff --git a/net/core/filter.c b/net/core/filter.c
index f4124aee170e..18e6a12378b6 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -31,6 +31,7 @@
 #include <net/netlink.h>
 #include <linux/skbuff.h>
 #include <net/sock.h>
+#include <net/flow_dissector.h>
 #include <linux/errno.h>
 #include <linux/timer.h>
 #include <asm/uaccess.h>
* Unmerged path net/ethernet/eth.c
