NFSv4.1/pNFS: pnfs_error_mark_layout_for_return() must always return layout

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 10335556c9e6ed2e1949fb595b7775f475299832
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/10335556.failed

Fix a bug whereby if all the layout segments could be immediately freed,
the call to pnfs_error_mark_layout_for_return() would never result in
a layoutreturn.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 10335556c9e6ed2e1949fb595b7775f475299832)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pnfs.c
diff --cc fs/nfs/pnfs.c
index da07387a0367,8e1d4229bf2d..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -1734,7 -1758,17 +1734,21 @@@ out_forget_reply
  	goto out;
  }
  
++<<<<<<< HEAD
 +void
++=======
+ static void
+ pnfs_set_plh_return_iomode(struct pnfs_layout_hdr *lo, enum pnfs_iomode iomode)
+ {
+ 	if (lo->plh_return_iomode == iomode)
+ 		return;
+ 	if (lo->plh_return_iomode != 0)
+ 		iomode = IOMODE_ANY;
+ 	lo->plh_return_iomode = iomode;
+ }
+ 
+ int
++>>>>>>> 10335556c9e6 (NFSv4.1/pNFS: pnfs_error_mark_layout_for_return() must always return layout)
  pnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,
  				struct list_head *tmp_list,
  				struct pnfs_layout_range *return_range)
@@@ -1756,7 -1791,9 +1771,13 @@@
  				lseg->pls_range.offset,
  				lseg->pls_range.length);
  			set_bit(NFS_LSEG_LAYOUTRETURN, &lseg->pls_flags);
++<<<<<<< HEAD
 +			mark_lseg_invalid(lseg, tmp_list);
++=======
+ 			pnfs_set_plh_return_iomode(lo, return_range->iomode);
+ 			if (!mark_lseg_invalid(lseg, tmp_list))
+ 				remaining++;
++>>>>>>> 10335556c9e6 (NFSv4.1/pNFS: pnfs_error_mark_layout_for_return() must always return layout)
  			set_bit(NFS_LAYOUT_RETURN_BEFORE_CLOSE,
  					&lo->plh_flags);
  		}
@@@ -1772,12 -1811,12 +1794,13 @@@ void pnfs_error_mark_layout_for_return(
  		.length = NFS4_MAX_UINT64,
  	};
  	LIST_HEAD(free_me);
+ 	bool return_now = false;
  
  	spin_lock(&inode->i_lock);
 -	/* set failure bit so that pnfs path will be retried later */
 -	pnfs_layout_set_fail_bit(lo, iomode);
 -	pnfs_set_plh_return_iomode(lo, range.iomode);
 +	if (lo->plh_return_iomode == 0)
 +		lo->plh_return_iomode = range.iomode;
 +	else if (lo->plh_return_iomode != range.iomode)
 +		lo->plh_return_iomode = IOMODE_ANY;
  	/*
  	 * mark all matching lsegs so that we are sure to have no live
  	 * segments at hand when sending layoutreturn. See pnfs_put_lseg()
* Unmerged path fs/nfs/pnfs.c
diff --git a/fs/nfs/pnfs.h b/fs/nfs/pnfs.h
index d4e2833ede5a..577d547764af 100644
--- a/fs/nfs/pnfs.h
+++ b/fs/nfs/pnfs.h
@@ -265,7 +265,7 @@ int pnfs_choose_layoutget_stateid(nfs4_stateid *dst,
 int pnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,
 				struct list_head *tmp_list,
 				struct pnfs_layout_range *recall_range);
-void pnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,
+int pnfs_mark_matching_lsegs_return(struct pnfs_layout_hdr *lo,
 				struct list_head *tmp_list,
 				struct pnfs_layout_range *recall_range);
 bool pnfs_roc(struct inode *ino);
