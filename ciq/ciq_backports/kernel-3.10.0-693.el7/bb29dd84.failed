SUNRPC: Fix suspicious RCU usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Anna Schumaker <Anna.Schumaker@Netapp.com>
commit bb29dd84333a96f309c6d0f88b285b5b78927058
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/bb29dd84.failed

We need to hold the rcu_read_lock() when calling rcu_dereference(),
otherwise we can't guarantee that the object being dereferenced still
exists.

Fixes: 39e5d2df ("SUNRPC search xprt switch for sockaddr")
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit bb29dd84333a96f309c6d0f88b285b5b78927058)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/clnt.c
diff --cc net/sunrpc/clnt.c
index 97ad109c5915,62a482790937..000000000000
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@@ -2699,6 -2730,58 +2699,61 @@@ out_put_switch
  }
  EXPORT_SYMBOL_GPL(rpc_clnt_add_xprt);
  
++<<<<<<< HEAD
++=======
+ static int
+ rpc_xprt_cap_max_reconnect_timeout(struct rpc_clnt *clnt,
+ 		struct rpc_xprt *xprt,
+ 		void *data)
+ {
+ 	unsigned long timeout = *((unsigned long *)data);
+ 
+ 	if (timeout < xprt->max_reconnect_timeout)
+ 		xprt->max_reconnect_timeout = timeout;
+ 	return 0;
+ }
+ 
+ void
+ rpc_cap_max_reconnect_timeout(struct rpc_clnt *clnt, unsigned long timeo)
+ {
+ 	rpc_clnt_iterate_for_each_xprt(clnt,
+ 			rpc_xprt_cap_max_reconnect_timeout,
+ 			&timeo);
+ }
+ EXPORT_SYMBOL_GPL(rpc_cap_max_reconnect_timeout);
+ 
+ void rpc_clnt_xprt_switch_put(struct rpc_clnt *clnt)
+ {
+ 	rcu_read_lock();
+ 	xprt_switch_put(rcu_dereference(clnt->cl_xpi.xpi_xpswitch));
+ 	rcu_read_unlock();
+ }
+ EXPORT_SYMBOL_GPL(rpc_clnt_xprt_switch_put);
+ 
+ void rpc_clnt_xprt_switch_add_xprt(struct rpc_clnt *clnt, struct rpc_xprt *xprt)
+ {
+ 	rcu_read_lock();
+ 	rpc_xprt_switch_add_xprt(rcu_dereference(clnt->cl_xpi.xpi_xpswitch),
+ 				 xprt);
+ 	rcu_read_unlock();
+ }
+ EXPORT_SYMBOL_GPL(rpc_clnt_xprt_switch_add_xprt);
+ 
+ bool rpc_clnt_xprt_switch_has_addr(struct rpc_clnt *clnt,
+ 				   const struct sockaddr *sap)
+ {
+ 	struct rpc_xprt_switch *xps;
+ 	bool ret;
+ 
+ 	rcu_read_lock();
+ 	xps = rcu_dereference(clnt->cl_xpi.xpi_xpswitch);
+ 	ret = rpc_xprt_switch_has_addr(xps, sap);
+ 	rcu_read_unlock();
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(rpc_clnt_xprt_switch_has_addr);
+ 
++>>>>>>> bb29dd84333a (SUNRPC: Fix suspicious RCU usage)
  #if IS_ENABLED(CONFIG_SUNRPC_DEBUG)
  static void rpc_show_header(void)
  {
* Unmerged path net/sunrpc/clnt.c
