ptr_ring: fix race conditions when resizing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Michael S. Tsirkin <mst@redhat.com>
commit e71695307114335be1ed912f4a347396c2ed0e69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e7169530.failed

Resizing currently drops consumer lock.  This can cause entries to be
reordered, which isn't good in itself.  More importantly, consumer can
detect a false ring empty condition and block forever.

Further, nesting of consumer within producer lock is problematic for
tun, since it produces entries in a BH, which causes a lock order
reversal:

       CPU0                    CPU1
       ----                    ----
  consume:
  lock(&(&r->consumer_lock)->rlock);
                               resize:
                               local_irq_disable();
                               lock(&(&r->producer_lock)->rlock);
                               lock(&(&r->consumer_lock)->rlock);
  <Interrupt>
  produce:
  lock(&(&r->producer_lock)->rlock);

To fix, nest producer lock within consumer lock during resize,
and keep consumer lock during the whole swap operation.

	Reported-by: Dmitry Vyukov <dvyukov@google.com>
	Cc: stable@vger.kernel.org
	Cc: "David S. Miller" <davem@davemloft.net>
	Acked-by: Jason Wang <jasowang@redhat.com>
	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e71695307114335be1ed912f4a347396c2ed0e69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ptr_ring.h
diff --cc include/linux/ptr_ring.h
index d78b8b89c707,6c70444da3b9..000000000000
--- a/include/linux/ptr_ring.h
+++ b/include/linux/ptr_ring.h
@@@ -358,12 -367,7 +368,16 @@@ static inline int ptr_ring_resize(struc
  	void **old;
  	void *ptr;
  
++<<<<<<< HEAD
 +	if (!queue)
 +		return -ENOMEM;
 +
 +	spin_lock_irqsave(&(r)->producer_lock, flags);
 +
 +	while ((ptr = ptr_ring_consume(r)))
++=======
+ 	while ((ptr = __ptr_ring_consume(r)))
++>>>>>>> e71695307114 (ptr_ring: fix race conditions when resizing)
  		if (producer < size)
  			queue[producer++] = ptr;
  		else if (destroy)
@@@ -375,13 -379,88 +389,95 @@@
  	old = r->queue;
  	r->queue = queue;
  
++<<<<<<< HEAD
 +	spin_unlock_irqrestore(&(r)->producer_lock, flags);
++=======
+ 	return old;
+ }
+ 
+ /*
+  * Note: producer lock is nested within consumer lock, so if you
+  * resize you must make sure all uses nest correctly.
+  * In particular if you consume ring in interrupt or BH context, you must
+  * disable interrupts/BH when doing so.
+  */
+ static inline int ptr_ring_resize(struct ptr_ring *r, int size, gfp_t gfp,
+ 				  void (*destroy)(void *))
+ {
+ 	unsigned long flags;
+ 	void **queue = __ptr_ring_init_queue_alloc(size, gfp);
+ 	void **old;
+ 
+ 	if (!queue)
+ 		return -ENOMEM;
+ 
+ 	spin_lock_irqsave(&(r)->consumer_lock, flags);
+ 	spin_lock(&(r)->producer_lock);
+ 
+ 	old = __ptr_ring_swap_queue(r, queue, size, gfp, destroy);
+ 
+ 	spin_unlock(&(r)->producer_lock);
+ 	spin_unlock_irqrestore(&(r)->consumer_lock, flags);
++>>>>>>> e71695307114 (ptr_ring: fix race conditions when resizing)
  
  	kfree(old);
  
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Note: producer lock is nested within consumer lock, so if you
+  * resize you must make sure all uses nest correctly.
+  * In particular if you consume ring in interrupt or BH context, you must
+  * disable interrupts/BH when doing so.
+  */
+ static inline int ptr_ring_resize_multiple(struct ptr_ring **rings, int nrings,
+ 					   int size,
+ 					   gfp_t gfp, void (*destroy)(void *))
+ {
+ 	unsigned long flags;
+ 	void ***queues;
+ 	int i;
+ 
+ 	queues = kmalloc(nrings * sizeof *queues, gfp);
+ 	if (!queues)
+ 		goto noqueues;
+ 
+ 	for (i = 0; i < nrings; ++i) {
+ 		queues[i] = __ptr_ring_init_queue_alloc(size, gfp);
+ 		if (!queues[i])
+ 			goto nomem;
+ 	}
+ 
+ 	for (i = 0; i < nrings; ++i) {
+ 		spin_lock_irqsave(&(rings[i])->consumer_lock, flags);
+ 		spin_lock(&(rings[i])->producer_lock);
+ 		queues[i] = __ptr_ring_swap_queue(rings[i], queues[i],
+ 						  size, gfp, destroy);
+ 		spin_unlock(&(rings[i])->producer_lock);
+ 		spin_unlock_irqrestore(&(rings[i])->consumer_lock, flags);
+ 	}
+ 
+ 	for (i = 0; i < nrings; ++i)
+ 		kfree(queues[i]);
+ 
+ 	kfree(queues);
+ 
+ 	return 0;
+ 
+ nomem:
+ 	while (--i >= 0)
+ 		kfree(queues[i]);
+ 
+ 	kfree(queues);
+ 
+ noqueues:
+ 	return -ENOMEM;
+ }
+ 
++>>>>>>> e71695307114 (ptr_ring: fix race conditions when resizing)
  static inline void ptr_ring_cleanup(struct ptr_ring *r, void (*destroy)(void *))
  {
  	void *ptr;
* Unmerged path include/linux/ptr_ring.h
