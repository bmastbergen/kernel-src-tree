powerpc: simplify csum_add(a, b) in case a or b is constant 0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [powerpc] simplify csum_add(a, b) in case a or b is constant 0 (Gustavo Duarte) [1430834]
Rebuild_FUZZ: 92.04%
commit-author Christophe Leroy <christophe.leroy@c-s.fr>
commit 5a8847c83ce6072d6fdf0d15d9aa060c0b83537f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5a8847c8.failed

Simplify csum_add(a, b) in case a or b is constant 0

	Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
	Signed-off-by: Scott Wood <oss@buserror.net>
(cherry picked from commit 5a8847c83ce6072d6fdf0d15d9aa060c0b83537f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/checksum.h
diff --cc arch/powerpc/include/asm/checksum.h
index 0ffd793cff0f,74cd8d82628a..000000000000
--- a/arch/powerpc/include/asm/checksum.h
+++ b/arch/powerpc/include/asm/checksum.h
@@@ -118,6 -102,78 +118,81 @@@ static inline __wsum csum_tcpudp_nofold
  #endif
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * computes the checksum of the TCP/UDP pseudo-header
+  * returns a 16-bit checksum, already complemented
+  */
+ static inline __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr,
+ 					unsigned short len,
+ 					unsigned short proto,
+ 					__wsum sum)
+ {
+ 	return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));
+ }
+ 
+ #define HAVE_ARCH_CSUM_ADD
+ static inline __wsum csum_add(__wsum csum, __wsum addend)
+ {
+ #ifdef __powerpc64__
+ 	u64 res = (__force u64)csum;
+ #endif
+ 	if (__builtin_constant_p(csum) && csum == 0)
+ 		return addend;
+ 	if (__builtin_constant_p(addend) && addend == 0)
+ 		return csum;
+ 
+ #ifdef __powerpc64__
+ 	res += (__force u64)addend;
+ 	return (__force __wsum)((u32)res + (res >> 32));
+ #else
+ 	asm("addc %0,%0,%1;"
+ 	    "addze %0,%0;"
+ 	    : "+r" (csum) : "r" (addend) : "xer");
+ 	return csum;
+ #endif
+ }
+ 
+ /*
+  * This is a version of ip_compute_csum() optimized for IP headers,
+  * which always checksum on 4 octet boundaries.  ihl is the number
+  * of 32-bit words and is always >= 5.
+  */
+ static inline __wsum ip_fast_csum_nofold(const void *iph, unsigned int ihl)
+ {
+ 	const u32 *ptr = (const u32 *)iph + 1;
+ #ifdef __powerpc64__
+ 	unsigned int i;
+ 	u64 s = *(const u32 *)iph;
+ 
+ 	for (i = 0; i < ihl - 1; i++, ptr++)
+ 		s += *ptr;
+ 	s += (s >> 32);
+ 	return (__force __wsum)s;
+ #else
+ 	__wsum sum, tmp;
+ 
+ 	asm("mtctr %3;"
+ 	    "addc %0,%4,%5;"
+ 	    "1: lwzu %1, 4(%2);"
+ 	    "adde %0,%0,%1;"
+ 	    "bdnz 1b;"
+ 	    "addze %0,%0;"
+ 	    : "=r" (sum), "=r" (tmp), "+b" (ptr)
+ 	    : "r" (ihl - 2), "r" (*(const u32 *)iph), "r" (*ptr)
+ 	    : "ctr", "xer", "memory");
+ 
+ 	return sum;
+ #endif
+ }
+ 
+ static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
+ {
+ 	return csum_fold(ip_fast_csum_nofold(iph, ihl));
+ }
+ 
++>>>>>>> 5a8847c83ce6 (powerpc: simplify csum_add(a, b) in case a or b is constant 0)
  #endif
  #endif /* __KERNEL__ */
  #endif
* Unmerged path arch/powerpc/include/asm/checksum.h
