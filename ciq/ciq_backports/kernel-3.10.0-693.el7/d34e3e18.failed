net: cls_u32: Add support for skip-sw flag to tc u32 classifier.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: cls_u32: Add support for skip-sw flag to tc u32 classifier. (Ivan Vecera) [1390693]
Rebuild_FUZZ: 95.38%
commit-author Samudrala, Sridhar <sridhar.samudrala@intel.com>
commit d34e3e181395192d6d1f50dd97bd7854e04e33a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d34e3e18.failed

On devices that support TC U32 offloads, this flag enables a filter to be
added only to HW. skip-sw and skip-hw are mutually exclusive flags. By
default without any flags, the filter is added to both HW and SW, but no
error checks are done in case of failure to add to HW. With skip-sw,
failure to add to HW is treated as an error.

Here is a sample script that adds 2 filters, one with skip-sw and the other
with skip-hw flag.

   # add ingress qdisc
   tc qdisc add dev p4p1 ingress

   # enable hw tc offload.
   ethtool -K p4p1 hw-tc-offload on

   # add u32 filter with skip-sw flag.
   tc filter add dev p4p1 parent ffff: protocol ip prio 99 \
      handle 800:0:1 u32 ht 800: flowid 800:1 \
      skip-sw \
      match ip src 192.168.1.0/24 \
      action drop

   # add u32 filter with skip-hw flag.
   tc filter add dev p4p1 parent ffff: protocol ip prio 99 \
      handle 800:0:2 u32 ht 800: flowid 800:2 \
      skip-hw \
      match ip src 192.168.2.0/24 \
      action drop

	Signed-off-by: Sridhar Samudrala <sridhar.samudrala@intel.com>
	Acked-by: John Fastabend <john.r.fastabend@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d34e3e181395192d6d1f50dd97bd7854e04e33a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/pkt_cls.h
#	include/uapi/linux/pkt_cls.h
#	net/sched/cls_u32.c
diff --cc include/net/pkt_cls.h
index b606c03c3836,8b4893878cf4..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -392,9 -392,49 +392,43 @@@ struct tc_cls_u32_offload 
  	};
  };
  
 -static inline bool tc_should_offload(struct net_device *dev, u32 flags)
 +static inline bool tc_should_offload(struct net_device *dev)
  {
 -	if (!(dev->features & NETIF_F_HW_TC))
 -		return false;
 -
 -	if (flags & TCA_CLS_FLAGS_SKIP_HW)
 -		return false;
 -
 -	if (!dev->netdev_ops->ndo_setup_tc)
 -		return false;
 -
 -	return true;
 +	return dev->netdev_ops->ndo_setup_tc;
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool tc_skip_sw(u32 flags)
+ {
+ 	return (flags & TCA_CLS_FLAGS_SKIP_SW) ? true : false;
+ }
+ 
+ /* SKIP_HW and SKIP_SW are mutually exclusive flags. */
+ static inline bool tc_flags_valid(u32 flags)
+ {
+ 	if (flags & ~(TCA_CLS_FLAGS_SKIP_HW | TCA_CLS_FLAGS_SKIP_SW))
+ 		return false;
+ 
+ 	if (!(flags ^ (TCA_CLS_FLAGS_SKIP_HW | TCA_CLS_FLAGS_SKIP_SW)))
+ 		return false;
+ 
+ 	return true;
+ }
+ 
+ enum tc_fl_command {
+ 	TC_CLSFLOWER_REPLACE,
+ 	TC_CLSFLOWER_DESTROY,
+ };
+ 
+ struct tc_cls_flower_offload {
+ 	enum tc_fl_command command;
+ 	unsigned long cookie;
+ 	struct flow_dissector *dissector;
+ 	struct fl_flow_key *mask;
+ 	struct fl_flow_key *key;
+ 	struct tcf_exts *exts;
+ };
+ 
++>>>>>>> d34e3e181395 (net: cls_u32: Add support for skip-sw flag to tc u32 classifier.)
  #endif
diff --cc include/uapi/linux/pkt_cls.h
index 3abfe7f00823,eba5914ba5d1..000000000000
--- a/include/uapi/linux/pkt_cls.h
+++ b/include/uapi/linux/pkt_cls.h
@@@ -171,6 -151,10 +171,13 @@@ enum 
  
  #define TCA_POLICE_MAX (__TCA_POLICE_MAX - 1)
  
++<<<<<<< HEAD
++=======
+ /* tca flags definitions */
+ #define TCA_CLS_FLAGS_SKIP_HW	(1 << 0)
+ #define TCA_CLS_FLAGS_SKIP_SW	(1 << 1)
+ 
++>>>>>>> d34e3e181395 (net: cls_u32: Add support for skip-sw flag to tc u32 classifier.)
  /* U32 filters */
  
  #define TC_U32_HTID(h) ((h)&0xFFF00000)
diff --cc net/sched/cls_u32.c
index 9fba35eb571c,079b43b3c5d2..000000000000
--- a/net/sched/cls_u32.c
+++ b/net/sched/cls_u32.c
@@@ -439,7 -448,9 +444,13 @@@ static void u32_remove_hw_knode(struct 
  	}
  }
  
++<<<<<<< HEAD
 +static void u32_replace_hw_hnode(struct tcf_proto *tp, struct tc_u_hnode *h)
++=======
+ static int u32_replace_hw_hnode(struct tcf_proto *tp,
+ 				 struct tc_u_hnode *h,
+ 				 u32 flags)
++>>>>>>> d34e3e181395 (net: cls_u32: Add support for skip-sw flag to tc u32 classifier.)
  {
  	struct net_device *dev = tp->q->dev_queue->dev;
  	struct tc_cls_u32_offload u32_offload = {0};
@@@ -479,7 -495,9 +495,13 @@@ static void u32_clear_hw_hnode(struct t
  	}
  }
  
++<<<<<<< HEAD
 +static void u32_replace_hw_knode(struct tcf_proto *tp, struct tc_u_knode *n)
++=======
+ static int u32_replace_hw_knode(struct tcf_proto *tp,
+ 				 struct tc_u_knode *n,
+ 				 u32 flags)
++>>>>>>> d34e3e181395 (net: cls_u32: Add support for skip-sw flag to tc u32 classifier.)
  {
  	struct net_device *dev = tp->q->dev_queue->dev;
  	struct tc_cls_u32_offload u32_offload = {0};
@@@ -799,6 -860,12 +826,15 @@@ static int u32_change(struct net *net, 
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
++=======
+ 	if (tb[TCA_U32_FLAGS]) {
+ 		flags = nla_get_u32(tb[TCA_U32_FLAGS]);
+ 		if (!tc_flags_valid(flags))
+ 			return err;
+ 	}
+ 
++>>>>>>> d34e3e181395 (net: cls_u32: Add support for skip-sw flag to tc u32 classifier.)
  	n = (struct tc_u_knode *)*arg;
  	if (n) {
  		struct tc_u_knode *new;
@@@ -822,7 -898,6 +864,10 @@@
  		u32_replace_knode(tp, tp_c, new);
  		tcf_unbind_filter(tp, &n->res);
  		call_rcu(&n->rcu, u32_delete_key_rcu);
++<<<<<<< HEAD
 +		u32_replace_hw_knode(tp, new);
++=======
++>>>>>>> d34e3e181395 (net: cls_u32: Add support for skip-sw flag to tc u32 classifier.)
  		return 0;
  	}
  
@@@ -933,16 -1013,16 +982,20 @@@
  
  		RCU_INIT_POINTER(n->next, pins);
  		rcu_assign_pointer(*ins, n);
++<<<<<<< HEAD
 +		u32_replace_hw_knode(tp, n);
++=======
++>>>>>>> d34e3e181395 (net: cls_u32: Add support for skip-sw flag to tc u32 classifier.)
  		*arg = (unsigned long)n;
  		return 0;
  	}
  
+ errhw:
  #ifdef CONFIG_CLS_U32_MARK
  	free_percpu(n->pcpu_success);
 -errout:
  #endif
  
 +errout:
  #ifdef CONFIG_CLS_U32_PERF
  	free_percpu(n->pf);
  #endif
* Unmerged path include/net/pkt_cls.h
* Unmerged path include/uapi/linux/pkt_cls.h
* Unmerged path net/sched/cls_u32.c
