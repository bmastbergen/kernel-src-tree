GFS2: Reduce contention on gfs2_log_lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit aacee72061a352d52ef9d3854f8db3b86b93ea16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/aacee720.failed

This patch modifies functions gfs2_trans_add_meta and _data so that
they check whether the buffer_head is already in a transaction,
and if so, avoid taking the gfs2_log_lock.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit aacee72061a352d52ef9d3854f8db3b86b93ea16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/trans.c
diff --cc fs/gfs2/trans.c
index d7f68983ce8e,affef3c066e0..000000000000
--- a/fs/gfs2/trans.c
+++ b/fs/gfs2/trans.c
@@@ -212,10 -193,10 +216,11 @@@ void gfs2_trans_add_data(struct gfs2_gl
  		set_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);
  		gfs2_pin(sdp, bd->bd_bh);
  		tr->tr_num_databuf_new++;
 -		list_add_tail(&bd->bd_list, &tr->tr_databuf);
 +		sdp->sd_log_num_databuf++;
 +		list_add_tail(&bd->bd_list, &sdp->sd_log_le_databuf);
  	}
  	gfs2_log_unlock(sdp);
+ out:
  	unlock_buffer(bh);
  }
  
@@@ -250,8 -205,15 +255,18 @@@ void gfs2_trans_add_meta(struct gfs2_gl
  
  	struct gfs2_sbd *sdp = gl->gl_name.ln_sbd;
  	struct gfs2_bufdata *bd;
++<<<<<<< HEAD
++=======
+ 	struct gfs2_meta_header *mh;
+ 	struct gfs2_trans *tr = current->journal_info;
+ 	enum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);
++>>>>>>> aacee72061a3 (GFS2: Reduce contention on gfs2_log_lock)
  
  	lock_buffer(bh);
+ 	if (buffer_pinned(bh)) {
+ 		set_bit(TR_TOUCHED, &tr->tr_flags);
+ 		goto out;
+ 	}
  	gfs2_log_lock(sdp);
  	bd = bh->b_private;
  	if (bd == NULL) {
@@@ -267,8 -229,29 +282,33 @@@
  		gfs2_log_lock(sdp);
  	}
  	gfs2_assert(sdp, bd->bd_gl == gl);
++<<<<<<< HEAD
 +	meta_lo_add(sdp, bd);
++=======
+ 	set_bit(TR_TOUCHED, &tr->tr_flags);
+ 	if (!list_empty(&bd->bd_list))
+ 		goto out_unlock;
+ 	set_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);
+ 	set_bit(GLF_DIRTY, &bd->bd_gl->gl_flags);
+ 	mh = (struct gfs2_meta_header *)bd->bd_bh->b_data;
+ 	if (unlikely(mh->mh_magic != cpu_to_be32(GFS2_MAGIC))) {
+ 		pr_err("Attempting to add uninitialised block to journal (inplace block=%lld)\n",
+ 		       (unsigned long long)bd->bd_bh->b_blocknr);
+ 		BUG();
+ 	}
+ 	if (unlikely(state == SFS_FROZEN)) {
+ 		printk(KERN_INFO "GFS2:adding buf while frozen\n");
+ 		gfs2_assert_withdraw(sdp, 0);
+ 	}
+ 	gfs2_pin(sdp, bd->bd_bh);
+ 	mh->__pad0 = cpu_to_be64(0);
+ 	mh->mh_jid = cpu_to_be32(sdp->sd_jdesc->jd_jid);
+ 	list_add(&bd->bd_list, &tr->tr_buf);
+ 	tr->tr_num_buf_new++;
+ out_unlock:
++>>>>>>> aacee72061a3 (GFS2: Reduce contention on gfs2_log_lock)
  	gfs2_log_unlock(sdp);
+ out:
  	unlock_buffer(bh);
  }
  
* Unmerged path fs/gfs2/trans.c
