sctp: sctp_transport_lookup_process should rcu_read_unlock when transport is null

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 08abb79542c9e8c367d1d8e44fe1026868d3f0a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/08abb795.failed

Prior to this patch, sctp_transport_lookup_process didn't rcu_read_unlock
when it failed to find a transport by sctp_addrs_lookup_transport.

This patch is to fix it by moving up rcu_read_unlock right before checking
transport and also to remove the out path.

Fixes: 1cceda784980 ("sctp: fix the issue sctp_diag uses lock_sock in rcu_read_lock")
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 08abb79542c9e8c367d1d8e44fe1026868d3f0a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/socket.c
diff --cc net/sctp/socket.c
index 5b053d7b1799,318c6786d653..000000000000
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@@ -4383,10 -4476,10 +4383,16 @@@ int sctp_transport_lookup_process(int (
  
  	rcu_read_lock();
  	transport = sctp_addrs_lookup_transport(net, laddr, paddr);
++<<<<<<< HEAD
 +	if (!transport || !sctp_transport_hold(transport))
 +		goto out;
 +
++=======
++>>>>>>> 08abb79542c9 (sctp: sctp_transport_lookup_process should rcu_read_unlock when transport is null)
  	rcu_read_unlock();
+ 	if (!transport)
+ 		return -ENOENT;
+ 
  	err = cb(transport, p);
  	sctp_transport_put(transport);
  
* Unmerged path net/sctp/socket.c
