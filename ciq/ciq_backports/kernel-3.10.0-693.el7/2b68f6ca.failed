mm: expose arch_mmap_rnd when available

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Kees Cook <keescook@chromium.org>
commit 2b68f6caeac271620cd2f9362aeaed360e317df0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2b68f6ca.failed

When an architecture fully supports randomizing the ELF load location,
a per-arch mmap_rnd() function is used to find a randomized mmap base.
In preparation for randomizing the location of ET_DYN binaries
separately from mmap, this renames and exports these functions as
arch_mmap_rnd(). Additionally introduces CONFIG_ARCH_HAS_ELF_RANDOMIZE
for describing this feature on architectures that support it
(which is a superset of ARCH_BINFMT_ELF_RANDOMIZE_PIE, since s390
already supports a separated ET_DYN ASLR from mmap ASLR without the
ARCH_BINFMT_ELF_RANDOMIZE_PIE logic).

	Signed-off-by: Kees Cook <keescook@chromium.org>
	Cc: Hector Marco-Gisbert <hecmargi@upv.es>
	Cc: Russell King <linux@arm.linux.org.uk>
	Reviewed-by: Ingo Molnar <mingo@kernel.org>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: Ralf Baechle <ralf@linux-mips.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: Alexander Viro <viro@zeniv.linux.org.uk>
	Cc: Oleg Nesterov <oleg@redhat.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: "David A. Long" <dave.long@linaro.org>
	Cc: Andrey Ryabinin <a.ryabinin@samsung.com>
	Cc: Arun Chandran <achandran@mvista.com>
	Cc: Yann Droneaud <ydroneaud@opteya.com>
	Cc: Min-Hua Chen <orca.chen@gmail.com>
	Cc: Paul Burton <paul.burton@imgtec.com>
	Cc: Alex Smith <alex@alex-smith.me.uk>
	Cc: Markos Chandras <markos.chandras@imgtec.com>
	Cc: Vineeth Vijayan <vvijayan@mvista.com>
	Cc: Jeff Bailey <jeffbailey@google.com>
	Cc: Michael Holzheu <holzheu@linux.vnet.ibm.com>
	Cc: Ben Hutchings <ben@decadent.org.uk>
	Cc: Behan Webster <behanw@converseincode.com>
	Cc: Ismael Ripoll <iripoll@upv.es>
	Cc: Jan-Simon Mller <dl9pf@gmx.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 2b68f6caeac271620cd2f9362aeaed360e317df0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/Kconfig
#	arch/arm/mm/mmap.c
#	arch/arm64/Kconfig
#	arch/arm64/mm/mmap.c
#	arch/mips/mm/mmap.c
#	arch/powerpc/Kconfig
#	arch/powerpc/mm/mmap_64.c
#	arch/s390/Kconfig
#	arch/s390/mm/mmap.c
diff --cc arch/arm/Kconfig
index d1387fc4470a,f85200a63a8b..000000000000
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@@ -3,14 -3,23 +3,19 @@@ config AR
  	default y
  	select ARCH_BINFMT_ELF_RANDOMIZE_PIE
  	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
++<<<<<<< HEAD
++=======
+ 	select ARCH_HAS_ELF_RANDOMIZE
+ 	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  	select ARCH_HAVE_CUSTOM_GPIO_H
 -	select ARCH_HAS_GCOV_PROFILE_ALL
 -	select ARCH_MIGHT_HAVE_PC_PARPORT
 -	select ARCH_SUPPORTS_ATOMIC_RMW
 -	select ARCH_USE_BUILTIN_BSWAP
 -	select ARCH_USE_CMPXCHG_LOCKREF
 +	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
  	select ARCH_WANT_IPC_PARSE_VERSION
  	select BUILDTIME_EXTABLE_SORT if MMU
 -	select CLONE_BACKWARDS
  	select CPU_PM if (SUSPEND || CPU_IDLE)
 -	select DCACHE_WORD_ACCESS if HAVE_EFFICIENT_UNALIGNED_ACCESS
 -	select GENERIC_ALLOCATOR
 -	select GENERIC_ATOMIC64 if (CPU_V7M || CPU_V6 || !CPU_32v6K || !AEABI)
 +	select DCACHE_WORD_ACCESS if (CPU_V6 || CPU_V6K || CPU_V7) && !CPU_BIG_ENDIAN && MMU
 +	select GENERIC_ATOMIC64 if (CPU_V6 || !CPU_32v6K || !AEABI)
  	select GENERIC_CLOCKEVENTS_BROADCAST if SMP
 -	select GENERIC_IDLE_POLL_SETUP
  	select GENERIC_IRQ_PROBE
  	select GENERIC_IRQ_SHOW
  	select GENERIC_PCI_IOMAP
diff --cc arch/arm/mm/mmap.c
index f0ef2f7d4ad7,407dc786583a..000000000000
--- a/arch/arm/mm/mmap.c
+++ b/arch/arm/mm/mmap.c
@@@ -169,14 -169,22 +169,32 @@@ arch_get_unmapped_area_topdown(struct f
  	return addr;
  }
  
++<<<<<<< HEAD
++=======
+ unsigned long arch_mmap_rnd(void)
+ {
+ 	unsigned long rnd;
+ 
+ 	/* 8 bits of randomness in 20 address space bits */
+ 	rnd = (unsigned long)get_random_int() % (1 << 8);
+ 
+ 	return rnd << PAGE_SHIFT;
+ }
+ 
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  void arch_pick_mmap_layout(struct mm_struct *mm)
  {
  	unsigned long random_factor = 0UL;
  
++<<<<<<< HEAD
 +	/* 8 bits of randomness in 20 address space bits */
 +	if ((current->flags & PF_RANDOMIZE) &&
 +	    !(current->personality & ADDR_NO_RANDOMIZE))
 +		random_factor = (get_random_int() % (1 << 8)) << PAGE_SHIFT;
++=======
+ 	if (current->flags & PF_RANDOMIZE)
+ 		random_factor = arch_mmap_rnd();
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  
  	if (mmap_is_legacy()) {
  		mm->mmap_base = TASK_UNMAPPED_BASE + random_factor;
diff --cc arch/arm64/Kconfig
index 56b3f6d447ae,7c1dbeb73e8d..000000000000
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@@ -1,6 -1,13 +1,15 @@@
  config ARM64
  	def_bool y
 -	select ARCH_BINFMT_ELF_RANDOMIZE_PIE
  	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
++<<<<<<< HEAD
++=======
+ 	select ARCH_HAS_ELF_RANDOMIZE
+ 	select ARCH_HAS_GCOV_PROFILE_ALL
+ 	select ARCH_HAS_SG_CHAIN
+ 	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
+ 	select ARCH_USE_CMPXCHG_LOCKREF
+ 	select ARCH_SUPPORTS_ATOMIC_RMW
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  	select ARCH_WANT_OPTIONAL_GPIOLIB
  	select ARCH_WANT_COMPAT_IPC_PARSE_VERSION
  	select ARCH_WANT_FRAME_POINTERS
diff --cc arch/arm64/mm/mmap.c
index 7c7be7855638,ed177475dd8c..000000000000
--- a/arch/arm64/mm/mmap.c
+++ b/arch/arm64/mm/mmap.c
@@@ -47,25 -47,16 +47,29 @@@ static int mmap_is_legacy(void
  	return sysctl_legacy_va_layout;
  }
  
++<<<<<<< HEAD
 +/*
 + * Since get_random_int() returns the same value within a 1 jiffy window, we
 + * will almost always get the same randomisation for the stack and mmap
 + * region. This will mean the relative distance between stack and mmap will be
 + * the same.
 + *
 + * To avoid this we can shift the randomness by 1 bit.
 + */
 +static unsigned long mmap_rnd(void)
++=======
+ unsigned long arch_mmap_rnd(void)
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  {
 -	unsigned long rnd;
 +	unsigned long rnd = 0;
  
 -	rnd = (unsigned long)get_random_int() & STACK_RND_MASK;
 +	if (current->flags & PF_RANDOMIZE)
 +		rnd = (long)get_random_int() & (STACK_RND_MASK >> 1);
  
 -	return rnd << PAGE_SHIFT;
 +	return rnd << (PAGE_SHIFT + 1);
  }
  
 -static unsigned long mmap_base(unsigned long rnd)
 +static unsigned long mmap_base(void)
  {
  	unsigned long gap = rlimit(RLIMIT_STACK);
  
@@@ -83,6 -74,11 +87,14 @@@
   */
  void arch_pick_mmap_layout(struct mm_struct *mm)
  {
++<<<<<<< HEAD
++=======
+ 	unsigned long random_factor = 0UL;
+ 
+ 	if (current->flags & PF_RANDOMIZE)
+ 		random_factor = arch_mmap_rnd();
+ 
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  	/*
  	 * Fall back to the standard layout if the personality bit is set, or
  	 * if the expected stack growth is unlimited:
diff --cc arch/mips/mm/mmap.c
index 7e5fe2790d8a,5c81fdd032c3..000000000000
--- a/arch/mips/mm/mmap.c
+++ b/arch/mips/mm/mmap.c
@@@ -142,18 -142,26 +142,40 @@@ unsigned long arch_get_unmapped_area_to
  			addr0, len, pgoff, flags, DOWN);
  }
  
++<<<<<<< HEAD
++=======
+ unsigned long arch_mmap_rnd(void)
+ {
+ 	unsigned long rnd;
+ 
+ 	rnd = (unsigned long)get_random_int();
+ 	rnd <<= PAGE_SHIFT;
+ 	if (TASK_IS_32BIT_ADDR)
+ 		rnd &= 0xfffffful;
+ 	else
+ 		rnd &= 0xffffffful;
+ 
+ 	return rnd;
+ }
+ 
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  void arch_pick_mmap_layout(struct mm_struct *mm)
  {
  	unsigned long random_factor = 0UL;
  
++<<<<<<< HEAD
 +	if (current->flags & PF_RANDOMIZE) {
 +		random_factor = get_random_int();
 +		random_factor = random_factor << PAGE_SHIFT;
 +		if (TASK_IS_32BIT_ADDR)
 +			random_factor &= 0xfffffful;
 +		else
 +			random_factor &= 0xffffffful;
 +	}
++=======
+ 	if (current->flags & PF_RANDOMIZE)
+ 		random_factor = arch_mmap_rnd();
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  
  	if (mmap_is_legacy()) {
  		mm->mmap_base = TASK_UNMAPPED_BASE + random_factor;
diff --cc arch/powerpc/Kconfig
index e42024f8779d,fc5fffbb331b..000000000000
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@@ -89,9 -86,13 +89,14 @@@ config PP
  	bool
  	default y
  	select ARCH_MIGHT_HAVE_PC_PARPORT
 -	select ARCH_MIGHT_HAVE_PC_SERIO
  	select BINFMT_ELF
++<<<<<<< HEAD
++=======
+ 	select ARCH_BINFMT_ELF_RANDOMIZE_PIE
+ 	select ARCH_HAS_ELF_RANDOMIZE
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  	select OF
  	select OF_EARLY_FLATTREE
 -	select OF_RESERVED_MEM
  	select HAVE_FTRACE_MCOUNT_RECORD
  	select HAVE_DYNAMIC_FTRACE
  	select HAVE_FUNCTION_TRACER
diff --cc arch/powerpc/mm/mmap_64.c
index 67a42ed0d2fc,0f0502e12f6c..000000000000
--- a/arch/powerpc/mm/mmap_64.c
+++ b/arch/powerpc/mm/mmap_64.c
@@@ -53,17 -53,16 +53,17 @@@ static inline int mmap_is_legacy(void
  	return sysctl_legacy_va_layout;
  }
  
- static unsigned long mmap_rnd(void)
+ unsigned long arch_mmap_rnd(void)
  {
 -	unsigned long rnd;
 -
 -	/* 8MB for 32bit, 1GB for 64bit */
 -	if (is_32bit_task())
 -		rnd = (unsigned long)get_random_int() % (1<<(23-PAGE_SHIFT));
 -	else
 -		rnd = (unsigned long)get_random_int() % (1<<(30-PAGE_SHIFT));
 +	unsigned long rnd = 0;
  
 +	if (current->flags & PF_RANDOMIZE) {
 +		/* 8MB for 32bit, 1GB for 64bit */
 +		if (is_32bit_task())
 +			rnd = (long)(get_random_int() % (1<<(23-PAGE_SHIFT)));
 +		else
 +			rnd = (long)(get_random_int() % (1<<(30-PAGE_SHIFT)));
 +	}
  	return rnd << PAGE_SHIFT;
  }
  
@@@ -85,6 -84,11 +85,14 @@@ static inline unsigned long mmap_base(v
   */
  void arch_pick_mmap_layout(struct mm_struct *mm)
  {
++<<<<<<< HEAD:arch/powerpc/mm/mmap_64.c
++=======
+ 	unsigned long random_factor = 0UL;
+ 
+ 	if (current->flags & PF_RANDOMIZE)
+ 		random_factor = arch_mmap_rnd();
+ 
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available):arch/powerpc/mm/mmap.c
  	/*
  	 * Fall back to the standard layout if the personality
  	 * bit is set, or if the expected stack growth is unlimited:
diff --cc arch/s390/Kconfig
index 11cceb7a4b0a,ac2b75d74cd2..000000000000
--- a/arch/s390/Kconfig
+++ b/arch/s390/Kconfig
@@@ -63,8 -63,11 +63,15 @@@ config ARCH_SUPPORTS_UPROBE
  
  config S390
  	def_bool y
 +	select ARCH_DISCARD_MEMBLOCK
  	select ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
++<<<<<<< HEAD
++=======
+ 	select ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS
+ 	select ARCH_HAS_ELF_RANDOMIZE
+ 	select ARCH_HAS_GCOV_PROFILE_ALL
+ 	select ARCH_HAS_SG_CHAIN
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  	select ARCH_HAVE_NMI_SAFE_CMPXCHG
  	select ARCH_INLINE_READ_LOCK
  	select ARCH_INLINE_READ_LOCK_BH
diff --cc arch/s390/mm/mmap.c
index 26158ac9a689,a94504d99c47..000000000000
--- a/arch/s390/mm/mmap.c
+++ b/arch/s390/mm/mmap.c
@@@ -60,10 -60,8 +60,10 @@@ static inline int mmap_is_legacy(void
  	return sysctl_legacy_va_layout;
  }
  
- static unsigned long mmap_rnd(void)
+ unsigned long arch_mmap_rnd(void)
  {
 +	if (!(current->flags & PF_RANDOMIZE))
 +		return 0;
  	if (is_32bit_task())
  		return (get_random_int() & 0x7ff) << PAGE_SHIFT;
  	else
@@@ -187,7 -185,11 +187,15 @@@ unsigned long randomize_et_dyn(void
  	if (!is_32bit_task())
  		/* Align to 4GB */
  		base &= ~((1UL << 32) - 1);
++<<<<<<< HEAD
 +	return base + mmap_rnd();
++=======
+ 
+ 	if (current->flags & PF_RANDOMIZE)
+ 		base += arch_mmap_rnd();
+ 
+ 	return base;
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  }
  
  #ifndef CONFIG_64BIT
@@@ -198,6 -200,11 +206,14 @@@
   */
  void arch_pick_mmap_layout(struct mm_struct *mm)
  {
++<<<<<<< HEAD
++=======
+ 	unsigned long random_factor = 0UL;
+ 
+ 	if (current->flags & PF_RANDOMIZE)
+ 		random_factor = arch_mmap_rnd();
+ 
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  	/*
  	 * Fall back to the standard layout if the personality
  	 * bit is set, or if the expected stack growth is unlimited:
@@@ -275,6 -280,11 +291,14 @@@ s390_get_unmapped_area_topdown(struct f
   */
  void arch_pick_mmap_layout(struct mm_struct *mm)
  {
++<<<<<<< HEAD
++=======
+ 	unsigned long random_factor = 0UL;
+ 
+ 	if (current->flags & PF_RANDOMIZE)
+ 		random_factor = arch_mmap_rnd();
+ 
++>>>>>>> 2b68f6caeac2 (mm: expose arch_mmap_rnd when available)
  	/*
  	 * Fall back to the standard layout if the personality
  	 * bit is set, or if the expected stack growth is unlimited:
diff --git a/arch/Kconfig b/arch/Kconfig
index b5a4cb176d36..2b3b7d550a46 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -466,6 +466,13 @@ config HAVE_STACK_VALIDATION
 	  Architecture supports the 'objtool check' host tool command, which
 	  performs compile-time stack metadata validation.
 
+config ARCH_HAS_ELF_RANDOMIZE
+	bool
+	help
+	  An architecture supports choosing randomized locations for
+	  stack, mmap, brk, and ET_DYN. Defined functions:
+	  - arch_mmap_rnd()
+
 #
 # ABI hall of shame
 #
* Unmerged path arch/arm/Kconfig
* Unmerged path arch/arm/mm/mmap.c
* Unmerged path arch/arm64/Kconfig
* Unmerged path arch/arm64/mm/mmap.c
diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index e53e2b40d695..d4d68be87619 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -18,6 +18,7 @@ config MIPS
 	select HAVE_KRETPROBES
 	select HAVE_DEBUG_KMEMLEAK
 	select ARCH_BINFMT_ELF_RANDOMIZE_PIE
+	select ARCH_HAS_ELF_RANDOMIZE
 	select HAVE_ARCH_TRANSPARENT_HUGEPAGE if CPU_SUPPORTS_HUGEPAGES && 64BIT
 	select RTC_LIB if !MACH_LOONGSON
 	select GENERIC_ATOMIC64 if !64BIT
* Unmerged path arch/mips/mm/mmap.c
* Unmerged path arch/powerpc/Kconfig
* Unmerged path arch/powerpc/mm/mmap_64.c
* Unmerged path arch/s390/Kconfig
* Unmerged path arch/s390/mm/mmap.c
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 5162fc083bed..9410bff4165c 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -84,6 +84,7 @@ config X86
 	select HAVE_ARCH_KMEMCHECK
 	select HAVE_USER_RETURN_NOTIFIER
 	select ARCH_BINFMT_ELF_RANDOMIZE_PIE
+	select ARCH_HAS_ELF_RANDOMIZE
 	select HAVE_ARCH_JUMP_LABEL
 	select HAVE_TEXT_POKE_SMP
 	select HAVE_GENERIC_HARDIRQS
diff --git a/arch/x86/mm/mmap.c b/arch/x86/mm/mmap.c
index 0e426764499a..cb7cd6e3e686 100644
--- a/arch/x86/mm/mmap.c
+++ b/arch/x86/mm/mmap.c
@@ -65,7 +65,7 @@ static int mmap_is_legacy(void)
 	return sysctl_legacy_va_layout;
 }
 
-static unsigned long mmap_rnd(void)
+unsigned long arch_mmap_rnd(void)
 {
 	unsigned long rnd;
 
@@ -114,7 +114,7 @@ void arch_pick_mmap_layout(struct mm_struct *mm)
 	unsigned long random_factor = 0UL;
 
 	if (current->flags & PF_RANDOMIZE)
-		random_factor = mmap_rnd();
+		random_factor = arch_mmap_rnd();
 
 	mm->mmap_legacy_base = mmap_legacy_base(random_factor);
 
diff --git a/include/linux/elf-randomize.h b/include/linux/elf-randomize.h
new file mode 100644
index 000000000000..7a4eda02d2b1
--- /dev/null
+++ b/include/linux/elf-randomize.h
@@ -0,0 +1,10 @@
+#ifndef _ELF_RANDOMIZE_H
+#define _ELF_RANDOMIZE_H
+
+#ifndef CONFIG_ARCH_HAS_ELF_RANDOMIZE
+static inline unsigned long arch_mmap_rnd(void) { return 0; }
+#else
+extern unsigned long arch_mmap_rnd(void);
+#endif
+
+#endif
