xfs: ioends require logically contiguous file offsets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Darrick J. Wong <darrick.wong@oracle.com>
commit 0df61da8ac5b7acb1db6cee142822ebe4724c739
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0df61da8.failed

We need to create a new ioend if the current writepage call isn't
logically contiguous with the range contained in the previous ioend.
Hopefully writepage gets called in order of increasing file offset.

	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>




(cherry picked from commit 0df61da8ac5b7acb1db6cee142822ebe4724c739)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_aops.c
diff --cc fs/xfs/xfs_aops.c
index acf6c4a54883,b125f9019145..000000000000
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@@ -540,25 -516,25 +540,32 @@@ xfs_add_to_ioend
  	struct inode		*inode,
  	struct buffer_head	*bh,
  	xfs_off_t		offset,
 -	struct xfs_writepage_ctx *wpc,
 -	struct list_head	*iolist)
 +	unsigned int		type,
 +	xfs_ioend_t		**result,
 +	int			need_ioend)
  {
++<<<<<<< HEAD
 +	xfs_ioend_t		*ioend = *result;
++=======
+ 	if (!wpc->ioend || wpc->io_type != wpc->ioend->io_type ||
+ 	    bh->b_blocknr != wpc->last_block + 1 ||
+ 	    offset != wpc->ioend->io_offset + wpc->ioend->io_size) {
+ 		struct xfs_ioend	*new;
++>>>>>>> 0df61da8ac5b (xfs: ioends require logically contiguous file offsets)
  
 -		if (wpc->ioend)
 -			list_add(&wpc->ioend->io_list, iolist);
 +	if (!ioend || need_ioend || type != ioend->io_type) {
 +		xfs_ioend_t	*previous = *result;
  
 -		new = xfs_alloc_ioend(inode, wpc->io_type);
 -		new->io_offset = offset;
 -		new->io_buffer_head = bh;
 -		new->io_buffer_tail = bh;
 -		wpc->ioend = new;
 +		ioend = xfs_alloc_ioend(inode, type);
 +		ioend->io_offset = offset;
 +		ioend->io_buffer_head = bh;
 +		ioend->io_buffer_tail = bh;
 +		if (previous)
 +			previous->io_list = ioend;
 +		*result = ioend;
  	} else {
 -		wpc->ioend->io_buffer_tail->b_private = bh;
 -		wpc->ioend->io_buffer_tail = bh;
 +		ioend->io_buffer_tail->b_private = bh;
 +		ioend->io_buffer_tail = bh;
  	}
  
  	bh->b_private = NULL;
* Unmerged path fs/xfs/xfs_aops.c
