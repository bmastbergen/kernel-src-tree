USB: bcma: support old USB 2.0 controller on Northstar devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Rafał Miłecki <rafal@milecki.pl>
commit d6b76c4ddb124dd22c6e910ca9332e472e7b3273
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d6b76c4d.failed

Currently bcma-hcd driver handles 3 different bcma cores:
1) BCMA_CORE_USB20_HOST (0x819)
2) BCMA_CORE_NS_USB20 (0x504)
3) BCMA_CORE_NS_USB30 (0x505)

The first one was introduced years ago and so far was used on MIPS
devices only. All Northstar (ARM) devices were using other two cores
which allowed easy implementation of separated initialization paths.

It seems however Broadcom decided to reuse this old USB 2.0 controller
on some recently introduced cheaper Northstar BCM53573 SoCs. I noticed
this on Tenda AC9 (based on BCM47189B0 belonging to BCM53573 family).

There is no difference in this old controller core identification
between MIPS and ARM devices: they share the same id and revision. We
need different controller initialization procedure however.
To handle this add a check for architecture and implement required
initialization for ARM case.

	Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit d6b76c4ddb124dd22c6e910ca9332e472e7b3273)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/host/bcma-hcd.c
diff --cc drivers/usb/host/bcma-hcd.c
index 205f4a336583,e0761d92f2b6..000000000000
--- a/drivers/usb/host/bcma-hcd.c
+++ b/drivers/usb/host/bcma-hcd.c
@@@ -30,9 -35,14 +30,12 @@@ MODULE_AUTHOR("Hauke Mehrtens")
  MODULE_DESCRIPTION("Common USB driver for BCMA Bus");
  MODULE_LICENSE("GPL");
  
+ /* See BCMA_CLKCTLST_EXTRESREQ and BCMA_CLKCTLST_EXTRESST */
+ #define USB_BCMA_CLKCTLST_USB_CLK_REQ			0x00000100
+ 
  struct bcma_hcd_device {
 -	struct bcma_device *core;
  	struct platform_device *ehci_dev;
  	struct platform_device *ohci_dev;
 -	struct gpio_desc *gpio_desc;
  };
  
  /* Wait for bitmask in a register to get set or cleared.
@@@ -159,6 -169,150 +162,153 @@@ static void bcma_hcd_init_chip(struct b
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * bcma_hcd_usb20_old_arm_init - Initialize old USB 2.0 controller on ARM
+  *
+  * Old USB 2.0 core is identified as BCMA_CORE_USB20_HOST and was introduced
+  * long before Northstar devices. It seems some cheaper chipsets like BCM53573
+  * still use it.
+  * Initialization of this old core differs between MIPS and ARM.
+  */
+ static int bcma_hcd_usb20_old_arm_init(struct bcma_hcd_device *usb_dev)
+ {
+ 	struct bcma_device *core = usb_dev->core;
+ 	struct device *dev = &core->dev;
+ 	struct bcma_device *pmu_core;
+ 
+ 	usleep_range(10000, 20000);
+ 	if (core->id.rev < 5)
+ 		return 0;
+ 
+ 	pmu_core = bcma_find_core(core->bus, BCMA_CORE_PMU);
+ 	if (!pmu_core) {
+ 		dev_err(dev, "Could not find PMU core\n");
+ 		return -ENOENT;
+ 	}
+ 
+ 	/* Take USB core out of reset */
+ 	bcma_awrite32(core, BCMA_IOCTL, BCMA_IOCTL_CLK | BCMA_IOCTL_FGC);
+ 	usleep_range(100, 200);
+ 	bcma_awrite32(core, BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);
+ 	usleep_range(100, 200);
+ 	bcma_awrite32(core, BCMA_RESET_CTL, 0);
+ 	usleep_range(100, 200);
+ 	bcma_awrite32(core, BCMA_IOCTL, BCMA_IOCTL_CLK);
+ 	usleep_range(100, 200);
+ 
+ 	/* Enable Misc PLL */
+ 	bcma_write32(core, BCMA_CLKCTLST, BCMA_CLKCTLST_FORCEHT |
+ 					  BCMA_CLKCTLST_HQCLKREQ |
+ 					  USB_BCMA_CLKCTLST_USB_CLK_REQ);
+ 	usleep_range(100, 200);
+ 
+ 	bcma_write32(core, 0x510, 0xc7f85000);
+ 	bcma_write32(core, 0x510, 0xc7f85003);
+ 	usleep_range(300, 600);
+ 
+ 	/* Program USB PHY PLL parameters */
+ 	bcma_write32(pmu_core, BCMA_CC_PMU_PLLCTL_ADDR, 0x6);
+ 	bcma_write32(pmu_core, BCMA_CC_PMU_PLLCTL_DATA, 0x005360c1);
+ 	usleep_range(100, 200);
+ 	bcma_write32(pmu_core, BCMA_CC_PMU_PLLCTL_ADDR, 0x7);
+ 	bcma_write32(pmu_core, BCMA_CC_PMU_PLLCTL_DATA, 0x0);
+ 	usleep_range(100, 200);
+ 	bcma_set32(pmu_core, BCMA_CC_PMU_CTL, BCMA_CC_PMU_CTL_PLL_UPD);
+ 	usleep_range(100, 200);
+ 
+ 	bcma_write32(core, 0x510, 0x7f8d007);
+ 	udelay(1000);
+ 
+ 	/* Take controller out of reset */
+ 	bcma_write32(core, 0x200, 0x4ff);
+ 	usleep_range(25, 50);
+ 	bcma_write32(core, 0x200, 0x6ff);
+ 	usleep_range(25, 50);
+ 	bcma_write32(core, 0x200, 0x7ff);
+ 	usleep_range(25, 50);
+ 
+ 	of_platform_default_populate(dev->of_node, NULL, dev);
+ 
+ 	return 0;
+ }
+ 
+ static void bcma_hcd_init_chip_arm_phy(struct bcma_device *dev)
+ {
+ 	struct bcma_device *arm_core;
+ 	void __iomem *dmu;
+ 
+ 	arm_core = bcma_find_core(dev->bus, BCMA_CORE_ARMCA9);
+ 	if (!arm_core) {
+ 		dev_err(&dev->dev, "can not find ARM Cortex A9 ihost core\n");
+ 		return;
+ 	}
+ 
+ 	dmu = ioremap_nocache(arm_core->addr_s[0], 0x1000);
+ 	if (!dmu) {
+ 		dev_err(&dev->dev, "can not map ARM Cortex A9 ihost core\n");
+ 		return;
+ 	}
+ 
+ 	/* Unlock DMU PLL settings */
+ 	iowrite32(0x0000ea68, dmu + 0x180);
+ 
+ 	/* Write USB 2.0 PLL control setting */
+ 	iowrite32(0x00dd10c3, dmu + 0x164);
+ 
+ 	/* Lock DMU PLL settings */
+ 	iowrite32(0x00000000, dmu + 0x180);
+ 
+ 	iounmap(dmu);
+ }
+ 
+ static void bcma_hcd_init_chip_arm_hc(struct bcma_device *dev)
+ {
+ 	u32 val;
+ 
+ 	/*
+ 	 * Delay after PHY initialized to ensure HC is ready to be configured
+ 	 */
+ 	usleep_range(1000, 2000);
+ 
+ 	/* Set packet buffer OUT threshold */
+ 	val = bcma_read32(dev, 0x94);
+ 	val &= 0xffff;
+ 	val |= 0x80 << 16;
+ 	bcma_write32(dev, 0x94, val);
+ 
+ 	/* Enable break memory transfer */
+ 	val = bcma_read32(dev, 0x9c);
+ 	val |= 1;
+ 	bcma_write32(dev, 0x9c, val);
+ }
+ 
+ static void bcma_hcd_init_chip_arm(struct bcma_device *dev)
+ {
+ 	bcma_core_enable(dev, 0);
+ 
+ 	if (dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM4707 ||
+ 	    dev->bus->chipinfo.id == BCMA_CHIP_ID_BCM53018) {
+ 		if (dev->bus->chipinfo.pkg == BCMA_PKG_ID_BCM4707 ||
+ 		    dev->bus->chipinfo.pkg == BCMA_PKG_ID_BCM4708)
+ 			bcma_hcd_init_chip_arm_phy(dev);
+ 
+ 		bcma_hcd_init_chip_arm_hc(dev);
+ 	}
+ }
+ 
+ static void bcma_hci_platform_power_gpio(struct bcma_device *dev, bool val)
+ {
+ 	struct bcma_hcd_device *usb_dev = bcma_get_drvdata(dev);
+ 
+ 	if (IS_ERR_OR_NULL(usb_dev->gpio_desc))
+ 		return;
+ 
+ 	gpiod_set_value(usb_dev->gpio_desc, val);
+ }
+ 
++>>>>>>> d6b76c4ddb12 (USB: bcma: support old USB 2.0 controller on Northstar devices)
  static const struct usb_ehci_pdata ehci_pdata = {
  };
  
@@@ -264,6 -412,60 +414,63 @@@ err_free_usb_dev
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int bcma_hcd_usb30_init(struct bcma_hcd_device *bcma_hcd)
+ {
+ 	struct bcma_device *core = bcma_hcd->core;
+ 	struct device *dev = &core->dev;
+ 
+ 	bcma_core_enable(core, 0);
+ 
+ 	of_platform_default_populate(dev->of_node, NULL, dev);
+ 
+ 	return 0;
+ }
+ 
+ static int bcma_hcd_probe(struct bcma_device *core)
+ {
+ 	int err;
+ 	struct bcma_hcd_device *usb_dev;
+ 
+ 	/* TODO: Probably need checks here; is the core connected? */
+ 
+ 	usb_dev = devm_kzalloc(&core->dev, sizeof(struct bcma_hcd_device),
+ 			       GFP_KERNEL);
+ 	if (!usb_dev)
+ 		return -ENOMEM;
+ 	usb_dev->core = core;
+ 
+ 	if (core->dev.of_node)
+ 		usb_dev->gpio_desc = devm_gpiod_get(&core->dev, "vcc",
+ 						    GPIOD_OUT_HIGH);
+ 
+ 	switch (core->id.id) {
+ 	case BCMA_CORE_USB20_HOST:
+ 		if (IS_ENABLED(CONFIG_ARM))
+ 			err = bcma_hcd_usb20_old_arm_init(usb_dev);
+ 		else if (IS_ENABLED(CONFIG_MIPS))
+ 			err = bcma_hcd_usb20_init(usb_dev);
+ 		else
+ 			err = -ENOTSUPP;
+ 		break;
+ 	case BCMA_CORE_NS_USB20:
+ 		err = bcma_hcd_usb20_init(usb_dev);
+ 		break;
+ 	case BCMA_CORE_NS_USB30:
+ 		err = bcma_hcd_usb30_init(usb_dev);
+ 		break;
+ 	default:
+ 		return -ENODEV;
+ 	}
+ 	if (err)
+ 		return err;
+ 
+ 	bcma_set_drvdata(core, usb_dev);
+ 	return 0;
+ }
+ 
++>>>>>>> d6b76c4ddb12 (USB: bcma: support old USB 2.0 controller on Northstar devices)
  static void bcma_hcd_remove(struct bcma_device *dev)
  {
  	struct bcma_hcd_device *usb_dev = bcma_get_drvdata(dev);
* Unmerged path drivers/usb/host/bcma-hcd.c
diff --git a/include/linux/bcma/bcma_regs.h b/include/linux/bcma/bcma_regs.h
index ebd5c1fcdea4..4901fb358b07 100644
--- a/include/linux/bcma/bcma_regs.h
+++ b/include/linux/bcma/bcma_regs.h
@@ -10,6 +10,7 @@
 #define  BCMA_CLKCTLST_HAVEALPREQ	0x00000008 /* ALP available request */
 #define  BCMA_CLKCTLST_HAVEHTREQ	0x00000010 /* HT available request */
 #define  BCMA_CLKCTLST_HWCROFF		0x00000020 /* Force HW clock request off */
+#define  BCMA_CLKCTLST_HQCLKREQ		0x00000040 /* HQ Clock */
 #define  BCMA_CLKCTLST_EXTRESREQ	0x00000700 /* Mask of external resource requests */
 #define  BCMA_CLKCTLST_EXTRESREQ_SHIFT	8
 #define  BCMA_CLKCTLST_HAVEALP		0x00010000 /* ALP available */
