tools/power turbostat: show GFX%rc6

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [tools] power turbostat: show GFXrc6 (Prarit Bhargava) [1422076]
Rebuild_FUZZ: 88.89%
commit-author Len Brown <len.brown@intel.com>
commit fdf676e51f301d207586d9bac509b8ce055bae8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fdf676e5.failed

The column "GFX%c6" show the percentage of time the GPU
is in the "render C6" state, rc6.  Deep package C-states on several
systems depend on the GPU being in RC6.

This information comes from the counter
/sys/class/drm/card0/power/rc6_residency_ms,
as read before and after the measurement interval.

	Signed-off-by: Len Brown <len.brown@intel.com>
(cherry picked from commit fdf676e51f301d207586d9bac509b8ce055bae8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/power/x86/turbostat/turbostat.c
diff --cc tools/power/x86/turbostat/turbostat.c
index b938c3391c64,9896619e4382..000000000000
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@@ -87,6 -90,10 +87,13 @@@ char *output_buffer, *outp
  unsigned int do_rapl;
  unsigned int do_dts;
  unsigned int do_ptm;
++<<<<<<< HEAD
++=======
+ unsigned int do_gfx_rc6_ms;
+ unsigned long long  gfx_cur_rc6_ms;
+ unsigned int do_gfx_mhz;
+ unsigned int gfx_cur_mhz;
++>>>>>>> fdf676e51f30 (tools/power turbostat: show GFX%rc6)
  unsigned int tcc_activation_temp;
  unsigned int tcc_activation_temp_override;
  double rapl_power_units, rapl_time_units;
@@@ -176,6 -187,8 +183,11 @@@ struct pkg_data 
  	unsigned long long pkg_any_core_c0;
  	unsigned long long pkg_any_gfxe_c0;
  	unsigned long long pkg_both_core_gfxe_c0;
++<<<<<<< HEAD
++=======
+ 	unsigned long long gfx_rc6_ms;
+ 	unsigned int gfx_mhz;
++>>>>>>> fdf676e51f30 (tools/power turbostat: show GFX%rc6)
  	unsigned int package_id;
  	unsigned int energy_pkg;	/* MSR_PKG_ENERGY_STATUS */
  	unsigned int energy_dram;	/* MSR_DRAM_ENERGY_STATUS */
@@@ -336,6 -368,12 +348,15 @@@ void print_header(void
  	if (do_ptm)
  		outp += sprintf(outp, "  PkgTmp");
  
++<<<<<<< HEAD
++=======
+ 	if (do_gfx_rc6_ms)
+ 		outp += sprintf(outp, " GFX%%rc6");
+ 
+ 	if (do_gfx_mhz)
+ 		outp += sprintf(outp, "  GFXMHz");
+ 
++>>>>>>> fdf676e51f30 (tools/power turbostat: show GFX%rc6)
  	if (do_skl_residency) {
  		outp += sprintf(outp, " Totl%%C0");
  		outp += sprintf(outp, "  Any%%C0");
@@@ -572,6 -620,14 +593,17 @@@ int format_counters(struct thread_data 
  	if (do_ptm)
  		outp += sprintf(outp, "%8d", p->pkg_temp_c);
  
++<<<<<<< HEAD
++=======
+ 	/* GFXrc6 */
+ 	if (do_gfx_rc6_ms)
+ 		outp += sprintf(outp, "%8.2f", 100.0 * p->gfx_rc6_ms / 1000.0 / interval_float);
+ 
+ 	/* GFXMHz */
+ 	if (do_gfx_mhz)
+ 		outp += sprintf(outp, "%8d", p->gfx_mhz);
+ 
++>>>>>>> fdf676e51f30 (tools/power turbostat: show GFX%rc6)
  	/* Totl%C0, Any%C0 GFX%C0 CPUGFX% */
  	if (do_skl_residency) {
  		outp += sprintf(outp, "%8.2f", 100.0 * p->pkg_wtd_core_c0/t->tsc);
@@@ -701,6 -766,9 +733,12 @@@ delta_package(struct pkg_data *new, str
  	old->pc10 = new->pc10 - old->pc10;
  	old->pkg_temp_c = new->pkg_temp_c;
  
++<<<<<<< HEAD
++=======
+ 	old->gfx_rc6_ms = new->gfx_rc6_ms - old->gfx_rc6_ms;
+ 	old->gfx_mhz = new->gfx_mhz;
+ 
++>>>>>>> fdf676e51f30 (tools/power turbostat: show GFX%rc6)
  	DELTA_WRAP32(new->energy_pkg, old->energy_pkg);
  	DELTA_WRAP32(new->energy_cores, old->energy_cores);
  	DELTA_WRAP32(new->energy_gfx, old->energy_gfx);
@@@ -858,6 -932,9 +896,12 @@@ void clear_counters(struct thread_data 
  	p->rapl_pkg_perf_status = 0;
  	p->rapl_dram_perf_status = 0;
  	p->pkg_temp_c = 0;
++<<<<<<< HEAD
++=======
+ 
+ 	p->gfx_rc6_ms = 0;
+ 	p->gfx_mhz = 0;
++>>>>>>> fdf676e51f30 (tools/power turbostat: show GFX%rc6)
  }
  int sum_counters(struct thread_data *t, struct core_data *c,
  	struct pkg_data *p)
@@@ -907,6 -987,9 +951,12 @@@
  	average.packages.energy_cores += p->energy_cores;
  	average.packages.energy_gfx += p->energy_gfx;
  
++<<<<<<< HEAD
++=======
+ 	average.packages.gfx_rc6_ms = p->gfx_rc6_ms;
+ 	average.packages.gfx_mhz = p->gfx_mhz;
+ 
++>>>>>>> fdf676e51f30 (tools/power turbostat: show GFX%rc6)
  	average.packages.pkg_temp_c = MAX(average.packages.pkg_temp_c, p->pkg_temp_c);
  
  	average.packages.rapl_pkg_perf_status += p->rapl_pkg_perf_status;
@@@ -1121,6 -1205,13 +1171,16 @@@ int get_counters(struct thread_data *t
  			return -17;
  		p->pkg_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (do_gfx_rc6_ms)
+ 		p->gfx_rc6_ms = gfx_cur_rc6_ms;
+ 
+ 	if (do_gfx_mhz)
+ 		p->gfx_mhz = gfx_cur_mhz;
+ 
++>>>>>>> fdf676e51f30 (tools/power turbostat: show GFX%rc6)
  	return 0;
  }
  
@@@ -1692,6 -1798,136 +1752,139 @@@ int mark_cpu_present(int cpu
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * snapshot_proc_interrupts()
+  *
+  * read and record summary of /proc/interrupts
+  *
+  * return 1 if config change requires a restart, else return 0
+  */
+ int snapshot_proc_interrupts(void)
+ {
+ 	static FILE *fp;
+ 	int column, retval;
+ 
+ 	if (fp == NULL)
+ 		fp = fopen_or_die("/proc/interrupts", "r");
+ 	else
+ 		rewind(fp);
+ 
+ 	/* read 1st line of /proc/interrupts to get cpu* name for each column */
+ 	for (column = 0; column < topo.num_cpus; ++column) {
+ 		int cpu_number;
+ 
+ 		retval = fscanf(fp, " CPU%d", &cpu_number);
+ 		if (retval != 1)
+ 			break;
+ 
+ 		if (cpu_number > topo.max_cpu_num) {
+ 			warn("/proc/interrupts: cpu%d: > %d", cpu_number, topo.max_cpu_num);
+ 			return 1;
+ 		}
+ 
+ 		irq_column_2_cpu[column] = cpu_number;
+ 		irqs_per_cpu[cpu_number] = 0;
+ 	}
+ 
+ 	/* read /proc/interrupt count lines and sum up irqs per cpu */
+ 	while (1) {
+ 		int column;
+ 		char buf[64];
+ 
+ 		retval = fscanf(fp, " %s:", buf);	/* flush irq# "N:" */
+ 		if (retval != 1)
+ 			break;
+ 
+ 		/* read the count per cpu */
+ 		for (column = 0; column < topo.num_cpus; ++column) {
+ 
+ 			int cpu_number, irq_count;
+ 
+ 			retval = fscanf(fp, " %d", &irq_count);
+ 			if (retval != 1)
+ 				break;
+ 
+ 			cpu_number = irq_column_2_cpu[column];
+ 			irqs_per_cpu[cpu_number] += irq_count;
+ 
+ 		}
+ 
+ 		while (getc(fp) != '\n')
+ 			;	/* flush interrupt description */
+ 
+ 	}
+ 	return 0;
+ }
+ /*
+  * snapshot_gfx_rc6_ms()
+  *
+  * record snapshot of
+  * /sys/class/drm/card0/power/rc6_residency_ms
+  *
+  * return 1 if config change requires a restart, else return 0
+  */
+ int snapshot_gfx_rc6_ms(void)
+ {
+ 	FILE *fp;
+ 	int retval;
+ 
+ 	fp = fopen_or_die("/sys/class/drm/card0/power/rc6_residency_ms", "r");
+ 
+ 	retval = fscanf(fp, "%lld", &gfx_cur_rc6_ms);
+ 	if (retval != 1)
+ 		err(1, "GFX rc6");
+ 
+ 	fclose(fp);
+ 
+ 	return 0;
+ }
+ /*
+  * snapshot_gfx_mhz()
+  *
+  * record snapshot of
+  * /sys/class/graphics/fb0/device/drm/card0/gt_cur_freq_mhz
+  *
+  * return 1 if config change requires a restart, else return 0
+  */
+ int snapshot_gfx_mhz(void)
+ {
+ 	static FILE *fp;
+ 	int retval;
+ 
+ 	if (fp == NULL)
+ 		fp = fopen_or_die("/sys/class/graphics/fb0/device/drm/card0/gt_cur_freq_mhz", "r");
+ 	else
+ 		rewind(fp);
+ 
+ 	retval = fscanf(fp, "%d", &gfx_cur_mhz);
+ 	if (retval != 1)
+ 		err(1, "GFX MHz");
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * snapshot /proc and /sys files
+  *
+  * return 1 if configuration restart needed, else return 0
+  */
+ int snapshot_proc_sysfs_files(void)
+ {
+ 	if (snapshot_proc_interrupts())
+ 		return 1;
+ 
+ 	if (do_gfx_rc6_ms)
+ 		snapshot_gfx_rc6_ms();
+ 
+ 	if (do_gfx_mhz)
+ 		snapshot_gfx_mhz();
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> fdf676e51f30 (tools/power turbostat: show GFX%rc6)
  void turbostat_loop()
  {
  	int retval;
@@@ -2856,6 -3200,10 +3049,13 @@@ void process_cpuid(
  	if (has_skl_msrs(family, model))
  		calculate_tsc_tweak();
  
++<<<<<<< HEAD
++=======
+ 	do_gfx_rc6_ms = !access("/sys/class/drm/card0/power/rc6_residency_ms", R_OK);
+ 
+ 	do_gfx_mhz = !access("/sys/class/graphics/fb0/device/drm/card0/gt_cur_freq_mhz", R_OK);
+ 
++>>>>>>> fdf676e51f30 (tools/power turbostat: show GFX%rc6)
  	return;
  }
  
* Unmerged path tools/power/x86/turbostat/turbostat.c
