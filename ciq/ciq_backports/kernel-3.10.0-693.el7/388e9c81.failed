tools/power turbostat: Make extensible via the --add parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [tools] power turbostat: Make extensible via the --add parameter (Prarit Bhargava) [1422076]
Rebuild_FUZZ: 94.92%
commit-author Len Brown <len.brown@intel.com>
commit 388e9c8134be6bbc3751ba7072f5fa9bc8ecbe01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/388e9c81.failed

Create the "--add" parameter.  This can be used to teach an existing
turbostat binary about any number of any type of counter.

turbostat(8) details the syntax for --add.

	Signed-off-by: Len Brown <len.brown@intel.com>
(cherry picked from commit 388e9c8134be6bbc3751ba7072f5fa9bc8ecbe01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/power/x86/turbostat/turbostat.c
diff --cc tools/power/x86/turbostat/turbostat.c
index 92e6f5e6c99d,4490a776bbae..000000000000
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@@ -133,7 -147,12 +133,16 @@@ double discover_bclk(unsigned int famil
  
  #define MAX(a, b) ((a) > (b) ? (a) : (b))
  
++<<<<<<< HEAD
 +int aperf_mperf_unstable;
++=======
+ /*
+  * buffer size used by sscanf() for added column names
+  * Usually truncated to 7 characters, but also handles 18 columns for raw 64-bit counters
+  */
+ #define	NAME_BYTES 20
+ 
++>>>>>>> 388e9c8134be (tools/power turbostat: Make extensible via the --add parameter)
  int backwards_count;
  char *progname;
  
@@@ -290,57 -350,93 +323,91 @@@ int get_msr(int cpu, off_t offset, unsi
  /*
   * Example Format w/ field column widths:
   *
++<<<<<<< HEAD
 + *  Package    Core     CPU Avg_MHz Bzy_MHz TSC_MHz     SMI   %Busy CPU_%c1 CPU_%c3 CPU_%c6 CPU_%c7 CoreTmp  PkgTmp Pkg%pc2 Pkg%pc3 Pkg%pc6 Pkg%pc7 PkgWatt CorWatt GFXWatt
 + * 123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678
++=======
+  *  Package    Core     CPU Avg_MHz Bzy_MHz TSC_MHz     IRQ   SMI   Busy% CPU_%c1 CPU_%c3 CPU_%c6 CPU_%c7 ThreadC CoreTmp  CoreCnt PkgTmp  GFXMHz Pkg%pc2 Pkg%pc3 Pkg%pc6 Pkg%pc7 PkgWatt CorWatt GFXWatt PkgCnt
+  * 12345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678
++>>>>>>> 388e9c8134be (tools/power turbostat: Make extensible via the --add parameter)
   */
  
  void print_header(void)
  {
+ 	struct msr_counter *mp;
+ 
  	if (show_pkg)
 -		outp += sprintf(outp, "\tPackage");
 +		outp += sprintf(outp, " Package");
  	if (show_core)
 -		outp += sprintf(outp, "\tCore");
 +		outp += sprintf(outp, "    Core");
  	if (show_cpu)
 -		outp += sprintf(outp, "\tCPU");
 +		outp += sprintf(outp, "     CPU");
  	if (has_aperf)
 -		outp += sprintf(outp, "\tAvg_MHz");
 +		outp += sprintf(outp, " Avg_MHz");
  	if (has_aperf)
 -		outp += sprintf(outp, "\tBusy%%");
 +		outp += sprintf(outp, "   %%Busy");
  	if (has_aperf)
 -		outp += sprintf(outp, "\tBzy_MHz");
 -	outp += sprintf(outp, "\tTSC_MHz");
 +		outp += sprintf(outp, " Bzy_MHz");
 +	outp += sprintf(outp, " TSC_MHz");
  
  	if (extra_delta_offset32)
 -		outp += sprintf(outp, "\tcount 0x%03X", extra_delta_offset32);
 +		outp += sprintf(outp, "  count 0x%03X", extra_delta_offset32);
  	if (extra_delta_offset64)
 -		outp += sprintf(outp, "\tCOUNT 0x%03X", extra_delta_offset64);
 +		outp += sprintf(outp, "  COUNT 0x%03X", extra_delta_offset64);
  	if (extra_msr_offset32)
 -		outp += sprintf(outp, "\t         MSR 0x%03X", extra_msr_offset32);
 +		outp += sprintf(outp, "   MSR 0x%03X", extra_msr_offset32);
  	if (extra_msr_offset64)
 -		outp += sprintf(outp, "\tMSR 0x%03X", extra_msr_offset64);
 +		outp += sprintf(outp, "           MSR 0x%03X", extra_msr_offset64);
  
 -	if (!debug)
 -		goto done;
 -
 -	if (do_irq)
 -		outp += sprintf(outp, "\tIRQ");
  	if (do_smi)
 -		outp += sprintf(outp, "\tSMI");
 +		outp += sprintf(outp, "     SMI");
  
  	if (do_nhm_cstates)
 -		outp += sprintf(outp, "\tCPU%%c1");
 +		outp += sprintf(outp, "  CPU%%c1");
  	if (do_nhm_cstates && !do_slm_cstates && !do_knl_cstates)
 -		outp += sprintf(outp, "\tCPU%%c3");
 +		outp += sprintf(outp, "  CPU%%c3");
  	if (do_nhm_cstates)
 -		outp += sprintf(outp, "\tCPU%%c6");
 +		outp += sprintf(outp, "  CPU%%c6");
  	if (do_snb_cstates)
 -		outp += sprintf(outp, "\tCPU%%c7");
 +		outp += sprintf(outp, "  CPU%%c7");
  
+ 	for (mp = sys.tp; mp; mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 64)
+ 				outp += sprintf(outp, "\t%18.18s", mp->name);
+ 			else
+ 				outp += sprintf(outp, "\t%10.10s", mp->name);
+ 		} else {
+ 			outp += sprintf(outp, "\t%-7.7s", mp->name);
+ 		}
+ 	}
+ 
  	if (do_dts)
++<<<<<<< HEAD
 +		outp += sprintf(outp, " CoreTmp");
++=======
+ 		outp += sprintf(outp, "\tCoreTmp");
+ 
+ 	for (mp = sys.cp; mp; mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 64)
+ 				outp += sprintf(outp, "\t%18.18s", mp->name);
+ 			else
+ 				outp += sprintf(outp, "\t%10.10s", mp->name);
+ 		} else {
+ 			outp += sprintf(outp, "\t%-7.7s", mp->name);
+ 		}
+ 	}
+ 
++>>>>>>> 388e9c8134be (tools/power turbostat: Make extensible via the --add parameter)
  	if (do_ptm)
 -		outp += sprintf(outp, "\tPkgTmp");
 -
 -	if (do_gfx_rc6_ms)
 -		outp += sprintf(outp, "\tGFX%%rc6");
 -
 -	if (do_gfx_mhz)
 -		outp += sprintf(outp, "\tGFXMHz");
 +		outp += sprintf(outp, "  PkgTmp");
  
  	if (do_skl_residency) {
 -		outp += sprintf(outp, "\tTotl%%C0");
 -		outp += sprintf(outp, "\tAny%%C0");
 -		outp += sprintf(outp, "\tGFX%%C0");
 -		outp += sprintf(outp, "\tCPUGFX%%");
 +		outp += sprintf(outp, " Totl%%C0");
 +		outp += sprintf(outp, "  Any%%C0");
 +		outp += sprintf(outp, "  GFX%%C0");
 +		outp += sprintf(outp, " CPUGFX%%");
  	}
  
  	if (do_pc2)
@@@ -359,31 -455,43 +426,46 @@@
  
  	if (do_rapl && !rapl_joules) {
  		if (do_rapl & RAPL_PKG)
 -			outp += sprintf(outp, "\tPkgWatt");
 +			outp += sprintf(outp, " PkgWatt");
  		if (do_rapl & RAPL_CORES_ENERGY_STATUS)
 -			outp += sprintf(outp, "\tCorWatt");
 +			outp += sprintf(outp, " CorWatt");
  		if (do_rapl & RAPL_GFX)
 -			outp += sprintf(outp, "\tGFXWatt");
 +			outp += sprintf(outp, " GFXWatt");
  		if (do_rapl & RAPL_DRAM)
 -			outp += sprintf(outp, "\tRAMWatt");
 +			outp += sprintf(outp, " RAMWatt");
  		if (do_rapl & RAPL_PKG_PERF_STATUS)
 -			outp += sprintf(outp, "\tPKG_%%");
 +			outp += sprintf(outp, "   PKG_%%");
  		if (do_rapl & RAPL_DRAM_PERF_STATUS)
 -			outp += sprintf(outp, "\tRAM_%%");
 +			outp += sprintf(outp, "   RAM_%%");
  	} else if (do_rapl && rapl_joules) {
  		if (do_rapl & RAPL_PKG)
 -			outp += sprintf(outp, "\tPkg_J");
 +			outp += sprintf(outp, "   Pkg_J");
  		if (do_rapl & RAPL_CORES_ENERGY_STATUS)
 -			outp += sprintf(outp, "\tCor_J");
 +			outp += sprintf(outp, "   Cor_J");
  		if (do_rapl & RAPL_GFX)
 -			outp += sprintf(outp, "\tGFX_J");
 +			outp += sprintf(outp, "   GFX_J");
  		if (do_rapl & RAPL_DRAM)
 -			outp += sprintf(outp, "\tRAM_J");
 +			outp += sprintf(outp, "   RAM_J");
  		if (do_rapl & RAPL_PKG_PERF_STATUS)
 -			outp += sprintf(outp, "\tPKG_%%");
 +			outp += sprintf(outp, "   PKG_%%");
  		if (do_rapl & RAPL_DRAM_PERF_STATUS)
 -			outp += sprintf(outp, "\tRAM_%%");
 +			outp += sprintf(outp, "   RAM_%%");
  	}
++<<<<<<< HEAD
++=======
+ 	for (mp = sys.pp; mp; mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 64)
+ 				outp += sprintf(outp, "\t%18.18s", mp->name);
+ 			else
+ 				outp += sprintf(outp, "\t%10.10s", mp->name);
+ 		} else {
+ 			outp += sprintf(outp, "\t%-7.7s", mp->name);
+ 		}
+ 	}
+ 
+ done:
++>>>>>>> 388e9c8134be (tools/power turbostat: Make extensible via the --add parameter)
  	outp += sprintf(outp, "\n");
  }
  
@@@ -407,8 -518,15 +492,13 @@@ int dump_counters(struct thread_data *t
  			extra_msr_offset32, t->extra_msr32);
  		outp += sprintf(outp, "msr0x%x: %016llX\n",
  			extra_msr_offset64, t->extra_msr64);
 -		if (do_irq)
 -			outp += sprintf(outp, "IRQ: %08X\n", t->irq_count);
  		if (do_smi)
  			outp += sprintf(outp, "SMI: %08X\n", t->smi_count);
+ 
+ 		for (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {
+ 			outp += sprintf(outp, "tADDED [%d] msr0x%x: %08llX\n",
+ 				i, mp->msr_num, t->counter[i]);
+ 		}
  	}
  
  	if (c) {
@@@ -553,15 -682,42 +655,42 @@@ int format_counters(struct thread_data 
  		goto done;
  
  	if (do_nhm_cstates && !do_slm_cstates && !do_knl_cstates)
 -		outp += sprintf(outp, "\t%.2f", 100.0 * c->c3/t->tsc);
 +		outp += sprintf(outp, "%8.2f", 100.0 * c->c3/t->tsc);
  	if (do_nhm_cstates)
 -		outp += sprintf(outp, "\t%.2f", 100.0 * c->c6/t->tsc);
 +		outp += sprintf(outp, "%8.2f", 100.0 * c->c6/t->tsc);
  	if (do_snb_cstates)
 -		outp += sprintf(outp, "\t%.2f", 100.0 * c->c7/t->tsc);
 +		outp += sprintf(outp, "%8.2f", 100.0 * c->c7/t->tsc);
  
+ 	for (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 32)
+ 				outp += sprintf(outp, "\t0x%08lx", (unsigned long) t->counter[i]);
+ 			else
+ 				outp += sprintf(outp, "\t0x%016llx", t->counter[i]);
+ 		} else if (mp->format == FORMAT_DELTA) {
+ 			outp += sprintf(outp, "\t%8lld", t->counter[i]);
+ 		} else if (mp->format == FORMAT_PERCENT) {
+ 			outp += sprintf(outp, "\t%.2f", 100.0 * t->counter[i]/t->tsc);
+ 		}
+ 	}
+ 
+ 
  	if (do_dts)
 -		outp += sprintf(outp, "\t%d", c->core_temp_c);
 +		outp += sprintf(outp, "%8d", c->core_temp_c);
  
+ 	for (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW) {
+ 			if (mp->width == 32)
+ 				outp += sprintf(outp, "\t0x%08lx", (unsigned long) c->counter[i]);
+ 			else
+ 				outp += sprintf(outp, "\t0x%016llx", c->counter[i]);
+ 		} else if (mp->format == FORMAT_DELTA) {
+ 			outp += sprintf(outp, "\t%8lld", c->counter[i]);
+ 		} else if (mp->format == FORMAT_PERCENT) {
+ 			outp += sprintf(outp, "\t%.2f", 100.0 * c->counter[i]/t->tsc);
+ 		}
+ 	}
+ 
  	/* print per-package data only for 1st core in package */
  	if (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))
  		goto done;
@@@ -675,9 -867,11 +817,11 @@@ void format_all_counters(struct thread_
  		old = 0x100000000 + new - old;	\
  	}
  
 -int
 +void
  delta_package(struct pkg_data *new, struct pkg_data *old)
  {
+ 	int i;
+ 	struct msr_counter *mp;
  
  	if (do_skl_residency) {
  		old->pkg_wtd_core_c0 = new->pkg_wtd_core_c0 - old->pkg_wtd_core_c0;
@@@ -703,6 -905,15 +847,18 @@@
  	DELTA_WRAP32(new->energy_dram, old->energy_dram);
  	DELTA_WRAP32(new->rapl_pkg_perf_status, old->rapl_pkg_perf_status);
  	DELTA_WRAP32(new->rapl_dram_perf_status, old->rapl_dram_perf_status);
++<<<<<<< HEAD
++=======
+ 
+ 	for (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW)
+ 			old->counter[i] = new->counter[i];
+ 		else
+ 			old->counter[i] = new->counter[i] - old->counter[i];
+ 	}
+ 
+ 	return 0;
++>>>>>>> 388e9c8134be (tools/power turbostat: Make extensible via the --add parameter)
  }
  
  void
@@@ -790,8 -1002,19 +959,19 @@@ delta_thread(struct thread_data *new, s
  	old->extra_msr32 = new->extra_msr32;
  	old->extra_msr64 = new->extra_msr64;
  
 -	if (do_irq)
 -		old->irq_count = new->irq_count - old->irq_count;
 -
  	if (do_smi)
  		old->smi_count = new->smi_count - old->smi_count;
++<<<<<<< HEAD
++=======
+ 
+ 	for (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW)
+ 			old->counter[i] = new->counter[i];
+ 		else
+ 			old->counter[i] = new->counter[i] - old->counter[i];
+ 	}
+ 	return 0;
++>>>>>>> 388e9c8134be (tools/power turbostat: Make extensible via the --add parameter)
  }
  
  int delta_cpu(struct thread_data *t, struct core_data *c,
@@@ -854,6 -1086,18 +1037,21 @@@ void clear_counters(struct thread_data 
  	p->rapl_pkg_perf_status = 0;
  	p->rapl_dram_perf_status = 0;
  	p->pkg_temp_c = 0;
++<<<<<<< HEAD
++=======
+ 
+ 	p->gfx_rc6_ms = 0;
+ 	p->gfx_mhz = 0;
+ 
+ 	for (i = 0, mp = sys.tp; mp; i++, mp = mp->next)
+ 		t->counter[i] = 0;
+ 
+ 	for (i = 0, mp = sys.cp; mp; i++, mp = mp->next)
+ 		c->counter[i] = 0;
+ 
+ 	for (i = 0, mp = sys.pp; mp; i++, mp = mp->next)
+ 		p->counter[i] = 0;
++>>>>>>> 388e9c8134be (tools/power turbostat: Make extensible via the --add parameter)
  }
  int sum_counters(struct thread_data *t, struct core_data *c,
  	struct pkg_data *p)
@@@ -866,6 -1113,15 +1067,18 @@@
  	average.threads.extra_delta32 += t->extra_delta32;
  	average.threads.extra_delta64 += t->extra_delta64;
  
++<<<<<<< HEAD
++=======
+ 	average.threads.irq_count += t->irq_count;
+ 	average.threads.smi_count += t->smi_count;
+ 
+ 	for (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {
+ 		if (mp->format == FORMAT_RAW)
+ 			continue;
+ 		average.threads.counter[i] += t->counter[i];
+ 	}
+ 
++>>>>>>> 388e9c8134be (tools/power turbostat: Make extensible via the --add parameter)
  	/* sum per-core values only for 1st thread in core */
  	if (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))
  		return 0;
@@@ -973,9 -1262,12 +1217,15 @@@ int get_counters(struct thread_data *t
  {
  	int cpu = t->cpu_id;
  	unsigned long long msr;
++<<<<<<< HEAD
++=======
+ 	int aperf_mperf_retry_count = 0;
+ 	struct msr_counter *mp;
+ 	int i;
++>>>>>>> 388e9c8134be (tools/power turbostat: Make extensible via the --add parameter)
  
  	if (cpu_migrate(cpu)) {
 -		fprintf(outf, "Could not migrate to CPU %d\n", cpu);
 +		fprintf(stderr, "Could not migrate to CPU %d\n", cpu);
  		return -1;
  	}
  
@@@ -1117,6 -1469,18 +1377,21 @@@
  			return -17;
  		p->pkg_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (do_gfx_rc6_ms)
+ 		p->gfx_rc6_ms = gfx_cur_rc6_ms;
+ 
+ 	if (do_gfx_mhz)
+ 		p->gfx_mhz = gfx_cur_mhz;
+ 
+ 	for (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {
+ 		if (get_msr(cpu, mp->msr_num, &p->counter[i]))
+ 			return -10;
+ 	}
+ 
++>>>>>>> 388e9c8134be (tools/power turbostat: Make extensible via the --add parameter)
  	return 0;
  }
  
@@@ -3180,7 -3960,7 +3457,11 @@@ int get_and_dump_counters(void
  }
  
  void print_version() {
++<<<<<<< HEAD
 +	fprintf(stderr, "turbostat version 4.12 5 Apr 2016"
++=======
+ 	fprintf(outf, "turbostat version 4.15 21 Dec 2016"
++>>>>>>> 388e9c8134be (tools/power turbostat: Make extensible via the --add parameter)
  		" - Len Brown <lenb@kernel.org>\n");
  }
  
@@@ -3209,9 -4139,12 +3640,12 @@@ void cmdline(int argc, char **argv
  
  	progname = argv[0];
  
 -	while ((opt = getopt_long_only(argc, argv, "+C:c:Ddhi:JM:m:o:PpST:v",
 +	while ((opt = getopt_long_only(argc, argv, "+C:c:Ddvhi:JM:m:PpST:V",
  				long_options, &option_index)) != -1) {
  		switch (opt) {
+ 		case 'a':
+ 			parse_add_command(optarg);
+ 			break;
  		case 'C':
  			sscanf(optarg, "%x", &extra_delta_offset64);
  			break;
diff --git a/tools/power/x86/turbostat/turbostat.8 b/tools/power/x86/turbostat/turbostat.8
index a7cc18d34bc1..a10579ad215d 100644
--- a/tools/power/x86/turbostat/turbostat.8
+++ b/tools/power/x86/turbostat/turbostat.8
@@ -25,6 +25,28 @@ Some information is not available on older processors.
 .SS Options
 Options can be specified with a single or double '-', and only as much of the option
 name as necessary to disambiguate it from others is necessary.  Note that options are case-sensitive.
+.PP
+\fB--add attributes\fP add column with counter having specified 'attributes'.  The 'location' attribute is required, all others are optional.
+.nf
+	location: {\fBmsrDDD\fP | \fBmsr0xXXX\fP}
+		msrDDD is a decimal offset, eg. msr16
+		msr0xXXX is a hex offset, eg. msr0x10
+
+	scope: {\fBcpu\fP | \fBcore\fP | \fBpackage\fP}
+		sample and print the counter for every cpu, core, or package.
+		default: cpu
+
+	size: {\fBu32\fP | \fBu64\fP }
+		MSRs are read as 64-bits, u32 truncates the displayed value to 32-bits.
+		default: u64
+
+	format: {\fBraw\fP | \fBdelta\fP | \fBpercent\fP}
+		'raw' shows the MSR contents in hex.
+		'delta' shows the difference in values during the measurement interval.
+		'percent' shows the delta as a percentage of the cycles elapsed.
+		default: delta
+.fi
+.PP
 \fB--Counter MSR#\fP shows the delta of the specified 64-bit MSR counter.
 .PP
 \fB--counter MSR#\fP shows the delta of the specified 32-bit MSR counter.
* Unmerged path tools/power/x86/turbostat/turbostat.c
