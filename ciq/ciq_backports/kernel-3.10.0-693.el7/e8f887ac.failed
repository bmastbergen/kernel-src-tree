net/mlx5e: Introduce tc offload support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Introduce tc offload support (Don Dutile) [1417284]
Rebuild_FUZZ: 94.59%
commit-author Amir Vadai <amir@vadai.me>
commit e8f887ac6a45ecb7f881f278a3fed1fbf002ef0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e8f887ac.failed

Extend ndo_setup_tc() to support ingress tc offloading. Will be used by
later patches to offload tc flower filter.

Feature is off by default and could be enabled by issuing:
 # ethtool  -K eth0 hw-tc-offload on

Offloads flow table is dynamically created when first filter is
added.
Rules are saved in a hash table that is maintained by the consumer (for
example - the flower offload in the next patch).
When last filter is removed and no filters exist in the hash table, the
offload flow table is destroyed.

	Signed-off-by: Amir Vadai <amir@vadai.me>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e8f887ac6a45ecb7f881f278a3fed1fbf002ef0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 3784a00cd751,4fc45ee0c5d1..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -6,7 -6,6 +6,11 @@@ mlx5_core-y :=	main.o cmd.o debugfs.o f
  
  mlx5_core-$(CONFIG_MLX5_CORE_EN) += wq.o eswitch.o \
  		en_main.o en_fs.o en_ethtool.o en_tx.o en_rx.o \
++<<<<<<< HEAD
 +		en_txrx.o en_clock.o
++=======
+ 		en_txrx.o en_clock.o vxlan.o en_tc.o
++>>>>>>> e8f887ac6a45 (net/mlx5e: Introduce tc offload support)
  
 +mlx5_core-$(CONFIG_MLX5_CORE_EN_VXLAN) += vxlan.o
  mlx5_core-$(CONFIG_MLX5_CORE_EN_DCB) +=  en_dcbnl.o
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index ae009c7fda21,e6210485e128..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -2332,60 -1957,41 +2346,96 @@@ static int set_feature_rx_vlan(struct n
  
  	mutex_lock(&priv->state_lock);
  
 +	priv->params.vlan_strip_disable = !enable;
 +	err = mlx5e_modify_rqs_vsd(priv, !enable);
 +	if (err)
 +		priv->params.vlan_strip_disable = enable;
 +
 +	mutex_unlock(&priv->state_lock);
 +
 +	return err;
 +}
 +
 +static int mlx5e_handle_feature(struct net_device *netdev,
 +				netdev_features_t wanted_features,
 +				netdev_features_t feature,
 +				mlx5e_feature_handler feature_handler)
 +{
 +	netdev_features_t changes = wanted_features ^ netdev->features;
 +	bool enable = !!(wanted_features & feature);
 +	int err;
 +
 +	if (!(changes & feature))
 +		return 0;
 +
 +	err = feature_handler(netdev, enable);
 +	if (err) {
 +		netdev_err(netdev, "%s feature 0x%llx failed err %d\n",
 +			   enable ? "Enable" : "Disable", feature, err);
 +		return err;
 +	}
 +
 +	MLX5E_SET_FEATURE(netdev, feature, enable);
 +	return 0;
 +}
 +
 +static int mlx5e_set_features(struct net_device *netdev,
 +			      netdev_features_t features)
 +{
 +	int err;
 +
 +	err  = mlx5e_handle_feature(netdev, features, NETIF_F_LRO,
 +				    set_feature_lro);
 +	err |= mlx5e_handle_feature(netdev, features,
 +				    NETIF_F_HW_VLAN_CTAG_FILTER,
 +				    set_feature_vlan_filter);
 +	err |= mlx5e_handle_feature(netdev, features, NETIF_F_RXALL,
 +				    set_feature_rx_all);
 +	err |= mlx5e_handle_feature(netdev, features, NETIF_F_HW_VLAN_CTAG_RX,
 +				    set_feature_rx_vlan);
 +
++<<<<<<< HEAD
 +	return err ? -EINVAL : 0;
++=======
+ 	if (changes & NETIF_F_LRO) {
+ 		bool was_opened = test_bit(MLX5E_STATE_OPENED, &priv->state);
+ 
+ 		if (was_opened)
+ 			mlx5e_close_locked(priv->netdev);
+ 
+ 		priv->params.lro_en = !!(features & NETIF_F_LRO);
+ 		err = mlx5e_modify_tirs_lro(priv);
+ 		if (err)
+ 			mlx5_core_warn(priv->mdev, "lro modify failed, %d\n",
+ 				       err);
+ 
+ 		if (was_opened)
+ 			err = mlx5e_open_locked(priv->netdev);
+ 	}
+ 
+ 	mutex_unlock(&priv->state_lock);
+ 
+ 	if (changes & NETIF_F_HW_VLAN_CTAG_FILTER) {
+ 		if (features & NETIF_F_HW_VLAN_CTAG_FILTER)
+ 			mlx5e_enable_vlan_filter(priv);
+ 		else
+ 			mlx5e_disable_vlan_filter(priv);
+ 	}
+ 
+ 	if ((changes & NETIF_F_HW_TC) && !(features & NETIF_F_HW_TC) &&
+ 	    mlx5e_tc_num_filters(priv)) {
+ 		netdev_err(netdev,
+ 			   "Active offloaded tc filters, can't turn hw_tc_offload off\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return err;
++>>>>>>> e8f887ac6a45 (net/mlx5e: Introduce tc offload support)
  }
  
 +#define MXL5_HW_MIN_MTU 64
 +#define MXL5E_MIN_MTU (MXL5_HW_MIN_MTU + ETH_FCS_LEN)
 +
  static int mlx5e_change_mtu(struct net_device *netdev, int new_mtu)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
@@@ -2929,8 -2396,12 +2979,17 @@@ static void mlx5e_build_netdev(struct n
  	if (!priv->params.lro_en)
  		netdev->features  &= ~NETIF_F_LRO;
  
++<<<<<<< HEAD
 +	if (fcs_enabled)
 +		netdev->features  &= ~NETIF_F_RXALL;
++=======
+ #define FT_CAP(f) MLX5_CAP_FLOWTABLE(mdev, flow_table_properties_nic_receive.f)
+ 	if (FT_CAP(flow_modify_en) &&
+ 	    FT_CAP(modify_root) &&
+ 	    FT_CAP(identified_miss_table_mode) &&
+ 	    FT_CAP(flow_table_modify))
+ 		priv->netdev->hw_features      |= NETIF_F_HW_TC;
++>>>>>>> e8f887ac6a45 (net/mlx5e: Introduce tc offload support)
  
  	netdev->features         |= NETIF_F_HIGHDMA;
  
@@@ -3123,23 -2535,21 +3186,34 @@@ static void *mlx5e_create_netdev(struc
  	err = register_netdev(netdev);
  	if (err) {
  		mlx5_core_err(mdev, "register_netdev failed, %d\n", err);
++<<<<<<< HEAD
 +		goto err_dealloc_q_counters;
++=======
+ 		goto err_tc_cleanup;
++>>>>>>> e8f887ac6a45 (net/mlx5e: Introduce tc offload support)
  	}
  
 -	if (mlx5e_vxlan_allowed(mdev))
 +	if (mlx5e_vxlan_allowed(mdev)) {
 +		rtnl_lock();
  		vxlan_get_rx_port(netdev);
 +		rtnl_unlock();
 +	}
  
  	mlx5e_enable_async_events(priv);
 -	schedule_work(&priv->set_rx_mode_work);
 +	queue_work(priv->wq, &priv->set_rx_mode_work);
  
  	return priv;
  
++<<<<<<< HEAD
 +
 +err_dealloc_q_counters:
 +	mlx5e_destroy_q_counter(priv);
++=======
+ err_tc_cleanup:
+ 	mlx5e_tc_cleanup(priv);
+ 
+ err_destroy_flow_tables:
++>>>>>>> e8f887ac6a45 (net/mlx5e: Introduce tc offload support)
  	mlx5e_destroy_flow_tables(priv);
  
  err_destroy_tirs:
@@@ -3185,25 -2592,19 +3259,31 @@@ static void mlx5e_destroy_netdev(struc
  
  	set_bit(MLX5E_STATE_DESTROYING, &priv->state);
  
 -	schedule_work(&priv->set_rx_mode_work);
 +	queue_work(priv->wq, &priv->set_rx_mode_work);
  	mlx5e_disable_async_events(priv);
++<<<<<<< HEAD
 +	flush_workqueue(priv->wq);
 +	if (test_bit(MLX5_INTERFACE_STATE_SHUTDOWN, &mdev->intf_state)) {
 +		netif_device_detach(netdev);
 +		mlx5e_close(netdev);
 +	} else {
 +		unregister_netdev(netdev);
 +	}
 +
++=======
+ 	flush_scheduled_work();
+ 	unregister_netdev(netdev);
+ 	mlx5e_tc_cleanup(priv);
++>>>>>>> e8f887ac6a45 (net/mlx5e: Introduce tc offload support)
  	mlx5e_vxlan_cleanup(priv);
 +	mlx5e_destroy_q_counter(priv);
  	mlx5e_destroy_flow_tables(priv);
  	mlx5e_destroy_tirs(priv);
 -	mlx5e_destroy_rqt(priv, MLX5E_SINGLE_RQ_RQT);
 -	mlx5e_destroy_rqt(priv, MLX5E_INDIRECTION_RQT);
 +	mlx5e_destroy_rqts(priv);
  	mlx5e_close_drop_rq(priv);
  	mlx5e_destroy_tises(priv);
 -	mlx5_core_destroy_mkey(priv->mdev, &priv->mr);
 +	mlx5_core_destroy_mkey(priv->mdev, &priv->umr_mkey);
 +	mlx5_core_destroy_mkey(priv->mdev, &priv->mkey);
  	mlx5_core_dealloc_transport_domain(priv->mdev, priv->tdn);
  	mlx5_core_dealloc_pd(priv->mdev, priv->pdn);
  	mlx5_unmap_free_uar(priv->mdev, &priv->cq_uar);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h
index f49539a1ae6e..6a4b4b26fb0b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@ -43,6 +43,7 @@
 #include <linux/mlx5/port.h>
 #include <linux/mlx5/vport.h>
 #include <linux/mlx5/transobj.h>
+#include <linux/rhashtable.h>
 #include "wq.h"
 #include "mlx5_core.h"
 #include "en_stats.h"
@@ -468,8 +469,16 @@ struct mlx5e_flow_table {
 	struct mlx5_flow_group		**g;
 };
 
+struct mlx5e_tc_flow_table {
+	struct mlx5_flow_table		*t;
+
+	struct rhashtable_params        ht_params;
+	struct rhashtable               ht;
+};
+
 struct mlx5e_flow_tables {
 	struct mlx5_flow_namespace	*ns;
+	struct mlx5e_tc_flow_table	tc;
 	struct mlx5e_flow_table		vlan;
 	struct mlx5e_flow_table		main;
 };
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
new file mode 100644
index 000000000000..1dc715d50244
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2016, Mellanox Technologies. All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include <linux/mlx5/fs.h>
+#include <linux/mlx5/device.h>
+#include <linux/rhashtable.h>
+#include "en.h"
+#include "en_tc.h"
+
+struct mlx5e_tc_flow {
+	struct rhash_head	node;
+	u64			cookie;
+	struct mlx5_flow_rule	*rule;
+};
+
+#define MLX5E_TC_FLOW_TABLE_NUM_ENTRIES 1024
+#define MLX5E_TC_FLOW_TABLE_NUM_GROUPS 4
+
+static struct mlx5_flow_rule *mlx5e_tc_add_flow(struct mlx5e_priv *priv,
+						u32 *match_c, u32 *match_v,
+						u32 action, u32 flow_tag)
+{
+	struct mlx5_flow_destination dest = {
+		.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE,
+		{.ft = priv->fts.vlan.t},
+	};
+	struct mlx5_flow_rule *rule;
+	bool table_created = false;
+
+	if (IS_ERR_OR_NULL(priv->fts.tc.t)) {
+		priv->fts.tc.t =
+			mlx5_create_auto_grouped_flow_table(priv->fts.ns, 0,
+							    MLX5E_TC_FLOW_TABLE_NUM_ENTRIES,
+							    MLX5E_TC_FLOW_TABLE_NUM_GROUPS);
+		if (IS_ERR(priv->fts.tc.t)) {
+			netdev_err(priv->netdev,
+				   "Failed to create tc offload table\n");
+			return ERR_CAST(priv->fts.tc.t);
+		}
+
+		table_created = true;
+	}
+
+	rule = mlx5_add_flow_rule(priv->fts.tc.t, MLX5_MATCH_OUTER_HEADERS,
+				  match_c, match_v,
+				  action, flow_tag,
+				  action & MLX5_FLOW_CONTEXT_ACTION_FWD_DEST ? &dest : NULL);
+
+	if (IS_ERR(rule) && table_created) {
+		mlx5_destroy_flow_table(priv->fts.tc.t);
+		priv->fts.tc.t = NULL;
+	}
+
+	return rule;
+}
+
+static void mlx5e_tc_del_flow(struct mlx5e_priv *priv,
+			      struct mlx5_flow_rule *rule)
+{
+	mlx5_del_flow_rule(rule);
+
+	if (!mlx5e_tc_num_filters(priv)) {
+		mlx5_destroy_flow_table(priv->fts.tc.t);
+		priv->fts.tc.t = NULL;
+	}
+}
+
+static const struct rhashtable_params mlx5e_tc_flow_ht_params = {
+	.head_offset = offsetof(struct mlx5e_tc_flow, node),
+	.key_offset = offsetof(struct mlx5e_tc_flow, cookie),
+	.key_len = sizeof(((struct mlx5e_tc_flow *)0)->cookie),
+	.automatic_shrinking = true,
+};
+
+int mlx5e_tc_init(struct mlx5e_priv *priv)
+{
+	struct mlx5e_tc_flow_table *tc = &priv->fts.tc;
+
+	tc->ht_params = mlx5e_tc_flow_ht_params;
+	return rhashtable_init(&tc->ht, &tc->ht_params);
+}
+
+static void _mlx5e_tc_del_flow(void *ptr, void *arg)
+{
+	struct mlx5e_tc_flow *flow = ptr;
+	struct mlx5e_priv *priv = arg;
+
+	mlx5e_tc_del_flow(priv, flow->rule);
+	kfree(flow);
+}
+
+void mlx5e_tc_cleanup(struct mlx5e_priv *priv)
+{
+	struct mlx5e_tc_flow_table *tc = &priv->fts.tc;
+
+	rhashtable_free_and_destroy(&tc->ht, _mlx5e_tc_del_flow, priv);
+
+	if (!IS_ERR_OR_NULL(priv->fts.tc.t)) {
+		mlx5_destroy_flow_table(priv->fts.tc.t);
+		priv->fts.tc.t = NULL;
+	}
+}
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
new file mode 100644
index 000000000000..46eacc582f13
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2016, Mellanox Technologies. All rights reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __MLX5_EN_TC_H__
+#define __MLX5_EN_TC_H__
+
+int mlx5e_tc_init(struct mlx5e_priv *priv);
+void mlx5e_tc_cleanup(struct mlx5e_priv *priv);
+
+static inline int mlx5e_tc_num_filters(struct mlx5e_priv *priv)
+{
+	return atomic_read(&priv->fts.tc.ht.nelems);
+}
+
+#endif /* __MLX5_EN_TC_H__ */
