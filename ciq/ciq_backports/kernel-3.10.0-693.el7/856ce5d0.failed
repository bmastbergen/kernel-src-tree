bridge: fix igmp / mld query parsing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Linus Lüssing <linus.luessing@c0d3.blue>
commit 856ce5d083e14571d051301fe3c65b32b8cbe321
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/856ce5d0.failed

With the newly introduced helper functions the skb pulling is hidden
in the checksumming function - and undone before returning to the
caller.

The IGMP and MLD query parsing functions in the bridge still
assumed that the skb is pointing to the beginning of the IGMP/MLD
message while it is now kept at the beginning of the IPv4/6 header.

If there is a querier somewhere else, then this either causes
the multicast snooping to stay disabled even though it could be
enabled. Or, if we have the querier enabled too, then this can
create unnecessary IGMP / MLD query messages on the link.

Fixing this by taking the offset between IP and IGMP/MLD header into
account, too.

Fixes: 9afd85c9e455 ("net: Export IGMP/MLD message validation code")
	Reported-by: Simon Wunderlich <sw@simonwunderlich.de>
	Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 856ce5d083e14571d051301fe3c65b32b8cbe321)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
diff --cc net/bridge/br_multicast.c
index f9002e7e306f,6852f3c7009c..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -1189,8 -1276,10 +1189,9 @@@ static int br_ip4_multicast_query(struc
  	struct igmpv3_query *ih3;
  	struct net_bridge_port_group *p;
  	struct net_bridge_port_group __rcu **pp;
 -	struct br_ip saddr;
  	unsigned long max_delay;
  	unsigned long now = jiffies;
+ 	unsigned int offset = skb_transport_offset(skb);
  	__be32 group;
  	int err = 0;
  
@@@ -1208,12 -1297,7 +1209,16 @@@
  			max_delay = 10 * HZ;
  			group = 0;
  		}
++<<<<<<< HEAD
 +	} else {
 +		if (!pskb_may_pull(skb, sizeof(struct igmpv3_query))) {
 +			err = -EINVAL;
 +			goto out;
 +		}
 +
++=======
+ 	} else if (skb->len >= offset + sizeof(*ih3)) {
++>>>>>>> 856ce5d083e1 (bridge: fix igmp / mld query parsing)
  		ih3 = igmpv3_query_hdr(skb);
  		if (ih3->nsrcs)
  			goto out;
@@@ -1274,8 -1355,10 +1279,9 @@@ static int br_ip6_multicast_query(struc
  	struct mld2_query *mld2q;
  	struct net_bridge_port_group *p;
  	struct net_bridge_port_group __rcu **pp;
 -	struct br_ip saddr;
  	unsigned long max_delay;
  	unsigned long now = jiffies;
+ 	unsigned int offset = skb_transport_offset(skb);
  	const struct in6_addr *group = NULL;
  	bool is_general_query;
  	int err = 0;
@@@ -1285,14 -1368,8 +1291,19 @@@
  	    (port && port->state == BR_STATE_DISABLED))
  		goto out;
  
++<<<<<<< HEAD
 +	/* RFC2710+RFC3810 (MLDv1+MLDv2) require link-local source addresses */
 +	if (!(ipv6_addr_type(&ip6h->saddr) & IPV6_ADDR_LINKLOCAL)) {
 +		err = -EINVAL;
 +		goto out;
 +	}
 +
 +	if (skb->len == sizeof(*mld)) {
 +		if (!pskb_may_pull(skb, sizeof(*mld))) {
++=======
+ 	if (skb->len == offset + sizeof(*mld)) {
+ 		if (!pskb_may_pull(skb, offset + sizeof(*mld))) {
++>>>>>>> 856ce5d083e1 (bridge: fix igmp / mld query parsing)
  			err = -EINVAL;
  			goto out;
  		}
* Unmerged path net/bridge/br_multicast.c
