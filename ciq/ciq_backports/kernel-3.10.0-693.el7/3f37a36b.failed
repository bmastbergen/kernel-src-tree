EDAC, amd64_edac: Drop pci_register_driver() use

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [edac] amd64_edac: Drop pci_register_driver() use (Suravee Suthikulpanit) [1303712]
Rebuild_FUZZ: 93.33%
commit-author Borislav Petkov <bp@suse.de>
commit 3f37a36b6282621d7c5a99b6911275f989766996
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3f37a36b.failed

- remove homegrown instances counting.
- take F3 PCI device from amd_nb caching instead of F2 which was used with the
PCI core.

With those changes, the driver doesn't need to register a PCI driver and
relies on the northbridges caching which we do anyway on AMD.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Cc: Yazen Ghannam <yazen.ghannam@amd.com>
(cherry picked from commit 3f37a36b6282621d7c5a99b6911275f989766996)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/amd64_edac.c
diff --cc drivers/edac/amd64_edac.c
index e233d8dbf7f6,624e2f78339c..000000000000
--- a/drivers/edac/amd64_edac.c
+++ b/drivers/edac/amd64_edac.c
@@@ -15,13 -15,7 +15,17 @@@ module_param(ecc_enable_override, int, 
  
  static struct msr __percpu *msrs;
  
++<<<<<<< HEAD
 +/*
 + * count successfully initialized driver instances for setup_pci_device()
 + */
 +static atomic_t drv_instances = ATOMIC_INIT(0);
 +
 +/* Per-node driver instances */
 +static struct mem_ctl_info **mcis;
++=======
+ /* Per-node stuff */
++>>>>>>> 3f37a36b6282 (EDAC, amd64_edac: Drop pci_register_driver() use)
  static struct ecc_settings **ecc_stngs;
  
  /*
@@@ -1958,6 -1970,16 +1962,19 @@@ static struct amd64_family_type family_
  			.dbam_to_cs		= f16_dbam_to_chip_select,
  		}
  	},
++<<<<<<< HEAD
++=======
+ 	[F16_M30H_CPUS] = {
+ 		.ctl_name = "F16h_M30h",
+ 		.f1_id = PCI_DEVICE_ID_AMD_16H_M30H_NB_F1,
+ 		.f2_id = PCI_DEVICE_ID_AMD_16H_M30H_NB_F2,
+ 		.ops = {
+ 			.early_channel_count	= f1x_early_channel_count,
+ 			.map_sysaddr_to_csrow	= f1x_map_sysaddr_to_csrow,
+ 			.dbam_to_cs		= f16_dbam_to_chip_select,
+ 		}
+ 	},
++>>>>>>> 3f37a36b6282 (EDAC, amd64_edac: Drop pci_register_driver() use)
  };
  
  /*
@@@ -2794,14 -2763,24 +2811,32 @@@ static struct amd64_family_type *per_fa
  	return fam_type;
  }
  
++<<<<<<< HEAD
 +static int init_one_instance(struct pci_dev *F2)
++=======
+ static const struct attribute_group *amd64_edac_attr_groups[] = {
+ #ifdef CONFIG_EDAC_DEBUG
+ 	&amd64_edac_dbg_group,
+ #endif
+ #ifdef CONFIG_EDAC_AMD64_ERROR_INJECTION
+ 	&amd64_edac_inj_group,
+ #endif
+ 	NULL
+ };
+ 
+ static int init_one_instance(unsigned int nid)
++>>>>>>> 3f37a36b6282 (EDAC, amd64_edac: Drop pci_register_driver() use)
  {
- 	struct amd64_pvt *pvt = NULL;
+ 	struct pci_dev *F3 = node_to_amd_nb(nid)->misc;
  	struct amd64_family_type *fam_type = NULL;
  	struct mem_ctl_info *mci = NULL;
  	struct edac_mc_layer layers[2];
+ 	struct amd64_pvt *pvt = NULL;
  	int err = 0, ret;
++<<<<<<< HEAD
 +	u16 nid = amd_get_node_id(F2);
++=======
++>>>>>>> 3f37a36b6282 (EDAC, amd64_edac: Drop pci_register_driver() use)
  
  	ret = -ENOMEM;
  	pvt = kzalloc(sizeof(struct amd64_pvt), GFP_KERNEL);
@@@ -2873,16 -2848,10 +2908,14 @@@
  	if (report_gart_errors)
  		amd_report_gart_errors(true);
  
 -	amd_register_ecc_decoder(decode_bus_error);
 +	amd_register_ecc_decoder(amd64_decode_bus_error);
 +
 +	mcis[nid] = mci;
  
- 	atomic_inc(&drv_instances);
- 
  	return 0;
  
 +err_add_sysfs:
 +	edac_mc_del_mc(mci->pdev);
  err_add_mc:
  	edac_mc_free(mci);
  
@@@ -2896,19 -2865,11 +2929,15 @@@ err_ret
  	return ret;
  }
  
- static int probe_one_instance(struct pci_dev *pdev,
- 			      const struct pci_device_id *mc_type)
+ static int probe_one_instance(unsigned int nid)
  {
++<<<<<<< HEAD
 +	u16 nid = amd_get_node_id(pdev);
++=======
++>>>>>>> 3f37a36b6282 (EDAC, amd64_edac: Drop pci_register_driver() use)
  	struct pci_dev *F3 = node_to_amd_nb(nid)->misc;
  	struct ecc_settings *s;
- 	int ret = 0;
- 
- 	ret = pci_enable_device(pdev);
- 	if (ret < 0) {
- 		edac_dbg(0, "ret=%d\n", ret);
- 		return -EIO;
- 	}
+ 	int ret;
  
  	ret = -ENOMEM;
  	s = kzalloc(sizeof(struct ecc_settings), GFP_KERNEL);
@@@ -2933,12 -2890,10 +2962,12 @@@
  			goto err_enable;
  	}
  
- 	ret = init_one_instance(pdev);
+ 	ret = init_one_instance(nid);
  	if (ret < 0) {
  		amd64_err("Error probing instance: %d\n", nid);
 -		restore_ecc_error_reporting(s, nid, F3);
 +
 +		if (boot_cpu_data.x86 < 0x17)
 +			restore_ecc_error_reporting(s, nid, F3);
  	}
  
  	return ret;
@@@ -2951,20 -2906,18 +2980,25 @@@ err_out
  	return ret;
  }
  
- static void remove_one_instance(struct pci_dev *pdev)
+ static void remove_one_instance(unsigned int nid)
  {
++<<<<<<< HEAD
 +	struct mem_ctl_info *mci;
 +	struct amd64_pvt *pvt;
 +	u16 nid = amd_get_node_id(pdev);
++=======
++>>>>>>> 3f37a36b6282 (EDAC, amd64_edac: Drop pci_register_driver() use)
  	struct pci_dev *F3 = node_to_amd_nb(nid)->misc;
  	struct ecc_settings *s = ecc_stngs[nid];
+ 	struct mem_ctl_info *mci;
+ 	struct amd64_pvt *pvt;
  
- 	mci = find_mci_by_dev(&pdev->dev);
+ 	mci = find_mci_by_dev(&F3->dev);
  	WARN_ON(!mci);
  
 +	del_mc_sysfs_attrs(mci);
  	/* Remove from EDAC CORE tracking list */
- 	mci = edac_mc_del_mc(&pdev->dev);
+ 	mci = edac_mc_del_mc(&F3->dev);
  	if (!mci)
  		return;
  
@@@ -2989,29 -2941,6 +3023,32 @@@
  	edac_mc_free(mci);
  }
  
++<<<<<<< HEAD
 +/*
 + * This table is part of the interface for loading drivers for PCI devices. The
 + * PCI core identifies what devices are on a system during boot, and then
 + * inquiry this table to see if this driver is for a given device found.
 + */
 +static const struct pci_device_id amd64_pci_table[] = {
 +	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_K8_NB_MEMCTL) },
 +	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_10H_NB_DRAM) },
 +	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_NB_F2) },
 +	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M30H_NB_F2) },
 +	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F2) },
 +	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_NB_F2) },
 +	{0, }
 +};
 +MODULE_DEVICE_TABLE(pci, amd64_pci_table);
 +
 +static struct pci_driver amd64_pci_driver = {
 +	.name		= EDAC_MOD_STR,
 +	.probe		= probe_one_instance,
 +	.remove		= remove_one_instance,
 +	.id_table	= amd64_pci_table,
 +};
 +
++=======
++>>>>>>> 3f37a36b6282 (EDAC, amd64_edac: Drop pci_register_driver() use)
  static void setup_pci_device(void)
  {
  	struct mem_ctl_info *mci;
@@@ -3035,9 -2964,8 +3072,10 @@@
  static int __init amd64_edac_init(void)
  {
  	int err = -ENODEV;
+ 	int i;
  
 +	printk(KERN_INFO "AMD64 EDAC driver v%s\n", EDAC_AMD64_VERSION);
 +
  	opstate_init();
  
  	if (amd_cache_northbridges() < 0)
@@@ -3053,20 -2980,25 +3091,18 @@@
  	if (!msrs)
  		goto err_free;
  
- 	err = pci_register_driver(&amd64_pci_driver);
- 	if (err)
- 		goto err_pci;
+ 	for (i = 0; i < amd_nb_num(); i++)
+ 		if (probe_one_instance(i)) {
+ 			/* unwind properly */
+ 			while (--i >= 0)
+ 				remove_one_instance(i);
  
- 	err = -ENODEV;
- 	if (!atomic_read(&drv_instances))
- 		goto err_no_instances;
+ 			goto err_pci;
+ 		}
  
  	setup_pci_device();
 -
 -#ifdef CONFIG_X86_32
 -	amd64_err("%s on 32-bit is unsupported. USE AT YOUR OWN RISK!\n", EDAC_MOD_STR);
 -#endif
 -
 -	printk(KERN_INFO "AMD64 EDAC driver v%s\n", EDAC_AMD64_VERSION);
 -
  	return 0;
  
- err_no_instances:
- 	pci_unregister_driver(&amd64_pci_driver);
- 
  err_pci:
  	msrs_free(msrs);
  	msrs = NULL;
* Unmerged path drivers/edac/amd64_edac.c
diff --git a/drivers/edac/amd64_edac.h b/drivers/edac/amd64_edac.h
index 42bc4a8e049e..18c85b4c5c07 100644
--- a/drivers/edac/amd64_edac.h
+++ b/drivers/edac/amd64_edac.h
@@ -507,7 +507,7 @@ struct low_ops {
 
 struct amd64_family_type {
 	const char *ctl_name;
-	u16 f1_id, f3_id;
+	u16 f1_id, f2_id;
 	struct low_ops ops;
 };
 
