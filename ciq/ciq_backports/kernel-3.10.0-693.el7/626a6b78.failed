perf tools: Enable overwrite settings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Wang Nan <wangnan0@huawei.com>
commit 626a6b784e91bc61ca9fe0f9dd5bb60cb91ccb6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/626a6b78.failed

This patch allows following config terms and option:

Globally setting events to overwrite;

  # perf record --overwrite ...

Set specific events to be overwrite or no-overwrite.

  # perf record --event cycles/overwrite/ ...
  # perf record --event cycles/no-overwrite/ ...

Add missing config terms and update the config term array size because
the longest string length has changed.

For overwritable events, it automatically selects attr.write_backward
since perf requires it to be backward for reading.

Test result:

  # perf record --overwrite -e syscalls:*enter_nanosleep* usleep 1
  [ perf record: Woken up 2 times to write data ]
  [ perf record: Captured and wrote 0.011 MB perf.data (1 samples) ]
  # perf evlist -v
  syscalls:sys_enter_nanosleep: type: 2, size: 112, config: 0x134, { sample_period, sample_freq }: 1, sample_type: IP|TID|TIME|CPU|PERIOD|RAW, disabled: 1, inherit: 1, mmap: 1, comm: 1, enable_on_exec: 1, task: 1, sample_id_all: 1, exclude_guest: 1, mmap2: 1, comm_exec: 1, write_backward: 1
  # Tip: use 'perf evlist --trace-fields' to show fields for tracepoint events

	Signed-off-by: Wang Nan <wangnan0@huawei.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Masami Hiramatsu <mhiramat@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Nilay Vaish <nilayvaish@gmail.com>
	Cc: Zefan Li <lizefan@huawei.com>
	Cc: pi3orama@163.com
Link: http://lkml.kernel.org/r/1468485287-33422-14-git-send-email-wangnan0@huawei.com
	Signed-off-by: He Kuang <hekuang@huawei.com>
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 626a6b784e91bc61ca9fe0f9dd5bb60cb91ccb6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-record.txt
#	tools/perf/tests/backward-ring-buffer.c
#	tools/perf/util/evsel.h
#	tools/perf/util/parse-events.c
#	tools/perf/util/parse-events.h
diff --cc tools/perf/Documentation/perf-record.txt
index 20052ecd742e,384c630436f8..000000000000
--- a/tools/perf/Documentation/perf-record.txt
+++ b/tools/perf/Documentation/perf-record.txt
@@@ -328,6 -347,40 +328,43 @@@ Configure all used events to run in ker
  --all-user::
  Configure all used events to run in user space.
  
++<<<<<<< HEAD
++=======
+ --timestamp-filename
+ Append timestamp to output file name.
+ 
+ --switch-output::
+ Generate multiple perf.data files, timestamp prefixed, switching to a new one
+ when receiving a SIGUSR2.
+ 
+ A possible use case is to, given an external event, slice the perf.data file
+ that gets then processed, possibly via a perf script, to decide if that
+ particular perf.data snapshot should be kept or not.
+ 
+ Implies --timestamp-filename, --no-buildid and --no-buildid-cache.
+ 
+ --dry-run::
+ Parse options then exit. --dry-run can be used to detect errors in cmdline
+ options.
+ 
+ 'perf record --dry-run -e' can act as a BPF script compiler if llvm.dump-obj
+ in config file is set to true.
+ 
+ --overwrite::
+ Makes all events use an overwritable ring buffer. An overwritable ring
+ buffer works like a flight recorder: when it gets full, the kernel will
+ overwrite the oldest records, that thus will never make it to the
+ perf.data file.
+ 
+ When '--overwrite' and '--switch-output' are used perf records and drops
+ events until it receives a signal, meaning that something unusual was
+ detected that warrants taking a snapshot of the most current events,
+ those fitting in the ring buffer at that moment.
+ 
+ 'overwrite' attribute can also be set or canceled for an event using
+ config terms. For example: 'cycles/overwrite/' and 'instructions/no-overwrite/'.
+ 
++>>>>>>> 626a6b784e91 (perf tools: Enable overwrite settings)
  SEE ALSO
  --------
  linkperf:perf-stat[1], linkperf:perf-list[1]
diff --cc tools/perf/tests/backward-ring-buffer.c
index d9ba991a9a30,615780cbfe1d..000000000000
--- a/tools/perf/tests/backward-ring-buffer.c
+++ b/tools/perf/tests/backward-ring-buffer.c
@@@ -117,10 -121,6 +121,13 @@@ int test__backward_ring_buffer(int subt
  
  	perf_evlist__config(evlist, &opts, NULL);
  
++<<<<<<< HEAD
 +	/* Set backward bit, ring buffer should be writing from end */
 +	evlist__for_each(evlist, evsel)
 +		evsel->attr.write_backward = 1;
 +
++=======
++>>>>>>> 626a6b784e91 (perf tools: Enable overwrite settings)
  	err = perf_evlist__open(evlist);
  	if (err < 0) {
  		pr_debug("perf_evlist__open: %s\n",
diff --cc tools/perf/util/evsel.h
index c7519fa90979,8a4a6c9f1480..000000000000
--- a/tools/perf/util/evsel.h
+++ b/tools/perf/util/evsel.h
@@@ -44,6 -44,8 +44,11 @@@ enum 
  	PERF_EVSEL__CONFIG_TERM_CALLGRAPH,
  	PERF_EVSEL__CONFIG_TERM_STACK_USER,
  	PERF_EVSEL__CONFIG_TERM_INHERIT,
++<<<<<<< HEAD
++=======
+ 	PERF_EVSEL__CONFIG_TERM_MAX_STACK,
+ 	PERF_EVSEL__CONFIG_TERM_OVERWRITE,
++>>>>>>> 626a6b784e91 (perf tools: Enable overwrite settings)
  	PERF_EVSEL__CONFIG_TERM_MAX,
  };
  
@@@ -56,7 -58,9 +61,8 @@@ struct perf_evsel_config_term 
  		bool	time;
  		char	*callgraph;
  		u64	stack_user;
 -		int	max_stack;
  		bool	inherit;
+ 		bool	overwrite;
  	} val;
  };
  
diff --cc tools/perf/util/parse-events.c
index a5b0d8e6c607,6c913c3914fb..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -675,6 -901,9 +675,12 @@@ static const char *config_term_names[__
  	[PARSE_EVENTS__TERM_TYPE_STACKSIZE]		= "stack-size",
  	[PARSE_EVENTS__TERM_TYPE_NOINHERIT]		= "no-inherit",
  	[PARSE_EVENTS__TERM_TYPE_INHERIT]		= "inherit",
++<<<<<<< HEAD
++=======
+ 	[PARSE_EVENTS__TERM_TYPE_MAX_STACK]		= "max-stack",
+ 	[PARSE_EVENTS__TERM_TYPE_OVERWRITE]		= "overwrite",
+ 	[PARSE_EVENTS__TERM_TYPE_NOOVERWRITE]		= "no-overwrite",
++>>>>>>> 626a6b784e91 (perf tools: Enable overwrite settings)
  };
  
  static bool config_term_shrinked;
@@@ -815,6 -1053,9 +827,12 @@@ static int config_term_tracepoint(struc
  	case PARSE_EVENTS__TERM_TYPE_STACKSIZE:
  	case PARSE_EVENTS__TERM_TYPE_INHERIT:
  	case PARSE_EVENTS__TERM_TYPE_NOINHERIT:
++<<<<<<< HEAD
++=======
+ 	case PARSE_EVENTS__TERM_TYPE_MAX_STACK:
+ 	case PARSE_EVENTS__TERM_TYPE_OVERWRITE:
+ 	case PARSE_EVENTS__TERM_TYPE_NOOVERWRITE:
++>>>>>>> 626a6b784e91 (perf tools: Enable overwrite settings)
  		return config_term_common(attr, term, err);
  	default:
  		if (err) {
@@@ -884,6 -1125,15 +902,18 @@@ do {								
  		case PARSE_EVENTS__TERM_TYPE_NOINHERIT:
  			ADD_CONFIG_TERM(INHERIT, inherit, term->val.num ? 0 : 1);
  			break;
++<<<<<<< HEAD
++=======
+ 		case PARSE_EVENTS__TERM_TYPE_MAX_STACK:
+ 			ADD_CONFIG_TERM(MAX_STACK, max_stack, term->val.num);
+ 			break;
+ 		case PARSE_EVENTS__TERM_TYPE_OVERWRITE:
+ 			ADD_CONFIG_TERM(OVERWRITE, overwrite, term->val.num ? 1 : 0);
+ 			break;
+ 		case PARSE_EVENTS__TERM_TYPE_NOOVERWRITE:
+ 			ADD_CONFIG_TERM(OVERWRITE, overwrite, term->val.num ? 0 : 1);
+ 			break;
++>>>>>>> 626a6b784e91 (perf tools: Enable overwrite settings)
  		default:
  			break;
  		}
diff --cc tools/perf/util/parse-events.h
index c93f61beef22,d1edbf8cc66a..000000000000
--- a/tools/perf/util/parse-events.h
+++ b/tools/perf/util/parse-events.h
@@@ -68,6 -68,9 +68,12 @@@ enum 
  	PARSE_EVENTS__TERM_TYPE_STACKSIZE,
  	PARSE_EVENTS__TERM_TYPE_NOINHERIT,
  	PARSE_EVENTS__TERM_TYPE_INHERIT,
++<<<<<<< HEAD
++=======
+ 	PARSE_EVENTS__TERM_TYPE_MAX_STACK,
+ 	PARSE_EVENTS__TERM_TYPE_NOOVERWRITE,
+ 	PARSE_EVENTS__TERM_TYPE_OVERWRITE,
++>>>>>>> 626a6b784e91 (perf tools: Enable overwrite settings)
  	__PARSE_EVENTS__TERM_TYPE_NR,
  };
  
* Unmerged path tools/perf/Documentation/perf-record.txt
diff --git a/tools/perf/builtin-record.c b/tools/perf/builtin-record.c
index 5f9433ee7668..fade294e355a 100644
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@ -1237,6 +1237,7 @@ struct option __record_options[] = {
 	OPT_BOOLEAN_SET('i', "no-inherit", &record.opts.no_inherit,
 			&record.opts.no_inherit_set,
 			"child tasks do not inherit counters"),
+	OPT_BOOLEAN(0, "overwrite", &record.opts.overwrite, "use overwrite mode"),
 	OPT_UINTEGER('F', "freq", &record.opts.user_freq, "profile at this frequency"),
 	OPT_CALLBACK('m', "mmap-pages", &record.opts, "pages[,pages]",
 		     "number of mmap data pages and AUX area tracing mmap pages",
diff --git a/tools/perf/perf.h b/tools/perf/perf.h
index 693cda7dcc6f..2f6f9328ff21 100644
--- a/tools/perf/perf.h
+++ b/tools/perf/perf.h
@@ -60,6 +60,7 @@ struct record_opts {
 	bool	     record_switch_events;
 	bool	     all_kernel;
 	bool	     all_user;
+	bool	     overwrite;
 	unsigned int freq;
 	unsigned int mmap_pages;
 	unsigned int auxtrace_mmap_pages;
* Unmerged path tools/perf/tests/backward-ring-buffer.c
diff --git a/tools/perf/util/evsel.c b/tools/perf/util/evsel.c
index c914890ab3f1..536c9ffa7a49 100644
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@ -678,6 +678,9 @@ static void apply_config_terms(struct perf_evsel *evsel,
 			 */
 			attr->inherit = term->val.inherit ? 1 : 0;
 			break;
+		case PERF_EVSEL__CONFIG_TERM_OVERWRITE:
+			attr->write_backward = term->val.overwrite ? 1 : 0;
+			break;
 		default:
 			break;
 		}
@@ -753,6 +756,7 @@ void perf_evsel__config(struct perf_evsel *evsel, struct record_opts *opts)
 
 	attr->sample_id_all = perf_missing_features.sample_id_all ? 0 : 1;
 	attr->inherit	    = !opts->no_inherit;
+	attr->write_backward = opts->overwrite ? 1 : 0;
 
 	perf_evsel__set_sample_bit(evsel, IP);
 	perf_evsel__set_sample_bit(evsel, TID);
* Unmerged path tools/perf/util/evsel.h
* Unmerged path tools/perf/util/parse-events.c
* Unmerged path tools/perf/util/parse-events.h
diff --git a/tools/perf/util/parse-events.l b/tools/perf/util/parse-events.l
index 1d4e9d370449..51ff10871181 100644
--- a/tools/perf/util/parse-events.l
+++ b/tools/perf/util/parse-events.l
@@ -188,6 +188,8 @@ call-graph		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_CALLGRAPH); }
 stack-size		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_STACKSIZE); }
 inherit			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_INHERIT); }
 no-inherit		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_NOINHERIT); }
+overwrite		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_OVERWRITE); }
+no-overwrite		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_NOOVERWRITE); }
 ,			{ return ','; }
 "/"			{ BEGIN(INITIAL); return '/'; }
 {name_minus}		{ return str(yyscanner, PE_NAME); }
