net/mlx5: E-Switch, Avoid ACLs in the offloads mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Avoid ACLs in the offloads mode (Don Dutile) [1417284]
Rebuild_FUZZ: 95.92%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit f96750f8d6bd64bb6f5a7a1146121b96bc6115f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f96750f8.failed

When we are in the switchdev/offloads mode, HW matching is done as
dictated by the offloaded rules and hence we don't need to enable
the ACLs mechanism used by the legacy mode.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f96750f8d6bd64bb6f5a7a1146121b96bc6115f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index b153747c6dc3,8b78f156214e..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1178,9 -1451,8 +1178,14 @@@ static void esw_enable_vport(struct mlx
  
  	esw_debug(esw->dev, "Enabling VPORT(%d)\n", vport_num);
  
++<<<<<<< HEAD
 +	if (vport_num) { /* Only VFs need ACLs for VST and spoofchk filtering */
 +		esw_vport_enable_ingress_acl(esw, vport);
 +		esw_vport_enable_egress_acl(esw, vport);
++=======
+ 	/* Only VFs need ACLs for VST and spoofchk filtering */
+ 	if (vport_num && esw->mode == SRIOV_LEGACY) {
++>>>>>>> f96750f8d6bd (net/mlx5: E-Switch, Avoid ACLs in the offloads mode)
  		esw_vport_ingress_config(esw, vport);
  		esw_vport_egress_config(esw, vport);
  	}
@@@ -1229,9 -1501,9 +1234,9 @@@ static void esw_disable_vport(struct ml
  	 * Calling vport change handler while vport is disabled will cleanup
  	 * the vport resources.
  	 */
 -	esw_vport_change_handle_locked(vport);
 +	esw_vport_change_handler(&vport->vport_change_handler);
  	vport->enabled_events = 0;
- 	if (vport_num) {
+ 	if (vport_num && esw->mode == SRIOV_LEGACY) {
  		esw_vport_disable_egress_acl(esw, vport);
  		esw_vport_disable_ingress_acl(esw, vport);
  	}
@@@ -1449,6 -1767,10 +1454,13 @@@ int mlx5_eswitch_set_vport_mac(struct m
  			       "Failed to set vport %d node guid, err = %d. RDMA_CM will not function properly for this VF.\n",
  			       vport, err);
  
++<<<<<<< HEAD
++=======
+ 	mutex_lock(&esw->state_lock);
+ 	if (evport->enabled && esw->mode == SRIOV_LEGACY)
+ 		err = esw_vport_ingress_config(esw, evport);
+ 	mutex_unlock(&esw->state_lock);
++>>>>>>> f96750f8d6bd (net/mlx5: E-Switch, Avoid ACLs in the offloads mode)
  	return err;
  }
  
@@@ -1527,6 -1852,54 +1539,57 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ int mlx5_eswitch_set_vport_spoofchk(struct mlx5_eswitch *esw,
+ 				    int vport, bool spoofchk)
+ {
+ 	struct mlx5_vport *evport;
+ 	bool pschk;
+ 	int err = 0;
+ 
+ 	if (!ESW_ALLOWED(esw))
+ 		return -EPERM;
+ 	if (!LEGAL_VPORT(esw, vport))
+ 		return -EINVAL;
+ 
+ 	evport = &esw->vports[vport];
+ 
+ 	mutex_lock(&esw->state_lock);
+ 	pschk = evport->spoofchk;
+ 	evport->spoofchk = spoofchk;
+ 	if (evport->enabled && esw->mode == SRIOV_LEGACY) {
+ 		err = esw_vport_ingress_config(esw, evport);
+ 		if (err)
+ 			evport->spoofchk = pschk;
+ 	}
+ 	mutex_unlock(&esw->state_lock);
+ 
+ 	return err;
+ }
+ 
+ int mlx5_eswitch_set_vport_trust(struct mlx5_eswitch *esw,
+ 				 int vport, bool setting)
+ {
+ 	struct mlx5_vport *evport;
+ 
+ 	if (!ESW_ALLOWED(esw))
+ 		return -EPERM;
+ 	if (!LEGAL_VPORT(esw, vport))
+ 		return -EINVAL;
+ 
+ 	evport = &esw->vports[vport];
+ 
+ 	mutex_lock(&esw->state_lock);
+ 	evport->trusted = setting;
+ 	if (evport->enabled)
+ 		esw_vport_change_handle_locked(evport);
+ 	mutex_unlock(&esw->state_lock);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> f96750f8d6bd (net/mlx5: E-Switch, Avoid ACLs in the offloads mode)
  int mlx5_eswitch_get_vport_stats(struct mlx5_eswitch *esw,
  				 int vport,
  				 struct ifla_vf_stats *vf_stats)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
