IB/mlx4: Remove debug prints after allocation failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Leon Romanovsky <leon@kernel.org>
commit 15d4626e498c09b66c0f74a107a83bd95abb175c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/15d4626e.failed

The prints after [k|v][m|z|c]alloc() functions are not needed,
because in case of failure, allocator will print their internal
error prints anyway.

	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 15d4626e498c09b66c0f74a107a83bd95abb175c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx4/main.c
diff --cc drivers/infiniband/hw/mlx4/main.c
index e42914fab934,1b54786d13d0..000000000000
--- a/drivers/infiniband/hw/mlx4/main.c
+++ b/drivers/infiniband/hw/mlx4/main.c
@@@ -3130,6 -3181,45 +3124,48 @@@ static void handle_bonded_port_state_ev
  	ib_dispatch_event(&ibev);
  }
  
++<<<<<<< HEAD
++=======
+ void mlx4_ib_sl2vl_update(struct mlx4_ib_dev *mdev, int port)
+ {
+ 	u64 sl2vl;
+ 	int err;
+ 
+ 	err = mlx4_ib_query_sl2vl(&mdev->ib_dev, port, &sl2vl);
+ 	if (err) {
+ 		pr_err("Unable to get current sl to vl mapping for port %d.  Using all zeroes (%d)\n",
+ 		       port, err);
+ 		sl2vl = 0;
+ 	}
+ 	atomic64_set(&mdev->sl2vl[port - 1], sl2vl);
+ }
+ 
+ static void ib_sl2vl_update_work(struct work_struct *work)
+ {
+ 	struct ib_event_work *ew = container_of(work, struct ib_event_work, work);
+ 	struct mlx4_ib_dev *mdev = ew->ib_dev;
+ 	int port = ew->port;
+ 
+ 	mlx4_ib_sl2vl_update(mdev, port);
+ 
+ 	kfree(ew);
+ }
+ 
+ void mlx4_sched_ib_sl2vl_update_work(struct mlx4_ib_dev *ibdev,
+ 				     int port)
+ {
+ 	struct ib_event_work *ew;
+ 
+ 	ew = kmalloc(sizeof(*ew), GFP_ATOMIC);
+ 	if (ew) {
+ 		INIT_WORK(&ew->work, ib_sl2vl_update_work);
+ 		ew->port = port;
+ 		ew->ib_dev = ibdev;
+ 		queue_work(wq, &ew->work);
+ 	}
+ }
+ 
++>>>>>>> 15d4626e498c (IB/mlx4: Remove debug prints after allocation failure)
  static void mlx4_ib_event(struct mlx4_dev *dev, void *ibdev_ptr,
  			  enum mlx4_dev_event event, unsigned long param)
  {
diff --git a/drivers/infiniband/hw/mlx4/alias_GUID.c b/drivers/infiniband/hw/mlx4/alias_GUID.c
index b285020315df..9507ee1b7db3 100644
--- a/drivers/infiniband/hw/mlx4/alias_GUID.c
+++ b/drivers/infiniband/hw/mlx4/alias_GUID.c
@@ -755,10 +755,8 @@ static void alias_guid_work(struct work_struct *work)
 	struct mlx4_ib_dev *dev = container_of(ib_sriov, struct mlx4_ib_dev, sriov);
 
 	rec = kzalloc(sizeof *rec, GFP_KERNEL);
-	if (!rec) {
-		pr_err("alias_guid_work: No Memory\n");
+	if (!rec)
 		return;
-	}
 
 	pr_debug("starting [port: %d]...\n", sriov_alias_port->port + 1);
 	ret = get_next_record_to_update(dev, sriov_alias_port->port, rec);
diff --git a/drivers/infiniband/hw/mlx4/cm.c b/drivers/infiniband/hw/mlx4/cm.c
index 39a488889fc7..d64845335e87 100644
--- a/drivers/infiniband/hw/mlx4/cm.c
+++ b/drivers/infiniband/hw/mlx4/cm.c
@@ -247,10 +247,8 @@ id_map_alloc(struct ib_device *ibdev, int slave_id, u32 sl_cm_id)
 	struct mlx4_ib_sriov *sriov = &to_mdev(ibdev)->sriov;
 
 	ent = kmalloc(sizeof (struct id_map_entry), GFP_KERNEL);
-	if (!ent) {
-		mlx4_ib_warn(ibdev, "Couldn't allocate id cache entry - out of memory\n");
+	if (!ent)
 		return ERR_PTR(-ENOMEM);
-	}
 
 	ent->sl_cm_id = sl_cm_id;
 	ent->slave_id = slave_id;
diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c
index 4133d3bbf9fa..78ddaf0e1e65 100644
--- a/drivers/infiniband/hw/mlx4/mad.c
+++ b/drivers/infiniband/hw/mlx4/mad.c
@@ -1095,10 +1095,8 @@ static void handle_slaves_guid_change(struct mlx4_ib_dev *dev, u8 port_num,
 
 	in_mad  = kmalloc(sizeof *in_mad, GFP_KERNEL);
 	out_mad = kmalloc(sizeof *out_mad, GFP_KERNEL);
-	if (!in_mad || !out_mad) {
-		mlx4_ib_warn(&dev->ib_dev, "failed to allocate memory for guid info mads\n");
+	if (!in_mad || !out_mad)
 		goto out;
-	}
 
 	guid_tbl_blk_num  *= 4;
 
@@ -1891,11 +1889,8 @@ static int alloc_pv_object(struct mlx4_ib_dev *dev, int slave, int port,
 
 	*ret_ctx = NULL;
 	ctx = kzalloc(sizeof (struct mlx4_ib_demux_pv_ctx), GFP_KERNEL);
-	if (!ctx) {
-		pr_err("failed allocating pv resource context "
-		       "for port %d, slave %d\n", port, slave);
+	if (!ctx)
 		return -ENOMEM;
-	}
 
 	ctx->ib_dev = &dev->ib_dev;
 	ctx->port = port;
* Unmerged path drivers/infiniband/hw/mlx4/main.c
diff --git a/drivers/infiniband/hw/mlx4/mcg.c b/drivers/infiniband/hw/mlx4/mcg.c
index a21d37f02f35..e010fe459e67 100644
--- a/drivers/infiniband/hw/mlx4/mcg.c
+++ b/drivers/infiniband/hw/mlx4/mcg.c
@@ -1142,7 +1142,6 @@ void mlx4_ib_mcg_port_cleanup(struct mlx4_ib_demux_ctx *ctx, int destroy_wq)
 	work = kmalloc(sizeof *work, GFP_KERNEL);
 	if (!work) {
 		ctx->flushing = 0;
-		mcg_warn("failed allocating work for cleanup\n");
 		return;
 	}
 
@@ -1202,10 +1201,8 @@ static int push_deleteing_req(struct mcast_group *group, int slave)
 		return 0;
 
 	req = kzalloc(sizeof *req, GFP_KERNEL);
-	if (!req) {
-		mcg_warn_group(group, "failed allocation - may leave stall groups\n");
+	if (!req)
 		return -ENOMEM;
-	}
 
 	if (!list_empty(&group->func[slave].pending)) {
 		pend_req = list_entry(group->func[slave].pending.prev, struct mcast_req, group_list);
