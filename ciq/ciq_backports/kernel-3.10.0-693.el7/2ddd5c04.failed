perf tools: Ditch record_opts.callgraph_set

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 2ddd5c049e71dd8551c268e7386fefeb7495e988
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2ddd5c04.failed

We have callchain_param.enabled for that.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Milian Wolff <milian.wolff@kdab.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-silwqjc2t25ls42dsvg28pp5@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 2ddd5c049e71dd8551c268e7386fefeb7495e988)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-record.c
#	tools/perf/builtin-trace.c
diff --cc tools/perf/builtin-record.c
index 36b0c64985d1,bd9593346bb2..000000000000
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@@ -922,11 -934,36 +922,40 @@@ static void callchain_debug(void
  {
  	static const char *str[CALLCHAIN_MAX] = { "NONE", "FP", "DWARF", "LBR" };
  
 -	pr_debug("callchain: type %s\n", str[callchain->record_mode]);
 +	pr_debug("callchain: type %s\n", str[callchain_param.record_mode]);
  
 -	if (callchain->record_mode == CALLCHAIN_DWARF)
 +	if (callchain_param.record_mode == CALLCHAIN_DWARF)
  		pr_debug("callchain: stack dump size %d\n",
++<<<<<<< HEAD
 +			 callchain_param.dump_size);
++=======
+ 			 callchain->dump_size);
+ }
+ 
+ int record_opts__parse_callchain(struct record_opts *record,
+ 				 struct callchain_param *callchain,
+ 				 const char *arg, bool unset)
+ {
+ 	int ret;
+ 	callchain->enabled = !unset;
+ 
+ 	/* --no-call-graph */
+ 	if (unset) {
+ 		callchain->record_mode = CALLCHAIN_NONE;
+ 		pr_debug("callchain: disabled\n");
+ 		return 0;
+ 	}
+ 
+ 	ret = parse_callchain_record_opt(arg, callchain);
+ 	if (!ret) {
+ 		/* Enable data address sampling for DWARF unwind. */
+ 		if (callchain->record_mode == CALLCHAIN_DWARF)
+ 			record->sample_address = true;
+ 		callchain_debug(callchain);
+ 	}
+ 
+ 	return ret;
++>>>>>>> 2ddd5c049e71 (perf tools: Ditch record_opts.callgraph_set)
  }
  
  int record_parse_callchain_opt(const struct option *opt,
@@@ -961,15 -977,14 +990,18 @@@ int record_callchain_opt(const struct o
  			 const char *arg __maybe_unused,
  			 int unset __maybe_unused)
  {
- 	struct record_opts *record = (struct record_opts *)opt->value;
+ 	struct callchain_param *callchain = opt->value;
  
- 	record->callgraph_set = true;
- 	callchain_param.enabled = true;
+ 	callchain->enabled = true;
  
- 	if (callchain_param.record_mode == CALLCHAIN_NONE)
- 		callchain_param.record_mode = CALLCHAIN_FP;
+ 	if (callchain->record_mode == CALLCHAIN_NONE)
+ 		callchain->record_mode = CALLCHAIN_FP;
  
++<<<<<<< HEAD
 +	callchain_debug();
++=======
+ 	callchain_debug(callchain);
++>>>>>>> 2ddd5c049e71 (perf tools: Ditch record_opts.callgraph_set)
  	return 0;
  }
  
diff --cc tools/perf/builtin-trace.c
index b18ec7559ff0,5e2614bbb48d..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -2369,6 -2457,15 +2369,18 @@@ static int trace__add_syscall_newtp(str
  	perf_evlist__add(evlist, sys_enter);
  	perf_evlist__add(evlist, sys_exit);
  
++<<<<<<< HEAD
++=======
+ 	if (callchain_param.enabled && !trace->kernel_syscallchains) {
+ 		/*
+ 		 * We're interested only in the user space callchain
+ 		 * leading to the syscall, allow overriding that for
+ 		 * debugging reasons using --kernel_syscall_callchains
+ 		 */
+ 		sys_exit->attr.exclude_callchain_kernel = 1;
+ 	}
+ 
++>>>>>>> 2ddd5c049e71 (perf tools: Ditch record_opts.callgraph_set)
  	trace->syscalls.events.sys_enter = sys_enter;
  	trace->syscalls.events.sys_exit  = sys_exit;
  
@@@ -2447,7 -2544,27 +2459,31 @@@ static int trace__run(struct trace *tra
  		goto out_delete_evlist;
  	}
  
++<<<<<<< HEAD
 +	perf_evlist__config(evlist, &trace->opts);
++=======
+ 	perf_evlist__config(evlist, &trace->opts, NULL);
+ 
+ 	if (callchain_param.enabled && trace->syscalls.events.sys_exit) {
+ 		perf_evsel__config_callchain(trace->syscalls.events.sys_exit,
+ 					     &trace->opts, &callchain_param);
+                /*
+                 * Now we have evsels with different sample_ids, use
+                 * PERF_SAMPLE_IDENTIFIER to map from sample to evsel
+                 * from a fixed position in each ring buffer record.
+                 *
+                 * As of this the changeset introducing this comment, this
+                 * isn't strictly needed, as the fields that can come before
+                 * PERF_SAMPLE_ID are all used, but we'll probably disable
+                 * some of those for things like copying the payload of
+                 * pointer syscall arguments, and for vfs_getname we don't
+                 * need PERF_SAMPLE_ADDR and PERF_SAMPLE_IP, so do this
+                 * here as a warning we need to use PERF_SAMPLE_IDENTIFIER.
+                 */
+ 		perf_evlist__set_sample_bit(evlist, IDENTIFIER);
+ 		perf_evlist__reset_sample_bit(evlist, ID);
+ 	}
++>>>>>>> 2ddd5c049e71 (perf tools: Ditch record_opts.callgraph_set)
  
  	signal(SIGCHLD, sig_handler);
  	signal(SIGINT, sig_handler);
@@@ -2995,6 -3144,26 +3031,29 @@@ int cmd_trace(int argc, const char **ar
  		trace.opts.sample_time = true;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (trace.opts.mmap_pages == UINT_MAX)
+ 		mmap_pages_user_set = false;
+ 
+ 	if (trace.max_stack == UINT_MAX) {
+ 		trace.max_stack = PERF_MAX_STACK_DEPTH;
+ 		max_stack_user_set = false;
+ 	}
+ 
+ #ifdef HAVE_DWARF_UNWIND_SUPPORT
+ 	if ((trace.min_stack || max_stack_user_set) && !callchain_param.enabled)
+ 		record_opts__parse_callchain(&trace.opts, &callchain_param, "dwarf", false);
+ #endif
+ 
+ 	if (callchain_param.enabled) {
+ 		if (!mmap_pages_user_set && geteuid() == 0)
+ 			trace.opts.mmap_pages = perf_event_mlock_kb_in_pages() * 4;
+ 
+ 		symbol_conf.use_callchain = true;
+ 	}
+ 
++>>>>>>> 2ddd5c049e71 (perf tools: Ditch record_opts.callgraph_set)
  	if (trace.evlist->nr_entries > 0)
  		evlist__set_evsel_handler(trace.evlist, trace__event_handler);
  
* Unmerged path tools/perf/builtin-record.c
diff --git a/tools/perf/builtin-top.c b/tools/perf/builtin-top.c
index 833214979c4f..510f5f2a23b8 100644
--- a/tools/perf/builtin-top.c
+++ b/tools/perf/builtin-top.c
@@ -1045,18 +1045,17 @@ callchain_opt(const struct option *opt, const char *arg, int unset)
 static int
 parse_callchain_opt(const struct option *opt, const char *arg, int unset)
 {
-	struct record_opts *record = (struct record_opts *)opt->value;
+	struct callchain_param *callchain = opt->value;
 
-	record->callgraph_set = true;
-	callchain_param.enabled = !unset;
-	callchain_param.record_mode = CALLCHAIN_FP;
+	callchain->enabled = !unset;
+	callchain->record_mode = CALLCHAIN_FP;
 
 	/*
 	 * --no-call-graph
 	 */
 	if (unset) {
 		symbol_conf.use_callchain = false;
-		callchain_param.record_mode = CALLCHAIN_NONE;
+		callchain->record_mode = CALLCHAIN_NONE;
 		return 0;
 	}
 
@@ -1162,10 +1161,10 @@ int cmd_top(int argc, const char **argv, const char *prefix __maybe_unused)
 		   "output field(s): overhead, period, sample plus all of sort keys"),
 	OPT_BOOLEAN('n', "show-nr-samples", &symbol_conf.show_nr_samples,
 		    "Show a column with the number of samples"),
-	OPT_CALLBACK_NOOPT('g', NULL, &top.record_opts,
+	OPT_CALLBACK_NOOPT('g', NULL, &callchain_param,
 			   NULL, "enables call-graph recording and display",
 			   &callchain_opt),
-	OPT_CALLBACK(0, "call-graph", &top.record_opts,
+	OPT_CALLBACK(0, "call-graph", &callchain_param,
 		     "record_mode[,record_size],print_type,threshold[,print_limit],order,sort_key[,branch]",
 		     top_callchain_help, &parse_callchain_opt),
 	OPT_BOOLEAN(0, "children", &symbol_conf.cumulate_callchain,
* Unmerged path tools/perf/builtin-trace.c
diff --git a/tools/perf/perf.h b/tools/perf/perf.h
index 693cda7dcc6f..22f01911bef9 100644
--- a/tools/perf/perf.h
+++ b/tools/perf/perf.h
@@ -52,7 +52,6 @@ struct record_opts {
 	bool	     sample_weight;
 	bool	     sample_time;
 	bool	     sample_time_set;
-	bool	     callgraph_set;
 	bool	     period;
 	bool	     running_time;
 	bool	     full_auxtrace;
