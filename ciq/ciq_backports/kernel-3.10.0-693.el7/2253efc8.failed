blk-mq: Move more code into blk_mq_direct_issue_request()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Bart Van Assche <bart.vanassche@sandisk.com>
commit 2253efc850c4cf690516bbc07854eeb1077202ba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2253efc8.failed

Move the "hctx stopped" test and the insert request calls into
blk_mq_direct_issue_request(). Rename that function into
blk_mq_try_issue_directly() to reflect its new semantics. Pass
the hctx pointer to that function instead of looking it up a
second time. These changes avoid that code has to be duplicated
in the next patch.

	Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 2253efc850c4cf690516bbc07854eeb1077202ba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index 1fb8b36f35c6,447c37f39e32..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1228,36 -1228,43 +1228,66 @@@ static struct request *blk_mq_map_reque
  	return rq;
  }
  
++<<<<<<< HEAD
 +static int blk_mq_direct_issue_request(struct request *rq)
 +{
 +	int ret;
 +	struct request_queue *q = rq->q;
 +	struct blk_mq_hw_ctx *hctx = q->mq_ops->map_queue(q,
 +			rq->mq_ctx->cpu);
++=======
+ static void blk_mq_try_issue_directly(struct blk_mq_hw_ctx *hctx,
+ 				      struct request *rq, blk_qc_t *cookie)
+ {
+ 	int ret;
+ 	struct request_queue *q = rq->q;
++>>>>>>> 2253efc850c4 (blk-mq: Move more code into blk_mq_direct_issue_request())
  	struct blk_mq_queue_data bd = {
  		.rq = rq,
  		.list = NULL,
  		.last = 1
  	};
 -	blk_qc_t new_cookie = blk_tag_to_qc_t(rq->tag, hctx->queue_num);
  
+ 	if (blk_mq_hctx_stopped(hctx))
+ 		goto insert;
+ 
  	/*
  	 * For OK queue, we are done. For error, kill it. Any other
  	 * error (busy), just add it to our list as we previously
  	 * would have done
  	 */
  	ret = q->mq_ops->queue_rq(hctx, &bd);
++<<<<<<< HEAD
 +	if (ret == BLK_MQ_RQ_QUEUE_OK)
 +		return 0;
 +	else {
 +		__blk_mq_requeue_request(rq);
 +
 +		if (ret == BLK_MQ_RQ_QUEUE_ERROR) {
 +			rq->errors = -EIO;
 +			blk_mq_end_request(rq, rq->errors);
 +			return 0;
 +		}
 +		return -1;
 +	}
++=======
+ 	if (ret == BLK_MQ_RQ_QUEUE_OK) {
+ 		*cookie = new_cookie;
+ 		return;
+ 	}
+ 
+ 	__blk_mq_requeue_request(rq);
+ 
+ 	if (ret == BLK_MQ_RQ_QUEUE_ERROR) {
+ 		*cookie = BLK_QC_T_NONE;
+ 		rq->errors = -EIO;
+ 		blk_mq_end_request(rq, rq->errors);
+ 		return;
+ 	}
+ 
+ insert:
+ 	blk_mq_insert_request(rq, false, true, true);
++>>>>>>> 2253efc850c4 (blk-mq: Move more code into blk_mq_direct_issue_request())
  }
  
  /*
@@@ -1328,11 -1340,9 +1358,17 @@@ static void blk_mq_make_request(struct 
  			old_rq = rq;
  		blk_mq_put_ctx(data.ctx);
  		if (!old_rq)
++<<<<<<< HEAD
 +			return;
 +		if (!blk_mq_direct_issue_request(old_rq))
 +			return;
 +		blk_mq_insert_request(old_rq, false, true, true);
 +		return;
++=======
+ 			goto done;
+ 		blk_mq_try_issue_directly(data.hctx, old_rq, &cookie);
+ 		goto done;
++>>>>>>> 2253efc850c4 (blk-mq: Move more code into blk_mq_direct_issue_request())
  	}
  
  	if (!blk_mq_merge_queue_io(data.hctx, data.ctx, rq, bio)) {
* Unmerged path block/blk-mq.c
