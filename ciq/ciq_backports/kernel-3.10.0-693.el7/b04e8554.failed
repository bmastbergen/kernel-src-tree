RDS: TCP: Hooks to set up a single connection path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Sowmini Varadhan <sowmini.varadhan@oracle.com>
commit b04e8554f7637999af8f54cca4dcfcf49f2ae7c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b04e8554.failed

This patch adds ->conn_path_connect callbacks in the rds_transport
that are used to set up a single connection path.

	Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
	Signed-off-by: Sowmini Varadhan <sowmini.varadhan@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b04e8554f7637999af8f54cca4dcfcf49f2ae7c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rds/ib.c
#	net/rds/ib.h
#	net/rds/loop.c
#	net/rds/rds.h
#	net/rds/tcp.c
#	net/rds/tcp.h
#	net/rds/tcp_connect.c
#	net/rds/threads.c
diff --cc net/rds/ib.c
index 6c6dd30d927b,7eaf887e46f8..000000000000
--- a/net/rds/ib.c
+++ b/net/rds/ib.c
@@@ -383,11 -385,11 +383,16 @@@ struct rds_transport rds_ib_transport 
  	.xmit			= rds_ib_xmit,
  	.xmit_rdma		= rds_ib_xmit_rdma,
  	.xmit_atomic		= rds_ib_xmit_atomic,
 -	.recv_path		= rds_ib_recv_path,
 +	.recv			= rds_ib_recv,
  	.conn_alloc		= rds_ib_conn_alloc,
  	.conn_free		= rds_ib_conn_free,
++<<<<<<< HEAD
 +	.conn_connect		= rds_ib_conn_connect,
 +	.conn_shutdown		= rds_ib_conn_shutdown,
++=======
+ 	.conn_path_connect	= rds_ib_conn_path_connect,
+ 	.conn_path_shutdown	= rds_ib_conn_path_shutdown,
++>>>>>>> b04e8554f763 (RDS: TCP: Hooks to set up a single connection path)
  	.inc_copy_to_user	= rds_ib_inc_copy_to_user,
  	.inc_free		= rds_ib_inc_free,
  	.cm_initiate_connect	= rds_ib_cm_initiate_connect,
diff --cc net/rds/ib.h
index 33ec6a6553e1,046f7508c06b..000000000000
--- a/net/rds/ib.h
+++ b/net/rds/ib.h
@@@ -328,8 -328,8 +328,13 @@@ extern struct list_head ib_nodev_conns
  /* ib_cm.c */
  int rds_ib_conn_alloc(struct rds_connection *conn, gfp_t gfp);
  void rds_ib_conn_free(void *arg);
++<<<<<<< HEAD
 +int rds_ib_conn_connect(struct rds_connection *conn);
 +void rds_ib_conn_shutdown(struct rds_connection *conn);
++=======
+ int rds_ib_conn_path_connect(struct rds_conn_path *cp);
+ void rds_ib_conn_path_shutdown(struct rds_conn_path *cp);
++>>>>>>> b04e8554f763 (RDS: TCP: Hooks to set up a single connection path)
  void rds_ib_state_change(struct sock *sk);
  int rds_ib_listen_init(void);
  void rds_ib_listen_stop(void);
diff --cc net/rds/loop.c
index 6b12b68541ae,f2bf78de5688..000000000000
--- a/net/rds/loop.c
+++ b/net/rds/loop.c
@@@ -183,11 -185,11 +183,16 @@@ void rds_loop_exit(void
   */
  struct rds_transport rds_loop_transport = {
  	.xmit			= rds_loop_xmit,
 -	.recv_path		= rds_loop_recv_path,
 +	.recv			= rds_loop_recv,
  	.conn_alloc		= rds_loop_conn_alloc,
  	.conn_free		= rds_loop_conn_free,
++<<<<<<< HEAD
 +	.conn_connect		= rds_loop_conn_connect,
 +	.conn_shutdown		= rds_loop_conn_shutdown,
++=======
+ 	.conn_path_connect	= rds_loop_conn_path_connect,
+ 	.conn_path_shutdown	= rds_loop_conn_path_shutdown,
++>>>>>>> b04e8554f763 (RDS: TCP: Hooks to set up a single connection path)
  	.inc_copy_to_user	= rds_message_inc_copy_to_user,
  	.inc_free		= rds_loop_inc_free,
  	.t_name			= "loopback",
diff --cc net/rds/rds.h
index 8889455d9d7c,6ef07bd27227..000000000000
--- a/net/rds/rds.h
+++ b/net/rds/rds.h
@@@ -440,10 -454,10 +440,17 @@@ struct rds_transport 
  	int (*laddr_check)(struct net *net, __be32 addr);
  	int (*conn_alloc)(struct rds_connection *conn, gfp_t gfp);
  	void (*conn_free)(void *data);
++<<<<<<< HEAD
 +	int (*conn_connect)(struct rds_connection *conn);
 +	void (*conn_shutdown)(struct rds_connection *conn);
 +	void (*xmit_prepare)(struct rds_connection *conn);
 +	void (*xmit_complete)(struct rds_connection *conn);
++=======
+ 	int (*conn_path_connect)(struct rds_conn_path *cp);
+ 	void (*conn_path_shutdown)(struct rds_conn_path *conn);
+ 	void (*xmit_path_prepare)(struct rds_conn_path *cp);
+ 	void (*xmit_path_complete)(struct rds_conn_path *cp);
++>>>>>>> b04e8554f763 (RDS: TCP: Hooks to set up a single connection path)
  	int (*xmit)(struct rds_connection *conn, struct rds_message *rm,
  		    unsigned int hdr_off, unsigned int sg, unsigned int off);
  	int (*xmit_rdma)(struct rds_connection *conn, struct rm_rdma_op *op);
diff --cc net/rds/tcp.c
index 5ea4c0469433,d278432f080b..000000000000
--- a/net/rds/tcp.c
+++ b/net/rds/tcp.c
@@@ -336,14 -356,14 +336,19 @@@ static void rds_tcp_exit(void)
  
  struct rds_transport rds_tcp_transport = {
  	.laddr_check		= rds_tcp_laddr_check,
 -	.xmit_path_prepare	= rds_tcp_xmit_path_prepare,
 -	.xmit_path_complete	= rds_tcp_xmit_path_complete,
 +	.xmit_prepare		= rds_tcp_xmit_prepare,
 +	.xmit_complete		= rds_tcp_xmit_complete,
  	.xmit			= rds_tcp_xmit,
 -	.recv_path		= rds_tcp_recv_path,
 +	.recv			= rds_tcp_recv,
  	.conn_alloc		= rds_tcp_conn_alloc,
  	.conn_free		= rds_tcp_conn_free,
++<<<<<<< HEAD
 +	.conn_connect		= rds_tcp_conn_connect,
 +	.conn_shutdown		= rds_tcp_conn_shutdown,
++=======
+ 	.conn_path_connect	= rds_tcp_conn_path_connect,
+ 	.conn_path_shutdown	= rds_tcp_conn_path_shutdown,
++>>>>>>> b04e8554f763 (RDS: TCP: Hooks to set up a single connection path)
  	.inc_copy_to_user	= rds_tcp_inc_copy_to_user,
  	.inc_free		= rds_tcp_inc_free,
  	.stats_info_copy	= rds_tcp_stats_info_copy,
diff --cc net/rds/tcp.h
index 3949f2d1c41c,1c3160faa963..000000000000
--- a/net/rds/tcp.h
+++ b/net/rds/tcp.h
@@@ -11,11 -11,11 +11,17 @@@ struct rds_tcp_incoming 
  struct rds_tcp_connection {
  
  	struct list_head	t_tcp_node;
++<<<<<<< HEAD
 +	struct rds_connection   *conn;
 +	/* t_conn_lock synchronizes the connection establishment between
 +	 * rds_tcp_accept_one and rds_tcp_conn_connect
++=======
+ 	struct rds_conn_path	*t_cpath;
+ 	/* t_conn_path_lock synchronizes the connection establishment between
+ 	 * rds_tcp_accept_one and rds_tcp_conn_path_connect
++>>>>>>> b04e8554f763 (RDS: TCP: Hooks to set up a single connection path)
  	 */
 -	struct mutex		t_conn_path_lock;
 +	struct mutex		t_conn_lock;
  	struct socket		*t_sock;
  	void			*t_orig_write_space;
  	void			*t_orig_data_ready;
@@@ -60,8 -60,8 +66,13 @@@ extern struct rds_transport rds_tcp_tra
  void rds_tcp_accept_work(struct sock *sk);
  
  /* tcp_connect.c */
++<<<<<<< HEAD
 +int rds_tcp_conn_connect(struct rds_connection *conn);
 +void rds_tcp_conn_shutdown(struct rds_connection *conn);
++=======
+ int rds_tcp_conn_path_connect(struct rds_conn_path *cp);
+ void rds_tcp_conn_path_shutdown(struct rds_conn_path *conn);
++>>>>>>> b04e8554f763 (RDS: TCP: Hooks to set up a single connection path)
  void rds_tcp_state_change(struct sock *sk);
  
  /* tcp_listen.c */
diff --cc net/rds/tcp_connect.c
index a86fb96b1ae0,c916715fbe61..000000000000
--- a/net/rds/tcp_connect.c
+++ b/net/rds/tcp_connect.c
@@@ -78,12 -79,13 +78,22 @@@ int rds_tcp_conn_path_connect(struct rd
  	struct socket *sock = NULL;
  	struct sockaddr_in src, dest;
  	int ret;
++<<<<<<< HEAD
 +	struct rds_tcp_connection *tc = conn->c_transport_data;
++=======
+ 	struct rds_connection *conn = cp->cp_conn;
+ 	struct rds_tcp_connection *tc = cp->cp_transport_data;
++>>>>>>> b04e8554f763 (RDS: TCP: Hooks to set up a single connection path)
  
 -	mutex_lock(&tc->t_conn_path_lock);
 +	mutex_lock(&tc->t_conn_lock);
  
++<<<<<<< HEAD
 +	if (rds_conn_up(conn)) {
 +		mutex_unlock(&tc->t_conn_lock);
++=======
+ 	if (rds_conn_path_up(cp)) {
+ 		mutex_unlock(&tc->t_conn_path_lock);
++>>>>>>> b04e8554f763 (RDS: TCP: Hooks to set up a single connection path)
  		return 0;
  	}
  	ret = sock_create_kern(rds_conn_net(conn), PF_INET,
diff --cc net/rds/threads.c
index 55bb19ff40f2,e8f0941f0548..000000000000
--- a/net/rds/threads.c
+++ b/net/rds/threads.c
@@@ -144,12 -145,16 +144,19 @@@ void rds_queue_reconnect(struct rds_con
  
  void rds_connect_worker(struct work_struct *work)
  {
 -	struct rds_conn_path *cp = container_of(work,
 -						struct rds_conn_path,
 -						cp_conn_w.work);
 -	struct rds_connection *conn = cp->cp_conn;
 +	struct rds_connection *conn = container_of(work, struct rds_connection, c_conn_w.work);
  	int ret;
  
++<<<<<<< HEAD
 +	clear_bit(RDS_RECONNECT_PENDING, &conn->c_flags);
 +	if (rds_conn_transition(conn, RDS_CONN_DOWN, RDS_CONN_CONNECTING)) {
 +		ret = conn->c_trans->conn_connect(conn);
++=======
+ 	clear_bit(RDS_RECONNECT_PENDING, &cp->cp_flags);
+ 	ret = rds_conn_path_transition(cp, RDS_CONN_DOWN, RDS_CONN_CONNECTING);
+ 	if (ret) {
+ 		ret = conn->c_trans->conn_path_connect(cp);
++>>>>>>> b04e8554f763 (RDS: TCP: Hooks to set up a single connection path)
  		rdsdebug("conn %p for %pI4 to %pI4 dispatched, ret %d\n",
  			conn, &conn->c_laddr, &conn->c_faddr, ret);
  
* Unmerged path net/rds/ib.c
* Unmerged path net/rds/ib.h
diff --git a/net/rds/ib_cm.c b/net/rds/ib_cm.c
index 121ebb33e60b..66ccd3a34273 100644
--- a/net/rds/ib_cm.c
+++ b/net/rds/ib_cm.c
@@ -675,8 +675,9 @@ out:
 	return ret;
 }
 
-int rds_ib_conn_connect(struct rds_connection *conn)
+int rds_ib_conn_path_connect(struct rds_conn_path *cp)
 {
+	struct rds_connection *conn = cp->cp_conn;
 	struct rds_ib_connection *ic = conn->c_transport_data;
 	struct sockaddr_in src, dest;
 	int ret;
* Unmerged path net/rds/loop.c
* Unmerged path net/rds/rds.h
* Unmerged path net/rds/tcp.c
* Unmerged path net/rds/tcp.h
* Unmerged path net/rds/tcp_connect.c
* Unmerged path net/rds/threads.c
