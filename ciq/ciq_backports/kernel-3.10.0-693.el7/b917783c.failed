flow_dissector: __skb_get_hash_symmetric arg can be const

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Florian Westphal <fw@strlen.de>
commit b917783c7b350518f8c5d88bb5848aa8064408a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b917783c.failed

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b917783c7b350518f8c5d88bb5848aa8064408a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/core/flow_dissector.c
diff --cc include/linux/skbuff.h
index dcb8575fa615,663fda2887f7..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -1001,6 -1064,121 +1001,124 @@@ static inline void skb_clear_hash_if_no
  		skb_clear_hash(skb);
  }
  
++<<<<<<< HEAD
++=======
+ static inline void
+ __skb_set_hash(struct sk_buff *skb, __u32 hash, bool is_sw, bool is_l4)
+ {
+ 	skb->l4_hash = is_l4;
+ 	skb->sw_hash = is_sw;
+ 	skb->hash = hash;
+ }
+ 
+ static inline void
+ skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
+ {
+ 	/* Used by drivers to set hash from HW */
+ 	__skb_set_hash(skb, hash, false, type == PKT_HASH_TYPE_L4);
+ }
+ 
+ static inline void
+ __skb_set_sw_hash(struct sk_buff *skb, __u32 hash, bool is_l4)
+ {
+ 	__skb_set_hash(skb, hash, true, is_l4);
+ }
+ 
+ void __skb_get_hash(struct sk_buff *skb);
+ u32 __skb_get_hash_symmetric(const struct sk_buff *skb);
+ u32 skb_get_poff(const struct sk_buff *skb);
+ u32 __skb_get_poff(const struct sk_buff *skb, void *data,
+ 		   const struct flow_keys *keys, int hlen);
+ __be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,
+ 			    void *data, int hlen_proto);
+ 
+ static inline __be32 skb_flow_get_ports(const struct sk_buff *skb,
+ 					int thoff, u8 ip_proto)
+ {
+ 	return __skb_flow_get_ports(skb, thoff, ip_proto, NULL, 0);
+ }
+ 
+ void skb_flow_dissector_init(struct flow_dissector *flow_dissector,
+ 			     const struct flow_dissector_key *key,
+ 			     unsigned int key_count);
+ 
+ bool __skb_flow_dissect(const struct sk_buff *skb,
+ 			struct flow_dissector *flow_dissector,
+ 			void *target_container,
+ 			void *data, __be16 proto, int nhoff, int hlen,
+ 			unsigned int flags);
+ 
+ static inline bool skb_flow_dissect(const struct sk_buff *skb,
+ 				    struct flow_dissector *flow_dissector,
+ 				    void *target_container, unsigned int flags)
+ {
+ 	return __skb_flow_dissect(skb, flow_dissector, target_container,
+ 				  NULL, 0, 0, 0, flags);
+ }
+ 
+ static inline bool skb_flow_dissect_flow_keys(const struct sk_buff *skb,
+ 					      struct flow_keys *flow,
+ 					      unsigned int flags)
+ {
+ 	memset(flow, 0, sizeof(*flow));
+ 	return __skb_flow_dissect(skb, &flow_keys_dissector, flow,
+ 				  NULL, 0, 0, 0, flags);
+ }
+ 
+ static inline bool skb_flow_dissect_flow_keys_buf(struct flow_keys *flow,
+ 						  void *data, __be16 proto,
+ 						  int nhoff, int hlen,
+ 						  unsigned int flags)
+ {
+ 	memset(flow, 0, sizeof(*flow));
+ 	return __skb_flow_dissect(NULL, &flow_keys_buf_dissector, flow,
+ 				  data, proto, nhoff, hlen, flags);
+ }
+ 
+ static inline __u32 skb_get_hash(struct sk_buff *skb)
+ {
+ 	if (!skb->l4_hash && !skb->sw_hash)
+ 		__skb_get_hash(skb);
+ 
+ 	return skb->hash;
+ }
+ 
+ __u32 __skb_get_hash_flowi6(struct sk_buff *skb, const struct flowi6 *fl6);
+ 
+ static inline __u32 skb_get_hash_flowi6(struct sk_buff *skb, const struct flowi6 *fl6)
+ {
+ 	if (!skb->l4_hash && !skb->sw_hash) {
+ 		struct flow_keys keys;
+ 		__u32 hash = __get_hash_from_flowi6(fl6, &keys);
+ 
+ 		__skb_set_sw_hash(skb, hash, flow_keys_have_l4(&keys));
+ 	}
+ 
+ 	return skb->hash;
+ }
+ 
+ __u32 __skb_get_hash_flowi4(struct sk_buff *skb, const struct flowi4 *fl);
+ 
+ static inline __u32 skb_get_hash_flowi4(struct sk_buff *skb, const struct flowi4 *fl4)
+ {
+ 	if (!skb->l4_hash && !skb->sw_hash) {
+ 		struct flow_keys keys;
+ 		__u32 hash = __get_hash_from_flowi4(fl4, &keys);
+ 
+ 		__skb_set_sw_hash(skb, hash, flow_keys_have_l4(&keys));
+ 	}
+ 
+ 	return skb->hash;
+ }
+ 
+ __u32 skb_get_hash_perturb(const struct sk_buff *skb, u32 perturb);
+ 
+ static inline __u32 skb_get_hash_raw(const struct sk_buff *skb)
+ {
+ 	return skb->hash;
+ }
+ 
++>>>>>>> b917783c7b35 (flow_dissector: __skb_get_hash_symmetric arg can be const)
  static inline void skb_copy_hash(struct sk_buff *to, const struct sk_buff *from)
  {
  	to->hash = from->hash;
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,0cc607d05fc8..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -367,8 -685,64 +367,69 @@@ u32 flow_hash_from_keys(struct flow_key
  }
  EXPORT_SYMBOL(flow_hash_from_keys);
  
++<<<<<<< HEAD
 +/*
 + * __skb_get_hash: calculate a flow hash based on src/dst addresses
++=======
+ static inline u32 ___skb_get_hash(const struct sk_buff *skb,
+ 				  struct flow_keys *keys, u32 keyval)
+ {
+ 	skb_flow_dissect_flow_keys(skb, keys,
+ 				   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);
+ 
+ 	return __flow_hash_from_keys(keys, keyval);
+ }
+ 
+ struct _flow_keys_digest_data {
+ 	__be16	n_proto;
+ 	u8	ip_proto;
+ 	u8	padding;
+ 	__be32	ports;
+ 	__be32	src;
+ 	__be32	dst;
+ };
+ 
+ void make_flow_keys_digest(struct flow_keys_digest *digest,
+ 			   const struct flow_keys *flow)
+ {
+ 	struct _flow_keys_digest_data *data =
+ 	    (struct _flow_keys_digest_data *)digest;
+ 
+ 	BUILD_BUG_ON(sizeof(*data) > sizeof(*digest));
+ 
+ 	memset(digest, 0, sizeof(*digest));
+ 
+ 	data->n_proto = flow->basic.n_proto;
+ 	data->ip_proto = flow->basic.ip_proto;
+ 	data->ports = flow->ports.ports;
+ 	data->src = flow->addrs.v4addrs.src;
+ 	data->dst = flow->addrs.v4addrs.dst;
+ }
+ EXPORT_SYMBOL(make_flow_keys_digest);
+ 
+ static struct flow_dissector flow_keys_dissector_symmetric __read_mostly;
+ 
+ u32 __skb_get_hash_symmetric(const struct sk_buff *skb)
+ {
+ 	struct flow_keys keys;
+ 
+ 	__flow_hash_secret_init();
+ 
+ 	memset(&keys, 0, sizeof(keys));
+ 	__skb_flow_dissect(skb, &flow_keys_dissector_symmetric, &keys,
+ 			   NULL, 0, 0, 0,
+ 			   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);
+ 
+ 	return __flow_hash_from_keys(&keys, hashrnd);
+ }
+ EXPORT_SYMBOL_GPL(__skb_get_hash_symmetric);
+ 
+ /**
+  * __skb_get_hash: calculate a flow hash
+  * @skb: sk_buff to calculate flow hash from
+  *
+  * This function calculates a flow hash based on src/dst addresses
++>>>>>>> b917783c7b35 (flow_dissector: __skb_get_hash_symmetric arg can be const)
   * and src/dst port numbers.  Sets hash in skb to non-zero hash value
   * on success, zero indicates no valid hash.  Also, sets l4_hash in skb
   * if hash is a canonical 4-tuple hash over transport ports.
* Unmerged path include/linux/skbuff.h
* Unmerged path net/core/flow_dissector.c
