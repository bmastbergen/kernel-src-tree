KVM: PPC: Book3S HV: kvmppc_host_rm_ops - handle offlining CPUs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Suresh Warrier <warrier@linux.vnet.ibm.com>
commit 6f3bb80944148012cbac1f98da249f591cbcae43
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6f3bb809.failed

The kvmppc_host_rm_ops structure keeps track of which cores are
are in the host by maintaining a bitmask of active/runnable
online CPUs that have not entered the guest. This patch adds
support to manage the bitmask when a CPU is offlined or onlined
in the host.

	Signed-off-by: Suresh Warrier <warrier@linux.vnet.ibm.com>
	Signed-off-by: Paul Mackerras <paulus@samba.org>
(cherry picked from commit 6f3bb80944148012cbac1f98da249f591cbcae43)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv.c
diff --cc arch/powerpc/kvm/book3s_hv.c
index 32dd0caea96b,16304d2c0cb7..000000000000
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@@ -3041,6 -3052,112 +3041,115 @@@ static int kvmppc_hv_setup_htab_rma(str
  	goto out_srcu;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_KVM_XICS
+ static int kvmppc_cpu_notify(struct notifier_block *self, unsigned long action,
+ 			void *hcpu)
+ {
+ 	unsigned long cpu = (long)hcpu;
+ 
+ 	switch (action) {
+ 	case CPU_UP_PREPARE:
+ 	case CPU_UP_PREPARE_FROZEN:
+ 		kvmppc_set_host_core(cpu);
+ 		break;
+ 
+ #ifdef CONFIG_HOTPLUG_CPU
+ 	case CPU_DEAD:
+ 	case CPU_DEAD_FROZEN:
+ 	case CPU_UP_CANCELED:
+ 	case CPU_UP_CANCELED_FROZEN:
+ 		kvmppc_clear_host_core(cpu);
+ 		break;
+ #endif
+ 	default:
+ 		break;
+ 	}
+ 
+ 	return NOTIFY_OK;
+ }
+ 
+ static struct notifier_block kvmppc_cpu_notifier = {
+ 	    .notifier_call = kvmppc_cpu_notify,
+ };
+ 
+ /*
+  * Allocate a per-core structure for managing state about which cores are
+  * running in the host versus the guest and for exchanging data between
+  * real mode KVM and CPU running in the host.
+  * This is only done for the first VM.
+  * The allocated structure stays even if all VMs have stopped.
+  * It is only freed when the kvm-hv module is unloaded.
+  * It's OK for this routine to fail, we just don't support host
+  * core operations like redirecting H_IPI wakeups.
+  */
+ void kvmppc_alloc_host_rm_ops(void)
+ {
+ 	struct kvmppc_host_rm_ops *ops;
+ 	unsigned long l_ops;
+ 	int cpu, core;
+ 	int size;
+ 
+ 	/* Not the first time here ? */
+ 	if (kvmppc_host_rm_ops_hv != NULL)
+ 		return;
+ 
+ 	ops = kzalloc(sizeof(struct kvmppc_host_rm_ops), GFP_KERNEL);
+ 	if (!ops)
+ 		return;
+ 
+ 	size = cpu_nr_cores() * sizeof(struct kvmppc_host_rm_core);
+ 	ops->rm_core = kzalloc(size, GFP_KERNEL);
+ 
+ 	if (!ops->rm_core) {
+ 		kfree(ops);
+ 		return;
+ 	}
+ 
+ 	get_online_cpus();
+ 
+ 	for (cpu = 0; cpu < nr_cpu_ids; cpu += threads_per_core) {
+ 		if (!cpu_online(cpu))
+ 			continue;
+ 
+ 		core = cpu >> threads_shift;
+ 		ops->rm_core[core].rm_state.in_host = 1;
+ 	}
+ 
+ 	/*
+ 	 * Make the contents of the kvmppc_host_rm_ops structure visible
+ 	 * to other CPUs before we assign it to the global variable.
+ 	 * Do an atomic assignment (no locks used here), but if someone
+ 	 * beats us to it, just free our copy and return.
+ 	 */
+ 	smp_wmb();
+ 	l_ops = (unsigned long) ops;
+ 
+ 	if (cmpxchg64((unsigned long *)&kvmppc_host_rm_ops_hv, 0, l_ops)) {
+ 		put_online_cpus();
+ 		kfree(ops->rm_core);
+ 		kfree(ops);
+ 		return;
+ 	}
+ 
+ 	register_cpu_notifier(&kvmppc_cpu_notifier);
+ 
+ 	put_online_cpus();
+ }
+ 
+ void kvmppc_free_host_rm_ops(void)
+ {
+ 	if (kvmppc_host_rm_ops_hv) {
+ 		unregister_cpu_notifier(&kvmppc_cpu_notifier);
+ 		kfree(kvmppc_host_rm_ops_hv->rm_core);
+ 		kfree(kvmppc_host_rm_ops_hv);
+ 		kvmppc_host_rm_ops_hv = NULL;
+ 	}
+ }
+ #endif
+ 
++>>>>>>> 6f3bb8094414 (KVM: PPC: Book3S HV: kvmppc_host_rm_ops - handle offlining CPUs)
  static int kvmppc_core_init_vm_hv(struct kvm *kvm)
  {
  	unsigned long lpcr, lpid;
* Unmerged path arch/powerpc/kvm/book3s_hv.c
