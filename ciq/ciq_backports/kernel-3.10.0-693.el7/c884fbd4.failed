gpio / ACPI: Add support for retrieving GpioInt resources from a device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit c884fbd452147e952ae160e750553d00ea4dc4c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c884fbd4.failed

ACPI specification knows two types of GPIOs: GpioIo and GpioInt. The latter
is used to describe that a given device interrupt line is connected to a
specific GPIO pin. Typical ACPI _CRS entry for such device looks like
below:

    Name (_CRS, ResourceTemplate ()
    {
        I2cSerialBus (0x004A, ControllerInitiated, 0x00061A80,
                      AddressingMode7Bit, "\\_SB.PCI0.I2C6",
                      0x00, ResourceConsumer)
        GpioIo (Exclusive, PullDefault, 0x0000, 0x0000,
                IoRestrictionOutputOnly, "\\_SB.GPO0",
                0x00, ResourceConsumer)
        {
            0x004B
        }
        GpioInt (Level, ActiveLow, Shared, PullDefault, 0x0000,
                 "\\_SB.GPO0", 0x00, ResourceConsumer)
        {
            0x004C
        }
    })

Currently drivers need to request a GPIO corresponding to the right GpioInt
and then translate that to Linux IRQ number. This adds unnecessary lines of
boiler-plate code.

We can ease this a bit by introducing acpi_dev_gpio_irq_get() analogous to
of_irq_get(). This function translates given GpioInt resource under the
device in question to the suitable Linux IRQ number.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit c884fbd452147e952ae160e750553d00ea4dc4c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib-acpi.c
#	include/linux/acpi.h
diff --cc drivers/gpio/gpiolib-acpi.c
index 716ee9843110,bff29bb0a3fe..000000000000
--- a/drivers/gpio/gpiolib-acpi.c
+++ b/drivers/gpio/gpiolib-acpi.c
@@@ -310,9 -514,217 +310,193 @@@ struct gpio_desc *acpi_get_gpiod_by_ind
  	return lookup.desc ? lookup.desc : ERR_PTR(-ENOENT);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * acpi_dev_gpio_irq_get() - Find GpioInt and translate it to Linux IRQ number
+  * @adev: pointer to a ACPI device to get IRQ from
+  * @index: index of GpioInt resource (starting from %0)
+  *
+  * If the device has one or more GpioInt resources, this function can be
+  * used to translate from the GPIO offset in the resource to the Linux IRQ
+  * number.
+  *
+  * Return: Linux IRQ number (>%0) on success, negative errno on failure.
+  */
+ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
+ {
+ 	int idx, i;
+ 
+ 	for (i = 0, idx = 0; idx <= index; i++) {
+ 		struct acpi_gpio_info info;
+ 		struct gpio_desc *desc;
+ 
+ 		desc = acpi_get_gpiod_by_index(adev, NULL, i, &info);
+ 		if (IS_ERR(desc))
+ 			break;
+ 		if (info.gpioint && idx++ == index)
+ 			return gpiod_to_irq(desc);
+ 	}
+ 	return -ENOENT;
+ }
+ EXPORT_SYMBOL_GPL(acpi_dev_gpio_irq_get);
+ 
+ static acpi_status
+ acpi_gpio_adr_space_handler(u32 function, acpi_physical_address address,
+ 			    u32 bits, u64 *value, void *handler_context,
+ 			    void *region_context)
+ {
+ 	struct acpi_gpio_chip *achip = region_context;
+ 	struct gpio_chip *chip = achip->chip;
+ 	struct acpi_resource_gpio *agpio;
+ 	struct acpi_resource *ares;
+ 	int pin_index = (int)address;
+ 	acpi_status status;
+ 	bool pull_up;
+ 	int length;
+ 	int i;
+ 
+ 	status = acpi_buffer_to_resource(achip->conn_info.connection,
+ 					 achip->conn_info.length, &ares);
+ 	if (ACPI_FAILURE(status))
+ 		return status;
+ 
+ 	if (WARN_ON(ares->type != ACPI_RESOURCE_TYPE_GPIO)) {
+ 		ACPI_FREE(ares);
+ 		return AE_BAD_PARAMETER;
+ 	}
+ 
+ 	agpio = &ares->data.gpio;
+ 	pull_up = agpio->pin_config == ACPI_PIN_CONFIG_PULLUP;
+ 
+ 	if (WARN_ON(agpio->io_restriction == ACPI_IO_RESTRICT_INPUT &&
+ 	    function == ACPI_WRITE)) {
+ 		ACPI_FREE(ares);
+ 		return AE_BAD_PARAMETER;
+ 	}
+ 
+ 	length = min(agpio->pin_table_length, (u16)(pin_index + bits));
+ 	for (i = pin_index; i < length; ++i) {
+ 		unsigned pin = agpio->pin_table[i];
+ 		struct acpi_gpio_connection *conn;
+ 		struct gpio_desc *desc;
+ 		bool found;
+ 
+ 		pin = acpi_gpiochip_pin_to_gpio_offset(chip, pin);
+ 		if (pin < 0) {
+ 			status = AE_BAD_PARAMETER;
+ 			goto out;
+ 		}
+ 
+ 		mutex_lock(&achip->conn_lock);
+ 
+ 		found = false;
+ 		list_for_each_entry(conn, &achip->conns, node) {
+ 			if (conn->pin == pin) {
+ 				found = true;
+ 				desc = conn->desc;
+ 				break;
+ 			}
+ 		}
+ 		if (!found) {
+ 			desc = gpiochip_request_own_desc(chip, pin,
+ 							 "ACPI:OpRegion");
+ 			if (IS_ERR(desc)) {
+ 				status = AE_ERROR;
+ 				mutex_unlock(&achip->conn_lock);
+ 				goto out;
+ 			}
+ 
+ 			switch (agpio->io_restriction) {
+ 			case ACPI_IO_RESTRICT_INPUT:
+ 				gpiod_direction_input(desc);
+ 				break;
+ 			case ACPI_IO_RESTRICT_OUTPUT:
+ 				/*
+ 				 * ACPI GPIO resources don't contain an
+ 				 * initial value for the GPIO. Therefore we
+ 				 * deduce that value from the pull field
+ 				 * instead. If the pin is pulled up we
+ 				 * assume default to be high, otherwise
+ 				 * low.
+ 				 */
+ 				gpiod_direction_output(desc, pull_up);
+ 				break;
+ 			default:
+ 				/*
+ 				 * Assume that the BIOS has configured the
+ 				 * direction and pull accordingly.
+ 				 */
+ 				break;
+ 			}
+ 
+ 			conn = kzalloc(sizeof(*conn), GFP_KERNEL);
+ 			if (!conn) {
+ 				status = AE_NO_MEMORY;
+ 				gpiochip_free_own_desc(desc);
+ 				mutex_unlock(&achip->conn_lock);
+ 				goto out;
+ 			}
+ 
+ 			conn->pin = pin;
+ 			conn->desc = desc;
+ 			list_add_tail(&conn->node, &achip->conns);
+ 		}
+ 
+ 		mutex_unlock(&achip->conn_lock);
+ 
+ 		if (function == ACPI_WRITE)
+ 			gpiod_set_raw_value_cansleep(desc,
+ 						     !!((1 << i) & *value));
+ 		else
+ 			*value |= (u64)gpiod_get_raw_value_cansleep(desc) << i;
+ 	}
+ 
+ out:
+ 	ACPI_FREE(ares);
+ 	return status;
+ }
+ 
+ static void acpi_gpiochip_request_regions(struct acpi_gpio_chip *achip)
+ {
+ 	struct gpio_chip *chip = achip->chip;
+ 	acpi_handle handle = ACPI_HANDLE(chip->dev);
+ 	acpi_status status;
+ 
+ 	INIT_LIST_HEAD(&achip->conns);
+ 	mutex_init(&achip->conn_lock);
+ 	status = acpi_install_address_space_handler(handle, ACPI_ADR_SPACE_GPIO,
+ 						    acpi_gpio_adr_space_handler,
+ 						    NULL, achip);
+ 	if (ACPI_FAILURE(status))
+ 		dev_err(chip->dev, "Failed to install GPIO OpRegion handler\n");
+ }
+ 
+ static void acpi_gpiochip_free_regions(struct acpi_gpio_chip *achip)
+ {
+ 	struct gpio_chip *chip = achip->chip;
+ 	acpi_handle handle = ACPI_HANDLE(chip->dev);
+ 	struct acpi_gpio_connection *conn, *tmp;
+ 	acpi_status status;
+ 
+ 	status = acpi_remove_address_space_handler(handle, ACPI_ADR_SPACE_GPIO,
+ 						   acpi_gpio_adr_space_handler);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_err(chip->dev, "Failed to remove GPIO OpRegion handler\n");
+ 		return;
+ 	}
+ 
+ 	list_for_each_entry_safe_reverse(conn, tmp, &achip->conns, node) {
+ 		gpiochip_free_own_desc(conn->desc);
+ 		list_del(&conn->node);
+ 		kfree(conn);
+ 	}
+ }
+ 
++>>>>>>> c884fbd45214 (gpio / ACPI: Add support for retrieving GpioInt resources from a device)
  void acpi_gpiochip_add(struct gpio_chip *chip)
  {
 -	struct acpi_gpio_chip *acpi_gpio;
 -	acpi_handle handle;
 -	acpi_status status;
 -
 -	if (!chip || !chip->dev)
 -		return;
 -
 -	handle = ACPI_HANDLE(chip->dev);
 -	if (!handle)
 -		return;
 -
 -	acpi_gpio = kzalloc(sizeof(*acpi_gpio), GFP_KERNEL);
 -	if (!acpi_gpio) {
 -		dev_err(chip->dev,
 -			"Failed to allocate memory for ACPI GPIO chip\n");
 -		return;
 -	}
 -
 -	acpi_gpio->chip = chip;
 -
 -	status = acpi_attach_data(handle, acpi_gpio_chip_dh, acpi_gpio);
 -	if (ACPI_FAILURE(status)) {
 -		dev_err(chip->dev, "Failed to attach ACPI GPIO chip\n");
 -		kfree(acpi_gpio);
 -		return;
 -	}
 -
 -	acpi_gpiochip_request_regions(acpi_gpio);
 +	acpi_gpiochip_request_interrupts(chip);
  }
  
  void acpi_gpiochip_remove(struct gpio_chip *chip)
diff --cc include/linux/acpi.h
index b4bf5e88c857,f57c440642cd..000000000000
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@@ -699,6 -700,43 +699,46 @@@ do {									
  #endif
  #endif
  
++<<<<<<< HEAD
++=======
+ struct acpi_gpio_params {
+ 	unsigned int crs_entry_index;
+ 	unsigned int line_index;
+ 	bool active_low;
+ };
+ 
+ struct acpi_gpio_mapping {
+ 	const char *name;
+ 	const struct acpi_gpio_params *data;
+ 	unsigned int size;
+ };
+ 
+ #if defined(CONFIG_ACPI) && defined(CONFIG_GPIOLIB)
+ int acpi_dev_add_driver_gpios(struct acpi_device *adev,
+ 			      const struct acpi_gpio_mapping *gpios);
+ 
+ static inline void acpi_dev_remove_driver_gpios(struct acpi_device *adev)
+ {
+ 	if (adev)
+ 		adev->driver_gpios = NULL;
+ }
+ 
+ int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index);
+ #else
+ static inline int acpi_dev_add_driver_gpios(struct acpi_device *adev,
+ 			      const struct acpi_gpio_mapping *gpios)
+ {
+ 	return -ENXIO;
+ }
+ static inline void acpi_dev_remove_driver_gpios(struct acpi_device *adev) {}
+ 
+ static inline int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)
+ {
+ 	return -ENXIO;
+ }
+ #endif
+ 
++>>>>>>> c884fbd45214 (gpio / ACPI: Add support for retrieving GpioInt resources from a device)
  /* Device properties */
  
  #define MAX_ACPI_REFERENCE_ARGS	8
* Unmerged path drivers/gpio/gpiolib-acpi.c
* Unmerged path include/linux/acpi.h
