net/mlx5e: Unregister netdev before detaching it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Unregister netdev before detaching it (Don Dutile) [1385330 1417285]
Rebuild_FUZZ: 95.65%
commit-author Mohamad Haj Yahia <mohamad@mellanox.com>
commit 5e1e93c7047381b81236f82f60c15d49c510d1a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5e1e93c7.failed

Detaching the netdev before unregistering it cause some netdev cleanup
ndos to fail because they check presence of the netdev, so we need to
unregister the netdev first.

Fixes: 26e59d8077a3 ('net/mlx5e: Implement mlx5e interface attach/detach callbacks')
	Signed-off-by: Mohamad Haj Yahia <mohamad@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5e1e93c7047381b81236f82f60c15d49c510d1a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 98d2ea9b4528,f4c687ce4c59..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -3144,61 -3900,173 +3144,80 @@@ err_destroy_tises
  err_destroy_umr_mkey:
  	mlx5_core_destroy_mkey(mdev, &priv->umr_mkey);
  
 -out:
 -	return err;
 -}
 +err_destroy_mkey:
 +	mlx5_core_destroy_mkey(mdev, &priv->mkey);
  
 -static void mlx5e_register_vport_rep(struct mlx5_core_dev *mdev)
 -{
 -	struct mlx5_eswitch *esw = mdev->priv.eswitch;
 -	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
 -	int vport;
 -	u8 mac[ETH_ALEN];
 +err_dealloc_transport_domain:
 +	mlx5_core_dealloc_transport_domain(mdev, priv->tdn);
  
 -	if (!MLX5_CAP_GEN(mdev, vport_group_manager))
 -		return;
 +err_dealloc_pd:
 +	mlx5_core_dealloc_pd(mdev, priv->pdn);
  
 -	mlx5_query_nic_vport_mac_address(mdev, 0, mac);
 +err_unmap_free_uar:
 +	mlx5_unmap_free_uar(mdev, &priv->cq_uar);
  
 -	for (vport = 1; vport < total_vfs; vport++) {
 -		struct mlx5_eswitch_rep rep;
 +err_destroy_wq:
 +	destroy_workqueue(priv->wq);
  
 -		rep.load = mlx5e_vport_rep_load;
 -		rep.unload = mlx5e_vport_rep_unload;
 -		rep.vport = vport;
 -		ether_addr_copy(rep.hw_id, mac);
 -		mlx5_eswitch_register_vport_rep(esw, vport, &rep);
 -	}
 +err_free_netdev:
 +	free_netdev(netdev);
 +
 +	return NULL;
  }
  
 -void mlx5e_detach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev)
 +static void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, void *vpriv)
  {
 -	struct mlx5e_priv *priv = netdev_priv(netdev);
 -	const struct mlx5e_profile *profile = priv->profile;
 +	struct mlx5e_priv *priv = vpriv;
 +	struct net_device *netdev = priv->netdev;
  
++<<<<<<< HEAD
  	set_bit(MLX5E_STATE_DESTROYING, &priv->state);
 -	if (profile->disable)
 -		profile->disable(priv);
  
 +	queue_work(priv->wq, &priv->set_rx_mode_work);
 +	mlx5e_disable_async_events(priv);
  	flush_workqueue(priv->wq);
 -
 -	rtnl_lock();
 -	if (netif_running(netdev))
 +	if (test_bit(MLX5_INTERFACE_STATE_SHUTDOWN, &mdev->intf_state)) {
 +		netif_device_detach(netdev);
  		mlx5e_close(netdev);
 -	netif_device_detach(netdev);
 -	rtnl_unlock();
 +	} else {
 +		unregister_netdev(netdev);
 +	}
  
 +	mlx5e_vxlan_cleanup(priv);
  	mlx5e_destroy_q_counter(priv);
 -	profile->cleanup_rx(priv);
 +	mlx5e_destroy_flow_tables(priv);
 +	mlx5e_destroy_tirs(priv);
 +	mlx5e_destroy_rqts(priv);
  	mlx5e_close_drop_rq(priv);
 -	profile->cleanup_tx(priv);
 +	mlx5e_destroy_tises(priv);
  	mlx5_core_destroy_mkey(priv->mdev, &priv->umr_mkey);
 +	mlx5_core_destroy_mkey(priv->mdev, &priv->mkey);
 +	mlx5_core_dealloc_transport_domain(priv->mdev, priv->tdn);
 +	mlx5_core_dealloc_pd(priv->mdev, priv->pdn);
 +	mlx5_unmap_free_uar(priv->mdev, &priv->cq_uar);
  	cancel_delayed_work_sync(&priv->update_stats_work);
 -}
 -
 -/* mlx5e_attach and mlx5e_detach scope should be only creating/destroying
 - * hardware contexts and to connect it to the current netdev.
 - */
 -static int mlx5e_attach(struct mlx5_core_dev *mdev, void *vpriv)
 -{
 -	struct mlx5e_priv *priv = vpriv;
 -	struct net_device *netdev = priv->netdev;
 -	int err;
 -
 -	if (netif_device_present(netdev))
 -		return 0;
 -
 -	err = mlx5e_create_mdev_resources(mdev);
 -	if (err)
 -		return err;
 -
 -	err = mlx5e_attach_netdev(mdev, netdev);
 -	if (err) {
 -		mlx5e_destroy_mdev_resources(mdev);
 -		return err;
 -	}
 -
 -	return 0;
 -}
 -
 -static void mlx5e_detach(struct mlx5_core_dev *mdev, void *vpriv)
 -{
 -	struct mlx5e_priv *priv = vpriv;
 -	struct net_device *netdev = priv->netdev;
 -
 -	if (!netif_device_present(netdev))
 -		return;
 -
 -	mlx5e_detach_netdev(mdev, netdev);
 -	mlx5e_destroy_mdev_resources(mdev);
 -}
 -
 -static void *mlx5e_add(struct mlx5_core_dev *mdev)
 -{
 -	struct mlx5_eswitch *esw = mdev->priv.eswitch;
 -	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
 -	void *ppriv = NULL;
 -	void *priv;
 -	int vport;
 -	int err;
 -	struct net_device *netdev;
 -
 -	err = mlx5e_check_required_hca_cap(mdev);
 -	if (err)
 -		return NULL;
 -
 -	mlx5e_register_vport_rep(mdev);
 -
 -	if (MLX5_CAP_GEN(mdev, vport_group_manager))
 -		ppriv = &esw->offloads.vport_reps[0];
 -
 -	netdev = mlx5e_create_netdev(mdev, &mlx5e_nic_profile, ppriv);
 -	if (!netdev) {
 -		mlx5_core_err(mdev, "mlx5e_create_netdev failed\n");
 -		goto err_unregister_reps;
 -	}
 -
 -	priv = netdev_priv(netdev);
 -
 -	err = mlx5e_attach(mdev, priv);
 -	if (err) {
 -		mlx5_core_err(mdev, "mlx5e_attach failed, %d\n", err);
 -		goto err_destroy_netdev;
 -	}
 -
 -	err = register_netdev(netdev);
 -	if (err) {
 -		mlx5_core_err(mdev, "register_netdev failed, %d\n", err);
 -		goto err_detach;
 -	}
 -
 -	return priv;
 -
 -err_detach:
 -	mlx5e_detach(mdev, priv);
 -
 -err_destroy_netdev:
 -	mlx5e_destroy_netdev(mdev, priv);
 -
 -err_unregister_reps:
 -	for (vport = 1; vport < total_vfs; vport++)
 -		mlx5_eswitch_unregister_vport_rep(esw, vport);
 -
 -	return NULL;
 -}
 -
 -void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, struct mlx5e_priv *priv)
 -{
 -	const struct mlx5e_profile *profile = priv->profile;
 -	struct net_device *netdev = priv->netdev;
 -
++=======
++>>>>>>> 5e1e93c70473 (net/mlx5e: Unregister netdev before detaching it)
  	destroy_workqueue(priv->wq);
 -	if (profile->cleanup)
 -		profile->cleanup(priv);
 -	free_netdev(netdev);
 -}
  
++<<<<<<< HEAD
 +	if (!test_bit(MLX5_INTERFACE_STATE_SHUTDOWN, &mdev->intf_state))
 +		free_netdev(netdev);
++=======
+ static void mlx5e_remove(struct mlx5_core_dev *mdev, void *vpriv)
+ {
+ 	struct mlx5_eswitch *esw = mdev->priv.eswitch;
+ 	int total_vfs = MLX5_TOTAL_VPORTS(mdev);
+ 	struct mlx5e_priv *priv = vpriv;
+ 	int vport;
+ 
+ 	for (vport = 1; vport < total_vfs; vport++)
+ 		mlx5_eswitch_unregister_vport_rep(esw, vport);
+ 
+ 	unregister_netdev(priv->netdev);
+ 	mlx5e_detach(mdev, vpriv);
+ 	mlx5e_destroy_netdev(mdev, priv);
++>>>>>>> 5e1e93c70473 (net/mlx5e: Unregister netdev before detaching it)
  }
  
  static void *mlx5e_get_netdev(void *vpriv)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
