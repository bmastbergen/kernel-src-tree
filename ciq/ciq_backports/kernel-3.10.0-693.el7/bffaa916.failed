net/mlx5: E-Switch, Add control for inline mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Add control for inline mode (Don Dutile) [1385330 1417286]
Rebuild_FUZZ: 95.56%
commit-author Roi Dayan <roid@mellanox.com>
commit bffaa916588ebb065cfa0287195d9ad35612eecf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/bffaa916.failed

Implement devlink show and set of HW inline-mode.
The supported modes: none, link, network, transport.
We currently support one mode for all vports so set is done on all vports.
When eswitch is first initialized the inline-mode is queried from the FW.

	Signed-off-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bffaa916588ebb065cfa0287195d9ad35612eecf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
#	drivers/net/ethernet/mellanox/mlx5/core/main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 084178cfa483,d6807c3cc461..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1379,8 -1797,9 +1379,13 @@@ int mlx5_eswitch_init(struct mlx5_core_
  
  	esw->total_vports = total_vports;
  	esw->enabled_vports = 0;
++<<<<<<< HEAD
++=======
+ 	esw->mode = SRIOV_NONE;
+ 	esw->offloads.inline_mode = MLX5_INLINE_MODE_NONE;
++>>>>>>> bffaa916588e (net/mlx5: E-Switch, Add control for inline mode)
  
 +	mlx5_eswitch_attach(esw);
  	dev->priv.eswitch = esw;
  	return 0;
  abort:
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 7b5e70f8cc22,cf1aa56424bd..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -130,9 -151,56 +130,62 @@@ struct mlx5_l2_table 
  
  struct mlx5_eswitch_fdb {
  	void *fdb;
++<<<<<<< HEAD
 +	struct mlx5_flow_group *addr_grp;
 +	struct mlx5_flow_group *allmulti_grp;
 +	struct mlx5_flow_group *promisc_grp;
++=======
+ 	union {
+ 		struct legacy_fdb {
+ 			struct mlx5_flow_group *addr_grp;
+ 			struct mlx5_flow_group *allmulti_grp;
+ 			struct mlx5_flow_group *promisc_grp;
+ 		} legacy;
+ 
+ 		struct offloads_fdb {
+ 			struct mlx5_flow_table *fdb;
+ 			struct mlx5_flow_group *send_to_vport_grp;
+ 			struct mlx5_flow_group *miss_grp;
+ 			struct mlx5_flow_handle *miss_rule;
+ 			int vlan_push_pop_refcount;
+ 		} offloads;
+ 	};
+ };
+ 
+ enum {
+ 	SRIOV_NONE,
+ 	SRIOV_LEGACY,
+ 	SRIOV_OFFLOADS
+ };
+ 
+ struct mlx5_esw_sq {
+ 	struct mlx5_flow_handle	*send_to_vport_rule;
+ 	struct list_head	 list;
+ };
+ 
+ struct mlx5_eswitch_rep {
+ 	int		       (*load)(struct mlx5_eswitch *esw,
+ 				       struct mlx5_eswitch_rep *rep);
+ 	void		       (*unload)(struct mlx5_eswitch *esw,
+ 					 struct mlx5_eswitch_rep *rep);
+ 	u16		       vport;
+ 	u8		       hw_id[ETH_ALEN];
+ 	void		      *priv_data;
+ 
+ 	struct mlx5_flow_handle *vport_rx_rule;
+ 	struct list_head       vport_sqs_list;
+ 	u16		       vlan;
+ 	u32		       vlan_refcount;
+ 	bool		       valid;
+ };
+ 
+ struct mlx5_esw_offload {
+ 	struct mlx5_flow_table *ft_offloads;
+ 	struct mlx5_flow_group *vport_rx_group;
+ 	struct mlx5_eswitch_rep *vport_reps;
+ 	DECLARE_HASHTABLE(encap_tbl, 8);
+ 	u8 inline_mode;
++>>>>>>> bffaa916588e (net/mlx5: E-Switch, Add control for inline mode)
  };
  
  struct mlx5_eswitch {
@@@ -170,4 -256,84 +223,87 @@@ int mlx5_eswitch_get_vport_stats(struc
  				 int vport,
  				 struct ifla_vf_stats *vf_stats);
  
++<<<<<<< HEAD
++=======
+ struct mlx5_flow_spec;
+ struct mlx5_esw_flow_attr;
+ 
+ struct mlx5_flow_handle *
+ mlx5_eswitch_add_offloaded_rule(struct mlx5_eswitch *esw,
+ 				struct mlx5_flow_spec *spec,
+ 				struct mlx5_esw_flow_attr *attr);
+ struct mlx5_flow_handle *
+ mlx5_eswitch_create_vport_rx_rule(struct mlx5_eswitch *esw, int vport, u32 tirn);
+ 
+ enum {
+ 	SET_VLAN_STRIP	= BIT(0),
+ 	SET_VLAN_INSERT	= BIT(1)
+ };
+ 
+ #define MLX5_FLOW_CONTEXT_ACTION_VLAN_POP  0x40
+ #define MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH 0x80
+ 
+ struct mlx5_encap_info {
+ 	__be32 daddr;
+ 	__be32 tun_id;
+ 	__be16 tp_dst;
+ };
+ 
+ struct mlx5_encap_entry {
+ 	struct hlist_node encap_hlist;
+ 	struct list_head flows;
+ 	u32 encap_id;
+ 	struct neighbour *n;
+ 	struct mlx5_encap_info tun_info;
+ 	unsigned char h_dest[ETH_ALEN];	/* destination eth addr	*/
+ 
+ 	struct net_device *out_dev;
+ 	int tunnel_type;
+ };
+ 
+ struct mlx5_esw_flow_attr {
+ 	struct mlx5_eswitch_rep *in_rep;
+ 	struct mlx5_eswitch_rep *out_rep;
+ 
+ 	int	action;
+ 	u16	vlan;
+ 	bool	vlan_handled;
+ 	struct mlx5_encap_entry *encap;
+ };
+ 
+ int mlx5_eswitch_sqs2vport_start(struct mlx5_eswitch *esw,
+ 				 struct mlx5_eswitch_rep *rep,
+ 				 u16 *sqns_array, int sqns_num);
+ void mlx5_eswitch_sqs2vport_stop(struct mlx5_eswitch *esw,
+ 				 struct mlx5_eswitch_rep *rep);
+ 
+ int mlx5_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode);
+ int mlx5_devlink_eswitch_mode_get(struct devlink *devlink, u16 *mode);
+ int mlx5_devlink_eswitch_inline_mode_set(struct devlink *devlink, u8 mode);
+ int mlx5_devlink_eswitch_inline_mode_get(struct devlink *devlink, u8 *mode);
+ int mlx5_eswitch_inline_mode_get(struct mlx5_eswitch *esw, int nvfs, u8 *mode);
+ void mlx5_eswitch_register_vport_rep(struct mlx5_eswitch *esw,
+ 				     int vport_index,
+ 				     struct mlx5_eswitch_rep *rep);
+ void mlx5_eswitch_unregister_vport_rep(struct mlx5_eswitch *esw,
+ 				       int vport_index);
+ 
+ int mlx5_eswitch_add_vlan_action(struct mlx5_eswitch *esw,
+ 				 struct mlx5_esw_flow_attr *attr);
+ int mlx5_eswitch_del_vlan_action(struct mlx5_eswitch *esw,
+ 				 struct mlx5_esw_flow_attr *attr);
+ int __mlx5_eswitch_set_vport_vlan(struct mlx5_eswitch *esw,
+ 				  int vport, u16 vlan, u8 qos, u8 set_flags);
+ 
+ #define MLX5_DEBUG_ESWITCH_MASK BIT(3)
+ 
+ #define esw_info(dev, format, ...)				\
+ 	pr_info("(%s): E-Switch: " format, (dev)->priv.name, ##__VA_ARGS__)
+ 
+ #define esw_warn(dev, format, ...)				\
+ 	pr_warn("(%s): E-Switch: " format, (dev)->priv.name, ##__VA_ARGS__)
+ 
+ #define esw_debug(dev, format, ...)				\
+ 	mlx5_core_dbg_mask(dev, MLX5_DEBUG_ESWITCH_MASK, format, ##__VA_ARGS__)
++>>>>>>> bffaa916588e (net/mlx5: E-Switch, Add control for inline mode)
  #endif /* __MLX5_ESWITCH_H__ */
diff --cc drivers/net/ethernet/mellanox/mlx5/core/main.c
index 9ec7bca8d8bb,b440a16101d2..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@@ -1341,7 -1235,16 +1341,18 @@@ struct mlx5_core_event_handler 
  		      void *data);
  };
  
++<<<<<<< HEAD
++=======
+ static const struct devlink_ops mlx5_devlink_ops = {
+ #ifdef CONFIG_MLX5_CORE_EN
+ 	.eswitch_mode_set = mlx5_devlink_eswitch_mode_set,
+ 	.eswitch_mode_get = mlx5_devlink_eswitch_mode_get,
+ 	.eswitch_inline_mode_set = mlx5_devlink_eswitch_inline_mode_set,
+ 	.eswitch_inline_mode_get = mlx5_devlink_eswitch_inline_mode_get,
+ #endif
+ };
++>>>>>>> bffaa916588e (net/mlx5: E-Switch, Add control for inline mode)
  
 -#define MLX5_IB_MOD "mlx5_ib"
  static int init_one(struct pci_dev *pdev,
  		    const struct pci_device_id *id)
  {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/main.c
