Btrfs: memset to avoid stale content in btree leaf

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Liu Bo <bo.li.liu@oracle.com>
commit 851cd173f06045816528176001cf82948282029c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/851cd173.failed

This is an additional patch to
"Btrfs: memset to avoid stale content in btree node block".

This uses memset to initialize the unused space in a leaf to avoid
potential stale content, which may be incurred by pushing items
between sibling leaves.

	Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
	Reviewed-by: David Sterba <dsterba@suse.com>
	Signed-off-by: David Sterba <dsterba@suse.com>
(cherry picked from commit 851cd173f06045816528176001cf82948282029c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/extent_io.c
diff --cc fs/btrfs/extent_io.c
index 4e9385653aea,ee40384c394d..000000000000
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@@ -3745,9 -3725,11 +3745,15 @@@ static noinline_for_stack int write_one
  	struct block_device *bdev = fs_info->fs_devices->latest_bdev;
  	struct extent_io_tree *tree = &BTRFS_I(fs_info->btree_inode)->io_tree;
  	u64 offset = eb->start;
+ 	u32 nritems;
  	unsigned long i, num_pages;
  	unsigned long bio_flags = 0;
++<<<<<<< HEAD
 +	int rw = (epd->sync_io ? WRITE_SYNC : WRITE) | REQ_META;
++=======
+ 	unsigned long start, end;
+ 	int write_flags = (epd->sync_io ? WRITE_SYNC : 0) | REQ_META;
++>>>>>>> 851cd173f060 (Btrfs: memset to avoid stale content in btree leaf)
  	int ret = 0;
  
  	clear_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags);
diff --git a/fs/btrfs/ctree.c b/fs/btrfs/ctree.c
index 87811240b15a..a52c926b8c37 100644
--- a/fs/btrfs/ctree.c
+++ b/fs/btrfs/ctree.c
@@ -1713,20 +1713,6 @@ int btrfs_realloc_node(struct btrfs_trans_handle *trans,
 	return err;
 }
 
-/*
- * The leaf data grows from end-to-front in the node.
- * this returns the address of the start of the last item,
- * which is the stop of the leaf data stack
- */
-static inline unsigned int leaf_data_end(struct btrfs_root *root,
-					 struct extent_buffer *leaf)
-{
-	u32 nr = btrfs_header_nritems(leaf);
-	if (nr == 0)
-		return BTRFS_LEAF_DATA_SIZE(root);
-	return btrfs_item_offset_nr(leaf, nr - 1);
-}
-
 
 /*
  * search for key in the extent_buffer.  The items start at offset p,
diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index 48f38b765f55..4886a5bd54dd 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -2252,6 +2252,21 @@ static inline unsigned long btrfs_leaf_data(struct extent_buffer *l)
 	return offsetof(struct btrfs_leaf, items);
 }
 
+/*
+ * The leaf data grows from end-to-front in the node.
+ * this returns the address of the start of the last item,
+ * which is the stop of the leaf data stack
+ */
+static inline unsigned int leaf_data_end(struct btrfs_root *root,
+					 struct extent_buffer *leaf)
+{
+	u32 nr = btrfs_header_nritems(leaf);
+
+	if (nr == 0)
+		return BTRFS_LEAF_DATA_SIZE(root);
+	return btrfs_item_offset_nr(leaf, nr - 1);
+}
+
 /* struct btrfs_file_extent_item */
 BTRFS_SETGET_FUNCS(file_extent_type, struct btrfs_file_extent_item, type, 8);
 BTRFS_SETGET_STACK_FUNCS(stack_file_extent_disk_bytenr,
* Unmerged path fs/btrfs/extent_io.c
