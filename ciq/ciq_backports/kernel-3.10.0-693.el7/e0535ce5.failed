net sched actions: allocate act cookie early

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: actions: allocate act cookie early (Ivan Vecera) [1447674]
Rebuild_FUZZ: 94.12%
commit-author Wolfgang Bumiller <w.bumiller@proxmox.com>
commit e0535ce58b92d7baf0b33284a6c4f8f0338f943e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e0535ce5.failed

Policing filters do not use the TCA_ACT_* enum and the tb[]
nlattr array in tcf_action_init_1() doesn't get filled for
them so we should not try to look for a TCA_ACT_COOKIE
attribute in the then uninitialized array.
The error handling in cookie allocation then calls
tcf_hash_release() leading to invalid memory access later
on.
Additionally, if cookie allocation fails after an already
existing non-policing filter has successfully been changed,
tcf_action_release() should not be called, also we would
have to roll back the changes in the error handling, so
instead we now allocate the cookie early and assign it on
success at the end.

CVE-2017-7979
Fixes: 1045ba77a596 ("net sched actions: Add support for user cookies")
	Signed-off-by: Wolfgang Bumiller <w.bumiller@proxmox.com>
	Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e0535ce58b92d7baf0b33284a6c4f8f0338f943e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_api.c
diff --cc net/sched/act_api.c
index 45d305cc522a,e05b924618a0..000000000000
--- a/net/sched/act_api.c
+++ b/net/sched/act_api.c
@@@ -442,6 -529,22 +442,25 @@@ errout
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static struct tc_cookie *nla_memdup_cookie(struct nlattr **tb)
+ {
+ 	struct tc_cookie *c = kzalloc(sizeof(*c), GFP_KERNEL);
+ 	if (!c)
+ 		return NULL;
+ 
+ 	c->data = nla_memdup(tb[TCA_ACT_COOKIE], GFP_KERNEL);
+ 	if (!c->data) {
+ 		kfree(c);
+ 		return NULL;
+ 	}
+ 	c->len = nla_len(tb[TCA_ACT_COOKIE]);
+ 
+ 	return c;
+ }
+ 
++>>>>>>> e0535ce58b92 (net sched actions: allocate act cookie early)
  struct tc_action *tcf_action_init_1(struct net *net, struct nlattr *nla,
  				    struct nlattr *est, char *name, int ovr,
  				    int bind)
@@@ -493,19 -609,21 +525,29 @@@
  		goto err_out;
  	}
  
 +	err = -ENOMEM;
 +	a = kzalloc(sizeof(*a), GFP_KERNEL);
 +	if (a == NULL)
 +		goto err_mod;
 +
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&a->list);
  	/* backward compatibility for policer */
  	if (name == NULL)
 -		err = a_o->init(net, tb[TCA_ACT_OPTIONS], est, &a, ovr, bind);
 +		err = a_o->init(net, tb[TCA_ACT_OPTIONS], est, a, ovr, bind);
  	else
 -		err = a_o->init(net, nla, est, &a, ovr, bind);
 +		err = a_o->init(net, nla, est, a, ovr, bind);
  	if (err < 0)
 -		goto err_mod;
 -
 +		goto err_free;
++=======
+ 	if (name == NULL && tb[TCA_ACT_COOKIE]) {
+ 		if (a->act_cookie) {
+ 			kfree(a->act_cookie->data);
+ 			kfree(a->act_cookie);
+ 		}
+ 		a->act_cookie = cookie;
+ 	}
++>>>>>>> e0535ce58b92 (net sched actions: allocate act cookie early)
  
  	/* module count goes up only when brand new policy is created
  	 * if it exists and is only bound to in a_o->init() then
* Unmerged path net/sched/act_api.c
