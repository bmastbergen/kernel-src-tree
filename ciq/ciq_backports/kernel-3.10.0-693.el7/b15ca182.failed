netlink: Add nla_memdup() to wrap kmemdup() use on nlattr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Thomas Graf <tgraf@suug.ch>
commit b15ca182ed136087f6a2cb9ffe880c923f36a56e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b15ca182.failed

Wrap several common instances of:
	kmemdup(nla_data(attr), nla_len(attr), GFP_KERNEL);

	Signed-off-by: Thomas Graf <tgraf@suug.ch>
	Acked-by: Johannes Berg <johannes@sipsolutions.net>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b15ca182ed136087f6a2cb9ffe880c923f36a56e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/act_bpf.c
#	net/sched/cls_bpf.c
#	net/wireless/nl80211.c
diff --cc net/sched/cls_bpf.c
index 95b1641cf7a7,52dc85acca7d..000000000000
--- a/net/sched/cls_bpf.c
+++ b/net/sched/cls_bpf.c
@@@ -149,6 -316,77 +149,80 @@@ static unsigned long cls_bpf_get(struc
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int cls_bpf_prog_from_ops(struct nlattr **tb, struct cls_bpf_prog *prog)
+ {
+ 	struct sock_filter *bpf_ops;
+ 	struct sock_fprog_kern fprog_tmp;
+ 	struct bpf_prog *fp;
+ 	u16 bpf_size, bpf_num_ops;
+ 	int ret;
+ 
+ 	bpf_num_ops = nla_get_u16(tb[TCA_BPF_OPS_LEN]);
+ 	if (bpf_num_ops > BPF_MAXINSNS || bpf_num_ops == 0)
+ 		return -EINVAL;
+ 
+ 	bpf_size = bpf_num_ops * sizeof(*bpf_ops);
+ 	if (bpf_size != nla_len(tb[TCA_BPF_OPS]))
+ 		return -EINVAL;
+ 
+ 	bpf_ops = kzalloc(bpf_size, GFP_KERNEL);
+ 	if (bpf_ops == NULL)
+ 		return -ENOMEM;
+ 
+ 	memcpy(bpf_ops, nla_data(tb[TCA_BPF_OPS]), bpf_size);
+ 
+ 	fprog_tmp.len = bpf_num_ops;
+ 	fprog_tmp.filter = bpf_ops;
+ 
+ 	ret = bpf_prog_create(&fp, &fprog_tmp);
+ 	if (ret < 0) {
+ 		kfree(bpf_ops);
+ 		return ret;
+ 	}
+ 
+ 	prog->bpf_ops = bpf_ops;
+ 	prog->bpf_num_ops = bpf_num_ops;
+ 	prog->bpf_name = NULL;
+ 	prog->filter = fp;
+ 
+ 	return 0;
+ }
+ 
+ static int cls_bpf_prog_from_efd(struct nlattr **tb, struct cls_bpf_prog *prog,
+ 				 const struct tcf_proto *tp)
+ {
+ 	struct bpf_prog *fp;
+ 	char *name = NULL;
+ 	u32 bpf_fd;
+ 
+ 	bpf_fd = nla_get_u32(tb[TCA_BPF_FD]);
+ 
+ 	fp = bpf_prog_get_type(bpf_fd, BPF_PROG_TYPE_SCHED_CLS);
+ 	if (IS_ERR(fp))
+ 		return PTR_ERR(fp);
+ 
+ 	if (tb[TCA_BPF_NAME]) {
+ 		name = nla_memdup(tb[TCA_BPF_NAME], GFP_KERNEL);
+ 		if (!name) {
+ 			bpf_prog_put(fp);
+ 			return -ENOMEM;
+ 		}
+ 	}
+ 
+ 	prog->bpf_ops = NULL;
+ 	prog->bpf_fd = bpf_fd;
+ 	prog->bpf_name = name;
+ 	prog->filter = fp;
+ 
+ 	if (fp->dst_needed && !(tp->q->flags & TCQ_F_INGRESS))
+ 		netif_keep_dst(qdisc_dev(tp->q));
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> b15ca182ed13 (netlink: Add nla_memdup() to wrap kmemdup() use on nlattr)
  static int cls_bpf_modify_existing(struct net *net, struct tcf_proto *tp,
  				   struct cls_bpf_prog *prog,
  				   unsigned long base, struct nlattr **tb,
diff --cc net/wireless/nl80211.c
index d6c35d1c99b6,0d3ab4bfeacf..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -10193,6 -10537,548 +10193,551 @@@ static int nl80211_stop_p2p_device(stru
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int nl80211_start_nan(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ 	struct wireless_dev *wdev = info->user_ptr[1];
+ 	struct cfg80211_nan_conf conf = {};
+ 	int err;
+ 
+ 	if (wdev->iftype != NL80211_IFTYPE_NAN)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (wdev->nan_started)
+ 		return -EEXIST;
+ 
+ 	if (rfkill_blocked(rdev->rfkill))
+ 		return -ERFKILL;
+ 
+ 	if (!info->attrs[NL80211_ATTR_NAN_MASTER_PREF])
+ 		return -EINVAL;
+ 
+ 	if (!info->attrs[NL80211_ATTR_NAN_DUAL])
+ 		return -EINVAL;
+ 
+ 	conf.master_pref =
+ 		nla_get_u8(info->attrs[NL80211_ATTR_NAN_MASTER_PREF]);
+ 	if (!conf.master_pref)
+ 		return -EINVAL;
+ 
+ 	conf.dual = nla_get_u8(info->attrs[NL80211_ATTR_NAN_DUAL]);
+ 
+ 	err = rdev_start_nan(rdev, wdev, &conf);
+ 	if (err)
+ 		return err;
+ 
+ 	wdev->nan_started = true;
+ 	rdev->opencount++;
+ 
+ 	return 0;
+ }
+ 
+ static int nl80211_stop_nan(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ 	struct wireless_dev *wdev = info->user_ptr[1];
+ 
+ 	if (wdev->iftype != NL80211_IFTYPE_NAN)
+ 		return -EOPNOTSUPP;
+ 
+ 	cfg80211_stop_nan(rdev, wdev);
+ 
+ 	return 0;
+ }
+ 
+ static int validate_nan_filter(struct nlattr *filter_attr)
+ {
+ 	struct nlattr *attr;
+ 	int len = 0, n_entries = 0, rem;
+ 
+ 	nla_for_each_nested(attr, filter_attr, rem) {
+ 		len += nla_len(attr);
+ 		n_entries++;
+ 	}
+ 
+ 	if (len >= U8_MAX)
+ 		return -EINVAL;
+ 
+ 	return n_entries;
+ }
+ 
+ static int handle_nan_filter(struct nlattr *attr_filter,
+ 			     struct cfg80211_nan_func *func,
+ 			     bool tx)
+ {
+ 	struct nlattr *attr;
+ 	int n_entries, rem, i;
+ 	struct cfg80211_nan_func_filter *filter;
+ 
+ 	n_entries = validate_nan_filter(attr_filter);
+ 	if (n_entries < 0)
+ 		return n_entries;
+ 
+ 	BUILD_BUG_ON(sizeof(*func->rx_filters) != sizeof(*func->tx_filters));
+ 
+ 	filter = kcalloc(n_entries, sizeof(*func->rx_filters), GFP_KERNEL);
+ 	if (!filter)
+ 		return -ENOMEM;
+ 
+ 	i = 0;
+ 	nla_for_each_nested(attr, attr_filter, rem) {
+ 		filter[i].filter = nla_memdup(attr, GFP_KERNEL);
+ 		filter[i].len = nla_len(attr);
+ 		i++;
+ 	}
+ 	if (tx) {
+ 		func->num_tx_filters = n_entries;
+ 		func->tx_filters = filter;
+ 	} else {
+ 		func->num_rx_filters = n_entries;
+ 		func->rx_filters = filter;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nl80211_nan_add_func(struct sk_buff *skb,
+ 				struct genl_info *info)
+ {
+ 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ 	struct wireless_dev *wdev = info->user_ptr[1];
+ 	struct nlattr *tb[NUM_NL80211_NAN_FUNC_ATTR], *func_attr;
+ 	struct cfg80211_nan_func *func;
+ 	struct sk_buff *msg = NULL;
+ 	void *hdr = NULL;
+ 	int err = 0;
+ 
+ 	if (wdev->iftype != NL80211_IFTYPE_NAN)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (!wdev->nan_started)
+ 		return -ENOTCONN;
+ 
+ 	if (!info->attrs[NL80211_ATTR_NAN_FUNC])
+ 		return -EINVAL;
+ 
+ 	if (wdev->owner_nlportid &&
+ 	    wdev->owner_nlportid != info->snd_portid)
+ 		return -ENOTCONN;
+ 
+ 	err = nla_parse(tb, NL80211_NAN_FUNC_ATTR_MAX,
+ 			nla_data(info->attrs[NL80211_ATTR_NAN_FUNC]),
+ 			nla_len(info->attrs[NL80211_ATTR_NAN_FUNC]),
+ 			nl80211_nan_func_policy);
+ 	if (err)
+ 		return err;
+ 
+ 	func = kzalloc(sizeof(*func), GFP_KERNEL);
+ 	if (!func)
+ 		return -ENOMEM;
+ 
+ 	func->cookie = wdev->wiphy->cookie_counter++;
+ 
+ 	if (!tb[NL80211_NAN_FUNC_TYPE] ||
+ 	    nla_get_u8(tb[NL80211_NAN_FUNC_TYPE]) > NL80211_NAN_FUNC_MAX_TYPE) {
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 
+ 	func->type = nla_get_u8(tb[NL80211_NAN_FUNC_TYPE]);
+ 
+ 	if (!tb[NL80211_NAN_FUNC_SERVICE_ID]) {
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	memcpy(func->service_id, nla_data(tb[NL80211_NAN_FUNC_SERVICE_ID]),
+ 	       sizeof(func->service_id));
+ 
+ 	func->close_range =
+ 		nla_get_flag(tb[NL80211_NAN_FUNC_CLOSE_RANGE]);
+ 
+ 	if (tb[NL80211_NAN_FUNC_SERVICE_INFO]) {
+ 		func->serv_spec_info_len =
+ 			nla_len(tb[NL80211_NAN_FUNC_SERVICE_INFO]);
+ 		func->serv_spec_info =
+ 			kmemdup(nla_data(tb[NL80211_NAN_FUNC_SERVICE_INFO]),
+ 				func->serv_spec_info_len,
+ 				GFP_KERNEL);
+ 		if (!func->serv_spec_info) {
+ 			err = -ENOMEM;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	if (tb[NL80211_NAN_FUNC_TTL])
+ 		func->ttl = nla_get_u32(tb[NL80211_NAN_FUNC_TTL]);
+ 
+ 	switch (func->type) {
+ 	case NL80211_NAN_FUNC_PUBLISH:
+ 		if (!tb[NL80211_NAN_FUNC_PUBLISH_TYPE]) {
+ 			err = -EINVAL;
+ 			goto out;
+ 		}
+ 
+ 		func->publish_type =
+ 			nla_get_u8(tb[NL80211_NAN_FUNC_PUBLISH_TYPE]);
+ 		func->publish_bcast =
+ 			nla_get_flag(tb[NL80211_NAN_FUNC_PUBLISH_BCAST]);
+ 
+ 		if ((!(func->publish_type & NL80211_NAN_SOLICITED_PUBLISH)) &&
+ 			func->publish_bcast) {
+ 			err = -EINVAL;
+ 			goto out;
+ 		}
+ 		break;
+ 	case NL80211_NAN_FUNC_SUBSCRIBE:
+ 		func->subscribe_active =
+ 			nla_get_flag(tb[NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE]);
+ 		break;
+ 	case NL80211_NAN_FUNC_FOLLOW_UP:
+ 		if (!tb[NL80211_NAN_FUNC_FOLLOW_UP_ID] ||
+ 		    !tb[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID]) {
+ 			err = -EINVAL;
+ 			goto out;
+ 		}
+ 
+ 		func->followup_id =
+ 			nla_get_u8(tb[NL80211_NAN_FUNC_FOLLOW_UP_ID]);
+ 		func->followup_reqid =
+ 			nla_get_u8(tb[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID]);
+ 		memcpy(func->followup_dest.addr,
+ 		       nla_data(tb[NL80211_NAN_FUNC_FOLLOW_UP_DEST]),
+ 		       sizeof(func->followup_dest.addr));
+ 		if (func->ttl) {
+ 			err = -EINVAL;
+ 			goto out;
+ 		}
+ 		break;
+ 	default:
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	if (tb[NL80211_NAN_FUNC_SRF]) {
+ 		struct nlattr *srf_tb[NUM_NL80211_NAN_SRF_ATTR];
+ 
+ 		err = nla_parse(srf_tb, NL80211_NAN_SRF_ATTR_MAX,
+ 				nla_data(tb[NL80211_NAN_FUNC_SRF]),
+ 				nla_len(tb[NL80211_NAN_FUNC_SRF]), NULL);
+ 		if (err)
+ 			goto out;
+ 
+ 		func->srf_include =
+ 			nla_get_flag(srf_tb[NL80211_NAN_SRF_INCLUDE]);
+ 
+ 		if (srf_tb[NL80211_NAN_SRF_BF]) {
+ 			if (srf_tb[NL80211_NAN_SRF_MAC_ADDRS] ||
+ 			    !srf_tb[NL80211_NAN_SRF_BF_IDX]) {
+ 				err = -EINVAL;
+ 				goto out;
+ 			}
+ 
+ 			func->srf_bf_len =
+ 				nla_len(srf_tb[NL80211_NAN_SRF_BF]);
+ 			func->srf_bf =
+ 				kmemdup(nla_data(srf_tb[NL80211_NAN_SRF_BF]),
+ 					func->srf_bf_len, GFP_KERNEL);
+ 			if (!func->srf_bf) {
+ 				err = -ENOMEM;
+ 				goto out;
+ 			}
+ 
+ 			func->srf_bf_idx =
+ 				nla_get_u8(srf_tb[NL80211_NAN_SRF_BF_IDX]);
+ 		} else {
+ 			struct nlattr *attr, *mac_attr =
+ 				srf_tb[NL80211_NAN_SRF_MAC_ADDRS];
+ 			int n_entries, rem, i = 0;
+ 
+ 			if (!mac_attr) {
+ 				err = -EINVAL;
+ 				goto out;
+ 			}
+ 
+ 			n_entries = validate_acl_mac_addrs(mac_attr);
+ 			if (n_entries <= 0) {
+ 				err = -EINVAL;
+ 				goto out;
+ 			}
+ 
+ 			func->srf_num_macs = n_entries;
+ 			func->srf_macs =
+ 				kzalloc(sizeof(*func->srf_macs) * n_entries,
+ 					GFP_KERNEL);
+ 			if (!func->srf_macs) {
+ 				err = -ENOMEM;
+ 				goto out;
+ 			}
+ 
+ 			nla_for_each_nested(attr, mac_attr, rem)
+ 				memcpy(func->srf_macs[i++].addr, nla_data(attr),
+ 				       sizeof(*func->srf_macs));
+ 		}
+ 	}
+ 
+ 	if (tb[NL80211_NAN_FUNC_TX_MATCH_FILTER]) {
+ 		err = handle_nan_filter(tb[NL80211_NAN_FUNC_TX_MATCH_FILTER],
+ 					func, true);
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ 	if (tb[NL80211_NAN_FUNC_RX_MATCH_FILTER]) {
+ 		err = handle_nan_filter(tb[NL80211_NAN_FUNC_RX_MATCH_FILTER],
+ 					func, false);
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg) {
+ 		err = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	hdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,
+ 			     NL80211_CMD_ADD_NAN_FUNCTION);
+ 	/* This can't really happen - we just allocated 4KB */
+ 	if (WARN_ON(!hdr)) {
+ 		err = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	err = rdev_add_nan_func(rdev, wdev, func);
+ out:
+ 	if (err < 0) {
+ 		cfg80211_free_nan_func(func);
+ 		nlmsg_free(msg);
+ 		return err;
+ 	}
+ 
+ 	/* propagate the instance id and cookie to userspace  */
+ 	if (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, func->cookie,
+ 			      NL80211_ATTR_PAD))
+ 		goto nla_put_failure;
+ 
+ 	func_attr = nla_nest_start(msg, NL80211_ATTR_NAN_FUNC);
+ 	if (!func_attr)
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID,
+ 		       func->instance_id))
+ 		goto nla_put_failure;
+ 
+ 	nla_nest_end(msg, func_attr);
+ 
+ 	genlmsg_end(msg, hdr);
+ 	return genlmsg_reply(msg, info);
+ 
+ nla_put_failure:
+ 	nlmsg_free(msg);
+ 	return -ENOBUFS;
+ }
+ 
+ static int nl80211_nan_del_func(struct sk_buff *skb,
+ 			       struct genl_info *info)
+ {
+ 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ 	struct wireless_dev *wdev = info->user_ptr[1];
+ 	u64 cookie;
+ 
+ 	if (wdev->iftype != NL80211_IFTYPE_NAN)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (!wdev->nan_started)
+ 		return -ENOTCONN;
+ 
+ 	if (!info->attrs[NL80211_ATTR_COOKIE])
+ 		return -EINVAL;
+ 
+ 	if (wdev->owner_nlportid &&
+ 	    wdev->owner_nlportid != info->snd_portid)
+ 		return -ENOTCONN;
+ 
+ 	cookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);
+ 
+ 	rdev_del_nan_func(rdev, wdev, cookie);
+ 
+ 	return 0;
+ }
+ 
+ static int nl80211_nan_change_config(struct sk_buff *skb,
+ 				     struct genl_info *info)
+ {
+ 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ 	struct wireless_dev *wdev = info->user_ptr[1];
+ 	struct cfg80211_nan_conf conf = {};
+ 	u32 changed = 0;
+ 
+ 	if (wdev->iftype != NL80211_IFTYPE_NAN)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (!wdev->nan_started)
+ 		return -ENOTCONN;
+ 
+ 	if (info->attrs[NL80211_ATTR_NAN_MASTER_PREF]) {
+ 		conf.master_pref =
+ 			nla_get_u8(info->attrs[NL80211_ATTR_NAN_MASTER_PREF]);
+ 		if (conf.master_pref <= 1 || conf.master_pref == 255)
+ 			return -EINVAL;
+ 
+ 		changed |= CFG80211_NAN_CONF_CHANGED_PREF;
+ 	}
+ 
+ 	if (info->attrs[NL80211_ATTR_NAN_DUAL]) {
+ 		conf.dual = nla_get_u8(info->attrs[NL80211_ATTR_NAN_DUAL]);
+ 		changed |= CFG80211_NAN_CONF_CHANGED_DUAL;
+ 	}
+ 
+ 	if (!changed)
+ 		return -EINVAL;
+ 
+ 	return rdev_nan_change_conf(rdev, wdev, &conf, changed);
+ }
+ 
+ void cfg80211_nan_match(struct wireless_dev *wdev,
+ 			struct cfg80211_nan_match_params *match, gfp_t gfp)
+ {
+ 	struct wiphy *wiphy = wdev->wiphy;
+ 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+ 	struct nlattr *match_attr, *local_func_attr, *peer_func_attr;
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	if (WARN_ON(!match->inst_id || !match->peer_inst_id || !match->addr))
+ 		return;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
+ 	if (!msg)
+ 		return;
+ 
+ 	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NAN_MATCH);
+ 	if (!hdr) {
+ 		nlmsg_free(msg);
+ 		return;
+ 	}
+ 
+ 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
+ 	    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,
+ 					 wdev->netdev->ifindex)) ||
+ 	    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
+ 			      NL80211_ATTR_PAD))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, match->cookie,
+ 			      NL80211_ATTR_PAD) ||
+ 	    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, match->addr))
+ 		goto nla_put_failure;
+ 
+ 	match_attr = nla_nest_start(msg, NL80211_ATTR_NAN_MATCH);
+ 	if (!match_attr)
+ 		goto nla_put_failure;
+ 
+ 	local_func_attr = nla_nest_start(msg, NL80211_NAN_MATCH_FUNC_LOCAL);
+ 	if (!local_func_attr)
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, match->inst_id))
+ 		goto nla_put_failure;
+ 
+ 	nla_nest_end(msg, local_func_attr);
+ 
+ 	peer_func_attr = nla_nest_start(msg, NL80211_NAN_MATCH_FUNC_PEER);
+ 	if (!peer_func_attr)
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(msg, NL80211_NAN_FUNC_TYPE, match->type) ||
+ 	    nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, match->peer_inst_id))
+ 		goto nla_put_failure;
+ 
+ 	if (match->info && match->info_len &&
+ 	    nla_put(msg, NL80211_NAN_FUNC_SERVICE_INFO, match->info_len,
+ 		    match->info))
+ 		goto nla_put_failure;
+ 
+ 	nla_nest_end(msg, peer_func_attr);
+ 	nla_nest_end(msg, match_attr);
+ 	genlmsg_end(msg, hdr);
+ 
+ 	if (!wdev->owner_nlportid)
+ 		genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),
+ 					msg, 0, NL80211_MCGRP_NAN, gfp);
+ 	else
+ 		genlmsg_unicast(wiphy_net(&rdev->wiphy), msg,
+ 				wdev->owner_nlportid);
+ 
+ 	return;
+ 
+ nla_put_failure:
+ 	nlmsg_free(msg);
+ }
+ EXPORT_SYMBOL(cfg80211_nan_match);
+ 
+ void cfg80211_nan_func_terminated(struct wireless_dev *wdev,
+ 				  u8 inst_id,
+ 				  enum nl80211_nan_func_term_reason reason,
+ 				  u64 cookie, gfp_t gfp)
+ {
+ 	struct wiphy *wiphy = wdev->wiphy;
+ 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+ 	struct sk_buff *msg;
+ 	struct nlattr *func_attr;
+ 	void *hdr;
+ 
+ 	if (WARN_ON(!inst_id))
+ 		return;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
+ 	if (!msg)
+ 		return;
+ 
+ 	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DEL_NAN_FUNCTION);
+ 	if (!hdr) {
+ 		nlmsg_free(msg);
+ 		return;
+ 	}
+ 
+ 	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
+ 	    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,
+ 					 wdev->netdev->ifindex)) ||
+ 	    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),
+ 			      NL80211_ATTR_PAD))
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,
+ 			      NL80211_ATTR_PAD))
+ 		goto nla_put_failure;
+ 
+ 	func_attr = nla_nest_start(msg, NL80211_ATTR_NAN_FUNC);
+ 	if (!func_attr)
+ 		goto nla_put_failure;
+ 
+ 	if (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, inst_id) ||
+ 	    nla_put_u8(msg, NL80211_NAN_FUNC_TERM_REASON, reason))
+ 		goto nla_put_failure;
+ 
+ 	nla_nest_end(msg, func_attr);
+ 	genlmsg_end(msg, hdr);
+ 
+ 	if (!wdev->owner_nlportid)
+ 		genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),
+ 					msg, 0, NL80211_MCGRP_NAN, gfp);
+ 	else
+ 		genlmsg_unicast(wiphy_net(&rdev->wiphy), msg,
+ 				wdev->owner_nlportid);
+ 
+ 	return;
+ 
+ nla_put_failure:
+ 	nlmsg_free(msg);
+ }
+ EXPORT_SYMBOL(cfg80211_nan_func_terminated);
+ 
++>>>>>>> b15ca182ed13 (netlink: Add nla_memdup() to wrap kmemdup() use on nlattr)
  static int nl80211_get_protocol_features(struct sk_buff *skb,
  					 struct genl_info *info)
  {
* Unmerged path net/sched/act_bpf.c
diff --git a/include/net/netlink.h b/include/net/netlink.h
index 983e9721f6f7..4f3a11e9959d 100644
--- a/include/net/netlink.h
+++ b/include/net/netlink.h
@@ -1169,6 +1169,16 @@ static inline struct in6_addr nla_get_in6_addr(const struct nlattr *nla)
 	return tmp;
 }
 
+/**
+ * nla_memdup - duplicate attribute memory (kmemdup)
+ * @src: netlink attribute to duplicate from
+ * @gfp: GFP mask
+ */
+static inline void *nla_memdup(const struct nlattr *src, gfp_t gfp)
+{
+	return kmemdup(nla_data(src), nla_len(src), gfp);
+}
+
 /**
  * nla_nest_start - Start a new level of nested attributes
  * @skb: socket buffer to add attributes to
* Unmerged path net/sched/act_bpf.c
* Unmerged path net/sched/cls_bpf.c
* Unmerged path net/wireless/nl80211.c
