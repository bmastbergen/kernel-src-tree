KVM: PPC: Book3S HV: Use generic kvm module parameters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Suraj Jitindar Singh <sjitindarsingh@gmail.com>
commit 307d93e476a340116cbddd1d3d7edf9b3cdd7506
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/307d93e4.failed

The previous patch exported the variables which back the module parameters
of the generic kvm module. Now use these variables in the kvm-hv module
so that any change to the generic module parameters will also have the
same effect for the kvm-hv module. This removes the duplication of the
kvm module parameters which was redundant and should reduce confusion when
tuning them.

	Signed-off-by: Suraj Jitindar Singh <sjitindarsingh@gmail.com>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit 307d93e476a340116cbddd1d3d7edf9b3cdd7506)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv.c
diff --cc arch/powerpc/kvm/book3s_hv.c
index 32dd0caea96b,f0d22ced3e1f..000000000000
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@@ -87,6 -93,21 +87,24 @@@ static int target_smt_mode
  module_param(target_smt_mode, int, S_IRUGO | S_IWUSR);
  MODULE_PARM_DESC(target_smt_mode, "Target threads per core (0 = max)");
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_KVM_XICS
+ static struct kernel_param_ops module_param_ops = {
+ 	.set = param_set_int,
+ 	.get = param_get_int,
+ };
+ 
+ module_param_cb(kvm_irq_bypass, &module_param_ops, &kvm_irq_bypass,
+ 							S_IRUGO | S_IWUSR);
+ MODULE_PARM_DESC(kvm_irq_bypass, "Bypass passthrough interrupt optimization");
+ 
+ module_param_cb(h_ipi_redirect, &module_param_ops, &h_ipi_redirect,
+ 							S_IRUGO | S_IWUSR);
+ MODULE_PARM_DESC(h_ipi_redirect, "Redirect H_IPI wakeup to a free host core");
+ #endif
+ 
++>>>>>>> 307d93e476a3 (KVM: PPC: Book3S HV: Use generic kvm module parameters)
  static void kvmppc_end_cede(struct kvm_vcpu *vcpu);
  static int kvmppc_hv_setup_htab_rma(struct kvm_vcpu *vcpu);
  
@@@ -2579,6 -2592,42 +2597,45 @@@ static void kvmppc_wait_for_exec(struc
  	finish_wait(&vcpu->arch.cpu_run, &wait);
  }
  
++<<<<<<< HEAD
++=======
+ static void grow_halt_poll_ns(struct kvmppc_vcore *vc)
+ {
+ 	/* 10us base */
+ 	if (vc->halt_poll_ns == 0 && halt_poll_ns_grow)
+ 		vc->halt_poll_ns = 10000;
+ 	else
+ 		vc->halt_poll_ns *= halt_poll_ns_grow;
+ 
+ 	if (vc->halt_poll_ns > halt_poll_ns)
+ 		vc->halt_poll_ns = halt_poll_ns;
+ }
+ 
+ static void shrink_halt_poll_ns(struct kvmppc_vcore *vc)
+ {
+ 	if (halt_poll_ns_shrink == 0)
+ 		vc->halt_poll_ns = 0;
+ 	else
+ 		vc->halt_poll_ns /= halt_poll_ns_shrink;
+ }
+ 
+ /* Check to see if any of the runnable vcpus on the vcore have pending
+  * exceptions or are no longer ceded
+  */
+ static int kvmppc_vcore_check_block(struct kvmppc_vcore *vc)
+ {
+ 	struct kvm_vcpu *vcpu;
+ 	int i;
+ 
+ 	for_each_runnable_thread(i, vcpu, vc) {
+ 		if (vcpu->arch.pending_exceptions || !vcpu->arch.ceded)
+ 			return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 307d93e476a3 (KVM: PPC: Book3S HV: Use generic kvm module parameters)
  /*
   * All the vcpus in this vcore are idle, so wait for a decrementer
   * or external interrupt to one of the vcpus.  vc->lock is held.
@@@ -2616,6 -2686,45 +2673,48 @@@ static void kvmppc_vcore_blocked(struc
  	spin_lock(&vc->lock);
  	vc->vcore_state = VCORE_INACTIVE;
  	trace_kvmppc_vcore_blocked(vc, 1);
++<<<<<<< HEAD
++=======
+ 	++vc->runner->stat.halt_successful_wait;
+ 
+ 	cur = ktime_get();
+ 
+ out:
+ 	block_ns = ktime_to_ns(cur) - ktime_to_ns(start_poll);
+ 
+ 	/* Attribute wait time */
+ 	if (do_sleep) {
+ 		vc->runner->stat.halt_wait_ns +=
+ 			ktime_to_ns(cur) - ktime_to_ns(start_wait);
+ 		/* Attribute failed poll time */
+ 		if (vc->halt_poll_ns)
+ 			vc->runner->stat.halt_poll_fail_ns +=
+ 				ktime_to_ns(start_wait) -
+ 				ktime_to_ns(start_poll);
+ 	} else {
+ 		/* Attribute successful poll time */
+ 		if (vc->halt_poll_ns)
+ 			vc->runner->stat.halt_poll_success_ns +=
+ 				ktime_to_ns(cur) -
+ 				ktime_to_ns(start_poll);
+ 	}
+ 
+ 	/* Adjust poll time */
+ 	if (halt_poll_ns) {
+ 		if (block_ns <= vc->halt_poll_ns)
+ 			;
+ 		/* We slept and blocked for longer than the max halt time */
+ 		else if (vc->halt_poll_ns && block_ns > halt_poll_ns)
+ 			shrink_halt_poll_ns(vc);
+ 		/* We slept and our poll time is too small */
+ 		else if (vc->halt_poll_ns < halt_poll_ns &&
+ 				block_ns < halt_poll_ns)
+ 			grow_halt_poll_ns(vc);
+ 	} else
+ 		vc->halt_poll_ns = 0;
+ 
+ 	trace_kvmppc_vcore_wakeup(do_sleep, block_ns);
++>>>>>>> 307d93e476a3 (KVM: PPC: Book3S HV: Use generic kvm module parameters)
  }
  
  static int kvmppc_run_vcpu(struct kvm_run *kvm_run, struct kvm_vcpu *vcpu)
* Unmerged path arch/powerpc/kvm/book3s_hv.c
