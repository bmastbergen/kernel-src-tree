pnfs: lift retry logic from send_layoutget to pnfs_update_layout

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jeff Layton <jlayton@poochiereds.net>
commit 83026d80a16ea6a4e4f06a994fc7831b1d8d6375
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/83026d80.failed

If we get back something like NFS4ERR_OLD_STATEID, that will be
translated into -EAGAIN, and the do/while loop in send_layoutget
will drive the call again.

This is not quite what we want, I think. An error like that is a
sign that something has changed. That something could have been a
concurrent LAYOUTGET that would give us a usable lseg.

Lift the retry logic into pnfs_update_layout instead. That allows
us to redo the layout search, and may spare us from having to issue
an RPC.

	Signed-off-by: Jeff Layton <jeff.layton@primarydata.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 83026d80a16ea6a4e4f06a994fc7831b1d8d6375)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pnfs.c
diff --cc fs/nfs/pnfs.c
index 51bf68561c0f,2a609af845fe..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -832,45 -848,30 +831,62 @@@ send_layoutget(struct pnfs_layout_hdr *
  	 * store in lseg. If we race with a concurrent seqid morphing
  	 * op, then re-send the LAYOUTGET.
  	 */
- 	do {
- 		lgp = kzalloc(sizeof(*lgp), gfp_flags);
- 		if (lgp == NULL)
- 			return NULL;
+ 	lgp = kzalloc(sizeof(*lgp), gfp_flags);
+ 	if (lgp == NULL)
+ 		return ERR_PTR(-ENOMEM);
  
- 		i_size = i_size_read(ino);
+ 	i_size = i_size_read(ino);
  
++<<<<<<< HEAD
 +		lgp->args.minlength = PAGE_CACHE_SIZE;
 +		if (lgp->args.minlength > range->length)
 +			lgp->args.minlength = range->length;
 +		if (range->iomode == IOMODE_READ) {
 +			if (range->offset >= i_size)
 +				lgp->args.minlength = 0;
 +			else if (i_size - range->offset < lgp->args.minlength)
 +				lgp->args.minlength = i_size - range->offset;
 +		}
 +		lgp->args.maxcount = PNFS_LAYOUT_MAXSIZE;
 +		pnfs_copy_range(&lgp->args.range, range);
 +		lgp->args.type = server->pnfs_curr_ld->id;
 +		lgp->args.inode = ino;
 +		lgp->args.ctx = get_nfs_open_context(ctx);
 +		lgp->gfp_flags = gfp_flags;
 +		lgp->cred = lo->plh_lc_cred;
 +
 +		lseg = nfs4_proc_layoutget(lgp, gfp_flags);
 +	} while (lseg == ERR_PTR(-EAGAIN));
 +
 +	if (IS_ERR(lseg)) {
 +		if (!nfs_error_is_fatal(PTR_ERR(lseg))) {
 +			pnfs_layout_clear_fail_bit(lo,
 +					pnfs_iomode_to_fail_bit(range->iomode));
 +			lseg = NULL;
 +		}
 +	} else {
 +		pnfs_layout_clear_fail_bit(lo,
 +				pnfs_iomode_to_fail_bit(range->iomode));
++=======
+ 	lgp->args.minlength = PAGE_SIZE;
+ 	if (lgp->args.minlength > range->length)
+ 		lgp->args.minlength = range->length;
+ 	if (range->iomode == IOMODE_READ) {
+ 		if (range->offset >= i_size)
+ 			lgp->args.minlength = 0;
+ 		else if (i_size - range->offset < lgp->args.minlength)
+ 			lgp->args.minlength = i_size - range->offset;
++>>>>>>> 83026d80a16e (pnfs: lift retry logic from send_layoutget to pnfs_update_layout)
  	}
+ 	lgp->args.maxcount = PNFS_LAYOUT_MAXSIZE;
+ 	pnfs_copy_range(&lgp->args.range, range);
+ 	lgp->args.type = server->pnfs_curr_ld->id;
+ 	lgp->args.inode = ino;
+ 	lgp->args.ctx = get_nfs_open_context(ctx);
+ 	lgp->gfp_flags = gfp_flags;
+ 	lgp->cred = lo->plh_lc_cred;
  
- 	return lseg;
+ 	return nfs4_proc_layoutget(lgp, gfp_flags);
  }
  
  static void pnfs_clear_layoutcommit(struct inode *inode,
@@@ -1627,9 -1630,25 +1643,25 @@@ lookup_again
  		arg.length += pg_offset;
  	}
  	if (arg.length != NFS4_MAX_UINT64)
 -		arg.length = PAGE_ALIGN(arg.length);
 +		arg.length = PAGE_CACHE_ALIGN(arg.length);
  
  	lseg = send_layoutget(lo, ctx, &arg, gfp_flags);
+ 	if (IS_ERR(lseg)) {
+ 		if (lseg == ERR_PTR(-EAGAIN)) {
+ 			if (first)
+ 				pnfs_clear_first_layoutget(lo);
+ 			pnfs_put_layout_hdr(lo);
+ 			goto lookup_again;
+ 		}
+ 
+ 		if (!nfs_error_is_fatal(PTR_ERR(lseg))) {
+ 			pnfs_layout_clear_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));
+ 			lseg = NULL;
+ 		}
+ 	} else {
+ 		pnfs_layout_clear_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));
+ 	}
+ 
  	atomic_dec(&lo->plh_outstanding);
  	trace_pnfs_update_layout(ino, pos, count, iomode, lo,
  				 PNFS_UPDATE_LAYOUT_SEND_LAYOUTGET);
* Unmerged path fs/nfs/pnfs.c
