sysfs, kernfs: introduce kernfs_create_file[_ns]()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tejun Heo <tj@kernel.org>
commit 496f73944a4a974f89d48920bf368aec8841b195
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/496f7394.failed

Introduce kernfs interface to create a file which takes and returns
sysfs_dirents.

The actual file creation part is separated out from
sysfs_add_file_mode_ns() into kernfs_create_file_ns().  The former now
only decides the kernfs_ops to use and the file's size and invokes the
latter.

This patch doesn't introduce behavior changes.

v2: Dummy implementation for !CONFIG_SYSFS updated to return -ENOSYS.

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 496f73944a4a974f89d48920bf368aec8841b195)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/file.c
#	include/linux/kernfs.h
diff --cc fs/sysfs/file.c
index 602f56db0442,69cca0f4ccf3..000000000000
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@@ -476,99 -870,167 +476,195 @@@ void sysfs_notify(struct kobject *k, co
  }
  EXPORT_SYMBOL_GPL(sysfs_notify);
  
 -const struct file_operations kernfs_file_operations = {
 -	.read		= kernfs_file_read,
 -	.write		= kernfs_file_write,
 +const struct file_operations sysfs_file_operations = {
 +	.read		= sysfs_read_file,
 +	.write		= sysfs_write_file,
  	.llseek		= generic_file_llseek,
 -	.mmap		= kernfs_file_mmap,
 -	.open		= kernfs_file_open,
 -	.release	= kernfs_file_release,
 -	.poll		= kernfs_file_poll,
 +	.open		= sysfs_open_file,
 +	.release	= sysfs_release,
 +	.poll		= sysfs_poll,
  };
  
++<<<<<<< HEAD
 +static int sysfs_attr_ns(struct kobject *kobj, const struct attribute *attr,
 +			 const void **pns)
 +{
 +	struct sysfs_dirent *dir_sd = kobj->sd;
 +	const struct sysfs_ops *ops;
 +	const void *ns = NULL;
 +	int err;
++=======
+ static const struct kernfs_ops sysfs_file_kfops_empty = {
+ };
+ 
+ static const struct kernfs_ops sysfs_file_kfops_ro = {
+ 	.seq_show	= sysfs_kf_seq_show,
+ };
+ 
+ static const struct kernfs_ops sysfs_file_kfops_wo = {
+ 	.write		= sysfs_kf_write,
+ };
+ 
+ static const struct kernfs_ops sysfs_file_kfops_rw = {
+ 	.seq_show	= sysfs_kf_seq_show,
+ 	.write		= sysfs_kf_write,
+ };
+ 
+ static const struct kernfs_ops sysfs_bin_kfops_ro = {
+ 	.read		= sysfs_kf_bin_read,
+ };
+ 
+ static const struct kernfs_ops sysfs_bin_kfops_wo = {
+ 	.write		= sysfs_kf_bin_write,
+ };
+ 
+ static const struct kernfs_ops sysfs_bin_kfops_rw = {
+ 	.read		= sysfs_kf_bin_read,
+ 	.write		= sysfs_kf_bin_write,
+ 	.mmap		= sysfs_kf_bin_mmap,
+ };
+ 
+ int sysfs_add_file_mode_ns(struct sysfs_dirent *dir_sd,
+ 			   const struct attribute *attr, bool is_bin,
+ 			   umode_t mode, const void *ns)
+ {
+ 	const struct kernfs_ops *ops;
+ 	struct sysfs_dirent *sd;
+ 	loff_t size;
++>>>>>>> 496f73944a4a (sysfs, kernfs: introduce kernfs_create_file[_ns]())
  
 -	if (!is_bin) {
 -		struct kobject *kobj = dir_sd->priv;
 -		const struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;
 -
 -		/* every kobject with an attribute needs a ktype assigned */
 -		if (WARN(!sysfs_ops, KERN_ERR
 -			 "missing sysfs attribute operations for kobject: %s\n",
 -			 kobject_name(kobj)))
 -			return -EINVAL;
 -
 -		if (sysfs_ops->show && sysfs_ops->store)
 -			ops = &sysfs_file_kfops_rw;
 -		else if (sysfs_ops->show)
 -			ops = &sysfs_file_kfops_ro;
 -		else if (sysfs_ops->store)
 -			ops = &sysfs_file_kfops_wo;
 -		else
 -			ops = &sysfs_file_kfops_empty;
 -
 -		size = PAGE_SIZE;
 -	} else {
 -		struct bin_attribute *battr = (void *)attr;
 -
 -		if ((battr->read && battr->write) || battr->mmap)
 -			ops = &sysfs_bin_kfops_rw;
 -		else if (battr->read)
 -			ops = &sysfs_bin_kfops_ro;
 -		else if (battr->write)
 -			ops = &sysfs_bin_kfops_wo;
 -		else
 -			ops = &sysfs_file_kfops_empty;
 -
 -		size = battr->size;
 +	if (!dir_sd) {
 +		WARN(1, KERN_ERR "sysfs: kobject %s without dirent\n",
 +			kobject_name(kobj));
 +		return -ENOENT;
  	}
  
++<<<<<<< HEAD
 +	err = 0;
 +	if (!sysfs_ns_type(dir_sd))
 +		goto out;
 +
 +	err = -EINVAL;
 +	if (!kobj->ktype)
 +		goto out;
 +	ops = kobj->ktype->sysfs_ops;
 +	if (!ops)
 +		goto out;
 +	if (!ops->namespace)
 +		goto out;
 +
 +	err = 0;
 +	ns = ops->namespace(kobj, attr);
 +out:
 +	if (err) {
 +		WARN(1, KERN_ERR "missing sysfs namespace attribute operation for "
 +		     "kobject: %s\n", kobject_name(kobj));
 +	}
 +	*pns = ns;
 +	return err;
 +}
 +
 +int sysfs_add_file_mode(struct sysfs_dirent *dir_sd,
 +			const struct attribute *attr, int type, umode_t amode)
 +{
 +	umode_t mode = (amode & S_IALLUGO) | S_IFREG;
 +	struct sysfs_addrm_cxt acxt;
 +	struct sysfs_dirent *sd;
 +	const void *ns;
 +	int rc;
 +
 +	rc = sysfs_attr_ns(dir_sd->s_dir.kobj, attr, &ns);
 +	if (rc)
 +		return rc;
 +
 +	sd = sysfs_new_dirent(attr->name, mode, type);
++=======
+ 	sd = kernfs_create_file_ns(dir_sd, attr->name, mode, size,
+ 				   ops, (void *)attr, ns);
+ 	if (IS_ERR(sd)) {
+ 		if (PTR_ERR(sd) == -EEXIST)
+ 			sysfs_warn_dup(dir_sd, attr->name);
+ 		return PTR_ERR(sd);
+ 	}
+ 	return 0;
+ }
+ 
+ /**
+  * kernfs_create_file_ns - create a file
+  * @parent: directory to create the file in
+  * @name: name of the file
+  * @mode: mode of the file
+  * @size: size of the file
+  * @ops: kernfs operations for the file
+  * @priv: private data for the file
+  * @ns: optional namespace tag of the file
+  *
+  * Returns the created node on success, ERR_PTR() value on error.
+  */
+ struct sysfs_dirent *kernfs_create_file_ns(struct sysfs_dirent *parent,
+ 					   const char *name,
+ 					   umode_t mode, loff_t size,
+ 					   const struct kernfs_ops *ops,
+ 					   void *priv, const void *ns)
+ {
+ 	struct sysfs_addrm_cxt acxt;
+ 	struct sysfs_dirent *sd;
+ 	int rc;
+ 
+ 	sd = sysfs_new_dirent(name, (mode & S_IALLUGO) | S_IFREG,
+ 			      SYSFS_KOBJ_ATTR);
++>>>>>>> 496f73944a4a (sysfs, kernfs: introduce kernfs_create_file[_ns]())
  	if (!sd)
- 		return -ENOMEM;
+ 		return ERR_PTR(-ENOMEM);
  
 -	sd->s_attr.ops = ops;
 -	sd->s_attr.size = size;
  	sd->s_ns = ns;
++<<<<<<< HEAD
 +	sd->s_attr.attr = (void *)attr;
 +	sysfs_dirent_init_lockdep(sd);
 +
 +	sysfs_addrm_start(&acxt, dir_sd);
 +	rc = sysfs_add_one(&acxt, sd);
++=======
+ 	sd->priv = priv;
+ 	sysfs_dirent_init_lockdep(sd);
+ 
+ 	/*
+ 	 * sd->s_attr.ops is accesible only while holding active ref.  We
+ 	 * need to know whether some ops are implemented outside active
+ 	 * ref.  Cache their existence in flags.
+ 	 */
+ 	if (ops->seq_show)
+ 		sd->s_flags |= SYSFS_FLAG_HAS_SEQ_SHOW;
+ 	if (ops->mmap)
+ 		sd->s_flags |= SYSFS_FLAG_HAS_MMAP;
+ 
+ 	sysfs_addrm_start(&acxt);
+ 	rc = __sysfs_add_one(&acxt, sd, parent);
++>>>>>>> 496f73944a4a (sysfs, kernfs: introduce kernfs_create_file[_ns]())
  	sysfs_addrm_finish(&acxt);
  
- 	if (rc)
+ 	if (rc) {
  		sysfs_put(sd);
- 
- 	return rc;
+ 		return ERR_PTR(rc);
+ 	}
+ 	return sd;
  }
  
 +
  int sysfs_add_file(struct sysfs_dirent *dir_sd, const struct attribute *attr,
 -		   bool is_bin)
 +		   int type)
  {
 -	return sysfs_add_file_mode_ns(dir_sd, attr, is_bin, attr->mode, NULL);
 +	return sysfs_add_file_mode(dir_sd, attr, type, attr->mode);
  }
  
 +
  /**
 - * sysfs_create_file_ns - create an attribute file for an object with custom ns
 - * @kobj: object we're creating for
 - * @attr: attribute descriptor
 - * @ns: namespace the new file should belong to
 + *	sysfs_create_file - create an attribute file for an object.
 + *	@kobj:	object we're creating for. 
 + *	@attr:	attribute descriptor.
   */
 -int sysfs_create_file_ns(struct kobject *kobj, const struct attribute *attr,
 -			 const void *ns)
 +
 +int sysfs_create_file(struct kobject * kobj, const struct attribute * attr)
  {
  	BUG_ON(!kobj || !kobj->sd || !attr);
  
diff --cc include/linux/kernfs.h
index 254b9e872b09,d0912cf02087..000000000000
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@@ -7,6 -7,133 +7,126 @@@
  #ifndef __LINUX_KERNFS_H
  #define __LINUX_KERNFS_H
  
 -#include <linux/kernel.h>
 -#include <linux/err.h>
 -#include <linux/list.h>
 -#include <linux/mutex.h>
 -
 -struct file;
 -struct iattr;
 -struct seq_file;
 -struct vm_area_struct;
 -
  struct sysfs_dirent;
  
++<<<<<<< HEAD
++=======
+ struct sysfs_open_file {
+ 	/* published fields */
+ 	struct sysfs_dirent	*sd;
+ 	struct file		*file;
+ 
+ 	/* private fields, do not use outside kernfs proper */
+ 	struct mutex		mutex;
+ 	int			event;
+ 	struct list_head	list;
+ 
+ 	bool			mmapped;
+ 	const struct vm_operations_struct *vm_ops;
+ };
+ 
+ struct kernfs_ops {
+ 	/*
+ 	 * Read is handled by either seq_file or raw_read().
+ 	 *
+ 	 * If seq_show() is present, seq_file path is active.  The behavior
+ 	 * is equivalent to single_open().  @sf->private points to the
+ 	 * associated sysfs_open_file.
+ 	 *
+ 	 * read() is bounced through kernel buffer and a read larger than
+ 	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
+ 	 */
+ 	int (*seq_show)(struct seq_file *sf, void *v);
+ 
+ 	ssize_t (*read)(struct sysfs_open_file *of, char *buf, size_t bytes,
+ 			loff_t off);
+ 
+ 	/*
+ 	 * write() is bounced through kernel buffer and a write larger than
+ 	 * PAGE_SIZE results in partial operation of PAGE_SIZE.
+ 	 */
+ 	ssize_t (*write)(struct sysfs_open_file *of, char *buf, size_t bytes,
+ 			 loff_t off);
+ 
+ 	int (*mmap)(struct sysfs_open_file *of, struct vm_area_struct *vma);
+ };
+ 
+ #ifdef CONFIG_SYSFS
+ 
+ struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
+ 					  const char *name, void *priv,
+ 					  const void *ns);
+ struct sysfs_dirent *kernfs_create_file_ns(struct sysfs_dirent *parent,
+ 					   const char *name,
+ 					   umode_t mode, loff_t size,
+ 					   const struct kernfs_ops *ops,
+ 					   void *priv, const void *ns);
+ struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
+ 					const char *name,
+ 					struct sysfs_dirent *target);
+ void kernfs_remove(struct sysfs_dirent *sd);
+ int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
+ 			     const void *ns);
+ int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
+ 		     const char *new_name, const void *new_ns);
+ void kernfs_enable_ns(struct sysfs_dirent *sd);
+ int kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr);
+ 
+ #else	/* CONFIG_SYSFS */
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_dir_ns(struct sysfs_dirent *parent, const char *name, void *priv,
+ 		     const void *ns)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_file_ns(struct sysfs_dirent *parent, const char *name,
+ 		      umode_t mode, loff_t size, const struct kernfs_ops *ops,
+ 		      void *priv, const void *ns)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_link(struct sysfs_dirent *parent, const char *name,
+ 		   struct sysfs_dirent *target)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline void kernfs_remove(struct sysfs_dirent *sd) { }
+ 
+ static inline int kernfs_remove_by_name_ns(struct sysfs_dirent *parent,
+ 					   const char *name, const void *ns)
+ { return -ENOSYS; }
+ 
+ static inline int kernfs_rename_ns(struct sysfs_dirent *sd,
+ 				   struct sysfs_dirent *new_parent,
+ 				   const char *new_name, const void *new_ns)
+ { return -ENOSYS; }
+ 
+ static inline void kernfs_enable_ns(struct sysfs_dirent *sd) { }
+ 
+ static inline int kernfs_setattr(struct sysfs_dirent *sd,
+ 				 const struct iattr *iattr)
+ { return -ENOSYS; }
+ 
+ #endif	/* CONFIG_SYSFS */
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_dir(struct sysfs_dirent *parent, const char *name, void *priv)
+ {
+ 	return kernfs_create_dir_ns(parent, name, priv, NULL);
+ }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_file(struct sysfs_dirent *parent, const char *name, umode_t mode,
+ 		   loff_t size, const struct kernfs_ops *ops, void *priv)
+ {
+ 	return kernfs_create_file_ns(parent, name, mode, size, ops, priv, NULL);
+ }
+ 
+ static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,
+ 					const char *name)
+ {
+ 	return kernfs_remove_by_name_ns(parent, name, NULL);
+ }
+ 
++>>>>>>> 496f73944a4a (sysfs, kernfs: introduce kernfs_create_file[_ns]())
  #endif	/* __LINUX_KERNFS_H */
* Unmerged path fs/sysfs/file.c
* Unmerged path include/linux/kernfs.h
