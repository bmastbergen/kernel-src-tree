tools/power turbostat: bug fixes to --add, --show/--hide features

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [tools] power turbostat: bug fixes to --add, --show/--hide features (Prarit Bhargava) [1447265]
Rebuild_FUZZ: 95.16%
commit-author Len Brown <len.brown@intel.com>
commit 0f47c08d8ccf8252a5c007502919bdc2126ffb1f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0f47c08d.failed

Fix a bug with --add, where the title of the column
is un-initialized if not specified by the user.

The initial implementation of --show and --hide
neglected to handle the pc8/pc9/pc10 counters.

Fix a bug where "--show Core" only worked with --debug

	Reported-by: Wendy Wang <wendy.wang@intel.com>
	Signed-off-by: Len Brown <len.brown@intel.com>
(cherry picked from commit 0f47c08d8ccf8252a5c007502919bdc2126ffb1f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/power/x86/turbostat/turbostat.c
diff --cc tools/power/x86/turbostat/turbostat.c
index 92e6f5e6c99d,4b04ba86e44f..000000000000
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@@ -49,16 -52,9 +49,11 @@@ unsigned int debug
  unsigned int rapl_joules;
  unsigned int summary_only;
  unsigned int dump_only;
 +unsigned int skip_c0;
 +unsigned int skip_c1;
 +unsigned int do_nhm_cstates;
  unsigned int do_snb_cstates;
  unsigned int do_knl_cstates;
- unsigned int do_pc2;
- unsigned int do_pc3;
- unsigned int do_pc6;
- unsigned int do_pc7;
- unsigned int do_c8_c9_c10;
  unsigned int do_skl_residency;
  unsigned int do_slm_cstates;
  unsigned int use_c1_residency_msr;
@@@ -288,102 -335,265 +283,246 @@@ int get_msr(int cpu, off_t offset, unsi
  }
  
  /*
 - * Each string in this array is compared in --show and --hide cmdline.
 - * Thus, strings that are proper sub-sets must follow their more specific peers.
 + * Example Format w/ field column widths:
 + *
 + *  Package    Core     CPU Avg_MHz Bzy_MHz TSC_MHz     SMI   %Busy CPU_%c1 CPU_%c3 CPU_%c6 CPU_%c7 CoreTmp  PkgTmp Pkg%pc2 Pkg%pc3 Pkg%pc6 Pkg%pc7 PkgWatt CorWatt GFXWatt
 + * 123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678123456781234567812345678
   */
++<<<<<<< HEAD
++=======
+ struct msr_counter bic[] = {
+ 	{ 0x0, "Package" },
+ 	{ 0x0, "Avg_MHz" },
+ 	{ 0x0, "Bzy_MHz" },
+ 	{ 0x0, "TSC_MHz" },
+ 	{ 0x0, "IRQ" },
+ 	{ 0x0, "SMI", 32, 0, FORMAT_DELTA, NULL},
+ 	{ 0x0, "Busy%" },
+ 	{ 0x0, "CPU%c1" },
+ 	{ 0x0, "CPU%c3" },
+ 	{ 0x0, "CPU%c6" },
+ 	{ 0x0, "CPU%c7" },
+ 	{ 0x0, "ThreadC" },
+ 	{ 0x0, "CoreTmp" },
+ 	{ 0x0, "CoreCnt" },
+ 	{ 0x0, "PkgTmp" },
+ 	{ 0x0, "GFX%rc6" },
+ 	{ 0x0, "GFXMHz" },
+ 	{ 0x0, "Pkg%pc2" },
+ 	{ 0x0, "Pkg%pc3" },
+ 	{ 0x0, "Pkg%pc6" },
+ 	{ 0x0, "Pkg%pc7" },
+ 	{ 0x0, "Pkg%pc8" },
+ 	{ 0x0, "Pkg%pc9" },
+ 	{ 0x0, "Pkg%pc10" },
+ 	{ 0x0, "PkgWatt" },
+ 	{ 0x0, "CorWatt" },
+ 	{ 0x0, "GFXWatt" },
+ 	{ 0x0, "PkgCnt" },
+ 	{ 0x0, "RAMWatt" },
+ 	{ 0x0, "PKG_%" },
+ 	{ 0x0, "RAM_%" },
+ 	{ 0x0, "Pkg_J" },
+ 	{ 0x0, "Cor_J" },
+ 	{ 0x0, "GFX_J" },
+ 	{ 0x0, "RAM_J" },
+ 	{ 0x0, "Core" },
+ 	{ 0x0, "CPU" },
+ 	{ 0x0, "Mod%c6" },
+ };
+ 
+ #define MAX_BIC (sizeof(bic) / sizeof(struct msr_counter))
+ #define	BIC_Package	(1ULL << 0)
+ #define	BIC_Avg_MHz	(1ULL << 1)
+ #define	BIC_Bzy_MHz	(1ULL << 2)
+ #define	BIC_TSC_MHz	(1ULL << 3)
+ #define	BIC_IRQ		(1ULL << 4)
+ #define	BIC_SMI		(1ULL << 5)
+ #define	BIC_Busy	(1ULL << 6)
+ #define	BIC_CPU_c1	(1ULL << 7)
+ #define	BIC_CPU_c3	(1ULL << 8)
+ #define	BIC_CPU_c6	(1ULL << 9)
+ #define	BIC_CPU_c7	(1ULL << 10)
+ #define	BIC_ThreadC	(1ULL << 11)
+ #define	BIC_CoreTmp	(1ULL << 12)
+ #define	BIC_CoreCnt	(1ULL << 13)
+ #define	BIC_PkgTmp	(1ULL << 14)
+ #define	BIC_GFX_rc6	(1ULL << 15)
+ #define	BIC_GFXMHz	(1ULL << 16)
+ #define	BIC_Pkgpc2	(1ULL << 17)
+ #define	BIC_Pkgpc3	(1ULL << 18)
+ #define	BIC_Pkgpc6	(1ULL << 19)
+ #define	BIC_Pkgpc7	(1ULL << 20)
+ #define	BIC_Pkgpc8	(1ULL << 21)
+ #define	BIC_Pkgpc9	(1ULL << 22)
+ #define	BIC_Pkgpc10	(1ULL << 23)
+ #define	BIC_PkgWatt	(1ULL << 24)
+ #define	BIC_CorWatt	(1ULL << 25)
+ #define	BIC_GFXWatt	(1ULL << 26)
+ #define	BIC_PkgCnt	(1ULL << 27)
+ #define	BIC_RAMWatt	(1ULL << 28)
+ #define	BIC_PKG__	(1ULL << 29)
+ #define	BIC_RAM__	(1ULL << 30)
+ #define	BIC_Pkg_J	(1ULL << 31)
+ #define	BIC_Cor_J	(1ULL << 32)
+ #define	BIC_GFX_J	(1ULL << 33)
+ #define	BIC_RAM_J	(1ULL << 34)
+ #define	BIC_Core	(1ULL << 35)
+ #define	BIC_CPU		(1ULL << 36)
+ #define	BIC_Mod_c6	(1ULL << 37)
+ 
+ unsigned long long bic_enabled = 0xFFFFFFFFFFFFFFFFULL;
+ unsigned long long bic_present;
+ 
+ #define DO_BIC(COUNTER_NAME) (bic_enabled & bic_present & COUNTER_NAME)
+ #define BIC_PRESENT(COUNTER_BIT) (bic_present |= COUNTER_BIT)
+ #define BIC_NOT_PRESENT(COUNTER_BIT) (bic_present &= ~COUNTER_BIT)
+ 
+ /*
+  * bic_lookup
+  * for all the strings in comma separate name_list,
+  * set the approprate bit in return value.
+  */
+ unsigned long long bic_lookup(char *name_list)
+ {
+ 	int i;
+ 	unsigned long long retval = 0;
+ 
+ 	while (name_list) {
+ 		char *comma;
+ 
+ 		comma = strchr(name_list, ',');
+ 
+ 		if (comma)
+ 			*comma = '\0';
+ 
+ 		for (i = 0; i < MAX_BIC; ++i) {
+ 			if (!strcmp(name_list, bic[i].name)) {
+ 				retval |= (1ULL << i);
+ 				break;
+ 			}
+ 		}
+ 		if (i == MAX_BIC) {
+ 			fprintf(stderr, "Invalid counter name: %s\n", name_list);
+ 			exit(-1);
+ 		}
+ 
+ 		name_list = comma;
+ 		if (name_list)
+ 			name_list++;
+ 
+ 	}
+ 	return retval;
+ }
++>>>>>>> 0f47c08d8ccf (tools/power turbostat: bug fixes to --add, --show/--hide features)
  
  void print_header(void)
  {
 -	struct msr_counter *mp;
 -
 -	if (DO_BIC(BIC_Package))
 -		outp += sprintf(outp, "\tPackage");
 -	if (DO_BIC(BIC_Core))
 -		outp += sprintf(outp, "\tCore");
 -	if (DO_BIC(BIC_CPU))
 -		outp += sprintf(outp, "\tCPU");
 -	if (DO_BIC(BIC_Avg_MHz))
 -		outp += sprintf(outp, "\tAvg_MHz");
 -	if (DO_BIC(BIC_Busy))
 -		outp += sprintf(outp, "\tBusy%%");
 -	if (DO_BIC(BIC_Bzy_MHz))
 -		outp += sprintf(outp, "\tBzy_MHz");
 -	if (DO_BIC(BIC_TSC_MHz))
 -		outp += sprintf(outp, "\tTSC_MHz");
 -
 -	if (DO_BIC(BIC_IRQ))
 -		outp += sprintf(outp, "\tIRQ");
 -	if (DO_BIC(BIC_SMI))
 -		outp += sprintf(outp, "\tSMI");
 -
 -	if (DO_BIC(BIC_CPU_c1))
 -		outp += sprintf(outp, "\tCPU%%c1");
 -
 -	for (mp = sys.tp; mp; mp = mp->next) {
 -		if (mp->format == FORMAT_RAW) {
 -			if (mp->width == 64)
 -				outp += sprintf(outp, "\t%18.18s", mp->name);
 -			else
 -				outp += sprintf(outp, "\t%10.10s", mp->name);
 -		} else {
 -			outp += sprintf(outp, "\t%-7.7s", mp->name);
 -		}
 -	}
 -
 -	if (DO_BIC(BIC_CPU_c3) && !do_slm_cstates && !do_knl_cstates)
 -		outp += sprintf(outp, "\tCPU%%c3");
 -	if (DO_BIC(BIC_CPU_c6))
 -		outp += sprintf(outp, "\tCPU%%c6");
 -	if (DO_BIC(BIC_CPU_c7))
 -		outp += sprintf(outp, "\tCPU%%c7");
 -
 -	if (DO_BIC(BIC_Mod_c6))
 -		outp += sprintf(outp, "\tMod%%c6");
 -
 -	if (DO_BIC(BIC_CoreTmp))
 -		outp += sprintf(outp, "\tCoreTmp");
 -
 -	for (mp = sys.cp; mp; mp = mp->next) {
 -		if (mp->format == FORMAT_RAW) {
 -			if (mp->width == 64)
 -				outp += sprintf(outp, "\t%18.18s", mp->name);
 -			else
 -				outp += sprintf(outp, "\t%10.10s", mp->name);
 -		} else {
 -			outp += sprintf(outp, "\t%-7.7s", mp->name);
 -		}
 -	}
 -
 -	if (DO_BIC(BIC_PkgTmp))
 -		outp += sprintf(outp, "\tPkgTmp");
 -
 -	if (DO_BIC(BIC_GFX_rc6))
 -		outp += sprintf(outp, "\tGFX%%rc6");
 +	if (show_pkg)
 +		outp += sprintf(outp, " Package");
 +	if (show_core)
 +		outp += sprintf(outp, "    Core");
 +	if (show_cpu)
 +		outp += sprintf(outp, "     CPU");
 +	if (has_aperf)
 +		outp += sprintf(outp, " Avg_MHz");
 +	if (has_aperf)
 +		outp += sprintf(outp, "   %%Busy");
 +	if (has_aperf)
 +		outp += sprintf(outp, " Bzy_MHz");
 +	outp += sprintf(outp, " TSC_MHz");
 +
 +	if (extra_delta_offset32)
 +		outp += sprintf(outp, "  count 0x%03X", extra_delta_offset32);
 +	if (extra_delta_offset64)
 +		outp += sprintf(outp, "  COUNT 0x%03X", extra_delta_offset64);
 +	if (extra_msr_offset32)
 +		outp += sprintf(outp, "   MSR 0x%03X", extra_msr_offset32);
 +	if (extra_msr_offset64)
 +		outp += sprintf(outp, "           MSR 0x%03X", extra_msr_offset64);
 +
 +	if (do_smi)
 +		outp += sprintf(outp, "     SMI");
 +
 +	if (do_nhm_cstates)
 +		outp += sprintf(outp, "  CPU%%c1");
 +	if (do_nhm_cstates && !do_slm_cstates && !do_knl_cstates)
 +		outp += sprintf(outp, "  CPU%%c3");
 +	if (do_nhm_cstates)
 +		outp += sprintf(outp, "  CPU%%c6");
 +	if (do_snb_cstates)
 +		outp += sprintf(outp, "  CPU%%c7");
  
 -	if (DO_BIC(BIC_GFXMHz))
 -		outp += sprintf(outp, "\tGFXMHz");
 +	if (do_dts)
 +		outp += sprintf(outp, " CoreTmp");
 +	if (do_ptm)
 +		outp += sprintf(outp, "  PkgTmp");
  
  	if (do_skl_residency) {
 -		outp += sprintf(outp, "\tTotl%%C0");
 -		outp += sprintf(outp, "\tAny%%C0");
 -		outp += sprintf(outp, "\tGFX%%C0");
 -		outp += sprintf(outp, "\tCPUGFX%%");
 -	}
 -
 +		outp += sprintf(outp, " Totl%%C0");
 +		outp += sprintf(outp, "  Any%%C0");
 +		outp += sprintf(outp, "  GFX%%C0");
 +		outp += sprintf(outp, " CPUGFX%%");
 +	}
 +
++<<<<<<< HEAD
 +	if (do_pc2)
 +		outp += sprintf(outp, " Pkg%%pc2");
 +	if (do_pc3)
 +		outp += sprintf(outp, " Pkg%%pc3");
 +	if (do_pc6)
 +		outp += sprintf(outp, " Pkg%%pc6");
 +	if (do_pc7)
 +		outp += sprintf(outp, " Pkg%%pc7");
 +	if (do_c8_c9_c10) {
 +		outp += sprintf(outp, " Pkg%%pc8");
 +		outp += sprintf(outp, " Pkg%%pc9");
 +		outp += sprintf(outp, " Pk%%pc10");
 +	}
++=======
+ 	if (DO_BIC(BIC_Pkgpc2))
+ 		outp += sprintf(outp, "\tPkg%%pc2");
+ 	if (DO_BIC(BIC_Pkgpc3))
+ 		outp += sprintf(outp, "\tPkg%%pc3");
+ 	if (DO_BIC(BIC_Pkgpc6))
+ 		outp += sprintf(outp, "\tPkg%%pc6");
+ 	if (DO_BIC(BIC_Pkgpc7))
+ 		outp += sprintf(outp, "\tPkg%%pc7");
+ 	if (DO_BIC(BIC_Pkgpc8))
+ 		outp += sprintf(outp, "\tPkg%%pc8");
+ 	if (DO_BIC(BIC_Pkgpc9))
+ 		outp += sprintf(outp, "\tPkg%%pc9");
+ 	if (DO_BIC(BIC_Pkgpc10))
+ 		outp += sprintf(outp, "\tPk%%pc10");
++>>>>>>> 0f47c08d8ccf (tools/power turbostat: bug fixes to --add, --show/--hide features)
  
  	if (do_rapl && !rapl_joules) {
 -		if (DO_BIC(BIC_PkgWatt))
 -			outp += sprintf(outp, "\tPkgWatt");
 -		if (DO_BIC(BIC_CorWatt))
 -			outp += sprintf(outp, "\tCorWatt");
 -		if (DO_BIC(BIC_GFXWatt))
 -			outp += sprintf(outp, "\tGFXWatt");
 -		if (DO_BIC(BIC_RAMWatt))
 -			outp += sprintf(outp, "\tRAMWatt");
 -		if (DO_BIC(BIC_PKG__))
 -			outp += sprintf(outp, "\tPKG_%%");
 -		if (DO_BIC(BIC_RAM__))
 -			outp += sprintf(outp, "\tRAM_%%");
 +		if (do_rapl & RAPL_PKG)
 +			outp += sprintf(outp, " PkgWatt");
 +		if (do_rapl & RAPL_CORES_ENERGY_STATUS)
 +			outp += sprintf(outp, " CorWatt");
 +		if (do_rapl & RAPL_GFX)
 +			outp += sprintf(outp, " GFXWatt");
 +		if (do_rapl & RAPL_DRAM)
 +			outp += sprintf(outp, " RAMWatt");
 +		if (do_rapl & RAPL_PKG_PERF_STATUS)
 +			outp += sprintf(outp, "   PKG_%%");
 +		if (do_rapl & RAPL_DRAM_PERF_STATUS)
 +			outp += sprintf(outp, "   RAM_%%");
  	} else if (do_rapl && rapl_joules) {
 -		if (DO_BIC(BIC_Pkg_J))
 -			outp += sprintf(outp, "\tPkg_J");
 -		if (DO_BIC(BIC_Cor_J))
 -			outp += sprintf(outp, "\tCor_J");
 -		if (DO_BIC(BIC_GFX_J))
 -			outp += sprintf(outp, "\tGFX_J");
 -		if (DO_BIC(BIC_RAM_J))
 -			outp += sprintf(outp, "\tRAM_J");
 -		if (DO_BIC(BIC_PKG__))
 -			outp += sprintf(outp, "\tPKG_%%");
 -		if (DO_BIC(BIC_RAM__))
 -			outp += sprintf(outp, "\tRAM_%%");
 -	}
 -	for (mp = sys.pp; mp; mp = mp->next) {
 -		if (mp->format == FORMAT_RAW) {
 -			if (mp->width == 64)
 -				outp += sprintf(outp, "\t%18.18s", mp->name);
 -			else
 -				outp += sprintf(outp, "\t%10.10s", mp->name);
 -		} else {
 -			outp += sprintf(outp, "\t%-7.7s", mp->name);
 -		}
 +		if (do_rapl & RAPL_PKG)
 +			outp += sprintf(outp, "   Pkg_J");
 +		if (do_rapl & RAPL_CORES_ENERGY_STATUS)
 +			outp += sprintf(outp, "   Cor_J");
 +		if (do_rapl & RAPL_GFX)
 +			outp += sprintf(outp, "   GFX_J");
 +		if (do_rapl & RAPL_DRAM)
 +			outp += sprintf(outp, "   RAM_J");
 +		if (do_rapl & RAPL_PKG_PERF_STATUS)
 +			outp += sprintf(outp, "   PKG_%%");
 +		if (do_rapl & RAPL_DRAM_PERF_STATUS)
 +			outp += sprintf(outp, "   RAM_%%");
  	}
 -
  	outp += sprintf(outp, "\n");
  }
  
@@@ -572,25 -824,26 +711,42 @@@ int format_counters(struct thread_data 
  
  	/* Totl%C0, Any%C0 GFX%C0 CPUGFX% */
  	if (do_skl_residency) {
 -		outp += sprintf(outp, "\t%.2f", 100.0 * p->pkg_wtd_core_c0/tsc);
 -		outp += sprintf(outp, "\t%.2f", 100.0 * p->pkg_any_core_c0/tsc);
 -		outp += sprintf(outp, "\t%.2f", 100.0 * p->pkg_any_gfxe_c0/tsc);
 -		outp += sprintf(outp, "\t%.2f", 100.0 * p->pkg_both_core_gfxe_c0/tsc);
 -	}
 -
 +		outp += sprintf(outp, "%8.2f", 100.0 * p->pkg_wtd_core_c0/t->tsc);
 +		outp += sprintf(outp, "%8.2f", 100.0 * p->pkg_any_core_c0/t->tsc);
 +		outp += sprintf(outp, "%8.2f", 100.0 * p->pkg_any_gfxe_c0/t->tsc);
 +		outp += sprintf(outp, "%8.2f", 100.0 * p->pkg_both_core_gfxe_c0/t->tsc);
 +	}
 +
++<<<<<<< HEAD
 +	if (do_pc2)
 +		outp += sprintf(outp, "%8.2f", 100.0 * p->pc2/t->tsc);
 +	if (do_pc3)
 +		outp += sprintf(outp, "%8.2f", 100.0 * p->pc3/t->tsc);
 +	if (do_pc6)
 +		outp += sprintf(outp, "%8.2f", 100.0 * p->pc6/t->tsc);
 +	if (do_pc7)
 +		outp += sprintf(outp, "%8.2f", 100.0 * p->pc7/t->tsc);
 +	if (do_c8_c9_c10) {
 +		outp += sprintf(outp, "%8.2f", 100.0 * p->pc8/t->tsc);
 +		outp += sprintf(outp, "%8.2f", 100.0 * p->pc9/t->tsc);
 +		outp += sprintf(outp, "%8.2f", 100.0 * p->pc10/t->tsc);
 +	}
++=======
+ 	if (DO_BIC(BIC_Pkgpc2))
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * p->pc2/tsc);
+ 	if (DO_BIC(BIC_Pkgpc3))
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * p->pc3/tsc);
+ 	if (DO_BIC(BIC_Pkgpc6))
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * p->pc6/tsc);
+ 	if (DO_BIC(BIC_Pkgpc7))
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * p->pc7/tsc);
+ 	if (DO_BIC(BIC_Pkgpc8))
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * p->pc8/tsc);
+ 	if (DO_BIC(BIC_Pkgpc9))
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * p->pc9/tsc);
+ 	if (DO_BIC(BIC_Pkgpc10))
+ 		outp += sprintf(outp, "\t%.2f", 100.0 * p->pc10/tsc);
++>>>>>>> 0f47c08d8ccf (tools/power turbostat: bug fixes to --add, --show/--hide features)
  
  	/*
   	 * If measurement interval exceeds minimum RAPL Joule Counter range,
@@@ -1062,26 -1452,35 +1218,42 @@@ int get_counters(struct thread_data *t
  		if (get_msr(cpu, MSR_PKG_BOTH_CORE_GFXE_C0_RES, &p->pkg_both_core_gfxe_c0))
  			return -13;
  	}
- 	if (do_pc3)
+ 	if (DO_BIC(BIC_Pkgpc3))
  		if (get_msr(cpu, MSR_PKG_C3_RESIDENCY, &p->pc3))
  			return -9;
++<<<<<<< HEAD
 +	if (do_pc6)
 +		if (get_msr(cpu, MSR_PKG_C6_RESIDENCY, &p->pc6))
 +			return -10;
 +	if (do_pc2)
++=======
+ 	if (DO_BIC(BIC_Pkgpc6)) {
+ 		if (do_slm_cstates) {
+ 			if (get_msr(cpu, MSR_ATOM_PKG_C6_RESIDENCY, &p->pc6))
+ 				return -10;
+ 		} else {
+ 			if (get_msr(cpu, MSR_PKG_C6_RESIDENCY, &p->pc6))
+ 				return -10;
+ 		}
+ 	}
+ 
+ 	if (DO_BIC(BIC_Pkgpc2))
++>>>>>>> 0f47c08d8ccf (tools/power turbostat: bug fixes to --add, --show/--hide features)
  		if (get_msr(cpu, MSR_PKG_C2_RESIDENCY, &p->pc2))
  			return -11;
- 	if (do_pc7)
+ 	if (DO_BIC(BIC_Pkgpc7))
  		if (get_msr(cpu, MSR_PKG_C7_RESIDENCY, &p->pc7))
  			return -12;
- 	if (do_c8_c9_c10) {
+ 	if (DO_BIC(BIC_Pkgpc8))
  		if (get_msr(cpu, MSR_PKG_C8_RESIDENCY, &p->pc8))
  			return -13;
+ 	if (DO_BIC(BIC_Pkgpc9))
  		if (get_msr(cpu, MSR_PKG_C9_RESIDENCY, &p->pc9))
  			return -13;
+ 	if (DO_BIC(BIC_Pkgpc10))
  		if (get_msr(cpu, MSR_PKG_C10_RESIDENCY, &p->pc10))
  			return -13;
- 	}
+ 
  	if (do_rapl & RAPL_PKG) {
  		if (get_msr(cpu, MSR_PKG_ENERGY_STATUS, &msr))
  			return -13;
@@@ -2832,13 -3814,44 +3004,43 @@@ void process_cpuid(
  	if (has_aperf)
  		aperf_mperf_multiplier = get_aperf_mperf_multiplier(family, model);
  
 -	BIC_PRESENT(BIC_IRQ);
 -	BIC_PRESENT(BIC_TSC_MHz);
 -
 -	if (probe_nhm_msrs(family, model)) {
 -		do_nhm_platform_info = 1;
 -		BIC_PRESENT(BIC_CPU_c1);
 -		BIC_PRESENT(BIC_CPU_c3);
 -		BIC_PRESENT(BIC_CPU_c6);
 -		BIC_PRESENT(BIC_SMI);
 -	}
 +	do_nhm_platform_info = do_nhm_cstates = do_smi = probe_nhm_msrs(family, model);
  	do_snb_cstates = has_snb_msrs(family, model);
++<<<<<<< HEAD
 +	do_pc2 = do_snb_cstates && (pkg_cstate_limit >= PCL__2);
 +	do_pc3 = (pkg_cstate_limit >= PCL__3);
 +	do_pc6 = (pkg_cstate_limit >= PCL__6);
 +	do_pc7 = do_snb_cstates && (pkg_cstate_limit >= PCL__7);
 +	do_c8_c9_c10 = has_hsw_msrs(family, model);
++=======
+ 
+ 	if (do_snb_cstates)
+ 		BIC_PRESENT(BIC_CPU_c7);
+ 
+ 	do_irtl_snb = has_snb_msrs(family, model);
+ 	if (do_snb_cstates && (pkg_cstate_limit >= PCL__2))
+ 		BIC_PRESENT(BIC_Pkgpc2);
+ 	if (pkg_cstate_limit >= PCL__3)
+ 		BIC_PRESENT(BIC_Pkgpc3);
+ 	if (pkg_cstate_limit >= PCL__6)
+ 		BIC_PRESENT(BIC_Pkgpc6);
+ 	if (do_snb_cstates && (pkg_cstate_limit >= PCL__7))
+ 		BIC_PRESENT(BIC_Pkgpc7);
+ 	if (has_slv_msrs(family, model)) {
+ 		BIC_NOT_PRESENT(BIC_Pkgpc2);
+ 		BIC_NOT_PRESENT(BIC_Pkgpc3);
+ 		BIC_PRESENT(BIC_Pkgpc6);
+ 		BIC_NOT_PRESENT(BIC_Pkgpc7);
+ 		BIC_PRESENT(BIC_Mod_c6);
+ 		use_c1_residency_msr = 1;
+ 	}
+ 	if (has_hsw_msrs(family, model)) {
+ 		BIC_PRESENT(BIC_Pkgpc8);
+ 		BIC_PRESENT(BIC_Pkgpc9);
+ 		BIC_PRESENT(BIC_Pkgpc10);
+ 	}
+ 	do_irtl_hsw = has_hsw_msrs(family, model);
++>>>>>>> 0f47c08d8ccf (tools/power turbostat: bug fixes to --add, --show/--hide features)
  	do_skl_residency = has_skl_msrs(family, model);
  	do_slm_cstates = is_slm(family, model);
  	do_knl_cstates  = is_knl(family, model);
@@@ -2968,10 -3995,10 +3170,15 @@@ void topology_probe(
  	}
  	topo.num_cores_per_pkg = max_core_id + 1;
  	if (debug > 1)
 -		fprintf(outf, "max_core_id %d, sizing for %d cores per package\n",
 +		fprintf(stderr, "max_core_id %d, sizing for %d cores per package\n",
  			max_core_id, topo.num_cores_per_pkg);
++<<<<<<< HEAD
 +	if (debug && !summary_only && topo.num_cores_per_pkg > 1)
 +		show_core = 1;
++=======
+ 	if (!summary_only && topo.num_cores_per_pkg > 1)
+ 		BIC_PRESENT(BIC_Core);
++>>>>>>> 0f47c08d8ccf (tools/power turbostat: bug fixes to --add, --show/--hide features)
  
  	topo.num_packages = max_package_id + 1;
  	if (debug > 1)
@@@ -3184,6 -4238,201 +3391,204 @@@ void print_version() 
  		" - Len Brown <lenb@kernel.org>\n");
  }
  
++<<<<<<< HEAD
++=======
+ int add_counter(unsigned int msr_num, char *name, unsigned int width,
+ 	enum counter_scope scope, enum counter_type type,
+ 	enum counter_format format)
+ {
+ 	struct msr_counter *msrp;
+ 
+ 	msrp = calloc(1, sizeof(struct msr_counter));
+ 	if (msrp == NULL) {
+ 		perror("calloc");
+ 		exit(1);
+ 	}
+ 
+ 	msrp->msr_num = msr_num;
+ 	strncpy(msrp->name, name, NAME_BYTES);
+ 	msrp->width = width;
+ 	msrp->type = type;
+ 	msrp->format = format;
+ 
+ 	switch (scope) {
+ 
+ 	case SCOPE_CPU:
+ 		msrp->next = sys.tp;
+ 		sys.tp = msrp;
+ 		sys.added_thread_counters++;
+ 		if (sys.added_thread_counters > MAX_ADDED_COUNTERS) {
+ 			fprintf(stderr, "exceeded max %d added thread counters\n",
+ 				MAX_ADDED_COUNTERS);
+ 			exit(-1);
+ 		}
+ 		break;
+ 
+ 	case SCOPE_CORE:
+ 		msrp->next = sys.cp;
+ 		sys.cp = msrp;
+ 		sys.added_core_counters++;
+ 		if (sys.added_core_counters > MAX_ADDED_COUNTERS) {
+ 			fprintf(stderr, "exceeded max %d added core counters\n",
+ 				MAX_ADDED_COUNTERS);
+ 			exit(-1);
+ 		}
+ 		break;
+ 
+ 	case SCOPE_PACKAGE:
+ 		msrp->next = sys.pp;
+ 		sys.pp = msrp;
+ 		sys.added_package_counters++;
+ 		if (sys.added_package_counters > MAX_ADDED_COUNTERS) {
+ 			fprintf(stderr, "exceeded max %d added package counters\n",
+ 				MAX_ADDED_COUNTERS);
+ 			exit(-1);
+ 		}
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void parse_add_command(char *add_command)
+ {
+ 	int msr_num = 0;
+ 	char name_buffer[NAME_BYTES] = "";
+ 	int width = 64;
+ 	int fail = 0;
+ 	enum counter_scope scope = SCOPE_CPU;
+ 	enum counter_type type = COUNTER_CYCLES;
+ 	enum counter_format format = FORMAT_DELTA;
+ 
+ 	while (add_command) {
+ 
+ 		if (sscanf(add_command, "msr0x%x", &msr_num) == 1)
+ 			goto next;
+ 
+ 		if (sscanf(add_command, "msr%d", &msr_num) == 1)
+ 			goto next;
+ 
+ 		if (sscanf(add_command, "u%d", &width) == 1) {
+ 			if ((width == 32) || (width == 64))
+ 				goto next;
+ 			width = 64;
+ 		}
+ 		if (!strncmp(add_command, "cpu", strlen("cpu"))) {
+ 			scope = SCOPE_CPU;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "core", strlen("core"))) {
+ 			scope = SCOPE_CORE;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "package", strlen("package"))) {
+ 			scope = SCOPE_PACKAGE;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "cycles", strlen("cycles"))) {
+ 			type = COUNTER_CYCLES;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "seconds", strlen("seconds"))) {
+ 			type = COUNTER_SECONDS;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "raw", strlen("raw"))) {
+ 			format = FORMAT_RAW;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "delta", strlen("delta"))) {
+ 			format = FORMAT_DELTA;
+ 			goto next;
+ 		}
+ 		if (!strncmp(add_command, "percent", strlen("percent"))) {
+ 			format = FORMAT_PERCENT;
+ 			goto next;
+ 		}
+ 
+ 		if (sscanf(add_command, "%18s,%*s", name_buffer) == 1) {	/* 18 < NAME_BYTES */
+ 			char *eos;
+ 
+ 			eos = strchr(name_buffer, ',');
+ 			if (eos)
+ 				*eos = '\0';
+ 			goto next;
+ 		}
+ 
+ next:
+ 		add_command = strchr(add_command, ',');
+ 		if (add_command)
+ 			add_command++;
+ 
+ 	}
+ 	if (msr_num == 0) {
+ 		fprintf(stderr, "--add: (msrDDD | msr0xXXX) required\n");
+ 		fail++;
+ 	}
+ 
+ 	/* generate default column header */
+ 	if (*name_buffer == '\0') {
+ 		if (format == FORMAT_RAW) {
+ 			if (width == 32)
+ 				sprintf(name_buffer, "msr%d", msr_num);
+ 			else
+ 				sprintf(name_buffer, "MSR%d", msr_num);
+ 		} else if (format == FORMAT_DELTA) {
+ 			if (width == 32)
+ 				sprintf(name_buffer, "cnt%d", msr_num);
+ 			else
+ 				sprintf(name_buffer, "CNT%d", msr_num);
+ 		} else if (format == FORMAT_PERCENT) {
+ 			if (width == 32)
+ 				sprintf(name_buffer, "msr%d%%", msr_num);
+ 			else
+ 				sprintf(name_buffer, "MSR%d%%", msr_num);
+ 		}
+ 	}
+ 
+ 	if (add_counter(msr_num, name_buffer, width, scope, type, format))
+ 		fail++;
+ 
+ 	if (fail) {
+ 		help();
+ 		exit(1);
+ 	}
+ }
+ /*
+  * HIDE_LIST - hide this list of counters, show the rest [default]
+  * SHOW_LIST - show this list of counters, hide the rest
+  */
+ enum show_hide_mode { SHOW_LIST, HIDE_LIST } global_show_hide_mode = HIDE_LIST;
+ 
+ int shown;
+ /*
+  * parse_show_hide() - process cmdline to set default counter action
+  */
+ void parse_show_hide(char *optarg, enum show_hide_mode new_mode)
+ {
+ 	/*
+ 	 * --show: show only those specified
+ 	 *  The 1st invocation will clear and replace the enabled mask
+ 	 *  subsequent invocations can add to it.
+ 	 */
+ 	if (new_mode == SHOW_LIST) {
+ 		if (shown == 0)
+ 			bic_enabled = bic_lookup(optarg);
+ 		else
+ 			bic_enabled |= bic_lookup(optarg);
+ 		shown = 1;
+ 
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * --hide: do not show those specified
+ 	 *  multiple invocations simply clear more bits in enabled mask
+ 	 */
+ 	bic_enabled &= ~bic_lookup(optarg);
+ }
+ 
++>>>>>>> 0f47c08d8ccf (tools/power turbostat: bug fixes to --add, --show/--hide features)
  void cmdline(int argc, char **argv)
  {
  	int opt;
* Unmerged path tools/power/x86/turbostat/turbostat.c
