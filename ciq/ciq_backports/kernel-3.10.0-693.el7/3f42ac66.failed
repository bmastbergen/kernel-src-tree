net/mlx5: E-Switch, Use the correct error check on returned pointers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: E-Switch, Use the correct error check on returned pointers (Don Dutile) [1385330 1417284]
Rebuild_FUZZ: 96.97%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 3f42ac6648723e906c1c10edc0c523aff29963cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3f42ac66.failed

The mlx5 flow-steering API (mlx5_create_flow_table/group/rule) never
returns null pointer on error. Even if it was doing that, checking
for IS_ERR_OR_NULL(p) and then returning PTR_ERR(p) would have cause
bugs, since PTR_ERR(NULL) --> success, crash.

To make things more robust and protect against related future bugs,
convert all IS_ERR_OR_NULL checks on returned values to IS_ERR.

Fixes: 5742df0f7dbe ('net/mlx5: E-Switch, Introduce VST vport ingress/egress ACLs')
Fixes: 86d722ad2c3b ('net/mlx5: Use flow steering infrastructure for mlx5_en')
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Reported-by: Ilya Lesokhin <ilyal@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3f42ac6648723e906c1c10edc0c523aff29963cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index b153747c6dc3,a350af221d15..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -414,8 -456,8 +414,13 @@@ static int esw_create_fdb_table(struct 
  	memset(flow_group_in, 0, inlen);
  
  	table_size = BIT(MLX5_CAP_ESW_FLOWTABLE_FDB(dev, log_max_ft_size));
++<<<<<<< HEAD
 +	fdb = mlx5_create_flow_table(root_ns, 0, table_size);
 +	if (IS_ERR_OR_NULL(fdb)) {
++=======
+ 	fdb = mlx5_create_flow_table(root_ns, 0, table_size, 0);
+ 	if (IS_ERR(fdb)) {
++>>>>>>> 3f42ac664872 (net/mlx5: E-Switch, Use the correct error check on returned pointers)
  		err = PTR_ERR(fdb);
  		esw_warn(dev, "Failed to create FDB Table err %d\n", err);
  		goto out;
@@@ -1072,23 -1343,55 +1077,55 @@@ static int esw_vport_ingress_config(str
  			 vport->vport, err);
  		goto out;
  	}
 +	MLX5_SET_TO_ONES(fte_match_param, match_c, outer_headers.vlan_tag);
 +	MLX5_SET_TO_ONES(fte_match_param, match_v, outer_headers.vlan_tag);
  
++<<<<<<< HEAD
++=======
+ 	if (vport->vlan || vport->qos)
+ 		MLX5_SET_TO_ONES(fte_match_param, match_c, outer_headers.vlan_tag);
+ 
+ 	if (vport->spoofchk) {
+ 		MLX5_SET_TO_ONES(fte_match_param, match_c, outer_headers.smac_47_16);
+ 		MLX5_SET_TO_ONES(fte_match_param, match_c, outer_headers.smac_15_0);
+ 		smac_v = MLX5_ADDR_OF(fte_match_param,
+ 				      match_v,
+ 				      outer_headers.smac_47_16);
+ 		ether_addr_copy(smac_v, smac);
+ 	}
+ 
+ 	vport->ingress.allow_rule =
+ 		mlx5_add_flow_rule(vport->ingress.acl,
+ 				   MLX5_MATCH_OUTER_HEADERS,
+ 				   match_c,
+ 				   match_v,
+ 				   MLX5_FLOW_CONTEXT_ACTION_ALLOW,
+ 				   0, NULL);
+ 	if (IS_ERR(vport->ingress.allow_rule)) {
+ 		err = PTR_ERR(vport->ingress.allow_rule);
+ 		pr_warn("vport[%d] configure ingress allow rule, err(%d)\n",
+ 			vport->vport, err);
+ 		vport->ingress.allow_rule = NULL;
+ 		goto out;
+ 	}
+ 
+ 	memset(match_c, 0, MLX5_ST_SZ_BYTES(fte_match_param));
+ 	memset(match_v, 0, MLX5_ST_SZ_BYTES(fte_match_param));
++>>>>>>> 3f42ac664872 (net/mlx5: E-Switch, Use the correct error check on returned pointers)
  	vport->ingress.drop_rule =
  		mlx5_add_flow_rule(vport->ingress.acl,
 -				   0,
 +				   MLX5_MATCH_OUTER_HEADERS,
  				   match_c,
  				   match_v,
  				   MLX5_FLOW_CONTEXT_ACTION_DROP,
  				   0, NULL);
- 	if (IS_ERR_OR_NULL(vport->ingress.drop_rule)) {
+ 	if (IS_ERR(vport->ingress.drop_rule)) {
  		err = PTR_ERR(vport->ingress.drop_rule);
 -		pr_warn("vport[%d] configure ingress drop rule, err(%d)\n",
 +		pr_warn("vport[%d] configure ingress rules, err(%d)\n",
  			vport->vport, err);
  		vport->ingress.drop_rule = NULL;
 -		goto out;
  	}
 -
  out:
 -	if (err)
 -		esw_vport_cleanup_ingress_rules(esw, vport);
 -
  	kfree(match_v);
  	kfree(match_c);
  	return err;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
