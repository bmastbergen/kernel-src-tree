KVM: PPC: Book3S HV: Convert kvmppc_read_intr to a C function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Suresh Warrier <warrier@linux.vnet.ibm.com>
commit 37f55d30df2eef89b97d627e5830beb6983c4101
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/37f55d30.failed

Modify kvmppc_read_intr to make it a C function.  Because it is called
from kvmppc_check_wake_reason, any of the assembler code that calls
either kvmppc_read_intr or kvmppc_check_wake_reason now has to assume
that the volatile registers might have been modified.

This also adds in the optimization of clearing saved_xirr in the case
where we completely handle and EOI an IPI.  Without this, the next
device interrupt will require two trips through the host interrupt
handling code.

[paulus@ozlabs.org - made kvmppc_check_wake_reason create a stack frame
 when it is calling kvmppc_read_intr, which means we can set r12 to
 the trap number (0x500) after the call to kvmppc_read_intr, instead
 of using r31.  Also moved the deliver_guest_interrupt label so as to
 restore XER and CTR, plus other minor tweaks.]

	Signed-off-by: Suresh Warrier <warrier@linux.vnet.ibm.com>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit 37f55d30df2eef89b97d627e5830beb6983c4101)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv_builtin.c
#	arch/powerpc/kvm/book3s_hv_rmhandlers.S
diff --cc arch/powerpc/kvm/book3s_hv_builtin.c
index 2b357edf45a7,b476a6af893f..000000000000
--- a/arch/powerpc/kvm/book3s_hv_builtin.c
+++ b/arch/powerpc/kvm/book3s_hv_builtin.c
@@@ -24,8 -24,11 +24,9 @@@
  #include <asm/xics.h>
  #include <asm/dbell.h>
  #include <asm/cputhreads.h>
+ #include <asm/io.h>
  
 -#define KVM_CMA_CHUNK_ORDER	18
 -
 +#include "book3s_hv_cma.h"
  /*
   * Hash page table alignment on newer cpus(CPU_FTR_ARCH_206)
   * should be power of 2.
@@@ -265,3 -284,89 +266,92 @@@ void kvmhv_commence_exit(int trap
  			kvmhv_interrupt_vcore(vc, ee);
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ struct kvmppc_host_rm_ops *kvmppc_host_rm_ops_hv;
+ EXPORT_SYMBOL_GPL(kvmppc_host_rm_ops_hv);
+ 
+ /*
+  * Determine what sort of external interrupt is pending (if any).
+  * Returns:
+  *	0 if no interrupt is pending
+  *	1 if an interrupt is pending that needs to be handled by the host
+  *	-1 if there was a guest wakeup IPI (which has now been cleared)
+  */
+ 
+ long kvmppc_read_intr(void)
+ {
+ 	unsigned long xics_phys;
+ 	u32 h_xirr;
+ 	__be32 xirr;
+ 	u32 xisr;
+ 	u8 host_ipi;
+ 
+ 	/* see if a host IPI is pending */
+ 	host_ipi = local_paca->kvm_hstate.host_ipi;
+ 	if (host_ipi)
+ 		return 1;
+ 
+ 	/* Now read the interrupt from the ICP */
+ 	xics_phys = local_paca->kvm_hstate.xics_phys;
+ 	if (unlikely(!xics_phys))
+ 		return 1;
+ 
+ 	/*
+ 	 * Save XIRR for later. Since we get control in reverse endian
+ 	 * on LE systems, save it byte reversed and fetch it back in
+ 	 * host endian. Note that xirr is the value read from the
+ 	 * XIRR register, while h_xirr is the host endian version.
+ 	 */
+ 	xirr = _lwzcix(xics_phys + XICS_XIRR);
+ 	h_xirr = be32_to_cpu(xirr);
+ 	local_paca->kvm_hstate.saved_xirr = h_xirr;
+ 	xisr = h_xirr & 0xffffff;
+ 	/*
+ 	 * Ensure that the store/load complete to guarantee all side
+ 	 * effects of loading from XIRR has completed
+ 	 */
+ 	smp_mb();
+ 
+ 	/* if nothing pending in the ICP */
+ 	if (!xisr)
+ 		return 0;
+ 
+ 	/* We found something in the ICP...
+ 	 *
+ 	 * If it is an IPI, clear the MFRR and EOI it.
+ 	 */
+ 	if (xisr == XICS_IPI) {
+ 		_stbcix(xics_phys + XICS_MFRR, 0xff);
+ 		_stwcix(xics_phys + XICS_XIRR, xirr);
+ 		/*
+ 		 * Need to ensure side effects of above stores
+ 		 * complete before proceeding.
+ 		 */
+ 		smp_mb();
+ 
+ 		/*
+ 		 * We need to re-check host IPI now in case it got set in the
+ 		 * meantime. If it's clear, we bounce the interrupt to the
+ 		 * guest
+ 		 */
+ 		host_ipi = local_paca->kvm_hstate.host_ipi;
+ 		if (unlikely(host_ipi != 0)) {
+ 			/* We raced with the host,
+ 			 * we need to resend that IPI, bummer
+ 			 */
+ 			_stbcix(xics_phys + XICS_MFRR, IPI_PRIORITY);
+ 			/* Let side effects complete */
+ 			smp_mb();
+ 			return 1;
+ 		}
+ 
+ 		/* OK, it's an IPI for us */
+ 		local_paca->kvm_hstate.saved_xirr = 0;
+ 		return -1;
+ 	}
+ 
+ 	return 1;
+ }
++>>>>>>> 37f55d30df2e (KVM: PPC: Book3S HV: Convert kvmppc_read_intr to a C function)
diff --cc arch/powerpc/kvm/book3s_hv_rmhandlers.S
index a4309327567b,dccfa85d35df..000000000000
--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S
+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
@@@ -2172,83 -2401,22 +2228,102 @@@ END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S
  	li	r3, -1
  	blr
  
++<<<<<<< HEAD
 +/*
 + * Determine what sort of external interrupt is pending (if any).
 + * Returns:
 + *	0 if no interrupt is pending
 + *	1 if an interrupt is pending that needs to be handled by the host
 + *	-1 if there was a guest wakeup IPI (which has now been cleared)
 + * Modifies r0, r6, r7, r8, returns value in r3.
 + */
 +kvmppc_read_intr:
 +	/* see if a host IPI is pending */
 +	li	r3, 1
 +	lbz	r0, HSTATE_HOST_IPI(r13)
 +	cmpwi	r0, 0
 +	bne	1f
 +
 +	/* Now read the interrupt from the ICP */
 +	ld	r6, HSTATE_XICS_PHYS(r13)
 +	li	r7, XICS_XIRR
 +	cmpdi	r6, 0
 +	beq-	1f
 +	lwzcix	r0, r6, r7
 +	/*
 +	 * Save XIRR for later. Since we get in in reverse endian on LE
 +	 * systems, save it byte reversed and fetch it back in host endian.
 +	 */
 +	li	r3, HSTATE_SAVED_XIRR
 +	STWX_BE	r0, r3, r13
 +#ifdef __LITTLE_ENDIAN__
 +	lwz	r3, HSTATE_SAVED_XIRR(r13)
 +#else
 +	mr	r3, r0
 +#endif
 +	rlwinm.	r3, r3, 0, 0xffffff
 +	sync
 +	beq	1f			/* if nothing pending in the ICP */
 +
 +	/* We found something in the ICP...
 +	 *
 +	 * If it's not an IPI, stash it in the PACA and return to
 +	 * the host, we don't (yet) handle directing real external
 +	 * interrupts directly to the guest
 +	 */
 +	cmpwi	r3, XICS_IPI		/* if there is, is it an IPI? */
 +	bne	42f
 +
 +	/* It's an IPI, clear the MFRR and EOI it */
 +	li	r3, 0xff
 +	li	r8, XICS_MFRR
 +	stbcix	r3, r6, r8		/* clear the IPI */
 +	stwcix	r0, r6, r7		/* EOI it */
 +	sync
 +
 +	/* We need to re-check host IPI now in case it got set in the
 +	 * meantime. If it's clear, we bounce the interrupt to the
 +	 * guest
 +	 */
 +	lbz	r0, HSTATE_HOST_IPI(r13)
 +	cmpwi	r0, 0
 +	bne-	43f
 +
 +	/* OK, it's an IPI for us */
 +	li	r12, 0
 +	li	r3, -1
 +1:	blr
 +
 +42:	/* It's not an IPI and it's for the host. We saved a copy of XIRR in
 +	 * the PACA earlier, it will be picked up by the host ICP driver
 +	 */
 +	li	r3, 1
 +	b	1b
 +
 +43:	/* We raced with the host, we need to resend that IPI, bummer */
 +	li	r0, IPI_PRIORITY
 +	stbcix	r0, r6, r8		/* set the IPI */
 +	sync
 +	li	r3, 1
 +	b	1b
++=======
+ 	/* Woken up due to Hypervisor maintenance interrupt */
+ 4:	li	r12, BOOK3S_INTERRUPT_HMI
+ 	li	r3, 1
+ 	blr
+ 
+ 	/* external interrupt - create a stack frame so we can call C */
+ 7:	mflr	r0
+ 	std	r0, PPC_LR_STKOFF(r1)
+ 	stdu	r1, -PPC_MIN_STKFRM(r1)
+ 	bl	kvmppc_read_intr
+ 	nop
+ 	li	r12, BOOK3S_INTERRUPT_EXTERNAL
+ 	ld	r0, PPC_MIN_STKFRM+PPC_LR_STKOFF(r1)
+ 	addi	r1, r1, PPC_MIN_STKFRM
+ 	mtlr	r0
+ 	blr
++>>>>>>> 37f55d30df2e (KVM: PPC: Book3S HV: Convert kvmppc_read_intr to a C function)
  
  /*
   * Save away FP, VMX and VSX registers.
* Unmerged path arch/powerpc/kvm/book3s_hv_builtin.c
* Unmerged path arch/powerpc/kvm/book3s_hv_rmhandlers.S
