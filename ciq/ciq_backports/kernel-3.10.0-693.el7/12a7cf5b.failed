dm mirror: use all available legs on multiple failures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Heinz Mauelshagen <heinzm@redhat.com>
commit 12a7cf5ba6c776a2621d8972c7d42e8d3d959d20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/12a7cf5b.failed

When any leg(s) have failed, any read will cause a new operational
default leg to be selected and the read is resubmitted to it.  If that
new default leg fails the read too, no other still accessible legs are
used to resubmit the read again -- thus failing the io.

Fix by allowing the read to get resubmitted until all operational legs
have been exhausted.  Also, remove any details.bi_dev use as a flag.

	Signed-off-by: Heinz Mauelshagen <heinzm@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 12a7cf5ba6c776a2621d8972c7d42e8d3d959d20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-raid1.c
diff --cc drivers/md/dm-raid1.c
index c41cafbde60d,9a8b71067c6e..000000000000
--- a/drivers/md/dm-raid1.c
+++ b/drivers/md/dm-raid1.c
@@@ -1223,22 -1257,12 +1220,17 @@@ static int mirror_end_io(struct dm_targ
  	}
  
  	if (error == -EOPNOTSUPP)
- 		goto out;
+ 		return error;
  
++<<<<<<< HEAD
 +	if ((error == -EWOULDBLOCK) && (bio->bi_rw & REQ_RAHEAD))
 +		goto out;
++=======
+ 	if ((error == -EWOULDBLOCK) && (bio->bi_opf & REQ_RAHEAD))
+ 		return error;
++>>>>>>> 12a7cf5ba6c7 (dm mirror: use all available legs on multiple failures)
  
  	if (unlikely(error)) {
- 		if (!bio_record->details.bi_bdev) {
- 			/*
- 			 * There wasn't enough memory to record necessary
- 			 * information for a retry or there was no other
- 			 * mirror in-sync.
- 			 */
- 			DMERR_LIMIT("Mirror read failed.");
- 			return -EIO;
- 		}
- 
  		m = bio_record->m;
  
  		DMERR("Mirror read failed from %s. Trying alternative device.",
@@@ -1254,7 -1278,7 +1246,11 @@@
  			bd = &bio_record->details;
  
  			dm_bio_restore(bd, bio);
++<<<<<<< HEAD
 +			bio_record->details.bi_bdev = NULL;
++=======
+ 			bio->bi_error = 0;
++>>>>>>> 12a7cf5ba6c7 (dm mirror: use all available legs on multiple failures)
  
  			queue_bio(ms, bio, rw);
  			return DM_ENDIO_INCOMPLETE;
* Unmerged path drivers/md/dm-raid1.c
