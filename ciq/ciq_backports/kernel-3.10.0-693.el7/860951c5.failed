mmc: host: use the defined function to check whether card is removable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mmc] host: use the defined function to check whether card is removable (Don Zickus) [1430497]
Rebuild_FUZZ: 96.30%
commit-author Jaehoon Chung <jh80.chung@samsung.com>
commit 860951c5f0f5caf595799d98b93a8304bf70f08d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/860951c5.failed

In linux/mmc/host.h, mmc_card_is_removable() is already defined.
It should be maintainted more easier than now.

	Signed-off-by: Jaehoon Chung <jh80.chung@samsung.com>
	Reviewed-by: Shawn Lin <shawn.lin@rock-chips.com>
	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
(cherry picked from commit 860951c5f0f5caf595799d98b93a8304bf70f08d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/mmc/host/dw_mmc.c
#	drivers/mmc/host/sdhci-bcm-kona.c
#	drivers/mmc/host/sdhci-of-at91.c
#	drivers/mmc/host/sdhci-st.c
#	drivers/mmc/host/sdhci.c
diff --cc drivers/mmc/host/dw_mmc.c
index bc3a1bc4940f,801285801664..000000000000
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@@ -836,42 -1367,94 +836,46 @@@ static void dw_mci_set_ios(struct mmc_h
  	default:
  		break;
  	}
 -
 -	if (slot->host->state == STATE_WAITING_CMD11_DONE && ios->clock != 0)
 -		slot->host->state = STATE_IDLE;
  }
  
 -static int dw_mci_card_busy(struct mmc_host *mmc)
 +static int dw_mci_get_ro(struct mmc_host *mmc)
  {
 +	int read_only;
  	struct dw_mci_slot *slot = mmc_priv(mmc);
 -	u32 status;
 +	struct dw_mci_board *brd = slot->host->pdata;
  
 -	/*
 -	 * Check the busy bit which is low when DAT[3:0]
 -	 * (the data lines) are 0000
 -	 */
 -	status = mci_readl(slot->host, STATUS);
 +	/* Use platform get_ro function, else try on board write protect */
 +	if (slot->quirks & DW_MCI_SLOT_QUIRK_NO_WRITE_PROTECT)
 +		read_only = 0;
 +	else if (brd->get_ro)
 +		read_only = brd->get_ro(slot->id);
 +	else if (gpio_is_valid(slot->wp_gpio))
 +		read_only = gpio_get_value(slot->wp_gpio);
 +	else
 +		read_only =
 +			mci_readl(slot->host, WRTPRT) & (1 << slot->id) ? 1 : 0;
 +
 +	dev_dbg(&mmc->class_dev, "card is %s\n",
 +		read_only ? "read-only" : "read-write");
  
 -	return !!(status & SDMMC_STATUS_BUSY);
 +	return read_only;
  }
  
 -static int dw_mci_switch_voltage(struct mmc_host *mmc, struct mmc_ios *ios)
 +static int dw_mci_get_cd(struct mmc_host *mmc)
  {
 +	int present;
  	struct dw_mci_slot *slot = mmc_priv(mmc);
 -	struct dw_mci *host = slot->host;
 -	const struct dw_mci_drv_data *drv_data = host->drv_data;
 -	u32 uhs;
 -	u32 v18 = SDMMC_UHS_18V << slot->id;
 -	int ret;
 +	struct dw_mci_board *brd = slot->host->pdata;
  
 -	if (drv_data && drv_data->switch_voltage)
 -		return drv_data->switch_voltage(mmc, ios);
 -
 -	/*
 -	 * Program the voltage.  Note that some instances of dw_mmc may use
 -	 * the UHS_REG for this.  For other instances (like exynos) the UHS_REG
 -	 * does no harm but you need to set the regulator directly.  Try both.
 -	 */
 -	uhs = mci_readl(host, UHS_REG);
 -	if (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330)
 -		uhs &= ~v18;
 -	else
 -		uhs |= v18;
 -
 -	if (!IS_ERR(mmc->supply.vqmmc)) {
 -		ret = mmc_regulator_set_vqmmc(mmc, ios);
 -
 -		if (ret) {
 -			dev_dbg(&mmc->class_dev,
 -					 "Regulator set error %d - %s V\n",
 -					 ret, uhs & v18 ? "1.8" : "3.3");
 -			return ret;
 -		}
 -	}
 -	mci_writel(host, UHS_REG, uhs);
 -
 -	return 0;
 -}
 -
 -static int dw_mci_get_ro(struct mmc_host *mmc)
 -{
 -	int read_only;
 -	struct dw_mci_slot *slot = mmc_priv(mmc);
 -	int gpio_ro = mmc_gpio_get_ro(mmc);
 -
 -	/* Use platform get_ro function, else try on board write protect */
 -	if (gpio_ro >= 0)
 -		read_only = gpio_ro;
 -	else
 -		read_only =
 -			mci_readl(slot->host, WRTPRT) & (1 << slot->id) ? 1 : 0;
 -
 -	dev_dbg(&mmc->class_dev, "card is %s\n",
 -		read_only ? "read-only" : "read-write");
 -
 -	return read_only;
 -}
 -
 -static int dw_mci_get_cd(struct mmc_host *mmc)
 -{
 -	int present;
 -	struct dw_mci_slot *slot = mmc_priv(mmc);
 -	struct dw_mci *host = slot->host;
 -	int gpio_cd = mmc_gpio_get_cd(mmc);
 -
 -	/* Use platform get_cd function, else try onboard card detect */
 -	if ((mmc->caps & MMC_CAP_NEEDS_POLL) || !mmc_card_is_removable(mmc))
 -		present = 1;
 -	else if (gpio_cd >= 0)
 -		present = gpio_cd;
 +	/* Use platform get_cd function, else try onboard card detect */
++<<<<<<< HEAD
 +	if (brd->quirks & DW_MCI_QUIRK_BROKEN_CARD_DETECTION)
++=======
++	if ((mmc->caps & MMC_CAP_NEEDS_POLL) || !mmc_card_is_removable(mmc))
++>>>>>>> 860951c5f0f5 (mmc: host: use the defined function to check whether card is removable)
 +		present = 1;
 +	else if (brd->get_cd)
 +		present = !brd->get_cd(slot->id);
  	else
  		present = (mci_readl(slot->host, CDETECT) & (1 << slot->id))
  			== 0 ? 1 : 0;
diff --cc drivers/mmc/host/sdhci.c
index 0ce88afd81da,cdcaba27c163..000000000000
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@@ -3068,8 -3089,8 +3068,13 @@@ int sdhci_add_host(struct sdhci_host *h
  		mmc->caps |= MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED;
  
  	if ((host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION) &&
++<<<<<<< HEAD
 +	    !(mmc->caps & MMC_CAP_NONREMOVABLE) &&
 +	    IS_ERR_VALUE(mmc_gpio_get_cd(host->mmc)))
++=======
+ 	    mmc_card_is_removable(mmc) &&
+ 	    mmc_gpio_get_cd(host->mmc) < 0)
++>>>>>>> 860951c5f0f5 (mmc: host: use the defined function to check whether card is removable)
  		mmc->caps |= MMC_CAP_NEEDS_POLL;
  
  	/* If there are external regulators, get them */
* Unmerged path drivers/mmc/host/sdhci-bcm-kona.c
* Unmerged path drivers/mmc/host/sdhci-of-at91.c
* Unmerged path drivers/mmc/host/sdhci-st.c
* Unmerged path drivers/mmc/host/dw_mmc.c
diff --git a/drivers/mmc/host/mxcmmc.c b/drivers/mmc/host/mxcmmc.c
index d5036353bddc..cde9bb6a67d3 100644
--- a/drivers/mmc/host/mxcmmc.c
+++ b/drivers/mmc/host/mxcmmc.c
@@ -1106,7 +1106,7 @@ static int mxcmci_probe(struct platform_device *pdev)
 
 	if (pdata)
 		dat3_card_detect = pdata->dat3_card_detect;
-	else if (!(mmc->caps & MMC_CAP_NONREMOVABLE)
+	else if (mmc_card_is_removable(mmc)
 			&& !of_property_read_bool(pdev->dev.of_node, "cd-gpios"))
 		dat3_card_detect = true;
 
* Unmerged path drivers/mmc/host/sdhci-bcm-kona.c
* Unmerged path drivers/mmc/host/sdhci-of-at91.c
* Unmerged path drivers/mmc/host/sdhci-st.c
* Unmerged path drivers/mmc/host/sdhci.c
diff --git a/drivers/mmc/host/tmio_mmc_pio.c b/drivers/mmc/host/tmio_mmc_pio.c
index f508ecb5b8a7..48d548996ab5 100644
--- a/drivers/mmc/host/tmio_mmc_pio.c
+++ b/drivers/mmc/host/tmio_mmc_pio.c
@@ -1022,7 +1022,7 @@ int tmio_mmc_host_probe(struct tmio_mmc_host **host,
 
 	_host->native_hotplug = !(pdata->flags & TMIO_MMC_USE_GPIO_CD ||
 				  mmc->caps & MMC_CAP_NEEDS_POLL ||
-				  mmc->caps & MMC_CAP_NONREMOVABLE ||
+				  !mmc_card_is_removable(mmc) ||
 				  mmc->slot.cd_irq >= 0);
 
 	_host->power = false;
