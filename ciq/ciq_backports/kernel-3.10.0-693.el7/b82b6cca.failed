cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Daniel Lezcano <daniel.lezcano@linaro.org>
commit b82b6cca488074da3852e8a54fde1d9f74bf1557
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b82b6cca.failed

The only place where the time is invalid is when the ACPI_CSTATE_FFH entry
method is not set. Otherwise for all the drivers, the time can be correctly
measured.

Instead of duplicating the CPUIDLE_FLAG_TIME_VALID flag in all the drivers
for all the states, just invert the logic by replacing it by the flag
CPUIDLE_FLAG_TIME_INVALID, hence we can set this flag only for the acpi idle
driver, remove the former flag from all the drivers and invert the logic with
this flag in the different governor.

	Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit b82b6cca488074da3852e8a54fde1d9f74bf1557)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/mach-at91/cpuidle.c
#	arch/arm/mach-davinci/cpuidle.c
#	arch/arm/mach-imx/cpuidle-imx6sl.c
#	arch/arm/mach-omap2/cpuidle44xx.c
#	arch/arm/mach-tegra/cpuidle-tegra114.c
#	arch/mips/include/asm/idle.h
#	drivers/cpuidle/cpuidle-arm64.c
#	drivers/cpuidle/cpuidle-big_little.c
#	drivers/cpuidle/cpuidle-cps.c
#	drivers/cpuidle/cpuidle-exynos.c
#	drivers/cpuidle/cpuidle-mvebu-v7.c
#	drivers/cpuidle/cpuidle-powernv.c
#	drivers/cpuidle/cpuidle-zynq.c
#	drivers/cpuidle/driver.c
#	drivers/cpuidle/dt_idle_states.c
#	drivers/cpuidle/governors/menu.c
#	drivers/idle/intel_idle.c
diff --cc arch/arm/mach-at91/cpuidle.c
index 69f9e3bbf4e5,1964ff07117c..000000000000
--- a/arch/arm/mach-at91/cpuidle.c
+++ b/arch/arm/mach-at91/cpuidle.c
@@@ -51,8 -42,7 +51,12 @@@ static struct cpuidle_driver at91_idle_
  	.states[1]		= {
  		.enter			= at91_enter_idle,
  		.exit_latency		= 10,
++<<<<<<< HEAD:arch/arm/mach-at91/cpuidle.c
 +		.target_residency	= 100000,
 +		.flags			= CPUIDLE_FLAG_TIME_VALID,
++=======
+ 		.target_residency	= 10000,
++>>>>>>> b82b6cca4880 (cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic):drivers/cpuidle/cpuidle-at91.c
  		.name			= "RAM_SR",
  		.desc			= "WFI and DDR Self Refresh",
  	},
diff --cc arch/arm/mach-davinci/cpuidle.c
index 36aef3a7dedb,b4675fc28f83..000000000000
--- a/arch/arm/mach-davinci/cpuidle.c
+++ b/arch/arm/mach-davinci/cpuidle.c
@@@ -65,8 -65,7 +65,12 @@@ static struct cpuidle_driver davinci_id
  	.states[1]		= {
  		.enter			= davinci_enter_idle,
  		.exit_latency		= 10,
++<<<<<<< HEAD
 +		.target_residency	= 100000,
 +		.flags			= CPUIDLE_FLAG_TIME_VALID,
++=======
+ 		.target_residency	= 10000,
++>>>>>>> b82b6cca4880 (cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic)
  		.name			= "DDR SR",
  		.desc			= "WFI and DDR Self Refresh",
  	},
diff --cc arch/arm/mach-omap2/cpuidle44xx.c
index c443f2e97e10,01e398a868bc..000000000000
--- a/arch/arm/mach-omap2/cpuidle44xx.c
+++ b/arch/arm/mach-omap2/cpuidle44xx.c
@@@ -171,8 -204,7 +170,12 @@@ static struct cpuidle_driver omap4_idle
  			/* C2 - CPU0 OFF + CPU1 OFF + MPU CSWR */
  			.exit_latency = 328 + 440,
  			.target_residency = 960,
++<<<<<<< HEAD
 +			.flags = CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_COUPLED |
 +			         CPUIDLE_FLAG_TIMER_STOP,
++=======
+ 			.flags = CPUIDLE_FLAG_COUPLED,
++>>>>>>> b82b6cca4880 (cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic)
  			.enter = omap_enter_idle_coupled,
  			.name = "C2",
  			.desc = "CPUx OFF, MPUSS CSWR",
@@@ -181,8 -213,7 +184,12 @@@
  			/* C3 - CPU0 OFF + CPU1 OFF + MPU OSWR */
  			.exit_latency = 460 + 518,
  			.target_residency = 1100,
++<<<<<<< HEAD
 +			.flags = CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_COUPLED |
 +			         CPUIDLE_FLAG_TIMER_STOP,
++=======
+ 			.flags = CPUIDLE_FLAG_COUPLED,
++>>>>>>> b82b6cca4880 (cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic)
  			.enter = omap_enter_idle_coupled,
  			.name = "C3",
  			.desc = "CPUx OFF, MPUSS OSWR",
diff --cc arch/arm/mach-tegra/cpuidle-tegra114.c
index 1d1c6023f4a2,b30908235d52..000000000000
--- a/arch/arm/mach-tegra/cpuidle-tegra114.c
+++ b/arch/arm/mach-tegra/cpuidle-tegra114.c
@@@ -23,9 -66,19 +23,22 @@@
  static struct cpuidle_driver tegra_idle_driver = {
  	.name = "tegra_idle",
  	.owner = THIS_MODULE,
 -	.state_count = TEGRA114_MAX_STATES,
 +	.state_count = 1,
  	.states = {
  		[0] = ARM_CPUIDLE_WFI_STATE_PWR(600),
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PM_SLEEP
+ 		[1] = {
+ 			.enter			= tegra114_idle_power_down,
+ 			.exit_latency		= 500,
+ 			.target_residency	= 1000,
+ 			.power_usage		= 0,
+ 			.name			= "powered-down",
+ 			.desc			= "CPU power gated",
+ 		},
+ #endif
++>>>>>>> b82b6cca4880 (cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic)
  	},
  };
  
diff --cc arch/mips/include/asm/idle.h
index d192158886b1,a2d18ab57ac6..000000000000
--- a/arch/mips/include/asm/idle.h
+++ b/arch/mips/include/asm/idle.h
@@@ -14,10 -14,16 +14,23 @@@ static inline int using_rollback_handle
  	return cpu_wait == r4k_wait;
  }
  
++<<<<<<< HEAD
 +static inline int address_is_in_r4k_wait_irqoff(unsigned long addr)
 +{
 +	return addr >= (unsigned long)r4k_wait_irqoff &&
 +	       addr < (unsigned long)__pastwait;
++=======
+ extern int mips_cpuidle_wait_enter(struct cpuidle_device *dev,
+ 				   struct cpuidle_driver *drv, int index);
+ 
+ #define MIPS_CPUIDLE_WAIT_STATE {\
+ 	.enter			= mips_cpuidle_wait_enter,\
+ 	.exit_latency		= 1,\
+ 	.target_residency	= 1,\
+ 	.power_usage		= UINT_MAX,\
+ 	.name			= "wait",\
+ 	.desc			= "MIPS wait",\
++>>>>>>> b82b6cca4880 (cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic)
  }
  
  #endif /* __ASM_IDLE_H  */
diff --cc drivers/cpuidle/cpuidle-powernv.c
index 7e83ba122045,e9248bb9173a..000000000000
--- a/drivers/cpuidle/cpuidle-powernv.c
+++ b/drivers/cpuidle/cpuidle-powernv.c
@@@ -214,8 -201,11 +213,16 @@@ static int powernv_add_idle_states(void
  			/* Add NAP state */
  			strcpy(powernv_states[nr_idle_states].name, "Nap");
  			strcpy(powernv_states[nr_idle_states].desc, "Nap");
++<<<<<<< HEAD
 +			powernv_states[nr_idle_states].flags = CPUIDLE_FLAG_TIME_VALID;
 +			powernv_states[nr_idle_states].target_residency = 100;
++=======
+ 			powernv_states[nr_idle_states].flags = 0;
+ 			powernv_states[nr_idle_states].exit_latency =
+ 					((unsigned int)latency_ns) / 1000;
+ 			powernv_states[nr_idle_states].target_residency =
+ 					((unsigned int)latency_ns / 100);
++>>>>>>> b82b6cca4880 (cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic)
  			powernv_states[nr_idle_states].enter = &nap_loop;
  			nr_idle_states++;
  		}
@@@ -225,9 -214,11 +232,17 @@@
  			/* Add FASTSLEEP state */
  			strcpy(powernv_states[nr_idle_states].name, "FastSleep");
  			strcpy(powernv_states[nr_idle_states].desc, "FastSleep");
++<<<<<<< HEAD
 +			powernv_states[nr_idle_states].flags =
 +				CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TIMER_STOP;
 +			powernv_states[nr_idle_states].target_residency = 300000;
++=======
+ 			powernv_states[nr_idle_states].flags = CPUIDLE_FLAG_TIMER_STOP;
+ 			powernv_states[nr_idle_states].exit_latency =
+ 					((unsigned int)latency_ns) / 1000;
+ 			powernv_states[nr_idle_states].target_residency =
+ 					((unsigned int)latency_ns / 100);
++>>>>>>> b82b6cca4880 (cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic)
  			powernv_states[nr_idle_states].enter = &fastsleep_loop;
  			nr_idle_states++;
  		}
diff --cc drivers/cpuidle/driver.c
index 3ac499d5a207,2697e87d5b34..000000000000
--- a/drivers/cpuidle/driver.c
+++ b/drivers/cpuidle/driver.c
@@@ -169,20 -168,46 +169,53 @@@ static int __cpuidle_driver_init(struc
  	/*
  	 * Look for the timer stop flag in the different states, so that we know
  	 * if the broadcast timer has to be set up.  The loop is in the reverse
 -	 * order, because usually one of the deeper states have this flag set.
 +	 * order, because usually on of the the deeper states has this flag set.
  	 */
  	for (i = drv->state_count - 1; i >= 0 ; i--) {
 -		if (drv->states[i].flags & CPUIDLE_FLAG_TIMER_STOP) {
 -			drv->bctimer = 1;
 -			break;
 -		}
 +
 +		if (!(drv->states[i].flags & CPUIDLE_FLAG_TIMER_STOP))
 +			continue;
 +
 +		drv->bctimer = 1;
 +		break;
  	}
 +
 +	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARCH_HAS_CPU_RELAX
+ static int poll_idle(struct cpuidle_device *dev,
+ 		struct cpuidle_driver *drv, int index)
+ {
+ 	local_irq_enable();
+ 	if (!current_set_polling_and_test()) {
+ 		while (!need_resched())
+ 			cpu_relax();
+ 	}
+ 	current_clr_polling();
+ 
+ 	return index;
+ }
+ 
+ static void poll_idle_init(struct cpuidle_driver *drv)
+ {
+ 	struct cpuidle_state *state = &drv->states[0];
+ 
+ 	snprintf(state->name, CPUIDLE_NAME_LEN, "POLL");
+ 	snprintf(state->desc, CPUIDLE_DESC_LEN, "CPUIDLE CORE POLL IDLE");
+ 	state->exit_latency = 0;
+ 	state->target_residency = 0;
+ 	state->power_usage = -1;
+ 	state->enter = poll_idle;
+ 	state->disabled = false;
+ }
+ #else
+ static void poll_idle_init(struct cpuidle_driver *drv) {}
+ #endif /* !CONFIG_ARCH_HAS_CPU_RELAX */
+ 
++>>>>>>> b82b6cca4880 (cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic)
  /**
   * __cpuidle_register_driver: register the driver
   * @drv: a valid pointer to a struct cpuidle_driver
diff --cc drivers/cpuidle/governors/menu.c
index 67fd901f6fc9,659d7b0c9ebf..000000000000
--- a/drivers/cpuidle/governors/menu.c
+++ b/drivers/cpuidle/governors/menu.c
@@@ -355,39 -385,49 +355,45 @@@ static void menu_reflect(struct cpuidle
   */
  static void menu_update(struct cpuidle_driver *drv, struct cpuidle_device *dev)
  {
 -	struct menu_device *data = this_cpu_ptr(&menu_devices);
 +	struct menu_device *data = &__get_cpu_var(menu_devices);
  	int last_idx = data->last_state_idx;
 +	unsigned int last_idle_us = cpuidle_get_last_residency(dev);
  	struct cpuidle_state *target = &drv->states[last_idx];
  	unsigned int measured_us;
 -	unsigned int new_factor;
 +	u64 new_factor;
  
  	/*
 -	 * Try to figure out how much time passed between entry to low
 -	 * power state and occurrence of the wakeup event.
 -	 *
 -	 * If the entered idle state didn't support residency measurements,
 -	 * we are basically lost in the dark how much time passed.
 -	 * As a compromise, assume we slept for the whole expected time.
 -	 *
 -	 * Any measured amount of time will include the exit latency.
 -	 * Since we are interested in when the wakeup begun, not when it
 -	 * was completed, we must subtract the exit latency. However, if
 -	 * the measured amount of time is less than the exit latency,
 -	 * assume the state was never reached and the exit latency is 0.
 +	 * Ugh, this idle state doesn't support residency measurements, so we
 +	 * are basically lost in the dark.  As a compromise, assume we slept
 +	 * for the whole expected time.
  	 */
++<<<<<<< HEAD
 +	if (unlikely(!(target->flags & CPUIDLE_FLAG_TIME_VALID)))
 +		last_idle_us = data->expected_us;
++=======
+ 	if (unlikely(target->flags & CPUIDLE_FLAG_TIME_INVALID)) {
+ 		/* Use timer value as is */
+ 		measured_us = data->next_timer_us;
++>>>>>>> b82b6cca4880 (cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic)
  
 -	} else {
 -		/* Use measured value */
 -		measured_us = cpuidle_get_last_residency(dev);
  
 -		/* Deduct exit latency */
 -		if (measured_us > target->exit_latency)
 -			measured_us -= target->exit_latency;
 +	measured_us = last_idle_us;
 +
 +	/*
 +	 * We correct for the exit latency; we are assuming here that the
 +	 * exit latency happens after the event that we're interested in.
 +	 */
 +	if (measured_us > data->exit_us)
 +		measured_us -= data->exit_us;
  
 -		/* Make sure our coefficients do not exceed unity */
 -		if (measured_us > data->next_timer_us)
 -			measured_us = data->next_timer_us;
 -	}
  
 -	/* Update our correction ratio */
 -	new_factor = data->correction_factor[data->bucket];
 -	new_factor -= new_factor / DECAY;
 +	/* update our correction ratio */
  
 -	if (data->next_timer_us > 0 && measured_us < MAX_INTERESTING)
 -		new_factor += RESOLUTION * measured_us / data->next_timer_us;
 +	new_factor = data->correction_factor[data->bucket]
 +			* (DECAY - 1) / DECAY;
 +
 +	if (data->expected_us > 0 && measured_us < MAX_INTERESTING)
 +		new_factor += RESOLUTION * measured_us / data->expected_us;
  	else
  		/*
  		 * we were idle so long that we count it as a perfect
diff --cc drivers/idle/intel_idle.c
index 36fafa7a7200,9cceacb92f9d..000000000000
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@@ -206,25 -206,32 +206,44 @@@ static struct cpuidle_state byt_cstates
  		.target_residency = 1,
  		.enter = &intel_idle },
  	{
++<<<<<<< HEAD
 +		.name = "C6N-BYT",
 +		.desc = "MWAIT 0x58",
 +		.flags = MWAIT2flg(0x58) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
 +		.exit_latency = 300,
++=======
+ 		.name = "C1E-BYT",
+ 		.desc = "MWAIT 0x01",
+ 		.flags = MWAIT2flg(0x01),
+ 		.exit_latency = 15,
+ 		.target_residency = 30,
+ 		.enter = &intel_idle },
+ 	{
+ 		.name = "C6N-BYT",
+ 		.desc = "MWAIT 0x58",
+ 		.flags = MWAIT2flg(0x58) | CPUIDLE_FLAG_TLB_FLUSHED,
+ 		.exit_latency = 40,
++>>>>>>> b82b6cca4880 (cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic)
  		.target_residency = 275,
  		.enter = &intel_idle },
  	{
  		.name = "C6S-BYT",
  		.desc = "MWAIT 0x52",
++<<<<<<< HEAD
 +		.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
 +		.exit_latency = 500,
++=======
+ 		.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TLB_FLUSHED,
+ 		.exit_latency = 140,
++>>>>>>> b82b6cca4880 (cpuidle: Invert CPUIDLE_FLAG_TIME_VALID logic)
  		.target_residency = 560,
  		.enter = &intel_idle },
  	{
  		.name = "C7-BYT",
  		.desc = "MWAIT 0x60",
- 		.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+ 		.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TLB_FLUSHED,
  		.exit_latency = 1200,
 -		.target_residency = 1500,
 +		.target_residency = 4000,
  		.enter = &intel_idle },
  	{
  		.name = "C7S-BYT",
* Unmerged path arch/arm/mach-imx/cpuidle-imx6sl.c
* Unmerged path drivers/cpuidle/cpuidle-arm64.c
* Unmerged path drivers/cpuidle/cpuidle-big_little.c
* Unmerged path drivers/cpuidle/cpuidle-cps.c
* Unmerged path drivers/cpuidle/cpuidle-exynos.c
* Unmerged path drivers/cpuidle/cpuidle-mvebu-v7.c
* Unmerged path drivers/cpuidle/cpuidle-zynq.c
* Unmerged path drivers/cpuidle/dt_idle_states.c
diff --git a/arch/arm/include/asm/cpuidle.h b/arch/arm/include/asm/cpuidle.h
index 2fca60ab513a..af319ac4960c 100644
--- a/arch/arm/include/asm/cpuidle.h
+++ b/arch/arm/include/asm/cpuidle.h
@@ -15,7 +15,6 @@ static inline int arm_cpuidle_simple_enter(struct cpuidle_device *dev,
 	.exit_latency           = 1,\
 	.target_residency       = 1,\
 	.power_usage		= p,\
-	.flags                  = CPUIDLE_FLAG_TIME_VALID,\
 	.name                   = "WFI",\
 	.desc                   = "ARM WFI",\
 }
* Unmerged path arch/arm/mach-at91/cpuidle.c
* Unmerged path arch/arm/mach-davinci/cpuidle.c
diff --git a/arch/arm/mach-imx/cpuidle-imx5.c b/arch/arm/mach-imx/cpuidle-imx5.c
index 5a47e3c6172f..3feca526d16b 100644
--- a/arch/arm/mach-imx/cpuidle-imx5.c
+++ b/arch/arm/mach-imx/cpuidle-imx5.c
@@ -24,7 +24,6 @@ static struct cpuidle_driver imx5_cpuidle_driver = {
 		.enter            = imx5_cpuidle_enter,
 		.exit_latency     = 2,
 		.target_residency = 1,
-		.flags            = CPUIDLE_FLAG_TIME_VALID,
 		.name             = "IMX5 SRPG",
 		.desc             = "CPU state retained,powered off",
 	},
diff --git a/arch/arm/mach-imx/cpuidle-imx6q.c b/arch/arm/mach-imx/cpuidle-imx6q.c
index 23ddfb693b2d..a127a9cd2ced 100644
--- a/arch/arm/mach-imx/cpuidle-imx6q.c
+++ b/arch/arm/mach-imx/cpuidle-imx6q.c
@@ -52,8 +52,7 @@ static struct cpuidle_driver imx6q_cpuidle_driver = {
 		{
 			.exit_latency = 50,
 			.target_residency = 75,
-			.flags = CPUIDLE_FLAG_TIME_VALID |
-			         CPUIDLE_FLAG_TIMER_STOP,
+			.flags = CPUIDLE_FLAG_TIMER_STOP,
 			.enter = imx6q_enter_wait,
 			.name = "WAIT",
 			.desc = "Clock off",
* Unmerged path arch/arm/mach-imx/cpuidle-imx6sl.c
diff --git a/arch/arm/mach-omap2/cpuidle34xx.c b/arch/arm/mach-omap2/cpuidle34xx.c
index e18709d3b95d..aa7b379e2661 100644
--- a/arch/arm/mach-omap2/cpuidle34xx.c
+++ b/arch/arm/mach-omap2/cpuidle34xx.c
@@ -265,7 +265,6 @@ static struct cpuidle_driver omap3_idle_driver = {
 			.enter		  = omap3_enter_idle_bm,
 			.exit_latency	  = 2 + 2,
 			.target_residency = 5,
-			.flags		  = CPUIDLE_FLAG_TIME_VALID,
 			.name		  = "C1",
 			.desc		  = "MPU ON + CORE ON",
 		},
@@ -273,7 +272,6 @@ static struct cpuidle_driver omap3_idle_driver = {
 			.enter		  = omap3_enter_idle_bm,
 			.exit_latency	  = 10 + 10,
 			.target_residency = 30,
-			.flags		  = CPUIDLE_FLAG_TIME_VALID,
 			.name		  = "C2",
 			.desc		  = "MPU ON + CORE ON",
 		},
@@ -281,7 +279,6 @@ static struct cpuidle_driver omap3_idle_driver = {
 			.enter		  = omap3_enter_idle_bm,
 			.exit_latency	  = 50 + 50,
 			.target_residency = 300,
-			.flags		  = CPUIDLE_FLAG_TIME_VALID,
 			.name		  = "C3",
 			.desc		  = "MPU RET + CORE ON",
 		},
@@ -289,7 +286,6 @@ static struct cpuidle_driver omap3_idle_driver = {
 			.enter		  = omap3_enter_idle_bm,
 			.exit_latency	  = 1500 + 1800,
 			.target_residency = 4000,
-			.flags		  = CPUIDLE_FLAG_TIME_VALID,
 			.name		  = "C4",
 			.desc		  = "MPU OFF + CORE ON",
 		},
@@ -297,7 +293,6 @@ static struct cpuidle_driver omap3_idle_driver = {
 			.enter		  = omap3_enter_idle_bm,
 			.exit_latency	  = 2500 + 7500,
 			.target_residency = 12000,
-			.flags		  = CPUIDLE_FLAG_TIME_VALID,
 			.name		  = "C5",
 			.desc		  = "MPU RET + CORE RET",
 		},
@@ -305,7 +300,6 @@ static struct cpuidle_driver omap3_idle_driver = {
 			.enter		  = omap3_enter_idle_bm,
 			.exit_latency	  = 3000 + 8500,
 			.target_residency = 15000,
-			.flags		  = CPUIDLE_FLAG_TIME_VALID,
 			.name		  = "C6",
 			.desc		  = "MPU OFF + CORE RET",
 		},
@@ -313,7 +307,6 @@ static struct cpuidle_driver omap3_idle_driver = {
 			.enter		  = omap3_enter_idle_bm,
 			.exit_latency	  = 10000 + 30000,
 			.target_residency = 30000,
-			.flags		  = CPUIDLE_FLAG_TIME_VALID,
 			.name		  = "C7",
 			.desc		  = "MPU OFF + CORE OFF",
 		},
* Unmerged path arch/arm/mach-omap2/cpuidle44xx.c
diff --git a/arch/arm/mach-s3c64xx/cpuidle.c b/arch/arm/mach-s3c64xx/cpuidle.c
index 3c8ab07c2012..2eb072440dfa 100644
--- a/arch/arm/mach-s3c64xx/cpuidle.c
+++ b/arch/arm/mach-s3c64xx/cpuidle.c
@@ -48,7 +48,6 @@ static struct cpuidle_driver s3c64xx_cpuidle_driver = {
 			.enter            = s3c64xx_enter_idle,
 			.exit_latency     = 1,
 			.target_residency = 1,
-			.flags            = CPUIDLE_FLAG_TIME_VALID,
 			.name             = "IDLE",
 			.desc             = "System active, ARM gated",
 		},
diff --git a/arch/arm/mach-shmobile/pm-sh7372.c b/arch/arm/mach-shmobile/pm-sh7372.c
index dec9293bb90d..9f24386a0114 100644
--- a/arch/arm/mach-shmobile/pm-sh7372.c
+++ b/arch/arm/mach-shmobile/pm-sh7372.c
@@ -418,7 +418,6 @@ static struct cpuidle_driver sh7372_cpuidle_driver = {
 		.desc = "Core Standby Mode",
 		.exit_latency = 10,
 		.target_residency = 20 + 10,
-		.flags = CPUIDLE_FLAG_TIME_VALID,
 		.enter = sh7372_enter_core_standby,
 	},
 	.states[2] = {
@@ -426,7 +425,6 @@ static struct cpuidle_driver sh7372_cpuidle_driver = {
 		.desc = "A3SM PLL ON",
 		.exit_latency = 20,
 		.target_residency = 30 + 20,
-		.flags = CPUIDLE_FLAG_TIME_VALID,
 		.enter = sh7372_enter_a3sm_pll_on,
 	},
 	.states[3] = {
@@ -434,7 +432,6 @@ static struct cpuidle_driver sh7372_cpuidle_driver = {
 		.desc = "A3SM PLL OFF",
 		.exit_latency = 120,
 		.target_residency = 30 + 120,
-		.flags = CPUIDLE_FLAG_TIME_VALID,
 		.enter = sh7372_enter_a3sm_pll_off,
 	},
 	.states[4] = {
@@ -442,7 +439,6 @@ static struct cpuidle_driver sh7372_cpuidle_driver = {
 		.desc = "A4S PLL OFF",
 		.exit_latency = 240,
 		.target_residency = 30 + 240,
-		.flags = CPUIDLE_FLAG_TIME_VALID,
 		.enter = sh7372_enter_a4s,
 		.disabled = true,
 	},
* Unmerged path arch/arm/mach-tegra/cpuidle-tegra114.c
diff --git a/arch/arm/mach-tegra/cpuidle-tegra20.c b/arch/arm/mach-tegra/cpuidle-tegra20.c
index 0cdba8de8c77..5f5c0c3c7679 100644
--- a/arch/arm/mach-tegra/cpuidle-tegra20.c
+++ b/arch/arm/mach-tegra/cpuidle-tegra20.c
@@ -59,8 +59,7 @@ static struct cpuidle_driver tegra_idle_driver = {
 			.exit_latency     = 5000,
 			.target_residency = 10000,
 			.power_usage      = 0,
-			.flags            = CPUIDLE_FLAG_TIME_VALID |
-			CPUIDLE_FLAG_COUPLED,
+			.flags            = CPUIDLE_FLAG_COUPLED,
 			.name             = "powered-down",
 			.desc             = "CPU power gated",
 		},
diff --git a/arch/arm/mach-tegra/cpuidle-tegra30.c b/arch/arm/mach-tegra/cpuidle-tegra30.c
index 3cf9aca5f3ea..13142be8cfb4 100644
--- a/arch/arm/mach-tegra/cpuidle-tegra30.c
+++ b/arch/arm/mach-tegra/cpuidle-tegra30.c
@@ -56,7 +56,6 @@ static struct cpuidle_driver tegra_idle_driver = {
 			.exit_latency		= 2000,
 			.target_residency	= 2200,
 			.power_usage		= 0,
-			.flags			= CPUIDLE_FLAG_TIME_VALID,
 			.name			= "powered-down",
 			.desc			= "CPU power gated",
 		},
diff --git a/arch/arm/mach-ux500/cpuidle.c b/arch/arm/mach-ux500/cpuidle.c
index a45dd09daed9..dc602aa4ed73 100644
--- a/arch/arm/mach-ux500/cpuidle.c
+++ b/arch/arm/mach-ux500/cpuidle.c
@@ -103,8 +103,7 @@ static struct cpuidle_driver ux500_idle_driver = {
 			.enter		  = ux500_enter_idle,
 			.exit_latency	  = 70,
 			.target_residency = 260,
-			.flags		  = CPUIDLE_FLAG_TIME_VALID |
-			                    CPUIDLE_FLAG_TIMER_STOP,
+			.flags		  = CPUIDLE_FLAG_TIMER_STOP,
 			.name		  = "ApIdle",
 			.desc		  = "ARM Retention",
 		},
* Unmerged path arch/mips/include/asm/idle.h
diff --git a/arch/sh/kernel/cpu/shmobile/cpuidle.c b/arch/sh/kernel/cpu/shmobile/cpuidle.c
index d30622592116..34ac98d4e094 100644
--- a/arch/sh/kernel/cpu/shmobile/cpuidle.c
+++ b/arch/sh/kernel/cpu/shmobile/cpuidle.c
@@ -59,7 +59,6 @@ static struct cpuidle_driver cpuidle_driver = {
 			.exit_latency = 1,
 			.target_residency = 1 * 2,
 			.power_usage = 3,
-			.flags = CPUIDLE_FLAG_TIME_VALID,
 			.enter = cpuidle_sleep_enter,
 			.name = "C1",
 			.desc = "SuperH Sleep Mode",
@@ -68,7 +67,6 @@ static struct cpuidle_driver cpuidle_driver = {
 			.exit_latency = 100,
 			.target_residency = 1 * 2,
 			.power_usage = 1,
-			.flags = CPUIDLE_FLAG_TIME_VALID,
 			.enter = cpuidle_sleep_enter,
 			.name = "C2",
 			.desc = "SuperH Sleep Mode [SF]",
@@ -78,7 +76,6 @@ static struct cpuidle_driver cpuidle_driver = {
 			.exit_latency = 2300,
 			.target_residency = 1 * 2,
 			.power_usage = 1,
-			.flags = CPUIDLE_FLAG_TIME_VALID,
 			.enter = cpuidle_sleep_enter,
 			.name = "C3",
 			.desc = "SuperH Mobile Standby Mode [SF]",
diff --git a/arch/x86/kernel/apm_32.c b/arch/x86/kernel/apm_32.c
index 8fdcec62d713..d109fecf64c5 100644
--- a/arch/x86/kernel/apm_32.c
+++ b/arch/x86/kernel/apm_32.c
@@ -378,7 +378,6 @@ static struct cpuidle_driver apm_idle_driver = {
 		{ /* entry 1 is for APM idle */
 			.name = "APM",
 			.desc = "APM idle",
-			.flags = CPUIDLE_FLAG_TIME_VALID,
 			.exit_latency = 250,	/* WAG */
 			.target_residency = 500,	/* WAG */
 			.enter = &apm_cpu_idle
diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
index 0a522c65c418..c0c213092838 100644
--- a/drivers/acpi/processor_idle.c
+++ b/drivers/acpi/processor_idle.c
@@ -991,8 +991,8 @@ static int acpi_processor_setup_cpuidle_states(struct acpi_processor *pr)
 		state->flags = 0;
 		switch (cx->type) {
 			case ACPI_STATE_C1:
-			if (cx->entry_method == ACPI_CSTATE_FFH)
-				state->flags |= CPUIDLE_FLAG_TIME_VALID;
+			if (cx->entry_method != ACPI_CSTATE_FFH)
+				state->flags |= CPUIDLE_FLAG_TIME_INVALID;
 
 			state->enter = acpi_idle_enter_c1;
 			state->enter_dead = acpi_idle_play_dead;
@@ -1000,14 +1000,12 @@ static int acpi_processor_setup_cpuidle_states(struct acpi_processor *pr)
 			break;
 
 			case ACPI_STATE_C2:
-			state->flags |= CPUIDLE_FLAG_TIME_VALID;
 			state->enter = acpi_idle_enter_simple;
 			state->enter_dead = acpi_idle_play_dead;
 			drv->safe_state_index = count;
 			break;
 
 			case ACPI_STATE_C3:
-			state->flags |= CPUIDLE_FLAG_TIME_VALID;
 			state->enter = pr->flags.bm_check ?
 					acpi_idle_enter_bm :
 					acpi_idle_enter_simple;
* Unmerged path drivers/cpuidle/cpuidle-arm64.c
* Unmerged path drivers/cpuidle/cpuidle-big_little.c
diff --git a/drivers/cpuidle/cpuidle-calxeda.c b/drivers/cpuidle/cpuidle-calxeda.c
index 223379169cb0..d0026d114b10 100644
--- a/drivers/cpuidle/cpuidle-calxeda.c
+++ b/drivers/cpuidle/cpuidle-calxeda.c
@@ -92,7 +92,6 @@ static struct cpuidle_driver calxeda_idle_driver = {
 		{
 			.name = "PG",
 			.desc = "Power Gate",
-			.flags = CPUIDLE_FLAG_TIME_VALID,
 			.exit_latency = 30,
 			.power_usage = 50,
 			.target_residency = 200,
* Unmerged path drivers/cpuidle/cpuidle-cps.c
* Unmerged path drivers/cpuidle/cpuidle-exynos.c
diff --git a/drivers/cpuidle/cpuidle-kirkwood.c b/drivers/cpuidle/cpuidle-kirkwood.c
index 521b0a7fdd89..ae09456a5792 100644
--- a/drivers/cpuidle/cpuidle-kirkwood.c
+++ b/drivers/cpuidle/cpuidle-kirkwood.c
@@ -47,7 +47,6 @@ static struct cpuidle_driver kirkwood_idle_driver = {
 		.enter			= kirkwood_enter_idle,
 		.exit_latency		= 10,
 		.target_residency	= 100000,
-		.flags			= CPUIDLE_FLAG_TIME_VALID,
 		.name			= "DDR SR",
 		.desc			= "WFI and DDR Self Refresh",
 	},
* Unmerged path drivers/cpuidle/cpuidle-mvebu-v7.c
* Unmerged path drivers/cpuidle/cpuidle-powernv.c
diff --git a/drivers/cpuidle/cpuidle-pseries.c b/drivers/cpuidle/cpuidle-pseries.c
index 287020fbdcf7..06ef0e41053f 100644
--- a/drivers/cpuidle/cpuidle-pseries.c
+++ b/drivers/cpuidle/cpuidle-pseries.c
@@ -145,14 +145,12 @@ static struct cpuidle_state dedicated_states[] = {
 	{ /* Snooze */
 		.name = "snooze",
 		.desc = "snooze",
-		.flags = CPUIDLE_FLAG_TIME_VALID,
 		.exit_latency = 0,
 		.target_residency = 0,
 		.enter = &snooze_loop },
 	{ /* CEDE */
 		.name = "CEDE",
 		.desc = "CEDE",
-		.flags = CPUIDLE_FLAG_TIME_VALID,
 		.exit_latency = 10,
 		.target_residency = 100,
 		.enter = &dedicated_cede_loop },
@@ -165,7 +163,6 @@ static struct cpuidle_state shared_states[] = {
 	{ /* Shared Cede */
 		.name = "Shared Cede",
 		.desc = "Shared Cede",
-		.flags = CPUIDLE_FLAG_TIME_VALID,
 		.exit_latency = 0,
 		.target_residency = 0,
 		.enter = &shared_cede_loop },
* Unmerged path drivers/cpuidle/cpuidle-zynq.c
* Unmerged path drivers/cpuidle/driver.c
* Unmerged path drivers/cpuidle/dt_idle_states.c
diff --git a/drivers/cpuidle/governors/ladder.c b/drivers/cpuidle/governors/ladder.c
index 9b784051ec12..6e914d072f88 100644
--- a/drivers/cpuidle/governors/ladder.c
+++ b/drivers/cpuidle/governors/ladder.c
@@ -79,7 +79,7 @@ static int ladder_select_state(struct cpuidle_driver *drv,
 
 	last_state = &ldev->states[last_idx];
 
-	if (drv->states[last_idx].flags & CPUIDLE_FLAG_TIME_VALID) {
+	if (!(drv->states[last_idx].flags & CPUIDLE_FLAG_TIME_INVALID)) {
 		last_residency = cpuidle_get_last_residency(dev) - \
 					 drv->states[last_idx].exit_latency;
 	}
* Unmerged path drivers/cpuidle/governors/menu.c
* Unmerged path drivers/idle/intel_idle.c
diff --git a/include/linux/cpuidle.h b/include/linux/cpuidle.h
index 0bc4b74668e9..9bd9bae0c305 100644
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@ -55,7 +55,7 @@ struct cpuidle_state {
 };
 
 /* Idle State Flags */
-#define CPUIDLE_FLAG_TIME_VALID	(0x01) /* is residency time measurable? */
+#define CPUIDLE_FLAG_TIME_INVALID	(0x01) /* is residency time measurable? */
 #define CPUIDLE_FLAG_COUPLED	(0x02) /* state applies to multiple cpus */
 #define CPUIDLE_FLAG_TIMER_STOP (0x04)  /* timer is stopped on this state */
 
@@ -88,7 +88,7 @@ DECLARE_PER_CPU(struct cpuidle_device *, cpuidle_devices);
  * cpuidle_get_last_residency - retrieves the last state's residency time
  * @dev: the target CPU
  *
- * NOTE: this value is invalid if CPUIDLE_FLAG_TIME_VALID isn't set
+ * NOTE: this value is invalid if CPUIDLE_FLAG_TIME_INVALID is set
  */
 static inline int cpuidle_get_last_residency(struct cpuidle_device *dev)
 {
