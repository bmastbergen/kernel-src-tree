net: fix HAVE_EFFICIENT_UNALIGNED_ACCESS typos

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] fix HAVE_EFFICIENT_UNALIGNED_ACCESS typos (Ivan Vecera) [1382040]
Rebuild_FUZZ: 94.25%
commit-author Eric Dumazet <edumazet@google.com>
commit cca1d81574d266d4a3aa33f3947297564525e127
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/cca1d815.failed

HAVE_EFFICIENT_UNALIGNED_ACCESS needs CONFIG_ prefix.

Also add a comment in nla_align_64bit() explaining we have
to add a padding if current skb->data is aligned, as it
certainly can be confusing.

Fixes: 35c5845957c7 ("net: Add helpers for 64-bit aligning netlink attributes.")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cca1d81574d266d4a3aa33f3947297564525e127)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netlink.h
diff --cc include/net/netlink.h
index a6619d807a58,cf95df1fa14b..000000000000
--- a/include/net/netlink.h
+++ b/include/net/netlink.h
@@@ -1229,6 -1231,46 +1229,49 @@@ static inline int nla_validate_nested(c
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * nla_align_64bit - 64-bit align the nla_data() of next attribute
+  * @skb: socket buffer the message is stored in
+  * @padattr: attribute type for the padding
+  *
+  * Conditionally emit a padding netlink attribute in order to make
+  * the next attribute we emit have a 64-bit aligned nla_data() area.
+  * This will only be done in architectures which do not have
+  * CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS defined.
+  *
+  * Returns zero on success or a negative error code.
+  */
+ static inline int nla_align_64bit(struct sk_buff *skb, int padattr)
+ {
+ #ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+ 	/* The nlattr header is 4 bytes in size, that's why we test
+ 	 * if the skb->data _is_ aligned.  This NOP attribute, plus
+ 	 * nlattr header for next attribute, will make nla_data()
+ 	 * 8-byte aligned.
+ 	 */
+ 	if (IS_ALIGNED((unsigned long)skb->data, 8) &&
+ 	    !nla_reserve(skb, padattr, 0))
+ 		return -EMSGSIZE;
+ #endif
+ 	return 0;
+ }
+ 
+ /**
+  * nla_total_size_64bit - total length of attribute including padding
+  * @payload: length of payload
+  */
+ static inline int nla_total_size_64bit(int payload)
+ {
+ 	return NLA_ALIGN(nla_attr_size(payload))
+ #ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+ 		+ NLA_ALIGN(nla_attr_size(0))
+ #endif
+ 		;
+ }
+ 
+ /**
++>>>>>>> cca1d81574d2 (net: fix HAVE_EFFICIENT_UNALIGNED_ACCESS typos)
   * nla_for_each_attr - iterate over a stream of attributes
   * @pos: loop counter, set to current attribute
   * @head: head of attribute stream
* Unmerged path include/net/netlink.h
