RDS: TCP: make ->sk_user_data point to a rds_conn_path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Sowmini Varadhan <sowmini.varadhan@oracle.com>
commit ea3b1ea53930879c9847044f5cb9c97411cae797
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ea3b1ea5.failed

The socket callbacks should all operate on a struct rds_conn_path,
in preparation for a MP capable RDS-TCP.

	Acked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>
	Signed-off-by: Sowmini Varadhan <sowmini.varadhan@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ea3b1ea53930879c9847044f5cb9c97411cae797)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/rds/tcp.c
#	net/rds/tcp_connect.c
#	net/rds/tcp_listen.c
#	net/rds/tcp_recv.c
#	net/rds/tcp_send.c
diff --cc net/rds/tcp.c
index 5ea4c0469433,5658f3e9f601..000000000000
--- a/net/rds/tcp.c
+++ b/net/rds/tcp.c
@@@ -185,7 -186,7 +185,11 @@@ void rds_tcp_reset_callbacks(struct soc
  	release_sock(osock->sk);
  	sock_release(osock);
  newsock:
++<<<<<<< HEAD
 +	rds_send_reset(conn);
++=======
+ 	rds_send_path_reset(cp);
++>>>>>>> ea3b1ea53930 (RDS: TCP: make ->sk_user_data point to a rds_conn_path)
  	lock_sock(sock->sk);
  	write_lock_bh(&sock->sk->sk_callback_lock);
  	tc->t_sock = sock;
@@@ -220,7 -222,7 +225,11 @@@ void rds_tcp_set_callbacks(struct socke
  		sock->sk->sk_data_ready = sock->sk->sk_user_data;
  
  	tc->t_sock = sock;
++<<<<<<< HEAD
 +	tc->conn = conn;
++=======
+ 	tc->t_cpath = cp;
++>>>>>>> ea3b1ea53930 (RDS: TCP: make ->sk_user_data point to a rds_conn_path)
  	tc->t_orig_data_ready = sock->sk->sk_data_ready;
  	tc->t_orig_write_space = sock->sk->sk_write_space;
  	tc->t_orig_state_change = sock->sk->sk_state_change;
diff --cc net/rds/tcp_connect.c
index a86fb96b1ae0,7eddce50e7a3..000000000000
--- a/net/rds/tcp_connect.c
+++ b/net/rds/tcp_connect.c
@@@ -40,12 -41,12 +40,18 @@@
  void rds_tcp_state_change(struct sock *sk)
  {
  	void (*state_change)(struct sock *sk);
- 	struct rds_connection *conn;
+ 	struct rds_conn_path *cp;
  	struct rds_tcp_connection *tc;
  
++<<<<<<< HEAD
 +	read_lock(&sk->sk_callback_lock);
 +	conn = sk->sk_user_data;
 +	if (!conn) {
++=======
+ 	read_lock_bh(&sk->sk_callback_lock);
+ 	cp = sk->sk_user_data;
+ 	if (!cp) {
++>>>>>>> ea3b1ea53930 (RDS: TCP: make ->sk_user_data point to a rds_conn_path)
  		state_change = sk->sk_state_change;
  		goto out;
  	}
@@@ -54,22 -55,22 +60,38 @@@
  
  	rdsdebug("sock %p state_change to %d\n", tc->t_sock, sk->sk_state);
  
++<<<<<<< HEAD
 +	switch(sk->sk_state) {
 +		/* ignore connecting sockets as they make progress */
 +		case TCP_SYN_SENT:
 +		case TCP_SYN_RECV:
 +			break;
 +		case TCP_ESTABLISHED:
 +			rds_connect_path_complete(conn, RDS_CONN_CONNECTING);
 +			break;
 +		case TCP_CLOSE_WAIT:
 +		case TCP_CLOSE:
 +			rds_conn_drop(conn);
 +		default:
 +			break;
++=======
+ 	switch (sk->sk_state) {
+ 	/* ignore connecting sockets as they make progress */
+ 	case TCP_SYN_SENT:
+ 	case TCP_SYN_RECV:
+ 		break;
+ 	case TCP_ESTABLISHED:
+ 		rds_connect_path_complete(cp, RDS_CONN_CONNECTING);
+ 		break;
+ 	case TCP_CLOSE_WAIT:
+ 	case TCP_CLOSE:
+ 		rds_conn_path_drop(cp);
+ 	default:
+ 		break;
++>>>>>>> ea3b1ea53930 (RDS: TCP: make ->sk_user_data point to a rds_conn_path)
  	}
  out:
 -	read_unlock_bh(&sk->sk_callback_lock);
 +	read_unlock(&sk->sk_callback_lock);
  	state_change(sk);
  }
  
@@@ -79,11 -80,12 +101,12 @@@ int rds_tcp_conn_connect(struct rds_con
  	struct sockaddr_in src, dest;
  	int ret;
  	struct rds_tcp_connection *tc = conn->c_transport_data;
+ 	struct rds_conn_path *cp = &conn->c_path[0];
  
 -	mutex_lock(&tc->t_conn_path_lock);
 +	mutex_lock(&tc->t_conn_lock);
  
  	if (rds_conn_up(conn)) {
 -		mutex_unlock(&tc->t_conn_path_lock);
 +		mutex_unlock(&tc->t_conn_lock);
  		return 0;
  	}
  	ret = sock_create_kern(rds_conn_net(conn), PF_INET,
diff --cc net/rds/tcp_listen.c
index b4b70bcb5e05,ca975a217a49..000000000000
--- a/net/rds/tcp_listen.c
+++ b/net/rds/tcp_listen.c
@@@ -119,8 -121,9 +120,9 @@@ int rds_tcp_accept_one(struct socket *s
  	 * rds_tcp_state_change() will do that cleanup
  	 */
  	rs_tcp = (struct rds_tcp_connection *)conn->c_transport_data;
+ 	cp = &conn->c_path[0];
  	rds_conn_transition(conn, RDS_CONN_DOWN, RDS_CONN_CONNECTING);
 -	mutex_lock(&rs_tcp->t_conn_path_lock);
 +	mutex_lock(&rs_tcp->t_conn_lock);
  	conn_state = rds_conn_state(conn);
  	if (conn_state != RDS_CONN_CONNECTING && conn_state != RDS_CONN_UP)
  		goto rst_nsk;
@@@ -132,17 -135,17 +134,28 @@@
  		 * c_transport_data.
  		 */
  		if (ntohl(inet->inet_saddr) < ntohl(inet->inet_daddr) ||
 -		    !conn->c_path[0].cp_outgoing) {
 +		    !conn->c_outgoing) {
  			goto rst_nsk;
  		} else {
++<<<<<<< HEAD
 +			rds_tcp_reset_callbacks(new_sock, conn);
 +			conn->c_outgoing = 0;
 +			/* rds_connect_path_complete() marks RDS_CONN_UP */
 +			rds_connect_path_complete(conn, RDS_CONN_RESETTING);
 +		}
 +	} else {
 +		rds_tcp_set_callbacks(new_sock, conn);
 +		rds_connect_path_complete(conn, RDS_CONN_CONNECTING);
++=======
+ 			rds_tcp_reset_callbacks(new_sock, cp);
+ 			conn->c_path[0].cp_outgoing = 0;
+ 			/* rds_connect_path_complete() marks RDS_CONN_UP */
+ 			rds_connect_path_complete(cp, RDS_CONN_RESETTING);
+ 		}
+ 	} else {
+ 		rds_tcp_set_callbacks(new_sock, cp);
+ 		rds_connect_path_complete(cp, RDS_CONN_CONNECTING);
++>>>>>>> ea3b1ea53930 (RDS: TCP: make ->sk_user_data point to a rds_conn_path)
  	}
  	new_sock = NULL;
  	ret = 0;
diff --cc net/rds/tcp_recv.c
index 288a3c443bdf,aa7a79a00ef7..000000000000
--- a/net/rds/tcp_recv.c
+++ b/net/rds/tcp_recv.c
@@@ -313,17 -294,17 +313,28 @@@ int rds_tcp_recv(struct rds_connection 
  	return ret;
  }
  
 -void rds_tcp_data_ready(struct sock *sk)
 +void rds_tcp_data_ready(struct sock *sk, int bytes)
  {
++<<<<<<< HEAD
 +	void (*ready)(struct sock *sk, int bytes);
 +	struct rds_connection *conn;
++=======
+ 	void (*ready)(struct sock *sk);
+ 	struct rds_conn_path *cp;
++>>>>>>> ea3b1ea53930 (RDS: TCP: make ->sk_user_data point to a rds_conn_path)
  	struct rds_tcp_connection *tc;
  
 -	rdsdebug("data ready sk %p\n", sk);
 +	rdsdebug("data ready sk %p bytes %d\n", sk, bytes);
  
++<<<<<<< HEAD
 +	read_lock(&sk->sk_callback_lock);
 +	conn = sk->sk_user_data;
 +	if (!conn) { /* check for teardown race */
++=======
+ 	read_lock_bh(&sk->sk_callback_lock);
+ 	cp = sk->sk_user_data;
+ 	if (!cp) { /* check for teardown race */
++>>>>>>> ea3b1ea53930 (RDS: TCP: make ->sk_user_data point to a rds_conn_path)
  		ready = sk->sk_data_ready;
  		goto out;
  	}
@@@ -332,11 -313,11 +343,11 @@@
  	ready = tc->t_orig_data_ready;
  	rds_tcp_stats_inc(s_tcp_data_ready_calls);
  
- 	if (rds_tcp_read_sock(conn, GFP_ATOMIC) == -ENOMEM)
- 		queue_delayed_work(rds_wq, &conn->c_recv_w, 0);
+ 	if (rds_tcp_read_sock(cp->cp_conn, GFP_ATOMIC) == -ENOMEM)
+ 		queue_delayed_work(rds_wq, &cp->cp_recv_w, 0);
  out:
 -	read_unlock_bh(&sk->sk_callback_lock);
 -	ready(sk);
 +	read_unlock(&sk->sk_callback_lock);
 +	ready(sk, bytes);
  }
  
  int rds_tcp_recv_init(void)
diff --cc net/rds/tcp_send.c
index 4be8e6261b9f,57e0f5826406..000000000000
--- a/net/rds/tcp_send.c
+++ b/net/rds/tcp_send.c
@@@ -177,12 -178,12 +177,18 @@@ static int rds_tcp_is_acked(struct rds_
  void rds_tcp_write_space(struct sock *sk)
  {
  	void (*write_space)(struct sock *sk);
- 	struct rds_connection *conn;
+ 	struct rds_conn_path *cp;
  	struct rds_tcp_connection *tc;
  
++<<<<<<< HEAD
 +	read_lock(&sk->sk_callback_lock);
 +	conn = sk->sk_user_data;
 +	if (!conn) {
++=======
+ 	read_lock_bh(&sk->sk_callback_lock);
+ 	cp = sk->sk_user_data;
+ 	if (!cp) {
++>>>>>>> ea3b1ea53930 (RDS: TCP: make ->sk_user_data point to a rds_conn_path)
  		write_space = sk->sk_write_space;
  		goto out;
  	}
@@@ -194,13 -195,13 +200,18 @@@
  
  	rdsdebug("tcp una %u\n", rds_tcp_snd_una(tc));
  	tc->t_last_seen_una = rds_tcp_snd_una(tc);
- 	rds_send_drop_acked(conn, rds_tcp_snd_una(tc), rds_tcp_is_acked);
+ 	rds_send_path_drop_acked(cp, rds_tcp_snd_una(tc), rds_tcp_is_acked);
  
++<<<<<<< HEAD
 +        if ((atomic_read(&sk->sk_wmem_alloc) << 1) <= sk->sk_sndbuf)
 +		queue_delayed_work(rds_wq, &conn->c_send_w, 0);
++=======
+ 	if ((atomic_read(&sk->sk_wmem_alloc) << 1) <= sk->sk_sndbuf)
+ 		queue_delayed_work(rds_wq, &cp->cp_send_w, 0);
++>>>>>>> ea3b1ea53930 (RDS: TCP: make ->sk_user_data point to a rds_conn_path)
  
  out:
 -	read_unlock_bh(&sk->sk_callback_lock);
 +	read_unlock(&sk->sk_callback_lock);
  
  	/*
  	 * write_space is only called when data leaves tcp's send queue if
* Unmerged path net/rds/tcp.c
diff --git a/net/rds/tcp.h b/net/rds/tcp.h
index 3949f2d1c41c..083d0137c220 100644
--- a/net/rds/tcp.h
+++ b/net/rds/tcp.h
@@ -49,8 +49,8 @@ struct rds_tcp_statistics {
 /* tcp.c */
 void rds_tcp_tune(struct socket *sock);
 void rds_tcp_nonagle(struct socket *sock);
-void rds_tcp_set_callbacks(struct socket *sock, struct rds_connection *conn);
-void rds_tcp_reset_callbacks(struct socket *sock, struct rds_connection *conn);
+void rds_tcp_set_callbacks(struct socket *sock, struct rds_conn_path *cp);
+void rds_tcp_reset_callbacks(struct socket *sock, struct rds_conn_path *cp);
 void rds_tcp_restore_callbacks(struct socket *sock,
 			       struct rds_tcp_connection *tc);
 u32 rds_tcp_snd_nxt(struct rds_tcp_connection *tc);
* Unmerged path net/rds/tcp_connect.c
* Unmerged path net/rds/tcp_listen.c
* Unmerged path net/rds/tcp_recv.c
* Unmerged path net/rds/tcp_send.c
