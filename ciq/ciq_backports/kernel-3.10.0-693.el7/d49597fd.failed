x86/cpu: Deal with broken firmware (VMWare/XEN)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Thomas Gleixner <tglx@linutronix.de>
commit d49597fd3bc7d9534de55e9256767f073be1b33a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d49597fd.failed

Both ACPI and MP specifications require that the APIC id in the respective
tables must be the same as the APIC id in CPUID.

The kernel retrieves the physical package id from the APIC id during the
ACPI/MP table scan and builds the physical to logical package map. The
physical package id which is used after a CPU comes up is retrieved from
CPUID. So we rely on ACPI/MP tables and CPUID agreeing in that respect.

There exist VMware and XEN implementations which violate the spec. As a
result the physical to logical package map, which relies on the ACPI/MP
tables does not work on those systems, because the CPUID initialized
physical package id does not match the firmware id. This causes system
crashes and malfunction due to invalid package mappings.

The only way to cure this is to sanitize the physical package id after the
CPUID enumeration and yell when the APIC ids are different. Fix up the
initial APIC id, which is fine as it is only used printout purposes.

If the physical package IDs differ yell and use the package information
from the ACPI/MP tables so the existing logical package map just works.

Chas provided the resulting dmesg output for his affected 4 virtual
sockets, 1 core per socket VM:

[Firmware Bug]: CPU1: APIC id mismatch. Firmware: 1 CPUID: 2
[Firmware Bug]: CPU1: Using firmware package id 1 instead of 2
....

Reported-and-tested-by: "Charles (Chas) Williams" <ciwillia@brocade.com>,
	Reported-by: M. Vefa Bicakci <m.v.b@runbox.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Alok Kataria <akataria@vmware.com>
	Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Cc: #4.6+ <stable@vger,kernel.org>
Link: http://lkml.kernel.org/r/alpine.DEB.2.20.1611091613540.3501@nanos
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit d49597fd3bc7d9534de55e9256767f073be1b33a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/common.c
diff --cc arch/x86/kernel/cpu/common.c
index d805b498a12b,cc9e980c68ec..000000000000
--- a/arch/x86/kernel/cpu/common.c
+++ b/arch/x86/kernel/cpu/common.c
@@@ -1028,18 -1132,40 +1057,22 @@@ static void identify_cpu(struct cpuinfo
  #ifdef CONFIG_NUMA
  	numa_add_cpu(smp_processor_id());
  #endif
++<<<<<<< HEAD
 +	/* The boot/hotplug time assigment got cleared, restore it */
 +	rh_c->logical_proc_id = topology_phys_to_logical_pkg(c->phys_proc_id);
 +
++=======
+ 	sanitize_package_id(c);
++>>>>>>> d49597fd3bc7 (x86/cpu: Deal with broken firmware (VMWare/XEN))
  }
  
 -/*
 - * Set up the CPU state needed to execute SYSENTER/SYSEXIT instructions
 - * on 32-bit kernels:
 - */
 -#ifdef CONFIG_X86_32
 -void enable_sep_cpu(void)
 +#ifdef CONFIG_X86_64
 +static void vgetcpu_set_mode(void)
  {
 -	struct tss_struct *tss;
 -	int cpu;
 -
 -	if (!boot_cpu_has(X86_FEATURE_SEP))
 -		return;
 -
 -	cpu = get_cpu();
 -	tss = &per_cpu(cpu_tss, cpu);
 -
 -	/*
 -	 * We cache MSR_IA32_SYSENTER_CS's value in the TSS's ss1 field --
 -	 * see the big comment in struct x86_hw_tss's definition.
 -	 */
 -
 -	tss->x86_tss.ss1 = __KERNEL_CS;
 -	wrmsr(MSR_IA32_SYSENTER_CS, tss->x86_tss.ss1, 0);
 -
 -	wrmsr(MSR_IA32_SYSENTER_ESP,
 -	      (unsigned long)tss + offsetofend(struct tss_struct, SYSENTER_stack),
 -	      0);
 -
 -	wrmsr(MSR_IA32_SYSENTER_EIP, (unsigned long)entry_SYSENTER_32, 0);
 -
 -	put_cpu();
 +	if (cpu_has(&boot_cpu_data, X86_FEATURE_RDTSCP))
 +		vgetcpu_mode = VGETCPU_RDTSCP;
 +	else
 +		vgetcpu_mode = VGETCPU_LSL;
  }
  #endif
  
* Unmerged path arch/x86/kernel/cpu/common.c
