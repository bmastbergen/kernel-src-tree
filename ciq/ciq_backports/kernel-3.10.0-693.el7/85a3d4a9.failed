net: bridge: don't increment tx_dropped in br_do_proxy_arp

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] bridge: don't increment tx_dropped in br_do_proxy_arp (Ivan Vecera) [1352289]
Rebuild_FUZZ: 95.50%
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit 85a3d4a9356b595d5440c3f1bf07ee7cecca1567
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/85a3d4a9.failed

pskb_may_pull may fail due to various reasons (e.g. alloc failure), but the
skb isn't changed/dropped and processing continues so we shouldn't
increment tx_dropped.

CC: Kyeyoon Park <kyeyoonp@codeaurora.org>
CC: Roopa Prabhu <roopa@cumulusnetworks.com>
CC: Stephen Hemminger <stephen@networkplumber.org>
CC: bridge@lists.linux-foundation.org
Fixes: 958501163ddd ("bridge: Add support for IEEE 802.11 Proxy ARP")
	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 85a3d4a9356b595d5440c3f1bf07ee7cecca1567)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_input.c
diff --cc net/bridge/br_input.c
index ca978d06eb18,abe11f085479..000000000000
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@@ -49,13 -57,72 +49,75 @@@ static int br_pass_frame_up(struct sk_b
  
  	indev = skb->dev;
  	skb->dev = brdev;
 -	skb = br_handle_vlan(br, vg, skb);
 +	skb = br_handle_vlan(br, pv, skb);
  	if (!skb)
  		return NET_RX_DROP;
 -	/* update the multicast stats if the packet is IGMP/MLD */
 -	br_multicast_count(br, NULL, skb, br_multicast_igmp_type(skb),
 -			   BR_MCAST_DIR_TX);
  
++<<<<<<< HEAD
 +	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, NULL, skb,
 +		       indev, NULL,
 +		       netif_receive_skb_sk);
++=======
+ 	return NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,
+ 		       dev_net(indev), NULL, skb, indev, NULL,
+ 		       br_netif_receive_skb);
+ }
+ 
+ static void br_do_proxy_arp(struct sk_buff *skb, struct net_bridge *br,
+ 			    u16 vid, struct net_bridge_port *p)
+ {
+ 	struct net_device *dev = br->dev;
+ 	struct neighbour *n;
+ 	struct arphdr *parp;
+ 	u8 *arpptr, *sha;
+ 	__be32 sip, tip;
+ 
+ 	BR_INPUT_SKB_CB(skb)->proxyarp_replied = false;
+ 
+ 	if ((dev->flags & IFF_NOARP) ||
+ 	    !pskb_may_pull(skb, arp_hdr_len(dev)))
+ 		return;
+ 
+ 	parp = arp_hdr(skb);
+ 
+ 	if (parp->ar_pro != htons(ETH_P_IP) ||
+ 	    parp->ar_op != htons(ARPOP_REQUEST) ||
+ 	    parp->ar_hln != dev->addr_len ||
+ 	    parp->ar_pln != 4)
+ 		return;
+ 
+ 	arpptr = (u8 *)parp + sizeof(struct arphdr);
+ 	sha = arpptr;
+ 	arpptr += dev->addr_len;	/* sha */
+ 	memcpy(&sip, arpptr, sizeof(sip));
+ 	arpptr += sizeof(sip);
+ 	arpptr += dev->addr_len;	/* tha */
+ 	memcpy(&tip, arpptr, sizeof(tip));
+ 
+ 	if (ipv4_is_loopback(tip) ||
+ 	    ipv4_is_multicast(tip))
+ 		return;
+ 
+ 	n = neigh_lookup(&arp_tbl, &tip, dev);
+ 	if (n) {
+ 		struct net_bridge_fdb_entry *f;
+ 
+ 		if (!(n->nud_state & NUD_VALID)) {
+ 			neigh_release(n);
+ 			return;
+ 		}
+ 
+ 		f = __br_fdb_get(br, n->ha, vid);
+ 		if (f && ((p->flags & BR_PROXYARP) ||
+ 			  (f->dst && (f->dst->flags & BR_PROXYARP_WIFI)))) {
+ 			arp_send(ARPOP_REPLY, ETH_P_ARP, sip, skb->dev, tip,
+ 				 sha, n->ha, sha);
+ 			BR_INPUT_SKB_CB(skb)->proxyarp_replied = true;
+ 		}
+ 
+ 		neigh_release(n);
+ 	}
++>>>>>>> 85a3d4a9356b (net: bridge: don't increment tx_dropped in br_do_proxy_arp)
  }
  
  /* note: already called with rcu_read_lock */
* Unmerged path net/bridge/br_input.c
