NTB: Add flow control to the ntb_netdev

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [ntb] Add flow control to the ntb_netdev (Suravee Suthikulpanit) [1303727]
Rebuild_FUZZ: 93.15%
commit-author Dave Jiang <dave.jiang@intel.com>
commit e74bfeedad08180b968d8613dcde141ffb0720c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e74bfeed.failed

Right now if we push the NTB really hard, we start dropping packets due
to not able to process the packets fast enough. We need to st:qop the
upper layer from flooding us when that happens.

A timer is necessary in order to restart the queue once the resource has
been processed on the receive side. Due to the way NTB is setup, the
resources on the tx side are tied to the processing of the rx side and
there's no async way to know when the rx side has released those
resources.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Jon Mason <jdmason@kudzu.us>
(cherry picked from commit e74bfeedad08180b968d8613dcde141ffb0720c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ntb_netdev.c
#	drivers/ntb/ntb_transport.c
#	include/linux/ntb_transport.h
diff --cc drivers/net/ntb_netdev.c
index db34e2d54fd9,a9acf7156855..000000000000
--- a/drivers/net/ntb_netdev.c
+++ b/drivers/net/ntb_netdev.c
@@@ -160,7 -213,7 +210,11 @@@ static netdev_tx_t ntb_netdev_start_xmi
  	struct ntb_netdev *dev = netdev_priv(ndev);
  	int rc;
  
++<<<<<<< HEAD
 +	netdev_dbg(ndev, "%s: skb len %d\n", __func__, skb->len);
++=======
+ 	ntb_netdev_maybe_stop_tx(ndev, dev->qp, tx_stop);
++>>>>>>> e74bfeedad08 (NTB: Add flow control to the ntb_netdev)
  
  	rc = ntb_transport_tx_enqueue(dev->qp, skb, skb->data, skb->len);
  	if (rc)
@@@ -190,12 -263,17 +264,15 @@@ static int ntb_netdev_open(struct net_d
  
  		rc = ntb_transport_rx_enqueue(dev->qp, skb, skb->data,
  					      ndev->mtu + ETH_HLEN);
 -		if (rc) {
 -			dev_kfree_skb(skb);
 +		if (rc == -EINVAL)
  			goto err;
 -		}
  	}
  
+ 	setup_timer(&dev->tx_timer, ntb_netdev_tx_timer, (unsigned long)ndev);
+ 
  	netif_carrier_off(ndev);
  	ntb_transport_link_up(dev->qp);
+ 	netif_start_queue(ndev);
  
  	return 0;
  
diff --cc drivers/ntb/ntb_transport.c
index 0d5e96e60628,0d851d684523..000000000000
--- a/drivers/ntb/ntb_transport.c
+++ b/drivers/ntb/ntb_transport.c
@@@ -454,10 -494,16 +454,16 @@@ static ssize_t debugfs_read(struct fil
  			       "tx_index - \t%u\n", qp->tx_index);
  	out_offset += snprintf(buf + out_offset, out_count - out_offset,
  			       "tx_max_entry - \t%u\n", qp->tx_max_entry);
+ 	out_offset += snprintf(buf + out_offset, out_count - out_offset,
+ 			       "qp->remote_rx_info->entry - \t%u\n",
+ 			       qp->remote_rx_info->entry);
+ 	out_offset += snprintf(buf + out_offset, out_count - out_offset,
+ 			       "free tx - \t%u\n",
+ 			       ntb_transport_tx_free_entry(qp));
  
  	out_offset += snprintf(buf + out_offset, out_count - out_offset,
 -			       "\nQP Link %s\n",
 -			       qp->link_is_up ? "Up" : "Down");
 +			       "\nQP Link %s\n", (qp->qp_link == NTB_LINK_UP) ?
 +			       "Up" : "Down");
  	if (out_offset > out_count)
  		out_offset = out_count;
  
@@@ -1787,3 -1975,80 +1794,83 @@@ unsigned int ntb_transport_max_size(str
  	return max;
  }
  EXPORT_SYMBOL_GPL(ntb_transport_max_size);
++<<<<<<< HEAD
++=======
+ 
+ unsigned int ntb_transport_tx_free_entry(struct ntb_transport_qp *qp)
+ {
+ 	unsigned int head = qp->tx_index;
+ 	unsigned int tail = qp->remote_rx_info->entry;
+ 
+ 	return tail > head ? tail - head : qp->tx_max_entry + tail - head;
+ }
+ EXPORT_SYMBOL_GPL(ntb_transport_tx_free_entry);
+ 
+ static void ntb_transport_doorbell_callback(void *data, int vector)
+ {
+ 	struct ntb_transport_ctx *nt = data;
+ 	struct ntb_transport_qp *qp;
+ 	u64 db_bits;
+ 	unsigned int qp_num;
+ 
+ 	db_bits = (nt->qp_bitmap & ~nt->qp_bitmap_free &
+ 		   ntb_db_vector_mask(nt->ndev, vector));
+ 
+ 	while (db_bits) {
+ 		qp_num = __ffs(db_bits);
+ 		qp = &nt->qp_vec[qp_num];
+ 
+ 		tasklet_schedule(&qp->rxc_db_work);
+ 
+ 		db_bits &= ~BIT_ULL(qp_num);
+ 	}
+ }
+ 
+ static const struct ntb_ctx_ops ntb_transport_ops = {
+ 	.link_event = ntb_transport_event_callback,
+ 	.db_event = ntb_transport_doorbell_callback,
+ };
+ 
+ static struct ntb_client ntb_transport_client = {
+ 	.ops = {
+ 		.probe = ntb_transport_probe,
+ 		.remove = ntb_transport_free,
+ 	},
+ };
+ 
+ static int __init ntb_transport_init(void)
+ {
+ 	int rc;
+ 
+ 	pr_info("%s, version %s\n", NTB_TRANSPORT_DESC, NTB_TRANSPORT_VER);
+ 
+ 	if (debugfs_initialized())
+ 		nt_debugfs_dir = debugfs_create_dir(KBUILD_MODNAME, NULL);
+ 
+ 	rc = bus_register(&ntb_transport_bus);
+ 	if (rc)
+ 		goto err_bus;
+ 
+ 	rc = ntb_register_client(&ntb_transport_client);
+ 	if (rc)
+ 		goto err_client;
+ 
+ 	return 0;
+ 
+ err_client:
+ 	bus_unregister(&ntb_transport_bus);
+ err_bus:
+ 	debugfs_remove_recursive(nt_debugfs_dir);
+ 	return rc;
+ }
+ module_init(ntb_transport_init);
+ 
+ static void __exit ntb_transport_exit(void)
+ {
+ 	debugfs_remove_recursive(nt_debugfs_dir);
+ 
+ 	ntb_unregister_client(&ntb_transport_client);
+ 	bus_unregister(&ntb_transport_bus);
+ }
+ module_exit(ntb_transport_exit);
++>>>>>>> e74bfeedad08 (NTB: Add flow control to the ntb_netdev)
* Unmerged path include/linux/ntb_transport.h
* Unmerged path drivers/net/ntb_netdev.c
* Unmerged path drivers/ntb/ntb_transport.c
* Unmerged path include/linux/ntb_transport.h
