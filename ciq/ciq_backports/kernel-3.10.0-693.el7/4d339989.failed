iwlwifi: mvm: support ibss in dqa mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Liad Kaufman <liad.kaufman@intel.com>
commit 4d339989acd730f17bc814b5ddb9c54e405766b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4d339989.failed

Allow working IBSS also when working in DQA mode.
This is done by setting it to treat the queues the
same as a BSS AP treats the queues.

Fixes: 7948b87308a4 ("iwlwifi: mvm: enable dynamic queue allocation mode")
	Signed-off-by: Liad Kaufman <liad.kaufman@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
(cherry picked from commit 4d339989acd730f17bc814b5ddb9c54e405766b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/mvm/sta.c
#	drivers/net/wireless/intel/iwlwifi/mvm/tx.c
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/sta.c
index b23ab4a4504f,9d28db7f56aa..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/sta.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/sta.c
@@@ -1063,15 -1806,12 +1063,20 @@@ int iwl_mvm_send_add_bcast_sta(struct i
  			iwl_mvm_get_wd_timeout(mvm, vif, false, false);
  		int queue;
  
++<<<<<<< HEAD
 +		if ((vif->type == NL80211_IFTYPE_AP) &&
 +		    (mvmvif->bcast_sta.tfd_queue_msk &
 +		     BIT(IWL_MVM_DQA_AP_PROBE_RESP_QUEUE)))
++=======
+ 		if (vif->type == NL80211_IFTYPE_AP ||
+ 		    vif->type == NL80211_IFTYPE_ADHOC)
++>>>>>>> 4d339989acd7 (iwlwifi: mvm: support ibss in dqa mode)
  			queue = IWL_MVM_DQA_AP_PROBE_RESP_QUEUE;
 -		else if (vif->type == NL80211_IFTYPE_P2P_DEVICE)
 +		else if ((vif->type == NL80211_IFTYPE_P2P_DEVICE) &&
 +			 (mvmvif->bcast_sta.tfd_queue_msk &
 +			  BIT(IWL_MVM_DQA_P2P_DEVICE_QUEUE)))
  			queue = IWL_MVM_DQA_P2P_DEVICE_QUEUE;
 -		else if (WARN(1, "Missing required TXQ for adding bcast STA\n"))
 +		else if (WARN(1, "Missed required TXQ for adding bcast STA\n"))
  			return -EINVAL;
  
  		iwl_mvm_enable_txq(mvm, queue, vif->hw_queue[0], 0, &cfg,
@@@ -1084,8 -1825,69 +1089,74 @@@
  	if (WARN_ON_ONCE(bsta->sta_id == IWL_MVM_STATION_COUNT))
  		return -ENOSPC;
  
++<<<<<<< HEAD
 +	return iwl_mvm_add_int_sta_common(mvm, bsta, baddr,
 +					  mvmvif->id, mvmvif->color);
++=======
+ 	ret = iwl_mvm_add_int_sta_common(mvm, bsta, baddr,
+ 					 mvmvif->id, mvmvif->color);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/*
+ 	 * In AP vif type, we also need to enable the cab_queue. However, we
+ 	 * have to enable it after the ADD_STA command is sent, otherwise the
+ 	 * FW will throw an assert once we send the ADD_STA command (it'll
+ 	 * detect a mismatch in the tfd_queue_msk, as we can't add the
+ 	 * enabled-cab_queue to the mask)
+ 	 */
+ 	if (iwl_mvm_is_dqa_supported(mvm) &&
+ 	    (vif->type == NL80211_IFTYPE_AP ||
+ 	     vif->type == NL80211_IFTYPE_ADHOC)) {
+ 		struct iwl_trans_txq_scd_cfg cfg = {
+ 			.fifo = IWL_MVM_TX_FIFO_MCAST,
+ 			.sta_id = mvmvif->bcast_sta.sta_id,
+ 			.tid = IWL_MAX_TID_COUNT,
+ 			.aggregate = false,
+ 			.frame_limit = IWL_FRAME_LIMIT,
+ 		};
+ 		unsigned int wdg_timeout =
+ 			iwl_mvm_get_wd_timeout(mvm, vif, false, false);
+ 
+ 		iwl_mvm_enable_txq(mvm, vif->cab_queue, vif->cab_queue,
+ 				   0, &cfg, wdg_timeout);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void iwl_mvm_free_bcast_sta_queues(struct iwl_mvm *mvm,
+ 					  struct ieee80211_vif *vif)
+ {
+ 	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
+ 
+ 	lockdep_assert_held(&mvm->mutex);
+ 
+ 	if (vif->type == NL80211_IFTYPE_AP ||
+ 	    vif->type == NL80211_IFTYPE_ADHOC)
+ 		iwl_mvm_disable_txq(mvm, vif->cab_queue, vif->cab_queue,
+ 				    IWL_MAX_TID_COUNT, 0);
+ 
+ 	if (mvmvif->bcast_sta.tfd_queue_msk &
+ 	    BIT(IWL_MVM_DQA_AP_PROBE_RESP_QUEUE)) {
+ 		iwl_mvm_disable_txq(mvm,
+ 				    IWL_MVM_DQA_AP_PROBE_RESP_QUEUE,
+ 				    vif->hw_queue[0], IWL_MAX_TID_COUNT,
+ 				    0);
+ 		mvmvif->bcast_sta.tfd_queue_msk &=
+ 			~BIT(IWL_MVM_DQA_AP_PROBE_RESP_QUEUE);
+ 	}
+ 
+ 	if (mvmvif->bcast_sta.tfd_queue_msk &
+ 	    BIT(IWL_MVM_DQA_P2P_DEVICE_QUEUE)) {
+ 		iwl_mvm_disable_txq(mvm,
+ 				    IWL_MVM_DQA_P2P_DEVICE_QUEUE,
+ 				    vif->hw_queue[0], IWL_MAX_TID_COUNT,
+ 				    0);
+ 		mvmvif->bcast_sta.tfd_queue_msk &=
+ 			~BIT(IWL_MVM_DQA_P2P_DEVICE_QUEUE);
+ 	}
++>>>>>>> 4d339989acd7 (iwlwifi: mvm: support ibss in dqa mode)
  }
  
  /* Send the FW a request to remove the station from it's internal data
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/tx.c
index b4d828b361f0,1ba0a6f55503..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c
@@@ -478,16 -501,38 +478,41 @@@ iwl_mvm_set_tx_params(struct iwl_mvm *m
  static int iwl_mvm_get_ctrl_vif_queue(struct iwl_mvm *mvm,
  				      struct ieee80211_tx_info *info, __le16 fc)
  {
++<<<<<<< HEAD
 +	if (iwl_mvm_is_dqa_supported(mvm)) {
 +		if (info->control.vif->type == NL80211_IFTYPE_AP &&
 +		    ieee80211_is_probe_resp(fc))
 +			return IWL_MVM_DQA_AP_PROBE_RESP_QUEUE;
 +		else if (ieee80211_is_mgmt(fc) &&
 +			 info->control.vif->type == NL80211_IFTYPE_P2P_DEVICE)
++=======
+ 	if (!iwl_mvm_is_dqa_supported(mvm))
+ 		return info->hw_queue;
+ 
+ 	switch (info->control.vif->type) {
+ 	case NL80211_IFTYPE_AP:
+ 	case NL80211_IFTYPE_ADHOC:
+ 		/*
+ 		 * Handle legacy hostapd as well, where station may be added
+ 		 * only after assoc. Take care of the case where we send a
+ 		 * deauth to a station that we don't have.
+ 		 */
+ 		if (ieee80211_is_probe_resp(fc) || ieee80211_is_auth(fc) ||
+ 		    ieee80211_is_deauth(fc))
+ 			return IWL_MVM_DQA_AP_PROBE_RESP_QUEUE;
+ 		if (info->hw_queue == info->control.vif->cab_queue)
+ 			return info->hw_queue;
+ 
+ 		WARN_ONCE(info->control.vif->type != NL80211_IFTYPE_ADHOC,
+ 			  "fc=0x%02x", le16_to_cpu(fc));
+ 		return IWL_MVM_DQA_AP_PROBE_RESP_QUEUE;
+ 	case NL80211_IFTYPE_P2P_DEVICE:
+ 		if (ieee80211_is_mgmt(fc))
++>>>>>>> 4d339989acd7 (iwlwifi: mvm: support ibss in dqa mode)
  			return IWL_MVM_DQA_P2P_DEVICE_QUEUE;
 -		if (info->hw_queue == info->control.vif->cab_queue)
 -			return info->hw_queue;
 -
 -		WARN_ON_ONCE(1);
 -		return IWL_MVM_DQA_P2P_DEVICE_QUEUE;
 -	default:
 -		WARN_ONCE(1, "Not a ctrl vif, no available queue\n");
 -		return -1;
  	}
 +
 +	return info->hw_queue;
  }
  
  int iwl_mvm_tx_skb_non_sta(struct iwl_mvm *mvm, struct sk_buff *skb)
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c b/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c
index 7aae068c02e5..fde421a2ba39 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c
@@ -216,7 +216,8 @@ u32 iwl_mvm_mac_get_queues_mask(struct ieee80211_vif *vif)
 			qmask |= BIT(vif->hw_queue[ac]);
 	}
 
-	if (vif->type == NL80211_IFTYPE_AP)
+	if (vif->type == NL80211_IFTYPE_AP ||
+	    vif->type == NL80211_IFTYPE_ADHOC)
 		qmask |= BIT(vif->cab_queue);
 
 	return qmask;
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/sta.c
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/tx.c
