KVM: x86: Misc LAPIC changes to expose helper functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
commit 1e6e2755b635e85ce0b1ce827b7c375b6a0a890c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1e6e2755.failed

Exporting LAPIC utility functions and macros for re-use in SVM code.

	Signed-off-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
	Reviewed-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 1e6e2755b635e85ce0b1ce827b7c375b6a0a890c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
diff --cc arch/x86/kvm/lapic.c
index 47c6b9ccd177,f6f42f634e77..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -251,9 -210,9 +237,9 @@@ static inline void apic_set_spiv(struc
  	}
  }
  
 -static inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)
 +static inline void kvm_apic_set_xapic_id(struct kvm_lapic *apic, u8 id)
  {
- 	apic_set_reg(apic, APIC_ID, id << 24);
+ 	kvm_lapic_set_reg(apic, APIC_ID, id << 24);
  	recalculate_apic_map(apic->vcpu->kvm);
  }
  
@@@ -267,8 -226,8 +253,13 @@@ static inline void kvm_apic_set_x2apic_
  {
  	u32 ldr = ((id >> 4) << 16) | (1 << (id & 0xf));
  
++<<<<<<< HEAD
 +	apic_set_reg(apic, APIC_ID, id);
 +	apic_set_reg(apic, APIC_LDR, ldr);
++=======
+ 	kvm_lapic_set_reg(apic, APIC_ID, id << 24);
+ 	kvm_lapic_set_reg(apic, APIC_LDR, ldr);
++>>>>>>> 1e6e2755b635 (KVM: x86: Misc LAPIC changes to expose helper functions)
  	recalculate_apic_map(apic->vcpu->kvm);
  }
  
@@@ -937,10 -903,10 +919,10 @@@ static int __apic_accept_irq(struct kvm
  				apic_clear_vector(vector, apic->regs + APIC_TMR);
  		}
  
 -		if (vcpu->arch.apicv_active)
 +		if (kvm_x86_ops->deliver_posted_interrupt)
  			kvm_x86_ops->deliver_posted_interrupt(vcpu, vector);
  		else {
- 			apic_set_irr(vector, apic);
+ 			kvm_lapic_set_irr(vector, apic);
  
  			kvm_make_request(KVM_REQ_EVENT, vcpu);
  			kvm_vcpu_kick(vcpu);
@@@ -1559,8 -1534,9 +1542,9 @@@ int kvm_lapic_reg_write(struct kvm_lapi
  		apic_debug("Local APIC Write to read-only register %x\n", reg);
  	return ret;
  }
+ EXPORT_SYMBOL_GPL(kvm_lapic_reg_write);
  
 -static int apic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,
 +static int apic_mmio_write(struct kvm_io_device *this,
  			    gpa_t address, int len, const void *data)
  {
  	struct kvm_lapic *apic = to_lapic(this);
@@@ -1741,34 -1716,34 +1725,34 @@@ void kvm_lapic_reset(struct kvm_vcpu *v
  	hrtimer_cancel(&apic->lapic_timer.timer);
  
  	if (!init_event)
 -		kvm_apic_set_id(apic, vcpu->vcpu_id);
 +		kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
  	kvm_apic_set_version(apic->vcpu);
  
- 	for (i = 0; i < APIC_LVT_NUM; i++)
- 		apic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);
+ 	for (i = 0; i < KVM_APIC_LVT_NUM; i++)
+ 		kvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);
  	apic_update_lvtt(apic);
  	if (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_LINT0_REENABLED))
- 		apic_set_reg(apic, APIC_LVT0,
+ 		kvm_lapic_set_reg(apic, APIC_LVT0,
  			     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));
  	apic_manage_nmi_watchdog(apic, kvm_apic_get_reg(apic, APIC_LVT0));
  
- 	apic_set_reg(apic, APIC_DFR, 0xffffffffU);
+ 	kvm_lapic_set_reg(apic, APIC_DFR, 0xffffffffU);
  	apic_set_spiv(apic, 0xff);
- 	apic_set_reg(apic, APIC_TASKPRI, 0);
+ 	kvm_lapic_set_reg(apic, APIC_TASKPRI, 0);
  	if (!apic_x2apic_mode(apic))
  		kvm_apic_set_ldr(apic, 0);
- 	apic_set_reg(apic, APIC_ESR, 0);
- 	apic_set_reg(apic, APIC_ICR, 0);
- 	apic_set_reg(apic, APIC_ICR2, 0);
- 	apic_set_reg(apic, APIC_TDCR, 0);
- 	apic_set_reg(apic, APIC_TMICT, 0);
+ 	kvm_lapic_set_reg(apic, APIC_ESR, 0);
+ 	kvm_lapic_set_reg(apic, APIC_ICR, 0);
+ 	kvm_lapic_set_reg(apic, APIC_ICR2, 0);
+ 	kvm_lapic_set_reg(apic, APIC_TDCR, 0);
+ 	kvm_lapic_set_reg(apic, APIC_TMICT, 0);
  	for (i = 0; i < 8; i++) {
- 		apic_set_reg(apic, APIC_IRR + 0x10 * i, 0);
- 		apic_set_reg(apic, APIC_ISR + 0x10 * i, 0);
- 		apic_set_reg(apic, APIC_TMR + 0x10 * i, 0);
+ 		kvm_lapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);
+ 		kvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);
+ 		kvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);
  	}
 -	apic->irr_pending = vcpu->arch.apicv_active;
 -	apic->isr_count = vcpu->arch.apicv_active ? 1 : 0;
 +	apic->irr_pending = kvm_vcpu_apic_vid_enabled(vcpu);
 +	apic->isr_count = kvm_x86_ops->hwapic_isr_update ? 1 : 0;
  	apic->highest_isr_cache = -1;
  	update_divide_count(apic);
  	atomic_set(&apic->lapic_timer.pending, 0);
* Unmerged path arch/x86/kvm/lapic.c
diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h
index 639882f11237..7d9bd9a17306 100644
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@ -7,6 +7,7 @@
 
 #define KVM_APIC_INIT		0
 #define KVM_APIC_SIPI		1
+#define KVM_APIC_LVT_NUM	6
 
 struct kvm_timer {
 	struct hrtimer timer;
@@ -59,6 +60,11 @@ void kvm_lapic_set_eoi(struct kvm_vcpu *vcpu);
 void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value);
 u64 kvm_lapic_get_base(struct kvm_vcpu *vcpu);
 void kvm_apic_set_version(struct kvm_vcpu *vcpu);
+int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val);
+int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,
+		       void *data);
+bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,
+			   int short_hand, unsigned int dest, int dest_mode);
 
 void __kvm_apic_update_irr(u32 *pir, void *regs);
 void kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir);
@@ -99,11 +105,34 @@ static inline bool kvm_hv_vapic_assist_page_enabled(struct kvm_vcpu *vcpu)
 int kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data);
 void kvm_lapic_init(void);
 
+#define VEC_POS(v) ((v) & (32 - 1))
+#define REG_POS(v) (((v) >> 5) << 4)
+
+static inline void kvm_lapic_set_vector(int vec, void *bitmap)
+{
+	set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
+}
+
+static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)
+{
+	kvm_lapic_set_vector(vec, apic->regs + APIC_IRR);
+	/*
+	 * irr_pending must be true if any interrupt is pending; set it after
+	 * APIC_IRR to avoid race with apic_clear_irr
+	 */
+	apic->irr_pending = true;
+}
+
 static inline u32 kvm_apic_get_reg(struct kvm_lapic *apic, int reg_off)
 {
 	        return *((u32 *) (apic->regs + reg_off));
 }
 
+static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)
+{
+	*((u32 *) (apic->regs + reg_off)) = val;
+}
+
 extern struct static_key kvm_no_apic_vcpu;
 
 static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)
