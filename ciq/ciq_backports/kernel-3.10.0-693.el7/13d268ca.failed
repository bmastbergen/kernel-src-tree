KVM: MMU: apply page track notifier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Xiao Guangrong <guangrong.xiao@linux.intel.com>
commit 13d268ca2c4c29d6da2ba79419f9a655e602afed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/13d268ca.failed

Register the notifier to receive write track event so that we can update
our shadow page table

It makes kvm_mmu_pte_write() be the callback of the notifier, no function
is changed

	Signed-off-by: Xiao Guangrong <guangrong.xiao@linux.intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 13d268ca2c4c29d6da2ba79419f9a655e602afed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/x86.c
diff --cc arch/x86/include/asm/kvm_host.h
index c4a4bfc6a009,1c3e390993a2..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -618,6 -704,8 +618,11 @@@ struct kvm_arch 
  	 */
  	struct list_head active_mmu_pages;
  	struct list_head zapped_obsolete_pages;
++<<<<<<< HEAD
++=======
+ 	struct kvm_page_track_notifier_node mmu_sp_tracker;
+ 	struct kvm_page_track_notifier_head track_notifier_head;
++>>>>>>> 13d268ca2c4c (KVM: MMU: apply page track notifier)
  
  	struct list_head assigned_dev_head;
  	struct iommu_domain *iommu_domain;
@@@ -1054,10 -1143,6 +1061,13 @@@ void kvm_pic_clear_all(struct kvm_pic *
  
  void kvm_inject_nmi(struct kvm_vcpu *vcpu);
  
++<<<<<<< HEAD
 +int fx_init(struct kvm_vcpu *vcpu, bool init_event);
 +
 +void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,
 +		       const u8 *new, int bytes);
++=======
++>>>>>>> 13d268ca2c4c (KVM: MMU: apply page track notifier)
  int kvm_mmu_unprotect_page(struct kvm *kvm, gfn_t gfn);
  int kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva);
  void __kvm_mmu_free_some_pages(struct kvm_vcpu *vcpu);
diff --cc arch/x86/kvm/x86.c
index 9677babcc502,f4654e4150b0..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -4556,7 -4345,7 +4556,11 @@@ int emulator_write_phys(struct kvm_vcp
  	ret = kvm_vcpu_write_guest(vcpu, gpa, val, bytes);
  	if (ret < 0)
  		return 0;
++<<<<<<< HEAD
 +	kvm_mmu_pte_write(vcpu, gpa, val, bytes);
++=======
+ 	kvm_page_track_write(vcpu, gpa, val, bytes);
++>>>>>>> 13d268ca2c4c (KVM: MMU: apply page track notifier)
  	return 1;
  }
  
@@@ -4814,7 -4603,7 +4818,11 @@@ static int emulator_cmpxchg_emulated(st
  		return X86EMUL_CMPXCHG_FAILED;
  
  	kvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);
++<<<<<<< HEAD
 +	kvm_mmu_pte_write(vcpu, gpa, new, bytes);
++=======
+ 	kvm_page_track_write(vcpu, gpa, new, bytes);
++>>>>>>> 13d268ca2c4c (KVM: MMU: apply page track notifier)
  
  	return X86EMUL_CONTINUE;
  
@@@ -7921,6 -7724,9 +7929,12 @@@ int kvm_arch_init_vm(struct kvm *kvm, u
  	INIT_DELAYED_WORK(&kvm->arch.kvmclock_update_work, kvmclock_update_fn);
  	INIT_DELAYED_WORK(&kvm->arch.kvmclock_sync_work, kvmclock_sync_fn);
  
++<<<<<<< HEAD
++=======
+ 	kvm_page_track_init(kvm);
+ 	kvm_mmu_init_vm(kvm);
+ 
++>>>>>>> 13d268ca2c4c (KVM: MMU: apply page track notifier)
  	return 0;
  }
  
* Unmerged path arch/x86/include/asm/kvm_host.h
diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c
index 9645a520c25f..f709d0b2aba9 100644
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@ -4364,8 +4364,8 @@ static u64 *get_written_sptes(struct kvm_mmu_page *sp, gpa_t gpa, int *nspte)
 	return spte;
 }
 
-void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,
-		       const u8 *new, int bytes)
+static void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,
+			      const u8 *new, int bytes)
 {
 	gfn_t gfn = gpa >> PAGE_SHIFT;
 	struct kvm_mmu_page *sp;
@@ -4579,6 +4579,21 @@ void kvm_mmu_setup(struct kvm_vcpu *vcpu)
 	init_kvm_mmu(vcpu);
 }
 
+void kvm_mmu_init_vm(struct kvm *kvm)
+{
+	struct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;
+
+	node->track_write = kvm_mmu_pte_write;
+	kvm_page_track_register_notifier(kvm, node);
+}
+
+void kvm_mmu_uninit_vm(struct kvm *kvm)
+{
+	struct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;
+
+	kvm_page_track_unregister_notifier(kvm, node);
+}
+
 /* The return value indicates if tlb flush on all vcpus is needed. */
 typedef bool (*slot_level_handler) (struct kvm *kvm, unsigned long *rmap);
 
* Unmerged path arch/x86/kvm/x86.c
