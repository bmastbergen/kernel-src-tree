HID: wacom: Initialize MT slots for generic devices at post_parse_hid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Initialize MT slots for generic devices at post_parse_hid (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 96.24%
commit-author Jason Gerecke <killertofu@gmail.com>
commit b58ba1ba1af9cfbad6f3af4c4fc3575d9aeae542
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b58ba1ba.failed

If a HID descriptor places HID_DG_CONTACTID before HID_DG_X and HID_DG_Y then
the ABS_X and ABS_Y will not be automatically initialized by the call to
input_mt_init_slots. To ensure that this is not a problem, we relocate that
call to occur after HID parsing has been completed and we've initalized all the
multitouch axes.

	Signed-off-by: Jason Gerecke <killertofu@gmail.com>
	Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit b58ba1ba1af9cfbad6f3af4c4fc3575d9aeae542)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,872aa0be2e70..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -13,48 -13,11 +13,49 @@@
  
  #include "wacom_wac.h"
  #include "wacom.h"
+ #include <linux/input/mt.h>
  
 +/* defines to get HID report descriptor */
 +#define HID_DEVICET_HID		(USB_TYPE_CLASS | 0x01)
 +#define HID_DEVICET_REPORT	(USB_TYPE_CLASS | 0x02)
 +#define HID_USAGE_UNDEFINED		0x00
 +#define HID_USAGE_PAGE			0x05
 +#define HID_USAGE_PAGE_DIGITIZER	0x0d
 +#define HID_USAGE_PAGE_DESKTOP		0x01
 +#define HID_USAGE			0x09
 +#define HID_USAGE_X			0x30
 +#define HID_USAGE_Y			0x31
 +#define HID_USAGE_X_TILT		0x3d
 +#define HID_USAGE_Y_TILT		0x3e
 +#define HID_USAGE_FINGER		0x22
 +#define HID_USAGE_STYLUS		0x20
 +#define HID_USAGE_CONTACTMAX		0x55
 +#define HID_COLLECTION			0xa1
 +#define HID_COLLECTION_LOGICAL		0x02
 +#define HID_COLLECTION_END		0xc0
 +
 +enum {
 +	WCM_UNDEFINED = 0,
 +	WCM_DESKTOP,
 +	WCM_DIGITIZER,
 +};
 +
 +struct hid_descriptor {
 +	struct usb_descriptor_header header;
 +	__le16   bcdHID;
 +	u8       bCountryCode;
 +	u8       bNumDescriptors;
 +	u8       bDescriptorType;
 +	__le16   wDescriptorLength;
 +} __attribute__ ((packed));
 +
 +/* defines to get/set USB message */
 +#define USB_REQ_GET_REPORT	0x01
 +#define USB_REQ_SET_REPORT	0x09
 +
 +#define WAC_HID_FEATURE_REPORT	0x03
  #define WAC_MSG_RETRIES		5
  
 -#define WAC_CMD_WL_LED_CONTROL	0x03
  #define WAC_CMD_LED_CONTROL	0x20
  #define WAC_CMD_ICON_START	0x21
  #define WAC_CMD_ICON_XFER	0x23
@@@ -290,248 -172,145 +291,346 @@@ static void wacom_retrieve_report_data(
   * interfaces haven't supported pressure or distance, this is enough
   * information to override invalid values in the wacom_features table.
   *
 - * Intuos5 touch interface and 3rd gen Bamboo Touch do not contain useful
 - * data. We deal with them after returning from this function.
 + * 3rd gen Bamboo Touch no longer define a Digitizer-Finger Pysical
 + * Collection. Instead they define a Logical Collection with a single
 + * Logical Maximum for both X and Y.
 + *
 + * Intuos5 touch interface does not contain useful data. We deal with
 + * this after returning from this function.
   */
++<<<<<<< HEAD
 +static int wacom_parse_hid(struct usb_interface *intf,
 +			   struct hid_descriptor *hid_desc,
++=======
+ static void wacom_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_features *features = &wacom->wacom_wac.features;
+ 	bool finger = (field->logical == HID_DG_FINGER) ||
+ 		      (field->physical == HID_DG_FINGER);
+ 	bool pen = (field->logical == HID_DG_STYLUS) ||
+ 		   (field->physical == HID_DG_STYLUS);
+ 
+ 	/*
+ 	* Requiring Stylus Usage will ignore boot mouse
+ 	* X/Y values and some cases of invalid Digitizer X/Y
+ 	* values commonly reported.
+ 	*/
+ 	if (!pen && !finger)
+ 		return;
+ 
+ 	/*
+ 	 * Bamboo models do not support HID_DG_CONTACTMAX.
+ 	 * And, Bamboo Pen only descriptor contains touch.
+ 	 */
+ 	if (features->type != BAMBOO_PT) {
+ 		/* ISDv4 touch devices at least supports one touch point */
+ 		if (finger && !features->touch_max)
+ 			features->touch_max = 1;
+ 	}
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		features->x_max = field->logical_maximum;
+ 		if (finger) {
+ 			features->device_type = BTN_TOOL_FINGER;
+ 			features->x_phy = field->physical_maximum;
+ 			if (features->type != BAMBOO_PT) {
+ 				features->unit = field->unit;
+ 				features->unitExpo = field->unit_exponent;
+ 			}
+ 		} else {
+ 			features->device_type = BTN_TOOL_PEN;
+ 		}
+ 		break;
+ 	case HID_GD_Y:
+ 		features->y_max = field->logical_maximum;
+ 		if (finger) {
+ 			features->y_phy = field->physical_maximum;
+ 			if (features->type != BAMBOO_PT) {
+ 				features->unit = field->unit;
+ 				features->unitExpo = field->unit_exponent;
+ 			}
+ 		}
+ 		break;
+ 	case HID_DG_TIPPRESSURE:
+ 		if (pen)
+ 			features->pressure_max = field->logical_maximum;
+ 		break;
+ 	}
+ 
+ 	if (features->type == HID_GENERIC)
+ 		wacom_wac_usage_mapping(hdev, field, usage);
+ }
+ 
+ static void wacom_post_parse_hid(struct hid_device *hdev,
+ 				 struct wacom_features *features)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	if (features->type == HID_GENERIC) {
+ 		/* Any last-minute generic device setup */
+ 		if (features->touch_max > 1) {
+ 			input_mt_init_slots(wacom_wac->input, wacom_wac->features.touch_max,
+ 				    INPUT_MT_DIRECT);
+ 		}
+ 	}
+ }
+ 
+ static void wacom_parse_hid(struct hid_device *hdev,
++>>>>>>> b58ba1ba1af9 (HID: wacom: Initialize MT slots for generic devices at post_parse_hid)
  			   struct wacom_features *features)
  {
 -	struct hid_report_enum *rep_enum;
 -	struct hid_report *hreport;
 -	int i, j;
 +	struct usb_device *dev = interface_to_usbdev(intf);
 +	char limit = 0;
 +	/* result has to be defined as int for some devices */
 +	int result = 0;
 +	int i = 0, usage = WCM_UNDEFINED, finger = 0, pen = 0;
 +	unsigned char *report;
 +
 +	report = kzalloc(hid_desc->wDescriptorLength, GFP_KERNEL);
 +	if (!report)
 +		return -ENOMEM;
  
 -	/* check features first */
 -	rep_enum = &hdev->report_enum[HID_FEATURE_REPORT];
 -	list_for_each_entry(hreport, &rep_enum->report_list, list) {
 -		for (i = 0; i < hreport->maxfield; i++) {
 -			/* Ignore if report count is out of bounds. */
 -			if (hreport->field[i]->report_count < 1)
 -				continue;
 +	/* retrive report descriptors */
 +	do {
 +		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 +			USB_REQ_GET_DESCRIPTOR,
 +			USB_RECIP_INTERFACE | USB_DIR_IN,
 +			HID_DEVICET_REPORT << 8,
 +			intf->altsetting[0].desc.bInterfaceNumber, /* interface */
 +			report,
 +			hid_desc->wDescriptorLength,
 +			5000); /* 5 secs */
 +	} while (result < 0 && limit++ < WAC_MSG_RETRIES);
 +
 +	/* No need to parse the Descriptor. It isn't an error though */
 +	if (result < 0)
 +		goto out;
  
 -			for (j = 0; j < hreport->field[i]->maxusage; j++) {
 -				wacom_feature_mapping(hdev, hreport->field[i],
 -						hreport->field[i]->usage + j);
 +	for (i = 0; i < hid_desc->wDescriptorLength; i++) {
 +
 +		switch (report[i]) {
 +		case HID_USAGE_PAGE:
 +			switch (report[i + 1]) {
 +			case HID_USAGE_PAGE_DIGITIZER:
 +				usage = WCM_DIGITIZER;
 +				i++;
 +				break;
 +
 +			case HID_USAGE_PAGE_DESKTOP:
 +				usage = WCM_DESKTOP;
 +				i++;
 +				break;
  			}
 +			break;
 +
 +		case HID_USAGE:
 +			switch (report[i + 1]) {
 +			case HID_USAGE_X:
 +				if (usage == WCM_DESKTOP) {
 +					if (finger) {
 +						features->device_type = BTN_TOOL_FINGER;
 +
 +						switch (features->type) {
 +						case TABLETPC2FG:
 +							features->pktlen = WACOM_PKGLEN_TPC2FG;
 +							break;
 +
 +						case MTSCREEN:
 +						case WACOM_24HDT:
 +							features->pktlen = WACOM_PKGLEN_MTOUCH;
 +							break;
 +
 +						case MTTPC:
 +							features->pktlen = WACOM_PKGLEN_MTTPC;
 +							break;
 +
 +						case BAMBOO_PT:
 +							features->pktlen = WACOM_PKGLEN_BBTOUCH;
 +							break;
 +
 +						default:
 +							features->pktlen = WACOM_PKGLEN_GRAPHIRE;
 +							break;
 +						}
 +
 +						switch (features->type) {
 +						case BAMBOO_PT:
 +							features->x_phy =
 +								get_unaligned_le16(&report[i + 5]);
 +							features->x_max =
 +								get_unaligned_le16(&report[i + 8]);
 +							i += 15;
 +							break;
 +
 +						case WACOM_24HDT:
 +							features->x_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->x_phy =
 +								get_unaligned_le16(&report[i + 8]);
 +							features->unit = report[i - 1];
 +							features->unitExpo = report[i - 3];
 +							i += 12;
 +							break;
 +
 +						case WACOM_27QHDT:
 +							if (!features->x_max) {
 +								features->x_max =
 +									get_unaligned_le16(&report[i - 4]);
 +								features->x_phy =
 +									get_unaligned_le16(&report[i - 7]);
 +								features->unit = report[i - 13];
 +								features->unitExpo = report[i - 11];
 +							}
 +							i += 9;
 +							break;
 +
 +						default:
 +							features->x_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->x_phy =
 +								get_unaligned_le16(&report[i + 6]);
 +							features->unit = report[i + 9];
 +							features->unitExpo = report[i + 11];
 +							i += 12;
 +							break;
 +						}
 +					} else if (pen) {
 +						/* penabled only accepts exact bytes of data */
 +						if (features->type >= TABLETPC)
 +							features->pktlen = WACOM_PKGLEN_GRAPHIRE;
 +						features->device_type = BTN_TOOL_PEN;
 +						features->x_max =
 +							get_unaligned_le16(&report[i + 3]);
 +						i += 4;
 +					}
 +				}
 +				break;
 +
 +			case HID_USAGE_Y:
 +				if (usage == WCM_DESKTOP) {
 +					if (finger) {
 +						switch (features->type) {
 +						case TABLETPC2FG:
 +						case MTSCREEN:
 +						case MTTPC:
 +							features->y_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->y_phy =
 +								get_unaligned_le16(&report[i + 6]);
 +							i += 7;
 +							break;
 +
 +						case WACOM_24HDT:
 +							features->y_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->y_phy =
 +								get_unaligned_le16(&report[i - 2]);
 +							i += 7;
 +							break;
 +
 +						case BAMBOO_PT:
 +							features->y_phy =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->y_max =
 +								get_unaligned_le16(&report[i + 6]);
 +							i += 12;
 +							break;
 +
 +						case WACOM_27QHDT:
 +							if (!features->y_max) {
 +								features->y_max =
 +									get_unaligned_le16(&report[i - 2]);
 +								features->y_phy =
 +									get_unaligned_le16(&report[i - 5]);
 +							}
 +							i += 2;
 +							break;
 +
 +						default:
 +							features->y_max =
 +								features->x_max;
 +							features->y_phy =
 +								get_unaligned_le16(&report[i + 3]);
 +							i += 4;
 +							break;
 +						}
 +					} else if (pen) {
 +						features->y_max =
 +							get_unaligned_le16(&report[i + 3]);
 +						i += 4;
 +					}
 +				}
 +				break;
 +
 +			case HID_USAGE_FINGER:
 +				finger = 1;
 +				i++;
 +				break;
 +
 +			/*
 +			 * Requiring Stylus Usage will ignore boot mouse
 +			 * X/Y values and some cases of invalid Digitizer X/Y
 +			 * values commonly reported.
 +			 */
 +			case HID_USAGE_STYLUS:
 +				pen = 1;
 +				i++;
 +				break;
 +
 +			case HID_USAGE_CONTACTMAX:
 +				/* leave touch_max as is if predefined */
 +				if (!features->touch_max)
 +					wacom_retrieve_report_data(intf, features);
 +				i++;
 +				break;
 +			}
 +			break;
 +
 +		case HID_COLLECTION_END:
 +			/* reset UsagePage and Finger */
 +			finger = usage = 0;
 +			break;
 +
 +		case HID_COLLECTION:
 +			i++;
 +			switch (report[i]) {
 +			case HID_COLLECTION_LOGICAL:
 +				i += wacom_parse_logical_collection(&report[i],
 +								    features);
 +				break;
 +			}
 +			break;
  		}
  	}
  
++<<<<<<< HEAD
 + out:
 +	result = 0;
 +	kfree(report);
 +	return result;
++=======
+ 	/* now check the input usages */
+ 	rep_enum = &hdev->report_enum[HID_INPUT_REPORT];
+ 	list_for_each_entry(hreport, &rep_enum->report_list, list) {
+ 
+ 		if (!hreport->maxfield)
+ 			continue;
+ 
+ 		for (i = 0; i < hreport->maxfield; i++)
+ 			for (j = 0; j < hreport->field[i]->maxusage; j++)
+ 				wacom_usage_mapping(hdev, hreport->field[i],
+ 						hreport->field[i]->usage + j);
+ 	}
+ 
+ 	wacom_post_parse_hid(hdev, features);
++>>>>>>> b58ba1ba1af9 (HID: wacom: Initialize MT slots for generic devices at post_parse_hid)
  }
  
 -static int wacom_hid_set_device_mode(struct hid_device *hdev)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct hid_data *hid_data = &wacom->wacom_wac.hid_data;
 -	struct hid_report *r;
 -	struct hid_report_enum *re;
 -
 -	if (hid_data->inputmode < 0)
 -		return 0;
 -
 -	re = &(hdev->report_enum[HID_FEATURE_REPORT]);
 -	r = re->report_id_hash[hid_data->inputmode];
 -	if (r) {
 -		r->field[0]->value[hid_data->inputmode_index] = 2;
 -		hid_hw_request(hdev, r, HID_REQ_SET_REPORT);
 -	}
 -	return 0;
 -}
 -
 -static int wacom_set_device_mode(struct hid_device *hdev, int report_id,
 -		int length, int mode)
 +static int wacom_set_device_mode(struct usb_interface *intf, int report_id, int length, int mode)
  {
  	unsigned char *rep_data;
  	int error = -ENOMEM, limit = 0;
diff --cc drivers/hid/wacom_wac.c
index 334849232c4c,064fd6cf36c6..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1102,6 -1252,295 +1102,298 @@@ static int wacom_tpc_irq(struct wacom_w
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_map_usage(struct wacom *wacom, struct hid_usage *usage,
+ 		struct hid_field *field, __u8 type, __u16 code, int fuzz)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 	int fmin = field->logical_minimum;
+ 	int fmax = field->logical_maximum;
+ 
+ 	usage->type = type;
+ 	usage->code = code;
+ 
+ 	set_bit(type, input->evbit);
+ 
+ 	switch (type) {
+ 	case EV_ABS:
+ 		input_set_abs_params(input, code, fmin, fmax, fuzz, 0);
+ 		input_abs_set_res(input, code,
+ 				  hidinput_calc_abs_res(field, code));
+ 		break;
+ 	case EV_KEY:
+ 		input_set_capability(input, EV_KEY, code);
+ 		break;
+ 	case EV_MSC:
+ 		input_set_capability(input, EV_MSC, code);
+ 		break;
+ 	}
+ }
+ 
+ static void wacom_wac_pen_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		wacom_map_usage(wacom, usage, field, EV_ABS, ABS_X, 4);
+ 		break;
+ 	case HID_GD_Y:
+ 		wacom_map_usage(wacom, usage, field, EV_ABS, ABS_Y, 4);
+ 		break;
+ 	case HID_DG_TIPPRESSURE:
+ 		wacom_map_usage(wacom, usage, field, EV_ABS, ABS_PRESSURE, 0);
+ 		break;
+ 	case HID_DG_INRANGE:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_TOOL_PEN, 0);
+ 		break;
+ 	case HID_DG_INVERT:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY,
+ 				BTN_TOOL_RUBBER, 0);
+ 		break;
+ 	case HID_DG_ERASER:
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_TOUCH, 0);
+ 		break;
+ 	case HID_DG_BARRELSWITCH:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_STYLUS, 0);
+ 		break;
+ 	case HID_DG_BARRELSWITCH2:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_STYLUS2, 0);
+ 		break;
+ 	case HID_DG_TOOLSERIALNUMBER:
+ 		wacom_map_usage(wacom, usage, field, EV_MSC, MSC_SERIAL, 0);
+ 		break;
+ 	}
+ }
+ 
+ static int wacom_wac_pen_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 
+ 	/* checking which Tool / tip switch to send */
+ 	switch (usage->hid) {
+ 	case HID_DG_INRANGE:
+ 		wacom_wac->hid_data.inrange_state = value;
+ 		return 0;
+ 	case HID_DG_INVERT:
+ 		wacom_wac->hid_data.invert_state = value;
+ 		return 0;
+ 	case HID_DG_ERASER:
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_wac->hid_data.tipswitch |= value;
+ 		return 0;
+ 	}
+ 
+ 	/* send pen events only when touch is up or forced out */
+ 	if (!usage->type || wacom_wac->shared->touch_down)
+ 		return 0;
+ 
+ 	input_event(input, usage->type, usage->code, value);
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_wac_pen_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 	bool prox = wacom_wac->hid_data.inrange_state;
+ 
+ 	if (!wacom_wac->shared->stylus_in_proximity) /* first in prox */
+ 		/* Going into proximity select tool */
+ 		wacom_wac->tool[0] = wacom_wac->hid_data.invert_state ?
+ 						BTN_TOOL_RUBBER : BTN_TOOL_PEN;
+ 
+ 	/* keep pen state for touch events */
+ 	wacom_wac->shared->stylus_in_proximity = prox;
+ 
+ 	/* send pen events only when touch is up or forced out */
+ 	if (!wacom_wac->shared->touch_down) {
+ 		input_report_key(input, BTN_TOUCH,
+ 				wacom_wac->hid_data.tipswitch);
+ 		input_report_key(input, wacom_wac->tool[0], prox);
+ 
+ 		wacom_wac->hid_data.tipswitch = false;
+ 
+ 		input_sync(input);
+ 	}
+ }
+ 
+ static void wacom_wac_finger_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	unsigned touch_max = wacom_wac->features.touch_max;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		if (touch_max == 1)
+ 			wacom_map_usage(wacom, usage, field, EV_ABS, ABS_X, 4);
+ 		else
+ 			wacom_map_usage(wacom, usage, field, EV_ABS,
+ 					ABS_MT_POSITION_X, 4);
+ 		break;
+ 	case HID_GD_Y:
+ 		if (touch_max == 1)
+ 			wacom_map_usage(wacom, usage, field, EV_ABS, ABS_Y, 4);
+ 		else
+ 			wacom_map_usage(wacom, usage, field, EV_ABS,
+ 					ABS_MT_POSITION_Y, 4);
+ 		break;
+ 	case HID_DG_CONTACTID:
+ 		break;
+ 	case HID_DG_INRANGE:
+ 		break;
+ 	case HID_DG_INVERT:
+ 		break;
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_TOUCH, 0);
+ 		break;
+ 	}
+ }
+ 
+ static int wacom_wac_finger_event(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		wacom_wac->hid_data.x = value;
+ 		break;
+ 	case HID_GD_Y:
+ 		wacom_wac->hid_data.y = value;
+ 		break;
+ 	case HID_DG_CONTACTID:
+ 		wacom_wac->hid_data.id = value;
+ 		break;
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_wac->hid_data.tipswitch = value;
+ 		break;
+ 	}
+ 
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_wac_finger_mt_report(struct wacom_wac *wacom_wac,
+ 		struct input_dev *input, bool touch)
+ {
+ 	int slot;
+ 	struct hid_data *hid_data = &wacom_wac->hid_data;
+ 
+ 	slot = input_mt_get_slot_by_key(input, hid_data->id);
+ 
+ 	input_mt_slot(input, slot);
+ 	input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
+ 	if (touch) {
+ 		input_report_abs(input, ABS_MT_POSITION_X, hid_data->x);
+ 		input_report_abs(input, ABS_MT_POSITION_Y, hid_data->y);
+ 	}
+ 	input_mt_sync_frame(input);
+ }
+ 
+ static void wacom_wac_finger_single_touch_report(struct wacom_wac *wacom_wac,
+ 		struct input_dev *input, bool touch)
+ {
+ 	struct hid_data *hid_data = &wacom_wac->hid_data;
+ 
+ 	if (touch) {
+ 		input_report_abs(input, ABS_X, hid_data->x);
+ 		input_report_abs(input, ABS_Y, hid_data->y);
+ 	}
+ 	input_report_key(input, BTN_TOUCH, touch);
+ }
+ 
+ static void wacom_wac_finger_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 	bool touch = wacom_wac->hid_data.tipswitch &&
+ 		     !wacom_wac->shared->stylus_in_proximity;
+ 	unsigned touch_max = wacom_wac->features.touch_max;
+ 
+ 	if (touch_max > 1)
+ 		wacom_wac_finger_mt_report(wacom_wac, input, touch);
+ 	else
+ 		wacom_wac_finger_single_touch_report(wacom_wac, input, touch);
+ 	input_sync(input);
+ 
+ 	/* keep touch state for pen event */
+ 	wacom_wac->shared->touch_down = touch;
+ }
+ 
+ #define WACOM_PEN_FIELD(f)	(((f)->logical == HID_DG_STYLUS) || \
+ 				 ((f)->physical == HID_DG_STYLUS) || \
+ 				 ((f)->application == HID_DG_PEN))
+ #define WACOM_FINGER_FIELD(f)	(((f)->logical == HID_DG_FINGER) || \
+ 				 ((f)->physical == HID_DG_FINGER) || \
+ 				 ((f)->application == HID_DG_TOUCHSCREEN))
+ 
+ void wacom_wac_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 
+ 	/* currently, only direct devices have proper hid report descriptors */
+ 	__set_bit(INPUT_PROP_DIRECT, input->propbit);
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_usage_mapping(hdev, field, usage);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_usage_mapping(hdev, field, usage);
+ }
+ 
+ int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 
+ 	if (wacom->wacom_wac.features.type != HID_GENERIC)
+ 		return 0;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_event(hdev, field, usage, value);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_event(hdev, field, usage, value);
+ 
+ 	return 0;
+ }
+ 
+ void wacom_wac_report(struct hid_device *hdev, struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_field *field = report->field[0];
+ 
+ 	if (wacom_wac->features.type != HID_GENERIC)
+ 		return;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_report(hdev, report);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_report(hdev, report);
+ }
+ 
++>>>>>>> b58ba1ba1af9 (HID: wacom: Initialize MT slots for generic devices at post_parse_hid)
  static int wacom_bpt_touch(struct wacom_wac *wacom)
  {
  	struct wacom_features *features = &wacom->features;
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
