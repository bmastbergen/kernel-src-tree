EDAC/mce_amd: Print syndrome register value on SMCA systems

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [edac] mce_amd: Print syndrome register value on SMCA systems (David Arcari) [1389383]
Rebuild_FUZZ: 95.58%
commit-author Yazen Ghannam <Yazen.Ghannam@amd.com>
commit b300e87300b68120aa5374341b252875a1cb6ea1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b300e873.failed

Print SyndV bit status and print the raw value of the MCA_SYND register.
Further decoding of the syndrome from struct mce.synd can be done in
other places where appropriate, e.g. DRAM ECC.

Boris: make the error stanza more compact by putting the error address
and syndrome on the same line:

  [Hardware Error]: Corrected error, no action required.
  [Hardware Error]: CPU:2 (17:0:0) MC4_STATUS[-|CE|-|PCC|AddrV|-|-|SyndV|CECC]: 0x96204100001e0117
  [Hardware Error]: Error Addr: 0x000000007f4c52e3, Syndrome: 0x0000000000000000
  [Hardware Error]: Invalid IP block specified.
  [Hardware Error]: cache level: L3/GEN, tx: DATA, mem-tx: RD

	Signed-off-by: Yazen Ghannam <Yazen.Ghannam@amd.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: http://lkml.kernel.org/r/1467633035-32080-2-git-send-email-Yazen.Ghannam@amd.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

(cherry picked from commit b300e87300b68120aa5374341b252875a1cb6ea1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/mce_amd.c
diff --cc drivers/edac/mce_amd.c
index 896ecd88aae5,057ece577800..000000000000
--- a/drivers/edac/mce_amd.c
+++ b/drivers/edac/mce_amd.c
@@@ -710,6 -820,177 +710,180 @@@ static void decode_mc6_mce(struct mce *
  	pr_emerg(HW_ERR "Corrupted MC6 MCE info?\n");
  }
  
++<<<<<<< HEAD
++=======
+ static void decode_f17h_core_errors(const char *ip_name, u8 xec,
+ 				   unsigned int mca_type)
+ {
+ 	const char * const *error_desc_array;
+ 	size_t len;
+ 
+ 	pr_emerg(HW_ERR "%s Error: ", ip_name);
+ 
+ 	switch (mca_type) {
+ 	case SMCA_LS:
+ 		error_desc_array = f17h_ls_mce_desc;
+ 		len = ARRAY_SIZE(f17h_ls_mce_desc) - 1;
+ 
+ 		if (xec == 0x4) {
+ 			pr_cont("Unrecognized LS MCA error code.\n");
+ 			return;
+ 		}
+ 		break;
+ 
+ 	case SMCA_IF:
+ 		error_desc_array = f17h_if_mce_desc;
+ 		len = ARRAY_SIZE(f17h_if_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_L2_CACHE:
+ 		error_desc_array = f17h_l2_mce_desc;
+ 		len = ARRAY_SIZE(f17h_l2_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_DE:
+ 		error_desc_array = f17h_de_mce_desc;
+ 		len = ARRAY_SIZE(f17h_de_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_EX:
+ 		error_desc_array = f17h_ex_mce_desc;
+ 		len = ARRAY_SIZE(f17h_ex_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_FP:
+ 		error_desc_array = f17h_fp_mce_desc;
+ 		len = ARRAY_SIZE(f17h_fp_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_L3_CACHE:
+ 		error_desc_array = f17h_l3_mce_desc;
+ 		len = ARRAY_SIZE(f17h_l3_mce_desc) - 1;
+ 		break;
+ 
+ 	default:
+ 		pr_cont("Corrupted MCA core error info.\n");
+ 		return;
+ 	}
+ 
+ 	if (xec > len) {
+ 		pr_cont("Unrecognized %s MCA bank error code.\n",
+ 			 amd_core_mcablock_names[mca_type]);
+ 		return;
+ 	}
+ 
+ 	pr_cont("%s.\n", error_desc_array[xec]);
+ }
+ 
+ static void decode_df_errors(u8 xec, unsigned int mca_type)
+ {
+ 	const char * const *error_desc_array;
+ 	size_t len;
+ 
+ 	pr_emerg(HW_ERR "Data Fabric Error: ");
+ 
+ 	switch (mca_type) {
+ 	case  SMCA_CS:
+ 		error_desc_array = f17h_cs_mce_desc;
+ 		len = ARRAY_SIZE(f17h_cs_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_PIE:
+ 		error_desc_array = f17h_pie_mce_desc;
+ 		len = ARRAY_SIZE(f17h_pie_mce_desc) - 1;
+ 		break;
+ 
+ 	default:
+ 		pr_cont("Corrupted MCA Data Fabric info.\n");
+ 		return;
+ 	}
+ 
+ 	if (xec > len) {
+ 		pr_cont("Unrecognized %s MCA bank error code.\n",
+ 			 amd_df_mcablock_names[mca_type]);
+ 		return;
+ 	}
+ 
+ 	pr_cont("%s.\n", error_desc_array[xec]);
+ }
+ 
+ /* Decode errors according to Scalable MCA specification */
+ static void decode_smca_errors(struct mce *m)
+ {
+ 	u32 addr = MSR_AMD64_SMCA_MCx_IPID(m->bank);
+ 	unsigned int hwid, mca_type, i;
+ 	u8 xec = XEC(m->status, xec_mask);
+ 	const char * const *error_desc_array;
+ 	const char *ip_name;
+ 	u32 low, high;
+ 	size_t len;
+ 
+ 	if (rdmsr_safe(addr, &low, &high)) {
+ 		pr_emerg(HW_ERR "Invalid IP block specified.\n");
+ 		return;
+ 	}
+ 
+ 	hwid = high & MCI_IPID_HWID;
+ 	mca_type = (high & MCI_IPID_MCATYPE) >> 16;
+ 
+ 	pr_emerg(HW_ERR "MC%d IPID value: 0x%08x%08x\n", m->bank, high, low);
+ 
+ 	/*
+ 	 * Based on hwid and mca_type values, decode errors from respective IPs.
+ 	 * Note: mca_type values make sense only in the context of an hwid.
+ 	 */
+ 	for (i = 0; i < ARRAY_SIZE(amd_hwids); i++)
+ 		if (amd_hwids[i].hwid == hwid)
+ 			break;
+ 
+ 	switch (i) {
+ 	case SMCA_F17H_CORE:
+ 		ip_name = (mca_type == SMCA_L3_CACHE) ?
+ 			  "L3 Cache" : "F17h Core";
+ 		return decode_f17h_core_errors(ip_name, xec, mca_type);
+ 		break;
+ 
+ 	case SMCA_DF:
+ 		return decode_df_errors(xec, mca_type);
+ 		break;
+ 
+ 	case SMCA_UMC:
+ 		error_desc_array = f17h_umc_mce_desc;
+ 		len = ARRAY_SIZE(f17h_umc_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_PB:
+ 		error_desc_array = f17h_pb_mce_desc;
+ 		len = ARRAY_SIZE(f17h_pb_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_PSP:
+ 		error_desc_array = f17h_psp_mce_desc;
+ 		len = ARRAY_SIZE(f17h_psp_mce_desc) - 1;
+ 		break;
+ 
+ 	case SMCA_SMU:
+ 		error_desc_array = f17h_smu_mce_desc;
+ 		len = ARRAY_SIZE(f17h_smu_mce_desc) - 1;
+ 		break;
+ 
+ 	default:
+ 		pr_emerg(HW_ERR "HWID:%d does not match any existing IPs.\n", hwid);
+ 		return;
+ 	}
+ 
+ 	ip_name = amd_hwids[i].name;
+ 	pr_emerg(HW_ERR "%s Error: ", ip_name);
+ 
+ 	if (xec > len) {
+ 		pr_cont("Unrecognized %s MCA bank error code.\n", ip_name);
+ 		return;
+ 	}
+ 
+ 	pr_cont("%s.\n", error_desc_array[xec]);
+ }
+ 
++>>>>>>> b300e87300b6 (EDAC/mce_amd: Print syndrome register value on SMCA systems)
  static inline void amd_decode_err_code(u16 ec)
  {
  	if (INT_ERROR(ec)) {
@@@ -793,6 -1074,17 +967,20 @@@ int amd_decode_mce(struct notifier_bloc
  			((m->status & MCI_STATUS_DEFERRED) ? "Deferred" : "-"),
  			((m->status & MCI_STATUS_POISON)   ? "Poison"   : "-"));
  
++<<<<<<< HEAD
++=======
+ 	if (boot_cpu_has(X86_FEATURE_SMCA)) {
+ 		u32 low, high;
+ 		u32 addr = MSR_AMD64_SMCA_MCx_CONFIG(m->bank);
+ 
+ 		pr_cont("|%s", ((m->status & MCI_STATUS_SYNDV) ? "SyndV" : "-"));
+ 
+ 		if (!rdmsr_safe(addr, &low, &high) &&
+ 		    (low & MCI_CONFIG_MCAX))
+ 			pr_cont("|%s", ((m->status & MCI_STATUS_TCC) ? "TCC" : "-"));
+ 	}
+ 
++>>>>>>> b300e87300b6 (EDAC/mce_amd: Print syndrome register value on SMCA systems)
  	/* do the two bits[14:13] together */
  	ecc = (m->status >> 45) & 0x3;
  	if (ecc)
@@@ -801,8 -1093,19 +989,22 @@@
  	pr_cont("]: 0x%016llx\n", m->status);
  
  	if (m->status & MCI_STATUS_ADDRV)
- 		pr_emerg(HW_ERR "MC%d Error Address: 0x%016llx\n", m->bank, m->addr);
+ 		pr_emerg(HW_ERR "Error Addr: 0x%016llx", m->addr);
+ 
++<<<<<<< HEAD
++=======
+ 	if (boot_cpu_has(X86_FEATURE_SMCA)) {
+ 		if (m->status & MCI_STATUS_SYNDV)
+ 			pr_cont(", Syndrome: 0x%016llx", m->synd);
+ 
+ 		pr_cont("\n");
+ 
+ 		decode_smca_errors(m);
+ 		goto err_code;
+ 	} else
+ 		pr_cont("\n");
  
++>>>>>>> b300e87300b6 (EDAC/mce_amd: Print syndrome register value on SMCA systems)
  	if (!fam_ops)
  		goto err_code;
  
* Unmerged path drivers/edac/mce_amd.c
