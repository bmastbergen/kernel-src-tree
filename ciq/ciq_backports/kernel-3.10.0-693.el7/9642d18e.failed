nohz: Affine unpinned timers to housekeepers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Vatika Harlalka <vatikaharlalka@gmail.com>
commit 9642d18eee2cd169b60c6ac0f20bda745b5a3d1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9642d18e.failed

The problem addressed in this patch is about affining unpinned
timers. Adaptive or Full Dynticks CPUs are currently disturbed
by unnecessary jitter due to firing of such timers on them.

This patch will affine timers to online CPUs which are not full
dynticks in NOHZ_FULL configured systems. It should not
introduce overhead in nohz full off case due to static keys.

	Signed-off-by: Vatika Harlalka <vatikaharlalka@gmail.com>
	Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
	Reviewed-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
	Acked-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Chris Metcalf <cmetcalf@ezchip.com>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1441119060-2230-2-git-send-email-fweisbec@gmail.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 9642d18eee2cd169b60c6ac0f20bda745b5a3d1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/tick.h
#	kernel/sched/core.c
diff --cc include/linux/tick.h
index 2503a03a1237,e312219ff823..000000000000
--- a/include/linux/tick.h
+++ b/include/linux/tick.h
@@@ -185,17 -141,29 +185,38 @@@ static inline bool tick_nohz_full_cpu(i
  	return cpumask_test_cpu(cpu, tick_nohz_full_mask);
  }
  
++<<<<<<< HEAD
 +extern void tick_nohz_init(void);
 +extern void __tick_nohz_full_check(void);
++=======
+ static inline void tick_nohz_full_add_cpus_to(struct cpumask *mask)
+ {
+ 	if (tick_nohz_full_enabled())
+ 		cpumask_or(mask, mask, tick_nohz_full_mask);
+ }
+ 
+ static inline int housekeeping_any_cpu(void)
+ {
+ 	return cpumask_any_and(housekeeping_mask, cpu_online_mask);
+ }
+ 
++>>>>>>> 9642d18eee2c (nohz: Affine unpinned timers to housekeepers)
  extern void tick_nohz_full_kick(void);
  extern void tick_nohz_full_kick_cpu(int cpu);
  extern void tick_nohz_full_kick_all(void);
 -extern void __tick_nohz_task_switch(void);
 +extern void __tick_nohz_task_switch(struct task_struct *tsk);
  #else
++<<<<<<< HEAD
 +static inline void tick_nohz_init(void) { }
++=======
+ static inline int housekeeping_any_cpu(void)
+ {
+ 	return smp_processor_id();
+ }
++>>>>>>> 9642d18eee2c (nohz: Affine unpinned timers to housekeepers)
  static inline bool tick_nohz_full_enabled(void) { return false; }
  static inline bool tick_nohz_full_cpu(int cpu) { return false; }
 -static inline void tick_nohz_full_add_cpus_to(struct cpumask *mask) { }
 +static inline void __tick_nohz_full_check(void) { }
  static inline void tick_nohz_full_kick_cpu(int cpu) { }
  static inline void tick_nohz_full_kick(void) { }
  static inline void tick_nohz_full_kick_all(void) { }
diff --cc kernel/sched/core.c
index 98e40872a037,0902e4d72671..000000000000
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@@ -588,10 -620,12 +588,16 @@@ void resched_cpu(int cpu
   */
  int get_nohz_timer_target(void)
  {
 -	int i, cpu = smp_processor_id();
 +	int cpu = smp_processor_id();
 +	int i;
  	struct sched_domain *sd;
  
++<<<<<<< HEAD
++=======
+ 	if (!idle_cpu(cpu) && is_housekeeping_cpu(cpu))
+ 		return cpu;
+ 
++>>>>>>> 9642d18eee2c (nohz: Affine unpinned timers to housekeepers)
  	rcu_read_lock();
  	for_each_domain(cpu, sd) {
  		for_each_cpu(i, sched_domain_span(sd)) {
* Unmerged path include/linux/tick.h
* Unmerged path kernel/sched/core.c
