crypto: algif_skcipher - Require setkey before accept(2)

jira LE-1907
cve CVE-2015-8970
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] algif_skcipher - Require setkey before accept(2) ("Bruno E. O. Meneguele") [1386234] {CVE-2015-8970}
Rebuild_FUZZ: 92.31%
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit dd504589577d8e8e70f51f997ad487a4cb6c026f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/dd504589.failed

Some cipher implementations will crash if you try to use them
without calling setkey first.  This patch adds a check so that
the accept(2) call will fail with -ENOKEY if setkey hasn't been
done on the socket yet.

	Cc: stable@vger.kernel.org
	Reported-by: Dmitry Vyukov <dvyukov@google.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Tested-by: Dmitry Vyukov <dvyukov@google.com>
(cherry picked from commit dd504589577d8e8e70f51f997ad487a4cb6c026f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/algif_skcipher.c
diff --cc crypto/algif_skcipher.c
index 83187f497c7c,f4431bc1ce43..000000000000
--- a/crypto/algif_skcipher.c
+++ b/crypto/algif_skcipher.c
@@@ -546,17 -755,51 +551,63 @@@ static struct proto_ops algif_skcipher_
  
  static void *skcipher_bind(const char *name, u32 type, u32 mask)
  {
++<<<<<<< HEAD
 +	return crypto_alloc_ablkcipher(name, type, mask);
++=======
+ 	struct skcipher_tfm *tfm;
+ 	struct crypto_skcipher *skcipher;
+ 
+ 	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);
+ 	if (!tfm)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	skcipher = crypto_alloc_skcipher(name, type, mask);
+ 	if (IS_ERR(skcipher)) {
+ 		kfree(tfm);
+ 		return ERR_CAST(skcipher);
+ 	}
+ 
+ 	tfm->skcipher = skcipher;
+ 
+ 	return tfm;
++>>>>>>> dd504589577d (crypto: algif_skcipher - Require setkey before accept(2))
  }
  
  static void skcipher_release(void *private)
  {
++<<<<<<< HEAD
 +	crypto_free_ablkcipher(private);
++=======
+ 	struct skcipher_tfm *tfm = private;
+ 
+ 	crypto_free_skcipher(tfm->skcipher);
+ 	kfree(tfm);
++>>>>>>> dd504589577d (crypto: algif_skcipher - Require setkey before accept(2))
  }
  
  static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
  {
++<<<<<<< HEAD
 +	return crypto_ablkcipher_setkey(private, key, keylen);
++=======
+ 	struct skcipher_tfm *tfm = private;
+ 	int err;
+ 
+ 	err = crypto_skcipher_setkey(tfm->skcipher, key, keylen);
+ 	tfm->has_key = !err;
+ 
+ 	return err;
+ }
+ 
+ static void skcipher_wait(struct sock *sk)
+ {
+ 	struct alg_sock *ask = alg_sk(sk);
+ 	struct skcipher_ctx *ctx = ask->private;
+ 	int ctr = 0;
+ 
+ 	while (atomic_read(&ctx->inflight) && ctr++ < 100)
+ 		msleep(100);
++>>>>>>> dd504589577d (crypto: algif_skcipher - Require setkey before accept(2))
  }
  
  static void skcipher_sock_destruct(struct sock *sk)
@@@ -575,20 -821,25 +626,37 @@@ static int skcipher_accept_parent(void 
  {
  	struct skcipher_ctx *ctx;
  	struct alg_sock *ask = alg_sk(sk);
++<<<<<<< HEAD
 +	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);
++=======
+ 	struct skcipher_tfm *tfm = private;
+ 	struct crypto_skcipher *skcipher = tfm->skcipher;
+ 	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);
+ 
+ 	if (!tfm->has_key)
+ 		return -ENOKEY;
++>>>>>>> dd504589577d (crypto: algif_skcipher - Require setkey before accept(2))
  
  	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
  	if (!ctx)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	ctx->iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),
++=======
+ 	ctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),
++>>>>>>> dd504589577d (crypto: algif_skcipher - Require setkey before accept(2))
  			       GFP_KERNEL);
  	if (!ctx->iv) {
  		sock_kfree_s(sk, ctx, len);
  		return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	memset(ctx->iv, 0, crypto_ablkcipher_ivsize(private));
++=======
+ 	memset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));
++>>>>>>> dd504589577d (crypto: algif_skcipher - Require setkey before accept(2))
  
  	INIT_LIST_HEAD(&ctx->tsgl);
  	ctx->len = len;
@@@ -600,9 -852,9 +668,15 @@@
  
  	ask->private = ctx;
  
++<<<<<<< HEAD
 +	ablkcipher_request_set_tfm(&ctx->req, private);
 +	ablkcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 +					af_alg_complete, &ctx->completion);
++=======
+ 	skcipher_request_set_tfm(&ctx->req, skcipher);
+ 	skcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+ 				      af_alg_complete, &ctx->completion);
++>>>>>>> dd504589577d (crypto: algif_skcipher - Require setkey before accept(2))
  
  	sk->sk_destruct = skcipher_sock_destruct;
  
* Unmerged path crypto/algif_skcipher.c
