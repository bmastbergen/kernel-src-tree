md/failfast: add failfast flag for md to be used by some personalities.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [md] failfast: add failfast flag for md to be used by some personalities (Jes Sorensen) [1380016]
Rebuild_FUZZ: 97.10%
commit-author NeilBrown <neilb@suse.com>
commit 688834e6ae6b21e3d98b5cf2586aa4a9b515c3a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/688834e6.failed

This patch just adds a 'failfast' per-device flag which can be stored
in v0.90 or v1.x metadata.
The flag is not used yet but the intent is that it can be used for
mirrored (raid1/raid10) arrays where low latency is more important
than keeping all devices on-line.

Setting the flag for a device effectively gives permission for that
device to be marked as Faulty and excluded from the array on the first
error.  The underlying driver will be directed not to retry requests
that result in failures.  There is a proviso that the device must not
be marked faulty if that would cause the array as a whole to fail, it
may only be marked Faulty if the array remains functional, but is
degraded.

Failures on read requests will cause the device to be marked
as Faulty immediately so that further reads will avoid that
device.  No attempt will be made to correct read errors by
over-writing with the correct data.

It is expected that if transient errors, such as cable unplug, are
possible, then something in user-space will revalidate failed
devices and re-add them when they appear to be working again.

	Signed-off-by: NeilBrown <neilb@suse.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 688834e6ae6b21e3d98b5cf2586aa4a9b515c3a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
#	drivers/md/md.h
#	include/uapi/linux/raid/md_p.h
diff --cc drivers/md/md.c
index 6cf58b727bcf,2cf0e89cc56c..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -2480,46 -2542,36 +2490,64 @@@ state_show(struct md_rdev *rdev, char *
  	unsigned long flags = ACCESS_ONCE(rdev->flags);
  
  	if (test_bit(Faulty, &flags) ||
 -	    (!test_bit(ExternalBbl, &flags) &&
 -	    rdev->badblocks.unacked_exist))
 -		len += sprintf(page+len, "faulty%s", sep);
 -	if (test_bit(In_sync, &flags))
 -		len += sprintf(page+len, "in_sync%s", sep);
 -	if (test_bit(Journal, &flags))
 -		len += sprintf(page+len, "journal%s", sep);
 -	if (test_bit(WriteMostly, &flags))
 -		len += sprintf(page+len, "write_mostly%s", sep);
 +	    rdev->badblocks.unacked_exist) {
 +		len+= sprintf(page+len, "%sfaulty",sep);
 +		sep = ",";
 +	}
 +	if (test_bit(In_sync, &flags)) {
 +		len += sprintf(page+len, "%sin_sync",sep);
 +		sep = ",";
 +	}
 +	if (test_bit(Journal, &flags)) {
 +		len += sprintf(page+len, "%sjournal",sep);
 +		sep = ",";
 +	}
 +	if (test_bit(WriteMostly, &flags)) {
 +		len += sprintf(page+len, "%swrite_mostly",sep);
 +		sep = ",";
 +	}
  	if (test_bit(Blocked, &flags) ||
  	    (rdev->badblocks.unacked_exist
 -	     && !test_bit(Faulty, &flags)))
 -		len += sprintf(page+len, "blocked%s", sep);
 +	     && !test_bit(Faulty, &flags))) {
 +		len += sprintf(page+len, "%sblocked", sep);
 +		sep = ",";
 +	}
  	if (!test_bit(Faulty, &flags) &&
  	    !test_bit(Journal, &flags) &&
++<<<<<<< HEAD
 +	    !test_bit(In_sync, &flags)) {
 +		len += sprintf(page+len, "%sspare", sep);
 +		sep = ",";
 +	}
 +	if (test_bit(WriteErrorSeen, &flags)) {
 +		len += sprintf(page+len, "%swrite_error", sep);
 +		sep = ",";
 +	}
 +	if (test_bit(WantReplacement, &flags)) {
 +		len += sprintf(page+len, "%swant_replacement", sep);
 +		sep = ",";
 +	}
 +	if (test_bit(Replacement, &flags)) {
 +		len += sprintf(page+len, "%sreplacement", sep);
 +		sep = ",";
 +	}
++=======
+ 	    !test_bit(In_sync, &flags))
+ 		len += sprintf(page+len, "spare%s", sep);
+ 	if (test_bit(WriteErrorSeen, &flags))
+ 		len += sprintf(page+len, "write_error%s", sep);
+ 	if (test_bit(WantReplacement, &flags))
+ 		len += sprintf(page+len, "want_replacement%s", sep);
+ 	if (test_bit(Replacement, &flags))
+ 		len += sprintf(page+len, "replacement%s", sep);
+ 	if (test_bit(ExternalBbl, &flags))
+ 		len += sprintf(page+len, "external_bbl%s", sep);
+ 	if (test_bit(FailFast, &flags))
+ 		len += sprintf(page+len, "failfast%s", sep);
+ 
+ 	if (len)
+ 		len -= strlen(sep);
++>>>>>>> 688834e6ae6b (md/failfast: add failfast flag for md to be used by some personalities.)
  
  	return len+sprintf(page+len, "\n");
  }
@@@ -6042,9 -6163,11 +6083,11 @@@ static int add_new_disk(struct mddev *m
  
  		if (info->state & (1<<MD_DISK_WRITEMOSTLY))
  			set_bit(WriteMostly, &rdev->flags);
+ 		if (info->state & (1<<MD_DISK_FAILFAST))
+ 			set_bit(FailFast, &rdev->flags);
  
  		if (!mddev->persistent) {
 -			pr_debug("md: nonpersistent superblock ...\n");
 +			printk(KERN_INFO "md: nonpersistent superblock ...\n");
  			rdev->sb_start = i_size_read(rdev->bdev->bd_inode) / 512;
  		} else
  			rdev->sb_start = calc_dev_sboffset(rdev);
diff --cc drivers/md/md.h
index 07747899ac17,bc6712ef8c81..000000000000
--- a/drivers/md/md.h
+++ b/drivers/md/md.h
@@@ -163,6 -162,21 +163,24 @@@ enum flag_bits 
  				 * Usually, this device should be faster
  				 * than other devices in the array
  				 */
++<<<<<<< HEAD
++=======
+ 	ClusterRemove,
+ 	RemoveSynchronized,	/* synchronize_rcu() was called after
+ 				 * this device was known to be faulty,
+ 				 * so it is safe to remove without
+ 				 * another synchronize_rcu() call.
+ 				 */
+ 	ExternalBbl,            /* External metadata provides bad
+ 				 * block management for a disk
+ 				 */
+ 	FailFast,		/* Minimal retries should be attempted on
+ 				 * this device, so use REQ_FAILFAST_DEV.
+ 				 * Also don't try to repair failed reads.
+ 				 * It is expects that no bad block log
+ 				 * is present.
+ 				 */
++>>>>>>> 688834e6ae6b (md/failfast: add failfast flag for md to be used by some personalities.)
  };
  
  static inline int is_badblock(struct md_rdev *rdev, sector_t s, int sectors,
diff --cc include/uapi/linux/raid/md_p.h
index 8f0b1c61eefb,9930f3e9040f..000000000000
--- a/include/uapi/linux/raid/md_p.h
+++ b/include/uapi/linux/raid/md_p.h
@@@ -77,6 -78,16 +77,19 @@@
  #define MD_DISK_ACTIVE		1 /* disk is running or spare disk */
  #define MD_DISK_SYNC		2 /* disk is in sync with the raid set */
  #define MD_DISK_REMOVED		3 /* disk is in sync with the raid set */
++<<<<<<< HEAD
++=======
+ #define MD_DISK_CLUSTER_ADD     4 /* Initiate a disk add across the cluster
+ 				   * For clustered enviroments only.
+ 				   */
+ #define MD_DISK_CANDIDATE	5 /* disk is added as spare (local) until confirmed
+ 				   * For clustered enviroments only.
+ 				   */
+ #define MD_DISK_FAILFAST	10 /* Send REQ_FAILFAST if there are multiple
+ 				    * devices available - and don't try to
+ 				    * correct read errors.
+ 				    */
++>>>>>>> 688834e6ae6b (md/failfast: add failfast flag for md to be used by some personalities.)
  
  #define	MD_DISK_WRITEMOSTLY	9 /* disk is "write-mostly" is RAID1 config.
  				   * read requests will only be sent here in
* Unmerged path drivers/md/md.c
* Unmerged path drivers/md/md.h
* Unmerged path include/uapi/linux/raid/md_p.h
