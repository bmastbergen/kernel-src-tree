libnl: fix help of _64bit functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit 11a99573079e15f11499ae8d21b07e3e3257fff1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/11a99573.failed

Fix typo and describe 'padattr'.

Fixes: 089bf1a6a924 ("libnl: add more helpers to align attributes on 64-bit")
	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 11a99573079e15f11499ae8d21b07e3e3257fff1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/nlattr.c
diff --cc lib/nlattr.c
index d6f970f3c800,fce1e9afc6d9..000000000000
--- a/lib/nlattr.c
+++ b/lib/nlattr.c
@@@ -340,6 -355,30 +340,33 @@@ struct nlattr *__nla_reserve(struct sk_
  EXPORT_SYMBOL(__nla_reserve);
  
  /**
++<<<<<<< HEAD
++=======
+  * __nla_reserve_64bit - reserve room for attribute on the skb and align it
+  * @skb: socket buffer to reserve room on
+  * @attrtype: attribute type
+  * @attrlen: length of attribute payload
+  * @padattr: attribute type for the padding
+  *
+  * Adds a netlink attribute header to a socket buffer and reserves
+  * room for the payload but does not copy it. It also ensure that this
+  * attribute will have a 64-bit aligned nla_data() area.
+  *
+  * The caller is responsible to ensure that the skb provides enough
+  * tailroom for the attribute header and payload.
+  */
+ struct nlattr *__nla_reserve_64bit(struct sk_buff *skb, int attrtype,
+ 				   int attrlen, int padattr)
+ {
+ 	if (nla_need_padding_for_64bit(skb))
+ 		nla_align_64bit(skb, padattr);
+ 
+ 	return __nla_reserve(skb, attrtype, attrlen);
+ }
+ EXPORT_SYMBOL(__nla_reserve_64bit);
+ 
+ /**
++>>>>>>> 11a99573079e (libnl: fix help of _64bit functions)
   * __nla_reserve_nohdr - reserve room for attribute without header
   * @skb: socket buffer to reserve room on
   * @attrlen: length of attribute payload
@@@ -382,6 -421,36 +409,39 @@@ struct nlattr *nla_reserve(struct sk_bu
  EXPORT_SYMBOL(nla_reserve);
  
  /**
++<<<<<<< HEAD
++=======
+  * nla_reserve_64bit - reserve room for attribute on the skb and align it
+  * @skb: socket buffer to reserve room on
+  * @attrtype: attribute type
+  * @attrlen: length of attribute payload
+  * @padattr: attribute type for the padding
+  *
+  * Adds a netlink attribute header to a socket buffer and reserves
+  * room for the payload but does not copy it. It also ensure that this
+  * attribute will have a 64-bit aligned nla_data() area.
+  *
+  * Returns NULL if the tailroom of the skb is insufficient to store
+  * the attribute header and payload.
+  */
+ struct nlattr *nla_reserve_64bit(struct sk_buff *skb, int attrtype, int attrlen,
+ 				 int padattr)
+ {
+ 	size_t len;
+ 
+ 	if (nla_need_padding_for_64bit(skb))
+ 		len = nla_total_size_64bit(attrlen);
+ 	else
+ 		len = nla_total_size(attrlen);
+ 	if (unlikely(skb_tailroom(skb) < len))
+ 		return NULL;
+ 
+ 	return __nla_reserve_64bit(skb, attrtype, attrlen, padattr);
+ }
+ EXPORT_SYMBOL(nla_reserve_64bit);
+ 
+ /**
++>>>>>>> 11a99573079e (libnl: fix help of _64bit functions)
   * nla_reserve_nohdr - reserve room for attribute without header
   * @skb: socket buffer to reserve room on
   * @attrlen: length of attribute payload
@@@ -421,6 -490,27 +481,30 @@@ void __nla_put(struct sk_buff *skb, in
  EXPORT_SYMBOL(__nla_put);
  
  /**
++<<<<<<< HEAD
++=======
+  * __nla_put_64bit - Add a netlink attribute to a socket buffer and align it
+  * @skb: socket buffer to add attribute to
+  * @attrtype: attribute type
+  * @attrlen: length of attribute payload
+  * @data: head of attribute payload
+  * @padattr: attribute type for the padding
+  *
+  * The caller is responsible to ensure that the skb provides enough
+  * tailroom for the attribute header and payload.
+  */
+ void __nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,
+ 		     const void *data, int padattr)
+ {
+ 	struct nlattr *nla;
+ 
+ 	nla = __nla_reserve_64bit(skb, attrtype, attrlen, padattr);
+ 	memcpy(nla_data(nla), data, attrlen);
+ }
+ EXPORT_SYMBOL(__nla_put_64bit);
+ 
+ /**
++>>>>>>> 11a99573079e (libnl: fix help of _64bit functions)
   * __nla_put_nohdr - Add a netlink attribute without header
   * @skb: socket buffer to add attribute to
   * @attrlen: length of attribute payload
@@@ -459,6 -549,34 +543,37 @@@ int nla_put(struct sk_buff *skb, int at
  EXPORT_SYMBOL(nla_put);
  
  /**
++<<<<<<< HEAD
++=======
+  * nla_put_64bit - Add a netlink attribute to a socket buffer and align it
+  * @skb: socket buffer to add attribute to
+  * @attrtype: attribute type
+  * @attrlen: length of attribute payload
+  * @data: head of attribute payload
+  * @padattr: attribute type for the padding
+  *
+  * Returns -EMSGSIZE if the tailroom of the skb is insufficient to store
+  * the attribute header and payload.
+  */
+ int nla_put_64bit(struct sk_buff *skb, int attrtype, int attrlen,
+ 		  const void *data, int padattr)
+ {
+ 	size_t len;
+ 
+ 	if (nla_need_padding_for_64bit(skb))
+ 		len = nla_total_size_64bit(attrlen);
+ 	else
+ 		len = nla_total_size(attrlen);
+ 	if (unlikely(skb_tailroom(skb) < len))
+ 		return -EMSGSIZE;
+ 
+ 	__nla_put_64bit(skb, attrtype, attrlen, data, padattr);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(nla_put_64bit);
+ 
+ /**
++>>>>>>> 11a99573079e (libnl: fix help of _64bit functions)
   * nla_put_nohdr - Add a netlink attribute without header
   * @skb: socket buffer to add attribute to
   * @attrlen: length of attribute payload
* Unmerged path lib/nlattr.c
