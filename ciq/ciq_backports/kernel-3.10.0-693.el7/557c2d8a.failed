fs/proc/task_mmu.c: update m->version in the main loop in m_start()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] proc/task_mmu.c: update m->version in the main loop in m_start() (Aaron Tomlin) [1425895]
Rebuild_FUZZ: 97.71%
commit-author Oleg Nesterov <oleg@redhat.com>
commit 557c2d8a73dc078817ba6949697ceb8c0f3f7362
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/557c2d8a.failed

Change the main loop in m_start() to update m->version. Mostly for
consistency, but this can help to avoid the same loop if the very
1st ->show() fails due to seq_overflow().

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Cyrill Gorcunov <gorcunov@openvz.org>
	Cc: "Eric W. Biederman" <ebiederm@xmission.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 557c2d8a73dc078817ba6949697ceb8c0f3f7362)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/task_mmu.c
diff --cc fs/proc/task_mmu.c
index 09ca18a42ac3,34d93a1cdeec..000000000000
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@@ -181,41 -171,29 +181,56 @@@ static void *m_start(struct seq_file *m
  	mm = priv->mm;
  	if (!mm || !atomic_inc_not_zero(&mm->mm_users))
  		return NULL;
 -
  	down_read(&mm->mmap_sem);
 +
 +	tail_vma = get_gate_vma(mm);
 +	priv->tail_vma = tail_vma;
  	hold_task_mempolicy(priv);
 -	priv->tail_vma = get_gate_vma(mm);
 +	/* Start with last addr hint */
 +	vma = find_vma(mm, last_addr);
 +	if (last_addr && vma) {
 +		vma = vma->vm_next;
 +		goto out;
 +	}
  
 -	if (last_addr) {
 -		vma = find_vma(mm, last_addr);
 -		if (vma && (vma = m_next_vma(priv, vma)))
 -			return vma;
++<<<<<<< HEAD
 +	/*
 +	 * Check the vma index is within the range and do
 +	 * sequential scan until m_index.
 +	 */
 +	vma = NULL;
 +	if ((unsigned long)l < mm->map_count) {
 +		vma = mm->mmap;
 +		while (l-- && vma)
 +			vma = vma->vm_next;
 +		goto out;
  	}
  
 +	if (l != mm->map_count)
 +		tail_vma = NULL; /* After gate vma */
 +
 +out:
 +	if (vma)
 +		return vma;
 +
 +	/* End of vmas has been reached */
 +	m->version = (tail_vma != NULL)? 0: -1UL;
 +	if (tail_vma)
 +		return tail_vma;
++=======
+ 	m->version = 0;
+ 	if (pos < mm->map_count) {
+ 		for (vma = mm->mmap; pos; pos--) {
+ 			m->version = vma->vm_start;
+ 			vma = vma->vm_next;
+ 		}
+ 		return vma;
+ 	}
+ 
+ 	/* we do not bother to update m->version in this case */
+ 	if (pos == mm->map_count && priv->tail_vma)
+ 		return priv->tail_vma;
++>>>>>>> 557c2d8a73dc (fs/proc/task_mmu.c: update m->version in the main loop in m_start())
  
  	vma_stop(priv);
  	return NULL;
* Unmerged path fs/proc/task_mmu.c
