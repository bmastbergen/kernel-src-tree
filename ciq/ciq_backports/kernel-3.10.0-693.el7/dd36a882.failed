autofs: change autofs4_wait() to take struct path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ian Kent <ikent@redhat.com>
commit dd36a882e7ade2c642f8711426ad8e4b7009aaae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/dd36a882.failed

In order to use the functions path_is_mountpoint() and path_has_submounts()
autofs needs to pass a struct path in several places.

Now change autofs4_wait() to take a struct path instead of a struct
dentry.

Link: http://lkml.kernel.org/r/20161011053413.27645.84666.stgit@pluto.themaw.net
	Signed-off-by: Ian Kent <raven@themaw.net>
	Cc: Al Viro <viro@ZenIV.linux.org.uk>
	Cc: Eric W. Biederman <ebiederm@xmission.com>
	Cc: Omar Sandoval <osandov@osandov.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit dd36a882e7ade2c642f8711426ad8e4b7009aaae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/autofs4/autofs_i.h
#	fs/autofs4/expire.c
#	fs/autofs4/root.c
#	fs/autofs4/waitq.c
diff --cc fs/autofs4/autofs_i.h
index adf967ffeaa6,c885daae68c8..000000000000
--- a/fs/autofs4/autofs_i.h
+++ b/fs/autofs4/autofs_i.h
@@@ -223,8 -217,9 +223,14 @@@ static inline int autofs_prepare_pipe(s
  
  /* Queue management functions */
  
++<<<<<<< HEAD
 +int autofs4_wait(struct autofs_sb_info *,struct dentry *, enum autofs_notify);
 +int autofs4_wait_release(struct autofs_sb_info *,autofs_wqt_t,int);
++=======
+ int autofs4_wait(struct autofs_sb_info *,
+ 		 const struct path *, enum autofs_notify);
+ int autofs4_wait_release(struct autofs_sb_info *, autofs_wqt_t, int);
++>>>>>>> dd36a882e7ad (autofs: change autofs4_wait() to take struct path)
  void autofs4_catatonic_mode(struct autofs_sb_info *);
  
  static inline u32 autofs4_get_dev(struct autofs_sb_info *sbi)
diff --cc fs/autofs4/expire.c
index 5b220e9acb0a,9c352da24444..000000000000
--- a/fs/autofs4/expire.c
+++ b/fs/autofs4/expire.c
@@@ -509,17 -509,27 +509,17 @@@ int autofs4_expire_wait(const struct pa
  	if (rcu_walk)
  		return -ECHILD;
  
 -retry:
  	spin_lock(&sbi->fs_lock);
 -	state = ino->flags & (AUTOFS_INF_WANT_EXPIRE | AUTOFS_INF_EXPIRING);
 -	if (state == AUTOFS_INF_WANT_EXPIRE) {
 -		spin_unlock(&sbi->fs_lock);
 -		/*
 -		 * Possibly being selected for expire, wait until
 -		 * it's selected or not.
 -		 */
 -		schedule_timeout_uninterruptible(HZ/10);
 -		goto retry;
 -	}
 -	if (state & AUTOFS_INF_EXPIRING) {
 +	if (ino->flags & AUTOFS_INF_EXPIRING) {
  		spin_unlock(&sbi->fs_lock);
  
 -		pr_debug("waiting for expire %p name=%pd\n", dentry, dentry);
 +		DPRINTK("waiting for expire %p name=%.*s",
 +			 dentry, dentry->d_name.len, dentry->d_name.name);
  
- 		status = autofs4_wait(sbi, dentry, NFY_NONE);
+ 		status = autofs4_wait(sbi, path, NFY_NONE);
  		wait_for_completion(&ino->expire_complete);
  
 -		pr_debug("expire done status=%d\n", status);
 +		DPRINTK("expire done status=%d", status);
  
  		if (d_unhashed(dentry))
  			return -EAGAIN;
@@@ -582,10 -593,12 +582,17 @@@ int autofs4_do_expire_multi(struct supe
  
  	if (dentry) {
  		struct autofs_info *ino = autofs4_dentry_ino(dentry);
+ 		struct path path = { .mnt = mnt, .dentry = dentry };
  
  		/* This is synchronous because it makes the daemon a
++<<<<<<< HEAD
 +                   little easier */
 +		ret = autofs4_wait(sbi, dentry, NFY_EXPIRE);
++=======
+ 		 * little easier
+ 		 */
+ 		ret = autofs4_wait(sbi, &path, NFY_EXPIRE);
++>>>>>>> dd36a882e7ad (autofs: change autofs4_wait() to take struct path)
  
  		spin_lock(&sbi->fs_lock);
  		/* avoid rapid-fire expire attempts if expiry fails */
diff --cc fs/autofs4/root.c
index b538a83d1c8b,0e9881552881..000000000000
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@@ -279,10 -278,9 +279,16 @@@ static int autofs4_mount_wait(const str
  	if (ino->flags & AUTOFS_INF_PENDING) {
  		if (rcu_walk)
  			return -ECHILD;
++<<<<<<< HEAD
 +		DPRINTK("waiting for mount name=%.*s",
 +			dentry->d_name.len, dentry->d_name.name);
 +		status = autofs4_wait(sbi, dentry, NFY_MOUNT);
 +		DPRINTK("mount wait done status=%d", status);
++=======
+ 		pr_debug("waiting for mount name=%pd\n", path->dentry);
+ 		status = autofs4_wait(sbi, path, NFY_MOUNT);
+ 		pr_debug("mount wait done status=%d\n", status);
++>>>>>>> dd36a882e7ad (autofs: change autofs4_wait() to take struct path)
  	}
  	ino->last_used = jiffies;
  	return status;
diff --cc fs/autofs4/waitq.c
index 71b3baf9aaca,38ef973f80e9..000000000000
--- a/fs/autofs4/waitq.c
+++ b/fs/autofs4/waitq.c
@@@ -340,9 -344,10 +340,15 @@@ static int validate_request(struct auto
  	return 1;
  }
  
++<<<<<<< HEAD
 +int autofs4_wait(struct autofs_sb_info *sbi, struct dentry *dentry,
 +		enum autofs_notify notify)
++=======
+ int autofs4_wait(struct autofs_sb_info *sbi,
+ 		 const struct path *path, enum autofs_notify notify)
++>>>>>>> dd36a882e7ad (autofs: change autofs4_wait() to take struct path)
  {
+ 	struct dentry *dentry = path->dentry;
  	struct autofs_wait_queue *wq;
  	struct qstr qstr;
  	char *name;
* Unmerged path fs/autofs4/autofs_i.h
* Unmerged path fs/autofs4/expire.c
* Unmerged path fs/autofs4/root.c
* Unmerged path fs/autofs4/waitq.c
