x86, boot: Move CPU flags out of cpucheck

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] boot: Move CPU flags out of cpucheck (Baoquan He) [1290840]
Rebuild_FUZZ: 93.51%
commit-author Kees Cook <keescook@chromium.org>
commit dd78b97367bd575918204cc89107c1479d3fc1a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/dd78b973.failed

Refactor the CPU flags handling out of the cpucheck routines so that
they can be reused by the future ASLR routines (in order to detect CPU
features like RDRAND and RDTSC).

This reworks has_eflag() and has_fpu() to be used on both 32-bit and
64-bit, and refactors the calls to cpuid to make them PIC-safe on 32-bit.

	Signed-off-by: Kees Cook <keescook@chromium.org>
Link: http://lkml.kernel.org/r/1381450698-28710-2-git-send-email-keescook@chromium.org
	Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
(cherry picked from commit dd78b97367bd575918204cc89107c1479d3fc1a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/boot.h
#	arch/x86/boot/cpucheck.c
diff --cc arch/x86/boot/boot.h
index c25ff94e1c02,50f8c5e0f37e..000000000000
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@@ -294,17 -306,8 +293,19 @@@ static inline int cmdline_find_option_b
  	return __cmdline_find_option_bool(cmd_line_ptr, option);
  }
  
- 
  /* cpu.c, cpucheck.c */
++<<<<<<< HEAD
 +struct cpu_features {
 +	int level;		/* Family, or 64 for x86-64 */
 +	int family;		/* Family, always */
 +	int model;
 +	u32 flags[NCAPINTS];
 +};
 +extern struct cpu_features cpu;
++=======
++>>>>>>> dd78b97367bd (x86, boot: Move CPU flags out of cpucheck)
  int check_cpu(int *cpu_level_ptr, int *req_level_ptr, u32 **err_flags_ptr);
 +int check_knl_erratum(void);
  int validate_cpu(void);
  
  /* early_serial_console.c */
diff --cc arch/x86/boot/cpucheck.c
index 00999f011949,e1f3c166a512..000000000000
--- a/arch/x86/boot/cpucheck.c
+++ b/arch/x86/boot/cpucheck.c
@@@ -28,10 -27,7 +28,8 @@@
  #include <asm/processor-flags.h>
  #include <asm/required-features.h>
  #include <asm/msr-index.h>
 +#include "string.h"
  
- struct cpu_features cpu;
- static u32 cpu_vendor[3];
  static u32 err_flags[NCAPINTS];
  
  static const int req_level = CONFIG_X86_MINIMUM_CPU_FAMILY;
@@@ -71,99 -67,6 +69,102 @@@ static int is_transmeta(void
  	       cpu_vendor[2] == A32('M', 'x', '8', '6');
  }
  
++<<<<<<< HEAD
 +static int is_intel(void)
 +{
 +	return cpu_vendor[0] == A32('G', 'e', 'n', 'u') &&
 +		cpu_vendor[1] == A32('i', 'n', 'e', 'I') &&
 +		cpu_vendor[2] == A32('n', 't', 'e', 'l');
 +}
 +
 +
 +static int has_fpu(void)
 +{
 +	u16 fcw = -1, fsw = -1;
 +	u32 cr0;
 +
 +	asm("movl %%cr0,%0" : "=r" (cr0));
 +	if (cr0 & (X86_CR0_EM|X86_CR0_TS)) {
 +		cr0 &= ~(X86_CR0_EM|X86_CR0_TS);
 +		asm volatile("movl %0,%%cr0" : : "r" (cr0));
 +	}
 +
 +	asm volatile("fninit ; fnstsw %0 ; fnstcw %1"
 +		     : "+m" (fsw), "+m" (fcw));
 +
 +	return fsw == 0 && (fcw & 0x103f) == 0x003f;
 +}
 +
 +static int has_eflag(u32 mask)
 +{
 +	u32 f0, f1;
 +
 +	asm("pushfl ; "
 +	    "pushfl ; "
 +	    "popl %0 ; "
 +	    "movl %0,%1 ; "
 +	    "xorl %2,%1 ; "
 +	    "pushl %1 ; "
 +	    "popfl ; "
 +	    "pushfl ; "
 +	    "popl %1 ; "
 +	    "popfl"
 +	    : "=&r" (f0), "=&r" (f1)
 +	    : "ri" (mask));
 +
 +	return !!((f0^f1) & mask);
 +}
 +
 +static void get_flags(void)
 +{
 +	u32 max_intel_level, max_amd_level;
 +	u32 tfms;
 +
 +	if (has_fpu())
 +		set_bit(X86_FEATURE_FPU, cpu.flags);
 +
 +	if (has_eflag(X86_EFLAGS_ID)) {
 +		asm("cpuid"
 +		    : "=a" (max_intel_level),
 +		      "=b" (cpu_vendor[0]),
 +		      "=d" (cpu_vendor[1]),
 +		      "=c" (cpu_vendor[2])
 +		    : "a" (0));
 +
 +		if (max_intel_level >= 0x00000001 &&
 +		    max_intel_level <= 0x0000ffff) {
 +			asm("cpuid"
 +			    : "=a" (tfms),
 +			      "=c" (cpu.flags[4]),
 +			      "=d" (cpu.flags[0])
 +			    : "a" (0x00000001)
 +			    : "ebx");
 +			cpu.level = (tfms >> 8) & 15;
 +			cpu.family = cpu.level;
 +			cpu.model = (tfms >> 4) & 15;
 +			if (cpu.level >= 6)
 +				cpu.model += ((tfms >> 16) & 0xf) << 4;
 +		}
 +
 +		asm("cpuid"
 +		    : "=a" (max_amd_level)
 +		    : "a" (0x80000000)
 +		    : "ebx", "ecx", "edx");
 +
 +		if (max_amd_level >= 0x80000001 &&
 +		    max_amd_level <= 0x8000ffff) {
 +			u32 eax = 0x80000001;
 +			asm("cpuid"
 +			    : "+a" (eax),
 +			      "=c" (cpu.flags[6]),
 +			      "=d" (cpu.flags[1])
 +			    : : "ebx");
 +		}
 +	}
 +}
 +
++=======
++>>>>>>> dd78b97367bd (x86, boot: Move CPU flags out of cpucheck)
  /* Returns a bitmask of which words we have error bits in */
  static int check_flags(void)
  {
diff --git a/arch/x86/boot/Makefile b/arch/x86/boot/Makefile
index e7fb72133865..13408eba8ecb 100644
--- a/arch/x86/boot/Makefile
+++ b/arch/x86/boot/Makefile
@@ -22,7 +22,7 @@ targets		:= vmlinux.bin setup.bin setup.elf bzImage
 targets		+= fdimage fdimage144 fdimage288 image.iso mtools.conf
 subdir-		:= compressed
 
-setup-y		+= a20.o bioscall.o cmdline.o copy.o cpu.o cpucheck.o
+setup-y		+= a20.o bioscall.o cmdline.o copy.o cpu.o cpuflags.o cpucheck.o
 setup-y		+= early_serial_console.o edd.o header.o main.o mca.o memory.o
 setup-y		+= pm.o pmjump.o printf.o regs.o string.o tty.o video.o
 setup-y		+= video-mode.o version.o
* Unmerged path arch/x86/boot/boot.h
diff --git a/arch/x86/boot/compressed/Makefile b/arch/x86/boot/compressed/Makefile
index 1dc427850e11..73214b133bc4 100644
--- a/arch/x86/boot/compressed/Makefile
+++ b/arch/x86/boot/compressed/Makefile
@@ -28,7 +28,7 @@ HOST_EXTRACFLAGS += -I$(srctree)/tools/include
 
 VMLINUX_OBJS = $(obj)/vmlinux.lds $(obj)/head_$(BITS).o $(obj)/misc.o \
 	$(obj)/string.o $(obj)/cmdline.o $(obj)/early_serial_console.o \
-	$(obj)/piggy.o
+	$(obj)/piggy.o $(obj)/cpuflags.o
 
 $(obj)/eboot.o: KBUILD_CFLAGS += -fshort-wchar -mno-red-zone
 
diff --git a/arch/x86/boot/compressed/cpuflags.c b/arch/x86/boot/compressed/cpuflags.c
new file mode 100644
index 000000000000..931cba6a4bb0
--- /dev/null
+++ b/arch/x86/boot/compressed/cpuflags.c
@@ -0,0 +1,12 @@
+#ifdef CONFIG_RANDOMIZE_BASE
+
+#include "../cpuflags.c"
+
+bool has_cpuflag(int flag)
+{
+	get_flags();
+
+	return test_bit(flag, cpu.flags);
+}
+
+#endif
* Unmerged path arch/x86/boot/cpucheck.c
diff --git a/arch/x86/boot/cpuflags.c b/arch/x86/boot/cpuflags.c
new file mode 100644
index 000000000000..b02544a2bce0
--- /dev/null
+++ b/arch/x86/boot/cpuflags.c
@@ -0,0 +1,104 @@
+#include <linux/types.h>
+#include "bitops.h"
+
+#include <asm/processor-flags.h>
+#include <asm/required-features.h>
+#include <asm/msr-index.h>
+#include "cpuflags.h"
+
+struct cpu_features cpu;
+u32 cpu_vendor[3];
+
+static bool loaded_flags;
+
+static int has_fpu(void)
+{
+	u16 fcw = -1, fsw = -1;
+	unsigned long cr0;
+
+	asm volatile("mov %%cr0,%0" : "=r" (cr0));
+	if (cr0 & (X86_CR0_EM|X86_CR0_TS)) {
+		cr0 &= ~(X86_CR0_EM|X86_CR0_TS);
+		asm volatile("mov %0,%%cr0" : : "r" (cr0));
+	}
+
+	asm volatile("fninit ; fnstsw %0 ; fnstcw %1"
+		     : "+m" (fsw), "+m" (fcw));
+
+	return fsw == 0 && (fcw & 0x103f) == 0x003f;
+}
+
+int has_eflag(unsigned long mask)
+{
+	unsigned long f0, f1;
+
+	asm volatile("pushf	\n\t"
+		     "pushf	\n\t"
+		     "pop %0	\n\t"
+		     "mov %0,%1	\n\t"
+		     "xor %2,%1	\n\t"
+		     "push %1	\n\t"
+		     "popf	\n\t"
+		     "pushf	\n\t"
+		     "pop %1	\n\t"
+		     "popf"
+		     : "=&r" (f0), "=&r" (f1)
+		     : "ri" (mask));
+
+	return !!((f0^f1) & mask);
+}
+
+/* Handle x86_32 PIC using ebx. */
+#if defined(__i386__) && defined(__PIC__)
+# define EBX_REG "=r"
+#else
+# define EBX_REG "=b"
+#endif
+
+static inline void cpuid(u32 id, u32 *a, u32 *b, u32 *c, u32 *d)
+{
+	asm volatile(".ifnc %%ebx,%3 ; movl  %%ebx,%3 ; .endif	\n\t"
+		     "cpuid					\n\t"
+		     ".ifnc %%ebx,%3 ; xchgl %%ebx,%3 ; .endif	\n\t"
+		    : "=a" (*a), "=c" (*c), "=d" (*d), EBX_REG (*b)
+		    : "a" (id)
+	);
+}
+
+void get_flags(void)
+{
+	u32 max_intel_level, max_amd_level;
+	u32 tfms;
+	u32 ignored;
+
+	if (loaded_flags)
+		return;
+	loaded_flags = true;
+
+	if (has_fpu())
+		set_bit(X86_FEATURE_FPU, cpu.flags);
+
+	if (has_eflag(X86_EFLAGS_ID)) {
+		cpuid(0x0, &max_intel_level, &cpu_vendor[0], &cpu_vendor[2],
+		      &cpu_vendor[1]);
+
+		if (max_intel_level >= 0x00000001 &&
+		    max_intel_level <= 0x0000ffff) {
+			cpuid(0x1, &tfms, &ignored, &cpu.flags[4],
+			      &cpu.flags[0]);
+			cpu.level = (tfms >> 8) & 15;
+			cpu.model = (tfms >> 4) & 15;
+			if (cpu.level >= 6)
+				cpu.model += ((tfms >> 16) & 0xf) << 4;
+		}
+
+		cpuid(0x80000000, &max_amd_level, &ignored, &ignored,
+		      &ignored);
+
+		if (max_amd_level >= 0x80000001 &&
+		    max_amd_level <= 0x8000ffff) {
+			cpuid(0x80000001, &ignored, &ignored, &cpu.flags[6],
+			      &cpu.flags[1]);
+		}
+	}
+}
diff --git a/arch/x86/boot/cpuflags.h b/arch/x86/boot/cpuflags.h
new file mode 100644
index 000000000000..9bb4e25f7317
--- /dev/null
+++ b/arch/x86/boot/cpuflags.h
@@ -0,0 +1,19 @@
+#ifndef BOOT_CPUFLAGS_H
+#define BOOT_CPUFLAGS_H
+
+#include <asm/cpufeature.h>
+#include <asm/processor-flags.h>
+
+struct cpu_features {
+	int level;		/* Family, or 64 for x86-64 */
+	int model;
+	u32 flags[NCAPINTS];
+};
+
+extern struct cpu_features cpu;
+extern u32 cpu_vendor[3];
+
+int has_eflag(unsigned long mask);
+void get_flags(void);
+
+#endif
