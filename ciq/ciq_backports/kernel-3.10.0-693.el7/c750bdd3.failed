drm/i915: Reject HDMI 12bpc if the sink doesn't indicate support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [drm] i915: Reject HDMI 12bpc if the sink doesn't indicate support (Rob Clark) [1422186]
Rebuild_FUZZ: 96.77%
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit c750bdd3e7e204cc88b32806c3864487a03cd84b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c750bdd3.failed

Check that the sink really declared 12bpc support before we enable it.
This should not actually never happen since it's mandatory for HDMI
sinks to support 12bpc if they support any deep color modes. But
reality disagrees with the theory and there are actually sinks in
the wild that violate the spec.

v2: Fix the output_types check
    Update commit message to state that these things are in fact real

	Cc: stable@vger.kernel.org
	Cc: Nicholas Sielicki <nicholas.sielicki@gmail.com>
Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=99250
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/20170213175818.24958-1-ville.syrjala@linux.intel.com
	Reviewed-by: Shashank Sharma <shashank.sharma@intel.com>
(cherry picked from commit c750bdd3e7e204cc88b32806c3864487a03cd84b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_hdmi.c
diff --cc drivers/gpu/drm/i915/intel_hdmi.c
index 3ddb4fac53fa,3eec74ca5116..000000000000
--- a/drivers/gpu/drm/i915/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/intel_hdmi.c
@@@ -1273,34 -1297,34 +1273,62 @@@ intel_hdmi_mode_valid(struct drm_connec
  
  static bool hdmi_12bpc_possible(struct intel_crtc_state *crtc_state)
  {
++<<<<<<< HEAD
 +	struct drm_device *dev = crtc_state->base.crtc->dev;
 +	struct drm_atomic_state *state;
 +	struct intel_encoder *encoder;
 +	struct drm_connector *connector;
 +	struct drm_connector_state *connector_state;
 +	int count = 0, count_hdmi = 0;
 +	int i;
 +
 +	if (HAS_GMCH_DISPLAY(dev))
++=======
+ 	struct drm_i915_private *dev_priv =
+ 		to_i915(crtc_state->base.crtc->dev);
+ 	struct drm_atomic_state *state = crtc_state->base.state;
+ 	struct drm_connector_state *connector_state;
+ 	struct drm_connector *connector;
+ 	int i;
+ 
+ 	if (HAS_GMCH_DISPLAY(dev_priv))
++>>>>>>> c750bdd3e7e2 (drm/i915: Reject HDMI 12bpc if the sink doesn't indicate support)
  		return false;
  
 +	state = crtc_state->base.state;
 +
 +	for_each_connector_in_state(state, connector, connector_state, i) {
 +		if (connector_state->crtc != crtc_state->base.crtc)
 +			continue;
 +
 +		encoder = to_intel_encoder(connector_state->best_encoder);
 +
 +		count_hdmi += encoder->type == INTEL_OUTPUT_HDMI;
 +		count++;
 +	}
 +
  	/*
  	 * HDMI 12bpc affects the clocks, so it's only possible
  	 * when not cloning with other encoder types.
  	 */
++<<<<<<< HEAD
 +	return count_hdmi > 0 && count_hdmi == count;
++=======
+ 	if (crtc_state->output_types != 1 << INTEL_OUTPUT_HDMI)
+ 		return false;
+ 
+ 	for_each_connector_in_state(state, connector, connector_state, i) {
+ 		const struct drm_display_info *info = &connector->display_info;
+ 
+ 		if (connector_state->crtc != crtc_state->base.crtc)
+ 			continue;
+ 
+ 		if ((info->edid_hdmi_dc_modes & DRM_EDID_HDMI_DC_36) == 0)
+ 			return false;
+ 	}
+ 
+ 	return true;
++>>>>>>> c750bdd3e7e2 (drm/i915: Reject HDMI 12bpc if the sink doesn't indicate support)
  }
  
  bool intel_hdmi_compute_config(struct intel_encoder *encoder,
* Unmerged path drivers/gpu/drm/i915/intel_hdmi.c
