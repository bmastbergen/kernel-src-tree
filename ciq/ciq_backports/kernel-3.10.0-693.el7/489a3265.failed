i40e: move all updates for VLAN mode into i40e_sync_vsi_filters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 489a32650721b0e1e25283257cacb3a337014794
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/489a3265.failed

In a similar fashion to how we handled exiting VLAN mode, move the logic
in i40e_vsi_add_vlan into i40e_sync_vsi_filters. Extract this logic into
its own function for ease of understanding as it will become quite
complex.

The new function, i40e_correct_mac_vlan_filters() correctly updates all
filters for when we need to enter VLAN mode, exit VLAN mode, and also
enforces the PVID when assigned.

Call i40e_correct_mac_vlan_filters from i40e_sync_vsi_filters passing it
the number of active VLAN filters, and the two temporary lists.

Remove the function for updating VLAN=0 filters from i40e_vsi_add_vlan.

The end result is that the logic for entering and exiting VLAN mode is
in one location which has the most knowledge about all filters. This
ensures that we always correctly have the non-VLAN filters assigned to
VID=0 or VID=-1 regardless of how we ended up getting to this result.

Additionally this enforces the PVID at sync time so that we know for
certain that an assigned PVID results in only filters with that PVID
will be added to the firmware.

Change-ID: I895cee81e9c92d0a16baee38bd0ca51bbb14e372
	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 489a32650721b0e1e25283257cacb3a337014794)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 2f00e31ef630,da4cbe32eb86..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -1223,72 -1227,137 +1223,179 @@@ bool i40e_is_vsi_in_vlan(struct i40e_vs
  }
  
  /**
++<<<<<<< HEAD
 + * i40e_put_mac_in_vlan - Make macvlan filters from macaddrs and vlans
 + * @vsi: the VSI to be searched
 + * @macaddr: the mac address to be filtered
 + * @is_vf: true if it is a VF
 + * @is_netdev: true if it is a netdev
++=======
+  * i40e_correct_mac_vlan_filters - Correct non-VLAN filters if necessary
+  * @vsi: the VSI to configure
+  * @tmp_add_list: list of filters ready to be added
+  * @tmp_del_list: list of filters ready to be deleted
+  * @vlan_filters: the number of active VLAN filters
+  *
+  * Update VLAN=0 and VLAN=-1 (I40E_VLAN_ANY) filters properly so that they
+  * behave as expected. If we have any active VLAN filters remaining or about
+  * to be added then we need to update non-VLAN filters to be marked as VLAN=0
+  * so that they only match against untagged traffic. If we no longer have any
+  * active VLAN filters, we need to make all non-VLAN filters marked as VLAN=-1
+  * so that they match against both tagged and untagged traffic. In this way,
+  * we ensure that we correctly receive the desired traffic. This ensures that
+  * when we have an active VLAN we will receive only untagged traffic and
+  * traffic matching active VLANs. If we have no active VLANs then we will
+  * operate in non-VLAN mode and receive all traffic, tagged or untagged.
+  *
+  * Finally, in a similar fashion, this function also corrects filters when
+  * there is an active PVID assigned to this VSI.
+  *
+  * In case of memory allocation failure return -ENOMEM. Otherwise, return 0.
+  *
+  * This function is only expected to be called from within
+  * i40e_sync_vsi_filters.
+  *
+  * NOTE: This function expects to be called while under the
+  * mac_filter_hash_lock
+  */
+ static int i40e_correct_mac_vlan_filters(struct i40e_vsi *vsi,
+ 					 struct hlist_head *tmp_add_list,
+ 					 struct hlist_head *tmp_del_list,
+ 					 int vlan_filters)
+ {
+ 	struct i40e_mac_filter *f, *add_head;
+ 	struct hlist_node *h;
+ 	int bkt, new_vlan;
+ 
+ 	/* To determine if a particular filter needs to be replaced we
+ 	 * have the three following conditions:
+ 	 *
+ 	 * a) if we have a PVID assigned, then all filters which are
+ 	 *    not marked as VLAN=PVID must be replaced with filters that
+ 	 *    are.
+ 	 * b) otherwise, if we have any active VLANS, all filters
+ 	 *    which are marked as VLAN=-1 must be replaced with
+ 	 *    filters marked as VLAN=0
+ 	 * c) finally, if we do not have any active VLANS, all filters
+ 	 *    which are marked as VLAN=0 must be replaced with filters
+ 	 *    marked as VLAN=-1
+ 	 */
+ 
+ 	/* Update the filters about to be added in place */
+ 	hlist_for_each_entry(f, tmp_add_list, hlist) {
+ 		if (vsi->info.pvid && f->vlan != vsi->info.pvid)
+ 			f->vlan = vsi->info.pvid;
+ 		else if (vlan_filters && f->vlan == I40E_VLAN_ANY)
+ 			f->vlan = 0;
+ 		else if (!vlan_filters && f->vlan == 0)
+ 			f->vlan = I40E_VLAN_ANY;
+ 	}
+ 
+ 	/* Update the remaining active filters */
+ 	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
+ 		/* Combine the checks for whether a filter needs to be changed
+ 		 * and then determine the new VLAN inside the if block, in
+ 		 * order to avoid duplicating code for adding the new filter
+ 		 * then deleting the old filter.
+ 		 */
+ 		if ((vsi->info.pvid && f->vlan != vsi->info.pvid) ||
+ 		    (vlan_filters && f->vlan == I40E_VLAN_ANY) ||
+ 		    (!vlan_filters && f->vlan == 0)) {
+ 			/* Determine the new vlan we will be adding */
+ 			if (vsi->info.pvid)
+ 				new_vlan = vsi->info.pvid;
+ 			else if (vlan_filters)
+ 				new_vlan = 0;
+ 			else
+ 				new_vlan = I40E_VLAN_ANY;
+ 
+ 			/* Create the new filter */
+ 			add_head = i40e_add_filter(vsi, f->macaddr, new_vlan);
+ 			if (!add_head)
+ 				return -ENOMEM;
+ 
+ 			/* Put the replacement filter into the add list */
+ 			hash_del(&add_head->hlist);
+ 			hlist_add_head(&add_head->hlist, tmp_add_list);
+ 
+ 			/* Put the original filter into the delete list */
+ 			f->state = I40E_FILTER_REMOVE;
+ 			hash_del(&f->hlist);
+ 			hlist_add_head(&f->hlist, tmp_del_list);
+ 		}
+ 	}
+ 
+ 	vsi->has_vlan_filter = !!vlan_filters;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * i40e_rm_default_mac_filter - Remove the default MAC filter set by NVM
+  * @vsi: the PF Main VSI - inappropriate for any other VSI
+  * @macaddr: the MAC address
++>>>>>>> 489a32650721 (i40e: move all updates for VLAN mode into i40e_sync_vsi_filters)
   *
 - * Remove whatever filter the firmware set up so the driver can manage
 - * its own filtering intelligently.
 + * Goes through all the macvlan filters and adds a
 + * macvlan filter for each unique vlan that already exists
 + *
 + * Returns first filter found on success, else NULL
   **/
 -static void i40e_rm_default_mac_filter(struct i40e_vsi *vsi, u8 *macaddr)
 +struct i40e_mac_filter *i40e_put_mac_in_vlan(struct i40e_vsi *vsi, u8 *macaddr,
 +					     bool is_vf, bool is_netdev)
  {
 -	struct i40e_aqc_remove_macvlan_element_data element;
 -	struct i40e_pf *pf = vsi->back;
 +	struct i40e_mac_filter *f;
  
 -	/* Only appropriate for the PF main VSI */
 -	if (vsi->type != I40E_VSI_MAIN)
 -		return;
 +	list_for_each_entry(f, &vsi->mac_filter_list, list) {
 +		if (vsi->info.pvid)
 +			f->vlan = le16_to_cpu(vsi->info.pvid);
 +		if (!i40e_find_filter(vsi, macaddr, f->vlan,
 +				      is_vf, is_netdev)) {
 +			if (!i40e_add_filter(vsi, macaddr, f->vlan,
 +					     is_vf, is_netdev))
 +				return NULL;
 +		}
 +	}
  
 -	memset(&element, 0, sizeof(element));
 -	ether_addr_copy(element.mac_addr, macaddr);
 -	element.vlan_tag = 0;
 -	/* Ignore error returns, some firmware does it this way... */
 -	element.flags = I40E_AQC_MACVLAN_DEL_PERFECT_MATCH;
 -	i40e_aq_remove_macvlan(&pf->hw, vsi->seid, &element, 1, NULL);
 +	return list_first_entry_or_null(&vsi->mac_filter_list,
 +					struct i40e_mac_filter, list);
 +}
  
 -	memset(&element, 0, sizeof(element));
 -	ether_addr_copy(element.mac_addr, macaddr);
 -	element.vlan_tag = 0;
 -	/* ...and some firmware does it this way. */
 -	element.flags = I40E_AQC_MACVLAN_DEL_PERFECT_MATCH |
 -			I40E_AQC_MACVLAN_DEL_IGNORE_VLAN;
 -	i40e_aq_remove_macvlan(&pf->hw, vsi->seid, &element, 1, NULL);
 +/**
 + * i40e_del_mac_all_vlan - Remove a MAC filter from all VLANS
 + * @vsi: the VSI to be searched
 + * @macaddr: the mac address to be removed
 + * @is_vf: true if it is a VF
 + * @is_netdev: true if it is a netdev
 + *
 + * Removes a given MAC address from a VSI, regardless of VLAN
 + *
 + * Returns 0 for success, or error
 + **/
 +int i40e_del_mac_all_vlan(struct i40e_vsi *vsi, u8 *macaddr,
 +			  bool is_vf, bool is_netdev)
 +{
 +	struct i40e_mac_filter *f = NULL;
 +	int changed = 0;
 +
 +	WARN(!spin_is_locked(&vsi->mac_filter_list_lock),
 +	     "Missing mac_filter_list_lock\n");
 +	list_for_each_entry(f, &vsi->mac_filter_list, list) {
 +		if ((ether_addr_equal(macaddr, f->macaddr)) &&
 +		    (is_vf == f->is_vf) &&
 +		    (is_netdev == f->is_netdev)) {
 +			f->counter--;
 +			changed = 1;
 +			if (f->counter == 0)
 +				f->state = I40E_FILTER_REMOVE;
 +		}
 +	}
 +	if (changed) {
 +		vsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;
 +		vsi->back->flags |= I40E_FLAG_FILTER_SYNC;
 +		return 0;
 +	}
 +	return -ENOENT;
  }
  
  /**
@@@ -1791,9 -2014,11 +1898,14 @@@ i40e_update_filter_state(int count
   **/
  int i40e_sync_vsi_filters(struct i40e_vsi *vsi)
  {
 -	struct hlist_head tmp_add_list, tmp_del_list;
 -	struct i40e_mac_filter *f, *add_head = NULL;
 +	struct i40e_mac_filter *f, *ftmp, *add_head = NULL;
 +	struct list_head tmp_add_list, tmp_del_list;
  	struct i40e_hw *hw = &vsi->back->hw;
++<<<<<<< HEAD
++=======
+ 	unsigned int failed_filters = 0;
+ 	unsigned int vlan_filters = 0;
++>>>>>>> 489a32650721 (i40e: move all updates for VLAN mode into i40e_sync_vsi_filters)
  	bool promisc_changed = false;
  	char vsi_name[16] = "PF";
  	int filter_list_len = 0;
@@@ -1832,22 -2057,38 +1944,42 @@@
  	if (vsi->flags & I40E_VSI_FLAG_FILTER_CHANGED) {
  		vsi->flags &= ~I40E_VSI_FLAG_FILTER_CHANGED;
  
 -		spin_lock_bh(&vsi->mac_filter_hash_lock);
 +		spin_lock_bh(&vsi->mac_filter_list_lock);
  		/* Create a list of filters to delete. */
 -		hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
 +		list_for_each_entry_safe(f, ftmp, &vsi->mac_filter_list, list) {
  			if (f->state == I40E_FILTER_REMOVE) {
 +				WARN_ON(f->counter != 0);
  				/* Move the element into temporary del_list */
 -				hash_del(&f->hlist);
 -				hlist_add_head(&f->hlist, &tmp_del_list);
 -
 -				/* Avoid counting removed filters */
 -				continue;
 +				list_move_tail(&f->list, &tmp_del_list);
 +				vsi->active_filters--;
  			}
  			if (f->state == I40E_FILTER_NEW) {
 -				hash_del(&f->hlist);
 -				hlist_add_head(&f->hlist, &tmp_add_list);
 +				WARN_ON(f->counter == 0);
 +				/* Move the element into temporary add_list */
 +				list_move_tail(&f->list, &tmp_add_list);
  			}
++<<<<<<< HEAD
 +		}
 +		spin_unlock_bh(&vsi->mac_filter_list_lock);
++=======
+ 
+ 			/* Count the number of active (current and new) VLAN
+ 			 * filters we have now. Does not count filters which
+ 			 * are marked for deletion.
+ 			 */
+ 			if (f->vlan > 0)
+ 				vlan_filters++;
+ 		}
+ 
+ 		retval = i40e_correct_mac_vlan_filters(vsi,
+ 						       &tmp_add_list,
+ 						       &tmp_del_list,
+ 						       vlan_filters);
+ 		if (retval)
+ 			goto err_no_memory_locked;
+ 
+ 		spin_unlock_bh(&vsi->mac_filter_hash_lock);
++>>>>>>> 489a32650721 (i40e: move all updates for VLAN mode into i40e_sync_vsi_filters)
  	}
  
  	/* Now process 'del_list' outside the lock */
@@@ -1934,7 -2152,7 +2066,11 @@@
  		del_list = NULL;
  	}
  
++<<<<<<< HEAD
 +	if (!list_empty(&tmp_add_list)) {
++=======
+ 	if (!hlist_empty(&tmp_add_list)) {
++>>>>>>> 489a32650721 (i40e: move all updates for VLAN mode into i40e_sync_vsi_filters)
  		/* Do all the adds now. */
  		filter_list_len = hw->aq.asq_buf_size /
  			       sizeof(struct i40e_aqc_add_macvlan_element_data);
@@@ -2319,35 -2539,28 +2455,36 @@@ static void i40e_vlan_rx_register(struc
  }
  
  /**
 - * i40e_add_vlan_all_mac - Add a MAC/VLAN filter for each existing MAC address
 + * i40e_vsi_add_vlan - Add vsi membership for given vlan
   * @vsi: the vsi being configured
   * @vid: vlan id to be added (0 = untagged only , -1 = any)
 - *
 - * This is a helper function for adding a new MAC/VLAN filter with the
 - * specified VLAN for each existing MAC address already in the hash table.
 - * This function does *not* perform any accounting to update filters based on
 - * VLAN mode.
 - *
 - * NOTE: this function expects to be called while under the
 - * mac_filter_hash_lock
   **/
 -int i40e_add_vlan_all_mac(struct i40e_vsi *vsi, s16 vid)
 +int i40e_vsi_add_vlan(struct i40e_vsi *vsi, s16 vid)
  {
 -	struct i40e_mac_filter *f, *add_f;
 -	struct hlist_node *h;
 -	int bkt;
 +	struct i40e_mac_filter *f, *ftmp, *add_f;
 +	bool is_netdev, is_vf;
  
 -	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
 -		if (f->state == I40E_FILTER_REMOVE)
 -			continue;
 -		add_f = i40e_add_filter(vsi, f->macaddr, vid);
 +	is_vf = (vsi->type == I40E_VSI_SRIOV);
 +	is_netdev = !!(vsi->netdev);
 +
 +	/* Locked once because all functions invoked below iterates list*/
 +	spin_lock_bh(&vsi->mac_filter_list_lock);
 +
 +	if (is_netdev) {
 +		add_f = i40e_add_filter(vsi, vsi->netdev->dev_addr, vid,
 +					is_vf, is_netdev);
 +		if (!add_f) {
 +			dev_info(&vsi->back->pdev->dev,
 +				 "Could not add vlan filter %d for %pM\n",
 +				 vid, vsi->netdev->dev_addr);
 +			spin_unlock_bh(&vsi->mac_filter_list_lock);
 +			return -ENOMEM;
 +		}
 +	}
 +
++<<<<<<< HEAD
 +	list_for_each_entry_safe(f, ftmp, &vsi->mac_filter_list, list) {
 +		add_f = i40e_add_filter(vsi, f->macaddr, vid, is_vf, is_netdev);
  		if (!add_f) {
  			dev_info(&vsi->back->pdev->dev,
  				 "Could not add vlan filter %d for %pM\n",
@@@ -2357,53 -2569,24 +2494,73 @@@
  		}
  	}
  
 +	/* Now if we add a vlan tag, make sure to check if it is the first
 +	 * tag (i.e. a "tag" -1 does exist) and if so replace the -1 "tag"
 +	 * with 0, so we now accept untagged and specified tagged traffic
 +	 * (and not all tags along with untagged)
 +	 */
 +	if (vid > 0) {
 +		if (is_netdev && i40e_find_filter(vsi, vsi->netdev->dev_addr,
 +						  I40E_VLAN_ANY,
 +						  is_vf, is_netdev)) {
 +			i40e_del_filter(vsi, vsi->netdev->dev_addr,
 +					I40E_VLAN_ANY, is_vf, is_netdev);
 +			add_f = i40e_add_filter(vsi, vsi->netdev->dev_addr, 0,
 +						is_vf, is_netdev);
 +			if (!add_f) {
 +				dev_info(&vsi->back->pdev->dev,
 +					 "Could not add filter 0 for %pM\n",
 +					 vsi->netdev->dev_addr);
 +				spin_unlock_bh(&vsi->mac_filter_list_lock);
 +				return -ENOMEM;
 +			}
 +		}
 +	}
 +
 +	/* Do not assume that I40E_VLAN_ANY should be reset to VLAN 0 */
 +	if (vid > 0 && !vsi->info.pvid) {
 +		list_for_each_entry_safe(f, ftmp, &vsi->mac_filter_list, list) {
 +			if (!i40e_find_filter(vsi, f->macaddr, I40E_VLAN_ANY,
 +					      is_vf, is_netdev))
 +				continue;
 +			i40e_del_filter(vsi, f->macaddr, I40E_VLAN_ANY,
 +					is_vf, is_netdev);
 +			add_f = i40e_add_filter(vsi, f->macaddr,
 +						0, is_vf, is_netdev);
 +			if (!add_f) {
 +				dev_info(&vsi->back->pdev->dev,
 +					 "Could not add filter 0 for %pM\n",
 +					f->macaddr);
 +				spin_unlock_bh(&vsi->mac_filter_list_lock);
 +				return -ENOMEM;
 +			}
 +		}
 +	}
 +
 +	/* Make sure to release before sync_vsi_filter because that
 +	 * function will lock/unlock as necessary
 +	 */
 +	spin_unlock_bh(&vsi->mac_filter_list_lock);
++=======
+ 	return 0;
+ }
+ 
+ /**
+  * i40e_vsi_add_vlan - Add VSI membership for given VLAN
+  * @vsi: the VSI being configured
+  * @vid: VLAN id to be added (0 = untagged only , -1 = any)
+  **/
+ int i40e_vsi_add_vlan(struct i40e_vsi *vsi, s16 vid)
+ {
+ 	int err;
+ 
+ 	/* Locked once because all functions invoked below iterates list*/
+ 	spin_lock_bh(&vsi->mac_filter_hash_lock);
+ 	err = i40e_add_vlan_all_mac(vsi, vid);
+ 	spin_unlock_bh(&vsi->mac_filter_hash_lock);
+ 	if (err)
+ 		return err;
++>>>>>>> 489a32650721 (i40e: move all updates for VLAN mode into i40e_sync_vsi_filters)
  
  	/* schedule our worker thread which will take care of
  	 * applying the new filter changes
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
