flow_dissector: do not break if ports are not needed in flowlabel

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jiri Pirko <jiri@resnulli.us>
commit 12c227ec89a70c14e3efcf102c5babece381e172
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/12c227ec.failed

This restored previous behaviour. If caller does not want ports to be
filled, we should not break.

Fixes: 06635a35d13d ("flow_dissect: use programable dissector in skb_flow_dissect and friends")
	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 12c227ec89a70c14e3efcf102c5babece381e172)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index fbf58a98e819,1f2d89300b1a..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -160,16 -185,52 +160,63 @@@ ipv6
  			return false;
  
  		ip_proto = iph->nexthdr;
 +		flow->src = (__force __be32)ipv6_addr_hash(&iph->saddr);
 +		flow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);
  		nhoff += sizeof(struct ipv6hdr);
  
++<<<<<<< HEAD
 +		/* skip the flow label processing if skb is NULL.  The
 +		 * assumption here is that if there is no skb we are not
 +		 * looking for flow info as much as we are length.
 +		 */
 +		if (!skb)
 +			break;
++=======
+ 		if (skb_flow_dissector_uses_key(flow_dissector,
+ 						FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS)) {
+ 			key_addrs = skb_flow_dissector_target(flow_dissector,
+ 							      FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS,
+ 							      target_container);
+ 
+ 			key_addrs->src = (__force __be32)ipv6_addr_hash(&iph->saddr);
+ 			key_addrs->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);
+ 			goto flow_label;
+ 		}
+ 		if (skb_flow_dissector_uses_key(flow_dissector,
+ 						FLOW_DISSECTOR_KEY_IPV6_ADDRS)) {
+ 			struct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;
+ 
+ 			key_ipv6_addrs = skb_flow_dissector_target(flow_dissector,
+ 								   FLOW_DISSECTOR_KEY_IPV6_ADDRS,
+ 								   target_container);
+ 
+ 			memcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));
+ 			goto flow_label;
+ 		}
+ 		break;
+ flow_label:
+ 		flow_label = ip6_flowlabel(iph);
+ 		if (flow_label) {
+ 			/* Awesome, IPv6 packet has a flow label so we can
+ 			 * use that to represent the ports without any
+ 			 * further dissection.
+ 			 */
+ 
+ 			key_basic->n_proto = proto;
+ 			key_basic->ip_proto = ip_proto;
+ 			key_basic->thoff = (u16)nhoff;
+ 
+ 			if (skb_flow_dissector_uses_key(flow_dissector,
+ 							FLOW_DISSECTOR_KEY_PORTS)) {
+ 				key_ports = skb_flow_dissector_target(flow_dissector,
+ 								      FLOW_DISSECTOR_KEY_PORTS,
+ 								      target_container);
+ 				key_ports->ports = flow_label;
+ 			}
+ 
+ 			return true;
+ 		}
++>>>>>>> 12c227ec89a7 (flow_dissector: do not break if ports are not needed in flowlabel)
  
  		break;
  	}
* Unmerged path net/core/flow_dissector.c
