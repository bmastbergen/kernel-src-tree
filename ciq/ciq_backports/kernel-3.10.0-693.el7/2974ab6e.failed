net/mlx5: Improve driver log messages

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Improve driver log messages (Don Dutile) [1385330 1417285]
Rebuild_FUZZ: 94.29%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 2974ab6e8bd8ad06d30ed471b91f8ff7aa6debd8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2974ab6e.failed

Remove duplicate pci dev name printing in mlx5_core_err.
Use mlx5_core_{warn,info,err} where possible to have the pci info in the
driver log messages.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Parvi Kaustubhi <parvik@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
(cherry picked from commit 2974ab6e8bd8ad06d30ed471b91f8ff7aa6debd8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index e67f03869c45,7c4935993b99..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -330,24 -295,26 +330,34 @@@ __esw_fdb_set_vport_rule(struct mlx5_es
  			    MLX5_MATCH_OUTER_HEADERS);
  	struct mlx5_flow_rule *flow_rule = NULL;
  	struct mlx5_flow_destination dest;
 -	struct mlx5_flow_spec *spec;
 -	void *mv_misc = NULL;
 -	void *mc_misc = NULL;
  	u8 *dmac_v = NULL;
  	u8 *dmac_c = NULL;
 -
 +	u32 *match_v;
 +	u32 *match_c;
 +
++<<<<<<< HEAD
 +	match_v = kzalloc(MLX5_ST_SZ_BYTES(fte_match_param), GFP_KERNEL);
 +	match_c = kzalloc(MLX5_ST_SZ_BYTES(fte_match_param), GFP_KERNEL);
 +	if (!match_v || !match_c) {
 +		pr_warn("FDB: Failed to alloc match parameters\n");
 +		goto out;
++=======
+ 	if (rx_rule)
+ 		match_header |= MLX5_MATCH_MISC_PARAMETERS;
+ 
+ 	spec = mlx5_vzalloc(sizeof(*spec));
+ 	if (!spec) {
+ 		esw_warn(esw->dev, "FDB: Failed to alloc match parameters\n");
+ 		return NULL;
++>>>>>>> 2974ab6e8bd8 (net/mlx5: Improve driver log messages)
  	}
 -	dmac_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,
 +
 +	dmac_v = MLX5_ADDR_OF(fte_match_param, match_v,
  			      outer_headers.dmac_47_16);
 -	dmac_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,
 +	dmac_c = MLX5_ADDR_OF(fte_match_param, match_c,
  			      outer_headers.dmac_47_16);
  
 -	if (match_header & MLX5_MATCH_OUTER_HEADERS) {
 +	if (match_header == MLX5_MATCH_OUTER_HEADERS) {
  		ether_addr_copy(dmac_v, mac_v);
  		ether_addr_copy(dmac_c, mac_c);
  	}
@@@ -358,16 -334,14 +368,22 @@@
  	esw_debug(esw->dev,
  		  "\tFDB add rule dmac_v(%pM) dmac_c(%pM) -> vport(%d)\n",
  		  dmac_v, dmac_c, vport);
 -	spec->match_criteria_enable = match_header;
  	flow_rule =
 -		mlx5_add_flow_rule(esw->fdb_table.fdb, spec,
 +		mlx5_add_flow_rule(esw->fdb_table.fdb,
 +				   match_header,
 +				   match_c,
 +				   match_v,
  				   MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,
  				   0, &dest);
++<<<<<<< HEAD
 +	if (IS_ERR_OR_NULL(flow_rule)) {
 +		pr_warn(
 +			"FDB: Failed to add flow rule: dmac_v(%pM) dmac_c(%pM) -> vport(%d), err(%ld)\n",
++=======
+ 	if (IS_ERR(flow_rule)) {
+ 		esw_warn(esw->dev,
+ 			 "FDB: Failed to add flow rule: dmac_v(%pM) dmac_c(%pM) -> vport(%d), err(%ld)\n",
++>>>>>>> 2974ab6e8bd8 (net/mlx5: Improve driver log messages)
  			 dmac_v, dmac_c, vport, PTR_ERR(flow_rule));
  		flow_rule = NULL;
  	}
@@@ -1072,25 -1298,51 +1088,61 @@@ static int esw_vport_ingress_config(str
  			 vport->vport, err);
  		goto out;
  	}
 +	MLX5_SET_TO_ONES(fte_match_param, match_c, outer_headers.vlan_tag);
 +	MLX5_SET_TO_ONES(fte_match_param, match_v, outer_headers.vlan_tag);
  
++<<<<<<< HEAD
++=======
+ 	if (vport->vlan || vport->qos)
+ 		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.vlan_tag);
+ 
+ 	if (vport->spoofchk) {
+ 		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.smac_47_16);
+ 		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.smac_15_0);
+ 		smac_v = MLX5_ADDR_OF(fte_match_param,
+ 				      spec->match_value,
+ 				      outer_headers.smac_47_16);
+ 		ether_addr_copy(smac_v, smac);
+ 	}
+ 
+ 	spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
+ 	vport->ingress.allow_rule =
+ 		mlx5_add_flow_rule(vport->ingress.acl, spec,
+ 				   MLX5_FLOW_CONTEXT_ACTION_ALLOW,
+ 				   0, NULL);
+ 	if (IS_ERR(vport->ingress.allow_rule)) {
+ 		err = PTR_ERR(vport->ingress.allow_rule);
+ 		esw_warn(esw->dev,
+ 			 "vport[%d] configure ingress allow rule, err(%d)\n",
+ 			 vport->vport, err);
+ 		vport->ingress.allow_rule = NULL;
+ 		goto out;
+ 	}
+ 
+ 	memset(spec, 0, sizeof(*spec));
++>>>>>>> 2974ab6e8bd8 (net/mlx5: Improve driver log messages)
  	vport->ingress.drop_rule =
 -		mlx5_add_flow_rule(vport->ingress.acl, spec,
 +		mlx5_add_flow_rule(vport->ingress.acl,
 +				   MLX5_MATCH_OUTER_HEADERS,
 +				   match_c,
 +				   match_v,
  				   MLX5_FLOW_CONTEXT_ACTION_DROP,
  				   0, NULL);
 -	if (IS_ERR(vport->ingress.drop_rule)) {
 +	if (IS_ERR_OR_NULL(vport->ingress.drop_rule)) {
  		err = PTR_ERR(vport->ingress.drop_rule);
++<<<<<<< HEAD
 +		pr_warn("vport[%d] configure ingress rules, err(%d)\n",
 +			vport->vport, err);
++=======
+ 		esw_warn(esw->dev,
+ 			 "vport[%d] configure ingress drop rule, err(%d)\n",
+ 			 vport->vport, err);
++>>>>>>> 2974ab6e8bd8 (net/mlx5: Improve driver log messages)
  		vport->ingress.drop_rule = NULL;
 -		goto out;
  	}
 -
  out:
 -	if (err)
 -		esw_vport_cleanup_ingress_rules(esw, vport);
 -	kvfree(spec);
 +	kfree(match_v);
 +	kfree(match_c);
  	return err;
  }
  
@@@ -1126,40 -1374,36 +1178,42 @@@ static int esw_vport_egress_config(stru
  	}
  
  	/* Allowed vlan rule */
 -	MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.vlan_tag);
 -	MLX5_SET_TO_ONES(fte_match_param, spec->match_value, outer_headers.vlan_tag);
 -	MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.first_vid);
 -	MLX5_SET(fte_match_param, spec->match_value, outer_headers.first_vid, vport->vlan);
 +	MLX5_SET_TO_ONES(fte_match_param, match_c, outer_headers.vlan_tag);
 +	MLX5_SET_TO_ONES(fte_match_param, match_v, outer_headers.vlan_tag);
 +	MLX5_SET_TO_ONES(fte_match_param, match_c, outer_headers.first_vid);
 +	MLX5_SET(fte_match_param, match_v, outer_headers.first_vid, vport->vlan);
  
 -	spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
  	vport->egress.allowed_vlan =
 -		mlx5_add_flow_rule(vport->egress.acl, spec,
 +		mlx5_add_flow_rule(vport->egress.acl,
 +				   MLX5_MATCH_OUTER_HEADERS,
 +				   match_c,
 +				   match_v,
  				   MLX5_FLOW_CONTEXT_ACTION_ALLOW,
  				   0, NULL);
 -	if (IS_ERR(vport->egress.allowed_vlan)) {
 +	if (IS_ERR_OR_NULL(vport->egress.allowed_vlan)) {
  		err = PTR_ERR(vport->egress.allowed_vlan);
- 		pr_warn("vport[%d] configure egress allowed vlan rule failed, err(%d)\n",
- 			vport->vport, err);
+ 		esw_warn(esw->dev,
+ 			 "vport[%d] configure egress allowed vlan rule failed, err(%d)\n",
+ 			 vport->vport, err);
  		vport->egress.allowed_vlan = NULL;
  		goto out;
  	}
  
  	/* Drop others rule (star rule) */
 -	memset(spec, 0, sizeof(*spec));
 +	memset(match_c, 0, MLX5_ST_SZ_BYTES(fte_match_param));
 +	memset(match_v, 0, MLX5_ST_SZ_BYTES(fte_match_param));
  	vport->egress.drop_rule =
 -		mlx5_add_flow_rule(vport->egress.acl, spec,
 +		mlx5_add_flow_rule(vport->egress.acl,
 +				   0,
 +				   match_c,
 +				   match_v,
  				   MLX5_FLOW_CONTEXT_ACTION_DROP,
  				   0, NULL);
 -	if (IS_ERR(vport->egress.drop_rule)) {
 +	if (IS_ERR_OR_NULL(vport->egress.drop_rule)) {
  		err = PTR_ERR(vport->egress.drop_rule);
- 		pr_warn("vport[%d] configure egress drop rule failed, err(%d)\n",
- 			vport->vport, err);
+ 		esw_warn(esw->dev,
+ 			 "vport[%d] configure egress drop rule failed, err(%d)\n",
+ 			 vport->vport, err);
  		vport->egress.drop_rule = NULL;
  	}
  out:
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index 3b6147aebe10..32670daebdeb 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@ -352,7 +352,7 @@ static void del_flow_table(struct fs_node *node)
 
 	err = mlx5_cmd_destroy_flow_table(dev, ft);
 	if (err)
-		pr_warn("flow steering can't destroy ft\n");
+		mlx5_core_warn(dev, "flow steering can't destroy ft\n");
 	fs_get_obj(prio, ft->node.parent);
 	prio->num_ft--;
 }
@@ -370,7 +370,7 @@ static void del_rule(struct fs_node *node)
 
 	match_value = mlx5_vzalloc(match_len);
 	if (!match_value) {
-		pr_warn("failed to allocate inbox\n");
+		mlx5_core_warn(dev, "failed to allocate inbox\n");
 		return;
 	}
 
@@ -390,8 +390,9 @@ static void del_rule(struct fs_node *node)
 		err = mlx5_cmd_update_fte(dev, ft,
 					  fg->id, fte);
 		if (err)
-			pr_warn("%s can't del rule fg id=%d fte_index=%d\n",
-				__func__, fg->id, fte->index);
+			mlx5_core_warn(dev,
+				       "%s can't del rule fg id=%d fte_index=%d\n",
+				       __func__, fg->id, fte->index);
 	}
 	kvfree(match_value);
 }
@@ -412,8 +413,9 @@ static void del_fte(struct fs_node *node)
 	err = mlx5_cmd_delete_fte(dev, ft,
 				  fte->index);
 	if (err)
-		pr_warn("flow steering can't delete fte in index %d of flow group id %d\n",
-			fte->index, fg->id);
+		mlx5_core_warn(dev,
+			       "flow steering can't delete fte in index %d of flow group id %d\n",
+			       fte->index, fg->id);
 
 	fte->status = 0;
 	fg->num_ftes--;
@@ -430,8 +432,8 @@ static void del_flow_group(struct fs_node *node)
 	dev = get_dev(&ft->node);
 
 	if (mlx5_cmd_destroy_flow_group(dev, ft, fg->id))
-		pr_warn("flow steering can't destroy fg %d of ft %d\n",
-			fg->id, ft->id);
+		mlx5_core_warn(dev, "flow steering can't destroy fg %d of ft %d\n",
+			       fg->id, ft->id);
 }
 
 static struct fs_fte *alloc_fte(u8 action,
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c
index e782d0fde09e..01ff19b82e55 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -323,7 +323,7 @@ enum {
 				MLX5_DEV_CAP_FLAG_DCT,
 };
 
-static u16 to_fw_pkey_sz(u32 size)
+static u16 to_fw_pkey_sz(struct mlx5_core_dev *dev, u32 size)
 {
 	switch (size) {
 	case 128:
@@ -339,7 +339,7 @@ static u16 to_fw_pkey_sz(u32 size)
 	case 4096:
 		return 5;
 	default:
-		pr_warn("invalid pkey table size %d\n", size);
+		mlx5_core_warn(dev, "invalid pkey table size %d\n", size);
 		return 0;
 	}
 }
@@ -489,7 +489,7 @@ static int handle_hca_cap(struct mlx5_core_dev *dev)
 		      128);
 	/* we limit the size of the pkey table to 128 entries for now */
 	MLX5_SET(cmd_hca_cap, set_hca_cap, pkey_table_size,
-		 to_fw_pkey_sz(128));
+		 to_fw_pkey_sz(dev, 128));
 
 	if (prof->mask & MLX5_PROF_MASK_QP_SIZE)
 		MLX5_SET(cmd_hca_cap, set_hca_cap, log_max_qp,
@@ -1324,8 +1324,9 @@ static int init_one(struct pci_dev *pdev,
 	pci_set_drvdata(pdev, dev);
 
 	if (prof_sel < 0 || prof_sel >= ARRAY_SIZE(profile)) {
-		pr_warn("selected profile out of range, selecting default (%d)\n",
-			MLX5_DEFAULT_PROF);
+		mlx5_core_warn(dev,
+			       "selected profile out of range, selecting default (%d)\n",
+			       MLX5_DEFAULT_PROF);
 		prof_sel = MLX5_DEFAULT_PROF;
 	}
 	dev->profile = &profile[prof_sel];
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
index f0d87046af8e..80efb1b4ac07 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.h
@@ -56,8 +56,8 @@ do {									\
 } while (0)
 
 #define mlx5_core_err(__dev, format, ...)				\
-	dev_err(&(__dev)->pdev->dev, "%s:%s:%d:(pid %d): " format,	\
-	       (__dev)->priv.name, __func__, __LINE__, current->pid,	\
+	dev_err(&(__dev)->pdev->dev, "%s:%d:(pid %d): " format,	\
+		__func__, __LINE__, current->pid,	\
 	       ##__VA_ARGS__)
 
 #define mlx5_core_warn(__dev, format, ...)				\
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/sriov.c b/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
index d6a3f412ba9f..82e830ac471f 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/sriov.c
@@ -155,13 +155,13 @@ int mlx5_core_sriov_configure(struct pci_dev *pdev, int num_vfs)
 		if (!pci_vfs_assigned(pdev))
 			pci_disable_sriov(pdev);
 		else
-			pr_info("unloading PF driver while leaving orphan VFs\n");
+			mlx5_core_info(dev, "unloading PF driver while leaving orphan VFs\n");
 		return 0;
 	}
 
 	err = mlx5_core_sriov_enable(pdev, num_vfs);
 	if (err) {
-		dev_warn(&pdev->dev, "mlx5_core_sriov_enable failed %d\n", err);
+		mlx5_core_warn(dev, "mlx5_core_sriov_enable failed %d\n", err);
 		return err;
 	}
 
@@ -180,7 +180,8 @@ static int sync_required(struct pci_dev *pdev)
 	int cur_vfs = pci_num_vf(pdev);
 
 	if (cur_vfs != sriov->num_vfs) {
-		pr_info("current VFs %d, registered %d - sync needed\n", cur_vfs, sriov->num_vfs);
+		mlx5_core_warn(dev, "current VFs %d, registered %d - sync needed\n",
+			       cur_vfs, sriov->num_vfs);
 		return 1;
 	}
 
