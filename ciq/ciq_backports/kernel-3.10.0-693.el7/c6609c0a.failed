vfs: add path_is_mountpoint() helper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ian Kent <ikent@redhat.com>
commit c6609c0a1c34fc097152b28b496236625673924f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c6609c0a.failed

d_mountpoint() can only be used reliably to establish if a dentry is
not mounted in any namespace. It isn't aware of the possibility there
may be multiple mounts using a given dentry that may be in a different
namespace.

Add helper functions, path_is_mountpoint(), that checks if a struct path
is a mountpoint for this case.

Link: http://lkml.kernel.org/r/20161011053358.27645.9729.stgit@pluto.themaw.net
	Signed-off-by: Ian Kent <raven@themaw.net>
	Cc: Al Viro <viro@ZenIV.linux.org.uk>
	Cc: Eric W. Biederman <ebiederm@xmission.com>
	Cc: Omar Sandoval <osandov@osandov.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit c6609c0a1c34fc097152b28b496236625673924f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/mount.h
#	fs/namespace.c
#	include/linux/mount.h
diff --cc fs/mount.h
index e343bfffd887,2c856fc47ae3..000000000000
--- a/fs/mount.h
+++ b/fs/mount.h
@@@ -79,6 -91,24 +79,27 @@@ static inline int is_mounted(struct vfs
  extern struct mount *__lookup_mnt(struct vfsmount *, struct dentry *);
  extern struct mount *__lookup_mnt_last(struct vfsmount *, struct dentry *);
  
++<<<<<<< HEAD
++=======
+ extern int __legitimize_mnt(struct vfsmount *, unsigned);
+ extern bool legitimize_mnt(struct vfsmount *, unsigned);
+ 
+ static inline bool __path_is_mountpoint(const struct path *path)
+ {
+ 	struct mount *m = __lookup_mnt(path->mnt, path->dentry);
+ 	return m && likely(!(m->mnt.mnt_flags & MNT_SYNC_UMOUNT));
+ }
+ 
+ extern void __detach_mounts(struct dentry *dentry);
+ 
+ static inline void detach_mounts(struct dentry *dentry)
+ {
+ 	if (!d_mountpoint(dentry))
+ 		return;
+ 	__detach_mounts(dentry);
+ }
+ 
++>>>>>>> c6609c0a1c34 (vfs: add path_is_mountpoint() helper)
  static inline void get_mnt_ns(struct mnt_namespace *ns)
  {
  	atomic_inc(&ns->count);
diff --cc fs/namespace.c
index 1062450f989e,7a73383e8365..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -985,25 -1159,44 +985,58 @@@ struct vfsmount *mntget(struct vfsmoun
  }
  EXPORT_SYMBOL(mntget);
  
++<<<<<<< HEAD
 +void mnt_pin(struct vfsmount *mnt)
++=======
+ /* path_is_mountpoint() - Check if path is a mount in the current
+  *                          namespace.
+  *
+  *  d_mountpoint() can only be used reliably to establish if a dentry is
+  *  not mounted in any namespace and that common case is handled inline.
+  *  d_mountpoint() isn't aware of the possibility there may be multiple
+  *  mounts using a given dentry in a different namespace. This function
+  *  checks if the passed in path is a mountpoint rather than the dentry
+  *  alone.
+  */
+ bool path_is_mountpoint(const struct path *path)
+ {
+ 	unsigned seq;
+ 	bool res;
+ 
+ 	if (!d_mountpoint(path->dentry))
+ 		return false;
+ 
+ 	rcu_read_lock();
+ 	do {
+ 		seq = read_seqbegin(&mount_lock);
+ 		res = __path_is_mountpoint(path);
+ 	} while (read_seqretry(&mount_lock, seq));
+ 	rcu_read_unlock();
+ 
+ 	return res;
+ }
+ EXPORT_SYMBOL(path_is_mountpoint);
+ 
+ struct vfsmount *mnt_clone_internal(struct path *path)
++>>>>>>> c6609c0a1c34 (vfs: add path_is_mountpoint() helper)
  {
 -	struct mount *p;
 -	p = clone_mnt(real_mount(path->mnt), path->dentry, CL_PRIVATE);
 -	if (IS_ERR(p))
 -		return ERR_CAST(p);
 -	p->mnt.mnt_flags |= MNT_INTERNAL;
 -	return &p->mnt;
 +	br_write_lock(&vfsmount_lock);
 +	real_mount(mnt)->mnt_pinned++;
 +	br_write_unlock(&vfsmount_lock);
 +}
 +EXPORT_SYMBOL(mnt_pin);
 +
 +void mnt_unpin(struct vfsmount *m)
 +{
 +	struct mount *mnt = real_mount(m);
 +	br_write_lock(&vfsmount_lock);
 +	if (mnt->mnt_pinned) {
 +		mnt_add_count(mnt, 1);
 +		mnt->mnt_pinned--;
 +	}
 +	br_write_unlock(&vfsmount_lock);
  }
 +EXPORT_SYMBOL(mnt_unpin);
  
  static inline void mangle(struct seq_file *m, const char *s)
  {
diff --cc include/linux/mount.h
index ff7641f32d5f,5b6dd004bfdc..000000000000
--- a/include/linux/mount.h
+++ b/include/linux/mount.h
@@@ -86,4 -96,8 +86,11 @@@ extern void mark_mounts_for_expiry(stru
  
  extern dev_t name_to_dev_t(const char *name);
  
++<<<<<<< HEAD
++=======
+ extern unsigned int sysctl_mount_max;
+ 
+ extern bool path_is_mountpoint(const struct path *path);
+ 
++>>>>>>> c6609c0a1c34 (vfs: add path_is_mountpoint() helper)
  #endif /* _LINUX_MOUNT_H */
* Unmerged path fs/mount.h
* Unmerged path fs/namespace.c
* Unmerged path include/linux/mount.h
