audit: Audit proc/<pid>/cmdline aka proctitle

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author William Roberts <bill.c.roberts@gmail.com>
commit 3f1c82502c299da08b7b7f08b435212e51166ed9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/3f1c8250.failed

During an audit event, cache and print the value of the process's
proctitle value (proc/<pid>/cmdline). This is useful in situations
where processes are started via fork'd virtual machines where the
comm field is incorrect. Often times, setting the comm field still
is insufficient as the comm width is not very wide and most
virtual machine "package names" do not fit. Also, during execution,
many threads have their comm field set as well. By tying it back to
the global cmdline value for the process, audit records will be more
complete in systems with these properties. An example of where this
is useful and applicable is in the realm of Android. With Android,
their is no fork/exec for VM instances. The bare, preloaded Dalvik
VM listens for a fork and specialize request. When this request comes
in, the VM forks, and the loads the specific application (specializing).
This was done to take advantage of COW and to not require a load of
basic packages by the VM on very app spawn. When this spawn occurs,
the package name is set via setproctitle() and shows up in procfs.
Many of these package names are longer then 16 bytes, the historical
width of task->comm. Having the cmdline in the audit records will
couple the application back to the record directly. Also, on my
Debian development box, some audit records were more useful then
what was printed under comm.

The cached proctitle is tied to the life-cycle of the audit_context
structure and is built on demand.

Proctitle is controllable by userspace, and thus should not be trusted.
It is meant as an aid to assist in debugging. The proctitle event is
emitted during syscall audits, and can be filtered with auditctl.

Example:
type=AVC msg=audit(1391217013.924:386): avc:  denied  { getattr } for  pid=1971 comm="mkdir" name="/" dev="selinuxfs" ino=1 scontext=system_u:system_r:consolekit_t:s0-s0:c0.c255 tcontext=system_u:object_r:security_t:s0 tclass=filesystem
type=SYSCALL msg=audit(1391217013.924:386): arch=c000003e syscall=137 success=yes exit=0 a0=7f019dfc8bd7 a1=7fffa6aed2c0 a2=fffffffffff4bd25 a3=7fffa6aed050 items=0 ppid=1967 pid=1971 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm="mkdir" exe="/bin/mkdir" subj=system_u:system_r:consolekit_t:s0-s0:c0.c255 key=(null)
type=UNKNOWN[1327] msg=audit(1391217013.924:386):  proctitle=6D6B646972002D70002F7661722F72756E2F636F6E736F6C65

	Acked-by: Steve Grubb <sgrubb@redhat.com> (wrt record formating)

	Signed-off-by: William Roberts <wroberts@tresys.com>
	Signed-off-by: Eric Paris <eparis@redhat.com>
(cherry picked from commit 3f1c82502c299da08b7b7f08b435212e51166ed9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/audit.h
#	kernel/audit.h
diff --cc include/uapi/linux/audit.h
index 28459be2d594,4315ee99b967..000000000000
--- a/include/uapi/linux/audit.h
+++ b/include/uapi/linux/audit.h
@@@ -108,8 -109,7 +108,12 @@@
  #define AUDIT_NETFILTER_PKT	1324	/* Packets traversing netfilter chains */
  #define AUDIT_NETFILTER_CFG	1325	/* Netfilter chain modifications */
  #define AUDIT_SECCOMP		1326	/* Secure Computing event */
++<<<<<<< HEAD
 +#define AUDIT_FEATURE_CHANGE	1328	/* audit log listing feature changes */
 +#define AUDIT_REPLACE		1329	/* Replace auditd if this packet unanswerd */
++=======
+ #define AUDIT_PROCTITLE		1327	/* Proctitle emit event */
++>>>>>>> 3f1c82502c29 (audit: Audit proc/<pid>/cmdline aka proctitle)
  
  #define AUDIT_AVC		1400	/* SE Linux avc denial or grant */
  #define AUDIT_SELINUX_ERR	1401	/* Internal SE Linux Errors */
diff --cc kernel/audit.h
index 18a56271aa9d,38c967d28de5..000000000000
--- a/kernel/audit.h
+++ b/kernel/audit.h
@@@ -104,15 -104,13 +104,20 @@@ struct audit_names 
  	 * should be freed on syscall exit.
  	 */
  	bool			should_free;
 +
 +#ifdef __GENKSYMS__
 +#if AUDIT_DEBUG
 +	int			put_count;
 +	int			ino_count;
 +#endif
 +#endif
  };
  
+ struct audit_proctitle {
+ 	int	len;	/* length of the cmdline field. */
+ 	char	*value;	/* the cmdline field */
+ };
+ 
  /* The per-task audit context. */
  struct audit_context {
  	int		    dummy;	/* must be the first element */
@@@ -209,9 -207,15 +214,18 @@@
  		} execve;
  	};
  	int fds[2];
++<<<<<<< HEAD
++=======
+ 	struct audit_proctitle proctitle;
+ 
+ #if AUDIT_DEBUG
+ 	int		    put_count;
+ 	int		    ino_count;
+ #endif
++>>>>>>> 3f1c82502c29 (audit: Audit proc/<pid>/cmdline aka proctitle)
  };
  
 -extern u32 audit_ever_enabled;
 +extern int audit_ever_enabled;
  
  extern void audit_copy_inode(struct audit_names *name,
  			     const struct dentry *dentry,
* Unmerged path include/uapi/linux/audit.h
* Unmerged path kernel/audit.h
diff --git a/kernel/auditsc.c b/kernel/auditsc.c
index f61810c3b625..53d97ea9ea5b 100644
--- a/kernel/auditsc.c
+++ b/kernel/auditsc.c
@@ -69,6 +69,7 @@
 #include <linux/capability.h>
 #include <linux/fs_struct.h>
 #include <linux/compat.h>
+#include <linux/ctype.h>
 
 #include "audit.h"
 
@@ -81,6 +82,9 @@
  * see the note near the top of audit_log_execve_info() about this value */
 #define MAX_EXECVE_AUDIT_LEN 7500
 
+/* max length to print of cmdline/proctitle value during audit */
+#define MAX_PROCTITLE_AUDIT_LEN 128
+
 /* number of audit rules */
 int audit_n_rules;
 
@@ -862,6 +866,13 @@ static inline struct audit_context *audit_get_context(struct task_struct *tsk,
 	return context;
 }
 
+static inline void audit_proctitle_free(struct audit_context *context)
+{
+	kfree(context->proctitle.value);
+	context->proctitle.value = NULL;
+	context->proctitle.len = 0;
+}
+
 static inline void audit_free_names(struct audit_context *context)
 {
 	struct audit_names *n, *next;
@@ -951,6 +962,7 @@ static inline void audit_free_context(struct audit_context *context)
 	audit_free_aux(context);
 	kfree(context->filterkey);
 	kfree(context->sockaddr);
+	audit_proctitle_free(context);
 	kfree(context);
 }
 
@@ -1260,6 +1272,59 @@ static void show_special(struct audit_context *context, int *call_panic)
 	audit_log_end(ab);
 }
 
+static inline int audit_proctitle_rtrim(char *proctitle, int len)
+{
+	char *end = proctitle + len - 1;
+	while (end > proctitle && !isprint(*end))
+		end--;
+
+	/* catch the case where proctitle is only 1 non-print character */
+	len = end - proctitle + 1;
+	len -= isprint(proctitle[len-1]) == 0;
+	return len;
+}
+
+static void audit_log_proctitle(struct task_struct *tsk,
+			 struct audit_context *context)
+{
+	int res;
+	char *buf;
+	char *msg = "(null)";
+	int len = strlen(msg);
+	struct audit_buffer *ab;
+
+	ab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);
+	if (!ab)
+		return;	/* audit_panic or being filtered */
+
+	audit_log_format(ab, "proctitle=");
+
+	/* Not  cached */
+	if (!context->proctitle.value) {
+		buf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);
+		if (!buf)
+			goto out;
+		/* Historically called this from procfs naming */
+		res = get_cmdline(tsk, buf, MAX_PROCTITLE_AUDIT_LEN);
+		if (res == 0) {
+			kfree(buf);
+			goto out;
+		}
+		res = audit_proctitle_rtrim(buf, res);
+		if (res == 0) {
+			kfree(buf);
+			goto out;
+		}
+		context->proctitle.value = buf;
+		context->proctitle.len = res;
+	}
+	msg = context->proctitle.value;
+	len = context->proctitle.len;
+out:
+	audit_log_n_untrustedstring(ab, msg, len);
+	audit_log_end(ab);
+}
+
 static void audit_log_exit(struct audit_context *context, struct task_struct *tsk)
 {
 	int i, call_panic = 0;
@@ -1377,6 +1442,8 @@ static void audit_log_exit(struct audit_context *context, struct task_struct *ts
 		audit_log_name(context, n, NULL, i++, &call_panic);
 	}
 
+	audit_log_proctitle(tsk, context);
+
 	/* Send end of event record to help user space know we are finished */
 	ab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);
 	if (ab)
