HID: wacom: Treat features->device_type values as flags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Treat features->device_type values as flags (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.24%
commit-author Jason Gerecke <killertofu@gmail.com>
commit aa86b18cc9cd147b40412a2d57b383a5e16fe3b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/aa86b18c.failed

The USB devices that this driver has historically supported segregate the
pen and touch portions of the tablet. Oftentimes the segregation would be
done at the interface level, though on occasion (e.g. Cintiq 24HDT) the
tablet would combine two totally independent USB devices behind an internal
USB hub. Because pen and touch never shared the same interface, it made
sense for the 'device_type' to store a single value: "pen" or "touch".

Recently, however, some I2C devices have been created which combine the
two. A first step to accomodating this is to expand 'device_type' so that
it can represent two (or potentially more) types simultaneously. To do
this, we treat it as a bitfield and set/check individual bits rather
than using the '=' and '==' operators.

This should not result in any functional change since no supported devices
(that I'm aware of, at least) have HID descriptors that indicate both
pen and touch reports on a single interface.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit aa86b18cc9cd147b40412a2d57b383a5e16fe3b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,2b4cbd872f94..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -290,248 -180,144 +290,328 @@@ static void wacom_retrieve_report_data(
   * interfaces haven't supported pressure or distance, this is enough
   * information to override invalid values in the wacom_features table.
   *
 - * Intuos5 touch interface and 3rd gen Bamboo Touch do not contain useful
 - * data. We deal with them after returning from this function.
 + * 3rd gen Bamboo Touch no longer define a Digitizer-Finger Pysical
 + * Collection. Instead they define a Logical Collection with a single
 + * Logical Maximum for both X and Y.
 + *
 + * Intuos5 touch interface does not contain useful data. We deal with
 + * this after returning from this function.
   */
++<<<<<<< HEAD
 +static int wacom_parse_hid(struct usb_interface *intf,
 +			   struct hid_descriptor *hid_desc,
++=======
+ static void wacom_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_features *features = &wacom->wacom_wac.features;
+ 	bool finger = WACOM_FINGER_FIELD(field);
+ 	bool pen = WACOM_PEN_FIELD(field);
+ 
+ 	/*
+ 	* Requiring Stylus Usage will ignore boot mouse
+ 	* X/Y values and some cases of invalid Digitizer X/Y
+ 	* values commonly reported.
+ 	*/
+ 	if (pen)
+ 		features->device_type |= WACOM_DEVICETYPE_PEN;
+ 	else if (finger)
+ 		features->device_type |= WACOM_DEVICETYPE_TOUCH;
+ 	else
+ 		return;
+ 
+ 	/*
+ 	 * Bamboo models do not support HID_DG_CONTACTMAX.
+ 	 * And, Bamboo Pen only descriptor contains touch.
+ 	 */
+ 	if (features->type != BAMBOO_PT) {
+ 		/* ISDv4 touch devices at least supports one touch point */
+ 		if (finger && !features->touch_max)
+ 			features->touch_max = 1;
+ 	}
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		features->x_max = field->logical_maximum;
+ 		if (finger) {
+ 			features->x_phy = field->physical_maximum;
+ 			if (features->type != BAMBOO_PT) {
+ 				features->unit = field->unit;
+ 				features->unitExpo = field->unit_exponent;
+ 			}
+ 		}
+ 		break;
+ 	case HID_GD_Y:
+ 		features->y_max = field->logical_maximum;
+ 		if (finger) {
+ 			features->y_phy = field->physical_maximum;
+ 			if (features->type != BAMBOO_PT) {
+ 				features->unit = field->unit;
+ 				features->unitExpo = field->unit_exponent;
+ 			}
+ 		}
+ 		break;
+ 	case HID_DG_TIPPRESSURE:
+ 		if (pen)
+ 			features->pressure_max = field->logical_maximum;
+ 		break;
+ 	}
+ 
+ 	if (features->type == HID_GENERIC)
+ 		wacom_wac_usage_mapping(hdev, field, usage);
+ }
+ 
+ static void wacom_post_parse_hid(struct hid_device *hdev,
+ 				 struct wacom_features *features)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	if (features->type == HID_GENERIC) {
+ 		/* Any last-minute generic device setup */
+ 		if (features->touch_max > 1) {
+ 			input_mt_init_slots(wacom_wac->input, wacom_wac->features.touch_max,
+ 				    INPUT_MT_DIRECT);
+ 		}
+ 	}
+ }
+ 
+ static void wacom_parse_hid(struct hid_device *hdev,
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  			   struct wacom_features *features)
  {
 -	struct hid_report_enum *rep_enum;
 -	struct hid_report *hreport;
 -	int i, j;
 -
 -	/* check features first */
 -	rep_enum = &hdev->report_enum[HID_FEATURE_REPORT];
 -	list_for_each_entry(hreport, &rep_enum->report_list, list) {
 -		for (i = 0; i < hreport->maxfield; i++) {
 -			/* Ignore if report count is out of bounds. */
 -			if (hreport->field[i]->report_count < 1)
 -				continue;
 -
 -			for (j = 0; j < hreport->field[i]->maxusage; j++) {
 -				wacom_feature_mapping(hdev, hreport->field[i],
 -						hreport->field[i]->usage + j);
 +	struct usb_device *dev = interface_to_usbdev(intf);
 +	char limit = 0;
 +	/* result has to be defined as int for some devices */
 +	int result = 0;
 +	int i = 0, usage = WCM_UNDEFINED, finger = 0, pen = 0;
 +	unsigned char *report;
 +
 +	report = kzalloc(hid_desc->wDescriptorLength, GFP_KERNEL);
 +	if (!report)
 +		return -ENOMEM;
 +
 +	/* retrive report descriptors */
 +	do {
 +		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 +			USB_REQ_GET_DESCRIPTOR,
 +			USB_RECIP_INTERFACE | USB_DIR_IN,
 +			HID_DEVICET_REPORT << 8,
 +			intf->altsetting[0].desc.bInterfaceNumber, /* interface */
 +			report,
 +			hid_desc->wDescriptorLength,
 +			5000); /* 5 secs */
 +	} while (result < 0 && limit++ < WAC_MSG_RETRIES);
 +
 +	/* No need to parse the Descriptor. It isn't an error though */
 +	if (result < 0)
 +		goto out;
 +
 +	for (i = 0; i < hid_desc->wDescriptorLength; i++) {
 +
 +		switch (report[i]) {
 +		case HID_USAGE_PAGE:
 +			switch (report[i + 1]) {
 +			case HID_USAGE_PAGE_DIGITIZER:
 +				usage = WCM_DIGITIZER;
 +				i++;
 +				break;
 +
 +			case HID_USAGE_PAGE_DESKTOP:
 +				usage = WCM_DESKTOP;
 +				i++;
 +				break;
  			}
 -		}
 -	}
 +			break;
  
 -	/* now check the input usages */
 -	rep_enum = &hdev->report_enum[HID_INPUT_REPORT];
 -	list_for_each_entry(hreport, &rep_enum->report_list, list) {
 +		case HID_USAGE:
 +			switch (report[i + 1]) {
 +			case HID_USAGE_X:
 +				if (usage == WCM_DESKTOP) {
 +					if (finger) {
 +						features->device_type = BTN_TOOL_FINGER;
 +
 +						switch (features->type) {
 +						case TABLETPC2FG:
 +							features->pktlen = WACOM_PKGLEN_TPC2FG;
 +							break;
 +
 +						case MTSCREEN:
 +						case WACOM_24HDT:
 +							features->pktlen = WACOM_PKGLEN_MTOUCH;
 +							break;
 +
 +						case MTTPC:
 +							features->pktlen = WACOM_PKGLEN_MTTPC;
 +							break;
 +
 +						case BAMBOO_PT:
 +							features->pktlen = WACOM_PKGLEN_BBTOUCH;
 +							break;
 +
 +						default:
 +							features->pktlen = WACOM_PKGLEN_GRAPHIRE;
 +							break;
 +						}
 +
 +						switch (features->type) {
 +						case BAMBOO_PT:
 +							features->x_phy =
 +								get_unaligned_le16(&report[i + 5]);
 +							features->x_max =
 +								get_unaligned_le16(&report[i + 8]);
 +							i += 15;
 +							break;
 +
 +						case WACOM_24HDT:
 +							features->x_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->x_phy =
 +								get_unaligned_le16(&report[i + 8]);
 +							features->unit = report[i - 1];
 +							features->unitExpo = report[i - 3];
 +							i += 12;
 +							break;
 +
 +						case WACOM_27QHDT:
 +							if (!features->x_max) {
 +								features->x_max =
 +									get_unaligned_le16(&report[i - 4]);
 +								features->x_phy =
 +									get_unaligned_le16(&report[i - 7]);
 +								features->unit = report[i - 13];
 +								features->unitExpo = report[i - 11];
 +							}
 +							i += 9;
 +							break;
 +
 +						default:
 +							features->x_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->x_phy =
 +								get_unaligned_le16(&report[i + 6]);
 +							features->unit = report[i + 9];
 +							features->unitExpo = report[i + 11];
 +							i += 12;
 +							break;
 +						}
 +					} else if (pen) {
 +						/* penabled only accepts exact bytes of data */
 +						if (features->type >= TABLETPC)
 +							features->pktlen = WACOM_PKGLEN_GRAPHIRE;
 +						features->device_type = BTN_TOOL_PEN;
 +						features->x_max =
 +							get_unaligned_le16(&report[i + 3]);
 +						i += 4;
 +					}
 +				}
 +				break;
  
 -		if (!hreport->maxfield)
 -			continue;
 +			case HID_USAGE_Y:
 +				if (usage == WCM_DESKTOP) {
 +					if (finger) {
 +						switch (features->type) {
 +						case TABLETPC2FG:
 +						case MTSCREEN:
 +						case MTTPC:
 +							features->y_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->y_phy =
 +								get_unaligned_le16(&report[i + 6]);
 +							i += 7;
 +							break;
 +
 +						case WACOM_24HDT:
 +							features->y_max =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->y_phy =
 +								get_unaligned_le16(&report[i - 2]);
 +							i += 7;
 +							break;
 +
 +						case BAMBOO_PT:
 +							features->y_phy =
 +								get_unaligned_le16(&report[i + 3]);
 +							features->y_max =
 +								get_unaligned_le16(&report[i + 6]);
 +							i += 12;
 +							break;
 +
 +						case WACOM_27QHDT:
 +							if (!features->y_max) {
 +								features->y_max =
 +									get_unaligned_le16(&report[i - 2]);
 +								features->y_phy =
 +									get_unaligned_le16(&report[i - 5]);
 +							}
 +							i += 2;
 +							break;
 +
 +						default:
 +							features->y_max =
 +								features->x_max;
 +							features->y_phy =
 +								get_unaligned_le16(&report[i + 3]);
 +							i += 4;
 +							break;
 +						}
 +					} else if (pen) {
 +						features->y_max =
 +							get_unaligned_le16(&report[i + 3]);
 +						i += 4;
 +					}
 +				}
 +				break;
  
 -		for (i = 0; i < hreport->maxfield; i++)
 -			for (j = 0; j < hreport->field[i]->maxusage; j++)
 -				wacom_usage_mapping(hdev, hreport->field[i],
 -						hreport->field[i]->usage + j);
 -	}
 +			case HID_USAGE_FINGER:
 +				finger = 1;
 +				i++;
 +				break;
  
 -	wacom_post_parse_hid(hdev, features);
 -}
 +			/*
 +			 * Requiring Stylus Usage will ignore boot mouse
 +			 * X/Y values and some cases of invalid Digitizer X/Y
 +			 * values commonly reported.
 +			 */
 +			case HID_USAGE_STYLUS:
 +				pen = 1;
 +				i++;
 +				break;
  
 -static int wacom_hid_set_device_mode(struct hid_device *hdev)
 -{
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	struct hid_data *hid_data = &wacom->wacom_wac.hid_data;
 -	struct hid_report *r;
 -	struct hid_report_enum *re;
 +			case HID_USAGE_CONTACTMAX:
 +				/* leave touch_max as is if predefined */
 +				if (!features->touch_max)
 +					wacom_retrieve_report_data(intf, features);
 +				i++;
 +				break;
 +			}
 +			break;
  
 -	if (hid_data->inputmode < 0)
 -		return 0;
 +		case HID_COLLECTION_END:
 +			/* reset UsagePage and Finger */
 +			finger = usage = 0;
 +			break;
  
 -	re = &(hdev->report_enum[HID_FEATURE_REPORT]);
 -	r = re->report_id_hash[hid_data->inputmode];
 -	if (r) {
 -		r->field[0]->value[hid_data->inputmode_index] = 2;
 -		hid_hw_request(hdev, r, HID_REQ_SET_REPORT);
 +		case HID_COLLECTION:
 +			i++;
 +			switch (report[i]) {
 +			case HID_COLLECTION_LOGICAL:
 +				i += wacom_parse_logical_collection(&report[i],
 +								    features);
 +				break;
 +			}
 +			break;
 +		}
  	}
 -	return 0;
 +
 + out:
 +	result = 0;
 +	kfree(report);
 +	return result;
  }
  
 -static int wacom_set_device_mode(struct hid_device *hdev, int report_id,
 -		int length, int mode)
 +static int wacom_set_device_mode(struct usb_interface *intf, int report_id, int length, int mode)
  {
  	unsigned char *rep_data;
  	int error = -ENOMEM, limit = 0;
@@@ -563,22 -402,32 +643,32 @@@
   * from the tablet, it is necessary to switch the tablet out of this
   * mode and into one which sends the full range of tablet data.
   */
 -static int wacom_query_tablet_data(struct hid_device *hdev,
 -		struct wacom_features *features)
 +static int wacom_query_tablet_data(struct usb_interface *intf, struct wacom_features *features)
  {
++<<<<<<< HEAD
 +	if (features->device_type == BTN_TOOL_FINGER) {
++=======
+ 	if (hdev->bus == BUS_BLUETOOTH)
+ 		return wacom_bt_query_tablet_data(hdev, 1, features);
+ 
+ 	if (features->type == HID_GENERIC)
+ 		return wacom_hid_set_device_mode(hdev);
+ 
+ 	if (features->device_type & WACOM_DEVICETYPE_TOUCH) {
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  		if (features->type > TABLETPC) {
  			/* MT Tablet PC touch */
 -			return wacom_set_device_mode(hdev, 3, 4, 4);
 +			return wacom_set_device_mode(intf, 3, 4, 4);
  		}
 -		else if (features->type == WACOM_24HDT || features->type == CINTIQ_HYBRID) {
 -			return wacom_set_device_mode(hdev, 18, 3, 2);
 +		else if (features->type == WACOM_24HDT) {
 +			return wacom_set_device_mode(intf, 18, 3, 2);
  		}
  		else if (features->type == WACOM_27QHDT) {
 -			return wacom_set_device_mode(hdev, 131, 3, 2);
 -		}
 -		else if (features->type == BAMBOO_PAD) {
 -			return wacom_set_device_mode(hdev, 2, 2, 2);
 +			return wacom_set_device_mode(intf, 131, 3, 2);
  		}
- 	} else if (features->device_type == BTN_TOOL_PEN) {
+ 	} else if (features->device_type & WACOM_DEVICETYPE_PEN) {
  		if (features->type <= BAMBOO_PT && features->type != WIRELESS) {
 -			return wacom_set_device_mode(hdev, 2, 2, 2);
 +			return wacom_set_device_mode(intf, 2, 2, 2);
  		}
  	}
  
@@@ -704,7 -536,12 +794,16 @@@ static int wacom_add_shared_data(struc
  		list_add_tail(&data->list, &wacom_udev_list);
  	}
  
++<<<<<<< HEAD
 +	wacom->shared = &data->shared;
++=======
+ 	wacom_wac->shared = &data->shared;
+ 
+ 	if (wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH)
+ 		wacom_wac->shared->touch = hdev;
+ 	else if (wacom_wac->features.device_type & WACOM_DEVICETYPE_PEN)
+ 		wacom_wac->shared->pen = hdev;
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  
  out:
  	mutex_unlock(&wacom_udev_list_lock);
@@@ -1064,8 -948,8 +1163,13 @@@ static void wacom_destroy_leds(struct w
  	case INTUOSPS:
  	case INTUOSPM:
  	case INTUOSPL:
++<<<<<<< HEAD
 +		if (wacom->wacom_wac.features.device_type == BTN_TOOL_PEN)
 +			sysfs_remove_group(&wacom->intf->dev.kobj,
++=======
+ 		if (wacom->wacom_wac.features.device_type & WACOM_DEVICETYPE_PEN)
+ 			sysfs_remove_group(&wacom->hdev->dev.kobj,
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  					   &intuos5_led_attr_group);
  		break;
  	}
@@@ -1220,20 -1295,27 +1324,25 @@@ static void wacom_wireless_work(struct 
  
  		/* Stylus interface */
  		wacom_wac1->features =
++<<<<<<< HEAD
 +			*((struct wacom_features *)id->driver_info);
 +		wacom_wac1->features.device_type = BTN_TOOL_PEN;
++=======
+ 			*((struct wacom_features *)id->driver_data);
+ 		wacom_wac1->features.device_type |= WACOM_DEVICETYPE_PEN;
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  		snprintf(wacom_wac1->name, WACOM_NAME_MAX, "%s (WL) Pen",
  			 wacom_wac1->features.name);
 -		snprintf(wacom_wac1->pad_name, WACOM_NAME_MAX, "%s (WL) Pad",
 -			 wacom_wac1->features.name);
 -		wacom_wac1->shared->touch_max = wacom_wac1->features.touch_max;
 -		wacom_wac1->shared->type = wacom_wac1->features.type;
 -		wacom_wac1->pid = wacom_wac->pid;
 -		error = wacom_allocate_inputs(wacom1) ||
 -			wacom_register_inputs(wacom1);
 +		error = wacom_register_input(wacom1);
  		if (error)
  			goto fail;
  
  		/* Touch interface */
 -		if (wacom_wac1->features.touch_max ||
 -		    wacom_wac1->features.type == INTUOSHT) {
 +		if (wacom_wac1->features.touch_max) {
  			wacom_wac2->features =
 -				*((struct wacom_features *)id->driver_data);
 +				*((struct wacom_features *)id->driver_info);
  			wacom_wac2->features.pktlen = WACOM_PKGLEN_BBTOUCH3;
- 			wacom_wac2->features.device_type = BTN_TOOL_FINGER;
+ 			wacom_wac2->features.device_type |= WACOM_DEVICETYPE_TOUCH;
  			wacom_wac2->features.x_max = wacom_wac2->features.y_max = 4096;
  			if (wacom_wac2->features.touch_max)
  				snprintf(wacom_wac2->name, WACOM_NAME_MAX,
@@@ -1293,10 -1396,80 +1402,84 @@@ static void wacom_calculate_res(struct 
  						    features->unitExpo);
  }
  
 -static size_t wacom_compute_pktlen(struct hid_device *hdev)
 +static int wacom_probe(struct usb_interface *intf, const struct usb_device_id *id)
  {
++<<<<<<< HEAD
++=======
+ 	struct hid_report_enum *report_enum;
+ 	struct hid_report *report;
+ 	size_t size = 0;
+ 
+ 	report_enum = hdev->report_enum + HID_INPUT_REPORT;
+ 
+ 	list_for_each_entry(report, &report_enum->report_list, list) {
+ 		size_t report_size = hid_report_len(report);
+ 		if (report_size > size)
+ 			size = report_size;
+ 	}
+ 
+ 	return size;
+ }
+ 
+ static void wacom_update_name(struct wacom *wacom)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	char name[WACOM_NAME_MAX];
+ 
+ 	/* Generic devices name unspecified */
+ 	if ((features->type == HID_GENERIC) && !strcmp("Wacom HID", features->name)) {
+ 		if (strstr(wacom->hdev->name, "Wacom") ||
+ 		    strstr(wacom->hdev->name, "wacom") ||
+ 		    strstr(wacom->hdev->name, "WACOM")) {
+ 			/* name is in HID descriptor, use it */
+ 			strlcpy(name, wacom->hdev->name, sizeof(name));
+ 
+ 			/* strip out excess whitespaces */
+ 			while (1) {
+ 				char *gap = strstr(name, "  ");
+ 				if (gap == NULL)
+ 					break;
+ 				/* shift everything including the terminator */
+ 				memmove(gap, gap+1, strlen(gap));
+ 			}
+ 			/* get rid of trailing whitespace */
+ 			if (name[strlen(name)-1] == ' ')
+ 				name[strlen(name)-1] = '\0';
+ 		} else {
+ 			/* no meaningful name retrieved. use product ID */
+ 			snprintf(name, sizeof(name),
+ 				 "%s %X", features->name, wacom->hdev->product);
+ 		}
+ 	} else {
+ 		strlcpy(name, features->name, sizeof(name));
+ 	}
+ 
+ 	/* Append the device type to the name */
+ 	snprintf(wacom_wac->pad_name, sizeof(wacom_wac->pad_name),
+ 		"%s Pad", name);
+ 
+ 	if (features->device_type & WACOM_DEVICETYPE_PEN) {
+ 		snprintf(wacom_wac->name, sizeof(wacom_wac->name),
+ 			"%s Pen", name);
+ 	}
+ 	else if (features->device_type & WACOM_DEVICETYPE_TOUCH) {
+ 		if (features->touch_max)
+ 			snprintf(wacom_wac->name, sizeof(wacom_wac->name),
+ 				"%s Finger", name);
+ 		else
+ 			snprintf(wacom_wac->name, sizeof(wacom_wac->name),
+ 				"%s Pad", name);
+ 	}
+ }
+ 
+ static int wacom_probe(struct hid_device *hdev,
+ 		const struct hid_device_id *id)
+ {
+ 	struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  	struct usb_device *dev = interface_to_usbdev(intf);
 +	struct usb_endpoint_descriptor *endpoint;
  	struct wacom *wacom;
  	struct wacom_wac *wacom_wac;
  	struct wacom_features *features;
@@@ -1343,84 -1542,71 +1526,105 @@@
  	wacom_set_default_phy(features);
  
  	/* Retrieve the physical and logical size for touch devices */
 -	wacom_retrieve_hid_descriptor(hdev, features);
 -	wacom_setup_device_quirks(wacom);
 +	error = wacom_retrieve_hid_descriptor(intf, features);
 +	if (error)
 +		goto fail3;
 +
++<<<<<<< HEAD
 +	/*
 +	 * Intuos5 has no useful data about its touch interface in its
 +	 * HID descriptor. If this is the touch interface (wMaxPacketSize
 +	 * of WACOM_PKGLEN_BBTOUCH3), override the table values.
 +	 */
 +	if (features->type >= INTUOS5S && features->type <= INTUOSPL) {
 +		if (endpoint->wMaxPacketSize == WACOM_PKGLEN_BBTOUCH3) {
 +			features->device_type = BTN_TOOL_FINGER;
 +			features->pktlen = WACOM_PKGLEN_BBTOUCH3;
  
 +			features->x_max = 4096;
 +			features->y_max = 4096;
 +		} else {
 +			features->device_type = BTN_TOOL_PEN;
 +		}
++=======
+ 	if (features->device_type == WACOM_DEVICETYPE_NONE &&
+ 	    features->type != WIRELESS) {
+ 		error = features->type == HID_GENERIC ? -ENODEV : 0;
+ 
+ 		dev_warn(&hdev->dev, "Unknown device_type for '%s'. %s.",
+ 			 hdev->name,
+ 			 error ? "Ignoring" : "Assuming pen");
+ 
+ 		if (error)
+ 			goto fail_shared_data;
+ 
+ 		features->device_type |= WACOM_DEVICETYPE_PEN;
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  	}
  
 +	wacom_setup_device_quirks(features);
 +
 +	/* set unit to "100th of a mm" for devices not reported by HID */
 +	if (!features->unit) {
 +		features->unit = 0x11;
 +		features->unitExpo = 16 - 3;
 +	}
  	wacom_calculate_res(features);
  
 -	wacom_update_name(wacom);
 +	strlcpy(wacom_wac->name, features->name, sizeof(wacom_wac->name));
  
 -	error = wacom_add_shared_data(hdev);
 -	if (error)
 -		goto fail_shared_data;
 +	if (features->quirks & WACOM_QUIRK_MULTI_INPUT) {
 +		struct usb_device *other_dev;
  
 -	if (!(features->quirks & WACOM_QUIRK_MONITOR) &&
 -	     (features->quirks & WACOM_QUIRK_BATTERY)) {
 -		error = wacom_initialize_battery(wacom);
 -		if (error)
 -			goto fail_battery;
 -	}
 +		/* Append the device type to the name */
 +		if (features->device_type != BTN_TOOL_FINGER)
 +			strlcat(wacom_wac->name, " Pen", WACOM_NAME_MAX);
 +		else if (features->touch_max)
 +			strlcat(wacom_wac->name, " Finger", WACOM_NAME_MAX);
 +		else
 +			strlcat(wacom_wac->name, " Pad", WACOM_NAME_MAX);
  
 -	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
 -		error = wacom_register_inputs(wacom);
 +		other_dev = wacom_get_sibling(dev, features->oVid, features->oPid);
 +		if (other_dev == NULL || wacom_get_usbdev_data(other_dev) == NULL)
 +			other_dev = dev;
 +		error = wacom_add_shared_data(wacom_wac, other_dev);
  		if (error)
 -			goto fail_register_inputs;
 +			goto fail3;
  	}
  
 -	if (hdev->bus == BUS_BLUETOOTH) {
 -		error = device_create_file(&hdev->dev, &dev_attr_speed);
 -		if (error)
 -			hid_warn(hdev,
 -				 "can't create sysfs speed attribute err: %d\n",
 -				 error);
 -	}
 +	usb_fill_int_urb(wacom->irq, dev,
 +			 usb_rcvintpipe(dev, endpoint->bEndpointAddress),
 +			 wacom_wac->data, features->pktlen,
 +			 wacom_sys_irq, wacom, endpoint->bInterval);
 +	wacom->irq->transfer_dma = wacom->data_dma;
 +	wacom->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
  
 -	if (features->type == HID_GENERIC)
 -		connect_mask |= HID_CONNECT_DRIVER;
 +	error = wacom_initialize_leds(wacom);
 +	if (error)
 +		goto fail4;
  
 -	/* Regular HID work starts now */
 -	error = hid_hw_start(hdev, connect_mask);
 -	if (error) {
 -		hid_err(hdev, "hw start failed\n");
 -		goto fail_hw_start;
 +	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
 +		error = wacom_register_input(wacom);
 +		if (error)
 +			goto fail5;
  	}
  
  	/* Note that if query fails it is not a hard failure */
 -	wacom_query_tablet_data(hdev, features);
 +	wacom_query_tablet_data(intf, features);
  
 -	if (features->quirks & WACOM_QUIRK_MONITOR)
 -		error = hid_hw_open(hdev);
 +	usb_set_intfdata(intf, wacom);
  
++<<<<<<< HEAD
 +	if (features->quirks & WACOM_QUIRK_MONITOR) {
 +		if (usb_submit_urb(wacom->irq, GFP_KERNEL)) {
 +			error = -EIO;
 +			goto fail5;
 +		}
++=======
+ 	if (wacom_wac->features.type == INTUOSHT && wacom_wac->features.touch_max) {
+ 		if (wacom_wac->features.device_type & WACOM_DEVICETYPE_TOUCH)
+ 			wacom_wac->shared->touch_input = wacom_wac->input;
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  	}
  
  	return 0;
diff --cc drivers/hid/wacom_wac.c
index bc916ccd4c20,5e7710d6b048..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1474,20 -2162,45 +1474,51 @@@ static void wacom_setup_intuos(struct w
  	input_set_abs_params(input_dev, ABS_THROTTLE, -1023, 1023, 0, 0);
  }
  
 -void wacom_setup_device_quirks(struct wacom *wacom)
 +void wacom_setup_device_quirks(struct wacom_features *features)
  {
 -	struct wacom_features *features = &wacom->wacom_wac.features;
  
  	/* touch device found but size is not defined. use default */
- 	if (features->device_type == BTN_TOOL_FINGER && !features->x_max) {
+ 	if (features->device_type & WACOM_DEVICETYPE_TOUCH && !features->x_max) {
  		features->x_max = 1023;
  		features->y_max = 1023;
  	}
  
++<<<<<<< HEAD
 +	/* these device have multiple inputs */
 +	if (features->type >= WIRELESS ||
 +	    (features->type >= INTUOS5S && features->type <= INTUOSPL) ||
 +	    (features->oVid && features->oPid))
 +		features->quirks |= WACOM_QUIRK_MULTI_INPUT;
++=======
+ 	/*
+ 	 * Intuos5/Pro and Bamboo 3rd gen have no useful data about its
+ 	 * touch interface in its HID descriptor. If this is the touch
+ 	 * interface (PacketSize of WACOM_PKGLEN_BBTOUCH3), override the
+ 	 * tablet values.
+ 	 */
+ 	if ((features->type >= INTUOS5S && features->type <= INTUOSHT) ||
+ 		(features->type == BAMBOO_PT)) {
+ 		if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 			features->device_type |= WACOM_DEVICETYPE_TOUCH;
+ 
+ 			features->x_max = 4096;
+ 			features->y_max = 4096;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * Raw Wacom-mode pen and touch events both come from interface
+ 	 * 0, whose HID descriptor has an application usage of 0xFF0D
+ 	 * (i.e., WACOM_VENDORDEFINED_PEN). We route pen packets back
+ 	 * out through the HID_GENERIC device created for interface 1,
+ 	 * so rewrite this one to be of type BTN_TOOL_FINGER.
+ 	 */
+ 	if (features->type == BAMBOO_PAD)
+ 		features->device_type |= WACOM_DEVICETYPE_TOUCH;
+ 
+ 	if (wacom->hdev->bus == BUS_BLUETOOTH)
+ 		features->quirks |= WACOM_QUIRK_BATTERY;
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  
  	/* quirk for bamboo touch with 2 low res touches */
  	if (features->type == BAMBOO_PT &&
@@@ -1505,8 -2218,10 +1536,12 @@@
  		features->quirks |= WACOM_QUIRK_NO_INPUT;
  
  		/* must be monitor interface if no device_type set */
++<<<<<<< HEAD
 +		if (!features->device_type)
++=======
+ 		if (features->device_type == WACOM_DEVICETYPE_NONE) {
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  			features->quirks |= WACOM_QUIRK_MONITOR;
 -			features->quirks |= WACOM_QUIRK_BATTERY;
 -		}
  	}
  }
  
@@@ -1592,6 -2309,211 +1627,214 @@@ int wacom_setup_input_capabilities(stru
  		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
++<<<<<<< HEAD
++=======
+ 	case WACOM_27QHD:
+ 	case WACOM_24HD:
+ 	case DTK:
+ 	case WACOM_22HD:
+ 	case WACOM_21UX2:
+ 	case WACOM_BEE:
+ 	case CINTIQ:
+ 	case WACOM_13HD:
+ 	case CINTIQ_HYBRID:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 287);
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		wacom_setup_cintiq(wacom_wac);
+ 		break;
+ 
+ 	case INTUOS3:
+ 	case INTUOS3L:
+ 	case INTUOS3S:
+ 	case INTUOS4:
+ 	case INTUOS4WL:
+ 	case INTUOS4L:
+ 	case INTUOS4S:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		input_abs_set_res(input_dev, ABS_Z, 287);
+ 		/* fall through */
+ 
+ 	case INTUOS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		wacom_setup_intuos(wacom_wac);
+ 		break;
+ 
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		if (features->device_type & WACOM_DEVICETYPE_PEN) {
+ 			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 					      features->distance_max,
+ 					      0, 0);
+ 
+ 			input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 			input_abs_set_res(input_dev, ABS_Z, 287);
+ 
+ 			wacom_setup_intuos(wacom_wac);
+ 		} else if (features->device_type & WACOM_DEVICETYPE_TOUCH) {
+ 			__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,
+ 			                     0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR,
+ 			                     0, features->y_max, 0, 0);
+ 			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		}
+ 		break;
+ 
+ 	case WACOM_24HDT:
+ 		if (features->device_type & WACOM_DEVICETYPE_TOUCH) {
+ 			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
+ 		}
+ 		/* fall through */
+ 
+ 	case WACOM_27QHDT:
+ 	case MTSCREEN:
+ 	case MTTPC:
+ 	case MTTPC_B:
+ 	case TABLETPC2FG:
+ 		if (features->device_type & WACOM_DEVICETYPE_TOUCH && features->touch_max > 1)
+ 			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);
+ 		/* fall through */
+ 
+ 	case TABLETPC:
+ 	case TABLETPCE:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 
+ 		if (!(features->device_type & WACOM_DEVICETYPE_PEN))
+ 			break;  /* no need to process stylus stuff */
+ 
+ 		/* fall through */
+ 
+ 	case DTUS:
+ 	case DTUSX:
+ 	case PL:
+ 	case DTU:
+ 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		break;
+ 
+ 	case PTU:
+ 		__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case PENPARTNER:
+ 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 		if (features->touch_max &&
+ 		    features->device_type & WACOM_DEVICETYPE_TOUCH) {
+ 			input_dev->evbit[0] |= BIT_MASK(EV_SW);
+ 			__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
+ 		}
+ 		/* fall through */
+ 
+ 	case BAMBOO_PT:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		if (features->device_type & WACOM_DEVICETYPE_TOUCH) {
+ 
+ 			if (features->touch_max) {
+ 				if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 					input_set_abs_params(input_dev,
+ 						     ABS_MT_TOUCH_MAJOR,
+ 						     0, features->x_max, 0, 0);
+ 					input_set_abs_params(input_dev,
+ 						     ABS_MT_TOUCH_MINOR,
+ 						     0, features->y_max, 0, 0);
+ 				}
+ 				input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 			} else {
+ 				/* buttons/keys only interface */
+ 				__clear_bit(ABS_X, input_dev->absbit);
+ 				__clear_bit(ABS_Y, input_dev->absbit);
+ 				__clear_bit(BTN_TOUCH, input_dev->keybit);
+ 
+ 				/* PAD is setup by wacom_setup_pad_input_capabilities later */
+ 				return 1;
+ 			}
+ 		} else if (features->device_type & WACOM_DEVICETYPE_PEN) {
+ 			__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 			__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 			__set_bit(BTN_STYLUS, input_dev->keybit);
+ 			__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 					      features->distance_max,
+ 					      0, 0);
+ 		}
+ 		break;
+ 	case BAMBOO_PAD:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 		input_mt_init_slots(input_dev, features->touch_max,
+ 				    INPUT_MT_POINTER);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	int i;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	/* kept for making legacy xf86-input-wacom working with the wheels */
+ 	__set_bit(ABS_MISC, input_dev->absbit);
+ 
+ 	/* kept for making legacy xf86-input-wacom accepting the pad */
+ 	input_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);
+ 
+ 	/* kept for making udev and libwacom accepting the pad */
+ 	__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 	switch (features->type) {
+ 	case GRAPHIRE_BT:
+ 		__set_bit(BTN_0, input_dev->keybit);
+ 		__set_bit(BTN_1, input_dev->keybit);
+ 		break;
+ 
+ 	case WACOM_MO:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_G4:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
+ 		break;
+ 
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  	case WACOM_24HD:
  		__set_bit(BTN_A, input_dev->keybit);
  		__set_bit(BTN_B, input_dev->keybit);
@@@ -1713,29 -2618,24 +1956,35 @@@
  
  	case INTUOS5S:
  	case INTUOSPS:
++<<<<<<< HEAD
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
++=======
+ 		/* touch interface does not have the pad device */
+ 		if (!(features->device_type & WACOM_DEVICETYPE_PEN))
+ 			return -ENODEV;
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  
 -		for (i = 0; i < 7; i++)
 -			__set_bit(BTN_0 + i, input_dev->keybit);
 +		if (features->device_type == BTN_TOOL_PEN) {
 +			for (i = 0; i < 7; i++)
 +				__set_bit(BTN_0 + i, input_dev->keybit);
  
 -		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
 -		break;
 +			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 +					      features->distance_max,
 +					      0, 0);
  
 -	case INTUOS4WL:
 -		/*
 -		 * For Bluetooth devices, the udev rule does not work correctly
 -		 * for pads unless we add a stylus capability, which forces
 -		 * ID_INPUT_TABLET to be set.
 -		 */
 -		__set_bit(BTN_STYLUS, input_dev->keybit);
 -		/* fall through */
 +			input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
 +
 +			wacom_setup_intuos(wacom_wac);
 +		} else if (features->device_type == BTN_TOOL_FINGER) {
 +			__clear_bit(ABS_MISC, input_dev->absbit);
 +
 +			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,
 +			                     0, features->x_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR,
 +			                     0, features->y_max, 0, 0);
 +			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
 +		}
 +		break;
  
  	case INTUOS4:
  	case INTUOS4L:
@@@ -1747,103 -2647,40 +1996,113 @@@
  		for (i = 0; i < 7; i++)
  			__set_bit(BTN_0 + i, input_dev->keybit);
  
 -		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
 +		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
 +		wacom_setup_intuos(wacom_wac);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
 -	case CINTIQ_HYBRID:
 -		for (i = 0; i < 9; i++)
 -			__set_bit(BTN_0 + i, input_dev->keybit);
 +	case WACOM_24HDT:
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
 +		}
 +		/* fall through */
  
 -		break;
 +	case MTSCREEN:
 +	case MTTPC:
 +	case TABLETPC2FG:
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			unsigned int flags = INPUT_MT_DIRECT;
  
 -	case DTUS:
 -		for (i = 0; i < 4; i++)
 -			__set_bit(BTN_0 + i, input_dev->keybit);
 -		break;
 +			if (wacom_wac->features.type == TABLETPC2FG)
 +				flags = 0;
  
++<<<<<<< HEAD
 +			input_mt_init_slots(input_dev, features->touch_max, flags);
 +		}
 +		/* fall through */
++=======
+ 	case INTUOSHT:
+ 	case BAMBOO_PT:
+ 		/* pad device is on the touch interface */
+ 		if (!(features->device_type & WACOM_DEVICETYPE_TOUCH) ||
+ 		    /* Bamboo Pen only tablet does not have pad */
+ 		    ((features->type == BAMBOO_PT) && !features->touch_max))
+ 			return -ENODEV;
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  
 +	case TABLETPC:
 +	case TABLETPCE:
  		__clear_bit(ABS_MISC, input_dev->absbit);
  
 -		__set_bit(BTN_LEFT, input_dev->keybit);
 -		__set_bit(BTN_FORWARD, input_dev->keybit);
 -		__set_bit(BTN_BACK, input_dev->keybit);
 -		__set_bit(BTN_RIGHT, input_dev->keybit);
 +		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
 +
 +		if (features->device_type != BTN_TOOL_PEN)
 +			break;  /* no need to process stylus stuff */
 +
 +		/* fall through */
 +
 +	case PL:
 +	case DTU:
 +		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +		__set_bit(BTN_STYLUS, input_dev->keybit);
 +		__set_bit(BTN_STYLUS2, input_dev->keybit);
  
 +		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
  		break;
  
 -	default:
 -		/* no pad supported */
 -		return -ENODEV;
 +	case PTU:
 +		__set_bit(BTN_STYLUS2, input_dev->keybit);
 +		/* fall through */
 +
 +	case PENPARTNER:
 +		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +		__set_bit(BTN_STYLUS, input_dev->keybit);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
 +		break;
 +
 +	case BAMBOO_PT:
 +		__clear_bit(ABS_MISC, input_dev->absbit);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
 +
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			unsigned int flags = INPUT_MT_POINTER;
 +
 +			__set_bit(BTN_LEFT, input_dev->keybit);
 +			__set_bit(BTN_FORWARD, input_dev->keybit);
 +			__set_bit(BTN_BACK, input_dev->keybit);
 +			__set_bit(BTN_RIGHT, input_dev->keybit);
 +
 +			if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MAJOR,
 +						     0, features->x_max, 0, 0);
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MINOR,
 +						     0, features->y_max, 0, 0);
 +			} else {
 +				__set_bit(BTN_TOOL_FINGER, input_dev->keybit);
 +				__set_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);
 +				flags = 0;
 +			}
 +			input_mt_init_slots(input_dev, features->touch_max, flags);
 +		} else if (features->device_type == BTN_TOOL_PEN) {
 +			__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +			__set_bit(BTN_STYLUS, input_dev->keybit);
 +			__set_bit(BTN_STYLUS2, input_dev->keybit);
 +			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 +					      features->distance_max,
 +					      0, 0);
 +		}
 +		break;
  	}
  	return 0;
  }
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,da2b3095c2f8..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -53,16 -52,42 +53,40 @@@
  #define WACOM_REPORT_TPC1FG		6
  #define WACOM_REPORT_TPC2FG		13
  #define WACOM_REPORT_TPCMT		13
 -#define WACOM_REPORT_TPCMT2		3
  #define WACOM_REPORT_TPCHID		15
 -#define WACOM_REPORT_CINTIQ		16
 -#define WACOM_REPORT_CINTIQPAD		17
  #define WACOM_REPORT_TPCST		16
 -#define WACOM_REPORT_DTUS		17
  #define WACOM_REPORT_TPC1FGE		18
  #define WACOM_REPORT_24HDT		1
 -#define WACOM_REPORT_WL			128
 -#define WACOM_REPORT_USB		192
 -#define WACOM_REPORT_BPAD_PEN		3
 -#define WACOM_REPORT_BPAD_TOUCH		16
  
  /* device quirks */
++<<<<<<< HEAD
 +#define WACOM_QUIRK_MULTI_INPUT		0x0001
 +#define WACOM_QUIRK_BBTOUCH_LOWRES	0x0002
 +#define WACOM_QUIRK_NO_INPUT		0x0004
 +#define WACOM_QUIRK_MONITOR		0x0008
++=======
+ #define WACOM_QUIRK_BBTOUCH_LOWRES	0x0001
+ #define WACOM_QUIRK_NO_INPUT		0x0002
+ #define WACOM_QUIRK_MONITOR		0x0004
+ #define WACOM_QUIRK_BATTERY		0x0008
+ 
+ /* device types */
+ #define WACOM_DEVICETYPE_NONE           0x0000
+ #define WACOM_DEVICETYPE_PEN            0x0001
+ #define WACOM_DEVICETYPE_TOUCH          0x0002
+ 
+ #define WACOM_VENDORDEFINED_PEN		0xff0d0001
+ 
+ #define WACOM_PEN_FIELD(f)	(((f)->logical == HID_DG_STYLUS) || \
+ 				 ((f)->physical == HID_DG_STYLUS) || \
+ 				 ((f)->physical == HID_DG_PEN) || \
+ 				 ((f)->application == HID_DG_PEN) || \
+ 				 ((f)->application == HID_DG_DIGITIZER) || \
+ 				 ((f)->application == WACOM_VENDORDEFINED_PEN))
+ #define WACOM_FINGER_FIELD(f)	(((f)->logical == HID_DG_FINGER) || \
+ 				 ((f)->physical == HID_DG_FINGER) || \
+ 				 ((f)->application == HID_DG_TOUCHSCREEN))
++>>>>>>> aa86b18cc9cd (HID: wacom: Treat features->device_type values as flags)
  
  enum {
  	PENPARTNER = 0,
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
* Unmerged path drivers/hid/wacom_wac.h
