block: fix bio_will_gap() for first bvec with offset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [block] fix bio_will_gap() for first bvec with offset (Ming Lei) [1443807]
Rebuild_FUZZ: 92.78%
commit-author Ming Lei <ming.lei@redhat.com>
commit 5a8d75a1b8c99bdc926ba69b7b7dbe4fae81a5af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5a8d75a1.failed

Commit 729204ef49ec("block: relax check on sg gap") allows us to merge
bios, if both are physically contiguous.  This change can merge a huge
number of small bios, through mkfs for example, mkfs.ntfs running time
can be decreased to ~1/10.

But if one rq starts with a non-aligned buffer (the 1st bvec's bv_offset
is non-zero) and if we allow the merge, it is quite difficult to respect
sg gap limit, especially the max segment size, or we risk having an
unaligned virtual boundary.  This patch tries to avoid the issue by
disallowing a merge, if the req starts with an unaligned buffer.

Also add comments to explain why the merged segment can't end in
unaligned virt boundary.

Fixes: 729204ef49ec ("block: relax check on sg gap")
	Tested-by: Johannes Thumshirn <jthumshirn@suse.de>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>

Rewrote parts of the commit message and comments.

	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 5a8d75a1b8c99bdc926ba69b7b7dbe4fae81a5af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/blkdev.h
diff --cc include/linux/blkdev.h
index d0c02b856b7c,01a696b0a4d3..000000000000
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@@ -1495,14 -1653,63 +1495,73 @@@ static inline bool bvec_gap_to_prev(str
  	return __bvec_gap_to_prev(q, bprv, offset);
  }
  
++<<<<<<< HEAD
 +static inline bool bio_will_gap(struct request_queue *q, struct bio *prev,
 +			 struct bio *next)
++=======
+ /*
+  * Check if the two bvecs from two bios can be merged to one segment.
+  * If yes, no need to check gap between the two bios since the 1st bio
+  * and the 1st bvec in the 2nd bio can be handled in one segment.
+  */
+ static inline bool bios_segs_mergeable(struct request_queue *q,
+ 		struct bio *prev, struct bio_vec *prev_last_bv,
+ 		struct bio_vec *next_first_bv)
+ {
+ 	if (!BIOVEC_PHYS_MERGEABLE(prev_last_bv, next_first_bv))
+ 		return false;
+ 	if (!BIOVEC_SEG_BOUNDARY(q, prev_last_bv, next_first_bv))
+ 		return false;
+ 	if (prev->bi_seg_back_size + next_first_bv->bv_len >
+ 			queue_max_segment_size(q))
+ 		return false;
+ 	return true;
+ }
+ 
+ static inline bool bio_will_gap(struct request_queue *q,
+ 				struct request *prev_rq,
+ 				struct bio *prev,
+ 				struct bio *next)
++>>>>>>> 5a8d75a1b8c9 (block: fix bio_will_gap() for first bvec with offset)
  {
 -	if (bio_has_data(prev) && queue_virt_boundary(q)) {
 -		struct bio_vec pb, nb;
 +	if (!bio_has_data(prev) || !queue_virt_boundary(q))
 +		return false;
  
++<<<<<<< HEAD
 +	return __bvec_gap_to_prev(q, &prev->bi_io_vec[prev->bi_vcnt - 1],
 +				  next->bi_io_vec[0].bv_offset);
++=======
+ 		/*
+ 		 * don't merge if the 1st bio starts with non-zero
+ 		 * offset, otherwise it is quite difficult to respect
+ 		 * sg gap limit. We work hard to merge a huge number of small
+ 		 * single bios in case of mkfs.
+ 		 */
+ 		if (prev_rq)
+ 			bio_get_first_bvec(prev_rq->bio, &pb);
+ 		else
+ 			bio_get_first_bvec(prev, &pb);
+ 		if (pb.bv_offset)
+ 			return true;
+ 
+ 		/*
+ 		 * We don't need to worry about the situation that the
+ 		 * merged segment ends in unaligned virt boundary:
+ 		 *
+ 		 * - if 'pb' ends aligned, the merged segment ends aligned
+ 		 * - if 'pb' ends unaligned, the next bio must include
+ 		 *   one single bvec of 'nb', otherwise the 'nb' can't
+ 		 *   merge with 'pb'
+ 		 */
+ 		bio_get_last_bvec(prev, &pb);
+ 		bio_get_first_bvec(next, &nb);
+ 
+ 		if (!bios_segs_mergeable(q, prev, &pb, &nb))
+ 			return __bvec_gap_to_prev(q, &pb, nb.bv_offset);
+ 	}
+ 
+ 	return false;
++>>>>>>> 5a8d75a1b8c9 (block: fix bio_will_gap() for first bvec with offset)
  }
  
  static inline bool req_gap_back_merge(struct request *req, struct bio *bio)
@@@ -1512,11 -1719,11 +1571,11 @@@
  
  static inline bool req_gap_front_merge(struct request *req, struct bio *bio)
  {
- 	return bio_will_gap(req->q, bio, req->bio);
+ 	return bio_will_gap(req->q, NULL, bio, req->bio);
  }
  
 +struct work_struct;
  int kblockd_schedule_work(struct work_struct *work);
 -int kblockd_schedule_work_on(int cpu, struct work_struct *work);
  int kblockd_schedule_delayed_work(struct delayed_work *dwork, unsigned long delay);
  int kblockd_schedule_delayed_work_on(int cpu, struct delayed_work *dwork, unsigned long delay);
  
* Unmerged path include/linux/blkdev.h
