kvm: introduce KVM_MAX_VCPU_ID

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Greg Kurz <gkurz@linux.vnet.ibm.com>
commit 0b1b1dfd52a67f4f09a18cb82337199bc90ad7fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0b1b1dfd.failed

The KVM_MAX_VCPUS define provides the maximum number of vCPUs per guest, and
also the upper limit for vCPU ids. This is okay for all archs except PowerPC
which can have higher ids, depending on the cpu/core/thread topology. In the
worst case (single threaded guest, host with 8 threads per core), it limits
the maximum number of vCPUS to KVM_MAX_VCPUS / 8.

This patch separates the vCPU numbering from the total number of vCPUs, with
the introduction of KVM_MAX_VCPU_ID, as the maximal valid value for vCPU ids
plus one.

The corresponding KVM_CAP_MAX_VCPU_ID allows userspace to validate vCPU ids
before passing them to KVM_CREATE_VCPU.

This patch only implements KVM_MAX_VCPU_ID with a specific value for PowerPC.
Other archs continue to return KVM_MAX_VCPUS instead.

	Suggested-by: Radim Krcmar <rkrcmar@redhat.com>
	Signed-off-by: Greg Kurz <gkurz@linux.vnet.ibm.com>
	Reviewed-by: Cornelia Huck <cornelia.huck@de.ibm.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 0b1b1dfd52a67f4f09a18cb82337199bc90ad7fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/kvm_host.h
#	include/linux/kvm_host.h
#	include/uapi/linux/kvm.h
diff --cc arch/powerpc/include/asm/kvm_host.h
index 8841a038084f,a07645c17818..000000000000
--- a/arch/powerpc/include/asm/kvm_host.h
+++ b/arch/powerpc/include/asm/kvm_host.h
@@@ -40,7 -40,8 +40,12 @@@
  #define KVM_MAX_VCORES		NR_CPUS
  #define KVM_USER_MEM_SLOTS	512
  
++<<<<<<< HEAD
 +#define __KVM_HAVE_ARCH_INTC_INITIALIZED
++=======
+ #include <asm/cputhreads.h>
+ #define KVM_MAX_VCPU_ID                (threads_per_subcore * KVM_MAX_VCORES)
++>>>>>>> 0b1b1dfd52a6 (kvm: introduce KVM_MAX_VCPU_ID)
  
  #ifdef CONFIG_KVM_MMIO
  #define KVM_COALESCED_MMIO_PAGE_OFFSET 1
diff --cc include/linux/kvm_host.h
index b42a4bf67232,352889d6e322..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -34,8 -35,8 +34,13 @@@
  
  #include <asm/kvm_host.h>
  
++<<<<<<< HEAD
 +#ifndef KVM_MMIO_SIZE
 +#define KVM_MMIO_SIZE 8
++=======
+ #ifndef KVM_MAX_VCPU_ID
+ #define KVM_MAX_VCPU_ID KVM_MAX_VCPUS
++>>>>>>> 0b1b1dfd52a6 (kvm: introduce KVM_MAX_VCPU_ID)
  #endif
  
  /*
diff --cc include/uapi/linux/kvm.h
index 9f7c8e1d99b2,05ebf475104c..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -691,7 -860,12 +691,16 @@@ struct kvm_ppc_smmu_info 
  #define KVM_CAP_GUEST_DEBUG_HW_WPS 120
  #define KVM_CAP_SPLIT_IRQCHIP 121
  #define KVM_CAP_IOEVENTFD_ANY_LENGTH 122
++<<<<<<< HEAD
 +#define KVM_CAP_X2APIC_API 129
++=======
+ #define KVM_CAP_HYPERV_SYNIC 123
+ #define KVM_CAP_S390_RI 124
+ #define KVM_CAP_SPAPR_TCE_64 125
+ #define KVM_CAP_ARM_PMU_V3 126
+ #define KVM_CAP_VCPU_ATTRIBUTES 127
+ #define KVM_CAP_MAX_VCPU_ID 128
++>>>>>>> 0b1b1dfd52a6 (kvm: introduce KVM_MAX_VCPU_ID)
  
  #ifdef KVM_CAP_IRQ_ROUTING
  
diff --git a/Documentation/virtual/kvm/api.txt b/Documentation/virtual/kvm/api.txt
index 7d0b79a97ed9..55aa80b43db6 100644
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@ -199,8 +199,8 @@ Type: vm ioctl
 Parameters: vcpu id (apic id on x86)
 Returns: vcpu fd on success, -1 on error
 
-This API adds a vcpu to a virtual machine.  The vcpu id is a small integer
-in the range [0, max_vcpus).
+This API adds a vcpu to a virtual machine. No more than max_vcpus may be added.
+The vcpu id is an integer in the range [0, max_vcpu_id).
 
 The recommended max_vcpus value can be retrieved using the KVM_CAP_NR_VCPUS of
 the KVM_CHECK_EXTENSION ioctl() at run-time.
@@ -212,6 +212,12 @@ cpus max.
 If the KVM_CAP_MAX_VCPUS does not exist, you should assume that max_vcpus is
 same as the value returned from KVM_CAP_NR_VCPUS.
 
+The maximum possible value for max_vcpu_id can be retrieved using the
+KVM_CAP_MAX_VCPU_ID of the KVM_CHECK_EXTENSION ioctl() at run-time.
+
+If the KVM_CAP_MAX_VCPU_ID does not exist, you should assume that max_vcpu_id
+is the same as the value returned from KVM_CAP_MAX_VCPUS.
+
 On powerpc using book3s_hv mode, the vcpus are mapped onto virtual
 threads in one or more virtual CPU cores.  (This is because the
 hardware requires all the hardware threads in a CPU core to be in the
* Unmerged path arch/powerpc/include/asm/kvm_host.h
* Unmerged path include/linux/kvm_host.h
* Unmerged path include/uapi/linux/kvm.h
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index f69003c71f36..419f1c505066 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -2368,7 +2368,7 @@ static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)
 	int r;
 	struct kvm_vcpu *vcpu, *v;
 
-	if (id >= KVM_MAX_VCPUS)
+	if (id >= KVM_MAX_VCPU_ID)
 		return -EINVAL;
 
 	vcpu = kvm_arch_vcpu_create(kvm, id);
@@ -2849,6 +2849,8 @@ static long kvm_vm_ioctl_check_extension_generic(struct kvm *kvm, long arg)
 	case KVM_CAP_MULTI_ADDRESS_SPACE:
 		return KVM_ADDRESS_SPACE_NUM;
 #endif
+	case KVM_CAP_MAX_VCPU_ID:
+		return KVM_MAX_VCPU_ID;
 	default:
 		break;
 	}
