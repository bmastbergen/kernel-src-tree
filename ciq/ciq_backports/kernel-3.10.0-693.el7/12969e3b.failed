HID: wacom: make the WL connection friendly for the desktop

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: make the WL connection friendly for the desktop (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.58%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 12969e3bdce5f63fbce2b6d616fdbc8eeb539f01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/12969e3b.failed

Currently, tablets connected to the WL receiver all share the same
VID/PID. There is no way for the user space to know which one is which
besides parsing the name. We can force the PID to be set to the
actual hardware. This way, the input device will have the correct PID
which can be match in libwacom.

With only this trick, the pad input does not inherit the ID_INPUT_TABLET
udev property from its parent. We can force udev to accept it by declaring
a BTN_STYLUS which is never used.

This way, tablets connected through WL can be used from the user point of
view in the same way they are used while connected through wire.

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Reviewed-by: Ping Cheng <pingc@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 12969e3bdce5f63fbce2b6d616fdbc8eeb539f01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,a8b7f16f76fa..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1127,11 -983,79 +1127,50 @@@ static void wacom_destroy_battery(struc
  	}
  }
  
 -static ssize_t wacom_show_speed(struct device *dev,
 -				struct device_attribute
 -				*attr, char *buf)
 -{
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -
 -	return snprintf(buf, PAGE_SIZE, "%i\n", wacom->wacom_wac.bt_high_speed);
 -}
 -
 -static ssize_t wacom_store_speed(struct device *dev,
 -				struct device_attribute *attr,
 -				const char *buf, size_t count)
 -{
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	u8 new_speed;
 -
 -	if (kstrtou8(buf, 0, &new_speed))
 -		return -EINVAL;
 -
 -	if (new_speed != 0 && new_speed != 1)
 -		return -EINVAL;
 -
 -	wacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);
 -
 -	return count;
 -}
 -
 -static DEVICE_ATTR(speed, DEV_ATTR_RW_PERM,
 -		wacom_show_speed, wacom_store_speed);
 -
 -static struct input_dev *wacom_allocate_input(struct wacom *wacom)
 +static int wacom_register_input(struct wacom *wacom)
  {
  	struct input_dev *input_dev;
++<<<<<<< HEAD
 +	struct usb_interface *intf = wacom->intf;
 +	struct usb_device *dev = interface_to_usbdev(intf);
++=======
+ 	struct hid_device *hdev = wacom->hdev;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	input_dev = input_allocate_device();
+ 	if (!input_dev)
+ 		return NULL;
+ 
+ 	input_dev->name = wacom_wac->name;
+ 	input_dev->phys = hdev->phys;
+ 	input_dev->dev.parent = &hdev->dev;
+ 	input_dev->open = wacom_open;
+ 	input_dev->close = wacom_close;
+ 	input_dev->uniq = hdev->uniq;
+ 	input_dev->id.bustype = hdev->bus;
+ 	input_dev->id.vendor  = hdev->vendor;
+ 	input_dev->id.product = wacom_wac->pid ? wacom_wac->pid : hdev->product;
+ 	input_dev->id.version = hdev->version;
+ 	input_set_drvdata(input_dev, wacom);
+ 
+ 	return input_dev;
+ }
+ 
+ static void wacom_unregister_inputs(struct wacom *wacom)
+ {
+ 	if (wacom->wacom_wac.input)
+ 		input_unregister_device(wacom->wacom_wac.input);
+ 	if (wacom->wacom_wac.pad_input)
+ 		input_unregister_device(wacom->wacom_wac.pad_input);
+ 	wacom->wacom_wac.input = NULL;
+ 	wacom->wacom_wac.pad_input = NULL;
+ 	wacom_destroy_leds(wacom);
+ }
+ 
+ static int wacom_register_inputs(struct wacom *wacom)
+ {
+ 	struct input_dev *input_dev, *pad_input_dev;
++>>>>>>> 12969e3bdce5 (HID: wacom: make the WL connection friendly for the desktop)
  	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
  	int error;
  
diff --cc drivers/hid/wacom_wac.c
index 01ec753fea53,b8180e40534d..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1587,6 -1775,246 +1587,249 @@@ int wacom_setup_input_capabilities(stru
  		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
++<<<<<<< HEAD
++=======
+ 	case GRAPHIRE_BT:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 		input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 					      features->distance_max,
+ 					      0, 0);
+ 
+ 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
+ 
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		__set_bit(BTN_MIDDLE, input_dev->keybit);
+ 
+ 		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_MOUSE, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 		break;
+ 
+ 	case WACOM_24HD:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		input_set_abs_params(input_dev, ABS_THROTTLE, 0, 71, 0, 0);
+ 		/* fall through */
+ 
+ 	case DTK:
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 
+ 		wacom_setup_cintiq(wacom_wac);
+ 		break;
+ 
+ 	case WACOM_22HD:
+ 	case WACOM_21UX2:
+ 	case WACOM_BEE:
+ 	case CINTIQ:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 
+ 		wacom_setup_cintiq(wacom_wac);
+ 		break;
+ 
+ 	case WACOM_13HD:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		wacom_setup_cintiq(wacom_wac);
+ 		break;
+ 
+ 	case INTUOS3:
+ 	case INTUOS3L:
+ 	case INTUOS3S:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		/* fall through */
+ 
+ 	case INTUOS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		wacom_setup_intuos(wacom_wac);
+ 		break;
+ 
+ 	case INTUOS5:
+ 	case INTUOS5L:
+ 	case INTUOSPM:
+ 	case INTUOSPL:
+ 	case INTUOS5S:
+ 	case INTUOSPS:
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 
+ 		if (features->device_type == BTN_TOOL_PEN) {
+ 			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 					      features->distance_max,
+ 					      0, 0);
+ 
+ 			input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 
+ 			wacom_setup_intuos(wacom_wac);
+ 		} else if (features->device_type == BTN_TOOL_FINGER) {
+ 			__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,
+ 			                     0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR,
+ 			                     0, features->y_max, 0, 0);
+ 			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 		}
+ 		break;
+ 
+ 	case INTUOS4:
+ 	case INTUOS4WL:
+ 	case INTUOS4L:
+ 	case INTUOS4S:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		wacom_setup_intuos(wacom_wac);
+ 
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 		break;
+ 
+ 	case WACOM_24HDT:
+ 		if (features->device_type == BTN_TOOL_FINGER) {
+ 			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
+ 			input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
+ 		}
+ 		/* fall through */
+ 
+ 	case MTSCREEN:
+ 	case MTTPC:
+ 	case MTTPC_B:
+ 	case TABLETPC2FG:
+ 		if (features->device_type == BTN_TOOL_FINGER && features->touch_max > 1)
+ 			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_DIRECT);
+ 		/* fall through */
+ 
+ 	case TABLETPC:
+ 	case TABLETPCE:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 
+ 		if (features->device_type != BTN_TOOL_PEN)
+ 			break;  /* no need to process stylus stuff */
+ 
+ 		/* fall through */
+ 
+ 	case DTUS:
+ 	case PL:
+ 	case DTU:
+ 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 		break;
+ 
+ 	case PTU:
+ 		__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 		/* fall through */
+ 
+ 	case PENPARTNER:
+ 		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 		__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 		break;
+ 
+ 	case INTUOSHT:
+ 		if (features->touch_max &&
+ 		    features->device_type == BTN_TOOL_FINGER) {
+ 			input_dev->evbit[0] |= BIT_MASK(EV_SW);
+ 			__set_bit(SW_MUTE_DEVICE, input_dev->swbit);
+ 		}
+ 		/* fall through */
+ 
+ 	case BAMBOO_PT:
+ 		__clear_bit(ABS_MISC, input_dev->absbit);
+ 
+ 		if (features->device_type == BTN_TOOL_FINGER) {
+ 
+ 			if (features->touch_max) {
+ 				if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
+ 					input_set_abs_params(input_dev,
+ 						     ABS_MT_TOUCH_MAJOR,
+ 						     0, features->x_max, 0, 0);
+ 					input_set_abs_params(input_dev,
+ 						     ABS_MT_TOUCH_MINOR,
+ 						     0, features->y_max, 0, 0);
+ 				}
+ 				input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
+ 			} else {
+ 				/* buttons/keys only interface */
+ 				__clear_bit(ABS_X, input_dev->absbit);
+ 				__clear_bit(ABS_Y, input_dev->absbit);
+ 				__clear_bit(BTN_TOUCH, input_dev->keybit);
+ 			}
+ 		} else if (features->device_type == BTN_TOOL_PEN) {
+ 			__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
+ 			__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
+ 			__set_bit(BTN_STYLUS, input_dev->keybit);
+ 			__set_bit(BTN_STYLUS2, input_dev->keybit);
+ 			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
+ 					      features->distance_max,
+ 					      0, 0);
+ 		}
+ 		break;
+ 
+ 	case CINTIQ_HYBRID:
+ 		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
+ 		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
+ 
+ 		wacom_setup_cintiq(wacom_wac);
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ int wacom_setup_pad_input_capabilities(struct input_dev *input_dev,
+ 				   struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	int i;
+ 
+ 	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+ 
+ 	/* kept for making legacy xf86-input-wacom working with the wheels */
+ 	__set_bit(ABS_MISC, input_dev->absbit);
+ 
+ 	/* kept for making legacy xf86-input-wacom accepting the pad */
+ 	input_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);
+ 
+ 	/* kept for making udev and libwacom accepting the pad */
+ 	__set_bit(BTN_STYLUS, input_dev->keybit);
+ 
+ 	switch (features->type) {
+ 	case GRAPHIRE_BT:
+ 		__set_bit(BTN_0, input_dev->keybit);
+ 		__set_bit(BTN_1, input_dev->keybit);
+ 		break;
+ 
+ 	case WACOM_MO:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
+ 		break;
+ 
+ 	case WACOM_G4:
+ 		__set_bit(BTN_BACK, input_dev->keybit);
+ 		__set_bit(BTN_LEFT, input_dev->keybit);
+ 		__set_bit(BTN_FORWARD, input_dev->keybit);
+ 		__set_bit(BTN_RIGHT, input_dev->keybit);
+ 		input_set_capability(input_dev, EV_REL, REL_WHEEL);
+ 		break;
+ 
++>>>>>>> 12969e3bdce5 (HID: wacom: make the WL connection friendly for the desktop)
  	case WACOM_24HD:
  		__set_bit(BTN_A, input_dev->keybit);
  		__set_bit(BTN_B, input_dev->keybit);
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
