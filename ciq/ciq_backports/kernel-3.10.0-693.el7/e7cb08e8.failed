scsi: zfcp: spin_lock_irqsave() is not nestable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Dan Carpenter <dan.carpenter@oracle.com>
commit e7cb08e894a0b876443ef8fdb0706575dc00a5d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e7cb08e8.failed

We accidentally overwrite the original saved value of "flags" so that we
can't re-enable IRQs at the end of the function.  Presumably this
function is mostly called with IRQs disabled or it would be obvious in
testing.

Fixes: aceeffbb59bb ("zfcp: trace full payload of all SAN records (req,resp,iels)")
	Cc: <stable@vger.kernel.org> #2.6.38+
	Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit e7cb08e894a0b876443ef8fdb0706575dc00a5d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/scsi/zfcp_dbf.c
diff --cc drivers/s390/scsi/zfcp_dbf.c
index b92faed3bf21,581001989937..000000000000
--- a/drivers/s390/scsi/zfcp_dbf.c
+++ b/drivers/s390/scsi/zfcp_dbf.c
@@@ -369,10 -372,41 +369,39 @@@ void zfcp_dbf_san(char *tag, struct zfc
  	rec->id = id;
  	rec->fsf_req_id = req_id;
  	rec->d_id = d_id;
 +	rec_len = min(len, (u16)ZFCP_DBF_SAN_MAX_PAYLOAD);
 +	memcpy(rec->payload, data, rec_len);
  	memcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);
 -	rec->pl_len = len; /* full length even if we cap pay below */
 -	if (!sg)
 -		goto out;
 -	rec_len = min_t(unsigned int, sg->length, ZFCP_DBF_SAN_MAX_PAYLOAD);
 -	memcpy(rec->payload, sg_virt(sg), rec_len); /* part of 1st sg entry */
 -	if (len <= rec_len)
 -		goto out; /* skip pay record if full content in rec->payload */
  
++<<<<<<< HEAD
++=======
+ 	/* if (len > rec_len):
+ 	 * dump data up to cap_len ignoring small duplicate in rec->payload
+ 	 */
+ 	spin_lock(&dbf->pay_lock);
+ 	memset(payload, 0, sizeof(*payload));
+ 	memcpy(payload->area, paytag, ZFCP_DBF_TAG_LEN);
+ 	payload->fsf_req_id = req_id;
+ 	payload->counter = 0;
+ 	for (; sg && pay_sum < cap_len; sg = sg_next(sg)) {
+ 		u16 pay_len, offset = 0;
+ 
+ 		while (offset < sg->length && pay_sum < cap_len) {
+ 			pay_len = min((u16)ZFCP_DBF_PAY_MAX_REC,
+ 				      (u16)(sg->length - offset));
+ 			/* cap_len <= pay_sum < cap_len+ZFCP_DBF_PAY_MAX_REC */
+ 			memcpy(payload->data, sg_virt(sg) + offset, pay_len);
+ 			debug_event(dbf->pay, 1, payload,
+ 				    zfcp_dbf_plen(pay_len));
+ 			payload->counter++;
+ 			offset += pay_len;
+ 			pay_sum += pay_len;
+ 		}
+ 	}
+ 	spin_unlock(&dbf->pay_lock);
+ 
+ out:
++>>>>>>> e7cb08e894a0 (scsi: zfcp: spin_lock_irqsave() is not nestable)
  	debug_event(dbf->san, 1, rec, sizeof(*rec));
  	spin_unlock_irqrestore(&dbf->san_lock, flags);
  }
* Unmerged path drivers/s390/scsi/zfcp_dbf.c
