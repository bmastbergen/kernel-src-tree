crypto: ccp - Updates for checkpatch warnings/errors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] ccp - Updates for checkpatch warnings/errors (Suravee Suthikulpanit) [1390820]
Rebuild_FUZZ: 91.67%
commit-author Tom Lendacky <thomas.lendacky@amd.com>
commit 8db8846754767bc955eaf7e28db8a94787d12ce6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8db88467.failed

Changes to address warnings and errors reported by the checkpatch
script.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 8db8846754767bc955eaf7e28db8a94787d12ce6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/ccp/ccp-crypto-aes-cmac.c
#	drivers/crypto/ccp/ccp-crypto-aes-xts.c
#	drivers/crypto/ccp/ccp-crypto-aes.c
#	drivers/crypto/ccp/ccp-crypto-main.c
#	drivers/crypto/ccp/ccp-crypto-sha.c
#	drivers/crypto/ccp/ccp-crypto.h
#	drivers/crypto/ccp/ccp-dev.h
#	drivers/crypto/ccp/ccp-ops.c
#	drivers/crypto/ccp/ccp-platform.c
diff --cc drivers/crypto/ccp/ccp-dev.h
index 72bf1536b653,6ff89031fb96..000000000000
--- a/drivers/crypto/ccp/ccp-dev.h
+++ b/drivers/crypto/ccp/ccp-dev.h
@@@ -30,6 -30,8 +30,11 @@@
  
  #define TRNG_RETRIES			10
  
++<<<<<<< HEAD
++=======
+ #define CACHE_NONE			0x00
+ #define CACHE_WB_NO_ALLOC		0xb7
++>>>>>>> 8db884675476 (crypto: ccp - Updates for checkpatch warnings/errors)
  
  /****** Register Mappings ******/
  #define Q_MASK_REG			0x000
@@@ -48,11 -50,11 +53,11 @@@
  #define CMD_Q_INT_STATUS_BASE		0x214
  #define CMD_Q_STATUS_INCR		0x20
  
 -#define CMD_Q_CACHE_BASE		0x228
 +#define CMD_Q_CACHE			0x228
  #define CMD_Q_CACHE_INC			0x20
  
- #define CMD_Q_ERROR(__qs)		((__qs) & 0x0000003f);
- #define CMD_Q_DEPTH(__qs)		(((__qs) >> 12) & 0x0000000f);
+ #define CMD_Q_ERROR(__qs)		((__qs) & 0x0000003f)
+ #define CMD_Q_DEPTH(__qs)		(((__qs) >> 12) & 0x0000000f)
  
  /****** REQ0 Related Values ******/
  #define REQ0_WAIT_FOR_WRITE		0x00000004
@@@ -253,9 -253,11 +256,8 @@@ struct ccp_device 
  	/* Suspend support */
  	unsigned int suspending;
  	wait_queue_head_t suspend_queue;
 -
 -	/* DMA caching attribute support */
 -	unsigned int axcache;
  };
  
- 
  int ccp_pci_init(void);
  void ccp_pci_exit(void);
  
diff --cc drivers/crypto/ccp/ccp-ops.c
index 9f0b4d5a712e,71f2e3c89424..000000000000
--- a/drivers/crypto/ccp/ccp-ops.c
+++ b/drivers/crypto/ccp/ccp-ops.c
@@@ -728,17 -751,19 +726,18 @@@ static void ccp_prepare_data(struct ccp
  
  	/* The CCP can only DMA from/to one address each per operation. This
  	 * requires that we find the smallest DMA area between the source
 -	 * and destination. The resulting len values will always be <= UINT_MAX
 -	 * because the dma length is an unsigned int.
 +	 * and destination.
  	 */
 -	sg_src_len = sg_dma_len(src->sg_wa.sg) - src->sg_wa.sg_used;
 -	sg_src_len = min_t(u64, src->sg_wa.bytes_left, sg_src_len);
 +	sg_src_len = min(sg_dma_len(src->sg_wa.sg) - src->sg_wa.sg_used,
 +			 src->sg_wa.bytes_left);
  
  	if (dst) {
 -		sg_dst_len = sg_dma_len(dst->sg_wa.sg) - dst->sg_wa.sg_used;
 -		sg_dst_len = min_t(u64, src->sg_wa.bytes_left, sg_dst_len);
 +		sg_dst_len = min(sg_dma_len(dst->sg_wa.sg) - dst->sg_wa.sg_used,
 +				 src->sg_wa.bytes_left);
  		op_len = min(sg_src_len, sg_dst_len);
- 	} else
+ 	} else {
  		op_len = sg_src_len;
+ 	}
  
  	/* The data operation length will be at least block_size in length
  	 * or the smaller of available sg room remaining for the source or
@@@ -1407,7 -1432,28 +1406,32 @@@ static int ccp_run_sha_cmd(struct ccp_c
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	ccp_set_dm_area(&ctx, 0, sha->ctx, 0, sha->ctx_len);
++=======
+ 	if (sha->first) {
+ 		const __be32 *init;
+ 
+ 		switch (sha->type) {
+ 		case CCP_SHA_TYPE_1:
+ 			init = ccp_sha1_init;
+ 			break;
+ 		case CCP_SHA_TYPE_224:
+ 			init = ccp_sha224_init;
+ 			break;
+ 		case CCP_SHA_TYPE_256:
+ 			init = ccp_sha256_init;
+ 			break;
+ 		default:
+ 			ret = -EINVAL;
+ 			goto e_ctx;
+ 		}
+ 		memcpy(ctx.address, init, CCP_SHA_CTXSIZE);
+ 	} else {
+ 		ccp_set_dm_area(&ctx, 0, sha->ctx, 0, sha->ctx_len);
+ 	}
+ 
++>>>>>>> 8db884675476 (crypto: ccp - Updates for checkpatch warnings/errors)
  	ret = ccp_copy_to_ksb(cmd_q, &ctx, op.jobid, op.ksb_ctx,
  			      CCP_PASSTHRU_BYTESWAP_256BIT);
  	if (ret) {
* Unmerged path drivers/crypto/ccp/ccp-crypto-aes-cmac.c
* Unmerged path drivers/crypto/ccp/ccp-crypto-aes-xts.c
* Unmerged path drivers/crypto/ccp/ccp-crypto-aes.c
* Unmerged path drivers/crypto/ccp/ccp-crypto-main.c
* Unmerged path drivers/crypto/ccp/ccp-crypto-sha.c
* Unmerged path drivers/crypto/ccp/ccp-crypto.h
* Unmerged path drivers/crypto/ccp/ccp-platform.c
* Unmerged path drivers/crypto/ccp/ccp-crypto-aes-cmac.c
* Unmerged path drivers/crypto/ccp/ccp-crypto-aes-xts.c
* Unmerged path drivers/crypto/ccp/ccp-crypto-aes.c
* Unmerged path drivers/crypto/ccp/ccp-crypto-main.c
* Unmerged path drivers/crypto/ccp/ccp-crypto-sha.c
* Unmerged path drivers/crypto/ccp/ccp-crypto.h
diff --git a/drivers/crypto/ccp/ccp-dev.c b/drivers/crypto/ccp/ccp-dev.c
index 2777dc97b570..4350f3566f0a 100644
--- a/drivers/crypto/ccp/ccp-dev.c
+++ b/drivers/crypto/ccp/ccp-dev.c
@@ -35,7 +35,6 @@ struct ccp_tasklet_data {
 	struct ccp_cmd *cmd;
 };
 
-
 static struct ccp_device *ccp_dev;
 static inline struct ccp_device *ccp_get_device(void)
 {
@@ -281,10 +280,8 @@ struct ccp_device *ccp_alloc_struct(struct device *dev)
 	struct ccp_device *ccp;
 
 	ccp = kzalloc(sizeof(*ccp), GFP_KERNEL);
-	if (ccp == NULL) {
-		dev_err(dev, "unable to allocate device struct\n");
+	if (!ccp)
 		return NULL;
-	}
 	ccp->dev = dev;
 
 	INIT_LIST_HEAD(&ccp->cmd);
* Unmerged path drivers/crypto/ccp/ccp-dev.h
* Unmerged path drivers/crypto/ccp/ccp-ops.c
diff --git a/drivers/crypto/ccp/ccp-pci.c b/drivers/crypto/ccp/ccp-pci.c
index 15741de944bc..285f01be8083 100644
--- a/drivers/crypto/ccp/ccp-pci.c
+++ b/drivers/crypto/ccp/ccp-pci.c
@@ -205,7 +205,7 @@ static int ccp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 
 	ret = -EIO;
 	ccp->io_map = pci_iomap(pdev, bar, 0);
-	if (ccp->io_map == NULL) {
+	if (!ccp->io_map) {
 		dev_err(dev, "pci_iomap failed\n");
 		goto e_device;
 	}
* Unmerged path drivers/crypto/ccp/ccp-platform.c
