posix acls: Remove duplicate xattr name definitions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] posix acls: Remove duplicate xattr name definitions (cifs only) (Sachin Prabhu) [1416808]
Rebuild_FUZZ: 89.47%
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 97d79299223baab330b194437e676d301f12d5f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/97d79299.failed

Remove POSIX_ACL_XATTR_{ACCESS,DEFAULT} and GFS2_POSIX_ACL_{ACCESS,DEFAULT}
and replace them with the definitions in <include/uapi/linux/xattr.h>.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Reviewed-by: James Morris <james.l.morris@oracle.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 97d79299223baab330b194437e676d301f12d5f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/lustre/lustre/llite/xattr.c
#	fs/hfsplus/posix_acl.c
#	fs/jfs/acl.c
#	fs/nfs/nfs3acl.c
#	fs/posix_acl.c
diff --cc fs/jfs/acl.c
index d254d6d35995,49456853e9de..000000000000
--- a/fs/jfs/acl.c
+++ b/fs/jfs/acl.c
@@@ -80,21 -80,26 +80,43 @@@ static int jfs_set_acl(tid_t tid, struc
  	int size = 0;
  	char *value = NULL;
  
++<<<<<<< HEAD
 +	if (S_ISLNK(inode->i_mode))
 +		return -EOPNOTSUPP;
++=======
+ 	switch (type) {
+ 	case ACL_TYPE_ACCESS:
+ 		ea_name = XATTR_NAME_POSIX_ACL_ACCESS;
+ 		if (acl) {
+ 			rc = posix_acl_equiv_mode(acl, &inode->i_mode);
+ 			if (rc < 0)
+ 				return rc;
+ 			inode->i_ctime = CURRENT_TIME;
+ 			mark_inode_dirty(inode);
+ 			if (rc == 0)
+ 				acl = NULL;
+ 		}
+ 		break;
+ 	case ACL_TYPE_DEFAULT:
+ 		ea_name = XATTR_NAME_POSIX_ACL_DEFAULT;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
++>>>>>>> 97d79299223b (posix acls: Remove duplicate xattr name definitions)
  
 +	switch(type) {
 +		case ACL_TYPE_ACCESS:
 +			ea_name = POSIX_ACL_XATTR_ACCESS;
 +			break;
 +		case ACL_TYPE_DEFAULT:
 +			ea_name = POSIX_ACL_XATTR_DEFAULT;
 +			if (!S_ISDIR(inode->i_mode))
 +				return acl ? -EACCES : 0;
 +			break;
 +		default:
 +			return -EINVAL;
 +	}
  	if (acl) {
  		size = posix_acl_xattr_size(acl->a_count);
  		value = kmalloc(size, GFP_KERNEL);
diff --cc fs/nfs/nfs3acl.c
index f2d1c3ad1bca,17c0fa1eccfa..000000000000
--- a/fs/nfs/nfs3acl.c
+++ b/fs/nfs/nfs3acl.c
@@@ -418,27 -246,51 +418,59 @@@ fail
  	return PTR_ERR(alloc);
  }
  
 -const struct xattr_handler *nfs3_xattr_handlers[] = {
 -	&posix_acl_access_xattr_handler,
 -	&posix_acl_default_xattr_handler,
 -	NULL,
 -};
 -
 -static int
 -nfs3_list_one_acl(struct inode *inode, int type, const char *name, void *data,
 -		size_t size, ssize_t *result)
 +int nfs3_proc_set_default_acl(struct inode *dir, struct inode *inode,
 +		umode_t mode)
  {
 -	struct posix_acl *acl;
 -	char *p = data + *result;
 +	struct posix_acl *dfacl, *acl;
 +	int error = 0;
  
 -	acl = get_acl(inode, type);
 -	if (IS_ERR_OR_NULL(acl))
 +	dfacl = nfs3_proc_getacl(dir, ACL_TYPE_DEFAULT);
 +	if (IS_ERR(dfacl)) {
 +		error = PTR_ERR(dfacl);
 +		return (error == -EOPNOTSUPP) ? 0 : error;
 +	}
 +	if (!dfacl)
  		return 0;
 -
 +	acl = posix_acl_dup(dfacl);
 +	error = posix_acl_create(&acl, GFP_KERNEL, &mode);
 +	if (error < 0)
 +		goto out_release_dfacl;
 +	error = nfs3_proc_setacls(inode, acl, S_ISDIR(inode->i_mode) ?
 +						      dfacl : NULL);
  	posix_acl_release(acl);
++<<<<<<< HEAD
 +out_release_dfacl:
 +	posix_acl_release(dfacl);
 +	return error;
++=======
+ 
+ 	*result += strlen(name);
+ 	*result += 1;
+ 	if (!size)
+ 		return 0;
+ 	if (*result > size)
+ 		return -ERANGE;
+ 
+ 	strcpy(p, name);
+ 	return 0;
+ }
+ 
+ ssize_t
+ nfs3_listxattr(struct dentry *dentry, char *data, size_t size)
+ {
+ 	struct inode *inode = d_inode(dentry);
+ 	ssize_t result = 0;
+ 	int error;
+ 
+ 	error = nfs3_list_one_acl(inode, ACL_TYPE_ACCESS,
+ 			XATTR_NAME_POSIX_ACL_ACCESS, data, size, &result);
+ 	if (error)
+ 		return error;
+ 
+ 	error = nfs3_list_one_acl(inode, ACL_TYPE_DEFAULT,
+ 			XATTR_NAME_POSIX_ACL_DEFAULT, data, size, &result);
+ 	if (error)
+ 		return error;
+ 	return result;
++>>>>>>> 97d79299223b (posix acls: Remove duplicate xattr name definitions)
  }
diff --cc fs/posix_acl.c
index 3000aa424973,571465d6df58..000000000000
--- a/fs/posix_acl.c
+++ b/fs/posix_acl.c
@@@ -444,4 -513,387 +444,363 @@@ posix_acl_chmod(struct posix_acl **acl
  	*acl = clone;
  	return err;
  }
 -EXPORT_SYMBOL(__posix_acl_chmod);
 -
 -int
 -posix_acl_chmod(struct inode *inode, umode_t mode)
 -{
 -	struct posix_acl *acl;
 -	int ret = 0;
 -
 -	if (!IS_POSIXACL(inode))
 -		return 0;
 -	if (!inode->i_op->set_acl)
 -		return -EOPNOTSUPP;
 -
 -	acl = get_acl(inode, ACL_TYPE_ACCESS);
 -	if (IS_ERR_OR_NULL(acl)) {
 -		if (acl == ERR_PTR(-EOPNOTSUPP))
 -			return 0;
 -		return PTR_ERR(acl);
 -	}
 -
 -	ret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);
 -	if (ret)
 -		return ret;
 -	ret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);
 -	posix_acl_release(acl);
 -	return ret;
 -}
  EXPORT_SYMBOL(posix_acl_chmod);
++<<<<<<< HEAD
++=======
+ 
+ int
+ posix_acl_create(struct inode *dir, umode_t *mode,
+ 		struct posix_acl **default_acl, struct posix_acl **acl)
+ {
+ 	struct posix_acl *p;
+ 	struct posix_acl *clone;
+ 	int ret;
+ 
+ 	*acl = NULL;
+ 	*default_acl = NULL;
+ 
+ 	if (S_ISLNK(*mode) || !IS_POSIXACL(dir))
+ 		return 0;
+ 
+ 	p = get_acl(dir, ACL_TYPE_DEFAULT);
+ 	if (!p || p == ERR_PTR(-EOPNOTSUPP)) {
+ 		*mode &= ~current_umask();
+ 		return 0;
+ 	}
+ 	if (IS_ERR(p))
+ 		return PTR_ERR(p);
+ 
+ 	clone = posix_acl_clone(p, GFP_NOFS);
+ 	if (!clone)
+ 		goto no_mem;
+ 
+ 	ret = posix_acl_create_masq(clone, mode);
+ 	if (ret < 0)
+ 		goto no_mem_clone;
+ 
+ 	if (ret == 0)
+ 		posix_acl_release(clone);
+ 	else
+ 		*acl = clone;
+ 
+ 	if (!S_ISDIR(*mode))
+ 		posix_acl_release(p);
+ 	else
+ 		*default_acl = p;
+ 
+ 	return 0;
+ 
+ no_mem_clone:
+ 	posix_acl_release(clone);
+ no_mem:
+ 	posix_acl_release(p);
+ 	return -ENOMEM;
+ }
+ EXPORT_SYMBOL_GPL(posix_acl_create);
+ 
+ /*
+  * Fix up the uids and gids in posix acl extended attributes in place.
+  */
+ static void posix_acl_fix_xattr_userns(
+ 	struct user_namespace *to, struct user_namespace *from,
+ 	void *value, size_t size)
+ {
+ 	posix_acl_xattr_header *header = (posix_acl_xattr_header *)value;
+ 	posix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;
+ 	int count;
+ 	kuid_t uid;
+ 	kgid_t gid;
+ 
+ 	if (!value)
+ 		return;
+ 	if (size < sizeof(posix_acl_xattr_header))
+ 		return;
+ 	if (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))
+ 		return;
+ 
+ 	count = posix_acl_xattr_count(size);
+ 	if (count < 0)
+ 		return;
+ 	if (count == 0)
+ 		return;
+ 
+ 	for (end = entry + count; entry != end; entry++) {
+ 		switch(le16_to_cpu(entry->e_tag)) {
+ 		case ACL_USER:
+ 			uid = make_kuid(from, le32_to_cpu(entry->e_id));
+ 			entry->e_id = cpu_to_le32(from_kuid(to, uid));
+ 			break;
+ 		case ACL_GROUP:
+ 			gid = make_kgid(from, le32_to_cpu(entry->e_id));
+ 			entry->e_id = cpu_to_le32(from_kgid(to, gid));
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ void posix_acl_fix_xattr_from_user(void *value, size_t size)
+ {
+ 	struct user_namespace *user_ns = current_user_ns();
+ 	if (user_ns == &init_user_ns)
+ 		return;
+ 	posix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);
+ }
+ 
+ void posix_acl_fix_xattr_to_user(void *value, size_t size)
+ {
+ 	struct user_namespace *user_ns = current_user_ns();
+ 	if (user_ns == &init_user_ns)
+ 		return;
+ 	posix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);
+ }
+ 
+ /*
+  * Convert from extended attribute to in-memory representation.
+  */
+ struct posix_acl *
+ posix_acl_from_xattr(struct user_namespace *user_ns,
+ 		     const void *value, size_t size)
+ {
+ 	posix_acl_xattr_header *header = (posix_acl_xattr_header *)value;
+ 	posix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;
+ 	int count;
+ 	struct posix_acl *acl;
+ 	struct posix_acl_entry *acl_e;
+ 
+ 	if (!value)
+ 		return NULL;
+ 	if (size < sizeof(posix_acl_xattr_header))
+ 		 return ERR_PTR(-EINVAL);
+ 	if (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))
+ 		return ERR_PTR(-EOPNOTSUPP);
+ 
+ 	count = posix_acl_xattr_count(size);
+ 	if (count < 0)
+ 		return ERR_PTR(-EINVAL);
+ 	if (count == 0)
+ 		return NULL;
+ 	
+ 	acl = posix_acl_alloc(count, GFP_NOFS);
+ 	if (!acl)
+ 		return ERR_PTR(-ENOMEM);
+ 	acl_e = acl->a_entries;
+ 	
+ 	for (end = entry + count; entry != end; acl_e++, entry++) {
+ 		acl_e->e_tag  = le16_to_cpu(entry->e_tag);
+ 		acl_e->e_perm = le16_to_cpu(entry->e_perm);
+ 
+ 		switch(acl_e->e_tag) {
+ 			case ACL_USER_OBJ:
+ 			case ACL_GROUP_OBJ:
+ 			case ACL_MASK:
+ 			case ACL_OTHER:
+ 				break;
+ 
+ 			case ACL_USER:
+ 				acl_e->e_uid =
+ 					make_kuid(user_ns,
+ 						  le32_to_cpu(entry->e_id));
+ 				if (!uid_valid(acl_e->e_uid))
+ 					goto fail;
+ 				break;
+ 			case ACL_GROUP:
+ 				acl_e->e_gid =
+ 					make_kgid(user_ns,
+ 						  le32_to_cpu(entry->e_id));
+ 				if (!gid_valid(acl_e->e_gid))
+ 					goto fail;
+ 				break;
+ 
+ 			default:
+ 				goto fail;
+ 		}
+ 	}
+ 	return acl;
+ 
+ fail:
+ 	posix_acl_release(acl);
+ 	return ERR_PTR(-EINVAL);
+ }
+ EXPORT_SYMBOL (posix_acl_from_xattr);
+ 
+ /*
+  * Convert from in-memory to extended attribute representation.
+  */
+ int
+ posix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,
+ 		   void *buffer, size_t size)
+ {
+ 	posix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;
+ 	posix_acl_xattr_entry *ext_entry;
+ 	int real_size, n;
+ 
+ 	real_size = posix_acl_xattr_size(acl->a_count);
+ 	if (!buffer)
+ 		return real_size;
+ 	if (real_size > size)
+ 		return -ERANGE;
+ 
+ 	ext_entry = ext_acl->a_entries;
+ 	ext_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);
+ 
+ 	for (n=0; n < acl->a_count; n++, ext_entry++) {
+ 		const struct posix_acl_entry *acl_e = &acl->a_entries[n];
+ 		ext_entry->e_tag  = cpu_to_le16(acl_e->e_tag);
+ 		ext_entry->e_perm = cpu_to_le16(acl_e->e_perm);
+ 		switch(acl_e->e_tag) {
+ 		case ACL_USER:
+ 			ext_entry->e_id =
+ 				cpu_to_le32(from_kuid(user_ns, acl_e->e_uid));
+ 			break;
+ 		case ACL_GROUP:
+ 			ext_entry->e_id =
+ 				cpu_to_le32(from_kgid(user_ns, acl_e->e_gid));
+ 			break;
+ 		default:
+ 			ext_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);
+ 			break;
+ 		}
+ 	}
+ 	return real_size;
+ }
+ EXPORT_SYMBOL (posix_acl_to_xattr);
+ 
+ static int
+ posix_acl_xattr_get(const struct xattr_handler *handler,
+ 		    struct dentry *dentry, const char *name,
+ 		    void *value, size_t size)
+ {
+ 	struct posix_acl *acl;
+ 	int error;
+ 
+ 	if (strcmp(name, "") != 0)
+ 		return -EINVAL;
+ 	if (!IS_POSIXACL(d_backing_inode(dentry)))
+ 		return -EOPNOTSUPP;
+ 	if (d_is_symlink(dentry))
+ 		return -EOPNOTSUPP;
+ 
+ 	acl = get_acl(d_backing_inode(dentry), handler->flags);
+ 	if (IS_ERR(acl))
+ 		return PTR_ERR(acl);
+ 	if (acl == NULL)
+ 		return -ENODATA;
+ 
+ 	error = posix_acl_to_xattr(&init_user_ns, acl, value, size);
+ 	posix_acl_release(acl);
+ 
+ 	return error;
+ }
+ 
+ static int
+ posix_acl_xattr_set(const struct xattr_handler *handler,
+ 		    struct dentry *dentry, const char *name,
+ 		    const void *value, size_t size, int flags)
+ {
+ 	struct inode *inode = d_backing_inode(dentry);
+ 	struct posix_acl *acl = NULL;
+ 	int ret;
+ 
+ 	if (strcmp(name, "") != 0)
+ 		return -EINVAL;
+ 	if (!IS_POSIXACL(inode))
+ 		return -EOPNOTSUPP;
+ 	if (!inode->i_op->set_acl)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (handler->flags == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))
+ 		return value ? -EACCES : 0;
+ 	if (!inode_owner_or_capable(inode))
+ 		return -EPERM;
+ 
+ 	if (value) {
+ 		acl = posix_acl_from_xattr(&init_user_ns, value, size);
+ 		if (IS_ERR(acl))
+ 			return PTR_ERR(acl);
+ 
+ 		if (acl) {
+ 			ret = posix_acl_valid(acl);
+ 			if (ret)
+ 				goto out;
+ 		}
+ 	}
+ 
+ 	ret = inode->i_op->set_acl(inode, acl, handler->flags);
+ out:
+ 	posix_acl_release(acl);
+ 	return ret;
+ }
+ 
+ static size_t
+ posix_acl_xattr_list(const struct xattr_handler *handler,
+ 		     struct dentry *dentry, char *list, size_t list_size,
+ 		     const char *name, size_t name_len)
+ {
+ 	const char *xname = handler->prefix;
+ 	size_t size;
+ 
+ 	if (!IS_POSIXACL(d_backing_inode(dentry)))
+ 		return 0;
+ 
+ 	size = strlen(xname) + 1;
+ 	if (list && size <= list_size)
+ 		memcpy(list, xname, size);
+ 	return size;
+ }
+ 
+ const struct xattr_handler posix_acl_access_xattr_handler = {
+ 	.prefix = XATTR_NAME_POSIX_ACL_ACCESS,
+ 	.flags = ACL_TYPE_ACCESS,
+ 	.list = posix_acl_xattr_list,
+ 	.get = posix_acl_xattr_get,
+ 	.set = posix_acl_xattr_set,
+ };
+ EXPORT_SYMBOL_GPL(posix_acl_access_xattr_handler);
+ 
+ const struct xattr_handler posix_acl_default_xattr_handler = {
+ 	.prefix = XATTR_NAME_POSIX_ACL_DEFAULT,
+ 	.flags = ACL_TYPE_DEFAULT,
+ 	.list = posix_acl_xattr_list,
+ 	.get = posix_acl_xattr_get,
+ 	.set = posix_acl_xattr_set,
+ };
+ EXPORT_SYMBOL_GPL(posix_acl_default_xattr_handler);
+ 
+ int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)
+ {
+ 	int error;
+ 
+ 	if (type == ACL_TYPE_ACCESS) {
+ 		error = posix_acl_equiv_mode(acl, &inode->i_mode);
+ 		if (error < 0)
+ 			return 0;
+ 		if (error == 0)
+ 			acl = NULL;
+ 	}
+ 
+ 	inode->i_ctime = CURRENT_TIME;
+ 	set_cached_acl(inode, type, acl);
+ 	return 0;
+ }
+ 
+ int simple_acl_create(struct inode *dir, struct inode *inode)
+ {
+ 	struct posix_acl *default_acl, *acl;
+ 	int error;
+ 
+ 	error = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);
+ 	if (error)
+ 		return error;
+ 
+ 	set_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);
+ 	set_cached_acl(inode, ACL_TYPE_ACCESS, acl);
+ 
+ 	if (default_acl)
+ 		posix_acl_release(default_acl);
+ 	if (acl)
+ 		posix_acl_release(acl);
+ 	return 0;
+ }
++>>>>>>> 97d79299223b (posix acls: Remove duplicate xattr name definitions)
* Unmerged path drivers/staging/lustre/lustre/llite/xattr.c
* Unmerged path fs/hfsplus/posix_acl.c
* Unmerged path drivers/staging/lustre/lustre/llite/xattr.c
diff --git a/fs/9p/acl.c b/fs/9p/acl.c
index 7af425f53bee..43974940b52e 100644
--- a/fs/9p/acl.c
+++ b/fs/9p/acl.c
@@ -67,8 +67,8 @@ int v9fs_get_acl(struct inode *inode, struct p9_fid *fid)
 		return 0;
 	}
 	/* get the default/access acl values and cache them */
-	dacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_DEFAULT);
-	pacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_ACCESS);
+	dacl = __v9fs_get_acl(fid, XATTR_NAME_POSIX_ACL_DEFAULT);
+	pacl = __v9fs_get_acl(fid, XATTR_NAME_POSIX_ACL_ACCESS);
 
 	if (!IS_ERR(dacl) && !IS_ERR(pacl)) {
 		set_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);
@@ -133,10 +133,10 @@ static int v9fs_set_acl(struct p9_fid *fid, int type, struct posix_acl *acl)
 		goto err_free_out;
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		name = POSIX_ACL_XATTR_ACCESS;
+		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		break;
 	case ACL_TYPE_DEFAULT:
-		name = POSIX_ACL_XATTR_DEFAULT;
+		name = XATTR_NAME_POSIX_ACL_DEFAULT;
 		break;
 	default:
 		BUG();
@@ -367,14 +367,14 @@ err_out:
 }
 
 const struct xattr_handler v9fs_xattr_acl_access_handler = {
-	.prefix	= POSIX_ACL_XATTR_ACCESS,
+	.prefix	= XATTR_NAME_POSIX_ACL_ACCESS,
 	.flags	= ACL_TYPE_ACCESS,
 	.get	= v9fs_xattr_get_acl,
 	.set	= v9fs_xattr_set_acl,
 };
 
 const struct xattr_handler v9fs_xattr_acl_default_handler = {
-	.prefix	= POSIX_ACL_XATTR_DEFAULT,
+	.prefix	= XATTR_NAME_POSIX_ACL_DEFAULT,
 	.flags	= ACL_TYPE_DEFAULT,
 	.get	= v9fs_xattr_get_acl,
 	.set	= v9fs_xattr_set_acl,
diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index f3e8df137f07..0dc9aa1afd1c 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -44,10 +44,10 @@ struct posix_acl *btrfs_get_acl(struct inode *inode, int type)
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		name = POSIX_ACL_XATTR_ACCESS;
+		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		break;
 	case ACL_TYPE_DEFAULT:
-		name = POSIX_ACL_XATTR_DEFAULT;
+		name = XATTR_NAME_POSIX_ACL_DEFAULT;
 		break;
 	default:
 		BUG();
@@ -109,7 +109,7 @@ static int btrfs_set_acl(struct btrfs_trans_handle *trans,
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		name = POSIX_ACL_XATTR_ACCESS;
+		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			ret = posix_acl_equiv_mode(acl, &inode->i_mode);
 			if (ret < 0)
@@ -122,7 +122,7 @@ static int btrfs_set_acl(struct btrfs_trans_handle *trans,
 	case ACL_TYPE_DEFAULT:
 		if (!S_ISDIR(inode->i_mode))
 			return acl ? -EINVAL : 0;
-		name = POSIX_ACL_XATTR_DEFAULT;
+		name = XATTR_NAME_POSIX_ACL_DEFAULT;
 		break;
 	default:
 		return -EINVAL;
diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index ded5036d1968..6c9d847ed64b 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -3545,10 +3545,10 @@ static noinline int acls_after_inode_item(struct extent_buffer *leaf,
 	int scanned = 0;
 
 	if (!xattr_access) {
-		xattr_access = btrfs_name_hash(POSIX_ACL_XATTR_ACCESS,
-					strlen(POSIX_ACL_XATTR_ACCESS));
-		xattr_default = btrfs_name_hash(POSIX_ACL_XATTR_DEFAULT,
-					strlen(POSIX_ACL_XATTR_DEFAULT));
+		xattr_access = btrfs_name_hash(XATTR_NAME_POSIX_ACL_ACCESS,
+					strlen(XATTR_NAME_POSIX_ACL_ACCESS));
+		xattr_default = btrfs_name_hash(XATTR_NAME_POSIX_ACL_DEFAULT,
+					strlen(XATTR_NAME_POSIX_ACL_DEFAULT));
 	}
 
 	slot++;
diff --git a/fs/ceph/acl.c b/fs/ceph/acl.c
index 13ef95e2a2db..b594172b45f0 100644
--- a/fs/ceph/acl.c
+++ b/fs/ceph/acl.c
@@ -70,10 +70,10 @@ struct posix_acl *ceph_get_acl(struct inode *inode, int type)
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		name = POSIX_ACL_XATTR_ACCESS;
+		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		break;
 	case ACL_TYPE_DEFAULT:
-		name = POSIX_ACL_XATTR_DEFAULT;
+		name = XATTR_NAME_POSIX_ACL_DEFAULT;
 		break;
 	default:
 		BUG();
@@ -113,7 +113,7 @@ static int ceph_set_acl(struct dentry *dentry, struct inode *inode,
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		name = POSIX_ACL_XATTR_ACCESS;
+		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			ret = posix_acl_equiv_mode(acl, &new_mode);
 			if (ret < 0)
@@ -127,7 +127,7 @@ static int ceph_set_acl(struct dentry *dentry, struct inode *inode,
 			ret = acl ? -EINVAL : 0;
 			goto out;
 		}
-		name = POSIX_ACL_XATTR_DEFAULT;
+		name = XATTR_NAME_POSIX_ACL_DEFAULT;
 		break;
 	default:
 		ret = -EINVAL;
@@ -233,11 +233,11 @@ int ceph_pre_init_acls(struct inode *dir, umode_t *mode,
 	ceph_pagelist_encode_32(pagelist, acl && default_acl ? 2 : 1);
 
 	if (acl) {
-		size_t len = strlen(POSIX_ACL_XATTR_ACCESS);
+		size_t len = strlen(XATTR_NAME_POSIX_ACL_ACCESS);
 		err = ceph_pagelist_reserve(pagelist, len + val_size1 + 8);
 		if (err)
 			goto out_err;
-		ceph_pagelist_encode_string(pagelist, POSIX_ACL_XATTR_ACCESS,
+		ceph_pagelist_encode_string(pagelist, XATTR_NAME_POSIX_ACL_ACCESS,
 					    len);
 		err = posix_acl_to_xattr(&init_user_ns, acl,
 					 tmp_buf, val_size1);
@@ -247,12 +247,12 @@ int ceph_pre_init_acls(struct inode *dir, umode_t *mode,
 		ceph_pagelist_append(pagelist, tmp_buf, val_size1);
 	}
 	if (default_acl) {
-		size_t len = strlen(POSIX_ACL_XATTR_DEFAULT);
+		size_t len = strlen(XATTR_NAME_POSIX_ACL_DEFAULT);
 		err = ceph_pagelist_reserve(pagelist, len + val_size2 + 8);
 		if (err)
 			goto out_err;
 		err = ceph_pagelist_encode_string(pagelist,
-						  POSIX_ACL_XATTR_DEFAULT, len);
+						  XATTR_NAME_POSIX_ACL_DEFAULT, len);
 		err = posix_acl_to_xattr(&init_user_ns, default_acl,
 					 tmp_buf, val_size2);
 		if (err < 0)
diff --git a/fs/cifs/xattr.c b/fs/cifs/xattr.c
index ff9e1f8b16a4..f5dc2f0df4ad 100644
--- a/fs/cifs/xattr.c
+++ b/fs/cifs/xattr.c
@@ -190,8 +190,8 @@ int cifs_setxattr(struct dentry *direntry, const char *ea_name,
 #endif /* CONFIG_CIFS_ACL */
 	} else {
 		int temp;
-		temp = strncmp(ea_name, POSIX_ACL_XATTR_ACCESS,
-			strlen(POSIX_ACL_XATTR_ACCESS));
+		temp = strncmp(ea_name, XATTR_NAME_POSIX_ACL_ACCESS,
+			strlen(XATTR_NAME_POSIX_ACL_ACCESS));
 		if (temp == 0) {
 #ifdef CONFIG_CIFS_POSIX
 			if (sb->s_flags & MS_POSIXACL)
@@ -203,8 +203,8 @@ int cifs_setxattr(struct dentry *direntry, const char *ea_name,
 #else
 			cifs_dbg(FYI, "set POSIX ACL not supported\n");
 #endif
-		} else if (strncmp(ea_name, POSIX_ACL_XATTR_DEFAULT,
-				   strlen(POSIX_ACL_XATTR_DEFAULT)) == 0) {
+		} else if (strncmp(ea_name, XATTR_NAME_POSIX_ACL_DEFAULT,
+				   strlen(XATTR_NAME_POSIX_ACL_DEFAULT)) == 0) {
 #ifdef CONFIG_CIFS_POSIX
 			if (sb->s_flags & MS_POSIXACL)
 				rc = CIFSSMBSetPosixACL(xid, pTcon, full_path,
@@ -292,8 +292,8 @@ ssize_t cifs_getxattr(struct dentry *direntry, const char *ea_name,
 			rc = pTcon->ses->server->ops->query_all_EAs(xid, pTcon,
 				full_path, ea_name, ea_value, buf_size,
 				cifs_sb->local_nls, cifs_remap(cifs_sb));
-	} else if (strncmp(ea_name, POSIX_ACL_XATTR_ACCESS,
-			  strlen(POSIX_ACL_XATTR_ACCESS)) == 0) {
+	} else if (strncmp(ea_name, XATTR_NAME_POSIX_ACL_ACCESS,
+			  strlen(XATTR_NAME_POSIX_ACL_ACCESS)) == 0) {
 #ifdef CONFIG_CIFS_POSIX
 		if (sb->s_flags & MS_POSIXACL)
 			rc = CIFSSMBGetPosixACL(xid, pTcon, full_path,
@@ -303,8 +303,8 @@ ssize_t cifs_getxattr(struct dentry *direntry, const char *ea_name,
 #else
 		cifs_dbg(FYI, "Query POSIX ACL not supported yet\n");
 #endif /* CONFIG_CIFS_POSIX */
-	} else if (strncmp(ea_name, POSIX_ACL_XATTR_DEFAULT,
-			  strlen(POSIX_ACL_XATTR_DEFAULT)) == 0) {
+	} else if (strncmp(ea_name, XATTR_NAME_POSIX_ACL_DEFAULT,
+			  strlen(XATTR_NAME_POSIX_ACL_DEFAULT)) == 0) {
 #ifdef CONFIG_CIFS_POSIX
 		if (sb->s_flags & MS_POSIXACL)
 			rc = CIFSSMBGetPosixACL(xid, pTcon, full_path,
diff --git a/fs/gfs2/acl.c b/fs/gfs2/acl.c
index 478ce00b530e..9c9a4aaf5650 100644
--- a/fs/gfs2/acl.c
+++ b/fs/gfs2/acl.c
@@ -31,9 +31,9 @@ static const char *gfs2_acl_name(int type)
 {
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		return GFS2_POSIX_ACL_ACCESS;
+		return XATTR_POSIX_ACL_ACCESS;
 	case ACL_TYPE_DEFAULT:
-		return GFS2_POSIX_ACL_DEFAULT;
+		return XATTR_POSIX_ACL_DEFAULT;
 	}
 	return NULL;
 }
diff --git a/fs/gfs2/acl.h b/fs/gfs2/acl.h
index ddc2cc8ab933..f7d50c38aede 100644
--- a/fs/gfs2/acl.h
+++ b/fs/gfs2/acl.h
@@ -12,8 +12,6 @@
 
 #include "incore.h"
 
-#define GFS2_POSIX_ACL_ACCESS		"posix_acl_access"
-#define GFS2_POSIX_ACL_DEFAULT		"posix_acl_default"
 #define GFS2_ACL_MAX_ENTRIES(sdp) ((300 << (sdp)->sd_sb.sb_bsize_shift) >> 12)
 
 extern struct posix_acl *gfs2_get_acl(struct inode *inode, int type);
* Unmerged path fs/hfsplus/posix_acl.c
* Unmerged path fs/jfs/acl.c
* Unmerged path fs/nfs/nfs3acl.c
* Unmerged path fs/posix_acl.c
diff --git a/fs/reiserfs/xattr_acl.c b/fs/reiserfs/xattr_acl.c
index 6c8767fdfc6a..5ae8ca7f2346 100644
--- a/fs/reiserfs/xattr_acl.c
+++ b/fs/reiserfs/xattr_acl.c
@@ -225,10 +225,10 @@ struct posix_acl *reiserfs_get_acl(struct inode *inode, int type)
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		name = POSIX_ACL_XATTR_ACCESS;
+		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		break;
 	case ACL_TYPE_DEFAULT:
-		name = POSIX_ACL_XATTR_DEFAULT;
+		name = XATTR_NAME_POSIX_ACL_DEFAULT;
 		break;
 	default:
 		BUG();
@@ -284,7 +284,7 @@ reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		name = POSIX_ACL_XATTR_ACCESS;
+		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
 			error = posix_acl_equiv_mode(acl, &inode->i_mode);
 			if (error < 0)
@@ -296,7 +296,7 @@ reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
-		name = POSIX_ACL_XATTR_DEFAULT;
+		name = XATTR_NAME_POSIX_ACL_DEFAULT;
 		if (!S_ISDIR(inode->i_mode))
 			return acl ? -EACCES : 0;
 		break;
diff --git a/fs/xfs/xfs_xattr.c b/fs/xfs/xfs_xattr.c
index 2a753b46d3d8..7162efb863f8 100644
--- a/fs/xfs/xfs_xattr.c
+++ b/fs/xfs/xfs_xattr.c
@@ -251,16 +251,16 @@ xfs_vn_listxattr(struct dentry *dentry, char *data, size_t size)
 	 * Then add the two synthetic ACL attributes.
 	 */
 	if (posix_acl_access_exists(inode)) {
-		error = list_one_attr(POSIX_ACL_XATTR_ACCESS,
-				strlen(POSIX_ACL_XATTR_ACCESS) + 1,
+		error = list_one_attr(XATTR_NAME_POSIX_ACL_ACCESS,
+				strlen(XATTR_NAME_POSIX_ACL_ACCESS) + 1,
 				data, size, &context.count);
 		if (error)
 			return error;
 	}
 
 	if (posix_acl_default_exists(inode)) {
-		error = list_one_attr(POSIX_ACL_XATTR_DEFAULT,
-				strlen(POSIX_ACL_XATTR_DEFAULT) + 1,
+		error = list_one_attr(XATTR_NAME_POSIX_ACL_DEFAULT,
+				strlen(XATTR_NAME_POSIX_ACL_DEFAULT) + 1,
 				data, size, &context.count);
 		if (error)
 			return error;
diff --git a/include/linux/posix_acl_xattr.h b/include/linux/posix_acl_xattr.h
index ad93ad0f1db0..47d8ee6fed67 100644
--- a/include/linux/posix_acl_xattr.h
+++ b/include/linux/posix_acl_xattr.h
@@ -9,16 +9,12 @@
 #ifndef _POSIX_ACL_XATTR_H
 #define _POSIX_ACL_XATTR_H
 
+#include <uapi/linux/xattr.h>
 #include <linux/posix_acl.h>
 
-/* Extended attribute names */
-#define POSIX_ACL_XATTR_ACCESS	"system.posix_acl_access"
-#define POSIX_ACL_XATTR_DEFAULT	"system.posix_acl_default"
-
 /* Supported ACL a_version fields */
 #define POSIX_ACL_XATTR_VERSION	0x0002
 
-
 /* An undefined entry e_id value */
 #define ACL_UNDEFINED_ID	(-1)
 
