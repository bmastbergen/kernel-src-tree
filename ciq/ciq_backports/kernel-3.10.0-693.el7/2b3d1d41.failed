xfs: set up inode operation vectors later

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 2b3d1d41b4d96c3b074096ae57b27cd191969643
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2b3d1d41.failed

In the next patch we'll set up different inode operations for inline vs
out of line symlinks, for that we need to make sure the flags are already
set up properly.

[dchinner: added xfs_setup_iops() call to xfs_rename_alloc_whiteout()]

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 2b3d1d41b4d96c3b074096ae57b27cd191969643)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_iops.c
diff --cc fs/xfs/xfs_iops.c
index 11c2c9d643e6,f08d91c51b7f..000000000000
--- a/fs/xfs/xfs_iops.c
+++ b/fs/xfs/xfs_iops.c
@@@ -169,16 -168,33 +169,25 @@@ xfs_vn_mknod
  	if (unlikely(error))
  		goto out_cleanup_inode;
  
 -#ifdef CONFIG_XFS_POSIX_ACL
  	if (default_acl) {
 -		error = xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);
 -		if (error)
 -			goto out_cleanup_inode;
 -	}
 -	if (acl) {
 -		error = xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);
 -		if (error)
 +		error = xfs_inherit_acl(inode, default_acl);
 +		default_acl = NULL;
 +		if (unlikely(error))
  			goto out_cleanup_inode;
  	}
 -#endif
  
++<<<<<<< HEAD
++=======
+ 	xfs_setup_iops(ip);
+ 
+ 	if (tmpfile)
+ 		d_tmpfile(dentry, inode);
+ 	else
+ 		d_instantiate(dentry, inode);
++>>>>>>> 2b3d1d41b4d9 (xfs: set up inode operation vectors later)
  
 +	d_instantiate(dentry, inode);
  	xfs_finish_inode_setup(ip);
 -
 - out_free_acl:
 -	if (default_acl)
 -		posix_acl_release(default_acl);
 -	if (acl)
 -		posix_acl_release(acl);
  	return error;
  
   out_cleanup_inode:
@@@ -1225,35 -1236,12 +1236,23 @@@ xfs_setup_inode
  	i_size_write(inode, ip->i_d.di_size);
  	xfs_diflags_to_iflags(inode, ip);
  
- 	ip->d_ops = ip->i_mount->m_nondir_inode_ops;
- 	lockdep_set_class(&ip->i_lock.mr_lock, &xfs_nondir_ilock_class);
- 	switch (inode->i_mode & S_IFMT) {
- 	case S_IFREG:
- 		inode->i_op = &xfs_inode_operations;
- 		inode->i_fop = &xfs_file_operations;
- 		inode->i_mapping->a_ops = &xfs_address_space_operations;
- 		break;
- 	case S_IFDIR:
+ 	if (S_ISDIR(inode->i_mode)) {
  		lockdep_set_class(&ip->i_lock.mr_lock, &xfs_dir_ilock_class);
++<<<<<<< HEAD
 +		if (xfs_sb_version_hasasciici(&XFS_M(inode->i_sb)->m_sb)) {
 +			inode->i_op = &xfs_dir_ci_inode_operations.ops;
 +			inode->i_flags |= S_IOPS_WRAPPER;
 +		} else {
 +			inode->i_op = &xfs_dir_inode_operations.ops;
 +			inode->i_flags |= S_IOPS_WRAPPER;
 +		}
 +		inode->i_fop = &xfs_dir_file_operations;
++=======
++>>>>>>> 2b3d1d41b4d9 (xfs: set up inode operation vectors later)
  		ip->d_ops = ip->i_mount->m_dir_inode_ops;
- 		break;
- 	case S_IFLNK:
- 		inode->i_op = &xfs_symlink_inode_operations;
- 		if (!(ip->i_df.if_flags & XFS_IFINLINE))
- 			inode->i_mapping->a_ops = &xfs_address_space_operations;
- 		break;
- 	default:
- 		inode->i_op = &xfs_inode_operations;
- 		init_special_inode(inode, inode->i_mode, inode->i_rdev);
- 		break;
+ 	} else {
+ 		ip->d_ops = ip->i_mount->m_nondir_inode_ops;
+ 		lockdep_set_class(&ip->i_lock.mr_lock, &xfs_nondir_ilock_class);
  	}
  
  	/*
diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c
index 2a5eecff8de3..94c3120efbfd 100644
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@ -2858,6 +2858,7 @@ xfs_rename_alloc_whiteout(
 	 * and flag it as linkable.
 	 */
 	drop_nlink(VFS_I(tmpfile));
+	xfs_setup_iops(tmpfile);
 	xfs_finish_inode_setup(tmpfile);
 	VFS_I(tmpfile)->i_state |= I_LINKABLE;
 
diff --git a/fs/xfs/xfs_inode.h b/fs/xfs/xfs_inode.h
index 4b3afab97ddb..15a3444fce48 100644
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@ -440,6 +440,9 @@ loff_t	__xfs_seek_hole_data(struct inode *inode, loff_t start,
 			     loff_t eof, int whence);
 
 /* from xfs_iops.c */
+extern void xfs_setup_inode(struct xfs_inode *ip);
+extern void xfs_setup_iops(struct xfs_inode *ip);
+
 /*
  * When setting up a newly allocated inode, we need to call
  * xfs_finish_inode_setup() once the inode is fully instantiated at
@@ -447,7 +450,6 @@ loff_t	__xfs_seek_hole_data(struct inode *inode, loff_t start,
  * before we've completed instantiation. Otherwise we can do it
  * the moment the inode lookup is complete.
  */
-extern void xfs_setup_inode(struct xfs_inode *ip);
 static inline void xfs_finish_inode_setup(struct xfs_inode *ip)
 {
 	xfs_iflags_clear(ip, XFS_INEW);
@@ -458,6 +460,7 @@ static inline void xfs_finish_inode_setup(struct xfs_inode *ip)
 static inline void xfs_setup_existing_inode(struct xfs_inode *ip)
 {
 	xfs_setup_inode(ip);
+	xfs_setup_iops(ip);
 	xfs_finish_inode_setup(ip);
 }
 
* Unmerged path fs/xfs/xfs_iops.c
