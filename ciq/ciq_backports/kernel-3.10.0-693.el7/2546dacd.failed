HID: wacom: split out input allocation and registration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: split out input allocation and registration (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.24%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 2546dacd3e0e48c40bbb99caf01455f1ade9bb24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2546dacd.failed

If the input can be created earlier during probe, we can already populate
them while reading the report descriptor. This way, we can rely on the
hid subsystem directly for tablets which already provide a meaningful
report descriptor (like ISDv4-5).

This patch only splits the allocation and registration, but do not
change where we allocate the input. This will come in a later patch.

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Jason Gerecke <killertofu@gmail.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 2546dacd3e0e48c40bbb99caf01455f1ade9bb24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,62f3c899ab98..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -1127,42 -995,161 +1127,163 @@@ static void wacom_destroy_battery(struc
  	}
  }
  
 -static ssize_t wacom_show_speed(struct device *dev,
 -				struct device_attribute
 -				*attr, char *buf)
 -{
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -
 -	return snprintf(buf, PAGE_SIZE, "%i\n", wacom->wacom_wac.bt_high_speed);
 -}
 -
 -static ssize_t wacom_store_speed(struct device *dev,
 -				struct device_attribute *attr,
 -				const char *buf, size_t count)
 +static int wacom_register_input(struct wacom *wacom)
  {
 -	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 -	u8 new_speed;
 -
 -	if (kstrtou8(buf, 0, &new_speed))
 -		return -EINVAL;
 -
 -	if (new_speed != 0 && new_speed != 1)
 -		return -EINVAL;
 -
 -	wacom_bt_query_tablet_data(hdev, new_speed, &wacom->wacom_wac.features);
 -
 -	return count;
 -}
 +	struct input_dev *input_dev;
++<<<<<<< HEAD
 +	struct usb_interface *intf = wacom->intf;
 +	struct usb_device *dev = interface_to_usbdev(intf);
 +	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
 +	int error;
  
 -static DEVICE_ATTR(speed, DEV_ATTR_RW_PERM,
 -		wacom_show_speed, wacom_store_speed);
 +	input_dev = input_allocate_device();
 +	if (!input_dev) {
 +		error = -ENOMEM;
 +		goto fail1;
 +	}
  
 -static struct input_dev *wacom_allocate_input(struct wacom *wacom)
 -{
 -	struct input_dev *input_dev;
 +	input_dev->name = wacom_wac->name;
 +	input_dev->dev.parent = &intf->dev;
 +	input_dev->open = wacom_open;
 +	input_dev->close = wacom_close;
 +	usb_to_input_id(dev, &input_dev->id);
 +	input_set_drvdata(input_dev, wacom);
++=======
+ 	struct hid_device *hdev = wacom->hdev;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	input_dev = input_allocate_device();
+ 	if (!input_dev)
+ 		return NULL;
+ 
+ 	input_dev->name = wacom_wac->name;
+ 	input_dev->phys = hdev->phys;
+ 	input_dev->dev.parent = &hdev->dev;
+ 	input_dev->open = wacom_open;
+ 	input_dev->close = wacom_close;
+ 	input_dev->uniq = hdev->uniq;
+ 	input_dev->id.bustype = hdev->bus;
+ 	input_dev->id.vendor  = hdev->vendor;
+ 	input_dev->id.product = wacom_wac->pid ? wacom_wac->pid : hdev->product;
+ 	input_dev->id.version = hdev->version;
+ 	input_set_drvdata(input_dev, wacom);
+ 
+ 	return input_dev;
+ }
+ 
+ static void wacom_free_inputs(struct wacom *wacom)
+ {
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	if (wacom_wac->input)
+ 		input_free_device(wacom_wac->input);
+ 	if (wacom_wac->pad_input)
+ 		input_free_device(wacom_wac->pad_input);
+ 	wacom_wac->input = NULL;
+ 	wacom_wac->pad_input = NULL;
+ }
+ 
+ static int wacom_allocate_inputs(struct wacom *wacom)
+ {
+ 	struct input_dev *input_dev, *pad_input_dev;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 
+ 	input_dev = wacom_allocate_input(wacom);
+ 	pad_input_dev = wacom_allocate_input(wacom);
+ 	if (!input_dev || !pad_input_dev) {
+ 		wacom_free_inputs(wacom);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	wacom_wac->input = input_dev;
+ 	wacom_wac->pad_input = pad_input_dev;
+ 	wacom_wac->pad_input->name = wacom_wac->pad_name;
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_clean_inputs(struct wacom *wacom)
+ {
+ 	if (wacom->wacom_wac.input) {
+ 		if (wacom->wacom_wac.input_registered)
+ 			input_unregister_device(wacom->wacom_wac.input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.input);
+ 	}
+ 	if (wacom->wacom_wac.pad_input) {
+ 		if (wacom->wacom_wac.input_registered)
+ 			input_unregister_device(wacom->wacom_wac.pad_input);
+ 		else
+ 			input_free_device(wacom->wacom_wac.pad_input);
+ 	}
+ 	wacom->wacom_wac.input = NULL;
+ 	wacom->wacom_wac.pad_input = NULL;
+ 	wacom_destroy_leds(wacom);
+ }
+ 
+ static int wacom_register_inputs(struct wacom *wacom)
+ {
+ 	struct input_dev *input_dev, *pad_input_dev;
+ 	struct wacom_wac *wacom_wac = &(wacom->wacom_wac);
+ 	int error;
+ 
+ 	input_dev = wacom_wac->input;
+ 	pad_input_dev = wacom_wac->pad_input;
+ 
+ 	if (!input_dev || !pad_input_dev)
+ 		return -EINVAL;
++>>>>>>> 2546dacd3e0e (HID: wacom: split out input allocation and registration)
  
 +	wacom_wac->input = input_dev;
  	error = wacom_setup_input_capabilities(input_dev, wacom_wac);
  	if (error)
++<<<<<<< HEAD
 +		goto fail1;
 +
 +	error = input_register_device(input_dev);
 +	if (error)
 +		goto fail2;
++=======
+ 		return error;
+ 
+ 	error = input_register_device(input_dev);
+ 	if (error)
+ 		return error;
+ 
+ 	error = wacom_setup_pad_input_capabilities(pad_input_dev, wacom_wac);
+ 	if (error) {
+ 		/* no pad in use on this interface */
+ 		input_free_device(pad_input_dev);
+ 		wacom_wac->pad_input = NULL;
+ 		pad_input_dev = NULL;
+ 	} else {
+ 		error = input_register_device(pad_input_dev);
+ 		if (error)
+ 			goto fail_register_pad_input;
+ 
+ 		error = wacom_initialize_leds(wacom);
+ 		if (error)
+ 			goto fail_leds;
+ 	}
++>>>>>>> 2546dacd3e0e (HID: wacom: split out input allocation and registration)
+ 
+ 	wacom_wac->input_registered = true;
  
  	return 0;
  
++<<<<<<< HEAD
 +fail2:
 +	input_free_device(input_dev);
 +	wacom_wac->input = NULL;
 +fail1:
++=======
+ fail_leds:
+ 	input_unregister_device(pad_input_dev);
+ 	pad_input_dev = NULL;
+ fail_register_pad_input:
+ 	input_unregister_device(input_dev);
+ 	wacom_wac->input = NULL;
++>>>>>>> 2546dacd3e0e (HID: wacom: split out input allocation and registration)
  	return error;
  }
  
@@@ -1183,31 -1171,29 +1304,39 @@@ static void wacom_wireless_work(struct 
  	wacom_destroy_battery(wacom);
  
  	/* Stylus interface */
 -	hdev1 = usb_get_intfdata(usbdev->config->interface[1]);
 -	wacom1 = hid_get_drvdata(hdev1);
 +	wacom1 = usb_get_intfdata(usbdev->config->interface[1]);
  	wacom_wac1 = &(wacom1->wacom_wac);
++<<<<<<< HEAD
 +	if (wacom_wac1->input)
 +		input_unregister_device(wacom_wac1->input);
 +	wacom_wac1->input = NULL;
++=======
+ 	wacom_clean_inputs(wacom1);
++>>>>>>> 2546dacd3e0e (HID: wacom: split out input allocation and registration)
  
  	/* Touch interface */
 -	hdev2 = usb_get_intfdata(usbdev->config->interface[2]);
 -	wacom2 = hid_get_drvdata(hdev2);
 +	wacom2 = usb_get_intfdata(usbdev->config->interface[2]);
  	wacom_wac2 = &(wacom2->wacom_wac);
++<<<<<<< HEAD
 +	if (wacom_wac2->input)
 +		input_unregister_device(wacom_wac2->input);
 +	wacom_wac2->input = NULL;
++=======
+ 	wacom_clean_inputs(wacom2);
++>>>>>>> 2546dacd3e0e (HID: wacom: split out input allocation and registration)
  
  	if (wacom_wac->pid == 0) {
 -		hid_info(wacom->hdev, "wireless tablet disconnected\n");
 -		wacom_wac1->shared->type = 0;
 +		dev_info(&wacom->intf->dev, "wireless tablet disconnected\n");
  	} else {
 -		const struct hid_device_id *id = wacom_ids;
 +		const struct usb_device_id *id = wacom_ids;
  
 -		hid_info(wacom->hdev, "wireless tablet connected with PID %x\n",
 +		dev_info(&wacom->intf->dev,
 +			 "wireless tablet connected with PID %x\n",
  			 wacom_wac->pid);
  
 -		while (id->bus) {
 -			if (id->vendor == USB_VENDOR_ID_WACOM &&
 -			    id->product == wacom_wac->pid)
 +		while (id->match_flags) {
 +			if (id->idVendor == USB_VENDOR_ID_WACOM &&
 +			    id->idProduct == wacom_wac->pid)
  				break;
  			id++;
  		}
@@@ -1224,7 -1209,13 +1353,17 @@@
  		wacom_wac1->features.device_type = BTN_TOOL_PEN;
  		snprintf(wacom_wac1->name, WACOM_NAME_MAX, "%s (WL) Pen",
  			 wacom_wac1->features.name);
++<<<<<<< HEAD
 +		error = wacom_register_input(wacom1);
++=======
+ 		snprintf(wacom_wac1->pad_name, WACOM_NAME_MAX, "%s (WL) Pad",
+ 			 wacom_wac1->features.name);
+ 		wacom_wac1->shared->touch_max = wacom_wac1->features.touch_max;
+ 		wacom_wac1->shared->type = wacom_wac1->features.type;
+ 		wacom_wac1->pid = wacom_wac->pid;
+ 		error = wacom_allocate_inputs(wacom1) ||
+ 			wacom_register_inputs(wacom1);
++>>>>>>> 2546dacd3e0e (HID: wacom: split out input allocation and registration)
  		if (error)
  			goto fail;
  
@@@ -1241,9 -1233,17 +1380,17 @@@
  			else
  				snprintf(wacom_wac2->name, WACOM_NAME_MAX,
  					 "%s (WL) Pad",wacom_wac2->features.name);
++<<<<<<< HEAD
 +			error = wacom_register_input(wacom2);
++=======
+ 			snprintf(wacom_wac2->pad_name, WACOM_NAME_MAX,
+ 				 "%s (WL) Pad", wacom_wac2->features.name);
+ 			wacom_wac2->pid = wacom_wac->pid;
+ 			error = wacom_allocate_inputs(wacom2) ||
+ 				wacom_register_inputs(wacom2);
++>>>>>>> 2546dacd3e0e (HID: wacom: split out input allocation and registration)
  			if (error)
  				goto fail;
 -
 -			if (wacom_wac1->features.type == INTUOSHT &&
 -			    wacom_wac1->features.touch_max)
 -				wacom_wac->shared->touch_input = wacom_wac2->input;
  		}
  
  		error = wacom_initialize_battery(wacom);
@@@ -1254,15 -1254,8 +1401,20 @@@
  	return;
  
  fail:
++<<<<<<< HEAD
 +	if (wacom_wac2->input) {
 +		input_unregister_device(wacom_wac2->input);
 +		wacom_wac2->input = NULL;
 +	}
 +
 +	if (wacom_wac1->input) {
 +		input_unregister_device(wacom_wac1->input);
 +		wacom_wac1->input = NULL;
 +	}
++=======
+ 	wacom_clean_inputs(wacom1);
+ 	wacom_clean_inputs(wacom2);
++>>>>>>> 2546dacd3e0e (HID: wacom: split out input allocation and registration)
  	return;
  }
  
@@@ -1386,29 -1416,31 +1538,34 @@@ static int wacom_probe(struct usb_inter
  		else
  			strlcat(wacom_wac->name, " Pad", WACOM_NAME_MAX);
  
 -		error = wacom_add_shared_data(hdev);
 +		other_dev = wacom_get_sibling(dev, features->oVid, features->oPid);
 +		if (other_dev == NULL || wacom_get_usbdev_data(other_dev) == NULL)
 +			other_dev = dev;
 +		error = wacom_add_shared_data(wacom_wac, other_dev);
  		if (error)
 -			goto fail_shared_data;
 +			goto fail3;
  	}
  
 -	if (!(features->quirks & WACOM_QUIRK_MONITOR) &&
 -	     (features->quirks & WACOM_QUIRK_BATTERY)) {
 -		error = wacom_initialize_battery(wacom);
 -		if (error)
 -			goto fail_battery;
 -	}
 +	usb_fill_int_urb(wacom->irq, dev,
 +			 usb_rcvintpipe(dev, endpoint->bEndpointAddress),
 +			 wacom_wac->data, features->pktlen,
 +			 wacom_sys_irq, wacom, endpoint->bInterval);
 +	wacom->irq->transfer_dma = wacom->data_dma;
 +	wacom->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 +
 +	error = wacom_initialize_leds(wacom);
 +	if (error)
 +		goto fail4;
  
  	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
++<<<<<<< HEAD
 +		error = wacom_register_input(wacom);
++=======
+ 		error = wacom_allocate_inputs(wacom) ||
+ 			wacom_register_inputs(wacom);
++>>>>>>> 2546dacd3e0e (HID: wacom: split out input allocation and registration)
  		if (error)
 -			goto fail_register_inputs;
 -	}
 -
 -	if (hdev->bus == BUS_BLUETOOTH) {
 -		error = device_create_file(&hdev->dev, &dev_attr_speed);
 -		if (error)
 -			hid_warn(hdev,
 -				 "can't create sysfs speed attribute err: %d\n",
 -				 error);
 +			goto fail5;
  	}
  
  	/* Note that if query fails it is not a hard failure */
@@@ -1425,30 -1463,38 +1582,54 @@@
  
  	return 0;
  
++<<<<<<< HEAD
 + fail5: wacom_destroy_leds(wacom);
 + fail4:	wacom_remove_shared_data(wacom_wac);
 + fail3:	usb_free_urb(wacom->irq);
 + fail2:	usb_free_coherent(dev, WACOM_PKGLEN_MAX, wacom_wac->data, wacom->data_dma);
 + fail1:	kfree(wacom);
++=======
+ fail_hw_start:
+ 	wacom_clean_inputs(wacom);
+ 	if (hdev->bus == BUS_BLUETOOTH)
+ 		device_remove_file(&hdev->dev, &dev_attr_speed);
+ fail_register_inputs:
+ 	wacom_clean_inputs(wacom);
+ 	wacom_destroy_battery(wacom);
+ fail_battery:
+ 	wacom_remove_shared_data(wacom_wac);
+ fail_shared_data:
+ fail_type:
+ fail_pktlen:
+ fail_parse:
+ 	kfree(wacom);
+ 	hid_set_drvdata(hdev, NULL);
++>>>>>>> 2546dacd3e0e (HID: wacom: split out input allocation and registration)
  	return error;
  }
  
 -static void wacom_remove(struct hid_device *hdev)
 +static void wacom_disconnect(struct usb_interface *intf)
  {
 -	struct wacom *wacom = hid_get_drvdata(hdev);
 +	struct wacom *wacom = usb_get_intfdata(intf);
  
 -	hid_hw_stop(hdev);
 +	usb_set_intfdata(intf, NULL);
  
 +	usb_kill_urb(wacom->irq);
  	cancel_work_sync(&wacom->work);
++<<<<<<< HEAD
 +	if (wacom->wacom_wac.input)
 +		input_unregister_device(wacom->wacom_wac.input);
++=======
+ 	wacom_clean_inputs(wacom);
+ 	if (hdev->bus == BUS_BLUETOOTH)
+ 		device_remove_file(&hdev->dev, &dev_attr_speed);
++>>>>>>> 2546dacd3e0e (HID: wacom: split out input allocation and registration)
  	wacom_destroy_battery(wacom);
 +	wacom_destroy_leds(wacom);
 +	usb_free_urb(wacom->irq);
 +	usb_free_coherent(interface_to_usbdev(intf), WACOM_PKGLEN_MAX,
 +			wacom->wacom_wac.data, wacom->data_dma);
  	wacom_remove_shared_data(&wacom->wacom_wac);
 -
 -	hid_set_drvdata(hdev, NULL);
  	kfree(wacom);
  }
  
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,72f9ca8e5cd4..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -146,6 -166,8 +146,11 @@@ struct wacom_wac 
  	struct wacom_features features;
  	struct wacom_shared *shared;
  	struct input_dev *input;
++<<<<<<< HEAD
++=======
+ 	struct input_dev *pad_input;
+ 	bool input_registered;
++>>>>>>> 2546dacd3e0e (HID: wacom: split out input allocation and registration)
  	int pid;
  	int battery_capacity;
  	int num_contacts_left;
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.h
