sysfs, kernfs: introduce kernfs_create_dir[_ns]()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tejun Heo <tj@kernel.org>
commit 93b2b8e4aa4317e3fe6414d117deb5f3c362e8bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/93b2b8e4.failed

Introduce kernfs interface to manipulate a directory which takes and
returns sysfs_dirents.

create_dir() is renamed to kernfs_create_dir_ns() and its argumantes
and return value are updated.  create_dir() usages are replaced with
kernfs_create_dir_ns() and sysfs_create_subdir() usages are replaced
with kernfs_create_dir().  Dup warnings are handled explicitly by
sysfs users of the kernfs interface.

sysfs_enable_ns() is renamed to kernfs_enable_ns().

This patch doesn't introduce any behavior changes.

v2: Dummy implementation for !CONFIG_SYSFS updated to return -ENOSYS.

v3: kernfs_enable_ns() added.

v4: Refreshed on top of "sysfs: drop kobj_ns_type handling, take #2"
    so that this patch removes sysfs_enable_ns().

	Signed-off-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 93b2b8e4aa4317e3fe6414d117deb5f3c362e8bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/sysfs/dir.c
#	fs/sysfs/sysfs.h
#	include/linux/kernfs.h
#	lib/kobject.c
diff --cc fs/sysfs/dir.c
index 3f68344137e5,cfbf4091fe5c..000000000000
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@@ -669,13 -664,22 +669,28 @@@ struct sysfs_dirent *sysfs_get_dirent(s
  
  	return sd;
  }
 -EXPORT_SYMBOL_GPL(sysfs_get_dirent_ns);
 +EXPORT_SYMBOL_GPL(sysfs_get_dirent);
  
++<<<<<<< HEAD
 +static int create_dir(struct kobject *kobj, struct sysfs_dirent *parent_sd,
 +	enum kobj_ns_type type, const void *ns, const char *name,
 +	struct sysfs_dirent **p_sd)
++=======
+ /**
+  * kernfs_create_dir_ns - create a directory
+  * @parent: parent in which to create a new directory
+  * @name: name of the new directory
+  * @priv: opaque data associated with the new directory
+  * @ns: optional namespace tag of the directory
+  *
+  * Returns the created node on success, ERR_PTR() value on failure.
+  */
+ struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
+ 					  const char *name, void *priv,
+ 					  const void *ns)
++>>>>>>> 93b2b8e4aa43 (sysfs, kernfs: introduce kernfs_create_dir[_ns]())
  {
 -	umode_t mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
 +	umode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;
  	struct sysfs_addrm_cxt acxt;
  	struct sysfs_dirent *sd;
  	int rc;
@@@ -683,67 -687,31 +698,81 @@@
  	/* allocate */
  	sd = sysfs_new_dirent(name, mode, SYSFS_DIR);
  	if (!sd)
- 		return -ENOMEM;
+ 		return ERR_PTR(-ENOMEM);
  
 +	sd->s_flags |= (type << SYSFS_NS_TYPE_SHIFT);
  	sd->s_ns = ns;
++<<<<<<< HEAD
 +	sd->s_dir.kobj = kobj;
 +
 +	/* link in */
 +	sysfs_addrm_start(&acxt, parent_sd);
 +	rc = sysfs_add_one(&acxt, sd);
++=======
+ 	sd->priv = priv;
+ 
+ 	/* link in */
+ 	sysfs_addrm_start(&acxt);
+ 	rc = __sysfs_add_one(&acxt, sd, parent);
++>>>>>>> 93b2b8e4aa43 (sysfs, kernfs: introduce kernfs_create_dir[_ns]())
  	sysfs_addrm_finish(&acxt);
  
- 	if (rc == 0)
- 		*p_sd = sd;
- 	else
- 		sysfs_put(sd);
+ 	if (!rc)
+ 		return sd;
  
++<<<<<<< HEAD
 +	return rc;
 +}
 +
 +int sysfs_create_subdir(struct kobject *kobj, const char *name,
 +			struct sysfs_dirent **p_sd)
 +{
 +	return create_dir(kobj, kobj->sd,
 +			  KOBJ_NS_TYPE_NONE, NULL, name, p_sd);
++=======
+ 	sysfs_put(sd);
+ 	return ERR_PTR(rc);
++>>>>>>> 93b2b8e4aa43 (sysfs, kernfs: introduce kernfs_create_dir[_ns]())
  }
  
  /**
 - * sysfs_create_dir_ns - create a directory for an object with a namespace tag
 - * @kobj: object we're creating directory for
 - * @ns: the namespace tag to use
 + *	sysfs_read_ns_type: return associated ns_type
 + *	@kobj: the kobject being queried
 + *
 + *	Each kobject can be tagged with exactly one namespace type
 + *	(i.e. network or user).  Return the ns_type associated with
 + *	this object if any
 + */
 +static enum kobj_ns_type sysfs_read_ns_type(struct kobject *kobj)
 +{
 +	const struct kobj_ns_type_operations *ops;
 +	enum kobj_ns_type type;
 +
 +	ops = kobj_child_ns_ops(kobj);
 +	if (!ops)
 +		return KOBJ_NS_TYPE_NONE;
 +
 +	type = ops->type;
 +	BUG_ON(type <= KOBJ_NS_TYPE_NONE);
 +	BUG_ON(type >= KOBJ_NS_TYPES);
 +	BUG_ON(!kobj_ns_type_registered(type));
 +
 +	return type;
 +}
 +
 +/**
 + *	sysfs_create_dir - create a directory for an object.
 + *	@kobj:		object we're creating directory for. 
   */
 -int sysfs_create_dir_ns(struct kobject *kobj, const void *ns)
 +int sysfs_create_dir(struct kobject * kobj)
  {
 +	enum kobj_ns_type type;
  	struct sysfs_dirent *parent_sd, *sd;
++<<<<<<< HEAD
 +	const void *ns = NULL;
 +	int error = 0;
++=======
++>>>>>>> 93b2b8e4aa43 (sysfs, kernfs: introduce kernfs_create_dir[_ns]())
  
  	BUG_ON(!kobj);
  
@@@ -755,18 -723,19 +784,30 @@@
  	if (!parent_sd)
  		return -ENOENT;
  
++<<<<<<< HEAD
 +	if (sysfs_ns_type(parent_sd))
 +		ns = kobj->ktype->namespace(kobj);
 +	type = sysfs_read_ns_type(kobj);
 +
 +	error = create_dir(kobj, parent_sd, type, ns, kobject_name(kobj), &sd);
 +	if (!error)
 +		kobj->sd = sd;
 +	return error;
++=======
+ 	sd = kernfs_create_dir_ns(parent_sd, kobject_name(kobj), kobj, ns);
+ 	if (IS_ERR(sd)) {
+ 		if (PTR_ERR(sd) == -EEXIST)
+ 			sysfs_warn_dup(parent_sd, kobject_name(kobj));
+ 		return PTR_ERR(sd);
+ 	}
+ 
+ 	kobj->sd = sd;
+ 	return 0;
++>>>>>>> 93b2b8e4aa43 (sysfs, kernfs: introduce kernfs_create_dir[_ns]())
  }
  
 -static struct dentry *sysfs_lookup(struct inode *dir, struct dentry *dentry,
 -				   unsigned int flags)
 +static struct dentry * sysfs_lookup(struct inode *dir, struct dentry *dentry,
 +				unsigned int flags)
  {
  	struct dentry *ret = NULL;
  	struct dentry *parent = dentry->d_parent;
@@@ -935,7 -1007,22 +976,26 @@@ int sysfs_move_dir(struct kobject *kobj
  	new_parent_sd = new_parent_kobj && new_parent_kobj->sd ?
  		new_parent_kobj->sd : &sysfs_root;
  
++<<<<<<< HEAD
 +	return sysfs_rename(sd, new_parent_sd, new_ns, sd->s_name);
++=======
+ 	return kernfs_rename_ns(sd, new_parent_sd, sd->s_name, new_ns);
+ }
+ 
+ /**
+  * kernfs_enable_ns - enable namespace under a directory
+  * @sd: directory of interest, should be empty
+  *
+  * This is to be called right after @sd is created to enable namespace
+  * under it.  All children of @sd must have non-NULL namespace tags and
+  * only the ones which match the super_block's tag will be visible.
+  */
+ void kernfs_enable_ns(struct sysfs_dirent *sd)
+ {
+ 	WARN_ON_ONCE(sysfs_type(sd) != SYSFS_DIR);
+ 	WARN_ON_ONCE(!RB_EMPTY_ROOT(&sd->s_dir.children));
+ 	sd->s_flags |= SYSFS_FLAG_NS;
++>>>>>>> 93b2b8e4aa43 (sysfs, kernfs: introduce kernfs_create_dir[_ns]())
  }
  
  /* Relationship between s_mode and the DT_xxx types */
diff --cc fs/sysfs/sysfs.h
index d1e4043eb0c3,9ac234ef4943..000000000000
--- a/fs/sysfs/sysfs.h
+++ b/fs/sysfs/sysfs.h
@@@ -182,13 -179,6 +182,16 @@@ struct sysfs_dirent *sysfs_new_dirent(c
  
  void release_sysfs_dirent(struct sysfs_dirent *sd);
  
++<<<<<<< HEAD
 +int sysfs_create_subdir(struct kobject *kobj, const char *name,
 +			struct sysfs_dirent **p_sd);
 +void sysfs_remove_subdir(struct sysfs_dirent *sd);
 +
 +int sysfs_rename(struct sysfs_dirent *sd,
 +	struct sysfs_dirent *new_parent_sd, const void *ns, const char *new_name);
 +
++=======
++>>>>>>> 93b2b8e4aa43 (sysfs, kernfs: introduce kernfs_create_dir[_ns]())
  static inline struct sysfs_dirent *__sysfs_get(struct sysfs_dirent *sd)
  {
  	if (sd) {
diff --cc include/linux/kernfs.h
index 254b9e872b09,e8b73d4a08d2..000000000000
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@@ -7,6 -7,71 +7,68 @@@
  #ifndef __LINUX_KERNFS_H
  #define __LINUX_KERNFS_H
  
 -#include <linux/kernel.h>
 -#include <linux/err.h>
 -
 -struct file;
 -struct iattr;
 -
  struct sysfs_dirent;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_SYSFS
+ 
+ struct sysfs_dirent *kernfs_create_dir_ns(struct sysfs_dirent *parent,
+ 					  const char *name, void *priv,
+ 					  const void *ns);
+ struct sysfs_dirent *kernfs_create_link(struct sysfs_dirent *parent,
+ 					const char *name,
+ 					struct sysfs_dirent *target);
+ void kernfs_remove(struct sysfs_dirent *sd);
+ int kernfs_remove_by_name_ns(struct sysfs_dirent *parent, const char *name,
+ 			     const void *ns);
+ int kernfs_rename_ns(struct sysfs_dirent *sd, struct sysfs_dirent *new_parent,
+ 		     const char *new_name, const void *new_ns);
+ void kernfs_enable_ns(struct sysfs_dirent *sd);
+ int kernfs_setattr(struct sysfs_dirent *sd, const struct iattr *iattr);
+ 
+ #else	/* CONFIG_SYSFS */
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_dir_ns(struct sysfs_dirent *parent, const char *name, void *priv,
+ 		     const void *ns)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_link(struct sysfs_dirent *parent, const char *name,
+ 		   struct sysfs_dirent *target)
+ { return ERR_PTR(-ENOSYS); }
+ 
+ static inline void kernfs_remove(struct sysfs_dirent *sd) { }
+ 
+ static inline int kernfs_remove_by_name_ns(struct sysfs_dirent *parent,
+ 					   const char *name, const void *ns)
+ { return -ENOSYS; }
+ 
+ static inline int kernfs_rename_ns(struct sysfs_dirent *sd,
+ 				   struct sysfs_dirent *new_parent,
+ 				   const char *new_name, const void *new_ns)
+ { return -ENOSYS; }
+ 
+ static inline void kernfs_enable_ns(struct sysfs_dirent *sd) { }
+ 
+ static inline int kernfs_setattr(struct sysfs_dirent *sd,
+ 				 const struct iattr *iattr)
+ { return -ENOSYS; }
+ 
+ #endif	/* CONFIG_SYSFS */
+ 
+ static inline struct sysfs_dirent *
+ kernfs_create_dir(struct sysfs_dirent *parent, const char *name, void *priv)
+ {
+ 	return kernfs_create_dir_ns(parent, name, priv, NULL);
+ }
+ 
+ static inline int kernfs_remove_by_name(struct sysfs_dirent *parent,
+ 					const char *name)
+ {
+ 	return kernfs_remove_by_name_ns(parent, name, NULL);
+ }
+ 
++>>>>>>> 93b2b8e4aa43 (sysfs, kernfs: introduce kernfs_create_dir[_ns]())
  #endif	/* __LINUX_KERNFS_H */
diff --cc lib/kobject.c
index 5bb69b9fd9a8,b8d848fb1377..000000000000
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@@ -60,7 -84,20 +60,24 @@@ static int create_dir(struct kobject *k
  	 */
  	sysfs_get(kobj->sd);
  
++<<<<<<< HEAD
 +	return error;
++=======
+ 	/*
+ 	 * If @kobj has ns_ops, its children need to be filtered based on
+ 	 * their namespace tags.  Enable namespace support on @kobj->sd.
+ 	 */
+ 	ops = kobj_child_ns_ops(kobj);
+ 	if (ops) {
+ 		BUG_ON(ops->type <= KOBJ_NS_TYPE_NONE);
+ 		BUG_ON(ops->type >= KOBJ_NS_TYPES);
+ 		BUG_ON(!kobj_ns_type_registered(ops->type));
+ 
+ 		kernfs_enable_ns(kobj->sd);
+ 	}
+ 
+ 	return 0;
++>>>>>>> 93b2b8e4aa43 (sysfs, kernfs: introduce kernfs_create_dir[_ns]())
  }
  
  static int get_kobj_path_length(struct kobject *kobj)
* Unmerged path fs/sysfs/dir.c
diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 1a6e16c0db91..49998ba143d8 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -101,9 +101,12 @@ static int internal_create_group(struct kobject *kobj, int update,
 		return -EINVAL;
 	}
 	if (grp->name) {
-		error = sysfs_create_subdir(kobj, grp->name, &sd);
-		if (error)
-			return error;
+		sd = kernfs_create_dir(kobj->sd, grp->name, kobj);
+		if (IS_ERR(sd)) {
+			if (PTR_ERR(sd) == -EEXIST)
+				sysfs_warn_dup(kobj->sd, grp->name);
+			return PTR_ERR(sd);
+		}
 	} else
 		sd = kobj->sd;
 	sysfs_get(sd);
* Unmerged path fs/sysfs/sysfs.h
* Unmerged path include/linux/kernfs.h
* Unmerged path lib/kobject.c
