mnt: In detach_mounts detach the appropriate unmounted mount

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit fe78fcc85a2046c51f1535710996860557eeec20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fe78fcc8.failed

The handling of in detach_mounts of unmounted but connected mounts is
buggy and can lead to an infinite loop.

Correct the handling of unmounted mounts in detach_mount.  When the
mountpoint of an unmounted but connected mount is connected to a
dentry, and that dentry is deleted we need to disconnect that mount
from the parent mount and the deleted dentry.

Nothing changes for the unmounted and connected children.  They can be
safely ignored.

	Cc: stable@vger.kernel.org
Fixes: ce07d891a0891d3c0d0c2d73d577490486b809e1 mnt: Honor MNT_LOCKED when detaching mounts
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit fe78fcc85a2046c51f1535710996860557eeec20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index 91fbddebae10,2b8aa15fd6df..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -1335,6 -1541,41 +1335,44 @@@ static int do_umount(struct mount *mnt
  	return retval;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * __detach_mounts - lazily unmount all mounts on the specified dentry
+  *
+  * During unlink, rmdir, and d_drop it is possible to loose the path
+  * to an existing mountpoint, and wind up leaking the mount.
+  * detach_mounts allows lazily unmounting those mounts instead of
+  * leaking them.
+  *
+  * The caller may hold dentry->d_inode->i_mutex.
+  */
+ void __detach_mounts(struct dentry *dentry)
+ {
+ 	struct mountpoint *mp;
+ 	struct mount *mnt;
+ 
+ 	namespace_lock();
+ 	mp = lookup_mountpoint(dentry);
+ 	if (IS_ERR_OR_NULL(mp))
+ 		goto out_unlock;
+ 
+ 	lock_mount_hash();
+ 	while (!hlist_empty(&mp->m_list)) {
+ 		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
+ 		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
+ 			hlist_add_head(&mnt->mnt_umount.s_list, &unmounted);
+ 			umount_mnt(mnt);
+ 		}
+ 		else umount_tree(mnt, UMOUNT_CONNECTED);
+ 	}
+ 	unlock_mount_hash();
+ 	put_mountpoint(mp);
+ out_unlock:
+ 	namespace_unlock();
+ }
+ 
++>>>>>>> fe78fcc85a20 (mnt: In detach_mounts detach the appropriate unmounted mount)
  /* 
   * Is the caller allowed to modify his namespace?
   */
* Unmerged path fs/namespace.c
