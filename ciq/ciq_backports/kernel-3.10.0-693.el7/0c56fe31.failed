mnt: Don't propagate unmounts to locked mounts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] mnt: Don't propagate unmounts to locked mounts ("Eric W. Biederman") [1247935]
Rebuild_FUZZ: 98.92%
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 0c56fe31420ca599c90240315f7959bf1b4eb6ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0c56fe31.failed

If the first mount in shared subtree is locked don't unmount the
shared subtree.

This is ensured by walking through the mounts parents before children
and marking a mount as unmountable if it is not locked or it is locked
but it's parent is marked.

This allows recursive mount detach to propagate through a set of
mounts when unmounting them would not reveal what is under any locked
mount.

	Cc: stable@vger.kernel.org
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 0c56fe31420ca599c90240315f7959bf1b4eb6ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/pnode.c
diff --cc fs/pnode.c
index 4cba0cce1f85,6367e1e435c6..000000000000
--- a/fs/pnode.c
+++ b/fs/pnode.c
@@@ -370,6 -362,46 +370,49 @@@ int propagate_mount_busy(struct mount *
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Clear MNT_LOCKED when it can be shown to be safe.
+  *
+  * mount_lock lock must be held for write
+  */
+ void propagate_mount_unlock(struct mount *mnt)
+ {
+ 	struct mount *parent = mnt->mnt_parent;
+ 	struct mount *m, *child;
+ 
+ 	BUG_ON(parent == mnt);
+ 
+ 	for (m = propagation_next(parent, parent); m;
+ 			m = propagation_next(m, parent)) {
+ 		child = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);
+ 		if (child)
+ 			child->mnt.mnt_flags &= ~MNT_LOCKED;
+ 	}
+ }
+ 
+ /*
+  * Mark all mounts that the MNT_LOCKED logic will allow to be unmounted.
+  */
+ static void mark_umount_candidates(struct mount *mnt)
+ {
+ 	struct mount *parent = mnt->mnt_parent;
+ 	struct mount *m;
+ 
+ 	BUG_ON(parent == mnt);
+ 
+ 	for (m = propagation_next(parent, parent); m;
+ 			m = propagation_next(m, parent)) {
+ 		struct mount *child = __lookup_mnt_last(&m->mnt,
+ 						mnt->mnt_mountpoint);
+ 		if (child && (!IS_MNT_LOCKED(child) || IS_MNT_MARKED(m))) {
+ 			SET_MNT_MARK(child);
+ 		}
+ 	}
+ }
+ 
+ /*
++>>>>>>> 0c56fe31420c (mnt: Don't propagate unmounts to locked mounts)
   * NOTE: unmounting 'mnt' naturally propagates to all other mounts its
   * parent propagates to.
   */
@@@ -386,11 -418,17 +429,22 @@@ static void __propagate_umount(struct m
  		struct mount *child = __lookup_mnt_last(&m->mnt,
  						mnt->mnt_mountpoint);
  		/*
- 		 * umount the child only if the child has no
- 		 * other children
+ 		 * umount the child only if the child has no children
+ 		 * and the child is marked safe to unmount.
  		 */
++<<<<<<< HEAD
 +		if (child && list_empty(&child->mnt_mounts))
 +			list_move_tail(&child->mnt_hash, &mnt->mnt_hash);
++=======
+ 		if (!child || !IS_MNT_MARKED(child))
+ 			continue;
+ 		CLEAR_MNT_MARK(child);
+ 		if (list_empty(&child->mnt_mounts)) {
+ 			list_del_init(&child->mnt_child);
+ 			child->mnt.mnt_flags |= MNT_UMOUNT;
+ 			list_move_tail(&child->mnt_list, &mnt->mnt_list);
+ 		}
++>>>>>>> 0c56fe31420c (mnt: Don't propagate unmounts to locked mounts)
  	}
  }
  
@@@ -405,7 -443,10 +459,14 @@@ int propagate_umount(struct list_head *
  {
  	struct mount *mnt;
  
++<<<<<<< HEAD
 +	list_for_each_entry(mnt, list, mnt_hash)
++=======
+ 	list_for_each_entry_reverse(mnt, list, mnt_list)
+ 		mark_umount_candidates(mnt);
+ 
+ 	list_for_each_entry(mnt, list, mnt_list)
++>>>>>>> 0c56fe31420c (mnt: Don't propagate unmounts to locked mounts)
  		__propagate_umount(mnt);
  	return 0;
  }
* Unmerged path fs/pnode.c
diff --git a/fs/pnode.h b/fs/pnode.h
index 65e04f65fa1a..7a3b134294ff 100644
--- a/fs/pnode.h
+++ b/fs/pnode.h
@@ -19,6 +19,7 @@
 #define IS_MNT_MARKED(m) ((m)->mnt.mnt_flags & MNT_MARKED)
 #define SET_MNT_MARK(m) ((m)->mnt.mnt_flags |= MNT_MARKED)
 #define CLEAR_MNT_MARK(m) ((m)->mnt.mnt_flags &= ~MNT_MARKED)
+#define IS_MNT_LOCKED(m) ((m)->mnt.mnt_flags & MNT_LOCKED)
 
 #define CL_EXPIRE    		0x01
 #define CL_SLAVE     		0x02
