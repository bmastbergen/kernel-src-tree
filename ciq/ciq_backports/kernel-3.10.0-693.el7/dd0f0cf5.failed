random: Fix crashes with sparse node ids

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Michael Ellerman <mpe@ellerman.id.au>
commit dd0f0cf58af70dc9267409f113bea772d57f675c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/dd0f0cf5.failed

On a system with sparse node ids, eg. a powerpc system with 4 nodes
numbered like so:

  node   0: [mem 0x0000000000000000-0x00000007ffffffff]
  node   1: [mem 0x0000000800000000-0x0000000fffffffff]
  node  16: [mem 0x0000001000000000-0x00000017ffffffff]
  node  17: [mem 0x0000001800000000-0x0000001fffffffff]

The code in rand_initialize() will allocate 4 pointers for the pool
array, and initialise them correctly.

However when go to use the pool, in eg. extract_crng(), we use the
numa_node_id() to index into the array. For the higher numbered node ids
this leads to random memory corruption, depending on what was kmalloc'ed
adjacent to the pool array.

Fix it by using nr_node_ids to size the pool array.

Fixes: 1e7f583af67b ("random: make /dev/urandom scalable for silly userspace programs")
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit dd0f0cf58af70dc9267409f113bea772d57f675c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/random.c
diff --cc drivers/char/random.c
index 6d0f2f6f23ab,3efb3bf0ab83..000000000000
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@@ -1287,9 -1655,28 +1288,34 @@@ static void init_std_data(struct entrop
   */
  static int rand_initialize(void)
  {
++<<<<<<< HEAD
 +	init_std_data(&input_pool);
 +	init_std_data(&blocking_pool);
 +	init_std_data(&nonblocking_pool);
++=======
+ #ifdef CONFIG_NUMA
+ 	int i;
+ 	struct crng_state *crng;
+ 	struct crng_state **pool;
+ #endif
+ 
+ 	init_std_data(&input_pool);
+ 	init_std_data(&blocking_pool);
+ 	crng_initialize(&primary_crng);
+ 
+ #ifdef CONFIG_NUMA
+ 	pool = kcalloc(nr_node_ids, sizeof(*pool), GFP_KERNEL|__GFP_NOFAIL);
+ 	for_each_online_node(i) {
+ 		crng = kmalloc_node(sizeof(struct crng_state),
+ 				    GFP_KERNEL | __GFP_NOFAIL, i);
+ 		spin_lock_init(&crng->lock);
+ 		crng_initialize(crng);
+ 		pool[i] = crng;
+ 	}
+ 	mb();
+ 	crng_node_pool = pool;
+ #endif
++>>>>>>> dd0f0cf58af7 (random: Fix crashes with sparse node ids)
  	return 0;
  }
  early_initcall(rand_initialize);
* Unmerged path drivers/char/random.c
