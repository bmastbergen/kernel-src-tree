qed: Fix static checker warning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Rahul Verma <Rahul.Verma@cavium.com>
commit 68203a67a7024c5d0b8e545d3d370b1fec971551
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/68203a67.failed

	Static Checker Warnings:
	drivers/net/ethernet/qlogic/qed/qed_main.c:1510 qed_fill_link_capability()
	error: uninitialized symbol 'tcvr_state'.
	drivers/net/ethernet/qlogic/qed/qed_mcp.c:1951 qed_mcp_trans_speed_mask()
	error: uninitialized symbol 'transceiver_state'.
	drivers/net/ethernet/qlogic/qed/qed_mcp.c:1951 qed_mcp_trans_speed_mask()
	error: uninitialized symbol 'transceiver_type'.

	Symbols tcvr_state, transceiver_state and transceiver_type
	are initialized with respective default state.

Fixes: c56a8be7e7aa ("qed: Add supported link and advertise link to display in ethtool.")
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Rahul Verma <Rahul.Verma@cavium.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 68203a67a7024c5d0b8e545d3d370b1fec971551)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qed/qed_mcp.c
diff --cc drivers/net/ethernet/qlogic/qed/qed_mcp.c
index 8f0a60facfe9,f40f654398a0..000000000000
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@@ -1001,6 -1893,250 +1001,253 @@@ int qed_mcp_get_media_type(struct qed_d
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ int qed_mcp_get_transceiver_data(struct qed_hwfn *p_hwfn,
+ 				 struct qed_ptt *p_ptt,
+ 				 u32 *p_transceiver_state,
+ 				 u32 *p_transceiver_type)
+ {
+ 	u32 transceiver_info;
+ 
+ 	*p_transceiver_type = ETH_TRANSCEIVER_TYPE_NONE;
+ 	*p_transceiver_state = ETH_TRANSCEIVER_STATE_UPDATING;
+ 
+ 	if (IS_VF(p_hwfn->cdev))
+ 		return -EINVAL;
+ 
+ 	if (!qed_mcp_is_init(p_hwfn)) {
+ 		DP_NOTICE(p_hwfn, "MFW is not initialized!\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	transceiver_info = qed_rd(p_hwfn, p_ptt,
+ 				  p_hwfn->mcp_info->port_addr +
+ 				  offsetof(struct public_port,
+ 					   transceiver_data));
+ 
+ 	*p_transceiver_state = (transceiver_info &
+ 				ETH_TRANSCEIVER_STATE_MASK) >>
+ 				ETH_TRANSCEIVER_STATE_OFFSET;
+ 
+ 	if (*p_transceiver_state == ETH_TRANSCEIVER_STATE_PRESENT)
+ 		*p_transceiver_type = (transceiver_info &
+ 				       ETH_TRANSCEIVER_TYPE_MASK) >>
+ 				       ETH_TRANSCEIVER_TYPE_OFFSET;
+ 	else
+ 		*p_transceiver_type = ETH_TRANSCEIVER_TYPE_UNKNOWN;
+ 
+ 	return 0;
+ }
+ static bool qed_is_transceiver_ready(u32 transceiver_state,
+ 				     u32 transceiver_type)
+ {
+ 	if ((transceiver_state & ETH_TRANSCEIVER_STATE_PRESENT) &&
+ 	    ((transceiver_state & ETH_TRANSCEIVER_STATE_UPDATING) == 0x0) &&
+ 	    (transceiver_type != ETH_TRANSCEIVER_TYPE_NONE))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
+ int qed_mcp_trans_speed_mask(struct qed_hwfn *p_hwfn,
+ 			     struct qed_ptt *p_ptt, u32 *p_speed_mask)
+ {
+ 	u32 transceiver_type, transceiver_state;
+ 
+ 	qed_mcp_get_transceiver_data(p_hwfn, p_ptt, &transceiver_state,
+ 				     &transceiver_type);
+ 
+ 	if (qed_is_transceiver_ready(transceiver_state, transceiver_type) ==
+ 				     false)
+ 		return -EINVAL;
+ 
+ 	switch (transceiver_type) {
+ 	case ETH_TRANSCEIVER_TYPE_1G_LX:
+ 	case ETH_TRANSCEIVER_TYPE_1G_SX:
+ 	case ETH_TRANSCEIVER_TYPE_1G_PCC:
+ 	case ETH_TRANSCEIVER_TYPE_1G_ACC:
+ 	case ETH_TRANSCEIVER_TYPE_1000BASET:
+ 		*p_speed_mask = NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_1G;
+ 		break;
+ 	case ETH_TRANSCEIVER_TYPE_10G_SR:
+ 	case ETH_TRANSCEIVER_TYPE_10G_LR:
+ 	case ETH_TRANSCEIVER_TYPE_10G_LRM:
+ 	case ETH_TRANSCEIVER_TYPE_10G_ER:
+ 	case ETH_TRANSCEIVER_TYPE_10G_PCC:
+ 	case ETH_TRANSCEIVER_TYPE_10G_ACC:
+ 	case ETH_TRANSCEIVER_TYPE_4x10G:
+ 		*p_speed_mask = NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_10G;
+ 		break;
+ 	case ETH_TRANSCEIVER_TYPE_40G_LR4:
+ 	case ETH_TRANSCEIVER_TYPE_40G_SR4:
+ 	case ETH_TRANSCEIVER_TYPE_MULTI_RATE_10G_40G_SR:
+ 	case ETH_TRANSCEIVER_TYPE_MULTI_RATE_10G_40G_LR:
+ 		*p_speed_mask = NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_40G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_10G;
+ 		break;
+ 	case ETH_TRANSCEIVER_TYPE_100G_AOC:
+ 	case ETH_TRANSCEIVER_TYPE_100G_SR4:
+ 	case ETH_TRANSCEIVER_TYPE_100G_LR4:
+ 	case ETH_TRANSCEIVER_TYPE_100G_ER4:
+ 	case ETH_TRANSCEIVER_TYPE_100G_ACC:
+ 		*p_speed_mask =
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_BB_100G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_25G;
+ 		break;
+ 	case ETH_TRANSCEIVER_TYPE_25G_SR:
+ 	case ETH_TRANSCEIVER_TYPE_25G_LR:
+ 	case ETH_TRANSCEIVER_TYPE_25G_AOC:
+ 	case ETH_TRANSCEIVER_TYPE_25G_ACC_S:
+ 	case ETH_TRANSCEIVER_TYPE_25G_ACC_M:
+ 	case ETH_TRANSCEIVER_TYPE_25G_ACC_L:
+ 		*p_speed_mask = NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_25G;
+ 		break;
+ 	case ETH_TRANSCEIVER_TYPE_25G_CA_N:
+ 	case ETH_TRANSCEIVER_TYPE_25G_CA_S:
+ 	case ETH_TRANSCEIVER_TYPE_25G_CA_L:
+ 	case ETH_TRANSCEIVER_TYPE_4x25G_CR:
+ 		*p_speed_mask = NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_25G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_10G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_1G;
+ 		break;
+ 	case ETH_TRANSCEIVER_TYPE_40G_CR4:
+ 	case ETH_TRANSCEIVER_TYPE_MULTI_RATE_10G_40G_CR:
+ 		*p_speed_mask = NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_40G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_10G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_1G;
+ 		break;
+ 	case ETH_TRANSCEIVER_TYPE_100G_CR4:
+ 	case ETH_TRANSCEIVER_TYPE_MULTI_RATE_40G_100G_CR:
+ 		*p_speed_mask =
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_BB_100G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_50G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_40G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_25G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_20G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_10G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_1G;
+ 		break;
+ 	case ETH_TRANSCEIVER_TYPE_MULTI_RATE_40G_100G_SR:
+ 	case ETH_TRANSCEIVER_TYPE_MULTI_RATE_40G_100G_LR:
+ 	case ETH_TRANSCEIVER_TYPE_MULTI_RATE_40G_100G_AOC:
+ 		*p_speed_mask =
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_BB_100G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_40G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_25G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_10G;
+ 		break;
+ 	case ETH_TRANSCEIVER_TYPE_XLPPI:
+ 		*p_speed_mask = NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_40G;
+ 		break;
+ 	case ETH_TRANSCEIVER_TYPE_10G_BASET:
+ 		*p_speed_mask = NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_10G |
+ 		    NVM_CFG1_PORT_DRV_SPEED_CAPABILITY_MASK_1G;
+ 		break;
+ 	default:
+ 		DP_INFO(p_hwfn, "Unknown transceiver type 0x%x\n",
+ 			transceiver_type);
+ 		*p_speed_mask = 0xff;
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int qed_mcp_get_board_config(struct qed_hwfn *p_hwfn,
+ 			     struct qed_ptt *p_ptt, u32 *p_board_config)
+ {
+ 	u32 nvm_cfg_addr, nvm_cfg1_offset, port_cfg_addr;
+ 
+ 	if (IS_VF(p_hwfn->cdev))
+ 		return -EINVAL;
+ 
+ 	if (!qed_mcp_is_init(p_hwfn)) {
+ 		DP_NOTICE(p_hwfn, "MFW is not initialized!\n");
+ 		return -EBUSY;
+ 	}
+ 	if (!p_ptt) {
+ 		*p_board_config = NVM_CFG1_PORT_PORT_TYPE_UNDEFINED;
+ 		return -EINVAL;
+ 	}
+ 
+ 	nvm_cfg_addr = qed_rd(p_hwfn, p_ptt, MISC_REG_GEN_PURP_CR0);
+ 	nvm_cfg1_offset = qed_rd(p_hwfn, p_ptt, nvm_cfg_addr + 4);
+ 	port_cfg_addr = MCP_REG_SCRATCH + nvm_cfg1_offset +
+ 			offsetof(struct nvm_cfg1, port[MFW_PORT(p_hwfn)]);
+ 	*p_board_config = qed_rd(p_hwfn, p_ptt,
+ 				 port_cfg_addr +
+ 				 offsetof(struct nvm_cfg1_port,
+ 					  board_cfg));
+ 
+ 	return 0;
+ }
+ 
+ /* Old MFW has a global configuration for all PFs regarding RDMA support */
+ static void
+ qed_mcp_get_shmem_proto_legacy(struct qed_hwfn *p_hwfn,
+ 			       enum qed_pci_personality *p_proto)
+ {
+ 	/* There wasn't ever a legacy MFW that published iwarp.
+ 	 * So at this point, this is either plain l2 or RoCE.
+ 	 */
+ 	if (test_bit(QED_DEV_CAP_ROCE, &p_hwfn->hw_info.device_capabilities))
+ 		*p_proto = QED_PCI_ETH_ROCE;
+ 	else
+ 		*p_proto = QED_PCI_ETH;
+ 
+ 	DP_VERBOSE(p_hwfn, NETIF_MSG_IFUP,
+ 		   "According to Legacy capabilities, L2 personality is %08x\n",
+ 		   (u32) *p_proto);
+ }
+ 
+ static int
+ qed_mcp_get_shmem_proto_mfw(struct qed_hwfn *p_hwfn,
+ 			    struct qed_ptt *p_ptt,
+ 			    enum qed_pci_personality *p_proto)
+ {
+ 	u32 resp = 0, param = 0;
+ 	int rc;
+ 
+ 	rc = qed_mcp_cmd(p_hwfn, p_ptt,
+ 			 DRV_MSG_CODE_GET_PF_RDMA_PROTOCOL, 0, &resp, &param);
+ 	if (rc)
+ 		return rc;
+ 	if (resp != FW_MSG_CODE_OK) {
+ 		DP_VERBOSE(p_hwfn, NETIF_MSG_IFUP,
+ 			   "MFW lacks support for command; Returns %08x\n",
+ 			   resp);
+ 		return -EINVAL;
+ 	}
+ 
+ 	switch (param) {
+ 	case FW_MB_PARAM_GET_PF_RDMA_NONE:
+ 		*p_proto = QED_PCI_ETH;
+ 		break;
+ 	case FW_MB_PARAM_GET_PF_RDMA_ROCE:
+ 		*p_proto = QED_PCI_ETH_ROCE;
+ 		break;
+ 	case FW_MB_PARAM_GET_PF_RDMA_IWARP:
+ 		*p_proto = QED_PCI_ETH_IWARP;
+ 		break;
+ 	case FW_MB_PARAM_GET_PF_RDMA_BOTH:
+ 		*p_proto = QED_PCI_ETH_RDMA;
+ 		break;
+ 	default:
+ 		DP_NOTICE(p_hwfn,
+ 			  "MFW answers GET_PF_RDMA_PROTOCOL but param is %08x\n",
+ 			  param);
+ 		return -EINVAL;
+ 	}
+ 
+ 	DP_VERBOSE(p_hwfn,
+ 		   NETIF_MSG_IFUP,
+ 		   "According to capabilities, L2 personality is %08x [resp %08x param %08x]\n",
+ 		   (u32) *p_proto, resp, param);
+ 	return 0;
+ }
+ 
++>>>>>>> 68203a67a702 (qed: Fix static checker warning)
  static int
  qed_mcp_get_shmem_proto(struct qed_hwfn *p_hwfn,
  			struct public_func *p_info,
* Unmerged path drivers/net/ethernet/qlogic/qed/qed_mcp.c
