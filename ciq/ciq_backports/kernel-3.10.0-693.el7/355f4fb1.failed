kvm: nVMX: VMCLEAR an active shadow VMCS after last use

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jim Mattson <jmattson@google.com>
commit 355f4fb1405ec29d0fac49b4d41fcd78cbd455d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/355f4fb1.failed

After a successful VM-entry with the "VMCS shadowing" VM-execution
control set, the shadow VMCS referenced by the VMCS link pointer field
in the current VMCS becomes active on the logical processor.

A VMCS that is made active on more than one logical processor may become
corrupted. Therefore, before an active VMCS can be migrated to another
logical processor, the first logical processor must execute a VMCLEAR
for the active VMCS. VMCLEAR both ensures that all VMCS data are written
to memory and makes the VMCS inactive.

	Signed-off-by: Jim Mattson <jmattson@google.com>
Reviewed-By: David Matlack <dmatlack@google.com>
Message-Id: <1477668579-22555-1-git-send-email-jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 355f4fb1405ec29d0fac49b4d41fcd78cbd455d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index c5eae125bff4,5382b82462fc..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -6829,8 -7145,15 +6833,20 @@@ static void free_nested(struct vcpu_vm
  	vmx->nested.vmxon = false;
  	free_vpid(vmx->nested.vpid02);
  	nested_release_vmcs12(vmx);
++<<<<<<< HEAD
 +	if (enable_shadow_vmcs)
 +		free_vmcs(vmx->nested.current_shadow_vmcs);
++=======
+ 	if (vmx->nested.msr_bitmap) {
+ 		free_page((unsigned long)vmx->nested.msr_bitmap);
+ 		vmx->nested.msr_bitmap = NULL;
+ 	}
+ 	if (enable_shadow_vmcs) {
+ 		vmcs_clear(vmx->vmcs01.shadow_vmcs);
+ 		free_vmcs(vmx->vmcs01.shadow_vmcs);
+ 		vmx->vmcs01.shadow_vmcs = NULL;
+ 	}
++>>>>>>> 355f4fb1405e (kvm: nVMX: VMCLEAR an active shadow VMCS after last use)
  	kfree(vmx->nested.cached_vmcs12);
  	/* Unpin physical memory we referred to in current vmcs02 */
  	if (vmx->nested.apic_access_page) {
* Unmerged path arch/x86/kvm/vmx.c
