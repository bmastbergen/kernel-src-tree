HID: wacom: implement the finger part of the HID generic handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: implement the finger part of the HID generic handling (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 96.00%
commit-author Benjamin Tissoires <benjamin.tissoires@redhat.com>
commit 5ae6e89f7409cb5d218bb728326eba9c650d9700
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5ae6e89f.failed

	Signed-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Acked-by: Jason Gerecke <killertofu@gmail.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 5ae6e89f7409cb5d218bb728326eba9c650d9700)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
#	drivers/hid/wacom_wac.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,8593047bb726..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -172,92 -89,56 +172,127 @@@ static void wacom_close(struct input_de
  }
  
  /*
 - * Calculate the resolution of the X or Y axis using hidinput_calc_abs_res.
 + * Calculate the resolution of the X or Y axis, given appropriate HID data.
 + * This function is little more than hidinput_calc_abs_res stripped down.
   */
  static int wacom_calc_hid_res(int logical_extents, int physical_extents,
 -			       unsigned unit, int exponent)
 +                              unsigned char unit, unsigned char exponent)
  {
 -	struct hid_field field = {
 -		.logical_maximum = logical_extents,
 -		.physical_maximum = physical_extents,
 -		.unit = unit,
 -		.unit_exponent = exponent,
 -	};
 -
 -	return hidinput_calc_abs_res(&field, ABS_X);
 +	int prev, unit_exponent;
 +
 +	/* Check if the extents are sane */
 +	if (logical_extents <= 0 || physical_extents <= 0)
 +		return 0;
 +
 +	/* Get signed value of nybble-sized twos-compliment exponent */
 +	unit_exponent = exponent;
 +	if (unit_exponent > 7)
 +		unit_exponent -= 16;
 +
 +	/* Convert physical_extents to millimeters */
 +	if (unit == 0x11) {		/* If centimeters */
 +		unit_exponent += 1;
 +	} else if (unit == 0x13) {	/* If inches */
 +		prev = physical_extents;
 +		physical_extents *= 254;
 +		if (physical_extents < prev)
 +			return 0;
 +		unit_exponent -= 1;
 +	} else {
 +		return 0;
 +	}
 +
 +	/* Apply negative unit exponent */
 +	for (; unit_exponent < 0; unit_exponent++) {
 +		prev = logical_extents;
 +		logical_extents *= 10;
 +		if (logical_extents < prev)
 +			return 0;
 +	}
 +	/* Apply positive unit exponent */
 +	for (; unit_exponent > 0; unit_exponent--) {
 +		prev = physical_extents;
 +		physical_extents *= 10;
 +		if (physical_extents < prev)
 +			return 0;
 +	}
 +
 +	/* Calculate resolution */
 +	return logical_extents / physical_extents;
  }
  
 -static void wacom_feature_mapping(struct hid_device *hdev,
 -		struct hid_field *field, struct hid_usage *usage)
 +static int wacom_parse_logical_collection(unsigned char *report,
 +					  struct wacom_features *features)
  {
++<<<<<<< HEAD
 +	int length = 0;
 +
 +	if (features->type == BAMBOO_PT) {
 +
 +		/* Logical collection is only used by 3rd gen Bamboo Touch */
 +		features->pktlen = WACOM_PKGLEN_BBTOUCH3;
 +		features->device_type = BTN_TOOL_FINGER;
 +
 +		features->x_max = features->y_max =
 +			get_unaligned_le16(&report[10]);
 +
 +		length = 11;
 +	}
 +	return length;
 +}
 +
 +static void wacom_retrieve_report_data(struct usb_interface *intf,
 +				       struct wacom_features *features)
 +{
 +	int result = 0;
 +	unsigned char *rep_data;
 +
 +	rep_data = kmalloc(2, GFP_KERNEL);
 +	if (rep_data) {
 +
 +		rep_data[0] = 12;
 +		result = wacom_get_report(intf, WAC_HID_FEATURE_REPORT,
 +					  rep_data[0], rep_data, 2,
 +					  WAC_MSG_RETRIES);
 +
 +		if (result >= 0 && rep_data[1] > 2)
 +			features->touch_max = rep_data[1];
 +
 +		kfree(rep_data);
++=======
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_features *features = &wacom->wacom_wac.features;
+ 	struct hid_data *hid_data = &wacom->wacom_wac.hid_data;
+ 	u8 *data;
+ 	int ret;
+ 
+ 	switch (usage->hid) {
+ 	case HID_DG_CONTACTMAX:
+ 		/* leave touch_max as is if predefined */
+ 		if (!features->touch_max) {
+ 			/* read manually */
+ 			data = kzalloc(2, GFP_KERNEL);
+ 			if (!data)
+ 				break;
+ 			data[0] = field->report->id;
+ 			ret = wacom_get_report(hdev, HID_FEATURE_REPORT,
+ 						data, 2, 0);
+ 			if (ret == 2)
+ 				features->touch_max = data[1];
+ 			kfree(data);
+ 		}
+ 		break;
+ 	case HID_DG_INPUTMODE:
+ 		/* Ignore if value index is out of bounds. */
+ 		if (usage->usage_index >= field->report_count) {
+ 			dev_err(&hdev->dev, "HID_DG_INPUTMODE out of range\n");
+ 			break;
+ 		}
+ 
+ 		hid_data->inputmode = field->report->id;
+ 		hid_data->inputmode_index = usage->usage_index;
+ 		break;
++>>>>>>> 5ae6e89f7409 (HID: wacom: implement the finger part of the HID generic handling)
  	}
  }
  
@@@ -525,13 -252,41 +560,37 @@@ static int wacom_parse_hid(struct usb_i
  		}
  	}
  
 -	/* now check the input usages */
 -	rep_enum = &hdev->report_enum[HID_INPUT_REPORT];
 -	list_for_each_entry(hreport, &rep_enum->report_list, list) {
 -
 -		if (!hreport->maxfield)
 -			continue;
 -
 -		for (i = 0; i < hreport->maxfield; i++)
 -			for (j = 0; j < hreport->field[i]->maxusage; j++)
 -				wacom_usage_mapping(hdev, hreport->field[i],
 -						hreport->field[i]->usage + j);
 -	}
 + out:
 +	result = 0;
 +	kfree(report);
 +	return result;
  }
  
++<<<<<<< HEAD
 +static int wacom_set_device_mode(struct usb_interface *intf, int report_id, int length, int mode)
++=======
+ static int wacom_hid_set_device_mode(struct hid_device *hdev)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct hid_data *hid_data = &wacom->wacom_wac.hid_data;
+ 	struct hid_report *r;
+ 	struct hid_report_enum *re;
+ 
+ 	if (hid_data->inputmode < 0)
+ 		return 0;
+ 
+ 	re = &(hdev->report_enum[HID_FEATURE_REPORT]);
+ 	r = re->report_id_hash[hid_data->inputmode];
+ 	if (r) {
+ 		r->field[0]->value[hid_data->inputmode_index] = 2;
+ 		hid_hw_request(hdev, r, HID_REQ_SET_REPORT);
+ 	}
+ 	return 0;
+ }
+ 
+ static int wacom_set_device_mode(struct hid_device *hdev, int report_id,
+ 		int length, int mode)
++>>>>>>> 5ae6e89f7409 (HID: wacom: implement the finger part of the HID generic handling)
  {
  	unsigned char *rep_data;
  	int error = -ENOMEM, limit = 0;
@@@ -563,8 -371,15 +622,17 @@@
   * from the tablet, it is necessary to switch the tablet out of this
   * mode and into one which sends the full range of tablet data.
   */
 -static int wacom_query_tablet_data(struct hid_device *hdev,
 -		struct wacom_features *features)
 +static int wacom_query_tablet_data(struct usb_interface *intf, struct wacom_features *features)
  {
++<<<<<<< HEAD
++=======
+ 	if (hdev->bus == BUS_BLUETOOTH)
+ 		return wacom_bt_query_tablet_data(hdev, 1, features);
+ 
+ 	if (features->type == HID_GENERIC)
+ 		return wacom_hid_set_device_mode(hdev);
+ 
++>>>>>>> 5ae6e89f7409 (HID: wacom: implement the finger part of the HID generic handling)
  	if (features->device_type == BTN_TOOL_FINGER) {
  		if (features->type > TABLETPC) {
  			/* MT Tablet PC touch */
@@@ -1386,41 -1458,51 +1454,63 @@@ static int wacom_probe(struct usb_inter
  		else
  			strlcat(wacom_wac->name, " Pad", WACOM_NAME_MAX);
  
 -		error = wacom_add_shared_data(hdev);
 +		other_dev = wacom_get_sibling(dev, features->oVid, features->oPid);
 +		if (other_dev == NULL || wacom_get_usbdev_data(other_dev) == NULL)
 +			other_dev = dev;
 +		error = wacom_add_shared_data(wacom_wac, other_dev);
  		if (error)
 -			goto fail_shared_data;
 +			goto fail3;
  	}
  
 -	if (!(features->quirks & WACOM_QUIRK_MONITOR) &&
 -	     (features->quirks & WACOM_QUIRK_BATTERY)) {
 -		error = wacom_initialize_battery(wacom);
 -		if (error)
 -			goto fail_battery;
 -	}
 +	usb_fill_int_urb(wacom->irq, dev,
 +			 usb_rcvintpipe(dev, endpoint->bEndpointAddress),
 +			 wacom_wac->data, features->pktlen,
 +			 wacom_sys_irq, wacom, endpoint->bInterval);
 +	wacom->irq->transfer_dma = wacom->data_dma;
 +	wacom->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 +
 +	error = wacom_initialize_leds(wacom);
 +	if (error)
 +		goto fail4;
  
  	if (!(features->quirks & WACOM_QUIRK_NO_INPUT)) {
 -		error = wacom_register_inputs(wacom);
 +		error = wacom_register_input(wacom);
  		if (error)
 -			goto fail_register_inputs;
 +			goto fail5;
  	}
  
 -	if (hdev->bus == BUS_BLUETOOTH) {
 -		error = device_create_file(&hdev->dev, &dev_attr_speed);
 -		if (error)
 -			hid_warn(hdev,
 -				 "can't create sysfs speed attribute err: %d\n",
 -				 error);
 -	}
++<<<<<<< HEAD
 +	/* Note that if query fails it is not a hard failure */
 +	wacom_query_tablet_data(intf, features);
  
 +	usb_set_intfdata(intf, wacom);
 +
 +	if (features->quirks & WACOM_QUIRK_MONITOR) {
 +		if (usb_submit_urb(wacom->irq, GFP_KERNEL)) {
 +			error = -EIO;
 +			goto fail5;
 +		}
++=======
+ 	if (features->type == HID_GENERIC)
+ 		connect_mask |= HID_CONNECT_DRIVER;
+ 
+ 	/* Regular HID work starts now */
+ 	error = hid_hw_start(hdev, connect_mask);
+ 	if (error) {
+ 		hid_err(hdev, "hw start failed\n");
+ 		goto fail_hw_start;
+ 	}
+ 
+ 	/* Note that if query fails it is not a hard failure */
+ 	wacom_query_tablet_data(hdev, features);
+ 
+ 	if (features->quirks & WACOM_QUIRK_MONITOR)
+ 		error = hid_hw_open(hdev);
+ 
+ 	if (wacom_wac->features.type == INTUOSHT && wacom_wac->features.touch_max) {
+ 		if (wacom_wac->features.device_type == BTN_TOOL_FINGER)
+ 			wacom_wac->shared->touch_input = wacom_wac->input;
++>>>>>>> 5ae6e89f7409 (HID: wacom: implement the finger part of the HID generic handling)
  	}
  
  	return 0;
diff --cc drivers/hid/wacom_wac.c
index 01ec753fea53,586b2405b0d4..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1102,6 -1248,296 +1102,299 @@@ static int wacom_tpc_irq(struct wacom_w
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_map_usage(struct wacom *wacom, struct hid_usage *usage,
+ 		struct hid_field *field, __u8 type, __u16 code, int fuzz)
+ {
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 	int fmin = field->logical_minimum;
+ 	int fmax = field->logical_maximum;
+ 
+ 	usage->type = type;
+ 	usage->code = code;
+ 
+ 	set_bit(type, input->evbit);
+ 
+ 	switch (type) {
+ 	case EV_ABS:
+ 		input_set_abs_params(input, code, fmin, fmax, fuzz, 0);
+ 		input_abs_set_res(input, code,
+ 				  hidinput_calc_abs_res(field, code));
+ 		break;
+ 	case EV_KEY:
+ 		input_set_capability(input, EV_KEY, code);
+ 		break;
+ 	case EV_MSC:
+ 		input_set_capability(input, EV_MSC, code);
+ 		break;
+ 	}
+ }
+ 
+ static void wacom_wac_pen_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		wacom_map_usage(wacom, usage, field, EV_ABS, ABS_X, 4);
+ 		break;
+ 	case HID_GD_Y:
+ 		wacom_map_usage(wacom, usage, field, EV_ABS, ABS_Y, 4);
+ 		break;
+ 	case HID_DG_TIPPRESSURE:
+ 		wacom_map_usage(wacom, usage, field, EV_ABS, ABS_PRESSURE, 0);
+ 		break;
+ 	case HID_DG_INRANGE:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_TOOL_PEN, 0);
+ 		break;
+ 	case HID_DG_INVERT:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY,
+ 				BTN_TOOL_RUBBER, 0);
+ 		break;
+ 	case HID_DG_ERASER:
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_TOUCH, 0);
+ 		break;
+ 	case HID_DG_BARRELSWITCH:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_STYLUS, 0);
+ 		break;
+ 	case HID_DG_BARRELSWITCH2:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_STYLUS2, 0);
+ 		break;
+ 	case HID_DG_TOOLSERIALNUMBER:
+ 		wacom_map_usage(wacom, usage, field, EV_MSC, MSC_SERIAL, 0);
+ 		break;
+ 	}
+ }
+ 
+ static int wacom_wac_pen_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 
+ 	/* checking which Tool / tip switch to send */
+ 	switch (usage->hid) {
+ 	case HID_DG_INRANGE:
+ 		wacom_wac->hid_data.inrange_state = value;
+ 		return 0;
+ 	case HID_DG_INVERT:
+ 		wacom_wac->hid_data.invert_state = value;
+ 		return 0;
+ 	case HID_DG_ERASER:
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_wac->hid_data.tipswitch |= value;
+ 		return 0;
+ 	}
+ 
+ 	/* send pen events only when touch is up or forced out */
+ 	if (!usage->type || wacom_wac->shared->touch_down)
+ 		return 0;
+ 
+ 	input_event(input, usage->type, usage->code, value);
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_wac_pen_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 	bool prox = wacom_wac->hid_data.inrange_state;
+ 
+ 	if (!wacom_wac->shared->stylus_in_proximity) /* first in prox */
+ 		/* Going into proximity select tool */
+ 		wacom_wac->tool[0] = wacom_wac->hid_data.invert_state ?
+ 						BTN_TOOL_RUBBER : BTN_TOOL_PEN;
+ 
+ 	/* keep pen state for touch events */
+ 	wacom_wac->shared->stylus_in_proximity = prox;
+ 
+ 	/* send pen events only when touch is up or forced out */
+ 	if (!wacom_wac->shared->touch_down) {
+ 		input_report_key(input, BTN_TOUCH,
+ 				wacom_wac->hid_data.tipswitch);
+ 		input_report_key(input, wacom_wac->tool[0], prox);
+ 
+ 		wacom_wac->hid_data.tipswitch = false;
+ 
+ 		input_sync(input);
+ 	}
+ }
+ 
+ static void wacom_wac_finger_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 	unsigned touch_max = wacom_wac->features.touch_max;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		if (touch_max == 1)
+ 			wacom_map_usage(wacom, usage, field, EV_ABS, ABS_X, 4);
+ 		else
+ 			wacom_map_usage(wacom, usage, field, EV_ABS,
+ 					ABS_MT_POSITION_X, 4);
+ 		break;
+ 	case HID_GD_Y:
+ 		if (touch_max == 1)
+ 			wacom_map_usage(wacom, usage, field, EV_ABS, ABS_Y, 4);
+ 		else
+ 			wacom_map_usage(wacom, usage, field, EV_ABS,
+ 					ABS_MT_POSITION_Y, 4);
+ 		break;
+ 	case HID_DG_CONTACTID:
+ 		input_mt_init_slots(input, wacom_wac->features.touch_max,
+ 			INPUT_MT_DIRECT);
+ 		break;
+ 	case HID_DG_INRANGE:
+ 		break;
+ 	case HID_DG_INVERT:
+ 		break;
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_map_usage(wacom, usage, field, EV_KEY, BTN_TOUCH, 0);
+ 		break;
+ 	}
+ }
+ 
+ static int wacom_wac_finger_event(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		wacom_wac->hid_data.x = value;
+ 		break;
+ 	case HID_GD_Y:
+ 		wacom_wac->hid_data.y = value;
+ 		break;
+ 	case HID_DG_CONTACTID:
+ 		wacom_wac->hid_data.id = value;
+ 		break;
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_wac->hid_data.tipswitch = value;
+ 		break;
+ 	}
+ 
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_wac_finger_mt_report(struct wacom_wac *wacom_wac,
+ 		struct input_dev *input, bool touch)
+ {
+ 	int slot;
+ 	struct hid_data *hid_data = &wacom_wac->hid_data;
+ 
+ 	slot = input_mt_get_slot_by_key(input, hid_data->id);
+ 
+ 	input_mt_slot(input, slot);
+ 	input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
+ 	if (touch) {
+ 		input_report_abs(input, ABS_MT_POSITION_X, hid_data->x);
+ 		input_report_abs(input, ABS_MT_POSITION_Y, hid_data->y);
+ 	}
+ 	input_mt_sync_frame(input);
+ }
+ 
+ static void wacom_wac_finger_single_touch_report(struct wacom_wac *wacom_wac,
+ 		struct input_dev *input, bool touch)
+ {
+ 	struct hid_data *hid_data = &wacom_wac->hid_data;
+ 
+ 	if (touch) {
+ 		input_report_abs(input, ABS_X, hid_data->x);
+ 		input_report_abs(input, ABS_Y, hid_data->y);
+ 	}
+ 	input_report_key(input, BTN_TOUCH, touch);
+ }
+ 
+ static void wacom_wac_finger_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 	bool touch = wacom_wac->hid_data.tipswitch &&
+ 		     !wacom_wac->shared->stylus_in_proximity;
+ 	unsigned touch_max = wacom_wac->features.touch_max;
+ 
+ 	if (touch_max > 1)
+ 		wacom_wac_finger_mt_report(wacom_wac, input, touch);
+ 	else
+ 		wacom_wac_finger_single_touch_report(wacom_wac, input, touch);
+ 	input_sync(input);
+ 
+ 	/* keep touch state for pen event */
+ 	wacom_wac->shared->touch_down = touch;
+ }
+ 
+ #define WACOM_PEN_FIELD(f)	(((f)->logical == HID_DG_STYLUS) || \
+ 				 ((f)->physical == HID_DG_STYLUS))
+ #define WACOM_FINGER_FIELD(f)	(((f)->logical == HID_DG_FINGER) || \
+ 				 ((f)->physical == HID_DG_FINGER))
+ 
+ void wacom_wac_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->input;
+ 
+ 	/* currently, only direct devices have proper hid report descriptors */
+ 	__set_bit(INPUT_PROP_DIRECT, input->propbit);
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_usage_mapping(hdev, field, usage);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_usage_mapping(hdev, field, usage);
+ }
+ 
+ int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 
+ 	if (wacom->wacom_wac.features.type != HID_GENERIC)
+ 		return 0;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_event(hdev, field, usage, value);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_event(hdev, field, usage, value);
+ 
+ 	return 0;
+ }
+ 
+ void wacom_wac_report(struct hid_device *hdev, struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_field *field = report->field[0];
+ 
+ 	if (wacom_wac->features.type != HID_GENERIC)
+ 		return;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_report(hdev, report);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_report(hdev, report);
+ }
+ 
++>>>>>>> 5ae6e89f7409 (HID: wacom: implement the finger part of the HID generic handling)
  static int wacom_bpt_touch(struct wacom_wac *wacom)
  {
  	struct wacom_features *features = &wacom->features;
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,0f0b85ec1322..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -135,6 -149,24 +135,27 @@@ struct wacom_features 
  struct wacom_shared {
  	bool stylus_in_proximity;
  	bool touch_down;
++<<<<<<< HEAD
++=======
+ 	/* for wireless device to access USB interfaces */
+ 	unsigned touch_max;
+ 	int type;
+ 	struct input_dev *touch_input;
+ };
+ 
+ struct hid_data {
+ 	__s16 inputmode;	/* InputMode HID feature, -1 if non-existent */
+ 	__s16 inputmode_index;	/* InputMode HID feature index in the report */
+ 	bool inrange_state;
+ 	bool invert_state;
+ 	bool tipswitch;
+ 	int x;
+ 	int y;
+ 	int pressure;
+ 	int width;
+ 	int height;
+ 	int id;
++>>>>>>> 5ae6e89f7409 (HID: wacom: implement the finger part of the HID generic handling)
  };
  
  struct wacom_wac {
* Unmerged path drivers/hid/wacom_sys.c
* Unmerged path drivers/hid/wacom_wac.c
* Unmerged path drivers/hid/wacom_wac.h
