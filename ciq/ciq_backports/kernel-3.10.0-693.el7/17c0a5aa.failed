make acct_kill() wait for file closing.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] make acct_kill() wait for file closing ("Eric W. Biederman") [1247935]
Rebuild_FUZZ: 98.70%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 17c0a5aaffa63da6b5c73a31e36616bdcd12d143
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/17c0a5aa.failed

Do actual closing of file via schedule_work().  And use
__fput_sync() there.

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 17c0a5aaffa63da6b5c73a31e36616bdcd12d143)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/acct.c
diff --cc kernel/acct.c
index 7ffb48430dba,d9ebc96b1126..000000000000
--- a/kernel/acct.c
+++ b/kernel/acct.c
@@@ -84,11 -92,16 +84,16 @@@ struct bsd_acct_struct 
  	unsigned long		needcheck;
  	struct file		*file;
  	struct pid_namespace	*ns;
++<<<<<<< HEAD
 +	struct list_head	list;
++=======
+ 	struct work_struct	work;
+ 	struct completion	done;
++>>>>>>> 17c0a5aaffa6 (make acct_kill() wait for file closing.)
  };
  
 -static void acct_free_rcu(struct rcu_head *head)
 -{
 -	kfree(container_of(head, struct bsd_acct_struct, rcu));
 -}
 -
  static DEFINE_SPINLOCK(acct_lock);
 +static LIST_HEAD(acct_list);
  
  /*
   * Check the amount of free space and suspend/resume accordingly.
@@@ -187,25 -193,30 +203,32 @@@ static void acct_kill(struct bsd_acct_s
  		      struct bsd_acct_struct *new)
  {
  	if (acct) {
- 		struct file *file = acct->file;
  		struct pid_namespace *ns = acct->ns;
++<<<<<<< HEAD
 +		spin_lock(&acct_lock);
 +		list_del(&acct->list);
 +		mnt_unpin(file->f_path.mnt);
 +		spin_unlock(&acct_lock);
 +		do_acct_process(acct);
 +		filp_close(file, NULL);
++=======
+ 		do_acct_process(acct);
+ 		INIT_WORK(&acct->work, close_work);
+ 		init_completion(&acct->done);
+ 		schedule_work(&acct->work);
+ 		wait_for_completion(&acct->done);
++>>>>>>> 17c0a5aaffa6 (make acct_kill() wait for file closing.)
  		spin_lock(&acct_lock);
 -		hlist_del(&acct->m_list);
 -		hlist_del(&acct->s_list);
 -		spin_unlock(&acct_lock);
  		ns->bacct = new;
  		if (new) {
 -			struct vfsmount *m = new->file->f_path.mnt;
 -			mnt_pin(m);
 -			spin_lock(&acct_lock);
 -			hlist_add_head(&new->s_list, &m->mnt_sb->s_pins);
 -			hlist_add_head(&new->m_list, &real_mount(m)->mnt_pins);
 -			spin_unlock(&acct_lock);
 -			mutex_unlock(&new->lock);
 +			mnt_pin(new->file->f_path.mnt);
 +			list_add(&new->list, &acct_list);
  		}
  		acct->ns = NULL;
 -		atomic_long_dec(&acct->count);
  		mutex_unlock(&acct->lock);
 -		acct_put(acct);
 +		if (!(acct->count -= 2))
 +			kfree(acct);
 +		spin_unlock(&acct_lock);
  	}
  }
  
* Unmerged path kernel/acct.c
