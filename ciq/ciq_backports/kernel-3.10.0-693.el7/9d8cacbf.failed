NFSv4: Fix reboot recovery in copy offload

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 9d8cacbf5636657d2cd0dda17438a56d806d3224
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9d8cacbf.failed

Copy offload code needs to be hooked into the code for handling
NFS4ERR_BAD_STATEID by ensuring that we set the "stateid" field
in struct nfs4_exception.

	Reported-by: Olga Kornievskaia <aglo@umich.edu>
Fixes: 2e72448b07dc3 ("NFS: Add COPY nfs operation")
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
	Cc: stable@vger.kernel.org # v4.7+
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 9d8cacbf5636657d2cd0dda17438a56d806d3224)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs42proc.c
diff --cc fs/nfs/nfs42proc.c
index 923864bebddf,1e486c73ec94..000000000000
--- a/fs/nfs/nfs42proc.c
+++ b/fs/nfs/nfs42proc.c
@@@ -121,8 -124,133 +121,133 @@@ int nfs42_proc_deallocate(struct file *
  		truncate_pagecache_range(inode, offset, (offset + len) -1);
  	if (err == -EOPNOTSUPP)
  		NFS_SERVER(inode)->caps &= ~NFS_CAP_DEALLOCATE;
 -out_unlock:
 -	inode_unlock(inode);
 -	return err;
 -}
  
++<<<<<<< HEAD
 +	mutex_unlock(&inode->i_mutex);
++=======
+ static ssize_t _nfs42_proc_copy(struct file *src,
+ 				struct nfs_lock_context *src_lock,
+ 				struct file *dst,
+ 				struct nfs_lock_context *dst_lock,
+ 				struct nfs42_copy_args *args,
+ 				struct nfs42_copy_res *res)
+ {
+ 	struct rpc_message msg = {
+ 		.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_COPY],
+ 		.rpc_argp = args,
+ 		.rpc_resp = res,
+ 	};
+ 	struct inode *dst_inode = file_inode(dst);
+ 	struct nfs_server *server = NFS_SERVER(dst_inode);
+ 	loff_t pos_src = args->src_pos;
+ 	loff_t pos_dst = args->dst_pos;
+ 	size_t count = args->count;
+ 	int status;
+ 
+ 	status = nfs4_set_rw_stateid(&args->src_stateid, src_lock->open_context,
+ 				     src_lock, FMODE_READ);
+ 	if (status)
+ 		return status;
+ 
+ 	status = nfs_filemap_write_and_wait_range(file_inode(src)->i_mapping,
+ 			pos_src, pos_src + (loff_t)count - 1);
+ 	if (status)
+ 		return status;
+ 
+ 	status = nfs4_set_rw_stateid(&args->dst_stateid, dst_lock->open_context,
+ 				     dst_lock, FMODE_WRITE);
+ 	if (status)
+ 		return status;
+ 
+ 	status = nfs_sync_inode(dst_inode);
+ 	if (status)
+ 		return status;
+ 
+ 	status = nfs4_call_sync(server->client, server, &msg,
+ 				&args->seq_args, &res->seq_res, 0);
+ 	if (status == -ENOTSUPP)
+ 		server->caps &= ~NFS_CAP_COPY;
+ 	if (status)
+ 		return status;
+ 
+ 	if (res->write_res.verifier.committed != NFS_FILE_SYNC) {
+ 		status = nfs_commit_file(dst, &res->write_res.verifier.verifier);
+ 		if (status)
+ 			return status;
+ 	}
+ 
+ 	truncate_pagecache_range(dst_inode, pos_dst,
+ 				 pos_dst + res->write_res.count);
+ 
+ 	return res->write_res.count;
+ }
+ 
+ ssize_t nfs42_proc_copy(struct file *src, loff_t pos_src,
+ 			struct file *dst, loff_t pos_dst,
+ 			size_t count)
+ {
+ 	struct nfs_server *server = NFS_SERVER(file_inode(dst));
+ 	struct nfs_lock_context *src_lock;
+ 	struct nfs_lock_context *dst_lock;
+ 	struct nfs42_copy_args args = {
+ 		.src_fh		= NFS_FH(file_inode(src)),
+ 		.src_pos	= pos_src,
+ 		.dst_fh		= NFS_FH(file_inode(dst)),
+ 		.dst_pos	= pos_dst,
+ 		.count		= count,
+ 	};
+ 	struct nfs42_copy_res res;
+ 	struct nfs4_exception src_exception = {
+ 		.inode		= file_inode(src),
+ 		.stateid	= &args.src_stateid,
+ 	};
+ 	struct nfs4_exception dst_exception = {
+ 		.inode		= file_inode(dst),
+ 		.stateid	= &args.dst_stateid,
+ 	};
+ 	ssize_t err, err2;
+ 
+ 	if (!nfs_server_capable(file_inode(dst), NFS_CAP_COPY))
+ 		return -EOPNOTSUPP;
+ 
+ 	src_lock = nfs_get_lock_context(nfs_file_open_context(src));
+ 	if (IS_ERR(src_lock))
+ 		return PTR_ERR(src_lock);
+ 
+ 	src_exception.state = src_lock->open_context->state;
+ 
+ 	dst_lock = nfs_get_lock_context(nfs_file_open_context(dst));
+ 	if (IS_ERR(dst_lock)) {
+ 		err = PTR_ERR(dst_lock);
+ 		goto out_put_src_lock;
+ 	}
+ 
+ 	dst_exception.state = dst_lock->open_context->state;
+ 
+ 	do {
+ 		inode_lock(file_inode(dst));
+ 		err = _nfs42_proc_copy(src, src_lock,
+ 				dst, dst_lock,
+ 				&args, &res);
+ 		inode_unlock(file_inode(dst));
+ 
+ 		if (err >= 0)
+ 			break;
+ 		if (err == -ENOTSUPP) {
+ 			err = -EOPNOTSUPP;
+ 			break;
+ 		}
+ 
+ 		err2 = nfs4_handle_exception(server, err, &src_exception);
+ 		err  = nfs4_handle_exception(server, err, &dst_exception);
+ 		if (!err)
+ 			err = err2;
+ 	} while (src_exception.retry || dst_exception.retry);
+ 
+ 	nfs_put_lock_context(dst_lock);
+ out_put_src_lock:
+ 	nfs_put_lock_context(src_lock);
++>>>>>>> 9d8cacbf5636 (NFSv4: Fix reboot recovery in copy offload)
  	return err;
  }
  
* Unmerged path fs/nfs/nfs42proc.c
