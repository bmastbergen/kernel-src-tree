perf/core: Introduce PMU_EV_CAP_READ_ACTIVE_PKG

jira LE-1907
cve CVE-2017-6001
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Carrillo-Cisneros <davidcc@google.com>
commit d6a2f9035bfc27d0e9d78b13635dda9fb017ac01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d6a2f903.failed

Introduce the flag PMU_EV_CAP_READ_ACTIVE_PKG, useful for uncore events,
that allows a PMU to signal the generic perf code that an event is readable
in the current CPU if the event is active in a CPU in the same package as
the current CPU.

This is an optimization that avoids a unnecessary IPI for the common case
where uncore events are run and read in the same package but in
different CPUs.

As an example, the IPI removal speeds up perf_read() in my Haswell system
as follows:

  - For event UNC_C_LLC_LOOKUP: From 260 us to 31 us.
  - For event RAPL's power/energy-cores/: From to 255 us to 27 us.

For the optimization to work, all events in the group must have it
(similarly to PERF_EV_CAP_SOFTWARE).

	Signed-off-by: David Carrillo-Cisneros <davidcc@google.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: David Carrillo-Cisneros <davidcc@google.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Kan Liang <kan.liang@intel.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Paul Turner <pjt@google.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vegard Nossum <vegard.nossum@gmail.com>
	Cc: Vince Weaver <vincent.weaver@maine.edu>
Link: http://lkml.kernel.org/r/1471467307-61171-4-git-send-email-davidcc@google.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit d6a2f9035bfc27d0e9d78b13635dda9fb017ac01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/perf_event.h
#	kernel/events/core.c
diff --cc include/linux/perf_event.h
index 6141b9801ed0,5c5362584aba..000000000000
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@@ -347,9 -510,15 +347,21 @@@ typedef void (*perf_overflow_handler_t)
  					struct perf_sample_data *,
  					struct pt_regs *regs);
  
++<<<<<<< HEAD
 +enum perf_group_flag {
 +	PERF_GROUP_SOFTWARE		= 0x1,
 +};
++=======
+ /*
+  * Event capabilities. For event_caps and groups caps.
+  *
+  * PERF_EV_CAP_SOFTWARE: Is a software event.
+  * PERF_EV_CAP_READ_ACTIVE_PKG: A CPU event (or cgroup event) that can be read
+  * from any CPU in the package where it is active.
+  */
+ #define PERF_EV_CAP_SOFTWARE		BIT(0)
+ #define PERF_EV_CAP_READ_ACTIVE_PKG	BIT(1)
++>>>>>>> d6a2f9035bfc (perf/core: Introduce PMU_EV_CAP_READ_ACTIVE_PKG)
  
  #define SWEVENT_HLIST_BITS		8
  #define SWEVENT_HLIST_SIZE		(1 << SWEVENT_HLIST_BITS)
diff --cc kernel/events/core.c
index 44be586a54d8,3f07e6cfc1b6..000000000000
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@@ -3550,18 -3573,15 +3566,30 @@@ static int perf_event_read(struct perf_
  			.group = group,
  			.ret = 0,
  		};
++<<<<<<< HEAD
 +		/*
 +		 * Purposely ignore the smp_call_function_single() return
 +		 * value.
 +		 *
 +		 * If event->oncpu isn't a valid CPU it means the event got
 +		 * scheduled out and that will have updated the event count.
 +		 *
 +		 * Therefore, either way, we'll have an up-to-date event count
 +		 * after this.
 +		 */
 +		(void)smp_call_function_single(event->oncpu, __perf_event_read, &data, 1);
 +		ret = data.ret;
++=======
+ 
+ 		local_cpu = get_cpu();
+ 		cpu_to_read = find_cpu_to_read(event, local_cpu);
+ 		put_cpu();
+ 
+ 		ret = smp_call_function_single(cpu_to_read, __perf_event_read, &data, 1);
+ 		/* The event must have been read from an online CPU: */
+ 		WARN_ON_ONCE(ret);
+ 		ret = ret ? : data.ret;
++>>>>>>> d6a2f9035bfc (perf/core: Introduce PMU_EV_CAP_READ_ACTIVE_PKG)
  	} else if (event->state == PERF_EVENT_STATE_INACTIVE) {
  		struct perf_event_context *ctx = event->ctx;
  		unsigned long flags;
* Unmerged path include/linux/perf_event.h
* Unmerged path kernel/events/core.c
