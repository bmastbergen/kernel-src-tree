acct: move mnt_pin() upwards.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] acct: move mnt_pin() upwards ("Eric W. Biederman") [1247935]
Rebuild_FUZZ: 98.25%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 215748e67d893169de9e62c3416e9e035e9e9c5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/215748e6.failed

	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 215748e67d893169de9e62c3416e9e035e9e9c5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/acct.c
diff --cc kernel/acct.c
index 7ffb48430dba,2d9e04d98998..000000000000
--- a/kernel/acct.c
+++ b/kernel/acct.c
@@@ -187,25 -193,29 +187,34 @@@ static void acct_kill(struct bsd_acct_s
  		      struct bsd_acct_struct *new)
  {
  	if (acct) {
 +		struct file *file = acct->file;
  		struct pid_namespace *ns = acct->ns;
 -		do_acct_process(acct);
 -		INIT_WORK(&acct->work, close_work);
 -		init_completion(&acct->done);
 -		schedule_work(&acct->work);
 -		wait_for_completion(&acct->done);
  		spin_lock(&acct_lock);
 -		hlist_del(&acct->m_list);
 -		hlist_del(&acct->s_list);
 +		list_del(&acct->list);
 +		mnt_unpin(file->f_path.mnt);
  		spin_unlock(&acct_lock);
 +		do_acct_process(acct);
 +		filp_close(file, NULL);
 +		spin_lock(&acct_lock);
  		ns->bacct = new;
  		if (new) {
++<<<<<<< HEAD
 +			mnt_pin(new->file->f_path.mnt);
 +			list_add(&new->list, &acct_list);
++=======
+ 			struct vfsmount *m = new->file->f_path.mnt;
+ 			spin_lock(&acct_lock);
+ 			hlist_add_head(&new->s_list, &m->mnt_sb->s_pins);
+ 			hlist_add_head(&new->m_list, &real_mount(m)->mnt_pins);
+ 			spin_unlock(&acct_lock);
+ 			mutex_unlock(&new->lock);
++>>>>>>> 215748e67d89 (acct: move mnt_pin() upwards.)
  		}
  		acct->ns = NULL;
 -		atomic_long_dec(&acct->count);
  		mutex_unlock(&acct->lock);
 -		acct_put(acct);
 +		if (!(acct->count -= 2))
 +			kfree(acct);
 +		spin_unlock(&acct_lock);
  	}
  }
  
@@@ -245,16 -255,19 +254,22 @@@ static int acct_on(struct filename *pat
  	acct->ns = ns;
  	mutex_init(&acct->lock);
  	mnt = file->f_path.mnt;
+ 	mnt_pin(mnt);
  
 -	old = acct_get(ns);
 -	mutex_lock_nested(&acct->lock, 1);	/* nobody has seen it yet */
 +	old = acct_get(&ns->bacct);
  	if (old) {
  		acct_kill(old, acct);
  	} else {
 -		ns->bacct = acct;
  		spin_lock(&acct_lock);
++<<<<<<< HEAD
 +		ns->bacct = acct;
 +		mnt_pin(mnt);
 +		list_add(&acct->list, &acct_list);
++=======
+ 		hlist_add_head(&acct->s_list, &mnt->mnt_sb->s_pins);
+ 		hlist_add_head(&acct->m_list, &real_mount(mnt)->mnt_pins);
++>>>>>>> 215748e67d89 (acct: move mnt_pin() upwards.)
  		spin_unlock(&acct_lock);
 -		mutex_unlock(&acct->lock);
  	}
  	mntput(mnt); /* it's pinned, now give up active reference */
  	return 0;
* Unmerged path kernel/acct.c
