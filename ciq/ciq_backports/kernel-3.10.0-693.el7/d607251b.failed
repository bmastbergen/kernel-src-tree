x86/boot: Calculate decompression size during boot not build

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] boot: Calculate decompression size during boot not build (Baoquan He) [1290840]
Rebuild_FUZZ: 96.55%
commit-author Yinghai Lu <yinghai@kernel.org>
commit d607251ba9acc0b5faeaa08818f60d041dd19472
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d607251b.failed

Currently z_extract_offset is calculated in boot/compressed/mkpiggy.c.
This doesn't work well because mkpiggy.c doesn't know the details of the
decompressor in use. As a result, it can only make an estimation, which
has risks:

 - output + output_len (VO) could be much bigger than input + input_len
   (ZO). In this case, the decompressed kernel plus relocs could overwrite
   the decompression code while it is running.

 - The head code of ZO could be bigger than z_extract_offset. In this case
   an overwrite could happen when the head code is running to move ZO to
   the end of buffer. Though currently the size of the head code is very
   small it's still a potential risk. Since there is no rule to limit the
   size of the head code of ZO, it runs the risk of suddenly becoming a
   (hard to find) bug.

Instead, this moves the z_extract_offset calculation into header.S, and
makes adjustments to be sure that the above two cases can never happen,
and further corrects the comments describing the calculations.

Since we have (in the previous patch) made ZO always be located against
the end of decompression buffer, z_extract_offset is only used here to
calculate an appropriate buffer size (INIT_SIZE), and is not longer used
elsewhere. As such, it can be removed from voffset.h.

Additionally clean up #if/#else #define to improve readability.

	Signed-off-by: Yinghai Lu <yinghai@kernel.org>
	Signed-off-by: Baoquan He <bhe@redhat.com>
[ Rewrote the changelog and comments. ]
	Signed-off-by: Kees Cook <keescook@chromium.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vivek Goyal <vgoyal@redhat.com>
	Cc: lasse.collin@tukaani.org
Link: http://lkml.kernel.org/r/1461888548-32439-4-git-send-email-keescook@chromium.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit d607251ba9acc0b5faeaa08818f60d041dd19472)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/boot/compressed/mkpiggy.c
#	arch/x86/boot/header.S
diff --cc arch/x86/boot/compressed/mkpiggy.c
index b669ab65bf6c,f095ed9e7d3c..000000000000
--- a/arch/x86/boot/compressed/mkpiggy.c
+++ b/arch/x86/boot/compressed/mkpiggy.c
@@@ -35,7 -34,7 +34,11 @@@ int main(int argc, char *argv[]
  {
  	uint32_t olen;
  	long ilen;
++<<<<<<< HEAD
 +	unsigned long offs;
++=======
+ 	unsigned long run_size;
++>>>>>>> d607251ba9ac (x86/boot: Calculate decompression size during boot not build)
  	FILE *f = NULL;
  	int retval = 1;
  
@@@ -65,26 -65,15 +68,35 @@@
  	ilen = ftell(f);
  	olen = get_unaligned_le32(&olen);
  
++<<<<<<< HEAD
 +	/*
 +	 * Now we have the input (compressed) and output (uncompressed)
 +	 * sizes, compute the necessary decompression offset...
 +	 */
 +
 +	offs = (olen > ilen) ? olen - ilen : 0;
 +	offs += olen >> 12;	/* Add 8 bytes for each 32K block */
 +	offs += 64*1024 + 128;	/* Add 64K + 128 bytes slack */
 +	offs = (offs+4095) & ~4095; /* Round to a 4K boundary */
++=======
+ 	run_size = atoi(argv[2]);
++>>>>>>> d607251ba9ac (x86/boot: Calculate decompression size during boot not build)
  
  	printf(".section \".rodata..compressed\",\"a\",@progbits\n");
  	printf(".globl z_input_len\n");
  	printf("z_input_len = %lu\n", ilen);
  	printf(".globl z_output_len\n");
  	printf("z_output_len = %lu\n", (unsigned long)olen);
++<<<<<<< HEAD
 +	printf(".globl z_extract_offset\n");
 +	printf("z_extract_offset = 0x%lx\n", offs);
 +	/* z_extract_offset_negative allows simplification of head_32.S */
 +	printf(".globl z_extract_offset_negative\n");
 +	printf("z_extract_offset_negative = -0x%lx\n", offs);
++=======
+ 	printf(".globl z_run_size\n");
+ 	printf("z_run_size = %lu\n", run_size);
++>>>>>>> d607251ba9ac (x86/boot: Calculate decompression size during boot not build)
  
  	printf(".globl input_data, input_data_end\n");
  	printf("input_data:\n");
diff --cc arch/x86/boot/header.S
index 7a6d43a554d7,3dd5be33aaa7..000000000000
--- a/arch/x86/boot/header.S
+++ b/arch/x86/boot/header.S
@@@ -440,13 -440,116 +440,120 @@@ setup_data:		.quad 0			# 64-bit physica
  
  pref_address:		.quad LOAD_PHYSICAL_ADDR	# preferred load addr
  
++<<<<<<< HEAD
 +#define ZO_INIT_SIZE	(ZO__end - ZO_startup_32 + ZO_z_extract_offset)
++=======
+ #
+ # Getting to provably safe in-place decompression is hard. Worst case
+ # behaviours need to be analyzed. Here let's take the decompression of
+ # a gzip-compressed kernel as example, to illustrate it:
+ #
+ # The file layout of gzip compressed kernel is:
+ #
+ #    magic[2]
+ #    method[1]
+ #    flags[1]
+ #    timestamp[4]
+ #    extraflags[1]
+ #    os[1]
+ #    compressed data blocks[N]
+ #    crc[4] orig_len[4]
+ #
+ # ... resulting in +18 bytes overhead of uncompressed data.
+ #
+ # (For more information, please refer to RFC 1951 and RFC 1952.)
+ #
+ # Files divided into blocks
+ # 1 bit (last block flag)
+ # 2 bits (block type)
+ #
+ # 1 block occurs every 32K -1 bytes or when there 50% compression
+ # has been achieved. The smallest block type encoding is always used.
+ #
+ # stored:
+ #    32 bits length in bytes.
+ #
+ # fixed:
+ #    magic fixed tree.
+ #    symbols.
+ #
+ # dynamic:
+ #    dynamic tree encoding.
+ #    symbols.
+ #
+ #
+ # The buffer for decompression in place is the length of the uncompressed
+ # data, plus a small amount extra to keep the algorithm safe. The
+ # compressed data is placed at the end of the buffer.  The output pointer
+ # is placed at the start of the buffer and the input pointer is placed
+ # where the compressed data starts. Problems will occur when the output
+ # pointer overruns the input pointer.
+ #
+ # The output pointer can only overrun the input pointer if the input
+ # pointer is moving faster than the output pointer.  A condition only
+ # triggered by data whose compressed form is larger than the uncompressed
+ # form.
+ #
+ # The worst case at the block level is a growth of the compressed data
+ # of 5 bytes per 32767 bytes.
+ #
+ # The worst case internal to a compressed block is very hard to figure.
+ # The worst case can at least be bounded by having one bit that represents
+ # 32764 bytes and then all of the rest of the bytes representing the very
+ # very last byte.
+ #
+ # All of which is enough to compute an amount of extra data that is required
+ # to be safe.  To avoid problems at the block level allocating 5 extra bytes
+ # per 32767 bytes of data is sufficient.  To avoid problems internal to a
+ # block adding an extra 32767 bytes (the worst case uncompressed block size)
+ # is sufficient, to ensure that in the worst case the decompressed data for
+ # block will stop the byte before the compressed data for a block begins.
+ # To avoid problems with the compressed data's meta information an extra 18
+ # bytes are needed.  Leading to the formula:
+ #
+ # extra_bytes = (uncompressed_size >> 12) + 32768 + 18
+ #
+ # Adding 8 bytes per 32K is a bit excessive but much easier to calculate.
+ # Adding 32768 instead of 32767 just makes for round numbers.
+ #
+ # Above analysis is for decompressing gzip compressed kernel only. Up to
+ # now 6 different decompressor are supported all together. And among them
+ # xz stores data in chunks and has maximum chunk of 64K. Hence safety
+ # margin should be updated to cover all decompressors so that we don't
+ # need to deal with each of them separately. Please check
+ # the description in lib/decompressor_xxx.c for specific information.
+ #
+ # extra_bytes = (uncompressed_size >> 12) + 65536 + 128
+ 
+ #define ZO_z_extra_bytes	((ZO_z_output_len >> 12) + 65536 + 128)
+ #if ZO_z_output_len > ZO_z_input_len
+ # define ZO_z_extract_offset	(ZO_z_output_len + ZO_z_extra_bytes - \
+ 				 ZO_z_input_len)
+ #else
+ # define ZO_z_extract_offset	ZO_z_extra_bytes
+ #endif
+ 
+ /*
+  * The extract_offset has to be bigger than ZO head section. Otherwise when
+  * the head code is running to move ZO to the end of the buffer, it will
+  * overwrite the head code itself.
+  */
+ #if (ZO__ehead - ZO_startup_32) > ZO_z_extract_offset
+ # define ZO_z_min_extract_offset ((ZO__ehead - ZO_startup_32 + 4095) & ~4095)
+ #else
+ # define ZO_z_min_extract_offset ((ZO_z_extract_offset + 4095) & ~4095)
+ #endif
+ 
+ #define ZO_INIT_SIZE	(ZO__end - ZO_startup_32 + ZO_z_min_extract_offset)
+ 
++>>>>>>> d607251ba9ac (x86/boot: Calculate decompression size during boot not build)
  #define VO_INIT_SIZE	(VO__end - VO__text)
  #if ZO_INIT_SIZE > VO_INIT_SIZE
- #define INIT_SIZE ZO_INIT_SIZE
+ # define INIT_SIZE ZO_INIT_SIZE
  #else
- #define INIT_SIZE VO_INIT_SIZE
+ # define INIT_SIZE VO_INIT_SIZE
  #endif
+ 
  init_size:		.long INIT_SIZE		# kernel initialization size
  handover_offset:	.long 0			# Filled in by build.c
  
diff --git a/arch/x86/boot/Makefile b/arch/x86/boot/Makefile
index e7fb72133865..6cf46961bd1e 100644
--- a/arch/x86/boot/Makefile
+++ b/arch/x86/boot/Makefile
@@ -95,7 +95,7 @@ targets += voffset.h
 $(obj)/voffset.h: vmlinux FORCE
 	$(call if_changed,voffset)
 
-sed-zoffset := -e 's/^\([0-9a-fA-F]*\) [ABCDGRSTVW] \(startup_32\|startup_64\|efi32_stub_entry\|efi64_stub_entry\|efi_pe_entry\|input_data\|_end\|z_.*\)$$/\#define ZO_\2 0x\1/p'
+sed-zoffset := -e 's/^\([0-9a-fA-F]*\) [ABCDGRSTVW] \(startup_32\|startup_64\|efi32_stub_entry\|efi64_stub_entry\|efi_pe_entry\|input_data\|_end\|_ehead\|_text\|z_.*\)$$/\#define ZO_\2 0x\1/p'
 
 quiet_cmd_zoffset = ZOFFSET $@
       cmd_zoffset = $(NM) $< | sed -n $(sed-zoffset) > $@
* Unmerged path arch/x86/boot/compressed/mkpiggy.c
* Unmerged path arch/x86/boot/header.S
