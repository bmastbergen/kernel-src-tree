flow-dissector: Fix alignment issue in __skb_flow_get_ports

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] flow_dissector: Fix alignment issue in __skb_flow_get_ports (Jonathan Toppins) [1428557]
Rebuild_FUZZ: 98.31%
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 5af7fb6e3e92c2797ee30d66138cf6aa6b29240d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5af7fb6e.failed

This patch addresses a kernel unaligned access bug seen on a sparc64 system
with an igb adapter.  Specifically the __skb_flow_get_ports was returning a
be32 pointer which was then having the value directly returned.

In order to prevent this it is actually easier to simply not populate the
ports or address values when an skb is not present.  In this case the
assumption is that the data isn't needed and rather than slow down the
faster aligned accesses by making them have to assume the unaligned path on
architectures that don't support efficent unaligned access it makes more
sense to simply switch off the bits that were copying the source and
destination address/port for the case where we only care about the protocol
types and lengths which are normally 16 bit fields anyway.

	Reported-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5af7fb6e3e92c2797ee30d66138cf6aa6b29240d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index 09a11a6dfc51,45084938c403..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -123,10 -127,27 +125,30 @@@ ipv6
  		if (!skb)
  			break;
  
++<<<<<<< HEAD
++=======
+ 		flow->src = (__force __be32)ipv6_addr_hash(&iph->saddr);
+ 		flow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);
+ 
+ 		flow_label = ip6_flowlabel(iph);
+ 		if (flow_label) {
+ 			/* Awesome, IPv6 packet has a flow label so we can
+ 			 * use that to represent the ports without any
+ 			 * further dissection.
+ 			 */
+ 			flow->n_proto = proto;
+ 			flow->ip_proto = ip_proto;
+ 			flow->ports = flow_label;
+ 			flow->thoff = (u16)nhoff;
+ 
+ 			return true;
+ 		}
+ 
++>>>>>>> 5af7fb6e3e92 (flow-dissector: Fix alignment issue in __skb_flow_get_ports)
  		break;
  	}
 -	case htons(ETH_P_8021AD):
 -	case htons(ETH_P_8021Q): {
 +	case __constant_htons(ETH_P_8021AD):
 +	case __constant_htons(ETH_P_8021Q): {
  		const struct vlan_hdr *vlan;
  		struct vlan_hdr _vlan;
  
* Unmerged path net/core/flow_dissector.c
