selinux: Pass security pointer to determine_inode_label()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Vivek Goyal <vgoyal@redhat.com>
commit c957f6df52c509ccfbb96659fd1a0f7812de333f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c957f6df.failed

Right now selinux_determine_inode_label() works on security pointer of
current task. Soon I need this to work on a security pointer retrieved
from a set of creds. So start passing in a pointer and caller can
decide where to fetch security pointer from.

	Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
	Acked-by: Stephen Smalley <sds@tycho.nsa.gov>
	Signed-off-by: Paul Moore <paul@paul-moore.com>
(cherry picked from commit c957f6df52c509ccfbb96659fd1a0f7812de333f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/selinux/hooks.c
diff --cc security/selinux/hooks.c
index 8f679be12609,f9d398bc9dcd..000000000000
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@@ -1653,6 -1805,32 +1653,35 @@@ out
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Determine the label for an inode that might be unioned.
+  */
+ static int
+ selinux_determine_inode_label(const struct task_security_struct *tsec,
+ 				 struct inode *dir,
+ 				 const struct qstr *name, u16 tclass,
+ 				 u32 *_new_isid)
+ {
+ 	const struct superblock_security_struct *sbsec = dir->i_sb->s_security;
+ 
+ 	if ((sbsec->flags & SE_SBINITIALIZED) &&
+ 	    (sbsec->behavior == SECURITY_FS_USE_MNTPOINT)) {
+ 		*_new_isid = sbsec->mntpoint_sid;
+ 	} else if ((sbsec->flags & SBLABEL_MNT) &&
+ 		   tsec->create_sid) {
+ 		*_new_isid = tsec->create_sid;
+ 	} else {
+ 		const struct inode_security_struct *dsec = inode_security(dir);
+ 		return security_transition_sid(tsec->sid, dsec->sid, tclass,
+ 					       name, _new_isid);
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> c957f6df52c5 (selinux: Pass security pointer to determine_inode_label())
  /* Check whether a task can create a file. */
  static int may_create(struct inode *dir,
  		      struct dentry *dentry,
@@@ -1680,12 -1857,10 +1709,19 @@@
  	if (rc)
  		return rc;
  
++<<<<<<< HEAD
 +	if (!newsid || !(sbsec->flags & SE_SBLABELSUPP)) {
 +		rc = security_transition_sid(sid, dsec->sid, tclass,
 +					     &dentry->d_name, &newsid);
 +		if (rc)
 +			return rc;
 +	}
++=======
+ 	rc = selinux_determine_inode_label(current_security(), dir,
+ 					   &dentry->d_name, tclass, &newsid);
+ 	if (rc)
+ 		return rc;
++>>>>>>> c957f6df52c5 (selinux: Pass security pointer to determine_inode_label())
  
  	rc = avc_has_perm(sid, newsid, tclass, FILE__CREATE, &ad);
  	if (rc)
@@@ -2631,24 -2838,12 +2667,33 @@@ static int selinux_dentry_init_security
  	u32 newsid;
  	int rc;
  
++<<<<<<< HEAD
 +	tsec = cred->security;
 +	dsec = dir->i_security;
 +	sbsec = dir->i_sb->s_security;
 +
 +	if (tsec->create_sid && sbsec->behavior != SECURITY_FS_USE_MNTPOINT) {
 +		newsid = tsec->create_sid;
 +	} else {
 +		rc = security_transition_sid(tsec->sid, dsec->sid,
 +					     inode_mode_to_security_class(mode),
 +					     name,
 +					     &newsid);
 +		if (rc) {
 +			printk(KERN_WARNING
 +				"%s: security_transition_sid failed, rc=%d\n",
 +			       __func__, -rc);
 +			return rc;
 +		}
 +	}
++=======
+ 	rc = selinux_determine_inode_label(current_security(),
+ 					   d_inode(dentry->d_parent), name,
+ 					   inode_mode_to_security_class(mode),
+ 					   &newsid);
+ 	if (rc)
+ 		return rc;
++>>>>>>> c957f6df52c5 (selinux: Pass security pointer to determine_inode_label())
  
  	return security_sid_to_context(newsid, (char **)ctx, ctxlen);
  }
@@@ -2670,22 -2864,12 +2715,31 @@@ static int selinux_inode_init_security(
  	sid = tsec->sid;
  	newsid = tsec->create_sid;
  
++<<<<<<< HEAD
 +	if ((sbsec->flags & SE_SBINITIALIZED) &&
 +	    (sbsec->behavior == SECURITY_FS_USE_MNTPOINT))
 +		newsid = sbsec->mntpoint_sid;
 +	else if (!newsid || !(sbsec->flags & SE_SBLABELSUPP)) {
 +		rc = security_transition_sid(sid, dsec->sid,
 +					     inode_mode_to_security_class(inode->i_mode),
 +					     qstr, &newsid);
 +		if (rc) {
 +			printk(KERN_WARNING "%s:  "
 +			       "security_transition_sid failed, rc=%d (dev=%s "
 +			       "ino=%ld)\n",
 +			       __func__,
 +			       -rc, inode->i_sb->s_id, inode->i_ino);
 +			return rc;
 +		}
 +	}
++=======
+ 	rc = selinux_determine_inode_label(current_security(),
+ 		dir, qstr,
+ 		inode_mode_to_security_class(inode->i_mode),
+ 		&newsid);
+ 	if (rc)
+ 		return rc;
++>>>>>>> c957f6df52c5 (selinux: Pass security pointer to determine_inode_label())
  
  	/* Possibly defer initialization to selinux_complete_init. */
  	if (sbsec->flags & SE_SBINITIALIZED) {
* Unmerged path security/selinux/hooks.c
