skbuff: Make __skb_set_sw_hash a general function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] Make __skb_set_sw_hash a general function (Jonathan Toppins) [1428557]
Rebuild_FUZZ: 91.11%
commit-author Tom Herbert <tom@herbertland.com>
commit bcc83839ffdb063dd2b0370cd85c4f825761fc59
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/bcc83839.failed

Move __skb_set_sw_hash to skbuff.h and add __skb_set_hash which is
a common method (between __skb_set_sw_hash and skb_set_hash) to set
the hash in an skbuff.

Also, move skb_clear_hash to be closer to __skb_set_hash.

	Signed-off-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bcc83839ffdb063dd2b0370cd85c4f825761fc59)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	include/net/flow_dissector.h
#	net/core/flow_dissector.c
diff --cc include/linux/skbuff.h
index dcb8575fa615,5d2c812e725b..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -969,16 -961,66 +990,27 @@@ __skb_set_hash(struct sk_buff *skb, __u
  static inline void
  skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
  {
++<<<<<<< HEAD
 +	skb->l4_hash = (type == PKT_HASH_TYPE_L4);
 +	skb->hash = hash;
++=======
+ 	/* Used by drivers to set hash from HW */
+ 	__skb_set_hash(skb, hash, false, type == PKT_HASH_TYPE_L4);
+ }
+ 
+ static inline void
+ __skb_set_sw_hash(struct sk_buff *skb, __u32 hash, bool is_l4)
+ {
+ 	__skb_set_hash(skb, hash, true, is_l4);
++>>>>>>> bcc83839ffdb (skbuff: Make __skb_set_sw_hash a general function)
  }
  
 -void __skb_get_hash(struct sk_buff *skb);
 -u32 skb_get_poff(const struct sk_buff *skb);
 -u32 __skb_get_poff(const struct sk_buff *skb, void *data,
 -		   const struct flow_keys *keys, int hlen);
 -__be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,
 -			    void *data, int hlen_proto);
 -
 -static inline __be32 skb_flow_get_ports(const struct sk_buff *skb,
 -					int thoff, u8 ip_proto)
 -{
 -	return __skb_flow_get_ports(skb, thoff, ip_proto, NULL, 0);
 -}
 -
 -void skb_flow_dissector_init(struct flow_dissector *flow_dissector,
 -			     const struct flow_dissector_key *key,
 -			     unsigned int key_count);
 -
 -bool __skb_flow_dissect(const struct sk_buff *skb,
 -			struct flow_dissector *flow_dissector,
 -			void *target_container,
 -			void *data, __be16 proto, int nhoff, int hlen);
 -
 -static inline bool skb_flow_dissect(const struct sk_buff *skb,
 -				    struct flow_dissector *flow_dissector,
 -				    void *target_container)
 -{
 -	return __skb_flow_dissect(skb, flow_dissector, target_container,
 -				  NULL, 0, 0, 0);
 -}
 -
 -static inline bool skb_flow_dissect_flow_keys(const struct sk_buff *skb,
 -					      struct flow_keys *flow)
 -{
 -	memset(flow, 0, sizeof(*flow));
 -	return __skb_flow_dissect(skb, &flow_keys_dissector, flow,
 -				  NULL, 0, 0, 0);
 -}
 -
 -static inline bool skb_flow_dissect_flow_keys_buf(struct flow_keys *flow,
 -						  void *data, __be16 proto,
 -						  int nhoff, int hlen)
 -{
 -	memset(flow, 0, sizeof(*flow));
 -	return __skb_flow_dissect(NULL, &flow_keys_buf_dissector, flow,
 -				  data, proto, nhoff, hlen);
 -}
 +#define skb_get_rxhash skb_get_hash
  
 +void __skb_get_hash(struct sk_buff *skb);
  static inline __u32 skb_get_hash(struct sk_buff *skb)
  {
 -	if (!skb->l4_hash && !skb->sw_hash)
 +	if (!skb->l4_hash)
  		__skb_get_hash(skb);
  
  	return skb->hash;
@@@ -989,18 -1033,26 +1021,21 @@@ static inline __u32 skb_get_hash_raw(co
  	return skb->hash;
  }
  
 -__u32 __skb_get_hash_flowi4(struct sk_buff *skb, struct flowi4 *fl);
 -
 -static inline __u32 skb_get_hash_flowi4(struct sk_buff *skb, struct flowi4 *fl4)
++<<<<<<< HEAD
 +static inline void skb_clear_hash(struct sk_buff *skb)
  {
 -	if (!skb->l4_hash && !skb->sw_hash)
 -		__skb_get_hash_flowi4(skb, fl4);
 -
 -	return skb->hash;
 +	skb->hash = 0;
 +	skb->l4_hash = 0;
  }
  
 -__u32 skb_get_hash_perturb(const struct sk_buff *skb, u32 perturb);
 -
 -static inline __u32 skb_get_hash_raw(const struct sk_buff *skb)
 +static inline void skb_clear_hash_if_not_l4(struct sk_buff *skb)
  {
 -	return skb->hash;
 +	if (!skb->l4_hash)
 +		skb_clear_hash(skb);
  }
  
++=======
++>>>>>>> bcc83839ffdb (skbuff: Make __skb_set_sw_hash a general function)
  static inline void skb_copy_hash(struct sk_buff *to, const struct sk_buff *from)
  {
  	to->hash = from->hash;
diff --cc net/core/flow_dissector.c
index c177964713d3,151b6e48b81f..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -342,8 -554,47 +342,52 @@@ u32 flow_hash_from_keys(struct flow_key
  }
  EXPORT_SYMBOL(flow_hash_from_keys);
  
++<<<<<<< HEAD
 +/*
 + * __skb_get_hash: calculate a flow hash based on src/dst addresses
++=======
+ static inline u32 ___skb_get_hash(const struct sk_buff *skb,
+ 				  struct flow_keys *keys, u32 keyval)
+ {
+ 	if (!skb_flow_dissect_flow_keys(skb, keys))
+ 		return 0;
+ 
+ 	return __flow_hash_from_keys(keys, keyval);
+ }
+ 
+ struct _flow_keys_digest_data {
+ 	__be16	n_proto;
+ 	u8	ip_proto;
+ 	u8	padding;
+ 	__be32	ports;
+ 	__be32	src;
+ 	__be32	dst;
+ };
+ 
+ void make_flow_keys_digest(struct flow_keys_digest *digest,
+ 			   const struct flow_keys *flow)
+ {
+ 	struct _flow_keys_digest_data *data =
+ 	    (struct _flow_keys_digest_data *)digest;
+ 
+ 	BUILD_BUG_ON(sizeof(*data) > sizeof(*digest));
+ 
+ 	memset(digest, 0, sizeof(*digest));
+ 
+ 	data->n_proto = flow->basic.n_proto;
+ 	data->ip_proto = flow->basic.ip_proto;
+ 	data->ports = flow->ports.ports;
+ 	data->src = flow->addrs.v4addrs.src;
+ 	data->dst = flow->addrs.v4addrs.dst;
+ }
+ EXPORT_SYMBOL(make_flow_keys_digest);
+ 
+ /**
+  * __skb_get_hash: calculate a flow hash
+  * @skb: sk_buff to calculate flow hash from
+  *
+  * This function calculates a flow hash based on src/dst addresses
++>>>>>>> bcc83839ffdb (skbuff: Make __skb_set_sw_hash a general function)
   * and src/dst port numbers.  Sets hash in skb to non-zero hash value
   * on success, zero indicates no valid hash.  Also, sets l4_hash in skb
   * if hash is a canonical 4-tuple hash over transport ports.
@@@ -351,44 -602,71 +395,98 @@@
  void __skb_get_hash(struct sk_buff *skb)
  {
  	struct flow_keys keys;
 -	u32 hash;
  
 -	__flow_hash_secret_init();
 -
 -	hash = ___skb_get_hash(skb, &keys, hashrnd);
 -	if (!hash)
 +	if (!skb_flow_dissect(skb, &keys))
  		return;
  
++<<<<<<< HEAD
 +	if (keys.ports)
 +		skb->l4_hash = 1;
 +
 +	skb->hash = __flow_hash_from_keys(&keys);
++=======
+ 	__skb_set_sw_hash(skb, hash,
+ 			  flow_keys_have_l4(&keys));
++>>>>>>> bcc83839ffdb (skbuff: Make __skb_set_sw_hash a general function)
  }
  EXPORT_SYMBOL(__skb_get_hash);
  
 -__u32 skb_get_hash_perturb(const struct sk_buff *skb, u32 perturb)
 +/*
 + * Returns a Tx hash based on the given packet descriptor a Tx queues' number
 + * to be used as a distribution range.
 + */
 +u16 __skb_tx_hash(const struct net_device *dev, struct sk_buff *skb,
 +		  unsigned int num_tx_queues)
  {
 -	struct flow_keys keys;
 +	u32 hash;
 +	u16 qoffset = 0;
 +	u16 qcount = num_tx_queues;
 +
 +	if (skb_rx_queue_recorded(skb)) {
 +		hash = skb_get_rx_queue(skb);
 +		while (unlikely(hash >= num_tx_queues))
 +			hash -= num_tx_queues;
 +		return hash;
 +	}
  
 -	return ___skb_get_hash(skb, &keys, perturb);
 +	if (dev->num_tc) {
 +		u8 tc = netdev_get_prio_tc_map(dev, skb->priority);
 +		qoffset = dev->tc_to_txq[tc].offset;
 +		qcount = dev->tc_to_txq[tc].count;
 +	}
 +
 +	return (u16) reciprocal_scale(skb_get_hash(skb), qcount) + qoffset;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(__skb_tx_hash);
++=======
+ EXPORT_SYMBOL(skb_get_hash_perturb);
+ 
+ __u32 __skb_get_hash_flowi6(struct sk_buff *skb, struct flowi6 *fl6)
+ {
+ 	struct flow_keys keys;
+ 
+ 	memset(&keys, 0, sizeof(keys));
+ 
+ 	memcpy(&keys.addrs.v6addrs.src, &fl6->saddr,
+ 	       sizeof(keys.addrs.v6addrs.src));
+ 	memcpy(&keys.addrs.v6addrs.dst, &fl6->daddr,
+ 	       sizeof(keys.addrs.v6addrs.dst));
+ 	keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
+ 	keys.ports.src = fl6->fl6_sport;
+ 	keys.ports.dst = fl6->fl6_dport;
+ 	keys.keyid.keyid = fl6->fl6_gre_key;
+ 	keys.tags.flow_label = (__force u32)fl6->flowlabel;
+ 	keys.basic.ip_proto = fl6->flowi6_proto;
+ 
+ 	__skb_set_sw_hash(skb, flow_hash_from_keys(&keys),
+ 			  flow_keys_have_l4(&keys));
+ 
+ 	return skb->hash;
+ }
+ EXPORT_SYMBOL(__skb_get_hash_flowi6);
+ 
+ __u32 __skb_get_hash_flowi4(struct sk_buff *skb, struct flowi4 *fl4)
+ {
+ 	struct flow_keys keys;
+ 
+ 	memset(&keys, 0, sizeof(keys));
+ 
+ 	keys.addrs.v4addrs.src = fl4->saddr;
+ 	keys.addrs.v4addrs.dst = fl4->daddr;
+ 	keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
+ 	keys.ports.src = fl4->fl4_sport;
+ 	keys.ports.dst = fl4->fl4_dport;
+ 	keys.keyid.keyid = fl4->fl4_gre_key;
+ 	keys.basic.ip_proto = fl4->flowi4_proto;
+ 
+ 	__skb_set_sw_hash(skb, flow_hash_from_keys(&keys),
+ 			  flow_keys_have_l4(&keys));
+ 
+ 	return skb->hash;
+ }
+ EXPORT_SYMBOL(__skb_get_hash_flowi4);
++>>>>>>> bcc83839ffdb (skbuff: Make __skb_set_sw_hash a general function)
  
  u32 __skb_get_poff(const struct sk_buff *skb, void *data,
  		   const struct flow_keys *keys, int hlen)
* Unmerged path include/net/flow_dissector.h
* Unmerged path include/linux/skbuff.h
* Unmerged path include/net/flow_dissector.h
* Unmerged path net/core/flow_dissector.c
