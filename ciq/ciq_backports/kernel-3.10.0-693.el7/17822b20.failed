pNFS: consolidate the different range intersection tests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 17822b207f3b66c3aa09d749d583ae63b3637f01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/17822b20.failed

Both pnfs.c and the flexfiles code have their own versions of the
range intersection testing, and the "end_offset" helper.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 17822b207f3b66c3aa09d749d583ae63b3637f01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pnfs.c
diff --cc fs/nfs/pnfs.c
index 1e52deed4cab,d70cc467a87b..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -470,35 -519,6 +461,38 @@@ pnfs_lseg_range_contained(const struct 
  	return (start1 <= start2) && (end1 >= end2);
  }
  
++<<<<<<< HEAD
 +/*
 + * is l1 and l2 intersecting?
 + *   start1                             end1
 + *   [----------------------------------)
 + *                              start2           end2
 + *                              [----------------)
 + */
 +static bool
 +pnfs_lseg_range_intersecting(const struct pnfs_layout_range *l1,
 +		    const struct pnfs_layout_range *l2)
 +{
 +	u64 start1 = l1->offset;
 +	u64 end1 = end_offset(start1, l1->length);
 +	u64 start2 = l2->offset;
 +	u64 end2 = end_offset(start2, l2->length);
 +
 +	return (end1 == NFS4_MAX_UINT64 || end1 > start2) &&
 +	       (end2 == NFS4_MAX_UINT64 || end2 > start1);
 +}
 +
 +static bool
 +should_free_lseg(const struct pnfs_layout_range *lseg_range,
 +		 const struct pnfs_layout_range *recall_range)
 +{
 +	return (recall_range->iomode == IOMODE_ANY ||
 +		lseg_range->iomode == recall_range->iomode) &&
 +	       pnfs_lseg_range_intersecting(lseg_range, recall_range);
 +}
 +
++=======
++>>>>>>> 17822b207f3b (pNFS: consolidate the different range intersection tests)
  static bool pnfs_lseg_dec_and_remove_zero(struct pnfs_layout_segment *lseg,
  		struct list_head *tmp_list)
  {
diff --git a/fs/nfs/flexfilelayout/flexfilelayoutdev.c b/fs/nfs/flexfilelayout/flexfilelayoutdev.c
index 5c7432f2d053..4c856b7ff1dd 100644
--- a/fs/nfs/flexfilelayout/flexfilelayoutdev.c
+++ b/fs/nfs/flexfilelayout/flexfilelayoutdev.c
@@ -220,22 +220,13 @@ outerr:
 	return false;
 }
 
-static u64
-end_offset(u64 start, u64 len)
-{
-	u64 end;
-
-	end = start + len;
-	return end >= start ? end : NFS4_MAX_UINT64;
-}
-
 static void extend_ds_error(struct nfs4_ff_layout_ds_err *err,
 			    u64 offset, u64 length)
 {
 	u64 end;
 
-	end = max_t(u64, end_offset(err->offset, err->length),
-		    end_offset(offset, length));
+	end = max_t(u64, pnfs_end_offset(err->offset, err->length),
+		    pnfs_end_offset(offset, length));
 	err->offset = min_t(u64, err->offset, offset);
 	err->length = end - err->offset;
 }
@@ -256,9 +247,9 @@ ff_ds_error_match(const struct nfs4_ff_layout_ds_err *e1,
 	ret = memcmp(&e1->deviceid, &e2->deviceid, sizeof(e1->deviceid));
 	if (ret != 0)
 		return ret;
-	if (end_offset(e1->offset, e1->length) < e2->offset)
+	if (pnfs_end_offset(e1->offset, e1->length) < e2->offset)
 		return -1;
-	if (e1->offset > end_offset(e2->offset, e2->length))
+	if (e1->offset > pnfs_end_offset(e2->offset, e2->length))
 		return 1;
 	/* If ranges overlap or are contiguous, they are the same */
 	return 0;
@@ -483,16 +474,6 @@ nfs4_ff_find_or_create_ds_client(struct pnfs_layout_segment *lseg, u32 ds_idx,
 	}
 }
 
-static bool is_range_intersecting(u64 offset1, u64 length1,
-				  u64 offset2, u64 length2)
-{
-	u64 end1 = end_offset(offset1, length1);
-	u64 end2 = end_offset(offset2, length2);
-
-	return (end1 == NFS4_MAX_UINT64 || end1 > offset2) &&
-	       (end2 == NFS4_MAX_UINT64 || end2 > offset1);
-}
-
 /* called with inode i_lock held */
 int ff_layout_encode_ds_ioerr(struct nfs4_flexfile_layout *flo,
 			      struct xdr_stream *xdr, int *count,
@@ -502,8 +483,10 @@ int ff_layout_encode_ds_ioerr(struct nfs4_flexfile_layout *flo,
 	__be32 *p;
 
 	list_for_each_entry_safe(err, n, &flo->error_list, list) {
-		if (!is_range_intersecting(err->offset, err->length,
-					   range->offset, range->length))
+		if (!pnfs_is_range_intersecting(err->offset,
+				pnfs_end_offset(err->offset, err->length),
+				range->offset,
+				pnfs_end_offset(range->offset, range->length)))
 			continue;
 		/* offset(8) + length(8) + stateid(NFS4_STATEID_SIZE)
 		 * + array length + deviceid(NFS4_DEVICEID4_SIZE)
* Unmerged path fs/nfs/pnfs.c
diff --git a/fs/nfs/pnfs.h b/fs/nfs/pnfs.h
index 6a045d2d2293..fad77c64c5dc 100644
--- a/fs/nfs/pnfs.h
+++ b/fs/nfs/pnfs.h
@@ -564,6 +564,38 @@ pnfs_copy_range(struct pnfs_layout_range *dst,
 	memcpy(dst, src, sizeof(*dst));
 }
 
+static inline u64
+pnfs_end_offset(u64 start, u64 len)
+{
+	if (NFS4_MAX_UINT64 - start <= len)
+		return NFS4_MAX_UINT64;
+	return start + len;
+}
+
+/*
+ * Are 2 ranges intersecting?
+ *   start1                             end1
+ *   [----------------------------------)
+ *                                start2           end2
+ *                                [----------------)
+ */
+static inline bool
+pnfs_is_range_intersecting(u64 start1, u64 end1, u64 start2, u64 end2)
+{
+	return (end1 == NFS4_MAX_UINT64 || start2 < end1) &&
+		(end2 == NFS4_MAX_UINT64 || start1 < end2);
+}
+
+static inline bool
+pnfs_lseg_range_intersecting(const struct pnfs_layout_range *l1,
+		const struct pnfs_layout_range *l2)
+{
+	u64 end1 = pnfs_end_offset(l1->offset, l1->length);
+	u64 end2 = pnfs_end_offset(l2->offset, l2->length);
+
+	return pnfs_is_range_intersecting(l1->offset, end1, l2->offset, end2);
+}
+
 extern unsigned int layoutstats_timer;
 
 #ifdef NFS_DEBUG
