net/mlx4_en: Fix the return value of mlx4_en_dcbnl_set_state()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx4_en: Fix the return value of mlx4_en_dcbnl_set_state() (Don Dutile) [1385329 1417284]
Rebuild_FUZZ: 96.67%
commit-author Kamal Heib <kamalh@mellanox.com>
commit c677071741343381f4f555867c04af7ec4a90869
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c6770717.failed

mlx4_en_dcbnl_set_state() returns u8, the return value from
mlx4_en_setup_tc() could be negative in case of failure, so fix that.

Fixes: af7d51852631 ("net/mlx4_en: Add DCB PFC support through CEE netlink commands")
	Signed-off-by: Kamal Heib <kamalh@mellanox.com>
	Signed-off-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c677071741343381f4f555867c04af7ec4a90869)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
diff --cc drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
index 9aacffd7b7f8,316a70714434..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
@@@ -80,6 -85,200 +80,203 @@@ struct mlx4_congestion_control_mb_prio_
  	__be32 reserved3[4];
  };
  
++<<<<<<< HEAD
++=======
+ static u8 mlx4_en_dcbnl_getcap(struct net_device *dev, int capid, u8 *cap)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 
+ 	switch (capid) {
+ 	case DCB_CAP_ATTR_PFC:
+ 		*cap = true;
+ 		break;
+ 	case DCB_CAP_ATTR_DCBX:
+ 		*cap = priv->cee_params.dcbx_cap;
+ 		break;
+ 	case DCB_CAP_ATTR_PFC_TCS:
+ 		*cap = 1 <<  mlx4_max_tc(priv->mdev->dev);
+ 		break;
+ 	default:
+ 		*cap = false;
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u8 mlx4_en_dcbnl_getpfcstate(struct net_device *netdev)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 
+ 	return priv->cee_params.dcb_cfg.pfc_state;
+ }
+ 
+ static void mlx4_en_dcbnl_setpfcstate(struct net_device *netdev, u8 state)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 
+ 	priv->cee_params.dcb_cfg.pfc_state = state;
+ }
+ 
+ static void mlx4_en_dcbnl_get_pfc_cfg(struct net_device *netdev, int priority,
+ 				      u8 *setting)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 
+ 	*setting = priv->cee_params.dcb_cfg.tc_config[priority].dcb_pfc;
+ }
+ 
+ static void mlx4_en_dcbnl_set_pfc_cfg(struct net_device *netdev, int priority,
+ 				      u8 setting)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 
+ 	priv->cee_params.dcb_cfg.tc_config[priority].dcb_pfc = setting;
+ 	priv->cee_params.dcb_cfg.pfc_state = true;
+ }
+ 
+ static int mlx4_en_dcbnl_getnumtcs(struct net_device *netdev, int tcid, u8 *num)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 
+ 	if (!(priv->flags & MLX4_EN_FLAG_DCB_ENABLED))
+ 		return -EINVAL;
+ 
+ 	if (tcid == DCB_NUMTCS_ATTR_PFC)
+ 		*num = mlx4_max_tc(priv->mdev->dev);
+ 	else
+ 		*num = 0;
+ 
+ 	return 0;
+ }
+ 
+ static u8 mlx4_en_dcbnl_set_all(struct net_device *netdev)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 	struct mlx4_en_dev *mdev = priv->mdev;
+ 	struct mlx4_en_cee_config *dcb_cfg = &priv->cee_params.dcb_cfg;
+ 
+ 	if (!(priv->cee_params.dcbx_cap & DCB_CAP_DCBX_VER_CEE))
+ 		return 1;
+ 
+ 	if (dcb_cfg->pfc_state) {
+ 		int tc;
+ 
+ 		priv->prof->rx_pause = 0;
+ 		priv->prof->tx_pause = 0;
+ 		for (tc = 0; tc < CEE_DCBX_MAX_PRIO; tc++) {
+ 			u8 tc_mask = 1 << tc;
+ 
+ 			switch (dcb_cfg->tc_config[tc].dcb_pfc) {
+ 			case pfc_disabled:
+ 				priv->prof->tx_ppp &= ~tc_mask;
+ 				priv->prof->rx_ppp &= ~tc_mask;
+ 				break;
+ 			case pfc_enabled_full:
+ 				priv->prof->tx_ppp |= tc_mask;
+ 				priv->prof->rx_ppp |= tc_mask;
+ 				break;
+ 			case pfc_enabled_tx:
+ 				priv->prof->tx_ppp |= tc_mask;
+ 				priv->prof->rx_ppp &= ~tc_mask;
+ 				break;
+ 			case pfc_enabled_rx:
+ 				priv->prof->tx_ppp &= ~tc_mask;
+ 				priv->prof->rx_ppp |= tc_mask;
+ 				break;
+ 			default:
+ 				break;
+ 			}
+ 		}
+ 		en_dbg(DRV, priv, "Set pfc on\n");
+ 	} else {
+ 		priv->prof->rx_pause = 1;
+ 		priv->prof->tx_pause = 1;
+ 		en_dbg(DRV, priv, "Set pfc off\n");
+ 	}
+ 
+ 	if (mlx4_SET_PORT_general(mdev->dev, priv->port,
+ 				  priv->rx_skb_size + ETH_FCS_LEN,
+ 				  priv->prof->tx_pause,
+ 				  priv->prof->tx_ppp,
+ 				  priv->prof->rx_pause,
+ 				  priv->prof->rx_ppp)) {
+ 		en_err(priv, "Failed setting pause params\n");
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u8 mlx4_en_dcbnl_get_state(struct net_device *dev)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 
+ 	if (priv->flags & MLX4_EN_FLAG_DCB_ENABLED)
+ 		return MLX4_CEE_STATE_UP;
+ 
+ 	return MLX4_CEE_STATE_DOWN;
+ }
+ 
+ static u8 mlx4_en_dcbnl_set_state(struct net_device *dev, u8 state)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 	int num_tcs = 0;
+ 
+ 	if (!(priv->cee_params.dcbx_cap & DCB_CAP_DCBX_VER_CEE))
+ 		return 1;
+ 
+ 	if (!!(state) == !!(priv->flags & MLX4_EN_FLAG_DCB_ENABLED))
+ 		return 0;
+ 
+ 	if (state) {
+ 		priv->flags |= MLX4_EN_FLAG_DCB_ENABLED;
+ 		num_tcs = IEEE_8021QAZ_MAX_TCS;
+ 	} else {
+ 		priv->flags &= ~MLX4_EN_FLAG_DCB_ENABLED;
+ 	}
+ 
+ 	if (mlx4_en_setup_tc(dev, num_tcs))
+ 		return 1;
+ 
+ 	return 0;
+ }
+ 
+ /* On success returns a non-zero 802.1p user priority bitmap
+  * otherwise returns 0 as the invalid user priority bitmap to
+  * indicate an error.
+  */
+ static int mlx4_en_dcbnl_getapp(struct net_device *netdev, u8 idtype, u16 id)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 	struct dcb_app app = {
+ 				.selector = idtype,
+ 				.protocol = id,
+ 			     };
+ 	if (!(priv->cee_params.dcbx_cap & DCB_CAP_DCBX_VER_CEE))
+ 		return 0;
+ 
+ 	return dcb_getapp(netdev, &app);
+ }
+ 
+ static int mlx4_en_dcbnl_setapp(struct net_device *netdev, u8 idtype,
+ 				u16 id, u8 up)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(netdev);
+ 	struct dcb_app app;
+ 
+ 	if (!(priv->cee_params.dcbx_cap & DCB_CAP_DCBX_VER_CEE))
+ 		return -EINVAL;
+ 
+ 	memset(&app, 0, sizeof(struct dcb_app));
+ 	app.selector = idtype;
+ 	app.protocol = id;
+ 	app.priority = up;
+ 
+ 	return dcb_setapp(netdev, &app);
+ }
+ 
++>>>>>>> c67707174134 (net/mlx4_en: Fix the return value of mlx4_en_dcbnl_set_state())
  static int mlx4_en_dcbnl_ieee_getets(struct net_device *dev,
  				   struct ieee_ets *ets)
  {
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_dcb_nl.c
