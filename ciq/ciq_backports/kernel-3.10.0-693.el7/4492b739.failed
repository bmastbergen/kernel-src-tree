scsi: lpfc: Fix panic on BFS configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] lpfc: Fix panic on BFS configuration (Maurizio Lombardi) [1443116]
Rebuild_FUZZ: 92.31%
commit-author James Smart <jsmart2021@gmail.com>
commit 4492b739c9ccfaf828bd7c02dc779ec2a5e55ff4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4492b739.failed

To select the appropriate shost template, the driver is issuing a
mailbox command to retrieve the wwn. Turns out the sending of the
command precedes the reset of the function.  On SLI-4 adapters, this is
inconsequential as the mailbox command location is specified by dma via
the BMBX register. However, on SLI-3 adapters, the location of the
mailbox command submission area changes. When the function is first
powered on or reset, the cmd is submitted via PCI bar memory. Later the
driver changes the function config to use host memory and DMA. The
request to start a mailbox command is the same, a simple doorbell write,
regardless of submission area.  So.. if there has not been a boot driver
run against the adapter, the mailbox command works as defaults are
ok. But, if the boot driver has configured the card and, and if no
platform pci function/slot reset occurs as the os starts, the mailbox
command will fail. The SLI-3 device will use the stale boot driver dma
location. This can cause PCI eeh errors.

Fix is to reset the sli-3 function before sending the mailbox command,
thus synchronizing the function/driver on mailbox location.

Note: The fix uses routines that are typically invoked later in the call
flow to reset the sli-3 device. The issue in using those routines is
that the normal (non-fix) flow does additional initialization, namely
the allocation of the pport structure. So, rather than significantly
reworking the initialization flow so that the pport is alloc'd first,
pointer checks are added to work around it. Checks are limited to the
routines invoked by a sli-3 adapter (s3 routines) as this fix/early call
is only invoked on a sli3 adapter. Nothing changes post the
fix. Subsequent initialization, and another adapter reset, still occur -
both on sli-3 and sli-4 adapters.

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
Fixes: 96418b5e2c88 ("scsi: lpfc: Fix eh_deadline setting for sli3 adapters.")
	Cc: stable@vger.kernel.org # v4.11+
	Reviewed-by: Ewan D. Milne <emilne@redhat.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 4492b739c9ccfaf828bd7c02dc779ec2a5e55ff4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_init.c
diff --cc drivers/scsi/lpfc/lpfc_init.c
index bbd4080d8122,e85f273e34ac..000000000000
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@@ -3324,6 -3594,150 +3324,153 @@@ out_free_mem
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static uint64_t
+ lpfc_get_wwpn(struct lpfc_hba *phba)
+ {
+ 	uint64_t wwn;
+ 	int rc;
+ 	LPFC_MBOXQ_t *mboxq;
+ 	MAILBOX_t *mb;
+ 
+ 	if (phba->sli_rev < LPFC_SLI_REV4) {
+ 		/* Reset the port first */
+ 		lpfc_sli_brdrestart(phba);
+ 		rc = lpfc_sli_chipset_init(phba);
+ 		if (rc)
+ 			return (uint64_t)-1;
+ 	}
+ 
+ 	mboxq = (LPFC_MBOXQ_t *) mempool_alloc(phba->mbox_mem_pool,
+ 						GFP_KERNEL);
+ 	if (!mboxq)
+ 		return (uint64_t)-1;
+ 
+ 	/* First get WWN of HBA instance */
+ 	lpfc_read_nv(phba, mboxq);
+ 	rc = lpfc_sli_issue_mbox(phba, mboxq, MBX_POLL);
+ 	if (rc != MBX_SUCCESS) {
+ 		lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
+ 				"6019 Mailbox failed , mbxCmd x%x "
+ 				"READ_NV, mbxStatus x%x\n",
+ 				bf_get(lpfc_mqe_command, &mboxq->u.mqe),
+ 				bf_get(lpfc_mqe_status, &mboxq->u.mqe));
+ 		mempool_free(mboxq, phba->mbox_mem_pool);
+ 		return (uint64_t) -1;
+ 	}
+ 	mb = &mboxq->u.mb;
+ 	memcpy(&wwn, (char *)mb->un.varRDnvp.portname, sizeof(uint64_t));
+ 	/* wwn is WWPN of HBA instance */
+ 	mempool_free(mboxq, phba->mbox_mem_pool);
+ 	if (phba->sli_rev == LPFC_SLI_REV4)
+ 		return be64_to_cpu(wwn);
+ 	else
+ 		return (((wwn & 0xffffffff00000000) >> 32) |
+ 			((wwn & 0x00000000ffffffff) << 32));
+ 
+ }
+ 
+ /**
+  * lpfc_sli4_nvme_sgl_update - update xri-sgl sizing and mapping
+  * @phba: pointer to lpfc hba data structure.
+  *
+  * This routine first calculates the sizes of the current els and allocated
+  * scsi sgl lists, and then goes through all sgls to updates the physical
+  * XRIs assigned due to port function reset. During port initialization, the
+  * current els and allocated scsi sgl lists are 0s.
+  *
+  * Return codes
+  *   0 - successful (for now, it always returns 0)
+  **/
+ int
+ lpfc_sli4_nvme_sgl_update(struct lpfc_hba *phba)
+ {
+ 	struct lpfc_nvme_buf *lpfc_ncmd = NULL, *lpfc_ncmd_next = NULL;
+ 	uint16_t i, lxri, els_xri_cnt;
+ 	uint16_t nvme_xri_cnt, nvme_xri_max;
+ 	LIST_HEAD(nvme_sgl_list);
+ 	int rc;
+ 
+ 	phba->total_nvme_bufs = 0;
+ 
+ 	if (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME))
+ 		return 0;
+ 	/*
+ 	 * update on pci function's allocated nvme xri-sgl list
+ 	 */
+ 
+ 	/* maximum number of xris available for nvme buffers */
+ 	els_xri_cnt = lpfc_sli4_get_els_iocb_cnt(phba);
+ 	nvme_xri_max = phba->sli4_hba.max_cfg_param.max_xri - els_xri_cnt;
+ 	phba->sli4_hba.nvme_xri_max = nvme_xri_max;
+ 	phba->sli4_hba.nvme_xri_max -= phba->sli4_hba.scsi_xri_max;
+ 
+ 	lpfc_printf_log(phba, KERN_INFO, LOG_SLI,
+ 			"6074 Current allocated NVME xri-sgl count:%d, "
+ 			"maximum  NVME xri count:%d\n",
+ 			phba->sli4_hba.nvme_xri_cnt,
+ 			phba->sli4_hba.nvme_xri_max);
+ 
+ 	spin_lock_irq(&phba->nvme_buf_list_get_lock);
+ 	spin_lock(&phba->nvme_buf_list_put_lock);
+ 	list_splice_init(&phba->lpfc_nvme_buf_list_get, &nvme_sgl_list);
+ 	list_splice(&phba->lpfc_nvme_buf_list_put, &nvme_sgl_list);
+ 	spin_unlock(&phba->nvme_buf_list_put_lock);
+ 	spin_unlock_irq(&phba->nvme_buf_list_get_lock);
+ 
+ 	if (phba->sli4_hba.nvme_xri_cnt > phba->sli4_hba.nvme_xri_max) {
+ 		/* max nvme xri shrunk below the allocated nvme buffers */
+ 		spin_lock_irq(&phba->nvme_buf_list_get_lock);
+ 		nvme_xri_cnt = phba->sli4_hba.nvme_xri_cnt -
+ 					phba->sli4_hba.nvme_xri_max;
+ 		spin_unlock_irq(&phba->nvme_buf_list_get_lock);
+ 		/* release the extra allocated nvme buffers */
+ 		for (i = 0; i < nvme_xri_cnt; i++) {
+ 			list_remove_head(&nvme_sgl_list, lpfc_ncmd,
+ 					 struct lpfc_nvme_buf, list);
+ 			if (lpfc_ncmd) {
+ 				pci_pool_free(phba->lpfc_sg_dma_buf_pool,
+ 					      lpfc_ncmd->data,
+ 					      lpfc_ncmd->dma_handle);
+ 				kfree(lpfc_ncmd);
+ 			}
+ 		}
+ 		spin_lock_irq(&phba->nvme_buf_list_get_lock);
+ 		phba->sli4_hba.nvme_xri_cnt -= nvme_xri_cnt;
+ 		spin_unlock_irq(&phba->nvme_buf_list_get_lock);
+ 	}
+ 
+ 	/* update xris associated to remaining allocated nvme buffers */
+ 	lpfc_ncmd = NULL;
+ 	lpfc_ncmd_next = NULL;
+ 	list_for_each_entry_safe(lpfc_ncmd, lpfc_ncmd_next,
+ 				 &nvme_sgl_list, list) {
+ 		lxri = lpfc_sli4_next_xritag(phba);
+ 		if (lxri == NO_XRI) {
+ 			lpfc_printf_log(phba, KERN_ERR, LOG_SLI,
+ 					"6075 Failed to allocate xri for "
+ 					"nvme buffer\n");
+ 			rc = -ENOMEM;
+ 			goto out_free_mem;
+ 		}
+ 		lpfc_ncmd->cur_iocbq.sli4_lxritag = lxri;
+ 		lpfc_ncmd->cur_iocbq.sli4_xritag = phba->sli4_hba.xri_ids[lxri];
+ 	}
+ 	spin_lock_irq(&phba->nvme_buf_list_get_lock);
+ 	spin_lock(&phba->nvme_buf_list_put_lock);
+ 	list_splice_init(&nvme_sgl_list, &phba->lpfc_nvme_buf_list_get);
+ 	INIT_LIST_HEAD(&phba->lpfc_nvme_buf_list_put);
+ 	spin_unlock(&phba->nvme_buf_list_put_lock);
+ 	spin_unlock_irq(&phba->nvme_buf_list_get_lock);
+ 	return 0;
+ 
+ out_free_mem:
+ 	lpfc_nvme_free(phba);
+ 	return rc;
+ }
+ 
++>>>>>>> 4492b739c9cc (scsi: lpfc: Fix panic on BFS configuration)
  /**
   * lpfc_create_port - Create an FC port
   * @phba: pointer to lpfc hba data structure.
diff --git a/drivers/scsi/lpfc/lpfc_crtn.h b/drivers/scsi/lpfc/lpfc_crtn.h
index 5d7cb958427c..5849879714c1 100644
--- a/drivers/scsi/lpfc/lpfc_crtn.h
+++ b/drivers/scsi/lpfc/lpfc_crtn.h
@@ -270,6 +270,7 @@ int lpfc_selective_reset(struct lpfc_hba *);
 void lpfc_reset_barrier(struct lpfc_hba *);
 int lpfc_sli_brdready(struct lpfc_hba *, uint32_t);
 int lpfc_sli_brdkill(struct lpfc_hba *);
+int lpfc_sli_chipset_init(struct lpfc_hba *phba);
 int lpfc_sli_brdreset(struct lpfc_hba *);
 int lpfc_sli_brdrestart(struct lpfc_hba *);
 int lpfc_sli_hba_setup(struct lpfc_hba *);
* Unmerged path drivers/scsi/lpfc/lpfc_init.c
diff --git a/drivers/scsi/lpfc/lpfc_sli.c b/drivers/scsi/lpfc/lpfc_sli.c
index c1522c6b2e42..17fcee8b9b69 100644
--- a/drivers/scsi/lpfc/lpfc_sli.c
+++ b/drivers/scsi/lpfc/lpfc_sli.c
@@ -4013,13 +4013,16 @@ lpfc_sli_brdreset(struct lpfc_hba *phba)
 	/* Reset HBA */
 	lpfc_printf_log(phba, KERN_INFO, LOG_SLI,
 			"0325 Reset HBA Data: x%x x%x\n",
-			phba->pport->port_state, psli->sli_flag);
+			(phba->pport) ? phba->pport->port_state : 0,
+			psli->sli_flag);
 
 	/* perform board reset */
 	phba->fc_eventTag = 0;
 	phba->link_events = 0;
-	phba->pport->fc_myDID = 0;
-	phba->pport->fc_prevDID = 0;
+	if (phba->pport) {
+		phba->pport->fc_myDID = 0;
+		phba->pport->fc_prevDID = 0;
+	}
 
 	/* Turn off parity checking and serr during the physical reset */
 	pci_read_config_word(phba->pcidev, PCI_COMMAND, &cfg_value);
@@ -4145,7 +4148,8 @@ lpfc_sli_brdrestart_s3(struct lpfc_hba *phba)
 	/* Restart HBA */
 	lpfc_printf_log(phba, KERN_INFO, LOG_SLI,
 			"0337 Restart HBA Data: x%x x%x\n",
-			phba->pport->port_state, psli->sli_flag);
+			(phba->pport) ? phba->pport->port_state : 0,
+			psli->sli_flag);
 
 	word0 = 0;
 	mb = (MAILBOX_t *) &word0;
@@ -4159,7 +4163,7 @@ lpfc_sli_brdrestart_s3(struct lpfc_hba *phba)
 	readl(to_slim); /* flush */
 
 	/* Only skip post after fc_ffinit is completed */
-	if (phba->pport->port_state)
+	if (phba->pport && phba->pport->port_state)
 		word0 = 1;	/* This is really setting up word1 */
 	else
 		word0 = 0;	/* This is really setting up word1 */
@@ -4168,7 +4172,8 @@ lpfc_sli_brdrestart_s3(struct lpfc_hba *phba)
 	readl(to_slim); /* flush */
 
 	lpfc_sli_brdreset(phba);
-	phba->pport->stopped = 0;
+	if (phba->pport)
+		phba->pport->stopped = 0;
 	phba->link_state = LPFC_INIT_START;
 	phba->hba_flag = 0;
 	spin_unlock_irq(&phba->hbalock);
@@ -4255,7 +4260,7 @@ lpfc_sli_brdrestart(struct lpfc_hba *phba)
  * iteration, the function will restart the HBA again. The function returns
  * zero if HBA successfully restarted else returns negative error code.
  **/
-static int
+int
 lpfc_sli_chipset_init(struct lpfc_hba *phba)
 {
 	uint32_t status, i = 0;
