mntns: Add a limit on the number of mount namespaces.

jira LE-1907
cve CVE-2016-6213
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [kernel] mntns: Add a limit on the number of mount namespaces ("Eric W. Biederman") [1340238 1322495] {CVE-2016-6213}
Rebuild_FUZZ: 99.05%
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 537f7ccb396804c6d0057b93ba8eb104ba44f851
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/537f7ccb.failed

v2: Fixed the very obvious lack of setting ucounts
    on struct mnt_ns reported by Andrei Vagin, and the kbuild
    test report.

	Reported-by: Andrei Vagin <avagin@openvz.org>
	Acked-by: Kees Cook <keescook@chromium.org>
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 537f7ccb396804c6d0057b93ba8eb104ba44f851)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
#	include/linux/user_namespace.h
#	kernel/ucount.c
diff --cc fs/namespace.c
index 5bfed5a73a95,491b8f3e4c9a..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -2440,9 -2719,20 +2440,24 @@@ dput_out
  	return retval;
  }
  
+ static struct ucounts *inc_mnt_namespaces(struct user_namespace *ns)
+ {
+ 	return inc_ucount(ns, current_euid(), UCOUNT_MNT_NAMESPACES);
+ }
+ 
+ static void dec_mnt_namespaces(struct ucounts *ucounts)
+ {
+ 	dec_ucount(ucounts, UCOUNT_MNT_NAMESPACES);
+ }
+ 
  static void free_mnt_ns(struct mnt_namespace *ns)
  {
++<<<<<<< HEAD
 +	proc_free_inum(ns->proc_inum);
++=======
+ 	ns_free_inum(&ns->ns);
+ 	dec_mnt_namespaces(ns->ucounts);
++>>>>>>> 537f7ccb3968 (mntns: Add a limit on the number of mount namespaces.)
  	put_user_ns(ns->user_ns);
  	kfree(ns);
  }
@@@ -2459,16 -2749,25 +2474,28 @@@ static atomic64_t mnt_ns_seq = ATOMIC64
  static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)
  {
  	struct mnt_namespace *new_ns;
+ 	struct ucounts *ucounts;
  	int ret;
  
+ 	ucounts = inc_mnt_namespaces(user_ns);
+ 	if (!ucounts)
+ 		return ERR_PTR(-ENFILE);
+ 
  	new_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);
- 	if (!new_ns)
+ 	if (!new_ns) {
+ 		dec_mnt_namespaces(ucounts);
  		return ERR_PTR(-ENOMEM);
++<<<<<<< HEAD
 +	ret = proc_alloc_inum(&new_ns->proc_inum);
++=======
+ 	}
+ 	ret = ns_alloc_inum(&new_ns->ns);
++>>>>>>> 537f7ccb3968 (mntns: Add a limit on the number of mount namespaces.)
  	if (ret) {
  		kfree(new_ns);
+ 		dec_mnt_namespaces(ucounts);
  		return ERR_PTR(ret);
  	}
 -	new_ns->ns.ops = &mntns_operations;
  	new_ns->seq = atomic64_add_return(1, &mnt_ns_seq);
  	atomic_set(&new_ns->count, 1);
  	new_ns->root = NULL;
diff --cc include/linux/user_namespace.h
index 9b176275291d,30ffe10cda18..000000000000
--- a/include/linux/user_namespace.h
+++ b/include/linux/user_namespace.h
@@@ -22,6 -22,19 +22,22 @@@ struct uid_gid_map {	/* 64 bytes -- 1 c
  
  #define USERNS_INIT_FLAGS USERNS_SETGROUPS_ALLOWED
  
++<<<<<<< HEAD
++=======
+ struct ucounts;
+ 
+ enum ucount_type {
+ 	UCOUNT_USER_NAMESPACES,
+ 	UCOUNT_PID_NAMESPACES,
+ 	UCOUNT_UTS_NAMESPACES,
+ 	UCOUNT_IPC_NAMESPACES,
+ 	UCOUNT_NET_NAMESPACES,
+ 	UCOUNT_MNT_NAMESPACES,
+ 	UCOUNT_CGROUP_NAMESPACES,
+ 	UCOUNT_COUNTS,
+ };
+ 
++>>>>>>> 537f7ccb3968 (mntns: Add a limit on the number of mount namespaces.)
  struct user_namespace {
  	struct uid_gid_map	uid_map;
  	struct uid_gid_map	gid_map;
* Unmerged path kernel/ucount.c
diff --git a/fs/mount.h b/fs/mount.h
index e343bfffd887..7f4032babcf6 100644
--- a/fs/mount.h
+++ b/fs/mount.h
@@ -8,6 +8,7 @@ struct mnt_namespace {
 	struct mount *	root;
 	struct list_head	list;
 	struct user_namespace	*user_ns;
+	struct ucounts		*ucounts;
 	u64			seq;	/* Sequence number to prevent loops */
 	wait_queue_head_t poll;
 	u64 event;
* Unmerged path fs/namespace.c
* Unmerged path include/linux/user_namespace.h
* Unmerged path kernel/ucount.c
