scsi: be2iscsi: Move functions to right files

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] be2iscsi: Move functions to right files (Maurizio Lombardi) [1382263]
Rebuild_FUZZ: 92.86%
commit-author Jitendra Bhivare <jitendra.bhivare@broadcom.com>
commit 480195c267a4c9f9fcb490897278a41940759b4f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/480195c2.failed

beiscsi_fail_session is defined in be_cmds.c: move it to be_iscsi.c
Move card configuration commands to be_cmds.c.

	Signed-off-by: Jitendra Bhivare <jitendra.bhivare@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 480195c267a4c9f9fcb490897278a41940759b4f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/be2iscsi/be_cmds.c
#	drivers/scsi/be2iscsi/be_cmds.h
#	drivers/scsi/be2iscsi/be_mgmt.h
diff --cc drivers/scsi/be2iscsi/be_cmds.c
index 403296239ae9,1ebb6ce12742..000000000000
--- a/drivers/scsi/be2iscsi/be_cmds.c
+++ b/drivers/scsi/be2iscsi/be_cmds.c
@@@ -118,15 -119,70 +118,6 @@@ void free_mcc_wrb(struct be_ctrl_info *
  	spin_unlock(&ctrl->mcc_lock);
  }
  
- /**
-  * beiscsi_fail_session(): Closing session with appropriate error
-  * @cls_session: ptr to session
-  **/
- void beiscsi_fail_session(struct iscsi_cls_session *cls_session)
 -/*
 - * beiscsi_mcc_compl_status - Return the status of MCC completion
 - * @phba: Driver private structure
 - * @tag: Tag for the MBX Command
 - * @wrb: the WRB used for the MBX Command
 - * @mbx_cmd_mem: ptr to memory allocated for MBX Cmd
 - *
 - * return
 - * Success: 0
 - * Failure: Non-Zero
 - */
 -int __beiscsi_mcc_compl_status(struct beiscsi_hba *phba,
 -			       unsigned int tag,
 -			       struct be_mcc_wrb **wrb,
 -			       struct be_dma_mem *mbx_cmd_mem)
--{
- 	iscsi_session_failure(cls_session->dd_data, ISCSI_ERR_CONN_FAILED);
 -	struct be_queue_info *mccq = &phba->ctrl.mcc_obj.q;
 -	uint16_t status = 0, addl_status = 0, wrb_num = 0;
 -	struct be_cmd_resp_hdr *mbx_resp_hdr;
 -	struct be_cmd_req_hdr *mbx_hdr;
 -	struct be_mcc_wrb *temp_wrb;
 -	uint32_t mcc_tag_status;
 -	int rc = 0;
 -
 -	mcc_tag_status = phba->ctrl.mcc_tag_status[tag];
 -	status = (mcc_tag_status & CQE_STATUS_MASK);
 -	addl_status = ((mcc_tag_status & CQE_STATUS_ADDL_MASK) >>
 -			CQE_STATUS_ADDL_SHIFT);
 -
 -	if (mbx_cmd_mem) {
 -		mbx_hdr = (struct be_cmd_req_hdr *)mbx_cmd_mem->va;
 -	} else {
 -		wrb_num = (mcc_tag_status & CQE_STATUS_WRB_MASK) >>
 -			  CQE_STATUS_WRB_SHIFT;
 -		temp_wrb = (struct be_mcc_wrb *)queue_get_wrb(mccq, wrb_num);
 -		mbx_hdr = embedded_payload(temp_wrb);
 -
 -		if (wrb)
 -			*wrb = temp_wrb;
 -	}
 -
 -	if (status || addl_status) {
 -		beiscsi_log(phba, KERN_WARNING,
 -			    BEISCSI_LOG_INIT | BEISCSI_LOG_EH |
 -			    BEISCSI_LOG_CONFIG,
 -			    "BC_%d : MBX Cmd Failed for Subsys : %d Opcode : %d with Status : %d and Extd_Status : %d\n",
 -			    mbx_hdr->subsystem, mbx_hdr->opcode,
 -			    status, addl_status);
 -		rc = -EIO;
 -		if (status == MCC_STATUS_INSUFFICIENT_BUFFER) {
 -			mbx_resp_hdr = (struct be_cmd_resp_hdr *)mbx_hdr;
 -			beiscsi_log(phba, KERN_WARNING,
 -				    BEISCSI_LOG_INIT | BEISCSI_LOG_EH |
 -				    BEISCSI_LOG_CONFIG,
 -				    "BC_%d : Insufficient Buffer Error Resp_Len : %d Actual_Resp_Len : %d\n",
 -				    mbx_resp_hdr->response_length,
 -				    mbx_resp_hdr->actual_resp_len);
 -			rc = -EAGAIN;
 -		}
 -	}
 -
 -	return rc;
--}
--
  /*
   * beiscsi_mccq_compl_wait()- Process completion in MCC CQ
   * @phba: Driver private structure
@@@ -1327,3 -1352,304 +1318,307 @@@ int be_cmd_set_vlan(struct beiscsi_hba 
  
  	return tag;
  }
++<<<<<<< HEAD
++=======
+ 
+ int beiscsi_check_supported_fw(struct be_ctrl_info *ctrl,
+ 			       struct beiscsi_hba *phba)
+ {
+ 	struct be_dma_mem nonemb_cmd;
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct be_mgmt_controller_attributes *req;
+ 	struct be_sge *sge = nonembedded_sgl(wrb);
+ 	int status = 0;
+ 
+ 	nonemb_cmd.va = pci_alloc_consistent(ctrl->pdev,
+ 				sizeof(struct be_mgmt_controller_attributes),
+ 				&nonemb_cmd.dma);
+ 	if (nonemb_cmd.va == NULL) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : pci_alloc_consistent failed in %s\n",
+ 			    __func__);
+ 		return -ENOMEM;
+ 	}
+ 	nonemb_cmd.size = sizeof(struct be_mgmt_controller_attributes);
+ 	req = nonemb_cmd.va;
+ 	memset(req, 0, sizeof(*req));
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	be_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);
+ 	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_GET_CNTL_ATTRIBUTES, sizeof(*req));
+ 	sge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd.dma));
+ 	sge->pa_lo = cpu_to_le32(nonemb_cmd.dma & 0xFFFFFFFF);
+ 	sge->len = cpu_to_le32(nonemb_cmd.size);
+ 	status = be_mbox_notify(ctrl);
+ 	if (!status) {
+ 		struct be_mgmt_controller_attributes_resp *resp = nonemb_cmd.va;
+ 
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : Firmware Version of CMD : %s\n"
+ 			    "Firmware Version is : %s\n"
+ 			    "Developer Build, not performing version check...\n",
+ 			    resp->params.hba_attribs
+ 			    .flashrom_version_string,
+ 			    resp->params.hba_attribs.
+ 			    firmware_version_string);
+ 
+ 		phba->fw_config.iscsi_features =
+ 				resp->params.hba_attribs.iscsi_features;
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BM_%d : phba->fw_config.iscsi_features = %d\n",
+ 			    phba->fw_config.iscsi_features);
+ 		memcpy(phba->fw_ver_str, resp->params.hba_attribs.
+ 		       firmware_version_string, BEISCSI_VER_STRLEN);
+ 	} else
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d :  Failed in beiscsi_check_supported_fw\n");
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	if (nonemb_cmd.va)
+ 		pci_free_consistent(ctrl->pdev, nonemb_cmd.size,
+ 				    nonemb_cmd.va, nonemb_cmd.dma);
+ 
+ 	return status;
+ }
+ 
+ /**
+  * beiscsi_get_fw_config()- Get the FW config for the function
+  * @ctrl: ptr to Ctrl Info
+  * @phba: ptr to the dev priv structure
+  *
+  * Get the FW config and resources available for the function.
+  * The resources are created based on the count received here.
+  *
+  * return
+  *	Success: 0
+  *	Failure: Non-Zero Value
+  **/
+ int beiscsi_get_fw_config(struct be_ctrl_info *ctrl,
+ 			  struct beiscsi_hba *phba)
+ {
+ 	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	struct be_fw_cfg *pfw_cfg = embedded_payload(wrb);
+ 	uint32_t cid_count, icd_count;
+ 	int status = -EINVAL;
+ 	uint8_t ulp_num = 0;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	be_wrb_hdr_prepare(wrb, sizeof(*pfw_cfg), true, 0);
+ 
+ 	be_cmd_hdr_prepare(&pfw_cfg->hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_QUERY_FIRMWARE_CONFIG,
+ 			   EMBED_MBX_MAX_PAYLOAD_SIZE);
+ 
+ 	if (be_mbox_notify(ctrl)) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : Failed in beiscsi_get_fw_config\n");
+ 		goto fail_init;
+ 	}
+ 
+ 	/* FW response formats depend on port id */
+ 	phba->fw_config.phys_port = pfw_cfg->phys_port;
+ 	if (phba->fw_config.phys_port >= BEISCSI_PHYS_PORT_MAX) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : invalid physical port id %d\n",
+ 			    phba->fw_config.phys_port);
+ 		goto fail_init;
+ 	}
+ 
+ 	/* populate and check FW config against min and max values */
+ 	if (!is_chip_be2_be3r(phba)) {
+ 		phba->fw_config.eqid_count = pfw_cfg->eqid_count;
+ 		phba->fw_config.cqid_count = pfw_cfg->cqid_count;
+ 		if (phba->fw_config.eqid_count == 0 ||
+ 		    phba->fw_config.eqid_count > 2048) {
+ 			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 				    "BG_%d : invalid EQ count %d\n",
+ 				    phba->fw_config.eqid_count);
+ 			goto fail_init;
+ 		}
+ 		if (phba->fw_config.cqid_count == 0 ||
+ 		    phba->fw_config.cqid_count > 4096) {
+ 			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 				    "BG_%d : invalid CQ count %d\n",
+ 				    phba->fw_config.cqid_count);
+ 			goto fail_init;
+ 		}
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : EQ_Count : %d CQ_Count : %d\n",
+ 			    phba->fw_config.eqid_count,
+ 			    phba->fw_config.cqid_count);
+ 	}
+ 
+ 	/**
+ 	 * Check on which all ULP iSCSI Protocol is loaded.
+ 	 * Set the Bit for those ULP. This set flag is used
+ 	 * at all places in the code to check on which ULP
+ 	 * iSCSi Protocol is loaded
+ 	 **/
+ 	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {
+ 		if (pfw_cfg->ulp[ulp_num].ulp_mode &
+ 		    BEISCSI_ULP_ISCSI_INI_MODE) {
+ 			set_bit(ulp_num, &phba->fw_config.ulp_supported);
+ 
+ 			/* Get the CID, ICD and Chain count for each ULP */
+ 			phba->fw_config.iscsi_cid_start[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].sq_base;
+ 			phba->fw_config.iscsi_cid_count[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].sq_count;
+ 
+ 			phba->fw_config.iscsi_icd_start[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].icd_base;
+ 			phba->fw_config.iscsi_icd_count[ulp_num] =
+ 				pfw_cfg->ulp[ulp_num].icd_count;
+ 
+ 			phba->fw_config.iscsi_chain_start[ulp_num] =
+ 				pfw_cfg->chain_icd[ulp_num].chain_base;
+ 			phba->fw_config.iscsi_chain_count[ulp_num] =
+ 				pfw_cfg->chain_icd[ulp_num].chain_count;
+ 
+ 			beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 				    "BG_%d : Function loaded on ULP : %d\n"
+ 				    "\tiscsi_cid_count : %d\n"
+ 				    "\tiscsi_cid_start : %d\n"
+ 				    "\t iscsi_icd_count : %d\n"
+ 				    "\t iscsi_icd_start : %d\n",
+ 				    ulp_num,
+ 				    phba->fw_config.
+ 				    iscsi_cid_count[ulp_num],
+ 				    phba->fw_config.
+ 				    iscsi_cid_start[ulp_num],
+ 				    phba->fw_config.
+ 				    iscsi_icd_count[ulp_num],
+ 				    phba->fw_config.
+ 				    iscsi_icd_start[ulp_num]);
+ 		}
+ 	}
+ 
+ 	if (phba->fw_config.ulp_supported == 0) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d : iSCSI initiator mode not set: ULP0 %x ULP1 %x\n",
+ 			    pfw_cfg->ulp[BEISCSI_ULP0].ulp_mode,
+ 			    pfw_cfg->ulp[BEISCSI_ULP1].ulp_mode);
+ 		goto fail_init;
+ 	}
+ 
+ 	/**
+ 	 * ICD is shared among ULPs. Use icd_count of any one loaded ULP
+ 	 **/
+ 	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)
+ 		if (test_bit(ulp_num, &phba->fw_config.ulp_supported))
+ 			break;
+ 	icd_count = phba->fw_config.iscsi_icd_count[ulp_num];
+ 	if (icd_count == 0 || icd_count > 65536) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d: invalid ICD count %d\n", icd_count);
+ 		goto fail_init;
+ 	}
+ 
+ 	cid_count = BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP0) +
+ 		    BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP1);
+ 	if (cid_count == 0 || cid_count > 4096) {
+ 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
+ 			    "BG_%d: invalid CID count %d\n", cid_count);
+ 		goto fail_init;
+ 	}
+ 
+ 	/**
+ 	 * Check FW is dual ULP aware i.e. can handle either
+ 	 * of the protocols.
+ 	 */
+ 	phba->fw_config.dual_ulp_aware = (pfw_cfg->function_mode &
+ 					  BEISCSI_FUNC_DUA_MODE);
+ 
+ 	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 		    "BG_%d : DUA Mode : 0x%x\n",
+ 		    phba->fw_config.dual_ulp_aware);
+ 
+ 	/* all set, continue using this FW config */
+ 	status = 0;
+ fail_init:
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return status;
+ }
+ 
+ /**
+  * beiscsi_get_port_name()- Get port name for the function
+  * @ctrl: ptr to Ctrl Info
+  * @phba: ptr to the dev priv structure
+  *
+  * Get the alphanumeric character for port
+  *
+  **/
+ int beiscsi_get_port_name(struct be_ctrl_info *ctrl, struct beiscsi_hba *phba)
+ {
+ 	int ret = 0;
+ 	struct be_mcc_wrb *wrb;
+ 	struct be_cmd_get_port_name *ioctl;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	ioctl = embedded_payload(wrb);
+ 
+ 	be_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);
+ 	be_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_GET_PORT_NAME,
+ 			   EMBED_MBX_MAX_PAYLOAD_SIZE);
+ 	ret = be_mbox_notify(ctrl);
+ 	phba->port_name = 0;
+ 	if (!ret) {
+ 		phba->port_name = ioctl->p.resp.port_names >>
+ 				  (phba->fw_config.phys_port * 8) & 0xff;
+ 	} else {
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : GET_PORT_NAME ret 0x%x status 0x%x\n",
+ 			    ret, ioctl->h.resp_hdr.status);
+ 	}
+ 
+ 	if (phba->port_name == 0)
+ 		phba->port_name = '?';
+ 
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return ret;
+ }
+ 
+ int beiscsi_set_uer_feature(struct beiscsi_hba *phba)
+ {
+ 	struct be_ctrl_info *ctrl = &phba->ctrl;
+ 	struct be_cmd_set_features *ioctl;
+ 	struct be_mcc_wrb *wrb;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&ctrl->mbox_lock);
+ 	wrb = wrb_from_mbox(&ctrl->mbox_mem);
+ 	memset(wrb, 0, sizeof(*wrb));
+ 	ioctl = embedded_payload(wrb);
+ 
+ 	be_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);
+ 	be_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,
+ 			   OPCODE_COMMON_SET_FEATURES,
+ 			   EMBED_MBX_MAX_PAYLOAD_SIZE);
+ 	ioctl->feature = BE_CMD_SET_FEATURE_UER;
+ 	ioctl->param_len = sizeof(ioctl->param.req);
+ 	ioctl->param.req.uer = BE_CMD_UER_SUPP_BIT;
+ 	ret = be_mbox_notify(ctrl);
+ 	if (!ret) {
+ 		phba->ue2rp = ioctl->param.resp.ue2rp;
+ 		set_bit(BEISCSI_HBA_UER_SUPP, &phba->state);
+ 		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
+ 			    "BG_%d : HBA error recovery supported\n");
+ 	} else {
+ 		/**
+ 		 * Check "MCC_STATUS_INVALID_LENGTH" for SKH.
+ 		 * Older FW versions return this error.
+ 		 */
+ 		if (ret == MCC_STATUS_ILLEGAL_REQUEST ||
+ 		    ret == MCC_STATUS_INVALID_LENGTH)
+ 			__beiscsi_log(phba, KERN_INFO,
+ 				      "BG_%d : HBA error recovery not supported\n");
+ 	}
+ 
+ 	mutex_unlock(&ctrl->mbox_lock);
+ 	return ret;
+ }
++>>>>>>> 480195c267a4 (scsi: be2iscsi: Move functions to right files)
diff --cc drivers/scsi/be2iscsi/be_cmds.h
index c50b74afd00a,c9823b00b254..000000000000
--- a/drivers/scsi/be2iscsi/be_cmds.h
+++ b/drivers/scsi/be2iscsi/be_cmds.h
@@@ -707,16 -714,45 +707,21 @@@ struct be_cmd_get_nic_conf_resp 
  	u8 mac_address[ETH_ALEN];
  } __packed;
  
++<<<<<<< HEAD
 +#define BEISCSI_ALIAS_LEN 32
++=======
+ /******************** Get HBA NAME *******************/
++>>>>>>> 480195c267a4 (scsi: be2iscsi: Move functions to right files)
  
  struct be_cmd_hba_name {
  	struct be_cmd_req_hdr hdr;
  	u16 flags;
  	u16 rsvd0;
  	u8 initiator_name[ISCSI_NAME_LEN];
- 	u8 initiator_alias[BEISCSI_ALIAS_LEN];
+ #define BE_INI_ALIAS_LEN 32
+ 	u8 initiator_alias[BE_INI_ALIAS_LEN];
  } __packed;
  
 -/******************** COMMON SET Features *******************/
 -#define BE_CMD_SET_FEATURE_UER	0x10
 -#define BE_CMD_UER_SUPP_BIT	0x1
 -struct be_uer_req {
 -	u32 uer;
 -	u32 rsvd;
 -};
 -
 -struct be_uer_resp {
 -	u32 uer;
 -	u16 ue2rp;
 -	u16 ue2sr;
 -};
 -
 -struct be_cmd_set_features {
 -	union {
 -		struct be_cmd_req_hdr req_hdr;
 -		struct be_cmd_resp_hdr resp_hdr;
 -	} h;
 -	u32 feature;
 -	u32 param_len;
 -	union {
 -		struct be_uer_req req;
 -		struct be_uer_resp resp;
 -		u32 rsvd[2];
 -	} param;
 -} __packed;
 -
  int beiscsi_cmd_eq_create(struct be_ctrl_info *ctrl,
  			  struct be_queue_info *eq, int eq_delay);
  
@@@ -785,6 -822,15 +786,18 @@@ int be_cmd_wrbq_create(struct be_ctrl_i
  /* Configuration Functions */
  int be_cmd_set_vlan(struct beiscsi_hba *phba, uint16_t vlan_tag);
  
++<<<<<<< HEAD
++=======
+ int beiscsi_check_supported_fw(struct be_ctrl_info *ctrl,
+ 			       struct beiscsi_hba *phba);
+ 
+ int beiscsi_get_fw_config(struct be_ctrl_info *ctrl, struct beiscsi_hba *phba);
+ 
+ int beiscsi_get_port_name(struct be_ctrl_info *ctrl, struct beiscsi_hba *phba);
+ 
+ int beiscsi_set_uer_feature(struct beiscsi_hba *phba);
+ 
++>>>>>>> 480195c267a4 (scsi: be2iscsi: Move functions to right files)
  struct be_default_pdu_context {
  	u32 dw[4];
  } __packed;
diff --cc drivers/scsi/be2iscsi/be_mgmt.h
index 294b740805a6,f8d27783f207..000000000000
--- a/drivers/scsi/be2iscsi/be_mgmt.h
+++ b/drivers/scsi/be2iscsi/be_mgmt.h
@@@ -282,15 -277,10 +277,22 @@@ int beiscsi_if_en_dhcp(struct beiscsi_h
  int beiscsi_if_en_static(struct beiscsi_hba *phba, u32 ip_type,
  			 u8 *ip, u8 *subnet);
  
++<<<<<<< HEAD
 +unsigned int mgmt_get_boot_target(struct beiscsi_hba *phba);
 +
 +unsigned int mgmt_reopen_session(struct beiscsi_hba *phba,
 +				  unsigned int reopen_type,
 +				  unsigned sess_handle);
 +
 +unsigned int mgmt_get_session_info(struct beiscsi_hba *phba,
 +				   u32 boot_session_handle,
 +				   struct be_dma_mem *nonemb_cmd);
++=======
+ int beiscsi_if_set_gw(struct beiscsi_hba *phba, u32 ip_type, u8 *gw);
+ 
+ int beiscsi_if_get_gw(struct beiscsi_hba *phba, u32 ip_type,
+ 		      struct be_cmd_get_def_gateway_resp *resp);
++>>>>>>> 480195c267a4 (scsi: be2iscsi: Move functions to right files)
  
  int mgmt_get_nic_conf(struct beiscsi_hba *phba,
  		      struct be_cmd_get_nic_conf_resp *mac);
@@@ -298,17 -288,19 +300,20 @@@
  int beiscsi_if_get_info(struct beiscsi_hba *phba, int ip_type,
  			struct be_cmd_get_if_info_resp **if_info);
  
 -unsigned int beiscsi_if_get_handle(struct beiscsi_hba *phba);
 -
 -int beiscsi_if_set_vlan(struct beiscsi_hba *phba, uint16_t vlan_tag);
 -
 -unsigned int beiscsi_boot_logout_sess(struct beiscsi_hba *phba);
++<<<<<<< HEAD
 +int beiscsi_if_get_gw(struct beiscsi_hba *phba, u32 ip_type,
 +		      struct be_cmd_get_def_gateway_resp *resp);
  
 -unsigned int beiscsi_boot_reopen_sess(struct beiscsi_hba *phba);
 +int beiscsi_if_set_gw(struct beiscsi_hba *phba, u32 ip_type, u8 *gw);
  
 -unsigned int beiscsi_boot_get_sinfo(struct beiscsi_hba *phba);
 +int be_mgmt_get_boot_shandle(struct beiscsi_hba *phba,
 +			      unsigned int *s_handle);
  
 -unsigned int __beiscsi_boot_get_shandle(struct beiscsi_hba *phba, int async);
++=======
++>>>>>>> 480195c267a4 (scsi: be2iscsi: Move functions to right files)
 +unsigned int beiscsi_if_get_handle(struct beiscsi_hba *phba);
  
 -int beiscsi_boot_get_shandle(struct beiscsi_hba *phba, unsigned int *s_handle);
 +int beiscsi_if_set_vlan(struct beiscsi_hba *phba, uint16_t vlan_tag);
  
  ssize_t beiscsi_drvr_ver_disp(struct device *dev,
  			       struct device_attribute *attr, char *buf);
* Unmerged path drivers/scsi/be2iscsi/be_cmds.c
* Unmerged path drivers/scsi/be2iscsi/be_cmds.h
diff --git a/drivers/scsi/be2iscsi/be_iscsi.c b/drivers/scsi/be2iscsi/be_iscsi.c
index faa37f67a8e6..7af56cd31927 100644
--- a/drivers/scsi/be2iscsi/be_iscsi.c
+++ b/drivers/scsi/be2iscsi/be_iscsi.c
@@ -119,6 +119,16 @@ void beiscsi_session_destroy(struct iscsi_cls_session *cls_session)
 	iscsi_session_teardown(cls_session);
 }
 
+/**
+ * beiscsi_session_fail(): Closing session with appropriate error
+ * @cls_session: ptr to session
+ **/
+void beiscsi_session_fail(struct iscsi_cls_session *cls_session)
+{
+	iscsi_session_failure(cls_session->dd_data, ISCSI_ERR_CONN_FAILED);
+}
+
+
 /**
  * beiscsi_conn_create - create an instance of iscsi connection
  * @cls_session: ptr to iscsi_cls_session
diff --git a/drivers/scsi/be2iscsi/be_iscsi.h b/drivers/scsi/be2iscsi/be_iscsi.h
index 0089e67badf8..2a4097a17ad0 100644
--- a/drivers/scsi/be2iscsi/be_iscsi.h
+++ b/drivers/scsi/be2iscsi/be_iscsi.h
@@ -50,6 +50,8 @@ struct iscsi_cls_session *beiscsi_session_create(struct iscsi_endpoint *ep,
 
 void beiscsi_session_destroy(struct iscsi_cls_session *cls_session);
 
+void beiscsi_session_fail(struct iscsi_cls_session *cls_session);
+
 struct iscsi_cls_conn *beiscsi_conn_create(struct iscsi_cls_session
 					   *cls_session, uint32_t cid);
 
diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index 8e3a0f9d2ac4..2b45ae032909 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -3850,7 +3850,7 @@ static int hwi_init_port(struct beiscsi_hba *phba)
 	if (status != 0)
 		goto error;
 
-	status = mgmt_check_supported_fw(ctrl, phba);
+	status = beiscsi_check_supported_fw(ctrl, phba);
 	if (status != 0) {
 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 			    "BM_%d : Unsupported fw version\n");
@@ -5664,13 +5664,13 @@ static int beiscsi_dev_probe(struct pci_dev *pcidev,
 	spin_lock_init(&phba->io_sgl_lock);
 	spin_lock_init(&phba->mgmt_sgl_lock);
 	spin_lock_init(&phba->async_pdu_lock);
-	ret = mgmt_get_fw_config(&phba->ctrl, phba);
+	ret = beiscsi_get_fw_config(&phba->ctrl, phba);
 	if (ret != 0) {
 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 			    "BM_%d : Error getting fw config\n");
 		goto free_port;
 	}
-	mgmt_get_port_name(&phba->ctrl, phba);
+	beiscsi_get_port_name(&phba->ctrl, phba);
 	beiscsi_get_params(phba);
 
 	if (enable_msix)
diff --git a/drivers/scsi/be2iscsi/be_mgmt.c b/drivers/scsi/be2iscsi/be_mgmt.c
index fa17b8e5a47c..d0bc42ab68ac 100644
--- a/drivers/scsi/be2iscsi/be_mgmt.c
+++ b/drivers/scsi/be2iscsi/be_mgmt.c
@@ -303,267 +303,6 @@ unsigned int mgmt_get_session_info(struct beiscsi_hba *phba,
 	return tag;
 }
 
-/**
- * mgmt_get_port_name()- Get port name for the function
- * @ctrl: ptr to Ctrl Info
- * @phba: ptr to the dev priv structure
- *
- * Get the alphanumeric character for port
- *
- **/
-int mgmt_get_port_name(struct be_ctrl_info *ctrl,
-		       struct beiscsi_hba *phba)
-{
-	int ret = 0;
-	struct be_mcc_wrb *wrb;
-	struct be_cmd_get_port_name *ioctl;
-
-	mutex_lock(&ctrl->mbox_lock);
-	wrb = wrb_from_mbox(&ctrl->mbox_mem);
-	memset(wrb, 0, sizeof(*wrb));
-	ioctl = embedded_payload(wrb);
-
-	be_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);
-	be_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,
-			   OPCODE_COMMON_GET_PORT_NAME,
-			   EMBED_MBX_MAX_PAYLOAD_SIZE);
-	ret = be_mbox_notify(ctrl);
-	phba->port_name = 0;
-	if (!ret) {
-		phba->port_name = ioctl->p.resp.port_names >>
-				  (phba->fw_config.phys_port * 8) & 0xff;
-	} else {
-		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
-			    "BG_%d : GET_PORT_NAME ret 0x%x status 0x%x\n",
-			    ret, ioctl->h.resp_hdr.status);
-	}
-
-	if (phba->port_name == 0)
-		phba->port_name = '?';
-
-	mutex_unlock(&ctrl->mbox_lock);
-	return ret;
-}
-
-/**
- * mgmt_get_fw_config()- Get the FW config for the function
- * @ctrl: ptr to Ctrl Info
- * @phba: ptr to the dev priv structure
- *
- * Get the FW config and resources available for the function.
- * The resources are created based on the count received here.
- *
- * return
- *	Success: 0
- *	Failure: Non-Zero Value
- **/
-int mgmt_get_fw_config(struct be_ctrl_info *ctrl,
-				struct beiscsi_hba *phba)
-{
-	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
-	struct be_fw_cfg *pfw_cfg = embedded_payload(wrb);
-	uint32_t cid_count, icd_count;
-	int status = -EINVAL;
-	uint8_t ulp_num = 0;
-
-	mutex_lock(&ctrl->mbox_lock);
-	memset(wrb, 0, sizeof(*wrb));
-	be_wrb_hdr_prepare(wrb, sizeof(*pfw_cfg), true, 0);
-
-	be_cmd_hdr_prepare(&pfw_cfg->hdr, CMD_SUBSYSTEM_COMMON,
-			   OPCODE_COMMON_QUERY_FIRMWARE_CONFIG,
-			   EMBED_MBX_MAX_PAYLOAD_SIZE);
-
-	if (be_mbox_notify(ctrl)) {
-		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
-			    "BG_%d : Failed in mgmt_get_fw_config\n");
-		goto fail_init;
-	}
-
-	/* FW response formats depend on port id */
-	phba->fw_config.phys_port = pfw_cfg->phys_port;
-	if (phba->fw_config.phys_port >= BEISCSI_PHYS_PORT_MAX) {
-		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
-			    "BG_%d : invalid physical port id %d\n",
-			    phba->fw_config.phys_port);
-		goto fail_init;
-	}
-
-	/* populate and check FW config against min and max values */
-	if (!is_chip_be2_be3r(phba)) {
-		phba->fw_config.eqid_count = pfw_cfg->eqid_count;
-		phba->fw_config.cqid_count = pfw_cfg->cqid_count;
-		if (phba->fw_config.eqid_count == 0 ||
-		    phba->fw_config.eqid_count > 2048) {
-			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
-				    "BG_%d : invalid EQ count %d\n",
-				    phba->fw_config.eqid_count);
-			goto fail_init;
-		}
-		if (phba->fw_config.cqid_count == 0 ||
-		    phba->fw_config.cqid_count > 4096) {
-			beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
-				    "BG_%d : invalid CQ count %d\n",
-				    phba->fw_config.cqid_count);
-			goto fail_init;
-		}
-		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
-			    "BG_%d : EQ_Count : %d CQ_Count : %d\n",
-			    phba->fw_config.eqid_count,
-			    phba->fw_config.cqid_count);
-	}
-
-	/**
-	 * Check on which all ULP iSCSI Protocol is loaded.
-	 * Set the Bit for those ULP. This set flag is used
-	 * at all places in the code to check on which ULP
-	 * iSCSi Protocol is loaded
-	 **/
-	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {
-		if (pfw_cfg->ulp[ulp_num].ulp_mode &
-		    BEISCSI_ULP_ISCSI_INI_MODE) {
-			set_bit(ulp_num, &phba->fw_config.ulp_supported);
-
-			/* Get the CID, ICD and Chain count for each ULP */
-			phba->fw_config.iscsi_cid_start[ulp_num] =
-				pfw_cfg->ulp[ulp_num].sq_base;
-			phba->fw_config.iscsi_cid_count[ulp_num] =
-				pfw_cfg->ulp[ulp_num].sq_count;
-
-			phba->fw_config.iscsi_icd_start[ulp_num] =
-				pfw_cfg->ulp[ulp_num].icd_base;
-			phba->fw_config.iscsi_icd_count[ulp_num] =
-				pfw_cfg->ulp[ulp_num].icd_count;
-
-			phba->fw_config.iscsi_chain_start[ulp_num] =
-				pfw_cfg->chain_icd[ulp_num].chain_base;
-			phba->fw_config.iscsi_chain_count[ulp_num] =
-				pfw_cfg->chain_icd[ulp_num].chain_count;
-
-			beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
-				    "BG_%d : Function loaded on ULP : %d\n"
-				    "\tiscsi_cid_count : %d\n"
-				    "\tiscsi_cid_start : %d\n"
-				    "\t iscsi_icd_count : %d\n"
-				    "\t iscsi_icd_start : %d\n",
-				    ulp_num,
-				    phba->fw_config.
-				    iscsi_cid_count[ulp_num],
-				    phba->fw_config.
-				    iscsi_cid_start[ulp_num],
-				    phba->fw_config.
-				    iscsi_icd_count[ulp_num],
-				    phba->fw_config.
-				    iscsi_icd_start[ulp_num]);
-		}
-	}
-
-	if (phba->fw_config.ulp_supported == 0) {
-		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
-			    "BG_%d : iSCSI initiator mode not set: ULP0 %x ULP1 %x\n",
-			    pfw_cfg->ulp[BEISCSI_ULP0].ulp_mode,
-			    pfw_cfg->ulp[BEISCSI_ULP1].ulp_mode);
-		goto fail_init;
-	}
-
-	/**
-	 * ICD is shared among ULPs. Use icd_count of any one loaded ULP
-	 **/
-	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)
-		if (test_bit(ulp_num, &phba->fw_config.ulp_supported))
-			break;
-	icd_count = phba->fw_config.iscsi_icd_count[ulp_num];
-	if (icd_count == 0 || icd_count > 65536) {
-		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
-			    "BG_%d: invalid ICD count %d\n", icd_count);
-		goto fail_init;
-	}
-
-	cid_count = BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP0) +
-		    BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP1);
-	if (cid_count == 0 || cid_count > 4096) {
-		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
-			    "BG_%d: invalid CID count %d\n", cid_count);
-		goto fail_init;
-	}
-
-	/**
-	 * Check FW is dual ULP aware i.e. can handle either
-	 * of the protocols.
-	 */
-	phba->fw_config.dual_ulp_aware = (pfw_cfg->function_mode &
-					  BEISCSI_FUNC_DUA_MODE);
-
-	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
-		    "BG_%d : DUA Mode : 0x%x\n",
-		    phba->fw_config.dual_ulp_aware);
-
-	/* all set, continue using this FW config */
-	status = 0;
-fail_init:
-	mutex_unlock(&ctrl->mbox_lock);
-	return status;
-}
-
-int mgmt_check_supported_fw(struct be_ctrl_info *ctrl,
-				      struct beiscsi_hba *phba)
-{
-	struct be_dma_mem nonemb_cmd;
-	struct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);
-	struct be_mgmt_controller_attributes *req;
-	struct be_sge *sge = nonembedded_sgl(wrb);
-	int status = 0;
-
-	nonemb_cmd.va = pci_alloc_consistent(ctrl->pdev,
-				sizeof(struct be_mgmt_controller_attributes),
-				&nonemb_cmd.dma);
-	if (nonemb_cmd.va == NULL) {
-		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
-			    "BG_%d : Failed to allocate memory for "
-			    "mgmt_check_supported_fw\n");
-		return -ENOMEM;
-	}
-	nonemb_cmd.size = sizeof(struct be_mgmt_controller_attributes);
-	req = nonemb_cmd.va;
-	memset(req, 0, sizeof(*req));
-	mutex_lock(&ctrl->mbox_lock);
-	memset(wrb, 0, sizeof(*wrb));
-	be_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);
-	be_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,
-			   OPCODE_COMMON_GET_CNTL_ATTRIBUTES, sizeof(*req));
-	sge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd.dma));
-	sge->pa_lo = cpu_to_le32(nonemb_cmd.dma & 0xFFFFFFFF);
-	sge->len = cpu_to_le32(nonemb_cmd.size);
-	status = be_mbox_notify(ctrl);
-	if (!status) {
-		struct be_mgmt_controller_attributes_resp *resp = nonemb_cmd.va;
-		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
-			    "BG_%d : Firmware Version of CMD : %s\n"
-			    "Firmware Version is : %s\n"
-			    "Developer Build, not performing version check...\n",
-			    resp->params.hba_attribs
-			    .flashrom_version_string,
-			    resp->params.hba_attribs.
-			    firmware_version_string);
-
-		phba->fw_config.iscsi_features =
-				resp->params.hba_attribs.iscsi_features;
-		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,
-			    "BM_%d : phba->fw_config.iscsi_features = %d\n",
-			    phba->fw_config.iscsi_features);
-		memcpy(phba->fw_ver_str, resp->params.hba_attribs.
-		       firmware_version_string, BEISCSI_VER_STRLEN);
-	} else
-		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
-			    "BG_%d :  Failed in mgmt_check_supported_fw\n");
-	mutex_unlock(&ctrl->mbox_lock);
-	if (nonemb_cmd.va)
-		pci_free_consistent(ctrl->pdev, nonemb_cmd.size,
-				    nonemb_cmd.va, nonemb_cmd.dma);
-
-	return status;
-}
-
 unsigned int mgmt_vendor_specific_fw_cmd(struct be_ctrl_info *ctrl,
 					 struct beiscsi_hba *phba,
 					 struct bsg_job *job,
* Unmerged path drivers/scsi/be2iscsi/be_mgmt.h
