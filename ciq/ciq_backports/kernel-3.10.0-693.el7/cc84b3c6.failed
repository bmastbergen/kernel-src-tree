ipv6: export several functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alexander Aring <aar@pengutronix.de>
commit cc84b3c6b48ae81748c5e25d3558872385196162
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/cc84b3c6.failed

This patch exports some neighbour discovery functions which can be used
by 6lowpan neighbour discovery ops functionality then.

	Cc: David S. Miller <davem@davemloft.net>
	Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
	Cc: James Morris <jmorris@namei.org>
	Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
	Cc: Patrick McHardy <kaber@trash.net>
	Acked-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
	Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
	Signed-off-by: Alexander Aring <aar@pengutronix.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cc84b3c6b48ae81748c5e25d3558872385196162)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/addrconf.h
#	include/net/ndisc.h
#	net/ipv6/addrconf.c
diff --cc include/net/addrconf.h
index b9f981413f76,9826d3a9464c..000000000000
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@@ -87,6 -94,16 +87,19 @@@ int ipv6_rcv_saddr_equal(const struct s
  void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);
  void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);
  
++<<<<<<< HEAD
++=======
+ void addrconf_add_linklocal(struct inet6_dev *idev,
+ 			    const struct in6_addr *addr, u32 flags);
+ 
+ int addrconf_prefix_rcv_add_addr(struct net *net, struct net_device *dev,
+ 				 const struct prefix_info *pinfo,
+ 				 struct inet6_dev *in6_dev,
+ 				 const struct in6_addr *addr, int addr_type,
+ 				 u32 addr_flags, bool sllao, bool tokenized,
+ 				 __u32 valid_lft, u32 prefered_lft);
+ 
++>>>>>>> cc84b3c6b48a (ipv6: export several functions)
  static inline int addrconf_ifid_eui48(u8 *eui, struct net_device *dev)
  {
  	if (dev->addr_len != ETH_ALEN)
diff --cc include/net/ndisc.h
index 4a7a80f7a6d2,3f0f41ddbeb0..000000000000
--- a/include/net/ndisc.h
+++ b/include/net/ndisc.h
@@@ -110,8 -120,184 +119,189 @@@ struct ndisc_options 
  
  #define NDISC_OPT_SPACE(len) (((len)+2+7)&~7)
  
++<<<<<<< HEAD
 +extern struct ndisc_options *ndisc_parse_options(u8 *opt, int opt_len,
 +						 struct ndisc_options *ndopts);
++=======
+ struct ndisc_options *ndisc_parse_options(const struct net_device *dev,
+ 					  u8 *opt, int opt_len,
+ 					  struct ndisc_options *ndopts);
+ 
+ void __ndisc_fill_addr_option(struct sk_buff *skb, int type, void *data,
+ 			      int data_len, int pad);
+ 
+ #define NDISC_OPS_REDIRECT_DATA_SPACE	2
+ 
+ /*
+  * This structure defines the hooks for IPv6 neighbour discovery.
+  * The following hooks can be defined; unless noted otherwise, they are
+  * optional and can be filled with a null pointer.
+  *
+  * int (*is_useropt)(u8 nd_opt_type):
+  *     This function is called when IPv6 decide RA userspace options. if
+  *     this function returns 1 then the option given by nd_opt_type will
+  *     be handled as userspace option additional to the IPv6 options.
+  *
+  * int (*parse_options)(const struct net_device *dev,
+  *			struct nd_opt_hdr *nd_opt,
+  *			struct ndisc_options *ndopts):
+  *     This function is called while parsing ndisc ops and put each position
+  *     as pointer into ndopts. If this function return unequal 0, then this
+  *     function took care about the ndisc option, if 0 then the IPv6 ndisc
+  *     option parser will take care about that option.
+  *
+  * void (*update)(const struct net_device *dev, struct neighbour *n,
+  *		  u32 flags, u8 icmp6_type,
+  *		  const struct ndisc_options *ndopts):
+  *     This function is called when IPv6 ndisc updates the neighbour cache
+  *     entry. Additional options which can be updated may be previously
+  *     parsed by parse_opts callback and accessible over ndopts parameter.
+  *
+  * int (*opt_addr_space)(const struct net_device *dev, u8 icmp6_type,
+  *			 struct neighbour *neigh, u8 *ha_buf,
+  *			 u8 **ha):
+  *     This function is called when the necessary option space will be
+  *     calculated before allocating a skb. The parameters neigh, ha_buf
+  *     abd ha are available on NDISC_REDIRECT messages only.
+  *
+  * void (*fill_addr_option)(const struct net_device *dev,
+  *			    struct sk_buff *skb, u8 icmp6_type,
+  *			    const u8 *ha):
+  *     This function is called when the skb will finally fill the option
+  *     fields inside skb. NOTE: this callback should fill the option
+  *     fields to the skb which are previously indicated by opt_space
+  *     parameter. That means the decision to add such option should
+  *     not lost between these two callbacks, e.g. protected by interface
+  *     up state.
+  *
+  * void (*prefix_rcv_add_addr)(struct net *net, struct net_device *dev,
+  *			       const struct prefix_info *pinfo,
+  *			       struct inet6_dev *in6_dev,
+  *			       struct in6_addr *addr,
+  *			       int addr_type, u32 addr_flags,
+  *			       bool sllao, bool tokenized,
+  *			       __u32 valid_lft, u32 prefered_lft,
+  *			       bool dev_addr_generated):
+  *     This function is called when a RA messages is received with valid
+  *     PIO option fields and an IPv6 address will be added to the interface
+  *     for autoconfiguration. The parameter dev_addr_generated reports about
+  *     if the address was based on dev->dev_addr or not. This can be used
+  *     to add a second address if link-layer operates with two link layer
+  *     addresses. E.g. 802.15.4 6LoWPAN.
+  */
+ struct ndisc_ops {
+ 	int	(*is_useropt)(u8 nd_opt_type);
+ 	int	(*parse_options)(const struct net_device *dev,
+ 				 struct nd_opt_hdr *nd_opt,
+ 				 struct ndisc_options *ndopts);
+ 	void	(*update)(const struct net_device *dev, struct neighbour *n,
+ 			  u32 flags, u8 icmp6_type,
+ 			  const struct ndisc_options *ndopts);
+ 	int	(*opt_addr_space)(const struct net_device *dev, u8 icmp6_type,
+ 				  struct neighbour *neigh, u8 *ha_buf,
+ 				  u8 **ha);
+ 	void	(*fill_addr_option)(const struct net_device *dev,
+ 				    struct sk_buff *skb, u8 icmp6_type,
+ 				    const u8 *ha);
+ 	void	(*prefix_rcv_add_addr)(struct net *net, struct net_device *dev,
+ 				       const struct prefix_info *pinfo,
+ 				       struct inet6_dev *in6_dev,
+ 				       struct in6_addr *addr,
+ 				       int addr_type, u32 addr_flags,
+ 				       bool sllao, bool tokenized,
+ 				       __u32 valid_lft, u32 prefered_lft,
+ 				       bool dev_addr_generated);
+ };
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static inline int ndisc_ops_is_useropt(const struct net_device *dev,
+ 				       u8 nd_opt_type)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->is_useropt)
+ 		return dev->ndisc_ops->is_useropt(nd_opt_type);
+ 	else
+ 		return 0;
+ }
+ 
+ static inline int ndisc_ops_parse_options(const struct net_device *dev,
+ 					  struct nd_opt_hdr *nd_opt,
+ 					  struct ndisc_options *ndopts)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->parse_options)
+ 		return dev->ndisc_ops->parse_options(dev, nd_opt, ndopts);
+ 	else
+ 		return 0;
+ }
+ 
+ static inline void ndisc_ops_update(const struct net_device *dev,
+ 					  struct neighbour *n, u32 flags,
+ 					  u8 icmp6_type,
+ 					  const struct ndisc_options *ndopts)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->update)
+ 		dev->ndisc_ops->update(dev, n, flags, icmp6_type, ndopts);
+ }
+ 
+ static inline int ndisc_ops_opt_addr_space(const struct net_device *dev,
+ 					   u8 icmp6_type)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->opt_addr_space &&
+ 	    icmp6_type != NDISC_REDIRECT)
+ 		return dev->ndisc_ops->opt_addr_space(dev, icmp6_type, NULL,
+ 						      NULL, NULL);
+ 	else
+ 		return 0;
+ }
+ 
+ static inline int ndisc_ops_redirect_opt_addr_space(const struct net_device *dev,
+ 						    struct neighbour *neigh,
+ 						    u8 *ha_buf, u8 **ha)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->opt_addr_space)
+ 		return dev->ndisc_ops->opt_addr_space(dev, NDISC_REDIRECT,
+ 						      neigh, ha_buf, ha);
+ 	else
+ 		return 0;
+ }
+ 
+ static inline void ndisc_ops_fill_addr_option(const struct net_device *dev,
+ 					      struct sk_buff *skb,
+ 					      u8 icmp6_type)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->fill_addr_option &&
+ 	    icmp6_type != NDISC_REDIRECT)
+ 		dev->ndisc_ops->fill_addr_option(dev, skb, icmp6_type, NULL);
+ }
+ 
+ static inline void ndisc_ops_fill_redirect_addr_option(const struct net_device *dev,
+ 						       struct sk_buff *skb,
+ 						       const u8 *ha)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->fill_addr_option)
+ 		dev->ndisc_ops->fill_addr_option(dev, skb, NDISC_REDIRECT, ha);
+ }
+ 
+ static inline void ndisc_ops_prefix_rcv_add_addr(struct net *net,
+ 						 struct net_device *dev,
+ 						 const struct prefix_info *pinfo,
+ 						 struct inet6_dev *in6_dev,
+ 						 struct in6_addr *addr,
+ 						 int addr_type, u32 addr_flags,
+ 						 bool sllao, bool tokenized,
+ 						 __u32 valid_lft,
+ 						 u32 prefered_lft,
+ 						 bool dev_addr_generated)
+ {
+ 	if (dev->ndisc_ops && dev->ndisc_ops->prefix_rcv_add_addr)
+ 		dev->ndisc_ops->prefix_rcv_add_addr(net, dev, pinfo, in6_dev,
+ 						    addr, addr_type,
+ 						    addr_flags, sllao,
+ 						    tokenized, valid_lft,
+ 						    prefered_lft,
+ 						    dev_addr_generated);
+ }
+ #endif
++>>>>>>> cc84b3c6b48a (ipv6: export several functions)
  
  /*
   * Return the padding between the option length and the start of the
diff --cc net/ipv6/addrconf.c
index ee6298c84794,6c8fc3f96b11..000000000000
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@@ -2149,6 -2327,109 +2149,112 @@@ static void manage_tempaddrs(struct ine
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static bool is_addr_mode_generate_stable(struct inet6_dev *idev)
+ {
+ 	return idev->addr_gen_mode == IN6_ADDR_GEN_MODE_STABLE_PRIVACY ||
+ 	       idev->addr_gen_mode == IN6_ADDR_GEN_MODE_RANDOM;
+ }
+ 
+ int addrconf_prefix_rcv_add_addr(struct net *net, struct net_device *dev,
+ 				 const struct prefix_info *pinfo,
+ 				 struct inet6_dev *in6_dev,
+ 				 const struct in6_addr *addr, int addr_type,
+ 				 u32 addr_flags, bool sllao, bool tokenized,
+ 				 __u32 valid_lft, u32 prefered_lft)
+ {
+ 	struct inet6_ifaddr *ifp = ipv6_get_ifaddr(net, addr, dev, 1);
+ 	int create = 0, update_lft = 0;
+ 
+ 	if (!ifp && valid_lft) {
+ 		int max_addresses = in6_dev->cnf.max_addresses;
+ 
+ #ifdef CONFIG_IPV6_OPTIMISTIC_DAD
+ 		if (in6_dev->cnf.optimistic_dad &&
+ 		    !net->ipv6.devconf_all->forwarding && sllao)
+ 			addr_flags |= IFA_F_OPTIMISTIC;
+ #endif
+ 
+ 		/* Do not allow to create too much of autoconfigured
+ 		 * addresses; this would be too easy way to crash kernel.
+ 		 */
+ 		if (!max_addresses ||
+ 		    ipv6_count_addresses(in6_dev) < max_addresses)
+ 			ifp = ipv6_add_addr(in6_dev, addr, NULL,
+ 					    pinfo->prefix_len,
+ 					    addr_type&IPV6_ADDR_SCOPE_MASK,
+ 					    addr_flags, valid_lft,
+ 					    prefered_lft);
+ 
+ 		if (IS_ERR_OR_NULL(ifp))
+ 			return -1;
+ 
+ 		update_lft = 0;
+ 		create = 1;
+ 		spin_lock_bh(&ifp->lock);
+ 		ifp->flags |= IFA_F_MANAGETEMPADDR;
+ 		ifp->cstamp = jiffies;
+ 		ifp->tokenized = tokenized;
+ 		spin_unlock_bh(&ifp->lock);
+ 		addrconf_dad_start(ifp);
+ 	}
+ 
+ 	if (ifp) {
+ 		u32 flags;
+ 		unsigned long now;
+ 		u32 stored_lft;
+ 
+ 		/* update lifetime (RFC2462 5.5.3 e) */
+ 		spin_lock_bh(&ifp->lock);
+ 		now = jiffies;
+ 		if (ifp->valid_lft > (now - ifp->tstamp) / HZ)
+ 			stored_lft = ifp->valid_lft - (now - ifp->tstamp) / HZ;
+ 		else
+ 			stored_lft = 0;
+ 		if (!update_lft && !create && stored_lft) {
+ 			const u32 minimum_lft = min_t(u32,
+ 				stored_lft, MIN_VALID_LIFETIME);
+ 			valid_lft = max(valid_lft, minimum_lft);
+ 
+ 			/* RFC4862 Section 5.5.3e:
+ 			 * "Note that the preferred lifetime of the
+ 			 *  corresponding address is always reset to
+ 			 *  the Preferred Lifetime in the received
+ 			 *  Prefix Information option, regardless of
+ 			 *  whether the valid lifetime is also reset or
+ 			 *  ignored."
+ 			 *
+ 			 * So we should always update prefered_lft here.
+ 			 */
+ 			update_lft = 1;
+ 		}
+ 
+ 		if (update_lft) {
+ 			ifp->valid_lft = valid_lft;
+ 			ifp->prefered_lft = prefered_lft;
+ 			ifp->tstamp = now;
+ 			flags = ifp->flags;
+ 			ifp->flags &= ~IFA_F_DEPRECATED;
+ 			spin_unlock_bh(&ifp->lock);
+ 
+ 			if (!(flags&IFA_F_TENTATIVE))
+ 				ipv6_ifa_notify(0, ifp);
+ 		} else
+ 			spin_unlock_bh(&ifp->lock);
+ 
+ 		manage_tempaddrs(in6_dev, ifp, valid_lft, prefered_lft,
+ 				 create, now);
+ 
+ 		in6_ifa_put(ifp);
+ 		addrconf_verify();
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(addrconf_prefix_rcv_add_addr);
+ 
++>>>>>>> cc84b3c6b48a (ipv6: export several functions)
  void addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len, bool sllao)
  {
  	struct prefix_info *pinfo;
* Unmerged path include/net/addrconf.h
* Unmerged path include/net/ndisc.h
* Unmerged path net/ipv6/addrconf.c
diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
index 48c6e50e8b35..c35818d9bcd5 100644
--- a/net/ipv6/ndisc.c
+++ b/net/ipv6/ndisc.c
@@ -72,15 +72,6 @@
 #include <linux/netfilter.h>
 #include <linux/netfilter_ipv6.h>
 
-/* Set to 3 to get tracing... */
-#define ND_DEBUG 1
-
-#define ND_PRINTK(val, level, fmt, ...)				\
-do {								\
-	if (val <= ND_DEBUG)					\
-		net_##level##_ratelimited(fmt, ##__VA_ARGS__);	\
-} while (0)
-
 static u32 ndisc_hash(const void *pkey,
 		      const struct net_device *dev,
 		      __u32 *hash_rnd);
@@ -146,8 +137,8 @@ struct neigh_table nd_tbl = {
 };
 EXPORT_SYMBOL_GPL(nd_tbl);
 
-static void __ndisc_fill_addr_option(struct sk_buff *skb, int type, void *data,
-				     int data_len, int pad)
+void __ndisc_fill_addr_option(struct sk_buff *skb, int type, void *data,
+			      int data_len, int pad)
 {
 	int space = __ndisc_opt_addr_space(data_len, pad);
 	u8 *opt = skb_put(skb, space);
@@ -165,6 +156,7 @@ static void __ndisc_fill_addr_option(struct sk_buff *skb, int type, void *data,
 	if ((space -= data_len) > 0)
 		memset(opt, 0, space);
 }
+EXPORT_SYMBOL_GPL(__ndisc_fill_addr_option);
 
 static inline void ndisc_fill_addr_option(struct sk_buff *skb, int type,
 					  void *data)
