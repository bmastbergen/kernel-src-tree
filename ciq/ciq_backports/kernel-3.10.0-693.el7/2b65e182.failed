scsi: lpfc: NVME Target: Add debugfs support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] lpfc: NVME Target: Add debugfs support (Ewan Milne) [1384922]
Rebuild_FUZZ: 92.68%
commit-author James Smart <jsmart2021@gmail.com>
commit 2b65e18202fd0f109b739dd6717286edca7a2b0d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2b65e182.failed

NVME Target: Add debugfs support

Adds debugfs snippets to cover the new NVME target functionality

	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: James Smart <james.smart@broadcom.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 2b65e18202fd0f109b739dd6717286edca7a2b0d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_debugfs.c
#	drivers/scsi/lpfc/lpfc_nvmet.c
#	drivers/scsi/lpfc/lpfc_nvmet.h
diff --cc drivers/scsi/lpfc/lpfc_debugfs.c
index 4dc8eba541b9,f92796d8dc42..000000000000
--- a/drivers/scsi/lpfc/lpfc_debugfs.c
+++ b/drivers/scsi/lpfc/lpfc_debugfs.c
@@@ -41,8 -44,10 +41,13 @@@
  #include "lpfc_sli4.h"
  #include "lpfc_nl.h"
  #include "lpfc_disc.h"
 -#include "lpfc.h"
  #include "lpfc_scsi.h"
++<<<<<<< HEAD
 +#include "lpfc.h"
++=======
+ #include "lpfc_nvme.h"
+ #include "lpfc_nvmet.h"
++>>>>>>> 2b65e18202fd (scsi: lpfc: NVME Target: Add debugfs support)
  #include "lpfc_logmsg.h"
  #include "lpfc_crtn.h"
  #include "lpfc_vport.h"
@@@ -530,8 -544,14 +535,18 @@@ lpfc_debugfs_nodelist_data(struct lpfc_
  	int len = 0;
  	int cnt;
  	struct Scsi_Host *shost = lpfc_shost_from_vport(vport);
+ 	struct lpfc_hba  *phba = vport->phba;
  	struct lpfc_nodelist *ndlp;
++<<<<<<< HEAD
 +	unsigned char *statep, *name;
++=======
+ 	unsigned char *statep;
+ 	struct nvme_fc_local_port *localport;
+ 	struct lpfc_nvme_lport *lport;
+ 	struct lpfc_nvme_rport *rport;
+ 	struct lpfc_nvmet_tgtport *tgtp;
+ 	struct nvme_fc_remote_port *nrport;
++>>>>>>> 2b65e18202fd (scsi: lpfc: NVME Target: Add debugfs support)
  
  	cnt = (LPFC_NODELIST_SIZE / LPFC_NODELIST_ENTRY_SIZE);
  
@@@ -611,8 -628,592 +626,597 @@@
  		len +=  snprintf(buf+len, size-len, "\n");
  	}
  	spin_unlock_irq(shost->host_lock);
++<<<<<<< HEAD
 +	return len;
 +}
++=======
+ 
+ 	if (phba->nvmet_support && phba->targetport && (vport == phba->pport)) {
+ 		tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;
+ 		len += snprintf(buf + len, size - len,
+ 				"\nNVME Targetport Entry ...\n");
+ 
+ 		/* Port state is only one of two values for now. */
+ 		if (phba->targetport->port_id)
+ 			statep = "REGISTERED";
+ 		else
+ 			statep = "INIT";
+ 		len += snprintf(buf + len, size - len,
+ 				"TGT WWNN x%llx WWPN x%llx State %s\n",
+ 				wwn_to_u64(vport->fc_nodename.u.wwn),
+ 				wwn_to_u64(vport->fc_portname.u.wwn),
+ 				statep);
+ 		len += snprintf(buf + len, size - len,
+ 				"    Targetport DID x%06x\n",
+ 				phba->targetport->port_id);
+ 		goto out_exit;
+ 	}
+ 
+ 	len += snprintf(buf + len, size - len,
+ 				"\nNVME Lport/Rport Entries ...\n");
+ 
+ 	localport = vport->localport;
+ 	if (!localport)
+ 		goto out_exit;
+ 
+ 	spin_lock_irq(shost->host_lock);
+ 	lport = (struct lpfc_nvme_lport *)localport->private;
+ 
+ 	/* Port state is only one of two values for now. */
+ 	if (localport->port_id)
+ 		statep = "ONLINE";
+ 	else
+ 		statep = "UNKNOWN ";
+ 
+ 	len += snprintf(buf + len, size - len,
+ 			"Lport DID x%06x PortState %s\n",
+ 			localport->port_id, statep);
+ 
+ 	len += snprintf(buf + len, size - len, "\tRport List:\n");
+ 	list_for_each_entry(rport, &lport->rport_list, list) {
+ 		/* local short-hand pointer. */
+ 		nrport = rport->remoteport;
+ 
+ 		/* Port state is only one of two values for now. */
+ 		switch (nrport->port_state) {
+ 		case FC_OBJSTATE_ONLINE:
+ 			statep = "ONLINE";
+ 			break;
+ 		case FC_OBJSTATE_UNKNOWN:
+ 			statep = "UNKNOWN ";
+ 			break;
+ 		default:
+ 			statep = "UNSUPPORTED";
+ 			break;
+ 		}
+ 
+ 		/* Tab in to show lport ownership. */
+ 		len += snprintf(buf + len, size - len,
+ 				"\t%s Port ID:x%06x ",
+ 				statep, nrport->port_id);
+ 		len += snprintf(buf + len, size - len, "WWPN x%llx ",
+ 				nrport->port_name);
+ 		len += snprintf(buf + len, size - len, "WWNN x%llx ",
+ 				nrport->node_name);
+ 		switch (nrport->port_role) {
+ 		case FC_PORT_ROLE_NVME_INITIATOR:
+ 			len +=  snprintf(buf + len, size - len,
+ 					 "NVME INITIATOR ");
+ 			break;
+ 		case FC_PORT_ROLE_NVME_TARGET:
+ 			len +=  snprintf(buf + len, size - len,
+ 					 "NVME TARGET ");
+ 			break;
+ 		case FC_PORT_ROLE_NVME_DISCOVERY:
+ 			len +=  snprintf(buf + len, size - len,
+ 					 "NVME DISCOVERY ");
+ 			break;
+ 		default:
+ 			len +=  snprintf(buf + len, size - len,
+ 					 "UNKNOWN ROLE x%x",
+ 					 nrport->port_role);
+ 			break;
+ 		}
+ 
+ 		/* Terminate the string. */
+ 		len +=  snprintf(buf + len, size - len, "\n");
+ 	}
+ 
+ 	spin_unlock_irq(shost->host_lock);
+  out_exit:
+ 	return len;
+ }
+ 
+ /**
+  * lpfc_debugfs_nvmestat_data - Dump target node list to a buffer
+  * @vport: The vport to gather target node info from.
+  * @buf: The buffer to dump log into.
+  * @size: The maximum amount of data to process.
+  *
+  * Description:
+  * This routine dumps the NVME statistics associated with @vport
+  *
+  * Return Value:
+  * This routine returns the amount of bytes that were dumped into @buf and will
+  * not exceed @size.
+  **/
+ static int
+ lpfc_debugfs_nvmestat_data(struct lpfc_vport *vport, char *buf, int size)
+ {
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	struct lpfc_nvmet_tgtport *tgtp;
+ 	int len = 0;
+ 
+ 	if (phba->nvmet_support) {
+ 		if (!phba->targetport)
+ 			return len;
+ 		tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;
+ 		len += snprintf(buf+len, size-len,
+ 				"\nNVME Targetport Statistics\n");
+ 
+ 		len += snprintf(buf+len, size-len,
+ 				"LS: Rcv %08x Drop %08x Abort %08x\n",
+ 				atomic_read(&tgtp->rcv_ls_req_in),
+ 				atomic_read(&tgtp->rcv_ls_req_drop),
+ 				atomic_read(&tgtp->xmt_ls_abort));
+ 		if (atomic_read(&tgtp->rcv_ls_req_in) !=
+ 		    atomic_read(&tgtp->rcv_ls_req_out)) {
+ 			len += snprintf(buf+len, size-len,
+ 					"Rcv LS: in %08x != out %08x\n",
+ 					atomic_read(&tgtp->rcv_ls_req_in),
+ 					atomic_read(&tgtp->rcv_ls_req_out));
+ 		}
+ 
+ 		len += snprintf(buf+len, size-len,
+ 				"LS: Xmt %08x Drop %08x Cmpl %08x Err %08x\n",
+ 				atomic_read(&tgtp->xmt_ls_rsp),
+ 				atomic_read(&tgtp->xmt_ls_drop),
+ 				atomic_read(&tgtp->xmt_ls_rsp_cmpl),
+ 				atomic_read(&tgtp->xmt_ls_rsp_error));
+ 
+ 		len += snprintf(buf+len, size-len,
+ 				"FCP: Rcv %08x Drop %08x\n",
+ 				atomic_read(&tgtp->rcv_fcp_cmd_in),
+ 				atomic_read(&tgtp->rcv_fcp_cmd_drop));
+ 
+ 		if (atomic_read(&tgtp->rcv_fcp_cmd_in) !=
+ 		    atomic_read(&tgtp->rcv_fcp_cmd_out)) {
+ 			len += snprintf(buf+len, size-len,
+ 					"Rcv FCP: in %08x != out %08x\n",
+ 					atomic_read(&tgtp->rcv_fcp_cmd_in),
+ 					atomic_read(&tgtp->rcv_fcp_cmd_out));
+ 		}
+ 
+ 		len += snprintf(buf+len, size-len,
+ 				"FCP Rsp: read %08x readrsp %08x write %08x rsp %08x\n",
+ 				atomic_read(&tgtp->xmt_fcp_read),
+ 				atomic_read(&tgtp->xmt_fcp_read_rsp),
+ 				atomic_read(&tgtp->xmt_fcp_write),
+ 				atomic_read(&tgtp->xmt_fcp_rsp));
+ 
+ 		len += snprintf(buf+len, size-len,
+ 				"FCP Rsp: abort %08x drop %08x\n",
+ 				atomic_read(&tgtp->xmt_fcp_abort),
+ 				atomic_read(&tgtp->xmt_fcp_drop));
+ 
+ 		len += snprintf(buf+len, size-len,
+ 				"FCP Rsp Cmpl: %08x err %08x drop %08x\n",
+ 				atomic_read(&tgtp->xmt_fcp_rsp_cmpl),
+ 				atomic_read(&tgtp->xmt_fcp_rsp_error),
+ 				atomic_read(&tgtp->xmt_fcp_rsp_drop));
+ 
+ 		len += snprintf(buf+len, size-len,
+ 				"ABORT: Xmt %08x Err %08x Cmpl %08x",
+ 				atomic_read(&tgtp->xmt_abort_rsp),
+ 				atomic_read(&tgtp->xmt_abort_rsp_error),
+ 				atomic_read(&tgtp->xmt_abort_cmpl));
+ 
+ 		len +=  snprintf(buf+len, size-len, "\n");
+ 	} else {
+ 		if (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME))
+ 			return len;
+ 
+ 		len += snprintf(buf + len, size - len,
+ 				"\nNVME Lport Statistics\n");
+ 
+ 		len += snprintf(buf + len, size - len,
+ 				"LS: Xmt %016llx Cmpl %016llx\n",
+ 				phba->fc4NvmeLsRequests,
+ 				phba->fc4NvmeLsCmpls);
+ 
+ 		len += snprintf(buf + len, size - len,
+ 				"FCP: Rd %016llx Wr %016llx IO %016llx\n",
+ 				phba->fc4NvmeInputRequests,
+ 				phba->fc4NvmeOutputRequests,
+ 				phba->fc4NvmeControlRequests);
+ 
+ 		len += snprintf(buf + len, size - len,
+ 				"    Cmpl %016llx\n", phba->fc4NvmeIoCmpls);
+ 	}
+ 
+ 	return len;
+ }
+ 
+ 
+ /**
+  * lpfc_debugfs_nvmektime_data - Dump target node list to a buffer
+  * @vport: The vport to gather target node info from.
+  * @buf: The buffer to dump log into.
+  * @size: The maximum amount of data to process.
+  *
+  * Description:
+  * This routine dumps the NVME statistics associated with @vport
+  *
+  * Return Value:
+  * This routine returns the amount of bytes that were dumped into @buf and will
+  * not exceed @size.
+  **/
+ static int
+ lpfc_debugfs_nvmektime_data(struct lpfc_vport *vport, char *buf, int size)
+ {
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	int len = 0;
+ 
+ 	if (phba->nvmet_support == 0) {
+ 		/* NVME Initiator */
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"ktime %s: Total Samples: %lld\n",
+ 				(phba->ktime_on ?  "Enabled" : "Disabled"),
+ 				phba->ktime_data_samples);
+ 		if (phba->ktime_data_samples == 0)
+ 			return len;
+ 
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"Segment 1: Last NVME Cmd cmpl "
+ 			"done -to- Start of next NVME cnd (in driver)\n");
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg1_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg1_min,
+ 			phba->ktime_seg1_max);
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"Segment 2: Driver start of NVME cmd "
+ 			"-to- Firmware WQ doorbell\n");
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg2_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg2_min,
+ 			phba->ktime_seg2_max);
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"Segment 3: Firmware WQ doorbell -to- "
+ 			"MSI-X ISR cmpl\n");
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg3_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg3_min,
+ 			phba->ktime_seg3_max);
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"Segment 4: MSI-X ISR cmpl -to- "
+ 			"NVME cmpl done\n");
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg4_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg4_min,
+ 			phba->ktime_seg4_max);
+ 		len += snprintf(
+ 			buf + len, PAGE_SIZE - len,
+ 			"Total IO avg time: %08lld\n",
+ 			((phba->ktime_seg1_total +
+ 			phba->ktime_seg2_total  +
+ 			phba->ktime_seg3_total +
+ 			phba->ktime_seg4_total) /
+ 			phba->ktime_data_samples));
+ 		return len;
+ 	}
+ 
+ 	/* NVME Target */
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"ktime %s: Total Samples: %lld %lld\n",
+ 			(phba->ktime_on ? "Enabled" : "Disabled"),
+ 			phba->ktime_data_samples,
+ 			phba->ktime_status_samples);
+ 	if (phba->ktime_data_samples == 0)
+ 		return len;
+ 
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"Segment 1: MSI-X ISR Rcv cmd -to- "
+ 			"cmd pass to NVME Layer\n");
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg1_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg1_min,
+ 			phba->ktime_seg1_max);
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"Segment 2: cmd pass to NVME Layer- "
+ 			"-to- Driver rcv cmd OP (action)\n");
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg2_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg2_min,
+ 			phba->ktime_seg2_max);
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"Segment 3: Driver rcv cmd OP -to- "
+ 			"Firmware WQ doorbell: cmd\n");
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg3_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg3_min,
+ 			phba->ktime_seg3_max);
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"Segment 4: Firmware WQ doorbell: cmd "
+ 			"-to- MSI-X ISR for cmd cmpl\n");
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg4_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg4_min,
+ 			phba->ktime_seg4_max);
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"Segment 5: MSI-X ISR for cmd cmpl "
+ 			"-to- NVME layer passed cmd done\n");
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg5_total /
+ 			phba->ktime_data_samples,
+ 			phba->ktime_seg5_min,
+ 			phba->ktime_seg5_max);
+ 
+ 	if (phba->ktime_status_samples == 0) {
+ 		len += snprintf(buf + len, PAGE_SIZE-len,
+ 				"Total: cmd received by MSI-X ISR "
+ 				"-to- cmd completed on wire\n");
+ 		len += snprintf(buf + len, PAGE_SIZE-len,
+ 				"avg:%08lld min:%08lld "
+ 				"max %08lld\n",
+ 				phba->ktime_seg10_total /
+ 				phba->ktime_data_samples,
+ 				phba->ktime_seg10_min,
+ 				phba->ktime_seg10_max);
+ 		return len;
+ 	}
+ 
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"Segment 6: NVME layer passed cmd done "
+ 			"-to- Driver rcv rsp status OP\n");
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg6_total /
+ 			phba->ktime_status_samples,
+ 			phba->ktime_seg6_min,
+ 			phba->ktime_seg6_max);
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"Segment 7: Driver rcv rsp status OP "
+ 			"-to- Firmware WQ doorbell: status\n");
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg7_total /
+ 			phba->ktime_status_samples,
+ 			phba->ktime_seg7_min,
+ 			phba->ktime_seg7_max);
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"Segment 8: Firmware WQ doorbell: status"
+ 			" -to- MSI-X ISR for status cmpl\n");
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg8_total /
+ 			phba->ktime_status_samples,
+ 			phba->ktime_seg8_min,
+ 			phba->ktime_seg8_max);
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"Segment 9: MSI-X ISR for status cmpl  "
+ 			"-to- NVME layer passed status done\n");
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg9_total /
+ 			phba->ktime_status_samples,
+ 			phba->ktime_seg9_min,
+ 			phba->ktime_seg9_max);
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"Total: cmd received by MSI-X ISR -to- "
+ 			"cmd completed on wire\n");
+ 	len += snprintf(buf + len, PAGE_SIZE-len,
+ 			"avg:%08lld min:%08lld max %08lld\n",
+ 			phba->ktime_seg10_total /
+ 			phba->ktime_status_samples,
+ 			phba->ktime_seg10_min,
+ 			phba->ktime_seg10_max);
+ 	return len;
+ }
+ 
+ /**
+  * lpfc_debugfs_nvmeio_trc_data - Dump NVME IO trace list to a buffer
+  * @phba: The phba to gather target node info from.
+  * @buf: The buffer to dump log into.
+  * @size: The maximum amount of data to process.
+  *
+  * Description:
+  * This routine dumps the NVME IO trace associated with @phba
+  *
+  * Return Value:
+  * This routine returns the amount of bytes that were dumped into @buf and will
+  * not exceed @size.
+  **/
+ static int
+ lpfc_debugfs_nvmeio_trc_data(struct lpfc_hba *phba, char *buf, int size)
+ {
+ 	struct lpfc_debugfs_nvmeio_trc *dtp;
+ 	int i, state, index, skip;
+ 	int len = 0;
+ 
+ 	state = phba->nvmeio_trc_on;
+ 
+ 	index = (atomic_read(&phba->nvmeio_trc_cnt) + 1) &
+ 		(phba->nvmeio_trc_size - 1);
+ 	skip = phba->nvmeio_trc_output_idx;
+ 
+ 	len += snprintf(buf + len, size - len,
+ 			"%s IO Trace %s: next_idx %d skip %d size %d\n",
+ 			(phba->nvmet_support ? "NVME" : "NVMET"),
+ 			(state ? "Enabled" : "Disabled"),
+ 			index, skip, phba->nvmeio_trc_size);
+ 
+ 	if (!phba->nvmeio_trc || state)
+ 		return len;
+ 
+ 	/* trace MUST bhe off to continue */
+ 
+ 	for (i = index; i < phba->nvmeio_trc_size; i++) {
+ 		if (skip) {
+ 			skip--;
+ 			continue;
+ 		}
+ 		dtp = phba->nvmeio_trc + i;
+ 		phba->nvmeio_trc_output_idx++;
+ 
+ 		if (!dtp->fmt)
+ 			continue;
+ 
+ 		len +=  snprintf(buf + len, size - len, dtp->fmt,
+ 			dtp->data1, dtp->data2, dtp->data3);
+ 
+ 		if (phba->nvmeio_trc_output_idx >= phba->nvmeio_trc_size) {
+ 			phba->nvmeio_trc_output_idx = 0;
+ 			len += snprintf(buf + len, size - len,
+ 					"Trace Complete\n");
+ 			goto out;
+ 		}
+ 
+ 		if (len >= (size - LPFC_DEBUG_OUT_LINE_SZ)) {
+ 			len += snprintf(buf + len, size - len,
+ 					"Trace Continue (%d of %d)\n",
+ 					phba->nvmeio_trc_output_idx,
+ 					phba->nvmeio_trc_size);
+ 			goto out;
+ 		}
+ 	}
+ 	for (i = 0; i < index; i++) {
+ 		if (skip) {
+ 			skip--;
+ 			continue;
+ 		}
+ 		dtp = phba->nvmeio_trc + i;
+ 		phba->nvmeio_trc_output_idx++;
+ 
+ 		if (!dtp->fmt)
+ 			continue;
+ 
+ 		len +=  snprintf(buf + len, size - len, dtp->fmt,
+ 			dtp->data1, dtp->data2, dtp->data3);
+ 
+ 		if (phba->nvmeio_trc_output_idx >= phba->nvmeio_trc_size) {
+ 			phba->nvmeio_trc_output_idx = 0;
+ 			len += snprintf(buf + len, size - len,
+ 					"Trace Complete\n");
+ 			goto out;
+ 		}
+ 
+ 		if (len >= (size - LPFC_DEBUG_OUT_LINE_SZ)) {
+ 			len += snprintf(buf + len, size - len,
+ 					"Trace Continue (%d of %d)\n",
+ 					phba->nvmeio_trc_output_idx,
+ 					phba->nvmeio_trc_size);
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	len += snprintf(buf + len, size - len,
+ 			"Trace Done\n");
+ out:
+ 	return len;
+ }
+ 
+ /**
+  * lpfc_debugfs_cpucheck_data - Dump target node list to a buffer
+  * @vport: The vport to gather target node info from.
+  * @buf: The buffer to dump log into.
+  * @size: The maximum amount of data to process.
+  *
+  * Description:
+  * This routine dumps the NVME statistics associated with @vport
+  *
+  * Return Value:
+  * This routine returns the amount of bytes that were dumped into @buf and will
+  * not exceed @size.
+  **/
+ static int
+ lpfc_debugfs_cpucheck_data(struct lpfc_vport *vport, char *buf, int size)
+ {
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	int i;
+ 	int len = 0;
+ 	uint32_t tot_xmt = 0;
+ 	uint32_t tot_rcv = 0;
+ 	uint32_t tot_cmpl = 0;
+ 	uint32_t tot_ccmpl = 0;
+ 
+ 	if (phba->nvmet_support == 0) {
+ 		/* NVME Initiator */
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"CPUcheck %s\n",
+ 				(phba->cpucheck_on & LPFC_CHECK_NVME_IO ?
+ 					"Enabled" : "Disabled"));
+ 		for (i = 0; i < phba->sli4_hba.num_present_cpu; i++) {
+ 			if (i >= LPFC_CHECK_CPU_CNT)
+ 				break;
+ 			len += snprintf(buf + len, PAGE_SIZE - len,
+ 					"%02d: xmit x%08x cmpl x%08x\n",
+ 					i, phba->cpucheck_xmt_io[i],
+ 					phba->cpucheck_cmpl_io[i]);
+ 			tot_xmt += phba->cpucheck_xmt_io[i];
+ 			tot_cmpl += phba->cpucheck_cmpl_io[i];
+ 		}
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"tot:xmit x%08x cmpl x%08x\n",
+ 				tot_xmt, tot_cmpl);
+ 		return len;
+ 	}
+ 
+ 	/* NVME Target */
+ 	len += snprintf(buf + len, PAGE_SIZE - len,
+ 			"CPUcheck %s ",
+ 			(phba->cpucheck_on & LPFC_CHECK_NVMET_IO ?
+ 				"IO Enabled - " : "IO Disabled - "));
+ 	len += snprintf(buf + len, PAGE_SIZE - len,
+ 			"%s\n",
+ 			(phba->cpucheck_on & LPFC_CHECK_NVMET_RCV ?
+ 				"Rcv Enabled\n" : "Rcv Disabled\n"));
+ 	for (i = 0; i < phba->sli4_hba.num_present_cpu; i++) {
+ 		if (i >= LPFC_CHECK_CPU_CNT)
+ 			break;
+ 		len += snprintf(buf + len, PAGE_SIZE - len,
+ 				"%02d: xmit x%08x ccmpl x%08x "
+ 				"cmpl x%08x rcv x%08x\n",
+ 				i, phba->cpucheck_xmt_io[i],
+ 				phba->cpucheck_ccmpl_io[i],
+ 				phba->cpucheck_cmpl_io[i],
+ 				phba->cpucheck_rcv_io[i]);
+ 		tot_xmt += phba->cpucheck_xmt_io[i];
+ 		tot_rcv += phba->cpucheck_rcv_io[i];
+ 		tot_cmpl += phba->cpucheck_cmpl_io[i];
+ 		tot_ccmpl += phba->cpucheck_ccmpl_io[i];
+ 	}
+ 	len += snprintf(buf + len, PAGE_SIZE - len,
+ 			"tot:xmit x%08x ccmpl x%08x cmpl x%08x rcv x%08x\n",
+ 			tot_xmt, tot_ccmpl, tot_cmpl, tot_rcv);
+ 	return len;
+ }
+ 
++>>>>>>> 2b65e18202fd (scsi: lpfc: NVME Target: Add debugfs support)
  #endif
  
  /**
@@@ -1243,6 -1864,422 +1847,425 @@@ lpfc_debugfs_dumpDataDif_release(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ 
+ static int
+ lpfc_debugfs_nvmestat_open(struct inode *inode, struct file *file)
+ {
+ 	struct lpfc_vport *vport = inode->i_private;
+ 	struct lpfc_debug *debug;
+ 	int rc = -ENOMEM;
+ 
+ 	debug = kmalloc(sizeof(*debug), GFP_KERNEL);
+ 	if (!debug)
+ 		goto out;
+ 
+ 	 /* Round to page boundary */
+ 	debug->buffer = kmalloc(LPFC_NVMESTAT_SIZE, GFP_KERNEL);
+ 	if (!debug->buffer) {
+ 		kfree(debug);
+ 		goto out;
+ 	}
+ 
+ 	debug->len = lpfc_debugfs_nvmestat_data(vport, debug->buffer,
+ 		LPFC_NVMESTAT_SIZE);
+ 
+ 	debug->i_private = inode->i_private;
+ 	file->private_data = debug;
+ 
+ 	rc = 0;
+ out:
+ 	return rc;
+ }
+ 
+ static ssize_t
+ lpfc_debugfs_nvmestat_write(struct file *file, const char __user *buf,
+ 			    size_t nbytes, loff_t *ppos)
+ {
+ 	struct lpfc_debug *debug = file->private_data;
+ 	struct lpfc_vport *vport = (struct lpfc_vport *)debug->i_private;
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	struct lpfc_nvmet_tgtport *tgtp;
+ 	char mybuf[64];
+ 	char *pbuf;
+ 
+ 	if (!phba->targetport)
+ 		return -ENXIO;
+ 
+ 	if (nbytes > 64)
+ 		nbytes = 64;
+ 
+ 	/* Protect copy from user */
+ 	if (!access_ok(VERIFY_READ, buf, nbytes))
+ 		return -EFAULT;
+ 
+ 	memset(mybuf, 0, sizeof(mybuf));
+ 
+ 	if (copy_from_user(mybuf, buf, nbytes))
+ 		return -EFAULT;
+ 	pbuf = &mybuf[0];
+ 
+ 	tgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;
+ 	if ((strncmp(pbuf, "reset", strlen("reset")) == 0) ||
+ 	    (strncmp(pbuf, "zero", strlen("zero")) == 0)) {
+ 		atomic_set(&tgtp->rcv_ls_req_in, 0);
+ 		atomic_set(&tgtp->rcv_ls_req_out, 0);
+ 		atomic_set(&tgtp->rcv_ls_req_drop, 0);
+ 		atomic_set(&tgtp->xmt_ls_abort, 0);
+ 		atomic_set(&tgtp->xmt_ls_rsp, 0);
+ 		atomic_set(&tgtp->xmt_ls_drop, 0);
+ 		atomic_set(&tgtp->xmt_ls_rsp_error, 0);
+ 		atomic_set(&tgtp->xmt_ls_rsp_cmpl, 0);
+ 
+ 		atomic_set(&tgtp->rcv_fcp_cmd_in, 0);
+ 		atomic_set(&tgtp->rcv_fcp_cmd_out, 0);
+ 		atomic_set(&tgtp->rcv_fcp_cmd_drop, 0);
+ 		atomic_set(&tgtp->xmt_fcp_abort, 0);
+ 		atomic_set(&tgtp->xmt_fcp_drop, 0);
+ 		atomic_set(&tgtp->xmt_fcp_read_rsp, 0);
+ 		atomic_set(&tgtp->xmt_fcp_read, 0);
+ 		atomic_set(&tgtp->xmt_fcp_write, 0);
+ 		atomic_set(&tgtp->xmt_fcp_rsp, 0);
+ 		atomic_set(&tgtp->xmt_fcp_rsp_cmpl, 0);
+ 		atomic_set(&tgtp->xmt_fcp_rsp_error, 0);
+ 		atomic_set(&tgtp->xmt_fcp_rsp_drop, 0);
+ 
+ 		atomic_set(&tgtp->xmt_abort_rsp, 0);
+ 		atomic_set(&tgtp->xmt_abort_rsp_error, 0);
+ 		atomic_set(&tgtp->xmt_abort_cmpl, 0);
+ 	}
+ 	return nbytes;
+ }
+ 
+ static int
+ lpfc_debugfs_nvmektime_open(struct inode *inode, struct file *file)
+ {
+ 	struct lpfc_vport *vport = inode->i_private;
+ 	struct lpfc_debug *debug;
+ 	int rc = -ENOMEM;
+ 
+ 	debug = kmalloc(sizeof(*debug), GFP_KERNEL);
+ 	if (!debug)
+ 		goto out;
+ 
+ 	 /* Round to page boundary */
+ 	debug->buffer = kmalloc(LPFC_NVMEKTIME_SIZE, GFP_KERNEL);
+ 	if (!debug->buffer) {
+ 		kfree(debug);
+ 		goto out;
+ 	}
+ 
+ 	debug->len = lpfc_debugfs_nvmektime_data(vport, debug->buffer,
+ 		LPFC_NVMEKTIME_SIZE);
+ 
+ 	debug->i_private = inode->i_private;
+ 	file->private_data = debug;
+ 
+ 	rc = 0;
+ out:
+ 	return rc;
+ }
+ 
+ static ssize_t
+ lpfc_debugfs_nvmektime_write(struct file *file, const char __user *buf,
+ 			     size_t nbytes, loff_t *ppos)
+ {
+ 	struct lpfc_debug *debug = file->private_data;
+ 	struct lpfc_vport *vport = (struct lpfc_vport *)debug->i_private;
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	char mybuf[64];
+ 	char *pbuf;
+ 
+ 	if (nbytes > 64)
+ 		nbytes = 64;
+ 
+ 	/* Protect copy from user */
+ 	if (!access_ok(VERIFY_READ, buf, nbytes))
+ 		return -EFAULT;
+ 
+ 	memset(mybuf, 0, sizeof(mybuf));
+ 
+ 	if (copy_from_user(mybuf, buf, nbytes))
+ 		return -EFAULT;
+ 	pbuf = &mybuf[0];
+ 
+ 	if ((strncmp(pbuf, "on", sizeof("on") - 1) == 0)) {
+ 		phba->ktime_data_samples = 0;
+ 		phba->ktime_status_samples = 0;
+ 		phba->ktime_seg1_total = 0;
+ 		phba->ktime_seg1_max = 0;
+ 		phba->ktime_seg1_min = 0xffffffff;
+ 		phba->ktime_seg2_total = 0;
+ 		phba->ktime_seg2_max = 0;
+ 		phba->ktime_seg2_min = 0xffffffff;
+ 		phba->ktime_seg3_total = 0;
+ 		phba->ktime_seg3_max = 0;
+ 		phba->ktime_seg3_min = 0xffffffff;
+ 		phba->ktime_seg4_total = 0;
+ 		phba->ktime_seg4_max = 0;
+ 		phba->ktime_seg4_min = 0xffffffff;
+ 		phba->ktime_seg5_total = 0;
+ 		phba->ktime_seg5_max = 0;
+ 		phba->ktime_seg5_min = 0xffffffff;
+ 		phba->ktime_seg6_total = 0;
+ 		phba->ktime_seg6_max = 0;
+ 		phba->ktime_seg6_min = 0xffffffff;
+ 		phba->ktime_seg7_total = 0;
+ 		phba->ktime_seg7_max = 0;
+ 		phba->ktime_seg7_min = 0xffffffff;
+ 		phba->ktime_seg8_total = 0;
+ 		phba->ktime_seg8_max = 0;
+ 		phba->ktime_seg8_min = 0xffffffff;
+ 		phba->ktime_seg9_total = 0;
+ 		phba->ktime_seg9_max = 0;
+ 		phba->ktime_seg9_min = 0xffffffff;
+ 		phba->ktime_seg10_total = 0;
+ 		phba->ktime_seg10_max = 0;
+ 		phba->ktime_seg10_min = 0xffffffff;
+ 
+ 		phba->ktime_on = 1;
+ 		return strlen(pbuf);
+ 	} else if ((strncmp(pbuf, "off",
+ 		   sizeof("off") - 1) == 0)) {
+ 		phba->ktime_on = 0;
+ 		return strlen(pbuf);
+ 	} else if ((strncmp(pbuf, "zero",
+ 		   sizeof("zero") - 1) == 0)) {
+ 		phba->ktime_data_samples = 0;
+ 		phba->ktime_status_samples = 0;
+ 		phba->ktime_seg1_total = 0;
+ 		phba->ktime_seg1_max = 0;
+ 		phba->ktime_seg1_min = 0xffffffff;
+ 		phba->ktime_seg2_total = 0;
+ 		phba->ktime_seg2_max = 0;
+ 		phba->ktime_seg2_min = 0xffffffff;
+ 		phba->ktime_seg3_total = 0;
+ 		phba->ktime_seg3_max = 0;
+ 		phba->ktime_seg3_min = 0xffffffff;
+ 		phba->ktime_seg4_total = 0;
+ 		phba->ktime_seg4_max = 0;
+ 		phba->ktime_seg4_min = 0xffffffff;
+ 		phba->ktime_seg5_total = 0;
+ 		phba->ktime_seg5_max = 0;
+ 		phba->ktime_seg5_min = 0xffffffff;
+ 		phba->ktime_seg6_total = 0;
+ 		phba->ktime_seg6_max = 0;
+ 		phba->ktime_seg6_min = 0xffffffff;
+ 		phba->ktime_seg7_total = 0;
+ 		phba->ktime_seg7_max = 0;
+ 		phba->ktime_seg7_min = 0xffffffff;
+ 		phba->ktime_seg8_total = 0;
+ 		phba->ktime_seg8_max = 0;
+ 		phba->ktime_seg8_min = 0xffffffff;
+ 		phba->ktime_seg9_total = 0;
+ 		phba->ktime_seg9_max = 0;
+ 		phba->ktime_seg9_min = 0xffffffff;
+ 		phba->ktime_seg10_total = 0;
+ 		phba->ktime_seg10_max = 0;
+ 		phba->ktime_seg10_min = 0xffffffff;
+ 		return strlen(pbuf);
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ static int
+ lpfc_debugfs_nvmeio_trc_open(struct inode *inode, struct file *file)
+ {
+ 	struct lpfc_hba *phba = inode->i_private;
+ 	struct lpfc_debug *debug;
+ 	int rc = -ENOMEM;
+ 
+ 	debug = kmalloc(sizeof(*debug), GFP_KERNEL);
+ 	if (!debug)
+ 		goto out;
+ 
+ 	 /* Round to page boundary */
+ 	debug->buffer = kmalloc(LPFC_NVMEIO_TRC_SIZE, GFP_KERNEL);
+ 	if (!debug->buffer) {
+ 		kfree(debug);
+ 		goto out;
+ 	}
+ 
+ 	debug->len = lpfc_debugfs_nvmeio_trc_data(phba, debug->buffer,
+ 		LPFC_NVMEIO_TRC_SIZE);
+ 
+ 	debug->i_private = inode->i_private;
+ 	file->private_data = debug;
+ 
+ 	rc = 0;
+ out:
+ 	return rc;
+ }
+ 
+ static ssize_t
+ lpfc_debugfs_nvmeio_trc_write(struct file *file, const char __user *buf,
+ 			      size_t nbytes, loff_t *ppos)
+ {
+ 	struct lpfc_debug *debug = file->private_data;
+ 	struct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;
+ 	int i;
+ 	unsigned long sz;
+ 	char mybuf[64];
+ 	char *pbuf;
+ 
+ 	if (nbytes > 64)
+ 		nbytes = 64;
+ 
+ 	/* Protect copy from user */
+ 	if (!access_ok(VERIFY_READ, buf, nbytes))
+ 		return -EFAULT;
+ 
+ 	memset(mybuf, 0, sizeof(mybuf));
+ 
+ 	if (copy_from_user(mybuf, buf, nbytes))
+ 		return -EFAULT;
+ 	pbuf = &mybuf[0];
+ 
+ 	if ((strncmp(pbuf, "off", sizeof("off") - 1) == 0)) {
+ 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 				"0570 nvmeio_trc_off\n");
+ 		phba->nvmeio_trc_output_idx = 0;
+ 		phba->nvmeio_trc_on = 0;
+ 		return strlen(pbuf);
+ 	} else if ((strncmp(pbuf, "on", sizeof("on") - 1) == 0)) {
+ 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 				"0571 nvmeio_trc_on\n");
+ 		phba->nvmeio_trc_output_idx = 0;
+ 		phba->nvmeio_trc_on = 1;
+ 		return strlen(pbuf);
+ 	}
+ 
+ 	/* We must be off to allocate the trace buffer */
+ 	if (phba->nvmeio_trc_on != 0)
+ 		return -EINVAL;
+ 
+ 	/* If not on or off, the parameter is the trace buffer size */
+ 	i = kstrtoul(pbuf, 0, &sz);
+ 	if (i)
+ 		return -EINVAL;
+ 	phba->nvmeio_trc_size = (uint32_t)sz;
+ 
+ 	/* It must be a power of 2 - round down */
+ 	i = 0;
+ 	while (sz > 1) {
+ 		sz = sz >> 1;
+ 		i++;
+ 	}
+ 	sz = (1 << i);
+ 	if (phba->nvmeio_trc_size != sz)
+ 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 				"0572 nvmeio_trc_size changed to %ld\n",
+ 				sz);
+ 	phba->nvmeio_trc_size = (uint32_t)sz;
+ 
+ 	/* If one previously exists, free it */
+ 	kfree(phba->nvmeio_trc);
+ 
+ 	/* Allocate new trace buffer and initialize */
+ 	phba->nvmeio_trc = kmalloc((sizeof(struct lpfc_debugfs_nvmeio_trc) *
+ 				    sz), GFP_KERNEL);
+ 	if (!phba->nvmeio_trc) {
+ 		lpfc_printf_log(phba, KERN_ERR, LOG_INIT,
+ 				"0573 Cannot create debugfs "
+ 				"nvmeio_trc buffer\n");
+ 		return -ENOMEM;
+ 	}
+ 	memset(phba->nvmeio_trc, 0,
+ 	       (sizeof(struct lpfc_debugfs_nvmeio_trc) * sz));
+ 	atomic_set(&phba->nvmeio_trc_cnt, 0);
+ 	phba->nvmeio_trc_on = 0;
+ 	phba->nvmeio_trc_output_idx = 0;
+ 
+ 	return strlen(pbuf);
+ }
+ 
+ static int
+ lpfc_debugfs_cpucheck_open(struct inode *inode, struct file *file)
+ {
+ 	struct lpfc_vport *vport = inode->i_private;
+ 	struct lpfc_debug *debug;
+ 	int rc = -ENOMEM;
+ 
+ 	debug = kmalloc(sizeof(*debug), GFP_KERNEL);
+ 	if (!debug)
+ 		goto out;
+ 
+ 	 /* Round to page boundary */
+ 	debug->buffer = kmalloc(LPFC_CPUCHECK_SIZE, GFP_KERNEL);
+ 	if (!debug->buffer) {
+ 		kfree(debug);
+ 		goto out;
+ 	}
+ 
+ 	debug->len = lpfc_debugfs_cpucheck_data(vport, debug->buffer,
+ 		LPFC_NVMEKTIME_SIZE);
+ 
+ 	debug->i_private = inode->i_private;
+ 	file->private_data = debug;
+ 
+ 	rc = 0;
+ out:
+ 	return rc;
+ }
+ 
+ static ssize_t
+ lpfc_debugfs_cpucheck_write(struct file *file, const char __user *buf,
+ 			    size_t nbytes, loff_t *ppos)
+ {
+ 	struct lpfc_debug *debug = file->private_data;
+ 	struct lpfc_vport *vport = (struct lpfc_vport *)debug->i_private;
+ 	struct lpfc_hba   *phba = vport->phba;
+ 	char mybuf[64];
+ 	char *pbuf;
+ 	int i;
+ 
+ 	if (nbytes > 64)
+ 		nbytes = 64;
+ 
+ 	/* Protect copy from user */
+ 	if (!access_ok(VERIFY_READ, buf, nbytes))
+ 		return -EFAULT;
+ 
+ 	memset(mybuf, 0, sizeof(mybuf));
+ 
+ 	if (copy_from_user(mybuf, buf, nbytes))
+ 		return -EFAULT;
+ 	pbuf = &mybuf[0];
+ 
+ 	if ((strncmp(pbuf, "on", sizeof("on") - 1) == 0)) {
+ 		if (phba->nvmet_support)
+ 			phba->cpucheck_on |= LPFC_CHECK_NVMET_IO;
+ 		else
+ 			phba->cpucheck_on |= LPFC_CHECK_NVME_IO;
+ 		return strlen(pbuf);
+ 	} else if ((strncmp(pbuf, "rcv",
+ 		   sizeof("rcv") - 1) == 0)) {
+ 		if (phba->nvmet_support)
+ 			phba->cpucheck_on |= LPFC_CHECK_NVMET_RCV;
+ 		else
+ 			return -EINVAL;
+ 		return strlen(pbuf);
+ 	} else if ((strncmp(pbuf, "off",
+ 		   sizeof("off") - 1) == 0)) {
+ 		phba->cpucheck_on = LPFC_CHECK_OFF;
+ 		return strlen(pbuf);
+ 	} else if ((strncmp(pbuf, "zero",
+ 		   sizeof("zero") - 1) == 0)) {
+ 		for (i = 0; i < phba->sli4_hba.num_present_cpu; i++) {
+ 			if (i >= LPFC_CHECK_CPU_CNT)
+ 				break;
+ 			phba->cpucheck_rcv_io[i] = 0;
+ 			phba->cpucheck_xmt_io[i] = 0;
+ 			phba->cpucheck_cmpl_io[i] = 0;
+ 			phba->cpucheck_ccmpl_io[i] = 0;
+ 		}
+ 		return strlen(pbuf);
+ 	}
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> 2b65e18202fd (scsi: lpfc: NVME Target: Add debugfs support)
  /*
   * ---------------------------------
   * iDiag debugfs file access methods
@@@ -2112,6 -3157,46 +3135,49 @@@ lpfc_idiag_cqs_for_eq(struct lpfc_hba *
  			return 1;
  	}
  
++<<<<<<< HEAD
++=======
+ 	for (qidx = 0; qidx < phba->cfg_nvme_io_channel; qidx++) {
+ 		qp = phba->sli4_hba.nvme_cq[qidx];
+ 		if (qp->assoc_qid != eq_id)
+ 			continue;
+ 
+ 		*len = __lpfc_idiag_print_cq(qp, "NVME", pbuffer, *len);
+ 
+ 		/* Reset max counter */
+ 		qp->CQ_max_cqe = 0;
+ 
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 
+ 		rc = lpfc_idiag_wqs_for_cq(phba, "NVME", pbuffer, len,
+ 				max_cnt, qp->queue_id);
+ 		if (rc)
+ 			return 1;
+ 	}
+ 
+ 	if (eqidx < phba->cfg_nvmet_mrq) {
+ 		/* NVMET CQset */
+ 		qp = phba->sli4_hba.nvmet_cqset[eqidx];
+ 		*len = __lpfc_idiag_print_cq(qp, "NVMET CQset", pbuffer, *len);
+ 
+ 		/* Reset max counter */
+ 		qp->CQ_max_cqe = 0;
+ 
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 
+ 		/* RQ header */
+ 		qp = phba->sli4_hba.nvmet_mrq_hdr[eqidx];
+ 		*len = __lpfc_idiag_print_rqpair(qp,
+ 				phba->sli4_hba.nvmet_mrq_data[eqidx],
+ 				"NVMET MRQ", pbuffer, *len);
+ 
+ 		if (*len >= max_cnt)
+ 			return 1;
+ 	}
+ 
++>>>>>>> 2b65e18202fd (scsi: lpfc: NVME Target: Add debugfs support)
  	return 0;
  }
  
@@@ -3591,6 -4783,46 +4657,49 @@@ static const struct file_operations lpf
  	.release =      lpfc_debugfs_release,
  };
  
++<<<<<<< HEAD
++=======
+ #undef lpfc_debugfs_op_nvmestat
+ static const struct file_operations lpfc_debugfs_op_nvmestat = {
+ 	.owner =        THIS_MODULE,
+ 	.open =         lpfc_debugfs_nvmestat_open,
+ 	.llseek =       lpfc_debugfs_lseek,
+ 	.read =         lpfc_debugfs_read,
+ 	.write =	lpfc_debugfs_nvmestat_write,
+ 	.release =      lpfc_debugfs_release,
+ };
+ 
+ #undef lpfc_debugfs_op_nvmektime
+ static const struct file_operations lpfc_debugfs_op_nvmektime = {
+ 	.owner =        THIS_MODULE,
+ 	.open =         lpfc_debugfs_nvmektime_open,
+ 	.llseek =       lpfc_debugfs_lseek,
+ 	.read =         lpfc_debugfs_read,
+ 	.write =	lpfc_debugfs_nvmektime_write,
+ 	.release =      lpfc_debugfs_release,
+ };
+ 
+ #undef lpfc_debugfs_op_nvmeio_trc
+ static const struct file_operations lpfc_debugfs_op_nvmeio_trc = {
+ 	.owner =        THIS_MODULE,
+ 	.open =         lpfc_debugfs_nvmeio_trc_open,
+ 	.llseek =       lpfc_debugfs_lseek,
+ 	.read =         lpfc_debugfs_read,
+ 	.write =	lpfc_debugfs_nvmeio_trc_write,
+ 	.release =      lpfc_debugfs_release,
+ };
+ 
+ #undef lpfc_debugfs_op_cpucheck
+ static const struct file_operations lpfc_debugfs_op_cpucheck = {
+ 	.owner =        THIS_MODULE,
+ 	.open =         lpfc_debugfs_cpucheck_open,
+ 	.llseek =       lpfc_debugfs_lseek,
+ 	.read =         lpfc_debugfs_read,
+ 	.write =	lpfc_debugfs_cpucheck_write,
+ 	.release =      lpfc_debugfs_release,
+ };
+ 
++>>>>>>> 2b65e18202fd (scsi: lpfc: NVME Target: Add debugfs support)
  #undef lpfc_debugfs_op_dumpData
  static const struct file_operations lpfc_debugfs_op_dumpData = {
  	.owner =        THIS_MODULE,
* Unmerged path drivers/scsi/lpfc/lpfc_nvmet.c
* Unmerged path drivers/scsi/lpfc/lpfc_nvmet.h
* Unmerged path drivers/scsi/lpfc/lpfc_debugfs.c
* Unmerged path drivers/scsi/lpfc/lpfc_nvmet.c
* Unmerged path drivers/scsi/lpfc/lpfc_nvmet.h
