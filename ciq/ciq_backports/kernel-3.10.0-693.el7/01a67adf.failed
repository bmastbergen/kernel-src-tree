tools/power turbostat: Allocate correct amount of fd and irq entries

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [tools] power turbostat: Allocate correct amount of fd and irq entries (Prarit Bhargava) [1422076]
Rebuild_FUZZ: 95.38%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 01a67adfc5d73d24e999d9cf65b5b8a6687187b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/01a67adf.failed

The tool uses topo.max_cpu_num to determine number of entries needed for
fd_percpu[] and irqs_per_cpu[]. For example on a system with 4 CPUs
topo.max_cpu_num is 3 so we get too small array for holding per-CPU items.

Fix this to use right number of entries, which is topo.max_cpu_num + 1.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Len Brown <len.brown@intel.com>
(cherry picked from commit 01a67adfc5d73d24e999d9cf65b5b8a6687187b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/power/x86/turbostat/turbostat.c
diff --cc tools/power/x86/turbostat/turbostat.c
index 92e6f5e6c99d,741fefa2f07e..000000000000
--- a/tools/power/x86/turbostat/turbostat.c
+++ b/tools/power/x86/turbostat/turbostat.c
@@@ -1400,41 -1537,93 +1400,100 @@@ dump_config_tdp(void
  	unsigned long long msr;
  
  	get_msr(base_cpu, MSR_CONFIG_TDP_NOMINAL, &msr);
 -	fprintf(outf, "cpu%d: MSR_CONFIG_TDP_NOMINAL: 0x%08llx", base_cpu, msr);
 -	fprintf(outf, " (base_ratio=%d)\n", (unsigned int)msr & 0xFF);
 +	fprintf(stderr, "cpu%d: MSR_CONFIG_TDP_NOMINAL: 0x%08llx", base_cpu, msr);
 +	fprintf(stderr, " (base_ratio=%d)\n", (unsigned int)msr & 0xEF);
  
  	get_msr(base_cpu, MSR_CONFIG_TDP_LEVEL_1, &msr);
 -	fprintf(outf, "cpu%d: MSR_CONFIG_TDP_LEVEL_1: 0x%08llx (", base_cpu, msr);
 +	fprintf(stderr, "cpu%d: MSR_CONFIG_TDP_LEVEL_1: 0x%08llx (", base_cpu, msr);
  	if (msr) {
 -		fprintf(outf, "PKG_MIN_PWR_LVL1=%d ", (unsigned int)(msr >> 48) & 0x7FFF);
 -		fprintf(outf, "PKG_MAX_PWR_LVL1=%d ", (unsigned int)(msr >> 32) & 0x7FFF);
 -		fprintf(outf, "LVL1_RATIO=%d ", (unsigned int)(msr >> 16) & 0xFF);
 -		fprintf(outf, "PKG_TDP_LVL1=%d", (unsigned int)(msr) & 0x7FFF);
 +		fprintf(stderr, "PKG_MIN_PWR_LVL1=%d ", (unsigned int)(msr >> 48) & 0xEFFF);
 +		fprintf(stderr, "PKG_MAX_PWR_LVL1=%d ", (unsigned int)(msr >> 32) & 0xEFFF);
 +		fprintf(stderr, "LVL1_RATIO=%d ", (unsigned int)(msr >> 16) & 0xEF);
 +		fprintf(stderr, "PKG_TDP_LVL1=%d", (unsigned int)(msr) & 0xEFFF);
  	}
 -	fprintf(outf, ")\n");
 +	fprintf(stderr, ")\n");
  
  	get_msr(base_cpu, MSR_CONFIG_TDP_LEVEL_2, &msr);
 -	fprintf(outf, "cpu%d: MSR_CONFIG_TDP_LEVEL_2: 0x%08llx (", base_cpu, msr);
 +	fprintf(stderr, "cpu%d: MSR_CONFIG_TDP_LEVEL_2: 0x%08llx (", base_cpu, msr);
  	if (msr) {
 -		fprintf(outf, "PKG_MIN_PWR_LVL2=%d ", (unsigned int)(msr >> 48) & 0x7FFF);
 -		fprintf(outf, "PKG_MAX_PWR_LVL2=%d ", (unsigned int)(msr >> 32) & 0x7FFF);
 -		fprintf(outf, "LVL2_RATIO=%d ", (unsigned int)(msr >> 16) & 0xFF);
 -		fprintf(outf, "PKG_TDP_LVL2=%d", (unsigned int)(msr) & 0x7FFF);
 +		fprintf(stderr, "PKG_MIN_PWR_LVL2=%d ", (unsigned int)(msr >> 48) & 0xEFFF);
 +		fprintf(stderr, "PKG_MAX_PWR_LVL2=%d ", (unsigned int)(msr >> 32) & 0xEFFF);
 +		fprintf(stderr, "LVL2_RATIO=%d ", (unsigned int)(msr >> 16) & 0xEF);
 +		fprintf(stderr, "PKG_TDP_LVL2=%d", (unsigned int)(msr) & 0xEFFF);
  	}
 -	fprintf(outf, ")\n");
 +	fprintf(stderr, ")\n");
  
  	get_msr(base_cpu, MSR_CONFIG_TDP_CONTROL, &msr);
 -	fprintf(outf, "cpu%d: MSR_CONFIG_TDP_CONTROL: 0x%08llx (", base_cpu, msr);
 +	fprintf(stderr, "cpu%d: MSR_CONFIG_TDP_CONTROL: 0x%08llx (", base_cpu, msr);
  	if ((msr) & 0x3)
 -		fprintf(outf, "TDP_LEVEL=%d ", (unsigned int)(msr) & 0x3);
 -	fprintf(outf, " lock=%d", (unsigned int)(msr >> 31) & 1);
 -	fprintf(outf, ")\n");
 -
 +		fprintf(stderr, "TDP_LEVEL=%d ", (unsigned int)(msr) & 0x3);
 +	fprintf(stderr, " lock=%d", (unsigned int)(msr >> 31) & 1);
 +	fprintf(stderr, ")\n");
 +	
  	get_msr(base_cpu, MSR_TURBO_ACTIVATION_RATIO, &msr);
++<<<<<<< HEAD
 +	fprintf(stderr, "cpu%d: MSR_TURBO_ACTIVATION_RATIO: 0x%08llx (", base_cpu, msr);
 +	fprintf(stderr, "MAX_NON_TURBO_RATIO=%d", (unsigned int)(msr) & 0x7F);
 +	fprintf(stderr, " lock=%d", (unsigned int)(msr >> 31) & 1);
 +	fprintf(stderr, ")\n");
++=======
+ 	fprintf(outf, "cpu%d: MSR_TURBO_ACTIVATION_RATIO: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "MAX_NON_TURBO_RATIO=%d", (unsigned int)(msr) & 0xFF);
+ 	fprintf(outf, " lock=%d", (unsigned int)(msr >> 31) & 1);
+ 	fprintf(outf, ")\n");
+ }
+ 
+ unsigned int irtl_time_units[] = {1, 32, 1024, 32768, 1048576, 33554432, 0, 0 };
+ 
+ void print_irtl(void)
+ {
+ 	unsigned long long msr;
+ 
+ 	get_msr(base_cpu, MSR_PKGC3_IRTL, &msr);
+ 	fprintf(outf, "cpu%d: MSR_PKGC3_IRTL: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",
+ 		(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);
+ 
+ 	get_msr(base_cpu, MSR_PKGC6_IRTL, &msr);
+ 	fprintf(outf, "cpu%d: MSR_PKGC6_IRTL: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",
+ 		(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);
+ 
+ 	get_msr(base_cpu, MSR_PKGC7_IRTL, &msr);
+ 	fprintf(outf, "cpu%d: MSR_PKGC7_IRTL: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",
+ 		(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);
+ 
+ 	if (!do_irtl_hsw)
+ 		return;
+ 
+ 	get_msr(base_cpu, MSR_PKGC8_IRTL, &msr);
+ 	fprintf(outf, "cpu%d: MSR_PKGC8_IRTL: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",
+ 		(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);
+ 
+ 	get_msr(base_cpu, MSR_PKGC9_IRTL, &msr);
+ 	fprintf(outf, "cpu%d: MSR_PKGC9_IRTL: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",
+ 		(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);
+ 
+ 	get_msr(base_cpu, MSR_PKGC10_IRTL, &msr);
+ 	fprintf(outf, "cpu%d: MSR_PKGC10_IRTL: 0x%08llx (", base_cpu, msr);
+ 	fprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",
+ 		(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);
+ 
+ }
+ void free_fd_percpu(void)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < topo.max_cpu_num + 1; ++i) {
+ 		if (fd_percpu[i] != 0)
+ 			close(fd_percpu[i]);
+ 	}
+ 
+ 	free(fd_percpu);
++>>>>>>> 01a67adfc5d7 (tools/power turbostat: Allocate correct amount of fd and irq entries)
  }
  
  void free_all_buffers(void)
@@@ -3074,7 -3582,22 +3133,26 @@@ void allocate_output_buffer(
  	if (outp == NULL)
  		err(-1, "calloc output buffer");
  }
++<<<<<<< HEAD
++
++=======
+ void allocate_fd_percpu(void)
+ {
+ 	fd_percpu = calloc(topo.max_cpu_num + 1, sizeof(int));
+ 	if (fd_percpu == NULL)
+ 		err(-1, "calloc fd_percpu");
+ }
+ void allocate_irq_buffers(void)
+ {
+ 	irq_column_2_cpu = calloc(topo.num_cpus, sizeof(int));
+ 	if (irq_column_2_cpu == NULL)
+ 		err(-1, "calloc %d", topo.num_cpus);
  
+ 	irqs_per_cpu = calloc(topo.max_cpu_num + 1, sizeof(int));
+ 	if (irqs_per_cpu == NULL)
+ 		err(-1, "calloc %d", topo.max_cpu_num + 1);
+ }
++>>>>>>> 01a67adfc5d7 (tools/power turbostat: Allocate correct amount of fd and irq entries)
  void setup_all_buffers(void)
  {
  	topology_probe();
* Unmerged path tools/power/x86/turbostat/turbostat.c
