remove lots of IS_ERR_VALUE abuses

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Arnd Bergmann <arnd@arndb.de>
commit 287980e49ffc0f6d911601e7e352a812ed27768e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/287980e4.failed

Most users of IS_ERR_VALUE() in the kernel are wrong, as they
pass an 'int' into a function that takes an 'unsigned long'
argument. This happens to work because the type is sign-extended
on 64-bit architectures before it gets converted into an
unsigned type.

However, anything that passes an 'unsigned short' or 'unsigned int'
argument into IS_ERR_VALUE() is guaranteed to be broken, as are
8-bit integers and types that are wider than 'unsigned long'.

Andrzej Hajda has already fixed a lot of the worst abusers that
were causing actual bugs, but it would be nice to prevent any
users that are not passing 'unsigned long' arguments.

This patch changes all users of IS_ERR_VALUE() that I could find
on 32-bit ARM randconfig builds and x86 allmodconfig. For the
moment, this doesn't change the definition of IS_ERR_VALUE()
because there are probably still architecture specific users
elsewhere.

Almost all the warnings I got are for files that are better off
using 'if (err)' or 'if (err < 0)'.
The only legitimate user I could find that we get a warning for
is the (32-bit only) freescale fman driver, so I did not remove
the IS_ERR_VALUE() there but changed the type to 'unsigned long'.
For 9pfs, I just worked around one user whose calling conventions
are so obscure that I did not dare change the behavior.

I was using this definition for testing:

 #define IS_ERR_VALUE(x) ((unsigned long*)NULL == (typeof (x)*)NULL && \
       unlikely((unsigned long long)(x) >= (unsigned long long)(typeof(x))-MAX_ERRNO))

which ends up making all 16-bit or wider types work correctly with
the most plausible interpretation of what IS_ERR_VALUE() was supposed
to return according to its users, but also causes a compile-time
warning for any users that do not pass an 'unsigned long' argument.

I suggested this approach earlier this year, but back then we ended
up deciding to just fix the users that are obviously broken. After
the initial warning that caused me to get involved in the discussion
(fs/gfs2/dir.c) showed up again in the mainline kernel, Linus
asked me to send the whole thing again.

[ Updated the 9p parts as per Al Viro  - Linus ]

	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Cc: Andrzej Hajda <a.hajda@samsung.com>
	Cc: Andrew Morton <akpm@linux-foundation.org>
Link: https://lkml.org/lkml/2016/1/7/363
Link: https://lkml.org/lkml/2016/5/27/486
	Acked-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org> # For nvmem part
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 287980e49ffc0f6d911601e7e352a812ed27768e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/boot/dts/b4860qds.dts
#	drivers/acpi/acpi_dbg.c
#	drivers/ata/sata_highbank.c
#	drivers/clk/tegra/clk-tegra210.c
#	drivers/cpufreq/omap-cpufreq.c
#	drivers/crypto/caam/ctrl.c
#	drivers/dma/sun4i-dma.c
#	drivers/gpio/gpio-xlp.c
#	drivers/gpu/drm/sti/sti_vtg.c
#	drivers/iommu/arm-smmu-v3.c
#	drivers/iommu/arm-smmu.c
#	drivers/irqchip/irq-clps711x.c
#	drivers/irqchip/irq-gic.c
#	drivers/irqchip/irq-hip04.c
#	drivers/irqchip/spear-shirq.c
#	drivers/mmc/host/dw_mmc.c
#	drivers/mmc/host/sdhci-esdhc-imx.c
#	drivers/mmc/host/sdhci-of-at91.c
#	drivers/net/ethernet/freescale/fman/fman.c
#	drivers/net/ethernet/freescale/fman/fman_muram.c
#	drivers/net/wireless/ti/wlcore/spi.c
#	drivers/nvmem/core.c
#	drivers/tty/serial/sprd_serial.c
#	drivers/video/da8xx-fb.c
#	fs/afs/write.c
#	kernel/pid.c
#	sound/soc/qcom/lpass-platform.c
diff --cc arch/powerpc/boot/dts/b4860qds.dts
index 78907f38bb77,889649ad8931..000000000000
--- a/arch/powerpc/boot/dts/b4860qds.dts
+++ b/arch/powerpc/boot/dts/b4860qds.dts
@@@ -31,31 -29,23 +31,39 @@@
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
 -#ifndef __FM_MURAM_EXT
 -#define __FM_MURAM_EXT
  
 -#include <linux/types.h>
 +/include/ "fsl/b4860si-pre.dtsi"
 +/include/ "b4qds.dts"
 +
 +/ {
 +	model = "fsl,B4860QDS";
 +	compatible = "fsl,B4860QDS";
  
 -#define FM_MURAM_INVALID_ALLOCATION	-1
 +	ifc: localbus@ffe124000 {
 +		board-control@3,0 {
 +			compatible = "fsl,b4860qds-fpga", "fsl,fpga-qixis";
 +		};
 +	};
  
 -/* Structure for FM MURAM information */
 -struct muram_info;
 +	rio: rapidio@ffe0c0000 {
 +		reg = <0xf 0xfe0c0000 0 0x11000>;
  
 -struct muram_info *fman_muram_init(phys_addr_t base, size_t size);
 +		port1 {
 +			ranges = <0 0 0xc 0x20000000 0 0x10000000>;
 +		};
 +		port2 {
 +			ranges = <0 0 0xc 0x30000000 0 0x10000000>;
 +		};
 +	};
  
 -unsigned long fman_muram_offset_to_vbase(struct muram_info *muram,
 -					 unsigned long offset);
++<<<<<<< HEAD:arch/powerpc/boot/dts/b4860qds.dts
 +};
  
 +/include/ "fsl/b4860si-post.dtsi"
++=======
+ unsigned long fman_muram_alloc(struct muram_info *muram, size_t size);
+ 
+ void fman_muram_free_mem(struct muram_info *muram, unsigned long offset, size_t size);
+ 
+ #endif /* __FM_MURAM_EXT */
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses):drivers/net/ethernet/freescale/fman/fman_muram.h
diff --cc drivers/ata/sata_highbank.c
index dd71250942a9,aafb8cc03523..000000000000
--- a/drivers/ata/sata_highbank.c
+++ b/drivers/ata/sata_highbank.c
@@@ -65,6 -72,159 +65,161 @@@ struct phy_lane_info 
  };
  static struct phy_lane_info port_data[CPHY_PORT_COUNT];
  
++<<<<<<< HEAD
++=======
+ static DEFINE_SPINLOCK(sgpio_lock);
+ #define SCLOCK				0
+ #define SLOAD				1
+ #define SDATA				2
+ #define SGPIO_PINS			3
+ #define SGPIO_PORTS			8
+ 
+ struct ecx_plat_data {
+ 	u32		n_ports;
+ 	/* number of extra clocks that the SGPIO PIC controller expects */
+ 	u32		pre_clocks;
+ 	u32		post_clocks;
+ 	unsigned	sgpio_gpio[SGPIO_PINS];
+ 	u32		sgpio_pattern;
+ 	u32		port_to_sgpio[SGPIO_PORTS];
+ };
+ 
+ #define SGPIO_SIGNALS			3
+ #define ECX_ACTIVITY_BITS		0x300000
+ #define ECX_ACTIVITY_SHIFT		0
+ #define ECX_LOCATE_BITS			0x80000
+ #define ECX_LOCATE_SHIFT		1
+ #define ECX_FAULT_BITS			0x400000
+ #define ECX_FAULT_SHIFT			2
+ static inline int sgpio_bit_shift(struct ecx_plat_data *pdata, u32 port,
+ 				u32 shift)
+ {
+ 	return 1 << (3 * pdata->port_to_sgpio[port] + shift);
+ }
+ 
+ static void ecx_parse_sgpio(struct ecx_plat_data *pdata, u32 port, u32 state)
+ {
+ 	if (state & ECX_ACTIVITY_BITS)
+ 		pdata->sgpio_pattern |= sgpio_bit_shift(pdata, port,
+ 						ECX_ACTIVITY_SHIFT);
+ 	else
+ 		pdata->sgpio_pattern &= ~sgpio_bit_shift(pdata, port,
+ 						ECX_ACTIVITY_SHIFT);
+ 	if (state & ECX_LOCATE_BITS)
+ 		pdata->sgpio_pattern |= sgpio_bit_shift(pdata, port,
+ 						ECX_LOCATE_SHIFT);
+ 	else
+ 		pdata->sgpio_pattern &= ~sgpio_bit_shift(pdata, port,
+ 						ECX_LOCATE_SHIFT);
+ 	if (state & ECX_FAULT_BITS)
+ 		pdata->sgpio_pattern |= sgpio_bit_shift(pdata, port,
+ 						ECX_FAULT_SHIFT);
+ 	else
+ 		pdata->sgpio_pattern &= ~sgpio_bit_shift(pdata, port,
+ 						ECX_FAULT_SHIFT);
+ }
+ 
+ /*
+  * Tell the LED controller that the signal has changed by raising the clock
+  * line for 50 uS and then lowering it for 50 uS.
+  */
+ static void ecx_led_cycle_clock(struct ecx_plat_data *pdata)
+ {
+ 	gpio_set_value(pdata->sgpio_gpio[SCLOCK], 1);
+ 	udelay(50);
+ 	gpio_set_value(pdata->sgpio_gpio[SCLOCK], 0);
+ 	udelay(50);
+ }
+ 
+ static ssize_t ecx_transmit_led_message(struct ata_port *ap, u32 state,
+ 					ssize_t size)
+ {
+ 	struct ahci_host_priv *hpriv =  ap->host->private_data;
+ 	struct ecx_plat_data *pdata = hpriv->plat_data;
+ 	struct ahci_port_priv *pp = ap->private_data;
+ 	unsigned long flags;
+ 	int pmp, i;
+ 	struct ahci_em_priv *emp;
+ 	u32 sgpio_out;
+ 
+ 	/* get the slot number from the message */
+ 	pmp = (state & EM_MSG_LED_PMP_SLOT) >> 8;
+ 	if (pmp < EM_MAX_SLOTS)
+ 		emp = &pp->em_priv[pmp];
+ 	else
+ 		return -EINVAL;
+ 
+ 	if (!(hpriv->em_msg_type & EM_MSG_TYPE_LED))
+ 		return size;
+ 
+ 	spin_lock_irqsave(&sgpio_lock, flags);
+ 	ecx_parse_sgpio(pdata, ap->port_no, state);
+ 	sgpio_out = pdata->sgpio_pattern;
+ 	for (i = 0; i < pdata->pre_clocks; i++)
+ 		ecx_led_cycle_clock(pdata);
+ 
+ 	gpio_set_value(pdata->sgpio_gpio[SLOAD], 1);
+ 	ecx_led_cycle_clock(pdata);
+ 	gpio_set_value(pdata->sgpio_gpio[SLOAD], 0);
+ 	/*
+ 	 * bit-bang out the SGPIO pattern, by consuming a bit and then
+ 	 * clocking it out.
+ 	 */
+ 	for (i = 0; i < (SGPIO_SIGNALS * pdata->n_ports); i++) {
+ 		gpio_set_value(pdata->sgpio_gpio[SDATA], sgpio_out & 1);
+ 		sgpio_out >>= 1;
+ 		ecx_led_cycle_clock(pdata);
+ 	}
+ 	for (i = 0; i < pdata->post_clocks; i++)
+ 		ecx_led_cycle_clock(pdata);
+ 
+ 	/* save off new led state for port/slot */
+ 	emp->led_state = state;
+ 
+ 	spin_unlock_irqrestore(&sgpio_lock, flags);
+ 	return size;
+ }
+ 
+ static void highbank_set_em_messages(struct device *dev,
+ 					struct ahci_host_priv *hpriv,
+ 					struct ata_port_info *pi)
+ {
+ 	struct device_node *np = dev->of_node;
+ 	struct ecx_plat_data *pdata = hpriv->plat_data;
+ 	int i;
+ 	int err;
+ 
+ 	for (i = 0; i < SGPIO_PINS; i++) {
+ 		err = of_get_named_gpio(np, "calxeda,sgpio-gpio", i);
+ 		if (err < 0)
+ 			return;
+ 
+ 		pdata->sgpio_gpio[i] = err;
+ 		err = gpio_request(pdata->sgpio_gpio[i], "CX SGPIO");
+ 		if (err) {
+ 			pr_err("sata_highbank gpio_request %d failed: %d\n",
+ 					i, err);
+ 			return;
+ 		}
+ 		gpio_direction_output(pdata->sgpio_gpio[i], 1);
+ 	}
+ 	of_property_read_u32_array(np, "calxeda,led-order",
+ 						pdata->port_to_sgpio,
+ 						pdata->n_ports);
+ 	if (of_property_read_u32(np, "calxeda,pre-clocks", &pdata->pre_clocks))
+ 		pdata->pre_clocks = 0;
+ 	if (of_property_read_u32(np, "calxeda,post-clocks",
+ 				&pdata->post_clocks))
+ 		pdata->post_clocks = 0;
+ 
+ 	/* store em_loc */
+ 	hpriv->em_loc = 0;
+ 	hpriv->em_buf_sz = 4;
+ 	hpriv->em_msg_type = EM_MSG_TYPE_LED;
+ 	pi->flags |= ATA_FLAG_EM | ATA_FLAG_SW_ACTIVITY;
+ }
+ 
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
  static u32 __combo_phy_reg_read(u8 sata_port, u32 addr)
  {
  	u32 data;
diff --cc drivers/cpufreq/omap-cpufreq.c
index 4b81d3e9f0ab,376e63ca94e8..000000000000
--- a/drivers/cpufreq/omap-cpufreq.c
+++ b/drivers/cpufreq/omap-cpufreq.c
@@@ -40,65 -42,19 +40,71 @@@ static struct clk *mpu_clk
  static struct device *mpu_dev;
  static struct regulator *mpu_reg;
  
 -static int omap_target(struct cpufreq_policy *policy, unsigned int index)
 +static int omap_verify_speed(struct cpufreq_policy *policy)
 +{
 +	if (!freq_table)
 +		return -EINVAL;
 +	return cpufreq_frequency_table_verify(policy, freq_table);
 +}
 +
 +static unsigned int omap_getspeed(unsigned int cpu)
  {
 -	int r, ret;
 -	struct dev_pm_opp *opp;
 +	unsigned long rate;
 +
 +	if (cpu >= NR_CPUS)
 +		return 0;
 +
 +	rate = clk_get_rate(mpu_clk) / 1000;
 +	return rate;
 +}
 +
 +static int omap_target(struct cpufreq_policy *policy,
 +		       unsigned int target_freq,
 +		       unsigned int relation)
 +{
 +	unsigned int i;
 +	int r, ret = 0;
 +	struct cpufreq_freqs freqs;
 +	struct opp *opp;
  	unsigned long freq, volt = 0, volt_old = 0, tol = 0;
 -	unsigned int old_freq, new_freq;
  
 -	old_freq = policy->cur;
 -	new_freq = freq_table[index].frequency;
 +	if (!freq_table) {
 +		dev_err(mpu_dev, "%s: cpu%d: no freq table!\n", __func__,
 +				policy->cpu);
 +		return -EINVAL;
 +	}
 +
++<<<<<<< HEAD
 +	ret = cpufreq_frequency_table_target(policy, freq_table, target_freq,
 +			relation, &i);
 +	if (ret) {
 +		dev_dbg(mpu_dev, "%s: cpu%d: no freq match for %d(ret=%d)\n",
 +			__func__, policy->cpu, target_freq, ret);
 +		return ret;
 +	}
 +	freqs.new = freq_table[i].frequency;
 +	if (!freqs.new) {
 +		dev_err(mpu_dev, "%s: cpu%d: no match for freq %d\n", __func__,
 +			policy->cpu, target_freq);
 +		return -EINVAL;
 +	}
 +
 +	freqs.old = omap_getspeed(policy->cpu);
  
 +	if (freqs.old == freqs.new && policy->cur == freqs.new)
 +		return ret;
 +
 +	/* notifiers */
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +
 +	freq = freqs.new * 1000;
 +	ret = clk_round_rate(mpu_clk, freq);
 +	if (IS_ERR_VALUE(ret)) {
++=======
+ 	freq = new_freq * 1000;
+ 	ret = clk_round_rate(policy->clk, freq);
+ 	if (ret < 0) {
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
  		dev_warn(mpu_dev,
  			 "CPUfreq: Cannot find matching frequency for %lu\n",
  			 freq);
diff --cc drivers/crypto/caam/ctrl.c
index 6e94bcd94678,5ad5f3009ae0..000000000000
--- a/drivers/crypto/caam/ctrl.c
+++ b/drivers/crypto/caam/ctrl.c
@@@ -158,34 -390,19 +158,38 @@@ static void kick_trng(struct platform_d
  
  /**
   * caam_get_era() - Return the ERA of the SEC on SoC, based
 - * on "sec-era" propery in the DTS. This property is updated by u-boot.
 + * on the SEC_VID register.
 + * Returns the ERA number (1..4) or -ENOTSUPP if the ERA is unknown.
 + * @caam_id - the value of the SEC_VID register
   **/
 -int caam_get_era(void)
 +int caam_get_era(u64 caam_id)
  {
 -	struct device_node *caam_node;
 -	int ret;
 -	u32 prop;
 +	struct sec_vid *sec_vid = (struct sec_vid *)&caam_id;
 +	static const struct {
 +		u16 ip_id;
 +		u8 maj_rev;
 +		u8 era;
 +	} caam_eras[] = {
 +		{0x0A10, 1, 1},
 +		{0x0A10, 2, 2},
 +		{0x0A12, 1, 3},
 +		{0x0A14, 1, 3},
 +		{0x0A14, 2, 4},
 +		{0x0A16, 1, 4},
 +		{0x0A11, 1, 4}
 +	};
 +	int i;
  
 -	caam_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
 -	ret = of_property_read_u32(caam_node, "fsl,sec-era", &prop);
 -	of_node_put(caam_node);
 +	for (i = 0; i < ARRAY_SIZE(caam_eras); i++)
 +		if (caam_eras[i].ip_id == sec_vid->ip_id &&
 +			caam_eras[i].maj_rev == sec_vid->maj_rev)
 +				return caam_eras[i].era;
  
++<<<<<<< HEAD
 +	return -ENOTSUPP;
++=======
+ 	return ret ? -ENOTSUPP : prop;
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
  }
  EXPORT_SYMBOL(caam_get_era);
  
diff --cc drivers/irqchip/irq-gic.c
index ee7c50312066,fbc4ae2afd29..000000000000
--- a/drivers/irqchip/irq-gic.c
+++ b/drivers/irqchip/irq-gic.c
@@@ -796,29 -1102,111 +796,61 @@@ void __init gic_init_bases(unsigned in
  		gic_irqs = 1020;
  	gic->gic_irqs = gic_irqs;
  
++<<<<<<< HEAD
 +	gic_irqs -= hwirq_base; /* calculate # of irqs to allocate */
 +	irq_base = irq_alloc_descs(irq_start, 16, gic_irqs, numa_node_id());
 +	if (IS_ERR_VALUE(irq_base)) {
 +		WARN(1, "Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\n",
 +		     irq_start);
 +		irq_base = irq_start;
++=======
+ 	if (handle) {		/* DT/ACPI */
+ 		gic->domain = irq_domain_create_linear(handle, gic_irqs,
+ 						       &gic_irq_domain_hierarchy_ops,
+ 						       gic);
+ 	} else {		/* Legacy support */
+ 		/*
+ 		 * For primary GICs, skip over SGIs.
+ 		 * For secondary GICs, skip over PPIs, too.
+ 		 */
+ 		if (gic == &gic_data[0] && (irq_start & 31) > 0) {
+ 			hwirq_base = 16;
+ 			if (irq_start != -1)
+ 				irq_start = (irq_start & ~31) + 16;
+ 		} else {
+ 			hwirq_base = 32;
+ 		}
+ 
+ 		gic_irqs -= hwirq_base; /* calculate # of irqs to allocate */
+ 
+ 		irq_base = irq_alloc_descs(irq_start, 16, gic_irqs,
+ 					   numa_node_id());
+ 		if (irq_base < 0) {
+ 			WARN(1, "Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\n",
+ 			     irq_start);
+ 			irq_base = irq_start;
+ 		}
+ 
+ 		gic->domain = irq_domain_add_legacy(NULL, gic_irqs, irq_base,
+ 					hwirq_base, &gic_irq_domain_ops, gic);
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
  	}
 +	gic->domain = irq_domain_add_legacy(node, gic_irqs, irq_base,
 +				    hwirq_base, &gic_irq_domain_ops, gic);
 +	if (WARN_ON(!gic->domain))
 +		return;
  
 -	if (WARN_ON(!gic->domain)) {
 -		ret = -ENODEV;
 -		goto error;
 -	}
 -
 -	if (gic == &gic_data[0]) {
 -		/*
 -		 * Initialize the CPU interface map to all CPUs.
 -		 * It will be refined as each CPU probes its ID.
 -		 * This is only necessary for the primary GIC.
 -		 */
 -		for (i = 0; i < NR_GIC_CPU_IF; i++)
 -			gic_cpu_map[i] = 0xff;
  #ifdef CONFIG_SMP
 -		set_smp_cross_call(gic_raise_softirq);
 -		register_cpu_notifier(&gic_cpu_notifier);
 +	set_smp_cross_call(gic_raise_softirq);
 +	register_cpu_notifier(&gic_cpu_notifier);
  #endif
 -		set_handle_irq(gic_handle_irq);
 -		if (static_key_true(&supports_deactivate))
 -			pr_info("GIC: Using split EOI/Deactivate mode\n");
 -	}
  
 -	gic_dist_init(gic);
 -	ret = gic_cpu_init(gic);
 -	if (ret)
 -		goto error;
 -
 -	ret = gic_pm_init(gic);
 -	if (ret)
 -		goto error;
 -
 -	return 0;
 -
 -error:
 -	if (IS_ENABLED(CONFIG_GIC_NON_BANKED) && gic->percpu_offset) {
 -		free_percpu(gic->dist_base.percpu_base);
 -		free_percpu(gic->cpu_base.percpu_base);
 -	}
 -
 -	kfree(gic->chip.name);
 -
 -	return ret;
 -}
 +	set_handle_irq(gic_handle_irq);
  
 -void __init gic_init(unsigned int gic_nr, int irq_start,
 -		     void __iomem *dist_base, void __iomem *cpu_base)
 -{
 -	struct gic_chip_data *gic;
 -
 -	if (WARN_ON(gic_nr >= CONFIG_ARM_GIC_MAX_NR))
 -		return;
 -
 -	/*
 -	 * Non-DT/ACPI systems won't run a hypervisor, so let's not
 -	 * bother with these...
 -	 */
 -	static_key_slow_dec(&supports_deactivate);
 -
 -	gic = &gic_data[gic_nr];
 -	gic->raw_dist_base = dist_base;
 -	gic->raw_cpu_base = cpu_base;
 -
 -	__gic_init_bases(gic, irq_start, NULL);
 -}
 -
 -static void gic_teardown(struct gic_chip_data *gic)
 -{
 -	if (WARN_ON(!gic))
 -		return;
 -
 -	if (gic->raw_dist_base)
 -		iounmap(gic->raw_dist_base);
 -	if (gic->raw_cpu_base)
 -		iounmap(gic->raw_cpu_base);
 +	gic_chip.flags |= gic_arch_extn.flags;
 +	gic_dist_init(gic);
 +	gic_cpu_init(gic);
 +	gic_pm_init(gic);
  }
  
  #ifdef CONFIG_OF
diff --cc drivers/irqchip/spear-shirq.c
index 8527743b5cef,1518ba31a80c..000000000000
--- a/drivers/irqchip/spear-shirq.c
+++ b/drivers/irqchip/spear-shirq.c
@@@ -262,10 -229,10 +262,15 @@@ static int __init shirq_init(struct spe
  	}
  
  	for (i = 0; i < block_nr; i++)
 -		nr_irqs += shirq_blocks[i]->nr_irqs;
 +		irq_nr += shirq_blocks[i]->irq_nr;
  
++<<<<<<< HEAD
 +	irq_base = irq_alloc_descs(-1, 0, irq_nr, 0);
 +	if (IS_ERR_VALUE(irq_base)) {
++=======
+ 	virq_base = irq_alloc_descs(-1, 0, nr_irqs, 0);
+ 	if (virq_base < 0) {
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
  		pr_err("%s: irq desc alloc failed\n", __func__);
  		goto err_unmap;
  	}
diff --cc drivers/mmc/host/dw_mmc.c
index bc3a1bc4940f,2cc6123b1df9..000000000000
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@@ -836,42 -1367,95 +836,52 @@@ static void dw_mci_set_ios(struct mmc_h
  	default:
  		break;
  	}
 -
 -	if (slot->host->state == STATE_WAITING_CMD11_DONE && ios->clock != 0)
 -		slot->host->state = STATE_IDLE;
  }
  
 -static int dw_mci_card_busy(struct mmc_host *mmc)
 +static int dw_mci_get_ro(struct mmc_host *mmc)
  {
 +	int read_only;
  	struct dw_mci_slot *slot = mmc_priv(mmc);
 -	u32 status;
 +	struct dw_mci_board *brd = slot->host->pdata;
  
 -	/*
 -	 * Check the busy bit which is low when DAT[3:0]
 -	 * (the data lines) are 0000
 -	 */
 -	status = mci_readl(slot->host, STATUS);
 +	/* Use platform get_ro function, else try on board write protect */
++<<<<<<< HEAD
 +	if (slot->quirks & DW_MCI_SLOT_QUIRK_NO_WRITE_PROTECT)
 +		read_only = 0;
 +	else if (brd->get_ro)
 +		read_only = brd->get_ro(slot->id);
 +	else if (gpio_is_valid(slot->wp_gpio))
 +		read_only = gpio_get_value(slot->wp_gpio);
++=======
++	if (gpio_ro >= 0)
++		read_only = gpio_ro;
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
 +	else
 +		read_only =
 +			mci_readl(slot->host, WRTPRT) & (1 << slot->id) ? 1 : 0;
  
 -	return !!(status & SDMMC_STATUS_BUSY);
 +	dev_dbg(&mmc->class_dev, "card is %s\n",
 +		read_only ? "read-only" : "read-write");
 +
 +	return read_only;
  }
  
 -static int dw_mci_switch_voltage(struct mmc_host *mmc, struct mmc_ios *ios)
 +static int dw_mci_get_cd(struct mmc_host *mmc)
  {
 +	int present;
  	struct dw_mci_slot *slot = mmc_priv(mmc);
 -	struct dw_mci *host = slot->host;
 -	const struct dw_mci_drv_data *drv_data = host->drv_data;
 -	u32 uhs;
 -	u32 v18 = SDMMC_UHS_18V << slot->id;
 -	int ret;
 -
 -	if (drv_data && drv_data->switch_voltage)
 -		return drv_data->switch_voltage(mmc, ios);
 -
 -	/*
 -	 * Program the voltage.  Note that some instances of dw_mmc may use
 -	 * the UHS_REG for this.  For other instances (like exynos) the UHS_REG
 -	 * does no harm but you need to set the regulator directly.  Try both.
 -	 */
 -	uhs = mci_readl(host, UHS_REG);
 -	if (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330)
 -		uhs &= ~v18;
 -	else
 -		uhs |= v18;
 -
 -	if (!IS_ERR(mmc->supply.vqmmc)) {
 -		ret = mmc_regulator_set_vqmmc(mmc, ios);
 -
 -		if (ret) {
 -			dev_dbg(&mmc->class_dev,
 -					 "Regulator set error %d - %s V\n",
 -					 ret, uhs & v18 ? "1.8" : "3.3");
 -			return ret;
 -		}
 -	}
 -	mci_writel(host, UHS_REG, uhs);
 -
 -	return 0;
 -}
 -
 -static int dw_mci_get_ro(struct mmc_host *mmc)
 -{
 -	int read_only;
 -	struct dw_mci_slot *slot = mmc_priv(mmc);
 -	int gpio_ro = mmc_gpio_get_ro(mmc);
 -
 -	/* Use platform get_ro function, else try on board write protect */
 -	if (gpio_ro >= 0)
 -		read_only = gpio_ro;
 -	else
 -		read_only =
 -			mci_readl(slot->host, WRTPRT) & (1 << slot->id) ? 1 : 0;
 -
 -	dev_dbg(&mmc->class_dev, "card is %s\n",
 -		read_only ? "read-only" : "read-write");
 -
 -	return read_only;
 -}
 -
 -static int dw_mci_get_cd(struct mmc_host *mmc)
 -{
 -	int present;
 -	struct dw_mci_slot *slot = mmc_priv(mmc);
 -	struct dw_mci *host = slot->host;
 -	int gpio_cd = mmc_gpio_get_cd(mmc);
 +	struct dw_mci_board *brd = slot->host->pdata;
  
  	/* Use platform get_cd function, else try onboard card detect */
 -	if ((mmc->caps & MMC_CAP_NEEDS_POLL) ||
 -	    (mmc->caps & MMC_CAP_NONREMOVABLE))
 +	if (brd->quirks & DW_MCI_QUIRK_BROKEN_CARD_DETECTION)
  		present = 1;
++<<<<<<< HEAD
 +	else if (brd->get_cd)
 +		present = !brd->get_cd(slot->id);
++=======
+ 	else if (gpio_cd >= 0)
+ 		present = gpio_cd;
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
  	else
  		present = (mci_readl(slot->host, CDETECT) & (1 << slot->id))
  			== 0 ? 1 : 0;
@@@ -2172,6 -2911,35 +2182,38 @@@ static struct dw_mci_board *dw_mci_pars
  }
  #endif /* CONFIG_OF */
  
++<<<<<<< HEAD
++=======
+ static void dw_mci_enable_cd(struct dw_mci *host)
+ {
+ 	unsigned long irqflags;
+ 	u32 temp;
+ 	int i;
+ 	struct dw_mci_slot *slot;
+ 
+ 	/*
+ 	 * No need for CD if all slots have a non-error GPIO
+ 	 * as well as broken card detection is found.
+ 	 */
+ 	for (i = 0; i < host->num_slots; i++) {
+ 		slot = host->slot[i];
+ 		if (slot->mmc->caps & MMC_CAP_NEEDS_POLL)
+ 			return;
+ 
+ 		if (mmc_gpio_get_cd(slot->mmc) < 0)
+ 			break;
+ 	}
+ 	if (i == host->num_slots)
+ 		return;
+ 
+ 	spin_lock_irqsave(&host->irq_lock, irqflags);
+ 	temp = mci_readl(host, INTMASK);
+ 	temp  |= SDMMC_INT_CD;
+ 	mci_writel(host, INTMASK, temp);
+ 	spin_unlock_irqrestore(&host->irq_lock, irqflags);
+ }
+ 
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
  int dw_mci_probe(struct dw_mci *host)
  {
  	const struct dw_mci_drv_data *drv_data = host->drv_data;
diff --cc drivers/mmc/host/sdhci-esdhc-imx.c
index d5f0d59e1310,9d3ae1f4bd3c..000000000000
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@@ -480,7 -974,45 +480,49 @@@ sdhci_esdhc_imx_probe_dt(struct platfor
  	if (gpio_is_valid(boarddata->wp_gpio))
  		boarddata->wp_type = ESDHC_WP_GPIO;
  
++<<<<<<< HEAD
 +	of_property_read_u32(np, "bus-width", &boarddata->max_bus_width);
++=======
+ 	of_property_read_u32(np, "fsl,tuning-step", &boarddata->tuning_step);
+ 
+ 	if (of_find_property(np, "no-1-8-v", NULL))
+ 		boarddata->support_vsel = false;
+ 	else
+ 		boarddata->support_vsel = true;
+ 
+ 	if (of_property_read_u32(np, "fsl,delay-line", &boarddata->delay_line))
+ 		boarddata->delay_line = 0;
+ 
+ 	mmc_of_parse_voltage(np, &host->ocr_mask);
+ 
+ 	/* sdr50 and sdr104 needs work on 1.8v signal voltage */
+ 	if ((boarddata->support_vsel) && esdhc_is_usdhc(imx_data) &&
+ 	    !IS_ERR(imx_data->pins_default)) {
+ 		imx_data->pins_100mhz = pinctrl_lookup_state(imx_data->pinctrl,
+ 						ESDHC_PINCTRL_STATE_100MHZ);
+ 		imx_data->pins_200mhz = pinctrl_lookup_state(imx_data->pinctrl,
+ 						ESDHC_PINCTRL_STATE_200MHZ);
+ 		if (IS_ERR(imx_data->pins_100mhz) ||
+ 				IS_ERR(imx_data->pins_200mhz)) {
+ 			dev_warn(mmc_dev(host->mmc),
+ 				"could not get ultra high speed state, work on normal mode\n");
+ 			/*
+ 			 * fall back to not support uhs by specify no 1.8v quirk
+ 			 */
+ 			host->quirks2 |= SDHCI_QUIRK2_NO_1_8_V;
+ 		}
+ 	} else {
+ 		host->quirks2 |= SDHCI_QUIRK2_NO_1_8_V;
+ 	}
+ 
+ 	/* call to generic mmc_of_parse to support additional capabilities */
+ 	ret = mmc_of_parse(host->mmc);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (mmc_gpio_get_cd(host->mmc) >= 0)
+ 		host->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
  
  	return 0;
  }
diff --cc drivers/net/wireless/ti/wlcore/spi.c
index e26447832683,cea9443c22a6..000000000000
--- a/drivers/net/wireless/ti/wlcore/spi.c
+++ b/drivers/net/wireless/ti/wlcore/spi.c
@@@ -324,6 -357,40 +324,42 @@@ static struct wl1271_if_operations spi_
  	.set_block_size = NULL,
  };
  
++<<<<<<< HEAD
++=======
+ static const struct of_device_id wlcore_spi_of_match_table[] = {
+ 	{ .compatible = "ti,wl1271" },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(of, wlcore_spi_of_match_table);
+ 
+ /**
+  * wlcore_probe_of - DT node parsing.
+  * @spi: SPI slave device parameters.
+  * @res: resource parameters.
+  * @glue: wl12xx SPI bus to slave device glue parameters.
+  * @pdev_data: wlcore device parameters
+  */
+ static int wlcore_probe_of(struct spi_device *spi, struct wl12xx_spi_glue *glue,
+ 			   struct wlcore_platdev_data *pdev_data)
+ {
+ 	struct device_node *dt_node = spi->dev.of_node;
+ 	int ret;
+ 
+ 	if (of_find_property(dt_node, "clock-xtal", NULL))
+ 		pdev_data->ref_clock_xtal = true;
+ 
+ 	ret = of_property_read_u32(dt_node, "ref-clock-frequency",
+ 				   &pdev_data->ref_clock_freq);
+ 	if (ret) {
+ 		dev_err(glue->dev,
+ 			"can't get reference clock frequency (%d)\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
  static int wl1271_probe(struct spi_device *spi)
  {
  	struct wl12xx_spi_glue *glue;
@@@ -358,6 -416,21 +394,24 @@@
  	 * comes from the board-peripherals file */
  	spi->bits_per_word = 32;
  
++<<<<<<< HEAD
++=======
+ 	glue->reg = devm_regulator_get(&spi->dev, "vwlan");
+ 	if (PTR_ERR(glue->reg) == -EPROBE_DEFER)
+ 		return -EPROBE_DEFER;
+ 	if (IS_ERR(glue->reg)) {
+ 		dev_err(glue->dev, "can't get regulator\n");
+ 		return PTR_ERR(glue->reg);
+ 	}
+ 
+ 	ret = wlcore_probe_of(spi, glue, &pdev_data);
+ 	if (ret) {
+ 		dev_err(glue->dev,
+ 			"can't get device tree parameters (%d)\n", ret);
+ 		return ret;
+ 	}
+ 
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
  	ret = spi_setup(spi);
  	if (ret < 0) {
  		dev_err(glue->dev, "spi_setup failed\n");
diff --cc drivers/video/da8xx-fb.c
index 0810939936f4,c229b1a0d13b..000000000000
--- a/drivers/video/da8xx-fb.c
+++ b/drivers/video/da8xx-fb.c
@@@ -698,15 -705,25 +698,28 @@@ static void lcd_reset(struct da8xx_fb_p
  	}
  }
  
 -static int da8xx_fb_config_clk_divider(struct da8xx_fb_par *par,
 -					      unsigned lcdc_clk_div,
 -					      unsigned lcdc_clk_rate)
 +static void lcd_calc_clk_divider(struct da8xx_fb_par *par)
  {
 -	int ret;
 +	unsigned int lcd_clk, div;
  
++<<<<<<< HEAD:drivers/video/da8xx-fb.c
 +	lcd_clk = clk_get_rate(par->lcdc_clk);
 +	div = lcd_clk / par->pxl_clk;
++=======
+ 	if (par->lcdc_clk_rate != lcdc_clk_rate) {
+ 		ret = clk_set_rate(par->lcdc_clk, lcdc_clk_rate);
+ 		if (ret) {
+ 			dev_err(par->dev,
+ 				"unable to set clock rate at %u\n",
+ 				lcdc_clk_rate);
+ 			return ret;
+ 		}
+ 		par->lcdc_clk_rate = clk_get_rate(par->lcdc_clk);
+ 	}
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses):drivers/video/fbdev/da8xx-fb.c
  
  	/* Configure the LCD clock divisor. */
 -	lcdc_write(LCD_CLK_DIVISOR(lcdc_clk_div) |
 +	lcdc_write(LCD_CLK_DIVISOR(div) |
  			(LCD_RASTER_MODE & 0x1), LCD_CTRL_REG);
  
  	if (lcd_revision == LCD_VERSION_2)
@@@ -721,10 -783,11 +734,18 @@@ static int lcd_init(struct da8xx_fb_pa
  	u32 bpp;
  	int ret = 0;
  
++<<<<<<< HEAD:drivers/video/da8xx-fb.c
 +	lcd_reset(par);
 +
 +	/* Calculate the divider */
 +	lcd_calc_clk_divider(par);
++=======
+ 	ret = da8xx_fb_calc_config_clk_divider(par, panel);
+ 	if (ret) {
+ 		dev_err(par->dev, "unable to configure clock\n");
+ 		return ret;
+ 	}
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses):drivers/video/fbdev/da8xx-fb.c
  
  	if (panel->sync & FB_SYNC_CLK_INVERT)
  		lcdc_write((lcdc_read(LCD_RASTER_TIMING_2_REG) |
diff --cc fs/afs/write.c
index a890db4b9898,14d506efd1aa..000000000000
--- a/fs/afs/write.c
+++ b/fs/afs/write.c
@@@ -644,11 -642,7 +644,15 @@@ ssize_t afs_file_write(struct kiocb *io
  	if (!count)
  		return 0;
  
++<<<<<<< HEAD
 +	result = generic_file_aio_write(iocb, iov, nr_segs, pos);
 +	if (IS_ERR_VALUE(result)) {
 +		_leave(" = %zd", result);
 +		return result;
 +	}
++=======
+ 	result = generic_file_write_iter(iocb, from);
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
  
  	_leave(" = %zd", result);
  	return result;
diff --cc kernel/pid.c
index f48427ae1285,f66162f2359b..000000000000
--- a/kernel/pid.c
+++ b/kernel/pid.c
@@@ -301,8 -311,10 +301,13 @@@ struct pid *alloc_pid(struct pid_namesp
  	pid->level = ns->level;
  	for (i = ns->level; i >= 0; i--) {
  		nr = alloc_pidmap(tmp);
++<<<<<<< HEAD
 +		if (nr < 0)
++=======
+ 		if (nr < 0) {
+ 			retval = nr;
++>>>>>>> 287980e49ffc (remove lots of IS_ERR_VALUE abuses)
  			goto out_free;
 -		}
  
  		pid->numbers[i].nr = nr;
  		pid->numbers[i].ns = tmp;
* Unmerged path drivers/acpi/acpi_dbg.c
* Unmerged path drivers/clk/tegra/clk-tegra210.c
* Unmerged path drivers/dma/sun4i-dma.c
* Unmerged path drivers/gpio/gpio-xlp.c
* Unmerged path drivers/gpu/drm/sti/sti_vtg.c
* Unmerged path drivers/iommu/arm-smmu-v3.c
* Unmerged path drivers/iommu/arm-smmu.c
* Unmerged path drivers/irqchip/irq-clps711x.c
* Unmerged path drivers/irqchip/irq-hip04.c
* Unmerged path drivers/mmc/host/sdhci-of-at91.c
* Unmerged path drivers/net/ethernet/freescale/fman/fman.c
* Unmerged path drivers/net/ethernet/freescale/fman/fman_muram.c
* Unmerged path drivers/nvmem/core.c
* Unmerged path drivers/tty/serial/sprd_serial.c
* Unmerged path sound/soc/qcom/lpass-platform.c
* Unmerged path arch/powerpc/boot/dts/b4860qds.dts
* Unmerged path drivers/acpi/acpi_dbg.c
* Unmerged path drivers/ata/sata_highbank.c
* Unmerged path drivers/clk/tegra/clk-tegra210.c
* Unmerged path drivers/cpufreq/omap-cpufreq.c
* Unmerged path drivers/crypto/caam/ctrl.c
* Unmerged path drivers/dma/sun4i-dma.c
* Unmerged path drivers/gpio/gpio-xlp.c
* Unmerged path drivers/gpu/drm/sti/sti_vtg.c
diff --git a/drivers/gpu/drm/tilcdc/tilcdc_tfp410.c b/drivers/gpu/drm/tilcdc/tilcdc_tfp410.c
index 6237a1896765..554ac4537ca5 100644
--- a/drivers/gpu/drm/tilcdc/tilcdc_tfp410.c
+++ b/drivers/gpu/drm/tilcdc/tilcdc_tfp410.c
@@ -369,7 +369,7 @@ static int tfp410_probe(struct platform_device *pdev)
 
 	tfp410_mod->gpio = of_get_named_gpio_flags(node, "powerdn-gpio",
 			0, NULL);
-	if (IS_ERR_VALUE(tfp410_mod->gpio)) {
+	if (tfp410_mod->gpio < 0) {
 		dev_warn(&pdev->dev, "No power down GPIO\n");
 	} else {
 		ret = gpio_request(tfp410_mod->gpio, "DVI_PDn");
diff --git a/drivers/gpu/host1x/hw/intr_hw.c b/drivers/gpu/host1x/hw/intr_hw.c
index b592eef1efcb..299b5646c70c 100644
--- a/drivers/gpu/host1x/hw/intr_hw.c
+++ b/drivers/gpu/host1x/hw/intr_hw.c
@@ -86,7 +86,7 @@ static int _host1x_intr_init_host_sync(struct host1x *host, u32 cpm,
 	err = devm_request_irq(host->dev, host->intr_syncpt_irq,
 			       syncpt_thresh_isr, IRQF_SHARED,
 			       "host1x_syncpt", host);
-	if (IS_ERR_VALUE(err)) {
+	if (err < 0) {
 		WARN_ON(1);
 		return err;
 	}
* Unmerged path drivers/iommu/arm-smmu-v3.c
* Unmerged path drivers/iommu/arm-smmu.c
* Unmerged path drivers/irqchip/irq-clps711x.c
* Unmerged path drivers/irqchip/irq-gic.c
* Unmerged path drivers/irqchip/irq-hip04.c
* Unmerged path drivers/irqchip/spear-shirq.c
diff --git a/drivers/media/i2c/adp1653.c b/drivers/media/i2c/adp1653.c
index ef75abe5984c..a1bbad44b727 100644
--- a/drivers/media/i2c/adp1653.c
+++ b/drivers/media/i2c/adp1653.c
@@ -92,7 +92,7 @@ static int adp1653_get_fault(struct adp1653_flash *flash)
 	int rval;
 
 	fault = i2c_smbus_read_byte_data(client, ADP1653_REG_FAULT);
-	if (IS_ERR_VALUE(fault))
+	if (fault < 0)
 		return fault;
 
 	flash->fault |= fault;
@@ -102,13 +102,13 @@ static int adp1653_get_fault(struct adp1653_flash *flash)
 
 	/* Clear faults. */
 	rval = i2c_smbus_write_byte_data(client, ADP1653_REG_OUT_SEL, 0);
-	if (IS_ERR_VALUE(rval))
+	if (rval < 0)
 		return rval;
 
 	flash->led_mode->val = V4L2_FLASH_LED_MODE_NONE;
 
 	rval = adp1653_update_hw(flash);
-	if (IS_ERR_VALUE(rval))
+	if (rval)
 		return rval;
 
 	return flash->fault;
@@ -155,7 +155,7 @@ static int adp1653_get_ctrl(struct v4l2_ctrl *ctrl)
 	int rval;
 
 	rval = adp1653_get_fault(flash);
-	if (IS_ERR_VALUE(rval))
+	if (rval)
 		return rval;
 
 	ctrl->cur.val = 0;
@@ -181,7 +181,7 @@ static int adp1653_set_ctrl(struct v4l2_ctrl *ctrl)
 	int rval;
 
 	rval = adp1653_get_fault(flash);
-	if (IS_ERR_VALUE(rval))
+	if (rval)
 		return rval;
 	if ((rval & (ADP1653_REG_FAULT_FLT_SCP |
 		     ADP1653_REG_FAULT_FLT_OT |
diff --git a/drivers/media/platform/s5p-tv/mixer_drv.c b/drivers/media/platform/s5p-tv/mixer_drv.c
index 5733033a6ead..2591fda18090 100644
--- a/drivers/media/platform/s5p-tv/mixer_drv.c
+++ b/drivers/media/platform/s5p-tv/mixer_drv.c
@@ -139,7 +139,7 @@ int mxr_power_get(struct mxr_device *mdev)
 
 	/* returning 1 means that power is already enabled,
 	 * so zero success be returned */
-	if (IS_ERR_VALUE(ret))
+	if (ret < 0)
 		return ret;
 	return 0;
 }
diff --git a/drivers/mfd/twl4030-irq.c b/drivers/mfd/twl4030-irq.c
index a5f9888aa19c..159269e8de81 100644
--- a/drivers/mfd/twl4030-irq.c
+++ b/drivers/mfd/twl4030-irq.c
@@ -704,7 +704,7 @@ int twl4030_init_irq(struct device *dev, int irq_num)
 	nr_irqs = TWL4030_PWR_NR_IRQS + TWL4030_CORE_NR_IRQS;
 
 	irq_base = irq_alloc_descs(-1, 0, nr_irqs, 0);
-	if (IS_ERR_VALUE(irq_base)) {
+	if (irq_base < 0) {
 		dev_err(dev, "Fail to allocate IRQ descs\n");
 		return irq_base;
 	}
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index b81b08f81325..c984321d1881 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -1276,7 +1276,7 @@ static int mmc_select_hs200(struct mmc_card *card)
 	 * switch to HS200 mode if bus width is set successfully.
 	 */
 	err = mmc_select_bus_width(card);
-	if (!IS_ERR_VALUE(err)) {
+	if (!err) {
 		val = EXT_CSD_TIMING_HS200 |
 		      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;
 		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
@@ -1583,7 +1583,7 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	} else if (mmc_card_hs(card)) {
 		/* Select the desired bus width optionally */
 		err = mmc_select_bus_width(card);
-		if (!IS_ERR_VALUE(err)) {
+		if (!err) {
 			err = mmc_select_hs_ddr(card);
 			if (err)
 				goto free_card;
* Unmerged path drivers/mmc/host/dw_mmc.c
* Unmerged path drivers/mmc/host/sdhci-esdhc-imx.c
* Unmerged path drivers/mmc/host/sdhci-of-at91.c
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 376ff417004b..a6cb9848f1da 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1603,7 +1603,7 @@ static int sdhci_get_cd(struct mmc_host *mmc)
 	 * Try slot gpio detect, if defined it take precedence
 	 * over build in controller functionality
 	 */
-	if (!IS_ERR_VALUE(gpio_cd))
+	if (gpio_cd >= 0)
 		return !!gpio_cd;
 
 	/* If polling, assume that the card is always present. */
@@ -3056,7 +3056,7 @@ int sdhci_add_host(struct sdhci_host *host)
 
 	if ((host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION) &&
 	    !(mmc->caps & MMC_CAP_NONREMOVABLE) &&
-	    IS_ERR_VALUE(mmc_gpio_get_cd(host->mmc)))
+	    mmc_gpio_get_cd(host->mmc) < 0)
 		mmc->caps |= MMC_CAP_NEEDS_POLL;
 
 	/* If there are external regulators, get them */
* Unmerged path drivers/net/ethernet/freescale/fman/fman.c
* Unmerged path drivers/net/ethernet/freescale/fman/fman_muram.c
* Unmerged path drivers/net/wireless/ti/wlcore/spi.c
* Unmerged path drivers/nvmem/core.c
diff --git a/drivers/tty/serial/amba-pl011.c b/drivers/tty/serial/amba-pl011.c
index e2774f9ecd59..4f96847d0ea8 100644
--- a/drivers/tty/serial/amba-pl011.c
+++ b/drivers/tty/serial/amba-pl011.c
@@ -2083,7 +2083,7 @@ static int pl011_probe_dt_alias(int index, struct device *dev)
 		return ret;
 
 	ret = of_alias_get_id(np, "serial");
-	if (IS_ERR_VALUE(ret)) {
+	if (ret < 0) {
 		seen_dev_without_alias = true;
 		ret = index;
 	} else {
* Unmerged path drivers/tty/serial/sprd_serial.c
* Unmerged path drivers/video/da8xx-fb.c
* Unmerged path fs/afs/write.c
diff --git a/fs/binfmt_flat.c b/fs/binfmt_flat.c
index d50bbe59da1e..6417afef3f6e 100644
--- a/fs/binfmt_flat.c
+++ b/fs/binfmt_flat.c
@@ -337,7 +337,7 @@ calc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)
 					"(%d != %d)", (unsigned) r, curid, id);
 			goto failed;
 		} else if ( ! p->lib_list[id].loaded &&
-				IS_ERR_VALUE(load_flat_shared_library(id, p))) {
+				load_flat_shared_library(id, p) < 0) {
 			printk("BINFMT_FLAT: failed to load library %d", id);
 			goto failed;
 		}
@@ -837,7 +837,7 @@ static int load_flat_shared_library(int id, struct lib_info *libs)
 
 	res = prepare_binprm(&bprm);
 
-	if (!IS_ERR_VALUE(res))
+	if (!res)
 		res = load_flat_file(&bprm, libs, id, NULL);
 
 	abort_creds(bprm.cred);
@@ -883,7 +883,7 @@ static int load_flat_binary(struct linux_binprm * bprm)
 	stack_len += FLAT_STACK_ALIGN - 1;  /* reserve for upcoming alignment */
 	
 	res = load_flat_file(bprm, &libinfo, 0, &stack_len);
-	if (IS_ERR_VALUE(res))
+	if (res < 0)
 		return res;
 	
 	/* Update data segment pointers for all libraries */
diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 2f15db06abea..66c3b0583220 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -790,12 +790,15 @@ static int get_leaf_nr(struct gfs2_inode *dip, u32 index,
 		       u64 *leaf_out)
 {
 	__be64 *hash;
+	int error;
 
 	hash = gfs2_dir_get_hash_table(dip);
-	if (IS_ERR(hash))
-		return PTR_ERR(hash);
-	*leaf_out = be64_to_cpu(*(hash + index));
-	return 0;
+	error = PTR_ERR_OR_ZERO(hash);
+
+	if (!error)
+		*leaf_out = be64_to_cpu(*(hash + index));
+
+	return error;
 }
 
 static int get_first_leaf(struct gfs2_inode *dip, u32 index,
* Unmerged path kernel/pid.c
diff --git a/net/9p/client.c b/net/9p/client.c
index addc116cecf0..576cd10e70b7 100644
--- a/net/9p/client.c
+++ b/net/9p/client.c
@@ -501,10 +501,10 @@ static int p9_check_errors(struct p9_client *c, struct p9_req_t *req)
 		if (err)
 			goto out_err;
 
-		if (p9_is_proto_dotu(c))
+		if (p9_is_proto_dotu(c) && ecode < 512)
 			err = -ecode;
 
-		if (!err || !IS_ERR_VALUE(err)) {
+		if (!err) {
 			err = p9_errstr2errno(ename, strlen(ename));
 
 			p9_debug(P9_DEBUG_9P, "<<< RERROR (%d) %s\n",
@@ -593,10 +593,10 @@ static int p9_check_zc_errors(struct p9_client *c, struct p9_req_t *req,
 		if (err)
 			goto out_err;
 
-		if (p9_is_proto_dotu(c))
+		if (p9_is_proto_dotu(c) && ecode < 512)
 			err = -ecode;
 
-		if (!err || !IS_ERR_VALUE(err)) {
+		if (!err) {
 			err = p9_errstr2errno(ename, strlen(ename));
 
 			p9_debug(P9_DEBUG_9P, "<<< RERROR (%d) %s\n",
* Unmerged path sound/soc/qcom/lpass-platform.c
