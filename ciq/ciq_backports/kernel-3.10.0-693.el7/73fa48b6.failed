Btrfs: refactor caching_thread()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Omar Sandoval <osandov@fb.com>
commit 73fa48b674e819098c3bafc47618d0e2868191e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/73fa48b6.failed

We're also going to load the free space tree from caching_thread(), so
we should refactor some of the common code.

	Signed-off-by: Omar Sandoval <osandov@fb.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit 73fa48b674e819098c3bafc47618d0e2868191e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/extent-tree.c
diff --cc fs/btrfs/extent-tree.c
index 70be760ed3a0,af8ffb59891f..000000000000
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@@ -407,10 -386,8 +406,13 @@@ static int load_extent_tree_free(struc
  	u64 total_found = 0;
  	u64 last = 0;
  	u32 nritems;
++<<<<<<< HEAD
 +	int ret = -ENOMEM;
 +	bool wakeup = true;
++=======
+ 	int ret;
++>>>>>>> 73fa48b674e8 (Btrfs: refactor caching_thread())
  
- 	caching_ctl = container_of(work, struct btrfs_caching_control, work);
  	block_group = caching_ctl->block_group;
  	fs_info = block_group->fs_info;
  	extent_root = fs_info->extent_root;
@@@ -521,10 -485,9 +521,10 @@@ next
  			else
  				last = key.objectid + key.offset;
  
- 			if (total_found > (1024 * 1024 * 2)) {
+ 			if (total_found > CACHING_CTL_WAKE_UP) {
  				total_found = 0;
 -				wake_up(&caching_ctl->wait);
 +				if (wakeup)
 +					wake_up(&caching_ctl->wait);
  			}
  		}
  		path->slots[0]++;
@@@ -534,41 -497,38 +534,62 @@@
  	total_found += add_new_free_space(block_group, fs_info, last,
  					  block_group->key.objectid +
  					  block_group->key.offset);
++<<<<<<< HEAD
++=======
+ 	caching_ctl->progress = (u64)-1;
+ 
+ out:
+ 	btrfs_free_path(path);
+ 	return ret;
+ }
+ 
+ static noinline void caching_thread(struct btrfs_work *work)
+ {
+ 	struct btrfs_block_group_cache *block_group;
+ 	struct btrfs_fs_info *fs_info;
+ 	struct btrfs_caching_control *caching_ctl;
+ 	int ret;
+ 
+ 	caching_ctl = container_of(work, struct btrfs_caching_control, work);
+ 	block_group = caching_ctl->block_group;
+ 	fs_info = block_group->fs_info;
+ 
+ 	mutex_lock(&caching_ctl->mutex);
+ 	down_read(&fs_info->commit_root_sem);
+ 
+ 	ret = load_extent_tree_free(caching_ctl);
+ 
++>>>>>>> 73fa48b674e8 (Btrfs: refactor caching_thread())
  	spin_lock(&block_group->lock);
  	block_group->caching_ctl = NULL;
- 	block_group->cached = BTRFS_CACHE_FINISHED;
+ 	block_group->cached = ret ? BTRFS_CACHE_ERROR : BTRFS_CACHE_FINISHED;
  	spin_unlock(&block_group->lock);
  
++<<<<<<< HEAD
 +#ifdef CONFIG_BTRFS_DEBUG
 +	if (btrfs_should_fragment_free_space(extent_root, block_group)) {
 +		u64 bytes_used;
 +
 +		spin_lock(&block_group->space_info->lock);
 +		spin_lock(&block_group->lock);
 +		bytes_used = block_group->key.offset -
 +			btrfs_block_group_used(&block_group->item);
 +		block_group->space_info->bytes_used += bytes_used >> 1;
 +		spin_unlock(&block_group->lock);
 +		spin_unlock(&block_group->space_info->lock);
 +		fragment_free_space(extent_root, block_group);
 +	}
 +#endif
 +
 +	caching_ctl->progress = (u64)-1;
 +err:
 +	btrfs_free_path(path);
++=======
++>>>>>>> 73fa48b674e8 (Btrfs: refactor caching_thread())
  	up_read(&fs_info->commit_root_sem);
- 
- 	free_excluded_extents(extent_root, block_group);
- 
+ 	free_excluded_extents(fs_info->extent_root, block_group);
  	mutex_unlock(&caching_ctl->mutex);
- out:
- 	if (ret) {
- 		spin_lock(&block_group->lock);
- 		block_group->caching_ctl = NULL;
- 		block_group->cached = BTRFS_CACHE_ERROR;
- 		spin_unlock(&block_group->lock);
- 	}
+ 
  	wake_up(&caching_ctl->wait);
  
  	put_caching_control(caching_ctl);
diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index 6c2e3747af00..f5ef23a03fda 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -1296,6 +1296,9 @@ struct btrfs_caching_control {
 	atomic_t count;
 };
 
+/* Once caching_thread() finds this much free space, it will wake up waiters. */
+#define CACHING_CTL_WAKE_UP (1024 * 1024 * 2)
+
 struct btrfs_io_ctl {
 	void *cur, *orig;
 	struct page *page;
* Unmerged path fs/btrfs/extent-tree.c
