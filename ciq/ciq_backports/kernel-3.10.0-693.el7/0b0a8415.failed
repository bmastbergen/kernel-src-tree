KEYS: request_key() should reget expired keys rather than give EKEYEXPIRED

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Howells <dhowells@redhat.com>
commit 0b0a84154eff56913e91df29de5c3a03a0029e38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0b0a8415.failed

Since the keyring facility can be viewed as a cache (at least in some
applications), the local expiration time on the key should probably be viewed
as a 'needs updating after this time' property rather than an absolute 'anyone
now wanting to use this object is out of luck' property.

Since request_key() is the main interface for the usage of keys, this should
update or replace an expired key rather than issuing EKEYEXPIRED if the local
expiration has been reached (ie. it should refresh the cache).

For absolute conditions where refreshing the cache probably doesn't help, the
key can be negatively instantiated using KEYCTL_REJECT_KEY with EKEYEXPIRED
given as the error to issue.  This will still cause request_key() to return
EKEYEXPIRED as that was explicitly set.

In the future, if the key type has an update op available, we might want to
upcall with the expired key and allow the upcall to update it.  We would pass
a different operation name (the first column in /etc/request-key.conf) to the
request-key program.

request_key() returning EKEYEXPIRED is causing an NFS problem which Chuck
Lever describes thusly:

	After about 10 minutes, my NFSv4 functional tests fail because the
	ownership of the test files goes to "-2". Looking at /proc/keys
	shows that the id_resolv keys that map to my test user ID have
	expired. The ownership problem persists until the expired keys are
	purged from the keyring, and fresh keys are obtained.

	I bisected the problem to 3.13 commit b2a4df200d57 ("KEYS: Expand
	the capacity of a keyring"). This commit inadvertantly changes the
	API contract of the internal function keyring_search_aux().

	The root cause appears to be that b2a4df200d57 made "no state check"
	the default behavior. "No state check" means the keyring search
	iterator function skips checking the key's expiry timeout, and
	returns expired keys.  request_key_and_link() depends on getting
	an -EAGAIN result code to know when to perform an upcall to refresh
	an expired key.

This patch can be tested directly by:

	keyctl request2 user debug:fred a @s
	keyctl timeout %user:debug:fred 3
	sleep 4
	keyctl request2 user debug:fred a @s

Without the patch, the last command gives error EKEYEXPIRED, but with the
command it gives a new key.

	Reported-by: Carl Hetherington <cth@carlh.net>
	Reported-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: David Howells <dhowells@redhat.com>
	Tested-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 0b0a84154eff56913e91df29de5c3a03a0029e38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/keys/internal.h
#	security/keys/request_key.c
diff --cc security/keys/internal.h
index 80b2aac4f50c,200e37867336..000000000000
--- a/security/keys/internal.h
+++ b/security/keys/internal.h
@@@ -112,15 -110,14 +112,24 @@@ typedef int (*key_match_func_t)(const s
  struct keyring_search_context {
  	struct keyring_index_key index_key;
  	const struct cred	*cred;
 -	struct key_match_data	match_data;
 +	key_match_func_t	match;
 +	const void		*match_data;
  	unsigned		flags;
++<<<<<<< HEAD
 +#define KEYRING_SEARCH_LOOKUP_TYPE	0x0001	/* [as type->def_lookup_type] */
 +#define KEYRING_SEARCH_NO_STATE_CHECK	0x0002	/* Skip state checks */
 +#define KEYRING_SEARCH_DO_STATE_CHECK	0x0004	/* Override NO_STATE_CHECK */
 +#define KEYRING_SEARCH_NO_UPDATE_TIME	0x0008	/* Don't update times */
 +#define KEYRING_SEARCH_NO_CHECK_PERM	0x0010	/* Don't check permissions */
 +#define KEYRING_SEARCH_DETECT_TOO_DEEP	0x0020	/* Give an error on excessive depth */
++=======
+ #define KEYRING_SEARCH_NO_STATE_CHECK	0x0001	/* Skip state checks */
+ #define KEYRING_SEARCH_DO_STATE_CHECK	0x0002	/* Override NO_STATE_CHECK */
+ #define KEYRING_SEARCH_NO_UPDATE_TIME	0x0004	/* Don't update times */
+ #define KEYRING_SEARCH_NO_CHECK_PERM	0x0008	/* Don't check permissions */
+ #define KEYRING_SEARCH_DETECT_TOO_DEEP	0x0010	/* Give an error on excessive depth */
+ #define KEYRING_SEARCH_SKIP_EXPIRED	0x0020	/* Ignore expired keys (intention to replace) */
++>>>>>>> 0b0a84154eff (KEYS: request_key() should reget expired keys rather than give EKEYEXPIRED)
  
  	int (*iterator)(const void *object, void *iterator_data);
  
diff --cc security/keys/request_key.c
index 67e413c80983,0c7aea4dea54..000000000000
--- a/security/keys/request_key.c
+++ b/security/keys/request_key.c
@@@ -517,9 -513,11 +517,17 @@@ struct key *request_key_and_link(struc
  		.index_key.type		= type,
  		.index_key.description	= description,
  		.cred			= current_cred(),
++<<<<<<< HEAD
 +		.match			= type->match,
 +		.match_data		= description,
 +		.flags			= KEYRING_SEARCH_LOOKUP_DIRECT,
++=======
+ 		.match_data.cmp		= key_default_cmp,
+ 		.match_data.raw_data	= description,
+ 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
+ 		.flags			= (KEYRING_SEARCH_DO_STATE_CHECK |
+ 					   KEYRING_SEARCH_SKIP_EXPIRED),
++>>>>>>> 0b0a84154eff (KEYS: request_key() should reget expired keys rather than give EKEYEXPIRED)
  	};
  	struct key *key;
  	key_ref_t key_ref;
* Unmerged path security/keys/internal.h
diff --git a/security/keys/keyring.c b/security/keys/keyring.c
index 04d0d7c2ab0e..13496c97c150 100644
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@ -526,7 +526,8 @@ static int keyring_search_iterator(const void *object, void *iterator_data)
 		}
 
 		if (key->expiry && ctx->now.tv_sec >= key->expiry) {
-			ctx->result = ERR_PTR(-EKEYEXPIRED);
+			if (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))
+				ctx->result = ERR_PTR(-EKEYEXPIRED);
 			kleave(" = %d [expire]", ctx->skipped_ret);
 			goto skipped;
 		}
* Unmerged path security/keys/request_key.c
