drm/i915: Fix forcewake active domain tracking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [drm] i915: Fix forcewake active domain tracking (Rob Clark) [1422186]
Rebuild_FUZZ: 95.45%
commit-author Tvrtko Ursulin <tvrtko.ursulin@intel.com>
commit b8473050805f35add97f3ff57570d55a01808df5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b8473050.failed

In commit 003342a50021 ("drm/i915: Keep track of active
forcewake domains in a bitmask") I forgot to adjust the
newly introduce fw_domains_active state across reset.

This caused the assert_forcewakes_inactive to trigger
during suspend and resume if there were user held
forcewakes.

v2: Bitmask checks are required since vfuncs are not
    always present.

v3: Move bitmask tracking to get/put vfunc for simplicity.
    (Chris Wilson)

	Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Fixes: 003342a50021 ("drm/i915: Keep track of active forcewake domains in a bitmask")
Testcase: igt/drv_suspend/forcewake
	Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
	Cc: "Paneri, Praveen" <praveen.paneri@intel.com>
	Cc: Chris Wilson <chris@chris-wilson.co.uk>
	Cc: Daniel Vetter <daniel.vetter@intel.com>
	Cc: Jani Nikula <jani.nikula@linux.intel.com>
	Cc: intel-gfx@lists.freedesktop.org
	Cc: v4.10+ <stable@vger.kernel.org>
	Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
Link: http://patchwork.freedesktop.org/patch/msgid/20170310093249.4484-1-tvrtko.ursulin@linux.intel.com
(cherry picked from commit b8473050805f35add97f3ff57570d55a01808df5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_uncore.c
diff --cc drivers/gpu/drm/i915/intel_uncore.c
index 68b6f69aa682,f1c0da06f8a2..000000000000
--- a/drivers/gpu/drm/i915/intel_uncore.c
+++ b/drivers/gpu/drm/i915/intel_uncore.c
@@@ -107,13 -111,16 +107,18 @@@ static voi
  fw_domains_get(struct drm_i915_private *dev_priv, enum forcewake_domains fw_domains)
  {
  	struct intel_uncore_forcewake_domain *d;
 +	enum forcewake_domain_id id;
  
 -	for_each_fw_domain_masked(d, fw_domains, dev_priv) {
 +	for_each_fw_domain_mask(d, fw_domains, dev_priv, id) {
  		fw_domain_wait_ack_clear(d);
  		fw_domain_get(d);
 -	}
 -
 -	for_each_fw_domain_masked(d, fw_domains, dev_priv)
  		fw_domain_wait_ack(d);
++<<<<<<< HEAD
 +	}
++=======
+ 
+ 	dev_priv->uncore.fw_domains_active |= fw_domains;
++>>>>>>> b8473050805f (drm/i915: Fix forcewake active domain tracking)
  }
  
  static void
@@@ -126,8 -132,17 +131,10 @@@ fw_domains_put(struct drm_i915_private 
  		fw_domain_put(d);
  		fw_domain_posting_read(d);
  	}
+ 
+ 	dev_priv->uncore.fw_domains_active &= ~fw_domains;
  }
  
 -static void
 -vgpu_fw_domains_nop(struct drm_i915_private *dev_priv,
 -		    enum forcewake_domains fw_domains)
 -{
 -	/* Guest driver doesn't need to takes care forcewake. */
 -}
 -
  static void
  fw_domains_posting_read(struct drm_i915_private *dev_priv)
  {
@@@ -236,15 -252,16 +243,19 @@@ static void intel_uncore_fw_release_tim
  		domain->wake_count++;
  
  	if (--domain->wake_count == 0)
++<<<<<<< HEAD
 +		domain->i915->uncore.funcs.force_wake_put(domain->i915,
 +							  1 << domain->id);
++=======
+ 		dev_priv->uncore.funcs.force_wake_put(dev_priv, domain->mask);
++>>>>>>> b8473050805f (drm/i915: Fix forcewake active domain tracking)
  
 -	spin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);
 -
 -	return HRTIMER_NORESTART;
 +	spin_unlock_irqrestore(&domain->i915->uncore.lock, irqflags);
  }
  
 -void intel_uncore_forcewake_reset(struct drm_i915_private *dev_priv,
 -				  bool restore)
 +void intel_uncore_forcewake_reset(struct drm_device *dev, bool restore)
  {
 +	struct drm_i915_private *dev_priv = dev->dev_private;
  	unsigned long irqflags;
  	struct intel_uncore_forcewake_domain *domain;
  	int retry_count = 100;
@@@ -716,12 -922,20 +727,24 @@@ __gen2_read(64
  	trace_i915_reg_rw(false, reg, val, sizeof(val), trace); \
  	return val
  
 -static noinline void ___force_wake_auto(struct drm_i915_private *dev_priv,
 -					enum forcewake_domains fw_domains)
 +static inline void __force_wake_get(struct drm_i915_private *dev_priv,
 +				    enum forcewake_domains fw_domains)
  {
  	struct intel_uncore_forcewake_domain *domain;
 +	enum forcewake_domain_id id;
  
++<<<<<<< HEAD
++=======
+ 	for_each_fw_domain_masked(domain, fw_domains, dev_priv)
+ 		fw_domain_arm_timer(domain);
+ 
+ 	dev_priv->uncore.funcs.force_wake_get(dev_priv, fw_domains);
+ }
+ 
+ static inline void __force_wake_auto(struct drm_i915_private *dev_priv,
+ 				     enum forcewake_domains fw_domains)
+ {
++>>>>>>> b8473050805f (drm/i915: Fix forcewake active domain tracking)
  	if (WARN_ON(!fw_domains))
  		return;
  
* Unmerged path drivers/gpu/drm/i915/intel_uncore.c
