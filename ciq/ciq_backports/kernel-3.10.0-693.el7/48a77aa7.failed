CIFS: Remove some obsolete comments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Steve French <smfrench@gmail.com>
commit 48a77aa7e20557319205f9bd4cc02d4b67b5f761
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/48a77aa7.failed

Remove some obsolete comments in the cifs inode_operations
structs that were pointed out by Stephen Rothwell.

CC: Stephen Rothwell <sfr@canb.auug.org.au>
CC: Al Viro <viro@zeniv.linux.org.uk>
	Reviewed-by: Sachin Prabhu <sprabhu@redhat.com>
	Signed-off-by: Steve French <steve.french@primarydata.com>
(cherry picked from commit 48a77aa7e20557319205f9bd4cc02d4b67b5f761)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifsfs.c
diff --cc fs/cifs/cifsfs.c
index 9f6ff2423731,5d8b7edf8a8f..000000000000
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@@ -907,9 -888,8 +907,8 @@@ const struct inode_operations_wrapper c
  	.link = cifs_hardlink,
  	.mkdir = cifs_mkdir,
  	.rmdir = cifs_rmdir,
 -	.rename2 = cifs_rename2,
 +	.rename = cifs_rename,
  	.permission = cifs_permission,
- /*	revalidate:cifs_revalidate,   */
  	.setattr = cifs_setattr,
  	.symlink = cifs_symlink,
  	.mknod   = cifs_mknod,
@@@ -924,39 -900,81 +923,43 @@@
  };
  
  const struct inode_operations cifs_file_inode_ops = {
- /*	revalidate:cifs_revalidate, */
  	.setattr = cifs_setattr,
- 	.getattr = cifs_getattr, /* do we need this anymore? */
+ 	.getattr = cifs_getattr,
  	.permission = cifs_permission,
 -	.setxattr = generic_setxattr,
 -	.getxattr = generic_getxattr,
 +#ifdef CONFIG_CIFS_XATTR
 +	.setxattr = cifs_setxattr,
 +	.getxattr = cifs_getxattr,
  	.listxattr = cifs_listxattr,
 -	.removexattr = generic_removexattr,
 +	.removexattr = cifs_removexattr,
 +#endif
  };
  
  const struct inode_operations cifs_symlink_inode_ops = {
  	.readlink = generic_readlink,
 -	.get_link = cifs_get_link,
 +	.follow_link = cifs_follow_link,
 +	.put_link = kfree_put_link,
  	.permission = cifs_permission,
++<<<<<<< HEAD
 +	/* BB add the following two eventually */
 +	/* revalidate: cifs_revalidate,
 +	   setattr:    cifs_notify_change, *//* BB do we need notify change */
 +#ifdef CONFIG_CIFS_XATTR
 +	.setxattr = cifs_setxattr,
 +	.getxattr = cifs_getxattr,
++=======
+ 	.setxattr = generic_setxattr,
+ 	.getxattr = generic_getxattr,
++>>>>>>> 48a77aa7e205 (CIFS: Remove some obsolete comments)
  	.listxattr = cifs_listxattr,
 -	.removexattr = generic_removexattr,
 +	.removexattr = cifs_removexattr,
 +#endif
  };
  
 -static int cifs_clone_file_range(struct file *src_file, loff_t off,
 -		struct file *dst_file, loff_t destoff, u64 len)
 -{
 -	struct inode *src_inode = file_inode(src_file);
 -	struct inode *target_inode = file_inode(dst_file);
 -	struct cifsFileInfo *smb_file_src = src_file->private_data;
 -	struct cifsFileInfo *smb_file_target = dst_file->private_data;
 -	struct cifs_tcon *target_tcon = tlink_tcon(smb_file_target->tlink);
 -	unsigned int xid;
 -	int rc;
 -
 -	cifs_dbg(FYI, "clone range\n");
 -
 -	xid = get_xid();
 -
 -	if (!src_file->private_data || !dst_file->private_data) {
 -		rc = -EBADF;
 -		cifs_dbg(VFS, "missing cifsFileInfo on copy range src file\n");
 -		goto out;
 -	}
 -
 -	/*
 -	 * Note: cifs case is easier than btrfs since server responsible for
 -	 * checks for proper open modes and file type and if it wants
 -	 * server could even support copy of range where source = target
 -	 */
 -	lock_two_nondirectories(target_inode, src_inode);
 -
 -	if (len == 0)
 -		len = src_inode->i_size - off;
 -
 -	cifs_dbg(FYI, "about to flush pages\n");
 -	/* should we flush first and last page first */
 -	truncate_inode_pages_range(&target_inode->i_data, destoff,
 -				   PAGE_ALIGN(destoff + len)-1);
 -
 -	if (target_tcon->ses->server->ops->duplicate_extents)
 -		rc = target_tcon->ses->server->ops->duplicate_extents(xid,
 -			smb_file_src, smb_file_target, off, len, destoff);
 -	else
 -		rc = -EOPNOTSUPP;
 -
 -	/* force revalidate of size and timestamps of target file now
 -	   that target is updated on the server */
 -	CIFS_I(target_inode)->time = 0;
 -	/* although unlocking in the reverse order from locking is not
 -	   strictly necessary here it is a little cleaner to be consistent */
 -	unlock_two_nondirectories(src_inode, target_inode);
 -out:
 -	free_xid(xid);
 -	return rc;
 -}
 -
  const struct file_operations cifs_file_ops = {
 -	.read_iter = cifs_loose_read_iter,
 -	.write_iter = cifs_file_write_iter,
 +	.read = do_sync_read,
 +	.write = do_sync_write,
 +	.aio_read = cifs_loose_read,
 +	.aio_write = cifs_file_aio_write,
  	.open = cifs_open,
  	.release = cifs_close,
  	.lock = cifs_lock,
* Unmerged path fs/cifs/cifsfs.c
