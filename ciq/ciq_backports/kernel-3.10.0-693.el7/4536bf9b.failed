raid5-ppl: load and recover the log

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Artur Paszkiewicz <artur.paszkiewicz@intel.com>
commit 4536bf9ba2d03404655586b07f8830b6f2106242
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4536bf9b.failed

Load the log from each disk when starting the array and recover if the
array is dirty.

The initial empty PPL is written by mdadm. When loading the log we
verify the header checksum and signature. For external metadata arrays
the signature is verified in userspace, so here we read it from the
header, verifying only if it matches on all disks, and use it later when
writing PPL.

In addition to the header checksum, each header entry also contains a
checksum of its partial parity data. If the header is valid, recovery is
performed for each entry until an invalid entry is found. If the array
is not degraded and recovery using PPL fully succeeds, there is no need
to resync the array because data and parity will be consistent, so in
this case resync will be disabled.

Due to compatibility with IMSM implementations on other systems, we
can't assume that the recovery data block size is always 4K. Writes
generated by MD raid5 don't have this issue, but when recovering PPL
written in other environments it is possible to have entries with
512-byte sector granularity. The recovery code takes this into account
and also the logical sector size of the underlying drives.

	Signed-off-by: Artur Paszkiewicz <artur.paszkiewicz@intel.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit 4536bf9ba2d03404655586b07f8830b6f2106242)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5-ppl.c
#	drivers/md/raid5.c
diff --cc drivers/md/raid5.c
index 896a84d8eff0,78ed5748d33d..000000000000
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@@ -6963,15 -7357,15 +6963,24 @@@ static int raid5_run(struct mddev *mdde
  
  	if (mddev->degraded > dirty_parity_disks &&
  	    mddev->recovery_cp != MaxSector) {
++<<<<<<< HEAD
 +		if (mddev->ok_start_degraded)
 +			printk(KERN_WARNING
 +			       "md/raid:%s: starting dirty degraded array"
 +			       " - data corruption possible.\n",
 +			       mdname(mddev));
++=======
+ 		if (test_bit(MD_HAS_PPL, &mddev->flags))
+ 			pr_crit("md/raid:%s: starting dirty degraded array with PPL.\n",
+ 				mdname(mddev));
+ 		else if (mddev->ok_start_degraded)
+ 			pr_crit("md/raid:%s: starting dirty degraded array - data corruption possible.\n",
+ 				mdname(mddev));
++>>>>>>> 4536bf9ba2d0 (raid5-ppl: load and recover the log)
  		else {
 -			pr_crit("md/raid:%s: cannot start dirty degraded array.\n",
 -				mdname(mddev));
 +			printk(KERN_ERR
 +			       "md/raid:%s: cannot start dirty degraded array.\n",
 +			       mdname(mddev));
  			goto abort;
  		}
  	}
* Unmerged path drivers/md/raid5-ppl.c
* Unmerged path drivers/md/raid5-ppl.c
* Unmerged path drivers/md/raid5.c
