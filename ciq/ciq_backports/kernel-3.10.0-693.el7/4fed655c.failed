mnt: Clear mnt_expire during pivot_root

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 4fed655c410cc56add64c7b1f7c85c7c56066ac2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4fed655c.failed

When inspecting the pivot_root and the current mount expiry logic I
realized that pivot_root fails to clear like mount move does.

Add the missing line in case someone does the interesting feat of
moving an expirable submount.  This gives a strong guarantee that root
of the filesystem tree will never expire.

	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 4fed655c410cc56add64c7b1f7c85c7c56066ac2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
diff --cc fs/namespace.c
index 5bfed5a73a95,fe1c77145a78..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -2782,7 -2967,9 +2782,13 @@@ SYSCALL_DEFINE2(pivot_root, const char 
  	/* mount new_root on / */
  	attach_mnt(new_mnt, real_mount(root_parent.mnt), root_mp);
  	touch_mnt_namespace(current->nsproxy->mnt_ns);
++<<<<<<< HEAD
 +	br_write_unlock(&vfsmount_lock);
++=======
+ 	/* A moved mount should not expire automatically */
+ 	list_del_init(&new_mnt->mnt_expire);
+ 	unlock_mount_hash();
++>>>>>>> 4fed655c410c (mnt: Clear mnt_expire during pivot_root)
  	chroot_fs_refs(&root, &new);
  	put_mountpoint(root_mp);
  	error = 0;
* Unmerged path fs/namespace.c
