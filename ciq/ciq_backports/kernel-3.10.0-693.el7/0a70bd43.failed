dax: enable dax in the presence of known media errors (badblocks)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit 0a70bd43053331d99881211e1d09f32de531432f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0a70bd43.failed

1/ If a mapping overlaps a bad sector fail the request.

2/ Do not opportunistically report more dax-capable capacity than is
   requested when errors present.

	Reviewed-by: Jeff Moyer <jmoyer@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
[vishal: fix a conflict with system RAM collision patches]
[vishal: add a 'size' parameter to ->direct_access]
[vishal: fix a conflict with DAX alignment check patches]
	Signed-off-by: Vishal Verma <vishal.l.verma@intel.com>
(cherry picked from commit 0a70bd43053331d99881211e1d09f32de531432f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/sysdev/axonram.c
#	drivers/block/brd.c
#	drivers/nvdimm/pmem.c
#	drivers/s390/block/dcssblk.c
#	fs/block_dev.c
#	include/linux/blkdev.h
diff --cc arch/powerpc/sysdev/axonram.c
index 4ccefcac96ef,ff75d70f7285..000000000000
--- a/arch/powerpc/sysdev/axonram.c
+++ b/arch/powerpc/sysdev/axonram.c
@@@ -141,7 -143,7 +141,11 @@@ axon_ram_make_request(struct request_qu
   */
  static long
  axon_ram_direct_access(struct block_device *device, sector_t sector,
++<<<<<<< HEAD
 +		       void **kaddr, pfn_t *pfn)
++=======
+ 		       void __pmem **kaddr, pfn_t *pfn, long size)
++>>>>>>> 0a70bd430533 (dax: enable dax in the presence of known media errors (badblocks))
  {
  	struct axon_ram_bank *bank = device->bd_disk->private_data;
  	loff_t offset = (loff_t)sector << AXON_RAM_SECTOR_SHIFT;
diff --cc drivers/block/brd.c
index 1f3a382ffd5b,c04bd9bc39fd..000000000000
--- a/drivers/block/brd.c
+++ b/drivers/block/brd.c
@@@ -374,7 -381,7 +374,11 @@@ static int brd_rw_page(struct block_dev
  
  #ifdef CONFIG_BLK_DEV_RAM_DAX
  static long brd_direct_access(struct block_device *bdev, sector_t sector,
++<<<<<<< HEAD
 +			void **kaddr, pfn_t *pfn)
++=======
+ 			void __pmem **kaddr, pfn_t *pfn, long size)
++>>>>>>> 0a70bd430533 (dax: enable dax in the presence of known media errors (badblocks))
  {
  	struct brd_device *brd = bdev->bd_disk->private_data;
  	struct page *page;
diff --cc drivers/nvdimm/pmem.c
index 26fd9ba8de78,c447579bd853..000000000000
--- a/drivers/nvdimm/pmem.c
+++ b/drivers/nvdimm/pmem.c
@@@ -164,13 -181,14 +164,20 @@@ static int pmem_rw_page(struct block_de
  	return rc;
  }
  
++<<<<<<< HEAD
 +/* see "strong" declaration in tools/testing/nvdimm/pmem-dax.c */
 +__weak long pmem_direct_access(struct block_device *bdev, sector_t sector,
 +		      void **kaddr, pfn_t *pfn)
++=======
+ static long pmem_direct_access(struct block_device *bdev, sector_t sector,
+ 		      void __pmem **kaddr, pfn_t *pfn, long size)
++>>>>>>> 0a70bd430533 (dax: enable dax in the presence of known media errors (badblocks))
  {
 -	struct pmem_device *pmem = bdev->bd_disk->private_data;
 +	struct pmem_device *pmem = bdev->bd_queue->queuedata;
  	resource_size_t offset = sector * 512 + pmem->data_offset;
  
+ 	if (unlikely(is_bad_pmem(&pmem->bb, sector, size)))
+ 		return -EIO;
  	*kaddr = pmem->virt_addr + offset;
  	*pfn = phys_to_pfn_t(pmem->phys_addr + offset, pmem->pfn_flags);
  
diff --cc drivers/s390/block/dcssblk.c
index 05c383625868,6ac33984bc0f..000000000000
--- a/drivers/s390/block/dcssblk.c
+++ b/drivers/s390/block/dcssblk.c
@@@ -28,9 -28,10 +28,13 @@@
  
  static int dcssblk_open(struct block_device *bdev, fmode_t mode);
  static void dcssblk_release(struct gendisk *disk, fmode_t mode);
 -static blk_qc_t dcssblk_make_request(struct request_queue *q,
 -						struct bio *bio);
 +static void dcssblk_make_request(struct request_queue *q, struct bio *bio);
  static long dcssblk_direct_access(struct block_device *bdev, sector_t secnum,
++<<<<<<< HEAD
 +			void **kaddr, pfn_t *pfn);
++=======
+ 			 void __pmem **kaddr, pfn_t *pfn, long size);
++>>>>>>> 0a70bd430533 (dax: enable dax in the presence of known media errors (badblocks))
  
  static char dcssblk_segments[DCSSBLK_PARM_LEN] = "\0";
  
@@@ -868,7 -883,7 +872,11 @@@ fail
  
  static long
  dcssblk_direct_access (struct block_device *bdev, sector_t secnum,
++<<<<<<< HEAD
 +			void **kaddr, pfn_t *pfn)
++=======
+ 			void __pmem **kaddr, pfn_t *pfn, long size)
++>>>>>>> 0a70bd430533 (dax: enable dax in the presence of known media errors (badblocks))
  {
  	struct dcssblk_dev_info *dev_info;
  	unsigned long offset, dev_sz;
diff --cc fs/block_dev.c
index 7d6ea6f10f58,45839b27972c..000000000000
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@@ -28,8 -29,6 +28,11 @@@
  #include <linux/log2.h>
  #include <linux/cleancache.h>
  #include <linux/dax.h>
++<<<<<<< HEAD
 +#include <linux/badblocks.h>
 +#include <linux/aio.h>
++=======
++>>>>>>> 0a70bd430533 (dax: enable dax in the presence of known media errors (badblocks))
  #include <asm/uaccess.h>
  #include "internal.h"
  
@@@ -534,6 -465,51 +537,54 @@@ int bdev_write_page(struct block_devic
  EXPORT_SYMBOL_GPL(bdev_write_page);
  
  /**
++<<<<<<< HEAD
++=======
+  * bdev_direct_access() - Get the address for directly-accessibly memory
+  * @bdev: The device containing the memory
+  * @dax: control and output parameters for ->direct_access
+  *
+  * If a block device is made up of directly addressable memory, this function
+  * will tell the caller the PFN and the address of the memory.  The address
+  * may be directly dereferenced within the kernel without the need to call
+  * ioremap(), kmap() or similar.  The PFN is suitable for inserting into
+  * page tables.
+  *
+  * Return: negative errno if an error occurs, otherwise the number of bytes
+  * accessible at this address.
+  */
+ long bdev_direct_access(struct block_device *bdev, struct blk_dax_ctl *dax)
+ {
+ 	sector_t sector = dax->sector;
+ 	long avail, size = dax->size;
+ 	const struct block_device_operations *ops = bdev->bd_disk->fops;
+ 
+ 	/*
+ 	 * The device driver is allowed to sleep, in order to make the
+ 	 * memory directly accessible.
+ 	 */
+ 	might_sleep();
+ 
+ 	if (size < 0)
+ 		return size;
+ 	if (!ops->direct_access)
+ 		return -EOPNOTSUPP;
+ 	if ((sector + DIV_ROUND_UP(size, 512)) >
+ 					part_nr_sects_read(bdev->bd_part))
+ 		return -ERANGE;
+ 	sector += get_start_sect(bdev);
+ 	if (sector % (PAGE_SIZE / 512))
+ 		return -EINVAL;
+ 	avail = ops->direct_access(bdev, sector, &dax->addr, &dax->pfn, size);
+ 	if (!avail)
+ 		return -ERANGE;
+ 	if (avail > 0 && avail & ~PAGE_MASK)
+ 		return -ENXIO;
+ 	return min(avail, size);
+ }
+ EXPORT_SYMBOL_GPL(bdev_direct_access);
+ 
+ /**
++>>>>>>> 0a70bd430533 (dax: enable dax in the presence of known media errors (badblocks))
   * bdev_dax_supported() - Check if the device supports dax for filesystem
   * @sb: The superblock of the device
   * @blocksize: The block size of the device
@@@ -583,6 -554,30 +634,33 @@@ int bdev_dax_supported(struct super_blo
  }
  EXPORT_SYMBOL_GPL(bdev_dax_supported);
  
++<<<<<<< HEAD
++=======
+ /**
+  * bdev_dax_capable() - Return if the raw device is capable for dax
+  * @bdev: The device for raw block device access
+  */
+ bool bdev_dax_capable(struct block_device *bdev)
+ {
+ 	struct blk_dax_ctl dax = {
+ 		.size = PAGE_SIZE,
+ 	};
+ 
+ 	if (!IS_ENABLED(CONFIG_FS_DAX))
+ 		return false;
+ 
+ 	dax.sector = 0;
+ 	if (bdev_direct_access(bdev, &dax) < 0)
+ 		return false;
+ 
+ 	dax.sector = bdev->bd_part->nr_sects - (PAGE_SIZE / 512);
+ 	if (bdev_direct_access(bdev, &dax) < 0)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
++>>>>>>> 0a70bd430533 (dax: enable dax in the presence of known media errors (badblocks))
  /*
   * pseudo-fs
   */
diff --cc include/linux/blkdev.h
index d0c02b856b7c,cf7c13c2c38d..000000000000
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@@ -1731,12 -1664,11 +1731,17 @@@ struct blk_dax_ctl 
  struct block_device_operations {
  	int (*open) (struct block_device *, fmode_t);
  	void (*release) (struct gendisk *, fmode_t);
 -	int (*rw_page)(struct block_device *, sector_t, struct page *, int rw);
  	int (*ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);
  	int (*compat_ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);
++<<<<<<< HEAD
 +	RH_KABI_REPLACE(int (*direct_access) (struct block_device *, sector_t,
 +						void **, unsigned long *),
 +			long (*direct_access)(struct block_device *, sector_t,
 +						void **, pfn_t *))
++=======
+ 	long (*direct_access)(struct block_device *, sector_t, void __pmem **,
+ 			pfn_t *, long);
++>>>>>>> 0a70bd430533 (dax: enable dax in the presence of known media errors (badblocks))
  	unsigned int (*check_events) (struct gendisk *disk,
  				      unsigned int clearing);
  	/* ->media_changed() is DEPRECATED, use ->check_events() instead */
* Unmerged path arch/powerpc/sysdev/axonram.c
* Unmerged path drivers/block/brd.c
* Unmerged path drivers/nvdimm/pmem.c
* Unmerged path drivers/s390/block/dcssblk.c
* Unmerged path fs/block_dev.c
* Unmerged path include/linux/blkdev.h
