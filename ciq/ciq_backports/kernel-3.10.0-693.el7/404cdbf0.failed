bridge: add vlan filtering change for new bridged device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Elad Raz <eladr@mellanox.com>
commit 404cdbf0894a0707dd19179d2e21a3ab37f33f54
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/404cdbf0.failed

Notifying hardware about newly bridged port vlan-aware changes.

	Signed-off-by: Elad Raz <eladr@mellanox.com>
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 404cdbf0894a0707dd19179d2e21a3ab37f33f54)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_vlan.c
diff --cc net/bridge/br_vlan.c
index 1122c9d717ea,85e43af4af7a..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -598,10 -875,79 +598,74 @@@ unlock
  
  int br_vlan_init(struct net_bridge *br)
  {
 -	struct net_bridge_vlan_group *vg;
 -	int ret = -ENOMEM;
 -
 -	vg = kzalloc(sizeof(*vg), GFP_KERNEL);
 -	if (!vg)
 -		goto out;
 -	ret = rhashtable_init(&vg->vlan_hash, &br_vlan_rht_params);
 -	if (ret)
 -		goto err_rhtbl;
 -	INIT_LIST_HEAD(&vg->vlan_list);
  	br->vlan_proto = htons(ETH_P_8021Q);
  	br->default_pvid = 1;
++<<<<<<< HEAD
 +	return br_vlan_add(br, 1,
 +			   BRIDGE_VLAN_INFO_PVID | BRIDGE_VLAN_INFO_UNTAGGED);
++=======
+ 	rcu_assign_pointer(br->vlgrp, vg);
+ 	ret = br_vlan_add(br, 1,
+ 			  BRIDGE_VLAN_INFO_PVID | BRIDGE_VLAN_INFO_UNTAGGED |
+ 			  BRIDGE_VLAN_INFO_BRENTRY);
+ 	if (ret)
+ 		goto err_vlan_add;
+ 
+ out:
+ 	return ret;
+ 
+ err_vlan_add:
+ 	rhashtable_destroy(&vg->vlan_hash);
+ err_rhtbl:
+ 	kfree(vg);
+ 
+ 	goto out;
+ }
+ 
+ int nbp_vlan_init(struct net_bridge_port *p)
+ {
+ 	struct switchdev_attr attr = {
+ 		.orig_dev = p->br->dev,
+ 		.id = SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING,
+ 		.flags = SWITCHDEV_F_SKIP_EOPNOTSUPP,
+ 		.u.vlan_filtering = p->br->vlan_enabled,
+ 	};
+ 	struct net_bridge_vlan_group *vg;
+ 	int ret = -ENOMEM;
+ 
+ 	vg = kzalloc(sizeof(struct net_bridge_vlan_group), GFP_KERNEL);
+ 	if (!vg)
+ 		goto out;
+ 
+ 	ret = switchdev_port_attr_set(p->dev, &attr);
+ 	if (ret && ret != -EOPNOTSUPP)
+ 		goto err_vlan_enabled;
+ 
+ 	ret = rhashtable_init(&vg->vlan_hash, &br_vlan_rht_params);
+ 	if (ret)
+ 		goto err_rhtbl;
+ 	INIT_LIST_HEAD(&vg->vlan_list);
+ 	rcu_assign_pointer(p->vlgrp, vg);
+ 	if (p->br->default_pvid) {
+ 		ret = nbp_vlan_add(p, p->br->default_pvid,
+ 				   BRIDGE_VLAN_INFO_PVID |
+ 				   BRIDGE_VLAN_INFO_UNTAGGED);
+ 		if (ret)
+ 			goto err_vlan_add;
+ 	}
+ out:
+ 	return ret;
+ 
+ err_vlan_add:
+ 	RCU_INIT_POINTER(p->vlgrp, NULL);
+ 	synchronize_rcu();
+ 	rhashtable_destroy(&vg->vlan_hash);
+ err_vlan_enabled:
+ err_rhtbl:
+ 	kfree(vg);
+ 
+ 	goto out;
++>>>>>>> 404cdbf0894a (bridge: add vlan filtering change for new bridged device)
  }
  
  /* Must be protected by RTNL.
* Unmerged path net/bridge/br_vlan.c
