KVM: VMX: validate individual bits of guest MSR_IA32_FEATURE_CONTROL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Haozhong Zhang <haozhong.zhang@intel.com>
commit 37e4c997dadf713d5b9cb88a801eb38d61a2aefc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/37e4c997.failed

KVM currently does not check the value written to guest
MSR_IA32_FEATURE_CONTROL, though bits corresponding to disabled features
may be set. This patch makes KVM to validate individual bits written to
guest MSR_IA32_FEATURE_CONTROL according to enabled features.

	Signed-off-by: Haozhong Zhang <haozhong.zhang@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 37e4c997dadf713d5b9cb88a801eb38d61a2aefc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index cebaaac0b163,0a3ccb073bb4..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -593,7 -603,22 +593,22 @@@ struct vcpu_vmx 
  #define PML_ENTITY_NUM		512
  	struct page *pml_pg;
  
 -	/* apic deadline value in host tsc */
 -	u64 hv_deadline_tsc;
 -
  	u64 current_tsc_ratio;
++<<<<<<< HEAD
++=======
+ 
+ 	bool guest_pkru_valid;
+ 	u32 guest_pkru;
+ 	u32 host_pkru;
+ 
+ 	/*
+ 	 * Only bits masked by msr_ia32_feature_control_valid_bits can be set in
+ 	 * msr_ia32_feature_control. FEATURE_CONTROL_LOCKED is always included
+ 	 * in msr_ia32_feature_control_valid_bits.
+ 	 */
+ 	u64 msr_ia32_feature_control;
+ 	u64 msr_ia32_feature_control_valid_bits;
++>>>>>>> 37e4c997dadf (KVM: VMX: validate individual bits of guest MSR_IA32_FEATURE_CONTROL)
  };
  
  enum segment_cache_field {
@@@ -2898,11 -3076,11 +2921,16 @@@ static int vmx_set_msr(struct kvm_vcpu 
  		ret = kvm_set_msr_common(vcpu, msr_info);
  		break;
  	case MSR_IA32_FEATURE_CONTROL:
++<<<<<<< HEAD
 +		if (!nested_vmx_allowed(vcpu) ||
 +		    (to_vmx(vcpu)->nested.msr_ia32_feature_control &
++=======
+ 		if (!vmx_feature_control_msr_valid(vcpu, data) ||
+ 		    (to_vmx(vcpu)->msr_ia32_feature_control &
++>>>>>>> 37e4c997dadf (KVM: VMX: validate individual bits of guest MSR_IA32_FEATURE_CONTROL)
  		     FEATURE_CONTROL_LOCKED && !msr_info->host_initiated))
  			return 1;
 -		vmx->msr_ia32_feature_control = data;
 +		vmx->nested.msr_ia32_feature_control = data;
  		if (msr_info->host_initiated && data == 0)
  			vmx_leave_nested(vcpu);
  		break;
@@@ -8893,6 -9209,22 +8923,25 @@@ static void vmx_cpuid_update(struct kvm
  
  	if (cpu_has_secondary_exec_ctrls())
  		vmcs_set_secondary_exec_control(secondary_exec_ctl);
++<<<<<<< HEAD
++=======
+ 
+ 	if (static_cpu_has(X86_FEATURE_PCOMMIT) && nested) {
+ 		if (guest_cpuid_has_pcommit(vcpu))
+ 			vmx->nested.nested_vmx_secondary_ctls_high |=
+ 				SECONDARY_EXEC_PCOMMIT;
+ 		else
+ 			vmx->nested.nested_vmx_secondary_ctls_high &=
+ 				~SECONDARY_EXEC_PCOMMIT;
+ 	}
+ 
+ 	if (nested_vmx_allowed(vcpu))
+ 		to_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=
+ 			FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;
+ 	else
+ 		to_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=
+ 			~FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;
++>>>>>>> 37e4c997dadf (KVM: VMX: validate individual bits of guest MSR_IA32_FEATURE_CONTROL)
  }
  
  static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
* Unmerged path arch/x86/kvm/vmx.c
