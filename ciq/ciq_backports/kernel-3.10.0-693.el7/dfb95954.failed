KVM: x86: Rename kvm_apic_get_reg to kvm_lapic_get_reg

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
commit dfb9595429c65f72656551b9e1ad20126486badb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/dfb95954.failed

Rename kvm_apic_get_reg to kvm_lapic_get_reg to be consistent with
the existing kvm_lapic_set_reg counterpart.

	Signed-off-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit dfb9595429c65f72656551b9e1ad20126486badb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/lapic.c
#	arch/x86/kvm/lapic.h
diff --cc arch/x86/kvm/lapic.c
index 47c6b9ccd177,34c28c0ffe6a..000000000000
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@@ -202,9 -159,9 +202,9 @@@ static void recalculate_apic_map(struc
  			continue;
  
  		aid = kvm_apic_id(apic);
- 		ldr = kvm_apic_get_reg(apic, APIC_LDR);
+ 		ldr = kvm_lapic_get_reg(apic, APIC_LDR);
  
 -		if (aid < ARRAY_SIZE(new->phys_map))
 +		if (aid <= new->max_apic_id)
  			new->phys_map[aid] = apic;
  
  		if (apic_x2apic_mode(apic)) {
@@@ -1260,6 -1236,36 +1260,39 @@@ static void update_divide_count(struct 
  				   apic->divide_count);
  }
  
++<<<<<<< HEAD
++=======
+ static void apic_update_lvtt(struct kvm_lapic *apic)
+ {
+ 	u32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &
+ 			apic->lapic_timer.timer_mode_mask;
+ 
+ 	if (apic->lapic_timer.timer_mode != timer_mode) {
+ 		apic->lapic_timer.timer_mode = timer_mode;
+ 		hrtimer_cancel(&apic->lapic_timer.timer);
+ 	}
+ }
+ 
+ static void apic_timer_expired(struct kvm_lapic *apic)
+ {
+ 	struct kvm_vcpu *vcpu = apic->vcpu;
+ 	struct swait_queue_head *q = &vcpu->wq;
+ 	struct kvm_timer *ktimer = &apic->lapic_timer;
+ 
+ 	if (atomic_read(&apic->lapic_timer.pending))
+ 		return;
+ 
+ 	atomic_inc(&apic->lapic_timer.pending);
+ 	kvm_set_pending_timer(vcpu);
+ 
+ 	if (swait_active(q))
+ 		swake_up(q);
+ 
+ 	if (apic_lvtt_tscdeadline(apic))
+ 		ktimer->expired_tscdeadline = ktimer->tscdeadline;
+ }
+ 
++>>>>>>> dfb9595429c6 (KVM: x86: Rename kvm_apic_get_reg to kvm_lapic_get_reg)
  /*
   * On APICv, this test will cause a busy wait
   * during a higher-priority task.
@@@ -1475,10 -1450,10 +1508,15 @@@ static int apic_reg_write(struct kvm_la
  			int i;
  			u32 lvt_val;
  
++<<<<<<< HEAD
 +			for (i = 0; i < APIC_LVT_NUM; i++) {
 +				lvt_val = kvm_apic_get_reg(apic,
++=======
+ 			for (i = 0; i < KVM_APIC_LVT_NUM; i++) {
+ 				lvt_val = kvm_lapic_get_reg(apic,
++>>>>>>> dfb9595429c6 (KVM: x86: Rename kvm_apic_get_reg to kvm_lapic_get_reg)
  						       APIC_LVTT + 0x10 * i);
 -				kvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,
 +				apic_set_reg(apic, APIC_LVTT + 0x10 * i,
  					     lvt_val | APIC_LVT_MASKED);
  			}
  			apic_update_lvtt(apic);
@@@ -1741,34 -1716,34 +1779,34 @@@ void kvm_lapic_reset(struct kvm_vcpu *v
  	hrtimer_cancel(&apic->lapic_timer.timer);
  
  	if (!init_event)
 -		kvm_apic_set_id(apic, vcpu->vcpu_id);
 +		kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
  	kvm_apic_set_version(apic->vcpu);
  
 -	for (i = 0; i < KVM_APIC_LVT_NUM; i++)
 -		kvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);
 +	for (i = 0; i < APIC_LVT_NUM; i++)
 +		apic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);
  	apic_update_lvtt(apic);
  	if (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_LINT0_REENABLED))
 -		kvm_lapic_set_reg(apic, APIC_LVT0,
 +		apic_set_reg(apic, APIC_LVT0,
  			     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));
- 	apic_manage_nmi_watchdog(apic, kvm_apic_get_reg(apic, APIC_LVT0));
+ 	apic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));
  
 -	kvm_lapic_set_reg(apic, APIC_DFR, 0xffffffffU);
 +	apic_set_reg(apic, APIC_DFR, 0xffffffffU);
  	apic_set_spiv(apic, 0xff);
 -	kvm_lapic_set_reg(apic, APIC_TASKPRI, 0);
 +	apic_set_reg(apic, APIC_TASKPRI, 0);
  	if (!apic_x2apic_mode(apic))
  		kvm_apic_set_ldr(apic, 0);
 -	kvm_lapic_set_reg(apic, APIC_ESR, 0);
 -	kvm_lapic_set_reg(apic, APIC_ICR, 0);
 -	kvm_lapic_set_reg(apic, APIC_ICR2, 0);
 -	kvm_lapic_set_reg(apic, APIC_TDCR, 0);
 -	kvm_lapic_set_reg(apic, APIC_TMICT, 0);
 +	apic_set_reg(apic, APIC_ESR, 0);
 +	apic_set_reg(apic, APIC_ICR, 0);
 +	apic_set_reg(apic, APIC_ICR2, 0);
 +	apic_set_reg(apic, APIC_TDCR, 0);
 +	apic_set_reg(apic, APIC_TMICT, 0);
  	for (i = 0; i < 8; i++) {
 -		kvm_lapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);
 -		kvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);
 -		kvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);
 +		apic_set_reg(apic, APIC_IRR + 0x10 * i, 0);
 +		apic_set_reg(apic, APIC_ISR + 0x10 * i, 0);
 +		apic_set_reg(apic, APIC_TMR + 0x10 * i, 0);
  	}
 -	apic->irr_pending = vcpu->arch.apicv_active;
 -	apic->isr_count = vcpu->arch.apicv_active ? 1 : 0;
 +	apic->irr_pending = kvm_vcpu_apic_vid_enabled(vcpu);
 +	apic->isr_count = kvm_x86_ops->hwapic_isr_update ? 1 : 0;
  	apic->highest_isr_cache = -1;
  	update_divide_count(apic);
  	atomic_set(&apic->lapic_timer.pending, 0);
diff --cc arch/x86/kvm/lapic.h
index 639882f11237,bbe5d12018bb..000000000000
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@@ -99,11 -105,34 +99,33 @@@ static inline bool kvm_hv_vapic_assist_
  int kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data);
  void kvm_lapic_init(void);
  
++<<<<<<< HEAD
 +static inline u32 kvm_apic_get_reg(struct kvm_lapic *apic, int reg_off)
++=======
+ #define VEC_POS(v) ((v) & (32 - 1))
+ #define REG_POS(v) (((v) >> 5) << 4)
+ 
+ static inline void kvm_lapic_set_vector(int vec, void *bitmap)
+ {
+ 	set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
+ }
+ 
+ static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)
+ {
+ 	kvm_lapic_set_vector(vec, apic->regs + APIC_IRR);
+ 	/*
+ 	 * irr_pending must be true if any interrupt is pending; set it after
+ 	 * APIC_IRR to avoid race with apic_clear_irr
+ 	 */
+ 	apic->irr_pending = true;
+ }
+ 
+ static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)
++>>>>>>> dfb9595429c6 (KVM: x86: Rename kvm_apic_get_reg to kvm_lapic_get_reg)
  {
- 	        return *((u32 *) (apic->regs + reg_off));
+ 	return *((u32 *) (apic->regs + reg_off));
  }
  
 -static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)
 -{
 -	*((u32 *) (apic->regs + reg_off)) = val;
 -}
 -
  extern struct static_key kvm_no_apic_vcpu;
  
  static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)
@@@ -161,10 -196,9 +183,14 @@@ static inline int kvm_lapic_latched_ini
  	return lapic_in_kernel(vcpu) && test_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
  }
  
 -static inline int kvm_apic_id(struct kvm_lapic *apic)
 +static inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)
  {
++<<<<<<< HEAD
 +	return (irq->delivery_mode == APIC_DM_LOWEST ||
 +			irq->msi_redir_hint);
++=======
+ 	return (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;
++>>>>>>> dfb9595429c6 (KVM: x86: Rename kvm_apic_get_reg to kvm_lapic_get_reg)
  }
  
  bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector);
diff --git a/arch/x86/kvm/ioapic.c b/arch/x86/kvm/ioapic.c
index 2a04ba60499f..94230a5970bc 100644
--- a/arch/x86/kvm/ioapic.c
+++ b/arch/x86/kvm/ioapic.c
@@ -445,7 +445,7 @@ static void __kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu,
 		spin_lock(&ioapic->lock);
 
 		if (trigger_mode != IOAPIC_LEVEL_TRIG ||
-		    kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)
+		    kvm_lapic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)
 			continue;
 
 		ASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);
* Unmerged path arch/x86/kvm/lapic.c
* Unmerged path arch/x86/kvm/lapic.h
