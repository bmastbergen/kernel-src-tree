powerpc/opal: Add real mode call wrappers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [powerpc] opal: Add real mode call wrappers (David Gibson) [1430371]
Rebuild_FUZZ: 89.19%
commit-author Benjamin Herrenschmidt <benh@kernel.crashing.org>
commit 69c592ed40d32b4b680fd46c1b059cfe8abeb755
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/69c592ed.failed

Replace the old generic opal_call_realmode() with proper per-call
wrappers similar to the normal ones and convert callers.

	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 69c592ed40d32b4b680fd46c1b059cfe8abeb755)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/opal-api.h
#	arch/powerpc/include/asm/opal.h
#	arch/powerpc/kernel/idle_power7.S
#	arch/powerpc/platforms/powernv/opal-wrappers.S
diff --cc arch/powerpc/include/asm/opal.h
index 0665efd78184,b656bb192b63..000000000000
--- a/arch/powerpc/include/asm/opal.h
+++ b/arch/powerpc/include/asm/opal.h
@@@ -1196,6 -211,23 +1196,26 @@@ int64_t opal_flash_write(uint64_t id, u
  		uint64_t size, uint64_t token);
  int64_t opal_flash_erase(uint64_t id, uint64_t offset, uint64_t size,
  		uint64_t token);
++<<<<<<< HEAD
++=======
+ int64_t opal_get_device_tree(uint32_t phandle, uint64_t buf, uint64_t len);
+ int64_t opal_pci_get_presence_state(uint64_t id, uint64_t data);
+ int64_t opal_pci_get_power_state(uint64_t id, uint64_t data);
+ int64_t opal_pci_set_power_state(uint64_t async_token, uint64_t id,
+ 				 uint64_t data);
+ int64_t opal_pci_poll2(uint64_t id, uint64_t data);
+ 
+ int64_t opal_int_get_xirr(uint32_t *out_xirr, bool just_poll);
+ int64_t opal_int_set_cppr(uint8_t cppr);
+ int64_t opal_int_eoi(uint32_t xirr);
+ int64_t opal_int_set_mfrr(uint32_t cpu, uint8_t mfrr);
+ int64_t opal_pci_tce_kill(uint64_t phb_id, uint32_t kill_type,
+ 			  uint32_t pe_num, uint32_t tce_size,
+ 			  uint64_t dma_addr, uint32_t npages);
+ int64_t opal_rm_pci_tce_kill(uint64_t phb_id, uint32_t kill_type,
+ 			     uint32_t pe_num, uint32_t tce_size,
+ 			     uint64_t dma_addr, uint32_t npages);
++>>>>>>> 69c592ed40d3 (powerpc/opal: Add real mode call wrappers)
  
  /* Internal functions */
  extern int early_init_dt_scan_opal(unsigned long node, const char *uname,
diff --cc arch/powerpc/kernel/idle_power7.S
index 2b40c50edd08,335eb6cedae5..000000000000
--- a/arch/powerpc/kernel/idle_power7.S
+++ b/arch/powerpc/kernel/idle_power7.S
@@@ -293,12 -427,17 +291,20 @@@ _GLOBAL(power7_wakeup_tb_loss
  	 * and they are restored before switching to the process context. Hence
  	 * until they are restored, they are free to be used.
  	 *
++<<<<<<< HEAD:arch/powerpc/kernel/idle_power7.S
 +	 * Save SRR1 in a NVGPR as it might be clobbered in opal_call_realmode
 +	 * (called in CHECK_HMI_INTERRUPT). SRR1 is required to determine the
 +	 * wakeup reason if we branch to kvm_start_guest.
++=======
+ 	 * Save SRR1 and LR in NVGPRs as they might be clobbered in
+ 	 * opal_call() (called in CHECK_HMI_INTERRUPT). SRR1 is required
+ 	 * to determine the wakeup reason if we branch to kvm_start_guest. LR
+ 	 * is required to return back to reset vector after hypervisor state
+ 	 * restore is complete.
++>>>>>>> 69c592ed40d3 (powerpc/opal: Add real mode call wrappers):arch/powerpc/kernel/idle_book3s.S
  	 */
 -	mflr	r17
 +
  	mfspr	r16,SPRN_SRR1
 -BEGIN_FTR_SECTION
 -	CHECK_HMI_INTERRUPT
 -END_FTR_SECTION_IFSET(CPU_FTR_HVMODE)
  
  	lbz	r7,PACA_THREAD_MASK(r13)
  	ld	r14,PACA_CORE_IDLE_STATE_PTR(r13)
@@@ -380,19 -522,13 +386,23 @@@ pnv_fastsleep_workaround_at_exit
  	b	fastsleep_workaround_at_exit
  
  timebase_resync:
 -	/*
 -	 * Use cr3 which indicates that we are waking up with atleast partial
 -	 * hypervisor state loss to determine if TIMEBASE RESYNC is needed.
 -	 */
 +	/* Do timebase resync if we are waking up from sleep. Use cr3 value
 +	 * set in exceptions-64s.S */
  	ble	cr3,clear_lock
 +
 +BEGIN_FTR_SECTION
 +	CHECK_HMI_INTERRUPT
 +END_FTR_SECTION_IFSET(CPU_FTR_HVMODE)
  	/* Time base re-sync */
++<<<<<<< HEAD:arch/powerpc/kernel/idle_power7.S
 +	li	r0,OPAL_RESYNC_TIMEBASE
 +	bl	opal_call_realmode
 +
 +	/* TODO: Check r3 for failure */
 +
++=======
+ 	bl	opal_rm_resync_timebase;
++>>>>>>> 69c592ed40d3 (powerpc/opal: Add real mode call wrappers):arch/powerpc/kernel/idle_book3s.S
  	/*
  	 * If waking up from sleep, per core state is not lost, skip to
  	 * clear_lock.
@@@ -447,35 -597,28 +457,43 @@@ common_exit
  	ld	r4,_WORT(r1)
  	mtspr	SPRN_WORT,r4
  
 -	/* Call cur_cpu_spec->cpu_restore() */
 -	LOAD_REG_ADDR(r4, cur_cpu_spec)
 -	ld	r4,0(r4)
 -	ld	r12,CPU_SPEC_RESTORE(r4)
 -#ifdef PPC64_ELF_ABI_v1
 -	ld	r12,0(r12)
 -#endif
 -	mtctr	r12
 -	bctrl
 -
  hypervisor_state_restored:
  
 +	li	r5,PNV_THREAD_RUNNING
 +	stb     r5,PACA_THREAD_IDLE_STATE(r13)
 +
++<<<<<<< HEAD:arch/powerpc/kernel/idle_power7.S
  	mtspr	SPRN_SRR1,r16
 -	mtlr	r17
 -	blr	/* Return back to System Reset vector from where
 -		   pnv_restore_hyp_resource was invoked */
 +#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
 +	li      r0,KVM_HWTHREAD_IN_KERNEL
 +	stb     r0,HSTATE_HWTHREAD_STATE(r13)
 +	/* Order setting hwthread_state vs. testing hwthread_req */
 +	sync
 +	lbz     r0,HSTATE_HWTHREAD_REQ(r13)
 +	cmpwi   r0,0
 +	beq     6f
 +	b       kvm_start_guest
 +6:
 +#endif
  
 +	REST_NVGPRS(r1)
 +	REST_GPR(2, r1)
 +	ld	r3,_CCR(r1)
 +	ld	r4,_MSR(r1)
 +	ld	r5,_NIP(r1)
 +	addi	r1,r1,INT_FRAME_SIZE
 +	mtcr	r3
 +	mfspr	r3,SPRN_SRR1		/* Return SRR1 */
 +	mtspr	SPRN_SRR1,r4
 +	mtspr	SPRN_SRR0,r5
 +	rfid
++=======
+ fastsleep_workaround_at_exit:
+ 	li	r3,1
+ 	li	r4,0
+ 	bl	opal_rm_config_cpu_idle_state
+ 	b	timebase_resync
++>>>>>>> 69c592ed40d3 (powerpc/opal: Add real mode call wrappers):arch/powerpc/kernel/idle_book3s.S
  
  /*
   * R3 here contains the value that will be returned to the caller
diff --cc arch/powerpc/platforms/powernv/opal-wrappers.S
index 390b25022409,cf928bba4d9a..000000000000
--- a/arch/powerpc/platforms/powernv/opal-wrappers.S
+++ b/arch/powerpc/platforms/powernv/opal-wrappers.S
@@@ -22,21 -58,23 +22,27 @@@
  #define OPAL_CALL(name, token)		\
   _GLOBAL_TOC(name);			\
  	mflr	r0;			\
++<<<<<<< HEAD
++=======
+ 	std	r0,PPC_LR_STKOFF(r1);	\
+ 	li	r0,token;		\
+ 	OPAL_BRANCH(opal_tracepoint_entry) \
++>>>>>>> 69c592ed40d3 (powerpc/opal: Add real mode call wrappers)
  	mfcr	r12;			\
 +	std	r0,16(r1);		\
  	stw	r12,8(r1);		\
  	std	r1,PACAR1(r13);		\
 -	li	r11,0;			\
 +	li	r0,0;			\
  	mfmsr	r12;			\
 -	ori	r11,r11,MSR_EE;		\
 +	ori	r0,r0,MSR_EE;		\
  	std	r12,PACASAVEDMSR(r13);	\
 -	andc	r12,r12,r11;		\
 +	andc	r12,r12,r0;		\
  	mtmsrd	r12,1;			\
 -	LOAD_REG_ADDR(r11,opal_return);	\
 -	mtlr	r11;			\
 -	li	r11,MSR_DR|MSR_IR|MSR_LE;\
 -	andc	r12,r12,r11;		\
 +	LOAD_REG_ADDR(r0,opal_return);	\
 +	mtlr	r0;			\
 +	li	r0,MSR_DR|MSR_IR|MSR_LE;\
 +	andc	r12,r12,r0;		\
 +	li	r0,token;		\
  	mtspr	SPRN_HSRR1,r12;		\
  	LOAD_REG_ADDR(r11,opal);	\
  	ld	r12,8(r11);		\
@@@ -61,40 -99,91 +67,119 @@@ opal_return
  	mtcr	r4;
  	rfid
  
++<<<<<<< HEAD
 +/*
 + * Make opal call in realmode. This is a generic function to be called
 + * from realmode. It handles endianness.
 + *
 + * r13 - paca pointer
 + * r1  - stack pointer
 + * r0  - opal token
 + */
 +_GLOBAL(opal_call_realmode)
 +	mflr	r12
 +	std	r12,PPC_LR_STKOFF(r1)
 +	ld	r2,PACATOC(r13)
 +	/* Set opal return address */
 +	LOAD_REG_ADDR(r12,return_from_opal_call)
 +	mtlr	r12
 +
 +	mfmsr	r12
 +#ifdef __LITTLE_ENDIAN__
 +	/* Handle endian-ness */
 +	li	r11,MSR_LE
 +	andc	r12,r12,r11
 +#endif
++=======
+ #ifdef CONFIG_TRACEPOINTS
+ opal_tracepoint_entry:
+ 	stdu	r1,-STACKFRAMESIZE(r1)
+ 	std	r0,STK_REG(R23)(r1)
+ 	std	r3,STK_REG(R24)(r1)
+ 	std	r4,STK_REG(R25)(r1)
+ 	std	r5,STK_REG(R26)(r1)
+ 	std	r6,STK_REG(R27)(r1)
+ 	std	r7,STK_REG(R28)(r1)
+ 	std	r8,STK_REG(R29)(r1)
+ 	std	r9,STK_REG(R30)(r1)
+ 	std	r10,STK_REG(R31)(r1)
+ 	mr	r3,r0
+ 	addi	r4,r1,STK_REG(R24)
+ 	bl	__trace_opal_entry
+ 	ld	r0,STK_REG(R23)(r1)
+ 	ld	r3,STK_REG(R24)(r1)
+ 	ld	r4,STK_REG(R25)(r1)
+ 	ld	r5,STK_REG(R26)(r1)
+ 	ld	r6,STK_REG(R27)(r1)
+ 	ld	r7,STK_REG(R28)(r1)
+ 	ld	r8,STK_REG(R29)(r1)
+ 	ld	r9,STK_REG(R30)(r1)
+ 	ld	r10,STK_REG(R31)(r1)
+ 	LOAD_REG_ADDR(r11,opal_tracepoint_return)
+ 	mfcr	r12
+ 	std	r11,16(r1)
+ 	stw	r12,8(r1)
+ 	std	r1,PACAR1(r13)
+ 	li	r11,0
+ 	mfmsr	r12
+ 	ori	r11,r11,MSR_EE
+ 	std	r12,PACASAVEDMSR(r13)
+ 	andc	r12,r12,r11
+ 	mtmsrd	r12,1
+ 	LOAD_REG_ADDR(r11,opal_return)
+ 	mtlr	r11
+ 	li	r11,MSR_DR|MSR_IR|MSR_LE
+ 	andc	r12,r12,r11
++>>>>>>> 69c592ed40d3 (powerpc/opal: Add real mode call wrappers)
  	mtspr	SPRN_HSRR1,r12
  	LOAD_REG_ADDR(r11,opal)
  	ld	r12,8(r11)
  	ld	r2,0(r11)
  	mtspr	SPRN_HSRR0,r12
++<<<<<<< HEAD
++=======
  	hrfid
  
- return_from_opal_call:
- #ifdef __LITTLE_ENDIAN__
- 	FIXUP_ENDIAN
+ opal_tracepoint_return:
+ 	std	r3,STK_REG(R31)(r1)
+ 	mr	r4,r3
+ 	ld	r0,STK_REG(R23)(r1)
+ 	bl	__trace_opal_exit
+ 	ld	r3,STK_REG(R31)(r1)
+ 	addi	r1,r1,STACKFRAMESIZE
+ 	ld	r0,16(r1)
+ 	mtlr	r0
+ 	blr
  #endif
+ 
+ #define OPAL_CALL_REAL(name, token)			\
+  _GLOBAL_TOC(name);					\
+ 	mflr	r0;					\
+ 	std	r0,PPC_LR_STKOFF(r1);			\
+ 	li	r0,token;				\
+ 	mfcr	r12;					\
+ 	stw	r12,8(r1);				\
+ 							\
+ 	/* Set opal return address */			\
+ 	LOAD_REG_ADDR(r11, opal_return_realmode);	\
+ 	mtlr	r11;					\
+ 	mfmsr	r12;					\
+ 	li	r11,MSR_LE;				\
+ 	andc	r12,r12,r11;				\
+ 	mtspr	SPRN_HSRR1,r12;				\
+ 	LOAD_REG_ADDR(r11,opal);			\
+ 	ld	r12,8(r11);				\
+ 	ld	r2,0(r11);				\
+ 	mtspr	SPRN_HSRR0,r12;				\
++>>>>>>> 69c592ed40d3 (powerpc/opal: Add real mode call wrappers)
+ 	hrfid
+ 
+ opal_return_realmode:
+ 	FIXUP_ENDIAN
+ 	ld	r2,PACATOC(r13);
+ 	lwz	r11,8(r1);
  	ld	r12,PPC_LR_STKOFF(r1)
+ 	mtcr	r11;
  	mtlr	r12
  	blr
  
@@@ -189,6 -281,9 +276,12 @@@ OPAL_CALL(opal_sensor_read,			OPAL_SENS
  OPAL_CALL(opal_get_param,			OPAL_GET_PARAM);
  OPAL_CALL(opal_set_param,			OPAL_SET_PARAM);
  OPAL_CALL(opal_handle_hmi,			OPAL_HANDLE_HMI);
++<<<<<<< HEAD
++=======
+ OPAL_CALL_REAL(opal_rm_handle_hmi,		OPAL_HANDLE_HMI);
+ OPAL_CALL(opal_config_cpu_idle_state,		OPAL_CONFIG_CPU_IDLE_STATE);
+ OPAL_CALL_REAL(opal_rm_config_cpu_idle_state,	OPAL_CONFIG_CPU_IDLE_STATE);
++>>>>>>> 69c592ed40d3 (powerpc/opal: Add real mode call wrappers)
  OPAL_CALL(opal_slw_set_reg,			OPAL_SLW_SET_REG);
  OPAL_CALL(opal_register_dump_region,		OPAL_REGISTER_DUMP_REGION);
  OPAL_CALL(opal_unregister_dump_region,		OPAL_UNREGISTER_DUMP_REGION);
@@@ -205,3 -300,13 +298,16 @@@ OPAL_CALL(opal_prd_msg,				OPAL_PRD_MSG
  OPAL_CALL(opal_leds_get_ind,			OPAL_LEDS_GET_INDICATOR);
  OPAL_CALL(opal_leds_set_ind,			OPAL_LEDS_SET_INDICATOR);
  OPAL_CALL(opal_console_flush,			OPAL_CONSOLE_FLUSH);
++<<<<<<< HEAD
++=======
+ OPAL_CALL(opal_get_device_tree,			OPAL_GET_DEVICE_TREE);
+ OPAL_CALL(opal_pci_get_presence_state,		OPAL_PCI_GET_PRESENCE_STATE);
+ OPAL_CALL(opal_pci_get_power_state,		OPAL_PCI_GET_POWER_STATE);
+ OPAL_CALL(opal_pci_set_power_state,		OPAL_PCI_SET_POWER_STATE);
+ OPAL_CALL(opal_int_get_xirr,			OPAL_INT_GET_XIRR);
+ OPAL_CALL(opal_int_set_cppr,			OPAL_INT_SET_CPPR);
+ OPAL_CALL(opal_int_eoi,				OPAL_INT_EOI);
+ OPAL_CALL(opal_int_set_mfrr,			OPAL_INT_SET_MFRR);
+ OPAL_CALL(opal_pci_tce_kill,			OPAL_PCI_TCE_KILL);
+ OPAL_CALL_REAL(opal_rm_pci_tce_kill,		OPAL_PCI_TCE_KILL);
++>>>>>>> 69c592ed40d3 (powerpc/opal: Add real mode call wrappers)
* Unmerged path arch/powerpc/include/asm/opal-api.h
* Unmerged path arch/powerpc/include/asm/opal-api.h
* Unmerged path arch/powerpc/include/asm/opal.h
* Unmerged path arch/powerpc/kernel/idle_power7.S
* Unmerged path arch/powerpc/platforms/powernv/opal-wrappers.S
