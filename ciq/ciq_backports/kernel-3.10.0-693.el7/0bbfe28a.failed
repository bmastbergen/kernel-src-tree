HID: wacom: Use correct report to query pen ID from INTUOSHT2 devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Use correct report to query pen ID from INTUOSHT2 devices (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 96.24%
commit-author Jason Gerecke <killertofu@gmail.com>
commit 0bbfe28ad0fdc11dddae5fe6f6e4e91b7be06395
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0bbfe28a.failed

Unlike other tablets which are compatible with the wacom_intuos_irq handler,
INTUOSHT2 devices provide pen ID with report ID 8 instead of 5. To ensure
wacom_intuos_schedule_prox_event works as intended for these tablets, we
must be sure it uses the correct report ID in this case.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 0bbfe28ad0fdc11dddae5fe6f6e4e91b7be06395)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
#	drivers/hid/wacom_wac.h
diff --cc drivers/hid/wacom_wac.c
index 98c7d65145c2,3aeddc297652..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -308,6 -436,145 +308,148 @@@ exit
  	return retval;
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_intuos_schedule_prox_event(struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	struct hid_report *r;
+ 	struct hid_report_enum *re;
+ 
+ 	re = &(wacom->hdev->report_enum[HID_FEATURE_REPORT]);
+ 	if (features->type == INTUOSHT2)
+ 		r = re->report_id_hash[WACOM_REPORT_INTUOSHT2_ID];
+ 	else
+ 		r = re->report_id_hash[WACOM_REPORT_INTUOS_ID1];
+ 	if (r) {
+ 		hid_hw_request(wacom->hdev, r, HID_REQ_GET_REPORT);
+ 	}
+ }
+ 
+ static int wacom_intuos_pad(struct wacom_wac *wacom)
+ {
+ 	struct wacom_features *features = &wacom->features;
+ 	unsigned char *data = wacom->data;
+ 	struct input_dev *input = wacom->pad_input;
+ 	int i;
+ 	int buttons = 0, nbuttons = features->numbered_buttons;
+ 	int keys = 0, nkeys = 0;
+ 	int ring1 = 0, ring2 = 0;
+ 	int strip1 = 0, strip2 = 0;
+ 	bool prox = false;
+ 
+ 	/* pad packets. Works as a second tool and is always in prox */
+ 	if (!(data[0] == WACOM_REPORT_INTUOSPAD || data[0] == WACOM_REPORT_INTUOS5PAD ||
+ 	      data[0] == WACOM_REPORT_CINTIQPAD))
+ 		return 0;
+ 
+ 	if (features->type >= INTUOS4S && features->type <= INTUOS4L) {
+ 		buttons = (data[3] << 1) | (data[2] & 0x01);
+ 		ring1 = data[1];
+ 	} else if (features->type == DTK) {
+ 		buttons = data[6];
+ 	} else if (features->type == WACOM_13HD) {
+ 		buttons = (data[4] << 1) | (data[3] & 0x01);
+ 	} else if (features->type == WACOM_24HD) {
+ 		buttons = (data[8] << 8) | data[6];
+ 		ring1 = data[1];
+ 		ring2 = data[2];
+ 
+ 		/*
+ 		 * Three "buttons" are available on the 24HD which are
+ 		 * physically implemented as a touchstrip. Each button
+ 		 * is approximately 3 bits wide with a 2 bit spacing.
+ 		 * The raw touchstrip bits are stored at:
+ 		 *    ((data[3] & 0x1f) << 8) | data[4])
+ 		 */
+ 		nkeys = 3;
+ 		keys = ((data[3] & 0x1C) ? 1<<2 : 0) |
+ 		       ((data[4] & 0xE0) ? 1<<1 : 0) |
+ 		       ((data[4] & 0x07) ? 1<<0 : 0);
+ 	} else if (features->type == WACOM_27QHD) {
+ 		nkeys = 3;
+ 		keys = data[2] & 0x07;
+ 
+ 		input_report_abs(input, ABS_X, be16_to_cpup((__be16 *)&data[4]));
+ 		input_report_abs(input, ABS_Y, be16_to_cpup((__be16 *)&data[6]));
+ 		input_report_abs(input, ABS_Z, be16_to_cpup((__be16 *)&data[8]));
+ 	} else if (features->type == CINTIQ_HYBRID) {
+ 		/*
+ 		 * Do not send hardware buttons under Android. They
+ 		 * are already sent to the system through GPIO (and
+ 		 * have different meaning).
+ 		 *
+ 		 * d-pad right  -> data[4] & 0x10
+ 		 * d-pad up     -> data[4] & 0x20
+ 		 * d-pad left   -> data[4] & 0x40
+ 		 * d-pad down   -> data[4] & 0x80
+ 		 * d-pad center -> data[3] & 0x01
+ 		 */
+ 		buttons = (data[4] << 1) | (data[3] & 0x01);
+ 	} else if (features->type == CINTIQ_COMPANION_2) {
+ 		/* d-pad right  -> data[4] & 0x10
+ 		 * d-pad up     -> data[4] & 0x20
+ 		 * d-pad left   -> data[4] & 0x40
+ 		 * d-pad down   -> data[4] & 0x80
+ 		 * d-pad center -> data[3] & 0x01
+ 		 */
+ 		buttons = ((data[2] >> 4) << 7) |
+ 		          ((data[1] & 0x04) << 6) |
+ 		          ((data[2] & 0x0F) << 2) |
+ 		          (data[1] & 0x03);
+ 	} else if (features->type >= INTUOS5S && features->type <= INTUOSPL) {
+ 		/*
+ 		 * ExpressKeys on Intuos5/Intuos Pro have a capacitive sensor in
+ 		 * addition to the mechanical switch. Switch data is
+ 		 * stored in data[4], capacitive data in data[5].
+ 		 *
+ 		 * Touch ring mode switch (data[3]) has no capacitive sensor
+ 		 */
+ 		buttons = (data[4] << 1) | (data[3] & 0x01);
+ 		ring1 = data[2];
+ 	} else {
+ 		if (features->type == WACOM_21UX2 || features->type == WACOM_22HD) {
+ 			buttons = (data[8] << 10) | ((data[7] & 0x01) << 9) |
+ 			          (data[6] << 1) | (data[5] & 0x01);
+ 
+ 			if (features->type == WACOM_22HD) {
+ 				nkeys = 3;
+ 				keys = data[9] & 0x07;
+ 			}
+ 		} else {
+ 			buttons = ((data[6] & 0x10) << 10) |
+ 			          ((data[5] & 0x10) << 9)  |
+ 			          ((data[6] & 0x0F) << 4)  |
+ 			          (data[5] & 0x0F);
+ 		}
+ 		strip1 = ((data[1] & 0x1f) << 8) | data[2];
+ 		strip2 = ((data[3] & 0x1f) << 8) | data[4];
+ 	}
+ 
+ 	prox = (buttons & ~(~0 << nbuttons)) | (keys & ~(~0 << nkeys)) |
+ 	       (ring1 & 0x80) | (ring2 & 0x80) | strip1 | strip2;
+ 
+ 	wacom_report_numbered_buttons(input, nbuttons, buttons);
+ 
+ 	for (i = 0; i < nkeys; i++)
+ 		input_report_key(input, KEY_PROG1 + i, keys & (1 << i));
+ 
+ 	input_report_abs(input, ABS_RX, strip1);
+ 	input_report_abs(input, ABS_RY, strip2);
+ 
+ 	input_report_abs(input, ABS_WHEEL,    (ring1 & 0x80) ? (ring1 & 0x7f) : 0);
+ 	input_report_abs(input, ABS_THROTTLE, (ring2 & 0x80) ? (ring2 & 0x7f) : 0);
+ 
+ 	input_report_key(input, wacom->tool[1], prox ? 1 : 0);
+ 	input_report_abs(input, ABS_MISC, prox ? PAD_DEVICE_ID : 0);
+ 
+ 	input_event(input, EV_MSC, MSC_SERIAL, 0xffffffff);
+ 
+ 	return 1;
+ }
+ 
++>>>>>>> 0bbfe28ad0fd (HID: wacom: Use correct report to query pen ID from INTUOSHT2 devices)
  static int wacom_intuos_inout(struct wacom_wac *wacom)
  {
  	struct wacom_features *features = &wacom->features;
diff --cc drivers/hid/wacom_wac.h
index d220d069f329,25baa7f29599..000000000000
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@@ -53,16 -54,46 +53,27 @@@
  #define WACOM_REPORT_TPC1FG		6
  #define WACOM_REPORT_TPC2FG		13
  #define WACOM_REPORT_TPCMT		13
 -#define WACOM_REPORT_TPCMT2		3
  #define WACOM_REPORT_TPCHID		15
 -#define WACOM_REPORT_CINTIQ		16
 -#define WACOM_REPORT_CINTIQPAD		17
  #define WACOM_REPORT_TPCST		16
 -#define WACOM_REPORT_DTUS		17
  #define WACOM_REPORT_TPC1FGE		18
  #define WACOM_REPORT_24HDT		1
++<<<<<<< HEAD
++=======
+ #define WACOM_REPORT_WL			128
+ #define WACOM_REPORT_USB		192
+ #define WACOM_REPORT_BPAD_PEN		3
+ #define WACOM_REPORT_BPAD_TOUCH		16
+ #define WACOM_REPORT_DEVICE_LIST	16
+ #define WACOM_REPORT_INTUOS_PEN		16
+ #define WACOM_REPORT_REMOTE		17
+ #define WACOM_REPORT_INTUOSHT2_ID	8
++>>>>>>> 0bbfe28ad0fd (HID: wacom: Use correct report to query pen ID from INTUOSHT2 devices)
  
  /* device quirks */
 -#define WACOM_QUIRK_BBTOUCH_LOWRES	0x0001
 -#define WACOM_QUIRK_BATTERY		0x0008
 -
 -/* device types */
 -#define WACOM_DEVICETYPE_NONE           0x0000
 -#define WACOM_DEVICETYPE_PEN            0x0001
 -#define WACOM_DEVICETYPE_TOUCH          0x0002
 -#define WACOM_DEVICETYPE_PAD            0x0004
 -#define WACOM_DEVICETYPE_WL_MONITOR     0x0008
 -
 -#define WACOM_VENDORDEFINED_PEN		0xff0d0001
 -
 -#define WACOM_PEN_FIELD(f)	(((f)->logical == HID_DG_STYLUS) || \
 -				 ((f)->physical == HID_DG_STYLUS) || \
 -				 ((f)->physical == HID_DG_PEN) || \
 -				 ((f)->application == HID_DG_PEN) || \
 -				 ((f)->application == HID_DG_DIGITIZER) || \
 -				 ((f)->application == WACOM_VENDORDEFINED_PEN))
 -#define WACOM_FINGER_FIELD(f)	(((f)->logical == HID_DG_FINGER) || \
 -				 ((f)->physical == HID_DG_FINGER) || \
 -				 ((f)->application == HID_DG_TOUCHSCREEN))
 +#define WACOM_QUIRK_MULTI_INPUT		0x0001
 +#define WACOM_QUIRK_BBTOUCH_LOWRES	0x0002
 +#define WACOM_QUIRK_NO_INPUT		0x0004
 +#define WACOM_QUIRK_MONITOR		0x0008
  
  enum {
  	PENPARTNER = 0,
* Unmerged path drivers/hid/wacom_wac.c
* Unmerged path drivers/hid/wacom_wac.h
