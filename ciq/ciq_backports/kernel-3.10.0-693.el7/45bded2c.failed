IB/mlx5: Verify that Q counters are supported

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Kamal Heib <kamalh@mellanox.com>
commit 45bded2c216da6010184ac5ebe88c27f73439009
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/45bded2c.failed

Make sure that the Q counters are supported by the FW before trying
to allocate/deallocte them, this will avoid driver load failure when
they aren't supported by the FW.

Fixes: 0837e86a7a34 ('IB/mlx5: Add per port counters')
	Cc: <stable@vger.kernel.org> # v4.7+
	Signed-off-by: Kamal Heib <kamalh@mellanox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 45bded2c216da6010184ac5ebe88c27f73439009)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index c59be3674778,0187f1d7234a..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -2992,13 -3313,27 +2992,15 @@@ static void *mlx5_ib_add(struct mlx5_co
  	if (err)
  		goto err_rsrc;
  
- 	err = mlx5_ib_alloc_q_counters(dev);
- 	if (err)
- 		goto err_odp;
+ 	if (MLX5_CAP_GEN(dev->mdev, max_qp_cnt)) {
+ 		err = mlx5_ib_alloc_q_counters(dev);
+ 		if (err)
+ 			goto err_odp;
+ 	}
  
 -	dev->mdev->priv.uar = mlx5_get_uars_page(dev->mdev);
 -	if (!dev->mdev->priv.uar)
 -		goto err_q_cnt;
 -
 -	err = mlx5_alloc_bfreg(dev->mdev, &dev->bfreg, false, false);
 -	if (err)
 -		goto err_uar_page;
 -
 -	err = mlx5_alloc_bfreg(dev->mdev, &dev->fp_bfreg, false, true);
 -	if (err)
 -		goto err_bfreg;
 -
  	err = ib_register_device(&dev->ib_dev, NULL);
  	if (err)
 -		goto err_fp_bfreg;
 +		goto err_q_cnt;
  
  	err = create_umr_res(dev);
  	if (err)
@@@ -3021,8 -3356,18 +3023,9 @@@ err_umrc
  err_dev:
  	ib_unregister_device(&dev->ib_dev);
  
 -err_fp_bfreg:
 -	mlx5_free_bfreg(dev->mdev, &dev->fp_bfreg);
 -
 -err_bfreg:
 -	mlx5_free_bfreg(dev->mdev, &dev->bfreg);
 -
 -err_uar_page:
 -	mlx5_put_uars_page(dev->mdev, dev->mdev->priv.uar);
 -
  err_q_cnt:
- 	mlx5_ib_dealloc_q_counters(dev);
+ 	if (MLX5_CAP_GEN(dev->mdev, max_qp_cnt))
+ 		mlx5_ib_dealloc_q_counters(dev);
  
  err_odp:
  	mlx5_ib_odp_remove_one(dev);
@@@ -3048,8 -3395,13 +3051,16 @@@ static void mlx5_ib_remove(struct mlx5_
  	struct mlx5_ib_dev *dev = context;
  	enum rdma_link_layer ll = mlx5_ib_port_link_layer(&dev->ib_dev, 1);
  
 -	mlx5_remove_netdev_notifier(dev);
  	ib_unregister_device(&dev->ib_dev);
++<<<<<<< HEAD
 +	mlx5_ib_dealloc_q_counters(dev);
++=======
+ 	mlx5_free_bfreg(dev->mdev, &dev->fp_bfreg);
+ 	mlx5_free_bfreg(dev->mdev, &dev->bfreg);
+ 	mlx5_put_uars_page(dev->mdev, mdev->priv.uar);
+ 	if (MLX5_CAP_GEN(dev->mdev, max_qp_cnt))
+ 		mlx5_ib_dealloc_q_counters(dev);
++>>>>>>> 45bded2c216d (IB/mlx5: Verify that Q counters are supported)
  	destroy_umrc_res(dev);
  	mlx5_ib_odp_remove_one(dev);
  	destroy_dev_resources(&dev->devr);
* Unmerged path drivers/infiniband/hw/mlx5/main.c
