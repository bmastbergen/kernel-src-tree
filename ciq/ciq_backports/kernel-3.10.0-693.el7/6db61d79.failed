flow_dissector: Ignore flow dissector return value from ___skb_get_hash

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tom Herbert <tom@herbertland.com>
commit 6db61d79c1e1b2346e2142d6c950a8d2e8380b82
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/6db61d79.failed

In ___skb_get_hash ignore return value from skb_flow_dissect_flow_keys.
A failure in that function likely means that there was a parse error,
so we may as well use whatever fields were found before the error was
hit.  This is also good because it means we won't keep trying to derive
the hash on subsequent calls to skb_get_hash for the same packet.

	Signed-off-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6db61d79c1e1b2346e2142d6c950a8d2e8380b82)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,b563339436d0..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -367,8 -613,47 +367,52 @@@ u32 flow_hash_from_keys(struct flow_key
  }
  EXPORT_SYMBOL(flow_hash_from_keys);
  
++<<<<<<< HEAD
 +/*
 + * __skb_get_hash: calculate a flow hash based on src/dst addresses
++=======
+ static inline u32 ___skb_get_hash(const struct sk_buff *skb,
+ 				  struct flow_keys *keys, u32 keyval)
+ {
+ 	skb_flow_dissect_flow_keys(skb, keys,
+ 				   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);
+ 
+ 	return __flow_hash_from_keys(keys, keyval);
+ }
+ 
+ struct _flow_keys_digest_data {
+ 	__be16	n_proto;
+ 	u8	ip_proto;
+ 	u8	padding;
+ 	__be32	ports;
+ 	__be32	src;
+ 	__be32	dst;
+ };
+ 
+ void make_flow_keys_digest(struct flow_keys_digest *digest,
+ 			   const struct flow_keys *flow)
+ {
+ 	struct _flow_keys_digest_data *data =
+ 	    (struct _flow_keys_digest_data *)digest;
+ 
+ 	BUILD_BUG_ON(sizeof(*data) > sizeof(*digest));
+ 
+ 	memset(digest, 0, sizeof(*digest));
+ 
+ 	data->n_proto = flow->basic.n_proto;
+ 	data->ip_proto = flow->basic.ip_proto;
+ 	data->ports = flow->ports.ports;
+ 	data->src = flow->addrs.v4addrs.src;
+ 	data->dst = flow->addrs.v4addrs.dst;
+ }
+ EXPORT_SYMBOL(make_flow_keys_digest);
+ 
+ /**
+  * __skb_get_hash: calculate a flow hash
+  * @skb: sk_buff to calculate flow hash from
+  *
+  * This function calculates a flow hash based on src/dst addresses
++>>>>>>> 6db61d79c1e1 (flow_dissector: Ignore flow dissector return value from ___skb_get_hash)
   * and src/dst port numbers.  Sets hash in skb to non-zero hash value
   * on success, zero indicates no valid hash.  Also, sets l4_hash in skb
   * if hash is a canonical 4-tuple hash over transport ports.
@@@ -377,13 -662,10 +421,20 @@@ void __skb_get_hash(struct sk_buff *skb
  {
  	struct flow_keys keys;
  
++<<<<<<< HEAD
 +	if (!skb_flow_dissect(skb, &keys))
 +		return;
 +
 +	if (keys.ports)
 +		skb->l4_hash = 1;
 +
 +	skb->hash = __flow_hash_from_keys(&keys);
++=======
+ 	__flow_hash_secret_init();
+ 
+ 	__skb_set_sw_hash(skb, ___skb_get_hash(skb, &keys, hashrnd),
+ 			  flow_keys_have_l4(&keys));
++>>>>>>> 6db61d79c1e1 (flow_dissector: Ignore flow dissector return value from ___skb_get_hash)
  }
  EXPORT_SYMBOL(__skb_get_hash);
  
* Unmerged path net/core/flow_dissector.c
