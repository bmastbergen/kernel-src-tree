fs/proc/task_mmu.c: kill the suboptimal and confusing m->version logic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] proc/task_mmu.c: kill the suboptimal and confusing m->version logic (Aaron Tomlin) [1425895]
Rebuild_FUZZ: 97.81%
commit-author Oleg Nesterov <oleg@redhat.com>
commit ebb6cdde1a50c3cd2a0a4668dfb571ecb3213449
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ebb6cdde.failed

m_start() carefully documents, checks, and sets "m->version = -1" if
we are going to return NULL. The only problem is that we will be never
called again if m_start() returns NULL, so this is simply pointless
and misleading.

Otoh, ->show() methods m->version = 0 if vma == tail_vma and this is
just wrong, we want -1 in this case. And in fact we also want -1 if
->vm_next == NULL and ->tail_vma == NULL.

And it is not used consistently, the "scan vmas" loop in m_start()
should update last_addr too.

Finally, imo the whole "last_addr" logic in m_start() looks horrible.
find_vma(last_addr) is called unconditionally even if we are not going
to use the result. But the main problem is that this code participates
in tail_vma-or-NULL mess, and this looks simply unfixable.

Remove this optimization. We will add it back after some cleanups.

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Cyrill Gorcunov <gorcunov@openvz.org>
	Cc: "Eric W. Biederman" <ebiederm@xmission.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit ebb6cdde1a50c3cd2a0a4668dfb571ecb3213449)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/task_mmu.c
diff --cc fs/proc/task_mmu.c
index 09ca18a42ac3,e182fc51ec2b..000000000000
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@@ -165,15 -145,6 +164,18 @@@ static void *m_start(struct seq_file *m
  	struct vm_area_struct *vma, *tail_vma = NULL;
  	loff_t l = *pos;
  
++<<<<<<< HEAD
 +	/*
 +	 * We remember last_addr rather than next_addr to hit with
 +	 * mmap_cache most of the time. We have zero last_addr at
 +	 * the beginning and also after lseek. We will have -1 last_addr
 +	 * after the end of the vmas.
 +	 */
 +	if (last_addr == -1UL)
 +		return NULL;
 +
++=======
++>>>>>>> ebb6cdde1a50 (fs/proc/task_mmu.c: kill the suboptimal and confusing m->version logic)
  	priv->task = get_pid_task(priv->pid, PIDTYPE_PID);
  	if (!priv->task)
  		return ERR_PTR(-ESRCH);
@@@ -1561,16 -1475,11 +1543,13 @@@ static int show_numa_map(struct seq_fil
  	if (md->writeback)
  		seq_printf(m, " writeback=%lu", md->writeback);
  
 -	for_each_node_state(nid, N_MEMORY)
 -		if (md->node[nid])
 -			seq_printf(m, " N%d=%lu", nid, md->node[nid]);
 +	for_each_node_state(n, N_MEMORY)
 +		if (md->node[n])
 +			seq_printf(m, " N%d=%lu", n, md->node[n]);
 +
 +	seq_printf(m, " kernelpagesize_kB=%lu", vma_kernel_pagesize(vma) >> 10);
  out:
  	seq_putc(m, '\n');
- 
- 	if (m->count < m->size)
- 		m->version = (vma != proc_priv->tail_vma) ? vma->vm_start : 0;
  	return 0;
  }
  
* Unmerged path fs/proc/task_mmu.c
