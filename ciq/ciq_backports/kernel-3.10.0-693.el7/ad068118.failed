xen-netfront: properly destroy queues when removing device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Vrabel <david.vrabel@citrix.com>
commit ad0681185770716523c81b156c44b9804d7b8ed2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ad068118.failed

xennet_remove() freed the queues before freeing the netdevice which
results in a use-after-free when free_netdev() tries to delete the
napi instances that have already been freed.

Fix this by fully destroy the queues (which includes deleting the napi
instances) before freeing the netdevice.

	Signed-off-by: David Vrabel <david.vrabel@citrix.com>
	Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ad0681185770716523c81b156c44b9804d7b8ed2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/xen-netfront.c
diff --cc drivers/net/xen-netfront.c
index 8896052a2ee0,e031c943286e..000000000000
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@@ -1631,6 -1548,210 +1631,213 @@@ fail
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ /* Queue-specific initialisation
+  * This used to be done in xennet_create_dev() but must now
+  * be run per-queue.
+  */
+ static int xennet_init_queue(struct netfront_queue *queue)
+ {
+ 	unsigned short i;
+ 	int err = 0;
+ 
+ 	spin_lock_init(&queue->tx_lock);
+ 	spin_lock_init(&queue->rx_lock);
+ 
+ 	init_timer(&queue->rx_refill_timer);
+ 	queue->rx_refill_timer.data = (unsigned long)queue;
+ 	queue->rx_refill_timer.function = rx_refill_timeout;
+ 
+ 	snprintf(queue->name, sizeof(queue->name), "%s-q%u",
+ 		 queue->info->netdev->name, queue->id);
+ 
+ 	/* Initialise tx_skbs as a free chain containing every entry. */
+ 	queue->tx_skb_freelist = 0;
+ 	for (i = 0; i < NET_TX_RING_SIZE; i++) {
+ 		skb_entry_set_link(&queue->tx_skbs[i], i+1);
+ 		queue->grant_tx_ref[i] = GRANT_INVALID_REF;
+ 		queue->grant_tx_page[i] = NULL;
+ 	}
+ 
+ 	/* Clear out rx_skbs */
+ 	for (i = 0; i < NET_RX_RING_SIZE; i++) {
+ 		queue->rx_skbs[i] = NULL;
+ 		queue->grant_rx_ref[i] = GRANT_INVALID_REF;
+ 	}
+ 
+ 	/* A grant for every tx ring slot */
+ 	if (gnttab_alloc_grant_references(NET_TX_RING_SIZE,
+ 					  &queue->gref_tx_head) < 0) {
+ 		pr_alert("can't alloc tx grant refs\n");
+ 		err = -ENOMEM;
+ 		goto exit;
+ 	}
+ 
+ 	/* A grant for every rx ring slot */
+ 	if (gnttab_alloc_grant_references(NET_RX_RING_SIZE,
+ 					  &queue->gref_rx_head) < 0) {
+ 		pr_alert("can't alloc rx grant refs\n");
+ 		err = -ENOMEM;
+ 		goto exit_free_tx;
+ 	}
+ 
+ 	return 0;
+ 
+  exit_free_tx:
+ 	gnttab_free_grant_references(queue->gref_tx_head);
+  exit:
+ 	return err;
+ }
+ 
+ static int write_queue_xenstore_keys(struct netfront_queue *queue,
+ 			   struct xenbus_transaction *xbt, int write_hierarchical)
+ {
+ 	/* Write the queue-specific keys into XenStore in the traditional
+ 	 * way for a single queue, or in a queue subkeys for multiple
+ 	 * queues.
+ 	 */
+ 	struct xenbus_device *dev = queue->info->xbdev;
+ 	int err;
+ 	const char *message;
+ 	char *path;
+ 	size_t pathsize;
+ 
+ 	/* Choose the correct place to write the keys */
+ 	if (write_hierarchical) {
+ 		pathsize = strlen(dev->nodename) + 10;
+ 		path = kzalloc(pathsize, GFP_KERNEL);
+ 		if (!path) {
+ 			err = -ENOMEM;
+ 			message = "out of memory while writing ring references";
+ 			goto error;
+ 		}
+ 		snprintf(path, pathsize, "%s/queue-%u",
+ 				dev->nodename, queue->id);
+ 	} else {
+ 		path = (char *)dev->nodename;
+ 	}
+ 
+ 	/* Write ring references */
+ 	err = xenbus_printf(*xbt, path, "tx-ring-ref", "%u",
+ 			queue->tx_ring_ref);
+ 	if (err) {
+ 		message = "writing tx-ring-ref";
+ 		goto error;
+ 	}
+ 
+ 	err = xenbus_printf(*xbt, path, "rx-ring-ref", "%u",
+ 			queue->rx_ring_ref);
+ 	if (err) {
+ 		message = "writing rx-ring-ref";
+ 		goto error;
+ 	}
+ 
+ 	/* Write event channels; taking into account both shared
+ 	 * and split event channel scenarios.
+ 	 */
+ 	if (queue->tx_evtchn == queue->rx_evtchn) {
+ 		/* Shared event channel */
+ 		err = xenbus_printf(*xbt, path,
+ 				"event-channel", "%u", queue->tx_evtchn);
+ 		if (err) {
+ 			message = "writing event-channel";
+ 			goto error;
+ 		}
+ 	} else {
+ 		/* Split event channels */
+ 		err = xenbus_printf(*xbt, path,
+ 				"event-channel-tx", "%u", queue->tx_evtchn);
+ 		if (err) {
+ 			message = "writing event-channel-tx";
+ 			goto error;
+ 		}
+ 
+ 		err = xenbus_printf(*xbt, path,
+ 				"event-channel-rx", "%u", queue->rx_evtchn);
+ 		if (err) {
+ 			message = "writing event-channel-rx";
+ 			goto error;
+ 		}
+ 	}
+ 
+ 	if (write_hierarchical)
+ 		kfree(path);
+ 	return 0;
+ 
+ error:
+ 	if (write_hierarchical)
+ 		kfree(path);
+ 	xenbus_dev_fatal(dev, err, "%s", message);
+ 	return err;
+ }
+ 
+ static void xennet_destroy_queues(struct netfront_info *info)
+ {
+ 	unsigned int i;
+ 
+ 	rtnl_lock();
+ 
+ 	for (i = 0; i < info->netdev->real_num_tx_queues; i++) {
+ 		struct netfront_queue *queue = &info->queues[i];
+ 
+ 		if (netif_running(info->netdev))
+ 			napi_disable(&queue->napi);
+ 		del_timer_sync(&queue->rx_refill_timer);
+ 		netif_napi_del(&queue->napi);
+ 	}
+ 
+ 	rtnl_unlock();
+ 
+ 	kfree(info->queues);
+ 	info->queues = NULL;
+ }
+ 
+ static int xennet_create_queues(struct netfront_info *info,
+ 				unsigned int num_queues)
+ {
+ 	unsigned int i;
+ 	int ret;
+ 
+ 	info->queues = kcalloc(num_queues, sizeof(struct netfront_queue),
+ 			       GFP_KERNEL);
+ 	if (!info->queues)
+ 		return -ENOMEM;
+ 
+ 	rtnl_lock();
+ 
+ 	for (i = 0; i < num_queues; i++) {
+ 		struct netfront_queue *queue = &info->queues[i];
+ 
+ 		queue->id = i;
+ 		queue->info = info;
+ 
+ 		ret = xennet_init_queue(queue);
+ 		if (ret < 0) {
+ 			dev_warn(&info->netdev->dev,
+ 				 "only created %d queues\n", i);
+ 			num_queues = i;
+ 			break;
+ 		}
+ 
+ 		netif_napi_add(queue->info->netdev, &queue->napi,
+ 			       xennet_poll, 64);
+ 		if (netif_running(info->netdev))
+ 			napi_enable(&queue->napi);
+ 	}
+ 
+ 	netif_set_real_num_tx_queues(info->netdev, num_queues);
+ 
+ 	rtnl_unlock();
+ 
+ 	if (num_queues == 0) {
+ 		dev_err(&info->netdev->dev, "no queues\n");
+ 		return -EINVAL;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> ad0681185770 (xen-netfront: properly destroy queues when removing device)
  /* Common code used when first setting up, and when resuming. */
  static int talk_to_netback(struct xenbus_device *dev,
  			   struct netfront_info *info)
@@@ -1927,111 -2079,43 +2134,126 @@@ static ssize_t store_rxbuf_min(struct d
  	if (endp == buf)
  		return -EBADMSG;
  
 -	/* rxbuf_min and rxbuf_max are no longer configurable. */
 -
 -	return len;
 -}
 +	if (target < RX_MIN_TARGET)
 +		target = RX_MIN_TARGET;
 +	if (target > RX_MAX_TARGET)
 +		target = RX_MAX_TARGET;
  
 -static DEVICE_ATTR(rxbuf_min, S_IRUGO|S_IWUSR, show_rxbuf, store_rxbuf);
 -static DEVICE_ATTR(rxbuf_max, S_IRUGO|S_IWUSR, show_rxbuf, store_rxbuf);
 -static DEVICE_ATTR(rxbuf_cur, S_IRUGO, show_rxbuf, NULL);
 +	spin_lock_bh(&np->rx_lock);
 +	if (target > np->rx_max_target)
 +		np->rx_max_target = target;
 +	np->rx_min_target = target;
 +	if (target > np->rx_target)
 +		np->rx_target = target;
  
 -static struct attribute *xennet_dev_attrs[] = {
 -	&dev_attr_rxbuf_min.attr,
 -	&dev_attr_rxbuf_max.attr,
 -	&dev_attr_rxbuf_cur.attr,
 -	NULL
 -};
 +	xennet_alloc_rx_buffers(netdev);
  
 -static const struct attribute_group xennet_dev_group = {
 -	.attrs = xennet_dev_attrs
 -};
 -#endif /* CONFIG_SYSFS */
 +	spin_unlock_bh(&np->rx_lock);
 +	return len;
 +}
  
 -static int xennet_remove(struct xenbus_device *dev)
 +static ssize_t show_rxbuf_max(struct device *dev,
 +			      struct device_attribute *attr, char *buf)
  {
++<<<<<<< HEAD
 +	struct net_device *netdev = to_net_dev(dev);
 +	struct netfront_info *info = netdev_priv(netdev);
 +
 +	return sprintf(buf, "%u\n", info->rx_max_target);
++=======
+ 	struct netfront_info *info = dev_get_drvdata(&dev->dev);
+ 
+ 	dev_dbg(&dev->dev, "%s\n", dev->nodename);
+ 
+ 	xennet_disconnect_backend(info);
+ 
+ 	unregister_netdev(info->netdev);
+ 
+ 	xennet_destroy_queues(info);
+ 	xennet_free_netdev(info->netdev);
+ 
+ 	return 0;
++>>>>>>> ad0681185770 (xen-netfront: properly destroy queues when removing device)
 +}
 +
 +static ssize_t store_rxbuf_max(struct device *dev,
 +			       struct device_attribute *attr,
 +			       const char *buf, size_t len)
 +{
 +	struct net_device *netdev = to_net_dev(dev);
 +	struct netfront_info *np = netdev_priv(netdev);
 +	char *endp;
 +	unsigned long target;
 +
 +	if (!capable(CAP_NET_ADMIN))
 +		return -EPERM;
 +
 +	target = simple_strtoul(buf, &endp, 0);
 +	if (endp == buf)
 +		return -EBADMSG;
 +
 +	if (target < RX_MIN_TARGET)
 +		target = RX_MIN_TARGET;
 +	if (target > RX_MAX_TARGET)
 +		target = RX_MAX_TARGET;
 +
 +	spin_lock_bh(&np->rx_lock);
 +	if (target < np->rx_min_target)
 +		np->rx_min_target = target;
 +	np->rx_max_target = target;
 +	if (target < np->rx_target)
 +		np->rx_target = target;
 +
 +	xennet_alloc_rx_buffers(netdev);
 +
 +	spin_unlock_bh(&np->rx_lock);
 +	return len;
 +}
 +
 +static ssize_t show_rxbuf_cur(struct device *dev,
 +			      struct device_attribute *attr, char *buf)
 +{
 +	struct net_device *netdev = to_net_dev(dev);
 +	struct netfront_info *info = netdev_priv(netdev);
 +
 +	return sprintf(buf, "%u\n", info->rx_target);
 +}
 +
 +static struct device_attribute xennet_attrs[] = {
 +	__ATTR(rxbuf_min, S_IRUGO|S_IWUSR, show_rxbuf_min, store_rxbuf_min),
 +	__ATTR(rxbuf_max, S_IRUGO|S_IWUSR, show_rxbuf_max, store_rxbuf_max),
 +	__ATTR(rxbuf_cur, S_IRUGO, show_rxbuf_cur, NULL),
 +};
 +
 +static int xennet_sysfs_addif(struct net_device *netdev)
 +{
 +	int i;
 +	int err;
 +
 +	for (i = 0; i < ARRAY_SIZE(xennet_attrs); i++) {
 +		err = device_create_file(&netdev->dev,
 +					   &xennet_attrs[i]);
 +		if (err)
 +			goto fail;
 +	}
 +	return 0;
 +
 + fail:
 +	while (--i >= 0)
 +		device_remove_file(&netdev->dev, &xennet_attrs[i]);
 +	return err;
  }
  
 +static void xennet_sysfs_delif(struct net_device *netdev)
 +{
 +	int i;
 +
 +	for (i = 0; i < ARRAY_SIZE(xennet_attrs); i++)
 +		device_remove_file(&netdev->dev, &xennet_attrs[i]);
 +}
 +
 +#endif /* CONFIG_SYSFS */
 +
  static const struct xenbus_device_id netfront_ids[] = {
  	{ "vif" },
  	{ "" }
* Unmerged path drivers/net/xen-netfront.c
