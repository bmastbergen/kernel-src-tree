perf/x86/intel/uncore: Add Knights Mill CPUID

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Piotr Luc <piotr.luc@intel.com>
commit ba2f81575eba8dcf128354169c20ae23f810f652
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/ba2f8157.failed

Add Knights Mill (KNM) to the list of CPUIDs supported by PMU.

	Signed-off-by: Piotr Luc <piotr.luc@intel.com>
	Reviewed-by: Dave Hansen <dave.hansen@intel.com>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Josh Poimboeuf <jpoimboe@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20161012182758.2925-1-piotr.luc@intel.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit ba2f81575eba8dcf128354169c20ae23f810f652)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/events/intel/uncore.c
diff --cc arch/x86/events/intel/uncore.c
index 53ff22fa4cd0,efca2685d876..000000000000
--- a/arch/x86/events/intel/uncore.c
+++ b/arch/x86/events/intel/uncore.c
@@@ -1363,40 -1258,105 +1363,125 @@@ err
  	return ret;
  }
  
 -#define X86_UNCORE_MODEL_MATCH(model, init)	\
 -	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, (unsigned long)&init }
 +static void __init uncore_cpu_setup(void *dummy)
 +{
 +	uncore_cpu_starting(smp_processor_id(), true);
 +}
  
 -struct intel_uncore_init_fun {
 -	void	(*cpu_init)(void);
 -	int	(*pci_init)(void);
 -};
 +/* Lazy to avoid allocation of a few bytes for the normal case */
 +static __initdata DECLARE_BITMAP(packages, MAX_LOCAL_APIC);
  
 -static const struct intel_uncore_init_fun nhm_uncore_init __initconst = {
 -	.cpu_init = nhm_uncore_cpu_init,
 -};
 +static int __init uncore_cpumask_init(bool msr)
 +{
 +	unsigned int cpu;
  
 -static const struct intel_uncore_init_fun snb_uncore_init __initconst = {
 -	.cpu_init = snb_uncore_cpu_init,
 -	.pci_init = snb_uncore_pci_init,
 -};
 +	for_each_online_cpu(cpu) {
 +		unsigned int pkg = topology_logical_package_id(cpu);
 +		int ret;
  
++<<<<<<< HEAD
 +		if (test_and_set_bit(pkg, packages))
 +			continue;
 +		/*
 +		 * The first online cpu of each package allocates and takes
 +		 * the refcounts for all other online cpus in that package.
 +		 * If msrs are not enabled no allocation is required.
 +		 */
 +		if (msr) {
 +			ret = uncore_cpu_prepare(cpu);
 +			if (ret)
 +				return ret;
 +		}
 +		uncore_event_init_cpu(cpu);
 +		smp_call_function_single(cpu, uncore_cpu_setup, NULL, 1);
 +	}
 +	__register_cpu_notifier(&uncore_cpu_nb);
 +	return 0;
 +}
++=======
+ static const struct intel_uncore_init_fun ivb_uncore_init __initconst = {
+ 	.cpu_init = snb_uncore_cpu_init,
+ 	.pci_init = ivb_uncore_pci_init,
+ };
+ 
+ static const struct intel_uncore_init_fun hsw_uncore_init __initconst = {
+ 	.cpu_init = snb_uncore_cpu_init,
+ 	.pci_init = hsw_uncore_pci_init,
+ };
+ 
+ static const struct intel_uncore_init_fun bdw_uncore_init __initconst = {
+ 	.cpu_init = snb_uncore_cpu_init,
+ 	.pci_init = bdw_uncore_pci_init,
+ };
+ 
+ static const struct intel_uncore_init_fun snbep_uncore_init __initconst = {
+ 	.cpu_init = snbep_uncore_cpu_init,
+ 	.pci_init = snbep_uncore_pci_init,
+ };
+ 
+ static const struct intel_uncore_init_fun nhmex_uncore_init __initconst = {
+ 	.cpu_init = nhmex_uncore_cpu_init,
+ };
+ 
+ static const struct intel_uncore_init_fun ivbep_uncore_init __initconst = {
+ 	.cpu_init = ivbep_uncore_cpu_init,
+ 	.pci_init = ivbep_uncore_pci_init,
+ };
+ 
+ static const struct intel_uncore_init_fun hswep_uncore_init __initconst = {
+ 	.cpu_init = hswep_uncore_cpu_init,
+ 	.pci_init = hswep_uncore_pci_init,
+ };
+ 
+ static const struct intel_uncore_init_fun bdx_uncore_init __initconst = {
+ 	.cpu_init = bdx_uncore_cpu_init,
+ 	.pci_init = bdx_uncore_pci_init,
+ };
+ 
+ static const struct intel_uncore_init_fun knl_uncore_init __initconst = {
+ 	.cpu_init = knl_uncore_cpu_init,
+ 	.pci_init = knl_uncore_pci_init,
+ };
+ 
+ static const struct intel_uncore_init_fun skl_uncore_init __initconst = {
+ 	.cpu_init = skl_uncore_cpu_init,
+ 	.pci_init = skl_uncore_pci_init,
+ };
+ 
+ static const struct intel_uncore_init_fun skx_uncore_init __initconst = {
+ 	.cpu_init = skx_uncore_cpu_init,
+ 	.pci_init = skx_uncore_pci_init,
+ };
+ 
+ static const struct x86_cpu_id intel_uncore_match[] __initconst = {
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_NEHALEM_EP,	  nhm_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_NEHALEM,	  nhm_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_WESTMERE,	  nhm_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_WESTMERE_EP,	  nhm_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_SANDYBRIDGE,	  snb_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_IVYBRIDGE,	  ivb_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_HASWELL_CORE,	  hsw_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_HASWELL_ULT,	  hsw_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_HASWELL_GT3E,	  hsw_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_BROADWELL_CORE, bdw_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_BROADWELL_GT3E, bdw_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_SANDYBRIDGE_X,  snbep_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_NEHALEM_EX,	  nhmex_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_WESTMERE_EX,	  nhmex_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_IVYBRIDGE_X,	  ivbep_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_HASWELL_X,	  hswep_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_BROADWELL_X,	  bdx_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_BROADWELL_XEON_D, bdx_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_XEON_PHI_KNL,	  knl_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_XEON_PHI_KNM,	  knl_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_SKYLAKE_DESKTOP,skl_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_SKYLAKE_MOBILE, skl_uncore_init),
+ 	X86_UNCORE_MODEL_MATCH(INTEL_FAM6_SKYLAKE_X,      skx_uncore_init),
+ 	{},
+ };
+ 
+ MODULE_DEVICE_TABLE(x86cpu, intel_uncore_match);
++>>>>>>> ba2f81575eba (perf/x86/intel/uncore: Add Knights Mill CPUID)
  
  static int __init intel_uncore_init(void)
  {
* Unmerged path arch/x86/events/intel/uncore.c
