HID: wacom - add touch_arbitration parameter to wacom module

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom - add touch_arbitration parameter to wacom module (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.65%
commit-author Ping Cheng <pinglinux@gmail.com>
commit 1924e05e6014917b23b7648302be39cfee03d047
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1924e05e.failed

Touch arbitration is always on in wacom.ko. However, there are
touch enabled applications use both pen and touch simultaneously.
We should provide an option for userland to decide if they want
arbitration on or off.

This patch sets default touch_arbitration to on since most userland
apps are not ready to process pen and touch events simultaneously.
In the future, when userland is ready to accept pen and touch events
together, we will switch default touch_arbitration to off.

	Tested-by: Peter Hutterer <peter.hutterer@who-t.net>
	Signed-off-by: Ping Cheng <pingc@wacom.com>
	Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit 1924e05e6014917b23b7648302be39cfee03d047)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index 98c7d65145c2,a48ed4ebd5a9..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -34,6 -34,54 +34,57 @@@
   */
  #define WACOM_CONTACT_AREA_SCALE 2607
  
++<<<<<<< HEAD
++=======
+ static bool touch_arbitration = 1;
+ module_param(touch_arbitration, bool, 0644);
+ MODULE_PARM_DESC(touch_arbitration, " on (Y) off (N)");
+ 
+ static void wacom_report_numbered_buttons(struct input_dev *input_dev,
+ 				int button_count, int mask);
+ 
+ /*
+  * Percent of battery capacity for Graphire.
+  * 8th value means AC online and show 100% capacity.
+  */
+ static unsigned short batcap_gr[8] = { 1, 15, 25, 35, 50, 70, 100, 100 };
+ 
+ /*
+  * Percent of battery capacity for Intuos4 WL, AC has a separate bit.
+  */
+ static unsigned short batcap_i4[8] = { 1, 15, 30, 45, 60, 70, 85, 100 };
+ 
+ static void __wacom_notify_battery(struct wacom_battery *battery,
+ 				   int bat_capacity, bool bat_charging,
+ 				   bool bat_connected, bool ps_connected)
+ {
+ 	bool changed = battery->battery_capacity != bat_capacity  ||
+ 		       battery->bat_charging     != bat_charging  ||
+ 		       battery->bat_connected    != bat_connected ||
+ 		       battery->ps_connected     != ps_connected;
+ 
+ 	if (changed) {
+ 		battery->battery_capacity = bat_capacity;
+ 		battery->bat_charging = bat_charging;
+ 		battery->bat_connected = bat_connected;
+ 		battery->ps_connected = ps_connected;
+ 
+ 		if (battery->battery)
+ 			power_supply_changed(battery->battery);
+ 	}
+ }
+ 
+ static void wacom_notify_battery(struct wacom_wac *wacom_wac,
+ 	int bat_capacity, bool bat_charging, bool bat_connected,
+ 	bool ps_connected)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 
+ 	__wacom_notify_battery(&wacom->battery, bat_capacity, bat_charging,
+ 			       bat_connected, ps_connected);
+ }
+ 
++>>>>>>> 1924e05e6014 (HID: wacom - add touch_arbitration parameter to wacom module)
  static int wacom_penpartner_irq(struct wacom_wac *wacom)
  {
  	unsigned char *data = wacom->data;
@@@ -488,23 -761,211 +539,225 @@@ static int wacom_intuos_inout(struct wa
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void wacom_intuos_general(struct wacom_wac *wacom)
++=======
+ static int wacom_remote_irq(struct wacom_wac *wacom_wac, size_t len)
+ {
+ 	unsigned char *data = wacom_wac->data;
+ 	struct input_dev *input;
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	struct wacom_remote *remote = wacom->remote;
+ 	int bat_charging, bat_percent, touch_ring_mode;
+ 	__u32 serial;
+ 	int i, index = -1;
+ 	unsigned long flags;
+ 
+ 	if (data[0] != WACOM_REPORT_REMOTE) {
+ 		hid_dbg(wacom->hdev, "%s: received unknown report #%d",
+ 			__func__, data[0]);
+ 		return 0;
+ 	}
+ 
+ 	serial = data[3] + (data[4] << 8) + (data[5] << 16);
+ 	wacom_wac->id[0] = PAD_DEVICE_ID;
+ 
+ 	spin_lock_irqsave(&remote->remote_lock, flags);
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		if (remote->remotes[i].serial == serial) {
+ 			index = i;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (index < 0 || !remote->remotes[index].registered)
+ 		goto out;
+ 
+ 	input = remote->remotes[index].input;
+ 
+ 	input_report_key(input, BTN_0, (data[9] & 0x01));
+ 	input_report_key(input, BTN_1, (data[9] & 0x02));
+ 	input_report_key(input, BTN_2, (data[9] & 0x04));
+ 	input_report_key(input, BTN_3, (data[9] & 0x08));
+ 	input_report_key(input, BTN_4, (data[9] & 0x10));
+ 	input_report_key(input, BTN_5, (data[9] & 0x20));
+ 	input_report_key(input, BTN_6, (data[9] & 0x40));
+ 	input_report_key(input, BTN_7, (data[9] & 0x80));
+ 
+ 	input_report_key(input, BTN_8, (data[10] & 0x01));
+ 	input_report_key(input, BTN_9, (data[10] & 0x02));
+ 	input_report_key(input, BTN_A, (data[10] & 0x04));
+ 	input_report_key(input, BTN_B, (data[10] & 0x08));
+ 	input_report_key(input, BTN_C, (data[10] & 0x10));
+ 	input_report_key(input, BTN_X, (data[10] & 0x20));
+ 	input_report_key(input, BTN_Y, (data[10] & 0x40));
+ 	input_report_key(input, BTN_Z, (data[10] & 0x80));
+ 
+ 	input_report_key(input, BTN_BASE, (data[11] & 0x01));
+ 	input_report_key(input, BTN_BASE2, (data[11] & 0x02));
+ 
+ 	if (data[12] & 0x80)
+ 		input_report_abs(input, ABS_WHEEL, (data[12] & 0x7f));
+ 	else
+ 		input_report_abs(input, ABS_WHEEL, 0);
+ 
+ 	bat_percent = data[7] & 0x7f;
+ 	bat_charging = !!(data[7] & 0x80);
+ 
+ 	if (data[9] | data[10] | (data[11] & 0x03) | data[12])
+ 		input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 	else
+ 		input_report_abs(input, ABS_MISC, 0);
+ 
+ 	input_event(input, EV_MSC, MSC_SERIAL, serial);
+ 
+ 	input_sync(input);
+ 
+ 	/*Which mode select (LED light) is currently on?*/
+ 	touch_ring_mode = (data[11] & 0xC0) >> 6;
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		if (remote->remotes[i].serial == serial)
+ 			wacom->led.groups[i].select = touch_ring_mode;
+ 	}
+ 
+ 	__wacom_notify_battery(&remote->remotes[index].battery, bat_percent,
+ 				bat_charging, 1, bat_charging);
+ 
+ out:
+ 	spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 	return 0;
+ }
+ 
+ static void wacom_remote_status_irq(struct wacom_wac *wacom_wac, size_t len)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	unsigned char *data = wacom_wac->data;
+ 	struct wacom_remote *remote = wacom->remote;
+ 	struct wacom_remote_data remote_data;
+ 	unsigned long flags;
+ 	int i, ret;
+ 
+ 	if (data[0] != WACOM_REPORT_DEVICE_LIST)
+ 		return;
+ 
+ 	memset(&remote_data, 0, sizeof(struct wacom_remote_data));
+ 
+ 	for (i = 0; i < WACOM_MAX_REMOTES; i++) {
+ 		int j = i * 6;
+ 		int serial = (data[j+6] << 16) + (data[j+5] << 8) + data[j+4];
+ 		bool connected = data[j+2];
+ 
+ 		remote_data.remote[i].serial = serial;
+ 		remote_data.remote[i].connected = connected;
+ 	}
+ 
+ 	spin_lock_irqsave(&remote->remote_lock, flags);
+ 
+ 	ret = kfifo_in(&remote->remote_fifo, &remote_data, sizeof(remote_data));
+ 	if (ret != sizeof(remote_data)) {
+ 		spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 		hid_err(wacom->hdev, "Can't queue Remote status event.\n");
+ 		return;
+ 	}
+ 
+ 	spin_unlock_irqrestore(&remote->remote_lock, flags);
+ 
+ 	wacom_schedule_work(wacom_wac, WACOM_WORKER_REMOTE);
+ }
+ 
+ static inline bool report_touch_events(struct wacom_wac *wacom)
+ {
+ 	return (touch_arbitration ? !wacom->shared->stylus_in_proximity : 1);
+ }
+ 
+ static inline bool delay_pen_events(struct wacom_wac *wacom)
+ {
+ 	return (wacom->shared->touch_down && touch_arbitration);
+ }
+ 
+ static int wacom_intuos_general(struct wacom_wac *wacom)
++>>>>>>> 1924e05e6014 (HID: wacom - add touch_arbitration parameter to wacom module)
  {
  	struct wacom_features *features = &wacom->features;
  	unsigned char *data = wacom->data;
 -	struct input_dev *input = wacom->pen_input;
 -	int idx = (features->type == INTUOS) ? (data[1] & 0x01) : 0;
 -	unsigned char type = (data[1] >> 1) & 0x0F;
 -	unsigned int x, y, distance, t;
 +	struct input_dev *input = wacom->input;
 +	unsigned int t;
  
++<<<<<<< HEAD
 +	/* general pen packet */
 +	if ((data[1] & 0xb8) == 0xa0) {
 +		t = (data[6] << 2) | ((data[7] >> 6) & 3);
 +		if (features->type >= INTUOS4S && features->type <= WACOM_24HD) {
 +			t = (t << 1) | (data[1] & 1);
++=======
+ 	if (data[0] != WACOM_REPORT_PENABLED && data[0] != WACOM_REPORT_CINTIQ &&
+ 		data[0] != WACOM_REPORT_INTUOS_PEN)
+ 		return 0;
+ 
+ 	if (delay_pen_events(wacom))
+ 		return 1;
+ 
+ 	/* don't report events if we don't know the tool ID */
+ 	if (!wacom->id[idx]) {
+ 		/* but reschedule a read of the current tool */
+ 		wacom_intuos_schedule_prox_event(wacom);
+ 		return 1;
+ 	}
+ 
+ 	/*
+ 	 * don't report events for invalid data
+ 	 */
+ 	/* older I4 styli don't work with new Cintiqs */
+ 	if ((!((wacom->id[idx] >> 20) & 0x01) &&
+ 			(features->type == WACOM_21UX2)) ||
+ 	    /* Only large Intuos support Lense Cursor */
+ 	    (wacom->tool[idx] == BTN_TOOL_LENS &&
+ 		(features->type == INTUOS3 ||
+ 		 features->type == INTUOS3S ||
+ 		 features->type == INTUOS4 ||
+ 		 features->type == INTUOS4S ||
+ 		 features->type == INTUOS5 ||
+ 		 features->type == INTUOS5S ||
+ 		 features->type == INTUOSPM ||
+ 		 features->type == INTUOSPS)) ||
+ 	   /* Cintiq doesn't send data when RDY bit isn't set */
+ 	   (features->type == CINTIQ && !(data[1] & 0x40)))
+ 		return 1;
+ 
+ 	x = (be16_to_cpup((__be16 *)&data[2]) << 1) | ((data[9] >> 1) & 1);
+ 	y = (be16_to_cpup((__be16 *)&data[4]) << 1) | (data[9] & 1);
+ 	distance = data[9] >> 2;
+ 	if (features->type < INTUOS3S) {
+ 		x >>= 1;
+ 		y >>= 1;
+ 		distance >>= 1;
+ 	}
+ 	input_report_abs(input, ABS_X, x);
+ 	input_report_abs(input, ABS_Y, y);
+ 	input_report_abs(input, ABS_DISTANCE, distance);
+ 
+ 	switch (type) {
+ 	case 0x00:
+ 	case 0x01:
+ 	case 0x02:
+ 	case 0x03:
+ 		/* general pen packet */
+ 		t = (data[6] << 3) | ((data[7] & 0xC0) >> 5) | (data[1] & 1);
+ 		if (features->pressure_max < 2047)
+ 			t >>= 1;
+ 		input_report_abs(input, ABS_PRESSURE, t);
+ 		if (features->type != INTUOSHT2) {
+ 		    input_report_abs(input, ABS_TILT_X,
+ 				 (((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
+ 		    input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
++>>>>>>> 1924e05e6014 (HID: wacom - add touch_arbitration parameter to wacom module)
  		}
 +		input_report_abs(input, ABS_PRESSURE, t);
 +		input_report_abs(input, ABS_TILT_X,
 +				 (((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
 +		input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
  		input_report_key(input, BTN_STYLUS, data[1] & 2);
  		input_report_key(input, BTN_STYLUS2, data[1] & 4);
  		input_report_key(input, BTN_TOUCH, t > 10);
@@@ -540,311 -1085,108 +793,384 @@@ static int wacom_intuos_irq(struct waco
                  return 0;
  	}
  
 -	/* process pad events */
 -	result = wacom_intuos_pad(wacom);
 -	if (result)
 -		return result;
 +	/* tool number */
 +	if (features->type == INTUOS)
 +		idx = data[1] & 0x01;
  
 -	/* process in/out prox events */
 -	result = wacom_intuos_inout(wacom);
 -	if (result)
 -		return result - 1;
 +	/* pad packets. Works as a second tool and is always in prox */
 +	if (data[0] == WACOM_REPORT_INTUOSPAD || data[0] == WACOM_REPORT_INTUOS5PAD ||
 +	    data[0] == WACOM_REPORT_CINTIQPAD) {
 +		if (features->type >= INTUOS4S && features->type <= INTUOS4L) {
 +			input_report_key(input, BTN_0, (data[2] & 0x01));
 +			input_report_key(input, BTN_1, (data[3] & 0x01));
 +			input_report_key(input, BTN_2, (data[3] & 0x02));
 +			input_report_key(input, BTN_3, (data[3] & 0x04));
 +			input_report_key(input, BTN_4, (data[3] & 0x08));
 +			input_report_key(input, BTN_5, (data[3] & 0x10));
 +			input_report_key(input, BTN_6, (data[3] & 0x20));
 +			if (data[1] & 0x80) {
 +				input_report_abs(input, ABS_WHEEL, (data[1] & 0x7f));
 +			} else {
 +				/* Out of proximity, clear wheel value. */
 +				input_report_abs(input, ABS_WHEEL, 0);
 +			}
 +			if (features->type != INTUOS4S) {
 +				input_report_key(input, BTN_7, (data[3] & 0x40));
 +				input_report_key(input, BTN_8, (data[3] & 0x80));
 +			}
 +			if (data[1] | (data[2] & 0x01) | data[3]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type == DTK) {
 +			input_report_key(input, BTN_0, (data[6] & 0x01));
 +			input_report_key(input, BTN_1, (data[6] & 0x02));
 +			input_report_key(input, BTN_2, (data[6] & 0x04));
 +			input_report_key(input, BTN_3, (data[6] & 0x08));
 +			input_report_key(input, BTN_4, (data[6] & 0x10));
 +			input_report_key(input, BTN_5, (data[6] & 0x20));
 +			if (data[6] & 0x3f) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type == WACOM_13HD) {
 +			input_report_key(input, BTN_0, (data[3] & 0x01));
 +			input_report_key(input, BTN_1, (data[4] & 0x01));
 +			input_report_key(input, BTN_2, (data[4] & 0x02));
 +			input_report_key(input, BTN_3, (data[4] & 0x04));
 +			input_report_key(input, BTN_4, (data[4] & 0x08));
 +			input_report_key(input, BTN_5, (data[4] & 0x10));
 +			input_report_key(input, BTN_6, (data[4] & 0x20));
 +			input_report_key(input, BTN_7, (data[4] & 0x40));
 +			input_report_key(input, BTN_8, (data[4] & 0x80));
 +			if ((data[3] & 0x01) | data[4]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type == WACOM_24HD) {
 +			input_report_key(input, BTN_0, (data[6] & 0x01));
 +			input_report_key(input, BTN_1, (data[6] & 0x02));
 +			input_report_key(input, BTN_2, (data[6] & 0x04));
 +			input_report_key(input, BTN_3, (data[6] & 0x08));
 +			input_report_key(input, BTN_4, (data[6] & 0x10));
 +			input_report_key(input, BTN_5, (data[6] & 0x20));
 +			input_report_key(input, BTN_6, (data[6] & 0x40));
 +			input_report_key(input, BTN_7, (data[6] & 0x80));
 +			input_report_key(input, BTN_8, (data[8] & 0x01));
 +			input_report_key(input, BTN_9, (data[8] & 0x02));
 +			input_report_key(input, BTN_A, (data[8] & 0x04));
 +			input_report_key(input, BTN_B, (data[8] & 0x08));
 +			input_report_key(input, BTN_C, (data[8] & 0x10));
 +			input_report_key(input, BTN_X, (data[8] & 0x20));
 +			input_report_key(input, BTN_Y, (data[8] & 0x40));
 +			input_report_key(input, BTN_Z, (data[8] & 0x80));
  
 -	/* process general packets */
 -	result = wacom_intuos_general(wacom);
 -	if (result)
 -		return result - 1;
 +			/*
 +			 * Three "buttons" are available on the 24HD which are
 +			 * physically implemented as a touchstrip. Each button
 +			 * is approximately 3 bits wide with a 2 bit spacing.
 +			 * The raw touchstrip bits are stored at:
 +			 *    ((data[3] & 0x1f) << 8) | data[4])
 +			 */
 +			input_report_key(input, KEY_PROG1, data[4] & 0x07);
 +			input_report_key(input, KEY_PROG2, data[4] & 0xE0);
 +			input_report_key(input, KEY_PROG3, data[3] & 0x1C);
  
 -	return 0;
 -}
 +			if (data[1] & 0x80) {
 +				input_report_abs(input, ABS_WHEEL, (data[1] & 0x7f));
 +			} else {
 +				/* Out of proximity, clear wheel value. */
 +				input_report_abs(input, ABS_WHEEL, 0);
 +			}
  
 -static int int_dist(int x1, int y1, int x2, int y2)
 -{
 -	int x = x2 - x1;
 -	int y = y2 - y1;
 +			if (data[2] & 0x80) {
 +				input_report_abs(input, ABS_THROTTLE, (data[2] & 0x7f));
 +			} else {
 +				/* Out of proximity, clear second wheel value. */
 +				input_report_abs(input, ABS_THROTTLE, 0);
 +			}
  
 -	return int_sqrt(x*x + y*y);
 -}
 +			if (data[1] | data[2] | (data[3] & 0x1f) | data[4] | data[6] | data[8]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type == WACOM_27QHD) {
 +			input_report_key(input, KEY_PROG1, data[2] & 0x01);
 +			input_report_key(input, KEY_PROG2, data[2] & 0x02);
 +			input_report_key(input, KEY_PROG3, data[2] & 0x04);
 +
 +			input_report_abs(input, ABS_X, be16_to_cpup((__be16 *)&data[4]));
 +			input_report_abs(input, ABS_Y, be16_to_cpup((__be16 *)&data[6]));
 +			input_report_abs(input, ABS_Z, be16_to_cpup((__be16 *)&data[8]));
 +			if ((data[2] & 0x07) | data[4] | data[5] | data[6] | data[7] | data[8] | data[9]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type >= INTUOS5S && features->type <= INTUOSPL) {
 +			int i;
  
 -static void wacom_intuos_bt_process_data(struct wacom_wac *wacom,
 -		unsigned char *data)
 -{
 -	memcpy(wacom->data, data, 10);
 -	wacom_intuos_irq(wacom);
 +			/* Touch ring mode switch has no capacitive sensor */
 +			input_report_key(input, BTN_0, (data[3] & 0x01));
  
 -	input_sync(wacom->pen_input);
 -	if (wacom->pad_input)
 -		input_sync(wacom->pad_input);
 -}
 +			/*
 +			 * ExpressKeys on Intuos5/Intuos Pro have a capacitive sensor in
 +			 * addition to the mechanical switch. Switch data is
 +			 * stored in data[4], capacitive data in data[5].
 +			 */
 +			for (i = 0; i < 8; i++)
 +				input_report_key(input, BTN_1 + i, data[4] & (1 << i));
  
 -static int wacom_intuos_bt_irq(struct wacom_wac *wacom, size_t len)
 -{
 -	unsigned char data[WACOM_PKGLEN_MAX];
 -	int i = 1;
 -	unsigned power_raw, battery_capacity, bat_charging, ps_connected;
 +			if (data[2] & 0x80) {
 +				input_report_abs(input, ABS_WHEEL, (data[2] & 0x7f));
 +			} else {
 +				/* Out of proximity, clear wheel value. */
 +				input_report_abs(input, ABS_WHEEL, 0);
 +			}
  
 -	memcpy(data, wacom->data, len);
 +			if (data[2] | (data[3] & 0x01) | data[4] | data[5]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else {
 +			if (features->type == WACOM_21UX2 || features->type == WACOM_22HD) {
 +				input_report_key(input, BTN_0, (data[5] & 0x01));
 +				input_report_key(input, BTN_1, (data[6] & 0x01));
 +				input_report_key(input, BTN_2, (data[6] & 0x02));
 +				input_report_key(input, BTN_3, (data[6] & 0x04));
 +				input_report_key(input, BTN_4, (data[6] & 0x08));
 +				input_report_key(input, BTN_5, (data[6] & 0x10));
 +				input_report_key(input, BTN_6, (data[6] & 0x20));
 +				input_report_key(input, BTN_7, (data[6] & 0x40));
 +				input_report_key(input, BTN_8, (data[6] & 0x80));
 +				input_report_key(input, BTN_9, (data[7] & 0x01));
 +				input_report_key(input, BTN_A, (data[8] & 0x01));
 +				input_report_key(input, BTN_B, (data[8] & 0x02));
 +				input_report_key(input, BTN_C, (data[8] & 0x04));
 +				input_report_key(input, BTN_X, (data[8] & 0x08));
 +				input_report_key(input, BTN_Y, (data[8] & 0x10));
 +				input_report_key(input, BTN_Z, (data[8] & 0x20));
 +				input_report_key(input, BTN_BASE, (data[8] & 0x40));
 +				input_report_key(input, BTN_BASE2, (data[8] & 0x80));
 +
 +				if (features->type == WACOM_22HD) {
 +					input_report_key(input, KEY_PROG1, data[9] & 0x01);
 +					input_report_key(input, KEY_PROG2, data[9] & 0x02);
 +					input_report_key(input, KEY_PROG3, data[9] & 0x04);
 +				}
 +			} else {
 +				input_report_key(input, BTN_0, (data[5] & 0x01));
 +				input_report_key(input, BTN_1, (data[5] & 0x02));
 +				input_report_key(input, BTN_2, (data[5] & 0x04));
 +				input_report_key(input, BTN_3, (data[5] & 0x08));
 +				input_report_key(input, BTN_4, (data[6] & 0x01));
 +				input_report_key(input, BTN_5, (data[6] & 0x02));
 +				input_report_key(input, BTN_6, (data[6] & 0x04));
 +				input_report_key(input, BTN_7, (data[6] & 0x08));
 +				input_report_key(input, BTN_8, (data[5] & 0x10));
 +				input_report_key(input, BTN_9, (data[6] & 0x10));
 +			}
 +			input_report_abs(input, ABS_RX, ((data[1] & 0x1f) << 8) | data[2]);
 +			input_report_abs(input, ABS_RY, ((data[3] & 0x1f) << 8) | data[4]);
  
 -	switch (data[0]) {
 -	case 0x04:
 -		wacom_intuos_bt_process_data(wacom, data + i);
 -		i += 10;
 -		/* fall through */
 -	case 0x03:
 +			if ((data[5] & 0x1f) | data[6] | (data[1] & 0x1f) |
 +				data[2] | (data[3] & 0x1f) | data[4] | data[8] |
 +				(data[7] & 0x01)) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		}
 +		input_event(input, EV_MSC, MSC_SERIAL, 0xffffffff);
 +                return 1;
 +	}
 +
 +	/* process in/out prox events */
 +	result = wacom_intuos_inout(wacom);
 +	if (result)
 +                return result - 1;
 +
 +	if (features->type >= INTUOS3S) {
 +		input_report_abs(input, ABS_X, (data[2] << 9) | (data[3] << 1) | ((data[9] >> 1) & 1));
 +		input_report_abs(input, ABS_Y, (data[4] << 9) | (data[5] << 1) | (data[9] & 1));
 +		input_report_abs(input, ABS_DISTANCE, ((data[9] >> 2) & 0x3f));
 +	} else {
 +		input_report_abs(input, ABS_X, be16_to_cpup((__be16 *)&data[2]));
 +		input_report_abs(input, ABS_Y, be16_to_cpup((__be16 *)&data[4]));
 +		input_report_abs(input, ABS_DISTANCE, ((data[9] >> 3) & 0x1f));
 +	}
 +
 +	/* process general packets */
 +	wacom_intuos_general(wacom);
 +
 +	/* 4D mouse, 2D mouse, marker pen rotation, tilt mouse, or Lens cursor packets */
 +	if ((data[1] & 0xbc) == 0xa8 || (data[1] & 0xbe) == 0xb0 || (data[1] & 0xbc) == 0xac) {
 +
 +		if (data[1] & 0x02) {
 +			/* Rotation packet */
 +			if (features->type >= INTUOS3S) {
 +				/* I3 marker pen rotation */
 +				t = (data[6] << 3) | ((data[7] >> 5) & 7);
 +				t = (data[7] & 0x20) ? ((t > 900) ? ((t-1) / 2 - 1350) :
 +					((t-1) / 2 + 450)) : (450 - t / 2) ;
 +				input_report_abs(input, ABS_Z, t);
 +			} else {
 +				/* 4D mouse rotation packet */
 +				t = (data[6] << 3) | ((data[7] >> 5) & 7);
 +				input_report_abs(input, ABS_RZ, (data[7] & 0x20) ?
 +					((t - 1) / 2) : -t / 2);
 +			}
 +
 +		} else if (!(data[1] & 0x10) && features->type < INTUOS3S) {
 +			/* 4D mouse packet */
 +			input_report_key(input, BTN_LEFT,   data[8] & 0x01);
 +			input_report_key(input, BTN_MIDDLE, data[8] & 0x02);
 +			input_report_key(input, BTN_RIGHT,  data[8] & 0x04);
 +
 +			input_report_key(input, BTN_SIDE,   data[8] & 0x20);
 +			input_report_key(input, BTN_EXTRA,  data[8] & 0x10);
 +			t = (data[6] << 2) | ((data[7] >> 6) & 3);
 +			input_report_abs(input, ABS_THROTTLE, (data[8] & 0x08) ? -t : t);
 +
 +		} else if (wacom->tool[idx] == BTN_TOOL_MOUSE) {
 +			/* I4 mouse */
 +			if (features->type >= INTUOS4S && features->type <= INTUOSPL) {
 +				input_report_key(input, BTN_LEFT,   data[6] & 0x01);
 +				input_report_key(input, BTN_MIDDLE, data[6] & 0x02);
 +				input_report_key(input, BTN_RIGHT,  data[6] & 0x04);
 +				input_report_rel(input, REL_WHEEL, ((data[7] & 0x80) >> 7)
 +						 - ((data[7] & 0x40) >> 6));
 +				input_report_key(input, BTN_SIDE,   data[6] & 0x08);
 +				input_report_key(input, BTN_EXTRA,  data[6] & 0x10);
 +
 +				input_report_abs(input, ABS_TILT_X,
 +					(((data[7] << 1) & 0x7e) | (data[8] >> 7)) - 64);
 +				input_report_abs(input, ABS_TILT_Y, (data[8] & 0x7f) - 64);
 +			} else {
 +				/* 2D mouse packet */
 +				input_report_key(input, BTN_LEFT,   data[8] & 0x04);
 +				input_report_key(input, BTN_MIDDLE, data[8] & 0x08);
 +				input_report_key(input, BTN_RIGHT,  data[8] & 0x10);
 +				input_report_rel(input, REL_WHEEL, (data[8] & 0x01)
 +						 - ((data[8] & 0x02) >> 1));
 +
 +				/* I3 2D mouse side buttons */
 +				if (features->type >= INTUOS3S && features->type <= INTUOS3L) {
 +					input_report_key(input, BTN_SIDE,   data[8] & 0x40);
 +					input_report_key(input, BTN_EXTRA,  data[8] & 0x20);
 +				}
 +			}
 +		} else if ((features->type < INTUOS3S || features->type == INTUOS3L ||
 +				features->type == INTUOS4L || features->type == INTUOS5L ||
 +				features->type == INTUOSPL) &&
 +			   wacom->tool[idx] == BTN_TOOL_LENS) {
 +			/* Lens cursor packets */
 +			input_report_key(input, BTN_LEFT,   data[8] & 0x01);
 +			input_report_key(input, BTN_MIDDLE, data[8] & 0x02);
 +			input_report_key(input, BTN_RIGHT,  data[8] & 0x04);
 +			input_report_key(input, BTN_SIDE,   data[8] & 0x10);
 +			input_report_key(input, BTN_EXTRA,  data[8] & 0x08);
 +		}
 +	}
 +
 +	input_report_abs(input, ABS_MISC, wacom->id[idx]); /* report tool id */
 +	input_report_key(input, wacom->tool[idx], 1);
 +	input_event(input, EV_MSC, MSC_SERIAL, wacom->serial[idx]);
 +	return 1;
 +}
 +
 +static int int_dist(int x1, int y1, int x2, int y2)
 +{
 +	int x = x2 - x1;
 +	int y = y2 - y1;
 +
 +	return int_sqrt(x*x + y*y);
 +}
 +
++<<<<<<< HEAD
++=======
++static void wacom_intuos_bt_process_data(struct wacom_wac *wacom,
++		unsigned char *data)
++{
++	memcpy(wacom->data, data, 10);
++	wacom_intuos_irq(wacom);
++
++	input_sync(wacom->pen_input);
++	if (wacom->pad_input)
++		input_sync(wacom->pad_input);
++}
++
++static int wacom_intuos_bt_irq(struct wacom_wac *wacom, size_t len)
++{
++	unsigned char data[WACOM_PKGLEN_MAX];
++	int i = 1;
++	unsigned power_raw, battery_capacity, bat_charging, ps_connected;
++
++	memcpy(data, wacom->data, len);
++
++	switch (data[0]) {
++	case 0x04:
++		wacom_intuos_bt_process_data(wacom, data + i);
++		i += 10;
++		/* fall through */
++	case 0x03:
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		wacom_intuos_bt_process_data(wacom, data + i);
+ 		i += 10;
+ 		power_raw = data[i];
+ 		bat_charging = (power_raw & 0x08) ? 1 : 0;
+ 		ps_connected = (power_raw & 0x10) ? 1 : 0;
+ 		battery_capacity = batcap_i4[power_raw & 0x07];
+ 		wacom_notify_battery(wacom, battery_capacity, bat_charging,
+ 				     battery_capacity || bat_charging,
+ 				     ps_connected);
+ 		break;
+ 	default:
+ 		dev_dbg(wacom->pen_input->dev.parent,
+ 				"Unknown report: %d,%d size:%zu\n",
+ 				data[0], data[1], len);
+ 		return 0;
+ 	}
+ 	return 0;
+ }
+ 
+ static int wacom_wac_finger_count_touches(struct wacom_wac *wacom)
+ {
+ 	struct input_dev *input = wacom->touch_input;
+ 	unsigned touch_max = wacom->features.touch_max;
+ 	int count = 0;
+ 	int i;
+ 
+ 	if (!touch_max)
+ 		return 0;
+ 
+ 	if (touch_max == 1)
+ 		return test_bit(BTN_TOUCH, input->key) &&
+ 			report_touch_events(wacom);
+ 
+ 	for (i = 0; i < input->mt->num_slots; i++) {
+ 		struct input_mt_slot *ps = &input->mt->slots[i];
+ 		int id = input_mt_get_value(ps, ABS_MT_TRACKING_ID);
+ 		if (id >= 0)
+ 			count++;
+ 	}
+ 
+ 	return count;
+ }
+ 
++>>>>>>> 1924e05e6014 (HID: wacom - add touch_arbitration parameter to wacom module)
  static int wacom_24hdt_irq(struct wacom_wac *wacom)
  {
 -	struct input_dev *input = wacom->touch_input;
 -	unsigned char *data = wacom->data;
 +	struct input_dev *input = wacom->input;
 +	char *data = wacom->data;
  	int i;
 -	int current_num_contacts = data[61];
 +	int current_num_contacts = 0;
  	int contacts_to_send = 0;
  	int num_contacts_left = 4; /* maximum contacts per packet */
  	int byte_per_packet = WACOM_BYTES_PER_24HDT_PACKET;
@@@ -870,7 -1210,7 +1196,11 @@@
  
  	for (i = 0; i < contacts_to_send; i++) {
  		int offset = (byte_per_packet * i) + 1;
++<<<<<<< HEAD
 +		bool touch = data[offset] & 0x1 && !wacom->shared->stylus_in_proximity;
++=======
+ 		bool touch = (data[offset] & 0x1) && report_touch_events(wacom);
++>>>>>>> 1924e05e6014 (HID: wacom - add touch_arbitration parameter to wacom module)
  		int slot = input_mt_get_slot_by_key(input, data[offset + 1]);
  
  		if (slot < 0)
@@@ -933,8 -1274,8 +1263,13 @@@ static int wacom_mt_touch(struct wacom_
  
  	for (i = 0; i < contacts_to_send; i++) {
  		int offset = (WACOM_BYTES_PER_MT_PACKET + x_offset) * i + 3;
++<<<<<<< HEAD
 +		bool touch = data[offset] & 0x1;
 +		int id = le16_to_cpup((__le16 *)&data[offset + 1]);
++=======
+ 		bool touch = (data[offset] & 0x1) && report_touch_events(wacom);
+ 		int id = get_unaligned_le16(&data[offset + 1]);
++>>>>>>> 1924e05e6014 (HID: wacom - add touch_arbitration parameter to wacom module)
  		int slot = input_mt_get_slot_by_key(input, id);
  
  		if (slot < 0)
@@@ -990,9 -1330,9 +1325,15 @@@ static int wacom_tpc_mt_touch(struct wa
  
  static int wacom_tpc_single_touch(struct wacom_wac *wacom, size_t len)
  {
++<<<<<<< HEAD
 +	char *data = wacom->data;
 +	struct input_dev *input = wacom->input;
 +	bool prox;
++=======
+ 	unsigned char *data = wacom->data;
+ 	struct input_dev *input = wacom->touch_input;
+ 	bool prox = report_touch_events(wacom);
++>>>>>>> 1924e05e6014 (HID: wacom - add touch_arbitration parameter to wacom module)
  	int x = 0, y = 0;
  
  	if (wacom->features.touch_max > 1 || len > WACOM_PKGLEN_TPC2FG)
@@@ -1090,6 -1435,410 +1433,413 @@@ static int wacom_tpc_irq(struct wacom_w
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_map_usage(struct input_dev *input, struct hid_usage *usage,
+ 		struct hid_field *field, __u8 type, __u16 code, int fuzz)
+ {
+ 	int fmin = field->logical_minimum;
+ 	int fmax = field->logical_maximum;
+ 
+ 	usage->type = type;
+ 	usage->code = code;
+ 
+ 	set_bit(type, input->evbit);
+ 
+ 	switch (type) {
+ 	case EV_ABS:
+ 		input_set_abs_params(input, code, fmin, fmax, fuzz, 0);
+ 		input_abs_set_res(input, code,
+ 				  hidinput_calc_abs_res(field, code));
+ 		break;
+ 	case EV_KEY:
+ 		input_set_capability(input, EV_KEY, code);
+ 		break;
+ 	case EV_MSC:
+ 		input_set_capability(input, EV_MSC, code);
+ 		break;
+ 	}
+ }
+ 
+ static void wacom_wac_pen_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->pen_input;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_X, 4);
+ 		break;
+ 	case HID_GD_Y:
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 4);
+ 		break;
+ 	case HID_DG_TIPPRESSURE:
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_PRESSURE, 0);
+ 		break;
+ 	case HID_DG_INRANGE:
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_TOOL_PEN, 0);
+ 		break;
+ 	case HID_DG_INVERT:
+ 		wacom_map_usage(input, usage, field, EV_KEY,
+ 				BTN_TOOL_RUBBER, 0);
+ 		break;
+ 	case HID_DG_ERASER:
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);
+ 		break;
+ 	case HID_DG_BARRELSWITCH:
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_STYLUS, 0);
+ 		break;
+ 	case HID_DG_BARRELSWITCH2:
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_STYLUS2, 0);
+ 		break;
+ 	case HID_DG_TOOLSERIALNUMBER:
+ 		wacom_map_usage(input, usage, field, EV_MSC, MSC_SERIAL, 0);
+ 		break;
+ 	}
+ }
+ 
+ static int wacom_wac_pen_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->pen_input;
+ 
+ 	/* checking which Tool / tip switch to send */
+ 	switch (usage->hid) {
+ 	case HID_DG_INRANGE:
+ 		wacom_wac->hid_data.inrange_state = value;
+ 		return 0;
+ 	case HID_DG_INVERT:
+ 		wacom_wac->hid_data.invert_state = value;
+ 		return 0;
+ 	case HID_DG_ERASER:
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_wac->hid_data.tipswitch |= value;
+ 		return 0;
+ 	}
+ 
+ 	/* send pen events only when touch is up or forced out
+ 	 * or touch arbitration is off
+ 	 */
+ 	if (!usage->type || delay_pen_events(wacom_wac))
+ 		return 0;
+ 
+ 	input_event(input, usage->type, usage->code, value);
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_wac_pen_pre_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	return;
+ }
+ 
+ static void wacom_wac_pen_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->pen_input;
+ 	bool prox = wacom_wac->hid_data.inrange_state;
+ 
+ 	if (!wacom_wac->shared->stylus_in_proximity) /* first in prox */
+ 		/* Going into proximity select tool */
+ 		wacom_wac->tool[0] = wacom_wac->hid_data.invert_state ?
+ 						BTN_TOOL_RUBBER : BTN_TOOL_PEN;
+ 
+ 	/* keep pen state for touch events */
+ 	wacom_wac->shared->stylus_in_proximity = prox;
+ 
+ 	if (!delay_pen_events(wacom_wac)) {
+ 		input_report_key(input, BTN_TOUCH,
+ 				wacom_wac->hid_data.tipswitch);
+ 		input_report_key(input, wacom_wac->tool[0], prox);
+ 
+ 		wacom_wac->hid_data.tipswitch = false;
+ 
+ 		input_sync(input);
+ 	}
+ }
+ 
+ static void wacom_wac_finger_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 	struct input_dev *input = wacom_wac->touch_input;
+ 	unsigned touch_max = wacom_wac->features.touch_max;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		features->last_slot_field = usage->hid;
+ 		if (touch_max == 1)
+ 			wacom_map_usage(input, usage, field, EV_ABS, ABS_X, 4);
+ 		else
+ 			wacom_map_usage(input, usage, field, EV_ABS,
+ 					ABS_MT_POSITION_X, 4);
+ 		break;
+ 	case HID_GD_Y:
+ 		features->last_slot_field = usage->hid;
+ 		if (touch_max == 1)
+ 			wacom_map_usage(input, usage, field, EV_ABS, ABS_Y, 4);
+ 		else
+ 			wacom_map_usage(input, usage, field, EV_ABS,
+ 					ABS_MT_POSITION_Y, 4);
+ 		break;
+ 	case HID_DG_WIDTH:
+ 	case HID_DG_HEIGHT:
+ 		features->last_slot_field = usage->hid;
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_MT_TOUCH_MAJOR, 0);
+ 		wacom_map_usage(input, usage, field, EV_ABS, ABS_MT_TOUCH_MINOR, 0);
+ 		input_set_abs_params(input, ABS_MT_ORIENTATION, 0, 1, 0, 0);
+ 		break;
+ 	case HID_DG_CONTACTID:
+ 		features->last_slot_field = usage->hid;
+ 		break;
+ 	case HID_DG_INRANGE:
+ 		features->last_slot_field = usage->hid;
+ 		break;
+ 	case HID_DG_INVERT:
+ 		features->last_slot_field = usage->hid;
+ 		break;
+ 	case HID_DG_TIPSWITCH:
+ 		features->last_slot_field = usage->hid;
+ 		wacom_map_usage(input, usage, field, EV_KEY, BTN_TOUCH, 0);
+ 		break;
+ 	case HID_DG_CONTACTCOUNT:
+ 		wacom_wac->hid_data.cc_report = field->report->id;
+ 		wacom_wac->hid_data.cc_index = field->index;
+ 		wacom_wac->hid_data.cc_value_index = usage->usage_index;
+ 		break;
+ 	}
+ }
+ 
+ static void wacom_wac_finger_slot(struct wacom_wac *wacom_wac,
+ 		struct input_dev *input)
+ {
+ 	struct hid_data *hid_data = &wacom_wac->hid_data;
+ 	bool mt = wacom_wac->features.touch_max > 1;
+ 	bool prox = hid_data->tipswitch &&
+ 		    report_touch_events(wacom_wac);
+ 
+ 	wacom_wac->hid_data.num_received++;
+ 	if (wacom_wac->hid_data.num_received > wacom_wac->hid_data.num_expected)
+ 		return;
+ 
+ 	if (mt) {
+ 		int slot;
+ 
+ 		slot = input_mt_get_slot_by_key(input, hid_data->id);
+ 		input_mt_slot(input, slot);
+ 		input_mt_report_slot_state(input, MT_TOOL_FINGER, prox);
+ 	}
+ 	else {
+ 		input_report_key(input, BTN_TOUCH, prox);
+ 	}
+ 
+ 	if (prox) {
+ 		input_report_abs(input, mt ? ABS_MT_POSITION_X : ABS_X,
+ 				 hid_data->x);
+ 		input_report_abs(input, mt ? ABS_MT_POSITION_Y : ABS_Y,
+ 				 hid_data->y);
+ 
+ 		if (test_bit(ABS_MT_TOUCH_MAJOR, input->absbit)) {
+ 			input_report_abs(input, ABS_MT_TOUCH_MAJOR, max(hid_data->width, hid_data->height));
+ 			input_report_abs(input, ABS_MT_TOUCH_MINOR, min(hid_data->width, hid_data->height));
+ 			if (hid_data->width != hid_data->height)
+ 				input_report_abs(input, ABS_MT_ORIENTATION, hid_data->width <= hid_data->height ? 0 : 1);
+ 		}
+ 	}
+ }
+ 
+ static int wacom_wac_finger_event(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 
+ 	switch (usage->hid) {
+ 	case HID_GD_X:
+ 		wacom_wac->hid_data.x = value;
+ 		break;
+ 	case HID_GD_Y:
+ 		wacom_wac->hid_data.y = value;
+ 		break;
+ 	case HID_DG_WIDTH:
+ 		wacom_wac->hid_data.width = value;
+ 		break;
+ 	case HID_DG_HEIGHT:
+ 		wacom_wac->hid_data.height = value;
+ 		break;
+ 	case HID_DG_CONTACTID:
+ 		wacom_wac->hid_data.id = value;
+ 		break;
+ 	case HID_DG_TIPSWITCH:
+ 		wacom_wac->hid_data.tipswitch = value;
+ 		break;
+ 	}
+ 
+ 
+ 	if (usage->usage_index + 1 == field->report_count) {
+ 		if (usage->hid == wacom_wac->features.last_slot_field)
+ 			wacom_wac_finger_slot(wacom_wac, wacom_wac->touch_input);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_wac_finger_pre_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_data* hid_data = &wacom_wac->hid_data;
+ 
+ 	if (hid_data->cc_report != 0 &&
+ 	    hid_data->cc_report != report->id) {
+ 		int i;
+ 
+ 		hid_data->cc_report = report->id;
+ 		hid_data->cc_index = -1;
+ 		hid_data->cc_value_index = -1;
+ 
+ 		for (i = 0; i < report->maxfield; i++) {
+ 			struct hid_field *field = report->field[i];
+ 			int j;
+ 
+ 			for (j = 0; j < field->maxusage; j++) {
+ 				if (field->usage[j].hid == HID_DG_CONTACTCOUNT) {
+ 					hid_data->cc_index = i;
+ 					hid_data->cc_value_index = j;
+ 
+ 					/* break */
+ 					i = report->maxfield;
+ 					j = field->maxusage;
+ 				}
+ 			}
+ 		}
+ 	}
+ 	if (hid_data->cc_report != 0 &&
+ 	    hid_data->cc_index >= 0) {
+ 		struct hid_field *field = report->field[hid_data->cc_index];
+ 		int value = field->value[hid_data->cc_value_index];
+ 		if (value)
+ 			hid_data->num_expected = value;
+ 	}
+ 	else {
+ 		hid_data->num_expected = wacom_wac->features.touch_max;
+ 	}
+ }
+ 
+ static void wacom_wac_finger_report(struct hid_device *hdev,
+ 		struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct input_dev *input = wacom_wac->touch_input;
+ 	unsigned touch_max = wacom_wac->features.touch_max;
+ 
+ 	/* If more packets of data are expected, give us a chance to
+ 	 * process them rather than immediately syncing a partial
+ 	 * update.
+ 	 */
+ 	if (wacom_wac->hid_data.num_received < wacom_wac->hid_data.num_expected)
+ 		return;
+ 
+ 	if (touch_max > 1)
+ 		input_mt_sync_frame(input);
+ 
+ 	input_sync(input);
+ 	wacom_wac->hid_data.num_received = 0;
+ 
+ 	/* keep touch state for pen event */
+ 	wacom_wac->shared->touch_down = wacom_wac_finger_count_touches(wacom_wac);
+ }
+ 
+ void wacom_wac_usage_mapping(struct hid_device *hdev,
+ 		struct hid_field *field, struct hid_usage *usage)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	/* currently, only direct devices have proper hid report descriptors */
+ 	features->device_type |= WACOM_DEVICETYPE_DIRECT;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_usage_mapping(hdev, field, usage);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_usage_mapping(hdev, field, usage);
+ }
+ 
+ int wacom_wac_event(struct hid_device *hdev, struct hid_field *field,
+ 		struct hid_usage *usage, __s32 value)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 
+ 	if (wacom->wacom_wac.features.type != HID_GENERIC)
+ 		return 0;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_event(hdev, field, usage, value);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_event(hdev, field, usage, value);
+ 
+ 	return 0;
+ }
+ 
+ static void wacom_report_events(struct hid_device *hdev, struct hid_report *report)
+ {
+ 	int r;
+ 
+ 	for (r = 0; r < report->maxfield; r++) {
+ 		struct hid_field *field;
+ 		unsigned count, n;
+ 
+ 		field = report->field[r];
+ 		count = field->report_count;
+ 
+ 		if (!(HID_MAIN_ITEM_VARIABLE & field->flags))
+ 			continue;
+ 
+ 		for (n = 0; n < count; n++)
+ 			wacom_wac_event(hdev, field, &field->usage[n], field->value[n]);
+ 	}
+ }
+ 
+ void wacom_wac_report(struct hid_device *hdev, struct hid_report *report)
+ {
+ 	struct wacom *wacom = hid_get_drvdata(hdev);
+ 	struct wacom_wac *wacom_wac = &wacom->wacom_wac;
+ 	struct hid_field *field = report->field[0];
+ 
+ 	if (wacom_wac->features.type != HID_GENERIC)
+ 		return;
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		wacom_wac_pen_pre_report(hdev, report);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		wacom_wac_finger_pre_report(hdev, report);
+ 
+ 	wacom_report_events(hdev, report);
+ 
+ 	if (WACOM_PEN_FIELD(field))
+ 		return wacom_wac_pen_report(hdev, report);
+ 
+ 	if (WACOM_FINGER_FIELD(field))
+ 		return wacom_wac_finger_report(hdev, report);
+ }
+ 
++>>>>>>> 1924e05e6014 (HID: wacom - add touch_arbitration parameter to wacom module)
  static int wacom_bpt_touch(struct wacom_wac *wacom)
  {
  	struct wacom_features *features = &wacom->features;
@@@ -1301,6 -2058,90 +2044,93 @@@ static int wacom_bpt_irq(struct wacom_w
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_bamboo_pad_pen_event(struct wacom_wac *wacom,
+ 		unsigned char *data)
+ {
+ 	unsigned char prefix;
+ 
+ 	/*
+ 	 * We need to reroute the event from the debug interface to the
+ 	 * pen interface.
+ 	 * We need to add the report ID to the actual pen report, so we
+ 	 * temporary overwrite the first byte to prevent having to kzalloc/kfree
+ 	 * and memcpy the report.
+ 	 */
+ 	prefix = data[0];
+ 	data[0] = WACOM_REPORT_BPAD_PEN;
+ 
+ 	/*
+ 	 * actually reroute the event.
+ 	 * No need to check if wacom->shared->pen is valid, hid_input_report()
+ 	 * will check for us.
+ 	 */
+ 	hid_input_report(wacom->shared->pen, HID_INPUT_REPORT, data,
+ 			 WACOM_PKGLEN_PENABLED, 1);
+ 
+ 	data[0] = prefix;
+ }
+ 
+ static int wacom_bamboo_pad_touch_event(struct wacom_wac *wacom,
+ 		unsigned char *data)
+ {
+ 	struct input_dev *input = wacom->touch_input;
+ 	unsigned char *finger_data, prefix;
+ 	unsigned id;
+ 	int x, y;
+ 	bool valid;
+ 
+ 	prefix = data[0];
+ 
+ 	for (id = 0; id < wacom->features.touch_max; id++) {
+ 		valid = !!(prefix & BIT(id)) &&
+ 			report_touch_events(wacom);
+ 
+ 		input_mt_slot(input, id);
+ 		input_mt_report_slot_state(input, MT_TOOL_FINGER, valid);
+ 
+ 		if (!valid)
+ 			continue;
+ 
+ 		finger_data = data + 1 + id * 3;
+ 		x = finger_data[0] | ((finger_data[1] & 0x0f) << 8);
+ 		y = (finger_data[2] << 4) | (finger_data[1] >> 4);
+ 
+ 		input_report_abs(input, ABS_MT_POSITION_X, x);
+ 		input_report_abs(input, ABS_MT_POSITION_Y, y);
+ 	}
+ 
+ 	input_mt_sync_frame(input);
+ 
+ 	input_report_key(input, BTN_LEFT, prefix & 0x40);
+ 	input_report_key(input, BTN_RIGHT, prefix & 0x80);
+ 
+ 	/* keep touch state for pen event */
+ 	wacom->shared->touch_down = !!prefix && report_touch_events(wacom);
+ 
+ 	return 1;
+ }
+ 
+ static int wacom_bamboo_pad_irq(struct wacom_wac *wacom, size_t len)
+ {
+ 	unsigned char *data = wacom->data;
+ 
+ 	if (!((len == WACOM_PKGLEN_BPAD_TOUCH) ||
+ 	      (len == WACOM_PKGLEN_BPAD_TOUCH_USB)) ||
+ 	    (data[0] != WACOM_REPORT_BPAD_TOUCH))
+ 		return 0;
+ 
+ 	if (data[1] & 0x01)
+ 		wacom_bamboo_pad_pen_event(wacom, &data[1]);
+ 
+ 	if (data[1] & 0x02)
+ 		return wacom_bamboo_pad_touch_event(wacom, &data[9]);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 1924e05e6014 (HID: wacom - add touch_arbitration parameter to wacom module)
  static int wacom_wireless_irq(struct wacom_wac *wacom, size_t len)
  {
  	unsigned char *data = wacom->data;
* Unmerged path drivers/hid/wacom_wac.c
