macvtap: correctly free skb during socket destruction

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jason Wang <jasowang@redhat.com>
commit 0d7eacbe637952fc737a968bc16db1f2ccbbe71c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0d7eacbe.failed

We should use kfree_skb() instead of kfree() to free an skb.

Fixes: 362899b8725b ("macvtap: switch to use skb array")
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Jason Wang <jasowang@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0d7eacbe637952fc737a968bc16db1f2ccbbe71c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/macvtap.c
diff --cc drivers/net/macvtap.c
index 5f51ecdb243d,a38c0dac514b..000000000000
--- a/drivers/net/macvtap.c
+++ b/drivers/net/macvtap.c
@@@ -514,7 -532,11 +514,15 @@@ static void macvtap_sock_write_space(st
  
  static void macvtap_sock_destruct(struct sock *sk)
  {
++<<<<<<< HEAD
 +	skb_queue_purge(&sk->sk_receive_queue);
++=======
+ 	struct macvtap_queue *q = container_of(sk, struct macvtap_queue, sk);
+ 	struct sk_buff *skb;
+ 
+ 	while ((skb = skb_array_consume(&q->skb_array)) != NULL)
+ 		kfree_skb(skb);
++>>>>>>> 0d7eacbe6379 (macvtap: correctly free skb during socket destruction)
  }
  
  static int macvtap_open(struct inode *inode, struct file *file)
* Unmerged path drivers/net/macvtap.c
