crypto: algif_skcipher - Add nokey compatibility path

jira LE-1907
cve CVE-2015-8970
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] algif_skcipher - Add nokey compatibility path ("Bruno E. O. Meneguele") [1386234] {CVE-2015-8970}
Rebuild_FUZZ: 91.84%
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit a0fa2d037129a9849918a92d91b79ed6c7bd2818
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a0fa2d03.failed

This patch adds a compatibility path to support old applications
that do acept(2) before setkey.

	Cc: stable@vger.kernel.org
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit a0fa2d037129a9849918a92d91b79ed6c7bd2818)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/algif_skcipher.c
diff --cc crypto/algif_skcipher.c
index 83187f497c7c,110bab499e43..000000000000
--- a/crypto/algif_skcipher.c
+++ b/crypto/algif_skcipher.c
@@@ -544,9 -753,117 +544,102 @@@ static struct proto_ops algif_skcipher_
  	.poll		=	skcipher_poll,
  };
  
+ static int skcipher_check_key(struct socket *sock)
+ {
+ 	int err;
+ 	struct sock *psk;
+ 	struct alg_sock *pask;
+ 	struct skcipher_tfm *tfm;
+ 	struct sock *sk = sock->sk;
+ 	struct alg_sock *ask = alg_sk(sk);
+ 
+ 	if (ask->refcnt)
+ 		return 0;
+ 
+ 	psk = ask->parent;
+ 	pask = alg_sk(ask->parent);
+ 	tfm = pask->private;
+ 
+ 	err = -ENOKEY;
+ 	lock_sock(psk);
+ 	if (!tfm->has_key)
+ 		goto unlock;
+ 
+ 	if (!pask->refcnt++)
+ 		sock_hold(psk);
+ 
+ 	ask->refcnt = 1;
+ 	sock_put(psk);
+ 
+ 	err = 0;
+ 
+ unlock:
+ 	release_sock(psk);
+ 
+ 	return err;
+ }
+ 
+ static int skcipher_sendmsg_nokey(struct socket *sock, struct msghdr *msg,
+ 				  size_t size)
+ {
+ 	int err;
+ 
+ 	err = skcipher_check_key(sock);
+ 	if (err)
+ 		return err;
+ 
+ 	return skcipher_sendmsg(sock, msg, size);
+ }
+ 
+ static ssize_t skcipher_sendpage_nokey(struct socket *sock, struct page *page,
+ 				       int offset, size_t size, int flags)
+ {
+ 	int err;
+ 
+ 	err = skcipher_check_key(sock);
+ 	if (err)
+ 		return err;
+ 
+ 	return skcipher_sendpage(sock, page, offset, size, flags);
+ }
+ 
+ static int skcipher_recvmsg_nokey(struct socket *sock, struct msghdr *msg,
+ 				  size_t ignored, int flags)
+ {
+ 	int err;
+ 
+ 	err = skcipher_check_key(sock);
+ 	if (err)
+ 		return err;
+ 
+ 	return skcipher_recvmsg(sock, msg, ignored, flags);
+ }
+ 
+ static struct proto_ops algif_skcipher_ops_nokey = {
+ 	.family		=	PF_ALG,
+ 
+ 	.connect	=	sock_no_connect,
+ 	.socketpair	=	sock_no_socketpair,
+ 	.getname	=	sock_no_getname,
+ 	.ioctl		=	sock_no_ioctl,
+ 	.listen		=	sock_no_listen,
+ 	.shutdown	=	sock_no_shutdown,
+ 	.getsockopt	=	sock_no_getsockopt,
+ 	.mmap		=	sock_no_mmap,
+ 	.bind		=	sock_no_bind,
+ 	.accept		=	sock_no_accept,
+ 	.setsockopt	=	sock_no_setsockopt,
+ 
+ 	.release	=	af_alg_release,
+ 	.sendmsg	=	skcipher_sendmsg_nokey,
+ 	.sendpage	=	skcipher_sendpage_nokey,
+ 	.recvmsg	=	skcipher_recvmsg_nokey,
+ 	.poll		=	skcipher_poll,
+ };
+ 
  static void *skcipher_bind(const char *name, u32 type, u32 mask)
  {
 -	struct skcipher_tfm *tfm;
 -	struct crypto_skcipher *skcipher;
 -
 -	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);
 -	if (!tfm)
 -		return ERR_PTR(-ENOMEM);
 -
 -	skcipher = crypto_alloc_skcipher(name, type, mask);
 -	if (IS_ERR(skcipher)) {
 -		kfree(tfm);
 -		return ERR_CAST(skcipher);
 -	}
 -
 -	tfm->skcipher = skcipher;
 -
 -	return tfm;
 +	return crypto_alloc_ablkcipher(name, type, mask);
  }
  
  static void skcipher_release(void *private)
@@@ -556,18 -876,42 +649,23 @@@
  
  static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
  {
 -	struct skcipher_tfm *tfm = private;
 -	int err;
 -
 -	err = crypto_skcipher_setkey(tfm->skcipher, key, keylen);
 -	tfm->has_key = !err;
 -
 -	return err;
 -}
 -
 -static void skcipher_wait(struct sock *sk)
 -{
 -	struct alg_sock *ask = alg_sk(sk);
 -	struct skcipher_ctx *ctx = ask->private;
 -	int ctr = 0;
 -
 -	while (atomic_read(&ctx->inflight) && ctr++ < 100)
 -		msleep(100);
 +	return crypto_ablkcipher_setkey(private, key, keylen);
  }
  
- static void skcipher_sock_destruct(struct sock *sk)
+ static void skcipher_sock_destruct_common(struct sock *sk)
  {
  	struct alg_sock *ask = alg_sk(sk);
  	struct skcipher_ctx *ctx = ask->private;
 -	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(&ctx->req);
 -
 -	if (atomic_read(&ctx->inflight))
 -		skcipher_wait(sk);
 +	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);
  
  	skcipher_free_sgl(sk);
 -	sock_kzfree_s(sk, ctx->iv, crypto_skcipher_ivsize(tfm));
 +	sock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));
  	sock_kfree_s(sk, ctx, ctx->len);
+ }
+ 
+ static void skcipher_sock_destruct(struct sock *sk)
+ {
+ 	skcipher_sock_destruct_common(sk);
  	af_alg_release_parent(sk);
  }
  
@@@ -575,7 -937,9 +691,13 @@@ static int skcipher_accept_parent_commo
  {
  	struct skcipher_ctx *ctx;
  	struct alg_sock *ask = alg_sk(sk);
++<<<<<<< HEAD
 +	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);
++=======
+ 	struct skcipher_tfm *tfm = private;
+ 	struct crypto_skcipher *skcipher = tfm->skcipher;
+ 	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);
++>>>>>>> a0fa2d037129 (crypto: algif_skcipher - Add nokey compatibility path)
  
  	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
  	if (!ctx)
* Unmerged path crypto/algif_skcipher.c
