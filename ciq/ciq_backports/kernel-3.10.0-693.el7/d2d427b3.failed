bridge: Add netlink support for vlan_protocol attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
commit d2d427b3927bd7a0348fc7f323d0e291f79a2779
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d2d427b3.failed

This enables bridge vlan_protocol to be configured through netlink.

When CONFIG_BRIDGE_VLAN_FILTERING is disabled, kernel behaves the
same way as this feature is not implemented.

	Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d2d427b3927bd7a0348fc7f323d0e291f79a2779)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_link.h
#	net/bridge/br_netlink.c
#	net/bridge/br_private.h
#	net/bridge/br_vlan.c
diff --cc include/uapi/linux/if_link.h
index 1b43f8aab560,2d13dd44ecaa..000000000000
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@@ -232,6 -227,11 +232,14 @@@ enum 
  	IFLA_BR_FORWARD_DELAY,
  	IFLA_BR_HELLO_TIME,
  	IFLA_BR_MAX_AGE,
++<<<<<<< HEAD
++=======
+ 	IFLA_BR_AGEING_TIME,
+ 	IFLA_BR_STP_STATE,
+ 	IFLA_BR_PRIORITY,
+ 	IFLA_BR_VLAN_FILTERING,
+ 	IFLA_BR_VLAN_PROTOCOL,
++>>>>>>> d2d427b3927b (bridge: Add netlink support for vlan_protocol attribute)
  	__IFLA_BR_MAX,
  };
  
diff --cc net/bridge/br_netlink.c
index 389930889e03,af5e187553fd..000000000000
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@@ -644,6 -705,157 +659,160 @@@ static int br_dev_newlink(struct net *s
  	return register_netdevice(dev);
  }
  
++<<<<<<< HEAD
++=======
+ static int br_port_slave_changelink(struct net_device *brdev,
+ 				    struct net_device *dev,
+ 				    struct nlattr *tb[],
+ 				    struct nlattr *data[])
+ {
+ 	struct net_bridge *br = netdev_priv(brdev);
+ 	int ret;
+ 
+ 	if (!data)
+ 		return 0;
+ 
+ 	spin_lock_bh(&br->lock);
+ 	ret = br_setport(br_port_get_rtnl(dev), data);
+ 	spin_unlock_bh(&br->lock);
+ 
+ 	return ret;
+ }
+ 
+ static int br_port_fill_slave_info(struct sk_buff *skb,
+ 				   const struct net_device *brdev,
+ 				   const struct net_device *dev)
+ {
+ 	return br_port_fill_attrs(skb, br_port_get_rtnl(dev));
+ }
+ 
+ static size_t br_port_get_slave_size(const struct net_device *brdev,
+ 				     const struct net_device *dev)
+ {
+ 	return br_port_info_size();
+ }
+ 
+ static const struct nla_policy br_policy[IFLA_BR_MAX + 1] = {
+ 	[IFLA_BR_FORWARD_DELAY]	= { .type = NLA_U32 },
+ 	[IFLA_BR_HELLO_TIME]	= { .type = NLA_U32 },
+ 	[IFLA_BR_MAX_AGE]	= { .type = NLA_U32 },
+ 	[IFLA_BR_AGEING_TIME] = { .type = NLA_U32 },
+ 	[IFLA_BR_STP_STATE] = { .type = NLA_U32 },
+ 	[IFLA_BR_PRIORITY] = { .type = NLA_U16 },
+ 	[IFLA_BR_VLAN_FILTERING] = { .type = NLA_U8 },
+ 	[IFLA_BR_VLAN_PROTOCOL] = { .type = NLA_U16 },
+ };
+ 
+ static int br_changelink(struct net_device *brdev, struct nlattr *tb[],
+ 			 struct nlattr *data[])
+ {
+ 	struct net_bridge *br = netdev_priv(brdev);
+ 	int err;
+ 
+ 	if (!data)
+ 		return 0;
+ 
+ 	if (data[IFLA_BR_FORWARD_DELAY]) {
+ 		err = br_set_forward_delay(br, nla_get_u32(data[IFLA_BR_FORWARD_DELAY]));
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (data[IFLA_BR_HELLO_TIME]) {
+ 		err = br_set_hello_time(br, nla_get_u32(data[IFLA_BR_HELLO_TIME]));
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (data[IFLA_BR_MAX_AGE]) {
+ 		err = br_set_max_age(br, nla_get_u32(data[IFLA_BR_MAX_AGE]));
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	if (data[IFLA_BR_AGEING_TIME]) {
+ 		u32 ageing_time = nla_get_u32(data[IFLA_BR_AGEING_TIME]);
+ 
+ 		br->ageing_time = clock_t_to_jiffies(ageing_time);
+ 	}
+ 
+ 	if (data[IFLA_BR_STP_STATE]) {
+ 		u32 stp_enabled = nla_get_u32(data[IFLA_BR_STP_STATE]);
+ 
+ 		br_stp_set_enabled(br, stp_enabled);
+ 	}
+ 
+ 	if (data[IFLA_BR_PRIORITY]) {
+ 		u32 priority = nla_get_u16(data[IFLA_BR_PRIORITY]);
+ 
+ 		br_stp_set_bridge_priority(br, priority);
+ 	}
+ 
+ 	if (data[IFLA_BR_VLAN_FILTERING]) {
+ 		u8 vlan_filter = nla_get_u8(data[IFLA_BR_VLAN_FILTERING]);
+ 
+ 		err = __br_vlan_filter_toggle(br, vlan_filter);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ #ifdef CONFIG_BRIDGE_VLAN_FILTERING
+ 	if (data[IFLA_BR_VLAN_PROTOCOL]) {
+ 		__be16 vlan_proto = nla_get_be16(data[IFLA_BR_VLAN_PROTOCOL]);
+ 
+ 		err = __br_vlan_set_proto(br, vlan_proto);
+ 		if (err)
+ 			return err;
+ 	}
+ #endif
+ 
+ 	return 0;
+ }
+ 
+ static size_t br_get_size(const struct net_device *brdev)
+ {
+ 	return nla_total_size(sizeof(u32)) +	/* IFLA_BR_FORWARD_DELAY  */
+ 	       nla_total_size(sizeof(u32)) +	/* IFLA_BR_HELLO_TIME */
+ 	       nla_total_size(sizeof(u32)) +	/* IFLA_BR_MAX_AGE */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_AGEING_TIME */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_STP_STATE */
+ 	       nla_total_size(sizeof(u16)) +    /* IFLA_BR_PRIORITY */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_VLAN_FILTERING */
+ #ifdef CONFIG_BRIDGE_VLAN_FILTERING
+ 	       nla_total_size(sizeof(__be16)) +	/* IFLA_BR_VLAN_PROTOCOL */
+ #endif
+ 	       0;
+ }
+ 
+ static int br_fill_info(struct sk_buff *skb, const struct net_device *brdev)
+ {
+ 	struct net_bridge *br = netdev_priv(brdev);
+ 	u32 forward_delay = jiffies_to_clock_t(br->forward_delay);
+ 	u32 hello_time = jiffies_to_clock_t(br->hello_time);
+ 	u32 age_time = jiffies_to_clock_t(br->max_age);
+ 	u32 ageing_time = jiffies_to_clock_t(br->ageing_time);
+ 	u32 stp_enabled = br->stp_enabled;
+ 	u16 priority = (br->bridge_id.prio[0] << 8) | br->bridge_id.prio[1];
+ 	u8 vlan_enabled = br_vlan_enabled(br);
+ 
+ 	if (nla_put_u32(skb, IFLA_BR_FORWARD_DELAY, forward_delay) ||
+ 	    nla_put_u32(skb, IFLA_BR_HELLO_TIME, hello_time) ||
+ 	    nla_put_u32(skb, IFLA_BR_MAX_AGE, age_time) ||
+ 	    nla_put_u32(skb, IFLA_BR_AGEING_TIME, ageing_time) ||
+ 	    nla_put_u32(skb, IFLA_BR_STP_STATE, stp_enabled) ||
+ 	    nla_put_u16(skb, IFLA_BR_PRIORITY, priority) ||
+ 	    nla_put_u8(skb, IFLA_BR_VLAN_FILTERING, vlan_enabled))
+ 		return -EMSGSIZE;
+ 
+ #ifdef CONFIG_BRIDGE_VLAN_FILTERING
+ 	if (nla_put_be16(skb, IFLA_BR_VLAN_PROTOCOL, br->vlan_proto))
+ 		return -EMSGSIZE;
+ #endif
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> d2d427b3927b (bridge: Add netlink support for vlan_protocol attribute)
  static size_t br_get_link_af_size(const struct net_device *dev)
  {
  	struct net_port_vlans *pv;
diff --cc net/bridge/br_private.h
index b75519ca3c51,19e8f79b6b99..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -602,7 -613,11 +602,12 @@@ int br_vlan_add(struct net_bridge *br, 
  int br_vlan_delete(struct net_bridge *br, u16 vid);
  void br_vlan_flush(struct net_bridge *br);
  bool br_vlan_find(struct net_bridge *br, u16 vid);
 -void br_recalculate_fwd_mask(struct net_bridge *br);
 -int __br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
  int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
++<<<<<<< HEAD
++=======
+ int __br_vlan_set_proto(struct net_bridge *br, __be16 proto);
+ int br_vlan_set_proto(struct net_bridge *br, unsigned long val);
++>>>>>>> d2d427b3927b (bridge: Add netlink support for vlan_protocol attribute)
  int br_vlan_init(struct net_bridge *br);
  int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);
  int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
diff --cc net/bridge/br_vlan.c
index 1122c9d717ea,3cd8cc9e804b..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -384,16 -441,69 +384,80 @@@ out
  	return found;
  }
  
 -/* Must be protected by RTNL. */
 -static void recalculate_group_addr(struct net_bridge *br)
 +static void br_set_hw_filters(struct net_bridge *br)
  {
++<<<<<<< HEAD
 +	struct net_bridge_port *p;
 +	struct net_port_vlans *pv;
++=======
+ 	if (br->group_addr_set)
+ 		return;
+ 
+ 	spin_lock_bh(&br->lock);
+ 	if (!br->vlan_enabled || br->vlan_proto == htons(ETH_P_8021Q)) {
+ 		/* Bridge Group Address */
+ 		br->group_addr[5] = 0x00;
+ 	} else { /* vlan_enabled && ETH_P_8021AD */
+ 		/* Provider Bridge Group Address */
+ 		br->group_addr[5] = 0x08;
+ 	}
+ 	spin_unlock_bh(&br->lock);
+ }
+ 
+ /* Must be protected by RTNL. */
+ void br_recalculate_fwd_mask(struct net_bridge *br)
+ {
+ 	if (!br->vlan_enabled || br->vlan_proto == htons(ETH_P_8021Q))
+ 		br->group_fwd_mask_required = BR_GROUPFWD_DEFAULT;
+ 	else /* vlan_enabled && ETH_P_8021AD */
+ 		br->group_fwd_mask_required = BR_GROUPFWD_8021AD &
+ 					      ~(1u << br->group_addr[5]);
+ }
+ 
+ int __br_vlan_filter_toggle(struct net_bridge *br, unsigned long val)
+ {
+ 	if (br->vlan_enabled == val)
+ 		return 0;
+ 
+ 	br->vlan_enabled = val;
+ 	br_manage_promisc(br);
+ 	recalculate_group_addr(br);
+ 	br_recalculate_fwd_mask(br);
+ 
+ 	return 0;
+ }
+ 
+ int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val)
+ {
+ 	if (!rtnl_trylock())
+ 		return restart_syscall();
+ 
+ 	__br_vlan_filter_toggle(br, val);
+ 	rtnl_unlock();
+ 
+ 	return 0;
+ }
+ 
+ int __br_vlan_set_proto(struct net_bridge *br, __be16 proto)
+ {
+ 	int err = 0;
+ 	struct net_bridge_port *p;
+ 	struct net_port_vlans *pv;
+ 	__be16 oldproto;
++>>>>>>> d2d427b3927b (bridge: Add netlink support for vlan_protocol attribute)
  	u16 vid, errvid;
 +	int err;
  
++<<<<<<< HEAD
 +	/* For each port, walk the vlan bitmap and write the vlan
 +	 * info to port driver.
 +	 */
++=======
+ 	if (br->vlan_proto == proto)
+ 		return 0;
+ 
+ 	/* Add VLANs for the new proto to the device filter. */
++>>>>>>> d2d427b3927b (bridge: Add netlink support for vlan_protocol attribute)
  	list_for_each_entry(p, &br->port_list, list) {
  		pv = rtnl_dereference(p->vlan_info);
  		if (!pv)
@@@ -406,12 -516,28 +470,31 @@@
  		}
  	}
  
 -	oldproto = br->vlan_proto;
 -	br->vlan_proto = proto;
 +	return;
  
++<<<<<<< HEAD
 +err_flt:
++=======
+ 	recalculate_group_addr(br);
+ 	br_recalculate_fwd_mask(br);
+ 
+ 	/* Delete VLANs for the old proto from the device filter. */
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		pv = rtnl_dereference(p->vlan_info);
+ 		if (!pv)
+ 			continue;
+ 
+ 		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID)
+ 			vlan_vid_del(p->dev, oldproto, vid);
+ 	}
+ 
+ 	return 0;
+ 
+ err_filt:
++>>>>>>> d2d427b3927b (bridge: Add netlink support for vlan_protocol attribute)
  	errvid = vid;
  	for_each_set_bit(vid, pv->vlan_bitmap, errvid)
 -		vlan_vid_del(p->dev, proto, vid);
 +		vlan_vid_del(p->dev, br->vlan_proto, vid);
  
  	list_for_each_entry_continue_reverse(p, &br->port_list, list) {
  		pv = rtnl_dereference(p->vlan_info);
@@@ -419,52 -545,26 +502,72 @@@
  			continue;
  
  		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID)
 -			vlan_vid_del(p->dev, proto, vid);
 +			vlan_vid_del(p->dev, br->vlan_proto, vid);
 +	}
 +}
 +
++<<<<<<< HEAD
 +static void br_clear_hw_filters(struct net_bridge *br)
 +{
 +	struct net_bridge_port *p;
 +	struct net_port_vlans *pv;
 +	u16 vid;
 +
 +	/* For each port, walk the vlan bitmap and clear
 +	 * the vlan info from the port driver.
 +	 */
 +	list_for_each_entry(p, &br->port_list, list) {
 +		pv = rtnl_dereference(p->vlan_info);
 +		if (!pv)
 +			continue;
 +
 +		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID)
 +			vlan_vid_del(p->dev, br->vlan_proto, vid);
  	}
 +}
 +
 +static void br_manage_vlans(struct net_bridge *br)
 +{
 +	if (br->vlan_enabled)
 +		br_set_hw_filters(br);
 +	else
 +		br_clear_hw_filters(br);
 +}
 +
 +int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val)
 +{
 +	if (!rtnl_trylock())
 +		return restart_syscall();
 +
 +	if (br->vlan_enabled == val)
 +		goto unlock;
  
 +	br->vlan_enabled = val;
 +	br_manage_vlans(br);
 +	br_manage_promisc(br);
 +
 +unlock:
 +	rtnl_unlock();
 +	return 0;
++=======
+ 	return err;
+ }
+ 
+ int br_vlan_set_proto(struct net_bridge *br, unsigned long val)
+ {
+ 	int err;
+ 
+ 	if (val != ETH_P_8021Q && val != ETH_P_8021AD)
+ 		return -EPROTONOSUPPORT;
+ 
+ 	if (!rtnl_trylock())
+ 		return restart_syscall();
+ 
+ 	err = __br_vlan_set_proto(br, htons(val));
+ 	rtnl_unlock();
+ 
+ 	return err;
++>>>>>>> d2d427b3927b (bridge: Add netlink support for vlan_protocol attribute)
  }
  
  static bool vlan_default_pvid(struct net_port_vlans *pv, u16 vid)
* Unmerged path include/uapi/linux/if_link.h
* Unmerged path net/bridge/br_netlink.c
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_vlan.c
