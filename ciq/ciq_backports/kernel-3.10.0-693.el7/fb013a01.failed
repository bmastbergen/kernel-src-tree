HID: wacom: Move Intuos pad handling code into dedicated function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Move Intuos pad handling code into dedicated function (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 96.00%
commit-author Jason Gerecke <killertofu@gmail.com>
commit fb013a01d48d71a68cd14ea30181754f93acae21
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fb013a01.failed

Begin slimming down the body of 'wacom_intuos_irq' by moving out its
largest block of code to a dedicated 'wacom_intuos_pad' function.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit fb013a01d48d71a68cd14ea30181754f93acae21)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index bdf17efa93aa,c611ea5b83c8..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -308,6 -433,262 +308,265 @@@ exit
  	return retval;
  }
  
++<<<<<<< HEAD
++=======
+ static void wacom_intuos_schedule_prox_event(struct wacom_wac *wacom_wac)
+ {
+ 	struct wacom *wacom = container_of(wacom_wac, struct wacom, wacom_wac);
+ 	struct hid_report *r;
+ 	struct hid_report_enum *re;
+ 
+ 	re = &(wacom->hdev->report_enum[HID_FEATURE_REPORT]);
+ 	r = re->report_id_hash[WACOM_REPORT_INTUOSREAD];
+ 	if (r) {
+ 		hid_hw_request(wacom->hdev, r, HID_REQ_GET_REPORT);
+ 	}
+ }
+ 
+ static int wacom_intuos_pad(struct wacom_wac *wacom)
+ {
+ 	struct wacom_features *features = &wacom->features;
+ 	unsigned char *data = wacom->data;
+ 	struct input_dev *input = wacom->pad_input;
+ 
+ 	/* pad packets. Works as a second tool and is always in prox */
+ 	if (!(data[0] == WACOM_REPORT_INTUOSPAD || data[0] == WACOM_REPORT_INTUOS5PAD ||
+ 	      data[0] == WACOM_REPORT_CINTIQPAD))
+ 		return 0;
+ 
+ 	if (features->type >= INTUOS4S && features->type <= INTUOS4L) {
+ 		input_report_key(input, BTN_0, (data[2] & 0x01));
+ 		input_report_key(input, BTN_1, (data[3] & 0x01));
+ 		input_report_key(input, BTN_2, (data[3] & 0x02));
+ 		input_report_key(input, BTN_3, (data[3] & 0x04));
+ 		input_report_key(input, BTN_4, (data[3] & 0x08));
+ 		input_report_key(input, BTN_5, (data[3] & 0x10));
+ 		input_report_key(input, BTN_6, (data[3] & 0x20));
+ 		if (data[1] & 0x80) {
+ 			input_report_abs(input, ABS_WHEEL, (data[1] & 0x7f));
+ 		} else {
+ 			/* Out of proximity, clear wheel value. */
+ 			input_report_abs(input, ABS_WHEEL, 0);
+ 		}
+ 		if (features->type != INTUOS4S) {
+ 			input_report_key(input, BTN_7, (data[3] & 0x40));
+ 			input_report_key(input, BTN_8, (data[3] & 0x80));
+ 		}
+ 		if (data[1] | (data[2] & 0x01) | data[3]) {
+ 			input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 		} else {
+ 			input_report_abs(input, ABS_MISC, 0);
+ 		}
+ 	} else if (features->type == DTK) {
+ 		input_report_key(input, BTN_0, (data[6] & 0x01));
+ 		input_report_key(input, BTN_1, (data[6] & 0x02));
+ 		input_report_key(input, BTN_2, (data[6] & 0x04));
+ 		input_report_key(input, BTN_3, (data[6] & 0x08));
+ 		input_report_key(input, BTN_4, (data[6] & 0x10));
+ 		input_report_key(input, BTN_5, (data[6] & 0x20));
+ 		if (data[6] & 0x3f) {
+ 			input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 		} else {
+ 			input_report_abs(input, ABS_MISC, 0);
+ 		}
+ 	} else if (features->type == WACOM_13HD) {
+ 		input_report_key(input, BTN_0, (data[3] & 0x01));
+ 		input_report_key(input, BTN_1, (data[4] & 0x01));
+ 		input_report_key(input, BTN_2, (data[4] & 0x02));
+ 		input_report_key(input, BTN_3, (data[4] & 0x04));
+ 		input_report_key(input, BTN_4, (data[4] & 0x08));
+ 		input_report_key(input, BTN_5, (data[4] & 0x10));
+ 		input_report_key(input, BTN_6, (data[4] & 0x20));
+ 		input_report_key(input, BTN_7, (data[4] & 0x40));
+ 		input_report_key(input, BTN_8, (data[4] & 0x80));
+ 		if ((data[3] & 0x01) | data[4]) {
+ 			input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 		} else {
+ 			input_report_abs(input, ABS_MISC, 0);
+ 		}
+ 	} else if (features->type == WACOM_24HD) {
+ 		input_report_key(input, BTN_0, (data[6] & 0x01));
+ 		input_report_key(input, BTN_1, (data[6] & 0x02));
+ 		input_report_key(input, BTN_2, (data[6] & 0x04));
+ 		input_report_key(input, BTN_3, (data[6] & 0x08));
+ 		input_report_key(input, BTN_4, (data[6] & 0x10));
+ 		input_report_key(input, BTN_5, (data[6] & 0x20));
+ 		input_report_key(input, BTN_6, (data[6] & 0x40));
+ 		input_report_key(input, BTN_7, (data[6] & 0x80));
+ 		input_report_key(input, BTN_8, (data[8] & 0x01));
+ 		input_report_key(input, BTN_9, (data[8] & 0x02));
+ 		input_report_key(input, BTN_A, (data[8] & 0x04));
+ 		input_report_key(input, BTN_B, (data[8] & 0x08));
+ 		input_report_key(input, BTN_C, (data[8] & 0x10));
+ 		input_report_key(input, BTN_X, (data[8] & 0x20));
+ 		input_report_key(input, BTN_Y, (data[8] & 0x40));
+ 		input_report_key(input, BTN_Z, (data[8] & 0x80));
+ 
+ 		/*
+ 		 * Three "buttons" are available on the 24HD which are
+ 		 * physically implemented as a touchstrip. Each button
+ 		 * is approximately 3 bits wide with a 2 bit spacing.
+ 		 * The raw touchstrip bits are stored at:
+ 		 *    ((data[3] & 0x1f) << 8) | data[4])
+ 		 */
+ 		input_report_key(input, KEY_PROG1, data[4] & 0x07);
+ 		input_report_key(input, KEY_PROG2, data[4] & 0xE0);
+ 		input_report_key(input, KEY_PROG3, data[3] & 0x1C);
+ 
+ 		if (data[1] & 0x80) {
+ 			input_report_abs(input, ABS_WHEEL, (data[1] & 0x7f));
+ 		} else {
+ 			/* Out of proximity, clear wheel value. */
+ 			input_report_abs(input, ABS_WHEEL, 0);
+ 		}
+ 
+ 		if (data[2] & 0x80) {
+ 			input_report_abs(input, ABS_THROTTLE, (data[2] & 0x7f));
+ 		} else {
+ 			/* Out of proximity, clear second wheel value. */
+ 			input_report_abs(input, ABS_THROTTLE, 0);
+ 		}
+ 
+ 		if (data[1] | data[2] | (data[3] & 0x1f) | data[4] | data[6] | data[8]) {
+ 			input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 		} else {
+ 			input_report_abs(input, ABS_MISC, 0);
+ 		}
+ 	} else if (features->type == WACOM_27QHD) {
+ 		input_report_key(input, KEY_PROG1, data[2] & 0x01);
+ 		input_report_key(input, KEY_PROG2, data[2] & 0x02);
+ 		input_report_key(input, KEY_PROG3, data[2] & 0x04);
+ 
+ 		input_report_abs(input, ABS_X, be16_to_cpup((__be16 *)&data[4]));
+ 		input_report_abs(input, ABS_Y, be16_to_cpup((__be16 *)&data[6]));
+ 		input_report_abs(input, ABS_Z, be16_to_cpup((__be16 *)&data[8]));
+ 		if ((data[2] & 0x07) | data[4] | data[5] | data[6] | data[7] | data[8] | data[9]) {
+ 			input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 		} else {
+ 			input_report_abs(input, ABS_MISC, 0);
+ 		}
+ 	} else if (features->type == CINTIQ_HYBRID) {
+ 		/*
+ 		 * Do not send hardware buttons under Android. They
+ 		 * are already sent to the system through GPIO (and
+ 		 * have different meaning).
+ 		 */
+ 		input_report_key(input, BTN_1, (data[4] & 0x01));
+ 		input_report_key(input, BTN_2, (data[4] & 0x02));
+ 		input_report_key(input, BTN_3, (data[4] & 0x04));
+ 		input_report_key(input, BTN_4, (data[4] & 0x08));
+ 
+ 		input_report_key(input, BTN_5, (data[4] & 0x10));  /* Right  */
+ 		input_report_key(input, BTN_6, (data[4] & 0x20));  /* Up     */
+ 		input_report_key(input, BTN_7, (data[4] & 0x40));  /* Left   */
+ 		input_report_key(input, BTN_8, (data[4] & 0x80));  /* Down   */
+ 		input_report_key(input, BTN_0, (data[3] & 0x01));  /* Center */
+ 
+ 		if (data[4] | (data[3] & 0x01)) {
+ 			input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 		} else {
+ 			input_report_abs(input, ABS_MISC, 0);
+ 		}
+ 
+ 	} else if (features->type == CINTIQ_COMPANION_2) {
+ 		input_report_key(input, BTN_1, (data[1] & 0x02));
+ 		input_report_key(input, BTN_2, (data[2] & 0x01));
+ 		input_report_key(input, BTN_3, (data[2] & 0x02));
+ 		input_report_key(input, BTN_4, (data[2] & 0x04));
+ 		input_report_key(input, BTN_5, (data[2] & 0x08));
+ 		input_report_key(input, BTN_6, (data[1] & 0x04));
+ 
+ 		input_report_key(input, BTN_7, (data[2] & 0x10));  /* Right  */
+ 		input_report_key(input, BTN_8, (data[2] & 0x20));  /* Up	 */
+ 		input_report_key(input, BTN_9, (data[2] & 0x40));  /* Left   */
+ 		input_report_key(input, BTN_A, (data[2] & 0x80));  /* Down   */
+ 		input_report_key(input, BTN_0, (data[1] & 0x01));  /* Center */
+ 
+ 		if (data[2] | (data[1] & 0x07)) {
+ 			input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 		} else {
+ 			input_report_abs(input, ABS_MISC, 0);
+ 		}
+ 
+ 	} else if (features->type >= INTUOS5S && features->type <= INTUOSPL) {
+ 		int i;
+ 
+ 		/* Touch ring mode switch has no capacitive sensor */
+ 		input_report_key(input, BTN_0, (data[3] & 0x01));
+ 
+ 		/*
+ 		 * ExpressKeys on Intuos5/Intuos Pro have a capacitive sensor in
+ 		 * addition to the mechanical switch. Switch data is
+ 		 * stored in data[4], capacitive data in data[5].
+ 		 */
+ 		for (i = 0; i < 8; i++)
+ 			input_report_key(input, BTN_1 + i, data[4] & (1 << i));
+ 
+ 		if (data[2] & 0x80) {
+ 			input_report_abs(input, ABS_WHEEL, (data[2] & 0x7f));
+ 		} else {
+ 			/* Out of proximity, clear wheel value. */
+ 			input_report_abs(input, ABS_WHEEL, 0);
+ 		}
+ 
+ 		if (data[2] | (data[3] & 0x01) | data[4] | data[5]) {
+ 			input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 		} else {
+ 			input_report_abs(input, ABS_MISC, 0);
+ 		}
+ 	} else {
+ 		if (features->type == WACOM_21UX2 || features->type == WACOM_22HD) {
+ 			input_report_key(input, BTN_0, (data[5] & 0x01));
+ 			input_report_key(input, BTN_1, (data[6] & 0x01));
+ 			input_report_key(input, BTN_2, (data[6] & 0x02));
+ 			input_report_key(input, BTN_3, (data[6] & 0x04));
+ 			input_report_key(input, BTN_4, (data[6] & 0x08));
+ 			input_report_key(input, BTN_5, (data[6] & 0x10));
+ 			input_report_key(input, BTN_6, (data[6] & 0x20));
+ 			input_report_key(input, BTN_7, (data[6] & 0x40));
+ 			input_report_key(input, BTN_8, (data[6] & 0x80));
+ 			input_report_key(input, BTN_9, (data[7] & 0x01));
+ 			input_report_key(input, BTN_A, (data[8] & 0x01));
+ 			input_report_key(input, BTN_B, (data[8] & 0x02));
+ 			input_report_key(input, BTN_C, (data[8] & 0x04));
+ 			input_report_key(input, BTN_X, (data[8] & 0x08));
+ 			input_report_key(input, BTN_Y, (data[8] & 0x10));
+ 			input_report_key(input, BTN_Z, (data[8] & 0x20));
+ 			input_report_key(input, BTN_BASE, (data[8] & 0x40));
+ 			input_report_key(input, BTN_BASE2, (data[8] & 0x80));
+ 
+ 			if (features->type == WACOM_22HD) {
+ 				input_report_key(input, KEY_PROG1, data[9] & 0x01);
+ 				input_report_key(input, KEY_PROG2, data[9] & 0x02);
+ 				input_report_key(input, KEY_PROG3, data[9] & 0x04);
+ 			}
+ 		} else {
+ 			input_report_key(input, BTN_0, (data[5] & 0x01));
+ 			input_report_key(input, BTN_1, (data[5] & 0x02));
+ 			input_report_key(input, BTN_2, (data[5] & 0x04));
+ 			input_report_key(input, BTN_3, (data[5] & 0x08));
+ 			input_report_key(input, BTN_4, (data[6] & 0x01));
+ 			input_report_key(input, BTN_5, (data[6] & 0x02));
+ 			input_report_key(input, BTN_6, (data[6] & 0x04));
+ 			input_report_key(input, BTN_7, (data[6] & 0x08));
+ 			input_report_key(input, BTN_8, (data[5] & 0x10));
+ 			input_report_key(input, BTN_9, (data[6] & 0x10));
+ 		}
+ 		input_report_abs(input, ABS_RX, ((data[1] & 0x1f) << 8) | data[2]);
+ 		input_report_abs(input, ABS_RY, ((data[3] & 0x1f) << 8) | data[4]);
+ 
+ 		if ((data[5] & 0x1f) | data[6] | (data[1] & 0x1f) |
+ 			data[2] | (data[3] & 0x1f) | data[4] | data[8] |
+ 			(data[7] & 0x01)) {
+ 			input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
+ 		} else {
+ 			input_report_abs(input, ABS_MISC, 0);
+ 		}
+ 	}
+ 	return 1;
+ }
+ 
++>>>>>>> fb013a01d48d (HID: wacom: Move Intuos pad handling code into dedicated function)
  static int wacom_intuos_inout(struct wacom_wac *wacom)
  {
  	struct wacom_features *features = &wacom->features;
@@@ -544,198 -1057,10 +803,205 @@@ static int wacom_intuos_irq(struct waco
  	if (features->type == INTUOS)
  		idx = data[1] & 0x01;
  
++<<<<<<< HEAD
 +	/* pad packets. Works as a second tool and is always in prox */
 +	if (data[0] == WACOM_REPORT_INTUOSPAD || data[0] == WACOM_REPORT_INTUOS5PAD ||
 +	    data[0] == WACOM_REPORT_CINTIQPAD) {
 +		if (features->type >= INTUOS4S && features->type <= INTUOS4L) {
 +			input_report_key(input, BTN_0, (data[2] & 0x01));
 +			input_report_key(input, BTN_1, (data[3] & 0x01));
 +			input_report_key(input, BTN_2, (data[3] & 0x02));
 +			input_report_key(input, BTN_3, (data[3] & 0x04));
 +			input_report_key(input, BTN_4, (data[3] & 0x08));
 +			input_report_key(input, BTN_5, (data[3] & 0x10));
 +			input_report_key(input, BTN_6, (data[3] & 0x20));
 +			if (data[1] & 0x80) {
 +				input_report_abs(input, ABS_WHEEL, (data[1] & 0x7f));
 +			} else {
 +				/* Out of proximity, clear wheel value. */
 +				input_report_abs(input, ABS_WHEEL, 0);
 +			}
 +			if (features->type != INTUOS4S) {
 +				input_report_key(input, BTN_7, (data[3] & 0x40));
 +				input_report_key(input, BTN_8, (data[3] & 0x80));
 +			}
 +			if (data[1] | (data[2] & 0x01) | data[3]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type == DTK) {
 +			input_report_key(input, BTN_0, (data[6] & 0x01));
 +			input_report_key(input, BTN_1, (data[6] & 0x02));
 +			input_report_key(input, BTN_2, (data[6] & 0x04));
 +			input_report_key(input, BTN_3, (data[6] & 0x08));
 +			input_report_key(input, BTN_4, (data[6] & 0x10));
 +			input_report_key(input, BTN_5, (data[6] & 0x20));
 +			if (data[6] & 0x3f) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type == WACOM_13HD) {
 +			input_report_key(input, BTN_0, (data[3] & 0x01));
 +			input_report_key(input, BTN_1, (data[4] & 0x01));
 +			input_report_key(input, BTN_2, (data[4] & 0x02));
 +			input_report_key(input, BTN_3, (data[4] & 0x04));
 +			input_report_key(input, BTN_4, (data[4] & 0x08));
 +			input_report_key(input, BTN_5, (data[4] & 0x10));
 +			input_report_key(input, BTN_6, (data[4] & 0x20));
 +			input_report_key(input, BTN_7, (data[4] & 0x40));
 +			input_report_key(input, BTN_8, (data[4] & 0x80));
 +			if ((data[3] & 0x01) | data[4]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type == WACOM_24HD) {
 +			input_report_key(input, BTN_0, (data[6] & 0x01));
 +			input_report_key(input, BTN_1, (data[6] & 0x02));
 +			input_report_key(input, BTN_2, (data[6] & 0x04));
 +			input_report_key(input, BTN_3, (data[6] & 0x08));
 +			input_report_key(input, BTN_4, (data[6] & 0x10));
 +			input_report_key(input, BTN_5, (data[6] & 0x20));
 +			input_report_key(input, BTN_6, (data[6] & 0x40));
 +			input_report_key(input, BTN_7, (data[6] & 0x80));
 +			input_report_key(input, BTN_8, (data[8] & 0x01));
 +			input_report_key(input, BTN_9, (data[8] & 0x02));
 +			input_report_key(input, BTN_A, (data[8] & 0x04));
 +			input_report_key(input, BTN_B, (data[8] & 0x08));
 +			input_report_key(input, BTN_C, (data[8] & 0x10));
 +			input_report_key(input, BTN_X, (data[8] & 0x20));
 +			input_report_key(input, BTN_Y, (data[8] & 0x40));
 +			input_report_key(input, BTN_Z, (data[8] & 0x80));
 +
 +			/*
 +			 * Three "buttons" are available on the 24HD which are
 +			 * physically implemented as a touchstrip. Each button
 +			 * is approximately 3 bits wide with a 2 bit spacing.
 +			 * The raw touchstrip bits are stored at:
 +			 *    ((data[3] & 0x1f) << 8) | data[4])
 +			 */
 +			input_report_key(input, KEY_PROG1, data[4] & 0x07);
 +			input_report_key(input, KEY_PROG2, data[4] & 0xE0);
 +			input_report_key(input, KEY_PROG3, data[3] & 0x1C);
 +
 +			if (data[1] & 0x80) {
 +				input_report_abs(input, ABS_WHEEL, (data[1] & 0x7f));
 +			} else {
 +				/* Out of proximity, clear wheel value. */
 +				input_report_abs(input, ABS_WHEEL, 0);
 +			}
 +
 +			if (data[2] & 0x80) {
 +				input_report_abs(input, ABS_THROTTLE, (data[2] & 0x7f));
 +			} else {
 +				/* Out of proximity, clear second wheel value. */
 +				input_report_abs(input, ABS_THROTTLE, 0);
 +			}
 +
 +			if (data[1] | data[2] | (data[3] & 0x1f) | data[4] | data[6] | data[8]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type == WACOM_27QHD) {
 +			input_report_key(input, KEY_PROG1, data[2] & 0x01);
 +			input_report_key(input, KEY_PROG2, data[2] & 0x02);
 +			input_report_key(input, KEY_PROG3, data[2] & 0x04);
 +
 +			input_report_abs(input, ABS_X, be16_to_cpup((__be16 *)&data[4]));
 +			input_report_abs(input, ABS_Y, be16_to_cpup((__be16 *)&data[6]));
 +			input_report_abs(input, ABS_Z, be16_to_cpup((__be16 *)&data[8]));
 +			if ((data[2] & 0x07) | data[4] | data[5] | data[6] | data[7] | data[8] | data[9]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else if (features->type >= INTUOS5S && features->type <= INTUOSPL) {
 +			int i;
 +
 +			/* Touch ring mode switch has no capacitive sensor */
 +			input_report_key(input, BTN_0, (data[3] & 0x01));
 +
 +			/*
 +			 * ExpressKeys on Intuos5/Intuos Pro have a capacitive sensor in
 +			 * addition to the mechanical switch. Switch data is
 +			 * stored in data[4], capacitive data in data[5].
 +			 */
 +			for (i = 0; i < 8; i++)
 +				input_report_key(input, BTN_1 + i, data[4] & (1 << i));
 +
 +			if (data[2] & 0x80) {
 +				input_report_abs(input, ABS_WHEEL, (data[2] & 0x7f));
 +			} else {
 +				/* Out of proximity, clear wheel value. */
 +				input_report_abs(input, ABS_WHEEL, 0);
 +			}
 +
 +			if (data[2] | (data[3] & 0x01) | data[4] | data[5]) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		} else {
 +			if (features->type == WACOM_21UX2 || features->type == WACOM_22HD) {
 +				input_report_key(input, BTN_0, (data[5] & 0x01));
 +				input_report_key(input, BTN_1, (data[6] & 0x01));
 +				input_report_key(input, BTN_2, (data[6] & 0x02));
 +				input_report_key(input, BTN_3, (data[6] & 0x04));
 +				input_report_key(input, BTN_4, (data[6] & 0x08));
 +				input_report_key(input, BTN_5, (data[6] & 0x10));
 +				input_report_key(input, BTN_6, (data[6] & 0x20));
 +				input_report_key(input, BTN_7, (data[6] & 0x40));
 +				input_report_key(input, BTN_8, (data[6] & 0x80));
 +				input_report_key(input, BTN_9, (data[7] & 0x01));
 +				input_report_key(input, BTN_A, (data[8] & 0x01));
 +				input_report_key(input, BTN_B, (data[8] & 0x02));
 +				input_report_key(input, BTN_C, (data[8] & 0x04));
 +				input_report_key(input, BTN_X, (data[8] & 0x08));
 +				input_report_key(input, BTN_Y, (data[8] & 0x10));
 +				input_report_key(input, BTN_Z, (data[8] & 0x20));
 +				input_report_key(input, BTN_BASE, (data[8] & 0x40));
 +				input_report_key(input, BTN_BASE2, (data[8] & 0x80));
 +
 +				if (features->type == WACOM_22HD) {
 +					input_report_key(input, KEY_PROG1, data[9] & 0x01);
 +					input_report_key(input, KEY_PROG2, data[9] & 0x02);
 +					input_report_key(input, KEY_PROG3, data[9] & 0x04);
 +				}
 +			} else {
 +				input_report_key(input, BTN_0, (data[5] & 0x01));
 +				input_report_key(input, BTN_1, (data[5] & 0x02));
 +				input_report_key(input, BTN_2, (data[5] & 0x04));
 +				input_report_key(input, BTN_3, (data[5] & 0x08));
 +				input_report_key(input, BTN_4, (data[6] & 0x01));
 +				input_report_key(input, BTN_5, (data[6] & 0x02));
 +				input_report_key(input, BTN_6, (data[6] & 0x04));
 +				input_report_key(input, BTN_7, (data[6] & 0x08));
 +				input_report_key(input, BTN_8, (data[5] & 0x10));
 +				input_report_key(input, BTN_9, (data[6] & 0x10));
 +			}
 +			input_report_abs(input, ABS_RX, ((data[1] & 0x1f) << 8) | data[2]);
 +			input_report_abs(input, ABS_RY, ((data[3] & 0x1f) << 8) | data[4]);
 +
 +			if ((data[5] & 0x1f) | data[6] | (data[1] & 0x1f) |
 +				data[2] | (data[3] & 0x1f) | data[4] | data[8] |
 +				(data[7] & 0x01)) {
 +				input_report_abs(input, ABS_MISC, PAD_DEVICE_ID);
 +			} else {
 +				input_report_abs(input, ABS_MISC, 0);
 +			}
 +		}
 +		input_event(input, EV_MSC, MSC_SERIAL, 0xffffffff);
 +                return 1;
 +	}
++=======
+ 	/* process pad events */
+ 	result = wacom_intuos_pad(wacom);
+ 	if (result)
+ 		return result;
++>>>>>>> fb013a01d48d (HID: wacom: Move Intuos pad handling code into dedicated function)
  
  	/* process in/out prox events */
  	result = wacom_intuos_inout(wacom);
* Unmerged path drivers/hid/wacom_wac.c
