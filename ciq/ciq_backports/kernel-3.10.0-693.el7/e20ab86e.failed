perf evsel: Move some methods from session.[ch] to evsel.[ch]

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [tools] perf evsel: Move some methods from session.[ch] to evsel.[ch] (Jiri Olsa) [1373817]
Rebuild_FUZZ: 95.73%
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit e20ab86e51218f9949f41fb39a6c4f63b662f135
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e20ab86e.failed

Those were converted to be evsel methods long ago, move the
source to where it belongs.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Milian Wolff <milian.wolff@kdab.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Wang Nan <wangnan0@huawei.com>
Link: http://lkml.kernel.org/n/tip-vja8rjmkw3gd5ungaeyb5s2j@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit e20ab86e51218f9949f41fb39a6c4f63b662f135)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-trace.c
#	tools/perf/util/evsel.h
#	tools/perf/util/session.c
#	tools/perf/util/session.h
diff --cc tools/perf/builtin-trace.c
index 6a499ab19e51,b842ddd3ad0c..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -2123,6 -2114,28 +2123,31 @@@ out_put
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int trace__fprintf_callchain(struct trace *trace, struct perf_evsel *evsel,
+ 				    struct perf_sample *sample)
+ {
+ 	struct addr_location al;
+ 	/* TODO: user-configurable print_opts */
+ 	const unsigned int print_opts = EVSEL__PRINT_SYM |
+ 				        EVSEL__PRINT_DSO |
+ 				        EVSEL__PRINT_UNKNOWN_AS_ADDR;
+ 
+ 	if (sample->callchain == NULL)
+ 		return 0;
+ 
+ 	if (machine__resolve(trace->host, &al, sample) < 0) {
+ 		pr_err("Problem processing %s callchain, skipping...\n",
+ 			perf_evsel__name(evsel));
+ 		return 0;
+ 	}
+ 
+ 	return perf_evsel__fprintf_callchain(evsel, sample, &al, 38, print_opts,
+ 					     scripting_max_stack, trace->output);
+ }
+ 
++>>>>>>> e20ab86e5121 (perf evsel: Move some methods from session.[ch] to evsel.[ch])
  static int trace__sys_exit(struct trace *trace, struct perf_evsel *evsel,
  			   union perf_event *event __maybe_unused,
  			   struct perf_sample *sample)
diff --cc tools/perf/util/evsel.h
index 8b108cb05d6f,36edd3c91d5c..000000000000
--- a/tools/perf/util/evsel.h
+++ b/tools/perf/util/evsel.h
@@@ -372,6 -387,25 +372,28 @@@ struct perf_attr_details 
  int perf_evsel__fprintf(struct perf_evsel *evsel,
  			struct perf_attr_details *details, FILE *fp);
  
++<<<<<<< HEAD
++=======
+ #define EVSEL__PRINT_IP			(1<<0)
+ #define EVSEL__PRINT_SYM		(1<<1)
+ #define EVSEL__PRINT_DSO		(1<<2)
+ #define EVSEL__PRINT_SYMOFFSET		(1<<3)
+ #define EVSEL__PRINT_ONELINE		(1<<4)
+ #define EVSEL__PRINT_SRCLINE		(1<<5)
+ #define EVSEL__PRINT_UNKNOWN_AS_ADDR	(1<<6)
+ 
+ int perf_evsel__fprintf_callchain(struct perf_evsel *evsel,
+ 				  struct perf_sample *sample,
+ 				  struct addr_location *al, int left_alignment,
+ 				  unsigned int print_opts,
+ 				  unsigned int stack_depth, FILE *fp);
+ 
+ int perf_evsel__fprintf_sym(struct perf_evsel *evsel, struct perf_sample *sample,
+ 			    struct addr_location *al, int left_alignment,
+ 			    unsigned int print_opts, unsigned int stack_depth,
+ 			    FILE *fp);
+ 
++>>>>>>> e20ab86e5121 (perf evsel: Move some methods from session.[ch] to evsel.[ch])
  bool perf_evsel__fallback(struct perf_evsel *evsel, int err,
  			  char *msg, size_t msgsize);
  int perf_evsel__open_strerror(struct perf_evsel *evsel, struct target *target,
diff --cc tools/perf/util/session.c
index 62b6d4051b99,91d4528d71fa..000000000000
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@@ -1953,112 -1953,6 +1953,115 @@@ struct perf_evsel *perf_session__find_f
  	return NULL;
  }
  
++<<<<<<< HEAD
 +void perf_evsel__print_ip(struct perf_evsel *evsel, struct perf_sample *sample,
 +			  struct addr_location *al, int left_alignment,
 +			  unsigned int print_opts, unsigned int stack_depth,
 +			  FILE *fp)
 +{
 +	struct callchain_cursor_node *node;
 +	int print_ip = print_opts & PRINT_IP_OPT_IP;
 +	int print_sym = print_opts & PRINT_IP_OPT_SYM;
 +	int print_dso = print_opts & PRINT_IP_OPT_DSO;
 +	int print_symoffset = print_opts & PRINT_IP_OPT_SYMOFFSET;
 +	int print_oneline = print_opts & PRINT_IP_OPT_ONELINE;
 +	int print_srcline = print_opts & PRINT_IP_OPT_SRCLINE;
 +	char s = print_oneline ? ' ' : '\t';
 +
 +	if (symbol_conf.use_callchain && sample->callchain) {
 +		struct addr_location node_al;
 +
 +		if (thread__resolve_callchain(al->thread, evsel,
 +					      sample, NULL, NULL,
 +					      stack_depth) != 0) {
 +			if (verbose)
 +				error("Failed to resolve callchain. Skipping\n");
 +			return;
 +		}
 +		callchain_cursor_commit(&callchain_cursor);
 +
 +		if (print_symoffset)
 +			node_al = *al;
 +
 +		while (stack_depth) {
 +			u64 addr = 0;
 +
 +			node = callchain_cursor_current(&callchain_cursor);
 +			if (!node)
 +				break;
 +
 +			if (node->sym && node->sym->ignore)
 +				goto next;
 +
 +			fprintf(fp, "%-*.*s", left_alignment, left_alignment, " ");
 +
 +			if (print_ip)
 +				fprintf(fp, "%c%16" PRIx64, s, node->ip);
 +
 +			if (node->map)
 +				addr = node->map->map_ip(node->map, node->ip);
 +
 +			if (print_sym) {
 +				fprintf(fp, " ");
 +				if (print_symoffset) {
 +					node_al.addr = addr;
 +					node_al.map  = node->map;
 +					symbol__fprintf_symname_offs(node->sym,
 +								     &node_al,
 +								     fp);
 +				} else
 +					symbol__fprintf_symname(node->sym, fp);
 +			}
 +
 +			if (print_dso) {
 +				fprintf(fp, " (");
 +				map__fprintf_dsoname(node->map, fp);
 +				fprintf(fp, ")");
 +			}
 +
 +			if (print_srcline)
 +				map__fprintf_srcline(node->map, addr, "\n  ",
 +						     fp);
 +
 +			if (!print_oneline)
 +				fprintf(fp, "\n");
 +
 +			stack_depth--;
 +next:
 +			callchain_cursor_advance(&callchain_cursor);
 +		}
 +
 +	} else {
 +		if (al->sym && al->sym->ignore)
 +			return;
 +
 +		fprintf(fp, "%-*.*s", left_alignment, left_alignment, " ");
 +
 +		if (print_ip)
 +			fprintf(fp, "%16" PRIx64, sample->ip);
 +
 +		if (print_sym) {
 +			fprintf(fp, " ");
 +			if (print_symoffset)
 +				symbol__fprintf_symname_offs(al->sym, al,
 +							     fp);
 +			else
 +				symbol__fprintf_symname(al->sym, fp);
 +		}
 +
 +		if (print_dso) {
 +			fprintf(fp, " (");
 +			map__fprintf_dsoname(al->map, fp);
 +			fprintf(fp, ")");
 +		}
 +
 +		if (print_srcline)
 +			map__fprintf_srcline(al->map, al->addr, "\n  ", fp);
 +	}
 +}
 +
++=======
++>>>>>>> e20ab86e5121 (perf evsel: Move some methods from session.[ch] to evsel.[ch])
  int perf_session__cpu_bitmap(struct perf_session *session,
  			     const char *cpu_list, unsigned long *cpu_bitmap)
  {
diff --cc tools/perf/util/session.h
index a6bc4ddbae3e,4bd758553450..000000000000
--- a/tools/perf/util/session.h
+++ b/tools/perf/util/session.h
@@@ -36,13 -36,6 +36,16 @@@ struct perf_session 
  	struct perf_tool	*tool;
  };
  
++<<<<<<< HEAD
 +#define PRINT_IP_OPT_IP		(1<<0)
 +#define PRINT_IP_OPT_SYM		(1<<1)
 +#define PRINT_IP_OPT_DSO		(1<<2)
 +#define PRINT_IP_OPT_SYMOFFSET	(1<<3)
 +#define PRINT_IP_OPT_ONELINE	(1<<4)
 +#define PRINT_IP_OPT_SRCLINE	(1<<5)
 +
++=======
++>>>>>>> e20ab86e5121 (perf evsel: Move some methods from session.[ch] to evsel.[ch])
  struct perf_tool;
  
  struct perf_session *perf_session__new(struct perf_data_file *file,
@@@ -104,11 -97,6 +107,14 @@@ size_t perf_session__fprintf_nr_events(
  struct perf_evsel *perf_session__find_first_evtype(struct perf_session *session,
  					    unsigned int type);
  
++<<<<<<< HEAD
 +void perf_evsel__print_ip(struct perf_evsel *evsel, struct perf_sample *sample,
 +			  struct addr_location *al, int left_alignment,
 +			  unsigned int print_opts, unsigned int stack_depth,
 +			  FILE *fp);
 +
++=======
++>>>>>>> e20ab86e5121 (perf evsel: Move some methods from session.[ch] to evsel.[ch])
  int perf_session__cpu_bitmap(struct perf_session *session,
  			     const char *cpu_list, unsigned long *cpu_bitmap);
  
diff --git a/tools/perf/builtin-script.c b/tools/perf/builtin-script.c
index bea425037a92..36912ad42127 100644
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@ -315,19 +315,19 @@ static void set_print_ip_opts(struct perf_event_attr *attr)
 
 	output[type].print_ip_opts = 0;
 	if (PRINT_FIELD(IP))
-		output[type].print_ip_opts |= PRINT_IP_OPT_IP;
+		output[type].print_ip_opts |= EVSEL__PRINT_IP;
 
 	if (PRINT_FIELD(SYM))
-		output[type].print_ip_opts |= PRINT_IP_OPT_SYM;
+		output[type].print_ip_opts |= EVSEL__PRINT_SYM;
 
 	if (PRINT_FIELD(DSO))
-		output[type].print_ip_opts |= PRINT_IP_OPT_DSO;
+		output[type].print_ip_opts |= EVSEL__PRINT_DSO;
 
 	if (PRINT_FIELD(SYMOFFSET))
-		output[type].print_ip_opts |= PRINT_IP_OPT_SYMOFFSET;
+		output[type].print_ip_opts |= EVSEL__PRINT_SYMOFFSET;
 
 	if (PRINT_FIELD(SRCLINE))
-		output[type].print_ip_opts |= PRINT_IP_OPT_SRCLINE;
+		output[type].print_ip_opts |= EVSEL__PRINT_SRCLINE;
 }
 
 /*
@@ -572,9 +572,9 @@ static void print_sample_bts(struct perf_sample *sample,
 			printf("\n");
 		} else {
 			printf(" ");
-			if (print_opts & PRINT_IP_OPT_SRCLINE) {
+			if (print_opts & EVSEL__PRINT_SRCLINE) {
 				print_srcline_last = true;
-				print_opts &= ~PRINT_IP_OPT_SRCLINE;
+				print_opts &= ~EVSEL__PRINT_SRCLINE;
 			}
 		}
 		perf_evsel__print_ip(evsel, sample, al, 0, print_opts,
* Unmerged path tools/perf/builtin-trace.c
diff --git a/tools/perf/util/evsel.c b/tools/perf/util/evsel.c
index e0478f1149c9..d7f19c54eefd 100644
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@ -2281,6 +2281,137 @@ out:
 	return ++printed;
 }
 
+int perf_evsel__fprintf_callchain(struct perf_evsel *evsel, struct perf_sample *sample,
+				  struct addr_location *al, int left_alignment,
+				  unsigned int print_opts, unsigned int stack_depth,
+				  FILE *fp)
+{
+	int printed = 0;
+	struct callchain_cursor_node *node;
+	int print_ip = print_opts & EVSEL__PRINT_IP;
+	int print_sym = print_opts & EVSEL__PRINT_SYM;
+	int print_dso = print_opts & EVSEL__PRINT_DSO;
+	int print_symoffset = print_opts & EVSEL__PRINT_SYMOFFSET;
+	int print_oneline = print_opts & EVSEL__PRINT_ONELINE;
+	int print_srcline = print_opts & EVSEL__PRINT_SRCLINE;
+	int print_unknown_as_addr = print_opts & EVSEL__PRINT_UNKNOWN_AS_ADDR;
+	char s = print_oneline ? ' ' : '\t';
+
+	if (sample->callchain) {
+		struct addr_location node_al;
+
+		if (thread__resolve_callchain(al->thread, evsel,
+					      sample, NULL, NULL,
+					      stack_depth) != 0) {
+			if (verbose)
+				error("Failed to resolve callchain. Skipping\n");
+			return printed;
+		}
+		callchain_cursor_commit(&callchain_cursor);
+
+		if (print_symoffset)
+			node_al = *al;
+
+		while (stack_depth) {
+			u64 addr = 0;
+
+			node = callchain_cursor_current(&callchain_cursor);
+			if (!node)
+				break;
+
+			if (node->sym && node->sym->ignore)
+				goto next;
+
+			printed += fprintf(fp, "%-*.*s", left_alignment, left_alignment, " ");
+
+			if (print_ip)
+				printed += fprintf(fp, "%c%16" PRIx64, s, node->ip);
+
+			if (node->map)
+				addr = node->map->map_ip(node->map, node->ip);
+
+			if (print_sym) {
+				printed += fprintf(fp, " ");
+				node_al.addr = addr;
+				node_al.map  = node->map;
+
+				if (print_symoffset) {
+					printed += __symbol__fprintf_symname_offs(node->sym, &node_al,
+										  print_unknown_as_addr, fp);
+				} else {
+					printed += __symbol__fprintf_symname(node->sym, &node_al,
+									     print_unknown_as_addr, fp);
+				}
+			}
+
+			if (print_dso) {
+				printed += fprintf(fp, " (");
+				printed += map__fprintf_dsoname(node->map, fp);
+				printed += fprintf(fp, ")");
+			}
+
+			if (print_srcline)
+				printed += map__fprintf_srcline(node->map, addr, "\n  ", fp);
+
+			if (!print_oneline)
+				printed += fprintf(fp, "\n");
+
+			stack_depth--;
+next:
+			callchain_cursor_advance(&callchain_cursor);
+		}
+	}
+
+	return printed;
+}
+
+int perf_evsel__fprintf_sym(struct perf_evsel *evsel, struct perf_sample *sample,
+			    struct addr_location *al, int left_alignment,
+			    unsigned int print_opts, unsigned int stack_depth,
+			    FILE *fp)
+{
+	int printed = 0;
+	int print_ip = print_opts & EVSEL__PRINT_IP;
+	int print_sym = print_opts & EVSEL__PRINT_SYM;
+	int print_dso = print_opts & EVSEL__PRINT_DSO;
+	int print_symoffset = print_opts & EVSEL__PRINT_SYMOFFSET;
+	int print_srcline = print_opts & EVSEL__PRINT_SRCLINE;
+	int print_unknown_as_addr = print_opts & EVSEL__PRINT_UNKNOWN_AS_ADDR;
+
+	if (symbol_conf.use_callchain && sample->callchain) {
+		printed += perf_evsel__fprintf_callchain(evsel, sample, al, left_alignment,
+							 print_opts, stack_depth, fp);
+	} else if (!(al->sym && al->sym->ignore)) {
+		printed += fprintf(fp, "%-*.*s", left_alignment, left_alignment, " ");
+
+		if (print_ip)
+			printed += fprintf(fp, "%16" PRIx64, sample->ip);
+
+		if (print_sym) {
+			printed += fprintf(fp, " ");
+			if (print_symoffset) {
+				printed += __symbol__fprintf_symname_offs(al->sym, al,
+									  print_unknown_as_addr, fp);
+			} else {
+				printed += __symbol__fprintf_symname(al->sym, al,
+								     print_unknown_as_addr, fp);
+			}
+		}
+
+		if (print_dso) {
+			printed += fprintf(fp, " (");
+			printed += map__fprintf_dsoname(al->map, fp);
+			printed += fprintf(fp, ")");
+		}
+
+		if (print_srcline)
+			printed += map__fprintf_srcline(al->map, al->addr, "\n  ", fp);
+	}
+
+	return printed;
+}
+
+
 bool perf_evsel__fallback(struct perf_evsel *evsel, int err,
 			  char *msg, size_t msgsize)
 {
* Unmerged path tools/perf/util/evsel.h
* Unmerged path tools/perf/util/session.c
* Unmerged path tools/perf/util/session.h
