cpuidle: menu: Fix menu_select() for CPUIDLE_DRIVER_STATE_START == 0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [cpuidle] menu: Fix menu_select() for CPUIDLE_DRIVER_STATE_START == 0 (Gustavo Duarte) [1409211]
Rebuild_FUZZ: 92.91%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 9c4b2867ed7c8c8784dd417ffd16e705e81eb145
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9c4b2867.failed

Commit a9ceb78bc75c (cpuidle,menu: use interactivity_req to disable
polling) exposed a bug in menu_select() causing it to return -1
on systems with CPUIDLE_DRIVER_STATE_START equal to zero, although
it should have returned 0.  As a result, idle states are not entered
by CPUs on those systems.

Namely, on the systems in question data->last_state_idx is initially
equal to -1 and the above commit modified the condition that would
have caused it to be changed to 0 to be less likely to trigger which
exposed the problem.  However, setting data->last_state_idx initially
to -1 doesn't make sense at all and on the affected systems it should
always be set to CPUIDLE_DRIVER_STATE_START (ie. 0) unconditionally,
so make that happen.

Fixes: a9ceb78bc75c (cpuidle,menu: use interactivity_req to disable polling)
Reported-and-tested-by: Sudeep Holla <sudeep.holla@arm.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 9c4b2867ed7c8c8784dd417ffd16e705e81eb145)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpuidle/governors/menu.c
diff --cc drivers/cpuidle/governors/menu.c
index 67fd901f6fc9,be0bae0b41e9..000000000000
--- a/drivers/cpuidle/governors/menu.c
+++ b/drivers/cpuidle/governors/menu.c
@@@ -269,9 -294,6 +269,12 @@@ static int menu_select(struct cpuidle_d
  		data->needs_update = 0;
  	}
  
++<<<<<<< HEAD
 +	data->last_state_idx = CPUIDLE_DRIVER_STATE_START - 1;
 +	data->exit_us = 0;
 +
++=======
++>>>>>>> 9c4b2867ed7c (cpuidle: menu: Fix menu_select() for CPUIDLE_DRIVER_STATE_START == 0)
  	/* Special case when user has set very strict latency requirement */
  	if (unlikely(latency_req == 0))
  		return 0;
@@@ -300,13 -316,27 +303,36 @@@
  	get_typical_interval(data);
  
  	/*
++<<<<<<< HEAD
 +	 * We want to default to C1 (hlt), not to busy polling
 +	 * unless the timer is happening really really soon.
 +	 */
 +	if (data->expected_us > 5 &&
 +	    !drv->states[CPUIDLE_DRIVER_STATE_START].disabled &&
 +		dev->states_usage[CPUIDLE_DRIVER_STATE_START].disable == 0)
++=======
+ 	 * Performance multiplier defines a minimum predicted idle
+ 	 * duration / latency ratio. Adjust the latency limit if
+ 	 * necessary.
+ 	 */
+ 	interactivity_req = data->predicted_us / performance_multiplier(nr_iowaiters, cpu_load);
+ 	if (latency_req > interactivity_req)
+ 		latency_req = interactivity_req;
+ 
+ 	if (CPUIDLE_DRIVER_STATE_START > 0) {
+ 		data->last_state_idx = CPUIDLE_DRIVER_STATE_START - 1;
+ 		/*
+ 		 * We want to default to C1 (hlt), not to busy polling
+ 		 * unless the timer is happening really really soon.
+ 		 */
+ 		if (interactivity_req > 20 &&
+ 		    !drv->states[CPUIDLE_DRIVER_STATE_START].disabled &&
+ 			dev->states_usage[CPUIDLE_DRIVER_STATE_START].disable == 0)
+ 			data->last_state_idx = CPUIDLE_DRIVER_STATE_START;
+ 	} else {
++>>>>>>> 9c4b2867ed7c (cpuidle: menu: Fix menu_select() for CPUIDLE_DRIVER_STATE_START == 0)
  		data->last_state_idx = CPUIDLE_DRIVER_STATE_START;
+ 	}
  
  	/*
  	 * Find the idle state with the lowest power while satisfying
* Unmerged path drivers/cpuidle/governors/menu.c
