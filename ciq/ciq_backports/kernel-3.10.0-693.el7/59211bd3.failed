net/mlx5: Split the load/unload flow into hardware and software flows

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Split the load/unload flow into hardware and software flows (Don Dutile) [1385214 1385330 1417285]
Rebuild_FUZZ: 97.01%
commit-author Mohamad Haj Yahia <mohamad@mellanox.com>
commit 59211bd3b6329c3e5f4a90ac3d7f87ffa7867073
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/59211bd3.failed

Gather all software context creating/destroying in one function and call
it once in the first load and in the last unload.
load/unload functions will now receive indication if we need to
create/destroy the software contexts.
In internal/pci error do the unload/load flows without releasing the
software objects.
In this way we perserve the sw core state and it help us restoring old
driver state after PCI error/shutdown.

	Signed-off-by: Mohamad Haj Yahia <mohamad@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 59211bd3b6329c3e5f4a90ac3d7f87ffa7867073)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/main.c
index e782d0fde09e,966647f74db5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@@ -1144,6 -1291,7 +1192,10 @@@ static int mlx5_load_one(struct mlx5_co
  		dev_err(&pdev->dev, "Failed to init flow steering\n");
  		goto err_fs;
  	}
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 59211bd3b632 (net/mlx5: Split the load/unload flow into hardware and software flows)
  #ifdef CONFIG_MLX5_CORE_EN
  	err = mlx5_eswitch_init(dev);
  	if (err) {
@@@ -1175,21 -1323,19 +1227,29 @@@ out
  
  	return 0;
  
++<<<<<<< HEAD
 +err_sriov:
 +	if (mlx5_sriov_cleanup(dev))
 +		dev_err(&dev->pdev->dev, "sriov cleanup failed\n");
++=======
+ err_reg_dev:
+ 	mlx5_sriov_cleanup(dev);
++>>>>>>> 59211bd3b632 (net/mlx5: Split the load/unload flow into hardware and software flows)
  
+ err_sriov:
  #ifdef CONFIG_MLX5_CORE_EN
  	mlx5_eswitch_cleanup(dev->priv.eswitch);
  #endif
++<<<<<<< HEAD
 +err_reg_dev:
++=======
++>>>>>>> 59211bd3b632 (net/mlx5: Split the load/unload flow into hardware and software flows)
  	mlx5_cleanup_fs(dev);
+ 
  err_fs:
- 	mlx5_cleanup_mkey_table(dev);
- 	mlx5_cleanup_srq_table(dev);
- 	mlx5_cleanup_qp_table(dev);
- 	mlx5_cleanup_cq_table(dev);
  	mlx5_irq_clear_affinity_hints(dev);
+ 
+ err_affinity_hints:
  	free_comp_eqs(dev);
  
  err_stop_eqs:
@@@ -1246,18 -1386,19 +1307,19 @@@ static int mlx5_unload_one(struct mlx5_
  	if (test_bit(MLX5_INTERFACE_STATE_DOWN, &dev->intf_state)) {
  		dev_warn(&dev->pdev->dev, "%s: interface is down, NOP\n",
  			 __func__);
+ 		if (cleanup)
+ 			mlx5_cleanup_once(dev);
  		goto out;
  	}
 -
 -	if (mlx5_device_registered(dev))
 -		mlx5_detach_device(dev);
 -
 -	mlx5_sriov_cleanup(dev);
 +	mlx5_unregister_device(dev);
  #ifdef CONFIG_MLX5_CORE_EN
  	mlx5_eswitch_cleanup(dev->priv.eswitch);
  #endif
++<<<<<<< HEAD
 +
++=======
++>>>>>>> 59211bd3b632 (net/mlx5: Split the load/unload flow into hardware and software flows)
  	mlx5_cleanup_fs(dev);
- 	mlx5_cleanup_mkey_table(dev);
- 	mlx5_cleanup_srq_table(dev);
- 	mlx5_cleanup_qp_table(dev);
- 	mlx5_cleanup_cq_table(dev);
  	mlx5_irq_clear_affinity_hints(dev);
  	free_comp_eqs(dev);
  	mlx5_stop_eqs(dev);
@@@ -1305,7 -1446,14 +1367,8 @@@ struct mlx5_core_event_handler 
  		      void *data);
  };
  
 -static const struct devlink_ops mlx5_devlink_ops = {
 -#ifdef CONFIG_MLX5_CORE_EN
 -	.eswitch_mode_set = mlx5_devlink_eswitch_mode_set,
 -	.eswitch_mode_get = mlx5_devlink_eswitch_mode_get,
 -#endif
 -};
  
+ #define MLX5_IB_MOD "mlx5_ib"
  static int init_one(struct pci_dev *pdev,
  		    const struct pci_device_id *id)
  {
@@@ -1353,10 -1507,21 +1418,27 @@@
  		dev_err(&pdev->dev, "mlx5_load_one failed with error code %d\n", err);
  		goto clean_health;
  	}
++<<<<<<< HEAD
 +
 +	return 0;
 +
++=======
+ 
+ 	err = request_module_nowait(MLX5_IB_MOD);
+ 	if (err)
+ 		pr_info("failed request module on %s\n", MLX5_IB_MOD);
+ 
+ 	err = devlink_register(devlink, &pdev->dev);
+ 	if (err)
+ 		goto clean_load;
+ 
+ 	return 0;
+ 
+ clean_load:
+ 	mlx5_unload_one(dev, priv, true);
++>>>>>>> 59211bd3b632 (net/mlx5: Split the load/unload flow into hardware and software flows)
  clean_health:
+ 	mlx5_pagealloc_cleanup(dev);
  	mlx5_health_cleanup(dev);
  close_pci:
  	mlx5_pci_close(dev, priv);
@@@ -1370,13 -1535,19 +1452,25 @@@ clean_dev
  static void remove_one(struct pci_dev *pdev)
  {
  	struct mlx5_core_dev *dev  = pci_get_drvdata(pdev);
 -	struct devlink *devlink = priv_to_devlink(dev);
  	struct mlx5_priv *priv = &dev->priv;
  
++<<<<<<< HEAD
 +	if (mlx5_unload_one(dev, priv)) {
++=======
+ 	devlink_unregister(devlink);
+ 	mlx5_unregister_device(dev);
+ 
+ 	if (mlx5_unload_one(dev, priv, true)) {
++>>>>>>> 59211bd3b632 (net/mlx5: Split the load/unload flow into hardware and software flows)
  		dev_err(&dev->pdev->dev, "mlx5_unload_one failed\n");
  		mlx5_health_cleanup(dev);
  		return;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	mlx5_pagealloc_cleanup(dev);
++>>>>>>> 59211bd3b632 (net/mlx5: Split the load/unload flow into hardware and software flows)
  	mlx5_health_cleanup(dev);
  	mlx5_pci_close(dev, priv);
  	pci_set_drvdata(pdev, NULL);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/main.c
