mm/hugetlb: optimize minimum size (min_size) accounting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [mm] hugetlb: optimize minimum size (min_size) accounting (Andrea Arcangeli) [1430172]
Rebuild_FUZZ: 97.20%
commit-author Mike Kravetz <mike.kravetz@oracle.com>
commit 09a95e29cb30a3930db22d340ddd072a82b6b0db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/09a95e29.failed

It was observed that minimum size accounting associated with the
hugetlbfs min_size mount option may not perform optimally and as
expected.  As huge pages/reservations are released from the filesystem
and given back to the global pools, they are reserved for subsequent
filesystem use as long as the subpool reserved count is less than
subpool minimum size.  It does not take into account used pages within
the filesystem.  The filesystem size limits are not exceeded and this is
technically not a bug.  However, better behavior would be to wait for
the number of used pages/reservations associated with the filesystem to
drop below the minimum size before taking reservations to satisfy
minimum size.

An optimization is also made to the hugepage_subpool_get_pages() routine
which is called when pages/reservations are allocated.  This does not
change behavior, but simply avoids the accounting if all reservations
have already been taken (subpool reserved count == 0).

	Signed-off-by: Mike Kravetz <mike.kravetz@oracle.com>
	Acked-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Hillf Danton <hillf.zj@alibaba-inc.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 09a95e29cb30a3930db22d340ddd072a82b6b0db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/hugetlb.c
diff --cc mm/hugetlb.c
index 3015ba754f26,fb37ef810655..000000000000
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@@ -113,36 -117,91 +113,79 @@@ void hugepage_put_subpool(struct hugepa
  	unlock_or_release_subpool(spool);
  }
  
 -/*
 - * Subpool accounting for allocating and reserving pages.
 - * Return -ENOMEM if there are not enough resources to satisfy the
 - * the request.  Otherwise, return the number of pages by which the
 - * global pools must be adjusted (upward).  The returned value may
 - * only be different than the passed value (delta) in the case where
 - * a subpool minimum size must be manitained.
 - */
 -static long hugepage_subpool_get_pages(struct hugepage_subpool *spool,
 +static int hugepage_subpool_get_pages(struct hugepage_subpool *spool,
  				      long delta)
  {
 -	long ret = delta;
 +	int ret = 0;
  
  	if (!spool)
 -		return ret;
 +		return 0;
  
  	spin_lock(&spool->lock);
 -
 -	if (spool->max_hpages != -1) {		/* maximum size accounting */
 -		if ((spool->used_hpages + delta) <= spool->max_hpages)
 -			spool->used_hpages += delta;
 -		else {
 -			ret = -ENOMEM;
 -			goto unlock_ret;
 -		}
 +	if ((spool->used_hpages + delta) <= spool->max_hpages) {
 +		spool->used_hpages += delta;
 +	} else {
 +		ret = -ENOMEM;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	/* minimum size accounting */
+ 	if (spool->min_hpages != -1 && spool->rsv_hpages) {
+ 		if (delta > spool->rsv_hpages) {
+ 			/*
+ 			 * Asking for more reserves than those already taken on
+ 			 * behalf of subpool.  Return difference.
+ 			 */
+ 			ret = delta - spool->rsv_hpages;
+ 			spool->rsv_hpages = 0;
+ 		} else {
+ 			ret = 0;	/* reserves already accounted for */
+ 			spool->rsv_hpages -= delta;
+ 		}
+ 	}
+ 
+ unlock_ret:
++>>>>>>> 09a95e29cb30 (mm/hugetlb: optimize minimum size (min_size) accounting)
  	spin_unlock(&spool->lock);
 +
  	return ret;
  }
  
 -/*
 - * Subpool accounting for freeing and unreserving pages.
 - * Return the number of global page reservations that must be dropped.
 - * The return value may only be different than the passed value (delta)
 - * in the case where a subpool minimum size must be maintained.
 - */
 -static long hugepage_subpool_put_pages(struct hugepage_subpool *spool,
 +static void hugepage_subpool_put_pages(struct hugepage_subpool *spool,
  				       long delta)
  {
 -	long ret = delta;
 -
  	if (!spool)
 -		return delta;
 +		return;
  
  	spin_lock(&spool->lock);
++<<<<<<< HEAD
 +	spool->used_hpages -= delta;
 +	/* If hugetlbfs_put_super couldn't free spool due to
 +	* an outstanding quota reference, free it now. */
++=======
+ 
+ 	if (spool->max_hpages != -1)		/* maximum size accounting */
+ 		spool->used_hpages -= delta;
+ 
+ 	 /* minimum size accounting */
+ 	if (spool->min_hpages != -1 && spool->used_hpages < spool->min_hpages) {
+ 		if (spool->rsv_hpages + delta <= spool->min_hpages)
+ 			ret = 0;
+ 		else
+ 			ret = spool->rsv_hpages + delta - spool->min_hpages;
+ 
+ 		spool->rsv_hpages += delta;
+ 		if (spool->rsv_hpages > spool->min_hpages)
+ 			spool->rsv_hpages = spool->min_hpages;
+ 	}
+ 
+ 	/*
+ 	 * If hugetlbfs_put_super couldn't free spool due to an outstanding
+ 	 * quota reference, free it now.
+ 	 */
++>>>>>>> 09a95e29cb30 (mm/hugetlb: optimize minimum size (min_size) accounting)
  	unlock_or_release_subpool(spool);
 -
 -	return ret;
  }
  
  static inline struct hugepage_subpool *subpool_inode(struct inode *inode)
* Unmerged path mm/hugetlb.c
