hv_netvsc: use consume_skb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Stephen Hemminger <sthemmin@microsoft.com>
commit 17db4bcef3c3c45b95b3b3d8577f725df1b2c0a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/17db4bce.failed

Packets that are transmitted in normal path should use consume_skb
instead of kfree_skb. This allows for better tracing of packet drops.

	Signed-off-by: Stephen Hemminger <sthemmin@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 17db4bcef3c3c45b95b3b3d8577f725df1b2c0a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc.c
diff --cc drivers/net/hyperv/netvsc.c
index 6ae624b33365,720b5fa9e625..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -618,6 -611,47 +618,50 @@@ static inline void netvsc_free_send_slo
  	sync_change_bit(index, net_device->send_section_map);
  }
  
++<<<<<<< HEAD
++=======
+ static void netvsc_send_tx_complete(struct netvsc_device *net_device,
+ 				    struct vmbus_channel *incoming_channel,
+ 				    struct hv_device *device,
+ 				    struct vmpacket_descriptor *packet)
+ {
+ 	struct sk_buff *skb = (struct sk_buff *)(unsigned long)packet->trans_id;
+ 	struct net_device *ndev = hv_get_drvdata(device);
+ 	struct net_device_context *net_device_ctx = netdev_priv(ndev);
+ 	struct vmbus_channel *channel = device->channel;
+ 	int num_outstanding_sends;
+ 	u16 q_idx = 0;
+ 	int queue_sends;
+ 
+ 	/* Notify the layer above us */
+ 	if (likely(skb)) {
+ 		struct hv_netvsc_packet *nvsc_packet
+ 			= (struct hv_netvsc_packet *)skb->cb;
+ 		u32 send_index = nvsc_packet->send_buf_index;
+ 
+ 		if (send_index != NETVSC_INVALID_INDEX)
+ 			netvsc_free_send_slot(net_device, send_index);
+ 		q_idx = nvsc_packet->q_idx;
+ 		channel = incoming_channel;
+ 
+ 		dev_consume_skb_any(skb);
+ 	}
+ 
+ 	num_outstanding_sends =
+ 		atomic_dec_return(&net_device->num_outstanding_sends);
+ 	queue_sends = atomic_dec_return(&net_device->queue_sends[q_idx]);
+ 
+ 	if (net_device->destroy && num_outstanding_sends == 0)
+ 		wake_up(&net_device->wait_drain);
+ 
+ 	if (netif_tx_queue_stopped(netdev_get_tx_queue(ndev, q_idx)) &&
+ 	    !net_device_ctx->start_remove &&
+ 	    (hv_ringbuf_avail_percent(&channel->outbound) > RING_AVAIL_PERCENT_HIWATER ||
+ 	     queue_sends < 1))
+ 		netif_tx_wake_queue(netdev_get_tx_queue(ndev, q_idx));
+ }
+ 
++>>>>>>> 17db4bcef3c3 (hv_netvsc: use consume_skb)
  static void netvsc_send_completion(struct netvsc_device *net_device,
  				   struct vmbus_channel *incoming_channel,
  				   struct hv_device *device,
* Unmerged path drivers/net/hyperv/netvsc.c
