drm/nouveau/kms/nv50: skip core channel cursor update on position-only changes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [drm] nouveau/kms/nv50: skip core channel cursor update on position-only chang (Ben Skeggs) [1451524]
Rebuild_FUZZ: 96.00%
commit-author Ben Skeggs <bskeggs@redhat.com>
commit e6db95799b1b870aae15682a6d0898df9e9dfb38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/e6db9579.failed

The DRM core used to only call prepare_fb/cleanup_fb() when a plane's
framebuffer changed, which achieved the desired effect.

It's apparently now up to the driver to decide on its own.

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
	Cc: stable@vger.kernel.org [4.11+]
(cherry picked from commit e6db95799b1b870aae15682a6d0898df9e9dfb38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/nv50_display.c
diff --cc drivers/gpu/drm/nouveau/nv50_display.c
index a43445caae60,fcec2aba9ad7..000000000000
--- a/drivers/gpu/drm/nouveau/nv50_display.c
+++ b/drivers/gpu/drm/nouveau/nv50_display.c
@@@ -461,236 -723,520 +461,331 @@@ evo_kick(u32 *push, void *evoc
  	mutex_unlock(&dmac->lock);
  }
  
 -#define evo_mthd(p, m, s) do {						\
 -	const u32 _m = (m), _s = (s);					\
 -	if (drm_debug & DRM_UT_KMS)					\
 -		pr_err("%04x %d %s\n", _m, _s, __func__);		\
 -	*((p)++) = ((_s << 18) | _m);					\
 +#if 1
 +#define evo_mthd(p,m,s) *((p)++) = (((s) << 18) | (m))
 +#define evo_data(p,d)   *((p)++) = (d)
 +#else
 +#define evo_mthd(p,m,s) do {                                                   \
 +	const u32 _m = (m), _s = (s);                                          \
 +	printk(KERN_ERR "%04x %d %s\n", _m, _s, __func__);                     \
 +	*((p)++) = ((_s << 18) | _m);                                          \
  } while(0)
 -
 -#define evo_data(p, d) do {						\
 -	const u32 _d = (d);						\
 -	if (drm_debug & DRM_UT_KMS)					\
 -		pr_err("\t%08x\n", _d);					\
 -	*((p)++) = _d;							\
 +#define evo_data(p,d) do {                                                     \
 +	const u32 _d = (d);                                                    \
 +	printk(KERN_ERR "\t%08x\n", _d);                                       \
 +	*((p)++) = _d;                                                         \
  } while(0)
 +#endif
  
 -/******************************************************************************
 - * Plane
 - *****************************************************************************/
 -#define nv50_wndw(p) container_of((p), struct nv50_wndw, plane)
 -
 -struct nv50_wndw {
 -	const struct nv50_wndw_func *func;
 -	struct nv50_dmac *dmac;
 -
 -	struct drm_plane plane;
 -
 -	struct nvif_notify notify;
 -	u16 ntfy;
 -	u16 sema;
 -	u32 data;
 -};
 -
 -struct nv50_wndw_func {
 -	void *(*dtor)(struct nv50_wndw *);
 -	int (*acquire)(struct nv50_wndw *, struct nv50_wndw_atom *asyw,
 -		       struct nv50_head_atom *asyh);
 -	void (*release)(struct nv50_wndw *, struct nv50_wndw_atom *asyw,
 -			struct nv50_head_atom *asyh);
 -	void (*prepare)(struct nv50_wndw *, struct nv50_head_atom *asyh,
 -			struct nv50_wndw_atom *asyw);
 -
 -	void (*sema_set)(struct nv50_wndw *, struct nv50_wndw_atom *);
 -	void (*sema_clr)(struct nv50_wndw *);
 -	void (*ntfy_set)(struct nv50_wndw *, struct nv50_wndw_atom *);
 -	void (*ntfy_clr)(struct nv50_wndw *);
 -	int (*ntfy_wait_begun)(struct nv50_wndw *, struct nv50_wndw_atom *);
 -	void (*image_set)(struct nv50_wndw *, struct nv50_wndw_atom *);
 -	void (*image_clr)(struct nv50_wndw *);
 -	void (*lut)(struct nv50_wndw *, struct nv50_wndw_atom *);
 -	void (*point)(struct nv50_wndw *, struct nv50_wndw_atom *);
 -
 -	u32 (*update)(struct nv50_wndw *, u32 interlock);
 -};
 -
 -static int
 -nv50_wndw_wait_armed(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)
 -{
 -	if (asyw->set.ntfy)
 -		return wndw->func->ntfy_wait_begun(wndw, asyw);
 -	return 0;
 -}
 -
 -static u32
 -nv50_wndw_flush_clr(struct nv50_wndw *wndw, u32 interlock, bool flush,
 -		    struct nv50_wndw_atom *asyw)
 +static bool
 +evo_sync_wait(void *data)
  {
 -	if (asyw->clr.sema && (!asyw->set.sema || flush))
 -		wndw->func->sema_clr(wndw);
 -	if (asyw->clr.ntfy && (!asyw->set.ntfy || flush))
 -		wndw->func->ntfy_clr(wndw);
 -	if (asyw->clr.image && (!asyw->set.image || flush))
 -		wndw->func->image_clr(wndw);
 -
 -	return flush ? wndw->func->update(wndw, interlock) : 0;
 +	if (nouveau_bo_rd32(data, EVO_MAST_NTFY) != 0x00000000)
 +		return true;
 +	usleep_range(1, 2);
 +	return false;
  }
  
 -static u32
 -nv50_wndw_flush_set(struct nv50_wndw *wndw, u32 interlock,
 -		    struct nv50_wndw_atom *asyw)
 +static int
 +evo_sync(struct drm_device *dev)
  {
 -	if (interlock) {
 -		asyw->image.mode = 0;
 -		asyw->image.interval = 1;
 +	struct nvif_device *device = &nouveau_drm(dev)->device;
 +	struct nv50_disp *disp = nv50_disp(dev);
 +	struct nv50_mast *mast = nv50_mast(dev);
 +	u32 *push = evo_wait(mast, 8);
 +	if (push) {
 +		nouveau_bo_wr32(disp->sync, EVO_MAST_NTFY, 0x00000000);
 +		evo_mthd(push, 0x0084, 1);
 +		evo_data(push, 0x80000000 | EVO_MAST_NTFY);
 +		evo_mthd(push, 0x0080, 2);
 +		evo_data(push, 0x00000000);
 +		evo_data(push, 0x00000000);
 +		evo_kick(push, mast);
 +		if (nvif_msec(device, 2000,
 +			if (evo_sync_wait(disp->sync))
 +				break;
 +		) >= 0)
 +			return 0;
  	}
  
 -	if (asyw->set.sema ) wndw->func->sema_set (wndw, asyw);
 -	if (asyw->set.ntfy ) wndw->func->ntfy_set (wndw, asyw);
 -	if (asyw->set.image) wndw->func->image_set(wndw, asyw);
 -	if (asyw->set.lut  ) wndw->func->lut      (wndw, asyw);
 -	if (asyw->set.point) wndw->func->point    (wndw, asyw);
 -
 -	return wndw->func->update(wndw, interlock);
 +	return -EBUSY;
  }
  
 -static void
 -nv50_wndw_atomic_check_release(struct nv50_wndw *wndw,
 -			       struct nv50_wndw_atom *asyw,
 -			       struct nv50_head_atom *asyh)
 +/******************************************************************************
 + * Page flipping channel
 + *****************************************************************************/
 +struct nouveau_bo *
 +nv50_display_crtc_sema(struct drm_device *dev, int crtc)
  {
 -	struct nouveau_drm *drm = nouveau_drm(wndw->plane.dev);
 -	NV_ATOMIC(drm, "%s release\n", wndw->plane.name);
 -	wndw->func->release(wndw, asyw, asyh);
 -	asyw->ntfy.handle = 0;
 -	asyw->sema.handle = 0;
 +	return nv50_disp(dev)->sync;
  }
  
 -static int
 -nv50_wndw_atomic_check_acquire(struct nv50_wndw *wndw,
 -			       struct nv50_wndw_atom *asyw,
 -			       struct nv50_head_atom *asyh)
 -{
 -	struct nouveau_framebuffer *fb = nouveau_framebuffer(asyw->state.fb);
 -	struct nouveau_drm *drm = nouveau_drm(wndw->plane.dev);
 -	int ret;
 -
 -	NV_ATOMIC(drm, "%s acquire\n", wndw->plane.name);
 -	asyw->clip.x1 = 0;
 -	asyw->clip.y1 = 0;
 -	asyw->clip.x2 = asyh->state.mode.hdisplay;
 -	asyw->clip.y2 = asyh->state.mode.vdisplay;
 -
 -	asyw->image.w = fb->base.width;
 -	asyw->image.h = fb->base.height;
 -	asyw->image.kind = (fb->nvbo->tile_flags & 0x0000ff00) >> 8;
 -
 -	if (asyh->state.pageflip_flags & DRM_MODE_PAGE_FLIP_ASYNC)
 -		asyw->interval = 0;
 -	else
 -		asyw->interval = 1;
 -
 -	if (asyw->image.kind) {
 -		asyw->image.layout = 0;
 -		if (drm->client.device.info.chipset >= 0xc0)
 -			asyw->image.block = fb->nvbo->tile_mode >> 4;
 -		else
 -			asyw->image.block = fb->nvbo->tile_mode;
 -		asyw->image.pitch = (fb->base.pitches[0] / 4) << 4;
 -	} else {
 -		asyw->image.layout = 1;
 -		asyw->image.block  = 0;
 -		asyw->image.pitch  = fb->base.pitches[0];
 -	}
 -
 -	ret = wndw->func->acquire(wndw, asyw, asyh);
 -	if (ret)
 -		return ret;
 +struct nv50_display_flip {
 +	struct nv50_disp *disp;
 +	struct nv50_sync *chan;
 +};
  
 -	if (asyw->set.image) {
 -		if (!(asyw->image.mode = asyw->interval ? 0 : 1))
 -			asyw->image.interval = asyw->interval;
 -		else
 -			asyw->image.interval = 0;
 -	}
 +static bool
 +nv50_display_flip_wait(void *data)
 +{
 +	struct nv50_display_flip *flip = data;
 +	if (nouveau_bo_rd32(flip->disp->sync, flip->chan->addr / 4) ==
 +					      flip->chan->data)
 +		return true;
 +	usleep_range(1, 2);
 +	return false;
 +}
  
 -	return 0;
 +void
 +nv50_display_flip_stop(struct drm_crtc *crtc)
 +{
++<<<<<<< HEAD
 +	struct nvif_device *device = &nouveau_drm(crtc->dev)->device;
 +	struct nv50_display_flip flip = {
 +		.disp = nv50_disp(crtc->dev),
 +		.chan = nv50_sync(crtc),
++=======
++	struct nv50_curs *curs = nv50_curs(wndw);
++	nvif_wr32(&curs->chan, 0x0084, (asyw->point.y << 16) | asyw->point.x);
+ }
+ 
 -static int
 -nv50_wndw_atomic_check(struct drm_plane *plane, struct drm_plane_state *state)
++static void
++nv50_curs_prepare(struct nv50_wndw *wndw, struct nv50_head_atom *asyh,
++		  struct nv50_wndw_atom *asyw)
+ {
 -	struct nouveau_drm *drm = nouveau_drm(plane->dev);
 -	struct nv50_wndw *wndw = nv50_wndw(plane);
 -	struct nv50_wndw_atom *armw = nv50_wndw_atom(wndw->plane.state);
 -	struct nv50_wndw_atom *asyw = nv50_wndw_atom(state);
 -	struct nv50_head_atom *harm = NULL, *asyh = NULL;
 -	bool varm = false, asyv = false, asym = false;
 -	int ret;
 -
 -	NV_ATOMIC(drm, "%s atomic_check\n", plane->name);
 -	if (asyw->state.crtc) {
 -		asyh = nv50_head_atom_get(asyw->state.state, asyw->state.crtc);
 -		if (IS_ERR(asyh))
 -			return PTR_ERR(asyh);
 -		asym = drm_atomic_crtc_needs_modeset(&asyh->state);
 -		asyv = asyh->state.active;
 -	}
 -
 -	if (armw->state.crtc) {
 -		harm = nv50_head_atom_get(asyw->state.state, armw->state.crtc);
 -		if (IS_ERR(harm))
 -			return PTR_ERR(harm);
 -		varm = harm->state.crtc->state->active;
 -	}
 -
 -	if (asyv) {
 -		asyw->point.x = asyw->state.crtc_x;
 -		asyw->point.y = asyw->state.crtc_y;
 -		if (memcmp(&armw->point, &asyw->point, sizeof(asyw->point)))
 -			asyw->set.point = true;
 -
 -		ret = nv50_wndw_atomic_check_acquire(wndw, asyw, asyh);
 -		if (ret)
 -			return ret;
 -	} else
 -	if (varm) {
 -		nv50_wndw_atomic_check_release(wndw, asyw, harm);
 -	} else {
 -		return 0;
 -	}
 -
 -	if (!asyv || asym) {
 -		asyw->clr.ntfy = armw->ntfy.handle != 0;
 -		asyw->clr.sema = armw->sema.handle != 0;
 -		if (wndw->func->image_clr)
 -			asyw->clr.image = armw->image.handle != 0;
 -		asyw->set.lut = wndw->func->lut && asyv;
++	u32 handle = nv50_disp(wndw->plane.dev)->mast.base.vram.handle;
++	u32 offset = asyw->image.offset;
++	if (asyh->curs.handle != handle || asyh->curs.offset != offset) {
++		asyh->curs.handle = handle;
++		asyh->curs.offset = offset;
++		asyh->set.curs = asyh->curs.visible;
+ 	}
 -
 -	return 0;
+ }
+ 
+ static void
 -nv50_wndw_cleanup_fb(struct drm_plane *plane, struct drm_plane_state *old_state)
++nv50_curs_release(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,
++		  struct nv50_head_atom *asyh)
+ {
 -	struct nouveau_framebuffer *fb = nouveau_framebuffer(old_state->fb);
 -	struct nouveau_drm *drm = nouveau_drm(plane->dev);
 -
 -	NV_ATOMIC(drm, "%s cleanup: %p\n", plane->name, old_state->fb);
 -	if (!old_state->fb)
 -		return;
 -
 -	nouveau_bo_unpin(fb->nvbo);
++	asyh->curs.visible = false;
+ }
+ 
+ static int
 -nv50_wndw_prepare_fb(struct drm_plane *plane, struct drm_plane_state *state)
++nv50_curs_acquire(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,
++		  struct nv50_head_atom *asyh)
+ {
 -	struct nouveau_framebuffer *fb = nouveau_framebuffer(state->fb);
 -	struct nouveau_drm *drm = nouveau_drm(plane->dev);
 -	struct nv50_wndw *wndw = nv50_wndw(plane);
 -	struct nv50_wndw_atom *asyw = nv50_wndw_atom(state);
 -	struct nv50_head_atom *asyh;
 -	struct nv50_dmac_ctxdma *ctxdma;
+ 	int ret;
+ 
 -	NV_ATOMIC(drm, "%s prepare: %p\n", plane->name, state->fb);
 -	if (!asyw->state.fb)
 -		return 0;
 -
 -	ret = nouveau_bo_pin(fb->nvbo, TTM_PL_FLAG_VRAM, true);
 -	if (ret)
++	ret = drm_plane_helper_check_state(&asyw->state, &asyw->clip,
++					   DRM_PLANE_HELPER_NO_SCALING,
++					   DRM_PLANE_HELPER_NO_SCALING,
++					   true, true);
++	asyh->curs.visible = asyw->state.visible;
++	if (ret || !asyh->curs.visible)
+ 		return ret;
+ 
 -	ctxdma = nv50_dmac_ctxdma_new(wndw->dmac, fb);
 -	if (IS_ERR(ctxdma)) {
 -		nouveau_bo_unpin(fb->nvbo);
 -		return PTR_ERR(ctxdma);
++	switch (asyw->state.fb->width) {
++	case 32: asyh->curs.layout = 0; break;
++	case 64: asyh->curs.layout = 1; break;
++	default:
++		return -EINVAL;
+ 	}
+ 
 -	asyw->state.fence = reservation_object_get_excl_rcu(fb->nvbo->bo.resv);
 -	asyw->image.handle = ctxdma->object.handle;
 -	asyw->image.offset = fb->nvbo->bo.offset;
 -
 -	if (wndw->func->prepare) {
 -		asyh = nv50_head_atom_get(asyw->state.state, asyw->state.crtc);
 -		if (IS_ERR(asyh))
 -			return PTR_ERR(asyh);
++	if (asyw->state.fb->width != asyw->state.fb->height)
++		return -EINVAL;
+ 
 -		wndw->func->prepare(wndw, asyh, asyw);
++	switch (asyw->state.fb->format->format) {
++	case DRM_FORMAT_ARGB8888: asyh->curs.format = 1; break;
++	default:
++		WARN_ON(1);
++		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
 -static const struct drm_plane_helper_funcs
 -nv50_wndw_helper = {
 -	.prepare_fb = nv50_wndw_prepare_fb,
 -	.cleanup_fb = nv50_wndw_cleanup_fb,
 -	.atomic_check = nv50_wndw_atomic_check,
 -};
 -
 -static void
 -nv50_wndw_atomic_destroy_state(struct drm_plane *plane,
 -			       struct drm_plane_state *state)
 -{
 -	struct nv50_wndw_atom *asyw = nv50_wndw_atom(state);
 -	__drm_atomic_helper_plane_destroy_state(&asyw->state);
 -	kfree(asyw);
 -}
 -
 -static struct drm_plane_state *
 -nv50_wndw_atomic_duplicate_state(struct drm_plane *plane)
 -{
 -	struct nv50_wndw_atom *armw = nv50_wndw_atom(plane->state);
 -	struct nv50_wndw_atom *asyw;
 -	if (!(asyw = kmalloc(sizeof(*asyw), GFP_KERNEL)))
 -		return NULL;
 -	__drm_atomic_helper_plane_duplicate_state(plane, &asyw->state);
 -	asyw->interval = 1;
 -	asyw->sema = armw->sema;
 -	asyw->ntfy = armw->ntfy;
 -	asyw->image = armw->image;
 -	asyw->point = armw->point;
 -	asyw->lut = armw->lut;
 -	asyw->clr.mask = 0;
 -	asyw->set.mask = 0;
 -	return &asyw->state;
 -}
 -
 -static void
 -nv50_wndw_reset(struct drm_plane *plane)
 -{
 -	struct nv50_wndw_atom *asyw;
 -
 -	if (WARN_ON(!(asyw = kzalloc(sizeof(*asyw), GFP_KERNEL))))
 -		return;
 -
 -	if (plane->state)
 -		plane->funcs->atomic_destroy_state(plane, plane->state);
 -	plane->state = &asyw->state;
 -	plane->state->plane = plane;
 -	plane->state->rotation = DRM_ROTATE_0;
 -}
 -
 -static void
 -nv50_wndw_destroy(struct drm_plane *plane)
 -{
 -	struct nv50_wndw *wndw = nv50_wndw(plane);
 -	void *data;
 -	nvif_notify_fini(&wndw->notify);
 -	data = wndw->func->dtor(wndw);
 -	drm_plane_cleanup(&wndw->plane);
 -	kfree(data);
 -}
 -
 -static const struct drm_plane_funcs
 -nv50_wndw = {
 -	.update_plane = drm_atomic_helper_update_plane,
 -	.disable_plane = drm_atomic_helper_disable_plane,
 -	.destroy = nv50_wndw_destroy,
 -	.reset = nv50_wndw_reset,
 -	.set_property = drm_atomic_helper_plane_set_property,
 -	.atomic_duplicate_state = nv50_wndw_atomic_duplicate_state,
 -	.atomic_destroy_state = nv50_wndw_atomic_destroy_state,
 -};
 -
 -static void
 -nv50_wndw_fini(struct nv50_wndw *wndw)
 -{
 -	nvif_notify_put(&wndw->notify);
 -}
 -
 -static void
 -nv50_wndw_init(struct nv50_wndw *wndw)
 -{
 -	nvif_notify_get(&wndw->notify);
 -}
 -
 -static int
 -nv50_wndw_ctor(const struct nv50_wndw_func *func, struct drm_device *dev,
 -	       enum drm_plane_type type, const char *name, int index,
 -	       struct nv50_dmac *dmac, const u32 *format, int nformat,
 -	       struct nv50_wndw *wndw)
 -{
 -	int ret;
 -
 -	wndw->func = func;
 -	wndw->dmac = dmac;
 -
 -	ret = drm_universal_plane_init(dev, &wndw->plane, 0, &nv50_wndw, format,
 -				       nformat, type, "%s-%d", name, index);
 -	if (ret)
 -		return ret;
 -
 -	drm_plane_helper_add(&wndw->plane, &nv50_wndw_helper);
 -	return 0;
 -}
 -
 -/******************************************************************************
 - * Cursor plane
 - *****************************************************************************/
 -#define nv50_curs(p) container_of((p), struct nv50_curs, wndw)
 -
 -struct nv50_curs {
 -	struct nv50_wndw wndw;
 -	struct nvif_object chan;
 -};
 -
 -static u32
 -nv50_curs_update(struct nv50_wndw *wndw, u32 interlock)
 -{
 -	struct nv50_curs *curs = nv50_curs(wndw);
 -	nvif_wr32(&curs->chan, 0x0080, 0x00000000);
 -	return 0;
 -}
 -
 -static void
 -nv50_curs_point(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)
 -{
 -	struct nv50_curs *curs = nv50_curs(wndw);
 -	nvif_wr32(&curs->chan, 0x0084, (asyw->point.y << 16) | asyw->point.x);
 -}
 -
 -static void
 -nv50_curs_prepare(struct nv50_wndw *wndw, struct nv50_head_atom *asyh,
 -		  struct nv50_wndw_atom *asyw)
 -{
 -	u32 handle = nv50_disp(wndw->plane.dev)->mast.base.vram.handle;
 -	u32 offset = asyw->image.offset;
 -	if (asyh->curs.handle != handle || asyh->curs.offset != offset) {
 -		asyh->curs.handle = handle;
 -		asyh->curs.offset = offset;
 -		asyh->set.curs = asyh->curs.visible;
 -	}
 -}
 -
 -static void
 -nv50_curs_release(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,
 -		  struct nv50_head_atom *asyh)
 -{
 -	asyh->curs.visible = false;
 -}
 -
 -static int
 -nv50_curs_acquire(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,
 -		  struct nv50_head_atom *asyh)
 -{
 -	int ret;
 -
 -	ret = drm_plane_helper_check_state(&asyw->state, &asyw->clip,
 -					   DRM_PLANE_HELPER_NO_SCALING,
 -					   DRM_PLANE_HELPER_NO_SCALING,
 -					   true, true);
 -	asyh->curs.visible = asyw->state.visible;
 -	if (ret || !asyh->curs.visible)
 -		return ret;
 -
 -	switch (asyw->state.fb->width) {
 -	case 32: asyh->curs.layout = 0; break;
 -	case 64: asyh->curs.layout = 1; break;
 -	default:
 -		return -EINVAL;
 -	}
 -
 -	if (asyw->state.fb->width != asyw->state.fb->height)
 -		return -EINVAL;
 -
 -	switch (asyw->state.fb->format->format) {
 -	case DRM_FORMAT_ARGB8888: asyh->curs.format = 1; break;
 -	default:
 -		WARN_ON(1);
 -		return -EINVAL;
 -	}
 -
 -	return 0;
 -}
 -
 -static void *
 -nv50_curs_dtor(struct nv50_wndw *wndw)
++static void *
++nv50_curs_dtor(struct nv50_wndw *wndw)
+ {
+ 	struct nv50_curs *curs = nv50_curs(wndw);
+ 	nvif_object_fini(&curs->chan);
+ 	return curs;
+ }
+ 
+ static const u32
+ nv50_curs_format[] = {
+ 	DRM_FORMAT_ARGB8888,
+ };
+ 
+ static const struct nv50_wndw_func
+ nv50_curs = {
+ 	.dtor = nv50_curs_dtor,
+ 	.acquire = nv50_curs_acquire,
+ 	.release = nv50_curs_release,
+ 	.prepare = nv50_curs_prepare,
+ 	.point = nv50_curs_point,
+ 	.update = nv50_curs_update,
+ };
+ 
+ static int
+ nv50_curs_new(struct nouveau_drm *drm, struct nv50_head *head,
+ 	      struct nv50_curs **pcurs)
+ {
+ 	static const struct nvif_mclass curses[] = {
+ 		{ GK104_DISP_CURSOR, 0 },
+ 		{ GF110_DISP_CURSOR, 0 },
+ 		{ GT214_DISP_CURSOR, 0 },
+ 		{   G82_DISP_CURSOR, 0 },
+ 		{  NV50_DISP_CURSOR, 0 },
+ 		{}
++>>>>>>> e6db95799b1b (drm/nouveau/kms/nv50: skip core channel cursor update on position-only changes)
  	};
 -	struct nv50_disp_cursor_v0 args = {
 -		.head = head->base.index,
 -	};
 -	struct nv50_disp *disp = nv50_disp(drm->dev);
 -	struct nv50_curs *curs;
 -	int cid, ret;
 -
 -	cid = nvif_mclass(disp->disp, curses);
 -	if (cid < 0) {
 -		NV_ERROR(drm, "No supported cursor immediate class\n");
 -		return cid;
 +	u32 *push;
 +
 +	push = evo_wait(flip.chan, 8);
 +	if (push) {
 +		evo_mthd(push, 0x0084, 1);
 +		evo_data(push, 0x00000000);
 +		evo_mthd(push, 0x0094, 1);
 +		evo_data(push, 0x00000000);
 +		evo_mthd(push, 0x00c0, 1);
 +		evo_data(push, 0x00000000);
 +		evo_mthd(push, 0x0080, 1);
 +		evo_data(push, 0x00000000);
 +		evo_kick(push, flip.chan);
  	}
  
 -	if (!(curs = *pcurs = kzalloc(sizeof(*curs), GFP_KERNEL)))
 -		return -ENOMEM;
 +	nvif_msec(device, 2000,
 +		if (nv50_display_flip_wait(&flip))
 +			break;
 +	);
 +}
  
 -	ret = nv50_wndw_ctor(&nv50_curs, drm->dev, DRM_PLANE_TYPE_CURSOR,
 -			     "curs", head->base.index, &disp->mast.base,
 -			     nv50_curs_format, ARRAY_SIZE(nv50_curs_format),
 -			     &curs->wndw);
 -	if (ret) {
 -		kfree(curs);
 -		return ret;
 -	}
 +int
 +nv50_display_flip_next(struct drm_crtc *crtc, struct drm_framebuffer *fb,
 +		       struct nouveau_channel *chan, u32 swap_interval)
 +{
 +	struct nouveau_framebuffer *nv_fb = nouveau_framebuffer(fb);
 +	struct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);
 +	struct nv50_head *head = nv50_head(crtc);
 +	struct nv50_sync *sync = nv50_sync(crtc);
 +	u32 *push;
 +	int ret;
  
 -	ret = nvif_object_init(disp->disp, 0, curses[cid].oclass, &args,
 -			       sizeof(args), &curs->chan);
 -	if (ret) {
 -		NV_ERROR(drm, "curs%04x allocation failed: %d\n",
 -			 curses[cid].oclass, ret);
 -		return ret;
 +	if (crtc->primary->fb->width != fb->width ||
 +	    crtc->primary->fb->height != fb->height)
 +		return -EINVAL;
 +
 +	swap_interval <<= 4;
 +	if (swap_interval == 0)
 +		swap_interval |= 0x100;
 +	if (chan == NULL)
 +		evo_sync(crtc->dev);
 +
 +	push = evo_wait(sync, 128);
 +	if (unlikely(push == NULL))
 +		return -EBUSY;
 +
 +	if (chan && chan->user.oclass < G82_CHANNEL_GPFIFO) {
 +		ret = RING_SPACE(chan, 8);
 +		if (ret)
 +			return ret;
 +
 +		BEGIN_NV04(chan, 0, NV11_SUBCHAN_DMA_SEMAPHORE, 2);
 +		OUT_RING  (chan, NvEvoSema0 + nv_crtc->index);
 +		OUT_RING  (chan, sync->addr ^ 0x10);
 +		BEGIN_NV04(chan, 0, NV11_SUBCHAN_SEMAPHORE_RELEASE, 1);
 +		OUT_RING  (chan, sync->data + 1);
 +		BEGIN_NV04(chan, 0, NV11_SUBCHAN_SEMAPHORE_OFFSET, 2);
 +		OUT_RING  (chan, sync->addr);
 +		OUT_RING  (chan, sync->data);
 +	} else
 +	if (chan && chan->user.oclass < FERMI_CHANNEL_GPFIFO) {
 +		u64 addr = nv84_fence_crtc(chan, nv_crtc->index) + sync->addr;
 +		ret = RING_SPACE(chan, 12);
 +		if (ret)
 +			return ret;
 +
 +		BEGIN_NV04(chan, 0, NV11_SUBCHAN_DMA_SEMAPHORE, 1);
 +		OUT_RING  (chan, chan->vram.handle);
 +		BEGIN_NV04(chan, 0, NV84_SUBCHAN_SEMAPHORE_ADDRESS_HIGH, 4);
 +		OUT_RING  (chan, upper_32_bits(addr ^ 0x10));
 +		OUT_RING  (chan, lower_32_bits(addr ^ 0x10));
 +		OUT_RING  (chan, sync->data + 1);
 +		OUT_RING  (chan, NV84_SUBCHAN_SEMAPHORE_TRIGGER_WRITE_LONG);
 +		BEGIN_NV04(chan, 0, NV84_SUBCHAN_SEMAPHORE_ADDRESS_HIGH, 4);
 +		OUT_RING  (chan, upper_32_bits(addr));
 +		OUT_RING  (chan, lower_32_bits(addr));
 +		OUT_RING  (chan, sync->data);
 +		OUT_RING  (chan, NV84_SUBCHAN_SEMAPHORE_TRIGGER_ACQUIRE_EQUAL);
 +	} else
 +	if (chan) {
 +		u64 addr = nv84_fence_crtc(chan, nv_crtc->index) + sync->addr;
 +		ret = RING_SPACE(chan, 10);
 +		if (ret)
 +			return ret;
 +
 +		BEGIN_NVC0(chan, 0, NV84_SUBCHAN_SEMAPHORE_ADDRESS_HIGH, 4);
 +		OUT_RING  (chan, upper_32_bits(addr ^ 0x10));
 +		OUT_RING  (chan, lower_32_bits(addr ^ 0x10));
 +		OUT_RING  (chan, sync->data + 1);
 +		OUT_RING  (chan, NV84_SUBCHAN_SEMAPHORE_TRIGGER_WRITE_LONG |
 +				 NVC0_SUBCHAN_SEMAPHORE_TRIGGER_YIELD);
 +		BEGIN_NVC0(chan, 0, NV84_SUBCHAN_SEMAPHORE_ADDRESS_HIGH, 4);
 +		OUT_RING  (chan, upper_32_bits(addr));
 +		OUT_RING  (chan, lower_32_bits(addr));
 +		OUT_RING  (chan, sync->data);
 +		OUT_RING  (chan, NV84_SUBCHAN_SEMAPHORE_TRIGGER_ACQUIRE_EQUAL |
 +				 NVC0_SUBCHAN_SEMAPHORE_TRIGGER_YIELD);
 +	}
 +
 +	if (chan) {
 +		sync->addr ^= 0x10;
 +		sync->data++;
 +		FIRE_RING (chan);
 +	}
 +
 +	/* queue the flip */
 +	evo_mthd(push, 0x0100, 1);
 +	evo_data(push, 0xfffe0000);
 +	evo_mthd(push, 0x0084, 1);
 +	evo_data(push, swap_interval);
 +	if (!(swap_interval & 0x00000100)) {
 +		evo_mthd(push, 0x00e0, 1);
 +		evo_data(push, 0x40000000);
 +	}
 +	evo_mthd(push, 0x0088, 4);
 +	evo_data(push, sync->addr);
 +	evo_data(push, sync->data++);
 +	evo_data(push, sync->data);
 +	evo_data(push, sync->base.sync.handle);
 +	evo_mthd(push, 0x00a0, 2);
 +	evo_data(push, 0x00000000);
 +	evo_data(push, 0x00000000);
 +	evo_mthd(push, 0x00c0, 1);
 +	evo_data(push, nv_fb->r_handle);
 +	evo_mthd(push, 0x0110, 2);
 +	evo_data(push, 0x00000000);
 +	evo_data(push, 0x00000000);
 +	if (nv50_vers(sync) < GF110_DISP_BASE_CHANNEL_DMA) {
 +		evo_mthd(push, 0x0800, 5);
 +		evo_data(push, nv_fb->nvbo->bo.offset >> 8);
 +		evo_data(push, 0);
 +		evo_data(push, (fb->height << 16) | fb->width);
 +		evo_data(push, nv_fb->r_pitch);
 +		evo_data(push, nv_fb->r_format);
 +	} else {
 +		evo_mthd(push, 0x0400, 5);
 +		evo_data(push, nv_fb->nvbo->bo.offset >> 8);
 +		evo_data(push, 0);
 +		evo_data(push, (fb->height << 16) | fb->width);
 +		evo_data(push, nv_fb->r_pitch);
 +		evo_data(push, nv_fb->r_format);
  	}
 +	evo_mthd(push, 0x0080, 1);
 +	evo_data(push, 0x00000000);
 +	evo_kick(push, sync);
  
 +	nouveau_bo_ref(nv_fb->nvbo, &head->image);
  	return 0;
  }
  
* Unmerged path drivers/gpu/drm/nouveau/nv50_display.c
