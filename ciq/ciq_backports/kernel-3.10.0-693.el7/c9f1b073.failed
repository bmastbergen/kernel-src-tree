net/mlx5: Add creation flags when adding new flow table

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [kernel] mlx5: Add creation flags when adding new flow table (Don Dutile) [1385330 1417286]
Rebuild_FUZZ: 96.23%
commit-author Hadar Hen Zion <hadarh@mellanox.com>
commit c9f1b073d0d750ccf8b30b272d1d76479f4cccbc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c9f1b073.failed

When creating flow tables, allow the caller to specify creation flags.
Currently no flags are used and as such this patch doesn't add any new
functionality.

	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c9f1b073d0d750ccf8b30b272d1d76479f4cccbc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
#	drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
#	include/linux/mlx5/fs.h
diff --cc drivers/infiniband/hw/mlx5/main.c
index c59be3674778,9b16431e1de8..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -1840,7 -1856,8 +1840,12 @@@ static struct mlx5_ib_flow_prio *get_fl
  	if (!ft) {
  		ft = mlx5_create_auto_grouped_flow_table(ns, priority,
  							 num_entries,
++<<<<<<< HEAD
 +							 num_groups);
++=======
+ 							 num_groups,
+ 							 0, 0);
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  
  		if (!IS_ERR(ft)) {
  			prio->refcount = 0;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 4df49e660587,9617892e0f15..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@@ -1077,9 -554,419 +1077,423 @@@ static void mlx5e_destroy_flow_table(st
  	ft->t = NULL;
  }
  
 -static void mlx5e_cleanup_ttc_rules(struct mlx5e_ttc_table *ttc)
 +static void mlx5e_destroy_main_flow_table(struct mlx5e_priv *priv)
  {
++<<<<<<< HEAD
 +	mlx5e_destroy_flow_table(&priv->fts.main);
++=======
+ 	int i;
+ 
+ 	for (i = 0; i < MLX5E_NUM_TT; i++) {
+ 		if (!IS_ERR_OR_NULL(ttc->rules[i])) {
+ 			mlx5_del_flow_rules(ttc->rules[i]);
+ 			ttc->rules[i] = NULL;
+ 		}
+ 	}
+ }
+ 
+ static struct {
+ 	u16 etype;
+ 	u8 proto;
+ } ttc_rules[] = {
+ 	[MLX5E_TT_IPV4_TCP] = {
+ 		.etype = ETH_P_IP,
+ 		.proto = IPPROTO_TCP,
+ 	},
+ 	[MLX5E_TT_IPV6_TCP] = {
+ 		.etype = ETH_P_IPV6,
+ 		.proto = IPPROTO_TCP,
+ 	},
+ 	[MLX5E_TT_IPV4_UDP] = {
+ 		.etype = ETH_P_IP,
+ 		.proto = IPPROTO_UDP,
+ 	},
+ 	[MLX5E_TT_IPV6_UDP] = {
+ 		.etype = ETH_P_IPV6,
+ 		.proto = IPPROTO_UDP,
+ 	},
+ 	[MLX5E_TT_IPV4_IPSEC_AH] = {
+ 		.etype = ETH_P_IP,
+ 		.proto = IPPROTO_AH,
+ 	},
+ 	[MLX5E_TT_IPV6_IPSEC_AH] = {
+ 		.etype = ETH_P_IPV6,
+ 		.proto = IPPROTO_AH,
+ 	},
+ 	[MLX5E_TT_IPV4_IPSEC_ESP] = {
+ 		.etype = ETH_P_IP,
+ 		.proto = IPPROTO_ESP,
+ 	},
+ 	[MLX5E_TT_IPV6_IPSEC_ESP] = {
+ 		.etype = ETH_P_IPV6,
+ 		.proto = IPPROTO_ESP,
+ 	},
+ 	[MLX5E_TT_IPV4] = {
+ 		.etype = ETH_P_IP,
+ 		.proto = 0,
+ 	},
+ 	[MLX5E_TT_IPV6] = {
+ 		.etype = ETH_P_IPV6,
+ 		.proto = 0,
+ 	},
+ 	[MLX5E_TT_ANY] = {
+ 		.etype = 0,
+ 		.proto = 0,
+ 	},
+ };
+ 
+ static struct mlx5_flow_handle *
+ mlx5e_generate_ttc_rule(struct mlx5e_priv *priv,
+ 			struct mlx5_flow_table *ft,
+ 			struct mlx5_flow_destination *dest,
+ 			u16 etype,
+ 			u8 proto)
+ {
+ 	struct mlx5_flow_handle *rule;
+ 	struct mlx5_flow_spec *spec;
+ 	int err = 0;
+ 
+ 	spec = mlx5_vzalloc(sizeof(*spec));
+ 	if (!spec) {
+ 		netdev_err(priv->netdev, "%s: alloc failed\n", __func__);
+ 		return ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	if (proto) {
+ 		spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
+ 		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ip_protocol);
+ 		MLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_protocol, proto);
+ 	}
+ 	if (etype) {
+ 		spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
+ 		MLX5_SET_TO_ONES(fte_match_param, spec->match_criteria, outer_headers.ethertype);
+ 		MLX5_SET(fte_match_param, spec->match_value, outer_headers.ethertype, etype);
+ 	}
+ 
+ 	rule = mlx5_add_flow_rules(ft, spec,
+ 				   MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,
+ 				   MLX5_FS_DEFAULT_FLOW_TAG,
+ 				   dest, 1);
+ 	if (IS_ERR(rule)) {
+ 		err = PTR_ERR(rule);
+ 		netdev_err(priv->netdev, "%s: add rule failed\n", __func__);
+ 	}
+ 
+ 	kvfree(spec);
+ 	return err ? ERR_PTR(err) : rule;
+ }
+ 
+ static int mlx5e_generate_ttc_table_rules(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5_flow_destination dest;
+ 	struct mlx5e_ttc_table *ttc;
+ 	struct mlx5_flow_handle **rules;
+ 	struct mlx5_flow_table *ft;
+ 	int tt;
+ 	int err;
+ 
+ 	ttc = &priv->fs.ttc;
+ 	ft = ttc->ft.t;
+ 	rules = ttc->rules;
+ 
+ 	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
+ 	for (tt = 0; tt < MLX5E_NUM_TT; tt++) {
+ 		if (tt == MLX5E_TT_ANY)
+ 			dest.tir_num = priv->direct_tir[0].tirn;
+ 		else
+ 			dest.tir_num = priv->indir_tir[tt].tirn;
+ 		rules[tt] = mlx5e_generate_ttc_rule(priv, ft, &dest,
+ 						    ttc_rules[tt].etype,
+ 						    ttc_rules[tt].proto);
+ 		if (IS_ERR(rules[tt]))
+ 			goto del_rules;
+ 	}
+ 
+ 	return 0;
+ 
+ del_rules:
+ 	err = PTR_ERR(rules[tt]);
+ 	rules[tt] = NULL;
+ 	mlx5e_cleanup_ttc_rules(ttc);
+ 	return err;
+ }
+ 
+ #define MLX5E_TTC_NUM_GROUPS	3
+ #define MLX5E_TTC_GROUP1_SIZE	BIT(3)
+ #define MLX5E_TTC_GROUP2_SIZE	BIT(1)
+ #define MLX5E_TTC_GROUP3_SIZE	BIT(0)
+ #define MLX5E_TTC_TABLE_SIZE	(MLX5E_TTC_GROUP1_SIZE +\
+ 				 MLX5E_TTC_GROUP2_SIZE +\
+ 				 MLX5E_TTC_GROUP3_SIZE)
+ static int mlx5e_create_ttc_table_groups(struct mlx5e_ttc_table *ttc)
+ {
+ 	int inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);
+ 	struct mlx5e_flow_table *ft = &ttc->ft;
+ 	int ix = 0;
+ 	u32 *in;
+ 	int err;
+ 	u8 *mc;
+ 
+ 	ft->g = kcalloc(MLX5E_TTC_NUM_GROUPS,
+ 			sizeof(*ft->g), GFP_KERNEL);
+ 	if (!ft->g)
+ 		return -ENOMEM;
+ 	in = mlx5_vzalloc(inlen);
+ 	if (!in) {
+ 		kfree(ft->g);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	/* L4 Group */
+ 	mc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);
+ 	MLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ip_protocol);
+ 	MLX5_SET_TO_ONES(fte_match_param, mc, outer_headers.ethertype);
+ 	MLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);
+ 	MLX5_SET_CFG(in, start_flow_index, ix);
+ 	ix += MLX5E_TTC_GROUP1_SIZE;
+ 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
+ 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
+ 	if (IS_ERR(ft->g[ft->num_groups]))
+ 		goto err;
+ 	ft->num_groups++;
+ 
+ 	/* L3 Group */
+ 	MLX5_SET(fte_match_param, mc, outer_headers.ip_protocol, 0);
+ 	MLX5_SET_CFG(in, start_flow_index, ix);
+ 	ix += MLX5E_TTC_GROUP2_SIZE;
+ 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
+ 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
+ 	if (IS_ERR(ft->g[ft->num_groups]))
+ 		goto err;
+ 	ft->num_groups++;
+ 
+ 	/* Any Group */
+ 	memset(in, 0, inlen);
+ 	MLX5_SET_CFG(in, start_flow_index, ix);
+ 	ix += MLX5E_TTC_GROUP3_SIZE;
+ 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
+ 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
+ 	if (IS_ERR(ft->g[ft->num_groups]))
+ 		goto err;
+ 	ft->num_groups++;
+ 
+ 	kvfree(in);
+ 	return 0;
+ 
+ err:
+ 	err = PTR_ERR(ft->g[ft->num_groups]);
+ 	ft->g[ft->num_groups] = NULL;
+ 	kvfree(in);
+ 
+ 	return err;
+ }
+ 
+ static void mlx5e_destroy_ttc_table(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_ttc_table *ttc = &priv->fs.ttc;
+ 
+ 	mlx5e_cleanup_ttc_rules(ttc);
+ 	mlx5e_destroy_flow_table(&ttc->ft);
+ }
+ 
+ static int mlx5e_create_ttc_table(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_ttc_table *ttc = &priv->fs.ttc;
+ 	struct mlx5e_flow_table *ft = &ttc->ft;
+ 	int err;
+ 
+ 	ft->t = mlx5_create_flow_table(priv->fs.ns, MLX5E_NIC_PRIO,
+ 				       MLX5E_TTC_TABLE_SIZE, MLX5E_TTC_FT_LEVEL, 0);
+ 	if (IS_ERR(ft->t)) {
+ 		err = PTR_ERR(ft->t);
+ 		ft->t = NULL;
+ 		return err;
+ 	}
+ 
+ 	err = mlx5e_create_ttc_table_groups(ttc);
+ 	if (err)
+ 		goto err;
+ 
+ 	err = mlx5e_generate_ttc_table_rules(priv);
+ 	if (err)
+ 		goto err;
+ 
+ 	return 0;
+ err:
+ 	mlx5e_destroy_flow_table(ft);
+ 	return err;
+ }
+ 
+ static void mlx5e_del_l2_flow_rule(struct mlx5e_priv *priv,
+ 				   struct mlx5e_l2_rule *ai)
+ {
+ 	if (!IS_ERR_OR_NULL(ai->rule)) {
+ 		mlx5_del_flow_rules(ai->rule);
+ 		ai->rule = NULL;
+ 	}
+ }
+ 
+ static int mlx5e_add_l2_flow_rule(struct mlx5e_priv *priv,
+ 				  struct mlx5e_l2_rule *ai, int type)
+ {
+ 	struct mlx5_flow_table *ft = priv->fs.l2.ft.t;
+ 	struct mlx5_flow_destination dest;
+ 	struct mlx5_flow_spec *spec;
+ 	int err = 0;
+ 	u8 *mc_dmac;
+ 	u8 *mv_dmac;
+ 
+ 	spec = mlx5_vzalloc(sizeof(*spec));
+ 	if (!spec) {
+ 		netdev_err(priv->netdev, "%s: alloc failed\n", __func__);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	mc_dmac = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,
+ 			       outer_headers.dmac_47_16);
+ 	mv_dmac = MLX5_ADDR_OF(fte_match_param, spec->match_value,
+ 			       outer_headers.dmac_47_16);
+ 
+ 	dest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;
+ 	dest.ft = priv->fs.ttc.ft.t;
+ 
+ 	switch (type) {
+ 	case MLX5E_FULLMATCH:
+ 		spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
+ 		eth_broadcast_addr(mc_dmac);
+ 		ether_addr_copy(mv_dmac, ai->addr);
+ 		break;
+ 
+ 	case MLX5E_ALLMULTI:
+ 		spec->match_criteria_enable = MLX5_MATCH_OUTER_HEADERS;
+ 		mc_dmac[0] = 0x01;
+ 		mv_dmac[0] = 0x01;
+ 		break;
+ 
+ 	case MLX5E_PROMISC:
+ 		break;
+ 	}
+ 
+ 	ai->rule = mlx5_add_flow_rules(ft, spec,
+ 				       MLX5_FLOW_CONTEXT_ACTION_FWD_DEST,
+ 				       MLX5_FS_DEFAULT_FLOW_TAG, &dest, 1);
+ 	if (IS_ERR(ai->rule)) {
+ 		netdev_err(priv->netdev, "%s: add l2 rule(mac:%pM) failed\n",
+ 			   __func__, mv_dmac);
+ 		err = PTR_ERR(ai->rule);
+ 		ai->rule = NULL;
+ 	}
+ 
+ 	kvfree(spec);
+ 
+ 	return err;
+ }
+ 
+ #define MLX5E_NUM_L2_GROUPS	   3
+ #define MLX5E_L2_GROUP1_SIZE	   BIT(0)
+ #define MLX5E_L2_GROUP2_SIZE	   BIT(15)
+ #define MLX5E_L2_GROUP3_SIZE	   BIT(0)
+ #define MLX5E_L2_TABLE_SIZE	   (MLX5E_L2_GROUP1_SIZE +\
+ 				    MLX5E_L2_GROUP2_SIZE +\
+ 				    MLX5E_L2_GROUP3_SIZE)
+ static int mlx5e_create_l2_table_groups(struct mlx5e_l2_table *l2_table)
+ {
+ 	int inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);
+ 	struct mlx5e_flow_table *ft = &l2_table->ft;
+ 	int ix = 0;
+ 	u8 *mc_dmac;
+ 	u32 *in;
+ 	int err;
+ 	u8 *mc;
+ 
+ 	ft->g = kcalloc(MLX5E_NUM_L2_GROUPS, sizeof(*ft->g), GFP_KERNEL);
+ 	if (!ft->g)
+ 		return -ENOMEM;
+ 	in = mlx5_vzalloc(inlen);
+ 	if (!in) {
+ 		kfree(ft->g);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	mc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);
+ 	mc_dmac = MLX5_ADDR_OF(fte_match_param, mc,
+ 			       outer_headers.dmac_47_16);
+ 	/* Flow Group for promiscuous */
+ 	MLX5_SET_CFG(in, start_flow_index, ix);
+ 	ix += MLX5E_L2_GROUP1_SIZE;
+ 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
+ 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
+ 	if (IS_ERR(ft->g[ft->num_groups]))
+ 		goto err_destroy_groups;
+ 	ft->num_groups++;
+ 
+ 	/* Flow Group for full match */
+ 	eth_broadcast_addr(mc_dmac);
+ 	MLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);
+ 	MLX5_SET_CFG(in, start_flow_index, ix);
+ 	ix += MLX5E_L2_GROUP2_SIZE;
+ 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
+ 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
+ 	if (IS_ERR(ft->g[ft->num_groups]))
+ 		goto err_destroy_groups;
+ 	ft->num_groups++;
+ 
+ 	/* Flow Group for allmulti */
+ 	eth_zero_addr(mc_dmac);
+ 	mc_dmac[0] = 0x01;
+ 	MLX5_SET_CFG(in, start_flow_index, ix);
+ 	ix += MLX5E_L2_GROUP3_SIZE;
+ 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
+ 	ft->g[ft->num_groups] = mlx5_create_flow_group(ft->t, in);
+ 	if (IS_ERR(ft->g[ft->num_groups]))
+ 		goto err_destroy_groups;
+ 	ft->num_groups++;
+ 
+ 	kvfree(in);
+ 	return 0;
+ 
+ err_destroy_groups:
+ 	err = PTR_ERR(ft->g[ft->num_groups]);
+ 	ft->g[ft->num_groups] = NULL;
+ 	mlx5e_destroy_groups(ft);
+ 	kvfree(in);
+ 
+ 	return err;
+ }
+ 
+ static void mlx5e_destroy_l2_table(struct mlx5e_priv *priv)
+ {
+ 	mlx5e_destroy_flow_table(&priv->fs.l2.ft);
+ }
+ 
+ static int mlx5e_create_l2_table(struct mlx5e_priv *priv)
+ {
+ 	struct mlx5e_l2_table *l2_table = &priv->fs.l2;
+ 	struct mlx5e_flow_table *ft = &l2_table->ft;
+ 	int err;
+ 
+ 	ft->num_groups = 0;
+ 	ft->t = mlx5_create_flow_table(priv->fs.ns, MLX5E_NIC_PRIO,
+ 				       MLX5E_L2_TABLE_SIZE, MLX5E_L2_FT_LEVEL, 0);
+ 
+ 	if (IS_ERR(ft->t)) {
+ 		err = PTR_ERR(ft->t);
+ 		ft->t = NULL;
+ 		return err;
+ 	}
+ 
+ 	err = mlx5e_create_l2_table_groups(l2_table);
+ 	if (err)
+ 		goto err_destroy_flow_table;
+ 
+ 	return 0;
+ 
+ err_destroy_flow_table:
+ 	mlx5_destroy_flow_table(ft->t);
+ 	ft->t = NULL;
+ 
+ 	return err;
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  }
  
  #define MLX5E_NUM_VLAN_GROUPS	2
@@@ -1150,7 -1037,8 +1564,12 @@@ static int mlx5e_create_vlan_flow_table
  	int err;
  
  	ft->num_groups = 0;
++<<<<<<< HEAD
 +	ft->t = mlx5_create_flow_table(priv->fts.ns, 1, MLX5E_VLAN_TABLE_SIZE);
++=======
+ 	ft->t = mlx5_create_flow_table(priv->fs.ns, MLX5E_NIC_PRIO,
+ 				       MLX5E_VLAN_TABLE_SIZE, MLX5E_VLAN_FT_LEVEL, 0);
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  
  	if (IS_ERR(ft->t)) {
  		err = PTR_ERR(ft->t);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 6c7352099dd6,27f21ac66639..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -414,8 -361,8 +414,13 @@@ static int esw_create_fdb_table(struct 
  	memset(flow_group_in, 0, inlen);
  
  	table_size = BIT(MLX5_CAP_ESW_FLOWTABLE_FDB(dev, log_max_ft_size));
++<<<<<<< HEAD
 +	fdb = mlx5_create_flow_table(root_ns, 0, table_size);
 +	if (IS_ERR_OR_NULL(fdb)) {
++=======
+ 	fdb = mlx5_create_flow_table(root_ns, 0, table_size, 0, 0);
+ 	if (IS_ERR(fdb)) {
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  		err = PTR_ERR(fdb);
  		esw_warn(dev, "Failed to create FDB Table err %d\n", err);
  		goto out;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
index 9255fb6f5d9d,cc97bb218e74..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
@@@ -57,16 -58,17 +58,22 @@@ int mlx5_cmd_update_root_ft(struct mlx5
  }
  
  int mlx5_cmd_create_flow_table(struct mlx5_core_dev *dev,
 -			       u16 vport,
 -			       enum fs_flow_table_op_mod op_mod,
  			       enum fs_flow_table_type type, unsigned int level,
  			       unsigned int log_size, struct mlx5_flow_table
- 			       *next_ft, unsigned int *table_id)
+ 			       *next_ft, unsigned int *table_id, u32 flags)
  {
++<<<<<<< HEAD
 +	u32 out[MLX5_ST_SZ_DW(create_flow_table_out)];
 +	u32 in[MLX5_ST_SZ_DW(create_flow_table_in)];
++=======
+ 	int en_encap_decap = !!(flags & MLX5_FLOW_TABLE_TUNNEL_EN);
+ 	u32 out[MLX5_ST_SZ_DW(create_flow_table_out)] = {0};
+ 	u32 in[MLX5_ST_SZ_DW(create_flow_table_in)]   = {0};
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  	int err;
  
 +	memset(in, 0, sizeof(in));
 +
  	MLX5_SET(create_flow_table_in, in, opcode,
  		 MLX5_CMD_OP_CREATE_FLOW_TABLE);
  
@@@ -77,11 -75,31 +84,24 @@@
  	MLX5_SET(create_flow_table_in, in, table_type, type);
  	MLX5_SET(create_flow_table_in, in, level, level);
  	MLX5_SET(create_flow_table_in, in, log_size, log_size);
 -	if (vport) {
 -		MLX5_SET(create_flow_table_in, in, vport_number, vport);
 -		MLX5_SET(create_flow_table_in, in, other_vport, 1);
 -	}
  
++<<<<<<< HEAD
 +	memset(out, 0, sizeof(out));
 +	err = mlx5_cmd_exec_check_status(dev, in, sizeof(in), out,
 +					 sizeof(out));
++=======
+ 	MLX5_SET(create_flow_table_in, in, decap_en, en_encap_decap);
+ 	MLX5_SET(create_flow_table_in, in, encap_en, en_encap_decap);
+ 
+ 	switch (op_mod) {
+ 	case FS_FT_OP_MOD_NORMAL:
+ 		if (next_ft) {
+ 			MLX5_SET(create_flow_table_in, in, table_miss_mode, 1);
+ 			MLX5_SET(create_flow_table_in, in, table_miss_id, next_ft->id);
+ 		}
+ 		break;
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  
 -	case FS_FT_OP_MOD_LAG_DEMUX:
 -		MLX5_SET(create_flow_table_in, in, op_mod, 0x1);
 -		if (next_ft)
 -			MLX5_SET(create_flow_table_in, in, lag_master_next_table_id,
 -				 next_ft->id);
 -		break;
 -	}
 -
 -	err = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
  	if (!err)
  		*table_id = MLX5_GET(create_flow_table_out, out,
  				     table_id);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index de1cde8dc012,4d28c8d70482..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -482,8 -503,10 +482,15 @@@ static struct mlx5_flow_group *alloc_fl
  	return fg;
  }
  
++<<<<<<< HEAD
 +static struct mlx5_flow_table *alloc_flow_table(int level, int max_fte,
 +						enum fs_flow_table_type table_type)
++=======
+ static struct mlx5_flow_table *alloc_flow_table(int level, u16 vport, int max_fte,
+ 						enum fs_flow_table_type table_type,
+ 						enum fs_flow_table_op_mod op_mod,
+ 						u32 flags)
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  {
  	struct mlx5_flow_table *ft;
  
@@@ -493,8 -516,11 +500,9 @@@
  
  	ft->level = level;
  	ft->node.type = FS_TYPE_FLOW_TABLE;
 -	ft->op_mod = op_mod;
  	ft->type = table_type;
 -	ft->vport = vport;
  	ft->max_fte = max_fte;
+ 	ft->flags = flags;
  	INIT_LIST_HEAD(&ft->fwd_rules);
  	mutex_init(&ft->lock);
  
@@@ -711,9 -762,25 +719,31 @@@ static int connect_flow_table(struct ml
  	return err;
  }
  
++<<<<<<< HEAD
 +struct mlx5_flow_table *mlx5_create_flow_table(struct mlx5_flow_namespace *ns,
 +					       int prio,
 +					       int max_fte)
++=======
+ static void list_add_flow_table(struct mlx5_flow_table *ft,
+ 				struct fs_prio *prio)
+ {
+ 	struct list_head *prev = &prio->node.children;
+ 	struct mlx5_flow_table *iter;
+ 
+ 	fs_for_each_ft(iter, prio) {
+ 		if (iter->level > ft->level)
+ 			break;
+ 		prev = &iter->node.list;
+ 	}
+ 	list_add(&ft->node.list, prev);
+ }
+ 
+ static struct mlx5_flow_table *__mlx5_create_flow_table(struct mlx5_flow_namespace *ns,
+ 							enum fs_flow_table_op_mod op_mod,
+ 							u16 vport, int prio,
+ 							int max_fte, u32 level,
+ 							u32 flags)
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  {
  	struct mlx5_flow_table *next_ft = NULL;
  	struct mlx5_flow_table *ft;
@@@ -738,20 -805,26 +768,38 @@@
  		err = -ENOSPC;
  		goto unlock_root;
  	}
++<<<<<<< HEAD
 +
 +	ft = alloc_flow_table(find_next_free_level(fs_prio),
 +			      roundup_pow_of_two(max_fte),
 +			      root->table_type);
++=======
+ 	/* The level is related to the
+ 	 * priority level range.
+ 	 */
+ 	level += fs_prio->start_level;
+ 	ft = alloc_flow_table(level,
+ 			      vport,
+ 			      max_fte ? roundup_pow_of_two(max_fte) : 0,
+ 			      root->table_type,
+ 			      op_mod, flags);
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  	if (!ft) {
  		err = -ENOMEM;
  		goto unlock_root;
  	}
  
  	tree_init_node(&ft->node, 1, del_flow_table);
 -	log_table_sz = ft->max_fte ? ilog2(ft->max_fte) : 0;
 +	log_table_sz = ilog2(ft->max_fte);
  	next_ft = find_next_chained_ft(fs_prio);
++<<<<<<< HEAD
 +	err = mlx5_cmd_create_flow_table(root->dev, ft->type, ft->level,
 +					 log_table_sz, next_ft, &ft->id);
++=======
+ 	err = mlx5_cmd_create_flow_table(root->dev, ft->vport, ft->op_mod, ft->type,
+ 					 ft->level, log_table_sz, next_ft, &ft->id,
+ 					 ft->flags);
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  	if (err)
  		goto free_ft;
  
@@@ -774,17 -847,45 +822,56 @@@ unlock_root
  	return ERR_PTR(err);
  }
  
++<<<<<<< HEAD
 +struct mlx5_flow_table *mlx5_create_auto_grouped_flow_table(struct mlx5_flow_namespace *ns,
 +							    int prio,
 +							    int num_flow_table_entries,
 +							    int max_num_groups)
++=======
+ struct mlx5_flow_table *mlx5_create_flow_table(struct mlx5_flow_namespace *ns,
+ 					       int prio, int max_fte,
+ 					       u32 level,
+ 					       u32 flags)
+ {
+ 	return __mlx5_create_flow_table(ns, FS_FT_OP_MOD_NORMAL, 0, prio,
+ 					max_fte, level, flags);
+ }
+ 
+ struct mlx5_flow_table *mlx5_create_vport_flow_table(struct mlx5_flow_namespace *ns,
+ 						     int prio, int max_fte,
+ 						     u32 level, u16 vport)
+ {
+ 	return __mlx5_create_flow_table(ns, FS_FT_OP_MOD_NORMAL, vport, prio,
+ 					max_fte, level, 0);
+ }
+ 
+ struct mlx5_flow_table *mlx5_create_lag_demux_flow_table(
+ 					       struct mlx5_flow_namespace *ns,
+ 					       int prio, u32 level)
+ {
+ 	return __mlx5_create_flow_table(ns, FS_FT_OP_MOD_LAG_DEMUX, 0, prio, 0,
+ 					level, 0);
+ }
+ EXPORT_SYMBOL(mlx5_create_lag_demux_flow_table);
+ 
+ struct mlx5_flow_table *mlx5_create_auto_grouped_flow_table(struct mlx5_flow_namespace *ns,
+ 							    int prio,
+ 							    int num_flow_table_entries,
+ 							    int max_num_groups,
+ 							    u32 level,
+ 							    u32 flags)
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  {
  	struct mlx5_flow_table *ft;
  
  	if (max_num_groups > num_flow_table_entries)
  		return ERR_PTR(-EINVAL);
  
++<<<<<<< HEAD
 +	ft = mlx5_create_flow_table(ns, prio, num_flow_table_entries);
++=======
+ 	ft = mlx5_create_flow_table(ns, prio, num_flow_table_entries, level, flags);
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  	if (IS_ERR(ft))
  		return ft;
  
@@@ -1565,12 -1825,12 +1652,16 @@@ static int create_anchor_flow_table(str
  	struct mlx5_flow_namespace *ns = NULL;
  	struct mlx5_flow_table *ft;
  
 -	ns = mlx5_get_flow_namespace(steering->dev, MLX5_FLOW_NAMESPACE_ANCHOR);
 +	ns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_ANCHOR);
  	if (!ns)
  		return -EINVAL;
++<<<<<<< HEAD
 +	ft = mlx5_create_flow_table(ns, ANCHOR_PRIO, ANCHOR_SIZE);
++=======
+ 	ft = mlx5_create_flow_table(ns, ANCHOR_PRIO, ANCHOR_SIZE, ANCHOR_LEVEL, 0);
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  	if (IS_ERR(ft)) {
 -		mlx5_core_err(steering->dev, "Failed to create last anchor flow table");
 +		mlx5_core_err(dev, "Failed to create last anchor flow table");
  		return PTR_ERR(ft);
  	}
  	return 0;
diff --cc include/linux/mlx5/fs.h
index 3f3444d24756,ab1a5fd2e995..000000000000
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@@ -83,12 -100,24 +87,32 @@@ struct mlx5_flow_table 
  mlx5_create_auto_grouped_flow_table(struct mlx5_flow_namespace *ns,
  				    int prio,
  				    int num_flow_table_entries,
++<<<<<<< HEAD
 +				    int max_num_groups);
++=======
+ 				    int max_num_groups,
+ 				    u32 level,
+ 				    u32 flags);
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  
  struct mlx5_flow_table *
  mlx5_create_flow_table(struct mlx5_flow_namespace *ns,
  		       int prio,
++<<<<<<< HEAD
 +		       int num_flow_table_entries);
++=======
+ 		       int num_flow_table_entries,
+ 		       u32 level,
+ 		       u32 flags);
+ struct mlx5_flow_table *
+ mlx5_create_vport_flow_table(struct mlx5_flow_namespace *ns,
+ 			     int prio,
+ 			     int num_flow_table_entries,
+ 			     u32 level, u16 vport);
+ struct mlx5_flow_table *mlx5_create_lag_demux_flow_table(
+ 					       struct mlx5_flow_namespace *ns,
+ 					       int prio, u32 level);
++>>>>>>> c9f1b073d0d7 (net/mlx5: Add creation flags when adding new flow table)
  int mlx5_destroy_flow_table(struct mlx5_flow_table *ft);
  
  /* inbox should be set with the following values:
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
index ef9e0168938b..7311428fde62 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.h
@@ -36,7 +36,7 @@
 int mlx5_cmd_create_flow_table(struct mlx5_core_dev *dev,
 			       enum fs_flow_table_type type, unsigned int level,
 			       unsigned int log_size, struct mlx5_flow_table
-			       *next_ft, unsigned int *table_id);
+			       *next_ft, unsigned int *table_id, u32 flags);
 
 int mlx5_cmd_destroy_flow_table(struct mlx5_core_dev *dev,
 				struct mlx5_flow_table *ft);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
index d607e564f454..f29868cb205b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.h
@@ -91,6 +91,7 @@ struct mlx5_flow_table {
 	struct mutex			lock;
 	/* FWD rules that point on this flow table */
 	struct list_head		fwd_rules;
+	u32				flags;
 };
 
 /* Type of children is mlx5_flow_rule */
* Unmerged path include/linux/mlx5/fs.h
