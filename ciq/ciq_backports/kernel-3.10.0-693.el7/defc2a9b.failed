s390/dasd: allow 0 for path_threshold attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [s390] dasd: allow 0 for path_threshold attribute (Hendrik Brueckner) [1447738]
Rebuild_FUZZ: 94.38%
commit-author Stefan Haberland <sth@linux.vnet.ibm.com>
commit defc2a9b9899511445cfbaa2c3a6509964b71207
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/defc2a9b.failed

Allow 0 as valid input for the path_threshold attribute to deactivate
the IFCC/CCC error handling.

	Signed-off-by: Stefan Haberland <sth@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit defc2a9b9899511445cfbaa2c3a6509964b71207)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/block/dasd_devmap.c
diff --cc drivers/s390/block/dasd_devmap.c
index a71bb8aaca1d,1164b51d09f3..000000000000
--- a/drivers/s390/block/dasd_devmap.c
+++ b/drivers/s390/block/dasd_devmap.c
@@@ -1337,6 -1464,122 +1337,125 @@@ static ssize_t dasd_reservation_state_s
  static DEVICE_ATTR(last_known_reservation_state, 0644,
  		   dasd_reservation_state_show, dasd_reservation_state_store);
  
++<<<<<<< HEAD
++=======
+ static ssize_t dasd_pm_show(struct device *dev,
+ 			      struct device_attribute *attr, char *buf)
+ {
+ 	struct dasd_device *device;
+ 	u8 opm, nppm, cablepm, cuirpm, hpfpm, ifccpm;
+ 
+ 	device = dasd_device_from_cdev(to_ccwdev(dev));
+ 	if (IS_ERR(device))
+ 		return sprintf(buf, "0\n");
+ 
+ 	opm = dasd_path_get_opm(device);
+ 	nppm = dasd_path_get_nppm(device);
+ 	cablepm = dasd_path_get_cablepm(device);
+ 	cuirpm = dasd_path_get_cuirpm(device);
+ 	hpfpm = dasd_path_get_hpfpm(device);
+ 	ifccpm = dasd_path_get_ifccpm(device);
+ 	dasd_put_device(device);
+ 
+ 	return sprintf(buf, "%02x %02x %02x %02x %02x %02x\n", opm, nppm,
+ 		       cablepm, cuirpm, hpfpm, ifccpm);
+ }
+ 
+ static DEVICE_ATTR(path_masks, 0444, dasd_pm_show, NULL);
+ 
+ /*
+  * threshold value for IFCC/CCC errors
+  */
+ static ssize_t
+ dasd_path_threshold_show(struct device *dev,
+ 			  struct device_attribute *attr, char *buf)
+ {
+ 	struct dasd_device *device;
+ 	int len;
+ 
+ 	device = dasd_device_from_cdev(to_ccwdev(dev));
+ 	if (IS_ERR(device))
+ 		return -ENODEV;
+ 	len = snprintf(buf, PAGE_SIZE, "%lu\n", device->path_thrhld);
+ 	dasd_put_device(device);
+ 	return len;
+ }
+ 
+ static ssize_t
+ dasd_path_threshold_store(struct device *dev, struct device_attribute *attr,
+ 			   const char *buf, size_t count)
+ {
+ 	struct dasd_device *device;
+ 	unsigned long flags;
+ 	unsigned long val;
+ 
+ 	device = dasd_device_from_cdev(to_ccwdev(dev));
+ 	if (IS_ERR(device))
+ 		return -ENODEV;
+ 
+ 	if (kstrtoul(buf, 10, &val) != 0 || val > DASD_THRHLD_MAX) {
+ 		dasd_put_device(device);
+ 		return -EINVAL;
+ 	}
+ 	spin_lock_irqsave(get_ccwdev_lock(to_ccwdev(dev)), flags);
+ 	device->path_thrhld = val;
+ 	spin_unlock_irqrestore(get_ccwdev_lock(to_ccwdev(dev)), flags);
+ 	dasd_put_device(device);
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR(path_threshold, 0644, dasd_path_threshold_show,
+ 		   dasd_path_threshold_store);
+ /*
+  * interval for IFCC/CCC checks
+  * meaning time with no IFCC/CCC error before the error counter
+  * gets reset
+  */
+ static ssize_t
+ dasd_path_interval_show(struct device *dev,
+ 			struct device_attribute *attr, char *buf)
+ {
+ 	struct dasd_device *device;
+ 	int len;
+ 
+ 	device = dasd_device_from_cdev(to_ccwdev(dev));
+ 	if (IS_ERR(device))
+ 		return -ENODEV;
+ 	len = snprintf(buf, PAGE_SIZE, "%lu\n", device->path_interval);
+ 	dasd_put_device(device);
+ 	return len;
+ }
+ 
+ static ssize_t
+ dasd_path_interval_store(struct device *dev, struct device_attribute *attr,
+ 	       const char *buf, size_t count)
+ {
+ 	struct dasd_device *device;
+ 	unsigned long flags;
+ 	unsigned long val;
+ 
+ 	device = dasd_device_from_cdev(to_ccwdev(dev));
+ 	if (IS_ERR(device))
+ 		return -ENODEV;
+ 
+ 	if ((kstrtoul(buf, 10, &val) != 0) ||
+ 	    (val > DASD_INTERVAL_MAX) || val == 0) {
+ 		dasd_put_device(device);
+ 		return -EINVAL;
+ 	}
+ 	spin_lock_irqsave(get_ccwdev_lock(to_ccwdev(dev)), flags);
+ 	if (val)
+ 		device->path_interval = val;
+ 	spin_unlock_irqrestore(get_ccwdev_lock(to_ccwdev(dev)), flags);
+ 	dasd_put_device(device);
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR(path_interval, 0644, dasd_path_interval_show,
+ 		   dasd_path_interval_store);
+ 
+ 
++>>>>>>> defc2a9b9899 (s390/dasd: allow 0 for path_threshold attribute)
  static struct attribute * dasd_attrs[] = {
  	&dev_attr_readonly.attr,
  	&dev_attr_discipline.attr,
* Unmerged path drivers/s390/block/dasd_devmap.c
