drm/nouveau/kms/nv50: fix setting of HeadSetRasterVertBlankDmi method

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [drm] nouveau/kms/nv50: fix setting of HeadSetRasterVertBlankDmi method (Rob Clark) [1422186]
Rebuild_FUZZ: 97.01%
commit-author Ben Skeggs <bskeggs@redhat.com>
commit d639fbcc102745187f747a21bdcffcf628e174c8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/d639fbcc.failed

	Cc: stable@vger.kernel.org	[4.10+]
	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit d639fbcc102745187f747a21bdcffcf628e174c8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/nv50_display.c
diff --cc drivers/gpu/drm/nouveau/nv50_display.c
index a43445caae60,4405ca1fb3e2..000000000000
--- a/drivers/gpu/drm/nouveau/nv50_display.c
+++ b/drivers/gpu/drm/nouveau/nv50_display.c
@@@ -745,111 -929,143 +745,152 @@@ nv50_crtc_set_dither(struct nouveau_crt
  	return 0;
  }
  
 -static void
 -nv50_wndw_cleanup_fb(struct drm_plane *plane, struct drm_plane_state *old_state)
 -{
 -	struct nouveau_framebuffer *fb = nouveau_framebuffer(old_state->fb);
 -	struct nouveau_drm *drm = nouveau_drm(plane->dev);
 -
 -	NV_ATOMIC(drm, "%s cleanup: %p\n", plane->name, old_state->fb);
 -	if (!old_state->fb)
 -		return;
 -
 -	nouveau_bo_unpin(fb->nvbo);
 -}
 -
  static int
 -nv50_wndw_prepare_fb(struct drm_plane *plane, struct drm_plane_state *state)
 +nv50_crtc_set_scale(struct nouveau_crtc *nv_crtc, bool update)
  {
 -	struct nouveau_framebuffer *fb = nouveau_framebuffer(state->fb);
 -	struct nouveau_drm *drm = nouveau_drm(plane->dev);
 -	struct nv50_wndw *wndw = nv50_wndw(plane);
 -	struct nv50_wndw_atom *asyw = nv50_wndw_atom(state);
 -	struct nv50_head_atom *asyh;
 -	struct nv50_dmac_ctxdma *ctxdma;
 -	int ret;
 -
 -	NV_ATOMIC(drm, "%s prepare: %p\n", plane->name, state->fb);
 -	if (!asyw->state.fb)
 -		return 0;
 -
 -	ret = nouveau_bo_pin(fb->nvbo, TTM_PL_FLAG_VRAM, true);
 -	if (ret)
 -		return ret;
 +	struct nv50_mast *mast = nv50_mast(nv_crtc->base.dev);
 +	struct drm_display_mode *omode, *umode = &nv_crtc->base.mode;
 +	struct drm_crtc *crtc = &nv_crtc->base;
 +	struct nouveau_connector *nv_connector;
 +	int mode = DRM_MODE_SCALE_NONE;
 +	u32 oX, oY, *push;
  
 -	ctxdma = nv50_dmac_ctxdma_new(wndw->dmac, fb);
 -	if (IS_ERR(ctxdma)) {
 -		nouveau_bo_unpin(fb->nvbo);
 -		return PTR_ERR(ctxdma);
 +	/* start off at the resolution we programmed the crtc for, this
 +	 * effectively handles NONE/FULL scaling
 +	 */
 +	nv_connector = nouveau_crtc_connector_get(nv_crtc);
 +	if (nv_connector && nv_connector->native_mode) {
 +		mode = nv_connector->scaling_mode;
 +		if (nv_connector->scaling_full) /* non-EDID LVDS/eDP mode */
 +			mode = DRM_MODE_SCALE_FULLSCREEN;
  	}
  
 -	asyw->state.fence = reservation_object_get_excl_rcu(fb->nvbo->bo.resv);
 -	asyw->image.handle = ctxdma->object.handle;
 -	asyw->image.offset = fb->nvbo->bo.offset;
 +	if (mode != DRM_MODE_SCALE_NONE)
 +		omode = nv_connector->native_mode;
 +	else
 +		omode = umode;
  
 -	if (wndw->func->prepare) {
 -		asyh = nv50_head_atom_get(asyw->state.state, asyw->state.crtc);
 -		if (IS_ERR(asyh))
 -			return PTR_ERR(asyh);
 +	oX = omode->hdisplay;
 +	oY = omode->vdisplay;
 +	if (omode->flags & DRM_MODE_FLAG_DBLSCAN)
 +		oY *= 2;
  
 -		wndw->func->prepare(wndw, asyh, asyw);
 -	}
 +	/* add overscan compensation if necessary, will keep the aspect
 +	 * ratio the same as the backend mode unless overridden by the
 +	 * user setting both hborder and vborder properties.
 +	 */
 +	if (nv_connector && ( nv_connector->underscan == UNDERSCAN_ON ||
 +			     (nv_connector->underscan == UNDERSCAN_AUTO &&
 +			      drm_detect_hdmi_monitor(nv_connector->edid)))) {
 +		u32 bX = nv_connector->underscan_hborder;
 +		u32 bY = nv_connector->underscan_vborder;
 +		u32 aspect = (oY << 19) / oX;
  
 -	return 0;
 -}
 +		if (bX) {
 +			oX -= (bX * 2);
 +			if (bY) oY -= (bY * 2);
 +			else    oY  = ((oX * aspect) + (aspect / 2)) >> 19;
 +		} else {
 +			oX -= (oX >> 4) + 32;
 +			if (bY) oY -= (bY * 2);
 +			else    oY  = ((oX * aspect) + (aspect / 2)) >> 19;
 +		}
 +	}
  
 -static const struct drm_plane_helper_funcs
 -nv50_wndw_helper = {
 -	.prepare_fb = nv50_wndw_prepare_fb,
 -	.cleanup_fb = nv50_wndw_cleanup_fb,
 -	.atomic_check = nv50_wndw_atomic_check,
 -};
 +	/* handle CENTER/ASPECT scaling, taking into account the areas
 +	 * removed already for overscan compensation
 +	 */
 +	switch (mode) {
 +	case DRM_MODE_SCALE_CENTER:
 +		oX = min((u32)umode->hdisplay, oX);
 +		oY = min((u32)umode->vdisplay, oY);
 +		/* fall-through */
 +	case DRM_MODE_SCALE_ASPECT:
 +		if (oY < oX) {
 +			u32 aspect = (umode->hdisplay << 19) / umode->vdisplay;
 +			oX = ((oY * aspect) + (aspect / 2)) >> 19;
 +		} else {
 +			u32 aspect = (umode->vdisplay << 19) / umode->hdisplay;
 +			oY = ((oX * aspect) + (aspect / 2)) >> 19;
 +		}
 +		break;
 +	default:
 +		break;
 +	}
  
 -static void
 -nv50_wndw_atomic_destroy_state(struct drm_plane *plane,
 -			       struct drm_plane_state *state)
 -{
 -	struct nv50_wndw_atom *asyw = nv50_wndw_atom(state);
 -	__drm_atomic_helper_plane_destroy_state(&asyw->state);
 -	dma_fence_put(asyw->state.fence);
 -	kfree(asyw);
 -}
 +	push = evo_wait(mast, 8);
 +	if (push) {
 +		if (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {
 +			/*XXX: SCALE_CTRL_ACTIVE??? */
 +			evo_mthd(push, 0x08d8 + (nv_crtc->index * 0x400), 2);
 +			evo_data(push, (oY << 16) | oX);
 +			evo_data(push, (oY << 16) | oX);
 +			evo_mthd(push, 0x08a4 + (nv_crtc->index * 0x400), 1);
 +			evo_data(push, 0x00000000);
 +			evo_mthd(push, 0x08c8 + (nv_crtc->index * 0x400), 1);
 +			evo_data(push, umode->vdisplay << 16 | umode->hdisplay);
 +		} else {
 +			evo_mthd(push, 0x04c0 + (nv_crtc->index * 0x300), 3);
 +			evo_data(push, (oY << 16) | oX);
 +			evo_data(push, (oY << 16) | oX);
 +			evo_data(push, (oY << 16) | oX);
 +			evo_mthd(push, 0x0494 + (nv_crtc->index * 0x300), 1);
 +			evo_data(push, 0x00000000);
 +			evo_mthd(push, 0x04b8 + (nv_crtc->index * 0x300), 1);
 +			evo_data(push, umode->vdisplay << 16 | umode->hdisplay);
 +		}
  
 -static struct drm_plane_state *
 -nv50_wndw_atomic_duplicate_state(struct drm_plane *plane)
 -{
 -	struct nv50_wndw_atom *armw = nv50_wndw_atom(plane->state);
 -	struct nv50_wndw_atom *asyw;
 -	if (!(asyw = kmalloc(sizeof(*asyw), GFP_KERNEL)))
 -		return NULL;
 -	__drm_atomic_helper_plane_duplicate_state(plane, &asyw->state);
 -	asyw->state.fence = NULL;
 -	asyw->interval = 1;
 -	asyw->sema = armw->sema;
 -	asyw->ntfy = armw->ntfy;
 -	asyw->image = armw->image;
 -	asyw->point = armw->point;
 -	asyw->lut = armw->lut;
 -	asyw->clr.mask = 0;
 -	asyw->set.mask = 0;
 -	return &asyw->state;
 -}
++<<<<<<< HEAD
 +		evo_kick(push, mast);
  
 +		if (update) {
 +			nv50_display_flip_stop(crtc);
 +			nv50_display_flip_next(crtc, crtc->primary->fb,
 +					       NULL, 1);
 +		}
++=======
+ static void
 -nv50_wndw_reset(struct drm_plane *plane)
++nv50_head_atomic_check_mode(struct nv50_head *head, struct nv50_head_atom *asyh)
+ {
 -	struct nv50_wndw_atom *asyw;
 -
 -	if (WARN_ON(!(asyw = kzalloc(sizeof(*asyw), GFP_KERNEL))))
 -		return;
++	struct drm_display_mode *mode = &asyh->state.adjusted_mode;
++	u32 ilace   = (mode->flags & DRM_MODE_FLAG_INTERLACE) ? 2 : 1;
++	u32 vscan   = (mode->flags & DRM_MODE_FLAG_DBLSCAN) ? 2 : 1;
++	u32 hbackp  =  mode->htotal - mode->hsync_end;
++	u32 vbackp  = (mode->vtotal - mode->vsync_end) * vscan / ilace;
++	u32 hfrontp =  mode->hsync_start - mode->hdisplay;
++	u32 vfrontp = (mode->vsync_start - mode->vdisplay) * vscan / ilace;
++	u32 blankus;
++	struct nv50_head_mode *m = &asyh->mode;
+ 
 -	if (plane->state)
 -		plane->funcs->atomic_destroy_state(plane, plane->state);
 -	plane->state = &asyw->state;
 -	plane->state->plane = plane;
 -	plane->state->rotation = DRM_ROTATE_0;
 -}
++	m->h.active = mode->htotal;
++	m->h.synce  = mode->hsync_end - mode->hsync_start - 1;
++	m->h.blanke = m->h.synce + hbackp;
++	m->h.blanks = mode->htotal - hfrontp - 1;
+ 
 -static void
 -nv50_wndw_destroy(struct drm_plane *plane)
 -{
 -	struct nv50_wndw *wndw = nv50_wndw(plane);
 -	void *data;
 -	nvif_notify_fini(&wndw->notify);
 -	data = wndw->func->dtor(wndw);
 -	drm_plane_cleanup(&wndw->plane);
 -	kfree(data);
 -}
++	m->v.active = mode->vtotal * vscan / ilace;
++	m->v.synce  = ((mode->vsync_end - mode->vsync_start) * vscan / ilace) - 1;
++	m->v.blanke = m->v.synce + vbackp;
++	m->v.blanks = m->v.active - vfrontp - 1;
+ 
 -static const struct drm_plane_funcs
 -nv50_wndw = {
 -	.update_plane = drm_atomic_helper_update_plane,
 -	.disable_plane = drm_atomic_helper_disable_plane,
 -	.destroy = nv50_wndw_destroy,
 -	.reset = nv50_wndw_reset,
 -	.set_property = drm_atomic_helper_plane_set_property,
 -	.atomic_duplicate_state = nv50_wndw_atomic_duplicate_state,
 -	.atomic_destroy_state = nv50_wndw_atomic_destroy_state,
 -};
++	/*XXX: Safe underestimate, even "0" works */
++	blankus = (m->v.active - mode->vdisplay - 2) * m->h.active;
++	blankus *= 1000;
++	blankus /= mode->clock;
++	m->v.blankus = blankus;
+ 
 -static void
 -nv50_wndw_fini(struct nv50_wndw *wndw)
 -{
 -	nvif_notify_put(&wndw->notify);
 -}
++	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
++		m->v.blank2e =  m->v.active + m->v.synce + vbackp;
++		m->v.blank2s =  m->v.blank2e + (mode->vdisplay * vscan / ilace);
++		m->v.active  = (m->v.active * 2) + 1;
++		m->interlace = true;
++	} else {
++		m->v.blank2e = 0;
++		m->v.blank2s = 1;
++		m->interlace = false;
++>>>>>>> d639fbcc1027 (drm/nouveau/kms/nv50: fix setting of HeadSetRasterVertBlankDmi method)
 +	}
  
 -static void
 -nv50_wndw_init(struct nv50_wndw *wndw)
 -{
 -	nvif_notify_get(&wndw->notify);
 +	return 0;
  }
  
  static int
* Unmerged path drivers/gpu/drm/nouveau/nv50_display.c
