get rid of propagate_umount() mistakenly treating slaves as busy.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] get rid of propagate_umount() mistakenly treating slaves as busy ("Eric W. Biederman") [1247935]
Rebuild_FUZZ: 99.22%
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit 88b368f27a094277143d8ecd5a056116f6a41520
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/88b368f2.failed

The check in __propagate_umount() ("has somebody explicitly mounted
something on that slave?") is done *before* taking the already doomed
victims out of the child lists.

	Cc: stable@vger.kernel.org
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 88b368f27a094277143d8ecd5a056116f6a41520)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namespace.c
#	fs/pnode.c
diff --cc fs/namespace.c
index a82db7875df0,3273177873f0..000000000000
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@@ -1167,26 -1236,36 +1167,38 @@@ static inline void namespace_lock(void
  }
  
  /*
 - * mount_lock must be held
 + * vfsmount lock must be held for write
   * namespace_sem must be held for write
 - * how = 0 => just this tree, don't propagate
 - * how = 1 => propagate; we know that nobody else has reference to any victims
 - * how = 2 => lazy umount
   */
 -void umount_tree(struct mount *mnt, int how)
 +void umount_tree(struct mount *mnt, int propagate)
  {
 -	HLIST_HEAD(tmp_list);
 +	LIST_HEAD(tmp_list);
  	struct mount *p;
 -	struct mount *last = NULL;
  
 -	for (p = mnt; p; p = next_mnt(p, mnt)) {
 -		hlist_del_init_rcu(&p->mnt_hash);
 -		hlist_add_head(&p->mnt_hash, &tmp_list);
 -	}
 +	for (p = mnt; p; p = next_mnt(p, mnt))
 +		list_move(&p->mnt_hash, &tmp_list);
  
++<<<<<<< HEAD
 +	if (propagate)
++=======
+ 	hlist_for_each_entry(p, &tmp_list, mnt_hash)
+ 		list_del_init(&p->mnt_child);
+ 
+ 	if (how)
++>>>>>>> 88b368f27a09 (get rid of propagate_umount() mistakenly treating slaves as busy.)
  		propagate_umount(&tmp_list);
  
 -	hlist_for_each_entry(p, &tmp_list, mnt_hash) {
 +	list_for_each_entry(p, &tmp_list, mnt_hash) {
  		list_del_init(&p->mnt_expire);
  		list_del_init(&p->mnt_list);
  		__touch_mnt_namespace(p->mnt_ns);
  		p->mnt_ns = NULL;
++<<<<<<< HEAD
 +		list_del_init(&p->mnt_child);
++=======
+ 		if (how < 2)
+ 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
++>>>>>>> 88b368f27a09 (get rid of propagate_umount() mistakenly treating slaves as busy.)
  		if (mnt_has_parent(p)) {
  			put_mountpoint(p->mnt_mp);
  			/* move the reference to mountpoint into ->mnt_ex_mountpoint */
diff --cc fs/pnode.c
index 4cba0cce1f85,aae331a5d03b..000000000000
--- a/fs/pnode.c
+++ b/fs/pnode.c
@@@ -389,8 -380,11 +389,16 @@@ static void __propagate_umount(struct m
  		 * umount the child only if the child has no
  		 * other children
  		 */
++<<<<<<< HEAD
 +		if (child && list_empty(&child->mnt_mounts))
 +			list_move_tail(&child->mnt_hash, &mnt->mnt_hash);
++=======
+ 		if (child && list_empty(&child->mnt_mounts)) {
+ 			list_del_init(&child->mnt_child);
+ 			hlist_del_init_rcu(&child->mnt_hash);
+ 			hlist_add_before_rcu(&child->mnt_hash, &mnt->mnt_hash);
+ 		}
++>>>>>>> 88b368f27a09 (get rid of propagate_umount() mistakenly treating slaves as busy.)
  	}
  }
  
* Unmerged path fs/namespace.c
* Unmerged path fs/pnode.c
