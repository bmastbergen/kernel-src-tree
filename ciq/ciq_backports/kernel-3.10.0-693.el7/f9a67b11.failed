md/bitmap: clear bitmap if bitmap_create failed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [md] bitmap: clear bitmap if bitmap_create failed (Jes Sorensen) [1380016]
Rebuild_FUZZ: 96.70%
commit-author Guoqing Jiang <gqjiang@suse.com>
commit f9a67b1182e5abfcfcec24762ea95a77332f035e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f9a67b11.failed

If bitmap_create returns an error, we need to call
either bitmap_destroy or bitmap_free to do clean up,
and the selection is based on mddev->bitmap is set
or not.

And the sysfs_put(bitmap->sysfs_can_clear) is moved
from bitmap_destroy to bitmap_free, and the comment
of bitmap_create is changed as well.

	Signed-off-by: Guoqing Jiang <gqjiang@suse.com>
	Signed-off-by: Shaohua Li <shli@fb.com>
(cherry picked from commit f9a67b1182e5abfcfcec24762ea95a77332f035e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/bitmap.c
diff --cc drivers/md/bitmap.c
index 5d638c495205,2a0362fc2107..000000000000
--- a/drivers/md/bitmap.c
+++ b/drivers/md/bitmap.c
@@@ -1581,6 -1673,13 +1581,16 @@@ static void bitmap_free(struct bitmap *
  	if (!bitmap) /* there was no bitmap */
  		return;
  
++<<<<<<< HEAD
++=======
+ 	if (bitmap->sysfs_can_clear)
+ 		sysfs_put(bitmap->sysfs_can_clear);
+ 
+ 	if (mddev_is_clustered(bitmap->mddev) && bitmap->mddev->cluster_info &&
+ 		bitmap->cluster_slot == md_cluster_ops->slot_number(bitmap->mddev))
+ 		md_cluster_stop(bitmap->mddev);
+ 
++>>>>>>> f9a67b1182e5 (md/bitmap: clear bitmap if bitmap_create failed)
  	/* Shouldn't be needed - but just in case.... */
  	wait_event(bitmap->write_wait,
  		   atomic_read(&bitmap->pending_writes) == 0);
@@@ -1625,8 -1721,9 +1632,9 @@@ void bitmap_destroy(struct mddev *mddev
  /*
   * initialize the bitmap structure
   * if this returns an error, bitmap_destroy must be called to do clean up
+  * once mddev->bitmap is set
   */
 -struct bitmap *bitmap_create(struct mddev *mddev, int slot)
 +int bitmap_create(struct mddev *mddev)
  {
  	struct bitmap *bitmap;
  	sector_t blocks = mddev->resync_max_sectors;
@@@ -1755,6 -1855,58 +1763,61 @@@ out
  }
  EXPORT_SYMBOL_GPL(bitmap_load);
  
++<<<<<<< HEAD
++=======
+ /* Loads the bitmap associated with slot and copies the resync information
+  * to our bitmap
+  */
+ int bitmap_copy_from_slot(struct mddev *mddev, int slot,
+ 		sector_t *low, sector_t *high, bool clear_bits)
+ {
+ 	int rv = 0, i, j;
+ 	sector_t block, lo = 0, hi = 0;
+ 	struct bitmap_counts *counts;
+ 	struct bitmap *bitmap = bitmap_create(mddev, slot);
+ 
+ 	if (IS_ERR(bitmap)) {
+ 		bitmap_free(bitmap);
+ 		return PTR_ERR(bitmap);
+ 	}
+ 
+ 	rv = bitmap_init_from_disk(bitmap, 0);
+ 	if (rv)
+ 		goto err;
+ 
+ 	counts = &bitmap->counts;
+ 	for (j = 0; j < counts->chunks; j++) {
+ 		block = (sector_t)j << counts->chunkshift;
+ 		if (bitmap_file_test_bit(bitmap, block)) {
+ 			if (!lo)
+ 				lo = block;
+ 			hi = block;
+ 			bitmap_file_clear_bit(bitmap, block);
+ 			bitmap_set_memory_bits(mddev->bitmap, block, 1);
+ 			bitmap_file_set_bit(mddev->bitmap, block);
+ 		}
+ 	}
+ 
+ 	if (clear_bits) {
+ 		bitmap_update_sb(bitmap);
+ 		/* Setting this for the ev_page should be enough.
+ 		 * And we do not require both write_all and PAGE_DIRT either
+ 		 */
+ 		for (i = 0; i < bitmap->storage.file_pages; i++)
+ 			set_page_attr(bitmap, i, BITMAP_PAGE_DIRTY);
+ 		bitmap_write_all(bitmap);
+ 		bitmap_unplug(bitmap);
+ 	}
+ 	*low = lo;
+ 	*high = hi;
+ err:
+ 	bitmap_free(bitmap);
+ 	return rv;
+ }
+ EXPORT_SYMBOL_GPL(bitmap_copy_from_slot);
+ 
+ 
++>>>>>>> f9a67b1182e5 (md/bitmap: clear bitmap if bitmap_create failed)
  void bitmap_status(struct seq_file *seq, struct bitmap *bitmap)
  {
  	unsigned long chunk_kb;
@@@ -2011,17 -2165,22 +2074,24 @@@ location_store(struct mddev *mddev, con
  				return -EINVAL;
  			mddev->bitmap_info.offset = offset;
  			if (mddev->pers) {
 -				struct bitmap *bitmap;
  				mddev->pers->quiesce(mddev, 1);
 -				bitmap = bitmap_create(mddev, -1);
 -				if (IS_ERR(bitmap))
 -					rv = PTR_ERR(bitmap);
 -				else {
 -					mddev->bitmap = bitmap;
 +				rv = bitmap_create(mddev);
 +				if (!rv)
  					rv = bitmap_load(mddev);
++<<<<<<< HEAD
 +				if (rv) {
 +					bitmap_destroy(mddev);
 +					mddev->bitmap_info.offset = 0;
++=======
+ 					if (rv)
+ 						mddev->bitmap_info.offset = 0;
++>>>>>>> f9a67b1182e5 (md/bitmap: clear bitmap if bitmap_create failed)
  				}
  				mddev->pers->quiesce(mddev, 0);
- 				if (rv)
+ 				if (rv) {
+ 					bitmap_destroy(mddev);
  					return rv;
+ 				}
  			}
  		}
  	}
* Unmerged path drivers/md/bitmap.c
