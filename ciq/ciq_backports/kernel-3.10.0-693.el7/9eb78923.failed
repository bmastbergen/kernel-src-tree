net/mlx5: Change ENOTSUPP to EOPNOTSUPP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [netdrv] mlx5: Change ENOTSUPP to EOPNOTSUPP (Don Dutile) [1385330 1417286]
Rebuild_FUZZ: 94.59%
commit-author Or Gerlitz <ogerlitz@mellanox.com>
commit 9eb7892351a3a3b403d879b41c4e6efb2c96516f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/9eb78923.failed

As ENOTSUPP is specific to NFS, change the return error value to
EOPNOTSUPP in various places in the mlx5 driver.

	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Suggested-by: Yotam Gigi <yotamg@mellanox.com>
	Reviewed-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 9eb7892351a3a3b403d879b41c4e6efb2c96516f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index e0b0c17e5832,1619147a63e8..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -643,6 -850,33 +643,36 @@@ extern const struct ethtool_ops mlx5e_e
  #ifdef CONFIG_MLX5_CORE_EN_DCB
  extern const struct dcbnl_rtnl_ops mlx5e_dcbnl_ops;
  int mlx5e_dcbnl_ieee_setets_core(struct mlx5e_priv *priv, struct ieee_ets *ets);
++<<<<<<< HEAD
++=======
+ void mlx5e_dcbnl_initialize(struct mlx5e_priv *priv);
+ #endif
+ 
+ #ifndef CONFIG_RFS_ACCEL
+ static inline int mlx5e_arfs_create_tables(struct mlx5e_priv *priv)
+ {
+ 	return 0;
+ }
+ 
+ static inline void mlx5e_arfs_destroy_tables(struct mlx5e_priv *priv) {}
+ 
+ static inline int mlx5e_arfs_enable(struct mlx5e_priv *priv)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int mlx5e_arfs_disable(struct mlx5e_priv *priv)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ #else
+ int mlx5e_arfs_create_tables(struct mlx5e_priv *priv);
+ void mlx5e_arfs_destroy_tables(struct mlx5e_priv *priv);
+ int mlx5e_arfs_enable(struct mlx5e_priv *priv);
+ int mlx5e_arfs_disable(struct mlx5e_priv *priv);
+ int mlx5e_rx_flow_steer(struct net_device *dev, const struct sk_buff *skb,
+ 			u16 rxq_index, u32 flow_id);
++>>>>>>> 9eb7892351a3 (net/mlx5: Change ENOTSUPP to EOPNOTSUPP)
  #endif
  
  u16 mlx5e_get_max_inline_cap(struct mlx5_core_dev *mdev);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
index 762af16ed021,35f9ae037ba0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
@@@ -42,12 -84,31 +42,12 @@@ static int mlx5e_dcbnl_ieee_getets(stru
  				   struct ieee_ets *ets)
  {
  	struct mlx5e_priv *priv = netdev_priv(netdev);
 -	struct mlx5_core_dev *mdev = priv->mdev;
 -	int err = 0;
 -	int i;
  
  	if (!MLX5_CAP_GEN(priv->mdev, ets))
- 		return -ENOTSUPP;
+ 		return -EOPNOTSUPP;
  
 -	ets->ets_cap = mlx5_max_tc(priv->mdev) + 1;
 -	for (i = 0; i < ets->ets_cap; i++) {
 -		err = mlx5_query_port_prio_tc(mdev, i, &ets->prio_tc[i]);
 -		if (err)
 -			return err;
 -	}
 -
 -	for (i = 0; i < ets->ets_cap; i++) {
 -		err = mlx5_query_port_tc_bw_alloc(mdev, i, &ets->tc_tx_bw[i]);
 -		if (err)
 -			return err;
 -		if (ets->tc_tx_bw[i] < MLX5E_MAX_BW_ALLOC)
 -			priv->dcbx.tc_tsa[i] = IEEE_8021QAZ_TSA_ETS;
 -	}
 -
 -	memcpy(ets->tc_tsa, priv->dcbx.tc_tsa, sizeof(ets->tc_tsa));
 -
 -	return err;
 +	memcpy(ets, &priv->params.ets, sizeof(*ets));
 +	return 0;
  }
  
  enum {
@@@ -170,6 -235,9 +170,12 @@@ static int mlx5e_dcbnl_ieee_setets(stru
  	struct mlx5e_priv *priv = netdev_priv(netdev);
  	int err;
  
++<<<<<<< HEAD
++=======
+ 	if (!MLX5_CAP_GEN(priv->mdev, ets))
+ 		return -EOPNOTSUPP;
+ 
++>>>>>>> 9eb7892351a3 (net/mlx5: Change ENOTSUPP to EOPNOTSUPP)
  	err = mlx5e_dbcnl_validate_ets(netdev, ets);
  	if (err)
  		return err;
@@@ -304,6 -395,284 +310,287 @@@ static int mlx5e_dcbnl_ieee_setmaxrate(
  	return mlx5_modify_port_ets_rate_limit(mdev, max_bw_value, max_bw_unit);
  }
  
++<<<<<<< HEAD
++=======
+ static u8 mlx5e_dcbnl_setall(struct net_device *netdev)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	struct ieee_ets ets;
+ 	struct ieee_pfc pfc;
+ 	int err = -EOPNOTSUPP;
+ 	int i;
+ 
+ 	if (!MLX5_CAP_GEN(mdev, ets))
+ 		goto out;
+ 
+ 	memset(&ets, 0, sizeof(ets));
+ 	memset(&pfc, 0, sizeof(pfc));
+ 
+ 	ets.ets_cap = IEEE_8021QAZ_MAX_TCS;
+ 	for (i = 0; i < CEE_DCBX_MAX_PGS; i++) {
+ 		ets.tc_tx_bw[i] = cee_cfg->pg_bw_pct[i];
+ 		ets.tc_rx_bw[i] = cee_cfg->pg_bw_pct[i];
+ 		ets.tc_tsa[i]   = IEEE_8021QAZ_TSA_ETS;
+ 		ets.prio_tc[i]  = cee_cfg->prio_to_pg_map[i];
+ 	}
+ 
+ 	err = mlx5e_dbcnl_validate_ets(netdev, &ets);
+ 	if (err) {
+ 		netdev_err(netdev,
+ 			   "%s, Failed to validate ETS: %d\n", __func__, err);
+ 		goto out;
+ 	}
+ 
+ 	err = mlx5e_dcbnl_ieee_setets_core(priv, &ets);
+ 	if (err) {
+ 		netdev_err(netdev,
+ 			   "%s, Failed to set ETS: %d\n", __func__, err);
+ 		goto out;
+ 	}
+ 
+ 	/* Set PFC */
+ 	pfc.pfc_cap = mlx5_max_tc(mdev) + 1;
+ 	if (!cee_cfg->pfc_enable)
+ 		pfc.pfc_en = 0;
+ 	else
+ 		for (i = 0; i < CEE_DCBX_MAX_PRIO; i++)
+ 			pfc.pfc_en |= cee_cfg->pfc_setting[i] << i;
+ 
+ 	err = mlx5e_dcbnl_ieee_setpfc(netdev, &pfc);
+ 	if (err) {
+ 		netdev_err(netdev,
+ 			   "%s, Failed to set PFC: %d\n", __func__, err);
+ 		goto out;
+ 	}
+ out:
+ 	return err ? MLX5_DCB_NO_CHG : MLX5_DCB_CHG_RESET;
+ }
+ 
+ static u8 mlx5e_dcbnl_getstate(struct net_device *netdev)
+ {
+ 	return MLX5E_CEE_STATE_UP;
+ }
+ 
+ static void mlx5e_dcbnl_getpermhwaddr(struct net_device *netdev,
+ 				      u8 *perm_addr)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 
+ 	if (!perm_addr)
+ 		return;
+ 
+ 	mlx5_query_nic_vport_mac_address(priv->mdev, 0, perm_addr);
+ }
+ 
+ static void mlx5e_dcbnl_setpgtccfgtx(struct net_device *netdev,
+ 				     int priority, u8 prio_type,
+ 				     u8 pgid, u8 bw_pct, u8 up_map)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;
+ 
+ 	if (priority >= CEE_DCBX_MAX_PRIO) {
+ 		netdev_err(netdev,
+ 			   "%s, priority is out of range\n", __func__);
+ 		return;
+ 	}
+ 
+ 	if (pgid >= CEE_DCBX_MAX_PGS) {
+ 		netdev_err(netdev,
+ 			   "%s, priority group is out of range\n", __func__);
+ 		return;
+ 	}
+ 
+ 	cee_cfg->prio_to_pg_map[priority] = pgid;
+ }
+ 
+ static void mlx5e_dcbnl_setpgbwgcfgtx(struct net_device *netdev,
+ 				      int pgid, u8 bw_pct)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;
+ 
+ 	if (pgid >= CEE_DCBX_MAX_PGS) {
+ 		netdev_err(netdev,
+ 			   "%s, priority group is out of range\n", __func__);
+ 		return;
+ 	}
+ 
+ 	cee_cfg->pg_bw_pct[pgid] = bw_pct;
+ }
+ 
+ static void mlx5e_dcbnl_getpgtccfgtx(struct net_device *netdev,
+ 				     int priority, u8 *prio_type,
+ 				     u8 *pgid, u8 *bw_pct, u8 *up_map)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 
+ 	if (priority >= CEE_DCBX_MAX_PRIO) {
+ 		netdev_err(netdev,
+ 			   "%s, priority is out of range\n", __func__);
+ 		return;
+ 	}
+ 
+ 	*prio_type = 0;
+ 	*bw_pct = 0;
+ 	*up_map = 0;
+ 
+ 	if (mlx5_query_port_prio_tc(mdev, priority, pgid))
+ 		*pgid = 0;
+ }
+ 
+ static void mlx5e_dcbnl_getpgbwgcfgtx(struct net_device *netdev,
+ 				      int pgid, u8 *bw_pct)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 
+ 	if (pgid >= CEE_DCBX_MAX_PGS) {
+ 		netdev_err(netdev,
+ 			   "%s, priority group is out of range\n", __func__);
+ 		return;
+ 	}
+ 
+ 	if (mlx5_query_port_tc_bw_alloc(mdev, pgid, bw_pct))
+ 		*bw_pct = 0;
+ }
+ 
+ static void mlx5e_dcbnl_setpfccfg(struct net_device *netdev,
+ 				  int priority, u8 setting)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;
+ 
+ 	if (priority >= CEE_DCBX_MAX_PRIO) {
+ 		netdev_err(netdev,
+ 			   "%s, priority is out of range\n", __func__);
+ 		return;
+ 	}
+ 
+ 	if (setting > 1)
+ 		return;
+ 
+ 	cee_cfg->pfc_setting[priority] = setting;
+ }
+ 
+ static int
+ mlx5e_dcbnl_get_priority_pfc(struct net_device *netdev,
+ 			     int priority, u8 *setting)
+ {
+ 	struct ieee_pfc pfc;
+ 	int err;
+ 
+ 	err = mlx5e_dcbnl_ieee_getpfc(netdev, &pfc);
+ 
+ 	if (err)
+ 		*setting = 0;
+ 	else
+ 		*setting = (pfc.pfc_en >> priority) & 0x01;
+ 
+ 	return err;
+ }
+ 
+ static void mlx5e_dcbnl_getpfccfg(struct net_device *netdev,
+ 				  int priority, u8 *setting)
+ {
+ 	if (priority >= CEE_DCBX_MAX_PRIO) {
+ 		netdev_err(netdev,
+ 			   "%s, priority is out of range\n", __func__);
+ 		return;
+ 	}
+ 
+ 	if (!setting)
+ 		return;
+ 
+ 	mlx5e_dcbnl_get_priority_pfc(netdev, priority, setting);
+ }
+ 
+ static u8 mlx5e_dcbnl_getcap(struct net_device *netdev,
+ 			     int capid, u8 *cap)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	u8 rval = 0;
+ 
+ 	switch (capid) {
+ 	case DCB_CAP_ATTR_PG:
+ 		*cap = true;
+ 		break;
+ 	case DCB_CAP_ATTR_PFC:
+ 		*cap = true;
+ 		break;
+ 	case DCB_CAP_ATTR_UP2TC:
+ 		*cap = false;
+ 		break;
+ 	case DCB_CAP_ATTR_PG_TCS:
+ 		*cap = 1 << mlx5_max_tc(mdev);
+ 		break;
+ 	case DCB_CAP_ATTR_PFC_TCS:
+ 		*cap = 1 << mlx5_max_tc(mdev);
+ 		break;
+ 	case DCB_CAP_ATTR_GSP:
+ 		*cap = false;
+ 		break;
+ 	case DCB_CAP_ATTR_BCN:
+ 		*cap = false;
+ 		break;
+ 	case DCB_CAP_ATTR_DCBX:
+ 		*cap = (DCB_CAP_DCBX_LLD_MANAGED |
+ 			DCB_CAP_DCBX_VER_CEE |
+ 			DCB_CAP_DCBX_STATIC);
+ 		break;
+ 	default:
+ 		*cap = 0;
+ 		rval = 1;
+ 		break;
+ 	}
+ 
+ 	return rval;
+ }
+ 
+ static int mlx5e_dcbnl_getnumtcs(struct net_device *netdev,
+ 				 int tcs_id, u8 *num)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 
+ 	switch (tcs_id) {
+ 	case DCB_NUMTCS_ATTR_PG:
+ 	case DCB_NUMTCS_ATTR_PFC:
+ 		*num = mlx5_max_tc(mdev) + 1;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u8 mlx5e_dcbnl_getpfcstate(struct net_device *netdev)
+ {
+ 	struct ieee_pfc pfc;
+ 
+ 	if (mlx5e_dcbnl_ieee_getpfc(netdev, &pfc))
+ 		return MLX5E_CEE_STATE_DOWN;
+ 
+ 	return pfc.pfc_en ? MLX5E_CEE_STATE_UP : MLX5E_CEE_STATE_DOWN;
+ }
+ 
+ static void mlx5e_dcbnl_setpfcstate(struct net_device *netdev, u8 state)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;
+ 
+ 	if ((state != MLX5E_CEE_STATE_UP) && (state != MLX5E_CEE_STATE_DOWN))
+ 		return;
+ 
+ 	cee_cfg->pfc_enable = state;
+ }
+ 
++>>>>>>> 9eb7892351a3 (net/mlx5: Change ENOTSUPP to EOPNOTSUPP)
  const struct dcbnl_rtnl_ops mlx5e_dcbnl_ops = {
  	.ieee_getets	= mlx5e_dcbnl_ieee_getets,
  	.ieee_setets	= mlx5e_dcbnl_ieee_setets,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
index 551175eb7f52,ffbdf9ee5a9b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
@@@ -1334,6 -1443,35 +1334,38 @@@ static int set_pflag_rx_cqe_based_moder
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int set_pflag_rx_cqe_compress(struct net_device *netdev,
+ 				     bool enable)
+ {
+ 	struct mlx5e_priv *priv = netdev_priv(netdev);
+ 	struct mlx5_core_dev *mdev = priv->mdev;
+ 	int err = 0;
+ 	bool reset;
+ 
+ 	if (!MLX5_CAP_GEN(mdev, cqe_compression))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (enable && priv->tstamp.hwtstamp_config.rx_filter != HWTSTAMP_FILTER_NONE) {
+ 		netdev_err(netdev, "Can't enable cqe compression while timestamping is enabled.\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	reset = test_bit(MLX5E_STATE_OPENED, &priv->state);
+ 
+ 	if (reset)
+ 		mlx5e_close_locked(netdev);
+ 
+ 	MLX5E_SET_PFLAG(priv, MLX5E_PFLAG_RX_CQE_COMPRESS, enable);
+ 	priv->params.rx_cqe_compress_def = enable;
+ 
+ 	if (reset)
+ 		err = mlx5e_open_locked(netdev);
+ 	return err;
+ }
+ 
++>>>>>>> 9eb7892351a3 (net/mlx5: Change ENOTSUPP to EOPNOTSUPP)
  static int mlx5e_handle_pflag(struct net_device *netdev,
  			      u32 wanted_flags,
  			      enum mlx5e_priv_flag flag,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
index b4907f71debf..e383a4fd2c9f 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c
@@ -1613,7 +1613,7 @@ int mlx5_cmd_init(struct mlx5_core_dev *dev)
 	if (cmd->cmdif_rev > CMD_IF_REV) {
 		dev_err(&dev->pdev->dev, "driver does not support command interface version. driver %d, firmware %d\n",
 			CMD_IF_REV, cmd->cmdif_rev);
-		err = -ENOTSUPP;
+		err = -EOPNOTSUPP;
 		goto err_free_page;
 	}
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_fs_ethtool.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 2aca61ab5499..c43519d50b85 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -2617,7 +2617,7 @@ static const struct net_device_ops mlx5e_netdev_ops_sriov = {
 static int mlx5e_check_required_hca_cap(struct mlx5_core_dev *mdev)
 {
 	if (MLX5_CAP_GEN(mdev, port_type) != MLX5_CAP_PORT_TYPE_ETH)
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;
 	if (!MLX5_CAP_GEN(mdev, eth_net_offloads) ||
 	    !MLX5_CAP_GEN(mdev, nic_flow_table) ||
 	    !MLX5_CAP_ETH(mdev, csum_cap) ||
@@ -2629,7 +2629,7 @@ static int mlx5e_check_required_hca_cap(struct mlx5_core_dev *mdev)
 			       < 3) {
 		mlx5_core_warn(mdev,
 			       "Not creating net device, some required device capabilities are missing\n");
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;
 	}
 	if (!MLX5_CAP_GEN(mdev, cq_moderation))
 		mlx5_core_warn(mdev, "CQ modiration is not supported\n");
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 6c7352099dd6..3b0d8a76a114 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -161,7 +161,7 @@ static int query_esw_vport_cvlan(struct mlx5_core_dev *dev, u32 vport,
 
 	if (!MLX5_CAP_ESW(dev, vport_cvlan_strip) ||
 	    !MLX5_CAP_ESW(dev, vport_cvlan_insert_if_not_exist))
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;
 
 	err = query_esw_vport_context_cmd(dev, vport, out, sizeof(out));
 	if (err)
@@ -1252,7 +1252,7 @@ int mlx5_eswitch_enable_sriov(struct mlx5_eswitch *esw, int nvfs)
 	if (!MLX5_CAP_GEN(esw->dev, eswitch_flow_table) ||
 	    !MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, ft_support)) {
 		esw_warn(esw->dev, "E-Switch FDB is not supported, aborting ...\n");
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;
 	}
 
 	if (!MLX5_CAP_ESW_INGRESS_ACL(esw->dev, ft_support))
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
index 9255fb6f5d9d..23f32d098738 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
@@ -262,7 +262,7 @@ int mlx5_cmd_update_fte(struct mlx5_core_dev *dev,
 						flow_table_properties_nic_receive.
 						flow_modify_en);
 	if (!atomic_mod_cap)
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;
 	opmod = 1;
 	modify_mask = 1 <<
 		MLX5_SET_FTE_MODIFY_ENABLE_MASK_DESTINATION_LIST;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c
index 6ca5c910701a..ee9e8d990966 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c
@@ -845,7 +845,7 @@ static int mlx5_core_set_issi(struct mlx5_core_dev *dev)
 		return 0;
 	}
 
-	return -ENOTSUPP;
+	return -EOPNOTSUPP;
 }
 
 static void mlx5_add_device(struct mlx5_interface *intf, struct mlx5_priv *priv)
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/port.c b/drivers/net/ethernet/mellanox/mlx5/core/port.c
index 96224f6777b6..25afd75ee6e4 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/port.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/port.c
@@ -628,7 +628,7 @@ static int mlx5_set_port_qetcr_reg(struct mlx5_core_dev *mdev, u32 *in,
 	u32 out[MLX5_ST_SZ_DW(qtct_reg)];
 
 	if (!MLX5_CAP_GEN(mdev, ets))
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;
 
 	return mlx5_core_access_reg(mdev, in, inlen, out, sizeof(out),
 				    MLX5_REG_QETCR, 0, 1);
@@ -640,7 +640,7 @@ static int mlx5_query_port_qetcr_reg(struct mlx5_core_dev *mdev, u32 *out,
 	u32 in[MLX5_ST_SZ_DW(qtct_reg)];
 
 	if (!MLX5_CAP_GEN(mdev, ets))
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;
 
 	memset(in, 0, sizeof(in));
 	return mlx5_core_access_reg(mdev, in, sizeof(in), out, outlen,
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/vport.c b/drivers/net/ethernet/mellanox/mlx5/core/vport.c
index 4908639947c4..a9fe44ca29fb 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/vport.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/vport.c
@@ -524,7 +524,7 @@ int mlx5_modify_nic_vport_node_guid(struct mlx5_core_dev *mdev,
 	if (!MLX5_CAP_GEN(mdev, vport_group_manager))
 		return -EACCES;
 	if (!MLX5_CAP_ESW(mdev, nic_vport_node_guid_modify))
-		return -ENOTSUPP;
+		return -EOPNOTSUPP;
 
 	in = mlx5_vzalloc(inlen);
 	if (!in)
