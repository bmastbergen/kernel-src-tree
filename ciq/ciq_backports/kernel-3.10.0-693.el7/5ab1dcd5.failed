amd-xgbe: Add I2C support for sideband communication

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Lendacky, Thomas <Thomas.Lendacky@amd.com>
commit 5ab1dcd58597c04f6d50980c3d5f3c2518301b31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5ab1dcd5.failed

Add support to initialize and use the I2C controller within the hardware
in order to perform sideband communication, e.g. determine the SFP media
type that is installed.

	Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5ab1dcd58597c04f6d50980c3d5f3c2518301b31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amd/xgbe/Makefile
#	drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c
#	drivers/net/ethernet/amd/xgbe/xgbe-main.c
#	drivers/net/ethernet/amd/xgbe/xgbe-pci.c
#	drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
#	drivers/net/ethernet/amd/xgbe/xgbe.h
diff --cc drivers/net/ethernet/amd/xgbe/Makefile
index 26cf9af1642f,0dea8f5da899..000000000000
--- a/drivers/net/ethernet/amd/xgbe/Makefile
+++ b/drivers/net/ethernet/amd/xgbe/Makefile
@@@ -1,6 -1,11 +1,13 @@@
  obj-$(CONFIG_AMD_XGBE) += amd-xgbe.o
  
  amd-xgbe-objs := xgbe-main.o xgbe-drv.o xgbe-dev.o \
++<<<<<<< HEAD
 +		 xgbe-desc.o xgbe-ethtool.o xgbe-mdio.o
++=======
+ 		 xgbe-desc.o xgbe-ethtool.o xgbe-mdio.o \
+ 		 xgbe-ptp.o \
+ 		 xgbe-i2c.o xgbe-phy-v1.o xgbe-phy-v2.o \
+ 		 xgbe-platform.o
++>>>>>>> 5ab1dcd58597 (amd-xgbe: Add I2C support for sideband communication)
  
 -amd-xgbe-$(CONFIG_PCI) += xgbe-pci.o
 -amd-xgbe-$(CONFIG_AMD_XGBE_DCB) += xgbe-dcb.o
  amd-xgbe-$(CONFIG_DEBUG_FS) += xgbe-debugfs.o
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c
index 5d2904a2cee6,0c0140decbc2..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c
@@@ -317,6 -316,126 +317,129 @@@ static const struct file_operations xpc
  	.write = xpcs_reg_value_write,
  };
  
++<<<<<<< HEAD
++=======
+ static ssize_t xprop_reg_addr_read(struct file *filp, char __user *buffer,
+ 				   size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 
+ 	return xgbe_common_read(buffer, count, ppos, pdata->debugfs_xprop_reg);
+ }
+ 
+ static ssize_t xprop_reg_addr_write(struct file *filp,
+ 				    const char __user *buffer,
+ 				    size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 
+ 	return xgbe_common_write(buffer, count, ppos,
+ 				 &pdata->debugfs_xprop_reg);
+ }
+ 
+ static ssize_t xprop_reg_value_read(struct file *filp, char __user *buffer,
+ 				    size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 	unsigned int value;
+ 
+ 	value = XP_IOREAD(pdata, pdata->debugfs_xprop_reg);
+ 
+ 	return xgbe_common_read(buffer, count, ppos, value);
+ }
+ 
+ static ssize_t xprop_reg_value_write(struct file *filp,
+ 				     const char __user *buffer,
+ 				     size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 	unsigned int value;
+ 	ssize_t len;
+ 
+ 	len = xgbe_common_write(buffer, count, ppos, &value);
+ 	if (len < 0)
+ 		return len;
+ 
+ 	XP_IOWRITE(pdata, pdata->debugfs_xprop_reg, value);
+ 
+ 	return len;
+ }
+ 
+ static const struct file_operations xprop_reg_addr_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = simple_open,
+ 	.read =  xprop_reg_addr_read,
+ 	.write = xprop_reg_addr_write,
+ };
+ 
+ static const struct file_operations xprop_reg_value_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = simple_open,
+ 	.read =  xprop_reg_value_read,
+ 	.write = xprop_reg_value_write,
+ };
+ 
+ static ssize_t xi2c_reg_addr_read(struct file *filp, char __user *buffer,
+ 				  size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 
+ 	return xgbe_common_read(buffer, count, ppos, pdata->debugfs_xi2c_reg);
+ }
+ 
+ static ssize_t xi2c_reg_addr_write(struct file *filp,
+ 				   const char __user *buffer,
+ 				   size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 
+ 	return xgbe_common_write(buffer, count, ppos,
+ 				 &pdata->debugfs_xi2c_reg);
+ }
+ 
+ static ssize_t xi2c_reg_value_read(struct file *filp, char __user *buffer,
+ 				   size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 	unsigned int value;
+ 
+ 	value = XI2C_IOREAD(pdata, pdata->debugfs_xi2c_reg);
+ 
+ 	return xgbe_common_read(buffer, count, ppos, value);
+ }
+ 
+ static ssize_t xi2c_reg_value_write(struct file *filp,
+ 				    const char __user *buffer,
+ 				    size_t count, loff_t *ppos)
+ {
+ 	struct xgbe_prv_data *pdata = filp->private_data;
+ 	unsigned int value;
+ 	ssize_t len;
+ 
+ 	len = xgbe_common_write(buffer, count, ppos, &value);
+ 	if (len < 0)
+ 		return len;
+ 
+ 	XI2C_IOWRITE(pdata, pdata->debugfs_xi2c_reg, value);
+ 
+ 	return len;
+ }
+ 
+ static const struct file_operations xi2c_reg_addr_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = simple_open,
+ 	.read =  xi2c_reg_addr_read,
+ 	.write = xi2c_reg_addr_write,
+ };
+ 
+ static const struct file_operations xi2c_reg_value_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = simple_open,
+ 	.read =  xi2c_reg_value_read,
+ 	.write = xi2c_reg_value_write,
+ };
+ 
++>>>>>>> 5ab1dcd58597 (amd-xgbe: Add I2C support for sideband communication)
  void xgbe_debugfs_init(struct xgbe_prv_data *pdata)
  {
  	struct dentry *pfile;
@@@ -368,6 -487,38 +491,41 @@@
  	if (!pfile)
  		netdev_err(pdata->netdev, "debugfs_create_file failed\n");
  
++<<<<<<< HEAD
++=======
+ 	if (pdata->xprop_regs) {
+ 		pfile = debugfs_create_file("xprop_register", 0600,
+ 					    pdata->xgbe_debugfs, pdata,
+ 					    &xprop_reg_addr_fops);
+ 		if (!pfile)
+ 			netdev_err(pdata->netdev,
+ 				   "debugfs_create_file failed\n");
+ 
+ 		pfile = debugfs_create_file("xprop_register_value", 0600,
+ 					    pdata->xgbe_debugfs, pdata,
+ 					    &xprop_reg_value_fops);
+ 		if (!pfile)
+ 			netdev_err(pdata->netdev,
+ 				   "debugfs_create_file failed\n");
+ 	}
+ 
+ 	if (pdata->xi2c_regs) {
+ 		pfile = debugfs_create_file("xi2c_register", 0600,
+ 					    pdata->xgbe_debugfs, pdata,
+ 					    &xi2c_reg_addr_fops);
+ 		if (!pfile)
+ 			netdev_err(pdata->netdev,
+ 				   "debugfs_create_file failed\n");
+ 
+ 		pfile = debugfs_create_file("xi2c_register_value", 0600,
+ 					    pdata->xgbe_debugfs, pdata,
+ 					    &xi2c_reg_value_fops);
+ 		if (!pfile)
+ 			netdev_err(pdata->netdev,
+ 				   "debugfs_create_file failed\n");
+ 	}
+ 
++>>>>>>> 5ab1dcd58597 (amd-xgbe: Add I2C support for sideband communication)
  	kfree(buf);
  }
  
diff --cc drivers/net/ethernet/amd/xgbe/xgbe-main.c
index e79ba9088346,385b7f605200..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe-main.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-main.c
@@@ -214,21 -160,17 +214,26 @@@ static void xgbe_default_config(struct 
  static void xgbe_init_all_fptrs(struct xgbe_prv_data *pdata)
  {
  	xgbe_init_function_ptrs_dev(&pdata->hw_if);
++<<<<<<< HEAD
++=======
+ 	xgbe_init_function_ptrs_phy(&pdata->phy_if);
+ 	xgbe_init_function_ptrs_i2c(&pdata->i2c_if);
++>>>>>>> 5ab1dcd58597 (amd-xgbe: Add I2C support for sideband communication)
  	xgbe_init_function_ptrs_desc(&pdata->desc_if);
 -
 -	pdata->vdata->init_function_ptrs_phy_impl(&pdata->phy_if);
  }
  
 -struct xgbe_prv_data *xgbe_alloc_pdata(struct device *dev)
 +static int xgbe_probe(struct platform_device *pdev)
  {
  	struct xgbe_prv_data *pdata;
 +	struct xgbe_hw_if *hw_if;
 +	struct xgbe_desc_if *desc_if;
  	struct net_device *netdev;
 +	struct device *dev = &pdev->dev;
 +	struct resource *res;
 +	const u8 *mac_addr;
 +	int ret;
 +
 +	DBGPR("--> xgbe_probe\n");
  
  	netdev = alloc_etherdev_mq(sizeof(struct xgbe_prv_data),
  				   XGBE_MAX_DMA_CHANNELS);
@@@ -240,12 -181,119 +245,125 @@@
  	SET_NETDEV_DEV(netdev, dev);
  	pdata = netdev_priv(netdev);
  	pdata->netdev = netdev;
 +	pdata->pdev = pdev;
  	pdata->dev = dev;
 +	platform_set_drvdata(pdev, netdev);
  
  	spin_lock_init(&pdata->lock);
++<<<<<<< HEAD
 +	mutex_init(&pdata->xpcs_mutex);
++=======
+ 	spin_lock_init(&pdata->xpcs_lock);
+ 	mutex_init(&pdata->rss_mutex);
+ 	spin_lock_init(&pdata->tstamp_lock);
+ 	mutex_init(&pdata->i2c_mutex);
+ 	init_completion(&pdata->i2c_complete);
+ 
+ 	pdata->msg_enable = netif_msg_init(debug, default_msg_level);
+ 
+ 	set_bit(XGBE_DOWN, &pdata->dev_state);
+ 	set_bit(XGBE_STOPPED, &pdata->dev_state);
+ 
+ 	return pdata;
+ }
+ 
+ void xgbe_free_pdata(struct xgbe_prv_data *pdata)
+ {
+ 	struct net_device *netdev = pdata->netdev;
+ 
+ 	free_netdev(netdev);
+ }
+ 
+ void xgbe_set_counts(struct xgbe_prv_data *pdata)
+ {
+ 	/* Set all the function pointers */
+ 	xgbe_init_all_fptrs(pdata);
+ 
+ 	/* Populate the hardware features */
+ 	xgbe_get_all_hw_features(pdata);
+ 
+ 	/* Set default max values if not provided */
+ 	if (!pdata->tx_max_channel_count)
+ 		pdata->tx_max_channel_count = pdata->hw_feat.tx_ch_cnt;
+ 	if (!pdata->rx_max_channel_count)
+ 		pdata->rx_max_channel_count = pdata->hw_feat.rx_ch_cnt;
+ 
+ 	if (!pdata->tx_max_q_count)
+ 		pdata->tx_max_q_count = pdata->hw_feat.tx_q_cnt;
+ 	if (!pdata->rx_max_q_count)
+ 		pdata->rx_max_q_count = pdata->hw_feat.rx_q_cnt;
+ 
+ 	/* Calculate the number of Tx and Rx rings to be created
+ 	 *  -Tx (DMA) Channels map 1-to-1 to Tx Queues so set
+ 	 *   the number of Tx queues to the number of Tx channels
+ 	 *   enabled
+ 	 *  -Rx (DMA) Channels do not map 1-to-1 so use the actual
+ 	 *   number of Rx queues or maximum allowed
+ 	 */
+ 	pdata->tx_ring_count = min_t(unsigned int, num_online_cpus(),
+ 				     pdata->hw_feat.tx_ch_cnt);
+ 	pdata->tx_ring_count = min_t(unsigned int, pdata->tx_ring_count,
+ 				     pdata->tx_max_channel_count);
+ 	pdata->tx_ring_count = min_t(unsigned int, pdata->tx_ring_count,
+ 				     pdata->tx_max_q_count);
+ 
+ 	pdata->tx_q_count = pdata->tx_ring_count;
+ 
+ 	pdata->rx_ring_count = min_t(unsigned int, num_online_cpus(),
+ 				     pdata->hw_feat.rx_ch_cnt);
+ 	pdata->rx_ring_count = min_t(unsigned int, pdata->rx_ring_count,
+ 				     pdata->rx_max_channel_count);
+ 
+ 	pdata->rx_q_count = min_t(unsigned int, pdata->hw_feat.rx_q_cnt,
+ 				  pdata->rx_max_q_count);
+ 
+ 	if (netif_msg_probe(pdata)) {
+ 		dev_dbg(pdata->dev, "TX/RX DMA channel count = %u/%u\n",
+ 			pdata->tx_ring_count, pdata->rx_ring_count);
+ 		dev_dbg(pdata->dev, "TX/RX hardware queue count = %u/%u\n",
+ 			pdata->tx_q_count, pdata->rx_q_count);
+ 	}
+ }
+ 
+ int xgbe_config_netdev(struct xgbe_prv_data *pdata)
+ {
+ 	struct net_device *netdev = pdata->netdev;
+ 	struct device *dev = pdata->dev;
+ 	unsigned int i;
+ 	int ret;
+ 
+ 	netdev->irq = pdata->dev_irq;
+ 	netdev->base_addr = (unsigned long)pdata->xgmac_regs;
+ 	memcpy(netdev->dev_addr, pdata->mac_addr, netdev->addr_len);
+ 
+ 	/* Initialize ECC timestamps */
+ 	pdata->tx_sec_period = jiffies;
+ 	pdata->tx_ded_period = jiffies;
+ 	pdata->rx_sec_period = jiffies;
+ 	pdata->rx_ded_period = jiffies;
+ 	pdata->desc_sec_period = jiffies;
+ 	pdata->desc_ded_period = jiffies;
+ 
+ 	/* Issue software reset to device */
+ 	pdata->hw_if.exit(pdata);
+ 
+ 	/* Set default configuration data */
+ 	xgbe_default_config(pdata);
+ 
+ 	/* Set the DMA mask */
+ 	ret = dma_set_mask_and_coherent(dev,
+ 					DMA_BIT_MASK(pdata->hw_feat.dma_width));
+ 	if (ret) {
+ 		dev_err(dev, "dma_set_mask_and_coherent failed\n");
+ 		return ret;
+ 	}
+ 
+ 	/* Set default max values if not provided */
+ 	if (!pdata->tx_max_fifo_size)
+ 		pdata->tx_max_fifo_size = pdata->hw_feat.tx_fifo_size;
+ 	if (!pdata->rx_max_fifo_size)
+ 		pdata->rx_max_fifo_size = pdata->hw_feat.rx_fifo_size;
++>>>>>>> 5ab1dcd58597 (amd-xgbe: Add I2C support for sideband communication)
  
  	/* Set and validate the number of descriptors for a ring */
  	BUILD_BUG_ON_NOT_POWER_OF_2(XGBE_TX_DESC_CNT);
@@@ -418,14 -389,46 +536,48 @@@
  	ret = register_netdev(netdev);
  	if (ret) {
  		dev_err(dev, "net device registration failed\n");
 -		return ret;
 +		goto err_reg_netdev;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Create the PHY/ANEG name based on netdev name */
+ 	snprintf(pdata->an_name, sizeof(pdata->an_name) - 1, "%s-pcs",
+ 		 netdev_name(netdev));
+ 
+ 	/* Create the ECC name based on netdev name */
+ 	snprintf(pdata->ecc_name, sizeof(pdata->ecc_name) - 1, "%s-ecc",
+ 		 netdev_name(netdev));
+ 
+ 	/* Create the I2C name based on netdev name */
+ 	snprintf(pdata->i2c_name, sizeof(pdata->i2c_name) - 1, "%s-i2c",
+ 		 netdev_name(netdev));
+ 
+ 	/* Create workqueues */
+ 	pdata->dev_workqueue =
+ 		create_singlethread_workqueue(netdev_name(netdev));
+ 	if (!pdata->dev_workqueue) {
+ 		netdev_err(netdev, "device workqueue creation failed\n");
+ 		ret = -ENOMEM;
+ 		goto err_netdev;
+ 	}
+ 
+ 	pdata->an_workqueue =
+ 		create_singlethread_workqueue(pdata->an_name);
+ 	if (!pdata->an_workqueue) {
+ 		netdev_err(netdev, "phy workqueue creation failed\n");
+ 		ret = -ENOMEM;
+ 		goto err_wq;
+ 	}
+ 
+ 	xgbe_ptp_register(pdata);
+ 
++>>>>>>> 5ab1dcd58597 (amd-xgbe: Add I2C support for sideband communication)
  	xgbe_debugfs_init(pdata);
  
 -	netif_dbg(pdata, drv, pdata->netdev, "%u Tx software queues\n",
 -		  pdata->tx_ring_count);
 -	netif_dbg(pdata, drv, pdata->netdev, "%u Rx software queues\n",
 -		  pdata->rx_ring_count);
 +	netdev_notice(netdev, "net device enabled\n");
 +
 +	DBGPR("<-- xgbe_probe\n");
  
  	return 0;
  
diff --cc drivers/net/ethernet/amd/xgbe/xgbe.h
index 1903f878545a,586154f4562f..000000000000
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@@ -121,10 -121,16 +121,20 @@@
  #include <linux/netdevice.h>
  #include <linux/workqueue.h>
  #include <linux/phy.h>
- 
++<<<<<<< HEAD
++
++=======
+ #include <linux/if_vlan.h>
+ #include <linux/bitops.h>
+ #include <linux/ptp_clock_kernel.h>
+ #include <linux/timecounter.h>
+ #include <linux/net_tstamp.h>
+ #include <net/dcbnl.h>
+ #include <linux/completion.h>
++>>>>>>> 5ab1dcd58597 (amd-xgbe: Add I2C support for sideband communication)
  
  #define XGBE_DRV_NAME		"amd-xgbe"
 -#define XGBE_DRV_VERSION	"1.0.3"
 +#define XGBE_DRV_VERSION	"1.0.0-a"
  #define XGBE_DRV_DESC		"AMD 10 Gigabit Ethernet Driver"
  
  /* Descriptor related defines */
@@@ -324,20 -485,114 +334,57 @@@ enum xgbe_int_state 
  	XGMAC_INT_STATE_RESTORE,
  };
  
 -enum xgbe_ecc_sec {
 -	XGBE_ECC_SEC_TX,
 -	XGBE_ECC_SEC_RX,
 -	XGBE_ECC_SEC_DESC,
 -};
 -
 -enum xgbe_speed {
 -	XGBE_SPEED_1000 = 0,
 -	XGBE_SPEED_2500,
 -	XGBE_SPEED_10000,
 -	XGBE_SPEEDS,
 -};
 -
 -enum xgbe_xpcs_access {
 -	XGBE_XPCS_ACCESS_V1 = 0,
 -	XGBE_XPCS_ACCESS_V2,
 -};
 -
 -enum xgbe_an_mode {
 -	XGBE_AN_MODE_CL73 = 0,
 -	XGBE_AN_MODE_CL37,
 -	XGBE_AN_MODE_CL37_SGMII,
 -	XGBE_AN_MODE_NONE,
 -};
 -
 -enum xgbe_an {
 -	XGBE_AN_READY = 0,
 -	XGBE_AN_PAGE_RECEIVED,
 -	XGBE_AN_INCOMPAT_LINK,
 -	XGBE_AN_COMPLETE,
 -	XGBE_AN_NO_LINK,
 -	XGBE_AN_ERROR,
 -};
 -
 -enum xgbe_rx {
 -	XGBE_RX_BPA = 0,
 -	XGBE_RX_XNP,
 -	XGBE_RX_COMPLETE,
 -	XGBE_RX_ERROR,
 -};
 -
 -enum xgbe_mode {
 -	XGBE_MODE_KX_1000 = 0,
 -	XGBE_MODE_KX_2500,
 -	XGBE_MODE_KR,
 -	XGBE_MODE_UNKNOWN,
 -};
 -
 -enum xgbe_speedset {
 -	XGBE_SPEEDSET_1000_10000 = 0,
 -	XGBE_SPEEDSET_2500_10000,
 -};
 -
 -struct xgbe_phy {
 -	u32 supported;
 -	u32 advertising;
 -	u32 lp_advertising;
 -
 -	int address;
 -
 -	int autoneg;
 -	int speed;
 -	int duplex;
 -
 -	int link;
 -
 -	int pause_autoneg;
 -	int tx_pause;
 -	int rx_pause;
 +enum xgbe_mtl_fifo_size {
 +	XGMAC_MTL_FIFO_SIZE_256  = 0x00,
 +	XGMAC_MTL_FIFO_SIZE_512  = 0x01,
 +	XGMAC_MTL_FIFO_SIZE_1K   = 0x03,
 +	XGMAC_MTL_FIFO_SIZE_2K   = 0x07,
 +	XGMAC_MTL_FIFO_SIZE_4K   = 0x0f,
 +	XGMAC_MTL_FIFO_SIZE_8K   = 0x1f,
 +	XGMAC_MTL_FIFO_SIZE_16K  = 0x3f,
 +	XGMAC_MTL_FIFO_SIZE_32K  = 0x7f,
 +	XGMAC_MTL_FIFO_SIZE_64K  = 0xff,
 +	XGMAC_MTL_FIFO_SIZE_128K = 0x1ff,
 +	XGMAC_MTL_FIFO_SIZE_256K = 0x3ff,
  };
  
+ enum xgbe_i2c_cmd {
+ 	XGBE_I2C_CMD_READ = 0,
+ 	XGBE_I2C_CMD_WRITE,
+ };
+ 
+ struct xgbe_i2c_op {
+ 	enum xgbe_i2c_cmd cmd;
+ 
+ 	unsigned int target;
+ 
+ 	void *buf;
+ 	unsigned int len;
+ };
+ 
+ struct xgbe_i2c_op_state {
+ 	struct xgbe_i2c_op *op;
+ 
+ 	unsigned int tx_len;
+ 	unsigned char *tx_buf;
+ 
+ 	unsigned int rx_len;
+ 	unsigned char *rx_buf;
+ 
+ 	unsigned int tx_abort_source;
+ 
+ 	int ret;
+ };
+ 
+ struct xgbe_i2c {
+ 	unsigned int started;
+ 	unsigned int max_speed_mode;
+ 	unsigned int rx_fifo_size;
+ 	unsigned int tx_fifo_size;
+ 
+ 	struct xgbe_i2c_op_state op_state;
+ };
+ 
  struct xgbe_mmc_stats {
  	/* Tx Stats */
  	u64 txoctetcount_gb;
@@@ -461,8 -723,113 +508,23 @@@ struct xgbe_hw_if 
  	void (*rx_mmc_int)(struct xgbe_prv_data *);
  	void (*tx_mmc_int)(struct xgbe_prv_data *);
  	void (*read_mmc_stats)(struct xgbe_prv_data *);
 -
 -	/* For Timestamp config */
 -	int (*config_tstamp)(struct xgbe_prv_data *, unsigned int);
 -	void (*update_tstamp_addend)(struct xgbe_prv_data *, unsigned int);
 -	void (*set_tstamp_time)(struct xgbe_prv_data *, unsigned int sec,
 -				unsigned int nsec);
 -	u64 (*get_tstamp_time)(struct xgbe_prv_data *);
 -	u64 (*get_tx_tstamp)(struct xgbe_prv_data *);
 -
 -	/* For Data Center Bridging config */
 -	void (*config_tc)(struct xgbe_prv_data *);
 -	void (*config_dcb_tc)(struct xgbe_prv_data *);
 -	void (*config_dcb_pfc)(struct xgbe_prv_data *);
 -
 -	/* For Receive Side Scaling */
 -	int (*enable_rss)(struct xgbe_prv_data *);
 -	int (*disable_rss)(struct xgbe_prv_data *);
 -	int (*set_rss_hash_key)(struct xgbe_prv_data *, const u8 *);
 -	int (*set_rss_lookup_table)(struct xgbe_prv_data *, const u32 *);
 -
 -	/* For ECC */
 -	void (*disable_ecc_ded)(struct xgbe_prv_data *);
 -	void (*disable_ecc_sec)(struct xgbe_prv_data *, enum xgbe_ecc_sec);
 -};
 -
 -/* This structure represents implementation specific routines for an
 - * implementation of a PHY. All routines are required unless noted below.
 - *   Optional routines:
 - *     kr_training_pre, kr_training_post
 - */
 -struct xgbe_phy_impl_if {
 -	/* Perform Setup/teardown actions */
 -	int (*init)(struct xgbe_prv_data *);
 -	void (*exit)(struct xgbe_prv_data *);
 -
 -	/* Perform start/stop specific actions */
 -	int (*reset)(struct xgbe_prv_data *);
 -	int (*start)(struct xgbe_prv_data *);
 -	void (*stop)(struct xgbe_prv_data *);
 -
 -	/* Return the link status */
 -	int (*link_status)(struct xgbe_prv_data *);
 -
 -	/* Indicate if a particular speed is valid */
 -	bool (*valid_speed)(struct xgbe_prv_data *, int);
 -
 -	/* Check if the specified mode can/should be used */
 -	bool (*use_mode)(struct xgbe_prv_data *, enum xgbe_mode);
 -	/* Switch the PHY into various modes */
 -	void (*set_mode)(struct xgbe_prv_data *, enum xgbe_mode);
 -	/* Retrieve mode needed for a specific speed */
 -	enum xgbe_mode (*get_mode)(struct xgbe_prv_data *, int);
 -	/* Retrieve new/next mode when trying to auto-negotiate */
 -	enum xgbe_mode (*switch_mode)(struct xgbe_prv_data *);
 -	/* Retrieve current mode */
 -	enum xgbe_mode (*cur_mode)(struct xgbe_prv_data *);
 -
 -	/* Retrieve current auto-negotiation mode */
 -	enum xgbe_an_mode (*an_mode)(struct xgbe_prv_data *);
 -
 -	/* Process results of auto-negotiation */
 -	enum xgbe_mode (*an_outcome)(struct xgbe_prv_data *);
 -
 -	/* Pre/Post KR training enablement support */
 -	void (*kr_training_pre)(struct xgbe_prv_data *);
 -	void (*kr_training_post)(struct xgbe_prv_data *);
 -};
 -
 -struct xgbe_phy_if {
 -	/* For PHY setup/teardown */
 -	int (*phy_init)(struct xgbe_prv_data *);
 -	void (*phy_exit)(struct xgbe_prv_data *);
 -
 -	/* For PHY support when setting device up/down */
 -	int (*phy_reset)(struct xgbe_prv_data *);
 -	int (*phy_start)(struct xgbe_prv_data *);
 -	void (*phy_stop)(struct xgbe_prv_data *);
 -
 -	/* For PHY support while device is up */
 -	void (*phy_status)(struct xgbe_prv_data *);
 -	int (*phy_config_aneg)(struct xgbe_prv_data *);
 -
 -	/* For PHY settings validation */
 -	bool (*phy_valid_speed)(struct xgbe_prv_data *, int);
 -
 -	/* For single interrupt support */
 -	irqreturn_t (*an_isr)(int, struct xgbe_prv_data *);
 -
 -	/* PHY implementation specific services */
 -	struct xgbe_phy_impl_if phy_impl;
  };
  
+ struct xgbe_i2c_if {
+ 	/* For initial I2C setup */
+ 	int (*i2c_init)(struct xgbe_prv_data *);
+ 
+ 	/* For I2C support when setting device up/down */
+ 	int (*i2c_start)(struct xgbe_prv_data *);
+ 	void (*i2c_stop)(struct xgbe_prv_data *);
+ 
+ 	/* For performing I2C operations */
+ 	int (*i2c_xfer)(struct xgbe_prv_data *, struct xgbe_i2c_op *);
+ 
+ 	/* For single interrupt support */
+ 	irqreturn_t (*i2c_isr)(int, struct xgbe_prv_data *);
+ };
+ 
  struct xgbe_desc_if {
  	int (*alloc_ring_resources)(struct xgbe_prv_data *);
  	void (*free_ring_resources)(struct xgbe_prv_data *);
@@@ -514,10 -887,31 +576,24 @@@ struct xgbe_hw_features 
  	unsigned int aux_snap_num;	/* Number of Aux snapshot inputs */
  };
  
++<<<<<<< HEAD
++=======
+ struct xgbe_version_data {
+ 	void (*init_function_ptrs_phy_impl)(struct xgbe_phy_if *);
+ 	enum xgbe_xpcs_access xpcs_access;
+ 	unsigned int mmc_64bit;
+ 	unsigned int tx_max_fifo_size;
+ 	unsigned int rx_max_fifo_size;
+ 	unsigned int tx_tstamp_workaround;
+ 	unsigned int ecc_support;
+ 	unsigned int i2c_support;
+ };
+ 
++>>>>>>> 5ab1dcd58597 (amd-xgbe: Add I2C support for sideband communication)
  struct xgbe_prv_data {
  	struct net_device *netdev;
 -	struct pci_dev *pcidev;
 -	struct platform_device *platdev;
 -	struct acpi_device *adev;
 +	struct platform_device *pdev;
  	struct device *dev;
 -	struct platform_device *phy_platdev;
 -	struct device *phy_dev;
 -
 -	/* Version related data */
 -	struct xgbe_version_data *vdata;
 -
 -	/* ACPI or DT flag */
 -	unsigned int use_acpi;
  
  	/* XGMAC/XPCS related mmio registers */
  	void __iomem *xgmac_regs;	/* XGMAC CSRs */
@@@ -526,15 -925,54 +602,16 @@@
  	/* Overall device lock */
  	spinlock_t lock;
  
 -	/* XPCS indirect addressing lock */
 -	spinlock_t xpcs_lock;
 -	unsigned int xpcs_window;
 -	unsigned int xpcs_window_size;
 -	unsigned int xpcs_window_mask;
 -
 -	/* RSS addressing mutex */
 -	struct mutex rss_mutex;
 -
 -	/* Flags representing xgbe_state */
 -	unsigned long dev_state;
 -
 -	/* ECC support */
 -	unsigned long tx_sec_period;
 -	unsigned long tx_ded_period;
 -	unsigned long rx_sec_period;
 -	unsigned long rx_ded_period;
 -	unsigned long desc_sec_period;
 -	unsigned long desc_ded_period;
 -
 -	unsigned int tx_sec_count;
 -	unsigned int tx_ded_count;
 -	unsigned int rx_sec_count;
 -	unsigned int rx_ded_count;
 -	unsigned int desc_ded_count;
 -	unsigned int desc_sec_count;
 -
 -	struct msix_entry *msix_entries;
 -	int dev_irq;
 -	int ecc_irq;
 -	int i2c_irq;
 -	int channel_irq[XGBE_MAX_DMA_CHANNELS];
 -
 -	unsigned int per_channel_irq;
 -	unsigned int irq_shared;
 -	unsigned int irq_count;
 -	unsigned int channel_irq_count;
 -	unsigned int channel_irq_mode;
 -
 -	char ecc_name[IFNAMSIZ + 32];
 +	/* XPCS indirect addressing mutex */
 +	struct mutex xpcs_mutex;
 +
 +	int irq_number;
  
  	struct xgbe_hw_if hw_if;
 -	struct xgbe_phy_if phy_if;
  	struct xgbe_desc_if desc_if;
+ 	struct xgbe_i2c_if i2c_if;
  
  	/* AXI DMA settings */
 -	unsigned int coherent;
  	unsigned int axdomain;
  	unsigned int arcache;
  	unsigned int awcache;
@@@ -605,11 -1077,56 +682,21 @@@
  	/* Hardware features of the device */
  	struct xgbe_hw_features hw_feat;
  
 -	/* Device work structures */
 +	/* Device restart work structure */
  	struct work_struct restart_work;
 -	struct work_struct stopdev_work;
  
++<<<<<<< HEAD
  	/* Keeps track of power mode */
  	unsigned int power_down;
 -
 -	/* Network interface message level setting */
 -	u32 msg_enable;
 -
 -	/* Current PHY settings */
 -	phy_interface_t phy_mode;
 -	int phy_link;
 -	int phy_speed;
 -
 -	/* MDIO/PHY related settings */
 -	unsigned int phy_started;
 -	void *phy_data;
 -	struct xgbe_phy phy;
 -	int mdio_mmd;
 -	unsigned long link_check;
 -
 -	char an_name[IFNAMSIZ + 32];
 -	struct workqueue_struct *an_workqueue;
 -
 -	int an_irq;
 -	struct work_struct an_irq_work;
 -
 -	/* Auto-negotiation state machine support */
 -	unsigned int an_int;
 -	unsigned int an_status;
 -	struct mutex an_mutex;
 -	enum xgbe_an an_result;
 -	enum xgbe_an an_state;
 -	enum xgbe_rx kr_state;
 -	enum xgbe_rx kx_state;
 -	struct work_struct an_work;
 -	unsigned int an_supported;
 -	unsigned int parallel_detect;
 -	unsigned int fec_ability;
 -	unsigned long an_start;
 -	enum xgbe_an_mode an_mode;
 -
++=======
+ 	/* I2C support */
+ 	struct xgbe_i2c i2c;
+ 	struct mutex i2c_mutex;
+ 	struct completion i2c_complete;
+ 	char i2c_name[IFNAMSIZ + 32];
+ 
+ 	unsigned int lpm_ctrl;		/* CTRL1 for resume */
++>>>>>>> 5ab1dcd58597 (amd-xgbe: Add I2C support for sideband communication)
  
  #ifdef CONFIG_DEBUG_FS
  	struct dentry *xgbe_debugfs;
@@@ -618,22 -1135,48 +705,35 @@@
  
  	unsigned int debugfs_xpcs_mmd;
  	unsigned int debugfs_xpcs_reg;
++<<<<<<< HEAD
++=======
+ 
+ 	unsigned int debugfs_xprop_reg;
+ 
+ 	unsigned int debugfs_xi2c_reg;
++>>>>>>> 5ab1dcd58597 (amd-xgbe: Add I2C support for sideband communication)
  #endif
  };
  
  /* Function prototypes*/
 -struct xgbe_prv_data *xgbe_alloc_pdata(struct device *);
 -void xgbe_free_pdata(struct xgbe_prv_data *);
 -void xgbe_set_counts(struct xgbe_prv_data *);
 -int xgbe_config_netdev(struct xgbe_prv_data *);
 -void xgbe_deconfig_netdev(struct xgbe_prv_data *);
 -
 -int xgbe_platform_init(void);
 -void xgbe_platform_exit(void);
 -#ifdef CONFIG_PCI
 -int xgbe_pci_init(void);
 -void xgbe_pci_exit(void);
 -#else
 -static inline int xgbe_pci_init(void) { return 0; }
 -static inline void xgbe_pci_exit(void) { }
 -#endif
  
  void xgbe_init_function_ptrs_dev(struct xgbe_hw_if *);
 -void xgbe_init_function_ptrs_phy(struct xgbe_phy_if *);
 -void xgbe_init_function_ptrs_phy_v1(struct xgbe_phy_if *);
 -void xgbe_init_function_ptrs_phy_v2(struct xgbe_phy_if *);
  void xgbe_init_function_ptrs_desc(struct xgbe_desc_if *);
++<<<<<<< HEAD
 +struct net_device_ops *xgbe_get_netdev_ops(void);
 +struct ethtool_ops *xgbe_get_ethtool_ops(void);
++=======
+ void xgbe_init_function_ptrs_i2c(struct xgbe_i2c_if *);
+ const struct net_device_ops *xgbe_get_netdev_ops(void);
+ const struct ethtool_ops *xgbe_get_ethtool_ops(void);
++>>>>>>> 5ab1dcd58597 (amd-xgbe: Add I2C support for sideband communication)
  
 -#ifdef CONFIG_AMD_XGBE_DCB
 -const struct dcbnl_rtnl_ops *xgbe_get_dcbnl_ops(void);
 -#endif
 -
 -void xgbe_ptp_register(struct xgbe_prv_data *);
 -void xgbe_ptp_unregister(struct xgbe_prv_data *);
 -void xgbe_dump_tx_desc(struct xgbe_prv_data *, struct xgbe_ring *,
 -		       unsigned int, unsigned int, unsigned int);
 -void xgbe_dump_rx_desc(struct xgbe_prv_data *, struct xgbe_ring *,
 +int xgbe_mdio_register(struct xgbe_prv_data *);
 +void xgbe_mdio_unregister(struct xgbe_prv_data *);
 +void xgbe_dump_phy_registers(struct xgbe_prv_data *);
 +void xgbe_dump_tx_desc(struct xgbe_ring *, unsigned int, unsigned int,
 +		       unsigned int);
 +void xgbe_dump_rx_desc(struct xgbe_ring *, struct xgbe_ring_desc *,
  		       unsigned int);
  void xgbe_print_pkt(struct net_device *, struct sk_buff *, bool);
  void xgbe_get_all_hw_features(struct xgbe_prv_data *);
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-pci.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
* Unmerged path drivers/net/ethernet/amd/xgbe/Makefile
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-common.h b/drivers/net/ethernet/amd/xgbe/xgbe-common.h
index 3373e9ef2003..6c8468d06df9 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-common.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-common.h
@@ -754,6 +754,65 @@
 #define PCS_MMD_SELECT			0xff
 
 
+/* I2C Control register offsets */
+#define IC_CON					0x0000
+#define IC_TAR					0x0004
+#define IC_DATA_CMD				0x0010
+#define IC_INTR_STAT				0x002c
+#define IC_INTR_MASK				0x0030
+#define IC_RAW_INTR_STAT			0x0034
+#define IC_CLR_INTR				0x0040
+#define IC_CLR_TX_ABRT				0x0054
+#define IC_CLR_STOP_DET				0x0060
+#define IC_ENABLE				0x006c
+#define IC_TXFLR				0x0074
+#define IC_RXFLR				0x0078
+#define IC_TX_ABRT_SOURCE			0x0080
+#define IC_ENABLE_STATUS			0x009c
+#define IC_COMP_PARAM_1				0x00f4
+
+/* I2C Control register entry bit positions and sizes */
+#define IC_COMP_PARAM_1_MAX_SPEED_MODE_INDEX	2
+#define IC_COMP_PARAM_1_MAX_SPEED_MODE_WIDTH	2
+#define IC_COMP_PARAM_1_RX_BUFFER_DEPTH_INDEX	8
+#define IC_COMP_PARAM_1_RX_BUFFER_DEPTH_WIDTH	8
+#define IC_COMP_PARAM_1_TX_BUFFER_DEPTH_INDEX	16
+#define IC_COMP_PARAM_1_TX_BUFFER_DEPTH_WIDTH	8
+#define IC_CON_MASTER_MODE_INDEX		0
+#define IC_CON_MASTER_MODE_WIDTH		1
+#define IC_CON_RESTART_EN_INDEX			5
+#define IC_CON_RESTART_EN_WIDTH			1
+#define IC_CON_RX_FIFO_FULL_HOLD_INDEX		9
+#define IC_CON_RX_FIFO_FULL_HOLD_WIDTH		1
+#define IC_CON_SLAVE_DISABLE_INDEX		6
+#define IC_CON_SLAVE_DISABLE_WIDTH		1
+#define IC_CON_SPEED_INDEX			1
+#define IC_CON_SPEED_WIDTH			2
+#define IC_DATA_CMD_CMD_INDEX			8
+#define IC_DATA_CMD_CMD_WIDTH			1
+#define IC_DATA_CMD_STOP_INDEX			9
+#define IC_DATA_CMD_STOP_WIDTH			1
+#define IC_ENABLE_ABORT_INDEX			1
+#define IC_ENABLE_ABORT_WIDTH			1
+#define IC_ENABLE_EN_INDEX			0
+#define IC_ENABLE_EN_WIDTH			1
+#define IC_ENABLE_STATUS_EN_INDEX		0
+#define IC_ENABLE_STATUS_EN_WIDTH		1
+#define IC_INTR_MASK_TX_EMPTY_INDEX		4
+#define IC_INTR_MASK_TX_EMPTY_WIDTH		1
+#define IC_RAW_INTR_STAT_RX_FULL_INDEX		2
+#define IC_RAW_INTR_STAT_RX_FULL_WIDTH		1
+#define IC_RAW_INTR_STAT_STOP_DET_INDEX		9
+#define IC_RAW_INTR_STAT_STOP_DET_WIDTH		1
+#define IC_RAW_INTR_STAT_TX_ABRT_INDEX		6
+#define IC_RAW_INTR_STAT_TX_ABRT_WIDTH		1
+#define IC_RAW_INTR_STAT_TX_EMPTY_INDEX		4
+#define IC_RAW_INTR_STAT_TX_EMPTY_WIDTH		1
+
+/* I2C Control register value */
+#define IC_TX_ABRT_7B_ADDR_NOACK		0x0001
+#define IC_TX_ABRT_ARB_LOST			0x1000
+
 /* Descriptor/Packet entry bit positions and sizes */
 #define RX_PACKET_ERRORS_CRC_INDEX		2
 #define RX_PACKET_ERRORS_CRC_WIDTH		1
@@ -986,6 +1045,39 @@ do {									\
 	ioread32((_pdata)->xpcs_regs + (_off))
 
 
+/* Macros for building, reading or writing register values or bits
+ * within the register values of I2C Control registers.
+ */
+#define XI2C_GET_BITS(_var, _prefix, _field)				\
+	GET_BITS((_var),						\
+		 _prefix##_##_field##_INDEX,				\
+		 _prefix##_##_field##_WIDTH)
+
+#define XI2C_SET_BITS(_var, _prefix, _field, _val)			\
+	SET_BITS((_var),						\
+		 _prefix##_##_field##_INDEX,				\
+		 _prefix##_##_field##_WIDTH, (_val))
+
+#define XI2C_IOREAD(_pdata, _reg)					\
+	ioread32((_pdata)->xi2c_regs + (_reg))
+
+#define XI2C_IOREAD_BITS(_pdata, _reg, _field)				\
+	GET_BITS(XI2C_IOREAD((_pdata), (_reg)),				\
+		 _reg##_##_field##_INDEX,				\
+		 _reg##_##_field##_WIDTH)
+
+#define XI2C_IOWRITE(_pdata, _reg, _val)				\
+	iowrite32((_val), (_pdata)->xi2c_regs + (_reg))
+
+#define XI2C_IOWRITE_BITS(_pdata, _reg, _field, _val)			\
+do {									\
+	u32 reg_val = XI2C_IOREAD((_pdata), (_reg));			\
+	SET_BITS(reg_val,						\
+		 _reg##_##_field##_INDEX,				\
+		 _reg##_##_field##_WIDTH, (_val));			\
+	XI2C_IOWRITE((_pdata), (_reg), reg_val);			\
+} while (0)
+
 /* Macros for building, reading or writing register values or bits
  * using MDIO.  Different from above because of the use of standardized
  * Linux include values.  No shifting is performed with the bit
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-debugfs.c
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index d58e85811bc9..607d24232403 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@ -260,6 +260,10 @@ static irqreturn_t xgbe_isr(int irq, void *data)
 
 	DBGPR("<--xgbe_isr\n");
 
+	/* If there is not a separate I2C irq, handle it here */
+	if (pdata->vdata->i2c_support && (pdata->dev_irq == pdata->i2c_irq))
+		pdata->i2c_if.i2c_isr(irq, pdata);
+
 isr_done:
 	return IRQ_HANDLED;
 }
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-i2c.c b/drivers/net/ethernet/amd/xgbe/xgbe-i2c.c
new file mode 100644
index 000000000000..0c7088a426e9
--- /dev/null
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-i2c.c
@@ -0,0 +1,492 @@
+/*
+ * AMD 10Gb Ethernet driver
+ *
+ * This file is available to you under your choice of the following two
+ * licenses:
+ *
+ * License 1: GPLv2
+ *
+ * Copyright (c) 2016 Advanced Micro Devices, Inc.
+ *
+ * This file is free software; you may copy, redistribute and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This file is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+ *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+ *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+ *     and you.
+ *
+ *     The Software IS NOT an item of Licensed Software or Licensed Product
+ *     under any End User Software License Agreement or Agreement for Licensed
+ *     Product with Synopsys or any supplement thereto.  Permission is hereby
+ *     granted, free of charge, to any person obtaining a copy of this software
+ *     annotated with this license and the Software, to deal in the Software
+ *     without restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+ *     of the Software, and to permit persons to whom the Software is furnished
+ *     to do so, subject to the following conditions:
+ *
+ *     The above copyright notice and this permission notice shall be included
+ *     in all copies or substantial portions of the Software.
+ *
+ *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+ *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+ *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *     THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *
+ * License 2: Modified BSD
+ *
+ * Copyright (c) 2016 Advanced Micro Devices, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Advanced Micro Devices, Inc. nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * This file incorporates work covered by the following copyright and
+ * permission notice:
+ *     The Synopsys DWC ETHER XGMAC Software Driver and documentation
+ *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,
+ *     Inc. unless otherwise expressly agreed to in writing between Synopsys
+ *     and you.
+ *
+ *     The Software IS NOT an item of Licensed Software or Licensed Product
+ *     under any End User Software License Agreement or Agreement for Licensed
+ *     Product with Synopsys or any supplement thereto.  Permission is hereby
+ *     granted, free of charge, to any person obtaining a copy of this software
+ *     annotated with this license and the Software, to deal in the Software
+ *     without restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+ *     of the Software, and to permit persons to whom the Software is furnished
+ *     to do so, subject to the following conditions:
+ *
+ *     The above copyright notice and this permission notice shall be included
+ *     in all copies or substantial portions of the Software.
+ *
+ *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"
+ *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS
+ *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ *     THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/kmod.h>
+#include <linux/delay.h>
+#include <linux/completion.h>
+#include <linux/mutex.h>
+
+#include "xgbe.h"
+#include "xgbe-common.h"
+
+#define XGBE_ABORT_COUNT	500
+#define XGBE_DISABLE_COUNT	1000
+
+#define XGBE_STD_SPEED		1
+
+#define XGBE_INTR_RX_FULL	BIT(IC_RAW_INTR_STAT_RX_FULL_INDEX)
+#define XGBE_INTR_TX_EMPTY	BIT(IC_RAW_INTR_STAT_TX_EMPTY_INDEX)
+#define XGBE_INTR_TX_ABRT	BIT(IC_RAW_INTR_STAT_TX_ABRT_INDEX)
+#define XGBE_INTR_STOP_DET	BIT(IC_RAW_INTR_STAT_STOP_DET_INDEX)
+#define XGBE_DEFAULT_INT_MASK	(XGBE_INTR_RX_FULL  |	\
+				 XGBE_INTR_TX_EMPTY |	\
+				 XGBE_INTR_TX_ABRT  |	\
+				 XGBE_INTR_STOP_DET)
+
+#define XGBE_I2C_READ		BIT(8)
+#define XGBE_I2C_STOP		BIT(9)
+
+static int xgbe_i2c_abort(struct xgbe_prv_data *pdata)
+{
+	unsigned int wait = XGBE_ABORT_COUNT;
+
+	/* Must be enabled to recognize the abort request */
+	XI2C_IOWRITE_BITS(pdata, IC_ENABLE, EN, 1);
+
+	/* Issue the abort */
+	XI2C_IOWRITE_BITS(pdata, IC_ENABLE, ABORT, 1);
+
+	while (wait--) {
+		if (!XI2C_IOREAD_BITS(pdata, IC_ENABLE, ABORT))
+			return 0;
+
+		usleep_range(500, 600);
+	}
+
+	return -EBUSY;
+}
+
+static int xgbe_i2c_set_enable(struct xgbe_prv_data *pdata, bool enable)
+{
+	unsigned int wait = XGBE_DISABLE_COUNT;
+	unsigned int mode = enable ? 1 : 0;
+
+	while (wait--) {
+		XI2C_IOWRITE_BITS(pdata, IC_ENABLE, EN, mode);
+		if (XI2C_IOREAD_BITS(pdata, IC_ENABLE_STATUS, EN) == mode)
+			return 0;
+
+		usleep_range(100, 110);
+	}
+
+	return -EBUSY;
+}
+
+static int xgbe_i2c_disable(struct xgbe_prv_data *pdata)
+{
+	unsigned int ret;
+
+	ret = xgbe_i2c_set_enable(pdata, false);
+	if (ret) {
+		/* Disable failed, try an abort */
+		ret = xgbe_i2c_abort(pdata);
+		if (ret)
+			return ret;
+
+		/* Abort succeeded, try to disable again */
+		ret = xgbe_i2c_set_enable(pdata, false);
+	}
+
+	return ret;
+}
+
+static int xgbe_i2c_enable(struct xgbe_prv_data *pdata)
+{
+	return xgbe_i2c_set_enable(pdata, true);
+}
+
+static void xgbe_i2c_clear_all_interrupts(struct xgbe_prv_data *pdata)
+{
+	XI2C_IOREAD(pdata, IC_CLR_INTR);
+}
+
+static void xgbe_i2c_disable_interrupts(struct xgbe_prv_data *pdata)
+{
+	XI2C_IOWRITE(pdata, IC_INTR_MASK, 0);
+}
+
+static void xgbe_i2c_enable_interrupts(struct xgbe_prv_data *pdata)
+{
+	XI2C_IOWRITE(pdata, IC_INTR_MASK, XGBE_DEFAULT_INT_MASK);
+}
+
+static void xgbe_i2c_write(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_i2c_op_state *state = &pdata->i2c.op_state;
+	unsigned int tx_slots;
+	unsigned int cmd;
+
+	/* Configured to never receive Rx overflows, so fill up Tx fifo */
+	tx_slots = pdata->i2c.tx_fifo_size - XI2C_IOREAD(pdata, IC_TXFLR);
+	while (tx_slots && state->tx_len) {
+		if (state->op->cmd == XGBE_I2C_CMD_READ)
+			cmd = XGBE_I2C_READ;
+		else
+			cmd = *state->tx_buf++;
+
+		if (state->tx_len == 1)
+			XI2C_SET_BITS(cmd, IC_DATA_CMD, STOP, 1);
+
+		XI2C_IOWRITE(pdata, IC_DATA_CMD, cmd);
+
+		tx_slots--;
+		state->tx_len--;
+	}
+
+	/* No more Tx operations, so ignore TX_EMPTY and return */
+	if (!state->tx_len)
+		XI2C_IOWRITE_BITS(pdata, IC_INTR_MASK, TX_EMPTY, 0);
+}
+
+static void xgbe_i2c_read(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_i2c_op_state *state = &pdata->i2c.op_state;
+	unsigned int rx_slots;
+
+	/* Anything to be read? */
+	if (state->op->cmd != XGBE_I2C_CMD_READ)
+		return;
+
+	rx_slots = XI2C_IOREAD(pdata, IC_RXFLR);
+	while (rx_slots && state->rx_len) {
+		*state->rx_buf++ = XI2C_IOREAD(pdata, IC_DATA_CMD);
+		state->rx_len--;
+		rx_slots--;
+	}
+}
+
+static void xgbe_i2c_clear_isr_interrupts(struct xgbe_prv_data *pdata,
+					  unsigned int isr)
+{
+	struct xgbe_i2c_op_state *state = &pdata->i2c.op_state;
+
+	if (isr & XGBE_INTR_TX_ABRT) {
+		state->tx_abort_source = XI2C_IOREAD(pdata, IC_TX_ABRT_SOURCE);
+		XI2C_IOREAD(pdata, IC_CLR_TX_ABRT);
+	}
+
+	if (isr & XGBE_INTR_STOP_DET)
+		XI2C_IOREAD(pdata, IC_CLR_STOP_DET);
+}
+
+static irqreturn_t xgbe_i2c_isr(int irq, void *data)
+{
+	struct xgbe_prv_data *pdata = (struct xgbe_prv_data *)data;
+	struct xgbe_i2c_op_state *state = &pdata->i2c.op_state;
+	unsigned int isr;
+
+	isr = XI2C_IOREAD(pdata, IC_RAW_INTR_STAT);
+	netif_dbg(pdata, intr, pdata->netdev,
+		  "I2C interrupt received: status=%#010x\n", isr);
+
+	xgbe_i2c_clear_isr_interrupts(pdata, isr);
+
+	if (isr & XGBE_INTR_TX_ABRT) {
+		netif_dbg(pdata, link, pdata->netdev,
+			  "I2C TX_ABRT received (%#010x) for target %#04x\n",
+			  state->tx_abort_source, state->op->target);
+
+		xgbe_i2c_disable_interrupts(pdata);
+
+		state->ret = -EIO;
+		goto out;
+	}
+
+	/* Check for data in the Rx fifo */
+	xgbe_i2c_read(pdata);
+
+	/* Fill up the Tx fifo next */
+	xgbe_i2c_write(pdata);
+
+out:
+	/* Complete on an error or STOP condition */
+	if (state->ret || XI2C_GET_BITS(isr, IC_RAW_INTR_STAT, STOP_DET))
+		complete(&pdata->i2c_complete);
+
+	return IRQ_HANDLED;
+}
+
+static void xgbe_i2c_set_mode(struct xgbe_prv_data *pdata)
+{
+	unsigned int reg;
+
+	reg = XI2C_IOREAD(pdata, IC_CON);
+	XI2C_SET_BITS(reg, IC_CON, MASTER_MODE, 1);
+	XI2C_SET_BITS(reg, IC_CON, SLAVE_DISABLE, 1);
+	XI2C_SET_BITS(reg, IC_CON, RESTART_EN, 1);
+	XI2C_SET_BITS(reg, IC_CON, SPEED, XGBE_STD_SPEED);
+	XI2C_SET_BITS(reg, IC_CON, RX_FIFO_FULL_HOLD, 1);
+	XI2C_IOWRITE(pdata, IC_CON, reg);
+}
+
+static void xgbe_i2c_get_features(struct xgbe_prv_data *pdata)
+{
+	struct xgbe_i2c *i2c = &pdata->i2c;
+	unsigned int reg;
+
+	reg = XI2C_IOREAD(pdata, IC_COMP_PARAM_1);
+	i2c->max_speed_mode = XI2C_GET_BITS(reg, IC_COMP_PARAM_1,
+					    MAX_SPEED_MODE);
+	i2c->rx_fifo_size = XI2C_GET_BITS(reg, IC_COMP_PARAM_1,
+					  RX_BUFFER_DEPTH);
+	i2c->tx_fifo_size = XI2C_GET_BITS(reg, IC_COMP_PARAM_1,
+					  TX_BUFFER_DEPTH);
+
+	if (netif_msg_probe(pdata))
+		dev_dbg(pdata->dev, "I2C features: %s=%u, %s=%u, %s=%u\n",
+			"MAX_SPEED_MODE", i2c->max_speed_mode,
+			"RX_BUFFER_DEPTH", i2c->rx_fifo_size,
+			"TX_BUFFER_DEPTH", i2c->tx_fifo_size);
+}
+
+static void xgbe_i2c_set_target(struct xgbe_prv_data *pdata, unsigned int addr)
+{
+	XI2C_IOWRITE(pdata, IC_TAR, addr);
+}
+
+static irqreturn_t xgbe_i2c_combined_isr(int irq, struct xgbe_prv_data *pdata)
+{
+	if (!XI2C_IOREAD(pdata, IC_RAW_INTR_STAT))
+		return IRQ_HANDLED;
+
+	return xgbe_i2c_isr(irq, pdata);
+}
+
+static int xgbe_i2c_xfer(struct xgbe_prv_data *pdata, struct xgbe_i2c_op *op)
+{
+	struct xgbe_i2c_op_state *state = &pdata->i2c.op_state;
+	int ret;
+
+	mutex_lock(&pdata->i2c_mutex);
+
+	reinit_completion(&pdata->i2c_complete);
+
+	ret = xgbe_i2c_disable(pdata);
+	if (ret) {
+		netdev_err(pdata->netdev, "failed to disable i2c master\n");
+		goto unlock;
+	}
+
+	xgbe_i2c_set_target(pdata, op->target);
+
+	memset(state, 0, sizeof(*state));
+	state->op = op;
+	state->tx_len = op->len;
+	state->tx_buf = op->buf;
+	state->rx_len = op->len;
+	state->rx_buf = op->buf;
+
+	xgbe_i2c_clear_all_interrupts(pdata);
+	ret = xgbe_i2c_enable(pdata);
+	if (ret) {
+		netdev_err(pdata->netdev, "failed to enable i2c master\n");
+		goto unlock;
+	}
+
+	/* Enabling the interrupts will cause the TX FIFO empty interrupt to
+	 * fire and begin to process the command via the ISR.
+	 */
+	xgbe_i2c_enable_interrupts(pdata);
+
+	if (!wait_for_completion_timeout(&pdata->i2c_complete, HZ)) {
+		netdev_err(pdata->netdev, "i2c operation timed out\n");
+		ret = -ETIMEDOUT;
+		goto disable;
+	}
+
+	ret = state->ret;
+	if (ret) {
+		if (state->tx_abort_source & IC_TX_ABRT_7B_ADDR_NOACK)
+			ret = -ENOTCONN;
+		else if (state->tx_abort_source & IC_TX_ABRT_ARB_LOST)
+			ret = -EAGAIN;
+	}
+
+disable:
+	xgbe_i2c_disable_interrupts(pdata);
+	xgbe_i2c_disable(pdata);
+
+unlock:
+	mutex_unlock(&pdata->i2c_mutex);
+
+	return ret;
+}
+
+static void xgbe_i2c_stop(struct xgbe_prv_data *pdata)
+{
+	if (!pdata->i2c.started)
+		return;
+
+	netif_dbg(pdata, link, pdata->netdev, "stopping I2C\n");
+
+	pdata->i2c.started = 0;
+
+	xgbe_i2c_disable_interrupts(pdata);
+	xgbe_i2c_disable(pdata);
+	xgbe_i2c_clear_all_interrupts(pdata);
+
+	if (pdata->dev_irq != pdata->i2c_irq)
+		devm_free_irq(pdata->dev, pdata->i2c_irq, pdata);
+}
+
+static int xgbe_i2c_start(struct xgbe_prv_data *pdata)
+{
+	int ret;
+
+	if (pdata->i2c.started)
+		return 0;
+
+	netif_dbg(pdata, link, pdata->netdev, "starting I2C\n");
+
+	/* If we have a separate I2C irq, enable it */
+	if (pdata->dev_irq != pdata->i2c_irq) {
+		ret = devm_request_irq(pdata->dev, pdata->i2c_irq,
+				       xgbe_i2c_isr, 0, pdata->i2c_name,
+				       pdata);
+		if (ret) {
+			netdev_err(pdata->netdev, "i2c irq request failed\n");
+			return ret;
+		}
+	}
+
+	pdata->i2c.started = 1;
+
+	return 0;
+}
+
+static int xgbe_i2c_init(struct xgbe_prv_data *pdata)
+{
+	int ret;
+
+	xgbe_i2c_disable_interrupts(pdata);
+
+	ret = xgbe_i2c_disable(pdata);
+	if (ret) {
+		dev_err(pdata->dev, "failed to disable i2c master\n");
+		return ret;
+	}
+
+	xgbe_i2c_get_features(pdata);
+
+	xgbe_i2c_set_mode(pdata);
+
+	xgbe_i2c_clear_all_interrupts(pdata);
+
+	return 0;
+}
+
+void xgbe_init_function_ptrs_i2c(struct xgbe_i2c_if *i2c_if)
+{
+	i2c_if->i2c_init		= xgbe_i2c_init;
+
+	i2c_if->i2c_start		= xgbe_i2c_start;
+	i2c_if->i2c_stop		= xgbe_i2c_stop;
+
+	i2c_if->i2c_xfer		= xgbe_i2c_xfer;
+
+	i2c_if->i2c_isr			= xgbe_i2c_combined_isr;
+}
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-main.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-pci.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe-phy-v2.c
* Unmerged path drivers/net/ethernet/amd/xgbe/xgbe.h
