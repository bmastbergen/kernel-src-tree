NTB: Document HW errata

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [ntb] Document HW errata (Suravee Suthikulpanit) [1303727]
Rebuild_FUZZ: 87.80%
commit-author Jon Mason <jon.mason@intel.com>
commit 58b889206ea4ba75a57986e223da647f91ba1a19
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/58b88920.failed

Add a comment describing the necessary ordering of modifications to the
NTB Limit and Base registers.

	Signed-off-by: Jon Mason <jon.mason@intel.com>
(cherry picked from commit 58b889206ea4ba75a57986e223da647f91ba1a19)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ntb/ntb_hw.c
diff --cc drivers/ntb/ntb_hw.c
index 5ff2ae362045,391c377a5d38..000000000000
--- a/drivers/ntb/ntb_hw.c
+++ b/drivers/ntb/ntb_hw.c
@@@ -558,104 -656,191 +558,288 @@@ static int ntb_xeon_setup(struct ntb_de
  	else
  		ndev->dev_type = NTB_DEV_DSD;
  
++<<<<<<< HEAD
 +	ndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
 +	ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;
 +	ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;
 +	ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;
++=======
+ 	switch (val & SNB_PPD_CONN_TYPE) {
+ 	case NTB_CONN_B2B:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = B2B\n");
+ 		ndev->conn_type = NTB_CONN_B2B;
+ 		ndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;
+ 		ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;
+ 		ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;
+ 		ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;
+ 		ndev->limits.max_spads = SNB_MAX_B2B_SPADS;
+ 
+ 		/* There is a Xeon hardware errata related to writes to
+ 		 * SDOORBELL or B2BDOORBELL in conjunction with inbound access
+ 		 * to NTB MMIO Space, which may hang the system.  To workaround
+ 		 * this use the second memory window to access the interrupt and
+ 		 * scratch pad registers on the remote system.
+ 		 */
+ 		if (xeon_errata_workaround) {
+ 			if (!ndev->mw[1].bar_sz)
+ 				return -EINVAL;
+ 
+ 			ndev->limits.max_mw = SNB_ERRATA_MAX_MW;
+ 			ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
+ 			ndev->reg_ofs.spad_write = ndev->mw[1].vbase +
+ 						   SNB_SPAD_OFFSET;
+ 			ndev->reg_ofs.rdb = ndev->mw[1].vbase +
+ 					    SNB_PDOORBELL_OFFSET;
+ 
+ 			/* Set the Limit register to 4k, the minimum size, to
+ 			 * prevent an illegal access
+ 			 */
+ 			writeq(ndev->mw[1].bar_sz + 0x1000, ndev->reg_base +
+ 			       SNB_PBAR4LMT_OFFSET);
+ 			/* HW errata on the Limit registers.  They can only be
+ 			 * written when the base register is 4GB aligned and
+ 			 * < 32bit.  This should already be the case based on the
+ 			 * driver defaults, but write the Limit registers first
+ 			 * just in case.
+ 			 */
+ 		} else {
+ 			ndev->limits.max_mw = SNB_MAX_MW;
+ 
+ 			/* HW Errata on bit 14 of b2bdoorbell register.  Writes
+ 			 * will not be mirrored to the remote system.  Shrink
+ 			 * the number of bits by one, since bit 14 is the last
+ 			 * bit.
+ 			 */
+ 			ndev->limits.max_db_bits = SNB_MAX_DB_BITS - 1;
+ 			ndev->reg_ofs.spad_write = ndev->reg_base +
+ 						   SNB_B2B_SPAD_OFFSET;
+ 			ndev->reg_ofs.rdb = ndev->reg_base +
+ 					    SNB_B2B_DOORBELL_OFFSET;
+ 
+ 			/* Disable the Limit register, just incase it is set to
+ 			 * something silly
+ 			 */
+ 			writeq(0, ndev->reg_base + SNB_PBAR4LMT_OFFSET);
+ 			/* HW errata on the Limit registers.  They can only be
+ 			 * written when the base register is 4GB aligned and
+ 			 * < 32bit.  This should already be the case based on the
+ 			 * driver defaults, but write the Limit registers first
+ 			 * just in case.
+ 			 */
+ 		}
+ 
+ 		/* The Xeon errata workaround requires setting SBAR Base
+ 		 * addresses to known values, so that the PBAR XLAT can be
+ 		 * pointed at SBAR0 of the remote system.
+ 		 */
+ 		if (ndev->dev_type == NTB_DEV_USD) {
+ 			writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
+ 			       SNB_PBAR2XLAT_OFFSET);
+ 			if (xeon_errata_workaround)
+ 				writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 			else {
+ 				writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 				/* B2B_XLAT_OFFSET is a 64bit register, but can
+ 				 * only take 32bit writes
+ 				 */
+ 				writel(SNB_MBAR01_DSD_ADDR & 0xffffffff,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
+ 				writel(SNB_MBAR01_DSD_ADDR >> 32,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
+ 			}
+ 
+ 			writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR0BASE_OFFSET);
+ 			writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR2BASE_OFFSET);
+ 			writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR4BASE_OFFSET);
+ 		} else {
+ 			writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
+ 			       SNB_PBAR2XLAT_OFFSET);
+ 			if (xeon_errata_workaround)
+ 				writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 			else {
+ 				writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
+ 				       SNB_PBAR4XLAT_OFFSET);
+ 				/* B2B_XLAT_OFFSET is a 64bit register, but can
+ 				 * only take 32bit writes
+ 				 */
+ 				writel(SNB_MBAR01_DSD_ADDR & 0xffffffff,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
+ 				writel(SNB_MBAR01_USD_ADDR >> 32,
+ 				       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
+ 			}
+ 			writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR0BASE_OFFSET);
+ 			writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR2BASE_OFFSET);
+ 			writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
+ 			       SNB_SBAR4BASE_OFFSET);
+ 		}
+ 		break;
+ 	case NTB_CONN_RP:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = RP\n");
+ 		ndev->conn_type = NTB_CONN_RP;
+ 
+ 		if (xeon_errata_workaround) {
+ 			dev_err(&ndev->pdev->dev, 
+ 				"NTB-RP disabled due to hardware errata.  To disregard this warning and potentially lock-up the system, add the parameter 'xeon_errata_workaround=0'.\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		/* Scratch pads need to have exclusive access from the primary
+ 		 * or secondary side.  Halve the num spads so that each side can
+ 		 * have an equal amount.
+ 		 */
+ 		ndev->limits.max_spads = SNB_MAX_COMPAT_SPADS / 2;
+ 		ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
+ 		/* Note: The SDOORBELL is the cause of the errata.  You REALLY
+ 		 * don't want to touch it.
+ 		 */
+ 		ndev->reg_ofs.rdb = ndev->reg_base + SNB_SDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;
+ 		/* Offset the start of the spads to correspond to whether it is
+ 		 * primary or secondary
+ 		 */
+ 		ndev->reg_ofs.spad_write = ndev->reg_base + SNB_SPAD_OFFSET +
+ 					   ndev->limits.max_spads * 4;
+ 		ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;
+ 		ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;
+ 		ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;
+ 		ndev->limits.max_mw = SNB_MAX_MW;
+ 		break;
+ 	case NTB_CONN_TRANSPARENT:
+ 		dev_info(&ndev->pdev->dev, "Conn Type = TRANSPARENT\n");
+ 		ndev->conn_type = NTB_CONN_TRANSPARENT;
+ 		/* Scratch pads need to have exclusive access from the primary
+ 		 * or secondary side.  Halve the num spads so that each side can
+ 		 * have an equal amount.
+ 		 */
+ 		ndev->limits.max_spads = SNB_MAX_COMPAT_SPADS / 2;
+ 		ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
+ 		ndev->reg_ofs.rdb = ndev->reg_base + SNB_PDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb = ndev->reg_base + SNB_SDOORBELL_OFFSET;
+ 		ndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_SDBMSK_OFFSET;
+ 		ndev->reg_ofs.spad_write = ndev->reg_base + SNB_SPAD_OFFSET;
+ 		/* Offset the start of the spads to correspond to whether it is
+ 		 * primary or secondary
+ 		 */
+ 		ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET +
+ 					  ndev->limits.max_spads * 4;
+ 		ndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_PBAR2XLAT_OFFSET;
+ 		ndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_PBAR4XLAT_OFFSET;
+ 
+ 		ndev->limits.max_mw = SNB_MAX_MW;
+ 		break;
+ 	default:
+ 		/* Most likely caused by the remote NTB-RP device not being
+ 		 * configured
+ 		 */
+ 		dev_err(&ndev->pdev->dev, "Unknown PPD %x\n", val);
+ 		return -EINVAL;
+ 	}
+ 
++>>>>>>> 58b889206ea4 (NTB: Document HW errata)
  	ndev->reg_ofs.lnk_cntl = ndev->reg_base + SNB_NTBCNTL_OFFSET;
 -	ndev->reg_ofs.lnk_stat = ndev->reg_base + SNB_SLINK_STATUS_OFFSET;
 +	ndev->reg_ofs.lnk_stat = ndev->reg_base + SNB_LINK_STATUS_OFFSET;
 +	ndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;
  	ndev->reg_ofs.spci_cmd = ndev->reg_base + SNB_PCICMD_OFFSET;
  
 +	/* There is a Xeon hardware errata related to writes to
 +	 * SDOORBELL or B2BDOORBELL in conjunction with inbound access
 +	 * to NTB MMIO Space, which may hang the system.  To workaround
 +	 * this use the second memory window to access the interrupt and
 +	 * scratch pad registers on the remote system.
 +	 */
 +	if (xeon_errata_workaround) {
 +		if (!ndev->mw[1].bar_sz)
 +			return -EINVAL;
 +
 +		ndev->limits.max_mw = SNB_ERRATA_MAX_MW;
 +		ndev->reg_ofs.spad_write = ndev->mw[1].vbase +
 +					   SNB_SPAD_OFFSET;
 +		ndev->reg_ofs.rdb = ndev->mw[1].vbase +
 +				    SNB_PDOORBELL_OFFSET;
 +
 +		/* Set the Limit register to 4k, the minimum size, to
 +		 * prevent an illegal access
 +		 */
 +		writeq(ndev->mw[1].bar_sz + 0x1000, ndev->reg_base +
 +		       SNB_PBAR4LMT_OFFSET);
 +	} else {
 +		ndev->limits.max_mw = SNB_MAX_MW;
 +		ndev->reg_ofs.spad_write = ndev->reg_base +
 +					   SNB_B2B_SPAD_OFFSET;
 +		ndev->reg_ofs.rdb = ndev->reg_base +
 +				    SNB_B2B_DOORBELL_OFFSET;
 +
 +		/* Disable the Limit register, just incase it is set to
 +		 * something silly
 +		 */
 +		writeq(0, ndev->reg_base + SNB_PBAR4LMT_OFFSET);
 +	}
 +
 +	/* The Xeon errata workaround requires setting SBAR Base
 +	 * addresses to known values, so that the PBAR XLAT can be
 +	 * pointed at SBAR0 of the remote system.
 +	 */
 +	if (ndev->dev_type == NTB_DEV_USD) {
 +		writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
 +		       SNB_PBAR2XLAT_OFFSET);
 +		if (xeon_errata_workaround)
 +			writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
 +			       SNB_PBAR4XLAT_OFFSET);
 +		else {
 +			writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
 +			       SNB_PBAR4XLAT_OFFSET);
 +			/* B2B_XLAT_OFFSET is a 64bit register, but can
 +			 * only take 32bit writes
 +			 */
 +			writel(SNB_MBAR01_USD_ADDR & 0xffffffff,
 +			       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
 +			writel(SNB_MBAR01_DSD_ADDR >> 32,
 +			       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
 +		}
 +
 +		writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
 +		       SNB_SBAR0BASE_OFFSET);
 +		writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
 +		       SNB_SBAR2BASE_OFFSET);
 +		writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
 +		       SNB_SBAR4BASE_OFFSET);
 +	} else {
 +		writeq(SNB_MBAR23_USD_ADDR, ndev->reg_base +
 +		       SNB_PBAR2XLAT_OFFSET);
 +		if (xeon_errata_workaround)
 +			writeq(SNB_MBAR01_USD_ADDR, ndev->reg_base +
 +			       SNB_PBAR4XLAT_OFFSET);
 +		else {
 +			writeq(SNB_MBAR45_USD_ADDR, ndev->reg_base +
 +			       SNB_PBAR4XLAT_OFFSET);
 +			/* B2B_XLAT_OFFSET is a 64bit register, but can
 +			 * only take 32bit writes
 +			 */
 +			writel(SNB_MBAR01_USD_ADDR & 0xffffffff,
 +			       ndev->reg_base + SNB_B2B_XLAT_OFFSETL);
 +			writel(SNB_MBAR01_USD_ADDR >> 32,
 +			       ndev->reg_base + SNB_B2B_XLAT_OFFSETU);
 +		}
 +		writeq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +
 +		       SNB_SBAR0BASE_OFFSET);
 +		writeq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +
 +		       SNB_SBAR2BASE_OFFSET);
 +		writeq(SNB_MBAR45_DSD_ADDR, ndev->reg_base +
 +		       SNB_SBAR4BASE_OFFSET);
 +	}
 +
 +	ndev->limits.max_spads = SNB_MAX_B2B_SPADS;
 +	ndev->limits.max_db_bits = SNB_MAX_DB_BITS;
  	ndev->limits.msix_cnt = SNB_MSIX_CNT;
  	ndev->bits_per_vector = SNB_DB_BITS_PER_VEC;
  
* Unmerged path drivers/ntb/ntb_hw.c
