bridge: netlink: export per-vlan stats

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
commit a60c090361ea211625c27052dbbc11c5222e20e4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a60c0903.failed

Add a new LINK_XSTATS_TYPE_BRIDGE attribute and implement the
RTM_GETSTATS callbacks for IFLA_STATS_LINK_XSTATS (fill_linkxstats and
get_linkxstats_size) in order to export the per-vlan stats.
The paddings were added because soon these fields will be needed for
per-port per-vlan stats (or something else if someone beats me to it) so
avoiding at least a few more netlink attributes.

	Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a60c090361ea211625c27052dbbc11c5222e20e4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_link.h
#	net/bridge/br_netlink.c
#	net/bridge/br_private.h
diff --cc include/uapi/linux/if_link.h
index 1b43f8aab560,d2d7fd4ba5f5..000000000000
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@@ -665,4 -779,56 +665,59 @@@ enum 
  
  #define IFLA_IPOIB_MAX (__IFLA_IPOIB_MAX - 1)
  
++<<<<<<< HEAD
++=======
+ 
+ /* HSR section */
+ 
+ enum {
+ 	IFLA_HSR_UNSPEC,
+ 	IFLA_HSR_SLAVE1,
+ 	IFLA_HSR_SLAVE2,
+ 	IFLA_HSR_MULTICAST_SPEC,	/* Last byte of supervision addr */
+ 	IFLA_HSR_SUPERVISION_ADDR,	/* Supervision frame multicast addr */
+ 	IFLA_HSR_SEQ_NR,
+ 	IFLA_HSR_VERSION,		/* HSR version */
+ 	__IFLA_HSR_MAX,
+ };
+ 
+ #define IFLA_HSR_MAX (__IFLA_HSR_MAX - 1)
+ 
+ /* STATS section */
+ 
+ struct if_stats_msg {
+ 	__u8  family;
+ 	__u8  pad1;
+ 	__u16 pad2;
+ 	__u32 ifindex;
+ 	__u32 filter_mask;
+ };
+ 
+ /* A stats attribute can be netdev specific or a global stat.
+  * For netdev stats, lets use the prefix IFLA_STATS_LINK_*
+  */
+ enum {
+ 	IFLA_STATS_UNSPEC, /* also used as 64bit pad attribute */
+ 	IFLA_STATS_LINK_64,
+ 	IFLA_STATS_LINK_XSTATS,
+ 	__IFLA_STATS_MAX,
+ };
+ 
+ #define IFLA_STATS_MAX (__IFLA_STATS_MAX - 1)
+ 
+ #define IFLA_STATS_FILTER_BIT(ATTR)	(1 << (ATTR - 1))
+ 
+ /* These are embedded into IFLA_STATS_LINK_XSTATS:
+  * [IFLA_STATS_LINK_XSTATS]
+  * -> [LINK_XSTATS_TYPE_xxx]
+  *    -> [rtnl link type specific attributes]
+  */
+ enum {
+ 	LINK_XSTATS_TYPE_UNSPEC,
+ 	LINK_XSTATS_TYPE_BRIDGE,
+ 	__LINK_XSTATS_TYPE_MAX
+ };
+ #define LINK_XSTATS_TYPE_MAX (__LINK_XSTATS_TYPE_MAX - 1)
+ 
++>>>>>>> a60c090361ea (bridge: netlink: export per-vlan stats)
  #endif /* _UAPI_LINUX_IF_LINK_H */
diff --cc net/bridge/br_netlink.c
index 2f4d900feeb1,a5343c7232bf..000000000000
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@@ -648,38 -789,540 +648,283 @@@ static int br_dev_newlink(struct net *s
  	return register_netdevice(dev);
  }
  
 -static int br_port_slave_changelink(struct net_device *brdev,
 -				    struct net_device *dev,
 -				    struct nlattr *tb[],
 -				    struct nlattr *data[])
 +static size_t br_get_link_af_size(const struct net_device *dev)
  {
 -	struct net_bridge *br = netdev_priv(brdev);
 -	int ret;
 +	struct net_port_vlans *pv;
  
 -	if (!data)
 +	if (br_port_exists(dev))
 +		pv = nbp_get_vlan_info(br_port_get_rtnl(dev));
 +	else if (dev->priv_flags & IFF_EBRIDGE)
 +		pv = br_get_vlan_info((struct net_bridge *)netdev_priv(dev));
 +	else
  		return 0;
  
 -	spin_lock_bh(&br->lock);
 -	ret = br_setport(br_port_get_rtnl(dev), data);
 -	spin_unlock_bh(&br->lock);
 -
 -	return ret;
 -}
 -
 -static int br_port_fill_slave_info(struct sk_buff *skb,
 -				   const struct net_device *brdev,
 -				   const struct net_device *dev)
 -{
 -	return br_port_fill_attrs(skb, br_port_get_rtnl(dev));
 -}
 -
 -static size_t br_port_get_slave_size(const struct net_device *brdev,
 -				     const struct net_device *dev)
 -{
 -	return br_port_info_size();
 -}
 -
 -static const struct nla_policy br_policy[IFLA_BR_MAX + 1] = {
 -	[IFLA_BR_FORWARD_DELAY]	= { .type = NLA_U32 },
 -	[IFLA_BR_HELLO_TIME]	= { .type = NLA_U32 },
 -	[IFLA_BR_MAX_AGE]	= { .type = NLA_U32 },
 -	[IFLA_BR_AGEING_TIME] = { .type = NLA_U32 },
 -	[IFLA_BR_STP_STATE] = { .type = NLA_U32 },
 -	[IFLA_BR_PRIORITY] = { .type = NLA_U16 },
 -	[IFLA_BR_VLAN_FILTERING] = { .type = NLA_U8 },
 -	[IFLA_BR_VLAN_PROTOCOL] = { .type = NLA_U16 },
 -	[IFLA_BR_GROUP_FWD_MASK] = { .type = NLA_U16 },
 -	[IFLA_BR_GROUP_ADDR] = { .type = NLA_BINARY,
 -				 .len  = ETH_ALEN },
 -	[IFLA_BR_MCAST_ROUTER] = { .type = NLA_U8 },
 -	[IFLA_BR_MCAST_SNOOPING] = { .type = NLA_U8 },
 -	[IFLA_BR_MCAST_QUERY_USE_IFADDR] = { .type = NLA_U8 },
 -	[IFLA_BR_MCAST_QUERIER] = { .type = NLA_U8 },
 -	[IFLA_BR_MCAST_HASH_ELASTICITY] = { .type = NLA_U32 },
 -	[IFLA_BR_MCAST_HASH_MAX] = { .type = NLA_U32 },
 -	[IFLA_BR_MCAST_LAST_MEMBER_CNT] = { .type = NLA_U32 },
 -	[IFLA_BR_MCAST_STARTUP_QUERY_CNT] = { .type = NLA_U32 },
 -	[IFLA_BR_MCAST_LAST_MEMBER_INTVL] = { .type = NLA_U64 },
 -	[IFLA_BR_MCAST_MEMBERSHIP_INTVL] = { .type = NLA_U64 },
 -	[IFLA_BR_MCAST_QUERIER_INTVL] = { .type = NLA_U64 },
 -	[IFLA_BR_MCAST_QUERY_INTVL] = { .type = NLA_U64 },
 -	[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL] = { .type = NLA_U64 },
 -	[IFLA_BR_MCAST_STARTUP_QUERY_INTVL] = { .type = NLA_U64 },
 -	[IFLA_BR_NF_CALL_IPTABLES] = { .type = NLA_U8 },
 -	[IFLA_BR_NF_CALL_IP6TABLES] = { .type = NLA_U8 },
 -	[IFLA_BR_NF_CALL_ARPTABLES] = { .type = NLA_U8 },
 -	[IFLA_BR_VLAN_DEFAULT_PVID] = { .type = NLA_U16 },
 -	[IFLA_BR_VLAN_STATS_ENABLED] = { .type = NLA_U8 },
 -};
 -
 -static int br_changelink(struct net_device *brdev, struct nlattr *tb[],
 -			 struct nlattr *data[])
 -{
 -	struct net_bridge *br = netdev_priv(brdev);
 -	int err;
 -
 -	if (!data)
 +	if (!pv)
  		return 0;
  
 -	if (data[IFLA_BR_FORWARD_DELAY]) {
 -		err = br_set_forward_delay(br, nla_get_u32(data[IFLA_BR_FORWARD_DELAY]));
 -		if (err)
 -			return err;
 -	}
 -
 -	if (data[IFLA_BR_HELLO_TIME]) {
 -		err = br_set_hello_time(br, nla_get_u32(data[IFLA_BR_HELLO_TIME]));
 -		if (err)
 -			return err;
 -	}
 -
 -	if (data[IFLA_BR_MAX_AGE]) {
 -		err = br_set_max_age(br, nla_get_u32(data[IFLA_BR_MAX_AGE]));
 -		if (err)
 -			return err;
 -	}
 -
 -	if (data[IFLA_BR_AGEING_TIME]) {
 -		err = br_set_ageing_time(br, nla_get_u32(data[IFLA_BR_AGEING_TIME]));
 -		if (err)
 -			return err;
 -	}
 -
 -	if (data[IFLA_BR_STP_STATE]) {
 -		u32 stp_enabled = nla_get_u32(data[IFLA_BR_STP_STATE]);
 -
 -		br_stp_set_enabled(br, stp_enabled);
 -	}
 -
 -	if (data[IFLA_BR_PRIORITY]) {
 -		u32 priority = nla_get_u16(data[IFLA_BR_PRIORITY]);
 -
 -		br_stp_set_bridge_priority(br, priority);
 -	}
 -
 -	if (data[IFLA_BR_VLAN_FILTERING]) {
 -		u8 vlan_filter = nla_get_u8(data[IFLA_BR_VLAN_FILTERING]);
 -
 -		err = __br_vlan_filter_toggle(br, vlan_filter);
 -		if (err)
 -			return err;
 -	}
 -
 -#ifdef CONFIG_BRIDGE_VLAN_FILTERING
 -	if (data[IFLA_BR_VLAN_PROTOCOL]) {
 -		__be16 vlan_proto = nla_get_be16(data[IFLA_BR_VLAN_PROTOCOL]);
 -
 -		err = __br_vlan_set_proto(br, vlan_proto);
 -		if (err)
 -			return err;
 -	}
 -
 -	if (data[IFLA_BR_VLAN_DEFAULT_PVID]) {
 -		__u16 defpvid = nla_get_u16(data[IFLA_BR_VLAN_DEFAULT_PVID]);
 -
 -		err = __br_vlan_set_default_pvid(br, defpvid);
 -		if (err)
 -			return err;
 -	}
 -
 -	if (data[IFLA_BR_VLAN_STATS_ENABLED]) {
 -		__u8 vlan_stats = nla_get_u8(data[IFLA_BR_VLAN_STATS_ENABLED]);
 -
 -		err = br_vlan_set_stats(br, vlan_stats);
 -		if (err)
 -			return err;
 -	}
 -#endif
 -
 -	if (data[IFLA_BR_GROUP_FWD_MASK]) {
 -		u16 fwd_mask = nla_get_u16(data[IFLA_BR_GROUP_FWD_MASK]);
 -
 -		if (fwd_mask & BR_GROUPFWD_RESTRICTED)
 -			return -EINVAL;
 -		br->group_fwd_mask = fwd_mask;
 -	}
 -
 -	if (data[IFLA_BR_GROUP_ADDR]) {
 -		u8 new_addr[ETH_ALEN];
 -
 -		if (nla_len(data[IFLA_BR_GROUP_ADDR]) != ETH_ALEN)
 -			return -EINVAL;
 -		memcpy(new_addr, nla_data(data[IFLA_BR_GROUP_ADDR]), ETH_ALEN);
 -		if (!is_link_local_ether_addr(new_addr))
 -			return -EINVAL;
 -		if (new_addr[5] == 1 ||		/* 802.3x Pause address */
 -		    new_addr[5] == 2 ||		/* 802.3ad Slow protocols */
 -		    new_addr[5] == 3)		/* 802.1X PAE address */
 -			return -EINVAL;
 -		spin_lock_bh(&br->lock);
 -		memcpy(br->group_addr, new_addr, sizeof(br->group_addr));
 -		spin_unlock_bh(&br->lock);
 -		br->group_addr_set = true;
 -		br_recalculate_fwd_mask(br);
 -	}
 -
 -	if (data[IFLA_BR_FDB_FLUSH])
 -		br_fdb_flush(br);
 -
 -#ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 -	if (data[IFLA_BR_MCAST_ROUTER]) {
 -		u8 multicast_router = nla_get_u8(data[IFLA_BR_MCAST_ROUTER]);
 -
 -		err = br_multicast_set_router(br, multicast_router);
 -		if (err)
 -			return err;
 -	}
 -
 -	if (data[IFLA_BR_MCAST_SNOOPING]) {
 -		u8 mcast_snooping = nla_get_u8(data[IFLA_BR_MCAST_SNOOPING]);
 -
 -		err = br_multicast_toggle(br, mcast_snooping);
 -		if (err)
 -			return err;
 -	}
 -
 -	if (data[IFLA_BR_MCAST_QUERY_USE_IFADDR]) {
 -		u8 val;
 -
 -		val = nla_get_u8(data[IFLA_BR_MCAST_QUERY_USE_IFADDR]);
 -		br->multicast_query_use_ifaddr = !!val;
 -	}
 -
 -	if (data[IFLA_BR_MCAST_QUERIER]) {
 -		u8 mcast_querier = nla_get_u8(data[IFLA_BR_MCAST_QUERIER]);
 -
 -		err = br_multicast_set_querier(br, mcast_querier);
 -		if (err)
 -			return err;
 -	}
 -
 -	if (data[IFLA_BR_MCAST_HASH_ELASTICITY]) {
 -		u32 val = nla_get_u32(data[IFLA_BR_MCAST_HASH_ELASTICITY]);
 -
 -		br->hash_elasticity = val;
 -	}
 -
 -	if (data[IFLA_BR_MCAST_HASH_MAX]) {
 -		u32 hash_max = nla_get_u32(data[IFLA_BR_MCAST_HASH_MAX]);
 -
 -		err = br_multicast_set_hash_max(br, hash_max);
 -		if (err)
 -			return err;
 -	}
 -
 -	if (data[IFLA_BR_MCAST_LAST_MEMBER_CNT]) {
 -		u32 val = nla_get_u32(data[IFLA_BR_MCAST_LAST_MEMBER_CNT]);
 -
 -		br->multicast_last_member_count = val;
 -	}
 -
 -	if (data[IFLA_BR_MCAST_STARTUP_QUERY_CNT]) {
 -		u32 val = nla_get_u32(data[IFLA_BR_MCAST_STARTUP_QUERY_CNT]);
 -
 -		br->multicast_startup_query_count = val;
 -	}
 -
 -	if (data[IFLA_BR_MCAST_LAST_MEMBER_INTVL]) {
 -		u64 val = nla_get_u64(data[IFLA_BR_MCAST_LAST_MEMBER_INTVL]);
 -
 -		br->multicast_last_member_interval = clock_t_to_jiffies(val);
 -	}
 -
 -	if (data[IFLA_BR_MCAST_MEMBERSHIP_INTVL]) {
 -		u64 val = nla_get_u64(data[IFLA_BR_MCAST_MEMBERSHIP_INTVL]);
 -
 -		br->multicast_membership_interval = clock_t_to_jiffies(val);
 -	}
 -
 -	if (data[IFLA_BR_MCAST_QUERIER_INTVL]) {
 -		u64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERIER_INTVL]);
 -
 -		br->multicast_querier_interval = clock_t_to_jiffies(val);
 -	}
 -
 -	if (data[IFLA_BR_MCAST_QUERY_INTVL]) {
 -		u64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERY_INTVL]);
 -
 -		br->multicast_query_interval = clock_t_to_jiffies(val);
 -	}
 -
 -	if (data[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL]) {
 -		u64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL]);
 -
 -		br->multicast_query_response_interval = clock_t_to_jiffies(val);
 -	}
 -
 -	if (data[IFLA_BR_MCAST_STARTUP_QUERY_INTVL]) {
 -		u64 val = nla_get_u64(data[IFLA_BR_MCAST_STARTUP_QUERY_INTVL]);
 -
 -		br->multicast_startup_query_interval = clock_t_to_jiffies(val);
 -	}
 -#endif
 -#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
 -	if (data[IFLA_BR_NF_CALL_IPTABLES]) {
 -		u8 val = nla_get_u8(data[IFLA_BR_NF_CALL_IPTABLES]);
 -
 -		br->nf_call_iptables = val ? true : false;
 -	}
 -
 -	if (data[IFLA_BR_NF_CALL_IP6TABLES]) {
 -		u8 val = nla_get_u8(data[IFLA_BR_NF_CALL_IP6TABLES]);
 -
 -		br->nf_call_ip6tables = val ? true : false;
 -	}
 -
 -	if (data[IFLA_BR_NF_CALL_ARPTABLES]) {
 -		u8 val = nla_get_u8(data[IFLA_BR_NF_CALL_ARPTABLES]);
 -
 -		br->nf_call_arptables = val ? true : false;
 -	}
 -#endif
 -
 -	return 0;
 +	/* Each VLAN is returned in bridge_vlan_info along with flags */
 +	return pv->num_vlans * nla_total_size(sizeof(struct bridge_vlan_info));
  }
  
++<<<<<<< HEAD
 +static struct rtnl_af_ops br_af_ops = {
++=======
+ static size_t br_get_size(const struct net_device *brdev)
+ {
+ 	return nla_total_size(sizeof(u32)) +	/* IFLA_BR_FORWARD_DELAY  */
+ 	       nla_total_size(sizeof(u32)) +	/* IFLA_BR_HELLO_TIME */
+ 	       nla_total_size(sizeof(u32)) +	/* IFLA_BR_MAX_AGE */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_AGEING_TIME */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_STP_STATE */
+ 	       nla_total_size(sizeof(u16)) +    /* IFLA_BR_PRIORITY */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_VLAN_FILTERING */
+ #ifdef CONFIG_BRIDGE_VLAN_FILTERING
+ 	       nla_total_size(sizeof(__be16)) +	/* IFLA_BR_VLAN_PROTOCOL */
+ 	       nla_total_size(sizeof(u16)) +    /* IFLA_BR_VLAN_DEFAULT_PVID */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_VLAN_STATS_ENABLED */
+ #endif
+ 	       nla_total_size(sizeof(u16)) +    /* IFLA_BR_GROUP_FWD_MASK */
+ 	       nla_total_size(sizeof(struct ifla_bridge_id)) +   /* IFLA_BR_ROOT_ID */
+ 	       nla_total_size(sizeof(struct ifla_bridge_id)) +   /* IFLA_BR_BRIDGE_ID */
+ 	       nla_total_size(sizeof(u16)) +    /* IFLA_BR_ROOT_PORT */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_ROOT_PATH_COST */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_TOPOLOGY_CHANGE */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_TOPOLOGY_CHANGE_DETECTED */
+ 	       nla_total_size_64bit(sizeof(u64)) + /* IFLA_BR_HELLO_TIMER */
+ 	       nla_total_size_64bit(sizeof(u64)) + /* IFLA_BR_TCN_TIMER */
+ 	       nla_total_size_64bit(sizeof(u64)) + /* IFLA_BR_TOPOLOGY_CHANGE_TIMER */
+ 	       nla_total_size_64bit(sizeof(u64)) + /* IFLA_BR_GC_TIMER */
+ 	       nla_total_size(ETH_ALEN) +       /* IFLA_BR_GROUP_ADDR */
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_MCAST_ROUTER */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_MCAST_SNOOPING */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_MCAST_QUERY_USE_IFADDR */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_MCAST_QUERIER */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_MCAST_HASH_ELASTICITY */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_MCAST_HASH_MAX */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_MCAST_LAST_MEMBER_CNT */
+ 	       nla_total_size(sizeof(u32)) +    /* IFLA_BR_MCAST_STARTUP_QUERY_CNT */
+ 	       nla_total_size_64bit(sizeof(u64)) + /* IFLA_BR_MCAST_LAST_MEMBER_INTVL */
+ 	       nla_total_size_64bit(sizeof(u64)) + /* IFLA_BR_MCAST_MEMBERSHIP_INTVL */
+ 	       nla_total_size_64bit(sizeof(u64)) + /* IFLA_BR_MCAST_QUERIER_INTVL */
+ 	       nla_total_size_64bit(sizeof(u64)) + /* IFLA_BR_MCAST_QUERY_INTVL */
+ 	       nla_total_size_64bit(sizeof(u64)) + /* IFLA_BR_MCAST_QUERY_RESPONSE_INTVL */
+ 	       nla_total_size_64bit(sizeof(u64)) + /* IFLA_BR_MCAST_STARTUP_QUERY_INTVL */
+ #endif
+ #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_NF_CALL_IPTABLES */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_NF_CALL_IP6TABLES */
+ 	       nla_total_size(sizeof(u8)) +     /* IFLA_BR_NF_CALL_ARPTABLES */
+ #endif
+ 	       0;
+ }
+ 
+ static int br_fill_info(struct sk_buff *skb, const struct net_device *brdev)
+ {
+ 	struct net_bridge *br = netdev_priv(brdev);
+ 	u32 forward_delay = jiffies_to_clock_t(br->forward_delay);
+ 	u32 hello_time = jiffies_to_clock_t(br->hello_time);
+ 	u32 age_time = jiffies_to_clock_t(br->max_age);
+ 	u32 ageing_time = jiffies_to_clock_t(br->ageing_time);
+ 	u32 stp_enabled = br->stp_enabled;
+ 	u16 priority = (br->bridge_id.prio[0] << 8) | br->bridge_id.prio[1];
+ 	u8 vlan_enabled = br_vlan_enabled(br);
+ 	u64 clockval;
+ 
+ 	clockval = br_timer_value(&br->hello_timer);
+ 	if (nla_put_u64_64bit(skb, IFLA_BR_HELLO_TIMER, clockval, IFLA_BR_PAD))
+ 		return -EMSGSIZE;
+ 	clockval = br_timer_value(&br->tcn_timer);
+ 	if (nla_put_u64_64bit(skb, IFLA_BR_TCN_TIMER, clockval, IFLA_BR_PAD))
+ 		return -EMSGSIZE;
+ 	clockval = br_timer_value(&br->topology_change_timer);
+ 	if (nla_put_u64_64bit(skb, IFLA_BR_TOPOLOGY_CHANGE_TIMER, clockval,
+ 			      IFLA_BR_PAD))
+ 		return -EMSGSIZE;
+ 	clockval = br_timer_value(&br->gc_timer);
+ 	if (nla_put_u64_64bit(skb, IFLA_BR_GC_TIMER, clockval, IFLA_BR_PAD))
+ 		return -EMSGSIZE;
+ 
+ 	if (nla_put_u32(skb, IFLA_BR_FORWARD_DELAY, forward_delay) ||
+ 	    nla_put_u32(skb, IFLA_BR_HELLO_TIME, hello_time) ||
+ 	    nla_put_u32(skb, IFLA_BR_MAX_AGE, age_time) ||
+ 	    nla_put_u32(skb, IFLA_BR_AGEING_TIME, ageing_time) ||
+ 	    nla_put_u32(skb, IFLA_BR_STP_STATE, stp_enabled) ||
+ 	    nla_put_u16(skb, IFLA_BR_PRIORITY, priority) ||
+ 	    nla_put_u8(skb, IFLA_BR_VLAN_FILTERING, vlan_enabled) ||
+ 	    nla_put_u16(skb, IFLA_BR_GROUP_FWD_MASK, br->group_fwd_mask) ||
+ 	    nla_put(skb, IFLA_BR_BRIDGE_ID, sizeof(struct ifla_bridge_id),
+ 		    &br->bridge_id) ||
+ 	    nla_put(skb, IFLA_BR_ROOT_ID, sizeof(struct ifla_bridge_id),
+ 		    &br->designated_root) ||
+ 	    nla_put_u16(skb, IFLA_BR_ROOT_PORT, br->root_port) ||
+ 	    nla_put_u32(skb, IFLA_BR_ROOT_PATH_COST, br->root_path_cost) ||
+ 	    nla_put_u8(skb, IFLA_BR_TOPOLOGY_CHANGE, br->topology_change) ||
+ 	    nla_put_u8(skb, IFLA_BR_TOPOLOGY_CHANGE_DETECTED,
+ 		       br->topology_change_detected) ||
+ 	    nla_put(skb, IFLA_BR_GROUP_ADDR, ETH_ALEN, br->group_addr))
+ 		return -EMSGSIZE;
+ 
+ #ifdef CONFIG_BRIDGE_VLAN_FILTERING
+ 	if (nla_put_be16(skb, IFLA_BR_VLAN_PROTOCOL, br->vlan_proto) ||
+ 	    nla_put_u16(skb, IFLA_BR_VLAN_DEFAULT_PVID, br->default_pvid) ||
+ 	    nla_put_u8(skb, IFLA_BR_VLAN_STATS_ENABLED, br->vlan_stats_enabled))
+ 		return -EMSGSIZE;
+ #endif
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	if (nla_put_u8(skb, IFLA_BR_MCAST_ROUTER, br->multicast_router) ||
+ 	    nla_put_u8(skb, IFLA_BR_MCAST_SNOOPING, !br->multicast_disabled) ||
+ 	    nla_put_u8(skb, IFLA_BR_MCAST_QUERY_USE_IFADDR,
+ 		       br->multicast_query_use_ifaddr) ||
+ 	    nla_put_u8(skb, IFLA_BR_MCAST_QUERIER, br->multicast_querier) ||
+ 	    nla_put_u32(skb, IFLA_BR_MCAST_HASH_ELASTICITY,
+ 			br->hash_elasticity) ||
+ 	    nla_put_u32(skb, IFLA_BR_MCAST_HASH_MAX, br->hash_max) ||
+ 	    nla_put_u32(skb, IFLA_BR_MCAST_LAST_MEMBER_CNT,
+ 			br->multicast_last_member_count) ||
+ 	    nla_put_u32(skb, IFLA_BR_MCAST_STARTUP_QUERY_CNT,
+ 			br->multicast_startup_query_count))
+ 		return -EMSGSIZE;
+ 
+ 	clockval = jiffies_to_clock_t(br->multicast_last_member_interval);
+ 	if (nla_put_u64_64bit(skb, IFLA_BR_MCAST_LAST_MEMBER_INTVL, clockval,
+ 			      IFLA_BR_PAD))
+ 		return -EMSGSIZE;
+ 	clockval = jiffies_to_clock_t(br->multicast_membership_interval);
+ 	if (nla_put_u64_64bit(skb, IFLA_BR_MCAST_MEMBERSHIP_INTVL, clockval,
+ 			      IFLA_BR_PAD))
+ 		return -EMSGSIZE;
+ 	clockval = jiffies_to_clock_t(br->multicast_querier_interval);
+ 	if (nla_put_u64_64bit(skb, IFLA_BR_MCAST_QUERIER_INTVL, clockval,
+ 			      IFLA_BR_PAD))
+ 		return -EMSGSIZE;
+ 	clockval = jiffies_to_clock_t(br->multicast_query_interval);
+ 	if (nla_put_u64_64bit(skb, IFLA_BR_MCAST_QUERY_INTVL, clockval,
+ 			      IFLA_BR_PAD))
+ 		return -EMSGSIZE;
+ 	clockval = jiffies_to_clock_t(br->multicast_query_response_interval);
+ 	if (nla_put_u64_64bit(skb, IFLA_BR_MCAST_QUERY_RESPONSE_INTVL, clockval,
+ 			      IFLA_BR_PAD))
+ 		return -EMSGSIZE;
+ 	clockval = jiffies_to_clock_t(br->multicast_startup_query_interval);
+ 	if (nla_put_u64_64bit(skb, IFLA_BR_MCAST_STARTUP_QUERY_INTVL, clockval,
+ 			      IFLA_BR_PAD))
+ 		return -EMSGSIZE;
+ #endif
+ #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
+ 	if (nla_put_u8(skb, IFLA_BR_NF_CALL_IPTABLES,
+ 		       br->nf_call_iptables ? 1 : 0) ||
+ 	    nla_put_u8(skb, IFLA_BR_NF_CALL_IP6TABLES,
+ 		       br->nf_call_ip6tables ? 1 : 0) ||
+ 	    nla_put_u8(skb, IFLA_BR_NF_CALL_ARPTABLES,
+ 		       br->nf_call_arptables ? 1 : 0))
+ 		return -EMSGSIZE;
+ #endif
+ 
+ 	return 0;
+ }
+ 
+ static size_t br_get_linkxstats_size(const struct net_device *dev)
+ {
+ 	struct net_bridge *br = netdev_priv(dev);
+ 	struct net_bridge_vlan_group *vg;
+ 	struct net_bridge_vlan *v;
+ 	int numvls = 0;
+ 
+ 	vg = br_vlan_group(br);
+ 	if (!vg)
+ 		return 0;
+ 
+ 	/* we need to count all, even placeholder entries */
+ 	list_for_each_entry(v, &vg->vlan_list, vlist)
+ 		numvls++;
+ 
+ 	/* account for the vlans and the link xstats type nest attribute */
+ 	return numvls * nla_total_size(sizeof(struct bridge_vlan_xstats)) +
+ 	       nla_total_size(0);
+ }
+ 
+ static int br_fill_linkxstats(struct sk_buff *skb, const struct net_device *dev,
+ 			      int *prividx)
+ {
+ 	struct net_bridge *br = netdev_priv(dev);
+ 	struct net_bridge_vlan_group *vg;
+ 	struct net_bridge_vlan *v;
+ 	struct nlattr *nest;
+ 	int vl_idx = 0;
+ 
+ 	vg = br_vlan_group(br);
+ 	if (!vg)
+ 		goto out;
+ 	nest = nla_nest_start(skb, LINK_XSTATS_TYPE_BRIDGE);
+ 	if (!nest)
+ 		return -EMSGSIZE;
+ 	list_for_each_entry(v, &vg->vlan_list, vlist) {
+ 		struct bridge_vlan_xstats vxi;
+ 		struct br_vlan_stats stats;
+ 
+ 		if (vl_idx++ < *prividx)
+ 			continue;
+ 		memset(&vxi, 0, sizeof(vxi));
+ 		vxi.vid = v->vid;
+ 		br_vlan_get_stats(v, &stats);
+ 		vxi.rx_bytes = stats.rx_bytes;
+ 		vxi.rx_packets = stats.rx_packets;
+ 		vxi.tx_bytes = stats.tx_bytes;
+ 		vxi.tx_packets = stats.tx_packets;
+ 
+ 		if (nla_put(skb, BRIDGE_XSTATS_VLAN, sizeof(vxi), &vxi))
+ 			goto nla_put_failure;
+ 	}
+ 	nla_nest_end(skb, nest);
+ 	*prividx = 0;
+ out:
+ 	return 0;
+ 
+ nla_put_failure:
+ 	nla_nest_end(skb, nest);
+ 	*prividx = vl_idx;
+ 
+ 	return -EMSGSIZE;
+ }
+ 
+ static struct rtnl_af_ops br_af_ops __read_mostly = {
++>>>>>>> a60c090361ea (bridge: netlink: export per-vlan stats)
  	.family			= AF_BRIDGE,
 -	.get_link_af_size	= br_get_link_af_size_filtered,
 +	.get_link_af_size	= br_get_link_af_size,
  };
  
  struct rtnl_link_ops br_link_ops __read_mostly = {
++<<<<<<< HEAD
 +	.kind		= "bridge",
 +	.priv_size	= sizeof(struct net_bridge),
 +	.setup		= br_dev_setup,
 +	.validate	= br_validate,
 +	.newlink	= br_dev_newlink,
 +	.dellink	= br_dev_delete,
 +	.get_size	= br_get_size,
 +	.fill_info	= br_fill_info,
++=======
+ 	.kind			= "bridge",
+ 	.priv_size		= sizeof(struct net_bridge),
+ 	.setup			= br_dev_setup,
+ 	.maxtype		= IFLA_BR_MAX,
+ 	.policy			= br_policy,
+ 	.validate		= br_validate,
+ 	.newlink		= br_dev_newlink,
+ 	.changelink		= br_changelink,
+ 	.dellink		= br_dev_delete,
+ 	.get_size		= br_get_size,
+ 	.fill_info		= br_fill_info,
+ 	.fill_linkxstats	= br_fill_linkxstats,
+ 	.get_linkxstats_size	= br_get_linkxstats_size,
+ 
+ 	.slave_maxtype		= IFLA_BRPORT_MAX,
+ 	.slave_policy		= br_port_policy,
+ 	.slave_changelink	= br_port_slave_changelink,
+ 	.get_slave_size		= br_port_get_slave_size,
+ 	.fill_slave_info	= br_port_fill_slave_info,
++>>>>>>> a60c090361ea (bridge: netlink: export per-vlan stats)
  };
  
  int __init br_netlink_init(void)
diff --cc net/bridge/br_private.h
index c814343ad045,c7fb5d7a7218..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -602,19 -708,34 +602,25 @@@ int br_vlan_set_default_pvid(struct net
  int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
  int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
  void nbp_vlan_flush(struct net_bridge_port *port);
 +bool nbp_vlan_find(struct net_bridge_port *port, u16 vid);
  int nbp_vlan_init(struct net_bridge_port *port);
++<<<<<<< HEAD
++=======
+ int nbp_get_num_vlan_infos(struct net_bridge_port *p, u32 filter_mask);
+ void br_vlan_get_stats(const struct net_bridge_vlan *v,
+ 		       struct br_vlan_stats *stats);
++>>>>>>> a60c090361ea (bridge: netlink: export per-vlan stats)
  
 -static inline struct net_bridge_vlan_group *br_vlan_group(
 -					const struct net_bridge *br)
 -{
 -	return rtnl_dereference(br->vlgrp);
 -}
 -
 -static inline struct net_bridge_vlan_group *nbp_vlan_group(
 -					const struct net_bridge_port *p)
 -{
 -	return rtnl_dereference(p->vlgrp);
 -}
 -
 -static inline struct net_bridge_vlan_group *br_vlan_group_rcu(
 -					const struct net_bridge *br)
 +static inline struct net_port_vlans *br_get_vlan_info(
 +						const struct net_bridge *br)
  {
 -	return rcu_dereference(br->vlgrp);
 +	return rcu_dereference_rtnl(br->vlan_info);
  }
  
 -static inline struct net_bridge_vlan_group *nbp_vlan_group_rcu(
 -					const struct net_bridge_port *p)
 +static inline struct net_port_vlans *nbp_get_vlan_info(
 +						const struct net_bridge_port *p)
  {
 -	return rcu_dereference(p->vlgrp);
 +	return rcu_dereference_rtnl(p->vlan_info);
  }
  
  /* Since bridge now depends on 8021Q module, but the time bridge sees the
@@@ -748,6 -858,47 +754,50 @@@ static inline int br_vlan_enabled(struc
  {
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline int __br_vlan_filter_toggle(struct net_bridge *br,
+ 					  unsigned long val)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int nbp_get_num_vlan_infos(struct net_bridge_port *p,
+ 					 u32 filter_mask)
+ {
+ 	return 0;
+ }
+ 
+ static inline struct net_bridge_vlan_group *br_vlan_group(
+ 					const struct net_bridge *br)
+ {
+ 	return NULL;
+ }
+ 
+ static inline struct net_bridge_vlan_group *nbp_vlan_group(
+ 					const struct net_bridge_port *p)
+ {
+ 	return NULL;
+ }
+ 
+ static inline struct net_bridge_vlan_group *br_vlan_group_rcu(
+ 					const struct net_bridge *br)
+ {
+ 	return NULL;
+ }
+ 
+ static inline struct net_bridge_vlan_group *nbp_vlan_group_rcu(
+ 					const struct net_bridge_port *p)
+ {
+ 	return NULL;
+ }
+ 
+ static inline void br_vlan_get_stats(const struct net_bridge_vlan *v,
+ 				     struct br_vlan_stats *stats)
+ {
+ }
++>>>>>>> a60c090361ea (bridge: netlink: export per-vlan stats)
  #endif
  
  struct nf_br_ops {
diff --git a/include/uapi/linux/if_bridge.h b/include/uapi/linux/if_bridge.h
index 15a865acafe9..e76c97e7a7e2 100644
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@ -132,6 +132,16 @@ struct bridge_vlan_info {
 	__u16 vid;
 };
 
+struct bridge_vlan_xstats {
+	__u64 rx_bytes;
+	__u64 rx_packets;
+	__u64 tx_bytes;
+	__u64 tx_packets;
+	__u16 vid;
+	__u16 pad1;
+	__u32 pad2;
+};
+
 /* Bridge multicast database attributes
  * [MDBA_MDB] = {
  *     [MDBA_MDB_ENTRY] = {
@@ -209,4 +219,12 @@ enum {
 };
 #define MDBA_SET_ENTRY_MAX (__MDBA_SET_ENTRY_MAX - 1)
 
+/* Embedded inside LINK_XSTATS_TYPE_BRIDGE */
+enum {
+	BRIDGE_XSTATS_UNSPEC,
+	BRIDGE_XSTATS_VLAN,
+	__BRIDGE_XSTATS_MAX
+};
+#define BRIDGE_XSTATS_MAX (__BRIDGE_XSTATS_MAX - 1)
+
 #endif /* _UAPI_LINUX_IF_BRIDGE_H */
* Unmerged path include/uapi/linux/if_link.h
* Unmerged path net/bridge/br_netlink.c
* Unmerged path net/bridge/br_private.h
diff --git a/net/bridge/br_vlan.c b/net/bridge/br_vlan.c
index 1122c9d717ea..18d70211bbad 100644
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@ -705,3 +705,30 @@ int nbp_vlan_init(struct net_bridge_port *p)
 				     BRIDGE_VLAN_INFO_UNTAGGED) :
 			0;
 }
+
+void br_vlan_get_stats(const struct net_bridge_vlan *v,
+		       struct br_vlan_stats *stats)
+{
+	int i;
+
+	memset(stats, 0, sizeof(*stats));
+	for_each_possible_cpu(i) {
+		u64 rxpackets, rxbytes, txpackets, txbytes;
+		struct br_vlan_stats *cpu_stats;
+		unsigned int start;
+
+		cpu_stats = per_cpu_ptr(v->stats, i);
+		do {
+			start = u64_stats_fetch_begin_irq(&cpu_stats->syncp);
+			rxpackets = cpu_stats->rx_packets;
+			rxbytes = cpu_stats->rx_bytes;
+			txbytes = cpu_stats->tx_bytes;
+			txpackets = cpu_stats->tx_packets;
+		} while (u64_stats_fetch_retry_irq(&cpu_stats->syncp, start));
+
+		stats->rx_packets += rxpackets;
+		stats->rx_bytes += rxbytes;
+		stats->tx_bytes += txbytes;
+		stats->tx_packets += txpackets;
+	}
+}
