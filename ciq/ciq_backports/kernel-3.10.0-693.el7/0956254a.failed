ovl: don't copy up opaqueness

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit 0956254a2d5b9e2141385514553aeef694dfe3b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0956254a.failed

When a copy up of a directory occurs which has the opaque xattr set, the
xattr remains in the upper directory. The immediate behavior with overlayfs
is that the upper directory is not treated as opaque, however after a
remount the opaque flag is used and upper directory is treated as opaque.
This causes files created in the lower layer to be hidden when using
multiple lower directories.

Fix by not copying up the opaque flag.

To reproduce:

 ----8<---------8<---------8<---------8<---------8<---------8<----
mkdir -p l/d/s u v w mnt
mount -t overlay overlay -olowerdir=l,upperdir=u,workdir=w mnt
rm -rf mnt/d/
mkdir -p mnt/d/n
umount mnt
mount -t overlay overlay -olowerdir=u:l,upperdir=v,workdir=w mnt
touch mnt/d/foo
umount mnt
mount -t overlay overlay -olowerdir=u:l,upperdir=v,workdir=w mnt
ls mnt/d
 ----8<---------8<---------8<---------8<---------8<---------8<----
 
output should be:  "foo  n"

	Reported-by: Derek McGowan <dmcg@drizz.net>
Link: https://bugzilla.kernel.org/show_bug.cgi?id=151291
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
	Cc: <stable@vger.kernel.org>
(cherry picked from commit 0956254a2d5b9e2141385514553aeef694dfe3b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/overlayfs.h
diff --cc fs/overlayfs/overlayfs.h
index d2c18d8054aa,34839bd2b6b8..000000000000
--- a/fs/overlayfs/overlayfs.h
+++ b/fs/overlayfs/overlayfs.h
@@@ -183,13 -183,17 +183,18 @@@ int ovl_check_d_type_supported(struct p
  /* inode.c */
  int ovl_setattr(struct dentry *dentry, struct iattr *attr);
  int ovl_permission(struct inode *inode, int mask);
 -int ovl_setxattr(struct dentry *dentry, struct inode *inode,
 -		 const char *name, const void *value,
 -		 size_t size, int flags);
 -ssize_t ovl_getxattr(struct dentry *dentry, struct inode *inode,
 -		     const char *name, void *value, size_t size);
 +int ovl_xattr_set(struct dentry *dentry, const char *name, const void *value,
 +		  size_t size, int flags);
 +ssize_t ovl_getxattr(struct dentry *dentry, const char *name,
 +		     void *value, size_t size);
  ssize_t ovl_listxattr(struct dentry *dentry, char *list, size_t size);
 -int ovl_removexattr(struct dentry *dentry, const char *name);
  struct posix_acl *ovl_get_acl(struct inode *inode, int type);
  int ovl_open_maybe_copy_up(struct dentry *dentry, unsigned int file_flags);
++<<<<<<< HEAD
++=======
+ int ovl_update_time(struct inode *inode, struct timespec *ts, int flags);
+ bool ovl_is_private_xattr(const char *name);
++>>>>>>> 0956254a2d5b (ovl: don't copy up opaqueness)
  
  struct inode *ovl_new_inode(struct super_block *sb, umode_t mode);
  struct inode *ovl_get_inode(struct super_block *sb, struct inode *realinode);
diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c
index 7aec041555ef..22a9de63bb99 100644
--- a/fs/overlayfs/copy_up.c
+++ b/fs/overlayfs/copy_up.c
@@ -80,6 +80,8 @@ int ovl_copy_xattr(struct dentry *old, struct dentry *new)
 	}
 
 	for (name = buf; name < (buf + list_size); name += strlen(name) + 1) {
+		if (ovl_is_private_xattr(name))
+			continue;
 retry:
 		size = vfs_getxattr(old, name, value, value_size);
 		if (size == -ERANGE)
diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c
index 7a726b31c27d..21c4f45cc3f2 100644
--- a/fs/overlayfs/inode.c
+++ b/fs/overlayfs/inode.c
@@ -227,7 +227,7 @@ static int ovl_readlink(struct dentry *dentry, char __user *buf, int bufsiz)
 	return err;
 }
 
-static bool ovl_is_private_xattr(const char *name)
+bool ovl_is_private_xattr(const char *name)
 {
 #define OVL_XATTR_PRE_NAME OVL_XATTR_PREFIX "."
 	return strncmp(name, OVL_XATTR_PRE_NAME,
* Unmerged path fs/overlayfs/overlayfs.h
