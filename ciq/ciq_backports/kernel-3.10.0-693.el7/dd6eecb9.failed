mempolicy: unexport get_vma_policy() and remove its "task" arg

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Oleg Nesterov <oleg@redhat.com>
commit dd6eecb917938c1b7e505a83df307b3476e7c8bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/dd6eecb9.failed

- get_vma_policy(task) is not safe if task != current, remove this
  argument.

- get_vma_policy() no longer has callers outside of mempolicy.c,
  make it static.

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Cc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
	Cc: Alexander Viro <viro@zeniv.linux.org.uk>
	Cc: Cyrill Gorcunov <gorcunov@openvz.org>
	Cc: "Eric W. Biederman" <ebiederm@xmission.com>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit dd6eecb917938c1b7e505a83df307b3476e7c8bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mempolicy.h
diff --cc include/linux/mempolicy.h
index 345ca974815f,3d385c81c153..000000000000
--- a/include/linux/mempolicy.h
+++ b/include/linux/mempolicy.h
@@@ -137,9 -137,7 +137,13 @@@ struct mempolicy *mpol_shared_policy_lo
  struct mempolicy *get_task_policy(struct task_struct *p);
  struct mempolicy *__get_vma_policy(struct vm_area_struct *vma,
  		unsigned long addr);
++<<<<<<< HEAD
 +struct mempolicy *get_vma_policy(struct task_struct *tsk,
 +		struct vm_area_struct *vma, unsigned long addr);
 +bool vma_policy_mof(struct task_struct *task, struct vm_area_struct *vma);
++=======
+ bool vma_policy_mof(struct vm_area_struct *vma);
++>>>>>>> dd6eecb91793 (mempolicy: unexport get_vma_policy() and remove its "task" arg)
  
  extern void numa_default_policy(void);
  extern void numa_policy_init(void);
* Unmerged path include/linux/mempolicy.h
diff --git a/mm/mempolicy.c b/mm/mempolicy.c
index b7e8a843647a..b87a87588f12 100644
--- a/mm/mempolicy.c
+++ b/mm/mempolicy.c
@@ -1646,27 +1646,24 @@ struct mempolicy *__get_vma_policy(struct vm_area_struct *vma,
 }
 
 /*
- * get_vma_policy(@task, @vma, @addr)
- * @task: task for fallback if vma policy == default
+ * get_vma_policy(@vma, @addr)
  * @vma: virtual memory area whose policy is sought
  * @addr: address in @vma for shared policy lookup
  *
  * Returns effective policy for a VMA at specified address.
- * Falls back to @task or system default policy, as necessary.
- * Current or other task's task mempolicy and non-shared vma policies must be
- * protected by task_lock(task) by the caller.
+ * Falls back to current->mempolicy or system default policy, as necessary.
  * Shared policies [those marked as MPOL_F_SHARED] require an extra reference
  * count--added by the get_policy() vm_op, as appropriate--to protect against
  * freeing by another task.  It is the caller's responsibility to free the
  * extra reference for shared policies.
  */
-struct mempolicy *get_vma_policy(struct task_struct *task,
-		struct vm_area_struct *vma, unsigned long addr)
+static struct mempolicy *get_vma_policy(struct vm_area_struct *vma,
+						unsigned long addr)
 {
 	struct mempolicy *pol = __get_vma_policy(vma, addr);
 
 	if (!pol)
-		pol = get_task_policy(task);
+		pol = get_task_policy(current);
 
 	return pol;
 }
@@ -1900,7 +1897,7 @@ struct zonelist *huge_zonelist(struct vm_area_struct *vma, unsigned long addr,
 {
 	struct zonelist *zl;
 
-	*mpol = get_vma_policy(current, vma, addr);
+	*mpol = get_vma_policy(vma, addr);
 	*nodemask = NULL;	/* assume !MPOL_BIND */
 
 	if (unlikely((*mpol)->mode == MPOL_INTERLEAVE)) {
@@ -2055,7 +2052,7 @@ alloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,
 	unsigned int cpuset_mems_cookie;
 
 retry_cpuset:
-	pol = get_vma_policy(current, vma, addr);
+	pol = get_vma_policy(vma, addr);
 	cpuset_mems_cookie = read_mems_allowed_begin();
 
 	if (unlikely(pol->mode == MPOL_INTERLEAVE)) {
@@ -2315,7 +2312,7 @@ int mpol_misplaced(struct page *page, struct vm_area_struct *vma, unsigned long
 
 	BUG_ON(!vma);
 
-	pol = get_vma_policy(current, vma, addr);
+	pol = get_vma_policy(vma, addr);
 	if (!(pol->flags & MPOL_F_MOF))
 		goto out;
 
