net: sched: consolidate handle_ing and ing_filter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [net] sched: consolidate handle_ing and ing_filter (Ivan Vecera) [1428588]
Rebuild_FUZZ: 94.62%
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit c9e99fd078ef7fdcd9ee4f5a4cfdbece319587af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c9e99fd0.failed

Given quite some code has been removed from ing_filter(), we can just
consolidate that function into handle_ing() and get rid of a few
instructions at the same time.

	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Alexei Starovoitov <ast@plumgrid.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c9e99fd078ef7fdcd9ee4f5a4cfdbece319587af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
diff --cc net/core/dev.c
index f531f8664bdd,8a757464bfa2..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -3620,55 -3521,37 +3620,73 @@@ EXPORT_SYMBOL_GPL(br_fdb_test_addr_hook
  #endif
  
  #ifdef CONFIG_NET_CLS_ACT
++<<<<<<< HEAD
 +/* TODO: Maybe we should just force sch_ingress to be compiled in
 + * when CONFIG_NET_CLS_ACT is? otherwise some useless instructions
 + * a compare and 2 stores extra right now if we dont have it on
 + * but have CONFIG_NET_CLS_ACT
 + * NOTE: This doesn't stop any functionality; if you dont have
 + * the ingress scheduler, you just can't add policies on ingress.
 + *
 + */
 +static int ing_filter(struct sk_buff *skb, struct netdev_queue *rxq)
 +{
 +	int result = TC_ACT_OK;
 +	struct Qdisc *q;
 +
 +	skb->tc_verd = SET_TC_AT(skb->tc_verd, AT_INGRESS);
 +
 +	q = rcu_dereference(rxq->qdisc);
 +	if (q != &noop_qdisc) {
 +		spin_lock(qdisc_lock(q));
 +		if (likely(!test_bit(__QDISC_STATE_DEACTIVATED, &q->state)))
 +			result = qdisc_enqueue_root(skb, q);
 +		spin_unlock(qdisc_lock(q));
 +	}
 +
 +	return result;
 +}
 +
++=======
++>>>>>>> c9e99fd078ef (net: sched: consolidate handle_ing and ing_filter)
  static inline struct sk_buff *handle_ing(struct sk_buff *skb,
  					 struct packet_type **pt_prev,
  					 int *ret, struct net_device *orig_dev)
  {
  	struct netdev_queue *rxq = rcu_dereference(skb->dev->ingress_queue);
+ 	struct Qdisc *q;
  
++<<<<<<< HEAD
 +	if (!rxq || rcu_access_pointer(rxq->qdisc) == &noop_qdisc)
 +		goto out;
++=======
+ 	/* If there's at least one ingress present somewhere (so
+ 	 * we get here via enabled static key), remaining devices
+ 	 * that are not configured with an ingress qdisc will bail
+ 	 * out w/o the rcu_dereference().
+ 	 */
+ 	if (!rxq || (q = rcu_dereference(rxq->qdisc)) == &noop_qdisc)
+ 		return skb;
++>>>>>>> c9e99fd078ef (net: sched: consolidate handle_ing and ing_filter)
  
  	if (*pt_prev) {
  		*ret = deliver_skb(skb, *pt_prev, orig_dev);
  		*pt_prev = NULL;
  	}
  
- 	switch (ing_filter(skb, rxq)) {
- 	case TC_ACT_SHOT:
- 	case TC_ACT_STOLEN:
- 		kfree_skb(skb);
- 		return NULL;
+ 	skb->tc_verd = SET_TC_AT(skb->tc_verd, AT_INGRESS);
+ 
+ 	if (likely(!test_bit(__QDISC_STATE_DEACTIVATED, &q->state))) {
+ 		switch (qdisc_enqueue_root(skb, q)) {
+ 		case TC_ACT_SHOT:
+ 		case TC_ACT_STOLEN:
+ 			kfree_skb(skb);
+ 			return NULL;
+ 		}
  	}
  
 +out:
 +	skb->tc_verd = 0;
  	return skb;
  }
  #endif
* Unmerged path net/core/dev.c
