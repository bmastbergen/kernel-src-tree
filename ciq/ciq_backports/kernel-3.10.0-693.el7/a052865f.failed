scsi: aacraid: Added support to set QD of attached drives

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] aacraid: Added support to set QD of attached drives (Scott Benesh) [1384213]
Rebuild_FUZZ: 94.44%
commit-author Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
commit a052865fe2871a3888dbb4ecf8c5dcab77a19ae8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a052865f.failed

Added support to set qd of drives in slave_configure.This only works for
HBA1000 attached drives.

	Signed-off-by: Raghava Aditya Renukunta <RaghavaAditya.Renukunta@microsemi.com>
	Signed-off-by: Dave Carroll <David.Carroll@microsemi.com>
	Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit a052865fe2871a3888dbb4ecf8c5dcab77a19ae8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/aacraid/linit.c
diff --cc drivers/scsi/aacraid/linit.c
index 71d8efdb66d8,03d935c8de93..000000000000
--- a/drivers/scsi/aacraid/linit.c
+++ b/drivers/scsi/aacraid/linit.c
@@@ -513,31 -446,44 +528,55 @@@ static int aac_slave_configure(struct s
  		for (cid = 0; cid < aac->maximum_num_containers; ++cid)
  			if (aac->fsa_dev[cid].valid)
  				++num_lsu;
+ 
  		__shost_for_each_device(dev, host) {
- 			if (dev->tagged_supported && (dev->type == TYPE_DISK) &&
- 					(!aac->raid_scsi_mode ||
- 						(sdev_channel(sdev) != 2)) &&
- 					!dev->no_uld_attach) {
+ 			if (dev->tagged_supported
+ 			 && dev->type == TYPE_DISK
+ 			 && (!aac->raid_scsi_mode || (sdev_channel(sdev) != 2))
+ 			 && !dev->no_uld_attach) {
  				if ((sdev_channel(dev) != CONTAINER_CHANNEL)
- 				 || !aac->fsa_dev[sdev_id(dev)].valid)
+ 				 || !aac->fsa_dev[sdev_id(dev)].valid) {
  					++num_lsu;
- 			} else
+ 				}
+ 			} else {
  				++num_one;
+ 			}
  		}
+ 
  		if (num_lsu == 0)
  			++num_lsu;
++<<<<<<< HEAD
 +		depth = (host->can_queue - num_one) / num_lsu;
 +		if (depth > 256)
 +			depth = 256;
 +		else if (depth < 2)
 +			depth = 2;
 +		scsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG, depth);
 +	} else {
 +		scsi_adjust_queue_depth(sdev, 0, 1);
++=======
++>>>>>>> a052865fe287 (scsi: aacraid: Added support to set QD of attached drives)
  
- 		sdev->tagged_supported = 1;
+ 		depth = (host->can_queue - num_one) / num_lsu;
  	}
  
+ common_config:
+ 	/*
+ 	 * Firmware has an individual device recovery time typically
+ 	 * of 35 seconds, give us a margin.
+ 	 */
+ 	if (set_timeout && sdev->request_queue->rq_timeout < (45 * HZ))
+ 		blk_queue_rq_timeout(sdev->request_queue, 45*HZ);
+ 
+ 	if (depth > 256)
+ 		depth = 256;
+ 	else if (depth < 1)
+ 		depth = 1;
+ 
+ 	scsi_change_queue_depth(sdev, depth);
+ 
+ 	sdev->tagged_supported = 1;
+ 
  	return 0;
  }
  
@@@ -550,11 -496,16 +589,22 @@@
   *	total capacity and the queue depth supported by the target device.
   */
  
 -static int aac_change_queue_depth(struct scsi_device *sdev, int depth)
 +static int aac_change_queue_depth(struct scsi_device *sdev, int depth,
 +				  int reason)
  {
++<<<<<<< HEAD
 +	if (reason != SCSI_QDEPTH_DEFAULT)
 +		return -EOPNOTSUPP;
++=======
+ 	struct aac_dev *aac = (struct aac_dev *)(sdev->host->hostdata);
+ 	int chn, tid, is_native_device = 0;
+ 
+ 	chn = aac_logical_to_phys(sdev_channel(sdev));
+ 	tid = sdev_id(sdev);
+ 	if (chn < AAC_MAX_BUSES && tid < AAC_MAX_TARGETS &&
+ 		aac->hba_map[chn][tid].devtype == AAC_DEVTYPE_NATIVE_RAW)
+ 		is_native_device = 1;
++>>>>>>> a052865fe287 (scsi: aacraid: Added support to set QD of attached drives)
  
  	if (sdev->tagged_supported && (sdev->type == TYPE_DISK) &&
  	    (sdev_channel(sdev) == CONTAINER_CHANNEL)) {
@@@ -576,9 -527,12 +626,18 @@@
  			depth = 256;
  		else if (depth < 2)
  			depth = 2;
++<<<<<<< HEAD
 +		scsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG, depth);
 +	} else
 +		scsi_adjust_queue_depth(sdev, 0, 1);
++=======
+ 		return scsi_change_queue_depth(sdev, depth);
+ 	} else if (is_native_device) {
+ 		scsi_change_queue_depth(sdev, aac->hba_map[chn][tid].qd_limit);
+ 	} else {
+ 		scsi_change_queue_depth(sdev, 1);
+ 	}
++>>>>>>> a052865fe287 (scsi: aacraid: Added support to set QD of attached drives)
  	return sdev->queue_depth;
  }
  
* Unmerged path drivers/scsi/aacraid/linit.c
