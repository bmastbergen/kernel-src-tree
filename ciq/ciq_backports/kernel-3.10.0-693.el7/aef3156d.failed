HID: wacom: Have wacom_{get,set}_report retry on -EAGAIN, not -EPIPE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Have wacom_{get, set}_report retry on -EAGAIN, not -EPIPE (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.45%
commit-author Jason Gerecke <killertofu@gmail.com>
commit aef3156d7294ac878c10ca8f02539b49adee9624
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/aef3156d.failed

Retrying on -EPIPE makes very little sense since this typically indicates
a problem that will not just disappear on its own. For instance, the USB
documentation states that it will be sent if the endpoint is stalled or
the device has disconnected. Instead, we should retry if -EAGAIN is
received since this indicates a temporary error condition such as a busy
bus.

In addition to adjusting the conditions we retry under, we also log an
error on failure so that we can be aware of what's going on.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit aef3156d7294ac878c10ca8f02539b49adee9624)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_sys.c
diff --cc drivers/hid/wacom_sys.c
index 527bf559d1db,109312f9d3de..000000000000
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@@ -67,14 -33,13 +67,24 @@@ static int wacom_get_report(struct usb_
  	int retval;
  
  	do {
++<<<<<<< HEAD
 +		retval = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 +				USB_REQ_GET_REPORT,
 +				USB_DIR_IN | USB_TYPE_CLASS |
 +				USB_RECIP_INTERFACE,
 +				(type << 8) + id,
 +				intf->altsetting[0].desc.bInterfaceNumber,
 +				buf, size, 100);
 +	} while ((retval == -ETIMEDOUT || retval == -EPIPE) && --retries);
++=======
+ 		retval = hid_hw_raw_request(hdev, buf[0], buf, size, type,
+ 				HID_REQ_GET_REPORT);
+ 	} while ((retval == -ETIMEDOUT || retval == -EAGAIN) && --retries);
+ 
+ 	if (retval < 0)
+ 		hid_err(hdev, "wacom_get_report: ran out of retries "
+ 			"(last error = %d)\n", retval);
++>>>>>>> aef3156d7294 (HID: wacom: Have wacom_{get,set}_report retry on -EAGAIN, not -EPIPE)
  
  	return retval;
  }
@@@ -86,13 -50,13 +96,23 @@@ static int wacom_set_report(struct usb_
  	int retval;
  
  	do {
++<<<<<<< HEAD
 +		retval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 +				USB_REQ_SET_REPORT,
 +				USB_TYPE_CLASS | USB_RECIP_INTERFACE,
 +				(type << 8) + id,
 +				intf->altsetting[0].desc.bInterfaceNumber,
 +				buf, size, 1000);
 +	} while ((retval == -ETIMEDOUT || retval == -EPIPE) && --retries);
++=======
+ 		retval = hid_hw_raw_request(hdev, buf[0], buf, size, type,
+ 				HID_REQ_SET_REPORT);
+ 	} while ((retval == -ETIMEDOUT || retval == -EAGAIN) && --retries);
+ 
+ 	if (retval < 0)
+ 		hid_err(hdev, "wacom_set_report: ran out of retries "
+ 			"(last error = %d)\n", retval);
++>>>>>>> aef3156d7294 (HID: wacom: Have wacom_{get,set}_report retry on -EAGAIN, not -EPIPE)
  
  	return retval;
  }
* Unmerged path drivers/hid/wacom_sys.c
