of_mdio: fix MDIO phy device refcounting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Russell King <rmk+kernel@arm.linux.org.uk>
commit f018ae7a8c576345d56a0cd40d86c0574a2eb360
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f018ae7a.failed

bus_find_device() is defined as:

 * This is similar to the bus_for_each_dev() function above, but it
 * returns a reference to a device that is 'found' for later use, as
 * determined by the @match callback.

and it does indeed return a reference-counted pointer to the device:

        while ((dev = next_device(&i)))
                if (match(dev, data) && get_device(dev))
                                        ^^^^^^^^^^^^^^^
                        break;
        klist_iter_exit(&i);
        return dev;

What that means is that when we're done with the struct device, we must
drop that reference.  Neither of_phy_connect() nor of_phy_attach() did
this when phy_connect_direct() or phy_attach_direct() failed.

With our previous patch, phy_connect_direct() and phy_attach_direct()
take a new refcount on the phy device when successful, so we can drop
our local reference immediatley after these functions, whether or not
they succeeded.

	Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
	Acked-by: Rob Herring <robh@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f018ae7a8c576345d56a0cd40d86c0574a2eb360)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/of_mdio.c
diff --cc drivers/of/of_mdio.c
index d5a57a9e329c,a87a868fed64..000000000000
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@@ -206,44 -233,135 +210,75 @@@ struct phy_device *of_phy_connect(struc
  	if (!phy)
  		return NULL;
  
++<<<<<<< HEAD
 +	return phy_connect_direct(dev, phy, hndlr, iface) ? NULL : phy;
++=======
+ 	phy->dev_flags = flags;
+ 
+ 	ret = phy_connect_direct(dev, phy, hndlr, iface);
+ 
+ 	/* refcount is held by phy_connect_direct() on success */
+ 	put_device(&phy->dev);
+ 
+ 	return ret ? NULL : phy;
++>>>>>>> f018ae7a8c57 (of_mdio: fix MDIO phy device refcounting)
  }
  EXPORT_SYMBOL(of_phy_connect);
  
  /**
 - * of_phy_attach - Attach to a PHY without starting the state machine
 + * of_phy_connect_fixed_link - Parse fixed-link property and return a dummy phy
   * @dev: pointer to net_device claiming the phy
 - * @phy_np: Node pointer for the PHY
 - * @flags: flags to pass to the PHY
 + * @hndlr: Link state callback for the network device
   * @iface: PHY data interface type
   *
++<<<<<<< HEAD
 + * This function is a temporary stop-gap and will be removed soon.  It is
 + * only to support the fs_enet, ucc_geth and gianfar Ethernet drivers.  Do
 + * not call this function from new drivers.
++=======
+  * If successful, returns a pointer to the phy_device with the embedded
+  * struct device refcount incremented by one, or NULL on failure. The
+  * refcount must be dropped by calling phy_disconnect() or phy_detach().
++>>>>>>> f018ae7a8c57 (of_mdio: fix MDIO phy device refcounting)
   */
 -struct phy_device *of_phy_attach(struct net_device *dev,
 -				 struct device_node *phy_np, u32 flags,
 -				 phy_interface_t iface)
 +struct phy_device *of_phy_connect_fixed_link(struct net_device *dev,
 +					     void (*hndlr)(struct net_device *),
 +					     phy_interface_t iface)
  {
++<<<<<<< HEAD
 +	struct device_node *net_np;
 +	char bus_id[MII_BUS_ID_SIZE + 3];
 +	struct phy_device *phy;
 +	const __be32 *phy_id;
 +	int sz;
++=======
+ 	struct phy_device *phy = of_phy_find_device(phy_np);
+ 	int ret;
++>>>>>>> f018ae7a8c57 (of_mdio: fix MDIO phy device refcounting)
  
 -	if (!phy)
 +	if (!dev->dev.parent)
 +		return NULL;
 +
++<<<<<<< HEAD
 +	net_np = dev->dev.parent->of_node;
 +	if (!net_np)
  		return NULL;
  
 +	phy_id = of_get_property(net_np, "fixed-link", &sz);
 +	if (!phy_id || sz < sizeof(*phy_id))
 +		return NULL;
 +
 +	sprintf(bus_id, PHY_ID_FMT, "fixed-0", be32_to_cpu(phy_id[0]));
 +
 +	phy = phy_connect(dev, bus_id, hndlr, iface);
 +	return IS_ERR(phy) ? NULL : phy;
++=======
+ 	ret = phy_attach_direct(dev, phy, flags, iface);
+ 
+ 	/* refcount is held by phy_attach_direct() on success */
+ 	put_device(&phy->dev);
+ 
+ 	return ret ? NULL : phy;
++>>>>>>> f018ae7a8c57 (of_mdio: fix MDIO phy device refcounting)
  }
 -EXPORT_SYMBOL(of_phy_attach);
 -
 -#if defined(CONFIG_FIXED_PHY)
 -/*
 - * of_phy_is_fixed_link() and of_phy_register_fixed_link() must
 - * support two DT bindings:
 - * - the old DT binding, where 'fixed-link' was a property with 5
 - *   cells encoding various informations about the fixed PHY
 - * - the new DT binding, where 'fixed-link' is a sub-node of the
 - *   Ethernet device.
 - */
 -bool of_phy_is_fixed_link(struct device_node *np)
 -{
 -	struct device_node *dn;
 -	int len, err;
 -	const char *managed;
 -
 -	/* New binding */
 -	dn = of_get_child_by_name(np, "fixed-link");
 -	if (dn) {
 -		of_node_put(dn);
 -		return true;
 -	}
 -
 -	err = of_property_read_string(np, "managed", &managed);
 -	if (err == 0 && strcmp(managed, "auto") != 0)
 -		return true;
 -
 -	/* Old binding */
 -	if (of_get_property(np, "fixed-link", &len) &&
 -	    len == (5 * sizeof(__be32)))
 -		return true;
 -
 -	return false;
 -}
 -EXPORT_SYMBOL(of_phy_is_fixed_link);
 -
 -int of_phy_register_fixed_link(struct device_node *np)
 -{
 -	struct fixed_phy_status status = {};
 -	struct device_node *fixed_link_node;
 -	const __be32 *fixed_link_prop;
 -	int link_gpio;
 -	int len, err;
 -	struct phy_device *phy;
 -	const char *managed;
 -
 -	err = of_property_read_string(np, "managed", &managed);
 -	if (err == 0) {
 -		if (strcmp(managed, "in-band-status") == 0) {
 -			/* status is zeroed, namely its .link member */
 -			phy = fixed_phy_register(PHY_POLL, &status, -1, np);
 -			return IS_ERR(phy) ? PTR_ERR(phy) : 0;
 -		}
 -	}
 -
 -	/* New binding */
 -	fixed_link_node = of_get_child_by_name(np, "fixed-link");
 -	if (fixed_link_node) {
 -		status.link = 1;
 -		status.duplex = of_property_read_bool(fixed_link_node,
 -						      "full-duplex");
 -		if (of_property_read_u32(fixed_link_node, "speed", &status.speed))
 -			return -EINVAL;
 -		status.pause = of_property_read_bool(fixed_link_node, "pause");
 -		status.asym_pause = of_property_read_bool(fixed_link_node,
 -							  "asym-pause");
 -		link_gpio = of_get_named_gpio_flags(fixed_link_node,
 -						    "link-gpios", 0, NULL);
 -		of_node_put(fixed_link_node);
 -		if (link_gpio == -EPROBE_DEFER)
 -			return -EPROBE_DEFER;
 -
 -		phy = fixed_phy_register(PHY_POLL, &status, link_gpio, np);
 -		return IS_ERR(phy) ? PTR_ERR(phy) : 0;
 -	}
 -
 -	/* Old binding */
 -	fixed_link_prop = of_get_property(np, "fixed-link", &len);
 -	if (fixed_link_prop && len == (5 * sizeof(__be32))) {
 -		status.link = 1;
 -		status.duplex = be32_to_cpu(fixed_link_prop[1]);
 -		status.speed = be32_to_cpu(fixed_link_prop[2]);
 -		status.pause = be32_to_cpu(fixed_link_prop[3]);
 -		status.asym_pause = be32_to_cpu(fixed_link_prop[4]);
 -		phy = fixed_phy_register(PHY_POLL, &status, -1, np);
 -		return IS_ERR(phy) ? PTR_ERR(phy) : 0;
 -	}
 -
 -	return -ENODEV;
 -}
 -EXPORT_SYMBOL(of_phy_register_fixed_link);
 -#endif
 +EXPORT_SYMBOL(of_phy_connect_fixed_link);
* Unmerged path drivers/of/of_mdio.c
