powerpc/powernv: Support PCI config restore for VFs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [powerpc] powernv: Support PCI config restore for VFs (Gustavo Duarte) [1315131]
Rebuild_FUZZ: 91.49%
commit-author Wei Yang <weiyang@linux.vnet.ibm.com>
commit 0dc2830e0a48d520c7db7cc55dbbd0edefac02f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0dc2830e.failed

After PE reset, OPAL API opal_pci_reinit() is called on all devices
contained in the PE to reinitialize them. While skiboot is not aware of
VFs, we have to implement the function in kernel to reinitialize VFs after
reset on PE for VFs.

In this patch, two functions pnv_pci_fixup_vf_mps() and
pnv_eeh_restore_vf_config() both manipulate the MPS of the VF, since for a
VF it has three cases.

1. Normal creation for a VF
   In this case, pnv_pci_fixup_vf_mps() is called to make the MPS a proper
   value compared with its parent.
2. EEH recovery without VF removed
   In this case, MPS is stored in pci_dn and pnv_eeh_restore_vf_config() is
   called to restore it and reinitialize other part.
3. EEH recovery with VF removed
   In this case, VF will be removed then re-created. Both functions are
   called. First pnv_pci_fixup_vf_mps() is called to store the proper MPS
   to pci_dn and then pnv_eeh_restore_vf_config() is called to do proper
   thing.

This introduces two functions: pnv_pci_fixup_vf_mps() to fixup the VF's
MPS to make sure it is equal to parent's and store this value in pci_dn
for future use. pnv_eeh_restore_vf_config() to re-initialize on VF by
restoring MPS, disabling completion timeout, enabling SERR, etc.

	Signed-off-by: Wei Yang <weiyang@linux.vnet.ibm.com>
	Acked-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 0dc2830e0a48d520c7db7cc55dbbd0edefac02f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/eeh-powernv.c
diff --cc arch/powerpc/platforms/powernv/eeh-powernv.c
index 244776788244,950b3e539057..000000000000
--- a/arch/powerpc/platforms/powernv/eeh-powernv.c
+++ b/arch/powerpc/platforms/powernv/eeh-powernv.c
@@@ -1526,6 -1699,40 +1597,43 @@@ static struct eeh_ops pnv_eeh_ops = 
  	.restore_config		= pnv_eeh_restore_config
  };
  
++<<<<<<< HEAD
++=======
+ void pcibios_bus_add_device(struct pci_dev *pdev)
+ {
+ 	struct pci_dn *pdn = pci_get_pdn(pdev);
+ 
+ 	if (!pdev->is_virtfn)
+ 		return;
+ 
+ 	/*
+ 	 * The following operations will fail if VF's sysfs files
+ 	 * aren't created or its resources aren't finalized.
+ 	 */
+ 	eeh_add_device_early(pdn);
+ 	eeh_add_device_late(pdev);
+ 	eeh_sysfs_add_device(pdev);
+ }
+ 
+ #ifdef CONFIG_PCI_IOV
+ static void pnv_pci_fixup_vf_mps(struct pci_dev *pdev)
+ {
+ 	struct pci_dn *pdn = pci_get_pdn(pdev);
+ 	int parent_mps;
+ 
+ 	if (!pdev->is_virtfn)
+ 		return;
+ 
+ 	/* Synchronize MPS for VF and PF */
+ 	parent_mps = pcie_get_mps(pdev->physfn);
+ 	if ((128 << pdev->pcie_mpss) >= parent_mps)
+ 		pcie_set_mps(pdev, parent_mps);
+ 	pdn->mps = pcie_get_mps(pdev);
+ }
+ DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pnv_pci_fixup_vf_mps);
+ #endif /* CONFIG_PCI_IOV */
+ 
++>>>>>>> 0dc2830e0a48 (powerpc/powernv: Support PCI config restore for VFs)
  /**
   * eeh_powernv_init - Register platform dependent EEH operations
   *
diff --git a/arch/powerpc/include/asm/pci-bridge.h b/arch/powerpc/include/asm/pci-bridge.h
index 03b6e8231048..154f3ddb978c 100644
--- a/arch/powerpc/include/asm/pci-bridge.h
+++ b/arch/powerpc/include/asm/pci-bridge.h
@@ -217,6 +217,7 @@ struct pci_dn {
 #define IODA_INVALID_M64        (-1)
 	int     (*m64_map)[PCI_SRIOV_NUM_BARS];
 #endif /* CONFIG_PCI_IOV */
+	int	mps;			/* Maximum Payload Size */
 #endif
 	struct list_head child_list;
 	struct list_head list;
* Unmerged path arch/powerpc/platforms/powernv/eeh-powernv.c
