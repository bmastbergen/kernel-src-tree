qla2xxx: Allow vref count to timeout on vport delete.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Allow vref count to timeout on vport delete (Himanshu Madhani) [1441897]
Rebuild_FUZZ: 99.05%
commit-author Joe Carnuccio <joe.carnuccio@cavium.com>
commit c4a9b538ab2a109c5f9798bea1f8f4bf93aadfb9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/c4a9b538.failed

	Cc: <stable@vger.kernel.org>
	Signed-off-by: Joe Carnuccio <joe.carnuccio@cavium.com>
	Signed-off-by: Himanshu Madhani <himanshu.madhani@cavium.com>
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit c4a9b538ab2a109c5f9798bea1f8f4bf93aadfb9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_attr.c
#	drivers/scsi/qla2xxx/qla_def.h
#	drivers/scsi/qla2xxx/qla_os.c
diff --cc drivers/scsi/qla2xxx/qla_attr.c
index c1f6b2d946ed,435ff7fd6384..000000000000
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@@ -2218,10 -2161,13 +2216,18 @@@ qla24xx_vport_delete(struct fc_vport *f
  	clear_bit(vha->vp_idx, ha->vp_idx_map);
  	mutex_unlock(&ha->vport_lock);
  
++<<<<<<< HEAD
 +	if (vha->req->id && !ha->flags.cpu_affinity_enabled) {
 +		if (qla25xx_delete_req_que(vha, vha->req) != QLA_SUCCESS)
++=======
+ 	dma_free_coherent(&ha->pdev->dev, vha->gnl.size, vha->gnl.l,
+ 	    vha->gnl.ldma);
+ 
+ 	if (vha->qpair && vha->qpair->vp_idx == vha->vp_idx) {
+ 		if (qla2xxx_delete_qpair(vha, vha->qpair) != QLA_SUCCESS)
++>>>>>>> c4a9b538ab2a (qla2xxx: Allow vref count to timeout on vport delete.)
  			ql_log(ql_log_warn, vha, 0x7087,
 -			    "Queue Pair delete failed.\n");
 +			    "Queue delete failed.\n");
  	}
  
  	ql_log(ql_log_info, vha, 0x7088, "VP[%d] deleted.\n", id);
diff --cc drivers/scsi/qla2xxx/qla_def.h
index 3968a8462b15,8662ef4192db..000000000000
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@@ -3633,7 -4070,13 +3633,15 @@@ typedef struct scsi_qla_host 
  
  	atomic_t	vref_count;
  	struct qla8044_reset_template reset_tmplt;
 -	struct qla_tgt_counters tgt_counters;
  	uint16_t	bbcr;
++<<<<<<< HEAD
++=======
+ 	struct name_list_extended gnl;
+ 	/* Count of active session/fcport */
+ 	int fcport_count;
+ 	wait_queue_head_t fcport_waitQ;
+ 	wait_queue_head_t vref_waitq;
++>>>>>>> c4a9b538ab2a (qla2xxx: Allow vref count to timeout on vport delete.)
  } scsi_qla_host_t;
  
  struct qla27xx_image_status {
@@@ -3667,21 -4127,37 +3675,50 @@@ struct qla_tgt_vp_map 
  		(test_bit(ISP_ABORT_NEEDED, &ha->dpc_flags) || \
  			 test_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags))
  
++<<<<<<< HEAD
 +#define QLA_VHA_MARK_BUSY(__vha, __bail) do {		     \
 +	atomic_inc(&__vha->vref_count);			     \
 +	mb();						     \
 +	if (__vha->flags.delete_progress) {		     \
 +		atomic_dec(&__vha->vref_count);		     \
 +		__bail = 1;				     \
 +	} else {					     \
 +		__bail = 0;				     \
 +	}						     \
 +} while (0)
 +
 +#define QLA_VHA_MARK_NOT_BUSY(__vha) do {		     \
 +	atomic_dec(&__vha->vref_count);			     \
++=======
+ #define QLA_VHA_MARK_BUSY(__vha, __bail) do {		\
+ 	atomic_inc(&__vha->vref_count);			\
+ 	mb();						\
+ 	if (__vha->flags.delete_progress) {		\
+ 		atomic_dec(&__vha->vref_count);		\
+ 		wake_up(&__vha->vref_waitq);		\
+ 		__bail = 1;				\
+ 	} else {					\
+ 		__bail = 0;				\
+ 	}						\
+ } while (0)
+ 
+ #define QLA_VHA_MARK_NOT_BUSY(__vha) do {		\
+ 	atomic_dec(&__vha->vref_count);			\
+ 	wake_up(&__vha->vref_waitq);			\
+ } while (0)						\
+ 
+ #define QLA_QPAIR_MARK_BUSY(__qpair, __bail) do {	\
+ 	atomic_inc(&__qpair->ref_count);		\
+ 	mb();						\
+ 	if (__qpair->delete_in_progress) {		\
+ 		atomic_dec(&__qpair->ref_count);	\
+ 		__bail = 1;				\
+ 	} else {					\
+ 	       __bail = 0;				\
+ 	}						\
++>>>>>>> c4a9b538ab2a (qla2xxx: Allow vref count to timeout on vport delete.)
  } while (0)
  
 -#define QLA_QPAIR_MARK_NOT_BUSY(__qpair)		\
 -	atomic_dec(&__qpair->ref_count);		\
 -
  /*
   * qla2x00 local function return status codes
   */
diff --cc drivers/scsi/qla2xxx/qla_os.c
index 3d08deed6b92,54d4e802bde0..000000000000
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@@ -3875,8 -4258,28 +3875,25 @@@ struct scsi_qla_host *qla2x00_create_ho
  	INIT_LIST_HEAD(&vha->vp_fcports);
  	INIT_LIST_HEAD(&vha->work_list);
  	INIT_LIST_HEAD(&vha->list);
 -	INIT_LIST_HEAD(&vha->qla_cmd_list);
 -	INIT_LIST_HEAD(&vha->qla_sess_op_cmd_list);
 -	INIT_LIST_HEAD(&vha->logo_list);
 -	INIT_LIST_HEAD(&vha->plogi_ack_list);
 -	INIT_LIST_HEAD(&vha->qp_list);
 -	INIT_LIST_HEAD(&vha->gnl.fcports);
  
  	spin_lock_init(&vha->work_lock);
++<<<<<<< HEAD
++=======
+ 	spin_lock_init(&vha->cmd_list_lock);
+ 	init_waitqueue_head(&vha->fcport_waitQ);
+ 	init_waitqueue_head(&vha->vref_waitq);
+ 
+ 	vha->gnl.size = sizeof(struct get_name_list_extended) *
+ 			(ha->max_loop_id + 1);
+ 	vha->gnl.l = dma_alloc_coherent(&ha->pdev->dev,
+ 	    vha->gnl.size, &vha->gnl.ldma, GFP_KERNEL);
+ 	if (!vha->gnl.l) {
+ 		ql_log(ql_log_fatal, vha, 0xffff,
+ 		    "Alloc failed for name list.\n");
+ 		scsi_remove_host(vha->host);
+ 		return NULL;
+ 	}
++>>>>>>> c4a9b538ab2a (qla2xxx: Allow vref count to timeout on vport delete.)
  
  	sprintf(vha->host_str, "%s_%ld", QLA2XXX_DRIVER_NAME, vha->host_no);
  	ql_dbg(ql_dbg_init, vha, 0x0041,
* Unmerged path drivers/scsi/qla2xxx/qla_attr.c
* Unmerged path drivers/scsi/qla2xxx/qla_def.h
diff --git a/drivers/scsi/qla2xxx/qla_init.c b/drivers/scsi/qla2xxx/qla_init.c
index a14a696a9002..8bd92af738e0 100644
--- a/drivers/scsi/qla2xxx/qla_init.c
+++ b/drivers/scsi/qla2xxx/qla_init.c
@@ -4211,6 +4211,7 @@ qla2x00_update_fcports(scsi_qla_host_t *base_vha)
 			}
 		}
 		atomic_dec(&vha->vref_count);
+		wake_up(&vha->vref_waitq);
 	}
 	spin_unlock_irqrestore(&ha->vport_slock, flags);
 }
diff --git a/drivers/scsi/qla2xxx/qla_mid.c b/drivers/scsi/qla2xxx/qla_mid.c
index c5dd594f6c31..8c8bb763997d 100644
--- a/drivers/scsi/qla2xxx/qla_mid.c
+++ b/drivers/scsi/qla2xxx/qla_mid.c
@@ -74,13 +74,14 @@ qla24xx_deallocate_vp_id(scsi_qla_host_t *vha)
 	 * ensures no active vp_list traversal while the vport is removed
 	 * from the queue)
 	 */
-	spin_lock_irqsave(&ha->vport_slock, flags);
-	while (atomic_read(&vha->vref_count)) {
-		spin_unlock_irqrestore(&ha->vport_slock, flags);
-
-		msleep(500);
+	wait_event_timeout(vha->vref_waitq, atomic_read(&vha->vref_count),
+	    10*HZ);
 
-		spin_lock_irqsave(&ha->vport_slock, flags);
+	spin_lock_irqsave(&ha->vport_slock, flags);
+	if (atomic_read(&vha->vref_count)) {
+		ql_dbg(ql_dbg_vport, vha, 0xfffa,
+		    "vha->vref_count=%u timeout\n", vha->vref_count.counter);
+		vha->vref_count = (atomic_t)ATOMIC_INIT(0);
 	}
 	list_del(&vha->list);
 	qlt_update_vp_map(vha, RESET_VP_IDX);
@@ -269,6 +270,7 @@ qla2x00_alert_all_vps(struct rsp_que *rsp, uint16_t *mb)
 
 			spin_lock_irqsave(&ha->vport_slock, flags);
 			atomic_dec(&vha->vref_count);
+			wake_up(&vha->vref_waitq);
 		}
 		i++;
 	}
* Unmerged path drivers/scsi/qla2xxx/qla_os.c
