tpm_crb: request and relinquish locality 0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
commit 877c57d0d0cac2c8fc661f708d8ee3fa7aa8d28b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/877c57d0.failed

This commit adds support for requesting and relinquishing locality 0 in
tpm_crb for the course of command transmission.

In order to achieve this, two new callbacks are added to struct
tpm_class_ops:

- request_locality
- relinquish_locality

With CRB interface you first set either requestAccess or relinquish bit
from TPM_LOC_CTRL_x register and then wait for locAssigned and
tpmRegValidSts bits to be set in the TPM_LOC_STATE_x register.

The reason why were are doing this is to make sure that the driver
will work properly with Intel TXT that uses locality 2. There's no
explicit guarantee that it would relinquish this locality. In more
general sense this commit enables tpm_crb to be a well behaving
citizen in a multi locality environment.

	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Reviewed-by: Jerry Snitselaar <jsnitsel@redhat.com>
	Tested-by: Jerry Snitselaar <jsnitsel@redhat.com>
(cherry picked from commit 877c57d0d0cac2c8fc661f708d8ee3fa7aa8d28b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/tpm/tpm-interface.c
#	drivers/char/tpm/tpm.h
diff --cc drivers/char/tpm/tpm-interface.c
index 8dd4f93138b9,158c1db83f05..000000000000
--- a/drivers/char/tpm/tpm-interface.c
+++ b/drivers/char/tpm/tpm-interface.c
@@@ -328,17 -328,70 +328,18 @@@ unsigned long tpm_calc_ordinal_duration
  }
  EXPORT_SYMBOL_GPL(tpm_calc_ordinal_duration);
  
 -static bool tpm_validate_command(struct tpm_chip *chip,
 -				 struct tpm_space *space,
 -				 const u8 *cmd,
 -				 size_t len)
 -{
 -	const struct tpm_input_header *header = (const void *)cmd;
 -	int i;
 -	u32 cc;
 -	u32 attrs;
 -	unsigned int nr_handles;
 -
 -	if (len < TPM_HEADER_SIZE)
 -		return false;
 -
 -	if (!space)
 -		return true;
 -
 -	if (chip->flags & TPM_CHIP_FLAG_TPM2 && chip->nr_commands) {
 -		cc = be32_to_cpu(header->ordinal);
 -
 -		i = tpm2_find_cc(chip, cc);
 -		if (i < 0) {
 -			dev_dbg(&chip->dev, "0x%04X is an invalid command\n",
 -				cc);
 -			return false;
 -		}
 -
 -		attrs = chip->cc_attrs_tbl[i];
 -		nr_handles =
 -			4 * ((attrs >> TPM2_CC_ATTR_CHANDLES) & GENMASK(2, 0));
 -		if (len < TPM_HEADER_SIZE + 4 * nr_handles)
 -			goto err_len;
 -	}
 -
 -	return true;
 -err_len:
 -	dev_dbg(&chip->dev,
 -		"%s: insufficient command length %zu", __func__, len);
 -	return false;
 -}
 -
 -/**
 - * tmp_transmit - Internal kernel interface to transmit TPM commands.
 - *
 - * @chip: TPM chip to use
 - * @buf: TPM command buffer
 - * @bufsiz: length of the TPM command buffer
 - * @flags: tpm transmit flags - bitmap
 - *
 - * Return:
 - *     0 when the operation is successful.
 - *     A negative number for system errors (errno).
 +/*
 + * Internal kernel interface to transmit TPM commands
   */
 -ssize_t tpm_transmit(struct tpm_chip *chip, struct tpm_space *space,
 -		     u8 *buf, size_t bufsiz, unsigned int flags)
 +ssize_t tpm_transmit(struct tpm_chip *chip, const u8 *buf, size_t bufsiz,
 +		     unsigned int flags)
  {
 -	struct tpm_output_header *header = (void *)buf;
 -	int rc;
 -	ssize_t len = 0;
 +	ssize_t rc;
  	u32 count, ordinal;
  	unsigned long stop;
+ 	bool need_locality;
  
 -	if (!tpm_validate_command(chip, space, buf, bufsiz))
 +	if (bufsiz < TPM_HEADER_SIZE)
  		return -EINVAL;
  
  	if (bufsiz > TPM_BUFSIZE)
@@@ -357,7 -410,22 +358,26 @@@
  	if (!(flags & TPM_TRANSMIT_UNLOCKED))
  		mutex_lock(&chip->tpm_mutex);
  
++<<<<<<< HEAD
 +	pm_runtime_get_sync(chip->dev.parent);
++=======
+ 	if (chip->dev.parent)
+ 		pm_runtime_get_sync(chip->dev.parent);
+ 
+ 	/* Store the decision as chip->locality will be changed. */
+ 	need_locality = chip->locality == -1;
+ 
+ 	if (need_locality && chip->ops->request_locality)  {
+ 		rc = chip->ops->request_locality(chip, 0);
+ 		if (rc < 0)
+ 			goto out_no_locality;
+ 		chip->locality = rc;
+ 	}
+ 
+ 	rc = tpm2_prepare_space(chip, space, ordinal, buf);
+ 	if (rc)
+ 		goto out;
++>>>>>>> 877c57d0d0ca (tpm_crb: request and relinquish locality 0)
  
  	rc = chip->ops->send(chip, (u8 *) buf, count);
  	if (rc < 0) {
@@@ -395,12 -463,32 +415,22 @@@
  	goto out;
  
  out_recv:
 -	len = chip->ops->recv(chip, (u8 *) buf, bufsiz);
 -	if (len < 0) {
 -		rc = len;
 +	rc = chip->ops->recv(chip, (u8 *) buf, bufsiz);
 +	if (rc < 0)
  		dev_err(&chip->dev,
 -			"tpm_transmit: tpm_recv: error %d\n", rc);
 -		goto out;
 -	} else if (len < TPM_HEADER_SIZE) {
 -		rc = -EFAULT;
 -		goto out;
 -	}
 -
 -	if (len != be32_to_cpu(header->length)) {
 -		rc = -EFAULT;
 -		goto out;
 -	}
 -
 -	rc = tpm2_commit_space(chip, space, ordinal, buf, &len);
 -
 +			"tpm_transmit: tpm_recv: error %zd\n", rc);
  out:
++<<<<<<< HEAD
 +	pm_runtime_put(chip->dev.parent);
++=======
+ 	if (need_locality && chip->ops->relinquish_locality) {
+ 		chip->ops->relinquish_locality(chip, chip->locality);
+ 		chip->locality = -1;
+ 	}
+ out_no_locality:
+ 	if (chip->dev.parent)
+ 		pm_runtime_put_sync(chip->dev.parent);
++>>>>>>> 877c57d0d0ca (tpm_crb: request and relinquish locality 0)
  
  	if (!(flags & TPM_TRANSMIT_UNLOCKED))
  		mutex_unlock(&chip->tpm_mutex);
diff --cc drivers/char/tpm/tpm.h
index 4d183c97f6a6,4b4c8dee3096..000000000000
--- a/drivers/char/tpm/tpm.h
+++ b/drivers/char/tpm/tpm.h
@@@ -179,6 -224,13 +179,16 @@@ struct tpm_chip 
  	acpi_handle acpi_dev_handle;
  	char ppi_version[TPM_PPI_VERSION_LEN + 1];
  #endif /* CONFIG_ACPI */
++<<<<<<< HEAD
++=======
+ 
+ 	struct tpm_space work_space;
+ 	u32 nr_commands;
+ 	u32 *cc_attrs_tbl;
+ 
+ 	/* active locality */
+ 	int locality;
++>>>>>>> 877c57d0d0ca (tpm_crb: request and relinquish locality 0)
  };
  
  #define to_tpm_chip(d) container_of(d, struct tpm_chip, dev)
diff --git a/drivers/char/tpm/tpm-chip.c b/drivers/char/tpm/tpm-chip.c
index e5950131bd90..c0b431cb32ea 100644
--- a/drivers/char/tpm/tpm-chip.c
+++ b/drivers/char/tpm/tpm-chip.c
@@ -188,6 +188,7 @@ struct tpm_chip *tpm_chip_alloc(struct device *dev,
 	chip->cdev.owner = THIS_MODULE;
 	chip->cdev.kobj.parent = &chip->dev.kobj;
 
+	chip->locality = -1;
 	return chip;
 
 out:
* Unmerged path drivers/char/tpm/tpm-interface.c
* Unmerged path drivers/char/tpm/tpm.h
diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c
index 853c808fb00e..079bcb8d2a99 100644
--- a/drivers/char/tpm/tpm_crb.c
+++ b/drivers/char/tpm/tpm_crb.c
@@ -34,6 +34,16 @@ enum crb_defaults {
 	CRB_ACPI_START_INDEX = 1,
 };
 
+enum crb_loc_ctrl {
+	CRB_LOC_CTRL_REQUEST_ACCESS	= BIT(0),
+	CRB_LOC_CTRL_RELINQUISH		= BIT(1),
+};
+
+enum crb_loc_state {
+	CRB_LOC_STATE_LOC_ASSIGNED	= BIT(1),
+	CRB_LOC_STATE_TPM_REG_VALID_STS	= BIT(7),
+};
+
 enum crb_ctrl_req {
 	CRB_CTRL_REQ_CMD_READY	= BIT(0),
 	CRB_CTRL_REQ_GO_IDLE	= BIT(1),
@@ -153,6 +163,35 @@ static int __maybe_unused crb_cmd_ready(struct device *dev,
 	return 0;
 }
 
+static int crb_request_locality(struct tpm_chip *chip, int loc)
+{
+	struct crb_priv *priv = dev_get_drvdata(&chip->dev);
+	u32 value = CRB_LOC_STATE_LOC_ASSIGNED |
+		CRB_LOC_STATE_TPM_REG_VALID_STS;
+
+	if (!priv->regs_h)
+		return 0;
+
+	iowrite32(CRB_LOC_CTRL_REQUEST_ACCESS, &priv->regs_h->loc_ctrl);
+	if (!crb_wait_for_reg_32(&priv->regs_h->loc_state, value, value,
+				 TPM2_TIMEOUT_C)) {
+		dev_warn(&chip->dev, "TPM_LOC_STATE_x.requestAccess timed out\n");
+		return -ETIME;
+	}
+
+	return 0;
+}
+
+static void crb_relinquish_locality(struct tpm_chip *chip, int loc)
+{
+	struct crb_priv *priv = dev_get_drvdata(&chip->dev);
+
+	if (!priv->regs_h)
+		return;
+
+	iowrite32(CRB_LOC_CTRL_RELINQUISH, &priv->regs_h->loc_ctrl);
+}
+
 static u8 crb_status(struct tpm_chip *chip)
 {
 	struct crb_priv *priv = dev_get_drvdata(&chip->dev);
@@ -259,6 +298,8 @@ static const struct tpm_class_ops tpm_crb = {
 	.send = crb_send,
 	.cancel = crb_cancel,
 	.req_canceled = crb_req_canceled,
+	.request_locality = crb_request_locality,
+	.relinquish_locality = crb_relinquish_locality,
 	.req_complete_mask = CRB_DRV_STS_COMPLETE,
 	.req_complete_val = CRB_DRV_STS_COMPLETE,
 };
diff --git a/include/linux/tpm.h b/include/linux/tpm.h
index da158f06e0b2..5a090f5ab335 100644
--- a/include/linux/tpm.h
+++ b/include/linux/tpm.h
@@ -48,7 +48,8 @@ struct tpm_class_ops {
 	u8 (*status) (struct tpm_chip *chip);
 	bool (*update_timeouts)(struct tpm_chip *chip,
 				unsigned long *timeout_cap);
-
+	int (*request_locality)(struct tpm_chip *chip, int loc);
+	void (*relinquish_locality)(struct tpm_chip *chip, int loc);
 };
 
 #if defined(CONFIG_TCG_TPM) || defined(CONFIG_TCG_TPM_MODULE)
