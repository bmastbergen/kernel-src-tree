blk-mq: add flag for drivers wanting blocking ->queue_rq()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jens Axboe <axboe@fb.com>
commit 1b792f2f92784c00db2e6431496e437855d6f12a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1b792f2f.failed

If a driver sets BLK_MQ_F_BLOCKING, it is allowed to block in its
->queue_rq() handler. For that case, blk-mq ensures that we always
calls it from a safe context.

	Signed-off-by: Jens Axboe <axboe@fb.com>
	Tested-by: Josef Bacik <jbacik@fb.com>
(cherry picked from commit 1b792f2f92784c00db2e6431496e437855d6f12a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/blk-mq.h
diff --cc include/linux/blk-mq.h
index 81b624be8424,5daa0ef756dd..000000000000
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@@ -193,10 -152,12 +193,19 @@@ enum 
  	BLK_MQ_RQ_QUEUE_ERROR	= 2,	/* end IO with error */
  
  	BLK_MQ_F_SHOULD_MERGE	= 1 << 0,
++<<<<<<< HEAD
 +	BLK_MQ_F_SHOULD_SORT	= 1 << 1,
 +	BLK_MQ_F_TAG_SHARED	= 1 << 2,
 +	BLK_MQ_F_SG_MERGE	= 1 << 3,
 +	BLK_MQ_F_DEFER_ISSUE	= 1 << 5,
++=======
+ 	BLK_MQ_F_TAG_SHARED	= 1 << 1,
+ 	BLK_MQ_F_SG_MERGE	= 1 << 2,
+ 	BLK_MQ_F_DEFER_ISSUE	= 1 << 4,
+ 	BLK_MQ_F_BLOCKING	= 1 << 5,
+ 	BLK_MQ_F_ALLOC_POLICY_START_BIT = 8,
+ 	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
++>>>>>>> 1b792f2f9278 (blk-mq: add flag for drivers wanting blocking ->queue_rq())
  
  	BLK_MQ_S_STOPPED	= 0,
  	BLK_MQ_S_TAG_ACTIVE	= 1,
diff --git a/block/blk-mq.c b/block/blk-mq.c
index 5a93dd7c2ec2..12cc921e60a6 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -882,7 +882,7 @@ void blk_mq_run_hw_queue(struct blk_mq_hw_ctx *hctx, bool async)
 	    !blk_mq_hw_queue_mapped(hctx)))
 		return;
 
-	if (!async) {
+	if (!async && !(hctx->flags & BLK_MQ_F_BLOCKING)) {
 		int cpu = get_cpu();
 		if (cpumask_test_cpu(cpu, hctx->cpumask)) {
 			__blk_mq_run_hw_queue(hctx);
* Unmerged path include/linux/blk-mq.h
