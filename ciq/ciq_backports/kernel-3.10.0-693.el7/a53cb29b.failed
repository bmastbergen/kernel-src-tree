vxlan: fix use-after-free on deletion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Mark Bloch <markb@mellanox.com>
commit a53cb29b0af346af44e4abf13d7e59f807fba690
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a53cb29b.failed

Adding a vxlan interface to a socket isn't symmetrical, while adding
is done in vxlan_open() the deletion is done in vxlan_dellink().
This can cause a use-after-free error when we close the vxlan
interface before deleting it.

We add vxlan_vs_del_dev() to match vxlan_vs_add_dev() and call
it from vxlan_stop() to match the call from vxlan_open().

Fixes: 56ef9c909b40 ("vxlan: Move socket initialization to within rtnl scope")
	Acked-by: Jiri Benc <jbenc@redhat.com>
	Tested-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a53cb29b0af346af44e4abf13d7e59f807fba690)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 05e4fb1a5b9e,a6b5052c1d36..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1039,16 -1073,21 +1041,24 @@@ static bool __vxlan_sock_release_prep(s
  
  static void vxlan_sock_release(struct vxlan_dev *vxlan)
  {
 -	struct vxlan_sock *sock4 = rtnl_dereference(vxlan->vn4_sock);
 +	bool ipv4 = __vxlan_sock_release_prep(vxlan->vn4_sock);
  #if IS_ENABLED(CONFIG_IPV6)
 -	struct vxlan_sock *sock6 = rtnl_dereference(vxlan->vn6_sock);
 -
 -	rcu_assign_pointer(vxlan->vn6_sock, NULL);
 +	bool ipv6 = __vxlan_sock_release_prep(vxlan->vn6_sock);
  #endif
  
 -	rcu_assign_pointer(vxlan->vn4_sock, NULL);
  	synchronize_net();
  
++<<<<<<< HEAD
 +	if (ipv4) {
 +		udp_tunnel_sock_release(vxlan->vn4_sock->sock);
 +		kfree(vxlan->vn4_sock);
++=======
+ 	vxlan_vs_del_dev(vxlan);
+ 
+ 	if (__vxlan_sock_release_prep(sock4)) {
+ 		udp_tunnel_sock_release(sock4->sock);
+ 		kfree(sock4);
++>>>>>>> a53cb29b0af3 (vxlan: fix use-after-free on deletion)
  	}
  
  #if IS_ENABLED(CONFIG_IPV6)
@@@ -3056,12 -3313,8 +3075,15 @@@ static int vxlan_newlink(struct net *sr
  static void vxlan_dellink(struct net_device *dev, struct list_head *head)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
- 	struct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);
  
++<<<<<<< HEAD
 +	spin_lock(&vn->sock_lock);
 +	if (!hlist_unhashed(&vxlan->hlist))
 +		hlist_del_rcu(&vxlan->hlist);
 +	spin_unlock(&vn->sock_lock);
++=======
+ 	vxlan_flush(vxlan, true);
++>>>>>>> a53cb29b0af3 (vxlan: fix use-after-free on deletion)
  
  	gro_cells_destroy(&vxlan->gro_cells);
  	list_del(&vxlan->next);
* Unmerged path drivers/net/vxlan.c
