sctp: call rcu_read_lock before checking for duplicate transport nodes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Xin Long <lucien.xin@gmail.com>
commit 5179b26694c92373275e4933f5d0ff32d585c675
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/5179b266.failed

Commit cd2b70875058 ("sctp: check duplicate node before inserting a
new transport") called rhltable_lookup() to check for the duplicate
transport node in transport rhashtable.

But rhltable_lookup() doesn't call rcu_read_lock inside, it could cause
a use-after-free issue if it tries to dereference the node that another
cpu has freed it. Note that sock lock can not avoid this as it is per
sock.

This patch is to fix it by calling rcu_read_lock before checking for
duplicate transport nodes.

Fixes: cd2b70875058 ("sctp: check duplicate node before inserting a new transport")
	Reported-by: Andrey Konovalov <andreyknvl@google.com>
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Acked-by: Neil Horman <nhorman@tuxdriver.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5179b26694c92373275e4933f5d0ff32d585c675)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/input.c
diff --cc net/sctp/input.c
index 9cdbec2d525c,2a28ab20487f..000000000000
--- a/net/sctp/input.c
+++ b/net/sctp/input.c
@@@ -884,24 -867,43 +884,47 @@@ int sctp_transport_hashtable_init(void
  
  void sctp_transport_hashtable_destroy(void)
  {
 -	rhltable_destroy(&sctp_transport_hashtable);
 +	rhashtable_destroy(&sctp_transport_hashtable);
  }
  
 -int sctp_hash_transport(struct sctp_transport *t)
 +void sctp_hash_transport(struct sctp_transport *t)
  {
 -	struct sctp_transport *transport;
 -	struct rhlist_head *tmp, *list;
  	struct sctp_hash_cmp_arg arg;
 -	int err;
  
  	if (t->asoc->temp)
 -		return 0;
 +		return;
  
 -	arg.net   = sock_net(t->asoc->base.sk);
 +	arg.ep = t->asoc->ep;
  	arg.paddr = &t->ipaddr;
 -	arg.lport = htons(t->asoc->base.bind_addr.port);
 +	arg.net   = sock_net(t->asoc->base.sk);
  
++<<<<<<< HEAD
 +reinsert:
 +	if (rhashtable_lookup_insert_key(&sctp_transport_hashtable, &arg,
 +					 &t->node, sctp_hash_params) == -EBUSY)
 +		goto reinsert;
++=======
+ 	rcu_read_lock();
+ 	list = rhltable_lookup(&sctp_transport_hashtable, &arg,
+ 			       sctp_hash_params);
+ 
+ 	rhl_for_each_entry_rcu(transport, tmp, list, node)
+ 		if (transport->asoc->ep == t->asoc->ep) {
+ 			rcu_read_unlock();
+ 			err = -EEXIST;
+ 			goto out;
+ 		}
+ 	rcu_read_unlock();
+ 
+ 	err = rhltable_insert_key(&sctp_transport_hashtable, &arg,
+ 				  &t->node, sctp_hash_params);
+ 
+ out:
+ 	if (err)
+ 		pr_err_once("insert transport fail, errno %d\n", err);
+ 
+ 	return err;
++>>>>>>> 5179b26694c9 (sctp: call rcu_read_lock before checking for duplicate transport nodes)
  }
  
  void sctp_unhash_transport(struct sctp_transport *t)
* Unmerged path net/sctp/input.c
