fs/proc/task_mmu.c: simplify m_start() to make it readable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [fs] proc/task_mmu.c: simplify m_start() to make it readable (Aaron Tomlin) [1425895]
Rebuild_FUZZ: 97.35%
commit-author Oleg Nesterov <oleg@redhat.com>
commit 0c255321f879c36bd74f58f9c7ed235ea6b919cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/0c255321.failed

Now that m->version is gone we can cleanup m_start(). In particular,

  - Remove the "unsigned long" typecast, m->index can't be negative
    or exceed ->map_count. But lets use "unsigned int pos" to make
    it clear that "pos < map_count" is safe.

  - Remove the unnecessary "vma != NULL" check in the main loop. It
    can't be NULL unless we have a vm bug.

  - This also means that "pos < map_count" case can simply return the
    valid vma and avoid "goto" and subsequent checks.

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: Cyrill Gorcunov <gorcunov@openvz.org>
	Cc: "Eric W. Biederman" <ebiederm@xmission.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 0c255321f879c36bd74f58f9c7ed235ea6b919cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/task_mmu.c
diff --cc fs/proc/task_mmu.c
index 09ca18a42ac3,bb16c967eefd..000000000000
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@@ -157,23 -138,13 +157,23 @@@ static void vma_stop(struct proc_maps_p
  	mmput(mm);
  }
  
- static void *m_start(struct seq_file *m, loff_t *pos)
+ static void *m_start(struct seq_file *m, loff_t *ppos)
  {
  	struct proc_maps_private *priv = m->private;
 +	unsigned long last_addr = m->version;
  	struct mm_struct *mm;
- 	struct vm_area_struct *vma, *tail_vma = NULL;
- 	loff_t l = *pos;
+ 	struct vm_area_struct *vma;
+ 	unsigned int pos = *ppos;
  
 +	/*
 +	 * We remember last_addr rather than next_addr to hit with
 +	 * mmap_cache most of the time. We have zero last_addr at
 +	 * the beginning and also after lseek. We will have -1 last_addr
 +	 * after the end of the vmas.
 +	 */
 +	if (last_addr == -1UL)
 +		return NULL;
 +
  	priv->task = get_pid_task(priv->pid, PIDTYPE_PID);
  	if (!priv->task)
  		return ERR_PTR(-ESRCH);
@@@ -181,41 -152,19 +181,42 @@@
  	mm = priv->mm;
  	if (!mm || !atomic_inc_not_zero(&mm->mm_users))
  		return NULL;
- 	down_read(&mm->mmap_sem);
  
- 	tail_vma = get_gate_vma(mm);
- 	priv->tail_vma = tail_vma;
+ 	down_read(&mm->mmap_sem);
  	hold_task_mempolicy(priv);
++<<<<<<< HEAD
 +	/* Start with last addr hint */
 +	vma = find_vma(mm, last_addr);
 +	if (last_addr && vma) {
 +		vma = vma->vm_next;
 +		goto out;
 +	}
++=======
+ 	priv->tail_vma = get_gate_vma(mm);
++>>>>>>> 0c255321f879 (fs/proc/task_mmu.c: simplify m_start() to make it readable)
  
- 	/*
- 	 * Check the vma index is within the range and do
- 	 * sequential scan until m_index.
- 	 */
- 	vma = NULL;
- 	if ((unsigned long)l < mm->map_count) {
- 		vma = mm->mmap;
- 		while (l-- && vma)
+ 	if (pos < mm->map_count) {
+ 		for (vma = mm->mmap; pos; pos--)
  			vma = vma->vm_next;
- 		goto out;
+ 		return vma;
  	}
  
++<<<<<<< HEAD
 +	if (l != mm->map_count)
 +		tail_vma = NULL; /* After gate vma */
 +
 +out:
 +	if (vma)
 +		return vma;
 +
 +	/* End of vmas has been reached */
 +	m->version = (tail_vma != NULL)? 0: -1UL;
 +	if (tail_vma)
 +		return tail_vma;
++=======
+ 	if (pos == mm->map_count && priv->tail_vma)
+ 		return priv->tail_vma;
++>>>>>>> 0c255321f879 (fs/proc/task_mmu.c: simplify m_start() to make it readable)
  
  	vma_stop(priv);
  	return NULL;
* Unmerged path fs/proc/task_mmu.c
