ntb: move platform detection to separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [ntb] move platform detection to separate function (Suravee Suthikulpanit) [1303727]
Rebuild_FUZZ: 94.62%
commit-author Dave Jiang <dave.jiang@intel.com>
commit b775e85bdb0395077a23bc072c4a62986883e276
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b775e85b.failed

Move the platform detection function to separate functions to allow
easier maintenence.

	Signed-off-by: Dave Jiang <dave.jiang@intel.com>
	Signed-off-by: Jon Mason <jdmason@kudzu.us>
(cherry picked from commit b775e85bdb0395077a23bc072c4a62986883e276)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ntb/ntb_hw.c
diff --cc drivers/ntb/ntb_hw.c
index b250e730a323,7567452250df..000000000000
--- a/drivers/ntb/ntb_hw.c
+++ b/drivers/ntb/ntb_hw.c
@@@ -480,7 -570,8 +515,12 @@@ static void ntb_link_event(struct ntb_d
  		ndev->link_status = NTB_LINK_UP;
  		event = NTB_EVENT_HW_LINK_UP;
  
++<<<<<<< HEAD
 +		if (ndev->hw_type == BWD_HW)
++=======
+ 		if (is_ntb_atom(ndev) ||
+ 		    ndev->conn_type == NTB_CONN_TRANSPARENT)
++>>>>>>> b775e85bdb03 (ntb: move platform detection to separate function)
  			status = readw(ndev->reg_ofs.lnk_stat);
  		else {
  			int rc = pci_read_config_word(ndev->pdev,
@@@ -745,22 -967,12 +785,23 @@@ static int ntb_device_setup(struct ntb_
  {
  	int rc;
  
++<<<<<<< HEAD
 +	switch (ndev->pdev->device) {
 +	case PCI_DEVICE_ID_INTEL_NTB_2ND_SNB:
 +	case PCI_DEVICE_ID_INTEL_NTB_RP_JSF:
 +	case PCI_DEVICE_ID_INTEL_NTB_RP_SNB:
 +	case PCI_DEVICE_ID_INTEL_NTB_CLASSIC_JSF:
 +	case PCI_DEVICE_ID_INTEL_NTB_CLASSIC_SNB:
 +	case PCI_DEVICE_ID_INTEL_NTB_B2B_JSF:
 +	case PCI_DEVICE_ID_INTEL_NTB_B2B_SNB:
++=======
+ 	if (is_ntb_xeon(ndev))
++>>>>>>> b775e85bdb03 (ntb: move platform detection to separate function)
  		rc = ntb_xeon_setup(ndev);
- 		break;
- 	case PCI_DEVICE_ID_INTEL_NTB_B2B_BWD:
+ 	else if (is_ntb_atom(ndev))
  		rc = ntb_bwd_setup(ndev);
- 		break;
- 	default:
+ 	else
  		rc = -ENODEV;
- 	}
  
  	if (rc)
  		return rc;
@@@ -776,8 -990,10 +817,12 @@@
  
  static void ntb_device_free(struct ntb_device *ndev)
  {
++<<<<<<< HEAD
 +	if (ndev->hw_type == BWD_HW)
++=======
+ 	if (is_ntb_atom(ndev)) {
++>>>>>>> b775e85bdb03 (ntb: move platform detection to separate function)
  		cancel_delayed_work_sync(&ndev->hb_timer);
 -		cancel_delayed_work_sync(&ndev->lr_timer);
 -	}
  }
  
  static irqreturn_t bwd_callback_msix_irq(int irq, void *data)
@@@ -1054,11 -1272,12 +1099,11 @@@ static int ntb_setup_interrupts(struct 
  	/* On BWD, disable all interrupts.  On SNB, disable all but Link
  	 * Interrupt.  The rest will be unmasked as callbacks are registered.
  	 */
- 	if (ndev->hw_type == BWD_HW)
+ 	if (is_ntb_atom(ndev))
  		writeq(~0, ndev->reg_ofs.ldb_mask);
 -	else {
 -		u16 var = 1 << SNB_LINK_DB;
 -		writew(~var, ndev->reg_ofs.ldb_mask);
 -	}
 +	else
 +		writew(~(1 << ndev->limits.max_db_bits),
 +		       ndev->reg_ofs.ldb_mask);
  
  	rc = ntb_setup_msix(ndev);
  	if (!rc)
@@@ -1145,6 -1364,101 +1190,104 @@@ static void ntb_free_callbacks(struct n
  	kfree(ndev->db_cb);
  }
  
++<<<<<<< HEAD
++=======
+ static ssize_t ntb_debugfs_read(struct file *filp, char __user *ubuf,
+ 				size_t count, loff_t *offp)
+ {
+ 	struct ntb_device *ndev;
+ 	char *buf;
+ 	ssize_t ret, offset, out_count;
+ 
+ 	out_count = 500;
+ 
+ 	buf = kmalloc(out_count, GFP_KERNEL);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	ndev = filp->private_data;
+ 	offset = 0;
+ 	offset += snprintf(buf + offset, out_count - offset,
+ 			   "NTB Device Information:\n");
+ 	offset += snprintf(buf + offset, out_count - offset,
+ 			   "Connection Type - \t\t%s\n",
+ 			   ndev->conn_type == NTB_CONN_TRANSPARENT ?
+ 			   "Transparent" : (ndev->conn_type == NTB_CONN_B2B) ?
+ 			   "Back to back" : "Root Port");
+ 	offset += snprintf(buf + offset, out_count - offset,
+ 			   "Device Type - \t\t\t%s\n",
+ 			   ndev->dev_type == NTB_DEV_USD ?
+ 			   "DSD/USP" : "USD/DSP");
+ 	offset += snprintf(buf + offset, out_count - offset,
+ 			   "Max Number of Callbacks - \t%u\n",
+ 			   ntb_max_cbs(ndev));
+ 	offset += snprintf(buf + offset, out_count - offset,
+ 			   "Link Status - \t\t\t%s\n",
+ 			   ntb_hw_link_status(ndev) ? "Up" : "Down");
+ 	if (ntb_hw_link_status(ndev)) {
+ 		offset += snprintf(buf + offset, out_count - offset,
+ 				   "Link Speed - \t\t\tPCI-E Gen %u\n",
+ 				   ndev->link_speed);
+ 		offset += snprintf(buf + offset, out_count - offset,
+ 				   "Link Width - \t\t\tx%u\n",
+ 				   ndev->link_width);
+ 	}
+ 
+ 	if (is_ntb_xeon(ndev)) {
+ 		u32 status32;
+ 		u16 status16;
+ 		int rc;
+ 
+ 		offset += snprintf(buf + offset, out_count - offset,
+ 				   "\nNTB Device Statistics:\n");
+ 		offset += snprintf(buf + offset, out_count - offset,
+ 				   "Upstream Memory Miss - \t%u\n",
+ 				   readw(ndev->reg_base +
+ 					 SNB_USMEMMISS_OFFSET));
+ 
+ 		offset += snprintf(buf + offset, out_count - offset,
+ 				   "\nNTB Hardware Errors:\n");
+ 
+ 		rc = pci_read_config_word(ndev->pdev, SNB_DEVSTS_OFFSET,
+ 					  &status16);
+ 		if (!rc)
+ 			offset += snprintf(buf + offset, out_count - offset,
+ 					   "DEVSTS - \t%#06x\n", status16);
+ 
+ 		rc = pci_read_config_word(ndev->pdev, SNB_LINK_STATUS_OFFSET,
+ 					  &status16);
+ 		if (!rc)
+ 			offset += snprintf(buf + offset, out_count - offset,
+ 					   "LNKSTS - \t%#06x\n", status16);
+ 
+ 		rc = pci_read_config_dword(ndev->pdev, SNB_UNCERRSTS_OFFSET,
+ 					   &status32);
+ 		if (!rc)
+ 			offset += snprintf(buf + offset, out_count - offset,
+ 					   "UNCERRSTS - \t%#010x\n", status32);
+ 
+ 		rc = pci_read_config_dword(ndev->pdev, SNB_CORERRSTS_OFFSET,
+ 					   &status32);
+ 		if (!rc)
+ 			offset += snprintf(buf + offset, out_count - offset,
+ 					   "CORERRSTS - \t%#010x\n", status32);
+ 	}
+ 
+ 	if (offset > out_count)
+ 		offset = out_count;
+ 
+ 	ret = simple_read_from_buffer(ubuf, count, offp, buf, offset);
+ 	kfree(buf);
+ 	return ret;
+ }
+ 
+ static const struct file_operations ntb_debugfs_info = {
+ 	.owner = THIS_MODULE,
+ 	.open = simple_open,
+ 	.read = ntb_debugfs_read,
+ };
+ 
++>>>>>>> b775e85bdb03 (ntb: move platform detection to separate function)
  static void ntb_setup_debugfs(struct ntb_device *ndev)
  {
  	if (!debugfs_initialized())
* Unmerged path drivers/ntb/ntb_hw.c
