mei: add read callback on demand for fixed_address clients

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alexander Usyskin <alexander.usyskin@intel.com>
commit a808c80cdaa83939b220176fcdffca8385d88ba6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a808c80c.failed

The Fixed address clients do not work with the flow control, and the
packet RX callback was allocated upon TX with anticipation of a
following RX. This won't work if the clients with unsolicited Rx. Rather
than preparing read callback upon a write we allocate one directly on
the reciev path if one doesn't exists.

	Signed-off-by: Alexander Usyskin <alexander.usyskin@intel.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a808c80cdaa83939b220176fcdffca8385d88ba6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/client.c
diff --cc drivers/misc/mei/client.c
index c6cc367e95dc,2a09db86e50e..000000000000
--- a/drivers/misc/mei/client.c
+++ b/drivers/misc/mei/client.c
@@@ -1168,26 -1144,20 +1168,35 @@@ err
  /**
   * mei_cl_flow_ctrl_creds - checks flow_control credits for cl.
   *
++<<<<<<< HEAD
 + * @cl: private data of the file object
 + *
 + * Return: 1 if mei_flow_ctrl_creds >0, 0 - otherwise.
 + */
 +int mei_cl_flow_ctrl_creds(struct mei_cl *cl)
++=======
+  * @cl: host client
+  *
+  * Return: 1 if mei_flow_ctrl_creds >0, 0 - otherwise.
+  */
+ static int mei_cl_flow_ctrl_creds(struct mei_cl *cl)
++>>>>>>> a808c80cdaa8 (mei: add read callback on demand for fixed_address clients)
  {
- 	int rets;
- 
  	if (WARN_ON(!cl || !cl->me_cl))
  		return -EINVAL;
  
  	if (cl->mei_flow_ctrl_creds > 0)
  		return 1;
  
++<<<<<<< HEAD
 +	if (mei_cl_is_fixed_address(cl)) {
 +		rets = mei_cl_read_start(cl, mei_cl_mtu(cl), NULL);
 +		if (rets && rets != -EBUSY)
 +			return rets;
++=======
+ 	if (mei_cl_is_fixed_address(cl))
++>>>>>>> a808c80cdaa8 (mei: add read callback on demand for fixed_address clients)
  		return 1;
- 	}
  
  	if (mei_cl_is_single_recv_buf(cl)) {
  		if (cl->me_cl->mei_flow_ctrl_creds > 0)
* Unmerged path drivers/misc/mei/client.c
diff --git a/drivers/misc/mei/interrupt.c b/drivers/misc/mei/interrupt.c
index 298ef580e3c9..d6f55b4d6f43 100644
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@ -107,8 +107,14 @@ int mei_cl_irq_read_msg(struct mei_cl *cl,
 
 	cb = list_first_entry_or_null(&cl->rd_pending, struct mei_cl_cb, list);
 	if (!cb) {
-		cl_err(dev, cl, "pending read cb not found\n");
-		goto out;
+		if (!mei_cl_is_fixed_address(cl)) {
+			cl_err(dev, cl, "pending read cb not found\n");
+			goto out;
+		}
+		cb = mei_cl_alloc_cb(cl, mei_cl_mtu(cl), MEI_FOP_READ, cl->fp);
+		if (!cb)
+			goto out;
+		list_add_tail(&cb->list, &cl->rd_pending);
 	}
 
 	if (!mei_cl_is_connected(cl)) {
