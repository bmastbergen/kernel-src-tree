x86/RAS: Simplify SMCA HWID descriptor struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Borislav Petkov <bp@suse.de>
commit 1ce9cd7f9f0b71af7c496b816734bc2dc699363a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1ce9cd7f.failed

Call it simply smca_hwid and call local variables "hwid". More readable.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Tested-by: Yazen Ghannam <yazen.ghannam@amd.com>
Link: http://lkml.kernel.org/r/20161103125556.15482-2-bp@alien8.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 1ce9cd7f9f0b71af7c496b816734bc2dc699363a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/mce.h
#	arch/x86/kernel/cpu/mcheck/mce_amd.c
#	drivers/edac/mce_amd.c
diff --cc arch/x86/include/asm/mce.h
index cb08d9d92582,ccc801a0da0f..000000000000
--- a/arch/x86/include/asm/mce.h
+++ b/arch/x86/include/asm/mce.h
@@@ -295,4 -332,53 +295,56 @@@ struct cper_sec_mem_err
  extern void apei_mce_report_mem_error(int corrected,
  				      struct cper_sec_mem_err *mem_err);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Enumerate new IP types and HWID values in AMD processors which support
+  * Scalable MCA.
+  */
+ #ifdef CONFIG_X86_MCE_AMD
+ 
+ /* These may be used by multiple smca_hwid_mcatypes */
+ enum smca_bank_types {
+ 	SMCA_LS = 0,	/* Load Store */
+ 	SMCA_IF,	/* Instruction Fetch */
+ 	SMCA_L2_CACHE,	/* L2 Cache */
+ 	SMCA_DE,	/* Decoder Unit */
+ 	SMCA_EX,	/* Execution Unit */
+ 	SMCA_FP,	/* Floating Point */
+ 	SMCA_L3_CACHE,	/* L3 Cache */
+ 	SMCA_CS,	/* Coherent Slave */
+ 	SMCA_PIE,	/* Power, Interrupts, etc. */
+ 	SMCA_UMC,	/* Unified Memory Controller */
+ 	SMCA_PB,	/* Parameter Block */
+ 	SMCA_PSP,	/* Platform Security Processor */
+ 	SMCA_SMU,	/* System Management Unit */
+ 	N_SMCA_BANK_TYPES
+ };
+ 
+ struct smca_bank_name {
+ 	const char *name;	/* Short name for sysfs */
+ 	const char *long_name;	/* Long name for pretty-printing */
+ };
+ 
+ extern struct smca_bank_name smca_bank_names[N_SMCA_BANK_TYPES];
+ 
+ #define HWID_MCATYPE(hwid, mcatype) ((hwid << 16) | mcatype)
+ 
+ struct smca_hwid {
+ 	unsigned int bank_type;	/* Use with smca_bank_types for easy indexing. */
+ 	u32 hwid_mcatype;	/* (hwid,mcatype) tuple */
+ 	u32 xec_bitmap;		/* Bitmap of valid ExtErrorCodes; current max is 21. */
+ };
+ 
+ struct smca_bank {
+ 	struct smca_hwid *hwid;
+ 	/* Instance ID */
+ 	u32 id;
+ };
+ 
+ extern struct smca_bank smca_banks[MAX_NR_BANKS];
+ 
+ #endif
+ 
++>>>>>>> 1ce9cd7f9f0b (x86/RAS: Simplify SMCA HWID descriptor struct)
  #endif /* _ASM_X86_MCE_H */
diff --cc arch/x86/kernel/cpu/mcheck/mce_amd.c
index 95ca733e89ae,ff81667af2f2..000000000000
--- a/arch/x86/kernel/cpu/mcheck/mce_amd.c
+++ b/arch/x86/kernel/cpu/mcheck/mce_amd.c
@@@ -63,6 -64,72 +63,75 @@@ static const char * const th_names[] = 
  	"execution_unit",
  };
  
++<<<<<<< HEAD
++=======
+ static const char * const smca_umc_block_names[] = {
+ 	"dram_ecc",
+ 	"misc_umc"
+ };
+ 
+ struct smca_bank_name smca_bank_names[] = {
+ 	[SMCA_LS]	= { "load_store",	"Load Store Unit" },
+ 	[SMCA_IF]	= { "insn_fetch",	"Instruction Fetch Unit" },
+ 	[SMCA_L2_CACHE]	= { "l2_cache",		"L2 Cache" },
+ 	[SMCA_DE]	= { "decode_unit",	"Decode Unit" },
+ 	[SMCA_EX]	= { "execution_unit",	"Execution Unit" },
+ 	[SMCA_FP]	= { "floating_point",	"Floating Point Unit" },
+ 	[SMCA_L3_CACHE]	= { "l3_cache",		"L3 Cache" },
+ 	[SMCA_CS]	= { "coherent_slave",	"Coherent Slave" },
+ 	[SMCA_PIE]	= { "pie",		"Power, Interrupts, etc." },
+ 	[SMCA_UMC]	= { "umc",		"Unified Memory Controller" },
+ 	[SMCA_PB]	= { "param_block",	"Parameter Block" },
+ 	[SMCA_PSP]	= { "psp",		"Platform Security Processor" },
+ 	[SMCA_SMU]	= { "smu",		"System Management Unit" },
+ };
+ EXPORT_SYMBOL_GPL(smca_bank_names);
+ 
+ static struct smca_hwid smca_hwid_mcatypes[] = {
+ 	/* { bank_type, hwid_mcatype, xec_bitmap } */
+ 
+ 	/* ZN Core (HWID=0xB0) MCA types */
+ 	{ SMCA_LS,	 HWID_MCATYPE(0xB0, 0x0), 0x1FFFEF },
+ 	{ SMCA_IF,	 HWID_MCATYPE(0xB0, 0x1), 0x3FFF },
+ 	{ SMCA_L2_CACHE, HWID_MCATYPE(0xB0, 0x2), 0xF },
+ 	{ SMCA_DE,	 HWID_MCATYPE(0xB0, 0x3), 0x1FF },
+ 	/* HWID 0xB0 MCATYPE 0x4 is Reserved */
+ 	{ SMCA_EX,	 HWID_MCATYPE(0xB0, 0x5), 0x7FF },
+ 	{ SMCA_FP,	 HWID_MCATYPE(0xB0, 0x6), 0x7F },
+ 	{ SMCA_L3_CACHE, HWID_MCATYPE(0xB0, 0x7), 0xFF },
+ 
+ 	/* Data Fabric MCA types */
+ 	{ SMCA_CS,	 HWID_MCATYPE(0x2E, 0x0), 0x1FF },
+ 	{ SMCA_PIE,	 HWID_MCATYPE(0x2E, 0x1), 0xF },
+ 
+ 	/* Unified Memory Controller MCA type */
+ 	{ SMCA_UMC,	 HWID_MCATYPE(0x96, 0x0), 0x3F },
+ 
+ 	/* Parameter Block MCA type */
+ 	{ SMCA_PB,	 HWID_MCATYPE(0x05, 0x0), 0x1 },
+ 
+ 	/* Platform Security Processor MCA type */
+ 	{ SMCA_PSP,	 HWID_MCATYPE(0xFF, 0x0), 0x1 },
+ 
+ 	/* System Management Unit MCA type */
+ 	{ SMCA_SMU,	 HWID_MCATYPE(0x01, 0x0), 0x1 },
+ };
+ 
+ struct smca_bank smca_banks[MAX_NR_BANKS];
+ EXPORT_SYMBOL_GPL(smca_banks);
+ 
+ /*
+  * In SMCA enabled processors, we can have multiple banks for a given IP type.
+  * So to define a unique name for each bank, we use a temp c-string to append
+  * the MCA_IPID[InstanceId] to type's name in get_name().
+  *
+  * InstanceId is 32 bits which is 8 characters. Make sure MAX_MCATYPE_NAME_LEN
+  * is greater than 8 plus 1 (for underscore) plus length of longest type name.
+  */
+ #define MAX_MCATYPE_NAME_LEN	30
+ static char buf_mcatype[MAX_MCATYPE_NAME_LEN];
+ 
++>>>>>>> 1ce9cd7f9f0b (x86/RAS: Simplify SMCA HWID descriptor struct)
  static DEFINE_PER_CPU(struct threshold_bank **, threshold_banks);
  static DEFINE_PER_CPU(unsigned int, bank_map);	/* see which banks are on */
  
@@@ -75,9 -142,33 +144,39 @@@ static void default_deferred_error_inte
  }
  void (*deferred_error_int_vector)(void) = default_deferred_error_interrupt;
  
++<<<<<<< HEAD
 +/*
 + * CPU Initialization
 + */
++=======
+ static void get_smca_bank_info(unsigned int bank)
+ {
+ 	unsigned int i, hwid_mcatype, cpu = smp_processor_id();
+ 	struct smca_hwid *s_hwid;
+ 	u32 high, instance_id;
+ 
+ 	/* Collect bank_info using CPU 0 for now. */
+ 	if (cpu)
+ 		return;
+ 
+ 	if (rdmsr_safe_on_cpu(cpu, MSR_AMD64_SMCA_MCx_IPID(bank), &instance_id, &high)) {
+ 		pr_warn("Failed to read MCA_IPID for bank %d\n", bank);
+ 		return;
+ 	}
+ 
+ 	hwid_mcatype = HWID_MCATYPE(high & MCI_IPID_HWID,
+ 				    (high & MCI_IPID_MCATYPE) >> 16);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(smca_hwid_mcatypes); i++) {
+ 		s_hwid = &smca_hwid_mcatypes[i];
+ 		if (hwid_mcatype == s_hwid->hwid_mcatype) {
+ 			smca_banks[bank].hwid = s_hwid;
+ 			smca_banks[bank].id = instance_id;
+ 			break;
+ 		}
+ 	}
+ }
++>>>>>>> 1ce9cd7f9f0b (x86/RAS: Simplify SMCA HWID descriptor struct)
  
  struct thresh_restart {
  	struct threshold_block	*b;
@@@ -651,6 -809,34 +750,37 @@@ static struct kobj_type threshold_ktyp
  	.default_attrs		= default_attrs,
  };
  
++<<<<<<< HEAD
++=======
+ static const char *get_name(unsigned int bank, struct threshold_block *b)
+ {
+ 	unsigned int bank_type;
+ 
+ 	if (!mce_flags.smca) {
+ 		if (b && bank == 4)
+ 			return bank4_names(b);
+ 
+ 		return th_names[bank];
+ 	}
+ 
+ 	if (!smca_banks[bank].hwid)
+ 		return NULL;
+ 
+ 	bank_type = smca_banks[bank].hwid->bank_type;
+ 
+ 	if (b && bank_type == SMCA_UMC) {
+ 		if (b->block < ARRAY_SIZE(smca_umc_block_names))
+ 			return smca_umc_block_names[b->block];
+ 		return NULL;
+ 	}
+ 
+ 	snprintf(buf_mcatype, MAX_MCATYPE_NAME_LEN,
+ 		 "%s_%x", smca_bank_names[bank_type].name,
+ 			  smca_banks[bank].id);
+ 	return buf_mcatype;
+ }
+ 
++>>>>>>> 1ce9cd7f9f0b (x86/RAS: Simplify SMCA HWID descriptor struct)
  static int allocate_threshold_blocks(unsigned int cpu, unsigned int bank,
  				     unsigned int block, u32 address)
  {
diff --cc drivers/edac/mce_amd.c
index 896ecd88aae5,8e96c6ddf272..000000000000
--- a/drivers/edac/mce_amd.c
+++ b/drivers/edac/mce_amd.c
@@@ -710,6 -848,37 +710,40 @@@ static void decode_mc6_mce(struct mce *
  	pr_emerg(HW_ERR "Corrupted MC6 MCE info?\n");
  }
  
++<<<<<<< HEAD
++=======
+ /* Decode errors according to Scalable MCA specification */
+ static void decode_smca_errors(struct mce *m)
+ {
+ 	struct smca_hwid *hwid;
+ 	unsigned int bank_type;
+ 	const char *ip_name;
+ 	u8 xec = XEC(m->status, xec_mask);
+ 
+ 	if (m->bank >= ARRAY_SIZE(smca_banks))
+ 		return;
+ 
+ 	if (boot_cpu_data.x86 >= 0x17 && m->bank == 4)
+ 		pr_emerg(HW_ERR "Bank 4 is reserved on Fam17h.\n");
+ 
+ 	hwid = smca_banks[m->bank].hwid;
+ 	if (!hwid)
+ 		return;
+ 
+ 	bank_type = hwid->bank_type;
+ 	ip_name = smca_bank_names[bank_type].long_name;
+ 
+ 	pr_emerg(HW_ERR "%s Extended Error Code: %d\n", ip_name, xec);
+ 
+ 	/* Only print the decode of valid error codes */
+ 	if (xec < smca_mce_descs[bank_type].num_descs &&
+ 			(hwid->xec_bitmap & BIT_ULL(xec))) {
+ 		pr_emerg(HW_ERR "%s Error: ", ip_name);
+ 		pr_cont("%s.\n", smca_mce_descs[bank_type].descs[xec]);
+ 	}
+ }
+ 
++>>>>>>> 1ce9cd7f9f0b (x86/RAS: Simplify SMCA HWID descriptor struct)
  static inline void amd_decode_err_code(u16 ec)
  {
  	if (INT_ERROR(ec)) {
* Unmerged path arch/x86/include/asm/mce.h
* Unmerged path arch/x86/kernel/cpu/mcheck/mce_amd.c
* Unmerged path drivers/edac/mce_amd.c
