flow_dissector: Use same pointer for IPv4 and IPv6 addresses

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Alexander Duyck <aduyck@mirantis.com>
commit b3c3106ce3f4646a008cd238b16f899ae14fd2a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/b3c3106c.failed

The IPv6 parsing was using a local pointer when it could use the same
pointer as the IPv4 portion of the code since the key_addrs can support
both IPv4 and IPv6 as it is just a pointer.

	Signed-off-by: Alexander Duyck <aduyck@mirantis.com>
	Acked-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b3c3106ce3f4646a008cd238b16f899ae14fd2a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,7c7b8739b8b8..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -157,19 -212,42 +157,52 @@@ ip
  ipv6:
  		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
  		if (!iph)
 -			goto out_bad;
 +			return false;
  
  		ip_proto = iph->nexthdr;
 +		flow->src = (__force __be32)ipv6_addr_hash(&iph->saddr);
 +		flow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);
  		nhoff += sizeof(struct ipv6hdr);
  
++<<<<<<< HEAD
 +		/* skip the flow label processing if skb is NULL.  The
 +		 * assumption here is that if there is no skb we are not
 +		 * looking for flow info as much as we are length.
 +		 */
 +		if (!skb)
 +			break;
++=======
+ 		if (dissector_uses_key(flow_dissector,
+ 				       FLOW_DISSECTOR_KEY_IPV6_ADDRS)) {
+ 			key_addrs = skb_flow_dissector_target(flow_dissector,
+ 							      FLOW_DISSECTOR_KEY_IPV6_ADDRS,
+ 							      target_container);
+ 
+ 			memcpy(&key_addrs->v6addrs, &iph->saddr,
+ 			       sizeof(key_addrs->v6addrs));
+ 			key_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
+ 		}
+ 
+ 		if ((dissector_uses_key(flow_dissector,
+ 					FLOW_DISSECTOR_KEY_FLOW_LABEL) ||
+ 		     (flags & FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL)) &&
+ 		    ip6_flowlabel(iph)) {
+ 			__be32 flow_label = ip6_flowlabel(iph);
+ 
+ 			if (dissector_uses_key(flow_dissector,
+ 					       FLOW_DISSECTOR_KEY_FLOW_LABEL)) {
+ 				key_tags = skb_flow_dissector_target(flow_dissector,
+ 								     FLOW_DISSECTOR_KEY_FLOW_LABEL,
+ 								     target_container);
+ 				key_tags->flow_label = ntohl(flow_label);
+ 			}
+ 			if (flags & FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL)
+ 				goto out_good;
+ 		}
+ 
+ 		if (flags & FLOW_DISSECTOR_F_STOP_AT_L3)
+ 			goto out_good;
++>>>>>>> b3c3106ce3f4 (flow_dissector: Use same pointer for IPv4 and IPv6 addresses)
  
  		break;
  	}
* Unmerged path net/core/flow_dissector.c
