HID: wacom: Add fuzz factor to distance and tilt axes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [hid] wacom: Add fuzz factor to distance and tilt axes (Aristeu Rozanski) [1346348 1388646 1385026]
Rebuild_FUZZ: 95.05%
commit-author Jason Gerecke <killertofu@gmail.com>
commit bef7e200065086e2ceef091f6853f3b053ad2ba9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/bef7e200.failed

The fuzz present on the distance and tilt axes is noticable when a puck is
present, and userspace (specifically libinput) would like the ability to
filter out the noise. To facilitate this, we assign a fuzz value of '1'
for the distance and tilt axes. This is large enough to cover most of the
natural variation in distance value as the puck is moved around, and
enough to cover the jitter in rotation (reported through tilt axes) when
the puck is left alone.

	Signed-off-by: Jason Gerecke <jason.gerecke@wacom.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit bef7e200065086e2ceef091f6853f3b053ad2ba9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/wacom_wac.c
diff --cc drivers/hid/wacom_wac.c
index 98c7d65145c2,ea949cb2ec1e..000000000000
--- a/drivers/hid/wacom_wac.c
+++ b/drivers/hid/wacom_wac.c
@@@ -1434,10 -2343,26 +1434,33 @@@ static void wacom_setup_cintiq(struct w
  	__set_bit(BTN_STYLUS2, input_dev->keybit);
  
  	input_set_abs_params(input_dev, ABS_DISTANCE,
++<<<<<<< HEAD
 +			     0, wacom_wac->features.distance_max, 0, 0);
 +	input_set_abs_params(input_dev, ABS_WHEEL, 0, 1023, 0, 0);
 +	input_set_abs_params(input_dev, ABS_TILT_X, -64, 63, 0, 0);
 +	input_set_abs_params(input_dev, ABS_TILT_Y, -64, 63, 0, 0);
++=======
+ 			     0, wacom_wac->features.distance_max, wacom_wac->features.distance_fuzz, 0);
+ }
+ 
+ static void wacom_setup_cintiq(struct wacom_wac *wacom_wac)
+ {
+ 	struct input_dev *input_dev = wacom_wac->pen_input;
+ 	struct wacom_features *features = &wacom_wac->features;
+ 
+ 	wacom_setup_basic_pro_pen(wacom_wac);
+ 
+ 	__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
+ 	__set_bit(BTN_TOOL_BRUSH, input_dev->keybit);
+ 	__set_bit(BTN_TOOL_PENCIL, input_dev->keybit);
+ 	__set_bit(BTN_TOOL_AIRBRUSH, input_dev->keybit);
+ 
+ 	input_set_abs_params(input_dev, ABS_WHEEL, 0, 1023, 0, 0);
+ 	input_set_abs_params(input_dev, ABS_TILT_X, -64, 63, features->tilt_fuzz, 0);
+ 	input_abs_set_res(input_dev, ABS_TILT_X, 57);
+ 	input_set_abs_params(input_dev, ABS_TILT_Y, -64, 63, features->tilt_fuzz, 0);
+ 	input_abs_set_res(input_dev, ABS_TILT_Y, 57);
++>>>>>>> bef7e2000650 (HID: wacom: Add fuzz factor to distance and tilt axes)
  }
  
  static void wacom_setup_intuos(struct wacom_wac *wacom_wac)
@@@ -1545,37 -2774,39 +1568,43 @@@ int wacom_setup_input_capabilities(stru
  
  	input_dev->evbit[0] |= BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
  
 -	/* kept for making legacy xf86-input-wacom working with the wheels */
 +	__set_bit(BTN_TOUCH, input_dev->keybit);
  	__set_bit(ABS_MISC, input_dev->absbit);
  
 -	/* kept for making legacy xf86-input-wacom accepting the pad */
 -	input_set_abs_params(input_dev, ABS_X, 0, 1, 0, 0);
 -	input_set_abs_params(input_dev, ABS_Y, 0, 1, 0, 0);
 -
 -	/* kept for making udev and libwacom accepting the pad */
 -	__set_bit(BTN_STYLUS, input_dev->keybit);
 -
 -	wacom_setup_numbered_buttons(input_dev, features->numbered_buttons);
 -
 -	switch (features->type) {
 -
 -	case CINTIQ_HYBRID:
 -	case CINTIQ_COMPANION_2:
 -	case DTK:
 -	case DTUS:
 -	case GRAPHIRE_BT:
 -		break;
 +	wacom_abs_set_axis(input_dev, wacom_wac);
  
 +	switch (wacom_wac->features.type) {
  	case WACOM_MO:
 -		__set_bit(BTN_BACK, input_dev->keybit);
 -		__set_bit(BTN_LEFT, input_dev->keybit);
 -		__set_bit(BTN_FORWARD, input_dev->keybit);
 -		__set_bit(BTN_RIGHT, input_dev->keybit);
  		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
 -		break;
 +		/* fall through */
  
  	case WACOM_G4:
++<<<<<<< HEAD
 +		input_set_capability(input_dev, EV_MSC, MSC_SERIAL);
 +
  		__set_bit(BTN_BACK, input_dev->keybit);
  		__set_bit(BTN_FORWARD, input_dev->keybit);
++=======
++		input_set_abs_params(input_dev, ABS_DISTANCE, 0,
++					      features->distance_max,
++					      features->distance_fuzz, 0);
++>>>>>>> bef7e2000650 (HID: wacom: Add fuzz factor to distance and tilt axes)
 +		/* fall through */
 +
 +	case GRAPHIRE:
  		input_set_capability(input_dev, EV_REL, REL_WHEEL);
 +
 +		__set_bit(BTN_LEFT, input_dev->keybit);
 +		__set_bit(BTN_RIGHT, input_dev->keybit);
 +		__set_bit(BTN_MIDDLE, input_dev->keybit);
 +
 +		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +		__set_bit(BTN_TOOL_MOUSE, input_dev->keybit);
 +		__set_bit(BTN_STYLUS, input_dev->keybit);
 +		__set_bit(BTN_STYLUS2, input_dev->keybit);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
  	case WACOM_24HD:
@@@ -1691,145 -2861,47 +1720,156 @@@
  	case INTUOS5L:
  	case INTUOSPM:
  	case INTUOSPL:
 +		if (features->device_type == BTN_TOOL_PEN) {
 +			__set_bit(BTN_7, input_dev->keybit);
 +			__set_bit(BTN_8, input_dev->keybit);
 +		}
 +		/* fall through */
 +
  	case INTUOS5S:
  	case INTUOSPS:
 -		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
 -		break;
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  
 -	case INTUOS4WL:
 -		/*
 -		 * For Bluetooth devices, the udev rule does not work correctly
 -		 * for pads unless we add a stylus capability, which forces
 -		 * ID_INPUT_TABLET to be set.
 -		 */
 -		__set_bit(BTN_STYLUS, input_dev->keybit);
 -		/* fall through */
++<<<<<<< HEAD
 +		if (features->device_type == BTN_TOOL_PEN) {
 +			for (i = 0; i < 7; i++)
 +				__set_bit(BTN_0 + i, input_dev->keybit);
 +
 +			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
 +					      features->distance_max,
 +					      0, 0);
 +
 +			input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
 +
 +			wacom_setup_intuos(wacom_wac);
 +		} else if (features->device_type == BTN_TOOL_FINGER) {
 +			__clear_bit(ABS_MISC, input_dev->absbit);
 +
 +			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,
 +			                     0, features->x_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_TOUCH_MINOR,
 +			                     0, features->y_max, 0, 0);
 +			input_mt_init_slots(input_dev, features->touch_max, INPUT_MT_POINTER);
 +		}
 +		break;
  
  	case INTUOS4:
  	case INTUOS4L:
 +		__set_bit(BTN_7, input_dev->keybit);
 +		__set_bit(BTN_8, input_dev->keybit);
 +		/* fall through */
 +
  	case INTUOS4S:
 -		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
 +		for (i = 0; i < 7; i++)
 +			__set_bit(BTN_0 + i, input_dev->keybit);
++=======
++		input_set_abs_params(input_dev, ABS_DISTANCE, 0,
++				      features->distance_max,
++				      features->distance_fuzz, 0);
++>>>>>>> bef7e2000650 (HID: wacom: Add fuzz factor to distance and tilt axes)
 +
 +		input_set_abs_params(input_dev, ABS_Z, -900, 899, 0, 0);
 +		wacom_setup_intuos(wacom_wac);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
 -	case INTUOSHT:
 -	case BAMBOO_PT:
 -	case BAMBOO_TOUCH:
 -	case INTUOSHT2:
 +	case WACOM_24HDT:
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, features->x_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_WIDTH_MAJOR, 0, features->x_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_WIDTH_MINOR, 0, features->y_max, 0, 0);
 +			input_set_abs_params(input_dev, ABS_MT_ORIENTATION, 0, 1, 0, 0);
 +		}
 +		/* fall through */
 +
 +	case MTSCREEN:
 +	case MTTPC:
 +	case TABLETPC2FG:
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			unsigned int flags = INPUT_MT_DIRECT;
 +
 +			if (wacom_wac->features.type == TABLETPC2FG)
 +				flags = 0;
 +
 +			input_mt_init_slots(input_dev, features->touch_max, flags);
 +		}
 +		/* fall through */
 +
 +	case TABLETPC:
 +	case TABLETPCE:
  		__clear_bit(ABS_MISC, input_dev->absbit);
  
 -		__set_bit(BTN_LEFT, input_dev->keybit);
 -		__set_bit(BTN_FORWARD, input_dev->keybit);
 -		__set_bit(BTN_BACK, input_dev->keybit);
 -		__set_bit(BTN_RIGHT, input_dev->keybit);
 +		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
  
 +		if (features->device_type != BTN_TOOL_PEN)
 +			break;  /* no need to process stylus stuff */
 +
 +		/* fall through */
 +
 +	case PL:
 +	case DTU:
 +		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +		__set_bit(BTN_STYLUS, input_dev->keybit);
 +		__set_bit(BTN_STYLUS2, input_dev->keybit);
 +
 +		__set_bit(INPUT_PROP_DIRECT, input_dev->propbit);
  		break;
  
 -	case REMOTE:
 -		input_set_capability(input_dev, EV_MSC, MSC_SERIAL);
 -		input_set_abs_params(input_dev, ABS_WHEEL, 0, 71, 0, 0);
 +	case PTU:
 +		__set_bit(BTN_STYLUS2, input_dev->keybit);
 +		/* fall through */
 +
 +	case PENPARTNER:
 +		__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +		__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +		__set_bit(BTN_STYLUS, input_dev->keybit);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
  		break;
  
 -	default:
 -		/* no pad supported */
 -		return -ENODEV;
 +	case BAMBOO_PT:
 +		__clear_bit(ABS_MISC, input_dev->absbit);
 +
 +		__set_bit(INPUT_PROP_POINTER, input_dev->propbit);
 +
 +		if (features->device_type == BTN_TOOL_FINGER) {
 +			unsigned int flags = INPUT_MT_POINTER;
 +
 +			__set_bit(BTN_LEFT, input_dev->keybit);
 +			__set_bit(BTN_FORWARD, input_dev->keybit);
 +			__set_bit(BTN_BACK, input_dev->keybit);
 +			__set_bit(BTN_RIGHT, input_dev->keybit);
 +
 +			if (features->pktlen == WACOM_PKGLEN_BBTOUCH3) {
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MAJOR,
 +						     0, features->x_max, 0, 0);
 +				input_set_abs_params(input_dev,
 +						     ABS_MT_TOUCH_MINOR,
 +						     0, features->y_max, 0, 0);
 +			} else {
 +				__set_bit(BTN_TOOL_FINGER, input_dev->keybit);
 +				__set_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);
 +				flags = 0;
 +			}
 +			input_mt_init_slots(input_dev, features->touch_max, flags);
 +		} else if (features->device_type == BTN_TOOL_PEN) {
 +			__set_bit(BTN_TOOL_RUBBER, input_dev->keybit);
 +			__set_bit(BTN_TOOL_PEN, input_dev->keybit);
 +			__set_bit(BTN_STYLUS, input_dev->keybit);
 +			__set_bit(BTN_STYLUS2, input_dev->keybit);
 +			input_set_abs_params(input_dev, ABS_DISTANCE, 0,
++<<<<<<< HEAD
 +					      features->distance_max,
 +					      0, 0);
++=======
++				      features->distance_max,
++				      features->distance_fuzz, 0);
++>>>>>>> bef7e2000650 (HID: wacom: Add fuzz factor to distance and tilt axes)
 +		}
 +		break;
  	}
  	return 0;
  }
diff --git a/drivers/hid/wacom_sys.c b/drivers/hid/wacom_sys.c
index e75b5002a526..60def0a0ba13 100644
--- a/drivers/hid/wacom_sys.c
+++ b/drivers/hid/wacom_sys.c
@@ -597,7 +597,8 @@ static int wacom_retrieve_hid_descriptor(struct usb_interface *intf,
 	features->x_fuzz = 4;
 	features->y_fuzz = 4;
 	features->pressure_fuzz = 0;
-	features->distance_fuzz = 0;
+	features->distance_fuzz = 1;
+	features->tilt_fuzz = 1;
 
 	/*
 	 * The wireless device HID is basic and layout conflicts with
* Unmerged path drivers/hid/wacom_wac.c
diff --git a/drivers/hid/wacom_wac.h b/drivers/hid/wacom_wac.h
index d220d069f329..431e599f55d7 100644
--- a/drivers/hid/wacom_wac.h
+++ b/drivers/hid/wacom_wac.h
@@ -126,6 +126,7 @@ struct wacom_features {
 	int y_fuzz;
 	int pressure_fuzz;
 	int distance_fuzz;
+	int tilt_fuzz;
 	unsigned quirks;
 	unsigned touch_max;
 	int oVid;
