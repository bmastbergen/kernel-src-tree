block: fix blk_integrity_register to use template's interval_exp if not 0

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [block] fix blk_integrity_register to use template's interval_exp if not 0 (Mike Snitzer) [1445816]
Rebuild_FUZZ: 94.96%
commit-author Mike Snitzer <snitzer@redhat.com>
commit 2859323e35ab5fc42f351fbda23ab544eaa85945
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2859323e.failed

When registering an integrity profile: if the template's interval_exp is
not 0 use it, otherwise use the ilog2() of logical block size of the
provided gendisk.

This fixes a long-standing DM linear target bug where it cannot pass
integrity data to the underlying device if its logical block size
conflicts with the underlying device's logical block size.

	Cc: stable@vger.kernel.org
	Reported-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
	Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 2859323e35ab5fc42f351fbda23ab544eaa85945)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-integrity.c
diff --cc block/blk-integrity.c
index 03cf7179e8ef,0f891a9aff4d..000000000000
--- a/block/blk-integrity.c
+++ b/block/blk-integrity.c
@@@ -372,57 -398,27 +372,67 @@@ EXPORT_SYMBOL(blk_integrity_is_initiali
  /**
   * blk_integrity_register - Register a gendisk as being integrity-capable
   * @disk:	struct gendisk pointer to make integrity-aware
 - * @template:	block integrity profile to register
 + * @template:	optional integrity profile to register
   *
 - * Description: When a device needs to advertise itself as being able to
 - * send/receive integrity metadata it must use this function to register
 - * the capability with the block layer. The template is a blk_integrity
 - * struct with values appropriate for the underlying hardware. See
 - * Documentation/block/data-integrity.txt.
 + * Description: When a device needs to advertise itself as being able
 + * to send/receive integrity metadata it must use this function to
 + * register the capability with the block layer.  The template is a
 + * blk_integrity struct with values appropriate for the underlying
 + * hardware.  If template is NULL the new profile is allocated but
 + * not filled out. See Documentation/block/data-integrity.txt.
   */
 -void blk_integrity_register(struct gendisk *disk, struct blk_integrity *template)
 +int blk_integrity_register(struct gendisk *disk, struct blk_integrity *template)
  {
 -	struct blk_integrity *bi = &disk->queue->integrity;
 +	struct blk_integrity *bi;
  
++<<<<<<< HEAD
 +	BUG_ON(disk == NULL);
++=======
+ 	bi->flags = BLK_INTEGRITY_VERIFY | BLK_INTEGRITY_GENERATE |
+ 		template->flags;
+ 	bi->interval_exp = template->interval_exp ? :
+ 		ilog2(queue_logical_block_size(disk->queue));
+ 	bi->profile = template->profile ? template->profile : &nop_profile;
+ 	bi->tuple_size = template->tuple_size;
+ 	bi->tag_size = template->tag_size;
++>>>>>>> 2859323e35ab (block: fix blk_integrity_register to use template's interval_exp if not 0)
 +
 +	if (disk->integrity == NULL) {
 +		bi = kmem_cache_alloc(integrity_cachep,
 +				      GFP_KERNEL | __GFP_ZERO);
 +		if (!bi)
 +			return -1;
 +
 +		if (kobject_init_and_add(&bi->kobj, &integrity_ktype,
 +					 &disk_to_dev(disk)->kobj,
 +					 "%s", "integrity")) {
 +			kmem_cache_free(integrity_cachep, bi);
 +			return -1;
 +		}
  
 -	disk->queue->backing_dev_info->capabilities |= BDI_CAP_STABLE_WRITES;
 +		kobject_uevent(&bi->kobj, KOBJ_ADD);
 +
 +		bi->flags |= INTEGRITY_FLAG_READ | INTEGRITY_FLAG_WRITE;
 +		bi->sector_size = queue_logical_block_size(disk->queue);
 +		disk->integrity = bi;
 +	} else
 +		bi = disk->integrity;
 +
 +	/* Use the provided profile as template */
 +	if (template != NULL) {
 +		bi->name = template->name;
 +		bi->generate_fn = template->generate_fn;
 +		bi->verify_fn = template->verify_fn;
 +		bi->tuple_size = template->tuple_size;
 +		bi->set_tag_fn = template->set_tag_fn;
 +		bi->get_tag_fn = template->get_tag_fn;
 +		bi->tag_size = template->tag_size;
 +	} else
 +		bi->name = bi_unsupported_name;
 +
 +	disk->queue->backing_dev_info.capabilities |= BDI_CAP_STABLE_WRITES;
 +
 +	return 0;
  }
  EXPORT_SYMBOL(blk_integrity_register);
  
* Unmerged path block/blk-integrity.c
