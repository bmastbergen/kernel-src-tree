xen-netfront: call netif_carrier_off() only once when disconnecting

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author David Vrabel <david.vrabel@citrix.com>
commit f9feb1e6a25f9e197f9e6e6cb04bf04d2cccff93
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/f9feb1e6.failed

In xennet_disconnect_backend(), netif_carrier_off() was called once
per queue when it needs to only be called once.

The queue locking around the netif_carrier_off() call looked very
odd. I think they were supposed to synchronize any NAPI instances with
the expectation that no further NAPI instances would be scheduled
because of the carrier being off (see the check in
xennet_rx_interrupt()).  But I can't easily tell if this works
correctly.

Instead, add a napi_synchronize() call after disabling the interrupts.
This is obviously correct as with no Rx interrupts, no further NAPI
instances will be scheduled.

	Signed-off-by: David Vrabel <david.vrabel@citrix.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f9feb1e6a25f9e197f9e6e6cb04bf04d2cccff93)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/xen-netfront.c
diff --cc drivers/net/xen-netfront.c
index 6c33c68dceb8,055222bae6e4..000000000000
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@@ -1414,30 -1436,34 +1414,57 @@@ static void xennet_end_access(int ref, 
  
  static void xennet_disconnect_backend(struct netfront_info *info)
  {
 -	unsigned int i = 0;
 -	unsigned int num_queues = info->netdev->real_num_tx_queues;
 -
 +	/* Stop old i/f to prevent errors whilst we rebuild the state. */
 +	spin_lock_bh(&info->rx_lock);
 +	spin_lock_irq(&info->tx_lock);
 +	netif_carrier_off(info->netdev);
 +	spin_unlock_irq(&info->tx_lock);
 +	spin_unlock_bh(&info->rx_lock);
 +
++<<<<<<< HEAD
 +	if (info->tx_irq && (info->tx_irq == info->rx_irq))
 +		unbind_from_irqhandler(info->tx_irq, info);
 +	if (info->tx_irq && (info->tx_irq != info->rx_irq)) {
 +		unbind_from_irqhandler(info->tx_irq, info);
 +		unbind_from_irqhandler(info->rx_irq, info);
++=======
+ 	netif_carrier_off(info->netdev);
+ 
+ 	for (i = 0; i < num_queues; ++i) {
+ 		struct netfront_queue *queue = &info->queues[i];
+ 
+ 		if (queue->tx_irq && (queue->tx_irq == queue->rx_irq))
+ 			unbind_from_irqhandler(queue->tx_irq, queue);
+ 		if (queue->tx_irq && (queue->tx_irq != queue->rx_irq)) {
+ 			unbind_from_irqhandler(queue->tx_irq, queue);
+ 			unbind_from_irqhandler(queue->rx_irq, queue);
+ 		}
+ 		queue->tx_evtchn = queue->rx_evtchn = 0;
+ 		queue->tx_irq = queue->rx_irq = 0;
+ 
+ 		napi_synchronize(&queue->napi);
+ 
+ 		/* End access and free the pages */
+ 		xennet_end_access(queue->tx_ring_ref, queue->tx.sring);
+ 		xennet_end_access(queue->rx_ring_ref, queue->rx.sring);
+ 
+ 		queue->tx_ring_ref = GRANT_INVALID_REF;
+ 		queue->rx_ring_ref = GRANT_INVALID_REF;
+ 		queue->tx.sring = NULL;
+ 		queue->rx.sring = NULL;
++>>>>>>> f9feb1e6a25f (xen-netfront: call netif_carrier_off() only once when disconnecting)
  	}
 +	info->tx_evtchn = info->rx_evtchn = 0;
 +	info->tx_irq = info->rx_irq = 0;
 +
 +	/* End access and free the pages */
 +	xennet_end_access(info->tx_ring_ref, info->tx.sring);
 +	xennet_end_access(info->rx_ring_ref, info->rx.sring);
 +
 +	info->tx_ring_ref = GRANT_INVALID_REF;
 +	info->rx_ring_ref = GRANT_INVALID_REF;
 +	info->tx.sring = NULL;
 +	info->rx.sring = NULL;
  }
  
  /**
* Unmerged path drivers/net/xen-netfront.c
