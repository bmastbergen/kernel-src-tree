flow_dissector: Add flag to stop parsing at L3

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Tom Herbert <tom@herbertland.com>
commit 8306b688f1a6621b9efe3b0d827e26750528b12a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8306b688.failed

Add an input flag to flow dissector on rather dissection should be
stopped when an L3 packet is encountered. This would be useful if a
caller just wanted to get IP addresses of the outermost header (e.g.
to do an L3 hash).

	Signed-off-by: Tom Herbert <tom@herbertland.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8306b688f1a6621b9efe3b0d827e26750528b12a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_dissector.h
#	net/core/flow_dissector.c
diff --cc net/core/flow_dissector.c
index dae6e57d80c3,94fd841f341f..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -145,36 -177,77 +145,67 @@@ ip
  		nhoff += iph->ihl * 4;
  
  		ip_proto = iph->protocol;
 +		if (ip_is_fragment(iph))
 +			ip_proto = 0;
  
++<<<<<<< HEAD
 +		iph_to_flow_copy_addrs(flow, iph);
++=======
+ 		if (!skb_flow_dissector_uses_key(flow_dissector,
+ 						 FLOW_DISSECTOR_KEY_IPV4_ADDRS))
+ 			break;
+ 
+ 		key_addrs = skb_flow_dissector_target(flow_dissector,
+ 			      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);
+ 		memcpy(&key_addrs->v4addrs, &iph->saddr,
+ 		       sizeof(key_addrs->v4addrs));
+ 		key_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;
+ 
+ 		if (ip_is_fragment(iph)) {
+ 			key_control->is_fragment = 1;
+ 
+ 			if (iph->frag_off & htons(IP_OFFSET)) {
+ 				goto out_good;
+ 			} else {
+ 				key_control->first_frag = 1;
+ 				if (!(flags & FLOW_DISSECTOR_F_PARSE_1ST_FRAG))
+ 					goto out_good;
+ 			}
+ 		}
+ 
+ 		if (flags & FLOW_DISSECTOR_F_STOP_AT_L3)
+ 			goto out_good;
+ 
++>>>>>>> 8306b688f1a6 (flow_dissector: Add flag to stop parsing at L3)
  		break;
  	}
 -	case htons(ETH_P_IPV6): {
 +	case __constant_htons(ETH_P_IPV6): {
  		const struct ipv6hdr *iph;
  		struct ipv6hdr _iph;
 -		__be32 flow_label;
 -
  ipv6:
  		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
  		if (!iph)
 -			goto out_bad;
 +			return false;
  
  		ip_proto = iph->nexthdr;
 +		flow->src = (__force __be32)ipv6_addr_hash(&iph->saddr);
 +		flow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);
  		nhoff += sizeof(struct ipv6hdr);
  
 -		if (skb_flow_dissector_uses_key(flow_dissector,
 -						FLOW_DISSECTOR_KEY_IPV6_ADDRS)) {
 -			struct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;
 -
 -			key_ipv6_addrs = skb_flow_dissector_target(flow_dissector,
 -								   FLOW_DISSECTOR_KEY_IPV6_ADDRS,
 -								   target_container);
 -
 -			memcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));
 -			key_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;
 -		}
 -
 -		flow_label = ip6_flowlabel(iph);
 -		if (flow_label) {
 -			if (skb_flow_dissector_uses_key(flow_dissector,
 -				FLOW_DISSECTOR_KEY_FLOW_LABEL)) {
 -				key_tags = skb_flow_dissector_target(flow_dissector,
 -								     FLOW_DISSECTOR_KEY_FLOW_LABEL,
 -								     target_container);
 -				key_tags->flow_label = ntohl(flow_label);
 -			}
 -		}
 +		/* skip the flow label processing if skb is NULL.  The
 +		 * assumption here is that if there is no skb we are not
 +		 * looking for flow info as much as we are length.
 +		 */
 +		if (!skb)
 +			break;
  
+ 		if (flags & FLOW_DISSECTOR_F_STOP_AT_L3)
+ 			goto out_good;
+ 
  		break;
  	}
 -	case htons(ETH_P_8021AD):
 -	case htons(ETH_P_8021Q): {
 +	case __constant_htons(ETH_P_8021AD):
 +	case __constant_htons(ETH_P_8021Q): {
  		const struct vlan_hdr *vlan;
  		struct vlan_hdr _vlan;
  
* Unmerged path include/net/flow_dissector.h
* Unmerged path include/net/flow_dissector.h
* Unmerged path net/core/flow_dissector.c
