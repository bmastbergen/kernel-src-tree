i40e: properly cleanup on allocation failure in i40e_sync_vsi_filters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 4a2ce27bb5f291c38d8e49ef16899828289e4d3d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4a2ce27b.failed

Currently, we fail to correctly restore filters on the temporary add
list when we fail to allocate memory either for deletion or addition.
Replace calls to "goto out;" with calls to a new location that correctly
handles memory allocation failures.

Note that it is safe for us to call i40e_undo_filter_entries on the
tmp_del_list even after we've deleted filters because at this point it
will be empty, so we don't need to separate the logic for add and
delete failure.

Change-Id: Iee107fd219c6e03e2fd9645c2debf8e8384a8521
	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 4a2ce27bb5f291c38d8e49ef16899828289e4d3d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 6f5b9c2cdeec,35f06ba6bc4e..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -1717,16 -1688,21 +1717,22 @@@ bottom_of_search_loop
   * @from: Pointer to list which contains MAC filter entries - changes to
   *        those entries needs to be undone.
   *
-  * MAC filter entries from list were slated to be removed from device.
+  * MAC filter entries from list were slated to be sent to firmware, either for
+  * addition or deletion.
   **/
++<<<<<<< HEAD
 +static void i40e_undo_del_filter_entries(struct i40e_vsi *vsi,
 +					 struct list_head *from)
++=======
+ static void i40e_undo_filter_entries(struct i40e_vsi *vsi,
+ 				     struct hlist_head *from)
++>>>>>>> 4a2ce27bb5f2 (i40e: properly cleanup on allocation failure in i40e_sync_vsi_filters)
  {
 -	struct i40e_mac_filter *f;
 -	struct hlist_node *h;
 -
 -	hlist_for_each_entry_safe(f, h, from, hlist) {
 -		u64 key = i40e_addr_to_hkey(f->macaddr);
 +	struct i40e_mac_filter *f, *ftmp;
  
 +	list_for_each_entry_safe(f, ftmp, from, list) {
  		/* Move the element back into MAC filter list*/
 -		hlist_del(&f->hlist);
 -		hash_add(vsi->mac_filter_hash, &f->hlist, key);
 +		list_move_tail(&f->list, &vsi->mac_filter_list);
  	}
  }
  
@@@ -1858,16 -1841,10 +1864,21 @@@ int i40e_sync_vsi_filters(struct i40e_v
  		list_size = filter_list_len *
  			    sizeof(struct i40e_aqc_remove_macvlan_element_data);
  		del_list = kzalloc(list_size, GFP_ATOMIC);
++<<<<<<< HEAD
 +		if (!del_list) {
 +			/* Undo VSI's MAC filter entry element updates */
 +			spin_lock_bh(&vsi->mac_filter_list_lock);
 +			i40e_undo_del_filter_entries(vsi, &tmp_del_list);
 +			spin_unlock_bh(&vsi->mac_filter_list_lock);
 +			retval = -ENOMEM;
 +			goto out;
 +		}
++=======
+ 		if (!del_list)
+ 			goto err_no_memory;
++>>>>>>> 4a2ce27bb5f2 (i40e: properly cleanup on allocation failure in i40e_sync_vsi_filters)
  
 -		hlist_for_each_entry_safe(f, h, &tmp_del_list, hlist) {
 +		list_for_each_entry_safe(f, ftmp, &tmp_del_list, list) {
  			cmd_flags = 0;
  
  			/* add to delete list */
@@@ -1942,12 -1919,11 +1953,11 @@@
  		list_size = filter_list_len *
  			       sizeof(struct i40e_aqc_add_macvlan_element_data);
  		add_list = kzalloc(list_size, GFP_ATOMIC);
- 		if (!add_list) {
- 			retval = -ENOMEM;
- 			goto out;
- 		}
+ 		if (!add_list)
+ 			goto err_no_memory;
+ 
  		num_add = 0;
 -		hlist_for_each_entry(f, &tmp_add_list, hlist) {
 +		list_for_each_entry(f, &tmp_add_list, list) {
  			if (test_bit(__I40E_FILTER_OVERFLOW_PROMISC,
  				     &vsi->state)) {
  				f->state = I40E_FILTER_FAILED;
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
