ixgbe: add support for geneve Rx offload

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Emil Tantilov <emil.s.tantilov@intel.com>
commit a21d0822ff693655b4bf412405ecd649636f3d3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/a21d0822.failed

Add geneve Rx offload support for x550em_a.

The implementation follows the vxlan code with the lower 16 bits of
the VXLANCTRL register holding the UDP port for VXLAN and the upper
for Geneve.

Disabled NFS filters in the RFCTL register which allows us to simplify
the check for VXLAN and Geneve packets in ixgbe_rx_checksum().

Removed vxlan from the name of the callback functions and replaced it
with udp_tunnel which is more in line with the new API.

	Signed-off-by: Emil Tantilov <emil.s.tantilov@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit a21d0822ff693655b4bf412405ecd649636f3d3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index c5b66180bd18,5b8819c56d53..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -6153,10 -6153,8 +6162,15 @@@ int ixgbe_open(struct net_device *netde
  
  	ixgbe_up_complete(adapter);
  
++<<<<<<< HEAD
 +	ixgbe_clear_vxlan_port(adapter);
 +#ifdef CONFIG_IXGBE_VXLAN
 +	vxlan_get_rx_port(netdev);
 +#endif
++=======
+ 	ixgbe_clear_udp_tunnel_port(adapter, IXGBE_VXLANCTRL_ALL_UDPPORT_MASK);
+ 	udp_tunnel_get_rx_info(netdev);
++>>>>>>> a21d0822ff69 (ixgbe: add support for geneve Rx offload)
  
  	return 0;
  
@@@ -7235,14 -7232,12 +7249,22 @@@ static void ixgbe_service_task(struct w
  		ixgbe_service_event_complete(adapter);
  		return;
  	}
++<<<<<<< HEAD
 +#ifdef CONFIG_IXGBE_VXLAN
 +	rtnl_lock();
 +	if (adapter->flags2 & IXGBE_FLAG2_VXLAN_REREG_NEEDED) {
 +		adapter->flags2 &= ~IXGBE_FLAG2_VXLAN_REREG_NEEDED;
 +		vxlan_get_rx_port(adapter->netdev);
++=======
+ 	if (adapter->flags2 & IXGBE_FLAG2_UDP_TUN_REREG_NEEDED) {
+ 		rtnl_lock();
+ 		adapter->flags2 &= ~IXGBE_FLAG2_UDP_TUN_REREG_NEEDED;
+ 		udp_tunnel_get_rx_info(adapter->netdev);
+ 		rtnl_unlock();
++>>>>>>> a21d0822ff69 (ixgbe: add support for geneve Rx offload)
  	}
 +	rtnl_unlock();
 +#endif /* CONFIG_IXGBE_VXLAN */
  	ixgbe_reset_subtask(adapter);
  	ixgbe_phy_interrupt_subtask(adapter);
  	ixgbe_sfp_detection_subtask(adapter);
@@@ -7680,8 -7674,11 +7702,12 @@@ static void ixgbe_atr(struct ixgbe_rin
  		if (adapter->vxlan_port &&
  		    udp_hdr(skb)->dest == adapter->vxlan_port)
  			hdr.network = skb_inner_network_header(skb);
+ 
+ 		if (adapter->geneve_port &&
+ 		    udp_hdr(skb)->dest == adapter->geneve_port)
+ 			hdr.network = skb_inner_network_header(skb);
  	}
 +#endif /* CONFIG_IXGBE_VXLAN */
  
  	/* Currently only IPv4/IPv6 with TCP is supported */
  	switch (hdr.ipv4->version) {
@@@ -8398,14 -8812,25 +8424,27 @@@ static int ixgbe_set_features(struct ne
  
  	netdev->features = features;
  
 +#ifdef CONFIG_IXGBE_VXLAN
  	if ((adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE)) {
- 		if (features & NETIF_F_RXCSUM)
- 			adapter->flags2 |= IXGBE_FLAG2_VXLAN_REREG_NEEDED;
- 		else
- 			ixgbe_clear_vxlan_port(adapter);
+ 		if (features & NETIF_F_RXCSUM) {
+ 			adapter->flags2 |= IXGBE_FLAG2_UDP_TUN_REREG_NEEDED;
+ 		} else {
+ 			u32 port_mask = IXGBE_VXLANCTRL_VXLAN_UDPPORT_MASK;
+ 
+ 			ixgbe_clear_udp_tunnel_port(adapter, port_mask);
+ 		}
+ 	}
+ 
+ 	if ((adapter->flags & IXGBE_FLAG_GENEVE_OFFLOAD_CAPABLE)) {
+ 		if (features & NETIF_F_RXCSUM) {
+ 			adapter->flags2 |= IXGBE_FLAG2_UDP_TUN_REREG_NEEDED;
+ 		} else {
+ 			u32 port_mask = IXGBE_VXLANCTRL_GENEVE_UDPPORT_MASK;
+ 
+ 			ixgbe_clear_udp_tunnel_port(adapter, port_mask);
+ 		}
  	}
 +#endif /* CONFIG_IXGBE_VXLAN */
  
  	if (need_reset)
  		ixgbe_do_reset(netdev);
@@@ -8416,32 -8841,60 +8455,78 @@@
  	return 0;
  }
  
 +#ifdef CONFIG_IXGBE_VXLAN
  /**
-  * ixgbe_add_vxlan_port - Get notifications about VXLAN ports that come up
+  * ixgbe_add_udp_tunnel_port - Get notifications about adding UDP tunnel ports
   * @dev: The port's netdev
 - * @ti: Tunnel endpoint information
 + * @sa_family: Socket Family that VXLAN is notifiying us about
 + * @port: New UDP port number that VXLAN started listening to
   **/
++<<<<<<< HEAD
 +static void ixgbe_add_vxlan_port(struct net_device *dev, sa_family_t sa_family,
 +				 __be16 port)
 +{
 +	struct ixgbe_adapter *adapter = netdev_priv(dev);
 +	struct ixgbe_hw *hw = &adapter->hw;
++=======
+ static void ixgbe_add_udp_tunnel_port(struct net_device *dev,
+ 				      struct udp_tunnel_info *ti)
+ {
+ 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	__be16 port = ti->port;
+ 	u32 port_shift = 0;
+ 	u32 reg;
  
- 	if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE))
+ 	if (ti->sa_family != AF_INET)
  		return;
++>>>>>>> a21d0822ff69 (ixgbe: add support for geneve Rx offload)
  
+ 	switch (ti->type) {
+ 	case UDP_TUNNEL_TYPE_VXLAN:
+ 		if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE))
+ 			return;
+ 
++<<<<<<< HEAD
 +	if (sa_family == AF_INET6)
 +		return;
 +
 +	if (adapter->vxlan_port == port)
 +		return;
++=======
+ 		if (adapter->vxlan_port == port)
+ 			return;
++>>>>>>> a21d0822ff69 (ixgbe: add support for geneve Rx offload)
  
- 	if (adapter->vxlan_port) {
- 		netdev_info(dev,
- 			    "Hit Max num of VXLAN ports, not adding port %d\n",
- 			    ntohs(port));
+ 		if (adapter->vxlan_port) {
+ 			netdev_info(dev,
+ 				    "VXLAN port %d set, not adding port %d\n",
+ 				    ntohs(adapter->vxlan_port),
+ 				    ntohs(port));
+ 			return;
+ 		}
+ 
+ 		adapter->vxlan_port = port;
+ 		break;
+ 	case UDP_TUNNEL_TYPE_GENEVE:
+ 		if (!(adapter->flags & IXGBE_FLAG_GENEVE_OFFLOAD_CAPABLE))
+ 			return;
+ 
+ 		if (adapter->geneve_port == port)
+ 			return;
+ 
+ 		if (adapter->geneve_port) {
+ 			netdev_info(dev,
+ 				    "GENEVE port %d set, not adding port %d\n",
+ 				    ntohs(adapter->geneve_port),
+ 				    ntohs(port));
+ 			return;
+ 		}
+ 
+ 		port_shift = IXGBE_VXLANCTRL_GENEVE_UDPPORT_SHIFT;
+ 		adapter->geneve_port = port;
+ 		break;
+ 	default:
  		return;
  	}
  
@@@ -8450,32 -8903,55 +8535,74 @@@
  }
  
  /**
-  * ixgbe_del_vxlan_port - Get notifications about VXLAN ports that go away
+  * ixgbe_del_udp_tunnel_port - Get notifications about removing UDP tunnel ports
   * @dev: The port's netdev
 - * @ti: Tunnel endpoint information
 + * @sa_family: Socket Family that VXLAN is notifying us about
 + * @port: UDP port number that VXLAN stopped listening to
   **/
++<<<<<<< HEAD
 +static void ixgbe_del_vxlan_port(struct net_device *dev, sa_family_t sa_family,
 +				 __be16 port)
++=======
+ static void ixgbe_del_udp_tunnel_port(struct net_device *dev,
+ 				      struct udp_tunnel_info *ti)
++>>>>>>> a21d0822ff69 (ixgbe: add support for geneve Rx offload)
  {
  	struct ixgbe_adapter *adapter = netdev_priv(dev);
+ 	u32 port_mask;
  
++<<<<<<< HEAD
 +	if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE))
 +		return;
 +
 +	if (sa_family == AF_INET6)
 +		return;
 +
 +	if (adapter->vxlan_port != port) {
 +		netdev_info(dev, "Port %d was not found, not deleting\n",
 +			    ntohs(port));
++=======
+ 	if (ti->type != UDP_TUNNEL_TYPE_VXLAN &&
+ 	    ti->type != UDP_TUNNEL_TYPE_GENEVE)
+ 		return;
+ 
+ 	if (ti->sa_family != AF_INET)
+ 		return;
+ 
+ 	switch (ti->type) {
+ 	case UDP_TUNNEL_TYPE_VXLAN:
+ 		if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE))
+ 			return;
+ 
+ 		if (adapter->vxlan_port != ti->port) {
+ 			netdev_info(dev, "VXLAN port %d not found\n",
+ 				    ntohs(ti->port));
+ 			return;
+ 		}
+ 
+ 		port_mask = IXGBE_VXLANCTRL_VXLAN_UDPPORT_MASK;
+ 		break;
+ 	case UDP_TUNNEL_TYPE_GENEVE:
+ 		if (!(adapter->flags & IXGBE_FLAG_GENEVE_OFFLOAD_CAPABLE))
+ 			return;
+ 
+ 		if (adapter->geneve_port != ti->port) {
+ 			netdev_info(dev, "GENEVE port %d not found\n",
+ 				    ntohs(ti->port));
+ 			return;
+ 		}
+ 
+ 		port_mask = IXGBE_VXLANCTRL_GENEVE_UDPPORT_MASK;
+ 		break;
+ 	default:
++>>>>>>> a21d0822ff69 (ixgbe: add support for geneve Rx offload)
  		return;
  	}
  
- 	ixgbe_clear_vxlan_port(adapter);
- 	adapter->flags2 |= IXGBE_FLAG2_VXLAN_REREG_NEEDED;
+ 	ixgbe_clear_udp_tunnel_port(adapter, port_mask);
+ 	adapter->flags2 |= IXGBE_FLAG2_UDP_TUN_REREG_NEEDED;
  }
 +#endif /* CONFIG_IXGBE_VXLAN */
  
  static int ixgbe_ndo_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
  			     struct net_device *dev,
@@@ -8770,13 -9262,11 +8897,20 @@@ static const struct net_device_ops ixgb
  	.ndo_fdb_add		= ixgbe_ndo_fdb_add,
  	.ndo_bridge_setlink	= ixgbe_ndo_bridge_setlink,
  	.ndo_bridge_getlink	= ixgbe_ndo_bridge_getlink,
++<<<<<<< HEAD
 +#ifdef CONFIG_IXGBE_VXLAN
 +	.ndo_add_vxlan_port	= ixgbe_add_vxlan_port,
 +	.ndo_del_vxlan_port	= ixgbe_del_vxlan_port,
 +#endif /* CONFIG_IXGBE_VXLAN */
++=======
+ 	.ndo_dfwd_add_station	= ixgbe_fwd_add,
+ 	.ndo_dfwd_del_station	= ixgbe_fwd_del,
+ 	.ndo_udp_tunnel_add	= ixgbe_add_udp_tunnel_port,
+ 	.ndo_udp_tunnel_del	= ixgbe_del_udp_tunnel_port,
++>>>>>>> a21d0822ff69 (ixgbe: add support for geneve Rx offload)
  	.ndo_features_check	= ixgbe_features_check,
 +	.extended.ndo_dfwd_add_station	= ixgbe_fwd_add,
 +	.extended.ndo_dfwd_del_station	= ixgbe_fwd_del,
  };
  
  /**
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe.h b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
index 7fe5a702b332..f23cd786e550 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
@@ -677,6 +677,7 @@ struct ixgbe_adapter {
 #define IXGBE_FLAG_RX_HWTSTAMP_ENABLED		BIT(25)
 #define IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER	BIT(26)
 #define IXGBE_FLAG_DCB_CAPABLE			BIT(27)
+#define IXGBE_FLAG_GENEVE_OFFLOAD_CAPABLE	BIT(28)
 
 	u32 flags2;
 #define IXGBE_FLAG2_RSC_CAPABLE			BIT(0)
@@ -690,7 +691,7 @@ struct ixgbe_adapter {
 #define IXGBE_FLAG2_RSS_FIELD_IPV6_UDP		BIT(9)
 #define IXGBE_FLAG2_PTP_PPS_ENABLED		BIT(10)
 #define IXGBE_FLAG2_PHY_INTERRUPT		BIT(11)
-#define IXGBE_FLAG2_VXLAN_REREG_NEEDED		BIT(12)
+#define IXGBE_FLAG2_UDP_TUN_REREG_NEEDED	BIT(12)
 #define IXGBE_FLAG2_VLAN_PROMISC		BIT(13)
 
 	/* Tx fast path data */
@@ -704,6 +705,7 @@ struct ixgbe_adapter {
 
 	/* Port number used to identify VXLAN traffic */
 	__be16 vxlan_port;
+	__be16 geneve_port;
 
 	/* TX */
 	struct ixgbe_ring *tx_ring[MAX_TX_QUEUES] ____cacheline_aligned_in_smp;
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
index da3d8358fee0..a8a47360b469 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
@@ -487,6 +487,13 @@ struct ixgbe_thermal_sensor_data {
 #define IXGBE_FHFT_EXT(_n)	(0x09800 + ((_n) * 0x100)) /* Ext Flexible Host
 							    * Filter Table */
 
+/* masks for accessing VXLAN and GENEVE UDP ports */
+#define IXGBE_VXLANCTRL_VXLAN_UDPPORT_MASK     0x0000ffff /* VXLAN port */
+#define IXGBE_VXLANCTRL_GENEVE_UDPPORT_MASK    0xffff0000 /* GENEVE port */
+#define IXGBE_VXLANCTRL_ALL_UDPPORT_MASK       0xffffffff /* GENEVE/VXLAN */
+
+#define IXGBE_VXLANCTRL_GENEVE_UDPPORT_SHIFT   16
+
 #define IXGBE_FLEXIBLE_FILTER_COUNT_MAX         4
 #define IXGBE_EXT_FLEXIBLE_FILTER_COUNT_MAX     2
 
