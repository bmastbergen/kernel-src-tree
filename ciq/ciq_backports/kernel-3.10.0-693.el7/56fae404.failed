bridge: Fix incorrect re-injection of STP packets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Ido Schimmel <idosch@mellanox.com>
commit 56fae404fb2c306db0a35dad0d16fa24c65678f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/56fae404.failed

Commit 8626c56c8279 ("bridge: fix potential use-after-free when hook
returns QUEUE or STOLEN verdict") fixed incorrect usage of NF_HOOK's
return value by consuming packets in okfn via br_pass_frame_up().

However, this function re-injects packets to the Rx path with skb->dev
set to the bridge device, which breaks kernel's STP, as all STP packets
appear to originate from the bridge device itself.

Instead, if STP is enabled and bridge isn't a 802.1ad bridge, then learn
packet's SMAC and inject it back to the Rx path for further processing
by the packet handlers.

The patch also makes netfilter's behavior consistent with regards to
packets destined to the Bridge Group Address, as no hook registered at
LOCAL_IN will ever be called, regardless if STP is enabled or not.

	Cc: Florian Westphal <fw@strlen.de>
	Cc: Shmulik Ladkani <shmulik.ladkani@gmail.com>
	Cc: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
Fixes: 8626c56c8279 ("bridge: fix potential use-after-free when hook returns QUEUE or STOLEN verdict")
	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 56fae404fb2c306db0a35dad0d16fa24c65678f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_input.c
diff --cc net/bridge/br_input.c
index ddc6cbe6269c,43d2cd862bc2..000000000000
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@@ -143,8 -213,7 +143,12 @@@ drop
  }
  EXPORT_SYMBOL_GPL(br_handle_frame_finish);
  
++<<<<<<< HEAD
 +/* note: already called with rcu_read_lock */
 +static int br_handle_local_finish(struct sock *sk, struct sk_buff *skb)
++=======
+ static void __br_handle_local_finish(struct sk_buff *skb)
++>>>>>>> 56fae404fb2c (bridge: Fix incorrect re-injection of STP packets)
  {
  	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
  	u16 vid = 0;
@@@ -152,7 -221,18 +156,22 @@@
  	/* check if vlan is allowed, to avoid spoofing */
  	if (p->flags & BR_LEARNING && br_should_learn(p, skb, &vid))
  		br_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid, false);
++<<<<<<< HEAD
 +	return 0;	 /* process further */
++=======
+ }
+ 
+ /* note: already called with rcu_read_lock */
+ static int br_handle_local_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
+ {
+ 	struct net_bridge_port *p = br_port_get_rcu(skb->dev);
+ 
+ 	__br_handle_local_finish(skb);
+ 
+ 	BR_INPUT_SKB_CB(skb)->brdev = p->br->dev;
+ 	br_pass_frame_up(skb);
+ 	return 0;
++>>>>>>> 56fae404fb2c (bridge: Fix incorrect re-injection of STP packets)
  }
  
  /*
* Unmerged path net/bridge/br_input.c
