{net,IB}/mlx5: Modify QP commands via mlx5 ifc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [kernel] {net, ib}/mlx5: Modify QP commands via mlx5 ifc (Don Dutile) [1385330 1417285]
Rebuild_FUZZ: 98.92%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 1a412fb1caa2c1b77719ccb5ed8b0c3c2bc65da7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1a412fb1.failed

Prior to this patch we assumed that modify QP commands have the
same layout.

In ConnectX-4 for each QP transition there is a specific command
and their layout can vary.

e.g: 2err/2rst commands don't have QP context in their layout and before
this patch we posted the QP context in those commands.

Fortunately the FW only checks the suffix of the commands and executes
them, while ignoring all invalid data sent after the valid command
layout.

This patch removes mlx5_modify_qp_mbox_in and changes
mlx5_core_qp_modify to receive the required transition and QP context
with opt_param_mask if needed.  This way the caller is not required to
provide the command inbox layout and it will be generated automatically.

mlx5_core_qp_modify will generate the command inbox/outbox layouts
according to the requested transition and will fill the requested
parameters.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Leon Romanovsky <leon@kernel.org>
(cherry picked from commit 1a412fb1caa2c1b77719ccb5ed8b0c3c2bc65da7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
#	include/linux/mlx5/qp.h
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 0f82de09f2d9,626173736749..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -1831,7 -1871,7 +1831,11 @@@ static void destroy_qp_common(struct ml
  {
  	struct mlx5_ib_cq *send_cq, *recv_cq;
  	struct mlx5_ib_qp_base *base = &qp->trans_qp.base;
++<<<<<<< HEAD
 +	struct mlx5_modify_qp_mbox_in *in;
++=======
+ 	unsigned long flags;
++>>>>>>> 1a412fb1caa2 ({net,IB}/mlx5: Modify QP commands via mlx5 ifc)
  	int err;
  
  	if (qp->ibqp.rwq_ind_tbl) {
diff --cc include/linux/mlx5/qp.h
index 7879bf411891,0aacb2a7480d..000000000000
--- a/include/linux/mlx5/qp.h
+++ b/include/linux/mlx5/qp.h
@@@ -525,99 -521,6 +526,102 @@@ struct mlx5_qp_context 
  	u8			rsvd1[24];
  };
  
++<<<<<<< HEAD
 +struct mlx5_create_qp_mbox_in {
 +	struct mlx5_inbox_hdr	hdr;
 +	__be32			input_qpn;
 +	u8			rsvd0[4];
 +	__be32			opt_param_mask;
 +	u8			rsvd1[4];
 +	struct mlx5_qp_context	ctx;
 +	u8			rsvd3[16];
 +	__be64			pas[0];
 +};
 +
 +struct mlx5_create_qp_mbox_out {
 +	struct mlx5_outbox_hdr	hdr;
 +	__be32			qpn;
 +	u8			rsvd0[4];
 +};
 +
 +struct mlx5_destroy_qp_mbox_in {
 +	struct mlx5_inbox_hdr	hdr;
 +	__be32			qpn;
 +	u8			rsvd0[4];
 +};
 +
 +struct mlx5_destroy_qp_mbox_out {
 +	struct mlx5_outbox_hdr	hdr;
 +	u8			rsvd0[8];
 +};
 +
 +struct mlx5_modify_qp_mbox_in {
 +	struct mlx5_inbox_hdr	hdr;
 +	__be32			qpn;
 +	u8			rsvd0[4];
 +	__be32			optparam;
 +	u8			rsvd1[4];
 +	struct mlx5_qp_context	ctx;
 +	u8			rsvd2[16];
 +};
 +
 +struct mlx5_modify_qp_mbox_out {
 +	struct mlx5_outbox_hdr	hdr;
 +	u8			rsvd0[8];
 +};
 +
 +struct mlx5_query_qp_mbox_in {
 +	struct mlx5_inbox_hdr	hdr;
 +	__be32			qpn;
 +	u8			rsvd[4];
 +};
 +
 +struct mlx5_query_qp_mbox_out {
 +	struct mlx5_outbox_hdr	hdr;
 +	u8			rsvd1[8];
 +	__be32			optparam;
 +	u8			rsvd0[4];
 +	struct mlx5_qp_context	ctx;
 +	u8			rsvd2[16];
 +	__be64			pas[0];
 +};
 +
 +struct mlx5_conf_sqp_mbox_in {
 +	struct mlx5_inbox_hdr	hdr;
 +	__be32			qpn;
 +	u8			rsvd[3];
 +	u8			type;
 +};
 +
 +struct mlx5_conf_sqp_mbox_out {
 +	struct mlx5_outbox_hdr	hdr;
 +	u8			rsvd[8];
 +};
 +
 +struct mlx5_alloc_xrcd_mbox_in {
 +	struct mlx5_inbox_hdr	hdr;
 +	u8			rsvd[8];
 +};
 +
 +struct mlx5_alloc_xrcd_mbox_out {
 +	struct mlx5_outbox_hdr	hdr;
 +	__be32			xrcdn;
 +	u8			rsvd[4];
 +};
 +
 +struct mlx5_dealloc_xrcd_mbox_in {
 +	struct mlx5_inbox_hdr	hdr;
 +	__be32			xrcdn;
 +	u8			rsvd[4];
 +};
 +
 +struct mlx5_dealloc_xrcd_mbox_out {
 +	struct mlx5_outbox_hdr	hdr;
 +	u8			rsvd[8];
 +};
 +
++=======
++>>>>>>> 1a412fb1caa2 ({net,IB}/mlx5: Modify QP commands via mlx5 ifc)
  static inline struct mlx5_core_qp *__mlx5_qp_lookup(struct mlx5_core_dev *dev, u32 qpn)
  {
  	return radix_tree_lookup(&dev->priv.qp_table.tree, qpn);
@@@ -628,23 -531,12 +632,23 @@@ static inline struct mlx5_core_mkey *__
  	return radix_tree_lookup(&dev->priv.mkey_table.tree, key);
  }
  
 +struct mlx5_page_fault_resume_mbox_in {
 +	struct mlx5_inbox_hdr	hdr;
 +	__be32			flags_qpn;
 +	u8			reserved[4];
 +};
 +
 +struct mlx5_page_fault_resume_mbox_out {
 +	struct mlx5_outbox_hdr	hdr;
 +	u8			rsvd[8];
 +};
 +
  int mlx5_core_create_qp(struct mlx5_core_dev *dev,
  			struct mlx5_core_qp *qp,
 -			u32 *in,
 +			struct mlx5_create_qp_mbox_in *in,
  			int inlen);
- int mlx5_core_qp_modify(struct mlx5_core_dev *dev, u16 operation,
- 			struct mlx5_modify_qp_mbox_in *in, int sqd_event,
+ int mlx5_core_qp_modify(struct mlx5_core_dev *dev, u16 opcode,
+ 			u32 opt_param_mask, void *qpc,
  			struct mlx5_core_qp *qp);
  int mlx5_core_destroy_qp(struct mlx5_core_dev *dev,
  			 struct mlx5_core_qp *qp);
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/qp.c b/drivers/net/ethernet/mellanox/mlx5/core/qp.c
index b82d65802d96..75162dcd9b7c 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/qp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/qp.c
@@ -348,21 +348,127 @@ int mlx5_core_destroy_qp(struct mlx5_core_dev *dev,
 }
 EXPORT_SYMBOL_GPL(mlx5_core_destroy_qp);
 
-int mlx5_core_qp_modify(struct mlx5_core_dev *dev, u16 operation,
-			struct mlx5_modify_qp_mbox_in *in, int sqd_event,
+struct mbox_info {
+	u32 *in;
+	u32 *out;
+	int inlen;
+	int outlen;
+};
+
+static int mbox_alloc(struct mbox_info *mbox, int inlen, int outlen)
+{
+	mbox->inlen  = inlen;
+	mbox->outlen = outlen;
+	mbox->in = kzalloc(mbox->inlen, GFP_KERNEL);
+	mbox->out = kzalloc(mbox->outlen, GFP_KERNEL);
+	if (!mbox->in || !mbox->out) {
+		kfree(mbox->in);
+		kfree(mbox->out);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void mbox_free(struct mbox_info *mbox)
+{
+	kfree(mbox->in);
+	kfree(mbox->out);
+}
+
+static int modify_qp_mbox_alloc(struct mlx5_core_dev *dev, u16 opcode, int qpn,
+				u32 opt_param_mask, void *qpc,
+				struct mbox_info *mbox)
+{
+	mbox->out = NULL;
+	mbox->in = NULL;
+
+#define MBOX_ALLOC(mbox, typ)  \
+	mbox_alloc(mbox, MLX5_ST_SZ_BYTES(typ##_in), MLX5_ST_SZ_BYTES(typ##_out))
+
+#define MOD_QP_IN_SET(typ, in, _opcode, _qpn) \
+	MLX5_SET(typ##_in, in, opcode, _opcode); \
+	MLX5_SET(typ##_in, in, qpn, _qpn)
+
+#define MOD_QP_IN_SET_QPC(typ, in, _opcode, _qpn, _opt_p, _qpc) \
+	MOD_QP_IN_SET(typ, in, _opcode, _qpn); \
+	MLX5_SET(typ##_in, in, opt_param_mask, _opt_p); \
+	memcpy(MLX5_ADDR_OF(typ##_in, in, qpc), _qpc, MLX5_ST_SZ_BYTES(qpc))
+
+	switch (opcode) {
+	/* 2RST & 2ERR */
+	case MLX5_CMD_OP_2RST_QP:
+		if (MBOX_ALLOC(mbox, qp_2rst))
+			return -ENOMEM;
+		MOD_QP_IN_SET(qp_2rst, mbox->in, opcode, qpn);
+		break;
+	case MLX5_CMD_OP_2ERR_QP:
+		if (MBOX_ALLOC(mbox, qp_2err))
+			return -ENOMEM;
+		MOD_QP_IN_SET(qp_2err, mbox->in, opcode, qpn);
+		break;
+
+	/* MODIFY with QPC */
+	case MLX5_CMD_OP_RST2INIT_QP:
+		if (MBOX_ALLOC(mbox, rst2init_qp))
+			return -ENOMEM;
+		 MOD_QP_IN_SET_QPC(rst2init_qp, mbox->in, opcode, qpn,
+				   opt_param_mask, qpc);
+		 break;
+	case MLX5_CMD_OP_INIT2RTR_QP:
+		if (MBOX_ALLOC(mbox, init2rtr_qp))
+			return -ENOMEM;
+		 MOD_QP_IN_SET_QPC(init2rtr_qp, mbox->in, opcode, qpn,
+				   opt_param_mask, qpc);
+		 break;
+	case MLX5_CMD_OP_RTR2RTS_QP:
+		if (MBOX_ALLOC(mbox, rtr2rts_qp))
+			return -ENOMEM;
+		 MOD_QP_IN_SET_QPC(rtr2rts_qp, mbox->in, opcode, qpn,
+				   opt_param_mask, qpc);
+		 break;
+	case MLX5_CMD_OP_RTS2RTS_QP:
+		if (MBOX_ALLOC(mbox, rts2rts_qp))
+			return -ENOMEM;
+		MOD_QP_IN_SET_QPC(rts2rts_qp, mbox->in, opcode, qpn,
+				  opt_param_mask, qpc);
+		break;
+	case MLX5_CMD_OP_SQERR2RTS_QP:
+		if (MBOX_ALLOC(mbox, sqerr2rts_qp))
+			return -ENOMEM;
+		MOD_QP_IN_SET_QPC(sqerr2rts_qp, mbox->in, opcode, qpn,
+				  opt_param_mask, qpc);
+		break;
+	case MLX5_CMD_OP_INIT2INIT_QP:
+		if (MBOX_ALLOC(mbox, init2init_qp))
+			return -ENOMEM;
+		MOD_QP_IN_SET_QPC(init2init_qp, mbox->in, opcode, qpn,
+				  opt_param_mask, qpc);
+		break;
+	default:
+		mlx5_core_err(dev, "Unknown transition for modify QP: OP(0x%x) QPN(0x%x)\n",
+			      opcode, qpn);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int mlx5_core_qp_modify(struct mlx5_core_dev *dev, u16 opcode,
+			u32 opt_param_mask, void *qpc,
 			struct mlx5_core_qp *qp)
 {
-	struct mlx5_modify_qp_mbox_out out;
-	int err = 0;
+	struct mbox_info mbox;
+	int err;
 
-	memset(&out, 0, sizeof(out));
-	in->hdr.opcode = cpu_to_be16(operation);
-	in->qpn = cpu_to_be32(qp->qpn);
-	err = mlx5_cmd_exec(dev, in, sizeof(*in), &out, sizeof(out));
+	err = modify_qp_mbox_alloc(dev, opcode, qp->qpn,
+				   opt_param_mask, qpc, &mbox);
 	if (err)
 		return err;
 
-	return mlx5_cmd_status_to_err(&out.hdr);
+	err = mlx5_cmd_exec(dev, mbox.in, mbox.inlen, mbox.out, mbox.outlen);
+	err = err ? : mlx5_cmd_status_to_err_v2(mbox.out);
+	mbox_free(&mbox);
+	return err;
 }
 EXPORT_SYMBOL_GPL(mlx5_core_qp_modify);
 
* Unmerged path include/linux/mlx5/qp.h
