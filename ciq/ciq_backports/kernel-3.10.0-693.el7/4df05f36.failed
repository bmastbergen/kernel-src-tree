x86: Make sure IDT is page aligned

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [x86] Make sure IDT is page aligned (Lenny Szubowicz) [1422235]
Rebuild_FUZZ: 92.06%
commit-author Kees Cook <keescook@chromium.org>
commit 4df05f361937ee86e5a8c9ead8aeb6a19ea9b7d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/4df05f36.failed

Since the IDT is referenced from a fixmap, make sure it is page aligned.
Merge with 32-bit one, since it was already aligned to deal with F00F
bug. Since bss is cleared before IDT setup, it can live there. This also
moves the other *_idt_table variables into common locations.

This avoids the risk of the IDT ever being moved in the bss and having
the mapping be offset, resulting in calling incorrect handlers. In the
current upstream kernel this is not a manifested bug, but heavily patched
kernels (such as those using the PaX patch series) did encounter this bug.

The tables other than idt_table technically do not need to be page
aligned, at least not at the current time, but using a common
declaration avoids mistakes.  On 64 bits the table is exactly one page
long, anyway.

	Signed-off-by: Kees Cook <keescook@chromium.org>
Link: http://lkml.kernel.org/r/20130716183441.GA14232@www.outflux.net
	Reported-by: PaX Team <pageexec@gmail.com>
	Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>
(cherry picked from commit 4df05f361937ee86e5a8c9ead8aeb6a19ea9b7d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/head_64.S
diff --cc arch/x86/kernel/head_64.S
index d9643f283b17,e1aabdb314c8..000000000000
--- a/arch/x86/kernel/head_64.S
+++ b/arch/x86/kernel/head_64.S
@@@ -524,21 -512,6 +524,24 @@@ ENTRY(phys_base
  
  #include "../../x86/xen/xen-head.S"
  	
++<<<<<<< HEAD
 +	.section .bss, "aw", @nobits
 +	.align PAGE_SIZE
 +ENTRY(idt_table)
 +	.skip IDT_ENTRIES * 16
 +
 +	.align L1_CACHE_BYTES
 +ENTRY(debug_idt_table)
 +	.skip IDT_ENTRIES * 16
 +
 +#ifdef CONFIG_TRACING
 +	.align L1_CACHE_BYTES
 +ENTRY(trace_idt_table)
 +	.skip IDT_ENTRIES * 16
 +#endif
 +
++=======
++>>>>>>> 4df05f361937 (x86: Make sure IDT is page aligned)
  	__PAGE_ALIGNED_BSS
  NEXT_PAGE(empty_zero_page)
  	.skip PAGE_SIZE
* Unmerged path arch/x86/kernel/head_64.S
diff --git a/arch/x86/kernel/tracepoint.c b/arch/x86/kernel/tracepoint.c
index 4e584a8d6edd..1c113db9ed57 100644
--- a/arch/x86/kernel/tracepoint.c
+++ b/arch/x86/kernel/tracepoint.c
@@ -12,10 +12,8 @@ atomic_t trace_idt_ctr = ATOMIC_INIT(0);
 struct desc_ptr trace_idt_descr = { NR_VECTORS * 16 - 1,
 				(unsigned long) trace_idt_table };
 
-#ifndef CONFIG_X86_64
-gate_desc trace_idt_table[NR_VECTORS] __page_aligned_data
-					= { { { { 0, 0 } } }, };
-#endif
+/* No need to be aligned, but done to keep all IDTs defined the same way. */
+gate_desc trace_idt_table[NR_VECTORS] __page_aligned_bss;
 
 static int trace_irq_vector_refcount;
 static DEFINE_MUTEX(irq_vector_mutex);
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index 2f6a20837c41..bdf6d27d7f2e 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -67,19 +67,19 @@
 #include <asm/x86_init.h>
 #include <asm/pgalloc.h>
 #include <asm/proto.h>
+
+/* No need to be aligned, but done to keep all IDTs defined the same way. */
+gate_desc debug_idt_table[NR_VECTORS] __page_aligned_bss;
 #else
 #include <asm/processor-flags.h>
 #include <asm/setup.h>
 
 asmlinkage int system_call(void);
-
-/*
- * The IDT has to be page-aligned to simplify the Pentium
- * F0 0F bug workaround.
- */
-gate_desc idt_table[NR_VECTORS] __page_aligned_data = { { { { 0, 0 } } }, };
 #endif
 
+/* Must be page-aligned because the real IDT is used in a fixmap. */
+gate_desc idt_table[NR_VECTORS] __page_aligned_bss;
+
 DECLARE_BITMAP(used_vectors, NR_VECTORS);
 EXPORT_SYMBOL_GPL(used_vectors);
 
