xfs: convert mount option parsing to tokens

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Eric Sandeen <sandeen@sandeen.net>
commit 2e74af0e118992e62062a6f0666edcac6d64afdc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/2e74af0e.failed

This should be a no-op change, just switch to token parsing
like every other respectable filesystem does.

	Signed-off-by: Eric Sandeen <sandeen@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 2e74af0e118992e62062a6f0666edcac6d64afdc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_super.c
index 0ba7a4b9bc63,9e1538d48548..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -65,69 -65,20 +65,74 @@@ static struct kset *xfs_kset;		/* top-l
  static struct xfs_kobj xfs_dbg_kobj;	/* global debug sysfs attrs */
  #endif
  
++<<<<<<< HEAD
 +#define MNTOPT_LOGBUFS	"logbufs"	/* number of XFS log buffers */
 +#define MNTOPT_LOGBSIZE	"logbsize"	/* size of XFS log buffers */
 +#define MNTOPT_LOGDEV	"logdev"	/* log device */
 +#define MNTOPT_RTDEV	"rtdev"		/* realtime I/O device */
 +#define MNTOPT_BIOSIZE	"biosize"	/* log2 of preferred buffered io size */
 +#define MNTOPT_WSYNC	"wsync"		/* safe-mode nfs compatible mount */
 +#define MNTOPT_NOALIGN	"noalign"	/* turn off stripe alignment */
 +#define MNTOPT_SWALLOC	"swalloc"	/* turn on stripe width allocation */
 +#define MNTOPT_SUNIT	"sunit"		/* data volume stripe unit */
 +#define MNTOPT_SWIDTH	"swidth"	/* data volume stripe width */
 +#define MNTOPT_NOUUID	"nouuid"	/* ignore filesystem UUID */
 +#define MNTOPT_MTPT	"mtpt"		/* filesystem mount point */
 +#define MNTOPT_GRPID	"grpid"		/* group-ID from parent directory */
 +#define MNTOPT_NOGRPID	"nogrpid"	/* group-ID from current process */
 +#define MNTOPT_BSDGROUPS    "bsdgroups"    /* group-ID from parent directory */
 +#define MNTOPT_SYSVGROUPS   "sysvgroups"   /* group-ID from current process */
 +#define MNTOPT_ALLOCSIZE    "allocsize"    /* preferred allocation size */
 +#define MNTOPT_NORECOVERY   "norecovery"   /* don't run XFS recovery */
 +#define MNTOPT_BARRIER	"barrier"	/* use writer barriers for log write and
 +					 * unwritten extent conversion */
 +#define MNTOPT_NOBARRIER "nobarrier"	/* .. disable */
 +#define MNTOPT_64BITINODE   "inode64"	/* inodes can be allocated anywhere */
 +#define MNTOPT_32BITINODE   "inode32"	/* inode allocation limited to
 +					 * XFS_MAXINUMBER_32 */
 +#define MNTOPT_IKEEP	"ikeep"		/* do not free empty inode clusters */
 +#define MNTOPT_NOIKEEP	"noikeep"	/* free empty inode clusters */
 +#define MNTOPT_LARGEIO	   "largeio"	/* report large I/O sizes in stat() */
 +#define MNTOPT_NOLARGEIO   "nolargeio"	/* do not report large I/O sizes
 +					 * in stat(). */
 +#define MNTOPT_ATTR2	"attr2"		/* do use attr2 attribute format */
 +#define MNTOPT_NOATTR2	"noattr2"	/* do not use attr2 attribute format */
 +#define MNTOPT_FILESTREAM  "filestreams" /* use filestreams allocator */
 +#define MNTOPT_QUOTA	"quota"		/* disk quotas (user) */
 +#define MNTOPT_NOQUOTA	"noquota"	/* no quotas */
 +#define MNTOPT_USRQUOTA	"usrquota"	/* user quota enabled */
 +#define MNTOPT_GRPQUOTA	"grpquota"	/* group quota enabled */
 +#define MNTOPT_PRJQUOTA	"prjquota"	/* project quota enabled */
 +#define MNTOPT_UQUOTA	"uquota"	/* user quota (IRIX variant) */
 +#define MNTOPT_GQUOTA	"gquota"	/* group quota (IRIX variant) */
 +#define MNTOPT_PQUOTA	"pquota"	/* project quota (IRIX variant) */
 +#define MNTOPT_UQUOTANOENF "uqnoenforce"/* user quota limit enforcement */
 +#define MNTOPT_GQUOTANOENF "gqnoenforce"/* group quota limit enforcement */
 +#define MNTOPT_PQUOTANOENF "pqnoenforce"/* project quota limit enforcement */
 +#define MNTOPT_QUOTANOENF  "qnoenforce"	/* same as uqnoenforce */
 +#define MNTOPT_DELAYLOG    "delaylog"	/* Delayed logging enabled */
 +#define MNTOPT_NODELAYLOG  "nodelaylog"	/* Delayed logging disabled */
 +#define MNTOPT_DISCARD	   "discard"	/* Discard unused blocks */
 +#define MNTOPT_NODISCARD   "nodiscard"	/* Do not discard unused blocks */
 +
 +#define MNTOPT_DAX	"dax"		/* Enable direct access to bdev pages */
 +
++=======
++>>>>>>> 2e74af0e1189 (xfs: convert mount option parsing to tokens)
  /*
   * Table driven mount option parser.
-  *
-  * Currently only used for remount, but it will be used for mount
-  * in the future, too.
   */
  enum {
- 	Opt_barrier,
- 	Opt_nobarrier,
- 	Opt_inode64,
- 	Opt_inode32,
- 	Opt_err
+ 	Opt_logbufs, Opt_logbsize, Opt_logdev, Opt_rtdev, Opt_biosize,
+ 	Opt_wsync, Opt_noalign, Opt_swalloc, Opt_sunit, Opt_swidth, Opt_nouuid,
+ 	Opt_mtpt, Opt_grpid, Opt_nogrpid, Opt_bsdgroups, Opt_sysvgroups,
+ 	Opt_allocsize, Opt_norecovery, Opt_barrier, Opt_nobarrier,
+ 	Opt_inode64, Opt_inode32, Opt_ikeep, Opt_noikeep,
+ 	Opt_largeio, Opt_nolargeio, Opt_attr2, Opt_noattr2, Opt_filestreams,
+ 	Opt_quota, Opt_noquota, Opt_usrquota, Opt_grpquota, Opt_prjquota,
+ 	Opt_uquota, Opt_gquota, Opt_pquota,
+ 	Opt_uqnoenforce, Opt_gqnoenforce, Opt_pqnoenforce, Opt_qnoenforce,
+ 	Opt_discard, Opt_nodiscard, Opt_dax, Opt_err,
  };
  
  static const match_table_t tokens = {
@@@ -332,57 -325,48 +379,75 @@@ xfs_parseargs
  			mp->m_qflags &= ~XFS_ALL_QUOTA_ACCT;
  			mp->m_qflags &= ~XFS_ALL_QUOTA_ENFD;
  			mp->m_qflags &= ~XFS_ALL_QUOTA_ACTIVE;
- 		} else if (!strcmp(this_char, MNTOPT_QUOTA) ||
- 			   !strcmp(this_char, MNTOPT_UQUOTA) ||
- 			   !strcmp(this_char, MNTOPT_USRQUOTA)) {
+ 			break;
+ 		case Opt_quota:
+ 		case Opt_uquota:
+ 		case Opt_usrquota:
  			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE |
  					 XFS_UQUOTA_ENFD);
- 		} else if (!strcmp(this_char, MNTOPT_QUOTANOENF) ||
- 			   !strcmp(this_char, MNTOPT_UQUOTANOENF)) {
+ 			break;
+ 		case Opt_qnoenforce:
+ 		case Opt_uqnoenforce:
  			mp->m_qflags |= (XFS_UQUOTA_ACCT | XFS_UQUOTA_ACTIVE);
  			mp->m_qflags &= ~XFS_UQUOTA_ENFD;
- 		} else if (!strcmp(this_char, MNTOPT_PQUOTA) ||
- 			   !strcmp(this_char, MNTOPT_PRJQUOTA)) {
+ 			break;
+ 		case Opt_pquota:
+ 		case Opt_prjquota:
  			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE |
  					 XFS_PQUOTA_ENFD);
- 		} else if (!strcmp(this_char, MNTOPT_PQUOTANOENF)) {
+ 			break;
+ 		case Opt_pqnoenforce:
  			mp->m_qflags |= (XFS_PQUOTA_ACCT | XFS_PQUOTA_ACTIVE);
  			mp->m_qflags &= ~XFS_PQUOTA_ENFD;
- 		} else if (!strcmp(this_char, MNTOPT_GQUOTA) ||
- 			   !strcmp(this_char, MNTOPT_GRPQUOTA)) {
+ 		case Opt_gquota:
+ 		case Opt_grpquota:
  			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE |
  					 XFS_GQUOTA_ENFD);
- 		} else if (!strcmp(this_char, MNTOPT_GQUOTANOENF)) {
+ 			break;
+ 		case Opt_gqnoenforce:
  			mp->m_qflags |= (XFS_GQUOTA_ACCT | XFS_GQUOTA_ACTIVE);
  			mp->m_qflags &= ~XFS_GQUOTA_ENFD;
++<<<<<<< HEAD
 +		} else if (!strcmp(this_char, MNTOPT_DELAYLOG)) {
 +			xfs_warn(mp,
 +	"delaylog is the default now, option is deprecated.");
 +		} else if (!strcmp(this_char, MNTOPT_NODELAYLOG)) {
 +			xfs_warn(mp,
 +	"nodelaylog support has been removed, option is deprecated.");
 +		} else if (!strcmp(this_char, MNTOPT_DISCARD)) {
++=======
+ 			break;
+ 		case Opt_discard:
++>>>>>>> 2e74af0e1189 (xfs: convert mount option parsing to tokens)
  			mp->m_flags |= XFS_MOUNT_DISCARD;
- 		} else if (!strcmp(this_char, MNTOPT_NODISCARD)) {
+ 			break;
+ 		case Opt_nodiscard:
  			mp->m_flags &= ~XFS_MOUNT_DISCARD;
+ 			break;
  #ifdef CONFIG_FS_DAX
- 		} else if (!strcmp(this_char, MNTOPT_DAX)) {
+ 		case Opt_dax:
  			mp->m_flags |= XFS_MOUNT_DAX;
+ 			break;
  #endif
++<<<<<<< HEAD
 +		} else if (!strcmp(this_char, "ihashsize")) {
 +			xfs_warn(mp,
 +	"ihashsize no longer used, option is deprecated.");
 +		} else if (!strcmp(this_char, "osyncisdsync")) {
 +			xfs_warn(mp,
 +	"osyncisdsync has no effect, option is deprecated.");
 +		} else if (!strcmp(this_char, "osyncisosync")) {
 +			xfs_warn(mp,
 +	"osyncisosync has no effect, option is deprecated.");
 +		} else if (!strcmp(this_char, "irixsgid")) {
 +			xfs_warn(mp,
 +	"irixsgid is now a sysctl(2) variable, option is deprecated.");
 +		} else {
 +			xfs_warn(mp, "unknown mount option [%s].", this_char);
++=======
+ 		default:
+ 			xfs_warn(mp, "unknown mount option [%s].", p);
++>>>>>>> 2e74af0e1189 (xfs: convert mount option parsing to tokens)
  			return -EINVAL;
  		}
  	}
* Unmerged path fs/xfs/xfs_super.c
