crypto: testmgr - don't use interruptible wait in tests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [crypto] testmgr - don't use interruptible wait in tests (Herbert Xu) [1459191]
Rebuild_FUZZ: 92.16%
commit-author Rabin Vincent <rabin.vincent@axis.com>
commit 8a45ac12ec5b6ee67f8559c78ae11d9af8b821ee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8a45ac12.failed

tcrypt/testmgr uses wait_for_completion_interruptible() everywhere when
it waits for a request to be completed.  If it's interrupted, then the
test is aborted and the request is freed.

However, if any of these calls actually do get interrupted, the result
will likely be a kernel crash, when the driver handles the now-freed
request.  Use wait_for_completion() instead.

	Signed-off-by: Rabin Vincent <rabin.vincent@axis.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 8a45ac12ec5b6ee67f8559c78ae11d9af8b821ee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/tcrypt.c
#	crypto/testmgr.c
diff --cc crypto/tcrypt.c
index 41684883a4b3,004349576ba1..000000000000
--- a/crypto/tcrypt.c
+++ b/crypto/tcrypt.c
@@@ -762,10 -764,9 +762,16 @@@ static inline int do_one_ahash_op(struc
  	if (ret == -EINPROGRESS || ret == -EBUSY) {
  		struct tcrypt_result *tr = req->base.data;
  
++<<<<<<< HEAD
 +		ret = wait_for_completion_interruptible(&tr->completion);
 +		if (!ret)
 +			ret = tr->err;
 +		INIT_COMPLETION(tr->completion);
++=======
+ 		wait_for_completion(&tr->completion);
+ 		reinit_completion(&tr->completion);
+ 		ret = tr->err;
++>>>>>>> 8a45ac12ec5b (crypto: testmgr - don't use interruptible wait in tests)
  	}
  	return ret;
  }
@@@ -991,10 -992,9 +997,16 @@@ static inline int do_one_acipher_op(str
  	if (ret == -EINPROGRESS || ret == -EBUSY) {
  		struct tcrypt_result *tr = req->base.data;
  
++<<<<<<< HEAD
 +		ret = wait_for_completion_interruptible(&tr->completion);
 +		if (!ret)
 +			ret = tr->err;
 +		INIT_COMPLETION(tr->completion);
++=======
+ 		wait_for_completion(&tr->completion);
+ 		reinit_completion(&tr->completion);
+ 		ret = tr->err;
++>>>>>>> 8a45ac12ec5b (crypto: testmgr - don't use interruptible wait in tests)
  	}
  
  	return ret;
diff --cc crypto/testmgr.c
index cc134d1b6ccc,235b1fff04c4..000000000000
--- a/crypto/testmgr.c
+++ b/crypto/testmgr.c
@@@ -188,10 -181,9 +188,16 @@@ static void testmgr_free_buf(char *buf[
  static int wait_async_op(struct tcrypt_result *tr, int ret)
  {
  	if (ret == -EINPROGRESS || ret == -EBUSY) {
++<<<<<<< HEAD
 +		ret = wait_for_completion_interruptible(&tr->completion);
 +		if (!ret)
 +			ret = tr->err;
 +		INIT_COMPLETION(tr->completion);
++=======
+ 		wait_for_completion(&tr->completion);
+ 		reinit_completion(&tr->completion);
+ 		ret = tr->err;
++>>>>>>> 8a45ac12ec5b (crypto: testmgr - don't use interruptible wait in tests)
  	}
  	return ret;
  }
@@@ -353,6 -333,45 +359,48 @@@ static int test_hash(struct crypto_ahas
  				ret = -EINVAL;
  				goto out;
  			}
++<<<<<<< HEAD
++=======
+ 			crypto_ahash_clear_flags(tfm, ~0);
+ 			memcpy(key, template[i].key, template[i].ksize);
+ 			ret = crypto_ahash_setkey(tfm, key, template[i].ksize);
+ 
+ 			if (ret) {
+ 				printk(KERN_ERR "alg: hash: setkey "
+ 				       "failed on chunking test %d "
+ 				       "for %s: ret=%d\n", j, algo, -ret);
+ 				goto out;
+ 			}
+ 		}
+ 
+ 		ahash_request_set_crypt(req, sg, result, template[i].psize);
+ 		ret = crypto_ahash_digest(req);
+ 		switch (ret) {
+ 		case 0:
+ 			break;
+ 		case -EINPROGRESS:
+ 		case -EBUSY:
+ 			wait_for_completion(&tresult.completion);
+ 			reinit_completion(&tresult.completion);
+ 			ret = tresult.err;
+ 			if (!ret)
+ 				break;
+ 			/* fall through */
+ 		default:
+ 			printk(KERN_ERR "alg: hash: digest failed "
+ 			       "on chunking test %d for %s: "
+ 			       "ret=%d\n", j, algo, -ret);
+ 			goto out;
+ 		}
+ 
+ 		if (memcmp(result, template[i].digest,
+ 			   crypto_ahash_digestsize(tfm))) {
+ 			printk(KERN_ERR "alg: hash: Chunking test %d "
+ 			       "failed for %s\n", j, algo);
+ 			hexdump(result, crypto_ahash_digestsize(tfm));
+ 			ret = -EINVAL;
+ 			goto out;
++>>>>>>> 8a45ac12ec5b (crypto: testmgr - don't use interruptible wait in tests)
  		}
  	}
  
@@@ -427,152 -480,265 +475,214 @@@ static int __test_aead(struct crypto_ae
  	aead_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
  				  tcrypt_complete, &result);
  
 -	for (i = 0, j = 0; i < tcount; i++) {
 -		if (template[i].np)
 -			continue;
 -
 -		j++;
 -
 -		/* some templates have no input data but they will
 -		 * touch input
 -		 */
 -		input = xbuf[0];
 -		input += align_offset;
 -		assoc = axbuf[0];
 -
 -		ret = -EINVAL;
 -		if (WARN_ON(align_offset + template[i].ilen >
 -			    PAGE_SIZE || template[i].alen > PAGE_SIZE))
 -			goto out;
 +	iv_len = crypto_aead_ivsize(tfm);
  
 -		memcpy(input, template[i].input, template[i].ilen);
 -		memcpy(assoc, template[i].assoc, template[i].alen);
 -		if (template[i].iv)
 -			memcpy(iv, template[i].iv, MAX_IVLEN);
 -		else
 -			memset(iv, 0, MAX_IVLEN);
 +	for (i = 0, j = 0; i < tcount; i++) {
 +		if (!template[i].np) {
 +			j++;
  
 -		crypto_aead_clear_flags(tfm, ~0);
 -		if (template[i].wk)
 -			crypto_aead_set_flags(tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 +			/* some tepmplates have no input data but they will
 +			 * touch input
 +			 */
 +			input = xbuf[0];
 +			assoc = axbuf[0];
  
 -		if (template[i].klen > MAX_KEYLEN) {
 -			pr_err("alg: aead%s: setkey failed on test %d for %s: key size %d > %d\n",
 -			       d, j, algo, template[i].klen,
 -			       MAX_KEYLEN);
  			ret = -EINVAL;
 -			goto out;
 -		}
 -		memcpy(key, template[i].key, template[i].klen);
 -
 -		ret = crypto_aead_setkey(tfm, key, template[i].klen);
 -		if (!ret == template[i].fail) {
 -			pr_err("alg: aead%s: setkey failed on test %d for %s: flags=%x\n",
 -			       d, j, algo, crypto_aead_get_flags(tfm));
 -			goto out;
 -		} else if (ret)
 -			continue;
 -
 -		authsize = abs(template[i].rlen - template[i].ilen);
 -		ret = crypto_aead_setauthsize(tfm, authsize);
 -		if (ret) {
 -			pr_err("alg: aead%s: Failed to set authsize to %u on test %d for %s\n",
 -			       d, authsize, j, algo);
 -			goto out;
 -		}
 -
 -		if (diff_dst) {
 -			output = xoutbuf[0];
 -			output += align_offset;
 -			sg_init_one(&sg[0], input, template[i].ilen);
 -			sg_init_one(&sgout[0], output, template[i].rlen);
 -		} else {
 -			sg_init_one(&sg[0], input,
 -				    template[i].ilen + (enc ? authsize : 0));
 -			output = input;
 -		}
 +			if (WARN_ON(template[i].ilen > PAGE_SIZE ||
 +				    template[i].alen > PAGE_SIZE))
 +				goto out;
  
 -		sg_init_one(&asg[0], assoc, template[i].alen);
 +			memcpy(input, template[i].input, template[i].ilen);
 +			memcpy(assoc, template[i].assoc, template[i].alen);
 +			if (template[i].iv)
 +				memcpy(iv, template[i].iv, iv_len);
 +			else
 +				memset(iv, 0, iv_len);
  
 -		aead_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,
 -				       template[i].ilen, iv);
 +			crypto_aead_clear_flags(tfm, ~0);
 +			if (template[i].wk)
 +				crypto_aead_set_flags(
 +					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
  
 -		aead_request_set_assoc(req, asg, template[i].alen);
 +			key = template[i].key;
  
 -		ret = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);
 +			ret = crypto_aead_setkey(tfm, key,
 +						 template[i].klen);
 +			if (!ret == template[i].fail) {
 +				pr_err("alg: aead%s: setkey failed on test %d for %s: flags=%x\n",
 +				       d, j, algo, crypto_aead_get_flags(tfm));
 +				goto out;
 +			} else if (ret)
 +				continue;
  
 -		switch (ret) {
 -		case 0:
 -			if (template[i].novrfy) {
 -				/* verification was supposed to fail */
 -				pr_err("alg: aead%s: %s failed on test %d for %s: ret was 0, expected -EBADMSG\n",
 -				       d, e, j, algo);
 -				/* so really, we got a bad message */
 -				ret = -EBADMSG;
 +			authsize = abs(template[i].rlen - template[i].ilen);
 +			ret = crypto_aead_setauthsize(tfm, authsize);
 +			if (ret) {
 +				pr_err("alg: aead%s: Failed to set authsize to %u on test %d for %s\n",
 +				       d, authsize, j, algo);
  				goto out;
  			}
++<<<<<<< HEAD
++=======
+ 			break;
+ 		case -EINPROGRESS:
+ 		case -EBUSY:
+ 			wait_for_completion(&result.completion);
+ 			reinit_completion(&result.completion);
+ 			ret = result.err;
+ 			if (!ret)
+ 				break;
+ 		case -EBADMSG:
+ 			if (template[i].novrfy)
+ 				/* verification failure was expected */
+ 				continue;
+ 			/* fall through */
+ 		default:
+ 			pr_err("alg: aead%s: %s failed on test %d for %s: ret=%d\n",
+ 			       d, e, j, algo, -ret);
+ 			goto out;
+ 		}
++>>>>>>> 8a45ac12ec5b (crypto: testmgr - don't use interruptible wait in tests)
  
 -		q = output;
 -		if (memcmp(q, template[i].result, template[i].rlen)) {
 -			pr_err("alg: aead%s: Test %d failed on %s for %s\n",
 -			       d, j, e, algo);
 -			hexdump(q, template[i].rlen);
 -			ret = -EINVAL;
 -			goto out;
 -		}
 -	}
 -
 -	for (i = 0, j = 0; i < tcount; i++) {
 -		/* alignment tests are only done with continuous buffers */
 -		if (align_offset != 0)
 -			break;
 -
 -		if (!template[i].np)
 -			continue;
 +			sg_init_one(&sg[0], input,
 +				    template[i].ilen + (enc ? authsize : 0));
  
 -		j++;
 +			if (diff_dst) {
 +				output = xoutbuf[0];
 +				sg_init_one(&sgout[0], output,
 +					    template[i].ilen +
 +						(enc ? authsize : 0));
 +			} else {
 +				output = input;
 +			}
  
 -		if (template[i].iv)
 -			memcpy(iv, template[i].iv, MAX_IVLEN);
 -		else
 -			memset(iv, 0, MAX_IVLEN);
 +			sg_init_one(&asg[0], assoc, template[i].alen);
  
 -		crypto_aead_clear_flags(tfm, ~0);
 -		if (template[i].wk)
 -			crypto_aead_set_flags(tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 -		if (template[i].klen > MAX_KEYLEN) {
 -			pr_err("alg: aead%s: setkey failed on test %d for %s: key size %d > %d\n",
 -			       d, j, algo, template[i].klen, MAX_KEYLEN);
 -			ret = -EINVAL;
 -			goto out;
 -		}
 -		memcpy(key, template[i].key, template[i].klen);
 +			aead_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,
 +					       template[i].ilen, iv);
  
 -		ret = crypto_aead_setkey(tfm, key, template[i].klen);
 -		if (!ret == template[i].fail) {
 -			pr_err("alg: aead%s: setkey failed on chunk test %d for %s: flags=%x\n",
 -			       d, j, algo, crypto_aead_get_flags(tfm));
 -			goto out;
 -		} else if (ret)
 -			continue;
 +			aead_request_set_assoc(req, asg, template[i].alen);
  
 -		authsize = abs(template[i].rlen - template[i].ilen);
 +			ret = enc ?
 +				crypto_aead_encrypt(req) :
 +				crypto_aead_decrypt(req);
  
 -		ret = -EINVAL;
 -		sg_init_table(sg, template[i].np);
 -		if (diff_dst)
 -			sg_init_table(sgout, template[i].np);
 -		for (k = 0, temp = 0; k < template[i].np; k++) {
 -			if (WARN_ON(offset_in_page(IDX[k]) +
 -				    template[i].tap[k] > PAGE_SIZE))
 +			switch (ret) {
 +			case 0:
 +				if (template[i].novrfy) {
 +					/* verification was supposed to fail */
 +					pr_err("alg: aead%s: %s failed on test %d for %s: ret was 0, expected -EBADMSG\n",
 +					       d, e, j, algo);
 +					/* so really, we got a bad message */
 +					ret = -EBADMSG;
 +					goto out;
 +				}
 +				break;
 +			case -EINPROGRESS:
 +			case -EBUSY:
 +				ret = wait_for_completion_interruptible(
 +					&result.completion);
 +				if (!ret && !(ret = result.err)) {
 +					INIT_COMPLETION(result.completion);
 +					break;
 +				}
 +			case -EBADMSG:
 +				if (template[i].novrfy)
 +					/* verification failure was expected */
 +					continue;
 +				/* fall through */
 +			default:
 +				pr_err("alg: aead%s: %s failed on test %d for %s: ret=%d\n",
 +				       d, e, j, algo, -ret);
  				goto out;
 -
 -			q = xbuf[IDX[k] >> PAGE_SHIFT] + offset_in_page(IDX[k]);
 -			memcpy(q, template[i].input + temp, template[i].tap[k]);
 -			sg_set_buf(&sg[k], q, template[i].tap[k]);
 -
 -			if (diff_dst) {
 -				q = xoutbuf[IDX[k] >> PAGE_SHIFT] +
 -				    offset_in_page(IDX[k]);
 -
 -				memset(q, 0, template[i].tap[k]);
 -
 -				sg_set_buf(&sgout[k], q, template[i].tap[k]);
  			}
  
 -			n = template[i].tap[k];
 -			if (k == template[i].np - 1 && enc)
 -				n += authsize;
 -			if (offset_in_page(q) + n < PAGE_SIZE)
 -				q[n] = 0;
 -
 -			temp += template[i].tap[k];
 -		}
 -
 -		ret = crypto_aead_setauthsize(tfm, authsize);
 -		if (ret) {
 -			pr_err("alg: aead%s: Failed to set authsize to %u on chunk test %d for %s\n",
 -			       d, authsize, j, algo);
 -			goto out;
 -		}
 -
 -		if (enc) {
 -			if (WARN_ON(sg[k - 1].offset +
 -				    sg[k - 1].length + authsize >
 -				    PAGE_SIZE)) {
 +			q = output;
 +			if (memcmp(q, template[i].result, template[i].rlen)) {
 +				pr_err("alg: aead%s: Test %d failed on %s for %s\n",
 +				       d, j, e, algo);
 +				hexdump(q, template[i].rlen);
  				ret = -EINVAL;
  				goto out;
  			}
 -
 -			if (diff_dst)
 -				sgout[k - 1].length += authsize;
 -			else
 -				sg[k - 1].length += authsize;
  		}
 +	}
  
 -		sg_init_table(asg, template[i].anp);
 -		ret = -EINVAL;
 -		for (k = 0, temp = 0; k < template[i].anp; k++) {
 -			if (WARN_ON(offset_in_page(IDX[k]) +
 -				    template[i].atap[k] > PAGE_SIZE))
 +	for (i = 0, j = 0; i < tcount; i++) {
 +		if (template[i].np) {
 +			j++;
 +
 +			if (template[i].iv)
 +				memcpy(iv, template[i].iv, iv_len);
 +			else
 +				memset(iv, 0, MAX_IVLEN);
 +
 +			crypto_aead_clear_flags(tfm, ~0);
 +			if (template[i].wk)
 +				crypto_aead_set_flags(
 +					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 +			key = template[i].key;
 +
 +			ret = crypto_aead_setkey(tfm, key, template[i].klen);
 +			if (!ret == template[i].fail) {
 +				pr_err("alg: aead%s: setkey failed on chunk test %d for %s: flags=%x\n",
 +				       d, j, algo, crypto_aead_get_flags(tfm));
  				goto out;
++<<<<<<< HEAD
 +			} else if (ret)
++=======
+ 			sg_set_buf(&asg[k],
+ 				   memcpy(axbuf[IDX[k] >> PAGE_SHIFT] +
+ 					  offset_in_page(IDX[k]),
+ 					  template[i].assoc + temp,
+ 					  template[i].atap[k]),
+ 				   template[i].atap[k]);
+ 			temp += template[i].atap[k];
+ 		}
+ 
+ 		aead_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,
+ 				       template[i].ilen,
+ 				       iv);
+ 
+ 		aead_request_set_assoc(req, asg, template[i].alen);
+ 
+ 		ret = enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req);
+ 
+ 		switch (ret) {
+ 		case 0:
+ 			if (template[i].novrfy) {
+ 				/* verification was supposed to fail */
+ 				pr_err("alg: aead%s: %s failed on chunk test %d for %s: ret was 0, expected -EBADMSG\n",
+ 				       d, e, j, algo);
+ 				/* so really, we got a bad message */
+ 				ret = -EBADMSG;
+ 				goto out;
+ 			}
+ 			break;
+ 		case -EINPROGRESS:
+ 		case -EBUSY:
+ 			wait_for_completion(&result.completion);
+ 			reinit_completion(&result.completion);
+ 			ret = result.err;
+ 			if (!ret)
+ 				break;
+ 		case -EBADMSG:
+ 			if (template[i].novrfy)
+ 				/* verification failure was expected */
++>>>>>>> 8a45ac12ec5b (crypto: testmgr - don't use interruptible wait in tests)
  				continue;
 -			/* fall through */
 -		default:
 -			pr_err("alg: aead%s: %s failed on chunk test %d for %s: ret=%d\n",
 -			       d, e, j, algo, -ret);
 -			goto out;
 -		}
  
 -		ret = -EINVAL;
 -		for (k = 0, temp = 0; k < template[i].np; k++) {
 +			authsize = abs(template[i].rlen - template[i].ilen);
 +
 +			ret = -EINVAL;
 +			sg_init_table(sg, template[i].np);
  			if (diff_dst)
 -				q = xoutbuf[IDX[k] >> PAGE_SHIFT] +
 -				    offset_in_page(IDX[k]);
 -			else
 +				sg_init_table(sgout, template[i].np);
 +			for (k = 0, temp = 0; k < template[i].np; k++) {
 +				if (WARN_ON(offset_in_page(IDX[k]) +
 +					    template[i].tap[k] > PAGE_SIZE))
 +					goto out;
 +
  				q = xbuf[IDX[k] >> PAGE_SHIFT] +
  				    offset_in_page(IDX[k]);
  
@@@ -883,70 -959,64 +993,124 @@@ static int __test_skcipher(struct crypt
  		else
  			memset(iv, 0, MAX_IVLEN);
  
 -		j++;
 -		ret = -EINVAL;
 -		if (WARN_ON(align_offset + template[i].ilen > PAGE_SIZE))
 -			goto out;
 +		if (!(template[i].np) || (template[i].also_non_np)) {
 +			j++;
  
++<<<<<<< HEAD
++=======
+ 		data = xbuf[0];
+ 		data += align_offset;
+ 		memcpy(data, template[i].input, template[i].ilen);
+ 
+ 		crypto_ablkcipher_clear_flags(tfm, ~0);
+ 		if (template[i].wk)
+ 			crypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_REQ_WEAK_KEY);
+ 
+ 		ret = crypto_ablkcipher_setkey(tfm, template[i].key,
+ 					       template[i].klen);
+ 		if (!ret == template[i].fail) {
+ 			pr_err("alg: skcipher%s: setkey failed on test %d for %s: flags=%x\n",
+ 			       d, j, algo, crypto_ablkcipher_get_flags(tfm));
+ 			goto out;
+ 		} else if (ret)
+ 			continue;
+ 
+ 		sg_init_one(&sg[0], data, template[i].ilen);
+ 		if (diff_dst) {
+ 			data = xoutbuf[0];
+ 			data += align_offset;
+ 			sg_init_one(&sgout[0], data, template[i].ilen);
+ 		}
+ 
+ 		ablkcipher_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,
+ 					     template[i].ilen, iv);
+ 		ret = enc ? crypto_ablkcipher_encrypt(req) :
+ 			    crypto_ablkcipher_decrypt(req);
+ 
+ 		switch (ret) {
+ 		case 0:
+ 			break;
+ 		case -EINPROGRESS:
+ 		case -EBUSY:
+ 			wait_for_completion(&result.completion);
+ 			reinit_completion(&result.completion);
+ 			ret = result.err;
+ 			if (!ret)
+ 				break;
+ 			/* fall through */
+ 		default:
+ 			pr_err("alg: skcipher%s: %s failed on test %d for %s: ret=%d\n",
+ 			       d, e, j, algo, -ret);
+ 			goto out;
+ 		}
+ 
+ 		q = data;
+ 		if (memcmp(q, template[i].result, template[i].rlen)) {
+ 			pr_err("alg: skcipher%s: Test %d failed on %s for %s\n",
+ 			       d, j, e, algo);
+ 			hexdump(q, template[i].rlen);
++>>>>>>> 8a45ac12ec5b (crypto: testmgr - don't use interruptible wait in tests)
  			ret = -EINVAL;
 -			goto out;
 +			if (WARN_ON(template[i].ilen > PAGE_SIZE))
 +				goto out;
 +
 +			data = xbuf[0];
 +			memcpy(data, template[i].input, template[i].ilen);
 +
 +			crypto_ablkcipher_clear_flags(tfm, ~0);
 +			if (template[i].wk)
 +				crypto_ablkcipher_set_flags(
 +					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 +
 +			ret = crypto_ablkcipher_setkey(tfm, template[i].key,
 +						       template[i].klen);
 +			if (!ret == template[i].fail) {
 +				pr_err("alg: skcipher%s: setkey failed on test %d for %s: flags=%x\n",
 +				       d, j, algo,
 +				       crypto_ablkcipher_get_flags(tfm));
 +				goto out;
 +			} else if (ret)
 +				continue;
 +
 +			sg_init_one(&sg[0], data, template[i].ilen);
 +			if (diff_dst) {
 +				data = xoutbuf[0];
 +				sg_init_one(&sgout[0], data, template[i].ilen);
 +			}
 +
 +			ablkcipher_request_set_crypt(req, sg,
 +						     (diff_dst) ? sgout : sg,
 +						     template[i].ilen, iv);
 +			ret = enc ?
 +				crypto_ablkcipher_encrypt(req) :
 +				crypto_ablkcipher_decrypt(req);
 +
 +			switch (ret) {
 +			case 0:
 +				break;
 +			case -EINPROGRESS:
 +			case -EBUSY:
 +				ret = wait_for_completion_interruptible(
 +					&result.completion);
 +				if (!ret && !((ret = result.err))) {
 +					INIT_COMPLETION(result.completion);
 +					break;
 +				}
 +				/* fall through */
 +			default:
 +				pr_err("alg: skcipher%s: %s failed on test %d for %s: ret=%d\n",
 +				       d, e, j, algo, -ret);
 +				goto out;
 +			}
 +
 +			q = data;
 +			if (memcmp(q, template[i].result, template[i].rlen)) {
 +				pr_err("alg: skcipher%s: Test %d failed on %s for %s\n",
 +				       d, j, e, algo);
 +				hexdump(q, template[i].rlen);
 +				ret = -EINVAL;
 +				goto out;
 +			}
  		}
  	}
  
@@@ -958,34 -1034,83 +1122,86 @@@
  		else
  			memset(iv, 0, MAX_IVLEN);
  
 -		j++;
 -		crypto_ablkcipher_clear_flags(tfm, ~0);
 -		if (template[i].wk)
 -			crypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 +		if (template[i].np) {
 +			j++;
  
 -		ret = crypto_ablkcipher_setkey(tfm, template[i].key,
 -					       template[i].klen);
 -		if (!ret == template[i].fail) {
 -			pr_err("alg: skcipher%s: setkey failed on chunk test %d for %s: flags=%x\n",
 -			       d, j, algo, crypto_ablkcipher_get_flags(tfm));
 -			goto out;
 -		} else if (ret)
 -			continue;
 +			crypto_ablkcipher_clear_flags(tfm, ~0);
 +			if (template[i].wk)
 +				crypto_ablkcipher_set_flags(
 +					tfm, CRYPTO_TFM_REQ_WEAK_KEY);
  
 -		temp = 0;
 -		ret = -EINVAL;
 -		sg_init_table(sg, template[i].np);
 -		if (diff_dst)
 -			sg_init_table(sgout, template[i].np);
 -		for (k = 0; k < template[i].np; k++) {
 -			if (WARN_ON(offset_in_page(IDX[k]) +
 -				    template[i].tap[k] > PAGE_SIZE))
 +			ret = crypto_ablkcipher_setkey(tfm, template[i].key,
 +						       template[i].klen);
 +			if (!ret == template[i].fail) {
 +				pr_err("alg: skcipher%s: setkey failed on chunk test %d for %s: flags=%x\n",
 +				       d, j, algo,
 +				       crypto_ablkcipher_get_flags(tfm));
  				goto out;
 +			} else if (ret)
 +				continue;
  
++<<<<<<< HEAD
 +			temp = 0;
 +			ret = -EINVAL;
 +			sg_init_table(sg, template[i].np);
++=======
+ 			q = xbuf[IDX[k] >> PAGE_SHIFT] + offset_in_page(IDX[k]);
+ 
+ 			memcpy(q, template[i].input + temp, template[i].tap[k]);
+ 
+ 			if (offset_in_page(q) + template[i].tap[k] < PAGE_SIZE)
+ 				q[template[i].tap[k]] = 0;
+ 
+ 			sg_set_buf(&sg[k], q, template[i].tap[k]);
+ 			if (diff_dst) {
+ 				q = xoutbuf[IDX[k] >> PAGE_SHIFT] +
+ 				    offset_in_page(IDX[k]);
+ 
+ 				sg_set_buf(&sgout[k], q, template[i].tap[k]);
+ 
+ 				memset(q, 0, template[i].tap[k]);
+ 				if (offset_in_page(q) +
+ 				    template[i].tap[k] < PAGE_SIZE)
+ 					q[template[i].tap[k]] = 0;
+ 			}
+ 
+ 			temp += template[i].tap[k];
+ 		}
+ 
+ 		ablkcipher_request_set_crypt(req, sg, (diff_dst) ? sgout : sg,
+ 					     template[i].ilen, iv);
+ 
+ 		ret = enc ? crypto_ablkcipher_encrypt(req) :
+ 			    crypto_ablkcipher_decrypt(req);
+ 
+ 		switch (ret) {
+ 		case 0:
+ 			break;
+ 		case -EINPROGRESS:
+ 		case -EBUSY:
+ 			wait_for_completion(&result.completion);
+ 			reinit_completion(&result.completion);
+ 			ret = result.err;
+ 			if (!ret)
+ 				break;
+ 			/* fall through */
+ 		default:
+ 			pr_err("alg: skcipher%s: %s failed on chunk test %d for %s: ret=%d\n",
+ 			       d, e, j, algo, -ret);
+ 			goto out;
+ 		}
+ 
+ 		temp = 0;
+ 		ret = -EINVAL;
+ 		for (k = 0; k < template[i].np; k++) {
++>>>>>>> 8a45ac12ec5b (crypto: testmgr - don't use interruptible wait in tests)
  			if (diff_dst)
 -				q = xoutbuf[IDX[k] >> PAGE_SHIFT] +
 -				    offset_in_page(IDX[k]);
 -			else
 +				sg_init_table(sgout, template[i].np);
 +			for (k = 0; k < template[i].np; k++) {
 +				if (WARN_ON(offset_in_page(IDX[k]) +
 +					    template[i].tap[k] > PAGE_SIZE))
 +					goto out;
 +
  				q = xbuf[IDX[k] >> PAGE_SHIFT] +
  				    offset_in_page(IDX[k]);
  
* Unmerged path crypto/tcrypt.c
* Unmerged path crypto/testmgr.c
