scsi: be2iscsi: Fix queue and connection parameters

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
Rebuild_CHGLOG: - [scsi] be2iscsi: Fix queue and connection parameters (Maurizio Lombardi) [1382263]
Rebuild_FUZZ: 93.75%
commit-author Jitendra Bhivare <jitendra.bhivare@broadcom.com>
commit 1b7a7ddceee5559a15c4c93020d7dcd9862babed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/1b7a7ddc.failed

Current EQ delay is set to 0 to receive very high max interrupt per sec.
Set EQ delay to 32 - reducing max interrupt rate from 65K to 20K per sec.

Set TCP connection window size to 64K with scale shift count 2.

	Signed-off-by: Jitendra Bhivare <jitendra.bhivare@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 1b7a7ddceee5559a15c4c93020d7dcd9862babed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/be2iscsi/be_main.c
diff --cc drivers/scsi/be2iscsi/be_main.c
index 8e3a0f9d2ac4,7c372b8e7dd5..000000000000
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@@ -3832,18 -3619,125 +3832,23 @@@ static int hwi_init_port(struct beiscsi
  
  	phwi_ctrlr = phba->phwi_ctrlr;
  	phwi_context = phwi_ctrlr->phwi_ctxt;
 -	if (phba->msix_enabled)
 -		eq_msix = 1;
 -	else
 -		eq_msix = 0;
 -
 -	for (i = 0; i < (phba->num_cpus + eq_msix); i++) {
 -		eq = &phwi_context->be_eq[i].q;
 -		eqe = queue_tail_node(eq);
 -		num_processed = 0;
 -		while (eqe->dw[offsetof(struct amap_eq_entry, valid) / 32]
 -					& EQE_VALID_MASK) {
 -			AMAP_SET_BITS(struct amap_eq_entry, valid, eqe, 0);
 -			queue_tail_inc(eq);
 -			eqe = queue_tail_node(eq);
 -			num_processed++;
 -		}
 +	phwi_context->max_eqd = 128;
 +	phwi_context->min_eqd = 0;
++<<<<<<< HEAD
 +	phwi_context->cur_eqd = 0;
 +	be_cmd_fw_initialize(&phba->ctrl);
 +	/* set optic state to unknown */
++=======
++	phwi_context->cur_eqd = 32;
++	/* set port optic state to unknown */
++>>>>>>> 1b7a7ddceee5 (scsi: be2iscsi: Fix queue and connection parameters)
 +	phba->optic_state = 0xff;
  
 -		if (num_processed)
 -			hwi_ring_eq_db(phba, eq->id, 1,	num_processed, 1, 1);
 -	}
 -}
 -
 -static void hwi_cleanup_port(struct beiscsi_hba *phba)
 -{
 -	struct be_queue_info *q;
 -	struct be_ctrl_info *ctrl = &phba->ctrl;
 -	struct hwi_controller *phwi_ctrlr;
 -	struct hwi_context_memory *phwi_context;
 -	struct hd_async_context *pasync_ctx;
 -	int i, eq_for_mcc, ulp_num;
 -
 -	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)
 -		if (test_bit(ulp_num, &phba->fw_config.ulp_supported))
 -			beiscsi_cmd_iscsi_cleanup(phba, ulp_num);
 -
 -	/**
 -	 * Purge all EQ entries that may have been left out. This is to
 -	 * workaround a problem we've seen occasionally where driver gets an
 -	 * interrupt with EQ entry bit set after stopping the controller.
 -	 */
 -	hwi_purge_eq(phba);
 -
 -	phwi_ctrlr = phba->phwi_ctrlr;
 -	phwi_context = phwi_ctrlr->phwi_ctxt;
 -
 -	be_cmd_iscsi_remove_template_hdr(ctrl);
 -
 -	for (i = 0; i < phba->params.cxns_per_ctrl; i++) {
 -		q = &phwi_context->be_wrbq[i];
 -		if (q->created)
 -			beiscsi_cmd_q_destroy(ctrl, q, QTYPE_WRBQ);
 -	}
 -	kfree(phwi_context->be_wrbq);
 -	free_wrb_handles(phba);
 -
 -	for (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {
 -		if (test_bit(ulp_num, &phba->fw_config.ulp_supported)) {
 -
 -			q = &phwi_context->be_def_hdrq[ulp_num];
 -			if (q->created)
 -				beiscsi_cmd_q_destroy(ctrl, q, QTYPE_DPDUQ);
 -
 -			q = &phwi_context->be_def_dataq[ulp_num];
 -			if (q->created)
 -				beiscsi_cmd_q_destroy(ctrl, q, QTYPE_DPDUQ);
 -
 -			pasync_ctx = phwi_ctrlr->phwi_ctxt->pasync_ctx[ulp_num];
 -		}
 -	}
 -
 -	beiscsi_cmd_q_destroy(ctrl, NULL, QTYPE_SGL);
 -
 -	for (i = 0; i < (phba->num_cpus); i++) {
 -		q = &phwi_context->be_cq[i];
 -		if (q->created) {
 -			be_queue_free(phba, q);
 -			beiscsi_cmd_q_destroy(ctrl, q, QTYPE_CQ);
 -		}
 -	}
 -
 -	be_mcc_queues_destroy(phba);
 -	if (phba->msix_enabled)
 -		eq_for_mcc = 1;
 -	else
 -		eq_for_mcc = 0;
 -	for (i = 0; i < (phba->num_cpus + eq_for_mcc); i++) {
 -		q = &phwi_context->be_eq[i].q;
 -		if (q->created) {
 -			be_queue_free(phba, q);
 -			beiscsi_cmd_q_destroy(ctrl, q, QTYPE_EQ);
 -		}
 -	}
 -	/* this ensures complete FW cleanup */
 -	beiscsi_cmd_function_reset(phba);
 -	/* last communication, indicate driver is unloading */
 -	beiscsi_cmd_special_wrb(&phba->ctrl, 0);
 -}
 -
 -static int hwi_init_port(struct beiscsi_hba *phba)
 -{
 -	struct hwi_controller *phwi_ctrlr;
 -	struct hwi_context_memory *phwi_context;
 -	unsigned int def_pdu_ring_sz;
 -	struct be_ctrl_info *ctrl = &phba->ctrl;
 -	int status, ulp_num;
 -
 -	phwi_ctrlr = phba->phwi_ctrlr;
 -	phwi_context = phwi_ctrlr->phwi_ctxt;
 -	phwi_context->max_eqd = 128;
 -	phwi_context->min_eqd = 0;
 -	phwi_context->cur_eqd = 32;
 -	/* set port optic state to unknown */
 -	phba->optic_state = 0xff;
 -
 -	status = beiscsi_create_eqs(phba, phwi_context);
 -	if (status != 0) {
 -		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 -			    "BM_%d : EQ not created\n");
 -		goto error;
 +	status = beiscsi_create_eqs(phba, phwi_context);
 +	if (status != 0) {
 +		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 +			    "BM_%d : EQ not created\n");
 +		goto error;
  	}
  
  	status = be_mcc_queues_create(phba, phwi_context);
* Unmerged path drivers/scsi/be2iscsi/be_main.c
diff --git a/drivers/scsi/be2iscsi/be_mgmt.c b/drivers/scsi/be2iscsi/be_mgmt.c
index fa17b8e5a47c..8728d132f1ba 100644
--- a/drivers/scsi/be2iscsi/be_mgmt.c
+++ b/drivers/scsi/be2iscsi/be_mgmt.c
@@ -883,7 +883,7 @@ int mgmt_open_connection(struct beiscsi_hba *phba,
 
 	if (!is_chip_be2_be3r(phba)) {
 		req->hdr.version = MBX_CMD_VER1;
-		req->tcp_window_size = 0;
+		req->tcp_window_size = 0x8000;
 		req->tcp_window_scale_count = 2;
 	}
 
