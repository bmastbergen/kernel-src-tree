nvme: Add tertiary number to NVME_VS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Gabriel Krisman Bertazi <krisman@linux.vnet.ibm.com>
commit 8ef2074d28373014d05e92b5f13364ef51075b6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/8ef2074d.failed

NVMe 1.2.1 specification adds a tertiary element to the version number.
This updates the macro and its callers to include the final number and
fixup a single place in nvmet where the version was generated manually.

	Signed-off-by: Gabriel Krisman Bertazi <krisman@linux.vnet.ibm.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 8ef2074d28373014d05e92b5f13364ef51075b6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
#	drivers/nvme/host/pci.c
#	drivers/nvme/target/core.c
diff --cc drivers/nvme/host/core.c
index 0588703d149f,bb168b71048d..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -597,10 -900,20 +597,27 @@@ static int nvme_revalidate_disk(struct 
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	if (ns->ctrl->vs >= NVME_VS(1, 1))
 +		memcpy(ns->eui, id->eui64, sizeof(ns->eui));
 +	if (ns->ctrl->vs >= NVME_VS(1, 2))
 +		memcpy(ns->uuid, id->nguid, sizeof(ns->uuid));
++=======
+ 	if (ns->ctrl->vs >= NVME_VS(1, 1, 0))
+ 		memcpy(ns->eui, (*id)->eui64, sizeof(ns->eui));
+ 	if (ns->ctrl->vs >= NVME_VS(1, 2, 0))
+ 		memcpy(ns->uuid, (*id)->nguid, sizeof(ns->uuid));
+ 
+ 	return 0;
+ }
+ 
+ static void __nvme_revalidate_disk(struct gendisk *disk, struct nvme_id_ns *id)
+ {
+ 	struct nvme_ns *ns = disk->private_data;
+ 	u8 lbaf, pi_type;
+ 	u16 old_ms;
+ 	unsigned short bs;
++>>>>>>> 8ef2074d2837 (nvme: Add tertiary number to NVME_VS)
  
  	old_ms = ns->ms;
  	lbaf = id->flbas & NVME_NS_FLBAS_LBA_MASK;
@@@ -1375,9 -1838,11 +1392,9 @@@ void nvme_scan_namespaces(struct nvme_c
  	if (nvme_identify_ctrl(ctrl, &id))
  		return;
  
 +	mutex_lock(&ctrl->namespaces_mutex);
  	nn = le32_to_cpu(id->nn);
- 	if (ctrl->vs >= NVME_VS(1, 1) &&
+ 	if (ctrl->vs >= NVME_VS(1, 1, 0) &&
  	    !(ctrl->quirks & NVME_QUIRK_IDENTIFY_CNS)) {
  		if (!nvme_scan_ns_list(ctrl, nn))
  			goto done;
diff --cc drivers/nvme/host/pci.c
index 3dc63da6bd14,26a8d31b291d..000000000000
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@@ -1665,9 -1613,37 +1665,33 @@@ static int nvme_pci_enable(struct nvme_
  	dev->q_depth = min_t(int, NVME_CAP_MQES(cap) + 1, NVME_Q_DEPTH);
  	dev->db_stride = 1 << NVME_CAP_STRIDE(cap);
  	dev->dbs = dev->bar + 4096;
++<<<<<<< HEAD
 +	if (readl(dev->bar + NVME_REG_VS) >= NVME_VS(1, 2))
++=======
+ 
+ 	/*
+ 	 * Temporary fix for the Apple controller found in the MacBook8,1 and
+ 	 * some MacBook7,1 to avoid controller resets and data loss.
+ 	 */
+ 	if (pdev->vendor == PCI_VENDOR_ID_APPLE && pdev->device == 0x2001) {
+ 		dev->q_depth = 2;
+ 		dev_warn(dev->dev, "detected Apple NVMe controller, set "
+ 			"queue depth=%u to work around controller resets\n",
+ 			dev->q_depth);
+ 	}
+ 
+ 	/*
+ 	 * CMBs can currently only exist on >=1.2 PCIe devices. We only
+ 	 * populate sysfs if a CMB is implemented. Note that we add the
+ 	 * CMB attribute to the nvme_ctrl kobj which removes the need to remove
+ 	 * it on exit. Since nvme_dev_attrs_group has no name we can pass
+ 	 * NULL as final argument to sysfs_add_file_to_group.
+ 	 */
+ 
+ 	if (readl(dev->bar + NVME_REG_VS) >= NVME_VS(1, 2, 0)) {
++>>>>>>> 8ef2074d2837 (nvme: Add tertiary number to NVME_VS)
  		dev->cmb = nvme_map_cmb(dev);
  
 -		if (dev->cmbsz) {
 -			if (sysfs_add_file_to_group(&dev->ctrl.device->kobj,
 -						    &dev_attr_cmb.attr, NULL))
 -				dev_warn(dev->dev,
 -					 "failed to add sysfs attribute for CMB\n");
 -		}
 -	}
 -
  	pci_enable_pcie_error_reporting(pdev);
  	pci_save_state(pdev);
  	return 0;
* Unmerged path drivers/nvme/target/core.c
* Unmerged path drivers/nvme/host/core.c
* Unmerged path drivers/nvme/host/pci.c
diff --git a/drivers/nvme/host/scsi.c b/drivers/nvme/host/scsi.c
index 44009105f8c8..7e6f83e47490 100644
--- a/drivers/nvme/host/scsi.c
+++ b/drivers/nvme/host/scsi.c
@@ -606,7 +606,7 @@ static int nvme_fill_device_id_eui64(struct nvme_ns *ns, struct sg_io_hdr *hdr,
 	eui = id_ns->eui64;
 	len = sizeof(id_ns->eui64);
 
-	if (ns->ctrl->vs >= NVME_VS(1, 2)) {
+	if (ns->ctrl->vs >= NVME_VS(1, 2, 0)) {
 		if (bitmap_empty(eui, len * 8)) {
 			eui = id_ns->nguid;
 			len = sizeof(id_ns->nguid);
@@ -679,7 +679,7 @@ static int nvme_trans_device_id_page(struct nvme_ns *ns, struct sg_io_hdr *hdr,
 {
 	int res;
 
-	if (ns->ctrl->vs >= NVME_VS(1, 1)) {
+	if (ns->ctrl->vs >= NVME_VS(1, 1, 0)) {
 		res = nvme_fill_device_id_eui64(ns, hdr, resp, alloc_len);
 		if (res != -EOPNOTSUPP)
 			return res;
* Unmerged path drivers/nvme/target/core.c
diff --git a/include/linux/nvme.h b/include/linux/nvme.h
index 69a54c418685..e5ff1328deda 100644
--- a/include/linux/nvme.h
+++ b/include/linux/nvme.h
@@ -656,6 +656,7 @@ struct nvme_completion {
 	__le16	status;		/* did the command fail, and if so, why? */
 };
 
-#define NVME_VS(major, minor) (((major) << 16) | ((minor) << 8))
+#define NVME_VS(major, minor, tertiary) \
+	(((major) << 16) | ((minor) << 8) | (tertiary))
 
 #endif /* _LINUX_NVME_H */
