nfp: allocate irqs in lower driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-693.el7
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit fdace6c224e9fc0e81337b6fee3cfd136824c983
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-693.el7/fdace6c2.failed

PF services multiple ports using single PCI device therefore
IRQs can no longer be allocated in the netdev code.  Lower
portion of the driver has to allocate the IRQs and hand them
out to ports.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fdace6c224e9fc0e81337b6fee3cfd136824c983)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/netronome/nfp/nfp_net.h
#	drivers/net/ethernet/netronome/nfp/nfp_net_common.c
#	drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net.h
index aecadca0b473,ef031010ae09..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net.h
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net.h
@@@ -333,7 -345,8 +334,12 @@@ struct nfp_net_rx_ring 
   * @napi:           NAPI structure for this ring vec
   * @tx_ring:        Pointer to TX ring
   * @rx_ring:        Pointer to RX ring
++<<<<<<< HEAD
 + * @irq_idx:        Index into MSI-X table
++=======
+  * @xdp_ring:	    Pointer to an extra TX ring for XDP
+  * @irq_entry:      MSI-X table entry (use for talking to the device)
++>>>>>>> fdace6c224e9 (nfp: allocate irqs in lower driver)
   * @rx_sync:	    Seqlock for atomic updates of RX stats
   * @rx_pkts:        Number of received packets
   * @rx_bytes:	    Number of received bytes
@@@ -732,15 -791,24 +740,29 @@@ int nfp_net_reconfig(struct nfp_net *nn
  void nfp_net_rss_write_itbl(struct nfp_net *nn);
  void nfp_net_rss_write_key(struct nfp_net *nn);
  void nfp_net_coalesce_write_cfg(struct nfp_net *nn);
++<<<<<<< HEAD
 +int nfp_net_irqs_alloc(struct nfp_net *nn);
 +void nfp_net_irqs_disable(struct nfp_net *nn);
 +int nfp_net_set_ring_size(struct nfp_net *nn, u32 rxd_cnt, u32 txd_cnt);
++=======
+ 
+ unsigned int
+ nfp_net_irqs_alloc(struct pci_dev *pdev, struct msix_entry *irq_entries,
+ 		   unsigned int min_irqs, unsigned int want_irqs);
+ void nfp_net_irqs_disable(struct pci_dev *pdev);
+ void
+ nfp_net_irqs_assign(struct nfp_net *nn, struct msix_entry *irq_entries,
+ 		    unsigned int n);
+ int
+ nfp_net_ring_reconfig(struct nfp_net *nn, struct bpf_prog **xdp_prog,
+ 		      struct nfp_net_ring_set *rx, struct nfp_net_ring_set *tx);
++>>>>>>> fdace6c224e9 (nfp: allocate irqs in lower driver)
  
 -#ifdef CONFIG_NFP_DEBUG
 +#ifdef CONFIG_NFP_NET_DEBUG
  void nfp_net_debugfs_create(void);
  void nfp_net_debugfs_destroy(void);
 -struct dentry *nfp_net_debugfs_device_add(struct pci_dev *pdev);
 -void nfp_net_debugfs_port_add(struct nfp_net *nn, struct dentry *ddir, int id);
 -void nfp_net_debugfs_dir_clean(struct dentry **dir);
 +void nfp_net_debugfs_adapter_add(struct nfp_net *nn);
 +void nfp_net_debugfs_adapter_del(struct nfp_net *nn);
  #else
  static inline void nfp_net_debugfs_create(void)
  {
diff --cc drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 2a625a67a222,074259cc8e06..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@@ -290,81 -281,65 +290,139 @@@ static void nfp_net_irq_unmask(struct n
  }
  
  /**
++<<<<<<< HEAD
 + * nfp_net_msix_alloc() - Try to allocate MSI-X irqs
 + * @nn:       NFP Network structure
 + * @nr_vecs:  Number of MSI-X vectors to allocate
 + *
 + * For MSI-X we want at least NFP_NET_NON_Q_VECTORS + 1 vectors.
 + *
 + * Return: Number of MSI-X vectors obtained or 0 on error.
 + */
 +static int nfp_net_msix_alloc(struct nfp_net *nn, int nr_vecs)
 +{
 +	struct pci_dev *pdev = nn->pdev;
 +	int nvecs;
 +	int i;
 +
 +	for (i = 0; i < nr_vecs; i++)
 +		nn->irq_entries[i].entry = i;
 +
 +	nvecs = pci_enable_msix_range(pdev, nn->irq_entries,
 +				      NFP_NET_NON_Q_VECTORS + 1, nr_vecs);
 +	if (nvecs < 0) {
 +		nn_warn(nn, "Failed to enable MSI-X. Wanted %d-%d (err=%d)\n",
 +			NFP_NET_NON_Q_VECTORS + 1, nr_vecs, nvecs);
 +		return 0;
 +	}
 +
 +	return nvecs;
 +}
 +
 +/**
 + * nfp_net_irqs_wanted() - Work out how many interrupt vectors we want
 + * @nn:       NFP Network structure
 + *
 + * We want a vector per CPU (or ring), whatever is smaller plus
 + * NFP_NET_NON_Q_VECTORS for LSC etc.
 + *
 + * Return: Number of interrupts wanted
 + */
 +static int nfp_net_irqs_wanted(struct nfp_net *nn)
 +{
 +	int ncpus;
 +	int vecs;
 +
 +	ncpus = num_online_cpus();
 +
 +	vecs = max_t(int, nn->num_tx_rings, nn->num_rx_rings);
 +	vecs = min_t(int, vecs, ncpus);
 +
 +	return vecs + NFP_NET_NON_Q_VECTORS;
 +}
 +
 +/**
++=======
++>>>>>>> fdace6c224e9 (nfp: allocate irqs in lower driver)
   * nfp_net_irqs_alloc() - allocates MSI-X irqs
-  * @nn:       NFP Network structure
+  * @pdev:        PCI device structure
+  * @irq_entries: Array to be initialized and used to hold the irq entries
+  * @min_irqs:    Minimal acceptable number of interrupts
+  * @wanted_irqs: Target number of interrupts to allocate
   *
   * Return: Number of irqs obtained or 0 on error.
   */
- int nfp_net_irqs_alloc(struct nfp_net *nn)
+ unsigned int
+ nfp_net_irqs_alloc(struct pci_dev *pdev, struct msix_entry *irq_entries,
+ 		   unsigned int min_irqs, unsigned int wanted_irqs)
  {
++<<<<<<< HEAD
 +	int wanted_irqs;
 +
 +	wanted_irqs = nfp_net_irqs_wanted(nn);
 +
 +	nn->num_irqs = nfp_net_msix_alloc(nn, wanted_irqs);
 +	if (nn->num_irqs == 0) {
 +		nn_err(nn, "Failed to allocate MSI-X IRQs\n");
 +		return 0;
 +	}
 +
 +	nn->num_r_vecs = nn->num_irqs - NFP_NET_NON_Q_VECTORS;
 +
 +	if (nn->num_irqs < wanted_irqs)
 +		nn_warn(nn, "Unable to allocate %d vectors. Got %d instead\n",
 +			wanted_irqs, nn->num_irqs);
 +
 +	return nn->num_irqs;
++=======
+ 	unsigned int i;
+ 	int got_irqs;
+ 
+ 	for (i = 0; i < wanted_irqs; i++)
+ 		irq_entries[i].entry = i;
+ 
+ 	got_irqs = pci_enable_msix_range(pdev, irq_entries,
+ 					 min_irqs, wanted_irqs);
+ 	if (got_irqs < 0) {
+ 		dev_err(&pdev->dev, "Failed to enable %d-%d MSI-X (err=%d)\n",
+ 			min_irqs, wanted_irqs, got_irqs);
+ 		return 0;
+ 	}
+ 
+ 	if (got_irqs < wanted_irqs)
+ 		dev_warn(&pdev->dev, "Unable to allocate %d IRQs got only %d\n",
+ 			 wanted_irqs, got_irqs);
+ 
+ 	return got_irqs;
+ }
+ 
+ /**
+  * nfp_net_irqs_assign() - Assign interrupts allocated externally to netdev
+  * @nn:		 NFP Network structure
+  * @irq_entries: Table of allocated interrupts
+  * @n:		 Size of @irq_entries (number of entries to grab)
+  *
+  * After interrupts are allocated with nfp_net_irqs_alloc() this function
+  * should be called to assign them to a specific netdev (port).
+  */
+ void
+ nfp_net_irqs_assign(struct nfp_net *nn, struct msix_entry *irq_entries,
+ 		    unsigned int n)
+ {
+ 	nn->max_r_vecs = n - NFP_NET_NON_Q_VECTORS;
+ 	nn->num_r_vecs = nn->max_r_vecs;
+ 
+ 	memcpy(nn->irq_entries, irq_entries, sizeof(*irq_entries) * n);
+ 
+ 	if (nn->num_rx_rings > nn->num_r_vecs ||
+ 	    nn->num_tx_rings > nn->num_r_vecs)
+ 		nn_warn(nn, "More rings (%d,%d) than vectors (%d).\n",
+ 			nn->num_rx_rings, nn->num_tx_rings, nn->num_r_vecs);
+ 
+ 	nn->num_rx_rings = min(nn->num_r_vecs, nn->num_rx_rings);
+ 	nn->num_tx_rings = min(nn->num_r_vecs, nn->num_tx_rings);
+ 	nn->num_stack_tx_rings = nn->num_tx_rings;
++>>>>>>> fdace6c224e9 (nfp: allocate irqs in lower driver)
  }
  
  /**
@@@ -514,18 -492,14 +575,29 @@@ static void nfp_net_vecs_init(struct ne
  	struct nfp_net_r_vector *r_vec;
  	int r;
  
++<<<<<<< HEAD
 +	if (nn->num_rx_rings > nn->num_r_vecs ||
 +	    nn->num_tx_rings > nn->num_r_vecs)
 +		nn_warn(nn, "More rings (%d,%d) than vectors (%d).\n",
 +			nn->num_rx_rings, nn->num_tx_rings, nn->num_r_vecs);
 +
 +	nn->num_rx_rings = min(nn->num_r_vecs, nn->num_rx_rings);
 +	nn->num_tx_rings = min(nn->num_r_vecs, nn->num_tx_rings);
 +
 +	nn->lsc_handler = nfp_net_irq_lsc;
 +	nn->exn_handler = nfp_net_irq_exn;
 +
 +	for (r = 0; r < nn->num_r_vecs; r++) {
++=======
+ 	nn->lsc_handler = nfp_net_irq_lsc;
+ 	nn->exn_handler = nfp_net_irq_exn;
+ 
+ 	for (r = 0; r < nn->max_r_vecs; r++) {
+ 		struct msix_entry *entry;
+ 
+ 		entry = &nn->irq_entries[NFP_NET_NON_Q_VECTORS + r];
+ 
++>>>>>>> fdace6c224e9 (nfp: allocate irqs in lower driver)
  		r_vec = &nn->r_vecs[r];
  		r_vec->nfp_net = nn;
  		r_vec->handler = nfp_net_irq_rxtx;
@@@ -1727,39 -1991,27 +1800,49 @@@ static in
  nfp_net_prepare_vector(struct nfp_net *nn, struct nfp_net_r_vector *r_vec,
  		       int idx)
  {
- 	struct msix_entry *entry = &nn->irq_entries[r_vec->irq_idx];
  	int err;
  
 -	/* Setup NAPI */
 -	netif_napi_add(nn->netdev, &r_vec->napi,
 -		       nfp_net_poll, NAPI_POLL_WEIGHT);
 +	if (idx < nn->num_tx_rings) {
 +		r_vec->tx_ring = &nn->tx_rings[idx];
 +		nfp_net_tx_ring_init(r_vec->tx_ring, r_vec, idx);
 +	} else {
 +		r_vec->tx_ring = NULL;
 +	}
 +
 +	if (idx < nn->num_rx_rings) {
 +		r_vec->rx_ring = &nn->rx_rings[idx];
 +		nfp_net_rx_ring_init(r_vec->rx_ring, r_vec, idx);
 +	} else {
 +		r_vec->rx_ring = NULL;
 +	}
  
  	snprintf(r_vec->name, sizeof(r_vec->name),
  		 "%s-rxtx-%d", nn->netdev->name, idx);
- 	err = request_irq(entry->vector, r_vec->handler, 0, r_vec->name, r_vec);
+ 	err = request_irq(r_vec->irq_vector, r_vec->handler, 0, r_vec->name,
+ 			  r_vec);
  	if (err) {
++<<<<<<< HEAD
 +		nn_err(nn, "Error requesting IRQ %d\n", entry->vector);
++=======
+ 		netif_napi_del(&r_vec->napi);
+ 		nn_err(nn, "Error requesting IRQ %d\n", r_vec->irq_vector);
++>>>>>>> fdace6c224e9 (nfp: allocate irqs in lower driver)
  		return err;
  	}
- 	disable_irq(entry->vector);
+ 	disable_irq(r_vec->irq_vector);
  
++<<<<<<< HEAD
 +	/* Setup NAPI */
 +	netif_napi_add(nn->netdev, &r_vec->napi,
 +		       nfp_net_poll, NAPI_POLL_WEIGHT);
 +
 +	irq_set_affinity_hint(entry->vector, &r_vec->affinity_mask);
++=======
+ 	irq_set_affinity_hint(r_vec->irq_vector, &r_vec->affinity_mask);
++>>>>>>> fdace6c224e9 (nfp: allocate irqs in lower driver)
  
- 	nn_dbg(nn, "RV%02d: irq=%03d/%03d\n", idx, entry->vector, entry->entry);
+ 	nn_dbg(nn, "RV%02d: irq=%03d/%03d\n", idx, r_vec->irq_vector,
+ 	       r_vec->irq_entry);
  
  	return 0;
  }
diff --cc drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
index f7062cb648e1,39407f7cc586..000000000000
--- a/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
@@@ -45,9 -45,27 +45,27 @@@
  
  #include "nfp_net_ctrl.h"
  #include "nfp_net.h"
+ #include "nfp_main.h"
+ 
+ /**
+  * struct nfp_net_vf - NFP VF-specific device structure
+  * @nn:		NFP Net structure for this device
+  * @irq_entries: Pre-allocated array of MSI-X entries
+  * @q_bar:	Pointer to mapped QC memory (NULL if TX/RX mapped directly)
+  * @ddir:	Per-device debugfs directory
+  */
+ struct nfp_net_vf {
+ 	struct nfp_net *nn;
+ 
+ 	struct msix_entry irq_entries[NFP_NET_NON_Q_VECTORS +
+ 				      NFP_NET_MAX_TX_RINGS];
+ 	u8 __iomem *q_bar;
+ 
+ 	struct dentry *ddir;
+ };
  
 -static const char nfp_net_driver_name[] = "nfp_netvf";
 -
 +const char nfp_net_driver_name[] = "nfp_netvf";
 +const char nfp_net_driver_version[] = "0.1";
  #define PCI_DEVICE_NFP6000VF		0x6003
  static const struct pci_device_id nfp_netvf_pci_device_ids[] = {
  	{ PCI_VENDOR_ID_NETRONOME, PCI_DEVICE_NFP6000VF,
@@@ -84,9 -100,10 +102,11 @@@ static int nfp_netvf_pci_probe(struct p
  	u32 tx_bar_off, rx_bar_off;
  	u32 tx_bar_sz, rx_bar_sz;
  	int tx_bar_no, rx_bar_no;
+ 	struct nfp_net_vf *vf;
+ 	unsigned int num_irqs;
  	u8 __iomem *ctrl_bar;
  	struct nfp_net *nn;
 +	int is_nfp3200;
  	u32 startq;
  	int stride;
  	int err;
@@@ -286,10 -286,9 +315,13 @@@
  	if (err)
  		goto err_irqs_disable;
  
- 	pci_set_drvdata(pdev, nn);
- 
  	nfp_net_info(nn);
++<<<<<<< HEAD
 +	nfp_net_debugfs_adapter_add(nn);
++=======
+ 	vf->ddir = nfp_net_debugfs_device_add(pdev);
+ 	nfp_net_debugfs_port_add(nn, vf->ddir, 0);
++>>>>>>> fdace6c224e9 (nfp: allocate irqs in lower driver)
  
  	return 0;
  
@@@ -322,7 -324,8 +357,12 @@@ static void nfp_netvf_pci_remove(struc
  	/* Note, the order is slightly different from above as we need
  	 * to keep the nn pointer around till we have freed everything.
  	 */
++<<<<<<< HEAD
 +	nfp_net_debugfs_adapter_del(nn);
++=======
+ 	nfp_net_debugfs_dir_clean(&nn->debugfs_dir);
+ 	nfp_net_debugfs_dir_clean(&vf->ddir);
++>>>>>>> fdace6c224e9 (nfp: allocate irqs in lower driver)
  
  	nfp_net_netdev_clean(nn->netdev);
  
@@@ -342,9 -343,12 +380,12 @@@
  
  	pci_release_regions(pdev);
  	pci_disable_device(pdev);
+ 
+ 	pci_set_drvdata(pdev, NULL);
+ 	kfree(vf);
  }
  
 -struct pci_driver nfp_netvf_pci_driver = {
 +static struct pci_driver nfp_netvf_pci_driver = {
  	.name        = nfp_net_driver_name,
  	.id_table    = nfp_netvf_pci_device_ids,
  	.probe       = nfp_netvf_pci_probe,
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net.h
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_net_common.c
* Unmerged path drivers/net/ethernet/netronome/nfp/nfp_netvf_main.c
